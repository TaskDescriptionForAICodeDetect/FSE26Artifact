[
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace __gnu_pbds;\nusing namespace std;\n \ntemplate <typename T>\nusing ordered_set =\n\ttree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n \n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n\t*this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n \n#define shandom_ruffle random_shuffle\n \nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=327;\nusing bn=bitset<87>;\nusing ld=long double;\n\nint n;\npii gdz[nax];\nll war[nax];\n\nint m;\nbn podz[nax];\nint ile[nax];\n\nll wyn;\n\nbn ter;\n \nll dajwar()\n{\n\tll ret=0;\n\tfor (int i=1; i<=n; i++)\n\t\tif (ter[i])\n\t\t\tret+=war[i];\n\treturn ret;\n}\n \nint popr()\n{\n\tfor (int i=1; i<=m; i++)\n\t\tif ((podz[i]&ter).count()>ile[i])\n\t\t\treturn 0;\n\treturn 1;\n}\n\nvi kol;\n\nstruct Simplex {        // Maximize c*x subject to Ax <= b.\n  using T = ld;     // Initialize the structure, set A, b, c and then run\n  vector<vector<T>> A;  // solve(). Max objective is stored in res. To recover\n  vector<T> b, c;       // the best result, use getVars().\n  int V, E;\n  vector<int> eqIds, varIds, cols;\n  T res;\n  static constexpr T kEps = 1e-8;\n\n  Simplex(int vars, int eqs) : A(eqs, vector<T>(vars)), b(eqs), c(vars),\n      V(vars), E(eqs), eqIds(eqs), varIds(vars), res(0) {\n    iota(varIds.begin(), varIds.end(), 0);\n    iota(eqIds.begin(), eqIds.end(), vars);\n  }\n\n  void pivot(int eq, int var) {\n    T coef = 1 / A[eq][var];\n    cols.clear();\n    for (int i = 0; i < V; i++) {\n      if (abs(A[eq][i]) > kEps) { cols.push_back(i); A[eq][i] *= coef; }\n    }\n    A[eq][var] *= coef; b[eq] *= coef;\n    for (int row = 0; row < E; row++) {\n      if (row == eq || abs(A[row][var]) < kEps) { continue; }\n      T k = -A[row][var];\n      A[row][var] = 0;\n      for (int i : cols) { A[row][i] += k * A[eq][i]; }\n      b[row] += k * b[eq];\n    }\n    T q = c[var]; c[var] = 0;\n    for (int i : cols) { c[i] -= q * A[eq][i]; }\n    res += q * b[eq];\n    swap(varIds[var], eqIds[eq]);\n  }\n\n  bool solve() {\n    while (true) {\n      int eq = -1, var = -1;\n      for (int i = 0; i < E; i++) { if (b[i] < -kEps) { eq = i; break; } }\n      if (eq == -1) { break; }\n      for (int i = 0; i < V; i++) { if (A[eq][i] < -kEps) { var = i; break; } }\n      if (var == -1) { res = -1e9; return false; /* No solution */ }\n      pivot(eq, var);\n    }\n    while (true) {\n      int var = -1, eq = -1;\n      for (int i = 0; i < V; i++) { if (c[i] > kEps) { var = i; break; } }\n      if (var == -1) { break; }\n      for (int i = 0; i < E; i++) {\n        if (A[i][var] < kEps) { continue; }\n        if (eq >= 0 && b[i] / A[i][var] >= b[eq] / A[eq][var]) { continue; }\n        eq = i;\n      }\n      if (eq == -1) { res = 1e9; return false; /* Unbounded */ }\n      pivot(eq, var);\n    }\n    return true;\n  }\n\n  vector<T> getVars() { // Optimal assignment of variables.\n    vector<T> result(V);\n    for (int i = 0; i < E; i++) if (eqIds[i] < V) result[eqIds[i]] = b[i];\n    return result;\n  }\n};\n\nvoid zmien(ld &v)\n{\n\tv*=(800+(rand()%401))/1000.0;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(\"%d%d%lld\", &gdz[i].first, &gdz[i].second, &war[i]);\n\tscanf(\"%d\", &m);\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\tchar c;\n\t\tint a, b;\n\t\tscanf(\" %c%d%d\", &c, &a, &b);\n\t\tfor (int j=1; j<=n; j++)\n\t\t{\n\t\t\tif (c=='L' && gdz[j].first<=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='R' && gdz[j].first>=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='D' && gdz[j].second<=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='U' && gdz[j].second>=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t}\n\t\tile[i]=b;\n\t}\n\tfor (int h=0; h<200; h++)\n\t{\n\t\tSimplex janusz(n, m+2*n);\n\t\tfor (int i=0; i<n; i++)\n\t\t{\n\t\t\tjanusz.c[i]=war[i+1];\n\t\t\tif (h)\n\t\t\t\tzmien(janusz.c[i]);\n\t\t}\n\t\tfor (int i=0; i<m; i++)\n\t\t{\n\t\t\tjanusz.b[i]=ile[i+1];\n\t\t\tfor (int j=0; j<n; j++)\n\t\t\t\tjanusz.A[i][j]=podz[i+1][j+1];\n\t\t}\n\t\tfor (int i=0; i<n; i++)\n\t\t{\n\t\t\tjanusz.b[m+i]=1;\n\t\t\tjanusz.A[m+i][i]=1;\n\t\t}\n\t\tfor (int i=0; i<n; i++)\n\t\t{\n\t\t\tjanusz.b[m+n+i]=0;\n\t\t\tjanusz.A[m+n+i][i]=-1;\n\t\t}\n\t\tassert(janusz.solve());\n\t\tauto wez=janusz.getVars();\n\t\t\n\t\tvector <pair<ld,int> > wek;\n\t\tfor (int i=1; i<=n; i++)\n\t\t\twek.push_back({wez[i-1], i});\n\t\t\n\t\tsort(wek.begin(), wek.end());\n\t\treverse(wek.begin(), wek.end());\n\t\t\n\t\tter.reset();\n\t\t\n\t\tfor (auto i : wek)\n\t\t{\n\t\t\tter[i.second]=1;\n\t\t\tif (!popr())\n\t\t\t\tter[i.second]=0;\n\t\t}\n\t\twyn=max(wyn, dajwar());\n\t}\n\t\n\tprintf(\"%lld\\n\", wyn);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\ntypedef long double T; // long long double, Rational, long double + mod<P>...\ntypedef vector<T> vd;\ntypedef vector<vd> vvd;\n\ntypedef long double DOUBLE;\ntypedef vector<DOUBLE> VD;\ntypedef vector<VD> VVD;\ntypedef vector<int> VI;\nconst DOUBLE EPS = 1e-20;\nstruct LPSolver {\n\tint m, n; VI B, N; VVD D;\n\tLPSolver(const VVD &A, const VD &b, const VD &c) : m(b.size()), n(c.size()), N(n + 1), B(m), D(m + 2, VD(n + 2)) { for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) D[i][j] = A[i][j]; for (int i = 0; i < m; i++) { B[i] = n + i; D[i][n] = -1; D[i][n + 1] = b[i]; } for (int j = 0; j < n; j++) { N[j] = j; D[m][j] = -c[j]; } N[n] = -1; D[m + 1][n] = 1; }\n\tvoid Pivot(int r, int s) { long double inv = 1.0 / D[r][s]; for (int i = 0; i < m + 2; i++) if (i != r) for (int j = 0; j < n + 2; j++) if (j != s) D[i][j] -= D[r][j] * D[i][s] * inv; for (int j = 0; j < n + 2; j++) if (j != s) D[r][j] *= inv; for (int i = 0; i < m + 2; i++) if (i != r) D[i][s] *= -inv; D[r][s] = inv; swap(B[r], N[s]); }\n\tbool Simplex(int phase) { int x = phase == 1 ? m + 1 : m; while (true) { int s = -1; for (int j = 0; j <= n; j++) { if (phase == 2 && N[j] == -1) continue; if (s == -1 || D[x][j] < D[x][s] || D[x][j] == D[x][s] && N[j] < N[s]) s = j; }if (D[x][s] > -EPS) return true; int r = -1; for (int i = 0; i < m; i++) { if (D[i][s] < EPS) continue; if (r == -1 || D[i][n + 1] / D[i][s] < D[r][n + 1] / D[r][s] || (D[i][n + 1] / D[i][s]) == (D[r][n + 1] / D[r][s]) && B[i] < B[r]) r = i; }if (r == -1) return false; Pivot(r, s); } } \n\tDOUBLE Solve(VD &x) { int r = 0; for (int i = 1; i < m; i++) if (D[i][n + 1] < D[r][n + 1]) r = i; if (D[r][n + 1] < -EPS) { Pivot(r, n); if (!Simplex(1) || D[m + 1][n + 1] < -EPS) return -numeric_limits<DOUBLE>::infinity(); for (int i = 0; i < m; i++) if (B[i] == -1) { int s = -1; for (int j = 0; j <= n; j++) if (s == -1 || D[i][j] < D[i][s] || D[i][j] == D[i][s] && N[j] < N[s]) s = j; Pivot(i, s); } }if (!Simplex(2)) return numeric_limits<DOUBLE>::infinity(); x = VD(n); for (int i = 0; i < m; i++) if (B[i] < n) x[B[i]] = D[i][n + 1]; return D[m][n + 1]; }\n};\n\nint n, m, x[105], y[105];\nll v[105];\n\nvvd A0, A;\nvd b0, c0, t, b, c;\n\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> x[i] >> y[i] >> v[i];\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tt.clear();\n\t\tt.resize(n);\n\t\tt[i] = 1;\n\t\tA.push_back(t);\n\t\tb.push_back(1);\t\t\n\t}\n\tcin >> m;\n\tfor (int i = 0; i < m; ++i) {\n\t\tt.clear();\n\t\tt.resize(n);\n\t\tchar f;\n\t\tint a, bb;\n\t\tcin >> f >> a >> bb;\n\t\tif (f == 'L') {\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\tif (x[j] <= a)\n\t\t\t\t\tt[j] = 1;\n\t\t} if (f == 'R') {\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\tif (x[j] >= a)\n\t\t\t\t\tt[j] = 1;\n\t\t} if (f == 'U') {\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\tif (y[j] >= a)\n\t\t\t\t\tt[j] = 1;\n\t\t} if (f == 'D') {\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\tif (y[j] <= a)\n\t\t\t\t\tt[j] = 1;\n\t\t}\n\t\tA.push_back(t);\n\t\tb.push_back(bb);\n\t}\n\tc.resize(n);\n\tfor (int i = 0; i < n; ++i)\n\t\tc[i] = v[i];\n\tll ans = 0;\n\tfor (int i = 0; i <= n; ++i) {\n\t\tA0 = A, b0 = b, c0 = c;\n\t\tt.clear();\n\t\tfor (int j = 0; j < n; ++j)\n\t\t\tt[j] = 1;\n\t\tA0.push_back(t);\n\t\tb0.push_back(i);\n\t\tfor (int j = 0; j < n; ++j)\n\t\t\tt[j] = -1;\n\t\tA0.push_back(t);\n\t\tb0.push_back(-i);\n\t\tvd xx;\n\t\tlong double h = LPSolver(A0, b0, c0).Solve(xx);\n\t\tans = max(ans, (ll)(h+.1));\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef HOME\n#define db(x) cerr << #x << \" = \" << x << endl\n#define db3(x, y, z) cerr << \"(\" << #x << \", \" << #y << \", \" << #z << \") = (\" << x << \", \" << y << \", \" << z << \")\" << endl\n#define db2(x, y) cerr << \"(\" << #x << \", \" << #y << \") = (\" << x << \", \" << y << \")\" << endl\n#define dbv(a) cerr << #a << \" = \"; for (auto xxx: a) cerr << xxx  << \" \"; cerr << endl\n#else\n#define db(x) ;\n#define db3(x, y, z) ;\n#define db2(x, y) ;\n#define dbv(a) ;\n#endif\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double dbl;\n\n\nconst int INF = 1.01e9;\nconst int MOD = (int)1e9 + 7;\n\nstruct Item {\n    int x, y;\n    ll val;\n};\n\nstruct Cond {\n    char type;\n    int a, b;\n\n    bool cover(Item it) {\n        if (type == 'L') {\n            return it.x <= a;\n        }\n        if (type == 'R') {\n            return it.x >= a;\n        }\n        if (type == 'D') {\n            return it.y <= a;\n        }\n        if (type == 'U') {\n            return it.y >= a;\n        }\n        assert(0);\n    }\n};\n\nll slow(vector<Item> a, vector<Cond> b) {\n    int n = a.size(), m = b.size();\n    ll ans = 0;\n    for (int mask = 0; mask < (1 << n); mask++) {\n        vector<int> cnt(m);\n        ll sum = 0;\n        for (int i = 0; i < n; i++) {\n            if (!(mask & (1 << i))) continue;\n            sum += a[i].val;\n            for (int j = 0; j < m; j++) {\n                if (b[j].cover(a[i])) {\n                    cnt[j]++;\n                }\n            }\n        }\n        bool bad = 0;\n        for (int i = 0; i < m; i++) {\n            if (cnt[i] > b[i].b) {\n                bad = 1;\n            }\n        }\n        if (bad) continue;\n        ans = max(ans, sum);\n    }\n    return ans;\n}\n\n\nbool eq(dbl a, dbl b) {\n    return fabs(a - b) < 1e-9;\n}\n\nbool ls(dbl a, dbl b) {\n    return !eq(a, b) && a < b;\n}\n\nvector<dbl> simplex(vector<vector<dbl> > a) {\n    int n = a.size() - 1;\n    int m = a[0].size() - 1;\n    vector<int> left(n + 1), up(m + 1);\n    iota(up.begin(), up.end(), 0);\n    iota(left.begin(), left.end(), m);\n    auto pivot = [&](int x, int y) {\n        swap(left[x], up[y]);\n        dbl k = a[x][y];\n        a[x][y] = 1;\n        vector<int> vct;\n        for (int j = 0; j <= m; j++) {\n            a[x][j] /= k;\n            if (!eq(a[x][j], 0)) vct.push_back(j);\n        }\n        for (int i = 0; i <= n; i++) {\n            if (eq(a[i][y], 0) || i == x) continue;\n            k = a[i][y];\n            a[i][y] = 0;\n            for (int j : vct) a[i][j] -= k * a[x][j];\n        }\n    };\n    while (1) {\n        int x = -1;\n        for (int i = 1; i <= n; i++) if (ls(a[i][0], 0) && (x == -1 || a[i][0] < a[x][0])) x = i;\n        if (x == -1) break;\n        int y = -1;\n        for (int j = 1; j <= m; j++) if (ls(a[x][j], 0) && (y == -1 || a[x][j] < a[x][y])) y = j;\n        if (y == -1) assert(0); // infeasible\n        pivot(x, y);\n    }\n    while (1) {\n        int y = -1;\n        for (int j = 1; j <= m; j++) if (ls(0, a[0][j]) && (y == -1 || a[0][j] > a[0][y])) y = j;\n        if (y == -1) break;\n        int x = -1;\n        for (int i = 1; i <= n; i++) if (ls(0, a[i][y]) && (x == -1 || a[i][0] / a[i][y] < a[x][0] / a[x][y])) x = i;\n        if (x == -1) assert(0); // unbounded\n        pivot(x, y);\n    }\n    vector<dbl> ans(m + 1);\n    for (int i = 1; i <= n; i++) if (left[i] <= m) ans[left[i]] = a[i][0];\n    ans[0] = -a[0][0];\n    return ans;\n}\n// j=1..m: x[j]>=0\n// i=1..n: sum(j=1..m) A[i][j]*x[j] <= A[i][0]\n// max sum(j=1..m) A[0][j]*x[j]\n// res[0] is answer\n// res[1..m] is certificate\n\nll blyat(vector<Item> a, vector<Cond> b) {\n    int n = a.size(), m = b.size();\n    vector<vector<dbl>> c(m + 1, vector<dbl>(n + 1));\n    for (int i = 0; i < n; i++) {\n        c[0][1 + i] = a[i].val;\n    }\n    for (int i = 0; i < m; i++) {\n        c[1 + i][0] = b[i].b;\n        for (int j = 0; j < n; j++) {\n            if (b[i].cover(a[j])) {\n                c[1 + i][1 + j] = 1;\n            }\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        vector<dbl> cur(n + 1);\n        cur[0] = 1;\n        cur[1 + i] = 1;\n        c.push_back(cur);\n    }\n    auto res = simplex(c);\n//    ll ans = 0;\n//    for (int i = 0; i < n; i++) {\n//        if (res[1 + i] > 0.5) {\n//            ans += a[i].val;\n//        }\n//    }\n//    return ans;\n    int cnt = 0;\n    vector<int> v;\n    for (int i = 0; i < n; i++) {\n        if (!eq(0, res[1 + i]) && !eq(1, res[1 + i])) {\n//            cnt++;\n            v.push_back(i);\n        }\n    }\n    static int mx = 0;\n    cnt = v.size();\n    mx = max(mx, cnt);\n    //db2(cnt, mx);\n\n    ll cres = 0;\n    for (int mask = 0; mask < (1LL << (int)v.size()); mask++) {\n        vector<int> cov(m);\n        ll cost = 0;\n        for (int i = 0; i < n; i++) {\n            if (eq(1, res[1 + i])) {\n                cost += a[i].val;\n                for (int j = 0; j < m; j++) {\n                    cov[j] += b[j].cover(a[i]);\n                }\n            }\n        }\n        for (int i = 0; i <(int)v.size(); i++) {\n            if (mask & (1 << i)) {\n                cost += a[v[i]].val;\n                for (int j= 0; j < m; j++) {\n                    cov[j] += b[j].cover(a[v[i]]);\n                }\n            }\n        }\n        bool ok = 1;\n        for (int j = 0; j < m; j++) ok &= cov[j] <= b[j].b;\n        if (ok) cres = max(cres, cost);\n    }\n    return cres;\n    return (ll)round(res[0]);\n}\n\nll fast(vector<Item> a, vector<Cond> b) {\n    dbl start = clock() / (dbl)CLOCKS_PER_SEC;\n\n    dbl TL = 1.7;\n    auto fail = [&]() {\n        return clock() / (dbl)CLOCKS_PER_SEC - start > TL;\n    };\n\n    int n = a.size();\n    ll ans = blyat(a, b);\n    for (int i = 0; i < n; i++) {\n        if (fail()) return ans;\n        auto na = a;\n        na.erase(na.begin() + i);\n        ans =max(ans, blyat(na, b));\n    }\n    while (1) {\n        if (fail()) return ans;\n        auto na = a;\n        random_shuffle(na.begin(), na.end());\n        na.resize(rand() % n + 1);\n        ans =max(ans, blyat(na, b));\n    }\n    return ans;\n}\n\nvoid stress() {\n    for (int it = 0;; it++) {\n        mt19937_64 rnd(it);\n        db(it);\n\n\n        int n = rnd() % 10 + 1;\n        vector<Item> a(n);\n        for (int i =0 ; i < n; i++) {\n            a[i].x = rnd() % 100;\n            a[i].y = rnd() % 100;\n            a[i].val = rnd() % (ll)1e15;\n        }\n        int m = rnd() % 10 + 1;\n        vector<Cond> b(m);\n        for (int i = 0; i < m; i++) {\n            b[i].a = rnd() % 100;\n            b[i].b = rnd() % (n + 1);\n            b[i].type = \"ULDR\"[rnd() % 4];\n        }\n\n        auto ans1 = fast(a, b);\n        auto ans2 = slow(a, b);\n        if (ans1 != ans2) {\n            cout << ans1 << \" instead of \" << ans2 << endl;\n            exit(0);\n        }\n    }\n}\n\nint main() {\n#ifdef HOME\n    assert(freopen(\"in\", \"r\", stdin));\n#endif\n//    stress();\n\n    int n;\n    while (scanf(\"%d\", &n) == 1) {\n        vector<Item> a(n);\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d%d%lld\", &a[i].x, &a[i].y, &a[i].val);\n        }\n        int m;\n        scanf(\"%d\", &m);\n        vector<Cond> b(m);\n        for (int i = 0; i < m; i++) {\n            scanf(\" %c%d%d\", &b[i].type, &b[i].a, &b[i].b);\n        }\n\n//        printf(\"%lld\\n\", slow(a, b));\n        printf(\"%lld\\n\", fast(a, b));\n    }\n\n#ifdef HOME\n    cerr << \"time: \" << clock() * 1.0 / CLOCKS_PER_SEC << endl;\n#endif\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 100 , M = 400 , V = N + M << 1 , E = N + N * M * 2 + M * 2;\nconst long long INF = 0x3f3f3f3f3f3f3f3fLL;\nint n,m,x[N],y[N],a[N],b[N],u[N],d[N],l[N],r[N]; char op[N];\nint t(1),Head[V],vis[V],S,T; deque <int> q; ll Delta,dis[V],v[N],Ans;\nstruct Edge { int u,v,next,val; ll cos; } e[E*4];\ntemplate<class T> inline T Read(void)\n{\n    T x = 0; bool w = 0; char ch = ' ';\n    while ( !isdigit(ch) ) w |= ch == '-' , ch = getchar();\n    while ( isdigit(ch) ) x = x * 10 + ch - 48 , ch = getchar();\n    return w ? -x : x;\n}\ninline void Input(void)\n{\n    n = Read<int>();\n    for (int i = 1; i <= n; i++)\n        x[i] = Read<int>() , y[i] = Read<int>() , v[i] = Read<ll>();\n    m = Read<int>();\n    for (int i = 1; i <= m; i++)\n    {\n        char c = ' ';\n        while ( isspace(c) ) c = getchar();\n        op[i] = c , a[i] = Read<int>() , b[i] = Read<int>();\n    }\n}\ninline void Insert(int x,int y,ll c,int v)\n{\n    e[++t] = (Edge){ x , y , Head[x] , v , c } , Head[x] = t;\n    e[++t] = (Edge){ y , x , Head[y] , 0 , -c } , Head[y] = t;\n}\ninline void Build(int k)\n{\n    for (int i = 1; i <= k; i++)\n        u[i] = r[i] = 500 , l[i] = d[i] = 0;\n    for (int i = 1; i <= m; i++)\n        if ( b[i] < k )\n        {\n            if ( op[i] == 'L' ) l[b[i]+1] = max( l[b[i]+1] , a[i] + 1 );\n            if ( op[i] == 'R' ) r[k-b[i]] = min( r[k-b[i]] , a[i] - 1 );\n            if ( op[i] == 'D' ) d[b[i]+1] = max( d[b[i]+1] , a[i] + 1 );\n            if ( op[i] == 'U' ) u[k-b[i]] = min( u[k-b[i]] , a[i] - 1 );\n            // if ( op[i] == 'L' ) l[b[i]+1] = a[i] + 1;\n            // if ( op[i] == 'R' ) r[k-b[i]] = a[i] - 1;\n            // if ( op[i] == 'D' ) d[b[i]+1] = a[i] + 1;\n            // if ( op[i] == 'U' ) u[k-b[i]] = a[i] - 1;\n        }\n    for (int i = 2; i <= k; i++) l[i] = max( l[i] , l[i-1] ) , d[i] = max( d[i] , d[i-1] );\n    for (int i = k-1; i >= 1; i--) r[i] = min( r[i] , r[i+1] ) , u[i] = min( u[i] , u[i+1] );\n    memset( Head , 0 , sizeof Head );\n    S = ( n + k ) << 1 | 1 , T = ( n + k + 1 ) * 2 , t = 1 , Delta = 0;\n    for (int i = 1; i <= n; i++) Insert( i , i+n , -v[i]-1000000000000000LL , 1 );\n    for (int i = 1; i <= k; i++)\n    {\n        Insert( S , n*2+i , 0 , 1 ) , Insert( n*2+k+i , T , 0 , 1 );\n        for (int j = 1; j <= n; j++)\n        {\n            if ( l[i] <= x[j] && x[j] <= r[i] ) Insert( n*2+i , j , 0 , 1 );\n            if ( d[i] <= y[j] && y[j] <= u[i] ) Insert( j+n , n*2+k+i , 0 , 1 );\n        }\n    }\n    // printf( \"t = %d\\n\" , t );\n}\ninline bool Relabel(void)\n{\n    memset( dis , 0x3f , sizeof dis );\n    memset( vis , 0 , sizeof vis );\n    dis[T] = 0 , vis[T] = 1 , q.push_front(T);\n    while ( !q.empty() )\n    {\n        int x = q.front(); q.pop_front() , vis[x] = 0;\n        if ( q.size() > 1 && dis[q.front()] > dis[q.back()] )\n            swap( q.front() , q.back() );\n        for (int i = Head[x] , y; i; i = e[i].next)\n            if ( e[i^1].val && dis[ y = e[i].v ] > dis[x] + e[i^1].cos )\n            {\n                dis[y] = dis[x] + e[i^1].cos;\n                if ( vis[y] ) continue;\n                vis[y] = true , q.push_back(y);\n                if ( q.size() > 1 && dis[q.front()] > dis[q.back()] )\n                    swap( q.front() , q.back() );\n            }\n    }\n    return dis[S] < INF;\n}\ninline int Dinic(int x,int flow)\n{\n    if ( !flow || x == T ) return flow;\n    int residue = flow; vis[x] = true;\n    for (int i = Head[x] , y; i; i = e[i].next)\n        if ( e[i].val && !vis[ y = e[i].v ] && !e[i].cos )\n        {\n            int k = Dinic( y , min( e[i].val , residue ) );\n            e[i].val -= k , e[i^1].val += k;\n            if ( ( residue -= k ) == 0 ) break;\n        }\n    return flow - residue;\n}\ninline pair<int,long long> PrimalDual(void)\n{\n    int Maxflow = 0, Flow = 0; long long Mincost = 0;\n    while ( Relabel() )\n    {\n        for (int i = 2; i <= t; i++)\n            e[i].cos += dis[e[i].v] - dis[e[i].u];\n        Delta += dis[S] , memset( vis , 0 , sizeof vis );\n        while ( Flow = Dinic( S , 1e9 ) )\n            Maxflow += Flow , Mincost += Flow * Delta,\n            memset( vis , 0 , sizeof vis );\n    }\n    return { Maxflow , Mincost };\n}\nint main(void)\n{\n    Input();\n    for (int i = 1; i <= n; i++)\n        Build(i) , Ans = max( Ans , -PrimalDual().second-1000000000000000LL*i );\n    printf( \"%lld\\n\" , Ans );\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace __gnu_pbds;\nusing namespace std;\n \ntemplate <typename T>\nusing ordered_set =\n\ttree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n \n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n\t*this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n \n#define shandom_ruffle random_shuffle\n \nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=327;\nusing bn=bitset<87>;\nusing ld=long double;\n\nint n;\npii gdz[nax];\nll war[nax];\n\nint m;\nbn podz[nax];\nint ile[nax];\n\nll wyn;\n\nstruct Simplex {        // Maximize c*x subject to Ax <= b.\n  using T = ld;     // Initialize the structure, set A, b, c and then run\n  vector<vector<T>> A;  // solve(). Max objective is stored in res. To recover\n  vector<T> b, c;       // the best result, use getVars().\n  int V, E;\n  vector<int> eqIds, varIds, cols;\n  T res;\n  static constexpr T kEps = 1e-9;\n\n  Simplex(int vars, int eqs) : A(eqs, vector<T>(vars)), b(eqs), c(vars),\n      V(vars), E(eqs), eqIds(eqs), varIds(vars), res(0) {\n    iota(varIds.begin(), varIds.end(), 0);\n    iota(eqIds.begin(), eqIds.end(), vars);\n  }\n\n  void pivot(int eq, int var) {\n    T coef = 1 / A[eq][var];\n    cols.clear();\n    for (int i = 0; i < V; i++) {\n      if (abs(A[eq][i]) > kEps) { cols.push_back(i); A[eq][i] *= coef; }\n    }\n    A[eq][var] *= coef; b[eq] *= coef;\n    for (int row = 0; row < E; row++) {\n      if (row == eq || abs(A[row][var]) < kEps) { continue; }\n      T k = -A[row][var];\n      A[row][var] = 0;\n      for (int i : cols) { A[row][i] += k * A[eq][i]; }\n      b[row] += k * b[eq];\n    }\n    T q = c[var]; c[var] = 0;\n    for (int i : cols) { c[i] -= q * A[eq][i]; }\n    res += q * b[eq];\n    swap(varIds[var], eqIds[eq]);\n  }\n\n  bool solve() {\n    while (true) {\n      int eq = -1, var = -1;\n      for (int i = 0; i < E; i++) { if (b[i] < -kEps) { eq = i; break; } }\n      if (eq == -1) { break; }\n      for (int i = 0; i < V; i++) { if (A[eq][i] < -kEps) { var = i; break; } }\n      if (var == -1) { res = -1e9; return false; /* No solution */ }\n      pivot(eq, var);\n    }\n    while (true) {\n      int var = -1, eq = -1;\n      for (int i = 0; i < V; i++) { if (c[i] > kEps) { var = i; break; } }\n      if (var == -1) { break; }\n      for (int i = 0; i < E; i++) {\n        if (A[i][var] < kEps) { continue; }\n        if (eq >= 0 && b[i] / A[i][var] >= b[eq] / A[eq][var]) { continue; }\n        eq = i;\n      }\n      if (eq == -1) { res = 1e9; return false; /* Unbounded */ }\n      pivot(eq, var);\n    }\n    return true;\n  }\n\n  vector<T> getVars() { // Optimal assignment of variables.\n    vector<T> result(V);\n    for (int i = 0; i < E; i++) if (eqIds[i] < V) result[eqIds[i]] = b[i];\n    return result;\n  }\n};\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(\"%d%d%lld\", &gdz[i].first, &gdz[i].second, &war[i]);\n\tscanf(\"%d\", &m);\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\tchar c;\n\t\tint a, b;\n\t\tscanf(\" %c%d%d\", &c, &a, &b);\n\t\tfor (int j=1; j<=n; j++)\n\t\t{\n\t\t\tif (c=='L' && gdz[j].first<=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='R' && gdz[j].first>=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='D' && gdz[j].second<=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='U' && gdz[j].second>=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t}\n\t\tile[i]=b;\n\t}\n\tSimplex janusz(n, m+2*n);\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tjanusz.c[i]=war[i+1];\n\t}\n\tfor (int i=0; i<m; i++)\n\t{\n\t\tjanusz.b[i]=ile[i+1];\n\t\tfor (int j=0; j<n; j++)\n\t\t\tjanusz.A[i][j]=podz[i+1][j+1];\n\t}\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tjanusz.b[m+i]=1;\n\t\tjanusz.A[m+i][i]=1;\n\t}\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tjanusz.b[m+n+i]=0;\n\t\tjanusz.A[m+n+i][i]=-1;\n\t}\n\tassert(janusz.solve());\n\tld wez=janusz.res;\n\tdebug() << imie(wez);\n\tdebug() << janusz.getVars();\n\tprintf(\"%lld\\n\", llround(wez));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//第8回シンデレラガール総選挙は是非本田未央ちゃんに投票をお願いします！\n//ファンのことも他のアイドルの子たちのことも本当に大事にしてて、今まで周りに色んなものを与えてくれました。\n//今度は私たちが未央ちゃんにお返しをする番です。みんなでガラスの靴を履かせてあげましょう！\n// #本田未央を一番星に #本田未央を令和のシンデレラガールに #第8回シンデレラガール総選挙\n#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\n#include<cassert>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\nnamespace MCF {\n\t#define MAXN 10050\n\t#define MAXM 500000\n\t#define wint int\n\t#define cint lint\n\tconst wint wEPS = 0;\n\tconst wint wINF = 1001001001;\n\tconst cint cEPS = 0;\n\tconst cint cINF = 123456789012345678LL;\n\tint n, m, ptr[MAXN], next[MAXM], zu[MAXM];\n\twint capa[MAXM], tof;\n\tcint cost[MAXM], toc, d[MAXN], pot[MAXN];\n\tint vis[MAXN], pree[MAXN];\n\tvoid init(int _n) {\n\t\tn = _n; m = 0; memset(ptr, ~0, n * 4);\n\t}\n\tvoid ae(int u, int v, wint w, cint c) {\n\t\tnext[m] = ptr[u]; ptr[u] = m; zu[m] = v; capa[m] = w; cost[m] = +c; ++m;\n\t\tnext[m] = ptr[v]; ptr[v] = m; zu[m] = u; capa[m] = 0; cost[m] = -c; ++m;\n\t}\n\tbool solve(int src, int ink, wint flo = wINF) {\n\t\tint i, u, v;\n\t\twint f;\n\t\tcint c, cc;\n\t\tmemset(pot, 0, n * sizeof(cint));\n\t\t\n\t\tfor (bool cont = 1; cont ;) {\n\t\t\tcont = 0;\n\t\t\tfor (u = 0; u < n; ++u) for (i = ptr[u]; ~i; i = next[i]) if (capa[i] > wEPS) {\n\t\t\t\tif (pot[zu[i]] > pot[u] + cost[i] + cEPS) {\n\t\t\t\t\tpot[zu[i]] = pot[u] + cost[i]; cont = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (toc = 0, tof = 0; tof + wEPS < flo; ) {\n\t\t\ttypedef pair<cint, int> node;\n\t\t\tpriority_queue<node, vector<node>, greater<node> > q;\n\t\t\tfor (u = 0; u < n; ++u) { d[u] = cINF; vis[u] = 0; }\n\t\t\tfor (q.push(mp(d[src] = 0, src)); !q.empty(); ) {\n\t\t\t\tc = q.top().first; u = q.top().second; q.pop();\n\t\t\t\tif (vis[u]++) continue;\n\t\t\t\tfor (i = ptr[u]; ~i; i = next[i]) if (capa[i] > wEPS) {\n\t\t\t\t\tcc = c + cost[i] + pot[u] - pot[v = zu[i]];\n\t\t\t\t\tif (d[v] > cc) { q.push(mp(d[v] = cc, v)); pree[v] = i; }\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!vis[ink]) return 0;\n\t\t\tf = flo - tof;\n\t\t\tfor (v = ink; v != src; v = zu[i ^ 1]) { i = pree[v]; f = min(f, capa[i]); }\n\t\t\tfor (v = ink; v != src; v = zu[i ^ 1]) { i = pree[v]; capa[i] -= f; capa[i ^ 1] += f; }\n\t\t\ttof += f;\n\t\t\ttoc += f * (d[ink] - pot[src] + pot[ink]);\n\t\t\tfor (u = 0; u < n; ++u) pot[u] += d[u];\n\t\t}\n\t\treturn 1;\n\t}\n}\nvector<pint> L,R,U,D,V;\nint x[84],y[84];lint v[84];\nlint inf=1234567890123456LL;\nint lx[84],ly[84],hx[84],hy[84];\nint main()\n{\n\tint n,m,a,b;char c;\n\tcin>>n;\n\trep(i,n) cin>>x[i]>>y[i]>>v[i];\n\tcin>>m;rep(i,m){\n\t\tcin>>c>>a>>b;\n\t\tif(c=='L') L.pb(mp(a,b));\n\t\tif(c=='R') R.pb(mp(a,b));\n\t\tif(c=='D') D.pb(mp(a,b));\n\t\tif(c=='U') U.pb(mp(a,b));\n\t}\n\t/*if(L.size()>0){\n\t\tsort(All(L));reverse(All(L));\n\t\tV.pb(L[0]);\n\t\tREP(i,1,L.size()){\n\t\t\tif(L[i].se<L[i-1].se) V.pb(L[i]);\n\t\t}\n\t\tL=V;V.clear();\n\t}\n\tif(R.size()>0){\n\t\tsort(All(R));//reverse(All(L));\n\t\tV.pb(R[0]);\n\t\tREP(i,1,L.size()){\n\t\t\tif(R[i].se<R[i-1].se) V.pb(R[i]);\n\t\t}\n\t\tR=V;V.clear();\n\t}\n\tif(D.size()>0){\n\t\tsort(All(D));reverse(All(D));\n\t\tV.pb(D[0]);\n\t\tREP(i,1,D.size()){\n\t\t\tif(D[i].se<D[i-1].se) V.pb(D[i]);\n\t\t}\n\t\tD=V;V.clear();\n\t}\n\tif(U.size()>0){\n\t\tsort(All(U));//reverse(All(U));\n\t\tV.pb(U[0]);\n\t\tREP(i,1,U.size()){\n\t\t\tif(U[i].se<U[i-1].se) V.pb(U[i]);\n\t\t}\n\t\tU=V;V.clear();\n\t}*/\n\tlint out=0;\n\trep(i,n+1){\n\t\trep(j,i+1) lx[j]=ly[j]=0,hx[j]=hy[j]=100;\n\t\trep(j,L.size()) REP(k,L[j].se,i) lx[k]=max(lx[k],L[j].fi+1);\n\t\t//if(i==4) cout<<L.size()<<' '<<L[0].se<<' '<<L[0].fi<<' '<<lx[1]<<endl;\n\t\trep(j,R.size()) REP(k,R[j].se,i) hx[i-1-k]=min(hx[i-1-k],R[j].fi-1);\n\t\trep(j,D.size()) REP(k,D[j].se,i) ly[k]=max(ly[k],D[j].fi+1);\n\t\trep(j,U.size()) REP(k,U[j].se,i) hy[i-1-k]=min(hy[i-1-k],U[j].fi-1);\n\t\t//cout<<i<<endl;rep(j,i) cout<<lx[j]<<' '<<hx[j]<<' '<<ly[j]<<' '<<hy[j]<<endl;\n\t\tint S=n*2+i*2,T=S+1;\n\t\tMCF::init(T+1);\n\t\trep(j,i) MCF::ae(S,j,1,0),MCF::ae(i+j,T,1,0);\n\t\trep(j,n){\n\t\t\tMCF::ae(i*2+j,i*2+n+j,1,inf-v[j]);\n\t\t\trep(k,i){\n\t\t\t\tif(lx[k]<=x[j] && x[j]<=hx[k]) MCF::ae(k,i*2+j,1,0);\n\t\t\t\tif(ly[k]<=y[j] && y[j]<=hy[k]) MCF::ae(i*2+n+j,i+k,1,0);\n\t\t\t}\n\t\t}\n\t\tMCF::solve(S,T);\n\t\t//cout<<i<<' '<<MCF::tof<<endl;\n\t\tif(i==MCF::tof){\n\t\t\tout=max(out,inf*i-MCF::toc);\n\t\t\t//cout<<i<<' '<<inf*i-MCF::toc<<endl;\n\t\t}\n\t}\n\tcout<<out<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int64_t INF = 1e18;\nstruct MinCostFlow{\n    struct edge {\n        int64_t to, cap, cost, rev;\n        edge(int64_t to, int64_t cap, int64_t cost, int64_t rev):to(to), cap(cap), cost(cost), rev(rev){}\n    };\n\n    int N, S, T;\n    int64_t flow;\n    int64_t cost;\n    vector<vector<edge>> G;\n    vector<pair<int, int>> prv; // {v, e};\n    vector<int64_t> h;\n\n    MinCostFlow(int N, int S, int T):N(N), S(S), T(T){\n        flow = cost = 0;\n        G.resize(N);\n        prv.resize(N);\n        h.resize(N);\n    }\n\n    void add_edge(int64_t from, int64_t to, int64_t cap, int64_t cost){\n        G[from].emplace_back(to, cap, cost, G[to].size());\n        G[to].emplace_back(from, 0, -cost, G[from].size()-1);\n    }\n\n    int64_t calculate(int64_t f){\n        typedef pair<int64_t, int> P;\n        \n        int64_t res = 0;\n        vector<int64_t> dist(N);\n\n        while(f > flow){\n            priority_queue<P, vector<P>, greater<P>> que;\n            fill(dist.begin(), dist.end(), INF);\n            dist[S] = 0;\n            que.push({0, S});\n            while(que.size()){\n                auto p = que.top(); que.pop();\n                int64_t d = p.first;\n                int i = p.second;\n                if(d > dist[i]) continue;\n                for(int idx=0; idx<G[i].size(); idx++){\n                    auto& e = G[i][idx];\n                    int j = e.to;\n                    int64_t d2 = d + e.cost + h[i] - h[j];\n                    if(e.cap > 0 && dist[j] > d2){\n                        dist[j] = d2;\n                        prv[j] = {i, idx};\n                        que.push({dist[j], j});\n                    }\n                }\n            }\n            if(dist[T] == INF) return -1;\n            for(int i=0; i<N; i++) h[i] += dist[i];\n            \n            int64_t d = f - flow;\n            for(int i=T; i!=S; i=prv[i].first){\n                auto& e = G[prv[i].first][prv[i].second];\n                d = min(d, e.cap);\n            }\n            flow += d;\n            res += d * h[T];\n            for(int i=T; i!=S; i=prv[i].first){\n                auto& e = G[prv[i].first][prv[i].second];\n                e.cap -= d;\n                G[i][e.rev].cap += d;\n            }\n        } \n        return res;\n    }\n};\n\nvoid chmin(int& a, int b){\n    a = min(a, b);\n}\nvoid chmax(int& a, int b){\n    a = max(a, b);\n}\n\nint N, M, X[80], Y[80];\nint64_t V[80];\nvector<pair<int, int>> C[4];\n\nint64_t solve(int K){\n    vector<vector<int>> L(2, vector<int>(K, 1)), R(2, vector<int>(K, 100));\n    for(int t=0; t<2; t++){\n        for(auto& p : C[2*t]){\n            int a = p.first, b = p.second;\n            if(b < K) chmax(L[t][b], a+1);\n        }\n        for(auto& p : C[2*t+1]){\n            int a = p.first, b = p.second;\n            if(b < K) chmin(R[t][K-b-1], a-1);\n        }\n        for(int i=1; i<K; i++) chmax(L[t][i], L[t][i-1]);\n        for(int i=K-2; i>=0; i--) chmin(R[t][i], R[t][i+1]);\n    }\n\n    int S = 320, T = 321;\n    MinCostFlow solver(T+1, S, T);\n    for(int i=0; i<K; i++){\n        solver.add_edge(S, i, 1, 0);\n        for(int j=0; j<N; j++){\n            if(L[0][i] <= X[j] && X[j] <= R[0][i]) solver.add_edge(i, 80+j, 1, 0);\n            if(L[1][i] <= Y[j] && Y[j] <= R[1][i]) solver.add_edge(160+j, 240+i, 1, 0);\n        }\n        solver.add_edge(240+i, T, 1, 0);\n    }\n    const int64_t OFFSET = 1e15;\n    for(int i=0; i<N; i++) solver.add_edge(80+i, 160+i, 1, OFFSET - V[i]);\n\n    int64_t res = solver.calculate(K);\n    return (res == -1 ? -1 : K*OFFSET - res);\n}\n\nint main(){\n    cin >> N;\n    for(int i=0; i<N; i++) cin >> X[i] >> Y[i] >> V[i];\n    cin >> M;\n    const string LRDU = \"LRDU\";\n    for(int i=0; i<M; i++){\n        char t;\n        int a, b;\n        cin >> t >> a >> b;\n        C[LRDU.find(t)].push_back({a, b});\n    }\n\n    int64_t ans = 0;\n    for(int K=1; K<=N; K++) ans = max(ans, solve(K));\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\nnamespace flow{\n\tconst ll __ = 1e6 + 7 , _ = 1e5 + 7;\n\tstruct Edge{ll end , upEd , f , c;}Ed[__];\n\tll head[_] , cntEd , S , T;\n\tvoid clear(){memset(head , 0 , sizeof(head)); cntEd = 1; S = T = 0;}\n\tvoid addEd(ll a , ll b , ll c , ll d){Ed[++cntEd] = (Edge){b , head[a] , c , d}; head[a] = cntEd;}\n\tvoid addE(ll a , ll b , ll c , ll d){addEd(a , b , c , d); addEd(b , a , 0 , -d);}\n\n\tbool vis[_]; queue < ll > q; ll dis[_] , pre[_];\n\tbool bfs(){\n\t\tq.push(S); memset(dis , -0x3f , sizeof(ll) * (T + 2)); dis[S] = 0;\n\t\twhile(!q.empty()){\n\t\t\tll t = q.front(); q.pop(); vis[t] = 0;\n\t\t\tfor(ll i = head[t] ; i ; i = Ed[i].upEd)\n\t\t\t\tif(Ed[i].f && dis[Ed[i].end] < dis[t] + Ed[i].c){\n\t\t\t\t\tdis[Ed[i].end] = dis[t] + Ed[i].c; pre[Ed[i].end] = i;\n\t\t\t\t\tif(!vis[Ed[i].end]){vis[Ed[i].end] = 1; q.push(Ed[i].end);}\n\t\t\t\t}\n\t\t}\n\t\treturn dis[T] != dis[T + 1];\n\t}\n\t\n\tll EK(ll s , ll t , ll tarf , ll tarc){\n\t\tS = s; T = t; ll sum = 0;\n\t\twhile(bfs()){\n\t\t\tll cur = T; --tarf;\n\t\t\twhile(cur != S){\n\t\t\t\tll t = pre[cur]; cur = Ed[t ^ 1].end; --Ed[t].f; ++Ed[t ^ 1].f;\n\t\t\t\tif(Ed[t].c == 1e16) --tarc; else if(Ed[t].c == -1e16) ++tarc; else sum += Ed[t].c;\n\t\t\t}\n\t\t}\n\t\treturn !tarf && !tarc ? sum : -1;\n\t}\n}\n\nll bound[2][2][103] , N , M , X[83] , Y[83]; ll v[83];\n\nsigned main(){\n\tcin >> N; for(ll i = 1 ; i <= N ; ++i) cin >> X[i] >> Y[i] >> v[i];\n\tcin >> M; memset(bound , 0x3f , sizeof(bound));\n\tfor(ll i = 1 ; i <= M ; ++i){\n\t\tchar c; ll p , q; cin >> c >> p >> q;\n\t\tswitch(c){\n\t\tcase 'L': bound[0][0][p] = min(bound[0][0][p] , q); break;\n\t\tcase 'R': bound[0][1][p] = min(bound[0][1][p] , q); break;\n\t\tcase 'U': bound[1][0][p] = min(bound[1][0][p] , q); break;\n\t\tcase 'D': bound[1][1][p] = min(bound[1][1][p] , q); break;\n\t\t}\n\t}\n\tll ans = 0;\n\tfor(ll i = 1 ; i <= N ; ++i){\n\t\tflow::clear(); bool flg = bound[0][0][100] >= i && bound[1][1][100] >= i; ll cnt = 0;\n\t\tfor(ll j = 1 ; j <= 100 ; ++j){\n\t\t\tll dwn = max(0ll , i - bound[0][0][j - 1]) , up = bound[0][1][j]; flg &= dwn <= up;\n\t\t\tcnt += dwn; flow::addE(j , j + 1 , dwn , (ll)1e16); flow::addE(j , j + 1 , up - dwn , 0);\n\t\t}\n\t\tfor(ll j = 100 ; j ; --j){\n\t\t\tll dwn = max(0ll , i - bound[1][1][j - 1]) , up = bound[1][0][j]; flg &= dwn <= up;\n\t\t\tcnt += dwn; flow::addE(202 - j , 203 - j , dwn , (ll)1e16); flow::addE(202 - j , 203 - j , up - dwn , 0);\n\t\t}\n\t\tfor(ll j = 1 ; j <= N ; ++j) flow::addE(X[j] + 1 , 202 - Y[j] , 1 , v[j]);\n\t\tflow::addE(0 , 1 , i , 0); if(flg) ans = max(ans , flow::EK(0 , 202 , i , cnt));\n\t}\n\tcout << ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\ntypedef long double T; // long long double, Rational, long double + mod<P>...\ntypedef vector<T> vd;\ntypedef vector<vd> vvd;\n\ntypedef long double DOUBLE;\ntypedef vector<DOUBLE> VD;\ntypedef vector<VD> VVD;\ntypedef vector<int> VI;\nconst DOUBLE EPS = 1e-20;\nstruct LPSolver {\n\tint m, n; VI B, N; VVD D;\n\tLPSolver(const VVD &A, const VD &b, const VD &c) : m(b.size()), n(c.size()), N(n + 1), B(m), D(m + 2, VD(n + 2)) { for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) D[i][j] = A[i][j]; for (int i = 0; i < m; i++) { B[i] = n + i; D[i][n] = -1; D[i][n + 1] = b[i]; } for (int j = 0; j < n; j++) { N[j] = j; D[m][j] = -c[j]; } N[n] = -1; D[m + 1][n] = 1; }\n\tvoid Pivot(int r, int s) { long double inv = 1.0 / D[r][s]; for (int i = 0; i < m + 2; i++) if (i != r) for (int j = 0; j < n + 2; j++) if (j != s) D[i][j] -= D[r][j] * D[i][s] * inv; for (int j = 0; j < n + 2; j++) if (j != s) D[r][j] *= inv; for (int i = 0; i < m + 2; i++) if (i != r) D[i][s] *= -inv; D[r][s] = inv; swap(B[r], N[s]); }\n\tbool Simplex(int phase) { int x = phase == 1 ? m + 1 : m; while (true) { int s = -1; for (int j = 0; j <= n; j++) { if (phase == 2 && N[j] == -1) continue; if (s == -1 || D[x][j] < D[x][s] || D[x][j] == D[x][s] && N[j] < N[s]) s = j; }if (D[x][s] > -EPS) return true; int r = -1; for (int i = 0; i < m; i++) { if (D[i][s] < EPS) continue; if (r == -1 || D[i][n + 1] / D[i][s] < D[r][n + 1] / D[r][s] || (D[i][n + 1] / D[i][s]) == (D[r][n + 1] / D[r][s]) && B[i] < B[r]) r = i; }if (r == -1) return false; Pivot(r, s); } } \n\tDOUBLE Solve(VD &x) { int r = 0; for (int i = 1; i < m; i++) if (D[i][n + 1] < D[r][n + 1]) r = i; if (D[r][n + 1] < -EPS) { Pivot(r, n); if (!Simplex(1) || D[m + 1][n + 1] < -EPS) return -numeric_limits<DOUBLE>::infinity(); for (int i = 0; i < m; i++) if (B[i] == -1) { int s = -1; for (int j = 0; j <= n; j++) if (s == -1 || D[i][j] < D[i][s] || D[i][j] == D[i][s] && N[j] < N[s]) s = j; Pivot(i, s); } }if (!Simplex(2)) return numeric_limits<DOUBLE>::infinity(); x = VD(n); for (int i = 0; i < m; i++) if (B[i] < n) x[B[i]] = D[i][n + 1]; return D[m][n + 1]; }\n};\n\nint n, m, x[105], y[105];\nll v[105];\n\nvvd A;\nvd b, c, t;\n\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> x[i] >> y[i] >> v[i];\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tt.clear();\n\t\tt.resize(n);\n\t\tt[i] = 1;\n\t\tA.push_back(t);\n\t\tb.push_back(1);\t\t\n\t}\n\tcin >> m;\n\tfor (int i = 0; i < m; ++i) {\n\t\tt.clear();\n\t\tt.resize(n);\n\t\tchar f;\n\t\tint a, bb;\n\t\tcin >> f >> a >> bb;\n\t\tif (f == 'L') {\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\tif (x[j] <= a)\n\t\t\t\t\tt[j] = 1;\n\t\t} if (f == 'R') {\n\t\t\tfor (int j = 0;j < n; ++j)\n\t\t\t\tif (x[j] >= a)\n\t\t\t\t\tt[j] = 1;\n\t\t} if (f == 'U') {\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\tif (y[j] >= a)\n\t\t\t\t\tt[j] = 1;\n\t\t} if (f == 'D') {\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\tif (y[j] <= a)\n\t\t\t\t\tt[j] = 1;\n\t\t}\n\t\tA.push_back(t);\n\t\tb.push_back(bb);\n\t}\n\tc.resize(n);\n\tfor (int i = 0; i < n; ++i)\n\t\tc[i] = v[i];\n\tvd xx;\n\tT val = LPSolver(A, b, c).Solve(xx);\n\tcout << (lround)(val) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<queue>\n#include<vector>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\ntemplate<class T> void read(T &x) {\n\tx=0; int f=1,ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=getchar();}\n\tx*=f;\n}\ntypedef long long ll;\nconst ll inf=1e18;\nconst int maxn=80+5;\nconst int maxm=320+5;\nconst int maxK=maxn;\nconst int maxnode=maxn*2+maxK*2;\nint N,M;\nint st,ed;\nint x[maxn],y[maxn]; ll v[maxn];\nint Lx[maxK],Ly[maxK],Rx[maxK],Ry[maxK];\nchar t[maxm]; int a[maxm],b[maxm];\nstruct edge {\n\tint to,cap; ll cost; int rev;\n\tedge(int to=0,int cap=0,ll cost=0,int rev=0):to(to),cap(cap),cost(cost),rev(rev){}\n};\nvector<edge> adj[maxnode];\ninline void addedge(int u,int v,int c,ll w) {\n\tadj[u].push_back(edge(v,c,w,adj[v].size()));\n\tadj[v].push_back(edge(u,0,-w,adj[u].size()-1));\n}\nnamespace MCMF {\n\tll dis[maxnode]; bool inq[maxnode];\n\tint prev[maxnode],pree[maxnode];\n\tbool SPFA() {\n\t\tqueue<int> q;\n\t\tfor(int i=st;i<=ed;++i) {\n\t\t\tdis[i]=-inf;\n\t\t}\n\t\tdis[st]=0;\n\t\tinq[st]=1;\n\t\tq.push(st);\n\t\twhile(!q.empty()) {\n\t\t\tint u=q.front(); q.pop();\n\t\t\tinq[u]=0;\n\t\t\tfor(unsigned int i=0;i<adj[u].size();++i) {\n\t\t\t\tedge &e=adj[u][i]; if(!e.cap) continue;\n\t\t\t\tif(dis[e.to]<dis[u]+e.cost) {\n\t\t\t\t\tdis[e.to]=dis[u]+e.cost;\n\t\t\t\t\tprev[e.to]=u;\n\t\t\t\t\tpree[e.to]=i;\n\t\t\t\t\tif(!inq[e.to]) {\n\t\t\t\t\t\tq.push(e.to);\n\t\t\t\t\t\tinq[e.to]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dis[ed]!=-inf;\n\t}\n\tvoid maxflow(int &flow,ll &cost) {\n\t\twhile(SPFA()) {\n\t\t\tint delt=1e9;\n\t\t\tfor(int u=ed;u!=st;u=prev[u]) {\n\t\t\t\tedge &e=adj[prev[u]][pree[u]];\n\t\t\t\tdelt=min(delt,e.cap);\n\t\t\t}\n\t\t\tflow+=delt;\n\t\t\tcost+=delt*dis[ed];\n\t\t\tfor(int u=ed;u!=st;u=prev[u]) {\n\t\t\t\tedge &e=adj[prev[u]][pree[u]];\n\t\t\t\te.cap-=delt;\n\t\t\t\tadj[u][e.rev].cap+=delt;\n\t\t\t}\n\t\t}\n\t}\n}\nll sol(int K) {\n\tst=0,ed=K+N+N+K+1;\n\tfor(int i=st;i<=ed;++i) {\n\t\tadj[i].clear();\n\t}\n\tfor(int i=1;i<=K;++i) {\n\t\tLx[i]=Ly[i]=0;\n\t\tRx[i]=Ry[i]=101;\n\t}\n\tfor(int i=1;i<=M;++i) {\n\t\tswitch(t[i]) {\n\t\t\tcase 'L': Lx[b[i]+1]=a[i]+1; break;\n\t\t\tcase 'D': Ly[b[i]+1]=a[i]+1; break;\n\t\t\tcase 'R': if(K>b[i]) Rx[K-b[i]]=a[i]-1; break;\n\t\t\tcase 'U': if(K>b[i]) Ry[K-b[i]]=a[i]-1; break;\n\t\t}\n\t}\n\tfor(int i=1;i<K;++i) {\n\t\tif(Lx[i]>Lx[i+1]) Lx[i+1]=Lx[i];\n\t\tif(Ly[i]>Ly[i+1]) Ly[i+1]=Ly[i];\n\t}\n\tfor(int i=K;i>1;--i) {\n\t\tif(Rx[i]<Rx[i-1]) Rx[i-1]=Rx[i];\n\t\tif(Ry[i]<Ry[i-1]) Ry[i-1]=Ry[i];\n\t}\n\tfor(int i=1;i<=K;++i) {\n\t\taddedge(st,i,1,0);\n\t\tfor(int j=1;j<=N;++j) {\n\t\t\tif(x[j]>=Lx[i]&&x[j]<=Rx[i]) {\n\t\t\t\taddedge(i,K+j,1,0);\n\t\t\t}\n\t\t\tif(y[j]>=Ly[i]&&y[j]<=Ry[i]) {\n\t\t\t\taddedge(K+N+j,K+N+N+i,1,0);\n\t\t\t}\n\t\t}\n\t\taddedge(K+N+N+i,ed,1,0);\n\t}\n\tfor(int i=1;i<=N;++i) {\n\t\taddedge(K+i,K+N+i,1,v[i]);\n\t}\n\tint flow=0; ll cost=0;\n\tMCMF::maxflow(flow,cost);\n\treturn flow==K?cost:-inf;\n}\nint main() {\n\tread(N);\n\tfor(int i=1;i<=N;++i) {\n\t\tread(x[i]),read(y[i]),read(v[i]);\n\t}\n\tread(M);\n\tfor(int i=1;i<=M;++i) {\n\t\tstatic char tmp[5];\n\t\tscanf(\"%s\",tmp);\n\t\tt[i]=tmp[0],read(a[i]),read(b[i]);\n\t}\n\tll an=0;\n\tfor(int i=1;i<=N;++i) {\n\t\tan=max(an,sol(i));\n\t}\n\tprintf(\"%lld\\n\",an);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <sstream>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <cstdlib>\n#include <cstdio>\n#include <iterator>\n#include <functional>\n#include <bitset>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\nclock_t __my_start_clock = clock();\n#else\n#define eprintf(...)\n#endif\n\n#define TIMESTAMP(x) eprintf(\"[\"#x\"] Time : %.3lf s.\\n\", (clock() - __my_start_clock)*1.0/CLOCKS_PER_SEC)\n#define TIMESTAMPf(x,...) eprintf(\"[\" x \"] Time : %.3lf s.\\n\", __VA_ARGS__, (clock() - __my_start_clock)*1.0/CLOCKS_PER_SEC)\n\n#define db(x) cerr << #x << \" = \" << x << endl\n#define db2(x, y) cerr << \"(\" << #x << \", \" << #y << \") = (\" << x << \", \" << y << \")\\n\";\n#define db3(x, y, z) cerr << \"(\" << #x << \", \" << #y << \", \" << #z << \") = (\" << x << \", \" << y << \", \" << z << \")\\n\"\n#define dbv(a) cerr << #a << \" = \"; for (auto xxxx: a) cerr << xxxx << \" \"; cerr << endl\n\n\nusing namespace std;\n\n#ifdef LOCAL\nstatic struct __timestamper {\n  string what;\n  __timestamper(const char* what) : what(what){};\n  __timestamper(const string& what) : what(what){};\n  ~__timestamper(){\n    TIMESTAMPf(\"%s\", what.data());\n\t}\n} __TIMESTAMPER(\"end\");\n#else \nstruct __timestamper {};\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\n\nclass MinCostMaxFlow {\npublic:\n  typedef long long flow_type;\n  typedef long long cost_type;\n  const flow_type FLOW_INF = 1LL << 60;\n  const cost_type COST_INF = 1LL << 60;\nprivate:\n  struct Edge {\n    int to, next;\n    flow_type f, c;\n    cost_type w;\n  };\n\n  int n;\n  vector<int> head;\n  vector<cost_type> phi;\n  vector<Edge> es;\n  cost_type cost;\n\n  cost_type get_cost(int id) {\n    cost_type res = es[id].w - phi[es[id].to] + phi[es[id ^ 1].to];\n    assert(es[id].c > 0 && res >= 0);\n    return res;\n  }\n\n  void pushFlow(int eid, flow_type val) {\n    es[eid].f += val, es[eid].c -= val;\n    es[eid ^ 1].f -= val, es[eid ^ 1].c += val;\n    cost += es[eid].w * val;\n  }\n\n\n  flow_type dijkstra(int s, int t, flow_type limit) {\n    vector<cost_type > d(n, COST_INF);\n    vector<int> pe(n, -1);\n    d[s] = 0;\n\n    priority_queue<pair<cost_type, int>> q;\n    q.push({-d[s], s});\n\n    while (!q.empty()) {\n      auto x = q.top();\n      q.pop();\n\n      int id = x.second;\n      if (x.first != -d[id]) continue;\n\n      for (int e = head[id]; e != -1; e = es[e].next) {\n        if (es[e].c == 0) continue;\n        int to = es[e].to;\n        if (d[to] > d[id] + get_cost(e)) {\n          d[to] = d[id] + get_cost(e);\n          q.push({-d[to], to});\n          pe[to] = e;\n        }\n      }\n    }\n\n    for (int i = 0; i < n; i++) {\n      phi[i] += d[i];\n    }\n\n    if (pe[t] == -1) return 0;\n\n    flow_type res = FLOW_INF;\n    if (limit > 0) res = min(res, limit);\n    int v = t;\n    while (v != s) {\n      res = min(res, es[pe[v]].c);\n      v = es[pe[v] ^ 1].to;\n    }\n    v = t;\n    while (v != s) {\n      pushFlow(pe[v], res);\n      v = es[pe[v] ^ 1].to;\n    }\n    return res;\n  };\n\npublic:\n  explicit MinCostMaxFlow(int n) : n(n), head(n, -1), phi(n, 0), cost(0) {}\n\n  int addEdge(int from, int to, flow_type c, cost_type w) {\n    int id = (int) es.size();\n    es.push_back({to, head[from], 0, c, w});\n    head[from] = id;\n    es.push_back({from, head[to], 0, 0, -w});\n    head[to] = id ^ 1;\n    return id;\n  }\n\n  pair<flow_type, cost_type> getFlow(int s, int t, flow_type k = -1) {\n    flow_type res = 0;\n\n    while (true) {\n      flow_type cur = dijkstra(s, t, k - res);\n      res += cur;\n      if (cur == 0 || res == k) break;\n    }\n\n    return {res, cost};\n  }\n};\n\nclass MinCostLRFlow {\n  MinCostMaxFlow flow;\n  MinCostMaxFlow::flow_type need;\npublic:\n\n  int n;\n  MinCostLRFlow(int n) : flow(n + 2), need(0), n(n) {}\n\n  MinCostMaxFlow::cost_type getFlow(int s, int t) {\n    flow.addEdge(t, s, 10000, 0);\n    auto res = flow.getFlow(n, n + 1);\n    if (res.first != need) {\n      return -1;\n    }\n    return res.second;\n  }\n\n  void addEdge(int from, int to, int l, int r, MinCostMaxFlow::cost_type cost) {\n    assert(0 <= from && from < n);\n    assert(0 <= to && to < n);\n    assert(0 <= l && l <= r);\n//    eprintf(\"[%d, %d] from %d to %d, cost = %lld\\n\", from, to, l, r, cost);\n    if (l < r) {\n      flow.addEdge(from, to, r - l, cost);\n    }\n    if (l) {\n      flow.addEdge(n, to, l, cost);\n      flow.addEdge(from, n + 1, l, 0);\n      need += l;\n    }\n  }\n};\n\nstruct point {\n  int x, y;\n  ll w;\n};\n\nstruct restriction {\n  char ty;\n  int a, b;\n};\n\nint main() {\n#ifdef LOCAL\n  freopen(\"e.in\", \"r\", stdin);\n  freopen(\"e.out\", \"w\", stdout);\n#endif\n\n  int n;\n  while (scanf(\"%d\", &n) == 1) {\n    vector<point> ps(n);\n    for (int i = 0; i < n; i++) {\n      scanf(\"%d%d%lld\", &ps[i].x, &ps[i].y, &ps[i].w);\n    }\n    int m;\n    scanf(\"%d\", &m);\n    vector<restriction> rs(m);\n    for (int i = 0; i < m; i++) {\n      scanf(\" %c%d%d\", &rs[i].ty, &rs[i].a, &rs[i].b);\n    }\n\n    vector<int> xs, ys;\n    ll sum = 0;\n    for (const auto& p : ps) {\n      xs.push_back(p.x);\n      ys.push_back(p.y);\n      sum += p.w;\n    }\n\n    for (const auto& r : rs) {\n      if (r.ty == 'U' || r.ty == 'D') {\n        ys.push_back(r.a);\n      } else {\n        xs.push_back(r.a);\n      }\n    }\n\n    sort(xs.begin(), xs.end()), xs.erase(unique(xs.begin(), xs.end()), xs.end());\n    sort(ys.begin(), ys.end()), ys.erase(unique(ys.begin(), ys.end()), ys.end());\n\n    ll ans = 0;\n    for (int remove = 0; remove <= n; remove++) {\n//      eprintf(\"remove = %d\\n\", remove);\n      MinCostLRFlow flow(2 + 2 * (int)xs.size() + 2 * (int)ys.size());\n      int x_start = 0;\n      int y_start = x_start + (int)xs.size();\n      int x_sum_start = y_start + (int)ys.size();\n      int y_sum_start = x_sum_start + (int)xs.size();\n      int s = y_sum_start + (int)ys.size();\n      int t = s + 1;\n      assert(t == flow.n - 1);\n      for (const auto &p : ps) {\n        int x = lower_bound(xs.begin(), xs.end(), p.x) - xs.begin();\n        int y = lower_bound(ys.begin(), ys.end(), p.y) - ys.begin();\n        flow.addEdge(x, y + y_start, 0, 1, p.w);\n      }\n\n      bool fail = false;\n\n      flow.addEdge(s, y_sum_start - 1, remove, remove, 0);\n      for (int i = 0; i < (int)xs.size(); i++) {\n        flow.addEdge(x_sum_start + i, x_start + i, 0, n, 0);\n        if (i != 0) {\n          int lf = 0;\n          int rg = n;\n\n          int cnt = 0;\n          for (const auto &p : ps) {\n            if (p.x <= xs[i - 1]) {\n              cnt++;\n            }\n          }\n\n          for (const auto& r : rs) {\n            if (r.ty == 'L' && r.a >= xs[i - 1]) {\n              lf = max(lf, cnt - r.b);\n            } else if (r.ty == 'R' && r.a <= xs[i]) {\n              rg = min(rg, r.b + cnt - (n - remove));\n            }\n          }\n\n          if (lf > rg) {\n            fail = true;\n          } else {\n            flow.addEdge(i + x_sum_start, i - 1 + x_sum_start, lf, rg, 0);\n          }\n        }\n      }\n\n      for (int i = 0; i < (int)ys.size(); i++) {\n        flow.addEdge(y_start + i, y_sum_start + i, 0, n, 0);\n        if (i != 0) {\n          int lf = 0;\n          int rg = n;\n          int cnt = 0;\n          for (const auto &p : ps) {\n            if (p.y <= ys[i - 1]) {\n              cnt++;\n            }\n          }\n\n          for (const auto& r : rs) {\n            if (r.ty == 'D' && r.a >= ys[i - 1]) {\n              lf = max(lf, cnt - r.b);\n            } else if (r.ty == 'U' && r.a <= ys[i]) {\n              rg = min(rg, r.b + cnt - (n - remove));\n            }\n          }\n          if (lf > rg) {\n            fail = true;\n          } else {\n            flow.addEdge(i + y_sum_start - 1, i + y_sum_start, lf, rg, 0);\n          }\n        }\n      }\n      flow.addEdge(y_sum_start + (int)ys.size() - 1, t, 0, n, 0);\n\n      if (!fail) {\n        ll res = flow.getFlow(s, t);\n//        eprintf(\"res = %lld\\n\", res);\n        if (res != -1) {\n          ans = max(ans, sum - res);\n        }\n      }\n    }\n    printf(\"%lld\\n\", ans);\n\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define R register\n#define ll long long\n#define INF 333222111666555444ll\n#define cmin(_A, _B) (_A > _B) ? (_A = _B) : 0\n#define cmax(_A, _B) (_A < _B) ? (_A = _B) : 0\n#define MIN(_A, _B) (((_A) < (_B)) ? (_A) : (_B))\n#define MAX(_A, _B) (((_A) > (_B)) ? (_A) : (_B))\n\nint n, m;\n\nstruct Point{\n\tint x, y;\n\tll v;\n}p[88];\n\nstruct Opt{\n\tchar op;\n\tint a, b;\n}d[333];\n\n\nstruct Flow{\n\tint cnt;\n\tint cntp;\n\tint S, T;\n\tint fr[333];\n\tint cur[333];\n\tint ne[66666];\n\tint to[66666];\n\tint c[66666];\n\tll w[66666];\n\t\n\tvoid add(R int a, R int b, R int v, R ll co){\n//\t\tprintf(\"%d %d %d %lld\\n\", a, b, v, co);\n\t\tne[++cnt] = fr[a], fr[a] = cnt, to[cnt] = b, c[cnt] = v, w[cnt] = co;\n\t\tne[++cnt] = fr[b], fr[b] = cnt, to[cnt] = a, c[cnt] = 0, w[cnt] = -co;\n\t}\n\t\n\tll dis[333];\n\tbool vis[333];\n\tint q[66666];\n\tunsigned short head, tail;\n\tbool spfa(){\n\t\thead = tail = 0;\n\t\tmemset(vis, 0, sizeof(vis));\n\t\tmemset(dis, 63, sizeof(dis));\n\t\tq[++tail] = S, dis[S] = 0;\n\t\twhile(head != tail){\n\t\t\tR int now = q[++head];\n//\t\t\tprintf(\"%d\\n\", now);\n\t\t\tvis[now] = false;\n\t\t\tfor(R int i = fr[now]; i; i = ne[i]){\n\t\t\t\tif(c[i] && dis[now] + w[i] < dis[to[i]]){\n\t\t\t\t\tdis[to[i]] = dis[now] + w[i];\n\t\t\t\t\tif(!vis[to[i]]) vis[to[i]] = true, q[++tail] = to[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tputs(\"ga\");\n\t\tif(dis[T] > INF) return false;\n\t\treturn true;\n\t}\n\t\n\tll tans;\n\tint dfs(int a, int flow){\n\t\tif(a == T) return flow;\n\t\tvis[a] = true;\n\t\tint f = flow, tmp;\n\t\tfor(int &i = cur[a]; i; i = ne[i]){\n\t\t\tif(!vis[to[i]] && c[i] && dis[to[i]] == dis[a] + w[i] && (tmp = dfs(to[i], MIN(f, c[i])))){\n\t\t\t\tc[i] -= tmp, c[i ^ 1] += tmp, f -= tmp, tans += w[i] * tmp;\n\t\t\t\tif(!f) {vis[a] = false; return flow;}\n\t\t\t}\n\t\t}\n\t\tvis[a] = false;\n\t\treturn flow - f;\n\t}\n\t\n\tint main(){\n\t\ttans = 0;\n\t\tR int tmp = 0;\n\t\twhile(spfa()){\n\t\t\tfor(R int i = 1; i <= cntp; i++) cur[i] = fr[i];\n\t\t\ttmp += dfs(S, 666);\n\t\t}\n\t\treturn tmp;\n\t}\n\t\n\tint mxx[88], mxy[88];\n\tint mnx[88], mny[88];\n\tbool build(int k){\n\t//\tprintf(\"%d\\n\", k);\n\t\tcnt = 1, cntp = 0;\n\t\tmemset(fr, 0, sizeof(fr));\n\t\tfor(R int i = 1; i <= k; i++)\n\t\t\tmxx[i] = mxy[i] = 101, mnx[i] = mny[i] = 0;\n\t\tfor(R int i = 1; i <= m; i++){\n\t\t\tif(d[i].b >= k) continue;\n\t\t\tif(d[i].op == 'L') cmax(mnx[d[i].b + 1], d[i].a);\n\t\t\tif(d[i].op == 'R') cmin(mxx[k - d[i].b], d[i].a);\n\t\t\tif(d[i].op == 'D') cmax(mny[d[i].b + 1], d[i].a);\n\t\t\tif(d[i].op == 'U') cmin(mxy[k - d[i].b], d[i].a);\n\t\t}\n\t\tfor(R int i = 2; i <= k; i++)\n\t\t\tcmax(mnx[i], mnx[i - 1]),\n\t\t\tcmax(mny[i], mny[i - 1]);\n\t\tfor(R int i = k - 1; i; i--)\n\t\t\tcmin(mxx[i], mxx[i + 1]),\n\t\t\tcmin(mxy[i], mxy[i + 1]);\n\t\tfor(R int i = 1; i <= k; i++)\n\t\t\tif(mxx[i] - mnx[i] < 2 || mxy[i] - mny[i] < 2) return false;\n\t\tfor(R int i = 1; i <= n; i++) add(i, i + n, 1, p[i].v);\n\t\tfor(R int i = 1; i <= k; i++){\n\t\t\tfor(R int j = 1; j <= n; j++){\n\t\t\t\tif(p[j].x > mnx[i] && p[j].x < mxx[i])\n\t\t\t\t\tadd(2 * n + i, j, 1, 0);\n\t\t\t\tif(p[j].y > mny[i] && p[j].y < mxy[i])\n\t\t\t\t\tadd(j + n, 2 * n + k + i, 1, 0);\n\t\t\t}\n\t\t}\n\t\tcntp = 2 * n + 2 * k;\n\t\tS = ++cntp, T = ++cntp;\n\t\tfor(R int i = 1; i <= k; i++) add(S, 2 * n + i, 1, 0), add(2 * n + k + i, T, 1, 0);\n\t\treturn true;\n\t}\n}A;\n\nint main(){\n\tll ans = 0;\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i <= n; i++)\n\t\tscanf(\"%d %d %lld\", &p[i].x, &p[i].y, &p[i].v), p[i].v = -p[i].v;\n\tscanf(\"%d\", &m);\n\tchar tch[3];\n\tfor(R int i = 1; i <= m; i++){\n\t\tscanf(\"%s\", tch + 1);\n\t\tscanf(\"%d %d\", &d[i].a, &d[i].b);\n\t\td[i].op = tch[1];\n\t}\n\tfor(R int i = 1; i <= n; i++){\n\t\tif(A.build(i)){\n\t\t\tif(A.main() != i) break;\n\t\t\tans = MIN(ans, A.tans);\n\t\t}\n\t\telse break;\n\t}\n\tprintf(\"%lld\\n\", -ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing cap_t = int;\nusing cost_t = long long;\n\nconst cap_t cap_inf = 0x3f3f3f3f;\nconst cost_t cost_inf = 1ll << 60;\n\nnamespace flow {\nstruct edge {\n  int to, rev;\n  cost_t cost;\n  cap_t cap;\n\n  edge(int t, cap_t c, cost_t w, int r) {\n    to = t;\n    rev = r;\n    cap = c;\n    cost = w;\n  }\n};\n\nvector<vector<edge>> adj;\nvector<cost_t> dist;\nint n, source, sink;\nvector<bool> visit;\nvector<int> cur;\ncost_t res;\ncap_t ans;\n\nvoid init(int v, int s, int t) {\n  n = v;\n  ans = res = 0;\n  source = s;\n  sink = t;\n  adj.clear();\n  adj.resize(n);\n  cur.resize(n);\n  dist.resize(n);\n  visit.resize(n);\n}\n\nvoid add(int x, int y, cap_t c, cost_t w) {\n  adj[x].emplace_back(y, c, w, adj[y].size());\n  adj[y].emplace_back(x, 0, -w, adj[x].size() - 1);\n}\n\nbool spfa() {\n  queue<int> q;\n  for (int i = 0; i < n; ++i) {\n    dist[i] = cost_inf;\n    visit[i] = false;\n    cur[i] = 0;\n  }\n  dist[source] = 0;\n  q.push(source);\n  while (!q.empty()) {\n    int x = q.front();\n    q.pop();\n    visit[x] = false;\n    for (auto e : adj[x]) {\n      if (e.cap && dist[e.to] > dist[x] + e.cost) {\n        dist[e.to] = dist[x] + e.cost;\n        if (!visit[e.to]) {\n          visit[e.to] = true;\n          q.push(e.to);\n        }\n      }\n    }\n  }\n  return dist[sink] != cost_inf;\n}\n\ncap_t dfs(int x, cap_t f) {\n  if (x == sink) {\n    return f;\n  }\n  visit[x] = true;\n  cap_t res = 0;\n  for (int &i = cur[x]; i < (int) adj[x].size(); ++i) {\n    edge &e = adj[x][i];\n    if (e.cap && dist[e.to] == dist[x] + e.cost && !visit[e.to]) {\n      cap_t w = dfs(e.to, min(e.cap, f - res));\n      res += w;\n      e.cap -= w;\n      adj[e.to][e.rev].cap += w;\n      if (res == f) {\n        visit[x] = false;\n        return res;\n      }\n    }\n  }\n  dist[x] = cost_inf;\n  return res;\n}\n\npair<cap_t, cost_t> min_cost_max_flow() {\n  while (spfa()) {\n    cap_t flow = dfs(source, cap_inf);\n    ans += flow;\n    res += flow * dist[sink];\n  }\n  return make_pair(ans, res);\n}\n}\n\nusing flow::source;\nusing flow::sink;\nusing flow::init;\nusing flow::add;\nusing flow::min_cost_max_flow;\n\nconst int MAX = 100;\n\nint main() {\n#ifdef wxh010910\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  int n;\n  cin >> n;\n  vector<int> x(n), y(n);\n  vector<long long> z(n);\n  for (int i = 0; i < n; ++i) {\n    cin >> x[i] >> y[i] >> z[i];\n  }\n  vector<int> l(MAX, n), r(MAX, n), d(MAX, n), u(MAX, n);\n  int m;\n  cin >> m;\n  while (m--) {\n    string type;\n    int a, b;\n    cin >> type >> a >> b;\n    --a;\n    if (type == \"L\") {\n      l[a] = b;\n    } else if (type == \"R\") {\n      r[a] = b;\n    } else if (type == \"D\") {\n      d[a] = b;\n    } else {\n      u[a] = b;\n    }\n  }\n  for (int i = MAX - 2; ~i; --i) {\n    l[i] = min(l[i], l[i + 1]);\n    d[i] = min(d[i], d[i + 1]);\n  }\n  for (int i = 1; i < MAX; ++i) {\n    r[i] = min(r[i], r[i - 1]);\n    u[i] = min(u[i], u[i - 1]);\n  }\n  long long ans = 0;\n  auto solve = [&](int take) {\n    init(MAX * 2 + 4, MAX * 2 + 2, MAX * 2 + 3);\n    add(source, 0, take, 0);\n    add(MAX + 1, sink, take, 0);\n    int need = take;\n    for (int i = 0; i < MAX; ++i) {\n      int low = max(0, take - l[max(i - 1, 0)]);\n      int high = r[i];\n      if (low > high) {\n        return;\n      }\n      add(i, i + 1, high - low, 0);\n      add(source, i + 1, low, 0);\n      add(i, sink, low, 0);\n      need += low;\n    }\n    for (int i = 0; i < MAX; ++i) {\n      int low = max(0, take - d[max(i - 1, 0)]);\n      int high = u[i];\n      if (low > high) {\n        return;\n      }\n      add(MAX + i + 2, MAX + i + 1, high - low, 0);\n      add(source, MAX + i + 1, low, 0);\n      add(MAX + i + 2, sink, low, 0);\n      need += low;\n    }\n    for (int i = 0; i < n; ++i) {\n      add(x[i], MAX + y[i] + 1, 1, -z[i]);\n    }\n    pair<int, long long> res = min_cost_max_flow();\n    if (res.first == need) {\n      ans = max(ans, -res.second);\n    }\n  };\n  for (int i = 1; i <= n; ++i) {\n    solve(i);\n  }\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<iomanip>\n#include<ctime>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#define sqr(x) ((x)*(x))\n#define fz1(i,n) for ((i)=1;(i)<=(n);(i)++)\n#define fd1(i,n) for ((i)=(n);(i)>=1;(i)--)\n#define fz0g(i,n) for ((i)=0;(i)<=(n);(i)++)\n#define fd0g(i,n) for ((i)=(n);(i)>=0;(i)--)\n#define fz0k(i,n) for ((i)=0;(i)<(n);(i)++)\n#define fd0k(i,n) for ((i)=(long long)((n)-1);(i)>=0;(i)--)\n#define fz(i,x,y) for ((i)=(x);(i)<=(y);(i)++)\n#define fd(i,y,x) for ((i)=(y);(i)>=(x);(i)--)\n#define fzin fz1(i,n)\n#define fzim fz1(i,m)\n#define fzjn fz1(j,n)\n#define fzjm fz1(j,m)\n#define ff(c,itr) for (__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n#define rdst(st,len){static char ss[len];scanf(\" %s\",ss);(st)=ss;}\n//#define T_ long long\nusing namespace std;\n//struct bit{T_ arr[1000005];long long lowbit(long long x){return x&(-x);}void add(long long x,T_ y){for (long long i=x;i<=n;i+=lowbit(i)) arr[i]+=y;}T_ query(long long x){T_ s=0;for (long long i=x;i>0;i-=lowbit(i)) s+=arr[i];return s;}};\n//struct seg{struct treedot{long long l,r;T_ sum,add;void update(T_ x){sum+=(r-l+1)*x; add+=x;}}c[800005];void pushdown(long long id){if (c[id].add){c[id*2].update(c[id].add);c[id*2+1].update(c[id].add);c[id].add=0;}}void pushup(long long id){c[id].sum=c[id*2].sum+c[id*2+1].sum;}void build(long long id,long long l,long long r){if (l>r) return;c[id].l=l;c[id].r=r;c[id].sum=0;c[id].add=0;if (l==r) c[id].sum=0;else{long long mid=l+(r-l)/2;build(id*2,l,mid);build(id*2+1,mid+1,r);pushup(id);}}void update(long long id,long long le,long long ri,T_ x){if (le>c[id].r||ri<c[id].l) return;if (le<=c[id].l&&c[id].r<=ri) c[id].update(x);else{pushdown(id);update(id*2,le,ri,x);update(id*2+1,le,ri,x);pushup(id);}}T_ query(long long id,long long le,long long ri){if (ri<c[id].l||c[id].r<le) return 0;if (le<=c[id].l&&c[id].r<=ri) return c[id].sum;T_ ans=0;pushdown(id);ans+=query(id*2,le,ri);ans+=query(id*2+1,le,ri);pushup(id);return ans;}};\n//struct bit_2d{T_ a[2005][2005];long long lowbit(long long x){return x&(-x);}void add(long long x,long long y,T_ z){long long i,j;for (i=x;i<=2000;i+=lowbit(i)){for (j=y;j<=2000;j+=lowbit(j)){a[i][j]+=z;}}}T_ query(long long x,long long y){long long i,j;T_ s=0;for (i=x;i;i-=lowbit(i)){for (j=y;j;j-=lowbit(j)){s+=a[i][j];}}return s;}T_ query(long long x,long long y,long long xx,long long yy){return query(xx,yy)-query(x-1,yy)-query(xx,y-1)+query(x-1,y-1);}};\nlong long n,m,i,j,k,dis[325],cnt,a[325],b[325],v[325],s=0,t=321,l[325],r[325],u[325],d[325],x,y,cst,inq[325],vis[325],ans;\nvector<long long> allx,ally;\nchar c[325],ca[325],cb[325];\nstruct ii\n{\n\tlong long y,z,d;\n}e[10005];\nvector<long long> bi[10005];\nvoid init()\n{\n\tint i;fz0g(i,321) bi[i].clear();cnt=0;\n}\nvoid add(long long x,long long y,long long z,long long d)\n{\n\tcnt++;bi[x].push_back(cnt*2-2);bi[y].push_back(cnt*2-1);\n\te[cnt*2-2]=(ii){y,z,d};e[cnt*2-1]=(ii){x,0,-d};\n}\nbool bfs(long long s,long long t)\n{\n\tmemset(dis,-0x18,sizeof(dis));dis[s]=0;queue<long long> qx;qx.push(s);inq[s]=1;\n\twhile (!qx.empty()){\n\t\tlong long x=qx.front();qx.pop();inq[x]=0;ff(bi[x],it) if (e[*it].z){\n\t\t\tlong long y=e[*it].y,z=dis[x]+e[*it].d;\n\t\t\tif (dis[y]<z){\n\t\t\t\tdis[y]=z;\n\t\t\t\tif (!inq[y]){\n\t\t\t\t\tinq[y]=1;qx.push(y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}return dis[t]>dis[324];\n}\nlong long dfs(long long x,long long tt,long long flw)\n{\n\tif (!flw) return 0;\n\tif (x==tt) {vis[x]=1;return flw;}\n\tif (vis[x]) return 0;\n\tvis[x]=1;\n\tvis[x]=1;long long ans=0;ff(bi[x],it) if (e[*it].z&&dis[e[*it].y]==dis[x]+e[*it].d){\n\t\tlong long t=dfs(e[*it].y,tt,min(flw,e[*it].z));cst+=t*e[*it].d;ans+=t;flw-=t;e[*it].z-=t;e[(*it)^1].z+=t;if (!flw) break;\n\t}return ans;\n}\nbool dinic(long long s,long long t,long long aa)\n{\n\tlong long ans=0;while (bfs(s,t)){\n\t\tdo{\n\t\t\tmemset(vis,0,sizeof(vis));\n\t\t\tans+=dfs(s,t,aa);\n\t\t}while (vis[t]);\n\t}if (ans==aa) return 1;return 0;\n}\nint main()\n{\n\tscanf(\"%lld\",&n);\n\tfz1(i,n){\n\t\tscanf(\"%lld%lld%lld\",&a[i],&b[i],&v[i]);\n//\t\tallx.push_back(a[i]);ally.push_back(b[i]);\n\t}//sort(allx.begin(),allx.end());allx.resize(unique(allx.begin(),allx.end())-allx.begin());sort(ally.begin(),ally.end());ally.resize(unique(ally.begin(),ally.end())-ally.begin());\n\t/*fz1(i,n){\n\t\ta[i]=upper_bound(allx.begin(),allx.end(),a[i])-allx.begin();\n\t\tb[i]=upper_bound(ally.begin(),ally.end(),b[i])-ally.begin();\n\t}*/\n\tscanf(\"%lld\",&m);fz1(i,m){\n\t\tscanf(\" %c%lld%lld\",&c[i],&ca[i],&cb[i]);\n\t}\n\tans=0;\n\tfz1(i,n){\n\t\tcst=0;init();\n\t\tfz1(j,i){\n\t\t\tl[i]=d[i]=0;\n\t\t\tr[i]=u[i]=0x1818181818181818ll;\n\t\t}\n\t\tfz1(j,m) if (cb[j]<i){\n\t\t\tif (c[j]=='L') l[cb[j]+1]=max(l[cb[j]+1],ca[j]+1ll);\n\t\t\tif (c[j]=='R') r[i-cb[j]]=min(r[i-cb[j]],ca[j]-1ll);\n\t\t\tif (c[j]=='D') d[cb[j]+1]=max(d[cb[j]+1],ca[j]+1ll);\n\t\t\tif (c[j]=='U') u[i-cb[j]]=min(u[i-cb[j]],ca[j]-1ll);\n\t\t}\n\t\tfz(j,2,i){\n\t\t\tl[j]=max(l[j],l[j-1]);\n\t\t\td[j]=max(d[j],d[j-1]);\n\t\t}\n\t\tfd(j,i-1,1){\n\t\t\tr[j]=min(r[j],r[j+1]);\n\t\t\tu[j]=min(u[j],u[j+1]);\n\t\t}\n\t\tfz1(j,i)fz1(k,n){\n\t\t\tif (l[j]<=a[k]&&a[k]<=r[j]){\n\t\t\t\tadd(j,n+k,1,0);\n\t\t\t}\n\t\t\tif (d[j]<=b[k]&&b[k]<=u[j]){\n\t\t\t\tadd(n+n+k,n+n+n+j,1,0);\n\t\t\t}\n\t\t}\n\t\tfz1(j,i){\n\t\t\tadd(s,j,1,0);add(n+n+n+j,t,1,0);\n\t\t}fz1(j,n){\n\t\t\tadd(j+n,j+n+n,1,v[j]);\n\t\t}if (dinic(s,t,i)) ans=max(ans,cst);\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define ll long long\n#define inf 0x3f3f3f3f3f3f3f3f\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\nchar buf[1<<21],*p1=buf,*p2=buf;\ninline char getc(){return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;}\nll read(){\n    R ll res,f=1;R char ch;\n    while((ch=getc())>'9'||ch<'0')(ch=='-')&&(f=-1);\n    for(res=ch-'0';(ch=getc())>='0'&&ch<='9';res=res*10+ch-'0');\n    return res*f;\n}\ninline char getop(){R char ch;while((ch=getc())>'Z'||ch<'A');return ch;}\nconst int N=505;\nstruct eg{int v,nx,w;ll c;}e[N*N];int head[N],tot;\ninline void add(R int u,R int v,R ll c){\n\te[++tot]={v,head[u],1,c},head[u]=tot,\n\te[++tot]={u,head[v],0,-c},head[v]=tot;\n}\nint x[N],y[N],a[N],b[N],t[N],LL[N],RR[N],DD[N],UU[N],vis[N],pe[N],n,m,S,T;\nll v[N],dis[N],res,ans;queue<int>q;\nbool spfa(){\n\tmemset(dis,0x3f,sizeof(dis));\n\tdis[S]=0,q.push(S);\n\twhile(!q.empty()){\n\t\tint u=q.front();q.pop(),vis[u]=0;\n\t\tgo(u)if(e[i].w&&(cmin(dis[v],dis[u]+e[i].c)?pe[v]=i,1:0)&&!vis[v])q.push(v),vis[v]=1;\n\t}\n\tif(dis[T]==inf)return false;\n\tres+=dis[T];\n\tfor(R int i=T;i!=S;i=e[pe[i]^1].v)--e[pe[i]].w,++e[pe[i]^1].w;\n\treturn true;\n}\nll calc(int k){\n\tfp(i,1,k)LL[i]=DD[i]=0,RR[i]=UU[i]=19260817;\n\tfp(i,1,m)if(b[i]<k){\n\t\tswitch(t[i]){\n\t\t\tcase 'L':LL[b[i]+1]=a[i]+1;break;\n\t\t\tcase 'R':RR[k-b[i]]=a[i]-1;break;\n\t\t\tcase 'D':DD[b[i]+1]=a[i]+1;break;\n\t\t\tcase 'U':UU[k-b[i]]=a[i]-1;break;\n\t\t}\n\t}\n\tfp(i,2,k)cmax(LL[i],LL[i-1]),cmax(DD[i],DD[i-1]);\n\tfd(i,k-1,1)cmin(RR[i],RR[i+1]),cmin(UU[i],UU[i+1]);\n\tmemset(head,0,sizeof(head)),tot=1;\n\tS=0,T=(n+k)<<1|1;\n\tfp(i,1,n)add(i,n+i,-v[i]);\n\tfp(i,1,k){\n\t\tadd(S,n+n+i,0),add(n+n+k+i,T,0);\n\t\tfp(j,1,n){\n\t\t\tif(x[j]>=LL[i]&&x[j]<=RR[i])add(n+n+i,j,0);\n\t\t\tif(y[j]>=DD[i]&&y[j]<=UU[i])add(n+j,n+n+k+i,0);\n\t\t}\n\t}\n\tres=0;while(spfa());\n\treturn -res;\n}\nint main(){\n//\tfreopen(\"testdata.in\",\"r\",stdin);\n\tn=read();\n\tfp(i,1,n)x[i]=read(),y[i]=read(),v[i]=read();\n\tm=read();\n\tfp(i,1,m)t[i]=getop(),a[i]=read(),b[i]=read();\n\tfp(i,1,n)cmax(ans,calc(i));\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n#define MP make_pair\n#define PB push_back\n#define int long long\n#define st first\n#define nd second\n#define rd third\n#define FOR(i, a, b) for(int i =(a); i <=(b); ++i)\n#define RE(i, n) FOR(i, 1, n)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define REP(i, n) for(int i = 0;i <(n); ++i)\n#define VAR(v, i) __typeof(i) v=(i)\n#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define __builtin_ctz __builtin_ctzll\n#define __builtin_clz __builtin_clzll\n#define __builtin_popcount __builtin_popcountll\nusing namespace std;\ntemplate<typename TH> void _dbg(const char* sdbg, TH h) { cerr<<sdbg<<\"=\"<<h<<\"\\n\"; }\ntemplate<typename TH, typename... TA> void _dbg(const char* sdbg, TH h, TA... t) {\n  while(*sdbg != ',') { cerr<<*sdbg++; } cerr<<\"=\"<<h<<\",\"; _dbg(sdbg+1, t...);\n}\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#define debugv(x) {{cerr <<#x <<\" = \"; FORE(itt, (x)) cerr <<*itt <<\", \"; cerr <<\"\\n\"; }}\n#else\n#define debug(...) (__VA_ARGS__)\n#define debugv(x)\n#define cerr if(0)cout\n#endif\n#define next ____next\n#define prev ____prev\n#define left ____left\n#define hash ____hash\ntypedef long long ll;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\ntypedef vector<pair<int, int> > VPII;\ntypedef vector<pair<ll, ll> > VPLL;\n\ntemplate<class C> void mini(C&a4, C b4){a4=min(a4, b4); }\ntemplate<class C> void maxi(C&a4, C b4){a4=max(a4, b4); }\ntemplate<class T1, class T2>\nostream& operator<< (ostream &out, pair<T1, T2> pair) { return out << \"(\" << pair.first << \", \" << pair.second << \")\";}\ntemplate<class A, class B, class C> struct Triple { A first; B second; C third;\n  bool operator<(const Triple& t) const { if (st != t.st) return st < t.st; if (nd != t.nd) return nd < t.nd; return rd < t.rd; } };\ntemplate<class T> void ResizeVec(T&, vector<int>) {}\ntemplate<class T> void ResizeVec(vector<T>& vec, vector<int> sz) {\n  vec.resize(sz[0]); sz.erase(sz.begin()); if (sz.empty()) { return; }\n  for (T& v : vec) { ResizeVec(v, sz); }\n}\ntypedef Triple<int, int, int> TIII;\ntemplate<class A, class B, class C>\nostream& operator<< (ostream &out, Triple<A, B, C> t) { return out << \"(\" << t.st << \", \" << t.nd << \", \" << t.rd << \")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, vector<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, set<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class L, class R> ostream& operator<<(ostream& out, map<L, R> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\n\nstruct Simplex {        // Maximize c*x subject to Ax <= b.\n  using T = LD;     // Initialize the structure, set A, b, c and then run\n  vector<vector<T>> A;  // solve(). Max objective is stored in res. To recover\n  vector<T> b, c;       // the best result, use getVars().\n  \n  int V, E;\n  VI eqIds, varIds, cols;\n  T res;\n  const T kEps = 1e-9;\n  \n  Simplex(int vars, int eqs) : A(eqs, vector<T>(vars)), b(eqs), c(vars),\n  V(vars), E(eqs), eqIds(eqs), varIds(vars), res(0) {\n    iota(ALL(varIds), 0); iota(ALL(eqIds), vars);\n  }\n  \n  void pivot(int eq, int var) {\n    T coef = 1 / A[eq][var];\n    cols.clear();\n    REP (i, V) {\n      if (abs(A[eq][i]) > kEps) { cols.PB(i); A[eq][i] *= coef; }\n    }\n    A[eq][var] *= coef; b[eq] *= coef;\n    REP (row, E) {\n      if (row == eq || abs(A[row][var]) < kEps) { continue; }\n      T k = -A[row][var];\n      A[row][var] = 0;\n      for (int i : cols) { A[row][i] += k * A[eq][i]; }\n      b[row] += k * b[eq];\n    }\n    T q = c[var]; c[var] = 0;\n    for (int i : cols) { c[i] -= q * A[eq][i]; }\n    res += q * b[eq];\n    \n    swap(varIds[var], eqIds[eq]);\n  }\n  \n  bool solve() {\n    while (true) {\n      int eq = -1, var = -1;\n      REP (i, E) { if (b[i] < -kEps) { eq = i; break; } }\n      if (eq == -1) { break; }\n      REP (i, V) { if (A[eq][i] < -kEps) { var = i; break; } }\n      if (var == -1) { res = -1e9; return false; /* No solution */ }\n      pivot(eq, var);\n    }\n    \n    while (true) {\n      int var = -1, eq = -1;\n      REP (i, V) { if (c[i] > kEps) { var = i; break; } }\n      if (var == -1) { break; }\n      REP (i, E) {\n        if (A[i][var] < kEps) { continue; }\n        if (eq >= 0 && b[i] / A[i][var] >= b[eq] / A[eq][var]) { continue; }\n        eq = i;\n      }\n      if (eq == -1) { res = 1e9; return false; /* Unbounded */ }\n      pivot(eq, var);\n    }\n    \n    return true;\n  }\n  \n  vector<T> getVars() {  // Optimal assignment of variables.\n    vector<T> result(V);\n    REP (i, E) { if (eqIds[i] < V) { result[eqIds[i]] = b[i]; } }\n    return result;\n  }\n};\n\n\nconst int N = 333;\nint x[N];\nint y[N];\nint v[N];\n\nint32_t main() {\n\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(10);\n  cerr << fixed << setprecision(10);\n  cin.tie(0);\n  //double beg_clock = 1.0 * clock() / CLOCKS_PER_SEC;\n  \n  int n;\n  cin>>n;\n  REP (i, n) {\n    cin>>x[i]>>y[i]>>v[i];\n    //sim.c.PB(v[i]);\n  }\n  int m;\n  cin>>m;\n  \n  Simplex sim(n, m + 2 * n);\n  REP (i, n) {\n    sim.c[i] = v[i];\n  }\n  REP (j, m) {\n    char t;\n    cin>>t;\n    int a, b;\n    cin>>a>>b;\n    sim.b[j]= b;\n    vector<LD> A;\n    REP (i, n) {\n      if ((t == 'L' && x[i] <= a) || (t == 'R' && x[i] >= a) || (t == 'U' && y[i] >= a) || (t == 'D' && y[i] <= a)) {\n        A.PB(1);\n      } else {\n        A.PB(0);\n      }\n    }\n    sim.A[j] = A;\n  }\n  REP (i, n) {\n    sim.b[m + 2 * i] = 1;\n    sim.b[m + 2 * i + 1] = 0;\n    sim.A[m + 2 * i][i] = 1;\n    sim.A[m + 2 * i + 1][i] = -1;\n  }\n  sim.solve();\n  debug(sim.res);\n  vector<LD> vars = sim.getVars();\n  debug(vars);\n  int R = 0;\n  REP (i, n) {\n    if (vars[i] > 0.5) {\n      R += v[i];\n    }\n  }\n  cout<<R<<endl;\n    \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>/*{{{*/\n#include<cctype>\n#include<cassert>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<ctime>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<set>\n#include<vector>\nusing namespace std;\ntypedef pair<int,int> pii;\n#define fi first\n#define se second\n#define pb push_back\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define ROF(i,a,b) for(int i=(a);i>=(b);--i)\nnamespace RA{\n    int r(int p){return 1ll*rand()*rand()%p;}\n    int r(int L,int R){return r(R-L+1)+L;}\n}/*}}}*/\n/******************heading******************/\ntypedef long long LL;\nconst LL LLINF=0x3f3f3f3f3f3f3f3f;\nconst int N=330,INF=0x3f3f3f3f;\n\nint s,t;\nstruct qxx{int nex,t,v;LL c;};\nqxx e[N*N*4];\nLL h[N],hh[N],le=1;\nvoid add_path(int f,int t,int v,LL c){e[++le]=(qxx){h[f],t,v,c},h[f]=le;}\nvoid add_flow(int f,int t,int v,LL c){\n    //printf(\"add_flow(%d,%d,%d,%lld)\\n\",f,t,v,c);\n    add_path(f,t,v,c),add_path(t,f,0,-c);}\n#define FORe(i,_u,_v,_w,_c)     for(LL i=h[_u],_v,_w,_c;_v=e[i].t,_w=e[i].v,_c=e[i].c,i;i=e[i].nex)\n#define FORflowe(i,_u,_v,_w,_c) for(LL &i=hh[_u],_v,_w,_c;_v=e[i].t,_w=e[i].v,_c=e[i].c,i;i=e[i].nex)\n\nint n,m;\nint x[N],y[N];\nLL val[N],ans=-LLINF;\nint xL[N],xR[N],yL[N],yR[N];\n\nvector<pii> L,R,U,D;\n\nqueue<int> q;\nbool vising[N];\nLL d[N];\nbool spfa(){\n    memset(d,0x3f,sizeof(d));\n    q.push(s),d[s]=0;\n    while(!q.empty()){\n        int u=q.front();q.pop();\n        vising[u]=0;\n        FORe(i,u,v,w,c){\n            if(!w||d[v]<=d[u]+c)continue;\n            d[v]=d[u]+c;\n            if(!vising[v])q.push(v),vising[v]=1;\n        }\n    }\n    return d[t]!=LLINF;\n}\nLL mincost;\nbool vis[N];\nint dfs(int u,int flow){\n    //printf(\"dfs(%d,%d)\\n\",u,flow);\n    vis[u]=1;\n    if(u==t)return flow;\n    int rest=flow;\n    FORflowe(i,u,v,w,c){\n        if(!rest)break;\n        if(vis[v]&&v!=t||!w||d[v]!=d[u]+c)continue;\n        int k=dfs(v,min(w,1ll*rest));\n        if(k)mincost+=k*c,e[i].v-=k,e[i^1].v+=k,rest-=k;\n        else d[v]=0;\n    }\n    return flow-rest;\n}\nLL go(){\n    int maxflow=0;\n    while(spfa()){\n        //puts(\"GG\");\n        memcpy(hh,h,sizeof(h));\n        for(int i;memset(vis,0,sizeof(vis)),(i=dfs(s,INF))&&vis[t];)maxflow+=i;\n    }\n    //printf(\"maxflow=%d,mincost=%lld\\n\",maxflow,mincost);\n    return mincost;\n}\nvoid init(){\n    memset(h,0,sizeof(h));\n    le=1,mincost=0;\n}\nvoid calc(int k){\n    //printf(\"calc(%d)\\n\",k);\n    for(pii x:L)xL[x.se+1]=x.fi+1; //x[b+1] >= a+1\n    for(pii x:R)xR[k-x.se]=x.fi-1; //x[k-b] <= a-1\n    for(pii x:D)yL[x.se+1]=x.fi+1;\n    for(pii x:U)yR[k-x.se]=x.fi-1;\n    xR[k+1]=INF;\n    FOR(i,1,k)if(!xL[i])xL[i]=xL[i-1];\n    ROF(i,k,1)if(!xR[i])xR[i]=xR[i+1];\n    yR[k+1]=INF;\n    FOR(i,1,k)if(!yL[i])yL[i]=yL[i-1];\n    ROF(i,k,1)if(!yR[i])yR[i]=yR[i+1];\n    //FOR(i,1,k)printf(\"[%d,%d]%c\",xL[i],xR[i],\" \\n\"[i==k]);\n    //FOR(i,1,k)printf(\"[%d,%d]%c\",yL[i],yR[i],\" \\n\"[i==k]);\n\n    // item: 1 - n, n+1 - 2n\n    // x : 2n+1 - 2n+k\n    // y : 2n+k+1 - 2n+2k\n    // s : 0\n    // t : 2n+2k+1\n    init();\n    s=0,t=2*n+2*k+1;\n    //printf(\"s=%d,t=%d\\n\",s,t);\n    FOR(i,1,k)add_flow(s,2*n+i,1,0);\n    FOR(i,1,k)FOR(j,1,n)if(xL[i]<=x[j]&&x[j]<=xR[i])add_flow(2*n+i,j,INF,0);\n    FOR(i,1,n)add_flow(i,i+n,1,-val[i]);\n    FOR(i,1,k)FOR(j,1,n)if(yL[i]<=y[j]&&y[j]<=yR[i])add_flow(j+n,2*n+k+i,INF,0);\n    FOR(i,1,k)add_flow(2*n+k+i,t,1,0);\n\n    LL res=go();\n    ans=max(ans,-res);\n}\n\nint main(){\n    scanf(\"%d\",&n);\n    FOR(i,1,n)scanf(\"%d%d%lld\",&x[i],&y[i],&val[i]);\n    scanf(\"%d\",&m);\n    FOR(i,1,m){\n        char t[10];\n        int a,b;\n        scanf(\"%s%d%d\",t,&a,&b);\n        if(t[0]=='L')L.pb({a,b});\n        else if(t[0]=='R')R.pb({a,b});\n        else if(t[0]=='U')U.pb({a,b});\n        else D.pb({a,b});\n    }\n    FOR(i,1,n)calc(i);\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace __gnu_pbds;\nusing namespace std;\n \ntemplate <typename T>\nusing ordered_set =\n\ttree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n \n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n\t*this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n \n#define shandom_ruffle random_shuffle\n \nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=327;\nusing bn=bitset<87>;\nusing ld=long double;\n\nint n;\npii gdz[nax];\nll war[nax];\n\nint m;\nbn podz[nax];\nint ile[nax];\n\nll wyn;\n\nbn ter;\n \nll dajwar()\n{\n\tll ret=0;\n\tfor (int i=1; i<=n; i++)\n\t\tif (ter[i])\n\t\t\tret+=war[i];\n\treturn ret;\n}\n \nint popr()\n{\n\tfor (int i=1; i<=m; i++)\n\t\tif ((podz[i]&ter).count()>ile[i])\n\t\t\treturn 0;\n\treturn 1;\n}\n\nstruct Simplex {        // Maximize c*x subject to Ax <= b.\n  using T = ld;     // Initialize the structure, set A, b, c and then run\n  vector<vector<T>> A;  // solve(). Max objective is stored in res. To recover\n  vector<T> b, c;       // the best result, use getVars().\n  int V, E;\n  vector<int> eqIds, varIds, cols;\n  T res;\n  static constexpr T kEps = 1e-5;\n\n  Simplex(int vars, int eqs) : A(eqs, vector<T>(vars)), b(eqs), c(vars),\n      V(vars), E(eqs), eqIds(eqs), varIds(vars), res(0) {\n    iota(varIds.begin(), varIds.end(), 0);\n    iota(eqIds.begin(), eqIds.end(), vars);\n  }\n\n  void pivot(int eq, int var) {\n    T coef = 1 / A[eq][var];\n    cols.clear();\n    for (int i = 0; i < V; i++) {\n      if (abs(A[eq][i]) > kEps) { cols.push_back(i); A[eq][i] *= coef; }\n    }\n    A[eq][var] *= coef; b[eq] *= coef;\n    for (int row = 0; row < E; row++) {\n      if (row == eq || abs(A[row][var]) < kEps) { continue; }\n      T k = -A[row][var];\n      A[row][var] = 0;\n      for (int i : cols) { A[row][i] += k * A[eq][i]; }\n      b[row] += k * b[eq];\n    }\n    T q = c[var]; c[var] = 0;\n    for (int i : cols) { c[i] -= q * A[eq][i]; }\n    res += q * b[eq];\n    swap(varIds[var], eqIds[eq]);\n  }\n\n  bool solve() {\n    while (true) {\n      int eq = -1, var = -1;\n      for (int i = 0; i < E; i++) { if (b[i] < -kEps) { eq = i; break; } }\n      if (eq == -1) { break; }\n      for (int i = 0; i < V; i++) { if (A[eq][i] < -kEps) { var = i; break; } }\n      if (var == -1) { res = -1e9; return false; /* No solution */ }\n      pivot(eq, var);\n    }\n    while (true) {\n      int var = -1, eq = -1;\n      for (int i = 0; i < V; i++) { if (c[i] > kEps) { var = i; break; } }\n      if (var == -1) { break; }\n      for (int i = 0; i < E; i++) {\n        if (A[i][var] < kEps) { continue; }\n        if (eq >= 0 && b[i] / A[i][var] >= b[eq] / A[eq][var]) { continue; }\n        eq = i;\n      }\n      if (eq == -1) { res = 1e9; return false; /* Unbounded */ }\n      pivot(eq, var);\n    }\n    return true;\n  }\n\n  vector<T> getVars() { // Optimal assignment of variables.\n    vector<T> result(V);\n    for (int i = 0; i < E; i++) if (eqIds[i] < V) result[eqIds[i]] = b[i];\n    return result;\n  }\n};\n\nvoid rek(int v, int jesz)\n{\n\tif (popr())\n\t\twyn=max(wyn, dajwar());\n\tif (!jesz)\n\t\treturn;\n\tfor (int i=v; i<=n; i++)\n\t{\n\t\tter.flip(i);\n\t\trek(i+1, jesz-1);\n\t\tter.flip(i);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(\"%d%d%lld\", &gdz[i].first, &gdz[i].second, &war[i]);\n\tscanf(\"%d\", &m);\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\tchar c;\n\t\tint a, b;\n\t\tscanf(\" %c%d%d\", &c, &a, &b);\n\t\tfor (int j=1; j<=n; j++)\n\t\t{\n\t\t\tif (c=='L' && gdz[j].first<=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='R' && gdz[j].first>=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='D' && gdz[j].second<=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='U' && gdz[j].second>=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t}\n\t\tile[i]=b;\n\t}\n\tSimplex janusz(n, m+2*n);\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tjanusz.c[i]=war[i+1];\n\t}\n\tfor (int i=0; i<m; i++)\n\t{\n\t\tjanusz.b[i]=ile[i+1];\n\t\tfor (int j=0; j<n; j++)\n\t\t\tjanusz.A[i][j]=podz[i+1][j+1];\n\t}\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tjanusz.b[m+i]=1;\n\t\tjanusz.A[m+i][i]=1;\n\t}\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tjanusz.b[m+n+i]=0;\n\t\tjanusz.A[m+n+i][i]=-1;\n\t}\n\tassert(janusz.solve());\n\tauto wez=janusz.getVars();\n\t\n\tfor (int i=0; i<n; i++)\n\t\tter[i+1]=(wez[i]>0.5);\n\t\n\tll sta=dajwar();\n\t\n\trek(1, 4);\n\t\n\tdebug() << janusz.getVars();\n\tprintf(\"%lld\\n\", wyn);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define inf 0x3f3f3f3f\n\nusing namespace std;\n\ntypedef long long ll;\n\nstruct Edge {\n  int t,f,next;\n  ll v;\n  Edge() {}\n  Edge(int a,int b,ll c,int d):t(a),f(b),v(c),next(d) {}\n};\n\nEdge e[1000000];\nint head[410],vs,vt,tot=-1;\n\nvoid addEdge(int x,int y,int z,ll v) {\n  e[++tot]=Edge(y,z,v,head[x]);\n  head[x]=tot;\n  e[++tot]=Edge(x,0,-v,head[y]);\n  head[y]=tot;\n}\n\nnamespace Flow {\n\nll dis[410];\nint cur[410];\nbool in[410];\nqueue <int> q;\n\nbool spfa() {\n  while (!q.empty()) q.pop();\n  memset(in,0,sizeof(in));\n  for(int i=vs;i<=vt;i++) dis[i]=-1e18;\n  dis[vs]=0;in[vs]=1;\n  q.push(vs);\n  while (!q.empty()) {\n  \tint x=q.front();q.pop();in[x]=0;\n  \tcur[x]=head[x];\n  \tfor(int i=head[x];i!=-1;i=e[i].next)\n  \t  if (e[i].f&&dis[x]+e[i].v>dis[e[i].t]) {\n  \t  \t  int u=e[i].t;\n  \t  \t  dis[u]=dis[x]+e[i].v;\n  \t  \t  if (!in[u]) {\n  \t  \t  \t    in[u]=1;\n  \t  \t  \t    q.push(u);\n\t\t\t  }\n\t\t}\n  }\n  return dis[vt]>-1e18;\n}\n\nint vis[410],cnt;\n\nint dfs(int x,int a) {\n  if (x==vt||!a) return a;\n  vis[x]=cnt;\n  int ans=0;\n  for(int &i=cur[x];i!=-1;i=e[i].next)\n    if (e[i].f&&vis[e[i].t]<cnt&&dis[x]+e[i].v==dis[e[i].t]) {\n    \tint u=e[i].t;\n    \tint f=dfs(u,min(a,e[i].f));\n    \tif (f) {\n    \t\te[i].f-=f;\n    \t\te[i^1].f+=f;\n    \t\tans+=f;\n    \t\ta-=f;\n    \t\tif (!a) break;\n\t\t}\n\t}\n  return ans;\n}\n\nll msmf(int d) {\n  int s1=0;\n  ll s2=0;\n  while (spfa()) {\n  \tint f;\n    do {\n    \tcnt++;\n    \tf=dfs(vs,inf);\n    \ts1+=f;\n    \ts2+=f*dis[vt];\n\t} while (f);\n  }\n  return (s1>=d)?s2:0;\n}\n\n}\n\nstruct Data {\n  int kind,x,y;\n  ll v;\n  Data() {}\n  Data(int a,int b,int c,ll d):kind(a),x(b),y(c),v(d) {}\n};\n\nData p[100],a[400];\nint minx[400],maxx[400],miny[400],maxy[400];\n\nll solve(int n,int m,int k) {\n  memset(head,255,sizeof(head));\n  memset(minx,0,sizeof(minx));\n  memset(maxx,0x3f,sizeof(maxx));\n  memset(miny,0,sizeof(miny));\n  memset(maxy,0x3f,sizeof(maxy));\n  vs=0;vt=2*n+2*k+1;\n  tot=-1;\n  for(int i=1;i<=m;i++)\n    if (a[i].kind==1) {\n    \tif (a[i].y<k) minx[a[i].y+1]=max(minx[a[i].y+1],a[i].x+1);\n\t}\n\telse if (a[i].kind==2) {\n\t\tif (a[i].y<k) maxx[k-a[i].y]=min(maxx[k-a[i].y],a[i].x-1);\n\t}\n\telse if (a[i].kind==3) {\n    \tif (a[i].y<k) miny[a[i].y+1]=max(miny[a[i].y+1],a[i].x+1);\n\t}\n\telse {\n\t\tif (a[i].y<k) maxy[k-a[i].y]=min(maxy[k-a[i].y],a[i].x-1);\n\t}\n  for(int i=1;i<=k;i++) {\n  \tminx[i]=max(minx[i],minx[i-1]);\n  \tminy[i]=max(miny[i],miny[i-1]);\n  }\n  for(int i=k;i>0;i--) {\n  \tmaxx[i]=min(maxx[i],maxx[i+1]);\n  \tmaxy[i]=min(maxy[i],maxy[i+1]);\n  }\n  for(int i=1;i<=n;i++) addEdge(i,n+i,1,p[i].v);\n  for(int i=1;i<=k;i++) {\n  \taddEdge(vs,2*n+i,1,0);\n  \tfor(int j=1;j<=n;j++)\n  \t  if (p[j].x>=minx[i]&&p[j].x<=maxx[i]) addEdge(2*n+i,j,1,0);\n  }\n  for(int i=1;i<=k;i++) {\n  \taddEdge(2*n+k+i,vt,1,0);\n  \tfor(int j=1;j<=n;j++)\n  \t  if (p[j].y>=miny[i]&&p[j].y<=maxy[i]) addEdge(n+j,2*n+k+i,1,0);\n  }\n  return Flow::msmf(k);\n}\n\nint main() {\n  int n;\n  scanf(\"%d\",&n);\n  for(int i=1;i<=n;i++) {\n  \tint x,y;\n  \tll z;\n  \tscanf(\"%d%d%lld\",&x,&y,&z);\n  \tp[i]=Data(0,x,y,z);\n  }\n  int m;\n  scanf(\"%d\",&m);\n  for(int i=1;i<=m;i++) {\n  \tchar str[5];\n  \tint x,y;\n  \tscanf(\"%s%d%d\",str,&x,&y);\n  \tif (str[0]=='L') a[i]=Data(1,x,y,0);\n  \telse if (str[0]=='R') a[i]=Data(2,x,y,0);\n  \telse if (str[0]=='D') a[i]=Data(3,x,y,0);\n  \telse a[i]=Data(4,x,y,0);\n  }\n  ll ans=0;\n  for(int i=1;i<=n;i++)\n    ans=max(ans,solve(n,m,i));\n  printf(\"%lld\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define itn int\n#define all(x) (x).begin(), (x).end()\n#define make_unique(x) sort(all((x))); (x).resize(unique(all((x))) - (x).begin())\n\n#define random_shuffle(...) shuffle(__VA_ARGS__, rng)\n#define rand() rng()\n\nusing namespace std;\n\ninline int nxt() {\n\tint x;\n\tscanf(\"%d\", &x);\n\treturn x;\n}\n\n#define sz(x) ((int) (x).size())\n#define forn(i,n) for (int i = 0; i < int(n); ++i)\n\ntypedef long long ll;\ntypedef long long i64;\ntypedef long double ld;\nconst int inf = int(1e9) + int(1e5);\nconst ll infl = ll(2e18) + ll(1e10);\n\nconst int maxn = 505;\nconst int maxm = 505;\n\nconst ld eps = 1e-4;\n\nbool eq(ld a, ld b) {\n    return fabsl(a - b) < eps;\n}\n\n//BEGIN_CODE\nnamespace Simplex {\n\nld D[maxm][maxn]; // [n+2][m+2]\nint B[maxm];\nint N[maxn];\nld x[maxn];\nint n, m;\n\n//x >= 0, Ax <= b, c^Tx -> max\nvoid init(int _n, int _m, ld A[][maxn], ld *b, ld *c) {\n    n = _n, m = _m;\n    forn (i, m)\n        forn (j, n)\n            D[i][j] = -A[i][j];\n    forn (i, m) {\n        D[i][n] = 1;\n        D[i][n + 1] = b[i];\n    }\n    forn (j, n) {\n        D[m][j] = c[j];\n        D[m + 1][j] = 0;\n    }\n    D[m][n + 1] = D[m][n] = D[m + 1][n + 1] = 0;\n    D[m + 1][n] = -1;\n    iota(B, B + m, n);\n    iota(N, N + n, 0);\n    N[n] = -1;\n}\n\nvoid pivot(int b, int nb) {\n    assert(D[b][nb] != 0);\n    ld q = 1. / -D[b][nb];\n    D[b][nb] = -1;\n    forn (i, n + 2)\n        D[b][i] *= q;\n    forn (i, m + 2) {\n        if (i == b)\n            continue;\n        ld coef = D[i][nb];\n        D[i][nb] = 0;\n        forn (j, n + 2)\n            D[i][j] += coef * D[b][j];\n    }\n    swap(B[b], N[nb]);\n}\n\nbool betterN(int f, int i, int j) {\n    if (eq(D[f][i], D[f][j]))\n        return N[i] < N[j];\n    return D[f][i] > D[f][j];\n}\n\nbool betterB(int nb, int i, int j) {\n    ld ai = D[i][n + 1] / D[i][nb];\n    ld aj = D[j][n + 1] / D[j][nb];\n    if (eq(ai, aj))\n        return B[i] < B[j];\n    return ai > aj;\n}\n\nbool simplex(int phase) {\n    int f = phase == 1 ? m : m + 1;\n    while (true) {\n        int nb = -1;\n        forn (i, n + 1) {\n            if (N[i] == -1 && phase == 1)\n                continue;\n            if (nb == -1 || betterN(f, i, nb))\n                nb = i;\n        }\n        if (D[f][nb] <= eps)\n            return phase == 1;\n        assert(nb != -1);\n\n        int b = -1;\n        forn (i, m) {\n            if (D[i][nb] >= -eps)\n                continue;\n            if (b == -1 || betterB(nb, i, b))\n                b = i;\n        }\n        if (b == -1)\n            return false;\n        pivot(b, nb);\n        if (N[nb] == -1 && phase == 2)\n            return true;\n    }\n}\n\nld solve() {\n    int b = -1;\n    forn (i, m) {\n        if (b == -1 || D[i][n + 1] < D[b][n + 1])\n            b = i;\n    }\n    assert(b != -1);\n    if (D[b][n + 1] < -eps) {\n        pivot(b, n);\n        if (!simplex(2) || D[m + 1][n + 1] < -eps)\n            return -infl;\n    }\n    if (!simplex(1))\n        return infl;\n\n    forn (i, n)\n        x[i] = 0;\n    forn (i, m)\n        if (B[i] < n)\n            x[B[i]] = D[i][n + 1];\n\n    return D[m][n + 1];\n}\n\n} //Simplex\n//END_CODE\n\nstruct Treasure {\n\tint x, y;\n\tlong long v;\n\n\tvoid scan() {\n\t\tscanf(\"%d%d%lld\", &x, &y, &v);\n\t}\n};\n\nstruct Constraint {\n\tchar t;\n\tint a, b;\n\n\tvoid scan() {\n\t\tcin >> t >> a >> b;\n\t}\n\n\tbool isAbout(const Treasure& tr) const {\n\t\tif (t == 'D') {\n\t\t\treturn tr.y <= a;\n\t\t} else if (t == 'U') {\n\t\t\treturn tr.y >= a;\n\t\t} else if (t == 'L') {\n\t\t\treturn tr.x <= a;\n\t\t} else if (t == 'R') {\n\t\t\treturn tr.x >= a;\n\t\t} else {\n\t\t\tassert(false);\n\t\t}\n\t}\n};\n\nld a[maxm][maxn];\nld b[maxm];\nld c[maxn];\n\nint main() {\n\tmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n\tint n = nxt();\n\tvector<Treasure> trs(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\ttrs[i].scan();\n\t}\n\n\tint m = nxt();\n\tvector<Constraint> crs(m);\n\tfor (int i = 0; i < m; ++i) {\n\t\tcrs[i].scan();\n\t}\n\n\tfor (int i = 0; i < m; ++i) {\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\ta[i][j] = crs[i].isAbout(trs[j]);\n\t\t}\n\t\tb[i] = crs[i].b;\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\ta[m + i][i] = 1;\n\t\tb[m + i] = 1;\n\t\tc[i] = trs[i].v;\n\t}\n\n\tSimplex::init(n, n + m, a, b, c);\n\t// Simplex::solve();\n\n\tlong double ans = Simplex::solve();\n\tlong long to_out = 0;\n\tvector<int> good(n, 0);\n\tfor (int i = 0; i < n; ++i) {\n\t\tbool can = true;\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tif (crs[j].isAbout(trs[i]) && crs[j].b == 0) {\n\t\t\t\tcan = false;\n\t\t\t}\n\t\t}\n\t\tif (!can) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\ta[i][j] = crs[i].isAbout(trs[j]);\n\t\t\t}\n\t\t\tb[i] = crs[i].b;\n\t\t}\n\t\tb[m + i] = 0;\n\t\tSimplex::init(n, n + m, a, b, c);\n\t\tauto res = Simplex::solve();\n\t\tif (res < ans - 0.5) {\n\t\t\tgood[i] = 1;\n\t\t\tfor (int j = 0; j < m; ++j) {\n\t\t\t\tif (crs[j].isAbout(trs[i]) && crs[j].b == 0) {\n\t\t\t\t\tcrs[j].b -= 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tb[m + i] = 1;\n\t\t\tto_out += trs[i].v;\n\t\t}\n\t}\n\n\tcout << to_out << \"\\n\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n#include <vector>\n#define PB push_back\n#define ll long long\nusing namespace std;\ntemplate <class T>\ninline void rd(T &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile(!isdigit(c)) { if(c=='-') f=-1; c=getchar(); }\n\twhile(isdigit(c)) x=x*10-'0'+c,c=getchar(); x*=f;\n}\ntemplate <class T> inline void cmin(T &x,T y) { if(y<x) x=y; }\ntemplate <class T> inline void cmax(T &x,T y) { if(x<y) x=y; }\nconst ll inf=1e16;\nint S,T,ncnt;\nnamespace Flow {\n\tconst int N=410;\n\tint head[N],cur[N];\n\tll dis[N];\n\tstruct ed { int to,next,f; ll w; };\n\tvector<ed> e;\n\tvoid init() { memset(head,-1,sizeof(head)),e.clear(); }\n\tvoid ad(int x,int y,int f,ll w) {\n\t\te.PB((ed){y,head[x],f,w}); head[x]=e.size()-1;\n\t\te.PB((ed){x,head[y],0,-w}); head[y]=e.size()-1;\n\t}\n\tqueue<int> que;\n\tint vis[N];\n\tbool bfs() {\n\t\tfor(int i=1;i<=ncnt;++i) dis[i]=-inf,cur[i]=head[i];\n\t\tdis[S]=0,vis[S]=1,que.push(S);\n\t\twhile(!que.empty()) {\n\t\t\tint u=que.front(); que.pop(),vis[u]=0;\n\t\t\tfor(int k=head[u];~k;k=e[k].next) if(e[k].f) {\n\t\t\t\tint v=e[k].to;\n\t\t\t\tif(dis[v]<dis[u]+e[k].w) {\n\t\t\t\t\tdis[v]=dis[u]+e[k].w;\n\t\t\t\t\tif(!vis[v]) vis[v]=1,que.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dis[T]>-inf;\n\t}\n\tint dfs(int u,int f) {\n\t\tif(u==T||!f) return f; int ret=0,tmp;\n\t\tvis[u]=1;\n\t\tfor(int &k=cur[u];~k;k=e[k].next) if(e[k].f) {\n\t\t\tint v=e[k].to;\n\t\t\tif(!vis[v]&&dis[v]==dis[u]+e[k].w&&(tmp=dfs(v,min(f,e[k].f)))) {\n\t\t\t\te[k].f-=tmp,e[k^1].f+=tmp;\n\t\t\t\tf-=tmp,ret+=tmp;\n\t\t\t\tif(!f) break;\n\t\t\t}\n\t\t}\n\t\tvis[u]=0;\n\t\treturn ret;\n\t}\n\tll work() { ll ans=0; while(bfs()) ans+=dfs(S,1e9)*dis[T]; return ans; }\n}\nconst int N=110;\nchar ss[N],str[10];\nint a[N],b[N];\nint xi[N],yi[N],n,m;\nint lbx[N],rbx[N],lby[N],rby[N];\nint idx[N],idy[N];\nll vi[N];\nll sol(int K) {\n\tfor(int i=1;i<=K;++i)\n\t\tlbx[i]=lby[i]=1,\n\t\trbx[i]=rby[i]=100;\n\tfor(int i=1;i<=m;++i) {\n\t\tif(b[i]>K) continue;\n\t\tif(ss[i]=='L') cmax(lbx[b[i]+1],a[i]+1);\n\t\telse if(ss[i]=='R') cmin(rbx[K-b[i]],a[i]-1);\n\t\telse if(ss[i]=='D') cmax(lby[b[i]+1],a[i]+1);\n\t\telse cmin(rby[K-b[i]],a[i]-1);\n\t}\n\tfor(int i=2;i<=K;++i)\n\t\tcmax(lbx[i],lbx[i-1]),\n\t\tcmax(lby[i],lby[i-1]);\n\tfor(int i=K-1;i>=1;--i)\n\t\tcmin(rbx[i],rbx[i+1]),\n\t\tcmin(rby[i],rby[i+1]);\n\t\n\tfor(int i=1;i<=K;++i) if(lbx[i]>rbx[i]||lby[i]>rby[i]) return 0;\n//\tfor(int i=1;i<=K;++i) printf(\"%d %d %d %d\\n\",lbx[i],rbx[i],lby[i],rby[i]);\n\tncnt=0; Flow::init();\n\tS=++ncnt,T=++ncnt;\n\tfor(int i=1;i<=100;++i) idx[i]=++ncnt,idy[i]=++ncnt;\n\tfor(int i=1;i<=K;++i) {\n\t\tint u=++ncnt;\n\t\tFlow::ad(S,u,1,0);\n\t\tfor(int j=lbx[i];j<=rbx[i];++j)\n\t\t\tFlow::ad(u,idx[j],1,0);\n\t}\n\tfor(int i=1;i<=K;++i) {\n\t\tint u=++ncnt;\n\t\tFlow::ad(u,T,1,0);\n\t\tfor(int j=lby[i];j<=rby[i];++j)\n\t\t\tFlow::ad(idy[j],u,1,0);\n\t}\n\tfor(int i=1;i<=n;++i)\n\t\tFlow::ad(idx[xi[i]],idy[yi[i]],1,vi[i]);\n\treturn Flow::work();\n}\n\t\n\t\nint main() {\n\trd(n);\n\tfor(int i=1;i<=n;++i) rd(xi[i]),rd(yi[i]),rd(vi[i]);\n\trd(m);\n\tfor(int i=1;i<=m;++i) {\n\t\tscanf(\"%s\",str);\n\t\tss[i]=str[0];\n\t\trd(a[i]),rd(b[i]);\n\t}\n\tll ans=0;\n\tfor(int i=1;i<=n;++i) ans=max(ans,sol(i));\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 505;\nconst int MAXV = 100;\nconst int INF  = 1e9;\ntypedef long long ll;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\nnamespace MincostFlow {\n\tconst int MAXP = 12005;\n\tconst int MAXQ = 2e5 + 5;\n\tconst long long INF = 1e18;\n\tstruct edge {int dest, flow, pos; ll cost; };\n\tvector <edge> a[MAXP];\n\tint n, m, s, t, tot, flow;\n\tll dist[MAXP], cost; int path[MAXP], home[MAXP];\n\tvoid FlowPath() {\n\t\tint p = t, ans = 1e9;\n\t\twhile (p != s) {\n\t\t\tans = min(ans, a[path[p]][home[p]].flow);\n\t\t\tp = path[p];\n\t\t}\n\t\tflow += ans;\n\t\tcost += ans * dist[t];\n\t\tp = t;\n\t\twhile (p != s) {\n\t\t\ta[path[p]][home[p]].flow -= ans;\n\t\t\ta[p][a[path[p]][home[p]].pos].flow += ans;\n\t\t\tp = path[p];\n\t\t}\n\t}\n\tbool spfa() {\n\t\tstatic int q[MAXQ];\n\t\tstatic bool inq[MAXP];\n\t\tstatic int l = 0, r = 0;\n\t\tfor (int i = 0; i <= r; i++)\n\t\t\tdist[q[i]] = -INF;\n\t\tq[l = r = 0] = s, dist[s] = 0, inq[s] = true;\n\t\twhile (l <= r) {\n\t\t\tint tmp = q[l];\n\t\t\tfor (unsigned i = 0; i < a[tmp].size(); i++)\n\t\t\t\tif (a[tmp][i].flow != 0 && dist[tmp] + a[tmp][i].cost > dist[a[tmp][i].dest]) {\n\t\t\t\t\tdist[a[tmp][i].dest] = dist[tmp] + a[tmp][i].cost;\n\t\t\t\t\tpath[a[tmp][i].dest] = tmp;\n\t\t\t\t\thome[a[tmp][i].dest] = i;\n\t\t\t\t\tif (!inq[a[tmp][i].dest]) {\n\t\t\t\t\t\tq[++r] = a[tmp][i].dest;\n\t\t\t\t\t\tinq[q[r]] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tl++, inq[tmp] = false;\n\t\t}\n\t\treturn dist[t] != -INF;\n\t}\n\tvoid addedge(int x, int y, int z, ll c) {\n\t\ta[x].push_back((edge){y, z, a[y].size(), c});\n\t\ta[y].push_back((edge){x, 0, a[x].size() - 1, -c});\n\t}\n\tll work(int n, int ns, int nt, int intend) {\n\t\tflow = cost = 0;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tdist[i] = -INF;\n\t\twhile (spfa())\n\t\tFlowPath();\n\t\tif (flow < intend) return 0;\n\t\ts = ns, t = nt;\n\t\twhile (spfa() && dist[t] > 0) FlowPath();\n\t\treturn cost;\n\t}\n\tvoid init() {\n\t\tfor (int i = 1; i <= tot; i++)\n\t\t\ta[i].clear();\n\t\ts = 1; t = tot = 2;\n\t}\n}\nint l[MAXN], r[MAXN], u[MAXN], d[MAXN];\nint s, t, n, m, tot, x[MAXN], y[MAXN]; ll v[MAXN];\nint main() {\n\tread(n);\n\tfor (int i = 1; i <= n; i++)\n\t\tread(x[i]), read(y[i]), read(v[i]);\n\tread(m);\n\tfor (int i = 0; i <= MAXV + 1; i++)\n\t\tl[i] = r[i] = u[i] = d[i] = n;\n\tl[0] = d[0] = 0, r[MAXV + 1] = u[MAXV + 1] = 0;\n\tfor (int i = 1; i <= m; i++) {\n\t\tchar c; int x, y;\n\t\tscanf(\"\\n%c%d%d\", &c, &x, &y);\n\t\tif (c == 'L') l[x] = y;\n\t\tif (c == 'R') r[x] = y;\n\t\tif (c == 'U') u[x] = y;\n\t\tif (c == 'D') d[x] = y;\n\t}\n\tfor (int i = 1, j = MAXV; i <= MAXV; i++, j--) {\n\t\tchkmin(r[i], r[i - 1]), chkmin(u[i], u[i - 1]);\n\t\tchkmin(l[j], l[j + 1]), chkmin(d[j], d[j + 1]);\n\t}\n\tll ans = 0;\n\tfor (int k = 1; k <= n; k++) {\n\t\tMincostFlow :: init();\n\t\ts = ++MincostFlow :: tot;\n\t\tt = ++MincostFlow :: tot;\n\t\tbool fail = false; int intend = 0;\n\t\tstatic int xp[MAXN], yp[MAXN], inp[MAXN], outp[MAXN];\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tinp[i] = ++MincostFlow :: tot;\n\t\t\toutp[i] = ++MincostFlow :: tot;\n\t\t}\n\t\tfor (int i = 1; i <= MAXV; i++) {\n\t\t\txp[i] = ++MincostFlow :: tot;\n\t\t\typ[i] = ++MincostFlow :: tot;\n\t\t}\n\t\tMincostFlow :: addedge(t, s, INF, -1e15);\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tMincostFlow :: addedge(inp[i], outp[i], 1, v[i]);\n\t\t\tMincostFlow :: addedge(xp[x[i]], inp[i], 1, 0);\n\t\t\tMincostFlow :: addedge(outp[i], yp[y[i]], 1, 0);\n\t\t}\n\t\txp[MAXV + 1] = s, yp[MAXV + 1] = t;\n\t\tfor (int i = 1; i <= MAXV; i++) {\n\t\t\tint Min, Max;\n\t\t\tMax = min(l[i], k), Min = max(k - r[i + 1], 0), intend += Min;\n\t\t\tif (Min > Max) {fail = true; break; }\n\t\t\tMincostFlow :: addedge(xp[i + 1], xp[i], Max - Min, 0);\n\t\t\tMincostFlow :: addedge(MincostFlow :: s, xp[i], Min, 0);\n\t\t\tMincostFlow :: addedge(xp[i + 1], MincostFlow :: t, Min, 0);\n\t\t\t\n\t\t\tMax = min(d[i], k), Min = max(k - u[i + 1], 0), intend += Min;\n\t\t\tif (Min > Max) {fail = true; break; }\n\t\t\tMincostFlow :: addedge(yp[i], yp[i + 1], Max - Min, 0);\n\t\t\tMincostFlow :: addedge(MincostFlow :: s, yp[i + 1], Min, 0);\n\t\t\tMincostFlow :: addedge(yp[i], MincostFlow :: t, Min, 0);\n\t\t}\n\t\tif (fail) continue;\n\t\telse chkmax(ans, MincostFlow :: work(MincostFlow :: tot, s, t, intend));\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define N 350\n#define M 200010\n#define int long long\n#define INF 4611686018427387904LL\ninline int read() {\n    int x=0;\n    char ch=getchar();\n    while (!isdigit(ch)) ch=getchar();\n    while (isdigit(ch)) x=x*10+ch-'0',ch=getchar();\n    return x;\n}\nstruct Point {\n    int x,y,val;\n}p[N];\nstruct opt {\n    char ch; int x,y;\n}a[N];\nint tot=1;\nint fir[N],nex[M],got[M],tak[M],cst[M];\ninline void AddEdge(int x,int y,int z,int w) { \n    nex[++tot]=fir[x],fir[x]=tot,got[tot]=y,tak[tot]=z,cst[tot]=w;\n}\ninline void Add(int x,int y,int z,int w) {\n    AddEdge(x,y,z,w),AddEdge(y,x,0,-w);\n}\nint xl[N],xr[N],yl[N],yr[N];\nint vis[N],dis[N],pre[N],que[N];\ninline int spfa(int s,int t) {\n    int l=1,r=1;\n    for (int i=1;i<=t;i++) vis[i]=false,dis[i]=-INF,pre[i]=0;\n    que[1]=s,dis[s]=0;\n    while (l<=r) {\n        int x=que[l];\n        for (int i=fir[x];i;i=nex[i]) {\n            int y=got[i],w=cst[i];\n            if (!tak[i] || dis[x]+w<=dis[y]) continue;\n            dis[y]=dis[x]+w,pre[y]=i;\n            if (!vis[y]) vis[y]=true,que[++r]=y;\n        }\n        ++l,vis[x]=false;\n    }\n    return dis[t]!=-INF;\n}\ninline int getflow(int s,int t) {\n    int flow=INF;\n    for (int i=t;i!=s;i=got[pre[i]^1]) {\n        flow=min(flow,tak[pre[i]]);\n    }\n    return flow;\n}\ninline void update(int s,int t,int flow,int &Maxflow,int &Mincost) {\n    Maxflow+=flow,Mincost+=flow*dis[t];\n    for (int i=t;i!=s;i=got[pre[i]^1]) {\n        tak[pre[i]]-=flow,tak[pre[i]^1]+=flow;\n    }\n}\ninline int solve(int s,int t) {\n    int Maxflow=0,Mincost=0;\n    while (spfa(s,t)) {\n        update(s,t,getflow(s,t),Maxflow,Mincost);\n    }\n    return Mincost;\n}\nsigned main() {\n    int n=read();\n    for (int i=1;i<=n;i++)\n        p[i].x=read(),p[i].y=read(),p[i].val=read();\n    int m=read(),res=0;\n    for (int i=1;i<=m;i++) {\n        char ch=getchar();\n        while (ch!='U' && ch!='D' && ch!='L' && ch!='R') ch=getchar();\n        a[i].ch=ch,a[i].x=read(),a[i].y=read();\n    }\n    for (int k=1;k<=n;k++) {\n        tot=1,memset(fir,0,sizeof(fir));\n        int s=(k<<1)+(n<<1)+1,t=s+1;\n        for (int i=1;i<=k;i++) Add(s,i,1,0);\n        for (int i=k+2*n+1;i<=2*k+2*n;i++) Add(i,t,1,0);\n        for (int i=k+1;i<=k+n;i++) Add(i,i+n,1,p[i-k].val);\n        for (int i=1;i<=k;i++) xl[i]=yl[i]=0,xr[i]=yr[i]=INF;\n        for (int i=1;i<=m;i++) {\n            if (a[i].ch=='U') for (int j=1;j<=k-a[i].y;j++) yr[j]=min(yr[j],a[i].x-1);\n            if (a[i].ch=='D') for (int j=a[i].y+1;j<=k;j++) yl[j]=max(yl[j],a[i].x+1);\n            if (a[i].ch=='L') for (int j=a[i].y+1;j<=k;j++) xl[j]=max(xl[j],a[i].x+1);\n            if (a[i].ch=='R') for (int j=1;j<=k-a[i].y;j++) xr[j]=min(xr[j],a[i].x-1);\n        }\n        for (int i=1;i<=k;i++) for (int j=1;j<=n;j++)\n            if (xl[i]<=p[j].x && p[j].x<=xr[i]) Add(i,j+k,1,0);\n        for (int i=1;i<=k;i++) for (int j=1;j<=n;j++)\n            if (yl[i]<=p[j].y && p[j].y<=yr[i]) Add(j+k+n,i+k+2*n,1,0);\n        res=max(res,solve(s,t));\n    }\n    cout<<res<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cassert>\n\n#define pb push_back\n#define fir first\n#define sec second\n#define forto(_) for (int e = last[_], v = E[e].to; e; v = E[e = E[e].next].to)\n#define forback(_) for (int _ = T; _ ^ S; _ = pre[_])\n\ntypedef long long LL;\n\nconst int kMaxn = 85, kMaxe = 2e4;\nconst LL kInf64 = 1e15;\n\ntypedef std::pair<int, int> Pii;\ntypedef int IArn[kMaxn];\ntypedef int IArv[kMaxn << 2];\n\nstruct Edge {\n\tint to, capt;\n\tLL cost;\n\tint next;\n} E[kMaxe << 1];\n\nint n, m, tote, S, T;\nIArn X, Y, L, R, U, D;\nIArv last, pre, pree;\nLL V[kMaxn], dist[kMaxn << 2];\nstd::vector<Pii> con[4];\nchar IN[5];\n\ninline void AddEdge(int u, int v, int cap, LL cst) {\n\tE[++tote] = (Edge){v, cap, cst, last[u]}, last[u] = tote;\n\tE[++tote] = (Edge){u, 0, -cst, last[v]}, last[v] = tote;\n}\ntemplate <typename T>\nvoid Umin(T & x, T y) {\n\tx > y ? x = y : 0;\n}\ntemplate <typename T>\nvoid Umax(T & x, T y) {\n\tx < y ? x = y : 0;\n}\nLL Mcf();\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d%d%lld\", X + i, Y + i, V + i);\n\t}\n\tscanf(\"%d\", &m);\n\tfor (int i = 0, ai, bi; i < m; i++) {\n\t\tscanf(\"%s%d%d\", IN, &ai, &bi);\n\t\tswitch (IN[0]) {\n\t\t\tcase 'L' :\n\t\t\t\tcon[0].pb(Pii(ai, bi));\n\t\t\t\tbreak;\n\t\t\tcase 'R' :\n\t\t\t\tcon[1].pb(Pii(ai, bi));\n\t\t\t\tbreak;\n\t\t\tcase 'D' :\n\t\t\t\tcon[2].pb(Pii(ai, bi));\n\t\t\t\tbreak;\n\t\t\tcase 'U' :\n\t\t\t\tcon[3].pb(Pii(ai, bi));\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tL[i] = D[i] = 1;\n\t}\n\tfor (auto & p : con[0]) {\n\t\tUmax(L[p.sec + 1], p.fir + 1);\n\t}\n\tfor (auto & p : con[2]) {\n\t\tUmax(D[p.sec + 1], p.fir + 1);\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tUmax(L[i], L[i - 1]);\n\t\tUmax(D[i], D[i - 1]);\n\t}\n\n\tLL ans = 0;\n\tfor (int k = 1; k <= n; k++) {\n\t\tfor (int i = 1; i <= k; i++) {\n\t\t\tR[i] = U[i] = 100;\n\t\t}\n\t\tfor (auto & p : con[1]) {\n\t\t\tif (k <= p.sec) continue;\n\t\t\tUmin(R[k - p.sec], p.fir - 1);\n\t\t}\n\t\tfor (auto & p : con[3]) {\n\t\t\tif (k <= p.sec) continue;\n\t\t\tUmin(U[k - p.sec], p.fir - 1);\n\t\t}\n\t\tfor (int i = k - 1; i > 0; i--) {\n\t\t\tUmin(R[i], R[i + 1]);\n\t\t\tUmin(U[i], U[i + 1]);\n\t\t}\n\n\t\ttote = 1;\n\t\tmemset(last, 0, sizeof last);\n\t\tT = (S = k + n + n + k + 1) + 1;\n\t\tfor (int i = 1; i <= k; i++) {\n\t\t\tAddEdge(S, i, 1, 0);\n\t\t\tAddEdge(k + n + n + i, T, 1, 0);\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tif (L[i] <= X[j] && X[j] <= R[i]) {\n\t\t\t\t\tAddEdge(i, k + j, 1, 0);\n\t\t\t\t}\n\t\t\t\tif (D[i] <= Y[j] && Y[j] <= U[i]) {\n\t\t\t\t\tAddEdge(k + n + j, k + n + n + i, 1, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tAddEdge(k + i, k + n + i, 1, kInf64 - V[i]);\n\t\t}\n\n\t\tans = std::max(ans, Mcf());\n\t}\n\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n\nbool Spfa() {\n\tstatic std::queue<int> que;\n\tstatic int inque[kMaxn << 2];\n\n\tmemset(pre, 0xff, sizeof pre);\n\tmemset(dist, 0x7f, sizeof dist);\n\n\tfor (dist[S] = 0, que.push(S), inque[S] = 1; !que.empty(); ) {\n\t\tint u = que.front(); que.pop();\n\t\tforto(u) {\n\t\t\tif (E[e].capt > 0 && dist[v] > dist[u] + E[e].cost) {\n\t\t\t\tdist[v] = dist[u] + E[e].cost;\n\t\t\t\tpre[v] = u, pree[v] = e;\n\t\t\t\tif (!inque[v]) {\n\t\t\t\t\tque.push(v), inque[v] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tinque[u] = 0;\n\t}\n\treturn ~pre[T];\n}\n\nLL Mcf() {\n\tLL tot = 0, sumf = 0;\n\twhile (Spfa()) {\n\t\tint flow = 100000;\n\t\tforback(u) {\n\t\t\tflow = std::min(flow, E[pree[u]].capt);\n\t\t}\n\t\ttot += 1ll * flow * dist[T], sumf += flow;\n\t\tforback(u) {\n\t\t\tE[pree[u]].capt -= flow;\n\t\t\tE[pree[u] ^ 1].capt += flow;\n\t\t}\n\t}\n\treturn sumf * kInf64 - tot;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define fi first\n#define se second\n#define sz(a) int(a.size())\n#define clr(a) memset(a,0,sizeof(a))\n#define all(a) a.begin(),a.end()\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int inf=1e9;\nconst ll Inf=1e18;\nconst int mod=1;\ntemplate<typename T=int>\nT gi() {\n\tT x=0,o=1;char ch=getchar();\n\twhile((ch<'0'||ch>'9')&&ch!='-') ch=getchar();\n\tif(ch=='-') o=-1,ch=getchar();\n\twhile(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n\treturn x*o;\n}\ntemplate<typename T> bool chkmax(T &a,T b) { return a<b?a=b,1:0; };\ntemplate<typename T> bool chkmin(T &a,T b) { return a>b?a=b,1:0; };\nint add(int a,int b) { return a+b>=mod?a+b-mod:a+b; }\nint sub(int a,int b) { return a-b<0?a-b+mod:a-b; }\nvoid inc(int &a,int b) { a=(a+b>=mod?a+b-mod:a+b); }\nvoid dec(int &a,int b) { a=(a-b<0?a-b+mod:a-b); }\nstring to_string(string s) { return '\"'+s+'\"'; }\nstring to_string(const char *s) { return to_string((string)s); }\nstring to_string(bool b) { return (b?\"true\":\"false\"); }\ntemplate<typename A,typename B> string to_string(pair<A,B> p) {\n\treturn \"(\"+to_string(p.fi)+\",\"+to_string(p.se)+\")\";\n}\ntemplate<typename T> string to_string(T v) {\n\tint fst=1;string ret=\"{\";\n\tfor(auto x:v) {\n\t\tif(!fst) ret+=\",\";\n\t\tfst=0,ret+=to_string(x);\n\t}\n\tret+=\"}\";return ret;\n}\nvoid dbg_out() { cerr<<endl; }\ntemplate<typename Head,typename... Tail> void dbg_out(Head H,Tail... T) {\n\tcerr<<\" \"<<to_string(H);\n\tdbg_out(T...);\n}\n#define dbg(...) cerr<<\"{\"<<#__VA_ARGS__<<\"}:\",dbg_out(__VA_ARGS__)\n\ntemplate<typename T>\nint qpow(int a,T b) {\n\tint ret=1;\n\twhile(b) {\n\t\tif(b&1) ret=1ll*ret*a%mod;\n\t\ta=1ll*a*a%mod,b>>=1;\n\t}\n\treturn ret;\n}\n\nconst int N=1e5+10;\n\nnamespace mcmf {\n\n\tstruct edge {\n\t\tint to,w,nxt;ll cost;\n\t} e[N<<1];\n\n\tint tot=1,h[N];\n\t\n\tvoid adde(int u,int v,int w,ll c) {\n\t\te[++tot]=(edge){v,w,h[u],c};h[u]=tot;\n\t\te[++tot]=(edge){u,0,h[v],-c};h[v]=tot;\n\t}\n\n\tint cur[N],s,t;\n\tll dis[N],ans=0;\n\tbool vis[N];\n\t\n\tbool spfa() {\n\t\tmemset(dis,0x3f,sizeof(dis));\n\t\tclr(vis);\n\t\tdeque<int> q;q.pb(s);dis[s]=0;\n\t\twhile(!q.empty()) {\n\t\t\tint u=q.front();q.pop_front();vis[u]=0;\n\t\t\tfor(int i=h[u];i;i=e[i].nxt)\n\t\t\t\tif(e[i].w) {\n\t\t\t\t\tint v=e[i].to;\n\t\t\t\t\tif(chkmin(dis[v],dis[u]+e[i].cost)) {\n\t\t\t\t\t\tif(!vis[v]) vis[v]=1,e[i].cost<0?q.push_front(v):q.pb(v);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\treturn dis[t]<Inf;\n\t}\n\t\n\tint dfs(int u,int flow) {\n\t\tif(u==t) return flow;\n\t\tvis[u]=1; int ret=0;\n\t\tfor(int &i=cur[u];i;i=e[i].nxt) {\n\t\t\tint v=e[i].to;\n\t\t\tif(e[i].w&&dis[v]==dis[u]+e[i].cost&&!vis[v]) {\n\t\t\t\tint d=dfs(v,min(flow,e[i].w));\n\t\t\t\te[i].w-=d;e[i^1].w+=d;ret+=d;flow-=d;ans+=e[i].cost*d;\n\t\t\t\tif(!flow) { vis[u]=0;break; }\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tpair<int,ll> solve() {\n\t\tans=0;\n\t\tint ret=0;\n\t\twhile(spfa()) {\n\t\t\tmemcpy(cur,h,sizeof(h));\n\t\t\tret+=dfs(s,inf);\n\t\t}\n\t\treturn mp(ret,ans);\n\t}\n\n\tvoid init(int _s,int _t) {\n\t\ts=_s,t=_t;\n\t\ttot=1;memset(h,0,sizeof(h));\n\t}\n\t\n}\n\nchar gc() {\n\tchar ch=getchar();\n\twhile(!isupper(ch)) ch=getchar();\n\treturn ch;\n}\n\nint n,m,x[N],y[N],a[N],b[N],liml[N],limr[N],limu[N],limd[N];\nll v[N];\nchar c[N];\n\nll calc(int k) {\n\tint s=0,t=2*k+201;\n\tmcmf::init(s,t);\n\tfor(int i=1;i<=k;i++) {\n\t\tliml[i]=1,limr[i]=100;\n\t\tlimd[i]=1,limu[i]=100;\n\t}\n\tfor(int i=1;i<=m;i++) {\n\t\tif(b[i]>=k) continue;\n\t\tif(c[i]=='L') {\n\t\t\tchkmax(liml[b[i]+1],a[i]+1);\n\t\t}\n\t\telse if(c[i]=='R') {\n\t\t\tchkmin(limr[k-b[i]],a[i]-1);\n\t\t}\n\t\telse if(c[i]=='D') {\n\t\t\tchkmax(limd[b[i]+1],a[i]+1);\n\t\t}\n\t\telse {\n\t\t\tchkmin(limu[k-b[i]],a[i]-1);\n\t\t}\n\t}\n\tfor(int i=2;i<=k;i++) {\n\t\tchkmax(liml[i],liml[i-1]);\n\t\tchkmax(limd[i],limd[i-1]);\n\t}\n\tfor(int i=k-1;i;i--) {\n\t\tchkmin(limr[i],limr[i+1]);\n\t\tchkmin(limu[i],limu[i+1]);\n\t}\n\tfor(int i=1;i<=k;i++) {\n\t\tmcmf::adde(s,i,1,0);\n\t\tmcmf::adde(i+k+200,t,1,0);\n\t\tfor(int j=liml[i];j<=limr[i];j++) {\n\t\t\tmcmf::adde(i,k+j,1,0);\n\t\t}\n\t\tfor(int j=limd[i];j<=limu[i];j++) {\n\t\t\tmcmf::adde(k+100+j,k+200+i,1,0);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++) {\n\t\tmcmf::adde(k+x[i],k+100+y[i],1,-v[i]);\n\t}\n\tauto ret=mcmf::solve();\n\tif(ret.fi!=k) return -1;\n\treturn -ret.se;\n}\n\nint main() {\n\tn=gi();\n\tfor(int i=1;i<=n;i++) x[i]=gi(),y[i]=gi(),v[i]=gi<ll>();\n\tm=gi();\n\tfor(int i=1;i<=m;i++) c[i]=gc(),a[i]=gi(),b[i]=gi();\n\tll ans=0;\n\tfor(int i=1;i<=n;i++) chkmax(ans,calc(i));\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<queue>\n#include<vector>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\ntemplate<class T> void read(T &x) {\n\tx=0; int f=1,ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=getchar();}\n\tx*=f;\n}\ntypedef long long ll;\nconst ll inf=1e18;\nconst int maxn=80+5;\nconst int maxm=320+5;\nconst int maxK=maxn;\nconst int maxnode=maxn*2+maxK*2;\nint N,M;\nint st,ed;\nint x[maxn],y[maxn]; ll v[maxn];\nint Lx[maxK],Ly[maxK],Rx[maxK],Ry[maxK];\nchar t[maxm]; int a[maxm],b[maxm];\nstruct edge {\n\tint to,cap; ll cost; int rev;\n\tedge(int to=0,int cap=0,ll cost=0,int rev=0):to(to),cap(cap),cost(cost),rev(rev){}\n};\nvector<edge> adj[maxnode];\ninline void addedge(int u,int v,int c,ll w) {\n\tadj[u].push_back(edge(v,c,w,adj[v].size()));\n\tadj[v].push_back(edge(u,0,-w,adj[u].size()-1));\n}\nnamespace MCMF {\n\tll dis[maxnode]; bool inq[maxnode];\n\tint prev[maxnode],pree[maxnode];\n\tbool SPFA() {\n\t\tqueue<int> q;\n\t\tfor(int i=st;i<=ed;++i) {\n\t\t\tdis[i]=-inf;\n\t\t}\n\t\tdis[st]=0;\n\t\tinq[st]=1;\n\t\tq.push(st);\n\t\twhile(!q.empty()) {\n\t\t\tint u=q.front(); q.pop();\n\t\t\tinq[u]=0;\n\t\t\tfor(unsigned int i=0;i<adj[u].size();++i) {\n\t\t\t\tedge &e=adj[u][i]; if(!e.cap) continue;\n\t\t\t\tif(dis[e.to]<dis[u]+e.cost) {\n\t\t\t\t\tdis[e.to]=dis[u]+e.cost;\n\t\t\t\t\tprev[e.to]=u;\n\t\t\t\t\tpree[e.to]=i;\n\t\t\t\t\tif(!inq[e.to]) {\n\t\t\t\t\t\tq.push(e.to);\n\t\t\t\t\t\tinq[e.to]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dis[ed]!=-inf;\n\t}\n\tvoid maxflow(int &flow,ll &cost) {\n\t\twhile(SPFA()) {\n\t\t\tint delt=1e9;\n\t\t\tfor(int u=ed;u!=st;u=prev[u]) {\n\t\t\t\tedge &e=adj[prev[u]][pree[u]];\n\t\t\t\tdelt=min(delt,e.cap);\n\t\t\t}\n\t\t\tflow+=delt;\n\t\t\tcost+=delt*dis[ed];\n\t\t\tfor(int u=ed;u!=st;u=prev[u]) {\n\t\t\t\tedge &e=adj[prev[u]][pree[u]];\n\t\t\t\te.cap-=delt;\n\t\t\t\tadj[u][e.rev].cap+=delt;\n\t\t\t}\n\t\t}\n\t}\n}\nll sol(int K) {\n\tst=0,ed=K+N+N+K+1;\n\tfor(int i=st;i<=ed;++i) {\n\t\tadj[i].clear();\n\t}\n\tfor(int i=1;i<=K;++i) {\n\t\tLx[i]=Ly[i]=0;\n\t\tRx[i]=Ry[i]=101;\n\t}\n\tfor(int i=1;i<=M;++i) {\n\t\tswitch(t[i]) {\n\t\t\tcase 'L': Lx[b[i]+1]=a[i]+1; break;\n\t\t\tcase 'R': Rx[K-b[i]]=a[i]-1; break;\n\t\t\tcase 'D': Ly[b[i]+1]=a[i]+1; break;\n\t\t\tcase 'U': Ry[K-b[i]]=a[i]-1; break;\n\t\t}\n\t}\n\tfor(int i=1;i<K;++i) {\n\t\tif(Lx[i]>Lx[i+1]) Lx[i+1]=Lx[i];\n\t\tif(Ly[i]>Ly[i+1]) Ly[i+1]=Ly[i];\n\t}\n\tfor(int i=K;i>1;--i) {\n\t\tif(Rx[i]<Rx[i-1]) Rx[i-1]=Rx[i];\n\t\tif(Ry[i]<Ry[i-1]) Ry[i-1]=Ry[i];\n\t}\n\tfor(int i=1;i<=K;++i) {\n\t\taddedge(st,i,1,0);\n\t\tfor(int j=1;j<=N;++j) {\n\t\t\tif(x[j]>=Lx[i]&&x[j]<=Rx[i]) {\n\t\t\t\taddedge(i,K+j,1,0);\n\t\t\t}\n\t\t\tif(y[j]>=Ly[i]&&y[j]<=Ry[i]) {\n\t\t\t\taddedge(K+N+j,K+N+N+i,1,0);\n\t\t\t}\n\t\t}\n\t\taddedge(K+N+N+i,ed,1,0);\n\t}\n\tfor(int i=1;i<=N;++i) {\n\t\taddedge(K+i,K+N+i,1,v[i]);\n\t}\n\tint flow=0; ll cost=0;\n\tMCMF::maxflow(flow,cost);\n\treturn cost;\n}\nint main() {\n\tread(N);\n\tfor(int i=1;i<=N;++i) {\n\t\tread(x[i]),read(y[i]),read(v[i]);\n\t}\n\tread(M);\n\tfor(int i=1;i<=M;++i) {\n\t\tstatic char tmp[5];\n\t\tscanf(\"%s\",tmp);\n\t\tt[i]=tmp[0],read(a[i]),read(b[i]);\n\t}\n\tll an=0;\n\tfor(int i=1;i<=N;++i) {\n\t\tan=max(an,sol(i));\n\t}\n\tprintf(\"%lld\\n\",an);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst long double EPS=1e-9;\nconst long double PI=acos(-1.0);\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\nlong double ABS(long double a){return max(a,-a);}\n\nnamespace MCF {\n\t// required <string.h> <vector> <queue> <algorithm>\n\t#define MAXN 350\n\t#define MAXM 200000\n\t#define wint int\n\t#define cint long long\n\tconst wint wEPS = 0;\n\tconst wint wINF = 1001001001;\n\tconst cint cEPS = 0;\n\tconst cint cINF = inf;\n\tint n, m, ptr[MAXN], next[MAXM], zu[MAXM];\n\twint capa[MAXM], tof;\n\tcint cost[MAXM], toc, d[MAXN], pot[MAXN];\n\tint vis[MAXN], pree[MAXN];\n\tvoid init(int _n) {\n\t\tn = _n; m = 0; memset(ptr, ~0, n * 4);\n\t}\n\tvoid ae(int u, int v, wint w, cint c) {\n\t\tnext[m] = ptr[u]; ptr[u] = m; zu[m] = v; capa[m] = w; cost[m] = +c; ++m;\n\t\tnext[m] = ptr[v]; ptr[v] = m; zu[m] = u; capa[m] = 0; cost[m] = -c; ++m;\n\t}\n\tbool solve(int src, int ink, wint flo = wINF) {\n\t\tint i, u, v;\n\t\twint f;\n\t\tcint c, cc;\n\t\tmemset(pot, 0, n * sizeof(cint));\n\t\t//*\n\t\tfor (bool cont = 1; cont; ) {\n\t\t\tcont = 0;\n\t\t\tfor (u = 0; u < n; ++u) for (i = ptr[u]; ~i; i = next[i]) if (capa[i] > wEPS) {\n\t\t\t\tif (pot[zu[i]] > pot[u] + cost[i] + cEPS) {\n\t\t\t\t\tpot[zu[i]] = pot[u] + cost[i]; cont = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//*/\n\t\tfor (toc = 0, tof = 0; tof + wEPS < flo; ) {\n\t\t\ttypedef pair<cint,int> node;\n\t\t\tpriority_queue< node,vector<node>,greater<node> > q;\n\t\t\tfor (u = 0; u < n; ++u) { d[u] = cINF; vis[u] = 0; }\n\t\t\tfor (q.push(make_pair(d[src] = 0, src)); !q.empty(); ) {\n\t\t\t\tc = q.top().first; u = q.top().second; q.pop();\n\t\t\t\tif (vis[u]++) continue;\n\t\t\t\tfor (i = ptr[u]; ~i; i = next[i]) if (capa[i] > wEPS) {\n\t\t\t\t\tcc = c + cost[i] + pot[u] - pot[v = zu[i]];\n\t\t\t\t\tif (d[v] > cc + cEPS) { q.push(make_pair(d[v] = cc, v)); pree[v] = i; }\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!vis[ink]) return 0;\n\t\t\tf = flo - tof;\n\t\t\tfor (v = ink; v != src; v = zu[i ^ 1]) { i = pree[v]; f=min(f,capa[i]); }\n\t\t\tfor (v = ink; v != src; v = zu[i ^ 1]) { i = pree[v]; capa[i] -= f; capa[i ^ 1] += f; }\n\t\t\ttof += f;\n\t\t\ttoc += f * (d[ink] - pot[src] + pot[ink]);\n\t\t\tfor (u = 0; u < n; ++u) pot[u] += d[u];\n\t\t}\n\t\treturn 1;\n\t}\n}\nint X[100];\nint Y[100];\nlong long C[100];\nchar t[400];\nint p[400];\nint q[400];\nint L[400];\nint R[400];\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tfor(int i=0;i<a;i++){\n\t\tscanf(\"%d%d%lld\",X+i,Y+i,C+i);\n\t}\n\tint b;scanf(\"%d\",&b);\n\tfor(int i=0;i<b;i++){\n\t\tscanf(\"%s%d%d\",t+i,p+i,q+i);\n\t}\n\tlong long ret=0;\n\tfor(int i=1;i<=a;i++){\n\t\tMCF::init(350);\n\t\tfor(int j=0;j<a;j++){\n\t\t\tMCF::ae(j*2,j*2+1,1,1000000000000000LL-C[j]);\n\t\t}\n\t\tint S=348;\n\t\tint T=349;\n\t\tfor(int j=0;j<i;j++){\n\t\t\tL[j]=0;\n\t\t\tR[j]=100;\n\t\t}\n\t\tfor(int j=0;j<b;j++){\n\t\t\tif(t[j]!='L'&&t[j]!='R')continue;\n\t\t\tif(q[j]>=i)continue;\n\t\t\tif(t[j]=='L'){\n\t\t\t\tL[q[j]]=max(L[q[j]],p[j]+1);\n\t\t\t}else{\n\t\t\t\tR[i-1-q[j]]=min(R[i-1-q[j]],p[j]-1);\n\t\t\t}\n\t\t}\n\t\tfor(int j=1;j<i;j++){\n\t\t\tL[j]=max(L[j],L[j-1]);\n\t\t}\n\t\tfor(int j=i-2;j>=0;j--){\n\t\t\tR[j]=min(R[j],R[j+1]);\n\t\t}\n\t\tfor(int j=0;j<i;j++){\n\t\t\tMCF::ae(S,a*2+j,1,0);\n\t\t\tfor(int k=0;k<a;k++){\n\t\t\t\tif(L[j]<=X[k]&&X[k]<=R[j])MCF::ae(a*2+j,k*2,1,0);\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<i;j++){\n\t\t\tL[j]=0;\n\t\t\tR[j]=100;\n\t\t}\n\t\tfor(int j=0;j<b;j++){\n\t\t\tif(t[j]!='D'&&t[j]!='U')continue;\n\t\t\tif(q[j]>=i)continue;\n\t\t\tif(t[j]=='D'){\n\t\t\t\tL[q[j]]=max(L[q[j]],p[j]+1);\n\t\t\t}else{\n\t\t\t\tR[i-1-q[j]]=min(R[i-1-q[j]],p[j]-1);\n\t\t\t}\n\t\t}\n\t\tfor(int j=1;j<i;j++){\n\t\t\tL[j]=max(L[j],L[j-1]);\n\t\t}\n\t\tfor(int j=i-2;j>=0;j--){\n\t\t\tR[j]=min(R[j],R[j+1]);\n\t\t}\n\t\tfor(int j=0;j<i;j++){\n\t\t\tMCF::ae(a*3+j,T,1,0);\n\t\t\tfor(int k=0;k<a;k++){\n\t\t\t\tif(L[j]<=Y[k]&&Y[k]<=R[j])MCF::ae(k*2+1,a*3+j,1,0);\n\t\t\t}\n\t\t}\n\t\tbool res=MCF::solve(S,T,i);\n\t\tif(!res)continue;\n\t\tret=max(ret,1000000000000000LL*i-MCF::toc);\n\t}\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <list>\n#include <time.h>\n#include <math.h>\n#include <random>\n#include <deque>\n#include <queue>\n#include <cassert>\n#include <unordered_map>\n#include <unordered_set>\n#include <iomanip>\n#include <bitset>\n#include <sstream>\n#include <chrono>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef long double dbl;\nconst int INF = 1.01e9;\n \nconst long double EPS = 1e-18;\nbool eq(long double x, long double y) {\n    return fabs(x - y) < EPS;\n}\nbool ls(long double x, long double y) {\n    return x < y && !eq(x, y);\n}\n \nvector<long double> simplex(vector<vector<long double> > a) {\n    int n = a.size() - 1;\n    int m = a[0].size() - 1;\n    vector<int> left(n + 1), up(m + 1);\n    iota(up.begin(), up.end(), 0);\n    iota(left.begin(), left.end(), m);\n    auto pivot = [&](int x, int y) {\n        swap(left[x], up[y]);\n        long double k = a[x][y];\n        a[x][y] = 1;\n        vector<int> vct;\n        for (int j = 0; j <= m; j++) {\n            a[x][j] /= k;\n            if (!eq(a[x][j], 0)) vct.push_back(j);\n        }\n        for (int i = 0; i <= n; i++) {\n            if (eq(a[i][y], 0) || i == x) continue;\n            k = a[i][y];\n            a[i][y] = 0;\n            for (int j : vct) a[i][j] -= k * a[x][j];\n        }\n    };\n    while (1) {\n        int x = -1;\n        for (int i = 1; i <= n; i++) if (ls(a[i][0], 0) && (x == -1 || a[i][0] < a[x][0])) x = i;\n        if (x == -1) break;\n        int y = -1;\n        for (int j = 1; j <= m; j++) if (ls(a[x][j], 0) && (y == -1 || a[x][j] < a[x][y])) y = j;\n        if (y == -1) assert(0); // infeasible\n        pivot(x, y);\n    }\n    while (1) {\n        int y = -1;\n        for (int j = 1; j <= m; j++) if (ls(0, a[0][j]) && (y == -1 || a[0][j] > a[0][y])) y = j;\n        if (y == -1) break;\n        int x = -1;\n        for (int i = 1; i <= n; i++) if (ls(0, a[i][y]) && (x == -1 || a[i][0] / a[i][y] < a[x][0] / a[x][y])) x = i;\n        if (x == -1) assert(0); // unbounded\n        pivot(x, y);\n    }\n    vector<long double> ans(m + 1);\n    for (int i = 1; i <= n; i++) if (left[i] <= m) ans[left[i]] = a[i][0];\n    ans[0] = -a[0][0];\n    return ans;\n}\n\n#ifdef ONPC\n  mt19937 rnd(228);\n#else\n  mt19937 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\n#endif\n\nint main()\n{\n#ifdef ONPC\n  freopen(\"a.in\", \"r\", stdin);\n#endif\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector <int> x(n), y(n);\n  vector <ll> ok;\n  vector <long double> v;\n  vector <pair <ll, int> > e;\n  for (int i = 0; i < n; i++)\n  {\n    cin >> x[i] >> y[i];\n    ll x;\n    cin >> x;\n    ok.push_back(x);\n    v.push_back(x);\n    e.push_back({x, i});\n  }\n  v.insert(v.begin(), 0);\n  int m;\n  cin >> m;\n  vector <vector <long double> > mat;\n  mat.push_back(v);\n  for (int i = 0; i < n; i++)\n  {\n    vector <long double> kek(n + 1);\n    kek[0] = kek[i + 1] = 1;\n    mat.push_back(kek);\n  }\n  vector <vector <int> > simp;\n  for (int i = 0; i < m; i++)\n  {\n    char c;\n    cin >> c;\n    int a;\n    int b;\n    cin >> a >> b;\n    vector <long double> arr = {(long double) b};\n    vector <int> kek = {b};\n    for (int j = 0; j < n; j++)\n    {\n      int grab = 0;\n      if (c == 'L' && x[j] <= a) grab = 1;\n      if (c == 'R' && x[j] >= a) grab = 1;\n      if (c == 'D' && y[j] <= a) grab = 1;\n      if (c == 'U' && y[j] >= a) grab = 1;\n      arr.push_back(grab);\n      kek.push_back(grab);\n    }\n    mat.push_back(arr);\n    simp.push_back(kek);\n  }\n  auto good = [&] (vector <int> grab)\n  {\n    for (auto c : simp)\n    {\n      int sum = 0;\n      for (int i = 1; i <= n; i++) sum += grab[i - 1] * c[i];\n      if (sum > c[0])\n      {\n        return false;\n      }\n    }\n    return true;\n  };\n  auto f = [&] (vector <int> grab)\n  {\n    ll sum = 0;\n    for (int i = 0; i < n; i++)\n    {\n      if (grab[i]) sum += ok[i];\n    }\n    return sum;\n  };\n  vector <int> grab;\n  for (int i = 0; i < n; i++) grab.push_back(0);\n  cout.precision(20);\n  auto solve = [&] ()\n  {\n    auto ret = simplex(mat);\n    sort(e.begin(), e.end());\n    vector <int> me(n);\n    int kek = 0;\n    for (int i = (int) e.size() - 1; i >= 0; i--)\n    {\n      if (!grab[e[i].second] && ret[e[i].second + 1] > EPS)\n      {\n        kek++;\n        me[e[i].second] = true;\n        grab[e[i].second] = true;\n        if (!good(grab)) grab[e[i].second] = false, me[e[i].second] = false;\n      }\n    }\n    int kekos = 0;\n    for (auto &c : mat)\n    {\n      kekos++;\n      if (kekos > n + 1)\n      for (int i = 1; i <= n; i++)\n      {\n        if (me[i - 1] && c[i] > EPS) c[i]--, c[0]--;\n      }\n    }\n    for (int i = 1; i <= n; i++)\n    {\n      if (me[i - 1])\n      {\n        mat[i][0] = 0;\n      }\n    }\n    return kek;\n  };\n  while (solve());\n  bool ch = true;\n  while (ch)\n  {\n    ch = false;\n    for (int i = (int) e.size() - 1; i >= 0; i--)\n    {\n      if (!grab[e[i].second])\n      {\n        grab[e[i].second] = true;\n        if (good(grab))\n        {\n          ch = true;\n        }\n        else\n        {\n          grab[e[i].second] = false;\n        }\n      }\n    }\n    if (!ch)\n    {\n      for (int i = 0; i < (int) e.size(); i++)\n      {\n        for (int j = i + 1; j < (int) e.size(); j++)\n        {\n          if (e[i].first < e[j].first && grab[e[i].second] && !grab[e[j].second])\n          {\n            auto x = grab;\n            swap(x[e[i].second], x[e[j].second]);\n            if (good(x))\n            {\n              grab = x;\n              ch = true;\n            }\n          }\n        }\n      }\n    }\n  }\n  ll best = f(grab);\n  cout << best << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define itn int\n#define all(x) (x).begin(), (x).end()\n#define make_unique(x) sort(all((x))); (x).resize(unique(all((x))) - (x).begin())\n\n#define random_shuffle(...) shuffle(__VA_ARGS__, rng)\n#define rand() rng()\n\nusing namespace std;\n\ninline int nxt() {\n\tint x;\n\tscanf(\"%d\", &x);\n\treturn x;\n}\n\n#define sz(x) ((int) (x).size())\n#define forn(i,n) for (int i = 0; i < int(n); ++i)\n\ntypedef long long ll;\ntypedef long long i64;\ntypedef long double ld;\nconst int inf = int(1e9) + int(1e5);\nconst ll infl = ll(2e18) + ll(1e10);\n\nconst int maxn = 505;\nconst int maxm = 505;\n\nconst ld eps = 1e-9;\n\nbool eq(ld a, ld b) {\n    return fabsl(a - b) < eps;\n}\n\n//BEGIN_CODE\nnamespace Simplex {\n\nld D[maxm][maxn]; // [n+2][m+2]\nint B[maxm];\nint N[maxn];\nld x[maxn];\nint n, m;\n\n//x >= 0, Ax <= b, c^Tx -> max\nvoid init(int _n, int _m, ld A[][maxn], ld *b, ld *c) {\n    n = _n, m = _m;\n    forn (i, m)\n        forn (j, n)\n            D[i][j] = -A[i][j];\n    forn (i, m) {\n        D[i][n] = 1;\n        D[i][n + 1] = b[i];\n    }\n    forn (j, n) {\n        D[m][j] = c[j];\n        D[m + 1][j] = 0;\n    }\n    D[m][n + 1] = D[m][n] = D[m + 1][n + 1] = 0;\n    D[m + 1][n] = -1;\n    iota(B, B + m, n);\n    iota(N, N + n, 0);\n    N[n] = -1;\n}\n\nvoid pivot(int b, int nb) {\n    assert(D[b][nb] != 0);\n    ld q = 1. / -D[b][nb];\n    D[b][nb] = -1;\n    forn (i, n + 2)\n        D[b][i] *= q;\n    forn (i, m + 2) {\n        if (i == b)\n            continue;\n        ld coef = D[i][nb];\n        D[i][nb] = 0;\n        forn (j, n + 2)\n            D[i][j] += coef * D[b][j];\n    }\n    swap(B[b], N[nb]);\n}\n\nbool betterN(int f, int i, int j) {\n    if (eq(D[f][i], D[f][j]))\n        return N[i] < N[j];\n    return D[f][i] > D[f][j];\n}\n\nbool betterB(int nb, int i, int j) {\n    ld ai = D[i][n + 1] / D[i][nb];\n    ld aj = D[j][n + 1] / D[j][nb];\n    if (eq(ai, aj))\n        return B[i] < B[j];\n    return ai > aj;\n}\n\nbool simplex(int phase) {\n    int f = phase == 1 ? m : m + 1;\n    while (true) {\n        int nb = -1;\n        forn (i, n + 1) {\n            if (N[i] == -1 && phase == 1)\n                continue;\n            if (nb == -1 || betterN(f, i, nb))\n                nb = i;\n        }\n        if (D[f][nb] <= eps)\n            return phase == 1;\n        assert(nb != -1);\n\n        int b = -1;\n        forn (i, m) {\n            if (D[i][nb] >= -eps)\n                continue;\n            if (b == -1 || betterB(nb, i, b))\n                b = i;\n        }\n        if (b == -1)\n            return false;\n        pivot(b, nb);\n        if (N[nb] == -1 && phase == 2)\n            return true;\n    }\n}\n\nld solve() {\n    int b = -1;\n    forn (i, m) {\n        if (b == -1 || D[i][n + 1] < D[b][n + 1])\n            b = i;\n    }\n    assert(b != -1);\n    if (D[b][n + 1] < -eps) {\n        pivot(b, n);\n        if (!simplex(2) || D[m + 1][n + 1] < -eps)\n            return -infl;\n    }\n    if (!simplex(1))\n        return infl;\n\n    forn (i, n)\n        x[i] = 0;\n    forn (i, m)\n        if (B[i] < n)\n            x[B[i]] = D[i][n + 1];\n\n    return D[m][n + 1];\n}\n\n} //Simplex\n//END_CODE\n\nstruct Treasure {\n\tint x, y;\n\tlong long v;\n\n\tvoid scan() {\n\t\tscanf(\"%d%d%lld\", &x, &y, &v);\n\t}\n};\n\nstruct Constraint {\n\tchar t;\n\tint a, b;\n\n\tvoid scan() {\n\t\tcin >> t >> a >> b;\n\t}\n\n\tbool isAbout(const Treasure& tr) const {\n\t\tif (t == 'D') {\n\t\t\treturn tr.y <= a;\n\t\t} else if (t == 'U') {\n\t\t\treturn tr.y >= a;\n\t\t} else if (t == 'L') {\n\t\t\treturn tr.x <= a;\n\t\t} else if (t == 'R') {\n\t\t\treturn tr.x >= a;\n\t\t} else {\n\t\t\tassert(false);\n\t\t}\n\t}\n};\n\nld a[maxm][maxn];\nld b[maxm];\nld c[maxn];\n\nint main() {\n\tmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n\tint n = nxt();\n\tvector<Treasure> trs(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\ttrs[i].scan();\n\t}\n\n\tint m = nxt();\n\tvector<Constraint> crs(m);\n\tfor (int i = 0; i < m; ++i) {\n\t\tcrs[i].scan();\n\t}\n\n\tfor (int i = 0; i < m; ++i) {\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\ta[i][j] = crs[i].isAbout(trs[j]);\n\t\t}\n\t\tb[i] = crs[i].b;\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\ta[m + i][i] = 1;\n\t\tb[m + i] = 1;\n\t\tc[i] = trs[i].v;\n\t}\n\n\tSimplex::init(n, n + m, a, b, c);\n\t// Simplex::solve();\n\n\tlong double ans = Simplex::solve();\n\t// for (int i = 0; i < n; ++i) {\n\t// \tans += trs[i].v * (int)(roundl(Simplex::x[i]));\n\t// }\n\tcout << (long long)roundl(ans) << \"\\n\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint N, M, x[100], y[100], x_code[100], y_code[100], in_code[100], out_code[100], lX[100], lY[100], rX[100], rY[100], lim[100], coord[100];\nlong long v[100];\nchar type[100];\nconst long long INF = 1LL << 60;\n\nclass maxFlowMinCut\n{\npublic:\n    int S, D, N, t[400], c[400][400], f[400][400];\n    bool inQ[400];\n    long long d[400], bani[400][400];\n    vector < int > v[400];\n\n    void addEdge (int x, int y, int cap, long long ban)\n    {\n        c[x][y] = cap, c[y][x] = 0;\n        bani[x][y] = ban, bani[y][x] = -ban;\n        v[x].push_back (y);\n        v[y].push_back (x);\n    }\n\n    bool bellman ()\n    {\n        queue < int > cc;\n        for (int i=1; i<=N; i++)\n            t[i] = -1, d[i] = INF, inQ[i] = 0;\n        t[S] = 0, d[S] = 0, inQ[S] = 1;\n        cc.push (S);\n        while (!cc.empty ())\n        {\n            int nod = cc.front ();\n            cc.pop (), inQ[nod] = 0;\n            for (auto it : v[nod])\n                if (c[nod][it] > f[nod][it] && d[nod] + bani[nod][it] < d[it])\n                {\n                    d[it] = d[nod] + bani[nod][it];\n                    t[it] = nod;\n                    if (!inQ[it])\n                        inQ[it] = 1,\n                        cc.push (it);\n                }\n        }\n        return (d[D] < INF);\n    }\n\n    pair < int, long long > minCostMaxFlow ()\n    {\n        int cap = 0;\n        long long ban = 0;\n        while (bellman ())\n        {\n            int minC = 1e9;\n            for (int i=D; i != S; i = t[i])\n                minC = min (minC, c[t[i]][i] - f[t[i]][i]);\n            for (int i=D; i != S; i = t[i])\n                f[t[i]][i] += minC,\n                f[i][t[i]] -= minC;\n            cap += minC, ban += 1LL * minC * d[D];\n        }\n        return {cap, ban};\n    }\n\n    void clear ()\n    {\n        for (int i=1; i<=N; i++)\n        {\n            for (auto j : v[i])\n                c[i][j] = c[j][i] = 0,\n                f[i][j] = f[j][i] = 0,\n                bani[i][j] = bani[j][i] = 0LL;\n            v[i].clear ();\n        }\n        S = D = N = 0;\n    }\n}net;\n\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nscanf (\"%d\", &N);\nfor (int i=1; i<=N; i++)\n    scanf (\"%d %d %lld\", &x[i], &y[i], &v[i]);\nscanf (\"%d\\n\", &M);\nfor (int i=1; i<=M; i++)\n    scanf (\"%c %d %d\\n\", &type[i], &coord[i], &lim[i]);\nlong long best = 0;\nfor (int K=1; K<=N; K++)\n{\n    net.clear (), net.S = 1, net.D = net.N = 2;\n    for (int i=1; i<=K; i++)\n        x_code[i] = ++net.N,\n        net.addEdge (net.S, x_code[i], 1, 0);\n    for (int i=1; i<=N; i++)\n        in_code[i] = ++net.N,\n        out_code[i] = ++net.N,\n        net.addEdge (in_code[i], out_code[i], 1, -v[i]);\n    for (int i=1; i<=K; i++)\n        y_code[i] = ++net.N,\n        net.addEdge (y_code[i], net.D, 1, 0);\n    for (int i=1; i<=K; i++)\n        lX[i] = lY[i] = 0,\n        rX[i] = rY[i] = 200;\n    for (int i=1; i<=M; i++)\n    {\n        if (type[i] == 'L' && lim[i] < K) lX[lim[i] + 1] = max (lX[lim[i] + 1], coord[i] + 1);\n        if (type[i] == 'R' && lim[i] < K) rX[K - lim[i]] = min (rX[K - lim[i]], coord[i] - 1);\n        if (type[i] == 'D' && lim[i] < K) lY[lim[i] + 1] = max (lY[lim[i] + 1], coord[i] + 1);\n        if (type[i] == 'U' && lim[i] < K) rY[K - lim[i]] = min (rY[K - lim[i]], coord[i] - 1);\n    }\n    for (int i=2; i<=K; i++)\n        lX[i] = max (lX[i], lX[i - 1]),\n        lY[i] = max (lY[i], lY[i - 1]);\n    for (int i=K - 1; i>=1; i--)\n        rX[i] = min (rX[i], rX[i + 1]),\n        rY[i] = min (rY[i], rY[i + 1]);\n    for (int i=1; i<=K; i++)\n        for (int j=1; j<=N; j++)\n        {\n            if (lX[i] <= x[j] && x[j] <= rX[i])\n                net.addEdge (x_code[i], in_code[j], 1, 0);\n            if (lY[i] <= y[j] && y[j] <= rY[i])\n                net.addEdge (out_code[j], y_code[i], 1, 0);\n        }\n/*    for (int i=1; i<=N; i++)\n        if (i == 1 || (5 <= i && i <= 7))\n            printf (\"%d %d\\n\", x[i], y[i]);\n    for (int i=1; i<=K; i++)\n        printf (\"[%d %d] [%d %d]\\n\", lX[i], rX[i], lY[i], rY[i]);*/\n    auto ans = net.minCostMaxFlow ();\n    //printf (\"%d -> %lld\\n\", ans.first, -ans.second);\n    if (ans.first == K)\n    {\n        if (-ans.second > best)\n            best = -ans.second;\n    }\n}\nprintf (\"%lld\\n\", best);\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double db;\n\nint get(){\n\tchar ch;\n\twhile(ch=getchar(),(ch<'0'||ch>'9')&&ch!='-');\n\tif (ch=='-'){\n\t\tint s=0;\n\t\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\t\treturn -s;\n\t}\n\tint s=ch-'0';\n\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\treturn s;\n}\n\nconst int N = 1000;\nconst int M = 1e6+5;\n\nint n,m;\nstruct point{\n\tint x,y;\n\tLL v;\n}a[N];\nstruct edge{\n\tint x,f,nxt;\n\tLL c;\n}e[M];\nint h[N],tot,ss,tt;\nint pt;\nstruct cons{\n\tint ty;\n\tint x,v;\n}c[N];\nint lx[N],rx[N],ly[N],ry[N];\nint sum[N];\n\nvoid addedge(int x,int y,int f,LL c){\n\te[++tot].x=y;e[tot].f=f;e[tot].c=c;e[tot].nxt=h[x];h[x]=tot;\n}\n\nvoid inse(int x,int y,int f,LL c){\n\taddedge(x,y,f,c);\n\taddedge(y,x,0,-c);\n}\n\nvoid add(int x,int y,int l,int r,LL v){\n\tinse(x,y,r-l,v);\n\tif (l){\n\t\tinse(ss,y,l,v);\n\t\tinse(x,tt,l,0);\n\t}\n}\n\nLL dis[N];\nint que[N],lst[N];\nbool pd[N];\n\nLL spfa(int ss,int tt){\n\tfo(i,1,pt)pd[i]=0,dis[i]=1e18;\n\tdis[ss]=0;\n\tint he=0,ta=1;\n\tpd[que[1]=ss]=1;\n\tfor(;he!=ta;){\n\t\tint x=que[he=he%pt+1];\n\t\tpd[x]=0;\n\t\tfor(int p=h[x];p;p=e[p].nxt)\n\t\t\tif (e[p].f&&dis[e[p].x]>dis[x]+e[p].c){\n\t\t\t\tdis[e[p].x]=dis[x]+e[p].c;\n\t\t\t\tlst[e[p].x]=p;\n\t\t\t\tif (!pd[e[p].x])pd[que[ta=ta%pt+1]=e[p].x]=1;\n\t\t\t}\n\t}\n\treturn dis[tt]<1e18;\n}\n\nLL aug(int ss,int tt){\n\tLL ret=dis[tt];\n\tfor(int x=tt;x!=ss;x=e[lst[x]^1].x){\n\t\te[lst[x]].f--;\n\t\te[lst[x]^1].f++;\n\t}\n\treturn ret;\n}\n\nint main(){\n\tn=get();\n\tfo(i,1,n){\n\t\ta[i].x=get();a[i].y=get();\n\t\tcin>>a[i].v;\n\t}\n\tm=get();\n\tfo(i,1,m){\n\t\tchar ch;\n\t\twhile(ch=getchar(),ch<'A'||ch>'Z');\n\t\tif (ch=='L')c[i].ty=1;\n\t\tif (ch=='R')c[i].ty=2;\n\t\tif (ch=='D')c[i].ty=3;\n\t\tif (ch=='U')c[i].ty=4;\n\t\tc[i].x=get();c[i].v=get();\n\t}\n\tLL ans=0;\n\tfo(all,1,n){\n\t\tfo(i,0,100)lx[i]=ly[i]=0,rx[i]=ry[i]=i;\n\t\tfo(i,1,m){\n\t\t\tint x=c[i].x,v=c[i].v;\n\t\t\tif (c[i].ty==1)rx[x]=min(rx[x],v);\n\t\t\tif (c[i].ty==2)lx[x-1]=max(lx[x-1],all-v);\n\t\t\tif (c[i].ty==3)ry[x]=min(ry[x],v);\n\t\t\tif (c[i].ty==4)ly[x-1]=max(ly[x-1],all-v);\n\t\t}\n\t\trx[100]=min(rx[100],all);\n\t\try[100]=min(ry[100],all);\n\t\tif (rx[100]<all||ry[100]<all)continue;\n\t\tbool can=1;\n\t\tfo(i,0,100)can&=(lx[i]<=rx[i]&&ly[i]<=ry[i]);\n\t\tif (!can)continue;\n\t\tpt=404;\n\t\tfo(i,1,pt)h[i]=sum[i]=0;\n\t\ttot=1;\n\t\tss=403,tt=404;\n\t\tint s=401,t=402;\n\t\tint key=0;\n\t\tfo(i,1,100){\n\t\t\tif (i==100){\n\t\t\t\tadd(s,i,lx[i],rx[i],0ll);\n\t\t\t}\n\t\t\telse add(i+1,i,lx[i],rx[i],0ll);\n\t\t\tadd(i,100+i,0,n,0ll);\n\t\t}\n\t\tfo(i,1,n)add(100+a[i].x,200+a[i].y,0,1,LL(1e15)-a[i].v);\n\t\tfo(i,1,100){\n\t\t\tif (i==100)add(300+i,t,ly[i],ry[i],0ll);\n\t\t\telse add(300+i,300+i+1,ly[i],ry[i],0ll);\n\t\t\tadd(200+i,300+i,0,n,0ll);\n\t\t}\n\t\tadd(t,s,0,1e9,0);\n\t\tLL tmp=0;\n\t\tint tim=0;\n\t\tfor(;spfa(ss,tt);){\n\t\t\ttmp=tmp+aug(ss,tt);\n\t\t}\n\t\tfor(int p=h[ss];p;p=e[p].nxt)if (e[p].f){can=0;break;}\n\t\tif (!can)continue;\n\t\th[t]=e[h[t]].nxt;\n\t\th[s]=e[h[s]].nxt;\n\t\tfor(;spfa(s,t);){\n\t\t\ttmp=tmp+aug(s,t);\n\t\t}\n\t\ttmp=LL(1e15)*all-tmp;\n\t\tfor(int p=h[s];p;p=e[p].nxt)if (e[p].x==100){key=p;break;}\n\t\tif (!e[key].f)ans=max(ans,tmp);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<queue>\n#include<vector>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\ntemplate<class T> void read(T &x) {\n\tx=0; int f=1,ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=getchar();}\n\tx*=f;\n}\ntypedef long long ll;\nconst ll inf=1e18;\nconst int maxn=80+5;\nconst int maxm=320+5;\nconst int maxK=maxn;\nconst int maxnode=maxn*2+maxK*2;\nint N,M;\nint st,ed;\nint x[maxn],y[maxn]; ll v[maxn];\nint Lx[maxK],Ly[maxK],Rx[maxK],Ry[maxK];\nchar t[maxm]; int a[maxm],b[maxm];\nstruct edge {\n\tint to,cap; ll cost; int rev;\n\tedge(int to=0,int cap=0,ll cost=0,int rev=0):to(to),cap(cap),cost(cost),rev(rev){}\n};\nvector<edge> adj[maxnode];\ninline void addedge(int u,int v,int c,ll w) {\n\tadj[u].push_back(edge(v,c,w,adj[v].size()));\n\tadj[v].push_back(edge(u,0,-w,adj[u].size()-1));\n}\nnamespace MCMF {\n\tll dis[maxnode]; bool inq[maxnode];\n\tint prev[maxnode],pree[maxnode];\n\tbool SPFA() {\n\t\tqueue<int> q;\n\t\tfor(int i=st;i<=ed;++i) {\n\t\t\tdis[i]=-inf;\n\t\t}\n\t\tdis[st]=0;\n\t\tinq[st]=1;\n\t\tq.push(st);\n\t\twhile(!q.empty()) {\n\t\t\tint u=q.front(); q.pop();\n\t\t\tinq[u]=0;\n\t\t\tfor(unsigned int i=0;i<adj[u].size();++i) {\n\t\t\t\tedge &e=adj[u][i]; if(!e.cap) continue;\n\t\t\t\tif(dis[e.to]<dis[u]+e.cost) {\n\t\t\t\t\tdis[e.to]=dis[u]+e.cost;\n\t\t\t\t\tprev[e.to]=u;\n\t\t\t\t\tpree[e.to]=i;\n\t\t\t\t\tif(!inq[e.to]) {\n\t\t\t\t\t\tq.push(e.to);\n\t\t\t\t\t\tinq[e.to]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dis[ed]!=-inf;\n\t}\n\tvoid maxflow(int &flow,ll &cost) {\n\t\twhile(SPFA()) {\n\t\t\tint delt=1e9;\n\t\t\tfor(int u=ed;u!=st;u=prev[u]) {\n\t\t\t\tedge &e=adj[prev[u]][pree[u]];\n\t\t\t\tdelt=min(delt,e.cap);\n\t\t\t}\n\t\t\tflow+=delt;\n\t\t\tcost+=delt*dis[ed];\n\t\t\tfor(int u=ed;u!=st;u=prev[u]) {\n\t\t\t\tedge &e=adj[prev[u]][pree[u]];\n\t\t\t\te.cap-=delt;\n\t\t\t\tadj[u][e.rev].cap+=delt;\n\t\t\t}\n\t\t}\n\t}\n}\nll sol(int K) {\n\tst=0,ed=K+N+N+K+1;\n\tfor(int i=st;i<=ed;++i) {\n\t\tadj[i].clear();\n\t}\n\tfor(int i=1;i<=K;++i) {\n\t\tLx[i]=Ly[i]=0;\n\t\tRx[i]=Ry[i]=101;\n\t}\n\tfor(int i=1;i<=M;++i) {\n\t\tswitch(t[i]) {\n\t\t\tcase 'L': Lx[b[i]+1]=a[i]+1; break;\n\t\t\tcase 'R': Rx[K-b[i]]=a[i]-1; break;\n\t\t\tcase 'D': Ly[b[i]+1]=a[i]+1; break;\n\t\t\tcase 'U': Ry[K-b[i]]=a[i]-1; break;\n\t\t}\n\t}\n\tfor(int i=1;i<K;++i) {\n\t\tif(Lx[i]>Lx[i+1]) Lx[i+1]=Lx[i];\n\t\tif(Ly[i]>Ly[i+1]) Ly[i+1]=Ly[i];\n\t}\n\tfor(int i=K;i>1;--i) {\n\t\tif(Rx[i]<Rx[i-1]) Rx[i-1]=Rx[i];\n\t\tif(Ry[i]<Ry[i-1]) Ry[i-1]=Ry[i];\n\t}\n\tfor(int i=1;i<=K;++i) {\n\t\taddedge(st,i,1,0);\n\t\tfor(int j=1;j<=N;++j) {\n\t\t\tif(x[j]>=Lx[i]&&x[j]<=Rx[i]) {\n\t\t\t\taddedge(i,K+j,1,0);\n\t\t\t}\n\t\t\tif(y[j]>=Ly[i]&&y[j]<=Ry[i]) {\n\t\t\t\taddedge(K+N+j,K+N+N+i,1,0);\n\t\t\t}\n\t\t}\n\t\taddedge(K+N+N+i,ed,1,0);\n\t}\n\tfor(int i=1;i<=N;++i) {\n\t\taddedge(K+i,K+N+i,1,v[i]);\n\t}\n\tint flow=0; ll cost=0;\n\tMCMF::maxflow(flow,cost);\n\treturn flow==K?cost:-inf;\n}\nint main() {\n\tread(N);\n\tfor(int i=1;i<=N;++i) {\n\t\tread(x[i]),read(y[i]),read(v[i]);\n\t}\n\tread(M);\n\tfor(int i=1;i<=M;++i) {\n\t\tstatic char tmp[5];\n\t\tscanf(\"%s\",tmp);\n\t\tt[i]=tmp[0],read(a[i]),read(b[i]);\n\t}\n\tll an=0;\n\tfor(int i=1;i<=N;++i) {\n\t\tan=max(an,sol(i));\n\t}\n\tprintf(\"%lld\\n\",an);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n\n#define fo(i,j,l) for(int i=j;i<=l;++i)\n#define fd(i,j,l) for(int i=j;i>=l;--i)\n\nusing namespace std;\ntypedef long long ll;\nconst ll N=1000,M=N*50,maxn=1e18;\n\nbool bz[N];\nint x[N],y[N];\nll v[N];\nint la[N],lb[M],ne[M],le[M];\nll cost[M];\nint fr[N],f1[N];\n\nint n,m,oo,S,T;\nchar c[N];\nint a[N],b[N],d[M];\nint p[N][2],q[N][2];\nll dis[N];\nll rec;\n\ninline ll max(ll a,ll b)\n{return a>b?a:b;}\n\ninline int min(int a,int b)\n{return a<b?a:b;}\n\ninline void llb(int a,int b,int c,ll co)\n{\n\tne[++oo]=la[a]; la[a]=oo; lb[oo]=b;\n\tle[oo]=c; cost[oo]=co; \n}\n\ninline void gg(int a,int b,int c,ll d)\n{\n\tllb(a,b,c,d); llb(b,a,0,-d);\n}\n\ninline bool flow()\n{\n\tfo(i,1,T)dis[i]=maxn;\n\tdis[S]=0;\n\tint l=0,r=1; d[1]=S; bz[S]=true;\n\twhile(l<r){\n\t\tint o=d[++l];\n\t\tfor(int y=la[o];y;y=ne[y])\n\t\tif(dis[o]-cost[y]<dis[lb[y]]&&le[y]==1){\n\t\t\tdis[lb[y]]=dis[o]-cost[y];\n\t\t\tfr[lb[y]]=o; f1[lb[y]]=y;\n\t\t\tif(!bz[lb[y]])d[++r]=lb[y],bz[lb[y]]=true;\n\t\t}\n\t\tbz[o]=false;\n\t}\n\tif(dis[T]==maxn)return false;\n\trec=0;\n\tfor(int u=T;u!=S;u=fr[u]){\n\t\tint k=f1[u];\n\t\tle[k]=0;\n\t\tle[k^1]=1;\n\t\trec=rec+cost[k];\n\t}\n\treturn true;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfo(i,1,n)scanf(\"%d%d%lld\",&x[i],&y[i],&v[i]);\n\tscanf(\"%d\",&m);\n\tfo(i,1,m){\n\t\tchar ch=' ';\n\t\tfor(;ch!='L'&&ch!='R'&&ch!='D'&&ch!='U';ch=getchar());\n\t\tc[i]=ch;\n\t\tscanf(\"%d%d\",&a[i],&b[i]);\n\t}\n\tll ans=0;\n\tfo(i,1,n){\n\t\tfo(l,1,i)p[l][0]=1,p[l][1]=100;\n\t\tfo(l,1,i)q[l][0]=1,q[l][1]=100;\n\t\tfo(l,1,m)\n\t\tif(c[l]=='L'&&b[l]<i){\n\t\t\tfo(j,b[l]+1,i)p[j][0]=max(p[j][0],a[l]+1);\n\t\t} else if(c[l]=='R'&&b[l]<i){\n\t\t\tfo(j,1,i-b[l])p[j][1]=min(p[j][1],a[l]-1);\n\t\t} else if(c[l]=='U'&&b[l]<i){\n\t\t\tfo(j,1,i-b[l])q[j][1]=min(q[j][1],a[l]-1);\n\t\t} else if(c[l]=='D'&&b[l]<i){\n\t\t\tfo(j,b[l]+1,i)q[j][0]=max(q[j][0],a[l]+1);\n\t\t}\n\t\tint ok=0;\n\t\tfo(l,1,i)if(p[l][0]>p[l][1]||q[l][0]>q[l][1]){ok=1; break;}\n\t\tif(ok)continue;\n\t\too=1;\n\t\tS=2*i+200+1,T=S+1;\n\t\tfo(j,1,T)la[j]=0;\n\t\tfo(l,1,i)gg(S,l,1,0);\n\t\tfo(l,1,i)gg(i+200+l,T,1,0);\n\t\tfo(j,1,i)fo(l,p[j][0],p[j][1])gg(j,i+l,1,0);\n\t\tfo(j,1,i)fo(l,q[j][0],q[j][1])gg(100+i+l,200+i+j,1,0);\n\t\tfo(l,1,n)gg(i+x[l],i+100+y[l],1,v[l]);\n\t\tll da=0; int cs=0;\n\t\twhile(flow()){\n\t\t\tda=da+rec;\n\t\t\t++cs;\n\t\t}\n\t\tif(cs==i)ans=max(ans,da);\n\t}\n\tcout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-03-27 10:28:38\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\n#define i64 long long\ni64 read()\n{\n\ti64 r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\nconst int N=2010;\nnamespace run\n{\n\tconst i64 inf=1ll<<60;\n\ti64 n,px[N],sx[N],py[N],sy[N],begin[N],next[N<<2],to[N<<2],w[N<<2],c[N<<2],e,S,T,m,x[N],y[N],v[N],ans,l,sw,sc;\n\ti64 d[N],q[N*N],_l,_r,pre[N],vis[N];\n\tvoid add(i64 u,i64 v,i64 W,i64 C){ e++; next[e]=begin[u]; begin[u]=e; to[e]=v; w[e]=W; c[e]=C; }\n\tvoid Add(i64 u,i64 v,i64 w,i64 c){ /*printf(\"%I64d %I64d %I64d\\n\",u,v,c);*/ add(u,v,w,c); add(v,u,0,-c); }\n#define fo(i,a) for(int i=begin[a];i;i=next[i])\n\tint bfs()\n\t{\n\t\tfr(i,1,m){ d[i]=inf; pre[i]=0; vis[i]=0; }\n\t\tq[_l=_r=1]=S; d[S]=0;\n\t\twhile(_l<=_r)\n\t\t{\n\t\t\tint u=q[_l++]; vis[u]=0;\n//\t\t\tprintf(\"%d\\n\",u);\n\t\t\tfo(i,u) if(w[i]&&d[u]+c[i]<d[to[i]])\n\t\t\t{\n\t\t\t\td[to[i]]=d[u]+c[i]; pre[to[i]]=i;\n\t\t\t\tif(!vis[to[i]]){ q[++_r]=to[i]; vis[to[i]]=1; }\n\t\t\t}\n\t\t}\n\t\treturn d[T]!=inf;\n\t}\n\ti64 solve(int c)\n\t{\n\t\tmemset(begin,0,sizeof(begin)); e=1; S=n+n+c+c+1; T=n+n+c+c+2; m=T;\n//\t\tprintf(\"%d %I64d %I64d\\n\",c,S,T);\n\t\tfr(i,1,n) Add(i,i+n,1,-v[i]);\n\t\tfr(j,1,c){ Add(S,j+n+n,1,0); Add(j+n+n+c,T,1,0); }\n\t\tfr(i,1,n) fr(j,1,c) if(px[x[i]]>=j&&sx[x[i]]>=c-j+1) Add(j+n+n,i,1,0);\n\t\tfr(i,1,n) fr(j,1,c) if(py[y[i]]>=j&&sy[y[i]]>=c-j+1) Add(i+n,j+n+n+c,1,0);\n\t\tsw=sc=0;\n\t\tfr(i,1,c) if(bfs())\n\t\t{\n//\t\t\tprintf(\"%I64d\\n\",d[T]);\n\t\t\tint u=T; sw++;\n\t\t\twhile(u!=S){ w[pre[u]]--; w[pre[u]^1]++; sc-=::run::c[pre[u]]; u=to[pre[u]^1]; }\n\t\t}\n\t\telse return 0;\n//\t\tprintf(\"%d %I64d\\n\",c,sw==c?sc:0);\n\t\treturn sc;\n\t}\n\tint main()\n\t{\n\t\tn=read(); l=100;\n\t\tfr(i,1,n){ x[i]=read(); y[i]=read(); v[i]=read(); }\n\t\tfr(i,0,l+1) px[i]=sx[i]=py[i]=sy[i]=n;\n\t\tfr(i,1,read())\n\t\t{\n\t\t\tchar opt[N]; i64 a,b;\n\t\t\tscanf(\"%s\",opt); a=read(); b=read();\n\t\t\tif(*opt=='L') px[a]=std::min(px[a],b);\n\t\t\tif(*opt=='R') sx[a]=std::min(sx[a],b);\n\t\t\tif(*opt=='D') py[a]=std::min(py[a],b);\n\t\t\tif(*opt=='U') sy[a]=std::min(sy[a],b);\n\t\t}\n\t\tfr(i,1,l){ sx[i]=std::min(sx[i],sx[i-1]); sy[i]=std::min(sy[i],sy[i-1]); }\n\t\tfd(i,l,1){ px[i]=std::min(px[i],px[i+1]); py[i]=std::min(py[i],py[i+1]); }\n//\t\tfr(i,1,n) printf(\"%I64d %I64d %I64d %I64d\\n\", );\n\t\tfr(i,1,n){ i64 k=solve(i); ans=std::max(ans,k); if(!k) break; }\n\t\tprintf(\"%lld\\n\",ans);\n\t\treturn 0;\n\t}\n}\nint main(){ return run::main(); }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#define dibs reserve\n#define OVER9000 1234567890\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) (((x) < 0)?-(x):(x))\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\nusing cat = long long;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\nstruct Edge\n{\n    int from, to, capacity;\n    cat cost;\n};\n\nvector<vector<int>> adj, capacity;\nvector<vector<cat>> cost;\n\nconst cat INF = (cat)1e18;\n\nvoid shortest_paths(int n, int v0, vector<cat>& d, vector<int>& p) {\n    d.assign(n, INF);\n    d[v0] = 0;\n    vector<int> m(n, 2);\n    deque<int> q;\n    q.push_back(v0);\n    p.assign(n, -1);\n\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop_front();\n        m[u] = 0;\n        for (int v : adj[u]) {\n            if (capacity[u][v] > 0 && d[v] > d[u] + cost[u][v]) {\n                d[v] = d[u] + cost[u][v];\n                p[v] = u;\n                if (m[v] == 2) {\n                    m[v] = 1;\n                    q.push_back(v);\n                } else if (m[v] == 0) {\n                    m[v] = 1;\n                    q.push_front(v);\n                }\n            }\n        }\n    }\n}\n\ncat min_cost_flow(int N, vector<Edge> edges, int K, int s, int t) {\n    adj.assign(N, vector<int>());\n    cost.assign(N, vector<cat>(N, 0));\n    capacity.assign(N, vector<int>(N, 0));\n    for (Edge e : edges) {\n        adj[e.from].push_back(e.to);\n        adj[e.to].push_back(e.from);\n        cost[e.from][e.to] = e.cost;\n        cost[e.to][e.from] = -e.cost;\n        capacity[e.from][e.to] = e.capacity;\n    }\n\n    int flow = 0;\n    cat cost_ = 0;\n    vector<int> p;\n    vector<cat> d;\n    while (flow < K) {\n        shortest_paths(N, s, d, p);\n        if (d[t] == INF)\n            break;\n\n        // find max flow on that path\n        int f = K - flow;\n        int cur = t;\n        while (cur != s) {\n            f = min(f, capacity[p[cur]][cur]);\n            cur = p[cur];\n        }\n\n        // apply flow\n        flow += f;\n        cost_ += f * d[t];\n        cur = t;\n        while (cur != s) {\n            capacity[p[cur]][cur] -= f;\n            capacity[cur][p[cur]] += f;\n            cur = p[cur];\n        }\n    }\n\n    // cout << flow << \"\\n\";\n    // for (Edge e : edges)\n    //     cout << e.from << \" \" << e.to << \" \" << e.capacity << \" \" << e.cost << \" \" << capacity[e.to][e.from] << \"\\n\";\n    if (flow < K)\n        return -1;\n    else\n        return cost_;\n}\n\nstruct jewel {\n\tint x, y;\n\tcat w;\n};\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\tint N, M;\n\tcin >> N;\n\tvector<jewel> J(N);\n\tfor(int i = 0; i < N; i++) cin >> J[i].x >> J[i].y >> J[i].w;\n\tvector< pair<int, int> > cond[4];\n\tcin >> M;\n\tfor(int i = 0; i < M; i++) {\n\t\tstring tp;\n\t\tint a, b;\n\t\tcin >> tp >> a >> b;\n\t\tif(tp == \"L\") cond[0].push_back({a, b});\n\t\tif(tp == \"D\") cond[1].push_back({a, b});\n\t\tif(tp == \"R\") cond[2].push_back({a-1, b});\n\t\tif(tp == \"U\") cond[3].push_back({a-1, b});\n\t}\n\tfor(int k = 0; k < 4; k++) {\n\t\tsort(begin(cond[k]), end(cond[k]));\n\t\tif(k/2 == 0) reverse(begin(cond[k]), end(cond[k]));\n\t\twhile(true) {\n\t\t\tbool stop = true;\n\t\t\tfor(int i = 0; i < (int)cond[k].size(); i++)\n\t\t\t\tfor(int j = 0; j < (int)cond[k].size(); j++) if(i != j)\n\t\t\t\t\tif(cond[k][i].ff == cond[k][j].ff && cond[k][i].ss < cond[k][j].ss) {\n\t\t\t\t\t\tcond[k].erase(begin(cond[k])+j);\n\t\t\t\t\t\tstop = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\tfor(int i = 0; i < (int)cond[k].size(); i++)\n\t\t\t\tfor(int j = i+1; j < (int)cond[k].size(); j++)\n\t\t\t\t\tif(cond[k][i].ss <= cond[k][j].ss) {\n\t\t\t\t\t\tcond[k].erase(begin(cond[k])+j);\n\t\t\t\t\t\tstop = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\tif(stop) break;\n\t\t}\n\t\tif(k/2 != 0) reverse(begin(cond[k]), end(cond[k]));\n\t}\n\tcat MX = 1e15;\n\tcat ans = 0;\n\tfor(int K = 1; K <= N; K++) {\n\t\tvector<Edge> edges;\n\t\tedges.push_back({0, 1, K, 0});\n\t\tint V = 2, S = 0;\n\t\tbool ok = true;\n\t\tvector< pair<int, int> > m[2] = {{{1, 100}}, {}}, b;\n\t\tfor(int a[2] = {0, 0}; a[0] < (int)cond[0].size() || a[1] < (int)cond[2].size();) {\n\t\t\tint i = 0;\n\t\t\tif(a[0] == (int)cond[0].size()) i = 1;\n\t\t\telse if(a[1] < (int)cond[2].size() && cond[2][a[1]].ff > cond[0][a[0]].ff) i = 1;\n\t\t\tif(i == 1 && K-cond[2][a[1]].ss > 0) {\n\t\t\t\tedges.push_back({V-1, V, K, 0});\n\t\t\t\tedges.push_back({V+1, V, K-cond[2][a[1]].ss, MX});\n\t\t\t\tedges.push_back({V+1, V+2, K, 0});\n\t\t\t\tedges.push_back({0, V+1, K-cond[2][a[1]].ss, 0});\n\t\t\t\tb.push_back({V, K-cond[2][a[1]].ss});\n\t\t\t\tS += K-cond[2][a[1]].ss;\n\t\t\t}\n\t\t\tm[0].push_back({V+2*i, cond[2*i][a[i]].ff});\n\t\t\tedges.push_back({V-1, V+2*i, (i == 0) ? cond[0][a[0]].ss : K, 0});\n\t\t\tV += 1+2*i;\n\t\t\ta[i]++;\n\t\t}\n\t\tV++;\n\t\treverse(begin(cond[1]), end(cond[1]));\n\t\treverse(begin(cond[3]), end(cond[3]));\n\t\tfor(int a[2] = {0, 0}; a[0] < (int)cond[1].size() || a[1] < (int)cond[3].size();) {\n\t\t\tint i = 0;\n\t\t\tif(a[0] == (int)cond[1].size()) i = 1;\n\t\t\telse if(a[1] < (int)cond[3].size() && cond[3][a[1]].ff < cond[1][a[0]].ff) i = 1;\n\t\t\tif(i == 1 && K-cond[3][a[1]].ss > 0) {\n\t\t\t\tedges.push_back({V-1, V, K, 0});\n\t\t\t\tedges.push_back({V+1, V, K-cond[3][a[1]].ss, MX});\n\t\t\t\tedges.push_back({V+1, V+2, K, 0});\n\t\t\t\tedges.push_back({0, V+1, K-cond[3][a[1]].ss, 0});\n\t\t\t\tb.push_back({V, K-cond[3][a[1]].ss});\n\t\t\t\tS += K-cond[3][a[1]].ss;\n\t\t\t}\n\t\t\tm[1].push_back({V-1, cond[2*i+1][a[i]].ff});\n\t\t\tedges.push_back({V-1, V+2*i, (i == 0) ? cond[1][a[0]].ss : K, 0});\n\t\t\tV += 1+2*i;\n\t\t\ta[i]++;\n\t\t}\n\t\treverse(begin(cond[1]), end(cond[1]));\n\t\treverse(begin(cond[3]), end(cond[3]));\n\t\tif(!ok) continue;\n\t\tint last = V-1;\n\t\tm[1].push_back({last, 100});\n\t\treverse(begin(m[1]), end(m[1]));\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tint a[2] = {0, 0};\n\t\t\twhile(a[0] < (int)m[0].size()) {\n\t\t\t\tif(m[0][a[0]].ss < J[i].x) break;\n\t\t\t\ta[0]++;\n\t\t\t}\n\t\t\twhile(a[1] < (int)m[1].size()) {\n\t\t\t\tif(m[1][a[1]].ss < J[i].y) break;\n\t\t\t\ta[1]++;\n\t\t\t}\n\t\t\tedges.push_back({m[0][a[0]-1].ff, V, 1, MX-J[i].w});\n\t\t\tedges.push_back({V, m[1][a[1]-1].ff, 1, 0});\n\t\t\tV++;\n\t\t}\n\t\tedges.push_back({last, V, K, 0});\n\t\tfor(auto p : b) edges.push_back({p.ff, V, p.ss, 0});\n\t\tcat mcf = min_cost_flow(V+1, edges, K+S, 0, V);\n\t\t// cout << K << \" \" << K*MX-mcf << \"!\\n\";\n\t\tif(mcf != -1) ans = max(ans, K*MX - mcf);\n\t}\n\tcout << ans << \"\\n\";\n\treturn 0;\n}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define CO const\n#define IN inline\ntypedef long long int64;\n\ntemplate<class T> IN T read(){\n\tT x=0,w=1;char c=getchar();\n\tfor(;!isdigit(c);c=getchar())if(c=='-') w=-w;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0';\n\treturn x*w;\n}\ntemplate<class T> IN T read(T&x){\n\treturn x=read<T>();\n}\n\nCO int N=400;\nCO int64 inf=1e18;\n// namespace flow{\n// \tint n,S,T;\n// \tstruct edge {int v,c;int64 w;int a;};\n// \tvector<edge> to[N];\n// \tint64 dis[N];int vis[N];\n\n// \tIN void init(int n){\n// \t\tflow::n=n,S=n-1,T=n;\n// \t\tfor(int i=1;i<=n;++i) to[i].clear();\n// \t}\n// \tIN void link(int u,int v,int c,int64 w){\n// \t\t// cerr<<\"link \"<<u<<\" \"<<v<<\" \"<<c<<\" \"<<w<<endl;\n// \t\tto[u].push_back({v,c,w}),to[v].push_back({u,0,-w});\n// \t\tto[u].back().a=to[v].size()-1,to[v].back().a=to[u].size()-1;\n// \t}\n// \tbool bfs(){\n// \t\tfill(dis+1,dis+n+1,-inf),dis[T]=0;\n// \t\tdeque<int> Q={T};\n// \t\tfill(vis+1,vis+n+1,0),vis[T]=1;\n// \t\twhile(Q.size()){\n// \t\t\tint u=Q.front();\n// \t\t\tQ.pop_front(),vis[u]=0;\n// \t\t\tfor(CO edge&e:to[u])if(to[e.v][e.a].c)\n// \t\t\t\tif(dis[e.v]<dis[u]+e.w){\n// \t\t\t\t\tdis[e.v]=dis[u]+e.w;\n// \t\t\t\t\tif(vis[e.v]) continue;\n// \t\t\t\t\tif(Q.size() and dis[e.v]>=dis[Q.front()])\n// \t\t\t\t\t\tQ.push_front(e.v);\n// \t\t\t\t\telse Q.push_back(e.v);\n// \t\t\t\t\tvis[e.v]=1;\n// \t\t\t\t}\n// \t\t}\n// \t\treturn dis[S]>-inf;\n// \t}\n// \tint dfs(int u,int lim){\n// \t\tif(u==T) return lim;\n// \t\t// vis[u]=1;\n// \t\tint rest=lim;\n// \t\tfor(edge&e:to[u])if(!vis[e.v] and e.c and dis[e.v]==dis[u]-e.w){\n// \t\t\tint delta=dfs(e.v,min(e.c,rest));\n// \t\t\tif(!delta) {dis[e.v]=-inf;continue;}\n// \t\t\trest-=delta,e.c-=delta,to[e.v][e.a].c+=delta;\n// \t\t\tif(!rest) break;\n// \t\t}\n// \t\tvis[u]=0;\n// \t\treturn lim-rest;\n// \t}\n// \tint64 main(){\n// \t\tint64 ans=0;\n// \t\twhile(bfs()) ans+=dfs(S,1e9)*dis[S],cerr<<ans<<endl;\n// \t\treturn ans;\n// \t}\n// }\n\nnamespace flow{\n    int n,S,T;\n    vector<int> to[N],nx[N],cap[N];\n\tvector<int64> cst[N];\n    int dis[N],vis[N];\n    deque<int> q;\n    \n\tIN void init(int n){\n\t\tflow::n=n,S=n-1,T=n;\n\t\tfor(int i=1;i<=n;++i){\n\t\t\tto[i].clear(),nx[i].clear(),cap[i].clear(),cst[i].clear();\n\t\t}\n\t}\n    IN void link(int u,int v,int c,int64 w){\n        to[u].push_back(v),cap[u].push_back(c),cst[u].push_back(w);\n        to[v].push_back(u),cap[v].push_back(0),cst[v].push_back(-w);\n        nx[u].push_back(to[v].size()-1),nx[v].push_back(to[u].size()-1);\n    }\n    bool lpfa(){\n        fill(dis+1,dis+n+1,-1),dis[T]=0;\n        q.push_back(T);\n        fill(vis+1,vis+n+1,0),vis[T]=1;\n        while(q.size()){\n            int x=q.front();\n            q.pop_front(),vis[x]=0;\n            for(int i=0;i<(int)to[x].size();++i){\n                int y=to[x][i],c=cap[y][nx[x][i]],w=-cst[x][i];\n                if(c&&dis[y]<dis[x]+w){\n                    dis[y]=dis[x]+w;\n                    if(!vis[y]){\n                        if(q.size()&&dis[y]>=dis[q.front()]) q.push_front(y);\n                        else q.push_back(y);\n                        vis[y]=1;\n                    }\n                }\n            }\n        }\n        return dis[S]>-1;\n    }\n    int dfs(int x,int lim){\n        if(x==T) return lim;\n        vis[x]=1;\n        int re=lim;\n        for(int i=0;re&&i<(int)to[x].size();++i){\n            int y=to[x][i],&c=cap[x][i],w=cst[x][i];\n            if(!vis[y]&&c&&dis[y]==dis[x]-w){\n                int delta=dfs(y,min(re,c));\n                if(!delta) {vis[y]=1;continue;}\n                re-=delta,c-=delta,cap[y][nx[x][i]]+=delta;\n            }\n        }\n        vis[x]=0;\n        return lim-re;\n    }\n    int64 main(){\n        int64 ans=0;\n        while(lpfa()) ans+=dfs(S,1e9)*dis[S];\n        return ans;\n    }\n}\n\nint n,X[N],Y[N];int64 V[N];\nint m,O[N],A[N],B[N];\nint L[N],R[N],D[N],U[N];\n\nint64 solve(int s){\n\tfill(L+1,L+s+1,0),fill(D+1,D+s+1,0);\n\tfill(R+1,R+s+1,n+1),fill(U+1,U+s+1,n+1);\n\tfor(int i=1;i<=m;++i)if(B[i]<s){\n\t\tif(O[i]=='L') L[B[i]+1]=A[i]+1;\n\t\telse if(O[i]=='R') R[s-B[i]]=A[i]-1;\n\t\telse if(O[i]=='D') D[B[i]+1]=A[i]+1;\n\t\telse U[s-B[i]]=A[i]-1;\n\t}\n\tfor(int i=2;i<=s;++i){\n\t\tL[i]=max(L[i],L[i-1]);\n\t\tD[i]=max(D[i],D[i-1]);\n\t}\n\tfor(int i=s-1;i>=1;--i){\n\t\tR[i]=min(R[i],R[i+1]);\n\t\tU[i]=min(U[i],U[i+1]);\n\t}\n\tflow::init(2*n+2*s+2);\n\tfor(int i=1;i<=n;++i) flow::link(i,i+n,1,V[i]);\n\tfor(int i=1;i<=s;++i){\n\t\tflow::link(flow::S,i+2*n,1,0),flow::link(i+2*n+s,flow::T,1,0);\n\t\tfor(int j=1;j<=n;++j){\n\t\t\tif(L[i]<=X[j] and X[j]<=R[i]) flow::link(i+2*n,j,1,0);\n\t\t\tif(D[i]<=Y[j] and Y[j]<=U[i]) flow::link(j+n,i+2*n+s,1,0);\n\t\t}\n\t}\n\treturn flow::main();\n}\nint main(){\n\tread(n);\n\tfor(int i=1;i<=n;++i) read(X[i]),read(Y[i]),read(V[i]);\n\tread(m);\n\tfor(int i=1;i<=m;++i){\n\t\tchar opt[2];scanf(\"%s\",opt);\n\t\tO[i]=opt[0],read(A[i]),read(B[i]);\n\t}\n\tint64 ans=0;\n\tfor(int i=1;i<=n;++i) ans=max(ans,solve(i));\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 1000005\nint tot,last[N],to[N],Next[N],flow[N];\nlong long val[N],dis[N];\nint e[N],q[10000005],S,T,Lx[N],Rx[N],Ly[N],Ry[N];\nint X[N],Y[N],n,m,pre[N];\nstruct node {\n  \tint id,x,y;\n}b[N],A[N];\nstruct pa {\n  \tint x,y;\n  \tlong long v;\n}a[N];\ninline void add(int x,int y,int f,long long v) {\n  Next[++tot]=last[x]; last[x]=tot; to[tot]=y; flow[tot]=f; val[tot]=v;\n}\n#define inf 1000000000000000000ll\ninline bool spfa() {\n  \tfor (int i=S;i<=T;i++) pre[i]=0,dis[i]=-inf,e[i]=0;\n  \tdis[S]=0; e[S]=1;\n  \tint l=0,r=1; q[1]=S;\n  \twhile (l<r) {\n      \tint k=q[++l];\n      \tfor (int i=last[k];i;i=Next[i]) {\n          \tif (!flow[i]||dis[to[i]]>=dis[S]+val[i]) continue;\n          \tdis[to[i]]=dis[S]+val[i];\n          \tpre[to[i]]=i;\n          \tif (!e[to[i]]) e[q[++r]=to[i]]=1;\n        }\n      \te[k]=0;\n    }\n  \treturn dis[T]!=-inf;\n}\ninline long long dinic(int y) {\n  \tlong long ans=0;\n  \tint s=0;\n  \twhile (spfa()) {\n      \ts++;\n      \tfor (int x=T;x!=S;x=to[pre[x]^1]) flow[pre[x]]--,flow[pre[x]^1]++,ans+=val[pre[x]];\n    }\n  \tif (s!=y) return 0;\n  \treturn ans;\n}\ninline long long work(int x) {\n  for (int i=1;i<=m;i++) if (b[i].id&1) A[i]=b[i];\n  else A[i]=node{b[i].id,x-b[i].x,b[i].y};\n  for (int i=1;i<=m;i++) if (A[i].x<0||(A[i].x==0&&!(A[i].id&1))) return 0;\n  for (int i=1;i<=x;i++) X[i]=2*n+i,Y[i]=2*n+i+x;\n  S=0,T=Y[x]+1;\n  for (int i=S;i<=T;i++) last[i]=0;\n  tot=1;\n  for (int i=1;i<=x;i++) Lx[i]=Ly[i]=1,Rx[i]=Ry[i]=100;\n  for (int i=1;i<=m;i++) {\n    if (A[i].id==1) Lx[A[i].x+1]=max(Lx[A[i].x+1],A[i].y+1);\n    else if (A[i].id==2) Rx[A[i].x]=min(Rx[A[i].x],A[i].y);\n    else if (A[i].id==3) Ly[A[i].x+1]=max(Ly[A[i].x+1],A[i].y+1);\n    else Ry[A[i].x]=min(Ry[A[i].x],A[i].y);\n  }\n  for (int i=1;i<=x;i++) Lx[i]=max(Lx[i],Lx[i-1]),Ly[i]=max(Ly[i],Ly[i-1]);\n  for (int i=x-1;i;i--) Rx[i]=min(Rx[i],Rx[i+1]),Ry[i]=min(Ry[i],Ry[i+1]);\n  for (int i=1;i<=x;i++) if (Lx[i]>Rx[i]) return false;\n  for (int i=1;i<=x;i++) add(S,X[i],1,0),add(X[i],S,0,0),add(Y[i],T,1,0),add(T,Y[i],0,0);\n  for (int i=1;i<=x;i++)\n  for (int j=1;j<=n;j++) {\n    \tif (a[j].x>=Lx[i]&&a[j].x<=Rx[i]) add(X[i],j,1,0),add(j,X[i],0,0);\n    \tif (a[j].y>=Ly[i]&&a[j].y<=Ry[i]) add(j+n,Y[i],1,0),add(Y[i],j+n,0,0);\n  }\n  for (int i=1;i<=n;i++) add(i,i+n,1,a[i].v),add(i+n,i,0,-a[i].v);\n  return dinic(x);\n}\nchar c[15];\nint main() {\n  scanf(\"%d\",&n);\n  for (int i=1;i<=n;i++) scanf(\"%d%d%lld\",&a[i].x,&a[i].y,&a[i].v);\n  scanf(\"%d\",&m);\n  for (int i=1;i<=m;i++) {\n    \tscanf(\"%s\",c);\n    \tscanf(\"%d%d\",&b[i].y,&b[i].x);\n    \tif (c[0]=='L') b[i].id=1;\n    \tif (c[0]=='R') b[i].id=2;\n    \tif (c[0]=='D') b[i].id=3;\n    \tif (c[0]=='U') b[i].id=4;\n  }\n  long long ans=0;\n  for (int i=4;i<=n;i++) \n\tans=max(ans,work(i));\n  printf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FOR(i,a,b) for (int i=a;i<=b;++i)\n#define REP(i,n) FOR(i,1,n)\n#define REP_0N(i,n) FOR(i,0,n)\n#define N 1005\n#define M 1005\nusing namespace std;\ntypedef __float128 ld;\nconst ld eps=1e-3; ld inf=1e18;\nint n,m,id[N],tp[N];\nld a[M][N],T,sum[N][M],A[N],d[N],x[N];\nint B[N];\nchar c[N];\nstruct node {\n    int x,y;\n    long long v;\n}b[N];inline void pivot(int r,int c) {\n    swap(id[r+n],id[c]);\n    ld t=-a[r][c];\n    a[r][c]=-1;\n    REP_0N(i,n) a[r][i]/=t;\n    REP_0N(i,m)\n    if (a[i][c]&&r!=i) {\n        t=a[i][c];\n        a[i][c]=0;\n        REP_0N(j,n) a[i][j]+=t*a[r][j];\n    }\n}\nvoid solve() {\n    ld t;\n    REP(i,n) id[i]=i;\n    while (true) {\n        int i=0,j=0; ld w=-eps;\n        REP(k,m) if (a[k][0]<w) w=a[i=k][0];\n        if (!i) break;\n        REP(k,n) if (a[i][k]>eps) {j=k; break;}\n        if (!j) return ;\n        pivot(i,j);\n    }\n    while (true) {\n        int i=0,j=0; ld w=eps;\n        REP(k,n) if (a[0][k]>w) w=a[0][j=k];\n        if (!j) break;\n        w=inf;\n        REP(k,m) if (a[k][j]<-eps&&(t=-a[k][0]/a[k][j])<w) w=t,i=k;\n        if (!i) return ;\n        pivot(i,j);\n    }\n    FOR(i,n+1,n+m) tp[id[i]]=i-n;\n    REP(i,n) x[i]=tp[i]?a[tp[i]][0]:0;\n    return ;\n}\nint main() {\n    scanf(\"%d\",&n);\n    for (int i=1;i<=n;i++) {\n        scanf(\"%d%d%lld\",&b[i].x,&b[i].y,&b[i].v);\n        a[0][i]=b[i].v;\n    }\n    scanf(\"%d\",&m);\n    for (int i=1;i<=m;i++) {\n        scanf(\"%s\",c);\n        int x,y;\n        scanf(\"%d%d\",&x,&y);\n        a[i][0]=y;\n        if (c[0]=='L') {\n            for (int j=1;j<=n;j++) if (b[j].x<=x) a[i][j]=-1;\n        }\n        else if (c[0]=='R') {\n            for (int j=1;j<=n;j++) if (b[j].x>=x) a[i][j]=-1;\n        }\n        else if (c[0]=='D') {\n            for (int j=1;j<=n;j++) if (b[j].y<=x) a[i][j]=-1;\n        }\n        else if (c[0]=='U') {\n            for (int j=1;j<=n;j++) if (b[j].y>=x) a[i][j]=-1;\n        }\n    }\n    for (int i=1;i<=n;i++) {\n        a[++m][0]=1;\n        a[m][i]=-1;\n    }\n    solve();\n    ld ans=0;\n    for (int i=1;i<=n;i++) ans+=b[i].v*x[i];\n    printf(\"%lld\\n\",(long long)(ans+0.5));\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\ntemplate<typename T>\nstruct PrimalDual{\n  struct edge{\n    Int to;\n    T cap,cost;\n    Int rev;\n    edge(){}\n    edge(Int to,T cap,T cost,Int rev):to(to),cap(cap),cost(cost),rev(rev){}\n  };\n  \n  T INF;\n  vector<vector<edge> > G;\n  vector<T> h,dist;\n  vector<Int> prevv,preve;\n\n  PrimalDual(){}\n  PrimalDual(Int n,T INF):INF(INF),G(n),h(n),dist(n),prevv(n),preve(n){}\n  \n  void add_edge(Int from,Int to,T cap,T cost){\n    G[from].emplace_back(to,cap,cost,G[to].size());\n    G[to].emplace_back(from,0,-cost,G[from].size()-1);\n  }\n\n  T flow(Int s,Int t,T f,Int &ok){    \n    T res=0;\n    fill(h.begin(),h.end(),0);\n    while(f>0){\n      using P = pair<T, Int>;\n      priority_queue<P,vector<P>,greater<P> > que;\n      fill(dist.begin(),dist.end(),INF);\n      \n      dist[s]=0;\n      que.emplace(dist[s],s);\n      while(!que.empty()){\n        P p=que.top();que.pop();\n        Int v=p.second;\n        if(dist[v]<p.first) continue;\n        for(Int i=0;i<(Int)G[v].size();i++){\n          edge &e=G[v][i];\n          if(e.cap==0) continue;\n          if(dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n            dist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n            prevv[e.to]=v;\n            preve[e.to]=i;\n            que.emplace(dist[e.to],e.to);\n          }\n        }\n      }\n      if(dist[t]==INF) return ok=0;\n      \n      for(Int v=0;v<(Int)h.size();v++) h[v]+=dist[v];\n\n      T d=f;\n      for(Int v=t;v!=s;v=prevv[v])\n        d=min(d,G[prevv[v]][preve[v]].cap);\n      \n      f-=d;\n      res+=d*h[t];\n      for(Int v=t;v!=s;v=prevv[v]){\n        edge &e=G[prevv[v]][preve[v]];\n        e.cap-=d;\n        G[v][e.rev].cap+=d;\n      }\n    }\n    ok=1;\n    return res;\n  }\n};\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<Int> xs(n),ys(n),vs(n);\n  for(Int i=0;i<n;i++) cin>>xs[i]>>ys[i]>>vs[i];\n\n  Int m;\n  cin>>m;\n  vector<char> ts(m);\n  vector<Int> as(m),bs(m);\n  for(Int i=0;i<m;i++) cin>>ts[i]>>as[i]>>bs[i];\n\n  const Int INF = 1e16;\n  vector<Int> ls(n,-INF),rs(n,INF),ds(n,-INF),us(n,INF);\n  for(Int i=0;i<m;i++){\n    if(ts[i]=='L') chmax(ls[bs[i]],as[i]);\n    if(ts[i]=='R') chmin(rs[bs[i]],as[i]);\n    if(ts[i]=='D') chmax(ds[bs[i]],as[i]);\n    if(ts[i]=='U') chmin(us[bs[i]],as[i]);\n  }\n  for(Int i=0;i+1<n;i++){\n    chmax(ls[i+1],ls[i]);\n    chmin(rs[i+1],rs[i]);\n    chmax(ds[i+1],ds[i]);\n    chmin(us[i+1],us[i]);\n  }\n  \n  Int ans=0;\n  for(Int k=1;k<=n;k++){\n    PrimalDual<Int> G(k*2+n*2+2,INF);\n    Int S=k*2+n*2,T=k*2+n*2+1;\n    for(Int i=0;i<k;i++){\n      G.add_edge(S,i,1,0);\n      G.add_edge(k+i,T,1,0);\n    }\n    \n    for(Int i=0;i<n;i++)\n      G.add_edge(k*2+i,k*2+n+i,1,INF-vs[i]);\n    \n    for(Int i=0;i<k;i++){\n      for(Int j=0;j<k;j++){\n        for(Int p=0;p<n;p++){\n          if(xs[p]<=ls[i]) continue;\n          if(xs[p]>=rs[k-(i+1)]) continue;\n          if(ys[p]<=ds[j]) continue;\n          if(ys[p]>=us[k-(j+1)]) continue;          \n          G.add_edge(i,k*2+p,1,0);     \n          G.add_edge(k*2+n+p,k+j,1,0);\n        }\n      }\n    }\n    \n    Int ok=1;\n    Int res=G.flow(S,T,k,ok);    \n    if(!ok) break;\n    chmax(ans,INF*k-res);\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = (int)1e9;\n\nconst int SRC = 0;\nconst int NODE = 0;\nconst int COND = 100;\nconst int SINK = 450;\n\nint costPerFlow;\nint flow;\n\nvector<int> adjList[505];\nint cost[505][505];\nint res[505][505];\n\nint dist[505];\nint p[505];\nbool bellman() {\n\tfor(int i=0; i<500; i++) dist[i] = INF, p[i] = -1;\n\tdist[SRC] = 0;\n\t//\n\tfor(int xxx=0; xxx<500; xxx++){\n\t\tbool alter = false;\n\t\tfor(int u=0; u<500; u++) for(int v: adjList[u]){\n\t\t\tint _dist = dist[u] + cost[u][v];\n\t\t\tif(_dist < dist[v] && res[u][v] > 0){\n\t\t\t\talter = true;\n\t\t\t\tdist[v] = _dist;\n\t\t\t\tp[v] = u;\n\t\t\t}\n\t\t}\n\t\tif(!alter) break;\n\t}\n\t//\n\treturn dist[SINK];\n}\nvoid augment(int u, int minEdge){\n\tif(u == SRC){ flow = minEdge; return ; }\n\tif(p[u] != -1){\n\t\taugment(p[u], min(minEdge, res[p[u]][u]));\n\t\tres[p[u]][u] -= flow;\n\t\tres[u][p[u]] += flow;\n\t\tcostPerFlow += cost[p[u]][u];\n\t}\n}\n\npair< pair<int,int> , int > dat[105];\nint main() {\n\t// reset\n\tfor(int i=0; i<503; i++) for(int j=0; j<503; j++) cost[i][j] = 0;\n\tfor(int i=0; i<503; i++) for(int j=0; j<503; j++) res[i][j] = 0;\n\t// input\n\tint n; scanf(\"%d\", &n);\n\tint summ = 0;\n\tfor(int i=1; i<=n; i++){\n\t\tscanf(\"%d %d %d\", &dat[i].first.first, &dat[i].first.second, &dat[i].second);\n\t\tadjList[SRC].push_back(NODE+i);\n\t\tadjList[NODE+i].push_back(SRC);\n\t\tcost[SRC][NODE+i] =  dat[i].second;\n\t\tcost[NODE+i][SRC] = -dat[i].second;\n\t\tres[SRC][NODE+i] = 1;\n\t\tsumm += dat[i].second;\n\t}\n\tint m; scanf(\"%d\", &m);\n\tfor(int i=1; i<=m; i++){\n\t\tchar s[5]; scanf(\"%s\", s);\n\t\tint a,b; scanf(\"%d %d\", &a, &b);\n\t\t//\n\t\tfor(int j=1; j<=n; j++){\n\t\t\tif(s[0] == 'L' && dat[i].first.first >= a){\n\t\t\t\tadjList[NODE+i].push_back(COND+j);\n\t\t\t\tadjList[COND+j].push_back(NODE+i);\n\t\t\t\tres[NODE+i][COND+j] = 1;\n\t\t\t}\n\t\t\tif(s[0] == 'R' && dat[i].first.first <= a){\n\t\t\t\tadjList[NODE+i].push_back(COND+j);\n\t\t\t\tadjList[COND+j].push_back(NODE+i);\n\t\t\t\tres[NODE+i][COND+j] = 1;\n\t\t\t}\n\t\t\tif(s[0] == 'D' && dat[i].first.second <= a){\n\t\t\t\tadjList[NODE+i].push_back(COND+j);\n\t\t\t\tadjList[COND+j].push_back(NODE+i);\n\t\t\t\tres[NODE+i][COND+j] = 1;\n\t\t\t}\n\t\t\tif(s[0] == 'U' && dat[i].first.second >= a){\n\t\t\t\tadjList[NODE+i].push_back(COND+j);\n\t\t\t\tadjList[COND+j].push_back(NODE+i);\n\t\t\t\tres[NODE+i][COND+j] = 1;\n\t\t\t}\n\t\t}\n\t\t//\n\t\tadjList[SINK].push_back(COND+i);\n\t\tadjList[COND+i].push_back(SINK);\n\t\tres[COND+i][SINK] = b;\n\t}\n\twhile(bellman()){\n\t\tflow = 0; augment(SINK, INF);\n\t\tif(flow == 0) break;\n\t\tsumm -= costPerFlow;\n\t}\n\tprintf(\"%d\\n\", summ);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fo(i,a,b)for(int i=a,_e=b;i<=_e;++i)\n#define fd(i,a,b)for(int i=b,_e=a;i>=_e;--i)\n#define ll long long\n#define db double\nusing namespace std;\nconst int N=500,mo=1e9+7;\nconst db eps=1e-9;\nint n,x[100],y[100];\nll v[100];\nint m,A,b;\ndb ans,a[N][N];\nchar c;\nvoid simplex(int x,int y,int n,int m){\n\tfo(i,0,m)if(i!=x)a[y][i]/=a[y][x];\n\ta[y][x]=1/a[y][x];\n\tans+=a[0][x]*a[y][0];\n\tfo(i,0,n){\n\t\tif(i==y||abs(a[i][x])<eps)continue;\n\t\tfo(j,0,m)if(j!=x)a[i][j]-=a[i][x]*a[y][j];\n\t\ta[i][x]-=a[i][x]*a[y][x];\n\t}\n}\nvoid solve(int n,int m){\n\tfor(;;){\n\t\tint x=0;\n\t\tfo(i,1,m)if(a[0][i]>eps){x=i;break;}\n\t\tif(!x)return;\n\t\tint y=0;db mi=1e18;\n\t\tfo(i,1,n)if(a[i][x]>eps&&(mi>a[i][0]/a[i][x]))y=i,mi=a[i][0]/a[i][x];\n\t\tsimplex(x,y,n,m);\n\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfo(i,1,n)scanf(\"%d%d%lld\",&x[i],&y[i],&v[i]),a[0][i]=v[i];\n\tscanf(\"%d\\n\",&m);\n\tfo(i,1,m){\n\t\tc=getchar();\n\t\tscanf(\"%d%d\\n\",&A,&b);\n\t\tfo(j,1,n){\n\t\t\tif(c=='L'&&x[j]<=A)a[i][j]=1;\n\t\t\tif(c=='R'&&x[j]>=A)a[i][j]=1;\n\t\t\tif(c=='D'&&y[j]<=A)a[i][j]=1;\n\t\t\tif(c=='U'&&y[j]>=A)a[i][j]=1;\n\t\t}\n\t\ta[i][0]=b;\n\t}\n\tfo(i,m+1,m+n)a[i][0]=1,a[i][i-m]=1;\n\tsolve(m+n,n);\n\tprintf(\"%lld\\n\",(ll)ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <list>\n#include <time.h>\n#include <math.h>\n#include <random>\n#include <deque>\n#include <queue>\n#include <cassert>\n#include <unordered_map>\n#include <unordered_set>\n#include <iomanip>\n#include <bitset>\n#include <sstream>\n#include <chrono>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef __float128 dbl;\nconst int INF = 1.01e9;\n\n__float128 fabs(__float128 x)\n{\n  if (x < 0) return -x;\n  return x;\n}\n \nconst __float128 EPS = 1e-25;\nbool eq(__float128 x, __float128 y) {\n    return fabs(x - y) < EPS;\n}\nbool ls(__float128 x, __float128 y) {\n    return x < y && !eq(x, y);\n}\n \nvector<__float128> simplex(vector<vector<__float128> > a) {\n    int n = a.size() - 1;\n    int m = a[0].size() - 1;\n    vector<int> left(n + 1), up(m + 1);\n    iota(up.begin(), up.end(), 0);\n    iota(left.begin(), left.end(), m);\n    auto pivot = [&](int x, int y) {\n        swap(left[x], up[y]);\n        __float128 k = a[x][y];\n        a[x][y] = 1;\n        vector<int> vct;\n        for (int j = 0; j <= m; j++) {\n            a[x][j] /= k;\n            if (!eq(a[x][j], 0)) vct.push_back(j);\n        }\n        for (int i = 0; i <= n; i++) {\n            if (eq(a[i][y], 0) || i == x) continue;\n            k = a[i][y];\n            a[i][y] = 0;\n            for (int j : vct) a[i][j] -= k * a[x][j];\n        }\n    };\n    while (1) {\n        int x = -1;\n        for (int i = 1; i <= n; i++) if (ls(a[i][0], 0) && (x == -1 || a[i][0] < a[x][0])) x = i;\n        if (x == -1) break;\n        int y = -1;\n        for (int j = 1; j <= m; j++) if (ls(a[x][j], 0) && (y == -1 || a[x][j] < a[x][y])) y = j;\n        if (y == -1) assert(0); // infeasible\n        pivot(x, y);\n    }\n    while (1) {\n        int y = -1;\n        for (int j = 1; j <= m; j++) if (ls(0, a[0][j]) && (y == -1 || a[0][j] > a[0][y])) y = j;\n        if (y == -1) break;\n        int x = -1;\n        for (int i = 1; i <= n; i++) if (ls(0, a[i][y]) && (x == -1 || a[i][0] / a[i][y] < a[x][0] / a[x][y])) x = i;\n        if (x == -1) assert(0); // unbounded\n        pivot(x, y);\n    }\n    vector<__float128> ans(m + 1);\n    for (int i = 1; i <= n; i++) if (left[i] <= m) ans[left[i]] = a[i][0];\n    ans[0] = -a[0][0];\n    return ans;\n}\n\n#ifdef ONPC\n  mt19937 rnd(228);\n#else\n  mt19937 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\n#endif\n\nint main()\n{\n#ifdef ONPC\n  freopen(\"a.in\", \"r\", stdin);\n#endif\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector <int> x(n), y(n);\n  vector <ll> ok;\n  vector <__float128> v;\n  vector <pair <ll, int> > e;\n  for (int i = 0; i < n; i++)\n  {\n    cin >> x[i] >> y[i];\n    ll x;\n    cin >> x;\n    ok.push_back(x);\n    v.push_back(x);\n    e.push_back({x, i});\n  }\n  v.insert(v.begin(), 0);\n  int m;\n  cin >> m;\n  vector <vector <__float128> > mat;\n  mat.push_back(v);\n  for (int i = 0; i < n; i++)\n  {\n    vector <__float128> kek(n + 1);\n    kek[0] = kek[i + 1] = 1;\n    mat.push_back(kek);\n  }\n  vector <vector <int> > simp;\n  for (int i = 0; i < m; i++)\n  {\n    char c;\n    cin >> c;\n    int a;\n    int b;\n    cin >> a >> b;\n    vector <__float128> arr = {(__float128) b};\n    vector <int> kek = {b};\n    for (int j = 0; j < n; j++)\n    {\n      int grab = 0;\n      if (c == 'L' && x[j] <= a) grab = 1;\n      if (c == 'R' && x[j] >= a) grab = 1;\n      if (c == 'D' && y[j] <= a) grab = 1;\n      if (c == 'U' && y[j] >= a) grab = 1;\n      arr.push_back(grab);\n      kek.push_back(grab);\n    }\n    mat.push_back(arr);\n    simp.push_back(kek);\n  }\n  auto good = [&] (vector <int> grab)\n  {\n    for (auto c : simp)\n    {\n      int sum = 0;\n      for (int i = 1; i <= n; i++) sum += grab[i - 1] * c[i];\n      if (sum > c[0])\n      {\n        return false;\n      }\n    }\n    return true;\n  };\n  auto f = [&] (vector <int> grab)\n  {\n    ll sum = 0;\n    for (int i = 0; i < n; i++)\n    {\n      if (grab[i]) sum += ok[i];\n    }\n    return sum;\n  };\n  vector <int> grab;\n  for (int i = 0; i < n; i++) grab.push_back(0);\n  cout.precision(20);\n  auto solve = [&] ()\n  {\n    auto ret = simplex(mat);\n    sort(e.begin(), e.end());\n    vector <int> me(n);\n    int x = -1;\n    for (int i = 1; i <= n; i++)\n    {\n      if (grab[i - 1]) continue;\n      grab[x - 1] = true;\n      if (!good(grab))\n      {\n        grab[x - 1] = false;\n        continue;\n      }\n      if (x == -1 || ret[i] > ret[x])\n      {\n        x = i;\n      }\n    }\n    if (x == -1 || ret[x] < EPS) return 0ll;\n    x--;\n    me[x] = true;\n    grab[x] = true;\n    if (!good(grab)) grab[x] = false, me[x] = false;\n    int kekos = 0;\n    for (auto &c : mat)\n    {\n      kekos++;\n      if (kekos > n + 1)\n      for (int i = 1; i <= n; i++)\n      {\n        if (me[i - 1] && c[i] > EPS) c[i]--, c[0]--;\n      }\n    }\n    for (int i = 1; i <= n; i++)\n    {\n      if (me[i - 1])\n      {\n        mat[i][0] = 0;\n      }\n    }\n    return ok[x];\n  };\n  ll ans = 0;\n  while (ll t = solve())\n  {\n    ans += t;\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\n\ntemplate<typename T>\nstruct PrimalDual{\n  struct edge{\n    Int to;\n    T cap,cost;\n    Int rev;\n    edge(){}\n    edge(Int to,T cap,T cost,Int rev):to(to),cap(cap),cost(cost),rev(rev){}\n  };\n  \n  T INF;\n  vector<vector<edge> > G;\n  vector<T> h,dist;\n  vector<Int> prevv,preve;\n\n  PrimalDual(){}\n  PrimalDual(Int n,T INF):INF(INF),G(n),h(n),dist(n),prevv(n),preve(n){}\n  \n  void add_edge(Int from,Int to,T cap,T cost){\n    G[from].emplace_back(to,cap,cost,G[to].size());\n    G[to].emplace_back(from,0,-cost,G[from].size()-1);\n  }\n\n  T flow(Int s,Int t,T f,Int &ok){    \n    T res=0;\n    fill(h.begin(),h.end(),0);\n    while(f>0){\n      using P = pair<T, Int>;\n      priority_queue<P,vector<P>,greater<P> > que;\n      fill(dist.begin(),dist.end(),INF);\n      \n      dist[s]=0;\n      que.emplace(dist[s],s);\n      while(!que.empty()){\n        P p=que.top();que.pop();\n        Int v=p.second;\n        if(dist[v]<p.first) continue;\n        for(Int i=0;i<(Int)G[v].size();i++){\n          edge &e=G[v][i];\n          if(e.cap==0) continue;\n          if(dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n            dist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n            prevv[e.to]=v;\n            preve[e.to]=i;\n            que.emplace(dist[e.to],e.to);\n          }\n        }\n      }\n      if(dist[t]==INF) return ok=0;\n      \n      for(Int v=0;v<(Int)h.size();v++) h[v]+=dist[v];\n\n      T d=f;\n      for(Int v=t;v!=s;v=prevv[v])\n        d=min(d,G[prevv[v]][preve[v]].cap);\n      \n      f-=d;\n      res+=d*h[t];\n      for(Int v=t;v!=s;v=prevv[v]){\n        edge &e=G[prevv[v]][preve[v]];\n        e.cap-=d;\n        G[v][e.rev].cap+=d;\n      }\n    }\n    ok=1;\n    return res;\n  }\n};\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<Int> xs(n),ys(n),vs(n);\n  for(Int i=0;i<n;i++) cin>>xs[i]>>ys[i]>>vs[i];\n\n  Int m;\n  cin>>m;\n  vector<char> ts(m);\n  vector<Int> as(m),bs(m);\n  for(Int i=0;i<m;i++) cin>>ts[i]>>as[i]>>bs[i];\n\n  const Int INF = 1e16;\n  vector<Int> ls(n,-INF),rs(n,INF),ds(n,-INF),us(n,INF);\n  for(Int i=0;i<m;i++){\n    if(ts[i]=='L') chmax(ls[bs[i]],as[i]);\n    if(ts[i]=='R') chmin(rs[bs[i]],as[i]);\n    if(ts[i]=='D') chmax(ds[bs[i]],as[i]);\n    if(ts[i]=='U') chmin(us[bs[i]],as[i]);\n  }\n  for(Int i=0;i+1<n;i++){\n    chmax(ls[i+1],ls[i]);\n    chmin(rs[i+1],rs[i]);\n    chmax(ds[i+1],ds[i]);\n    chmin(us[i+1],us[i]);\n  }\n  \n  Int ans=0;\n  for(Int k=1;k<=n;k++){\n    PrimalDual<Int> G(k*2+n*2+2,INF);\n    Int S=k*2+n*2,T=k*2+n*2+1;\n    for(Int i=0;i<k;i++){\n      G.add_edge(S,i,1,0);\n      G.add_edge(k+i,T,1,0);\n    }    \n    \n    for(Int p=0;p<n;p++){\n      G.add_edge(k*2+p,k*2+n+p,1,INF-vs[p]);      \n      for(Int i=0;i<k;i++){\n        if(xs[p]<=ls[i]) continue;\n        if(xs[p]>=rs[k-(i+1)]) continue;      \n        G.add_edge(i,k*2+p,1,0);     \n      }           \n      for(Int j=0;j<k;j++){\n        if(ys[p]<=ds[j]) continue;\n        if(ys[p]>=us[k-(j+1)]) continue;    \n        G.add_edge(k*2+n+p,k+j,1,0);\n      }   \n    }\n    \n    Int ok=1;\n    Int res=G.flow(S,T,k,ok);    \n    if(!ok) break;\n    chmax(ans,INF*k-res);\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace __gnu_pbds;\nusing namespace std;\n \ntemplate <typename T>\nusing ordered_set =\n\ttree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n \n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n\t*this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n \n#define shandom_ruffle random_shuffle\n \nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=327;\nusing bn=bitset<87>;\n\nint n;\npii gdz[nax];\nll war[nax];\n\nint m;\nbn podz[nax];\nint ile[nax];\n\nll wyn;\n\nbn ter;\n\nll dajwar()\n{\n\tll ret=0;\n\tfor (int i=1; i<=n; i++)\n\t\tif (ter[i])\n\t\t\tret+=war[i];\n\treturn ret;\n}\n\nint popr()\n{\n\tfor (int i=1; i<=m; i++)\n\t\tif ((podz[i]&ter).count()>ile[i])\n\t\t\treturn 0;\n\treturn 1;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(\"%d%d%lld\", &gdz[i].first, &gdz[i].second, &war[i]);\n\tscanf(\"%d\", &m);\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\tchar c;\n\t\tint a, b;\n\t\tscanf(\" %c%d%d\", &c, &a, &b);\n\t\tfor (int j=1; j<=n; j++)\n\t\t{\n\t\t\tif (c=='L' && gdz[j].first<=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='R' && gdz[j].first>=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='D' && gdz[j].second<=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='U' && gdz[j].second>=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t}\n\t\tile[i]=b;\n\t}\n\tll sta=0;\n\tconst int czes=5e5;\n\tconst int res=7e4;\n\tfor (int h=0; h%czes || (clock()<=4.5*CLOCKS_PER_SEC); h++)\n\t{\n\t\tif (!(rand()%res))\n\t\t{\n\t\t\tfor (int i=1; i<30; i++)\n\t\t\t\tter.flip(rand()%n+1);\n\t\t\tsta=dajwar();\n\t\t\twyn=max(wyn, sta);\n\t\t}\n\t\tbn pam=ter;\n\t\tint r=rand()%3+1;\n\t\tfor (int i=0; i<r; i++)\n\t\t\tter.flip(rand()%n+1);\n\t\tif (!popr())\n\t\t{\n\t\t\tter=pam;\n\t\t\tcontinue;\n\t\t}\n\t\tll now=dajwar();\n\t\tif (now>=sta || !(rand()%500))\n\t\t{\n\t\t\tsta=now;\n\t\t\twyn=max(wyn, now);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tter=pam;\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\\n\", wyn);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <list>\n#include <time.h>\n#include <math.h>\n#include <random>\n#include <deque>\n#include <queue>\n#include <cassert>\n#include <unordered_map>\n#include <unordered_set>\n#include <iomanip>\n#include <bitset>\n#include <sstream>\n#include <chrono>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef __float128 dbl;\nconst int INF = 1.01e9;\n\n__float128 abs(__float128 x)\n{\n  if (x < 0) return -x;\n  return x;\n}\n \nconst __float128 EPS = 1e-25;\nbool eq(__float128 x, __float128 y) {\n    return fabs(x - y) < EPS;\n}\nbool ls(__float128 x, __float128 y) {\n    return x < y && !eq(x, y);\n}\n \nvector<__float128> simplex(vector<vector<__float128> > a) {\n    int n = a.size() - 1;\n    int m = a[0].size() - 1;\n    vector<int> left(n + 1), up(m + 1);\n    iota(up.begin(), up.end(), 0);\n    iota(left.begin(), left.end(), m);\n    auto pivot = [&](int x, int y) {\n        swap(left[x], up[y]);\n        __float128 k = a[x][y];\n        a[x][y] = 1;\n        vector<int> vct;\n        for (int j = 0; j <= m; j++) {\n            a[x][j] /= k;\n            if (!eq(a[x][j], 0)) vct.push_back(j);\n        }\n        for (int i = 0; i <= n; i++) {\n            if (eq(a[i][y], 0) || i == x) continue;\n            k = a[i][y];\n            a[i][y] = 0;\n            for (int j : vct) a[i][j] -= k * a[x][j];\n        }\n    };\n    while (1) {\n        int x = -1;\n        for (int i = 1; i <= n; i++) if (ls(a[i][0], 0) && (x == -1 || a[i][0] < a[x][0])) x = i;\n        if (x == -1) break;\n        int y = -1;\n        for (int j = 1; j <= m; j++) if (ls(a[x][j], 0) && (y == -1 || a[x][j] < a[x][y])) y = j;\n        if (y == -1) assert(0); // infeasible\n        pivot(x, y);\n    }\n    while (1) {\n        int y = -1;\n        for (int j = 1; j <= m; j++) if (ls(0, a[0][j]) && (y == -1 || a[0][j] > a[0][y])) y = j;\n        if (y == -1) break;\n        int x = -1;\n        for (int i = 1; i <= n; i++) if (ls(0, a[i][y]) && (x == -1 || a[i][0] / a[i][y] < a[x][0] / a[x][y])) x = i;\n        if (x == -1) assert(0); // unbounded\n        pivot(x, y);\n    }\n    vector<__float128> ans(m + 1);\n    for (int i = 1; i <= n; i++) if (left[i] <= m) ans[left[i]] = a[i][0];\n    ans[0] = -a[0][0];\n    return ans;\n}\n\n#ifdef ONPC\n  mt19937 rnd(228);\n#else\n  mt19937 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\n#endif\n\nint main()\n{\n#ifdef ONPC\n  freopen(\"a.in\", \"r\", stdin);\n#endif\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector <int> x(n), y(n);\n  vector <ll> ok;\n  vector <__float128> v;\n  vector <pair <ll, int> > e;\n  for (int i = 0; i < n; i++)\n  {\n    cin >> x[i] >> y[i];\n    ll x;\n    cin >> x;\n    ok.push_back(x);\n    v.push_back(x);\n    e.push_back({x, i});\n  }\n  v.insert(v.begin(), 0);\n  int m;\n  cin >> m;\n  vector <vector <__float128> > mat;\n  mat.push_back(v);\n  for (int i = 0; i < n; i++)\n  {\n    vector <__float128> kek(n + 1);\n    kek[0] = kek[i + 1] = 1;\n    mat.push_back(kek);\n  }\n  vector <vector <int> > simp;\n  for (int i = 0; i < m; i++)\n  {\n    char c;\n    cin >> c;\n    int a;\n    int b;\n    cin >> a >> b;\n    vector <__float128> arr = {(__float128) b};\n    vector <int> kek = {b};\n    for (int j = 0; j < n; j++)\n    {\n      int grab = 0;\n      if (c == 'L' && x[j] <= a) grab = 1;\n      if (c == 'R' && x[j] >= a) grab = 1;\n      if (c == 'D' && y[j] <= a) grab = 1;\n      if (c == 'U' && y[j] >= a) grab = 1;\n      arr.push_back(grab);\n      kek.push_back(grab);\n    }\n    mat.push_back(arr);\n    simp.push_back(kek);\n  }\n  auto good = [&] (vector <int> grab)\n  {\n    for (auto c : simp)\n    {\n      int sum = 0;\n      for (int i = 1; i <= n; i++) sum += grab[i - 1] * c[i];\n      if (sum > c[0])\n      {\n        return false;\n      }\n    }\n    return true;\n  };\n  auto f = [&] (vector <int> grab)\n  {\n    ll sum = 0;\n    for (int i = 0; i < n; i++)\n    {\n      if (grab[i]) sum += ok[i];\n    }\n    return sum;\n  };\n  vector <int> grab;\n  for (int i = 0; i < n; i++) grab.push_back(0);\n  cout.precision(20);\n  auto solve = [&] ()\n  {\n    auto ret = simplex(mat);\n    sort(e.begin(), e.end());\n    vector <int> me(n);\n    int x = -1;\n    for (int i = 1; i <= n; i++)\n    {\n      if (grab[i - 1]) continue;\n      grab[x - 1] = true;\n      if (!good(grab))\n      {\n        grab[x - 1] = false;\n        continue;\n      }\n      if (x == -1 || ret[i] > ret[x])\n      {\n        x = i;\n      }\n    }\n    if (x == -1 || ret[x] < EPS) return 0ll;\n    x--;\n    me[x] = true;\n    grab[x] = true;\n    if (!good(grab)) grab[x] = false, me[x] = false;\n    int kekos = 0;\n    for (auto &c : mat)\n    {\n      kekos++;\n      if (kekos > n + 1)\n      for (int i = 1; i <= n; i++)\n      {\n        if (me[i - 1] && c[i] > EPS) c[i]--, c[0]--;\n      }\n    }\n    for (int i = 1; i <= n; i++)\n    {\n      if (me[i - 1])\n      {\n        mat[i][0] = 0;\n      }\n    }\n    return ok[x];\n  };\n  ll ans = 0;\n  while (ll t = solve())\n  {\n    ans += t;\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n#define pa pair<int,int>\nconst int inf=2147483647;\nLL read()\n{\n\tLL x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+(ch^48),ch=getchar();\n\treturn x*f;\n}\nint n,m,st,ed;\nstruct P{int x,y;LL v;}p[85];\nstruct Q{int o,a,b;}q[325];\nchar op[3];\nstruct Edge{int x,y,d,next;LL c;}e[100010];\nint last[450],len;\nvoid ins(int x,int y,int d,LL c)\n{\n\tint t=++len;\n\te[t].x=x;e[t].y=y;e[t].d=d;e[t].c=c;\n\te[t].next=last[x];last[x]=t;\n}\nvoid addedge(int x,int y,int d,LL c){/*printf(\"%d %d %d %lld\\n\",x,y,d,c);*/ins(x,y,d,c),ins(y,x,0,-c);}\nLL f[450];int pre[450];bool in[450];\nbool spfa()\n{\n\tmemset(f,-63,sizeof(f));f[st]=0;\n\tmemset(in,false,sizeof(in));\n\tqueue<int>q;q.push(st);\n//\tprintf(\"st %d\\n\",st);\n\twhile(!q.empty())\n\t{\n\t\tint x=q.front();q.pop();in[x]=false;\n//\t\tprintf(\"x=%d\\n\",x);\n\t\tfor(int i=last[x];i;i=e[i].next)\n\t\t{\n\t\t\tint y=e[i].y;\n\t\t\tif(e[i].d>0&&f[x]+e[i].c>f[y])\n\t\t\t{\n\t\t\t\tpre[y]=i;\n\t\t\t\tf[y]=f[x]+e[i].c;\n\t\t\t\tif(!in[y])in[y]=true,q.push(y);\n\t\t\t}\n\t\t}\n\t}\n\tif(f[ed]>0)return true;\n\treturn false;\n}\nLL Ans,ans=0;\nvoid work()\n{\n\tint x=ed;\n\twhile(x!=st)\n\t{\n\t\tAns+=e[pre[x]].c;\n\t\te[pre[x]].d--,e[pre[x]^1].d++;\n\t\tx=e[pre[x]].x;\n\t}\n}\nint lx[85],rx[85],ly[85],ry[85];\nvoid solve(int k)\n{\n\tmemset(last,0,sizeof(last));len=1;\n\tfor(int i=1;i<=n;i++)\n\taddedge(p[i].x,200+i,1,p[i].v),addedge(200+i,100+p[i].y,1,0);\n\tfor(int i=1;i<=k;i++)lx[i]=ly[i]=1,rx[i]=ry[i]=100;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tif(q[i].o==0)lx[q[i].b+1]=max(lx[q[i].b+1],q[i].a+1);\n\t\tif(q[i].o==1&&k>q[i].b)rx[k-q[i].b]=min(rx[k-q[i].b],q[i].a-1);\n\t\tif(q[i].o==2)ly[q[i].b+1]=max(ly[q[i].b+1],q[i].a+1);\n\t\tif(q[i].o==3&&k>q[i].b)ry[k-q[i].b]=min(ry[k-q[i].b],q[i].a-1);\n\t}\n\tfor(int i=2;i<=k;i++)lx[i]=max(lx[i],lx[i-1]),ly[i]=max(ly[i],ly[i-1]);\n\tfor(int i=k-1;i;i--)rx[i]=min(rx[i],rx[i+1]),ry[i]=min(ry[i],ry[i+1]);\n//\tprintf(\"%d %d %d %d\\n\",lx[1],rx[1],ly[1],ry[1]);\n\tst=200+n+2*k+1,ed=st+1;\n//\tprintf(\"st=%d ed=%d\\n\",st,ed);\n\tfor(int i=1;i<=k;i++)\n\t{\n\t\tif(lx[i]>rx[i]||ly[i]>ry[i])return;\n//\t\tprintf(\"%d %d %d %d\\n\",lx[i],rx[i],ly[i],ry[i]);\n\t\taddedge(st,200+n+i,1,0),addedge(200+n+k+i,ed,1,0);\n\t\tfor(int j=lx[i];j<=rx[i];j++)addedge(200+n+i,j,1,0);\n\t\tfor(int j=ly[i];j<=ry[i];j++)addedge(100+j,200+n+k+i,1,0);\n//\t\tprintf(\"st=%d\\n\",st);\n\t}\n\tint u=0;Ans=0;\n\twhile(spfa())u++,work();\n//\tprintf(\"u=%d\\n\",u);\n\tif(u!=k)return;\n//\tputs(\"ok\");\n\tans=max(ans,Ans);\n}\nint main()\n{\n\tn=read();\n\tfor(int i=1;i<=n;i++)p[i].x=read(),p[i].y=read(),p[i].v=read();\n\tm=read();\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%s\",op);\n\t\tq[i].a=read(),q[i].b=read();\n\t\tif(op[0]=='L')q[i].o=0;\n\t\tif(op[0]=='R')q[i].o=1;\n\t\tif(op[0]=='D')q[i].o=2;\n\t\tif(op[0]=='U')q[i].o=3;\n\t}\n//\tsolve(4);\n\tfor(int i=1;i<=n;i++)solve(i);\n\tprintf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=505,M=2005,R=100;\nconst ll inf=0x3f3f3f3f3f3f3f3fll;\nint read(){\n\tint f=1,g=0;\n\tchar ch=getchar();\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-') f=-1;\n\tfor (;isdigit(ch);ch=getchar()) g=g*10+ch-'0';\n\treturn f*g;\n}\nvoid chkmax(int &x,int y){if (x<y) x=y;}\nvoid chkmin(int &x,int y){if (x>y) x=y;}\nint n,m;\nstruct jew{int x,y;ll w;}a[N];\nstruct node{char typ;int x,r;}b[N];\nll cost,ans;\nint S,T,cnt,fir[N],fr[N],siz;\nstruct edge{int u,v;ll w;int fl,nex;}e[M];\nvoid add(int u,int v,ll w,int fl){\n\te[++siz]=(edge){u,v,w,fl,fir[u]};fir[u]=siz;\n\te[++siz]=(edge){v,u,-w,0,fir[v]};fir[v]=siz;\n}\nll dist[N];int que[N*50];bool inq[N];\nvoid dec(int x,int fl){e[x].fl-=fl;e[x^1].fl+=fl;}\nbool spfa(){\n\tmemset(dist,-1,8*(cnt+1));\n\tmemset(inq,0,cnt+1);\n\tint l=1,r=1;que[l]=S;dist[S]=0;inq[S]=1;\n\twhile (l<=r){\n\t\tint x=que[l];\n\t\tfor (int i=fir[x];i;i=e[i].nex)\n\t\tif ((e[i].fl)&&(dist[e[i].v]<dist[x]+e[i].w)){\n\t\t\tif (!inq[e[i].v]) {que[++r]=e[i].v;inq[e[i].v]=1;}\n\t\t\tdist[e[i].v]=dist[x]+e[i].w;fr[e[i].v]=i;\n\t\t}\n\t\tinq[x]=0;l++;\n\t}\n\treturn dist[T]>0;\n}\nint update(){\n\tint t=0x3f3f3f3f;\n\tfor (int i=fr[T];i;i=fr[e[i].u]) t=min(t,e[i].fl);\n\tcost+=t*dist[T];\n\tfor (int i=fr[T];i;i=fr[e[i].u]) dec(i,t);\n\treturn t;\n}\nint dinic(){\n\tint flow=0;\n\twhile (spfa()) flow+=update();\n\treturn flow;\n}\nint ml[N],mr[N],mu[N],md[N];\nvoid calc(int L){\n\tmemset(fir,0,sizeof(fir));siz=1;\n\tS=0;T=cnt=L*2+R*2+1;\n\tfor (int i=1;i<=n;i++) add(a[i].x,a[i].y+R,a[i].w,1);\n\tfor (int i=1;i<=L;i++) {ml[i]=mu[i]=1,mr[i]=md[i]=R;add(S,R*2+i,0,1);add(R*2+L+i,T,0,1);}\n\tfor (int i=1;i<=m;i++)\n\tif (b[i].r>=L) continue;\n\telse if (b[i].typ=='L') chkmax(ml[b[i].r+1],b[i].x+1);\n\telse if (b[i].typ=='R') chkmin(mr[L-b[i].r],b[i].x-1);\n\telse if (b[i].typ=='D') chkmax(mu[b[i].r+1],b[i].x+1);\n\telse if (b[i].typ=='U') chkmin(md[L-b[i].r],b[i].x-1);\n\tfor (int i=2;i<=L;i++) chkmax(ml[i],ml[i-1]),chkmax(mu[i],mu[i-1]);\n\tfor (int i=L-1;i;i--)  chkmin(md[i],md[i+1]),chkmin(md[i],md[i+1]);\n\tfor (int i=1;i<=L;i++){\n\t\tfor (int j=ml[i];j<=mr[i];j++) add(R*2+i,j,0,1);\n\t\tfor (int j=mu[i];j<=md[i];j++) add(j+R,R*2+L+i,0,1);\n\t}\n\tcost=0;\n\tif (dinic()==L) ans=max(ans,cost);\n//\tfor (int i=1;i<=n;i++) if (!e[i*2].fl) printf(\"%d \",i);\n//\tprintf(\"\\n\");\n}\nint main(){\n//\tfreopen(\"a.in\",\"r\",stdin);\n//\tfreopen(\"a.out\",\"w\",stdout);\n\tn=read();\n\tfor (int i=1;i<=n;i++) scanf(\" %d %d %lld\",&a[i].x,&a[i].y,&a[i].w);\n\tm=read();\n\tfor (int i=1;i<=m;i++) scanf(\" %c %d %d\",&b[i].typ,&b[i].x,&b[i].r);\n\tfor (int i=1;i<=n;i++) calc(i);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nostream &operator<<(ostream &os, __float128 f) { return os << (LD)f; }\n\n\nstruct Simplex {        // Maximize c*x subject to Ax <= b.\n  using T = LD;         // Initialize the structure, set A, b, c and then run\n  vector<vector<T>> A;  // solve(). Max objective is stored in res. To recover\n  vector<T> b, c;       // the best result, use getVars().\n  T abs(T x) { return x < 0 ? -x : x; }\n\n  int V, E;\n  VI eqIds, varIds, cols;\n  T res;\n  const LD kEps = 1e-9;\n\n  Simplex(int vars, int eqs) : A(eqs, vector<T>(vars)), b(eqs), c(vars),\n                               V(vars), E(eqs), eqIds(eqs), varIds(vars), res(0) {\n    iota(ALL(varIds), 0); iota(ALL(eqIds), vars);\n  }\n\n  void pivot(int eq, int var) {\n    T coef = 1 / A[eq][var];\n    cols.clear();\n    REP (i, V) {\n      if (abs(A[eq][i]) > kEps) { cols.PB(i); A[eq][i] *= coef; }\n    }\n    A[eq][var] *= coef; b[eq] *= coef;\n    REP (row, E) {\n      if (row == eq || abs(A[row][var]) < kEps) { continue; }\n      T k = -A[row][var];\n      A[row][var] = 0;\n      for (int i : cols) { A[row][i] += k * A[eq][i]; }\n      b[row] += k * b[eq];\n    }\n    T q = c[var]; c[var] = 0;\n    for (int i : cols) { c[i] -= q * A[eq][i]; }\n    res += q * b[eq];\n\n    swap(varIds[var], eqIds[eq]);\n  }\n  \n  bool solve() {\n    while (true) {\n      int eq = -1, var = -1;\n      REP (i, E) { if (b[i] < -kEps) { eq = i; break; } }\n      if (eq == -1) { break; }\n      REP (i, V) { if (A[eq][i] < -kEps) { var = i; break; } }\n      if (var == -1) { res = -1e9; return false; /* No solution */ }\n      pivot(eq, var);\n    }\n\n    while (true) {\n      int var = -1, eq = -1;\n      REP (i, V) { if (c[i] > kEps) { var = i; break; } }\n      if (var == -1) { break; }\n      REP (i, E) {\n        if (A[i][var] < kEps) { continue; }\n        if (eq >= 0 && b[i] / A[i][var] >= b[eq] / A[eq][var]) { continue; }\n        eq = i;\n      }\n      if (eq == -1) { res = 1e9; return false; /* Unbounded */ }\n      pivot(eq, var);\n    }\n\n    return true;\n  }\n  \n  vector<T> getVars() {  // Optimal assignment of variables.\n    vector<T> result(V);\n    REP (i, E) { if (eqIds[i] < V) { result[eqIds[i]] = b[i]; } }\n    return result;\n  }\n};\n\nint N, M;\nvector<PII> points;\nVI point_vals;\n\nLL low_bound;\nclock_t time_start;\n\nvoid Solve(Simplex sim) {\n  Simplex sim_copy = sim;\n  assert(sim.solve());\n\n  if (sim.res - 1e-9 < low_bound) { return; }\n  auto vars = sim.getVars();\n\n  if ((clock() - time_start) > 4.9 * CLOCKS_PER_SEC) {\n    cout << low_bound << \"\\n\";\n    exit(0);\n  }\n\n  LL my_low = 0;\n  for (int i = 0; i < N; ++i) {\n    if (vars[i] > .99) {\n      my_low += point_vals[i];\n      //sim_copy.b[M + i * 2] = -1;\n    }\n  }\n\n  maxi(low_bound, my_low);\n  bool had_any = false;\n  for (int i = 0; i < N; ++i) {\n    if (vars[i] > .01 && vars[i] < .989) {\n      had_any = true;\n    }\n  }\n\n  if (had_any) {\n    // take none?\n    for (int i = 0; i < N; ++i) {\n      if (vars[i] > .01 && vars[i] < .989) {\n        sim_copy.b[M + i * 2 + 1] = 0;\n      }\n    }\n    Solve(sim_copy);\n    for (int i = 0; i < N; ++i) {\n      if (vars[i] > .01 && vars[i] < .989) {\n        sim_copy.b[M + i * 2 + 1] = 1;\n      }\n    }\n  }\n\n  for (int i = 0; i < N; ++i) {\n    if (vars[i] > .01 && vars[i] < .989) {\n      // take?\n      sim_copy.b[M + i * 2] = -1;\n      Solve(sim_copy);\n      sim_copy.b[M + i * 2] = 0;\n      sim_copy.b[M + i * 2 + 1] = 0;\n      if (sim.res - 1e-9 < low_bound) { return; }\n    }\n  }\n\n}\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n  time_start = clock();\n\n  cin >> N;\n  points.resize(N);\n  point_vals.resize(N);\n\n  for (int i = 0; i < N; ++i) {\n    cin >> points[i].st >> points[i].nd >> point_vals[i];\n  }\n\n  map<char, function<bool(PII, int)>> checkers = {\n    {'L', [](const PII &pt, int a) { return pt.st <= a; }},\n    {'R', [](const PII &pt, int a) { return pt.st >= a; }},\n    {'D', [](const PII &pt, int a) { return pt.nd <= a; }},\n    {'U', [](const PII &pt, int a) { return pt.nd >= a; }}\n  };\n\n  cin >> M;\n\n  Simplex sim(N, M + 2 * N);\n  for (int i = 0; i < M; ++i) {\n    char type;\n    int a, b;\n    cin >> type >> a >> b;\n\n    for (int j = 0; j < N; ++j) {\n      sim.A[i][j] = checkers[type](points[j], a);\n    }\n    sim.b[i] = b;\n\n    debug(sim.A[i], sim.b[i]);\n  }\n  for (int i = 0; i < N; ++i) {\n    sim.c[i] = point_vals[i];\n    sim.A[M + i * 2][i] = -1;\n    sim.A[M + i * 2 + 1][i] = 1;\n    sim.b[M + i * 2] = 0;\n    sim.b[M + i * 2 + 1] = 1;\n  }\n  auto orig_a = sim.A;\n  auto orig_b = sim.b;\n\n  Solve(sim);\n  cout << low_bound << \"\\n\";\n\n  /*assert(sim.solve());\n  auto vars = sim.getVars();\n\n  vector<int> always, maybe;\n  debug(vars);\n  for (int i = 0; i < N; ++i) {\n    if (vars[i] > 0.7) {\n      always.PB(i);\n    } else if (vars[i] > 0.3) {\n      maybe.PB(i);\n    }\n  }\n\n  debug(always, maybe);\n\n  assert(SZ(maybe) <= 3);\n  LL ans = -1;\n\n  for (LL m = 0; m < (1LL << SZ(maybe)); ++m) {\n    vector<int> mine = always;\n    for (int j = 0; j < SZ(maybe); ++j) {\n      if ((m >> j) & 1) { mine.PB(maybe[j]); }\n    }\n\n    bool fail = false;\n    for (int i = 0; i < M; ++i) {\n      int cnt = 0;\n      for (int j : mine) {\n        if (orig_a[i][j] > 0.5) { ++cnt; }\n      }\n      debug(mine, i, cnt, orig_b[i]);\n      if (cnt > (int)round((LD)orig_b[i])) { debug(i); fail = true; }\n    }\n\n    if (fail) { continue; }\n    LL x = 0;\n    for (int i : mine) {\n      x += point_vals[i];\n    }\n    maxi(ans, x);\n  }\n\n  cout << ans << \"\\n\";*/\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fo(i,a,b)for(int i=a,_e=b;i<=_e;++i)\n#define fd(i,a,b)for(int i=b,_e=a;i>=_e;i--)\n#define ll long long\n#define db double\nusing namespace std;\nconst int N=500,mo=1e9+7;\nconst db eps=1e-9;\nint n,x[100],y[100];\nll v[100];\nint m,A,b;\ndb ans,a[N][N];\nchar c;\ninline void simplex(int x,int y,int n,int m)\n{\n\tfor (int i = 0 ; i <= m ; ++i) if (i != x) a[y][i] /= a[y][x];\n\ta[y][x] = 1.0 / a[y][x];\n\tfor (int i = 1 ; i <= n ; ++i)\n\t{\n\t\tif (i == y || abs(a[i][x]) <= eps) continue;\n\t\tfor (int j = 0 ; j <= m ; ++j)\n\t\tif (j != x) a[i][j] -= a[y][j] * a[i][x];\n\t\ta[i][x] = -a[i][x] * a[y][x];\n\t} ans += a[0][x] * a[y][0];\n\tfor (int i = 1 ; i <= m ; ++i)\n\tif (i != x) a[0][i] -= a[y][i] * a[0][x];\n\ta[0][x] = -a[0][x] * a[y][x];\n}\ninline void solve(int n,int m)\n{\n\twhile (1)\n\t{\n\t\tint fir = 0;\n\t\tfor (int i = 1 ; i <= m ; ++i)\n\t\tif (a[0][i] > eps) { fir = i; break; }\n\t\tif (!fir) return;\n\t\tint sec = 0; db mi = 1e18;\n\t\tfor (int i = 1 ; i <= n ; ++i)\n\t\tif (a[i][fir] > eps && mi > (a[i][0] / a[i][fir])){\n\t\t\tsec = i,mi = a[i][0] / a[i][fir];\n\t\t}\n\t\tsimplex(fir,sec,n,m);\n\t}\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfo(i,1,n)scanf(\"%d%d%d\",&x[i],&y[i],&v[i]),a[0][i]=v[i];\n\tscanf(\"%d\\n\",&m);\n\tfo(i,1,m){\n\t\tc=getchar();\n\t\tscanf(\"%d%d\\n\",&A,&b);\n\t\tfo(j,1,n){\n\t\t\tif(c=='L'&&x[j]<=A)a[i][j]=1;\n\t\t\tif(c=='R'&&x[j]>=A)a[i][j]=1;\n\t\t\tif(c=='D'&&y[j]<=A)a[i][j]=1;\n\t\t\tif(c=='U'&&y[j]>=A)a[i][j]=1;\n\t\t}\n\t\ta[i][0]=b;\n\t}\n\tfo(i,m+1,m+n)a[i][0]=1,a[i][i-m]=1;\n\tsolve(m+n,n);\n\tprintf(\"%lld\\n\",(ll)ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 100 , M = 400 , V = N + M << 1 , E = N + N * M * 2 + M * 2 , INF = 0x3f3f3f3f;\nint n,m,x[N],y[N],a[N],b[N],u[N],d[N],l[N],r[N]; char op[N];\nint t(1),Head[V],vis[V],S,T; deque <int> q; ll Delta,dis[V],v[N],Ans;\nstruct Edge { int u,v,next,val; ll cos; } e[E*4];\ntemplate<class T> inline T Read(void)\n{\n    T x = 0; bool w = 0; char ch = ' ';\n    while ( !isdigit(ch) ) w |= ch == '-' , ch = getchar();\n    while ( isdigit(ch) ) x = x * 10 + ch - 48 , ch = getchar();\n    return w ? -x : x;\n}\ninline void Input(void)\n{\n    n = Read<int>();\n    for (int i = 1; i <= n; i++)\n        x[i] = Read<int>() , y[i] = Read<int>() , v[i] = Read<ll>();\n    m = Read<int>();\n    for (int i = 1; i <= m; i++)\n    {\n        char c = ' ';\n        while ( isspace(c) ) c = getchar();\n        op[i] = c , a[i] = Read<int>() , b[i] = Read<int>();\n    }\n}\ninline void Insert(int x,int y,ll c,int v)\n{\n    e[++t] = (Edge){ x , y , Head[x] , v , c } , Head[x] = t;\n    e[++t] = (Edge){ y , x , Head[y] , 0 , -c } , Head[y] = t;\n}\ninline void Build(int k)\n{\n    for (int i = 1; i <= k; i++)\n        u[i] = r[i] = INF , l[i] = d[i] = 0;\n    for (int i = 1; i <= m; i++)\n        if ( b[i] < k )\n        {\n            // if ( op[i] == 'L' ) l[b[i]+1] = max( l[b[i]+1] , a[i] + 1 );\n            // if ( op[i] == 'R' ) r[k-b[i]] = min( r[k-b[i]] , a[i] - 1 );\n            // if ( op[i] == 'D' ) d[b[i]+1] = max( d[b[i]+1] , a[i] + 1 );\n            // if ( op[i] == 'U' ) u[k-b[i]] = min( u[k-b[i]] , a[i] - 1 );\n            if ( op[i] == 'L' ) l[b[i]+1] = a[i] + 1;\n            if ( op[i] == 'R' ) r[k-b[i]] = a[i] - 1;\n            if ( op[i] == 'D' ) d[b[i]+1] = a[i] + 1;\n            if ( op[i] == 'U' ) u[k-b[i]] = a[i] - 1;\n        }\n    for (int i = 2; i <= k; i++) l[i] = max( l[i] , l[i-1] ) , d[i] = max( d[i] , d[i-1] );\n    for (int i = k-1; i >= 1; i--) r[i] = min( r[i] , r[i+1] ) , u[i] = min( u[i] , u[i+1] );\n    memset( Head , 0 , sizeof Head );\n    S = ( n + k ) << 1 | 1 , T = ( n + k + 1 ) * 2 , t = 1 , Delta = 0;\n    for (int i = 1; i <= n; i++) Insert( i , i+n , v[i] , 1 );\n    for (int i = 1; i <= k; i++)\n    {\n        Insert( S , n*2+i , 0 , 1 ) , Insert( n*2+k+i , T , 0 , 1 );\n        for (int j = 1; j <= n; j++)\n        {\n            if ( l[i] <= x[j] && x[j] <= r[i] ) Insert( n*2+i , j , 0 , 1 );\n            if ( d[i] <= y[j] && y[j] <= u[i] ) Insert( j+n , n*2+k+i , 0 , 1 );\n        }\n    }\n    // printf( \"t = %d\\n\" , t );\n}\ninline bool Relabel(void)\n{\n    memset( dis , 0xcf , sizeof dis );\n    memset( vis , 0x00 , sizeof vis );\n    dis[T] = 0 , vis[T] = 1 , q.push_back(T);\n    while ( !q.empty() )\n    {\n        // puts(\"SPFAing\");\n        int x = q.front(); q.pop_front() , vis[x] = 0;\n        if ( q.size() > 1 && dis[q.front()] < dis[q.back()] )\n            swap( q.front() , q.back() );\n        for (int i = Head[x] , y; i; i = e[i].next)\n            if ( e[i^1].val && dis[ y = e[i].v ] < dis[x] + e[i^1].cos )\n            {\n                dis[y] = dis[x] + e[i^1].cos;\n                // printf( \"dis[%d] = %lld\\n\" , y , dis[y] );\n                if ( vis[y] ) continue;\n                vis[y] = true , q.push_back(y);\n                if ( q.size() > 1 && dis[q.front()] < dis[q.back()] )\n                    swap( q.front() , q.back() );\n            }\n    }\n    // printf( \"d[%d] = %lld\\n\" , S , dis[S] );\n    return dis[S] != dis[0];\n}\ninline int Dinic(int x,int flow)\n{\n    if ( x == T || !flow ) return flow;\n    int residue = flow; vis[x] = true;\n    for (int i = Head[x] , y; i; i = e[i].next)\n        if ( e[i].val && !vis[ y = e[i].v ] && !e[i].cos )\n        {\n            int k = Dinic( y , min( e[i].val , residue ) );\n            e[i].val -= k , e[i^1].val += k;\n            if ( ( residue -= k ) == 0 ) break;\n        }\n    return flow - residue;\n}\ninline pair<int,ll> PrimalDual(void)\n{\n    int Maxflow = 0 , Flow = 0; ll Maxcost = 0;\n    while ( Relabel() )\n    {\n        for (int i = 2; i <= t; i++)\n            e[i].cos += dis[e[i].v] - dis[e[i].u];\n        Delta += dis[S] , memset( vis , 0 , sizeof vis );\n        // printf( \"Delta = %lld\\n\" , Delta );\n        while ( Flow = Dinic( S , INF ) )\n            Maxflow += Flow , Maxcost += 1LL * Flow * Delta ,\n            memset( vis , 0 , sizeof vis ) /*, printf( \"Dinicing Flow = %d\\n\" , Flow ) */;\n    }\n    return make_pair( Maxflow , Maxcost );\n}\nint main(void)\n{\n    Input();\n    for (int i = 1; i <= n; i++)\n        Build(i) , Ans = max( Ans , PrimalDual().second );\n    printf( \"%lld\\n\" , Ans );\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef __WIN32\n#define LLFORMAT \"I64\"\n#else\n#define LLFORMAT \"ll\"\n#endif\n\nusing namespace std;\n\nstruct edge {\n\tint to, cap, rev;\n\tlong long cst;\n\n\tedge() {}\n\tedge(int to, int cap, int rev, long long cst): to(to), cap(cap), rev(rev), cst(cst) {}\n};\n\nint main() {\n\tios::sync_with_stdio(false);\n\tint n;\n\tcin >> n;\n\tvector<int> x(n), y(n), ordx(n), ordy(n);\n\tvector<long long> v(n);\n\tfor (int i = 0; i < n; ++i) cin >> x[i] >> y[i] >> v[i], ordx[i] = i, ordy[i] = i;\n\tsort(ordx.begin(), ordx.end(), [&](int a, int b) { return x[a] > x[b]; });\n\tsort(ordy.begin(), ordy.end(), [&](int a, int b) { return y[a] > y[b]; });\n\tint m;\n\tcin >> m;\n\tvector<pair<int, int> > liml, limd;\n\tfor (int i = 0; i < m; ++i) {\n\t\tchar t;\n\t\tint a, b;\n\t\tcin >> t >> a >> b;\n\t\t++b;\n\t\tif(t == 'L') liml.push_back(make_pair(a, b));\n\t\telse if(t == 'R') liml.push_back(make_pair(a - 1, -b));\n\t\telse if(t == 'D') limd.push_back(make_pair(a, b));\n\t\telse limd.push_back(make_pair(a - 1, -b));\n\t}\n\tsort(liml.begin(), liml.end());\n\tsort(limd.begin(), limd.end());\n\treverse(liml.begin(), liml.end());\n\treverse(limd.begin(), limd.end());\n\tlong long ans = 0;\n\tvector<vector<edge> > g(n + m + 5);\n\tvector<long long> dst(n + m + 5);\n\tvector<int> pree(n + m + 5), prev(n + m + 5);\n\tvector<bool> in(n + m + 5);\n\tfor (int chs = 0; chs <= n; ++chs) {\n\t\tfill(g.begin(), g.end(), vector<edge>());\n\t\tint S = g.size() - 1, T = g.size() - 2, SS = g.size() - 3, TT = g.size() - 4, lim = g.size() - 5;\n\t\tint total_low = 0;\n\t\tauto add_edge = [&](int from, int to, int low, int hgh, long long cst) {\n\t\t\tlow = max(low, 0);\n\t\t\ttotal_low += low;\n\t\t\tauto add_edge = [&](int from, int to, int cap, long long cst) {\n\t\t\t\tif(!cap) return;\n\t\t\t\tg[from].push_back(edge(to, cap, g[to].size(), cst));\n\t\t\t\tg[to].push_back(edge(from, 0, g[from].size() - 1, -cst));\n\t\t\t\treturn;\n\t\t\t};\n\t\t\tadd_edge(from, to, hgh - low, cst);\n\t\t\tadd_edge(SS, to, low, 0);\n\t\t\tadd_edge(from, TT, low, 0);\n\t\t\treturn;\n\t\t};\n\t\tadd_edge(S, lim, chs, chs, 0);\n\t\tint j = 0, pre = lim;\n\t\tfor (int i = 0; i < liml.size(); ++i) {\n\t\t\tint u = i, a = liml[i].first, b = liml[i].second;\n\t\t\twhile(j < n) {\n\t\t\t\tint i = ordx[j];\n\t\t\t\tif(x[i] <= a) break;\n\t\t\t\tadd_edge(pre, i + m, 0, 1, -v[i]);\n\t\t\t\t++j;\n\t\t\t}\n\t\t\tif(b > 0) add_edge(pre, u, 0, b - 1, 0);\n\t\t\telse add_edge(pre, u, chs - (-b - 1), n, 0);\n\t\t\tpre = u;\n\t\t}\n\t\twhile(j < n) {\n\t\t\tint i = ordx[j];\n\t\t\tadd_edge(pre, i + m, 0, 1, -v[i]);\n\t\t\t++j;\n\t\t}\n\t\tj = 0, pre = T;\n\t\tfor (int i = 0; i < limd.size(); ++i) {\n\t\t\tint u = m - 1 - i, a = limd[i].first, b = limd[i].second;\n\t\t\twhile(j < n) {\n\t\t\t\tint i = ordy[j];\n\t\t\t\tif(y[i] <= a) break;\n\t\t\t\tadd_edge(i + m, pre, 0, 1, 0);\n\t\t\t\t++j;\n\t\t\t}\n\t\t\tif(b > 0) add_edge(u, pre, 0, b - 1, 0);\n\t\t\telse add_edge(u, pre, chs - (-b - 1), n, 0);\n\t\t\tpre = u;\n\t\t}\n\t\twhile(j < n) {\n\t\t\tint i = ordy[j];\n\t\t\tadd_edge(i + m, pre, 0, 1, 0);\n\t\t\t++j;\n\t\t}\n\t\tstatic const int oo = 1e9;\n\t\tadd_edge(T, S, 0, oo, 0);\n\t\tauto mcmf = [&](int S, int T) {\n\t\t\tauto spfa = [&](int S, int T) {\n\t\t\t\tstatic const long long oo = 1ll << 62;\n\t\t\t\tfill(dst.begin(), dst.end(), oo);\n\t\t\t\tfill(in.begin(), in.end(),false);\n\t\t\t\tqueue<int> q;\n\t\t\t\tq.push(S);\n\t\t\t\tin[S] = true;\n\t\t\t\tdst[S] = 0;\n\t\t\t\twhile(q.size()) {\n\t\t\t\t\tint u = q.front();\n\t\t\t\t\tq.pop();\n\t\t\t\t\tin[u] = false;\n\t\t\t\t\tfor (int i = 0; i < g[u].size(); ++i) if(g[u][i].cap) {\n\t\t\t\t\t\tint v = g[u][i].to;\n\t\t\t\t\t\tlong long w = dst[u] + g[u][i].cst;\n\t\t\t\t\t\tif(dst[v] > w) {\n\t\t\t\t\t\t\tdst[v] = w;\n\t\t\t\t\t\t\tprev[v] = u;\n\t\t\t\t\t\t\tpree[v] = i;\n\t\t\t\t\t\t\tif(!in[v]) in[v] = true, q.push(v);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn dst[T] < oo;\n\t\t\t};\n\t\t\tint flow = 0;\n\t\t\tlong long cost = 0;\n\t\t\twhile(spfa(S, T)) {\n\t\t\t\tint mn = oo;\n\t\t\t\tfor (int u = T; u != S; u = prev[u]) mn = min(mn, g[prev[u]][pree[u]].cap);\n\t\t\t\tflow += mn;\n\t\t\t\tcost += mn * dst[T];\n\t\t\t\tfor (int u = T; u != S; u = prev[u]) {\n\t\t\t\t\tint v = prev[u], i = pree[u];\n\t\t\t\t\tg[v][i].cap -= mn;\n\t\t\t\t\tg[u][g[v][i].rev].cap += mn;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn make_pair(flow, cost);\n\t\t};\n\t\tauto res = mcmf(SS, TT);\n\t\tif(res.first != total_low) continue;\n\t\tans = min(ans, mcmf(S, T).second + res.second);\n\t}\n\tcout << -ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nclass MinCostFlow {\nprivate:\n    const int n;\n    vector<tuple<int, long long, int>> e;\n    vector<vector<int>> g;\n    vector<long long> h, dis;\n    vector<int> pre;\n    bool dijkstra(int s, int t) {\n        dis.assign(n, 1E18);\n        pre.assign(n, -1);\n        priority_queue<pair<long long, int>> que;\n        dis[s] = 0;\n        que.emplace(0, s);\n        while (!que.empty()) {\n            int u;\n            long long d;\n            tie(d, u) = que.top();\n            d = -d;\n            que.pop();\n            if (dis[u] != d)\n                continue;\n            for (int i : g[u]) {\n                int v, c;\n                long long f;\n                tie(v, f, c) = e[i];\n                if (c > 0 && dis[v] > d + h[u] - h[v] + f) {\n                    dis[v] = d + h[u] - h[v] + f;\n                    pre[v] = i;\n                    que.emplace(-dis[v], v);\n                }\n            }\n        }\n        return dis[t] != 1E18;\n    }\npublic:\n    MinCostFlow(int n) : n(n), g(n) {}\n    void addEdge(int u, int v, long long f, int c) {\n        g[u].push_back(e.size());\n        e.emplace_back(v, f, c);\n        g[v].push_back(e.size());\n        e.emplace_back(u, -f, 0);\n    }\n    pair<int, long long> minCostMaxFlow(const int s, const int t) {\n        int flow = 0;\n        long long cost = 0;\n        h.assign(n, 0);\n        while (dijkstra(s, t)) {\n            for (int i = 0; i < n; ++i)\n                h[i] += dis[i];\n            for (int i = t; i != s; i = get<0>(e[pre[i] ^ 1])) {\n                --get<2>(e[pre[i]]);\n                ++get<2>(e[pre[i] ^ 1]);\n            }\n            ++flow;\n            cost += h[t];\n        }\n        return {flow, cost};\n    }\n};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin >> n;\n    vector<int> x(n), y(n);\n    vector<long long> v(n);\n    for (int i = 0; i < n; ++i)\n        cin >> x[i] >> y[i] >> v[i];\n    int m;\n    cin >> m;\n    vector<int> l(n, 1), r(n, 100), d(n, 1), u(n, 100);\n    for (int i = 0; i < m; ++i) {\n        char t;\n        int a, b;\n        cin >> t >> a >> b;\n        if (t == 'L') {\n            l[b] = max(l[b], a + 1);\n        } else if (t == 'R') {\n            r[b] = min(r[b], a - 1);\n        } else if (t == 'D') {\n            d[b] = max(d[b], a + 1);\n        } else {\n            u[b] = min(u[b], a - 1);\n        }\n    }\n    for (int i = 1; i < n; ++i) {\n        l[i] = max(l[i], l[i - 1]);\n        r[i] = min(r[i], r[i - 1]);\n        d[i] = max(d[i], d[i - 1]);\n        u[i] = min(u[i], u[i - 1]);\n    }\n    long long ans = 0;\n    for (int k = 1; k <= n; ++k) {\n        MinCostFlow flow(2 * (n + k + 1));\n        const int s = 2 * (n + k), t = s + 1;\n        for (int i = 0; i < n; ++i)\n            flow.addEdge(i, i + n, 1E15 - v[i], 1);\n        for (int i = 0; i < k; ++i) {\n            flow.addEdge(s, i + 2 * n, 0, 1);\n            flow.addEdge(i + 2 * n + k, t, 0, 1);\n            for (int j = 0; j < n; ++j) {\n                if (l[i] <= x[j] && x[j] <= r[k - i - 1])\n                    flow.addEdge(i + 2 * n, j, 0, 1);\n                if (d[i] <= y[j] && y[j] <= u[k - i - 1])\n                    flow.addEdge(j + n, i + 2 * n + k, 0, 1);\n            }\n        }\n        auto f = flow.minCostMaxFlow(s, t);\n        if (f.first != k)\n            break;\n        ans = max(ans, k * (long long)1E15 - f.second);\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n\n#define FILL(a, n, x) memset((a), (x), sizeof ((a)[0]) * (n))\n#define COPY(a, n, b) memcpy((b), (a), sizeof ((a)[0]) * (n))\n#define FILLA(a, x) memset((a), (x), sizeof (a))\n#define COPYA(a, b) memcpy((b), (a), sizeof (a))\n\nusing namespace std;\n\ntypedef long long li;\ntypedef unsigned long long lu;\nconst li infl = ~0LLU >> 2;\n\ntemplate <class T>\ninline void Min(T &x, T y) {\n  if (y < x) x = y;\n}\ntemplate <class T>\ninline void Max(T &x, T y) {\n  if (y > x) x = y;\n}\n\n// const int mod = 998244353;\nint mod;\ninline int Add(int x) { return x >= mod ? x - mod : x; }\ninline void Add(int &x, int y) { x += y; if (x >= mod) x -= mod; }\ninline int Sub(int x) { return x < 0 ? x + mod : x; }\ninline void Sub(int &x, int y) { x -= y; if (x < 0) x += mod; }\ninline int Mul(int x, int y) { return (int)((li)x * y % mod); }\ninline int Mul(int x, int y, int z) { return Mul(x, Mul(y, z)); }\nint Pow(int x, int y) {\n  int z = 1;\n  for (; y; y >>= 1) {\n    if (y & 1) z = Mul(z, x);\n    x = Mul(x, x);\n  }\n  return z;\n}\nint Inv(int x) {\n  return Pow(x, mod - 2);\n}\n\n// ----------------------------------------\n\nconst int maxn = 80, maxx = 100, maxm = 320;\n\nint n, x[maxn], y[maxn];\nli v[maxn];\n\nint m;\nchar type[maxm];\nint a[maxm], b[maxm];\n\nint min_x[maxx + 1], max_x[maxx + 1], min_y[maxx + 1], max_y[maxx + 1];\n\nnamespace mcf {\n  const int maxn = 204;\n  const int maxm = 1e6;\n  const int inf = ~0U >> 1;\n  const li infl = ~0LLU >> 2;\n\n  int n, m, s, t;\n  vector<int> g[maxn];\n  int enter[maxn];\n  li basic_cost;\n\n  struct Edge {\n    int v, cap;\n    li cost;\n  } edge[maxm];\n\n  void AddSimple(int u, int v, int cap, li cost) {\n    g[u].push_back(m);\n    edge[m++] = {v, cap, cost};\n    g[v].push_back(m);\n    edge[m++] = {u, 0, -cost};\n  }\n\n  void AddEdge(int u, int v, int l, int r, li cost) {\n    basic_cost += cost * l;\n    enter[v] += l;\n    enter[u] -= l;\n    if (l < r) {\n      AddSimple(u, v, r - l, cost);\n    }\n  }\n\n  void Init(int _n) {\n    n = _n + 2;\n    s = _n, t = s + 1;\n    m = 0;\n    for (int i = 0; i < n; ++i) {\n      g[i].clear();\n      enter[i] = 0;\n    }\n    basic_cost = 0;\n  }\n\n  li h[maxn], dist[maxn];\n  int prev[maxn];\n\n  struct Node {\n    int u;\n    li d;\n    bool operator < (const Node &b) const {\n      return d > b.d;\n    }\n  };\n\n  bool Dijkstra(void) {\n    for (int i = 0; i < n; ++i) {\n      dist[i] = infl;\n    }\n    dist[s] = 0;\n    priority_queue<Node> que;\n    que.push({s, 0});\n    while (!que.empty()) {\n      int u = que.top().u;\n      li d = que.top().d;\n      que.pop();\n      if (d != dist[u]) continue;\n      for (int i = 0; i < g[u].size(); ++i) {\n        Edge &e = edge[g[u][i]];\n        if (e.cap == 0) continue;\n        li newd = d + e.cost + h[u] - h[e.v];\n        if (newd < dist[e.v]) {\n          dist[e.v] = newd;\n          que.push({e.v, newd});\n          prev[e.v] = g[u][i];\n        }\n      }\n    }\n    return dist[t] < infl;\n  }\n\n  pair<bool, li> Solve(void) {\n    int should = 0;\n    for (int i = 0; i < n; ++i) {\n      if (enter[i] > 0) {\n        should += enter[i];\n        AddSimple(s, i, enter[i], 0);\n      } else {\n        AddSimple(i, t, -enter[i], 0);\n      }\n      h[i] = 0;\n    }\n    int flow = 0;\n    li cost = basic_cost;\n    while (Dijkstra()) {\n      for (int i = 0; i < n; ++i) {\n        h[i] = min(h[i] + dist[i], infl);\n      }\n      int now = inf;\n      for (int x = t; x != s; x = edge[prev[x] ^ 1].v) {\n        Min(now, edge[prev[x]].cap);\n      }\n      flow += now;\n      cost += now * h[t];\n      for (int x = t; x != s; x = edge[prev[x] ^ 1].v) {\n        edge[prev[x]].cap -= now;\n        edge[prev[x] ^ 1].cap += now;\n      }\n    }\n    return {flow == should, cost};\n  }\n}\n\nint main(void) {\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d%d%lld\", x + i, y + i, v + i);\n    --x[i]; --y[i];\n  }\n  scanf(\"%d\", &m);\n  for (int i = 0; i < m; ++i) {\n    char buf[2];\n    scanf(\"%s%d%d\", buf, a + i, b + i);\n    --a[i];\n    type[i] = buf[0];\n  }\n\n  li ans = 0;\n  for (int total = 1; total <= n; ++total) {\n    for (int i = 0; i <= maxx; ++i) {\n      min_x[i] = min_y[i] = 0;\n      max_x[i] = max_y[i] = n;\n    }\n    for (int i = 0; i < m; ++i) {\n      switch (type[i]) {\n      case 'L':\n        Min(max_x[a[i] + 1], b[i]);\n        break;\n      case 'R':\n        Max(min_x[a[i]], total - b[i]);\n        break;\n      case 'D':\n        Min(max_y[a[i] + 1], b[i]);\n        break;\n      case 'U':\n        Max(min_y[a[i]], total - b[i]);\n        break;\n      }\n    }\n\n    mcf::Init(maxx + 1 << 1);\n    int mid = maxx + 1;\n    for (int i = 0; i < maxx; ++i) {\n      mcf::AddEdge(i + 1, i, min_x[i + 1], max_x[i + 1], 0);\n      mcf::AddEdge(mid + i, mid + i + 1, min_y[i + 1], max_y[i + 1], 0);\n    }\n    mcf::AddEdge(mid + maxx, maxx, total, total, 0);\n    for (int i = 0; i < n; ++i) {\n      mcf::AddEdge(x[i], mid + y[i], 1, 1, -v[i]);\n      mcf::AddEdge(mid + y[i], x[i], 0, 1, v[i]);\n    }\n    auto res = mcf::Solve();\n    if (res.first) {\n      li cost = res.second;\n      Max(ans, -cost);\n    }\n  }\n\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-03-27 10:28:38\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\n#define i64 long long\ni64 read()\n{\n\ti64 r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\nconst int N=2010;\nnamespace run\n{\n\tconst i64 inf=1ll<<60;\n\ti64 n,px[N],sx[N],py[N],sy[N],begin[N],next[N<<2],to[N<<2],w[N<<2],c[N<<2],e,S,T,m,x[N],y[N],v[N],ans,l,sw,sc;\n\ti64 d[N],q[N*N],_l,_r,pre[N],vis[N];\n\tvoid add(i64 u,i64 v,i64 W,i64 C){ e++; next[e]=begin[u]; begin[u]=e; to[e]=v; w[e]=W; c[e]=C; }\n\tvoid Add(i64 u,i64 v,i64 w,i64 c){ /*printf(\"%I64d %I64d %I64d\\n\",u,v,c);*/ add(u,v,w,c); add(v,u,0,-c); }\n#define fo(i,a) for(int i=begin[a];i;i=next[i])\n\tint bfs()\n\t{\n\t\tfr(i,1,m){ d[i]=inf; pre[i]=0; vis[i]=0; }\n\t\tq[_l=_r=1]=S; d[S]=0;\n\t\twhile(_l<=_r)\n\t\t{\n\t\t\tint u=q[_l++]; vis[u]=0;\n//\t\t\tprintf(\"%d\\n\",u);\n\t\t\tfo(i,u) if(w[i]&&d[u]+c[i]<d[to[i]])\n\t\t\t{\n\t\t\t\td[to[i]]=d[u]+c[i]; pre[to[i]]=i;\n\t\t\t\tif(!vis[to[i]]){ q[++_r]=to[i]; vis[to[i]]=1; }\n\t\t\t}\n\t\t}\n\t\treturn d[T]!=inf;\n\t}\n\ti64 solve(int c)\n\t{\n\t\tmemset(begin,0,sizeof(begin)); e=1; S=n+n+c+c+1; T=n+n+c+c+2; m=T;\n//\t\tprintf(\"%d %I64d %I64d\\n\",c,S,T);\n\t\tfr(i,1,n) Add(i,i+n,1,-v[i]);\n\t\tfr(j,1,c){ Add(S,j+n+n,1,0); Add(j+n+n+c,T,1,0); }\n\t\tfr(i,1,n) fr(j,1,c) if(px[x[i]]>=j&&sx[x[i]]>=c-j+1) Add(j+n+n,i,1,0);\n\t\tfr(i,1,n) fr(j,1,c) if(py[y[i]]>=j&&sy[y[i]]>=c-j+1) Add(i+n,j+n+n+c,1,0);\n\t\tsw=sc=0;\n\t\twhile(bfs())\n\t\t{\n//\t\t\tprintf(\"%I64d\\n\",d[T]);\n\t\t\tint u=T; sw++;\n\t\t\twhile(u!=S){ w[pre[u]]--; w[pre[u]^1]++; sc-=::run::c[pre[u]]; u=to[pre[u]^1]; }\n\t\t}\n//\t\tprintf(\"%d %I64d\\n\",c,sw==c?sc:0);\n\t\treturn sw==c?sc:0;\n\t}\n\tint main()\n\t{\n\t\tn=read(); l=100;\n\t\tfr(i,1,n){ x[i]=read(); y[i]=read(); v[i]=read(); }\n\t\tfr(i,0,l+1) px[i]=sx[i]=py[i]=sy[i]=n;\n\t\tfr(i,1,read())\n\t\t{\n\t\t\tchar opt[N]; i64 a,b;\n\t\t\tscanf(\"%s\",opt); a=read(); b=read();\n\t\t\tif(*opt=='L') px[a]=std::min(px[a],b);\n\t\t\tif(*opt=='R') sx[a]=std::min(sx[a],b);\n\t\t\tif(*opt=='D') py[a]=std::min(py[a],b);\n\t\t\tif(*opt=='U') sy[a]=std::min(sy[a],b);\n\t\t}\n\t\tfr(i,1,l){ sx[i]=std::min(sx[i],sx[i-1]); sy[i]=std::min(sy[i],sy[i-1]); }\n\t\tfd(i,l,1){ px[i]=std::min(px[i],px[i+1]); py[i]=std::min(py[i],py[i+1]); }\n//\t\tfr(i,1,n) printf(\"%I64d %I64d %I64d %I64d\\n\", );\n\t\tfr(i,1,n){ i64 k=solve(i); ans=std::max(ans,k); if(!k) break; }\n\t\tprintf(\"%lld\\n\",ans);\n\t\treturn 0;\n\t}\n}\nint main(){ return run::main(); }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define rng(a) a.begin(),a.end()\n#define rrng(a) a.rbegin(),a.rend()\n#define maxs(x,y) (x = max(x,y))\n#define mins(x,y) (x = min(x,y))\n#define limit(x,l,r) max(l,min(x,r))\n#define lims(x,l,r) (x = max(l,min(x,r)))\n#define isin(x,l,r) ((l) <= (x) && (x) < (r))\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcountll\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,v(T),greater<T> >\n#define bn(x) ((1<<x)-1)\n#define dup(x,y) (((x)+(y)-1)/(y))\n#define newline puts(\"\")\n#define v(T) vector<T>\n#define vv(T) v(v(T))\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ntemplate<typename T>inline istream& operator>>(istream&i,v(T)&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(const v(T)&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>inline ostream& operator<<(ostream&o,const v(T)&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>inline istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>inline ostream& operator<<(ostream&o,const pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\ntemplate<typename T>inline ll suma(const v(T)& a) { ll res(0); for (auto&& x : a) res += x; return res;}\nconst double eps = 1e-10;\nconst ll LINF = 1001002003004005006ll;\nconst int INF = 1001001001;\n#define dame { puts(\"-1\"); return 0;}\n#define yn {puts(\"YES\");}else{puts(\"NO\");}\nconst int MX = 200005;\ntypedef pair<ll,P> Q;\ntypedef vector<Q> vq;\n\n// Min cost flow\n// !! Be care of double and INF !!\nstruct Mincost {\n  typedef ll TC;\n  typedef int TL;\n  typedef pair<TC,int> TP;\n  struct Edge {\n    int to, nxt; TC co; TL lim;\n    Edge(){}\n    Edge(int to, int nxt, TC co, TL lim):to(to),nxt(nxt),co(co),lim(lim){}\n  };\n  int n;\n  vi head, pre; vector<TC> dist;\n  vector<Edge> e;\n  Mincost(int n):n(n),head(n,-1) {}\n  void add(int f, int t, TC c=0, TL l=1) {\n    // cerr<<f<<\" \"<<t<<\" \"<<c<<\" \"<<l<<endl;\n    e.pb(Edge(t,head[f],c,l)); head[f] = sz(e)-1;\n    e.pb(Edge(f,head[t],-c,0)); head[t] = sz(e)-1;\n  }\n  void dijk(int sv){\n    dist = vector<TC>(n,LINF); // INF !!\n    pre = vi(n,-1);\n    priority_queue<TP, vector<TP>, greater<TP>> q;\n    int v; TC d;\n    q.push(TP(0,sv));\n    dist[sv] = 0;\n    while (sz(q)) {\n      d = q.top().fi; v = q.top().se; q.pop();\n      if (dist[v] != d) continue;\n      for (int i = head[v]; i != -1; i = e[i].nxt) {\n        int u = e[i].to;\n        if (e[i].lim && d+e[i].co < dist[u]) { // double !!\n          dist[u] = d+e[i].co;\n          pre[u] = i^1;\n          q.push(TP(dist[u],u));\n        }\n      }\n    }\n  }\n  TC solve(int sv, int tv, TL flow) {\n    TC res = 0; TL f;\n    while (flow>0) {\n      dijk(sv);\n      // cerr<<dist<<endl;\n      if (dist[tv] == LINF) return -1; // (double) INF !!\n      rep(i,n)for (int j = head[i]; j != -1; j = e[j].nxt) {\n        e[j].co += dist[i] - dist[e[j].to];\n      }\n      f = flow;\n      for (int i = tv; i != sv; i = e[pre[i]].to) f = min(f,e[pre[i]^1].lim);\n      for (int i = tv; i != sv; i = e[pre[i]].to) {\n        e[pre[i]^1].lim -= f, e[pre[i]].lim += f;\n      }\n      res += dist[tv]*flow; flow -= f;\n    }\n    return res;\n  }\n};\n//\n\nconst int M = 102;\nconst ll B = 1001002003004005ll;\n\nint main() {\n  int n;\n  scanf(\"%d\",&n);\n  vq ps;\n  rep(i,n) {\n    ll z;\n    int x,y;\n    scanf(\"%d%d%lld\",&x,&y,&z);\n    ps.pb(Q(z,P(x,y)));\n  }\n  vp dl, dr;\n  vp dd, du;\n  int q;\n  scanf(\"%d\",&q);\n  rep(i,q) {\n    char c;\n    int x,y;\n    scanf(\" %c%d%d\",&c,&x,&y);\n    if (c == 'L') dl.pb(P(x,y));\n    if (c == 'R') dr.pb(P(x-1,y));\n    if (c == 'D') dd.pb(P(x,y));\n    if (c == 'U') du.pb(P(x-1,y));\n  }\n\n  ll ans = 0;\n  rrep(m,n) {\n    // if (m != 4) continue; //\n    int sv = M*2, tv = sv+1;\n    Mincost g(tv+1);\n    ll now = B*m;\n    rep(i,n) {\n      int x = ps[i].se.fi, y = ps[i].se.se;\n      ll z = ps[i].fi;\n      g.add(x,M+y,B-z,1);\n    }\n    bool ok = true;\n    int flow = m;\n    {\n      vi l(M-1), r(M-1,m);\n      for (P p : dl) {\n        int x = p.fi, y = m-p.se;\n        maxs(l[x],y);\n      }\n      for (P p : dr) {\n        int x = p.fi, y = p.se;\n        mins(r[x],y);\n      }\n      rep(i,M-1) {\n        if (r[i] < l[i]) {\n          ok = false;\n          break;\n        }\n        if (l[i]) {\n          g.add(sv,i+1,0,l[i]);\n          g.add(i,tv,0,l[i]);\n          flow += l[i];\n        }\n        g.add(i,i+1,0,r[i]-l[i]);\n      }\n    }\n    if (!ok) continue;\n    {\n      vi l(M-1), r(M-1,m);\n      for (P p : dd) {\n        int x = p.fi, y = m-p.se;\n        maxs(l[x],y);\n      }\n      for (P p : du) {\n        int x = p.fi, y = p.se;\n        mins(r[x],y);\n      }\n      rep(i,M-1) {\n        if (r[i] < l[i]) {\n          ok = false;\n          break;\n        }\n        if (l[i]) {\n          g.add(sv,M+i,0,l[i]);\n          g.add(M+i+1,tv,0,l[i]);\n          flow += l[i];\n        }\n        g.add(M+i+1,M+i,0,r[i]-l[i]);\n      }\n    }\n    if (!ok) continue;\n    g.add(sv,0,0,m);\n    g.add(M,tv,0,m);\n    ll res = g.solve(sv,tv,flow);\n    // cerr<<res<<endl;\n    if (res == -1) continue;\n    now -= res;\n    maxs(ans, now);\n    // cerr<<m<<\" \"<<now<<endl;\n    // rep(i,n) {\n    //   cerr<<i<<\" \"<<g.e[i*2].lim<<endl;\n    // }\n  }\n\n  cout<<ans<<endl;\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<stack>\n#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\nstruct MinCostMaxFlow {\n    typedef LL Flow;\n    typedef LL Cost;\n    static const Flow FLOW_INF = 1LL<<60;\n    static const Cost COST_INF = 1LL<<60;\n    struct Edge {\n\tint src, dst;\n\tCost cst;\n\tFlow cap;\n\tint rev;\n\tbool operator<(const Edge&y) const {\n\t    return cst > y.cst;\n\t}\n    };\n    typedef vector<vector<Edge> > Graph;\n    Graph G;\n    MinCostMaxFlow(int N) : G(N) {}\n    // directed\n    void add_edge(int u, int v, Cost x, Flow f) {\n\tG[u].push_back((Edge){ u, v, x, f, (int)G[v].size() });\n\tG[v].push_back((Edge){ v, u, -x, 0, (int)G[u].size()-1 });\n    }\n\n    Flow flow;\n    Cost cost;\n    Flow solve(int s, int t, Flow limit = FLOW_INF) {\n\tflow = 0;\n\tcost = 0;\n\tvector<Cost>len, h(G.size(), 0);\n\tvector<int> prev, prev_num;\n\twhile (limit > 0) {\n\t    priority_queue<Edge> Q;\n\t    Q.push((Edge){-2, s, 0, 0, 0});\n\t    len.assign(G.size(), COST_INF);\n\t    prev.assign(G.size(), -1); prev_num.assign(G.size(), -1);\n\t    len[s] = 0;\n\t    while (!Q.empty()) {\n\t\tEdge e = Q.top(); Q.pop();\n\t\tif (e.cst > len[e.dst]) continue;\n\t\tif (e.dst == t) break;\n\t\tfor (int i=0; i<(int)G[e.dst].size(); i++) {\n\t\t    const Edge &f = G[e.dst][i];\n\t\t    if (f.cap > 0 && len[f.dst] > len[f.src] + f.cst + h[f.src] - h[f.dst]) {\n\t\t\tlen[f.dst] = len[f.src] + f.cst + h[f.src] - h[f.dst];\n\t\t\tQ.push((Edge){ f.src, f.dst, len[f.dst], 0, 0 });\n\t\t\tprev[f.dst] = f.src; prev_num[f.dst] = i;\n\t\t    }\n\t\t}\n\t    }\n\t    if (prev[t] == -1) return flow;\n\t    for (int i=0; i<(int)G.size(); i++) h[i] += len[i];\n\t    \n\t    Flow f = limit;\n\t    for (int v=t; v!=s; v=prev[v])\n\t\tf = min(f, G[prev[v]][prev_num[v]].cap);\n\t    for (int v=t; v!=s; v=prev[v]) {\n\t\tEdge &e = G[prev[v]][prev_num[v]];\n\t\te.cap -= f;\n\t\tG[e.dst][e.rev].cap += f;\n\t    }\n\t    limit -= f;\n\t    flow += f;\n\t    cost += f * h[t];\n\t}\n\treturn flow;\n    }\n};\nconst MinCostMaxFlow::Flow MinCostMaxFlow::FLOW_INF;\nconst MinCostMaxFlow::Cost MinCostMaxFlow::COST_INF;\n\nint N;\nint X[88], Y[88];\nLL V[88];\nint M;\nchar T[333];\nint A[333], B[333];\n\nint Llo[88], Lhi[88], Dlo[88], Dhi[88];\nconst LL BASE = 1LL<<50;\nLL calc(int K) {\n    memset(Lhi, 0x3f, sizeof Lhi);\n    memset(Llo, 0xc0, sizeof Llo);\n    memset(Dhi, 0x3f, sizeof Dhi);\n    memset(Dlo, 0xc0, sizeof Dlo);\n    REP (j, M) {\n\tint a = A[j], b = B[j];\n\tif (b < K) {\n\t    if (T[j] == 'L') amax(Llo[b], a);\n\t    if (T[j] == 'R') amin(Lhi[K-b-1], a);\n\t    if (T[j] == 'D') amax(Dlo[b], a);\n\t    if (T[j] == 'U') amin(Dhi[K-b-1], a);\n\t}\n    }\n    REP (i, K-1) {\n\tamax(Llo[i+1], Llo[i]);\n\tamax(Dlo[i+1], Dlo[i]);\n    }\n    for (int i=K-2; i>=0; i--) {\n\tamin(Lhi[i], Lhi[i+1]);\n\tamin(Dhi[i], Dhi[i+1]);\n    }\n//    rprintf(\"%d\", Llo, Llo+K);\n//    rprintf(\"%d\", Lhi, Lhi+K);\n//    rprintf(\"%d\", Dlo, Dlo+K);\n//    rprintf(\"%d\", Dhi, Dhi+K);\n//\n    const int SRC = K*2+N*2, SNK = SRC+1;\n    MinCostMaxFlow G(SNK+1);\n    REP (i, N) {\n\tint left = i+K*2, right = left + N;\n\tG.add_edge(left, right, BASE - V[i], 1);\n\tREP (a, K) {\n\t    if (Llo[a] < X[i] && X[i] < Lhi[a]) {\n\t\tG.add_edge(a, left, 0, 1);\n\t    }\n\t    if (Dlo[a] < Y[i] && Y[i] < Dhi[a]) {\n\t\tG.add_edge(right, a+K, 0, 1);\n\t    }\n\t}\n    }\n    REP (a, K) {\n\tG.add_edge(SRC, a, 0, 1);\n\tG.add_edge(a+K, SNK, 0, 1);\n    }\n    G.solve(SRC, SNK);\n    if (G.flow == K) {\n\treturn K * BASE - G.cost;\n    } else {\n\treturn 0;\n    }\n\n}\n\nvoid MAIN() {\n    scanf(\"%d\", &N);\n    REP (i, N) scanf(\"%d%d%lld\", X+i, Y+i, V+i);\n    scanf(\"%d\", &M);\n    REP (i, M) scanf(\"%s%d%d\", T+i, A+i, B+i);\n\n    \n    LL ans = 0;\n    for (int k=1; k<=N; k++) amax(ans, calc(k));\n    \n    printf(\"%lld\\n\", ans);\n\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair < int , int > pii;\ntypedef pair < LL , int > pli;\nint n,m,x[80],y[80],px[80],py[80];\nLL v[80];\nchar readch(){\n\tchar c=getchar();\n\twhile(c!='L' && c!='R' && c!='U' && c!='D'){\n\t\tc=getchar();\n\t}\n\treturn c;\n}\nnamespace flows{\n\tstruct edge{\n\t\tint v,f,r;\n\t\tLL c;\n\t\tvoid set(int V,int F,int R,LL C){\n\t\t\tv=V;f=F;r=R;c=C;\n\t\t}\n\t}tmp;\n\tvector < edge > adj[1005];\n\tvoid init(){\n\t\tint i;\n\t\tfor(i=0;i<1005;++i) adj[i].clear();\n\t}\n\tLL dis[1005];\n\tpriority_queue < pli > pq;\n\tint predv[1005],prede[1005];\n\t\n};\nbool cmpx(int a,int b){\n\treturn x[a]<x[b];\n}\nbool cmpy(int a,int b){\n\treturn y[a]<y[b];\n}\nchar TP[405];\nint D[405],V[405];\nvector < pii > consx,consy;\nLL solve(int tot){\n\tint i,j,k;\n\tconsx.clear();\n\tconsy.clear();\n\tfor(i=0;i<m;++i){\n\t\tif(TP[i]=='L')\n\t\t\tconsx.push_back(mpr(D[i],V[i]));\n\t\telse if(TP[i]=='R' && V[i]<tot)\n\t\t\tconsx.push_back(mpr(D[i]-1,-tot+V[i]));\n\t\telse if(TP[i]=='D')\n\t\t\tconsy.push_back(mpr(D[i],V[i]));\n\t\telse if(TP[i]=='U' && V[i]<tot)\n\t\t\tconsy.push_back(mpr(D[i]-1,-tot+V[i]));\n\t}\n\tsort(consx.begin(),consx.end());\n\tsort(consy.begin(),consy.end());\n\tflows::init();\n\t// 0: super source  1: original source  2: extra source\n\tflows::addedge(0,1,tot,0);\n\tflows::addedge(4,3,tot,0);\n\tint extraflow=0;\n\tfor(i=(int)consx.size()-1;i>=0;--i){\n\t\tif(consx[i].second<0) return 0ll;\n\t\tif(!i) flows::addedge(1,6,tot,0);\n\t\telse{\n\t\t\t\n\t\t}\n\t}\n}\nint main(){\n\tint i,j,k;\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;++i){\n\t\tscanf(\"%d%d%lld\",x+i,y+i,v+i);\n\t\t--x[i];--y[i];\n\t\tpx[i]=i;\n\t\tpy[i]=i;\n\t}\n\tscanf(\"%d\",&m);\n\tfor(i=0;i<m;++i){\n\t\tTP[i]=readch();\n\t\tscanf(\"%d%d\",D+i,V+i);\n\t\t--D[i];\n\t}\n\tsort(px,px+n,cmpx);\n\tsort(py,py+n,cmpy);\n\tLL res=0ll;\n\tfor(i=0;i<=n;++i){\n\t\tUMAX(res,solve(i));\n\t}\n\tprintf(\"%lld\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n#define rep(i,a) for(int i=lst[a];i;i=nxt[i])\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N=85,M=325;\n\nstruct P{int x,y;ll v;}p[N];\nstruct limit{int a,b,tp;}lim[M];\n\nint n,m;\nchar opt[5];\n\nnamespace flow{\n\n\tconst int N=505,M=N*500;\n\tconst ll inf=1e18;\n\n\tint t[M],f[M],nxt[M],lst[N],l,S,T;\n\tll v[M];\n\n\tvoid add(int x,int y,int z,ll c) {\n\t\tt[++l]=y;f[l]=z;v[l]=c;nxt[l]=lst[x];lst[x]=l;\n\t\tt[++l]=x;f[l]=0;v[l]=-c;nxt[l]=lst[y];lst[y]=l;\n\t}\n\n\tll dis[N],ans;\n\tint pre[N];\n\tbool vis[N];\n\tint q[M];\n\n\tbool spfa() {\n\t\tfo(i,S,T) dis[i]=-inf;dis[S]=0;\n\t\tint i=0,j=1;q[1]=S;vis[S]=1;\n\t\twhile (i<j) {\n\t\t\trep(k,q[++i]) \n\t\t\t\tif (f[k]&&dis[t[k]]<dis[q[i]]+v[k]) {\n\t\t\t\t\tdis[t[k]]=dis[q[i]]+v[k],pre[t[k]]=k;\n\t\t\t\t\tif (!vis[t[k]]) vis[t[k]]=1,q[++j]=t[k];\n\t\t\t\t}\n\t\t\tvis[q[i]]=0;\n\t\t}\n\t\treturn dis[T]>0;\n\t}\n\n\tvoid find() {\n\t\tfor(int x=T;x;x=t[pre[x]^1]) {\n\t\t\tans+=v[pre[x]];\n\t\t\tf[pre[x]]--;f[pre[x]^1]++;\n\t\t}\n\t}\n\n\tint lx[N],ly[N],rx[N],ry[N];\n\n\tll solve(int k) {\n\t\tfo(i,S,T) lst[i]=0;l=1;\n\t\tS=0;T=n+(k<<1)+200+1;\n\t\tfo(i,1,n) {\n\t\t\tadd(k+p[i].x,k+100+i,1,p[i].v);\n\t\t\tadd(k+100+i,k+100+n+p[i].y,1,0);\n\t\t}\n\t\tfo(i,1,k) lx[i]=ly[i]=1,rx[i]=ry[i]=100;\n\t\tfo(i,1,m) {\n\t\t\tif (lim[i].tp==0) lx[lim[i].b+1]=max(lx[lim[i].b]+1,lim[i].a+1);\n\t\t\tif (lim[i].tp==1&&k>lim[i].b) rx[k-lim[i].b]=min(rx[k-lim[i].b],lim[i].a-1);\n\t\t\tif (lim[i].tp==2) ly[lim[i].b+1]=max(ly[lim[i].b]+1,lim[i].a+1);\n\t\t\tif (lim[i].tp==3&&k>lim[i].b) ry[k-lim[i].b]=min(ry[k-lim[i].b],lim[i].a-1);\n\t\t}\n\t\tfo(i,2,k) lx[i]=max(lx[i],lx[i-1]),ly[i]=max(ly[i],ly[i-1]);\n\t\tfd(i,k-1,1) rx[i]=min(rx[i],rx[i+1]),ry[i]=min(ry[i],ry[i+1]);\n\t\tfo(i,1,k) {\n\t\t\tadd(S,i,1,0);add(200+n+k+i,T,1,0);\n\t\t\tfo(j,lx[i],rx[i]) add(i,j+k,1,0);\n\t\t\tfo(j,ly[i],ry[i]) add(k+100+n+j,200+n+k+i,1,0);\n\t\t} \n\t\trep(i,42);\n\t\tans=0;int flow=0;\n\t\twhile (spfa()) flow++,find();\n\t\treturn flow==k?ans:0;\n\t}\n}\n\nint main() {\n\tscanf(\"%d\",&n);\n\tfo(i,1,n) scanf(\"%d%d%lld\",&p[i].x,&p[i].y,&p[i].v);\n\tscanf(\"%d\",&m);\n\tfo(i,1,m) {\n\t\tscanf(\"%s\",opt+1);\n\t\tscanf(\"%d%d\",&lim[i].a,&lim[i].b);\n\t\tif (opt[1]=='L') lim[i].tp=0;\n\t\tif (opt[1]=='R') lim[i].tp=1;\n\t\tif (opt[1]=='D') lim[i].tp=2;\n\t\tif (opt[1]=='U') lim[i].tp=3;\n\t}\n\tll ans=0;\n\tfo(i,1,n) ans=max(ans,flow::solve(i));\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace __gnu_pbds;\nusing namespace std;\n \ntemplate <typename T>\nusing ordered_set =\n\ttree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n \n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n\t*this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n \n#define shandom_ruffle random_shuffle\n \nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=327;\nusing bn=bitset<87>;\nusing ld=long double;\n\nint n;\npii gdz[nax];\nll war[nax];\n\nint m;\nbn podz[nax];\nint ile[nax];\n\nll wyn;\n\nbn ter;\n \nll dajwar()\n{\n\tll ret=0;\n\tfor (int i=1; i<=n; i++)\n\t\tif (ter[i])\n\t\t\tret+=war[i];\n\treturn ret;\n}\n \nint popr()\n{\n\tfor (int i=1; i<=m; i++)\n\t\tif ((podz[i]&ter).count()>ile[i])\n\t\t\treturn 0;\n\treturn 1;\n}\n\nvi kol;\n\nstruct Simplex {        // Maximize c*x subject to Ax <= b.\n  using T = ld;     // Initialize the structure, set A, b, c and then run\n  vector<vector<T>> A;  // solve(). Max objective is stored in res. To recover\n  vector<T> b, c;       // the best result, use getVars().\n  int V, E;\n  vector<int> eqIds, varIds, cols;\n  T res;\n  static constexpr T kEps = 1e-5;\n\n  Simplex(int vars, int eqs) : A(eqs, vector<T>(vars)), b(eqs), c(vars),\n      V(vars), E(eqs), eqIds(eqs), varIds(vars), res(0) {\n    iota(varIds.begin(), varIds.end(), 0);\n    iota(eqIds.begin(), eqIds.end(), vars);\n  }\n\n  void pivot(int eq, int var) {\n    T coef = 1 / A[eq][var];\n    cols.clear();\n    for (int i = 0; i < V; i++) {\n      if (abs(A[eq][i]) > kEps) { cols.push_back(i); A[eq][i] *= coef; }\n    }\n    A[eq][var] *= coef; b[eq] *= coef;\n    for (int row = 0; row < E; row++) {\n      if (row == eq || abs(A[row][var]) < kEps) { continue; }\n      T k = -A[row][var];\n      A[row][var] = 0;\n      for (int i : cols) { A[row][i] += k * A[eq][i]; }\n      b[row] += k * b[eq];\n    }\n    T q = c[var]; c[var] = 0;\n    for (int i : cols) { c[i] -= q * A[eq][i]; }\n    res += q * b[eq];\n    swap(varIds[var], eqIds[eq]);\n  }\n\n  bool solve() {\n    while (true) {\n      int eq = -1, var = -1;\n      for (int i = 0; i < E; i++) { if (b[i] < -kEps) { eq = i; break; } }\n      if (eq == -1) { break; }\n      for (int i = 0; i < V; i++) { if (A[eq][i] < -kEps) { var = i; break; } }\n      if (var == -1) { res = -1e9; return false; /* No solution */ }\n      pivot(eq, var);\n    }\n    while (true) {\n      int var = -1, eq = -1;\n      for (int i = 0; i < V; i++) { if (c[i] > kEps) { var = i; break; } }\n      if (var == -1) { break; }\n      for (int i = 0; i < E; i++) {\n        if (A[i][var] < kEps) { continue; }\n        if (eq >= 0 && b[i] / A[i][var] >= b[eq] / A[eq][var]) { continue; }\n        eq = i;\n      }\n      if (eq == -1) { res = 1e9; return false; /* Unbounded */ }\n      pivot(eq, var);\n    }\n    return true;\n  }\n\n  vector<T> getVars() { // Optimal assignment of variables.\n    vector<T> result(V);\n    for (int i = 0; i < E; i++) if (eqIds[i] < V) result[eqIds[i]] = b[i];\n    return result;\n  }\n};\n\nvoid rek(int v, int jesz)\n{\n\tif (popr())\n\t\twyn=max(wyn, dajwar());\n\tif (!jesz)\n\t\treturn;\n\tfor (int i=v; i<=n; i++)\n\t{\n\t\tter.flip(i);\n\t\trek(i+1, jesz-1);\n\t\tter.flip(i);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(\"%d%d%lld\", &gdz[i].first, &gdz[i].second, &war[i]);\n\tscanf(\"%d\", &m);\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\tchar c;\n\t\tint a, b;\n\t\tscanf(\" %c%d%d\", &c, &a, &b);\n\t\tfor (int j=1; j<=n; j++)\n\t\t{\n\t\t\tif (c=='L' && gdz[j].first<=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='R' && gdz[j].first>=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='D' && gdz[j].second<=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='U' && gdz[j].second>=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t}\n\t\tile[i]=b;\n\t}\n\tSimplex janusz(n, m+2*n);\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tjanusz.c[i]=war[i+1];\n\t}\n\tfor (int i=0; i<m; i++)\n\t{\n\t\tjanusz.b[i]=ile[i+1];\n\t\tfor (int j=0; j<n; j++)\n\t\t\tjanusz.A[i][j]=podz[i+1][j+1];\n\t}\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tjanusz.b[m+i]=1;\n\t\tjanusz.A[m+i][i]=1;\n\t}\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tjanusz.b[m+n+i]=0;\n\t\tjanusz.A[m+n+i][i]=-1;\n\t}\n\tassert(janusz.solve());\n\tauto wez=janusz.getVars();\n\t\n\tfor (int i=0; i<n; i++)\n\t\tter[i+1]=(wez[i]>0.5);\n\t\n\twyn=llround(janusz.res);\n\t\n\twhile(popr())\n\t{\n\t\tint czy=0;\n\t\tfor (int i=1; i<=n; i++)\n\t\t{\n\t\t\tif (!ter[i])\n\t\t\t{\n\t\t\t\tter[i]=1;\n\t\t\t\tif (popr())\n\t\t\t\t\tczy=1;\n\t\t\t\telse\n\t\t\t\t\tter[i]=0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (!czy)\n\t\t\tbreak;\n\t}\n\t\n\trek(1, 4+(n<=65));\n\t\n\tdebug() << janusz.getVars();\n\tprintf(\"%lld\\n\", wyn);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef HOME\n#define db(x) cerr << #x << \" = \" << x << endl\n#define db3(x, y, z) cerr << \"(\" << #x << \", \" << #y << \", \" << #z << \") = (\" << x << \", \" << y << \", \" << z << \")\" << endl\n#define db2(x, y) cerr << \"(\" << #x << \", \" << #y << \") = (\" << x << \", \" << y << \")\" << endl\n#define dbv(a) cerr << #a << \" = \"; for (auto xxx: a) cerr << xxx  << \" \"; cerr << endl\n#else\n#define db(x) ;\n#define db3(x, y, z) ;\n#define db2(x, y) ;\n#define dbv(a) ;\n#endif\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double dbl;\n\n\nconst int INF = 1.01e9;\nconst int MOD = (int)1e9 + 7;\n\nstruct Item {\n    int x, y;\n    ll val;\n};\n\nstruct Cond {\n    char type;\n    int a, b;\n\n    bool cover(Item it) {\n        if (type == 'L') {\n            return it.x <= a;\n        }\n        if (type == 'R') {\n            return it.x >= a;\n        }\n        if (type == 'D') {\n            return it.y <= a;\n        }\n        if (type == 'U') {\n            return it.y >= a;\n        }\n        assert(0);\n    }\n};\n\nll slow(vector<Item> a, vector<Cond> b) {\n    int n = a.size(), m = b.size();\n    ll ans = 0;\n    for (int mask = 0; mask < (1 << n); mask++) {\n        vector<int> cnt(m);\n        ll sum = 0;\n        for (int i = 0; i < n; i++) {\n            if (!(mask & (1 << i))) continue;\n            sum += a[i].val;\n            for (int j = 0; j < m; j++) {\n                if (b[j].cover(a[i])) {\n                    cnt[j]++;\n                }\n            }\n        }\n        bool bad = 0;\n        for (int i = 0; i < m; i++) {\n            if (cnt[i] > b[i].b) {\n                bad = 1;\n            }\n        }\n        if (bad) continue;\n        ans = max(ans, sum);\n    }\n    return ans;\n}\n\n\nbool eq(dbl a, dbl b) {\n    return fabs(a - b) < 1e-9;\n}\n\nbool ls(dbl a, dbl b) {\n    return !eq(a, b) && a < b;\n}\n\nvector<dbl> supersimplex(vector<vector<dbl> > a) {\n    int n = a.size() - 1;\n    int m = a[0].size() - 1;\n    vector<int> left(n + 1), up(m + 1);\n    iota(up.begin(), up.end(), 0);\n    iota(left.begin(), left.end(), m);\n    while (1) {\n        auto pivot = [&](int x, int y) {\n            swap(left[x], up[y]);\n            dbl k = a[x][y];\n            a[x][y] = 1;\n            vector<int> vct;\n            for (int j = 0; j <= m; j++) {\n                a[x][j] /= k;\n                if (!eq(a[x][j], 0)) vct.push_back(j);\n            }\n            for (int i = 0; i <= n; i++) {\n                if (eq(a[i][y], 0) || i == x) continue;\n                k = a[i][y];\n                a[i][y] = 0;\n                for (int j : vct) a[i][j] -= k * a[x][j];\n            }\n        };\n        while (1) {\n            int x = -1;\n            for (int i = 1; i <= n; i++) if (ls(a[i][0], 0) && (x == -1 || a[i][0] < a[x][0])) x = i;\n            if (x == -1) break;\n            int y = -1;\n            for (int j = 1; j <= m; j++) if (ls(a[x][j], 0) && (y == -1 || a[x][j] < a[x][y])) y = j;\n            if (y == -1) return vector<dbl>(m, 0);\n            pivot(x, y);\n        }\n        while (1) {\n            int y = -1;\n            for (int j = 1; j <= m; j++) if (ls(0, a[0][j]) && (y == -1 || a[0][j] > a[0][y])) y = j;\n            if (y == -1) break;\n            int x = -1;\n            for (int i = 1; i <= n; i++) if (ls(0, a[i][y]) && (x == -1 || a[i][0] / a[i][y] < a[x][0] / a[x][y])) x = i;\n            if (x == -1) assert(0); // unbounded\n            pivot(x, y);\n        }\n\n        vector<int> v;\n        vector<dbl> ans(m + 1);\n        vector<int> rev(m + 1);\n        for (int i = 1; i <= n; i++) if (left[i] <= m) ans[left[i]] = a[i][0], rev[left[i]] = i;\n        ans[0] = -a[0][0];\n        for (int i = 1; i <= m; i++) {\n            if (!eq(ans[i], floor(ans[i])) && !eq(ans[i], floor(ans[i]) + 1)) {\n                v.push_back(rev[i]);\n            }\n        }\n        if (clock() / (double)CLOCKS_PER_SEC > 1.7 || n * m > 1e7) return ans;\n        if (v.empty()) {\n            return ans;\n        }\n        for (int i = 0; i <= n; i++) {\n            for (int j = 0; j < (int)v.size(); j++) {\n                a[i].push_back(0);\n            }\n        }\n        for (int i = 0; i < (int)v.size(); i++) {\n            vector<dbl> cur(a[0].size());\n            cur[m + 1 + i] = 1;\n            cur[0] = floor(a[v[i]][0]) - a[v[i]][0];\n            for (int j = 1; j <= m; j++) {\n                cur[j] = floor(a[v[i]][j]) - a[v[i]][j];\n            }\n            a.push_back(cur);\n        }\n        m += v.size();\n        n += v.size();\n        up.resize(up.size() + v.size());\n        left.resize(left.size() + v.size());\n    }\n}\n// j=1..m: x[j]>=0\n// i=1..n: sum(j=1..m) A[i][j]*x[j] <= A[i][0]\n// max sum(j=1..m) A[0][j]*x[j]\n// res[0] is answer\n// res[1..m] is certificate\n\nll fast(vector<Item> a, vector<Cond> b) {\n    int n = a.size(), m = b.size();\n    vector<vector<dbl>> c(m + 1, vector<dbl>(n + 1));\n    for (int i = 0; i < n; i++) {\n        c[0][1 + i] = a[i].val;\n    }\n    for (int i = 0; i < m; i++) {\n        c[1 + i][0] = b[i].b;\n        for (int j = 0; j < n; j++) {\n            if (b[i].cover(a[j])) {\n                c[1 + i][1 + j] = 1;\n            }\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        vector<dbl> cur(n + 1);\n        cur[0] = 1;\n        cur[1 + i] = 1;\n        c.push_back(cur);\n    }\n    return (ll)round(supersimplex(c)[0]);\n}\n\nvoid stress() {\n    for (int it = 0;; it++) {\n        mt19937_64 rnd(it);\n        db(it);\n\n\n        int n = 80;\n        vector<Item> a(n);\n        for (int i =0 ; i < n; i++) {\n            a[i].x = rnd() % 1000;\n            a[i].y = rnd() % 1000;\n            a[i].val = rnd() % (ll)1e15;\n        }\n        int m = rnd() % (4 * n) + 1;\n        vector<Cond> b(m);\n        for (int i = 0; i < m; i++) {\n            b[i].a = rnd() % 1000;\n            b[i].b = rnd() % (n + 1);\n            b[i].type = \"ULDR\"[rnd() % 4];\n        }\n\n        auto ans1 = fast(a, b);\n//        auto ans2 = slow(a, b);\n        auto ans2 = ans1;\n        if (ans1 != ans2) {\n            cout << ans1 << \" instead of \" << ans2 << endl;\n            exit(0);\n        }\n    }\n}\n\nint main() {\n#ifdef HOME\n    assert(freopen(\"in\", \"r\", stdin));\n    stress();\n#endif\n\n    int n;\n    while (scanf(\"%d\", &n) == 1) {\n        vector<Item> a(n);\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d%d%lld\", &a[i].x, &a[i].y, &a[i].val);\n        }\n        int m;\n        scanf(\"%d\", &m);\n        vector<Cond> b(m);\n        for (int i = 0; i < m; i++) {\n            scanf(\" %c%d%d\", &b[i].type, &b[i].a, &b[i].b);\n        }\n\n//        printf(\"%lld\\n\", slow(a, b));\n        printf(\"%lld\\n\", fast(a, b));\n    }\n\n#ifdef HOME\n    cerr << \"time: \" << clock() * 1.0 / CLOCKS_PER_SEC << endl;\n#endif\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<double, double> pdd;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\n//const int mod = ;\n\nstruct J {\n  int x, y, ind;\n  ll cost;\n};\n\nvi dx(100, 100), ux(100, 100), dy(100, 100), uy(100, 100);\nvector<J> v;\nvi best;\nll best_score = 0;\n\nll eval(const vi& x) {\n  ll score = 0;\n  for (int i = 0; i < v.size(); ++i) score += v[i].cost * x[i];\n  return score;\n}\n\nvoid update(const vi& x) {\n  ll score = eval(x);\n  if (score > best_score) {\n    best = x;\n    best_score = score;\n  }\n}\n\nint tmpx[100], tmpy[100];\nbool valid_add(int ind, const vi& x) {\n  memset(tmpx, 0, sizeof(tmpx));\n  memset(tmpy, 0, sizeof(tmpy));\n  for (int i = 0; i < x.size(); ++i) if (x[i] || i == ind) {\n    tmpx[v[i].x]++;\n    tmpy[v[i].y]++;\n  }\n  int sx = 0;\n  for (int i = 0; i < 100; ++i) {\n    sx += tmpx[i];\n    if (sx > dx[i]) return false;\n  }\n  sx = 0;\n  for (int i = 99; i >= 0; --i) {\n    sx += tmpx[i];\n    if (sx > ux[i]) return false;\n  }\n  int sy = 0;\n  for (int i = 0; i < 100; ++i) {\n    sy += tmpy[i];\n    if (sy > dy[i]) return false;\n  }\n  sy = 0;\n  for (int i = 99; i >= 0; --i) {\n    sy += tmpy[i];\n    if (sy > uy[i]) return false;\n  }\n  return true;\n}\n\nvoid f(vi x) {\n  ll score = eval(x);\n  for (int t = 0; t < 10; ++t) {\n    ll s0 = score;\n    for (int i = 0; i < x.size(); ++i) if (x[i]) {\n      vi y = x;\n      y[i] = 0;\n      if (t % 2) {\n        for (int j = 0; j < x.size(); ++j) if (j != i) {\n          if (valid_add(j, y)) {\n            y[j] = 1;\n          }\n        }\n      } else {\n        for (int j = x.size() - 1; j >= 0; --j) if (j != i) {\n          if (valid_add(j, y)) {\n            y[j] = 1;\n          }\n        }\n      }\n      ll cand = eval(y);\n      if (cand > score) {\n        score = cand;\n        x = y;\n      }\n    }\n    for (int i = 0; i < x.size(); ++i) if (x[i]) for (int i1 = i + 1; i1 < x.size(); ++i1) if (x[i1]) {\n      vi y = x;\n      y[i] = y[i1] = 0;\n      if (t % 2) {\n        for (int j = 0; j < x.size(); ++j) if (j != i && j != i1) {\n          if (valid_add(j, y)) {\n            y[j] = 1;\n          }\n        }\n      } else {\n        for (int j = x.size() - 1; j >= 0; --j) if (j != i && j != i1) {\n          if (valid_add(j, y)) {\n            y[j] = 1;\n          }\n        }\n      }\n      ll cand = eval(y);\n      if (cand > score) {\n        score = cand;\n        x = y;\n      }\n    }\n    if (score == s0) break;\n  }\n  update(x);\n}\n\nvoid greedy(int type) {\n  vector<J> ts = v;\n  if (type == 0) {\n    sort(ts.rbegin(), ts.rend(), [&](const auto& a, const auto& b){return a.cost < b.cost;});\n  } else if (type > 0) {\n    vd mulx(v.size(), 1e-10), muly(v.size(), 1e-10);\n    vd mul(v.size());\n    for (int i = 0; i < v.size(); ++i) {\n      for (int x = v[i].x; x < 100; ++x) if (ux[x] != 100) {\n        mulx[i] += 1. / ux[x];\n      }\n      for (int x = 0; x <= v[i].x; ++x) if (dx[x] != 100) {\n        mulx[i] += 1. / dx[x];\n      }\n      for (int y = v[i].y; y < 100; ++y) if (uy[y] != 100) {\n        muly[i] += 1. / uy[y];\n      }\n      for (int y = 0; y <= v[i].y; ++y) if (dy[y] != 100) {\n        muly[i] += 1. / dy[y];\n      }\n      if (type == 1) {\n        mul[i] = 1. / (mulx[i] + muly[i]);\n      } else if (type == 2) {\n        mul[i] = 1. / (mulx[i]);\n      } else if (type == 3) {\n        mul[i] = 1. / (muly[i]);\n      } else if (type == 5) {\n        mul[i] = 1. / sqrt(mulx[i] + muly[i]);\n      }\n    }\n    sort(ts.rbegin(), ts.rend(), [&](const auto& a, const auto& b){return a.cost * mul[a.ind] < b.cost * mul[b.ind];});\n  } else {\n    random_shuffle(ts.begin(), ts.end());\n  }\n  vi x(v.size());\n  for (int i = 0; i < ts.size(); ++i) {\n    int ind = ts[i].ind;\n    if (valid_add(ind, x)) {\n//      cerr << ind << endl;\n      x[ind] = 1;\n    }\n  }\n  f(x);\n//  update(x);\n}\n\nint main() {\n  std::ios::sync_with_stdio(false); std::cin.tie(0);\n  int n;\n  cin >> n;\n  v.resize(n);\n  for (int i = 0; i < n; ++i) {\n    cin >> v[i].x >> v[i].y >> v[i].cost;\n    --v[i].x; --v[i].y;\n    v[i].ind = i;\n  }\n  int m;\n  cin >> m;\n  for (int i = 0; i < m; ++i) {\n    string t;\n    int a, b;\n    cin >> t >> a >> b;\n    --a;\n    if (t == \"L\") {\n      dx[a] = b;\n    }\n    if (t == \"R\") {\n      ux[a] = b;\n    }\n    if (t == \"D\") {\n      dy[a] = b;\n    }\n    if (t == \"U\") {\n      uy[a] = b;\n    }\n  }\n  for (int t = 0; t < 6; ++t) {\n    greedy(t);\n  }\n  for (int t = 0; t < 10; ++t) {\n    greedy(-1);\n  }\n  cout << best_score << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ref(i,x,y)for(int i=x;i<=y;++i)\n#define def(i,x,y)for(int i=x;i>=y;--i)\n#define fi first\n#define se second\n#define int long long\n#define pb push_back\ntypedef long long LL;\nconst int N=221;\nint n,m;\nint lx[2][N],ly[2][N];\nstruct dot{int x,y,v,id;}p[N],px[N],py[N];\nbool cmpx(dot a,dot b){return a.x<b.x;}\nbool cmpy(dot a,dot b){return a.y<b.y;}\nvoid smin(int&a,int b){if(b<a)a=b;}\nvoid smax(int&a,int b){if(b>a)a=b;}\nnamespace eden{\n\tint w[N][N],c[N][N],op,ed;\n\tvoid init(){\n\t\tmemset(w,0,sizeof w);\n\t\tmemset(c,0,sizeof c);\n\t}\n\tvoid add(int x,int y,int ww,int cc){\n\t\tw[x][y]=ww;w[y][x]=0;\n\t\tc[x][y]=cc;c[y][x]=-cc;\n\t}\n\tqueue<int> q;bool vis[N];int dis[N],pre[N];\n\tbool spfa(){\n\t\tmemset(vis,0,sizeof vis);\n\t\tmemset(pre,0,sizeof pre);\n\t\twhile(!q.empty())q.pop();\n\t\tref(i,1,ed)dis[i]=(LL)1e18;\n\t\tdis[op]=0;q.push(op);vis[op]=1;\n\t\twhile(!q.empty()){\n\t\t\tint u=q.front();q.pop();vis[u]=0;\n\t\t\tref(v,1,ed)if(w[u][v]&&dis[u]+c[u][v]<dis[v]){\n\t\t\t\tdis[v]=dis[u]+c[u][v];pre[v]=u;\n\t\t\t\tif(!vis[v])vis[v]=1,q.push(v);\n\t\t\t}\n\t\t}\n\t\treturn (dis[ed]<(LL)1e18);\n\t}\n\tpair<int,int> run(){\n\t\tint fw=0,res=0;\n\t\twhile(spfa()){\n\t\t\tfw++;res+=dis[ed];\n\t\t\tfor(int i=ed;i!=op;i=pre[i])\n\t\t\t\tw[pre[i]][i]--,w[i][pre[i]]++;\n\t\t}\n\t\treturn make_pair(fw,res);\n\t}\n}\nsigned main(){\n\tcin>>n;\n\tref(i,1,n)cin>>p[i].x>>p[i].y>>p[i].v;\n\tref(i,1,n)p[i].id=i;\n\tref(i,1,n)px[i]=p[i];\n\tref(i,1,n)py[i]=p[i];\n\tsort(px+1,px+n+1,cmpx);\n\tsort(py+1,py+n+1,cmpy);\n\tcin>>m;\n\tref(i,1,n)lx[0][i]=ly[0][i]=n+1;\n\tref(i,1,n)lx[1][i]=ly[1][i]=0;\n\tref(i,1,m){\n\t\tchar c;int a,b;cin>>c>>a>>b;\n\t\tif(c=='L'){\n\t\t\tint pos=0;\n\t\t\tref(j,1,n)if(px[j].x<=a)pos=j;\n\t\t\tif(pos>b)smin(lx[0][pos-b],pos);\n\t\t}\n\t\tif(c=='R'){\n\t\t\tint pos=n+1;\n\t\t\tdef(j,n,1)if(px[j].x>=a)pos=j;\n\t\t\tif(n+1-pos>b)smax(lx[1][n+1-pos-b],pos);\n\t\t}\n\t\tif(c=='D'){\n\t\t\tint pos=0;\n\t\t\tref(j,1,n)if(py[j].y<=a)pos=j;\n\t\t\tif(pos>b)smin(ly[0][pos-b],pos);\n\t\t}\n\t\tif(c=='U'){\n\t\t\tint pos=n+1;\n\t\t\tdef(j,n,1)if(py[j].y>=a)pos=j;\n\t\t\tif(n+1-pos>b)smax(ly[1][n+1-pos-b],pos);\n\t\t}\n\t}\n\tdef(i,n-1,1)smin(lx[0][i],lx[0][i+1]);\n\tdef(i,n-1,1)smin(ly[0][i],ly[0][i+1]);\n\tdef(i,n-1,1)smax(lx[1][i],lx[1][i+1]);\n\tdef(i,n-1,1)smax(ly[1][i],ly[1][i+1]);\n\tint ans=0,sum=0;\n\tref(i,1,n)ans+=p[i].v,sum+=p[i].v;\n\tref(S,0,n){\n\t\tif(S<n){\n\t\t\tif(lx[0][S+1]<=n||ly[0][S+1]<=n)continue;\n\t\t\tif(lx[1][S+1]>=1||ly[1][S+1]>=1)continue;\n\t\t}\n\t\tbool fg=1;\n\t\tref(i,1,S)if(lx[1][S+1-i]>lx[0][i]){fg=0;break;}\n\t\tref(i,1,S)if(ly[1][S+1-i]>ly[0][i]){fg=0;break;}\n\t\tif(!fg)continue;\n\t\teden::init();\n\t\teden::op=n+n+n+n+1;eden::ed=eden::op+1;\n\t\tref(i,1,S)ref(j,max(1LL,lx[1][S+1-i]),min(n,lx[0][i]))\n\t\t\teden::add(i,n+px[j].id,1,0);\n\t\tref(i,1,n)eden::add(n+i,n+n+i,1,p[i].v);\n\t\tref(i,1,S)ref(j,max(1LL,ly[1][S+1-i]),min(n,ly[0][i]))\n\t\t\teden::add(n+n+py[j].id,n+n+n+i,1,0);\n\t\tref(i,1,S)eden::add(eden::op,i,1,0);\n\t\tref(i,1,S)eden::add(n+n+n+i,eden::ed,1,0);\n\t\tpair<int,int> pp=eden::run();\n\t\tif(pp.fi==S)ans=min(ans,pp.se);\n\t}\n\tcout<<sum-ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "//Author:xht37\n#include <bits/stdc++.h>\n\n#define ui unsigned int\n#define ll long long\n#define ul unsigned ll\n#define ld long double\n\n#define pi pair <int, int>\n#define fi first\n#define se second\n#define mp make_pair\n\n#define ls (p << 1)\n#define rs (ls | 1)\n#define md ((t[p].l + t[p].r) >> 1)\n\n#define vi vector <int>\n#define pb push_back\n#define pq priority_queue\n\n#define dbg(x) cerr << #x\" = \" << x << endl\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#define fl(x) freopen(x\".in\", \"r\", stdin), freopen(x\".out\", \"w\", stdout)\n\nusing namespace std;\n\nnamespace io {\n\tconst int SI = 1 << 21 | 1;\n\tchar IB[SI], *IS, *IT, OB[SI], *OS = OB, *OT = OS + SI - 1, c, ch[100];\n\tint f, t;\n\t#define gc() (IS == IT ? (IT = (IS = IB) + fread(IB, 1, SI, stdin), IS == IT ? EOF : *IS++) : *IS++)\n\tinline void flush() {\n\t\tfwrite(OB, 1, OS - OB, stdout), OS = OB;\n\t}\n\tinline void pc(char x) {\n\t\t*OS++ = x;\n\t\tif (OS == OT) flush();\n\t}\n\n\ttemplate <class I>\n\tinline void rd(I &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + (c & 15), c = gc());\n\t\tx *= f;\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y) {\n\t\trd(x), rd(y);\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y, I &z) {\n\t\trd(x), rd(y), rd(z);\n\t}\n\ttemplate <class I>\n\tinline void rda(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) rd(a[i]);\n\t}\n\tinline void rdc(char &c) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t}\n\tinline void rds(char *s, int &n) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (n = 0; c >= 33 && c <= 126; s[++n] = c, c = gc());\n\t\ts[n+1] = '\\0';\n\t}\n\tinline void rds(string &s) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (s.clear(); c >= 33 && c <= 126; s.pb(c), c = gc());\n\t}\n\n\ttemplate <class I>\n\tinline void print(I x, char k = '\\n') {\n\t\tif (!x) pc('0');\n\t\tif (x < 0) pc('-'), x = -x;\n\t\twhile (x) ch[++t] = x % 10 + '0', x /= 10;\n\t\twhile (t) pc(ch[t--]);\n\t\tpc(k);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y) {\n\t\tprint(x, ' '), print(y);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y, I z) {\n\t\tprint(x, ' '), print(y, ' '), print(z);\n\t}\n\ttemplate <class I>\n\tinline void printa(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) print(a[i], \" \\n\"[i==n]);\n\t}\n\tinline void printc(char c) {\n\t\tpc(c);\n\t}\n\tinline void prints(char *s, int n) {\n\t\tfor (int i = 1; i <= n; i++) pc(s[i]);\n\t\tpc('\\n');\n\t}\n\tinline void prints(string s) {\n\t\tint n = s.length();\n\t\twhile (t < n) pc(s[t++]);\n\t\tpc('\\n'), t = 0;\n\t}\n\tstruct Flush {\n\t\t~Flush() {\n\t\t\tflush();\n\t\t}\n\t} flusher;\n}\nusing io::rd;\nusing io::rda;\nusing io::rdc;\nusing io::rds;\nusing io::print;\nusing io::printa;\nusing io::printc;\nusing io::prints;\n\nnamespace Dinic {\n\tconst int N = 1e5 + 7, M = 2e6 + 7;\n\tconst ll inf = 1e18;\n\tint n, S, T;\n\tint h[N], hi[N], e[M], t[M], tot;\n\tll d[N], f[M], c[M], mxf, ans;\n\tbool v[N];\n\n\tinline void add(int x, int y, ll z, ll w, bool o = 1) {\n\t\te[++tot] = y, f[tot] = z, c[tot] = w, t[tot] = h[x], h[x] = tot;\n\t\tif (o) add(y, x, 0, -w, 0);\n\t}\n\n\tinline bool bfs() {\n\t\tfor (int i = 1; i <= n; i++) d[i] = inf, v[i] = 0;\n\t\tqueue<int> q;\n\t\tq.push(S), d[S] = 0, v[S] = 1;\n\t\twhile (q.size()) {\n\t\t\tint x = q.front();\n\t\t\tq.pop(), v[x] = 0;\n\t\t\tfor (int i = h[x]; i; i = t[i]) {\n\t\t\t\tint y = e[i];\n\t\t\t\tll z = f[i], w = c[i];\n\t\t\t\tif (d[y] <= d[x] + w || !z) continue;\n\t\t\t\td[y] = d[x] + w;\n\t\t\t\tif (!v[y]) q.push(y), v[y] = 1;\n\t\t\t}\n\t\t}\n\t\treturn d[T] != inf;\n\t}\n\n\tll dfs(int x, ll now = inf) {\n\t\tif (x == T) return now;\n\t\tv[x] = 1;\n\t\tll rst = now;\n\t\tfor (int &i = hi[x]; i; i = t[i]) {\n\t\t\tint y = e[i];\n\t\t\tll z = f[i], w = c[i];\n\t\t\tif (v[y] || d[y] != d[x] + w || !z) continue;\n\t\t\tll k = dfs(y, min(z, rst));\n\t\t\tif (!k) d[y] = inf;\n\t\t\telse ans += k * w, f[i] -= k, f[i^1] += k, rst -= k;\n\t\t\tif (!rst) break;\n\t\t}\n\t\tv[x] = 0;\n\t\treturn now - rst;\n\t}\n\n\tinline void main() {\n\t\twhile (bfs()) {\n\t\t\tfor (int i = 1; i <= n; i++) hi[i] = h[i];\n\t\t\tll now;\n\t\t\twhile ((now = dfs(S))) mxf += now;\n\t\t}\n\t}\n\n\tinline void init(int _n, int _S, int _T) {\n\t\tn = _n, S = _S, T = _T, tot = 1, mxf = 0, ans = 0;\n\t\tfor (int i = 1; i <= n; i++) h[i] = 0; \n\t}\n}\nusing Dinic::add;\n\nconst int N = 87, M = 327;\nint n, m, x[N], y[N], a[M], b[M];\nchar t[M];\nll v[N], ans;\n\ninline bool in(int l, int x, int r) {\n\treturn l <= x && x <= r;\n}\n\ninline ll work(int k) {\n\tstatic int lx[N], rx[N], ly[N], ry[N];\n\tfor (int i = 1; i <= k; i++)\n\t\tlx[i] = ly[i] = 1, rx[i] = ry[i] = 100;\n\tfor (int i = 1; i <= m; i++)\n\t\tswitch (t[i]) {\n\t\t\tcase 'L' : {\n\t\t\t\tfor (int j = b[i] + 1; j <= k; j++)\n\t\t\t\t\tlx[j] = max(lx[j], a[i] + 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'R' : {\n\t\t\t\tfor (int j = 1; j <= k - b[i]; j++)\n\t\t\t\t\trx[j] = min(rx[j], a[i] - 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'D' : {\n\t\t\t\tfor (int j = b[i] + 1; j <= k; j++)\n\t\t\t\t\tly[j] = max(ly[j], a[i] + 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'U' : {\n\t\t\t\tfor (int j = 1; j <= k - b[i]; j++)\n\t\t\t\t\try[j] = min(ry[j], a[i] - 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tif (lx[i] > rx[i] || ly[i] > ry[i]) return 0;\n\tstatic int S, T, P[N], Q[N], X[N], Y[N], C;\n\tS = 1, T = 2, C = 2;\n\tfor (int i = 1; i <= n; i++) P[i] = ++C, Q[i] = ++C;\n\tfor (int i = 1; i <= k; i++) X[i] = ++C, Y[i] = ++C;\n\tDinic::init(C, S, T);\n\tfor (int i = 1; i <= n; i++) add(P[i], Q[i], 1, -v[i]);\n\tfor (int i = 1; i <= k; i++) {\n\t\tadd(S, X[i], 1, 0), add(Y[i], T, 1, 0);\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tif (in(lx[i], x[j], rx[i])) add(X[i], P[j], 1, 0);\n\t\t\tif (in(ly[i], y[j], ry[i])) add(Q[j], Y[i], 1, 0);\n\t\t}\n\t}\n\tDinic::main();\n\treturn Dinic::mxf == k ? -Dinic::ans : 0;\n}\n\nint main() {\n\trd(n);\n\tfor (int i = 1; i <= n; i++) rd(x[i], y[i]), rd(v[i]);\n\trd(m);\n\tfor (int i = 1; i <= m; i++) rdc(t[i]), rd(a[i], b[i]);\n\tfor (int k = 1; k <= n; k++) ans = max(ans, work(k));\n\tprint(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate <class T>\nistream& operator>>(istream& is, vector<T>& v) {\n  for (T& x : v)\n    is >> x;\n  return is;\n}\n\nostream& operator<<(ostream& os, const pair<char, int>& unit) {\n  return os << unit.first << \"^\" << unit.second;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n  if (!v.empty()) {\n    os << v.front();\n    for (int i = 1; i < v.size(); ++i)\n      os << ' ' << v[i];\n  }\n  return os;\n}\n\nnamespace Min25 {\n\n#define _rep(_1, _2, _3, _4, name, ...) name\n#define rep2(i, n) rep3(i, 0, n)\n#define rep3(i, a, b) rep4(i, a, b, 1)\n#define rep4(i, a, b, c) for (int i = int(a); i < int(b); i += int(c))\n#define rep(...) _rep(__VA_ARGS__, rep4, rep3, rep2, _)(__VA_ARGS__)\n\nusing namespace std;\n\nusing i64 = long long;\nusing u8 = unsigned char;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing f80 = long double;\n\ntemplate<\n    typename CapType, typename TotalCapType,\n    typename CostType, typename TotalCostType\n>\nclass CostScaling {\n private:\n  static const int alpha = 8; // eps <- max(1, eps / alpha)\n\n  using cap_t = CapType;\n  using tcap_t = TotalCapType;\n  using cost_t = CostType; // > max{|C|} * (2 * |V|)\n  using tcost_t = TotalCostType;\n  static constexpr cost_t Inf = (tcap_t(1) << (sizeof(tcap_t) * 8 - 2)) - 1;\n\n  struct InputEdge { int from, to; cap_t b, c; cost_t cost; };\n  struct Edge { int to, rev; cap_t cap; cost_t cost; };\n\n  class Dinic {\n   public:\n    Dinic(int N, const vector<int> &ofs, vector<Edge> &edges,\n          vector<tcap_t> &capacity)\n        : N(N), ofs(ofs), edges(edges), capacity(capacity), last(N) {}\n\n    bool succeeded() {\n      // s -> u: capacity[u]\n      // u -> t: capacity[u + N]\n      tcap_t f = 0;\n      for (int u = 0; u < N; ++u) f += capacity[u];\n      vector<int> que(N);\n      while (f) {\n        dist.assign(N, -1);\n        int qh = 0, qt = 0, lv = N;\n        for (int u = 0; u < N; ++u) if (capacity[u] > 0) que[qt++] = u, dist[u] = 0;\n        for (; qh < qt;) {\n          int u = que[qh++];\n          if (lv == N && capacity[u + N] > 0) lv = dist[u];\n          if (dist[u] > lv) break;\n          for (int ei = ofs[u]; ei < ofs[u + 1]; ++ei) {\n            int v = edges[ei].to;\n            if (edges[ei].cap > 0 && dist[v] == -1) {\n              que[qt++] = v, dist[v] = dist[u] + 1;\n            }\n          }\n        }\n        if (lv == N) break;\n        for (int u = 0; u < N; ++u) last[u] = ofs[u];\n        for (int u = 0; u < N; ++u)\n          if (capacity[u] > 0) {\n            auto df = block_flow(u, capacity[u]);\n            f -= df, capacity[u] -= df;\n          }\n      }\n      return f == 0;\n    }\n\n   private:\n    tcap_t block_flow(int u, tcap_t f) {\n      tcap_t ret = 0;\n      if (capacity[u + N] > 0) {\n        tcap_t df = min(f, capacity[u + N]);\n        capacity[u + N] -= df;\n        return df;\n      }\n      for (auto &ei = last[u]; ei < ofs[u + 1]; ++ei) {\n        auto &e = edges[ei];\n        int v = e.to;\n        if (e.cap == 0 || dist[v] <= dist[u]) continue;\n        cap_t df = block_flow(v, min<cap_t>(e.cap, f));\n        if (df == 0) continue;\n        e.cap -= df, edges[e.rev].cap += df;\n        f -= df, ret += df;\n        if (f == 0) break;\n      }\n      return ret;\n    }\n\n    int N;\n    const vector<int> &ofs;\n    vector<Edge> &edges;\n    vector<tcap_t> &capacity;\n    vector<int> last, dist;\n  };\n\n public:\n  CostScaling(int N, int M = 0) : N(N), capacity(2 * N) {\n    if (M > 0) in.reserve(M);\n  }\n\n  void add_directed_edge(int u, int v, cap_t b, cap_t c, cost_t cost) {\n    if (b > 0) capacity[v] += b, capacity[u + N] += b;\n    else capacity[u] += -b, capacity[v + N] += -b;\n    in.push_back({u, v, b, c, cost});\n  }\n\n  pair<bool, tcost_t> minimum_cost_circulation() {\n    construct();\n    if (!has_feasible_circulation()) return {false, 0};\n\n    const int cost_multiplier = 2 << __lg(N); // should be > |V|\n    cost_t eps = 0;\n    for (auto &e : edges) e.cost *= cost_multiplier, eps = max(eps, e.cost);\n\n    while (eps > 1) refine(eps = max<cost_t>(1, eps / alpha));\n\n    tcost_t ret = initial_cost;\n    for (auto &e : edges) ret -= (e.cost / cost_multiplier) * e.cap;\n    return {true, ret / 2};\n  }\n\n private:\n  void refine(const cost_t eps) {\n    auto cost_p = [&](int u, const Edge &e) {\n      return e.cost + potential[u] - potential[e.to];\n    };\n    for (int u = 0; u < N; ++u)\n      for (int i = ofs[u]; i < ofs[u + 1]; ++i) {\n        auto &e = edges[i];\n        if (cost_p(u, e) < 0) edges[e.rev].cap += e.cap, e.cap = 0;\n      }\n    vector<tcap_t> excess(initial_excess);\n    for (auto &e : edges) excess[e.to] -= e.cap;\n\n    vector<int> stack;\n    stack.reserve(N);\n    for (int u = 0; u < N; ++u) if (excess[u] > 0) stack.push_back(u);\n\n    auto residue = [&](const Edge &e) -> cap_t { return e.cap; };\n    auto push = [&](int u, Edge &e, cap_t df) {\n      e.cap -= df;\n      edges[e.rev].cap += df;\n      excess[e.to] += df;\n      excess[u] -= df;\n      if (excess[e.to] > 0 && excess[e.to] <= df) {\n        stack.push_back(e.to);\n      }\n    };\n    auto relabel = [&](int u, cost_t delta) {\n      potential[u] -= delta + eps;\n    };\n    auto relabel_in_advance = [&](int u) {\n      if (excess[u] != 0) return false;\n      auto delta = Inf;\n      for (int ei = ofs[u]; ei < ofs[u + 1]; ++ei) {\n        auto &e = edges[ei];\n        if (residue(e) == 0) continue;\n        if (cost_p(u, e) < 0) return false;\n        else delta = min<tcost_t>(delta, cost_p(u, e));\n      }\n      relabel(u, delta);\n      return true;\n    };\n    auto discharge = [&](int u) {\n      auto delta = Inf;\n      for (int ei = ofs[u]; ei < ofs[u + 1]; ++ei) {\n        auto &e = edges[ei];\n        if (residue(e) == 0) continue;\n        if (cost_p(u, e) < 0) {\n          if (relabel_in_advance(e.to)) {\n            --ei;\n            continue; // modify ei (!)\n          }\n          cap_t df = min<tcap_t>(excess[u], residue(e));\n          push(u, e, df);\n          if (!excess[u]) return;\n        } else delta = min<tcost_t>(delta, cost_p(u, e));\n      }\n      relabel(u, delta);\n      stack.push_back(u);\n    };\n    while (!stack.empty()) {\n      auto u = stack.back();\n      stack.pop_back();\n      discharge(u);\n    }\n  }\n\n  void construct() {\n    ofs.assign(N + 1, 0);\n    edges.resize(2 * in.size());\n    initial_excess.assign(N, 0);\n    initial_cost = 0;\n    potential.assign(N, 0);\n    for (auto &e : in) ofs[e.from + 1]++, ofs[e.to + 1]++;\n    for (int i = 1; i <= N; ++i) ofs[i] += ofs[i - 1];\n    for (auto &e : in) {\n      initial_excess[e.to] += e.c;\n      initial_excess[e.from] += -e.b;\n      initial_cost += tcost_t(e.cost) * (e.c + e.b);\n      edges[ofs[e.from]++] = {e.to, ofs[e.to], e.c - e.b, e.cost};\n      edges[ofs[e.to]++] = {e.from, ofs[e.from] - 1, 0, -e.cost};\n    }\n    for (int i = N; i > 0; --i) ofs[i] = ofs[i - 1];\n    ofs[0] = 0;\n  }\n\n  bool has_feasible_circulation() {\n    return Dinic(N, ofs, edges, capacity).succeeded();\n  }\n\n private:\n  int N;\n  vector<InputEdge> in;\n  vector<tcap_t> capacity;\n\n  vector<int> ofs;\n  vector<Edge> edges;\n\n  tcost_t initial_cost;\n  vector<tcap_t> initial_excess;\n  vector<tcost_t> potential;\n};\n\nusing MCC = CostScaling<int64_t, int64_t, int64_t, int64_t>;\n\n}\n\n#undef _rep\n#undef rep\n#undef rep2\n#undef rep3\n#undef rep4\n\nstruct MinCostMaxFlow {\n  Min25::MCC mcc1, mcc2;\n\n  MinCostMaxFlow(int n, int m) : mcc1(n, m), mcc2(n, m) {}\n\n  void addEdge(int u, int v, ll w) {\n    mcc1.add_directed_edge(u, v, 0, 1, 0);\n    mcc2.add_directed_edge(u, v, 0, 1, w);\n  }\n\n  pair<int, ll> mcmf() {\n    mcc1.add_directed_edge(1, 0, 0, 1e18, -1);\n    auto maxFlow = -mcc1.minimum_cost_circulation().second;\n    mcc2.add_directed_edge(1, 0, maxFlow, maxFlow, 0);\n    return make_pair(maxFlow, mcc2.minimum_cost_circulation().second);\n  }\n};\n\ntemplate <class T>\nvoid chkMax(T& x, const T& y) {\n  if (y > x) x = y;\n}\n\ntemplate <class T>\nvoid chkMin(T& x, const T& y) {\n  if (y < x) x = y;\n}\n\nconst int N = 85, M = N * 4;\n\nint n;\nint x[N], y[N]; ll v[N];\nint m;\nchar t[M]; int a[M], b[M];\n\nint l[N], r[N], d[N], u[N];\n\nint main() {\n#ifdef LBT\n  freopen(\"test.in\", \"r\", stdin);\n  int nol_cl = clock();\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  cin >> n;\n  for (int i = 1; i <= n; ++i)\n    cin >> x[i] >> y[i] >> v[i];\n  cin >> m;\n  for (int i = 1; i <= m; ++i)\n    cin >> t[i] >> a[i] >> b[i];\n\n  ll ans = 0;\n  for (int k = 1; k <= n; ++k) {\n    fill(l + 1, l + k + 1, 1);\n    fill(r + 1, r + k + 1, 100);\n    fill(d + 1, d + k + 1, 1);\n    fill(u + 1, u + k + 1, 100);\n    for (int i = 1; i <= m; ++i) {\n      if (b[i] >= k) continue;\n      if (t[i] == 'L')\n        chkMax(l[b[i] + 1], a[i] + 1);\n      else if (t[i] == 'R')\n        chkMin(r[k - b[i]], a[i] - 1);\n      else if (t[i] == 'D')\n        chkMax(d[b[i] + 1], a[i] + 1);\n      else\n        chkMin(u[k - b[i]], a[i] - 1);\n    }\n    for (int i = 2; i <= k; ++i) chkMax(l[i], l[i - 1]);\n    for (int i = 2; i <= k; ++i) chkMax(d[i], d[i - 1]);\n    for (int i = k - 1; i; --i) chkMin(r[i], r[i + 1]);\n    for (int i = k - 1; i; --i) chkMin(u[i], u[i + 1]);\n    int S = 0, T = 1; // 2 + N * 2 + K * 2\n    // k * 2 + n +\n    MinCostMaxFlow mcmf(n * 2 + k * 2 + 2, n + k * 2 + n * k * 2);\n    for (int i = 1; i <= n; ++i)\n      mcmf.addEdge(i * 2, i * 2 + 1, (ll)1e15 - v[i]);\n    // max : n * 2 + 1, n * 2 + i\n    // cerr << n *2 + 1 << ' ';\n    for (int i = 1; i <= k; ++i) {\n      mcmf.addEdge(S, n * 2 + 1 + i, 0);\n      mcmf.addEdge(n * 2 + k + 1 + i, T, 0);\n      for (int j = 1; j <= n; ++j) {\n        if (l[i] <= x[j] && x[j] <= r[i])\n          mcmf.addEdge(n * 2 + 1 + i, j * 2, 0);\n        if (d[i] <= y[j] && y[j] <= u[i])\n          mcmf.addEdge(j * 2 + 1, n * 2 + k + 1 + i, 0);\n      }\n    }\n    auto val = mcmf.mcmf();\n    // cerr << val.first << ' ' << k << ' ' << val.second << '\\n';\n    if (val.first == k) chkMax(ans, ll(k * (ll)1e15 - val.second));\n  }\n  cout << ans << '\\n';\n\n#ifdef LBT\n  LOG(\"Time: %dms\\n\", int ((clock()\n      -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n#define MP make_pair\n#define PB push_back\n#define int long long\n#define st first\n#define nd second\n#define rd third\n#define FOR(i, a, b) for(int i =(a); i <=(b); ++i)\n#define RE(i, n) FOR(i, 1, n)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define REP(i, n) for(int i = 0;i <(n); ++i)\n#define VAR(v, i) __typeof(i) v=(i)\n#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define __builtin_ctz __builtin_ctzll\n#define __builtin_clz __builtin_clzll\n#define __builtin_popcount __builtin_popcountll\nusing namespace std;\ntemplate<typename TH> void _dbg(const char* sdbg, TH h) { cerr<<sdbg<<\"=\"<<h<<\"\\n\"; }\ntemplate<typename TH, typename... TA> void _dbg(const char* sdbg, TH h, TA... t) {\n  while(*sdbg != ',') { cerr<<*sdbg++; } cerr<<\"=\"<<h<<\",\"; _dbg(sdbg+1, t...);\n}\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#define debugv(x) {{cerr <<#x <<\" = \"; FORE(itt, (x)) cerr <<*itt <<\", \"; cerr <<\"\\n\"; }}\n#else\n#define debug(...) (__VA_ARGS__)\n#define debugv(x)\n#define cerr if(0)cout\n#endif\n#define next ____next\n#define prev ____prev\n#define left ____left\n#define hash ____hash\ntypedef long long ll;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\ntypedef vector<pair<int, int> > VPII;\ntypedef vector<pair<ll, ll> > VPLL;\n\ntemplate<class C> void mini(C&a4, C b4){a4=min(a4, b4); }\ntemplate<class C> void maxi(C&a4, C b4){a4=max(a4, b4); }\ntemplate<class T1, class T2>\nostream& operator<< (ostream &out, pair<T1, T2> pair) { return out << \"(\" << pair.first << \", \" << pair.second << \")\";}\ntemplate<class A, class B, class C> struct Triple { A first; B second; C third;\n  bool operator<(const Triple& t) const { if (st != t.st) return st < t.st; if (nd != t.nd) return nd < t.nd; return rd < t.rd; } };\ntemplate<class T> void ResizeVec(T&, vector<int>) {}\ntemplate<class T> void ResizeVec(vector<T>& vec, vector<int> sz) {\n  vec.resize(sz[0]); sz.erase(sz.begin()); if (sz.empty()) { return; }\n  for (T& v : vec) { ResizeVec(v, sz); }\n}\ntypedef Triple<int, int, int> TIII;\ntemplate<class A, class B, class C>\nostream& operator<< (ostream &out, Triple<A, B, C> t) { return out << \"(\" << t.st << \", \" << t.nd << \", \" << t.rd << \")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, vector<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, set<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class L, class R> ostream& operator<<(ostream& out, map<L, R> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\n\nstruct Simplex {        // Maximize c*x subject to Ax <= b.\n  using T = LD;     // Initialize the structure, set A, b, c and then run\n  vector<vector<T>> A;  // solve(). Max objective is stored in res. To recover\n  vector<T> b, c;       // the best result, use getVars().\n  \n  int V, E;\n  VI eqIds, varIds, cols;\n  T res;\n  const T kEps = 1e-9;\n  \n  Simplex(int vars, int eqs) : A(eqs, vector<T>(vars)), b(eqs), c(vars),\n  V(vars), E(eqs), eqIds(eqs), varIds(vars), res(0) {\n    iota(ALL(varIds), 0); iota(ALL(eqIds), vars);\n  }\n  \n  void pivot(int eq, int var) {\n    T coef = 1 / A[eq][var];\n    cols.clear();\n    REP (i, V) {\n      if (abs(A[eq][i]) > kEps) { cols.PB(i); A[eq][i] *= coef; }\n    }\n    A[eq][var] *= coef; b[eq] *= coef;\n    REP (row, E) {\n      if (row == eq || abs(A[row][var]) < kEps) { continue; }\n      T k = -A[row][var];\n      A[row][var] = 0;\n      for (int i : cols) { A[row][i] += k * A[eq][i]; }\n      b[row] += k * b[eq];\n    }\n    T q = c[var]; c[var] = 0;\n    for (int i : cols) { c[i] -= q * A[eq][i]; }\n    res += q * b[eq];\n    \n    swap(varIds[var], eqIds[eq]);\n  }\n  \n  bool solve() {\n    while (true) {\n      int eq = -1, var = -1;\n      REP (i, E) { if (b[i] < -kEps) { eq = i; break; } }\n      if (eq == -1) { break; }\n      REP (i, V) { if (A[eq][i] < -kEps) { var = i; break; } }\n      if (var == -1) { res = -1e9; return false; /* No solution */ }\n      pivot(eq, var);\n    }\n    \n    while (true) {\n      int var = -1, eq = -1;\n      REP (i, V) { if (c[i] > kEps) { var = i; break; } }\n      if (var == -1) { break; }\n      REP (i, E) {\n        if (A[i][var] < kEps) { continue; }\n        if (eq >= 0 && b[i] / A[i][var] >= b[eq] / A[eq][var]) { continue; }\n        eq = i;\n      }\n      if (eq == -1) { res = 1e9; return false; /* Unbounded */ }\n      pivot(eq, var);\n    }\n    \n    return true;\n  }\n  \n  vector<T> getVars() {  // Optimal assignment of variables.\n    vector<T> result(V);\n    REP (i, E) { if (eqIds[i] < V) { result[eqIds[i]] = b[i]; } }\n    return result;\n  }\n};\n\n\nconst int N = 333;\nint x[N];\nint y[N];\nint v[N];\n\nint32_t main() {\n\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(10);\n  cerr << fixed << setprecision(10);\n  cin.tie(0);\n  //double beg_clock = 1.0 * clock() / CLOCKS_PER_SEC;\n  \n  int n;\n  cin>>n;\n  REP (i, n) {\n    cin>>x[i]>>y[i]>>v[i];\n    //sim.c.PB(v[i]);\n  }\n  int m;\n  cin>>m;\n  \n  Simplex sim(n, m + 2 * n);\n  REP (i, n) {\n    sim.c[i] = v[i];\n  }\n  REP (j, m) {\n    char t;\n    cin>>t;\n    int a, b;\n    cin>>a>>b;\n    sim.b[j]= b;\n    vector<LD> A;\n    REP (i, n) {\n      if ((t == 'L' && x[i] <= a) || (t == 'R' && x[i] >= a) || (t == 'U' && y[i] >= a) || (t == 'D' && y[i] <= a)) {\n        A.PB(1);\n      } else {\n        A.PB(0);\n      }\n    }\n    sim.A[j] = A;\n  }\n  REP (i, n) {\n    sim.b[m + 2 * i] = 1;\n    sim.b[m + 2 * i + 1] = 0;\n    sim.A[m + 2 * i][i] = 1;\n    sim.A[m + 2 * i + 1][i] = -1;\n  }\n  sim.solve();\n  debug(sim.res);\n  cout<<(int)(round(sim.res))<<endl;\n  return 0;\n  vector<LD> vars = sim.getVars();\n  debug(vars);\n  int R = 0;\n  REP (i, n) {\n    assert(vars[i] < 0.001 || vars[i] > 0.999);\n    if (vars[i] > 0.5) {\n      R += v[i];\n    }\n  }\n  cout<<R<<endl;\n    \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <list>\n#include <time.h>\n#include <math.h>\n#include <random>\n#include <deque>\n#include <queue>\n#include <cassert>\n#include <unordered_map>\n#include <unordered_set>\n#include <iomanip>\n#include <bitset>\n#include <sstream>\n#include <chrono>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef long double dbl;\nconst int INF = 1.01e9;\n \nconst long double EPS = 1e-18;\nbool eq(long double x, long double y) {\n    return fabs(x - y) < EPS;\n}\nbool ls(long double x, long double y) {\n    return x < y && !eq(x, y);\n}\n \nvector<long double> simplex(vector<vector<long double> > a) {\n    int n = a.size() - 1;\n    int m = a[0].size() - 1;\n    vector<int> left(n + 1), up(m + 1);\n    iota(up.begin(), up.end(), 0);\n    iota(left.begin(), left.end(), m);\n    auto pivot = [&](int x, int y) {\n        swap(left[x], up[y]);\n        long double k = a[x][y];\n        a[x][y] = 1;\n        vector<int> vct;\n        for (int j = 0; j <= m; j++) {\n            a[x][j] /= k;\n            if (!eq(a[x][j], 0)) vct.push_back(j);\n        }\n        for (int i = 0; i <= n; i++) {\n            if (eq(a[i][y], 0) || i == x) continue;\n            k = a[i][y];\n            a[i][y] = 0;\n            for (int j : vct) a[i][j] -= k * a[x][j];\n        }\n    };\n    while (1) {\n        int x = -1;\n        for (int i = 1; i <= n; i++) if (ls(a[i][0], 0) && (x == -1 || a[i][0] < a[x][0])) x = i;\n        if (x == -1) break;\n        int y = -1;\n        for (int j = 1; j <= m; j++) if (ls(a[x][j], 0) && (y == -1 || a[x][j] < a[x][y])) y = j;\n        if (y == -1) assert(0); // infeasible\n        pivot(x, y);\n    }\n    while (1) {\n        int y = -1;\n        for (int j = 1; j <= m; j++) if (ls(0, a[0][j]) && (y == -1 || a[0][j] > a[0][y])) y = j;\n        if (y == -1) break;\n        int x = -1;\n        for (int i = 1; i <= n; i++) if (ls(0, a[i][y]) && (x == -1 || a[i][0] / a[i][y] < a[x][0] / a[x][y])) x = i;\n        if (x == -1) assert(0); // unbounded\n        pivot(x, y);\n    }\n    vector<long double> ans(m + 1);\n    for (int i = 1; i <= n; i++) if (left[i] <= m) ans[left[i]] = a[i][0];\n    ans[0] = -a[0][0];\n    return ans;\n}\n\n#ifdef ONPC\n  mt19937 rnd(228);\n#else\n  mt19937 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\n#endif\n\nint main()\n{\n#ifdef ONPC\n  freopen(\"a.in\", \"r\", stdin);\n#endif\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector <int> x(n), y(n);\n  vector <ll> ok;\n  vector <long double> v;\n  vector <pair <ll, int> > e;\n  for (int i = 0; i < n; i++)\n  {\n    cin >> x[i] >> y[i];\n    ll x;\n    cin >> x;\n    ok.push_back(x);\n    v.push_back(x);\n    e.push_back({x, i});\n  }\n  v.insert(v.begin(), 0);\n  int m;\n  cin >> m;\n  vector <vector <long double> > mat;\n  mat.push_back(v);\n  for (int i = 0; i < n; i++)\n  {\n    vector <long double> kek(n + 1);\n    kek[0] = kek[i + 1] = 1;\n    mat.push_back(kek);\n  }\n  vector <vector <int> > simp;\n  for (int i = 0; i < m; i++)\n  {\n    char c;\n    cin >> c;\n    int a;\n    int b;\n    cin >> a >> b;\n    vector <long double> arr = {(long double) b};\n    vector <int> kek = {b};\n    for (int j = 0; j < n; j++)\n    {\n      int grab = 0;\n      if (c == 'L' && x[j] <= a) grab = 1;\n      if (c == 'R' && x[j] >= a) grab = 1;\n      if (c == 'D' && y[j] <= a) grab = 1;\n      if (c == 'U' && y[j] >= a) grab = 1;\n      arr.push_back(grab);\n      kek.push_back(grab);\n    }\n    mat.push_back(arr);\n    simp.push_back(kek);\n  }\n  auto good = [&] (vector <int> grab)\n  {\n    for (auto c : simp)\n    {\n      int sum = 0;\n      for (int i = 1; i <= n; i++) sum += grab[i - 1] * c[i];\n      if (sum > c[0])\n      {\n        return false;\n      }\n    }\n    return true;\n  };\n  auto f = [&] (vector <int> grab)\n  {\n    ll sum = 0;\n    for (int i = 0; i < n; i++)\n    {\n      if (grab[i]) sum += ok[i];\n    }\n    return sum;\n  };\n  vector <int> grab;\n  for (int i = 0; i < n; i++) grab.push_back(0);\n  cout.precision(20);\n  auto solve = [&] ()\n  {\n    auto ret = simplex(mat);\n    long double ans = 0;\n    for (int i = 1; i <= n; i++) ans += ret[i] * ok[i - 1];\n    cout << (long long) (ans + 0.5) << endl;\n    exit(0);\n    sort(e.begin(), e.end());\n    vector <int> me(n);\n    int kek = 0;\n    for (int i = (int) e.size() - 1; i >= 0; i--)\n    {\n      if (!grab[e[i].second] && ret[e[i].second + 1] > EPS)\n      {\n        kek++;\n        me[e[i].second] = true;\n        grab[e[i].second] = true;\n        if (!good(grab)) grab[e[i].second] = false, me[e[i].second] = false;\n      }\n    }\n    int kekos = 0;\n    for (auto &c : mat)\n    {\n      kekos++;\n      if (kekos > n + 1)\n      for (int i = 1; i <= n; i++)\n      {\n        if (me[i - 1] && c[i] > EPS) c[i]--, c[0]--;\n      }\n    }\n    for (int i = 1; i <= n; i++)\n    {\n      if (me[i - 1])\n      {\n        mat[i][0] = 0;\n      }\n    }\n    return kek;\n  };\n  while (solve());\n  bool ch = true;\n  while (ch)\n  {\n    ch = false;\n    for (int i = (int) e.size() - 1; i >= 0; i--)\n    {\n      if (!grab[e[i].second])\n      {\n        grab[e[i].second] = true;\n        if (good(grab))\n        {\n          ch = true;\n        }\n        else\n        {\n          grab[e[i].second] = false;\n        }\n      }\n    }\n    if (!ch)\n    {\n      for (int i = 0; i < (int) e.size(); i++)\n      {\n        for (int j = i + 1; j < (int) e.size(); j++)\n        {\n          for (int k = j + 1; k < (int) e.size(); k++)\n          {\n            if (e[i].first + e[j].first < e[k].first && grab[e[i].second] && grab[e[j].second] && !grab[e[k].second])\n            {\n              auto x = grab;\n              x[e[i].second] = x[e[j].second] = 0;\n              x[e[k].second] = 1;\n              if (good(x))\n              {\n                grab = x;\n                ch = true;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  ll best = f(grab);\n  cout << best << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 505\n#define inf 1000000007\nusing namespace std;\ntypedef long long ll;\nll read()\n{\n    ll x=0,f=1;\n    char ch=getchar();\n    while(ch-'0'<0||ch-'0'>9){if(ch=='-') f=-1;ch=getchar();}\n    while(ch-'0'>=0&&ch-'0'<=9){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nint n,m,s,t;\nstruct P{\n    int x,y;\n    ll v;\n}p[85];\nstruct X{\n    char d;\n    int a,b;\n}co[325];\nint Lx[85],Rx[85],Ly[85],Ry[85];\nint head[325],nxt[140010],to[140010],c[140010],tot;\nll v[140010];\nvoid add(int x,int y,int z,ll u)\n{\n    tot++;\n    nxt[tot]=head[x];\n    head[x]=tot;\n    to[tot]=y;\n    c[tot]=z;\n    v[tot]=u;\n}\nvoid addx(int x,int y,int z,ll u)\n{\n    add(x,y,z,u);\n    add(y,x,0,-u);\n}\nll ans,res,dis[325];\nint vis[325],pre[325],pre_num[325];\nqueue<int>q;\nint spfa()\n{\n    for(int i=1;i<=t;i++)  dis[i]=-1e18;\n    dis[s]=0;q.push(s);vis[s]=1;\n    while(q.size())\n    {\n        int now=q.front();q.pop();vis[now]=0;\n        for(int i=head[now];i;i=nxt[i])\n        {\n            if(dis[to[i]]<dis[now]+v[i]&&c[i])\n            {\n                dis[to[i]]=dis[now]+v[i];\n                pre[to[i]]=now;\n                pre_num[to[i]]=i;\n                if(!vis[to[i]])  q.push(to[i]),vis[to[i]]=1;\n            }\n        }\n    }\n    if(dis[t]==-1e18)  return 0;\n    int di=inf;\n    for(int i=t;i!=s;i=pre[i])  di=min(di,c[pre_num[i]]);\n    for(int i=t;i!=s;i=pre[i])  c[pre_num[i]]-=di,c[pre_num[i]^1]+=di;\n    ans+=dis[t]*di;\n    return di;\n}\nint main()\n{\n    n=read();\n    for(int i=1;i<=n;i++)  p[i].x=read(),p[i].y=read(),p[i].v=read();\n    m=read();\n    for(int i=1;i<=m;i++)  co[i].d=getchar(),co[i].a=read(),co[i].b=read();\n    for(int k=1;k<=n;k++)\n    {\n        tot=1;memset(head,0,sizeof(head));\n        s=2*k+2*n+1;t=s+1;\n        for(int i=1;i<=k;i++)  addx(s,i,1,0);\n        for(int i=k+2*n+1;i<=2*n+2*k;i++)  addx(i,t,1,0);\n        for(int i=k+1;i<=k+n;i++)  addx(i,i+n,1,p[i-k].v);\n        for(int i=1;i<=k;i++)  Lx[i]=Ly[i]=0,Rx[i]=Ry[i]=inf;\n        for(int i=1;i<=m;i++)\n        {\n            if(co[i].d=='U')\n            {\n                for(int j=1;j<=k-co[i].b;j++)  Ry[j]=min(Ry[j],co[i].a-1);\n            }\n            if(co[i].d=='D')\n            {\n                for(int j=co[i].b+1;j<=k;j++)  Ly[j]=max(Ly[j],co[i].a+1);\n            }\n            if(co[i].d=='L')\n            {\n                for(int j=co[i].b+1;j<=k;j++)  Lx[j]=max(Lx[j],co[i].a+1);\n            }\n            if(co[i].d=='R')\n            {\n                for(int j=1;j<=k-co[i].b;j++)  Rx[j]=min(Rx[j],co[i].a-1);\n            }\n        }\n        for(int i=1;i<=k;i++)\n          for(int j=1;j<=n;j++)\n            if(Lx[i]<=p[j].x&&p[j].x<=Rx[i])  addx(i,k+j,1,0);\n        for(int i=1;i<=k;i++)\n          for(int j=1;j<=n;j++)\n            if(Ly[i]<=p[j].y&&p[j].y<=Ry[i])  addx(k+n+j,k+2*n+i,1,0);\n        ans=0;\n        while(spfa()){};\n        res=max(res,ans);   \n    }\n    cout<<res<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=505,M=50005,R=100;\nconst ll inf=0x3f3f3f3f3f3f3f3fll;\nint read(){\n\tint f=1,g=0;\n\tchar ch=getchar();\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-') f=-1;\n\tfor (;isdigit(ch);ch=getchar()) g=g*10+ch-'0';\n\treturn f*g;\n}\nvoid chkmax(int &x,int y){if (x<y) x=y;}\nvoid chkmin(int &x,int y){if (x>y) x=y;}\nint n,m;\nstruct jew{int x,y;ll w;}a[N];\nstruct node{char typ;int x,r;}b[N];\nll cost,ans;\nint S,T,cnt,fir[N],fr[N],siz;\nstruct edge{int u,v;ll w;int fl,nex;}e[M];\nvoid add(int u,int v,ll w,int fl){\n\te[++siz]=(edge){u,v,w,fl,fir[u]};fir[u]=siz;\n\te[++siz]=(edge){v,u,-w,0,fir[v]};fir[v]=siz;\n}\nll dist[N];int que[N*50];bool inq[N];\nvoid dec(int x,int fl){e[x].fl-=fl;e[x^1].fl+=fl;}\nbool spfa(){\n\tmemset(dist,-1,8*(cnt+1));\n\tmemset(inq,0,cnt+1);\n\tint l=1,r=1;que[l]=S;dist[S]=0;inq[S]=1;\n\twhile (l<=r){\n\t\tint x=que[l];\n\t\tfor (int i=fir[x];i;i=e[i].nex)\n\t\tif ((e[i].fl)&&(dist[e[i].v]<dist[x]+e[i].w)){\n\t\t\tif (!inq[e[i].v]) {que[++r]=e[i].v;inq[e[i].v]=1;}\n\t\t\tdist[e[i].v]=dist[x]+e[i].w;fr[e[i].v]=i;\n\t\t}\n\t\tinq[x]=0;l++;\n\t}\n\treturn dist[T]>0;\n}\nint update(){\n\tint t=0x3f3f3f3f;\n\tfor (int i=fr[T];i;i=fr[e[i].u]) t=min(t,e[i].fl);\n\tcost+=t*dist[T];\n\tfor (int i=fr[T];i;i=fr[e[i].u]) dec(i,t);\n\treturn t;\n}\nint dinic(){\n\tint flow=0;\n\twhile (spfa()) flow+=update();\n\treturn flow;\n}\nint ml[N],mr[N],mu[N],md[N];\nvoid calc(int L){\n\tmemset(fir,0,sizeof(fir));siz=1;\n\tS=0;T=cnt=L*2+R*2+1;\n\tfor (int i=1;i<=n;i++) add(a[i].x,a[i].y+R,a[i].w,1);\n\tfor (int i=1;i<=L;i++) {ml[i]=mu[i]=1,mr[i]=md[i]=R;add(S,R*2+i,0,1);add(R*2+L+i,T,0,1);}\n\tfor (int i=1;i<=m;i++)\n\tif (b[i].r>=L) continue;\n\telse if (b[i].typ=='L') chkmax(ml[b[i].r+1],b[i].x+1);\n\telse if (b[i].typ=='R') chkmin(mr[L-b[i].r],b[i].x-1);\n\telse if (b[i].typ=='D') chkmax(mu[b[i].r+1],b[i].x+1);\n\telse if (b[i].typ=='U') chkmin(md[L-b[i].r],b[i].x-1);\n\tfor (int i=2;i<=L;i++) chkmax(ml[i],ml[i-1]),chkmax(mu[i],mu[i-1]);\n\tfor (int i=L-1;i;i--)  chkmin(md[i],md[i+1]),chkmin(md[i],md[i+1]);\n\tfor (int i=1;i<=L;i++){\n\t\tfor (int j=ml[i];j<=mr[i];j++) add(R*2+i,j,0,1);\n\t\tfor (int j=mu[i];j<=md[i];j++) add(j+R,R*2+L+i,0,1);\n\t}\n\tcost=0;\n\tif (dinic()==L) ans=max(ans,cost);\n//\tfor (int i=1;i<=n;i++) if (!e[i*2].fl) printf(\"%d \",i);\n//\tprintf(\"\\n\");\n}\nint main(){\n\tn=read();\n\tfor (int i=1;i<=n;i++) scanf(\" %d %d %lld\",&a[i].x,&a[i].y,&a[i].w);\n\tm=read();\n\tfor (int i=1;i<=m;i++) scanf(\" %c %d %d\",&b[i].typ,&b[i].x,&b[i].r);\n\tfor (int i=1;i<=n;i++) calc(i);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace __gnu_pbds;\nusing namespace std;\n \ntemplate <typename T>\nusing ordered_set =\n\ttree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n \n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n\t*this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n \n#define shandom_ruffle random_shuffle\n \nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=327;\nusing bn=bitset<87>;\nusing ld=long double;\n\nint n;\npii gdz[nax];\nll war[nax];\n\nint m;\nbn podz[nax];\nint ile[nax];\n\nll wyn;\n\nbn ter;\n \nll dajwar()\n{\n\tll ret=0;\n\tfor (int i=1; i<=n; i++)\n\t\tif (ter[i])\n\t\t\tret+=war[i];\n\treturn ret;\n}\n \nint popr()\n{\n\tfor (int i=1; i<=m; i++)\n\t\tif ((podz[i]&ter).count()>ile[i])\n\t\t\treturn 0;\n\treturn 1;\n}\n\nvi kol;\n\nstruct Simplex {        // Maximize c*x subject to Ax <= b.\n  using T = ld;     // Initialize the structure, set A, b, c and then run\n  vector<vector<T>> A;  // solve(). Max objective is stored in res. To recover\n  vector<T> b, c;       // the best result, use getVars().\n  int V, E;\n  vector<int> eqIds, varIds, cols;\n  T res;\n  static constexpr T kEps = 1e-17;\n\n  Simplex(int vars, int eqs) : A(eqs, vector<T>(vars)), b(eqs), c(vars),\n      V(vars), E(eqs), eqIds(eqs), varIds(vars), res(0) {\n    iota(varIds.begin(), varIds.end(), 0);\n    iota(eqIds.begin(), eqIds.end(), vars);\n  }\n\n  void pivot(int eq, int var) {\n    T coef = 1 / A[eq][var];\n    cols.clear();\n    for (int i = 0; i < V; i++) {\n      if (abs(A[eq][i]) > kEps) { cols.push_back(i); A[eq][i] *= coef; }\n    }\n    A[eq][var] *= coef; b[eq] *= coef;\n    for (int row = 0; row < E; row++) {\n      if (row == eq || abs(A[row][var]) < kEps) { continue; }\n      T k = -A[row][var];\n      A[row][var] = 0;\n      for (int i : cols) { A[row][i] += k * A[eq][i]; }\n      b[row] += k * b[eq];\n    }\n    T q = c[var]; c[var] = 0;\n    for (int i : cols) { c[i] -= q * A[eq][i]; }\n    res += q * b[eq];\n    swap(varIds[var], eqIds[eq]);\n  }\n\n  bool solve() {\n    while (true) {\n      int eq = -1, var = -1;\n      for (int i = 0; i < E; i++) { if (b[i] < -kEps) { eq = i; break; } }\n      if (eq == -1) { break; }\n      for (int i = 0; i < V; i++) { if (A[eq][i] < -kEps) { var = i; break; } }\n      if (var == -1) { res = -1e9; return false; /* No solution */ }\n      pivot(eq, var);\n    }\n    while (true) {\n      int var = -1, eq = -1;\n      for (int i = 0; i < V; i++) { if (c[i] > kEps) { var = i; break; } }\n      if (var == -1) { break; }\n      for (int i = 0; i < E; i++) {\n        if (A[i][var] < kEps) { continue; }\n        if (eq >= 0 && b[i] / A[i][var] >= b[eq] / A[eq][var]) { continue; }\n        eq = i;\n      }\n      if (eq == -1) { res = 1e9; return false; /* Unbounded */ }\n      pivot(eq, var);\n    }\n    return true;\n  }\n\n  vector<T> getVars() { // Optimal assignment of variables.\n    vector<T> result(V);\n    for (int i = 0; i < E; i++) if (eqIds[i] < V) result[eqIds[i]] = b[i];\n    return result;\n  }\n};\n\nvoid zmien(ld v)\n{\n\tv*=(9+(rand()%3))/10.0;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(\"%d%d%lld\", &gdz[i].first, &gdz[i].second, &war[i]);\n\tscanf(\"%d\", &m);\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\tchar c;\n\t\tint a, b;\n\t\tscanf(\" %c%d%d\", &c, &a, &b);\n\t\tfor (int j=1; j<=n; j++)\n\t\t{\n\t\t\tif (c=='L' && gdz[j].first<=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='R' && gdz[j].first>=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='D' && gdz[j].second<=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='U' && gdz[j].second>=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t}\n\t\tile[i]=b;\n\t}\n\tfor (int h=0; h<1000; h++)\n\t{\n\t\tSimplex janusz(n, m+2*n);\n\t\tfor (int i=0; i<n; i++)\n\t\t{\n\t\t\tjanusz.c[i]=war[i+1];\n\t\t\tif (h)\n\t\t\t\tzmien(janusz.c[i]);\n\t\t}\n\t\tfor (int i=0; i<m; i++)\n\t\t{\n\t\t\tjanusz.b[i]=ile[i+1];\n\t\t\tfor (int j=0; j<n; j++)\n\t\t\t\tjanusz.A[i][j]=podz[i+1][j+1];\n\t\t}\n\t\tfor (int i=0; i<n; i++)\n\t\t{\n\t\t\tjanusz.b[m+i]=1;\n\t\t\tjanusz.A[m+i][i]=1;\n\t\t}\n\t\tfor (int i=0; i<n; i++)\n\t\t{\n\t\t\tjanusz.b[m+n+i]=0;\n\t\t\tjanusz.A[m+n+i][i]=-1;\n\t\t}\n\t\tassert(janusz.solve());\n\t\tauto wez=janusz.getVars();\n\t\t\n\t\tvector <pair<ld,int> > wek;\n\t\tfor (int i=1; i<=n; i++)\n\t\t\twek.push_back({wez[i-1], i});\n\t\t\n\t\tsort(wek.begin(), wek.end());\n\t\treverse(wek.begin(), wek.end());\n\t\t\n\t\tter.reset();\n\t\t\n\t\tfor (auto i : wek)\n\t\t{\n\t\t\tter[i.second]=1;\n\t\t\tif (!popr())\n\t\t\t\tter[i.second]=0;\n\t\t}\n\t\twyn=max(wyn, dajwar());\n\t}\n\t\n\tprintf(\"%lld\\n\", wyn);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 5000005\nint tot,last[N],to[N],Next[N],flow[N];\nlong long val[N],dis[N];\nint e[N],q[30000005],S,T,Lx[N],Rx[N],Ly[N],Ry[N];\nint X[N],Y[N],n,m,pre[N];\nstruct node {\n  \tint id,x,y;\n}b[N],A[N];\nstruct pa {\n  \tint x,y;\n  \tlong long v;\n}a[N];\ninline void add(int x,int y,int f,long long v) {\n  Next[++tot]=last[x]; last[x]=tot; to[tot]=y; flow[tot]=f; val[tot]=v;\n}\n#define inf 1000000000000000000ll\ninline bool spfa() {\n  \tfor (int i=S;i<=T;i++) pre[i]=0,dis[i]=-inf,e[i]=0;\n  \tdis[S]=0; e[S]=1;\n  \tint l=0,r=1; q[1]=S;\n  \twhile (l<r) {\n      \tint k=q[++l];\n      \tfor (int i=last[k];i;i=Next[i]) {\n          \tif (!flow[i]||dis[to[i]]>=dis[S]+val[i]) continue;\n          \tdis[to[i]]=dis[S]+val[i];\n          \tpre[to[i]]=i;\n          \tif (!e[to[i]]) e[q[++r]=to[i]]=1;\n        }\n      \te[k]=0;\n    }\n  \treturn dis[T]!=-inf;\n}\ninline long long dinic(int y) {\n  \tlong long ans=0;\n  \tint s=0;\n  \twhile (spfa()) {\n      \ts++;\n      \tfor (int x=T;x!=S;x=to[pre[x]^1]) flow[pre[x]]--,flow[pre[x]^1]++,ans+=val[pre[x]];\n    }\n  \tif (s!=y) {\n\t  \tprintf(\"%lld\\n\",ans);\n\t  \texit(0);\n\t  }\n  \treturn ans;\n}\ninline long long work(int x) {\n  for (int i=1;i<=m;i++) if (b[i].id&1) A[i]=b[i];\n  else A[i]=node{b[i].id,x-b[i].x,b[i].y-1};\n  for (int i=1;i<=x;i++) X[i]=2*n+i,Y[i]=2*n+i+x;\n  S=0,T=Y[x]+1;\n  for (int i=S;i<=T;i++) last[i]=0;\n  tot=1;\n  for (int i=1;i<=x;i++) Lx[i]=Ly[i]=1,Rx[i]=Ry[i]=100;\n  for (int i=1;i<=m;i++) {\n  \tif (A[i].x<0||(A[i].x==0&&!(A[i].id&1))) continue;\n    if (A[i].id==1) Lx[A[i].x+1]=max(Lx[A[i].x+1],A[i].y+1);\n    else if (A[i].id==2) Rx[A[i].x]=min(Rx[A[i].x],A[i].y);\n    else if (A[i].id==3) Ly[A[i].x+1]=max(Ly[A[i].x+1],A[i].y+1);\n    else Ry[A[i].x]=min(Ry[A[i].x],A[i].y);\n  }\n  for (int i=1;i<=x;i++) Lx[i]=max(Lx[i],Lx[i-1]),Ly[i]=max(Ly[i],Ly[i-1]);\n  for (int i=x-1;i;i--) Rx[i]=min(Rx[i],Rx[i+1]),Ry[i]=min(Ry[i],Ry[i+1]);\n  for (int i=1;i<=x;i++) if (Lx[i]>Rx[i]) return 0;\n  for (int i=1;i<=x;i++) if (Ly[i]>Ry[i]) return 0;\n  for (int i=1;i<=x;i++) add(S,X[i],1,0),add(X[i],S,0,0),add(Y[i],T,1,0),add(T,Y[i],0,0);\n  for (int i=1;i<=x;i++)\n  for (int j=1;j<=n;j++) {\n    \tif (a[j].x>=Lx[i]&&a[j].x<=Rx[i]) add(X[i],j,1,0),add(j,X[i],0,0);\n    \tif (a[j].y>=Ly[i]&&a[j].y<=Ry[i]) add(j+n,Y[i],1,0),add(Y[i],j+n,0,0);\n  }\n  for (int i=1;i<=n;i++) add(i,i+n,1,a[i].v),add(i+n,i,0,-a[i].v);\n  return dinic(x);\n}\nchar c[15];\nint main() {\n\t//freopen(\"0.in\",\"r\",stdin);\n  scanf(\"%d\",&n);\n  for (int i=1;i<=n;i++) scanf(\"%d%d%lld\",&a[i].x,&a[i].y,&a[i].v);\n  scanf(\"%d\",&m);\n  for (int i=1;i<=m;i++) {\n    \tscanf(\"%s\",c);\n    \tscanf(\"%d%d\",&b[i].y,&b[i].x);\n    \tif (c[0]=='L') b[i].id=1;\n    \tif (c[0]=='R') b[i].id=2;\n    \tif (c[0]=='D') b[i].id=3;\n    \tif (c[0]=='U') b[i].id=4;\n  }\n  long long ans=0;\n  for (int i=1;i<=n;i++) \n\tans=max(ans,work(i));\n  printf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace __gnu_pbds;\nusing namespace std;\n \ntemplate <typename T>\nusing ordered_set =\n\ttree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n \n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n\t*this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n \n#define shandom_ruffle random_shuffle\n \nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=327;\nusing bn=bitset<87>;\nusing ld=long double;\n\nint n;\npii gdz[nax];\nll war[nax];\n\nint m;\nbn podz[nax];\nint ile[nax];\n\nll wyn;\n\nbn ter;\n \nll dajwar()\n{\n\tll ret=0;\n\tfor (int i=1; i<=n; i++)\n\t\tif (ter[i])\n\t\t\tret+=war[i];\n\treturn ret;\n}\n \nint popr()\n{\n\tfor (int i=1; i<=m; i++)\n\t\tif ((podz[i]&ter).count()>ile[i])\n\t\t\treturn 0;\n\treturn 1;\n}\n\nstruct Simplex {        // Maximize c*x subject to Ax <= b.\n  using T = ld;     // Initialize the structure, set A, b, c and then run\n  vector<vector<T>> A;  // solve(). Max objective is stored in res. To recover\n  vector<T> b, c;       // the best result, use getVars().\n  int V, E;\n  vector<int> eqIds, varIds, cols;\n  T res;\n  static constexpr T kEps = 1e-5;\n\n  Simplex(int vars, int eqs) : A(eqs, vector<T>(vars)), b(eqs), c(vars),\n      V(vars), E(eqs), eqIds(eqs), varIds(vars), res(0) {\n    iota(varIds.begin(), varIds.end(), 0);\n    iota(eqIds.begin(), eqIds.end(), vars);\n  }\n\n  void pivot(int eq, int var) {\n    T coef = 1 / A[eq][var];\n    cols.clear();\n    for (int i = 0; i < V; i++) {\n      if (abs(A[eq][i]) > kEps) { cols.push_back(i); A[eq][i] *= coef; }\n    }\n    A[eq][var] *= coef; b[eq] *= coef;\n    for (int row = 0; row < E; row++) {\n      if (row == eq || abs(A[row][var]) < kEps) { continue; }\n      T k = -A[row][var];\n      A[row][var] = 0;\n      for (int i : cols) { A[row][i] += k * A[eq][i]; }\n      b[row] += k * b[eq];\n    }\n    T q = c[var]; c[var] = 0;\n    for (int i : cols) { c[i] -= q * A[eq][i]; }\n    res += q * b[eq];\n    swap(varIds[var], eqIds[eq]);\n  }\n\n  bool solve() {\n    while (true) {\n      int eq = -1, var = -1;\n      for (int i = 0; i < E; i++) { if (b[i] < -kEps) { eq = i; break; } }\n      if (eq == -1) { break; }\n      for (int i = 0; i < V; i++) { if (A[eq][i] < -kEps) { var = i; break; } }\n      if (var == -1) { res = -1e9; return false; /* No solution */ }\n      pivot(eq, var);\n    }\n    while (true) {\n      int var = -1, eq = -1;\n      for (int i = 0; i < V; i++) { if (c[i] > kEps) { var = i; break; } }\n      if (var == -1) { break; }\n      for (int i = 0; i < E; i++) {\n        if (A[i][var] < kEps) { continue; }\n        if (eq >= 0 && b[i] / A[i][var] >= b[eq] / A[eq][var]) { continue; }\n        eq = i;\n      }\n      if (eq == -1) { res = 1e9; return false; /* Unbounded */ }\n      pivot(eq, var);\n    }\n    return true;\n  }\n\n  vector<T> getVars() { // Optimal assignment of variables.\n    vector<T> result(V);\n    for (int i = 0; i < E; i++) if (eqIds[i] < V) result[eqIds[i]] = b[i];\n    return result;\n  }\n};\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(\"%d%d%lld\", &gdz[i].first, &gdz[i].second, &war[i]);\n\tscanf(\"%d\", &m);\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\tchar c;\n\t\tint a, b;\n\t\tscanf(\" %c%d%d\", &c, &a, &b);\n\t\tfor (int j=1; j<=n; j++)\n\t\t{\n\t\t\tif (c=='L' && gdz[j].first<=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='R' && gdz[j].first>=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='D' && gdz[j].second<=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='U' && gdz[j].second>=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t}\n\t\tile[i]=b;\n\t}\n\tSimplex janusz(n, m+2*n);\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tjanusz.c[i]=war[i+1];\n\t}\n\tfor (int i=0; i<m; i++)\n\t{\n\t\tjanusz.b[i]=ile[i+1];\n\t\tfor (int j=0; j<n; j++)\n\t\t\tjanusz.A[i][j]=podz[i+1][j+1];\n\t}\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tjanusz.b[m+i]=1;\n\t\tjanusz.A[m+i][i]=1;\n\t}\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tjanusz.b[m+n+i]=0;\n\t\tjanusz.A[m+n+i][i]=-1;\n\t}\n\tassert(janusz.solve());\n\tauto wez=janusz.getVars();\n\t\n\tfor (int i=0; i<n; i++)\n\t\tter[i+1]=(wez[i]>0.5);\n\t\n\twhile(!popr())\n\t\tter[rand()%n+1]=0;\n\t\n\tll sta=dajwar();\n\t\n\twyn=sta;\n\t\n\tconst int czes=5e5;\n\tconst int res=7e4;\n\tfor (int h=0; h%czes || (clock()<=4.5*CLOCKS_PER_SEC); h++)\n\t{\n\t\tif (!(rand()%res))\n\t\t{\n\t\t\tter.reset();\n\t\t\tvi kol(n);\n\t\t\tiota(kol.begin(), kol.end(), 1);\n\t\t\tshandom_ruffle(kol.begin(), kol.end());\n\t\t\tfor (int i : kol)\n\t\t\t{\n\t\t\t\tter[i]=1;\n\t\t\t\tif (!popr())\n\t\t\t\t\tter[i]=0;\n\t\t\t}\n\t\t\tsta=dajwar();\n\t\t\twyn=max(wyn, sta);\n\t\t}\n\t\tbn pam=ter;\n\t\tint r=rand()%2+1;\n\t\tfor (int i=0; i<r; i++)\n\t\t\tter.flip(rand()%n+1);\n\t\tif (!popr())\n\t\t{\n\t\t\tter=pam;\n\t\t\tcontinue;\n\t\t}\n\t\tll now=dajwar();\n\t\tif (now>=sta || !(rand()%5000))\n\t\t{\n\t\t\tsta=now;\n\t\t\twyn=max(wyn, now);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tter=pam;\n\t\t}\n\t}\n\t\n\tdebug() << janusz.getVars();\n\tprintf(\"%lld\\n\", wyn);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int V=170,E=500,N=85;\nstruct graph{\n\tstruct edge{int to,next;ll w;int f;}e[E<<1];\n\tint h[V],xb,n;\n\tinline void addedge(int x,int y,ll w,int f){\n\t\te[++xb]=(edge){y,h[x],w,f};h[x]=xb;\n\t\te[++xb]=(edge){x,h[y],-w,0};h[y]=xb;\n\t}\n\tinline pair<int,ll>mcmf(int S,int T){\n\t\tstatic int q[V],mi[V],lv[V],le[V];static bool inq[V];static ll d[V];\n\t\tint t,w,ans1=0,u,i;ll ans2=0;\n\t\tfor(;;){\n\t\t\tmemset(inq+1,0,n);inq[S]=1;\n\t\t\tfor(i=1;i<=n;++i)d[i]=-(1ll<<60);d[S]=0;\n\t\t\tt=0;w=1;q[1]=S;mi[S]=1<<30;\n\t\t\tfor(;t!=w;){\n\t\t\t\tinq[u=q[t=t==n?1:t+1]]=0;\n\t\t\t\tfor(int i=h[u];i;i=e[i].next)if(e[i].f && d[e[i].to]<d[u]+e[i].w){\n\t\t\t\t\td[e[i].to]=d[u]+e[i].w;\n\t\t\t\t\tmi[e[i].to]=min(mi[u],e[i].f);\n\t\t\t\t\tlv[e[i].to]=u;le[e[i].to]=i;\n\t\t\t\t\tif(!inq[e[i].to])inq[q[w=w==n?1:w+1]=e[i].to]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(d[T]==-(1ll<<60))return make_pair(ans1,ans2);\n\t\t\tans1+=mi[T];\n\t\t\tfor(u=T;u!=S;u=lv[u]){\n\t\t\t\tans2+=mi[T]*e[le[u]].w;\n\t\t\t\te[le[u]].f-=mi[T];\n\t\t\t\te[le[u]^1].f+=mi[T];\n\t\t\t}\n\t\t}\n\t}\n};\nstruct G2{\nstruct edge{int fr,to,lo,hi;ll w;}e[E];\nint n,xb,id[N];\ngraph g;\ninline void add(int u,int v,int l,int r,ll w){e[++xb]=(edge){u,v,l,r,w};}\ninline ll mcmf(){\n\tstatic int in[V];int i;\n\tmemset(in+1,0,n<<2);for(i=1;i<=xb;++i)in[e[i].to]+=e[i].lo,in[e[i].fr]-=e[i].lo;\n\tg.xb=1;g.n=n+2;memset(g.h+1,0,g.n<<2);memset(id+1,0,n<<2);\n\tfor(i=1;i<=n;++i){\n\t\tif(in[i]<0)g.addedge(i,n+2,0,-in[i]),id[i]=g.xb-1;\n\t\tif(in[i]>0)g.addedge(n+1,i,0,in[i]),id[i]=g.xb-1;\n\t}\n\tfor(i=1;i<=xb;++i){\n\t\tif(e[i].hi>e[i].lo)g.addedge(e[i].fr,e[i].to,e[i].w,e[i].hi-e[i].lo);\n\t\tif(e[i].hi<e[i].lo)return 0;\n\t}\n\tll ret=g.mcmf(n+1,n+2).second;\n\tfor(i=1;i<=n;++i)if(g.e[id[i]].f)\n\t\treturn 0;\n//cerr<<ret<<' '<<endl;\n\treturn ret;\n}\n}g;\nint n,x[N],y[N],i,j,a,b,xx[N],yy[N],xxb,yxb,m,mn,v1[N],v2[N],v3[N],v4[N];\nll v[N],ans;\nchar op[9];\nint main(){\n\t//freopen(\"1\",\"r\",stdin);\n\tscanf(\"%d\",&n);mn=n;\n\tfor(i=1;i<=n;++i)scanf(\"%d%d%lld\",x+i,y+i,v+i),xx[++xxb]=x[i],yy[++yxb]=y[i];\n\tsort(xx+1,xx+xxb+1);xxb=unique(xx+1,xx+xxb+1)-xx-1;\n\tsort(yy+1,yy+yxb+1);yxb=unique(yy+1,yy+yxb+1)-yy-1;\n\tfor(i=1;i<=n;++i)x[i]=lower_bound(xx+1,xx+xxb+1,x[i])-xx,y[i]=lower_bound(yy+1,yy+yxb+1,y[i])-yy;\n\tfor(i=1;i<=xxb;++i)v1[i]=v2[i]=n;for(i=1;i<=yxb;++i)v3[i]=v4[i]=n;\n\tscanf(\"%d\",&m);\n\tfor(i=1;i<=m;++i){\n\t\tscanf(\"%s%d%d\",op,&a,&b);\n\t\tif(*op=='L'){\n\t\t\ta=upper_bound(xx+1,xx+xxb+1,a)-xx-1;\n\t\t\tif(1<=a && a<xxb)v1[a]=min(v1[a],b);\n\t\t\tif(a==xxb)\nmn=min(b,mn);\n\t\t}\n\t\tif(*op=='R'){\n\t\t\ta=lower_bound(xx+1,xx+xxb+1,a)-xx;\n\t\t\tif(1<a && a<=xxb)v2[a]=min(v2[a],b);\n\t\t\tif(a==1)\nmn=min(b,mn);\n\t\t}\n\t\tif(*op=='D'){\n\t\t\ta=upper_bound(yy+1,yy+yxb+1,a)-yy-1;\n\t\t\tif(1<=a && a<yxb)v3[a]=min(v3[a],b);\n\t\t\tif(a==yxb)\nmn=min(b,mn);\n\t\t}\n\t\tif(*op=='U'){\n\t\t\ta=lower_bound(yy+1,yy+yxb+1,a)-yy;\n\t\t\tif(1<a && a<=yxb)v4[a]=min(v4[a],b);\n\t\t\tif(a==1)\nmn=min(b,mn);\n\t\t}\n\t}\n\tg.n=xxb+yxb;\n\tfor(i=1;i<=mn;++i){\n\t\tg.xb=0;\n\t\tfor(j=1;j<xxb;++j)g.add(j,j+1,max(0,i-v1[j]),v2[j+1],0);\n\t\tfor(j=1;j<yxb;++j)g.add(xxb+j,xxb+j+1,max(0,i-v4[j+1]),v3[j],0);\n\t\tfor(j=1;j<=n;++j)g.add(x[j],y[j]+xxb,0,1,v[j]);\n\t\tg.add(g.n,1,i,i,0);\n//cerr<<i<<endl;\n\t\tans=max(ans,g.mcmf());\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nostream &operator<<(ostream &os, __float128 f) { return os << (LD)f; }\n\n\nstruct Simplex {        // Maximize c*x subject to Ax <= b.\n  using T = __float128; // Initialize the structure, set A, b, c and then run\n  vector<vector<T>> A;  // solve(). Max objective is stored in res. To recover\n  vector<T> b, c;       // the best result, use getVars().\n  T abs(T x) { return x < 0 ? -x : x; }\n\n  int V, E;\n  VI eqIds, varIds, cols;\n  T res;\n  const LD kEps = 1e-9;\n\n  Simplex(int vars, int eqs) : A(eqs, vector<T>(vars)), b(eqs), c(vars),\n                               V(vars), E(eqs), eqIds(eqs), varIds(vars), res(0) {\n    iota(ALL(varIds), 0); iota(ALL(eqIds), vars);\n  }\n\n  void pivot(int eq, int var) {\n    T coef = 1 / A[eq][var];\n    cols.clear();\n    REP (i, V) {\n      if (abs(A[eq][i]) > kEps) { cols.PB(i); A[eq][i] *= coef; }\n    }\n    A[eq][var] *= coef; b[eq] *= coef;\n    REP (row, E) {\n      if (row == eq || abs(A[row][var]) < kEps) { continue; }\n      T k = -A[row][var];\n      A[row][var] = 0;\n      for (int i : cols) { A[row][i] += k * A[eq][i]; }\n      b[row] += k * b[eq];\n    }\n    T q = c[var]; c[var] = 0;\n    for (int i : cols) { c[i] -= q * A[eq][i]; }\n    res += q * b[eq];\n\n    swap(varIds[var], eqIds[eq]);\n  }\n  \n  bool solve() {\n    while (true) {\n      int eq = -1, var = -1;\n      REP (i, E) { if (b[i] < -kEps) { eq = i; break; } }\n      if (eq == -1) { break; }\n      REP (i, V) { if (A[eq][i] < -kEps) { var = i; break; } }\n      if (var == -1) { res = -1e9; return false; /* No solution */ }\n      pivot(eq, var);\n    }\n\n    while (true) {\n      int var = -1, eq = -1;\n      REP (i, V) { if (c[i] > kEps) { var = i; break; } }\n      if (var == -1) { break; }\n      REP (i, E) {\n        if (A[i][var] < kEps) { continue; }\n        if (eq >= 0 && b[i] / A[i][var] >= b[eq] / A[eq][var]) { continue; }\n        eq = i;\n      }\n      if (eq == -1) { res = 1e9; return false; /* Unbounded */ }\n      pivot(eq, var);\n    }\n\n    return true;\n  }\n  \n  vector<T> getVars() {  // Optimal assignment of variables.\n    vector<T> result(V);\n    REP (i, E) { if (eqIds[i] < V) { result[eqIds[i]] = b[i]; } }\n    return result;\n  }\n};\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n\n  int N, M;\n  cin >> N;\n  vector<PII> points(N);\n  vector<int> point_vals(N);\n\n  for (int i = 0; i < N; ++i) {\n    cin >> points[i].st >> points[i].nd >> point_vals[i];\n  }\n\n  map<char, function<bool(PII, int)>> checkers = {\n    {'L', [](const PII &pt, int a) { return pt.st <= a; }},\n    {'R', [](const PII &pt, int a) { return pt.st >= a; }},\n    {'D', [](const PII &pt, int a) { return pt.nd <= a; }},\n    {'U', [](const PII &pt, int a) { return pt.nd >= a; }}\n  };\n\n  cin >> M;\n\n  Simplex sim(N, M + 2 * N);\n  for (int i = 0; i < M; ++i) {\n    char type;\n    int a, b;\n    cin >> type >> a >> b;\n\n    for (int j = 0; j < N; ++j) {\n      sim.A[i][j] = checkers[type](points[j], a);\n    }\n    sim.b[i] = b;\n\n    debug(sim.A[i], sim.b[i]);\n  }\n  for (int i = 0; i < N; ++i) {\n    sim.c[i] = point_vals[i];\n    sim.A[M + i * 2][i] = -1;\n    sim.A[M + i * 2 + 1][i] = 1;\n    sim.b[M + i * 2] = 0;\n    sim.b[M + i * 2 + 1] = 1;\n  }\n  auto orig_a = sim.A;\n  auto orig_b = sim.b;\n\n  assert(sim.solve());\n  auto vars = sim.getVars();\n\n  vector<int> always, maybe;\n  for (int i = 0; i < N; ++i) {\n    if (vars[i] > 0.7) {\n      always.PB(i);\n    } else if (vars[i] > 0.3) {\n      maybe.PB(i);\n    }\n  }\n\n  debug(always, maybe);\n\n  LL ans = -1;\n\n  for (LL m = 0; m < (1LL << SZ(maybe)); ++m) {\n    vector<int> mine = always;\n    for (int j = 0; j < SZ(maybe); ++j) {\n      if ((m >> j) & 1) { mine.PB(maybe[j]); }\n    }\n\n    bool fail = false;\n    for (int i = 0; i < M; ++i) {\n      int cnt = 0;\n      for (int j : mine) {\n        if (orig_a[i][j] > 0.5) { ++cnt; }\n      }\n      debug(mine, i, cnt, orig_b[i]);\n      if (cnt > (int)round((LD)orig_b[i])) { debug(i); fail = true; }\n    }\n\n    if (fail) { continue; }\n    LL x = 0;\n    for (int i : mine) {\n      x += point_vals[i];\n    }\n    maxi(ans, x);\n  }\n\n  cout << ans << \"\\n\";\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace __gnu_pbds;\nusing namespace std;\n \ntemplate <typename T>\nusing ordered_set =\n\ttree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n \n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n\t*this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n \n#define shandom_ruffle random_shuffle\n \nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=327;\nusing bn=bitset<87>;\n\nint n;\npii gdz[nax];\nll war[nax];\n\nint m;\nbn podz[nax];\nint ile[nax];\n\nll wyn;\n\nbn ter;\n\nll dajwar()\n{\n\tll ret=0;\n\tfor (int i=1; i<=n; i++)\n\t\tif (ter[i])\n\t\t\tret+=war[i];\n\treturn ret;\n}\n\nint popr()\n{\n\tfor (int i=1; i<=m; i++)\n\t\tif ((podz[i]&ter).count()>ile[i])\n\t\t\treturn 0;\n\treturn 1;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(\"%d%d%lld\", &gdz[i].first, &gdz[i].second, &war[i]);\n\tscanf(\"%d\", &m);\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\tchar c;\n\t\tint a, b;\n\t\tscanf(\" %c%d%d\", &c, &a, &b);\n\t\tfor (int j=1; j<=n; j++)\n\t\t{\n\t\t\tif (c=='L' && gdz[j].first<=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='R' && gdz[j].first>=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='D' && gdz[j].second<=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='U' && gdz[j].second>=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t}\n\t\tile[i]=b;\n\t}\n\tll sta=0;\n\tconst int czes=5e5;\n\tconst int res=7e4;\n\tfor (int h=0; h%czes || (clock()<=4.5*CLOCKS_PER_SEC); h++)\n\t{\n\t\tif (!(rand()%res))\n\t\t{\n\t\t\tter.reset();\n\t\t\tvi kol(n);\n\t\t\tiota(kol.begin(), kol.end(), 1);\n\t\t\tshandom_ruffle(kol.begin(), kol.end());\n\t\t\tfor (int i : kol)\n\t\t\t{\n\t\t\t\tter[i]=1;\n\t\t\t\tif (!popr())\n\t\t\t\t\tter[i]=0;\n\t\t\t}\n\t\t\tsta=dajwar();\n\t\t\twyn=max(wyn, sta);\n\t\t}\n\t\tbn pam=ter;\n\t\tint r=rand()%3+1;\n\t\tfor (int i=0; i<r; i++)\n\t\t\tter.flip(rand()%n+1);\n\t\tif (!popr())\n\t\t{\n\t\t\tter=pam;\n\t\t\tcontinue;\n\t\t}\n\t\tll now=dajwar();\n\t\tif (now>=sta || !(rand()%500))\n\t\t{\n\t\t\tsta=now;\n\t\t\twyn=max(wyn, now);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tter=pam;\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\\n\", wyn);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <list>\n#include <time.h>\n#include <math.h>\n#include <random>\n#include <deque>\n#include <queue>\n#include <cassert>\n#include <unordered_map>\n#include <unordered_set>\n#include <iomanip>\n#include <bitset>\n#include <sstream>\n#include <chrono>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef __float128 dbl;\nconst int INF = 1.01e9;\n\n__float128 abs(__float128 x)\n{\n  if (x < 0) return -x;\n  return x;\n}\n \nconst __float128 EPS = 1e-25;\nbool eq(__float128 x, __float128 y) {\n    return fabs(x - y) < EPS;\n}\nbool ls(__float128 x, __float128 y) {\n    return x < y && !eq(x, y);\n}\n \nvector<__float128> simplex(vector<vector<__float128> > a) {\n    int n = a.size() - 1;\n    int m = a[0].size() - 1;\n    vector<int> left(n + 1), up(m + 1);\n    iota(up.begin(), up.end(), 0);\n    iota(left.begin(), left.end(), m);\n    auto pivot = [&](int x, int y) {\n        swap(left[x], up[y]);\n        __float128 k = a[x][y];\n        a[x][y] = 1;\n        vector<int> vct;\n        for (int j = 0; j <= m; j++) {\n            a[x][j] /= k;\n            if (!eq(a[x][j], 0)) vct.push_back(j);\n        }\n        for (int i = 0; i <= n; i++) {\n            if (eq(a[i][y], 0) || i == x) continue;\n            k = a[i][y];\n            a[i][y] = 0;\n            for (int j : vct) a[i][j] -= k * a[x][j];\n        }\n    };\n    while (1) {\n        int x = -1;\n        for (int i = 1; i <= n; i++) if (ls(a[i][0], 0) && (x == -1 || a[i][0] < a[x][0])) x = i;\n        if (x == -1) break;\n        int y = -1;\n        for (int j = 1; j <= m; j++) if (ls(a[x][j], 0) && (y == -1 || a[x][j] < a[x][y])) y = j;\n        if (y == -1) assert(0); // infeasible\n        pivot(x, y);\n    }\n    while (1) {\n        int y = -1;\n        for (int j = 1; j <= m; j++) if (ls(0, a[0][j]) && (y == -1 || a[0][j] > a[0][y])) y = j;\n        if (y == -1) break;\n        int x = -1;\n        for (int i = 1; i <= n; i++) if (ls(0, a[i][y]) && (x == -1 || a[i][0] / a[i][y] < a[x][0] / a[x][y])) x = i;\n        if (x == -1) assert(0); // unbounded\n        pivot(x, y);\n    }\n    vector<__float128> ans(m + 1);\n    for (int i = 1; i <= n; i++) if (left[i] <= m) ans[left[i]] = a[i][0];\n    ans[0] = -a[0][0];\n    return ans;\n}\n\n#ifdef ONPC\n  mt19937 rnd(228);\n#else\n  mt19937 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\n#endif\n\nint main()\n{\n#ifdef ONPC\n  freopen(\"a.in\", \"r\", stdin);\n#endif\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector <int> x(n), y(n);\n  vector <ll> ok;\n  vector <__float128> v;\n  vector <pair <ll, int> > e;\n  for (int i = 0; i < n; i++)\n  {\n    cin >> x[i] >> y[i];\n    ll x;\n    cin >> x;\n    ok.push_back(x);\n    v.push_back(x);\n    e.push_back({x, i});\n  }\n  v.insert(v.begin(), 0);\n  int m;\n  cin >> m;\n  vector <vector <__float128> > mat;\n  mat.push_back(v);\n  for (int i = 0; i < n; i++)\n  {\n    vector <__float128> kek(n + 1);\n    kek[0] = kek[i + 1] = 1;\n    mat.push_back(kek);\n  }\n  vector <vector <int> > simp;\n  for (int i = 0; i < m; i++)\n  {\n    char c;\n    cin >> c;\n    int a;\n    int b;\n    cin >> a >> b;\n    vector <__float128> arr = {(__float128) b};\n    vector <int> kek = {b};\n    for (int j = 0; j < n; j++)\n    {\n      int grab = 0;\n      if (c == 'L' && x[j] <= a) grab = 1;\n      if (c == 'R' && x[j] >= a) grab = 1;\n      if (c == 'D' && y[j] <= a) grab = 1;\n      if (c == 'U' && y[j] >= a) grab = 1;\n      arr.push_back(grab);\n      kek.push_back(grab);\n    }\n    mat.push_back(arr);\n    simp.push_back(kek);\n  }\n  auto good = [&] (vector <int> grab)\n  {\n    for (auto c : simp)\n    {\n      int sum = 0;\n      for (int i = 1; i <= n; i++) sum += grab[i - 1] * c[i];\n      if (sum > c[0])\n      {\n        return false;\n      }\n    }\n    return true;\n  };\n  auto f = [&] (vector <int> grab)\n  {\n    ll sum = 0;\n    for (int i = 0; i < n; i++)\n    {\n      if (grab[i]) sum += ok[i];\n    }\n    return sum;\n  };\n  vector <int> grab;\n  for (int i = 0; i < n; i++) grab.push_back(0);\n  cout.precision(20);\n  auto solve = [&] ()\n  {\n    auto ret = simplex(mat);\n    sort(e.begin(), e.end());\n    vector <int> me(n);\n    int x = -1;\n    for (int i = 1; i <= n; i++)\n    {\n      if (grab[i - 1]) continue;\n      grab[x - 1] = true;\n      if (!good(grab))\n      {\n        grab[x - 1] = false;\n        continue;\n      }\n      if (x == -1 || ret[i] > ret[x])\n      {\n        x = i;\n      }\n    }\n    if (x == -1 || ret[x] < EPS) return 0ll;\n    x--;\n    me[x] = true;\n    grab[x] = true;\n    if (!good(grab)) grab[x] = false, me[x] = false;\n    int kekos = 0;\n    for (auto &c : mat)\n    {\n      kekos++;\n      if (kekos > n + 1)\n      for (int i = 1; i <= n; i++)\n      {\n        if (me[i - 1] && c[i] > EPS) c[i]--, c[0]--;\n      }\n    }\n    for (int i = 1; i <= n; i++)\n    {\n      if (me[i - 1])\n      {\n        mat[i][0] = 0;\n      }\n    }\n    return ok[x];\n  };\n  ll ans = 0;\n  while (ll t = solve())\n  {\n    ans += t;\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\nconst int INF(0X3F3F3F3F);\ntypedef long long int LL;\n\nnamespace G\n{\n\tconst int Max_V(85 * 2);\n\tconst int Max_E(85 * 30);\n\tint V, S, T, Head[Max_V], Total, To[Max_E], Next[Max_E], Cap[Max_E], Flow[Max_E];\n\tLL Weight[Max_E];\n\tvoid clear()\n\t{\n\t\tfor (int i = 1;i <= V;++i)\n\t\t\tHead[i] = 0;\n\t\tfor (int i = 2;i <= Total + 1;++i)\n\t\t\tTo[i] = Next[i] = Cap[i] = Flow[i] = Weight[i] = 0;\n\t\tV = S = T = Total = 0;\n\t}\n\tinline void Add_Edge(int tot, int s, int t, int c, LL w)\n\t{\n\t\tTo[tot] = t, Next[tot] = Head[s], Head[s] = tot, Cap[tot] = c, Flow[tot] = 0, Weight[tot] = w;\n\t}\n\tinline void Add_Link(int s, int t, int c, LL w)\n\t{\n\t\tTotal += 2, Add_Edge(Total, s, t, c, w), Add_Edge(Total ^ 1, t, s, 0, -w);\n\t}\n\tLL Dist[Max_V];\n\tbool InQ[Max_V], done[Max_V];\n\tbool SPFA()\n\t{\n\t\tqueue<int> Q;\n\t\tmemset(Dist, -0X3F, sizeof(Dist)), Dist[S] = 0LL;\n\t\tmemset(done, false, sizeof(done)), Q.push(S), InQ[S] = true;\n\t\tfor (int u;Q.empty() == false;)\n\t\t{\n\t\t\tu = Q.front(), Q.pop(), InQ[u] = false, done[u] = true;\n\t\t\tfor (int i = Head[u], v;i;i = Next[i])\n\t\t\t\tif (Cap[i] > Flow[i] && Dist[v = To[i]] < Dist[u] + Weight[i])\n\t\t\t\t{\n\t\t\t\t\tDist[v] = Dist[u] + Weight[i];\n\t\t\t\t\tif (!InQ[v])\n\t\t\t\t\t\tQ.push(v), InQ[v] = true;\n\t\t\t\t}\n\t\t}\n\t\treturn done[T];\n\t}\n\tint Cur[Max_V];\n\tint DFS(int u, int a)\n\t{\n\t\tif (u == T || a == 0)\n\t\t\treturn a;\n\t\tint Ans(0);\n\t\tdone[u] = true;\n\t\tfor (int &i = Cur[u], v, f;i;i = Next[i])\n\t\t\tif (Dist[v = To[i]] == Dist[u] + Weight[i] && !done[v] && (f = DFS(v, min(a, Cap[i] - Flow[i]))) > 0)\n\t\t\t{\n\t\t\t\tAns += f, Flow[i] += f, Flow[i ^ 1] -= f;\n\t\t\t\tif ((a -= f) == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\tdone[u] = false;\n\t\treturn Ans;\n\t}\n\tvoid MCMF(int &FLOW, LL &COST)\n\t{\n\t\tfor (int f;SPFA();)\n\t\t{\n\t\t\tfor (int i = 1;i <= V;++i)\n\t\t\t\tCur[i] = Head[i], done[i] = false;\n\t\t\tFLOW -= (f = DFS(S, INF)), COST += Dist[T] * f;\n\t\t}\n\t}\n}\n\nconst int Max_N(85);\nconst int Max_M(325);\n\nint N, X[Max_N], Y[Max_N], PX[Max_N], PY[Max_N], XL[Max_N], XR[Max_N], YL[Max_N], YR[Max_N], M, T[Max_M], A[Max_M], B[Max_M];\nLL V[Max_N], Ans;\n\ninline bool comp_X(int a, int b)\n{\n\treturn X[a] < X[b];\n}\n\ninline bool comp_Y(int a, int b)\n{\n\treturn Y[a] < Y[b];\n}\n\n/*\n枚举选的宝石总数Sum，那么可以变成对于每个前缀选的宝石数量都有一个区间的限制。在X轴和Y轴上分别可以列出方程\nX轴的方程组： \n0 = 0\nX[1] = XV[1]\nX[1] + X[2] = XV[2]\n...\nX[1] + X[2] + ... + X[N] = Sum\nY轴的方程组： \n0 = 0\nY[1] = YV[1]\nY[1] + Y[2] = YV[2]\n...\nY[1] + Y[2] + ... + Y[N] = Sum\n对于每个XV[i]，有XL[i] <= XV[i] <= XR[i]的限制；对于每个YV[i]，有YL[i] <= YV[i] <= YR[i]的限制\n对于每个轴的方程组，两两差分。那么每个XV和YV出现了恰好两次，系数分别是+1和-1。每个X和Y出现了恰好一次\n那么对于点(x, y)，X[x]和Y[y]是同一个变量。所以这些变量可以看做出现了恰好两次，系数分别是+1和-1\n然后用流量平衡建图，可以得到一个最大费用可行流问题 \n*/\nint main()\n{\n\tscanf(\"%d\", &N);\n\tfor (int i = 1;i <= N;++i)\n\t\tscanf(\"%d%d%lld\", X + i, Y + i, V + i), PX[i] = PY[i] = i;\n\tsort(PX + 1, PX + 1 + N, comp_X), sort(PY + 1, PY + 1 + N, comp_Y);\n\tscanf(\"%d\", &M);\n\tfor (int i = 1;i <= M;++i)\n\t{\n\t\tchar op[10];\n\t\tscanf(\"%s%d%d\", op, A + i, B + i);\n\t\tif (*op == 'L')\n\t\t\tT[i] = 1;\n\t\tif (*op == 'R')\n\t\t\tT[i] = 2;\n\t\tif (*op == 'D')\n\t\t\tT[i] = 3;\n\t\tif (*op == 'U')\n\t\t\tT[i] = 4;\n\t}\n\tfor (int Sum = 1;Sum <= N;++Sum)\n\t{\n\t\tXL[0] = YL[0] = XR[0] = YR[0] = 0;\n\t\tfor (int i = 1;i <= N - 1;++i)\n\t\t\tXL[i] = YL[i] = 0, XR[i] = YR[i] = Sum;\n\t\tXL[N] = YL[N] = XR[N] = YR[N];\n\t\tfor (int i = 1;i <= M;++i)\n\t\t{\n\t\t\tif (T[i] == 1)\n\t\t\t\tif (X[PX[1]] <= A[i])\n\t\t\t\t\tfor (int j = 1;j <= N;++j)\n\t\t\t\t\t\tif (j == N || X[PX[j + 1]] > A[i])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tXR[j] = min(XR[j], B[i]);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\tif (T[i] == 2)\n\t\t\t\tif (A[i] <= X[PX[N]])\n\t\t\t\t\tfor (int j = N - 1;j >= 0;--j)\n\t\t\t\t\t\tif (j == 0 || A[i] > X[PX[j]])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tXL[j] = max(XL[j], Sum - B[i]);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\tif (T[i] == 3)\n\t\t\t\tif (Y[PY[1]] <= A[i])\n\t\t\t\t\tfor (int j = 1;j <= N;++j)\n\t\t\t\t\t\tif (j == N || Y[PY[j + 1]] > A[i])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tYR[j] = min(YR[j], B[i]);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\tif (T[i] == 4)\n\t\t\t\tif (A[i] <= Y[PY[N]])\n\t\t\t\t\tfor (int j = N - 1;j >= 0;--j)\n\t\t\t\t\t\tif (j == 0 || A[i] > Y[PY[j]])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tYL[j] = max(YL[j], Sum - B[i]);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t}\n\t\tfor (int i = 0;i <= N;++i)\n\t\t\tif (XL[i] > XR[i] || YL[i] > YR[i])\n\t\t\t\tgoto loop;\n\t\tint FLOW(0);\n\t\tLL COST(0LL);\n\t\tG::clear(), G::V = N + N + 2, G::S = N + N + 1, G::T = N + N + 2;\n\t\tfor (int i = 1, x, y;i <= N;++i)\n\t\t{\n\t\t\tfor (x = 1;x <= N;++x)\n\t\t\t\tif (PX[x] == i)\n\t\t\t\t\tbreak;\n\t\t\tfor (y = 1;y <= N;++y)\n\t\t\t\tif (PY[y] == i)\n\t\t\t\t\tbreak;\n\t\t\tCOST += V[i], ++FLOW, G::Add_Link(G::S, x, 1, 0LL), G::Add_Link(N + y, G::T, 1, 0LL);\n\t\t\tG::Add_Link(x, N + y, 1, -V[i]);\n\t\t}\n\t\tfor (int i = 1;i <= N - 1;++i)\n\t\t{\n\t\t\tif (XL[i])\n\t\t\t\tG::Add_Link(G::S, i + 1, XL[i], 0LL), G::Add_Link(i, G::T, XL[i], 0LL), FLOW += XL[i];\n\t\t\tif (XR[i] - XL[i])\n\t\t\t\tG::Add_Link(i, i + 1, XR[i] - XL[i], 0LL);\n\t\t}\n\t\tfor (int i = 1;i <= N - 1;++i)\n\t\t{\n\t\t\tif (YL[i])\n\t\t\t\tG::Add_Link(G::S, N + i, YL[i], 0LL), G::Add_Link(N + (i + 1), G::T, YL[i], 0LL), FLOW += YL[i];\n\t\t\tif (YR[i] - YL[i])\n\t\t\t\tG::Add_Link(N + (i + 1), N + i, YR[i] - YL[i], 0LL);\n\t\t}\n\t\tFLOW += Sum, G::Add_Link(N, G::T, Sum, 0LL), G::Add_Link(G::S, N + N, Sum, 0LL);\n\t\tG::MCMF(FLOW, COST);\n\t\tif (FLOW)\n\t\t\tgoto loop;\n\t\tAns = max(Ans, COST);\n\t}\n\tloop :\n\tprintf(\"%lld\", Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstring>\n#include <iostream>\n#include <queue>\n\n#define DEBUG() std::cerr << __FUNCTION__ << \" \" << __LINE__ << std::endl\n\nusing i64 = long long;\n\nnamespace flw {\n\tconst int N = 5000 + 7, M = 5000000 + 7;\n\tconst int INF = 1 << 28;\n\tstruct flow {\n\t\tint n, st, ed;\n\t\tint vis[N];\n\t\ti64 dis[N];\n\t\tstruct edge {\n\t\t\tint to, nex, cap; i64 wei;\n\t\t} e[M];\n\t\tint fir[N], cur[N], eid;\n\t\tint maxflow;\n\t\ti64 mincost;\n\n\t\tvoid init() {\n\t\t\teid = 1;\n\t\t\tstd::fill(fir + 1, fir + n + 1, 0);\n\t\t\tst = ed = n = 0;\n\t\t}\n\t\tvoid addedge(int u, int v, int c, i64 w) {\n\t\t\te[++eid] = (edge){ v, fir[u], c, w }, fir[u] = eid;\n\t\t}\n\t\tvoid addflow(int u, int v, int c, i64 w) {\n\t\t\taddedge(u, v, c, w), addedge(v, u, 0, -w);\n\t\t}\n\t\tvoid dinic() {\n\t\t\tmaxflow = mincost = 0;\n\t\t\tint f;\n\t\t\twhile (bfs())\n\t\t\t\twhile (f = dfs(st, INF)) maxflow += f, mincost += f * dis[st];\n\t\t}\n\t\tint bfs() {\n\t\t\tstd::fill(dis + 1, dis + n + 1, 1ll << 60),\n\t\t\tstd::fill(vis + 1, vis + n + 1, 0);\n\t\t\tstd::copy(fir + 1, fir + n + 1, cur + 1);\n\t\t\tstatic std::queue<int> q;\n\t\t\tdis[ed] = 0, vis[ed] = 1, q.push(ed);\n\t\t\tfor (int s; q.size(); ) {\n\t\t\t\ts = q.front(), q.pop();\n\t\t\t\tfor (int i = fir[s]; i; i = e[i].nex)\n\t\t\t\t\tif (e[i ^ 1].cap && dis[e[i].to] > dis[s] - e[i].wei) {\n\t\t\t\t\t\tdis[e[i].to] = dis[s] - e[i].wei;\n\t\t\t\t\t\tif (!vis[e[i].to])\n\t\t\t\t\t\t\tvis[e[i].to] = 1, q.push(e[i].to);\n\t\t\t\t\t}\n\t\t\t\tvis[s] = 0;\n\t\t\t}\n\t\t\treturn dis[st] < 1ll << 60;\n\t\t}\n\t\ti64 dfs(int s, int f) {\n\t\t\tif (s == ed) return f;\n\t\t\tvis[s] = 1;\n\t\t\tint u = 0, t;\n\t\t\tfor (int& i = cur[s]; i; i = e[i].nex) {\n\t\t\t\tif (!e[i].cap || vis[e[i].to] || dis[s] != dis[e[i].to] + e[i].wei) continue;\n\t\t\t\tt = dfs(e[i].to, std::min(f - u, e[i].cap));\n\t\t\t\te[i].cap -= t, e[i ^ 1].cap += t, u += t;\n\t\t\t\tif (f == u) break;\n\t\t\t}\n\t\t\treturn vis[s] = 0, u;\n\t\t}\n\t};\n}\n\nconst int X = 100 + 7, N = 80 + 7;\n\nint n, m;\nint u[N], v[N];\ni64 w[N];\nint x[N], y[N], z[N];\nint llm[N], rlm[N], dlm[N], ulm[N];\nflw::flow f;\ni64 ans;\n\nint main() {\n//\tfreopen(\"code.in\", \"r\", stdin);\n//\tfreopen(\"code.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i)\n\t\tscanf(\"%d%d%lld\", u + i, v + i, w + i);\n\tscanf(\"%d\", &m);\n\tfor (int i = 1; i <= m; ++i) {\n\t\tchar c[3];\n\t\tscanf(\"%s%d%d\", c, x + i, y + i);\n\t\tif (y[i] >= n) { --i; --m; continue; }\n\t\tz[i] = c[0];\n\t}\n\n\tfor (int k = 1; k <= n; ++k) {\n\t\tf.init();\n\t\tf.st = 2 * (n + k) + 1, f.ed = f.n = f.st + 1;\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t\tf.addflow(i, n + i, 1, -w[i]);\n\t\tmemset(llm, 0, sizeof llm);\n\t\tmemset(dlm, 0, sizeof dlm);\n\t\tmemset(rlm, 0x3f, sizeof rlm);\n\t\tmemset(ulm, 0x3f, sizeof ulm);\n\t\tfor (int i = 1; i <= m; ++i) {\n\t\t\tif (y[i] >= k) continue;\n\t\t\tif (z[i] == 'L') llm[y[i] + 1] = std::max(llm[y[i] + 1], x[i] + 1);\n\t\t\tif (z[i] == 'R') rlm[k - y[i]] = std::min(rlm[k - y[i]], x[i] - 1);\n\t\t\tif (z[i] == 'D') dlm[y[i] + 1] = std::max(dlm[y[i] + 1], x[i] + 1);\n\t\t\tif (z[i] == 'U') ulm[k - y[i]] = std::min(ulm[k - y[i]], x[i] - 1);\n\t\t}\n\t\tfor (int i = 1; i <= k; ++i)\n\t\t\tllm[i] = std::max(llm[i], llm[i - 1]),\n\t\t\tdlm[i] = std::max(dlm[i], dlm[i - 1]);\n\t\tfor (int i = k; i; --i)\n\t\t\trlm[i] = std::min(rlm[i], rlm[i + 1]),\n\t\t\tulm[i] = std::min(ulm[i], ulm[i + 1]);\n\t\tfor (int i = 1; i <= k; ++i) {\n\t\t\tf.addflow(f.st, 2 * n + i, 1, 0);\n\t\t\tf.addflow(2 * n + k + i, f.ed, 1, 0);\n\t\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\t\tif (llm[i] <= u[j] && u[j] <= rlm[i]) f.addflow(2 * n + i, j, 1, 0);\n\t\t\t\tif (dlm[i] <= v[j] && v[j] <= ulm[i]) f.addflow(n + j, 2 * n + k + i, 1, 0);\n\t\t\t}\n\t\t}\n\t\tf.dinic();\n\t\tif (f.maxflow == k) ans = std::max(ans, -f.mincost);\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst LL INF = 0x3f3f3f3f3f3f3f;\n\nnamespace flow\n{\n\tconst int MAXN = 400;\n\tstruct edge\n\t{\n\t\tint to, cap;\n\t\tLL cost;\n\t};\n\tint n, m;\n\tedge ed[30005];\n\tvector<int> G[405];\n\t\n\tvoid clear()\n\t{\n\t\tm = 0;\n\t\trep(i, n) G[i].clear();\n\t}\n\t\n\tvoid add_edge(int u, int v, int fl, LL co)\n\t{\n\t\ted[m].to = v; ed[m].cap = fl; ed[m].cost = co; G[u].push_back(m); m ++;\n\t\ted[m].to = u; ed[m].cap = 0; ed[m].cost = -co; G[v].push_back(m); m ++;\n\t}\n\t\n\tLL h[405];\n\tLL pat[405];\n\tint prev[405];\n\tbool vis[405];\n\t\n\tbool dijk(int s, int t)\n\t{\n\t\trep(i, n) {\n\t\t\tpat[i] = INF;\n\t\t\tvis[i] = false;\n\t\t}\n\t\tpat[s] = 0;\n\t\tpriority_queue<pair<LL, int> > que;\n\t\tque.push(MP(0, s));\n\t\t\n\t\twhile(!que.empty()) {\n\t\t\tint cur = que.top().second;\n\t\t\tque.pop();\n\t\t\tif(vis[cur]) continue;\n\t\t\tvis[cur] = true;\n\t\t\trep(i, G[cur].size()) {\n\t\t\t\tint ce = G[cur][i];\n\t\t\t\tif(ed[ce].cap == 0) continue;\n\t\t\t\tif(pat[ed[ce].to] > pat[cur] + ed[ce].cost) {\n\t\t\t\t\tpat[ed[ce].to] = pat[cur] + ed[ce].cost;\n\t\t\t\t\tprev[ed[ce].to] = ce;\n\t\t\t\t\tque.push(MP(-pat[ed[ce].to], ed[ce].to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn pat[t] != INF;\n\t}\n\t\n\tLL mcf(int s, int t, int mf)\n\t{\n\t\trep(i, n) h[i] = 0;\n\t\tLL ans = 0;\n\t\twhile(dijk(s, t)) {\n\t\t\t//in this occasion flow must be 1\n\t\t\tint cur = t, cf = 1;\n\t\t\twhile(cur != s) {\n\t\t\t\ted[prev[cur]].cap -= cf;\n\t\t\t\ted[prev[cur] ^ 1].cap += cf;\n\t\t\t\tcur = ed[prev[cur] ^ 1].to;\n\t\t\t}\n\t\t\trep(i, m) ed[i].cost += pat[ed[i ^ 1].to] - pat[ed[i].to];\n\t\t\trep(i, m) h[i] += pat[i];\n\t\t\tans += h[t] * cf;\n\t\t\tmf --;\n\t\t\tif(mf == 0) return ans;\n\t\t}\n\t\treturn -1;\n\t}\n}\n\nint n, x[85], y[85];\nLL v[85];\nint m, a[325], b[325];\nchar t[325];\nLL ans;\n\nint minx[85], maxx[85], miny[85], maxy[85];\nLL solve(int tot)\n{\n\trep(i, n) {\n\t\tminx[i] = miny[i] = -INF;\n\t\tmaxx[i] = maxy[i] = INF;\n\t}\n\t\n\trep(i, m) if(b[i] < tot) {\n\t\tif(t[i] == 'L') minx[b[i]] = max(minx[b[i]], a[i] + 1);\n\t\telse if(t[i] == 'R') maxx[tot - b[i] - 1] = min(maxx[tot - b[i] - 1], a[i] - 1);\n\t\telse if(t[i] == 'D') miny[b[i]] = max(miny[b[i]], a[i] + 1);\n\t\telse if(t[i] == 'U') maxy[tot - b[i] - 1] = min(maxy[tot - b[i] - 1], a[i] - 1);\n\t}\n\trep(i, tot - 1) {\n\t\tminx[i + 1] = max(minx[i], minx[i + 1]);\n\t\tminy[i + 1] = max(miny[i], miny[i + 1]);\n\t}\n\tfor(int i = tot - 1; i > 0; i --) {\n\t\tmaxx[i - 1] = min(maxx[i - 1], maxx[i]);\n\t\tmaxy[i - 1] = min(maxy[i - 1], maxy[i]);\n\t}\n\t\n\tflow::n = 2 + tot * 2 + n * 2;\n\tflow::clear();\n\trep(i, tot) flow::add_edge(tot * 2 + n * 2, i, 1, 0);\n\trep(i, tot) rep(j, n) if(x[j] >= minx[i] && x[j] <= maxx[i])\n\tflow::add_edge(i, j + tot * 2, 1, 0);\n\trep(i, n) flow::add_edge(i + tot * 2, i + tot * 2 + n, 1, INF - v[i]);\n\trep(i, tot) rep(j, n) if(y[j] >= miny[i] && y[j] <= maxy[i])\n\tflow::add_edge(j + tot * 2 + n, i + tot, 1, 0);\n\trep(i, tot) flow::add_edge(i + tot, tot * 2 + n * 2 + 1, 1, 0);\n\t\n\tLL ret = flow::mcf(flow::n - 2, flow::n - 1, tot);\n\t\n\treturn ret == -1 ? -1 : INF * tot - ret;\n}\n\nint main()\n{\n\tcin >> n;\n\trep(i, n) cin >> x[i] >> y[i] >> v[i];\n\tcin >> m;\n\trep(i, m) cin >> t[i] >> a[i] >> b[i];\n\tfor(int t = 0; t <= n; t ++)\n\tans = max(ans, solve(t));\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define gc getchar()\n#define pc putchar\n#define li long long\ninline li read(){\n\tli x = 0,y = 0,c = gc;\n\twhile(!isdigit(c)) y = c,c = gc;\n\twhile(isdigit(c)) x = (x << 1) + (x << 3) + (c ^ '0'),c = gc;\n\treturn y == '-' ? -x : x;\n}\ninline void print(li q){\n\tif(q < 0) pc('-'),q = -q;\n\tif(q >= 10) print(q / 10);\n\tpc(q % 10 + '0');\n}\n#define ldb long double\nldb p[510][510];\nint n,m,cnt;\nli x[510],y[510],a[510];\nint main(){\n\tint i,j,k,l,u,v;\n\tn = read();for(i = 1;i <= n;++i) x[i] = read(),y[i] = read(),a[i] = read();cnt = n;\n\tm = read();\n\tchar c;\n\tfor(i = 1;i <= m;++i){\n\t\tc = gc;while(c < 'A' || c > 'Z') c = gc;\n\t\tu = read();v = read();\n\t\tp[i][0] = v;\n\t\tif(c == 'U'){\n\t\t\tfor(j = 1;j <= n;++j) if(y[j] >= u) p[i][j] = 1;\n\t\t} \n\t\telse if(c == 'D'){\n\t\t\tfor(j = 1;j <= n;++j) if(y[j] <= u) p[i][j] = 1;\n\t\t} \n\t\telse if(c == 'L'){\n\t\t\tfor(j = 1;j <= n;++j) if(x[j] <= u) p[i][j] = 1;\n\t\t} \n\t\telse{\n\t\t\tfor(j = 1;j <= n;++j) if(x[j] >= u) p[i][j] = 1;\n\t\t} \n\t\tp[i][++cnt] = 1;\n\t}\n\tfor(i = 1;i <= n;++i) p[i + m][i] = p[i + m][++cnt] = p[i + m][0] = 1;\n\tfor(i = 1;i <= n;++i) p[0][i] = a[i];\n\t/*for(i = 0;i <= n + m;++i){\n\t\tfor(j = 0;j <= cnt;++j) cerr<<p[i][j]<<\" \";cerr<<endl;\n\t}\n\tcerr<<endl;*/\n\twhile(1){\n\t\tint fg = 0;\n\t\tfor(i = 1;i <= cnt;++i) if(p[0][i] > 0 && (!fg || p[0][i] > p[0][fg])) fg = i;\n\t\tif(!fg) break;\n\t\tint tp = 0;\n\t\tfor(i = 1;i <= n + m;++i) if(p[i][fg] > 0 && (!tp || p[i][0] / p[i][fg] < p[tp][0] / p[tp][fg])) tp = i;\n\t\tif(!tp) break;\n\t\tfor(i = 0;i <= cnt;++i) if(i != fg) p[tp][i] /= p[tp][fg];p[tp][fg] = 1;\n\t\tfor(i = 0;i <= n + m;++i) if(i != tp){\n\t\t\tfor(j = 0;j <= cnt;++j) if(j != fg) p[i][j] -= p[i][fg] * p[tp][j];p[i][fg] = 0;\n\t\t} \n\t\t/*cerr<<fg<<\"*\"<<tp<<endl;\n\t\tfor(i = 0;i <= n + m;++i){\n\t\t\tif(i == 14) cerr<<\"*\";\n\t\t\tfor(j = 0;j <= cnt;++j) cerr<<p[i][j]<<\" \";cerr<<endl;\n\t\t}\n\t\tcerr<<endl;\n\t\tsystem(\"pause\");*/\n\t}\n\tprint((li)(-p[0][0] + 0.5l));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,\"Line:\",__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\nvoid print(ll x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nint mask(int i){\n\treturn (int(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n    static random_device rd;\n    static mt19937_64 gen(rd());\n    #endif\n    return uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\n//AGC034D\n//負辺あったら壊れるからBellman-Fordとかやるといいんじゃない？\ntemplate<class D>\nstruct mincf{\n\tusing P=pair<D,int>;\n\tstruct E{int to,rev,cap;D cost;};\n\tint n;\n\tvvc<E> g;\n\tvc<D> h,d;\n\tvi pv,pe;\n\tmincf(int nn):n(nn),g(n),h(n),d(n),pv(n),pe(n){}\n\tvoid ae(int a,int b,int cap,D cost){\n\t\tg[a].pb({b,(int)g[b].size(),cap,cost});\n\t\tg[b].pb({a,(int)g[a].size()-1,0,-cost});\n\t}\n\tP go(int s,int t,int f){\n\t\tpriority_queue<P,vc<P>,greater<P>> q;\n\t\tfill(all(d),inf);\n\t\td[s]=0;\n\t\tq.push(P(0,s));\n\t\twhile(q.size()){\n\t\t\tD a;\n\t\t\tint v;\n\t\t\ttie(a,v)=q.top();q.pop();\n\t\t\tif(d[v]<a)continue;\n\t\t\trep(i,(int)g[v].size()){\n\t\t\t\tE e=g[v][i];\n\t\t\t\tif(e.cap>0){\n\t\t\t\t\tD w=d[v]+e.cost+h[v]-h[e.to];\n\t\t\t\t\tif(w<d[e.to]){\n\t\t\t\t\t\td[e.to]=w;\n\t\t\t\t\t\tq.push(P(w,e.to));\n\t\t\t\t\t\tpv[e.to]=v;\n\t\t\t\t\t\tpe[e.to]=i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(d[t]==inf)return P(0,0);\n\t\trep(i,n)\n\t\t\th[i]=min(h[i]+d[i],inf);\n\t\tint a=f;\n\t\tfor(int v=t;v!=s;v=pv[v])\n\t\t\tchmin(a,g[pv[v]][pe[v]].cap);\n\t\tfor(int v=t;v!=s;v=pv[v]){\n\t\t\tE& e=g[pv[v]][pe[v]];\n\t\t\te.cap-=a;\n\t\t\tg[e.to][e.rev].cap+=a;\n\t\t}\n\t\treturn P(a*h[t],a);\n\t}\n\tD calc(int s,int t,int f){\n\t\tD res=0;\n\t\twhile(f>0){\n\t\t\tP w=go(s,t,f);\n\t\t\tif(w.b==0)\n\t\t\t\treturn inf;\n\t\t\tf-=w.b;\n\t\t\tres+=w.a;\n\t\t}\n\t\treturn res;\n\t}\n};\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tconst int v=ten(15);\n\t\n\tint n;cin>>n;\n\tvc<tuple<int,int,int>> z;\n\trep(i,n){\n\t\tint x,y,w;cin>>x>>y>>w;\n\t\tz.eb(x,y,w);\n\t}\n\t\n\tint m;cin>>m;\n\tvc<tuple<char,int,int>> c;\n\trep(i,m){\n\t\tstring t;\n\t\tint a,b;\n\t\tcin>>t>>a>>b;\n\t\tc.eb(t[0],a,b);\n\t}\n\t\n\tint ans=0;\n\t\n\trng(k,1,n+1){\n\t\tconst int s=102;\n\t\t\n\t\tmincf<int> mcf(1+s+s+1);\n\t\t\n\t\tvi lwx(s-1,0),upx(s-1,k);\n\t\tvi lwy(s-1,0),upy(s-1,k);\n\t\t\n\t\tfor(auto d:c){\n\t\t\tchar t;\n\t\t\tint a,b;\n\t\t\ttie(t,a,b)=d;\n\t\t\t\n\t\t\tif(t=='L'){\n\t\t\t\tchmax(lwx[a],k-b);\n\t\t\t}else if(t=='R'){\n\t\t\t\tchmin(upx[a-1],b);\n\t\t\t}else if(t=='D'){\n\t\t\t\tchmin(upy[a],b);\n\t\t\t}else if(t=='U'){\n\t\t\t\tchmax(lwy[a-1],k-b);\n\t\t\t}else\n\t\t\t\tassert(false);\n\t\t}\n\t\t\n\t\tbool ok=true;\n\t\trep(i,s-1)if(lwx[i]>upx[i]){\n\t\t\tok=false;\n\t\t}\n\t\trep(i,s-1)if(lwy[i]>upy[i]){\n\t\t\tok=false;\n\t\t}\n\t\tif(!ok)break;\n\t\t\n\t\tint f=k;\n\t\trep(i,s-1){\n\t\t\tmcf.ae(1+i,1+i+1,upx[i]-lwx[i],0);\n\t\t\tf+=lwx[i];\n\t\t\tmcf.ae(1+i,1+s+s,lwx[i],0);\n\t\t\tmcf.ae(0,1+i+1,lwx[i],0);\n\t\t}\n\t\tmcf.ae(0,1,k,0);\n\t\t\n\t\trep(i,s-1){\n\t\t\tmcf.ae(1+s+i,1+s+i+1,upy[i]-lwy[i],0);\n\t\t\tf+=lwy[i];\n\t\t\tmcf.ae(1+s+i,1+s+s,lwy[i],0);\n\t\t\tmcf.ae(0,1+s+i+1,lwy[i],0);\n\t\t}\n\t\tmcf.ae(1+s+s-1,1+s+s,k,0);\n\t\t\n\t\tfor(auto waf:z){\n\t\t\tint x,y,w;tie(x,y,w)=waf;\n\t\t\tmcf.ae(1+x,1+s+y,1,v-w);\n\t\t}\n\t\t\n\t\tint cost=mcf.calc(0,1+s+s,f);\n\t\tchmax(ans,v*k-cost);\n\t}\n\t\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace __gnu_pbds;\nusing namespace std;\n \ntemplate <typename T>\nusing ordered_set =\n\ttree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n \n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n\t*this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n \n#define shandom_ruffle random_shuffle\n \nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=327;\nusing bn=bitset<87>;\nusing ld=long double;\n\nint n;\npii gdz[nax];\nll war[nax];\n\nint m;\nbn podz[nax];\nint ile[nax];\n\nll wyn;\n\nstruct Simplex {        // Maximize c*x subject to Ax <= b.\n  using T = ld;     // Initialize the structure, set A, b, c and then run\n  vector<vector<T>> A;  // solve(). Max objective is stored in res. To recover\n  vector<T> b, c;       // the best result, use getVars().\n  int V, E;\n  vector<int> eqIds, varIds, cols;\n  T res;\n  static constexpr T kEps = 1e-18;\n\n  Simplex(int vars, int eqs) : A(eqs, vector<T>(vars)), b(eqs), c(vars),\n      V(vars), E(eqs), eqIds(eqs), varIds(vars), res(0) {\n    iota(varIds.begin(), varIds.end(), 0);\n    iota(eqIds.begin(), eqIds.end(), vars);\n  }\n\n  void pivot(int eq, int var) {\n    T coef = 1 / A[eq][var];\n    cols.clear();\n    for (int i = 0; i < V; i++) {\n      if (abs(A[eq][i]) > kEps) { cols.push_back(i); A[eq][i] *= coef; }\n    }\n    A[eq][var] *= coef; b[eq] *= coef;\n    for (int row = 0; row < E; row++) {\n      if (row == eq || abs(A[row][var]) < kEps) { continue; }\n      T k = -A[row][var];\n      A[row][var] = 0;\n      for (int i : cols) { A[row][i] += k * A[eq][i]; }\n      b[row] += k * b[eq];\n    }\n    T q = c[var]; c[var] = 0;\n    for (int i : cols) { c[i] -= q * A[eq][i]; }\n    res += q * b[eq];\n    swap(varIds[var], eqIds[eq]);\n  }\n\n  bool solve() {\n    while (true) {\n      int eq = -1, var = -1;\n      for (int i = 0; i < E; i++) { if (b[i] < -kEps) { eq = i; break; } }\n      if (eq == -1) { break; }\n      for (int i = 0; i < V; i++) { if (A[eq][i] < -kEps) { var = i; break; } }\n      if (var == -1) { res = -1e9; return false; /* No solution */ }\n      pivot(eq, var);\n    }\n    while (true) {\n      int var = -1, eq = -1;\n      for (int i = 0; i < V; i++) { if (c[i] > kEps) { var = i; break; } }\n      if (var == -1) { break; }\n      for (int i = 0; i < E; i++) {\n        if (A[i][var] < kEps) { continue; }\n        if (eq >= 0 && b[i] / A[i][var] >= b[eq] / A[eq][var]) { continue; }\n        eq = i;\n      }\n      if (eq == -1) { res = 1e9; return false; /* Unbounded */ }\n      pivot(eq, var);\n    }\n    return true;\n  }\n\n  vector<T> getVars() { // Optimal assignment of variables.\n    vector<T> result(V);\n    for (int i = 0; i < E; i++) if (eqIds[i] < V) result[eqIds[i]] = b[i];\n    return result;\n  }\n};\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(\"%d%d%lld\", &gdz[i].first, &gdz[i].second, &war[i]);\n\tscanf(\"%d\", &m);\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\tchar c;\n\t\tint a, b;\n\t\tscanf(\" %c%d%d\", &c, &a, &b);\n\t\tfor (int j=1; j<=n; j++)\n\t\t{\n\t\t\tif (c=='L' && gdz[j].first<=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='R' && gdz[j].first>=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='D' && gdz[j].second<=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='U' && gdz[j].second>=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t}\n\t\tile[i]=b;\n\t}\n\tSimplex janusz(n, m+2*n);\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tjanusz.c[i]=war[i+1];\n\t}\n\tfor (int i=0; i<m; i++)\n\t{\n\t\tjanusz.b[i]=ile[i+1];\n\t\tfor (int j=0; j<n; j++)\n\t\t\tjanusz.A[i][j]=podz[i+1][j+1];\n\t}\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tjanusz.b[m+i]=1;\n\t\tjanusz.A[m+i][i]=1;\n\t}\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tjanusz.b[m+n+i]=0;\n\t\tjanusz.A[m+n+i][i]=-1;\n\t}\n\tassert(janusz.solve());\n\tld wez=janusz.res;\n\tdebug() << imie(wez);\n\tdebug() << janusz.getVars();\n\tprintf(\"%lld\\n\", llround(wez));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define pint pair<int,int>\n#define mk(x,y) make_pair(x,y)\n#define fir first\n#define sec second\n#define Rep(x,y,z) for(int x=y;x<=z;++x)\n#define Red(x,y,z) for(int x=y;x>=z;--x)\nusing namespace std;\nconst int MAXN=1e3+5,MAXM=1e6+5;\nchar buf[1<<12],*p1=buf,*p2=buf,nc;int ny;\n//inline char gc() {return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<12,stdin),p1==p2)?EOF:*p1++;}\ninline char gc(){return getchar();}\ninline ll read(){\n\tll x=0;ny=1;while(nc=gc(),(nc<48||nc>57)&&nc!=EOF)if(nc==45)ny=-1;if(nc<0)return nc;\n\tx=nc-48;while(nc=gc(),47<nc&&nc<58&&nc!=EOF)x=(x<<3)+(x<<1)+(nc^48);return x*ny;\n}\nstruct Edge{int to,next,w;ll c;}edges[MAXM];\nint cnt,head[MAXN],cur[MAXN],vis[MAXN],S,T,mf;ll dis[MAXN],mc;\ninline void add(int x,int y,int w,ll c){\n\tedges[++cnt]=(Edge){y,head[x],w,c},head[x]=cnt;\n\tedges[++cnt]=(Edge){x,head[y],0,-c},head[y]=cnt;\n}inline bool bfs(){\n\tqueue<int>q;q.push(S),memset(dis,-0x3f,sizeof(dis)),memcpy(cur,head,sizeof(head)),memset(vis,0,sizeof(vis)),dis[S]=0;\n\tfor(int x;!q.empty();q.pop()){\n\t\tx=q.front(),vis[x]=0;\n\t\tfor(int i=head[x],y;i;i=edges[i].next)\n\t\t\tif(edges[i].w&&dis[y=edges[i].to]<dis[x]+edges[i].c)dis[y]=dis[x]+edges[i].c,!vis[y]?q.push(y),0:0;\n\t}return dis[T]>0;\n}int dfs(int x,int dist){\n\tif(x==T||!dist)return dist;int z=0;vis[x]=1;\n\tfor(int&i=cur[x],y,k;i;i=edges[i].next)if(edges[i].w&&dis[y=edges[i].to]==dis[x]+edges[i].c&&!vis[y]){\n\t\tk=dfs(y,min(dist,edges[i].w)),z+=k,dist-=k,edges[i].w-=k,edges[i^1].w+=k;\n\t\tif(!dist)break;\n\t}return z;\n}inline void MCMF(){mc=mf=0;for(int t=0;bfs();)t=dfs(S,1e9),mc+=dis[T]*t,mf+=t;}\nint x[MAXN],y[MAXN],a[MAXN],b[MAXN],lx[MAXN],rx[MAXN],ly[MAXN],ry[MAXN],n,m;char ty[MAXN];ll v[MAXN],ans;\ninline void Solve(int k){\n\tmemset(head,0,sizeof(head)),cnt=1;\n\tRep(i,1,n)add(x[i],i+200,1,v[i]),add(i+200,y[i]+100,1,0);\n\tRep(i,1,k)lx[i]=ly[i]=1,rx[i]=ry[i]=100;\n\tRep(i,1,m){\n\t\tif(ty[i]=='L')lx[b[i]+1]=max(lx[b[i]+1],a[i]+1);\n\t\tif(ty[i]=='R'&&b[i]<k)rx[k-b[i]]=min(rx[k-b[i]],a[i]-1);\n\t\tif(ty[i]=='D')ly[b[i]+1]=max(ly[b[i]+1],a[i]+1);\n\t\tif(ty[i]=='U'&&b[i]<k)ry[k-b[i]]=min(ry[k-b[i]],a[i]-1);\n\t}Rep(i,1,k)lx[i]=max(lx[i],lx[i-1]),ly[i]=max(ly[i],ly[i-1]);\n\tRed(i,k-1,1)rx[i]=min(rx[i],rx[i+1]),ry[i]=min(ry[i],ry[i+1]);\n\tS=MAXN-2,T=MAXN-1;\n\tRep(i,1,k){\n\t\tif(lx[i]>rx[i]||ly[i]>ry[i])return;\n\t\tadd(S,i+n+200,1,0),add(i+n+k+200,T,1,0);\n\t\tRep(j,lx[i],rx[i])add(i+n+200,j,1,0);Rep(j,ly[i],ry[i])add(j+100,i+n+k+200,1,0);\n\t}MCMF();if(mf!=k)return;ans=max(ans,mc);\n}\nint main(){\n//\tfreopen(\"std.in\",\"r\",stdin);\n//\tfreopen(\"std.out\",\"w\",stdout);\n\tn=read();Rep(i,1,n)x[i]=read(),y[i]=read(),v[i]=read();\n\tm=read();Rep(i,1,m)cin>>ty[i],a[i]=read(),b[i]=read();\n\tRep(i,1,n)Solve(i);cout<<ans<<\"\\n\";\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cmath>\n#include<cstdlib>\n#define LL long long\n#define LD long double\nusing namespace std;\nconst int NN=90;\nconst int MM=10000 +117;\nint read(){\n\tint fl=1,x;char c;\n\tfor(c=getchar();(c<'0'||c>'9')&&c!='-';c=getchar());\n\tif(c=='-'){fl=-1;c=getchar();}\n\tfor(x=0;c>='0'&&c<='9';c=getchar())\n\t\tx=(x<<3)+(x<<1)+c-'0';\n\treturn x*fl;\n}\nvoid open(){\n\tfreopen(\"a.in\",\"r\",stdin);\n\t//freopen(\"a.out\",\"w\",stdout);\n}\nvoid close(){\n\tfclose(stdin);\n\tfclose(stdout);\n}\n\n\nint m,n;\nint pos[NN][2]={};\nLL v[NN]={};\nstruct node{\n\tint l,r;\n}x[NN],y[NN]={};\nint q[NN][3]={};\nint f[300]={};\nint p[4*NN]={};\nint ecnt=0;\nint pcnt=0;\nint st,fin;\nint maxf;\nLL minc;\nstruct edge{\n\tint to,xt,rem;\n\tLL ct;\n}e[6*NN*NN]={};\nvoid ADD(int a,int b,int rem,LL ct){\n\t++ecnt;\n\te[ecnt].to=b;\n\te[ecnt].xt=p[a];\n\te[ecnt].rem=rem;\n\te[ecnt].ct=ct;\n\tp[a]=ecnt;\n}\nvoid add(int a,int b,int rem,LL ct){\n\t//cerr<<\"from \"<<a<<\" to \"<<b<<\" cap:\"<<rem<<\" cost:\"<<ct<<endl;\n\tADD(a,b,rem,ct);\n\tADD(b,a,0,-ct);\n}\nLL sp[4*NN]={};\nint pre[4*NN]={};\nbool inq[4*NN]={};\nqueue<int> qu;\nbool spfa(){\n\tfor(int i=1;i<=pcnt;++i){\n\t\tsp[i]=1e18;\n\t}\n\tsp[st]=0;\n\tqu.push(st);\n\twhile(!qu.empty()){\n\t\tint x=qu.front();\n\t\tqu.pop();\n\t\tinq[x]=0;\n\t\tfor(int pos=p[x];pos;pos=e[pos].xt){\n\t\t\tint cur=e[pos].to;\n\t\t\tif(e[pos].rem&&e[pos].ct+sp[x]<sp[cur]){\n\t\t\t\tsp[cur]=sp[x]+e[pos].ct;\n\t\t\t\tpre[cur]=pos;\n\t\t\t\tif(!inq[cur]){\n\t\t\t\t\tqu.push(cur);\n\t\t\t\t\tinq[cur]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn sp[fin]!=1e18;\n}\nvoid getf(){\n\tmaxf=0;\n\tminc=0;\n\twhile(spfa()){\n\t\tmaxf+=1;\n\t\tminc+=sp[fin];\n\t\tint pos=fin;\n\t\twhile(pos!=st){\n\t\t\tint id=pre[pos];\n\t\t\te[id].rem-=1;\n\t\t\te[id^1].rem+=1;\n\t\t\tpos=e[id^1].to;\n\t\t}\n\t}\n}\nLL solve(int all){\n\tfor(int i=1;i<=all;++i){\n\t\tx[i].l=0;\n\t\tx[i].r=1e9;\n\t\ty[i].l=0;\n\t\ty[i].r=1e9;\n\t}\n\tfor(int i=1;i<=m;++i){\n\t\tint a=q[i][1];\n\t\tint b=q[i][2];\n\t\tswitch(q[i][0]){\n\t\t\tcase 0:\n\t\t\tx[b+1].l=max(x[b+1].l,a+1);\n\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\tif(all>b)x[all-b].r=min(x[all-b].r,a);\n\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\ty[b+1].l=max(y[b+1].l,a+1);\n\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\tif(all>b)y[all-b].r=min(y[all-b].r,a);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=2;i<=all;++i){\n\t\tx[i].l=max(x[i-1].l,x[i].l);\n\t\ty[i].l=max(y[i-1].l,y[i].l);\n\t}\n\tfor(int i=all-1;i>=1;--i){\n\t\tx[i].r=min(x[i+1].r,x[i].r);\n\t\ty[i].r=min(y[i+1].r,y[i].r);\n\t}\n\tfor(int i=1;i<=all;++i){\n\t\tif(x[i].l>x[i].r||y[i].l>y[i].r)return -1;\n\t}\n\tst=2*n+2*all+1;\n\tfin=st+1;\n\tecnt=1;\n\tpcnt=fin;\n\tfor(int i=1;i<=pcnt;++i)p[i]=0;\n\tfor(int i=1;i<=n;++i){\n\t\tadd(i,n+i,1,-v[i]);\n\t}\n\tfor(int i=1;i<=all;++i){\n\t\tadd(st,2*n+i,1,0);\n\t\tadd(2*n+all+i,fin,1,0);\n\t\tfor(int j=1;j<=n;++j){\n\t\t\tif(x[i].l<=pos[j][0]&&pos[j][0]<=x[i].r){\n\t\t\t\tadd(2*n+i,j,1,0);\n\t\t\t}\n\t\t\tif(y[i].l<=pos[j][1]&&pos[j][1]<=y[i].r){\n\t\t\t\tadd(n+j,2*n+all+i,1,0);\n\t\t\t}\n\t\t}\n\t}\n\tgetf();\n\tif(maxf==all)return -minc;\n\telse return -1;\n}\nint lix[NN]={};\nint liy[NN]={};\nchar getc(){\n\tchar c=getchar();\n\twhile(c==' '||c=='\\n'||c=='\\r')c=getchar();\n\treturn c;\n}\nint main(){\n\t//open();\n\tn=read();\n\tfor(int i=1;i<=n;++i){\n\t\tlix[i]=pos[i][0]=read();\n\t\tliy[i]=pos[i][1]=read();\n\t\tscanf(\"%lld\",&v[i]);\n\t}\n\tsort(lix+1,lix+1+n);\n\tsort(liy+1,liy+1+n);\n\tf['L']=0;\n\tf['R']=1;\n\tf['D']=2;\n\tf['U']=3;\n\tm=read();\n\tfor(int i=1;i<=m;++i){\n\t\tq[i][0]=f[getc()];\n\t\tq[i][1]=read()-(q[i][0]&1);\n\t\tq[i][2]=read();\n\t\t/*if(q[i][0]&2){\n\t\t\tq[i][1]=upper_bound(liy+1,liy+1+n,q[i][1])-liy-1;\n\t\t}\n\t\telse{\n\t\t\tq[i][1]=upper_bound(lix+1,lix+1+n,q[i][1])-lix-1;\n\t\t}*/\n\t}\n\tLL ans=0;\n\tfor(int i=1;i<=n;++i){\n\t\tLL tp=solve(i);\n\t\t//cerr<<tp<<endl;\n\t\tans=max(ans,tp);\n\t}\n\tprintf(\"%lld\\n\",ans);\n\tclose();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef HOME\n#define db(x) cerr << #x << \" = \" << x << endl\n#define db3(x, y, z) cerr << \"(\" << #x << \", \" << #y << \", \" << #z << \") = (\" << x << \", \" << y << \", \" << z << \")\" << endl\n#define db2(x, y) cerr << \"(\" << #x << \", \" << #y << \") = (\" << x << \", \" << y << \")\" << endl\n#define dbv(a) cerr << #a << \" = \"; for (auto xxx: a) cerr << xxx  << \" \"; cerr << endl\n#else\n#define db(x) ;\n#define db3(x, y, z) ;\n#define db2(x, y) ;\n#define dbv(a) ;\n#endif\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double dbl;\n\n\nconst int INF = 1.01e9;\nconst int MOD = (int)1e9 + 7;\n\nstruct Item {\n    int x, y;\n    ll val;\n};\n\nstruct Cond {\n    char type;\n    int a, b;\n\n    bool cover(Item it) {\n        if (type == 'L') {\n            return it.x <= a;\n        }\n        if (type == 'R') {\n            return it.x >= a;\n        }\n        if (type == 'D') {\n            return it.y <= a;\n        }\n        if (type == 'U') {\n            return it.y >= a;\n        }\n        assert(0);\n    }\n};\n\nll slow(vector<Item> a, vector<Cond> b) {\n    int n = a.size(), m = b.size();\n    ll ans = 0;\n    for (int mask = 0; mask < (1 << n); mask++) {\n        vector<int> cnt(m);\n        ll sum = 0;\n        for (int i = 0; i < n; i++) {\n            if (!(mask & (1 << i))) continue;\n            sum += a[i].val;\n            for (int j = 0; j < m; j++) {\n                if (b[j].cover(a[i])) {\n                    cnt[j]++;\n                }\n            }\n        }\n        bool bad = 0;\n        for (int i = 0; i < m; i++) {\n            if (cnt[i] > b[i].b) {\n                bad = 1;\n            }\n        }\n        if (bad) continue;\n        ans = max(ans, sum);\n    }\n    return ans;\n}\n\n\nbool eq(dbl a, dbl b) {\n    return fabs(a - b) < 1e-9;\n}\n\nbool ls(dbl a, dbl b) {\n    return !eq(a, b) && a < b;\n}\n\nvector<dbl> simplex(vector<vector<dbl> > a) {\n    int n = a.size() - 1;\n    int m = a[0].size() - 1;\n    vector<int> left(n + 1), up(m + 1);\n    iota(up.begin(), up.end(), 0);\n    iota(left.begin(), left.end(), m);\n    auto pivot = [&](int x, int y) {\n        swap(left[x], up[y]);\n        dbl k = a[x][y];\n        a[x][y] = 1;\n        vector<int> vct;\n        for (int j = 0; j <= m; j++) {\n            a[x][j] /= k;\n            if (!eq(a[x][j], 0)) vct.push_back(j);\n        }\n        for (int i = 0; i <= n; i++) {\n            if (eq(a[i][y], 0) || i == x) continue;\n            k = a[i][y];\n            a[i][y] = 0;\n            for (int j : vct) a[i][j] -= k * a[x][j];\n        }\n    };\n    while (1) {\n        int x = -1;\n        for (int i = 1; i <= n; i++) if (ls(a[i][0], 0) && (x == -1 || a[i][0] < a[x][0])) x = i;\n        if (x == -1) break;\n        int y = -1;\n        for (int j = 1; j <= m; j++) if (ls(a[x][j], 0) && (y == -1 || a[x][j] < a[x][y])) y = j;\n        if (y == -1) assert(0); // infeasible\n        pivot(x, y);\n    }\n    while (1) {\n        int y = -1;\n        for (int j = 1; j <= m; j++) if (ls(0, a[0][j]) && (y == -1 || a[0][j] > a[0][y])) y = j;\n        if (y == -1) break;\n        int x = -1;\n        for (int i = 1; i <= n; i++) if (ls(0, a[i][y]) && (x == -1 || a[i][0] / a[i][y] < a[x][0] / a[x][y])) x = i;\n        if (x == -1) assert(0); // unbounded\n        pivot(x, y);\n    }\n    vector<dbl> ans(m + 1);\n    for (int i = 1; i <= n; i++) if (left[i] <= m) ans[left[i]] = a[i][0];\n    ans[0] = -a[0][0];\n    return ans;\n}\n// j=1..m: x[j]>=0\n// i=1..n: sum(j=1..m) A[i][j]*x[j] <= A[i][0]\n// max sum(j=1..m) A[0][j]*x[j]\n// res[0] is answer\n// res[1..m] is certificate\n\nll blyat(vector<Item> a, vector<Cond> b) {\n    int n = a.size(), m = b.size();\n    vector<vector<dbl>> c(m + 1, vector<dbl>(n + 1));\n    for (int i = 0; i < n; i++) {\n        c[0][1 + i] = a[i].val;\n    }\n    for (int i = 0; i < m; i++) {\n        c[1 + i][0] = b[i].b;\n        for (int j = 0; j < n; j++) {\n            if (b[i].cover(a[j])) {\n                c[1 + i][1 + j] = 1;\n            }\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        vector<dbl> cur(n + 1);\n        cur[0] = 1;\n        cur[1 + i] = 1;\n        c.push_back(cur);\n    }\n    auto res = simplex(c);\n//    ll ans = 0;\n//    for (int i = 0; i < n; i++) {\n//        if (res[1 + i] > 0.5) {\n//            ans += a[i].val;\n//        }\n//    }\n//    return ans;\n    int cnt = 0;\n    vector<int> v;\n    for (int i = 0; i < n; i++) {\n        if (!eq(0, res[1 + i]) && !eq(1, res[1 + i])) {\n//            cnt++;\n            v.push_back(i);\n        }\n    }\n    static int mx = 0;\n    cnt = v.size();\n    mx = max(mx, cnt);\n    //db2(cnt, mx);\n\n    ll cres = 0;\n    for (int mask = 0; mask < (1LL << (int)v.size()); mask++) {\n        if (mask > 40) break;\n        vector<int> cov(m);\n        ll cost = 0;\n        for (int i = 0; i < n; i++) {\n            if (eq(1, res[1 + i])) {\n                cost += a[i].val;\n                for (int j = 0; j < m; j++) {\n                    cov[j] += b[j].cover(a[i]);\n                }\n            }\n        }\n        for (int i = 0; i <(int)v.size(); i++) {\n            if (mask & (1 << i)) {\n                cost += a[v[i]].val;\n                for (int j= 0; j < m; j++) {\n                    cov[j] += b[j].cover(a[v[i]]);\n                }\n            }\n        }\n        bool ok = 1;\n        for (int j = 0; j < m; j++) ok &= cov[j] <= b[j].b;\n        if (ok) cres = max(cres, cost);\n    }\n    return cres;\n    return (ll)round(res[0]);\n}\n\nll fast(vector<Item> a, vector<Cond> b) {\n    dbl start = clock() / (dbl)CLOCKS_PER_SEC;\n\n    dbl TL = 1.8;\n    auto fail = [&]() {\n        return clock() / (dbl)CLOCKS_PER_SEC - start > TL;\n    };\n\n    int n = a.size();\n    ll ans = blyat(a, b);\n    for (int i = 0; i < n; i++) {\n        if (fail()) return ans;\n        auto na = a;\n        na.erase(na.begin() + i);\n        ans =max(ans, blyat(na, b));\n    }\n    while (1) {\n        if (fail()) return ans;\n        auto na = a;\n        random_shuffle(na.begin(), na.end());\n        int k = rand() % max(5, n / 6) + 2;\n        k = min(n, k);\n        na.resize(n - k);\n        //na.resize(rand() % (n - (n + 1) / 2) + (n + 1) / 2);\n        ans =max(ans, blyat(na, b));\n    }\n    return ans;\n}\n\nvoid stress() {\n    for (int it = 0;; it++) {\n        mt19937_64 rnd(it);\n        db(it);\n\n\n        int n = rnd() % 15 + 1;\n        vector<Item> a(n);\n        for (int i =0 ; i < n; i++) {\n            a[i].x = rnd() % 100;\n            a[i].y = rnd() % 100;\n            a[i].val = rnd() % (ll)1e15;\n        }\n        int m = rnd() % 15 + 1;\n        vector<Cond> b(m);\n        for (int i = 0; i < m; i++) {\n            b[i].a = rnd() % 100;\n            b[i].b = rnd() % (n + 1);\n            b[i].type = \"ULDR\"[rnd() % 4];\n        }\n\n        auto ans1 = fast(a, b);\n        auto ans2 = slow(a, b);\n        if (ans1 != ans2) {\n            cout << ans1 << \" instead of \" << ans2 << endl;\n            exit(0);\n        }\n    }\n}\n\nint main() {\n#ifdef HOME\n    assert(freopen(\"in\", \"r\", stdin));\n    stress();\n#endif\n\n    int n;\n    while (scanf(\"%d\", &n) == 1) {\n        vector<Item> a(n);\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d%d%lld\", &a[i].x, &a[i].y, &a[i].val);\n        }\n        int m;\n        scanf(\"%d\", &m);\n        vector<Cond> b(m);\n        for (int i = 0; i < m; i++) {\n            scanf(\" %c%d%d\", &b[i].type, &b[i].a, &b[i].b);\n        }\n\n//        printf(\"%lld\\n\", slow(a, b));\n        printf(\"%lld\\n\", fast(a, b));\n    }\n\n#ifdef HOME\n    cerr << \"time: \" << clock() * 1.0 / CLOCKS_PER_SEC << endl;\n#endif\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<double, double> pdd;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\n//const int mod = ;\n\nstruct J {\n  int x, y, ind;\n  ll cost;\n};\n\nvi dx(100, 100), ux(100, 100), dy(100, 100), uy(100, 100);\nvector<J> v;\nvi best;\nll best_score = 0;\n\nll eval(const vi& x) {\n  ll score = 0;\n  for (int i = 0; i < v.size(); ++i) score += v[i].cost * x[i];\n  return score;\n}\n\nvoid update(const vi& x) {\n  ll score = eval(x);\n  if (score > best_score) {\n    best = x;\n    best_score = score;\n  }\n}\n\nint tmpx[100], tmpy[100];\nbool valid_add(int ind, const vi& x) {\n  memset(tmpx, 0, sizeof(tmpx));\n  memset(tmpy, 0, sizeof(tmpy));\n  for (int i = 0; i < x.size(); ++i) if (x[i] || i == ind) {\n    tmpx[v[i].x]++;\n    tmpy[v[i].y]++;\n  }\n  int sx = 0;\n  for (int i = 0; i < 100; ++i) {\n    sx += tmpx[i];\n    if (sx > dx[i]) return false;\n  }\n  sx = 0;\n  for (int i = 99; i >= 0; --i) {\n    sx += tmpx[i];\n    if (sx > ux[i]) return false;\n  }\n  int sy = 0;\n  for (int i = 0; i < 100; ++i) {\n    sy += tmpy[i];\n    if (sy > dy[i]) return false;\n  }\n  sy = 0;\n  for (int i = 99; i >= 0; --i) {\n    sy += tmpy[i];\n    if (sy > uy[i]) return false;\n  }\n  return true;\n}\n\nvoid greedy(int type) {\n  vector<J> ts = v;\n  if (type == 0) {\n    sort(ts.rbegin(), ts.rend(), [&](const auto& a, const auto& b){return a.cost < b.cost;});\n  } else {\n    vd mulx(v.size(), 1e-10), muly(v.size(), 1e-10);\n    vd mul(v.size());\n    for (int i = 0; i < v.size(); ++i) {\n      for (int x = v[i].x; x < 100; ++x) if (ux[x] != 100) {\n        mulx[i] += 1. / ux[x];\n      }\n      for (int x = 0; x <= v[i].x; ++x) if (dx[x] != 100) {\n        mulx[i] += 1. / dx[x];\n      }\n      for (int y = v[i].y; y < 100; ++y) if (uy[y] != 100) {\n        muly[i] += 1. / uy[y];\n      }\n      for (int y = 0; y <= v[i].y; ++y) if (dy[y] != 100) {\n        muly[i] += 1. / dy[y];\n      }\n      if (type == 1) {\n        mul[i] = 1. / (mulx[i] + muly[i]);\n      } else if (type == 2) {\n        mul[i] = 1. / (mulx[i]);\n      } else if (type == 3) {\n        mul[i] = 1. / (muly[i]);\n      } else if (type == 5) {\n        mul[i] = 1. / sqrt(mulx[i] + muly[i]);\n      }\n    }\n    sort(ts.rbegin(), ts.rend(), [&](const auto& a, const auto& b){return a.cost * mul[a.ind] < b.cost * mul[b.ind];});\n  }\n  vi x(v.size());\n  for (int i = 0; i < ts.size(); ++i) {\n    int ind = ts[i].ind;\n    if (valid_add(ind, x)) {\n//      cerr << ind << endl;\n      x[ind] = 1;\n    }\n  }\n  update(x);\n}\n\nint main() {\n  std::ios::sync_with_stdio(false); std::cin.tie(0);\n  int n;\n  cin >> n;\n  v.resize(n);\n  for (int i = 0; i < n; ++i) {\n    cin >> v[i].x >> v[i].y >> v[i].cost;\n    --v[i].x; --v[i].y;\n    v[i].ind = i;\n  }\n  int m;\n  cin >> m;\n  for (int i = 0; i < m; ++i) {\n    string t;\n    int a, b;\n    cin >> t >> a >> b;\n    --a;\n    if (t == \"L\") {\n      dx[a] = b;\n    }\n    if (t == \"R\") {\n      ux[a] = b;\n    }\n    if (t == \"D\") {\n      dy[a] = b;\n    }\n    if (t == \"U\") {\n      uy[a] = b;\n    }\n  }\n  for (int t = 0; t < 6; ++t) {\n    greedy(t);\n  }\n  cout << best_score << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\ntypedef long double T; // long double, Rational, double + mod<P>...\ntypedef vector<T> vd;\ntypedef vector<vd> vvd;\n\nconst T eps = 1e-18, inf = 1/.0;\n#define MP make_pair\n#define ltj(X) if(s == -1 || MP(X[j],N[j]) < MP(X[s],N[s])) s=j\n\nstruct LPSolver {\n\tint m, n;\n\tvi N, B;\n\tvvd D;\n\n\tLPSolver(const vvd& A, const vd& b, const vd& c) :\n\t\tm(sz(b)), n(sz(c)), N(n+1), B(m), D(m+2, vd(n+2)) {\n\t\t\trep(i,0,m) rep(j,0,n) D[i][j] = A[i][j];\n\t\t\trep(i,0,m) { B[i] = n+i; D[i][n] = -1; D[i][n+1] = b[i];}\n\t\t\trep(j,0,n) { N[j] = j; D[m][j] = -c[j]; }\n\t\t\tN[n] = -1; D[m+1][n] = 1;\n\t\t}\n\n\tvoid pivot(int r, int s) {\n\t\tT *a = D[r].data(), inv = 1 / a[s];\n\t\trep(i,0,m+2) if (i != r && abs(D[i][s]) > eps) {\n\t\t\tT *b = D[i].data(), inv2 = b[s] * inv;\n\t\t\trep(j,0,n+2) b[j] -= a[j] * inv2;\n\t\t\tb[s] = a[s] * inv2;\n\t\t}\n\t\trep(j,0,n+2) if (j != s) D[r][j] *= inv;\n\t\trep(i,0,m+2) if (i != r) D[i][s] *= -inv;\n\t\tD[r][s] = inv;\n\t\tswap(B[r], N[s]);\n\t}\n\n\tbool simplex(int phase) {\n\t\tint x = m + phase - 1;\n\t\tfor (;;) {\n\t\t\tint s = -1;\n\t\t\trep(j,0,n+1) if (N[j] != -phase) ltj(D[x]);\n\t\t\tif (D[x][s] >= -eps) return true;\n\t\t\tint r = -1;\n\t\t\trep(i,0,m) {\n\t\t\t\tif (D[i][s] <= eps) continue;\n\t\t\t\tif (r == -1 || MP(D[i][n+1] / D[i][s], B[i])\n\t\t\t\t             < MP(D[r][n+1] / D[r][s], B[r])) r = i;\n\t\t\t}\n\t\t\tif (r == -1) return false;\n\t\t\tpivot(r, s);\n\t\t}\n\t}\n\n\tT solve(vd &x) {\n\t\tint r = 0;\n\t\trep(i,1,m) if (D[i][n+1] < D[r][n+1]) r = i;\n\t\tif (D[r][n+1] < -eps) {\n\t\t\tpivot(r, n);\n\t\t\tif (!simplex(2) || D[m+1][n+1] < -eps) return -inf;\n\t\t\trep(i,0,m) if (B[i] == -1) {\n\t\t\t\tint s = 0;\n\t\t\t\trep(j,1,n+1) ltj(D[i]);\n\t\t\t\tpivot(i, s);\n\t\t\t}\n\t\t}\n\t\tbool ok = simplex(1); x = vd(n);\n\t\trep(i,0,m) if (B[i] < n) x[B[i]] = D[i][n+1];\n\t\treturn ok ? D[m][n+1] : inf;\n\t}\n};\n\nint n, m, x[105], y[105];\nll v[105];\n\nvvd A, A1;\nvd t, b, c, b1, c1, xx;\n\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> x[i] >> y[i] >> v[i];\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tt.clear();\n\t\tt.resize(n);\n\t\tt[i] = -1;\n\t\tA.push_back(t);\n\t\tb.push_back(0);\t\n\t\tt.clear();\n\t\tt.resize(n);\n\t\tt[i] = 1;\n\t\tA.push_back(t);\n\t\tb.push_back(1);\t\t\n\t}\n\tcin >> m;\n\tfor (int i = 0; i < m; ++i) {\n\t\tt.clear();\n\t\tt.resize(n);\n\t\tchar f;\n\t\tint a, bb;\n\t\tcin >> f >> a >> bb;\n\t\tif (f == 'L') {\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\tif (x[j] <= a)\n\t\t\t\t\tt[j] = 1;\n\t\t} if (f == 'R') {\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\tif (x[j] >= a)\n\t\t\t\t\tt[j] = 1;\n\t\t} if (f == 'U') {\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\tif (y[j] >= a)\n\t\t\t\t\tt[j] = 1;\n\t\t} if (f == 'D') {\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\tif (y[j] <= a)\n\t\t\t\t\tt[j] = 1;\n\t\t}\n\t\tA.push_back(t);\n\t\tb.push_back(bb);\n\t}\n\tc.resize(n);\n\tfor (int i = 0; i < n; ++i)\n\t\tc[i] = v[i];\n\tll ans = 0;\n\tfor (int i = 0; i <= n; ++i) {\n\t\tA1 = A, b1 = b, c1 = c;\n\t\tfor (int j = 0; j < n; ++j)\n\t\t\tt[j] = 1;\n\t\tA1.push_back(t);\n\t\tb1.push_back(i+20*eps);\n\t\tfor (int j = 0; j < n; ++j)\n\t\t\tt[j] = -1;\n\t\tA1.push_back(t);\n\t\tb1.push_back(-i+20*eps);\n\t\tans = max(ans, (ll)lround(LPSolver(A1, b1, c1).solve(xx)));\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\n#define pb push_back\n#define fir first\n#define sec second\n#define forto(_) for (int e = last[_], v = E[e].to; e; v = E[e = E[e].next].to)\n#define forback(_) for (int _ = T; _ ^ S; _ = pre[_])\n\ntypedef long long LL;\n\nconst int kMaxn = 85, kMaxe = 2e4;\nconst LL kInf64 = 1e15;\n\ntypedef std::pair<int, int> Pii;\ntypedef int IArn[kMaxn];\ntypedef int IArv[kMaxn << 2];\n\nstruct Edge {\n\tint to, capt;\n\tLL cost;\n\tint next;\n} E[kMaxe << 1];\n\nint n, m, tote, S, T;\nIArn X, Y, L, R, U, D;\nIArv last, pre, pree;\nLL V[kMaxn], dist[kMaxn << 2];\nstd::vector<Pii> con[4];\nchar IN[5];\n\ninline void AddEdge(int u, int v, int cap, LL cst) {\n\tE[++tote] = (Edge){v, cap, cst, last[u]}, last[u] = tote;\n\tE[++tote] = (Edge){u, 0, -cst, last[v]}, last[v] = tote;\n}\nLL Mcf();\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d%d%lld\", X + i, Y + i, V + i);\n\t}\n\tscanf(\"%d\", &m);\n\tfor (int i = 0, ai, bi; i < m; i++) {\n\t\tscanf(\"%s%d%d\", IN, &ai, &bi);\n\t\tswitch (IN[0]) {\n\t\t\tcase 'L' :\n\t\t\t\tcon[0].pb(Pii(ai, bi));\n\t\t\t\tbreak;\n\t\t\tcase 'R' :\n\t\t\t\tcon[1].pb(Pii(ai, bi));\n\t\t\t\tbreak;\n\t\t\tcase 'D' :\n\t\t\t\tcon[2].pb(Pii(ai, bi));\n\t\t\t\tbreak;\n\t\t\tcase 'U' :\n\t\t\t\tcon[3].pb(Pii(ai, bi));\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n/*\tfor (int i = 0; i < 4; i++) {\n\t\tstd::vector<Pii> & cur = con[i];\n\t\tif (i & 1) {\n\t\t\tstd::sort(cur.begin(), cur.end(), std::greater<Pii>());\n\t\t} else {\n\t\t\tstd::sort(cur.begin(), cur.end());\n\t\t}\n\t\tint back = 0;\n\t\tfor (auto & p : cur) {\n\t\t\tfor (; back && p.sec <= cur[back - 1].sec; --back);\n\t\t\tcur[back++] = p;\n\t\t}\n\t\tcur.erase(cur.begin() + back, cur.end());\n\t}*/\t\n\tfor (int i = 1; i <= n; i++) {\n\t\tL[i] = D[i] = 1;\n\t}\n\tfor (auto & p : con[0]) {\n\t\tL[p.sec + 1] = p.fir + 1;\n\t}\n\tfor (auto & p : con[2]) {\n\t\tD[p.sec + 1] = p.fir + 1;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tL[i] = std::max(L[i], L[i - 1]);\n\t\tD[i] = std::max(D[i], D[i - 1]);\n\t}\n\n\tLL ans = 0;\n\tfor (int k = 1; k <= n; k++) {\n\t\tfor (int i = 0; i <= k; i++) {\n\t\t\tR[i] = U[i] = 100;\n\t\t}\n\t\tfor (auto & p : con[1]) {\n\t\t\tif (k <= p.sec) continue;\n\t\t\tR[k - p.sec] = p.fir - 1;\n\t\t}\n\t\tfor (auto & p : con[3]) {\n\t\t\tif (k <= p.sec) continue;\n\t\t\tU[k - p.sec] = p.fir - 1;\n\t\t}\n\t\tfor (int i = k - 1; i > 0; i--) {\n\t\t\tR[i] = std::min(R[i + 1], R[i]);\n\t\t\tU[i] = std::min(U[i + 1], U[i]);\n\t\t}\n\n\t\ttote = 1;\n\t\tmemset(last, 0, sizeof last);\n\t\tT = (S = k + n + n + k + 1) + 1;\n\t\tfor (int i = 1; i <= k; i++) {\n\t\t\tAddEdge(S, i, 1, 0);\n\t\t\tAddEdge(k + n + n + i, T, 1, 0);\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tif (L[i] <= X[j] && X[j] <= R[i]) {\n\t\t\t\t\tAddEdge(i, k + j, 1, 0);\n\t\t\t\t}\n\t\t\t\tif (D[i] <= Y[j] && Y[j] <= U[i]) {\n\t\t\t\t\tAddEdge(k + n + j, k + n + n + i, 1, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tAddEdge(k + i, k + n + i, 1, kInf64 - V[i]);\n\t\t}\n\t\tans = std::max(ans, Mcf());\n\t}\n\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n\nbool Spfa() {\n\tstatic std::queue<int> que;\n\tstatic int inque[kMaxn << 2];\n\n\tmemset(pre, 0xff, sizeof pre);\n\tmemset(dist, 0x7f, sizeof dist);\n\n\tfor (dist[S] = 0, que.push(S), inque[S] = 1; !que.empty(); ) {\n\t\tint u = que.front(); que.pop();\n\t\tforto(u) {\n\t\t\tif (E[e].capt > 0 && dist[v] > dist[u] + E[e].cost) {\n\t\t\t\tdist[v] = dist[u] + E[e].cost;\n\t\t\t\tpre[v] = u, pree[v] = e;\n\t\t\t\tif (!inque[v]) {\n\t\t\t\t\tque.push(v), inque[v] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tinque[u] = 0;\n\t}\n\treturn ~pre[T];\n}\n\nLL Mcf() {\n\tLL tot = 0, sumf = 0;\n\twhile (Spfa()) {\n\t\tint flow = 100000;\n\t\tforback(u) {\n\t\t\tflow = std::min(flow, E[pree[u]].capt);\n\t\t}\n\t\ttot += 1ll * flow * dist[T], sumf += flow;\n\t\tforback(u) {\n\t\t\tE[pree[u]].capt -= flow;\n\t\t\tE[pree[u] ^ 1].capt += flow;\n\t\t}\n\t}\n\treturn sumf * kInf64 - tot;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <list>\n#include <time.h>\n#include <math.h>\n#include <random>\n#include <deque>\n#include <queue>\n#include <cassert>\n#include <unordered_map>\n#include <unordered_set>\n#include <iomanip>\n#include <bitset>\n#include <sstream>\n#include <chrono>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef __float128 dbl;\nconst int INF = 1.01e9;\n\n__float128 fabs(__float128 x)\n{\n  if (x < 0) return -x;\n  return x;\n}\n \nconst __float128 EPS = 1e-25;\nbool eq(__float128 x, __float128 y) {\n    return fabs(x - y) < EPS;\n}\nbool ls(__float128 x, __float128 y) {\n    return x < y && !eq(x, y);\n}\n \nvector<__float128> simplex(vector<vector<__float128> > a) {\n    int n = a.size() - 1;\n    int m = a[0].size() - 1;\n    vector<int> left(n + 1), up(m + 1);\n    iota(up.begin(), up.end(), 0);\n    iota(left.begin(), left.end(), m);\n    auto pivot = [&](int x, int y) {\n        swap(left[x], up[y]);\n        __float128 k = a[x][y];\n        a[x][y] = 1;\n        vector<int> vct;\n        for (int j = 0; j <= m; j++) {\n            a[x][j] /= k;\n            if (!eq(a[x][j], 0)) vct.push_back(j);\n        }\n        for (int i = 0; i <= n; i++) {\n            if (eq(a[i][y], 0) || i == x) continue;\n            k = a[i][y];\n            a[i][y] = 0;\n            for (int j : vct) a[i][j] -= k * a[x][j];\n        }\n    };\n    while (1) {\n        int x = -1;\n        for (int i = 1; i <= n; i++) if (ls(a[i][0], 0) && (x == -1 || a[i][0] < a[x][0])) x = i;\n        if (x == -1) break;\n        int y = -1;\n        for (int j = 1; j <= m; j++) if (ls(a[x][j], 0) && (y == -1 || a[x][j] < a[x][y])) y = j;\n        if (y == -1) assert(0); // infeasible\n        pivot(x, y);\n    }\n    while (1) {\n        int y = -1;\n        for (int j = 1; j <= m; j++) if (ls(0, a[0][j]) && (y == -1 || a[0][j] > a[0][y])) y = j;\n        if (y == -1) break;\n        int x = -1;\n        for (int i = 1; i <= n; i++) if (ls(0, a[i][y]) && (x == -1 || a[i][0] / a[i][y] < a[x][0] / a[x][y])) x = i;\n        if (x == -1) assert(0); // unbounded\n        pivot(x, y);\n    }\n    vector<__float128> ans(m + 1);\n    for (int i = 1; i <= n; i++) if (left[i] <= m) ans[left[i]] = a[i][0];\n    ans[0] = -a[0][0];\n    return ans;\n}\n\n#ifdef ONPC\n  mt19937 rnd(228);\n#else\n  mt19937 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\n#endif\n\nint main()\n{\n#ifdef ONPC\n  freopen(\"a.in\", \"r\", stdin);\n#endif\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector <int> x(n), y(n);\n  vector <ll> ok;\n  vector <__float128> v;\n  vector <pair <ll, int> > e;\n  for (int i = 0; i < n; i++)\n  {\n    cin >> x[i] >> y[i];\n    ll x;\n    cin >> x;\n    ok.push_back(x);\n    v.push_back(x);\n    e.push_back({x, i});\n  }\n  v.insert(v.begin(), 0);\n  int m;\n  cin >> m;\n  vector <vector <__float128> > mat;\n  mat.push_back(v);\n  for (int i = 0; i < n; i++)\n  {\n    vector <__float128> kek(n + 1);\n    kek[0] = kek[i + 1] = 1;\n    mat.push_back(kek);\n  }\n  vector <vector <int> > simp;\n  for (int i = 0; i < m; i++)\n  {\n    char c;\n    cin >> c;\n    int a;\n    int b;\n    cin >> a >> b;\n    vector <__float128> arr = {(__float128) b};\n    vector <int> kek = {b};\n    for (int j = 0; j < n; j++)\n    {\n      int grab = 0;\n      if (c == 'L' && x[j] <= a) grab = 1;\n      if (c == 'R' && x[j] >= a) grab = 1;\n      if (c == 'D' && y[j] <= a) grab = 1;\n      if (c == 'U' && y[j] >= a) grab = 1;\n      arr.push_back(grab);\n      kek.push_back(grab);\n    }\n    mat.push_back(arr);\n    simp.push_back(kek);\n  }\n  auto good = [&] (vector <int> grab)\n  {\n    for (auto c : simp)\n    {\n      int sum = 0;\n      for (int i = 1; i <= n; i++) sum += grab[i - 1] * c[i];\n      if (sum > c[0])\n      {\n        return false;\n      }\n    }\n    return true;\n  };\n  auto f = [&] (vector <int> grab)\n  {\n    ll sum = 0;\n    for (int i = 0; i < n; i++)\n    {\n      if (grab[i]) sum += ok[i];\n    }\n    return sum;\n  };\n  vector <int> grab;\n  for (int i = 0; i < n; i++) grab.push_back(0);\n  cout.precision(20);\n  auto solve = [&] ()\n  {\n    auto ret = simplex(mat);\n    sort(e.begin(), e.end());\n    vector <int> me(n);\n    int x = -1;\n    for (int i = 1; i <= n; i++)\n    {\n      if (grab[i - 1]) continue;\n      grab[i - 1] = true;\n      if (!good(grab))\n      {\n        grab[i - 1] = false;\n        continue;\n      }\n      if (x == -1 || ret[i] > ret[x])\n      {\n        x = i;\n      }\n    }\n    if (x == -1 || ret[x] < EPS) return 0ll;\n    x--;\n    me[x] = true;\n    grab[x] = true;\n    if (!good(grab)) grab[x] = false, me[x] = false;\n    int kekos = 0;\n    for (auto &c : mat)\n    {\n      kekos++;\n      if (kekos > n + 1)\n      for (int i = 1; i <= n; i++)\n      {\n        if (me[i - 1] && c[i] > EPS) c[i]--, c[0]--;\n      }\n    }\n    for (int i = 1; i <= n; i++)\n    {\n      if (me[i - 1])\n      {\n        mat[i][0] = 0;\n      }\n    }\n    return ok[x];\n  };\n  ll ans = 0;\n  while (ll t = solve())\n  {\n    ans += t;\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cassert>\n\n#define pb push_back\n#define fir first\n#define sec second\n#define forto(_) for (int e = last[_], v = E[e].to; e; v = E[e = E[e].next].to)\n#define forback(_) for (int _ = T; _ ^ S; _ = pre[_])\n\ntypedef long long LL;\n\nconst int kMaxn = 85, kMaxe = 2e4;\nconst LL kInf64 = 1e15;\n\ntypedef std::pair<int, int> Pii;\ntypedef int IArn[kMaxn];\ntypedef int IArv[kMaxn << 2];\n\nstruct Edge {\n\tint to, capt;\n\tLL cost;\n\tint next;\n} E[kMaxe << 1];\n\nint n, m, tote, S, T;\nIArn X, Y, L, R, U, D;\nIArv last, pre, pree;\nLL V[kMaxn], dist[kMaxn << 2];\nstd::vector<Pii> con[4];\nchar IN[5];\n\ninline void AddEdge(int u, int v, int cap, LL cst) {\n\tE[++tote] = (Edge){v, cap, cst, last[u]}, last[u] = tote;\n\tE[++tote] = (Edge){u, 0, -cst, last[v]}, last[v] = tote;\n\tassert(tote < kMaxe * 2);\n}\nLL Mcf();\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d%d%lld\", X + i, Y + i, V + i);\n\t}\n\tscanf(\"%d\", &m);\n\tfor (int i = 0, ai, bi; i < m; i++) {\n\t\tscanf(\"%s%d%d\", IN, &ai, &bi);\n\t\tswitch (IN[0]) {\n\t\t\tcase 'L' :\n\t\t\t\tcon[0].pb(Pii(ai, bi));\n\t\t\t\tbreak;\n\t\t\tcase 'R' :\n\t\t\t\tcon[1].pb(Pii(ai, bi));\n\t\t\t\tbreak;\n\t\t\tcase 'D' :\n\t\t\t\tcon[2].pb(Pii(ai, bi));\n\t\t\t\tbreak;\n\t\t\tcase 'U' :\n\t\t\t\tcon[3].pb(Pii(ai, bi));\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tL[i] = D[i] = 1;\n\t}\n\tfor (auto & p : con[0]) {\n\t\tL[p.sec + 1] = p.fir + 1;\n\t}\n\tfor (auto & p : con[2]) {\n\t\tD[p.sec + 1] = p.fir + 1;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tL[i] = std::max(L[i], L[i - 1]);\n\t\tD[i] = std::max(D[i], D[i - 1]);\n\t}\n\n\tLL ans = 0;\n\tfor (int k = 1; k <= n; k++) {\n\t\tfor (int i = 1; i <= k; i++) {\n\t\t\tR[i] = U[i] = 100;\n\t\t}\n\t\tfor (auto & p : con[1]) {\n\t\t\tif (k <= p.sec) continue;\n\t\t\tR[k - p.sec] = p.fir - 1;\n\t\t}\n\t\tfor (auto & p : con[3]) {\n\t\t\tif (k <= p.sec) continue;\n\t\t\tU[k - p.sec] = p.fir - 1;\n\t\t}\n\t\tfor (int i = k - 1; i > 0; i--) {\n\t\t\tR[i] = std::min(R[i + 1], R[i]);\n\t\t\tU[i] = std::min(U[i + 1], U[i]);\n\t\t}\n\n\t\ttote = 1;\n\t\tmemset(last, 0, sizeof last);\n\t\tT = (S = k + n + n + k + 1) + 1;\n\t\tfor (int i = 1; i <= k; i++) {\n\t\t\tAddEdge(S, i, 1, 0);\n\t\t\tAddEdge(k + n + n + i, T, 1, 0);\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tif (L[i] <= X[j] && X[j] <= R[i]) {\n\t\t\t\t\tAddEdge(i, k + j, 1, 0);\n\t\t\t\t}\n\t\t\t\tif (D[i] <= Y[j] && Y[j] <= U[i]) {\n\t\t\t\t\tAddEdge(k + n + j, k + n + n + i, 1, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tAddEdge(k + i, k + n + i, 1, kInf64 - V[i]);\n\t\t}\n\n\t\tans = std::max(ans, Mcf());\n\t}\n\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n\nbool Spfa() {\n\tstatic std::queue<int> que;\n\tstatic int inque[kMaxn << 2];\n\n\tmemset(pre, 0xff, sizeof pre);\n\tmemset(dist, 0x7f, sizeof dist);\n\n\tfor (dist[S] = 0, que.push(S), inque[S] = 1; !que.empty(); ) {\n\t\tint u = que.front(); que.pop();\n\t\tforto(u) {\n\t\t\tif (E[e].capt > 0 && dist[v] > dist[u] + E[e].cost) {\n\t\t\t\tdist[v] = dist[u] + E[e].cost;\n\t\t\t\tpre[v] = u, pree[v] = e;\n\t\t\t\tif (!inque[v]) {\n\t\t\t\t\tque.push(v), inque[v] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tinque[u] = 0;\n\t}\n\treturn ~pre[T];\n}\n\nLL Mcf() {\n\tLL tot = 0, sumf = 0;\n\twhile (Spfa()) {\n\t\tint flow = 100000;\n\t\tforback(u) {\n\t\t\tflow = std::min(flow, E[pree[u]].capt);\n\t\t}\n\t\ttot += 1ll * flow * dist[T], sumf += flow;\n\t\tforback(u) {\n\t\t\tE[pree[u]].capt -= flow;\n\t\t\tE[pree[u] ^ 1].capt += flow;\n\t\t}\n\t}\n\treturn sumf * kInf64 - tot;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=505,M=50005,R=100;\nconst ll inf=0x3f3f3f3f3f3f3f3fll;\nint read(){\n\tint f=1,g=0;\n\tchar ch=getchar();\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-') f=-1;\n\tfor (;isdigit(ch);ch=getchar()) g=g*10+ch-'0';\n\treturn f*g;\n}\nvoid chkmax(int &x,int y){if (x<y) x=y;}\nvoid chkmin(int &x,int y){if (x>y) x=y;}\nint n,m;\nstruct jew{int x,y;ll w;}a[N];\nstruct node{char typ;int x,r;}b[N];\nll cost,ans;\nint S,T,cnt,fir[N],fr[N],siz;\nstruct edge{int u,v;ll w;int fl,nex;}e[M];\nvoid add(int u,int v,ll w,int fl){\n\te[++siz]=(edge){u,v,w,fl,fir[u]};fir[u]=siz;\n\te[++siz]=(edge){v,u,-w,0,fir[v]};fir[v]=siz;\n}\nll dist[N];int que[N*50];bool inq[N];\nvoid dec(int x,int fl){e[x].fl-=fl;e[x^1].fl+=fl;}\nbool spfa(){\n\tmemset(dist,0xc0,8*(cnt+1));\n\tmemset(inq,0,cnt+1);\n\tint l=1,r=1;que[l]=S;dist[S]=0;inq[S]=1;\n\twhile (l<=r){\n\t\tint x=que[l];\n\t\tfor (int i=fir[x];i;i=e[i].nex)\n\t\tif ((e[i].fl)&&(dist[e[i].v]<dist[x]+e[i].w)){\n\t\t\tif (!inq[e[i].v]) {que[++r]=e[i].v;inq[e[i].v]=1;}\n\t\t\tdist[e[i].v]=dist[x]+e[i].w;fr[e[i].v]=i;\n\t\t}\n\t\tinq[x]=0;l++;\n\t}\n\treturn dist[T]>(ll)0xc0c0c0c0c0c0c0c0ll;\n}\nint update(){\n\tint t=0x3f3f3f3f;\n\tfor (int i=fr[T];i;i=fr[e[i].u]) t=min(t,e[i].fl);\n\tcost+=t*dist[T];\n\tfor (int i=fr[T];i;i=fr[e[i].u]) dec(i,t);\n\treturn t;\n}\nint dinic(){\n\tint flow=0;\n\twhile (spfa()) flow+=update();\n\treturn flow;\n}\nint ml[N],mr[N],mu[N],md[N];\nvoid calc(int L){\n\tmemset(fir,0,sizeof(fir));siz=1;\n\tS=0;T=cnt=L*2+R*2+1;\n\tfor (int i=1;i<=n;i++) add(a[i].x,a[i].y+R,a[i].w,1);\n\tfor (int i=1;i<=L;i++) {ml[i]=mu[i]=1,mr[i]=md[i]=R;add(S,R*2+i,0,1);add(R*2+L+i,T,0,1);}\n\tfor (int i=1;i<=m;i++)\n\tif (b[i].r>=L) continue;\n\telse if (b[i].typ=='L') chkmax(ml[b[i].r+1],b[i].x+1);\n\telse if (b[i].typ=='R') chkmin(mr[L-b[i].r],b[i].x-1);\n\telse if (b[i].typ=='D') chkmax(mu[b[i].r+1],b[i].x+1);\n\telse if (b[i].typ=='U') chkmin(md[L-b[i].r],b[i].x-1);\n\tfor (int i=2;i<=L;i++) chkmax(ml[i],ml[i-1]),chkmax(mu[i],mu[i-1]);\n\tfor (int i=L-1;i;i--)  chkmin(mr[i],mr[i+1]),chkmin(md[i],md[i+1]);\n\tfor (int i=1;i<=L;i++){\n\t\tfor (int j=ml[i];j<=mr[i];j++) add(R*2+i,j,0,1);\n\t\tfor (int j=mu[i];j<=md[i];j++) add(j+R,R*2+L+i,0,1);\n\t}\n\tcost=0;\n\tif (dinic()==L){\n\t\tans=max(ans,cost);\n\t\tfor (int i=1;i<=n;i++) if (!e[i*2].fl) printf(\"%d \",i);\n\t\tprintf(\"\\n\");\n\t}\n}\nint main(){\n//\tfreopen(\"a.in\",\"r\",stdin);\n\tn=read();\n\tfor (int i=1;i<=n;i++) scanf(\" %d %d %lld\",&a[i].x,&a[i].y,&a[i].w);\n\tm=read();\n\tfor (int i=1;i<=m;i++) scanf(\" %c %d %d\",&b[i].typ,&b[i].x,&b[i].r);\n\tfor (int i=1;i<=n;i++) calc(i);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define IL inline\n#define _ 1005\n#define ll long long\n#define RG register\nusing namespace std ;\n\nIL ll gi() {\n\tRG ll data = 0 , fu = 1 ; RG char ch = 0 ;\n\twhile(ch != '-' && (ch < '0' || ch > '9')) ch = getchar() ; if(ch == '-') fu = -1 , ch = getchar() ;\n\twhile('0' <= ch && ch <= '9') data = (data << 1) + (data << 3) + (ch ^ 48) , ch = getchar() ; return data * fu ;\n}\n\nconst ll extra = 1e15 ;\nconst ll inf = 1e18 ;\n\nstruct _Edge{int to , next , flow ; ll cost ; } Edge[_ * _] ; int head[_] , cur[_] , CNT ;\nIL void AddEdge(int u , int v , int fl , ll cs) {\n\t//cout << u << \" ------------> \" << v << \" ; flow = \" << fl << \" , cost = \" << cs << endl ;\n\tEdge[++ CNT] = (_Edge){v , head[u] , fl , cs} ; head[u] = CNT ;\n\tEdge[++ CNT] = (_Edge){u , head[v] , 0 , -cs} ; head[v] = CNT ; return ; \n}\nstruct Point{int x,y ; ll v ; } p[_] ; bool vis[_] ;\nstruct Limit{char t ; int a,b ; } q[_] ;\nll dis[_],Cost,Ans ; int L[_],U[_],D[_],R[_],n,m,S,T,K,Flow,oo ;\n\nIL bool bfs() {\n\tqueue<int> Q ; \n\tfor(int i = 1; i <= T; i ++) dis[i] = inf , vis[i] = false ;\n\tQ.push(S) ; vis[S] = true ; dis[S] = 0 ;\n\twhile(!Q.empty()) {\n\t\tint u = Q.front() ; Q.pop() ;\n\t\tfor(int e = head[u] ; e ; e = Edge[e].next) {\n\t\t\tint v = Edge[e].to ;\n\t\t\tif(dis[v] > dis[u] + Edge[e].cost && Edge[e].flow > 0) {\n\t\t\t\tdis[v] = dis[u] + Edge[e].cost ;\n\t\t\t\tif(!vis[v]) vis[v] = true , Q.push(v) ;\n\t\t\t}\n\t\t}vis[u] = false ; \n\t}return dis[T] != inf ; \n}\nint dfs(int u , int Lim) {\n\tif(u == T || !Lim) return Lim ;\n\tll flow = 0 , f = 0 ; vis[u] = true ;\n\tfor(int &e = cur[u] ; e ; e = Edge[e].next) {\n\t\tint v = Edge[e].to ;\n\t\tif(!vis[v] && dis[v]==dis[u]+Edge[e].cost && (f = dfs(v,min(Lim,Edge[e].flow))) > 0) {\n\t\t\tflow += f ; Lim -= f ; Edge[e].flow -= f ; Edge[e ^ 1].flow += f ;\n\t\t\tCost += 1ll * flow * Edge[e].cost ;\n\t\t\tif(!Lim) break ;\n\t\t}\n\t}if(!flow) dis[u] = -1 ; vis[u] = false ; return flow ; \n}\n\t\nIL void solve() {\n\tfor(int i = 1; i <= T; i ++) head[i] = 0 ; CNT = 1 ; oo = 0 ;\n\tfor(int i = 1; i <= K ; i ++) L[i] = U[i] = 0 , R[i] = D[i] = 1989 ;\n\tfor(int i = 1; i <= m ; i ++)\n\t\tif(q[i].b < K) {\n\t\t\tif(q[i].t == 'L') L[q[i].b + 1] = max(L[q[i].b + 1] , q[i].a + 1) ;\n\t\t\telse if(q[i].t == 'R') R[K - q[i].b] = min(R[K - q[i].b] , q[i].a - 1) ;\n\t\t\telse if(q[i].t == 'U') U[q[i].b + 1] = max(U[q[i].b + 1] , q[i].a + 1) ;\n\t\t\telse if(q[i].t == 'D') D[K - q[i].b] = min(D[K - q[i].b] , q[i].a - 1) ;\n\t\t}\n\tfor(int i = 2; i <= K; i ++) L[i] = max(L[i] , L[i - 1]) ;\n\tfor(int i = K - 1; i >= 1; i --) R[i] = min(R[i] , R[i + 1]) ;\n\tfor(int i = 2; i <= K; i ++) U[i] = max(U[i] , U[i - 1]) ;\n\tfor(int i = K - 1; i >= 1; i --) D[i] = min(D[i] , D[i + 1]) ;\n\t//for(int i = 1; i <= K; i ++) cout <<\"choice\"<<i<<\":  \"<< L[i] << \" , \" << R[i] << \"   ;   \" << U[i] << \" \" << D[i] << endl ; \n\tS = 2 * (n + K) + 1 ;\n\tT = 2 * (n + K) + 2 ;\n\tfor(int i = 1; i <= K; i ++) AddEdge(S , i , 1 , 0) ;\n\tfor(int i = 1; i <= K; i ++) AddEdge(K + 2 * n + i , T , 1 , 0) ;\n\tfor(int i = 1; i <= K; i ++)\n\t\tfor(int j = 1; j <= n; j ++) {\n\t\t\tif(L[i] <= p[j].x && p[j].x <= R[i]) AddEdge(i , K + j , 1 , 0) ;\n\t\t\tif(U[i] <= p[j].y && p[j].y <= D[i]) AddEdge(K + n + j , K + 2 * n + i , 1 , 0) ;\n\t\t}\n\tfor(int i = 1; i <= n; i ++) AddEdge(K + i , K + n + i , 1 , extra - p[i].v) ;\n\tFlow = 0 ; Cost = 0 ; \n\twhile(bfs()) {\n\t\tfor(int i = 1; i <= T; i ++) cur[i] = head[i] ;\n\t\tFlow += dfs(S , 1e9) ;\n\t}\n\tCost -= 1ll * extra * K ; Cost = -Cost ;\n\tif(Flow == K && Ans < Cost) Ans = Cost ; return ; \n}\n\nint main() {\n\tn = gi() ;\n\tfor(int i = 1; i <= n; i ++) p[i].x = gi() , p[i].y = gi() , p[i].v = gi() ;\n\tm = gi() ;\n    for(int i = 1; i <= m; i ++) scanf(\"%c %d %d\\n\" , &q[i].t , &q[i].a , &q[i].b) ;\n\tfor(int i = 1; i <= m; i ++) if(q[i].t == 'U') q[i].t = 'D' ; else if(q[i].t == 'D') q[i].t = 'U' ;\n\t//for(int i = 1; i <=m; i ++) cout << q[i].t << \" ; a = \" << q[i].a << \" , b = \" << q[i].b << endl ;\n\tAns = 0 ;\n\tK = 4 ; solve() ; cout << Ans << endl ;\n\treturn 0 ; \n\tfor(K = 1; K <= n; ++ K) solve() ;\n\tprintf(\"%lld\\n\" , Ans) ;\n\treturn 0 ; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n#define pa pair<int,int>\nconst int inf=2147483647;\nLL read()\n{\n\tLL x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+(ch^48),ch=getchar();\n\treturn x*f;\n}\nint n,m,st,ed;\nstruct P{int x,y;LL v;}p[85];\nstruct Q{int o,a,b;}q[325];\nchar op[3];\nstruct Edge{int x,y,d,next;LL c;}e[100010];\nint last[450],len;\nvoid ins(int x,int y,int d,LL c)\n{\n\tint t=++len;\n\te[t].x=x;e[t].y=y;e[t].d=d;e[t].c=c;\n\te[t].next=last[x];last[x]=t;\n}\nvoid addedge(int x,int y,int d,LL c){ins(x,y,d,c),ins(y,x,0,-c);}\nLL f[450];int pre[450];bool in[450];\nbool spfa()\n{\n\tmemset(f,-63,sizeof(f));f[st]=0;\n\tmemset(in,false,sizeof(in));\n\tqueue<int>q;q.push(st);\n\twhile(!q.empty())\n\t{\n\t\tint x=q.front();q.pop();in[x]=false;\n\t\tfor(int i=last[x];i;i=e[i].next)\n\t\t{\n\t\t\tint y=e[i].y;\n\t\t\tif(e[i].d>0&&f[x]+e[i].c>f[y])\n\t\t\t{\n\t\t\t\tpre[y]=i;\n\t\t\t\tf[y]=f[x]+e[i].c;\n\t\t\t\tif(!in[y])in[y]=true,q.push(y);\n\t\t\t}\n\t\t}\n\t}\n\tif(f[ed]>0)return true;\n\treturn false;\n}\nLL Ans,ans=0;\nvoid work()\n{\n\tint x=ed;\n\twhile(x!=st)\n\t{\n\t\tAns+=e[pre[x]].c;\n\t\te[pre[x]].d--,e[pre[x]^1].d++;\n\t\tx=e[pre[x]].x;\n\t}\n}\nint lx[85],rx[85],ly[85],ry[85];\nvoid solve(int k)\n{\n\tmemset(last,0,sizeof(last));len=1;\n\tfor(int i=1;i<=n;i++)\n\taddedge(p[i].x,200+i,1,p[i].v),addedge(200+i,100+p[i].y,1,0);\n\tfor(int i=1;i<=k;i++)lx[i]=ly[i]=1,rx[i]=ry[i]=100;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tif(q[i].o==0)lx[q[i].b+1]=max(lx[q[i].b+1],q[i].a+1);\n\t\tif(q[i].o==1&&k>q[i].b)rx[k-q[i].b]=min(rx[k-q[i].b],q[i].a-1);\n\t\tif(q[i].o==2)ly[q[i].b+1]=max(ly[q[i].b+1],q[i].a+1);\n\t\tif(q[i].o==3&&k>q[i].b)ry[k-q[i].b]=min(ry[k-q[i].b],q[i].a-1);\n\t}\n\tfor(int i=2;i<=k;i++)lx[i]=max(lx[i],lx[i-1]),ly[i]=max(ly[i],ly[i-1]);\n\tfor(int i=k-1;i;i--)rx[i]=min(rx[i],rx[i+1]),ry[i]=min(ry[i],ry[i+1]);\n\tst=200+n+2*k+1,ed=st+1;\n\tfor(int i=1;i<=k;i++)\n\t{\n\t\tif(lx[i]>rx[i]||ly[i]>ry[i])return;\n\t\taddedge(st,200+n+i,1,0),addedge(200+n+k+i,ed,1,0);\n\t\tfor(int j=lx[i];j<=rx[i];j++)addedge(200+n+i,j,1,0);\n\t\tfor(int j=ly[i];j<=ry[i];j++)addedge(100+j,200+n+k+i,1,0);\n\t}\n\tint u=0;Ans=0;\n\twhile(spfa())u++,work();\n\tif(u!=k)return;\n\tans=max(ans,Ans);\n}\nint main()\n{\n\tn=read();\n\tfor(int i=1;i<=n;i++)p[i].x=read(),p[i].y=read(),p[i].v=read();\n\tm=read();\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%s\",op);\n\t\tq[i].a=read(),q[i].b=read();\n\t\tif(op[0]=='L')q[i].o=0;\n\t\tif(op[0]=='R')q[i].o=1;\n\t\tif(op[0]=='D')q[i].o=2;\n\t\tif(op[0]=='U')q[i].o=3;\n\t}\n\tfor(int i=1;i<=n;i++)solve(i);\n\tprintf(\"%lld\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 500;\nint n, x[maxn + 10], y[maxn + 10];\nll v[maxn + 10];\nchar t[maxn + 10];\nint a[maxn + 10], b[maxn + 10], m;\nint mnx[maxn + 10], mxx[maxn + 10];\nint mny[maxn + 10], mxy[maxn + 10];\nll res;\n\nnamespace flow {\n\ttypedef long long FlowType, CostType;\n\tconst int maxn = 1e5, maxm = 2e5;\n\tconst FlowType inff = 1e18;\n\tconst CostType infc = 1e18;\n\n\tint n, m, s, t;\n\tvector<int> g[maxn];\n\n\tstruct Edge {\n\t\tint v;\n\t\tFlowType cap, flow;\n\t\tCostType cost;\n\t} edge[maxm << 1];\n\n\tCostType dist[maxn], h[maxn];\n\n\tvoid Init(int _n, int _s, int _t) {\n\t\tn = _n; s = _s; t = _t; m = 0;\n\t\tfor (int i = 0; i <= n; ++i) g[i].clear();\n\t}\n\n\tvoid AddEdge(int u, int v, FlowType cap, CostType cost) {\n\t\tg[u].push_back(m);\n\t\tedge[m++] = (Edge){v, cap, 0, cost};\n\t\tg[v].push_back(m);\n\t\tedge[m++] = (Edge){u, 0, 0, -cost};\n\t}\n\n\tstruct Node {\n\t\tint u;\n\t\tCostType d;\n\t\tbool operator < (const Node &rhs) const {\n\t\t\treturn d > rhs.d;\n\t\t}\n\t};\n\n\tbool Dijkstra(void) {\n\t\tpriority_queue<Node> q;\n\t\tq.push((Node){s, 0});\n\t\tfill(dist, dist + n, infc);\n\t\tdist[s] = 0;\n\t\twhile (!q.empty()) {\n\t\t\tint u = q.top().u;\n\t\t\tCostType d = q.top().d;\n\t\t\tq.pop();\n\t\t\tif (d != dist[u]) continue;\n\t\t\tfor (int i = 0; i < g[u].size(); ++i) {\n\t\t\t\tEdge &e = edge[g[u][i]];\n\t\t\t\tif (e.flow < e.cap) {\n\t\t\t\t\tCostType t = dist[u] + h[u] - h[e.v] + e.cost;\n\t\t\t\t\tif (dist[e.v] > t) {\n\t\t\t\t\t\tdist[e.v] = t;\n\t\t\t\t\t\tq.push((Node){e.v, t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\th[i] = min(h[i] + dist[i], infc);\n\t\t}\n\t\treturn h[t] != infc;\n\t}\n\n\tbool ins[maxn];\n\tint cur[maxn];\n\n\tFlowType Dfs(int u, FlowType f) {\n\t\tif (u == t) return f;\n\t\tins[u] = true;\n\t\tFlowType sum = 0;\n\t\tfor (int &i = cur[u]; i < g[u].size(); ++i) {\n\t\t\tEdge &e = edge[g[u][i]], &r = edge[g[u][i] ^ 1];\n\t\t\tif (e.flow < e.cap && e.cost + h[u] - h[e.v] == 0 && !ins[e.v]) {\n\t\t\t\tFlowType t = Dfs(e.v, min(f - sum, e.cap - e.flow));\n\t\t\t\te.flow += t;\n\t\t\t\tr.flow -= t;\n\t\t\t\tsum += t;\n\t\t\t\tif (sum == f) break;\n\t\t\t}\n\t\t}\n\t\tins[u] = false;\n\t\treturn sum;\n\t}\n\n\tpair<FlowType, CostType> Solve(void) {\n\t\tpair<FlowType, CostType> ans(0, 0);\n\t\tfill(h, h + n, 0);\n\t\tfill(ins, ins + n, false);\n\t\twhile (Dijkstra()) {\n\t\t\tfill(cur, cur + n, 0);\n\t\t\tFlowType f = Dfs(s, inff);\n\t\t\tans.first += f;\n\t\t\tans.second += f * h[t];\n\t\t}\n\t\treturn ans;\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i) scanf(\"%d%d%lld\", &x[i], &y[i], &v[i]);\n\tscanf(\"%d\", &m);\n\tfor (int i = 1; i <= m; ++i) {\n\t\tchar s[10]; scanf(\"%s\", s);\n\t\tt[i] = s[0];\n\t\tscanf(\"%d%d\", &a[i], &b[i]);\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tflow::Init(2 + n * 2 + i * 2 + 1, 1, 2);\n\t\tfor (int j = 1; j <= i; ++j) {\n\t\t\tmnx[j] = 0; mxx[j] = 200;\n\t\t\tmny[j] = 0; mxy[j] = 200;\n\t\t}\n\t\tfor (int j = 1; j <= m; ++j) {\n\t\t\tif (t[j] == 'L') {\n\t\t\t\tfor (int k = b[j] + 1; k <= i; ++k)\n\t\t\t\t\tmnx[k] = max(mnx[k], a[j] + 1);\n\t\t\t} else if (t[j] == 'R') {\n\t\t\t\tfor (int k = i - b[j]; k >= 1; --k)\n\t\t\t\t\tmxx[k] = min(mxx[k], a[j] - 1);\n\t\t\t} else if (t[j] == 'D') {\n\t\t\t\tfor (int k = b[j] + 1; k <= i; ++k)\n\t\t\t\t\tmny[k] = max(mny[k], a[j] + 1);\n\t\t\t} else {\n\t\t\t\tfor (int k = i - b[j]; k >= 1; --k)\n\t\t\t\t\tmxy[k] = min(mxy[k], a[j] - 1);\n\t\t\t}\n\t\t}\n\t\tfor (int j = 1; j <= i; ++j) {\n\t\t\tflow::AddEdge(1, j + 2 + n * 2, 1, 0);\n\t\t\tflow::AddEdge(j + 2 + n * 2 + i, 2, 1, 0);\n\t\t}\n\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\tflow::AddEdge(j + 2, j + n + 2, 1, -v[j]);\n\t\t\tfor (int k = 1; k <= i; ++k) {\n\t\t\t\tif (x[j] >= mnx[k] && x[j] <= mxx[k]) {\n\t\t\t\t\tflow::AddEdge(k + 2 + n * 2, j + 2, 1, 0);\n\t\t\t\t}\n\t\t\t\tif (y[j] >= mny[k] && y[j] <= mxy[k]) {\n\t\t\t\t\tflow::AddEdge(j + n + 2, k + 2 + n * 2 + i, 1, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpair<ll, ll> ans = flow::Solve();\n\t\tif (ans.first == i) res = max(res, -ans.second);\n\t}\n\tprintf(\"%lld\", res);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<iomanip>\n#include<ctime>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#define sqr(x) ((x)*(x))\n#define fz1(i,n) for ((i)=1;(i)<=(n);(i)++)\n#define fd1(i,n) for ((i)=(n);(i)>=1;(i)--)\n#define fz0g(i,n) for ((i)=0;(i)<=(n);(i)++)\n#define fd0g(i,n) for ((i)=(n);(i)>=0;(i)--)\n#define fz0k(i,n) for ((i)=0;(i)<(n);(i)++)\n#define fd0k(i,n) for ((i)=(int)((n)-1);(i)>=0;(i)--)\n#define fz(i,x,y) for ((i)=(x);(i)<=(y);(i)++)\n#define fd(i,y,x) for ((i)=(y);(i)>=(x);(i)--)\n#define fzin fz1(i,n)\n#define fzim fz1(i,m)\n#define fzjn fz1(j,n)\n#define fzjm fz1(j,m)\n#define ff(c,itr) for (__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n#define rdst(st,len){static char ss[len];scanf(\" %s\",ss);(st)=ss;}\n//#define T_ int\nusing namespace std;\n//struct bit{T_ arr[1000005];int lowbit(int x){return x&(-x);}void add(int x,T_ y){for (int i=x;i<=n;i+=lowbit(i)) arr[i]+=y;}T_ query(int x){T_ s=0;for (int i=x;i>0;i-=lowbit(i)) s+=arr[i];return s;}};\n//struct seg{struct treedot{int l,r;T_ sum,add;void update(T_ x){sum+=(r-l+1)*x; add+=x;}}c[800005];void pushdown(int id){if (c[id].add){c[id*2].update(c[id].add);c[id*2+1].update(c[id].add);c[id].add=0;}}void pushup(int id){c[id].sum=c[id*2].sum+c[id*2+1].sum;}void build(int id,int l,int r){if (l>r) return;c[id].l=l;c[id].r=r;c[id].sum=0;c[id].add=0;if (l==r) c[id].sum=0;else{int mid=l+(r-l)/2;build(id*2,l,mid);build(id*2+1,mid+1,r);pushup(id);}}void update(int id,int le,int ri,T_ x){if (le>c[id].r||ri<c[id].l) return;if (le<=c[id].l&&c[id].r<=ri) c[id].update(x);else{pushdown(id);update(id*2,le,ri,x);update(id*2+1,le,ri,x);pushup(id);}}T_ query(int id,int le,int ri){if (ri<c[id].l||c[id].r<le) return 0;if (le<=c[id].l&&c[id].r<=ri) return c[id].sum;T_ ans=0;pushdown(id);ans+=query(id*2,le,ri);ans+=query(id*2+1,le,ri);pushup(id);return ans;}};\n//struct bit_2d{T_ a[2005][2005];int lowbit(int x){return x&(-x);}void add(int x,int y,T_ z){int i,j;for (i=x;i<=2000;i+=lowbit(i)){for (j=y;j<=2000;j+=lowbit(j)){a[i][j]+=z;}}}T_ query(int x,int y){int i,j;T_ s=0;for (i=x;i;i-=lowbit(i)){for (j=y;j;j-=lowbit(j)){s+=a[i][j];}}return s;}T_ query(int x,int y,int xx,int yy){return query(xx,yy)-query(x-1,yy)-query(xx,y-1)+query(x-1,y-1);}};\nint n,m,i,j,k,cnt,a[325],b[325],s=0,t=321,l[325],r[325],u[325],d[325],x,y,inq[325],vis[325];\nvector<int> allx,ally;\nlong long v[325],cst,ans,dis[325];\nchar c[325],ca[325],cb[325];\nstruct ii\n{\n\tint y,z;\n\tlong long d;\n}e[10005];\nvector<int> bi[10005];\nvoid init()\n{\n\tint i;fz0g(i,321) bi[i].clear();cnt=0;\n}\nvoid add(int x,int y,int z,long long d)\n{\n\tcnt++;bi[x].push_back(cnt*2-2);bi[y].push_back(cnt*2-1);\n\te[cnt*2-2]=(ii){y,z,d};e[cnt*2-1]=(ii){x,0,-d};\n}\nbool bfs(int s,int t)\n{\n\tmemset(dis,-0x18,sizeof(dis));dis[s]=0;queue<int> qx;qx.push(s);inq[s]=1;\n\twhile (!qx.empty()){\n\t\tint x=qx.front();qx.pop();inq[x]=0;ff(bi[x],it) if (e[*it].z){\n\t\t\tint y=e[*it].y;long long z=dis[x]+e[*it].d;\n\t\t\tif (dis[y]<z){\n\t\t\t\tdis[y]=z;\n\t\t\t\tif (!inq[y]){\n\t\t\t\t\tinq[y]=1;qx.push(y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}return dis[t]>dis[324];\n}\nint dfs(int x,int tt,int flw)\n{\n\tif (!flw) return 0;\n\tif (x==tt) {vis[x]=1;return flw;}\n\tif (vis[x]) return 0;\n\tvis[x]=1;int ans=0;ff(bi[x],it){\n//\t\tcerr<<e[*it].y<<' '<<e[*it].z<<endl;\n\t\tif (e[*it].z&&dis[e[*it].y]==dis[x]+e[*it].d){\n\t\t\tint t=dfs(e[*it].y,tt,min(flw,e[*it].z));cst+=t*e[*it].d;ans+=t;flw-=t;e[*it].z-=t;e[(*it)^1].z+=t;if (!flw) break;\n\t\t}\n\t}return ans;\n}\nbool dinic(int s,int t,int aa)\n{\n\tint ans=0;while (bfs(s,t)){\n\t\tdo{\n\t\t\tmemset(vis,0,sizeof(vis));\n\t\t\tans+=dfs(s,t,aa);\n\t\t}while (vis[t]);\n\t}if (ans==aa) return 1;return 0;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfz1(i,n){\n\t\tscanf(\"%d%d%lld\",&a[i],&b[i],&v[i]);\n//\t\tallx.push_back(a[i]);ally.push_back(b[i]);\n\t}//sort(allx.begin(),allx.end());allx.resize(unique(allx.begin(),allx.end())-allx.begin());sort(ally.begin(),ally.end());ally.resize(unique(ally.begin(),ally.end())-ally.begin());\n\t/*fz1(i,n){\n\t\ta[i]=upper_bound(allx.begin(),allx.end(),a[i])-allx.begin();\n\t\tb[i]=upper_bound(ally.begin(),ally.end(),b[i])-ally.begin();\n\t}*/\n\tscanf(\"%d\",&m);fz1(i,m){\n\t\tscanf(\" %c%d%d\",&c[i],&ca[i],&cb[i]);\n\t}\n\tans=0;\n\tfz1(i,n){\n\t\tcst=0;init();\n\t\tfz1(j,i){\n\t\t\tl[i]=d[i]=0;\n\t\t\tr[i]=u[i]=0x18181818;\n\t\t}\n\t\tfz1(j,m) if (cb[j]<i){\n\t\t\tif (c[j]=='L') l[cb[j]+1]=max(l[cb[j]+1],ca[j]+1);\n\t\t\tif (c[j]=='R') r[i-cb[j]]=min(r[i-cb[j]],ca[j]-1);\n\t\t\tif (c[j]=='D') d[cb[j]+1]=max(d[cb[j]+1],ca[j]+1);\n\t\t\tif (c[j]=='U') u[i-cb[j]]=min(u[i-cb[j]],ca[j]-1);\n\t\t}\n\t\tfz(j,2,i){\n\t\t\tl[j]=max(l[j],l[j-1]);\n\t\t\td[j]=max(d[j],d[j-1]);\n\t\t}\n\t\tfd(j,i-1,1){\n\t\t\tr[j]=min(r[j],r[j+1]);\n\t\t\tu[j]=min(u[j],u[j+1]);\n\t\t}\n\t\tfz1(j,i)fz1(k,n){\n\t\t\tif (l[j]<=a[k]&&a[k]<=r[j]){\n\t\t\t\tadd(j,n+k,1,0);\n\t\t\t}\n\t\t\tif (d[j]<=b[k]&&b[k]<=u[j]){\n\t\t\t\tadd(n+n+k,n+n+n+j,1,0);\n\t\t\t}\n\t\t}\n\t\tfz1(j,i){\n\t\t\tadd(s,j,1,0);add(n+n+n+j,t,1,0);\n\t\t}fz1(j,n){\n\t\t\tadd(j+n,j+n+n,1,v[j]);\n\t\t}if (dinic(s,t,i)) ans=max(ans,cst);\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 85 * 4 + 5;\nconst int M = N * N;\n\ntypedef long long LL;\nconst LL Base = 1e15, INF = 1e18;\n\nint n, v, m, T[N], a[N], b[N], num, L[N], R[N], U[N], D[N];\nchar s[N];\nlong long ans = 0;\n\nstruct NODE {\n\tint x, y;\n\tlong long v;\n\tvoid input() {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tscanf(\"%lld\", &v);\n\t}\n}P[N];\n\nint chg(char c) {\n\tif(c == 'L') return 0;\n\tif(c == 'R') return 1;\n\tif(c == 'D') return 2;\n\treturn 3;\n}\n\nnamespace CostFlow {\n\t\n\tint fir[N], ne[M], to[M], C[M], cnt, s, t, vis[N], tim, pre[N];\n\tLL dis[N], Cost[M], res;\n\t\n\tvoid init() {\n\t\tres = 0;\n\t\tmemset(fir, 0, sizeof(fir));\n\t\tcnt = 1;\n\t}\n\t\n\tvoid add(int x, int y, int fl, LL Co) {\n\t\tne[++ cnt] = fir[x];\n\t\tfir[x] = cnt;\n\t\tto[cnt] = y;\n\t\tC[cnt] = fl;\n\t\tCost[cnt] = Co;\n\t}\n\t\n\tvoid link(int x, int y, int fl, LL Co) {\n\t\tadd(x, y, fl, Co);\n\t\tadd(y, x, 0, -Co);\n\t}\n\t\n\t#define Foreachson(i, x) for(int i = fir[x]; i; i = ne[i])\n\t\n\tbool inq[N];\n\t\n\tbool SPFA(int s, int t) {\n\t\tqueue <int> q;\n\t\twhile(!q.empty()) q.pop();\n\t\tfor(int i = s; i <= t; ++ i) dis[i] = -INF, inq[i] = 0, pre[i] = 0;\n\t\tdis[s] = 0;\n\t\tq.push(s); inq[s] = 1;\n\t\twhile(!q.empty()) {\n\t\t\tint ind = q.front(); inq[ind] = 0;\n\t\t\tq.pop();\n\t\t\tForeachson(i, ind) if(C[i]) {\n\t\t\t\tint V = to[i];\n\t\t\t\tif(dis[V] < dis[ind] + Cost[i]) {\n\t\t\t\t\tdis[V] = dis[ind] + Cost[i];\n\t\t\t\t\tpre[V] = i;\n\t\t\t\t\tif(!inq[V]) q.push(V), inq[V] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dis[t] == -INF) return 0;\n\t\treturn 1;\n\t}\n\t\n\tLL CostFlow() {\n\t\tLL res = 0;\n\t\tint tot = 0;\n\t\twhile(SPFA(s, t)) {\n\t\t\tres += dis[t];\n\t\t\t++ tot;\n\t\t\tint now = t;\n\t\t\twhile(now != s) {\n\t\t\t\t-- C[pre[now]]; ++ C[pre[now] ^ 1];\n\t\t\t\tnow = to[pre[now] ^ 1];\n\t\t\t}\n\t\t}\n\t\t//cerr << tot << endl;\n\t\treturn res;\n\t}\n}\n\nLL solve(int num) {\n\tfor(int i = 1; i <= num; ++ i) L[i] = D[i] = 0, R[i] = U[i] = 101;\n\tfor(int i = 1; i <= m; ++ i) {\n\t\tif(b[i] >= num) continue;\n\t\tif(T[i] == 0) L[b[i] + 1] = max(L[b[i] + 1], a[i] + 1);\n\t\tif(T[i] == 2) D[b[i] + 1] = max(D[b[i] + 1], a[i] + 1);\n\t\tif(T[i] == 1) R[num - b[i]] = min(R[num - b[i]], a[i] - 1);\n\t\tif(T[i] == 3) U[num - b[i]] = min(U[num - b[i]], a[i] - 1);\n\t}\n\tfor(int i = 1; i < num; ++ i) {\n\t\tL[i + 1] = max(L[i + 1], L[i]);\n\t\tD[i + 1] = max(D[i + 1], D[i]);\n\t}\n\tfor(int i = num - 1; i >= 1; -- i) {\n\t\tU[i] = min(U[i], U[i + 1]);\n\t\tR[i] = min(R[i], R[i + 1]);\n\t}\n\tCostFlow :: init();\n\tint s = 1, t = 2 * num + 2 * n + 2;\n\tCostFlow :: s = 1, CostFlow :: t = 2 * num + 2 * n + 2;\n\t\n\tfor(int i = 1; i <= num; ++ i)\n\tCostFlow :: link(s, 2 * n + 1 + i, 1, 0), \n\tCostFlow :: link(2 * n + 1 + num + i, t, 1, 0);\n\t\n\tfor(int i = 1; i <= n; ++ i) {\n\t\tCostFlow :: link(i * 2, i * 2 + 1, 1, P[i].v);\n\t\tfor(int j = 1; j <= num; ++ j) {\n\t\t\tif(L[j] <= P[i].x && P[i].x <= R[j]) {\n\t\t\t\tCostFlow :: link(2 * n + 1 + j, i * 2, 1, 0);\n\t\t\t}\n\t\t\tif(D[j] <= P[i].y && P[i].y <= U[j]) {\n\t\t\t\tCostFlow :: link(i * 2 + 1, 2 * n + num + 1 + j, 1, 0);\n\t\t\t}\n\t\t}\n\t}\n\tLL res = CostFlow :: CostFlow();\n\t//cerr << num <<\" \" << res << endl;\n\treturn res;\n}\n\nint main(void) {\n\tcin >> n;\n\tfor(int i = 1; i <= n; ++ i) P[i].input();\n\tcin >> m;\n\tfor(int i = 1; i <= m; ++ i) {\n\t\tscanf(\"%s\", s);\n\t\tT[i] = chg(s[0]);\n\t\tscanf(\"%d%d\", &a[i], &b[i]);\n\t}\n\tfor(num = 1; num <= n; ++ num) {\n\t\tans = max(ans, solve(num));\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// Created by Nikolay Budin\n\n#ifdef LOCAL\n#  define _GLIBCXX_DEBUG\n#else\n#  define cerr __get_ce\n#endif\n#include <bits/stdc++.h>\n#define ff first\n#define ss second\n#define szof(x) ((int)x.size())\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef unsigned long long ull;\nint const INF = (int)1e9 + 1e3;\nll const INFL = (ll)1e18 + 1e6;\n#ifdef LOCAL\n\tmt19937 tw(9450189);\n#else\n\tmt19937 tw(chrono::high_resolution_clock::now().time_since_epoch().count());\n#endif\nuniform_int_distribution<ll> ll_distr;\nll rnd(ll a, ll b) { return ll_distr(tw) % (b - a + 1) + a; }\n\nstruct big_integer {\nprivate:\n    std::vector<uint32_t> number;\n    void normalize();\n    void negate();\n    \npublic:\n    big_integer();\n    big_integer(int num);\n    big_integer(ll num);\n    big_integer(uint32_t num);\n    big_integer(std::vector<uint32_t> const& _number);\n    explicit big_integer(std::string const& s);\n\n    ~big_integer();\n    \n    big_integer(big_integer const& other);\n\n    void print() const;\n\n    bool get_sign() const;\n\n    size_t size() const;\n    \n    uint32_t operator[](size_t pos) const;\n\n    big_integer& operator=(big_integer const& other);\n\n    big_integer& operator+=(big_integer const& rhs);\n    big_integer& operator-=(big_integer const& rhs);\n    big_integer& operator*=(big_integer const& rhs);\n    big_integer& operator/=(big_integer const& rhs);\n    big_integer& operator%=(big_integer const& rhs);\n\n    big_integer& operator&=(big_integer const& rhs);\n    big_integer& operator|=(big_integer const& rhs);\n    big_integer& operator^=(big_integer const& rhs);\n\n    big_integer& operator<<=(int rhs);\n    big_integer& operator>>=(int rhs);\n\n    big_integer operator+() const;\n    big_integer operator-() const;\n    big_integer operator~() const;\n\n    big_integer& operator++();\n    big_integer operator++(int);\n    big_integer& operator--();\n    big_integer operator--(int);\n\n    friend bool operator==(big_integer const& a, big_integer const& b);\n    friend bool operator!=(big_integer const& a, big_integer const& b);\n    friend bool operator<(big_integer const& a, big_integer const& b);\n    friend bool operator>(big_integer const& a, big_integer const& b);\n    friend bool operator<=(big_integer const& a, big_integer const& b);\n    friend bool operator>=(big_integer const& a, big_integer const& b);\n\n    friend std::string to_string(big_integer const& a);\n};\n\nbool operator==(big_integer const& num1, big_integer const& num2);\nbool operator!=(big_integer const& a, big_integer const& b);\nbool operator<(big_integer const& num1, big_integer const& num2);\nbool operator>(big_integer const& num1, big_integer const& num2);\nbool operator<=(big_integer const& num1, big_integer const& num2);\nbool operator>=(big_integer const& num1, big_integer const& num2);\n\nbig_integer operator+(big_integer num1, big_integer const& num2);\nbig_integer operator-(big_integer num1, big_integer const& num2);\nbig_integer operator*(big_integer a, big_integer const& b);\nbig_integer operator/(big_integer a, big_integer const& b);\nbig_integer operator%(big_integer a, big_integer const& b);\n\nbig_integer operator&(big_integer num1, big_integer const& num2);\nbig_integer operator|(big_integer num1, big_integer const& num2);\nbig_integer operator^(big_integer num1, big_integer const& num2);\n\nbig_integer operator<<(big_integer a, int b);\nbig_integer operator>>(big_integer a, int b);\n\nstd::string to_string(big_integer const& a);\nstd::ostream& operator<<(std::ostream& s, big_integer const& a);\n\nconst big_integer TEN(10), ZERO(0);\nconst uint64_t MASK = (((uint64_t) 1 << 32) - 1);\n\nvoid big_integer::normalize() {\n    //assert(number.back() == 0 || number.back() == MASK);\n    while (number.size() > 1 && number[number.size() - 2] == number.back()) {\n        number.pop_back();\n    }\n}\n\nvoid big_integer::negate() {\n    for (auto& num: number) {\n        num = ~num;\n    }\n    operator+=(big_integer(1));\n}\n\nbig_integer::big_integer() {\n    number = {0};\n}\n\nbig_integer::big_integer(int num) {\n    number = {(uint32_t) num};\n    if (num > 0) {\n        number.push_back(0);\n    }\n    if (num < 0) {\n        number.push_back((uint32_t) -1);\n    }\n    normalize();\n}\n\nbig_integer::big_integer(uint32_t num) {\n    number = {num, 0};\n}\n\nbig_integer::big_integer(ll num) {\n    number = {(uint32_t) num, (uint32_t) (num >> 32)};\n    if (num > 0) {\n        number.push_back(0);\n    }\n    if (num < 0) {\n        number.push_back((uint32_t) -1);\n    }\n    normalize();\n}\n\nbig_integer::big_integer(std::vector<uint32_t> const& _number) {\n    number = _number;\n    while (number.size() > 1 && number[number.size() - 2] == number.back()) {\n        number.pop_back();\n    }\n}\n\nbig_integer::big_integer(std::string const& s) {\n    number = {0};\n    big_integer tp(1);\n    bool sign = 0;\n    if (s[0] == '-') {\n        sign = 1;\n    }\n    \n    for (size_t i = s.size() - 1; ~i; --i) {\n        if ('0' <= s[i] && s[i] <= '9') {\n            operator+=(tp * big_integer(s[i] - '0'));\n            tp *= TEN;\n        }\n    }\n\n    if (sign) {\n        negate();\n    }\n}\n\nbig_integer::~big_integer() {\n}\n\nbig_integer::big_integer(big_integer const& other) {\n    number = other.number;\n}\n\nvoid big_integer::print() const {\n    for (auto num: number) {\n        std::cerr << num << \" \";\n    }\n    std::cerr << std::endl;\n}\n\nbool big_integer::get_sign() const {\n    return number.back();\n}\n\nsize_t big_integer::size() const {\n    return number.size();\n}\n\nuint32_t big_integer::operator[](size_t pos) const {\n    //assert(number.size());\n    return number[std::min(pos, number.size() - 1)];\n}\n\nbig_integer& big_integer::operator=(big_integer const& other) {\n    number = other.number;\n    return *this;\n}\n\nbig_integer& big_integer::operator+=(big_integer const& rhs) {\n    std::vector<uint32_t> v;\n    size_t c = 0;\n    uint64_t now = 0;\n    while (c <= size() || c <= rhs.size()) {\n        now += operator[](c);\n        now += rhs[c];\n        v.push_back(now & MASK);\n        now >>= 32;\n        ++c;\n    }\n    number = v;\n    normalize();\n    return *this;\n}\n\nbig_integer& big_integer::operator-=(big_integer const& rhs) {\n    std::vector<uint32_t> v;\n    size_t c = 0;\n    uint64_t now = 0;\n    while (c <= size() || c <= rhs.size()) {\n        now += rhs[c];\n        v.push_back(operator[](c) - now);\n        if (operator[](c) >= now) {\n            now = 0;\n        } else {\n            now = 1;\n        }\n        ++c;\n    }\n    number = v;\n    normalize();\n    return *this;\n}\n\nbig_integer& big_integer::operator*=(big_integer const& rhs) {\n    bool sign = get_sign() ^ rhs.get_sign();\n    big_integer a = *this;\n    if (a.get_sign() == 1) {\n        a.negate();\n    }\n    big_integer b = rhs;\n    if (b.get_sign() == 1) {\n        b.negate();\n    }\n\n    std::vector<std::pair<uint64_t, uint64_t>> v(a.size() + b.size() - 1);\n    for (size_t i = 0; i < a.size(); ++i) {\n        for (size_t j = 0; j < b.size(); ++j) {\n            uint64_t tmp = (uint64_t) a[i] * b[j];\n            v[i + j].first += tmp & (((uint64_t) 1 << 32 ) - 1);\n            if (i + j + 1 < v.size()) {\n                v[i + j + 1].second += tmp >> 32;\n            }\n        }\n    }\n    number = std::vector<uint32_t>();\n    uint64_t now = 0;\n    for (size_t i = 0; i < v.size(); ++i) {\n        now += v[i].first;\n        now += v[i].second;\n        number.push_back(now & MASK);\n        now >>= 32;\n    }\n    normalize();\n    if (sign) {\n        negate();\n    }\n    return *this;\n}\n\nbig_integer& big_integer::operator/=(big_integer const& rhs) {\n    bool sign = get_sign() ^ rhs.get_sign();\n    if (get_sign() == 1) {\n        negate();\n    }\n    big_integer b = rhs;\n    if (b.get_sign() == 1) {\n        b.negate();\n    }\n    \n    if (*this < b) {\n        number = {0};\n        return *this;\n    }\n\n    std::vector<uint32_t> v(size() - b.size() + 2);\n    for (size_t i = size() - b.size(); ~i; --i) {\n        uint64_t l = 0, r = (uint64_t) 1 << 32;\n        while (r - l > 1) {\n            uint32_t mid = l + (r - l) / 2;\n            \n            uint64_t now = 0;\n            bool flag = true;\n            for (size_t j = 0; j < b.size(); ++j) {\n                now += (uint64_t) b[j] * mid;\n                if ((now & MASK) != number[i + j]) {\n                    flag = (number[i + j] > (now & MASK));\n                }\n                now >>= 32;\n            }\n\n            if (flag) {\n                l = mid;\n            } else {\n                r = mid;\n            }\n        }\n        \n        uint64_t now = 0, nowd = 0;\n        for (size_t j = 0; j < b.size(); ++j) {\n            now += (uint64_t) b[j] * l;\n            nowd += now & MASK;\n            now >>= 32;\n            if (nowd <= number[i + j]) {\n                number[i + j] -= nowd;\n                nowd = 0;\n            } else {\n                number[i + j] -= nowd;\n                nowd = 1;\n            }\n        }\n        v[i] = l;\n    }\n\n    number = v;\n    normalize();\n    if (sign) {\n        negate();\n    }\n    return *this;\n}\n\nbig_integer& big_integer::operator%=(big_integer const& rhs) {\n    bool sign = get_sign();\n    if (get_sign() == 1) {\n        negate();\n    }\n    big_integer b = rhs;\n    if (b.get_sign() == 1) {\n        b.negate();\n    }\n    \n    if (*this < b) {\n        return *this;\n    }\n\n    for (size_t i = size() - b.size(); ~i; --i) {\n        uint64_t l = 0, r = (uint64_t) 1 << 32;\n        while (r - l > 1) {\n            uint32_t mid = l + (r - l) / 2;\n            \n            uint64_t now = 0;\n            bool flag = true;\n            for (size_t j = 0; j < b.size(); ++j) {\n                now += (uint64_t) b[j] * mid;\n                //prod[j] = now & MASK;\n                if ((now & MASK) != number[i + j]) {\n                    flag = (number[i + j] > (now & MASK));\n                }\n                now >>= 32;\n            }\n\n            if (flag) {\n                l = mid;\n            } else {\n                r = mid;\n            }\n        }\n        \n        uint64_t now = 0, nowd = 0;\n        for (size_t j = 0; j < b.size(); ++j) {\n            now += (uint64_t) b[j] * l;\n            nowd += now & MASK;\n            now >>= 32;\n            if (nowd <= number[i + j]) {\n                number[i + j] -= nowd;\n                nowd = 0;\n            } else {\n                number[i + j] -= nowd;\n                nowd = 1;\n            }\n        }\n    }\n\n    normalize();\n    if (sign) {\n        negate();\n    }\n    return *this;\n}\n\nbig_integer& big_integer::operator&=(big_integer const& rhs) {\n    std::vector<uint32_t> v;\n    size_t c = 0;\n    while (c <= size() || c <= rhs.size()) {\n        v.push_back(operator[](c) & rhs[c]);\n        ++c;\n    }\n    number = v;\n    normalize();\n    return *this;\n}\n\nbig_integer& big_integer::operator|=(big_integer const& rhs) {\n    std::vector<uint32_t> v;\n    size_t c = 0;\n    while (c <= size() || c <= rhs.size()) {\n        v.push_back(operator[](c) | rhs[c]);\n        ++c;\n    }\n    number = v;\n    normalize();\n    return *this;\n}\n\nbig_integer& big_integer::operator^=(big_integer const& rhs) {\n    std::vector<uint32_t> v;\n    size_t c = 0;\n    while (c <= size() || c <= rhs.size()) {\n        v.push_back(operator[](c) ^ rhs[c]);\n        ++c;\n    }\n    number = v;\n    normalize();\n    return *this;\n}\n\nbig_integer& big_integer::operator<<=(int rhs) {\n    int d = rhs % 32;\n    int tot = rhs / 32;\n    std::vector<uint32_t> v;\n    for (int i = 0; i < tot; ++i) {\n        v.push_back(0);\n    }\n    size_t c = 0;\n    uint32_t prev = 0;\n    while (c <= size()) {\n        uint32_t tmp = (operator[](c) << d) | prev;\n        v.push_back(tmp);\n        prev = operator[](c) >> (32 - d);\n        ++c;\n    }\n    number = v;\n    normalize();\n    return *this;\n}\n\nbig_integer& big_integer::operator>>=(int rhs) {\n    int d = rhs % 32;\n    int tot = rhs / 32;\n    std::vector<uint32_t> v;\n    size_t c = tot;\n    do {\n        uint32_t tmp = (operator[](c) >> d) | (operator[](c + 1) << (32 - d));\n        v.push_back(tmp);\n        ++c;\n    } while (c <= size() + 1);\n    number = v;\n    normalize();\n    return *this;\n}\n\nbig_integer big_integer::operator+() const {\n    big_integer ret = *this;\n    return ret;\n}\n\nbig_integer big_integer::operator-() const {\n    big_integer ret = *this;\n    ret.negate();\n    return ret;\n}\n\nbig_integer big_integer::operator~() const {\n    std::vector<uint32_t> v;\n    for (size_t i = 0; i < size(); ++i) {\n        v.push_back(~number[i]);\n    }\n    return big_integer(v);\n}\n\nbig_integer& big_integer::operator++() {\n    operator+=(big_integer(1));\n    return *this;\n}\n\nbig_integer big_integer::operator++(int) {\n    big_integer ret = *this;\n    operator+=(big_integer(1));\n    return ret;\n}\n\nbig_integer& big_integer::operator--() {\n    operator-=(big_integer(1));\n    return *this;\n}\n\nbig_integer big_integer::operator--(int) {\n    big_integer ret = *this;\n    operator-=(big_integer(1));\n    return ret;\n}\n\n\n\nbool operator==(big_integer const& a, big_integer const& b) {\n    return a.number == b.number;\n}\n\nbool operator!=(big_integer const& a, big_integer const& b) {\n    return a.number != b.number;\n}\n\nbool operator<(big_integer const& a, big_integer const& b) {\n    if (a.get_sign() != b.get_sign()) {\n        return a.get_sign() > b.get_sign();\n    }\n    \n    if (a.number.size() != b.number.size()) {\n        return a.number.size() < b.number.size();\n    }\n\n    for (size_t i = a.number.size() - 1; ~i; --i) {\n        if (a.number[i] != b.number[i]) {\n            return a.number[i] < b.number[i];\n        }\n    }\n    return false;\n}\n\nbool operator>(big_integer const& a, big_integer const& b) {\n    return !(a == b || a < b);\n}\n\nbool operator<=(big_integer const& a, big_integer const& b) {\n    return a == b || a < b;\n}\n\nbool operator>=(big_integer const& a, big_integer const& b) {\n    return a == b || a > b;\n}\n\nbig_integer operator+(big_integer a, big_integer const& b) {\n    return a += b;\n}\n\nbig_integer operator-(big_integer a, big_integer const& b) {\n    return a -= b;\n}\n\nbig_integer operator*(big_integer a, big_integer const& b) {\n    return a *= b;\n}\n\nbig_integer operator/(big_integer a, big_integer const& b) {\n    return a /= b;\n}\n\nbig_integer operator%(big_integer a, big_integer const& b) {\n    return a %= b;\n}\n\nbig_integer operator&(big_integer a, big_integer const& b) {\n    return a &= b;\n}\n\nbig_integer operator|(big_integer a, big_integer const& b) {\n    return a |= b;\n}\n\nbig_integer operator^(big_integer a, big_integer const& b) {\n    return a ^= b;\n}\n\nbig_integer operator<<(big_integer a, int b) {\n    return a <<= b;\n}\nbig_integer operator>>(big_integer a, int b) {\n    return a >>= b;\n}\n\nstd::string to_string(big_integer const& a) {\n    big_integer tmp = a;\n    std::string ret = \"\";\n    bool sign = 0;\n    if (tmp < ZERO) {\n        tmp = -tmp;\n        sign = 1;\n    }\n    while (tmp > ZERO) {\n        big_integer dig = tmp % TEN;\n        ret += '0' + dig[0];\n        tmp /= TEN;\n    }\n    if (ret.size() == 0) {\n        ret = \"0\";\n    }\n    if (sign) {\n        ret += '-';\n    }\n    reverse(ret.begin(), ret.end());\n    return ret;\n}\n\nstd::ostream& operator<<(std::ostream& s, big_integer const& a) {\n    s << to_string(a);\n    return s;\n}\n\nstruct number {\n\tbig_integer p, q;\n\n\tnumber() : p(0), q(1) {}\n\n\tnumber(ll num) : p(big_integer(num)), q(1) {}\n\n\tnumber(big_integer _p, big_integer _q) : p(_p), q(_q) {\n\t\tif (q < 0) {\n\t\t\tq *= -1;\n\t\t\tp *= -1;\n\t\t}\n\t}\n\n\tnumber operator+(number const& other) const {\n\t\treturn number(p * other.q + q * other.p, q * other.q);\n\t}\n\tnumber operator-(number const& other) const {\n\t\treturn number(p * other.q - q * other.p, q * other.q);\n\t}\n\n\tnumber operator*(number const& other) const {\n\t\treturn number(p * other.p, q * other.q);\n\t}\n\n\tnumber operator/(number const& other) const {\n\t\treturn number(p * other.q, q * other.p);\n\t}\n\n\tnumber& operator/=(number const& other) {\n\t\tauto tmp = *this / other;\n\t\tp = tmp.p;\n\t\tq = tmp.q;\n\t\treturn *this;\n\t}\n\n\tnumber& operator-=(number const& other) {\n\t\tauto tmp = *this - other;\n\t\tp = tmp.p;\n\t\tq = tmp.q;\n\t\treturn *this;\n\t}\n\n\tnumber operator-() const {\n\t\treturn number(-p, q);\n\t}\n\n\tbool operator==(number const& other) const {\n\t\treturn p * other.q == q * other.p;\n\t}\n\n\tbool operator<(number const& other) const {\n\t\treturn p * other.q < q * other.p;\n\t}\n\n\tbool operator>(number const& other) const {\n\t\treturn p * other.q > q * other.p;\n\t}\n};\n\nbool eq(number a, number b) {\n\treturn a == b;\n}\n\nbool ls(number a, number b) {\n\treturn a < b;\n}\n\nvector<number> simplex(vector<vector<number> > a) {\n    int n = a.size() - 1;\n    int m = a[0].size() - 1;\n    vector<int> left(n + 1), up(m + 1);\n    iota(up.begin(), up.end(), 0);\n    iota(left.begin(), left.end(), m);\n    auto pivot = [&](int x, int y) {\n        swap(left[x], up[y]);\n        number k = a[x][y];\n        a[x][y] = 1;\n        vector<int> vct;\n        for (int j = 0; j <= m; j++) {\n            a[x][j] /= k;\n            if (!eq(a[x][j], 0)) vct.push_back(j);\n        }\n        for (int i = 0; i <= n; i++) {\n            if (eq(a[i][y], 0) || i == x) continue;\n            k = a[i][y];\n            a[i][y] = 0;\n            for (int j : vct) a[i][j] -= k * a[x][j];\n        }\n    };\n    while (1) {\n        int x = -1;\n        for (int i = 1; i <= n; i++) if (ls(a[i][0], 0) && (x == -1 || a[i][0] < a[x][0])) x = i;\n        if (x == -1) break;\n        int y = -1;\n        for (int j = 1; j <= m; j++) if (ls(a[x][j], 0) && (y == -1 || a[x][j] < a[x][y])) y = j;\n        if (y == -1) assert(0); // infeasible\n        pivot(x, y);\n    }\n    while (1) {\n        int y = -1;\n        for (int j = 1; j <= m; j++) if (ls(0, a[0][j]) && (y == -1 || a[0][j] > a[0][y])) y = j;\n        if (y == -1) break;\n        int x = -1;\n        for (int i = 1; i <= n; i++) if (ls(0, a[i][y]) && (x == -1 || a[i][0] / a[i][y] < a[x][0] / a[x][y])) x = i;\n        if (x == -1) assert(0); // unbounded\n        pivot(x, y);\n    }\n    vector<number> ans(m + 1);\n    for (int i = 1; i <= n; i++) if (left[i] <= m) ans[left[i]] = a[i][0];\n    ans[0] = -a[0][0];\n    return ans;\n}\n// j=1..m: x[j]>=0\n// i=1..n: sum(j=1..m) A[i][j]*x[j] <= A[i][0]\n// max sum(j=1..m) A[0][j]*x[j]\n// res[0] is answer\n// res[1..m] is certificate\n\nvoid solve() {\n\tint n;\n\tcin >> n;\n\tvector<vector<number>> matr;\n\tvector<pii> coords;\n\tmatr.push_back(vector<number>(n + 1));\n\tfor (int i = 0; i < n; ++i) {\n\t\tint x, y;\n\t\tll w;\n\t\tcin >> x >> y >> w;\n\t\tmatr[0][i + 1] = w;\n\t\tcoords.push_back({x, y});\n\t\tmatr.push_back(vector<number>(n + 1));\n\t\tmatr.back()[0] = 1;\n\t\tmatr.back()[i + 1] = 1;\n\t}\n\n\tint m;\n\tcin >> m;\n\tfor (int i = 0; i < m; ++i) {\n\t\tchar t;\n\t\tint a, b;\n\t\tcin >> t >> a >> b;\n\t\tmatr.push_back(vector<number>(n + 1));\n\t\tmatr.back()[0] = b;\n\t\tif (t == 'L') {\n\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\tif (coords[j].ff <= a) {\n\t\t\t\t\tmatr.back()[j + 1] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (t == 'R') {\n\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\tif (coords[j].ff >= a) {\n\t\t\t\t\tmatr.back()[j + 1] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (t == 'D') {\n\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\tif (coords[j].ss <= a) {\n\t\t\t\t\tmatr.back()[j + 1] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (t == 'U') {\n\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\tif (coords[j].ss >= a) {\n\t\t\t\t\tmatr.back()[j + 1] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tauto res = simplex(matr);\n\tcout << res[0].p << \"\\n\";\n}\n\n\nint main() {\n#ifdef LOCAL\n\tauto start_time = clock();\n\tcerr << setprecision(3) << fixed;\n#endif\n\tcout << setprecision(15) << fixed;\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\n\tint test_count = 1;\n\t// cin >> test_count;\n\tfor (int test = 1; test <= test_count; ++test) {\n\t\tsolve();\n\t}\n\t\n#ifdef LOCAL\n\tauto end_time = clock();\n\tcerr << \"Execution time: \" << (end_time - start_time) * (int)1e3 / CLOCKS_PER_SEC << \" ms\\n\";\n#endif\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for((i)=1;(i)<=(n);(i)++) \nusing namespace std;\nint n,m,i,j,a[85],b[85],c[85];\nstruct edge{\n\tint y,z,d;\n}e[2000005];\nvector<int> adj[405];\nint main(){\n\tcin>>n>>m;\n\trep(i,n){\n\t\tcin>>a[i]>>b[i]>>c[i];\n\t}\n\t\n\treturn 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#define M 5010\n#define int long long\n#define clr(X) memset(X, 0, sizeof X)\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int Lim = 105;\n\nint Head[M], Next[M], Go[M], Cost[M], Fl[M], Cnt = 1;\n\nint n, A[M], B[M], C[M], Q, op[M], QA[M], QB[M];\n\nbool vis[M];\n\nint Dis[M], Pr[M], mxF[M];\n\nll nwans = 0, totans = 0; // getmax!\n\n/*struct node {\n    int dis, v;\n    node() {}\n    node(int _1, int _2) {dis = _1, v = _2;}\n    node operator < (const node& X) const {return dis > X.dis;}\n};\n\npriority_queue <node> Q;*/\n\nvoid SPFA(int S) {\n    memset(Dis, 63, sizeof Dis), clr(Pr), clr(mxF), clr(vis), mxF[S] = 1e9;\n    Dis[S] = 0;\n    vector <int> V(1, S);\n    for(int i = 0; i < V.size(); i++) {\n        int x = V[i], ds = Dis[x];\n        vis[x] = 0;\n        for(int T = Head[x]; T; T = Next[T])\n            if(Fl[T] && Dis[Go[T]] > ds + Cost[T]) {\n                Dis[Go[T]] = ds + Cost[T];\n                mxF[Go[T]] = min(mxF[x], Fl[T]);\n                Pr[Go[T]] = T ^ 1;\n                if(!vis[Go[T]]) vis[Go[T]] = 1, V.push_back(Go[T]);\n            }\n    }\n}\n\nint MMP(int SS, int TT, int f) {\n    int ans = 0, fl = 0;\n    for(; ;) {\n        SPFA(SS);\n        if(Dis[TT] > 1e18) {\n            if(fl < f) return 0;\n            return ans;\n        }\n        ans += mxF[TT] * Dis[TT], fl += mxF[TT];\n        for(int i = TT; i != SS; i = Go[Pr[i]]) {\n            Fl[Pr[i]] += mxF[TT];\n            Fl[Pr[i] ^ 1] -= mxF[TT];\n        }\n    }\n}\n\nconst int SS = 500, TT = 501;\n\nint Deg[M];\n\nvoid addedge(int a, int b, int f, int c) {\n    Go[++Cnt] = b;\n    Next[Cnt] = Head[a];\n    Head[a] = Cnt;\n    Fl[Cnt] = f;\n    Cost[Cnt] = c;\n}\nvoid dealedge(int a, int b, int lw, int hi, int c) {\n    //nwans += c * lw;\n    addedge(a, b, hi - lw, c);\n    addedge(b, a, 0, -c);\n    Deg[b] += lw;\n    Deg[a] -= lw;\n}\n\nvoid cmax(int &x, int y) {if(x < y) x = y;}\nvoid cmin(int &x, int y) {if(x > y) x = y;}\n\nsigned main() {\n    scanf(\"%lld\", &n);\n    for(int i = 1; i <= n; i++) {\n        scanf(\"%lld%lld%lld\", &A[i], &B[i], &C[i]);\n    }\n    scanf(\"%lld\", &Q);\n    for(int i = 1; i <= Q; i++) {\n        char ch[3];\n        scanf(\"%s\", ch);\n        op[i] = ch[0];\n        scanf(\"%lld%lld\", &QA[i], &QB[i]);\n    }\n    for(int TTT = 0; TTT <= n; TTT++) {\n        clr(Head), Cnt = 1;\n        clr(Deg);\n        dealedge(207, 1, TTT, TTT, 0);\n        int XXMx[111], XXMn[111], YYMx[111], YYMn[111];\n        memset(XXMx, 0, sizeof XXMx);\n        memset(YYMx, 0, sizeof YYMx);\n        for(int i = 0; i <= 105; i++) YYMn[i] = 23333, XXMn[i] = 23333;\n        int flag = 1;\n        for(int i = 1; i <= Q; i++) {\n            int o = op[i];\n            if(o == 'R') {\n                cmin(XXMn[QA[i]], QB[i]);\n            } else if(o == 'L') {\n                cmax(XXMx[QA[i] + 1], TTT - QB[i]);\n            } else if(o == 'D') {\n                cmin(YYMn[QA[i]], QB[i]);\n            } else {\n                cmax(YYMx[QA[i] - 1], TTT - QB[i]);\n            }\n        }\n        if(!flag) continue;\n        for(int i = 0; i <= 100; i++){\n            if(XXMx[i + 1] > XXMn[i + 1]) flag = 0;dealedge(i + 2, i + 3, XXMx[i + 1], XXMn[i + 1], 0);}\n        for(int i = 0; i <= 100; i++) {\n            if(YYMx[i] > YYMn[i]) flag = 0;dealedge(104 + i, 105 + i, YYMx[i], YYMn[i], 0);\n        }\n        if(!flag) continue;\n        dealedge(1, 2, 0, 233333, 0);\n        dealedge(205, 207, 0, 233333, 0);\n        for(int i = 1; i <= n; i++)\n            dealedge(1 + A[i], 104 + B[i], 0, 1, -C[i]);\n        for(int i = 1; i <= 207; i++)\n            if(Deg[i] > 0) {\n                addedge(SS, i, Deg[i], 0);\n                addedge(i, SS, 0, 0);\n            } else if(Deg[i] < 0) {\n                addedge(i, TT, -Deg[i], 0);\n                addedge(TT, i, 0, 0);\n            }\n        int tottot = 0;\n        for(int i = 1; i <= 207; i++) if(Deg[i] > 0) tottot += Deg[i];\n        totans = max(totans, -MMP(SS, TT, tottot));\n    }\n    printf(\"%lld\\n\", totans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint m, n, x[85], y[85];\nint a[333], b[333];\nchar t[333];\nbool taken[85];\nlong long ans, sum, v[85];\nint l[105], r[105], d[105], u[105];\nbool check() {\n\tfor(int i = 0; i < m; ++i) {\n\t\tswitch(t[i]) {\n\t\t\tcase 'L':{\n\t\t\t\tif(l[a[i]] > b[i]) return 0;\n\t\t\t\tbreak;\n\t\t\t} \n\t\t\tcase 'R':{\n\t\t\t\tif(r[a[i]] > b[i]) return 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'U':{\n\t\t\t\tif(u[a[i]] > b[i]) return 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'D': {\n\t\t\t\tif(d[a[i]] > b[i]) return 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}\nvoid add(int k, int f) {\n\tfor(int i = 1; i <= x[k]; ++i) r[i] += f;\n\tfor(int i = x[k]; i <= 100; ++i) l[i] += f;\n\tfor(int i = 1; i <= y[k]; ++i) u[i] += f;\n\tfor(int i = y[k]; i <= 100; ++i) d[i] += f;\n}\nvoid climb() {\n\tbool flag = 1;\n\twhile(flag) {\n\t\tflag = 0;\n\t\tint k = 0;\n\t\tlong long mx = 0;\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tif(!taken[i]) {\n\t\t\t\tadd(i, 1);\n\t\t\t\tif(check() && v[i] > mx) mx = v[i], k = i;\n\t\t\t\tadd(i, -1);\n\t\t\t}\n\t\tif(mx) {\n\t\t\tflag = 1;\n\t\t\tadd(k, 1);\n\t\t\ttaken[k] = 1;\n\t\t\tsum += mx;\n\t\t}\n\t}\n\t/*if(sum == 39ll) {\n\t\tprintf(\"%d %d %d %d\\n\", l[3], r[2], d[5], u[4]);\n\t}*/\n\tans = max(ans, sum);\n}\nint main() {\n\tsrand(time(0));\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; ++i)\n\t\tscanf(\"%d%d%lld\", x+i, y+i, v+i);\n\tscanf(\"%d\", &m);\n\tchar s[5];\n\tfor(int i = 0; i < m; ++i)\n\t\tscanf(\"%s%d%d\", s, a+i, b+i), t[i] = s[0];\n\tint T = 10000;\n\tfor(int i = 0; i < T; ++i) {\n\t\tsum = 0;\n\t\tfor(int j = 1; j <= 100; ++j)\n\t\t\tl[j] = r[j] = d[j] = u[j] = 0;\n\t\tfor(int j = 0; j < n; ++j) {\n\t\t\ttaken[j] = rand() % 2;\n\t\t\tif(taken[j]) add(j, 1), sum += v[j];\n\t\t}\n\t\tif(check()) \n\t\t{\n\t\t\tclimb();\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef HOME\n#define db(x) cerr << #x << \" = \" << x << endl\n#define db3(x, y, z) cerr << \"(\" << #x << \", \" << #y << \", \" << #z << \") = (\" << x << \", \" << y << \", \" << z << \")\" << endl\n#define db2(x, y) cerr << \"(\" << #x << \", \" << #y << \") = (\" << x << \", \" << y << \")\" << endl\n#define dbv(a) cerr << #a << \" = \"; for (auto xxx: a) cerr << xxx  << \" \"; cerr << endl\n#else\n#define db(x) ;\n#define db3(x, y, z) ;\n#define db2(x, y) ;\n#define dbv(a) ;\n#endif\n\nusing namespace std;\ntypedef long long ll;\ntypedef long long dbl;\n\n\nconst int INF = 1.01e9;\nconst int MOD = (int)1e9 + 7;\n\nstruct Item {\n    int x, y;\n    ll val;\n};\n\nstruct Cond {\n    char type;\n    int a, b;\n\n    bool cover(Item it) {\n        if (type == 'L') {\n            return it.x <= a;\n        }\n        if (type == 'R') {\n            return it.x >= a;\n        }\n        if (type == 'D') {\n            return it.y <= a;\n        }\n        if (type == 'U') {\n            return it.y >= a;\n        }\n        assert(0);\n    }\n};\n\nll slow(vector<Item> a, vector<Cond> b) {\n    int n = a.size(), m = b.size();\n    ll ans = 0;\n    for (int mask = 0; mask < (1 << n); mask++) {\n        vector<int> cnt(m);\n        ll sum = 0;\n        for (int i = 0; i < n; i++) {\n            if (!(mask & (1 << i))) continue;\n            sum += a[i].val;\n            for (int j = 0; j < m; j++) {\n                if (b[j].cover(a[i])) {\n                    cnt[j]++;\n                }\n            }\n        }\n        bool bad = 0;\n        for (int i = 0; i < m; i++) {\n            if (cnt[i] > b[i].b) {\n                bad = 1;\n            }\n        }\n        if (bad) continue;\n        ans = max(ans, sum);\n    }\n    return ans;\n}\n\n\nbool eq(dbl a, dbl b) {\n    return fabs(a - b) < 1e-9;\n}\n\nbool ls(dbl a, dbl b) {\n    return !eq(a, b) && a < b;\n}\n\nvector<dbl> simplex(vector<vector<dbl> > a) {\n    int n = a.size() - 1;\n    int m = a[0].size() - 1;\n    vector<int> left(n + 1), up(m + 1);\n    iota(up.begin(), up.end(), 0);\n    iota(left.begin(), left.end(), m);\n    auto pivot = [&](int x, int y) {\n        swap(left[x], up[y]);\n        dbl k = a[x][y];\n        a[x][y] = 1;\n        vector<int> vct;\n        for (int j = 0; j <= m; j++) {\n            a[x][j] /= k;\n            if (!eq(a[x][j], 0)) vct.push_back(j);\n        }\n        for (int i = 0; i <= n; i++) {\n            if (eq(a[i][y], 0) || i == x) continue;\n            k = a[i][y];\n            a[i][y] = 0;\n            for (int j : vct) a[i][j] -= k * a[x][j];\n        }\n    };\n    while (1) {\n        int x = -1;\n        for (int i = 1; i <= n; i++) if (ls(a[i][0], 0) && (x == -1 || a[i][0] < a[x][0])) x = i;\n        if (x == -1) break;\n        int y = -1;\n        for (int j = 1; j <= m; j++) if (ls(a[x][j], 0) && (y == -1 || a[x][j] < a[x][y])) y = j;\n        if (y == -1) return vector<dbl>(m + 1, 0);\n        pivot(x, y);\n    }\n    while (1) {\n        int y = -1;\n        for (int j = 1; j <= m; j++) if (ls(0, a[0][j]) && (y == -1 || a[0][j] > a[0][y])) y = j;\n        if (y == -1) break;\n        int x = -1;\n        for (int i = 1; i <= n; i++) if (ls(0, a[i][y]) && (x == -1 || a[i][0] / a[i][y] < a[x][0] / a[x][y])) x = i;\n        if (x == -1) assert(0); // unbounded\n        pivot(x, y);\n    }\n    vector<dbl> ans(m + 1);\n    for (int i = 1; i <= n; i++) if (left[i] <= m) ans[left[i]] = a[i][0];\n    ans[0] = -a[0][0];\n    return ans;\n}\n// j=1..m: x[j]>=0\n// i=1..n: sum(j=1..m) A[i][j]*x[j] <= A[i][0]\n// max sum(j=1..m) A[0][j]*x[j]\n// res[0] is answer\n// res[1..m] is certificate\n\nll fast(vector<Item> a, vector<Cond> b) {\n    int n = a.size(), m = b.size();\n    vector<vector<dbl>> c(m + 1, vector<dbl>(n + 1));\n    for (int i = 0; i < n; i++) {\n        c[0][1 + i] = a[i].val;\n    }\n    for (int i = 0; i < m; i++) {\n        c[1 + i][0] = b[i].b;\n        for (int j = 0; j < n; j++) {\n            if (b[i].cover(a[j])) {\n                c[1 + i][1 + j] = 1;\n            }\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        vector<dbl> cur(n + 1);\n        cur[0] = 1;\n        cur[1 + i] = 1;\n        c.push_back(cur);\n    }\n    ll res = 0;\n    for (int cnt = 1; cnt <= n; cnt++) {\n        auto cc = c;\n        vector<dbl> cur(n + 1, 1);\n        cur[0] = cnt;\n        cc.push_back(cur);\n        for (auto &x : cur) x *= -1;\n        cc.push_back(cur);\n        res = max(res, (ll)round(simplex(cc)[0]));\n    }\n    return res;\n}\n\nvoid stress() {\n    for (int it =0;; it++) {\n        mt19937_64 rnd(it);\n        db(it);\n\n\n        int n = rnd() % 10 + 1;\n        vector<Item> a(n);\n        for (int i =0 ; i < n; i++) {\n            a[i].x = rnd() % 100;\n            a[i].y = rnd() % 100;\n            a[i].val = rnd() % (ll)1e15;\n        }\n        int m = rnd() % 10 + 1;\n        vector<Cond> b(m);\n        for (int i = 0; i < m; i++) {\n            b[i].a = rnd() % 100;\n            b[i].b = rnd() % (n + 1);\n            b[i].type = \"ULDR\"[rnd() % 4];\n        }\n\n        auto ans1 = fast(a, b);\n        auto ans2 = slow(a, b);\n        if (ans1 != ans2) {\n            cout << ans1 << \" instead of \" << ans2 << endl;\n            exit(0);\n        }\n    }\n}\n\nint main() {\n#ifdef HOME\n    assert(freopen(\"in\", \"r\", stdin));\n#endif\n//    stress();\n\n    int n;\n    while (scanf(\"%d\", &n) == 1) {\n        vector<Item> a(n);\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d%d%lld\", &a[i].x, &a[i].y, &a[i].val);\n        }\n        int m;\n        scanf(\"%d\", &m);\n        vector<Cond> b(m);\n        for (int i = 0; i < m; i++) {\n            scanf(\" %c%d%d\", &b[i].type, &b[i].a, &b[i].b);\n        }\n\n//        printf(\"%lld\\n\", slow(a, b));\n        printf(\"%lld\\n\", fast(a, b));\n    }\n\n#ifdef HOME\n    cerr << \"time: \" << clock() * 1.0 / CLOCKS_PER_SEC << endl;\n#endif\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef HOME\n#define db(x) cerr << #x << \" = \" << x << endl\n#define db3(x, y, z) cerr << \"(\" << #x << \", \" << #y << \", \" << #z << \") = (\" << x << \", \" << y << \", \" << z << \")\" << endl\n#define db2(x, y) cerr << \"(\" << #x << \", \" << #y << \") = (\" << x << \", \" << y << \")\" << endl\n#define dbv(a) cerr << #a << \" = \"; for (auto xxx: a) cerr << xxx  << \" \"; cerr << endl\n#else\n#define db(x) ;\n#define db3(x, y, z) ;\n#define db2(x, y) ;\n#define dbv(a) ;\n#endif\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double dbl;\n\n\nconst int INF = 1.01e9;\nconst int MOD = (int)1e9 + 7;\n\nstruct Item {\n    int x, y;\n    ll val;\n};\n\nstruct Cond {\n    char type;\n    int a, b;\n\n    bool cover(Item it) {\n        if (type == 'L') {\n            return it.x <= a;\n        }\n        if (type == 'R') {\n            return it.x >= a;\n        }\n        if (type == 'D') {\n            return it.y <= a;\n        }\n        if (type == 'U') {\n            return it.y >= a;\n        }\n        assert(0);\n    }\n};\n\nll slow(vector<Item> a, vector<Cond> b) {\n    int n = a.size(), m = b.size();\n    ll ans = 0;\n    for (int mask = 0; mask < (1 << n); mask++) {\n        vector<int> cnt(m);\n        ll sum = 0;\n        for (int i = 0; i < n; i++) {\n            if (!(mask & (1 << i))) continue;\n            sum += a[i].val;\n            for (int j = 0; j < m; j++) {\n                if (b[j].cover(a[i])) {\n                    cnt[j]++;\n                }\n            }\n        }\n        bool bad = 0;\n        for (int i = 0; i < m; i++) {\n            if (cnt[i] > b[i].b) {\n                bad = 1;\n            }\n        }\n        if (bad) continue;\n        ans = max(ans, sum);\n    }\n    return ans;\n}\n\n\nbool eq(dbl a, dbl b) {\n    return fabs(a - b) < 1e-9;\n}\n\nbool ls(dbl a, dbl b) {\n    return !eq(a, b) && a < b;\n}\n\nvector<dbl> supersimplex(vector<vector<dbl> > a) {\n    int n = a.size() - 1;\n    int m = a[0].size() - 1;\n    vector<int> left(n + 1), up(m + 1);\n    iota(up.begin(), up.end(), 0);\n    iota(left.begin(), left.end(), m);\n    while (1) {\n        auto pivot = [&](int x, int y) {\n            swap(left[x], up[y]);\n            dbl k = a[x][y];\n            a[x][y] = 1;\n            vector<int> vct;\n            for (int j = 0; j <= m; j++) {\n                a[x][j] /= k;\n                if (!eq(a[x][j], 0)) vct.push_back(j);\n            }\n            for (int i = 0; i <= n; i++) {\n                if (eq(a[i][y], 0) || i == x) continue;\n                k = a[i][y];\n                a[i][y] = 0;\n                for (int j : vct) a[i][j] -= k * a[x][j];\n            }\n        };\n        while (1) {\n            int x = -1;\n            for (int i = 1; i <= n; i++) if (ls(a[i][0], 0) && (x == -1)) x = i;\n            if (x == -1) break;\n            int y = -1;\n            for (int j = 1; j <= m; j++) if (ls(a[x][j], 0) && (y == -1 || a[x][j] < a[x][y])) y = j;\n            if (y == -1) return vector<dbl>(m, 0);\n            pivot(x, y);\n        }\n        while (1) {\n            int y = -1;\n            for (int j = 1; j <= m; j++) if (ls(0, a[0][j]) && (y == -1 || a[0][j] > a[0][y])) y = j;\n            if (y == -1) break;\n            int x = -1;\n            for (int i = 1; i <= n; i++) if (ls(0, a[i][y]) && (x == -1 || a[i][0] / a[i][y] < a[x][0] / a[x][y])) x = i;\n            if (x == -1) break;\n            pivot(x, y);\n        }\n\n        vector<int> v;\n        vector<dbl> ans(m + 1);\n        vector<int> rev(m + 1);\n        for (int i = 1; i <= n; i++) if (left[i] <= m) ans[left[i]] = a[i][0], rev[left[i]] = i;\n        ans[0] = -a[0][0];\n        for (int i = 1; i <= m; i++) {\n            if (!eq(ans[i], floor(ans[i])) && !eq(ans[i], floor(ans[i]) + 1)) {\n                v.push_back(rev[i]);\n            }\n        }\n        if (clock() / (double)CLOCKS_PER_SEC > 1.7 || n * m > 1e7) return ans;\n        if (v.empty()) {\n            return ans;\n        }\n        for (int i = 0; i <= n; i++) {\n            for (int j = 0; j < (int)v.size(); j++) {\n                a[i].push_back(0);\n            }\n        }\n        for (int i = 0; i < (int)v.size(); i++) {\n            vector<dbl> cur(a[0].size());\n            cur[m + 1 + i] = 1;\n            cur[0] = floor(a[v[i]][0]) - a[v[i]][0];\n            for (int j = 1; j <= m; j++) {\n                cur[j] = floor(a[v[i]][j]) - a[v[i]][j];\n            }\n            a.push_back(cur);\n        }\n        m += v.size();\n        n += v.size();\n        up.resize(up.size() + v.size());\n        left.resize(left.size() + v.size());\n    }\n}\n// j=1..m: x[j]>=0\n// i=1..n: sum(j=1..m) A[i][j]*x[j] <= A[i][0]\n// max sum(j=1..m) A[0][j]*x[j]\n// res[0] is answer\n// res[1..m] is certificate\n\nll fast(vector<Item> a, vector<Cond> b) {\n    int n = a.size(), m = b.size();\n    vector<vector<dbl>> c(m + 1, vector<dbl>(n + 1));\n    for (int i = 0; i < n; i++) {\n        c[0][1 + i] = a[i].val;\n    }\n    for (int i = 0; i < m; i++) {\n        c[1 + i][0] = b[i].b;\n        for (int j = 0; j < n; j++) {\n            if (b[i].cover(a[j])) {\n                c[1 + i][1 + j] = 1;\n            }\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        vector<dbl> cur(n + 1);\n        cur[0] = 1;\n        cur[1 + i] = 1;\n        c.push_back(cur);\n    }\n    return (ll)round(supersimplex(c)[0]);\n}\n\nvoid stress() {\n    for (int it = 0;; it++) {\n        mt19937_64 rnd(it);\n        db(it);\n\n\n        int n = 80;\n        vector<Item> a(n);\n        for (int i =0 ; i < n; i++) {\n            a[i].x = rnd() % 1000;\n            a[i].y = rnd() % 1000;\n            a[i].val = rnd() % (ll)1e15;\n        }\n        int m = rnd() % (4 * n) + 1;\n        vector<Cond> b(m);\n        for (int i = 0; i < m; i++) {\n            b[i].a = rnd() % 1000;\n            b[i].b = rnd() % (n + 1);\n            b[i].type = \"ULDR\"[rnd() % 4];\n        }\n\n        auto ans1 = fast(a, b);\n//        auto ans2 = slow(a, b);\n        auto ans2 = ans1;\n        if (ans1 != ans2) {\n            cout << ans1 << \" instead of \" << ans2 << endl;\n            exit(0);\n        }\n    }\n}\n\nint main() {\n#ifdef HOME\n    assert(freopen(\"in\", \"r\", stdin));\n    stress();\n#endif\n\n    int n;\n    while (scanf(\"%d\", &n) == 1) {\n        vector<Item> a(n);\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d%d%lld\", &a[i].x, &a[i].y, &a[i].val);\n        }\n        int m;\n        scanf(\"%d\", &m);\n        vector<Cond> b(m);\n        for (int i = 0; i < m; i++) {\n            scanf(\" %c%d%d\", &b[i].type, &b[i].a, &b[i].b);\n        }\n\n//        printf(\"%lld\\n\", slow(a, b));\n        printf(\"%lld\\n\", fast(a, b));\n    }\n\n#ifdef HOME\n    cerr << \"time: \" << clock() * 1.0 / CLOCKS_PER_SEC << endl;\n#endif\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#define lop(c,l) for(int c=1;c<=(l);++c)\n#define loop(c,l) for(int c=0;c<(l);++c)\nusing namespace std;\n\n#define int long long\ntemplate<int Vari,int Crat>\nstruct algo_simplex{\n\tint matrix[Crat+1][Vari+1],ans[Vari+1];\n\tint id[Crat<<1|1];\n\tint vari,crat;\n\tint target;\n\tconst char* cond;\n\tvoid pivot(const int& l,const int& e){\n\t\tswap(id[vari+l],id[e]);\n\t\tint t=matrix[l][e];\n\t\tmatrix[l][e]=1;\n\t\tfor(int j=0;j<=vari;j++) matrix[l][j]/=t;\n\t\tfor(int i=0;i<=crat;i++) if(i!=l&&abs(matrix[i][e])>1e-8){\n\t\t\tt=matrix[i][e];\n\t\t\tmatrix[i][e]=0;\n\t\t\tfor(int j=0;j<=vari;j++) matrix[i][j]-=matrix[l][j]*t;\n\t\t}\n\t}\n\tbool init(){\n\t\twhile(1){\n\t\t\tint l=0,e=0;\n\t\t\tfor(int i=1;i<=crat;i++) if(matrix[i][0]<-1e-8&&(!l||(rand()&1))) l=i;\n\t\t\tif(!l) return 1;\n\t\t\tfor(int j=1;j<=vari;j++) if(matrix[l][j]<-1e-8&&(!e||(rand()&1))) e=j;\n\t\t\tif(!e) return 0;\n\t\t\tpivot(l,e);\n\t\t}\n\t}\n\tbool funct(const int& v,const int& c){\n\t\tsrand(new int()-(int*)NULL);\n\t\tvari=v,crat=c;\n\t\tfor(int i=1;i<=vari;i++) id[i]=i;\n\t\tif(!init())\treturn 0;\n\t\twhile(1){\n\t\t\tint l=0,e=0;\n\t\t\tint minn=1e15;\n\t\t\tfor(int j=1;j<=vari&&!e;j++) if(matrix[0][j]>1e-8) e=j;\n\t\t\tif(!e) break;\n\t\t\tfor(int i=1;i<=crat;i++) if(matrix[i][e]>1e-8&&matrix[i][0]/matrix[i][e]<minn) minn=matrix[i][0]/matrix[i][e],l=i;\n\t\t\tif(!l) return 0;\n\t\t\tpivot(l,e);\n\t\t}\n\t\ttarget=-matrix[0][0];\n\t\tfor(int i=1;i<=crat;i++) ans[id[vari+i]]=matrix[i][0];\n\t\treturn 1;\n\t}\n};\nalgo_simplex<80,400> spl;\nstruct loc{\n\tint x,y,v;\n}p[81];\nint n,m,ll,lim;\nchar ch;\nsigned main(signed,char**,char**){\n\tscanf(\"%lld\",&n);\n\tlop(i,n){\n\t\tscanf(\"%lld%lld%lld\",&p[i].x,&p[i].y,&p[i].v);\n\t\tspl.matrix[0][i]=p[i].v;\n\t}\n\tscanf(\"%lld\",&m);\n\tlop(i,m){\n\t\tscanf(\" %c%lld%lld\",&ch,&ll,&lim);\n\t\tswitch(ch){\n\t\t\tcase 'L':{\n\t\t\t\tlop(j,n) if(p[j].x<=ll) spl.matrix[i][j]=1;\n\t\t\t\tspl.matrix[i][0]=lim;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'R':{\n\t\t\t\tlop(j,n) if(p[j].x>=ll) spl.matrix[i][j]=1;\n\t\t\t\tspl.matrix[i][0]=lim;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'D':{\n\t\t\t\tlop(j,n) if(p[j].y<=ll) spl.matrix[i][j]=1;\n\t\t\t\tspl.matrix[i][0]=lim;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'U':{\n\t\t\t\tlop(j,n) if(p[j].y>=ll) spl.matrix[i][j]=1;\n\t\t\t\tspl.matrix[i][0]=lim;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tlop(i,n) spl.matrix[m+i][i]=1,spl.matrix[m+i][0]=1;\n\tspl.funct(n,m+n);\n\tprintf(\"%lld\",spl.target);\n\texit(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define all(x) (x).begin (),(x).end()\n#define sqrt(x) sqrt(abs(x))\n#define re return\n#define sz(x) ((int)(x).size ())\n#define prev PREV\n#define next NEXT\n\nusing ll = long long;\nusing ii = pair<int, int>;\nusing ld = long double;\nusing D = double;\nusing vi = vector<int>;\nusing vii = vector<ii>;\nusing vvi = vector<vi>;\nusing vs = vector<string>;\n\ntemplate<typename T> T abs (T x) { re x < 0 ? -x : x; }\ntemplate<typename T> T sgn (T x) { re x < 0 ? -1 : (x > 0 ? 1 : 0); }\ntemplate<typename T> T sqr (T x) { re x * x; }\ntemplate<typename T> T gcd (T a, T b) { re a != 0 ? gcd (b % a, a) : b; }\n\nconst int inf = 1e9;\nconst ll INF = 1e15;\n\nint n;\nint m;\nint o, e;\nint x[200];\nint y[200];\nll val[200];\nint a[400];\nint b[400];\nstring t[400];\nvi vx, vy;\nint lx[200];\nint rx[200];\nint ly[200];\nint ry[200];\n\nvii v[2000];\nint ec[200000];\nll ef[200000];\nll d[2000];\nll p[2000];\nint mark[2000];\nint prev[2000];\nint preve[2000];\nset<pair<ll, int> > all;\n\n\nvoid addedge (int a, int b, int c, ll d) {\n//\tprintf (\"%d %d %d %I64d\\n\", a, b, c, d);\n\tv[a].pb (mp (b, e));\n\tec[e] = c;\n\tef[e] = d;\n\te++;\n\tv[b].pb (mp (a, e));\n\tec[e] = 0;\n\tef[e] = -d;\n\te++;\n}\n\nll go (int S, int T) {\n\tall.clear ();\n\tfor (int i = 0; i < o; i++) {\n\t\tmark[i] = 0;\n\t\td[i] = 1e18;\n\t}\n\tmark[S] = 1;\n\td[S] = 0;\n\tall.insert (mp (0, S));\n\twhile (!all.empty ()) {\n\t\tint x = all.begin ()->se;\n//\t\tprintf (\"%d\\n\", x);\n\t\tmark[x] = 2;\n\t\tall.erase (all.begin ());\n\t\tfor (int i = 0; i < sz (v[x]); i++) {\n\t\t\tint y = v[x][i].fi;\n\t\t\tint z = v[x][i].se;\n\t\t\tif (ec[z] > 0 && d[x] + p[x] + ef[z] - p[y] < d[y]) {\n\t\t\t\tif (mark[y] == 1) all.erase (mp (d[y], y));\n\t\t\t\td[y] = d[x] + p[x] + ef[z] - p[y];\n\t\t\t\tprev[y] = x;\n\t\t\t\tpreve[y] = z;\n\t\t\t\tmark[y] = 1;\n\t\t\t\tall.insert (mp (d[y], y));\n\t\t\t}\n\t\t}\n\t}\n\tif (mark[T] == 0) re -1;\n\tll ans = d[T] - p[S] + p[T];\n\tfor (int i = 0; i < o; i++)\n\t\tif (mark[i])\n\t\t\tp[i] += d[i];\n\tre ans;\n}\n\nll calc (int h) {\n\tint ox = sz (vx);\n\tint oy = sz (vy);\n\tfor (int i = 0; i < ox; i++) {\n\t\tlx[i] = 0;\n\t\trx[i] = h;\n\t\tfor (int j = 0; j < m; j++)\n\t\t\tif (t[j] == \"L\") {\n\t\t\t\tif (vx[i] <= a[j]) rx[i] = min (rx[i], b[j]);\n\t\t\t} else\n\t\t\tif (t[j] == \"R\") {\n\t\t\t\tif (vx[i] >= a[j] - 1) lx[i] = max (lx[i], h - b[j]);\n\t\t\t}\n\t\tif (lx[i] > rx[i]) re -1;\t\n\t}\n\tfor (int i = 0; i < oy; i++) {\n\t\tly[i] = 0;\n\t\try[i] = h;\n\t\tfor (int j = 0; j < m; j++)\n\t\t\tif (t[j] == \"D\") {\n\t\t\t\tif (vy[i] <= a[j]) ry[i] = min (ry[i], b[j]);\n\t\t\t} else\n\t\t\tif (t[j] == \"U\") {\n\t\t\t\tif (vy[i] >= a[j] - 1) ly[i] = max (ly[i], h - b[j]);\n\t\t\t}\n\t\tif (ly[i] > ry[i]) re -1;\t\n\t}\n\to = 2 * ox + 2 * oy + 2 * n + 5;\n\te = 0;\n\tfor (int i = 0; i < o; i++) v[i].clear ();\n\tint req = 0;\n\taddedge (o - 4, 2 * n + 2 * (ox - 1), inf, 0);\n\tfor (int i = 0; i < ox; i++) {\n//\t\tprintf (\"x %d: %d %d\\n\", vx[i], lx[i], rx[i]);\n\t\treq += lx[i];\n\t\taddedge (2 * n + 2 * i, 2 * n + 2 * i + 1, rx[i] - lx[i], 0);\n\t\taddedge (o - 2, 2 * n + 2 * i + 1, lx[i], 0);\n\t\taddedge (2 * n + 2 * i, o - 1, lx[i], 0);\n\t\tif (i > 0) addedge (2 * n + 2 * i + 1, 2 * n + 2 * (i - 1), inf, 0);\n\t}\n\taddedge (2 * n + 2 * ox + 2 * (oy - 1) + 1, o - 3, inf, 0);\n\tfor (int i = 0; i < oy; i++) {\n//\t\tprintf (\"y %d: %d %d\\n\", vy[i], ly[i], ry[i]);\n\t\treq += ly[i];\n\t\taddedge (2 * n + 2 * ox + 2 * i, 2 * n + 2 * ox + 2 * i + 1, ry[i] - ly[i], 0);\n\t\taddedge (o - 2, 2 * n + 2 * ox + 2 * i + 1, ly[i], 0);\n\t\taddedge (2 * n + 2 * ox + 2 * i, o - 1, ly[i], 0);\n\t\tif (i > 0) addedge (2 * n + 2 * ox + 2 * (i - 1) + 1, 2 * n + 2 * ox + 2 * i, inf, 0);\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\taddedge (2 * i, 2 * i + 1, 1, INF - val[i]);\n\t\tint j = 0;\n\t\twhile (vx[j] < x[i]) j++;\n\t\taddedge (2 * n + 2 * j + 1, 2 * i, inf, 0);\n\t\tj = 0;\n\t\twhile (vy[j] < y[i]) j++;\n\t\taddedge (2 * i + 1, 2 * n + 2 * ox + 2 * j, inf, 0);\n\t}\n\treq += h;\n\taddedge (o - 3, o - 5, inf, 0);\n\taddedge (o - 2, o - 4, h, 0);\n\taddedge (o - 5, o - 1, h, 0);\n\tll ans = 0;\n\tfor (int i = 0; i < o; i++) p[i] = 0;\n\tfor (int i = 0; i < req; i++) {\n\t\tll tmp = go (o - 2, o - 1);\n//\t\tprintf (\"%d: %d = %I64d\\n\", h, i, INF - tmp);\n\t\tif (tmp == -1) re -1;\n\t\tans += tmp;\n\t\tint j = o - 1;\n\t\twhile (j != o - 2) {\n\t\t\tint k = prev[j];\n\t\t\tint z = preve[j];\n\t\t\tec[z]--;\n\t\t\tec[z ^ 1]++;\n//\t\t\tprintf (\"%d -> %d = %d\\n\", k / 2, j / 2, ec[z]);\n\t\t\tj = k;\n\t\t}\n\t}\n\tll tmp = go (o - 2, o - 1);\n\tre h * INF - ans;\n}\n\nint main () {\n\tcin >> n;\n\tfor (int i = 0; i < 100; i++) {\n\t\tvx.pb (i + 1);\n\t\tvy.pb (i + 1);\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x[i] >> y[i] >> val[i];\n\t\tvx.pb (x[i]);\n\t\tvy.pb (y[i]);\n\t}\t\n\tcin >> m;\n\tfor (int i = 0; i < m; i++) {\n\t\tcin >> t[i] >> a[i] >> b[i];\n\t\tif (t[i] == \"L\" || t[i] == \"R\") vx.pb (a[i]); else vy.pb (a[i]);\n\t}\n\tsort (all (vx));\n\tvx.resize (unique (all (vx)) - vx.begin ());\n\tsort (all (vy));\n\tvy.resize (unique (all (vy)) - vy.begin ());\n\tll ans = 0;\n\tint l = 0, r = n;\n\twhile (r - l > 2) {\n\t\tint s1 = (2 * l + r) / 3;\n\t\tint s2 = (l + 2 * r) / 3;\n\t\tll h1 = calc (s1);\n\t\tll h2 = calc (s2);\n\t\tif (h1 >= h2) r = s2; else l = s1;\n\t}\n\tfor (int i = l; i <= r; i++) ans = max (ans, calc (i));\n/*\tfor (int t = 0; t <= n; t++) {\n\t\tll tmp = calc (t);\n\t\tans = max (ans, tmp);\n\t}\t*/\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define space putchar(' ')\n#define enter putchar('\\n')\n#define MAXN 100005\n#define eps 1e-10\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef unsigned int u32;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;T f = 1;char c = getchar();\n    while(c < '0' || c > '9') {\n\tif(c == '-') f = -1;\n\tc = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n\tres = res * 10 + c - '0';\n\tc = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n\tout(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nstruct node {\n    int to,next,cap;int64 val;\n}E[1000005];\nint sumE,head[505],a[85],b[85],x[85],y[85],N,M;\nint L[2][85],R[2][85],S,T,f;\nint64 val[85],res,ans,ex;\nbool vis[505];\nchar s[330][2];\nvoid add(int u,int v,int c,int64 a) {\n    E[++sumE].to = v;\n    E[sumE].next = head[u];\n    E[sumE].cap = c;\n    E[sumE].val = a;\n    head[u] = sumE;\n}\nvoid addtwo(int u,int v,int c,int64 a) {\n    add(u,v,c,a);\n    add(v,u,0,-a);\n}\nvoid build(int K) {\n    sumE = 1;memset(head,0,sizeof(head));\n    for(int i = 1 ; i <= N ; ++i) L[0][i] = L[1][i] = 1,R[0][i] = R[1][i] = 100;\n    for(int i = 1 ; i <= M ; ++i) {\n        if(b[i] >= K) continue;\n        if(s[i][0] == 'L') {\n            L[0][b[i] + 1] = a[i] + 1;\n        }\n        else if(s[i][0] == 'R') {\n            R[0][K - b[i]] = a[i] - 1;\n        }\n        else if(s[i][0] == 'D') {\n            L[1][b[i] + 1] = a[i] + 1;\n        }\n        else if(s[i][0] == 'U') {\n            R[1][K - b[i]] = a[i] - 1;\n        }\n    }\n    for(int i = 2 ; i <= K ; ++i) {\n    \tL[0][i] = max(L[0][i - 1],L[0][i]);\n    \tL[1][i] = max(L[1][i - 1],L[1][i]);\n    }\n    for(int i = K - 1 ; i >= 1 ; --i) {\n    \tR[0][i] = min(R[0][i + 1],R[0][i]);\n    \tR[1][i] = min(R[1][i + 1],R[1][i]);\n    }\n    S = 1;T = 2 * K + 2 * N + 2;\n    for(int i = 1 ; i <= K ; ++i) {\n    \taddtwo(S,i + 1,1,0);\n    \taddtwo(i + K + 2 * N + 1,T,1,0);\n    \tfor(int j = 1 ; j <= N ; ++j) {\n    \t    if(x[j] >= L[0][i] && x[j] <= R[0][i]) {\n        \t\taddtwo(i + 1,K + j + 1,1,0);\n    \t    }\n    \t    if(y[j] >= L[1][i] && y[j] <= R[1][i]) {\n        \t\taddtwo(K + N + j + 1,i + K + 2 * N + 1,1,0);\n    \t    }\n    \t}\n    }\n    for(int i = 1 ; i <= N ; ++i) {\n        addtwo(K + i + 1,K + N + i + 1,1,val[i]);\n    }\n\n}\nint maxflow(int u,int aug) {\n    if(u == T) {\n    \tres += ex * aug;\n        f += aug;\n    \treturn aug;\n    }\n    int flow = 0;\n    vis[u] = 1;\n    for(int i = head[u] ; i ; i = E[i].next) {\n        int v = E[i].to;\n    \tif(E[i].cap > 0 && !vis[v] && E[i].val == 0) {\n    \t    int t = maxflow(v,min(E[i].cap,aug - flow));\n    \t    flow += t;\n    \t    E[i].cap -= t;\n    \t    E[i ^ 1].cap += t;\n    \t}\n    }\n    return flow;\n}\nbool modlabel() {\n    int64 p = -1e18;\n    for(int u = S ; u <= T ; ++u) {\n    \tif(vis[u]) {\n    \t    for(int i = head[u] ; i ; i = E[i].next) {\n        \t\tint v = E[i].to;\n        \t\tif(!vis[v] && E[i].cap > 0 && E[i].val > p) p = E[i].val;\n    \t    }\n    \t}\n    }\n    if(p == -1e18) return false;\n    ex += p;\n    for(int u = S ; u <= T ; ++u) {\n    \tif(vis[u]) {\n    \t    for(int i = head[u] ; i ; i = E[i].next) {\n        \t\tE[i].val -= p;\n        \t\tE[i ^ 1].val += p;\n    \t    }\n    \t}\n    }\n    return true;\n}\nvoid Init() {\n    read(N);\n    for(int i = 1 ; i <= N ; ++i) {\n    \tread(x[i]);read(y[i]);read(val[i]);\n    }\n    read(M);\n    for(int i = 1 ; i <= M ; ++i) {\n    \tscanf(\"%s\",s[i]);read(a[i]);read(b[i]);\n    }\n}\nvoid Solve() {\n    ans = 0;\n    for(int i = 1 ; i <= N ; ++i) {\n    \tbuild(i);\n    \tres = 0;ex = 0;\n        f = 0;\n    \tdo {\n    \t    do {\n                memset(vis,0,sizeof(vis));\n    \t    }while(maxflow(1,i));\n    \t}while(modlabel());\n        if(f == i) ans = max(ans,res);\n    }\n    out(ans);enter;\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Init();\n    Solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <assert.h>\n\nusing namespace std;\n\nstruct Jewel\n{\n  int x, y;\n  long long v;\n  int cnt = 0;\n\n  bool operator<(const Jewel &other) const\n  {\n    return (other.v == v ? cnt < other.cnt : other.v < v);\n  }\n};\n\nstruct Request\n{\n  string t;\n  int a, b;\n  int cnt = 0;\n};\n\nint main()\n{\n  int N;\n  cin >> N;\n  vector<Jewel> jewel(N);\n  for (int i = 0; i < N; i++)\n  {\n    int x, y;\n    long long v;\n    cin >> x >> y >> v;\n    jewel[i] = {x, y, v};\n  }\n  int M;\n  cin >> M;\n  vector<Request> request(M);\n  for (int i = 0; i < M; i++)\n  {\n    string t;\n    int a, b;\n    cin >> t >> a >> b;\n    request[i] = {t, a, b};\n  }\n  chrono::system_clock::time_point start = chrono::system_clock::now();\n  long long ans = 0;\n  while (chrono::duration_cast<chrono::microseconds>(chrono::system_clock::now() - start).count() / 1000 < 4993)\n  {\n    long long tmp = 0;\n    for (Request &j : request)\n      j.cnt = 0;\n    for (Jewel i : jewel)\n    {\n      bool ok = true;\n      for (Request j : request)\n        switch (j.t[0])\n        {\n        case 'L':\n          if (i.x <= j.a && j.b < j.cnt + 1)\n            ok = false;\n          break;\n        case 'R':\n          if (j.a <= i.x && j.b < j.cnt + 1)\n            ok = false;\n          break;\n        case 'D':\n          if (i.y <= j.a && j.b < j.cnt + 1)\n            ok = false;\n          break;\n        case 'U':\n          if (j.a <= i.y && j.b < j.cnt + 1)\n            ok = false;\n          break;\n        }\n      if (!ok)\n        continue;\n      tmp += i.v;\n      for (Request &j : request)\n        switch (j.t[0])\n        {\n        case 'L':\n          if (i.x <= j.a)\n            j.cnt++;\n          break;\n        case 'R':\n          if (j.a <= i.x)\n            j.cnt++;\n          break;\n        case 'D':\n          if (i.y <= j.a)\n            j.cnt++;\n          break;\n        case 'U':\n          if (j.a <= i.y)\n            j.cnt++;\n          break;\n        }\n    }\n    random_shuffle(jewel.begin(), jewel.end());\n    if (ans < tmp)\n      ans = tmp;\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\ntypedef long double louble;\n\n#define so(a) ((int)((a).size()))\n\ntemplate<typename T1,typename T2> inline T1 max(T1 a,T2 b){return a<b?b:a;}\ntemplate<typename T1,typename T2> inline T1 min(T1 a,T2 b){return a<b?a:b;}\n\nconst char lf = '\\n';\n\nnamespace ae86\n{\n\tconst int bufl = 1 << 15;\n\n\tchar buf[bufl],*s=buf,*t=buf;\n\n\tinline int fetch()\n\t{\n\t\tif(s==t){t=(s=buf)+fread(buf,1,bufl,stdin);if(s==t)return EOF;}\n\t\treturn *s++;\n\t}\n\n\tinline lint ty()\n\t{\n\t\tlint a=0;int b=1,c=fetch();\n\t\twhile(!isdigit(c))b^=c=='-',c=fetch();\n\t\twhile(isdigit(c))a=a*10+c-48,c=fetch();\n\t\treturn b?a:-a;\n\t}\n\n\tinline int tc()\n\t{\n\t\tint c=fetch();\n\t\twhile(c<=32 && c!=EOF)c=fetch();\n\t\treturn c;\n\t}\n}\nusing ae86::ty;\nusing ae86::tc;\n\nconst int _ = 407 , inf = 0x3f3f3f3f;\nconst lint V = 1e16 , linf = 0x3f3f3f3f3f3f3f3f;\n\nstruct costflow\n{\n\tstatic const int _n = _ , _e = _ * 9999;\n\n\tint to[_e],ne[_e],he[_n],ecnt;\n\tlint ev[_e],ec[_e];\n\n\tvoid adde(int a,int b,lint c,lint d){to[++ecnt]=b,ev[ecnt]=c,ec[ecnt]=d,ne[ecnt]=he[a],he[a]=ecnt;}\n\tvoid addde(int a,int b,lint c,lint d){adde(a,b,c,d),adde(b,a,0,-d);}\n\n\tint S,T,ed[_n],dcnt;\n\tlint dis[_n];int pv[_n],pe[_n];\n\t\n\tint bfs()\n\t{\n\t\tmemset(dis,63,sizeof(lint)*(dcnt+2));\n\t\tmemset(pv,0,sizeof(int)*(dcnt+2));\n\t\tmemset(pe,0,sizeof(int)*(dcnt+2));\n\t\tmemset(ed,0,sizeof(int)*(dcnt+2));\n\t\t\n\t\tqueue<int> q;\n\t\tdis[S]=0,ed[S]=1,q.emplace(S);\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tint a=q.front();\n\t\t\tq.pop(),ed[a]=0;\n\t\t\tfor(int i=he[a];i;i=ne[i])\n\t\t\t{\n\t\t\t\tif(!ev[i])continue;\n\t\t\t\tint b=to[i];\n\t\t\t\tif(dis[a]+ec[i]>=dis[b])continue;\n\t\t\t\tdis[b]=dis[a]+ec[i],pe[b]=i,pv[b]=a;\n\t\t\t\tif(!ed[b])q.emplace(b),ed[b]=1;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn dis[T]<linf;\n\t}\n\n\tpair<lint,lint> run(int s,int t)\n\t{\n\t\tS=s,T=t;\n\t\tlint sflw=0,scos=0;\n\t\twhile(bfs())\n\t\t{\n\t\t\tlint dlt=linf;\n\t\t\tfor(int i=T;i!=S;i=pv[i])dlt=min(dlt,ev[pe[i]]);\n\t\t\tsflw+=dlt,scos+=dis[T]*dlt;\n\t\t\tfor(int i=T;i!=S;i=pv[i])ev[pe[i]]-=dlt,ev[pe[i]^1]+=dlt;\n\t\t}\n\t\treturn make_pair(sflw,scos);\n\t}\n\t\n\tvoid cls()\n\t{\n\t\tmemset(he,0,sizeof(he)),ecnt=1,dcnt=0;\n\t}\n}f;\n\nint n,m,px[_],py[_];lint pv[_];\nint dir[_]={0},loc[_]={0},lim[_]={0};\n\nint ll[_],rr[_],uu[_],dd[_];\n\nlint finder(int tar)\n{\n\tf.cls();\n\n\tfor(int i=1;i<=tar;i++)ll[i]=dd[i]=0,rr[i]=uu[i]=inf;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tif(lim[i]>=tar)continue;\n\t\tif(dir[i]=='L')ll[lim[i]+1]=loc[i]+1;\n\t\tif(dir[i]=='R')rr[tar-lim[i]]=loc[i]-1;\n\t\tif(dir[i]=='D')dd[lim[i]+1]=loc[i]+1;\n\t\tif(dir[i]=='U')uu[tar-lim[i]]=loc[i]-1;\n\t}\n\n\tfor(int i=2;i<=tar;i++)ll[i]=max(ll[i],ll[i-1]),dd[i]=max(dd[i],dd[i-1]);\n\tfor(int i=tar-1;i>=1;i--)rr[i]=min(rr[i],rr[i+1]),uu[i]=min(uu[i],uu[i+1]);\n\n\tf.dcnt=n+n+tar+tar;\n\tint s=++f.dcnt,t=++f.dcnt;\n\n\tfor(int i=1;i<=n;i++)f.addde(i,n+i,1,-pv[i]-V);\n\tfor(int i=1;i<=tar;i++)\n\t{\n\t\tf.addde(s,n+n+i,1,0),f.addde(n+n+tar+i,t,1,0);\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tif(ll[i]<=px[j] && px[j]<=rr[i])f.addde(n+n+i,j,1,0);\n\t\t\tif(dd[i]<=py[j] && py[j]<=uu[i])f.addde(n+j,n+n+tar+i,1,0);\n\t\t}\n\t}\n\n\tauto res=f.run(s,t);\n\tif(res.first<tar)return -1;\n\treturn -res.second-V*tar;\n}\n\nint main()\n{\n\tios::sync_with_stdio(0),cout.tie(nullptr);\n\n\tn=ty();\n\tfor(int i=1;i<=n;i++)px[i]=ty(),py[i]=ty(),pv[i]=ty();\n\tm=ty();\n\tfor(int i=1;i<=m;i++)dir[i]=tc(),loc[i]=ty(),lim[i]=ty();\n\t\n\tlint ans=0;\n\tfor(int i=1;i<=n;i++)ans=max(ans,finder(i));\n\tcout<<ans<<lf;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<queue>\n#define MAXN 80\n#define MAXM 320\n#define MAXNODE 500\n#define MAXEDGE MAXNODE*MAXNODE\n#define INF 0x3FFFFFFF\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,LL> PII;\nstruct Point\n{\n\tint x,y;\n\tLL V;\n}poi[MAXN+5];\nstruct Limit\n{\n\tint typ,a,b;\n}lim[MAXM+5];\nstruct edge\n{\n\tint to,cap;\n\tLL cost;\n\tedge *nxt,*bck;\n}edges[MAXEDGE*2+5];\nedge *ncnt,*Adj[MAXNODE+5],*Cur[MAXNODE+5];\nint n,m;\nint dn[MAXN+5],up[MAXN+5];\nLL dist[MAXNODE+5];\nbool vis[MAXNODE+5];\nvoid Init()\n{\n\tncnt=&edges[0];\n\tmemset(Adj,0,sizeof(Adj));\n}\nvoid AddEdge(int u,int v,int cap,LL cost)\n{\n\tedge *p=++ncnt;\n\tp->to=v;p->cap=cap;p->cost=cost;\n\tp->nxt=Adj[u];Adj[u]=p;\n\t\n\tedge *q=++ncnt;\n\tq->to=u;q->cap=0;q->cost=-cost;\n\tq->nxt=Adj[v];Adj[v]=q;\n\t\n\tp->bck=q,q->bck=p;\n}\nbool SPFA(int S,int T,int nds)\n{\n\tstatic queue<int> que;\n\twhile(que.empty()==false)\tque.pop();\n\tfor(int i=S;i<=T;i++)\n\t\tvis[i]=false,dist[i]=-1LL;\n\tque.push(S);vis[S]=true;dist[S]=0;\n\twhile(que.empty()==false)\n\t{\n\t\tint u=que.front();\n\t\tque.pop();vis[u]=false;\n\t\tfor(edge *p=Adj[u];p!=NULL;p=p->nxt)\n\t\t{\n\t\t\tint v=p->to;\n\t\t\tif(p->cap&&dist[v]<dist[u]+p->cost)\n\t\t\t{\n\t\t\t\tdist[v]=dist[u]+p->cost;\n\t\t\t\tif(vis[v]==false)\n\t\t\t\t\tvis[v]=true,que.push(v);\n\t\t\t}\n\t\t}\n\t}\n\tif(dist[T]==-1)\n\t\treturn false;\n\treturn true;\n}\nint Aug(int T,int u,int tot,LL &ans)\n{\n\tif(u==T)\n\t\treturn tot;\n\tvis[u]=true;\n\tint sum=0,delta;\n\tfor(edge *&p=Cur[u];p!=NULL;p=p->nxt)\n\t{\n\t\tint v=p->to;\n\t\tif(!vis[v]&&p->cap&&dist[u]+p->cost==dist[v])\n\t\t{\n\t\t\tdelta=min(p->cap,tot-sum);\n\t\t\tdelta=Aug(T,v,delta,ans);\n\t\t\tsum+=delta;\n\t\t\tp->cap-=delta,p->bck->cap+=delta;\n\t\t\tans+=1LL*delta*p->cost;\n\t\t\tif(tot==sum)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tvis[u]=false;\n\treturn sum;\n}\nPII Max_Cost_Flow(int S,int T,int nds)\n{\n\tPII ret=PII(0,0);\n\tint tmn=0;\n\twhile(SPFA(S,T,nds))\n\t{\n\t\tfor(int i=S;i<=T;i++)\n\t\t\tCur[i]=Adj[i],vis[i]=false;\n\t\tret.first+=Aug(T,S,INF,ret.second);\n\t\ttmn++;\n\t}\n\treturn ret;\n}\nvoid DeBug(int S,int T)\n{\n\tprintf(\"===========BEGIN============\\n\");\n\tfor(int i=S;i<=T;i++)\n\t{\n\t\tprintf(\"%d:\",i);\n\t\tfor(edge *p=Adj[i];p!=NULL;p=p->nxt)\n\t\t\tif(p->cap)\n\t\t\t\tprintf(\"(%d %d %lld) \",p->to,p->cap,p->cost);\n\t\tprintf(\"\\n\");\n\t}\n\tprintf(\"============END=============\\n\");\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d %d %lld\",&poi[i].x,&poi[i].y,&poi[i].V);\n\tscanf(\"%d\",&m);\n\tchar opt[10];\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%s %d %d\",opt,&lim[i].a,&lim[i].b);\n\t\tif(opt[0]=='L')\tlim[i].typ=1;\n\t\tif(opt[0]=='R')\tlim[i].typ=2;\n\t\tif(opt[0]=='D')\tlim[i].typ=3;\n\t\tif(opt[0]=='U')\tlim[i].typ=4;\n\t}\n\tLL ans=0;\n\tfor(int tot=1;tot<=n;tot++)\n\t{\n\t\tInit();\n\t\tint nds=tot*2+200+2;\n\t\tint S=0,T=nds-1;\n\t\tfor(int i=1;i<=tot;i++)\n\t\t\tAddEdge(S,i,1,0),AddEdge(i+tot+200,T,1,0);\n\t\t//对于x这一维建边 \n\t\tfor(int i=1;i<=tot;i++)\n\t\t\tdn[i]=1,up[i]=100;\n\t\tfor(int i=1;i<=m;i++)\n\t\t\tif(lim[i].typ==1&&lim[i].b+1<=tot)\n\t\t\t\tdn[lim[i].b+1]=max(dn[lim[i].b+1],lim[i].a+1);\n\t\t\telse if(lim[i].typ==2&&tot-lim[i].b>=1)\n\t\t\t\tup[tot-lim[i].b]=min(up[tot-lim[i].b],lim[i].a-1);\n\t\tfor(int i=2;i<=tot;i++)\n\t\t\tdn[i]=max(dn[i-1],dn[i]);\n\t\tfor(int i=tot-1;i>=1;i--)\n\t\t\tup[i]=min(up[i+1],up[i]);\n\t\tfor(int i=1;i<=tot;i++)\n\t\t\tfor(int j=dn[i];j<=up[i];j++)\n\t\t\t\tAddEdge(i,tot+j,1,0);\n\t\t//对于y这一维建边\n\t\tfor(int i=1;i<=tot;i++)\n\t\t\tdn[i]=1,up[i]=100;\n\t\tfor(int i=1;i<=m;i++)\n\t\t\tif(lim[i].typ==3&&lim[i].b+1<=tot)\n\t\t\t\tdn[lim[i].b+1]=max(dn[lim[i].b+1],lim[i].a+1);\n\t\t\telse if(lim[i].typ==4&&tot-lim[i].b>=1)\n\t\t\t\tup[tot-lim[i].b]=min(up[tot-lim[i].b],lim[i].a-1);\n\t\tfor(int i=2;i<=tot;i++)\n\t\t\tdn[i]=max(dn[i-1],dn[i]);\n\t\tfor(int i=tot-1;i>=1;i--)\n\t\t\tup[i]=min(up[i+1],up[i]);\n\t\tfor(int i=1;i<=tot;i++)\n\t\t\tfor(int j=dn[i];j<=up[i];j++)\n\t\t\t\tAddEdge(j+100+tot,i+200+tot,1,0);\n\t\t//对于每一个点建边\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tAddEdge(tot+poi[i].x,100+tot+poi[i].y,1,poi[i].V);\n\t\tPII ret=Max_Cost_Flow(S,T,nds);\n\t\tif(ret.first==tot)\n\t\t\tans=max(ans,ret.second);\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define mpr make_pair\ntypedef long long LL;\ntypedef pair < int , int > pii;\ntypedef pair < LL , int > pli;\nconst LL INF=(LL)(1e15+5),LINF=(LL)(2e18+5);\nint n,m,x[80],y[80],px[80],py[80];\nLL v[80];\nchar readch(){\n\tchar c=getchar();\n\twhile(c!='L' && c!='R' && c!='U' && c!='D'){\n\t\tc=getchar();\n\t}\n\treturn c;\n}\nnamespace flows{\n\tstruct edge{\n\t\tint v,f,r;\n\t\tLL c;\n\t\tvoid set(int V,int F,int R,LL C){\n\t\t\tv=V;f=F;r=R;c=C;\n\t\t}\n\t}tmp;\n\tvector < edge > adj[505];\n\tpriority_queue < pli > pq;\n\tint predv[505],prede[505],flow;\n\tLL f[505],dis[505],cost;\n\tvoid init(){\n\t\tint i;\n\t\tfor(i=0;i<505;++i) adj[i].clear();\n\t\tmemset(f,0,sizeof(f));\n\t\tflow=0;cost=0ll;\n\t}\n\tvoid addedge(int u,int v,int f,LL c){\n\t\ttmp.set(v,f,(int)adj[v].size(),c);\n\t\tadj[u].push_back(tmp);\n\t\ttmp.set(u,0,(int)adj[u].size()-1,-c);\n\t\tadj[v].push_back(tmp);\n\t}\n\tvoid dijkstra(){\n\t\tint i,j,k;\n\t\tfill(dis,dis+505,LINF);\n\t\tdis[0]=0ll;\n\t\tpq.push(mpr(0ll,0));\n\t\twhile(!pq.empty()){\n\t\t\tLL D=-pq.top().first;\n\t\t\tint cur=pq.top().second;\n\t\t\tpq.pop();\n\t\t\tif(dis[cur]!=D) continue;\n\t\t\tfor(i=0;i<(int)adj[cur].size();++i){\n\t\t\t\tif(!adj[cur][i].f) continue;\n\t\t\t\tint v=adj[cur][i].v;\n\t\t\t\tLL l=adj[cur][i].c+f[cur]-f[v];\n\t\t\t\tif(D+l<dis[v]){\n\t\t\t\t\tdis[v]=D+l;\n\t\t\t\t\tpredv[v]=cur;\n\t\t\t\t\tprede[v]=i;\n\t\t\t\t\tpq.push(mpr(-dis[v],v));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmemcpy(f,dis,sizeof(f));\n\t}\n\tvoid mincostflow(){\n\t\tint i,j,k;\n\t\twhile(1){\n\t\t\tdijkstra();\n\t\t\tif(dis[3]==LINF) return;\n\t\t\tLL c=0ll;\n\t\t\tint f=10000;\n\t\t\tfor(i=3;i;i=predv[i]){\n\t\t\t\tedge &E=adj[predv[i]][prede[i]];\n\t\t\t\tf=min(f,E.f);\n\t\t\t\tc+=E.c;\n\t\t\t}\n\t\t\tflow+=f;\n\t\t\tcost+=c*(LL)f;\n\t\t\tfor(i=3;i;i=predv[i]){\n\t\t\t\tedge &E=adj[predv[i]][prede[i]];\n\t\t\t\tE.f-=f;\n\t\t\t\tadj[i][E.r].f+=f;\n\t\t\t}\n\t\t}\n\t}\n};\nbool cmpx(int a,int b){\n\treturn x[a]<x[b];\n}\nbool cmpy(int a,int b){\n\treturn y[a]<y[b];\n}\nchar TP[405];\nint D[405],V[405];\nvector < pii > consx,consy;\nLL solve(int tot){\n\tint i,j,k;\n\tconsx.clear();\n\tconsy.clear();\n\tfor(i=0;i<m;++i){\n\t\tif(TP[i]=='L')\n\t\t\tconsx.push_back(mpr(D[i],V[i]));\n\t\telse if(TP[i]=='R' && V[i]<tot)\n\t\t\tconsx.push_back(mpr(D[i]-1,-tot+V[i]));\n\t\telse if(TP[i]=='D')\n\t\t\tconsy.push_back(mpr(D[i],V[i]));\n\t\telse if(TP[i]=='U' && V[i]<tot)\n\t\t\tconsy.push_back(mpr(D[i]-1,-tot+V[i]));\n\t}\n\tsort(consx.begin(),consx.end());\n\tsort(consy.begin(),consy.end());\n\tflows::init();\n\t// 0: super source  1: original source  2: extra source\n\t// 3: super sink  4: original sink  5: extra sink\n\tflows::addedge(0,1,tot,0);\n\tflows::addedge(4,3,tot,0);\n\tint extraflow=0,ptr=n-1,pr=1,SX=(int)consx.size();\n\tfor(i=SX-1;i>=0;--i){\n\t\tint d=consx[i].first,f=consx[i].second;\n\t\tif(i==SX-1 || consx[i+1].first!=d){\n\t\t\twhile(ptr>=0 && x[px[ptr]]>d){\n\t\t\t\tflows::addedge(pr,6+SX+px[ptr],1,0);\n\t\t\t\t--ptr;\n\t\t\t}\n\t\t}\n\t\tif(f<0){\n\t\t\tf=-f;\n\t\t\textraflow+=f;\n\t\t\tflows::addedge(2,i+6,f,0);\n\t\t\tflows::addedge(pr,5,f,0);\n\t\t\tflows::addedge(pr,i+6,tot-f,0);\n\t\t}\n\t\telse flows::addedge(pr,i+6,f,0);\n\t\tpr=i+6;\n\t}\n\twhile(ptr>=0){\n\t\tflows::addedge(pr,6+SX+px[ptr],1,0);\n\t\t--ptr;\n\t}\n\tfor(i=0;i<n;++i){\n\t\tflows::addedge(6+SX+i,6+SX+n+i,1,INF-v[i]);\n\t}\n\tptr=0;pr=-1;\n\tint pf;\n\tfor(i=0;i<(int)consy.size();++i){\n\t\tint d=consy[i].first,cur=6+SX+n*2+i;\n\t\twhile(ptr<n && y[py[ptr]]<=d){\n\t\t\tflows::addedge(6+SX+n+py[ptr],cur,1,0);\n\t\t\t++ptr;\n\t\t}\n\t\tif(pr!=-1){\n\t\t\tif(pf<0){\n\t\t\t\tpf=-pf;\n\t\t\t\textraflow+=pf;\n\t\t\t\tflows::addedge(2,cur,pf,0);\n\t\t\t\tflows::addedge(pr,5,pf,0);\n\t\t\t\tflows::addedge(pr,cur,tot-pf,0);\n\t\t\t}\n\t\t\telse flows::addedge(pr,cur,pf,0);\n\t\t}\n\t\tpf=consy[i].second;\n\t\tpr=cur;\n\t}\n\tif(pr!=-1){\n\t\tif(pf<0){\n\t\t\tpf=-pf;\n\t\t\textraflow+=pf;\n\t\t\tflows::addedge(2,4,pf,0);\n\t\t\tflows::addedge(pr,5,pf,0);\n\t\t\tflows::addedge(pr,4,tot-pf,0);\n\t\t}\n\t\telse flows::addedge(pr,4,pf,0);\n\t}\n\twhile(ptr<n){\n\t\tflows::addedge(6+SX+n+py[ptr],4,1,0);\n\t\t++ptr;\n\t}\n\tflows::addedge(0,2,extraflow,0);\n\tflows::addedge(5,3,extraflow,0);\n\tflows::mincostflow();\n\tif(flows::flow==extraflow+tot)\n\t\treturn INF*(LL)tot-flows::cost;\n\treturn 0ll;\n}\nint main(){\n\tint i,j,k;\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;++i){\n\t\tscanf(\"%d%d%lld\",x+i,y+i,v+i);\n\t\t--x[i];--y[i];\n\t\tpx[i]=i;\n\t\tpy[i]=i;\n\t}\n\tscanf(\"%d\",&m);\n\tfor(i=0;i<m;++i){\n\t\tTP[i]=readch();\n\t\tscanf(\"%d%d\",D+i,V+i);\n\t\t--D[i];\n\t}\n\tsort(px,px+n,cmpx);\n\tsort(py,py+n,cmpy);\n\tLL res=0ll;\n\tfor(i=1;i<=n;++i){\n\t\tres=max(res,solve(i));\n\t}\n\tprintf(\"%lld\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define N 710\n#define M 200010\n#define int long long\n#define INF 4611686018427387904LL\ninline int read() {\n    int x=0;\n    char ch=getchar();\n    while (!isdigit(ch)) ch=getchar();\n    while (isdigit(ch)) x=x*10+ch-'0',ch=getchar();\n    return x;\n}\nstruct Point {\n    int x,y,val;\n}p[N];\nstruct opt {\n    char ch; int x,y;\n}a[N];\nint tot=1;\nint fir[N],nex[M],got[M],tak[M],cst[M];\ninline void AddEdge(int x,int y,int z,int w) { \n    nex[++tot]=fir[x],fir[x]=tot,got[tot]=y,tak[tot]=z,cst[tot]=w;\n}\ninline void Add(int x,int y,int z,int w) {\n    AddEdge(x,y,z,w),AddEdge(y,x,0,-w);\n}\nint xl[N],xr[N],yl[N],yr[N];\nint vis[N],dis[N],pre[N],que[N];\ninline int spfa(int s,int t) {\n    int l=1,r=1;\n    for (int i=1;i<=t;i++) vis[i]=false,dis[i]=-INF,pre[i]=0;\n    que[1]=s,dis[s]=0;\n    while (l<=r) {\n        int x=que[l];\n        for (int i=fir[x];i;i=nex[i]) {\n            int y=got[i],w=cst[i];\n            if (!tak[i] || dis[x]+w<=dis[y]) continue;\n            dis[y]=dis[x]+w,pre[y]=i;\n            if (!vis[y]) vis[y]=true,que[++r]=y;\n        }\n        ++l,vis[x]=false;\n    }\n    return dis[t]!=-INF;\n}\ninline int getflow(int s,int t) {\n    int flow=INF;\n    for (int i=t;i!=s;i=got[pre[i]^1]) {\n        flow=min(flow,tak[pre[i]]);\n    }\n    return flow;\n}\ninline void update(int s,int t,int flow,int &Maxflow,int &Mincost) {\n    Maxflow+=flow,Mincost+=flow*dis[t];\n    for (int i=t;i!=s;i=got[pre[i]^1]) {\n        tak[pre[i]]-=flow,tak[pre[i]^1]+=flow;\n    }\n}\ninline int solve(int s,int t) {\n    int Maxflow=0,Mincost=0;\n    while (spfa(s,t)) {\n        update(s,t,getflow(s,t),Maxflow,Mincost);\n    }\n    return Mincost;\n}\nsigned main() {\n    int n=read();\n    for (int i=1;i<=n;i++)\n        p[i].x=read(),p[i].y=read(),p[i].val=read();\n    int m=read(),res=0;\n    for (int i=1;i<=m;i++) {\n        char ch=getchar();\n        while (ch!='U' && ch!='D' && ch!='L' && ch!='R') ch=getchar();\n        a[i].ch=ch,a[i].x=read(),a[i].y=read();\n    }\n    for (int k=1;k<=n;k++) {\n        tot=1,memset(fir,0,sizeof(fir));\n        int s=(k<<1)+(n<<1)+1,t=s+1;\n        for (int i=1;i<=k;i++) Add(s,i,1,0);\n        for (int i=k+2*n+1;i<=2*k+2*n;i++) Add(i,t,1,0);\n        for (int i=k+1;i<=k+n;i++) Add(i,i+n,1,p[i-k].val);\n        for (int i=1;i<=k;i++) xl[i]=yl[i]=0,xr[i]=yr[i]=INF;\n        for (int i=1;i<=m;i++) {\n            if (a[i].ch=='U') for (int j=1;j<=k-a[i].y;j++) yr[j]=min(yr[j],a[i].x-1);\n            if (a[i].ch=='D') for (int j=a[i].y+1;j<=k;j++) yl[j]=max(yl[j],a[i].x+1);\n            if (a[i].ch=='L') for (int j=a[i].y+1;j<=k;j++) xl[j]=max(xl[j],a[i].x+1);\n            if (a[i].ch=='R') for (int j=1;j<=k-a[i].y;j++) xr[j]=min(xr[j],a[i].x-1);\n        }\n        for (int i=1;i<=k;i++) for (int j=1;j<=n;j++)\n            if (xl[i]<=p[j].x && p[j].x<=xr[i]) Add(i,j+k,1,0);\n        for (int i=1;i<=k;i++) for (int j=1;j<=n;j++)\n            if (yl[i]<=p[j].y && p[j].y<=yr[i]) Add(j+k+n,i+k+2*n,1,0);\n        res=max(res,solve(s,t));\n    }\n    cout<<res<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define re register\nstruct eg\n{\n\tint to,nx,v;\n\tlong long c;\n}e[200100];\nint cnt,q[200100],la[200100],cur[200100],s,t,N;\nlong long ans;\nint num,nm;\nbool bo[200100];\nlong long d[200100];\nunsigned short hd,ta;\ninline void addE(re int a,re int b,re int c,re long long d)\n{\n\te[++cnt]=(eg){b,la[a],c,d};la[a]=cnt;\n\te[++cnt]=(eg){a,la[b],0,-d};la[b]=cnt;\n}\ninline void addE1(re int a,re int b,re int mi,re int mx)\n{\n\tif(mx<mi){nm=1<<30;return;}\n\tmi=std::max(mi,0);nm+=mi;addE(s,b,mi,0);addE(a,t,mi,0);addE(a,b,mx-mi,0);\n}\nbool bfs()\n{\n\tq[0]=s;ta=1;\n\tfor(re int i=1;i<=N;i++)d[i]=-1ll<<60,cur[i]=la[i],bo[i]=0;\n\td[s]=0;bo[s]=1;\n\tfor(hd=0;hd!=ta;hd++)\n\t{\n\t\tre int x=q[hd];//printf(\"*d*%d %lld\\n\",x,d[x]);\n\t\tfor(re int j=la[x];j;j=e[j].nx)if(e[j].v&&d[e[j].to]<d[x]+e[j].c)\n\t\t{\n\t\t\td[e[j].to]=d[x]+e[j].c;\n\t\t\tif(!bo[e[j].to])q[ta++]=e[j].to;\n\t\t}\n\t\tbo[x]=0;\n\t}\n\treturn (d[t]>-1ll<<60);\n}int dfs(re int a,re int fl)\n{\n\tif(a==t)return fl;\n\tbo[a]=1;\n\tre int fi=fl;\n\tfor(re int&i=cur[a];i;i=e[i].nx)if(e[i].v&&!bo[e[i].to]&&d[e[i].to]==d[a]+e[i].c)\n\t{\n\t\tre int t=dfs(e[i].to,std::min(e[i].v,fi));\n\t\tfi-=t;e[i].v-=t;e[i^1].v+=t;\n\t\tif(!fi)return fl;\n\t}\n\treturn fl-fi;\n}\nvoid dinic()\n{\n\twhile(bfs())\n\t{\n\t\tre int x=dfs(s,1<<30);\n\t\tans+=x*d[t];num+=x;\n\t}\n}\nint x[110],y[110],l1[410],l2[410],r1[410],r2[410];\nlong long c[110];\nchar ss[110];\nint main()\n{\n\tre int n,m,a,b;\n\tscanf(\"%d\",&n);\n\tre long long as=0;\n\tfor(re int i=1;i<=n;i++)scanf(\"%d%d%lld\",&x[i],&y[i],&c[i]);\n\tfor(re int i=1;i<=100;i++)l1[i]=l2[i]=r1[i]=r2[i]=n;\n\tscanf(\"%d\",&m);\n\tfor(re int i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%s%d%d\",ss,&a,&b);\n\t\tswitch(ss[0])\n\t\t{\n\t\t\tcase 'L':l1[a]=std::min(l1[a],b);break;\n\t\t\tcase 'R':l2[a]=std::min(l2[a],b);break;\n\t\t\tcase 'D':r1[a]=std::min(r1[a],b);break;\n\t\t\tcase 'U':r2[a]=std::min(r2[a],b);break;\n\t\t}\n\t}\n\tfor(re int i=2;i<=100;i++)l2[a]=std::min(l2[a],l2[a-1]),r2[a]=std::min(r2[a],r2[a-1]);\n\tfor(re int i=99;i;i--)l1[a]=std::min(l1[a],l1[a+1]),r1[a]=std::min(r1[a],r1[a+1]);\n\ts=299;t=300;N=300;\n\tfor(re int i=1;i<=n;i++)\n\t{\n\t\tcnt=1;nm=0;ans=0;num=0;\n\t\tfor(re int j=1;j<=N;j++)la[j]=0;\n\t\tfor(re int j=1;j<=n;j++)addE(x[j],101+y[j],1,c[j]);\n\t\tfor(re int j=1;j<=100;j++)\n\t\t{\n\t\t\taddE1(j,j+1,i-l1[j],l2[j+1]);\n\t\t\taddE1(j+102,j+101,i-r1[j],r2[j+1]);\n\t\t}\n\t\taddE(210,1,1<<30,0);addE(102,211,1<<30,0);\n\t\taddE(s,210,i,0);addE(211,t,i,0);nm+=i;\n\t\tif(nm!=(1<<30))dinic();\n\t\tif(num!=nm)break;\n\t\tas=std::max(as,ans);\n\t}\n\tprintf(\"%lld\\n\",as);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int V=170,E=500,N=85;\nstruct graph{\n\tstruct edge{int to,next;ll w;int f;}e[E<<1];\n\tint h[V],xb,n;\n\tinline void addedge(int x,int y,ll w,int f){\n\t\te[++xb]=(edge){y,h[x],w,f};h[x]=xb;\n\t\te[++xb]=(edge){x,h[y],-w,0};h[y]=xb;\n\t}\n\tinline pair<int,ll>mcmf(int S,int T){\n\t\tstatic int q[V],mi[V],lv[V],le[V];static bool inq[V];static ll d[V];\n\t\tint t,w,ans1=0,u,i;ll ans2=0;\n\t\tfor(;;){\n\t\t\tmemset(inq+1,0,n);inq[S]=1;\n\t\t\tfor(i=1;i<=n;++i)d[i]=-(1ll<<60);d[S]=0;\n\t\t\tt=0;w=1;q[1]=S;mi[S]=1<<30;\n\t\t\tfor(;t!=w;){\n\t\t\t\tinq[u=q[t=t==n?1:t+1]]=0;\n\t\t\t\tfor(int i=h[u];i;i=e[i].next)if(e[i].f && d[e[i].to]<d[u]+e[i].w){\n\t\t\t\t\td[e[i].to]=d[u]+e[i].w;\n\t\t\t\t\tmi[e[i].to]=min(mi[u],e[i].f);\n\t\t\t\t\tlv[e[i].to]=u;le[e[i].to]=i;\n\t\t\t\t\tif(!inq[e[i].to])inq[q[w=w==n?1:w+1]=e[i].to]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(d[T]==-(1ll<<60))return make_pair(ans1,ans2);\n\t\t\tans1+=mi[T];\n\t\t\tfor(u=T;u!=S;u=lv[u]){\n\t\t\t\tans2+=mi[T]*e[le[u]].w;\n\t\t\t\te[le[u]].f-=mi[T];\n\t\t\t\te[le[u]^1].f+=mi[T];\n\t\t\t}\n\t\t}\n\t}\n};\nstruct G2{\nstruct edge{int fr,to,lo,hi;ll w;}e[E];\nint n,xb,id[V],in[V];\ngraph g;\ninline void add(int u,int v,int l,int r,ll w){e[++xb]=(edge){u,v,l,r,w};}\ninline ll mcmf(){\n\tint i;\n\tmemset(in+1,0,n<<2);for(i=1;i<=xb;++i)in[e[i].to]+=e[i].lo,in[e[i].fr]-=e[i].lo;\n\tg.xb=1;g.n=n+2;memset(g.h+1,0,g.n<<2);memset(id+1,0,n<<2);\n\tfor(i=1;i<=n;++i){\n\t\tif(in[i]<0)g.addedge(i,n+2,0,-in[i]),id[i]=g.xb-1;\n\t\tif(in[i]>0)g.addedge(n+1,i,0,in[i]),id[i]=g.xb-1;\n\t}\n\tfor(i=1;i<=xb;++i){\n\t\tif(e[i].hi>e[i].lo)g.addedge(e[i].fr,e[i].to,e[i].w,e[i].hi-e[i].lo);\n\t\tif(e[i].hi<e[i].lo)return 0;\n\t}\n\tll ret=g.mcmf(n+1,n+2).second;\n\tfor(i=1;i<=n;++i)if(g.e[id[i]].f)\n\t\treturn 0;\n//cerr<<ret<<' '<<endl;\n\treturn ret;\n}\n}g;\nint n,x[N],y[N],i,j,a,b,xx[N],yy[N],xxb,yxb,m,mn,v1[N],v2[N],v3[N],v4[N];\nll v[N],ans;\nchar op[9];\nint main(){\n//\tfreopen(\"1\",\"r\",stdin);\n\tscanf(\"%d\",&n);mn=n;\n\tfor(i=1;i<=n;++i)scanf(\"%d%d%lld\",x+i,y+i,v+i),xx[++xxb]=x[i],yy[++yxb]=y[i];\n\tsort(xx+1,xx+xxb+1);xxb=unique(xx+1,xx+xxb+1)-xx-1;\n\tsort(yy+1,yy+yxb+1);yxb=unique(yy+1,yy+yxb+1)-yy-1;\n\tfor(i=1;i<=n;++i)x[i]=lower_bound(xx+1,xx+xxb+1,x[i])-xx,y[i]=lower_bound(yy+1,yy+yxb+1,y[i])-yy;\n\tfor(i=1;i<=xxb;++i)v1[i]=v2[i]=n;for(i=1;i<=yxb;++i)v3[i]=v4[i]=n;\n\tscanf(\"%d\",&m);\n\tfor(i=1;i<=m;++i){\n\t\tscanf(\"%s%d%d\",op,&a,&b);\n\t\tif(*op=='L'){\n\t\t\ta=upper_bound(xx+1,xx+xxb+1,a)-xx-1;\n\t\t\tif(1<=a && a<xxb)v1[a]=min(v1[a],b);\n\t\t\tif(a==xxb)\nmn=min(b,mn);\n\t\t}\n\t\tif(*op=='R'){\n\t\t\ta=lower_bound(xx+1,xx+xxb+1,a)-xx;\n\t\t\tif(1<a && a<=xxb)v2[a]=min(v2[a],b);\n\t\t\tif(a==1)\nmn=min(b,mn);\n\t\t}\n\t\tif(*op=='D'){\n\t\t\ta=upper_bound(yy+1,yy+yxb+1,a)-yy-1;\n\t\t\tif(1<=a && a<yxb)v3[a]=min(v3[a],b);\n\t\t\tif(a==yxb)\nmn=min(b,mn);\n\t\t}\n\t\tif(*op=='U'){\n\t\t\ta=lower_bound(yy+1,yy+yxb+1,a)-yy;\n\t\t\tif(1<a && a<=yxb)v4[a]=min(v4[a],b);\n\t\t\tif(a==1)\nmn=min(b,mn);\n\t\t}\n\t}\n\tg.n=xxb+yxb;\n\tfor(i=1;i<=mn;++i){\n\t\tg.xb=0;\n\t\tfor(j=1;j<xxb;++j)g.add(j,j+1,max(0,i-v1[j]),v2[j+1],0);\n\t\tfor(j=1;j<yxb;++j)g.add(xxb+j,xxb+j+1,max(0,i-v4[j+1]),v3[j],0);\n\t\tfor(j=1;j<=n;++j)g.add(x[j],y[j]+xxb,0,1,v[j]);\n\t\tg.add(g.n,1,i,i,0);\n//cerr<<i<<endl;\n\t\tans=max(ans,g.mcmf());\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef pair<ll,int> pli;\n\ntemplate<class T> inline void read(T &x){\n\tint f=0;x=0;char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar())f|=(ch=='-');\n\tfor(;isdigit(ch);ch=getchar())x=x*10+ch-'0';\n\tif(f)x=-x;\n}\n\nconst int N=1005,iinf=1e9;\nconst ll inf=1e18+9,mx=1e15+26;\nnamespace G{\n\tstruct edge{int v,f,c,id;ll w;};vector<edge> e[N];\n\tint r[N],ins[N],n,s,t; ll d[N],f[N];\n\tvoid add(int u,int v,int c,ll w){\n\t\te[u].pb((edge){v,0,c,(int)e[v].size(),w});\n\t\te[v].pb((edge){u,0,0,(int)e[u].size()-1,-w});\n\t}\n\tpriority_queue<pli,vector<pli>,greater<pli> >Q;\n\tint dij(){\n\t\trep(i,1,n){\n\t\t\tf[i]=min(f[i]+d[i],inf);\n\t\t\td[i]=(i==s?0:inf);\n\t\t}\n\t\tfor(Q.push(mp(0,s));!Q.empty();){\n\t\t\tpii t=Q.top(); Q.pop();\n\t\t\tif(t.fi>d[t.se]) continue;\n\t\t\tfor(int u=t.se,k=0;k<(int)e[u].size();k++){\n\t\t\t\tedge &v=e[u][k];\n\t\t\t\tif(v.f<v.c&&f[u]+d[u]+v.w<f[v.v]+d[v.v]){\n\t\t\t\t\td[v.v]=f[u]+d[u]+v.w-f[v.v];\n\t\t\t\t\tQ.push(mp(d[v.v],v.v));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn d[t]<inf;\n\t}\n\tint dfs(int u,int a){\n\t\tif(u==t) return a;\n\t\tint res=0; ins[u]=1;\n\t\tfor(int &k=r[u];k<(int)e[u].size();k++){\n\t\t\tedge &v=e[u][k];\n\t\t\tif(v.f<v.c&&f[u]+d[u]+v.w==f[v.v]+d[v.v]&&!ins[v.v]){\n\t\t\t\tint ret=dfs(v.v,min(a,v.c-v.f));\n\t\t\t\tv.f+=ret,e[v.v][v.id].f-=ret,res+=ret;\n\t\t\t\tif(!(a-=ret)) break;\n\t\t\t}\n\t\t}\n\t\treturn ins[u]=0,res;\n\t}\n\tvoid flow(int &flow,ll &cost){\n\t\tfill(d+1,d+n+1,0),fill(f+1,f+n+1,0);\n\t\twhile(dij()){\n\t\t\tfill(r+1,r+n+1,0);\n\t\t\tint ret=dfs(s,iinf);\n\t\t\tflow+=ret,cost+=(d[t]+f[t])*ret;\n\t\t}\n\t}\n}\n\nconst int lim=100;\nint xl[N],xr[N],yl[N],yr[N],d[N];\nint L[N],R[N],U[N],D[N];\nint x[N],y[N],X[N],Y[N];\nll v[N],ans;\nint n,m,a,b;\n\nvoid add(int u,int v,int l,int r){\n\tG::add(u,v,r-l,0),d[u]+=l,d[v]-=l;\n}\n\nvoid solve(int c){\n\tint s=1,t=lim+2,S=lim+lim+3,T=S+1;\n\trep(i,1,lim){\n\t\txl[i]=max(0,c-L[i-1]),xr[i]=R[i];\n\t\tyl[i]=max(0,c-D[i-1]),yr[i]=U[i];\n\t\tif(xl[i]>xr[i]||yl[i]>yr[i]) return;\n\t}\n\tfill(d+1,d+T+1,0);\n\tG::n=T,G::s=S,G::t=T;\n\trep(i,1,T) G::e[i].clear();\n\trep(i,1,lim){\n\t\tadd(s+i-1,s+i,xl[i],xr[i]);\n\t\tadd(t+i,t+i-1,yl[i],yr[i]);\n\t}\n\trep(i,1,n){\n\t\tG::add(s+x[i],t+y[i],1,mx-v[i]);\n\t}\n\tadd(t,s,c,c);\n\tint aim=0,flow=0; ll cost=0;\n\trep(i,1,S-1){\n\t\tif(d[i]>0) G::add(i,T,d[i],0),aim+=d[i];\n\t\tif(d[i]<0) G::add(S,i,-d[i],0);\n\t}\n\tG::flow(flow,cost);\n\tif(aim==flow) ans=max(ans,mx*c-cost);\n}\n\nint main(){\n\tread(n);\n\trep(i,1,n){\n\t\tread(x[i]),read(y[i]),read(v[i]);\n\t\tX[x[i]]++,Y[y[i]]++;\n\t}\n\trep(i,1,lim){\n\t\tX[i]+=X[i-1],Y[i]+=Y[i-1];\n\t\tL[i]=X[i],R[i]=n-X[i-1];\n\t\tD[i]=Y[i],U[i]=n-Y[i-1];\n\t}\n\tread(m);\n\trep(i,1,m){\n\t\tstatic char op[5];\n\t\tscanf(\"%s\",op);\n\t\tread(a),read(b);\n\t\tif(op[0]=='L') L[a]=min(L[a],b);\n\t\tif(op[0]=='R') R[a]=min(R[a],b);\n\t\tif(op[0]=='U') U[a]=min(U[a],b);\n\t\tif(op[0]=='D') D[a]=min(D[a],b);\n\t}\n\tper(i,lim-1,1){\n\t\tL[i]=min(L[i],L[i+1]);\n\t\tD[i]=min(D[i],D[i+1]);\n\t}\n\trep(i,2,lim){\n\t\tR[i]=min(R[i],R[i-1]);\n\t\tU[i]=min(U[i],U[i-1]);\n\t}\n\tper(i,n,1) if(i*mx>ans) solve(i);\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef HOME\n#define db(x) cerr << #x << \" = \" << x << endl\n#define db3(x, y, z) cerr << \"(\" << #x << \", \" << #y << \", \" << #z << \") = (\" << x << \", \" << y << \", \" << z << \")\" << endl\n#define db2(x, y) cerr << \"(\" << #x << \", \" << #y << \") = (\" << x << \", \" << y << \")\" << endl\n#define dbv(a) cerr << #a << \" = \"; for (auto xxx: a) cerr << xxx  << \" \"; cerr << endl\n#else\n#define db(x) ;\n#define db3(x, y, z) ;\n#define db2(x, y) ;\n#define dbv(a) ;\n#endif\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double dbl;\n\n\nconst int INF = 1.01e9;\nconst int MOD = (int)1e9 + 7;\n\nstruct Item {\n    int x, y;\n    ll val;\n};\n\nstruct Cond {\n    char type;\n    int a, b;\n\n    bool cover(Item it) {\n        if (type == 'L') {\n            return it.x <= a;\n        }\n        if (type == 'R') {\n            return it.x >= a;\n        }\n        if (type == 'D') {\n            return it.y <= a;\n        }\n        if (type == 'U') {\n            return it.y >= a;\n        }\n        assert(0);\n    }\n};\n\nll slow(vector<Item> a, vector<Cond> b) {\n    int n = a.size(), m = b.size();\n    ll ans = 0;\n    for (int mask = 0; mask < (1 << n); mask++) {\n        vector<int> cnt(m);\n        ll sum = 0;\n        for (int i = 0; i < n; i++) {\n            if (!(mask & (1 << i))) continue;\n            sum += a[i].val;\n            for (int j = 0; j < m; j++) {\n                if (b[j].cover(a[i])) {\n                    cnt[j]++;\n                }\n            }\n        }\n        bool bad = 0;\n        for (int i = 0; i < m; i++) {\n            if (cnt[i] > b[i].b) {\n                bad = 1;\n            }\n        }\n        if (bad) continue;\n        ans = max(ans, sum);\n    }\n    return ans;\n}\n\n\nbool eq(dbl a, dbl b) {\n    return fabs(a - b) < 1e-9;\n}\n\nbool ls(dbl a, dbl b) {\n    return !eq(a, b) && a < b;\n}\n\nvector<dbl> supersimplex(vector<vector<dbl> > a) {\n    int n = a.size() - 1;\n    int m = a[0].size() - 1;\n    vector<int> left(n + 1), up(m + 1);\n    iota(up.begin(), up.end(), 0);\n    iota(left.begin(), left.end(), m);\n    while (1) {\n        auto pivot = [&](int x, int y) {\n            swap(left[x], up[y]);\n            dbl k = a[x][y];\n            a[x][y] = 1;\n            vector<int> vct;\n            for (int j = 0; j <= m; j++) {\n                a[x][j] /= k;\n                if (!eq(a[x][j], 0)) vct.push_back(j);\n            }\n            for (int i = 0; i <= n; i++) {\n                if (eq(a[i][y], 0) || i == x) continue;\n                k = a[i][y];\n                a[i][y] = 0;\n                for (int j : vct) a[i][j] -= k * a[x][j];\n            }\n        };\n        while (1) {\n            int x = -1;\n            for (int i = 1; i <= n; i++) if (ls(a[i][0], 0) && (x == -1 || a[i][0] < a[x][0])) x = i;\n            if (x == -1) break;\n            int y = -1;\n            for (int j = 1; j <= m; j++) if (ls(a[x][j], 0) && (y == -1 || a[x][j] < a[x][y])) y = j;\n            if (y == -1) return vector<dbl>(m, 0);\n            pivot(x, y);\n        }\n        while (1) {\n            int y = -1;\n            for (int j = 1; j <= m; j++) if (ls(0, a[0][j]) && (y == -1 || a[0][j] > a[0][y])) y = j;\n            if (y == -1) break;\n            int x = -1;\n            for (int i = 1; i <= n; i++)\n                if (ls(0, a[i][y]) && (x == -1 || a[i][0] / a[i][y] < a[x][0] / a[x][y]))\n                    x = i;\n            if (x == -1) assert(0); // unbounded\n            pivot(x, y);\n        }\n\n        vector<int> v;\n        vector<dbl> ans(m + 1);\n        for (int i = 1; i <= n; i++) if (left[i] <= m) ans[left[i]] = a[i][0];\n        ans[0] = -a[0][0];\n        for (int i = 1; i <= m; i++) {\n            if (!eq(ans[i], floor(ans[i])) && !eq(ans[i], floor(ans[i]) + 1)) {\n                v.push_back(i);\n            }\n        }\n        if (v.empty()) {\n            return ans;\n        }\n        for (int i = 0; i <= n; i++) {\n            for (int j = 0; j < (int)v.size(); j++) {\n                a[i].push_back(0);\n            }\n        }\n        for (int i = 0; i < (int)v.size(); i++) {\n            vector<dbl> cur(a[0].size());\n            cur[m + 1 + i] = 1;\n            for (int j = 0; j <= m; j++) {\n                cur[j] = floor(a[v[i]][j]) - a[v[i]][j];\n            }\n            a.push_back(cur);\n        }\n        m += v.size();\n        n += v.size();\n        up.resize(up.size() + v.size());\n        left.resize(left.size() + v.size());\n    }\n}\n// j=1..m: x[j]>=0\n// i=1..n: sum(j=1..m) A[i][j]*x[j] <= A[i][0]\n// max sum(j=1..m) A[0][j]*x[j]\n// res[0] is answer\n// res[1..m] is certificate\n\nll fast(vector<Item> a, vector<Cond> b) {\n    int n = a.size(), m = b.size();\n    vector<vector<dbl>> c(m + 1, vector<dbl>(n + 1));\n    for (int i = 0; i < n; i++) {\n        c[0][1 + i] = a[i].val;\n    }\n    for (int i = 0; i < m; i++) {\n        c[1 + i][0] = b[i].b;\n        for (int j = 0; j < n; j++) {\n            if (b[i].cover(a[j])) {\n                c[1 + i][1 + j] = 1;\n            }\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        vector<dbl> cur(n + 1);\n        cur[0] = 1;\n        cur[1 + i] = 1;\n        c.push_back(cur);\n    }\n    return (ll)round(supersimplex(cc)[0]);\n}\n\nvoid stress() {\n    for (int it =0;; it++) {\n        mt19937_64 rnd(it);\n        db(it);\n\n\n        int n = rnd() % 10 + 1;\n        vector<Item> a(n);\n        for (int i =0 ; i < n; i++) {\n            a[i].x = rnd() % 100;\n            a[i].y = rnd() % 100;\n            a[i].val = rnd() % (ll)1e15;\n        }\n        int m = rnd() % 10 + 1;\n        vector<Cond> b(m);\n        for (int i = 0; i < m; i++) {\n            b[i].a = rnd() % 100;\n            b[i].b = rnd() % (n + 1);\n            b[i].type = \"ULDR\"[rnd() % 4];\n        }\n\n        auto ans1 = fast(a, b);\n        auto ans2 = slow(a, b);\n        if (ans1 != ans2) {\n            cout << ans1 << \" instead of \" << ans2 << endl;\n            exit(0);\n        }\n    }\n}\n\nint main() {\n#ifdef HOME\n    assert(freopen(\"in\", \"r\", stdin));\n    stress();\n#endif\n\n    int n;\n    while (scanf(\"%d\", &n) == 1) {\n        vector<Item> a(n);\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d%d%lld\", &a[i].x, &a[i].y, &a[i].val);\n        }\n        int m;\n        scanf(\"%d\", &m);\n        vector<Cond> b(m);\n        for (int i = 0; i < m; i++) {\n            scanf(\" %c%d%d\", &b[i].type, &b[i].a, &b[i].b);\n        }\n\n//        printf(\"%lld\\n\", slow(a, b));\n        printf(\"%lld\\n\", fast(a, b));\n    }\n\n#ifdef HOME\n    cerr << \"time: \" << clock() * 1.0 / CLOCKS_PER_SEC << endl;\n#endif\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nstruct edge {\n    int v, nxt, f;\n    ll c;\n} e[2 * 80 * 80 * 8 + 10];\nint head[410], tot, cur[410];\ninline void init() {\n    tot = 1;\n    memset(head, 0, sizeof head);\n}\ninline void addedge(int u, int v, int f, ll c) {\n    e[++tot] = edge{v, head[u], f, c};\n    head[u] = tot;\n    e[++tot] = edge{u, head[v], 0, -c};\n    head[v] = tot;\n}\nint n, m, x[100], y[100];\nll v[100];\nstruct node {\n    char type;\n    int key, val;\n} a[325];\nll dis[410];\nint inq[410];\nint s, t;\ninline bool spfa() {\n    memset(dis, ~0x3f, sizeof dis);\n    queue <int> q;\n    q.push(s);\n    dis[s] = 0;\n    inq[s] = 1;\n    while (!q.empty()) {\n        int now = q.front();\n        q.pop();\n        for (int i = head[now]; i; i = e[i].nxt) {\n            if (e[i].f && dis[now] + e[i].c > dis[e[i].v]) {\n                dis[e[i].v] = dis[now] + e[i].c;\n                if (!inq[e[i].v]) inq[e[i].v] = 1, q.push(e[i].v);\n            }\n        }\n        inq[now] = 0;\n    }\n    return memcpy(cur, head, sizeof cur), dis[t] >= -1e18;\n}\nint ansf, insta[410];\nll ansc;\ninline int dfs(int now, int limit) {\n    if (now == t) return limit;\n    insta[now] = 1;\n    int ans = 0;\n    for (int &i = cur[now]; i; i = e[i].nxt) {\n        if (e[i].f == 0 || dis[now] + e[i].c != dis[e[i].v] || insta[e[i].v]) continue;\n        int tmp = dfs(e[i].v, min(limit, e[i].f));\n        ans += tmp, limit -= tmp;\n        ansc += tmp * e[i].c;\n        e[i].f -= tmp;\n        e[i ^ 1].f += tmp;\n        if (limit == 0) return insta[now] = 0, ans;\n    }\n    return insta[now] = 0, ans;\n}\ninline void work() {\n    ansf = ansc = 0;\n    while (spfa()) ansf += dfs(s, 1e9);\n}\nint l[100], r[100];\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i++) scanf(\"%d%d%lld\", x + i, y + i, v + i);\n    scanf(\"%d\", &m);\n    for (int i = 1; i <= m; i++) scanf(\"%s%d%d\", &a[i].type, &a[i].key, &a[i].val);\n    ll ans = 0;\n    for (int k = 1; k <= n; k++) {\n        init();\n        for (int i = 1; i <= n; i++) l[i] = 0, r[i] = 100;\n        for (int i = 1; i <= m; i++) {\n            switch (a[i].type) {\n                case 'L': {\n                    for (int j = a[i].val + 1; j <= k; j++) l[j] = max(l[j], a[i].key + 1);\n                    break;\n                }\n                case 'R': {\n                    for (int j = 1; j <= k - a[i].val; j++) r[j] = min(r[j], a[i].key);\n                    break;\n                }\n            }\n        }\n        for (int i = 1; i <= k; i++)\n            for (int j = 1; j <= n; j++)\n                if (x[j] >= l[i] && x[j] <= r[i]) addedge(i, j + k, 1, 0);\n        for (int i = 1; i <= n; i++) l[i] = 0, r[i] = 100;\n        for (int i = 1; i <= m; i++) {\n            switch (a[i].type) {\n                case 'D': {\n                    for (int j = a[i].val + 1; j <= k; j++) l[j] = max(l[j], a[i].key + 1);\n                    break;\n                }\n                case 'U': {\n                    for (int j = 1; j <= k - a[i].val; j++) r[j] = min(r[j], a[i].key - 1);\n                    break;\n                }\n            }\n        }\n        for (int i = 1; i <= k; i++)\n            for (int j = 1; j <= n; j++)\n                if (y[j] >= l[i] && y[j] <= r[i]) addedge(j + k + n, i + k + n + n, 1, 0);\n        s = 0, t = k + k + n + n + 1;\n        for (int i = 1; i <= k; i++) addedge(s, i, 1, 0), addedge(i + n + n + k, t, 1, 0);\n        for(int i = 1; i <= n; i++) addedge(i + k, i + k + n, 1, v[i]);\n        work();\n        if (ansf != k) continue;\n        ans = max(ans, ansc);\n    }\n    return cout << ans << endl, 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define cmin(a,b) (a>(b)?a=(b),1:0)\n#define cmax(a,b) (a<(b)?a=(b),1:0)\n#define dmin(a,b) ((a)<(b)?(a):(b))\n#define dmax(a,b) ((a)>(b)?(a):(b))\nnamespace io\n{\n\tint F()\n\t{\n\t\t int F=1,n=0;\n\t\t char ch;\n\t\t while((ch=getchar())!='-'&&(ch<'0'||ch>'9'));\n\t\t ch=='-'?F=0:n=ch-'0';\n\t\t while((ch=getchar())>='0'&&ch<='9')n=n*10+ch-'0';\n\t\t return F?n:-n;\n\t}\n\tlong long G()\n\t{\n\t\t long long F=1,n=0;\n\t\t char ch;\n\t\t while((ch=getchar())!='-'&&(ch<'0'||ch>'9'));\n\t\t ch=='-'?F=0:n=ch-'0';\n\t\t while((ch=getchar())>='0'&&ch<='9')n=n*10+ch-'0';\n\t\t return F?n:-n;\n\t}\n}\nstruct edge\n{\n\tint to;\n\tlong long val;\n\tint res;\n\tint next;\n}e[3888];\nint pe=222;\nvoid insert(int a,int to,long long val,int cap)\n{\n\te[pe]=(edge){to,val,cap,e[a].next};\n\te[a].next=pe++;\n}\nvoid addedge(int a,int to,long long val,int cap)\n{\n\tinsert(a,to,val,cap);\n\tinsert(to,a,-val,0);\n}\nint S,T;\nint U[222],D[222],L[222],R[222];\nint x[222],y[222];\nlong long v[222];\nint in[222];\nint q[22222222],hq,tq;\nint vis[2222];\nlong long dis[2222];\nint from[2222],frome[2222];\nint flow;\nbool spfa()\n{\n\tfor(int i=1;i<=T;++i)dis[i]=0x6e6e6e6e6e6e6e6ell;\n\tfor(q[hq=1]=S,tq=2,vis[S]=1,dis[S]=0;hq!=tq;vis[q[hq++]]=0)\n\t\tfor(register int p=e[q[hq]].next;p;p=e[p].next)\n\t\t\tif(e[p].res&&cmin(dis[e[p].to],dis[q[hq]]+e[p].val))\n\t\t\t{\n\t\t\t\tfrom[e[p].to]=q[hq],frome[e[p].to]=p;\n\t\t\t\tif(!vis[e[p].to])vis[e[p].to]=1,q[tq++]=e[p].to;\n\t\t\t}\n\treturn dis[T]!=0x6e6e6e6e6e6e6e6ell;\n}\nlong long ek()\n{\n\tflow=0;\n\tlong long ans=0;\n\twhile(spfa())\n\t{\n\t\tint now=T;\n\t\tint min=0x3f3f3f3f;\n\t\twhile(1)\n\t\t{\n\t\t\tcmin(min,e[frome[now]].res);\n\t\t\tnow=from[now];\n\t\t\tif(now==S)break;\n\t\t}\n\t\tnow=T;\n\t\twhile(1)\n\t\t{\n\t\t\te[frome[now]].res-=min;\n\t\t\te[frome[now]^1].res+=min;\n\t\t\tnow=from[now];\n\t\t\tif(now==S)break;\n\t\t}\n\t\tans+=dis[T]*min;\n\t\tflow+=min;\n\t}\n\treturn ans;\n}\nint main()\n{\n\tint n=io::F();\n\tfor(register int i=1;i<=n;++i)\n\t\tx[i]=io::F(),y[i]=io::F(),v[i]=io::G();\n\tint m=io::F();\n\tfor(register int i=1;i<=100;++i)U[i]=L[i]=D[i]=R[i]=-1;\n\tfor(register int i=1;i<=m;++i)\n\t{\n\t\tchar s[4];\n\t\tscanf(\"%s\",s);\n\t\tint a=io::F(),b=io::F();\n\t\tif(*s=='U')U[a]=b;\n\t\tif(*s=='D')D[a]=b;\n\t\tif(*s=='L')L[a]=b;\n\t\tif(*s=='R')R[a]=b;\n\t}\n\tfor(register int i=1;i<=100;++i)\n\t{\n\t\tif(U[i]==-1)U[i]=n;\n\t\tif(D[i]==-1)D[i]=n;\n\t\tif(L[i]==-1)L[i]=n;\n\t\tif(R[i]==-1)R[i]=n;\n\t}\n\tS=201,T=202;\n\tlong long max=0;\n\tint sum;\n\tlong long tmp;\n\tfor(register int s=1;s<=n;++s)\n\t{\n\t\tfor(register int j=1;j<=T;++j)e[j].next=0,in[j]=0;\n\t\tpe=222;\n\t\tif(s>R[1])goto skip;\n\t\tif(s>L[100])goto skip;\n\t\tif(s>U[1])goto skip;\n\t\tif(s>D[100])goto skip;\n\t\tfor(register int i=1;i<100;++i)\n\t\t{\n\t\t\tint lb,rb;\n\t\t\trb=R[i+1],lb=s-L[i];\n\t\t\tif(lb>rb)goto skip;\n\t\t\taddedge(i,i+1,0,rb-lb);\n\t\t\tin[i+1]+=lb;\n\t\t\tin[i]-=lb;\n\t\t\t\n\t\t\trb=D[i],lb=s-U[i+1];\n\t\t\tif(lb>rb)goto skip;\n\t\t\taddedge(i+100,i+101,0,rb-lb);\n\t\t\tin[i+101]+=lb;\n\t\t\tin[i+100]-=lb;\n\t\t}\n\t\t{\n\t\t\tin[1]+=s;\n\t\t\tin[200]-=s;\n\t\t}\n\t\tsum=0;\n\t\tfor(register int i=1;i<=200;++i)\n\t\t\tif(in[i]>0)addedge(S,i,0,in[i]),sum+=in[i];\n\t\t\t\telse if(in[i]<0)addedge(i,T,0,-in[i]);\n\t\tfor(register int i=1;i<=n;++i)\n\t\t\taddedge(x[i],y[i]+100,-v[i],1);\n\t\ttmp=-ek();\n\t\tif(flow!=sum)continue;\n\t\tcmax(max,tmp);\n\t\tskip:;\n\t}\n\tprintf(\"%lld\\n\",max);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>/*{{{*/\n#include<cctype>\n#include<cassert>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<ctime>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<set>\n#include<vector>\nusing namespace std;\ntypedef pair<int,int> pii;\n#define fi first\n#define se second\n#define pb push_back\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define ROF(i,a,b) for(int i=(a);i>=(b);--i)\nnamespace RA{\n    int r(int p){return 1ll*rand()*rand()%p;}\n    int r(int L,int R){return r(R-L+1)+L;}\n}/*}}}*/\n/******************heading******************/\ntypedef long long LL;\nconst LL LLINF=0x3f3f3f3f3f3f3f3f;\nconst int N=100,INF=0x3f3f3f3f;\n\nint s,t;\nstruct qxx{int nex,t,v;LL c;};\nqxx e[N*N*4];\nLL h[N],hh[N],le=1;\nvoid add_path(int f,int t,int v,LL c){e[++le]=(qxx){h[f],t,v,c},h[f]=le;}\nvoid add_flow(int f,int t,int v,LL c){\n    //printf(\"add_flow(%d,%d,%d,%lld)\\n\",f,t,v,c);\n    add_path(f,t,v,c),add_path(t,f,0,-c);}\n#define FORe(i,_u,_v,_w,_c)     for(LL i=h[_u],_v,_w,_c;_v=e[i].t,_w=e[i].v,_c=e[i].c,i;i=e[i].nex)\n#define FORflowe(i,_u,_v,_w,_c) for(LL &i=hh[_u],_v,_w,_c;_v=e[i].t,_w=e[i].v,_c=e[i].c,i;i=e[i].nex)\n\nint n,m;\nint x[N],y[N];\nLL val[N],ans=-LLINF;\nint xL[N],xR[N],yL[N],yR[N];\n\nvector<pii> L,R,U,D;\n\nqueue<int> q;\nbool vising[N];\nLL d[N];\nbool spfa(){\n    memset(d,0x3f,sizeof(d));\n    q.push(s),d[s]=0;\n    while(!q.empty()){\n        int u=q.front();q.pop();\n        vising[u]=0;\n        FORe(i,u,v,w,c){\n            if(!w||d[v]<=d[u]+c)continue;\n            d[v]=d[u]+c;\n            if(!vising[v])q.push(v),vising[v]=1;\n        }\n    }\n    return d[t]!=LLINF;\n}\nLL mincost;\nbool vis[N];\nint dfs(int u,int flow){\n    //printf(\"dfs(%d,%d)\\n\",u,flow);\n    vis[u]=1;\n    if(u==t)return flow;\n    int rest=flow;\n    FORflowe(i,u,v,w,c){\n        if(!rest)break;\n        if(vis[v]&&v!=t||!w||d[v]!=d[u]+c)continue;\n        int k=dfs(v,min(w,1ll*rest));\n        if(k)mincost+=k*c,e[i].v-=k,e[i^1].v+=k,rest-=k;\n        else d[v]=0;\n    }\n    return flow-rest;\n}\nLL go(){\n    int maxflow=0;\n    while(spfa()){\n        //puts(\"GG\");\n        memcpy(hh,h,sizeof(h));\n        for(int i;memset(vis,0,sizeof(vis)),(i=dfs(s,INF))&&vis[t];)maxflow+=i;\n    }\n    //printf(\"maxflow=%d,mincost=%lld\\n\",maxflow,mincost);\n    return mincost;\n}\nvoid init(){\n    memset(h,0,sizeof(h));\n    le=1,mincost=0;\n}\nvoid calc(int k){\n    //printf(\"calc(%d)\\n\",k);\n    for(pii x:L)xL[x.se+1]=x.fi+1; //x[b+1] >= a+1\n    for(pii x:R)xR[k-x.se]=x.fi-1; //x[k-b] <= a-1\n    for(pii x:D)yL[x.se+1]=x.fi+1;\n    for(pii x:U)yR[k-x.se]=x.fi-1;\n    xR[k+1]=INF;\n    FOR(i,1,k)if(!xL[i])xL[i]=xL[i-1];\n    ROF(i,k,1)if(!xR[i])xR[i]=xR[i+1];\n    yR[k+1]=INF;\n    FOR(i,1,k)if(!yL[i])yL[i]=yL[i-1];\n    ROF(i,k,1)if(!yR[i])yR[i]=yR[i+1];\n    //FOR(i,1,k)printf(\"[%d,%d]%c\",xL[i],xR[i],\" \\n\"[i==k]);\n    //FOR(i,1,k)printf(\"[%d,%d]%c\",yL[i],yR[i],\" \\n\"[i==k]);\n\n    // item: 1 - n, n+1 - 2n\n    // x : 2n+1 - 2n+k\n    // y : 2n+k+1 - 2n+2k\n    // s : 0\n    // t : 2n+2k+1\n    init();\n    s=0,t=2*n+2*k+1;\n    //printf(\"s=%d,t=%d\\n\",s,t);\n    FOR(i,1,k)add_flow(s,2*n+i,1,0);\n    FOR(i,1,k)FOR(j,1,n)if(xL[i]<=x[j]&&x[j]<=xR[i])add_flow(2*n+i,j,INF,0);\n    FOR(i,1,n)add_flow(i,i+n,1,-val[i]);\n    FOR(i,1,k)FOR(j,1,n)if(yL[i]<=y[j]&&y[j]<=yR[i])add_flow(j+n,2*n+k+i,INF,0);\n    FOR(i,1,k)add_flow(2*n+k+i,t,1,0);\n\n    LL res=go();\n    ans=max(ans,-res);\n}\n\nint main(){\n    scanf(\"%d\",&n);\n    FOR(i,1,n)scanf(\"%d%d%lld\",&x[i],&y[i],&val[i]);\n    scanf(\"%d\",&m);\n    FOR(i,1,m){\n        char t[10];\n        int a,b;\n        scanf(\"%s%d%d\",t,&a,&b);\n        if(t[0]=='L')L.pb({a,b});\n        else if(t[0]=='R')R.pb({a,b});\n        else if(t[0]=='U')U.pb({a,b});\n        else D.pb({a,b});\n    }\n    FOR(i,1,n)calc(i);\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\n  _|_|                              _|  _|    _|\n_|    _|  _|  _|_|  _|_|_|_|        _|  _|  _|\n_|    _|  _|_|          _|          _|  _|_|\n_|    _|  _|          _|      _|    _|  _|  _|\n  _|_|    _|        _|_|_|_|    _|_|    _|    _|\n\n*/\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<set>\n//#define ls (rt<<1)\n//#define rs (rt<<1|1)\n#define vi vector<int>\n#define pb push_back\n#define mk make_pair\n#define pii pair<ll,ll>\n#define rep(i,a,b) for(int i=(a),i##end=(b);i<=i##end;i++)\n#define fi first\n#define se second\n#define int long long\ntypedef long long ll;\nusing namespace std;\nconst int maxn=420;\nconst int inf=1e18+100;\nint xl[maxn],xr[maxn],yl[maxn],yr[maxn],s=415,t=416;\nint head[maxn*2],cnt=1;\nstruct gg{\n    int u,v,w;ll cost;int next;\n    void insert(int U,int V,int W,ll Cost,int Next){\n        u=U,v=V,w=W,cost=Cost,next=Next;\n    }\n}side[(maxn*maxn)*2];\nstruct Point{\n    int x,y;\n    ll cost=0;\n}point[maxn];\nstruct Lim{\n    int a,b;char c;\n}lim[maxn];\nvoid ins(int u,int v,int w,ll cost){\n    side[++cnt].insert(u,v,w,cost,head[u]);head[u]=cnt;\n    side[++cnt].insert(v,u,0,-cost,head[v]);head[v]=cnt;\n}\nint n,m;\nvoid init(int k){\n    rep(i,1,k)xl[i]=yl[i]=-inf,xr[i]=yr[i]=inf;\n    rep(i,1,m){\n        if(lim[i].c=='L')rep(j,lim[i].b+1,k)xl[j]=max(xl[j],lim[i].a+1);\n        else if(lim[i].c=='R')for(int j=k-lim[i].b;j>0;j--)xr[j]=min(xr[j],lim[i].a-1);\n        else if(lim[i].c=='D')rep(j,lim[i].b+1,k)yl[j]=max(yl[j],lim[i].a+1);\n        else if(lim[i].c=='U')for(int j=k-lim[i].b;j>0;j--)yr[j]=min(yr[j],lim[i].a-1);\n    }\n    memset(head,0,sizeof(head));cnt=1;\n    rep(i,1,k)ins(s,2*n+i,1,0);\n    rep(i,1,k)ins(2*n+k+i,t,1,0);\n    rep(i,1,n){\n        ins(i,n+i,1,point[i].cost);\n        rep(j,1,k){\n            if(xl[j]<=point[i].x&&point[i].x<=xr[j])ins(2*n+j,i,1,0);\n            if(yl[j]<=point[i].y&&point[i].y<=yr[j])ins(n+i,2*n+k+j,1,0);\n        }\n    }\n}\nint rk[maxn],q[maxn];\nll dis[maxn],lenth;\nbool vis[maxn];\nbool spfa(){\n    rep(i,1,maxn-1)dis[i]=-inf;\n    memset(vis,0,sizeof(vis));\n    int hd=1,tl=1;q[hd]=s;vis[s]=1;dis[s]=0;\n    while(hd<=tl){\n        int u=q[hd++];vis[u]=0;//cout<<u<<' '<<endl;\n        for(int i=head[u];i;i=side[i].next){\n            int v=side[i].v;if(!side[i].w)continue;\n            if(dis[u]+side[i].cost>dis[v]){\n                dis[v]=dis[u]+side[i].cost;\n                if(!vis[v])q[++tl]=v;\n                vis[v]=1;\n            }\n        }\n    }\n    if(dis[t]!=-inf)return 1;\n    return 0;\n}\nint dfs(int u,int flow){\n    if(u==t)return flow;\n    vis[u]=1;int tot=0;\n    for(int i=head[u];i;i=side[i].next){\n        int v=side[i].v;if(vis[v]||!side[i].w||dis[v]!=dis[u]+side[i].cost)continue;\n        int sent=dfs(v,min(flow,side[i].w));\n        lenth+=1ll*side[i].cost*sent,side[i].w-=sent,side[i^1].w+=sent,tot+=sent;flow-=sent;\n    }\n    // vis[u]=0;\n    return tot;\n}\npii dinic(){\n    int mxflow=0;lenth=0;\n    while(spfa()){\n        int x;\n        while((x=dfs(s,inf)))mxflow+=x;\n    }\n    return mk(mxflow,lenth);\n}\nchar tmp[3];\nsigned main(){\n    scanf(\"%lld\",&n);\n    rep(i,1,n)scanf(\"%lld%lld%lld\",&point[i].x,&point[i].y,&point[i].cost);\n    scanf(\"%lld\",&m);\n    rep(i,1,m){\n        scanf(\"%s%lld%lld\",tmp+1,&lim[i].a,&lim[i].b);lim[i].c=tmp[1];\n    }\n    ll out=0;\n    rep(k,1,n){\n        init(k);\n        pii ans=dinic();out=max(out,ans.se);//cout<<ans.se<<endl;\n    }\n    cout<<out;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <sstream>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <cstdlib>\n#include <cstdio>\n#include <iterator>\n#include <functional>\n#include <bitset>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\nclock_t __my_start_clock = clock();\n#else\n#define eprintf(...)\n#endif\n\n#define TIMESTAMP(x) eprintf(\"[\"#x\"] Time : %.3lf s.\\n\", (clock() - __my_start_clock)*1.0/CLOCKS_PER_SEC)\n#define TIMESTAMPf(x,...) eprintf(\"[\" x \"] Time : %.3lf s.\\n\", __VA_ARGS__, (clock() - __my_start_clock)*1.0/CLOCKS_PER_SEC)\n\n#define db(x) cerr << #x << \" = \" << x << endl\n#define db2(x, y) cerr << \"(\" << #x << \", \" << #y << \") = (\" << x << \", \" << y << \")\\n\";\n#define db3(x, y, z) cerr << \"(\" << #x << \", \" << #y << \", \" << #z << \") = (\" << x << \", \" << y << \", \" << z << \")\\n\"\n#define dbv(a) cerr << #a << \" = \"; for (auto xxxx: a) cerr << xxxx << \" \"; cerr << endl\n\n\nusing namespace std;\n\n#ifdef LOCAL\nstatic struct __timestamper {\n  string what;\n  __timestamper(const char* what) : what(what){};\n  __timestamper(const string& what) : what(what){};\n  ~__timestamper(){\n    TIMESTAMPf(\"%s\", what.data());\n\t}\n} __TIMESTAMPER(\"end\");\n#else \nstruct __timestamper {};\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\n\nclass MinCostMaxFlow {\npublic:\n  typedef long long flow_type;\n  typedef long long cost_type;\n  const flow_type FLOW_INF = 1LL << 60;\n  const cost_type COST_INF = 1LL << 60;\nprivate:\n  struct Edge {\n    int to, next;\n    flow_type f, c;\n    cost_type w;\n  };\n\n  int n;\n  vector<int> head;\n  vector<cost_type> phi;\n  vector<Edge> es;\n  cost_type cost;\n\n  cost_type get_cost(int id) {\n    cost_type res = es[id].w - phi[es[id].to] + phi[es[id ^ 1].to];\n    assert(es[id].c > 0 && res >= 0);\n    return res;\n  }\n\n  void pushFlow(int eid, flow_type val) {\n    es[eid].f += val, es[eid].c -= val;\n    es[eid ^ 1].f -= val, es[eid ^ 1].c += val;\n    cost += es[eid].w * val;\n  }\n\n\n  flow_type dijkstra(int s, int t, flow_type limit) {\n    vector<cost_type > d(n, COST_INF);\n    vector<int> pe(n, -1);\n    d[s] = 0;\n\n    priority_queue<pair<cost_type, int>> q;\n    q.push({-d[s], s});\n\n    while (!q.empty()) {\n      auto x = q.top();\n      q.pop();\n\n      int id = x.second;\n      if (x.first != -d[id]) continue;\n\n      for (int e = head[id]; e != -1; e = es[e].next) {\n        if (es[e].c == 0) continue;\n        int to = es[e].to;\n        if (d[to] > d[id] + get_cost(e)) {\n          d[to] = d[id] + get_cost(e);\n          q.push({-d[to], to});\n          pe[to] = e;\n        }\n      }\n    }\n\n    for (int i = 0; i < n; i++) {\n      phi[i] += d[i];\n    }\n\n    if (pe[t] == -1) return 0;\n\n    flow_type res = FLOW_INF;\n    if (limit > 0) res = min(res, limit);\n    int v = t;\n    while (v != s) {\n      res = min(res, es[pe[v]].c);\n      v = es[pe[v] ^ 1].to;\n    }\n    v = t;\n    while (v != s) {\n      pushFlow(pe[v], res);\n      v = es[pe[v] ^ 1].to;\n    }\n    return res;\n  };\n\npublic:\n  explicit MinCostMaxFlow(int n) : n(n), head(n, -1), phi(n, 0), cost(0) {}\n\n  int addEdge(int from, int to, flow_type c, cost_type w) {\n    int id = (int) es.size();\n    es.push_back({to, head[from], 0, c, w});\n    head[from] = id;\n    es.push_back({from, head[to], 0, 0, -w});\n    head[to] = id ^ 1;\n    return id;\n  }\n\n  pair<flow_type, cost_type> getFlow(int s, int t, flow_type k = -1) {\n    flow_type res = 0;\n\n    while (true) {\n      flow_type cur = dijkstra(s, t, k - res);\n      res += cur;\n      if (cur == 0 || res == k) break;\n    }\n\n    return {res, cost};\n  }\n};\n\nclass MinCostLRFlow {\n  MinCostMaxFlow flow;\n  MinCostMaxFlow::flow_type need;\npublic:\n\n  int n;\n  MinCostLRFlow(int n) : flow(n + 2), need(0), n(n) {}\n\n  MinCostMaxFlow::cost_type getFlow(int s, int t) {\n    flow.addEdge(t, s, 10000, 0);\n    auto res = flow.getFlow(n, n + 1);\n    if (res.first != need) {\n      return -1;\n    }\n    return res.second;\n  }\n\n  void addEdge(int from, int to, int l, int r, MinCostMaxFlow::cost_type cost) {\n    assert(0 <= from && from < n);\n    assert(0 <= to && to < n);\n    assert(0 <= l && l <= r);\n    eprintf(\"[%d, %d] from %d to %d, cost = %lld\\n\", from, to, l, r, cost);\n    if (l < r) {\n      flow.addEdge(from, to, r - l, cost);\n    }\n    if (l) {\n      flow.addEdge(n, to, l, cost);\n      flow.addEdge(from, n + 1, l, 0);\n      need += l;\n    }\n  }\n};\n\nstruct point {\n  int x, y;\n  ll w;\n};\n\nstruct restriction {\n  char ty;\n  int a, b;\n};\n\nint main() {\n#ifdef LOCAL\n  freopen(\"e.in\", \"r\", stdin);\n  freopen(\"e.out\", \"w\", stdout);\n#endif\n\n  int n;\n  while (scanf(\"%d\", &n) == 1) {\n    vector<point> ps(n);\n    for (int i = 0; i < n; i++) {\n      scanf(\"%d%d%lld\", &ps[i].x, &ps[i].y, &ps[i].w);\n    }\n    int m;\n    scanf(\"%d\", &m);\n    vector<restriction> rs(m);\n    for (int i = 0; i < m; i++) {\n      scanf(\" %c%d%d\", &rs[i].ty, &rs[i].a, &rs[i].b);\n    }\n\n    vector<int> xs, ys;\n    ll sum = 0;\n    for (const auto& p : ps) {\n      xs.push_back(p.x);\n      ys.push_back(p.y);\n      sum += p.w;\n    }\n\n    for (const auto& r : rs) {\n      if (r.ty == 'U' || r.ty == 'D') {\n        ys.push_back(r.a);\n      } else {\n        xs.push_back(r.a);\n      }\n    }\n\n    xs.push_back(0);\n    ys.push_back(0);\n    xs.push_back(101);\n    ys.push_back(101);\n\n    sort(xs.begin(), xs.end()), xs.erase(unique(xs.begin(), xs.end()), xs.end());\n    sort(ys.begin(), ys.end()), ys.erase(unique(ys.begin(), ys.end()), ys.end());\n\n    ll ans = 0;\n    for (int remove = 0; remove <= n; remove++) {\n      eprintf(\"remove = %d\\n\", remove);\n      MinCostLRFlow flow(2 + 2 * (int)xs.size() + 2 * (int)ys.size());\n      int x_start = 0;\n      int y_start = x_start + (int)xs.size();\n      int x_sum_start = y_start + (int)ys.size();\n      int y_sum_start = x_sum_start + (int)xs.size();\n      int s = y_sum_start + (int)ys.size();\n      int t = s + 1;\n      assert(t == flow.n - 1);\n      for (const auto &p : ps) {\n        int x = lower_bound(xs.begin(), xs.end(), p.x) - xs.begin();\n        int y = lower_bound(ys.begin(), ys.end(), p.y) - ys.begin();\n        flow.addEdge(x, y + y_start, 0, 1, p.w);\n      }\n\n      bool fail = false;\n\n      flow.addEdge(s, y_sum_start - 1, remove, remove, 0);\n      for (int i = 0; i < (int)xs.size(); i++) {\n        flow.addEdge(x_sum_start + i, x_start + i, 0, n, 0);\n        if (i != 0) {\n          int lf = 0;\n          int rg = n;\n\n          int cnt = 0;\n          for (const auto &p : ps) {\n            if (p.x <= xs[i - 1]) {\n              cnt++;\n            }\n          }\n\n          for (const auto& r : rs) {\n            if (r.ty == 'L' && r.a >= xs[i - 1]) {\n              lf = max(lf, cnt - r.b);\n            } else if (r.ty == 'R' && r.a <= xs[i]) {\n              rg = min(rg, r.b + cnt - (n - remove));\n            }\n          }\n\n          if (lf > rg) {\n            fail = true;\n          } else {\n            flow.addEdge(i + x_sum_start, i - 1 + x_sum_start, lf, rg, 0);\n          }\n        }\n      }\n\n      for (int i = 0; i < (int)ys.size(); i++) {\n        flow.addEdge(y_start + i, y_sum_start + i, 0, n, 0);\n        if (i != 0) {\n          int lf = 0;\n          int rg = n;\n          int cnt = 0;\n          for (const auto &p : ps) {\n            if (p.y <= ys[i - 1]) {\n              cnt++;\n            }\n          }\n\n          for (const auto& r : rs) {\n            if (r.ty == 'D' && r.a >= ys[i - 1]) {\n              lf = max(lf, cnt - r.b);\n            } else if (r.ty == 'U' && r.a <= ys[i]) {\n              rg = min(rg, r.b + cnt - (n - remove));\n            }\n          }\n          if (lf > rg) {\n            fail = true;\n          } else {\n            flow.addEdge(i + y_sum_start - 1, i + y_sum_start, lf, rg, 0);\n          }\n        }\n      }\n      flow.addEdge(y_sum_start + (int)ys.size() - 1, t, 0, n, 0);\n\n      if (!fail) {\n        ll res = flow.getFlow(s, t);\n        eprintf(\"res = %lld\\n\", res);\n        if (res != -1) {\n          ans = max(ans, sum - res);\n        }\n      }\n    }\n    printf(\"%lld\\n\", ans);\n\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// includes {{{\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<tuple>\n#include<cmath>\n#include<random>\n#include<cassert>\n#include<bitset>\n#include<cstdlib>\n// #include<deque>\n// #include<multiset>\n// #include<cstring>\n// #include<bits/stdc++.h>\n// }}}\nusing namespace std;\nusing ll = long long;\n\n// MinCostFlow(size, inf)\n// MinCostFlow(size, inf, int& s, int& t)\n// addEdge(from, to, capacity, cost, undirected = false)\n// === build(s, t, flow) ===\n// O(FE log V)\n// return mincost\n// return -1 if impossible\n/// --- MinCostFlow {{{ ///\n#include <cassert>\n#include <queue>\n#include <tuple>\n#include <vector>\n// with Dijkstra with Potential\nstruct MinCostFlow {\n  struct Edge {\n    int to;\n    ll cap, cost;\n    size_t rev;\n  };\n  int n;\n  vector< vector< Edge > > graph;\n  vector< ll > h; // potential\n  vector< ll > dist;\n  vector< int > prevv, preve;\n  ll inf;\n  MinCostFlow(int n, ll inf)\n    : n(n), graph(n), h(n), dist(n), prevv(n), preve(n), inf(inf) {}\n  MinCostFlow(int n, ll inf, int &s, int &t) : MinCostFlow(n + 2, inf) {\n    s = n, t = n + 1;\n  }\n  void addEdge(int a, int b, ll cap, ll cost, int undirected = 0) {\n    assert(cost >= 0);\n    assert(0 <= a && a < n);\n    assert(0 <= b && b < n);\n    graph[a].emplace_back((Edge){b, cap, cost, graph[b].size()});\n    graph[b].emplace_back((Edge){a, undirected ? cap : 0, -cost, graph[a].size() - 1});\n  }\n  ll build(int s, int t, ll f) {\n    h.assign(n, 0);\n    ll res = 0;\n    while(f > 0) {\n      dist.assign(n, inf);\n      dist[s] = 0;\n      // Dijkstra with potential\n      using P = pair< ll, int >;\n      priority_queue< P, vector< P >, greater< P > > pq;\n      pq.emplace(0, s);\n      while(pq.size()) {\n        ll d;\n        int v;\n        tie(d, v) = pq.top();\n        pq.pop();\n        if(dist[v] < d) continue;\n        for(size_t i = 0; i < graph[v].size(); i++) {\n          Edge &edge = graph[v][i];\n          ll nd = dist[v] + edge.cost + h[v] - h[edge.to];\n          if(edge.cap > 0 && dist[edge.to] > nd) {\n            dist[edge.to] = nd;\n            pq.emplace(nd, edge.to);\n            prevv[edge.to] = v;\n            preve[edge.to] = i;\n          }\n        }\n      }\n      //\n      if(dist[t] == inf) return -1;\n      for(int v = 0; v < n; v++) h[v] += dist[v];\n\n      ll d = f;\n      for(int v = t; v != s; v = prevv[v]) {\n        d = min(d, graph[prevv[v]][preve[v]].cap);\n      }\n      f -= d;\n      res += d * h[t];\n      for(int v = t; v != s; v = prevv[v]) {\n        Edge &edge = graph[prevv[v]][preve[v]];\n        edge.cap -= d;\n        graph[v][edge.rev].cap += d;\n      }\n    }\n    return res;\n  }\n};\n/// }}}--- ///\n\nll inf = 1e18;\n\nconstexpr int N = 80, M = 320;\n\nint n, m;\nint x[N], y[N];\nll v[N];\nchar type[M];\nint a[M], b[M];\n\nint XL[N], XR[N];\nint YL[N], YR[N];\n\n// smin, smax {{{\ntemplate < class T, class U >\ninline void smin(T &a, const U &b) {\n  a = a < (T) b ? a : b;\n}\ntemplate < class T, class U >\ninline void smax(T &a, const U &b) {\n  a = a < (T) b ? b : a;\n}\n// }}}\n\nll solve(int k) {\n  if(k == 0) return 0;\n  int s, t;\n  MinCostFlow ecas(k + k + n + n, inf, s, t);\n  for(int i = 0; i < k; i++) XL[i] = 0, XR[i] = 100;\n  for(int i = 0; i < k; i++) YL[i] = 0, YR[i] = 100;\n  for(int i = 0; i < m; i++) {\n    if(b[i] >= k) continue;\n    switch(type[i]) {\n      case 'L':\n        smax(XL[b[i]], a[i] + 1);\n        break;\n      case 'R':\n        smin(XR[k - b[i] - 1], a[i] - 1);\n        break;\n      case 'D':\n        smax(YL[b[i]], a[i] + 1);\n        break;\n      case 'U':\n        smin(YR[k - b[i] - 1], a[i] - 1);\n        break;\n    }\n  }\n  for(int i = 0; i + 1 < k; i++) smax(XL[i+1], XL[i]), smax(YL[i+1] , YL[i]);\n  for(int i = k - 2; i >= 0; i--) smin(XR[i], XR[i+1]), smin(YR[i] , YR[i+1]);\n\n  ll bias = 1e15;\n\n  for(int i = 0; i < k; i++) ecas.addEdge(s, i, 1, 0);\n  for(int i = 0; i < k; i++) ecas.addEdge(k + i, t, 1, 0);\n  for(int i = 0; i < n; i++) ecas.addEdge(k + k + i, k + k + n + i, 1, bias - v[i]);\n\n  for(int i = 0; i < k; i++) {\n    for(int j = 0; j < n; j++) {\n      if(XL[i] <= x[j] && x[j] <= XR[i]) {\n        ecas.addEdge(i, k + k + j, 1, 0);\n      }\n      if(YL[i] <= y[j] && y[j] <= YR[i]) {\n        ecas.addEdge(k + k + n + j, k + i, 1, 0);\n      }\n    }\n  }\n\n  ll val = ecas.build(s, t, k);\n  if(val == -1) return -1;\n\n  val = -val + bias * k;\n  return val;\n}\n\n// O(N^4 log N)\nint main() {\n  std::ios::sync_with_stdio(false), std::cin.tie(0);\n\n  cin >> n;\n  for(int i = 0; i < n; i++) cin >> x[i] >> y[i] >> v[i];\n  \n  cin >> m;\n  for(int i = 0; i < m; i++) cin >> type[i] >> a[i] >> b[i];\n\n  ll ans = 0;\n\n  for(int k = 1; k <= n; k++) {\n    auto val = solve(k);\n    if(val != -1) smax(ans, val);\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n\nint main(){\n  int n;\n  cin >> n;\n  long stage[110][110];\n  for(int i=0;i<110;i++){\n    for(int j=0;j<110;j++){\n      stage[i][j]=0;\n    }\n  }\n  for(int i=0;i<n;i++){\n    int x,y;\n    long v;\n    cin >> x>> y>>v;\n    stage[x][y]=v;\n  }\n  int m;\n  cin >> m;\n  int lool[330][3];\n  for(int i=0;i<m;i++){\n    string s;\n    int a,b;\n    cin >> s >>a >>b;\n    if(s==\"L\"){\n      lool[i][0]=0;\n      lool[i][1]=a;\n      lool[i][2]=b;\n    }else if(s==\"R\"){\n      lool[i][0]=1;\n      lool[i][1]=a;\n      lool[i][2]=b;\n    }else if(s==\"D\"){\n      lool[i][0]=2;\n      lool[i][1]=a;\n      lool[i][2]=b;\n    }else{\n      lool[i][0]=3;\n      lool[i][1]=a;\n      lool[i][2]=b;\n    }\n  }\n  \n  int sum=0;\n  int max=1;\n  int max_x,max_y;\n  while(1){\n    //価値最大の宝石を探索\n    for(int i=1;i<=100;i++){\n      for(int j=1;j<=100;j++){\n        if(max<=stage[i][j]){\n          max=stage[i][j];\n          max_x=i;\n          max_y=j;\n        }\n      }\n    }\n    \n    if(max==1) break;\n    \n    //条件にあってるか検索\n    bool flag=true;\n    for(int i=0;i<m;i++){\n      if(lool[i][0]==0){\n        if(lool[i][2]==0){\n          if(max_x<=lool[i][1]) flag=false;\n        }\n      }else if(lool[i][0]==1){\n        if(lool[i][2]==0){\n          if(max_x>=lool[i][1]) flag=false;\n        }\n      }else if(lool[i][0]==2){\n        if(lool[i][2]==0){\n          if(max_y<=lool[i][1]) flag=false;\n        }\n      }else if(lool[i][0]==3){\n        if(lool[i][2]==0){\n          if(max_y>=lool[i][1]) flag=false;\n        }\n      }\n    }\n    if(flag==true){\n      stage[max_x][max_y]=0;\n      sum+=max;\n      max=1;\n      //条件のかきかえ\n      for(int i=0;i<m;i++){\n        if(lool[i][0]==0){\n          if(max_x<=lool[i][1]){\n          \tlool[i][2]--;\n          }\n        }else if(lool[i][0]==1){\n          if(max_x>=lool[i][1]){\n          \tlool[i][2]--;\n          }\n        }else if(lool[i][0]==2){\n          if(max_y<=lool[i][1]){\n          \tlool[i][2]--;\n          }\n        }else if(lool[i][0]==3){\n          if(max_y>=lool[i][1]){\n          \tlool[i][2]--;\n          }\n        }\n    }\n    }else{\n      stage[max_x][max_y]=0;\n      max=1;\n    }\n  }\n  cout << sum;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cctype>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing i64=long long;\nconst int V=327,E=26087;const i64 inf=1e18;\nint n,m,s,t,tot,head[V],vis[V];i64 cost,dis[V];\nstruct edge{int v,f;i64 c;int next;}e[E];\nstruct node{int x,y;i64 v;}p[V];\nstruct opt{int o,a,b;}op[V];\nint read(){int x=0;int c=getchar();while(isspace(c))c=getchar();while(isdigit(c))(x*=10)+=c&15,c=getchar();return x;}\ni64 raed(){i64 x=0;int c=getchar();while(isspace(c))c=getchar();while(isdigit(c))(x*=10)+=c&15,c=getchar();return x;}\nvoid add(int u,int v,int f,i64 c){e[++tot]={v,f,c,head[u]},head[u]=tot,e[++tot]={u,0,-c,head[v]},head[v]=tot;}\nint update()\n{\n    i64 mn=inf;\n    for(int u=1;u<=t;++u) if(vis[u]) for(int i=head[u];i;i=e[i].next) if(!vis[e[i].v]&&e[i].f) mn=std::min(mn,dis[e[i].v]+e[i].c-dis[u]);\n    if(mn==inf) return 0;\n    for(int u=1;u<=t;++u) if(vis[u]) dis[u]+=mn;\n    return 1;\n}\nint dfs(int u,int res)\n{\n    if(u==t) return cost-=dis[s]*res,res;\n    int use=0;vis[u]=1;\n    for(int i=head[u],t;i;i=e[i].next)\n\tif(!vis[e[i].v]&&e[i].f&&dis[u]==dis[e[i].v]+e[i].c)\n\t{\n\t    t=dfs(e[i].v,std::min(res-use,e[i].f)),use+=t,e[i].f-=t,e[i^1].f+=t;\n\t    if(use==res) return use;\n\t}\n    return use;\n}\nvoid solve(int k)\n{\n    static int lx[V],rx[V],ly[V],ry[V];\n    tot=1,cost=0,s=2*k+2*n+1,t=s+1,memset(head+1,0,t<<2),memset(dis+1,0,t<<3);\n    memset(lx+1,0,k<<2),memset(ly+1,0,k<<2),memset(rx+1,0x7f,k<<2),memset(ry+1,0x7f,k<<2);\n    for(int i=1;i<=k;++i) add(s,i,1,0),add(i+n+n+k,t,1,0);\n    for(int i=1;i<=n;++i) add(i+k,i+n+k,1,-p[i].v);\n    for(int i=1;i<=m;++i)\n\tswitch(op[i].o)\n\t{\n\tcase'U':for(int j=1;j<=k-op[i].b;++j)ry[j]=std::min(ry[j],op[i].a-1);break;\n\tcase'D':for(int j=op[i].b+1;j<=k;++j)ly[j]=std::max(ly[j],op[i].a+1);break;\n\tcase'L':for(int j=op[i].b+1;j<=k;++j)lx[j]=std::max(lx[j],op[i].a+1);break;\n\tcase'R':for(int j=1;j<=k-op[i].b;++j)rx[j]=std::min(rx[j],op[i].a-1);break;\n\t}\n    for(int i=1;i<=k;++i) for(int j=1;j<=n;++j) if(lx[i]<=p[j].x&&p[j].x<=rx[i]) add(i,j+k,1,0);\n    for(int i=1;i<=k;++i) for(int j=1;j<=n;++j) if(ly[i]<=p[j].y&&p[j].y<=ry[i]) add(j+n+k,i+n+n+k,1,0);\n    do do memset(vis+1,0,t<<2);while(dfs(s,1e9));while(update());\n}\nint main()\n{\n    i64 ans=0;\n    n=read();for(int i=1;i<=n;++i) p[i]={read(),read(),raed()};\n    m=read();for(int i=1;i<=m;++i) op[i]={getchar(),read(),read()};\n    for(int k=1;k<=n;++k) solve(k),ans=std::max(ans,cost);\n    printf(\"%lld\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace __gnu_pbds;\nusing namespace std;\n \ntemplate <typename T>\nusing ordered_set =\n\ttree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n \n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n\t*this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n \n#define shandom_ruffle random_shuffle\n \nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=327;\nusing bn=bitset<87>;\n\nint n;\npii gdz[nax];\nll war[nax];\n\nint m;\nbn podz[nax];\nint ile[nax];\n\nll wyn;\n\nbn ter;\n\nll dajwar()\n{\n\tll ret=0;\n\tfor (int i=1; i<=n; i++)\n\t\tif (ter[i])\n\t\t\tret+=war[i];\n\treturn ret;\n}\n\nint popr()\n{\n\tfor (int i=1; i<=m; i++)\n\t\tif ((podz[i]&ter).count()>ile[i])\n\t\t\treturn 0;\n\treturn 1;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(\"%d%d%lld\", &gdz[i].first, &gdz[i].second, &war[i]);\n\tscanf(\"%d\", &m);\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\tchar c;\n\t\tint a, b;\n\t\tscanf(\" %c%d%d\", &c, &a, &b);\n\t\tfor (int j=1; j<=n; j++)\n\t\t{\n\t\t\tif (c=='L' && gdz[j].first<=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='R' && gdz[j].first>=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='D' && gdz[j].second<=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='U' && gdz[j].second>=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t}\n\t\tile[i]=b;\n\t}\n\tll sta=0;\n\tconst int czes=5e5;\n\tconst int res=3e4;\n\tfor (int h=0; h%czes || (clock()<=4.5*CLOCKS_PER_SEC); h++)\n\t{\n\t\tif (!(rand()%res))\n\t\t{\n\t\t\tter.reset();\n\t\t\tsta=0;\n\t\t}\n\t\tbn pam=ter;\n\t\tint r=rand()%2+1;\n\t\tfor (int i=0; i<r; i++)\n\t\t\tter.flip(rand()%n+1);\n\t\tif (!popr())\n\t\t{\n\t\t\tter=pam;\n\t\t\tcontinue;\n\t\t}\n\t\tll now=dajwar();\n\t\tif (now>=sta || !(rand()%500))\n\t\t{\n\t\t\tsta=now;\n\t\t\twyn=max(wyn, now);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tter=pam;\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\\n\", wyn);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nostream &operator<<(ostream &os, __float128 f) { return os << (LD)f; }\n\n\nstruct Simplex {        // Maximize c*x subject to Ax <= b.\n  using T = LD;         // Initialize the structure, set A, b, c and then run\n  vector<vector<T>> A;  // solve(). Max objective is stored in res. To recover\n  vector<T> b, c;       // the best result, use getVars().\n  T abs(T x) { return x < 0 ? -x : x; }\n\n  int V, E;\n  VI eqIds, varIds, cols;\n  T res;\n  const LD kEps = 1e-9;\n\n  Simplex(int vars, int eqs) : A(eqs, vector<T>(vars)), b(eqs), c(vars),\n                               V(vars), E(eqs), eqIds(eqs), varIds(vars), res(0) {\n    iota(ALL(varIds), 0); iota(ALL(eqIds), vars);\n  }\n\n  void pivot(int eq, int var) {\n    T coef = 1 / A[eq][var];\n    cols.clear();\n    REP (i, V) {\n      if (abs(A[eq][i]) > kEps) { cols.PB(i); A[eq][i] *= coef; }\n    }\n    A[eq][var] *= coef; b[eq] *= coef;\n    REP (row, E) {\n      if (row == eq || abs(A[row][var]) < kEps) { continue; }\n      T k = -A[row][var];\n      A[row][var] = 0;\n      for (int i : cols) { A[row][i] += k * A[eq][i]; }\n      b[row] += k * b[eq];\n    }\n    T q = c[var]; c[var] = 0;\n    for (int i : cols) { c[i] -= q * A[eq][i]; }\n    res += q * b[eq];\n\n    swap(varIds[var], eqIds[eq]);\n  }\n  \n  bool solve() {\n    while (true) {\n      int eq = -1, var = -1;\n      REP (i, E) { if (b[i] < -kEps) { eq = i; break; } }\n      if (eq == -1) { break; }\n      REP (i, V) { if (A[eq][i] < -kEps) { var = i; break; } }\n      if (var == -1) { res = -1e9; return false; /* No solution */ }\n      pivot(eq, var);\n    }\n\n    while (true) {\n      int var = -1, eq = -1;\n      REP (i, V) { if (c[i] > kEps) { var = i; break; } }\n      if (var == -1) { break; }\n      REP (i, E) {\n        if (A[i][var] < kEps) { continue; }\n        if (eq >= 0 && b[i] / A[i][var] >= b[eq] / A[eq][var]) { continue; }\n        eq = i;\n      }\n      if (eq == -1) { res = 1e9; return false; /* Unbounded */ }\n      pivot(eq, var);\n    }\n\n    return true;\n  }\n  \n  vector<T> getVars() {  // Optimal assignment of variables.\n    vector<T> result(V);\n    REP (i, E) { if (eqIds[i] < V) { result[eqIds[i]] = b[i]; } }\n    return result;\n  }\n};\n\nint N, M;\nvector<PII> points;\nVI point_vals;\n\nLL low_bound;\nclock_t time_start;\n\nvoid Solve(Simplex sim) {\n  Simplex sim_copy = sim;\n  assert(sim.solve());\n\n  if (sim.res - 1e-9 < low_bound) { return; }\n  auto vars = sim.getVars();\n\n  if ((clock() - time_start) > 4.9 * CLOCKS_PER_SEC) {\n    cout << low_bound << \"\\n\";\n    exit(0);\n  }\n\n  LL my_low = 0;\n  for (int i = 0; i < N; ++i) {\n    if (vars[i] > .99) {\n      my_low += point_vals[i];\n      //sim_copy.b[M + i * 2] = -1;\n    }\n  }\n\n  maxi(low_bound, my_low);\n  bool had_any = false;\n  for (int i = 0; i < N; ++i) {\n    if (vars[i] > .01 && vars[i] < .989) {\n      assert(vars[i] > .49 && vars[i] < .51);\n      had_any = true;\n    }\n  }\n\n  if (had_any) {\n    // take none?\n    for (int i = 0; i < N; ++i) {\n      if (vars[i] > .01 && vars[i] < .989) {\n        sim_copy.b[M + i * 2 + 1] = 0;\n      }\n    }\n    Solve(sim_copy);\n    for (int i = 0; i < N; ++i) {\n      if (vars[i] > .01 && vars[i] < .989) {\n        sim_copy.b[M + i * 2 + 1] = 1;\n      }\n    }\n  }\n\n  for (int i = 0; i < N; ++i) {\n    if (vars[i] > .01 && vars[i] < .989) {\n      // take?\n      sim_copy.b[M + i * 2] = -1;\n      Solve(sim_copy);\n      sim_copy.b[M + i * 2] = 0;\n      sim_copy.b[M + i * 2 + 1] = 0;\n      if (sim.res - 1e-9 < low_bound) { return; }\n    }\n  }\n\n}\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n  time_start = clock();\n\n  cin >> N;\n  points.resize(N);\n  point_vals.resize(N);\n\n  for (int i = 0; i < N; ++i) {\n    cin >> points[i].st >> points[i].nd >> point_vals[i];\n  }\n\n  map<char, function<bool(PII, int)>> checkers = {\n    {'L', [](const PII &pt, int a) { return pt.st <= a; }},\n    {'R', [](const PII &pt, int a) { return pt.st >= a; }},\n    {'D', [](const PII &pt, int a) { return pt.nd <= a; }},\n    {'U', [](const PII &pt, int a) { return pt.nd >= a; }}\n  };\n\n  cin >> M;\n\n  Simplex sim(N, M + 2 * N);\n  for (int i = 0; i < M; ++i) {\n    char type;\n    int a, b;\n    cin >> type >> a >> b;\n\n    for (int j = 0; j < N; ++j) {\n      sim.A[i][j] = checkers[type](points[j], a);\n    }\n    sim.b[i] = b;\n\n    debug(sim.A[i], sim.b[i]);\n  }\n  for (int i = 0; i < N; ++i) {\n    sim.c[i] = point_vals[i];\n    sim.A[M + i * 2][i] = -1;\n    sim.A[M + i * 2 + 1][i] = 1;\n    sim.b[M + i * 2] = 0;\n    sim.b[M + i * 2 + 1] = 1;\n  }\n  auto orig_a = sim.A;\n  auto orig_b = sim.b;\n\n  Solve(sim);\n  cout << low_bound << \"\\n\";\n\n  /*assert(sim.solve());\n  auto vars = sim.getVars();\n\n  vector<int> always, maybe;\n  debug(vars);\n  for (int i = 0; i < N; ++i) {\n    if (vars[i] > 0.7) {\n      always.PB(i);\n    } else if (vars[i] > 0.3) {\n      maybe.PB(i);\n    }\n  }\n\n  debug(always, maybe);\n\n  assert(SZ(maybe) <= 3);\n  LL ans = -1;\n\n  for (LL m = 0; m < (1LL << SZ(maybe)); ++m) {\n    vector<int> mine = always;\n    for (int j = 0; j < SZ(maybe); ++j) {\n      if ((m >> j) & 1) { mine.PB(maybe[j]); }\n    }\n\n    bool fail = false;\n    for (int i = 0; i < M; ++i) {\n      int cnt = 0;\n      for (int j : mine) {\n        if (orig_a[i][j] > 0.5) { ++cnt; }\n      }\n      debug(mine, i, cnt, orig_b[i]);\n      if (cnt > (int)round((LD)orig_b[i])) { debug(i); fail = true; }\n    }\n\n    if (fail) { continue; }\n    LL x = 0;\n    for (int i : mine) {\n      x += point_vals[i];\n    }\n    maxi(ans, x);\n  }\n\n  cout << ans << \"\\n\";*/\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define REV(i,n) for(ll (i) = (n) - 1;(i) >= 0;--i)\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {REP(WW,n)cerr << v[WW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,WW,HH) {REP(W_,WW){REP(H_,HH)cerr << v[W_][H_] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n#define fastcin() cin.tie(0);ios::sync_with_stdio(false)\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nclass minCostFlow {\n\n\tstruct edge { ll to, cap, cost, rev; };\n\n\tll V;\n\tvector<vector<edge>> G;\n\tvector<ll> dist;\n\tvector<ll> prevv;\n\tvector<ll> preve;\n\npublic:\n\n\tminCostFlow(ll n): G(n), dist(n), prevv(n), preve(n), V(n){\n\t}\n\n\tvoid addEdge(ll from, ll to, ll cap, ll cost) {\n\t\tG[from].push_back((edge){to, cap, cost, (ll)G[to].size()});\n\t\tG[to].push_back((edge){from, 0, -cost, (ll)G[from].size() - 1});\n\t}\n\n\tll solve(ll s, ll t, ll f) {\n\t\tll ret = 0;\n\t\twhile(f > 0) {\n\t\t\tfill(dist.begin(), dist.end(), LLINF);\n\t\t\tdist[s] = 0;\n\t\t\tbool update = true;\n\t\t\twhile(update) {\n\t\t\t\tupdate = false;\n\t\t\t\tfor(ll v = 0;v < V;v++) {\n\t\t\t\t\tif(dist[v] == LLINF)continue;\n\t\t\t\t\tfor(ll i = 0;i < G[v].size();i++) {\n\t\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\t\tif(e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n\t\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dist[t] == LLINF) {\n\t\t\t\treturn LLINF;//流せない\n\t\t\t}\n\n\t\t\tll d = f;\n\t\t\tfor(ll v = t;v != s;v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tret += d * dist[t];\n\t\t\tfor(ll v = t;v != s;v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n};\n\nll check(vector<pair<P, ll>> &v, vector<pair<char, P>> &t, int k){\n\tll cost = 1000000000000000LL;\n\tint n = v.size();\n\tint m = t.size();\n\t\n\tvector<P> ver(k, MP(0, LLINF));\n\tvector<P> hor(k, MP(0, LLINF));\n\t\n\tREP(i, m){\n\t\tchar c = t[i].FI;\n\t\tP p = t[i].SE;\n\t\tif(c == 'L'){\n\t\t\tif(p.SE >= k)continue;\n\t\t\thor[p.SE].FI = max(hor[p.SE].FI, p.FI + 1);\n\t\t}\n\t\telse if(c == 'R'){\n\t\t\tif(k - p.SE - 1 < 0)continue;\n\t\t\thor[k - p.SE - 1].SE = min(hor[k - p.SE - 1].SE, p.FI - 1);\n\t\t}\n\t\telse if(c == 'D'){\n\t\t\tif(p.SE >= k)continue;\n\t\t\tver[p.SE].FI = max(ver[p.SE].FI, p.FI + 1);\n\t\t}\n\t\telse {\n\t\t\tif(k - p.SE - 1 < 0)continue;\n\t\t\tver[k - p.SE - 1].SE = min(ver[k - p.SE - 1].SE, p.FI - 1);\n\t\t}\n\t}\n\t\n\tREP(i, k - 1){\n\t\tver[i + 1].FI = max(ver[i + 1].FI, ver[i].FI);\n\t\thor[i + 1].FI = max(hor[i + 1].FI, hor[i].FI);\n\t\tver[k - i - 2].SE = min(ver[k - i - 2].SE, ver[k - i - 1].SE); \n\t\thor[k - i - 2].SE = min(hor[k - i - 2].SE, hor[k - i - 1].SE); \n\t}\n\t\n\tminCostFlow mcf(2 * (n + k) + 10);\n\t\n\tll s = 2 * (k + n);\n\tll g = 2 * (k + n) + 1;\n\t\n\tREP(i, k){\n\t\tll idA = 2 * n + i;\n\t\tll idB = 2 * n + k + i;\n\t\tmcf.addEdge(s, idA, 1, 0);\n\t\tmcf.addEdge(idB, g, 1, 0);\n\t}\n\t\n\tREP(i, n){\n\t\tP now = v[i].FI;\n\t\tll val = v[i].SE;\n\t\tll idA = i;\n\t\tll idB = i + n;\n\t\tmcf.addEdge(idA, idB, 1, cost - val);\n\t\tREP(j, k){\n\t\t\tll idC = 2 * n + j;\n\t\t\tll idD = 2 * n + k + j;\n\t\t\tif(now.FI >= hor[j].FI && now.FI <= hor[j].SE){\n\t\t\t\tmcf.addEdge(idC, idA, 1, 0);\n\t\t\t}\n\t\t\tif(now.SE >= ver[j].FI && now.SE <= ver[j].SE){\n\t\t\t\tmcf.addEdge(idB, idD, 1, 0);\n\t\t\t}\n\t\t}\n\t}\n\treturn k * cost - mcf.solve(s, g, k);\n}\n\nint main(){\n\t\n\tll n;cin >> n;\n\tvector<pair<P, ll>> v(n);\n\tREP(i, n)cin >> v[i].FI.FI >> v[i].FI.SE >> v[i].SE;\n\tll m;cin >> m;\n\tvector<pair<char, P>> t(m);\n\tREP(i, m)cin >> t[i].FI >> t[i].SE.FI >> t[i].SE.SE;\n\t\n\tll ans = 0;\n\t\n\tfor(ll i = 1;i <= n;i++){\n\t\tans = max(ans, check(v, t, i));\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Tp template<typename Ty>\n#define Ts template<typename Ty,typename... Ar>\n#define Reg register\n#define RI Reg int\n#define Con const\n#define CI Con int&\n#define I inline\n#define W while\n#define N 80\n#define M 320\n#define LL long long\n#define INF 1e18\n#define Gmax(x,y) (x<(y)&&(x=(y)))\n#define Gmin(x,y) (x>(y)&&(x=(y)))\nusing namespace std;\nint n,m,L[N+5],R[N+5],U[N+5],D[N+5];\nstruct Jewel {int x,y;LL v;}s[N+5];struct Data {char op;int x,y;}p[M+5];\ntemplate<int PS,int ES> class MinCostMaxlow\n{\n\tprivate:\n\t\t#define E(x) ((((x)-1)^1)+1)\n\t\t#define S (4*n+1)\n\t\t#define T (4*n+2)\n\t\tint ee,lnk[PS+5];struct edge {int to,nxt,F;LL C;}e[2*ES+5];\n\t\tint p[PS+5],IQ[PS+5],F[PS+5];LL C[PS+5];queue<int> q;\n\t\tI bool SPFA()\n\t\t{\n\t\t\tRI i,k;for(i=0;i<=4*n+2;++i) F[i]=1e9,C[i]=-INF;q.push(S),C[S]=0;\n\t\t\tW(!q.empty()) for(i=lnk[k=q.front()],q.pop(),IQ[k]=0;i;i=e[i].nxt)\n\t\t\t{\n\t\t\t\tif(!e[i].F||C[k]+e[i].C<=C[e[i].to]) continue;\n\t\t\t\tC[e[i].to]=C[k]+e[p[e[i].to]=i].C,F[e[i].to]=min(F[k],e[i].F),\n\t\t\t\t!IQ[e[i].to]&&(q.push(e[i].to),IQ[e[i].to]=1);\n\t\t\t}return F[T]!=1e9;\n\t\t}\n\tpublic:\n\t\tI void Clear() {ee=0,memset(lnk,0,sizeof(lnk));}\n\t\tI void Add(CI x,CI y,CI f,Con LL& c)\n\t\t{\n\t\t\te[++ee].nxt=lnk[x],e[lnk[x]=ee].to=y,e[ee].F=f,e[ee].C=c,\n\t\t\te[++ee].nxt=lnk[y],e[lnk[y]=ee].to=x,e[ee].F=0,e[ee].C=-c;\n\t\t}\n\t\tI LL MCMF(RI k)\n\t\t{\n\t\t\tRI x;LL t=0;W(SPFA())\n\t\t\t{\n\t\t\t\tk-=F[T],t+=C[T]*F[T],x=T;\n\t\t\t\tW(x^S) e[p[x]].F-=F[T],e[E(p[x])].F+=F[T],x=e[E(p[x])].to;\n\t\t\t}return k?0:t;\n\t\t}\n};MinCostMaxlow<4*N+2,3*N+2*N*N> F;\nint main()\n{\n\tRI i,j,k;for(scanf(\"%d\",&n),i=1;i<=n;++i) scanf(\"%d%d%lld\",&s[i].x,&s[i].y,&s[i].v);\n\tfor(scanf(\"%d\",&m),i=1;i<=m;++i) cin>>p[i].op,scanf(\"%d%d\",&p[i].x,&p[i].y);\n\tLL ans=0;for(i=1;i<=n;++i)\n\t{\n\t\tfor(j=1;j<=i;++j) L[j]=D[j]=0,R[j]=U[j]=100;for(j=1;j<=m;++j) switch(p[j].op)\n\t\t{\n\t\t\tcase 'L':p[j].y<i&&Gmax(L[p[j].y+1],p[j].x+1);break;\n\t\t\tcase 'R':p[j].y<i&&Gmin(R[i-p[j].y],p[j].x-1);break;\n\t\t\tcase 'D':p[j].y<i&&Gmax(D[p[j].y+1],p[j].x+1);break;\n\t\t\tcase 'U':p[j].y<i&&Gmin(U[i-p[j].y],p[j].x-1);break;\n\t\t}\n\t\tfor(j=2;j<=i;++j) Gmax(L[j],L[j-1]),Gmax(D[j],D[j-1]);\n\t\tfor(j=i-1;j;--j) Gmin(R[j],R[j+1]),Gmin(U[j],U[j+1]);F.Clear();\n\t\tfor(j=1;j<=n;++j) F.Add(j,n+j,1,s[j].v);for(j=1;j<=i;++j) F.Add(S,2*n+j,1,0),F.Add(3*n+j,T,1,0);\n\t\tfor(j=1;j<=i;++j) for(k=1;k<=n;++k) L[j]<=s[k].x&&s[k].x<=R[j]&&(F.Add(2*n+j,k,1,0),0);\n\t\tfor(j=1;j<=i;++j) for(k=1;k<=n;++k) D[j]<=s[k].y&&s[k].y<=U[j]&&(F.Add(n+k,3*n+j,1,0),0);\n\t\tans=max(ans,F.MCMF(i));\n\t}return printf(\"%lld\\n\",ans),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nnamespace io{\n    const int l=1<<20;\n    char buf[l],*s,*t,c;\n    inline void gc(){\n        if(s==t){\n            t=(s=buf)+fread(buf,1,l,stdin);\n            c=s==t?EOF:*s++;\n        }else c=*s++;\n    }\n    template<class IT>inline void gi(IT &x){\n        x=0;gc();while(c<'0'||c>'9')gc();\n        while('0'<=c&&c<='9'){x=(x<<1)+(x<<3)+(c^48);gc();}\n    }\n    char buf0[20];int a;\n    template<class IT>inline void pi(IT x){\n        if(x<0){putchar('-');x=-x;}\n        do buf0[++a]=x%10+48;while(x/=10);\n        while(a)putchar(buf0[a--]);\n        putchar('\\n');\n    }\n};\nusing io::gi;\nusing io::pi;\ntypedef unsigned int ui;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<int,ll > pil;\ntypedef pair<ll ,int> pli;\ntypedef pair<ll ,ll > pll;\ntypedef vector<int> vi;\ntypedef vector<ll > vl;\n#define pque priority_queue\n#define rep(i,l,r) for(i=(l);i<=(r);++i)\n#define per(i,l,r) for(i=(l);i>=(r);--i)\n#define REP(i,l,r) for(i=(l);i< (r);++i)\n#define PER(i,l,r) for(i=(l);i> (r);--i)\n#define mp make_pair\n#define pb push_back\n#define pf push_front\n#define pob pop_back\n#define pof pop_front\n#define fi first\n#define se second\ntemplate<class IT>inline void cmax(IT &a,IT b){if(a<b)a=b;}\ntemplate<class IT>inline void cmin(IT &a,IT b){if(b<a)a=b;}\nconst int N=85,M=325,V=N<<2;\nstruct edge{\n\tint u,w1;ll w2;int n;\n\tinline edge(){}\n\tinline edge(int u,int w1,ll w2,int n):u(u),w1(w1),w2(w2),n(n){}\n}e[N*V];int f[V],tot;\ninline void add(int v,int u,ll w2=0ll){\n\t//printf(\"%d %d %lld\\n\",v,u,w2);\n\te[tot]=edge(u,1, w2,f[v]);f[v]=(tot++);\n\te[tot]=edge(v,0,-w2,f[u]);f[u]=(tot++);\n}\nint q[V],in[V],p[V],pe[V];ll d[V];\ninline ll spfa(int S){\n\tint l=1,r=1,v,i,u;ll w;\n\tq[1]=S;\n\tREP(i,1,S)d[i]=-1ll;d[S]=0ll;\n\twhile(l<=r){\n\t\tin[v=q[(l++)%N]]=0;\n\t\tfor(i=f[v];~i;i=e[i].n)if(e[i].w1){\n\t\t\tu=e[i].u;\n\t\t\tif((w=d[v]+e[i].w2)>d[u]){\n\t\t\t\td[u]=w;\n\t\t\t\tp[u]=v;\n\t\t\t\tpe[u]=i;\n\t\t\t\tif(!in[u]){\n\t\t\t\t\tin[u]=1;\n\t\t\t\t\tq[(++r)%V]=u;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn d[S-1];\n}\nstruct jewel{\n\tint x,y;ll z;\n}J[N];\nstruct clue{\n\tint a,b;char c;\n}C[V];\nint lx[N],rx[N],ly[N],ry[N];\nint main(){\n    //freopen(\"a.in\",\"r\",stdin);\n    //freopen(\"a.out\",\"w\",stdout);\n    int n,m,i,j,k,v,u,ans1;ll ans2,ans=0ll,f2;\n\tchar str[2];\n    scanf(\"%d\",&n);\n    rep(i,1,n)scanf(\"%d%d%lld\",&J[i].x,&J[i].y,&J[i].z);\n\tscanf(\"%d\",&m);\n\trep(i,1,m){scanf(\"%s%d%d\",str,&C[i].a,&C[i].b);C[i].c=str[0];}\n\trep(k,1,n){\n\t\trep(i,1,k)lx[i]=1  ;\n\t\trep(i,1,k)rx[i]=100;\n\t\trep(i,1,k)ly[i]=1  ;\n\t\trep(i,1,k)ry[i]=100;\n\t\trep(i,1,m)if(C[i].b<k){\n\t\t\tswitch(C[i].c){\n\t\t\t\tcase 'L':cmax(lx[  C[i].b+1],C[i].a+1);break;\n\t\t\t\tcase 'R':cmin(rx[k-C[i].b  ],C[i].a-1);break;\n\t\t\t\tcase 'D':cmax(ly[  C[i].b+1],C[i].a+1);break;\n\t\t\t\tcase 'U':cmin(ry[k-C[i].b  ],C[i].a-1);break;\n\t\t\t}\n\t\t}\n\t\trep(i,2,k)cmax(lx[i  ],lx[i-1]);\n\t\trep(i,2,k)cmax(ly[i  ],ly[i-1]);\n\t\tper(i,k,2)cmin(rx[i-1],rx[i  ]);\n\t\tper(i,k,2)cmin(ry[i-1],ry[i  ]);\n\t\t//rep(i,1,k)printf(\"[%d,%d] [%d,%d]\\n\",lx[i],rx[i],ly[i],ry[i]);\n\t\tmemset(f,-1,sizeof(f));tot=0;\n\t\tv=(u=((n+k)<<1|1))+1;\n\t\trep(i,1,k)add(v,(n<<1)+i  );\n\t\trep(i,1,k)add(k+(n<<1)+i,u);\n\t\trep(i,1,n)add(i,i+n,J[i].z);\n\t\trep(i,1,k)rep(j,1,n){\n\t\t\tif(lx[i]<=J[j].x&&J[j].x<=rx[i])add(    (n<<1)+i,j);\n\t\t\tif(ly[i]<=J[j].y&&J[j].y<=ry[i])add(j+n,(n<<1)+i+k);\n\t\t}\n\t\tans1=0;ans2=0ll;\n\t\twhile(~(f2=spfa(v))){\n\t\t\t++ans1;\n\t\t\tans2+=f2;\n\t\t\tfor(i=u;i!=v;i=p[i]){\n\t\t\t\te[pe[i]  ].w1=0;\n\t\t\t\te[pe[i]^1].w1=1;\n\t\t\t}\n\t\t}\n\t\t//printf(\"k=%d ans1=%d ans2=%lld\\n\",k,ans1,ans2);\n\t\tif(ans1!=k)break;cmax(ans,ans2);\n\t}\n\tprintf(\"%lld\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nostream &operator<<(ostream &os, __float128 f) { return os << (LD)f; }\n\n\nstruct Simplex {        // Maximize c*x subject to Ax <= b.\n  using T = LD;         // Initialize the structure, set A, b, c and then run\n  vector<vector<T>> A;  // solve(). Max objective is stored in res. To recover\n  vector<T> b, c;       // the best result, use getVars().\n  T abs(T x) { return x < 0 ? -x : x; }\n\n  int V, E;\n  VI eqIds, varIds, cols;\n  T res;\n  const LD kEps = 1e-9;\n\n  Simplex(int vars, int eqs) : A(eqs, vector<T>(vars)), b(eqs), c(vars),\n                               V(vars), E(eqs), eqIds(eqs), varIds(vars), res(0) {\n    iota(ALL(varIds), 0); iota(ALL(eqIds), vars);\n  }\n\n  void pivot(int eq, int var) {\n    T coef = 1 / A[eq][var];\n    cols.clear();\n    REP (i, V) {\n      if (abs(A[eq][i]) > kEps) { cols.PB(i); A[eq][i] *= coef; }\n    }\n    A[eq][var] *= coef; b[eq] *= coef;\n    REP (row, E) {\n      if (row == eq || abs(A[row][var]) < kEps) { continue; }\n      T k = -A[row][var];\n      A[row][var] = 0;\n      for (int i : cols) { A[row][i] += k * A[eq][i]; }\n      b[row] += k * b[eq];\n    }\n    T q = c[var]; c[var] = 0;\n    for (int i : cols) { c[i] -= q * A[eq][i]; }\n    res += q * b[eq];\n\n    swap(varIds[var], eqIds[eq]);\n  }\n  \n  bool solve() {\n    while (true) {\n      int eq = -1, var = -1;\n      REP (i, E) { if (b[i] < -kEps) { eq = i; break; } }\n      if (eq == -1) { break; }\n      REP (i, V) { if (A[eq][i] < -kEps) { var = i; break; } }\n      if (var == -1) { res = -1e9; return false; /* No solution */ }\n      pivot(eq, var);\n    }\n\n    while (true) {\n      int var = -1, eq = -1;\n      REP (i, V) { if (c[i] > kEps) { var = i; break; } }\n      if (var == -1) { break; }\n      REP (i, E) {\n        if (A[i][var] < kEps) { continue; }\n        if (eq >= 0 && b[i] / A[i][var] >= b[eq] / A[eq][var]) { continue; }\n        eq = i;\n      }\n      if (eq == -1) { res = 1e9; return false; /* Unbounded */ }\n      pivot(eq, var);\n    }\n\n    return true;\n  }\n  \n  vector<T> getVars() {  // Optimal assignment of variables.\n    vector<T> result(V);\n    REP (i, E) { if (eqIds[i] < V) { result[eqIds[i]] = b[i]; } }\n    return result;\n  }\n};\n\nint N, M;\nvector<PII> points;\nVI point_vals;\n\nLL Solve(Simplex sim, LL low_bound) {\n  Simplex sim_copy = sim;\n  assert(sim.solve());\n\n  if (sim.res - 1e-9 < low_bound) { return 0; }\n  auto vars = sim.getVars();\n\n  LL my_low = 0;\n  for (int i = 0; i < N; ++i) {\n    if (vars[i] > .99) {\n      my_low += point_vals[i];\n      //sim_copy.b[M + i * 2] = -1;\n    }\n  }\n\n  maxi(low_bound, my_low);\n\n  bool had_any = false;\n  for (int i = 0; i < N; ++i) {\n    if (vars[i] > .01 && vars[i] < .989) {\n      had_any = true;\n      // take?\n      sim_copy.b[M + i * 2] = -1;\n      maxi(low_bound, Solve(sim_copy, low_bound));\n      sim_copy.b[M + i * 2] = 0;\n      if (sim.res - 1e-9 < low_bound) { return low_bound; }\n    }\n  }\n\n  if (had_any) {\n    // take none?\n    for (int i = 0; i < N; ++i) {\n      if (vars[i] > .01 && vars[i] < .989) {\n        sim_copy.b[M + i * 2 + 1] = 0;\n      }\n    }\n    maxi(low_bound, Solve(sim_copy, low_bound));\n  }\n\n  return low_bound;\n}\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n\n  cin >> N;\n  points.resize(N);\n  point_vals.resize(N);\n\n  for (int i = 0; i < N; ++i) {\n    cin >> points[i].st >> points[i].nd >> point_vals[i];\n  }\n\n  map<char, function<bool(PII, int)>> checkers = {\n    {'L', [](const PII &pt, int a) { return pt.st <= a; }},\n    {'R', [](const PII &pt, int a) { return pt.st >= a; }},\n    {'D', [](const PII &pt, int a) { return pt.nd <= a; }},\n    {'U', [](const PII &pt, int a) { return pt.nd >= a; }}\n  };\n\n  cin >> M;\n\n  Simplex sim(N, M + 2 * N);\n  for (int i = 0; i < M; ++i) {\n    char type;\n    int a, b;\n    cin >> type >> a >> b;\n\n    for (int j = 0; j < N; ++j) {\n      sim.A[i][j] = checkers[type](points[j], a);\n    }\n    sim.b[i] = b;\n\n    debug(sim.A[i], sim.b[i]);\n  }\n  for (int i = 0; i < N; ++i) {\n    sim.c[i] = point_vals[i];\n    sim.A[M + i * 2][i] = -1;\n    sim.A[M + i * 2 + 1][i] = 1;\n    sim.b[M + i * 2] = 0;\n    sim.b[M + i * 2 + 1] = 1;\n  }\n  auto orig_a = sim.A;\n  auto orig_b = sim.b;\n\n  cout << Solve(sim, 0) << \"\\n\";\n\n  /*assert(sim.solve());\n  auto vars = sim.getVars();\n\n  vector<int> always, maybe;\n  debug(vars);\n  for (int i = 0; i < N; ++i) {\n    if (vars[i] > 0.7) {\n      always.PB(i);\n    } else if (vars[i] > 0.3) {\n      maybe.PB(i);\n    }\n  }\n\n  debug(always, maybe);\n\n  assert(SZ(maybe) <= 3);\n  LL ans = -1;\n\n  for (LL m = 0; m < (1LL << SZ(maybe)); ++m) {\n    vector<int> mine = always;\n    for (int j = 0; j < SZ(maybe); ++j) {\n      if ((m >> j) & 1) { mine.PB(maybe[j]); }\n    }\n\n    bool fail = false;\n    for (int i = 0; i < M; ++i) {\n      int cnt = 0;\n      for (int j : mine) {\n        if (orig_a[i][j] > 0.5) { ++cnt; }\n      }\n      debug(mine, i, cnt, orig_b[i]);\n      if (cnt > (int)round((LD)orig_b[i])) { debug(i); fail = true; }\n    }\n\n    if (fail) { continue; }\n    LL x = 0;\n    for (int i : mine) {\n      x += point_vals[i];\n    }\n    maxi(ans, x);\n  }\n\n  cout << ans << \"\\n\";*/\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n#include <vector>\n#define PB push_back\n#define ll long long\nusing namespace std;\ntemplate <class T>\ninline void rd(T &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile(!isdigit(c)) { if(c=='-') f=-1; c=getchar(); }\n\twhile(isdigit(c)) x=x*10-'0'+c,c=getchar(); x*=f;\n}\ntemplate <class T> inline void cmin(T &x,T y) { if(y<x) x=y; }\ntemplate <class T> inline void cmax(T &x,T y) { if(x<y) x=y; }\nconst ll inf=1e16;\nint S,T,ncnt;\nnamespace Flow {\n\tconst int N=410;\n\tint head[N],cur[N];\n\tll dis[N];\n\tstruct ed { int to,next,f; ll w; };\n\tvector<ed> e;\n\tvoid init() { memset(head,-1,sizeof(head)),e.clear(); }\n\tvoid ad(int x,int y,int f,ll w) {\n\t\te.PB((ed){y,head[x],f,w}); head[x]=e.size()-1;\n\t\te.PB((ed){x,head[y],0,-w}); head[y]=e.size()-1;\n\t}\n\tqueue<int> que;\n\tint vis[N];\n\tbool bfs() {\n\t\tfor(int i=1;i<=ncnt;++i) dis[i]=-inf,cur[i]=head[i];\n\t\tdis[S]=0,vis[S]=1,que.push(S);\n\t\twhile(!que.empty()) {\n\t\t\tint u=que.front(); que.pop(),vis[u]=0;\n\t\t\tfor(int k=head[u];~k;k=e[k].next) if(e[k].f) {\n\t\t\t\tint v=e[k].to;\n\t\t\t\tif(dis[v]<dis[u]+e[k].w) {\n\t\t\t\t\tdis[v]=dis[u]+e[k].w;\n\t\t\t\t\tif(!vis[v]) vis[v]=1,que.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dis[T]>-inf;\n\t}\n\tint dfs(int u,int f) {\n\t\tif(u==T||!f) return f; int ret=0,tmp;\n\t\tvis[u]=1;\n\t\tfor(int &k=cur[u];~k;k=e[k].next) if(e[k].f) {\n\t\t\tint v=e[k].to;\n\t\t\tif(!vis[v]&&dis[v]==dis[u]+e[k].w&&(tmp=dfs(v,min(f,e[k].f)))) {\n\t\t\t\te[k].f-=tmp,e[k^1].f+=tmp;\n\t\t\t\tf-=tmp,ret+=tmp;\n\t\t\t\tif(!f) break;\n\t\t\t}\n\t\t}\n\t\tvis[u]=0;\n\t\treturn ret;\n\t}\n\tll work() { ll ans=0; while(bfs()) ans+=dfs(S,1e9)*dis[T]; return ans; }\n}\nconst int N=110;\nconst int M=410;\nchar ss[M],str[10];\nint a[M],b[M];\nint xi[N],yi[N],n,m;\nint lbx[N],rbx[N],lby[N],rby[N];\nint idx[N],idy[N];\nll vi[N];\nll sol(int K) {\n\tfor(int i=1;i<=K;++i)\n\t\tlbx[i]=lby[i]=1,\n\t\trbx[i]=rby[i]=100;\n\tfor(int i=1;i<=m;++i) {\n\t\tif(b[i]>K) continue;\n\t\tif(ss[i]=='L') cmax(lbx[b[i]+1],a[i]+1);\n\t\telse if(ss[i]=='R') cmin(rbx[K-b[i]],a[i]-1);\n\t\telse if(ss[i]=='D') cmax(lby[b[i]+1],a[i]+1);\n\t\telse cmin(rby[K-b[i]],a[i]-1);\n\t}\n\tfor(int i=2;i<=K;++i)\n\t\tcmax(lbx[i],lbx[i-1]),\n\t\tcmax(lby[i],lby[i-1]);\n\tfor(int i=K-1;i>=1;--i)\n\t\tcmin(rbx[i],rbx[i+1]),\n\t\tcmin(rby[i],rby[i+1]);\n\t\n\tfor(int i=1;i<=K;++i) if(lbx[i]>rbx[i]||lby[i]>rby[i]) return 0;\n//\tfor(int i=1;i<=K;++i) printf(\"%d %d %d %d\\n\",lbx[i],rbx[i],lby[i],rby[i]);\n\tncnt=0; Flow::init();\n\tS=++ncnt,T=++ncnt;\n\tfor(int i=1;i<=100;++i) idx[i]=++ncnt,idy[i]=++ncnt;\n\tfor(int i=1;i<=K;++i) {\n\t\tint u=++ncnt;\n\t\tFlow::ad(S,u,1,0);\n\t\tfor(int j=lbx[i];j<=rbx[i];++j)\n\t\t\tFlow::ad(u,idx[j],1,0);\n\t}\n\tfor(int i=1;i<=K;++i) {\n\t\tint u=++ncnt;\n\t\tFlow::ad(u,T,1,0);\n\t\tfor(int j=lby[i];j<=rby[i];++j)\n\t\t\tFlow::ad(idy[j],u,1,0);\n\t}\n\tfor(int i=1;i<=n;++i)\n\t\tFlow::ad(idx[xi[i]],idy[yi[i]],1,vi[i]);\n\treturn Flow::work();\n}\n\t\n\t\nint main() {\n\trd(n);\n\tfor(int i=1;i<=n;++i) rd(xi[i]),rd(yi[i]),rd(vi[i]);\n\trd(m);\n\tfor(int i=1;i<=m;++i) {\n\t\tscanf(\"%s\",str);\n\t\tss[i]=str[0];\n\t\trd(a[i]),rd(b[i]);\n\t}\n\tll ans=0;\n\tfor(int i=1;i<=n;++i) ans=max(ans,sol(i));\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#define M 5010\n#define int long long\n#define clr(X) memset(X, 0, sizeof X)\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int Lim = 105;\n\nint Head[M], Next[M], Go[M], Cost[M], Fl[M], Cnt = 1;\n\nint n, A[M], B[M], C[M], Q, op[M], QA[M], QB[M];\n\nbool vis[M];\n\nint Dis[M], Pr[M], mxF[M];\n\nll nwans = 0, totans = 0; // getmax!\n\n/*struct node {\n    int dis, v;\n    node() {}\n    node(int _1, int _2) {dis = _1, v = _2;}\n    node operator < (const node& X) const {return dis > X.dis;}\n};\n\npriority_queue <node> Q;*/\n\nvoid SPFA(int S) {\n    memset(Dis, 63, sizeof Dis), clr(Pr), clr(mxF), clr(vis), mxF[S] = 2333333;\n    Dis[S] = 0;\n    vector <int> V(1, S);\n    for(int i = 0; i < V.size(); i++) {\n        int x = V[i], ds = Dis[x];\n        vis[x] = 0;\n        for(int T = Head[x]; T; T = Next[T])\n            if(Fl[T] && Dis[Go[T]] > ds + Cost[T]) {\n                Dis[Go[T]] = ds + Cost[T];\n                mxF[Go[T]] = min(mxF[x], Fl[T]);\n                Pr[Go[T]] = T ^ 1;\n                if(!vis[Go[T]]) vis[Go[T]] = 1, V.push_back(Go[T]);\n            }\n    }\n}\n\nint MMP(int SS, int TT, int f) {\n    int ans = 0, fl = 0;\n    for(; ;) {\n        SPFA(SS);\n        if(Dis[TT] > 1e18) {\n            if(fl != f) return 1e18;\n            return ans;\n        }\n        ans += Fl[TT] * Dis[TT], fl += mxF[TT];\n        for(int i = TT; i != SS; i = Go[Pr[i]]) {\n            Fl[Pr[i]] += mxF[TT];\n            Fl[Pr[i] ^ 1] -= mxF[TT];\n        }\n    }\n}\n\nconst int SS = 500, TT = 501;\n\nint Deg[M];\n\nvoid addedge(int a, int b, int f, int c) {\n    Go[++Cnt] = b;\n    Next[Cnt] = Head[a];\n    Head[a] = Cnt;\n    Fl[Cnt] = f;\n    Cost[Cnt] = c;\n}\nvoid dealedge(int a, int b, int lw, int hi, int c) {\n    nwans += c * lw;\n    addedge(a, b, hi - lw, c);\n    addedge(b, a, 0, -c);\n    Deg[b] += lw;\n    Deg[a] -= lw;\n}\n\nvoid cmax(int &x, int y) {if(x < y) x = y;}\nvoid cmin(int &x, int y) {if(x > y) x = y;}\n\nsigned main() {\n    scanf(\"%lld\", &n);\n    for(int i = 1; i <= n; i++) {\n        scanf(\"%lld%lld%lld\", &A[i], &B[i], &C[i]);\n    }\n    scanf(\"%lld\", &Q);\n    for(int i = 1; i <= Q; i++) {\n        char ch[3];\n        scanf(\"%s\", ch);\n        op[i] = ch[0];\n        scanf(\"%lld%lld\", &QA[i], &QB[i]);\n    }\n    for(int TTT = 0; TTT <= n; TTT++) {\n        clr(Head), Cnt = 1;\n        dealedge(207, 1, TT, TT, 0);\n        int XXMx[111], XXMn[111], YYMx[111], YYMn[111];\n        memset(XXMx, 0, sizeof XXMx);\n        memset(YYMx, 0, sizeof YYMx);\n        clr(Deg);\n        int flag = 1;\n        for(int i = 1; i <= Q; i++) {\n            int o = op[i];\n            if(o == 'R') {\n                cmax(XXMx[QA[i]], QB[i]);\n            } else if(o == 'L') {\n                if(QB[i] < TTT) flag = 0;\n                cmin(XXMn[QA[i] + 1], TTT - QB[i]);\n            } else if(o == 'D') {\n                cmax(YYMx[QA[i]], QB[i]);\n            } else {\n                if(QB[i] < TTT) flag = 0;\n                cmin(YYMn[QA[i] - 1], TTT - QB[i]);\n            }\n        }\n        if(!flag) continue;\n        for(int i = 0; i <= 100; i++)\n            dealedge(i + 2, i + 3, XXMn[i + 1], XXMx[i + 1], 0);\n        for(int i = 0; i <= 100; i++)\n            dealedge(104 + i, 105 + i, YYMn[i], YYMx[i], 0);\n        dealedge(1, 2, 0, 233333, 0);\n        dealedge(205, 207, 0, 233333, 0);\n        for(int i = 1; i <= n; i++)\n            dealedge(1 + A[i], 104 + B[i], 0, 1, -C[i]);\n        for(int i = 1; i <= 207; i++)\n            if(Deg[i] > 0) {\n                addedge(SS, i, Deg[i], 0);\n                addedge(i, SS, 0, 0);\n            } else if(Deg[i] < 0) {\n                addedge(i, TT, Deg[i], 0);\n                addedge(TT, i, 0, 0);\n            }\n        totans = max(totans, -MMP(SS, TT, TTT) - nwans);\n    }\n    printf(\"%lld\\n\", totans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FOR(i,a,b) for (int i=a;i<=b;++i)\n#define REP(i,n) FOR(i,1,n)\n#define REP_0N(i,n) FOR(i,0,n)\n#define N 1005\n#define M 1005\nusing namespace std;\ntypedef long double ld;\nconst ld eps=0; ld inf=1e18;\nint n,m,id[N],tp[N];\nld a[M][N],T,sum[N][M],A[N],d[N],x[N];\nint B[N];\nchar c[N];\nstruct node {\n    int x,y;\n    long long v;\n}b[N];\ninline void pivot(int r,int c) {\n    swap(id[r+n],id[c]);\n    ld t=-a[r][c];\n    a[r][c]=-1;\n    REP_0N(i,n) a[r][i]/=t;\n    REP_0N(i,m)\n    if (a[i][c]&&r!=i) {\n        t=a[i][c];\n        a[i][c]=0;\n        REP_0N(j,n) a[i][j]+=t*a[r][j];\n    }\n}\ninline void solve() {\n    ld t;\n    REP(i,n) id[i]=i;\n    while (true) {\n        int i=0,j=0; ld w=0;\n        REP(k,m) if (a[k][0]<w) w=a[i=k][0];\n        if (!i) break;\n        REP(k,n) if (a[i][k]>0) {j=k; break;}\n        if (!j) return ;\n        pivot(i,j);\n    }\n    while (true) {\n        int i=0,j=0; ld w=0;\n        REP(k,n) if (a[0][k]>w) w=a[0][j=k];\n        if (!j) break;\n        w=inf;\n        REP(k,m) if (a[k][j]<0&&(t=-a[k][0]/a[k][j])<w) w=t,i=k;\n        if (!i) return ;\n        pivot(i,j);\n    }\n    FOR(i,n+1,n+m) tp[id[i]]=i-n;\n    REP(i,n) x[i]=tp[i]?a[tp[i]][0]:0;\n}\nint main() {\n    scanf(\"%d\",&n);\n    for (int i=1;i<=n;i++) {\n        scanf(\"%d%d%lld\",&b[i].x,&b[i].y,&b[i].v);\n        a[0][i]=b[i].v;\n    }\n    scanf(\"%d\",&m);\n    for (int i=1;i<=m;i++) {\n        scanf(\"%s\",c);\n        int x,y;\n        scanf(\"%d%d\",&x,&y);\n        a[i][0]=y;\n        if (c[0]=='L') {\n            for (int j=1;j<=n;j++) if (b[j].x<=x) a[i][j]=-1;\n        }\n        else if (c[0]=='R') {\n            for (int j=1;j<=n;j++) if (b[j].x>=x) a[i][j]=-1;\n        }\n        else if (c[0]=='D') {\n            for (int j=1;j<=n;j++) if (b[j].y<=x) a[i][j]=-1;\n        }\n        else if (c[0]=='U') {\n            for (int j=1;j<=n;j++) if (b[j].y>=x) a[i][j]=-1;\n        }\n    }\n    for (int i=1;i<=n;i++) {\n        a[++m][0]=1;\n        a[m][i]=-1;\n    }\n    solve();\n    ld ans=0;\n    for (int i=1;i<=n;i++) ans+=b[i].v*x[i];\n    printf(\"%lld\\n\",(long long)(ans+eps));\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n\n#define fo(i,j,l) for(int i=j;i<=l;++i)\n#define fd(i,j,l) for(int i=j;i>=l;--i)\n#define eps 3e-1\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double db;\nconst ll N=1000;\nconst db sj=5e-20,op=1e8;\n\nint f1[N],f2[N];\nint s1[N],s2[N];\nint w[N];\nll x[N],y[N],v[N];\n\nint n,m,oo,a,b,o2;\ndb c[N],s[N][N];\nint bh[N];\ndb d[N];\nint dl[N];\nint g,gs;\ndb ans=0;\nll da=0;\n\ninline db iabs(db gg)\n{return (gg<0)?(-gg):gg;}\n\ninline void trans(int h,int k)\n{\n\tint u=bh[h]; bh[h]=k;\n\tdb xs=-s[h][k];\n\ts[h][k]=0; s[h][u]=-1;\n\tfo(i,1,g)s[h][i]=s[h][i]/xs;\n\tc[h]=c[h]/xs;\n\tfo(i,1,gs)if(i!=h&&s[i][k]!=0&&iabs(s[i][k])>sj){\n\t\tfo(l,1,g)s[i][l]=s[i][l]+s[i][k]*s[h][l];\n\t\tc[i]=c[i]+c[h]*s[i][k];\n\t\ts[i][k]=0;\n\t}\n\tfo(i,1,g)d[i]=d[i]+d[k]*s[h][i];\n\tans=ans+d[k]*c[h];\n\td[k]=0;\n}\n\ninline int find()\n{\n\tint po=0; d[0]=sj;\n\tfo(i,1,g)if(d[i]>d[po])po=i;\n\treturn po;\n}\n\ninline void Simplex()\n{\n\tint x;\n\twhile((x=find())!=0){\n\t\tdouble zd=(db)1e18;\n\t\tint po=0;\n\t\tfo(i,1,gs)if(s[i][x]<-sj)if(c[i]/(-s[i][x])<zd)zd=c[i]/(-s[i][x]),po=i;\n\t\tif(!po)break;\n\t\ttrans(po,x);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfo(i,1,n){\n\t\tscanf(\"%lld%lld%lld\",&x[i],&y[i],&v[i]);\n\t}\n\tfo(i,1,n)d[i]=v[i]/op;\n\tscanf(\"%d\",&gs); m=gs;\n\tfo(i,1,m){\n\t\tchar ch=' ';\n\t\tfor(;ch!='L'&&ch!='R'&&ch!='U'&&ch!='D';ch=getchar());\n\t\tint aa,bb;\n\t\tscanf(\"%d%d\",&aa,&bb);\n\t\tc[i]=bb;\n\t\tif(ch=='L'){fo(l,1,n)if(x[l]<=aa)s[i][l]=-1;}\n\t\tif(ch=='R'){fo(l,1,n)if(x[l]>=aa)s[i][l]=-1;}\n\t\tif(ch=='D'){fo(l,1,n)if(y[l]<=aa)s[i][l]=-1;}\n\t\tif(ch=='U'){fo(l,1,n)if(y[l]>=aa)s[i][l]=-1;}\t\t\n\t}\n\tfo(i,1,n){\n\t\t++gs; c[gs]=1;\n\t\ts[gs][i]=-1;\n\t}\n\tg=m+n;\n\tSimplex();\n\tll da=(ll)(ans*op+eps);\n\tcout<<da;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#define lop(c,l) for(int c=1;c<=(l);++c)\n#define loop(c,l) for(int c=0;c<(l);++c)\nusing namespace std;\n\n#define int long long\ntemplate<int Vari,int Crat>\nstruct algo_simplex{\n\tdouble matrix[Crat+1][Vari+1],ans[Vari+1];\n\tint id[Crat<<1|1];\n\tint vari,crat;\n\tdouble target;\n\tconst char* cond;\n\tvoid pivot(const int& l,const int& e){\n\t\tswap(id[vari+l],id[e]);\n\t\tdouble t=matrix[l][e];\n\t\tmatrix[l][e]=1;\n\t\tfor(int j=0;j<=vari;j++) matrix[l][j]/=t;\n\t\tfor(int i=0;i<=crat;i++) if(i!=l&&abs(matrix[i][e])>1e-8){\n\t\t\tt=matrix[i][e];\n\t\t\tmatrix[i][e]=0;\n\t\t\tfor(int j=0;j<=vari;j++) matrix[i][j]-=matrix[l][j]*t;\n\t\t}\n\t}\n\tbool init(){\n\t\twhile(1){\n\t\t\tint l=0,e=0;\n\t\t\tfor(int i=1;i<=crat;i++) if(matrix[i][0]<-1e-8&&(!l||(rand()&1))) l=i;\n\t\t\tif(!l) return 1;\n\t\t\tfor(int j=1;j<=vari;j++) if(matrix[l][j]<-1e-8&&(!e||(rand()&1))) e=j;\n\t\t\tif(!e) return 0;\n\t\t\tpivot(l,e);\n\t\t}\n\t}\n\tbool funct(const int& v,const int& c){\n\t\tsrand(new int()-(int*)NULL);\n\t\tvari=v,crat=c;\n\t\tfor(int i=1;i<=vari;i++) id[i]=i;\n\t\tif(!init())\treturn 0;\n\t\twhile(1){\n\t\t\tint l=0,e=0;\n\t\t\tdouble minn=1e15;\n\t\t\tfor(int j=1;j<=vari&&!e;j++) if(matrix[0][j]>1e-8) e=j;\n\t\t\tif(!e) break;\n\t\t\tfor(int i=1;i<=crat;i++) if(matrix[i][e]>1e-8&&matrix[i][0]/matrix[i][e]<minn) minn=matrix[i][0]/matrix[i][e],l=i;\n\t\t\tif(!l) return 0;\n\t\t\tpivot(l,e);\n\t\t}\n\t\ttarget=-matrix[0][0];\n\t\tfor(int i=1;i<=crat;i++) ans[id[vari+i]]=matrix[i][0];\n\t\treturn 1;\n\t}\n};\nalgo_simplex<80,400> spl;\nstruct loc{\n\tint x,y,v;\n}p[81];\nint n,m,ll,lim;\nchar ch;\nsigned main(signed,char**,char**){\n\tscanf(\"%lld\",&n);\n\tlop(i,n){\n\t\tscanf(\"%lld%lld%lld\",&p[i].x,&p[i].y,&p[i].v);\n\t\tspl.matrix[0][i]=p[i].v;\n\t}\n\tscanf(\"%lld\",&m);\n\tlop(i,m){\n\t\tscanf(\" %c%lld%lld\",&ch,&ll,&lim);\n\t\tswitch(ch){\n\t\t\tcase 'L':{\n\t\t\t\tlop(j,n) if(p[j].x<=ll) spl.matrix[i][j]=1;\n\t\t\t\tspl.matrix[i][0]=lim;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'R':{\n\t\t\t\tlop(j,n) if(p[j].x>=ll) spl.matrix[i][j]=1;\n\t\t\t\tspl.matrix[i][0]=lim;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'D':{\n\t\t\t\tlop(j,n) if(p[j].y<=ll) spl.matrix[i][j]=1;\n\t\t\t\tspl.matrix[i][0]=lim;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'U':{\n\t\t\t\tlop(j,n) if(p[j].y>=ll) spl.matrix[i][j]=1;\n\t\t\t\tspl.matrix[i][0]=lim;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tlop(i,n) spl.matrix[m+i][i]=1,spl.matrix[m+i][0]=1;\n\tspl.funct(n,m+n);\n\tprintf(\"%.0lf\",spl.target+1e-8);\n\texit(0);\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 16.03.2019 16:16:57       \n**/\n#undef _GLIBCXX_DEBUG\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring to_string(string s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntypedef long double ld;\n\nconst ld eps = 1e-8;\n\nvector<ld> simplex(vector<vector<ld>> a) {\n  int n = (int) a.size() - 1;\n  int m = (int) a[0].size() - 1;\n  vector<int> left(n + 1);\n  vector<int> up(m + 1);\n  iota(left.begin(), left.end(), m);\n  iota(up.begin(), up.end(), 0);\n  auto pivot = [&](int x, int y) {\n    swap(left[x], up[y]);\n    ld k = a[x][y];\n    a[x][y] = 1;\n    vector<int> pos;\n    for (int j = 0; j <= m; j++) {\n      a[x][j] /= k;\n      if (fabs(a[x][j]) > eps) {\n        pos.push_back(j);\n      }\n    }\n    for (int i = 0; i <= n; i++) {\n      if (fabs(a[i][y]) < eps || i == x) {\n        continue;\n      }\n      k = a[i][y];\n      a[i][y] = 0;\n      for (int j : pos) {\n        a[i][j] -= k * a[x][j];\n      }\n    }\n  };\n  while (1) {\n    int x = -1;\n    for (int i = 1; i <= n; i++) {\n      if (a[i][0] < -eps && (x == -1 || a[i][0] < a[x][0])) {\n        x = i;\n      }\n    }\n    if (x == -1) {\n      break;\n    }\n    int y = -1;\n    for (int j = 1; j <= m; j++) {\n      if (a[x][j] < -eps && (y == -1 || a[x][j] < a[x][y])) {\n        y = j;\n      }\n    }\n    if (y == -1) {\n      return vector<ld>(); // infeasible\n    }\n    pivot(x, y);\n  }\n  while (1) {\n    int y = -1;\n    for (int j = 1; j <= m; j++) {\n      if (a[0][j] > eps && (y == -1 || a[0][j] > a[0][y])) {\n        y = j;\n      }\n    }\n    if (y == -1) {\n      break;\n    }\n    int x = -1;\n    for (int i = 1; i <= n; i++) {\n      if (a[i][y] > eps && (x == -1 || a[i][0] / a[i][y] < a[x][0] / a[x][y])) {\n        x = i;\n      }\n    }\n    if (x == -1) {\n      return vector<ld>(); // unbounded\n    }\n    pivot(x, y);\n  }\n  vector<ld> ans(m + 1);\n  for (int i = 1; i <= n; i++) {\n    if (left[i] <= m) {\n      ans[left[i]] = a[i][0];\n    }\n  }\n  ans[0] = -a[0][0];\n  return ans;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<int> x(n), y(n);\n  vector<long long> z(n);\n  for (int i = 0; i < n; i++) {\n    cin >> x[i] >> y[i] >> z[i];\n  }\n  vector<vector<ld>> mat;\n  {\n    vector<ld> row(n + 1);\n    for (int i = 0; i < n; i++) {\n      row[i + 1] = z[i];\n    }\n    mat.push_back(row);\n  }\n  {\n    for (int i = 0; i < n; i++) {\n      vector<ld> row(n + 1);\n      row[0] = 1;\n      row[i + 1] = 1;\n      mat.push_back(row);\n    }\n  }\n  int tt;\n  cin >> tt;\n  for (int qq = 0; qq < tt; qq++) {\n    string foo;\n    int bar, baz;\n    cin >> foo >> bar >> baz;\n    vector<ld> row(n + 1);\n    row[0] = baz;\n    if (foo == \"L\") {\n      for (int i = 0; i < n; i++) if (x[i] <= bar) row[i + 1] = 1;\n    }\n    if (foo == \"R\") {\n      for (int i = 0; i < n; i++) if (x[i] >= bar) row[i + 1] = 1;\n    }\n    if (foo == \"D\") {\n      for (int i = 0; i < n; i++) if (y[i] <= bar) row[i + 1] = 1;\n    }\n    if (foo == \"U\") {\n      for (int i = 0; i < n; i++) if (y[i] >= bar) row[i + 1] = 1;\n    }\n    mat.push_back(row);\n  }\n  vector<ld> ret = simplex(mat);\n  debug(ret[0]);\n  vector<int> bads;\n  mt19937 rng((unsigned int) chrono::steady_clock::now().time_since_epoch().count());\n  for (int i = 0; i < n; i++) {\n    if (ret[i + 1] > eps && ret[i + 1] < 1 - eps) {\n      bads.push_back(i);\n    }\n  }\n  debug(bads);\n  bads.resize(min((int) bads.size(), 12));\n  long long ans = 0;\n  loop:\n  int sz = (int) bads.size();\n  for (int t = 0; t < (1 << sz); t++) {\n    for (int i = 0; i < sz; i++) {\n      if (t & (1 << i)) {\n        mat[bads[i] + 1][0] = 1;\n        vector<ld> row(n + 1);\n        row[0] = -1;\n        row[bads[i] + 1] = -1;\n        mat.push_back(row);\n      } else {\n        mat[bads[i] + 1][0] = 0;\n      }\n    }\n    vector<ld> ret2 = simplex(mat);\n    if (!ret2.empty()) {\n      long long val = 0;\n      int ctr = 0;\n      for (int i = 0; i < n; i++) {\n        if (ret2[i + 1] > eps && ret2[i + 1] < 1 - eps) {\n          if (bads.size() < 12) {\n            bads.push_back(i);\n            debug(\"oh no goto\");\n            goto loop;\n          }\n        }\n        val += z[i] * (ret2[i + 1] > 1 - eps);\n      }\n      debug(val, ctr);\n      ans = max(ans, val);\n    }\n    mat.resize(n + tt + 1);\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\n  _|_|                              _|  _|    _|\n_|    _|  _|  _|_|  _|_|_|_|        _|  _|  _|\n_|    _|  _|_|          _|          _|  _|_|\n_|    _|  _|          _|      _|    _|  _|  _|\n  _|_|    _|        _|_|_|_|    _|_|    _|    _|\n\n*/\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<set>\n//#define ls (rt<<1)\n//#define rs (rt<<1|1)\n#define vi vector<int>\n#define pb push_back\n#define mk make_pair\n#define pii pair<ll,ll>\n#define rep(i,a,b) for(int i=(a),i##end=(b);i<=i##end;i++)\n#define fi first\n#define se second\n#define int long long\ntypedef long long ll;\nusing namespace std;\nconst int maxn=420;\nconst int inf=1e18+100;\nint xl[maxn],xr[maxn],yl[maxn],yr[maxn],s=415,t=416;\nint head[maxn],cnt=1;\nstruct gg{\n    int u,v,w;ll cost;int next;\n    void insert(int U,int V,int W,ll Cost,int Next){\n        u=U,v=V,w=W,cost=Cost,next=Next;\n    }\n}side[maxn*maxn*2*4];\nstruct Point{\n    int x,y;\n    ll cost=0;\n}point[maxn];\nstruct Lim{\n    int a,b;char c;\n}lim[maxn];\nvoid ins(int u,int v,int w,ll cost){\n    side[++cnt].insert(u,v,w,cost,head[u]);head[u]=cnt;\n    side[++cnt].insert(v,u,0,-cost,head[v]);head[v]=cnt;\n}\nint n,m;\nvoid init(int k){\n   rep(i,1,k)xl[i]=yl[i]=-inf,xr[i]=yr[i]=inf;\n   rep(i,1,m){\n       if(lim[i].c=='L')rep(j,lim[i].b+1,k)xl[j]=max(xl[j],lim[i].a+1);\n       else if(lim[i].c=='R')for(int j=k-lim[i].b;j>0;j--)xr[j]=min(xr[j],lim[i].a-1);\n       else if(lim[i].c=='D')rep(j,lim[i].b+1,k)yl[j]=max(yl[j],lim[i].a+1);\n       else if(lim[i].c=='U')for(int j=k-lim[i].b;j>0;j--)yr[j]=min(yr[j],lim[i].a-1);\n   }\n   memset(head,0,sizeof(head));cnt=1;\n   rep(i,1,k)ins(s,2*n+i,1,0);\n   rep(i,1,k)ins(2*n+k+i,t,1,0);\n   rep(i,1,n){\n        ins(i,n+i,1,point[i].cost);\n        rep(j,1,k){\n            if(xl[j]<=point[i].x&&point[i].x<=xr[j])ins(2*n+j,i,1,0);\n            if(yl[j]<=point[i].y&&point[i].y<=yr[j])ins(n+i,2*n+k+j,1,0);\n        }\n   }\n}\nint rk[maxn],q[maxn];\nll dis[maxn],lenth;\nbool vis[maxn];\nbool spfa(){\n    rep(i,1,maxn-1)dis[i]=-inf;\n    memset(vis,0,sizeof(vis));\n    int hd=1,tl=1;q[hd]=s;vis[s]=1;dis[s]=0;\n    while(hd<=tl){\n        int u=q[hd++];vis[u]=0;//cout<<u<<' '<<endl;\n        for(int i=head[u];i;i=side[i].next){\n            int v=side[i].v;if(!side[i].w)continue;\n            if(dis[u]+side[i].cost>dis[v]){\n                dis[v]=dis[u]+side[i].cost;\n                if(!vis[v])q[++tl]=v;\n                vis[v]=1;\n            }\n        }\n    }\n    if(dis[t]!=-inf)return 1;\n    return 0;\n}\nint dfs(int u,int flow){\n    if(u==t)return flow;\n    vis[u]=1;int tot=0;\n    for(int i=head[u];i;i=side[i].next){\n        int v=side[i].v;if(vis[v]||!side[i].w||dis[v]!=dis[u]+side[i].cost)continue;\n        int sent=dfs(v,min(flow,side[i].w));\n        lenth+=1ll*side[i].cost*sent,side[i].w-=sent,side[i^1].w+=sent,tot+=sent;flow-=sent;\n    }\n   // vis[u]=0;\n    return tot;\n}\npii dinic(){\n    int mxflow=0;lenth=0;\n    while(spfa()){\n        int x;\n        while((x=dfs(s,inf)))mxflow+=x;\n    }\n    return mk(mxflow,lenth);\n}\nchar tmp[3];\nsigned main(){\n    scanf(\"%lld\",&n);\n    rep(i,1,n)scanf(\"%lld%lld%lld\",&point[i].x,&point[i].y,&point[i].cost);\n    scanf(\"%lld\",&m);\n    rep(i,1,m){\n        scanf(\"%s%lld%lld\",tmp+1,&lim[i].a,&lim[i].b);lim[i].c=tmp[1];\n    }\n    ll out=0;\n    rep(k,1,n){\n        init(k);\n        pii ans=dinic();out=max(out,ans.se);//cout<<ans.se<<endl;\n    }\n    cout<<out;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n\nusing namespace std;\nconst int N=105,NN=N<<1,M=N*N;\nconst LL inf=1ll<<55;\nLL rd()\n{\n    LL x=0,w=1;char ch=0;\n    while(ch<'0'||ch>'9'){if(ch=='-') w=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+(ch^48);ch=getchar();}\n    return x*w;\n}\nstruct node\n{\n\tLL x,y;\n\tnode(LL nx=0,LL ny=0){x=nx,y=ny;}\n\tbool operator < (const node &bb) const {return x!=bb.x?x<bb.x:y<bb.y;}\n\tnode operator + (const node &bb) const {return (node){x+bb.x,y+bb.y};}\n}w[M],di[NN];\nint to[M],nt[M],c[M],hd[NN],tot=1,ps,pt,fw[NN],pr[NN],v[NN];\nLL s1,s2,ans;\nvoid adde(int x,int y,int z,LL z1,LL z2)\n{\n\t++tot,to[tot]=y,nt[tot]=hd[x],c[tot]=z,w[tot]=(node){+z1,+z2},hd[x]=tot;\n\t++tot,to[tot]=x,nt[tot]=hd[y],c[tot]=0,w[tot]=(node){-z1,-z2},hd[y]=tot;\n\ts1-=z*z1;\n}\nvoid csfl()\n{\n\tqueue<int> q;\n\twhile(1)\n\t{\n\t\tfor(int i=1;i<=pt;++i) di[i]=(node){-inf,-inf};\n\t\tdi[ps]=(node){0,0},fw[ps]=1<<30,v[ps]=1,q.push(ps);\n\t\tfw[pt]=0;\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tint x=q.front();\n\t\t\tq.pop();\n\t\t\tfor(int i=hd[x];i;i=nt[i])\n\t\t\t{\n\t\t\t\tint y=to[i];\n\t\t\t\tif(c[i]>0&&di[y]<di[x]+w[i])\n\t\t\t\t{\n\t\t\t\t\tdi[y]=di[x]+w[i];\n\t\t\t\t\tpr[y]=i,fw[y]=min(fw[x],c[i]);\n\t\t\t\t\tif(!v[y]) v[y]=1,q.push(y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tv[x]=0;\n\t\t}\n\t\tif(!fw[pt]) return;\n\t\ts1+=di[pt].x*fw[pt],s2+=di[pt].y*fw[pt];\n\t\tint x=pt;\n\t\twhile(x!=ps)\n\t\t{\n\t\t\tint i=pr[x];\n\t\t\tc[i]-=fw[pt],c[i^1]+=fw[pt];\n\t\t\tx=to[i^1];\n\t\t}\n\t}\n}\nint n,m,t=100;\nchar cc[2];\nLL a[N][3],b[N<<2][3],px[N][2],py[N][2];\nmap<char,int> id;\n\nint main()\n{\n\tid['L']=0,id['R']=1,id['D']=2,id['U']=3;\n\tn=rd();\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=0;j<=2;++j)\n\t\t\ta[i][j]=rd();\n\tm=rd();\n\tfor(int i=1;i<=m;++i)\n\t{\n\t\tscanf(\"%s\",cc),b[i][0]=id[cc[0]];\n\t\tb[i][1]=rd(),b[i][2]=rd();\n\t}\n\tps=0,pt=203;\n\tint yyb=201,zsy=202;\n\tfor(int h=1;h<=n;++h)\n\t{\n\t\tmemset(hd,0,sizeof(int)*(pt+1)),tot=1,s1=s2=0;\n\t\tfor(int i=1;i<=t;++i) px[i][0]=0,px[i][1]=1<<30;\n\t\tfor(int i=1;i<=t;++i) py[i][0]=0,py[i][1]=1<<30;\n\t\tfor(int i=1;i<=m;++i)\n\t\t{\n\t\t\tif(b[i][0]==0) px[b[i][1]][1]=min(px[b[i][1]][1],b[i][2]);\n\t\t\tif(b[i][0]==1) px[b[i][1]-1][0]=max(px[b[i][1]-1][0],h-b[i][2]);\n\t\t\tif(b[i][0]==2) py[b[i][1]][1]=min(py[b[i][1]][1],b[i][2]);\n\t\t\tif(b[i][0]==3) py[b[i][1]-1][0]=max(py[b[i][1]-1][0],h-b[i][2]);\n\t\t}\n\t\tadde(ps,yyb,h,1,0);\n\t\tbool o=1;\n\t\tint np=yyb;\n\t\tfor(int i=t;i;--i)\n\t\t{\n\t\t\tif(px[i][0]>px[i][1]){o=0;break;}\n\t\t\tadde(np,i,px[i][0],1,0),adde(np,i,px[i][1]-px[i][0],0,0);\n\t\t\tnp=i;\n\t\t}\n\t\tnp=zsy;\n\t\tfor(int i=t;i;--i)\n\t\t{\n\t\t\tif(py[i][0]>py[i][1]){o=0;break;}\n\t\t\tadde(i+t,np,py[i][0],1,0),adde(i+t,np,py[i][1]-py[i][0],0,0);\n\t\t\tnp=i+t;\n\t\t}\n\t\tadde(zsy,pt,h,1,0);\n\t\tif(!o) continue;\n\t\tfor(int i=1;i<=n;++i) adde(a[i][0],a[i][1]+t,1,0,a[i][2]);\n\t\tcsfl();\n\t\tif(s1>=0) ans=max(ans,s2);\n\t}\n\tprintf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n#define MAXN 100\n#define MAXM 500\n#define LL long long\nconst double eps=1e-10;\ndouble a[MAXM][MAXN];\nint n,m;\nvoid pivot(int r,int c)\n{\n\tdouble tmp=-a[r][c];\n\ta[r][c]=-1;\n\tfor(int i=0;i<=n;i++) a[r][i]/=tmp;\n\tfor(int i=0;i<=m;i++)\n\t\tif(a[i][c]&&i!=r)\n\t\t{\n\t\t\ttmp=a[i][c];a[i][c]=0;\n\t\t\tfor(int j=0;j<=n;j++)\n\t\t\t\ta[i][j]+=tmp*a[r][j];\n\t\t}\n}\nvoid Solve()\n{\n\twhile(1)\n\t{\n\t\tdouble tmp=eps;\n\t\tint i=0,j=0;\n\t\tfor(int k=1;k<=n;k++) if(a[0][k]>tmp) tmp=a[0][j=k];\n\t\tif(!j) break;\n\t\ttmp=1e17;\n\t\tfor(int k=1;k<=m;k++) if(a[k][j]<-eps&&-a[k][0]/a[k][j]<tmp)\n\t\t{\n\t\t\ttmp=-a[k][0]/a[k][j];\n\t\t\ti=k;\n\t\t}\n\t\tpivot(i,j);\n\t}\n\tprintf(\"%.0lf\\n\",floor(a[0][0]));\n}\nint N,M,x[MAXN],y[MAXN],A;\nchar s[5];\nint main()\n{\n\tscanf(\"%d\",&N);\n\tfor(int i=1;i<=N;i++)\n\t\tscanf(\"%d%d%lf\",&x[i],&y[i],&a[0][i]);\n\tscanf(\"%d\",&M);\n\tfor(int i=1;i<=M;i++)\n\t{\n\t\tscanf(\"%s%d%lf\",s,&A,&a[i][0]);\n\t\tif(s[0]=='L')\n\t\t{\n\t\t\tfor(int j=1;j<=N;j++)\n\t\t\t\tif(x[j]<=A) a[i][j]=-1;\n\t\t}\n\t\telse if(s[0]=='R')\n\t\t{\n\t\t\tfor(int j=1;j<=N;j++)\n\t\t\t\tif(x[j]>=A) a[i][j]=-1;\n\t\t}\n\t\telse if(s[0]=='D')\n\t\t{\n\t\t\tfor(int j=1;j<=N;j++)\n\t\t\t\tif(y[j]<=A) a[i][j]=-1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(int j=1;j<=N;j++)\n\t\t\t\tif(y[j]>=A) a[i][j]=-1;\n\t\t}\n\t}\n\tfor(int i=1;i<=N;i++)\n\t\ta[i+M][0]=1,a[i+M][i]=-1;\n\tn=N;m=M+N;\n\tSolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\ntemplate< typename T >\nstruct RadixHeap\n{\n  using uint = long long;\n  vector< pair< uint, T > > v[65];\n  uint size, last;\n\n  RadixHeap() : size(0), last(0) {}\n\n  bool empty() const { return size == 0; }\n\n  inline Int getbit(Int a)\n  {\n    return a ? 64 - __builtin_clzll(a) : 0;\n  }\n\n  void emplace(uint key, const T &value)\n  {\n    ++size;\n    v[getbit(key ^ last)].emplace_back(key, value);\n  }\n\n  pair< uint, T > pop()\n  {\n    if(v[0].empty()) {\n      Int idx = 1;\n      while(v[idx].empty()) ++idx;\n      last = min_element(begin(v[idx]), end(v[idx]))->first;\n      for(auto &p : v[idx]) v[getbit(p.first ^ last)].emplace_back(p);\n      v[idx].clear();\n    }\n    --size;\n    auto ret = v[0].back();\n    v[0].pop_back();\n    return ret;\n  }\n};\n\ntemplate<typename T>\nstruct PrimalDual{\n  struct edge{\n    Int to;\n    T cap,cost;\n    Int rev;\n    edge(){}\n    edge(Int to,T cap,T cost,Int rev):to(to),cap(cap),cost(cost),rev(rev){}\n  };\n  \n  T INF;\n  vector<vector<edge> > G;\n  vector<T> h,dist;\n  vector<Int> prevv,preve;\n\n  PrimalDual(){}\n  PrimalDual(Int n,T INF):INF(INF),G(n),h(n),dist(n),prevv(n),preve(n){}\n  \n  void add_edge(Int from,Int to,T cap,T cost){\n    G[from].emplace_back(to,cap,cost,G[to].size());\n    G[to].emplace_back(from,0,-cost,G[from].size()-1);\n  }\n\n  T flow(Int s,Int t,T f,Int &ok){    \n    T res=0;\n    fill(h.begin(),h.end(),0);\n    while(f>0){\n      RadixHeap<T> que;\n      fill(dist.begin(),dist.end(),INF);\n      \n      dist[s]=0;\n      que.emplace(dist[s],s);\n      while(!que.empty()){\n        auto p=que.pop();\n        Int v=p.second;\n        if(dist[v]<p.first) continue;\n        for(Int i=0;i<(Int)G[v].size();i++){\n          edge &e=G[v][i];\n          if(e.cap==0) continue;\n          if(dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n            dist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n            prevv[e.to]=v;\n            preve[e.to]=i;\n            que.emplace(dist[e.to],e.to);\n          }\n        }\n      }\n      if(dist[t]==INF) return ok=0;\n      \n      for(Int v=0;v<(Int)h.size();v++) h[v]+=dist[v];\n\n      T d=f;\n      for(Int v=t;v!=s;v=prevv[v])\n        d=min(d,G[prevv[v]][preve[v]].cap);\n      \n      f-=d;\n      res+=d*h[t];\n      for(Int v=t;v!=s;v=prevv[v]){\n        edge &e=G[prevv[v]][preve[v]];\n        e.cap-=d;\n        G[v][e.rev].cap+=d;\n      }\n    }\n    ok=1;\n    return res;\n  }\n};\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<Int> xs(n),ys(n),vs(n);\n  for(Int i=0;i<n;i++) cin>>xs[i]>>ys[i]>>vs[i];\n\n  Int m;\n  cin>>m;\n  vector<char> ts(m);\n  vector<Int> as(m),bs(m);\n  for(Int i=0;i<m;i++) cin>>ts[i]>>as[i]>>bs[i];\n\n  const Int INF = 1e16;\n  vector<Int> ls(n,-INF),rs(n,INF),ds(n,-INF),us(n,INF);\n  for(Int i=0;i<m;i++){\n    if(ts[i]=='L') chmax(ls[bs[i]],as[i]);\n    if(ts[i]=='R') chmin(rs[bs[i]],as[i]);\n    if(ts[i]=='D') chmax(ds[bs[i]],as[i]);\n    if(ts[i]=='U') chmin(us[bs[i]],as[i]);\n  }\n  for(Int i=0;i+1<n;i++){\n    chmax(ls[i+1],ls[i]);\n    chmin(rs[i+1],rs[i]);\n    chmax(ds[i+1],ds[i]);\n    chmin(us[i+1],us[i]);\n  }\n  \n  Int ans=0;\n  for(Int k=1;k<=n;k++){\n    PrimalDual<Int> G(k*2+n*2+2,INF);\n    Int S=k*2+n*2,T=k*2+n*2+1;\n    for(Int i=0;i<k;i++){\n      G.add_edge(S,i,1,0);\n      G.add_edge(k+i,T,1,0);\n    }    \n    \n    for(Int p=0;p<n;p++){\n      G.add_edge(k*2+p,k*2+n+p,1,INF-vs[p]);      \n      for(Int i=0;i<k;i++){\n        for(Int j=0;j<k;j++){\n          if(xs[p]<=ls[i]) continue;\n          if(xs[p]>=rs[k-(i+1)]) continue;\n          if(ys[p]<=ds[j]) continue;\n          if(ys[p]>=us[k-(j+1)]) continue;          \n          G.add_edge(i,k*2+p,1,0);     \n          G.add_edge(k*2+n+p,k+j,1,0);\n        }\n      }\n    }\n    \n    Int ok=1;\n    Int res=G.flow(S,T,k,ok);    \n    if(!ok) break;\n    chmax(ans,INF*k-res);\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FOR(i,a,b) for (int i=a;i<=b;++i)\n#define REP(i,n) FOR(i,1,n)\n#define REP_0N(i,n) FOR(i,0,n)\n#define N 1005\n#define M 1005\nusing namespace std;\ntypedef __float128 ld;\nconst ld eps=1e-8; ld inf=1e18;\nint n,m,id[N],tp[N];\nld a[M][N],T,sum[N][M],A[N],d[N],x[N];\nint B[N];\nchar c[N];\nstruct node {\n    int x,y;\n    long long v;\n}b[N];inline void pivot(int r,int c) {\n    swap(id[r+n],id[c]);\n    ld t=-a[r][c];\n    a[r][c]=-1;\n    REP_0N(i,n) a[r][i]/=t;\n    REP_0N(i,m)\n    if (a[i][c]&&r!=i) {\n        t=a[i][c];\n        a[i][c]=0;\n        REP_0N(j,n) a[i][j]+=t*a[r][j];\n    }\n}\nvoid solve() {\n    ld t;\n    REP(i,n) id[i]=i;\n    while (true) {\n        int i=0,j=0; ld w=-eps;\n        REP(k,m) if (a[k][0]<w) w=a[i=k][0];\n        if (!i) break;\n        REP(k,n) if (a[i][k]>eps) {j=k; break;}\n        if (!j) return ;\n        pivot(i,j);\n    }\n    while (true) {\n        int i=0,j=0; ld w=eps;\n        REP(k,n) if (a[0][k]>w) w=a[0][j=k];\n        if (!j) break;\n        w=inf;\n        REP(k,m) if (a[k][j]<-eps&&(t=-a[k][0]/a[k][j])<w) w=t,i=k;\n        if (!i) return ;\n        pivot(i,j);\n    }\n    FOR(i,n+1,n+m) tp[id[i]]=i-n;\n    REP(i,n) x[i]=tp[i]?a[tp[i]][0]:0;\n    return ;\n}\nint main() {\n    scanf(\"%d\",&n);\n    for (int i=1;i<=n;i++) {\n        scanf(\"%d%d%lld\",&b[i].x,&b[i].y,&b[i].v);\n        a[0][i]=b[i].v;\n    }\n    scanf(\"%d\",&m);\n    for (int i=1;i<=m;i++) {\n        scanf(\"%s\",c);\n        int x,y;\n        scanf(\"%d%d\",&x,&y);\n        a[i][0]=y;\n        if (c[0]=='L') {\n            for (int j=1;j<=n;j++) if (b[j].x<=x) a[i][j]=-1;\n        }\n        else if (c[0]=='R') {\n            for (int j=1;j<=n;j++) if (b[j].x>=x) a[i][j]=-1;\n        }\n        else if (c[0]=='D') {\n            for (int j=1;j<=n;j++) if (b[j].y<=x) a[i][j]=-1;\n        }\n        else if (c[0]=='U') {\n            for (int j=1;j<=n;j++) if (b[j].y>=x) a[i][j]=-1;\n        }\n    }\n    for (int i=1;i<=n;i++) {\n        a[++m][0]=1;\n        a[m][i]=-1;\n    }\n    solve();\n    ld ans=0;\n    for (int i=1;i<=n;i++) ans+=b[i].v*x[i];\n    printf(\"%lld\\n\",(long long)(ans+0.5));\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst LL INF = 0x3f3f3f3f3f3f3f;\n\nnamespace flow\n{\n\tconst int MAXN = 400;\n\tstruct edge\n\t{\n\t\tint to, cap;\n\t\tLL cost;\n\t};\n\tint n, m;\n\tedge ed[2005];\n\tvector<int> G[405];\n\t\n\tvoid clear()\n\t{\n\t\tm = 0;\n\t\trep(i, n) G[i].clear();\n\t}\n\t\n\tvoid add_edge(int u, int v, int fl, LL co)\n\t{\n\t\ted[m].to = v; ed[m].cap = fl; ed[m].cost = co; G[u].push_back(m); m ++;\n\t\ted[m].to = u; ed[m].cap = 0; ed[m].cost = -co; G[v].push_back(m); m ++;\n\t}\n\t\n\tLL h[405];\n\tLL pat[405];\n\tint prev[405];\n\tbool vis[405];\n\t\n\tbool dijk(int s, int t)\n\t{\n\t\trep(i, n) {\n\t\t\tpat[i] = INF;\n\t\t\tvis[i] = false;\n\t\t}\n\t\tpat[s] = 0;\n\t\tpriority_queue<pair<LL, int> > que;\n\t\tque.push(MP(0, s));\n\t\t\n\t\twhile(!que.empty()) {\n\t\t\tint cur = que.top().second;\n\t\t\tque.pop();\n\t\t\tif(vis[cur]) continue;\n\t\t\tvis[cur] = true;\n\t\t\trep(i, G[cur].size()) {\n\t\t\t\tint ce = G[cur][i];\n\t\t\t\tif(ed[ce].cap == 0) continue;\n\t\t\t\tif(pat[ed[ce].to] > pat[cur] + ed[ce].cost) {\n\t\t\t\t\tpat[ed[ce].to] = pat[cur] + ed[ce].cost;\n\t\t\t\t\tprev[ed[ce].to] = ce;\n\t\t\t\t\tque.push(MP(-pat[ed[ce].to], ed[ce].to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn pat[t] != INF;\n\t}\n\t\n\tLL mcf(int s, int t, int mf)\n\t{\n\t\trep(i, n) h[i] = 0;\n\t\tLL ans = 0;\n\t\twhile(dijk(s, t)) {\n\t\t\t//in this occasion flow must be 1\n\t\t\tint cur = t, cf = 1;\n\t\t\twhile(cur != s) {\n\t\t\t\ted[prev[cur]].cap -= cf;\n\t\t\t\ted[prev[cur] ^ 1].cap += cf;\n\t\t\t\tcur = ed[prev[cur] ^ 1].to;\n\t\t\t}\n\t\t\trep(i, m) ed[i].cost += pat[ed[i ^ 1].to] - pat[ed[i].to];\n\t\t\trep(i, m) h[i] += pat[i];\n\t\t\tans += h[t] * cf;\n\t\t\tmf --;\n\t\t\tif(mf == 0) return ans;\n\t\t}\n\t\treturn -1;\n\t}\n}\n\nint n, x[85], y[85];\nLL v[85];\nint m, a[325], b[325];\nchar t[325];\nLL ans;\n\nint minx[85], maxx[85], miny[85], maxy[85];\nLL solve(int tot)\n{\n\trep(i, n) {\n\t\tminx[i] = miny[i] = -INF;\n\t\tmaxx[i] = maxy[i] = INF;\n\t}\n\t\n\trep(i, m) if(b[i] < tot) {\n\t\tif(t[i] == 'L') minx[b[i]] = max(minx[b[i]], a[i] + 1);\n\t\telse if(t[i] == 'R') maxx[tot - b[i] - 1] = min(maxx[tot - b[i] - 1], a[i] - 1);\n\t\telse if(t[i] == 'D') miny[b[i]] = max(miny[b[i]], a[i] + 1);\n\t\telse if(t[i] == 'U') maxy[tot - b[i] - 1] = min(maxy[tot - b[i] - 1], a[i] - 1);\n\t}\n\trep(i, tot - 1) {\n\t\tminx[i + 1] = max(minx[i], minx[i + 1]);\n\t\tminy[i + 1] = max(miny[i], miny[i + 1]);\n\t}\n\tfor(int i = tot - 1; i > 0; i --) {\n\t\tmaxx[i - 1] = min(maxx[i - 1], maxx[i]);\n\t\tmaxy[i - 1] = min(maxy[i - 1], maxy[i]);\n\t}\n\t\n\tflow::n = 2 + tot * 2 + n * 2;\n\tflow::clear();\n\trep(i, tot) flow::add_edge(tot * 2 + n * 2, i, 1, 0);\n\trep(i, tot) rep(j, n) if(x[j] >= minx[i] && x[j] <= maxx[i])\n\tflow::add_edge(i, j + tot * 2, 1, 0);\n\trep(i, n) flow::add_edge(i + tot * 2, i + tot * 2 + n, 1, INF - v[i]);\n\trep(i, tot) rep(j, n) if(y[j] >= miny[i] && y[j] <= maxy[i])\n\tflow::add_edge(j + tot * 2 + n, i + tot, 1, 0);\n\trep(i, tot) flow::add_edge(i + tot, tot * 2 + n * 2 + 1, 1, 0);\n\t\n\tLL ret = flow::mcf(flow::n - 2, flow::n - 1, tot);\n\t\n\treturn ret == -1 ? -1 : INF * tot - ret;\n}\n\nint main()\n{\n\tcin >> n;\n\trep(i, n) cin >> x[i] >> y[i] >> v[i];\n\tcin >> m;\n\trep(i, m) cin >> t[i] >> a[i] >> b[i];\n\tfor(int t = 0; t <= n; t ++)\n\tans = max(ans, solve(t));\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cctype>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing i64=long long;\nconst int V=327,E=26087;const i64 inf=1e18;\nint n,m,s,t,tot,head[V],vis[V];i64 cost,dis[V];\nstruct edge{int v,f;i64 c;int next;}e[E];\nstruct node{int x,y;i64 v;}p[V];\nstruct opt{int o,a,b;}op[V];\nint read(){int x=0;int c=getchar();while(isspace(c))c=getchar();while(isdigit(c))(x*=10)+=c&15,c=getchar();return x;}\ni64 raed(){i64 x=0;int c=getchar();while(isspace(c))c=getchar();while(isdigit(c))(x*=10)+=c&15,c=getchar();return x;}\nvoid add(int u,int v,int f,i64 c){e[++tot]={v,f,c,head[u]},head[u]=tot,e[++tot]={u,0,-c,head[v]},head[v]=tot;}\nint update()\n{\n    i64 mn=inf;\n    for(int u=1;u<=t;++u) if(vis[u]) for(int i=head[u];i;i=e[i].next) if(!vis[e[i].v]&&e[i].f) mn=std::min(mn,dis[e[i].v]+e[i].c-dis[u]);\n    if(mn==inf) return 0;\n    for(int u=1;u<=t;++u) if(vis[u]) dis[u]+=mn;\n    return 1;\n}\nint dfs(int u,int res)\n{\n    if(u==t) return cost-=dis[s]*res,res;\n    int use=0;vis[u]=1;\n    for(int i=head[u],t;i;i=e[i].next)\n\tif(!vis[e[i].v]&&e[i].f&&dis[u]==dis[e[i].v]+e[i].c)\n\t{\n\t    t=dfs(e[i].v,std::min(res-use,e[i].f)),use+=t,e[i].f-=t,e[i^1].f+=t;\n\t    if(use==res) return use;\n\t}\n    return use;\n}\nvoid solve(int k)\n{\n    static int lx[V],rx[V],ly[V],ry[V];\n    tot=1,cost=0,s=2*k+2*n+1,t=s+1,memset(head+1,0,t<<2),memset(dis+1,0,t<<3);\n    memset(lx+1,0,k<<2),memset(ly+1,0,k<<2),memset(rx+1,0x7f,k<<2),memset(ry+1,0x7f,k<<2);\n    for(int i=1;i<=k;++i) add(s,i,1,0),add(i+n+n+k,t,1,0);\n    for(int i=1;i<=n;++i) add(i+k,i+n+k,1,-p[i].v);\n    for(int i=1;i<=m;++i)\n\tswitch(op[i].o)\n\t{\n\tcase'U':for(int j=1;j<=k-op[i].b;++j)ry[j]=std::min(ry[j],op[i].a-1);break;\n\tcase'D':for(int j=op[i].b+1;j<=k;++j)ly[j]=std::max(ly[j],op[i].a+1);break;\n\tcase'L':for(int j=op[i].b+1;j<=k;++j)lx[j]=std::max(lx[j],op[i].a+1);break;\n\tcase'R':for(int j=1;j<=k-op[i].b;++j)rx[j]=std::min(rx[j],op[i].a-1);break;\n\t}\n    for(int i=1;i<=k;++i) for(int j=1;j<=n;++j) if(lx[i]<=p[j].x&&p[j].x<=rx[i]) add(i,j+k,1,0);\n    for(int i=1;i<=k;++i) for(int j=1;j<=n;++j) if(ly[i]<=p[j].y&&p[j].y<=ry[i]) add(j+n+k,i+n+n+k,1,0);\n    do do memset(vis+1,0,t<<2);while(dfs(s,1e9));while(update());\n}\nint main()\n{\n    i64 ans=0;\n    n=read();for(int i=1;i<=n;++i) p[i]={read(),read(),raed()};\n    m=read();for(int i=1;i<=m;++i) op[i]={getchar(),read(),read()};\n    for(int k=1;k<=n;++k) solve(k),ans=std::max(ans,cost);\n    printf(\"%lld\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define ull unsigned long long\n#define ULL ull\n#define mp make_pair\n#define pii pair<int,int>\n#define piii pair<int, pii >\n#define pll pair <ll,ll>\n#define pb push_back\n#define big 20160116\n#define pq priority_queue\n#define rank rk124232\n#define y1 y20160116\n#define y0 y20160110\nusing namespace std;\n#ifndef MY\n\t#define putchar IO::_putchar\n\t#define getchar IO::_getchar\n#endif\nnamespace IO\n{\n    const int sz=1<<15;\n    char inbuf[sz],outbuf[sz];\n    char *pinbuf=inbuf+sz;\n    char *poutbuf=outbuf;\n    inline char _getchar()\n    {\n        if (pinbuf==inbuf+sz)fread(inbuf,1,sz,stdin),pinbuf=inbuf;\n        return *(pinbuf++);\n    }\n    inline void _putchar(char x)\n    {\n        if (poutbuf==outbuf+sz)fwrite(outbuf,1,sz,stdout),poutbuf=outbuf;\n        *(poutbuf++)=x;\n    }\n    inline void flush()\n    {\n        if (poutbuf!=outbuf)fwrite(outbuf,1,poutbuf-outbuf,stdout),poutbuf=outbuf;\n    }\n}\ninline int read()\n{\n    int x=0,p=1;\n\tchar c=getchar();\n    while (c<'0' || c>'9'){\n    \tif (c=='-') p=-1;\n    \tc=getchar();\n\t}\n    while (c>='0' && c<='9') x=x*10+c-48,c=getchar();\n    return x*p;\n}\nconst int Maxn=555;\nint n,m;\nint l1[Maxn],l2[Maxn],r1[Maxn],r2[Maxn];\nint x[Maxn],y[Maxn];\nchar tp[Maxn],A[Maxn],B[Maxn];\nLL v[Maxn];\nstruct edge{\n\tint to,cap,rev;\n\tLL cost;\n\tedge(int _to,int _cap,LL _cost,int _rev){\n\t\tto=_to;cap=_cap,cost=_cost;rev=_rev;\n\t}\n\tedge(){\n\t\t;\n\t}\n};\nvector<edge> G[Maxn];\nLL dist[Maxn];\nint preve[Maxn],prevv[Maxn],vis[Maxn];\nint q[Maxn*Maxn],sq,eq;\nint s=553,t=554;\nconst LL INF=4e16;\nvoid add_edge(int u,int v,int ca,LL co){\n\tG[u].pb(edge(v,ca,co,G[v].size()));\n\tG[v].pb(edge(u,0,-co,G[u].size()-1));\n}\nLL Bas=0;\nvoid Add_edge(int u,int v,int lo,int hi,LL co){\n\tadd_edge(u,v,hi-lo,co);\n\tadd_edge(u,v,lo,co-INF);\n\tBas+=INF*lo;\n}\nvoid Clear(){\n\tfor (int i=0;i<Maxn;i++){\n\t\tG[i].clear();dist[i]=0;vis[i]=0;\n\t}\n}\nbool bad=false;\nLL MCF(int f){\n\tLL ret=0;\n\twhile (1){\n\t\tif (!f) break;\n\t\tfor (int i=0;i<Maxn;i++) dist[i]=9e18,vis[i]=0;\n\t\tsq=eq=0;\n\t\tdist[s]=0;q[eq++]=s;vis[s]=true;\n\t\twhile (sq<eq){\n\t\t\tint x=q[sq++];\n\t\t\tvis[x]=false;\n\t\t\tfor (int i=0;i<G[x].size();i++){\n\t\t\t\tif (G[x][i].cap){\n\t\t\t\t\tint v=G[x][i].to;\n\t\t\t\t\tif (dist[v]>dist[x]+G[x][i].cost){\n\t\t\t\t\t\tdist[v]=dist[x]+G[x][i].cost;\n\t\t\t\t\t\tprevv[v]=x;preve[v]=i;\n\t\t\t\t\t\tif (!vis[v]){\n\t\t\t\t\t\t\tq[eq++]=v;\n\t\t\t\t\t\t\tvis[v]=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t//\tassert(dist[s]==0);\n\t//\tcout<<\"FF\"<<' '<<dist[t]<<endl; \n\t\tif (dist[t]==9e18){\n\t\t\tbad=true;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif (dist[t]>0) return ret;\n\t\tint Fl=f;\n\t\tfor (int i=t;i!=s;i=prevv[i]){\n\t\t//\tcout<<i<<endl;\n\t\t\tFl=min(Fl,G[prevv[i]][preve[i]].cap);\n\t\t}\n\t\tret+=dist[t]*Fl;\n\t\tfor (int i=t;i!=s;i=prevv[i]){\n\t\t\tedge &e=G[prevv[i]][preve[i]];\n\t\t\te.cap-=Fl;\n\t\t\tG[i][e.rev].cap+=Fl;\n\t\t}\n\t\tf-=Fl;\n\t//\tcout<<\"EE\"<<endl;\n\t}\n\treturn ret;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++){\n\t\tscanf(\"%d %d %lld\",&x[i],&y[i],&v[i]);\n\t}\n\tscanf(\"%d\",&m);\n\tfor (int i=1;i<=m;i++){\n\t\tscanf(\" %c %d %d\",&tp[i],&A[i],&B[i]);\n\t}\n\tLL ans=0;\n\tfor (int _=1;_<=n;_++){\n\t//\tcerr<<_<<endl;\n\t\tClear();\n\t\tBas=0;\n\t\tfor (int i=1;i<=101;i++){\n\t\t\tl1[i]=l2[i]=0;r1[i]=r2[i]=n;\n\t\t} \n\t\tfor (int i=1;i<=m;i++){\n\t\t\tif (tp[i]=='L'){\n\t\t\t\tr1[A[i]]=B[i];\n\t\t\t}\n\t\t\telse if (tp[i]=='R'){\n\t\t\t\tl1[A[i]-1]=max(0,_-B[i]);\n\t\t\t}\n\t\t\telse if (tp[i]=='D'){\n\t\t\t\tr2[A[i]]=B[i];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tl2[A[i]-1]=max(0,_-B[i]);\n\t\t\t}\n\t\t}\n\t\tif (l1[0] || l2[0]) continue;\n\t\tfor (int i=1;i<=100;i++){\n\t\t\tl1[i]=max(l1[i],l1[i-1]);\n\t\t\tl2[i]=max(l2[i],l2[i-1]);\n\t\t}\n\t\tfor (int i=100;i>=1;i--){\n\t\t\tr1[i]=min(r1[i],r1[i+1]);\n\t\t\tr2[i]=min(r2[i],r2[i+1]);\n\t\t}\n\t\tAdd_edge(s,100,l1[100],r1[100],0);\n\t\tfor (int i=100;i>1;i--){\n\t\t\tAdd_edge(i,i-1,l1[i-1],r1[i-1],0);\n\t\t}\n\t\tAdd_edge(200,t,l2[100],r2[100],0);\n\t\tfor (int i=100;i>1;i--){\n\t\t\tAdd_edge(i+99,i+100,l2[i-1],r2[i-1],0);\n\t\t}\n\t\tint kc=200;\n\t\tfor (int i=1;i<=n;i++){\n\t\t\tadd_edge(x[i],i+kc,1,-v[i]);\n\t\t\tadd_edge(i+kc,y[i]+100,1,0);\n\t\t}// cerr<<_<<endl;\n\t\tbad=false;\n\t\tLL Res=MCF(_);\n\t\tif (bad) continue;\n\t\t//cerr<<_<<endl;\n\t\tbool flag=true;\n\t\tfor (int i=0;i<Maxn;i++){\n\t\t\tfor (int j=0;j<G[i].size();j++){\n\t\t\t\tif (G[i][j].cost==-INF){\n\t\t\t\t//\tcout<<\"HHHHHHHHHHH\"<<endl;\n\t\t\t\t\tif (G[i][j].cap) flag=false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (!flag) continue;\n\t//\tcout<<\"F\"<<\" \"<<_<<' '<<Res<<' '<<Bas<<endl;\n\t\tans=min(ans,Res+Bas);\n\t}\n\tprintf(\"%lld\\n\",-ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<cstdlib>\n#include<cstring>\n#include<queue>\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0' || ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0' && ch<='9')x=x*10+ch-'0',ch=getchar();\n\treturn x*f;\n}\nint stack[20];\ninline void write(int x)\n{\n\tif(x<0){putchar('-');x=-x;}\n\tif(!x){putchar('0');return;}\n\tint top=0;\n\twhile(x)stack[++top]=x%10,x/=10;\n\twhile(top)putchar(stack[top--]+'0');\n}\ninline void pr1(int x){write(x),putchar(' ');}\ninline void pr2(int x){write(x),puts(\"\");}\nconst int inf=0x3f3f3f3f;\nqueue<int>Q;\nstruct edge\n{\n\tint x,y,c,next;long long w;\n}a[30010];int len,last[510];\ninline void trins(int x,int y,int c,long long w)\n{\n\tlen++;\n\ta[len].x=x;a[len].y=y;a[len].c=c;a[len].w=w;\n\ta[len].next=last[x];last[x]=len;\n}\ninline void ins(int x,int y,int c,long long w){trins(x,y,c,w),trins(y,x,0,-w);}\nint st,ed,pre[510],f[510];\nbool v[510];\nlong long d[510]; \ninline bool spfa()\n{\n\tmemset(d,-1,sizeof(d));\n\tmemset(v,false,sizeof(v));\n\tQ.push(st);f[st]=inf,d[st]=0,v[st]=true;\n\twhile(!Q.empty())\n\t{\n\t\tint x=Q.front();Q.pop();\n\t\tfor(int k=last[x];k;k=a[k].next)\n\t\t{\n\t\t\tif(!a[k].c)continue;\n\t\t\tint y=a[k].y;\n\t\t\tif(d[y]<d[x]+a[k].w)\n\t\t\t{\n\t\t\t\td[y]=d[x]+a[k].w;pre[y]=k;f[y]=min(f[x],a[k].c);\n\t\t\t\tif(v[y]==false)v[y]=true,Q.push(y);\n\t\t\t}\n\t\t}v[x]=false;\n\t}\n\tif(d[ed]==-1)return false;\n\telse return true;\n}\nint sum;\nlong long ans;\ninline void solve()\n{\n\tint x=ed;\n\twhile(x!=st)\n\t{\n\t\tint k=pre[x];\n\t\ta[k].c-=f[ed],a[k^1].c+=f[ed];\n\t\tx=a[k].x;\n\t}sum+=f[ed],ans+=f[ed]*d[ed];\n}\nstruct query\n{\n\tint id,x,y;\n}q[350];\nstruct point\n{\n\tint x,y;long long c;\n}p[100];\nint L[2][100],R[2][100];\nchar ss[2];\nint main()\n{\n\t//freopen(\"a.in\",\"r\",stdin);\n\t//freopen(\"a.out\",\"w\",stdout);\n\tint n=read();\n\tfor(int i=1;i<=n;i++)scanf(\"%d%d%lld\",&p[i].x,&p[i].y,&p[i].c);\n\tint m=read();\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%s%d%d\",ss+1,&q[i].x,&q[i].y);\n\t\tif(ss[1]=='L')q[i].id=0;\n\t\tif(ss[1]=='R')q[i].id=2;\n\t\tif(ss[1]=='D')q[i].id=1;\n\t\tif(ss[1]=='U')q[i].id=3;\n\t}\n\tlong long mx=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=i;j++)L[0][j]=L[1][j]=1,R[0][j]=R[1][j]=100;\n\t\tfor(int j=1;j<=m;j++)\n\t\t{\n\t\t\tif(q[j].id<2)L[q[j].id][q[j].y+1]=q[j].x+1;\n\t\t\telse if(i>q[j].y)R[q[j].id-2][i-q[j].y]=q[j].x-1;\n\t\t}\n\t\tfor(int j=2;j<=i;j++)L[0][j]=max(L[0][j],L[0][j-1]),L[1][j]=max(L[1][j],L[1][j-1]);\n\t\tfor(int j=i-1;j>=1;j--)R[0][j]=min(R[0][j],R[0][j+1]),R[1][j]=min(R[1][j],R[1][j+1]);\n\t\tlen=1,memset(last,0,sizeof(last));\n\t\tst=0,ed=2*n+1;\n\t\tfor(int j=1;j<=n;j++)ins(j,j+n,1,p[j].c);\n\t\tint now=ed+1;\n\t\tfor(int j=1;j<=i;j++)\n\t\t{\n\t\t\tins(st,now,1,0),ins(now+1,ed,1,0);\n\t\t\tfor(int k=1;k<=n;k++)\n\t\t\t{\n\t\t\t\tif(p[k].x>=L[0][j] && p[k].x<=R[0][j])ins(now,k,1,0);\n\t\t\t\tif(p[k].y>=L[1][j] && p[k].y<=R[1][j])ins(k+n,now+1,1,0);\n\t\t\t}now+=2;\n\t\t}\n\t\tsum=ans=0;\n\t\twhile(spfa()==true)solve();\n\t\tif(sum==i)mx=max(mx,ans);\n\t}printf(\"%lld\\n\",mx);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-03-27 10:28:38\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\n#define i64 long long\ni64 read()\n{\n\ti64 r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\nconst int N=4010;\nnamespace run\n{\n\tconst i64 inf=1ll<<60;\n\ti64 n,px[N],sx[N],py[N],sy[N],begin[N],next[N<<2],to[N<<2],w[N<<2],c[N<<2],e,S,T,m,x[N],y[N],v[N],ans,l,sw,sc;\n\ti64 d[N],q[N*N],_l,_r,pre[N],vis[N];\n\tvoid add(i64 u,i64 v,i64 W,i64 C){ e++; next[e]=begin[u]; begin[u]=e; to[e]=v; w[e]=W; c[e]=C; }\n\tvoid Add(i64 u,i64 v,i64 w,i64 c){ /*printf(\"%I64d %I64d %I64d\\n\",u,v,c);*/ add(u,v,w,c); add(v,u,0,-c); }\n#define fo(i,a) for(int i=begin[a];i;i=next[i])\n\tint bfs()\n\t{\n\t\tfr(i,1,m){ d[i]=inf; pre[i]=0; vis[i]=0; }\n\t\tq[_l=_r=1]=S; d[S]=0;\n\t\twhile(_l<=_r)\n\t\t{\n\t\t\tint u=q[_l++]; vis[u]=0;\n//\t\t\tprintf(\"%d\\n\",u);\n\t\t\tfo(i,u) if(w[i]&&d[u]+c[i]<d[to[i]])\n\t\t\t{\n\t\t\t\td[to[i]]=d[u]+c[i]; pre[to[i]]=i;\n\t\t\t\tif(!vis[to[i]]){ q[++_r]=to[i]; vis[to[i]]=1; }\n\t\t\t}\n\t\t}\n\t\treturn d[T]!=inf;\n\t}\n\ti64 solve(int c)\n\t{\n\t\tmemset(begin,0,sizeof(begin)); e=1; S=n+n+c+c+1; T=n+n+c+c+2; m=T;\n//\t\tprintf(\"%d %I64d %I64d\\n\",c,S,T);\n\t\tfr(i,1,n) Add(i,i+n,1,-v[i]);\n\t\tfr(j,1,c){ Add(S,j+n+n,1,0); Add(j+n+n+c,T,1,0); }\n\t\tfr(i,1,n) fr(j,1,c) if(px[x[i]]>=j&&sx[x[i]]>=c-j+1) Add(j+n+n,i,1,0);\n\t\tfr(i,1,n) fr(j,1,c) if(py[y[i]]>=j&&sy[y[i]]>=c-j+1) Add(i+n,j+n+n+c,1,0);\n\t\tsw=sc=0;\n\t\tfr(i,1,c) if(bfs())\n\t\t{\n//\t\t\tprintf(\"%I64d\\n\",d[T]);\n\t\t\tint u=T; sw++;\n\t\t\twhile(u!=S){ w[pre[u]]--; w[pre[u]^1]++; sc-=::run::c[pre[u]]; u=to[pre[u]^1]; }\n\t\t}\n\t\telse return 0;\n//\t\tprintf(\"%d %I64d\\n\",c,sw==c?sc:0);\n\t\treturn sc;\n\t}\n\tint main()\n\t{\n\t\tn=read(); l=100;\n\t\tfr(i,1,n){ x[i]=read(); y[i]=read(); v[i]=read(); }\n\t\tfr(i,0,l+1) px[i]=sx[i]=py[i]=sy[i]=n;\n\t\tfr(i,1,read())\n\t\t{\n\t\t\tchar opt[N]; i64 a,b;\n\t\t\tscanf(\"%s\",opt); a=read(); b=read();\n\t\t\tif(*opt=='L') px[a]=std::min(px[a],b);\n\t\t\tif(*opt=='R') sx[a]=std::min(sx[a],b);\n\t\t\tif(*opt=='D') py[a]=std::min(py[a],b);\n\t\t\tif(*opt=='U') sy[a]=std::min(sy[a],b);\n\t\t}\n\t\tfr(i,1,l){ sx[i]=std::min(sx[i],sx[i-1]); sy[i]=std::min(sy[i],sy[i-1]); }\n\t\tfd(i,l,1){ px[i]=std::min(px[i],px[i+1]); py[i]=std::min(py[i],py[i+1]); }\n//\t\tfr(i,1,n) printf(\"%I64d %I64d %I64d %I64d\\n\", );\n\t\tfr(i,1,n){ i64 k=solve(i); ans=std::max(ans,k); if(!k) break; }\n\t\tprintf(\"%lld\\n\",ans);\n\t\treturn 0;\n\t}\n}\nint main(){ return run::main(); }"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define gc getchar()\n#define pc putchar\n#define li long long\ninline li read(){\n\tli x = 0,y = 0,c = gc;\n\twhile(!isdigit(c)) y = c,c = gc;\n\twhile(isdigit(c)) x = (x << 1) + (x << 3) + (c ^ '0'),c = gc;\n\treturn y == '-' ? -x : x;\n}\ninline void print(li q){\n\tif(q < 0) pc('-'),q = -q;\n\tif(q >= 10) print(q / 10);\n\tpc(q % 10 + '0');\n}\n#define ldb long double\nldb p[510][510],q[510][510];\nint n,m,cnt;\nli x[510],y[510],a[510];\ninline bool chk(){\n\tfor(int i = 0;i <= n + m;++i) for(int j = 0;j <= cnt;++j){\n\t\tldb tp = abs(p[i][j]) - (li)(abs(p[i][j]) + 0.5l);\n\t\t//cerr<<i<<\" \"<<j<<\" \"<<p[i][j]<<\" \"<<tp<<\" \"<<(li)(p[i][j] + 0.5l)<<endl;\n\t\tif(abs(tp) > 1e-8l) return 0;\n\t}\n\treturn 1;\n}\nint ji[510];\nli calc(){\n\tint i,j;\n\tmemset(ji,0,sizeof(ji));\n\tfor(i = n + 1;i <= cnt;++i) ji[i] = i - n;\n\tji[n] = n + m + 1;\n\tfor(i = 0;i <= n + m;++i){\n\t\tli tp = q[i][n];\n\t\tfor(j = 0;j <= cnt;++j) q[i][j] -= q[n + m + 1][j] * tp;\n\t}\n\t//for(i = 0;i <= n + m + 1;++i){\n\t//\tfor(j = 0;j <= cnt;++j) cout<<q[i][j]<<\" \";cout<<endl;\n\t//}\n\t//cout<<endl;\n\t//for(i = 1;i <= cnt;++i) cout<<ji[i]<<\" \";\n\t//cout<<endl<<endl<<endl;\n\t//for(i = 1;i <= n + m + 1;++i) cerr<<q[i][0]<<\" \";cerr<<endl;\n\t//for(i = 1;i <= n + m + 1;++i) if(q[i][0] < 0) return 0;\n\t//for(i = 1;i <= n;++i) cerr<<ji[i]<<\" \";cerr<<endl;\n\twhile(1){\n\t\tint fg = 0;\n\t\tfor(i = 1;i <= cnt;++i) if(ji[i]) if(q[ji[i]][0] < 0 && (!fg || q[ji[i]][0] < q[ji[fg]][0])) fg = i;\n\t\tif(!fg) break;\n\t\tint tp = 0,tmp = 0;\n\t\tfor(i = 1;i <= cnt;++i) if(q[ji[fg]][i] < 0 && (!tp || q[ji[fg]][i] < q[ji[fg]][tp])) tp = i;\n\t\t//for(i = 1;i <= n + m + 2;++i) if(q[i][fg] > 0 && (!tp || q[i][0] / q[i][fg] < q[tp][0] / q[tp][fg])) tp = i;\n\t\t//cerr<<fg<<\"*\"<<tp<<endl;\n\t\tif(!tp) return 0;\n\t\tji[tp] = ji[fg];tmp = fg;fg = ji[fg];ji[tmp] = 0;swap(tp,fg);\n\t\t//tmp = tp;tp = ji[tmp];ji[tmp] = 0;ji[fg] = tp;\n\t\tfor(i = 0;i <= cnt;++i) if(i != fg) q[tp][i] /= q[tp][fg];q[tp][fg] = 1;\n\t\tfor(i = 0;i <= n + m + 1;++i) if(i != tp){\n\t\t\tfor(j = 0;j <= cnt;++j) if(j != fg) q[i][j] -= q[i][fg] * q[tp][j];q[i][fg] = 0;\n\t\t} \n\t\t//cout<<fg<<\"*\"<<tp<<\" \"<<(li)(-q[0][0] + 0.5l)<<endl;\n\t\t//cerr<<fg<<\"*\"<<tp<<endl;\n\t\t//for(i = 0;i <= n + m;++i){\n\t\t//\tif(i == 12) cerr<<\"*\";\n\t\t//\tfor(j = 0;j <= cnt;++j) cout<<q[i][j]<<\" \";cout<<endl;\n\t\t//}\n\t\t//cerr<<endl;\n\t\t//for(i = 1;i <= cnt;++i) cerr<<ji[i]<<\" \";\n\t\t//cout<<endl<<endl<<endl;\n\t\t//if(chk()) as = max(as,(li)(-q[0][0] + 0.5l));\n\t\t//system(\"pause\");\n\t}\n\t//int ctt = 0;\n\t//for(i = 1;i <= n;++i) cerr<<ji[i]<<\" \";cerr<<endl;\n\t//for(i = 1;i <= n;++i) if(ji[i] && q[ji[i]][0] > 1 - 1e-8l) ++ctt;\n\t//cerr<<ctt<<endl;\n\twhile(1){\n\t\tint fg = 0;\n\t\tfor(i = 1;i <= cnt;++i) if(!ji[i]) if(q[0][i] > 0 && (!fg || q[0][i] > q[0][fg])) fg = i;\n\t\tif(!fg) break;\n\t\tint tp = 0,tmp = 0;\n\t\tfor(i = 1;i <= cnt;++i) if(ji[i]) if(q[ji[i]][fg] > 0 && (!tp || q[ji[i]][0] / q[ji[i]][fg] < q[ji[tp]][0] / q[ji[tp]][fg])) tp = i;\n\t\t//for(i = 1;i <= n + m + 2;++i) if(q[i][fg] > 0 && (!tp || q[i][0] / q[i][fg] < q[tp][0] / q[tp][fg])) tp = i;\n\t\tif(!tp) return 0;\n\t\ttmp = tp;tp = ji[tmp];ji[tmp] = 0;ji[fg] = tp;\n\t\tfor(i = 0;i <= cnt;++i) if(i != fg) q[tp][i] /= q[tp][fg];q[tp][fg] = 1;\n\t\tfor(i = 0;i <= n + m + 1;++i) if(i != tp){\n\t\t\tfor(j = 0;j <= cnt;++j) if(j != fg) q[i][j] -= q[i][fg] * q[tp][j];q[i][fg] = 0;\n\t\t} \n\t\t//cout<<fg<<\"*\"<<tp<<\" \"<<(li)(-q[0][0] + 0.5l)<<endl;\n\t\t//cerr<<fg<<\"*\"<<tp<<endl;\n\t\t//for(i = 0;i <= n + m;++i){\n\t\t//\tif(i == 12) cerr<<\"*\";\n\t\t//\tfor(j = 0;j <= cnt;++j) cout<<q[i][j]<<\" \";cout<<endl;\n\t\t//}\n\t\t//cerr<<endl;\n\t\t//for(i = 1;i <= cnt;++i) cerr<<ji[i]<<\" \";\n\t\t//cout<<endl<<endl<<endl;\n\t\t//if(chk()) as = max(as,(li)(-q[0][0] + 0.5l));\n\t\t//system(\"pause\");\n\t}\n\tli as = 0;\n\t//for(i = 1;i <= cnt;++i) if(ji[i]) if(q[ji[i]][0] < 0) return 0;\n\t//for(i = 1;i <= n;++i) cerr<<(ji[i] ? q[ji[i]][0] : 0)<<\" \";cerr<<endl;\n\tfor(i = 1;i <= n;++i) if(ji[i]){\n\t\tif(q[ji[i]][0] > 1 - 1e-8l) as += a[i];\n\t} \n\t//cerr<<as<<endl;\n\treturn as;\n\t//return (li)(-q[0][0] + 0.5l);\n}\nint main(){\n\t//system(\"mode con cols=200 lines=1000\");\n\tint i,j,k,l,u,v;\n\tn = read();for(i = 1;i <= n;++i) x[i] = read(),y[i] = read(),a[i] = read();cnt = n;\n\tm = read();\n\tchar c;\n\tfor(i = 1;i <= m;++i){\n\t\tc = gc;while(c < 'A' || c > 'Z') c = gc;\n\t\tu = read();v = read();\n\t\tp[i][0] = v;\n\t\tif(c == 'U'){\n\t\t\tfor(j = 1;j <= n;++j) if(y[j] >= u) p[i][j] = 1;\n\t\t} \n\t\telse if(c == 'D'){\n\t\t\tfor(j = 1;j <= n;++j) if(y[j] <= u) p[i][j] = 1;\n\t\t} \n\t\telse if(c == 'L'){\n\t\t\tfor(j = 1;j <= n;++j) if(x[j] <= u) p[i][j] = 1;\n\t\t} \n\t\telse{\n\t\t\tfor(j = 1;j <= n;++j) if(x[j] >= u) p[i][j] = 1;\n\t\t} \n\t\tp[i][++cnt] = 1;\n\t\t//ji[cnt] = i;\n\t}\n\tfor(i = 1;i <= n;++i){\n\t\tp[i + m][i] = p[i + m][++cnt] = p[i + m][0] = 1;\n\t\t//ji[cnt] = i + m;\n\t} \n\t//cerr<<n + m<<\" \"<<cnt<<endl;\n\tfor(i = 1;i <= n;++i) p[0][i] = a[i];\n\t//freopen(\"out.txt\",\"w\",stdout);\n\t//for(i = 0;i <= n + m + 1;++i){\n\t//\tfor(j = 0;j <= cnt;++j) cout<<p[i][j]<<\" \";cout<<endl;\n\t//}\n\t//cerr<<endl;\n\t//for(i = 1;i <= cnt;++i) cerr<<ji[i]<<\" \";\n\t//cout<<endl<<endl<<endl;\n\tli as = 0;\n\tfor(i = 1;i <= n;++i) p[n + m + 1][i] = 1,p[n + m + 2][i] = -1;\n\t//freopen(\"qwq.out\",\"w\",stdout);\n\tfor(int qwq = 1;qwq <= n;++qwq){\n\t\t//cerr<<qwq<<\":\"<<endl;\n\t\tfor(i = 0;i <= n + m + 1;++i) for(j = 0;j <= cnt;++j) q[i][j] = p[i][j];\n\t\tq[n + m + 1][0] = qwq;//q[n + m + 2][0] = -qwq;\n\t\tas = max(as,calc());\n\t}\n\t//for(i = 1;i <= cnt;++i) cerr<<(ji[i] ? p[ji[i]][0] : 0)<<\" \";cerr<<endl;\n\tprint(as);\n\t//print(as);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <queue>\nusing namespace std;\nconst int Q=1000,P=1<<18;\n#define ll long long\nint las[Q],e[P],nn[P],c[P];\nll v[P];\nqueue<int> q;\nint S,T;\nconst ll inf=100000000000000000LL;\nll dis[Q];\nint inc;\nvoid iNS(int x,int y,int z,ll w)\n{\n    e[++inc]=y;\n    nn[inc]=las[x];\n    las[x]=inc;\n    c[inc]=z;\n    v[inc]=w;\n}\nvoid ins(int x,int y,int z,ll w)\n{\n    iNS(x,y,z,w),iNS(y,x,0,-w);\n}\nint ch[Q];\nint pn[Q],pt[Q];\nint Spfa()\n{\n    for(int i=1;i<=T;i++)\n        dis[i]=-inf;\n    dis[S]=0;\n    q.push(S);\n    while(q.size()){\n        int x=q.front();q.pop();\n        ch[x]=0;\n        for(int t=las[x];t;t=nn[t]){\n            int y=e[t];\n            if(c[t]&&dis[x]+v[t]>dis[y]){\n                dis[y]=dis[x]+v[t];\n                pn[y]=x,pt[y]=t;\n                if(!ch[y])ch[y]=1,q.push(y);\n            }\n        }\n    }\n    return dis[T]>-inf;\n}\nll tmp,als=0;\nvoid Upd()\n{\n    tmp+=dis[T];\n    for(int now=T;now!=S;now=pn[now]){\n        int nt=pt[now];\n        --c[nt],++c[nt^1];\n    }\n}\nint n,m;\nint X[Q],Y[Q];\nint A[Q],B[Q];\nchar ty[Q][5];\nll V[Q];\nint L[Q],R[Q];\nint U[Q],D[Q];\ninline void Gmax(int &a,int b)\n{a<b?a=b:1;}\ninline void Gmin(int &a,int b)\n{a>b?a=b:1;}\nvoid Deal(int Num)\n{\n    S=(Num<<1)+(n<<1)+1,T=S+1;\n    for(int i=1;i<=T;i++)\n        las[i]=0;\n    inc=1;\n    for(int i=1;i<=Num;i++)L[i]=D[i]=-998244353,R[i]=U[i]=998244353;\n    for(int i=1;i<=m;i++){\n        if(Num<=B[i])continue;\n        if(ty[i][0]=='L')Gmax(L[B[i]+1],A[i]+1);\n        if(ty[i][0]=='D')Gmax(D[B[i]+1],A[i]+1);\n        if(ty[i][0]=='R')Gmin(R[Num-B[i]],A[i]-1);\n        if(ty[i][0]=='U')Gmin(U[Num-B[i]],A[i]-1);\n    }\n    for(int i=2;i<=Num;i++)\n        Gmax(L[i],L[i-1]),Gmax(D[i],D[i-1]);\n    for(int i=Num-1;i;--i)\n        Gmin(R[i],R[i+1]),Gmin(U[i],U[i+1]);\n    int ini=(Num<<1);\n    for(int i=1;i<=Num;i++){\n        ins(S,i,1,0),ins(i+Num,T,1,0);\n        for(int j=1;j<=n;j++)\n            if(X[j]>=L[i]&&X[j]<=R[i])\n                ins(i,ini+j,1,0);\n        for(int j=1;j<=n;j++)\n            if(Y[j]>=D[i]&&Y[j]<=U[i])\n                ins(ini+n+j,i+Num,1,0);\n    }\n    for(int i=1;i<=n;i++)\n        ins(i+ini,i+ini+n,1,V[i]);\n    tmp=0;\n    int tim=0;\n    while(Spfa())Upd(),++tim;\n    if(tim==Num)als=max(als,tmp);\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)\n        scanf(\"%d%d%lld\",&X[i],&Y[i],&V[i]);\n    scanf(\"%d\",&m);\n    for(int i=1;i<=m;i++)\n        scanf(\"%s%d%d\",ty[i],&A[i],&B[i]);\n    for(int i=1;i<=n;i++)\n        Deal(i);\n    printf(\"%lld\\n\",als);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define cmin(a,b) (a>(b)?a=(b),1:0)\n#define cmax(a,b) (a<(b)?a=(b),1:0)\n#define dmin(a,b) ((a)<(b)?(a):(b))\n#define dmax(a,b) ((a)>(b)?(a):(b))\nnamespace io\n{\n\tint F()\n\t{\n\t\t int F=1,n=0;\n\t\t char ch;\n\t\t while((ch=getchar())!='-'&&(ch<'0'||ch>'9'));\n\t\t ch=='-'?F=0:n=ch-'0';\n\t\t while((ch=getchar())>='0'&&ch<='9')n=n*10+ch-'0';\n\t\t return F?n:-n;\n\t}\n\tlong long G()\n\t{\n\t\t long long F=1,n=0;\n\t\t char ch;\n\t\t while((ch=getchar())!='-'&&(ch<'0'||ch>'9'));\n\t\t ch=='-'?F=0:n=ch-'0';\n\t\t while((ch=getchar())>='0'&&ch<='9')n=n*10+ch-'0';\n\t\t return F?n:-n;\n\t}\n}\nstruct edge\n{\n\tint to;\n\tlong long val;\n\tint res;\n\tint next;\n}e[3888];\nint pe=222;\nvoid insert(int a,int to,long long val,int cap)\n{\n\te[pe]=(edge){to,val,cap,e[a].next};\n\te[a].next=pe++;\n}\nvoid addedge(int a,int to,long long val,int cap)\n{\n\tinsert(a,to,val,cap);\n\tinsert(to,a,-val,0);\n}\nint S,T;\nint U[222],D[222],L[222],R[222];\nint x[222],y[222];\nlong long v[222];\nint in[222];\nint q[22222222],hq,tq;\nint vis[2222];\nlong long dis[2222];\nint from[2222],frome[2222];\nint flow;\nbool spfa()\n{\n\tfor(int i=1;i<=T;++i)dis[i]=0x6e6e6e6e6e6e6e6ell;\n\tfor(q[hq=1]=S,tq=2,vis[S]=1,dis[S]=0;hq!=tq;vis[q[hq++]]=0)\n\t\tfor(register int p=e[q[hq]].next;p;p=e[p].next)\n\t\t\tif(e[p].res&&cmin(dis[e[p].to],dis[q[hq]]+e[p].val))\n\t\t\t{\n\t\t\t\tfrom[e[p].to]=q[hq],frome[e[p].to]=p;\n\t\t\t\tif(!vis[e[p].to])vis[e[p].to]=1,q[tq++]=e[p].to;\n\t\t\t}\n\treturn dis[T]!=0x6e6e6e6e6e6e6e6ell;\n}\nlong long ek()\n{\n\tflow=0;\n\tlong long ans=0;\n\twhile(spfa())\n\t{\n\t\tint now=T;\n\t\tint min=0x3f3f3f3f;\n\t\twhile(1)\n\t\t{\n\t\t\tcmin(min,e[frome[now]].res);\n\t\t\tnow=from[now];\n\t\t\tif(now==S)break;\n\t\t}\n\t\tnow=T;\n\t\twhile(1)\n\t\t{\n\t\t\te[frome[now]].res-=min;\n\t\t\te[frome[now]^1].res+=min;\n\t\t\tnow=from[now];\n\t\t\tif(now==S)break;\n\t\t}\n\t\tans+=dis[T]*min;\n\t\tflow+=min;\n\t}\n\treturn ans;\n}\nint main()\n{\n\tint n=io::F();\n\tfor(register int i=1;i<=n;++i)\n\t\tx[i]=io::F(),y[i]=io::F(),v[i]=io::G();\n\tint m=io::F();\n\tfor(register int i=1;i<=m;++i)\n\t{\n\t\tchar s[4];\n\t\tscanf(\"%s\",s);\n\t\tint a=io::F(),b=io::F();\n\t\tif(*s=='U')U[a]=b;\n\t\tif(*s=='D')D[a]=b;\n\t\tif(*s=='L')L[a]=b;\n\t\tif(*s=='R')R[a]=b;\n\t}\n\tfor(register int i=0;i<100;++i)\n\t{\n\t\tif(U[i]==0)U[i]=n;\n\t\tif(D[i]==0)D[i]=n;\n\t\tif(L[i]==0)L[i]=n;\n\t\tif(R[i]==0)R[i]=n;\n\t}\n\tS=201,T=202;\n\tlong long max=0;\n\tint sum;\n\tlong long tmp;\n\tfor(register int s=1;s<=n;++s)\n\t{\n\t\tfor(register int j=1;j<=T;++j)e[j].next=0,in[j]=0;\n\t\tpe=222;\n\t\tif(s>R[1])goto skip;\n\t\tfor(register int i=1;i<100;++i)\n\t\t{\n\t\t\tint lb,rb;\n\t\t\trb=R[i+1],lb=s-L[i];\n\t\t\tif(lb>rb)goto skip;\n\t\t\taddedge(i,i+1,0,rb-lb);\n\t\t\tin[i+1]+=lb;\n\t\t\tin[i]-=lb;\n\t\t\t\n\t\t\trb=D[i],lb=s-U[i+1];\n\t\t\tif(lb>rb)goto skip;\n\t\t\taddedge(i+100,i+101,0,rb-lb);\n\t\t\tin[i+101]+=lb;\n\t\t\tin[i+100]-=lb;\n\t\t}\n\t\t{\n\t\t\tin[1]+=s;\n\t\t\tin[200]-=s;\n\t\t}\n\t\tsum=0;\n\t\tfor(register int i=1;i<=200;++i)\n\t\t\tif(in[i]>0)addedge(S,i,0,in[i]),sum+=in[i];\n\t\t\t\telse if(in[i]<0)addedge(i,T,0,-in[i]);\n\t\tfor(register int i=1;i<=n;++i)\n\t\t\taddedge(x[i],y[i]+100,-v[i],1);\n\t\ttmp=-ek();\n\t\tif(flow!=sum)continue;\n\t\tcmax(max,tmp);\n\t\tskip:;\n\t}\n\tprintf(\"%lld\\n\",max);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace __gnu_pbds;\nusing namespace std;\n \ntemplate <typename T>\nusing ordered_set =\n\ttree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n \n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n\t*this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n \n#define shandom_ruffle random_shuffle\n \nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=327;\nusing bn=bitset<87>;\nusing ld=long double;\n\nint n;\npii gdz[nax];\nll war[nax];\n\nint m;\nbn podz[nax];\nint ile[nax];\n\nll wyn;\n\nbn ter;\n \nll dajwar()\n{\n\tll ret=0;\n\tfor (int i=1; i<=n; i++)\n\t\tif (ter[i])\n\t\t\tret+=war[i];\n\treturn ret;\n}\n \nint popr()\n{\n\tfor (int i=1; i<=m; i++)\n\t\tif ((podz[i]&ter).count()>ile[i])\n\t\t\treturn 0;\n\treturn 1;\n}\n\nstruct Simplex {        // Maximize c*x subject to Ax <= b.\n  using T = ld;     // Initialize the structure, set A, b, c and then run\n  vector<vector<T>> A;  // solve(). Max objective is stored in res. To recover\n  vector<T> b, c;       // the best result, use getVars().\n  int V, E;\n  vector<int> eqIds, varIds, cols;\n  T res;\n  static constexpr T kEps = 1e-5;\n\n  Simplex(int vars, int eqs) : A(eqs, vector<T>(vars)), b(eqs), c(vars),\n      V(vars), E(eqs), eqIds(eqs), varIds(vars), res(0) {\n    iota(varIds.begin(), varIds.end(), 0);\n    iota(eqIds.begin(), eqIds.end(), vars);\n  }\n\n  void pivot(int eq, int var) {\n    T coef = 1 / A[eq][var];\n    cols.clear();\n    for (int i = 0; i < V; i++) {\n      if (abs(A[eq][i]) > kEps) { cols.push_back(i); A[eq][i] *= coef; }\n    }\n    A[eq][var] *= coef; b[eq] *= coef;\n    for (int row = 0; row < E; row++) {\n      if (row == eq || abs(A[row][var]) < kEps) { continue; }\n      T k = -A[row][var];\n      A[row][var] = 0;\n      for (int i : cols) { A[row][i] += k * A[eq][i]; }\n      b[row] += k * b[eq];\n    }\n    T q = c[var]; c[var] = 0;\n    for (int i : cols) { c[i] -= q * A[eq][i]; }\n    res += q * b[eq];\n    swap(varIds[var], eqIds[eq]);\n  }\n\n  bool solve() {\n    while (true) {\n      int eq = -1, var = -1;\n      for (int i = 0; i < E; i++) { if (b[i] < -kEps) { eq = i; break; } }\n      if (eq == -1) { break; }\n      for (int i = 0; i < V; i++) { if (A[eq][i] < -kEps) { var = i; break; } }\n      if (var == -1) { res = -1e9; return false; /* No solution */ }\n      pivot(eq, var);\n    }\n    while (true) {\n      int var = -1, eq = -1;\n      for (int i = 0; i < V; i++) { if (c[i] > kEps) { var = i; break; } }\n      if (var == -1) { break; }\n      for (int i = 0; i < E; i++) {\n        if (A[i][var] < kEps) { continue; }\n        if (eq >= 0 && b[i] / A[i][var] >= b[eq] / A[eq][var]) { continue; }\n        eq = i;\n      }\n      if (eq == -1) { res = 1e9; return false; /* Unbounded */ }\n      pivot(eq, var);\n    }\n    return true;\n  }\n\n  vector<T> getVars() { // Optimal assignment of variables.\n    vector<T> result(V);\n    for (int i = 0; i < E; i++) if (eqIds[i] < V) result[eqIds[i]] = b[i];\n    return result;\n  }\n};\n\nvoid rek(int v, int jesz)\n{\n\tif (popr())\n\t\twyn=max(wyn, dajwar());\n\tif (!jesz)\n\t\treturn;\n\tfor (int i=v; i<=n; i++)\n\t{\n\t\tter.flip(i);\n\t\trek(i+1, jesz-1);\n\t\tter.flip(i);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(\"%d%d%lld\", &gdz[i].first, &gdz[i].second, &war[i]);\n\tscanf(\"%d\", &m);\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\tchar c;\n\t\tint a, b;\n\t\tscanf(\" %c%d%d\", &c, &a, &b);\n\t\tfor (int j=1; j<=n; j++)\n\t\t{\n\t\t\tif (c=='L' && gdz[j].first<=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='R' && gdz[j].first>=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='D' && gdz[j].second<=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='U' && gdz[j].second>=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t}\n\t\tile[i]=b;\n\t}\n\tSimplex janusz(n, m+2*n);\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tjanusz.c[i]=war[i+1];\n\t}\n\tfor (int i=0; i<m; i++)\n\t{\n\t\tjanusz.b[i]=ile[i+1];\n\t\tfor (int j=0; j<n; j++)\n\t\t\tjanusz.A[i][j]=podz[i+1][j+1];\n\t}\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tjanusz.b[m+i]=1;\n\t\tjanusz.A[m+i][i]=1;\n\t}\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tjanusz.b[m+n+i]=0;\n\t\tjanusz.A[m+n+i][i]=-1;\n\t}\n\tassert(janusz.solve());\n\tauto wez=janusz.getVars();\n\t\n\tfor (int i=0; i<n; i++)\n\t\tter[i+1]=(wez[i]>0.5);\n\t\n\tll sta=dajwar();\n\t\n\twhile(popr())\n\t{\n\t\tint czy=0;\n\t\tfor (int i=1; i<=n; i++)\n\t\t{\n\t\t\tif (!ter[i])\n\t\t\t{\n\t\t\t\tter[i]=1;\n\t\t\t\tif (popr())\n\t\t\t\t\tczy=1;\n\t\t\t\telse\n\t\t\t\t\tter[i]=0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (!czy)\n\t\t\tbreak;\n\t}\n\t\n\trek(1, 5);\n\t\n\tdebug() << janusz.getVars();\n\tprintf(\"%lld\\n\", wyn);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate <class T>\nistream& operator>>(istream& is, vector<T>& v) {\n  for (T& x : v)\n    is >> x;\n  return is;\n}\n\nostream& operator<<(ostream& os, const pair<char, int>& unit) {\n  return os << unit.first << \"^\" << unit.second;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n  if (!v.empty()) {\n    os << v.front();\n    for (int i = 1; i < v.size(); ++i)\n      os << ' ' << v[i];\n  }\n  return os;\n}\n\nnamespace Min25 {\n\n#define _rep(_1, _2, _3, _4, name, ...) name\n#define rep2(i, n) rep3(i, 0, n)\n#define rep3(i, a, b) rep4(i, a, b, 1)\n#define rep4(i, a, b, c) for (int i = int(a); i < int(b); i += int(c))\n#define rep(...) _rep(__VA_ARGS__, rep4, rep3, rep2, _)(__VA_ARGS__)\n\nusing namespace std;\n\nusing i64 = long long;\nusing u8 = unsigned char;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing f80 = long double;\n\ntemplate<\n    typename CapType, typename TotalCapType,\n    typename CostType, typename TotalCostType\n>\nclass CostScaling {\n private:\n  static const int alpha = 8; // eps <- max(1, eps / alpha)\n\n  using cap_t = CapType;\n  using tcap_t = TotalCapType;\n  using cost_t = CostType; // > max{|C|} * (2 * |V|)\n  using tcost_t = TotalCostType;\n  static constexpr cost_t Inf = (tcap_t(1) << (sizeof(tcap_t) * 8 - 2)) - 1;\n\n  struct InputEdge { int from, to; cap_t b, c; cost_t cost; };\n  struct Edge { int to, rev; cap_t cap; cost_t cost; };\n\n  class Dinic {\n   public:\n    Dinic(int N, const vector<int> &ofs, vector<Edge> &edges,\n          vector<tcap_t> &capacity)\n        : N(N), ofs(ofs), edges(edges), capacity(capacity), last(N) {}\n\n    bool succeeded() {\n      // s -> u: capacity[u]\n      // u -> t: capacity[u + N]\n      tcap_t f = 0;\n      for (int u = 0; u < N; ++u) f += capacity[u];\n      vector<int> que(N);\n      while (f) {\n        dist.assign(N, -1);\n        int qh = 0, qt = 0, lv = N;\n        for (int u = 0; u < N; ++u) if (capacity[u] > 0) que[qt++] = u, dist[u] = 0;\n        for (; qh < qt;) {\n          int u = que[qh++];\n          if (lv == N && capacity[u + N] > 0) lv = dist[u];\n          if (dist[u] > lv) break;\n          for (int ei = ofs[u]; ei < ofs[u + 1]; ++ei) {\n            int v = edges[ei].to;\n            if (edges[ei].cap > 0 && dist[v] == -1) {\n              que[qt++] = v, dist[v] = dist[u] + 1;\n            }\n          }\n        }\n        if (lv == N) break;\n        for (int u = 0; u < N; ++u) last[u] = ofs[u];\n        for (int u = 0; u < N; ++u)\n          if (capacity[u] > 0) {\n            auto df = block_flow(u, capacity[u]);\n            f -= df, capacity[u] -= df;\n          }\n      }\n      return f == 0;\n    }\n\n   private:\n    tcap_t block_flow(int u, tcap_t f) {\n      tcap_t ret = 0;\n      if (capacity[u + N] > 0) {\n        tcap_t df = min(f, capacity[u + N]);\n        capacity[u + N] -= df;\n        return df;\n      }\n      for (auto &ei = last[u]; ei < ofs[u + 1]; ++ei) {\n        auto &e = edges[ei];\n        int v = e.to;\n        if (e.cap == 0 || dist[v] <= dist[u]) continue;\n        cap_t df = block_flow(v, min<cap_t>(e.cap, f));\n        if (df == 0) continue;\n        e.cap -= df, edges[e.rev].cap += df;\n        f -= df, ret += df;\n        if (f == 0) break;\n      }\n      return ret;\n    }\n\n    int N;\n    const vector<int> &ofs;\n    vector<Edge> &edges;\n    vector<tcap_t> &capacity;\n    vector<int> last, dist;\n  };\n\n public:\n  CostScaling(int N, int M = 0) : N(N), capacity(2 * N) {\n    if (M > 0) in.reserve(M);\n  }\n\n  void add_directed_edge(int u, int v, cap_t b, cap_t c, cost_t cost) {\n    if (b > 0) capacity[v] += b, capacity[u + N] += b;\n    else capacity[u] += -b, capacity[v + N] += -b;\n    in.push_back({u, v, b, c, cost});\n  }\n\n  pair<bool, tcost_t> minimum_cost_circulation() {\n    construct();\n    if (!has_feasible_circulation()) return {false, 0};\n\n    const int cost_multiplier = 2 << __lg(N); // should be > |V|\n    cost_t eps = 0;\n    for (auto &e : edges) e.cost *= cost_multiplier, eps = max(eps, e.cost);\n\n    while (eps > 1) refine(eps = max<cost_t>(1, eps / alpha));\n\n    tcost_t ret = initial_cost;\n    for (auto &e : edges) ret -= (e.cost / cost_multiplier) * e.cap;\n    return {true, ret / 2};\n  }\n\n private:\n  void refine(const cost_t eps) {\n    auto cost_p = [&](int u, const Edge &e) {\n      return e.cost + potential[u] - potential[e.to];\n    };\n    for (int u = 0; u < N; ++u)\n      for (int i = ofs[u]; i < ofs[u + 1]; ++i) {\n        auto &e = edges[i];\n        if (cost_p(u, e) < 0) edges[e.rev].cap += e.cap, e.cap = 0;\n      }\n    vector<tcap_t> excess(initial_excess);\n    for (auto &e : edges) excess[e.to] -= e.cap;\n\n    vector<int> stack;\n    stack.reserve(N);\n    for (int u = 0; u < N; ++u) if (excess[u] > 0) stack.push_back(u);\n\n    auto residue = [&](const Edge &e) -> cap_t { return e.cap; };\n    auto push = [&](int u, Edge &e, cap_t df) {\n      e.cap -= df;\n      edges[e.rev].cap += df;\n      excess[e.to] += df;\n      excess[u] -= df;\n      if (excess[e.to] > 0 && excess[e.to] <= df) {\n        stack.push_back(e.to);\n      }\n    };\n    auto relabel = [&](int u, cost_t delta) {\n      potential[u] -= delta + eps;\n    };\n    auto relabel_in_advance = [&](int u) {\n      if (excess[u] != 0) return false;\n      auto delta = Inf;\n      for (int ei = ofs[u]; ei < ofs[u + 1]; ++ei) {\n        auto &e = edges[ei];\n        if (residue(e) == 0) continue;\n        if (cost_p(u, e) < 0) return false;\n        else delta = min<tcost_t>(delta, cost_p(u, e));\n      }\n      relabel(u, delta);\n      return true;\n    };\n    auto discharge = [&](int u) {\n      auto delta = Inf;\n      for (int ei = ofs[u]; ei < ofs[u + 1]; ++ei) {\n        auto &e = edges[ei];\n        if (residue(e) == 0) continue;\n        if (cost_p(u, e) < 0) {\n          if (relabel_in_advance(e.to)) {\n            --ei;\n            continue; // modify ei (!)\n          }\n          cap_t df = min<tcap_t>(excess[u], residue(e));\n          push(u, e, df);\n          if (!excess[u]) return;\n        } else delta = min<tcost_t>(delta, cost_p(u, e));\n      }\n      relabel(u, delta);\n      stack.push_back(u);\n    };\n    while (!stack.empty()) {\n      auto u = stack.back();\n      stack.pop_back();\n      discharge(u);\n    }\n  }\n\n  void construct() {\n    ofs.assign(N + 1, 0);\n    edges.resize(2 * in.size());\n    initial_excess.assign(N, 0);\n    initial_cost = 0;\n    potential.assign(N, 0);\n    for (auto &e : in) ofs[e.from + 1]++, ofs[e.to + 1]++;\n    for (int i = 1; i <= N; ++i) ofs[i] += ofs[i - 1];\n    for (auto &e : in) {\n      initial_excess[e.to] += e.c;\n      initial_excess[e.from] += -e.b;\n      initial_cost += tcost_t(e.cost) * (e.c + e.b);\n      edges[ofs[e.from]++] = {e.to, ofs[e.to], e.c - e.b, e.cost};\n      edges[ofs[e.to]++] = {e.from, ofs[e.from] - 1, 0, -e.cost};\n    }\n    for (int i = N; i > 0; --i) ofs[i] = ofs[i - 1];\n    ofs[0] = 0;\n  }\n\n  bool has_feasible_circulation() {\n    return Dinic(N, ofs, edges, capacity).succeeded();\n  }\n\n private:\n  int N;\n  vector<InputEdge> in;\n  vector<tcap_t> capacity;\n\n  vector<int> ofs;\n  vector<Edge> edges;\n\n  tcost_t initial_cost;\n  vector<tcap_t> initial_excess;\n  vector<tcost_t> potential;\n};\n\nusing MCC = CostScaling<int64_t, int64_t, int64_t, int64_t>;\n\n}\n\n#undef _rep\n#undef rep\n#undef rep2\n#undef rep3\n#undef rep4\n\nstruct MinCostMaxFlow {\n  Min25::MCC mcc1, mcc2;\n\n  MinCostMaxFlow(int n, int m) : mcc1(n, m), mcc2(n, m) {}\n\n  void addEdge(int u, int v, ll w) {\n    mcc1.add_directed_edge(u, v, 0, 1, 0);\n    mcc2.add_directed_edge(u, v, 0, 1, w);\n  }\n\n  pair<int, ll> mcmf() {\n    mcc1.add_directed_edge(1, 0, 0, 1e18, -1);\n    auto maxFlow = -mcc1.minimum_cost_circulation().second;\n    mcc2.add_directed_edge(1, 0, maxFlow, maxFlow, 0);\n    return make_pair(maxFlow, mcc2.minimum_cost_circulation().second);\n  }\n};\n\ntemplate <class T>\nvoid chkMax(T& x, const T& y) {\n  if (y > x) x = y;\n}\n\ntemplate <class T>\nvoid chkMin(T& x, const T& y) {\n  if (y < x) x = y;\n}\n\nconst int N = 85, M = N * 4;\n\nint n;\nint x[N], y[N]; ll v[N];\nint m;\nchar t[M]; int a[M], b[M];\n\nint l[N], r[N], d[N], u[N];\n\nint main() {\n#ifdef LBT\n  freopen(\"test.in\", \"r\", stdin);\n  int nol_cl = clock();\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  cin >> n;\n  for (int i = 1; i <= n; ++i)\n    cin >> x[i] >> y[i] >> v[i];\n  cin >> m;\n  for (int i = 1; i <= m; ++i)\n    cin >> t[i] >> a[i] >> b[i];\n\n  ll ans = 0;\n  for (int k = 1; k <= n; ++k) {\n    fill(l + 1, l + k + 1, 1);\n    fill(r + 1, r + k + 1, 100);\n    fill(d + 1, d + k + 1, 1);\n    fill(u + 1, u + k + 1, 100);\n    for (int i = 1; i <= m; ++i) {\n      if (b[i] >= k) continue;\n      if (t[i] == 'L')\n        chkMax(l[b[i] + 1], a[i] + 1);\n      else if (t[i] == 'R')\n        chkMin(r[k - b[i]], a[i] - 1);\n      else if (t[i] == 'D')\n        chkMax(d[b[i] + 1], a[i] + 1);\n      else\n        chkMin(u[k - b[i]], a[i] - 1);\n    }\n    for (int i = 2; i <= k; ++i) chkMax(l[i], l[i - 1]);\n    for (int i = 2; i <= k; ++i) chkMax(d[i], d[i - 1]);\n    for (int i = k - 1; i; --i) chkMin(r[i], r[i + 1]);\n    for (int i = k - 1; i; --i) chkMin(u[i], u[i + 1]);\n    int S = 0, T = 1; // 2 + N * 2 + K * 2\n    // k * 2 + n +\n    MinCostMaxFlow mcmf(n * 2 + k * 2 + 2, n + k * 2 + n * k * 2);\n    for (int i = 1; i <= n; ++i)\n      mcmf.addEdge(i * 2, i * 2 + 1, 1e15 - v[i]);\n    // max : n * 2 + 1, n * 2 + i\n    // cerr << n *2 + 1 << ' ';\n    for (int i = 1; i <= k; ++i) {\n      mcmf.addEdge(S, n * 2 + 1 + i, 0);\n      mcmf.addEdge(n * 2 + k + 1 + i, T, 0);\n      for (int j = 1; j <= n; ++j) {\n        if (l[i] <= x[j] && x[j] <= r[i])\n          mcmf.addEdge(n * 2 + 1 + i, j * 2, 0);\n        if (d[i] <= y[j] && y[j] <= u[i])\n          mcmf.addEdge(j * 2 + 1, n * 2 + k + 1 + i, 0);\n      }\n    }\n    auto val = mcmf.mcmf();\n    // cerr << val.first << ' ' << k << ' ' << val.second << '\\n';\n    if (val.first == k) chkMax(ans, ll(k * 1e15 - val.second));\n  }\n  cout << ans << '\\n';\n\n#ifdef LBT\n  LOG(\"Time: %dms\\n\", int ((clock()\n      -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\n  _|_|                              _|  _|    _|\n_|    _|  _|  _|_|  _|_|_|_|        _|  _|  _|\n_|    _|  _|_|          _|          _|  _|_|\n_|    _|  _|          _|      _|    _|  _|  _|\n  _|_|    _|        _|_|_|_|    _|_|    _|    _|\n\n*/\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<set>\n//#define ls (rt<<1)\n//#define rs (rt<<1|1)\n#define vi vector<int>\n#define pb push_back\n#define mk make_pair\n#define pii pair<ll,ll>\n#define rep(i,a,b) for(int i=(a),i##end=(b);i<=i##end;i++)\n#define fi first\n#define se second\n#define int long long\ntypedef long long ll;\nusing namespace std;\nconst int maxn=420;\nconst int inf=1e18+100;\nint xl[maxn],xr[maxn],yl[maxn],yr[maxn],s=415,t=416;\nint head[maxn],cnt=1;\nstruct gg{\n    int u,v,w;ll cost;int next;\n    void insert(int U,int V,int W,ll Cost,int Next){\n        u=U,v=V,w=W,cost=Cost,next=Next;\n    }\n}side[720*720*2];\nstruct Point{\n    int x,y;\n    ll cost=0;\n}point[maxn];\nstruct Lim{\n    int a,b;char c;\n}lim[maxn];\nvoid ins(int u,int v,int w,ll cost){\n    side[++cnt].insert(u,v,w,cost,head[u]);head[u]=cnt;\n    side[++cnt].insert(v,u,0,-cost,head[v]);head[v]=cnt;\n}\nint n,m;\nvoid init(int k){\n   rep(i,1,k)xl[i]=yl[i]=-inf,xr[i]=yr[i]=inf;\n   rep(i,1,m){\n       if(lim[i].c=='L')rep(j,lim[i].b+1,k)xl[j]=max(xl[j],lim[i].a+1);\n       else if(lim[i].c=='R')for(int j=k-lim[i].b;j>0;j--)xr[j]=min(xr[j],lim[i].a-1);\n       else if(lim[i].c=='D')rep(j,lim[i].b+1,k)yl[j]=max(yl[j],lim[i].a+1);\n       else if(lim[i].c=='U')for(int j=k-lim[i].b;j>0;j--)yr[j]=min(yr[j],lim[i].a-1);\n   }\n   memset(head,0,sizeof(head));cnt=1;\n   rep(i,1,k)ins(s,2*n+i,1,0);\n   rep(i,1,k)ins(2*n+k+i,t,1,0);\n   rep(i,1,n){\n        ins(i,n+i,1,point[i].cost);\n        rep(j,1,k){\n            if(xl[j]<=point[i].x&&point[i].x<=xr[j])ins(2*n+j,i,1,0);\n            if(yl[j]<=point[i].y&&point[i].y<=yr[j])ins(n+i,2*n+k+j,1,0);\n        }\n   }\n}\nint rk[maxn],q[maxn];\nll dis[maxn],lenth;\nbool vis[maxn];\nbool spfa(){\n    rep(i,1,maxn-1)dis[i]=-inf;\n    memset(vis,0,sizeof(vis));\n    int hd=1,tl=1;q[hd]=s;vis[s]=1;dis[s]=0;\n    while(hd<=tl){\n        int u=q[hd++];vis[u]=0;//cout<<u<<' '<<endl;\n        for(int i=head[u];i;i=side[i].next){\n            int v=side[i].v;if(!side[i].w)continue;\n            if(dis[u]+side[i].cost>dis[v]){\n                dis[v]=dis[u]+side[i].cost;\n                if(!vis[v])q[++tl]=v;\n                vis[v]=1;\n            }\n        }\n    }\n    if(dis[t]!=-inf)return 1;\n    return 0;\n}\nint dfs(int u,int flow){\n    if(u==t)return flow;\n    vis[u]=1;int tot=0;\n    for(int i=head[u];i;i=side[i].next){\n        int v=side[i].v;if(vis[v]||!side[i].w||dis[v]!=dis[u]+side[i].cost)continue;\n        int sent=dfs(v,min(flow,side[i].w));\n        lenth+=1ll*side[i].cost*sent,side[i].w-=sent,side[i^1].w+=sent,tot+=sent;flow-=sent;\n    }\n   // vis[u]=0;\n    return tot;\n}\npii dinic(){\n    int mxflow=0;lenth=0;\n    while(spfa()){\n        int x;\n        while((x=dfs(s,inf)))mxflow+=x;\n    }\n    return mk(mxflow,lenth);\n}\nchar tmp[3];\nsigned main(){\n    scanf(\"%lld\",&n);\n    rep(i,1,n)scanf(\"%lld%lld%lld\",&point[i].x,&point[i].y,&point[i].cost);\n    scanf(\"%lld\",&m);\n    rep(i,1,m){\n        scanf(\"%s%lld%lld\",tmp+1,&lim[i].a,&lim[i].b);lim[i].c=tmp[1];\n    }\n    ll out=0;\n    rep(k,1,n){\n        init(k);\n        pii ans=dinic();out=max(out,ans.se);//cout<<ans.se<<endl;\n    }\n    cout<<out;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nint S=0,T;\nint N;\nstruct edge{\n\tint s,t,cap;long long v;int nxt;\n}e[50005];\nint e_cnt,last[405];\nvoid addedge(int u,int v,int cap,long long l){\n\te[e_cnt]=(edge){u,v,cap,l,last[u]};\n\tlast[u]=e_cnt++;\n\te[e_cnt]=(edge){v,u,0,-l,last[v]};\n\tlast[v]=e_cnt++;\n}\nlong long d[405];int fa[405];\nbool vis[405];\n#define LIM -(1000000000000001ll)\nbool dij(){\n\tfor(int i=0;i<=T;i++)d[i]=LIM;\n\tmemset(vis,0,sizeof(vis));\n\td[S]=0;\n\tfor(int i=0;i<=T;i++){\n\t\tint x=-1;\n\t\tfor(int j=0;j<=T;j++)if(!vis[j]&&(x==-1||d[j]>d[x]))x=j;\n\t\tif(x==-1||d[x]==LIM)break;\n\t\tvis[x]=1;\n\t\tfor(int i=last[x];i!=-1;i=e[i].nxt)if(!vis[e[i].t]&&e[i].cap&&d[e[i].t]<d[x]+e[i].v){\n\t\t\t// assert(e[i].v<=0);\n\t\t\td[e[i].t]=d[x]+e[i].v;\n\t\t\tfa[e[i].t]=i;\n\t\t}\n\t}\n\treturn d[T]>LIM;\n}\npair<int,long long> solve(){\n\tint flow=0;long long cost=0;long long r=0;\n\twhile(dij()){\n\t\tflow++;\n\t\tint u=T;\n\t\twhile(u!=S){\n\t\t\te[fa[u]].cap=0;\n\t\t\te[fa[u]^1].cap=1;\n\t\t\tu=e[fa[u]].s;\n\t\t}\n\t\tr+=d[T];\n\t\tcost+=r;\n\t\tfor(int i=0;i<e_cnt;i++)e[i].v=d[e[i].s]+e[i].v-d[e[i].t];\n\t}\n\treturn make_pair(flow,cost);\n}\nint x[85],y[85];long long v[85];\nint t[325],a[325],b[325];\nint L[85][2],R[85][2];\nint main(){\n\t// freopen(\"e.in\",\"r\",stdin);\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d%d%lld\",&x[i],&y[i],&v[i]);\n\t}\n\tint m;\n\tscanf(\"%d\",&m);\n\tfor(int i=1;i<=m;i++){\n\t\tchar c=getchar();\n\t\twhile(c<'A'||c>'Z')c=getchar();\n\t\tif(c=='L')t[i]=0;\n\t\tif(c=='R')t[i]=1;\n\t\tif(c=='D')t[i]=2;\n\t\tif(c=='U')t[i]=3;\n\t\tscanf(\"%d%d\",&a[i],&b[i]);\n\t}\n\tlong long ans=0;\n\tfor(int supy=1;supy<=n;supy++){\n\t\tmemset(R,63,sizeof(R));\n\t\tfor(int j=1;j<=m;j++)if(b[j]<supy){\n\t\t\tif(t[j]&1)R[supy-b[j]][t[j]>>1]=min(R[supy-b[j]][t[j]>>1],a[j]-1);\n\t\t\telse L[b[j]+1][t[j]>>1]=max(L[b[j]+1][t[j]>>1],a[j]+1);\n\t\t}\n\t\tfor(int i=2;i<=supy;i++)for(int j=0;j<2;j++)L[i][j]=max(L[i][j],L[i-1][j]);\n\t\tfor(int i=supy-1;i>0;i--)for(int j=0;j<2;j++)R[i][j]=min(R[i][j],R[i+1][j]);\n\t\t// for(int i=1;i<=supy;i++)printf(\"%d %d\\n\",L[i][0],R[i][0]);\n\t\t// for(int i=1;i<=supy;i++)printf(\"%d %d\\n\",L[i][1],R[i][1]);\n\t\tT=2*supy+2*n+1;\n\t\te_cnt=0;\n\t\tmemset(last,-1,sizeof(last));\n\t\tfor(int i=1;i<=supy;i++)addedge(S,i,1,0),addedge(i+supy,T,1,0);\n\t\tfor(int i=1;i<=n;i++)addedge(i+2*supy,i+n+2*supy,1,v[i]-1000000000000000ll);\n\t\tfor(int i=1;i<=supy;i++)\n\t\t\tfor(int j=1;j<=n;j++)if(x[j]>=L[i][0]&&x[j]<=R[i][0])addedge(i,j+2*supy,1,0);\n\t\tfor(int i=1;i<=supy;i++)\n\t\t\tfor(int j=1;j<=n;j++)if(y[j]>=L[i][1]&&y[j]<=R[i][1])addedge(j+n+2*supy,i+supy,1,0);\n\t\tpair<int,long long>res=solve();\n\t\t// printf(\"%d %d %lld\\n\",supy,res.first,res.second);\n\t\tres.second+=supy*1000000000000000ll;\n\t\tif(res.first==supy)ans=max(ans,res.second);\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n\n#define fo(i,j,l) for(int i=j;i<=l;++i)\n#define fd(i,j,l) for(int i=j;i>=l;--i)\n#define eps 2e-1\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double db;\nconst ll N=1000;\nconst db sj=5e-20,op=1e1;\n\nint f1[N],f2[N];\nint s1[N],s2[N];\nint w[N];\nll x[N],y[N],v[N];\n\nint n,m,oo,a,b,o2;\ndb c[N],s[N][N];\nint bh[N];\ndb d[N];\nint dl[N];\nint g,gs;\ndb ans=0;\nll da=0;\n\ninline db iabs(db gg)\n{return (gg<0)?(-gg):gg;}\n\ninline void trans(int h,int k)\n{\n\tint u=bh[h]; bh[h]=k;\n\tdb xs=-s[h][k];\n\ts[h][k]=0; s[h][u]=-1;\n\tfo(i,1,g)s[h][i]=s[h][i]/xs;\n\tc[h]=c[h]/xs;\n\tfo(i,1,gs)if(i!=h&&s[i][k]!=0){\n\t\tfo(l,1,g)s[i][l]=s[i][l]+s[i][k]*s[h][l];\n\t\tc[i]=c[i]+c[h]*s[i][k];\n\t\ts[i][k]=0;\n\t}\n\tfo(i,1,g)d[i]=d[i]+d[k]*s[h][i];\n\tans=ans+d[k]*c[h];\n\td[k]=0;\n}\n\ninline int find()\n{\n\tint po=0; d[0]=sj;\n\tfo(i,1,g)if(d[i]>d[po])po=i;\n\treturn po;\n}\n\ninline void Simplex()\n{\n\tint x;\n\twhile((x=find())!=0){\n\t\tdouble zd=(db)1e20;\n\t\tint po=0;\n\t\tfo(i,1,gs)if(s[i][x]<-sj)if(c[i]/(-s[i][x])<zd)zd=c[i]/(-s[i][x]),po=i;\n\t\tif(!po)break;\n\t\ttrans(po,x);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfo(i,1,n){\n\t\tscanf(\"%lld%lld%lld\",&x[i],&y[i],&v[i]);\n\t}\n\tfo(i,1,n)d[i]=v[i]/op;\n\tscanf(\"%d\",&gs); m=gs;\n\tfo(i,1,m){\n\t\tchar ch=' ';\n\t\tfor(;ch!='L'&&ch!='R'&&ch!='U'&&ch!='D';ch=getchar());\n\t\tint aa,bb;\n\t\tscanf(\"%d%d\",&aa,&bb);\n\t\tc[i]=bb;\n\t\tif(ch=='L'){fo(l,1,n)if(x[l]<=aa)s[i][l]=-1;}\n\t\tif(ch=='R'){fo(l,1,n)if(x[l]>=aa)s[i][l]=-1;}\n\t\tif(ch=='D'){fo(l,1,n)if(y[l]<=aa)s[i][l]=-1;}\n\t\tif(ch=='U'){fo(l,1,n)if(y[l]>=aa)s[i][l]=-1;}\t\t\n\t}\n\tfo(i,1,n){\n\t\t++gs; c[gs]=1;\n\t\ts[gs][i]=-1;\n\t}\n\tg=m+n;\n\tSimplex();\n\tll da=(ll)(ans*op+eps);\n\tcout<<da;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\nusing namespace std;\ntypedef long long ll;\nconst ll N=1005,inf=1e18,M=1e6;\nll w[M],ne[M],la[M],len[M],cst[M],t=1;\nll d[M],dep[M],s[M],ans,S,T,vis[M],cur[M];\nvoid alink(ll x,ll y,ll z,ll l){\n\tw[++t]=y;\n\tne[t]=la[x];\n\tla[x]=t;\n\tlen[t]=z;\n\tcst[t]=l;\n}\nvoid link(ll x,ll y,ll z,ll l){\n\talink(x,y,z,l);\n\talink(y,x,0,-l);\n}\nvoid clear(){\n\tfor (ll i=1;i<=T;i++)la[i]=0;\n\tt=1;\n}\nll spfa(){\n\tfor (ll i=1;i<=T;i++)s[i]=-inf,vis[i]=0;\n\tll l=0,r=1;\n\ts[S]=0,d[1]=S,vis[S]=1;\n\twhile (l<r){\n\t\tll x=d[++l];\n\t\tfor (ll y=la[x];y;y=ne[y]){\n\t\t\tll z=w[y];\n\t\t\tif (s[z]<s[x]+cst[y]&&len[y]){\n\t\t\t\ts[z]=s[x]+cst[y];\n\t\t\t\tif (!vis[z]){\n\t\t\t\t\td[++r]=z;\n\t\t\t\t\tvis[z]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvis[x]=0;\n\t}\n\tl=0,r=1;vis[S]=1;\n\twhile (l<r){\n\t\tll x=d[++l];\n\t\tcur[x]=la[x];\n\t\tfor (ll y=la[x];y;y=ne[y]){\n\t\t\tll z=w[y];\n\t\t\tif (s[z]==s[x]+cst[y]&&len[y]&&!vis[z]){\n\t\t\t\tdep[z]=dep[x]+1;\n\t\t\t\tvis[z]=1;\n\t\t\t\td[++r]=z;\n\t\t\t}\n\t\t}\n\t}\n\treturn vis[T];\n}\nll flow(ll x,ll val){\n\tif (x==T)return val;\n\tll v1=val;\n\tfor (ll y=cur[x];y;cur[x]=y=ne[y]){\n\t\tll z=w[y];\n\t\tif (dep[z]!=dep[x]+1||!len[y]||s[z]!=s[x]+cst[y])continue;\n\t\tll use=flow(z,min(len[y],val));\n\t\tval-=use;\n\t\tlen[y]-=use;\n\t\tlen[y^1]+=use;\n\t\tans+=use*cst[y];\n\t\tif (!val)return v1;\n\t}return v1-val;\n}\nll n,px[N],py[N],val[N];\nll L[N],R[N],U[N],D[N];\nll ty[N],lim[N],lc[N],k;\nll z1[N],z2[N],c1[N],c2[N];\nint main(){\n\tcin>>n;\n\tfor (ll i=1;i<=n;i++)scanf(\"%lld%lld%lld\",&px[i],&py[i],&val[i]);\n\tcin>>k;\n\tfor (ll i=1;i<=k;i++){\n\t\tscanf(\"\\n\");\n\t\tty[i]=getchar();\n\t\tscanf(\"%lld%lld\",&lc[i],&lim[i]);\n\t}\n\tt=0;\n\tfor (ll i=1;i<=n;i++)\n\t\tz1[i]=++t,z2[i]=++t,L[i]=0,R[i]=100,U[i]=100,D[i]=0,c1[i]=++t,c2[i]=++t;\n\tS=++t,T=++t;t=1;\n\tll max1=0;\n\tfor (ll K=1;K<=n;K++){\n\t\tfor (ll i=1;i<=n;i++)\n\t\t\tL[i]=0,R[i]=100,U[i]=100,D[i]=0;\n\t\tans=0;clear();\n\t\tfor (ll i=1;i<=k;i++){\n\t\t\tif (ty[i]=='L'){\n\t\t\t\tfor (ll j=lim[i]+1;j<=K;j++)\n\t\t\t\t\tL[j]=max(L[j],lc[i]+1);\n\t\t\t}\n\t\t\tif (ty[i]=='R'){\n\t\t\t\tfor (ll j=1;j<=K-lim[i];j++)\n\t\t\t\t\tR[j]=min(R[j],lc[i]-1);\n\t\t\t}\n\t\t\tif (ty[i]=='U'){\n\t\t\t\tfor (ll j=1;j<=K-lim[i];j++)\n\t\t\t\t\tU[j]=min(U[j],lc[i]-1);\n\t\t\t}\n\t\t\tif (ty[i]=='D'){\n\t\t\t\tfor (ll j=lim[i]+1;j<=K;j++)\n\t\t\t\t\tD[j]=max(D[j],lc[i]+1);\n\t\t\t}\n\t\t}\n\t\tfor (ll i=1;i<=K;i++)link(S,z1[i],1,0),link(z2[i],T,1,0);\n\t\tfor (ll i=1;i<=K;i++){\n\t\t\tfor (ll j=1;j<=n;j++){\n\t\t\t\tif (L[i]<=px[j]&&px[j]<=R[i])\n\t\t\t\t\tlink(z1[i],c1[j],1,0);\n\t\t\t\tif (D[i]<=py[j]&&py[j]<=U[i])\n\t\t\t\t\tlink(c2[j],z2[i],1,0);\n\t\t\t}\n\t\t}\n\t\tfor (ll i=1;i<=n;i++)link(c1[i],c2[i],1,val[i]);\n\t\twhile (spfa()){\n\t\t\tif (s[T]>0)flow(S,1<<30);\n\t\t\telse break;\n\t\t}\n\t\tmax1=max(max1,ans);\n\t}\n\tcout<<max1<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "//Zory-2019\n#include<cmath>\n#include<ctime>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<map>\n#include<set>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<bitset>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<deque>\nusing namespace std;\nnamespace mine\n{\n\ttypedef long long ll;\n\t#define double long double\n\tconst int INF=0x3f3f3f3f;\n\tconst ll LLINF=0x3f3f3f3f3f3f3f3fll;\n\tll qread()\n\t{\n\t\tll ans=0;char c=getchar();int f=1;\n\t\twhile(c<'0' or c>'9') {if(c=='-') f=-1;c=getchar();}\n\t\twhile('0'<=c and c<='9') ans=ans*10+c-'0',c=getchar();\n\t\treturn ans*f;\n\t}\n\tvoid write(ll num)\n\t{\n\t\tif(num<0) {num=-num;putchar('-');}\n\t\tif(num>9) write(num/10);\n\t\tputchar('0'+num%10);\n\t}\n\tvoid writeln(int num){write(num);puts(\"\");}\n\t#define FR first\n\t#define SE second\n\t#define MP make_pair\n\t#define pr pair<int,int>\n\t#define PB push_back\n\tinline void chmax(int &x,int y) {x=x>y?x:y;}\n\tinline void chmin(int &x,int y) {x=x<y?x:y;}\n\n\tconst int MAX_N=1100,MAX_M=1e5;\n\tint hou[MAX_N];\n\tstruct Edge{int y,g,c;ll w;}e[MAX_M*2];\n\tint ln=0;int oth(int x){return x&1?x+1:x-1;}\n\tvoid ins(int x,int y,int c,ll w)\n\t{\n\t\tif(c==0) return;\n\t\te[++ln]=(Edge){y,hou[x],c,w};hou[x]=ln;\n\t\te[++ln]=(Edge){x,hou[y],0,-w};hou[y]=ln;\n\t}\n\tint st,ed;queue<int> qq;bool v[MAX_N];\n\tll dis[MAX_N];int fm[MAX_N],mic[MAX_N];\n\tll ans;int flow;\n\tbool solve()\n\t{\n\t\tmemset(dis,-0x3f,sizeof dis);\n\t\tmemset(v,0,sizeof v);v[st]=1;\n\t\tqq.push(st);mic[st]=INF;dis[st]=0;\n\t\twhile(qq.size())\n\t\t{\n\t\t\tint x=qq.front();qq.pop();\n\t\t\tfor(int k=hou[x];k>0;k=e[k].g)\n\t\t\t{\n\t\t\t\tint y=e[k].y;\n\t\t\t\tif(dis[y]<dis[x]+e[k].w and e[k].c)\n\t\t\t\t{\n\t\t\t\t\tdis[y]=dis[x]+e[k].w;\n\t\t\t\t\tmic[y]=min(mic[x],e[k].c);fm[y]=k;\n\t\t\t\t\tif(!v[y]) v[y]=1,qq.push(y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tv[x]=0;\n\t\t}\n\t\tif(mic[ed]==0 or dis[ed]<0) return 0;\n\t\tans+=dis[ed]*mic[ed];flow+=mic[ed];\n\t\tfor(int x=ed;x!=st;x=e[oth(fm[x])].y) e[fm[x]].c-=mic[ed],e[oth(fm[x])].c+=mic[ed];\n\t\treturn 1;\n\t}\n\n\tint n,m;ll val[MAX_N];\n\tpr pt[MAX_N];struct Qes{int a,b;char op[10];}q[MAX_N];\n\tint fl[2][MAX_N],fr[2][MAX_N];\n\tll getans(int T)\n\t{\n\t\tln=0;memset(hou,0,sizeof hou);st=0,ed=n*4+1;\n\t\tfor(int i=1;i<=n;i++) ins(i,n+i,1,val[i]);\n\t\tmemset(fl,0,sizeof fl);memset(fr,0x3f,sizeof fr);fl[0][1]=1;fr[0][T]=100;fl[1][1]=1;fr[1][T]=100;\n\t\tfor(int i=1;i<=m;i++) if(q[i].b<T)\n\t\t{\n\t\t\tif(q[i].op[0]=='L') chmax(fl[0][q[i].b+1],q[i].a+1);\n\t\t\tif(q[i].op[0]=='R') chmin(fr[0][T-q[i].b],q[i].a-1);\n\t\t\tif(q[i].op[0]=='D') chmax(fl[1][q[i].b+1],q[i].a+1);\n\t\t\tif(q[i].op[0]=='U') chmin(fr[1][T-q[i].b],q[i].a-1);\n\t\t}\n\t\tfor(int i=1;i<T;i++) chmax(fl[0][i+1],fl[0][i]);for(int i=T;i>=2;i--) chmin(fr[0][i-1],fr[0][i]);\n\t\tfor(int i=1;i<=T;i++)\n\t\t{\n\t\t\tins(st,n*2+i,1,0);\n\t\t\tfor(int j=1;j<=n;j++) if(fl[0][i]<=pt[j].FR and pt[j].FR<=fr[0][i]) ins(n*2+i,j,1,0)/*,printf(\"%d \",j)*/;\n\t\t\t// puts(\"\");\n\t\t}\n\t\tfor(int i=1;i<T;i++) chmax(fl[1][i+1],fl[1][i]);for(int i=T;i>=2;i--) chmin(fr[1][i-1],fr[1][i]);\n\t\tfor(int i=1;i<=T;i++)\n\t\t{\n\t\t\tins(n*3+i,ed,1,0);\n\t\t\tfor(int j=1;j<=n;j++) if(fl[1][i]<=pt[j].SE and pt[j].SE<=fr[1][i]) ins(n+j,n*3+i,1,0)/*,printf(\"%d \",j)*/;\n\t\t\t// puts(\"\");\n\t\t}\n\t\tans=0;flow=0;while(solve()) ;\n\t\t// printf(\"T=%d flow=%d ans=%lld\\n\",T,flow,ans);\n\t\treturn ans*(flow==T);\n\t}\n\tvoid main()\n\t{\n\t\tn=qread();for(int i=1;i<=n;i++) scanf(\"%d%d%lld\",&pt[i].FR,&pt[i].SE,&val[i]);\n\t\tm=qread();for(int i=1;i<=m;i++) scanf(\"%s%d%d\",q[i].op,&q[i].a,&q[i].b);\n\t\tll ans=0;for(int T=1;T<=n;T++) ans=max(ans,getans(T));\n\t\tprintf(\"%lld\",ans);\n\t}\n};\nint main()\n{\n\tsrand(time(0));\n\tmine::main();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define LL long long\nconst int inf=2147483647;\nint read(){\n\tint x=0,f=1;\n\tchar ch=getchar();\n\twhile (ch<'0' || ch>'9'){\n\t\tif (ch=='-') f=-1;\n\t\tch=getchar();\n\t}\n\twhile (ch>='0' && ch<='9'){\n\t\tx=x*10+ch-'0';ch=getchar();\n\t}\n\treturn x*f;\n}\n#define N 450\n#define M 100010\n#define G 85\n#define Q 325\nstruct edge{\n\tint x,y,d,nxt;LL c;\n}E[M];\nchar op[3];\nstruct pt{\n\tint x,y;LL v;\n}p[G];\nstruct query{\n\tint op,a,b;\n}q[Q];\nint ec[N],tot;\nvoid addE(int x,int y,int d,LL c){\n\ttot++;E[tot].x=x;E[tot].y=y;E[tot].d=d;E[tot].c=c;E[tot].nxt=ec[x];ec[x]=tot;\n}\nvoid addEdge(int x,int y,int d,LL c){\n\taddE(x,y,d,c);addE(y,x,0,-c);\n}\nint n,m,S,T;\nLL f[N];int pre[N];bool vis[N];\nbool spfa(){\n\tmemset(f,-63,sizeof(f));f[S]=0;\n\tmemset(vis,0,sizeof(vis));\n\tqueue <int> q;q.push(S);\n\twhile (!q.empty()){\n\t\tint x=q.front();q.pop();vis[x]=false;\n\t\tfor (int i=ec[x];i;i=E[i].nxt){\n\t\t\tint y=E[i].y;\n\t\t\tif (E[i].d>0 && f[x]+E[i].c>f[y]){\n\t\t\t\tpre[y]=i;f[y]=f[x]+E[i].c;\n\t\t\t\tif (!vis[y]) vis[y]=true,q.push(y);\n\t\t\t} \n\t\t}\n\t}\n\tif (f[T]>0) return true;\n\telse return false;\n}\nLL ans2,ans=0;\nvoid work(){\n\tint x=T;\n\twhile (x!=S){\n\t\tans2+=E[pre[x]].c;\n\t\tE[pre[x]].d--;E[pre[x]^1].d++;x=E[pre[x]].x;\n\t}\n}\nint lx[G],rx[G],ly[G],ry[G];\nvoid solve(int k){\n\tmemset(ec,0,sizeof(ec));tot=1;\n\tfor (int i=1;i<=n;++i) addEdge(p[i].x,200+i,1,p[i].v),addEdge(200+i,100+p[i].y,1,0);\n\tfor (int i=1;i<=k;++i) lx[i]=ly[i]=1,rx[i]=ry[i]=100;\n\tfor (int i=1;i<=m;++i){\n\t\tif (q[i].op==0) lx[q[i].b+1]=max(lx[q[i].b+1],q[i].a+1);\n\t\tif (q[i].op==1 && k>q[i].b) rx[k-q[i].b]=min(rx[k-q[i].b],q[i].a-1);\n\t\tif (q[i].op==2) ly[q[i].b+1]=max(ly[q[i].b+1],q[i].a+1);\n\t\tif (q[i].op==3 && k>q[i].b) ry[k-q[i].b]=min(ry[k-q[i].b],q[i].a-1);\n\t}\n\tfor (int i=2;i<=k;++i) lx[i]=max(lx[i],lx[i-1]),ly[i]=max(ly[i],ly[i-1]);\n\tfor (int i=k-1;i;--i) rx[i]=min(rx[i],rx[i+1]),ry[i]=min(ry[i],ry[i+1]);\n\tS=200+n+2*k+1,T=S+1;\n\tfor (int i=1;i<=k;++i){\n\t\tif (lx[i]>rx[i] || ly[i]>ry[i]) return;\n\t\taddEdge(S,200+n+i,1,0);addEdge(200+n+k+i,T,1,0);\n\t\tfor (int j=lx[i];j<=rx[i];++j) addEdge(200+n+i,j,1,0);\n\t\tfor (int j=ly[i];j<=ry[i];++j) addEdge(100+j,200+n+k+i,1,0);\n\t}\n\tint cnt=0;ans2=0;\n\twhile (spfa()) cnt++,work();\n\tif (cnt!=k) return;\n\tans=max(ans,ans2);\n}\nsigned main(){\n\tn=read();for (int i=1;i<=n;++i) p[i].x=read(),p[i].y=read(),p[i].v=read();\n\tm=read();\n\tfor (int i=1;i<=m;++i){\n\t\tscanf(\"%s\",op);\n\t\tq[i].a=read();q[i].b=read();\n\t\tif (op[0]=='L') q[i].op=0;\n\t\tif (op[0]=='R') q[i].op=1;\n\t\tif (op[0]=='D') q[i].op=2;\n\t\tif (op[0]=='U') q[i].op=3;\n\t}\t\n\tfor (int i=1;i<=n;++i) solve(i);\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <list>\n#include <time.h>\n#include <math.h>\n#include <random>\n#include <deque>\n#include <queue>\n#include <cassert>\n#include <unordered_map>\n#include <unordered_set>\n#include <iomanip>\n#include <bitset>\n#include <sstream>\n#include <chrono>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef long double dbl;\nconst int INF = 1.01e9;\n \nconst long double EPS = 1e-18;\nbool eq(long double x, long double y) {\n    return fabs(x - y) < EPS;\n}\nbool ls(long double x, long double y) {\n    return x < y && !eq(x, y);\n}\n \nvector<long double> simplex(vector<vector<long double> > a) {\n    int n = a.size() - 1;\n    int m = a[0].size() - 1;\n    vector<int> left(n + 1), up(m + 1);\n    iota(up.begin(), up.end(), 0);\n    iota(left.begin(), left.end(), m);\n    auto pivot = [&](int x, int y) {\n        swap(left[x], up[y]);\n        long double k = a[x][y];\n        a[x][y] = 1;\n        vector<int> vct;\n        for (int j = 0; j <= m; j++) {\n            a[x][j] /= k;\n            if (!eq(a[x][j], 0)) vct.push_back(j);\n        }\n        for (int i = 0; i <= n; i++) {\n            if (eq(a[i][y], 0) || i == x) continue;\n            k = a[i][y];\n            a[i][y] = 0;\n            for (int j : vct) a[i][j] -= k * a[x][j];\n        }\n    };\n    while (1) {\n        int x = -1;\n        for (int i = 1; i <= n; i++) if (ls(a[i][0], 0) && (x == -1 || a[i][0] < a[x][0])) x = i;\n        if (x == -1) break;\n        int y = -1;\n        for (int j = 1; j <= m; j++) if (ls(a[x][j], 0) && (y == -1 || a[x][j] < a[x][y])) y = j;\n        if (y == -1) assert(0); // infeasible\n        pivot(x, y);\n    }\n    while (1) {\n        int y = -1;\n        for (int j = 1; j <= m; j++) if (ls(0, a[0][j]) && (y == -1 || a[0][j] > a[0][y])) y = j;\n        if (y == -1) break;\n        int x = -1;\n        for (int i = 1; i <= n; i++) if (ls(0, a[i][y]) && (x == -1 || a[i][0] / a[i][y] < a[x][0] / a[x][y])) x = i;\n        if (x == -1) assert(0); // unbounded\n        pivot(x, y);\n    }\n    vector<long double> ans(m + 1);\n    for (int i = 1; i <= n; i++) if (left[i] <= m) ans[left[i]] = a[i][0];\n    ans[0] = -a[0][0];\n    return ans;\n}\n\n#ifdef ONPC\n  mt19937 rnd(228);\n#else\n  mt19937 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\n#endif\n\nint main()\n{\n#ifdef ONPC\n  freopen(\"a.in\", \"r\", stdin);\n#endif\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector <int> x(n), y(n);\n  vector <ll> ok;\n  vector <long double> v;\n  vector <pair <ll, int> > e;\n  for (int i = 0; i < n; i++)\n  {\n    cin >> x[i] >> y[i];\n    ll x;\n    cin >> x;\n    ok.push_back(x);\n    v.push_back(x);\n    e.push_back({x, i});\n  }\n  v.insert(v.begin(), 0);\n  int m;\n  cin >> m;\n  vector <vector <long double> > mat;\n  mat.push_back(v);\n  for (int i = 0; i < n; i++)\n  {\n    vector <long double> kek(n + 1);\n    kek[0] = kek[i + 1] = 1;\n    mat.push_back(kek);\n  }\n  vector <vector <int> > simp;\n  for (int i = 0; i < m; i++)\n  {\n    char c;\n    cin >> c;\n    int a;\n    int b;\n    cin >> a >> b;\n    vector <long double> arr = {(long double) b};\n    vector <int> kek = {b};\n    for (int j = 0; j < n; j++)\n    {\n      int grab = 0;\n      if (c == 'L' && x[j] <= a) grab = 1;\n      if (c == 'R' && x[j] >= a) grab = 1;\n      if (c == 'D' && y[j] <= a) grab = 1;\n      if (c == 'U' && y[j] >= a) grab = 1;\n      arr.push_back(grab);\n      kek.push_back(grab);\n    }\n    mat.push_back(arr);\n    simp.push_back(kek);\n  }\n  auto ret = simplex(mat);\n  vector <int> grab;\n  for (int i = 1; i < (int) ret.size(); i++)\n  {\n    if (ret[i] >= 0.5)\n    {\n      grab.push_back(1);\n    }\n    else\n    {\n      grab.push_back(0);\n    }\n  }\n  sort(e.begin(), e.end());\n  auto good = [&] (vector <int> grab)\n  {\n    for (auto c : simp)\n    {\n      int sum = 0;\n      for (int i = 1; i <= n; i++) sum += grab[i - 1] * c[i];\n      if (sum > c[0])\n      {\n        return false;\n      }\n    }\n    return true;\n  };\n  auto f = [&] (vector <int> grab)\n  {\n    ll sum = 0;\n    for (int i = 0; i < n; i++)\n    {\n      if (grab[i]) sum += ok[i];\n    }\n    return sum;\n  };\n  for (int i = 0; i < (int) e.size(); i++)\n  {\n    if (grab[e[i].second] && !good(grab))\n    {\n      grab[e[i].second] = 0;\n    }\n  }\n  bool ch = true;\n  while (ch)\n  {\n    ch = false;\n    for (int i = (int) e.size() - 1; i >= 0; i--)\n    {\n      if (!grab[e[i].second])\n      {\n        grab[e[i].second] = true;\n        if (good(grab))\n        {\n          ch = true;\n        }\n        else\n        {\n          grab[e[i].second] = false;\n        }\n      }\n    }\n    if (!ch)\n    {\n      for (int i = 0; i < (int) e.size(); i++)\n      {\n        for (int j = i + 1; j < (int) e.size(); j++)\n        {\n          if (e[i].first < e[j].first && grab[e[i].second] && !grab[e[j].second])\n          {\n            auto x = grab;\n            swap(x[e[i].second], x[e[j].second]);\n            if (good(x))\n            {\n              grab = x;\n              ch = true;\n            }\n          }\n        }\n      }\n    }\n  }\n  ll best = f(grab);\n  while (clock() / (double) CLOCKS_PER_SEC <= 4)\n  {\n    vector <int> perm(n);\n    for (int i = 0; i < n; i++) perm[i] = i;\n    shuffle(perm.begin(), perm.end(), rnd);\n    vector <int> grab(n);\n    for (int i : perm)\n    {\n      grab[i] = true;\n      if (!good(grab)) grab[i] = false;\n    }\n    bool ch = true;\n    while (ch)\n    {\n      ch = false;\n      for (int i = (int) e.size() - 1; i >= 0; i--)\n      {\n        if (!grab[e[i].second])\n        {\n          grab[e[i].second] = true;\n          if (good(grab))\n          {\n            ch = true;\n          }\n          else\n          {\n            grab[e[i].second] = false;\n          }\n        }\n      }\n      if (!ch)\n      {\n        for (int i = 0; i < (int) e.size(); i++)\n        {\n          for (int j = i + 1; j < (int) e.size(); j++)\n          {\n            if (e[i].first < e[j].first && grab[e[i].second] && !grab[e[j].second])\n            {\n              auto x = grab;\n              swap(x[e[i].second], x[e[j].second]);\n              if (good(x))\n              {\n                grab = x;\n                ch = true;\n              }\n            }\n          }\n        }\n      }\n    }\n    best = max(best, f(grab));\n  }\n  cout << best << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 1000005\nint tot,last[N],to[N],Next[N],flow[N];\nlong long val[N],dis[N];\nint e[N],q[10000005],S,T,Lx[N],Rx[N],Ly[N],Ry[N];\nint X[N],Y[N],n,m,pre[N];\nstruct node {\n  \tint id,x,y;\n}b[N],A[N];\nstruct pa {\n  \tint x;\n  \tlong long y;\n}a[N];\ninline void add(int x,int y,int f,long long v) {\n  Next[++tot]=last[x]; last[x]=tot; to[tot]=y; flow[tot]=f; val[tot]=v;\n}\n#define inf 1000000000000000000ll\ninline bool spfa() {\n  \tfor (int i=S;i<=T;i++) dis[i]=inf,e[i]=0;\n  \tdis[S]=0; e[S]=1;\n  \tint l=0,r=1; q[1]=S;\n  \twhile (l<r) {\n      \tint k=q[++l];\n      \tfor (int i=last[k];i;i=Next[i]) {\n          \tif (!flow[i]||dis[to[i]]<=dis[S]+val[i]) continue;\n          \tdis[to[i]]=dis[S]+val[i];\n          \tpre[to[i]]=i;\n          \tif (!e[to[i]]) e[q[++r]=to[i]]=1;\n        }\n      \te[k]=0;\n    }\n  \treturn dis[T]!=inf;\n}\ninline long long dinic(int y) {\n  \tlong long ans=0;\n  \tint s=0;\n  \twhile (spfa()) {\n      \ts++;\n      \tfor (int x=T;x!=S;x=to[pre[x]^1]) flow[pre[x]]--,flow[pre[x]^1]++,ans+=val[pre[x]];\n    }\n  \tif (s!=y) return 0;\n  \treturn ans;\n}\ninline long long work(int x) {\n  for (int i=1;i<=m;i++) if (b[i].id&1) A[i]=b[i];\n  else A[i]=node{b[i].id,x-b[i].x,b[i].y+1};\n  for (int i=1;i<=x;i++) X[i]=2*n+i,Y[i]=2*n+i+x;\n  S=0,T=Y[x]+1;\n  for (int i=S;i<=T;i++) last[i]=0;\n  tot=1;\n  for (int i=1;i<=x;i++) Lx[i]=Ly[i]=1,Rx[i]=Ry[i]=100;\n  for (int i=1;i<=m;i++) {\n    if (A[i].id==1) Lx[A[i].x+1]=max(Lx[A[i].x+1],A[i].y+1);\n    else if (A[i].id==2) Rx[A[i].x]=min(Rx[A[i].x],A[i].y);\n    else if (A[i].id==3) Ly[A[i].x+1]=max(Ly[A[i].x+1],A[i].y+1);\n    else Ry[A[i].x]=min(Ry[A[i].x],A[i].y);\n  }\n  for (int i=1;i<=x;i++) Lx[i]=max(Lx[i],Lx[i-1]),Ly[i]=max(Ly[i],Ly[i-1]);\n  for (int i=x-1;i;i--) Rx[i]=min(Rx[i],Rx[i+1]),Ry[i]=min(Ry[i],Ry[i+1]);\n  for (int i=1;i<=x;i++) if (Lx[i]>Rx[i]) return false;\n  for (int i=1;i<=x;i++) add(S,X[i],1,0),add(X[i],S,0,0),add(Y[i],T,1,0),add(T,Y[i],0,0);\n  for (int i=1;i<=x;i++) \n  for (int j=1;j<=n;j++) {\n    \tif (a[j].x>=Lx[i]&&a[j].x<=Rx[i]) add(X[i],j,1,0),add(j,X[i],0,0);\n    \tif (a[j].y>=Ly[i]&&a[j].y<=Ry[i]) add(j+n,Y[i],1,0),add(Y[i],j+n,0,0);\n  }\n  for (int i=1;i<=n;i++) add(i,i+n,1,a[i].y),add(i+n,i,0,-a[i].y);\n  return dinic(x);\n}\nchar c[15];\nint main() {\n  scanf(\"%d\",&n);\n  for (int i=1;i<=n;i++) scanf(\"%d%lld\",&a[i].x,&a[i].y);\n  scanf(\"%d\",&m);\n  for (int i=1;i<=m;i++) {\n    \tscanf(\"%s\",c);\n    \tscanf(\"%d%d\",&b[i].x,&b[i].y);\n    \tif (c[0]=='L') b[i].id=1;\n    \tif (c[0]=='R') b[i].id=2;\n    \tif (c[0]=='D') b[i].id=3;\n    \tif (c[0]=='U') b[i].id=4;\n  }\n  long long ans=0;\n  for (int i=1;i<=n;i++) ans=max(ans,work(i));\n  printf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <list>\n#include <time.h>\n#include <math.h>\n#include <random>\n#include <deque>\n#include <queue>\n#include <cassert>\n#include <unordered_map>\n#include <unordered_set>\n#include <iomanip>\n#include <bitset>\n#include <sstream>\n#include <chrono>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef long double dbl;\nconst int INF = 1.01e9;\n \nconst long double EPS = 1e-18;\nbool eq(long double x, long double y) {\n    return fabs(x - y) < EPS;\n}\nbool ls(long double x, long double y) {\n    return x < y && !eq(x, y);\n}\n \nvector<long double> simplex(vector<vector<long double> > a) {\n    int n = a.size() - 1;\n    int m = a[0].size() - 1;\n    vector<int> left(n + 1), up(m + 1);\n    iota(up.begin(), up.end(), 0);\n    iota(left.begin(), left.end(), m);\n    auto pivot = [&](int x, int y) {\n        swap(left[x], up[y]);\n        long double k = a[x][y];\n        a[x][y] = 1;\n        vector<int> vct;\n        for (int j = 0; j <= m; j++) {\n            a[x][j] /= k;\n            if (!eq(a[x][j], 0)) vct.push_back(j);\n        }\n        for (int i = 0; i <= n; i++) {\n            if (eq(a[i][y], 0) || i == x) continue;\n            k = a[i][y];\n            a[i][y] = 0;\n            for (int j : vct) a[i][j] -= k * a[x][j];\n        }\n    };\n    while (1) {\n        int x = -1;\n        for (int i = 1; i <= n; i++) if (ls(a[i][0], 0) && (x == -1 || a[i][0] < a[x][0])) x = i;\n        if (x == -1) break;\n        int y = -1;\n        for (int j = 1; j <= m; j++) if (ls(a[x][j], 0) && (y == -1 || a[x][j] < a[x][y])) y = j;\n        if (y == -1) assert(0); // infeasible\n        pivot(x, y);\n    }\n    while (1) {\n        int y = -1;\n        for (int j = 1; j <= m; j++) if (ls(0, a[0][j]) && (y == -1 || a[0][j] > a[0][y])) y = j;\n        if (y == -1) break;\n        int x = -1;\n        for (int i = 1; i <= n; i++) if (ls(0, a[i][y]) && (x == -1 || a[i][0] / a[i][y] < a[x][0] / a[x][y])) x = i;\n        if (x == -1) assert(0); // unbounded\n        pivot(x, y);\n    }\n    vector<long double> ans(m + 1);\n    for (int i = 1; i <= n; i++) if (left[i] <= m) ans[left[i]] = a[i][0];\n    ans[0] = -a[0][0];\n    return ans;\n}\n\n#ifdef ONPC\n  mt19937 rnd(228);\n#else\n  mt19937 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\n#endif\n\nint main()\n{\n#ifdef ONPC\n  freopen(\"a.in\", \"r\", stdin);\n#endif\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector <int> x(n), y(n);\n  vector <ll> ok;\n  vector <long double> v;\n  vector <pair <ll, int> > e;\n  for (int i = 0; i < n; i++)\n  {\n    cin >> x[i] >> y[i];\n    ll x;\n    cin >> x;\n    ok.push_back(x);\n    v.push_back(x);\n    e.push_back({x, i});\n  }\n  v.insert(v.begin(), 0);\n  int m;\n  cin >> m;\n  vector <vector <long double> > mat;\n  mat.push_back(v);\n  for (int i = 0; i < n; i++)\n  {\n    vector <long double> kek(n + 1);\n    kek[0] = kek[i + 1] = 1;\n    mat.push_back(kek);\n  }\n  vector <vector <int> > simp;\n  for (int i = 0; i < m; i++)\n  {\n    char c;\n    cin >> c;\n    int a;\n    int b;\n    cin >> a >> b;\n    vector <long double> arr = {(long double) b};\n    vector <int> kek = {b};\n    for (int j = 0; j < n; j++)\n    {\n      int grab = 0;\n      if (c == 'L' && x[j] <= a) grab = 1;\n      if (c == 'R' && x[j] >= a) grab = 1;\n      if (c == 'D' && y[j] <= a) grab = 1;\n      if (c == 'U' && y[j] >= a) grab = 1;\n      arr.push_back(grab);\n      kek.push_back(grab);\n    }\n    mat.push_back(arr);\n    simp.push_back(kek);\n  }\n  auto good = [&] (vector <int> grab)\n  {\n    for (auto c : simp)\n    {\n      int sum = 0;\n      for (int i = 1; i <= n; i++) sum += grab[i - 1] * c[i];\n      if (sum > c[0])\n      {\n        return false;\n      }\n    }\n    return true;\n  };\n  auto f = [&] (vector <int> grab)\n  {\n    ll sum = 0;\n    for (int i = 0; i < n; i++)\n    {\n      if (grab[i]) sum += ok[i];\n    }\n    return sum;\n  };\n  vector <int> grab;\n  for (int i = 0; i < n; i++) grab.push_back(0);\n  cout.precision(20);\n  auto solve = [&] ()\n  {\n    auto ret = simplex(mat);\n    sort(e.begin(), e.end());\n    vector <int> me(n);\n    int kek = 0;\n    for (int i = (int) e.size() - 1; i >= 0; i--)\n    {\n      if (!grab[e[i].second] && ret[e[i].second + 1] > EPS)\n      {\n        kek++;\n        me[e[i].second] = true;\n        grab[e[i].second] = true;\n        if (!good(grab)) grab[e[i].second] = false, me[e[i].second] = false;\n      }\n    }\n    int kekos = 0;\n    for (auto &c : mat)\n    {\n      kekos++;\n      if (kekos > n + 1)\n      for (int i = 1; i <= n; i++)\n      {\n        if (me[i - 1] && c[i] > EPS) c[i]--, c[0]--;\n      }\n    }\n    for (int i = 1; i <= n; i++)\n    {\n      if (me[i - 1])\n      {\n        mat[i][0] = 0;\n      }\n    }\n    return kek;\n  };\n  while (solve());\n  bool ch = true;\n  while (ch)\n  {\n    ch = false;\n    for (int i = (int) e.size() - 1; i >= 0; i--)\n    {\n      if (!grab[e[i].second])\n      {\n        grab[e[i].second] = true;\n        if (good(grab))\n        {\n          ch = true;\n        }\n        else\n        {\n          grab[e[i].second] = false;\n        }\n      }\n    }\n    if (!ch)\n    {\n      for (int i = 0; i < (int) e.size(); i++)\n      {\n        for (int j = i + 1; j < (int) e.size(); j++)\n        {\n          for (int k = j + 1; k < (int) e.size(); k++)\n          {\n            if (e[i].first + e[j].first < e[k].first && grab[e[i].second] && grab[e[j].second] && !grab[e[k].second])\n            {\n              auto x = grab;\n              x[e[i].second] = x[e[j].second] = 0;\n              x[e[k].second] = 1;\n              if (good(x))\n              {\n                grab = x;\n                ch = true;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  ll best = f(grab);\n  cout << best << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define N 2010\n#define M 200010\n#define int long long\n#define INF 4611686018427387904LL\ninline int read() {\n    int x=0;\n    char ch=getchar();\n    while (!isdigit(ch)) ch=getchar();\n    while (isdigit(ch)) x=x*10+ch-'0',ch=getchar();\n    return x;\n}\nstruct Point {\n    int x,y,val;\n}p[N];\nstruct opt {\n    char ch; int x,y;\n}a[N];\nint tot=1;\nint fir[N],nex[M],got[M],tak[M],cst[M];\ninline void AddEdge(int x,int y,int z,int w) { \n    nex[++tot]=fir[x],fir[x]=tot,got[tot]=y,tak[tot]=z,cst[tot]=w;\n}\ninline void Add(int x,int y,int z,int w) {\n    AddEdge(x,y,z,w),AddEdge(y,x,0,-w);\n}\nint xl[N],xr[N],yl[N],yr[N];\nint vis[N],dis[N],pre[N],que[N];\ninline int spfa(int s,int t) {\n    int l=1,r=1;\n    for (int i=1;i<=t;i++) vis[i]=false,dis[i]=-INF,pre[i]=0;\n    que[1]=s,dis[s]=0;\n    while (l<=r) {\n        int x=que[l];\n        for (int i=fir[x];i;i=nex[i]) {\n            int y=got[i],w=cst[i];\n            if (!tak[i] || dis[x]+w<=dis[y]) continue;\n            dis[y]=dis[x]+w,pre[y]=i;\n            if (!vis[y]) vis[y]=true,que[++r]=y;\n        }\n        ++l,vis[x]=false;\n    }\n    return dis[t]!=-INF;\n}\ninline int getflow(int s,int t) {\n    int flow=INF;\n    for (int i=t;i!=s;i=got[pre[i]^1]) {\n        flow=min(flow,tak[pre[i]]);\n    }\n    return flow;\n}\ninline void update(int s,int t,int flow,int &Maxflow,int &Mincost) {\n    Maxflow+=flow,Mincost+=flow*dis[t];\n    for (int i=t;i!=s;i=got[pre[i]^1]) {\n        tak[pre[i]]-=flow,tak[pre[i]^1]+=flow;\n    }\n}\ninline int solve(int s,int t) {\n    int Maxflow=0,Mincost=0;\n    while (spfa(s,t)) {\n        update(s,t,getflow(s,t),Maxflow,Mincost);\n    }\n    return Mincost;\n}\nsigned main() {\n    int n=read();\n    for (int i=1;i<=n;i++)\n        p[i].x=read(),p[i].y=read(),p[i].val=read();\n    int m=read(),res=0;\n    for (int i=1;i<=m;i++) {\n        char ch=getchar();\n        while (ch!='U' && ch!='D' && ch!='L' && ch!='R') ch=getchar();\n        a[i].ch=ch,a[i].x=read(),a[i].y=read();\n    }\n    for (int k=1;k<=n;k++) {\n        tot=1,memset(fir,0,sizeof(fir));\n        int s=(k<<1)+(n<<1)+1,t=s+1;\n        for (int i=1;i<=k;i++) Add(s,i,1,0);\n        for (int i=k+2*n+1;i<=2*k+2*n;i++) Add(i,t,1,0);\n        for (int i=k+1;i<=k+n;i++) Add(i,i+n,1,p[i-k].val);\n        for (int i=1;i<=k;i++) xl[i]=yl[i]=0,xr[i]=yr[i]=INF;\n        for (int i=1;i<=m;i++) {\n            if (a[i].ch=='U') for (int j=1;j<=k-a[i].y;j++) yr[j]=min(yr[j],a[i].x-1);\n            if (a[i].ch=='D') for (int j=a[i].y+1;j<=k;j++) yl[j]=max(yl[j],a[i].x+1);\n            if (a[i].ch=='L') for (int j=a[i].y+1;j<=k;j++) xl[j]=max(xl[j],a[i].x+1);\n            if (a[i].ch=='R') for (int j=1;j<=k-a[i].y;j++) xr[j]=min(xr[j],a[i].x-1);\n        }\n        for (int i=1;i<=k;i++) for (int j=1;j<=n;j++)\n            if (xl[i]<=p[j].x && p[j].x<=xr[i]) Add(i,j+k,1,0);\n        for (int i=1;i<=k;i++) for (int j=1;j<=n;j++)\n            if (yl[i]<=p[j].y && p[j].y<=yr[i]) Add(j+k+n,i+k+2*n,1,0);\n        res=max(res,solve(s,t));\n    }\n    cout<<res<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define FIO \"agc31E\"\nusing namespace std;\n\nconst int N=85,M=325,V=1e5,E=4e6,INF=1e9;\n\ntemplate<class T>inline void chkmax(T &a,const T &b){if(a<b)a=b;}\ntemplate<class T>inline void chkmin(T &a,const T &b){if(a>b)a=b;}\n\nint n,m;\nint x[N],y[N];\nll v[N];\nint a[M],b[M];\nchar t[M][2];\n\nint maxflow;\nll maxcost;\n\nint ptr;\nint h[V],to[E],nxt[E],flow[E],ecnt,hh[V];\nll cost[E];\n\ninline void adde(int u,int v,int w,ll x){nxt[++ecnt]=h[u];h[u]=ecnt;to[ecnt]=v;flow[ecnt]=w;cost[ecnt]=x;}\n\ninline void add(int u,int v,int w,ll x){adde(u,v,w,x);adde(v,u,0,-x);}\n\nint lef[N],rig[N],id[N][2],S,T,low[N][2],hig[N][2];\n\nint vis[V];\nll dis[V];\n\ninline void build(int k){\n  memset(h,0,sizeof h);\n  ecnt=1;\n  ptr=0;\n  for(int i=1;i<=n;i++){\n    id[i][0]=++ptr;\n    id[i][1]=++ptr;\n    add(id[i][0],id[i][1],1,v[i]);\n  }\n  for(int i=1;i<=k;i++)\n    lef[i]=++ptr,rig[i]=++ptr;\n  T=++ptr;\n  for(int i=1;i<=k;i++)low[i][0]=low[i][1]=1,hig[i][0]=hig[i][1]=100;\n\n  for(int i=1;i<=m;i++){\n    switch(t[i][0]){\n      case 'L':{\n                 if(b[i]<k)\n                   chkmax(low[b[i]+1][0],a[i]+1);\n                 break;\n               }\n      case 'R':{\n                 if(b[i]<k)\n                   chkmin(hig[k-b[i]][0],a[i]-1);\n                 break;\n               }\n      case 'D':{\n                 if(b[i]<k)\n                   chkmax(low[b[i]+1][1],a[i]+1);\n                 break;\n               }\n      case 'U':{\n                 if(b[i]<k)\n                   chkmin(hig[k-b[i]][1],a[i]-1);\n                 break;\n               }\n    }\n  }\n\n  for(int i=2;i<=k;i++)\n    chkmax(low[i][0],low[i-1][0]),\n    chkmax(low[i][1],low[i-1][1]);\n\n  for(int i=k-1;i;i--)\n    chkmin(hig[i][0],hig[i+1][0]),\n    chkmin(hig[i][1],hig[i+1][1]);\n\n  //for(int i=1;i<=k;i++) printf(\"rk %d x[%d,%d] y[%d][%d]\\n\",i,low[i][0],hig[i][0],low[i][1],hig[i][1]);\n\n  for(int i=1;i<=k;i++)\n    for(int j=1;j<=n;j++){\n      if(x[j]>=low[i][0]&&x[j]<=hig[i][0])\n        add(lef[i],id[j][0],1,0);\n      if(y[j]>=low[i][1]&&y[j]<=hig[i][1])\n        add(id[j][1],rig[i],1,0);\n    }\n\n  for(int i=1;i<=k;i++)add(S,lef[i],1,0),add(rig[i],T,1,0);\n\n}\n\ninline bool spfa(){\n  memset(vis,0,sizeof vis);\n  memset(dis,-0x3f,sizeof dis);\n  dis[S]=0;\n  queue<int>q;\n  q.push(S);\n  vis[S]=1;\n  while(!q.empty()){\n    int u=q.front();q.pop();\n    //printf(\"u=%d\\n\",u);\n    vis[u]=0;\n    for(int i=h[u],v;i;i=nxt[i])if(dis[v=to[i]]<dis[u]+cost[i]&&flow[i]){\n      dis[v]=dis[u]+cost[i];\n      if(!vis[v]){\n        q.push(v);\n        vis[v]=1;\n      }\n    }\n  }\n  //printf(\"dis[T]=%lld dis[ptr+1]=%lld\\n\",dis[T],dis[ptr+1]);\n  return dis[T]>dis[ptr+1];\n}\n\ninline int dfs(int u=S,int lim=INF){\n  if(u==T)return lim;\n  int ret=0;\n  vis[u]=1;\n  for(int &i=hh[u],v;i;i=nxt[i])if(dis[v=to[i]]==dis[u]+cost[i]&&flow[i]&&!vis[v]){\n    int del=dfs(v,min(lim-ret,flow[i]));\n    if(del){\n      ret+=del;\n      flow[i]-=del;\n      flow[i^1]+=del;\n      if(ret==lim)return ret;\n    }\n  }\n  vis[u]=0;\n  return ret;\n}\n\ninline void mcmf(){\n  maxflow=maxcost=0;\n  while(spfa()){\n    memset(vis,0,sizeof vis);\n    memcpy(hh,h,sizeof h);\n    int f=dfs();\n    maxflow+=f;\n    //printf(\"mf+=%lld*%d\\n\",dis[T],f);\n    maxcost+=dis[T]*f;\n  }\n  //printf(\"mf=%d mc=%lld\\n\",maxflow,maxcost);\n}\n\nll ans;\nint main(){\n  scanf(\"%d\",&n);\n  for(int i=1;i<=n;i++)scanf(\"%d%d%lld\",&x[i],&y[i],&v[i]);\n  scanf(\"%d\",&m);\n  for(int i=1;i<=m;i++)scanf(\"%s%d%d\",t[i],&a[i],&b[i]);\n\n  for(int i=1;i<=n;i++){\n    build(i);\n    mcmf();\n    if(maxflow==i)chkmax(ans,maxcost);\n  }\n  printf(\"%lld\\n\",ans);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define TRACE(x) x\n#define WATCH(x) TRACE(cout << #x\" = \" << x << endl)\n#define WATCHR(a, b) TRACE(for (auto it=a; it!=b;) cout << *(it++) << \" \"; cout << endl)\n#define WATCHC(V) TRACE({cout << #V\" = \"; WATCHR(V.begin(), V.end());})\n\n#define all(x) (x).begin(), (x).end()\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate<typename F, typename C> struct min_cost_flow {\n    static constexpr int bits = 63 - __builtin_clzll(numeric_limits<F>::max());\n\n    int V;\n    vvi adj;\n    vi dest;\n    vector<F> cap;\n    vector<C> cost;\n\n    min_cost_flow(int V = 0) : V(V) {\n        adj.resize(V);\n    }\n\n    void __arc(int u, int v, F f, C c) {\n        adj[u].push_back(dest.size());\n        dest.push_back(v);\n        cap.push_back(f);\n        cost.push_back(c);\n    }\n\n    // Inserts a directed edge u --> v with capacity f and cost c.\n    void arc(int u, int v, F f, C c) {\n        __arc(u, v, f, c);\n        __arc(v, u, F(0), -c);\n    }\n\n    bool dijkstra(auto& imb, auto& flow, auto& pot, F delta) {\n        priority_queue<tuple<C, int, int>> q;\n        vi ent(V, -2);\n        vector<C> dist(V, numeric_limits<C>::max());\n        for (int v = 0; v < V; v++) if (imb[v] >= delta)\n            q.push(make_tuple(0., v, -1));\n\n        while (!q.empty()) {\n            C d; int v, f; tie(d, v, f) = q.top(); q.pop();\n            if (ent[v] != -2) continue;\n            dist[v] = -d; ent[v] = f;\n            for (int e : adj[v]) if (cap[e] - flow[e] >= delta)\n                q.push(make_tuple(d - (cost[e] + pot[v] - pot[dest[e]]), dest[e], e ));\n        }\n\n        for (int v = 0; v < V; v++) if (ent[v] != -2 && imb[v] <= -delta) {\n            for (int u = 0; u < V; u++) pot[u] += dist[u];\n            for (int e = ent[v]; ~e; e = ent[dest[e^1]]) {\n                flow[e] += delta;\n                flow[e^1] -= delta;\n                imb[dest[e]] += delta;\n                imb[dest[e^1]] -= delta;\n            }\n            return true;\n        }\n        return false;\n    }\n\n    // O(E^2 * log V * bits)\n    pair<bool, C> solve(vector<F>& imb) {\n        vector<F> flow(cap.size());\n        vector<C> pot(V);\n        for (F delta = 1ll << bits; delta; delta >>= 1) {\n            for (int e = 0; e < dest.size(); e++) {\n                int u = dest[e^1], v = dest[e];\n                F res = cap[e] - flow[e];\n                if (res >= delta && cost[e] + pot[u] - pot[v] < 0) {\n                    flow[e^1] -= res;\n                    flow[e] += res;\n                    imb[u] -= res;\n                    imb[v] += res;\n                }\n            }\n            while (dijkstra(imb, flow, pot, delta));\n        }\n\n        C ans = 0;\n        for (int e = 0; e < dest.size(); e++) if (flow[e] > 0)  {\n            ans += flow[e] * cost[e];\n        }\n        return { imb == vector<F>(V, 0), ans };\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n\n    int N, M;\n    cin >> N;\n\n    vi x(N), y(N); vll val(N);\n    for (int i = 0; i < N; i++) {\n        cin >> x[i] >> y[i] >> val[i];\n    }\n\n    cin >> M;\n    string dir(M, '.'); vi loc(M), qua(M);\n    for (int i = 0; i < M; i++) {\n        cin >> dir[i] >> loc[i] >> qua[i];\n    }\n\n    auto pmin = [](vi& v, int inx, int val) {\n        if (inx >= 0 && inx < v.size()) v[inx] = min(v[inx], val);\n    };\n    auto pmax = [](vi& v, int inx, int val) {\n        if (inx >= 0 && inx < v.size()) v[inx] = max(v[inx], val);\n    };\n    auto best = [&](int K) {\n        vi xlo(K, 1), xhi(K, 100), ylo(K, 1), yhi(K, 100);\n        for (int i = 0; i < M; i++) {\n            if (dir[i] == 'L') pmax(xlo, qua[i], loc[i] + 1);\n            if (dir[i] == 'R') pmin(xhi, K - 1 - qua[i], loc[i] - 1);\n            if (dir[i] == 'D') pmax(ylo, qua[i], loc[i] + 1);\n            if (dir[i] == 'U') pmin(yhi, K - 1 - qua[i], loc[i] - 1);\n        }\n        for (int i = 1; i < K; i++) {\n            xlo[i] = max(xlo[i], xlo[i-1]);\n            ylo[i] = max(ylo[i], ylo[i-1]);\n        }\n        for (int i = K - 2; i >= 0; i--) {\n            xhi[i] = min(xhi[i], xhi[i+1]);\n            yhi[i] = min(yhi[i], yhi[i+1]);\n        }\n\n        const int V = 1 + K + 2 * N + K + 1;\n        const int SRC = 0, XL = 1, JL = 1 + K, YL = 1 + K + 2 * N, SNK = V - 1;\n\n        min_cost_flow<int, ll> g(V);\n        for (int i = 0; i < K; i++) {\n            g.arc(SRC, XL + i, 1, 0);\n            for (int j = 0; j < N; j++) {\n                if (xlo[i] <= x[j] && x[j] <= xhi[i])\n                    g.arc(XL + i, JL + j, 1, 0);\n            }\n            g.arc(YL + i, SNK, 1, 0);\n            for (int j = 0; j < N; j++) {\n                if (ylo[i] <= y[j] && y[j] <= yhi[i])\n                    g.arc(JL + N + j, YL + i, 1, 0);\n            }\n        }\n        const ll MAXV = 1e15;\n        for (int j = 0; j < N; j++) {\n            g.arc(JL + j, JL + N + j, 1, MAXV - val[j]);\n        }\n\n        vi imb(V);\n        imb[SRC] = K;\n        imb[SNK] = -K;\n        auto res = g.solve(imb);\n        return res.first ? MAXV * K - res.second : 0ll;\n    };\n\n    ll ans = 0;\n    for (int k = 1; k <= N; k++)\n        ans = max(ans, best(k));\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 400\n#define N 500\n#define M 100000\n#define T 1000000\n#define ll long long\n#define INF 1000000000000000000LL\nusing namespace std;\nint tx[maxn], ty[maxn], id1[maxn], id2[maxn], s = 1, t = 2, cnt = 2, n, m, edge = 1;\nint head[N], nxt[M], a[M], r[M], dl[T], L[2][maxn], R[2][maxn], c1[maxn], c2[maxn];\nll cost[M], dis[N], val[maxn], res, sum, cur[N], visit[N], id3[2][maxn];\nchar tp[maxn];\nvoid create(int u, int v, int rest, ll money)\n{\n\tedge++; a[edge] = v; nxt[edge] = head[u]; head[u] = edge;\n\tr[edge] = rest; cost[edge] = money;\n}\nvoid build()\n{\n\tint lef = 1, righ = 1;\n\tdl[1] = s;\n\tfor (int i = 1; i <= cnt; i++)\n\t{\n\t\tdis[i] = -INF;\n\t\tcur[i] = head[i];\n\t}\n\tdis[s] = 0; visit[s] = 1;\n\twhile (lef <= righ)\n\t{\n\t\tint u = dl[lef];\n\t\tfor (int i = head[u]; i; i = nxt[i])\n\t\t{\n\t\t\tint v = a[i];\n\t\t\tif (r[i] && dis[u] + cost[i] > dis[v])\n\t\t\t{\n\t\t\t\tdis[v] = dis[u] + cost[i];\n\t\t\t\tif (visit[v] == 0) {visit[v] = 1; dl[++righ] = v;}\n\t\t\t}\n\t\t}\n\t\tlef++; visit[u] = 0;\n\t}\n}\nint dinic(int u, int flow)\n{\n\tif (u == t) {sum += flow * dis[t]; return flow;}\n\tint ans = 0;\n\tvisit[u] = 1;\n\tfor (int i = cur[u]; i; i = nxt[i])\n\t{\n\t\tint v = a[i];\n\t\tcur[u] = i;\n\t\tif (r[i] && dis[u] + cost[i] == dis[v] && visit[v] == 0)\n\t\t{\n\t\t\tint low = dinic(v, min(flow, r[i]));\n\t\t\tr[i] -= low; r[i ^ 1] += low;\n\t\t\tflow -= low; ans += low;\n\t\t\tif (flow == 0) break;\n\t\t}\n\t}\n\tvisit[u] = 0;\n\tif (ans == 0) dis[u] = -INF;\n\treturn ans;\n}\nvoid check(int x)\n{\n\tfor (int i = 1; i <= x; i++)\n\t{\n\t\tL[0][i] = L[1][i] = 0;\n\t\tR[0][i] = R[1][i] = 110;\n\t}\n\tfor (int i = 1; i <= m; i++)\n\t\tif (tp[i] == 'L' && c2[i] < x) L[0][c2[i] + 1] = c1[i] + 1;\n\t\telse if (tp[i] == 'R' && c2[i] < x) R[0][x - c2[i]] = c1[i] - 1;\n\t\telse if (tp[i] == 'D' && c2[i] < x) L[1][c2[i] + 1] = c1[i] + 1;\n\t\telse if (tp[i] == 'U' && c2[i] < x) R[1][x - c2[i]] = c1[i] - 1;\n\tfor (int i = 2; i <= x; i++)\n\t{\n\t\tL[0][i] = max(L[0][i], L[0][i - 1]);\n\t\tL[1][i] = max(L[1][i], L[1][i - 1]);\n\t}\n\tfor (int i = x - 1; i >= 1; i--)\n\t{\n\t\tR[0][i] = min(R[0][i], R[0][i + 1]);\n\t\tR[1][i] = min(R[1][i], R[1][i + 1]);\n\t}\n\tfor (int i = 1; i <= x; i++)\n\t{\n\t\tcreate(s, id1[i], 1, 0);\n\t\tcreate(id1[i], s, 0, 0);\n\t}\n\tfor (int i = 1; i <= x; i++)\n\t{\n\t\tcreate(id2[i], t, 1, 0);\n\t\tcreate(t, id2[i], 0, 0);\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tcreate(id3[0][i], id3[1][i], 1, val[i]);\n\t\tcreate(id3[1][i], id3[0][i], 0, -val[i]);\n\t\tfor (int j = 1; j <= x; j++)\n\t\t{\n\t\t\tif (tx[i] >= L[0][j] && tx[i] <= R[0][j])\n\t\t\t{\n\t\t\t\tcreate(id1[j], id3[0][i], 1, 0);\n\t\t\t\tcreate(id3[0][i], id1[j], 0, 0);\n\t\t\t}\n\t\t\tif (ty[i] >= L[1][j] && ty[i] <= R[1][j])\n\t\t\t{\n\t\t\t\tcreate(id3[1][i], id2[j], 1, 0);\n\t\t\t\tcreate(id2[j], id3[1][i], 0, 0);\n\t\t\t}\n\t\t}\n\t}\n\tbuild();\n\tint mxflow = 0;\n\tsum = 0;\n\twhile (dis[t] != -INF)\n\t{\n\t\tmxflow += dinic(s, 2e9);\n\t\tbuild();\n\t}\n\tif (mxflow == x) res = max(res, sum);\n\tedge = 1;\n\tfor (int i = 1; i <= cnt; i++)\n\t\thead[i] = 0;\n}\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tscanf(\"%d%d%lld\", &tx[i], &ty[i], &val[i]);\n\t\tid1[i] = ++cnt; id2[i] = ++cnt;\n\t\tid3[0][i] = ++cnt; id3[1][i] = ++cnt;\n\t}\n\tscanf(\"%d\", &m);\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\tchar c = getchar();\n\t\twhile (c < 'A' || c > 'Z') c = getchar();\n\t\tscanf(\"%d%d\", &c1[i], &c2[i]);\n\t\ttp[i] = c;\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tcheck(i);\n\tprintf(\"%lld\\n\", res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nint X[101],Y[101];\nll V[101];\nint L[101],R[101],U[101],D[101];\n\nint M;\nstring S[333];\nint A[333],B[333];\n\ntemplate<int NV,class V> class MinCostFlow {\npublic:\n\tstruct edge { int to; V capacity; V cost; int reve;};\n\tvector<edge> E[NV]; int prev_v[NV], prev_e[NV]; V dist[NV];\n\tvoid add_edge(int x,int y, V cap, V cost) {\n\t\tE[x].push_back((edge){y,cap,cost,(int)E[y].size()});\n\t\tE[y].push_back((edge){x,0, -cost,(int)E[x].size()-1}); /* rev edge */\n\t}\n\t\n\tV mincost(int from, int to, ll flow) {\n\t\tV res=0; int i,v;\n\t\tZERO(prev_v); ZERO(prev_e);\n\t\twhile(flow>0) {\n\t\t\tfill(dist, dist+NV, numeric_limits<V>::max()/2);\n\t\t\tdist[from]=0;\n\t\t\tpriority_queue<pair<V,int> > Q;\n\t\t\tQ.push(make_pair(0,from));\n\t\t\twhile(Q.size()) {\n\t\t\t\tV d=-Q.top().first;\n\t\t\t\tint cur=Q.top().second;\n\t\t\t\tQ.pop();\n\t\t\t\tif(dist[cur]!=d) continue;\n\t\t\t\tif(d==numeric_limits<V>::max()/2) break;\n\t\t\t\tFOR(i,E[cur].size()) {\n\t\t\t\t\tedge &e=E[cur][i];\n\t\t\t\t\tif(e.capacity>0 && dist[e.to]>d+e.cost) {\n\t\t\t\t\t\tdist[e.to]=d+e.cost;\n\t\t\t\t\t\tprev_v[e.to]=cur;\n\t\t\t\t\t\tprev_e[e.to]=i;\n\t\t\t\t\t\tQ.push(make_pair(-dist[e.to],e.to));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(dist[to]==numeric_limits<V>::max()/2) return -1;\n\t\t\tll lc=flow;\n\t\t\tfor(v=to;v!=from;v=prev_v[v]) lc = min(lc, E[prev_v[v]][prev_e[v]].capacity);\n\t\t\tflow -= lc;\n\t\t\tres += lc*dist[to];\n\t\t\tfor(v=to;v!=from;v=prev_v[v]) {\n\t\t\t\tedge &e=E[prev_v[v]][prev_e[v]];\n\t\t\t\te.capacity -= lc;\n\t\t\t\tE[v][e.reve].capacity += lc;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N) cin>>X[i]>>Y[i]>>V[i];\n\tcin>>M;\n\tFOR(i,M) cin>>S[i]>>A[i]>>B[i];\n\t\n\tll ret=0;\n\tfor(int K=1;K<=N;K++) {\n\t\tMinCostFlow<450,ll> mcf;\n\t\tZERO(L);\n\t\tZERO(D);\n\t\tFOR(x,101) U[x]=R[x]=100;\n\t\tFOR(i,M) if(B[i]<K) {\n\t\t\tif(S[i]==\"L\") L[B[i]]=max(L[B[i]],A[i]+1);\n\t\t\tif(S[i]==\"D\") D[B[i]]=max(D[B[i]],A[i]+1);\n\t\t\tif(S[i]==\"R\") R[K-B[i]-1]=min(R[K-B[i]-1],A[i]-1);\n\t\t\tif(S[i]==\"U\") U[K-B[i]-1]=min(U[K-B[i]-1],A[i]-1);\n\t\t}\n\t\tfor(i=1;i<K;i++) L[i]=max(L[i],L[i-1]), D[i]=max(D[i],D[i-1]);\n\t\tfor(i=K-2;i>=0;i--) R[i]=min(R[i],R[i+1]), U[i]=min(U[i],U[i+1]);\n\t\t\n\t\tFOR(i,K) {\n\t\t\tmcf.add_edge(0,1+i,1,0);\n\t\t\tmcf.add_edge(101+i,100,1,0);\n\t\t}\n\t\tFOR(i,N) {\n\t\t\tmcf.add_edge(200+i,300+i,1,1000000000000000LL-V[i]);\n\t\t\tFOR(j,K) {\n\t\t\t\tif(L[j]<=X[i] && X[i]<=R[j]) mcf.add_edge(1+j,200+i,1,0);\n\t\t\t\tif(D[j]<=Y[i] && Y[i]<=U[j]) mcf.add_edge(300+i,101+j,1,0);\n\t\t\t}\n\t\t}\n\t\tll v=mcf.mincost(0,100,K);\n\t\tif(v>=0) ret=max(ret,K*1000000000000000LL-v);\n\t}\n\tcout<<ret<<endl;\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//2019.5.25 by ljz\n#include<bits/stdc++.h>\nusing namespace std;\n#define res register int\n#define LL long long\n#define inf 0x3f3f3f3f\n#define INF 0x3f3f3f3f3f3f\n#define eps 1e-10\n#define RG register\n#define db double\n#define pc(x) __builtin_popcount(x)\ntypedef pair<int,int> Pair;\n#define mp make_pair\n#define fi first\n#define se second\n#define gc getchar\n//inline char gc() {\n//    static char buf[100000],*p1,*p2;\n//    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n//}\ninline int read() {\n    res s=0,ch=gc();\n    while(ch<'0'||ch>'9')ch=gc();\n    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=gc();\n    return s;\n}\ninline LL Read() {\n    RG LL s=0;\n    res ch=gc();\n    while(ch<'0'||ch>'9')ch=gc();\n    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=gc();\n    return s;\n}\ninline void swap(res &x,res &y) {\n    x^=y^=x^=y;\n}\n//mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nconst int N=4e2+10;\nnamespace MAIN {\n    int n,m;\n    char str[10];\n    LL v[N];\n    int x[N],y[N],t[N],a[N],b[N];\n    struct E{\n        int next,to,flow;\n        LL cost;\n        E() {}\n        E(res next,res to,res flow,RG LL cost):next(next),to(to),flow(flow),cost(cost) {}\n    }edge[N*N];\n    int head[N],cnt;\n    inline void addedge(const res &u,const res &v,const res &f,const RG LL &c){\n        edge[++cnt]=E(head[u],v,f,c),head[u]=cnt;\n        edge[++cnt]=E(head[v],u,0,-c),head[v]=cnt;\n    }\n    LL dis[N];\n    int Q[N*N],he,ta,S,T,vis[N],pre[N];\n    inline bool spfa(RG LL &ret){\n        for(res i=S;i<=T;i++)dis[i]=INF;\n        Q[he=ta=1]=S,vis[S]=1,dis[S]=0;\n        while(he<=ta){\n            res u=Q[he++];\n            vis[u]=0;\n            for(res i=head[u];~i;i=edge[i].next){\n                res tox=edge[i].to;\n                if(dis[tox]>dis[u]+edge[i].cost&&edge[i].flow){\n                    dis[tox]=dis[u]+edge[i].cost,pre[tox]=i;\n                    if(!vis[tox])vis[tox]=1,Q[++ta]=tox;\n                }\n            }\n        }\n        if(dis[T]==INF)return 0;\n        ret+=dis[T];\n        for(res i=T;i!=S;i=edge[pre[i]^1].to)edge[pre[i]].flow--,edge[pre[i]^1].flow++;\n        return 1;\n    }\n    int L[N],R[N],D[N],U[N];\n    inline LL calc(const res &k){\n        for(res i=1;i<=k;i++)L[i]=D[i]=0,R[i]=U[i]=inf;\n        for(res i=1;i<=m;i++)\n            if(b[i]<k){\n                if(t[i]==0)L[b[i]+1]=a[i]+1;\n                if(t[i]==1)R[k-b[i]]=a[i]-1;\n                if(t[i]==2)D[b[i]+1]=a[i]+1;\n                if(t[i]==3)U[k-b[i]]=a[i]-1;\n            }\n        for(res i=2;i<=k;i++)L[i]=max(L[i],L[i-1]),D[i]=max(D[i],D[i-1]);\n        for(res i=k-1;i;i--)R[i]=min(R[i],R[i+1]),U[i]=min(U[i],U[i+1]);\n        S=0,T=(n+k)<<1|1;\n        for(res i=S;i<=T;i++)head[i]=-1;\n        cnt=-1;\n        for(res i=1;i<=n;i++)addedge(i,i+n,1,-v[i]-INF);\n        for(res i=1;i<=k;i++){\n            addedge(S,i+n*2,1,0),addedge(i+k+n*2,T,1,0);\n            for(res j=1;j<=n;j++){\n                if(L[i]<=x[j]&&x[j]<=R[i])addedge(i+n*2,j,1,0);\n                if(D[i]<=y[j]&&y[j]<=U[i])addedge(j+n,i+k+n*2,1,0);\n            }\n        }\n        RG LL ret=0;\n        while(spfa(ret));\n        return -ret-INF*k;\n    }\n    LL ans;\n    inline int get(const RG char *st){\n        return st[0]=='L'?0:(st[0]=='R'?1:(st[0]=='D'?2:3));\n    }\n    inline void MAIN(){\n        n=read();\n        for(res i=1;i<=n;i++)x[i]=read(),y[i]=read(),v[i]=Read();\n        m=read();\n        for(res i=1;i<=m;i++)scanf(\"%s\",str),t[i]=get(str),a[i]=read(),b[i]=read();\n        for(res i=1;i<=n;i++)ans=max(ans,calc(i));\n        printf(\"%lld\\n\",ans);\n    }\n}\nint main() {\n//    srand((unsigned)time(NULL));\n//    freopen(\"zao.in\",\"r\",stdin);\n//    freopen(\"std.out\",\"w\",stdout);\n    MAIN::MAIN();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 100 , M = 400 , V = N + M << 1 , E = N + N * M * 2 + M * 2 , INF = 0x3f3f3f3f;\nint n,m,x[N],y[N],a[N],b[N],u[N],d[N],l[N],r[N]; char op[N];\nint t(1),Head[V],vis[V],S,T; deque <int> q; ll Delta,dis[V],v[N],Ans;\nstruct Edge { int u,v,next,val; ll cos; } e[E*2];\ntemplate<class T> inline T Read(void)\n{\n    T x = 0; bool w = 0; char ch = ' ';\n    while ( !isdigit(ch) ) w |= ch == '-' , ch = getchar();\n    while ( isdigit(ch) ) x = x * 10 + ch - 48 , ch = getchar();\n    return w ? -x : x;\n}\ninline void Input(void)\n{\n    n = Read<int>();\n    for (int i = 1; i <= n; i++)\n        x[i] = Read<int>() , y[i] = Read<int>() , v[i] = Read<ll>();\n    m = Read<int>();\n    for (int i = 1; i <= m; i++)\n    {\n        char c = ' ';\n        while ( isspace(c) ) c = getchar();\n        op[i] = c , a[i] = Read<int>() , b[i] = Read<int>();\n    }\n}\ninline void Insert(int x,int y,ll c,int v)\n{\n    e[++t] = (Edge){ x , y , Head[x] , v , c } , Head[x] = t;\n    e[++t] = (Edge){ y , x , Head[y] , 0 , -c } , Head[y] = t;\n}\ninline void Build(int k)\n{\n    for (int i = 1; i <= k; i++)\n        u[i] = r[i] = INF , l[i] = d[i] = 0;\n    for (int i = 1; i <= m; i++)\n        if ( b[i] < k )\n        {\n            if ( op[i] == 'L' ) l[b[i]+1] = max( l[b[i]+1] , a[i] + 1 );\n            if ( op[i] == 'R' ) r[k-b[i]] = min( r[k-b[i]] , a[i] - 1 );\n            if ( op[i] == 'D' ) d[b[i]+1] = max( d[b[i]+1] , a[i] + 1 );\n            if ( op[i] == 'U' ) u[k-b[i]] = min( u[k-b[i]] , a[i] - 1 );\n            // if ( op[i] == 'L' ) l[b[i]+1] = a[i] + 1;\n            // if ( op[i] == 'R' ) r[k-b[i]] = a[i] - 1;\n            // if ( op[i] == 'D' ) d[b[i]+1] = a[i] + 1;\n            // if ( op[i] == 'U' ) u[k-b[i]] = a[i] - 1;\n        }\n    for (int i = 2; i <= k; i++) l[i] = max( l[i] , l[i-1] ) , d[i] = max( d[i] , d[i-1] );\n    for (int i = k-1; i >= 1; i--) r[i] = min( r[i] , r[i+1] ) , u[i] = min( u[i] , u[i+1] );\n    memset( Head , 0 , sizeof Head );\n    S = ( n + k ) << 1 | 1 , T = ( n + k + 1 ) * 2 , t = 1 , Delta = 0;\n    for (int i = 1; i <= n; i++) Insert( i , i+n , v[i] , 1 );\n    for (int i = 1; i <= k; i++)\n    {\n        Insert( S , n*2+i , 0 , 1 ) , Insert( n*2+k+i , T , 0 , 1 );\n        for (int j = 1; j <= n; j++)\n        {\n            if ( l[i] <= x[j] && x[j] <= r[i] ) Insert( n*2+i , j , 0 , 1 );\n            if ( d[i] <= y[j] && y[j] <= u[i] ) Insert( j+n , n*2+k+i , 0 , 1 );\n        }\n    }\n    // printf( \"t = %d\\n\" , t );\n}\ninline bool Relabel(void)\n{\n    memset( dis , 0xcf , sizeof dis );\n    memset( vis , 0x00 , sizeof vis );\n    dis[T] = 0 , vis[T] = 1 , q.push_back(T);\n    while ( !q.empty() )\n    {\n        // puts(\"SPFAing\");\n        int x = q.front(); q.pop_front() , vis[x] = 0;\n        if ( q.size() > 1 && dis[q.front()] < dis[q.back()] )\n            swap( q.front() , q.back() );\n        for (int i = Head[x] , y; i; i = e[i].next)\n            if ( e[i^1].val && dis[ y = e[i].v ] < dis[x] + e[i^1].cos )\n            {\n                dis[y] = dis[x] + e[i^1].cos;\n                // printf( \"dis[%d] = %lld\\n\" , y , dis[y] );\n                if ( vis[y] ) continue;\n                vis[y] = true , q.push_back(y);\n                if ( q.size() > 1 && dis[q.front()] < dis[q.back()] )\n                    swap( q.front() , q.back() );\n            }\n    }\n    // printf( \"d[%d] = %lld\\n\" , S , dis[S] );\n    return dis[S] != dis[0];\n}\ninline int Dinic(int x,int flow)\n{\n    if ( x == T || !flow ) return flow;\n    int residue = flow; vis[x] = true;\n    for (int i = Head[x] , y; i; i = e[i].next)\n        if ( e[i].val && !vis[ y = e[i].v ] && !e[i].cos )\n        {\n            int k = Dinic( y , min( e[i].val , residue ) );\n            e[i].val -= k , e[i^1].val += k;\n            if ( ( residue -= k ) == 0 ) break;\n        }\n    return flow - residue;\n}\ninline pair<int,ll> PrimalDual(void)\n{\n    int Maxflow = 0 , Flow = 0; ll Maxcost = 0;\n    while ( Relabel() )\n    {\n        for (int i = 2; i <= t; i++)\n            e[i].cos += dis[e[i].v] - dis[e[i].u];\n        Delta += dis[S] , memset( vis , 0 , sizeof vis );\n        // printf( \"Delta = %lld\\n\" , Delta );\n        while ( Flow = Dinic( S , INF ) )\n            Maxflow += Flow , Maxcost += 1LL * Flow * Delta ,\n            memset( vis , 0 , sizeof vis ) /*, printf( \"Dinicing Flow = %d\\n\" , Flow ) */;\n    }\n    return make_pair( Maxflow , Maxcost );\n}\nint main(void)\n{\n    Input();\n    for (int i = 1; i <= n; i++)\n        Build(i) , Ans = max( Ans , PrimalDual().second );\n    printf( \"%lld\\n\" , Ans );\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n#define dump(x) cout << #x << \" = \" << (x) << endl\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\ntemplate<class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n\tos<<\"{\";\n\trep(i, v.size()) {\n\t\tif (i) os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\n#define MN 510\nconst ll INF = TEN(18);\n\nstruct edge {\n\tint to, cap, rev; ll cost;\n\tedge(int to, int cap, ll cost, int rev) : to(to), cap(cap), cost(cost), rev(rev){}\n};\n\nint N;\nvector<edge> g[MN];\nll h[MN], dst[MN];\nint prevv[MN], preve[MN];\n\ninline void add_edge(int f, int t, int cap, ll cost) {\n\tg[f].emplace_back(t, cap, cost, (int)g[t].size());\n\tg[t].emplace_back(f, 0, -cost, (int)g[f].size() - 1);\n}\n\nll min_cost_flow(int s, int t, int f) {\n\tll res = 0;\n\tmemset(h, 0, sizeof(h));\n\n\tfill(h, h + N + 1, INF);\n\th[s] = 0;\n\tfor (int t = 0; t < N; ++t) {\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (auto e : g[i]) if (e.cap) {\n\t\t\t\th[e.to] = min(h[e.to], h[i] + e.cost);\n\t\t\t}\n\t\t}\n\t}\n\n\twhile (f > 0) {\n\t\tusing pli = pair<ll, int>;\n\t\tpriority_queue<pli, vector<pli>, greater<pli> > que;\n\t\tfill(dst, dst + N + 1, INF);\n\t\tdst[s] = 0;\n\t\tque.push(mp(0, s));\n\t\twhile (!que.empty()) {\n\t\t\tpli p = que.top(); que.pop();\n\t\t\tint v = p.se;\n\t\t\tif (dst[v] < p.fi) continue;\n\t\t\trep(i, g[v].size()) {\n\t\t\t\tedge &e = g[v][i];\n\t\t\t\tll nd = dst[v] + e.cost + h[v] - h[e.to];\n\t\t\t\tif (e.cap > 0 && dst[e.to] > nd) {\n\t\t\t\t\tdst[e.to] = nd;\n\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\tque.push(mp(dst[e.to], e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (dst[t] == INF) return -INF;\n\t\trep(i, N) h[i] += dst[i];\n\n\t\tint d = f;\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\td = min(d, g[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d * h[t];\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\tedge &e = g[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tg[v][e.rev].cap += d;\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint main() {\n\tint n; cin >> n;\n\tvector<pair<pii, ll>> pts(n);\n\n\trep(i, n) {\n\t\tint x, y; ll v;\n\t\tcin >> x >> y >> v;\n\t\t--x; --y;\n\t\tpts[i] = mp(mp(x, y), v);\n\t}\n\n\tint M; cin >> M;\n\tvector<pair<int, pii>> conds;\n\trep(i, M) {\n\t\tchar c; int a, b;\n\t\tcin >> c >> a >> b;\n\t\t--a; \n\t\tif (c == 'L') {\n\t\t\tconds.eb(0, mp(a, b));\n\t\t} else if (c == 'R') {\n\t\t\tconds.eb(1, mp(a, b));\n\t\t} else if (c == 'D') {\n\t\t\tconds.eb(2, mp(a, b));\n\t\t} else {\n\t\t\tconds.eb(3, mp(a, b));\n\t\t}\n\t}\n\n\tll ans = 0;\n\n\tfor (int num = 1; num <= n; ++num) {\n\t\trep(j, MN) g[j].clear();\n\t\tvi lox(num + 1, 0), hix(num + 1, 99), loy(num + 1, 0), hiy(num + 1, 99);\n\n\t\trep(i, M) {\n\t\t\tint a = conds[i].se.fi, b = conds[i].se.se;\n\t\t\tif (b >= num) continue;\n\n\t\t\tif (conds[i].fi == 0) {\n\t\t\t\tlox[b + 1] = max(lox[b + 1], a + 1);\n\t\t\t} else if (conds[i].fi == 1) {\n\t\t\t\thix[num - b] = min(hix[num - b], a - 1);\n\t\t\t} else if (conds[i].fi == 2) {\n\t\t\t\tloy[b + 1] = max(loy[b + 1], a + 1);\n\t\t\t} else {\n\t\t\t\thiy[num - b] = min(hiy[num - b], a - 1);\n\t\t\t}\n\t\t}\n\n\t\tbool ok = true;\n\t\tfor (int i = 1; i <= num; ++i) {\n\t\t\tif (lox[i] > hix[i] || loy[i] > hiy[i]) {\n\t\t\t\tok = false;\n\t\t\t}\n\t\t}\n\n\t\tif (!ok) continue;\n\t\trep(i, num) {\n\t\t\tlox[i+1] = max(lox[i+1], lox[i]);\n\t\t\tloy[i+1] = max(loy[i+1], loy[i]);\n\t\t}\n\t\tfor (int i = num-1; i >= 0; --i) {\n\t\t\thix[i] = min(hix[i], hix[i+1]);\n\t\t\thiy[i] = min(hiy[i], hiy[i+1]);\n\t\t}\n\n\t\tN = (1 + num + 100) * 2;\n\n\t\tint s = 0, t = N-1;\n\n\t\trep(i, num) {\n\t\t\tadd_edge(s, i + 1, 1, 0ll);\n\t\t\tfor (int x = lox[i+1]; x <= hix[i+1]; ++x) {\n\t\t\t\tadd_edge(i + 1, 1 + num + x, 1, 0ll);\n\t\t\t}\n\n\t\t\tadd_edge(1 + num + 100 + 100 + i, t, 1, 0ll);\n\t\t\tfor (int y = loy[i+1]; y <= hiy[i+1]; ++y) {\n\t\t\t\tadd_edge(1 + num + 100 + y, 1 + num + 100 + 100 + i, 1, 0ll);\n\t\t\t}\n\t\t}\n\n\t\trep(i, n) {\n\t\t\tint x = pts[i].fi.fi, y = pts[i].fi.se;\n\t\t\tadd_edge(1 + num + x, 1 + num + 100 + y, 1, -pts[i].se);\n\t\t}\n\n\t\tll res = min_cost_flow(s, t, num);\n\t\tif (res != -INF) {\n\t\t\tans = max(ans, -res);\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define Rep(i,a,b) for(register int i=(a);i<=int(b);++i)\n#define Dep(i,a,b) for(register int i=(a);i>=int(b);--i)\n#define rep(i,a,b) for(register int i=(a);i<int(b);++i)\n#define mem(x,v) memset(x,v,sizeof(x))\n#define fi first\n#define se second\n#define gc getchar\n#define pc putchar\ninline ll read(){\n    ll x=0,f=1;char c=gc();\n    for(;!isdigit(c);c=gc())if(c=='-')f=-1;\n    for(;isdigit(c);c=gc())x=(x<<1)+(x<<3)+(c^48);\n    return x*f;\n}\ninline void write(ll x){if(x<0)x=-x,pc('-');if(x>=10)write(x/10);putchar(x%10+'0');}\ninline void wri(ll x){write(x);pc(' ');}\ninline void writeln(ll x){write(x);pc('\\n');}\n#define int ll\nconst int maxn = 2005;\nstruct Edge{\n\tint to,nxt,cap;\n\tll v;\n\tEdge(){}\n\tEdge(int to,int nxt,int cap,ll v):\n\t\tto(to),nxt(nxt),cap(cap),v(v){}\n}edge[maxn*maxn];\nint first[maxn],nume;\nint tot,S,T,idx[maxn],idy[maxn];\nvoid Addedge(int a,int b,int c,ll v){\n//\tprintf(\"_%d -> %d{%d %d}\\n\",a,b,c,v);\n\tedge[nume] = Edge(b,first[a],c,v);first[a] = nume++;\n\tedge[nume] = Edge(a,first[b],0,-v);first[b] = nume++;\n}\nll dis[maxn];\nint q[maxn*maxn],vis[maxn],from[maxn];\nbool spfa(){\n\tRep(i,1,tot) dis[i] = -(1ll<<62),vis[i] = 0,from[i] = 0;\n\tint front=0,rear=0;\n\tq[rear++] = S;dis[S] = 0;vis[S] = true;\n\twhile(front < rear){\n\t\tint u = q[front++];vis[u] = false;\n\t\tfor(int e=first[u];~e;e=edge[e].nxt){\n\t\t\tif(dis[edge[e].to] < dis[u] + edge[e].v && edge[e].cap){\n\t\t\t\tdis[edge[e].to] = dis[u] + edge[e].v;\n\t\t\t\tfrom[edge[e].to] = e;\n\t\t\t\tif(!vis[edge[e].to]){\n\t\t\t\t\tvis[edge[e].to] = true;\n\t\t\t\t\tq[rear++] = edge[e].to;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dis[T] != -(1ll<<62);\n}\nvoid del(){\n\tfor(int e=from[T];e;e=from[edge[e^1].to]){\n\t\tedge[e].cap--,edge[e^1].cap++;\n\t}\n}\nstruct que{\n\tchar s[10];\n\tint x,cnt;\n}qq[maxn];\nint n,Q,x[maxn],y[maxn],mn[maxn],mx[maxn];\nll v[maxn];\nconst int MX = 100;\nll work(int cnt){\n\tmemset(first,-1,sizeof(first));nume = 0;\n\ttot = 0;S = ++tot;T = ++tot;\n\tRep(i,1,MX) idx[i] = ++tot,idy[i] = ++tot;\n\tRep(i,1,n) Addedge(idx[x[i]],idy[y[i]],1,v[i]);\n\t\n\t\tRep(i,0,cnt+1) mx[i]=MX,mn[i]=1;\n\t\tRep(i,1,Q){\n\t\t\tif (qq[i].s[0]=='L'&&cnt>=qq[i].cnt+1){\n\t\t\t\tmn[qq[i].cnt+1]=max(mn[qq[i].cnt+1],qq[i].x+1);\n//\t\t\t\tprintf(\"Mn(%d) [%d]\\n\",qq[i].cnt+1,qq[i].x+1);\n\t\t\t}\n\t\t\tif (qq[i].s[0]=='R'&&cnt>=qq[i].cnt+1)\n\t\t\t\tmx[cnt-qq[i].cnt]=min(mx[cnt-qq[i].cnt],qq[i].x-1);\n\t\t}\n\t\tRep(i,1,cnt) mn[i]=max(mn[i],mn[i-1]);\n\t\tDep(i,cnt,1) mx[i]=min(mx[i],mx[i+1]);\n//\t\tRep(i,1,cnt){\n//\t\t\tprintf(\"{%d %d}\\n\",mn[i],mx[i]);\n//\t\t}\n\t\tRep(i,1,cnt){\n\t\t\tint tmp=++tot;\n\t\t\tif (mn[i]>mx[i]) return 0;\n\t\t\tAddedge(S,tmp,1,0);\n\t\t\tRep(j,mn[i],mx[i])\n\t\t\t\tAddedge(tmp,idx[j],1,0);\n\t\t}\n\n\t\tRep(i,0,cnt+1) mx[i]=MX,mn[i]=1;\n\t\tRep(i,1,Q){\n\t\t\tif (qq[i].s[0]=='D'&&cnt>=qq[i].cnt+1)\n\t\t\t\tmn[qq[i].cnt+1]=max(mn[qq[i].cnt+1],qq[i].x+1);\n\t\t\tif (qq[i].s[0]=='U'&&cnt>=qq[i].cnt+1)\n\t\t\t\tmx[cnt-qq[i].cnt]=min(mx[cnt-qq[i].cnt],qq[i].x-1);\n\t\t}\n\t\tRep(i,1,cnt) mn[i]=max(mn[i],mn[i-1]);\n\t\tDep(i,cnt,1) mx[i]=min(mx[i],mx[i+1]);\n\t\tRep(i,1,cnt){\n\t\t\tint tmp=++tot;\n\t\t\tif (mn[i]>mx[i]) return 0;\n\t\t\tAddedge(tmp,T,1,0);\n\t\t\tRep(j,mn[i],mx[i])\n\t\t\t\tAddedge(idy[j],tmp,1,0);\n\t\t}\n\tll ans = 0;\n\tRep(i,1,cnt){\n\t\tif(!spfa()) return 0;\n\t\tans += dis[T];\n\t\tdel();\n\t}\n//\tprintf(\"%lld %lld\\n\",cnt,ans);\n\treturn ans;\n}\nsigned main(){\n\tn = read();\n\tRep(i,1,n){\n\t\tx[i] = read(),y[i] = read(),v[i] = read();\n\t}\n\tQ = read();\n\tRep(i,1,Q) scanf(\"%s\",qq[i].s);qq[i] . x = read(),qq[i] . cnt = read();\n\tll ans = 0;\n\tRep(i,1,n) ans=max(ans,work(i));\n\twriteln(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cmath>\n#include<cstdlib>\n#define LL long long\n#define LD long double\nusing namespace std;\nconst int NN=90;\nconst int MM=1000 +117;\nint read(){\n\tint fl=1,x;char c;\n\tfor(c=getchar();(c<'0'||c>'9')&&c!='-';c=getchar());\n\tif(c=='-'){fl=-1;c=getchar();}\n\tfor(x=0;c>='0'&&c<='9';c=getchar())\n\t\tx=(x<<3)+(x<<1)+c-'0';\n\treturn x*fl;\n}\nvoid open(){\n\tfreopen(\"a.in\",\"r\",stdin);\n\t//freopen(\"a.out\",\"w\",stdout);\n}\nvoid close(){\n\tfclose(stdin);\n\tfclose(stdout);\n}\n\n\nint m,n;\nint pos[NN][2]={};\nLL v[NN]={};\nstruct node{\n\tint l,r;\n}x[NN],y[NN]={};\nint q[MM][3]={};\nint f[300]={};\nint p[4*NN]={};\nint ecnt=0;\nint pcnt=0;\nint st,fin;\nint maxf;\nLL minc;\nstruct edge{\n\tint to,xt,rem;\n\tLL ct;\n}e[6*NN*NN]={};\nvoid ADD(int a,int b,int rem,LL ct){\n\t++ecnt;\n\te[ecnt].to=b;\n\te[ecnt].xt=p[a];\n\te[ecnt].rem=rem;\n\te[ecnt].ct=ct;\n\tp[a]=ecnt;\n}\nvoid add(int a,int b,int rem,LL ct){\n\t//cerr<<\"from \"<<a<<\" to \"<<b<<\" cap:\"<<rem<<\" cost:\"<<ct<<endl;\n\tADD(a,b,rem,ct);\n\tADD(b,a,0,-ct);\n}\nLL sp[4*NN]={};\nint pre[4*NN]={};\nbool inq[4*NN]={};\nqueue<int> qu;\nbool spfa(){\n\tfor(int i=1;i<=pcnt;++i){\n\t\tsp[i]=1e18;\n\t}\n\tsp[st]=0;\n\tqu.push(st);\n\twhile(!qu.empty()){\n\t\tint x=qu.front();\n\t\tqu.pop();\n\t\tinq[x]=0;\n\t\tfor(int pos=p[x];pos;pos=e[pos].xt){\n\t\t\tint cur=e[pos].to;\n\t\t\tif(e[pos].rem&&e[pos].ct+sp[x]<sp[cur]){\n\t\t\t\tsp[cur]=sp[x]+e[pos].ct;\n\t\t\t\tpre[cur]=pos;\n\t\t\t\tif(!inq[cur]){\n\t\t\t\t\tqu.push(cur);\n\t\t\t\t\tinq[cur]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn sp[fin]!=1e18;\n}\nvoid getf(){\n\tmaxf=0;\n\tminc=0;\n\twhile(spfa()){\n\t\tmaxf+=1;\n\t\tminc+=sp[fin];\n\t\tint pos=fin;\n\t\twhile(pos!=st){\n\t\t\tint id=pre[pos];\n\t\t\te[id].rem-=1;\n\t\t\te[id^1].rem+=1;\n\t\t\tpos=e[id^1].to;\n\t\t}\n\t}\n}\nLL solve(int all){\n\tfor(int i=1;i<=all;++i){\n\t\tx[i].l=0;\n\t\tx[i].r=1e9;\n\t\ty[i].l=0;\n\t\ty[i].r=1e9;\n\t}\n\tfor(int i=1;i<=m;++i){\n\t\tint a=q[i][1];\n\t\tint b=q[i][2];\n\t\tswitch(q[i][0]){\n\t\t\tcase 0:\n\t\t\tx[b+1].l=max(x[b+1].l,a+1);\n\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\tif(all>b)x[all-b].r=min(x[all-b].r,a);\n\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\ty[b+1].l=max(y[b+1].l,a+1);\n\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\tif(all>b)y[all-b].r=min(y[all-b].r,a);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=2;i<=all;++i){\n\t\tx[i].l=max(x[i-1].l,x[i].l);\n\t\ty[i].l=max(y[i-1].l,y[i].l);\n\t}\n\tfor(int i=all-1;i>=1;--i){\n\t\tx[i].r=min(x[i+1].r,x[i].r);\n\t\ty[i].r=min(y[i+1].r,y[i].r);\n\t}\n\tfor(int i=1;i<=all;++i){\n\t\tif(x[i].l>x[i].r||y[i].l>y[i].r)return -1;\n\t}\n\tst=2*n+2*all+1;\n\tfin=st+1;\n\tecnt=1;\n\tpcnt=fin;\n\tfor(int i=1;i<=pcnt;++i)p[i]=0;\n\tfor(int i=1;i<=n;++i){\n\t\tadd(i,n+i,1,-v[i]);\n\t}\n\tfor(int i=1;i<=all;++i){\n\t\tadd(st,2*n+i,1,0);\n\t\tadd(2*n+all+i,fin,1,0);\n\t\tfor(int j=1;j<=n;++j){\n\t\t\tif(x[i].l<=pos[j][0]&&pos[j][0]<=x[i].r){\n\t\t\t\tadd(2*n+i,j,1,0);\n\t\t\t}\n\t\t\tif(y[i].l<=pos[j][1]&&pos[j][1]<=y[i].r){\n\t\t\t\tadd(n+j,2*n+all+i,1,0);\n\t\t\t}\n\t\t}\n\t}\n\tgetf();\n\tif(maxf==all)return -minc;\n\telse return -1;\n}\nint lix[NN]={};\nint liy[NN]={};\nchar getc(){\n\tchar c=getchar();\n\twhile(c==' '||c=='\\n'||c=='\\r')c=getchar();\n\treturn c;\n}\nint main(){\n\t//open();\n\tn=read();\n\tfor(int i=1;i<=n;++i){\n\t\tlix[i]=pos[i][0]=read();\n\t\tliy[i]=pos[i][1]=read();\n\t\tscanf(\"%lld\",&v[i]);\n\t}\n\tsort(lix+1,lix+1+n);\n\tsort(liy+1,liy+1+n);\n\tf['L']=0;\n\tf['R']=1;\n\tf['D']=2;\n\tf['U']=3;\n\tm=read();\n\tfor(int i=1;i<=m;++i){\n\t\tq[i][0]=f[getc()];\n\t\tq[i][1]=read()-(q[i][0]&1);\n\t\tq[i][2]=read();\n\t\t/*if(q[i][0]&2){\n\t\t\tq[i][1]=upper_bound(liy+1,liy+1+n,q[i][1])-liy-1;\n\t\t}\n\t\telse{\n\t\t\tq[i][1]=upper_bound(lix+1,lix+1+n,q[i][1])-lix-1;\n\t\t}*/\n\t}\n\tLL ans=0;\n\tfor(int i=1;i<=n;++i){\n\t\tLL tp=solve(i);\n\t\t//cerr<<tp<<endl;\n\t\tans=max(ans,tp);\n\t}\n\tprintf(\"%lld\\n\",ans);\n\tclose();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Fail puts(\"NO\"),exit(0);\n#define eps 1e-10\n#define maxn 505\n#define maxm 100010\n#define inf 1000000007\n#define mod 1000000007\n#define pi acos(-1)\n#define mp(x,y) make_pair(x,y)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int>pii;\ntypedef bitset<maxn> bit;\nll read()\n{\n    ll x=0,f=1;\n    char ch=getchar();\n    while(ch-'0'<0||ch-'0'>9){if(ch=='-') f=-1;ch=getchar();}\n    while(ch-'0'>=0&&ch-'0'<=9){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nint n,m,s,t;\nstruct P{\n    int x,y;\n    ll v;\n}p[85];\nstruct X{\n    char d;\n    int a,b;\n}co[325];\nint Lx[85],Rx[85],Ly[85],Ry[85];\nint head[325],nxt[14010],to[14010],c[14010],tot;\nll v[14010];\nvoid add(int x,int y,int z,ll u)\n{\n    tot++;\n    nxt[tot]=head[x];\n    head[x]=tot;\n    to[tot]=y;\n    c[tot]=z;\n    v[tot]=u;\n}\nvoid addx(int x,int y,int z,ll u)\n{\n    add(x,y,z,u);\n    add(y,x,0,-u);\n}\nll ans,res,dis[325];\nint vis[325],pre[325],pre_num[325];\nqueue<int>q;\nint spfa()\n{\n    for(int i=1;i<=t;i++)  dis[i]=-1e18;\n    dis[s]=0;q.push(s);vis[s]=1;\n    while(q.size())\n    {\n        int now=q.front();q.pop();vis[now]=0;\n        for(int i=head[now];i;i=nxt[i])\n        {\n            if(dis[to[i]]<dis[now]+v[i]&&c[i])\n            {\n                dis[to[i]]=dis[now]+v[i];\n                pre[to[i]]=now;\n                pre_num[to[i]]=i;\n                if(!vis[to[i]])  q.push(to[i]),vis[to[i]]=1;\n            }\n        }\n    }\n    if(dis[t]==-1e18)  return 0;\n    int di=inf;\n    for(int i=t;i!=s;i=pre[i])  di=min(di,c[pre_num[i]]);\n    for(int i=t;i!=s;i=pre[i])  c[pre_num[i]]-=di,c[pre_num[i]^1]+=di;\n    ans+=dis[t]*di;\n    return di;\n}\nint main()\n{\n    n=read();\n    for(int i=1;i<=n;i++)  p[i].x=read(),p[i].y=read(),p[i].v=read();\n    m=read();\n    for(int i=1;i<=m;i++)  co[i].d=getchar(),co[i].a=read(),co[i].b=read();\n    for(int k=1;k<=n;k++)\n    {\n        tot=1;memset(head,0,sizeof(head));\n        s=2*k+2*n+1;t=s+1;\n        for(int i=1;i<=k;i++)  addx(s,i,1,0);\n        for(int i=k+2*n+1;i<=2*n+2*k;i++)  addx(i,t,1,0);\n        for(int i=k+1;i<=k+n;i++)  addx(i,i+n,1,p[i-k].v);\n        for(int i=1;i<=k;i++)  Lx[i]=Ly[i]=0,Rx[i]=Ry[i]=inf;\n        for(int i=1;i<=m;i++)\n        {\n            if(co[i].d=='U')\n            {\n                for(int j=1;j<=k-co[i].b;j++)  Ry[j]=min(Ry[j],co[i].a-1);\n            }\n            if(co[i].d=='D')\n            {\n                for(int j=co[i].b+1;j<=k;j++)  Ly[j]=max(Ly[j],co[i].a+1);\n            }\n            if(co[i].d=='L')\n            {\n                for(int j=co[i].b+1;j<=k;j++)  Lx[j]=max(Lx[j],co[i].a+1);\n            }\n            if(co[i].d=='R')\n            {\n                for(int j=1;j<=k-co[i].b;j++)  Rx[j]=min(Rx[j],co[i].a-1);\n            }\n        }\n        for(int i=1;i<=k;i++)\n          for(int j=1;j<=n;j++)\n            if(Lx[i]<=p[j].x&&p[j].x<=Rx[i])  addx(i,k+j,1,0);\n        for(int i=1;i<=k;i++)\n          for(int j=1;j<=n;j++)\n            if(Ly[i]<=p[j].y&&p[j].y<=Ry[i])  addx(k+n+j,k+2*n+i,1,0);\n        ans=0;\n        while(spfa()){};\n        res=max(res,ans);   \n    }\n    cout<<res<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define space putchar(' ')\n#define enter putchar('\\n')\n#define MAXN 100005\n#define eps 1e-10\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef unsigned int u32;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;T f = 1;char c = getchar();\n    while(c < '0' || c > '9') {\n\tif(c == '-') f = -1;\n\tc = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n\tres = res * 10 + c - '0';\n\tc = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n\tout(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nstruct node {\n    int to,next,cap;int64 val;\n}E[1000005];\nint sumE,head[505],a[85],b[85],x[85],y[85],N,M;\nint L[2][85],R[2][85],S,T,f;\nint64 val[85],res,ans,ex;\nbool vis[505];\nchar s[330][2];\nvoid add(int u,int v,int c,int64 a) {\n    E[++sumE].to = v;\n    E[sumE].next = head[u];\n    E[sumE].cap = c;\n    E[sumE].val = a;\n    head[u] = sumE;\n}\nvoid addtwo(int u,int v,int c,int64 a) {\n    add(u,v,c,a);\n    add(v,u,0,-a);\n}\nvoid build(int K) {\n    sumE = 1;memset(head,0,sizeof(head));\n    for(int i = 1 ; i <= N ; ++i) L[0][i] = L[1][i] = 1,R[0][i] = R[1][i] = 100;\n    for(int i = 1 ; i <= M ; ++i) {\n        if(b[i] >= K) continue;\n        if(s[i][0] == 'L') {\n            L[0][b[i] + 1] = max(L[0][b[i] + 1],a[i] + 1);\n        }\n        else if(s[i][0] == 'R') {\n            R[0][K - b[i]] = min(R[0][K - b[i]],a[i] - 1);\n        }\n        else if(s[i][0] == 'D') {\n            L[1][b[i] + 1] = max(L[1][b[i] + 1],a[i] + 1);\n        }\n        else if(s[i][0] == 'U') {\n            R[1][K - b[i]] = min(R[1][K - b[i]],a[i] - 1);\n        }\n    }\n    for(int i = 2 ; i <= K ; ++i) {\n    \tL[0][i] = max(L[0][i - 1],L[0][i]);\n    \tL[1][i] = max(L[1][i - 1],L[1][i]);\n    }\n    for(int i = K - 1 ; i >= 1 ; --i) {\n    \tR[0][i] = min(R[0][i + 1],R[0][i]);\n    \tR[1][i] = min(R[1][i + 1],R[1][i]);\n    }\n    S = 1;T = 2 * K + 2 * N + 2;\n    for(int i = 1 ; i <= K ; ++i) {\n    \taddtwo(S,i + 1,1,0);\n    \taddtwo(i + K + 2 * N + 1,T,1,0);\n    \tfor(int j = 1 ; j <= N ; ++j) {\n    \t    if(x[j] >= L[0][i] && x[j] <= R[0][i]) {\n        \t\taddtwo(i + 1,K + j + 1,1,0);\n    \t    }\n    \t    if(y[j] >= L[1][i] && y[j] <= R[1][i]) {\n        \t\taddtwo(K + N + j + 1,i + K + 2 * N + 1,1,0);\n    \t    }\n    \t}\n    }\n    for(int i = 1 ; i <= N ; ++i) {\n        addtwo(K + i + 1,K + N + i + 1,1,val[i]);\n    }\n\n}\nint maxflow(int u,int aug) {\n    if(u == T) {\n    \tres += ex * aug;\n        f += aug;\n    \treturn aug;\n    }\n    int flow = 0;\n    vis[u] = 1;\n    for(int i = head[u] ; i ; i = E[i].next) {\n        int v = E[i].to;\n    \tif(E[i].cap > 0 && !vis[v] && E[i].val == 0) {\n    \t    int t = maxflow(v,min(E[i].cap,aug - flow));\n    \t    flow += t;\n    \t    E[i].cap -= t;\n    \t    E[i ^ 1].cap += t;\n    \t}\n    }\n    return flow;\n}\nbool modlabel() {\n    int64 p = -1e18;\n    for(int u = S ; u <= T ; ++u) {\n    \tif(vis[u]) {\n    \t    for(int i = head[u] ; i ; i = E[i].next) {\n        \t\tint v = E[i].to;\n        \t\tif(!vis[v] && E[i].cap > 0 && E[i].val > p) p = E[i].val;\n    \t    }\n    \t}\n    }\n    if(p == -1e18) return false;\n    ex += p;\n    for(int u = S ; u <= T ; ++u) {\n    \tif(vis[u]) {\n    \t    for(int i = head[u] ; i ; i = E[i].next) {\n        \t\tE[i].val -= p;\n        \t\tE[i ^ 1].val += p;\n    \t    }\n    \t}\n    }\n    return true;\n}\nvoid Init() {\n    read(N);\n    for(int i = 1 ; i <= N ; ++i) {\n    \tread(x[i]);read(y[i]);read(val[i]);\n    }\n    read(M);\n    for(int i = 1 ; i <= M ; ++i) {\n    \tscanf(\"%s\",s[i]);read(a[i]);read(b[i]);\n    }\n}\nvoid Solve() {\n    ans = 0;\n    for(int i = 1 ; i <= N ; ++i) {\n    \tbuild(i);\n    \tres = 0;ex = 0;\n        f = 0;\n    \tdo {\n    \t    do {\n                memset(vis,0,sizeof(vis));\n    \t    }while(maxflow(1,i));\n    \t}while(modlabel());\n        if(f == i) ans = max(ans,res);\n    }\n    out(ans);enter;\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Init();\n    Solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n#define REP(i, a, n) for(LL i = (a), i##_max = (n); i < i##_max; ++i)\n#define REM(i, a, n) for(LL i = (LL)(n) - 1, i##min = (a); i >= i##min; --i)\n#define ALL(arr) (arr).begin(), (arr).end()\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP {cin.tie(NULL); ios::sync_with_stdio(false);}\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst string INFSTR = \"\\x7f\";\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate<class T>\nT Compare(T left, T right) { return left > right ? 1 : (left < right ? -1 : 0); }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\ntemplate <class T>\nT Next() { T buf; cin >> buf; return buf; }\n\n#ifdef ONLY_MY_ENVIR\n#include \"IntMod.h\"\n#include \"UnionFind.h\"\n#include \"Graph.h\"\n#include \"Range.h\"\n#include \"Global.h\"\n#include \"FlowSolver.h\"\n#include \"Tree.h\"\n#include \"SuffixArray.h\"\n#include \"Matrix.h\"\n#include \"SegmentTree.h\"\n#include \"SegmentTree2D.h\"\n#include \"BIT.h\"\n#include \"Rational.h\"\n#include \"Position.h\"\n#include \"Factorization.h\"\n#include \"Math.h\"\n#include \"LazySegmentTree.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>> (istream& ist, __int128& val) { LL tmp;  ist >> tmp; val = tmp; return ist; }\nostream& operator<< (ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\n#if 1234567891\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\n// template <class T>\n// auto Is(const T& value) { return [value](const auto& comparand) -> bool { return comparand == value; }; }\n#endif\n\nint N, M;\nint x[80], y[80];\nLL v[80];\nchar t[320];\nint a[320], b[320];\nbool lim[320][80];\n\nvoid pre() {\n\tREP(j, 0, M) {\n\t\tREP(i, 0, N) {\n\t\t\tbool ng = false;\n\t\t\tswitch (t[j]) {\n\t\t\tcase 'L': ng = (x[i] <= a[j]); break;\n\t\t\tcase 'R': ng = (x[i] >= a[j]); break;\n\t\t\tcase 'D': ng = (y[i] <= a[j]); break;\n\t\t\tcase 'U': ng = (y[i] >= a[j]); break;\n\t\t\t}\n\t\t\tif (ng) lim[j][i] = true;\n\t\t}\n\t}\n}\n\nLL calc_score(const vector<bool>& ans) {\n\tLL score = 0;\n\tREP(i, 0, N) {\n\t\tif (ans[i]) {\n\t\t\tscore += v[i];\n\t\t}\n\t}\n\n\tREP(j, 0, M) {\n\t\tint cnt = 0;\n\t\tREP(i, 0, N) {\n\t\t\tif (!ans[i]) continue;\n\t\t\tif (!lim[j][i]) continue;\n\t\t\t++cnt;\n\t\t}\n\t\tif (cnt > b[j]) {\n\t\t\tscore -= 1e18;\n\t\t}\n\t}\n\treturn score;\n}\n\nLL sub() {\n\tpre();\n\tmt19937 mt;\n\tvector<bool> ans(N, false);\n\tLL score = calc_score(ans);\n\tLL mx = score;\n\tdouble temp_start = 1e15;\n\tdouble temp_end = 0.1;\n\tdouble temp = 5;\n\n\tconst int times = 270000;\n\tREP(z, 0, times) {\n\t\tint i = mt() % N;\n\n\t\tLL pre_score = score;\n\n\t\tans[i] = !ans[i];\n\n\t\tscore = calc_score(ans);\n\t\tmx = max(mx, score);\n\n\t\tLL delta = score - pre_score;\n\t\tbool accepted = delta > 0 ||\n\t\t\t(-delta < temp * 10 && exp(delta / temp) * (1ULL << 32) >= mt() );\n\n\t\tif (!accepted) {\n\t\t\tans[i] = !ans[i];\n\t\t\tscore = pre_score;\n\t\t}\n\n\t\tif (z % 256 == 0) {\n\t\t\tdouble ratio = z / (double)times;\n\t\t\ttemp = pow(temp_start, 1 - ratio) * pow(temp_end, ratio);\n\t\t\tcerr << temp << '\\t' << score << endl;\n\t\t}\n\t}\n\treturn mx;\n}\n\nint main() {\n\tcin >> N;\n\tREP(i, 0, N) {\n\t\tcin >> x[i] >> y[i] >> v[i];\n\t}\n\tcin >> M;\n\tREP(j, 0, M) {\n\t\tcin >> t[j] >> a[j] >> b[j];\n\t}\n\n\tcout << sub() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#define lop(c,l) for(int c=1;c<=(l);++c)\n#define loop(c,l) for(int c=0;c<(l);++c)\nusing namespace std;\n\n#define int long long\n#define double long double\n#define inf 1e14\n#define eps 1e-14\ntemplate<int Vari,int Crat>\nstruct algo_simplex{\n\tdouble matrix[Crat+1][Vari+1],ans[Vari+1];\n\tint id[Crat<<1|1];\n\tint vari,crat,target;\n\tvoid pivot(const int& l,const int& e){\n\t\tswap(id[vari+l],id[e]);\n\t\tdouble t=matrix[l][e];\n\t\tmatrix[l][e]=1;\n\t\tfor(int j=0;j<=vari;j++) matrix[l][j]/=t;\n\t\tfor(int i=0;i<=crat;i++) if(i!=l&&abs(matrix[i][e])>eps){\n\t\t\tt=matrix[i][e];\n\t\t\tmatrix[i][e]=0;\n\t\t\tfor(int j=0;j<=vari;j++) matrix[i][j]-=matrix[l][j]*t;\n\t\t}\n\t}\n\tbool init(){\n\t\twhile(1){\n\t\t\tint l=0,e=0;\n\t\t\tfor(int i=1;i<=crat;i++) if(matrix[i][0]<-eps&&(!l||(rand()&1))) l=i;\n\t\t\tif(!l) return 1;\n\t\t\tfor(int j=1;j<=vari;j++) if(matrix[l][j]<-eps&&(!e||(rand()&1))) e=j;\n\t\t\tif(!e) return 0;\n\t\t\tpivot(l,e);\n\t\t}\n\t}\n\tbool funct(const int& v,const int& c){\n\t\tsrand(new int()-(int*)NULL);\n\t\tvari=v,crat=c;\n\t\tfor(int i=1;i<=vari;i++) id[i]=i;\n\t\tif(!init())\treturn 0;\n\t\twhile(1){\n\t\t\tint l=0,e=0,minn=inf;\n\t\t\tfor(int j=1;j<=vari&&!e;j++) if(matrix[0][j]>eps) e=j;\n\t\t\tif(!e) break;\n\t\t\tfor(int i=1;i<=crat;i++) if(matrix[i][e]>eps&&matrix[i][0]/matrix[i][e]<minn) minn=matrix[i][0]/matrix[i][e],l=i;\n\t\t\tif(!l) return 0;\n\t\t\tpivot(l,e);\n\t\t}\n\t\ttarget=-matrix[0][0];\n\t\tfor(int i=1;i<=crat;i++) ans[id[vari+i]]=matrix[i][0];\n\t\treturn 1;\n\t}\n};\nalgo_simplex<80,400> spl;\nstruct loc{\n\tint x,y,v;\n}p[81];\nint n,m,ll,lim,ans;\nchar ch;\nsigned main(signed,char**,char**){\n\tscanf(\"%lld\",&n);\n\tlop(i,n){\n\t\tscanf(\"%lld%lld%lld\",&p[i].x,&p[i].y,&p[i].v);\n\t\tspl.matrix[0][i]=p[i].v;\n\t}\n\tscanf(\"%lld\",&m);\n\tlop(i,m){\n\t\tscanf(\" %c%lld%lld\",&ch,&ll,&lim);\n\t\tswitch(ch){\n\t\t\tcase 'L':{\n\t\t\t\tlop(j,n) if(p[j].x<=ll) spl.matrix[i][j]=1;\n\t\t\t\tspl.matrix[i][0]=lim;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'R':{\n\t\t\t\tlop(j,n) if(p[j].x>=ll) spl.matrix[i][j]=1;\n\t\t\t\tspl.matrix[i][0]=lim;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'D':{\n\t\t\t\tlop(j,n) if(p[j].y<=ll) spl.matrix[i][j]=1;\n\t\t\t\tspl.matrix[i][0]=lim;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'U':{\n\t\t\t\tlop(j,n) if(p[j].y>=ll) spl.matrix[i][j]=1;\n\t\t\t\tspl.matrix[i][0]=lim;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tlop(i,n) spl.matrix[m+i][i]=1,spl.matrix[m+i][0]=1;\n\tspl.funct(n,m+n);\n\tlop(i,n) if(round(spl.ans[i])==1) ans+=p[i].v;\n\tprintf(\"%lld\",ans);\n\texit(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nconst int S=0,T=1,SS=2,TT=3,siz=100;\nint n,m,x[110],y[110],r[400][3],d[400];\nlong long v[110],ans;\nstruct bian\n{\n\tint nxt,to,f;\n\tlong long w;\n}bi[10010];\nint head[220],num;\nvoid add(int from,int to,int f,long long w)\n{\n\tbi[++num].nxt=head[from];\n\thead[from]=num;\n\tbi[num].to=to;\n\tbi[num].f=f;\n\tbi[num].w=w;\n}\nvoid ADD(int from,int to,int f,long long w){add(from,to,f,w),add(to,from,0,-w);}\nint lox[110],hix[220],loy[110],hiy[110];\nqueue<int>q;\nlong long dis[220];\nint fb[220];\nbool in[220];\nvoid bfs(int s)\n{\n\tq.push(s);fb[s]=0;\n\tmemset(dis,-1,sizeof(dis));\n\tdis[s]=0;\n\tint x,y;\n\twhile(!q.empty())\n\t{\n\t\tx=q.front();q.pop();\n\t//\tprintf(\"%d %lld\\n\",x,dis[x]);\n\t\tfor(int i=head[x];i;i=bi[i].nxt)\n\t\t\tif(bi[i].f)\n\t\t\t{\n\t\t\t\ty=bi[i].to;\n\t\t\t\tif(dis[y]==-1)dis[y]=dis[x]+bi[i].w,q.push(y),fb[y]=i;\n\t\t\t}\n\t}\n}\nvoid spfa(int s)\n{\n\tq.push(s);fb[s]=0;\n\tmemset(dis,0xc0,sizeof(dis));\n\tdis[s]=0;\n\tint x,y;\n\twhile(!q.empty())\n\t{\n\t\tx=q.front();q.pop();in[x]=0;\n\t//\tprintf(\"%d %lld\\n\",x,dis[x]);\n\t\tfor(int i=head[x];i;i=bi[i].nxt)\n\t\t\tif(bi[i].f)\n\t\t\t{\n\t\t\t\ty=bi[i].to;\n\t\t\t\tif(dis[x]+bi[i].w>dis[y])\n\t\t\t\t{\n\t\t\t\t//\tprintf(\"u %d %d\\n\",x,y);\n\t\t\t\t\tdis[y]=dis[x]+bi[i].w;\n\t\t\t\t\tfb[y]=i;\n\t\t\t\t\tif(!in[y])in[y]=1,q.push(y);\n\t\t\t\t}\n\t\t\t}\n\t}\n}\nvoid solve(int cnt)\n{\n//\tprintf(\"%d:\\n\",cnt);\n\tnum=1;\n\tmemset(head,0,sizeof(head));\n\tmemset(d,0,sizeof(d));\n\tfor(int i=1;i<=siz;++i)lox[i]=loy[i]=0,hix[i]=hiy[i]=cnt;\n\tfor(int i=1;i<=m;++i)\n\t\tif(r[i][0]=='L')hix[r[i][1]]=r[i][2];\n\t\telse if(r[i][0]=='R')lox[r[i][1]-1]=cnt-r[i][2]>0?cnt-r[i][2]:0;\n\t\telse if(r[i][0]=='D')hiy[r[i][1]]=r[i][2];\n\t\telse loy[r[i][1]-1]=cnt-r[i][2]>0?cnt-r[i][2]:0;\n//\tfor(int i=1;i<=siz;++i)printf(\"%d \",lox[i]);printf(\"\\n\");\n//\tfor(int i=1;i<=siz;++i)printf(\"%d \",hix[i]);printf(\"\\n\");\n//\tfor(int i=1;i<=siz;++i)printf(\"%d \",loy[i]);printf(\"\\n\");\n//\tfor(int i=1;i<=siz;++i)printf(\"%d \",hiy[i]);printf(\"\\n\");\n\tfor(int i=1;i<=siz;++i)\n\t{\n\t\tif(lox[i]>hix[i])return;\n\t\td[3+i]+=lox[i];\n\t\tif(i<siz)d[4+i]-=lox[i],ADD(4+i,3+i,hix[i]-lox[i],0);\n\t\telse d[S]-=lox[i],ADD(S,3+i,hix[i]-lox[i],0);\n\t}\n\tfor(int i=1;i<=siz;++i)\n\t{\n\t\tif(loy[i]>hiy[i])return;\n\t\td[3+siz+i]-=loy[i];\n\t\tif(i<siz)d[4+siz+i]+=loy[i],ADD(3+siz+i,4+siz+i,hiy[i]-loy[i],0);\n\t\telse d[T]+=loy[i],ADD(3+siz+i,T,hiy[i]-loy[i],0);\n\t}\n\tfor(int i=1;i<=n;++i)ADD(3+x[i],3+siz+y[i],1,v[i]);\n\tint sum=0;\n\tlong long cost=0;\n\tfor(int i=0;i<=2*siz+3;++i)\n\t\tif(d[i]>0)ADD(SS,i,d[i],0),sum+=d[i];\n\t\telse if(d[i]<0)ADD(i,TT,-d[i],0);\n\tADD(T,S,0x3f3f3f3f,0);\n//\tfor(int i=0;i<=2*siz+3;++i)\n//\t\tfor(int j=head[i];j;j=bi[j].nxt)\n//\t\t\tif(bi[j].f)printf(\"%d %d %d %lld\\n\",i,bi[j].to,bi[j].f,bi[j].w);\n\twhile(sum)\n\t{\n\t\tbfs(SS);\n\t\tif(dis[TT]==-1)break;\n\t\t--sum;cost+=dis[TT];\n\t\tint x=TT;\n\t\twhile(x!=SS)--bi[fb[x]].f,++bi[fb[x]^1].f,x=bi[fb[x]^1].to;\n\t}\n//\tprintf(\"%d\\n\",sum);\n\tbi[head[S]].f=0,bi[head[T]].f=0;\n\tif(sum)return;\n\twhile(1)\n\t{\n\t\tspfa(S);\n\t\tif(dis[T]<=0)break;\n\t//\tprintf(\"%lld\\n\",dis[T]);\n\t\tcost+=dis[T];\n\t\tint x=T;\n\t\twhile(x!=S)--bi[fb[x]].f,++bi[fb[x]^1].f,x=bi[fb[x]^1].to;\n\t}\n//\tprintf(\"%lld\\n\",cost);\n\tans=max(ans,cost);\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i)scanf(\"%d %d %lld\",&x[i],&y[i],&v[i]);\n\tscanf(\"%d\",&m);\n\tfor(int i=1;i<=m;++i)scanf(\" %c %d %d\",&r[i][0],&r[i][1],&r[i][2]);\n\tfor(int i=1;i<=n;++i)solve(i);\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n#include <vector>\n#define PB push_back\n#define ll long long\nusing namespace std;\ntemplate <class T>\ninline void rd(T &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile(!isdigit(c)) { if(c=='-') f=-1; c=getchar(); }\n\twhile(isdigit(c)) x=x*10-'0'+c,c=getchar(); x*=f;\n}\ntemplate <class T> inline void cmin(T &x,T y) { if(y<x) x=y; }\ntemplate <class T> inline void cmax(T &x,T y) { if(x<y) x=y; }\nconst ll inf=1e17;\nint S,T,ncnt;\nnamespace Flow {\n\tconst int N=410;\n\tint head[N],cur[N];\n\tll dis[N];\n\tstruct ed { int to,next,f; ll w; };\n\tvector<ed> e;\n\tvoid init() { memset(head,-1,sizeof(head)),e.clear(); }\n\tvoid ad(int x,int y,int f,ll w) {\n\t\te.PB((ed){y,head[x],f,w}); head[x]=e.size()-1;\n\t\te.PB((ed){x,head[y],0,-w}); head[y]=e.size()-1;\n\t}\n\tqueue<int> que;\n\tint vis[N];\n\tbool bfs() {\n\t\tfor(int i=1;i<=ncnt;++i) dis[i]=-inf,cur[i]=head[i];\n\t\tdis[S]=0,vis[S]=1,que.push(S);\n\t\twhile(!que.empty()) {\n\t\t\tint u=que.front(); que.pop(),vis[u]=0;\n\t\t\tfor(int k=head[u];~k;k=e[k].next) if(e[k].f) {\n\t\t\t\tint v=e[k].to;\n\t\t\t\tif(dis[v]<dis[u]+e[k].w) {\n\t\t\t\t\tdis[v]=dis[u]+e[k].w;\n\t\t\t\t\tif(!vis[v]) vis[v]=1,que.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dis[T]>-inf;\n\t}\n\tint dfs(int u,int f) {\n\t\tif(u==T||!f) return f; int ret=0,tmp;\n\t\tvis[u]=1;\n\t\tfor(int k=head[u];~k;k=e[k].next) if(e[k].f) {\n\t\t\tint v=e[k].to;\n\t\t\tif(!vis[v]&&dis[v]==dis[u]+e[k].w&&(tmp=dfs(v,min(f,e[k].f)))) {\n\t\t\t\te[k].f-=tmp,e[k^1].f+=tmp;\n\t\t\t\tf-=tmp,ret+=tmp;\n\t\t\t\tif(!f) break;\n\t\t\t}\n\t\t}\n\t\tvis[u]=0;\n\t\treturn ret;\n\t}\n\tll work() { ll ans=0; while(bfs()) ans+=dfs(S,1e9)*dis[T]; return ans; }\n}\nconst int N=110;\nchar ss[N],str[10];\nint a[N],b[N];\nint xi[N],yi[N],n,m;\nint lbx[N],rbx[N],lby[N],rby[N];\nint idx[N],idy[N];\nll vi[N];\nll sol(int K) {\n\tfor(int i=1;i<=K;++i)\n\t\tlbx[i]=lby[i]=1,\n\t\trbx[i]=rby[i]=100;\n\tfor(int i=1;i<=m;++i) {\n\t\tif(b[i]>K) continue;\n\t\tif(ss[i]=='L') cmax(lbx[b[i]+1],a[i]+1);\n\t\telse if(ss[i]=='R') cmin(rbx[K-b[i]],a[i]-1);\n\t\telse if(ss[i]=='D') cmax(lby[b[i]+1],a[i]+1);\n\t\telse cmin(rby[K-b[i]],a[i]-1);\n\t}\n\tfor(int i=2;i<=K;++i)\n\t\tcmax(lbx[i],lbx[i-1]),\n\t\tcmax(lby[i],lby[i-1]);\n\tfor(int i=K-1;i>=1;--i)\n\t\tcmin(rbx[i],rbx[i+1]),\n\t\tcmin(rby[i],rby[i+1]);\n\t\n\tfor(int i=1;i<=K;++i) if(lbx[i]>rbx[i]||lby[i]>rby[i]) return 0;\n//\tfor(int i=1;i<=K;++i) printf(\"%d %d %d %d\\n\",lbx[i],rbx[i],lby[i],rby[i]);\n\tncnt=0; Flow::init();\n\tS=++ncnt,T=++ncnt;\n\tfor(int i=1;i<=100;++i) idx[i]=++ncnt,idy[i]=++ncnt;\n\tfor(int i=1;i<=K;++i) {\n\t\tint u=++ncnt;\n\t\tFlow::ad(S,u,1,0);\n\t\tfor(int j=lbx[i];j<=rbx[i];++j)\n\t\t\tFlow::ad(u,idx[j],1,0);\n\t}\n\tfor(int i=1;i<=K;++i) {\n\t\tint u=++ncnt;\n\t\tFlow::ad(u,T,1,0);\n\t\tfor(int j=lby[i];j<=rby[i];++j)\n\t\t\tFlow::ad(idy[j],u,1,0);\n\t}\n\tfor(int i=1;i<=n;++i)\n\t\tFlow::ad(idx[xi[i]],idy[yi[i]],1,vi[i]);\n\treturn Flow::work();\n}\n\t\n\t\nint main() {\n\trd(n);\n\tfor(int i=1;i<=n;++i) rd(xi[i]),rd(yi[i]),rd(vi[i]);\n\trd(m);\n\tfor(int i=1;i<=m;++i) {\n\t\tscanf(\"%s\",str);\n\t\tss[i]=str[0];\n\t\trd(a[i]),rd(b[i]);\n\t}\n\tll ans=0;\n\tfor(int i=1;i<=n;++i) ans=max(ans,sol(i));\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n\n#define fo(i,j,l) for(int i=j;i<=l;++i)\n#define fd(i,j,l) for(int i=j;i>=l;--i)\n\nusing namespace std;\ntypedef long long ll;\nconst ll N=1000,M=N*50,maxn=1e18;\n\nbool bz[N];\nint x[N],y[N];\nll v[N];\nint la[N],lb[M],ne[M],le[M];\nll cost[M];\nint fr[N],f1[N];\n\nint n,m,oo,S,T;\nchar c[N];\nint a[N],b[N],d[M];\nint p[N][2],q[N][2];\nll dis[N];\nll rec;\n\ninline ll max(ll a,ll b)\n{return a>b?a:b;}\n\ninline int min(int a,int b)\n{return a<b?a:b;}\n\ninline void llb(int a,int b,int c,ll co)\n{\n\tne[++oo]=la[a]; la[a]=oo; lb[oo]=b;\n\tle[oo]=c; cost[oo]=co; \n}\n\ninline void gg(int a,int b,int c,ll d)\n{\n\tllb(a,b,c,d); llb(b,a,0,-d);\n}\n\ninline bool flow()\n{\n\tfo(i,1,T)dis[i]=maxn;\n\tdis[S]=0;\n\tint l=0,r=1; d[1]=S; bz[S]=true;\n\twhile(l<r){\n\t\tint o=d[++l];\n\t\tfor(int y=la[o];y;y=ne[y])\n\t\tif(dis[o]-cost[y]<dis[lb[y]]&&le[y]==1){\n\t\t\tdis[lb[y]]=dis[o]-cost[y];\n\t\t\tfr[lb[y]]=o; f1[lb[y]]=y;\n\t\t\tif(!bz[lb[y]])d[++r]=lb[y],bz[lb[y]]=true;\n\t\t}\n\t\tbz[o]=false;\n\t}\n\tif(dis[T]==maxn)return false;\n\trec=0;\n\tfor(int u=T;u!=S;u=fr[u]){\n\t\tint k=f1[u];\n\t\tle[k]=0;\n\t\tle[k^1]=1;\n\t\trec=rec+cost[k];\n\t}\n\treturn true;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfo(i,1,n)scanf(\"%d%d%lld\",&x[i],&y[i],&v[i]);\n\tscanf(\"%d\",&m);\n\tfo(i,1,m){\n\t\tchar ch=' ';\n\t\tfor(;ch!='L'&&ch!='R'&&ch!='D'&&ch!='U';ch=getchar());\n\t\tc[i]=ch;\n\t\tscanf(\"%d%d\",&a[i],&b[i]);\n\t}\n\tll ans=0;\n\tfo(i,1,n){\n\t\tfo(l,1,i)p[l][0]=1,p[l][1]=100;\n\t\tfo(l,1,i)q[l][0]=1,q[l][1]=100;\n\t\tfo(l,1,m)\n\t\tif(c[l]=='L'&&b[l]<i){\n\t\t\tfo(j,b[l]+1,i)p[j][0]=max(p[j][0],a[l]+1);\n\t\t} else if(c[l]=='R'&&b[l]<i){\n\t\t\tfo(j,1,i-b[l])p[j][1]=min(p[j][1],a[l]-1);\n\t\t} else if(c[l]=='U'&&b[l]<i){\n\t\t\tfo(j,1,i-b[l])q[j][1]=min(q[j][1],a[l]-1);\n\t\t} else if(c[l]=='D'&&b[l]<i){\n\t\t\tfo(j,b[l]+1,i)q[j][0]=max(q[j][0],a[l]+1);\n\t\t}\n\t\tint ok=0;\n\t\tfo(l,1,i)if(p[l][0]>p[l][1]||q[l][0]>q[l][1]){ok=1; break;}\n\t\tif(ok)continue;\n\t\too=1;\n\t\tS=2*i+2*n+1,T=S+1;\n\t\tfo(j,1,T)la[j]=0;\n\t\tfo(l,1,i)gg(S,l,1,0);\n\t\tfo(l,1,i)gg(i+2*n+l,T,1,0);\n\t\tfo(l,1,n)gg(i+l,i+n+l,1,v[l]);\n\t\tfo(l,1,n){\n\t\t\tfo(j,1,i)if(p[j][0]<=x[l]&&x[l]<=p[j][1])gg(j,i+l,1,0);\n\t\t\tfo(j,1,i)if(q[j][0]<=y[l]&&y[l]<=q[j][1])gg(i+l+n,i+n*2+j,1,0);\n\t\t}\n\t\tll da=0; int cs=0;\n\t\twhile(flow()){\n\t\t\tda=da+rec;\n\t\t\t++cs;\n\t\t}\n\t\tif(cs==i)ans=max(ans,da);\n\t}\n\tcout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n#define MOD @\n#define ADD(X,Y) ((X) = ((X) + (Y)%MOD) % MOD)\ntypedef long long i64; typedef vector<int> ivec; typedef vector<string> svec;\n\ntemplate <class T> void chmax(T &a, const T &b) { a = max(a, b); }\ntemplate <class T> void chmin(T &a, const T &b) { a = min(a, b); }\n\nnamespace MCF {\n\t#define MAXN 300\n\t#define MAXM 5050\n\t#define wint i64\n\t#define cint i64\n\tconst wint wEPS = 0;\n\tconst wint wINF = 1LL << 60LL;\n\tconst cint cEPS = 0;\n\tconst cint cINF = 1LL << 60LL;\n\tint n, m, ptr[MAXN], next[MAXM], zu[MAXM];\n\twint capa[MAXM], tof; // tof: possible flow, toc: mincost\n\tcint cost[MAXM], toc, d[MAXN], pot[MAXN];\n\tint vis[MAXN], pree[MAXN];\n\tvoid init(int _n) {\n\t\tn = _n; m = 0; memset(ptr, ~0, n * 4);\n\t}\n\tvoid ae(int u, int v, wint w, cint c) {\n\t\tnext[m] = ptr[u]; ptr[u] = m; zu[m] = v; capa[m] = w; cost[m] = +c; ++m;\n\t\tnext[m] = ptr[v]; ptr[v] = m; zu[m] = u; capa[m] = 0; cost[m] = -c; ++m;\n\t} // MAXM should be at least 2 * (num of edges) !!\n\tbool solve(int src, int ink, wint flo = wINF) {\n\t\tint i, u, v;\n\t\twint f;\n\t\tcint c, cc;\n\t\tmemset(pot, 0, n * sizeof(cint));\n\n\t\tfor (bool cont = 1; cont; ) {\n\t\t\tcont = 0;\n\t\t\tfor (u = 0; u < n; ++u) for (i = ptr[u]; ~i; i = next[i]) if (capa[i] > wEPS) {\n\t\t\t\tif (pot[zu[i]] > pot[u] + cost[i] + cEPS) {\n\t\t\t\t\tpot[zu[i]] = pot[u] + cost[i]; cont = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (toc = 0, tof = 0; tof + wEPS < flo; ) {\n\t\t\ttypedef pair<cint,int> node;\n\t\t\tpriority_queue< node,vector<node>,greater<node> > q;\n\t\t\tfor (u = 0; u < n; ++u) { d[u] = cINF; vis[u] = 0; }\n\t\t\tfor (q.push(make_pair(d[src] = 0, src)); !q.empty(); ) {\n\t\t\t\tc = q.top().first; u = q.top().second; q.pop();\n\t\t\t\tif (vis[u]++) continue;\n\t\t\t\tfor (i = ptr[u]; ~i; i = next[i]) if (capa[i] > wEPS) {\n\t\t\t\t\tcc = c + cost[i] + pot[u] - pot[v = zu[i]];\n\t\t\t\t\tif (d[v] > cc) { q.push(make_pair(d[v] = cc, v)); pree[v] = i; }\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!vis[ink]) return 0;\n\t\t\tf = flo - tof;\n\t\t\tfor (v = ink; v != src; v = zu[i ^ 1]) { i = pree[v]; chmin(f, capa[i]); }\n\t\t\tfor (v = ink; v != src; v = zu[i ^ 1]) { i = pree[v]; capa[i] -= f; capa[i ^ 1] += f; }\n\t\t\ttof += f;\n\t\t\ttoc += f * (d[ink] - pot[src] + pot[ink]);\n\t\t\tfor (u = 0; u < n; ++u) pot[u] += d[u];\n\t\t}\n\t\treturn 1;\n\t} // returns whether (max_flow >= flo)\n}\n\nint N, M;\nint X[80], Y[80]; i64 V[80];\n\nint Xa[101], Xb[101], Ya[101], Yb[101];\nint lo[101], hi[101];\n\nvoid preproc(int *xa, int *xb)\n{\n\tfor (int i = 99; i >= 0; --i) chmin(xa[i], xa[i + 1]);\n\tfor (int i = 1; i <= 100; ++i) chmin(xb[i], xb[i - 1]);\n}\nvoid compute_lohi(int *xa, int *xb, int n)\n{\n\tfor (int i = 0; i < 100; ++i) {\n\t\thi[i] = xb[i + 1];\n\t\tlo[i] = max(n - xa[i], 0);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\", &N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tscanf(\"%d%d%lld\", X + i, Y + i, V + i);\n\t}\n\n\tfill(Xa, Xa + 101, N);\n\tfill(Xb, Xb + 101, N);\n\tfill(Ya, Ya + 101, N);\n\tfill(Yb, Yb + 101, N);\n\tscanf(\"%d\", &M);\n\tfor (int i = 0; i < M; ++i) {\n\t\tchar T[2]; int a, b;\n\t\tscanf(\"%s%d%d\", T, &a, &b);\n\n\t\tif (T[0] == 'L') chmin(Xa[a], b);\n\t\tif (T[0] == 'R') chmin(Xb[a], b);\n\t\tif (T[0] == 'D') chmin(Ya[a], b);\n\t\tif (T[0] == 'U') chmin(Yb[a], b);\n\t}\n\n\tpreproc(Xa, Xb);\n\tpreproc(Ya, Yb);\n\n\ti64 ans = 0;\n\tfor (int n = 0; n <= N; ++n) {\n\t\tMCF::init(204);\n\n\t\tcompute_lohi(Xa, Xb, n);\n\t\tint s = 202, t = 203;\n\t\tint lo_sum = 0;\n\t\tfor (int i = 0; i < 100; ++i) {\n\t\t\tif (hi[i] < lo[i]) goto fail;\n\t\t\tMCF::ae(i, i + 1, hi[i] - lo[i], 0);\n\t\t\tMCF::ae(i, t, lo[i], 0);\n\t\t\tMCF::ae(s, i + 1, lo[i], 0);\n\t\t\tlo_sum += lo[i];\n\t\t}\n\t\tcompute_lohi(Ya, Yb, n);\n\t\tfor (int i = 0; i < 100; ++i) {\n\t\t\tif (hi[i] < lo[i]) goto fail;\n\t\t\tMCF::ae(101 + i + 1, 101 + i, hi[i] - lo[i], 0);\n\t\t\tMCF::ae(101 + i + 1, t, lo[i], 0);\n\t\t\tMCF::ae(s, 101 + i, lo[i], 0);\n\t\t\tlo_sum += lo[i];\n\t\t}\n\n\t\tMCF::ae(s, 0, n, 0);\n\t\tMCF::ae(101, t, n, 0);\n\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tMCF::ae(X[i], Y[i] + 101, 1, -V[i]);\n\t\t}\n\n\t\t//printf(\"%d %d\\n\", lo_sum, n);\n\t\tif (MCF::solve(s, t, lo_sum + n)) {\n\t\t\tans = max(ans, -MCF::toc);\n\t\t}\n\n\tfail:\n\t\tcontinue;\n\t}\n\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\ntypedef long double T; // long double, Rational, double + mod<P>...\ntypedef vector<T> vd;\ntypedef vector<vd> vvd;\n\nconst T eps = 1e-18, inf = 1/.0;\n#define MP make_pair\n#define ltj(X) if(s == -1 || MP(X[j],N[j]) < MP(X[s],N[s])) s=j\n\nstruct LPSolver {\n\tint m, n;\n\tvi N, B;\n\tvvd D;\n\n\tLPSolver(const vvd& A, const vd& b, const vd& c) :\n\t\tm(sz(b)), n(sz(c)), N(n+1), B(m), D(m+2, vd(n+2)) {\n\t\t\trep(i,0,m) rep(j,0,n) D[i][j] = A[i][j];\n\t\t\trep(i,0,m) { B[i] = n+i; D[i][n] = -1; D[i][n+1] = b[i];}\n\t\t\trep(j,0,n) { N[j] = j; D[m][j] = -c[j]; }\n\t\t\tN[n] = -1; D[m+1][n] = 1;\n\t\t}\n\n\tvoid pivot(int r, int s) {\n\t\tT *a = D[r].data(), inv = 1 / a[s];\n\t\trep(i,0,m+2) if (i != r && abs(D[i][s]) > eps) {\n\t\t\tT *b = D[i].data(), inv2 = b[s] * inv;\n\t\t\trep(j,0,n+2) b[j] -= a[j] * inv2;\n\t\t\tb[s] = a[s] * inv2;\n\t\t}\n\t\trep(j,0,n+2) if (j != s) D[r][j] *= inv;\n\t\trep(i,0,m+2) if (i != r) D[i][s] *= -inv;\n\t\tD[r][s] = inv;\n\t\tswap(B[r], N[s]);\n\t}\n\n\tbool simplex(int phase) {\n\t\tint x = m + phase - 1;\n\t\tfor (;;) {\n\t\t\tint s = -1;\n\t\t\trep(j,0,n+1) if (N[j] != -phase) ltj(D[x]);\n\t\t\tif (D[x][s] >= -eps) return true;\n\t\t\tint r = -1;\n\t\t\trep(i,0,m) {\n\t\t\t\tif (D[i][s] <= eps) continue;\n\t\t\t\tif (r == -1 || MP(D[i][n+1] / D[i][s], B[i])\n\t\t\t\t             < MP(D[r][n+1] / D[r][s], B[r])) r = i;\n\t\t\t}\n\t\t\tif (r == -1) return false;\n\t\t\tpivot(r, s);\n\t\t}\n\t}\n\n\tT solve(vd &x) {\n\t\tint r = 0;\n\t\trep(i,1,m) if (D[i][n+1] < D[r][n+1]) r = i;\n\t\tif (D[r][n+1] < -eps) {\n\t\t\tpivot(r, n);\n\t\t\tif (!simplex(2) || D[m+1][n+1] < -eps) return -inf;\n\t\t\trep(i,0,m) if (B[i] == -1) {\n\t\t\t\tint s = 0;\n\t\t\t\trep(j,1,n+1) ltj(D[i]);\n\t\t\t\tpivot(i, s);\n\t\t\t}\n\t\t}\n\t\tbool ok = simplex(1); x = vd(n);\n\t\trep(i,0,m) if (B[i] < n) x[B[i]] = D[i][n+1];\n\t\treturn ok ? D[m][n+1] : inf;\n\t}\n};\n\nint n, m, x[105], y[105];\nll v[105];\n\nvvd A;\nvd b, c, t;\n\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i)\n\t\tcin >> x[i] >> y[i] >> v[i];\n\tfor (int i = 0; i < n; ++i) {\n\t\tt.clear();\n\t\tt.resize(n);\n\t\tt[i] = -1;\n\t\tA.push_back(t);\n\t\tb.push_back(0);\n\t\tt.clear();\n\t\tt.resize(n);\n\t\tt[i] = 1;\n\t\tA.push_back(t);\n\t\tb.push_back(1);\t\t\n\t}\n\tcin >> m;\n\tfor (int i = 0; i < m; ++i) {\n\t\tt.clear();\n\t\tt.resize(n);\n\t\tchar f;\n\t\tint a, bb;\n\t\tcin >> f >> a >> bb;\n\t\tif (f == 'L') {\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\tif (x[j] <= a)\n\t\t\t\t\tt[j] = 1;\n\t\t} if (f == 'R') {\n\t\t\tfor (int j = 0;j < n; ++j)\n\t\t\t\tif (x[j] >= a)\n\t\t\t\t\tt[j] = 1;\n\t\t} if (f == 'U') {\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\tif (y[j] >= a)\n\t\t\t\t\tt[j] = 1;\n\t\t} if (f == 'D') {\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\tif (y[j] <= a)\n\t\t\t\t\tt[j] = 1;\n\t\t}\n\t\tA.push_back(t);\n\t\tb.push_back(bb);\n\t}\n\tc.resize(n);\n\tfor (int i = 0; i < n; ++i)\n\t\tc[i] = v[i];\n\tvd xx;\n\tT val = LPSolver(A, b, c).solve(xx);\n\tcout << (lround)(val+.1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define IL inline\n#define _ 1005\n#define ll long long\n#define RG register\nusing namespace std ;\n\nIL ll gi() {\n\tRG ll data = 0 , fu = 1 ; RG char ch = 0 ;\n\twhile(ch != '-' && (ch < '0' || ch > '9')) ch = getchar() ; if(ch == '-') fu = -1 , ch = getchar() ;\n\twhile('0' <= ch && ch <= '9') data = (data << 1) + (data << 3) + (ch ^ 48) , ch = getchar() ; return data * fu ;\n}\n\nconst ll extra = 1e15 ;\nconst ll inf = 1e18 ;\n\nstruct _Edge{int to , next , flow ; ll cost ; } Edge[_ * _] ; int head[_] , cur[_] , CNT ;\nIL void AddEdge(int u , int v , int fl , ll cs) {\n\t//cout << u << \" ------------> \" << v << \" ; flow = \" << fl << \" , cost = \" << cs << endl ;\n\tEdge[++ CNT] = (_Edge){v , head[u] , fl , cs} ; head[u] = CNT ;\n\tEdge[++ CNT] = (_Edge){u , head[v] , 0 , -cs} ; head[v] = CNT ; return ; \n}\nstruct Point{int x,y ; ll v ; } p[_] ; bool vis[_] ;\nstruct Limit{char t ; int a,b ; } q[_] ;\nll dis[_],Cost,Ans ; int L[_],U[_],D[_],R[_],n,m,S,T,K,Flow,oo ;\n\nIL bool bfs() {\n\tqueue<int> Q ; \n\tfor(int i = 1; i <= T; i ++) dis[i] = inf , vis[i] = false ;\n\tQ.push(S) ; vis[S] = true ; dis[S] = 0 ;\n\twhile(!Q.empty()) {\n\t\tint u = Q.front() ; Q.pop() ;\n\t\tfor(int e = head[u] ; e ; e = Edge[e].next) {\n\t\t\tint v = Edge[e].to ;\n\t\t\tif(dis[v] > dis[u] + Edge[e].cost && Edge[e].flow > 0) {\n\t\t\t\tdis[v] = dis[u] + Edge[e].cost ;\n\t\t\t\tif(!vis[v]) vis[v] = true , Q.push(v) ;\n\t\t\t}\n\t\t}vis[u] = false ; \n\t}return dis[T] != inf ; \n}\nint dfs(int u , int Lim) {\n\tif(u == T || !Lim) return Lim ;\n\tll flow = 0 , f = 0 ; vis[u] = true ;\n\tfor(int &e = cur[u] ; e ; e = Edge[e].next) {\n\t\tint v = Edge[e].to ;\n\t\tif(!vis[v] && dis[v]==dis[u]+Edge[e].cost && (f = dfs(v,min(Lim,Edge[e].flow))) > 0) {\n\t\t\tflow += f ; Lim -= f ; Edge[e].flow -= f ; Edge[e ^ 1].flow += f ;\n\t\t\tCost += 1ll * flow * Edge[e].cost ;\n\t\t\tif(!Lim) break ;\n\t\t}\n\t}if(!flow) dis[u] = -1 ; vis[u] = false ; return flow ; \n}\n\t\nIL void solve() {\n\tfor(int i = 1; i <= T; i ++) head[i] = 0 ; CNT = 1 ; oo = 0 ;\n\tfor(int i = 1; i <= K ; i ++) L[i] = U[i] = 0 , R[i] = D[i] = 1989 ;\n\tfor(int i = 1; i <= m ; i ++)\n\t\tif(q[i].b < K) {\n\t\t\tif(q[i].t == 'L') L[q[i].b + 1] = max(L[q[i].b + 1] , q[i].a + 1) ;\n\t\t\telse if(q[i].t == 'R') R[K - q[i].b] = min(R[K - q[i].b] , q[i].a - 1) ;\n\t\t\telse if(q[i].t == 'U') U[q[i].b + 1] = max(U[q[i].b + 1] , q[i].a + 1) ;\n\t\t\telse if(q[i].t == 'D') D[K - q[i].b] = min(D[K - q[i].b] , q[i].a - 1) ;\n\t\t}\n\tfor(int i = 2; i <= K; i ++) L[i] = max(L[i] , L[i - 1]) ;\n\tfor(int i = K - 1; i >= 1; i --) R[i] = min(R[i] , R[i + 1]) ;\n\tfor(int i = 2; i <= K; i ++) U[i] = max(U[i] , U[i - 1]) ;\n\tfor(int i = K - 1; i >= 1; i --) D[i] = min(D[i] , D[i + 1]) ;\n\t//for(int i = 1; i <= K; i ++) cout <<\"choice\"<<i<<\":  \"<< L[i] << \" , \" << R[i] << \"   ;   \" << U[i] << \" \" << D[i] << endl ; \n\tS = 2 * (n + K) + 1 ;\n\tT = 2 * (n + K) + 2 ;\n\tfor(int i = 1; i <= K; i ++) AddEdge(S , i , 1 , 0) ;\n\tfor(int i = 1; i <= K; i ++) AddEdge(K + 2 * n + i , T , 1 , 0) ;\n\tfor(int i = 1; i <= K; i ++)\n\t\tfor(int j = 1; j <= n; j ++) {\n\t\t\tif(L[i] <= p[j].x && p[j].x <= R[i]) AddEdge(i , K + j , 1 , 0) ;\n\t\t\tif(U[i] <= p[j].y && p[j].y <= D[i]) AddEdge(K + n + j , K + 2 * n + i , 1 , 0) ;\n\t\t}\n\tfor(int i = 1; i <= n; i ++) AddEdge(K + i , K + n + i , 1 , extra - p[i].v) ;\n\tFlow = 0 ; Cost = 0 ; \n\twhile(bfs()) {\n\t\tfor(int i = 1; i <= T; i ++) cur[i] = head[i] ;\n\t\tFlow += dfs(S , 1e9) ;\n\t}\n\tCost -= 1ll * extra * K ; Cost = -Cost ;\n\tif(Flow == K && Ans < Cost) Ans = Cost ; return ; \n}\n\nint main() {\n\tn = gi() ;\n\tfor(int i = 1; i <= n; i ++) p[i].x = gi() , p[i].y = gi() , p[i].v = gi() ;\n\tm = gi() ;\n    for(int i = 1; i <= m; i ++) scanf(\"%c %d %d\\n\" , &q[i].t , &q[i].a , &q[i].b) ;\n\tfor(int i = 1; i <= m; i ++) if(q[i].t == 'U') q[i].t = 'D' ; else if(q[i].t == 'D') q[i].t = 'U' ;\n\t//for(int i = 1; i <=m; i ++) cout << q[i].t << \" ; a = \" << q[i].a << \" , b = \" << q[i].b << endl ;\n\tAns = 0 ;\n\tfor(K = 1; K <= n; ++ K) solve() ;\n\tprintf(\"%lld\\n\" , Ans) ;\n\treturn 0 ; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long ll;\ntypedef std::pair<ll,int> pr;\nconst int maxn = 10010;\nll x[maxn], y[maxn], v[maxn], a[maxn], b[maxn];\nchar t[maxn]; \nint n,m;\nnamespace mcmf{\n    const int maxn = 10010,maxm = 1001000;\n    struct T{ int to,nxt,v; ll f; } way[maxm << 1];;\n    int h[maxn],num = 1;\n    inline void link(int x,int y,int v,ll f){\n        way[++num]={y,h[x],v,f},h[x]=num;\n        way[++num]={x,h[y],0,-f},h[y]=num;\n    }\n    ll d[maxn],dis[maxn]; int vis[maxn],fr[maxn];\n    inline void bellmanford(int s,int t){\n        std::queue<int> q;\n\t\tstd::fill(d + s,d + t + 1,1e18);\n        std::fill(vis + s,vis + t + 1,0);\n        for(d[s] = 0,q.push(s);!q.empty();){\n            int t = q.front(); q.pop(); vis[t] = 0;\n            for(int i=h[t];i;i=way[i].nxt) \n                if(way[i].v && d[way[i].to] > d[t] + way[i].f){\n                    d[way[i].to] = d[t] + way[i].f;\n                    if(!vis[way[i].to]) vis[way[i].to]=1,q.push(way[i].to);\n                }\n        }\n    }\n    inline bool dijkstra(int s,int t){\n        std::priority_queue<pr,std::vector<pr>,std::greater<pr>> q;\n        std::fill(dis + s,dis + t + 1,1e18);\n        std::fill(vis + s,vis + t + 1,0);\n        for(dis[s] = 0,q.push(pr(0,s));!q.empty();){\n            pr t=q.top(); q.pop(); if(vis[t.second]) continue; vis[t.second] = 1;\n            for(int i=h[t.second];i;i=way[i].nxt){\n                const ll v = way[i].f + d[t.second] - d[way[i].to];\n                if(way[i].v && dis[way[i].to] > dis[t.second] + v){\n                    dis[way[i].to] = dis[t.second] + v; fr[way[i].to] = i;\n                    q.push(pr(dis[way[i].to],way[i].to));\n                }\n            }\n        }\n        return dis[t] < 9e17;\n    }\n    inline std::pair<ll,ll> ek(int s,int t){\n        bellmanford(s,t); ll flow = 0,cost = 0;\n        while(dijkstra(s,t)){\n            ll sum = 0,fl = 1e18;\n            for(int i=fr[t];i;i=fr[way[i^1].to])\n                fl = std::min<ll>(way[i].v,fl), sum += way[i].f;\n            flow += fl,cost += fl * sum;\n            for(int i=fr[t];i;i=fr[way[i^1].to]) way[i].v -= fl,way[i ^ 1].v += fl;\n            for(int i=s;i<=t;++i) d[i] += dis[i];\n        }\n\t\tstd::fill(h + s,h + t + 1,0);\n        return {flow,cost};\n    }\n}\nint lx[maxn], rx[maxn];\nint ly[maxn], ry[maxn];\ninline void up(int & x,int y){ if(x < y) x = y; }\ninline void down(int & x,int y){ if(x > y) x = y; }\nint main(){\n    std::ios::sync_with_stdio(false),std::cin.tie(0);\n    std::cin >> n;\n\tfor(int i = 1;i <= n;++i) std::cin >> x[i] >> y[i] >> v[i];\n\tstd::cin >> m;\n\tfor(int i = 1;i <= m;++i) std::cin >> t[i] >> a[i] >> b[i];\n\tll ans = 0;\n\tfor(int cnt = 1;cnt <= n;++cnt) {\n\t\tfor(int i = 0;i <= cnt + 1;++i) lx[i] = ly[i] = 0, rx[i] = ry[i] = 1e9;\n\t\tfor(int i = 1;i <= m;++i) if(b[i] < cnt) {\n\t\t\tif(t[i] == 'L') up(lx[b[i] + 1], a[i] + 1);\n\t\t\tif(t[i] == 'R') down(rx[cnt - b[i]], a[i] - 1);\n\t\t\tif(t[i] == 'D') up(ly[b[i] + 1], a[i] + 1);\n\t\t\tif(t[i] == 'U') down(ry[cnt - b[i]], a[i] - 1);\n\t\t}\n\t\tfor(int i = cnt;i >= 1;--i) down(rx[i], rx[i + 1]), down(ry[i], ry[i + 1]);\n\t\tfor(int i = 1;i <= cnt;++i) up(lx[i], lx[i - 1]), up(ly[i], ly[i - 1]);\n\t\tmcmf::num = 1;\n\t\tusing mcmf::link;\n\t\tfor(int j = 1;j <= n;++j) link(j + cnt,j + cnt + n,1,-v[j]);\n\t\tfor(int i = 1;i <= cnt;++i) {\n\t\t\tlink(0, i, 1, 0), link(i + cnt + n + n,cnt + n + n + cnt + 1, 1, 0);\n\t\t\tfor(int j = 1;j <= n;++j) if(lx[i] <= x[j] && x[j] <= rx[i]) link(i, j + cnt, 1, 0);\n\t\t\tfor(int j = 1;j <= n;++j) if(ly[i] <= y[j] && y[j] <= ry[i]) link(j + cnt + n, i + cnt + n + n, 1, 0);\n\t\t}\n\t\tauto it = mcmf::ek(0,cnt + n + n + cnt + 1);\n\t\tans = std::max(ans, - it.second);\n\t}\n\tstd::cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define space putchar(' ')\n#define enter putchar('\\n')\n#define MAXN 100005\n#define eps 1e-10\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef unsigned int u32;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;T f = 1;char c = getchar();\n    while(c < '0' || c > '9') {\n\tif(c == '-') f = -1;\n\tc = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n\tres = res * 10 + c - '0';\n\tc = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n\tout(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nstruct node {\n    int to,next,cap;int64 val;\n}E[1000005];\nint sumE,head[505],a[85],b[85],x[85],y[85],N,M;\nint L[2][85],R[2][85],S,T,f;\nint64 val[85],res,ans,ex;\nbool vis[505];\nchar s[330][2];\nvoid add(int u,int v,int c,int64 a) {\n    E[++sumE].to = v;\n    E[sumE].next = head[u];\n    E[sumE].cap = c;\n    E[sumE].val = a;\n    head[u] = sumE;\n}\nvoid addtwo(int u,int v,int c,int64 a) {\n    add(u,v,c,a);\n    add(v,u,0,-a);\n}\nvoid build(int K) {\n    sumE = 1;memset(head,0,sizeof(head));\n    for(int i = 1 ; i <= N ; ++i) L[0][i] = L[1][i] = 1,R[0][i] = R[1][i] = 100;\n    for(int i = 1 ; i <= M ; ++i) {\n        if(b[i] >= K) continue;\n        if(s[i][0] == 'L') {\n            L[0][b[i] + 1] = a[i] + 1;\n        }\n        else if(s[i][0] == 'R') {\n            R[0][K - b[i]] = a[i] - 1;\n        }\n        else if(s[i][0] == 'D') {\n            L[1][b[i] + 1] = a[i] + 1;\n        }\n        else if(s[i][0] == 'U') {\n            R[1][K - b[i]] = a[i] - 1;\n        }\n    }\n    for(int i = 2 ; i <= K ; ++i) {\n    \tL[0][i] = max(L[0][i - 1],L[0][i]);\n    \tL[1][i] = max(L[1][i - 1],L[1][i]);\n    }\n    for(int i = K - 1 ; i >= 1 ; --i) {\n    \tR[0][i] = min(R[0][i + 1],R[0][i]);\n    \tR[1][i] = min(R[1][i + 1],R[1][i]);\n    }\n    S = 1;T = 2 * K + 2 * N + 2;\n    for(int i = 1 ; i <= K ; ++i) {\n    \taddtwo(S,i + 1,1,0);\n    \taddtwo(i + K + 2 * N + 1,T,1,0);\n    \tfor(int j = 1 ; j <= N ; ++j) {\n    \t    if(x[j] >= L[0][i] && x[j] <= R[0][i]) {\n        \t\taddtwo(i + 1,K + j + 1,1,0);\n    \t    }\n    \t    if(y[j] >= L[1][i] && y[j] <= R[1][i]) {\n        \t\taddtwo(K + N + j + 1,i + K + 2 * N + 1,1,0);\n    \t    }\n    \t}\n    }\n    for(int i = 1 ; i <= N ; ++i) {\n        addtwo(K + i + 1,K + N + i + 1,1,-val[i]);\n    }\n\n}\nint maxflow(int u,int aug) {\n    if(u == T) {\n    \tres += ex * aug;\n        f += aug;\n    \treturn aug;\n    }\n    int flow = 0;\n    vis[u] = 1;\n    for(int i = head[u] ; i ; i = E[i].next) {\n        int v = E[i].to;\n    \tif(E[i].cap > 0 && !vis[v] && E[i].val == 0) {\n    \t    int t = maxflow(v,min(E[i].cap,aug - flow));\n    \t    flow += t;\n    \t    E[i].cap -= t;\n    \t    E[i ^ 1].cap += t;\n    \t}\n    }\n    return flow;\n}\nbool modlabel() {\n    int64 p = 1e18;\n    for(int u = S ; u <= T ; ++u) {\n    \tif(vis[u]) {\n    \t    for(int i = head[u] ; i ; i = E[i].next) {\n        \t\tint v = E[i].to;\n        \t\tif(!vis[v] && E[i].cap > 0 && E[i].val < p) p = E[i].val;\n    \t    }\n    \t}\n    }\n    if(p == 1e18) return false;\n    ex += p;\n    for(int u = S ; u <= T ; ++u) {\n    \tif(vis[u]) {\n    \t    for(int i = head[u] ; i ; i = E[i].next) {\n        \t\tE[i].val -= p;\n        \t\tE[i ^ 1].val += p;\n    \t    }\n    \t}\n    }\n    return true;\n}\nvoid Init() {\n    read(N);\n    for(int i = 1 ; i <= N ; ++i) {\n    \tread(x[i]);read(y[i]);read(val[i]);\n    }\n    read(M);\n    for(int i = 1 ; i <= M ; ++i) {\n    \tscanf(\"%s\",s[i]);read(a[i]);read(b[i]);\n    }\n}\nvoid Solve() {\n    ans = 0;\n    for(int i = 1 ; i <= N ; ++i) {\n    \tbuild(i);\n    \tres = 0;ex = 0;\n        f = 0;\n    \tdo {\n    \t    do {\n                memset(vis,0,sizeof(vis));\n    \t    }while(maxflow(1,i));\n    \t}while(modlabel());\n        if(f == i) ans = max(ans,-res);\n    }\n    out(ans);enter;\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Init();\n    Solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<cstring>\nusing namespace std;\n#define N 421\n#define M 38300\nint s[N][3],v[N][2],n,m,l[N][2],r[N][2],head[N],cur[N],cnt,in[N],vis[N];\nchar c[12];\nlong long dis[N],c1[N],as1,as;\nstruct edge{int t,next,v;long long c;}ed[M];\nvoid adde(int f,int t,int v,long long c){ed[++cnt]=(edge){t,head[f],v,c};head[f]=cnt;ed[++cnt]=(edge){f,head[t],0,-c};head[t]=cnt;}\nbool spfa(int s,int t)\n{\n\tmemset(dis,-0x3f,sizeof(dis));\n\tmemcpy(cur,head,sizeof(cur));\n\tqueue<int> tp;\n\ttp.push(s);dis[s]=0;in[s]=1;\n\twhile(!tp.empty())\n\t{\n\t\tint r=tp.front();tp.pop();in[r]=0;\n\t\tfor(int i=head[r];i;i=ed[i].next)\n\t\tif(ed[i].v&&dis[ed[i].t]<dis[r]+ed[i].c)\n\t\t{\n\t\t\tdis[ed[i].t]=dis[r]+ed[i].c;\n\t\t\tif(!in[ed[i].t])in[ed[i].t]=1,tp.push(ed[i].t);\n\t\t}\n\t}\n\treturn dis[t]>-1e18;\n}\nint dfs(int u,int t,int f)\n{\n\tif(!f||u==t)return f;\n\tvis[u]=1;\n\tint tp,as=0;\n\tfor(int& i=cur[u];i;i=ed[i].next)\n\tif(!vis[ed[i].t]&&ed[i].v&&dis[ed[i].t]==dis[u]+ed[i].c&&(tp=dfs(ed[i].t,t,min(f,ed[i].v))))\n\t{\n\t\ted[i].v-=tp;ed[i^1].v+=tp;\n\t\tf-=tp,as+=tp;as1+=ed[i].c*tp;\n\t\tif(!f){vis[u]=0;return as;}\n\t}\n\tvis[u]=0;return as;\n}\nint dinic(int s,int t){int tp=0;while(spfa(s,t))tp+=dfs(s,t,1e8);return tp;}\nint main()\n{\n\tscanf(\"%d\",&n);for(int i=1;i<=n;i++)scanf(\"%d%d%lld\",&v[i][0],&v[i][1],&c1[i]);\n\tscanf(\"%d\",&m);for(int i=1;i<=m;i++){scanf(\"%s%d%d\",c+1,&s[i][1],&s[i][2]);if(c[1]=='U')s[i][0]=0;if(c[1]=='D')s[i][0]=1;if(c[1]=='R')s[i][0]=2;if(c[1]=='L')s[i][0]=3;}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tcnt=1;for(int j=1;j<=402;j++)head[j]=0;\n\t\tfor(int j=1;j<=i;j++)l[j][0]=1,l[j][1]=100,r[j][0]=1,r[j][1]=100;\n\t\tfor(int j=1;j<=m;j++)if(i>s[j][2])\n\t\t{\n\t\t\tint tp=s[j][2];\n\t\t\tif(s[j][0]==1)\n\t\t\t{\n\t\t\t\tfor(int k=1;k<=i-tp;k++)l[k][0]=max(l[k][0],s[j][1]+1);\n\t\t\t}\n\t\t\tif(s[j][0]==0)\n\t\t\t{\n\t\t\t\tfor(int k=tp+1;k<=i;k++)l[k][1]=min(l[k][1],s[j][1]-1);\n\t\t\t}\n\t\t\tif(s[j][0]==3)\n\t\t\t{\n\t\t\t\tfor(int k=1;k<=i-tp;k++)r[k][0]=max(r[k][0],s[j][1]+1);\n\t\t\t}\n\t\t\tif(s[j][0]==2)\n\t\t\t{\n\t\t\t\tfor(int k=tp+1;k<=i;k++)r[k][1]=min(r[k][1],s[j][1]-1);\n\t\t\t}\n\t\t}\n\t\tint s1=401,t=402;\n\t\tfor(int j=1;j<=i;j++)adde(s1,j,1,0);\n\t\tfor(int j=1;j<=i;j++)\n\t\tfor(int k=l[j][0];k<=l[j][1];k++)\n\t\tadde(j,k+100,1,0);\n\t\tfor(int j=1;j<=n;j++)adde(v[j][1]+100,v[j][0]+200,1,c1[j]);\n\t\tfor(int j=1;j<=i;j++)\n\t\tfor(int k=r[j][0];k<=r[j][1];k++)\n\t\tadde(k+200,j+300,1,0);\n\t\tfor(int j=1;j<=i;j++)adde(j+300,t,1,0);\n\t\tas1=0;int tp2=dinic(s1,t);\n\t\tif(tp2==i)as=max(as,as1);\n\t}\n\tprintf(\"%lld\\n\",as);\n}//"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<queue>\nusing namespace std;\nconst int maxn = 2e5+5;\nint en[maxn],nt[maxn],la[maxn],v[maxn],owo;\n//owo 1 !!!\nlong long len[maxn];\nvoid adg(int x,int y,int vv,long long le) {\n\ten[++owo]=y; nt[owo]=la[x]; la[x] = owo; len[owo] = le; v[owo] = vv;\n\ten[++owo]=x; nt[owo]=la[y]; la[y] = owo; len[owo] = -le; v[owo] = 0;\n}\nlong long ANS;\nint N,M,tot,QD,ZD;\nint X[maxn],Y[maxn];\nlong long V[maxn];\nchar ss[10],T[maxn];\nint A[maxn],B[maxn];\nint Lx[105],Rx[105];\nint Ly[105],Ry[105];\nint IDX[maxn],IDY[maxn],IDB[maxn];\nqueue<int>Q;\nlong long dis[maxn];\nint path[maxn],epath[maxn];\nbool rd[maxn];\nlong long MAXVAL;\nbool spfa() {\n\tfor(int i=1;i<=tot;i++) {\n\t\tdis[i] = -1e15; rd[i] = 0;\n\t}\n\trd[QD] = 1; dis[QD] = 0;\n\tQ.push(QD);\n\twhile(Q.size()) {\n\t\tint x = Q.front(); Q.pop(); rd[x] = 0;\n\t\tfor(int it=la[x];it;it=nt[it]) {\n\t\t\tint y = en[it];\n\t\t\tif(v[it]&&dis[y] < dis[x] + len[it]) {\n\t\t\t\tdis[y] = dis[x] + len[it];\n\t\t\t\tpath[y] = x; epath[y] = it;\n\t\t\t\tif(!rd[y]) Q.push(y),rd[y]=1;\n\t\t\t}\n\t\t}\n\t}\n\tif(dis[ZD]<=0) return 0;\n\tint p = ZD;\n\tfor(;p!=QD;p=path[p])\n\t\tv[epath[p]]--,v[epath[p]^1]++;\n\tMAXVAL += dis[ZD];\n\treturn 1;\n}\n\nvoid solve(int K) {\n\tfor(int i=1;i<=tot;i++) la[i] = 0; \n\towo = 1; tot = 0;\n\tfor(int i=1;i<=100;i++) {\n\t\tIDX[i] = ++tot; IDY[i] = ++tot; \n\t}\n\tfor(int i=1;i<=N;i++) {\n\t\tIDB[i] = ++tot;\n\t\tadg(IDX[X[i]],IDB[i],1,V[i]);\n\t\tadg(IDB[i],IDY[Y[i]],1,0);\n\t}\n\t\n\tfill(Lx+1,Lx+1+K,1); fill(Rx+1,Rx+1+K,100);\n\tfill(Ly+1,Ly+1+K,1); fill(Ry+1,Ry+1+K,100);\n\t\n\tfor(int i=1;i<=M;i++) {\n\t\tif(T[i]=='L') Lx[B[i]+1] = max(Lx[B[i]+1],A[i]+1);\n\t\telse if(T[i]=='R'&&K>B[i]) Rx[K-B[i]] = min(Rx[K-B[i]],A[i]-1);\n\t\telse if(T[i]=='D') Ly[B[i]+1] = max(Ly[B[i]+1],A[i]+1);\n\t\telse if(T[i]=='U'&&K>B[i]) Ry[K-B[i]] = min(Ry[K-B[i]],A[i]-1);\n\t}\n\tfor(int i=2;i<=K;i++) Lx[i] = max(Lx[i],Lx[i-1]),Ly[i] = max(Ly[i],Ly[i-1]);\n\tfor(int i=K-1;i>=1;i--) Rx[i] = min(Rx[i],Rx[i+1]),Ry[i] = min(Ry[i],Ry[i+1]);\n\tQD = ++tot; ZD = ++tot;\n\tfor(int i=1;i<=K;i++) {\n\t\tif( (Lx[i] > Rx[i]) || (Ly[i]>Ry[i]) ) return;\n\t\tint p = ++tot; int q = ++tot;\n\t\tadg(QD,p,1,0); \n\t\tadg(q,ZD,1,0);\n\t\tfor(int j=Lx[i];j<=Rx[i];j++) adg(p,IDX[j],1,0);\n\t\tfor(int j=Ly[i];j<=Ry[i];j++) adg(IDY[j],q,1,0);\n\t}\n\tint flow = 0;\n\tMAXVAL = 0;\n\twhile(spfa()) flow++;\n\tif(flow!=K) return;\n\tANS = max(ANS,MAXVAL);\n}\nint main() {\n\tscanf(\"%d\",&N);\n\tfor(int i=1;i<=N;i++) {\n\t\tscanf(\"%d%d%lld\",&X[i],&Y[i],&V[i]);\n\t}\n\tscanf(\"%d\",&M);\n\tfor(int i=1;i<=M;i++) {\n\t\tscanf(\"%s%d%d\",&ss[1],&A[i],&B[i]);\n\t\tT[i] = ss[1];\n\t}\n\tfor(int i=1;i<=N;i++) solve(i);\n\tprintf(\"%lld\",ANS);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof x)\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define fi first\n#define se second\n#define y0 _y0\n#define y1 _y1\n#define outval(x) cerr<<#x\" = \"<<x<<endl\n#define outtag(x) cerr<<\"-----------------\"#x\"-----------------\\n\"\n#define outarr(a,L,R) cerr<<#a\"[\"<<L<<\"..\"<<R<<\"] = \";\\\n                    For(_x,L,R) cerr<<a[_x]<<\" \";cerr<<endl;\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair <int,int> pii;\nLL read(){\n    LL x=0,f=0;\n    char ch=getchar();\n    while (!isdigit(ch))\n        f=ch=='-',ch=getchar();\n    while (isdigit(ch))\n        x=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n    return f?-x:x;\n}\nconst int N=85,M=325;\nconst LL LLINF=1e18;\nint n,m;\nstruct Node{\n\tint x,y;\n\tLL v;\n}a[N];\nstruct Limit{\n\tchar c;\n\tint a,b;\n}l[M];\nnamespace flows{\n\tconst int N=85*4,M=85*85*2*2;\n\tstruct Edge{\n\t\tint x,y,nxt,cap;\n\t\tLL cost;\n\t\tEdge(){}\n\t\tEdge(int _x,int _y,int _nxt,int _cap,LL _cost){\n\t\t\tx=_x,y=_y,nxt=_nxt,cap=_cap,cost=_cost;\n\t\t}\n\t}e[M];\n\tint n,S,T,cnt;\n\tint fst[N],cur[N],vis[N];\n\tLL dis[N];\n\tvoid clear(int _n,int _S,int _T){\n\t\tn=_n,S=_S,T=_T;\n\t\tclr(fst),cnt=1;\n\t}\n\tvoid Add(int x,int y,int cap,LL cost){\n\t\te[++cnt]=Edge(x,y,fst[x],cap,cost),fst[x]=cnt;\n\t\te[++cnt]=Edge(y,x,fst[y],0,-cost),fst[y]=cnt;\n\t}\n\tint bfs(){\n\t\tstatic queue <int> q;\n\t\twhile (!q.empty())\n\t\t\tq.pop();\n\t\tFor(i,1,n)\n\t\t\tdis[i]=-LLINF,vis[i]=0;\n\t\tdis[S]=0,q.push(S);\n\t\twhile (!q.empty()){\n\t\t\tint x=q.front();\n\t\t\tq.pop();\n\t\t\tvis[x]=0;\n\t\t\tfor (int i=fst[x];i;i=e[i].nxt){\n\t\t\t\tint y=e[i].y;\n\t\t\t\tif (e[i].cap&&dis[x]+e[i].cost>dis[y]){\n\t\t\t\t\tdis[y]=dis[x]+e[i].cost;\n\t\t\t\t\tif (!vis[y]){\n\t\t\t\t\t\tvis[y]=1;\n\t\t\t\t\t\tq.push(y);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dis[T]>-LLINF;\n\t}\n\tint dfs(int x,int Lim){\n\t\tif (x==T||!Lim)\n\t\t\treturn Lim;\n\t\tint rem=Lim;\n\t\tvis[x]=1;\n\t\tfor (int &i=cur[x];i;i=e[i].nxt){\n\t\t\tint y=e[i].y;\n\t\t\tif (!vis[y]&&e[i].cap&&dis[x]+e[i].cost==dis[y]){\n\t\t\t\tint d=dfs(y,min(rem,e[i].cap));\n\t\t\t\trem-=d,e[i].cap-=d,e[i^1].cap+=d;\n\t\t\t}\n\t\t}\n\t\tvis[x]=0;\n\t\treturn Lim-rem;\n\t}\n\tLL Dinic(){\n\t\tLL cost=0;\n\t\twhile (bfs()){\n\t\t\tclr(vis);\n\t\t\tFor(i,1,n)\n\t\t\t\tcur[i]=fst[i];\n\t\t\tint d=dfs(S,1e9);\n\t\t\tcost+=dis[T]*d;\n\t\t}\n\t\treturn cost;\n\t}\n}\nvoid ckmax(int &x,int y){\n\tif (x<y)\n\t\tx=y;\n}\nvoid ckmin(int &x,int y){\n\tif (x>y)\n\t\tx=y;\n}\nint x0[N],x1[N],y0[N],y1[N];\nint main(){\n\tn=read();\n\tFor(i,1,n)\n\t\ta[i].x=read(),a[i].y=read(),a[i].v=read();\n\tm=read();\n\tFor(i,1,m){\n\t\tchar s[10];\n\t\tcin>>s>>l[i].a>>l[i].b;\n\t\tl[i].c=s[0];\n\t}\n\tLL ans=0;\n\tFor(k,1,n){\n\t\tint S=(n+k)*2+1,T=S+1;\n\t\tflows::clear(T,S,T);\n\t\tFor(i,0,k+1){\n\t\t\tx0[i]=y0[i]=0;\n\t\t\tx1[i]=y1[i]=101;\n\t\t}\n\t\tFor(i,1,m){\n\t\t\tif (l[i].b>=k)\n\t\t\t\tcontinue;\n\t\t\tif (l[i].c=='L')\n\t\t\t\tckmax(x0[l[i].b+1],l[i].a);\n\t\t\tif (l[i].c=='R')\n\t\t\t\tckmin(x1[k-l[i].b],l[i].a);\n\t\t\tif (l[i].c=='D')\n\t\t\t\tckmax(y0[l[i].b+1],l[i].a);\n\t\t\tif (l[i].c=='U')\n\t\t\t\tckmin(y1[k-l[i].b],l[i].a);\n\t\t}\n\t\tFor(i,1,k){\n\t\t\tckmax(x0[i],x0[i-1]);\n\t\t\tckmax(y0[i],y0[i-1]);\n\t\t}\n\t\tFod(i,k,1){\n\t\t\tckmin(x1[i],x1[i+1]);\n\t\t\tckmin(y1[i],y1[i+1]);\n\t\t}\n\t\tFor(i,1,n)\n\t\t\tflows::Add(i,i+n,1,a[i].v);\n\t\tFor(i,1,k){\n\t\t\tflows::Add(S,i+n*2,1,0);\n\t\t\tflows::Add(i+n*2+k,T,1,0);\n\t\t\tFor(j,1,n){\n\t\t\t\tif (x0[i]<a[j].x&&a[j].x<x1[i])\n\t\t\t\t\tflows::Add(i+n*2,j,1,0);\n\t\t\t\tif (y0[i]<a[j].y&&a[j].y<y1[i])\n\t\t\t\t\tflows::Add(j+n,i+n*2+k,1,0);\n\t\t\t}\n\t\t}\n\t\tans=max(ans,flows::Dinic());\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <vector>\n#include <bitset>\n#include <cstdio>\n#include <cctype>\n#include <string>\n#include <numeric>\n#include <cstring>\n#include <cassert>\n#include <climits>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\n#include <functional>\nusing namespace std ;\n#define rep(i, a, b) for (register int i = (a); i <= (b); ++i)\n#define per(i, a, b) for (register int i = (a); i >= (b); --i)\n#define loop(it, v) for (auto it = v.begin(); it != v.end(); it++)\n#define cont(i, x) for (register int i = head[x]; i; i = edge[i].nex)\n#define clr(a) memset(a, 0, sizeof(a))\n#define ass(a, cnt) memset(a, cnt, sizeof(a))\n#define cop(a, b) memcpy(a, b, sizeof(a))\n#define lowbit(x) (x & -x)\n#define all(x) x.begin(), x.end()\n#define SC(t, x) static_cast <t> (x)\n#define ub upper_bound\n#define lb lower_bound\n#define pqueue priority_queue\n#define mp make_pair\n#define pb push_back\n#define pof pop_front\n#define pob pop_back\n#define fi first\n#define se second\n#define y1 y1_\n#define Pi acos(-1.0)\n#define iv inline void\n#define enter putchar('\\n')\n#define siz(x) ((int)x.size())\n#define file(x) freopen(x\".in\", \"r\", stdin),freopen(x\".out\", \"w\", stdout)\ntypedef double db ;\ntypedef long long ll ;\ntypedef unsigned long long ull ;\ntypedef pair <int, int> pii ;\ntypedef vector <int> vi ;\ntypedef vector <pii> vii ;\ntypedef queue <int> qi ;\ntypedef queue <pii> qii ;\ntypedef set <int> si ;\ntypedef map <int, int> mii ;\ntypedef map <string, int> msi ;\nconst int maxn = 200 + 5 ;\nconst int inf = 0x3f3f3f3f ;\nconst int iinf = 1 << 30 ;\nconst ll linf = 2e18 ;\nconst ll mod = 998244353 ;\nconst double eps = 1e-7 ;\ntemplate <class T = int> T read()\n{\n\tT f = 1, a = 0;\n\tchar ch = getchar() ;\n\twhile (!isdigit(ch)) { if (ch == '-') f = -1 ; ch = getchar() ; }\n\twhile (isdigit(ch)) { a =  (a << 3) + (a << 1) + ch - '0' ; ch = getchar() ; }\n\treturn a * f ;\n}\n\n#define int ll\n#define inf linf\n\nnamespace mcmf\n{\n\tconst int maxm = 10 * maxn;\n\tint n, s, t;\n\tstruct node\n\t{\n\t\tint nex, to, val, cost;\n\t}\n\tedge[maxm];\n\tint head[maxn], tot = 1;\n\tvoid add_path(int u, int v, int w, int c)\n\t{\n\t\tedge[++ tot] = (node){head[u], v, w, c};\n\t\thead[u] = tot;\n\t}\n\tvoid add_flow(int u, int v, int w, int c)\n\t{\n\t\tadd_path(u, v, w, c);\n\t\tadd_path(v, u, 0, -c);\n\t}\n\tint dist[maxn], pre[maxn], lim[maxn], vis[maxn];\n\tbool spfa()\n\t{\n\t\trep(i, 1, n) dist[i] = inf;\n\t\tqi q;\n\t\tq.push(s), dist[s] = 0, lim[s] = inf, lim[t] = 0;\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tint now = q.front();\n\t\t\tq.pop();\n\t\t\tvis[now] = 0;\n\t\t\tcont(i, now)\n\t\t\t{\n\t\t\t\tint to = edge[i].to, val = edge[i].val, cost = edge[i].cost;\n\t\t\t\tif(!val || dist[to] <= dist[now] + cost) continue;\n\t\t\t\tdist[to] = dist[now] + cost, lim[to] = min(lim[now], val), pre[to] = i ^ 1;\n\t\t\t\tif(!vis[to]) q.push(to), vis[to] = 1;\n\t\t\t}\n\t\t}\n\t\treturn lim[t];\n\t}\n\tint maxflow, mincost;\n\tvoid updata()\n\t{\n\t\tmaxflow += lim[t];\n\t\tfor(int i = t; i != s; i = edge[pre[i]].to)\n\t\t{\n\t\t\tedge[pre[i]].val += lim[t], edge[pre[i] ^ 1].val -= lim[t];\n\t\t\tmincost += lim[t] * edge[pre[i] ^ 1].cost;\n\t\t}\n\t}\n\tvoid clear()\n\t{\n\t\trep(i, 1, n) head[i] = 0;\n\t\ttot = 1;\n\t\tmaxflow = mincost = 0;\n\t}\n}\n\nint n, x[maxn], y[maxn], w[maxn], ans;\n\nint m, t[maxn], a[maxn], b[maxn], pos[maxn];\n\nint minn[maxn], maxx[maxn];\n\nvoid solve(int sum)\n{\n\t// puts(\"------------solve-------------\");\n\t// printf(\"sum : %lld\\n\", sum);\n\tmcmf :: n = 2 * (sum + n + 1);\n\trep(i, 1, sum << 1) maxx[i] = inf, minn[i] = 0;\n\trep(i, 1, m)\n\t{\n\t\tif(b[i] >= sum) continue;\n\t\tif(t[i] == 1) minn[b[i] + 1] = max(minn[b[i] + 1], a[i] + 1);\n\t\tif(t[i] == 2) maxx[sum - b[i]] = min(maxx[sum - b[i]], a[i] - 1);\n\t\tif(t[i] == 3) minn[b[i] + 1 + sum] = max(minn[b[i] + 1 + sum], a[i] + 1);\n\t\tif(t[i] == 4) maxx[sum - b[i] + sum] = min(maxx[sum - b[i] + sum], a[i] - 1);\n\t}\n\trep(i, 2, sum) minn[i] = max(minn[i], minn[i - 1]);\n\tper(i, sum - 1, 1) maxx[i] = min(maxx[i], maxx[i + 1]);\n\trep(i, sum + 2, sum + sum) minn[i] = max(minn[i], minn[i - 1]);\n\tper(i, sum + sum - 1, sum + 1) maxx[i] = min(maxx[i], maxx[i + 1]);\n\t// rep(i, 1, sum)\n\t// {\n\t// \tprintf(\"i : %lld\\n\", i);\n\t// \tputs(\"x : \");\n\t// \tprintf(\"%lld %lld\\n\", minn[i], maxx[i]);\n\t// \tputs(\"y : \");\n\t// \tprintf(\"%lld %lld\\n\", minn[sum + i], maxx[sum + i]);\n\t// }\n\t// puts(\"add_limit success\");\n\tmcmf :: s = mcmf :: n, mcmf :: t = mcmf :: n - 1;\n\trep(i, 1, sum) mcmf :: add_flow(mcmf :: s, i, 1, 0), mcmf :: add_flow(sum + n + n + i, mcmf :: t, 1, 0);\n\trep(i, 1, n)\n\t{\n\t\tmcmf :: add_flow(sum + i, sum + n + i, 1, -w[i]);\n\t\tpos[i] = mcmf :: tot;\n\t\trep(j, 1, sum)\n\t\t{\n\t\t\tif(x[i] >= minn[j] && x[i] <= maxx[j]) mcmf :: add_flow(j, sum + i, 1, 0);\n\t\t\tif(y[i] >= minn[j + sum] && y[i] <= maxx[j + sum]) mcmf :: add_flow(sum + n + i, sum + n + n + j, 1, 0);\n\t\t}\n\t}\n\t// puts(\"build_graph success\");\n\twhile (mcmf :: spfa()) mcmf :: updata();\n\tans = min(ans, mcmf :: mincost);\n\t// printf(\"mincost : %lld\\n\", mcmf :: mincost);\n\t// puts(\"choose : \");\n\t// rep(i, 1, n) if(mcmf :: edge[pos[i]].val == 1) printf(\"%lld \", i);\n\t// enter;\n\tmcmf :: clear();\n\treturn ;\n}\n\nsigned main()\n{\n\tscanf(\"%lld\", &n);\n\trep(i, 1, n) scanf(\"%lld %lld %lld\", &x[i], &y[i], &w[i]);\n\tscanf(\"%lld\", &m);\n\trep(i, 1, m)\n\t{\n\t\tchar tmp;\n\t\tscanf(\"%s\", &tmp);\n\t\tif(tmp == 'L') t[i] = 1;\n\t\tif(tmp == 'R') t[i] = 2;\n\t\tif(tmp == 'D') t[i] = 3;\n\t\tif(tmp == 'U') t[i] = 4;\n\t\tscanf(\"%lld %lld\", &a[i], &b[i]);\n\t}\n\trep(i, 1, n) solve(i);\n\tprintf(\"%lld\\n\", -ans);\n\treturn 0;\n}\n\n\n/*\n\n7\n1 3 6\n1 5 9\n3 1 8\n4 3 8\n6 2 9\n5 4 11\n5 7 10\n4\nL 3 1\nR 2 3\nD 5 3\nU 4 2\n\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 5000005\nint tot,last[N],to[N],Next[N],flow[N];\nlong long val[N],dis[N];\nint e[N],q[10000005],S,T,Lx[N],Rx[N],Ly[N],Ry[N];\nint X[N],Y[N],n,m,pre[N];\nstruct node {\n  \tint id,x,y;\n}b[N],A[N];\nstruct pa {\n  \tint x,y;\n  \tlong long v;\n}a[N];\ninline void add(int x,int y,int f,long long v) {\n  Next[++tot]=last[x]; last[x]=tot; to[tot]=y; flow[tot]=f; val[tot]=v;\n}\n#define inf 1000000000000000000ll\ninline bool spfa() {\n  \tfor (int i=S;i<=T;i++) pre[i]=0,dis[i]=-inf,e[i]=0;\n  \tdis[S]=0; e[S]=1;\n  \tint l=0,r=1; q[1]=S;\n  \twhile (l<r) {\n      \tint k=q[++l];\n      \tfor (int i=last[k];i;i=Next[i]) {\n          \tif (!flow[i]||dis[to[i]]>=dis[S]+val[i]) continue;\n          \tdis[to[i]]=dis[S]+val[i];\n          \tpre[to[i]]=i;\n          \tif (!e[to[i]]) e[q[++r]=to[i]]=1;\n        }\n      \te[k]=0;\n    }\n  \treturn dis[T]!=-inf;\n}\ninline long long dinic(int y) {\n  \tlong long ans=0;\n  \tint s=0;\n  \twhile (spfa()) {\n      \ts++;\n      \tfor (int x=T;x!=S;x=to[pre[x]^1]) flow[pre[x]]--,flow[pre[x]^1]++,ans+=val[pre[x]];\n    }\n  \tif (s!=y) {\n\t  \tprintf(\"%lld\\n\",ans);\n\t  \texit(0);\n\t  }\n  \treturn ans;\n}\ninline long long work(int x) {\n  for (int i=1;i<=m;i++) if (b[i].id&1) A[i]=b[i];\n  else A[i]=node{b[i].id,x-b[i].x,b[i].y-1};\n  for (int i=1;i<=x;i++) X[i]=2*n+i,Y[i]=2*n+i+x;\n  S=0,T=Y[x]+1;\n  for (int i=S;i<=T;i++) last[i]=0;\n  tot=1;\n  for (int i=1;i<=x;i++) Lx[i]=Ly[i]=1,Rx[i]=Ry[i]=100;\n  for (int i=1;i<=m;i++) {\n  \tif (A[i].x<0||(A[i].x==0&&!(A[i].id&1))) continue;\n    if (A[i].id==1) Lx[A[i].x+1]=max(Lx[A[i].x+1],A[i].y+1);\n    else if (A[i].id==2) Rx[A[i].x]=min(Rx[A[i].x],A[i].y);\n    else if (A[i].id==3) Ly[A[i].x+1]=max(Ly[A[i].x+1],A[i].y+1);\n    else Ry[A[i].x]=min(Ry[A[i].x],A[i].y);\n  }\n  for (int i=1;i<=x;i++) Lx[i]=max(Lx[i],Lx[i-1]),Ly[i]=max(Ly[i],Ly[i-1]);\n  for (int i=x-1;i;i--) Rx[i]=min(Rx[i],Rx[i+1]),Ry[i]=min(Ry[i],Ry[i+1]);\n  for (int i=1;i<=x;i++) if (Lx[i]>Rx[i]) return false;\n  for (int i=1;i<=x;i++) add(S,X[i],1,0),add(X[i],S,0,0),add(Y[i],T,1,0),add(T,Y[i],0,0);\n  for (int i=1;i<=x;i++)\n  for (int j=1;j<=n;j++) {\n    \tif (a[j].x>=Lx[i]&&a[j].x<=Rx[i]) add(X[i],j,1,0),add(j,X[i],0,0);\n    \tif (a[j].y>=Ly[i]&&a[j].y<=Ry[i]) add(j+n,Y[i],1,0),add(Y[i],j+n,0,0);\n  }\n  for (int i=1;i<=n;i++) add(i,i+n,1,a[i].v),add(i+n,i,0,-a[i].v);\n  return dinic(x);\n}\nchar c[15];\nint main() {\n\t//freopen(\"0.in\",\"r\",stdin);\n  scanf(\"%d\",&n);\n  for (int i=1;i<=n;i++) scanf(\"%d%d%lld\",&a[i].x,&a[i].y,&a[i].v);\n  scanf(\"%d\",&m);\n  for (int i=1;i<=m;i++) {\n    \tscanf(\"%s\",c);\n    \tscanf(\"%d%d\",&b[i].y,&b[i].x);\n    \tif (c[0]=='L') b[i].id=1;\n    \tif (c[0]=='R') b[i].id=2;\n    \tif (c[0]=='D') b[i].id=3;\n    \tif (c[0]=='U') b[i].id=4;\n  }\n  long long ans=0;\n  for (int i=1;i<=n;i++) \n\tans=max(ans,work(i));\n  printf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define itn int\n#define all(x) (x).begin(), (x).end()\n#define make_unique(x) sort(all((x))); (x).resize(unique(all((x))) - (x).begin())\n\n#define random_shuffle(...) shuffle(__VA_ARGS__, rng)\n#define rand() rng()\n\nusing namespace std;\n\ninline int nxt() {\n\tint x;\n\tscanf(\"%d\", &x);\n\treturn x;\n}\n\n#define sz(x) ((int) (x).size())\n#define forn(i,n) for (int i = 0; i < int(n); ++i)\n\ntypedef long long ll;\ntypedef long long i64;\ntypedef long double ld;\nconst int inf = int(1e9) + int(1e5);\nconst ll infl = ll(2e18) + ll(1e10);\n\nconst int maxn = 505;\nconst int maxm = 505;\n\nconst ld eps = 1e-4;\n\nbool eq(ld a, ld b) {\n    return fabsl(a - b) < eps;\n}\n\n//BEGIN_CODE\nnamespace Simplex {\n\nld D[maxm][maxn]; // [n+2][m+2]\nint B[maxm];\nint N[maxn];\nld x[maxn];\nint n, m;\n\n//x >= 0, Ax <= b, c^Tx -> max\nvoid init(int _n, int _m, ld A[][maxn], ld *b, ld *c) {\n    n = _n, m = _m;\n    forn (i, m)\n        forn (j, n)\n            D[i][j] = -A[i][j];\n    forn (i, m) {\n        D[i][n] = 1;\n        D[i][n + 1] = b[i];\n    }\n    forn (j, n) {\n        D[m][j] = c[j];\n        D[m + 1][j] = 0;\n    }\n    D[m][n + 1] = D[m][n] = D[m + 1][n + 1] = 0;\n    D[m + 1][n] = -1;\n    iota(B, B + m, n);\n    iota(N, N + n, 0);\n    N[n] = -1;\n}\n\nvoid pivot(int b, int nb) {\n    assert(D[b][nb] != 0);\n    ld q = 1. / -D[b][nb];\n    D[b][nb] = -1;\n    forn (i, n + 2)\n        D[b][i] *= q;\n    forn (i, m + 2) {\n        if (i == b)\n            continue;\n        ld coef = D[i][nb];\n        D[i][nb] = 0;\n        forn (j, n + 2)\n            D[i][j] += coef * D[b][j];\n    }\n    swap(B[b], N[nb]);\n}\n\nbool betterN(int f, int i, int j) {\n    if (eq(D[f][i], D[f][j]))\n        return N[i] < N[j];\n    return D[f][i] > D[f][j];\n}\n\nbool betterB(int nb, int i, int j) {\n    ld ai = D[i][n + 1] / D[i][nb];\n    ld aj = D[j][n + 1] / D[j][nb];\n    if (eq(ai, aj))\n        return B[i] < B[j];\n    return ai > aj;\n}\n\nbool simplex(int phase) {\n    int f = phase == 1 ? m : m + 1;\n    while (true) {\n        int nb = -1;\n        forn (i, n + 1) {\n            if (N[i] == -1 && phase == 1)\n                continue;\n            if (nb == -1 || betterN(f, i, nb))\n                nb = i;\n        }\n        if (D[f][nb] <= eps)\n            return phase == 1;\n        assert(nb != -1);\n\n        int b = -1;\n        forn (i, m) {\n            if (D[i][nb] >= -eps)\n                continue;\n            if (b == -1 || betterB(nb, i, b))\n                b = i;\n        }\n        if (b == -1)\n            return false;\n        pivot(b, nb);\n        if (N[nb] == -1 && phase == 2)\n            return true;\n    }\n}\n\nld solve() {\n    int b = -1;\n    forn (i, m) {\n        if (b == -1 || D[i][n + 1] < D[b][n + 1])\n            b = i;\n    }\n    assert(b != -1);\n    if (D[b][n + 1] < -eps) {\n        pivot(b, n);\n        if (!simplex(2) || D[m + 1][n + 1] < -eps)\n            return -infl;\n    }\n    if (!simplex(1))\n        return infl;\n\n    forn (i, n)\n        x[i] = 0;\n    forn (i, m)\n        if (B[i] < n)\n            x[B[i]] = D[i][n + 1];\n\n    return D[m][n + 1];\n}\n\n} //Simplex\n//END_CODE\n\nstruct Treasure {\n\tint x, y;\n\tlong long v;\n\n\tvoid scan() {\n\t\tscanf(\"%d%d%lld\", &x, &y, &v);\n\t}\n};\n\nstruct Constraint {\n\tchar t;\n\tint a, b;\n\n\tvoid scan() {\n\t\tcin >> t >> a >> b;\n\t}\n\n\tbool isAbout(const Treasure& tr) const {\n\t\tif (t == 'D') {\n\t\t\treturn tr.y <= a;\n\t\t} else if (t == 'U') {\n\t\t\treturn tr.y >= a;\n\t\t} else if (t == 'L') {\n\t\t\treturn tr.x <= a;\n\t\t} else if (t == 'R') {\n\t\t\treturn tr.x >= a;\n\t\t} else {\n\t\t\tassert(false);\n\t\t}\n\t}\n};\n\nld a[maxm][maxn];\nld b[maxm];\nld c[maxn];\n\nint main() {\n\tmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n\tint n = nxt();\n\tvector<Treasure> trs(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\ttrs[i].scan();\n\t}\n\n\tint m = nxt();\n\tvector<Constraint> crs(m);\n\tfor (int i = 0; i < m; ++i) {\n\t\tcrs[i].scan();\n\t}\n\n\tfor (int i = 0; i < m; ++i) {\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\ta[i][j] = crs[i].isAbout(trs[j]);\n\t\t}\n\t\tb[i] = crs[i].b;\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\ta[m + i][i] = 1;\n\t\tb[m + i] = 1;\n\t\tc[i] = trs[i].v;\n\t}\n\n\tSimplex::init(n, n + m, a, b, c);\n\t// Simplex::solve();\n\n\tlong double ans = Simplex::solve();\n\t// for (int i = 0; i < n; ++i) {\n\t// \tans += trs[i].v * (int)(roundl(Simplex::x[i]));\n\t// }\n\tcout << (long long)roundl(ans) << \"\\n\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nint S=0,T;\nint N;\nstruct edge{\n\tint s,t,cap;long long v;int nxt;\n}e[50005];\nint e_cnt,last[405];\nvoid addedge(int u,int v,int cap,long long l){\n\te[e_cnt]=(edge){u,v,cap,l,last[u]};\n\tlast[u]=e_cnt++;\n\te[e_cnt]=(edge){v,u,0,-l,last[v]};\n\tlast[v]=e_cnt++;\n}\nlong long d[405];int fa[405];\nbool vis[405];\n#define LIM -(1e15+1)\nbool dij(){\n\tfor(int i=0;i<=T;i++)d[i]=LIM;\n\tmemset(vis,0,sizeof(vis));\n\td[S]=0;\n\tfor(int i=0;i<=T;i++){\n\t\tint x=-1;\n\t\tfor(int j=0;j<=T;j++)if(!vis[j]&&(x==-1||d[j]>d[x]))x=j;\n\t\tif(x==-1||d[x]==LIM)break;\n\t\tvis[x]=1;\n\t\tfor(int i=last[x];i!=-1;i=e[i].nxt)if(!vis[e[i].t]&&e[i].cap&&d[e[i].t]<d[x]+e[i].v){\n\t\t\t// assert(e[i].v<=0);\n\t\t\td[e[i].t]=d[x]+e[i].v;\n\t\t\tfa[e[i].t]=i;\n\t\t}\n\t}\n\treturn d[T]>LIM;\n}\npair<int,long long> solve(){\n\tint flow=0;long long cost=0;long long r=0;\n\twhile(dij()){\n\t\tflow++;\n\t\tint u=T;\n\t\twhile(u!=S){\n\t\t\te[fa[u]].cap=0;\n\t\t\te[fa[u]^1].cap=1;\n\t\t\tu=e[fa[u]].s;\n\t\t}\n\t\tr+=d[T];\n\t\tcost+=r;\n\t\tfor(int i=0;i<e_cnt;i++)e[i].v=d[e[i].s]+e[i].v-d[e[i].t];\n\t}\n\treturn make_pair(flow,cost);\n}\nint x[85],y[85];long long v[85];\nint t[325],a[325],b[325];\nint L[85][2],R[85][2];\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d%d%lld\",&x[i],&y[i],&v[i]);\n\t}\n\tint m;\n\tscanf(\"%d\",&m);\n\tfor(int i=1;i<=m;i++){\n\t\tchar c=getchar();\n\t\twhile(c<'A'||c>'Z')c=getchar();\n\t\tif(c=='L')t[i]=0;\n\t\tif(c=='R')t[i]=1;\n\t\tif(c=='D')t[i]=2;\n\t\tif(c=='U')t[i]=3;\n\t\tscanf(\"%d%d\",&a[i],&b[i]);\n\t}\n\tlong long ans=0;\n\tfor(int supy=1;supy<=n;supy++){\n\t\tmemset(R,63,sizeof(R));\n\t\tfor(int j=1;j<=m;j++)if(b[j]<supy){\n\t\t\tif(t[j]&1)R[supy-b[j]][t[j]>>1]=min(R[supy-b[j]][t[j]>>1],a[j]-1);\n\t\t\telse L[b[j]+1][t[j]>>1]=max(L[b[j]+1][t[j]>>1],a[j]+1);\n\t\t}\n\t\tfor(int i=2;i<=supy;i++)for(int j=0;j<2;j++)L[i][j]=max(L[i][j],L[i-1][j]);\n\t\tfor(int i=supy-1;i>0;i--)for(int j=0;j<2;j++)R[i][j]=min(R[i][j],R[i+1][j]);\n\t\t// for(int i=1;i<=supy;i++)printf(\"%d %d\\n\",L[i][0],R[i][0]);\n\t\t// for(int i=1;i<=supy;i++)printf(\"%d %d\\n\",L[i][1],R[i][1]);\n\t\tT=2*supy+2*n+1;\n\t\te_cnt=0;\n\t\tmemset(last,-1,sizeof(last));\n\t\tfor(int i=1;i<=supy;i++)addedge(S,i,1,0),addedge(i+supy,T,1,0);\n\t\tfor(int i=1;i<=n;i++)addedge(i+2*supy,i+n+2*supy,1,v[i]-1e15);\n\t\tfor(int i=1;i<=supy;i++)\n\t\t\tfor(int j=1;j<=n;j++)if(x[j]>=L[i][0]&&x[j]<=R[i][0])addedge(i,j+2*supy,1,0);\n\t\tfor(int i=1;i<=supy;i++)\n\t\t\tfor(int j=1;j<=n;j++)if(y[j]>=L[i][1]&&y[j]<=R[i][1])addedge(j+n+2*supy,i+supy,1,0);\n\t\tpair<int,long long>res=solve();\n\t\t// printf(\"%d %d %lld\\n\",supy,res.first,res.second);\n\t\tres.second+=supy*1e15;\n\t\tif(res.first==supy)ans=max(ans,res.second);\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace __gnu_pbds;\nusing namespace std;\n \ntemplate <typename T>\nusing ordered_set =\n\ttree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n \n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n\t*this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n \n#define shandom_ruffle random_shuffle\n \nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=327;\nusing bn=bitset<87>;\n\nint n;\npii gdz[nax];\nll war[nax];\n\nint m;\nbn podz[nax];\nint ile[nax];\n\nll wyn;\n\nbn ter;\n\nll dajwar()\n{\n\tll ret=0;\n\tfor (int i=1; i<=n; i++)\n\t\tif (ter[i])\n\t\t\tret+=war[i];\n\treturn ret;\n}\n\nint popr()\n{\n\tfor (int i=1; i<=m; i++)\n\t\tif ((podz[i]&ter).count()>ile[i])\n\t\t\treturn 0;\n\treturn 1;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(\"%d%d%lld\", &gdz[i].first, &gdz[i].second, &war[i]);\n\tscanf(\"%d\", &m);\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\tchar c;\n\t\tint a, b;\n\t\tscanf(\" %c%d%d\", &c, &a, &b);\n\t\tfor (int j=1; j<=n; j++)\n\t\t{\n\t\t\tif (c=='L' && gdz[j].first<=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='R' && gdz[j].first>=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='D' && gdz[j].second<=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='U' && gdz[j].second>=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t}\n\t\tile[i]=b;\n\t}\n\tll sta=dajwar();\n\tfor (int h=0; h%10000 || (clock()<=4.5*CLOCKS_PER_SEC); h++)\n\t{\n\t\tbn pam=ter;\n\t\tint r=rand()%2+1;\n\t\tfor (int i=0; i<r; i++)\n\t\t\tter.flip(rand()%n+1);\n\t\tif (!popr())\n\t\t{\n\t\t\tter=pam;\n\t\t\tcontinue;\n\t\t}\n\t\tll now=dajwar();\n\t\tif (now>=sta || !(rand()%1000))\n\t\t{\n\t\t\tsta=now;\n\t\t\twyn=max(wyn, now);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tter=pam;\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\\n\", wyn);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#define inlien inline\n#define retrun return\n#define cpnst const\ntypedef long long ll;\nstruct edg\n{int p,t,l;ll w;}e[2222222];\nint h[2222222],tot=1;\ninline void build(int x,int y,int l,ll w)\n{e[++tot]=(edg){h[x],y,l,w},h[x]=tot;}\ninline void ins(int x,int y,int l,ll w)\n{build(x,y,l,w),build(y,x,0,-w);}\nint frm[2222222],fri[2222222];\nll dis[2222222];\nint tn=2,S=1,T=2;\n#include<queue>\nstd::queue<int>q;\nbool isin[2222222];\nll spfa()\n{\n\tregister int i;\n\tfor(i=1;i<=tn;i++)dis[i]=-1e18;\n\tdis[S]=0,isin[S]=1,q.push(S);\n\tfor(;!q.empty();)\n\t{\n\t\tint p=q.front();q.pop();\n\t\tfor(i=h[p];i;i=e[i].p)\n\t\t{\n\t\t\tint to=e[i].t;\n\t\t\tif(!e[i].l)continue;\n\t\t\tif(dis[to]<dis[p]+e[i].w)\n\t\t\t{\n\t\t\t\tdis[to]=dis[p]+e[i].w,frm[to]=p,fri[to]=i;\n\t\t\t\tif(!isin[to])isin[to]=1,q.push(to);\n\t\t\t}\n\t\t}isin[p]=0;\n\t}return dis[T];\n}\nvoid cost(register int P=T)\n{for(;P^S;P=frm[P])e[fri[P]].l--,e[fri[P]^1].l++;}\nll mcmf(ll x)\n{\n\tll ret=0,d;\n\tfor(d=spfa();;x--,ret+=d,cost(),d=spfa())\n\t\tif(d<-9e17)return x?0:ret;\n}\n#include<algorithm>\nusing std::max;\nusing std::min;\nvoid init()\n{for(register int i=1;i<=tn;i++)h[i]=0;tot=1;}\nint F[1111111],G[1111111],H[1111111],K[1111111];\nint L[1111111],R[1111111],D[1111111],U[1111111];\nint x[1111111],y[1111111];\nll a[1111111];\nchar str[1111111][3];\nint p[1111111],k[1111111];\nint main()\n{\n\tint n,m;\n\tscanf(\"%d\",&n);\n\tregister int i,ii,iii;\n\tfor(i=1;i<=n;i++)scanf(\"%d%d%lld\",x+i,y+i,a+i);\n\tscanf(\"%d\",&m);\n\tfor(i=1;i<=100;i++)\n\t\tF[i]=++tn,G[i]=++tn,H[i]=++tn,K[i]=++tn;\n\tll ans=0;\n\tfor(i=1;i<=m;i++)scanf(\"%s %d %d\",str+i,p+i,k+i);\n\tfor(ii=1;ii<=n;ii++)\n\t{\n\t\tinit();\n\t\tfor(i=1;i<=ii;i++)L[i]=D[i]=1,R[i]=U[i]=100;\n\t\tfor(i=1;i<=m;i++)\n\t\t{\n\t\t\tif(k[i]>=ii)continue;\n\t\t\tswitch(*str[i])\n\t\t\t{\n\t\t\t\tcase'L':L[k[i]+1]=max(L[k[i]+1],p[i]+1);break;\n\t\t\t\tcase'R':R[ii-k[i]]=min(R[ii-k[i]],p[i]-1);break;\n\t\t\t\tcase'D':D[k[i]+1]=max(D[k[i]+1],p[i]+1);break;\n\t\t\t\tcase'U':U[ii-k[i]]=min(U[ii-k[i]],p[i]-1);break;\n\t\t\t}\n\t\t}for(i=2;i<=ii;i++)\n\t\t\tL[i]=max(L[i-1],L[i]),D[i]=max(D[i-1],D[i]);\n\t\tfor(i=ii-1;i;i--)\n\t\t\tR[i]=min(R[i+1],R[i]),U[i]=min(U[i+1],U[i]);\n\t\tfor(i=1;i<=ii;i++)\n\t\t\tins(S,H[i],1,0),ins(K[i],T,1,0);\n\t\tfor(i=1;i<=ii;i++)\n\t\t \tfor(iii=1;iii<=100;iii++)\n\t\t \t{\n\t \t\t\tif(iii>=L[i]&&iii<=R[i])\n\t \t\t\t\tins(H[i],F[iii],1e9,0);\n\t \t\t\tif(iii>=D[i]&&iii<=U[i])\n\t \t\t\t\tins(G[iii],K[i],1e9,0);\n\t \t\t}\n\t\tfor(i=1;i<=n;i++)ins(F[x[i]],G[y[i]],1,a[i]);\n\t\tans=max(ans,mcmf(ii));\n\t}printf(\"%lld\\n\",ans);\n}\n/*\nGiving the world a better yourself is giving yourself a better world. \n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cstring>\n#include<cmath>\n#include<cstdio>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nlong long read()\n{\n\tchar c=getchar();\n\tlong long res=0;\n\twhile(c<'0'||c>'9') c=getchar();\n\twhile(c>='0'&&c<='9') res=(res<<1)+(res<<3)+(c^48),c=getchar();\n\treturn res;\n}\nint n,m,s,t,h[405],cnt=1,lx[205],rx[205],ly[205],ry[205],p[405],pre[405];\nlong long d[405],ans,sum;\nbool vis[405];\nchar op[10];\nstruct Edge\n{\n\tint to,next,d;\n\tlong long v;\n}w[100005];\nstruct node\n{\n\tint x,y;\n\tlong long v;\n}a[100005];\nstruct que\n{\n\tint op,x,v;\n}b[100005];\nvoid add(int x,int y,int d,long long v)\n{\n\tw[++cnt]=(Edge){y,h[x],d,v};\n\th[x]=cnt;\n\tw[++cnt]=(Edge){x,h[y],0,-v};\n\th[y]=cnt;\n}\nbool Spfa()\n{\n\tmemset(d,-0x3f,sizeof(d));\n\td[s]=0;p[s]=0x3f3f3f3f;p[t]=0;\n\tqueue<int> q;\n\tq.push(s);\n\twhile(!q.empty())\n\t{\n\t\tint u=q.front();\n\t\tq.pop();\n\t\tvis[u]=0;\n\t\tfor(int i=h[u];i;i=w[i].next)\n\t\t{\n\t\t\tint to=w[i].to;\n\t\t\tif(w[i].d&&d[to]<d[u]+w[i].v)\n\t\t\t{\n\t\t\t\td[to]=d[u]+w[i].v;\n\t\t\t\tp[to]=min(p[u],w[i].d);pre[to]=i;\n\t\t\t\tif(!vis[to]) q.push(to),vis[to]=1;\n\t\t\t}\n\t\t}\n\t}\n\treturn p[t];\n}\nvoid Solve()\n{\n\tsum+=p[t]*d[t];\n\tint now=t;\n\twhile(now!=s)\n\t{\n\t\tw[pre[now]].d-=p[t];\n\t\tw[pre[now]^1].d+=p[t];\n\t\tnow=w[pre[now]^1].to;\n\t}\n}\nvoid EK()\n{\n\tsum=0;\n\twhile(Spfa()) Solve();\n}\nint main()\n{\n\tn=read();\n\tfor(int i=1;i<=n;i++) a[i].x=read(),a[i].y=read(),a[i].v=read();\n\tm=read();\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%s\",op);\n\t\tif(op[0]=='L') b[i].op=1;\n\t\telse if(op[0]=='R') b[i].op=2;\n\t\telse if(op[0]=='D') b[i].op=3;\n\t\telse b[i].op=4;\n\t\tb[i].x=read(),b[i].v=read();\n\t}\n\tfor(int k=1;k<=n;k++)\n\t{\n\t\tmemset(h,0,sizeof(h));cnt=1;\n\t\ts=0,t=2*k+2*n+1;\n\t\tfor(int i=1;i<=k;i++) add(s,i,1,0),add(i+2*n+k,t,1,0);\n\t\tmemset(lx,0,sizeof(lx));memset(rx,0x3f,sizeof(rx));\n\t\tmemset(ly,0,sizeof(ly));memset(ry,0x3f,sizeof(ry));\n\t\tfor(int i=1;i<=m;i++)\n\t\t{\n\t\t\tif(b[i].op==1) for(int j=b[i].v+1;j<=k;j++) lx[j]=max(lx[j],b[i].x+1);\n\t\t\telse if(b[i].op==2) for(int j=1;j<=k-b[i].v;j++) rx[j]=min(rx[j],b[i].x-1);\n\t\t\telse if(b[i].op==3) for(int j=b[i].v+1;j<=k;j++) ly[j]=max(ly[j],b[i].x+1);\n\t\t\telse for(int j=1;j<=k-b[i].v;j++) ry[j]=min(ry[j],b[i].x-1);\n\t\t}\n\t\tfor(int i=1;i<=n;i++) add(i+k,i+n+k,1,a[i].v);\n\t\tfor(int i=1;i<=k;i++)\n\t\tfor(int j=1;j<=n;j++) if(lx[i]<=a[j].x&&a[j].x<=rx[i]) add(i,j+k,1,0);\n\t\tfor(int i=1;i<=k;i++)\n\t\tfor(int j=1;j<=n;j++) if(ly[i]<=a[j].y&&a[j].y<=ry[i]) add(j+k+n,2*n+i+k,1,0);\n\t\tEK();\n\t\tans=max(ans,sum);\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nstruct edge {\n    int v, nxt, f;\n    ll c;\n} e[2 * 80 * 80 * 8 + 10];\nint head[410], tot, cur[410];\ninline void init() {\n    tot = 1;\n    memset(head, 0, sizeof head);\n}\ninline void addedge(int u, int v, int f, ll c) {\n    e[++tot] = edge{v, head[u], f, c};\n    head[u] = tot;\n    e[++tot] = edge{u, head[v], 0, -c};\n    head[v] = tot;\n}\nint n, m, x[100], y[100];\nll v[100];\nstruct node {\n    char type;\n    int key, val;\n} a[325];\nll dis[410];\nint inq[410];\nint s, t;\ninline bool spfa() {\n    memset(dis, ~0x3f, sizeof dis);\n    queue <int> q;\n    q.push(s);\n    dis[s] = 0;\n    inq[s] = 1;\n    while (!q.empty()) {\n        int now = q.front();\n        q.pop();\n        for (int i = head[now]; i; i = e[i].nxt) {\n            if (e[i].f && dis[now] + e[i].c > dis[e[i].v]) {\n                dis[e[i].v] = dis[now] + e[i].c;\n                if (!inq[e[i].v]) inq[e[i].v] = 1, q.push(e[i].v);\n            }\n        }\n        inq[now] = 0;\n    }\n    return memcpy(cur, head, sizeof cur), dis[t] >= -1e18;\n}\nint ansf, insta[410];\nll ansc;\ninline int dfs(int now, int limit) {\n    if (now == t) return limit;\n    insta[now] = 1;\n    int ans = 0;\n    for (int &i = cur[now]; i; i = e[i].nxt) {\n        if (e[i].f == 0 || dis[now] + e[i].c != dis[e[i].v] || insta[e[i].v]) continue;\n        int tmp = dfs(e[i].v, min(limit, e[i].f));\n        ans += tmp, limit -= tmp;\n        ansc += tmp * e[i].c;\n        e[i].f -= tmp;\n        e[i ^ 1].f += tmp;\n        if (limit == 0) return insta[now] = 0, ans;\n    }\n    return insta[now] = 0, ans;\n}\ninline void work() {\n    ansf = ansc = 0;\n    while (spfa()) ansf += dfs(s, 1e9);\n}\nint l[100], r[100];\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i++) scanf(\"%d%d%lld\", x + i, y + i, v + i);\n    scanf(\"%d\", &m);\n    for (int i = 1; i <= m; i++) scanf(\"%s%d%d\", &a[i].type, &a[i].key, &a[i].val);\n    ll ans = 0;\n    for (int k = 1; k <= n; k++) {\n        init();\n        for (int i = 1; i <= n; i++) l[i] = 0, r[i] = 100;\n        for (int i = 1; i <= m; i++) {\n            switch (a[i].type) {\n                case 'L': {\n                    for (int j = a[i].val + 1; j <= k; j++) l[j] = max(l[j], a[i].key + 1);\n                    break;\n                }\n                case 'R': {\n                    for (int j = 1; j <= k - a[i].val; j++) r[j] = min(r[j], a[i].key - 1);\n                    break;\n                }\n            }\n        }\n        for (int i = 1; i <= k; i++)\n            for (int j = 1; j <= n; j++)\n                if (x[j] >= l[i] && x[j] <= r[i]) addedge(i, j + k, 1, 0);\n        for (int i = 1; i <= n; i++) l[i] = 0, r[i] = 100;\n        for (int i = 1; i <= m; i++) {\n            switch (a[i].type) {\n                case 'D': {\n                    for (int j = a[i].val + 1; j <= k; j++) l[j] = max(l[j], a[i].key + 1);\n                    break;\n                }\n                case 'U': {\n                    for (int j = 1; j <= k - a[i].val; j++) r[j] = min(r[j], a[i].key - 1);\n                    break;\n                }\n            }\n        }\n        for (int i = 1; i <= k; i++)\n            for (int j = 1; j <= n; j++)\n                if (y[j] >= l[i] && y[j] <= r[i]) addedge(j + k + n, i + k + n + n, 1, 0);\n        s = 0, t = k + k + n + n + 1;\n        for (int i = 1; i <= k; i++) addedge(s, i, 1, 0), addedge(i + n + n + k, t, 1, 0);\n        for(int i = 1; i <= n; i++) addedge(i + k, i + k + n, 1, v[i]);\n        work();\n        if (ansf != k) continue;\n        ans = max(ans, ansc);\n    }\n    return cout << ans << endl, 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\nnamespace flow{\n\tconst ll __ = 1e6 + 7 , _ = 1e5 + 7;\n\tstruct Edge{ll end , upEd , f , c;}Ed[__];\n\tll head[_] , cntEd , S , T;\n\tvoid clear(){memset(head , 0 , sizeof(head)); cntEd = 1; S = T = 0;}\n\tvoid addEd(ll a , ll b , ll c , ll d){Ed[++cntEd] = (Edge){b , head[a] , c , d}; head[a] = cntEd;}\n\tvoid addE(ll a , ll b , ll c , ll d){addEd(a , b , c , d); addEd(b , a , 0 , -d);}\n\n\tbool vis[_]; queue < ll > q; ll dis[_] , pre[_];\n\tbool bfs(){\n\t\tq.push(S); memset(dis , -0x3f , sizeof(ll) * (T + 2)); dis[S] = 0;\n\t\twhile(!q.empty()){\n\t\t\tll t = q.front(); q.pop(); vis[t] = 0;\n\t\t\tfor(ll i = head[t] ; i ; i = Ed[i].upEd)\n\t\t\t\tif(Ed[i].f && dis[Ed[i].end] < dis[t] + Ed[i].c){\n\t\t\t\t\tdis[Ed[i].end] = dis[t] + Ed[i].c; pre[Ed[i].end] = i;\n\t\t\t\t\tif(!vis[Ed[i].end]){vis[Ed[i].end] = 1; q.push(Ed[i].end);}\n\t\t\t\t}\n\t\t}\n\t\treturn dis[T] != dis[T + 1];\n\t}\n\t\n\tll EK(ll s , ll t , ll tarf){\n\t\tS = s; T = t; ll sum = 0 , fl = 0;\n\t\twhile(bfs()){++fl; ll cur = T; while(cur != S){ll t = pre[cur]; cur = Ed[t ^ 1].end; sum += Ed[t].c; --Ed[t].f; ++Ed[t ^ 1].f;}}\n\t\treturn fl == tarf ? sum : -1;\n\t}\n}\n\nll bound[2][2][103] , N , M , X[83] , Y[83]; ll v[83];\n\nsigned main(){\n\tcin >> N; for(ll i = 1 ; i <= N ; ++i) cin >> X[i] >> Y[i] >> v[i];\n\tcin >> M; memset(bound , 0x3f , sizeof(bound));\n\tfor(ll i = 1 ; i <= M ; ++i){\n\t\tchar c; ll p , q; cin >> c >> p >> q;\n\t\tswitch(c){\n\t\tcase 'L': bound[0][0][p] = min(bound[0][0][p] , q); break;\n\t\tcase 'R': bound[0][1][p] = min(bound[0][1][p] , q); break;\n\t\tcase 'U': bound[1][0][p] = min(bound[1][0][p] , q); break;\n\t\tcase 'D': bound[1][1][p] = min(bound[1][1][p] , q); break;\n\t\t}\n\t}\n\tll ans = 0;\n\tfor(ll i = 1 ; i <= N ; ++i){\n\t\tflow::clear(); bool flg = bound[0][0][100] >= i && bound[1][1][100] >= i; ll cnt = 0;\n\t\tfor(ll j = 1 ; j <= 100 ; ++j){\n\t\t\tll dwn = max(0ll , i - bound[0][0][j - 1]) , up = bound[0][1][j]; flg &= dwn <= up;\n\t\t\tcnt += dwn; flow::addE(j , j + 1 , dwn , (ll)1e16); flow::addE(j , j + 1 , up - dwn , 0);\n\t\t}\n\t\tfor(ll j = 100 ; j ; --j){\n\t\t\tll dwn = max(0ll , i - bound[1][1][j - 1]) , up = bound[1][0][j]; flg &= dwn <= up;\n\t\t\tcnt += dwn; flow::addE(202 - j , 203 - j , dwn , (ll)1e16); flow::addE(202 - j , 203 - j , up - dwn , 0);\n\t\t}\n\t\tfor(ll j = 1 ; j <= N ; ++j) flow::addE(X[j] + 1 , 202 - Y[j] , 1 , v[j]);\n\t\tflow::addE(0 , 1 , i , 0); if(flg) ans = max(ans , flow::EK(0 , 202 , i) - cnt * (ll)1e16);\n\t}\n\tcout << ans;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 100 , M = 400 , V = N + M << 1 , E = N + N * M * 2 + M * 2 , INF = 0x3f3f3f3f;\nint n,m,x[N],y[N],a[N],b[N],u[N],d[N],l[N],r[N]; char op[N];\nint t(1),Head[V],vis[V],S,T; deque <int> q; ll Delta,dis[V],v[N],Ans;\nstruct Edge { int u,v,next,val; ll cos; } e[E*2];\ntemplate<class T> inline T Read(void)\n{\n    T x = 0; bool w = 0; char ch = ' ';\n    while ( !isdigit(ch) ) w |= ch == '-' , ch = getchar();\n    while ( isdigit(ch) ) x = x * 10 + ch - 48 , ch = getchar();\n    return w ? -x : x;\n}\ninline void Input(void)\n{\n    n = Read<int>();\n    for (int i = 1; i <= n; i++)\n        x[i] = Read<int>() , y[i] = Read<int>() , v[i] = Read<ll>();\n    m = Read<int>();\n    for (int i = 1; i <= m; i++)\n    {\n        char c = ' ';\n        while ( isspace(c) ) c = getchar();\n        op[i] = c , a[i] = Read<int>() , b[i] = Read<int>();\n    }\n}\ninline void Insert(int x,int y,ll c,int v)\n{\n    e[++t] = (Edge){ x , y , Head[x] , v , c } , Head[x] = t;\n    e[++t] = (Edge){ y , x , Head[y] , 0 , -c } , Head[y] = t;\n}\ninline void Build(int k)\n{\n    for (int i = 1; i <= k; i++)\n        u[i] = r[i] = INF , l[i] = d[i] = 0;\n    for (int i = 1; i <= m; i++)\n        if ( b[i] < k )\n        {\n            if ( op[i] == 'L' ) l[b[i]+1] = max( l[b[i]+1] , a[i] + 1 );\n            if ( op[i] == 'R' ) r[k-b[i]] = min( r[k-b[i]] , a[i] - 1 );\n            if ( op[i] == 'D' ) d[b[i]+1] = max( d[b[i]+1] , a[i] + 1 );\n            if ( op[i] == 'U' ) u[k-b[i]] = min( u[k-b[i]] , a[i] - 1 );\n            // if ( op[i] == 'L' ) l[b[i]+1] = a[i] + 1;\n            // if ( op[i] == 'R' ) r[k-b[i]] = a[i] - 1;\n            // if ( op[i] == 'D' ) d[b[i]+1] = a[i] + 1;\n            // if ( op[i] == 'U' ) u[k-b[i]] = a[i] - 1;\n        }\n    for (int i = 2; i <= k; i++) l[i] = max( l[i] , l[i-1] ) , d[i] = max( d[i] , d[i-1] );\n    for (int i = k-1; i >= 1; i--) r[i] = min( r[i] , r[i+1] ) , u[i] = min( u[i] , u[i+1] );\n    memset( Head , 0 , sizeof Head );\n    S = ( n + k ) << 1 | 1 , T = ( n + k + 1 ) * 2 , t = 1 , Delta = 0;\n    for (int i = 1; i <= n; i++) Insert( i , i+n , v[i] , 1 );\n    for (int i = 1; i <= k; i++)\n    {\n        Insert( S , n*2+i , 0 , 1 ) , Insert( n*2+k+i , T , 0 , 1 );\n        for (int j = 1; j <= n; j++)\n        {\n            if ( l[i] <= x[j] && x[j] <= r[i] ) Insert( n*2+i , j , 0 , 1 );\n            if ( d[i] <= y[j] && y[j] <= u[i] ) Insert( j+n , n*2+k+i , 0 , 1 );\n        }\n    }\n    // printf( \"t = %d\\n\" , t );\n}\ninline bool Relabel(void)\n{\n    memset( dis , 0xcf , sizeof dis );\n    memset( vis , 0x00 , sizeof vis );\n    dis[T] = 0 , vis[T] = 1 , q.push_back(T);\n    while ( !q.empty() )\n    {\n        // puts(\"SPFAing\");\n        int x = q.front(); q.pop_front() , vis[x] = 0;\n        if ( q.size() > 1 && dis[q.front()] < dis[q.back()] )\n            swap( q.front() , q.back() );\n        for (int i = Head[x] , y; i; i = e[i].next)\n            if ( e[i^1].val && dis[ y = e[i].v ] < dis[x] + e[i^1].cos )\n            {\n                dis[y] = dis[x] + e[i^1].cos;\n                // printf( \"dis[%d] = %lld\\n\" , y , dis[y] );\n                if ( vis[y] ) continue;\n                vis[y] = true , q.push_back(y);\n                if ( q.size() > 1 && dis[q.front()] < dis[q.back()] )\n                    swap( q.front() , q.back() );\n            }\n    }\n    // printf( \"d[%d] = %lld\\n\" , S , dis[S] );\n    return dis[S] != dis[0];\n}\ninline int Dinic(int x,int flow)\n{\n    if ( x == T || !flow ) return flow;\n    int residue = flow; vis[x] = true;\n    for (int i = Head[x] , y; i; i = e[i].next)\n        if ( e[i].val && !vis[ y = e[i].v ] && !e[i].cos )\n        {\n            int k = Dinic( y , min( e[i].val , residue ) );\n            e[i].val -= k , e[i^1].val += k;\n            if ( ( residue -= k ) == 0 ) break;\n        }\n    return flow - residue;\n}\ninline pair<int,ll> PrimalDual(void)\n{\n    int Maxflow = 0 , Flow = 0; ll Maxcost = 0;\n    while ( Relabel() )\n    {\n        for (int i = 2; i <= t; i++)\n            e[i].cos += dis[e[i].v] - dis[e[i].u];\n        Delta += dis[S] , memset( vis , 0 , sizeof vis );\n        // printf( \"Delta = %lld\\n\" , Delta );\n        while ( Flow = Dinic( S , INF ) )\n            Maxflow += Flow , Maxcost += Flow * Delta ,\n            memset( vis , 0 , sizeof vis ) /*, printf( \"Dinicing Flow = %d\\n\" , Flow ) */;\n    }\n    return make_pair( Maxflow , Maxcost );\n}\nint main(void)\n{\n    Input();\n    for (int i = 1; i <= n; i++)\n        Build(i) , Ans = max( Ans , PrimalDual().second );\n    printf( \"%lld\\n\" , Ans );\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FOR(i,a,b) for (int i=a;i<=b;++i)\n#define REP(i,n) FOR(i,1,n)\n#define REP_0N(i,n) FOR(i,0,n)\n#define N 1005\n#define M 1005\nusing namespace std;\ntypedef __float128 ld;\nconst ld eps=0; ld inf=1e18;\nint n,m,id[N],tp[N];\nld a[M][N],T,sum[N][M],A[N],d[N],x[N];\nint B[N];\nchar c[N];\nstruct node {\n    int x,y;\n    long long v;\n}b[N];\ninline void pivot(int r,int c) {\n    swap(id[r+n],id[c]);\n    ld t=-a[r][c];\n    a[r][c]=-1;\n    REP_0N(i,n) a[r][i]/=t;\n    REP_0N(i,m)\n    if (a[i][c]&&r!=i) {\n        t=a[i][c];\n        a[i][c]=0;\n        REP_0N(j,n) a[i][j]+=t*a[r][j];\n    }\n}\ninline void solve() {\n    ld t;\n    REP(i,n) id[i]=i;\n    while (true) {\n        int i=0,j=0; ld w=0;\n        REP(k,m) if (a[k][0]<w) w=a[i=k][0];\n        if (!i) break;\n        REP(k,n) if (a[i][k]>0) {j=k; break;}\n        if (!j) return ;\n        pivot(i,j);\n    }\n    while (true) {\n        int i=0,j=0; ld w=0;\n        REP(k,n) if (a[0][k]>w) w=a[0][j=k];\n        if (!j) break;\n        w=inf;\n        REP(k,m) if (a[k][j]<0&&(t=-a[k][0]/a[k][j])<w) w=t,i=k;\n        if (!i) return ;\n        pivot(i,j);\n    }\n    FOR(i,n+1,n+m) tp[id[i]]=i-n;\n    REP(i,n) x[i]=tp[i]?a[tp[i]][0]:0;\n}\nint main() {\n    scanf(\"%d\",&n);\n    for (int i=1;i<=n;i++) {\n        scanf(\"%d%d%lld\",&b[i].x,&b[i].y,&b[i].v);\n        a[0][i]=b[i].v;\n    }\n    scanf(\"%d\",&m);\n    for (int i=1;i<=m;i++) {\n        scanf(\"%s\",c);\n        int x,y;\n        scanf(\"%d%d\",&x,&y);\n        a[i][0]=y;\n        if (c[0]=='L') {\n            for (int j=1;j<=n;j++) if (b[j].x<=x) a[i][j]=-1;\n        }\n        else if (c[0]=='R') {\n            for (int j=1;j<=n;j++) if (b[j].x>=x) a[i][j]=-1;\n        }\n        else if (c[0]=='D') {\n            for (int j=1;j<=n;j++) if (b[j].y<=x) a[i][j]=-1;\n        }\n        else if (c[0]=='U') {\n            for (int j=1;j<=n;j++) if (b[j].y>=x) a[i][j]=-1;\n        }\n    }\n    for (int i=1;i<=n;i++) {\n        a[++m][0]=1;\n        a[m][i]=-1;\n    }\n    solve();\n    ld ans=0;\n    for (int i=1;i<=n;i++) ans+=b[i].v*x[i];\n    printf(\"%lld\\n\",(long long)(ans+0.5));\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 16.03.2019 16:16:57       \n**/\n#undef _GLIBCXX_DEBUG\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring to_string(string s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntypedef long double ld;\n\nconst ld eps = 1e-8;\n\nvector<ld> simplex(vector<vector<ld>> a) {\n  int n = (int) a.size() - 1;\n  int m = (int) a[0].size() - 1;\n  vector<int> left(n + 1);\n  vector<int> up(m + 1);\n  iota(left.begin(), left.end(), m);\n  iota(up.begin(), up.end(), 0);\n  auto pivot = [&](int x, int y) {\n    swap(left[x], up[y]);\n    ld k = a[x][y];\n    a[x][y] = 1;\n    vector<int> pos;\n    for (int j = 0; j <= m; j++) {\n      a[x][j] /= k;\n      if (fabs(a[x][j]) > eps) {\n        pos.push_back(j);\n      }\n    }\n    for (int i = 0; i <= n; i++) {\n      if (fabs(a[i][y]) < eps || i == x) {\n        continue;\n      }\n      k = a[i][y];\n      a[i][y] = 0;\n      for (int j : pos) {\n        a[i][j] -= k * a[x][j];\n      }\n    }\n  };\n  while (1) {\n    int x = -1;\n    for (int i = 1; i <= n; i++) {\n      if (a[i][0] < -eps && (x == -1 || a[i][0] < a[x][0])) {\n        x = i;\n      }\n    }\n    if (x == -1) {\n      break;\n    }\n    int y = -1;\n    for (int j = 1; j <= m; j++) {\n      if (a[x][j] < -eps && (y == -1 || a[x][j] < a[x][y])) {\n        y = j;\n      }\n    }\n    if (y == -1) {\n      return vector<ld>(); // infeasible\n    }\n    pivot(x, y);\n  }\n  while (1) {\n    int y = -1;\n    for (int j = 1; j <= m; j++) {\n      if (a[0][j] > eps && (y == -1 || a[0][j] > a[0][y])) {\n        y = j;\n      }\n    }\n    if (y == -1) {\n      break;\n    }\n    int x = -1;\n    for (int i = 1; i <= n; i++) {\n      if (a[i][y] > eps && (x == -1 || a[i][0] / a[i][y] < a[x][0] / a[x][y])) {\n        x = i;\n      }\n    }\n    if (x == -1) {\n      return vector<ld>(); // unbounded\n    }\n    pivot(x, y);\n  }\n  vector<ld> ans(m + 1);\n  for (int i = 1; i <= n; i++) {\n    if (left[i] <= m) {\n      ans[left[i]] = a[i][0];\n    }\n  }\n  ans[0] = -a[0][0];\n  return ans;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<int> x(n), y(n);\n  vector<long long> z(n);\n  for (int i = 0; i < n; i++) {\n    cin >> x[i] >> y[i] >> z[i];\n  }\n  vector<vector<ld>> mat;\n  {\n    vector<ld> row(n + 1);\n    for (int i = 0; i < n; i++) {\n      row[i + 1] = z[i];\n    }\n    mat.push_back(row);\n  }\n  {\n    for (int i = 0; i < n; i++) {\n      vector<ld> row(n + 1);\n      row[0] = 1;\n      row[i + 1] = 1;\n      mat.push_back(row);\n    }\n  }\n  int tt;\n  cin >> tt;\n  for (int qq = 0; qq < tt; qq++) {\n    string foo;\n    int bar, baz;\n    cin >> foo >> bar >> baz;\n    vector<ld> row(n + 1);\n    row[0] = baz;\n    if (foo == \"L\") {\n      for (int i = 0; i < n; i++) if (x[i] <= bar) row[i + 1] = 1;\n    }\n    if (foo == \"R\") {\n      for (int i = 0; i < n; i++) if (x[i] >= bar) row[i + 1] = 1;\n    }\n    if (foo == \"D\") {\n      for (int i = 0; i < n; i++) if (y[i] <= bar) row[i + 1] = 1;\n    }\n    if (foo == \"U\") {\n      for (int i = 0; i < n; i++) if (y[i] >= bar) row[i + 1] = 1;\n    }\n    mat.push_back(row);\n  }\n  vector<ld> ret = simplex(mat);\n  debug(ret[0]);\n  vector<int> bads;\n  mt19937 rng((unsigned int) chrono::steady_clock::now().time_since_epoch().count());\n  for (int i = 0; i < n; i++) {\n    if (ret[i + 1] > eps && ret[i + 1] < 1 - eps) {\n      bads.push_back(i);\n    }\n  }\n  debug(bads);\n  bads.resize(min((int) bads.size(), 12));\n  int sz = (int) bads.size();\n  long long ans = 0;\n  for (int t = 0; t < (1 << sz); t++) {\n    for (int i = 0; i < sz; i++) {\n      if (t & (1 << i)) {\n        mat[bads[i] + 1][0] = 1;\n        vector<ld> row(n + 1);\n        row[0] = -1;\n        row[bads[i] + 1] = -1;\n        mat.push_back(row);\n      } else {\n        mat[bads[i] + 1][0] = 0;\n      }\n    }\n    vector<ld> ret2 = simplex(mat);\n    if (!ret2.empty()) {\n      long long val = 0;\n      int ctr = 0;\n      for (int i = 0; i < n; i++) {\n        ctr += (ret2[i + 1] > eps && ret2[i + 1] < 1 - eps);\n        val += z[i] * (ret2[i + 1] > 1 - eps);\n      }\n      debug(val, ctr);\n      ans = max(ans, val);\n    }\n    mat.resize(n + tt + 1);\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n#define dump(x) cout << #x << \" = \" << (x) << endl\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\ntemplate<class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n\tos<<\"{\";\n\trep(i, v.size()) {\n\t\tif (i) os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\n#define MN 510\nconst ll INF = TEN(18);\n\nstruct edge {\n\tint to, cap, rev; ll cost;\n\tedge(int to, int cap, ll cost, int rev) : to(to), cap(cap), cost(cost), rev(rev){}\n};\n\nint N;\nvector<edge> g[MN];\nll h[MN], dst[MN];\nint prevv[MN], preve[MN];\n\ninline void add_edge(int f, int t, int cap, ll cost) {\n\tg[f].emplace_back(t, cap, cost, (int)g[t].size());\n\tg[t].emplace_back(f, 0, -cost, (int)g[f].size() - 1);\n}\n\nll min_cost_flow(int s, int t, int f) {\n\tll res = 0;\n\tmemset(h, 0, sizeof(h));\n/*\n\tfill(h, h + N + 1, INF);\n\th[s] = 0;\n\tfor (int t = 0; t < N; ++t) {\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (auto e : g[i]) if (e.cap) {\n\t\t\t\th[e.to] = min(h[e.to], h[i] + e.cost);\n\t\t\t}\n\t\t}\n\t}\n*/\n\twhile (f > 0) {\n\t\tusing pli = pair<ll, int>;\n\t\tpriority_queue<pli, vector<pli>, greater<pli> > que;\n\t\tfill(dst, dst + N + 1, INF);\n\t\tdst[s] = 0;\n\t\tque.push(mp(0, s));\n\t\twhile (!que.empty()) {\n\t\t\tpli p = que.top(); que.pop();\n\t\t\tint v = p.se;\n\t\t\tif (dst[v] < p.fi) continue;\n\t\t\trep(i, g[v].size()) {\n\t\t\t\tedge &e = g[v][i];\n\t\t\t\tll nd = dst[v] + e.cost + h[v] - h[e.to];\n\t\t\t\tif (e.cap > 0 && dst[e.to] > nd) {\n\t\t\t\t\tdst[e.to] = nd;\n\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\tque.push(mp(dst[e.to], e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (dst[t] == INF) return -INF;\n\t\trep(i, N) h[i] += dst[i];\n\n\t\tint d = f;\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\td = min(d, g[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d * h[t];\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\tedge &e = g[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tg[v][e.rev].cap += d;\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint main() {\n\tint n; cin >> n;\n\tvector<pair<pii, ll>> pts(n);\n\n\trep(i, n) {\n\t\tint x, y; ll v;\n\t\tcin >> x >> y >> v;\n\t\t--x; --y;\n\t\tpts[i] = mp(mp(x, y), v);\n\t}\n\n\tint M; cin >> M;\n\tvector<pair<int, pii>> conds;\n\trep(i, M) {\n\t\tchar c; int a, b;\n\t\tcin >> c >> a >> b;\n\t\t--a; \n\t\tif (c == 'L') {\n\t\t\tconds.eb(0, mp(a, b));\n\t\t} else if (c == 'R') {\n\t\t\tconds.eb(1, mp(a, b));\n\t\t} else if (c == 'D') {\n\t\t\tconds.eb(2, mp(a, b));\n\t\t} else {\n\t\t\tconds.eb(3, mp(a, b));\n\t\t}\n\t}\n\n\tll ans = 0;\n\n\tfor (int num = 1; num <= n; ++num) {\n\t\trep(j, MN) g[j].clear();\n\t\tvi lox(num + 1, 0), hix(num + 1, 99), loy(num + 1, 0), hiy(num + 1, 99);\n\n\t\trep(i, M) {\n\t\t\tint a = conds[i].se.fi, b = conds[i].se.se;\n\t\t\tif (b >= num) continue;\n\n\t\t\tif (conds[i].fi == 0) {\n\t\t\t\tlox[b + 1] = max(lox[b + 1], a + 1);\n\t\t\t} else if (conds[i].fi == 1) {\n\t\t\t\thix[num - b] = min(hix[num - b], a - 1);\n\t\t\t} else if (conds[i].fi == 2) {\n\t\t\t\tloy[b + 1] = max(loy[b + 1], a + 1);\n\t\t\t} else {\n\t\t\t\thiy[num - b] = min(hiy[num - b], a - 1);\n\t\t\t}\n\t\t}\n\n\t\tbool ok = true;\n\t\tfor (int i = 1; i <= num; ++i) {\n\t\t\tif (lox[i] > hix[i] || loy[i] > hiy[i]) {\n\t\t\t\tok = false;\n\t\t\t}\n\t\t}\n\n\t\tif (!ok) continue;\n\t\trep(i, num) {\n\t\t\tlox[i+1] = max(lox[i+1], lox[i]);\n\t\t\tloy[i+1] = max(loy[i+1], loy[i]);\n\t\t}\n\t\tfor (int i = num-1; i >= 0; --i) {\n\t\t\thix[i] = min(hix[i], hix[i+1]);\n\t\t\thiy[i] = min(hiy[i], hiy[i+1]);\n\t\t}\n\n\t\tN = (1 + num + 100) * 2;\n\n\t\tint s = 0, t = N-1;\n\n\t\trep(i, num) {\n\t\t\tadd_edge(s, i + 1, 1, 0ll);\n\t\t\tfor (int x = lox[i+1]; x <= hix[i+1]; ++x) {\n\t\t\t\tadd_edge(i + 1, 1 + num + x, 1, 0ll);\n\t\t\t}\n\n\t\t\tadd_edge(1 + num + 100 + 100 + i, t, 1, 0ll);\n\t\t\tfor (int y = loy[i+1]; y <= hiy[i+1]; ++y) {\n\t\t\t\tadd_edge(1 + num + 100 + y, 1 + num + 100 + 100 + i, 1, 0ll);\n\t\t\t}\n\t\t}\n\n\t\trep(i, n) {\n\t\t\tint x = pts[i].fi.fi, y = pts[i].fi.se;\n\t\t\tadd_edge(1 + num + x, 1 + num + 100 + y, 1, -pts[i].se);\n\t\t}\n\n\t\tll res = min_cost_flow(s, t, num);\n\t\tif (res != -INF) {\n\t\t\tans = max(ans, -res);\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace __gnu_pbds;\nusing namespace std;\n \ntemplate <typename T>\nusing ordered_set =\n\ttree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n \n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n\t*this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n \n#define shandom_ruffle random_shuffle\n \nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=327;\nusing bn=bitset<87>;\nusing ld=long double;\n\nint n;\npii gdz[nax];\nll war[nax];\n\nint m;\nbn podz[nax];\nint ile[nax];\n\nll wyn;\n\nbn ter;\n \nll dajwar()\n{\n\tll ret=0;\n\tfor (int i=1; i<=n; i++)\n\t\tif (ter[i])\n\t\t\tret+=war[i];\n\treturn ret;\n}\n \nint popr()\n{\n\tfor (int i=1; i<=m; i++)\n\t\tif ((podz[i]&ter).count()>ile[i])\n\t\t\treturn 0;\n\treturn 1;\n}\n\nstruct Simplex {        // Maximize c*x subject to Ax <= b.\n  using T = ld;     // Initialize the structure, set A, b, c and then run\n  vector<vector<T>> A;  // solve(). Max objective is stored in res. To recover\n  vector<T> b, c;       // the best result, use getVars().\n  int V, E;\n  vector<int> eqIds, varIds, cols;\n  T res;\n  static constexpr T kEps = 1e-5;\n\n  Simplex(int vars, int eqs) : A(eqs, vector<T>(vars)), b(eqs), c(vars),\n      V(vars), E(eqs), eqIds(eqs), varIds(vars), res(0) {\n    iota(varIds.begin(), varIds.end(), 0);\n    iota(eqIds.begin(), eqIds.end(), vars);\n  }\n\n  void pivot(int eq, int var) {\n    T coef = 1 / A[eq][var];\n    cols.clear();\n    for (int i = 0; i < V; i++) {\n      if (abs(A[eq][i]) > kEps) { cols.push_back(i); A[eq][i] *= coef; }\n    }\n    A[eq][var] *= coef; b[eq] *= coef;\n    for (int row = 0; row < E; row++) {\n      if (row == eq || abs(A[row][var]) < kEps) { continue; }\n      T k = -A[row][var];\n      A[row][var] = 0;\n      for (int i : cols) { A[row][i] += k * A[eq][i]; }\n      b[row] += k * b[eq];\n    }\n    T q = c[var]; c[var] = 0;\n    for (int i : cols) { c[i] -= q * A[eq][i]; }\n    res += q * b[eq];\n    swap(varIds[var], eqIds[eq]);\n  }\n\n  bool solve() {\n    while (true) {\n      int eq = -1, var = -1;\n      for (int i = 0; i < E; i++) { if (b[i] < -kEps) { eq = i; break; } }\n      if (eq == -1) { break; }\n      for (int i = 0; i < V; i++) { if (A[eq][i] < -kEps) { var = i; break; } }\n      if (var == -1) { res = -1e9; return false; /* No solution */ }\n      pivot(eq, var);\n    }\n    while (true) {\n      int var = -1, eq = -1;\n      for (int i = 0; i < V; i++) { if (c[i] > kEps) { var = i; break; } }\n      if (var == -1) { break; }\n      for (int i = 0; i < E; i++) {\n        if (A[i][var] < kEps) { continue; }\n        if (eq >= 0 && b[i] / A[i][var] >= b[eq] / A[eq][var]) { continue; }\n        eq = i;\n      }\n      if (eq == -1) { res = 1e9; return false; /* Unbounded */ }\n      pivot(eq, var);\n    }\n    return true;\n  }\n\n  vector<T> getVars() { // Optimal assignment of variables.\n    vector<T> result(V);\n    for (int i = 0; i < E; i++) if (eqIds[i] < V) result[eqIds[i]] = b[i];\n    return result;\n  }\n};\n\nvoid rek(int v, int jesz)\n{\n\tif (popr())\n\t\twyn=max(wyn, dajwar());\n\tif (!jesz)\n\t\treturn;\n\tfor (int i=v; i<=n; i++)\n\t{\n\t\tter.flip(i);\n\t\trek(i+1, jesz-1);\n\t\tter.flip(i);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(\"%d%d%lld\", &gdz[i].first, &gdz[i].second, &war[i]);\n\tscanf(\"%d\", &m);\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\tchar c;\n\t\tint a, b;\n\t\tscanf(\" %c%d%d\", &c, &a, &b);\n\t\tfor (int j=1; j<=n; j++)\n\t\t{\n\t\t\tif (c=='L' && gdz[j].first<=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='R' && gdz[j].first>=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='D' && gdz[j].second<=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='U' && gdz[j].second>=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t}\n\t\tile[i]=b;\n\t}\n\tSimplex janusz(n, m+2*n);\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tjanusz.c[i]=war[i+1];\n\t}\n\tfor (int i=0; i<m; i++)\n\t{\n\t\tjanusz.b[i]=ile[i+1];\n\t\tfor (int j=0; j<n; j++)\n\t\t\tjanusz.A[i][j]=podz[i+1][j+1];\n\t}\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tjanusz.b[m+i]=1;\n\t\tjanusz.A[m+i][i]=1;\n\t}\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tjanusz.b[m+n+i]=0;\n\t\tjanusz.A[m+n+i][i]=-1;\n\t}\n\tassert(janusz.solve());\n\tauto wez=janusz.getVars();\n\t\n\tfor (int i=0; i<n; i++)\n\t\tter[i+1]=(wez[i]>0.5);\n\t\n\tll sta=dajwar();\n\t\n\twhile(popr())\n\t{\n\t\tint czy=0;\n\t\tfor (int i=1; i<=n; i++)\n\t\t{\n\t\t\tif (!ter[i])\n\t\t\t{\n\t\t\t\tter[i]=1;\n\t\t\t\tif (popr())\n\t\t\t\t\tczy=1;\n\t\t\t\telse\n\t\t\t\t\tter[i]=0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (!czy)\n\t\t\tbreak;\n\t}\n\t\n\trek(1, 4);\n\t\n\tdebug() << janusz.getVars();\n\tprintf(\"%lld\\n\", wyn);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstring>\n#include <cstdio>\nusing ll = long long;\nint lst[405], to[200005], pre[200005], cap[200005], tot;\nint que[2000005], path[405], sum[405];\nbool in[405], vis[405];\nll dis[405], cost[200005];\ninline void add_edge(int u, int v, int _cap, ll _cost)\n{\n\tauto _add = [&] (int x, int y, int ca, ll co)\n\t{\n\t\tto[tot] = y;\n\t\tpre[tot] = lst[x];\n\t\tcap[tot] = ca;\n\t\tcost[tot] = co;\n\t\tlst[x] = tot++;\n\t};\n\t_add(u, v, _cap, _cost);\n\t_add(v, u, 0, -_cost);\n}\nint dfs(int u, int t, int rem)\n{\n\tif (u == t)\n\t\treturn rem;\n\tvis[u] = true;\n\tint ans = 0;\n\tfor (int i = lst[u]; ~i; i = pre[i])\n\t{\n\t\tif (vis[to[i]] || !cap[i] || dis[to[i]] != dis[u] + cost[i])\n\t\t\tcontinue;\n\t\tint v = to[i], res = dfs(v, t, std::min(rem - ans, cap[i]));\n\t\tcap[i] -= res;\n\t\tcap[i ^ 1] += res;\n\t\tans += res;\n\t\tif (ans == rem)\n\t\t\treturn ans;\n\t}\n\treturn ans;\n}\ninline ll min_cost_max_flow(int s, int t)\n{\n\tll res = 0;\n\twhile (true)\n\t{\n\t\tmemset(dis, 0x3f, sizeof(dis));\n\t\tmemset(in, false, sizeof(in));\n\t\tint he = 0, ta = 0;\n\t\tque[ta++] = s;\n\t\tdis[s] = 0;\n\t\tin[s] = true;\n\t\tauto update = [&] { if (he < ta && dis[que[he]] > dis[que[ta - 1]]) std::swap(que[he], que[ta - 1]); };\n\t\twhile (he < ta)\n\t\t{\n\t\t\tint u = que[he++];\n\t\t\tin[u] = false;\n\t\t\tupdate();\n\t\t\tfor (int i = lst[u]; ~i; i = pre[i])\n\t\t\t{\n\t\t\t\tif (cap[i] && dis[to[i]] > dis[u] + cost[i])\n\t\t\t\t{\n\t\t\t\t\tpath[to[i]] = i;\n\t\t\t\t\tdis[to[i]] = dis[u] + cost[i];\n\t\t\t\t\tif (!in[to[i]])\n\t\t\t\t\t{\n\t\t\t\t\t\tin[to[i]] = true;\n\t\t\t\t\t\tque[ta++] = to[i];\n\t\t\t\t\t\tupdate();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dis[t] >= 1e18)\n\t\t\tbreak;\n\t\twhile (true)\n\t\t{\n\t\t\tfor (int i = 0; i < ta; i++)\n\t\t\t\tvis[que[i]] = false;\n\t\t\tint mn = dfs(s, t, 1e9);\n\t\t\tif (!mn)\n\t\t\t\tbreak;\n\t\t\tres += mn * dis[t];\n\t\t}\n\t}\n\treturn res;\n}\nconstexpr int LIM = 100;\nstruct { int x, y; ll w; } arr[105];\nstruct { char tp; int a, b; } qry[105];\nint xl[105], xr[105], yl[105], yr[105];\nint main()\n{\n\t// freopen(\"AGC031-E.in\", \"r\", stdin);\n\tint n, q;\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(\"%d%d%lld\", &arr[i].x, &arr[i].y, &arr[i].w);\n\tscanf(\"%d\", &q);\n\tfor (int i = 0; i < q; i++)\n\t\tscanf(\" %c%d%d\", &qry[i].tp, &qry[i].a, &qry[i].b);\n\tll ans = 0;\n\tfor (int k = 1; k <= n; k++)\n\t{\n\t\tfor (int i = 1; i <= k; i++)\n\t\t{\n\t\t\txl[i] = yl[i] = 1;\n\t\t\txr[i] = yr[i] = LIM - 1;\n\t\t}\n\t\tfor (int i = 0; i < q; i++)\n\t\t{\n\t\t\tif (qry[i].b >= k)\n\t\t\t\tcontinue;\n\t\t\tif (qry[i].tp == 'L' || qry[i].tp == 'D')\n\t\t\t{\n\t\t\t\tint *res = qry[i].tp == 'L' ? xl : yl;\n\t\t\t\tres[qry[i].b + 1] = std::max(res[qry[i].b + 1], qry[i].a + 1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint *res = qry[i].tp == 'R' ? xr : yr;\n\t\t\t\tres[k - qry[i].b] = std::min(res[k - qry[i].b], qry[i].a - 1);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 2; i <= k; i++)\n\t\t{\n\t\t\txl[i] = std::max(xl[i], xl[i - 1]);\n\t\t\tyl[i] = std::max(yl[i], yl[i - 1]);\n\t\t}\n\t\tfor (int i = k - 1; i; i--)\n\t\t{\n\t\t\txr[i] = std::min(xr[i], xr[i + 1]);\n\t\t\tyr[i] = std::min(yr[i], yr[i + 1]);\n\t\t}\n\t\tmemset(lst, -1, sizeof(lst));\n\t\ttot = 0;\n\t\tfor (int i = 1; i <= k; i++)\n\t\t{\n\t\t\tadd_edge(0, i, 1, 0);\n\t\t\tadd_edge(k + i, k * 2 + LIM * 2 + 1, 1, 0);\n\t\t\tfor (int j = xl[i]; j <= xr[i]; j++)\n\t\t\t\tadd_edge(i, k * 2 + j, 1, 0);\n\t\t\tfor (int j = yl[i]; j <= yr[i]; j++)\n\t\t\t\tadd_edge(k * 2 + LIM + j, k + i, 1, 0);\n\t\t}\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tadd_edge(k * 2 + arr[i].x, k * 2 + LIM + arr[i].y, 1, -arr[i].w);\n\t\tans = std::max(ans, -min_cost_max_flow(0, k * 2 + LIM * 2 + 1));\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing uint = unsigned int;\n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define rep1(i,n) for(int i=1;i<=int(n);i++)\n#define per(i,n) for(int i=int(n)-1;i>=0;i--)\n#define per1(i,n) for(int i=int(n);i>0;i--)\n#define all(c) c.begin(),c.end()\n#define si(x) int(x.size())\n#define pb emplace_back\n#define fs first\n#define sc second\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = vector<vector<T>>;\ntemplate<class T,class U> void chmax(T& x, U y){if(x<y) x=y;}\ntemplate<class T,class U> void chmin(T& x, U y){if(y<x) x=y;}\ntemplate<class T> void mkuni(V<T>& v){sort(all(v));v.erase(unique(all(v)),v.end());}\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){\n\treturn o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";\n}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){\n\to<<\"{\";\n\tfor(const T& v:vc) o<<v<<\",\";\n\to<<\"}\";\n\treturn o;\n}\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\n#ifdef LOCAL\n#define show(x) cerr << \"LINE\" << __LINE__ << \" : \" << #x << \" = \" << (x) << endl\nvoid dmpr(ostream& os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" ~ \";\n\tdmpr(os,args...);\n}\n#define shows(...) cerr << \"LINE\" << __LINE__ << \" : \";dmpr(cerr,##__VA_ARGS__)\n#define dump(x) cerr << \"LINE\" << __LINE__ << \" : \" << #x << \" = {\";  \\\n\tfor(auto v: x) cerr << v << \",\"; cerr << \"}\" << endl;\n#else\n#define show(x) void(0)\n#define dump(x) void(0)\n#define shows(...) void(0)\n#endif\n\nstruct MinCostFlow{\n\tusing C = ll;\t\t// capacity\n\tusing D = ll;\t\t// distance (cost)\n\tconst D inf = 1e18;\n\n\tstruct edge{\n\t\tint to;\n\t\tC cap;\n\t\tD dist;\n\t\tint rev;\n\t\tedge(int to_,C cap_, D dist_, int rev_):to(to_),cap(cap_),dist(dist_),rev(rev_){}\n\t};\n\t\n\tint N;\n\tVV<edge> G;\n\tV<D> h;\n\tV<D> dist;\n\tV<int> prevv,preve;\n\tMinCostFlow(int N_):N(N_){\n\t\tG.resize(N);\n\t\th.resize(N);\n\t\tdist.resize(N);\n\t\tprevv.resize(N);\n\t\tpreve.resize(N);\n\t}\n\n\tvoid add_edge(int from, int to, C cap, D dist){\n//\t\tcerr << \"add edge: \" << from \" -> \" << to << \"(cap,dist) = \" << cap << \",\" << dist << endl;\n\t\tedge e1(to,cap,dist,(int)G[to].size());\n\t\tedge e2(from,0,-dist,(int)G[from].size());\n\t\tG[from].push_back(e1);\n\t\tG[to].push_back(e2);\n\t}\n\tD min_cost_flow(int s, int t, C f){\n\t\tD res = 0;\n\t\th = V<D>(N);\n\t\twhile(f > 0){\n\t\t\tusing P = pair<D,int>;\n\t\t\tpriority_queue< P,vector<P>,greater<P> > que;\n\t\t\tdist = V<D>(N,inf);\n\t\t\tdist[s] = 0;\n\t\t\tque.push(P(0,s));\n\t\t\twhile(!que.empty()){\n\t\t\t\tP p = que.top();\n\t\t\t\tque.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif(dist[v] < p.first) continue;\n\t\t\t\tfor(int i=0;i<(int)G[v].size();i++){\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif(e.cap>0 && dist[e.to]>dist[v]+e.dist+h[v]-h[e.to]){\n\t\t\t\t\t\tdist[e.to]=dist[v]+e.dist+h[v]-h[e.to];\n\t\t\t\t\t\tprevv[e.to]=v;\n\t\t\t\t\t\tpreve[e.to]=i;\n\t\t\t\t\t\tque.push(P(dist[e.to],e.to));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dist[t]==inf) return -1;\n\t\t\trep(v,N) h[v]+=dist[v];\n\t\t\tC d = f;\n\t\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\t\tchmin(d,G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\t\tedge &e=G[prevv[v]][preve[v]];\n\t\t\t\te.cap-=d;\n\t\t\t\tG[v][e.rev].cap+=d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\t\t//DON'T USE scanf/printf/puts !!\n\tcout << fixed << setprecision(20);\n\n\tconst int S = 101;\n\tint N; cin >> N;\n\tV<int> jx(N),jy(N);\n\tV<ll> jv(N);\n\trep(i,N){\n\t\tcin >> jx[i] >> jy[i] >> jv[i];\n\t\tjx[i]--,jy[i]--;\n\t}\n\tint M; cin >> M;\n\tV<int> L_(S,N),R_(S,N),D_(S,N),U_(S,N);\n\trep(i,M){\n\t\tchar c; int a,b; cin >> c >> a >> b; a--;\n\t\tif(c == 'L') L_[a] = b;\n\t\tif(c == 'R') R_[a] = b;\n\t\tif(c == 'D') D_[a] = b;\n\t\tif(c == 'U') U_[a] = b;\n\t}\n\tll ans = 0;\n\trep1(K,N){\n\t\tV<int> L=L_,D=D_,R(S),U(S);\n\t\trep(i,S-1){\n\t\t\tR[i] = max(K - R_[i+1],0);\n\t\t\tU[i] = max(K - U_[i+1],0);\n\t\t}\n\t\trep(i,S){\n\t\t\tchmin(L[i],K);\n\t\t\tchmin(D[i],K);\n\t\t}\n\t\tper(i,S-1){\n\t\t\tchmin(L[i],L[i+1]);\n\t\t\tchmin(D[i],D[i+1]);\n\t\t}\n\t\trep1(i,S-1){\n\t\t\tchmax(R[i],R[i-1]);\n\t\t\tchmax(U[i],U[i-1]);\n\t\t}\n\t\tshow(\"=====================\");\n\t\tshow(K);\n\t\tshow(L);show(R);\n\n\t\tint FN = 1+S+N+S+1;\n\t\tMinCostFlow MCF(FN);\n\t\tint SS = 0, TT = 1;\n\t\tauto f = [&](int i){return i+2;};\n\t\tauto g = [&](int i){return i+2+S;};\n\t\tauto h = [&](int i){return i+2+S+N;};\n\t\tbool ok = true;\n\t\t{\n\t\t\trep(i,S){\n\t\t\t\tint cap = L[i] - (i==0 ? 0 : L[i-1]);\n\t\t\t\tMCF.add_edge(SS,f(i),cap,0);\n\t\t\t}\n\t\t\trep(i,S-1){\n\t\t\t\tint cap = L[i] - R[i];\n\t\t\t\tif(cap<0) ok = false;\n\t\t\t\tMCF.add_edge(f(i),f(i+1),cap,0);\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\trep(i,S){\n\t\t\t\tint cap = D[i] - (i==0 ? 0 : D[i-1]);\n\t\t\t\tMCF.add_edge(h(i),TT,cap,0);\n\t\t\t}\n\t\t\trep(i,S-1){\n\t\t\t\tint cap = D[i] - U[i];\n\t\t\t\tif(cap<0) ok = false;\n\t\t\t\tMCF.add_edge(h(i+1),h(i),cap,0);\n\t\t\t}\n\t\t}\n\t\tshow(ok);\n\t\tif(!ok) continue;\n\t\tconst ll inf = TEN(15);\n\t\trep(i,N){\n\t\t\tMCF.add_edge(f(jx[i]),g(i),1,inf-jv[i]);\n\t\t\tMCF.add_edge(g(i),h(jy[i]),1,0);\n\t\t}\n\t\tll F = MCF.min_cost_flow(SS,TT,K);\n\t\tshow(F);\n\t\tif(F == -1) continue;\n\t\tF = inf * K - F;\n\t\tchmax(ans,F);\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\ntypedef long double T; // long long double, Rational, long double + mod<P>...\ntypedef vector<T> vd;\ntypedef vector<vd> vvd;\n\ntypedef long double DOUBLE;\ntypedef vector<DOUBLE> VD;\ntypedef vector<VD> VVD;\ntypedef vector<int> VI;\nconst DOUBLE EPS = 1e-20;\nstruct LPSolver {\n\tint m, n; VI B, N; VVD D;\n\tLPSolver(const VVD &A, const VD &b, const VD &c) : m(b.size()), n(c.size()), N(n + 1), B(m), D(m + 2, VD(n + 2)) { for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) D[i][j] = A[i][j]; for (int i = 0; i < m; i++) { B[i] = n + i; D[i][n] = -1; D[i][n + 1] = b[i]; } for (int j = 0; j < n; j++) { N[j] = j; D[m][j] = -c[j]; } N[n] = -1; D[m + 1][n] = 1; }\n\tvoid Pivot(int r, int s) { long double inv = 1.0 / D[r][s]; for (int i = 0; i < m + 2; i++) if (i != r) for (int j = 0; j < n + 2; j++) if (j != s) D[i][j] -= D[r][j] * D[i][s] * inv; for (int j = 0; j < n + 2; j++) if (j != s) D[r][j] *= inv; for (int i = 0; i < m + 2; i++) if (i != r) D[i][s] *= -inv; D[r][s] = inv; swap(B[r], N[s]); }\n\tbool Simplex(int phase) { int x = phase == 1 ? m + 1 : m; while (true) { int s = -1; for (int j = 0; j <= n; j++) { if (phase == 2 && N[j] == -1) continue; if (s == -1 || D[x][j] < D[x][s] || D[x][j] == D[x][s] && N[j] < N[s]) s = j; }if (D[x][s] > -EPS) return true; int r = -1; for (int i = 0; i < m; i++) { if (D[i][s] < EPS) continue; if (r == -1 || D[i][n + 1] / D[i][s] < D[r][n + 1] / D[r][s] || (D[i][n + 1] / D[i][s]) == (D[r][n + 1] / D[r][s]) && B[i] < B[r]) r = i; }if (r == -1) return false; Pivot(r, s); } } \n\tDOUBLE Solve(VD &x) { int r = 0; for (int i = 1; i < m; i++) if (D[i][n + 1] < D[r][n + 1]) r = i; if (D[r][n + 1] < -EPS) { Pivot(r, n); if (!Simplex(1) || D[m + 1][n + 1] < -EPS) return -numeric_limits<DOUBLE>::infinity(); for (int i = 0; i < m; i++) if (B[i] == -1) { int s = -1; for (int j = 0; j <= n; j++) if (s == -1 || D[i][j] < D[i][s] || D[i][j] == D[i][s] && N[j] < N[s]) s = j; Pivot(i, s); } }if (!Simplex(2)) return numeric_limits<DOUBLE>::infinity(); x = VD(n); for (int i = 0; i < m; i++) if (B[i] < n) x[B[i]] = D[i][n + 1]; return D[m][n + 1]; }\n};\n\nint n, m, x[105], y[105];\nll v[105];\n\nvvd A, A1;\nvd t, b, c, b1, c1;\n\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> x[i] >> y[i] >> v[i];\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tt.clear();\n\t\tt.resize(n);\n\t\tt[i] = 1;\n\t\tA.push_back(t);\n\t\tb.push_back(1);\t\t\n\t}\n\tcin >> m;\n\tfor (int i = 0; i < m; ++i) {\n\t\tt.clear();\n\t\tt.resize(n);\n\t\tchar f;\n\t\tint a, bb;\n\t\tcin >> f >> a >> bb;\n\t\tif (f == 'L') {\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\tif (x[j] <= a)\n\t\t\t\t\tt[j] = 1;\n\t\t} if (f == 'R') {\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\tif (x[j] >= a)\n\t\t\t\t\tt[j] = 1;\n\t\t} if (f == 'U') {\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\tif (y[j] >= a)\n\t\t\t\t\tt[j] = 1;\n\t\t} if (f == 'D') {\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\tif (y[j] <= a)\n\t\t\t\t\tt[j] = 1;\n\t\t}\n\t\tA.push_back(t);\n\t\tb.push_back(bb);\n\t}\n\tc.resize(n);\n\tc1.resize(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tc[i] = 1;\n\t\tc1[i] = v[i];\n\t}\n\tA1 = A, b1 = b;\n\tvd xx;\n\tint mm = floor(LPSolver(A, b, c).Solve(xx)+2*EPS);\n\tt.clear();\n\tt.resize(n);\n\tfor (int i = 0; i < n; ++i)\n\t\tt[i] = 1;\n\tA1.push_back(t);\n\tb1.push_back(mm);\n\tcout << lround(LPSolver(A1, b1, c1).Solve(xx)) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define nn 808\n#define ll long long \n\nnamespace ene{\n\tvector<ll> v[nn],cap[nn],cost[nn],rev[nn];\n\tvoid clear()\n\t{\n\t\tfor(ll i=0;i<nn;i++) v[i].clear(),cap[i].clear(),cost[i].clear(),rev[i].clear();\n\t}\n\tvoid link(ll x,ll y,ll c,ll d)\n\t{\n\t\trev[x].push_back(v[y].size());rev[y].push_back(v[x].size());\n\t\tv[x].push_back(y);v[y].push_back(x);\n\t\tcap[x].push_back(c);cap[y].push_back(0);\n\t\tcost[x].push_back(d);cost[y].push_back(-d);\n\t}\n\t\n\tll ss;ll vis[nn];\n\tll prex[nn],prei[nn];ll dist[nn];\n\tvoid spfa(ll s)\n\t{\n\t\tfor(ll i=0;i<nn;i++) dist[i]=-1e18;\n\t\tqueue<ll> q;q.push(s);dist[s]=0;vis[s]=1;\n\t\twhile(q.size())\n\t\t{\n\t\t\tll x=q.front();q.pop();vis[x]=0;\n\t\t\tfor(ll i=0;i<v[x].size();i++)\n\t\t\t{\n\t\t\t\tll y=v[x][i];\n\t\t\t\tif(dist[y]<dist[x]+cost[x][i] and cap[x][i])\n\t\t\t\t{\n\t\t\t\t\tdist[y]=dist[x]+cost[x][i],prex[y]=x,prei[y]=i;\n\t\t\t\t\tif(!vis[y]) q.push(y);vis[y]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll dfs(ll y,ll f)\n\t{\n\t\tif(y==ss) return f;\n\t\tll x=prex[y],i=prei[y],j=rev[x][i];\n\t\tf=dfs(x,min(f,cap[x][i]));\n\t\tcap[x][i]-=f,cap[y][j]+=f;\n\t\treturn f;\n\t}\n\tll solve(ll s,ll t,ll n)\n\t{\n\t\tss=s;ll ans=0;\n\t\twhile(1)\n\t\t{\n\t\t\tspfa(s);if(dist[t]<-1e17) break;\n\t\t\tll tp=dfs(t,1e18);\n\t\t\ttp=min(tp,n);n-=tp;\n\t\t\tans+=tp*dist[t];\n\t\t}\n\t\tif(n) return -1e18;\n\t\treturn ans;\n\t}\n\n};\n\nll n,m;\nll xans[nn],yans[nn];ll val[nn];\nll s=nn-1,t=nn-2;\nll morex[nn],morey[nn],lessx[nn],lessy[nn];\nchar str[nn][3];ll xx[nn],kk[nn];\nll output=0;\nvoid solve(ll guess)\n{\n\tene::clear();set<ll> sx,sy;map<ll,ll> mx,my;\n\tfor(ll i=1;i<=n;i++) sx.insert(xans[i]),sy.insert(yans[i]);\t\n\t\n\tsx.insert(1e16),sy.insert(1e16);\n\t\n\tll tot=0;ll xn,yn;\n\tfor(set<ll>::iterator it=sx.begin();it!=sx.end();it++) mx[*it]=++tot;xn=tot;\n\tfor(set<ll>::iterator it=sy.begin();it!=sy.end();it++) my[*it]=++tot;yn=tot;\n\t\n\tfor(ll i=1;i<=n;i++) ene::link(mx[xans[i]],my[yans[i]],1,val[i]);\n\t\n\tmemset(morex,0x3f,sizeof morex);memset(morey,0x3f,sizeof morey);\n\tmemset(lessx,0,sizeof lessx);memset(lessy,0,sizeof lessy);\n\t\n\tfor(ll i=1;i<=m;i++)\n\t{\n\t\tll x=xx[i],k=kk[i];\n\t\tif(str[i][0]=='R')\n\t\t{\n\t\t\tk++;\n\t\t\tll tx=*sx.lower_bound(x);\n\t\t\tif(k<=xn)morex[k]=min(morex[k],mx[tx]-1);\n\t\t}\n\t\telse if(str[i][0]=='U')\n\t\t{\n\t\t\tk++;k+=xn;\n\t\t\tll ty=*sy.lower_bound(x);\n\t\t\tif(k<=yn)morey[k]=min(morey[k],my[ty]-1);\n\t\t}\n\t\telse if(str[i][0]=='L')\n\t\t{\n\t\t\tk=guess-k;\n\t\t\tll tx=*sx.upper_bound(x);\n\t\t\tif(k>=1)lessx[k]=max(lessx[k],mx[tx]);\n\t\t}\n\t\telse if(str[i][0]=='D')\n\t\t{\n\t\t\tk=guess-k;k+=xn;\n\t\t\tll ty=*sy.upper_bound(x);\n\t\t\tif(k>=xn+1)lessy[k]=max(lessy[k],my[ty]);\n\t\t}\n\t}\n\t\n\t\t\n\tfor(ll i=2;i<=xn;i++) morex[i]=min(morex[i-1],morex[i]);\n\tfor(ll i=xn;i>=2;i--) lessx[i-1]=max(lessx[i-1],lessx[i]); \n\tfor(ll i=xn+2;i<=yn;i++) morey[i]=min(morey[i-1],morey[i]);\n\tfor(ll i=yn;i>=xn+2;i--) lessy[i-1]=max(lessy[i-1],lessy[i]);\n\t//cout<<lessx[2]<<\"\\n\";\n\tfor(ll i=1;i<=guess;i++)\n\t{\n\t\t++tot;ene::link(s,tot,1,0);\n\t\tfor(ll j=1;j<=xn;j++)\n\t\t\tif(j>=lessx[i] and j<=morex[i])\n\t\t\t\tene::link(tot,j,1,0);\n\t}system(\"pause\");\n\tfor(ll i=xn+1;i<=guess;i++)\n\t{\n\t\t++tot;ene::link(tot,t,1,0);\n\t\tfor(ll j=xn+1;j<=yn;j++)\n\t\t\tif(j>=lessy[i] and j<=morey[i])\n\t\t\t\tene::link(j,tot,1,0);\n\t}\n\t\n//\tif(output>0) cout<<guess<<\"\\n\";\n\toutput=max(output,ene::solve(s,t,guess));\n}\n\nsigned main()\n{\n\tscanf(\"%lld\",&n);for(ll i=1;i<=n;i++) scanf(\"%lld%lld%lld\",&xans[i],&yans[i],&val[i]);\n\tscanf(\"%lld\",&m);for(ll i=1;i<=m;i++) scanf(\"%s%lld%lld\",str[i],&xx[i],&kk[i]);\n\t\n\tfor(ll i=1;i<=n;i++) solve(i);\n\t\n\tcout<<output<<\"\\n\";\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct edge\n{\n\tint v,nxt,flow;\n\tlong long w;\n}e[500050];\n\nint head[405],ecnt;\nlong long dep[405];\nbool inq[405];\nint n,m;\nint s,t;\nconst long long inf = 1e18;\n\nvoid adde(int u,int v,int fl,long long w)\n{\n\te[ecnt].v = v;\n\te[ecnt].nxt = head[u];\n\te[ecnt].flow = fl;\n\te[ecnt].w = w;\n\thead[u] = ecnt ++;\n}\n\nvoid Adde(int u,int v,int fl,long long w)\n{\n\tadde(u,v,fl,w);\n\tadde(v,u,0,-w);\n}\n\nbool spfa()\n{\n    deque<long long> que;\n   \tfor(int i = 0;i <= t; ++ i)\n   \t\tdep[i] = (1ll << 62);\n    memset(inq,0,sizeof(inq));\n    dep[t] = 0;\n    que.push_back(t);\n    while(!que.empty())\n    {\n        long long u = que.front();\n        que.pop_front();\n        for(long long i = head[u];~i;i = e[i].nxt)\n        {\n            long long v = e[i].v;\n            if(e[i ^ 1].flow && dep[u] - e[i].w < dep[v])\n            {\n                dep[v] = dep[u] + e[i ^ 1].w;\n                if(!inq[v])\n                {\n                    if(que.empty() || dep[v] < dep[que.front()])\n                        que.push_front(v);\n                    else\n                        que.push_back(v);\n                    inq[v] = true;\n                }\n            }\n        }\n        inq[u] = false;\n    }\n    return dep[s] < (1ll << 62);\n}\n\nint curedge[405];\nlong long ans;\nbool vis[405];\n\nlong long dfs(long long s,long long t,long long flow)\n{\n    if(s == t)\n        return flow;\n    long long delta = flow;\n    vis[s] = true;\n    for(long long i = head[s];~i;i = e[i].nxt)\n    {\n        long long v = e[i].v;\n        if(!vis[v] && dep[v] == dep[s] - e[i].w && e[i].flow)\n        {\n            //prlong longf(\"%d %d\\n\",s,v);\n            long long g = dfs(v,t,min((long long)e[i].flow,delta));\n            delta -= g;\n            ans += g * e[i].w;\n            e[i].flow -= g;\n            e[i ^ 1].flow += g;\n            if(!delta)\n                return flow;\n        }\n    }\n    return flow - delta;\n}\n\nlong long dinic()\n{\n    long long anss = 0;\n    while(spfa())\n    {\n    \tvis[t] = 1;\n    \twhile(vis[t])\n    \t{\n        \tmemset(vis,0,sizeof(vis));\n        \tanss += dfs(s,t,inf);\n        }\n    }\n    return anss;\n}\n\nint pre[405];\n\nstruct stone\n{\n\tint x,y;\n\tlong long vl;\n}st[105];\n\nstruct Limitation\n{\n\tint a,b;\n}L[105],R[105],D[105],U[105];\nint lc,rc,dc,uc;\nint xl[105],xr[105],yl[105],yr[105];\n\nint main()\n{\n\tint n; scanf(\"%d\",&n);\n\tfor(int i = 1;i <= n; ++ i)\n\t\tscanf(\"%d%d%lld\",&st[i].x,&st[i].y,&st[i].vl);\n\tint m; scanf(\"%d\",&m);\n\tfor(int i = 1;i <= m; ++ i)\n\t{\n\t\tchar str[16]; scanf(\"%s\",str + 1);\n\t\tif(str[1] == 'L') lc ++,scanf(\"%d%d\",&L[lc].a,&L[lc].b);\n\t\telse if(str[1] == 'R') rc ++,scanf(\"%d%d\",&R[rc].a,&R[rc].b);\n\t\telse if(str[1] == 'U') uc ++,scanf(\"%d%d\",&U[uc].a,&U[uc].b);\n\t\telse dc ++,scanf(\"%d%d\",&D[dc].a,&D[dc].b);\n\t}\n\tlong long as = 0;\n\tfor(int k = 1;k <= n; ++ k)\n\t{\n\t\tmemset(head,-1,sizeof(head));\n\t\tecnt = 0;\n\t\tans = 0;\n\t\ts = 0,t = k * 2 + n * 2 + 1;\n\t\tfor(int i = 1;i <= k; ++ i)\n\t\t\tAdde(s,i,1,0),\n\t\t\tAdde(i + 2 * n + k,t,1,0),\n\t\t\txl[i] = yl[i] = 0,xr[i] = yr[i] = 100;\n\t\tfor(int i = 1;i <= lc; ++ i)\n\t\t\tfor(int j = L[i].b + 1;j <= k; ++ j)\n\t\t\t\txl[j] = max(xl[j],L[i].a + 1);\n\t\tfor(int i = 1;i <= rc; ++ i)\n\t\t\tfor(int j = k - R[i].b;j >= 1; -- j)\n\t\t\t\txr[j] = min(xr[j],R[i].a - 1);\n\t\tfor(int i = 1;i <= dc; ++ i)\n\t\t\tfor(int j = D[i].b + 1;j <= k; ++ j)\n\t\t\t\tyl[j] = max(yl[j],D[i].a + 1);\n\t\tfor(int i = 1;i <= uc; ++ i)\n\t\t\tfor(int j = k - U[i].b;j >= 1; -- j)\n\t\t\t\tyr[j] = min(yr[j],U[i].a - 1);\n\t\tfor(int i = 1;i <= n; ++ i)\n\t\t{\n\t\t\tAdde(i + k,i + n + k,1,-st[i].vl);\n\t\t\tfor(int j = 1;j <= k; ++ j)\n\t\t\t{\n\t\t\t\tif(yl[j] <= st[i].y && st[i].y <= yr[j])\n\t\t\t\t\tAdde(i + n + k,j + 2 * n + k,1,0);\n\t\t\t\tif(xl[j] <= st[i].x && st[i].x <= xr[j])\n\t\t\t\t\tAdde(j,i + k,1,0);\n\t\t\t}\n\t\t}\n\t\tdinic(); as = max(as,-ans);\n\t}\n\tprintf(\"%lld\\n\",as);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for((i)=1;(i)<=(n);(i)++) \nusing namespace std;\nint n,m,i,j,px[85],py[85],pv[85],qa[85],qb[85],ans;\nchar qt[85];\nint mix[85],miy[85],mxx[85],mxy[85];\nstruct edge{\n\tint y,z,d;\n}e[2000005];\nvector<int> adj[405];\nint calc(int k){\n\tint i,j;\n\trep(i,k){\n\t\tmix[i]=miy[i]=0;\n\t\tmxx[i]=mxy[i]=101;\n\t}\n\trep(i,m){\n\t\tif(qb[i]<k){\n\t\t\tif(qt[i]=='L') mix[b[i]+1]=a[i]+1;\n\t\t\tif(qt[i]=='R') mxx[k-b[i]]=a[i]-1; \n\t\t\tif(qt[i]=='D') mix[b[i]+1]=a[i]+1;\n\t\t\tif(qt[i]=='U') mxx[k-b[i]]=a[i]-1; \n\t\t}\n\t}\n}\nint main(){\n\tcin>>n;\n\trep(i,n){\n\t\tcin>>px[i]>>py[i]>>pv[i];\n\t}\n\tcin>>m;\n\trep(i,m){\n\t\tcin>>qt[i]>>qa[i]>>qb[i];\n\t}\n\trep(i,n){\n\t\tans=max(ans,calc(i));\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// includes {{{\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<tuple>\n#include<cmath>\n#include<random>\n#include<cassert>\n#include<bitset>\n#include<cstdlib>\n// #include<deque>\n// #include<multiset>\n// #include<cstring>\n// #include<bits/stdc++.h>\n// }}}\nusing namespace std;\nusing ll = long long;\n\n// MinCostFlow(size, inf)\n// MinCostFlow(size, inf, int& s, int& t)\n// addEdge(from, to, capacity, cost, undirected = false)\n// === build(s, t, flow) ===\n// O(FE log V)\n// return mincost\n// return -1 if impossible\n/// --- MinCostFlow {{{ ///\n#include <cassert>\n#include <queue>\n#include <tuple>\n#include <vector>\n// with Dijkstra with Potential\nstruct MinCostFlow {\n  struct Edge {\n    int to;\n    ll cap, cost;\n    size_t rev;\n  };\n  int n;\n  vector< vector< Edge > > graph;\n  vector< ll > h; // potential\n  vector< ll > dist;\n  vector< int > prevv, preve;\n  ll inf;\n  MinCostFlow(int n, ll inf)\n    : n(n), graph(n), h(n), dist(n), prevv(n), preve(n), inf(inf) {}\n  MinCostFlow(int n, ll inf, int &s, int &t) : MinCostFlow(n + 2, inf) {\n    s = n, t = n + 1;\n  }\n  void addEdge(int a, int b, ll cap, ll cost, int undirected = 0) {\n    assert(cost >= 0);\n    assert(0 <= a && a < n);\n    assert(0 <= b && b < n);\n    graph[a].emplace_back((Edge){b, cap, cost, graph[b].size()});\n    graph[b].emplace_back((Edge){a, undirected ? cap : 0, -cost, graph[a].size() - 1});\n  }\n  ll build(int s, int t, ll f) {\n    h.assign(n, 0);\n    ll res = 0;\n    while(f > 0) {\n      dist.assign(n, inf);\n      dist[s] = 0;\n      // Dijkstra with potential\n      using P = pair< ll, int >;\n      priority_queue< P, vector< P >, greater< P > > pq;\n      pq.emplace(0, s);\n      while(pq.size()) {\n        ll d;\n        int v;\n        tie(d, v) = pq.top();\n        pq.pop();\n        if(dist[v] < d) continue;\n        for(size_t i = 0; i < graph[v].size(); i++) {\n          Edge &edge = graph[v][i];\n          ll nd = dist[v] + edge.cost + h[v] - h[edge.to];\n          if(edge.cap > 0 && dist[edge.to] > nd) {\n            dist[edge.to] = nd;\n            pq.emplace(nd, edge.to);\n            prevv[edge.to] = v;\n            preve[edge.to] = i;\n          }\n        }\n      }\n      //\n      if(dist[t] == inf) return -1;\n      for(int v = 0; v < n; v++) h[v] += dist[v];\n\n      ll d = f;\n      for(int v = t; v != s; v = prevv[v]) {\n        d = min(d, graph[prevv[v]][preve[v]].cap);\n      }\n      f -= d;\n      res += d * h[t];\n      for(int v = t; v != s; v = prevv[v]) {\n        Edge &edge = graph[prevv[v]][preve[v]];\n        edge.cap -= d;\n        graph[v][edge.rev].cap += d;\n      }\n    }\n    return res;\n  }\n};\n/// }}}--- ///\n\nll inf = 1e18;\n\nconstexpr int N = 80, M = 320;\n\nint n, m;\nint x[N], y[N];\nll v[N];\nchar type[M];\nint a[M], b[M];\n\nint XL[N], XR[N];\nint YL[N], YR[N];\n\n// smin, smax {{{\ntemplate < class T, class U >\ninline void smin(T &a, const U &b) {\n  a = a < (T) b ? a : b;\n}\ntemplate < class T, class U >\ninline void smax(T &a, const U &b) {\n  a = a < (T) b ? b : a;\n}\n// }}}\n\nll solve(int k) {\n  if(k == 0) return 0;\n  int s, t;\n  MinCostFlow ecas(k + k + n + n, inf, s, t);\n  for(int i = 0; i < k; i++) XL[i] = 0, XR[i] = 100;\n  for(int i = 0; i < k; i++) YL[i] = 0, YR[i] = 100;\n  for(int i = 0; i < m; i++) {\n    if(b[i] >= k) continue;\n    switch(type[i]) {\n      case 'L':\n        smax(XL[b[i]], a[i] + 1);\n        break;\n      case 'R':\n        smin(XR[k - b[i] - 1], a[i] - 1);\n        break;\n      case 'D':\n        smax(YL[b[i]], a[i] + 1);\n        break;\n      case 'U':\n        smin(YR[k - b[i] - 1], a[i] - 1);\n        break;\n    }\n  }\n  for(int i = 0; i + 1 < k; i++) smax(XL[i+1], XL[i]), smax(YL[i+1] , YL[i]);\n  for(int i = k - 2; i >= 0; i--) smin(XR[i], XR[i+1]), smin(YR[i] , YR[i+1]);\n\n  ll bias = 1e15;\n\n  for(int i = 0; i < k; i++) ecas.addEdge(s, i, 1, 0);\n  for(int i = 0; i < k; i++) ecas.addEdge(k + i, t, 1, 0);\n  for(int i = 0; i < n; i++) ecas.addEdge(k + k + i, k + k + n + i, 1, bias - v[i]);\n\n  for(int i = 0; i < k; i++) {\n    for(int j = 0; j < n; j++) {\n      if(XL[i] <= x[j] && x[j] <= XR[i]) {\n        ecas.addEdge(i, k + k + j, 1, 0);\n      }\n      if(YL[i] <= y[j] && y[j] <= YR[i]) {\n        ecas.addEdge(k + k + n + j, k + i, 1, 0);\n      }\n    }\n  }\n\n  ll val = ecas.build(s, t, k);\n  if(val == -1) return -1;\n\n  val = -val + bias * k;\n  return val;\n}\n\n// O(N^3 log^2 N)\nint main() {\n  std::ios::sync_with_stdio(false), std::cin.tie(0);\n\n  cin >> n;\n  for(int i = 0; i < n; i++) cin >> x[i] >> y[i] >> v[i];\n  \n  cin >> m;\n  for(int i = 0; i < m; i++) cin >> type[i] >> a[i] >> b[i];\n\n  ll ans = 0;\n\n  int ok = 0, ng = n + 1;\n  while(ng - ok > 1) {\n    int mid = (ok + ng) >> 1;\n    if(solve(mid) != -1) ok = mid; else ng = mid;\n  }\n\n  cout << solve(ok) << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nint S=0,T;\nint N;\nstruct edge{\n\tint s,t,cap;long long v;int nxt;\n}e[50005];\nint e_cnt,last[405];\nvoid addedge(int u,int v,int cap,long long l){\n\te[e_cnt]=(edge){u,v,cap,l,last[u]};\n\tlast[u]=e_cnt++;\n\te[e_cnt]=(edge){v,u,0,-l,last[v]};\n\tlast[v]=e_cnt++;\n}\nlong long d[405];int fa[405];\nbool vis[405];\n#define LIM -2e15\nbool dij(){\n\tfor(int i=0;i<=T;i++)d[i]=LIM;\n\tmemset(vis,0,sizeof(vis));\n\td[S]=0;\n\tfor(int i=0;i<=T;i++){\n\t\tint x=-1;\n\t\tfor(int j=0;j<=T;j++)if(!vis[j]&&(x==-1||d[j]>d[x]))x=j;\n\t\tif(x==-1)break;\n\t\tvis[x]=1;\n\t\tfor(int i=last[x];i!=-1;i=e[i].nxt)if(!vis[e[i].t]&&e[i].cap&&d[e[i].t]<d[x]+e[i].v){\n\t\t\tassert(e[i].v<=0);\n\t\t\td[e[i].t]=d[x]+e[i].v;\n\t\t\tfa[e[i].t]=i;\n\t\t}\n\t}\n\treturn d[T]>LIM;\n}\npair<int,long long> solve(){\n\tint flow=0;long long cost=0;long long r=0;\n\twhile(dij()){\n\t\tflow++;\n\t\tint u=T;\n\t\twhile(u!=S){\n\t\t\te[fa[u]].cap=0;\n\t\t\te[fa[u]^1].cap=1;\n\t\t\tu=e[fa[u]].s;\n\t\t}\n\t\tr+=d[T];\n\t\tcost+=r;\n\t\tfor(int i=0;i<e_cnt;i++)e[i].v=d[e[i].s]+e[i].v-d[e[i].t];\n\t}\n\treturn make_pair(flow,cost);\n}\nint x[85],y[85];long long v[85];\nint t[325],a[325],b[325];\nint L[85][2],R[85][2];\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d%d%lld\",&x[i],&y[i],&v[i]);\n\t}\n\tint m;\n\tscanf(\"%d\",&m);\n\tfor(int i=1;i<=m;i++){\n\t\tchar c=getchar();\n\t\twhile(c<'A'||c>'Z')c=getchar();\n\t\tif(c=='L')t[i]=0;\n\t\tif(c=='R')t[i]=1;\n\t\tif(c=='D')t[i]=2;\n\t\tif(c=='U')t[i]=3;\n\t\tscanf(\"%d%d\",&a[i],&b[i]);\n\t}\n\tlong long ans=0;\n\tfor(int supy=1;supy<=n;supy++){\n\t\tmemset(R,63,sizeof(R));\n\t\tfor(int j=1;j<=m;j++)if(b[j]<supy){\n\t\t\tif(t[j]&1)R[supy-b[j]][t[j]>>1]=min(R[supy-b[j]][t[j]>>1],a[j]-1);\n\t\t\telse L[b[j]+1][t[j]>>1]=max(L[b[j]+1][t[j]>>1],a[j]+1);\n\t\t}\n\t\tfor(int i=2;i<=supy;i++)for(int j=0;j<2;j++)L[i][j]=max(L[i][j],L[i-1][j]);\n\t\tfor(int i=supy-1;i>0;i--)for(int j=0;j<2;j++)R[i][j]=min(R[i][j],R[i+1][j]);\n\t\t// for(int i=1;i<=supy;i++)printf(\"%d %d\\n\",L[i][0],R[i][0]);\n\t\t// for(int i=1;i<=supy;i++)printf(\"%d %d\\n\",L[i][1],R[i][1]);\n\t\tT=2*supy+2*n+1;\n\t\te_cnt=0;\n\t\tmemset(last,-1,sizeof(last));\n\t\tfor(int i=1;i<=supy;i++)addedge(S,i,1,0),addedge(i+supy,T,1,0);\n\t\tfor(int i=1;i<=n;i++)addedge(i+2*supy,i+n+2*supy,1,v[i]-1e15);\n\t\tfor(int i=1;i<=supy;i++)\n\t\t\tfor(int j=1;j<=n;j++)if(x[j]>=L[i][0]&&x[j]<=R[i][0])addedge(i,j+2*supy,1,0);\n\t\tfor(int i=1;i<=supy;i++)\n\t\t\tfor(int j=1;j<=n;j++)if(y[j]>=L[i][1]&&y[j]<=R[i][1])addedge(j+n+2*supy,i+supy,1,0);\n\t\tpair<int,long long>res=solve();\n\t\t// printf(\"%d %d %lld\\n\",supy,res.first,res.second);\n\t\tres.second+=supy*1e15;\n\t\tif(res.first==supy)ans=max(ans,res.second);\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct edge\n{\n\tint v,nxt,flow,w;\n}e[500050];\n\nint head[405],ecnt;\nlong long dep[405];\nbool inq[405];\nint n,m;\nint s,t;\nconst long long inf = 1e18;\n\nvoid adde(int u,int v,int fl,int w)\n{\n\te[ecnt].v = v;\n\te[ecnt].nxt = head[u];\n\te[ecnt].flow = fl;\n\te[ecnt].w = w;\n\thead[u] = ecnt ++;\n}\n\nvoid Adde(int u,int v,int fl,int w)\n{\n\tadde(u,v,fl,w);\n\tadde(v,u,0,-w);\n}\n\nbool spfa()\n{\n    deque<long long> que;\n   \tfor(int i = 0;i <= t; ++ i)\n   \t\tdep[i] = (1ll << 62);\n    memset(inq,0,sizeof(inq));\n    dep[t] = 0;\n    que.push_back(t);\n    while(!que.empty())\n    {\n        long long u = que.front();\n        que.pop_front();\n        for(long long i = head[u];~i;i = e[i].nxt)\n        {\n            long long v = e[i].v;\n            if(e[i ^ 1].flow && dep[u] - e[i].w < dep[v])\n            {\n                dep[v] = dep[u] + e[i ^ 1].w;\n                if(!inq[v])\n                {\n                    if(que.empty() || dep[v] < dep[que.front()])\n                        que.push_front(v);\n                    else\n                        que.push_back(v);\n                    inq[v] = true;\n                }\n            }\n        }\n        inq[u] = false;\n    }\n    return dep[s] < (1ll << 62);\n}\n\nint curedge[405];\nlong long ans;\nbool vis[405];\n\nlong long dfs(long long s,long long t,long long flow)\n{\n    if(s == t)\n        return flow;\n    long long delta = flow;\n    vis[s] = true;\n    for(long long i = head[s];~i;i = e[i].nxt)\n    {\n        long long v = e[i].v;\n        if(!vis[v] && dep[v] == dep[s] - e[i].w && e[i].flow)\n        {\n            //prlong longf(\"%d %d\\n\",s,v);\n            long long g = dfs(v,t,min((long long)e[i].flow,delta));\n            delta -= g;\n            ans += g * e[i].w;\n            e[i].flow -= g;\n            e[i ^ 1].flow += g;\n            if(!delta)\n                return flow;\n        }\n    }\n    return flow - delta;\n}\n\nlong long dinic()\n{\n    long long anss = 0;\n    while(spfa())\n    {\n    \tvis[t] = 1;\n    \twhile(vis[t])\n    \t{\n        \tmemset(vis,0,sizeof(vis));\n        \tanss += dfs(s,t,inf);\n        }\n    }\n    return anss;\n}\n\nint pre[405];\n\nstruct stone\n{\n\tint x,y,vl;\n}st[105];\n\nstruct Limitation\n{\n\tint a,b;\n}L[105],R[105],D[105],U[105];\nint lc,rc,dc,uc;\nint xl[105],xr[105],yl[105],yr[105];\n\nint main()\n{\n\tint n; scanf(\"%d\",&n);\n\tfor(int i = 1;i <= n; ++ i)\n\t\tscanf(\"%d%d%d\",&st[i].x,&st[i].y,&st[i].vl);\n\tint m; scanf(\"%d\",&m);\n\tfor(int i = 1;i <= m; ++ i)\n\t{\n\t\tchar str[16]; scanf(\"%s\",str + 1);\n\t\tif(str[1] == 'L') lc ++,scanf(\"%d%d\",&L[lc].a,&L[lc].b);\n\t\telse if(str[1] == 'R') rc ++,scanf(\"%d%d\",&R[rc].a,&R[rc].b);\n\t\telse if(str[1] == 'U') uc ++,scanf(\"%d%d\",&U[uc].a,&U[uc].b);\n\t\telse dc ++,scanf(\"%d%d\",&D[dc].a,&D[dc].b);\n\t}\n\tlong long as = 0;\n\tfor(int k = 1;k <= n; ++ k)\n\t{\n\t\tmemset(head,-1,sizeof(head));\n\t\tecnt = 0;\n\t\tans = 0;\n\t\ts = 0,t = k * 2 + n * 2 + 1;\n\t\tfor(int i = 1;i <= k; ++ i)\n\t\t\tAdde(s,i,1,0),\n\t\t\tAdde(i + 2 * n + k,t,1,0),\n\t\t\txl[i] = yl[i] = 0,xr[i] = yr[i] = 100;\n\t\tfor(int i = 1;i <= lc; ++ i)\n\t\t\tfor(int j = L[i].b + 1;j <= k; ++ j)\n\t\t\t\txl[j] = max(xl[j],L[i].a + 1);\n\t\tfor(int i = 1;i <= rc; ++ i)\n\t\t\tfor(int j = k - R[i].b;j >= 1; -- j)\n\t\t\t\txr[j] = min(xr[j],R[i].a - 1);\n\t\tfor(int i = 1;i <= dc; ++ i)\n\t\t\tfor(int j = D[i].b + 1;j <= k; ++ j)\n\t\t\t\tyl[j] = max(yl[j],D[i].a + 1);\n\t\tfor(int i = 1;i <= uc; ++ i)\n\t\t\tfor(int j = k - U[i].b;j >= 1; -- j)\n\t\t\t\tyr[j] = min(yr[j],U[i].a - 1);\n\t\tfor(int i = 1;i <= n; ++ i)\n\t\t{\n\t\t\tAdde(i + k,i + n + k,1,-st[i].vl);\n\t\t\tfor(int j = 1;j <= k; ++ j)\n\t\t\t{\n\t\t\t\tif(yl[j] <= st[i].y && st[i].y <= yr[j])\n\t\t\t\t\tAdde(i + n + k,j + 2 * n + k,1,0);\n\t\t\t\tif(xl[j] <= st[i].x && st[i].x <= xr[j])\n\t\t\t\t\tAdde(j,i + k,1,0);\n\t\t\t}\n\t\t}\n\t\tdinic(); as = max(as,-ans);\n\t}\n\tprintf(\"%lld\\n\",as);\n}"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#define foreach(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\n#ifndef LOCAL\n#define cerr if(0)cout\n#endif\ntypedef long long ll;\nconst int mod = 1e9+7;\n//My i/o stream\nstruct fastio\n{\n\tchar s[100000];\n\tint it, len;\n\tfastio() {it=len=0;}\n\tinline char get()\n\t{\n\t\tif (it<len) return s[it++]; it=0;\n\t\tlen=fread(s, 1, 100000, stdin);\n\t\tif (len==0) return EOF; else return s[it++];\n\t}\n\tbool notend()\n\t{\n\t\tchar c=get();\n\t\twhile (c==' '||c=='\\n') c=get();\n\t\tif (it>0) it--;\n\t\treturn c!=EOF;\n\t}\n}_buff;\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putchar(' ')\n#define putii(x,y) puti(x),puti(y)\n#define putiii(x,y,z) putii(x,y),puti(z)\n#define putsi(x) putnum(x),putchar('\\n')\n#define putsii(x,y) puti(x),putsi(y)\n#define putsiii(x,y,z) putii(x,y),putsi(z)\ninline ll getnum()\n{\n\tll r=0; bool ng=0; char c; c=_buff.get();\n\twhile (c!='-'&&(c<'0'||c>'9')) c=_buff.get();\n\tif (c=='-') ng=1, c=_buff.get();\n\twhile (c>='0'&&c<='9') r=r*10+c-'0', c=_buff.get();\n\treturn ng?-r:r;\n}\ntemplate <class T> inline void putnum(T x)\n{\n\tif (x<0) putchar('-'), x=-x;\n\tregister short a[20]={}, sz=0;\n\twhile (x) a[sz++]=x%10, x/=10;\n\tif(sz==0) putchar('0');\n\tfor (int i=sz-1; i>=0; i--) putchar('0'+a[i]);\n}\ninline char getreal() {char c=_buff.get(); while (c<=32) c=_buff.get(); return c;}\nll qpow(ll x, ll k) {return k==0? 1: 1ll*qpow(1ll*x*x%mod,k>>1)*(k&1?x:1)%mod;}\nconst ll inf = 4e18;\nnamespace F\n{\n\tconst int maxn = 1011, maxe = 100011;\n\tint head[maxn], nxt[maxe], to[maxe], cap[maxe];\n\tll cost[maxe], tot;\n\tll ftot;\n\tvoid init()\n\t{\n\t\tftot = 0;\n\t\ttot = 1;\n\t\tmemset(head, 0, sizeof(head));\n\t}\n\tvoid add_edge(int x, int y, int c, ll w)\n\t{\n\t\tassert(x<maxn&&y<maxn);\n//\t\tcerr<<\"add_edge:\"<<x<<\",\"<<y<<\" \"<<c<<\" \"<<w<<endl;\n\t\tnxt[++tot] = head[x];\n\t\thead[x] = tot;\n\t\tto[tot] = y;\n\t\tcap[tot] = c;\n\t\tcost[tot] = w;\n\t\tswap(x, y);\n\t\tnxt[++tot] = head[x];\n\t\thead[x] = tot;\n\t\tto[tot] = y;\n\t\tcap[tot] = 0;\n\t\tcost[tot] = -w;\n\t\tassert(tot<maxe);\n\t}\n\tint q[maxn], qb, qe;\n\tll dis[maxn];\n\tbool inq[maxn];\n\tint qnxt(int x) {return (x+1)%maxn;}\n\tint qpre(int x) {return (x-1+maxn)%maxn;}\n\tvoid balance()\n\t{\n\t\tif (qb!=qe&&dis[q[qpre(qe)]]<dis[q[qb]])\n\t\t{\n\t\t\tswap(q[qpre(qe)], q[qb]);\n\t\t}\n\t}\n\tvoid spfa(int S, int N)\n\t{\n\t\tinq[S] = 1;\n\t\tfor (int i=0; i<=N; i++) dis[i] = inf;\n\t\tdis[S] = 0;\n\t\tqb = qe = 0;\n\t\tq[qe++] = S;\n\t\twhile (qb<qe)\n\t\t{\n\t\t\tint x = q[qb];\n\t\t\tinq[x] = 0;\n\t\t\tqb = qnxt(qb);\n\t\t\tbalance();\n\t\t\tfor (int i = head[x]; i; i=nxt[i])\n\t\t\t{\n\t\t\t\tif (cap[i]&&dis[to[i]]>dis[x]+cost[i])\n\t\t\t\t{\n\t\t\t\t\tdis[to[i]] = dis[x]+cost[i];\n\t\t\t\t\tif (!inq[to[i]])\n\t\t\t\t\t{\n\t\t\t\t\t\tinq[to[i]] = 1;\n\t\t\t\t\t\tq[qe] = to[i];\n\t\t\t\t\t\tqe = qnxt(qe);\n\t\t\t\t\t\tbalance();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tfor (int i=1; i<=N; i++) cerr<<dis[i]<<\" \"; cerr<<endl;\n\t}\n\t\n\tbool vis[maxn];\n\tint dfs(int x, int T, int f)\n\t{\n\t\tif (x==T) return f;\n\t\tvis[x] = 1;\n\t\tint of = f;\n\t\tfor (int i=head[x]; i; i=nxt[i])\n\t\t{\n\t\t\tif (!vis[to[i]]&&cap[i]&&dis[to[i]]==dis[x]+cost[i])\n\t\t\t{\n\t\t\t\tint u = to[i];\n\t\t\t\tint d = dfs(u, T, min(f, cap[i]));\n\t\t\t\tcap[i] -= d;\n\t\t\t\tcap[i^1] += d;\n\t\t\t\tf -= d;\n\t\t\t\tif (!f) return of;\n\t\t\t}\n\t\t}\n\t\treturn of-f;\n\t}\n\tll min_cost_max_flow(int S, int T, int K)\n\t{\n\t\tll ans = 0;\n\t\twhile (true)\n\t\t{\n\t\t\tspfa(S, T);\n\t\t\tif (dis[T]>=inf) return ans;\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\tmemset(vis, 0, sizeof(vis));\n\t\t\t\tint f = dfs(S, T, K);\n\t\t\t\tftot += f;\n\t\t\t\tans += 1ll*f*dis[T];\n\t\t\t\tif (f==0) break;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n};\nint n;\nint tid[256];\npair<int,int> a[88];\nll w[88];\nvector<pair<int,int> > M[4];\npair<int,int> segx[88], segy[88];\nll solve(int K)\n{\n//\tcerr<<\"solve: \"<<K<<endl;\n\tfor (int i=1; i<=K; i++) segx[i] = segy[i] = MP(0, 100);\n\tfor (auto x : M[0])\n\t{\n\t\tfor (int i=x.SS+1; i<=K; i++)\n\t\t{\n\t\t\tsegx[i].FF = max(segx[i].FF, x.FF+1);\n\t\t}\n\t}\n\tfor (auto x : M[1])\n\t{\n\t\tfor (int i=K-x.SS; i>=1; i--)\n\t\t{\n\t\t\tsegx[i].SS = min(segx[i].SS, x.FF-1);\n\t\t}\n\t}\n\tfor (auto x : M[2])\n\t{\n\t\tfor (int i=x.SS+1; i<=K; i++)\n\t\t{\n\t\t\tsegy[i].FF = max(segy[i].FF, x.FF+1);\n\t\t}\n\t}\n\tfor (auto x : M[3])\n\t{\n\t\tfor (int i=K-x.SS; i>=1; i--)\n\t\t{\n\t\t\tsegy[i].SS = min(segy[i].SS, x.FF-1);\n\t\t}\n\t}\n\tint S = 2*K+2*n+1, T = S+1;\n\tF::init();\n\tfor (int i=1; i<=K; i++)\n\t{\n\t\tF::add_edge(S, i, 1, 0);\n\t\tF::add_edge(i+K, T, 1, 0);\n\t\tfor (int j=1; j<=n; j++)\n\t\t{\n\t\t\tif (segx[i].FF<=a[j].FF&&a[j].FF<=segx[i].SS)\n\t\t\t{\n\t\t\t\tF::add_edge(i, j+2*K, 1, 0);\n\t\t\t}\n\t\t\tif (segy[i].FF<=a[j].SS&&a[j].SS<=segy[i].SS)\n\t\t\t{\n\t\t\t\tF::add_edge(j+2*K+n, i+K, 1, 0);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1; i<=n; i++) F::add_edge(i+2*K, i+2*K+n, 1, -w[i]);\n\tll ans = F::min_cost_max_flow(S, T, K);\n//\tcerr<<\"F::ftot=\"<<F::ftot<<endl;\n\tif (F::ftot<K) return 0;\n//\tcerr<<\"ans=\"<<ans<<endl;\n\treturn -ans;\n}\nint main()\n{\n\ttid['L'] = 0;\n\ttid['R'] = 1;\n\ttid['D'] = 2;\n\ttid['U'] = 3;\n\tgeti(n);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tll x, y, v;\n\t\tgetiii(x, y, v);\n\t\ta[i] = MP(x, y);\n\t\tw[i] = v;\n\t}\n\tint m;\n\tgeti(m);\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\tchar t;\n\t\tint a, b;\n\t\tt = getreal();\n\t\tgetii(a, b);\n\t\tM[tid[t]].PB(MP(a, b));\n\t}\n\tll ans = 0;\n\tfor (int K=1; K<=n; K++)\n\t{\n\t\tans = max(ans, solve(K));\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<queue>\n#define MAXN 80\n#define MAXM 320\n#define MAXNODE 500\n#define MAXEDGE MAXNODE*MAXNODE\n#define INF 0x3FFFFFFF\n#define INF2 1000000000000000000LL\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,LL> PII;\nstruct Point\n{\n\tint x,y;\n\tLL V;\n}poi[MAXN+5];\nstruct Limit\n{\n\tint typ,a,b;\n}lim[MAXM+5];\nstruct edge\n{\n\tint to,cap;\n\tLL cost;\n\tedge *nxt,*bck;\n}edges[MAXEDGE*2+5];\nedge *ncnt,*Adj[MAXNODE+5],*Cur[MAXNODE+5];\nint n,m;\nint dn[MAXN+5],up[MAXN+5];\nLL dist[MAXNODE+5];\nbool vis[MAXNODE+5];\nvoid Init()\n{\n\tncnt=&edges[0];\n\tmemset(Adj,0,sizeof(Adj));\n}\nvoid AddEdge(int u,int v,int cap,LL cost)\n{\n\tedge *p=++ncnt;\n\tp->to=v;p->cap=cap;p->cost=cost;\n\tp->nxt=Adj[u];Adj[u]=p;\n\t\n\tedge *q=++ncnt;\n\tq->to=u;q->cap=0;q->cost=-cost;\n\tq->nxt=Adj[v];Adj[v]=q;\n\t\n\tp->bck=q,q->bck=p;\n}\nbool SPFA(int S,int T,int nds)\n{\n\tstatic queue<int> que;\n\twhile(que.empty()==false)\tque.pop();\n\tfor(int i=S;i<=T;i++)\n\t\tvis[i]=false,dist[i]=-INF2;\n\tque.push(S);vis[S]=true;dist[S]=0;\n\twhile(que.empty()==false)\n\t{\n\t\tint u=que.front();\n\t\tque.pop();vis[u]=false;\n\t\tfor(edge *p=Adj[u];p!=NULL;p=p->nxt)\n\t\t{\n\t\t\tint v=p->to;\n\t\t\tif(p->cap&&dist[v]<dist[u]+p->cost)\n\t\t\t{\n\t\t\t\tdist[v]=dist[u]+p->cost;\n\t\t\t\tif(vis[v]==false)\n\t\t\t\t\tvis[v]=true,que.push(v);\n\t\t\t}\n\t\t}\n\t}\n\tif(dist[T]==-INF2)\n\t\treturn false;\n\treturn true;\n}\nint Aug(int T,int u,int tot,LL &ans)\n{\n\tif(u==T)\n\t\treturn tot;\n\tvis[u]=true;\n\tint sum=0,delta;\n\tfor(edge *&p=Cur[u];p!=NULL;p=p->nxt)\n\t{\n\t\tint v=p->to;\n\t\tif(!vis[v]&&p->cap&&dist[u]+p->cost==dist[v])\n\t\t{\n\t\t\tdelta=min(p->cap,tot-sum);\n\t\t\tdelta=Aug(T,v,delta,ans);\n\t\t\tsum+=delta;\n\t\t\tp->cap-=delta,p->bck->cap+=delta;\n\t\t\tans+=1LL*delta*p->cost;\n\t\t\tif(tot==sum)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tvis[u]=false;\n\treturn sum;\n}\nPII Max_Cost_Flow(int S,int T,int nds)\n{\n\tPII ret=PII(0,0);\n\tint tmn=0;\n\twhile(SPFA(S,T,nds))\n\t{\n\t\tfor(int i=S;i<=T;i++)\n\t\t\tCur[i]=Adj[i],vis[i]=false;\n\t\tret.first+=Aug(T,S,INF,ret.second);\n\t\ttmn++;\n\t}\n\treturn ret;\n}\nvoid DeBug(int S,int T)\n{\n\tprintf(\"===========BEGIN============\\n\");\n\tfor(int i=S;i<=T;i++)\n\t{\n\t\tprintf(\"%d:\",i);\n\t\tfor(edge *p=Adj[i];p!=NULL;p=p->nxt)\n\t\t\tif(p->cap)\n\t\t\t\tprintf(\"(%d %d %lld) \",p->to,p->cap,p->cost);\n\t\tprintf(\"\\n\");\n\t}\n\tprintf(\"============END=============\\n\");\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d %d %lld\",&poi[i].x,&poi[i].y,&poi[i].V);\n\tscanf(\"%d\",&m);\n\tchar opt[10];\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%s %d %d\",opt,&lim[i].a,&lim[i].b);\n\t\tif(opt[0]=='L')\tlim[i].typ=1;\n\t\tif(opt[0]=='R')\tlim[i].typ=2;\n\t\tif(opt[0]=='D')\tlim[i].typ=3;\n\t\tif(opt[0]=='U')\tlim[i].typ=4;\n\t}\n\tLL ans=0;\n\tfor(int tot=1;tot<=n;tot++)\n\t{\n\t\tInit();\n\t\tint nds=tot*2+200+2;\n\t\tint S=0,T=nds-1;\n\t\tfor(int i=1;i<=tot;i++)\n\t\t\tAddEdge(S,i,1,0),AddEdge(i+tot+200,T,1,0);\n\t\t//对于x这一维建边 \n\t\tfor(int i=1;i<=tot;i++)\n\t\t\tdn[i]=1,up[i]=100;\n\t\tfor(int i=1;i<=m;i++)\n\t\t\tif(lim[i].typ==1&&lim[i].b+1<=tot)\n\t\t\t\tdn[lim[i].b+1]=max(dn[lim[i].b+1],lim[i].a+1);\n\t\t\telse if(lim[i].typ==2&&tot-lim[i].b>=1)\n\t\t\t\tup[tot-lim[i].b]=min(up[tot-lim[i].b],lim[i].a-1);\n\t\tfor(int i=2;i<=tot;i++)\n\t\t\tdn[i]=max(dn[i-1],dn[i]);\n\t\tfor(int i=tot-1;i>=1;i--)\n\t\t\tup[i]=min(up[i+1],up[i]);\n\t\tfor(int i=1;i<=tot;i++)\n\t\t\tfor(int j=dn[i];j<=up[i];j++)\n\t\t\t\tAddEdge(i,tot+j,MAXN,0);\n\t\t//对于y这一维建边\n\t\tfor(int i=1;i<=tot;i++)\n\t\t\tdn[i]=1,up[i]=100;\n\t\tfor(int i=1;i<=m;i++)\n\t\t\tif(lim[i].typ==3&&lim[i].b+1<=tot)\n\t\t\t\tdn[lim[i].b+1]=max(dn[lim[i].b+1],lim[i].a+1);\n\t\t\telse if(lim[i].typ==4&&tot-lim[i].b>=1)\n\t\t\t\tup[tot-lim[i].b]=min(up[tot-lim[i].b],lim[i].a-1);\n\t\tfor(int i=2;i<=tot;i++)\n\t\t\tdn[i]=max(dn[i-1],dn[i]);\n\t\tfor(int i=tot-1;i>=1;i--)\n\t\t\tup[i]=min(up[i+1],up[i]);\n\t\tfor(int i=1;i<=tot;i++)\n\t\t\tfor(int j=dn[i];j<=up[i];j++)\n\t\t\t\tAddEdge(j+100+tot,i+200+tot,MAXN,0);\n\t\t//对于每一个点建边\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tAddEdge(tot+poi[i].x,100+tot+poi[i].y,1,poi[i].V);\n\t\tPII ret=Max_Cost_Flow(S,T,nds);\n\t\tif(ret.first==tot)\n\t\t\tans=max(ans,ret.second);\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n#define LL long long\n#define fgx cerr<<\"--------------\"<<endl;\n#define dgx cerr<<\"==============\"<<endl;\n\ninline LL read(){\n\tLL x=0,f=1; char c=getchar();\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0';\n\treturn x*f;\n}\nconst LL MAXN = 500010;\nconst LL INF = 1000000000;\n\nLL N; LL d[2][MAXN+1],V[MAXN+1];\nLL Cost[MAXN+1]; LL Node[MAXN+1],Next[MAXN+1],C[MAXN+1],Root[MAXN+1];\nLL cnt; LL S,T;\ninline void addedge(LL u,LL v,LL c,LL w){ Cost[cnt]=w; C[cnt]=c; Node[cnt]=v; Next[cnt]=Root[u]; Root[u]=cnt++; }\ninline void insert(LL u,LL v,LL c,LL w){ w=-w; addedge(u,v,c,w); addedge(v,u,0,-w); return ; }\nLL dis[MAXN+1]; bool inq[MAXN+1];\nLL ans,ret;\ninline bool BFS(){\n\tmemset(inq,false,sizeof(inq));\n\tdeque<LL> que; for(LL i=0;i<=T;i++) dis[i]=INF;\n\tdis[T]=0; que.push_back(T); inq[T]=true;\n\twhile(!que.empty()){\n\t    LL k=que.front(); que.pop_front();\n\t\tfor(LL x=Root[k];x!=-1;x=Next[x]){\n\t\t    LL v=Node[x];\n\t\t    if(C[x^1]>0&&dis[v]>dis[k]-Cost[x]){\n\t\t        dis[v]=dis[k]-Cost[x];\n\t\t\t\tif(!inq[v]){\n\t\t\t\t\tinq[v]=true;\n\t\t\t\t    if(que.empty()||dis[v]<=dis[que.front()]) que.push_front(v);\n\t\t\t\t    else que.push_back(v);\n\t\t\t    }\n\t\t    }\n\t    }inq[k]=false;\n\t} return dis[S]<INF;\n} LL fans;\ninline LL DFS(LL k,LL t){\n    if(k==T) {inq[k]=1;return t;} \n\tinq[k]=1; LL res=0;\n\tfor(LL x=Root[k];x!=-1;x=Next[x]){\n\t    LL v=Node[x];\n\t    if(C[x]>0&&!inq[v]&&dis[v]==dis[k]-Cost[x]){\n\t        LL tmp=DFS(v,min(t,C[x]));\n\t\t\tif(!tmp) continue; C[x]-=tmp; C[x^1]+=tmp;\n\t\t\tres+=tmp; t-=tmp; fans+=(LL)tmp*Cost[x]; if(!t) return res;\t\n\t    }\n    } return res;\n}\n#define fr first\n#define sc second\ninline void Max(LL &a,LL b){ a=max(a,b); }\ninline void Min(LL &a,LL b){ a=min(a,b); }\nLL L[2][MAXN+1],R[2][MAXN+1];\nLL M; char ch[5];\nvector<pair<LL,LL> > vec[4];\ninline void check(LL K){\n\tfor(LL i=0;i<=100;i++) L[0][i]=L[1][i]=1,R[0][i]=R[1][i]=100; cnt=0;\n\tfor(LL i=0;i<=N*2+2*K+1;i++) Root[i]=-1;\n\tfor(LL i=0,l=vec[0].size();i<l;i++) Max(L[0][vec[0][i].fr+1],vec[0][i].sc+1);\n\tfor(LL i=0,l=vec[1].size();i<l;i++) if(vec[1][i].fr<K) Min(R[0][K-vec[1][i].fr],vec[1][i].sc-1);\n\tfor(LL i=0,l=vec[2].size();i<l;i++) Max(L[1][vec[2][i].fr+1],vec[2][i].sc+1);\n\tfor(LL i=0,l=vec[3].size();i<l;i++) if(vec[3][i].fr<K) Min(R[1][K-vec[3][i].fr],vec[3][i].sc-1);\n\tS=0,T=N*2+K*2+1; for(LL i=1;i<=N;i++) insert(i,N+i,1,V[i]);\n\tfor(LL i=0;i<2;i++){\n\t\tfor(LL j=1;j<=100;j++) L[i][j]=max(L[i][j],L[i][j-1]);\n\t\tfor(LL j=99;j>=0;j--) R[i][j]=min(R[i][j],R[i][j+1]);\n\t\tfor(LL j=1;j<=K;j++){\n\t\t\tif(!i) insert(S,N*2+j,1,0);\n\t\t\telse insert(N*2+K+j,T,1,0);\n\t\t\tfor(LL k=1;k<=N;k++){\n\t\t\t\tif(d[i][k]>=L[i][j]&&d[i][k]<=R[i][j]){\n\t\t\t\t\tif(!i) insert(N*2+j,k,1,0);\n\t\t\t\t\telse insert(N+k,N*2+K+j,1,0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} fans=0;\n\tret=0; while(BFS()) ret+=DFS(S,INF);\n\tans=max(ans,-fans); return ; \n}\n\nint main(){\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tN=read();\n\tmemset(Root,-1,sizeof(Root));\n\tfor(LL i=1;i<=N;i++){\n\t\td[0][i]=read(),d[1][i]=read(),V[i]=read();\n\t} M=read();\n\tfor(LL i=1;i<=M;i++){\n\t\tscanf(\"%s\",ch+1); LL a=read(),b=read();\n\t\tLL opr; if(ch[1]=='L') opr=0;\n\t\telse if(ch[1]=='R') opr=1;\n\t\telse if(ch[1]=='U') opr=3;\n\t\telse opr=2; vec[opr].push_back(make_pair(b,a));\n\t}\n\tfor(LL i=0;i<4;i++) sort(vec[i].begin(),vec[i].end());\n\tfor(LL K=1;K<=N;K++) check(K);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 1000\n#define M 1000\n#define V 1000\n#define E 10000\n#define INF 1000000000000000000LL\nusing namespace std;\nint n;\nstruct jewel{int x,y;long long v;}J[N];\nstruct table{\n    int n,a[N];\n    void add(int x){a[++n]=x;}\n    void su(){sort(a+1,a+n+1);n=unique(a+1,a+n+1)-a-1;}\n    int lst(int x){return upper_bound(a+1,a+n+1,x)-a-1;}\n    int nxt(int x){return lower_bound(a+1,a+n+1,x)-a;}\n}X,Y;\nint m;\nstruct cond{char t;int a,b;}C[M];\nint e,head[V],nxt[E],to[E],cap[E],op[E];\nlong long val[E];\nvoid add(int x,int y,int c,long long v){\n    nxt[++e]=head[x],to[head[x]=e]=y,cap[e]=c,val[e]=v,op[e]=e+1;\n    nxt[++e]=head[y],to[head[y]=e]=x,cap[e]=0,val[e]=-v,op[e]=e-1;\n}\nint S,T,from[V],from_edge[V];\nlong long f[V];\nbool vis[V];\nqueue <int> q;\nlong long spfa(){\n    for(int i=0;i<=X.n+Y.n+3;++i)f[i]=-INF*2;\n    f[S]=0,vis[S]=1,q.push(S);\n    while(!q.empty()){\n        int x=q.front();\n        vis[x]=0,q.pop();\n        for(int i=head[x];i;i=nxt[i])\n            if(cap[i] && f[x]+val[i]>f[to[i]]){\n\t\t    \tf[to[i]]=f[x]+val[i];\n\t\t\t\tfrom[to[i]]=x,from_edge[to[i]]=i;\n\t\t    \tif(!vis[to[i]])vis[to[i]]=1,q.push(to[i]);\n\t\t    }\n    }\n    return f[T];\n}\nint flow;\nlong long cost;\nvoid augment(){\n    int delta=N;\n    for(int i=T;i!=S;i=from[i])delta=min(delta,cap[from_edge[i]]);\n    flow+=delta;\n    for(int i=T;i!=S;i=from[i]){\n\t\tcap[from_edge[i]]-=delta;\n        cap[op[from_edge[i]]]+=delta;\n        if(val[from_edge[i]]==-INF)continue;\n\t\tcost+=val[from_edge[i]]*delta;\n    }\n}\nint R_min[N],R_max[N],U_min[N],U_max[N];\nint in[V];\nlong long solve(int k){\n    int s=0,t=X.n+1,ss=X.n+Y.n+2,tt=X.n+Y.n+3;\n    e=0;for(int i=0;i<=X.n+Y.n+3;++i)head[i]=0;\n    for(int i=1;i<=X.n+1;++i)R_min[i]=0,R_max[i]=N;\n    for(int i=1;i<=Y.n+1;++i)U_min[i]=0,U_max[i]=N;\n    R_max[X.n+1]=U_max[Y.n+1]=0;\n    R_min[1]=R_max[1]=k;\n    for(int i=1;i<=m;++i)\n        if(C[i].t=='L')R_min[C[i].a+1]=max(R_min[C[i].a+1],k-C[i].b);\n        else if(C[i].t=='R')R_max[C[i].a]=min(R_max[C[i].a],C[i].b);\n        else if(C[i].t=='D')U_min[C[i].a+1]=max(U_min[C[i].a+1],k-C[i].b);\n        else U_max[C[i].a]=min(U_max[C[i].a],C[i].b);\n    for(int i=1;i<=X.n+1;++i)\n        if(R_min[i]>R_max[i])return 0;\n    for(int i=1;i<=Y.n+1;++i)\n        if(U_min[i]>U_max[i])return 0;\n    for(int i=0;i<=X.n+Y.n+1;++i)in[i]=0;\n    for(int i=1;i<=X.n;++i){\n        add(i-1,i,R_max[i]-R_min[i],0);\n        in[i]+=R_min[i],in[i-1]-=R_min[i];\n    }\n    for(int i=1;i<=n;++i)add(X.nxt(J[i].x),t+Y.nxt(J[i].y),1,J[i].v);\n    for(int i=1;i<=Y.n;++i){\n        add(t+i,t+i-1,U_max[i]-U_min[i],0);\n        in[t+i]-=U_min[i],in[t+i-1]+=U_min[i];\n    }\n    int total=0;\n    for(int i=0;i<=X.n+Y.n+1;++i)\n        if(in[i]>0)total+=in[i],add(ss,i,in[i],0);\n        else if(in[i]<0)add(i,tt,-in[i],0);\n    add(t,s,N,-INF);\n    S=ss,T=tt,flow=0,cost=0;\n    while(spfa()>-INF*2)augment();\n    if(flow<total)return 0;\n    S=s,T=t;\n    head[s]=nxt[head[s]];\n    head[e]=nxt[head[t]];\n    while(spfa()>0)augment();\n    return cost;\n}\nint main(){\n    cin>>n;\n    X.n=Y.n=0;\n    X.add(0),Y.add(0);\n    X.add(101),Y.add(101);\n    for(int i=1;i<=n;++i){\n        cin>>J[i].x>>J[i].y>>J[i].v;\n        X.add(J[i].x),Y.add(J[i].y);\n    }\n    X.su(),Y.su();\n    cin>>m;\n    for(int i=1;i<=m;++i){\n        char ch=getchar();\n        while(ch!='L' && ch!='R' && ch!='D' && ch!='U')ch=getchar();\n        C[i].t=ch;\n        cin>>C[i].a>>C[i].b;\n        if(ch=='L')C[i].a=X.lst(C[i].a);\n        else if(ch=='R')C[i].a=X.nxt(C[i].a);\n        else if(ch=='D')C[i].a=Y.lst(C[i].a);\n        else C[i].a=Y.nxt(C[i].a);\n    }\n    long long ans=0;\n    for(int i=1;i<=n;++i)ans=max(ans,solve(i));\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <iostream>\n#include <queue>\n\n#define DEBUG() std::cerr << __FUNCTION__ << \" \" << __LINE__ << std::endl\n\nusing i64 = long long;\n\nnamespace flw {\n\tconst int N = 5000 + 7, M = 5000000 + 7;\n\tconst int INF = 1 << 28;\n\tstruct flow {\n\t\tint n, st, ed;\n\t\tint vis[N];\n\t\ti64 dis[N];\n\t\tstruct edge {\n\t\t\tint to, nex, cap; i64 wei;\n\t\t} e[M];\n\t\tint fir[N], cur[N], eid;\n\t\tint maxflow;\n\t\ti64 mincost;\n\n\t\tvoid init() {\n\t\t\teid = 1;\n\t\t\tstd::fill(fir + 1, fir + n + 1, 0);\n\t\t\tst = ed = n = 0;\n\t\t}\n\t\tvoid addedge(int u, int v, int c, i64 w) {\n\t\t\te[++eid] = (edge){ v, fir[u], c, w }, fir[u] = eid;\n\t\t}\n\t\tvoid addflow(int u, int v, int c, i64 w) {\n\t\t\taddedge(u, v, c, w), addedge(v, u, 0, -w);\n\t\t}\n\t\tvoid dinic() {\n\t\t\tmaxflow = mincost = 0;\n\t\t\tint f;\n\t\t\twhile (bfs())\n\t\t\t\twhile (f = dfs(st, INF)) maxflow += f, mincost += f * dis[st];\n\t\t}\n\t\tint bfs() {\n\t\t\tstd::fill(dis + 1, dis + n + 1, 1ll << 60),\n\t\t\tstd::fill(vis + 1, vis + n + 1, 0);\n\t\t\tstd::copy(fir + 1, fir + n + 1, cur + 1);\n\t\t\tstatic std::queue<int> q;\n\t\t\tdis[ed] = 0, vis[ed] = 1, q.push(ed);\n\t\t\tfor (int s; q.size(); ) {\n\t\t\t\ts = q.front(), q.pop();\n\t\t\t\tfor (int i = fir[s]; i; i = e[i].nex)\n\t\t\t\t\tif (e[i ^ 1].cap && dis[e[i].to] > dis[s] - e[i].wei) {\n\t\t\t\t\t\tdis[e[i].to] = dis[s] - e[i].wei;\n\t\t\t\t\t\tif (!vis[e[i].to])\n\t\t\t\t\t\t\tvis[e[i].to] = 1, q.push(e[i].to);\n\t\t\t\t\t}\n\t\t\t\tvis[s] = 0;\n\t\t\t}\n\t\t\treturn dis[st] < 1ll << 60;\n\t\t}\n\t\ti64 dfs(int s, int f) {\n\t\t\tif (s == ed) return f;\n\t\t\tvis[s] = 1;\n\t\t\tint u = 0, t;\n\t\t\tfor (int& i = cur[s]; i; i = e[i].nex) {\n\t\t\t\tif (!e[i].cap || vis[e[i].to] || dis[s] != dis[e[i].to] + e[i].wei) continue;\n\t\t\t\tt = dfs(e[i].to, std::min(f - u, e[i].cap));\n\t\t\t\te[i].cap -= t, e[i ^ 1].cap += t, u += t;\n\t\t\t\tif (f == u) break;\n\t\t\t}\n\t\t\treturn vis[s] = 0, u;\n\t\t}\n\t};\n}\n\nconst int X = 100 + 7, N = 80 + 7, M = 320 + 7;\n\nint n, m;\nint u[N], v[N];\ni64 w[N];\nint x[M], y[M], z[M];\nint llm[N], rlm[N], dlm[N], ulm[N];\nflw::flow f;\ni64 ans;\n\nint main() {\n//\tfreopen(\"code.in\", \"r\", stdin);\n//\tfreopen(\"code.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i)\n\t\tscanf(\"%d%d%lld\", u + i, v + i, w + i);\n\tscanf(\"%d\", &m);\n\tfor (int i = 1; i <= m; ++i) {\n\t\tchar c[3];\n\t\tscanf(\"%s%d%d\", c, x + i, y + i);\n\t\tif (y[i] >= n) { --i; --m; continue; }\n\t\tz[i] = c[0];\n\t}\n\n\tfor (int k = 1; k <= n; ++k) {\n\t\tf.init();\n\t\tf.st = 2 * (n + k) + 1, f.ed = f.n = f.st + 1;\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t\tf.addflow(i, n + i, 1, -w[i]);\n\t\tmemset(llm, 0, sizeof llm);\n\t\tmemset(dlm, 0, sizeof dlm);\n\t\tmemset(rlm, 0x3f, sizeof rlm);\n\t\tmemset(ulm, 0x3f, sizeof ulm);\n\t\tfor (int i = 1; i <= m; ++i) {\n\t\t\tif (y[i] >= k) continue;\n\t\t\tif (z[i] == 'L') llm[y[i] + 1] = std::max(llm[y[i] + 1], x[i] + 1);\n\t\t\tif (z[i] == 'R') rlm[k - y[i]] = std::min(rlm[k - y[i]], x[i] - 1);\n\t\t\tif (z[i] == 'D') dlm[y[i] + 1] = std::max(dlm[y[i] + 1], x[i] + 1);\n\t\t\tif (z[i] == 'U') ulm[k - y[i]] = std::min(ulm[k - y[i]], x[i] - 1);\n\t\t}\n\t\tfor (int i = 1; i <= k; ++i)\n\t\t\tllm[i] = std::max(llm[i], llm[i - 1]),\n\t\t\tdlm[i] = std::max(dlm[i], dlm[i - 1]);\n\t\tfor (int i = k; i; --i)\n\t\t\trlm[i] = std::min(rlm[i], rlm[i + 1]),\n\t\t\tulm[i] = std::min(ulm[i], ulm[i + 1]);\n\t\tfor (int i = 1; i <= k; ++i) {\n\t\t\tf.addflow(f.st, 2 * n + i, 1, 0);\n\t\t\tf.addflow(2 * n + k + i, f.ed, 1, 0);\n\t\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\t\tif (llm[i] <= u[j] && u[j] <= rlm[i]) f.addflow(2 * n + i, j, 1, 0);\n\t\t\t\tif (dlm[i] <= v[j] && v[j] <= ulm[i]) f.addflow(n + j, 2 * n + k + i, 1, 0);\n\t\t\t}\n\t\t}\n\t\tf.dinic();\n\t\tif (f.maxflow == k) ans = std::max(ans, -f.mincost);\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ld double\n#define ull unsigned long long\n#define ll long long\n#define pii pair<int, int>\n#define iiii pair<int, pii>\n#define mp make_pair\n#define INF 1000000000\n#define MOD 1000000007\n#define rep(i, x) for(int (i) = 0; (i) < (x); (i)++)\ninline int getint() {\n\tint x = 0, p = 1; char c = getchar();\n\twhile (c <= 32) c = getchar();\n\tif (c == 45) p = -p, c = getchar();\n\twhile (c > 32) x = x * 10 + c - 48, c = getchar();\n\treturn x * p;\n}\nusing namespace std;\n//ruogu_alter\nconst int N = 405;\nconst int M = 85;\nconst int K = 325;\nconst int s = N - 1;\nconst int t = N - 2;\nconst int base0 = 100;\nconst int base1 = 200;\nconst ll inf = 2e18;\nll res;\nstruct edge {\n  int to, val;\n  ll cost;\n  int rev;\n};\nint flow[N], pre[N], pree[N];\nll dis[N];\nbool vis[N];\nvector<edge> g[N];\nint n, m;\nint px[M], py[M], lx[M], rx[M], ly[M], ry[M];\nll v[M];\nint a[K], b[K];\nchar op[K];\n//\ninline void addedge(int x, int y, int z, ll w) {\n  g[x].emplace_back((edge){y, z, w, (int)g[y].size()});\n  g[y].emplace_back((edge){x, 0, -w, (int)g[x].size() - 1});\n}\nbool spfa() {\n  int st = 0;\n  vector<int> qu; qu.emplace_back(s);\n  rep(i, N) dis[i] = inf, flow[i] = INF;\n  dis[s] = 0; vis[s] = true;\n  while (st < qu.size()) {\n    int u = qu[st++]; vis[u] = false;\n    rep(i, g[u].size()) {\n      edge &e = g[u][i];\n      if (e.val && dis[e.to] > dis[u] + e.cost) {\n        dis[e.to] = dis[u] + e.cost;\n        flow[e.to] = min(flow[u], e.val);\n        pre[e.to] = u;\n        pree[e.to] = i;\n        if (!vis[e.to]) {\n          vis[e.to] = true;\n          qu.emplace_back(e.to);\n        }\n      }\n    }\n  }\n  return dis[t] < inf;\n}\nll ek(int sum) {\n  int f = 0; ll c = 0;\n  while (spfa()) {\n    int x = t;\n    f += flow[t];\n    c += 1ll * flow[t] * dis[t];\n    while (x != s) {\n      int y = pre[x], z = pree[x];\n      g[y][z].val -= flow[t];\n      g[x][g[y][z].rev].val += flow[t];\n      x = y;\n    }\n  }\n  if (f != sum) return 1;\n  return c;\n} \nvoid solve(int sum) {\n  rep(i, sum) lx[i] = ly[i] = 1, rx[i] = ry[i] = 100;\n  rep(j, m) {\n    if (op[j] == 'L') for (int i = b[j]; i < sum; i++) lx[i] = max(lx[i], a[j] + 1);\n    if (op[j] == 'D') for (int i = b[j]; i < sum; i++) ly[i] = max(ly[i], a[j] + 1);\n    if (op[j] == 'R') rep(i, sum - b[j]) rx[i] = min(rx[i], a[j] - 1);\n    if (op[j] == 'U') rep(i, sum - b[j]) ry[i] = min(ry[i], a[j] - 1);\n  }\n  rep(i, n) --lx[i], --ly[i], --rx[i], --ry[i];\n  rep(i, n) if (lx[i] > rx[i] || ly[i] > ry[i]) return;\n  rep(i, N) g[i].clear();\n  rep(i, n) addedge(px[i], py[i] + base0, 1, -v[i]);\n  rep(i, sum) {\n    addedge(s, i + base1, 1, 0);\n    for (int j = lx[i]; j <= rx[i]; j++) addedge(i + base1, j, 1, 0);\n    for (int j = ly[i]; j <= ry[i]; j++) addedge(j + base0, i + base1 + sum, 1, 0);\n    addedge(i + base1 + sum, t, 1, 0);\n  }\n  ll ans = ek(sum); \n  if (ans <= 0) res = max(res, -ans);\n}\nint main() {\n\t//freopen(\".in\", \"r\", stdin);\n\t//freopen(\".out\", \"w\", stdout);\n\tn = getint(); \n  rep(i, n) {\n    px[i] = getint() - 1, py[i] = getint() - 1;\n    scanf(\"%lld\", v + i);\n  }\n  m = getint();\n  rep(i, m) {\n    cin >> op[i]; a[i] = getint(); b[i] = getint();\n  }\n  for (int sum = 1; sum <= n; sum++) {\n    solve(sum);\n  }\n  cout << res << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\nusing pi = pair<int, int>;\nconst int MAXN = 405;\nconst int MAXC = 100;\nconst int mod = 1e9 + 7;\n\nstruct dinic{\n\tstruct edg{ int pos, cap, rev; };\n\tvector<edg> gph[MAXN];\n\tvoid clear(){ for(int i=0; i<MAXN; i++) gph[i].clear(); }\n\tvoid add_edge(int s, int e, int x){\n\t\tgph[s].push_back({e, x, (int)gph[e].size()});\n\t\tgph[e].push_back({s, 0, (int)gph[s].size()-1});\n\t}\n\tint dis[MAXN], pnt[MAXN];\n\tbool bfs(int src, int sink){\n\t\tmemset(dis, 0, sizeof(dis));\n\t\tmemset(pnt, 0, sizeof(pnt));\n\t\tqueue<int> que;\n\t\tque.push(src);\n\t\tdis[src] = 1;\n\t\twhile(!que.empty()){\n\t\t\tint x = que.front();\n\t\t\tque.pop();\n\t\t\tfor(auto &e : gph[x]){\n\t\t\t\tif(e.cap > 0 && !dis[e.pos]){\n\t\t\t\t\tdis[e.pos] = dis[x] + 1;\n\t\t\t\t\tque.push(e.pos);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dis[sink] > 0;\n\t}\n\tint dfs(int x, int sink, int f){\n\t\tif(x == sink) return f;\n\t\tfor(; pnt[x] < gph[x].size(); pnt[x]++){\n\t\t\tedg e = gph[x][pnt[x]];\n\t\t\tif(e.cap > 0 && dis[e.pos] == dis[x] + 1){\n\t\t\t\tint w = dfs(e.pos, sink, min(f, e.cap));\n\t\t\t\tif(w){\n\t\t\t\t\tgph[x][pnt[x]].cap -= w;\n\t\t\t\t\tgph[e.pos][e.rev].cap += w;\n\t\t\t\t\treturn w;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tlint match(int src, int sink){\n\t\tlint ret = 0;\n\t\twhile(bfs(src, sink)){\n\t\t\tint r;\n\t\t\twhile((r = dfs(src, sink, 2e9))) ret += r;\n\t\t}\n\t\treturn ret;\n\t}\n}mf;\n\nstruct MCMF{\n\tstruct edg{ int pos, cap, rev; lint cost; };\n\tvector<edg> gph[MAXN];\n\tvoid clear(){\n\t\tfor(int i=0; i<MAXN; i++) gph[i].clear();\n\t}\n\tvoid add_edge(int s, int e, int x, lint c){\n\t\tgph[s].push_back({e, x, (int)gph[e].size(), c});\n\t\tgph[e].push_back({s, 0, (int)gph[s].size()-1, -c});\n\t}\n\tlint dist[MAXN];\n\tint pa[MAXN], pe[MAXN];\n\tbool inque[MAXN];\n\tbool spfa(int src, int sink){\n\t\tmemset(dist, 0x3f, sizeof(dist));\n\t\tmemset(inque, 0, sizeof(inque));\n\t\tqueue<int> que;\n\t\tdist[src] = 0;\n\t\tinque[src] = 1;\n\t\tque.push(src);\n\t\tbool ok = 0;\n\t\twhile(!que.empty()){\n\t\t\tint x = que.front();\n\t\t\tque.pop();\n\t\t\tif(x == sink) ok = 1;\n\t\t\tinque[x] = 0;\n\t\t\tfor(int i=0; i<gph[x].size(); i++){\n\t\t\t\tedg e = gph[x][i];\n\t\t\t\tif(e.cap > 0 && dist[e.pos] > dist[x] + e.cost){\n\t\t\t\t\tdist[e.pos] = dist[x] + e.cost;\n\t\t\t\t\tpa[e.pos] = x;\n\t\t\t\t\tpe[e.pos] = i;\n\t\t\t\t\tif(!inque[e.pos]){\n\t\t\t\t\t\tinque[e.pos] = 1;\n\t\t\t\t\t\tque.push(e.pos);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ok;\n\t}\n\tlint match(int src, int sink){\n\t\tlint ret = 0;\n\t\twhile(spfa(src, sink)){\n\t\t\tint cap = 1e9;\n\t\t\tfor(int pos = sink; pos != src; pos = pa[pos]){\n\t\t\t\tcap = min(cap, gph[pa[pos]][pe[pos]].cap);\n\t\t\t}\n\t\t\tret += dist[sink] * cap;\n\t\t\tfor(int pos = sink; pos != src; pos = pa[pos]){\n\t\t\t\tint rev = gph[pa[pos]][pe[pos]].rev;\n\t\t\t\tgph[pa[pos]][pe[pos]].cap -= cap;\n\t\t\t\tgph[pos][rev].cap += cap;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\tlint neomatch(int src, int sink){\n\t\tlint ret = 0;\n\t\twhile(spfa(src, sink)){\n\t\t\tint cap = 1e9;\n\t\t\tfor(int pos = sink; pos != src; pos = pa[pos]){\n\t\t\t\tcap = min(cap, gph[pa[pos]][pe[pos]].cap);\n\t\t\t}\n\t\t\tif(dist[sink] >= 0) break;\n\t\t\tret += dist[sink] * cap;\n\t\t\tfor(int pos = sink; pos != src; pos = pa[pos]){\n\t\t\t\tint rev = gph[pa[pos]][pe[pos]].rev;\n\t\t\t\tgph[pa[pos]][pe[pos]].cap -= cap;\n\t\t\t\tgph[pos][rev].cap += cap;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n}mcmf;\n\nstruct LRMCMF{\n\tlint lsum;\n\tvoid clear(){\n\t\tlsum = 0;\n\t\tmcmf.clear();\n\t\tmf.clear();\n\t}\n\tvoid add_edge(int s, int e, int l, int r, lint v){\n\t\tlsum += l;\n\t\tmf.add_edge(s + 2, e + 2, r - l);\n\t\tmf.add_edge(0, e + 2, l);\n\t\tmf.add_edge(s + 2, 1, l);\n\t\tmcmf.add_edge(s + 2, e + 2, r - l, v);\n\t\tmcmf.add_edge(0, e + 2, l, v);\n\t\tmcmf.add_edge(s + 2, 1, l, v);\n\t}\n\tlint solve(int s, int e){\n\t\tmf.add_edge(e+2, s+2, 1e9); // to reduce as maxflow with lower bounds, in circulation problem skip this line\n\t\tmcmf.add_edge(e + 2, s + 2, 1e9, 0);\n\t\tif(lsum == mf.match(0, 1)){\n\t\t\tlint ans = mcmf.match(0, 1);\n\t\t\tans += mcmf.neomatch(s + 2, e + 2);\n\t\t\treturn ans;\n\t\t}\n\t\treturn 0;\n\t\t// to get maximum LR flow, run maxflow from s+2 to e+2 again\n\t}\n}SOLVER;\n\nint n, m;\nlint A[MAXN][MAXN];\nchar buf[MAXN][5];\nint x[MAXN], y[MAXN];\npi bx[MAXN], by[MAXN];\n\nlint solve(int k){\n\tSOLVER.clear();\n\tfill(bx, bx + MAXN, pi(0, k));\n\tfill(by, by + MAXN, pi(0, k));\n\tbx[0] = by[0] = pi(0, 0);\n\tfor(int i=0; i<m; i++){\n\t\tif(*buf[i] == 'L'){\n\t\t\tbx[x[i]].second = min(bx[x[i]].second, y[i]);\n\t\t}\n\t\tif(*buf[i] == 'R'){\n\t\t\tbx[x[i] - 1].first = max(bx[x[i] - 1].first, k - y[i]);\n\t\t}\n\t\tif(*buf[i] == 'D'){\n\t\t\tby[x[i]].second = min(by[x[i]].second, y[i]);\n\t\t}\n\t\tif(*buf[i] == 'U'){\n\t\t\tby[x[i] - 1].first = max(by[x[i] - 1].first, k - y[i]);\n\t\t}\n\t}\n\tfor(int i=0; i<MAXN; i++){\n\t\tif(bx[i].second < bx[i].first) return 0;\n\t\tif(by[i].second < by[i].first) return 0;\n\t}\n\tSOLVER.add_edge(0, MAXC + 1, k, k, 0);\n\tSOLVER.add_edge(MAXC * 2 + 2, MAXC * 2 + 3, k, k, 0);\n\tfor(int i=MAXC; i>=1; i--){\n\t\tSOLVER.add_edge(i + 1, i, bx[i].first, bx[i].second, 0); \n\t\tSOLVER.add_edge(MAXC + i + 1, MAXC + i + 2, by[i].first, by[i].second, 0);\n\t}\n\tfor(int i=1; i<=MAXC; i++){\n\t\tfor(int j=1; j<=MAXC; j++){\n\t\t\tif(A[i][j]) SOLVER.add_edge(i, j + MAXC + 1, 0, 1, -A[i][j]);\n\t\t}\n\t}\n//\tcout << k << endl;\n\treturn -SOLVER.solve(0, 2 * MAXC + 3);\n}\n\n\nint main(){\n\tcin >> n;\n\tfor(int i=0; i<n; i++){\n\t\tint x, y; lint z;\n\t\tcin >> x >> y >> z;\n\t\tA[x][y] = z;\n\t}\n\tcin >> m;\n\tfor(int i=0; i<m; i++){\n\t\tcin >> buf[i] >> x[i] >> y[i];\n\t}\n\tlint ret = 0;\n\tfor(int i=1; i<=n; i++) ret = max(ret, solve(i));\n\tcout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * This line was copied from template\n * This is esol.cpp\n * \n * @author: Nikolay Kalinin\n * @date: Sat, 16 Mar 2019 16:20:18 +0300\n */\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n    #define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing D = double;\nusing uint = unsigned int;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nconst int maxn = 505;\nconst ll inf = 2e18;\nconst int MAXC = 105;\nconst int infk = maxn;\nconst int maxk = maxn;\n\nstruct tedge\n{\n    int to, f, cap;\n    ll cost;\n    int o;\n};\n\nint x[maxn], y[maxn];\nll v[maxn];\nint n, m;\nint max_down[maxn], max_left[maxn], max_right[maxn], max_up[maxn];\nvector<tedge> gr[maxn];\nbool inq[maxn];\nqueue<int> q;\nll d[maxn];\nint prv[maxn];\nchar s_tmp[5];\nll answer;\nbool ok;\nint maxf[maxn];\n\nvoid addedge(int a, int b, int f, ll c)\n{\n    int ao = gr[b].size();\n    int bo = gr[a].size();\n    gr[a].pb({b, 0, f, c, ao});\n    gr[b].pb({a, 0, 0, -c, bo});\n}\n\nvoid addedgeLR(int a, int b, int L, int R, ll c)\n{\n    if (L < 0) L = 0;\n    if (R < L) ok = false, R = L;\n//     cout << \"addedgeLR \" << a << ' ' << b << ' ' << L << ' ' << R << ' ' << c << endl;\n    addedge(n + MAXC * 2, b, L, c);\n    addedge(a, n + MAXC * 2 + 1, L, c);\n    addedge(a, b, R - L, 2 * c);\n}\n\nbool find_path(int nn, int s, int t)\n{\n    for (int i = 0; i < nn; i++) d[i] = inf;\n    d[s] = 0;\n    while (!q.empty()) q.pop();\n    q.push(s);\n    for (int i = 0; i < nn; i++) inq[i] = false;\n    inq[s] = true;\n    maxf[s] = maxk;\n    while (!q.empty())\n    {\n        int cur = q.front();\n        q.pop();\n//         cout << cur << ' ' << d[cur] << endl;\n        inq[cur] = false;\n        for (auto t : gr[cur]) if (t.f < t.cap && d[t.to] > d[cur] + t.cost)\n        {\n            d[t.to] = d[cur] + t.cost;\n            prv[t.to] = t.o;\n            maxf[t.to] = min(maxf[cur], t.cap - t.f);\n            if (!inq[t.to])\n            {\n                inq[t.to] = true;\n                q.push(t.to);\n            }\n        }\n    }\n//     cout << \"d[t] = \" << d[t] << ' ' << maxf[t] << endl;\n    if (d[t] > inf / 2) return false;\n    answer += maxf[t] * d[t];\n    int cur = t;\n    while (cur != s)\n    {\n        gr[cur][prv[cur]].f -= maxf[t];\n        int nxt = gr[cur][prv[cur]].to;\n        gr[nxt][gr[cur][prv[cur]].o].f += maxf[t];\n        cur = nxt;\n    }\n    return true;\n}\n\nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++)\n    {\n        scanf(\"%d%d%lld\", &x[i], &y[i], &v[i]);\n    }\n    for (int i = 0; i < MAXC; i++)\n    {\n        max_left[i] = infk;\n        max_right[i] = infk;\n        max_down[i] = infk;\n        max_up[i] = infk;\n    }\n    scanf(\"%d\", &m);\n    for (int i = 0; i < m; i++)\n    {\n        int a, b;\n        scanf(\"%s%d%d\", s_tmp, &a, &b);\n        if (s_tmp[0] == 'L') max_left[a] = min(max_left[a], b);\n        if (s_tmp[0] == 'R') max_right[a] = min(max_right[a], b);\n        if (s_tmp[0] == 'U') max_up[a] = min(max_up[a], b);\n        if (s_tmp[0] == 'D') max_down[a] = min(max_down[a], b);\n    }\n    ll bestans =0 ;\n    for (int k = 1; k <= n; k++)\n    {\n//         cout << \"try \" << k << endl;\n        for (int i =0; i < n + 2 * MAXC + 2; i++) gr[i].clear();\n        ok = true;\n        for (int i = 0; i < MAXC - 1; i++)\n        {\n            addedgeLR(n + i, n + i + 1, k - max_left[i], max_right[i + 1], 0);\n            addedgeLR(n + MAXC + i + 1, n + MAXC + i, k - max_down[i], max_up[i + 1], 0);\n        }\n        for (int i = 0; i < n; i++) addedgeLR(n + x[i], n + MAXC + y[i], 0, 1, -v[i]);\n        addedgeLR(n + MAXC + 0, n + 0, k, k, 0);\n        if (!ok) continue;\n        answer = 0;\n        while (find_path(n + MAXC * 2 + 2, n + MAXC * 2 + 0, n + MAXC * 2 + 1));\n        \n        for (auto e : gr[n + MAXC * 2]) if (e.f != e.cap) ok = false;\n        if (ok)\n        {\n//             cout << \"ok \" << -answer / 2 << endl;\n            bestans = max(bestans, -answer);\n        }\n    }\n    cout << bestans / 2 << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n\n\nstruct udE{\n\tint x, y;\n\tll c, u, d;\n};\nnamespace udcf{\n\tll inf=1e9;\n\tnamespace mincf{\n\t\tconst int E=101000;\n\t\tconst int V=1010;\n\t\t\n\t\tstruct R{\n\t\t\tint to,nex;\n\t\t\tll cost,flow;\n\t\t}r[E];\n\t\tint st,en,n,cnt,hea[V];\n\t\t\n\t\tvoid A(int u,int v,ll c,ll f){\n\t\t\tr[++cnt]=(R){v,hea[u],c,f}; hea[u]=cnt;\n\t\t\tr[++cnt]=(R){u,hea[v],-c,0};hea[v]=cnt;\n\t\t}\n\t\tvoid resta(int n_,int st_,int en_){\n\t\t\tmemset(hea,0,sizeof hea);\n\t\t\tcnt=1;\n\t\t\tn=n_; st=st_; en=en_;\n\t\t}\n\t\t\n\t\tint pv[V],pe[V],in[V];\n\t\tqueue<int>q;\n\t\tll fl,f[V],d[V],ans,sf,inf;\n\t\t\n\t\tbool spfa(){\n\t\t\twhile (!q.empty()) q.pop();\n\t\t\tmemset(in,0,sizeof in);\n\t\t\tmemset(d,62,sizeof d);\n\t\t\tf[st]=inf=d[0]; d[st]=0;\n\t\t\tll x,y,z;\n\t\t\tfor (q.push(st);!q.empty();q.pop()){\n\t\t\t\tx=q.front(); in[x]=0;\n\t\t\t\tfor (int i=hea[x];i>0;i=r[i].nex) if (r[i].flow){\n\t\t\t\t\ty=r[i].to; z=d[x]+r[i].cost;\n\t\t\t\t\tif (z<d[y]){\n\t\t\t\t\t\td[y]=z; f[y]=min(f[x],r[i].flow);\n\t\t\t\t\t\tpv[y]=x; pe[y]=i;\n\t\t\t\t\t\tif (!in[y]){ in[y]=1; q.push(y); }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn d[en]!=inf;\n\t\t}\n\t\t\n\t\tll realmain(){\n\t\t\tsf=ans=0;\n\t\t\twhile (spfa()){\n\t\t\t\tsf+=fl=f[en];\n\t\t\t\tans+=fl*d[en];\n\t\t\t\tfor (int x=en;x!=st;x=pv[x]){\n\t\t\t\t\tr[pe[x]].flow-=fl;\n\t\t\t\t\tr[pe[x]^1].flow+=fl;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ans;\n\t\t}\n\t}\n\tpair<int,ll> realmain(int n,int s,int t,vector<udE>e){\n\t\tint ss=n+1, tt=n+2;\n\t\tmincf::resta(n,ss,tt);\n\t\tmincf::A(t,s,0,inf);\n\t\tll aim=0, bas=0;\n\t\tfor (unsigned it=0;it<e.size();++it){\n\t\t\tudE E=e[it];\n\t\t\tif (E.u<E.d) return (pair<int,ll>){-1,-1ll};\n\t\t\tif (E.d){\n\t\t\t\taim+=E.d; bas+=E.d*E.c;\n\t\t\t\tmincf::A(ss,E.y,0,E.d);\n\t\t\t\tmincf::A(E.x,tt,0,E.d);\n\t\t\t}\n\t\t\tif (E.u-E.d){\n\t\t\t\tmincf::A(E.x,E.y,E.c,E.u-E.d);\n\t\t\t}\n\t\t}\n\t\tll res=mincf::realmain();\n\t\tif (mincf::sf!=aim) return (pair<int,ll>){-1,-1ll};\n\t\treturn (pair<int,ll>){1,res+bas};\n\t}\n}\n\nint n, xl[111], xr[111], yl[111], yr[111];\nvector<udE>org, vec;\n\nint m, a[333], b[333];\nchar ty[333];\n\nint main(){\n\tcin>>n;\n\tfor (int i=1;i<=n;++i){\n\t\tll x, y, v;\n\t\tcin>>x>>y>>v; ++x; ++y;\n\t\torg.push_back({x,y+102,-v,1,0});\n\t}\n\tcin>>m;\n\tfor (int i=1;i<=m;++i){\n\t\tcin>>ty[i]>>a[i]>>b[i];\n\t\t++a[i];\n\t}\n\tll ans=0;\n\tfor (int tot=1;tot<=n;++tot){\n\t\tvec=org;\n\t\tmemset(xl,0,sizeof xl); xl[101]=tot;\n\t\tmemset(xr,1,sizeof xr); xr[101]=tot;\n\t\tmemset(yl,0,sizeof yl); yl[101]=tot;\n\t\tmemset(yr,1,sizeof yr); yr[101]=tot;\n\t\tfor (int i=1;i<=m;++i){\n\t\t\tif (ty[i]=='L') xr[a[i]]=min(xr[a[i]],b[i]);\n\t\t\tif (ty[i]=='R') xl[a[i]-1]=max(xl[a[i]-1],tot-b[i]);\n\t\t\tif (ty[i]=='D') yr[a[i]]=min(yr[a[i]],b[i]);\n\t\t\tif (ty[i]=='U') yl[a[i]-1]=max(yl[a[i]-1],tot-b[i]);\n\t\t}\n\t\tfor (int i=1;i<=101;++i){\n\t\t\tvec.push_back({i+1,i,0,xr[i],xl[i]});\n\t\t\tvec.push_back({i+102,i+1+102,0,yr[i],yl[i]});\n\t\t}\n\t\tpair<int,ll> res=udcf::realmain(204,102,204,vec);\n\t\tcerr<<tot<<' '<<res.first<<' '<<res.second<<endl;\n\t\tif (res.first==1) ans=max(ans,-res.second);\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\n  _|_|                              _|  _|    _|\n_|    _|  _|  _|_|  _|_|_|_|        _|  _|  _|\n_|    _|  _|_|          _|          _|  _|_|\n_|    _|  _|          _|      _|    _|  _|  _|\n  _|_|    _|        _|_|_|_|    _|_|    _|    _|\n\n*/\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<set>\n//#define ls (rt<<1)\n//#define rs (rt<<1|1)\n#define vi vector<int>\n#define pb push_back\n#define mk make_pair\n#define pii pair<ll,ll>\n#define rep(i,a,b) for(int i=(a),i##end=(b);i<=i##end;i++)\n#define fi first\n#define se second\n#define int long long\ntypedef long long ll;\nusing namespace std;\nconst int maxn=420;\nconst int inf=1e9+100;\nint xl[maxn],xr[maxn],yl[maxn],yr[maxn],s=415,t=416;\nint head[maxn],cnt=1;\nstruct gg{\n    int u,v,w;ll cost;int next;\n    void insert(int U,int V,int W,ll Cost,int Next){\n        u=U,v=V,w=W,cost=Cost,next=Next;\n    }\n}side[(maxn*82)*2];\nstruct Point{\n    int x,y;\n    ll cost=0;\n}point[maxn];\nstruct Lim{\n    int a,b;char c;\n}lim[maxn];\nvoid ins(int u,int v,int w,ll cost){\n    side[++cnt].insert(u,v,w,cost,head[u]);head[u]=cnt;\n    side[++cnt].insert(v,u,0,-cost,head[v]);head[v]=cnt;\n}\nint n,m;\nvoid init(int k){\n   rep(i,1,k)xl[i]=yl[i]=-inf,xr[i]=yr[i]=inf;\n   rep(i,1,m){\n       if(lim[i].c=='L')rep(j,lim[i].b+1,k)xl[j]=max(xl[j],lim[i].a+1);\n       else if(lim[i].c=='R')for(int j=k-lim[i].b;j>0;j--)xr[j]=min(xr[j],lim[i].a-1);\n       else if(lim[i].c=='D')rep(j,lim[i].b+1,k)yl[j]=max(yl[j],lim[i].a+1);\n       else if(lim[i].c=='U')for(int j=k-lim[i].b;j>0;j--)yr[j]=min(yr[j],lim[i].a-1);\n   }\n   memset(head,0,sizeof(head));cnt=1;\n   rep(i,1,k)ins(s,2*n+i,1,0);\n   rep(i,1,k)ins(2*n+k+i,t,1,0);\n   rep(i,1,n){\n        ins(i,n+i,1,point[i].cost);\n        rep(j,1,k){\n            if(xl[j]<=point[i].x&&point[i].x<=xr[j])ins(2*n+j,i,1,0);\n            if(yl[j]<=point[i].y&&point[i].y<=yr[j])ins(n+i,2*n+k+j,1,0);\n        }\n   }\n}\nint rk[maxn],q[maxn];\nll dis[maxn],lenth;\nbool vis[maxn];\nbool spfa(){\n    rep(i,1,maxn-1)dis[i]=-inf;\n    memset(vis,0,sizeof(vis));\n    int hd=1,tl=1;q[hd]=s;vis[s]=1;dis[s]=0;\n    while(hd<=tl){\n        int u=q[hd++];vis[u]=0;//cout<<u<<' '<<endl;\n        for(int i=head[u];i;i=side[i].next){\n            int v=side[i].v;if(!side[i].w)continue;\n            if(dis[u]+side[i].cost>dis[v]){\n                dis[v]=dis[u]+side[i].cost;\n                if(!vis[v])q[++tl]=v;\n                vis[v]=1;\n            }\n        }\n    }\n    if(dis[t]>0)return 1;\n    return 0;\n}\nint dfs(int u,int flow){\n    if(u==t)return flow;\n    vis[u]=1;int tot=0;\n    for(int i=head[u];i;i=side[i].next){\n        int v=side[i].v;if(vis[v]||!side[i].w||dis[v]!=dis[u]+side[i].cost)continue;\n        int sent=dfs(v,min(flow,side[i].w));\n        lenth+=1ll*side[i].cost*sent,side[i].w-=sent,side[i^1].w+=sent,tot+=sent;flow-=sent;\n    }\n   // vis[u]=0;\n    return tot;\n}\npii dinic(){\n    int mxflow=0;lenth=0;\n    while(spfa()){\n        int x;\n        while((x=dfs(s,inf)))mxflow+=x;\n    }\n    return mk(mxflow,lenth);\n}\nchar tmp[3];\nsigned main(){\n    scanf(\"%lld\",&n);\n    rep(i,1,n)scanf(\"%lld%lld%lld\",&point[i].x,&point[i].y,&point[i].cost);\n    scanf(\"%lld\",&m);\n    rep(i,1,m){\n        scanf(\"%s%lld%lld\",tmp+1,&lim[i].a,&lim[i].b);lim[i].c=tmp[1];\n    }\n    ll out=0;\n    rep(k,1,n){\n        init(k);\n        pii ans=dinic();out=max(out,ans.se);//cout<<ans.se<<endl;\n    }\n    cout<<out;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ri register int\ntypedef long long ll;\n#define rll register ll\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\t// input a signed integer\n\ttemplate <class I>\n\tinline void gi (I &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = (x << 1) + (x << 3) + (c & 15); x *= f;\n\t}\n\t// input a letter\n\ttemplate <class I>\n\tinline void get (I &x) {\n\t\tfor (c = gc(); c < 'A' || c > 'Z'; c = gc()) ;\n\t\tx = c;\n\t}\n\t// print a signed integer\n\ttemplate <class I>\n\tinline void print (I x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t}\n\t//no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io :: gi;\nusing io :: get;\nusing io :: putc;\nusing io :: print;\nconst int N=85,M=105,inf=2e9,L=325;\nconst ll INF=1e8;\nint flag,x0[N],_y0[N],lx[M],rx[M],ly[M],ry[M];\nll v0[N];\nstruct node{\n\tchar op;\n\tint a,b;\n}q[L];\ninline void chmin(int &x,ri y){\n\tx=min(x,y);\n}\ninline void chmax(int &x,ri y){\n\tx=max(x,y);\n}\nnamespace G{\n\tconst int _N=(M<<1)+N,_M=(M<<1)+(N<<1); \n\tconst ll INF=1e18;\n\tint size,s,t,m,a[_M],b[_M],c[_M],d[_M],deg[_N],\n\ttot,head[_N],nxt[_M<<2],adj[_M<<2],cap[_M<<2],q[_M<<5],S,T,flow,sum,vis[_N],cur[_N];\n\tll cost,dis[_N],val[_M<<2],e[_M];\n\tinline void addedge(ri x,ri y,ri c,rll w){\n\t\tnxt[++tot]=head[x];\n\t\tadj[head[x]=tot]=y;\n\t\tcap[tot]=c;\n\t\tval[tot]=w;\n\t}\n\tinline void Add(ri x,ri y,ri c,rll v){\n\t\taddedge(x,y,c,v);\n\t\taddedge(y,x,0,-v);\n\t}\n\tinline void add(ri x,ri y,ri lower,ri upper,rll cost){\n\t\tif(lower>upper) flag=0;\n\t\t++m;\n\t\ta[m]=x;\n\t\tb[m]=y;\n\t\tc[m]=lower;\n\t\td[m]=upper;\n\t\te[m]=cost;\n\t}\n\tinline void build(){\n\t\tri i;\n\t\tcost=0;\n\t\tfor(i=1;i<=m;++i)\n\t\t\tdeg[a[i]]-=c[i],\n\t\t\tdeg[b[i]]+=c[i],\n\t\t\tcost+=c[i]*e[i],\n\t\t\tAdd(a[i],b[i],d[i]-c[i],e[i]);\n\t\tS=size+1;\n\t\tT=size+2;\n\t\tsum=0;\n\t\tfor(i=1;i<=size;++i){\n\t\t\tif(deg[i]>0) Add(S,i, deg[i],0),sum+=deg[i];\n\t\t\tif(deg[i]<0) Add(i,T,-deg[i],0);\n\t\t}\n\t\tAdd(t,s,inf,0);\n\t\tsize+=2;\n\t}\n\tinline bool spfa(){\n\t\tri l,r,x,y,i;\n\t\tfor(i=1;i<=size;++i) dis[i]=-INF,vis[i]=0,cur[i]=head[i];\n\t\tq[l=r=1]=S;dis[S]=0; \n\t\twhile(l<=r){\n\t\t\tx=q[l++];vis[x]=0; \n\t\t\tfor(i=head[x];i;i=nxt[i])\n\t\t\t\tif(cap[i]&&dis[y=adj[i]]<dis[x]+val[i]){\n\t\t\t\t\tdis[y]=dis[x]+val[i];\n\t\t\t\t\tif(!vis[y]) q[++r]=y,vis[y]=1;\n\t\t\t\t}\n\t\t}\n\t\treturn dis[T]>-INF;\n\t}\n\tinline int dfs(ri x,ri now){\n\t\tif(x==T) return now;\n\t\tvis[x]=1;\n\t\tri y,tmp,res=0;\n\t\tfor(int &i=cur[x];i;i=nxt[i])\n\t\t\tif(!vis[y=adj[i]]&&cap[i]&&dis[y]==dis[x]+val[i])\n\t\t\t\tif(cap[i]-=(tmp=dfs(y,min(now-res,cap[i]))),cap[i^1]+=tmp,(res+=tmp)==now)\n\t\t\t\t\treturn vis[x]=false,res;\n\t\treturn res;\n\t}\n\tinline ll costflow(){\n\t\tri tmp;\n\t\tflow=0;\n\t\twhile(spfa())\n\t\t\ttmp=dfs(S,inf),\n\t\t\tflow+=tmp,\n\t\t\tcost+=tmp*dis[T];\n\t\tif(flow!=sum) return -INF;\n\t\treturn cost;\n\t}\n\tinline void clear(){\n\t\ttot=1;m=0;\n\t\tfor(ri i=1;i<=size;++i) head[i]=deg[i]=0;\n\t}\n}\nint posx[M],posy[M];\nint main(){\n\tri n,m,i,k,limx,limy;\n\tgi(n);\n\tlimx=limy=0;\n\tfor(i=1;i<=n;++i)\n\t\tgi(x0[i]),gi(_y0[i]),gi(v0[i]),\n\t\tlimx=max(limx,x0[i]),\n\t\tlimy=max(limy,_y0[i]);\n\tgi(m);\n\tfor(i=1;i<=m;++i){\n\t\tget(q[i].op);gi(q[i].a);gi(q[i].b);\n\t\tif(q[i].op=='L'||q[i].op=='R')\n\t\t\tlimx=max(limx,q[i].a);\n\t\telse\n\t\t\tlimy=max(limy,q[i].a);\n\t}\n\trll ans=0; \n\tfor(k=1;k<=n;++k){\n\t\tG::clear();\n\t\tfor(i=1;i<=limx;++i)\n\t\t\tlx[i]=0,\n\t\t\trx[i]=inf;\n\t\tfor(i=1;i<=limy;++i)\n\t\t\tly[i]=0,\n\t\t\try[i]=inf;\n\t\tflag=1;\n\t\tfor(i=1;i<=m;++i)\n\t\t\tif(q[i].op=='L')\n\t\t\t\tchmin(rx[q[i].a],q[i].b);\n\t\t\telse if(q[i].op=='R'){\n\t\t\t\tif(q[i].a-1==0){\n\t\t\t\t\tif(k-q[i].b>0){\n\t\t\t\t\t\tflag=0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tchmax(lx[q[i].a-1],k-q[i].b);\n\t\t\t}\n\t\t\telse if(q[i].op=='D')\n\t\t\t\tchmin(ry[q[i].a],q[i].b);\n\t\t\telse{\n\t\t\t\tif(q[i].a-1==0){\n\t\t\t\t\tif(k-q[i].b>0){\n\t\t\t\t\t\tflag=0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tchmax(ly[q[i].a-1],k-q[i].b);\n\t\t\t}\n\t\tif(!flag) continue;\n\t\tfor(i=1;i<=limx;++i)\n\t\t\tlx[i]=max(lx[i-1],lx[i]);\n\t\tfor(i=limx-1;i;--i)\n\t\t\trx[i]=min(rx[i+1],rx[i]);\n\t\tfor(i=1;i<=limy;++i)\n\t\t\tly[i]=max(ly[i-1],ly[i]);\n\t\tfor(i=limy-1;i;--i)\n\t\t\try[i]=min(ry[i+1],ry[i]);\n\t\tG::size=n;\n\t\tfor(i=1;i<=limx;++i)\n\t\t\tposx[i]=++G::size;\n\t\tfor(i=1;i<=limy;++i)\n\t\t\tposy[i]=++G::size;\n\t\tG::s=++G::size;\n\t\tG::t=++G::size;\n\t\tG::add(G::s,posx[limx],max(k,lx[limx]),min(k,rx[limx]),0);\n\t\tfor(i=limx-1;i;--i)\n\t\t\tG::add(posx[i+1],posx[i],lx[i],rx[i],0);\n\t\tG::add(posy[limy],G::t,ly[limy],ry[limy],0);\n\t\tfor(i=1;i<limy;++i)\n\t\t\tG::add(posy[i],posy[i+1],ly[i],ry[i],0);\n\t\tfor(i=1;i<=n;++i)\n\t\t\tG::add(posx[x0[i]],i,0,1,v0[i]),\n\t\t\tG::add(i,posy[_y0[i]],0,1,0);\n\t\tif(!flag) continue;\n\t\tG::build();\n\t\tans=max(ans,G::costflow());\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <cstdint>\n#include <unordered_set>\n#include <unordered_map>\n\nusing namespace std;\n\nusing Int = long long;\n\ntemplate <class T1, class T2> ostream &operator<<(ostream &os, const pair<T1, T2> &a) { return os << \"(\" << a.first << \", \" << a.second << \")\"; };\ntemplate <class T> void pv(T a, T b) { for (T i = a; i != b; ++i) cout << *i << \" \"; cout << endl; }\ntemplate <class T> void chmin(T &t, const T &f) { if (t > f) t = f; }\ntemplate <class T> void chmax(T &t, const T &f) { if (t < f) t = f; }\n\n\nnamespace LP {\n\t#define double long double\n\t#define MAXM 410\n\t#define MAXN 410\n\tconst double EPS = 1e-15;\n\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n\tint m, n, is[MAXM], js[MAXN];\n\tdouble a[MAXM][MAXN], b[MAXM], c[MAXN], d[MAXM][MAXN], x[MAXN];\n\tint solve() {\n\t\tint i, j, ii, jj;\n\t\tfor (i = 0; i < m; ++i) is[i] = n + i;\n\t\tfor (j = 0; j < n; ++j) js[j] = j;\n\t\tis[m] = js[n] = m + n;\n\t\tfor (i = 0; i < m; ++i) for (j = 0; j < n; ++j) d[i][j] = -a[i][j];\n\t\tfor (i = 0; i < m; ++i) d[i][n] = b[i];\n\t\tfor (j = 0; j < n; ++j) d[m][j] = c[j];\n\t\td[m][n] = 0.0;\n\t\tfor (; ; ) {\n\t\t\tfor (ii = m, i = 0; i < m; ++i) if (sig(d[i][n]) < 0 && is[ii] > is[i]) ii = i;\n\t\t\tfor (jj = n, j = 0; j < n; ++j) if (sig(d[m][j]) > 0 && js[jj] > js[j]) jj = j;\n\t\t\tif (ii == m && jj == n) break;\n\t\t\tif (is[ii] > js[jj]) {\n\t\t\t\tfor (ii = m, i = 0; i < m; ++i) if (sig(d[i][jj]) < 0 && is[ii] > is[i]) ii = i;\n\t\t\t} else {\n\t\t\t\tfor (jj = n, j = 0; j < n; ++j) if (sig(d[ii][j]) > 0 && js[jj] > js[j]) jj = j;\n\t\t\t}\n\t\t\tif (ii == m) return +1;\n\t\t\tif (jj == n) return -1;\n\t\t\tswap(is[ii], js[jj]);\n\t\t\td[ii][jj] = 1.0 / d[ii][jj];\n\t\t\tfor (j = 0; j <= n; ++j) if (j != jj) d[ii][j] *= -d[ii][jj];\n\t\t\tfor (i = 0; i <= m; ++i) if (i != ii && sig(d[i][jj]) != 0) {\n\t\t\t\tfor (j = 0; j <= n; ++j) if (j != jj) d[i][j] += d[ii][j] * d[i][jj];\n\t\t\t\td[i][jj] *= d[ii][jj];\n\t\t\t}\n\t\t}\n\t\tfor (j = 0; j < n; ++j) x[j] = 0.0;\n\t\tfor (i = 0; i < m; ++i) if (is[i] < n) x[is[i]] = d[i][n];\n\t\treturn 0;\n\t}\n}\n\n\nint N;\nvector<int> X, Y;\nvector<Int> V;\nint M;\nvector<char> T;\nvector<int> A, B;\n\nint main() {\n  for (; ~scanf(\"%d\", &N); ) {\n    X.resize(N);\n    Y.resize(N);\n    V.resize(N);\n    for (int j = 0; j < N; ++j) {\n      scanf(\"%d%d%lld\", &X[j], &Y[j], &V[j]);\n    }\n    scanf(\"%d\", &M);\n    T.resize(M);\n    A.resize(M);\n    B.resize(M);\n    for (int i = 0; i < M; ++i) {\n      scanf(\" %c%d%d\", &T[i], &A[i], &B[i]);\n    }\n    LP::m = N + M;\n    LP::n = N;\n    memset(LP::a, 0, sizeof(LP::a));\n    for (int j = 0; j < N; ++j) {\n      LP::a[j][j] = 1;\n      LP::b[j] = 1;\n    }\n    for (int i = 0; i < M; ++i) {\n      for (int j = 0; j < N; ++j) {\n        bool on;\n        switch (T[i]) {\n          case 'L': on = (X[j] <= A[i]); break;\n          case 'R': on = (X[j] >= A[i]); break;\n          case 'D': on = (Y[j] <= A[i]); break;\n          case 'U': on = (Y[j] >= A[i]); break;\n          default: assert(false);\n        }\n        if (on) {\n          LP::a[N + i][j] = 1;\n        }\n      }\n      LP::b[N + i] = B[i];\n    }\n    for (int j = 0; j < N; ++j) {\n      LP::c[j] = V[j];\n    }\n    const int status = LP::solve();\n    cerr << \"status = \" << status << endl;\n    printf(\"%.Lf\\n\", LP::d[LP::m][LP::n]);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\n  _|_|                              _|  _|    _|\n_|    _|  _|  _|_|  _|_|_|_|        _|  _|  _|\n_|    _|  _|_|          _|          _|  _|_|\n_|    _|  _|          _|      _|    _|  _|  _|\n  _|_|    _|        _|_|_|_|    _|_|    _|    _|\n\n*/\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<set>\n//#define ls (rt<<1)\n//#define rs (rt<<1|1)\n#define vi vector<int>\n#define pb push_back\n#define mk make_pair\n#define pii pair<ll,ll>\n#define rep(i,a,b) for(int i=(a),i##end=(b);i<=i##end;i++)\n#define fi first\n#define se second\n#define int long long\ntypedef long long ll;\nusing namespace std;\nconst int maxn=420;\nconst int inf=1e18+100;\nint xl[maxn],xr[maxn],yl[maxn],yr[maxn],s=415,t=416;\nint head[maxn],cnt=1;\nstruct gg{\n    int u,v,w;ll cost;int next;\n    void insert(int U,int V,int W,ll Cost,int Next){\n        u=U,v=V,w=W,cost=Cost,next=Next;\n    }\n}side[(maxn*82)*2];\nstruct Point{\n    int x,y;\n    ll cost=0;\n}point[maxn];\nstruct Lim{\n    int a,b;char c;\n}lim[maxn];\nvoid ins(int u,int v,int w,ll cost){\n    side[++cnt].insert(u,v,w,cost,head[u]);head[u]=cnt;\n    side[++cnt].insert(v,u,0,-cost,head[v]);head[v]=cnt;\n}\nint n,m;\nvoid init(int k){\n   rep(i,1,k)xl[i]=yl[i]=-inf,xr[i]=yr[i]=inf;\n   rep(i,1,m){\n       if(lim[i].c=='L')rep(j,lim[i].b+1,k)xl[j]=max(xl[j],lim[i].a+1);\n       else if(lim[i].c=='R')for(int j=k-lim[i].b;j>0;j--)xr[j]=min(xr[j],lim[i].a-1);\n       else if(lim[i].c=='D')rep(j,lim[i].b+1,k)yl[j]=max(yl[j],lim[i].a+1);\n       else if(lim[i].c=='U')for(int j=k-lim[i].b;j>0;j--)yr[j]=min(yr[j],lim[i].a-1);\n   }\n   memset(head,0,sizeof(head));cnt=1;\n   rep(i,1,k)ins(s,2*n+i,1,0);\n   rep(i,1,k)ins(2*n+k+i,t,1,0);\n   rep(i,1,n){\n        ins(i,n+i,1,point[i].cost);\n        rep(j,1,k){\n            if(xl[j]<=point[i].x&&point[i].x<=xr[j])ins(2*n+j,i,1,0);\n            if(yl[j]<=point[i].y&&point[i].y<=yr[j])ins(n+i,2*n+k+j,1,0);\n        }\n   }\n}\nint rk[maxn],q[maxn];\nll dis[maxn],lenth;\nbool vis[maxn];\nbool spfa(){\n    rep(i,1,maxn-1)dis[i]=-inf;\n    memset(vis,0,sizeof(vis));\n    int hd=1,tl=1;q[hd]=s;vis[s]=1;dis[s]=0;\n    while(hd<=tl){\n        int u=q[hd++];vis[u]=0;//cout<<u<<' '<<endl;\n        for(int i=head[u];i;i=side[i].next){\n            int v=side[i].v;if(!side[i].w)continue;\n            if(dis[u]+side[i].cost>dis[v]){\n                dis[v]=dis[u]+side[i].cost;\n                if(!vis[v])q[++tl]=v;\n                vis[v]=1;\n            }\n        }\n    }\n    if(dis[t]!=-inf)return 1;\n    return 0;\n}\nint dfs(int u,int flow){\n    if(u==t)return flow;\n    vis[u]=1;int tot=0;\n    for(int i=head[u];i;i=side[i].next){\n        int v=side[i].v;if(vis[v]||!side[i].w||dis[v]!=dis[u]+side[i].cost)continue;\n        int sent=dfs(v,min(flow,side[i].w));\n        lenth+=1ll*side[i].cost*sent,side[i].w-=sent,side[i^1].w+=sent,tot+=sent;flow-=sent;\n    }\n   // vis[u]=0;\n    return tot;\n}\npii dinic(){\n    int mxflow=0;lenth=0;\n    while(spfa()){\n        int x;\n        while((x=dfs(s,inf)))mxflow+=x;\n    }\n    return mk(mxflow,lenth);\n}\nchar tmp[3];\nsigned main(){\n    scanf(\"%lld\",&n);\n    rep(i,1,n)scanf(\"%lld%lld%lld\",&point[i].x,&point[i].y,&point[i].cost);\n    scanf(\"%lld\",&m);\n    rep(i,1,m){\n        scanf(\"%s%lld%lld\",tmp+1,&lim[i].a,&lim[i].b);lim[i].c=tmp[1];\n    }\n    ll out=0;\n    rep(k,1,n){\n        init(k);\n        pii ans=dinic();out=max(out,ans.se);//cout<<ans.se<<endl;\n    }\n    cout<<out;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define all(x) (x).begin (),(x).end()\n#define sqrt(x) sqrt(abs(x))\n#define re return\n#define sz(x) ((int)(x).size ())\n#define prev PREV\n#define next NEXT\n\nusing ll = long long;\nusing ii = pair<int, int>;\nusing ld = long double;\nusing D = double;\nusing vi = vector<int>;\nusing vii = vector<ii>;\nusing vvi = vector<vi>;\nusing vs = vector<string>;\n\ntemplate<typename T> T abs (T x) { re x < 0 ? -x : x; }\ntemplate<typename T> T sgn (T x) { re x < 0 ? -1 : (x > 0 ? 1 : 0); }\ntemplate<typename T> T sqr (T x) { re x * x; }\ntemplate<typename T> T gcd (T a, T b) { re a != 0 ? gcd (b % a, a) : b; }\n\nconst int inf = 1e9;\nconst ll INF = 1e15;\n\nint n;\nint m;\nint o, e;\nint x[200];\nint y[200];\nll val[200];\nint a[400];\nint b[400];\nstring t[400];\nvi vx, vy;\nint lx[200];\nint rx[200];\nint ly[200];\nint ry[200];\n\nvii v[2000];\nint ec[200000];\nll ef[200000];\nll d[2000];\nll p[2000];\nint mark[2000];\nint prev[2000];\nint preve[2000];\nset<pair<ll, int> > all;\n\n\nvoid addedge (int a, int b, int c, ll d) {\n//\tprintf (\"%d %d %d %I64d\\n\", a, b, c, d);\n\tv[a].pb (mp (b, e));\n\tec[e] = c;\n\tef[e] = d;\n\te++;\n\tv[b].pb (mp (a, e));\n\tec[e] = 0;\n\tef[e] = -d;\n\te++;\n}\n\nll go (int S, int T) {\n\tall.clear ();\n\tfor (int i = 0; i < o; i++) {\n\t\tmark[i] = 0;\n\t\td[i] = 1e18;\n\t}\n\tmark[S] = 1;\n\td[S] = 0;\n\tall.insert (mp (0, S));\n\twhile (!all.empty ()) {\n\t\tint x = all.begin ()->se;\n//\t\tprintf (\"%d\\n\", x);\n\t\tmark[x] = 2;\n\t\tall.erase (all.begin ());\n\t\tfor (int i = 0; i < sz (v[x]); i++) {\n\t\t\tint y = v[x][i].fi;\n\t\t\tint z = v[x][i].se;\n\t\t\tif (ec[z] > 0 && d[x] + p[x] + ef[z] - p[y] < d[y]) {\n\t\t\t\tif (mark[y] == 1) all.erase (mp (d[y], y));\n\t\t\t\td[y] = d[x] + p[x] + ef[z] - p[y];\n\t\t\t\tprev[y] = x;\n\t\t\t\tpreve[y] = z;\n\t\t\t\tmark[y] = 1;\n\t\t\t\tall.insert (mp (d[y], y));\n\t\t\t}\n\t\t}\n\t}\n\tif (mark[T] == 0) re -1;\n\tll ans = d[T] - p[S] + p[T];\n\tfor (int i = 0; i < o; i++)\n\t\tif (mark[i])\n\t\t\tp[i] += d[i];\n\tre ans;\n}\n\nmap<int, ll> was;\n\nll calc (int h) {\n\tif (was.count (h)) re was[h];\n\tint ox = sz (vx);\n\tint oy = sz (vy);\n\tfor (int i = 0; i < ox; i++) {\n\t\tlx[i] = 0;\n\t\trx[i] = h;\n\t\tfor (int j = 0; j < m; j++)\n\t\t\tif (t[j] == \"L\") {\n\t\t\t\tif (vx[i] <= a[j]) rx[i] = min (rx[i], b[j]);\n\t\t\t} else\n\t\t\tif (t[j] == \"R\") {\n\t\t\t\tif (vx[i] >= a[j] - 1) lx[i] = max (lx[i], h - b[j]);\n\t\t\t}\n\t\tif (lx[i] > rx[i]) re was[h] = -1;\t\n\t}\n\tfor (int i = 0; i < oy; i++) {\n\t\tly[i] = 0;\n\t\try[i] = h;\n\t\tfor (int j = 0; j < m; j++)\n\t\t\tif (t[j] == \"D\") {\n\t\t\t\tif (vy[i] <= a[j]) ry[i] = min (ry[i], b[j]);\n\t\t\t} else\n\t\t\tif (t[j] == \"U\") {\n\t\t\t\tif (vy[i] >= a[j] - 1) ly[i] = max (ly[i], h - b[j]);\n\t\t\t}\n\t\tif (ly[i] > ry[i]) re was[h] = -1;\t\n\t}\n\to = 2 * ox + 2 * oy + 2 * n + 5;\n\te = 0;\n\tfor (int i = 0; i < o; i++) v[i].clear ();\n\tint req = 0;\n\taddedge (o - 4, 2 * n + 2 * (ox - 1), inf, 0);\n\tfor (int i = 0; i < ox; i++) {\n//\t\tprintf (\"x %d: %d %d\\n\", vx[i], lx[i], rx[i]);\n\t\treq += lx[i];\n\t\taddedge (2 * n + 2 * i, 2 * n + 2 * i + 1, rx[i] - lx[i], 0);\n\t\taddedge (o - 2, 2 * n + 2 * i + 1, lx[i], 0);\n\t\taddedge (2 * n + 2 * i, o - 1, lx[i], 0);\n\t\tif (i > 0) addedge (2 * n + 2 * i + 1, 2 * n + 2 * (i - 1), inf, 0);\n\t}\n\taddedge (2 * n + 2 * ox + 2 * (oy - 1) + 1, o - 3, inf, 0);\n\tfor (int i = 0; i < oy; i++) {\n//\t\tprintf (\"y %d: %d %d\\n\", vy[i], ly[i], ry[i]);\n\t\treq += ly[i];\n\t\taddedge (2 * n + 2 * ox + 2 * i, 2 * n + 2 * ox + 2 * i + 1, ry[i] - ly[i], 0);\n\t\taddedge (o - 2, 2 * n + 2 * ox + 2 * i + 1, ly[i], 0);\n\t\taddedge (2 * n + 2 * ox + 2 * i, o - 1, ly[i], 0);\n\t\tif (i > 0) addedge (2 * n + 2 * ox + 2 * (i - 1) + 1, 2 * n + 2 * ox + 2 * i, inf, 0);\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\taddedge (2 * i, 2 * i + 1, 1, INF - val[i]);\n\t\tint j = 0;\n\t\twhile (vx[j] < x[i]) j++;\n\t\taddedge (2 * n + 2 * j + 1, 2 * i, inf, 0);\n\t\tj = 0;\n\t\twhile (vy[j] < y[i]) j++;\n\t\taddedge (2 * i + 1, 2 * n + 2 * ox + 2 * j, inf, 0);\n\t}\n\treq += h;\n\taddedge (o - 3, o - 5, inf, 0);\n\taddedge (o - 2, o - 4, h, 0);\n\taddedge (o - 5, o - 1, h, 0);\n\tll ans = 0;\n\tfor (int i = 0; i < o; i++) p[i] = 0;\n\tfor (int i = 0; i < req; i++) {\n\t\tll tmp = go (o - 2, o - 1);\n//\t\tprintf (\"%d: %d = %I64d\\n\", h, i, INF - tmp);\n\t\tif (tmp == -1) re was[h] = -1;\n\t\tans += tmp;\n\t\tint j = o - 1;\n\t\twhile (j != o - 2) {\n\t\t\tint k = prev[j];\n\t\t\tint z = preve[j];\n\t\t\tec[z]--;\n\t\t\tec[z ^ 1]++;\n//\t\t\tprintf (\"%d -> %d = %d\\n\", k / 2, j / 2, ec[z]);\n\t\t\tj = k;\n\t\t}\n\t}\n\tll tmp = go (o - 2, o - 1);\n\tre was[h] = h * INF - ans;\n}\n\nint main () {\n\tcin >> n;\n\tfor (int i = 0; i < 100; i++) {\n\t\tvx.pb (i + 1);\n\t\tvy.pb (i + 1);\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x[i] >> y[i] >> val[i];\n\t\tvx.pb (x[i]);\n\t\tvy.pb (y[i]);\n\t}\t\n\tcin >> m;\n\tfor (int i = 0; i < m; i++) {\n\t\tcin >> t[i] >> a[i] >> b[i];\n\t\tif (t[i] == \"L\" || t[i] == \"R\") vx.pb (a[i]); else vy.pb (a[i]);\n\t}\n\tsort (all (vx));\n\tvx.resize (unique (all (vx)) - vx.begin ());\n\tsort (all (vy));\n\tvy.resize (unique (all (vy)) - vy.begin ());\n\tll ans = 0;\n\tint l = 0, r = n;\n\twhile (r - l > 2) {\n\t\tint s1 = (2 * l + r) / 3;\n\t\tint s2 = (l + 2 * r) / 3;\n\t\tll h1 = calc (s1);\n\t\tll h2 = calc (s2);\n\t\tif (h1 >= h2) r = s2; else l = s1;\n\t}\n\tfor (int i = l; i <= r; i++) ans = max (ans, calc (i));\n/*\tfor (int t = 0; t <= n; t++) {\n\t\tll tmp = calc (t);\n\t\tans = max (ans, tmp);\n\t}\t*/\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for (int i = (a); i <= (b); ++ i)\n#define rrp(i,a,b) for (int i = (a); i >= (b); -- i)\n#define gc() getchar()\n#define fir first\n#define sec second\ntypedef pair<int,int> pii;\ntypedef double db;\ntypedef long long ll;\ntemplate <typename tp>\ninline void read(tp& x) {\n  x = 0; char tmp; bool key = 0;\n  for (tmp = gc(); !isdigit(tmp); tmp = gc())\n    key = (tmp == '-');\n  for (; isdigit(tmp); tmp = gc()) \n    x = (x << 3) + (x << 1) + (tmp ^ '0');\n  if (key) x = -x;\n}\ntemplate <typename tp>\ninline void ckmn(tp& x,tp y) {\n  x = x < y ? x : y;\n}\ntemplate <typename tp>\ninline void ckmx(tp& x,tp y) {\n  x = x < y ? y : x;\n}\n\nnamespace flow {\n  const int N = 500, M = 40000, INF = 0x3f3f3f3f;\n  const ll LLINF = 1ll << 60;\n  struct edge {\n    int la,b,cap;\n    ll co;\n  } con[M];\n  int tot=1,fir[N],st,en,n,inq[N],vis[N],flo;\n  ll ans, dis[N], now;\n  void add_edge(int from,int to,int capc,ll cos) {\n    con[++tot] = (edge) {fir[from],to,capc,cos};\n    fir[from] = tot;\n    con[++tot] = (edge) {fir[to],from,0,-cos};\n    fir[to] = tot;\n  }\n  int dfs(int pos,int imp) {\n    if (pos == en || (!imp)) return ans += now * imp, flo += imp, imp;\n    int ret = 0, tmp;\n    vis[pos] = 1;\n    for (int i = fir[pos] ; i ; i = con[i].la) {\n      if (!con[i].co && !vis[con[i].b]) {\n\ttmp = dfs(con[i].b,min(imp,con[i].cap));\n\tcon[i].cap -= tmp;\n\tcon[i^1].cap += tmp;\n\tret += tmp;\n\timp -= tmp;\n\tif (!imp) break;\n      }\n    }\n    return ret;\n  }\n  deque<int> q;\n  void qpush(int pos) {\n    inq[pos] = 1;\n    if (q.empty()) q.push_back(pos);\n    else {\n      if (dis[pos] < dis[q.front()])\n\tq.push_front(pos);\n      else q.push_back(pos);\n    }\n  }\n  bool spfa() {\n    while (!q.empty()) q.pop_back();\n    rep (i, 1, n) dis[i] = LLINF;\n    memset(inq,0,sizeof inq);\n    dis[st] = 0;\n    qpush(st);\n    for (int pos ; !q.empty() ; ) {\n      pos = q.front();\n      q.pop_front();\n      inq[pos] = 0;\n      for (int i = fir[pos] ; i ; i = con[i].la) {\n\tif (con[i].cap && dis[con[i].b] > dis[pos] + con[i].co) {\n\t  dis[con[i].b] = dis[pos] + con[i].co;\n\t  if (!inq[con[i].b]) qpush(con[i].b);\n\t}\n      }\n    }\n    if (dis[en] == LLINF) return 0;\n    now += dis[en];\n    for (int pos = 1 ; pos <= n ; ++ pos) {\n      for (int i = fir[pos] ; i ; i = con[i].la)\n\tcon[i].co += dis[pos] - dis[con[i].b];\n    }\n    return 1;\n  }\n  ll solve() {\n    while (spfa()) {\n      do memset(vis,0,sizeof vis);\n      while (dfs(st, INF));\n    }\n    return ans;\n  }\n  void init() {\n    tot = 1;\n    memset(fir, 0, sizeof fir);\n    now = ans = 0;\n    st = en = n = 0;\n    flo = 0;\n  }\n}\n\nconst int N = 120;\nint liml[2][N], limr[2][N];\nint n, m, px[N], py[N], sz = 100;\nll pv[N];\nint lp[N], rp[N];\nll solve(int num) {\n  flow::init();\n  flow::n = 2 * n;\n  rep (i, 1, n) flow::add_edge(i, i+n, 1, -pv[i]);\n  flow::st = ++ flow::n, flow::en = ++ flow::n;\n  rep (a, 0, 1) {\n    rep (i, 1, num) lp[i] = 1, rp[i] = sz;\n    rep (i, 1, sz) if (liml[a][i]+1 <= num)\n      ckmx(lp[liml[a][i] + 1], i+1);\n    rep (i, 1, sz) if (num > limr[a][i])\n      ckmn(rp[num - limr[a][i]], i-1);\n    rep (i, 2, num) lp[i] = max(lp[i-1], lp[i]);\n    rrp (i, num-1, 1) rp[i] = min(rp[i+1], rp[i]);\n    // rep (i, 1, num)\n    //   printf(\"(%d,%d) \", lp[i], rp[i]);\n    // puts(\"\");\n    if (a == 0) {\n      rep (i, 1, num) {\n\tint id = ++ flow::n;\n\tflow::add_edge(flow::st, id, 1, 0);\n\trep (j, 1, n) if (px[j] >= lp[i] && px[j] <= rp[i])\n\t  flow::add_edge(id, j, 1, 0);\n      }\n    } else {\n      rep (i, 1, num) {\n\tint id = ++ flow::n;\n\tflow::add_edge(id, flow::en, 1, 0);\n\trep (j, 1, n) if (py[j] >= lp[i] && py[j] <= rp[i])\n\t  flow::add_edge(j+n, id, 1, 0);\n      }\n    }\n  }\n  ll ret = -flow::solve();\n  if (flow::flo == num) return ret;\n  else return 0;\n}\nint main() {\n  char str[3];\n  int x,y;\n  read(n);\n  rep (i, 1, n)\n    read(px[i]), read(py[i]), read(pv[i]);\n  rep (a, 0, 1) rep (i, 1, sz)\n    liml[a][i] = limr[a][i] = n;\n  read(m);\n  rep (i, 1, m) {\n    scanf(\"%s\", str);\n    read(x), read(y);\n    if (*str == 'L') {\n      ckmn(liml[0][x], y);\n    } else if (*str == 'R') {\n      ckmn(limr[0][x], y);\n    } else if (*str == 'D') {\n      ckmn(liml[1][x], y);\n    } else if (*str == 'U') {\n      ckmn(limr[1][x], y);\n    }\n  }\n  rep (a, 0, 1) rrp (i, sz-1, 1)\n    liml[a][i] = min(liml[a][i], liml[a][i+1]);\n  rep (a, 0, 1) rep (i, 2, sz)\n    limr[a][i] = min(limr[a][i], limr[a][i-1]);\n  ll ans = 0;\n  rep (i, 1, n)\n    ckmx(ans, solve(i));\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 100\n#define M 400\n#define V 200\n#define E 2000\n#define INF 1000000000000000000LL\nusing namespace std;\nint n;\nstruct jewel{int x,y;long long v;}J[N];\nstruct table{\n    int n,a[N];\n    void add(int x){a[++n]=x;}\n    void su(){sort(a+1,a+n+1);n=unique(a+1,a+n+1)-a-1;}\n    int lst(int x){return upper_bound(a+1,a+n+1,x)-a-1;}\n    int nxt(int x){return lower_bound(a+1,a+n+1,x)-a;}\n}X,Y;\nint m;\nstruct cond{char t;int a,b;}C[M];\nint e,head[V],nxt[E],to[E],cap[E],op[E];\nlong long val[E];\nvoid add(int x,int y,int c,long long v){\n    nxt[++e]=head[x],to[head[x]=e]=y,cap[e]=c,val[e]=v,op[e]=e+1;\n    nxt[++e]=head[y],to[head[y]=e]=x,cap[e]=0,val[e]=-v,op[e]=e-1;\n}\nint S,T,from[V],from_edge[V];\nlong long f[V];\nbool vis[V];\nqueue <int> q;\nlong long spfa(){\n    for(int i=0;i<=X.n+Y.n+3;++i)f[i]=-INF*2;\n    f[S]=0,vis[S]=1,q.push(S);\n    while(!q.empty()){\n        int x=q.front();\n        vis[x]=0,q.pop();\n        for(int i=head[x];i;i=nxt[i])\n            if(cap[i] && f[x]+val[i]>f[to[i]]){\n\t\t    \tf[to[i]]=f[x]+val[i];\n\t\t\t\tfrom[to[i]]=x,from_edge[to[i]]=i;\n\t\t    \tif(!vis[to[i]])vis[to[i]]=1,q.push(to[i]);\n\t\t    }\n    }\n    return f[T];\n}\nint flow;\nlong long cost;\nvoid augment(){\n    int delta=N;\n    for(int i=T;i!=S;i=from[i])delta=min(delta,cap[from_edge[i]]);\n    flow+=delta;\n    for(int i=T;i!=S;i=from[i]){\n\t\tcap[from_edge[i]]-=delta;\n        cap[op[from_edge[i]]]+=delta;\n        if(val[from_edge[i]]==-INF)continue;\n\t\tcost+=val[from_edge[i]]*delta;\n    }\n}\nint R_min[N],R_max[N],U_min[N],U_max[N];\nint in[V];\nlong long solve(int k){\n    int s=0,t=X.n+1,ss=X.n+Y.n+2,tt=X.n+Y.n+3;\n    e=0;for(int i=0;i<=X.n+Y.n+3;++i)head[i]=0;\n    for(int i=1;i<=X.n+1;++i)R_min[i]=0,R_max[i]=N;\n    for(int i=1;i<=Y.n+1;++i)U_min[i]=0,U_max[i]=N;\n    R_max[X.n+1]=U_max[Y.n+1]=0;\n    R_min[1]=R_max[1]=k;\n    for(int i=1;i<=m;++i)\n        if(C[i].t=='L')R_min[C[i].a+1]=max(R_min[C[i].a+1],k-C[i].b);\n        else if(C[i].t=='R')R_max[C[i].a]=min(R_max[C[i].a],C[i].b);\n        else if(C[i].t=='D')U_min[C[i].a+1]=max(U_min[C[i].a+1],k-C[i].b);\n        else U_max[C[i].a]=min(U_max[C[i].a],C[i].b);\n    for(int i=1;i<=X.n+1;++i)\n        if(R_min[i]>R_max[i])return 0;\n    for(int i=1;i<=Y.n+1;++i)\n        if(U_min[i]>U_max[i])return 0;\n    for(int i=0;i<=X.n+Y.n+1;++i)in[i]=0;\n    for(int i=1;i<=X.n;++i){\n        add(i-1,i,R_max[i]-R_min[i],0);\n        in[i]+=R_min[i],in[i-1]-=R_min[i];\n    }\n    for(int i=1;i<=n;++i)add(X.nxt(J[i].x),t+Y.nxt(J[i].y),1,J[i].v);\n    for(int i=1;i<=Y.n;++i){\n        add(t+i,t+i-1,U_max[i]-U_min[i],0);\n        in[t+i]-=U_min[i],in[t+i-1]+=U_min[i];\n    }\n    int total=0;\n    for(int i=0;i<=X.n+Y.n+1;++i)\n        if(in[i]>0)total+=in[i],add(ss,i,in[i],0);\n        else if(in[i]<0)add(i,tt,-in[i],0);\n    add(t,s,N,-INF);\n    S=ss,T=tt,flow=0,cost=0;\n    while(spfa()>-INF*2)augment();\n    if(flow<total)return 0;\n    S=s,T=t;\n    head[s]=nxt[head[s]];\n    head[e]=nxt[head[t]];\n    while(spfa()>0)augment();\n    return cost;\n}\nint main(){\n    cin>>n;\n    X.n=Y.n=0;\n    X.add(0),Y.add(0);\n    X.add(101),Y.add(101);\n    for(int i=1;i<=n;++i){\n        cin>>J[i].x>>J[i].y>>J[i].v;\n        X.add(J[i].x),Y.add(J[i].y);\n    }\n    X.su(),Y.su();\n    cin>>m;\n    for(int i=1;i<=m;++i){\n        char ch=getchar();\n        while(ch!='L' && ch!='R' && ch!='D' && ch!='U')ch=getchar();\n        C[i].t=ch;\n        cin>>C[i].a>>C[i].b;\n        if(ch=='L')C[i].a=X.lst(C[i].a);\n        else if(ch=='R')C[i].a=X.nxt(C[i].a);\n        else if(ch=='D')C[i].a=Y.lst(C[i].a);\n        else C[i].a=Y.nxt(C[i].a);\n    }\n    long long ans=0;\n    for(int i=1;i<=n;++i)ans=max(ans,solve(i));\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MV = 815;\nconst int ME = 1200006;\nconst ll oo = 1e18;\n\ntemplate <typename T> void cmin(T &x, const T &y)\n{\n\tif(y < x) x = y;\n}\n\ntemplate <typename T> void cmax(T &x, const T &y)\n{\n\tif(y > x) x = y;\n}\n\ntemplate <typename T> void read(T &x)\n{\n\tx = 0; char c = getchar(); bool f = 0;\n\twhile(!isdigit(c) && c!='-') c = getchar();\n\tif(c == '-') f = 1, c = getchar();\n\twhile(isdigit(c)) x = x*10+c-'0', c = getchar();\n\tif(f) x = -x;\n}\n\nstruct edge\n{\n\tint u, v, f;\n\tll c;\n\tint n;\n\n\tedge (const int &u0 = 0, const int &v0 = 0, const ll &f0 = 0, const ll &c0 = 0, const int &n0 = 0) : u(u0), v(v0), f(f0), c(c0), n(n0) {}\n};\n\nstruct GRAPH\n{\n\tedge e[ME];\n\tint fst[MV], lnum;\n\n\tvoid init() {memset(fst, 0xff, sizeof(fst)); lnum = -1;}\n\t\n\tGRAPH () {init();}\n\t\n\tvoid addeg(int nu, int nv, int nc, int nf)\n\t{\n\t\te[++lnum] = edge(nu, nv, nf, nc, fst[nu]), fst[nu] = lnum;\n\t\te[++lnum] = edge(nv, nu, 0, -nc, fst[nv]), fst[nv] = lnum;\n\t}\n\t\n\tint que[MV], inq[MV], cur[MV];\n\tll dis[MV];\n\t\n\tbool spfa(int frm, int tar)\n\t{\n\t\tint h = 1, t = 1, x, y;\n\t\tmemset(dis, 0x9f, sizeof(dis));\n\t\tdis[frm] = 0;\n\t\tque[h] = frm;\n\t\tinq[frm] = 1;\n\t\twhile(h >= t)\n\t\t{\n\t\t\tx = que[(t++)%MV];\n\t\t\tinq[x] = 0;\n\t\t\tfor(int i=fst[x]; ~i; i=e[i].n)\n\t\t\t{\n\t\t\t\ty = e[i].v;\n\t\t\t\tif(e[i].f && dis[y]<dis[x]+e[i].c)\n\t\t\t\t{\n\t\t\t\t\tdis[y] = dis[x] + e[i].c;\n\t\t\t\t\tif(!inq[y]) que[(++h)%MV] = y, inq[y] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn (dis[tar] > -oo);\n\t}\n\t\n\tint dinic(int x, int t, int f)\n\t{\n\t\tif(x == t) return f;\n\t\tint a, y, now = 0;\n\t\tinq[x] = 1;\n\t\tfor(int &i=cur[x]; ~i; i=e[i].n)\n\t\t{\n\t\t\ty = e[i].v;\n\t\t\tif(dis[y]==dis[x]+e[i].c && e[i].f && !inq[y])\n\t\t\t{\n\t\t\t\ta = dinic(y, t, min(e[i].f, f-now));\n\t\t\t\tnow += a;\n\t\t\t\te[i].f -= a;\n\t\t\t\te[i^1].f += a;\n\t\t\t\tif(now == f) break;\n\t\t\t}\n\t\t}\n\t\tinq[x] = 0;\n\t\treturn now;\n\t}\n\t\n\tpair<int, ll> costf(int s, int t)\n\t{\n\t\tll cost = 0;\n\t\tint flow = 0;\n\t\twhile(spfa(s, t))\n\t\t{\n\t\t\tmemmove(cur, fst, sizeof(cur));\n\t\t\tint new_flow = dinic(s, t, ME);\n\t\t\tcost += dis[t] * new_flow;\n\t\t\tflow += new_flow;\n\t\t}\n\t\treturn make_pair(flow, cost);\n\t}\n} G;\n\nint n, m;\nint lx[MV], rx[MV];\nint ly[MV], ry[MV];\nint px[MV], py[MV];\nll pv[MV];\nchar qc[MV];\nint qa[MV], qb[MV];\nint global_s, global_t;\n\nvoid input()\n{\n\tread(n);\n\tfor(int i=1; i<=n; i++) read(px[i]), read(py[i]), read(pv[i]);\n\tread(m);\n\tfor(int i=1; i<=n; i++) lx[i] = 1, rx[i] = 100, ly[i] = 1, ry[i] = 100;\n\tfor(int i=1; i<=m; i++)\n\t{\n\t\tqc[i] = getchar();\n\t\twhile(!isalpha(qc[i])) qc[i] = getchar();\n\t\tread(qa[i]), read(qb[i]);\n\t}\n}\n\nvoid build(int num)\n{\n\tfor(int i=1; i<=num; i++) lx[i] = ly[i] = 1, rx[i] = ry[i] = 100;\n\tfor(int i=1; i<=m; i++)\n\t{\n\t\tif(qb[i] > num) continue;\n\t\tif(qc[i] == 'L') cmax(lx[qb[i]+1], qa[i]+1);\n\t\tif(qc[i] == 'R') cmin(rx[num-qb[i]], qa[i]-1);\n\t\tif(qc[i] == 'D') cmax(ly[qb[i]+1], qa[i]+1);\n\t\tif(qc[i] == 'U') cmin(ry[num-qb[i]], qa[i]-1);\n\t}\n\tfor(int i=1; i<=num; i++) cmax(lx[i], lx[i-1]), cmax(ly[i], ly[i-1]);\n\tfor(int i=num; i>=1; i--) cmin(rx[i], rx[i+1]), cmin(ry[i], ry[i+1]);\n\tG.init();\n\tfor(int i=1; i<=num; i++)\n\t{\n\t\tfor(int j=1; j<=n; j++)\n\t\t{\n\t\t\tif(lx[i]<=px[j] && px[j]<=rx[i]) G.addeg(i, num*2+j, 0, 1);\n\t\t\tif(ly[i]<=py[j] && py[j]<=ry[i]) G.addeg(num*2+n+j, num+i, 0, 1);\n\t\t}\n\t}\n\tfor(int i=1; i<=n; i++) G.addeg(num*2+i, num*2+n+i, pv[i], 1);\n\tglobal_s = num*2+n*2+1, global_t = global_s+1;\n\tfor(int i=1; i<=num; i++) G.addeg(global_s, i, 0, 1), G.addeg(num+i, global_t, 0, 1);\n}\n\nvoid work()\n{\n\tll ans = 0;\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tbuild(i);\n\t\tauto ret = G.costf(global_s, global_t);\n\t\tif(ret.first != i) break;\n\t\telse cmax(ans, ret.second);\n\t}\n\tprintf(\"%lld\\n\", ans);\n}\n\nint main()\n{\n\tinput();\n\twork();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<queue>\nusing namespace std;\ntypedef long long ll;\nconst int N=1000005;\nqueue<int> q;\nint n,m,x[N],y[N],lt1[N],rt1[N],lt2[N],rt2[N],a[400],b[400],Flow,pre[N],lst[N],A[N],i,j,k,l,head[N],adj[N],nxt[N],flow[N],cap[N],cnt;\nbool v[N];\nll val[N],cost[N],Cost,dis[N],ans;\nchar s[400][10];\nvoid addedge(int u,int v,int w,ll c)\n{\n\tadj[++l]=v;\n\tnxt[l]=head[u];\n\thead[u]=l;\n\tflow[l]=0;\n\tcap[l]=w;\n\tcost[l]=c;\n\tadj[++l]=u;\n\tnxt[l]=head[v];\n\thead[v]=l;\n\tflow[l]=0;\n\tcap[l]=0;\n\tcost[l]=-c;\n}\nbool spfa()\n{\n\tint i,j;\n\tfor(i=1;i<=cnt;++i)\n\t\tdis[i]=-(1ll<<60),v[i]=false;\n\tdis[cnt-1]=0;\n\tq.push(cnt-1);\n\tv[cnt-1]=true;\n\tA[cnt-1]=1<<30;\n\twhile(!q.empty())\n\t{\n\t\ti=q.front();\n\t\tq.pop();\n\t\tv[i]=false;\n\t\tfor(j=head[i];j;j=nxt[j])\n\t\t\tif(flow[j]<cap[j]&&dis[i]+cost[j]>dis[adj[j]])\n\t\t\t{\n\t\t\t\tdis[adj[j]]=dis[i]+cost[j];\n\t\t\t\tA[adj[j]]=min(A[i],cap[j]-flow[j]);\n\t\t\t\tpre[adj[j]]=i;\n\t\t\t\tlst[adj[j]]=j;\n\t\t\t\tif(!v[adj[j]])\n\t\t\t\t{\n\t\t\t\t\tv[adj[j]]=true;\n\t\t\t\t\tq.push(adj[j]);\n\t\t\t\t}\n\t\t\t}\n\t}\n\tif(dis[cnt]==-(1ll<<60))\n\t\treturn false;\n\tFlow+=A[cnt];\n\tCost+=A[cnt]*dis[cnt];\n\ti=cnt;\n\twhile(i!=cnt-1)\n\t{\n\t\tflow[lst[i]]+=A[cnt];\n\t\tflow[lst[i]&1?lst[i]+1:lst[i]-1]-=A[cnt];\n\t\ti=pre[i];\n\t}\n\treturn true;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;++i)\n\t\tscanf(\"%d%d%lld\",x+i,y+i,val+i);\n\tscanf(\"%d\",&m);\n\tfor(i=1;i<=m;++i)\n\t\tscanf(\"%s%d%d\",s[i],a+i,b+i);\n\tfor(i=1;i<=n;++i)\n\t{\n\t\tfor(j=1;j<=i;++j)\n\t\t\tlt1[j]=lt2[j]=1,rt1[j]=rt2[j]=100;\n\t\tfor(j=1;j<=m;++j)\n\t\tif(b[j]<i)\n\t\t{\n\t\t\tif(s[j][0]=='L')\n\t\t\t\tlt1[b[j]+1]=max(lt1[b[j]+1],a[j]+1);\n\t\t\telse if(s[j][0]=='R')\n\t\t\t\trt1[i-b[j]]=min(rt1[i-b[j]],a[j]-1);\n\t\t\telse if(s[j][0]=='D')\n\t\t\t\tlt2[b[j]+1]=max(lt2[b[j]+1],a[j]+1);\n\t\t\telse\n\t\t\t\trt2[i-b[j]]=min(rt2[i-b[j]],a[j]-1);\n\t\t}\n\t\tfor(j=2;j<=i;++j)\n\t\t{\n\t\t\tlt1[j]=max(lt1[j-1],lt1[j]);\n\t\t\tlt2[j]=max(lt2[j-1],lt2[j]);\n\t\t}\n\t\tfor(j=i-1;j>=1;--j)\n\t\t{\n\t\t\trt1[j]=min(rt1[j+1],rt1[j]);\n\t\t\trt2[j]=min(rt2[j+1],rt2[j]);\n\t\t}\n\t\tfor(j=1;j<=2+2*n+2*i;++j)\n\t\t\thead[j]=0;\n\t\tl=0;\n\t\tfor(j=1;j<=i;++j)\n\t\t{\n\t\t\taddedge(2*n+2*i+1,j,1,0);\n\t\t\taddedge(i+j,2*n+2*i+2,1,0);\n\t\t\tfor(k=1;k<=n;++k)\n\t\t\t{\n\t\t\t\tif(x[k]>=lt1[j]&&x[k]<=rt1[j])\n\t\t\t\t\taddedge(j,2*i+k,1,0);\n\t\t\t\tif(y[k]>=lt2[j]&&y[k]<=rt2[j])\n\t\t\t\t\taddedge(2*i+n+k,i+j,1,0);\n\t\t\t}\n\t\t}\n\t\tfor(j=1;j<=n;++j)\n\t\t\taddedge(2*i+j,2*i+n+j,1,val[j]);\n\t\tcnt=2+2*n+2*i;\n\t\tCost=Flow=0;\n\t\twhile(spfa());\n\t\tif(Flow<i)\n\t\t\tbreak;\n\t\tans=max(ans,Cost);\n\t}\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MV = 815;\nconst int ME = 1200006;\nconst ll oo = 1e18;\n\ntemplate <typename T> void cmin(T &x, const T &y)\n{\n\tif(y < x) x = y;\n}\n\ntemplate <typename T> void cmax(T &x, const T &y)\n{\n\tif(y > x) x = y;\n}\n\ntemplate <typename T> void read(T &x)\n{\n\tx = 0; char c = getchar(); bool f = 0;\n\twhile(!isdigit(c) && c!='-') c = getchar();\n\tif(c == '-') f = 1, c = getchar();\n\twhile(isdigit(c)) x = x*10+c-'0', c = getchar();\n\tif(f) x = -x;\n}\n\nstruct EDGE\n{\n\tint v;\n\tll w;\n\tint c;\n\n\tEDGE (const int &v0 = 0, const ll &w0 = 0, const int &c0 = 0) : v(v0), w(w0), c(c0) {}\n};\n\nstruct GRAPH\n{\n\tint fst[MV], nxt[ME], lnum;\n\tint q[MV], pre[MV], inq[MV];\n\tEDGE e[ME];\n\tll dis[MV];\n\n\tvoid init()\n\t{\n\t\tmemset(fst, 0xff, sizeof(fst));\n\t\tlnum = -1;\n\t}\n\n\tGRAPH () {init();}\n\n\tvoid addeg(int nu, int nv, ll nw, int nc)\n\t{\n\t\tnxt[++lnum] = fst[nu];\n\t\te[lnum] = EDGE(nv, nw, nc);\n\t\tfst[nu] = lnum;\n\t\tnxt[++lnum] = fst[nv];\n\t\te[lnum] = EDGE(nu, -nw, 0);\n\t\tfst[nv] = lnum;\n\t}\n\n\tint spfa(int &flow, ll &cost, int frm, int tar)\n\t{\n\t\tint h=0, t=1, x, y, mxf = ME, now;\n\t\tll cst = 0;\n\t\tmemset(dis, 0x9f, sizeof(dis));\n\t\tmemset(inq, 0, sizeof(inq));\n\t\tmemset(pre, 0, sizeof(pre));\n\t\tq[++h] = frm;\n\t\tdis[frm] = 0;\n\t\tpre[frm] = -1;\n\t\twhile(h >= t)\n\t\t{\n\t\t\tx = q[(t++)%MV];\n\t\t\tinq[x] = 0;\n\t\t\tfor(int i=fst[x]; i!=-1; i=nxt[i])\n\t\t\t{\n\t\t\t\ty = e[i].v;\n\t\t\t\tif(e[i].c && dis[y]<dis[x]+e[i].w)\n\t\t\t\t{\n\t\t\t\t\tdis[y] = dis[x]+e[i].w;\n\t\t\t\t\tpre[y] = i;\n\t\t\t\t\tif(!inq[y]) q[(++h)%MV] = y, inq[y] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dis[tar] < -oo) return 0;\n\t\tnow = pre[tar];\n\t\twhile(now != -1)\n\t\t{\n\t\t\tmxf = min(mxf, e[now].c);\n\t\t\tcst += e[now].w;\n\t\t\tnow = pre[e[now^1].v];\n\t\t}\n\t\tnow = pre[tar];\n\t\twhile(now != -1)\n\t\t{\n\t\t\te[now].c -= mxf;\n\t\t\te[now^1].c += mxf;\n\t\t\tnow = pre[e[now^1].v];\n\t\t}\n\t\tflow += mxf;\n\t\tcost += cst*mxf;\n\t\treturn 1;\n\t}\n\n\tpair<int, ll> mcf(int s, int t)\n\t{\n\t\tint flow = 0;\n\t\tll cost = 0;\n\t\twhile(spfa(flow, cost, s, t));\n\t\treturn make_pair(flow, cost);\n\t}\n} G;\n\nint n, m;\nint lx[MV], rx[MV];\nint ly[MV], ry[MV];\nint px[MV], py[MV];\nll pv[MV];\nchar qc[MV];\nint qa[MV], qb[MV];\nint global_s, global_t;\n\nvoid input()\n{\n\tread(n);\n\tfor(int i=1; i<=n; i++) read(px[i]), read(py[i]), read(pv[i]);\n\tread(m);\n\tfor(int i=1; i<=n; i++) lx[i] = 1, rx[i] = 100, ly[i] = 1, ry[i] = 100;\n\tfor(int i=1; i<=m; i++)\n\t{\n\t\tqc[i] = getchar();\n\t\twhile(!isalpha(qc[i])) qc[i] = getchar();\n\t\tread(qa[i]), read(qb[i]);\n\t}\n}\n\nvoid build(int num)\n{\n\tfor(int i=1; i<=num; i++) lx[i] = ly[i] = 1, rx[i] = ry[i] = 100;\n\tfor(int i=1; i<=m; i++)\n\t{\n\t\tif(qb[i] > num) continue;\n\t\tif(qc[i] == 'L') cmax(lx[qb[i]+1], qa[i]+1);\n\t\tif(qc[i] == 'R') cmin(rx[num-qb[i]], qa[i]-1);\n\t\tif(qc[i] == 'D') cmax(ly[qb[i]+1], qa[i]+1);\n\t\tif(qc[i] == 'U') cmin(ry[num-qb[i]], qa[i]-1);\n\t}\n\tfor(int i=1; i<=num; i++) cmax(lx[i], lx[i-1]), cmax(ly[i], ly[i-1]);\n\tfor(int i=num; i>=1; i--) cmin(rx[i], rx[i+1]), cmin(ry[i], ry[i+1]);\n\tG.init();\n\tfor(int i=1; i<=num; i++)\n\t{\n\t\tfor(int j=1; j<=n; j++)\n\t\t{\n\t\t\tif(lx[i]<=px[j] && px[j]<=rx[i]) G.addeg(i, num*2+j, 0, 1);\n\t\t\tif(ly[i]<=py[j] && py[j]<=ry[i]) G.addeg(num*2+n+j, num+i, 0, 1);\n\t\t}\n\t}\n\tfor(int i=1; i<=n; i++) G.addeg(num*2+i, num*2+n+i, pv[i], 1);\n\tglobal_s = num*2+n*2+1, global_t = global_s+1;\n\tfor(int i=1; i<=num; i++) G.addeg(global_s, i, 0, 1), G.addeg(num+i, global_t, 0, 1);\n}\n\nvoid work()\n{\n\tll ans = 0;\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tbuild(i);\n\t\tauto ret = G.mcf(global_s, global_t);\n\t\tif(ret.first != i) break;\n\t\telse cmax(ans, ret.second);\n\t}\n\tprintf(\"%lld\\n\", ans);\n}\n\nint main()\n{\n\tinput();\n\twork();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define nn 808\n#define ll long long \n\nnamespace ene{\n\tvector<ll> v[nn],cap[nn],cost[nn],rev[nn];\n\tvoid clear()\n\t{\n\t\tfor(ll i=0;i<nn;i++) v[i].clear(),cap[i].clear(),cost[i].clear(),rev[i].clear();\n\t}\n\tvoid link(ll x,ll y,ll c,ll d)\n\t{\n\t\trev[x].push_back(v[y].size());rev[y].push_back(v[x].size());\n\t\tv[x].push_back(y);v[y].push_back(x);\n\t\tcap[x].push_back(c);cap[y].push_back(0);\n\t\tcost[x].push_back(d);cost[y].push_back(-d);\n\t}\n\t\n\tll ss;ll vis[nn];\n\tll prex[nn],prei[nn];ll dist[nn];\n\tvoid spfa(ll s)\n\t{\n\t\tfor(ll i=0;i<nn;i++) dist[i]=-1e18;\n\t\tqueue<ll> q;q.push(s);dist[s]=0;vis[s]=1;\n\t\twhile(q.size())\n\t\t{\n\t\t\tll x=q.front();q.pop();vis[x]=0;\n\t\t\tfor(ll i=0;i<v[x].size();i++)\n\t\t\t{\n\t\t\t\tll y=v[x][i];\n\t\t\t\tif(dist[y]<dist[x]+cost[x][i] and cap[x][i])\n\t\t\t\t{\n\t\t\t\t\tdist[y]=dist[x]+cost[x][i],prex[y]=x,prei[y]=i;\n\t\t\t\t\tif(!vis[y]) q.push(y);vis[y]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll dfs(ll y,ll f)\n\t{\n\t\tif(y==ss) return f;\n\t\tll x=prex[y],i=prei[y],j=rev[x][i];\n\t\tf=dfs(x,min(f,cap[x][i]));\n\t\tcap[x][i]-=f,cap[y][j]+=f;\n\t\treturn f;\n\t}\n\tll solve(ll s,ll t,ll n)\n\t{\n\t\tss=s;ll ans=0;\n\t\twhile(1)\n\t\t{\n\t\t\tspfa(s);if(dist[t]<-1e17) break;\n\t\t\tll tp=dfs(t,1e18);\n\t\t\ttp=min(tp,n);n-=tp;\n\t\t\tans+=tp*dist[t];\n\t\t}\n\t\tif(n) return -1e18;\n\t\treturn ans;\n\t}\n\n};\n\nll n,m;\nll xans[nn],yans[nn];ll val[nn];\nll s=nn-1,t=nn-2;\nll morex[nn],morey[nn],lessx[nn],lessy[nn];\nchar str[nn][3];ll xx[nn],kk[nn];\nll output=0;\nvoid solve(ll guess)\n{\n\tene::clear();set<ll> sx,sy;map<ll,ll> mx,my;\n\tfor(ll i=1;i<=n;i++) sx.insert(xans[i]),sy.insert(yans[i]);\t\n\t\n\tsx.insert(1e16),sy.insert(1e16);\n\t\n\tll tot=0;ll xn,yn;\n\tfor(set<ll>::iterator it=sx.begin();it!=sx.end();it++) mx[*it]=++tot;xn=tot;\n\tfor(set<ll>::iterator it=sy.begin();it!=sy.end();it++) my[*it]=++tot;yn=tot;\n\t\n\tfor(ll i=1;i<=n;i++) ene::link(mx[xans[i]],my[yans[i]],1,val[i]);\n\t\n\tmemset(morex,0x3f,sizeof morex);memset(morey,0x3f,sizeof morey);\n\tmemset(lessx,0,sizeof lessx);memset(lessy,0,sizeof lessy);\n\t\n\tfor(ll i=1;i<=m;i++)\n\t{\n\t\tll x=xx[i],k=kk[i];\n\t\tif(str[i][0]=='R')\n\t\t{\n\t\t\tk++;\n\t\t\tll tx=*sx.lower_bound(x);\n\t\t\tif(k<=xn)morex[k]=min(morex[k],mx[tx]-1);\n\t\t}\n\t\telse if(str[i][0]=='U')\n\t\t{\n\t\t\tk++;k+=xn;\n\t\t\tll ty=*sy.lower_bound(x);\n\t\t\tif(k<=yn)morey[k]=min(morey[k],my[ty]-1);\n\t\t}\n\t\telse if(str[i][0]=='L')\n\t\t{\n\t\t\tk=guess-k;\n\t\t\tll tx=*sx.upper_bound(x);\n\t\t\tif(k>=1)lessx[k]=max(lessx[k],mx[tx]);\n\t\t}\n\t\telse if(str[i][0]=='D')\n\t\t{\n\t\t\tk=guess-k;k+=xn;\n\t\t\tll ty=*sy.upper_bound(x);\n\t\t\tif(k>=xn+1)lessy[k]=max(lessy[k],my[ty]);\n\t\t}\n\t}\n\t\n\t\t\n\tfor(ll i=2;i<=xn;i++) morex[i]=min(morex[i-1],morex[i]);\n\tfor(ll i=xn;i>=2;i--) lessx[i-1]=max(lessx[i-1],lessx[i]); \n\tfor(ll i=xn+2;i<=yn;i++) morey[i]=min(morey[i-1],morey[i]);\n\tfor(ll i=yn;i>=xn+2;i--) lessy[i-1]=max(lessy[i-1],lessy[i]);\n\t//cout<<lessx[2]<<\"\\n\";\n\tfor(ll i=1;i<=guess;i++)\n\t{\n\t\t++tot;ene::link(s,tot,1,0);\n\t\tfor(ll j=1;j<=xn;j++)\n\t\t\tif(j>=lessx[i] and j<=morex[i])\n\t\t\t\tene::link(tot,j,1,0);\n\t}\n\tfor(ll i=xn+1;i<=xn+guess;i++)\n\t{\n\t\t++tot;ene::link(tot,t,1,0);\n\t\tfor(ll j=xn+1;j<=yn;j++)\n\t\t\tif(j>=lessy[i] and j<=morey[i])\n\t\t\t\tene::link(j,tot,1,0);\n\t}\n\t\n//\tif(output>0) cout<<guess<<\"\\n\";\n\toutput=max(output,ene::solve(s,t,guess));\n}\n\nsigned main()\n{\n\tscanf(\"%lld\",&n);for(ll i=1;i<=n;i++) scanf(\"%lld%lld%lld\",&xans[i],&yans[i],&val[i]);\n\tscanf(\"%lld\",&m);for(ll i=1;i<=m;i++) scanf(\"%s%lld%lld\",str[i],&xx[i],&kk[i]);\n\t\n\tfor(ll i=1;i<=n;i++) solve(i);\n\t\n\tcout<<output<<\"\\n\";\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<ctime>\n#include<map>\n#include<bitset>\n#include<set>\n#include<assert.h>\n#define LL long long\n#define mp(x,y) make_pair(x,y)\n#define pll pair<long long,long long>\n#define pii pair<int,int>\n#define SZ(x) ((int)x.size())\nusing namespace std;\ninline LL read()\n{\n\tLL f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint stack[20];\ntemplate<typename T>inline void write(T x)\n{\n\tif(x<0){putchar('-');x=-x;}\n    if(!x){putchar('0');return;}\n    int top=0;\n    while(x)stack[++top]=x%10,x/=10;\n    while(top)putchar(stack[top--]+'0');\n}\ntemplate<typename T>inline void pr1(T x){write(x);putchar(' ');}\ntemplate<typename T>inline void pr2(T x){write(x);putchar('\\n');}\nconst int MAXN=85;\nconst int MAXM=325;\nnamespace Flow\n{\n\tstruct edge{int x,y,c,next;LL d;}a[MAXM*MAXM*4];int len=1,last[MAXN*5];\n\tvoid clear(){len=1;memset(last,0,sizeof(last));}\n\tvoid ins(int x,int y,int c,LL d)\n\t{\n\t\tlen++;a[len].x=x;a[len].y=y;a[len].c=c;a[len].d=d;a[len].next=last[x];last[x]=len;\n\t\tlen++;a[len].x=y;a[len].y=x;a[len].c=0;a[len].d=-d;a[len].next=last[y];last[y]=len;\n\t}\n\tqueue<int> li;\n\tLL d[MAXN*5],S,T;bool vis[MAXN*5];\n\tint pre[MAXN*5],tmp[MAXN*5];\n\tbool spfa()\n\t{\n\t\tmemset(d,-63,sizeof(d));d[S]=0;li.push(S);vis[S]=1;LL INF=d[0];\n\t\twhile(!li.empty())\n\t\t{\n\t\t\tint x=li.front();li.pop();vis[x]=0;\n\t\t\tfor(int k=last[x];k;k=a[k].next)\n\t\t\t{\n\t\t\t\tint y=a[k].y;\n\t\t\t\tif(d[y]<d[x]+a[k].d&&a[k].c)\n\t\t\t\t{\n\t\t\t\t\td[y]=d[x]+a[k].d;pre[y]=x;tmp[y]=k;\n\t\t\t\t\tif(!vis[y])vis[y]=1,li.push(y);\n\t\t\t\t}\n\t\t\t}\n\t\t}return d[T]!=INF;\n\t}\n\tLL mcf()\n\t{\n\t\tLL ret=0;int minn=99999999;\n\t\twhile(spfa())\n\t\t{\n\t\t\tminn=999999999;\n\t\t\tfor(int x=T;x!=S;x=pre[x])minn=min(minn,a[tmp[x]].c);\n\t\t\tret+=d[T]*minn;\n\t\t\tfor(int x=T;x!=S;x=pre[x])a[tmp[x]].c-=minn,a[tmp[x]^1].c+=minn;\n\t\t}return ret;\n\t}\n}\nusing Flow::ins;\nusing Flow::mcf;\nusing Flow::S;\nusing Flow::T;\nusing Flow::clear;\nint n,m;\nconst int pmx=100;\nstruct node{int x,y;LL v;}w[MAXN],ask[MAXM],ask1[MAXM];\nint lx[MAXM],rx[MAXM],ly[MAXM],ry[MAXM];\nLL query(int mx)\n{\n\tclear();\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\task1[i]=ask[i];\n\t\tif(ask[i].v==1||ask[i].v==3)ask1[i].y=mx-ask1[i].y,ask1[i].y=max(ask1[i].y,0);\n\t\telse ask1[i].y=min(ask1[i].y,mx);\n\t}S=2*pmx+2*n+1;T=S+1;\n\tfor(int i=1;i<=n;i++)ins(w[i].x,w[i].y+pmx,1,w[i].v);\n\tmemset(lx,0,sizeof(lx));memset(rx,63,sizeof(rx));memset(ly,0,sizeof(ly));memset(ry,63,sizeof(ry));\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tif(ask1[i].v==1)lx[mx-ask1[i].y+1]=max(lx[mx-ask1[i].y+1],ask1[i].x+1);\n\t\telse if(ask1[i].v==2)rx[mx-ask1[i].y]=min(rx[mx-ask1[i].y],ask1[i].x-1);\n\t\telse if(ask1[i].v==3)ly[mx-ask1[i].y+1]=max(ly[mx-ask1[i].y+1],ask1[i].x+1);\n\t\telse ry[mx-ask1[i].y]=min(ry[mx-ask1[i].y],ask1[i].x-1);\n\t}rx[mx]=min(rx[mx],pmx);ry[mx]=min(ry[mx],pmx);lx[1]=max(lx[1],1);ly[1]=max(ly[1],1);\n\tfor(int i=2;i<=mx;i++)lx[i]=max(lx[i],lx[i-1]),ly[i]=max(ly[i],ly[i-1]);\n\tfor(int i=mx-1;i>=1;i--)rx[i]=min(rx[i],rx[i+1]),ry[i]=min(ry[i],ry[i+1]);\n//\tfor(int i=2;i<=mx;i++)\n//\t{\n//\t\tif(rx[i]!=rx[i-1])lx[i]=max(lx[i],rx[i-1]+1);\n//\t\tif(ry[i]!=ry[i-1])ly[i]=max(ly[i],ry[i-1]+1);\n//\t}\n//\tfor(int i=mx-1;i>=1;i--)\n//\t{\n//\t\tif(lx[i]!=lx[i+1])rx[i]=min(rx[i],lx[i+1]-1);\n//\t\tif(ly[i]!=ly[i+1])ry[i]=min(ry[i],ly[i+1]-1);\t\n//\t}\n\tfor(int i=1;i<=mx;i++)\n\t{\n\t\tif(lx[i]>rx[i]||ly[i]>ry[i])return 0;\n\t\tfor(int j=lx[i];j<=rx[i];j++)ins(2*pmx+i,j,1,0);\n\t\tfor(int j=ly[i];j<=ry[i];j++)ins(j+pmx,2*pmx+n+i,1,0);\n\t}\n\tfor(int i=1;i<=mx;i++)ins(S,2*pmx+i,1,0),ins(2*pmx+n+i,T,1,0);\n\treturn mcf();\n}\nint rd()\n{\n\tchar ch=getchar();while(ch<'A'||ch>'Z')ch=getchar();\n\treturn (ch=='L'?1:(ch=='R'?2:(ch=='D'?3:4)));\n}\nint main()\n{\n\tn=read();\n\tfor(int i=1;i<=n;i++)w[i].x=read(),w[i].y=read(),w[i].v=read();\n\tm=read();\n\tfor(int i=1;i<=m;i++)ask[i].v=rd(),ask[i].x=read(),ask[i].y=read();\n\tLL ans=0;\n\tfor(int i=1;i<=n;i++)\n\t\tans=max(ans,query(i));\n\tpr2(ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 505;\nconst long double eps = 1e-8;\nconst long double INF = 1e99;\ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\ntemplate <typename T> void write(T x) {\n\tif (x < 0) x = -x, putchar('-');\n\tif (x > 9) write(x / 10);\n\tputchar(x % 10 + '0');\n}\ntemplate <typename T> void writeln(T x) {\n\twrite(x);\n\tputs(\"\");\n}\nlong double a[MAXN][MAXN], ans[MAXN];\nint n, m, type, idn[MAXN], idm[MAXN];\nvoid pivot(int l, int e) {\n\tswap(idm[l], idn[e]);\n\tlong double tmp = -a[l][e]; a[l][e] = -1;\n\tfor (int i = 0; i <= n; i++)\n\t\tif (fabs(a[l][i]) > eps) a[l][i] /= tmp;\n\t\telse a[l][i] = 0;\n\tfor (int i = 0; i <= m; i++) {\n\t\tif (i == l || fabs(a[i][e]) <= eps) continue;\n\t\tlong double tmp = a[i][e]; a[i][e] = 0;\n\t\tfor (int j = 0; j <= n; j++)\n\t\t\ta[i][j] += tmp * a[l][j];\n\t}\n}\nlong double simplex() {\n\twhile (true) {\n\t\tint l = m + 1, e = n + 1;\n\t\tidn[e] = idm[l] = n + m + 1;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tif (a[0][i] > eps && idn[i] < idn[e]) e = i;\n\t\tif (e == n + 1) return a[0][0];\n\t\tlong double tmp, Min = INF;\n\t\tfor (int i = 1; i <= m; i++)\n\t\t\tif (a[i][e] < -eps && ((tmp = a[i][0] / -a[i][e]) < Min - eps || tmp < Min + eps && idm[i] < idm[l])) l = i, Min = tmp;\n\t\tif (l == m + 1) {\n\t\t\tprintf(\"Unbounded\\n\");\n\t\t\texit(0);\n\t\t}\n\t\tpivot(l, e);\t\n\t}\n}\nlong double solve() {\n\tfor (int i = 1; i <= n; i++)\n\t\tidn[i] = i;\n\tfor (int i = 1; i <= m; i++)\n\t\tidm[i] = n + i;\n\tint l = 0, Min = 0;\n\tfor (int i = 1; i <= m; i++)\n\t\tif (a[i][0] < Min) {\n\t\t\tMin = a[i][0];\n\t\t\tl = i;\n\t\t}\n\tif (Min == 0) return simplex();\n\tstatic long double tmp[MAXN];\n\tfor (int i = 1; i <= n; i++)\n\t\ttmp[i] = a[0][i], a[0][i] = 0;\n\tidn[++n] = 0; a[0][n] = -1;\n\tfor (int i = 1; i <= m; i++)\n\t\ta[i][n] = 1;\n\tpivot(l, n);\n\tif (simplex() < -eps) {\n\t\tprintf(\"Infeasible\\n\");\n\t\texit(0);\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (idm[i] != 0) continue;\n\t\tfor (int j = 1; j <= n; j++)\n\t\t\tif (fabs(a[i][j]) > eps) {\n\t\t\t\tpivot(i, j);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tbreak;\n\t}\n\tint e = 0;\n\tfor (int i = 1; i <= n; i++)\n\t\tif (idn[i] == 0) e = i;\n\tfor (int i = 0; i <= m; i++)\n\t\tswap(a[i][e], a[i][n]);\n\tswap(idn[e], idn[n--]);\n\tmemset(a[0], 0, sizeof(a[0]));\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (idm[i] > n) continue;\n\t\tfor (int j = 0; j <= n; j++)\n\t\t\ta[0][j] += tmp[idm[i]] * a[i][j];\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tif (idn[i] <= n) a[0][i] += tmp[idn[i]];\n\treturn simplex();\n}\nint x[MAXN], y[MAXN];\nint main() {\n\tread(n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tread(x[i]), read(y[i]);\n\t\tread(a[0][i]);\n\t}\n\tread(m); \n\tfor (int i = 1; i <= m; i++) {\n\t\tchar c; int p, q;\n\t\tscanf(\"\\n%c%d%d\", &c, &p, &q);\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tif (c == 'D' && y[j] <= p) a[i][j] = -1;\n\t\t\tif (c == 'U' && y[j] >= p) a[i][j] = -1;\n\t\t\tif (c == 'L' && x[j] <= p) a[i][j] = -1;\n\t\t\tif (c == 'R' && x[j] >= p) a[i][j] = -1;\n\t\t}\n\t\ta[i][0] = q;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tm++, a[m][0] = 1;\n\t\ta[m][i] = -1;\n\t}\n\tprintf(\"%.0Lf\\n\", solve());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ref(i,x,y)for(int i=x;i<=y;++i)\n#define def(i,x,y)for(int i=x;i>=y;--i)\n#define fi first\n#define se second\n#define int long long\n#define pb push_back\ntypedef long long LL;\nconst int N=301;\nint n,m;\nint lx[2][N],ly[2][N];\nstruct dot{int x,y,v,id;}p[N],px[N],py[N];\nbool cmpx(dot a,dot b){return a.x<b.x;}\nbool cmpy(dot a,dot b){return a.y<b.y;}\nvoid smin(int&a,int b){if(b<a)a=b;}\nvoid smax(int&a,int b){if(b>a)a=b;}\nnamespace eden{\n\tint w[N][N],c[N][N],op,ed;\n\tvoid init(){\n\t\tmemset(w,0,sizeof w);\n\t\tmemset(c,0,sizeof c);\n\t}\n\tvoid add(int x,int y,int ww,int cc){\n\t\tw[x][y]=ww;w[y][x]=0;\n\t\tc[x][y]=cc;c[y][x]=-cc;\n\t}\n\tqueue<int> q;bool vis[N];int dis[N],pre[N];\n\tbool spfa(){\n\t\tref(i,1,ed)dis[i]=(LL)1e18,pre[i]=0;\n\t\tdis[op]=0;q.push(op);\n\t\twhile(!q.empty()){\n\t\t\tint u=q.front();q.pop();vis[u]=0;\n\t\t\tref(v,1,ed)if(w[u][v]&&dis[u]+c[u][v]<dis[v]){\n\t\t\t\tdis[v]=dis[u]+c[u][v];pre[v]=u;\n\t\t\t\tif(!vis[v])vis[v]=1,q.push(v);\n\t\t\t}\n\t\t}\n\t\treturn (dis[ed]<(LL)1e18);\n\t}\n\tpair<int,int> run(){\n\t\tint fw=0,res=0;\n\t\twhile(spfa()){\n\t\t\tfw++;res+=dis[ed];\n\t\t\tfor(int i=ed;i!=op;i=pre[i])\n\t\t\t\tw[pre[i]][i]--,w[i][pre[i]]++;\n\t\t}\n\t\treturn make_pair(fw,res);\n\t}\n}\nsigned main(){\n\tcin>>n;\n\tref(i,1,n)cin>>p[i].x>>p[i].y>>p[i].v;\n\tref(i,1,n)p[i].id=i;\n\tref(i,1,n)px[i]=p[i];\n\tref(i,1,n)py[i]=p[i];\n\tsort(px+1,px+n+1,cmpx);\n\tsort(py+1,py+n+1,cmpy);\n\tcin>>m;\n\tref(i,1,n)lx[0][i]=ly[0][i]=n+1;\n\tref(i,1,n)lx[1][i]=ly[1][i]=0;\n\tref(i,1,m){\n\t\tchar c;int a,b;cin>>c>>a>>b;\n\t\tif(c=='L'){\n\t\t\tint pos=0;\n\t\t\tref(j,1,n)if(px[j].x<=a)pos=j;\n\t\t\tif(pos>b)smin(lx[0][pos-b],pos);\n\t\t}\n\t\tif(c=='R'){\n\t\t\tint pos=n+1;\n\t\t\tdef(j,n,1)if(px[j].x>=a)pos=j;\n\t\t\tif(n+1-pos>b)smax(lx[1][n+1-pos-b],pos);\n\t\t}\n\t\tif(c=='D'){\n\t\t\tint pos=0;\n\t\t\tref(j,1,n)if(py[j].y<=a)pos=j;\n\t\t\tif(pos>b)smin(ly[0][pos-b],pos);\n\t\t}\n\t\tif(c=='U'){\n\t\t\tint pos=n+1;\n\t\t\tdef(j,n,1)if(py[j].y>=a)pos=j;\n\t\t\tif(n+1-pos>b)smax(ly[1][n+1-pos-b],pos);\n\t\t}\n\t}\n\tdef(i,n-1,1)smin(lx[0][i],lx[0][i+1]);\n\tdef(i,n-1,1)smin(ly[0][i],ly[0][i+1]);\n\tdef(i,n-1,1)smax(lx[1][i],lx[1][i+1]);\n\tdef(i,n-1,1)smax(ly[1][i],ly[1][i+1]);\n\tint ans=0,sum=0;\n\tref(i,1,n)ans+=p[i].v,sum+=p[i].v;\n\tref(S,1,n){\n\t\tif(S<n){\n\t\t\tif(lx[0][S+1]<=n||ly[0][S+1]<=n)continue;\n\t\t\tif(lx[1][S+1]>=1&&ly[1][S+1]>=1)continue;\n\t\t}\n\t\tbool fg=1;\n\t\tref(i,1,S)if(lx[1][S+1-i]>lx[0][i]){fg=0;break;}\n\t\tref(i,1,S)if(ly[1][S+1-i]>ly[0][i]){fg=0;break;}\n\t\tif(!fg)continue;\n\t\teden::init();\n\t\teden::op=n+n+n+n+1;eden::ed=eden::op+1;\n\t\tref(i,1,S)ref(j,max(1LL,lx[1][S+1-i]),min(n,lx[0][i]))\n\t\t\teden::add(i,n+px[j].id,1,0);\n\t\tref(i,1,n)eden::add(n+i,n+n+i,1,p[i].v);\n\t\tref(i,1,S)ref(j,max(1LL,ly[1][S+1-i]),min(n,ly[0][i]))\n\t\t\teden::add(n+n+py[j].id,n+n+n+i,1,0);\n\t\tref(i,1,S)eden::add(eden::op,i,1,0);\n\t\tref(i,1,S)eden::add(n+n+n+i,eden::ed,1,0);\n\t\tpair<int,int> pp=eden::run();\n\t\tif(pp.fi==S)ans=min(ans,pp.se);\n\t}\n\tcout<<sum-ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nint S=0,T;\nint N;\nstruct edge{\n\tint s,t,cap;long long v;int nxt;\n}e[50005];\nint e_cnt,last[405];\nvoid addedge(int u,int v,int cap,long long l){\n\te[e_cnt]=(edge){u,v,cap,l,last[u]};\n\tlast[u]=e_cnt++;\n\te[e_cnt]=(edge){v,u,0,-l,last[v]};\n\tlast[v]=e_cnt++;\n}\nlong long d[405];int fa[405];\nbool vis[405];\n#define LIM -2e15\nbool dij(){\n\tfor(int i=0;i<=T;i++)d[i]=LIM;\n\tmemset(vis,0,sizeof(vis));\n\td[S]=0;\n\tfor(int i=0;i<=T;i++){\n\t\tint x=-1;\n\t\tfor(int j=0;j<=T;j++)if(!vis[j]&&(x==-1||d[j]>d[x]))x=j;\n\t\tif(x==-1)break;\n\t\tvis[x]=1;\n\t\tfor(int i=last[x];i!=-1;i=e[i].nxt)if(!vis[e[i].t]&&e[i].cap&&d[e[i].t]<d[x]+e[i].v){\n\t\t\t//assert(e[i].v<=0);\n\t\t\td[e[i].t]=d[x]+e[i].v;\n\t\t\tfa[e[i].t]=i;\n\t\t}\n\t}\n\treturn d[T]>LIM;\n}\npair<int,long long> solve(){\n\tint flow=0;long long cost=0;long long r=0;\n\twhile(dij()){\n\t\tflow++;\n\t\tint u=T;\n\t\twhile(u!=S){\n\t\t\te[fa[u]].cap=0;\n\t\t\te[fa[u]^1].cap=1;\n\t\t\tu=e[fa[u]].s;\n\t\t}\n\t\tr+=d[T];\n\t\tcost+=r;\n\t\tfor(int i=0;i<e_cnt;i++)e[i].v=d[e[i].s]+e[i].v-d[e[i].t];\n\t}\n\treturn make_pair(flow,cost);\n}\nint x[85],y[85];long long v[85];\nint t[325],a[325],b[325];\nint L[85][2],R[85][2];\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d%d%lld\",&x[i],&y[i],&v[i]);\n\t}\n\tint m;\n\tscanf(\"%d\",&m);\n\tfor(int i=1;i<=m;i++){\n\t\tchar c=getchar();\n\t\twhile(c<'A'||c>'Z')c=getchar();\n\t\tif(c=='L')t[i]=0;\n\t\tif(c=='R')t[i]=1;\n\t\tif(c=='D')t[i]=2;\n\t\tif(c=='U')t[i]=3;\n\t\tscanf(\"%d%d\",&a[i],&b[i]);\n\t}\n\tlong long ans=0;\n\tfor(int supy=1;supy<=n;supy++){\n\t\tmemset(R,63,sizeof(R));\n\t\tfor(int j=1;j<=m;j++)if(b[j]<supy){\n\t\t\tif(t[j]&1)R[supy-b[j]][t[j]>>1]=min(R[supy-b[j]][t[j]>>1],a[j]-1);\n\t\t\telse L[b[j]+1][t[j]>>1]=max(L[b[j]+1][t[j]>>1],a[j]+1);\n\t\t}\n\t\tfor(int i=2;i<=supy;i++)for(int j=0;j<2;j++)L[i][j]=max(L[i][j],L[i-1][j]);\n\t\tfor(int i=supy-1;i>0;i--)for(int j=0;j<2;j++)R[i][j]=min(R[i][j],R[i+1][j]);\n\t\t// for(int i=1;i<=supy;i++)printf(\"%d %d\\n\",L[i][0],R[i][0]);\n\t\t// for(int i=1;i<=supy;i++)printf(\"%d %d\\n\",L[i][1],R[i][1]);\n\t\tT=2*supy+2*n+1;\n\t\te_cnt=0;\n\t\tmemset(last,-1,sizeof(last));\n\t\tfor(int i=1;i<=supy;i++)addedge(S,i,1,0),addedge(i+supy,T,1,0);\n\t\tfor(int i=1;i<=n;i++)addedge(i+2*supy,i+n+2*supy,1,v[i]-1e15);\n\t\tfor(int i=1;i<=supy;i++)\n\t\t\tfor(int j=1;j<=n;j++)if(x[j]>=L[i][0]&&x[j]<=R[i][0])addedge(i,j+2*supy,1,0);\n\t\tfor(int i=1;i<=supy;i++)\n\t\t\tfor(int j=1;j<=n;j++)if(y[j]>=L[i][1]&&y[j]<=R[i][1])addedge(j+n+2*supy,i+supy,1,0);\n\t\tpair<int,long long>res=solve();\n\t\t// printf(\"%d %d %lld\\n\",supy,res.first,res.second);\n\t\tres.second+=supy*1e15;\n\t\tif(res.first==supy)ans=max(ans,res.second);\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<map>\n#include<bitset>\n#include<set>\n#define N (100010)\n#define P ()\n#define M ()\n#define inf (0x7f7f7f7f)\n#define rg register int\n#define Label puts(\"NAIVE\")\n#define spa print(' ')\n#define ent print('\\n')\n#define rand() (((rand())<<(15))^(rand()))\n#define file(s) freopen(s\".in\",\"r\",stdin),freopen(s\".out\",\"w\",stdout)\ntypedef long double ld;\ntypedef long long LL;\ntypedef unsigned long long ull;\nusing namespace std;\nnamespace fastIO1{\n\tinline char read(){\n\t\tstatic const int IN_LEN=1000000;\n\t\tstatic char buf[IN_LEN],*s,*t;\n\t\treturn (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);\n\t}\n\ttemplate<class T>\n\tinline void read(T &x){\n\t\tstatic bool iosig;\n\t\tstatic char c;\n\t\tfor(iosig=false,c=read();!isdigit(c);c=read()){\n\t\t\tif(c=='-')iosig=true;\n\t\t\tif(c==-1)return;\n\t\t}\n\t\tfor(x=0;isdigit(c);c=read())x=((x+(x<<2))<<1)+(c^'0');\n\t\tif(iosig)x=-x;\n\t}\n\tinline char readc(char &c){\n\t\tfor(c=read();!isalpha(c)&&!isdigit(c);c=read())\n\t\tif(c==-1)return 0;\n\t}\n\tconst int OUT_LEN = 10000000;\n\tchar obuf[OUT_LEN],*ooh=obuf;\n\tinline void print(char c){\n\t\tif(ooh==obuf+OUT_LEN)fwrite(obuf,1,OUT_LEN,stdout),ooh=obuf;\n\t\t*ooh++=c;\n\t}\n\ttemplate<class T>\n\tinline void print(T x){\n\t\tstatic int buf[30],cnt;\n\t\tif(x==0)print('0');\n\t\telse{\n\t\t\tif(x<0)print('-'),x=-x;\n\t\t\tfor(cnt=0;x;x/=10)buf[++cnt]=x%10+48;\n\t\t\twhile(cnt)print((char)buf[cnt--]);\n\t\t}\n\t}\n\tinline void flush(){fwrite(obuf,1,ooh-obuf,stdout);}\n}\nnamespace fastIO2{\n\ttemplate<class T>\n\tinline void read(T &x){\n\t\tstatic bool iosig;\n\t\tstatic char c;\n\t\tfor(iosig=false,c=getchar();!isdigit(c);c=getchar()){\n\t\t\tif(c=='-')iosig=true;\n\t\t\tif(c==-1)return;\n\t\t}\n\t\tfor(x=0;isdigit(c);c=getchar())x=((x+(x<<2))<<1)+(c^'0');\n\t\tif(iosig)x=-x;\n\t}\n}\nusing namespace fastIO1;\nstruct limits{int l,op,x;}q[N];\nstruct points{int x,y;LL w;}a[N];\nint n,m,E=1,S,T,V,fl,lx[N],rx[N],ly[N],ry[N];\nint fi[N],ne[N],b[N],cap[N],pre[N],prv[N];\nbool vis[N]; LL ans,mx,ot,c[N],dis[N];\nvoid add(int x,int y,int cp,LL cost){\n//\tprintf(\"%d--%lld-->%d\\n\",x,cost,y);\n\tne[++E]=fi[x],fi[x]=E,b[E]=y;\n\tcap[E]=cp,c[E]=cost;\n\tne[++E]=fi[y],fi[y]=E,b[E]=x;\n\tcap[E]=0,c[E]=-cost;\n}\nvoid mcmf(int S,int T,int flow,int cnt){\n\twhile(flow){\n\t\tfor(int i=1;i<=V;i++)dis[i]=inf,vis[i]=0;\n\t\tdis[S]=0; queue<int> Q; Q.push(S),vis[S]=1;\n\t\twhile(!Q.empty()){\n\t\t\tint u=Q.front();Q.pop(),vis[u]=0;\n\t\t\tif(dis[u]==inf)continue;\n\t\t\tfor(int i=fi[u];i;i=ne[i]){\n\t\t\t\tint v=b[i];\n\t\t\t\tif(cap[i]>0&&dis[u]+c[i]<dis[v]){\n                    dis[v]=dis[u]+c[i];\n                    prv[v]=u,pre[v]=i;\n                    if(!vis[v])Q.push(v),vis[v]=1;\n                }\n\t\t\t}\n\t\t}\n\t\tif(dis[T]==inf)break;\n\t\tint w=flow;\n\t\tfor(int i=T;i!=S;i=prv[i])\n\t\tw=min(w,cap[pre[i]]);\n\t\tflow-=w,mx+=w*dis[T],fl+=w;\n//\t\tif(fl==cnt)ans=min(ans,mx);\n\t\tfor(int i=T;i!=S;i=prv[i]){\n\t\t\tint e=pre[i];\n\t\t\tcap[e]-=w,cap[e^1]+=w;\n\t\t}\n\t}\n}\nvoid solve(int cnt){\n\tmemset(fi,0,n*32),E=1;\n\tmemset(rx,inf,(n+3)<<2);\n\tmemset(lx,0,(n+3)<<2);\n\tmemset(ry,inf,(n+3)<<2);\n\tmemset(ly,0,(n+3)<<2);\n//\tcout<<cnt<<endl;\n\tfor(int j=1;j<=m;j++){\n\t\tint t=(q[j].op&1)?q[j].x+1:cnt-q[j].x;\n//\t\tcout<<j<<\" \"<<t<<endl;\n\t\tif(t>cnt||t<=0)continue;\n\t\t\n\t\tif(q[j].op==1)lx[t]=max(lx[t],q[j].l+1);\n\t\telse if(q[j].op==2)rx[t]=min(rx[t],q[j].l-1);\n\t\telse if(q[j].op==3)ly[t]=max(ly[t],q[j].l+1);\n\t\telse ry[t]=min(ry[t],q[j].l-1);\n\t}\n\tfor(int i=2;i<=cnt;i++)lx[i]=max(lx[i-1],lx[i]),ly[i]=max(ly[i-1],ly[i]);\n\tfor(int i=cnt;i;i--)rx[i]=min(rx[i+1],rx[i]),ry[i]=min(ry[i+1],ry[i]);\n//\tfor(int j=1;j<=cnt;j++)cout<<lx[j]<<\" \"<<rx[j]<<endl;\n//\tfor(int j=1;j<=cnt;j++)cout<<ly[j]<<\" \"<<ry[j]<<endl;\n//\tfor(int j=1;j<=cnt;j++)cout<\n\tS=2*(n+cnt)+1,T=S+1,V=T;\n\tfor(int i=1;i<=n;i++)add(i,i+n,1,-a[i].w);\n\tfor(int i=1;i<=cnt;i++){\n\t\tif(lx[i]>rx[i]||ly[i]>ry[i])return;\n\t\tfor(int j=1;j<=n;j++)\n\t\tif(lx[i]<=a[j].x&&a[j].x<=rx[i])\n\t\tadd(i+2*n,j,1,0);\n\t\tfor(int j=1;j<=n;j++)\n\t\tif(ly[i]<=a[j].y&&a[j].y<=ry[i])\n\t\tadd(j+n,i+2*n+cnt,1,0);\n\t\tadd(S,i+2*n,1,0),add(i+2*n+cnt,T,1,0);\n\t}\n\tmx=0,mcmf(S,T,inf,cnt),ot=max(ot,-mx);\n//\tcout<<fl<<\" \"<<mx<<endl;\n//\tcout<<\"ans=\"<<-ans<<endl;\n//\tputs(\"--------------\");\n}\nint main(){\n\tread(n);\n\tfor(int i=1;i<=n;i++)read(a[i].x),read(a[i].y),read(a[i].w); read(m);\n\tfor(int i=1;i<=m;i++){\n\t\tchar ch; readc(ch),read(q[i].l),read(q[i].x);\n\t\tq[i].op=(ch=='L')?1:ch=='R'?2:ch=='D'?3:4;\n\t}\n\tfor(int i=1;i<=n;i++)solve(i); cout<<ot;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstring>\n#include <cstdio>\nusing ll = long long;\nint lst[405], to[200005], pre[200005], cap[200005], tot;\nint que[2000005], path[405], sum[405];\nbool in[405], vis[405];\nll dis[405], cost[200005];\ninline void add_edge(int u, int v, int _cap, ll _cost)\n{\n\tauto _add = [&] (int x, int y, int ca, ll co)\n\t{\n\t\tto[tot] = y;\n\t\tpre[tot] = lst[x];\n\t\tcap[tot] = ca;\n\t\tcost[tot] = co;\n\t\tlst[x] = tot++;\n\t};\n\t_add(u, v, _cap, _cost);\n\t_add(v, u, 0, -_cost);\n}\nint dfs(int u, int t, int rem)\n{\n\tif (u == t)\n\t\treturn rem;\n\tvis[u] = true;\n\tint ans = 0;\n\tfor (int i = lst[u]; ~i; i = pre[i])\n\t{\n\t\tif (vis[to[i]] || !cap[i] || dis[to[i]] != dis[u] + cost[i])\n\t\t\tcontinue;\n\t\tint v = to[i], res = dfs(v, t, std::min(rem - ans, cap[i]));\n\t\tcap[i] -= res;\n\t\tcap[i ^ 1] += res;\n\t\tans += res;\n\t\tif (ans == rem)\n\t\t\treturn ans;\n\t}\n\treturn ans;\n}\ninline ll min_cost_max_flow(int s, int t)\n{\n\tll res = 0;\n\twhile (true)\n\t{\n\t\tmemset(dis, 0x3f, sizeof(dis));\n\t\tmemset(in, false, sizeof(in));\n\t\tint he = 0, ta = 0;\n\t\tque[ta++] = s;\n\t\tdis[s] = 0;\n\t\tin[s] = true;\n\t\tauto update = [&] { if (he < ta && dis[que[he]] > dis[que[ta - 1]]) std::swap(que[he], que[ta - 1]); };\n\twhile (he < ta)\n\t\t{\n\t\t\tint u = que[he++];\n\t\t\tin[u] = false;\n\t\t\tupdate();\n\t\t\tfor (int i = lst[u]; ~i; i = pre[i])\n\t\t\t{\n\t\t\t\tif (cap[i] && dis[to[i]] > dis[u] + cost[i])\n\t\t\t\t{\n\t\t\t\t\tpath[to[i]] = i;\n\t\t\t\t\tdis[to[i]] = dis[u] + cost[i];\n\t\t\t\t\tif (!in[to[i]])\n\t\t\t\t\t{\n\t\t\t\t\t\tin[to[i]] = true;\n\t\t\t\t\t\tque[ta++] = to[i];\n\t\t\t\t\t\tupdate();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dis[t] >= 1e18)\n\t\t\tbreak;\n\t\twhile (true)\n\t\t{\n\t\t\tfor (int i = 0; i < ta; i++)\n\t\t\t\tvis[que[i]] = false;\n\t\t\tint mn = dfs(s, t, 1e9);\n\t\t\tif (!mn)\n\t\t\t\tbreak;\n\t\t\tres += mn * dis[t];\n\t\t}\n\t}\n\treturn res;\n}\nconstexpr int LIM = 100;\nstruct { int x, y; ll w; } arr[405];\nstruct { char tp; int a, b; } qry[405];\nint xl[405], xr[405], yl[405], yr[405];\nint main()\n{\n\t// freopen(\"AGC031-E.in\", \"r\", stdin);\n\tint n, q;\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(\"%d%d%lld\", &arr[i].x, &arr[i].y, &arr[i].w);\n\tscanf(\"%d\", &q);\n\tfor (int i = 0; i < q; i++)\n\t\tscanf(\" %c%d%d\", &qry[i].tp, &qry[i].a, &qry[i].b);\n\tll ans = 0;\n\tfor (int k = 1; k <= n; k++)\n\t{\n\t\tfor (int i = 1; i <= k; i++)\n\t\t{\n\t\t\txl[i] = yl[i] = 0;\n\t\t\txr[i] = yr[i] = LIM;\n\t\t}\n\t\tfor (int i = 0; i < q; i++)\n\t\t{\n\t\t\tif (qry[i].b >= k)\n\t\t\t\tcontinue;\n\t\t\tif (qry[i].tp == 'L' || qry[i].tp == 'D')\n\t\t\t{\n\t\t\t\tint *res = qry[i].tp == 'L' ? xl : yl;\n\t\t\t\tres[qry[i].b + 1] = std::max(res[qry[i].b + 1], qry[i].a + 1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint *res = qry[i].tp == 'R' ? xr : yr;\n\t\t\t\tres[k - qry[i].b] = std::min(res[k - qry[i].b], qry[i].a - 1);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 2; i <= k; i++)\n\t\t{\n\t\t\txl[i] = std::max(xl[i], xl[i - 1]);\n\t\t\tyl[i] = std::max(yl[i], yl[i - 1]);\n\t\t}\n\t\tfor (int i = k - 1; i; i--)\n\t\t{\n\t\t\txr[i] = std::min(xr[i], xr[i + 1]);\n\t\t\tyr[i] = std::min(yr[i], yr[i + 1]);\n\t\t}\n\t\tmemset(lst, -1, sizeof(lst));\n\t\ttot = 0;\n\t\tfor (int i = 1; i <= k; i++)\n\t\t{\n\t\t\tadd_edge(0, i, 1, 0);\n\t\t\tadd_edge(k + i, k * 2 + LIM * 2 + 1, 1, 0);\n\t\t\tfor (int j = xl[i]; j <= xr[i]; j++)\n\t\t\t\tadd_edge(i, k * 2 + j, 1, 0);\n\t\t\tfor (int j = yl[i]; j <= yr[i]; j++)\n\t\t\t\tadd_edge(k * 2 + LIM + j, k + i, 1, 0);\n\t\t}\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tadd_edge(k * 2 + arr[i].x, k * 2 + LIM + arr[i].y, 1, -arr[i].w);\n\t\tans = std::max(ans, -min_cost_max_flow(0, k * 2 + LIM * 2 + 1));\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,a,b) for(int i=(a);i<(b);i++)\n#define pb push_back\n#define eb emplace_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n\nusing vint=vector<int>;\nusing pint=pair<int,int>;\nusing vpint=vector<pint>;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\ntemplate<class A,class B>\nostream& operator<<(ostream& ost,const pair<A,B>&p){\n    ost<<\"{\"<<p.first<<\",\"<<p.second<<\"}\";\n    return ost;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& ost,const vector<T>&v){\n    ost<<\"{\";\n    for(int i=0;i<v.size();i++){\n        if(i)ost<<\",\";\n        ost<<v[i];\n    }\n    ost<<\"}\";\n    return ost;\n}\n\nstruct PrimalDual{\n    using F=long long;\n    static const F INF;\n    \n    struct Edge{\n        int to;\n        F cap,cost;\n        int rev;\n        Edge(int to,F cap,F cost,int rev):to(to),cap(cap),cost(cost),rev(rev){}\n    };\n    \n    int n;\n    vector<vector<Edge>>G;\n\n    PrimalDual(int n):n(n),G(n){}\n\n    void addEdge(int from,int to,F cap,F cost){\n        G[from].push_back(Edge(to,cap,cost,G[to].size()));\n        G[to].push_back(Edge(from,0,-cost,G[from].size()-1));\n    }\n\n\n    F minCostFlow(int s,int t,F f){\n        F cur=0;\n\n        vector<F>h(n);\n        vector<int>prevv(n,-1),preve(n,-1);\n        vector<F>dist(n);\n        priority_queue<pair<F,int>,vector<pair<F,int>>,greater<pair<F,int>>>que;\n        \n        /*\n        fill(h.begin(),h.end(),INF);\n        h[s]=0;\n        while(true){\n            bool update=false;\n            for(int v=0;v<n;v++){\n                for(auto &e:G[v]){\n                    if(e.cap&&h[e.to]>h[v]+e.cost){\n                        update=true;\n                        h[e.to]=h[v]+e.cost;\n                    }\n                }\n            }\n            if(!update)break;\n        }\n        */\n\n\n        while(f>0){\n            fill(dist.begin(),dist.end(),INF);\n            dist[s]=0;\n            que.emplace(0,s); \n            while(que.size()){\n                F d;\n                int v;\n                tie(d,v)=que.top();\n                que.pop();\n                if(dist[v]<d)continue;\n                for(int i=0;i<G[v].size();i++){\n                    Edge &e=G[v][i];\n                    F nd=dist[v]+e.cost+h[v]-h[e.to];\n                    if(e.cap>0&&dist[e.to]>nd){\n                        dist[e.to]=nd;\n                        prevv[e.to]=v;preve[e.to]=i;\n                        que.emplace(nd,e.to);\n                    }\n                }\n            }\n            if(dist[t]==INF)return INF;\n            for(int v=0;v<n;v++)h[v]+=dist[v];\n            F nf=f;\n            for(int v=t;v!=s;v=prevv[v]){\n                nf=min(nf,G[prevv[v]][preve[v]].cap);\n            }\n            f-=nf;\n            cur+=nf*h[t];\n            for(int v=t;v!=s;v=prevv[v]){\n                Edge &e=G[prevv[v]][preve[v]];\n                e.cap-=nf;\n                G[v][e.rev].cap+=nf;\n            }\n        }\n        return cur;\n    }\n};\nconst PrimalDual::F PrimalDual::INF=1ll<<50;\n\nint N;\nint X[111],Y[111],V[111];\nint M;\nchar T[333];\nint A[333],B[333];\n\nconst int LIM=1000000000000000;\n\nint solve(int num){\n    vint capX(100,PrimalDual::INF),capY(100,PrimalDual::INF);\n    vint lowX(100),lowY(100);\n\n    PrimalDual pd(200+4);\n    int src=200;\n    int snk=201;\n    int supersrc=202;\n    int supersnk=203;\n    rep(i,M){\n        if(T[i]=='U'){\n            if(B[i]>num)continue;\n            if(A[i]==0)continue;\n            lowY[A[i]-1]=num-B[i];\n        }\n        if(T[i]=='D'){\n            capY[A[i]]=B[i];\n        }\n        \n        if(T[i]=='L'){\n            capX[A[i]]=B[i];\n        }\n        \n        if(T[i]=='R'){\n            if(B[i]>num)continue;\n            if(A[i]==0)continue;\n            lowX[A[i]-1]=num-B[i];\n        }\n    }\n\n    /*\n    rep(i,100){\n        if(capX[i]!=PrimalDual::INF)cout<<\"capX \"<<i<<\" \"<<capX[i]<<endl;\n        if(lowX[i])cout<<\"lowX \"<<i<<\" \"<<lowX[i]<<endl;\n    }\n    rep(i,100){\n        if(capY[i]!=PrimalDual::INF)cout<<\"capY \"<<i<<\" \"<<capY[i]<<endl;\n        if(lowY[i])cout<<\"lowY \"<<i<<\" \"<<lowY[i]<<endl;\n    }*/\n\n\n    int f=num;\n\n    rep(i,100){\n        if(capX[i]<lowX[i])return 0;\n        int from,to=i;\n        if(i==99)from=src;\n        else from=i+1;\n        \n        pd.addEdge(from,to,capX[i]-lowX[i],0);\n        pd.addEdge(supersrc,to,lowX[i],0);\n        pd.addEdge(from,supersnk,lowX[i],0);\n        f+=lowX[i];\n    }\n    \n    rep(i,100){\n        if(capY[i]<lowY[i])return 0;\n        int from=i+100,to;\n        if(i==99)to=snk;\n        else to=i+1+100;\n        \n        pd.addEdge(from,to,capY[i]-lowY[i],0);\n        pd.addEdge(supersrc,to,lowY[i],0);\n        pd.addEdge(from,supersnk,lowY[i],0);\n        f+=lowY[i];\n    }\n    rep(i,N){\n        pd.addEdge(X[i],Y[i]+100,1,LIM-V[i]);\n    }\n    pd.addEdge(supersrc,src,num,0);\n    pd.addEdge(snk,supersnk,num,0);\n\n    int tmp=pd.minCostFlow(supersrc,supersnk,f);\n    if(tmp==PrimalDual::INF)return 0;\n    tmp-=LIM*num;\n    tmp*=-1;\n    return tmp;\n}\n\nsigned main(){\n    scanf(\"%lld\",&N);\n    rep(i,N)scanf(\"%lld%lld%lld\",&X[i],&Y[i],&V[i]),X[i]--,Y[i]--;\n\n    scanf(\"%lld\",&M);\n    rep(i,M)scanf(\" %c%lld%lld\",&T[i],&A[i],&B[i]),A[i]--;\n\n\n\n    int ans=0;\n    for(int i=1;i<=N;i++)chmax(ans,solve(i));\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#define R register\n#define LL long long\n#define max(_i_,_j_) ((_i_)>(_j_)?(_i_):(_j_))\n#define min(_i_,_j_) ((_i_)<(_j_)?(_i_):(_j_))\nchar Is[1<<22],*Ss=Is;\ninline int read()\n{\n\tR char ch;\n\twhile((ch=*Ss++)<48||ch>57);R int in=ch^48;\n\twhile((ch=*Ss++)>47&&ch<58)in=(in<<1)+(in<<3)+(ch^48);\n\treturn in;\n}\ninline LL readll()\n{\n\tR char ch;\n\twhile((ch=*Ss++)<48||ch>57);R LL in=ch^48;\n\twhile((ch=*Ss++)>47&&ch<58)in=(in<<1)+(in<<3)+(ch^48);\n\treturn in;\n}\ninline char gettype()\n{\n\tR char ch;\n\twhile((ch=*Ss++)!='U'&&ch!='D'&&ch!='L'&&ch!='R');\n\treturn ch;\n}\nint n,m;\nstruct point\n{\n\tint x,y;\n\tLL v;\n}p[111];\nint lm[111],rm[111],um[111],dm[111];\nint first[333],next[66666],to[66666],f[66666],deg[333];\nLL w[66666];\nint S,T,ecnt;\nLL fee;\nint gu;\ninline void connect(int u,int v,int mnf,int mxf,LL cost)\n{\n\tdeg[u]+=mnf,deg[v]-=mnf;\n\t++ecnt,\n\tnext[ecnt<<1]=first[u],first[u]=ecnt<<1,to[ecnt<<1]=v,f[ecnt<<1]=mxf-mnf,w[ecnt<<1]=cost,\n\tnext[ecnt<<1|1]=first[v],first[v]=ecnt<<1|1,to[ecnt<<1|1]=u,f[ecnt<<1|1]=0,w[ecnt<<1|1]=-cost;\n}\nint que[65540];\nunsigned head,tail;\nLL dis[333],ans;\nbool vis[333];\nbool SPFA()\n{\n\thead=tail=0;\n\tmemset(dis,63,(T+1)<<3);\n\tque[++tail]=S;\n\tdis[S]=0;\n\tfor(R int now;head!=tail;)\n\t{\n\t\tnow=que[++head];\n\t\tvis[now]=0;\n\t\tfor(R int i=first[now];i;i=next[i])\n\t\t\tif(f[i]&&dis[to[i]]>dis[now]+w[i])\n\t\t\t\tdis[to[i]]=dis[now]+w[i],\n\t\t\t\t!vis[to[i]]?que[++tail]=to[i],vis[to[i]]=1:0;\n\t}\n\treturn dis[T]<(1ll<<60ll);\n}\nint cur[333];\nint DFS(int now,int flow)\n{\n\tif(now==T)return flow;\n\tvis[now]=1;\n\tint re=0;\n\tfor(R int &i=cur[now];i;i=next[i])\n\t\tif(f[i]&&!vis[to[i]]&&dis[to[i]]==dis[now]+w[i])\n\t\t{\n\t\t\tint tmp=DFS(to[i],min(flow-re,f[i]));\n\t\t\tre+=tmp,\n\t\t\tf[i]-=tmp,\n\t\t\tf[i^1]+=tmp,\n\t\t\tfee+=w[i]*tmp;\n\t\t\tif(re==flow)\n\t\t\t{\n\t\t\t\tvis[now]=0;\n\t\t\t\treturn re;\n\t\t\t}\n\t\t}\n\tif(!re)dis[now]=(1ll<<60ll);\n\tvis[now]=0;\n\treturn re;\n}\nint Dinic()\n{\n\tint maxflow=0;\n\twhile(SPFA())\n\t\tmemcpy(cur,first,T<<2),\n\t\tmaxflow+=DFS(S,233);\n\treturn maxflow;\n}\nint main()\n{\n\tfread(Is,1,1<<22,stdin);\n\tn=read();\n\tfor(R int i=1;i<=n;++i)\n\t\tp[i].x=read(),p[i].y=read(),p[i].v=readll();\n\tfor(R int i=0;i<=101;++i)\n\t\tlm[i]=rm[i]=um[i]=dm[i]=n;\n\tm=read();\n\tfor(R int i=1;i<=m;++i)\n\t{\n\t\tR char type=gettype();\n\t\tR int a=read(),b=read();\n\t\tif(type=='U')um[a]=b;\n\t\telse if(type=='D')dm[a]=b;\n\t\telse if(type=='L')lm[a]=b;\n\t\telse if(type=='R')rm[a]=b;\n\t}\n\tfor(R int tot=1;tot<=n;++tot)\n\t{\n\t\tmemset(first,0,233<<2),\n\t\tmemset(deg,0,233<<2),\n\t\tecnt=0,gu=0;\n\t\tfor(R int i=1;i<=101;++i)\n\t\t{\n\t\t\tif(tot-lm[i-1]>rm[i])break;\n\t\t\tconnect(i-1,i,tot-lm[i-1],rm[i],0);\n\t\t}\n\t\tfor(R int i=1;i<=101;++i)\n\t\t{\n\t\t\tif(tot-um[i]>dm[i-1])break;\n\t\t\tconnect(101+i,101+i+1,tot-um[i],dm[i-1],0);\n\t\t}\n\t\tfor(R int i=1;i<=n;++i)\n\t\t\tconnect(p[i].x,101+p[i].y+1,0,1,-p[i].v);\n\t\tdeg[0]-=tot,deg[203]+=tot;\n\t\tS=204,T=205;\n\t\tfee=0;\n\t\tfor(R int i=0;i<=203;++i)\n\t\t{\n\t\t\tif(deg[i]>0)\n\t\t\t\tconnect(i,T,0,deg[i],0),\n\t\t\t\tgu+=deg[i];\n\t\t\telse if(deg[i]<0)\n\t\t\t\tconnect(S,i,0,-deg[i],0);\n\t\t}\n\t\tif(Dinic()!=gu)break;\n\t\t-fee>ans?ans=-fee:0;\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "/* cerberus97 - Hanit Banga */\n\n#include <iostream>\n#include <iomanip>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define pb push_back\n#define fast_cin() ios_base::sync_with_stdio(false); cin.tie(NULL)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\n\n// Push-Relabel implementation of the cost-scaling algorithm\n// Runs in O( <max_flow> * log(V * max_edge_cost)) = O( V^3 * log(V * C))\n// Operates on integers\n\ntemplate<typename flow_t = int, typename cost_t = int>\nstruct mcSFlow{\n    struct Edge{\n        cost_t c;\n        flow_t f;\n        int to, rev;\n        Edge(int _to, cost_t _c, flow_t _f, int _rev):c(_c), f(_f), to(_to), rev(_rev){}\n    };\n    const cost_t INFCOST = numeric_limits<cost_t>::max()/2;\n    const cost_t INFFLOW = numeric_limits<flow_t>::max()/2;\n    cost_t epsilon;\n    int N, S, T;\n    vector<vector<Edge> > G;\n    vector<unsigned int> isEnqueued, state;\n    mcSFlow(int _N, int _S, int _T):epsilon(0), N(_N), S(_S), T(_T), G(_N){}\n    void add_edge(int a, int b, cost_t cost, flow_t cap){\n        if(a==b){assert(cost>=0); return;}\n        cost*=N;// to preserve integer-values\n        epsilon = max(epsilon, abs(cost));\n        assert(a>=0&&a<N&&b>=0&&b<N);\n        G[a].emplace_back(b, cost, cap, G[b].size());\n        G[b].emplace_back(a, -cost, 0, G[a].size()-1);\n    }\n    flow_t calc_max_flow(){ // Dinic max-flow\n        vector<flow_t> dist(N), state(N);\n        vector<Edge*> path(N);\n        auto cmp = [](Edge*a, Edge*b){return a->f < b->f;};\n        flow_t addFlow, retflow=0;;\n        do{\n            fill(dist.begin(), dist.end(), -1);\n            dist[S]=0;\n            auto head = state.begin(), tail = state.begin();\n            for(*tail++ = S;head!=tail;++head){\n                for(Edge const&e:G[*head]){\n                    if(e.f && dist[e.to]==-1){\n                        dist[e.to] = dist[*head]+1;\n                        *tail++=e.to;\n                    }\n                }\n            }\n            addFlow = 0;\n            fill(state.begin(), state.end(), 0);\n            auto top = path.begin();\n            Edge dummy(S, 0, INFFLOW, -1);\n            *top++ = &dummy;\n            while(top != path.begin()){\n                int n = (*prev(top))->to;\n                if(n==T){\n                    auto next_top = min_element(path.begin(), top, cmp);\n                    flow_t flow = (*next_top)->f;\n                    while(--top!=path.begin()){\n                        Edge &e=**top, &f=G[e.to][e.rev];\n                        e.f-=flow;\n                        f.f+=flow;\n                    }\n                    addFlow=1;\n                    retflow+=flow;\n                    top = next_top;\n                    continue;\n                }\n                for(int &i=state[n], i_max = G[n].size(), need = dist[n]+1;;++i){\n                    if(i==i_max){\n                        dist[n]=-1;\n                        --top;\n                        break;\n                    }\n                    if(dist[G[n][i].to] == need && G[n][i].f){\n                        *top++ = &G[n][i];\n                        break;\n                    }\n                }\n            }\n        }while(addFlow);\n        return retflow;\n    }\n    vector<flow_t> excess;\n    vector<cost_t> h;\n    void push(Edge &e, flow_t amt){\n        //cerr << \"push: \" << G[e.to][e.rev].to << \" -> \" << e.to << \" (\" << e.f << \"/\" << e.c << \") : \" << amt << \"\\n\";\n        if(e.f < amt) amt=e.f;\n        e.f-=amt;\n        excess[e.to]+=amt;\n        G[e.to][e.rev].f+=amt;\n        excess[G[e.to][e.rev].to]-=amt;\n    }\n    void relabel(int vertex){\n        cost_t newHeight = -INFCOST;\n        for(unsigned int i=0;i<G[vertex].size();++i){\n            Edge const&e = G[vertex][i];\n            if(e.f && newHeight < h[e.to]-e.c){\n                newHeight = h[e.to] - e.c;\n                state[vertex] = i;\n            }\n        }\n        h[vertex] = newHeight - epsilon;\n    }\n    const int scale=2;\n    pair<flow_t, cost_t> minCostFlow(){\n        cost_t retCost = 0;\n        for(int i=0;i<N;++i){\n            for(Edge &e:G[i]){\n                retCost += e.c*(e.f);\n            }\n        }\n        //find feasible flow\n        flow_t retFlow = calc_max_flow();\n        excess.resize(N);h.resize(N);\n        queue<int> q;\n        isEnqueued.assign(N, 0); state.assign(N,0);\n        for(;epsilon;epsilon>>=scale){\n            //refine\n            fill(state.begin(), state.end(), 0);\n            for(int i=0;i<N;++i)\n                for(auto &e:G[i])\n                    if(h[i] + e.c - h[e.to] < 0 && e.f) push(e, e.f);\n            for(int i=0;i<N;++i){\n                if(excess[i]>0){\n                    q.push(i);\n                    isEnqueued[i]=1;\n                }\n            }\n            while(!q.empty()){\n                int cur=q.front();q.pop();\n                isEnqueued[cur]=0;\n                // discharge\n                while(excess[cur]>0){\n                    if(state[cur] == G[cur].size()){\n                        relabel(cur);\n                    }\n                    for(unsigned int &i=state[cur], max_i = G[cur].size();i<max_i;++i){\n                        Edge &e=G[cur][i];\n                        if(h[cur] + e.c - h[e.to] < 0){\n                            push(e, excess[cur]);\n                            if(excess[e.to]>0 && isEnqueued[e.to]==0){\n                                q.push(e.to);\n                                isEnqueued[e.to]=1;\n                            }\n                            if(excess[cur]==0) break;\n                        }\n                    }\n                }\n            }\n            if(epsilon>1 && epsilon>>scale==0){\n                epsilon = 1<<scale;\n            }\n        }\n        for(int i=0;i<N;++i){\n            for(Edge &e:G[i]){\n                retCost -= e.c*(e.f);\n            }\n        }\n        //cerr << \" -> \" << retFlow << \" / \" << retCost << \" bzw. \" << retCost/2/N << \"\\n\";\n        return make_pair(retFlow, retCost/2/N);\n    }\n    flow_t getFlow(Edge const &e){\n        return G[e.to][e.rev].f;\n    }\n};\n\nconst int N = 100, M = 350, X = 150;\n\nint x[N], y[N]; ll v[N];\nchar t[M]; int a[M], b[M];\nint l[N], r[N], u[N], d[N];\n\nint main() {\n\tfast_cin();\n\tint n; cin >> n;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tcin >> x[i] >> y[i] >> v[i];\n\t}\n\tint m; cin >> m;\n\tfor (int i = 1; i <= m; ++i) {\n\t\tcin >> t[i] >> a[i] >> b[i];\n\t}\n\tll best = 0;\n\tfor (int k = 1; k <= n; ++k) {\n\t\tfor (int i = 0; i <= k; ++i) {\n\t\t\tl[i] = d[i] = 0;\n\t\t}\n\t\tfor (int i = 1; i <= k + 1; ++i) {\n\t\t\tr[i] = u[i] = X;\n\t\t}\n\t\tfor (int i = 1; i <= m; ++i) {\n\t\t\tif (t[i] == 'L') {\n\t\t\t\tl[b[i] + 1] = max(l[b[i] + 1], a[i] + 1);\n\t\t\t} else if (t[i] == 'R' and k >= b[i]) {\n\t\t\t\tr[k - b[i]] = min(r[k - b[i]], a[i] - 1);\n\t\t\t} else if (t[i] == 'D') {\n\t\t\t\td[b[i] + 1] = max(d[b[i] + 1], a[i] + 1);\n\t\t\t} else if (t[i] == 'U' and k >= b[i]) {\n\t\t\t\tu[k - b[i]] = min(u[k - b[i]], a[i] - 1);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= k; ++i) {\n\t\t\tl[i] = max(l[i], l[i - 1]);\n\t\t\td[i] = max(d[i], d[i - 1]);\n\t\t}\n\t\tfor (int i = k; i >= 1; --i) {\n\t\t\tr[i] = min(r[i], r[i + 1]);\n\t\t\tu[i] = min(u[i], u[i + 1]);\n\t\t}\n\t\tint source = 0, sink = 2 * k + 2 * n + 1;\n\t\tmcSFlow<int, ll> F(2 * k + 2 * n + 2, source, sink);\n\t\tfor (int i = 1; i <= k; ++i) {\n\t\t\tF.add_edge(source, i, 0, 1);\n\t\t}\n\t\tfor (int i = 1; i <= k; ++i) {\n\t\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\t\tif (l[i] <= x[j] and x[j] <= r[i]) {\n\t\t\t\t\tF.add_edge(i, j + k, 0, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\tF.add_edge(j + k, j + k + n, -v[j], 1);\n\t\t}\n\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\tfor (int i = 1; i <= k; ++i) {\n\t\t\t\tif (d[i] <= y[j] and y[j] <= u[i]) {\n\t\t\t\t\tF.add_edge(j + k + n, i + k + 2 * n, 0, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= k; ++i) {\n\t\t\tF.add_edge(i + k + 2 * n, sink, 0, 1);\n\t\t}\n\t\tauto flow = F.minCostFlow();\n\t\tif (flow.first == k) {\n\t\t\tbest = max(best, -flow.second);\n\t\t}\n\t}\n\tcout << best << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\nusing namespace std;\nconst int N=105;\nint lx[N],ly[N],rx[N],ry[N];\nint n,m,x[N],y[N],p[N*4],cnt[N*4];\nll dis[N*4],v[N],ans;\nint vis[N*4],q[N*N*4];\nint S,T,from[N*4];\nchar tp[N*4][5];\nstruct edge{\n\tint from,to,next,f;\n\tll v;\n}e[N*N*N];\nint head[N*4],tot;\nvoid add(int x,int y,int f,ll v){\n\te[++tot]=(edge){x,y,head[x],f,v};\n\thead[x]=tot;\n\te[++tot]=(edge){y,x,head[y],0,-v};\n\thead[y]=tot;\n}\nbool bfs(ll &sum){\n\tFor(i,1,T)\n\t\tdis[i]=-(1ll<<60),vis[i]=0;\n\tint h=0,t=1;\n\tq[1]=S; dis[S]=0;\n\twhile (h!=t){\n\t\tint x=q[++h]; vis[x]=0;\n\t\tfor (int i=head[x];i;i=e[i].next)\n\t\t\tif (dis[e[i].to]<dis[x]+e[i].v&&e[i].f){\n\t\t\t\tdis[e[i].to]=dis[x]+e[i].v;\n\t\t\t\tfrom[e[i].to]=i;\n\t\t\t\tif (!vis[e[i].to]){\n\t\t\t\t\tvis[e[i].to]=1;\n\t\t\t\t\tq[++t]=e[i].to;\n\t\t\t\t}\n\t\t\t}\n\t}\n\tif (dis[T]==-(1ll<<60)) return 0;\n\tsum+=dis[T];\n\tfor (int i=from[T];i;i=from[e[i].from])\n\t\te[i].f--,e[i^1].f++;\n\treturn 1;\n}\nvoid update(int k){\n\tmemset(head,0,sizeof(head));\n\ttot=1;\n\tFor(i,1,k){\n\t\tlx[i]=ly[i]=1;\n\t\trx[i]=ry[i]=N-1;\n\t}\n\tFor(i,1,m){\n\t\tif (cnt[i]>k) continue;\n\t\tif (tp[i][1]=='L') lx[cnt[i]+1]=max(lx[cnt[i]+1],p[i]+1);\n\t\tif (tp[i][1]=='R') rx[k-cnt[i]]=min(rx[k-cnt[i]],p[i]-1);\n\t\tif (tp[i][1]=='D') ly[cnt[i]+1]=max(ly[cnt[i]+1],p[i]+1);\n\t\tif (tp[i][1]=='U') ry[k-cnt[i]]=min(ry[k-cnt[i]],p[i]-1);\n\t}\n\tFor(i,2,k){\n\t\tlx[i]=max(lx[i],lx[i-1]);\n\t\tly[i]=max(ly[i],ly[i-1]);\n\t}\n\tRep(i,k-1,1){\n\t\trx[i]=min(rx[i],rx[i+1]);\n\t\try[i]=min(ry[i],ry[i+1]);\n\t}\n\tS=2*N+2*k+1; T=S+1;\n\tFor(i,1,k){\n\t\tadd(S,i,1,0);\n\t\tadd(i+2*N+k,T,1,0);\n\t\tFor(j,lx[i],rx[i]) add(i,j+k,1,0);\n\t\tFor(j,ly[i],ry[i]) add(j+N+k,i+2*N+k,1,0);\n\t}\n\tFor(i,1,n)\n\t\tadd(x[i]+k,y[i]+k+N,1,v[i]);\n\tll sum=0;\n\tFor(i,1,k)\n\t\tif (!bfs(sum))\n\t\t\treturn;\n\tans=max(ans,sum);\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tFor(i,1,n) scanf(\"%d%d%lld\",&x[i],&y[i],&v[i]);\n\tscanf(\"%d\",&m);\n\tFor(i,1,m) scanf(\"%s%d%d\",tp[i]+1,&p[i],&cnt[i]);\n\tFor(i,1,n) update(i);\n\tprintf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 19.01.2020 03:02:31       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename T, typename C>\nclass mcmf {\n public:\n  static constexpr T eps = (T) 1e-9;\n\n  struct edge {\n    int from;\n    int to;\n    T c;\n    T f;\n    C cost;\n  };\n\n  vector<vector<int>> g;\n  vector<edge> edges;\n  vector<C> d;\n  vector<int> q;\n  vector<bool> in_queue;\n  vector<int> pe;\n  int n;\n  int st, fin;\n  T flow;\n  C cost;\n\n  mcmf(int _n, int _st, int _fin) : n(_n), st(_st), fin(_fin) {\n    assert(0 <= st && st < n && 0 <= fin && fin < n && st != fin);\n    g.resize(n);\n    d.resize(n);\n    in_queue.resize(n);\n    pe.resize(n);\n    flow = 0;\n    cost = 0;\n  }\n\n  void clear_flow() {\n    for (const edge &e : edges) {\n      e.f = 0;\n    }\n    flow = 0;\n  }\n   \n  void add(int from, int to, T forward_cap, T backward_cap, C cost) {\n    assert(0 <= from && from < n && 0 <= to && to < n);\n    g[from].push_back((int) edges.size());\n    edges.push_back({from, to, forward_cap, 0, cost});\n    g[to].push_back((int) edges.size());\n    edges.push_back({to, from, backward_cap, 0, -cost});\n  }\n\n  bool expath() {\n    fill(d.begin(), d.end(), numeric_limits<C>::max());\n    q.clear();\n    q.push_back(st);\n    d[st] = 0;\n    in_queue[st] = true;\n    int beg = 0;\n    bool found = false;\n    while (beg < (int) q.size()) {\n      int i = q[beg++];\n      if (i == fin) {\n        found = true;\n      }\n      in_queue[i] = false;\n      for (int id : g[i]) {\n        const edge &e = edges[id];\n        if (e.c - e.f > eps && d[i] + e.cost < d[e.to]) {\n          d[e.to] = d[i] + e.cost;\n          pe[e.to] = id;\n          if (!in_queue[e.to]) {\n            q.push_back(e.to);\n            in_queue[e.to] = true;\n          }\n        }\n      }\n    }\n    if (found) {\n      T push = numeric_limits<T>::max();\n      int v = fin;\n      while (v != st) {\n        const edge &e = edges[pe[v]];\n        push = min(push, e.c - e.f);\n        v = e.from;\n      }\n      v = fin;\n      while (v != st) {\n        edge &e = edges[pe[v]];\n        e.f += push;\n        edge &back = edges[pe[v] ^ 1];\n        back.f -= push;\n        v = e.from;\n      }\n      flow += push;\n      cost += push * d[fin];\n    }\n    return found;\n  }\n   \n  pair<T, C> max_flow_min_cost() {\n    while (expath()) {}\n    return {flow, cost};\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<int> x(n), y(n);\n  vector<long long> v(n);\n  for (int i = 0; i < n; i++) {\n    cin >> x[i] >> y[i] >> v[i];\n  }\n  int m;\n  cin >> m;\n  vector<char> t(m);\n  vector<int> a(m), b(m);\n  for (int i = 0; i < m; i++) {\n    cin >> t[i] >> a[i] >> b[i];\n  } \n  long long ans = 0;\n  for (int k = 1; k <= n; k++) {\n    vector<int> lx(k, 1), rx(k, 100);\n    vector<int> ly(k, 1), ry(k, 100);\n    for (int i = 0; i < m; i++) {\n      if (b[i] >= k) {\n        continue;\n      }\n      if (t[i] == 'L') {\n        lx[b[i]] = max(lx[b[i]], a[i] + 1);\n      }\n      if (t[i] == 'D') {\n        ly[b[i]] = max(ly[b[i]], a[i] + 1);\n      }\n      if (t[i] == 'R') {\n        rx[k - 1 - b[i]] = min(rx[k - 1 - b[i]], a[i] - 1);\n      }\n      if (t[i] == 'U') {\n        ry[k - 1 - b[i]] = min(ry[k - 1 - b[i]], a[i] - 1);\n      }\n    }\n    for (int i = 0; i < k - 1; i++) {\n      lx[i + 1] = max(lx[i + 1], lx[i]);\n      ly[i + 1] = max(ly[i + 1], ly[i]);\n    }\n    for (int i = k - 1; i > 0; i--) {\n      rx[i - 1] = min(rx[i - 1], rx[i]);\n      ry[i - 1] = min(ry[i - 1], ry[i]);\n    }\n    mcmf<int, long long> f(1 + k + n + n + k + 1, 0, 1 + k + n + n + k);\n    for (int i = 0; i < k; i++) {\n      f.add(0, 1 + i, 1, 0, 0);\n      for (int j = 0; j < n; j++) {\n        if (lx[i] <= x[j] && x[j] <= rx[i]) {\n          f.add(1 + i, 1 + k + j, 1, 0, 0);\n        }\n        if (ly[i] <= y[j] && y[j] <= ry[i]) {\n          f.add(1 + k + n + j, 1 + k + n + n + i, 1, 0, 0);\n        }\n      }\n      f.add(1 + k + n + n + i, 1 + k + n + n + k, 1, 0, 0);\n    }\n    for (int i = 0; i < n; i++) {\n      f.add(1 + k + i, 1 + k + n + i, 1, 0, -v[i]);\n    }\n    auto p = f.max_flow_min_cost();\n    if (p.first == k) {\n      ans = max(ans, -p.second);\n    }\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\nusing int64 = long long;\nconst int mod = 1e9 + 7;\nconst int inf = (1 << 30) - 1;\nconst int64 infll = (1LL << 61) - 1;\n\nstruct IoSetup {\n  IoSetup() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    cerr << fixed << setprecision(10);\n  }\n} iosetup;\n\ntemplate< typename T >\nostream &operator<<(ostream &os, const vector< T > &v) {\n  for(int i = 0; i < (int) v.size(); i++) {\n    os << v[i] << (i + 1 != v.size() ? \" \" : \"\");\n  }\n  return os;\n}\n\ntemplate< typename T >\nistream &operator>>(istream &is, vector< T > &v) {\n  for(T &in : v) is >> in;\n  return is;\n}\n\ntemplate< typename T1, typename T2 >\ninline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\ntemplate< typename T1, typename T2 >\ninline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\ntemplate< typename T = int64 >\nvector< T > make_v(size_t a) {\n  return vector< T >(a);\n}\n\ntemplate< typename T, typename... Ts >\nauto make_v(size_t a, Ts... ts) {\n  return vector< decltype(make_v< T >(ts...)) >(a, make_v< T >(ts...));\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value == 0 >::type fill_v(T &t, const V &v) {\n  t = v;\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value != 0 >::type fill_v(T &t, const V &v) {\n  for(auto &e : t) fill_v(e, v);\n}\n\ntemplate< typename flow_t, typename cost_t >\nstruct PrimalDual {\n  const cost_t INF;\n\n  struct edge {\n    int to;\n    flow_t cap;\n    cost_t cost;\n    int rev;\n    bool isrev;\n  };\n  vector< vector< edge > > graph;\n  vector< cost_t > potential, min_cost;\n  vector< int > prevv, preve;\n\n  PrimalDual(int V) : graph(V), INF(numeric_limits< cost_t >::max()) {}\n\n  void add_edge(int from, int to, flow_t cap, cost_t cost) {\n    graph[from].emplace_back((edge) {to, cap, cost, (int) graph[to].size(), false});\n    graph[to].emplace_back((edge) {from, 0, -cost, (int) graph[from].size() - 1, true});\n  }\n\n  cost_t min_cost_flow(int s, int t, flow_t f) {\n    int V = (int) graph.size();\n    cost_t ret = 0;\n    using Pi = pair< cost_t, int >;\n    priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n    potential.assign(V, 0);\n    preve.assign(V, -1);\n    prevv.assign(V, -1);\n\n    while(f > 0) {\n      min_cost.assign(V, INF);\n      que.emplace(0, s);\n      min_cost[s] = 0;\n      while(!que.empty()) {\n        Pi p = que.top();\n        que.pop();\n        if(min_cost[p.second] < p.first) continue;\n        for(int i = 0; i < graph[p.second].size(); i++) {\n          edge &e = graph[p.second][i];\n          cost_t nextCost = min_cost[p.second] + e.cost + potential[p.second] - potential[e.to];\n          if(e.cap > 0 && min_cost[e.to] > nextCost) {\n            min_cost[e.to] = nextCost;\n            prevv[e.to] = p.second, preve[e.to] = i;\n            que.emplace(min_cost[e.to], e.to);\n          }\n        }\n      }\n      if(min_cost[t] == INF) return 0;//return -1;\n      for(int v = 0; v < V; v++) potential[v] += min_cost[v];\n      flow_t addflow = f;\n      for(int v = t; v != s; v = prevv[v]) {\n        addflow = min(addflow, graph[prevv[v]][preve[v]].cap);\n      }\n      f -= addflow;\n      ret += addflow * potential[t];\n      for(int v = t; v != s; v = prevv[v]) {\n        edge &e = graph[prevv[v]][preve[v]];\n        e.cap -= addflow;\n        graph[v][e.rev].cap += addflow;\n      }\n    }\n    return ret;\n  }\n\n  void output() {\n    for(int i = 0; i < graph.size(); i++) {\n      for(auto &e : graph[i]) {\n        if(e.isrev) continue;\n        auto &rev_e = graph[e.to][e.rev];\n        cout << i << \"->\" << e.to << \" (flow: \" << rev_e.cap << \"/\" << rev_e.cap + e.cap << \")\" << endl;\n      }\n    }\n  }\n};\n\n\nint main() {\n  int N, M;\n  cin >> N;\n  vector< int > X(N), Y(N);\n  vector< int64 > V(N);\n  for(int i = 0; i < N; i++) {\n    cin >> X[i] >> Y[i] >> V[i];\n    --X[i], --Y[i];\n  }\n  cin >> M;\n  vector< int > L(100, N), R(100, N), D(100, N), U(100, N);\n  for(int i = 0; i < M; i++) {\n    char t;\n    int a, b;\n    cin >> t >> a >> b;\n    --a;\n    if(t == 'L') chmin(L[a], b);\n    else if(t == 'R') chmin(R[a], b);\n    else if(t == 'D') chmin(D[a], b);\n    else chmin(U[a], b);\n  }\n  for(int i = 98; i >= 0; i--) chmin(L[i], L[i + 1]);\n  for(int i = 1; i < 100; i++) chmin(R[i], R[i - 1]);\n  for(int i = 98; i >= 0; i--) chmin(D[i], D[i + 1]);\n  for(int i = 1; i < 100; i++) chmin(U[i], U[i - 1]);\n\n  int64 ret = 0;\n  for(int k = 1; k <= N; k++) {\n\n    auto get_range = [&](vector< int > &P, vector< int > &Q) {\n      vector< int > l(N + 2), r(N + 2, inf);\n      for(int i = 0; i < P.size(); i++) {\n        chmax(l[P[i] + 1], i + 1);\n      }\n      for(int i = 0; i < Q.size(); i++) {\n        if(k - Q[i] > 0) chmin(r[k - Q[i]], i - 1);\n      }\n      vector< pair< int, int > > ret;\n      for(int i = k - 1; i >= 0; i--) {\n        chmin(r[i], r[i + 1]);\n      }\n      for(int i = 1; i <= k; i++) {\n        chmax(l[i], l[i - 1]);\n        ret.emplace_back(l[i], r[i]);\n      }\n      return ret;\n    };\n\n\n    auto latte = get_range(L, R);\n    auto malta = get_range(D, U);\n\n    PrimalDual< int64, int64 > flow(2 * k + N * 2 + 2);\n    int S = 2 * k + 2 * N, T = S + 1;\n    for(int i = 0; i < k; i++) {\n      flow.add_edge(S, i, 1, 0);\n      flow.add_edge(i + k, T, 1, 0);\n    }\n    for(int i = 0; i < N; i++) {\n      for(int j = 0; j < k; j++) {\n        if(latte[j].first <= X[i] && X[i] <= latte[j].second) {\n          flow.add_edge(j, 2 * k + i, 1, 0);\n        }\n        if(malta[j].first <= Y[i] && Y[i] <= malta[j].second) {\n          flow.add_edge(2 * k + N + i, k + j, 1, 0);\n        }\n      }\n      flow.add_edge(2 * k + i, 2 * k + N + i, 1, -V[i]);\n    }\n    chmax(ret, -flow.min_cost_flow(S, T, k));\n  }\n  cout << ret << endl;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>/*{{{*/\n#include<cctype>\n#include<cassert>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<ctime>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<set>\n#include<vector>\nusing namespace std;\ntypedef pair<int,int> pii;\n#define fi first\n#define se second\n#define pb push_back\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define ROF(i,a,b) for(int i=(a);i>=(b);--i)\nnamespace RA{\n    int r(int p){return 1ll*rand()*rand()%p;}\n    int r(int L,int R){return r(R-L+1)+L;}\n}/*}}}*/\n/******************heading******************/\ntypedef long long LL;\nconst LL LLINF=0x3f3f3f3f3f3f3f3f;\nconst int N=400,INF=0x3f3f3f3f;\n\nint s,t;\nstruct qxx{int nex,t,v;LL c;};\nqxx e[N*N*10];\nLL h[N],hh[N],le=1;\nvoid add_path(int f,int t,int v,LL c){e[++le]=(qxx){h[f],t,v,c},h[f]=le;}\nvoid add_flow(int f,int t,int v,LL c){\n    //printf(\"add_flow(%d,%d,%d,%lld)\\n\",f,t,v,c);\n    add_path(f,t,v,c),add_path(t,f,0,-c);}\n#define FORe(i,_u,_v,_w,_c)     for(LL i=h[_u],_v,_w,_c;_v=e[i].t,_w=e[i].v,_c=e[i].c,i;i=e[i].nex)\n#define FORflowe(i,_u,_v,_w,_c) for(LL &i=hh[_u],_v,_w,_c;_v=e[i].t,_w=e[i].v,_c=e[i].c,i;i=e[i].nex)\n\nint n,m;\nint x[N],y[N];\nLL val[N],ans=-LLINF;\nint xL[N],xR[N],yL[N],yR[N];\n\nvector<pii> L,R,U,D;\n\nqueue<int> q;\nbool vising[N];\nLL d[N];\nbool spfa(){\n    memset(d,0x3f,sizeof(d));\n    q.push(s),d[s]=0;\n    while(!q.empty()){\n        int u=q.front();q.pop();\n        vising[u]=0;\n        FORe(i,u,v,w,c){\n            if(!w||d[v]<=d[u]+c)continue;\n            d[v]=d[u]+c;\n            if(!vising[v])q.push(v),vising[v]=1;\n        }\n    }\n    return d[t]!=LLINF;\n}\nLL mincost;\nbool vis[N];\nint dfs(int u,int flow){\n    //printf(\"dfs(%d,%d)\\n\",u,flow);\n    vis[u]=1;\n    if(u==t)return flow;\n    int rest=flow;\n    FORflowe(i,u,v,w,c){\n        if(!rest)break;\n        if(vis[v]&&v!=t||!w||d[v]!=d[u]+c)continue;\n        int k=dfs(v,min(w,1ll*rest));\n        if(k)mincost+=k*c,e[i].v-=k,e[i^1].v+=k,rest-=k;\n        else d[v]=0;\n    }\n    return flow-rest;\n}\nLL go(){\n    int maxflow=0;\n    while(spfa()){\n        //puts(\"GG\");\n        memcpy(hh,h,sizeof(h));\n        for(int i;memset(vis,0,sizeof(vis)),(i=dfs(s,INF))&&vis[t];)maxflow+=i;\n    }\n    //printf(\"maxflow=%d,mincost=%lld\\n\",maxflow,mincost);\n    return mincost;\n}\nvoid init(){\n    memset(h,0,sizeof(h));\n    le=1,mincost=0;\n}\nvoid calc(int k){\n    //printf(\"calc(%d)\\n\",k);\n    for(pii x:L)xL[x.se+1]=x.fi+1; //x[b+1] >= a+1\n    for(pii x:R)xR[k-x.se]=x.fi-1; //x[k-b] <= a-1\n    for(pii x:D)yL[x.se+1]=x.fi+1;\n    for(pii x:U)yR[k-x.se]=x.fi-1;\n    xR[k+1]=INF;\n    FOR(i,1,k)if(!xL[i])xL[i]=xL[i-1];\n    ROF(i,k,1)if(!xR[i])xR[i]=xR[i+1];\n    yR[k+1]=INF;\n    FOR(i,1,k)if(!yL[i])yL[i]=yL[i-1];\n    ROF(i,k,1)if(!yR[i])yR[i]=yR[i+1];\n    //FOR(i,1,k)printf(\"[%d,%d]%c\",xL[i],xR[i],\" \\n\"[i==k]);\n    //FOR(i,1,k)printf(\"[%d,%d]%c\",yL[i],yR[i],\" \\n\"[i==k]);\n\n    // item: 1 - n, n+1 - 2n\n    // x : 2n+1 - 2n+k\n    // y : 2n+k+1 - 2n+2k\n    // s : 0\n    // t : 2n+2k+1\n    init();\n    s=0,t=2*n+2*k+1;\n    //printf(\"s=%d,t=%d\\n\",s,t);\n    FOR(i,1,k)add_flow(s,2*n+i,1,0);\n    FOR(i,1,k)FOR(j,1,n)if(xL[i]<=x[j]&&x[j]<=xR[i])add_flow(2*n+i,j,INF,0);\n    FOR(i,1,n)add_flow(i,i+n,1,-val[i]);\n    FOR(i,1,k)FOR(j,1,n)if(yL[i]<=y[j]&&y[j]<=yR[i])add_flow(j+n,2*n+k+i,INF,0);\n    FOR(i,1,k)add_flow(2*n+k+i,t,1,0);\n\n    LL res=go();\n    ans=max(ans,-res);\n}\n\nint main(){\n    scanf(\"%d\",&n);\n    FOR(i,1,n)scanf(\"%d%d%lld\",&x[i],&y[i],&val[i]);\n    scanf(\"%d\",&m);\n    FOR(i,1,m){\n        char t[10];\n        int a,b;\n        scanf(\"%s%d%d\",t,&a,&b);\n        if(t[0]=='L')L.pb({a,b});\n        else if(t[0]=='R')R.pb({a,b});\n        else if(t[0]=='U')U.pb({a,b});\n        else D.pb({a,b});\n    }\n    FOR(i,1,n)calc(i);\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#define foreach(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\n#ifndef LOCAL\n#define cerr if(0)cout\n#endif\ntypedef long long ll;\nconst int mod = 1e9+7;\n//My i/o stream\nstruct fastio\n{\n\tchar s[100000];\n\tint it, len;\n\tfastio() {it=len=0;}\n\tinline char get()\n\t{\n\t\tif (it<len) return s[it++]; it=0;\n\t\tlen=fread(s, 1, 100000, stdin);\n\t\tif (len==0) return EOF; else return s[it++];\n\t}\n\tbool notend()\n\t{\n\t\tchar c=get();\n\t\twhile (c==' '||c=='\\n') c=get();\n\t\tif (it>0) it--;\n\t\treturn c!=EOF;\n\t}\n}_buff;\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putchar(' ')\n#define putii(x,y) puti(x),puti(y)\n#define putiii(x,y,z) putii(x,y),puti(z)\n#define putsi(x) putnum(x),putchar('\\n')\n#define putsii(x,y) puti(x),putsi(y)\n#define putsiii(x,y,z) putii(x,y),putsi(z)\ninline ll getnum()\n{\n\tll r=0; bool ng=0; char c; c=_buff.get();\n\twhile (c!='-'&&(c<'0'||c>'9')) c=_buff.get();\n\tif (c=='-') ng=1, c=_buff.get();\n\twhile (c>='0'&&c<='9') r=r*10+c-'0', c=_buff.get();\n\treturn ng?-r:r;\n}\ntemplate <class T> inline void putnum(T x)\n{\n\tif (x<0) putchar('-'), x=-x;\n\tregister short a[20]={}, sz=0;\n\twhile (x) a[sz++]=x%10, x/=10;\n\tif(sz==0) putchar('0');\n\tfor (int i=sz-1; i>=0; i--) putchar('0'+a[i]);\n}\ninline char getreal() {char c=_buff.get(); while (c<=32) c=_buff.get(); return c;}\nll qpow(ll x, ll k) {return k==0? 1: 1ll*qpow(1ll*x*x%mod,k>>1)*(k&1?x:1)%mod;}\nconst ll inf = 4e18;\nnamespace F\n{\n\tconst int maxn = 1011, maxe = 100011;\n\tint head[maxn], nxt[maxe], to[maxe], cap[maxe];\n\tll cost[maxe], tot;\n\tll ftot;\n\tvoid init()\n\t{\n\t\ttot = 1;\n\t\tmemset(head, 0, sizeof(head));\n\t}\n\tvoid add_edge(int x, int y, int c, ll w)\n\t{\n//\t\tcerr<<\"add_edge:\"<<x<<\",\"<<y<<\" \"<<c<<\" \"<<w<<endl;\n\t\tnxt[++tot] = head[x];\n\t\thead[x] = tot;\n\t\tto[tot] = y;\n\t\tcap[tot] = c;\n\t\tcost[tot] = w;\n\t\tswap(x, y);\n\t\tnxt[++tot] = head[x];\n\t\thead[x] = tot;\n\t\tto[tot] = y;\n\t\tcap[tot] = 0;\n\t\tcost[tot] = -w;\n\t}\n\tint q[maxn], qb, qe;\n\tll dis[maxn];\n\tbool inq[maxn];\n\tint qnxt(int x) {return (x+1)%maxn;}\n\tint qpre(int x) {return (x-1+maxn)%maxn;}\n\tvoid balance()\n\t{\n\t\tif (qb!=qe&&dis[q[qpre(qe)]]<dis[q[qb]])\n\t\t{\n\t\t\tswap(q[qpre(qe)], q[qb]);\n\t\t}\n\t}\n\tvoid spfa(int S, int N)\n\t{\n\t\tinq[S] = 1;\n\t\tfor (int i=0; i<=N; i++) dis[i] = inf;\n\t\tdis[S] = 0;\n\t\tqb = qe = 0;\n\t\tq[qe++] = S;\n\t\twhile (qb<qe)\n\t\t{\n\t\t\tint x = q[qb];\n\t\t\tinq[x] = 0;\n\t\t\tqb = qnxt(qb);\n\t\t\tbalance();\n\t\t\tfor (int i = head[x]; i; i=nxt[i])\n\t\t\t{\n\t\t\t\tif (cap[i]&&dis[to[i]]>dis[x]+cost[i])\n\t\t\t\t{\n\t\t\t\t\tdis[to[i]] = dis[x]+cost[i];\n\t\t\t\t\tif (!inq[to[i]])\n\t\t\t\t\t{\n\t\t\t\t\t\tinq[to[i]] = 1;\n\t\t\t\t\t\tq[qe] = to[i];\n\t\t\t\t\t\tqe = qnxt(qe);\n\t\t\t\t\t\tbalance();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tfor (int i=1; i<=N; i++) cerr<<dis[i]<<\" \"; cerr<<endl;\n\t}\n\t\n\tbool vis[maxn];\n\tint dfs(int x, int T, int f)\n\t{\n\t\tif (x==T) return f;\n\t\tvis[x] = 1;\n\t\tint of = f;\n\t\tfor (int i=head[x]; i; i=nxt[i])\n\t\t{\n\t\t\tif (!vis[to[i]]&&cap[i]&&dis[to[i]]==dis[x]+cost[i])\n\t\t\t{\n\t\t\t\tint u = to[i];\n\t\t\t\tint d = dfs(u, T, min(f, cap[i]));\n\t\t\t\tcap[i] -= d;\n\t\t\t\tcap[i^1] += d;\n\t\t\t\tf -= d;\n\t\t\t\tif (!f) return of;\n\t\t\t}\n\t\t}\n\t\treturn of-f;\n\t}\n\tll min_cost_max_flow(int S, int T, int K)\n\t{\n\t\tll ans = 0;\n\t\twhile (true)\n\t\t{\n\t\t\tspfa(S, T);\n\t\t\tif (dis[T]>=inf) return ans;\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\tmemset(vis, 0, sizeof(vis));\n\t\t\t\tint f = dfs(S, T, K);\n\t\t\t\tftot += f;\n\t\t\t\tans += 1ll*f*dis[T];\n\t\t\t\tif (f==0) break;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n};\nint n;\nint tid[256];\npair<int,int> a[88];\nll w[88];\nvector<pair<int,int> > M[4];\npair<int,int> segx[88], segy[88];\nll solve(int K)\n{\n//\tcerr<<\"solve: \"<<K<<endl;\n\tfor (int i=1; i<=K; i++) segx[i] = segy[i] = MP(0, 100);\n\tfor (auto x : M[0])\n\t{\n\t\tfor (int i=x.SS+1; i<=K; i++)\n\t\t{\n\t\t\tsegx[i].FF = max(segx[i].FF, x.FF+1);\n\t\t}\n\t}\n\tfor (auto x : M[1])\n\t{\n\t\tfor (int i=K-x.SS; i>=1; i--)\n\t\t{\n\t\t\tsegx[i].SS = min(segx[i].SS, x.FF-1);\n\t\t}\n\t}\n\tfor (auto x : M[2])\n\t{\n\t\tfor (int i=x.SS+1; i<=K; i++)\n\t\t{\n\t\t\tsegy[i].FF = max(segy[i].FF, x.FF+1);\n\t\t}\n\t}\n\tfor (auto x : M[3])\n\t{\n\t\tfor (int i=K-x.SS; i>=1; i--)\n\t\t{\n\t\t\tsegy[i].SS = min(segy[i].SS, x.FF-1);\n\t\t}\n\t}\n/*\tfor (int i=1; i<=K; i++)\n\t{\n\t\tcerr<<\"(\"<<segx[i].FF<<\",\"<<segx[i].SS<<\") (\"<<segy[i].FF<<\",\"<<segy[i].SS<<\")\"<<endl;\n\t}\n*/\t\n\tint S = 2*K+2*n+1, T = S+1;\n//\tcerr<<\"S=\"<<S<<\" T=\"<<T<<endl;\n\tF::init();\n\tfor (int i=1; i<=K; i++)\n\t{\n\t\tF::add_edge(S, i, 1, 0);\n\t\tF::add_edge(i+K, T, 1, 0);\n\t\tfor (int j=1; j<=n; j++)\n\t\t{\n\t\t\tif (segx[i].FF<=a[j].FF&&a[j].FF<=segx[i].SS)\n\t\t\t{\n\t\t\t\tF::add_edge(i, j+2*K, 1, 0);\n\t\t\t}\n\t\t\tif (segy[i].FF<=a[j].SS&&a[j].SS<=segy[i].SS)\n\t\t\t{\n\t\t\t\tF::add_edge(j+2*K+n, i+K, 1, 0);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1; i<=n; i++) F::add_edge(i+2*K, i+2*K+n, 1, -w[i]);\n\tll ans = F::min_cost_max_flow(S, T, K);\n//\tcerr<<\"F::ftot=\"<<F::ftot<<endl;\n\tif (F::ftot<K) return 0;\n//\tcerr<<\"ans=\"<<ans<<endl;\n\treturn -ans;\n}\nint main()\n{\n\ttid['L'] = 0;\n\ttid['R'] = 1;\n\ttid['D'] = 2;\n\ttid['U'] = 3;\n\tgeti(n);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tll x, y, v;\n\t\tgetiii(x, y, v);\n\t\ta[i] = MP(x, y);\n\t\tw[i] = v;\n\t}\n\tint m;\n\tgeti(m);\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\tchar t;\n\t\tint a, b;\n\t\tt = getreal();\n\t\tgetii(a, b);\n\t\tM[tid[t]].PB(MP(a, b));\n\t}\n\tll ans = 0;\n\tfor (int K=1; K<=n; K++)\n\t{\n\t\tans = max(ans, solve(K));\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <list>\n#include <time.h>\n#include <math.h>\n#include <random>\n#include <deque>\n#include <queue>\n#include <cassert>\n#include <unordered_map>\n#include <unordered_set>\n#include <iomanip>\n#include <bitset>\n#include <sstream>\n#include <chrono>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef long double dbl;\nconst int INF = 1.01e9;\n \nconst long double EPS = 1e-18;\nbool eq(long double x, long double y) {\n    return fabs(x - y) < EPS;\n}\nbool ls(long double x, long double y) {\n    return x < y && !eq(x, y);\n}\n \nvector<long double> simplex(vector<vector<long double> > a) {\n    int n = a.size() - 1;\n    int m = a[0].size() - 1;\n    vector<int> left(n + 1), up(m + 1);\n    iota(up.begin(), up.end(), 0);\n    iota(left.begin(), left.end(), m);\n    auto pivot = [&](int x, int y) {\n        swap(left[x], up[y]);\n        long double k = a[x][y];\n        a[x][y] = 1;\n        vector<int> vct;\n        for (int j = 0; j <= m; j++) {\n            a[x][j] /= k;\n            if (!eq(a[x][j], 0)) vct.push_back(j);\n        }\n        for (int i = 0; i <= n; i++) {\n            if (eq(a[i][y], 0) || i == x) continue;\n            k = a[i][y];\n            a[i][y] = 0;\n            for (int j : vct) a[i][j] -= k * a[x][j];\n        }\n    };\n    while (1) {\n        int x = -1;\n        for (int i = 1; i <= n; i++) if (ls(a[i][0], 0) && (x == -1 || a[i][0] < a[x][0])) x = i;\n        if (x == -1) break;\n        int y = -1;\n        for (int j = 1; j <= m; j++) if (ls(a[x][j], 0) && (y == -1 || a[x][j] < a[x][y])) y = j;\n        if (y == -1) assert(0); // infeasible\n        pivot(x, y);\n    }\n    while (1) {\n        int y = -1;\n        for (int j = 1; j <= m; j++) if (ls(0, a[0][j]) && (y == -1 || a[0][j] > a[0][y])) y = j;\n        if (y == -1) break;\n        int x = -1;\n        for (int i = 1; i <= n; i++) if (ls(0, a[i][y]) && (x == -1 || a[i][0] / a[i][y] < a[x][0] / a[x][y])) x = i;\n        if (x == -1) assert(0); // unbounded\n        pivot(x, y);\n    }\n    vector<long double> ans(m + 1);\n    for (int i = 1; i <= n; i++) if (left[i] <= m) ans[left[i]] = a[i][0];\n    ans[0] = -a[0][0];\n    return ans;\n}\n\n#ifdef ONPC\n  mt19937 rnd(228);\n#else\n  mt19937 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\n#endif\n\nint main()\n{\n#ifdef ONPC\n  freopen(\"a.in\", \"r\", stdin);\n#endif\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector <int> x(n), y(n);\n  vector <ll> ok;\n  vector <long double> v;\n  vector <pair <ll, int> > e;\n  for (int i = 0; i < n; i++)\n  {\n    cin >> x[i] >> y[i];\n    ll x;\n    cin >> x;\n    ok.push_back(x);\n    v.push_back(x);\n    e.push_back({x, i});\n  }\n  v.insert(v.begin(), 0);\n  int m;\n  cin >> m;\n  vector <vector <long double> > mat;\n  mat.push_back(v);\n  for (int i = 0; i < n; i++)\n  {\n    vector <long double> kek(n + 1);\n    kek[0] = kek[i + 1] = 1;\n    mat.push_back(kek);\n  }\n  vector <vector <int> > simp;\n  for (int i = 0; i < m; i++)\n  {\n    char c;\n    cin >> c;\n    int a;\n    int b;\n    cin >> a >> b;\n    vector <long double> arr = {(long double) b};\n    vector <int> kek = {b};\n    for (int j = 0; j < n; j++)\n    {\n      int grab = 0;\n      if (c == 'L' && x[j] <= a) grab = 1;\n      if (c == 'R' && x[j] >= a) grab = 1;\n      if (c == 'D' && y[j] <= a) grab = 1;\n      if (c == 'U' && y[j] >= a) grab = 1;\n      arr.push_back(grab);\n      kek.push_back(grab);\n    }\n    mat.push_back(arr);\n    simp.push_back(kek);\n  }\n  auto ret = simplex(mat);\n  vector <int> grab;\n  for (int i = 1; i < (int) ret.size(); i++)\n  {\n    if (ret[i] >= 0.5)\n    {\n      grab.push_back(1);\n    }\n    else\n    {\n      grab.push_back(0);\n    }\n  }\n  sort(e.begin(), e.end());\n  auto good = [&] (vector <int> grab)\n  {\n    for (auto c : simp)\n    {\n      int sum = 0;\n      for (int i = 1; i <= n; i++) sum += grab[i - 1] * c[i];\n      if (sum > c[0])\n      {\n        return false;\n      }\n    }\n    return true;\n  };\n  for (int i = 0; i < (int) e.size(); i++)\n  {\n    if (grab[e[i].second] && !good(grab))\n    {\n      grab[e[i].second] = 0;\n    }\n  }\n  bool ch = true;\n  while (ch)\n  {\n    ch = false;\n    for (int i = (int) e.size() - 1; i >= 0; i--)\n    {\n      if (!grab[e[i].second])\n      {\n        grab[e[i].second] = true;\n        if (good(grab))\n        {\n          ch = true;\n        }\n        else\n        {\n          grab[e[i].second] = false;\n        }\n      }\n    }\n    if (!ch)\n    {\n      for (int i = 0; i < (int) e.size(); i++)\n      {\n        for (int j = i + 1; j < (int) e.size(); j++)\n        {\n          if (e[i].first < e[j].first && grab[e[i].second] && !grab[e[j].second])\n          {\n            auto x = grab;\n            swap(x[e[i].second], x[e[j].second]);\n            if (good(x))\n            {\n              grab = x;\n              ch = true;\n            }\n          }\n        }\n      }\n    }\n  }\n  ll ans = 0;\n  for (int i = 0; i < n; i++)\n  {\n    if (grab[i]) ans += ok[i];\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n#define pa pair<int,int>\nconst int inf=2147483647;\nLL read()\n{\n\tLL x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+(ch^48),ch=getchar();\n\treturn x*f;\n}\nint n,m,st,ed;\nstruct P{int x,y;LL v;}p[85];\nstruct Q{int o,a,b;}q[325];\nchar op[3];\nstruct Edge{int x,y,d,next;LL c;}e[100010];\nint last[450],len;\nvoid ins(int x,int y,int d,LL c)\n{\n\tint t=++len;\n\te[t].x=x;e[t].y=y;e[t].d=d;e[t].c=c;\n\te[t].next=last[x];last[x]=t;\n}\nvoid addedge(int x,int y,int d,LL c){ins(x,y,d,c),ins(y,x,0,-c);}\nLL f[450];int pre[450];bool in[450];\nbool spfa()\n{\n\tmemset(f,-63,sizeof(f));f[st]=0;\n\tmemset(in,false,sizeof(in));\n\tqueue<int>q;q.push(st);\n\twhile(!q.empty())\n\t{\n\t\tint x=q.front();q.pop();in[x]=false;\n\t\tfor(int i=last[x];i;i=e[i].next)\n\t\t{\n\t\t\tint y=e[i].y;\n\t\t\tif(e[i].d>0&&f[x]+e[i].c>f[y])\n\t\t\t{\n\t\t\t\tpre[y]=i;\n\t\t\t\tf[y]=f[x]+e[i].c;\n\t\t\t\tif(!in[y])in[y]=true,q.push(y);\n\t\t\t}\n\t\t}\n\t}\n\tif(f[ed]>0)return true;\n\treturn false;\n}\nLL Ans,ans=0;\nvoid work()\n{\n\tint x=ed;\n\twhile(x!=st)\n\t{\n\t\tAns+=e[pre[x]].c;\n\t\te[pre[x]].d--,e[pre[x]^1].d++;\n\t\tx=e[pre[x]].x;\n\t}\n}\nint lx[85],rx[85],ly[85],ry[85];\nvoid solve(int k)\n{\n\tmemset(last,0,sizeof(last));len=1;\n\tfor(int i=1;i<=n;i++)\n\taddedge(p[i].x,200+i,1,p[i].v),addedge(200+i,100+p[i].y,1,0);\n\tfor(int i=1;i<=k;i++)lx[i]=ly[i]=1,rx[i]=ry[i]=100;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tif(q[i].o==0)lx[q[i].b+1]=max(lx[q[i].b+1],q[i].a+1);\n\t\tif(q[i].o==1&&k>q[i].b)rx[k-q[i].b]=min(rx[k-q[i].b],q[i].a-1);\n\t\tif(q[i].o==2)ly[q[i].b+1]=max(ly[q[i].b+1],q[i].a+1);\n\t\tif(q[i].o==3&&k>q[i].b)ry[k-q[i].b]=min(ry[k-q[i].b],q[i].a-1);\n\t}\n\tfor(int i=2;i<=k;i++)lx[i]=max(lx[i],lx[i-1]),ly[i]=max(ly[i],ly[i-1]);\n\tfor(int i=k-1;i;i--)rx[i]=min(rx[i],rx[i+1]),ry[i]=min(ry[i],ry[i+1]);\n\tst=200+n+2*k+1,ed=st+1;\n\tfor(int i=1;i<=k;i++)\n\t{\n\t\tif(lx[i]>rx[i]||ly[i]>ry[i])return;\n\t\taddedge(st,200+n+i,1,0),addedge(200+n+k+i,ed,1,0);\n\t\tfor(int j=lx[i];j<=rx[i];j++)addedge(200+n+i,j,1,0);\n\t\tfor(int j=ly[i];j<=ry[i];j++)addedge(100+j,200+n+k+i,1,0);\n\t}\n\tint u=0;Ans=0;\n\twhile(spfa())u++,work();\n\tif(u!=k)return;\n\tans=max(ans,Ans);\n}\nint main()\n{\n\tn=read();\n\tfor(int i=1;i<=n;i++)p[i].x=read(),p[i].y=read(),p[i].v=read();\n\tm=read();\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%s\",op);\n\t\tq[i].a=read(),q[i].b=read();\n\t\tif(op[0]=='L')q[i].o=0;\n\t\tif(op[0]=='R')q[i].o=1;\n\t\tif(op[0]=='D')q[i].o=2;\n\t\tif(op[0]=='U')q[i].o=3;\n\t}\n\tfor(int i=1;i<=n;i++)solve(i);\n\tprintf(\"%lld\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\nnamespace flow{\n\tconst ll __ = 1e6 + 7 , _ = 1e5 + 7;\n\tstruct Edge{ll end , upEd , f , c;}Ed[__];\n\tll head[_] , cntEd , S , T;\n\tvoid clear(){memset(head , 0 , sizeof(head)); cntEd = 1; S = T = 0;}\n\tvoid addEd(ll a , ll b , ll c , ll d){Ed[++cntEd] = (Edge){b , head[a] , c , d}; head[a] = cntEd;}\n\tvoid addE(ll a , ll b , ll c , ll d){addEd(a , b , c , d); addEd(b , a , 0 , -d);}\n\n\tbool vis[_]; queue < ll > q; ll dis[_] , pre[_];\n\tbool bfs(){\n\t\tq.push(S); memset(dis , -0x3f , sizeof(ll) * (T + 2)); dis[S] = 0;\n\t\twhile(!q.empty()){\n\t\t\tll t = q.front(); q.pop(); vis[t] = 0;\n\t\t\tfor(ll i = head[t] ; i ; i = Ed[i].upEd)\n\t\t\t\tif(Ed[i].f && dis[Ed[i].end] < dis[t] + Ed[i].c){\n\t\t\t\t\tdis[Ed[i].end] = dis[t] + Ed[i].c; pre[Ed[i].end] = i;\n\t\t\t\t\tif(!vis[Ed[i].end]){vis[Ed[i].end] = 1; q.push(Ed[i].end);}\n\t\t\t\t}\n\t\t}\n\t\treturn dis[T] != dis[T + 1];\n\t}\n\t\n\tll EK(ll s , ll t , ll tarf , ll tarc){\n\t\tS = s; T = t; ll sum = 0;\n\t\twhile(bfs()){\n\t\t\tll cur = T; --tarf;\n\t\t\twhile(cur != S){\n\t\t\t\tll t = pre[cur]; cur = Ed[t ^ 1].end; --Ed[t].f; ++Ed[t ^ 1].f;\n\t\t\t\tif(Ed[t].c == 1e16) --tarc; else if(Ed[t].c == -1e16) ++tarc; else sum += Ed[t].c;\n\t\t\t}\n\t\t}\n\t\treturn !tarf && !tarc ? sum : -1;\n\t}\n}\n\nll bound[2][2][103] , N , M , X[83] , Y[83]; ll v[83];\n\nsigned main(){\n\tcin >> N; for(ll i = 1 ; i <= N ; ++i) cin >> X[i] >> Y[i] >> v[i];\n\tcin >> M; memset(bound , 0x3f , sizeof(bound));\n\tfor(ll i = 1 ; i <= M ; ++i){\n\t\tchar c; ll p , q; cin >> c >> p >> q;\n\t\tswitch(c){\n\t\tcase 'L': bound[0][0][p] = min(bound[0][0][p] , q); break;\n\t\tcase 'R': bound[0][1][p] = min(bound[0][1][p] , q); break;\n\t\tcase 'U': bound[1][0][p] = min(bound[1][0][p] , q); break;\n\t\tcase 'D': bound[1][1][p] = min(bound[1][1][p] , q); break;\n\t\t}\n\t}\n\tll ans = 0;\n\tfor(ll i = 1 ; i <= N ; ++i){\n\t\tflow::clear(); bool flg = bound[0][0][100] >= i && bound[1][1][100] >= i; ll cnt = 0;\n\t\tfor(ll j = 1 ; j <= 100 ; ++j){\n\t\t\tll dwn = max(0ll , i - bound[0][0][j - 1]) , up = bound[0][1][j]; flg &= dwn <= up;\n\t\t\tcnt += dwn; flow::addE(j , j + 1 , dwn , (ll)1e16); flow::addE(j , j + 1 , up - dwn , 0);\n\t\t}\n\t\tfor(ll j = 100 ; j ; --j){\n\t\t\tll dwn = max(0ll , i - bound[1][1][j - 1]) , up = bound[1][0][j]; flg &= dwn <= up;\n\t\t\tcnt += dwn; flow::addE(202 - j , 203 - j , dwn , (ll)1e16); flow::addE(202 - j , 203 - j , up - dwn , 0);\n\t\t}\n\t\tfor(ll j = 1 ; j <= N ; ++j) flow::addE(X[j] + 1 , 202 - Y[j] , 1 , v[j]);\n\t\tflow::addE(0 , 1 , i , 0); if(flg) ans = max(ans , flow::EK(0 , 202 , i , cnt));\n\t}\n\tcout << ans;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<set>\n//#define ls (rt<<1)\n//#define rs (rt<<1|1)\n#define vi vector<int>\n#define pb push_back\n#define mk make_pair\n#define pii pair<ll,ll>\n#define rep(i,a,b) for(int i=(a),i##end=(b);i<=i##end;i++)\n#define fi first\n#define se second\n#define int long long\ntypedef long long ll;\nusing namespace std;\nconst int maxn=520;\nconst int inf=1e18+100;\nint xl[maxn],xr[maxn],yl[maxn],yr[maxn],s=415,t=416;\nint head[maxn],cnt=1;\nstruct gg{\n    int u,v,w;ll cost;int next;\n    void insert(int U,int V,int W,ll Cost,int Next){\n        u=U,v=V,w=W,cost=Cost,next=Next;\n    }\n}side[(maxn*82)*2*4];\nstruct Point{\n    int x,y;\n    ll cost=0;\n}point[maxn];\nstruct Lim{\n    int a,b;char c;\n}lim[maxn];\nvoid ins(int u,int v,int w,ll cost){\n    side[++cnt].insert(u,v,w,cost,head[u]);head[u]=cnt;\n    side[++cnt].insert(v,u,0,-cost,head[v]);head[v]=cnt;\n}\nint n,m;\nvoid init(int k){\n   rep(i,1,k)xl[i]=yl[i]=-inf,xr[i]=yr[i]=inf;\n   rep(i,1,m){\n       if(lim[i].c=='L')rep(j,lim[i].b+1,k)xl[j]=max(xl[j],lim[i].a+1);\n       else if(lim[i].c=='R')for(int j=k-lim[i].b;j>0;j--)xr[j]=min(xr[j],lim[i].a-1);\n       else if(lim[i].c=='D')rep(j,lim[i].b+1,k)yl[j]=max(yl[j],lim[i].a+1);\n       else if(lim[i].c=='U')for(int j=k-lim[i].b;j>0;j--)yr[j]=min(yr[j],lim[i].a-1);\n   }\n   memset(head,0,sizeof(head));cnt=1;\n   rep(i,1,k)ins(s,2*n+i,1,0);\n   rep(i,1,k)ins(2*n+k+i,t,1,0);\n   rep(i,1,n){\n        ins(i,n+i,1,point[i].cost);\n        rep(j,1,k){\n            if(xl[j]<=point[i].x&&point[i].x<=xr[j])ins(2*n+j,i,1,0);\n            if(yl[j]<=point[i].y&&point[i].y<=yr[j])ins(n+i,2*n+k+j,1,0);\n        }\n   }\n}\nint rk[maxn],q[maxn];\nll dis[maxn],lenth;\nbool vis[maxn];\nbool spfa(){\n    rep(i,1,maxn-1)dis[i]=-inf;\n    memset(vis,0,sizeof(vis));\n    int hd=1,tl=1;q[hd]=s;vis[s]=1;dis[s]=0;\n    while(hd<=tl){\n        int u=q[hd++];vis[u]=0;//cout<<u<<' '<<endl;\n        for(int i=head[u];i;i=side[i].next){\n            int v=side[i].v;if(!side[i].w)continue;\n            if(dis[u]+side[i].cost>dis[v]){\n                dis[v]=dis[u]+side[i].cost;\n                if(!vis[v])q[++tl]=v;\n                vis[v]=1;\n            }\n        }\n    }\n    if(dis[t]!=-inf)return 1;\n    return 0;\n}\nint dfs(int u,int flow){\n    if(u==t)return flow;\n    vis[u]=1;int tot=0;\n    for(int i=head[u];i;i=side[i].next){\n        int v=side[i].v;if(vis[v]||!side[i].w||dis[v]!=dis[u]+side[i].cost)continue;\n        int sent=dfs(v,min(flow,side[i].w));\n        lenth+=1ll*side[i].cost*sent,side[i].w-=sent,side[i^1].w+=sent,tot+=sent;flow-=sent;\n    }\n   // vis[u]=0;\n    return tot;\n}\npii dinic(){\n    int mxflow=0;lenth=0;\n    while(spfa()){\n        int x;\n        while((x=dfs(s,inf)))mxflow+=x;\n    }\n    return mk(mxflow,lenth);\n}\nchar tmp[3];\nsigned main(){\n    scanf(\"%lld\",&n);\n    rep(i,1,n)scanf(\"%lld%lld%lld\",&point[i].x,&point[i].y,&point[i].cost);\n    scanf(\"%lld\",&m);\n    rep(i,1,m){\n        scanf(\"%s%lld%lld\",tmp+1,&lim[i].a,&lim[i].b);lim[i].c=tmp[1];\n    }\n    ll out=0;\n    rep(k,1,n){\n        init(k);\n        pii ans=dinic();out=max(out,ans.se);//cout<<ans.se<<endl;\n    }\n    cout<<out;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>/*{{{*/\n#include<cctype>\n#include<cassert>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<ctime>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<set>\n#include<vector>\nusing namespace std;\ntypedef pair<int,int> pii;\n#define fi first\n#define se second\n#define pb push_back\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define ROF(i,a,b) for(int i=(a);i>=(b);--i)\nnamespace RA{\n    int r(int p){return 1ll*rand()*rand()%p;}\n    int r(int L,int R){return r(R-L+1)+L;}\n}/*}}}*/\n/******************heading******************/\ntypedef long long LL;\nconst LL LLINF=0x3f3f3f3f3f3f3f3f;\nconst int N=400,INF=0x3f3f3f3f;\n\nint s,t;\nstruct qxx{int nex,t,v;LL c;};\nqxx e[N*N*10];\nLL h[N],hh[N],le=1;\nvoid add_path(int f,int t,int v,LL c){e[++le]=(qxx){h[f],t,v,c},h[f]=le;}\nvoid add_flow(int f,int t,int v,LL c){\n    //printf(\"add_flow(%d,%d,%d,%lld)\\n\",f,t,v,c);\n    add_path(f,t,v,c),add_path(t,f,0,-c);}\n#define FORe(i,_u,_v,_w,_c)     for(LL i=h[_u],_v,_w,_c;_v=e[i].t,_w=e[i].v,_c=e[i].c,i;i=e[i].nex)\n#define FORflowe(i,_u,_v,_w,_c) for(LL &i=hh[_u],_v,_w,_c;_v=e[i].t,_w=e[i].v,_c=e[i].c,i;i=e[i].nex)\n\nint n,m;\nint x[N],y[N];\nLL val[N],ans=-LLINF;\nint xL[N],xR[N],yL[N],yR[N];\n\nvector<pii> L,R,U,D;\n\nqueue<int> q;\nbool vising[N];\nLL d[N];\nbool spfa(){\n    memset(d,0x3f,sizeof(d));\n    q.push(s),d[s]=0;\n    while(!q.empty()){\n        int u=q.front(); q.pop();\n        vising[u]=0;\n        FORe(i,u,v,w,c){\n            if(!w||d[v]<=d[u]+c)continue;\n            d[v]=d[u]+c;\n            if(!vising[v])q.push(v),vising[v]=1;\n        }\n    }\n    return d[t]!=LLINF;\n}\nLL mincost;\nbool vis[N];\nint dfs(int u,int flow){\n    vis[u]=1;\n    if(u==t)return flow;\n    int rest=flow;\n    FORflowe(i,u,v,w,c){\n        if(!rest)break;\n        if(vis[v]&&v!=t||!w||d[v]!=d[u]+c)continue;\n        int k=dfs(v,min(w,1ll*rest));\n        if(k)mincost+=k*c,e[i].v-=k,e[i^1].v+=k,rest-=k;\n        else d[v]=0;\n    }\n    return flow-rest;\n}\nLL go(){\n    int maxflow=0;\n    while(spfa()){\n        memcpy(hh,h,sizeof(h));\n        for(int i;memset(vis,0,sizeof(vis)),(i=dfs(s,INF))&&vis[t];)maxflow+=i;\n    }\n    //printf(\"maxflow=%d,mincost=%lld\\n\",maxflow,mincost);\n    return mincost;\n}\nvoid init(){\n    memset(h,0,sizeof(h));\n    le=1,mincost=0;\n}\nvoid calc(int k){\n    //printf(\"calc(%d)\\n\",k);\n    for(pii x:L)xL[x.se+1]=x.fi+1; //x[b+1] >= a+1\n    for(pii x:R)if(k-x.se>0)xR[k-x.se]=x.fi-1; //x[k-b] <= a-1\n    for(pii x:D)yL[x.se+1]=x.fi+1;\n    for(pii x:U)if(k-x.se>0)yR[k-x.se]=x.fi-1; //BUG#1:忘判>0\n    xR[k+1]=INF;\n    FOR(i,1,k)if(!xL[i])xL[i]=xL[i-1];\n    ROF(i,k,1)if(!xR[i])xR[i]=xR[i+1];\n    yR[k+1]=INF;\n    FOR(i,1,k)if(!yL[i])yL[i]=yL[i-1];\n    ROF(i,k,1)if(!yR[i])yR[i]=yR[i+1];\n    //FOR(i,1,k)printf(\"[%d,%d]%c\",xL[i],xR[i],\" \\n\"[i==k]);\n    //FOR(i,1,k)printf(\"[%d,%d]%c\",yL[i],yR[i],\" \\n\"[i==k]);\n\n    // item: 1 - n, n+1 - 2n\n    // x : 2n+1 - 2n+k\n    // y : 2n+k+1 - 2n+2k\n    // s : 0\n    // t : 2n+2k+1\n    init();\n    s=0,t=2*n+2*k+1;\n    //printf(\"s=%d,t=%d\\n\",s,t);\n    FOR(i,1,k)add_flow(s,2*n+i,1,0);\n    FOR(i,1,k)FOR(j,1,n)if(xL[i]<=x[j]&&x[j]<=xR[i])add_flow(2*n+i,j,INF,0);\n    FOR(i,1,n)add_flow(i,i+n,1,-val[i]);\n    FOR(i,1,k)FOR(j,1,n)if(yL[i]<=y[j]&&y[j]<=yR[i])add_flow(j+n,2*n+k+i,INF,0);\n    FOR(i,1,k)add_flow(2*n+k+i,t,1,0);\n\n    LL res=go();\n    ans=max(ans,-res);\n}\n\nint main(){\n    scanf(\"%d\",&n);\n    FOR(i,1,n)scanf(\"%d%d%lld\",&x[i],&y[i],&val[i]);\n    scanf(\"%d\",&m);\n    FOR(i,1,m){\n        char t[10];\n        int a,b;\n        scanf(\"%s%d%d\",t,&a,&b);\n        if(t[0]=='L')L.pb({a,b});\n        else if(t[0]=='R')R.pb({a,b});\n        else if(t[0]=='U')U.pb({a,b});\n        else D.pb({a,b});\n    }\n    FOR(i,1,n)calc(i);\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\n  _|_|                              _|  _|    _|\n_|    _|  _|  _|_|  _|_|_|_|        _|  _|  _|\n_|    _|  _|_|          _|          _|  _|_|\n_|    _|  _|          _|      _|    _|  _|  _|\n  _|_|    _|        _|_|_|_|    _|_|    _|    _|\n\n*/\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<set>\n//#define ls (rt<<1)\n//#define rs (rt<<1|1)\n#define vi vector<int>\n#define pb push_back\n#define mk make_pair\n#define pii pair<ll,ll>\n#define rep(i,a,b) for(int i=(a),i##end=(b);i<=i##end;i++)\n#define fi first\n#define se second\n#define int long long\ntypedef long long ll;\nusing namespace std;\nconst int maxn=420;\nconst int inf=1e18+100;\nint xl[maxn],xr[maxn],yl[maxn],yr[maxn],s=415,t=416;\nint head[maxn],cnt=1;\nstruct gg{\n    int u,v,w;ll cost;int next;\n    void insert(int U,int V,int W,ll Cost,int Next){\n        u=U,v=V,w=W,cost=Cost,next=Next;\n    }\n}side[(maxn*82)*2*4];\nstruct Point{\n    int x,y;\n    ll cost=0;\n}point[maxn];\nstruct Lim{\n    int a,b;char c;\n}lim[maxn];\nvoid ins(int u,int v,int w,ll cost){\n    side[++cnt].insert(u,v,w,cost,head[u]);head[u]=cnt;\n    side[++cnt].insert(v,u,0,-cost,head[v]);head[v]=cnt;\n}\nint n,m;\nvoid init(int k){\n   rep(i,1,k)xl[i]=yl[i]=-inf,xr[i]=yr[i]=inf;\n   rep(i,1,m){\n       if(lim[i].c=='L')rep(j,lim[i].b+1,k)xl[j]=max(xl[j],lim[i].a+1);\n       else if(lim[i].c=='R')for(int j=k-lim[i].b;j>0;j--)xr[j]=min(xr[j],lim[i].a-1);\n       else if(lim[i].c=='D')rep(j,lim[i].b+1,k)yl[j]=max(yl[j],lim[i].a+1);\n       else if(lim[i].c=='U')for(int j=k-lim[i].b;j>0;j--)yr[j]=min(yr[j],lim[i].a-1);\n   }\n   memset(head,0,sizeof(head));cnt=1;\n   rep(i,1,k)ins(s,2*n+i,1,0);\n   rep(i,1,k)ins(2*n+k+i,t,1,0);\n   rep(i,1,n){\n        ins(i,n+i,1,point[i].cost);\n        rep(j,1,k){\n            if(xl[j]<=point[i].x&&point[i].x<=xr[j])ins(2*n+j,i,1,0);\n            if(yl[j]<=point[i].y&&point[i].y<=yr[j])ins(n+i,2*n+k+j,1,0);\n        }\n   }\n}\nint rk[maxn],q[maxn];\nll dis[maxn],lenth;\nbool vis[maxn];\nbool spfa(){\n    rep(i,1,maxn-1)dis[i]=-inf;\n    memset(vis,0,sizeof(vis));\n    int hd=1,tl=1;q[hd]=s;vis[s]=1;dis[s]=0;\n    while(hd<=tl){\n        int u=q[hd++];vis[u]=0;//cout<<u<<' '<<endl;\n        for(int i=head[u];i;i=side[i].next){\n            int v=side[i].v;if(!side[i].w)continue;\n            if(dis[u]+side[i].cost>dis[v]){\n                dis[v]=dis[u]+side[i].cost;\n                if(!vis[v])q[++tl]=v;\n                vis[v]=1;\n            }\n        }\n    }\n    if(dis[t]!=-inf)return 1;\n    return 0;\n}\nint dfs(int u,int flow){\n    if(u==t)return flow;\n    vis[u]=1;int tot=0;\n    for(int i=head[u];i;i=side[i].next){\n        int v=side[i].v;if(vis[v]||!side[i].w||dis[v]!=dis[u]+side[i].cost)continue;\n        int sent=dfs(v,min(flow,side[i].w));\n        lenth+=1ll*side[i].cost*sent,side[i].w-=sent,side[i^1].w+=sent,tot+=sent;flow-=sent;\n    }\n   // vis[u]=0;\n    return tot;\n}\npii dinic(){\n    int mxflow=0;lenth=0;\n    while(spfa()){\n        int x;\n        while((x=dfs(s,inf)))mxflow+=x;\n    }\n    return mk(mxflow,lenth);\n}\nchar tmp[3];\nsigned main(){\n    scanf(\"%lld\",&n);\n    rep(i,1,n)scanf(\"%lld%lld%lld\",&point[i].x,&point[i].y,&point[i].cost);\n    scanf(\"%lld\",&m);\n    rep(i,1,m){\n        scanf(\"%s%lld%lld\",tmp+1,&lim[i].a,&lim[i].b);lim[i].c=tmp[1];\n    }\n    ll out=0;\n    rep(k,1,n){\n        init(k);\n        pii ans=dinic();out=max(out,ans.se);//cout<<ans.se<<endl;\n    }\n    cout<<out;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#define foreach(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\n#ifndef LOCAL\n#define cerr if(0)cout\n#endif\ntypedef long long ll;\nconst int mod = 1e9+7;\n//My i/o stream\nstruct fastio\n{\n\tchar s[100000];\n\tint it, len;\n\tfastio() {it=len=0;}\n\tinline char get()\n\t{\n\t\tif (it<len) return s[it++]; it=0;\n\t\tlen=fread(s, 1, 100000, stdin);\n\t\tif (len==0) return EOF; else return s[it++];\n\t}\n\tbool notend()\n\t{\n\t\tchar c=get();\n\t\twhile (c==' '||c=='\\n') c=get();\n\t\tif (it>0) it--;\n\t\treturn c!=EOF;\n\t}\n}_buff;\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putchar(' ')\n#define putii(x,y) puti(x),puti(y)\n#define putiii(x,y,z) putii(x,y),puti(z)\n#define putsi(x) putnum(x),putchar('\\n')\n#define putsii(x,y) puti(x),putsi(y)\n#define putsiii(x,y,z) putii(x,y),putsi(z)\ninline ll getnum()\n{\n\tll r=0; bool ng=0; char c; c=_buff.get();\n\twhile (c!='-'&&(c<'0'||c>'9')) c=_buff.get();\n\tif (c=='-') ng=1, c=_buff.get();\n\twhile (c>='0'&&c<='9') r=r*10+c-'0', c=_buff.get();\n\treturn ng?-r:r;\n}\ntemplate <class T> inline void putnum(T x)\n{\n\tif (x<0) putchar('-'), x=-x;\n\tregister short a[20]={}, sz=0;\n\twhile (x) a[sz++]=x%10, x/=10;\n\tif(sz==0) putchar('0');\n\tfor (int i=sz-1; i>=0; i--) putchar('0'+a[i]);\n}\ninline char getreal() {char c=_buff.get(); while (c<=32) c=_buff.get(); return c;}\nll qpow(ll x, ll k) {return k==0? 1: 1ll*qpow(1ll*x*x%mod,k>>1)*(k&1?x:1)%mod;}\nconst ll inf = 4e18;\nnamespace F\n{\n\tconst int maxn=2011,maxm=200011*2;\n\tint head[maxn],nxt[maxm],cap[maxm],to[maxm],tot;\n\tll cost[maxm];\n\tll ftot=0;\n\tll base_ans;\n\tvoid init()\n\t{\n\t\tmemset(head,0,sizeof(head));\n\t\ttot=1;ftot=0;\n\t\tbase_ans=0;\n\t}\n\tvoid add_edge(int x,int y,int c,ll w)\n\t{\n//\t\tcerr<<\"adde:\"<<x<<\",\"<<y<<\" \"<<c<<\" \"<<w<<endl;\n\t\tnxt[++tot]=head[x];\n\t\thead[x]=tot;\n\t\tto[tot]=y;\n\t\tcap[tot]=c;\n\t\tcost[tot]=w;\n\t\tnxt[++tot]=head[y];\n\t\thead[y]=tot;\n\t\tto[tot]=x;\n\t\tcap[tot]=0;\n\t\tcost[tot]=-w;\n\t}\n\tll dis[maxn];\n\tbool inq[maxn];\n\tint q[maxn],qb,qe;\n\tbool vis[maxn];\n\tvoid spfa(int S,int T,int N)\n\t{\n\t\tfor(int i=0;i<=N;i++)dis[i]=4e18;\n\t\tqb=qe=0;\n\t\tq[qe++]=S;dis[S]=0;inq[S]=1;\n\t\twhile(qb!=qe)\n\t\t{\n\t\t\tint x=q[qb++];inq[x]=0;\n\t\t\tif(qb==maxn)qb=0;\n\t\t\tfor(int i=head[x];i;i=nxt[i])\n\t\t\t{\n\t\t\t\tint u=to[i];\n\t\t\t\tif(cap[i]&&dis[u]>dis[x]+cost[i])\n\t\t\t\t{\n\t\t\t\t\tdis[u]=dis[x]+cost[i];\n\t\t\t\t\tif(!inq[u])\n\t\t\t\t\t{\n\t\t\t\t\t\tinq[u]=1;\n\t\t\t\t\t\tif(qb==qe||dis[u]>dis[q[qb]])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tq[qe++]=u;\n\t\t\t\t\t\t\tif(qe==maxn)qe=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tqb--;\n\t\t\t\t\t\t\tif(qb<0)qb=maxn-1;\n\t\t\t\t\t\t\tq[qb]=u;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int x,int T,int f)\n\t{\n\t\tif(x==T)return f;\n\t\tint of=f;\n\t\tvis[x]=1;\n\t\tfor(int i=head[x];i;i=nxt[i])\n\t\t{\n\t\t\tint u=to[i];\n\t\t\tif(dis[x]+cost[i]==dis[u]&&cap[i]>0&&!vis[u])\n\t\t\t{\n\t\t\t\tint d=dfs(u,T,min(f,cap[i]));\n\t\t\t\tif(d>0)\n\t\t\t\t{\n\t\t\t\t\tf-=d;\n\t\t\t\t\tcap[i]-=d;\n\t\t\t\t\tcap[i^1]+=d;\n\t\t\t\t\tif(f==0)return of;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn of-f;\n\t}\n\tll MinCostFlow(int S,int T,int K,bool mini,int N=-1)\n\t{\n\t\tif(N==-1)N=maxn-1;\n\t\tll ans=0;\n\t\twhile(K>0)\n\t\t{\n\t\t\tspfa(S,T,N);\n\t\t\tif(dis[T]>3e18)break;\n\t\t\tif(dis[T]>0&&mini)break;\n\t\t\tint flow=0;\n\t\t\tdo\n\t\t\t{\n\t\t\t\tfor(int i=0;i<=N;i++)vis[i]=0;\n\t\t\t\tK-=flow;\n\t\t\t\tftot+=flow;\n\t\t\t\tans+=flow*dis[T];\n\t\t\t}while(flow=dfs(S,T,K));\n\t\t}\n\t\treturn ans;\n\t}\n\tbool modlabel(int N)\n\t{\n\t\tll mn=5e18;\n\t\tfor(int i=0;i<=N;i++)if(vis[i])\n\t\t\tfor(int j=head[i];j;j=nxt[j])if(!vis[to[j]]&&cap[j])\n\t\t\t\tmn=min(mn,cost[j]-(dis[to[j]]-dis[i]));\n\t\tfor(int i=0;i<=N;i++)if(!vis[i])dis[i]+=mn;\n\t\treturn mn<4e18;\n\t}\n\tll MinCostFlow_zkw(int S,int T,int K,bool mini,int N=-1)\n\t{\n\t\tif(N==-1)N=maxn-1;\n\t\tspfa(S,T,N);\n\t\tll ans=0;\n\t\tdo\n\t\t{\n\t\t\tif(dis[T]>0&&mini)break;\n\t\t\tint f=0;\n\t\t\tdo\n\t\t\t{\n\t\t\t\tans+=dis[T]*f;\n\t\t\t\tK-=f;ftot+=f;\n\t\t\t\tif(K==0)break;\n\t\t\t\tfor(int i=0;i<=N;i++)vis[i]=0;\n\t\t\t}while(f=dfs(S,T,K));\n\t\t}while(K>0&&modlabel(N));\n\t\treturn ans;\n\t}\n};\nint n;\nint tid[256];\npair<int,int> a[88];\nll w[88];\nvector<pair<int,int> > M[4];\npair<int,int> segx[88], segy[88];\nll solve(int K)\n{\n//\tcerr<<\"solve: \"<<K<<endl;\n\tfor (int i=1; i<=K; i++) segx[i] = segy[i] = MP(0, 100);\n\tfor (auto x : M[0])\n\t{\n\t\tfor (int i=x.SS+1; i<=K; i++)\n\t\t{\n\t\t\tsegx[i].FF = max(segx[i].FF, x.FF+1);\n\t\t}\n\t}\n\tfor (auto x : M[1])\n\t{\n\t\tfor (int i=K-x.SS; i>=1; i--)\n\t\t{\n\t\t\tsegx[i].SS = min(segx[i].SS, x.FF-1);\n\t\t}\n\t}\n\tfor (auto x : M[2])\n\t{\n\t\tfor (int i=x.SS+1; i<=K; i++)\n\t\t{\n\t\t\tsegy[i].FF = max(segy[i].FF, x.FF+1);\n\t\t}\n\t}\n\tfor (auto x : M[3])\n\t{\n\t\tfor (int i=K-x.SS; i>=1; i--)\n\t\t{\n\t\t\tsegy[i].SS = min(segy[i].SS, x.FF-1);\n\t\t}\n\t}\n\tint S = 2*K+2*n+1, T = S+1;\n\tF::init();\n\tfor (int i=1; i<=K; i++)\n\t{\n\t\tF::add_edge(S, i, 1, 0);\n\t\tF::add_edge(i+K, T, 1, 0);\n\t\tfor (int j=1; j<=n; j++)\n\t\t{\n\t\t\tif (segx[i].FF<=a[j].FF&&a[j].FF<=segx[i].SS)\n\t\t\t{\n\t\t\t\tF::add_edge(i, j+2*K, 1, 0);\n\t\t\t}\n\t\t\tif (segy[i].FF<=a[j].SS&&a[j].SS<=segy[i].SS)\n\t\t\t{\n\t\t\t\tF::add_edge(j+2*K+n, i+K, 1, 0);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1; i<=n; i++) F::add_edge(i+2*K, i+2*K+n, 1, -w[i]);\n\tll ans = F::MinCostFlow(S, T, K, 0, T);\n//\tcerr<<\"F::ftot=\"<<F::ftot<<endl;\n\tif (F::ftot<K) return 0;\n//\tcerr<<\"ans=\"<<ans<<endl;\n\treturn -ans;\n}\nint main()\n{\n\ttid['L'] = 0;\n\ttid['R'] = 1;\n\ttid['D'] = 2;\n\ttid['U'] = 3;\n\tgeti(n);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tll x, y, v;\n\t\tgetiii(x, y, v);\n\t\ta[i] = MP(x, y);\n\t\tw[i] = v;\n\t}\n\tint m;\n\tgeti(m);\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\tchar t;\n\t\tint a, b;\n\t\tt = getreal();\n\t\tgetii(a, b);\n\t\tM[tid[t]].PB(MP(a, b));\n\t}\n\tll ans = 0;\n\tfor (int K=1; K<=n; K++)\n\t{\n\t\tans = max(ans, solve(K));\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<queue>\nusing namespace std;\n#define ll long long\nll gi(){\n    ll x=0,w=1;char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();\n    if(ch=='-')w=0,ch=getchar();\n    while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();\n    return w?x:-x;\n}\nint gc(){\n    char ch=getchar();\n    while(ch<'A'||ch>'Z')ch=getchar();\n    return ch;\n}\nconst int N=405;\nstruct edge{int to,nxt,w;ll cost;}E[N*N];\nint n,m,x[N],y[N],t[N],a[N],b[N],L[N],R[N],D[N],U[N],head[N],cnt,S,T,vis[N],pe[N];\nll v[N],dis[N],ans;queue<int>Q;\nvoid link(int u,int v,ll w){\n    E[++cnt]=(edge){v,head[u],1,w};head[u]=cnt;\n    E[++cnt]=(edge){u,head[v],0,-w};head[v]=cnt;\n}\nbool spfa(ll &res){\n    memset(dis,63,sizeof(dis));\n    dis[S]=0;Q.push(S);\n    while(!Q.empty()){\n        int u=Q.front();Q.pop();vis[u]=0;\n        for(int i=head[u],v;i;i=E[i].nxt)\n            if(E[i].w&&dis[v=E[i].to]>dis[u]+E[i].cost){\n                dis[v]=dis[u]+E[i].cost;pe[v]=i;\n                if(!vis[v])vis[v]=1,Q.push(v);\n            }\n    }\n    if(dis[T]==dis[0])return false;res+=dis[T];\n    for(int i=T;i!=S;i=E[pe[i]^1].to)--E[pe[i]].w,++E[pe[i]^1].w;\n    return true;\n}\nll cal(int k){\n    for(int i=1;i<=k;++i)L[i]=D[i]=0,R[i]=U[i]=233;\n    for(int i=1;i<=m;++i)\n        if(b[i]<k){\n            if(t[i]=='L')L[b[i]+1]=a[i]+1;\n            if(t[i]=='R')R[k-b[i]]=a[i]-1;\n            if(t[i]=='D')D[b[i]+1]=a[i]+1;\n            if(t[i]=='U')U[k-b[i]]=a[i]-1;\n        }\n    for(int i=2;i<=k;++i)L[i]=max(L[i],L[i-1]),D[i]=max(D[i],D[i-1]);\n    for(int i=k-1;i;--i)R[i]=min(R[i],R[i+1]),U[i]=min(U[i],U[i+1]);\n    memset(head,0,sizeof(head));cnt=1;S=n+k<<1|1;T=n+k+1<<1;\n    for(int i=1;i<=n;++i)link(i,n+i,-v[i]-1000000000000000ll);\n    for(int i=1;i<=k;++i){\n        link(S,n+n+i,0);link(n+n+k+i,T,0);\n        for(int j=1;j<=n;++j){\n            if(L[i]<=x[j]&&x[j]<=R[i])link(n+n+i,j,0);\n            if(D[i]<=y[j]&&y[j]<=U[i])link(n+j,n+n+k+i,0);\n        }\n    }\n    // printf( \"t = %d\\n\" , cnt );\n    ll res=0;while(spfa(res));return -res-1000000000000000ll*k;\n}\nint main(){\n    n=gi();\n    for(int i=1;i<=n;++i)x[i]=gi(),y[i]=gi(),v[i]=gi();\n    m=gi();\n    for(int i=1;i<=m;++i)t[i]=gc(),a[i]=gi(),b[i]=gi();\n    for(int i=1;i<=n;++i)ans=max(ans,cal(i));\n    printf(\"%lld\\n\",ans);return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nostream &operator<<(ostream &os, __float128 f) { return os << (LD)f; }\n\n\nstruct Simplex {        // Maximize c*x subject to Ax <= b.\n  using T = __float128; // Initialize the structure, set A, b, c and then run\n  vector<vector<T>> A;  // solve(). Max objective is stored in res. To recover\n  vector<T> b, c;       // the best result, use getVars().\n  T abs(T x) { return x < 0 ? -x : x; }\n\n  int V, E;\n  VI eqIds, varIds, cols;\n  T res;\n  const LD kEps = 1e-9;\n\n  Simplex(int vars, int eqs) : A(eqs, vector<T>(vars)), b(eqs), c(vars),\n                               V(vars), E(eqs), eqIds(eqs), varIds(vars), res(0) {\n    iota(ALL(varIds), 0); iota(ALL(eqIds), vars);\n  }\n\n  void pivot(int eq, int var) {\n    T coef = 1 / A[eq][var];\n    cols.clear();\n    REP (i, V) {\n      if (abs(A[eq][i]) > kEps) { cols.PB(i); A[eq][i] *= coef; }\n    }\n    A[eq][var] *= coef; b[eq] *= coef;\n    REP (row, E) {\n      if (row == eq || abs(A[row][var]) < kEps) { continue; }\n      T k = -A[row][var];\n      A[row][var] = 0;\n      for (int i : cols) { A[row][i] += k * A[eq][i]; }\n      b[row] += k * b[eq];\n    }\n    T q = c[var]; c[var] = 0;\n    for (int i : cols) { c[i] -= q * A[eq][i]; }\n    res += q * b[eq];\n\n    swap(varIds[var], eqIds[eq]);\n  }\n  \n  bool solve() {\n    while (true) {\n      int eq = -1, var = -1;\n      REP (i, E) { if (b[i] < -kEps) { eq = i; break; } }\n      if (eq == -1) { break; }\n      REP (i, V) { if (A[eq][i] < -kEps) { var = i; break; } }\n      if (var == -1) { res = -1e9; return false; /* No solution */ }\n      pivot(eq, var);\n    }\n\n    while (true) {\n      int var = -1, eq = -1;\n      REP (i, V) { if (c[i] > kEps) { var = i; break; } }\n      if (var == -1) { break; }\n      REP (i, E) {\n        if (A[i][var] < kEps) { continue; }\n        if (eq >= 0 && b[i] / A[i][var] >= b[eq] / A[eq][var]) { continue; }\n        eq = i;\n      }\n      if (eq == -1) { res = 1e9; return false; /* Unbounded */ }\n      pivot(eq, var);\n    }\n\n    return true;\n  }\n  \n  vector<T> getVars() {  // Optimal assignment of variables.\n    vector<T> result(V);\n    REP (i, E) { if (eqIds[i] < V) { result[eqIds[i]] = b[i]; } }\n    return result;\n  }\n};\n\nint N, M;\nvector<PII> points;\nVI point_vals;\n\nLL Solve(Simplex sim, LL low_bound) {\n  Simplex sim_copy = sim;\n  assert(sim.solve());\n\n  if (sim.res - 1e-9 < low_bound) { return -1; }\n  auto vars = sim.getVars();\n\n  LL my_low = 0;\n  for (int i = 0; i < N; ++i) {\n    if (vars[i] > .99) {\n      my_low += point_vals[i];\n      sim_copy.b[M + i * 2] = -1;\n    }\n  }\n\n  maxi(low_bound, my_low);\n\n  for (int i = 0; i < N; ++i) {\n    if (vars[i] > .01 && vars[i] < .989) {\n      // take?\n      sim_copy.b[M + i * 2] = -1;\n      maxi(low_bound, Solve(sim_copy, low_bound));\n      // don't take?\n      sim_copy.b[M + i * 2] = 0;\n      sim_copy.b[M + i * 2 + 1] = 0;\n      maxi(low_bound, Solve(sim_copy, low_bound));\n      break;\n    }\n  }\n\n  return low_bound;\n}\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n\n  cin >> N;\n  points.resize(N);\n  point_vals.resize(N);\n\n  for (int i = 0; i < N; ++i) {\n    cin >> points[i].st >> points[i].nd >> point_vals[i];\n  }\n\n  map<char, function<bool(PII, int)>> checkers = {\n    {'L', [](const PII &pt, int a) { return pt.st <= a; }},\n    {'R', [](const PII &pt, int a) { return pt.st >= a; }},\n    {'D', [](const PII &pt, int a) { return pt.nd <= a; }},\n    {'U', [](const PII &pt, int a) { return pt.nd >= a; }}\n  };\n\n  cin >> M;\n\n  Simplex sim(N, M + 2 * N);\n  for (int i = 0; i < M; ++i) {\n    char type;\n    int a, b;\n    cin >> type >> a >> b;\n\n    for (int j = 0; j < N; ++j) {\n      sim.A[i][j] = checkers[type](points[j], a);\n    }\n    sim.b[i] = b;\n\n    debug(sim.A[i], sim.b[i]);\n  }\n  for (int i = 0; i < N; ++i) {\n    sim.c[i] = point_vals[i];\n    sim.A[M + i * 2][i] = -1;\n    sim.A[M + i * 2 + 1][i] = 1;\n    sim.b[M + i * 2] = 0;\n    sim.b[M + i * 2 + 1] = 1;\n  }\n  auto orig_a = sim.A;\n  auto orig_b = sim.b;\n\n  cout << Solve(sim, 0) << \"\\n\";\n\n  /*assert(sim.solve());\n  auto vars = sim.getVars();\n\n  vector<int> always, maybe;\n  debug(vars);\n  for (int i = 0; i < N; ++i) {\n    if (vars[i] > 0.7) {\n      always.PB(i);\n    } else if (vars[i] > 0.3) {\n      maybe.PB(i);\n    }\n  }\n\n  debug(always, maybe);\n\n  assert(SZ(maybe) <= 3);\n  LL ans = -1;\n\n  for (LL m = 0; m < (1LL << SZ(maybe)); ++m) {\n    vector<int> mine = always;\n    for (int j = 0; j < SZ(maybe); ++j) {\n      if ((m >> j) & 1) { mine.PB(maybe[j]); }\n    }\n\n    bool fail = false;\n    for (int i = 0; i < M; ++i) {\n      int cnt = 0;\n      for (int j : mine) {\n        if (orig_a[i][j] > 0.5) { ++cnt; }\n      }\n      debug(mine, i, cnt, orig_b[i]);\n      if (cnt > (int)round((LD)orig_b[i])) { debug(i); fail = true; }\n    }\n\n    if (fail) { continue; }\n    LL x = 0;\n    for (int i : mine) {\n      x += point_vals[i];\n    }\n    maxi(ans, x);\n  }\n\n  cout << ans << \"\\n\";*/\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n#define REP(i, a, n) for(LL i = (a), i##_max = (n); i < i##_max; ++i)\n#define REM(i, a, n) for(LL i = (LL)(n) - 1, i##min = (a); i >= i##min; --i)\n#define ALL(arr) (arr).begin(), (arr).end()\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP {cin.tie(NULL); ios::sync_with_stdio(false);}\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst string INFSTR = \"\\x7f\";\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate<class T>\nT Compare(T left, T right) { return left > right ? 1 : (left < right ? -1 : 0); }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\ntemplate <class T>\nT Next() { T buf; cin >> buf; return buf; }\n\n#ifdef ONLY_MY_ENVIR\n#include \"IntMod.h\"\n#include \"UnionFind.h\"\n#include \"Graph.h\"\n#include \"Range.h\"\n#include \"Global.h\"\n#include \"FlowSolver.h\"\n#include \"Tree.h\"\n#include \"SuffixArray.h\"\n#include \"Matrix.h\"\n#include \"SegmentTree.h\"\n#include \"SegmentTree2D.h\"\n#include \"BIT.h\"\n#include \"Rational.h\"\n#include \"Position.h\"\n#include \"Factorization.h\"\n#include \"Math.h\"\n#include \"LazySegmentTree.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>> (istream& ist, __int128& val) { LL tmp;  ist >> tmp; val = tmp; return ist; }\nostream& operator<< (ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\n#if 1234567891\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\n// template <class T>\n// auto Is(const T& value) { return [value](const auto& comparand) -> bool { return comparand == value; }; }\n#endif\n\nint N, M;\nint x[80], y[80];\nLL v[80];\nchar t[320];\nint a[320], b[320];\nbool lim[320][80];\n\nvoid pre() {\n\tREP(j, 0, M) {\n\t\tREP(i, 0, N) {\n\t\t\tbool ng = false;\n\t\t\tswitch (t[j]) {\n\t\t\tcase 'L': ng = (x[i] <= a[j]); break;\n\t\t\tcase 'R': ng = (x[i] >= a[j]); break;\n\t\t\tcase 'D': ng = (y[i] <= a[j]); break;\n\t\t\tcase 'U': ng = (y[i] >= a[j]); break;\n\t\t\t}\n\t\t\tif (ng) lim[j][i] = true;\n\t\t}\n\t}\n}\n\nLL calc_score(const vector<bool>& ans) {\n\tLL score = 0;\n\tREP(i, 0, N) {\n\t\tif (ans[i]) {\n\t\t\tscore += v[i];\n\t\t}\n\t}\n\n\tREP(j, 0, M) {\n\t\tint cnt = 0;\n\t\tREP(i, 0, N) {\n\t\t\tif (!ans[i]) continue;\n\t\t\tif (!lim[j][i]) continue;\n\t\t\t++cnt;\n\t\t}\n\t\tif (cnt > b[j]) {\n\t\t\tscore -= 1e18;\n\t\t}\n\t}\n\treturn score;\n}\n\nLL sub() {\n\tpre();\n\tmt19937 mt;\n\tvector<bool> ans(N, false);\n\tLL score = calc_score(ans);\n\tLL mx = score;\n\tdouble temp_start = 1e15;\n\tdouble temp_end = 0.1;\n\tdouble temp = 5;\n\n\tconst int times = 100000;\n\tREP(z, 0, times) {\n\t\tint i = mt() % N;\n\n\t\tLL pre_score = score;\n\n\t\tans[i] = !ans[i];\n\n\t\tscore = calc_score(ans);\n\t\tmx = max(mx, score);\n\n\t\tLL delta = score - pre_score;\n\t\tbool accepted = delta > 0 ||\n\t\t\t(-delta < temp * 10 && exp(delta / temp) * (1ULL << 32) >= mt() );\n\n\t\tif (!accepted) {\n\t\t\tans[i] = !ans[i];\n\t\t\tscore = pre_score;\n\t\t}\n\n\t\tif (z % 256 == 0) {\n\t\t\tdouble ratio = z / (double)times;\n\t\t\ttemp = pow(temp_start, 1 - ratio) * pow(temp_end, ratio);\n\t\t\tcerr << temp << '\\t' << score << endl;\n\t\t}\n\t}\n\treturn mx;\n}\n\nint main() {\n\tcin >> N;\n\tREP(i, 0, N) {\n\t\tcin >> x[i] >> y[i] >> v[i];\n\t}\n\tcin >> M;\n\tREP(j, 0, M) {\n\t\tcin >> t[j] >> a[j] >> b[j];\n\t}\n\n\tcout << sub() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 16.03.2019 16:16:57       \n**/\n#undef _GLIBCXX_DEBUG\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring to_string(string s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntypedef long double ld;\n\nconst ld eps = 1e-8;\n\nvector<ld> simplex(vector<vector<ld>> a) {\n  int n = (int) a.size() - 1;\n  int m = (int) a[0].size() - 1;\n  vector<int> left(n + 1);\n  vector<int> up(m + 1);\n  iota(left.begin(), left.end(), m);\n  iota(up.begin(), up.end(), 0);\n  auto pivot = [&](int x, int y) {\n    swap(left[x], up[y]);\n    ld k = a[x][y];\n    a[x][y] = 1;\n    vector<int> pos;\n    for (int j = 0; j <= m; j++) {\n      a[x][j] /= k;\n      if (fabs(a[x][j]) > eps) {\n        pos.push_back(j);\n      }\n    }\n    for (int i = 0; i <= n; i++) {\n      if (fabs(a[i][y]) < eps || i == x) {\n        continue;\n      }\n      k = a[i][y];\n      a[i][y] = 0;\n      for (int j : pos) {\n        a[i][j] -= k * a[x][j];\n      }\n    }\n  };\n  while (1) {\n    int x = -1;\n    for (int i = 1; i <= n; i++) {\n      if (a[i][0] < -eps && (x == -1 || a[i][0] < a[x][0])) {\n        x = i;\n      }\n    }\n    if (x == -1) {\n      break;\n    }\n    int y = -1;\n    for (int j = 1; j <= m; j++) {\n      if (a[x][j] < -eps && (y == -1 || a[x][j] < a[x][y])) {\n        y = j;\n      }\n    }\n    if (y == -1) {\n      return vector<ld>(); // infeasible\n    }\n    pivot(x, y);\n  }\n  while (1) {\n    int y = -1;\n    for (int j = 1; j <= m; j++) {\n      if (a[0][j] > eps && (y == -1 || a[0][j] > a[0][y])) {\n        y = j;\n      }\n    }\n    if (y == -1) {\n      break;\n    }\n    int x = -1;\n    for (int i = 1; i <= n; i++) {\n      if (a[i][y] > eps && (x == -1 || a[i][0] / a[i][y] < a[x][0] / a[x][y])) {\n        x = i;\n      }\n    }\n    if (x == -1) {\n      return vector<ld>(); // unbounded\n    }\n    pivot(x, y);\n  }\n  vector<ld> ans(m + 1);\n  for (int i = 1; i <= n; i++) {\n    if (left[i] <= m) {\n      ans[left[i]] = a[i][0];\n    }\n  }\n  ans[0] = -a[0][0];\n  return ans;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<int> x(n), y(n);\n  vector<long long> z(n);\n  for (int i = 0; i < n; i++) {\n    cin >> x[i] >> y[i] >> z[i];\n  }\n  vector<vector<ld>> mat;\n  {\n    vector<ld> row(n + 1);\n    for (int i = 0; i < n; i++) {\n      row[i + 1] = z[i];\n    }\n    mat.push_back(row);\n  }\n  {\n    for (int i = 0; i < n; i++) {\n      vector<ld> row(n + 1);\n      row[0] = 1;\n      row[i + 1] = 1;\n      mat.push_back(row);\n    }\n  }\n  int tt;\n  cin >> tt;\n  for (int qq = 0; qq < tt; qq++) {\n    string foo;\n    int bar, baz;\n    cin >> foo >> bar >> baz;\n    vector<ld> row(n + 1);\n    row[0] = baz;\n    if (foo == \"L\") {\n      for (int i = 0; i < n; i++) if (x[i] <= bar) row[i + 1] = 1;\n    }\n    if (foo == \"R\") {\n      for (int i = 0; i < n; i++) if (x[i] >= bar) row[i + 1] = 1;\n    }\n    if (foo == \"D\") {\n      for (int i = 0; i < n; i++) if (y[i] <= bar) row[i + 1] = 1;\n    }\n    if (foo == \"U\") {\n      for (int i = 0; i < n; i++) if (y[i] >= bar) row[i + 1] = 1;\n    }\n    mat.push_back(row);\n  }\n  vector<ld> ret = simplex(mat);\n  debug(ret[0]);\n  vector<int> bads;\n  mt19937 rng((unsigned int) chrono::steady_clock::now().time_since_epoch().count());\n  for (int i = 0; i < n; i++) {\n    if (ret[i + 1] > eps && ret[i + 1] < 1 - eps || rng() % 20 == 0) {\n      bads.push_back(i);\n    }\n  }\n  debug(bads);\n  bads.resize(min((int) bads.size(), 12));\n  long long ans = 0;\n  loop:\n  int sz = (int) bads.size();\n  for (int t = 0; t < (1 << sz); t++) {\n    for (int i = 0; i < sz; i++) {\n      if (t & (1 << i)) {\n        mat[bads[i] + 1][0] = 1;\n        vector<ld> row(n + 1);\n        row[0] = -1;\n        row[bads[i] + 1] = -1;\n        mat.push_back(row);\n      } else {\n        mat[bads[i] + 1][0] = 0;\n      }\n    }\n    vector<ld> ret2 = simplex(mat);\n    if (!ret2.empty()) {\n      long long val = 0;\n      int ctr = 0;\n      for (int i = 0; i < n; i++) {\n        if (ret2[i + 1] > eps && ret2[i + 1] < 1 - eps) {\n          if (bads.size() < 12) {\n            bads.push_back(i);\n            debug(\"oh no goto\");\n            goto loop;\n          }\n        }\n        val += z[i] * (ret2[i + 1] > 1 - eps);\n      }\n      debug(val, ctr);\n      ans = max(ans, val);\n    }\n    mat.resize(n + tt + 1);\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nnamespace io{\n    const int l=1<<20;\n    char buf[l],*s,*t,c;\n    inline void gc(){\n        if(s==t){\n            t=(s=buf)+fread(buf,1,l,stdin);\n            c=s==t?EOF:*s++;\n        }else c=*s++;\n    }\n    template<class IT>inline void gi(IT &x){\n        x=0;gc();while(c<'0'||c>'9')gc();\n        while('0'<=c&&c<='9'){x=(x<<1)+(x<<3)+(c^48);gc();}\n    }\n    char buf0[20];int a;\n    template<class IT>inline void pi(IT x){\n        if(x<0){putchar('-');x=-x;}\n        do buf0[++a]=x%10+48;while(x/=10);\n        while(a)putchar(buf0[a--]);\n        putchar('\\n');\n    }\n};\nusing io::gi;\nusing io::pi;\ntypedef unsigned int ui;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<int,ll > pil;\ntypedef pair<ll ,int> pli;\ntypedef pair<ll ,ll > pll;\ntypedef vector<int> vi;\ntypedef vector<ll > vl;\n#define pque priority_queue\n#define rep(i,l,r) for(i=(l);i<=(r);++i)\n#define per(i,l,r) for(i=(l);i>=(r);--i)\n#define REP(i,l,r) for(i=(l);i< (r);++i)\n#define PER(i,l,r) for(i=(l);i> (r);--i)\n#define mp make_pair\n#define pb push_back\n#define pf push_front\n#define pob pop_back\n#define pof pop_front\n#define fi first\n#define se second\ntemplate<class IT>inline void cmax(IT &a,IT b){if(a<b)a=b;}\ntemplate<class IT>inline void cmin(IT &a,IT b){if(b<a)a=b;}\nconst int N=85,V=N<<2;\nstruct edge{\n\tint u,w1;ll w2;int n;\n\tinline edge(){}\n\tinline edge(int u,int w1,ll w2,int n):u(u),w1(w1),w2(w2),n(n){}\n}e[N*V];int f[V],tot;\ninline void add(int v,int u,ll w2=0ll){\n\t//printf(\"%d %d %lld\\n\",v,u,w2);\n\te[tot]=edge(u,1, w2,f[v]);f[v]=(tot++);\n\te[tot]=edge(v,0,-w2,f[u]);f[u]=(tot++);\n}\nint q[V],in[V],p[V],pe[V];ll d[V];\ninline ll spfa(int S){\n\tint l=1,r=1,v,i,u;ll w;\n\tq[1]=S;\n\tREP(i,1,S)d[i]=-1ll;d[S]=0ll;\n\twhile(l<=r){\n\t\tin[v=q[(l++)%N]]=0;\n\t\tfor(i=f[v];~i;i=e[i].n)if(e[i].w1){\n\t\t\tu=e[i].u;\n\t\t\tif((w=d[v]+e[i].w2)>d[u]){\n\t\t\t\td[u]=w;\n\t\t\t\tp[u]=v;\n\t\t\t\tpe[u]=i;\n\t\t\t\tif(!in[u]){\n\t\t\t\t\tin[u]=1;\n\t\t\t\t\tq[(++r)%V]=u;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn d[S-1];\n}\nstruct jewel{\n\tint x,y;ll z;\n}J[N];\nstruct clue{\n\tint a,b;char c;\n}C[V];\nint lx[N],rx[N],ly[N],ry[N];\nint main(){\n    //freopen(\"a.in\",\"r\",stdin);\n    //freopen(\"a.out\",\"w\",stdout);\n    int n,m,i,j,k,v,u,ans1;ll ans2,ans=0ll,f2;\n\tchar str[2];\n    scanf(\"%d\",&n);\n    rep(i,1,n)scanf(\"%d%d%lld\",&J[i].x,&J[i].y,&J[i].z);\n\tscanf(\"%d\",&m);\n\trep(i,1,m){scanf(\"%s%d%d\",str,&C[i].a,&C[i].b);C[i].c=str[0];}\n\trep(k,1,n){\n\t\trep(i,1,k)lx[i]=1  ;\n\t\trep(i,1,k)rx[i]=100;\n\t\trep(i,1,k)ly[i]=1  ;\n\t\trep(i,1,k)ry[i]=100;\n\t\trep(i,1,m)if(C[i].b<k){\n\t\t\tswitch(C[i].c){\n\t\t\t\tcase 'L':cmax(lx[  C[i].b+1],C[i].a+1);break;\n\t\t\t\tcase 'R':cmin(rx[k-C[i].b  ],C[i].a-1);break;\n\t\t\t\tcase 'D':cmax(ly[  C[i].b+1],C[i].a+1);break;\n\t\t\t\tcase 'U':cmin(ry[k-C[i].b  ],C[i].a-1);break;\n\t\t\t}\n\t\t}\n\t\trep(i,2,k)cmax(lx[i  ],lx[i-1]);\n\t\trep(i,2,k)cmax(ly[i  ],ly[i-1]);\n\t\tper(i,k,2)cmin(rx[i-1],rx[i  ]);\n\t\tper(i,k,2)cmin(ry[i-1],ry[i  ]);\n\t\t//rep(i,1,k)printf(\"[%d,%d] [%d,%d]\\n\",lx[i],rx[i],ly[i],ry[i]);\n\t\tmemset(f,-1,sizeof(f));tot=0;\n\t\tv=(u=((n+k)<<1|1))+1;\n\t\trep(i,1,k)add(v,(n<<1)+i  );\n\t\trep(i,1,k)add(k+(n<<1)+i,u);\n\t\trep(i,1,n)add(i,i+n,J[i].z);\n\t\trep(i,1,k)rep(j,1,n){\n\t\t\tif(lx[i]<=J[j].x&&J[j].x<=rx[i])add(    (n<<1)+i,j);\n\t\t\tif(ly[i]<=J[j].y&&J[j].y<=ry[i])add(j+n,(n<<1)+i+k);\n\t\t}\n\t\tans1=0;ans2=0ll;\n\t\twhile(~(f2=spfa(v))){\n\t\t\t++ans1;\n\t\t\tans2+=f2;\n\t\t\tfor(i=u;i!=v;i=p[i]){\n\t\t\t\te[pe[i]  ].w1=0;\n\t\t\t\te[pe[i]^1].w1=1;\n\t\t\t}\n\t\t}\n\t\t//printf(\"k=%d ans1=%d ans2=%lld\\n\",k,ans1,ans2);\n\t\tif(ans1!=k)break;cmax(ans,ans2);\n\t}\n\tprintf(\"%lld\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,a,b) for(int i=(a),_ed=(b);i<=_ed;++i)\n#define DREP(i,a,b) for(int i=(a),_ed=(b);i>=_ed;--i)\n#define mp(x,y) make_pair((x),(y))\n#define sz(x) (int)(x).size()\n#define pb push_back\ntypedef long long ll;\ntypedef pair<int,int> pii;\ninline ll read(){\n    register ll x=0,f=1;register char ch=getchar();\n    while(!isdigit(ch)){if(ch=='-')f=0;ch=getchar();}\n    while(isdigit(ch)){x=x*10+(ch^'0');ch=getchar();}\n    return f?x:-x;\n}\n\nconst int inf=1e9;\nconst ll INF=1e16;\nint n,m;char ch[10];\nstruct node{int x,y;ll v;} a[85];\nstruct query{int op,a,b;} q[325];\ninline void chkmax(int& x,int y){x=x>y?x:y;}\ninline void chkmin(int& x,int y){x=x<y?x:y;}\n\nint s,t,num,head[325],vis[325],flow[325],id[325],pre[325];\nll dis[325],ans;\nstruct edge{int to,next,flo;ll val;} e[200005];\ninline void add(int u,int v,int f,ll w){\n\te[++num]=(edge){v,head[u],f,w},head[u]=num;\n\te[++num]=(edge){u,head[v],0,-w},head[v]=num;\n}\n\nbool bfs(){\n\tqueue<int> q;\n\tREP(i,1,324)dis[i]=-INF;\n\tmemset(vis,0,sizeof vis);\n\tdis[s]=0,flow[s]=inf,q.push(s),vis[s]=1;\n\twhile(!q.empty()){\n\t\tint u=q.front();q.pop(),vis[u]=0;\n\t\tfor(int i=head[u];i;i=e[i].next){\n\t\t\tint v=e[i].to;\n\t\t\tif(!e[i].flo||dis[v]>=dis[u]+e[i].val)continue;\n\t\t\tdis[v]=dis[u]+e[i].val;\n\t\t\tflow[v]=min(flow[u],e[i].flo);\n\t\t\tid[v]=i,pre[v]=u;\n\t\t\tif(!vis[v])vis[v]=1,q.push(v);\n\t\t}\n\t}\n\treturn dis[t]>-INF;\n}\nll network(){\n\tll ans=0;\n\twhile(bfs()){\n\t\tans+=dis[t]*flow[t];\n\t\tint p=t;\n\t\twhile(p^s)e[id[p]].flo-=flow[t],e[id[p]^1].flo+=flow[t],p=pre[p];\n\t}\n\treturn ans;\n}\n\nvoid work(int K){\n\tint L[165],R[165];\n\tnum=1,memset(head,0,sizeof head);\n\ts=n+n+K+K+1,t=s+1;\n\tREP(i,1,n)add(i,n+i,1,a[i].v);\n\tmemset(L,0,sizeof L),memset(R,0x3f,sizeof R);\n\tREP(t,1,m){\n\t\tif(q[t].op==0)REP(i,q[t].b+1,K)chkmax(L[i],q[t].a+1);\n\t\telse if(q[t].op==1)REP(i,1,K-q[t].b)chkmin(R[i],q[t].a-1);\n\t\telse if(q[t].op==2)REP(i,q[t].b+1,K)chkmax(L[K+i],q[t].a+1);\n\t\telse REP(i,1,K-q[t].b)chkmin(R[K+i],q[t].a-1);\n\t}\n\tREP(i,1,K){\n\t\tadd(s,n+n+i,1,0);\n\t\tREP(j,1,n)if(L[i]<=a[j].x&&a[j].x<=R[i])add(n+n+i,j,1,0);\n\t}\n\tREP(i,K+1,K+K){\n\t\tadd(n+n+i,t,1,0);\n\t\tREP(j,1,n)if(L[i]<=a[j].y&&a[j].y<=R[i])add(n+j,n+n+i,1,0);\n\t}\n\tans=max(ans,network());\n}\n\nint main(){\n\tn=read();\n\tREP(i,1,n)a[i]=(node){read(),read(),read()};\n\tm=read();\n\tREP(i,1,m){\n\t\tscanf(\"%s\",ch);int o;\n\t\tif(ch[0]=='L')o=0;\n\t\telse if(ch[0]=='R')o=1;\n\t\telse if(ch[0]=='D')o=2;\n\t\telse o=3;\n\t\tq[i]=(query){o,read(),read()};\n\t}\n\tREP(i,1,n)\n\t\twork(i);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ri register int\ntypedef long long ll;\n#define rll register ll\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\t// input a signed integer\n\ttemplate <class I>\n\tinline void gi (I &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = (x << 1) + (x << 3) + (c & 15); x *= f;\n\t}\n\t// input a letter\n\ttemplate <class I>\n\tinline void get (I &x) {\n\t\tfor (c = gc(); c < 'A' || c > 'Z'; c = gc()) ;\n\t\tx = c;\n\t}\n\t// print a signed integer\n\ttemplate <class I>\n\tinline void print (I x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t}\n\t//no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io :: gi;\nusing io :: get;\nusing io :: putc;\nusing io :: print;\nconst int N=85,M=105,inf=2e9,L=325;\nconst ll INF=1e8;\nint flag,x0[N],_y0[N],lx[M],rx[M],ly[M],ry[M];\nll v0[N];\nstruct node{\n\tchar op;\n\tint a,b;\n}q[L];\ninline void chmin(int &x,ri y){\n\tx=min(x,y);\n}\ninline void chmax(int &x,ri y){\n\tx=max(x,y);\n}\nnamespace G{\n\tconst int _N=(M<<1)+N,_M=(M<<1)+(N<<1); \n\tconst ll INF=1e18;\n\tint size,s,t,m,a[_M],b[_M],c[_M],d[_M],deg[_N],\n\ttot=1,head[_N],nxt[_M<<2],adj[_M<<2],cap[_M<<2],q[_M<<5],S,T,flow,sum,vis[_N],cur[_N];\n\tll cost,dis[_N],val[_M<<2],e[_M];\n\tinline void addedge(ri x,ri y,ri c,rll w){\n\t\tnxt[++tot]=head[x];\n\t\tadj[head[x]=tot]=y;\n\t\tcap[tot]=c;\n\t\tval[tot]=w;\n\t}\n\tinline void Add(ri x,ri y,ri c,rll v){\n\t\taddedge(x,y,c,v);\n\t\taddedge(y,x,0,-v);\n\t}\n\tinline void add(ri x,ri y,ri lower,ri upper,rll cost){\n\t\tif(lower>upper) flag=0;\n\t\t++m;\n\t\ta[m]=x;\n\t\tb[m]=y;\n\t\tc[m]=lower;\n\t\td[m]=upper;\n\t\te[m]=cost;\n\t}\n\tinline void build(){\n\t\tri i;\n\t\tcost=0;\n\t\tfor(i=1;i<=m;++i)\n\t\t\tdeg[a[i]]-=c[i],\n\t\t\tdeg[b[i]]+=c[i],\n\t\t\tcost+=c[i]*e[i],\n\t\t\tAdd(a[i],b[i],d[i]-c[i],e[i]);\n\t\tS=size+1;\n\t\tT=size+2;\n\t\tsum=0;\n\t\tfor(i=1;i<=size;++i){\n\t\t\tif(deg[i]>0) Add(S,i, deg[i],0),sum+=deg[i];\n\t\t\tif(deg[i]<0) Add(i,T,-deg[i],0);\n\t\t}\n\t\tAdd(t,s,inf,0);\n\t\tsize+=2;\n\t}\n\tinline bool spfa(){\n\t\tri l,r,x,y,i;\n\t\tfor(i=1;i<=size;++i) dis[i]=-INF,vis[i]=0,cur[i]=head[i];\n\t\tq[l=r=1]=S;dis[S]=0; \n\t\twhile(l<=r){\n\t\t\tx=q[l++];vis[x]=0; \n\t\t\tfor(i=head[x];i;i=nxt[i])\n\t\t\t\tif(cap[i]&&dis[y=adj[i]]<dis[x]+val[i]){\n\t\t\t\t\tdis[y]=dis[x]+val[i];\n\t\t\t\t\tif(!vis[y]) q[++r]=y,vis[y]=1;\n\t\t\t\t}\n\t\t}\n\t\treturn dis[T]>-INF;\n\t}\n\tinline int dfs(ri x,ri now){\n\t\tif(x==T) return now;\n\t\tvis[x]=1;\n\t\tri y,tmp,res=0;\n\t\tfor(int &i=cur[x];i;i=nxt[i])\n\t\t\tif(!vis[y=adj[i]]&&cap[i]&&dis[y]==dis[x]+val[i])\n\t\t\t\tif(cap[i]-=(tmp=dfs(y,min(now-res,cap[i]))),cap[i^1]+=tmp,(res+=tmp)==now)\n\t\t\t\t\treturn vis[x]=false,res;\n\t\treturn res;\n\t}\n\tinline ll costflow(){\n\t\tri tmp;\n\t\tflow=0;\n\t\twhile(spfa())\n\t\t\ttmp=dfs(S,inf),\n\t\t\tflow+=tmp,\n\t\t\tcost+=tmp*dis[T];\n\t\tif(flow!=sum) return -INF;\n\t\treturn cost;\n\t}\n\tinline void clear(){\n\t\ttot=1;m=0;\n\t\tfor(ri i=1;i<=size;++i) head[i]=deg[i]=0;\n\t}\n}\nint posx[M],posy[M];\nint main(){\n\tri n,m,i,k,limx,limy;\n\tgi(n);\n\tlimx=limy=0;\n\tfor(i=1;i<=n;++i)\n\t\tgi(x0[i]),gi(_y0[i]),gi(v0[i]),\n\t\tlimx=max(limx,x0[i]),\n\t\tlimy=max(limy,_y0[i]);\n\tgi(m);\n\tfor(i=1;i<=m;++i){\n\t\tget(q[i].op);gi(q[i].a);gi(q[i].b);\n\t\tif(q[i].op=='L'||q[i].op=='R')\n\t\t\tlimx=max(limx,q[i].a);\n\t\telse\n\t\t\tlimy=max(limy,q[i].a);\n\t}\n\trll ans=0; \n\tfor(k=1;k<=n;++k){\n\t\tfor(i=1;i<=limx;++i)\n\t\t\tlx[i]=0,\n\t\t\trx[i]=inf;\n\t\tfor(i=1;i<=limy;++i)\n\t\t\tly[i]=0,\n\t\t\try[i]=inf;\n\t\tflag=1;\n\t\tfor(i=1;i<=m;++i)\n\t\t\tif(q[i].op=='L')\n\t\t\t\tchmin(rx[q[i].a],q[i].b);\n\t\t\telse if(q[i].op=='R'){\n\t\t\t\tif(q[i].a-1==0){\n\t\t\t\t\tif(k-q[i].b>0){\n\t\t\t\t\t\tflag=0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tchmax(lx[q[i].a-1],k-q[i].b);\n\t\t\t}\n\t\t\telse if(q[i].op=='D')\n\t\t\t\tchmin(ry[q[i].a],q[i].b);\n\t\t\telse{\n\t\t\t\tif(q[i].a-1==0){\n\t\t\t\t\tif(k-q[i].b>0){\n\t\t\t\t\t\tflag=0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tchmax(ly[q[i].a-1],k-q[i].b);\n\t\t\t}\n\t\tif(!flag) continue;\n\t\tfor(i=1;i<=limx;++i)\n\t\t\tlx[i]=max(lx[i-1],lx[i]);\n\t\tfor(i=limx-1;i;--i)\n\t\t\trx[i]=min(rx[i+1],rx[i]);\n\t\tfor(i=1;i<=limy;++i)\n\t\t\tly[i]=max(ly[i-1],ly[i]);\n\t\tfor(i=limy-1;i;--i)\n\t\t\try[i]=min(ry[i+1],ry[i]);\n\t\tG::size=n;\n\t\tfor(i=1;i<=limx;++i)\n\t\t\tposx[i]=++G::size;\n\t\tfor(i=1;i<=limy;++i)\n\t\t\tposy[i]=++G::size;\n\t\tG::s=++G::size;\n\t\tG::t=++G::size;\n\t\tG::add(G::s,posx[limx],max(k,lx[limx]),min(k,rx[limx]),0);\n\t\tfor(i=limx-1;i;--i)\n\t\t\tG::add(posx[i+1],posx[i],lx[i],rx[i],0);\n\t\tG::add(posy[limy],G::t,ly[limy],ry[limy],0);\n\t\tfor(i=1;i<limy;++i)\n\t\t\tG::add(posy[i],posy[i+1],ly[i],ry[i],0);\n\t\tfor(i=1;i<=n;++i)\n\t\t\tG::add(posx[x0[i]],i,0,1,v0[i]),\n\t\t\tG::add(i,posy[_y0[i]],0,1,0);\n\t\tif(!flag) continue;\n\t\tG::build();\n\t\tans=max(ans,G::costflow());\n\t\tG::clear();\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#define foreach(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\n#ifndef LOCAL\n#define cerr if(0)cout\n#endif\ntypedef long long ll;\nconst int mod = 1e9+7;\n//My i/o stream\nstruct fastio\n{\n\tchar s[100000];\n\tint it, len;\n\tfastio() {it=len=0;}\n\tinline char get()\n\t{\n\t\tif (it<len) return s[it++]; it=0;\n\t\tlen=fread(s, 1, 100000, stdin);\n\t\tif (len==0) return EOF; else return s[it++];\n\t}\n\tbool notend()\n\t{\n\t\tchar c=get();\n\t\twhile (c==' '||c=='\\n') c=get();\n\t\tif (it>0) it--;\n\t\treturn c!=EOF;\n\t}\n}_buff;\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putchar(' ')\n#define putii(x,y) puti(x),puti(y)\n#define putiii(x,y,z) putii(x,y),puti(z)\n#define putsi(x) putnum(x),putchar('\\n')\n#define putsii(x,y) puti(x),putsi(y)\n#define putsiii(x,y,z) putii(x,y),putsi(z)\ninline ll getnum()\n{\n\tll r=0; bool ng=0; char c; c=_buff.get();\n\twhile (c!='-'&&(c<'0'||c>'9')) c=_buff.get();\n\tif (c=='-') ng=1, c=_buff.get();\n\twhile (c>='0'&&c<='9') r=r*10+c-'0', c=_buff.get();\n\treturn ng?-r:r;\n}\ntemplate <class T> inline void putnum(T x)\n{\n\tif (x<0) putchar('-'), x=-x;\n\tregister short a[20]={}, sz=0;\n\twhile (x) a[sz++]=x%10, x/=10;\n\tif(sz==0) putchar('0');\n\tfor (int i=sz-1; i>=0; i--) putchar('0'+a[i]);\n}\ninline char getreal() {char c=_buff.get(); while (c<=32) c=_buff.get(); return c;}\nll qpow(ll x, ll k) {return k==0? 1: 1ll*qpow(1ll*x*x%mod,k>>1)*(k&1?x:1)%mod;}\nconst ll inf = 4e18;\nnamespace F\n{\n\tconst int maxn = 2011, maxe = 100011;\n\tint head[maxn], nxt[maxe], to[maxe], cap[maxe];\n\tll cost[maxe], tot;\n\tvoid init()\n\t{\n\t\ttot = 1;\n\t\tmemset(head, 0, sizeof(head));\n\t}\n\tvoid add_edge(int x, int y, int c, ll w)\n\t{\n//\t\tcerr<<\"add_edge:\"<<x<<\",\"<<y<<\" \"<<c<<\" \"<<w<<endl;\n\t\tnxt[++tot] = head[x];\n\t\thead[x] = tot;\n\t\tto[tot] = y;\n\t\tcap[tot] = c;\n\t\tcost[tot] = w;\n\t\tswap(x, y);\n\t\tnxt[++tot] = head[x];\n\t\thead[x] = tot;\n\t\tto[tot] = y;\n\t\tcap[tot] = 0;\n\t\tcost[tot] = -w;\n\t\tassert(tot<maxe);\n\t}\n\tint q[maxn], qb, qe;\n\tll dis[maxn];\n\tbool inq[maxn];\n\tint qnxt(int x) {return (x+1)%maxn;}\n\tint qpre(int x) {return (x-1+maxn)%maxn;}\n\tvoid balance()\n\t{\n\t\tif (qb!=qe&&dis[q[qpre(qe)]]<dis[q[qb]])\n\t\t{\n\t\t\tswap(q[qpre(qe)], q[qb]);\n\t\t}\n\t}\n\tvoid spfa(int S, int N)\n\t{\n\t\tinq[S] = 1;\n\t\tfor (int i=0; i<=N; i++) dis[i] = inf;\n\t\tdis[S] = 0;\n\t\tqb = qe = 0;\n\t\tq[qe++] = S;\n\t\twhile (qb<qe)\n\t\t{\n\t\t\tint x = q[qb];\n\t\t\tinq[x] = 0;\n\t\t\tqb = qnxt(qb);\n\t\t\tbalance();\n\t\t\tfor (int i = head[x]; i; i=nxt[i])\n\t\t\t{\n\t\t\t\tif (cap[i]&&dis[to[i]]>dis[x]+cost[i])\n\t\t\t\t{\n\t\t\t\t\tdis[to[i]] = dis[x]+cost[i];\n\t\t\t\t\tif (!inq[to[i]])\n\t\t\t\t\t{\n\t\t\t\t\t\tinq[to[i]] = 1;\n\t\t\t\t\t\tq[qe] = to[i];\n\t\t\t\t\t\tqe = qnxt(qe);\n\t\t\t\t\t\tbalance();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tfor (int i=1; i<=N; i++) cerr<<dis[i]<<\" \"; cerr<<endl;\n\t}\n\t\n\tbool vis[maxn];\n\tint dfs(int x, int T, int f)\n\t{\n\t\tif (x==T) return f;\n\t\tvis[x] = 1;\n\t\tint of = f;\n\t\tfor (int i=head[x]; i; i=nxt[i])\n\t\t{\n\t\t\tif (!vis[to[i]]&&cap[i]&&dis[to[i]]==dis[x]+cost[i])\n\t\t\t{\n\t\t\t\tint u = to[i];\n\t\t\t\tint d = dfs(u, T, min(f, cap[i]));\n\t\t\t\tcap[i] -= d;\n\t\t\t\tcap[i^1] += d;\n\t\t\t\tf -= d;\n\t\t\t\tif (!f) return of;\n\t\t\t}\n\t\t}\n\t\treturn of-f;\n\t}\n\tpair<int, ll> min_cost_flow(int S, int T, int K)\n\t{\n\t\tll ans = 0;\n\t\tint flow = 0;\n\t\twhile (flow<K)\n\t\t{\n\t\t\tspfa(S, T);\n\t\t\tif (dis[T]>=inf) break;\n\t\t\twhile (flow<K)\n\t\t\t{\n\t\t\t\tmemset(vis, 0, sizeof(vis));\n\t\t\t\tint f = dfs(S, T, K-flow);\n\t\t\t\tans += 1ll*f*dis[T];\n\t\t\t\tflow += f;\n\t\t\t\tif (f==0) break;\n\t\t\t}\n\t\t}\n\t\treturn MP(flow, ans);\n\t}\n};\nint n;\nint tid[256];\npair<int,int> a[88];\nll w[88];\nvector<pair<int,int> > M[4];\npair<int,int> segx[88], segy[88];\nll solve(int K)\n{\n//\tcerr<<\"solve: \"<<K<<endl;\n\tfor (int i=1; i<=K; i++) segx[i] = segy[i] = MP(0, 100);\n\tfor (auto x : M[0])\n\t{\n\t\tfor (int i=x.SS+1; i<=K; i++)\n\t\t{\n\t\t\tsegx[i].FF = max(segx[i].FF, x.FF+1);\n\t\t}\n\t}\n\tfor (auto x : M[1])\n\t{\n\t\tfor (int i=K-x.SS; i>=1; i--)\n\t\t{\n\t\t\tsegx[i].SS = min(segx[i].SS, x.FF-1);\n\t\t}\n\t}\n\tfor (auto x : M[2])\n\t{\n\t\tfor (int i=x.SS+1; i<=K; i++)\n\t\t{\n\t\t\tsegy[i].FF = max(segy[i].FF, x.FF+1);\n\t\t}\n\t}\n\tfor (auto x : M[3])\n\t{\n\t\tfor (int i=K-x.SS; i>=1; i--)\n\t\t{\n\t\t\tsegy[i].SS = min(segy[i].SS, x.FF-1);\n\t\t}\n\t}\n\tint S = 2*K+2*n+1, T = S+1;\n\tF::init();\n\tfor (int i=1; i<=K; i++)\n\t{\n\t\tF::add_edge(S, i, 1, 0);\n\t\tF::add_edge(i+K, T, 1, 0);\n\t\tfor (int j=1; j<=n; j++)\n\t\t{\n\t\t\tif (segx[i].FF<=a[j].FF&&a[j].FF<=segx[i].SS)\n\t\t\t{\n\t\t\t\tF::add_edge(i, j+2*K, 1, 0);\n\t\t\t}\n\t\t\tif (segy[i].FF<=a[j].SS&&a[j].SS<=segy[i].SS)\n\t\t\t{\n\t\t\t\tF::add_edge(j+2*K+n, i+K, 1, 0);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1; i<=n; i++) F::add_edge(i+2*K, i+2*K+n, 1, -w[i]);\n\tpair<int, ll> ans = F::min_cost_flow(S, T, K);\n//\tcerr<<\"F::ftot=\"<<F::ftot<<endl;\n\tif (ans.FF<K) return 0;\n//\tcerr<<\"ans=\"<<ans<<endl;\n\treturn -ans.SS;\n}\nint main()\n{\n\ttid['L'] = 0;\n\ttid['R'] = 1;\n\ttid['D'] = 2;\n\ttid['U'] = 3;\n\tgeti(n);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tll x, y, v;\n\t\tgetiii(x, y, v);\n\t\ta[i] = MP(x, y);\n\t\tw[i] = v;\n\t}\n\tint m;\n\tgeti(m);\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\tchar t;\n\t\tint a, b;\n\t\tt = getreal();\n\t\tgetii(a, b);\n\t\tM[tid[t]].PB(MP(a, b));\n\t}\n\tll ans = 0;\n\tfor (int K=1; K<=n; K++)\n\t{\n\t\tans = max(ans, solve(K));\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define REP(i,a,b) for(int i=(a),_end_=(b);i<=_end_;i++)\n#define DREP(i,a,b) for(int i=(a),_end_=(b);i>=_end_;i--)\n#define EREP(i,u) for(int i=start[u];i;i=e[i].next)\n#define fi first\n#define se second\n#define mkr(a,b) make_pair(a,b)\n#define SZ(A) ((int)A.size())\ntemplate<class T>inline void chkmin(T &a,T b){ if(a>b)a=b;}\ntemplate<class T>inline void chkmax(T &a,T b){ if(a<b)a=b;}\ninline int read()\n{\n\tint s=0,f=1;char ch=getchar();\n\twhile(!isdigit(ch) && ch!='-')ch=getchar();\n\tif(ch=='-')ch=getchar(),f=-1;\n\twhile(isdigit(ch))s=s*10+ch-'0',ch=getchar();\n\treturn ~f?s:-s;\n}\n\nconst int maxn=1020;\nconst int MAX=100;\nconst int inf=0x3f3f3f3f;\n\nstruct node {\n\tint v,next,w;ll cost;\n};\nnode e[10200];\nint cnt,start[1020];\ninline void addedge(int u,int v,int w,ll cost){ e[++cnt]=(node){v,start[u],w,cost}; start[u]=cnt;}\ninline void Addedge(int u,int v,int w,ll cost){ addedge(u,v,w,cost); addedge(v,u,0,-cost);}\n\nint tot,S,T;\n\nint n,m,x[maxn],y[maxn];\nll v[maxn];\n\nint L[maxn],R[maxn],D[maxn],U[maxn];\n\ninline void init()\n{\n\tn=read();\n\tREP(i,1,n)x[i]=read(),y[i]=read(),scanf(\"%lld\",&v[i]);\n\tREP(i,0,MAX+1)L[i]=R[i]=D[i]=U[i]=n;\n\tm=read();\n\tREP(i,1,m)\n\t{\n\t\tchar op; scanf(\"%c\",&op); int a=read(),b=read();\n\t\tif(op=='L')chkmin(L[a],b);\n\t\telse if(op=='R')chkmin(R[a],b);\n\t\telse if(op=='D')chkmin(D[a],b);\n\t\telse if(op=='U')chkmin(U[a],b);\n\t}\n\tREP(i,1,MAX)chkmin(R[i],R[i-1]),chkmin(U[i],U[i-1]);\n\tDREP(i,MAX,1)chkmin(L[i-1],L[i]),chkmin(D[i-1],D[i]);\n}\n\nll Ans;\nll ans;\nint FLOW,EXFLOW;\n\nint exflow[maxn];\n\ninline void Add(int u,int v,int l,int r,int cost)\n{\n\tAddedge(u,v,r-l,cost);\n\tans+=l*cost;\n\texflow[v]+=l; exflow[u]-=l;\n}\n\ninline void build()\n{\n\tREP(i,1,tot)\n\t\tif(exflow[i]>0)Addedge(S,i,exflow[i],0),EXFLOW+=exflow[i];\n\t\telse if(exflow[i]<0)Addedge(i,T,-exflow[i],0);\n}\n\ninline void min_cost(int S,int T)\n{\n\tstatic ll dist[maxn];\n\tstatic int vis[maxn],pre[maxn];\n\tqueue<int>q;\n\tFLOW=0;\n\twhile(1)\n\t{\n\t\tREP(i,1,tot)dist[i]=1ll<<60,vis[i]=pre[i]=0;\n\t\tq.push(S); dist[S]=0;\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tint u=q.front();q.pop();vis[u]=0;\n\t\t\tEREP(i,u)\n\t\t\t{\n\t\t\t\tint v=e[i].v;\n\t\t\t\tif(e[i].w && dist[v]>dist[u]+e[i].cost)\n\t\t\t\t{\n\t\t\t\t\tdist[v]=dist[u]+e[i].cost;\n\t\t\t\t\tpre[v]=i;\n\t\t\t\t\tif(!vis[v])vis[v]=1,q.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dist[T]==(1ll<<60))break;\n\t\tint flow=inf;\n\t\tfor(int i=pre[T];i;i=pre[e[i^1].v])chkmin(flow,e[i].w);\n\t\tfor(int i=pre[T];i;i=pre[e[i^1].v])e[i].w-=flow,e[i^1].w+=flow;\n\t\tans+=flow*dist[T]; FLOW+=flow;\n\t}\n}\n\ninline void work(int take)\n{\n\tstatic int numx[maxn],numy[maxn];\n\tmemset(exflow,0,sizeof(int)*(tot+1));\n\tmemset(start,0,sizeof(int)*(tot+1)); tot=0; cnt=1;\n\tS=++tot; T=++tot;\n\tREP(i,0,MAX)numx[i]=++tot,numy[i]=++tot;\n\tAddedge(S,numx[0],take,0);\n\tAddedge(numy[0],T,take,0);\n\tREP(i,1,MAX)\n\t{\n\t\tint low=max(0,take-L[i-1]),high=R[i];\n\t\tif(low>high)return;\n\t\tAdd(numx[i-1],numx[i],low,high,0);\n\t}\n\tREP(i,1,MAX)\n\t{\n\t\tint low=max(0,take-D[i-1]),high=U[i];\n\t\tif(low>high)return;\n\t\tAdd(numy[i],numy[i-1],low,high,0);\n\t}\n\tREP(i,1,n)Addedge(numx[x[i]],numy[y[i]],1,-v[i]);\n\tans=EXFLOW=0; \n\tbuild();\n\tmin_cost(S,T);\n\tif(EXFLOW+take==FLOW)chkmax(Ans,-ans);\n}\n\ninline void doing()\n{\n\tREP(i,0, min(min(L[MAX],D[MAX]),min(R[0],U[0])) )work(i);\n\tprintf(\"%lld\\n\",Ans);\n}\n\nint main()\n{\n\tinit();\n\tdoing();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAXNUM 333\ntypedef long long ll;\n#define rep(i,s,t) for(int i=s;i<t;i++)\nconst ll inf=1e18;\n#define pii pair<int,int>\ntypedef struct edge {\n    int ver;ll cost, flow;\n}edge;\nint nodenum, edgenum;\nedge e[111111];\nvector<int> v[MAXNUM];\nll dis[MAXNUM];int pre[MAXNUM];\nint preedge[MAXNUM];ll minflow[MAXNUM];\nbool isused[MAXNUM];\nint stnode, ednode;\nll cost, flow;\nbool spfa()\n{\n    for (int i = 1; i <= nodenum; i++)\n        dis[i] = inf, isused[i] = 0;\n    queue<int> q;\n    q.push(stnode);\n    isused[stnode] = 1, minflow[stnode] = inf;\n    dis[stnode] = 0;\n    while (!q.empty())\n    {\n        int now = q.front();\n        q.pop();\n        isused[now]=0;\n        for (int i : v[now])\n        {\n            if (!e[i].flow)\n                continue;\n            int k = e[i].ver;\n            if (dis[k] > dis[now] + e[i].cost)\n            {\n                dis[k] = dis[now] + e[i].cost;\n                pre[k] = now;\n                preedge[k] = i;\n                minflow[k] = min(minflow[now], e[i].flow);\n                if (!isused[k])\n                    q.push(k), isused[k] = 1;\n            }\n        }\n    }\n    if (dis[ednode] == inf)\n        return 0;\n    return 1;\n}\nvoid addedge(int a, int b, ll f, ll c)\n{\n    e[edgenum].ver = b,e[edgenum].cost = c,e[edgenum].flow = f;v[a].push_back(edgenum++);\n    e[edgenum].ver = a;e[edgenum].cost = -c;e[edgenum].flow = 0;v[b].push_back(edgenum++);\n}\nvoid mincostflow()\n{\n    cost = flow = 0;\n    while (spfa())\n    {\n        ll f = minflow[ednode];\n        for (int i = ednode; i != stnode; i = pre[i])\n        {\n            int k = preedge[i];\n            e[k].flow -= f;\n            e[k ^ 1].flow += f;\n        }\n        flow += f;\n        cost += dis[ednode] * f;\n    }\n}\nint toflow[MAXNUM];ll sumcost;\nvoid add(int a, int b, ll maxf, int minf,ll c)\n{\n    ll k = maxf - minf;\n    addedge(a, b, k, c);\n    toflow[a] -= minf;\n    toflow[b] += minf, sumcost += minf * c;\n}\nll max_limit_flow()\n{\n    v[nodenum + 1].clear(); v[nodenum + 2].clear();\n    add(ednode, stnode, inf, 0,0);ll sumnow=0;\n    int k=edgenum;\n    for (int i = 1; i <= nodenum; i++)\n    {\n        if (toflow[i] < 0)\n            addedge(i,nodenum+2, -toflow[i],0);\n        else addedge(nodenum + 1, i, toflow[i],0),sumnow+=toflow[i];\n    }\n    int start = stnode, end = ednode;\n    stnode = nodenum + 1, ednode = nodenum + 2;\n    nodenum += 2;\n    mincostflow();\n    if (sumnow != flow)\n        return 1111;\n    stnode = start, ednode = end,sumcost+=cost;\n    nodenum -= 2;\n    e[k].flow = e[k ^ 1].flow = 0;\n    nodenum -= 2;\n    for(int i:v[nodenum+1])\n        e[i].flow = e[i ^ 1].flow = 0;\n    for(int i:v[nodenum+2])\n        e[i].flow = e[i ^ 1].flow = 0;\n    mincostflow();\n    return cost + sumcost;\n}\nint n,m;\nint upx[111],downx[111],upy[111],downy[111];\npii item[111];ll w[111];\nll getres(int k)\n{\n    cost=sumcost=flow=0;nodenum=204+2;edgenum=2;\n    rep(i,1,nodenum+1)toflow[i]=0,v[i].clear();\n    stnode=nodenum,ednode=nodenum-1;\n    add(stnode,1,k,k,0),add(204,ednode,k,k,0);\n    rep(i,0,101)add(i+1,i+2,upx[i+1],max(0,k-downx[i]),0);\n    rep(i,0,101)add(i+102+1,i+102+2,downy[i],max(0,k-upy[i+1]),0);\n    rep(i,1,n+1)add(item[i].first+1,item[i].second+1+102,1,0,-w[i]);\n    return -max_limit_flow();\n}\nchar tmps[3];\nint main()\n{\n    scanf(\"%d\",&n);\n    rep(i,1,n+1)scanf(\"%d%d%lld\",&item[i].first,&item[i].second,&w[i]);\n    int m,a,b;scanf(\"%d\",&m);\n    rep(i,0,102)\n        upx[i]=downy[i]=n+2,downx[i]=upy[i]=n+2;\n    rep(i,1,m+1)\n    {\n        scanf(\"%s%d%d\",tmps,&a,&b);\n        if(tmps[0]=='L')downx[a]=min(downx[a],b);\n        else if(tmps[0]=='R')upx[a]=min(upx[a],b);\n        else if(tmps[0]=='U')upy[a]=min(upy[a],b);\n        else downy[a]=min(downy[a],b);\n    }\n    ll res=0;\n    rep(i,1,n+1)\n        res=max(res,getres(i));\n    printf(\"%lld\\n\",res);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\n#include<queue>\nusing namespace std;\nconst long long INF=1e18;\nstruct Graph{\n\tstruct Edge{\n\t\tint v;\n\t\tint c;\n\t\tlong long cost;\n\t\tint nxt;\n\t}e[100010];int tot;\n\tint first[1010];\n\tvoid build(int u,int v,int c,long long cost)\n\t{\n\t\te[++tot]=(Edge){v,c,cost,first[u]};\n\t\tfirst[u]=tot;\n\t\treturn ;\n\t}\n\tvoid adde(int u,int v,int c,long long cost)\n\t{\n\t\tbuild(u,v,c,cost);\n\t\tbuild(v,u,0,-cost);\n\t\treturn ;\n\t}\n\tvoid reset()\n\t{\n\t\tmemset(first,0,sizeof(first));\n\t\ttot=1;\n\t\treturn ;\n\t}\n\tlong long dis[1010];\n\tint pren[1010],pree[1010];\n\tbool book[1010];\n\tint S,T;\n\tbool spfa()\n\t{\n\t\tqueue<int>q;\n\t\tfor(int i=S;i<=T;i++)\n\t\t\tdis[i]=-INF;\n\t\tbook[S]=true;\n\t\tdis[S]=0;\n\t\tq.push(S);\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tint u=q.front();\n\t\t\tq.pop();book[u]=false;\n\t\t\tfor(int i=first[u];i;i=e[i].nxt)\n\t\t\t\tif(e[i].c&&dis[u]+e[i].cost>dis[e[i].v])\n\t\t\t\t{\n\t\t\t\t\tdis[e[i].v]=dis[u]+e[i].cost;\n\t\t\t\t\tpren[e[i].v]=u;\n\t\t\t\t\tpree[e[i].v]=i;\n\t\t\t\t\tif(!book[e[i].v])\n\t\t\t\t\t{\n\t\t\t\t\t\tbook[e[i].v]=true;\n\t\t\t\t\t\tq.push(e[i].v);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\treturn dis[T]>-INF;\n\t}\n\tlong long solve()\n\t{\n\t\tlong long ans=0;\n\t\twhile(spfa())\n\t\t{\n\t\t\tans+=dis[T];\n\t\t\tfor(int i=T;i!=S;i=pren[i])\n\t\t\t{\n\t\t\t\tint ee=pree[i];\n\t\t\t\te[ee].c--;\n\t\t\t\te[ee^1].c++;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n}G;\nint n,m;\nint l[110],r[110],d[110],u[110];\nint L[81],R[81],D[81],U[81];\nint x[81],y[81];\nlong long v[81];\nlong long solve(int k)\n{\n\tG.reset();\n\tfor(int i=1;i<=k;i++)\n\t\tL[i]=D[i]=1,R[i]=U[i]=100;\n\tfor(int i=1;i<=100;i++)\n\t{\n\t\t//l\n\t\tif(l[i]+1<=k)L[l[i]+1]=max(L[l[i]+1],i+1);\n\t\t//d\n\t\tif(d[i]+1<=k)D[d[i]+1]=max(D[d[i]+1],i+1);\n\t\t//r\n\t\tif(k-r[i]>0)R[k-r[i]]=min(R[k-r[i]],i-1);\n\t\t//u\n\t\tif(k-u[i]>0)U[k-u[i]]=min(U[k-u[i]],i-1);\n\t}\n\tfor(int i=2;i<=k;i++)\n\t\tL[i]=max(L[i],L[i-1]),\n\t\tD[i]=max(D[i],D[i-1]);\n\tfor(int i=k-1;i>=1;i--)\n\t\tR[i]=min(R[i],R[i+1]),\n\t\tU[i]=min(U[i],U[i+1]);\n\tG.S=0;G.T=k+n+n+k+1;\n\tfor(int i=1;i<=k;i++)\n\t{\n\t\tG.adde(G.S,i,1,0);\n\t\tG.adde(k+n+n+i,G.T,1,0);\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tG.adde(k+i,k+n+i,1,v[i]);\n\t\tfor(int j=1;j<=k;j++)\n\t\t{\n\t\t\tif(L[j]<=x[i]&&x[i]<=R[j])\n\t\t\t\tG.adde(j,k+i,1,0);\n\t\t\tif(D[j]<=y[i]&&y[i]<=U[j])\n\t\t\t\tG.adde(k+n+i,k+n+n+j,1,0);\n\t\t}\n\t}\n\treturn G.solve();\n}\nchar s[5];\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d %d %lld\",&x[i],&y[i],&v[i]);\n\tfor(int i=1;i<=100;i++)\n\t\tl[i]=r[i]=u[i]=d[i]=n;\n\tscanf(\"%d\",&m);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%s\",s);\n\t\tint a,b;scanf(\"%d %d\",&a,&b);\n\t\tif(s[0]=='L')l[a]=min(l[a],b);\n\t\tif(s[0]=='R')r[a]=min(r[a],b);\n\t\tif(s[0]=='D')d[a]=min(d[a],b);\n\t\tif(s[0]=='U')u[a]=min(u[a],b);\n\t}\n\tlong long ans=0;\n\tfor(int i=1;i<=n;i++)\n\t\tans=max(ans,solve(i));\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=505,M=2e5+5,inf=1<<30;\nint head[N],nxt[M],to[M],wei[M],tot=1,s,t,n,m,x[N],y[N],a[N],b[N],lx[N],rx[N],ly[N],ry[N];\nll cost[M],dis[N],v[N],res,ans; char op[N][2]; bool vis[N];\nvoid adde(int u, int v, ll c=0, int w=1)\n{\n\tnxt[++tot]=head[u],head[u]=tot,to[tot]=v,wei[tot]=w,cost[tot]=-c;\n\tnxt[++tot]=head[v],head[v]=tot,to[tot]=u,wei[tot]=0,cost[tot]=c;\n}\nbool spfa()\n{\n\tmemset(vis,0,sizeof(bool)*(t+3));\n\tmemset(dis,0x3f,sizeof(ll)*(t+3));\n\tqueue<int> q;\n\tdis[t]=0,q.push(t);\n\twhile(!q.empty())\n\t{\n\t\tint u=q.front();\n\t\tvis[u]=false,q.pop();\n\t\tfor(int e=head[u];e;e=nxt[e])\n\t\t\tif(wei[e^1]&&dis[to[e]]>dis[u]-cost[e])\n\t\t\t{\n\t\t\t\tdis[to[e]]=dis[u]-cost[e];\n\t\t\t\tif(!vis[to[e]]) vis[to[e]]=true,q.push(to[e]);\n\t\t\t}\n\t}\n\treturn dis[s]!=dis[0];\n}\nint dfs(int u, int mx)\n{\n\tvis[u]=true;\n\tif(u==t) return mx;\n\tint l=mx;\n\tfor(int e=head[u];e&&l;e=nxt[e])\n\t\tif(!vis[to[e]]&&wei[e]>0&&dis[to[e]]==dis[u]-cost[e])\n\t\t{\n\t\t\tint f=dfs(to[e],min(l,wei[e]));\n\t\t\tres+=1ll*f*cost[e];\n\t\t\tl-=f,wei[e]-=f,wei[e^1]+=f;\n\t\t}\n\treturn mx-l;\n}\nll exec()\n{\n\tres=0;\n\twhile(spfa())\n\t\tdo\n\t\t{\n\t\t\tmemset(vis,0,sizeof(bool)*(t+3));\n\t\t\tdfs(s,inf);\n\t\t} while(vis[t]);\n\treturn -res;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i) scanf(\"%d%d%lld\",&x[i],&y[i],&v[i]);\n\tscanf(\"%d\",&m);\n\tfor(int i=1;i<=m;++i) scanf(\"%s%d%d\",op[i],&a[i],&b[i]);\n\tfor(int k=1;k<=n;++k)\n\t{\n\t\tmemset(head,0,sizeof(head)),tot=1;\n\t\ts=(n+k)*2+1,t=s+1;\n\t\tfor(int i=1;i<=k;++i) adde(s,i),adde(i+k+2*n,t),lx[i]=ly[i]=0,rx[i]=ry[i]=inf;\n\t\tfor(int i=1;i<=n;++i) adde(i+k,i+n+k,v[i]);\n\t\tfor(int i=1;i<=m;++i)\n\t\t{\n\t\t\tif(op[i][0]=='L')\n\t\t\t\tfor(int j=b[i]+1;j<=k;++j) lx[j]=max(lx[j],a[i]+1);\n\t\t\tif(op[i][0]=='R')\n\t\t\t\tfor(int j=1;j<=k-b[i];++j) rx[j]=min(rx[j],a[i]-1);\n\t\t\tif(op[i][0]=='D')\n\t\t\t\tfor(int j=b[i]+1;j<=k;++j) ly[j]=max(ly[j],a[i]+1);\n\t\t\tif(op[i][0]=='U')\n\t\t\t\tfor(int j=1;j<=k-b[i];++j) ry[j]=min(ry[j],a[i]-1);\n\t\t}\n\t\tfor(int i=1;i<=k;++i)\n\t\t\tfor(int j=1;j<=n;++j)\n\t\t\t{\n\t\t\t\tif(lx[i]<=x[j]&&x[j]<=rx[i]) adde(i,j+k);\n\t\t\t\tif(ly[i]<=y[j]&&y[j]<=ry[i]) adde(j+k+n,i+k+2*n);\n\t\t\t}\n\t\tans=max(ans,exec());\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst LL INF = 0x3f3f3f3f3f3f3f;\n\nnamespace flow\n{\n\tconst int MAXN = 400;\n\tstruct edge\n\t{\n\t\tint to, cap;\n\t\tLL cost;\n\t};\n\tint n, m;\n\tedge ed[30005];\n\tvector<int> G[405];\n\t\n\tvoid clear()\n\t{\n\t\tm = 0;\n\t\trep(i, n) G[i].clear();\n\t}\n\t\n\tvoid add_edge(int u, int v, int fl, LL co)\n\t{\n\t\ted[m].to = v; ed[m].cap = fl; ed[m].cost = co; G[u].push_back(m); m ++;\n\t\ted[m].to = u; ed[m].cap = 0; ed[m].cost = -co; G[v].push_back(m); m ++;\n\t}\n\t\n\tLL h[405];\n\tLL pat[405];\n\tint prev[405];\n\tbool vis[405];\n\t\n\tbool dijk(int s, int t)\n\t{\n\t\trep(i, n) {\n\t\t\tpat[i] = INF;\n\t\t\tvis[i] = false;\n\t\t}\n\t\tpat[s] = 0;\n\t\tpriority_queue<pair<LL, int> > que;\n\t\tque.push(MP(0, s));\n\t\t\n\t\twhile(!que.empty()) {\n\t\t\tint cur = que.top().second;\n\t\t\tque.pop();\n\t\t\tif(vis[cur]) continue;\n\t\t\tvis[cur] = true;\n\t\t\trep(i, G[cur].size()) {\n\t\t\t\tint ce = G[cur][i];\n\t\t\t\tif(ed[ce].cap == 0) continue;\n\t\t\t\tif(pat[ed[ce].to] > pat[cur] + ed[ce].cost) {\n\t\t\t\t\tpat[ed[ce].to] = pat[cur] + ed[ce].cost;\n\t\t\t\t\tprev[ed[ce].to] = ce;\n\t\t\t\t\tque.push(MP(-pat[ed[ce].to], ed[ce].to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn pat[t] != INF;\n\t}\n\t\n\tLL mcf(int s, int t, int mf)\n\t{\n\t\trep(i, n) h[i] = 0;\n\t\tLL ans = 0;\n\t\twhile(dijk(s, t)) {\n\t\t\t//in this occasion flow must be 1\n\t\t\tint cur = t, cf = 1;\n\t\t\twhile(cur != s) {\n\t\t\t\ted[prev[cur]].cap -= cf;\n\t\t\t\ted[prev[cur] ^ 1].cap += cf;\n\t\t\t\tcur = ed[prev[cur] ^ 1].to;\n\t\t\t}\n\t\t\trep(i, m) ed[i].cost += pat[ed[i ^ 1].to] - pat[ed[i].to];\n\t\t\trep(i, n) h[i] += pat[i];\n\t\t\tans += h[t] * cf;\n\t\t\tmf --;\n\t\t\tif(mf == 0) return ans;\n\t\t}\n\t\treturn -1;\n\t}\n}\n\nint n, x[85], y[85];\nLL v[85];\nint m, a[325], b[325];\nchar t[325];\nLL ans;\n\nint minx[85], maxx[85], miny[85], maxy[85];\nLL solve(int tot)\n{\n\trep(i, n) {\n\t\tminx[i] = miny[i] = -INF;\n\t\tmaxx[i] = maxy[i] = INF;\n\t}\n\t\n\trep(i, m) if(b[i] < tot) {\n\t\tif(t[i] == 'L') minx[b[i]] = max(minx[b[i]], a[i] + 1);\n\t\telse if(t[i] == 'R') maxx[tot - b[i] - 1] = min(maxx[tot - b[i] - 1], a[i] - 1);\n\t\telse if(t[i] == 'D') miny[b[i]] = max(miny[b[i]], a[i] + 1);\n\t\telse if(t[i] == 'U') maxy[tot - b[i] - 1] = min(maxy[tot - b[i] - 1], a[i] - 1);\n\t}\n\trep(i, tot - 1) {\n\t\tminx[i + 1] = max(minx[i], minx[i + 1]);\n\t\tminy[i + 1] = max(miny[i], miny[i + 1]);\n\t}\n\tfor(int i = tot - 1; i > 0; i --) {\n\t\tmaxx[i - 1] = min(maxx[i - 1], maxx[i]);\n\t\tmaxy[i - 1] = min(maxy[i - 1], maxy[i]);\n\t}\n\t\n\tflow::n = 2 + tot * 2 + n * 2;\n\tflow::clear();\n\trep(i, tot) flow::add_edge(tot * 2 + n * 2, i, 1, 0);\n\trep(i, tot) rep(j, n) if(x[j] >= minx[i] && x[j] <= maxx[i])\n\tflow::add_edge(i, j + tot * 2, 1, 0);\n\trep(i, n) flow::add_edge(i + tot * 2, i + tot * 2 + n, 1, INF - v[i]);\n\trep(i, tot) rep(j, n) if(y[j] >= miny[i] && y[j] <= maxy[i])\n\tflow::add_edge(j + tot * 2 + n, i + tot, 1, 0);\n\trep(i, tot) flow::add_edge(i + tot, tot * 2 + n * 2 + 1, 1, 0);\n\t\n\tLL ret = flow::mcf(flow::n - 2, flow::n - 1, tot);\n\t\n\treturn ret == -1 ? -1 : INF * tot - ret;\n}\n\nint main()\n{\n\tcin >> n;\n\trep(i, n) cin >> x[i] >> y[i] >> v[i];\n\tcin >> m;\n\trep(i, m) cin >> t[i] >> a[i] >> b[i];\n\tfor(int t = 0; t <= n; t ++)\n\tans = max(ans, solve(t));\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<iomanip>\n#include<ctime>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#define sqr(x) ((x)*(x))\n#define fz1(i,n) for ((i)=1;(i)<=(n);(i)++)\n#define fd1(i,n) for ((i)=(n);(i)>=1;(i)--)\n#define fz0g(i,n) for ((i)=0;(i)<=(n);(i)++)\n#define fd0g(i,n) for ((i)=(n);(i)>=0;(i)--)\n#define fz0k(i,n) for ((i)=0;(i)<(n);(i)++)\n#define fd0k(i,n) for ((i)=(int)((n)-1);(i)>=0;(i)--)\n#define fz(i,x,y) for ((i)=(x);(i)<=(y);(i)++)\n#define fd(i,y,x) for ((i)=(y);(i)>=(x);(i)--)\n#define fzin fz1(i,n)\n#define fzim fz1(i,m)\n#define fzjn fz1(j,n)\n#define fzjm fz1(j,m)\n#define ff(c,itr) for (__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n#define rdst(st,len){static char ss[len];scanf(\" %s\",ss);(st)=ss;}\n//#define T_ int\nusing namespace std;\n//struct bit{T_ arr[1000005];int lowbit(int x){return x&(-x);}void add(int x,T_ y){for (int i=x;i<=n;i+=lowbit(i)) arr[i]+=y;}T_ query(int x){T_ s=0;for (int i=x;i>0;i-=lowbit(i)) s+=arr[i];return s;}};\n//struct seg{struct treedot{int l,r;T_ sum,add;void update(T_ x){sum+=(r-l+1)*x; add+=x;}}c[800005];void pushdown(int id){if (c[id].add){c[id*2].update(c[id].add);c[id*2+1].update(c[id].add);c[id].add=0;}}void pushup(int id){c[id].sum=c[id*2].sum+c[id*2+1].sum;}void build(int id,int l,int r){if (l>r) return;c[id].l=l;c[id].r=r;c[id].sum=0;c[id].add=0;if (l==r) c[id].sum=0;else{int mid=l+(r-l)/2;build(id*2,l,mid);build(id*2+1,mid+1,r);pushup(id);}}void update(int id,int le,int ri,T_ x){if (le>c[id].r||ri<c[id].l) return;if (le<=c[id].l&&c[id].r<=ri) c[id].update(x);else{pushdown(id);update(id*2,le,ri,x);update(id*2+1,le,ri,x);pushup(id);}}T_ query(int id,int le,int ri){if (ri<c[id].l||c[id].r<le) return 0;if (le<=c[id].l&&c[id].r<=ri) return c[id].sum;T_ ans=0;pushdown(id);ans+=query(id*2,le,ri);ans+=query(id*2+1,le,ri);pushup(id);return ans;}};\n//struct bit_2d{T_ a[2005][2005];int lowbit(int x){return x&(-x);}void add(int x,int y,T_ z){int i,j;for (i=x;i<=2000;i+=lowbit(i)){for (j=y;j<=2000;j+=lowbit(j)){a[i][j]+=z;}}}T_ query(int x,int y){int i,j;T_ s=0;for (i=x;i;i-=lowbit(i)){for (j=y;j;j-=lowbit(j)){s+=a[i][j];}}return s;}T_ query(int x,int y,int xx,int yy){return query(xx,yy)-query(x-1,yy)-query(xx,y-1)+query(x-1,y-1);}};\nint n,m,i,j,k,cnt,a[325],b[325],s=0,t=321,l[325],r[325],u[325],d[325],x,y,inq[325],vis[325];\nvector<int> allx,ally;\nlong long v[325],cst,ans,dis[325];\nchar c[325],ca[325],cb[325];\nstruct ii\n{\n\tint y,z;\n\tlong long d;\n}e[1000005];\nvector<int> bi[325];\nvoid init()\n{\n\tint i;fz0g(i,321) bi[i].clear();cnt=0;\n}\nvoid add(int x,int y,int z,long long d)\n{\n\tcnt++;bi[x].push_back(cnt*2-2);bi[y].push_back(cnt*2-1);\n\te[cnt*2-2]=(ii){y,z,d};e[cnt*2-1]=(ii){x,0,-d};\n}\nbool bfs(int s,int t)\n{\n\tmemset(dis,-0x18,sizeof(dis));dis[s]=0;queue<int> qx;qx.push(s);inq[s]=1;\n\twhile (!qx.empty()){\n\t\tint x=qx.front();qx.pop();inq[x]=0;ff(bi[x],it) if (e[*it].z){\n\t\t\tint y=e[*it].y;long long z=dis[x]+e[*it].d;\n\t\t\tif (dis[y]<z){\n\t\t\t\tdis[y]=z;\n\t\t\t\tif (!inq[y]){\n\t\t\t\t\tinq[y]=1;qx.push(y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}return dis[t]>dis[324];\n}\nint dfs(int x,int tt,int flw)\n{\n\tif (!flw) return 0;\n\tif (x==tt) {vis[x]=1;return flw;}\n\tif (vis[x]) return 0;\n\tvis[x]=1;int ans=0;ff(bi[x],it){\n//\t\tcerr<<e[*it].y<<' '<<e[*it].z<<endl;\n\t\tif (e[*it].z&&dis[e[*it].y]==dis[x]+e[*it].d){\n\t\t\tint t=dfs(e[*it].y,tt,min(flw,e[*it].z));cst+=t*e[*it].d;ans+=t;flw-=t;e[*it].z-=t;e[(*it)^1].z+=t;if (!flw) break;\n\t\t}\n\t}return ans;\n}\nbool dinic(int s,int t,int aa)\n{\n\tint ans=0;while (bfs(s,t)){\n\t\tdo{\n\t\t\tmemset(vis,0,sizeof(vis));\n\t\t\tans+=dfs(s,t,aa);\n\t\t}while (vis[t]);\n\t}if (ans==aa) return 1;return 0;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfz1(i,n){\n\t\tscanf(\"%d%d%lld\",&a[i],&b[i],&v[i]);\n//\t\tallx.push_back(a[i]);ally.push_back(b[i]);\n\t}//sort(allx.begin(),allx.end());allx.resize(unique(allx.begin(),allx.end())-allx.begin());sort(ally.begin(),ally.end());ally.resize(unique(ally.begin(),ally.end())-ally.begin());\n\t/*fz1(i,n){\n\t\ta[i]=upper_bound(allx.begin(),allx.end(),a[i])-allx.begin();\n\t\tb[i]=upper_bound(ally.begin(),ally.end(),b[i])-ally.begin();\n\t}*/\n\tscanf(\"%d\",&m);fz1(i,m){\n\t\tscanf(\" %c%d%d\",&c[i],&ca[i],&cb[i]);\n\t}\n\tans=0;\n\tfz1(i,n){\n\t\tcst=0;init();\n\t\tfz1(j,i){\n\t\t\tl[i]=d[i]=0;\n\t\t\tr[i]=u[i]=0x18181818;\n\t\t}\n\t\tfz1(j,m) if (cb[j]<i){\n\t\t\tif (c[j]=='L') l[cb[j]+1]=max(l[cb[j]+1],ca[j]+1);\n\t\t\tif (c[j]=='R') r[i-cb[j]]=min(r[i-cb[j]],ca[j]-1);\n\t\t\tif (c[j]=='D') d[cb[j]+1]=max(d[cb[j]+1],ca[j]+1);\n\t\t\tif (c[j]=='U') u[i-cb[j]]=min(u[i-cb[j]],ca[j]-1);\n\t\t}\n\t\tfz(j,2,i){\n\t\t\tl[j]=max(l[j],l[j-1]);\n\t\t\td[j]=max(d[j],d[j-1]);\n\t\t}\n\t\tfd(j,i-1,1){\n\t\t\tr[j]=min(r[j],r[j+1]);\n\t\t\tu[j]=min(u[j],u[j+1]);\n\t\t}\n\t\tfz1(j,i)fz1(k,n){\n\t\t\tif (l[j]<=a[k]&&a[k]<=r[j]){\n\t\t\t\tadd(j,n+k,1,0);\n\t\t\t}\n\t\t\tif (d[j]<=b[k]&&b[k]<=u[j]){\n\t\t\t\tadd(n+n+k,n+n+n+j,1,0);\n\t\t\t}\n\t\t}\n\t\tfz1(j,i){\n\t\t\tadd(s,j,1,0);add(n+n+n+j,t,1,0);\n\t\t}fz1(j,n){\n\t\t\tadd(j+n,j+n+n,1,v[j]);\n\t\t}if (dinic(s,t,i)) ans=max(ans,cst);\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace __gnu_pbds;\nusing namespace std;\n \ntemplate <typename T>\nusing ordered_set =\n\ttree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n \n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n\t*this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n \n#define shandom_ruffle random_shuffle\n \nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=327;\nusing bn=bitset<87>;\nusing ld=long double;\n\nint n;\npii gdz[nax];\nll war[nax];\n\nint m;\nbn podz[nax];\nint ile[nax];\n\nll wyn;\n\nbn ter;\n \nll dajwar()\n{\n\tll ret=0;\n\tfor (int i=1; i<=n; i++)\n\t\tif (ter[i])\n\t\t\tret+=war[i];\n\treturn ret;\n}\n \nint popr()\n{\n\tfor (int i=1; i<=m; i++)\n\t\tif ((podz[i]&ter).count()>ile[i])\n\t\t\treturn 0;\n\treturn 1;\n}\n\nvi kol;\n\nstruct Simplex {        // Maximize c*x subject to Ax <= b.\n  using T = ld;     // Initialize the structure, set A, b, c and then run\n  vector<vector<T>> A;  // solve(). Max objective is stored in res. To recover\n  vector<T> b, c;       // the best result, use getVars().\n  int V, E;\n  vector<int> eqIds, varIds, cols;\n  T res;\n  static constexpr T kEps = 1e-10;\n\n  Simplex(int vars, int eqs) : A(eqs, vector<T>(vars)), b(eqs), c(vars),\n      V(vars), E(eqs), eqIds(eqs), varIds(vars), res(0) {\n    iota(varIds.begin(), varIds.end(), 0);\n    iota(eqIds.begin(), eqIds.end(), vars);\n  }\n\n  void pivot(int eq, int var) {\n    T coef = 1 / A[eq][var];\n    cols.clear();\n    for (int i = 0; i < V; i++) {\n      if (abs(A[eq][i]) > kEps) { cols.push_back(i); A[eq][i] *= coef; }\n    }\n    A[eq][var] *= coef; b[eq] *= coef;\n    for (int row = 0; row < E; row++) {\n      if (row == eq || abs(A[row][var]) < kEps) { continue; }\n      T k = -A[row][var];\n      A[row][var] = 0;\n      for (int i : cols) { A[row][i] += k * A[eq][i]; }\n      b[row] += k * b[eq];\n    }\n    T q = c[var]; c[var] = 0;\n    for (int i : cols) { c[i] -= q * A[eq][i]; }\n    res += q * b[eq];\n    swap(varIds[var], eqIds[eq]);\n  }\n\n  bool solve() {\n    while (true) {\n      int eq = -1, var = -1;\n      for (int i = 0; i < E; i++) { if (b[i] < -kEps) { eq = i; break; } }\n      if (eq == -1) { break; }\n      for (int i = 0; i < V; i++) { if (A[eq][i] < -kEps) { var = i; break; } }\n      if (var == -1) { res = -1e9; return false; /* No solution */ }\n      pivot(eq, var);\n    }\n    while (true) {\n      int var = -1, eq = -1;\n      for (int i = 0; i < V; i++) { if (c[i] > kEps) { var = i; break; } }\n      if (var == -1) { break; }\n      for (int i = 0; i < E; i++) {\n        if (A[i][var] < kEps) { continue; }\n        if (eq >= 0 && b[i] / A[i][var] >= b[eq] / A[eq][var]) { continue; }\n        eq = i;\n      }\n      if (eq == -1) { res = 1e9; return false; /* Unbounded */ }\n      pivot(eq, var);\n    }\n    return true;\n  }\n\n  vector<T> getVars() { // Optimal assignment of variables.\n    vector<T> result(V);\n    for (int i = 0; i < E; i++) if (eqIds[i] < V) result[eqIds[i]] = b[i];\n    return result;\n  }\n};\n\nvoid zmien(ld v)\n{\n\tv*=(9+(rand()%3))/10.0;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(\"%d%d%lld\", &gdz[i].first, &gdz[i].second, &war[i]);\n\tscanf(\"%d\", &m);\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\tchar c;\n\t\tint a, b;\n\t\tscanf(\" %c%d%d\", &c, &a, &b);\n\t\tfor (int j=1; j<=n; j++)\n\t\t{\n\t\t\tif (c=='L' && gdz[j].first<=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='R' && gdz[j].first>=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='D' && gdz[j].second<=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='U' && gdz[j].second>=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t}\n\t\tile[i]=b;\n\t}\n\tfor (int h=0; h<1000; h++)\n\t{\n\t\tSimplex janusz(n, m+2*n);\n\t\tfor (int i=0; i<n; i++)\n\t\t{\n\t\t\tjanusz.c[i]=war[i+1];\n\t\t\tif (h)\n\t\t\t\tzmien(janusz.c[i]);\n\t\t}\n\t\tfor (int i=0; i<m; i++)\n\t\t{\n\t\t\tjanusz.b[i]=ile[i+1];\n\t\t\tfor (int j=0; j<n; j++)\n\t\t\t\tjanusz.A[i][j]=podz[i+1][j+1];\n\t\t}\n\t\tfor (int i=0; i<n; i++)\n\t\t{\n\t\t\tjanusz.b[m+i]=1;\n\t\t\tjanusz.A[m+i][i]=1;\n\t\t}\n\t\tfor (int i=0; i<n; i++)\n\t\t{\n\t\t\tjanusz.b[m+n+i]=0;\n\t\t\tjanusz.A[m+n+i][i]=-1;\n\t\t}\n\t\tassert(janusz.solve());\n\t\tauto wez=janusz.getVars();\n\t\t\n\t\tvector <pair<ld,int> > wek;\n\t\tfor (int i=1; i<=n; i++)\n\t\t\twek.push_back({wez[i-1], i});\n\t\t\n\t\tsort(wek.begin(), wek.end());\n\t\treverse(wek.begin(), wek.end());\n\t\t\n\t\tter.reset();\n\t\t\n\t\tfor (auto i : wek)\n\t\t{\n\t\t\tter[i.second]=1;\n\t\t\tif (!popr())\n\t\t\t\tter[i.second]=0;\n\t\t}\n\t\twyn=max(wyn, dajwar());\n\t}\n\t\n\tprintf(\"%lld\\n\", wyn);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define INF 1e15\nusing namespace std;\nstruct Po{int x,y;ll z;}v[85];\nstruct Qu{char ch;int x,y;}c[410];\nstruct Info{int nu,ne,qu;ll co;}a[500010];\nint m,n,s,t,l[85],r[85],b[1010],num,li[500010],la[5010],zh[5010];\nbool vi[5010];\nll nu,ansn,di[5010];\nvoid jb(int x,int y,ll z){\n\ta[++num].nu=y;a[num].ne=b[x];b[x]=num;a[num].co=z;a[num].qu=1;\n\ta[++num].nu=x;a[num].ne=b[y];b[y]=num;a[num].co=-z;a[num].qu=0;\n}\nll que(){\n\tfor (int i=1;i<=t;i++) vi[i]=1,di[i]=INF,la[i]=0,zh[i]=0;\n\tdi[s]=0;vi[s]=0;\n\tint l=1,r=1;li[l]=s;\n\twhile (l<=r){\n\t\tfor (int y=b[li[l]];y;y=a[y].ne){\n\t\t\tif (a[y].qu!=0&&di[a[y].nu]>di[li[l]]+a[y].co){\n\t\t\t\tdi[a[y].nu]=di[li[l]]+a[y].co;\n\t\t\t\tla[a[y].nu]=li[l];zh[a[y].nu]=y;\n\t\t\t\tif (vi[a[y].nu]){li[++r]=a[y].nu;vi[a[y].nu]=0;}\n\t\t\t}\n\t\t}\n\t\tvi[li[l]]=1;\n\t\tl++;\n\t}\n//\tfor (int i=1;i<=t;i++) cout<<i<<' '<<di[i]<<' '<<vi[i]<<' '<<la[i]<<' '<<zh[i]<<endl;\n\tif (di[t]==INF)return -INF;\n\tfor (int i=t;i!=s;i=la[i]){a[zh[i]].qu=0;a[zh[i]^1].qu=1;}\n\treturn INF-di[t];\n}\nint main(){\n\tcin>>n;\n\tfor (int i=1;i<=n;i++)cin>>v[i].x>>v[i].y>>v[i].z;\n\tcin>>m;\n\tfor (int i=1;i<=m;i++) cin>>c[i].ch>>c[i].x>>c[i].y;\n\tfor (int k=1;k<=n;k++){\n\t\tmemset(b,0,sizeof(b));num=1;nu=0;\n\t\ts=n+n+k+k+1;t=n+n+k+k+2;\n\t\tfor (int i=1;i<=k;i++) jb(s,i,0),jb(i+k,t,0);\n\t\tfor (int i=1;i<=k;i++) l[i]=1,r[i]=100;\n\t\tfor (int i=1;i<=m;i++){\n\t\t\tif (c[i].ch=='L'&&c[i].y<k)l[c[i].y+1]=max(l[c[i].y+1],c[i].x+1);\n\t\t\tif (c[i].ch=='R'&&c[i].y<k)r[k-c[i].y]=min(r[k-c[i].y],c[i].x-1);\n\t\t}\n\t\tfor (int i=2;i<=k;i++)l[i]=max(l[i],l[i-1]);\n\t\tfor (int i=k-1;i>=1;i--)r[i]=min(r[i],r[i+1]);\n\t\tfor (int i=1;i<=k;i++)\n\t\t\tfor (int j=1;j<=n;j++)\n\t\t\t\tif (v[j].x>=l[i]&&v[j].x<=r[i])jb(i,j+k+k,0);\n\t\tfor (int i=1;i<=k;i++) l[i]=1,r[i]=100;\n\t\tfor (int i=1;i<=m;i++){\n\t\t\tif (c[i].ch=='D'&&c[i].y<k)l[c[i].y+1]=max(l[c[i].y+1],c[i].x+1);\n\t\t\tif (c[i].ch=='U'&&c[i].y<k)r[k-c[i].y]=min(r[k-c[i].y],c[i].x-1);\n\t\t}\n\t\tfor (int i=2;i<=k;i++)l[i]=max(l[i],l[i-1]);\n\t\tfor (int i=k-1;i>=1;i--)r[i]=min(r[i],r[i+1]);\n\t\tfor (int i=1;i<=k;i++)\n\t\t\tfor (int j=1;j<=n;j++)\n\t\t\t\tif (v[j].y>=l[i]&&v[j].y<=r[i])jb(j+k+k+n,i+k,0);\n\t\tfor (int i=1;i<=n;i++)jb(i+k+k,i+k+k+n,INF-v[i].z);\n\t\tfor (int i=1;i<=k;i++)nu+=que();\n\t\tansn=max(ansn,nu);\n\t}\n\tcout<<ansn<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<cmath>\nusing namespace std;\n\nconst int N = 410, M = 3010;\n\nint AA[M][N], BB[M];\n\nstruct Simplex {\n\tusing T = long double;\n\tconst T eps = 1e-7;\n\tint n, m;\n\tint Left[M], Down[N];\n\t// time complexity: exponential. fast $O(MN^2)$ in experiment. dependent on the modeling.\n\t// Ax <= b, max c^T x. 최댓값: v, 답 추적: sol[i]. 1 based\n\tT a[M][N], b[M], c[N], v, sol[N];\n\tbool eq(T a, T b) { return fabs(a - b) < eps; }\n\tbool ls(T a, T b) { return a < b && !eq(a, b); }\n\tvoid init(int p, int q) {\n\t\tn = p; m = q; v = 0;\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) a[i][j] = 0;\n\t\t}\n\t\tfor (int i = 1; i <= m; i++) b[i] = 0;\n\t\tfor (int i = 1; i <= n; i++) c[i] = sol[i] = 0;\n\t}\n\tvoid pivot(int x, int y) {\n\t\tswap(Left[x], Down[y]);\n\t\tT k = a[x][y]; a[x][y] = 1;\n\t\tvector<int> nz;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\ta[x][i] /= k;\n\t\t\tif (!eq(a[x][i], 0)) nz.push_back(i);\n\t\t}\n\t\tb[x] /= k;\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tif (i == x || eq(a[i][y], 0)) continue;\n\t\t\tk = a[i][y]; a[i][y] = 0;\n\t\t\tb[i] -= k * b[x];\n\t\t\tfor (int j : nz) a[i][j] -= k * a[x][j];\n\t\t}\n\t\tif (eq(c[y], 0)) return;\n\t\tk = c[y]; c[y] = 0;\n\t\tv += k * b[x];\n\t\tfor (int i : nz) c[i] -= k * a[x][i];\n\t}\n\t// 0: found solution, 1: no feasible solution, 2: unbounded\n\tint solve() {\n\t\tfor (int i = 1; i <= n; i++) Down[i] = i;\n\t\tfor (int i = 1; i <= m; i++) Left[i] = n + i;\n\t\twhile (1) { // Eliminating negative b[i]\n\t\t\tint x = 0, y = 0;\n\t\t\tfor (int i = 1; i <= m; i++) if (ls(b[i], 0) && (x == 0 || b[i] < b[x])) x = i;\n\t\t\tif (x == 0) break;\n\t\t\tfor (int i = 1; i <= n; i++) if (ls(a[x][i], 0) && (y == 0 || a[x][i] < a[x][y])) y = i;\n\t\t\tif (y == 0) return 1;\n\t\t\tpivot(x, y);\n\t\t}\n\t\twhile (1) {\n\t\t\tint x = 0, y = 0;\n\t\t\tfor (int i = 1; i <= n; i++)\n\t\t\t\tif (ls(0, c[i]) && (!y || c[i] > c[y])) y = i;\n\t\t\tif (y == 0) break;\n\t\t\tfor (int i = 1; i <= m; i++)\n\t\t\t\tif (ls(0, a[i][y]) && (!x || b[i] / a[i][y] < b[x] / a[x][y])) x = i;\n\t\t\tif (x == 0) return 2;\n\t\t\tpivot(x, y);\n\t\t}\n\t\tfor (int i = 1; i <= m; i++) if (Left[i] <= n) sol[Left[i]] = b[i];\n\t\treturn 0;\n\t}\n}SS;\n\nstruct point {\n\tint x, y;\n}w[81];\nlong long cost[81];\n\nstruct AA {\n\tint a;\n\tlong double t;\n\tbool operator<(const AA &p)const {\n\t\treturn t < p.t;\n\t}\n}ord[81];\n\nint main() {\n\tint n, m;\n\tint i, j, k;\n\tscanf(\"%d\", &n);\n\tfor (i = 1; i <= n; i++) {\n\t\tlong long t;\n\t\tscanf(\"%d%d%lld\", &w[i].x, &w[i].y, &cost[i]);\n\t}\n\tscanf(\"%d\", &m);\n\n\tSS.init(n, n+m);\n\tfor (i = 1; i <= n; i++) {\n\t\tSS.c[i] = cost[i];\n\t}\n\tfor (i = 1; i <= m; i++) {\n\t\tchar pp[3];\n\t\tint a, b;\n\t\tscanf(\"%s\", pp);\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tSS.b[i] = b;\n\t\tBB[i] = b;\n\t\tif (pp[0] == 'L') {\n\t\t\tfor (j = 1; j <= n; j++) {\n\t\t\t\tif (w[j].x <= a) {\n\t\t\t\t\tSS.a[i][j] = 1;\n\t\t\t\t\tAA[i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (pp[0] == 'R') {\n\t\t\tfor (j = 1; j <= n; j++) {\n\t\t\t\tif (w[j].x >= a) {\n\t\t\t\t\tSS.a[i][j] = 1;\n\t\t\t\t\tAA[i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (pp[0] == 'D') {\n\t\t\tfor (j = 1; j <= n; j++) {\n\t\t\t\tif (w[j].y <= a) {\n\t\t\t\t\tSS.a[i][j] = 1;\n\t\t\t\t\tAA[i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (pp[0] == 'U') {\n\t\t\tfor (j = 1; j <= n; j++) {\n\t\t\t\tif (w[j].y >= a) {\n\t\t\t\t\tSS.a[i][j] = 1;\n\t\t\t\t\tAA[i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 1; i <= n; i++) {\n\t\tSS.a[i + m][i] = 1;\n\t\tSS.b[i + m] = 1;\n\t}\n\tSS.solve();\n\tfor (i = 1; i <= n; i++) {\n\t\tord[i] = { i,SS.sol[i] };\n\t}\n\tsort(ord + 1, ord + n + 1);\n\tfor (i = 1; i <= n; i++) {\n\t\tfor (j = 1; j <= m; j++) {\n\t\t\tint c = 0;\n\t\t\tfor (k = i; k <= n; k++) {\n\t\t\t\tif (AA[j][ord[k].a])c++;\n\t\t\t}\n\t\t\tif (BB[j] < c)break;\n\t\t}\n\t\tif (j == m + 1) {\n\t\t\tlong long res = 0;\n\t\t\tfor (j = i; j <= n; j++) {\n\t\t\t\tres += cost[ord[j].a];\n\t\t\t}\n\t\t\tprintf(\"%lld\\n\", res);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tputs(\"0\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace __gnu_pbds;\nusing namespace std;\n \ntemplate <typename T>\nusing ordered_set =\n\ttree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n \n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n\t*this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n \n#define shandom_ruffle random_shuffle\n \nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=327;\nusing bn=bitset<87>;\nusing ld=long double;\n\nint n;\npii gdz[nax];\nll war[nax];\n\nint m;\nbn podz[nax];\nint ile[nax];\n\nll wyn;\n\nstruct Simplex {        // Maximize c*x subject to Ax <= b.\n  using T = ld;     // Initialize the structure, set A, b, c and then run\n  vector<vector<T>> A;  // solve(). Max objective is stored in res. To recover\n  vector<T> b, c;       // the best result, use getVars().\n  int V, E;\n  vector<int> eqIds, varIds, cols;\n  T res;\n  static constexpr T kEps = 1e-9;\n\n  Simplex(int vars, int eqs) : A(eqs, vector<T>(vars)), b(eqs), c(vars),\n      V(vars), E(eqs), eqIds(eqs), varIds(vars), res(0) {\n    iota(varIds.begin(), varIds.end(), 0);\n    iota(eqIds.begin(), eqIds.end(), vars);\n  }\n\n  void pivot(int eq, int var) {\n    T coef = 1 / A[eq][var];\n    cols.clear();\n    for (int i = 0; i < V; i++) {\n      if (abs(A[eq][i]) > kEps) { cols.push_back(i); A[eq][i] *= coef; }\n    }\n    A[eq][var] *= coef; b[eq] *= coef;\n    for (int row = 0; row < E; row++) {\n      if (row == eq || abs(A[row][var]) < kEps) { continue; }\n      T k = -A[row][var];\n      A[row][var] = 0;\n      for (int i : cols) { A[row][i] += k * A[eq][i]; }\n      b[row] += k * b[eq];\n    }\n    T q = c[var]; c[var] = 0;\n    for (int i : cols) { c[i] -= q * A[eq][i]; }\n    res += q * b[eq];\n    swap(varIds[var], eqIds[eq]);\n  }\n\n  bool solve() {\n    while (true) {\n      int eq = -1, var = -1;\n      for (int i = 0; i < E; i++) { if (b[i] < -kEps) { eq = i; break; } }\n      if (eq == -1) { break; }\n      for (int i = 0; i < V; i++) { if (A[eq][i] < -kEps) { var = i; break; } }\n      if (var == -1) { res = -1e9; return false; /* No solution */ }\n      pivot(eq, var);\n    }\n    while (true) {\n      int var = -1, eq = -1;\n      for (int i = 0; i < V; i++) { if (c[i] > kEps) { var = i; break; } }\n      if (var == -1) { break; }\n      for (int i = 0; i < E; i++) {\n        if (A[i][var] < kEps) { continue; }\n        if (eq >= 0 && b[i] / A[i][var] >= b[eq] / A[eq][var]) { continue; }\n        eq = i;\n      }\n      if (eq == -1) { res = 1e9; return false; /* Unbounded */ }\n      pivot(eq, var);\n    }\n    return true;\n  }\n\n  vector<T> getVars() { // Optimal assignment of variables.\n    vector<T> result(V);\n    for (int i = 0; i < E; i++) if (eqIds[i] < V) result[eqIds[i]] = b[i];\n    return result;\n  }\n};\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(\"%d%d%lld\", &gdz[i].first, &gdz[i].second, &war[i]);\n\tscanf(\"%d\", &m);\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\tchar c;\n\t\tint a, b;\n\t\tscanf(\" %c%d%d\", &c, &a, &b);\n\t\tfor (int j=1; j<=n; j++)\n\t\t{\n\t\t\tif (c=='L' && gdz[j].first<=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='R' && gdz[j].first>=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='D' && gdz[j].second<=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='U' && gdz[j].second>=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t}\n\t\tile[i]=b;\n\t}\n\tSimplex janusz(n, m+n);\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tjanusz.c[i]=war[i+1];\n\t}\n\tfor (int i=0; i<m; i++)\n\t{\n\t\tjanusz.b[i]=ile[i+1];\n\t\tfor (int j=0; j<n; j++)\n\t\t\tjanusz.A[i][j]=podz[i+1][j+1];\n\t}\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tjanusz.b[m+i]=1;\n\t\tjanusz.A[m+i][i]=1;\n\t}\n\tassert(janusz.solve());\n\tld wez=janusz.res;\n\tdebug() << imie(wez);\n\tdebug() << janusz.getVars();\n\tprintf(\"%lld\\n\", llround(wez));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n\nusing namespace std;\nconst int N=105,NN=N<<1,M=N*N;\nconst LL inf=1ll<<55;\nLL rd()\n{\n    LL x=0,w=1;char ch=0;\n    while(ch<'0'||ch>'9'){if(ch=='-') w=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+(ch^48);ch=getchar();}\n    return x*w;\n}\nstruct node\n{\n\tLL x,y;\n\tnode(LL nx=0,LL ny=0){x=nx,y=ny;}\n\tbool operator < (const node &bb) const {return x!=bb.x?x<bb.x:y<bb.y;}\n\tnode operator + (const node &bb) const {return (node){x+bb.x,y+bb.y};}\n}w[M],di[NN];\nint to[M],nt[M],c[M],hd[NN],tot=1,ps,pt,fw[NN],pr[NN],v[NN];\nLL s1,s2,ans;\nvoid adde(int x,int y,int z,LL z1,LL z2)\n{\n\t++tot,to[tot]=y,nt[tot]=hd[x],c[tot]=z,w[tot]=(node){+z1,+z2},hd[x]=tot;\n\t++tot,to[tot]=x,nt[tot]=hd[y],c[tot]=0,w[tot]=(node){-z1,-z2},hd[y]=tot;\n\ts1-=z*z1;\n}\nvoid csfl()\n{\n\tqueue<int> q;\n\twhile(1)\n\t{\n\t\tfor(int i=1;i<=pt;++i) di[i]=(node){-inf,-inf};\n\t\tdi[ps]=(node){0,0},fw[ps]=1<<30,v[ps]=1,q.push(ps);\n\t\tfw[pt]=0;\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tint x=q.front();\n\t\t\tq.pop();\n\t\t\tfor(int i=hd[x];i;i=nt[i])\n\t\t\t{\n\t\t\t\tint y=to[i];\n\t\t\t\tif(c[i]>0&&di[y]<di[x]+w[i])\n\t\t\t\t{\n\t\t\t\t\tdi[y]=di[x]+w[i];\n\t\t\t\t\tpr[y]=i,fw[y]=min(fw[x],c[i]);\n\t\t\t\t\tif(!v[y]) v[y]=1,q.push(y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tv[x]=0;\n\t\t}\n\t\tif(!fw[pt]) return;\n\t\ts1+=di[pt].x*fw[pt],s2+=di[pt].y*fw[pt];\n\t\tint x=pt;\n\t\twhile(x!=ps)\n\t\t{\n\t\t\tint i=pr[x];\n\t\t\tc[i]-=fw[pt],c[i^1]+=fw[pt];\n\t\t\tx=to[i^1];\n\t\t}\n\t}\n}\nint n,m,t=100;\nchar cc[2];\nLL a[N][3],b[N<<2][3],px[N][2],py[N][2];\nmap<char,int> id;\n\nint main()\n{\n/////\n\tid['L']=0,id['R']=1,id['D']=2,id['U']=3;\n\tn=rd();\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=0;j<=2;++j)\n\t\t\ta[i][j]=rd();\n\tm=rd();\n\tfor(int i=1;i<=m;++i)\n\t{\n\t\tscanf(\"%s\",cc),b[i][0]=id[cc[0]];\n\t\tb[i][1]=rd(),b[i][2]=rd();\n\t}\n\tps=0,pt=203;\n\tint yyb=201,zsy=202;\n\tfor(int h=1;h<=n;++h)\n\t{\n\t\tmemset(hd,0,sizeof(int)*(pt+1)),tot=1,s1=s2=0;\n\t\tfor(int i=1;i<=t;++i) px[i][0]=0,px[i][1]=1<<30;\n\t\tfor(int i=1;i<=t;++i) py[i][0]=0,py[i][1]=1<<30;\n\t\tfor(int i=1;i<=m;++i)\n\t\t{\n\t\t\tif(b[i][0]==0) px[b[i][1]][1]=min(px[b[i][1]][1],b[i][2]);\n\t\t\tif(b[i][0]==1) px[b[i][1]-1][0]=max(px[b[i][1]-1][0],h-b[i][2]);\n\t\t\tif(b[i][0]==2) py[b[i][1]][1]=min(py[b[i][1]][1],b[i][2]);\n\t\t\tif(b[i][0]==3) py[b[i][1]-1][0]=max(py[b[i][1]-1][0],h-b[i][2]);\n\t\t}\n\t\tadde(ps,yyb,h,1,0);\n\t\tbool o=1;\n\t\tint np=yyb;\n\t\tfor(int i=t;i;--i)\n\t\t{\n\t\t\tif(px[i][0]>px[i][1]){o=0;break;}\n\t\t\tadde(np,i,px[i][0],1,0),adde(np,i,px[i][1]-px[i][0],0,0);\n\t\t\tnp=i;\n\t\t}\n\t\tnp=zsy;\n\t\tfor(int i=t;i;--i)\n\t\t{\n\t\t\tif(py[i][0]>py[i][1]){o=0;break;}\n\t\t\tadde(i+t,np,py[i][0],1,0),adde(i+t,np,py[i][1]-py[i][0],0,0);\n\t\t\tnp=i+t;\n\t\t}\n\t\tadde(zsy,pt,h,1,0);\n\t\tif(!o) continue;\n\t\tfor(int i=1;i<=n;++i) adde(a[i][0],a[i][1]+t,1,0,a[i][2]);\n\t\tcsfl();\n\t\tif(s1>=0) ans=max(ans,s2);\n\t}\n\tprintf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\n  _|_|                              _|  _|    _|\n_|    _|  _|  _|_|  _|_|_|_|        _|  _|  _|\n_|    _|  _|_|          _|          _|  _|_|\n_|    _|  _|          _|      _|    _|  _|  _|\n  _|_|    _|        _|_|_|_|    _|_|    _|    _|\n\n*/\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<set>\n//#define ls (rt<<1)\n//#define rs (rt<<1|1)\n#define vi vector<int>\n#define pb push_back\n#define mk make_pair\n#define pii pair<ll,ll>\n#define rep(i,a,b) for(int i=(a),i##end=(b);i<=i##end;i++)\n#define fi first\n#define se second\n#define int long long\ntypedef long long ll;\nusing namespace std;\nconst int maxn=720;\nconst int inf=1e18+100;\nint xl[maxn],xr[maxn],yl[maxn],yr[maxn],s=415,t=416;\nint head[maxn],cnt=1;\nstruct gg{\n    int u,v,w;ll cost;int next;\n    void insert(int U,int V,int W,ll Cost,int Next){\n        u=U,v=V,w=W,cost=Cost,next=Next;\n    }\n}side[(maxn*82)*2];\nstruct Point{\n    int x,y;\n    ll cost=0;\n}point[maxn];\nstruct Lim{\n    int a,b;char c;\n}lim[maxn];\nvoid ins(int u,int v,int w,ll cost){\n    side[++cnt].insert(u,v,w,cost,head[u]);head[u]=cnt;\n    side[++cnt].insert(v,u,0,-cost,head[v]);head[v]=cnt;\n}\nint n,m;\nvoid init(int k){\n    rep(i,1,k)xl[i]=yl[i]=-inf,xr[i]=yr[i]=inf;\n    rep(i,1,m){\n        if(lim[i].c=='L')rep(j,lim[i].b+1,k)xl[j]=max(xl[j],lim[i].a+1);\n        else if(lim[i].c=='R')for(int j=k-lim[i].b;j>0;j--)xr[j]=min(xr[j],lim[i].a-1);\n        else if(lim[i].c=='D')rep(j,lim[i].b+1,k)yl[j]=max(yl[j],lim[i].a+1);\n        else if(lim[i].c=='U')for(int j=k-lim[i].b;j>0;j--)yr[j]=min(yr[j],lim[i].a-1);\n    }\n    memset(head,0,sizeof(head));cnt=1;\n    rep(i,1,k)ins(s,2*n+i,1,0);\n    rep(i,1,k)ins(2*n+k+i,t,1,0);\n    rep(i,1,n){\n        ins(i,n+i,1,point[i].cost);\n        rep(j,1,k){\n            if(xl[j]<=point[i].x&&point[i].x<=xr[j])ins(2*n+j,i,1,0);\n            if(yl[j]<=point[i].y&&point[i].y<=yr[j])ins(n+i,2*n+k+j,1,0);\n        }\n    }\n}\nint rk[maxn],q[maxn];\nll dis[maxn],lenth;\nbool vis[maxn];\nbool spfa(){\n    rep(i,1,maxn-1)dis[i]=-inf;\n    memset(vis,0,sizeof(vis));\n    int hd=1,tl=1;q[hd]=s;vis[s]=1;dis[s]=0;\n    while(hd<=tl){\n        int u=q[hd++];vis[u]=0;//cout<<u<<' '<<endl;\n        for(int i=head[u];i;i=side[i].next){\n            int v=side[i].v;if(!side[i].w)continue;\n            if(dis[u]+side[i].cost>dis[v]){\n                dis[v]=dis[u]+side[i].cost;\n                if(!vis[v])q[++tl]=v;\n                vis[v]=1;\n            }\n        }\n    }\n    if(dis[t]!=-inf)return 1;\n    return 0;\n}\nint dfs(int u,int flow){\n    if(u==t)return flow;\n    vis[u]=1;int tot=0;\n    for(int i=head[u];i;i=side[i].next){\n        int v=side[i].v;if(vis[v]||!side[i].w||dis[v]!=dis[u]+side[i].cost)continue;\n        int sent=dfs(v,min(flow,side[i].w));\n        lenth+=1ll*side[i].cost*sent,side[i].w-=sent,side[i^1].w+=sent,tot+=sent;flow-=sent;\n    }\n    // vis[u]=0;\n    return tot;\n}\npii dinic(){\n    int mxflow=0;lenth=0;\n    while(spfa()){\n        int x;\n        while((x=dfs(s,inf)))mxflow+=x;\n    }\n    return mk(mxflow,lenth);\n}\nchar tmp[3];\nsigned main(){\n    scanf(\"%lld\",&n);\n    rep(i,1,n)scanf(\"%lld%lld%lld\",&point[i].x,&point[i].y,&point[i].cost);\n    scanf(\"%lld\",&m);\n    rep(i,1,m){\n        scanf(\"%s%lld%lld\",tmp+1,&lim[i].a,&lim[i].b);lim[i].c=tmp[1];\n    }\n    ll out=0;\n    rep(k,1,n){\n        init(k);\n        pii ans=dinic();out=max(out,ans.se);//cout<<ans.se<<endl;\n    }\n    cout<<out;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 100005\n#define ll long long\nusing namespace std;\nint S=1,T=2,tot=2;\nint pre[maxn],to[maxn],las[maxn],cap[maxn],inc=1;\nll cost[maxn];\nvoid AE(int a,int b,int c,ll d)\n{\n\tpre[++inc]=las[a],las[a]=inc;\n\tto[inc]=b,cap[inc]=c,cost[inc]=d;\n}\nvoid ins(int a,int b,int c,ll d)\n{\n\t//printf(\"%d %d %lld\\n\",a,b,d);\n\tAE(a,b,c,d),AE(b,a,0,-d);\n}\nint lk[maxn],lid[maxn]; ll dis[maxn];\nint Q[maxn],inq[maxn],fr,tl;\nint SPFA()\n{\n\tfor(int i=1;i<=tot;i++) dis[i]=-1e18,lk[i]=lid[i]=0;\n\tdis[S]=0,fr=tl=1,Q[tl]=S,inq[S]=1;\n\twhile(tl>=fr)\n\t{\n\t\tint x=Q[fr]; fr++;\n\t\tinq[x]=0;\n\t\tfor(int i=las[x];i;i=pre[i])\n\t\t{\n\t\t\tint y=to[i];\n\t\t\tif(cap[i]>0&&dis[y]<dis[x]+cost[i])\n\t\t\t{\n\t\t\t\tdis[y]=dis[x]+cost[i],lk[y]=x,lid[y]=i;\n\t\t\t\tif(!inq[y]) Q[++tl]=y,inq[y]=1;\n\t\t\t}\n\t\t}\n\t}\n\treturn dis[T]>-1e18;\n}\nll AddFlow()\n{\n\tll flow=1e18;\n\tfor(int x=T;x!=S;x=lk[x])\n\t\tflow=min(flow,(ll)cap[lid[x]]);//,printf(\"%d--\",lk[x]);\n\t//puts(\"\");\n\tfor(int x=T;x!=S;x=lk[x])\n\t\tcap[lid[x]]-=flow,cap[lid[x]^1]+=flow;\n\treturn flow*dis[T];\n}\nstruct node\n{\n\tint x,y; ll v;\n}itm[maxn],lim[maxn];\n//int cmp1(node a,node b){return a.x<b.x;}\n//int cmp2(node a,node b){return a.y<b.y;}\nint n,m,mp[2222],lb[maxn][2],rb[maxn][2];\nll ans=0;\nvoid Solve(int K)\n{\n\tmemset(las,0,sizeof(las)),inc=1;\n\tfor(int i=1;i<=K;i++) lb[i][0]=lb[i][1]=1,rb[i][0]=rb[i][1]=100;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint rk=lim[i].y,pos=lim[i].x;\n\t\tif(lim[i].v==3&&rk<K)\n\t\t\tlb[rk+1][0]=max(lb[rk+1][0],pos+1);\n\t\tif(lim[i].v==4&&rk<K)\n\t\t\trb[K-rk][0]=min(rb[K-rk][0],pos-1);\n\t\tif(lim[i].v==1&&rk<K)\n\t\t\tlb[rk+1][1]=max(lb[rk+1][1],pos+1);\n\t\tif(lim[i].v==2&&rk<K)\n\t\t\trb[K-rk][1]=min(rb[K-rk][1],pos-1);\n\t}\n\tfor(int i=2;i<=K;i++)\n\t{\n\t\tlb[i][0]=max(lb[i][0],lb[i-1][0]);\n\t\tlb[i][1]=max(lb[i][1],lb[i-1][1]);\n\t}\n\tfor(int i=K-1;i>=1;i--)\n\t{\n\t\trb[i][0]=min(rb[i][0],rb[i+1][0]);\n\t\trb[i][1]=min(rb[i][1],rb[i+1][1]);\n\t}\n\ttot=2+2*K+2*n;\n\tfor(int i=1;i<=K;i++)\n\t{\n\t\tins(S,i+2,1,0);\n\t\tins(i+K+2*n+2,T,1,0);\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(itm[j].x>=lb[i][0]&&itm[j].x<=rb[i][0]) ins(i+2,j+K+2,1,0);\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(itm[j].y>=lb[i][1]&&itm[j].y<=rb[i][1]) ins(j+n+K+2,i+2*n+K+2,1,0);\n\t}\n\tfor(int i=1;i<=n;i++) ins(i+K+2,i+n+K+2,1,itm[i].v);\n\tll c=0;\n\twhile(SPFA())\n\t\tc+=AddFlow();\n\tans=max(ans,c);\n}\nint main()\n{\n\tmp['U']=2,mp['D']=1,mp['L']=3,mp['R']=4;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d%d%lld\",&itm[i].x,&itm[i].y,&itm[i].v);\n\tscanf(\"%d\",&m);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tchar ty[3];int a,b;\n\t\tscanf(\"%s%d%d\",ty,&a,&b);\n\t\tlim[i]=(node){a,b,mp[ty[0]]};\n\t}\n\tfor(int i=1;i<=n;i++) Solve(i);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#define gc getchar()\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n#define ROF(i,a,b) for(int i=a;i>=b;i--)\n#define REP(u) for(int i=hd[u],v,c;v=e[i].v,c=e[i].c,i;i=e[i].n)\nusing namespace std;\ntypedef long long ll;\nconst int N=550,M=100100,iNF=1000010000;\nconst ll INF=1e18;\nint n,m,S,T,X,fl,mxf;\nint lc[N],rc[N],uc[N],dc[N],hd[N],in[N],vi[N];\nll mxw,ans,di[N];\nchar o;\nqueue<int>qu;\nstruct vec{int x,y;ll w;}p[N];\nstruct lim{char o;int t,c;}q[N];\nstruct edge{int n,v,c;ll w;}e[M];\nvoid add_(int u,int v,ll w,int c){e[++fl]=(edge){hd[u],v,c,w};hd[u]=fl;}\nvoid adde(int u,int v,ll w,int c){add_(u,v,w,c);add_(v,u,-w,0);}\nbool SPFA(){\n\tFOR(i,S,T) di[i]=-INF;\n\tdi[T]=0;qu.push(T);\n\twhile(qu.size()){\n\t\tint u=qu.front();qu.pop();in[u]=0;\n\t\tREP(u)if(e[i^1].c && di[v]<di[u]-e[i].w){\n\t\t\tdi[v]=di[u]-e[i].w;\n\t\t\tif(!in[v]) qu.push(v),in[v]=1;\n\t\t}\n\t}\n\treturn di[S]>-INF;\n}\nint dfs(int u,int E){\n\tvi[u]=1;\n\tif(u==T) return E;\n\tint F=0;\n\tREP(u)if(c && !vi[v] && di[v]==di[u]-e[i].w){\n\t\tint t=dfs(v,min(E,c));\n\t\tmxw+=e[i].w*t;\n\t\tF+=t;e[i^1].c+=t;\n\t\tE-=t;e[i^0].c-=t;\n\t\tif(!E) break;\n\t}return F;\n}\nvoid work(int k){\n\tFOR(i,0,k+1) lc[i]=dc[i]=1,rc[i]=uc[i]=X;\n\tFOR(i,1,m){\n\t\tint t=q[i].t,c=q[i].c;\n\t\tif(q[i].o=='R'||q[i].o=='U') c=k-c+1;\n\t\tif(q[i].o=='L' && 1<=c && c<=k) lc[c]=max(lc[c],t+1);\n\t\tif(q[i].o=='R' && 1<=c && c<=k) rc[c]=min(rc[c],t-1);\n\t\tif(q[i].o=='D' && 1<=c && c<=k) dc[c]=max(dc[c],t+1);\n\t\tif(q[i].o=='U' && 1<=c && c<=k) uc[c]=min(uc[c],t-1);\n\t}\n\tS=1;T=2*(k+X+1);fl=1;\n\tFOR(i,S,T) hd[i]=0;\n\tFOR(i,1,k) lc[i]=max(lc[i],lc[i-1]),dc[i]=max(dc[i],dc[i-1]);\n\tROF(i,k,1) rc[i]=min(rc[i],rc[i+1]),uc[i]=min(uc[i],uc[i+1]);\n\tFOR(i,1,k){\n\t\tadde(S,i<<1|0,0,1);\n\t\tadde(i<<1|1,T,0,1);\n\t\tFOR(j,lc[i],rc[i]) adde(i<<1|0,(j+k)<<1|0,0,1);\n\t\tFOR(j,dc[i],uc[i]) adde((j+k)<<1|1,i<<1|1,0,1);\n\t}\n\tFOR(i,1,n) adde((p[i].x+k)<<1|0,(p[i].y+k)<<1|1,p[i].w,1);\n\tmxw=mxf=0;\n\t//FOR(x,S,T){cout<<x<<':';REP(x) cout<<v<<' ';cout<<'\\n';}\n\twhile(SPFA()){\n\t\tdo{\n\t\t\tFOR(i,S,T) vi[i]=0;\n\t\t\tmxf+=dfs(S,iNF);\n\t\t}while(vi[T]);\n\t}\n\tif(mxf==k) ans=max(ans,mxw);\n}\nint main(){\n\t//freopen(\"1.in\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tFOR(i,1,n) scanf(\"%d%d%lld\",&p[i].x,&p[i].y,&p[i].w);\n\tFOR(i,1,n) X=max(X,max(p[i].x,p[i].y));\n\tscanf(\"%d\",&m);\n\tFOR(i,1,m){\n\t\tfor(o=gc;o!='L'&&o!='R'&&o!='D'&&o!='U';o=gc);\n\t\tq[i].o=o;scanf(\"%d%d\",&q[i].t,&q[i].c),q[i].c++;\n\t}\n\tFOR(i,1,n) work(i);\n\tcout<<ans<<'\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\n\nLL s[410][110], c[110]; int n, m;\n\ninline void pivot(int x, int y) {\n    LL tmp = s[y][x]; s[y][x] = -1;\n    for (int i = 1; i <= n + 1; i++) s[y][i] /= -tmp;\n    for (int i = 1; i <= m; i++) if (i != y) {\n        tmp = s[i][x], s[i][x] = 0;\n        if (!tmp) continue;\n        for (int j = 1; j <= n + 1; j++) s[i][j] += s[y][j] * tmp;\n    }\n    tmp = c[x], c[x] = 0;\n    for (int i = 1; i <= n + 1; i++) c[i] += s[y][i] * tmp;\n}\n\ninline LL LP() {\n    for (int cur = 0, pos = 0; ; pivot(cur, pos), pos = cur = 0) {\n        for (int i = 1; i <= n; i++) if (c[i] > 0) cur = i;\n        if (!cur) return c[n + 1];\n        LL mn = 1e18;\n        for (int i = 1; i <= m; i++) if (s[i][cur] < 0) {\n            LL tmp = s[i][n + 1] / -s[i][cur];\n            if (tmp < mn) mn = tmp, pos = i;\n        }\n    }\n}\n\nint x[110], y[110];\n\nint main() {\n    int n, tp = 0; scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i++) \n        scanf(\"%d%d%lld\", &x[i], &y[i], &c[i]), s[++tp][i] = -1, s[tp][n + 1] = 1;\n    int m; scanf(\"%d\", &m);\n    while (m--) {\n        char st[5]; int a, b; scanf(\"%s%d%d\", st + 1, &a, &b), tp++, s[tp][n + 1] = b;\n        if (st[1] == 'L') {\n            for (int i = 1; i <= n; i++) if (x[i] <= a) s[tp][i] = -1;\n        } else if (st[1] == 'R') {\n            for (int i = 1; i <= n; i++) if (x[i] >= a) s[tp][i] = -1;\n        } else if (st[1] == 'D') {\n            for (int i = 1; i <= n; i++) if (y[i] <= a) s[tp][i] = -1;\n        } else for (int i = 1; i <= n; i++) if (y[i] >= a) s[tp][i] = -1;\n    }\n    ::m = tp, ::n = n, printf(\"%lld\\n\", LP());\n}"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#define foreach(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\n#ifndef LOCAL\n#define cerr if(0)cout\n#endif\ntypedef long long ll;\nconst int mod = 1e9+7;\n//My i/o stream\nstruct fastio\n{\n\tchar s[100000];\n\tint it, len;\n\tfastio() {it=len=0;}\n\tinline char get()\n\t{\n\t\tif (it<len) return s[it++]; it=0;\n\t\tlen=fread(s, 1, 100000, stdin);\n\t\tif (len==0) return EOF; else return s[it++];\n\t}\n\tbool notend()\n\t{\n\t\tchar c=get();\n\t\twhile (c==' '||c=='\\n') c=get();\n\t\tif (it>0) it--;\n\t\treturn c!=EOF;\n\t}\n}_buff;\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putchar(' ')\n#define putii(x,y) puti(x),puti(y)\n#define putiii(x,y,z) putii(x,y),puti(z)\n#define putsi(x) putnum(x),putchar('\\n')\n#define putsii(x,y) puti(x),putsi(y)\n#define putsiii(x,y,z) putii(x,y),putsi(z)\ninline ll getnum()\n{\n\tll r=0; bool ng=0; char c; c=_buff.get();\n\twhile (c!='-'&&(c<'0'||c>'9')) c=_buff.get();\n\tif (c=='-') ng=1, c=_buff.get();\n\twhile (c>='0'&&c<='9') r=r*10+c-'0', c=_buff.get();\n\treturn ng?-r:r;\n}\ntemplate <class T> inline void putnum(T x)\n{\n\tif (x<0) putchar('-'), x=-x;\n\tregister short a[20]={}, sz=0;\n\twhile (x) a[sz++]=x%10, x/=10;\n\tif(sz==0) putchar('0');\n\tfor (int i=sz-1; i>=0; i--) putchar('0'+a[i]);\n}\ninline char getreal() {char c=_buff.get(); while (c<=32) c=_buff.get(); return c;}\nll qpow(ll x, ll k) {return k==0? 1: 1ll*qpow(1ll*x*x%mod,k>>1)*(k&1?x:1)%mod;}\nconst ll inf = 4e18;\nnamespace F\n{\n\tconst int maxn = 400, maxe = 100011;\n\tint head[maxn], nxt[maxe], to[maxe], cap[maxe];\n\tll cost[maxe], tot;\n\tvoid init()\n\t{\n\t\ttot = 1;\n\t\tmemset(head, 0, sizeof(head));\n\t}\n\tvoid add_edge(int x, int y, int c, ll w)\n\t{\n//\t\tcerr<<\"add_edge:\"<<x<<\",\"<<y<<\" \"<<c<<\" \"<<w<<endl;\n\t\tnxt[++tot] = head[x];\n\t\thead[x] = tot;\n\t\tto[tot] = y;\n\t\tcap[tot] = c;\n\t\tcost[tot] = w;\n\t\tswap(x, y);\n\t\tnxt[++tot] = head[x];\n\t\thead[x] = tot;\n\t\tto[tot] = y;\n\t\tcap[tot] = 0;\n\t\tcost[tot] = -w;\n\t\tassert(tot<maxe);\n\t}\n\tdeque<int> q;\n\tll dis[maxn];\n\tbool inq[maxn];\n\tvoid balance()\n\t{\n\t\tif (q.size()>0&&dis[q.front()]<dis[q.back()])\n\t\t{\n\t\t\tswap(q.front(), q.back());\n\t\t}\n\t}\n\tvoid spfa(int S, int N)\n\t{\n\t\tinq[S] = 1; q.push_back(S);\n\t\tfor (int i=0; i<=N; i++) dis[i] = inf;\n\t\tdis[S] = 0;\n\t\twhile (!q.empty())\n\t\t{\n\t\t\tint x = q.front(); q.pop_front();\n\t\t\tinq[x] = 0;\n\t\t\tbalance();\n\t\t\tfor (int i = head[x]; i; i=nxt[i])\n\t\t\t{\n\t\t\t\tif (cap[i]&&dis[to[i]]>dis[x]+cost[i])\n\t\t\t\t{\n\t\t\t\t\tdis[to[i]] = dis[x]+cost[i];\n\t\t\t\t\tif (!inq[to[i]])\n\t\t\t\t\t{\n\t\t\t\t\t\tinq[to[i]] = 1;\n\t\t\t\t\t\tq.push_back(to[i]);\n\t\t\t\t\t\tbalance();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tfor (int i=1; i<=N; i++) cerr<<dis[i]<<\" \"; cerr<<endl;\n\t}\n\t\n\tbool vis[maxn];\n\tint dfs(int x, int T, int f)\n\t{\n\t\tif (x==T) return f;\n\t\tvis[x] = 1;\n\t\tint of = f;\n\t\tfor (int i=head[x]; i; i=nxt[i])\n\t\t{\n\t\t\tif (!vis[to[i]]&&cap[i]&&dis[to[i]]==dis[x]+cost[i])\n\t\t\t{\n\t\t\t\tint u = to[i];\n\t\t\t\tint d = dfs(u, T, min(f, cap[i]));\n\t\t\t\tcap[i] -= d;\n\t\t\t\tcap[i^1] += d;\n\t\t\t\tf -= d;\n\t\t\t\tif (!f) return of;\n\t\t\t}\n\t\t}\n\t\treturn of-f;\n\t}\n\tpair<int, ll> min_cost_flow(int S, int T, int K)\n\t{\n\t\tll ans = 0;\n\t\tint flow = 0;\n\t\twhile (flow<K)\n\t\t{\n\t\t\tspfa(S, T);\n\t\t\tif (dis[T]>=inf) break;\n\t\t\twhile (flow<K)\n\t\t\t{\n\t\t\t\tmemset(vis, 0, sizeof(vis));\n\t\t\t\tint f = dfs(S, T, K-flow);\n\t\t\t\tans += 1ll*f*dis[T];\n\t\t\t\tflow += f;\n\t\t\t\tif (f==0) break;\n\t\t\t}\n\t\t}\n\t\treturn MP(flow, ans);\n\t}\n};\nint n;\nint tid[256];\npair<int,int> a[88];\nll w[88];\nvector<pair<int,int> > M[4];\npair<int,int> segx[88], segy[88];\nll solve(int K)\n{\n//\tcerr<<\"solve: \"<<K<<endl;\n\tfor (int i=1; i<=K; i++) segx[i] = segy[i] = MP(0, 100);\n\tfor (auto x : M[0])\n\t{\n\t\tfor (int i=x.SS+1; i<=K; i++)\n\t\t{\n\t\t\tsegx[i].FF = max(segx[i].FF, x.FF+1);\n\t\t}\n\t}\n\tfor (auto x : M[1])\n\t{\n\t\tfor (int i=K-x.SS; i>=1; i--)\n\t\t{\n\t\t\tsegx[i].SS = min(segx[i].SS, x.FF-1);\n\t\t}\n\t}\n\tfor (auto x : M[2])\n\t{\n\t\tfor (int i=x.SS+1; i<=K; i++)\n\t\t{\n\t\t\tsegy[i].FF = max(segy[i].FF, x.FF+1);\n\t\t}\n\t}\n\tfor (auto x : M[3])\n\t{\n\t\tfor (int i=K-x.SS; i>=1; i--)\n\t\t{\n\t\t\tsegy[i].SS = min(segy[i].SS, x.FF-1);\n\t\t}\n\t}\n\tint S = 2*K+2*n+1, T = S+1;\n\tF::init();\n\tfor (int i=1; i<=K; i++)\n\t{\n\t\tF::add_edge(S, i, 1, 0);\n\t\tF::add_edge(i+K, T, 1, 0);\n\t\tfor (int j=1; j<=n; j++)\n\t\t{\n\t\t\tif (segx[i].FF<=a[j].FF&&a[j].FF<=segx[i].SS)\n\t\t\t{\n\t\t\t\tF::add_edge(i, j+2*K, 1, 0);\n\t\t\t}\n\t\t\tif (segy[i].FF<=a[j].SS&&a[j].SS<=segy[i].SS)\n\t\t\t{\n\t\t\t\tF::add_edge(j+2*K+n, i+K, 1, 0);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1; i<=n; i++) F::add_edge(i+2*K, i+2*K+n, 1, -w[i]);\n\tpair<int, ll> ans = F::min_cost_flow(S, T, K);\n//\tcerr<<\"F::ftot=\"<<F::ftot<<endl;\n\tif (ans.FF<K) return 0;\n//\tcerr<<\"ans=\"<<ans<<endl;\n\treturn -ans.SS;\n}\nint main()\n{\n\ttid['L'] = 0;\n\ttid['R'] = 1;\n\ttid['D'] = 2;\n\ttid['U'] = 3;\n\tgeti(n);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tll x, y, v;\n\t\tgetiii(x, y, v);\n\t\ta[i] = MP(x, y);\n\t\tw[i] = v;\n\t}\n\tint m;\n\tgeti(m);\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\tchar t;\n\t\tint a, b;\n\t\tt = getreal();\n\t\tgetii(a, b);\n\t\tM[tid[t]].PB(MP(a, b));\n\t}\n\tll ans = 0;\n\tfor (int K=1; K<=n; K++)\n\t{\n\t\tans = max(ans, solve(K));\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 16.03.2019 16:16:57       \n**/\n#undef _GLIBCXX_DEBUG\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring to_string(string s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntypedef long double ld;\n\nconst ld eps = 1e-8;\n\nvector<ld> simplex(vector<vector<ld>> a) {\n  int n = (int) a.size() - 1;\n  int m = (int) a[0].size() - 1;\n  vector<int> left(n + 1);\n  vector<int> up(m + 1);\n  iota(left.begin(), left.end(), m);\n  iota(up.begin(), up.end(), 0);\n  auto pivot = [&](int x, int y) {\n    swap(left[x], up[y]);\n    ld k = a[x][y];\n    a[x][y] = 1;\n    vector<int> pos;\n    for (int j = 0; j <= m; j++) {\n      a[x][j] /= k;\n      if (fabs(a[x][j]) > eps) {\n        pos.push_back(j);\n      }\n    }\n    for (int i = 0; i <= n; i++) {\n      if (fabs(a[i][y]) < eps || i == x) {\n        continue;\n      }\n      k = a[i][y];\n      a[i][y] = 0;\n      for (int j : pos) {\n        a[i][j] -= k * a[x][j];\n      }\n    }\n  };\n  while (1) {\n    int x = -1;\n    for (int i = 1; i <= n; i++) {\n      if (a[i][0] < -eps && (x == -1 || a[i][0] < a[x][0])) {\n        x = i;\n      }\n    }\n    if (x == -1) {\n      break;\n    }\n    int y = -1;\n    for (int j = 1; j <= m; j++) {\n      if (a[x][j] < -eps && (y == -1 || a[x][j] < a[x][y])) {\n        y = j;\n      }\n    }\n    if (y == -1) {\n      return vector<ld>(); // infeasible\n    }\n    pivot(x, y);\n  }\n  while (1) {\n    int y = -1;\n    for (int j = 1; j <= m; j++) {\n      if (a[0][j] > eps && (y == -1 || a[0][j] > a[0][y])) {\n        y = j;\n      }\n    }\n    if (y == -1) {\n      break;\n    }\n    int x = -1;\n    for (int i = 1; i <= n; i++) {\n      if (a[i][y] > eps && (x == -1 || a[i][0] / a[i][y] < a[x][0] / a[x][y])) {\n        x = i;\n      }\n    }\n    if (x == -1) {\n      return vector<ld>(); // unbounded\n    }\n    pivot(x, y);\n  }\n  vector<ld> ans(m + 1);\n  for (int i = 1; i <= n; i++) {\n    if (left[i] <= m) {\n      ans[left[i]] = a[i][0];\n    }\n  }\n  ans[0] = -a[0][0];\n  return ans;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<int> x(n), y(n);\n  vector<long long> z(n);\n  for (int i = 0; i < n; i++) {\n    cin >> x[i] >> y[i] >> z[i];\n  }\n  vector<vector<ld>> mat;\n  {\n    vector<ld> row(n + 1);\n    for (int i = 0; i < n; i++) {\n      row[i + 1] = z[i];\n    }\n    mat.push_back(row);\n  }\n  {\n    for (int i = 0; i < n; i++) {\n      vector<ld> row(n + 1);\n      row[0] = 1;\n      row[i + 1] = 1;\n      mat.push_back(row);\n    }\n  }\n  int tt;\n  cin >> tt;\n  for (int qq = 0; qq < tt; qq++) {\n    string foo;\n    int bar, baz;\n    cin >> foo >> bar >> baz;\n    vector<ld> row(n + 1);\n    row[0] = baz;\n    if (foo == \"L\") {\n      for (int i = 0; i < n; i++) if (x[i] <= bar) row[i + 1] = 1;\n    }\n    if (foo == \"R\") {\n      for (int i = 0; i < n; i++) if (x[i] >= bar) row[i + 1] = 1;\n    }\n    if (foo == \"D\") {\n      for (int i = 0; i < n; i++) if (y[i] <= bar) row[i + 1] = 1;\n    }\n    if (foo == \"U\") {\n      for (int i = 0; i < n; i++) if (y[i] >= bar) row[i + 1] = 1;\n    }\n    mat.push_back(row);\n  }\n  vector<ld> ret = simplex(mat);\n  debug(ret[0]);\n  vector<int> bads;\n  mt19937 rng((unsigned int) chrono::steady_clock::now().time_since_epoch().count());\n  for (int i = 0; i < n; i++) {\n    if (ret[i + 1] > eps && ret[i + 1] < 1 - eps) {\n      bads.push_back(i);\n    }\n  }\n  debug(bads);\n  bads.resize(min((int) bads.size(), 10));\n  int sz = (int) bads.size();\n  long long ans = 0;\n  for (int t = 0; t < (1 << sz); t++) {\n    for (int i = 0; i < sz; i++) {\n      if (t & (1 << i)) {\n        mat[bads[i] + 1][0] = 1;\n        vector<ld> row(n + 1);\n        row[0] = -1;\n        row[bads[i] + 1] = -1;\n        mat.push_back(row);\n      } else {\n        mat[bads[i] + 1][0] = 0;\n      }\n    }\n    vector<ld> ret2 = simplex(mat);\n    if (ret2.empty()) continue;\n    long long val = 0;\n    for (int i = 0; i < n; i++) {\n      val += z[i] * (ret2[i + 1] > 1 - eps);\n    }\n    debug(val);\n    ans = max(ans, val);\n    mat.resize(n + tt + 1);\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long ll;\nll gi(){\n\tll x=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch))f^=ch=='-',ch=getchar();\n\twhile(isdigit(ch))x=x*10+ch-'0',ch=getchar();\n\treturn f?x:-x;\n}\nstd::mt19937 rnd(time(NULL));\n#define rand rnd\n#define pr std::pair<int,int>\n#define fi first\n#define se second\ntemplate<class T>void cxk(T&a,T b){a=a>b?a:b;}\ntemplate<class T>void cnk(T&a,T b){a=a<b?a:b;}\n#ifdef mod\nint pow(int x,int y){\n\tint ret=1;\n\twhile(y){\n\t\tif(y&1)ret=1ll*ret*x%mod;\n\t\tx=1ll*x*x%mod;y>>=1;\n\t}\n\treturn ret;\n}\ntemplate<class Ta,class Tb>void inc(Ta&a,Tb b){a=a+b>=mod?a+b-mod:a+b;}\ntemplate<class Ta,class Tb>void dec(Ta&a,Tb b){a=a>=b?a-b:a+mod-b;}\n#endif\nint px[81],py[81];ll pk[81];\nchar qc[323];int qa[321],qb[321];\nint Lx[81],Rx[81],Ly[81],Ry[81];\nint fir[410],dis[10000010],nxt[10000010],w[10000010],id=1;ll cost[10000010];\nvoid link(int a,int b,int c,ll d){\n\tnxt[++id]=fir[a],fir[a]=id,dis[id]=b,w[id]=c,cost[id]=d;\n\tnxt[++id]=fir[b],fir[b]=id,dis[id]=a,w[id]=0,cost[id]=-d;\n}\nint S,T,lst[410],que[100000],hd,tl,inq[410];\nll dist[410],Cost,Flow;\nbool Mincost(){\n\thd=tl=0;memset(dist,63,sizeof dist);\n\tdist[S]=0;inq[S]=1;que[tl++]=S;lst[S]=0;\n\twhile(hd^tl){\n\t\tint x=que[hd++];\n\t\tfor(int i=fir[x];i;i=nxt[i])\n\t\t\tif(w[i]&&dist[dis[i]]>dist[x]+cost[i]){\n\t\t\t\tdist[dis[i]]=dist[x]+cost[i];lst[dis[i]]=i;\n\t\t\t\tif(!inq[dis[i]])inq[dis[i]]=1,que[tl++]=dis[i];\n\t\t\t}\n\t\tinq[x]=0;\n\t}\n\tif(dist[T]>1e18)return 0;\n\tfor(int i=lst[T];i;i=lst[dis[i^1]])--w[i],++w[i^1],Cost+=cost[i];\n\t++Flow;\n\treturn 1;\n}\nint main(){\n#ifdef LOCAL\n\tfreopen(\"in.in\",\"r\",stdin);\n\t//freopen(\"out.out\",\"w\",stdout);\n#endif\n\tint n=gi();\n\tfor(int i=1;i<=n;++i)px[i]=gi(),py[i]=gi(),pk[i]=gi();\n\tint q=gi();\n\tfor(int i=1;i<=q;++i)scanf(\"%s\",qc+i),qa[i]=gi(),qb[i]=gi();\n\tll ans=0;\n\tfor(int N=1;N<=n;++N){\n\t\tfor(int i=1;i<=N;++i)Lx[i]=1,Rx[i]=100,Ly[i]=1,Ry[i]=100;\n\t\tfor(int i=1;i<=q;++i){\n\t\t\tswitch(qc[i]){\n\t\t\tcase'L':for(int j=qb[i]+1;j<=N;++j)cxk(Lx[j],qa[i]+1);break;\n\t\t\tcase'R':for(int j=1;j<=N-qb[i];++j)cnk(Rx[j],qa[i]-1);break;\n\t\t\tcase'D':for(int j=qb[i]+1;j<=N;++j)cxk(Ly[j],qa[i]+1);break;\n\t\t\tcase'U':for(int j=1;j<=N-qb[i];++j)cnk(Ry[j],qa[i]-1);break;\n\t\t\t}\n\t\t}\n\t\tmemset(fir,0,sizeof fir);id=1;\n\t\tS=N+N+200+1,T=S+1;\n\t\tfor(int i=1;i<=N;++i)link(S,i,1,0),link(i+N,T,1,0);\n\t\tfor(int i=1;i<=N;++i)\n\t\t\tfor(int j=1;j<=100;++j){\n\t\t\t\tif(Lx[i]<=j&&j<=Rx[i])link(i,j+N+N,1,0);\n\t\t\t\tif(Ly[i]<=j&&j<=Ry[i])link(j+N+N+100,i+N,1,0);\n\t\t\t}\n\t\tfor(int i=1;i<=n;++i)link(px[i]+N+N,py[i]+N+N+100,1,-pk[i]);\n\t\tFlow=Cost=0;while(Mincost());\n\t\tif(Flow==N&&-Cost>ans)ans=-Cost;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int maxn = 100005;\nconst int INF = 1e9;\nconst ll INF_LL = 1e18, bound = 1e15+3;\n\nint e_num = 1, S, T, maxf = 0;\nll mincost = 0;\nint hed[maxn];\nll ct[maxn];\nstruct Edge {\n  int from, to, nxt, c;\n  ll cost;\n} edge[maxn];\nvoid addedge(int from, int to, int c, ll cost) {\n  edge[++e_num] = (Edge){from, to, hed[from], c, cost};\n  hed[from] = e_num;\n}\nvoid adde(int from, int to, int c, ll cost) {\n  addedge(from, to, c, cost);\n  addedge(to, from, 0, -cost);\n}\nqueue<int> q;\n#define prev prv\nint inq[maxn], prev[maxn], pree[maxn];\nbool SPFA() {\n  for (int i = 0; i <= T; i++) ct[i] = INF_LL;\n  inq[S] = 1;\n  ct[S] = 0;\n  q.push(S);\n  while (!q.empty()) {\n    int cur = q.front();\n    q.pop();\n    for (int i = hed[cur]; i; i = edge[i].nxt) {\n      int to = edge[i].to;\n      if (ct[to] > ct[cur] + edge[i].cost && edge[i].c) {\n        if (!inq[to]) {\n          inq[to] = 1;\n          q.push(to);\n        }\n        ct[to] = ct[cur] + edge[i].cost;\n        prev[to] = cur;\n        pree[to] = i;\n      }\n    }\n    inq[cur] = 0;\n  }\n  if (ct[T] == INF_LL) return 0;\n  int flow = INF;\n  for (int cur = T; prev[cur]; cur = prev[cur]) {\n    int ed = pree[cur];\n    flow = min(flow, edge[ed].c);\n  }\n  for (int cur = T; prev[cur]; cur = prev[cur]) {\n    int ed = pree[cur];\n    edge[ed].c -= flow;\n    edge[ed ^ 1].c += flow;\n  }\n  maxf += flow;\n  mincost += flow * ct[T];\n  return 1;\n}\n\nconst int N = 233;\nint n, m, L[N], R[N], U[N], D[N], x[N], y[N];\nint type[N], tt[N], vv[N];\nll v[N];\n\nll Main(int k) {\n  memset(L, 0, sizeof L);\n  memset(D, 0, sizeof D);\n  memset(R, 0x3f, sizeof R);\n  memset(U, 0x3f, sizeof U);\n  for (int x = 1; x <= m; x++) {\n    int t = tt[x], v = vv[x];\n    if (type[x] == 'L') {\n      for (int i = v + 1; i <= k; i++) {\n        L[i] = max(L[i], t + 1);\n      }\n    } else if (type[x] == 'R') {\n      for (int i = 1; i <= k - v; i++) {\n        R[i] = min(R[i], t - 1);\n      }\n    } else if (type[x] == 'D') {\n      for (int i = v + 1; i <= k; i++) {\n        D[i] = max(D[i], t + 1);\n      }\n    } else {\n      for (int i = 1; i <= k - v; i++) {\n        U[i] = min(U[i], t - 1);\n      }\n    }\n  }\n  S = n * 4 + 1, T = n * 4 + 2;\n  mincost = maxf = 0;\n  e_num = 1;\n  memset(hed, 0, sizeof hed);\n  for (int i = 1; i <= k; i++) {\n    adde(S, i, 1, 0);\n    adde(i + k, T, 1, 0);\n    for (int j = 1; j <= n; j++) {\n      if (L[i] <= x[j] && x[j] <= R[i]) {\n        adde(i, j + k + k, 1, 0);\n      }\n      if (D[i] <= y[j] && y[j] <= U[i]) {\n        adde(j + k + k + n, i + k, 1, 0);\n      }\n    }\n  }\n  for (int j = 1; j <= n; j++) {\n    adde(j + k + k, j + k + k + n, 1, bound - v[j]);\n  }\n  while (SPFA());\n  if (maxf != k) return 0;\n  return maxf * bound - mincost;\n}\n\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d%d%lld\", &x[i], &y[i], &v[i]);\n  }\n  scanf(\"%d\", &m);\n  for (int i = 1; i <= m; i++) {\n    char c[4];\n    scanf(\"%s%d%d\", c, &tt[i], &vv[i]);\n    type[i] = c[0];\n  }\n  ll ans = 0;\n  for (int i = 1; i <= n; i++) {\n    ans = max(ans, Main(i));\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cassert>\n\n#define pb push_back\n#define fir first\n#define sec second\n#define forto(_) for (int e = last[_], v = E[e].to; e; v = E[e = E[e].next].to)\n#define forback(_) for (int _ = T; _ ^ S; _ = pre[_])\n\ntypedef long long LL;\n\nconst int kMaxn = 85, kMaxe = 2e4;\nconst LL kInf64 = 1e15 + 5;\n\ntypedef std::pair<int, int> Pii;\ntypedef int IArn[kMaxn];\ntypedef int IArv[kMaxn << 2];\n\nstruct Edge {\n\tint to, capt;\n\tLL cost;\n\tint next;\n} E[kMaxe << 1];\n\nint n, m, tote, S, T;\nIArn X, Y, L, R, U, D;\nIArv last, pre, pree;\nLL V[kMaxn], dist[kMaxn << 2];\nstd::vector<Pii> con[4];\nchar IN[5];\n\ninline void AddEdge(int u, int v, int cap, LL cst) {\n\tE[++tote] = (Edge){v, cap, cst, last[u]}, last[u] = tote;\n\tassert(E[tote].cost == cst);\n\tE[++tote] = (Edge){u, 0, -cst, last[v]}, last[v] = tote;\n}\ntemplate <typename T>\nvoid Umin(T & x, T y) {\n\tx > y ? x = y : 0;\n}\ntemplate <typename T>\nvoid Umax(T & x, T y) {\n\tx < y ? x = y : 0;\n}\nLL Mcf(int);\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d%d%lld\", X + i, Y + i, V + i);\n\t}\n\tscanf(\"%d\", &m);\n\tfor (int i = 0, ai, bi; i < m; i++) {\n\t\tscanf(\"%s%d%d\", IN, &ai, &bi);\n\t\tswitch (IN[0]) {\n\t\t\tcase 'L' :\n\t\t\t\tcon[0].pb(Pii(ai, bi));\n\t\t\t\tbreak;\n\t\t\tcase 'R' :\n\t\t\t\tcon[1].pb(Pii(ai, bi));\n\t\t\t\tbreak;\n\t\t\tcase 'D' :\n\t\t\t\tcon[2].pb(Pii(ai, bi));\n\t\t\t\tbreak;\n\t\t\tcase 'U' :\n\t\t\t\tcon[3].pb(Pii(ai, bi));\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n/*\tfor (int i = 1; i <= n; i++) {\n\t\tL[i] = D[i] = 1;\n\t}\n\tfor (auto & p : con[0]) {\n\t\tUmax(L[p.sec + 1], p.fir + 1);\n\t}\n\tfor (auto & p : con[2]) {\n\t\tUmax(D[p.sec + 1], p.fir + 1);\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tUmax(L[i], L[i - 1]);\n\t\tUmax(D[i], D[i - 1]);\n\t}*/\n\n\tLL ans = 0;\n\tfor (int k = 1; k <= n; k++) {\n\t\tfor (int i = 1; i <= k; i++) {\n\t\t\tR[i] = U[i] = 1000;\n\t\t\tL[i] = D[i] = 0;\n\t\t}\n\t\tfor (auto & p : con[1]) {\n\t\t\tif (k <= p.sec) continue;\n\t\t\tUmin(R[k - p.sec], p.fir - 1);\n\t\t}\n\t\tfor (auto & p : con[3]) {\n\t\t\tif (k <= p.sec) continue;\n\t\t\tUmin(U[k - p.sec], p.fir - 1);\n\t\t}\n\t\tfor (int i = k - 1; i > 0; i--) {\n\t\t\tUmin(R[i], R[i + 1]);\n\t\t\tUmin(U[i], U[i + 1]);\n\t\t}\n\t\tfor (auto & p : con[0]) {\n\t\t\tif (k <= p.sec) continue;\n\t\t\tUmax(L[p.sec + 1], p.fir + 1);\n\t\t}\n\t\tfor (auto & p : con[2]) {\n\t\t\tif (k <= p.sec) continue;\n\t\t\tUmax(D[p.sec + 1], p.fir + 1);\n\t\t}\n\t\tfor (int i = 2; i <= k; i++) {\n\t\t\tUmax(L[i], L[i - 1]);\n\t\t\tUmax(D[i], D[i - 1]);\n\t\t}\n\n\n\t\ttote = 1;\n\t\tmemset(last, 0, sizeof last);\n\t\tT = (S = k + n + n + k + 1) + 1;\n\t\tfor (int i = 1; i <= k; i++) {\n\t\t\tAddEdge(S, i, 1, 0);\n\t\t\tAddEdge(k + n + n + i, T, 1, 0);\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tif (L[i] <= X[j] && X[j] <= R[i]) {\n\t\t\t\t\tAddEdge(i, k + j, 1, 0);\n\t\t\t\t}\n\t\t\t\tif (D[i] <= Y[j] && Y[j] <= U[i]) {\n\t\t\t\t\tAddEdge(k + n + j, k + n + n + i, 1, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tAddEdge(k + i, k + n + i, 1, kInf64 - V[i]);\n\t\t}\n\n\t\tans = std::max(ans, Mcf(k));\n\t}\n\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n\nbool Spfa() {\n\tstatic std::queue<int> que;\n\tstatic int inque[kMaxn << 2];\n\n\tmemset(pre, 0xff, sizeof pre);\n\tmemset(dist, 0x7f, sizeof dist);\n\n\tfor (dist[S] = 0, que.push(S), inque[S] = 1; !que.empty(); ) {\n\t\tint u = que.front(); que.pop();\n\t\tforto(u) {\n\t\t\tif (E[e].capt > 0 && dist[v] > dist[u] + E[e].cost) {\n\t\t\t\tdist[v] = dist[u] + E[e].cost;\n\t\t\t\tpre[v] = u, pree[v] = e;\n\t\t\t\tif (!inque[v]) {\n\t\t\t\t\tque.push(v), inque[v] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tinque[u] = 0;\n\t}\n\treturn ~pre[T];\n}\n\nLL Mcf(int maxf) {\n\tLL tot = 0, sumf = 0;\n\twhile (Spfa()) {\n\t\tint flow = 100000;\n\t\tforback(u) {\n\t\t\tflow = std::min(flow, E[pree[u]].capt);\n\t\t}\n\t\ttot += 1ll * flow * dist[T], sumf += flow;\n\t\tforback(u) {\n\t\t\tE[pree[u]].capt -= flow;\n\t\t\tE[pree[u] ^ 1].capt += flow;\n\t\t}\n\t}\n\treturn sumf >= maxf ? maxf * kInf64 - tot : 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAX_N = 1e3, MAX_COOR = 100;\nconst ll INF = LLONG_MAX / 2;\n\nvoid set_max(int &a, int b) { a = max(a, b); }\nvoid set_min(int &a, int b) { a = min(a, b); }\n\nnamespace MCMF {\n    struct Edge;\n\n    struct Node {\n        Edge *from, *head;\n        ll dis;\n        bool inq;\n        Node();\n    };\n    vector<Node *> nodes;\n\n    Node::Node() : head(nullptr), inq(false) { nodes.push_back(this); }\n\n    struct Edge {\n        Node *to;\n        Edge *nxt, *rev;\n        ll cap, cost;\n        Edge(Node *a, Node *b, ll cap, ll cost) : to(b), nxt(a->head), cap(cap), cost(cost) {\n            a->head = this;\n        }\n    };\n\n    void add_edge(Node *a, Node *b, ll cap, ll cost) {\n        new Edge(a, b, cap, cost);\n        new Edge(b, a, 0, -cost);\n        (a->head->rev = b->head)->rev = a->head;\n    }\n\n    bool SPFA(Node *S, Node *T) {\n        for (Node *i : nodes) i->dis = -INF;\n        S->dis = 0;\n        queue<Node *> que;\n        auto push = [&](Node *x) { que.push(x); x->inq = true; };\n        auto pop = [&]() { Node *x = que.front(); que.pop(); x->inq = false; return x; };\n        push(S);\n        while (!que.empty()) {\n            Node *x = pop();\n            for (Edge *i = x->head; i; i = i->nxt) {\n                if (i->cap && x->dis + i->cost > i->to->dis) {\n                    i->to->dis = x->dis + i->cost; i->to->from = i;\n                    if (!i->to->inq) {\n                        push(i->to);\n                    }\n                }\n            }\n        }\n        return T->dis != -INF;\n    }\n\n    void main(Node *S, Node *T, ll &flow, ll &cost) {\n        while (SPFA(S, T)) {\n            ll v = INF;\n            for (Node *i = T; i != S; i = i->from->rev->to) v = min(v, i->from->cap);\n            flow += v; cost += v * T->dis;\n            for (Node *i = T; i != S; i = i->from->rev->to) i->from->cap -= v, i->from->rev->cap += v;\n        }\n    }\n\n    void clear() {\n        for (Node *i : nodes) {\n            for (Edge *j = i->head, *k; j; j = k) k = j->nxt, delete j;\n            delete i;\n        }\n        nodes.clear();\n    }\n\n    void describe_edge(Node *a, Node *b) {\n        for (Edge *i = a->head; i; i = i->nxt) {\n            if (i->to == b) {\n                printf(\"cap: %lld cost:%lld used: %lld\\n\", i->cap, i->cost, i->rev->cap);\n                return;\n            }\n        }\n        printf(\"Not found\\n\");\n    }\n}\n\nusing MCMF::Node;\nusing MCMF::add_edge;\nusing MCMF::describe_edge;\n\nstruct Jewel {\n    int x, y;\n    ll v;\n\n    void read() { scanf(\"%d%d%lld\", &x, &y, &v); }\n} jewels[MAX_N];\n\nstruct Constraint {\n    char t;\n    int a, b;\n\n    void read() { char s[5]; scanf(\"%s\", s); t = s[0]; scanf(\"%d%d\", &a, &b); }\n} constraints[MAX_N];\n\nint N, M;\nint x_mx[MAX_N], x_mn[MAX_N], y_mx[MAX_N], y_mn[MAX_N], x_delta[MAX_N], y_delta[MAX_N];\nNode *x_n[MAX_N], *y_n[MAX_N], *S, *T;\nll ans = 0;\n\nint main() {\n    scanf(\"%d\", &N);\n    for (int i = 1; i <= N; i++) jewels[i].read();\n    scanf(\"%d\", &M);\n    for (int i = 1; i <= M; i++) constraints[i].read();\n    for (int sel = 1; sel <= N; sel++) {\n        for (int i = 0; i <= MAX_COOR; i++) x_mx[i] = INT_MAX, x_mn[i] = 0, y_mx[i] = INT_MAX, y_mn[i] = 0, x_delta[i] = 0, y_delta[i] = 0;\n        for (int i = 1; i <= M; i++) {\n            switch (constraints[i].t) {\n            case 'L': {\n                set_max(x_mn[constraints[i].a], sel - constraints[i].b);\n            } break;\n            case 'R': {\n                set_min(x_mx[constraints[i].a - 1], constraints[i].b);\n            } break;\n            case 'D': {\n                set_max(y_mn[constraints[i].a], sel - constraints[i].b);\n            } break;\n            case 'U': {\n                set_min(y_mx[constraints[i].a - 1], constraints[i].b);\n            } break;\n            }\n        }\n        bool ok = true;\n        for (int i = 0; i <= MAX_COOR; i++) {\n            if (x_mn[i] > x_mx[i] || y_mn[i] > y_mx[i])\n                ok = false;\n        }\n        if (!ok) continue;\n        ll flow = 0, cost = 0;\n        for (int i = 0; i <= MAX_COOR; i++) {\n            x_delta[i + 1] += x_mn[i];\n            x_delta[i] -= x_mn[i];\n            y_delta[i + 1] -= y_mn[i];\n            y_delta[i] += y_mn[i];\n        }\n        x_delta[0] += sel;\n        y_delta[0] -= sel;\n        for (int i = 0; i <= MAX_COOR + 1; i++) {\n            x_n[i] = new Node();\n            y_n[i] = new Node();\n        }\n        S = new Node();\n        T = new Node();\n        for (int i = 0; i <= MAX_COOR + 1; i++) {\n            if (x_delta[i] > 0) {\n                add_edge(S, x_n[i], x_delta[i], 0);\n                flow -= x_delta[i];\n            }\n            if (x_delta[i] < 0) {\n                add_edge(x_n[i], T, -x_delta[i], 0);\n            }\n            if (y_delta[i] > 0) {\n                add_edge(S, y_n[i], y_delta[i], 0);\n                flow -= y_delta[i];\n            }\n            if (y_delta[i] < 0) {\n                add_edge(y_n[i], T, -y_delta[i], 0);\n            }\n        }\n        for (int i = 0; i <= MAX_COOR; i++) {\n            add_edge(x_n[i], x_n[i + 1], x_mx[i] - x_mn[i], 0);\n            add_edge(y_n[i + 1], y_n[i], y_mx[i] - y_mn[i], 0);\n        }\n        for (int i = 1; i <= N; i++) {\n            add_edge(x_n[jewels[i].x], y_n[jewels[i].y], 1, jewels[i].v);\n        }\n        MCMF::main(S, T, flow, cost);\n        if (flow == 0) {\n            ans = max(ans, cost);\n        }\n        MCMF::clear();\n    }\n    printf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define db(x) cerr << #x << \"=\" << x << endl\n#define db2(x, y) cerr << #x << \"=\" << x << \",\" << #y << \"=\" << y << endl\n#define db3(x, y, z) cerr << #x << \"=\" << x << \",\" << #y << \"=\" << y << \",\" << #z << \"=\" << z << endl\n#define dbv(v) cerr << #v << \"=\"; for (auto _x : v) cerr << _x << \", \"; cerr << endl\n#define dba(a, n) cerr << #a << \"=\"; for (int _i = 0; _i < (n); ++_i) cerr << a[_i] << \", \"; cerr << endl\ntypedef long long ll;\ntypedef long double ld;\nstruct Mcmf {\n\tconst ll INFC = 1LL << 60;\n\tstruct Edge {\n\t\tint to;\n\t\tint f, cap;\n\t\tll cost;\n\t};\n\tint n, src, sink;\n\tvector<ll> pi, dist;\n\tvector<int> fromEdge;\n\tvector<Edge> edges;\n\tvector<vector<int>> G;\n\tMcmf(int _n, int _src = -1, int _sink = -1) : n(_n), src(_src), sink(_sink) {\n\t\tG.resize(n);\n\t\tdist.resize(n);\n\t\tpi.resize(n);\n\t\tfromEdge.resize(n);\n\t}\n\tvoid addEdge(int from, int to, int cap, ll cost) {\n\t\tG[from].push_back(edges.size());\n\t\tedges.push_back({to, 0, cap, cost});\n\t\tG[to].push_back(edges.size());\n\t\tedges.push_back({from, 0, 0, -cost});\n\t}\n\tll cheapestPath() {\n\t\ttypedef pair<ll, int> Pair;\n\t\tpriority_queue<Pair, vector<Pair>, greater<Pair>> pq;\n\t\tfill(dist.begin(), dist.begin() + n, INFC);\n\t\tdist[src] = 0;\n\t\tpq.emplace(dist[src], src);\n\t\twhile (!pq.empty()) {\n\t\t\tint u = pq.top().second;\n\t\t\tll cdist = pq.top().first;\n\t\t\tpq.pop();\n\t\t\tif (cdist > dist[u]) continue;\n\t\t\tfor (int x : G[u]) {\n\t\t\t\tEdge e = edges[x];\n\t\t\t\tif (e.f == e.cap) continue;\n\t\t\t\tint v = e.to;\n\t\t\t\t// assert pi[u], pi[v] <<< INFC\n\t\t\t\tll val = dist[u] + pi[u] - pi[v] + e.cost;\n\t\t\t\tif (val < dist[v]) {\n\t\t\t\t\tdist[v] = val;\n\t\t\t\t\tfromEdge[v] = x;\n\t\t\t\t\tpq.emplace(dist[v], v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dist[sink] >= INFC) return INFC;\n\t\tll cost = dist[sink] + pi[sink];\n\t\tfor (int k = 0; k < n; ++k)\n\t\t\tpi[k] = min(INFC, pi[k] + dist[k]);\n\t\treturn cost;\n\t}\n\tpair<ll, int> maxFlow() {\n\t\tll totcost = 0;\n\t\tint totflow = 0;\n\t\tfor (;;) {\n\t\t\tll cost = cheapestPath();\n\t\t\t// Change INFC to 0 to find min-cost flow (not maxflow)\n\t\t\t// Can prove that marginal-cost of flows increases (by exchange)\n\t\t\tif (cost >= INFC) break;\n\t\t\tint flow = INT_MAX;\n\t\t\tfor (int x = sink; x != src;) {\n\t\t\t\tint e = fromEdge[x];\n\t\t\t\tflow = min(flow, edges[e].cap - edges[e].f);\n\t\t\t\tx = edges[e ^ 1].to;\n\t\t\t}\n\t\t\tfor (int x = sink; x != src;) {\n\t\t\t\tint e = fromEdge[x];\n\t\t\t\tedges[e].f += flow;\n\t\t\t\tedges[e ^ 1].f -= flow;\n\t\t\t\tx = edges[e ^ 1].to;\n\t\t\t}\n\t\t\ttotcost += cost * flow;\n\t\t\ttotflow += flow;\n\t\t\t/* Inc one flow at a time\n\t\t\ttotcost += cost;\n\t\t\t++totflow;\n\t\t\tfor (int x = sink; x != src;) {\n\t\t\t\tint e = fromEdge[x];\n\t\t\t\t++edges[e].f;\n\t\t\t\t--edges[e ^ 1].f;\n\t\t\t\tx = edges[e ^ 1].to;\n\t\t\t}\n\t\t\t*/\n\t\t}\n\t\treturn {totcost, totflow};\n\t}\n\t// pi makes all edges nonnegative, so initialize if necessary\n\tvoid initPi() {\n\t\tfill(pi.begin(), pi.begin() + n, 0);\n\t}\n};\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tvector<int> x(n), y(n);\n\tvector<ll> v(n);\n\tfor (int i = 0; i < n; ++i) scanf(\"%d%d%lld\", &x[i], &y[i], &v[i]);\n\tint m;\n\tscanf(\"%d\", &m);\n\tvector<int> a(m), b(m);\n\tvector<char> t(m);\n\tfor (int i = 0; i < m; ++i) {\n\t\tscanf(\" %c%d%d\", &t[i], &a[i], &b[i]);\n\t}\n\tll ans = 0;\n\tconst ll OFFSET = 1e15;\n\tfor (int k = 1; k <= n; ++k) {\n\t\tint nodes = 2 + k * 2 + n * 2;\n\t\tMcmf g(nodes, 0, nodes - 1);\n\t\tauto add = [&](int vs, char l, char r, vector<int>& coord) {\n\t\t\tvector<int> L(k + 1, 1), R(k + 1, 100);\n\t\t\tfor (int i = 0; i < m; ++i) {\n\t\t\t\tif (b[i] >= k) continue;\n\t\t\t\tif (t[i] == l) {\n\t\t\t\t\tL[b[i] + 1] = max(L[b[i] + 1], a[i] + 1);\n\t\t\t\t} else if (t[i] == r) {\n\t\t\t\t\tR[k - b[i]] = min(R[k - b[i]], a[i] - 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 1; i < k; ++i) {\n\t\t\t\tL[i + 1] = max(L[i], L[i + 1]);\n\t\t\t}\n\t\t\tfor (int i = k - 1; i >= 1; --i) {\n\t\t\t\tR[i] = min(R[i], R[i + 1]);\n\t\t\t}\n\t\t\tfor (int i = 1; i <= k; ++i) {\n\t\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\t\tif (coord[j] >= L[i] && coord[j] <= R[i]) {\n\t\t\t\t\t\tif (l == 'L') g.addEdge(i + vs, j + 1, 1, 0);\n\t\t\t\t\t\telse g.addEdge(j + n + 1, i + vs, 1, 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tadd(2 * n, 'L', 'R', x);\n\t\tadd(2 * n + k, 'D', 'U', y);\n\t\tfor (int i = 1; i <= k; ++i) {\n\t\t\tg.addEdge(g.src, i + 2 * n, 1, 0);\n\t\t\tg.addEdge(i + 2 * n + k, g.sink, 1, 0);\n\t\t}\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tg.addEdge(i + 1, i + n + 1, 1, OFFSET - v[i]);\n\t\t}\n\t\tauto ret = g.maxFlow();\n\t\tif (ret.second == k) {\n\t\t\tans = max(ans, k * OFFSET - ret.first);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<double, double> pdd;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\n//const int mod = ;\n\nstruct J {\n  int x, y, ind;\n  ll cost;\n};\n\nvi dx(100, 100), ux(100, 100), dy(100, 100), uy(100, 100);\nvector<J> v;\nvi best;\nll best_score = 0;\n\nll eval(const vi& x) {\n  ll score = 0;\n  for (int i = 0; i < v.size(); ++i) score += v[i].cost * x[i];\n  return score;\n}\n\nvoid update(const vi& x) {\n  ll score = eval(x);\n  if (score > best_score) {\n    best = x;\n    best_score = score;\n  }\n}\n\nint tmpx[100], tmpy[100];\nbool valid_add(int ind, const vi& x) {\n  memset(tmpx, 0, sizeof(tmpx));\n  memset(tmpy, 0, sizeof(tmpy));\n  for (int i = 0; i < x.size(); ++i) if (x[i] || i == ind) {\n    tmpx[v[i].x]++;\n    tmpy[v[i].y]++;\n  }\n  int sx = 0;\n  for (int i = 0; i < 100; ++i) {\n    sx += tmpx[i];\n    if (sx > dx[i]) return false;\n  }\n  sx = 0;\n  for (int i = 99; i >= 0; --i) {\n    sx += tmpx[i];\n    if (sx > ux[i]) return false;\n  }\n  int sy = 0;\n  for (int i = 0; i < 100; ++i) {\n    sy += tmpy[i];\n    if (sy > dy[i]) return false;\n  }\n  sy = 0;\n  for (int i = 99; i >= 0; --i) {\n    sy += tmpy[i];\n    if (sy > uy[i]) return false;\n  }\n  return true;\n}\n\nvoid f(vi x) {\n  ll score = eval(x);\n  for (int t = 0; t < 10; ++t) {\n    ll s0 = score;\n    for (int i = 0; i < x.size(); ++i) if (x[i]) {\n      vi y = x;\n      y[i] = 0;\n      if (t % 2) {\n        for (int j = 0; j < x.size(); ++j) if (j != i) {\n          if (valid_add(j, y)) {\n            y[j] = 1;\n          }\n        }\n      } else {\n        for (int j = x.size() - 1; j >= 0; --j) if (j != i) {\n          if (valid_add(j, y)) {\n            y[j] = 1;\n          }\n        }\n      }\n      ll cand = eval(y);\n      if (cand > score) {\n        score = cand;\n        x = y;\n      }\n    }\n    for (int i = 0; i < x.size(); ++i) if (x[i]) for (int i1 = i + 1; i1 < x.size(); ++i1) if (x[i1]) {\n      vi y = x;\n      y[i] = y[i1] = 0;\n      if (t % 2) {\n        for (int j = 0; j < x.size(); ++j) if (j != i && j != i1) {\n          if (valid_add(j, y)) {\n            y[j] = 1;\n          }\n        }\n      } else {\n        for (int j = x.size() - 1; j >= 0; --j) if (j != i && j != i1) {\n          if (valid_add(j, y)) {\n            y[j] = 1;\n          }\n        }\n      }\n      ll cand = eval(y);\n      if (cand > score) {\n        score = cand;\n        x = y;\n      }\n    }\n    if (score == s0) break;\n  }\n  update(x);\n}\n\nvoid greedy(int type) {\n  vector<J> ts = v;\n  if (type == 0) {\n    sort(ts.rbegin(), ts.rend(), [&](const auto& a, const auto& b){return a.cost < b.cost;});\n  } else if (type > 0) {\n    vd mulx(v.size(), 1e-10), muly(v.size(), 1e-10);\n    vd mul(v.size());\n    for (int i = 0; i < v.size(); ++i) {\n      for (int x = v[i].x; x < 100; ++x) if (ux[x] != 100) {\n        mulx[i] += 1. / ux[x];\n      }\n      for (int x = 0; x <= v[i].x; ++x) if (dx[x] != 100) {\n        mulx[i] += 1. / dx[x];\n      }\n      for (int y = v[i].y; y < 100; ++y) if (uy[y] != 100) {\n        muly[i] += 1. / uy[y];\n      }\n      for (int y = 0; y <= v[i].y; ++y) if (dy[y] != 100) {\n        muly[i] += 1. / dy[y];\n      }\n      if (type == 1) {\n        mul[i] = 1. / (mulx[i] + muly[i]);\n      } else if (type == 2) {\n        mul[i] = 1. / (mulx[i]);\n      } else if (type == 3) {\n        mul[i] = 1. / (muly[i]);\n      } else if (type == 5) {\n        mul[i] = 1. / sqrt(mulx[i] + muly[i]);\n      }\n    }\n    sort(ts.rbegin(), ts.rend(), [&](const auto& a, const auto& b){return a.cost * mul[a.ind] < b.cost * mul[b.ind];});\n  } else {\n    random_shuffle(ts.begin(), ts.end());\n  }\n  vi x(v.size());\n  for (int i = 0; i < ts.size(); ++i) {\n    int ind = ts[i].ind;\n    if (valid_add(ind, x)) {\n//      cerr << ind << endl;\n      x[ind] = 1;\n    }\n  }\n  f(x);\n//  update(x);\n}\n\nint main() {\n  std::ios::sync_with_stdio(false); std::cin.tie(0);\n  int n;\n  cin >> n;\n  v.resize(n);\n  for (int i = 0; i < n; ++i) {\n    cin >> v[i].x >> v[i].y >> v[i].cost;\n    --v[i].x; --v[i].y;\n    v[i].ind = i;\n  }\n  int m;\n  cin >> m;\n  for (int i = 0; i < m; ++i) {\n    string t;\n    int a, b;\n    cin >> t >> a >> b;\n    --a;\n    if (t == \"L\") {\n      dx[a] = b;\n    }\n    if (t == \"R\") {\n      ux[a] = b;\n    }\n    if (t == \"D\") {\n      dy[a] = b;\n    }\n    if (t == \"U\") {\n      uy[a] = b;\n    }\n  }\n  for (int t = 0; t < 6; ++t) {\n    greedy(t);\n  }\n  for (int t = 0; t < 20; ++t) {\n    greedy(-1);\n  }\n  cout << best_score << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define ll long long\n#define inf 0x3f3f3f3f3f3f3f3f\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\nchar buf[1<<21],*p1=buf,*p2=buf;\ninline char getc(){return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;}\nll read(){\n    R ll res,f=1;R char ch;\n    while((ch=getc())>'9'||ch<'0')(ch=='-')&&(f=-1);\n    for(res=ch-'0';(ch=getc())>='0'&&ch<='9';res=res*10+ch-'0');\n    return res*f;\n}\ninline char getop(){R char ch;while((ch=getc())>'Z'||ch<'A');return ch;}\nconst int N=505;\nstruct eg{int v,nx,w;ll c;}e[N*N];int head[N],tot;\ninline void add(R int u,R int v,R ll c){\n\te[++tot]={v,head[u],1,c},head[u]=tot,\n\te[++tot]={u,head[v],0,-c},head[v]=tot;\n}\nint x[N],y[N],a[N],b[N],t[N],LL[N],RR[N],DD[N],UU[N],vis[N],pe[N],n,m,S,T;\nll v[N],dis[N],res,ans;queue<int>q;\nbool spfa(){\n\tmemset(dis,0x3f,sizeof(dis));\n\tdis[S]=0,q.push(S);\n\twhile(!q.empty()){\n\t\tint u=q.front();q.pop(),vis[u]=0;\n\t\tgo(u)if(e[i].w&&(cmin(dis[v],dis[u]+e[i].c)?pe[v]=i,1:0)&&!vis[v])q.push(v),vis[v]=1;\n\t}\n\tif(dis[T]==inf)return false;\n\tres+=dis[T];\n\tfor(R int i=T;i!=S;i=e[pe[i]^1].v)--e[pe[i]].w,++e[pe[i]^1].w;\n\treturn true;\n}\nll calc(int k){\n\tfp(i,1,k)LL[i]=DD[i]=0,RR[i]=UU[i]=19260817;\n\tfp(i,1,m)if(b[i]<k){\n\t\tswitch(t[i]){\n\t\t\tcase 'L':LL[b[i]+1]=a[i]+1;break;\n\t\t\tcase 'R':RR[k-b[i]]=a[i]-1;break;\n\t\t\tcase 'D':DD[b[i]+1]=a[i]+1;break;\n\t\t\tcase 'U':UU[k-b[i]]=a[i]-1;break;\n\t\t}\n\t}\n\tfp(i,2,k)cmax(LL[i],LL[i-1]),cmax(DD[i],DD[i-1]);\n\tfd(i,k-1,1)cmin(RR[i],RR[i+1]),cmin(UU[i],UU[i+1]);\n\tmemset(head,0,sizeof(head)),tot=1;\n\tS=0,T=(n+k)<<1|1;\n\tfp(i,1,n)add(i,n+i,-v[i]-1000000000000000ll);\n\tfp(i,1,k){\n\t\tadd(S,n+n+i,0),add(n+n+k+i,T,0);\n\t\tfp(j,1,n){\n\t\t\tif(x[j]>=LL[i]&&x[j]<=RR[i])add(n+n+i,j,0);\n\t\t\tif(y[j]>=DD[i]&&y[j]<=UU[i])add(n+j,n+n+k+i,0);\n\t\t}\n\t}\n\tres=0;while(spfa());\n\treturn -res-k*1000000000000000ll;\n}\nint main(){\n//\tfreopen(\"testdata.in\",\"r\",stdin);\n\tn=read();\n\tfp(i,1,n)x[i]=read(),y[i]=read(),v[i]=read();\n\tm=read();\n\tfp(i,1,m)t[i]=getop(),a[i]=read(),b[i]=read();\n\tfp(i,1,n)cmax(ans,calc(i));\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#define lop(c,l) for(int c=1;c<=(l);++c)\n#define loop(c,l) for(int c=0;c<(l);++c)\nusing namespace std;\n\n#define int long long\n#define double long double\n#define inf 1e14\n#define eps 1e-14\ntemplate<int Vari,int Crat>\nstruct algo_simplex{\n\tdouble matrix[Crat+1][Vari+1],ans[Vari+1];\n\tint id[Crat<<1|1];\n\tint vari,crat,target;\n\tvoid pivot(const int& l,const int& e){\n\t\tswap(id[vari+l],id[e]);\n\t\tdouble t=matrix[l][e];\n\t\tmatrix[l][e]=1;\n\t\tfor(int j=0;j<=vari;j++) matrix[l][j]/=t;\n\t\tfor(int i=0;i<=crat;i++) if(i!=l&&abs(matrix[i][e])>eps){\n\t\t\tt=matrix[i][e];\n\t\t\tmatrix[i][e]=0;\n\t\t\tfor(int j=0;j<=vari;j++) matrix[i][j]-=matrix[l][j]*t;\n\t\t}\n\t}\n\tbool init(){\n\t\twhile(1){\n\t\t\tint l=0,e=0;\n\t\t\tfor(int i=1;i<=crat;i++) if(matrix[i][0]<-eps&&(!l||(rand()&1))) l=i;\n\t\t\tif(!l) return 1;\n\t\t\tfor(int j=1;j<=vari;j++) if(matrix[l][j]<-eps&&(!e||(rand()&1))) e=j;\n\t\t\tif(!e) return 0;\n\t\t\tpivot(l,e);\n\t\t}\n\t}\n\tbool funct(const int& v,const int& c){\n\t\tsrand(new int()-(int*)NULL);\n\t\tvari=v,crat=c;\n\t\tfor(int i=1;i<=vari;i++) id[i]=i;\n\t\tif(!init())\treturn 0;\n\t\twhile(1){\n\t\t\tint l=0,e=0,minn=inf;\n\t\t\tfor(int j=1;j<=vari&&!e;j++) if(matrix[0][j]>eps) e=j;\n\t\t\tif(!e) break;\n\t\t\tfor(int i=1;i<=crat;i++) if(matrix[i][e]>eps&&matrix[i][0]/matrix[i][e]<minn) minn=matrix[i][0]/matrix[i][e],l=i;\n\t\t\tif(!l) return 0;\n\t\t\tpivot(l,e);\n\t\t}\n\t\ttarget=-matrix[0][0];\n\t\tfor(int i=1;i<=crat;i++) ans[id[vari+i]]=matrix[i][0];\n\t\treturn 1;\n\t}\n};\nalgo_simplex<80,400> spl;\nstruct loc{\n\tint x,y,v;\n}p[81];\nint n,m,ll,lim,ans;\nchar ch;\nsigned main(signed,char**,char**){\n\tscanf(\"%lld\",&n);\n\tlop(i,n){\n\t\tscanf(\"%lld%lld%lld\",&p[i].x,&p[i].y,&p[i].v);\n\t\tspl.matrix[0][i]=p[i].v;\n\t}\n\tscanf(\"%lld\",&m);\n\tlop(i,m){\n\t\tscanf(\" %c%lld%lld\",&ch,&ll,&lim);\n\t\tswitch(ch){\n\t\t\tcase 'L':{\n\t\t\t\tlop(j,n) if(p[j].x<=ll) spl.matrix[i][j]=1;\n\t\t\t\tspl.matrix[i][0]=lim;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'R':{\n\t\t\t\tlop(j,n) if(p[j].x>=ll) spl.matrix[i][j]=1;\n\t\t\t\tspl.matrix[i][0]=lim;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'D':{\n\t\t\t\tlop(j,n) if(p[j].y<=ll) spl.matrix[i][j]=1;\n\t\t\t\tspl.matrix[i][0]=lim;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'U':{\n\t\t\t\tlop(j,n) if(p[j].y>=ll) spl.matrix[i][j]=1;\n\t\t\t\tspl.matrix[i][0]=lim;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tlop(i,n) spl.matrix[m+i][i]=1,spl.matrix[m+i][0]=1;\n\tspl.funct(n,m+n);\n\tlop(i,n) if(spl.ans[i]) ans+=p[i].v;\n\tprintf(\"%lld\",ans);\n\texit(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nostream &operator<<(ostream &os, __float128 f) { return os << (LD)f; }\n\n\nstruct Simplex {        // Maximize c*x subject to Ax <= b.\n  using T = LD;         // Initialize the structure, set A, b, c and then run\n  vector<vector<T>> A;  // solve(). Max objective is stored in res. To recover\n  vector<T> b, c;       // the best result, use getVars().\n  T abs(T x) { return x < 0 ? -x : x; }\n\n  int V, E;\n  VI eqIds, varIds, cols;\n  T res;\n  const LD kEps = 1e-9;\n\n  Simplex(int vars, int eqs) : A(eqs, vector<T>(vars)), b(eqs), c(vars),\n                               V(vars), E(eqs), eqIds(eqs), varIds(vars), res(0) {\n    iota(ALL(varIds), 0); iota(ALL(eqIds), vars);\n  }\n\n  void pivot(int eq, int var) {\n    T coef = 1 / A[eq][var];\n    cols.clear();\n    REP (i, V) {\n      if (abs(A[eq][i]) > kEps) { cols.PB(i); A[eq][i] *= coef; }\n    }\n    A[eq][var] *= coef; b[eq] *= coef;\n    REP (row, E) {\n      if (row == eq || abs(A[row][var]) < kEps) { continue; }\n      T k = -A[row][var];\n      A[row][var] = 0;\n      for (int i : cols) { A[row][i] += k * A[eq][i]; }\n      b[row] += k * b[eq];\n    }\n    T q = c[var]; c[var] = 0;\n    for (int i : cols) { c[i] -= q * A[eq][i]; }\n    res += q * b[eq];\n\n    swap(varIds[var], eqIds[eq]);\n  }\n  \n  bool solve() {\n    while (true) {\n      int eq = -1, var = -1;\n      REP (i, E) { if (b[i] < -kEps) { eq = i; break; } }\n      if (eq == -1) { break; }\n      REP (i, V) { if (A[eq][i] < -kEps) { var = i; break; } }\n      if (var == -1) { res = -1e9; return false; /* No solution */ }\n      pivot(eq, var);\n    }\n\n    while (true) {\n      int var = -1, eq = -1;\n      REP (i, V) { if (c[i] > kEps) { var = i; break; } }\n      if (var == -1) { break; }\n      REP (i, E) {\n        if (A[i][var] < kEps) { continue; }\n        if (eq >= 0 && b[i] / A[i][var] >= b[eq] / A[eq][var]) { continue; }\n        eq = i;\n      }\n      if (eq == -1) { res = 1e9; return false; /* Unbounded */ }\n      pivot(eq, var);\n    }\n\n    return true;\n  }\n  \n  vector<T> getVars() {  // Optimal assignment of variables.\n    vector<T> result(V);\n    REP (i, E) { if (eqIds[i] < V) { result[eqIds[i]] = b[i]; } }\n    return result;\n  }\n};\n\nint N, M;\nvector<PII> points;\nVI point_vals;\n\nLL low_bound;\nclock_t time_start;\n\nvoid Solve(Simplex sim) {\n  Simplex sim_copy = sim;\n  assert(sim.solve());\n\n  if (sim.res - 1e-9 < low_bound) { return; }\n  auto vars = sim.getVars();\n\n  if ((clock() - time_start) > 4.9 * CLOCKS_PER_SEC) {\n    cout << low_bound << \"\\n\";\n    exit(0);\n  }\n\n  LL my_low = 0;\n  for (int i = 0; i < N; ++i) {\n    if (vars[i] > .99) {\n      my_low += point_vals[i];\n      //sim_copy.b[M + i * 2] = -1;\n    }\n  }\n\n  maxi(low_bound, my_low);\n  bool had_any = false;\n  for (int i = 0; i < N; ++i) {\n    if (vars[i] > .01 && vars[i] < .989) {\n      had_any = true;\n    }\n  }\n\n  if (had_any) {\n    // take none?\n    for (int i = 0; i < N; ++i) {\n      if (vars[i] > .01 && vars[i] < .989) {\n        sim_copy.b[M + i * 2 + 1] = 0;\n      }\n    }\n    Solve(sim_copy);\n    for (int i = 0; i < N; ++i) {\n      if (vars[i] > .01 && vars[i] < .989) {\n        sim_copy.b[M + i * 2 + 1] = 1;\n      }\n    }\n  }\n\n  for (int i = 0; i < N; ++i) {\n    if (vars[i] > .01 && vars[i] < .989) {\n      // take?\n      sim_copy.b[M + i * 2] = -1;\n      Solve(sim_copy);\n      sim_copy.b[M + i * 2] = 0;\n      if (sim.res - 1e-9 < low_bound) { return; }\n    }\n  }\n\n}\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n  time_start = clock();\n\n  cin >> N;\n  points.resize(N);\n  point_vals.resize(N);\n\n  for (int i = 0; i < N; ++i) {\n    cin >> points[i].st >> points[i].nd >> point_vals[i];\n  }\n\n  map<char, function<bool(PII, int)>> checkers = {\n    {'L', [](const PII &pt, int a) { return pt.st <= a; }},\n    {'R', [](const PII &pt, int a) { return pt.st >= a; }},\n    {'D', [](const PII &pt, int a) { return pt.nd <= a; }},\n    {'U', [](const PII &pt, int a) { return pt.nd >= a; }}\n  };\n\n  cin >> M;\n\n  Simplex sim(N, M + 2 * N);\n  for (int i = 0; i < M; ++i) {\n    char type;\n    int a, b;\n    cin >> type >> a >> b;\n\n    for (int j = 0; j < N; ++j) {\n      sim.A[i][j] = checkers[type](points[j], a);\n    }\n    sim.b[i] = b;\n\n    debug(sim.A[i], sim.b[i]);\n  }\n  for (int i = 0; i < N; ++i) {\n    sim.c[i] = point_vals[i];\n    sim.A[M + i * 2][i] = -1;\n    sim.A[M + i * 2 + 1][i] = 1;\n    sim.b[M + i * 2] = 0;\n    sim.b[M + i * 2 + 1] = 1;\n  }\n  auto orig_a = sim.A;\n  auto orig_b = sim.b;\n\n  Solve(sim);\n  cout << low_bound << \"\\n\";\n\n  /*assert(sim.solve());\n  auto vars = sim.getVars();\n\n  vector<int> always, maybe;\n  debug(vars);\n  for (int i = 0; i < N; ++i) {\n    if (vars[i] > 0.7) {\n      always.PB(i);\n    } else if (vars[i] > 0.3) {\n      maybe.PB(i);\n    }\n  }\n\n  debug(always, maybe);\n\n  assert(SZ(maybe) <= 3);\n  LL ans = -1;\n\n  for (LL m = 0; m < (1LL << SZ(maybe)); ++m) {\n    vector<int> mine = always;\n    for (int j = 0; j < SZ(maybe); ++j) {\n      if ((m >> j) & 1) { mine.PB(maybe[j]); }\n    }\n\n    bool fail = false;\n    for (int i = 0; i < M; ++i) {\n      int cnt = 0;\n      for (int j : mine) {\n        if (orig_a[i][j] > 0.5) { ++cnt; }\n      }\n      debug(mine, i, cnt, orig_b[i]);\n      if (cnt > (int)round((LD)orig_b[i])) { debug(i); fail = true; }\n    }\n\n    if (fail) { continue; }\n    LL x = 0;\n    for (int i : mine) {\n      x += point_vals[i];\n    }\n    maxi(ans, x);\n  }\n\n  cout << ans << \"\\n\";*/\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<iomanip>\n#include<ctime>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#define sqr(x) ((x)*(x))\n#define fz1(i,n) for ((i)=1;(i)<=(n);(i)++)\n#define fd1(i,n) for ((i)=(n);(i)>=1;(i)--)\n#define fz0g(i,n) for ((i)=0;(i)<=(n);(i)++)\n#define fd0g(i,n) for ((i)=(n);(i)>=0;(i)--)\n#define fz0k(i,n) for ((i)=0;(i)<(n);(i)++)\n#define fd0k(i,n) for ((i)=(long long)((n)-1);(i)>=0;(i)--)\n#define fz(i,x,y) for ((i)=(x);(i)<=(y);(i)++)\n#define fd(i,y,x) for ((i)=(y);(i)>=(x);(i)--)\n#define fzin fz1(i,n)\n#define fzim fz1(i,m)\n#define fzjn fz1(j,n)\n#define fzjm fz1(j,m)\n#define ff(c,itr) for (__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n#define rdst(st,len){static char ss[len];scanf(\" %s\",ss);(st)=ss;}\n//#define T_ long long\nusing namespace std;\n//struct bit{T_ arr[1000005];long long lowbit(long long x){return x&(-x);}void add(long long x,T_ y){for (long long i=x;i<=n;i+=lowbit(i)) arr[i]+=y;}T_ query(long long x){T_ s=0;for (long long i=x;i>0;i-=lowbit(i)) s+=arr[i];return s;}};\n//struct seg{struct treedot{long long l,r;T_ sum,add;void update(T_ x){sum+=(r-l+1)*x; add+=x;}}c[800005];void pushdown(long long id){if (c[id].add){c[id*2].update(c[id].add);c[id*2+1].update(c[id].add);c[id].add=0;}}void pushup(long long id){c[id].sum=c[id*2].sum+c[id*2+1].sum;}void build(long long id,long long l,long long r){if (l>r) return;c[id].l=l;c[id].r=r;c[id].sum=0;c[id].add=0;if (l==r) c[id].sum=0;else{long long mid=l+(r-l)/2;build(id*2,l,mid);build(id*2+1,mid+1,r);pushup(id);}}void update(long long id,long long le,long long ri,T_ x){if (le>c[id].r||ri<c[id].l) return;if (le<=c[id].l&&c[id].r<=ri) c[id].update(x);else{pushdown(id);update(id*2,le,ri,x);update(id*2+1,le,ri,x);pushup(id);}}T_ query(long long id,long long le,long long ri){if (ri<c[id].l||c[id].r<le) return 0;if (le<=c[id].l&&c[id].r<=ri) return c[id].sum;T_ ans=0;pushdown(id);ans+=query(id*2,le,ri);ans+=query(id*2+1,le,ri);pushup(id);return ans;}};\n//struct bit_2d{T_ a[2005][2005];long long lowbit(long long x){return x&(-x);}void add(long long x,long long y,T_ z){long long i,j;for (i=x;i<=2000;i+=lowbit(i)){for (j=y;j<=2000;j+=lowbit(j)){a[i][j]+=z;}}}T_ query(long long x,long long y){long long i,j;T_ s=0;for (i=x;i;i-=lowbit(i)){for (j=y;j;j-=lowbit(j)){s+=a[i][j];}}return s;}T_ query(long long x,long long y,long long xx,long long yy){return query(xx,yy)-query(x-1,yy)-query(xx,y-1)+query(x-1,y-1);}};\nlong long n,m,i,j,k,dis[325],cnt,a[325],b[325],v[325],s=0,t=321,l[325],r[325],u[325],d[325],x,y,cst,inq[325],vis[325],ans;\nvector<long long> allx,ally;\nchar c[325],ca[325],cb[325];\nstruct ii\n{\n\tlong long y,z,d;\n}e[1000005];\nvector<long long> bi[10005];\nvoid init()\n{\n\tint i;fz0g(i,321) bi[i].clear();cnt=0;\n}\nvoid add(long long x,long long y,long long z,long long d)\n{\n\tcnt++;bi[x].push_back(cnt*2-2);bi[y].push_back(cnt*2-1);\n\te[cnt*2-2]=(ii){y,z,d};e[cnt*2-1]=(ii){x,0,-d};\n}\nbool bfs(long long s,long long t)\n{\n\tmemset(dis,-0x18,sizeof(dis));dis[s]=0;queue<long long> qx;qx.push(s);inq[s]=1;\n\twhile (!qx.empty()){\n\t\tlong long x=qx.front();qx.pop();inq[x]=0;ff(bi[x],it) if (e[*it].z){\n\t\t\tlong long y=e[*it].y,z=dis[x]+e[*it].d;\n\t\t\tif (dis[y]<z){\n\t\t\t\tdis[y]=z;\n\t\t\t\tif (!inq[y]){\n\t\t\t\t\tinq[y]=1;qx.push(y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}return dis[t]>dis[324];\n}\nlong long dfs(long long x,long long tt,long long flw)\n{\n\tif (x==tt) vis[tt]=1;\n\tif (x==tt||!flw) return flw;if (vis[x])return 0;vis[x]=1;long long ans=0;ff(bi[x],it) if (e[*it].z&&dis[e[*it].y]==dis[x]+e[*it].d){\n\t\tlong long t=dfs(e[*it].y,tt,min(flw,e[*it].z));cst+=t*e[*it].d;ans+=t;flw-=t;e[*it].z-=t;e[(*it)^1].z+=t;if (!flw) break;\n\t}return ans;\n}\nbool dinic(long long s,long long t,long long aa)\n{\n\tlong long ans=0;while (bfs(s,t)){\n\t\tdo{\n\t\t\tmemset(vis,0,sizeof(vis));\n\t\t\tans+=dfs(s,t,aa);\n\t\t}while (vis[t]);\n\t}if (ans==aa) return 1;return 0;\n}\nint main()\n{\n\tscanf(\"%lld\",&n);\n\tfz1(i,n){\n\t\tscanf(\"%lld%lld%lld\",&a[i],&b[i],&v[i]);\n//\t\tallx.push_back(a[i]);ally.push_back(b[i]);\n\t}//sort(allx.begin(),allx.end());allx.resize(unique(allx.begin(),allx.end())-allx.begin());sort(ally.begin(),ally.end());ally.resize(unique(ally.begin(),ally.end())-ally.begin());\n\t/*fz1(i,n){\n\t\ta[i]=upper_bound(allx.begin(),allx.end(),a[i])-allx.begin();\n\t\tb[i]=upper_bound(ally.begin(),ally.end(),b[i])-ally.begin();\n\t}*/\n\tscanf(\"%lld\",&m);fz1(i,m){\n\t\tscanf(\" %c%lld%lld\",&c[i],&ca[i],&cb[i]);\n\t}\n\tans=0;\n\tfz1(i,n){\n\t\tcst=0;init();\n\t\tfz1(j,i){\n\t\t\tl[i]=d[i]=0;\n\t\t\tr[i]=u[i]=0x1818181818181818ll;\n\t\t}\n\t\tfz1(j,m) if (cb[j]<i){\n\t\t\tif (c[j]=='L') l[cb[j]+1]=max(l[cb[j]+1],ca[j]+1ll);\n\t\t\tif (c[j]=='R') r[i-cb[j]]=min(r[i-cb[j]],ca[j]-1ll);\n\t\t\tif (c[j]=='D') d[cb[j]+1]=max(d[cb[j]+1],ca[j]+1ll);\n\t\t\tif (c[j]=='U') u[i-cb[j]]=min(u[i-cb[j]],ca[j]-1ll);\n\t\t}\n\t\tfz(j,2,i){\n\t\t\tl[j]=max(l[j],l[j-1]);\n\t\t\td[j]=max(d[j],d[j-1]);\n\t\t}\n\t\tfd(j,i-1,1){\n\t\t\tr[j]=min(r[j],r[j+1]);\n\t\t\tu[j]=min(u[j],u[j+1]);\n\t\t}\n\t\tfz1(j,i)fz1(k,n){\n\t\t\tif (l[j]<=a[k]&&a[k]<=r[j]){\n\t\t\t\tadd(j,n+k,1,0);\n\t\t\t}\n\t\t\tif (d[j]<=b[k]&&b[k]<=u[j]){\n\t\t\t\tadd(n+n+k,n+n+n+j,1,0);\n\t\t\t}\n\t\t}\n\t\tfz1(j,i){\n\t\t\tadd(s,j,1,0);add(n+n+n+j,t,1,0);\n\t\t}fz1(j,n){\n\t\t\tadd(j+n,j+n+n,1,v[j]);\n\t\t}if (dinic(s,t,i)) ans=max(ans,cst);\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Created by Nikolay Budin\n\n#ifdef LOCAL\n#  define _GLIBCXX_DEBUG\n#else\n#  define cerr __get_ce\n#endif\n#include <bits/stdc++.h>\n#define ff first\n#define ss second\n#define szof(x) ((int)x.size())\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef unsigned long long ull;\nint const INF = (int)1e9 + 1e3;\nll const INFL = (ll)1e18 + 1e6;\n#ifdef LOCAL\n\tmt19937 tw(9450189);\n#else\n\tmt19937 tw(chrono::high_resolution_clock::now().time_since_epoch().count());\n#endif\nuniform_int_distribution<ll> ll_distr;\nll rnd(ll a, ll b) { return ll_distr(tw) % (b - a + 1) + a; }\n\nconst long double eps = 1e-9;\n\nbool eq(long double a, long double b) {\n\treturn abs(a - b) < eps;\n}\n\nbool ls(long double a, long double b) {\n\treturn a + eps < b;\n}\n\nvector<long double> simplex(vector<vector<long double> > a) {\n    int n = a.size() - 1;\n    int m = a[0].size() - 1;\n    vector<int> left(n + 1), up(m + 1);\n    iota(up.begin(), up.end(), 0);\n    iota(left.begin(), left.end(), m);\n    auto pivot = [&](int x, int y) {\n        swap(left[x], up[y]);\n        long double k = a[x][y];\n        a[x][y] = 1;\n        vector<int> vct;\n        for (int j = 0; j <= m; j++) {\n            a[x][j] /= k;\n            if (!eq(a[x][j], 0)) vct.push_back(j);\n        }\n        for (int i = 0; i <= n; i++) {\n            if (eq(a[i][y], 0) || i == x) continue;\n            k = a[i][y];\n            a[i][y] = 0;\n            for (int j : vct) a[i][j] -= k * a[x][j];\n        }\n    };\n    while (1) {\n        int x = -1;\n        for (int i = 1; i <= n; i++) if (ls(a[i][0], 0) && (x == -1 || a[i][0] < a[x][0])) x = i;\n        if (x == -1) break;\n        int y = -1;\n        for (int j = 1; j <= m; j++) if (ls(a[x][j], 0) && (y == -1 || a[x][j] < a[x][y])) y = j;\n        if (y == -1) assert(0); // infeasible\n        pivot(x, y);\n    }\n    while (1) {\n        int y = -1;\n        for (int j = 1; j <= m; j++) if (ls(0, a[0][j]) && (y == -1 || a[0][j] > a[0][y])) y = j;\n        if (y == -1) break;\n        int x = -1;\n        for (int i = 1; i <= n; i++) if (ls(0, a[i][y]) && (x == -1 || a[i][0] / a[i][y] < a[x][0] / a[x][y])) x = i;\n        if (x == -1) assert(0); // unbounded\n        pivot(x, y);\n    }\n    vector<long double> ans(m + 1);\n    for (int i = 1; i <= n; i++) if (left[i] <= m) ans[left[i]] = a[i][0];\n    ans[0] = -a[0][0];\n    return ans;\n}\n// j=1..m: x[j]>=0\n// i=1..n: sum(j=1..m) A[i][j]*x[j] <= A[i][0]\n// max sum(j=1..m) A[0][j]*x[j]\n// res[0] is answer\n// res[1..m] is certificate\n\nvoid solve() {\n\tint n;\n\tcin >> n;\n\tvector<vector<long double>> matr;\n\tvector<pii> coords;\n\tmatr.push_back(vector<long double>(n + 1));\n\tfor (int i = 0; i < n; ++i) {\n\t\tint x, y;\n\t\tll w;\n\t\tcin >> x >> y >> w;\n\t\tmatr[0][i + 1] = w;\n\t\tcoords.push_back({x, y});\n\t\tmatr.push_back(vector<long double>(n + 1));\n\t\tmatr.back()[0] = 1;\n\t\tmatr.back()[i + 1] = 1;\n\t}\n\n\tint m;\n\tcin >> m;\n\tfor (int i = 0; i < m; ++i) {\n\t\tchar t;\n\t\tint a, b;\n\t\tcin >> t >> a >> b;\n\t\tmatr.push_back(vector<long double>(n + 1));\n\t\tmatr.back()[0] = b;\n\t\tif (t == 'L') {\n\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\tif (coords[j].ff <= a) {\n\t\t\t\t\tmatr.back()[j + 1] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (t == 'R') {\n\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\tif (coords[j].ff >= a) {\n\t\t\t\t\tmatr.back()[j + 1] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (t == 'D') {\n\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\tif (coords[j].ss <= a) {\n\t\t\t\t\tmatr.back()[j + 1] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (t == 'U') {\n\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\tif (coords[j].ss >= a) {\n\t\t\t\t\tmatr.back()[j + 1] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tauto res = simplex(matr);\n\tcout << (ll) round(res[0]) << \"\\n\";\n}\n\n\nint main() {\n#ifdef LOCAL\n\tauto start_time = clock();\n\tcerr << setprecision(3) << fixed;\n#endif\n\tcout << setprecision(15) << fixed;\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\n\tint test_count = 1;\n\t// cin >> test_count;\n\tfor (int test = 1; test <= test_count; ++test) {\n\t\tsolve();\n\t}\n\t\n#ifdef LOCAL\n\tauto end_time = clock();\n\tcerr << \"Execution time: \" << (end_time - start_time) * (int)1e3 / CLOCKS_PER_SEC << \" ms\\n\";\n#endif\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define R register\n#define ll long long\n#define INF 333222111666555444ll\n#define cmin(_A, _B) (_A > _B) ? (_A = _B) : 0\n#define cmax(_A, _B) (_A < _B) ? (_A = _B) : 0\n#define MIN(_A, _B) (((_A) < (_B)) ? (_A) : (_B))\n#define MAX(_A, _B) (((_A) > (_B)) ? (_A) : (_B))\n\nint n, m;\n\nstruct Point{\n\tint x, y;\n\tll v;\n}p[88];\n\nstruct Opt{\n\tchar op;\n\tint a, b;\n}d[333];\n\n\nstruct Flow{\n\tint cnt;\n\tint cntp;\n\tint S, T;\n\tint fr[333];\n\tint cur[333];\n\tint ne[66666];\n\tint to[66666];\n\tint c[66666];\n\tll w[66666];\n\t\n\tvoid add(R int a, R int b, R int v, R ll co){\n//\t\tprintf(\"%d %d %d %lld\\n\", a, b, v, co);\n\t\tne[++cnt] = fr[a], fr[a] = cnt, to[cnt] = b, c[cnt] = v, w[cnt] = co;\n\t\tne[++cnt] = fr[b], fr[b] = cnt, to[cnt] = a, c[cnt] = 0, w[cnt] = -co;\n\t}\n\t\n\tll dis[333];\n\tbool vis[333];\n\tint q[66666];\n\tunsigned short head, tail;\n\tbool spfa(){\n\t\thead = tail = 0;\n\t\tmemset(vis, 0, sizeof(vis));\n\t\tmemset(dis, 63, sizeof(dis));\n\t\tq[++tail] = S, dis[S] = 0;\n\t\twhile(head != tail){\n\t\t\tR int now = q[++head];\n//\t\t\tprintf(\"%d\\n\", now);\n\t\t\tvis[now] = false;\n\t\t\tfor(R int i = fr[now]; i; i = ne[i]){\n\t\t\t\tif(c[i] && dis[now] + w[i] < dis[to[i]]){\n\t\t\t\t\tdis[to[i]] = dis[now] + w[i];\n\t\t\t\t\tif(!vis[to[i]]) vis[to[i]] = true, q[++tail] = to[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tputs(\"ga\");\n\t\tif(dis[T] > INF) return false;\n\t\treturn true;\n\t}\n\t\n\tll tans;\n\tint dfs(int a, int flow){\n\t\tif(a == T) return flow;\n\t\tvis[a] = true;\n\t\tint f = flow, tmp;\n\t\tfor(int &i = cur[a]; i; i = ne[i]){\n\t\t\tif(!vis[to[i]] && c[i] && dis[to[i]] == dis[a] + w[i] && (tmp = dfs(to[i], MIN(f, c[i])))){\n\t\t\t\tc[i] -= tmp, c[i ^ 1] += tmp, f -= tmp, tans += w[i] * tmp;\n\t\t\t\tif(!f) {vis[a] = false; return flow;}\n\t\t\t}\n\t\t}\n\t\tvis[a] = false;\n\t\treturn flow - f;\n\t}\n\t\n\tint main(){\n\t\ttans = 0;\n\t\tR int tmp = 0;\n\t\twhile(spfa()){\n\t\t\tfor(R int i = 1; i <= cntp; i++) cur[i] = fr[i];\n\t\t\ttmp += dfs(S, 666);\n\t\t}\n\t\treturn tmp;\n\t}\n\t\n\tint mxx[88], mxy[88];\n\tint mnx[88], mny[88];\n\tbool build(int k){\n\t//\tprintf(\"%d\\n\", k);\n\t\tcnt = 1, cntp = 0;\n\t\tmemset(fr, 0, sizeof(fr));\n\t\tfor(R int i = 1; i <= k; i++)\n\t\t\tmxx[i] = mxy[i] = 101, mnx[i] = mny[i] = 0;\n\t\tfor(R int i = 1; i <= m; i++){\n\t\t\tif(d[i].b >= k) continue;\n\t\t\tif(d[i].op == 'L') cmax(mnx[d[i].b + 1], d[i].a);\n\t\t\tif(d[i].op == 'R') cmin(mxx[k - d[i].b], d[i].a);\n\t\t\tif(d[i].op == 'D') cmax(mny[d[i].b + 1], d[i].a);\n\t\t\tif(d[i].op == 'U') cmin(mxy[k - d[i].b], d[i].a);\n\t\t}\n\t\tfor(R int i = 2; i <= k; i++)\n\t\t\tcmax(mnx[i], mnx[i - 1]),\n\t\t\tcmax(mny[i], mny[i - 1]);\n\t\tfor(R int i = k - 1; i; i--)\n\t\t\tcmin(mxx[i], mxx[i + 1]),\n\t\t\tcmin(mxy[i], mxy[i + 1]);\n\t\tfor(R int i = 1; i <= k; i++)\n\t\t\tif(mxx[i] - mnx[i] < 2 || mxy[i] - mny[i] < 2) return false;\n\t\tfor(R int i = 1; i <= n; i++) add(i, i + n, 1, p[i].v);\n\t\tfor(R int i = 1; i <= k; i++){\n\t\t\tfor(R int j = 1; j <= n; j++){\n\t\t\t\tif(p[j].x > mnx[i] && p[j].x < mxx[i])\n\t\t\t\t\tadd(2 * n + i, j, 1, 0);\n\t\t\t\tif(p[j].y > mny[i] && p[j].y < mxy[i])\n\t\t\t\t\tadd(j + n, 2 * n + k + i, 1, 0);\n\t\t\t}\n\t\t}\n\t\tcntp = 2 * n + 2 * k;\n\t\tS = ++cntp, T = ++cntp;\n\t\tfor(R int i = 1; i <= k; i++) add(S, 2 * n + i, 1, 0), add(2 * n + k + i, T, 1, 0);\n\t\treturn true;\n\t}\n}A;\n\nint main(){\n\tll ans = 0;\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i <= n; i++)\n\t\tscanf(\"%d %d %lld\", &p[i].x, &p[i].y, &p[i].v), p[i].v = -p[i].v;\n\tscanf(\"%d\", &m);\n\tchar tch[3];\n\tfor(R int i = 1; i <= m; i++){\n\t\tscanf(\"%s\", tch + 1);\n\t\tscanf(\"%d %d\", &d[i].a, &d[i].b);\n\t\td[i].op = tch[1];\n\t}\n\tfor(R int i = 1; i <= n; i++){\n\t\tif(A.build(i)){\n\t\t\tif(A.main() != i) break;\n\t\t\tans = MIN(ans, A.tans);\n\t\t}\n\t\telse break;\n\t}\n\tprintf(\"%lld\\n\", -ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef BZ\n#pragma GCC optimize \"-O3\"\n#endif\n#include <bits/stdc++.h>\n\n#define FASTIO\n#define ALL(v) (v).begin(), (v).end()\n#define rep(i, l, r) for (int i = (l); i < (r); ++i)\n\n#ifdef FASTIO\n#define scanf abacaba\n#define printf abacaba\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\n\n/*\nll pw(ll a, ll b) {\n\tll ans = 1; while (b) {\n\t\twhile (!(b & 1)) b >>= 1, a = (a * a) % MOD;\n\t\tans = (ans * a) % MOD, --b;\n\t} return ans;\n}\n*/\n\nconst int MAXN = 210;\n\nstruct edge {\n\tint a, b;\n\tint f, c;\n\tll w;\n};\n\n\nint s, t;\nvector<edge> ed;\n\nvector<int> eds[MAXN];\n\nvoid add_edge(int a, int b, int c, ll w) {\n\tedge x;\n\tx.a = a, x.b = b, x.c = c, x.f = 0, x.w = w;\n\teds[a].push_back(ed.size());\n\ted.push_back(x);\n\tswap(x.a, x.b), x.c = 0, x.w = -w;\n\teds[b].push_back(ed.size());\n\ted.push_back(x);\n}\n\n\nconst ll INF = 1e18;\nint en[210];\nll dd[210];\nint go[210];\nqueue<int> qu;\n\nvoid clear() {\n\ted.clear();\n\tfor (int i = 0; i <= t; ++i)\n\t\teds[i].clear();\n}\n\npair<int, ll> flow() {\n\tint cur = 0;\n\tll cost = 0;\n\twhile (true) {\n\t\tfill(en, en + t + 1, 0);\n\t\tfill(dd, dd + t + 1, INF);\n\t\tfill(go, go + t + 1, -1);\n\t\tdd[s] = 0;\n\t\tqu.push(s);\n\t\ten[s] = 1;\n\t\twhile (!qu.empty()) {\n\t\t\tint x = qu.front();\n\t\t\tqu.pop();\n\t\t\ten[x] = 0;\n\t\t\tfor (int e: eds[x]) {\n\t\t\t\tif (ed[e].c == ed[e].f)\n\t\t\t\t\tcontinue;\n\t\t\t\tint u = ed[e].b;\n\t\t\t\tif (dd[u] > dd[x] + ed[e].w) {\n\t\t\t\t\tdd[u] = dd[x] + ed[e].w;\n\t\t\t\t\tgo[u] = e;\n\t\t\t\t\tif (!en[u])\n\t\t\t\t\t\ten[u] = 1, qu.push(u);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dd[t] == INF)\n\t\t\tbreak;\n\t\tint mn = 200;\n\t\tint now = t;\n\t\twhile (now != s) {\n\t\t\tint e = go[now];\n\t\t\tmn = min(mn, ed[e].c - ed[e].f);\n\t\t\tnow = ed[e].a;\n\t\t}\n\t\tnow = t;\n\t\tcur += mn;\n\t\tcost += mn * dd[t];\n\t\twhile (now != s) {\n\t\t\tint e = go[now];\n\t\t\ted[e].f += mn;\n\t\t\ted[e ^ 1].f -= mn;\n\t\t\tnow = ed[e].a;\n\t\t}\n\t}\n\treturn {cur, cost};\n}\n\n\nvector<tuple<int, int, ll>> ad;\n\nint n;\nint m;\nint lb[210], rb[210];\n\nint main() {\n#ifdef FASTIO\n\tios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n#endif\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint x, y;\n\t\tll v;\n\t\tcin >> x >> y >> v;\n\t\tad.emplace_back(x - 1, 100 + y - 1, -v);\n\t}\n\tcin >> m;\n\tfor (int i = 0; i < 200; ++i)\n\t\trb[i] = n, lb[i] = -n;\n\tint mx = n;\n\tfor (int i = 0; i < m; ++i) {\n\t\tchar t;\n\t\tint a, b;\n\t\tcin >> t >> a >> b;\n\t\t--a;\n\t\tif (t == 'L') {\n\t\t\tif (a == 99)\n\t\t\t\tmx = min(mx, b);\n\t\t\telse\n\t\t\t\tlb[a + 1] = max(lb[a + 1], -b);\n\t\t}\n\t\telse if (t == 'R') {\n\t\t\tif (a == 0)\n\t\t\t\tmx = min(mx, b);\n\t\t\telse \n\t\t\t\trb[a] = min(rb[a], b);\n\t\t}\n\t\telse if (t == 'D') {\n\t\t\tif (a == 99)\n\t\t\t\tmx = min(mx, b);\n\t\t\telse\n\t\t\t\trb[100 + a + 1] = min(rb[100 + a + 1], b);\n\t\t}\n\t\telse {\n\t\t\tif (a == 0)\n\t\t\t\tmx = min(mx, b);\n\t\t\telse\n\t\t\t\tlb[100 + a] = max(lb[100 + a], -b);\n\t\t}\n\t}\n\tll ans = 0;\n\ts = 200;\n\tt = 201;\n\tfor (int k = 1; k <= mx; ++k) {\n\t\tclear();\n\t\tint fl = 0;\n\t\tfor (int i = 0; i < 200; ++i)\n\t\t\tif (lb[i] + k > rb[i])\n\t\t\t\tfl = 1;\n\t\tif (fl)\n\t\t\tcontinue;\n\t\tadd_edge(s, 0, k, 0); \n\t\tadd_edge(199, t, k, 0);\n\t\tint sum = k;\n\t\tfor (int i = 0; i < 99; ++i) {\n\t\t\tint l = max(0, lb[i + 1] + k);\n\t\t\tint r = min(k, rb[i + 1]);\n\t\t\tadd_edge(i, i + 1, r - l, 0);\n\t\t\tadd_edge(s, i + 1, l, 0);\n\t\t\tadd_edge(i, t, l, 0);\n\t\t\tsum += l;\n\t\t}\n\t\tfor (int i = 100; i < 199; ++i) {\n\t\t\tint l = max(0, lb[i + 1] + k);\n\t\t\tint r = min(k, rb[i + 1]);\n\t\t\tadd_edge(i, i + 1, r - l, 0);\n\t\t\tadd_edge(s, i + 1, l, 0);\n\t\t\tadd_edge(i, t, l, 0);\n\t\t\tsum += l;\n\t\t}\n\t\tfor (auto e: ad) {\n\t\t\tint a, b; ll v;\n\t\t\ttie(a, b, v) = e;\n\t\t\tadd_edge(a, b, 1, v);\n\t\t}\n\t\tpair<int, ll> x = flow();\n\t\tif (x.first == sum)\n\t\t\tans = min(ans, x.second);\n\t}\n\tcout << -ans << \"\\n\";\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n#define LL long long\n#define fgx cerr<<\"--------------\"<<endl;\n#define dgx cerr<<\"==============\"<<endl;\n\ninline LL read(){\n\tLL x=0,f=1; char c=getchar();\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0';\n\treturn x*f;\n}\nconst LL MAXN = 500010;\nconst LL INF = 1e17;\n\nLL N; LL d[2][MAXN+1],V[MAXN+1];\nLL Cost[MAXN+1]; LL Node[MAXN+1],Next[MAXN+1],C[MAXN+1],Root[MAXN+1];\nLL cnt; LL S,T;\ninline void addedge(LL u,LL v,LL c,LL w){ Cost[cnt]=w; C[cnt]=c; Node[cnt]=v; Next[cnt]=Root[u]; Root[u]=cnt++; }\ninline void insert(LL u,LL v,LL c,LL w){ w=-w; addedge(u,v,c,w); addedge(v,u,0,-w); return ; }\nLL dis[MAXN+1]; bool inq[MAXN+1];\nLL ans,ret;\ninline bool BFS(){\n\tdeque<LL> que; for(LL i=0;i<=T;i++) dis[i]=INF,inq[i]=0;\n\tdis[T]=0; que.push_back(T); inq[T]=true;\n\tint td=0;\n\twhile(!que.empty()){\n\t    LL k=que.front(); que.pop_front(); ++td;\n\t\tfor(LL x=Root[k];x!=-1;x=Next[x]){\n\t\t    LL v=Node[x];\n\t\t    if(C[x^1]>0&&dis[v]>dis[k]-Cost[x]){\n\t\t        dis[v]=dis[k]-Cost[x];\n\t\t\t\tif(!inq[v]){\n\t\t\t\t\tinq[v]=true;\n\t\t\t\t    if(que.empty()||dis[v]<=dis[que.front()]) que.push_front(v);\n\t\t\t\t    else que.push_back(v);\n\t\t\t    }\n\t\t    }\n\t    }inq[k]=false;\n\t}  return dis[S]<INF;\n} LL fans;\ninline LL DFS(LL k,LL t){\n    if(k==T) {inq[k]=1;return t;} \n\tinq[k]=1; LL res=0;\n\tfor(LL x=Root[k];x!=-1;x=Next[x]){\n\t    LL v=Node[x];\n\t    if(C[x]>0&&!inq[v]&&dis[v]==dis[k]-Cost[x]){\n\t        LL tmp=DFS(v,min(t,C[x]));\n\t\t\tif(!tmp) continue; C[x]-=tmp; C[x^1]+=tmp;\n\t\t\tres+=tmp; t-=tmp; fans+=(LL)tmp*Cost[x]; if(!t) return res;\t\n\t    }\n    } return res;\n}\n#define fr first\n#define sc second\ninline void Max(LL &a,LL b){ a=max(a,b); }\ninline void Min(LL &a,LL b){ a=min(a,b); }\nLL L[2][MAXN+1],R[2][MAXN+1];\nLL M; char ch[5];\nvector<pair<LL,LL> > vec[4];\nint sta[MAXN+1],sta2[MAXN+1],sta3[MAXN+1];\ninline void check(LL K){\n\tfor(LL i=0;i<=K+1;i++) L[0][i]=L[1][i]=1,R[0][i]=R[1][i]=100; cnt=0;\n\tfor(LL i=0;i<=N*2+2*K+1;i++) Root[i]=-1;\n\tfor(LL i=0,l=vec[0].size();i<l;i++) Max(L[0][vec[0][i].fr+1],vec[0][i].sc+1);\n\tfor(LL i=0,l=vec[1].size();i<l;i++) if(vec[1][i].fr<K) Min(R[0][K-vec[1][i].fr],vec[1][i].sc-1);\n\tfor(LL i=0,l=vec[2].size();i<l;i++) Max(L[1][vec[2][i].fr+1],vec[2][i].sc+1);\n\tfor(LL i=0,l=vec[3].size();i<l;i++) if(vec[3][i].fr<K) Min(R[1][K-vec[3][i].fr],vec[3][i].sc-1);\n\tS=0,T=N*2+K*2+1; int top=0,top2=0,top3=0;\n\tfor(LL i=1;i<=N;i++) insert(i,N+i,1,V[i]),sta[++top]=cnt-2;\n\tfor(LL i=0;i<2;i++){\n\t\tfor(LL j=1;j<=K;j++) L[i][j]=max(L[i][j],L[i][j-1]);\n\t\tfor(LL j=K-1;j>=0;j--) R[i][j]=min(R[i][j],R[i][j+1]);\n\t\tfor(LL j=1;j<=K;j++){\n\t\t\tif(!i) insert(S,N*2+j,1,0),sta2[++top2]=cnt-2;\n\t\t\telse insert(N*2+K+j,T,1,0),sta3[++top3]=cnt-2;\n\t\t\t\n\t\t\t\t\t//if(K==5&&!i) cout<<\"gg:\"<<L[i][j]<<\" \"<<R[i][j]<<endl;\n\t\t\tfor(LL k=1;k<=N;k++){\n\t\t\t\tif(d[i][k]>=L[i][j]&&d[i][k]<=R[i][j]){\n\t\t\t\t\tif(!i) insert(N*2+j,k,1,0);\n\t\t\t\t\telse insert(N+k,N*2+K+j,1,0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} fans=0;\n\tret=0; while(BFS()) ret+=DFS(S,INF);\n\tans=max(ans,-fans); //cout<<-fans<<\" \"<<ret<<\" \"<<K<<endl;\n\t//for(int i=1;i<=top;i++) cout<<C[sta[i]]<<\" \"; cout<<endl; for(int i=1;i<=top2;i++) cout<<C[sta2[i]]<<\" \"; cout<<endl;for(int i=1;i<=top3;i++) cout<<C[sta3[i]]<<\" \"; cout<<endl; \n\t return ; \n}\n\nint main(){\n\t//freopen(\"a.in\",\"r\",stdin);\n\t//freopen(\"a2.out\",\"w\",stdout);\n\tN=read();\n\tmemset(Root,-1,sizeof(Root));\n\tfor(LL i=1;i<=N;i++){\n\t\td[0][i]=read(),d[1][i]=read(),V[i]=read();\n\t} M=read();\n\tfor(LL i=1;i<=M;i++){\n\t\tscanf(\"%s\",ch+1); LL a=read(),b=read();\n\t\tLL opr; if(ch[1]=='L') opr=0;\n\t\telse if(ch[1]=='R') opr=1;\n\t\telse if(ch[1]=='U') opr=3;\n\t\telse opr=2; vec[opr].push_back(make_pair(b,a));\n\t}\n\tfor(LL i=0;i<4;i++) sort(vec[i].begin(),vec[i].end());\n\tfor(LL K=1;K<=N;K++) check(K);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n#define LL long long\n#define fgx cerr<<\"--------------\"<<endl;\n#define dgx cerr<<\"==============\"<<endl;\n\ninline LL read(){\n\tLL x=0,f=1; char c=getchar();\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0';\n\treturn x*f;\n}\nconst LL MAXN = 500010;\nconst LL INF = 1000000000;\n\nLL N; LL d[2][MAXN+1],V[MAXN+1];\nLL Cost[MAXN+1]; LL Node[MAXN+1],Next[MAXN+1],C[MAXN+1],Root[MAXN+1];\nLL cnt; LL S,T;\ninline void addedge(LL u,LL v,LL c,LL w){ Cost[cnt]=w; C[cnt]=c; Node[cnt]=v; Next[cnt]=Root[u]; Root[u]=cnt++; }\ninline void insert(LL u,LL v,LL c,LL w){ w=-w; addedge(u,v,c,w); addedge(v,u,0,-w); return ; }\nLL dis[MAXN+1]; bool inq[MAXN+1];\nLL ans,ret;\ninline bool BFS(){\n\tmemset(inq,false,sizeof(inq));\n\tdeque<LL> que; for(LL i=0;i<=T;i++) dis[i]=INF;\n\tdis[T]=0; que.push_back(T); inq[T]=true;\n\twhile(!que.empty()){\n\t    LL k=que.front(); que.pop_front();\n\t\tfor(LL x=Root[k];x!=-1;x=Next[x]){\n\t\t    LL v=Node[x];\n\t\t    if(C[x^1]>0&&dis[v]>dis[k]-Cost[x]){\n\t\t        dis[v]=dis[k]-Cost[x];\n\t\t\t\tif(!inq[v]){\n\t\t\t\t\tinq[v]=true;\n\t\t\t\t    if(que.empty()||dis[v]<=dis[que.front()]) que.push_front(v);\n\t\t\t\t    else que.push_back(v);\n\t\t\t    }\n\t\t    }\n\t    }inq[k]=false;\n\t} return dis[S]<INF;\n} LL fans;\ninline LL DFS(LL k,LL t){\n    if(k==T) {inq[k]=1;return t;} \n\tinq[k]=1; LL res=0;\n\tfor(LL x=Root[k];x!=-1;x=Next[x]){\n\t    LL v=Node[x];\n\t    if(C[x]>0&&!inq[v]&&dis[v]==dis[k]-Cost[x]){\n\t        LL tmp=DFS(v,min(t,C[x]));\n\t\t\tif(!tmp) continue; C[x]-=tmp; C[x^1]+=tmp;\n\t\t\tres+=tmp; t-=tmp; fans+=(LL)tmp*Cost[x]; if(!t) return res;\t\n\t    }\n    } return res;\n}\n#define fr first\n#define sc second\ninline void Max(LL &a,LL b){ a=max(a,b); }\ninline void Min(LL &a,LL b){ a=min(a,b); }\nLL L[2][MAXN+1],R[2][MAXN+1];\nLL M; char ch[5];\nvector<pair<LL,LL> > vec[4];\ninline void check(LL K){\n\tfor(LL i=0;i<=100;i++) L[0][i]=L[1][i]=1,R[0][i]=R[1][i]=100; cnt=0;\n\tfor(LL i=0;i<=N*2+2*K+1;i++) Root[i]=-1;\n\tfor(LL i=0,l=vec[0].size();i<l;i++) Max(L[0][vec[0][i].fr+1],vec[0][i].sc+1);\n\tfor(LL i=0,l=vec[1].size();i<l;i++) if(vec[1][i].fr<K) Min(R[0][K-vec[1][i].fr],vec[1][i].sc-1);\n\tfor(LL i=0,l=vec[2].size();i<l;i++) Max(L[1][vec[2][i].fr+1],vec[2][i].sc+1);\n\tfor(LL i=0,l=vec[3].size();i<l;i++) if(vec[3][i].fr<K) Min(R[1][K-vec[3][i].fr],vec[3][i].sc-1);\n\tS=0,T=N*2+K*2+1; for(LL i=1;i<=N;i++) insert(i,N+i,1,V[i]);\n\tfor(LL i=0;i<2;i++){\n\t\tfor(LL j=1;j<=100;j++) L[i][j]=max(L[i][j],L[i][j-1]);\n\t\tfor(LL j=99;j>=0;j--) R[i][j]=min(R[i][j],R[i][j+1]);\n\t\tfor(LL j=1;j<=K;j++){\n\t\t\tif(!i) insert(S,N*2+j,1,0);\n\t\t\telse insert(N*2+K+j,T,1,0);\n\t\t\tfor(LL k=1;k<=N;k++){\n\t\t\t\tif(d[i][k]>=L[i][j]&&d[i][k]<=R[i][j]){\n\t\t\t\t\tif(!i) insert(N*2+j,k,1,0);\n\t\t\t\t\telse insert(N+k,N*2+K+j,1,0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} fans=0;\n\tret=0; while(BFS()) ret+=DFS(S,INF);\n\tans=max(ans,-fans); return ; \n}\n\nint main(){\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tN=read();\n\tmemset(Root,-1,sizeof(Root));\n\tfor(LL i=1;i<=N;i++){\n\t\td[0][i]=read(),d[1][i]=read(),V[i]=read();\n\t} M=read();\n\tfor(LL i=1;i<=M;i++){\n\t\tscanf(\"%s\",ch+1); LL a=read(),b=read();\n\t\tLL opr; if(ch[1]=='L') opr=0;\n\t\telse if(ch[1]=='R') opr=1;\n\t\telse if(ch[1]=='U') opr=3;\n\t\telse opr=2; vec[opr].push_back(make_pair(b,a));\n\t}\n\tfor(LL i=1;i<=4;i++) sort(vec[i].begin(),vec[i].end());\n\tfor(LL K=1;K<=N;K++) check(K);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace mcmf {\n\nconst long long inf = 1000111222000111222LL;\n\nstruct edge {\n    int to, flow, capacity;\n    long long cost;\n\n    edge() {\n    }\n\n    edge(int to, int flow, int capacity, long long cost): to(to), flow(flow), capacity(capacity), cost(cost) {\n    }\n\n};\n\nconst int max_v = 404;\n\nvector<edge> edges;\nvector<int> g[max_v];\n\nvoid clr() {\n    edges.clear();\n    for (int i = 0; i < max_v; ++i) {\n        g[i].clear();\n    }\n}\n\nvoid add_edge(int u, int v, int capacity, long long cost) {\n    g[u].push_back(edges.size());\n    edges.push_back(edge(v, 0, capacity, cost));\n    g[v].push_back(edges.size());\n    edges.push_back(edge(u, 0, 0, -cost));\n}\n\nint parent[max_v], p_id[max_v];\nlong long phi[max_v], dist[max_v];\n\nlong long dijkstra(int s, int t) {\n    for (int i = 0; i <= t; ++i) {\n        dist[i] = inf;\n    }\n    priority_queue<pair<long long, int>> q;\n    dist[s] = 0;\n    q.push({0, s});\n    while (!q.empty()) {\n        pair<long long, int> p = q.top();\n        q.pop();\n        long long d = -p.first, v = p.second;\n        if (d != dist[v]) {\n            continue;\n        }\n        for (int id : g[v]) {\n            if (edges[id].flow == edges[id].capacity) {\n                continue;\n            }\n            int to = edges[id].to;\n            // cout << v << \" \" << dist[v] << \" -> \" << to << \" \" << edges[id].cost << endl;\n            if (dist[v] + edges[id].cost + phi[v] - phi[to] < dist[to]) {\n                dist[to] = dist[v] + edges[id].cost + phi[v] - phi[to];\n                parent[to] = v;\n                p_id[to] = id;\n                q.push({-dist[to], to});\n            }\n        }\n    }\n    if (dist[t] == inf) {\n        return inf;\n    }\n    for (int i = 0; i <= t; ++i) {\n        phi[i] = min(inf, dist[i] + phi[i]);\n    }\n    int v = t;\n    while (v != s) {\n        ++edges[p_id[v]].flow;\n        --edges[p_id[v] ^ 1].flow;\n        v = parent[v];\n    }\n    return phi[t];\n}\n\nlong long min_cost_max_flow(int s, int t, int k) {\n    for (int i = 0; i <= t; ++i) {\n        phi[i] = 0;\n    }\n    long long res = 0;\n    int it = 0;\n    while (true) {\n        long long x = dijkstra(s, t);\n        if (x == inf) {\n            break;\n        }\n        ++it;\n        res += x;\n    }\n    if (it != k) {\n        return 0;\n    }\n    return res;\n}\n\n}\n\nconst int max_n = 105;\nconst int max_c = 333;\nconst long long inf = 1000111222000111LL;\n\nint lx[max_n], rx[max_n], ly[max_n], ry[max_n];\n\nstruct constraint {\n    char tp;\n    int x, cnt;\n\n    void read() {\n        scanf(\"\\n%c%d%d\", &tp, &x, &cnt);\n        --x;\n    }\n\n    void add(int k) {\n        if (tp == 'L') {\n            for (int i = cnt; i < k; ++i) {\n                lx[i] = max(lx[i], x + 1);\n            }\n        } else if (tp == 'D') {\n            for (int i = cnt; i < k; ++i) {\n                ly[i] = max(ly[i], x + 1);\n            }\n        } else if (tp == 'R') {\n            for (int i = 0; i < k - cnt; ++i) {\n                rx[i] = min(rx[i], x - 1);\n            }\n        } else {\n            for (int i = 0; i < k - cnt; ++i) {\n                ry[i] = min(ry[i], x - 1);\n            }\n        }\n    }\n};\n\nint n, m, x[max_n], y[max_n];\nlong long v[max_n];\nconstraint c[max_c];\n\nlong long solve(int k) {\n    for (int i = 0; i < k; ++i) {\n        lx[i] = ly[i] = 0;\n        rx[i] = ry[i] = 99;\n    }\n    for (int i = 0; i < m; ++i) {\n        c[i].add(k);\n    }\n    for (int i = 0; i < k; ++i) {\n        if (lx[i] > rx[i] || ly[i] > ry[i]) {\n            return 0;\n        }\n    }\n    if (0) {\n        cout << k << \": \" << endl;\n        for (int i = 0; i < k; ++i) {\n            cout << lx[i] << \" \" << rx[i] << \", \" << ly[i] << \" \" << ry[i] << endl;\n        }\n        cout << endl;\n    }\n    mcmf::clr();\n    const int max_x = 100;\n    int s = 2 * k + 2 * max_x;\n    int t = s + 1;\n    for (int i = 0; i < k; ++i) {\n        mcmf::add_edge(s, i, 1, 0);\n        for (int x = lx[i]; x <= rx[i]; ++x) {\n            mcmf::add_edge(i, k + x, 1, 0);\n        }\n        mcmf::add_edge(k + 2 * max_x + i, t, 1, 0);\n        for (int y = ly[i]; y <= ry[i]; ++y) {\n            mcmf::add_edge(k + max_x + y, k + 2 * max_x + i, 1, 0);\n        }\n    }\n    for (int i = 0; i < n; ++i) {\n        mcmf::add_edge(k + x[i], k + max_x + y[i], 1, -v[i] + inf);\n    }\n    long long res = -mcmf::min_cost_max_flow(s, t, k);\n    if (res == 0) {\n        return 0;\n    }\n    return res + k * inf;\n}\n\nint main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; ++i) {\n        scanf(\"%d%d%lld\", &x[i], &y[i], &v[i]);\n        --x[i];\n        --y[i];\n    }\n    scanf(\"%d\", &m);\n    for (int i = 0; i < m; ++i) {\n        c[i].read();\n    }\n    long long ans = 0;\n    for (int i = 1; i <= n; ++i) {\n        long long res = solve(i);\n        if (res == 0) {\n            break;\n        }\n        ans = max(ans, res);\n    }\n    printf(\"%lld\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//2019.5.25 by ljz\n#include<bits/stdc++.h>\nusing namespace std;\n#define res register int\n#define LL long long\n#define inf 0x3f3f3f3f\n#define INF 1000000000000000LL\n#define eps 1e-10\n#define RG register\n#define db double\n#define pc(x) __builtin_popcount(x)\ntypedef pair<int,int> Pair;\n#define mp make_pair\n#define fi first\n#define se second\n#define gc getchar\n//inline char gc() {\n//    static char buf[100000],*p1,*p2;\n//    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n//}\ninline int read() {\n    res s=0,ch=gc();\n    while(ch<'0'||ch>'9')ch=gc();\n    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=gc();\n    return s;\n}\ninline LL Read() {\n    RG LL s=0;\n    res ch=gc();\n    while(ch<'0'||ch>'9')ch=gc();\n    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=gc();\n    return s;\n}\ninline void swap(res &x,res &y) {\n    x^=y^=x^=y;\n}\n//mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nconst int N=4e2+10;\nnamespace MAIN {\n    int n,m;\n    char str[10];\n    LL v[N];\n    int x[N],y[N],t[N],a[N],b[N];\n    struct E{\n        int next,to,flow;\n        LL cost;\n        E() {}\n        E(res next,res to,res flow,RG LL cost):next(next),to(to),flow(flow),cost(cost) {}\n    }edge[N*N];\n    int head[N],cnt;\n    inline void addedge(const res &u,const res &v,const res &f,const RG LL &c){\n        edge[++cnt]=E(head[u],v,f,c),head[u]=cnt;\n        edge[++cnt]=E(head[v],u,0,-c),head[v]=cnt;\n    }\n    LL dis[N];\n    int Q[N*N],he,ta,S,T,vis[N],pre[N];\n    inline bool spfa(RG LL &ret){\n        for(res i=S;i<=T;i++)dis[i]=INF;\n        Q[he=ta=1]=S,vis[S]=1,dis[S]=0;\n        while(he<=ta){\n            res u=Q[he++];\n            vis[u]=0;\n            for(res i=head[u];~i;i=edge[i].next){\n                res tox=edge[i].to;\n                if(dis[tox]>dis[u]+edge[i].cost&&edge[i].flow){\n                    dis[tox]=dis[u]+edge[i].cost,pre[tox]=i;\n                    if(!vis[tox])vis[tox]=1,Q[++ta]=tox;\n                }\n            }\n        }\n        if(dis[T]==INF)return 0;\n        ret+=dis[T];\n        for(res i=T;i!=S;i=edge[pre[i]^1].to)edge[pre[i]].flow--,edge[pre[i]^1].flow++;\n        return 1;\n    }\n    int L[N],R[N],D[N],U[N];\n    inline LL calc(const res &k){\n        for(res i=1;i<=k;i++)L[i]=D[i]=0,R[i]=U[i]=inf;\n        for(res i=1;i<=m;i++)\n            if(b[i]<k){\n                if(t[i]==0)L[b[i]+1]=a[i]+1;\n                if(t[i]==1)R[k-b[i]]=a[i]-1;\n                if(t[i]==2)D[b[i]+1]=a[i]+1;\n                if(t[i]==3)U[k-b[i]]=a[i]-1;\n            }\n        for(res i=2;i<=k;i++)L[i]=max(L[i],L[i-1]),D[i]=max(D[i],D[i-1]);\n        for(res i=k-1;i;i--)R[i]=min(R[i],R[i+1]),U[i]=min(U[i],U[i+1]);\n        S=0,T=(n+k)<<1|1;\n        for(res i=S;i<=T;i++)head[i]=-1;\n        cnt=-1;\n        for(res i=1;i<=n;i++)addedge(i,i+n,1,-v[i]-INF);\n        for(res i=1;i<=k;i++){\n            addedge(S,i+n*2,1,0),addedge(i+k+n*2,T,1,0);\n            for(res j=1;j<=n;j++){\n                if(L[i]<=x[j]&&x[j]<=R[i])addedge(i+n*2,j,1,0);\n                if(D[i]<=y[j]&&y[j]<=U[i])addedge(j+n,i+k+n*2,1,0);\n            }\n        }\n        RG LL ret=0;\n        while(spfa(ret));\n        return -ret-INF*k;\n    }\n    LL ans;\n    inline int get(const RG char *st){\n        return st[0]=='L'?0:(st[0]=='R'?1:(st[0]=='D'?2:3));\n    }\n    inline void MAIN(){\n        n=read();\n        for(res i=1;i<=n;i++)x[i]=read(),y[i]=read(),v[i]=Read();\n        m=read();\n        for(res i=1;i<=m;i++)scanf(\"%s\",str),t[i]=get(str),a[i]=read(),b[i]=read();\n        for(res i=1;i<=n;i++)ans=max(ans,calc(i));\n        printf(\"%lld\\n\",ans);\n    }\n}\nint main() {\n//    srand((unsigned)time(NULL));\n//    freopen(\"zao.in\",\"r\",stdin);\n//    freopen(\"std.out\",\"w\",stdout);\n    MAIN::MAIN();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\ntemplate<typename T>\nstruct PrimalDual{\n  struct edge{\n    Int to;\n    T cap,cost;\n    Int rev;\n    edge(){}\n    edge(Int to,T cap,T cost,Int rev):to(to),cap(cap),cost(cost),rev(rev){}\n  };\n  \n  T INF;\n  vector<vector<edge> > G;\n  vector<T> h,dist;\n  vector<Int> prevv,preve;\n\n  PrimalDual(){}\n  PrimalDual(Int n,T INF):INF(INF),G(n),h(n),dist(n),prevv(n),preve(n){}\n  \n  void add_edge(Int from,Int to,T cap,T cost){\n    G[from].emplace_back(to,cap,cost,G[to].size());\n    G[to].emplace_back(from,0,-cost,G[from].size()-1);\n  }\n\n  T flow(Int s,Int t,T f,Int &ok){    \n    T res=0;\n    fill(h.begin(),h.end(),0);\n    while(f>0){\n      using P = pair<T, Int>;\n      priority_queue<P,vector<P>,greater<P> > que;\n      fill(dist.begin(),dist.end(),INF);\n      \n      dist[s]=0;\n      que.emplace(dist[s],s);\n      while(!que.empty()){\n        P p=que.top();que.pop();\n        Int v=p.second;\n        if(dist[v]<p.first) continue;\n        for(Int i=0;i<(Int)G[v].size();i++){\n          edge &e=G[v][i];\n          if(e.cap==0) continue;\n          if(dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n            dist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n            prevv[e.to]=v;\n            preve[e.to]=i;\n            que.emplace(dist[e.to],e.to);\n          }\n        }\n      }\n      if(dist[t]==INF) return ok=0;\n      \n      for(Int v=0;v<(Int)h.size();v++) h[v]+=dist[v];\n\n      T d=f;\n      for(Int v=t;v!=s;v=prevv[v])\n        d=min(d,G[prevv[v]][preve[v]].cap);\n      \n      f-=d;\n      res+=d*h[t];\n      for(Int v=t;v!=s;v=prevv[v]){\n        edge &e=G[prevv[v]][preve[v]];\n        e.cap-=d;\n        G[v][e.rev].cap+=d;\n      }\n    }\n    ok=1;\n    return res;\n  }\n};\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<Int> xs(n),ys(n),vs(n);\n  for(Int i=0;i<n;i++) cin>>xs[i]>>ys[i]>>vs[i];\n\n  Int m;\n  cin>>m;\n  vector<char> ts(m);\n  vector<Int> as(m),bs(m);\n  for(Int i=0;i<m;i++) cin>>ts[i]>>as[i]>>bs[i];\n\n  const Int INF = 1e16;\n  vector<Int> ls(n,-INF),rs(n,INF),ds(n,-INF),us(n,INF);\n  for(Int i=0;i<m;i++){\n    if(ts[i]=='L') chmax(ls[bs[i]],as[i]);\n    if(ts[i]=='R') chmin(rs[bs[i]],as[i]);\n    if(ts[i]=='D') chmax(ds[bs[i]],as[i]);\n    if(ts[i]=='U') chmin(us[bs[i]],as[i]);\n  }\n  for(Int i=0;i+1<n;i++){\n    chmax(ls[i+1],ls[i]);\n    chmin(rs[i+1],rs[i]);\n    chmax(ds[i+1],ds[i]);\n    chmin(us[i+1],us[i]);\n  }\n  \n  Int ans=0;\n  for(Int k=1;k<=n;k++){\n    PrimalDual<Int> G(k*2+n*2+2,INF);\n    Int S=k*2+n*2,T=k*2+n*2+1;\n    for(Int i=0;i<k;i++){\n      G.add_edge(S,i,1,0);\n      G.add_edge(k+i,T,1,0);\n    }\n    \n    for(Int i=0;i<n;i++)\n      G.add_edge(k*2+i,k*2+n+i,1,INF-vs[i]);\n    \n    for(Int i=0;i<k;i++){\n      for(Int j=0;j<k;j++){\n        for(Int p=0;p<n;p++){\n          if(xs[p]<=ls[i]) continue;\n          if(xs[p]>=rs[k-(i+1)]) continue;\n          if(ys[p]<=ds[j]) continue;\n          if(ys[p]>=us[k-(j+1)]) continue;          \n          G.add_edge(i,k*2+p,1,0);     \n          G.add_edge(k*2+n+p,k+j,1,0);\n        }\n      }\n    }\n    continue;\n    Int ok=1;\n    Int res=G.flow(S,T,k,ok);    \n    if(!ok) break;\n    chmax(ans,INF*k-res);\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define space putchar(' ')\n#define enter putchar('\\n')\n#define MAXN 100005\n#define eps 1e-10\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef unsigned int u32;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;T f = 1;char c = getchar();\n    while(c < '0' || c > '9') {\n\tif(c == '-') f = -1;\n\tc = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n\tres = res * 10 + c - '0';\n\tc = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n\tout(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nstruct node {\n    int to,next,cap;int64 val;\n}E[1000005];\nint sumE,head[505],a[330],b[330],x[85],y[85],N,M;\nint L[2][85],R[2][85],S,T,f;\nint64 val[85],res,ans,ex;\nbool vis[505];\nchar s[330][2];\nvoid add(int u,int v,int c,int64 a) {\n    E[++sumE].to = v;\n    E[sumE].next = head[u];\n    E[sumE].cap = c;\n    E[sumE].val = a;\n    head[u] = sumE;\n}\nvoid addtwo(int u,int v,int c,int64 a) {\n    add(u,v,c,a);\n    add(v,u,0,-a);\n}\nvoid build(int K) {\n    sumE = 1;memset(head,0,sizeof(head));\n    for(int i = 1 ; i <= N ; ++i) L[0][i] = L[1][i] = 1,R[0][i] = R[1][i] = 100;\n    for(int i = 1 ; i <= M ; ++i) {\n        if(b[i] >= K) continue;\n        if(s[i][0] == 'L') {\n            L[0][b[i] + 1] = max(L[0][b[i] + 1],a[i] + 1);\n        }\n        else if(s[i][0] == 'R') {\n            R[0][K - b[i]] = min(R[0][K - b[i]],a[i] - 1);\n        }\n        else if(s[i][0] == 'D') {\n            L[1][b[i] + 1] = max(L[1][b[i] + 1],a[i] + 1);\n        }\n        else if(s[i][0] == 'U') {\n            R[1][K - b[i]] = min(R[1][K - b[i]],a[i] - 1);\n        }\n    }\n    for(int i = 2 ; i <= K ; ++i) {\n    \tL[0][i] = max(L[0][i - 1],L[0][i]);\n    \tL[1][i] = max(L[1][i - 1],L[1][i]);\n    }\n    for(int i = K - 1 ; i >= 1 ; --i) {\n    \tR[0][i] = min(R[0][i + 1],R[0][i]);\n    \tR[1][i] = min(R[1][i + 1],R[1][i]);\n    }\n    S = 1;T = 2 * K + 2 * N + 2;\n    for(int i = 1 ; i <= K ; ++i) {\n    \taddtwo(S,i + 1,1,0);\n    \taddtwo(i + K + 2 * N + 1,T,1,0);\n    \tfor(int j = 1 ; j <= N ; ++j) {\n    \t    if(x[j] >= L[0][i] && x[j] <= R[0][i]) {\n        \t\taddtwo(i + 1,K + j + 1,1,0);\n    \t    }\n    \t    if(y[j] >= L[1][i] && y[j] <= R[1][i]) {\n        \t\taddtwo(K + N + j + 1,i + K + 2 * N + 1,1,0);\n    \t    }\n    \t}\n    }\n    for(int i = 1 ; i <= N ; ++i) {\n        addtwo(K + i + 1,K + N + i + 1,1,val[i]);\n    }\n\n}\nint maxflow(int u,int aug) {\n    if(u == T) {\n    \tres += ex * aug;\n        f += aug;\n    \treturn aug;\n    }\n    int flow = 0;\n    vis[u] = 1;\n    for(int i = head[u] ; i ; i = E[i].next) {\n        int v = E[i].to;\n    \tif(E[i].cap > 0 && !vis[v] && E[i].val == 0) {\n    \t    int t = maxflow(v,min(E[i].cap,aug - flow));\n    \t    flow += t;\n    \t    E[i].cap -= t;\n    \t    E[i ^ 1].cap += t;\n    \t}\n    }\n    return flow;\n}\nbool modlabel() {\n    int64 p = -1e18;\n    for(int u = S ; u <= T ; ++u) {\n    \tif(vis[u]) {\n    \t    for(int i = head[u] ; i ; i = E[i].next) {\n        \t\tint v = E[i].to;\n        \t\tif(!vis[v] && E[i].cap > 0 && E[i].val > p) p = E[i].val;\n    \t    }\n    \t}\n    }\n    if(p == -1e18) return false;\n    ex += p;\n    for(int u = S ; u <= T ; ++u) {\n    \tif(vis[u]) {\n    \t    for(int i = head[u] ; i ; i = E[i].next) {\n        \t\tE[i].val -= p;\n        \t\tE[i ^ 1].val += p;\n    \t    }\n    \t}\n    }\n    return true;\n}\nvoid Init() {\n    read(N);\n    for(int i = 1 ; i <= N ; ++i) {\n    \tread(x[i]);read(y[i]);read(val[i]);\n    }\n    read(M);\n    for(int i = 1 ; i <= M ; ++i) {\n    \tscanf(\"%s\",s[i]);read(a[i]);read(b[i]);\n    }\n}\nvoid Solve() {\n    ans = 0;\n    for(int i = 1 ; i <= N ; ++i) {\n    \tbuild(i);\n    \tres = 0;ex = 0;\n        f = 0;\n    \tdo {\n    \t    do {\n                memset(vis,0,sizeof(vis));\n    \t    }while(maxflow(1,i));\n    \t}while(modlabel());\n        if(f == i) ans = max(ans,res);\n    }\n    out(ans);enter;\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Init();\n    Solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\nnamespace flow{\n\tconst ll __ = 1e6 + 7 , _ = 1e5 + 7;\n\tstruct Edge{ll end , upEd , f , c;}Ed[__];\n\tll head[_] , cntEd , S , T;\n\tvoid clear(){memset(head , 0 , sizeof(head)); cntEd = 1; S = T = 0;}\n\tvoid addEd(ll a , ll b , ll c , ll d){Ed[++cntEd] = (Edge){b , head[a] , c , d}; head[a] = cntEd;}\n\tvoid addE(ll a , ll b , ll c , ll d){addEd(a , b , c , d); addEd(b , a , 0 , -d);}\n\n\tbool vis[_]; queue < ll > q; ll dis[_] , pre[_];\n\tbool bfs(){\n\t\tq.push(S); memset(dis , -0x3f , sizeof(ll) * (T + 2)); dis[S] = 0;\n\t\twhile(!q.empty()){\n\t\t\tll t = q.front(); q.pop(); vis[t] = 0;\n\t\t\tfor(ll i = head[t] ; i ; i = Ed[i].upEd)\n\t\t\t\tif(Ed[i].f && dis[Ed[i].end] < dis[t] + Ed[i].c){\n\t\t\t\t\tdis[Ed[i].end] = dis[t] + Ed[i].c; pre[Ed[i].end] = i;\n\t\t\t\t\tif(!vis[Ed[i].end]){vis[Ed[i].end] = 1; q.push(Ed[i].end);}\n\t\t\t\t}\n\t\t}\n\t\treturn dis[T] != dis[T + 1];\n\t}\n\t\n\tll EK(ll s , ll t , ll tarf){\n\t\tS = s; T = t; ll sum = 0; ll fl = 0;\n\t\twhile(bfs()){++fl; ll cur = T; while(cur != S){ll t = pre[cur]; cur = Ed[t ^ 1].end; sum += Ed[t].c; --Ed[t].f; ++Ed[t ^ 1].f;}}\n\t\treturn fl == tarf ? sum : -1;\n\t}\n}\n\nll bound[2][2][103] , N , M , X[83] , Y[83]; ll v[83];\n\nsigned main(){\n\tcin >> N; for(ll i = 1 ; i <= N ; ++i) cin >> X[i] >> Y[i] >> v[i];\n\tcin >> M; memset(bound , 0x3f , sizeof(bound));\n\tfor(ll i = 1 ; i <= M ; ++i){\n\t\tchar c; ll p , q; cin >> c >> p >> q;\n\t\tswitch(c){\n\t\tcase 'L': bound[0][0][p] = min(bound[0][0][p] , q); break;\n\t\tcase 'R': bound[0][1][p] = min(bound[0][1][p] , q); break;\n\t\tcase 'U': bound[1][0][p] = min(bound[1][0][p] , q); break;\n\t\tcase 'D': bound[1][1][p] = min(bound[1][1][p] , q); break;\n\t\t}\n\t}\n\tll ans = 0;\n\tfor(ll i = 1 ; i <= N ; ++i){\n\t\tflow::clear(); bool flg = bound[0][0][100] >= i && bound[1][1][100] >= i; ll cnt = 0;\n\t\tfor(ll j = 1 ; j <= 100 ; ++j){\n\t\t\tll dwn = max(0ll , i - bound[0][0][j - 1]) , up = bound[0][1][j]; flg &= dwn <= up;\n\t\t\tcnt += dwn; flow::addE(j , j + 1 , dwn , (ll)1e16); flow::addE(j , j + 1 , up - dwn , 0);\n\t\t}\n\t\tfor(ll j = 100 ; j ; --j){\n\t\t\tll dwn = max(0ll , i - bound[1][1][j - 1]) , up = bound[1][0][j]; flg &= dwn <= up;\n\t\t\tcnt += dwn; flow::addE(202 - j , 203 - j , dwn , (ll)1e16); flow::addE(202 - j , 203 - j , up - dwn , 0);\n\t\t}\n\t\tfor(ll j = 1 ; j <= N ; ++j) flow::addE(X[j] , 202 - Y[j] , 1 , v[j]);\n\t\tflow::addE(0 , 1 , i , 0); if(flg) ans = max(ans , flow::EK(0 , 202 , i) - cnt * (ll)1e16);\n\t}\n\tcout << ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 100 , M = 400 , V = N + M << 1 , E = N + N * M * 2 + M * 2;\nconst long long INF = 0x3f3f3f3f3f3f3f3fLL;\nint n,m,x[N],y[N],a[N],b[N],u[N],d[N],l[N],r[N],pre[N]; char op[N];\nint t(1),Head[V],vis[V],S,T; deque <int> q; ll Delta,dis[V],v[N],Ans;\nstruct Edge { int u,v,next,val; ll cos; } e[E*4];\ntemplate<class T> inline T Read(void)\n{\n    T x = 0; bool w = 0; char ch = ' ';\n    while ( !isdigit(ch) ) w |= ch == '-' , ch = getchar();\n    while ( isdigit(ch) ) x = x * 10 + ch - 48 , ch = getchar();\n    return w ? -x : x;\n}\ninline void Input(void)\n{\n    n = Read<int>();\n    for (int i = 1; i <= n; i++)\n        x[i] = Read<int>() , y[i] = Read<int>() , v[i] = Read<ll>();\n    m = Read<int>();\n    for (int i = 1; i <= m; i++)\n    {\n        char c = ' ';\n        while ( isspace(c) ) c = getchar();\n        op[i] = c , a[i] = Read<int>() , b[i] = Read<int>();\n    }\n}\ninline void Insert(int x,int y,ll c,int v)\n{\n    e[++t] = (Edge){ x , y , Head[x] , v , c } , Head[x] = t;\n    e[++t] = (Edge){ y , x , Head[y] , 0 , -c } , Head[y] = t;\n}\ninline bool SPFA(long long &res)\n{\n    memset( dis , 0x3f , sizeof dis );\n    dis[S] = 0 , q.push_back(S);\n    while ( !q.empty() )\n    {\n        int u = q.front(); q.pop_front(); vis[u]=0;\n        for (int i = Head[u] , y; i; i = e[i].next)\n            if(e[i].val&&dis[y=e[i].v]>dis[u]+e[i].cos)\n            {\n                dis[y]=dis[u]+e[i].cos,pre[y]=i;\n                if(!vis[y])vis[y]=1 , q.push_back(y);\n            }\n    }\n    if(dis[T]==dis[0])return false;res+=dis[T];\n    for (int i=T;i!=S;i=e[pre[i]^1].v)--e[pre[i]].val,++e[pre[i]^1].val;\n    return true;\n}\ninline long long Build(int k)\n{\n    for (int i = 1; i <= k; i++)\n        u[i] = r[i] = 500 , l[i] = d[i] = 0;\n    for (int i = 1; i <= m; i++)\n        if ( b[i] < k )\n        {\n            if ( op[i] == 'L' ) l[b[i]+1] = max( l[b[i]+1] , a[i] + 1 );\n            if ( op[i] == 'R' ) r[k-b[i]] = min( r[k-b[i]] , a[i] - 1 );\n            if ( op[i] == 'D' ) d[b[i]+1] = max( d[b[i]+1] , a[i] + 1 );\n            if ( op[i] == 'U' ) u[k-b[i]] = min( u[k-b[i]] , a[i] - 1 );\n            // if ( op[i] == 'L' ) l[b[i]+1] = a[i] + 1;\n            // if ( op[i] == 'R' ) r[k-b[i]] = a[i] - 1;\n            // if ( op[i] == 'D' ) d[b[i]+1] = a[i] + 1;\n            // if ( op[i] == 'U' ) u[k-b[i]] = a[i] - 1;\n        }\n    for (int i = 2; i <= k; i++) l[i] = max( l[i] , l[i-1] ) , d[i] = max( d[i] , d[i-1] );\n    for (int i = k-1; i >= 1; i--) r[i] = min( r[i] , r[i+1] ) , u[i] = min( u[i] , u[i+1] );\n    memset( Head , 0 , sizeof Head );\n    S = ( n + k ) << 1 | 1 , T = ( n + k + 1 ) * 2 , t = 1 , Delta = 0;\n    for (int i = 1; i <= n; i++) Insert( i , i+n , -v[i]-1000000000000000LL , 1 );\n    for (int i = 1; i <= k; i++)\n    {\n        Insert( S , n*2+i , 0 , 1 ) , Insert( n*2+k+i , T , 0 , 1 );\n        for (int j = 1; j <= n; j++)\n        {\n            if ( l[i] <= x[j] && x[j] <= r[i] ) Insert( n*2+i , j , 0 , 1 );\n            if ( d[i] <= y[j] && y[j] <= u[i] ) Insert( j+n , n*2+k+i , 0 , 1 );\n        }\n    }\n    // printf( \"t = %d\\n\" , t );\n    long long ans = 0; while ( SPFA(ans) ); return -ans-1000000000000000LL*k;\n}\n\nint main(void)\n{\n    Input();\n    for (int i = 1; i <= n; i++)\n         Ans = max( Ans , Build(i) );\n    printf( \"%lld\\n\" , Ans );\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\ntypedef long double T; // long long double, Rational, long double + mod<P>...\ntypedef vector<T> vd;\ntypedef vector<vd> vvd;\n\ntypedef long double DOUBLE;\ntypedef vector<DOUBLE> VD;\ntypedef vector<VD> VVD;\ntypedef vector<int> VI;\nconst DOUBLE EPS = 1e-20;\nstruct LPSolver {\n\tint m, n; VI B, N; VVD D;\n\tLPSolver(const VVD &A, const VD &b, const VD &c) : m(b.size()), n(c.size()), N(n + 1), B(m), D(m + 2, VD(n + 2)) { for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) D[i][j] = A[i][j]; for (int i = 0; i < m; i++) { B[i] = n + i; D[i][n] = -1; D[i][n + 1] = b[i]; } for (int j = 0; j < n; j++) { N[j] = j; D[m][j] = -c[j]; } N[n] = -1; D[m + 1][n] = 1; }\n\tvoid Pivot(int r, int s) { long double inv = 1.0 / D[r][s]; for (int i = 0; i < m + 2; i++) if (i != r) for (int j = 0; j < n + 2; j++) if (j != s) D[i][j] -= D[r][j] * D[i][s] * inv; for (int j = 0; j < n + 2; j++) if (j != s) D[r][j] *= inv; for (int i = 0; i < m + 2; i++) if (i != r) D[i][s] *= -inv; D[r][s] = inv; swap(B[r], N[s]); }\n\tbool Simplex(int phase) { int x = phase == 1 ? m + 1 : m; while (true) { int s = -1; for (int j = 0; j <= n; j++) { if (phase == 2 && N[j] == -1) continue; if (s == -1 || D[x][j] < D[x][s] || D[x][j] == D[x][s] && N[j] < N[s]) s = j; }if (D[x][s] > -EPS) return true; int r = -1; for (int i = 0; i < m; i++) { if (D[i][s] < EPS) continue; if (r == -1 || D[i][n + 1] / D[i][s] < D[r][n + 1] / D[r][s] || (D[i][n + 1] / D[i][s]) == (D[r][n + 1] / D[r][s]) && B[i] < B[r]) r = i; }if (r == -1) return false; Pivot(r, s); } } \n\tDOUBLE Solve(VD &x) { int r = 0; for (int i = 1; i < m; i++) if (D[i][n + 1] < D[r][n + 1]) r = i; if (D[r][n + 1] < -EPS) { Pivot(r, n); if (!Simplex(1) || D[m + 1][n + 1] < -EPS) return -numeric_limits<DOUBLE>::infinity(); for (int i = 0; i < m; i++) if (B[i] == -1) { int s = -1; for (int j = 0; j <= n; j++) if (s == -1 || D[i][j] < D[i][s] || D[i][j] == D[i][s] && N[j] < N[s]) s = j; Pivot(i, s); } }if (!Simplex(2)) return numeric_limits<DOUBLE>::infinity(); x = VD(n); for (int i = 0; i < m; i++) if (B[i] < n) x[B[i]] = D[i][n + 1]; return D[m][n + 1]; }\n};\n\nint n, m, x[105], y[105];\nll v[105];\n\nvvd A0, A;\nvd b0, c0, t, b, c;\n\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> x[i] >> y[i] >> v[i];\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tt.clear();\n\t\tt.resize(n);\n\t\tt[i] = 1;\n\t\tA.push_back(t);\n\t\tb.push_back(1);\t\t\n\t}\n\tcin >> m;\n\tfor (int i = 0; i < m; ++i) {\n\t\tt.clear();\n\t\tt.resize(n);\n\t\tchar f;\n\t\tint a, bb;\n\t\tcin >> f >> a >> bb;\n\t\tif (f == 'L') {\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\tif (x[j] <= a)\n\t\t\t\t\tt[j] = 1;\n\t\t} if (f == 'R') {\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\tif (x[j] >= a)\n\t\t\t\t\tt[j] = 1;\n\t\t} if (f == 'U') {\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\tif (y[j] >= a)\n\t\t\t\t\tt[j] = 1;\n\t\t} if (f == 'D') {\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\tif (y[j] <= a)\n\t\t\t\t\tt[j] = 1;\n\t\t}\n\t\tA.push_back(t);\n\t\tb.push_back(bb);\n\t}\n\tc.resize(n);\n\tfor (int i = 0; i < n; ++i)\n\t\tc[i] = v[i];\n\tll ans = 0;\n\tfor (int i = 0; i <= n; ++i) {\n\t\tA0 = A, b0 = b, c0 = c;\n\t\tt.clear();\n\t\tt.resize(n);\n\t\tfor (int j = 0; j < n; ++j)\n\t\t\tt[j] = 1;\n\t\tA0.push_back(t);\n\t\tb0.push_back(i);\n\t\tfor (int j = 0; j < n; ++j)\n\t\t\tt[j] = -1;\n\t\tA0.push_back(t);\n\t\tb0.push_back(-i);\n\t\tvd xx;\n\t\tlong double h = LPSolver(A0, b0, c0).Solve(xx);\n\t\tans = max(ans, (ll)(h+.1));\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define itn int\n#define all(x) (x).begin(), (x).end()\n#define make_unique(x) sort(all((x))); (x).resize(unique(all((x))) - (x).begin())\n\n#define random_shuffle(...) shuffle(__VA_ARGS__, rng)\n#define rand() rng()\n\nusing namespace std;\n\ninline int nxt() {\n\tint x;\n\tscanf(\"%d\", &x);\n\treturn x;\n}\n\n#define sz(x) ((int) (x).size())\n#define forn(i,n) for (int i = 0; i < int(n); ++i)\n\ntypedef long long ll;\ntypedef long long i64;\ntypedef long double ld;\nconst int inf = int(1e9) + int(1e5);\nconst ll infl = ll(2e18) + ll(1e10);\n\nconst int maxn = 505;\nconst int maxm = 505;\n\nconst ld eps = 1e-14;\n\nbool eq(ld a, ld b) {\n    return fabsl(a - b) < eps;\n}\n\n//BEGIN_CODE\nnamespace Simplex {\n\nld D[maxm][maxn]; // [n+2][m+2]\nint B[maxm];\nint N[maxn];\nld x[maxn];\nint n, m;\n\n//x >= 0, Ax <= b, c^Tx -> max\nvoid init(int _n, int _m, ld A[][maxn], ld *b, ld *c) {\n    n = _n, m = _m;\n    forn (i, m)\n        forn (j, n)\n            D[i][j] = -A[i][j];\n    forn (i, m) {\n        D[i][n] = 1;\n        D[i][n + 1] = b[i];\n    }\n    forn (j, n) {\n        D[m][j] = c[j];\n        D[m + 1][j] = 0;\n    }\n    D[m][n + 1] = D[m][n] = D[m + 1][n + 1] = 0;\n    D[m + 1][n] = -1;\n    iota(B, B + m, n);\n    iota(N, N + n, 0);\n    N[n] = -1;\n}\n\nvoid pivot(int b, int nb) {\n    assert(D[b][nb] != 0);\n    ld q = 1. / -D[b][nb];\n    D[b][nb] = -1;\n    forn (i, n + 2)\n        D[b][i] *= q;\n    forn (i, m + 2) {\n        if (i == b)\n            continue;\n        ld coef = D[i][nb];\n        D[i][nb] = 0;\n        forn (j, n + 2)\n            D[i][j] += coef * D[b][j];\n    }\n    swap(B[b], N[nb]);\n}\n\nbool betterN(int f, int i, int j) {\n    if (eq(D[f][i], D[f][j]))\n        return N[i] < N[j];\n    return D[f][i] > D[f][j];\n}\n\nbool betterB(int nb, int i, int j) {\n    ld ai = D[i][n + 1] / D[i][nb];\n    ld aj = D[j][n + 1] / D[j][nb];\n    if (eq(ai, aj))\n        return B[i] < B[j];\n    return ai > aj;\n}\n\nbool simplex(int phase) {\n    int f = phase == 1 ? m : m + 1;\n    while (true) {\n        int nb = -1;\n        forn (i, n + 1) {\n            if (N[i] == -1 && phase == 1)\n                continue;\n            if (nb == -1 || betterN(f, i, nb))\n                nb = i;\n        }\n        if (D[f][nb] <= eps)\n            return phase == 1;\n        assert(nb != -1);\n\n        int b = -1;\n        forn (i, m) {\n            if (D[i][nb] >= -eps)\n                continue;\n            if (b == -1 || betterB(nb, i, b))\n                b = i;\n        }\n        if (b == -1)\n            return false;\n        pivot(b, nb);\n        if (N[nb] == -1 && phase == 2)\n            return true;\n    }\n}\n\nld solve() {\n    int b = -1;\n    forn (i, m) {\n        if (b == -1 || D[i][n + 1] < D[b][n + 1])\n            b = i;\n    }\n    assert(b != -1);\n    if (D[b][n + 1] < -eps) {\n        pivot(b, n);\n        if (!simplex(2) || D[m + 1][n + 1] < -eps)\n            return -infl;\n    }\n    if (!simplex(1))\n        return infl;\n\n    forn (i, n)\n        x[i] = 0;\n    forn (i, m)\n        if (B[i] < n)\n            x[B[i]] = D[i][n + 1];\n\n    return D[m][n + 1];\n}\n\n} //Simplex\n//END_CODE\n\nstruct Treasure {\n\tint x, y;\n\tlong long v;\n\n\tvoid scan() {\n\t\tscanf(\"%d%d%lld\", &x, &y, &v);\n\t}\n};\n\nstruct Constraint {\n\tchar t;\n\tint a, b;\n\n\tvoid scan() {\n\t\tcin >> t >> a >> b;\n\t}\n\n\tbool isAbout(const Treasure& tr) const {\n\t\tif (t == 'D') {\n\t\t\treturn tr.y <= a;\n\t\t} else if (t == 'U') {\n\t\t\treturn tr.y >= a;\n\t\t} else if (t == 'L') {\n\t\t\treturn tr.x <= a;\n\t\t} else if (t == 'R') {\n\t\t\treturn tr.x >= a;\n\t\t} else {\n\t\t\tassert(false);\n\t\t}\n\t}\n};\n\nld a[maxm][maxn];\nld b[maxm];\nld c[maxn];\n\nint main() {\n\tmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n\tint n = nxt();\n\tvector<Treasure> trs(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\ttrs[i].scan();\n\t}\n\n\tint m = nxt();\n\tvector<Constraint> crs(m);\n\tfor (int i = 0; i < m; ++i) {\n\t\tcrs[i].scan();\n\t}\n\n\tfor (int i = 0; i < m; ++i) {\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\ta[i][j] = crs[i].isAbout(trs[j]);\n\t\t}\n\t\tb[i] = crs[i].b;\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\ta[m + i][i] = 1;\n\t\tb[m + i] = 1;\n\t\tc[i] = trs[i].v;\n\t}\n\n\tSimplex::init(n, n + m, a, b, c);\n\t// Simplex::solve();\n\n\tlong double ans = Simplex::solve();\n\t// for (int i = 0; i < n; ++i) {\n\t// \tans += trs[i].v * (int)(roundl(Simplex::x[i]));\n\t// }\n\tcout << (long long)roundl(ans) << \"\\n\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<queue>\n#define MAXN 80\n#define MAXM 320\n#define MAXNODE 500\n#define MAXEDGE MAXNODE*MAXNODE\n#define INF 0x3FFFFFFF\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,LL> PII;\nstruct Point\n{\n\tint x,y;\n\tLL V;\n}poi[MAXN+5];\nstruct Limit\n{\n\tint typ,a,b;\n}lim[MAXM+5];\nstruct edge\n{\n\tint to,cap;\n\tLL cost;\n\tedge *nxt,*bck;\n}edges[MAXEDGE*2+5];\nedge *ncnt,*Adj[MAXNODE+5],*Cur[MAXNODE+5];\nint n,m;\nint dn[MAXN+5],up[MAXN+5];\nLL dist[MAXNODE+5];\nbool vis[MAXNODE+5];\nvoid Init()\n{\n\tncnt=&edges[0];\n\tmemset(Adj,0,sizeof(Adj));\n}\nvoid AddEdge(int u,int v,int cap,LL cost)\n{\n\tedge *p=++ncnt;\n\tp->to=v;p->cap=cap;p->cost=cost;\n\tp->nxt=Adj[u];Adj[u]=p;\n\t\n\tedge *q=++ncnt;\n\tq->to=u;q->cap=0;q->cost=-cost;\n\tq->nxt=Adj[v];Adj[v]=q;\n\t\n\tp->bck=q,q->bck=p;\n}\nbool SPFA(int S,int T,int nds)\n{\n\tstatic queue<int> que;\n\twhile(que.empty()==false)\tque.pop();\n\tfor(int i=S;i<=T;i++)\n\t\tvis[i]=false,dist[i]=-1LL;\n\tque.push(S);vis[S]=true;dist[S]=0;\n\twhile(que.empty()==false)\n\t{\n\t\tint u=que.front();\n\t\tque.pop();vis[u]=false;\n\t\tfor(edge *p=Adj[u];p!=NULL;p=p->nxt)\n\t\t{\n\t\t\tint v=p->to;\n\t\t\tif(p->cap&&dist[v]<dist[u]+p->cost)\n\t\t\t{\n\t\t\t\tdist[v]=dist[u]+p->cost;\n\t\t\t\tif(vis[v]==false)\n\t\t\t\t\tvis[v]=true,que.push(v);\n\t\t\t}\n\t\t}\n\t}\n\tif(dist[T]==-1)\n\t\treturn false;\n\treturn true;\n}\nint Aug(int T,int u,int tot,LL &ans)\n{\n\tif(u==T)\n\t\treturn tot;\n\tvis[u]=true;\n\tint sum=0,delta;\n\tfor(edge *&p=Cur[u];p!=NULL;p=p->nxt)\n\t{\n\t\tint v=p->to;\n\t\tif(!vis[v]&&p->cap&&dist[u]+p->cost==dist[v])\n\t\t{\n\t\t\tdelta=min(p->cap,tot-sum);\n\t\t\tdelta=Aug(T,v,delta,ans);\n\t\t\tsum+=delta;\n\t\t\tp->cap-=delta,p->bck->cap+=delta;\n\t\t\tans+=1LL*delta*p->cost;\n\t\t\tif(tot==sum)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tvis[u]=false;\n\treturn sum;\n}\nPII Max_Cost_Flow(int S,int T,int nds)\n{\n\tPII ret=PII(0,0);\n\tint tmn=0;\n\twhile(SPFA(S,T,nds))\n\t{\n\t\tfor(int i=S;i<=T;i++)\n\t\t\tCur[i]=Adj[i],vis[i]=false;\n\t\tret.first+=Aug(T,S,INF,ret.second);\n\t\ttmn++;\n\t}\n\treturn ret;\n}\nvoid DeBug(int S,int T)\n{\n\tprintf(\"===========BEGIN============\\n\");\n\tfor(int i=S;i<=T;i++)\n\t{\n\t\tprintf(\"%d:\",i);\n\t\tfor(edge *p=Adj[i];p!=NULL;p=p->nxt)\n\t\t\tif(p->cap)\n\t\t\t\tprintf(\"(%d %d %lld) \",p->to,p->cap,p->cost);\n\t\tprintf(\"\\n\");\n\t}\n\tprintf(\"============END=============\\n\");\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d %d %lld\",&poi[i].x,&poi[i].y,&poi[i].V);\n\tscanf(\"%d\",&m);\n\tchar opt[10];\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%s %d %d\",opt,&lim[i].a,&lim[i].b);\n\t\tif(opt[0]=='L')\tlim[i].typ=1;\n\t\tif(opt[0]=='R')\tlim[i].typ=2;\n\t\tif(opt[0]=='D')\tlim[i].typ=3;\n\t\tif(opt[0]=='U')\tlim[i].typ=4;\n\t}\n\tLL ans=0;\n\tfor(int tot=1;tot<=n;tot++)\n\t{\n\t\tInit();\n\t\tint nds=tot*2+200+2;\n\t\tint S=0,T=nds-1;\n\t\tfor(int i=1;i<=tot;i++)\n\t\t\tAddEdge(S,i,1,0),AddEdge(i+tot+200,T,1,0);\n\t\t//对于x这一维建边 \n\t\tfor(int i=1;i<=tot;i++)\n\t\t\tdn[i]=1,up[i]=100;\n\t\tfor(int i=1;i<=m;i++)\n\t\t\tif(lim[i].typ==1&&lim[i].b+1<=tot)\n\t\t\t\tdn[lim[i].b+1]=max(dn[lim[i].b+1],lim[i].a+1);\n\t\t\telse if(lim[i].typ==2&&tot-lim[i].b>=1)\n\t\t\t\tup[tot-lim[i].b]=min(up[tot-lim[i].b],lim[i].a-1);\n\t\tfor(int i=2;i<=tot;i++)\n\t\t\tdn[i]=max(dn[i-1],dn[i]);\n\t\tfor(int i=tot-1;i>=1;i--)\n\t\t\tup[i]=min(up[i+1],up[i]);\n\t\tfor(int i=1;i<=tot;i++)\n\t\t\tfor(int j=dn[i];j<=up[i];j++)\n\t\t\t\tAddEdge(i,tot+j,MAXN,0);\n\t\t//对于y这一维建边\n\t\tfor(int i=1;i<=tot;i++)\n\t\t\tdn[i]=1,up[i]=100;\n\t\tfor(int i=1;i<=m;i++)\n\t\t\tif(lim[i].typ==3&&lim[i].b+1<=tot)\n\t\t\t\tdn[lim[i].b+1]=max(dn[lim[i].b+1],lim[i].a+1);\n\t\t\telse if(lim[i].typ==4&&tot-lim[i].b>=1)\n\t\t\t\tup[tot-lim[i].b]=min(up[tot-lim[i].b],lim[i].a-1);\n\t\tfor(int i=2;i<=tot;i++)\n\t\t\tdn[i]=max(dn[i-1],dn[i]);\n\t\tfor(int i=tot-1;i>=1;i--)\n\t\t\tup[i]=min(up[i+1],up[i]);\n\t\tfor(int i=1;i<=tot;i++)\n\t\t\tfor(int j=dn[i];j<=up[i];j++)\n\t\t\t\tAddEdge(j+100+tot,i+200+tot,MAXN,0);\n\t\t//对于每一个点建边\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tAddEdge(tot+poi[i].x,100+tot+poi[i].y,1,poi[i].V);\n\t\tPII ret=Max_Cost_Flow(S,T,nds);\n\t\tif(ret.first==tot)\n\t\t\tans=max(ans,ret.second);\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cassert>\n\n#define pb push_back\n#define fir first\n#define sec second\n#define forto(_) for (int e = last[_], v = E[e].to; e; v = E[e = E[e].next].to)\n#define forback(_) for (int _ = T; _ ^ S; _ = pre[_])\n\ntypedef long long LL;\n\nconst int kMaxn = 85, kMaxe = 2e4;\nconst LL kInf64 = 1e15;\n\ntypedef std::pair<int, int> Pii;\ntypedef int IArn[kMaxn];\ntypedef int IArv[kMaxn << 2];\n\nstruct Edge {\n\tint to, capt;\n\tLL cost;\n\tint next;\n} E[kMaxe << 1];\n\nint n, m, tote, S, T;\nIArn X, Y, L, R, U, D;\nIArv last, pre, pree;\nLL V[kMaxn], dist[kMaxn << 2];\nstd::vector<Pii> con[4];\nchar IN[5];\n\ninline void AddEdge(int u, int v, int cap, LL cst) {\n\tE[++tote] = (Edge){v, cap, cst, last[u]}, last[u] = tote;\n\tE[++tote] = (Edge){u, 0, -cst, last[v]}, last[v] = tote;\n}\ntemplate <typename T>\nvoid Umin(T & x, T y) {\n\tx > y ? x = y : 0;\n}\ntemplate <typename T>\nvoid Umax(T & x, T y) {\n\tx < y ? x = y : 0;\n}\nLL Mcf(int);\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d%d%lld\", X + i, Y + i, V + i);\n\t}\n\tscanf(\"%d\", &m);\n\tfor (int i = 0, ai, bi; i < m; i++) {\n\t\tscanf(\"%s%d%d\", IN, &ai, &bi);\n\t\tswitch (IN[0]) {\n\t\t\tcase 'L' :\n\t\t\t\tcon[0].pb(Pii(ai, bi));\n\t\t\t\tbreak;\n\t\t\tcase 'R' :\n\t\t\t\tcon[1].pb(Pii(ai, bi));\n\t\t\t\tbreak;\n\t\t\tcase 'D' :\n\t\t\t\tcon[2].pb(Pii(ai, bi));\n\t\t\t\tbreak;\n\t\t\tcase 'U' :\n\t\t\t\tcon[3].pb(Pii(ai, bi));\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tL[i] = D[i] = 1;\n\t}\n\tfor (auto & p : con[0]) {\n\t\tUmax(L[p.sec + 1], p.fir + 1);\n\t}\n\tfor (auto & p : con[2]) {\n\t\tUmax(D[p.sec + 1], p.fir + 1);\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tUmax(L[i], L[i - 1]);\n\t\tUmax(D[i], D[i - 1]);\n\t}\n\n\tLL ans = 0;\n\tfor (int k = 1; k <= n; k++) {\n\t\tfor (int i = 1; i <= k; i++) {\n\t\t\tR[i] = U[i] = 100;\n\t\t}\n\t\tfor (auto & p : con[1]) {\n\t\t\tif (k <= p.sec) continue;\n\t\t\tUmin(R[k - p.sec], p.fir - 1);\n\t\t}\n\t\tfor (auto & p : con[3]) {\n\t\t\tif (k <= p.sec) continue;\n\t\t\tUmin(U[k - p.sec], p.fir - 1);\n\t\t}\n\t\tfor (int i = k - 1; i > 0; i--) {\n\t\t\tUmin(R[i], R[i + 1]);\n\t\t\tUmin(U[i], U[i + 1]);\n\t\t}\n\n\t\ttote = 1;\n\t\tmemset(last, 0, sizeof last);\n\t\tT = (S = k + n + n + k + 1) + 1;\n\t\tfor (int i = 1; i <= k; i++) {\n\t\t\tAddEdge(S, i, 1, 0);\n\t\t\tAddEdge(k + n + n + i, T, 1, 0);\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tif (L[i] <= X[j] && X[j] <= R[i]) {\n\t\t\t\t\tAddEdge(i, k + j, 1, 0);\n\t\t\t\t}\n\t\t\t\tif (D[i] <= Y[j] && Y[j] <= U[i]) {\n\t\t\t\t\tAddEdge(k + n + j, k + n + n + i, 1, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tAddEdge(k + i, k + n + i, 1, kInf64 - V[i]);\n\t\t}\n\n\t\tans = std::max(ans, Mcf(k));\n\t}\n\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n\nbool Spfa() {\n\tstatic std::queue<int> que;\n\tstatic int inque[kMaxn << 2];\n\n\tmemset(pre, 0xff, sizeof pre);\n\tmemset(dist, 0x7f, sizeof dist);\n\n\tfor (dist[S] = 0, que.push(S), inque[S] = 1; !que.empty(); ) {\n\t\tint u = que.front(); que.pop();\n\t\tforto(u) {\n\t\t\tif (E[e].capt > 0 && dist[v] > dist[u] + E[e].cost) {\n\t\t\t\tdist[v] = dist[u] + E[e].cost;\n\t\t\t\tpre[v] = u, pree[v] = e;\n\t\t\t\tif (!inque[v]) {\n\t\t\t\t\tque.push(v), inque[v] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tinque[u] = 0;\n\t}\n\treturn ~pre[T];\n}\n\nLL Mcf(int maxf) {\n\tLL tot = 0, sumf = 0;\n\twhile (Spfa()) {\n\t\tint flow = 100000;\n\t\tforback(u) {\n\t\t\tflow = std::min(flow, E[pree[u]].capt);\n\t\t}\n\t\ttot += 1ll * flow * dist[T], sumf += flow;\n\t\tforback(u) {\n\t\t\tE[pree[u]].capt -= flow;\n\t\t\tE[pree[u] ^ 1].capt += flow;\n\t\t}\n\t}\n\treturn sumf == maxf ? sumf * kInf64 - tot : 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nnamespace io{\n    const int l=1<<20;\n    char buf[l],*s,*t,c;\n    inline void gc(){\n        if(s==t){\n            t=(s=buf)+fread(buf,1,l,stdin);\n            c=s==t?EOF:*s++;\n        }else c=*s++;\n    }\n    template<class IT>inline void gi(IT &x){\n        x=0;gc();while(c<'0'||c>'9')gc();\n        while('0'<=c&&c<='9'){x=(x<<1)+(x<<3)+(c^48);gc();}\n    }\n    char buf0[20];int a;\n    template<class IT>inline void pi(IT x){\n        if(x<0){putchar('-');x=-x;}\n        do buf0[++a]=x%10+48;while(x/=10);\n        while(a)putchar(buf0[a--]);\n        putchar('\\n');\n    }\n};\nusing io::gi;\nusing io::pi;\ntypedef unsigned int ui;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<int,ll > pil;\ntypedef pair<ll ,int> pli;\ntypedef pair<ll ,ll > pll;\ntypedef vector<int> vi;\ntypedef vector<ll > vl;\n#define pque priority_queue\n#define rep(i,l,r) for(i=(l);i<=(r);++i)\n#define per(i,l,r) for(i=(l);i>=(r);--i)\n#define REP(i,l,r) for(i=(l);i< (r);++i)\n#define PER(i,l,r) for(i=(l);i> (r);--i)\n#define mp make_pair\n#define pb push_back\n#define pf push_front\n#define pob pop_back\n#define pof pop_front\n#define fi first\n#define se second\ntemplate<class IT>inline void cmax(IT &a,IT b){if(a<b)a=b;}\ntemplate<class IT>inline void cmin(IT &a,IT b){if(b<a)a=b;}\nconst int N=85,V=N<<2;const ll inf=-1000000000000000000ll;\nstruct edge{\n\tint u,w1;ll w2;int n;\n\tinline edge(){}\n\tinline edge(int u,int w1,ll w2,int n):u(u),w1(w1),w2(w2),n(n){}\n}e[N*V];int f[V],tot;\ninline void add(int v,int u,ll w2=0ll){\n\t//printf(\"%d %d %lld\\n\",v,u,w2);\n\te[tot]=edge(u,1, w2,f[v]);f[v]=(tot++);\n\te[tot]=edge(v,0,-w2,f[u]);f[u]=(tot++);\n}\nint q[V],in[V],p[V],pe[V];ll d[V];\ninline ll spfa(int S){\n\tint l=1,r=1,v,i,u;ll w;\n\tq[1]=S;\n\tREP(i,1,S)in[i]=0;\n\tREP(i,1,S)d[i]=inf;d[S]=0ll;//printf(\"d5=%lld\\n\",d[5]);\n\twhile(l<=r){\n\t\tin[v=q[(l++)%V]]=0;\n\t\tfor(i=f[v];~i;i=e[i].n)if(e[i].w1){\n\t\t\tu=e[i].u;\n\t\t\t//printf(\"v=%d -> u=%d dv=%lld du=%lld w=%lld\\n\",v,u,d[v],d[u],e[i].w2);\n\t\t\tif((w=d[v]+e[i].w2)>d[u]){\n\t\t\t\t//printf(\"v=%d -> u=%d in=%d\\n\",v,u,in[u]);\n\t\t\t\td[u]=w;\n\t\t\t\tp[u]=v;\n\t\t\t\tpe[u]=i;\n\t\t\t\tif(!in[u]){\n\t\t\t\t\tin[u]=1;\n\t\t\t\t\tq[(++r)%V]=u;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn d[S-1];\n}\nstruct jewel{\n\tint x,y;ll z;\n}J[N];\nstruct clue{\n\tint a,b;char c;\n}C[V];\nint lx[N],rx[N],ly[N],ry[N];\nint main(){\n    //freopen(\"a.in\",\"r\",stdin);\n    //freopen(\"a.out\",\"w\",stdout);\n    int n,m,i,j,k,v,u,ans1;ll ans2,ans=0ll,f2;\n\tchar str[2];\n    scanf(\"%d\",&n);\n    rep(i,1,n)scanf(\"%d%d%lld\",&J[i].x,&J[i].y,&J[i].z);\n\tscanf(\"%d\",&m);\n\trep(i,1,m){scanf(\"%s%d%d\",str,&C[i].a,&C[i].b);C[i].c=str[0];}\n\trep(k,1,n){\n\t\trep(i,1,k)lx[i]=1  ;\n\t\trep(i,1,k)rx[i]=100;\n\t\trep(i,1,k)ly[i]=1  ;\n\t\trep(i,1,k)ry[i]=100;\n\t\trep(i,1,m)if(C[i].b<k){\n\t\t\tswitch(C[i].c){\n\t\t\t\tcase 'L':cmax(lx[  C[i].b+1],C[i].a+1);break;\n\t\t\t\tcase 'R':cmin(rx[k-C[i].b  ],C[i].a-1);break;\n\t\t\t\tcase 'D':cmax(ly[  C[i].b+1],C[i].a+1);break;\n\t\t\t\tcase 'U':cmin(ry[k-C[i].b  ],C[i].a-1);break;\n\t\t\t}\n\t\t}\n\t\trep(i,2,k)cmax(lx[i  ],lx[i-1]);\n\t\trep(i,2,k)cmax(ly[i  ],ly[i-1]);\n\t\tper(i,k,2)cmin(rx[i-1],rx[i  ]);\n\t\tper(i,k,2)cmin(ry[i-1],ry[i  ]);\n\t\t//rep(i,1,k)printf(\"[%d,%d] [%d,%d]\\n\",lx[i],rx[i],ly[i],ry[i]);\n\t\tmemset(f,-1,sizeof(f));tot=0;\n\t\tv=(u=((n+k)<<1|1))+1;\n\t\trep(i,1,k)add(v,(n<<1)+i  );\n\t\trep(i,1,k)add(k+(n<<1)+i,u);\n\t\trep(i,1,n)add(i,i+n,J[i].z);\n\t\trep(i,1,k)rep(j,1,n){\n\t\t\tif(lx[i]<=J[j].x&&J[j].x<=rx[i])add(    (n<<1)+i,j);\n\t\t\tif(ly[i]<=J[j].y&&J[j].y<=ry[i])add(j+n,(n<<1)+i+k);\n\t\t}\n\t\tans1=0;ans2=0ll;\n\t\twhile((f2=spfa(v))!=inf){\n\t\t\t//printf(\"f2=%lld\\n\",f2);\n\t\t\t++ans1;\n\t\t\tans2+=f2;\n\t\t\tfor(i=u;i!=v;i=p[i]){\n\t\t\t\t//printf(\"(%d,%d) \",i,pe[i]);\n\t\t\t\te[pe[i]  ].w1=0;\n\t\t\t\te[pe[i]^1].w1=1;\n\t\t\t}\n\t\t\t//puts(\"\");\n\t\t}\n\t\t//printf(\"k=%d ans1=%d ans2=%lld\\n\",k,ans1,ans2);\n\t\tif(ans1!=k)break;cmax(ans,ans2);\n\t}\n\tprintf(\"%lld\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\ntemplate<typename T>\nstruct PrimalDual{\n  struct edge{\n    Int to;\n    T cap,cost;\n    Int rev;\n    edge(){}\n    edge(Int to,T cap,T cost,Int rev):to(to),cap(cap),cost(cost),rev(rev){}\n  };\n  \n  T INF;\n  array<vector<edge>, 400> G;\n  vector<T> h,dist;\n  vector<Int> prevv,preve;\n\n  PrimalDual(){}\n  PrimalDual(Int n,T INF):INF(INF),h(n),dist(n),prevv(n),preve(n){}\n  \n  void add_edge(Int from,Int to,T cap,T cost){\n    G[from].emplace_back(to,cap,cost,G[to].size());\n    G[to].emplace_back(from,0,-cost,G[from].size()-1);\n  }\n\n  T flow(Int s,Int t,T f,Int &ok){    \n    T res=0;\n    fill(h.begin(),h.end(),0);\n    while(f>0){\n      using P = pair<T, Int>;\n      priority_queue<P,vector<P>,greater<P> > que;\n      fill(dist.begin(),dist.end(),INF);\n      \n      dist[s]=0;\n      que.emplace(dist[s],s);\n      while(!que.empty()){\n        P p=que.top();que.pop();\n        Int v=p.second;\n        if(dist[v]<p.first) continue;\n        for(Int i=0;i<(Int)G[v].size();i++){\n          edge &e=G[v][i];\n          if(e.cap==0) continue;\n          if(dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n            dist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n            prevv[e.to]=v;\n            preve[e.to]=i;\n            que.emplace(dist[e.to],e.to);\n          }\n        }\n      }\n      if(dist[t]==INF) return ok=0;\n      \n      for(Int v=0;v<(Int)h.size();v++) h[v]+=dist[v];\n\n      T d=f;\n      for(Int v=t;v!=s;v=prevv[v])\n        d=min(d,G[prevv[v]][preve[v]].cap);\n      \n      f-=d;\n      res+=d*h[t];\n      for(Int v=t;v!=s;v=prevv[v]){\n        edge &e=G[prevv[v]][preve[v]];\n        e.cap-=d;\n        G[v][e.rev].cap+=d;\n      }\n    }\n    ok=1;\n    return res;\n  }\n};\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<Int> xs(n),ys(n),vs(n);\n  for(Int i=0;i<n;i++) cin>>xs[i]>>ys[i]>>vs[i];\n\n  Int m;\n  cin>>m;\n  vector<char> ts(m);\n  vector<Int> as(m),bs(m);\n  for(Int i=0;i<m;i++) cin>>ts[i]>>as[i]>>bs[i];\n\n  const Int INF = 1e16;\n  vector<Int> ls(n,-INF),rs(n,INF),ds(n,-INF),us(n,INF);\n  for(Int i=0;i<m;i++){\n    if(ts[i]=='L') chmax(ls[bs[i]],as[i]);\n    if(ts[i]=='R') chmin(rs[bs[i]],as[i]);\n    if(ts[i]=='D') chmax(ds[bs[i]],as[i]);\n    if(ts[i]=='U') chmin(us[bs[i]],as[i]);\n  }\n  for(Int i=0;i+1<n;i++){\n    chmax(ls[i+1],ls[i]);\n    chmin(rs[i+1],rs[i]);\n    chmax(ds[i+1],ds[i]);\n    chmin(us[i+1],us[i]);\n  }\n  \n  Int ans=0;\n  for(Int k=1;k<=n;k++){\n    PrimalDual<Int> G(k*2+n*2+2,INF);\n    Int S=k*2+n*2,T=k*2+n*2+1;\n    for(Int i=0;i<k;i++){\n      G.add_edge(S,i,1,0);\n      G.add_edge(k+i,T,1,0);\n    }    \n    \n    for(Int p=0;p<n;p++){\n      G.add_edge(k*2+p,k*2+n+p,1,INF-vs[p]);      \n      for(Int i=0;i<k;i++){\n        for(Int j=0;j<k;j++){\n          if(xs[p]<=ls[i]) continue;\n          if(xs[p]>=rs[k-(i+1)]) continue;\n          if(ys[p]<=ds[j]) continue;\n          if(ys[p]>=us[k-(j+1)]) continue;          \n          G.add_edge(i,k*2+p,1,0);     \n          G.add_edge(k*2+n+p,k+j,1,0);\n        }\n      }\n    }\n    \n    Int ok=1;\n    Int res=G.flow(S,T,k,ok);    \n    if(!ok) break;\n    chmax(ans,INF*k-res);\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace __gnu_pbds;\nusing namespace std;\n \ntemplate <typename T>\nusing ordered_set =\n\ttree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n \n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n\t*this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n \n#define shandom_ruffle random_shuffle\n \nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=327;\nusing bn=bitset<87>;\nusing ld=long double;\n\nint n;\npii gdz[nax];\nll war[nax];\n\nint m;\nbn podz[nax];\nint ile[nax];\n\nll wyn;\n\nstruct Simplex {        // Maximize c*x subject to Ax <= b.\n  using T = ld;     // Initialize the structure, set A, b, c and then run\n  vector<vector<T>> A;  // solve(). Max objective is stored in res. To recover\n  vector<T> b, c;       // the best result, use getVars().\n  int V, E;\n  vector<int> eqIds, varIds, cols;\n  T res;\n  static constexpr T kEps = 1e-5;\n\n  Simplex(int vars, int eqs) : A(eqs, vector<T>(vars)), b(eqs), c(vars),\n      V(vars), E(eqs), eqIds(eqs), varIds(vars), res(0) {\n    iota(varIds.begin(), varIds.end(), 0);\n    iota(eqIds.begin(), eqIds.end(), vars);\n  }\n\n  void pivot(int eq, int var) {\n    T coef = 1 / A[eq][var];\n    cols.clear();\n    for (int i = 0; i < V; i++) {\n      if (abs(A[eq][i]) > kEps) { cols.push_back(i); A[eq][i] *= coef; }\n    }\n    A[eq][var] *= coef; b[eq] *= coef;\n    for (int row = 0; row < E; row++) {\n      if (row == eq || abs(A[row][var]) < kEps) { continue; }\n      T k = -A[row][var];\n      A[row][var] = 0;\n      for (int i : cols) { A[row][i] += k * A[eq][i]; }\n      b[row] += k * b[eq];\n    }\n    T q = c[var]; c[var] = 0;\n    for (int i : cols) { c[i] -= q * A[eq][i]; }\n    res += q * b[eq];\n    swap(varIds[var], eqIds[eq]);\n  }\n\n  bool solve() {\n    while (true) {\n      int eq = -1, var = -1;\n      for (int i = 0; i < E; i++) { if (b[i] < -kEps) { eq = i; break; } }\n      if (eq == -1) { break; }\n      for (int i = 0; i < V; i++) { if (A[eq][i] < -kEps) { var = i; break; } }\n      if (var == -1) { res = -1e9; return false; /* No solution */ }\n      pivot(eq, var);\n    }\n    while (true) {\n      int var = -1, eq = -1;\n      for (int i = 0; i < V; i++) { if (c[i] > kEps) { var = i; break; } }\n      if (var == -1) { break; }\n      for (int i = 0; i < E; i++) {\n        if (A[i][var] < kEps) { continue; }\n        if (eq >= 0 && b[i] / A[i][var] >= b[eq] / A[eq][var]) { continue; }\n        eq = i;\n      }\n      if (eq == -1) { res = 1e9; return false; /* Unbounded */ }\n      pivot(eq, var);\n    }\n    return true;\n  }\n\n  vector<T> getVars() { // Optimal assignment of variables.\n    vector<T> result(V);\n    for (int i = 0; i < E; i++) if (eqIds[i] < V) result[eqIds[i]] = b[i];\n    return result;\n  }\n};\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(\"%d%d%lld\", &gdz[i].first, &gdz[i].second, &war[i]);\n\tscanf(\"%d\", &m);\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\tchar c;\n\t\tint a, b;\n\t\tscanf(\" %c%d%d\", &c, &a, &b);\n\t\tfor (int j=1; j<=n; j++)\n\t\t{\n\t\t\tif (c=='L' && gdz[j].first<=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='R' && gdz[j].first>=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='D' && gdz[j].second<=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='U' && gdz[j].second>=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t}\n\t\tile[i]=b;\n\t}\n\tSimplex janusz(n, m+2*n);\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tjanusz.c[i]=war[i+1];\n\t}\n\tfor (int i=0; i<m; i++)\n\t{\n\t\tjanusz.b[i]=ile[i+1];\n\t\tfor (int j=0; j<n; j++)\n\t\t\tjanusz.A[i][j]=podz[i+1][j+1];\n\t}\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tjanusz.b[m+i]=1;\n\t\tjanusz.A[m+i][i]=1;\n\t}\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tjanusz.b[m+n+i]=0;\n\t\tjanusz.A[m+n+i][i]=-1;\n\t}\n\tassert(janusz.solve());\n\tld wez=janusz.res;\n\tdebug() << imie(wez);\n\tdebug() << janusz.getVars();\n\tprintf(\"%lld\\n\", llround(wez));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define all(x) (x).begin (),(x).end()\n#define sqrt(x) sqrt(abs(x))\n#define re return\n#define sz(x) ((int)(x).size ())\n#define prev PREV\n#define next NEXT\n\nusing ll = long long;\nusing ii = pair<int, int>;\nusing ld = long double;\nusing D = double;\nusing vi = vector<int>;\nusing vii = vector<ii>;\nusing vvi = vector<vi>;\nusing vs = vector<string>;\n\ntemplate<typename T> T abs (T x) { re x < 0 ? -x : x; }\ntemplate<typename T> T sgn (T x) { re x < 0 ? -1 : (x > 0 ? 1 : 0); }\ntemplate<typename T> T sqr (T x) { re x * x; }\ntemplate<typename T> T gcd (T a, T b) { re a != 0 ? gcd (b % a, a) : b; }\n\nconst int inf = 1e9;\nconst ll INF = 1e15;\n\nint n;\nint m;\nint o, e;\nint x[100];\nint y[100];\nll val[100];\nint a[100];\nint b[100];\nstring t[100];\nvi vx, vy;\nint lx[110];\nint rx[110];\nint ly[110];\nint ry[110];\n\nvii v[600];\nint ec[10000];\nll ef[10000];\nll d[600];\nll p[600];\nint mark[600];\nint prev[600];\nint preve[600];\nset<pair<ll, int> > all;\n\n\nvoid addedge (int a, int b, int c, ll d) {\n//\tprintf (\"%d %d %d %I64d\\n\", a, b, c, d);\n\tv[a].pb (mp (b, e));\n\tec[e] = c;\n\tef[e] = d;\n\te++;\n\tv[b].pb (mp (a, e));\n\tec[e] = 0;\n\tef[e] = -d;\n\te++;\n}\n\nll go (int S, int T) {\n\tall.clear ();\n\tfor (int i = 0; i < o; i++) {\n\t\tmark[i] = 0;\n\t\td[i] = 1e18;\n\t}\n\tmark[S] = 1;\n\td[S] = 0;\n\tall.insert (mp (0, S));\n\twhile (!all.empty ()) {\n\t\tint x = all.begin ()->se;\n//\t\tprintf (\"%d\\n\", x);\n\t\tmark[x] = 2;\n\t\tall.erase (all.begin ());\n\t\tfor (int i = 0; i < sz (v[x]); i++) {\n\t\t\tint y = v[x][i].fi;\n\t\t\tint z = v[x][i].se;\n\t\t\tif (ec[z] > 0 && d[x] + p[x] + ef[z] - p[y] < d[y]) {\n\t\t\t\tif (mark[y] == 1) all.erase (mp (d[y], y));\n\t\t\t\td[y] = d[x] + p[x] + ef[z] - p[y];\n\t\t\t\tprev[y] = x;\n\t\t\t\tpreve[y] = z;\n\t\t\t\tmark[y] = 1;\n\t\t\t\tall.insert (mp (d[y], y));\n\t\t\t}\n\t\t}\n\t}\n\tif (mark[T] == 0) re -1;\n\tll ans = d[T] - p[S] + p[T];\n\tfor (int i = 0; i < o; i++)\n\t\tif (mark[i])\n\t\t\tp[i] += d[i];\n\tre ans;\n}\n\nll calc (int h) {\n\tint ox = sz (vx);\n\tint oy = sz (vy);\n\tfor (int i = 0; i < ox; i++) {\n\t\tlx[i] = 0;\n\t\trx[i] = h;\n\t\tfor (int j = 0; j < m; j++)\n\t\t\tif (t[j] == \"L\") {\n\t\t\t\tif (vx[i] <= a[j]) rx[i] = min (rx[i], b[j]);\n\t\t\t} else\n\t\t\tif (t[j] == \"R\") {\n\t\t\t\tif (vx[i] >= a[j] - 1) lx[i] = max (lx[i], h - b[j]);\n\t\t\t}\n\t\tif (lx[i] > rx[i]) re -1;\t\n\t}\n\tfor (int i = 0; i < oy; i++) {\n\t\tly[i] = 0;\n\t\try[i] = h;\n\t\tfor (int j = 0; j < m; j++)\n\t\t\tif (t[j] == \"D\") {\n\t\t\t\tif (vy[i] <= a[j]) ry[i] = min (ry[i], b[j]);\n\t\t\t} else\n\t\t\tif (t[j] == \"U\") {\n\t\t\t\tif (vy[i] >= a[j] - 1) ly[i] = max (ly[i], h - b[j]);\n\t\t\t}\n\t\tif (ly[i] > ry[i]) re -1;\t\n\t}\n\to = 2 * ox + 2 * oy + 2 * n + 5;\n\te = 0;\n\tfor (int i = 0; i < o; i++) v[i].clear ();\n\tint req = 0;\n\taddedge (o - 4, 2 * n + 2 * (ox - 1), inf, 0);\n\tfor (int i = 0; i < ox; i++) {\n//\t\tprintf (\"x %d: %d %d\\n\", vx[i], lx[i], rx[i]);\n\t\treq += lx[i];\n\t\taddedge (2 * n + 2 * i, 2 * n + 2 * i + 1, rx[i] - lx[i], 0);\n\t\taddedge (o - 2, 2 * n + 2 * i + 1, lx[i], 0);\n\t\taddedge (2 * n + 2 * i, o - 1, lx[i], 0);\n\t\tif (i > 0) addedge (2 * n + 2 * i + 1, 2 * n + 2 * (i - 1), inf, 0);\n\t}\n\taddedge (2 * n + 2 * ox + 2 * (oy - 1) + 1, o - 3, inf, 0);\n\tfor (int i = 0; i < oy; i++) {\n//\t\tprintf (\"y %d: %d %d\\n\", vy[i], ly[i], ry[i]);\n\t\treq += ly[i];\n\t\taddedge (2 * n + 2 * ox + 2 * i, 2 * n + 2 * ox + 2 * i + 1, ry[i] - ly[i], 0);\n\t\taddedge (o - 2, 2 * n + 2 * ox + 2 * i + 1, ly[i], 0);\n\t\taddedge (2 * n + 2 * ox + 2 * i, o - 1, ly[i], 0);\n\t\tif (i > 0) addedge (2 * n + 2 * ox + 2 * (i - 1) + 1, 2 * n + 2 * ox + 2 * i, inf, 0);\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\taddedge (2 * i, 2 * i + 1, 1, INF - val[i]);\n\t\tint j = 0;\n\t\twhile (vx[j] < x[i]) j++;\n\t\taddedge (2 * n + 2 * j + 1, 2 * i, inf, 0);\n\t\tj = 0;\n\t\twhile (vy[j] < y[i]) j++;\n\t\taddedge (2 * i + 1, 2 * n + 2 * ox + 2 * j, inf, 0);\n\t}\n\treq += h;\n\taddedge (o - 3, o - 5, inf, 0);\n\taddedge (o - 2, o - 4, h, 0);\n\taddedge (o - 5, o - 1, h, 0);\n\tll ans = 0;\n\tfor (int i = 0; i < o; i++) p[i] = 0;\n\tfor (int i = 0; i < req; i++) {\n\t\tll tmp = go (o - 2, o - 1);\n//\t\tprintf (\"%d: %d = %I64d\\n\", h, i, INF - tmp);\n\t\tif (tmp == -1) re -1;\n\t\tans += tmp;\n\t\tint j = o - 1;\n\t\twhile (j != o - 2) {\n\t\t\tint k = prev[j];\n\t\t\tint z = preve[j];\n\t\t\tec[z]--;\n\t\t\tec[z ^ 1]++;\n//\t\t\tprintf (\"%d -> %d = %d\\n\", k / 2, j / 2, ec[z]);\n\t\t\tj = k;\n\t\t}\n\t}\n\tll tmp = go (o - 2, o - 1);\n\tre h * INF - ans;\n}\n\nint main () {\n\tcin >> n;\n\tfor (int i = 0; i < 100; i++) {\n\t\tvx.pb (i + 1);\n\t\tvy.pb (i + 1);\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x[i] >> y[i] >> val[i];\n\t\tvx.pb (x[i]);\n\t\tvy.pb (y[i]);\n\t}\t\n\tcin >> m;\n\tfor (int i = 0; i < m; i++) {\n\t\tcin >> t[i] >> a[i] >> b[i];\n\t\tif (t[i] == \"L\" || t[i] == \"R\") vx.pb (a[i]); else vy.pb (a[i]);\n\t}\t\n\tsort (all (vx));\n\tvx.resize (unique (all (vx)) - vx.begin ());\n\tsort (all (vy));\n\tvy.resize (unique (all (vy)) - vy.begin ());\n\tll ans = 0;\n\tfor (int t = 0; t <= n; t++) {\n\t\tll tmp = calc (t);\n\t\tans = max (ans, tmp);\n//\t\tcout << t << \" \" << tmp << endl;\n\t}\t\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n\n#define fo(i,j,l) for(int i=j;i<=l;++i)\n#define fd(i,j,l) for(int i=j;i>=l;--i)\n#define eps 1e-2\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double db;\nconst ll N=600;\nconst db sj=5e-18;\n\nint f1[N],f2[N];\nint s1[N],s2[N];\nint w[N];\nll x[N],y[N],v[N];\n\nint n,m,oo,a,b,o2;\ndb c[N],s[N][N];\nint bh[N];\ndb d[N];\nint dl[N];\nint g,gs;\ndb ans=0;\nll da=0;\n\ninline db iabs(db gg)\n{return (gg<0)?(-gg):gg;}\n\ninline void trans(int h,int k)\n{\n\tint u=bh[h]; bh[h]=k;\n\tdb xs=-s[h][k];\n\ts[h][k]=0; s[h][u]=-1;\n\tfo(i,1,g)s[h][i]=s[h][i]/xs;\n\tc[h]=c[h]/xs;\n\tfo(i,1,gs)if(i!=h&&s[i][k]!=0&&iabs(s[i][k])>sj){\n\t\tfo(l,1,g)s[i][l]=s[i][l]+s[i][k]*s[h][l];\n\t\tc[i]=c[i]+c[h]*s[i][k];\n\t\ts[i][k]=0;\n\t}\n\tfo(i,1,g)d[i]=d[i]+d[k]*s[h][i];\n\tans=ans+d[k]*c[h];\n\td[k]=0;\n}\n\ninline int find()\n{\n\tint po=0; d[0]=sj;\n\tfo(i,1,g)if(d[i]>d[po])po=i;\n\treturn po;\n}\n\ninline void Simplex()\n{\n\tint x;\n\twhile((x=find())!=0){\n\t\tdouble zd=100000000;\n\t\tint po=0;\n\t\tfo(i,1,gs)if(s[i][x]<-sj)if(c[i]/(-s[i][x])<zd)zd=c[i]/(-s[i][x]),po=i;\n\t\tif(!po)break;\n\t\ttrans(po,x);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfo(i,1,n){\n\t\tscanf(\"%lld%lld%lld\",&x[i],&y[i],&v[i]);\n\t}\n\tfo(i,1,n)d[i]=v[i];\n\tscanf(\"%d\",&gs); m=gs;\n\tfo(i,1,m){\n\t\tchar ch=' ';\n\t\tfor(;ch!='L'&&ch!='R'&&ch!='U'&&ch!='D';ch=getchar());\n\t\tint aa,bb;\n\t\tscanf(\"%d%d\",&aa,&bb);\n\t\tc[i]=bb;\n\t\tif(ch=='L'){fo(l,1,n)if(x[l]<=aa)s[i][l]=-1;}\n\t\tif(ch=='R'){fo(l,1,n)if(x[l]>=aa)s[i][l]=-1;}\n\t\tif(ch=='D'){fo(l,1,n)if(y[l]<=aa)s[i][l]=-1;}\n\t\tif(ch=='U'){fo(l,1,n)if(y[l]>=aa)s[i][l]=-1;}\t\t\n\t}\n\tfo(i,1,n){\n\t\t++gs; c[gs]=1;\n\t\ts[gs][i]=-1;\n\t}\n\tg=m+n;\n\tSimplex();\n\tll da=(ll)(ans+eps);\n\tif(da<0)puts(\"-1\");else cout<<da;\n}"
  },
  {
    "language": "C++",
    "code": "// This amazing code is by Eric Sunli Chen.\n#include<bits/stdc++.h>\nusing namespace std;\ntemplate<typename T> bool get_int(T &x)\n{\n\tchar t=getchar();\n\tbool neg=false;\n\tx=0;\n\tfor(; (t>'9'||t<'0')&&t!='-'&&t!=EOF; t=getchar());\n\tif(t=='-')neg=true,t=getchar();if(t==EOF)return false;\n\tfor(; t<='9'&&t>='0'; t=getchar())x=x*10+t-'0';\n\tif(neg)x=-x;return true;\n}\ntemplate<typename T> void print_int(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tshort a[20]= {},sz=0;\n\twhile(x>0)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1; i>=0; i--)putchar('0'+a[i]);\n}\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define get1(a) get_int(a)\n#define get2(a,b) (get1(a)&&get1(b))\n#define get3(a,b,c) (get1(a)&&get2(b,c))\n#define printendl(a) print_int(a),puts(\"\")\ntypedef long long LL;\ntypedef unsigned long long uLL;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\nconst int inf=0x3f3f3f3f;\nconst LL Linf=1ll<<61;\nconst double pi=acos(-1.0);\n\nconst int maxn=233;\nconst int maxm=100111;\nstruct mincost_flow\n{\n\tstruct edge{int to,cap;LL cost;};\n\tint head[maxn],nxt[maxm<<1],iter[maxn],tot=1;\n\tedge e[maxm<<1];\n\tvoid addedge(int u,int v,int cap,LL cost)\n\t{\n//\t\tprintf(\"Edge %d %d %d %lld\\n\",u,v,cap,cost);\n\t\tnxt[++tot]=head[u];\n\t\thead[u]=tot;\n\t\te[tot]=edge{v,cap,cost};\n\t\tnxt[++tot]=head[v];\n\t\thead[v]=tot;\n\t\te[tot]=edge{u,0,-cost};\n\t}\n\tvoid clear()\n\t{\n\t\tmemset(head,0,sizeof(head));\n\t\ttot=1;\n\t}\n\tbool inq[maxn];int q[maxn],pre[maxn];\n\tLL dist[maxn];\n\tvoid spfa(int s)\n\t{\n\t\tmemset(dist,0x3f,sizeof(dist));\n\t\tdist[s]=0;int fr=0,rr=0;q[rr++]=s;\n\t\twhile(fr!=rr)\n\t\t{\n\t\t\tint x=q[fr++];if(fr==maxn)fr=0;\n\t\t\tinq[x]=0;\n\t\t\tfor(int i=head[x];i;i=nxt[i])if(e[i].cap&&dist[e[i].to]>dist[x]+e[i].cost)\n\t\t\t{\n\t\t\t\tdist[e[i].to]=dist[x]+e[i].cost;\n\t\t\t\tpre[e[i].to]=i;\n\t\t\t\tif(!inq[e[i].to])\n\t\t\t\t{\n\t\t\t\t\tinq[e[i].to]=1;\n\t\t\t\t\tif(fr==rr||dist[q[fr]]<=dist[e[i].to])\n\t\t\t\t\t{\n\t\t\t\t\t\tq[rr++]=e[i].to;\n\t\t\t\t\t\tif(rr==maxn)rr=0;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif(fr==0)fr=maxn;\n\t\t\t\t\t\tq[--fr]=e[i].to;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tLL augment(int t,int s,int&f)\n\t{\n\t\tint d=f,cur;\n\t\tfor(cur=t;cur!=s;cur=e[pre[cur]^1].to)d=min(d,e[pre[cur]].cap);\n\t\tf-=d;\n\t\tfor(cur=t;cur!=s;cur=e[pre[cur]^1].to)\n\t\t{\n\t\t\te[pre[cur]].cap-=d;\n\t\t\te[pre[cur]^1].cap+=d;\n\t\t}\n\t\treturn dist[t]*d;\n\t}\n\tLL mincostflow(int s,int t,int f)\n\t{\n\t\tLL ret=0;\n\t\twhile(f)\n\t\t{\n\t\t\tspfa(s);\n\t\t\tif(dist[t]==0x3f3f3f3f3f3f3f3fll)return 0;\n\t\t\tret+=augment(t,s,f);\n\t\t}\n\t\treturn ret;\n\t}\n}thor;\n\nint n,m,x[111],y[111];LL v[111];\nint tp[411],a[411],b[411];\n\nint l[111],r[111],ll[111],rr[111];\nLL calc(int sz)\n{\n\tthor.clear();int NUM=101,s=NUM+NUM+1,t=s+1,S=t+1,T=S+1;\n\tfor(int i=1;i<=n;i++)thor.addedge(x[i],y[i]+NUM,1,-v[i]);\n\tfor(int i=0;i<NUM;i++)\n\t{\n\t\tl[i]=ll[i]=0;\n\t\tr[i]=rr[i]=sz;\n\t}\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tif(tp[i]==0)r[a[i]]=min(r[a[i]],b[i]);\n\t\telse if(tp[i]==1)l[a[i]-1]=max(l[a[i]-1],sz-b[i]);\n\t\telse if(tp[i]==2)rr[a[i]]=min(rr[a[i]],b[i]);\n\t\telse if(tp[i]==3)ll[a[i]-1]=max(ll[a[i]-1],sz-b[i]);\n\t}\n\tfor(int i=0;i<NUM;i++)if(l[i]>r[i]||ll[i]>rr[i])return 0;\n\tif(l[0]||ll[0])return 0;\n\t\n\tint sum=sz;\n\tthor.addedge(s,NUM,sz,0);\n\tthor.addedge(NUM+NUM,t,sz,0);\n\tthor.addedge(S,s,sz,0);\n\tthor.addedge(t,T,sz,0);\n\tfor(int i=NUM-1;i>=1;i--)\n\t{\n\t\tif(l[i]<r[i])thor.addedge(i+1,i,r[i]-l[i],0);\n\t\tif(l[i])\n\t\t{\n\t\t\tthor.addedge(S,i,l[i],0);\n\t\t\tthor.addedge(i+1,T,l[i],0);\n\t\t\tsum+=l[i];\n\t\t}\n\t}\n\tfor(int i=NUM-1;i>=1;i--)\n\t{\n\t\tif(ll[i]<rr[i])thor.addedge(i+NUM,i+NUM+1,rr[i]-ll[i],0);\n\t\tif(ll[i])\n\t\t{\n\t\t\tthor.addedge(S,i+NUM+1,ll[i],0);\n\t\t\tthor.addedge(i+NUM,T,ll[i],0);\n\t\t\tsum+=ll[i];\n\t\t}\n\t}\n\tLL ret=thor.mincostflow(S,T,sum);\n\treturn -ret;\n}\n\nint main()\n{\n\tget1(n);\n\tfor(int i=1;i<=n;i++)get3(x[i],y[i],v[i]);\n\tget1(m);\n\tchar op[4];\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%s\",op);get2(a[i],b[i]);\n\t\tif(op[0]=='L')tp[i]=0;\n\t\telse if(op[0]=='R')tp[i]=1;\n\t\telse if(op[0]=='D')tp[i]=2;\n\t\telse tp[i]=3;\n\t}\n\tLL ans=0;\n\tfor(int i=1;i<=n;i++)ans=max(ans,calc(i));\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nint S=0,T;\nint N;\nstruct edge{\n\tint s,t,cap;long long v;int nxt;\n}e[50005];\nint e_cnt,last[405];\nvoid addedge(int u,int v,int cap,long long l){\n\te[e_cnt]=(edge){u,v,cap,l,last[u]};\n\tlast[u]=e_cnt++;\n\te[e_cnt]=(edge){v,u,0,-l,last[v]};\n\tlast[v]=e_cnt++;\n}\nlong long d[405];int fa[405];\nbool vis[405];\n#define LIM -(1000000000000001ll)\nbool dij(){\n\tfor(int i=0;i<=T;i++)d[i]=LIM;\n\tmemset(vis,0,sizeof(vis));\n\td[S]=0;\n\tfor(int i=0;i<=T;i++){\n\t\tint x=-1;\n\t\tfor(int j=0;j<=T;j++)if(!vis[j]&&(x==-1||d[j]>d[x]))x=j;\n\t\tif(x==-1||d[x]==LIM)break;\n\t\tvis[x]=1;\n\t\tfor(int i=last[x];i!=-1;i=e[i].nxt)if(!vis[e[i].t]&&e[i].cap&&d[e[i].t]<d[x]+e[i].v){\n\t\t\t// assert(e[i].v<=0);\n\t\t\td[e[i].t]=d[x]+e[i].v;\n\t\t\tfa[e[i].t]=i;\n\t\t}\n\t}\n\treturn d[T]>LIM;\n}\npair<int,long long> solve(){\n\tint flow=0;long long cost=0;long long r=0;\n\twhile(dij()){\n\t\tflow++;\n\t\tint u=T;\n\t\twhile(u!=S){\n\t\t\te[fa[u]].cap=0;\n\t\t\te[fa[u]^1].cap=1;\n\t\t\tu=e[fa[u]].s;\n\t\t}\n\t\tr+=d[T];\n\t\tcost+=r;\n\t\tfor(int i=0;i<e_cnt;i++)e[i].v=d[e[i].s]+e[i].v-d[e[i].t];\n\t}\n\treturn make_pair(flow,cost);\n}\nint x[85],y[85];long long v[85];\nint t[325],a[325],b[325];\nint L[85][2],R[85][2];\nint main(){\n\tfreopen(\"e.in\",\"r\",stdin);\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d%d%lld\",&x[i],&y[i],&v[i]);\n\t}\n\tint m;\n\tscanf(\"%d\",&m);\n\tfor(int i=1;i<=m;i++){\n\t\tchar c=getchar();\n\t\twhile(c<'A'||c>'Z')c=getchar();\n\t\tif(c=='L')t[i]=0;\n\t\tif(c=='R')t[i]=1;\n\t\tif(c=='D')t[i]=2;\n\t\tif(c=='U')t[i]=3;\n\t\tscanf(\"%d%d\",&a[i],&b[i]);\n\t}\n\tlong long ans=0;\n\tfor(int supy=1;supy<=n;supy++){\n\t\tmemset(R,63,sizeof(R));\n\t\tfor(int j=1;j<=m;j++)if(b[j]<supy){\n\t\t\tif(t[j]&1)R[supy-b[j]][t[j]>>1]=min(R[supy-b[j]][t[j]>>1],a[j]-1);\n\t\t\telse L[b[j]+1][t[j]>>1]=max(L[b[j]+1][t[j]>>1],a[j]+1);\n\t\t}\n\t\tfor(int i=2;i<=supy;i++)for(int j=0;j<2;j++)L[i][j]=max(L[i][j],L[i-1][j]);\n\t\tfor(int i=supy-1;i>0;i--)for(int j=0;j<2;j++)R[i][j]=min(R[i][j],R[i+1][j]);\n\t\t// for(int i=1;i<=supy;i++)printf(\"%d %d\\n\",L[i][0],R[i][0]);\n\t\t// for(int i=1;i<=supy;i++)printf(\"%d %d\\n\",L[i][1],R[i][1]);\n\t\tT=2*supy+2*n+1;\n\t\te_cnt=0;\n\t\tmemset(last,-1,sizeof(last));\n\t\tfor(int i=1;i<=supy;i++)addedge(S,i,1,0),addedge(i+supy,T,1,0);\n\t\tfor(int i=1;i<=n;i++)addedge(i+2*supy,i+n+2*supy,1,v[i]-1000000000000000ll);\n\t\tfor(int i=1;i<=supy;i++)\n\t\t\tfor(int j=1;j<=n;j++)if(x[j]>=L[i][0]&&x[j]<=R[i][0])addedge(i,j+2*supy,1,0);\n\t\tfor(int i=1;i<=supy;i++)\n\t\t\tfor(int j=1;j<=n;j++)if(y[j]>=L[i][1]&&y[j]<=R[i][1])addedge(j+n+2*supy,i+supy,1,0);\n\t\tpair<int,long long>res=solve();\n\t\t// printf(\"%d %d %lld\\n\",supy,res.first,res.second);\n\t\tres.second+=supy*1000000000000000ll;\n\t\tif(res.first==supy)ans=max(ans,res.second);\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\nusing namespace std;\nconst int N=105;\nint lx[N],ly[N],rx[N],ry[N];\nint n,m,x[N],y[N],p[N],cnt[N];\nll dis[N*4],v[N],ans;\nint vis[N*4],q[N*N*4];\nint S,T,from[N*4];\nchar tp[N][5];\nstruct edge{\n\tint from,to,next,f;\n\tll v;\n}e[N*N*N];\nint head[N*4],tot;\nvoid add(int x,int y,int f,ll v){\n\te[++tot]=(edge){x,y,head[x],f,v};\n\thead[x]=tot;\n\te[++tot]=(edge){y,x,head[y],0,-v};\n\thead[y]=tot;\n}\nbool bfs(ll &sum){\n\tFor(i,1,T)\n\t\tdis[i]=-(1ll<<60),vis[i]=0;\n\tint h=0,t=1;\n\tq[1]=S; dis[S]=0;\n\twhile (h!=t){\n\t\tint x=q[++h]; vis[x]=0;\n\t\tfor (int i=head[x];i;i=e[i].next)\n\t\t\tif (dis[e[i].to]<dis[x]+e[i].v&&e[i].f){\n\t\t\t\tdis[e[i].to]=dis[x]+e[i].v;\n\t\t\t\tfrom[e[i].to]=i;\n\t\t\t\tif (!vis[e[i].to]){\n\t\t\t\t\tvis[e[i].to]=1;\n\t\t\t\t\tq[++t]=e[i].to;\n\t\t\t\t}\n\t\t\t}\n\t}\n\tif (dis[T]==-(1ll<<60)) return 0;\n\tsum+=dis[T];\n\tfor (int i=from[T];i;i=from[e[i].from])\n\t\te[i].f--,e[i^1].f++;\n\treturn 1;\n}\nvoid update(int k){\n\tmemset(head,0,sizeof(head));\n\ttot=1;\n\tFor(i,1,k){\n\t\tlx[i]=ly[i]=1;\n\t\trx[i]=ry[i]=N-1;\n\t}\n\tFor(i,1,m){\n\t\tif (cnt[i]>k) continue;\n\t\tif (tp[i][1]=='L') lx[cnt[i]+1]=max(lx[cnt[i]+1],p[i]+1);\n\t\tif (tp[i][1]=='R') rx[k-cnt[i]]=min(rx[k-cnt[i]],p[i]-1);\n\t\tif (tp[i][1]=='D') ly[cnt[i]+1]=max(ly[cnt[i]+1],p[i]+1);\n\t\tif (tp[i][1]=='U') ry[k-cnt[i]]=min(ry[k-cnt[i]],p[i]-1);\n\t}\n\tFor(i,2,k){\n\t\tlx[i]=max(lx[i],lx[i-1]);\n\t\tly[i]=max(ly[i],ly[i-1]);\n\t}\n\tRep(i,k-1,1){\n\t\trx[i]=min(rx[i],rx[i+1]);\n\t\try[i]=min(ry[i],ry[i+1]);\n\t}\n\tS=2*N+2*k+1; T=S+1;\n\tFor(i,1,k){\n\t\tadd(S,i,1,0);\n\t\tadd(i+2*N+k,T,1,0);\n\t\tFor(j,lx[i],rx[i]) add(i,j+k,1,0);\n\t\tFor(j,ly[i],ry[i]) add(j+N+k,i+2*N+k,1,0);\n\t}\n\tFor(i,1,n)\n\t\tadd(x[i]+k,y[i]+k+N,1,v[i]);\n\tll sum=0;\n\tFor(i,1,k)\n\t\tif (!bfs(sum))\n\t\t\treturn;\n\tans=max(ans,sum);\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tFor(i,1,n) scanf(\"%d%d%lld\",&x[i],&y[i],&v[i]);\n\tscanf(\"%d\",&m);\n\tFor(i,1,m) scanf(\"%s%d%d\",tp[i]+1,&p[i],&cnt[i]);\n\tFor(i,1,n) update(i);\n\tprintf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define itn int\n#define all(x) (x).begin(), (x).end()\n#define make_unique(x) sort(all((x))); (x).resize(unique(all((x))) - (x).begin())\n\n#define random_shuffle(...) shuffle(__VA_ARGS__, rng)\n#define rand() rng()\n\nusing namespace std;\n\ninline int nxt() {\n\tint x;\n\tscanf(\"%d\", &x);\n\treturn x;\n}\n\n#define sz(x) ((int) (x).size())\n#define forn(i,n) for (int i = 0; i < int(n); ++i)\n\ntypedef long long ll;\ntypedef long long i64;\ntypedef __float128 ld;\nconst int inf = int(1e9) + int(1e5);\nconst ll infl = ll(2e18) + ll(1e10);\n\nconst int maxn = 505;\nconst int maxm = 505;\n\nconst ld eps = 1e-4;\n\nbool eq(ld a, ld b) {\n    return fabsl(a - b) < eps;\n}\n\n//BEGIN_CODE\nnamespace Simplex {\n\nld D[maxm][maxn]; // [n+2][m+2]\nint B[maxm];\nint N[maxn];\nld x[maxn];\nint n, m;\n\n//x >= 0, Ax <= b, c^Tx -> max\nvoid init(int _n, int _m, ld A[][maxn], ld *b, ld *c) {\n    n = _n, m = _m;\n    forn (i, m)\n        forn (j, n)\n            D[i][j] = -A[i][j];\n    forn (i, m) {\n        D[i][n] = 1;\n        D[i][n + 1] = b[i];\n    }\n    forn (j, n) {\n        D[m][j] = c[j];\n        D[m + 1][j] = 0;\n    }\n    D[m][n + 1] = D[m][n] = D[m + 1][n + 1] = 0;\n    D[m + 1][n] = -1;\n    iota(B, B + m, n);\n    iota(N, N + n, 0);\n    N[n] = -1;\n}\n\nvoid pivot(int b, int nb) {\n    assert(D[b][nb] != 0);\n    ld q = 1. / -D[b][nb];\n    D[b][nb] = -1;\n    forn (i, n + 2)\n        D[b][i] *= q;\n    forn (i, m + 2) {\n        if (i == b)\n            continue;\n        ld coef = D[i][nb];\n        D[i][nb] = 0;\n        forn (j, n + 2)\n            D[i][j] += coef * D[b][j];\n    }\n    swap(B[b], N[nb]);\n}\n\nbool betterN(int f, int i, int j) {\n    if (eq(D[f][i], D[f][j]))\n        return N[i] < N[j];\n    return D[f][i] > D[f][j];\n}\n\nbool betterB(int nb, int i, int j) {\n    ld ai = D[i][n + 1] / D[i][nb];\n    ld aj = D[j][n + 1] / D[j][nb];\n    if (eq(ai, aj))\n        return B[i] < B[j];\n    return ai > aj;\n}\n\nbool simplex(int phase) {\n    int f = phase == 1 ? m : m + 1;\n    while (true) {\n        int nb = -1;\n        forn (i, n + 1) {\n            if (N[i] == -1 && phase == 1)\n                continue;\n            if (nb == -1 || betterN(f, i, nb))\n                nb = i;\n        }\n        if (D[f][nb] <= eps)\n            return phase == 1;\n        assert(nb != -1);\n\n        int b = -1;\n        forn (i, m) {\n            if (D[i][nb] >= -eps)\n                continue;\n            if (b == -1 || betterB(nb, i, b))\n                b = i;\n        }\n        if (b == -1)\n            return false;\n        pivot(b, nb);\n        if (N[nb] == -1 && phase == 2)\n            return true;\n    }\n}\n\nld solve() {\n    int b = -1;\n    forn (i, m) {\n        if (b == -1 || D[i][n + 1] < D[b][n + 1])\n            b = i;\n    }\n    assert(b != -1);\n    if (D[b][n + 1] < -eps) {\n        pivot(b, n);\n        if (!simplex(2) || D[m + 1][n + 1] < -eps)\n            return -infl;\n    }\n    if (!simplex(1))\n        return infl;\n\n    forn (i, n)\n        x[i] = 0;\n    forn (i, m)\n        if (B[i] < n)\n            x[B[i]] = D[i][n + 1];\n\n    return D[m][n + 1];\n}\n\n} //Simplex\n//END_CODE\n\nstruct Treasure {\n\tint x, y;\n\tlong long v;\n\n\tvoid scan() {\n\t\tscanf(\"%d%d%lld\", &x, &y, &v);\n\t}\n};\n\nstruct Constraint {\n\tchar t;\n\tint a, b;\n\n\tvoid scan() {\n\t\tcin >> t >> a >> b;\n\t}\n\n\tbool isAbout(const Treasure& tr) const {\n\t\tif (t == 'D') {\n\t\t\treturn tr.y <= a;\n\t\t} else if (t == 'U') {\n\t\t\treturn tr.y >= a;\n\t\t} else if (t == 'L') {\n\t\t\treturn tr.x <= a;\n\t\t} else if (t == 'R') {\n\t\t\treturn tr.x >= a;\n\t\t} else {\n\t\t\tassert(false);\n\t\t}\n\t}\n};\n\nld a[maxm][maxn];\nld b[maxm];\nld c[maxn];\n\nint main() {\n\tmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n\tint n = nxt();\n\tvector<Treasure> trs(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\ttrs[i].scan();\n\t}\n\n\tint m = nxt();\n\tvector<Constraint> crs(m);\n\tfor (int i = 0; i < m; ++i) {\n\t\tcrs[i].scan();\n\t}\n\n\tfor (int i = 0; i < m; ++i) {\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\ta[i][j] = crs[i].isAbout(trs[j]);\n\t\t}\n\t\tb[i] = crs[i].b;\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\ta[m + i][i] = 1;\n\t\tb[m + i] = 1;\n\t\tc[i] = trs[i].v;\n\t}\n\n\tSimplex::init(n, n + m, a, b, c);\n\t// Simplex::solve();\n\n\tld ans = Simplex::solve();\n\tcout << (long long)roundl(ans) << \"\\n\";\n\t// long long to_out = 0;\n\t// vector<int> good(n, 0);\n\t// for (int i = 0; i < n; ++i) {\n\t// \tbool can = true;\n\t// \tfor (int j = 0; j < m; ++j) {\n\t// \t\tif (crs[j].isAbout(trs[i]) && crs[j].b == 0) {\n\t// \t\t\tcan = false;\n\t// \t\t}\n\t// \t}\n\t// \tif (!can) {\n\t// \t\tcontinue;\n\t// \t}\n\t// \tfor (int i = 0; i < m; ++i) {\n\t// \t\tfor (int j = 0; j < n; ++j) {\n\t// \t\t\ta[i][j] = crs[i].isAbout(trs[j]);\n\t// \t\t}\n\t// \t\tb[i] = crs[i].b;\n\t// \t}\n\t// \tb[m + i] = 0;\n\t// \tSimplex::init(n, n + m, a, b, c);\n\t// \tauto res = Simplex::solve();\n\t// \tif (res < ans - 0.5) {\n\t// \t\tgood[i] = 1;\n\t// \t\tfor (int j = 0; j < m; ++j) {\n\t// \t\t\tif (crs[j].isAbout(trs[i]) && crs[j].b == 0) {\n\t// \t\t\t\tcrs[j].b -= 1;\n\t// \t\t\t}\n\t// \t\t}\n\t// \t\tb[m + i] = 1;\n\t// \t\tto_out += trs[i].v;\n\t// \t}\n\t// }\n\n\t// cout << to_out << \"\\n\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MV = 815;\nconst int ME = 600006;\nconst ll oo = 1e18;\n\ntemplate <typename T> void cmin(T &x, const T &y)\n{\n\tif(y < x) x = y;\n}\n\ntemplate <typename T> void cmax(T &x, const T &y)\n{\n\tif(y > x) x = y;\n}\n\ntemplate <typename T> void read(T &x)\n{\n\tx = 0; char c = getchar(); bool f = 0;\n\twhile(!isdigit(c) && c!='-') c = getchar();\n\tif(c == '-') f = 1, c = getchar();\n\twhile(isdigit(c)) x = x*10+c-'0', c = getchar();\n\tif(f) x = -x;\n}\n\nstruct EDGE\n{\n\tint v;\n\tll w;\n\tint c;\n\n\tEDGE (const int &v0 = 0, const ll &w0 = 0, const int &c0 = 0) : v(v0), w(w0), c(c0) {}\n};\n\nstruct GRAPH\n{\n\tint fst[MV], nxt[ME], lnum;\n\tint q[MV], pre[MV], inq[MV];\n\tEDGE e[ME];\n\tll dis[MV];\n\n\tvoid init()\n\t{\n\t\tmemset(fst, 0xff, sizeof(fst));\n\t\tlnum = -1;\n\t}\n\n\tGRAPH () {init();}\n\n\tvoid addeg(int nu, int nv, ll nw, int nc)\n\t{\n\t\tnxt[++lnum] = fst[nu];\n\t\te[lnum] = EDGE(nv, nw, nc);\n\t\tfst[nu] = lnum;\n\t\tnxt[++lnum] = fst[nv];\n\t\te[lnum] = EDGE(nu, -nw, 0);\n\t\tfst[nv] = lnum;\n\t}\n\n\tint spfa(int &flow, ll &cost, int frm, int tar)\n\t{\n\t\tint h=0, t=1, x, y, mxf = ME, now;\n\t\tll cst = 0;\n\t\tmemset(dis, 0x9f, sizeof(dis));\n\t\tmemset(inq, 0, sizeof(inq));\n\t\tmemset(pre, 0, sizeof(pre));\n\t\tq[++h] = frm;\n\t\tdis[frm] = 0;\n\t\tpre[frm] = -1;\n\t\twhile(h >= t)\n\t\t{\n\t\t\tx = q[(t++)%MV];\n\t\t\tinq[x] = 0;\n\t\t\tfor(int i=fst[x]; i!=-1; i=nxt[i])\n\t\t\t{\n\t\t\t\ty = e[i].v;\n\t\t\t\tif(e[i].c && dis[y]<dis[x]+e[i].w)\n\t\t\t\t{\n\t\t\t\t\tdis[y] = dis[x]+e[i].w;\n\t\t\t\t\tpre[y] = i;\n\t\t\t\t\tif(!inq[y]) q[(++h)%MV] = y, inq[y] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dis[tar] < -oo) return 0;\n\t\tnow = pre[tar];\n\t\twhile(now != -1)\n\t\t{\n\t\t\tmxf = min(mxf, e[now].c);\n\t\t\tcst += e[now].w;\n\t\t\tnow = pre[e[now^1].v];\n\t\t}\n\t\tnow = pre[tar];\n\t\twhile(now != -1)\n\t\t{\n\t\t\te[now].c -= mxf;\n\t\t\te[now^1].c += mxf;\n\t\t\tnow = pre[e[now^1].v];\n\t\t}\n\t\tflow += mxf;\n\t\tcost += cst*mxf;\n\t\treturn 1;\n\t}\n\n\tpair<int, ll> mcf(int s, int t)\n\t{\n\t\tint flow = 0;\n\t\tll cost = 0;\n\t\twhile(spfa(flow, cost, s, t));\n\t\treturn make_pair(flow, cost);\n\t}\n} G;\n\nint n, m;\nint lx[MV], rx[MV];\nint ly[MV], ry[MV];\nint px[MV], py[MV];\nll pv[MV];\nchar qc[MV];\nint qa[MV], qb[MV];\nint global_s, global_t;\n\nvoid input()\n{\n\tread(n);\n\tfor(int i=1; i<=n; i++) read(px[i]), read(py[i]), read(pv[i]);\n\tread(m);\n\tfor(int i=1; i<=n; i++) lx[i] = 1, rx[i] = 100, ly[i] = 1, ry[i] = 100;\n\tfor(int i=1; i<=m; i++)\n\t{\n\t\tqc[i] = getchar();\n\t\twhile(!isalpha(qc[i])) qc[i] = getchar();\n\t\tread(qa[i]), read(qb[i]);\n\t}\n}\n\nvoid build(int num)\n{\n\tfor(int i=1; i<=num; i++) lx[i] = ly[i] = 1, rx[i] = ry[i] = 100;\n\tfor(int i=1; i<=m; i++)\n\t{\n\t\tif(qb[i] > num) continue;\n\t\tif(qc[i] == 'L') cmax(lx[qb[i]+1], qa[i]+1);\n\t\tif(qc[i] == 'R') cmin(rx[num-qb[i]], qa[i]-1);\n\t\tif(qc[i] == 'D') cmax(ly[qb[i]+1], qa[i]+1);\n\t\tif(qc[i] == 'U') cmin(ry[num-qb[i]], qa[i]-1);\n\t}\n\tfor(int i=1; i<=num; i++) cmax(lx[i], lx[i-1]), cmax(ly[i], ly[i-1]);\n\tfor(int i=num; i>=1; i--) cmin(rx[i], rx[i+1]), cmin(ry[i], ry[i+1]);\n\tG.init();\n\tfor(int i=1; i<=num; i++)\n\t{\n\t\tfor(int j=1; j<=n; j++)\n\t\t{\n\t\t\tif(lx[i]<=px[j] && px[j]<=rx[i]) G.addeg(i, num*2+j, 0, 1);\n\t\t\tif(ly[i]<=py[j] && py[j]<=ry[i]) G.addeg(num*2+n+j, num+i, 0, 1);\n\t\t}\n\t}\n\tfor(int i=1; i<=n; i++) G.addeg(num*2+i, num*2+n+i, pv[i], 1);\n\tglobal_s = num*2+n*2+1, global_t = global_s+1;\n\tfor(int i=1; i<=num; i++) G.addeg(global_s, i, 0, 1), G.addeg(num+i, global_t, 0, 1);\n}\n\nvoid work()\n{\n\tll ans = 0;\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tbuild(i);\n\t\tauto ret = G.mcf(global_s, global_t);\n\t\tif(ret.first != i) break;\n\t\telse cmax(ans, ret.second);\n\t\t//cout<<i<<\" \"<<ret.second<<endl;\n\t}\n\tprintf(\"%lld\\n\", ans);\n}\n\nint main()\n{\n\tinput();\n\twork();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef HOME\n#define db(x) cerr << #x << \" = \" << x << endl\n#define db3(x, y, z) cerr << \"(\" << #x << \", \" << #y << \", \" << #z << \") = (\" << x << \", \" << y << \", \" << z << \")\" << endl\n#define db2(x, y) cerr << \"(\" << #x << \", \" << #y << \") = (\" << x << \", \" << y << \")\" << endl\n#define dbv(a) cerr << #a << \" = \"; for (auto xxx: a) cerr << xxx  << \" \"; cerr << endl\n#else\n#define db(x) ;\n#define db3(x, y, z) ;\n#define db2(x, y) ;\n#define dbv(a) ;\n#endif\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double dbl;\n\n\nconst int INF = 1.01e9;\nconst int MOD = (int)1e9 + 7;\n\nstruct Item {\n    int x, y;\n    ll val;\n};\n\nstruct Cond {\n    char type;\n    int a, b;\n\n    bool cover(Item it) {\n        if (type == 'L') {\n            return it.x <= a;\n        }\n        if (type == 'R') {\n            return it.x >= a;\n        }\n        if (type == 'D') {\n            return it.y <= a;\n        }\n        if (type == 'U') {\n            return it.y >= a;\n        }\n        assert(0);\n    }\n};\n\nll slow(vector<Item> a, vector<Cond> b) {\n    int n = a.size(), m = b.size();\n    ll ans = 0;\n    for (int mask = 0; mask < (1 << n); mask++) {\n        vector<int> cnt(m);\n        ll sum = 0;\n        for (int i = 0; i < n; i++) {\n            if (!(mask & (1 << i))) continue;\n            sum += a[i].val;\n            for (int j = 0; j < m; j++) {\n                if (b[j].cover(a[i])) {\n                    cnt[j]++;\n                }\n            }\n        }\n        bool bad = 0;\n        for (int i = 0; i < m; i++) {\n            if (cnt[i] > b[i].b) {\n                bad = 1;\n            }\n        }\n        if (bad) continue;\n        ans = max(ans, sum);\n    }\n    return ans;\n}\n\n\nbool eq(dbl a, dbl b) {\n    return fabs(a - b) < 1e-9;\n}\n\nbool ls(dbl a, dbl b) {\n    return !eq(a, b) && a < b;\n}\n\nvector<dbl> supersimplex(vector<vector<dbl> > a) {\n    int n = a.size() - 1;\n    int m = a[0].size() - 1;\n    vector<int> left(n + 1), up(m + 1);\n    iota(up.begin(), up.end(), 0);\n    iota(left.begin(), left.end(), m);\n    while (1) {\n        auto pivot = [&](int x, int y) {\n            swap(left[x], up[y]);\n            dbl k = a[x][y];\n            a[x][y] = 1;\n            vector<int> vct;\n            for (int j = 0; j <= m; j++) {\n                a[x][j] /= k;\n                if (!eq(a[x][j], 0)) vct.push_back(j);\n            }\n            for (int i = 0; i <= n; i++) {\n                if (eq(a[i][y], 0) || i == x) continue;\n                k = a[i][y];\n                a[i][y] = 0;\n                for (int j : vct) a[i][j] -= k * a[x][j];\n            }\n        };\n        while (1) {\n            int x = -1;\n            for (int i = 1; i <= n; i++) if (ls(a[i][0], 0) && (x == -1 || a[i][0] < a[x][0])) x = i;\n            if (x == -1) break;\n            int y = -1;\n            for (int j = 1; j <= m; j++) if (ls(a[x][j], 0) && (y == -1 || a[x][j] < a[x][y])) y = j;\n            if (y == -1) return vector<dbl>(m, 0);\n            pivot(x, y);\n        }\n        while (1) {\n            int y = -1;\n            for (int j = 1; j <= m; j++) if (ls(0, a[0][j]) && (y == -1 || a[0][j] > a[0][y])) y = j;\n            if (y == -1) break;\n            int x = -1;\n            for (int i = 1; i <= n; i++) if (ls(0, a[i][y]) && (x == -1 || a[i][0] / a[i][y] < a[x][0] / a[x][y])) x = i;\n            if (x == -1) assert(0); // unbounded\n            pivot(x, y);\n        }\n\n        vector<int> v;\n        vector<dbl> ans(m + 1);\n        vector<int> rev(m + 1);\n        for (int i = 1; i <= n; i++) if (left[i] <= m) ans[left[i]] = a[i][0], rev[left[i]] = i;\n        ans[0] = -a[0][0];\n        for (int i = 1; i <= m; i++) {\n            if (!eq(ans[i], floor(ans[i])) && !eq(ans[i], floor(ans[i]) + 1)) {\n                v.push_back(rev[i]);\n            }\n        }\n        if (v.empty()) {\n            return ans;\n        }\n        for (int i = 0; i <= n; i++) {\n            for (int j = 0; j < (int)v.size(); j++) {\n                a[i].push_back(0);\n            }\n        }\n        for (int i = 0; i < (int)v.size(); i++) {\n            vector<dbl> cur(a[0].size());\n            cur[m + 1 + i] = 1;\n            cur[0] = floor(a[v[i]][0]) - a[v[i]][0];\n            for (int j = 1; j <= m; j++) {\n                cur[j] = floor(a[v[i]][j]) - a[v[i]][j];\n            }\n            a.push_back(cur);\n        }\n        m += v.size();\n        n += v.size();\n        up.resize(up.size() + v.size());\n        left.resize(left.size() + v.size());\n    }\n}\n// j=1..m: x[j]>=0\n// i=1..n: sum(j=1..m) A[i][j]*x[j] <= A[i][0]\n// max sum(j=1..m) A[0][j]*x[j]\n// res[0] is answer\n// res[1..m] is certificate\n\nll fast(vector<Item> a, vector<Cond> b) {\n    int n = a.size(), m = b.size();\n    vector<vector<dbl>> c(m + 1, vector<dbl>(n + 1));\n    for (int i = 0; i < n; i++) {\n        c[0][1 + i] = a[i].val;\n    }\n    for (int i = 0; i < m; i++) {\n        c[1 + i][0] = b[i].b;\n        for (int j = 0; j < n; j++) {\n            if (b[i].cover(a[j])) {\n                c[1 + i][1 + j] = 1;\n            }\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        vector<dbl> cur(n + 1);\n        cur[0] = 1;\n        cur[1 + i] = 1;\n        c.push_back(cur);\n    }\n    return (ll)round(supersimplex(c)[0]);\n}\n\nvoid stress() {\n    for (int it = 36812;; it++) {\n        mt19937_64 rnd(it);\n        db(it);\n\n\n        int n = rnd() % 10 + 1;\n        vector<Item> a(n);\n        for (int i =0 ; i < n; i++) {\n            a[i].x = rnd() % 100;\n            a[i].y = rnd() % 100;\n            a[i].val = rnd() % (ll)1e15;\n        }\n        int m = rnd() % 10 + 1;\n        vector<Cond> b(m);\n        for (int i = 0; i < m; i++) {\n            b[i].a = rnd() % 100;\n            b[i].b = rnd() % (n + 1);\n            b[i].type = \"ULDR\"[rnd() % 4];\n        }\n\n        auto ans1 = fast(a, b);\n        auto ans2 = slow(a, b);\n        if (ans1 != ans2) {\n            cout << ans1 << \" instead of \" << ans2 << endl;\n            exit(0);\n        }\n    }\n}\n\nint main() {\n#ifdef HOME\n    assert(freopen(\"in\", \"r\", stdin));\n    stress();\n#endif\n\n    int n;\n    while (scanf(\"%d\", &n) == 1) {\n        vector<Item> a(n);\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d%d%lld\", &a[i].x, &a[i].y, &a[i].val);\n        }\n        int m;\n        scanf(\"%d\", &m);\n        vector<Cond> b(m);\n        for (int i = 0; i < m; i++) {\n            scanf(\" %c%d%d\", &b[i].type, &b[i].a, &b[i].b);\n        }\n\n//        printf(\"%lld\\n\", slow(a, b));\n        printf(\"%lld\\n\", fast(a, b));\n    }\n\n#ifdef HOME\n    cerr << \"time: \" << clock() * 1.0 / CLOCKS_PER_SEC << endl;\n#endif\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <list>\n#include <time.h>\n#include <math.h>\n#include <random>\n#include <deque>\n#include <queue>\n#include <cassert>\n#include <unordered_map>\n#include <unordered_set>\n#include <iomanip>\n#include <bitset>\n#include <sstream>\n#include <chrono>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef long double dbl;\nconst int INF = 1.01e9;\n \nconst long double EPS = 1e-9;\nbool eq(long double x, long double y) {\n    return fabs(x - y) < EPS;\n}\nbool ls(long double x, long double y) {\n    return x < y && !eq(x, y);\n}\n \nvector<long double> simplex(vector<vector<long double> > a) {\n    int n = a.size() - 1;\n    int m = a[0].size() - 1;\n    vector<int> left(n + 1), up(m + 1);\n    iota(up.begin(), up.end(), 0);\n    iota(left.begin(), left.end(), m);\n    auto pivot = [&](int x, int y) {\n        swap(left[x], up[y]);\n        long double k = a[x][y];\n        a[x][y] = 1;\n        vector<int> vct;\n        for (int j = 0; j <= m; j++) {\n            a[x][j] /= k;\n            if (!eq(a[x][j], 0)) vct.push_back(j);\n        }\n        for (int i = 0; i <= n; i++) {\n            if (eq(a[i][y], 0) || i == x) continue;\n            k = a[i][y];\n            a[i][y] = 0;\n            for (int j : vct) a[i][j] -= k * a[x][j];\n        }\n    };\n    while (1) {\n        int x = -1;\n        for (int i = 1; i <= n; i++) if (ls(a[i][0], 0) && (x == -1 || a[i][0] < a[x][0])) x = i;\n        if (x == -1) break;\n        int y = -1;\n        for (int j = 1; j <= m; j++) if (ls(a[x][j], 0) && (y == -1 || a[x][j] < a[x][y])) y = j;\n        if (y == -1) assert(0); // infeasible\n        pivot(x, y);\n    }\n    while (1) {\n        int y = -1;\n        for (int j = 1; j <= m; j++) if (ls(0, a[0][j]) && (y == -1 || a[0][j] > a[0][y])) y = j;\n        if (y == -1) break;\n        int x = -1;\n        for (int i = 1; i <= n; i++) if (ls(0, a[i][y]) && (x == -1 || a[i][0] / a[i][y] < a[x][0] / a[x][y])) x = i;\n        if (x == -1) assert(0); // unbounded\n        pivot(x, y);\n    }\n    vector<long double> ans(m + 1);\n    for (int i = 1; i <= n; i++) if (left[i] <= m) ans[left[i]] = a[i][0];\n    ans[0] = -a[0][0];\n    return ans;\n}\n\n#ifdef ONPC\n  mt19937 rnd(228);\n#else\n  mt19937 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\n#endif\n\nint main()\n{\n#ifdef ONPC\n  freopen(\"a.in\", \"r\", stdin);\n#endif\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector <int> x(n), y(n);\n  vector <ll> ok;\n  vector <long double> v;\n  vector <pair <ll, int> > e;\n  for (int i = 0; i < n; i++)\n  {\n    cin >> x[i] >> y[i];\n    ll x;\n    cin >> x;\n    ok.push_back(x);\n    v.push_back(x);\n    e.push_back({x, i});\n  }\n  v.insert(v.begin(), 0);\n  int m;\n  cin >> m;\n  vector <vector <long double> > mat;\n  mat.push_back(v);\n  for (int i = 0; i < n; i++)\n  {\n    vector <long double> kek(n + 1);\n    kek[0] = kek[i + 1] = 1;\n    mat.push_back(kek);\n  }\n  vector <vector <int> > simp;\n  for (int i = 0; i < m; i++)\n  {\n    char c;\n    cin >> c;\n    int a;\n    int b;\n    cin >> a >> b;\n    vector <long double> arr = {(long double) b};\n    vector <int> kek = {b};\n    for (int j = 0; j < n; j++)\n    {\n      int grab = 0;\n      if (c == 'L' && x[j] <= a) grab = 1;\n      if (c == 'R' && x[j] >= a) grab = 1;\n      if (c == 'D' && y[j] <= a) grab = 1;\n      if (c == 'U' && y[j] >= a) grab = 1;\n      arr.push_back(grab);\n      kek.push_back(grab);\n    }\n    mat.push_back(arr);\n    simp.push_back(kek);\n  }\n  auto ret = simplex(mat);\n  vector <int> grab;\n  for (int i = 1; i < (int) ret.size(); i++)\n  {\n    if (ret[i] >= 0.5)\n    {\n      grab.push_back(1);\n    }\n    else\n    {\n      grab.push_back(0);\n    }\n  }\n  sort(e.begin(), e.end());\n  auto good = [&] (vector <int> grab)\n  {\n    for (auto c : simp)\n    {\n      int sum = 0;\n      for (int i = 1; i <= n; i++) sum += grab[i - 1] * c[i];\n      if (sum > c[0])\n      {\n        return false;\n      }\n    }\n    return true;\n  };\n  for (int i = 0; i < (int) e.size(); i++)\n  {\n    if (grab[e[i].second] && !good(grab))\n    {\n      grab[e[i].second] = 0;\n    }\n  }\n  bool ch = true;\n  while (ch)\n  {\n    ch = false;\n    for (int i = (int) e.size() - 1; i >= 0; i--)\n    {\n      if (!grab[e[i].second])\n      {\n        grab[e[i].second] = true;\n        if (good(grab))\n        {\n          ch = true;\n        }\n        else\n        {\n          grab[e[i].second] = false;\n        }\n      }\n    }\n    if (!ch)\n    {\n      for (int i = 0; i < (int) e.size(); i++)\n      {\n        for (int j = i + 1; j < (int) e.size(); j++)\n        {\n          if (e[i].first < e[j].first && grab[e[i].second] && !grab[e[j].second])\n          {\n            auto x = grab;\n            swap(x[e[i].second], x[e[j].second]);\n            if (good(x))\n            {\n              grab = x;\n              ch = true;\n            }\n          }\n        }\n      }\n    }\n  }\n  ll ans = 0;\n  for (int i = 0; i < n; i++)\n  {\n    if (grab[i]) ans += ok[i];\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<queue>\nusing namespace std;\n#define ll long long\nll gi(){\n    ll x=0,w=1;char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();\n    if(ch=='-')w=0,ch=getchar();\n    while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();\n    return w?x:-x;\n}\nint gc(){\n    char ch=getchar();\n    while(ch<'A'||ch>'Z')ch=getchar();\n    return ch;\n}\nconst int N=405;\nstruct edge{int to,nxt,w;ll cost;}E[N*N];\nint n,m,x[N],y[N],t[N],a[N],b[N],L[N],R[N],D[N],U[N],head[N],cnt,S,T,vis[N],pe[N];\nll v[N],dis[N],ans;queue<int>Q;\nvoid link(int u,int v,ll w){\n    E[++cnt]=(edge){v,head[u],1,w};head[u]=cnt;\n    E[++cnt]=(edge){u,head[v],0,-w};head[v]=cnt;\n}\nbool spfa(ll &res){\n    memset(dis,63,sizeof(dis));\n    dis[S]=0;Q.push(S);\n    while(!Q.empty()){\n        int u=Q.front();Q.pop();vis[u]=0;\n        for(int i=head[u],v;i;i=E[i].nxt)\n            if(E[i].w&&dis[v=E[i].to]>dis[u]+E[i].cost){\n                dis[v]=dis[u]+E[i].cost;pe[v]=i;\n                if(!vis[v])vis[v]=1,Q.push(v);\n            }\n    }\n    if(dis[T]==dis[0])return false;res+=dis[T];\n    for(int i=T;i!=S;i=E[pe[i]^1].to)--E[pe[i]].w,++E[pe[i]^1].w;\n    return true;\n}\nll cal(int k){\n    for(int i=1;i<=k;++i)L[i]=D[i]=0,R[i]=U[i]=233;\n    for(int i=1;i<=m;++i)\n        if(b[i]<k){\n            if(t[i]=='L')L[b[i]+1]=a[i]+1;\n            if(t[i]=='R')R[k-b[i]]=a[i]-1;\n            if(t[i]=='D')D[b[i]+1]=a[i]+1;\n            if(t[i]=='U')U[k-b[i]]=a[i]-1;\n        }\n    for(int i=2;i<=k;++i)L[i]=max(L[i],L[i-1]),D[i]=max(D[i],D[i-1]);\n    for(int i=k-1;i;--i)R[i]=min(R[i],R[i+1]),U[i]=min(U[i],U[i+1]);\n    memset(head,0,sizeof(head));cnt=1;S=n+k<<1|1;T=n+k+1<<1;\n    for(int i=1;i<=n;++i)link(i,n+i,-v[i]-1000000000000000ll);\n    for(int i=1;i<=k;++i){\n        link(S,n+n+i,0);link(n+n+k+i,T,0);\n        for(int j=1;j<=n;++j){\n            if(L[i]<=x[j]&&x[j]<=R[i])link(n+n+i,j,0);\n            if(D[i]<=y[j]&&y[j]<=U[i])link(n+j,n+n+k+i,0);\n        }\n    }\n    ll res=0;while(spfa(res));return -res-1000000000000000ll*k;\n}\nint main(){\n    n=gi();\n    for(int i=1;i<=n;++i)x[i]=gi(),y[i]=gi(),v[i]=gi();\n    m=gi();\n    for(int i=1;i<=m;++i)t[i]=gc(),a[i]=gi(),b[i]=gi();\n    for(int i=1;i<=n;++i)ans=max(ans,cal(i));\n    printf(\"%lld\\n\",ans);return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>/*{{{*/\n#include<cctype>\n#include<cassert>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<ctime>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<set>\n#include<vector>\nusing namespace std;\ntypedef pair<int,int> pii;\n#define fi first\n#define se second\n#define pb push_back\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define ROF(i,a,b) for(int i=(a);i>=(b);--i)\nnamespace RA{\n    int r(int p){return 1ll*rand()*rand()%p;}\n    int r(int L,int R){return r(R-L+1)+L;}\n}/*}}}*/\n/******************heading******************/\ntypedef long long LL;\nconst LL LLINF=0x3f3f3f3f3f3f3f3f;\nconst int N=400,INF=0x3f3f3f3f;\n\nint s,t;\nstruct qxx{int nex,t,v;LL c;};\nqxx e[N*N*10];\nLL h[N],hh[N],le=1;\nvoid add_path(int f,int t,int v,LL c){e[++le]=(qxx){h[f],t,v,c},h[f]=le;}\nvoid add_flow(int f,int t,int v,LL c){\n    //printf(\"add_flow(%d,%d,%d,%lld)\\n\",f,t,v,c);\n    add_path(f,t,v,c),add_path(t,f,0,-c);}\n#define FORe(i,_u,_v,_w,_c)     for(LL i=h[_u],_v,_w,_c;_v=e[i].t,_w=e[i].v,_c=e[i].c,i;i=e[i].nex)\n#define FORflowe(i,_u,_v,_w,_c) for(LL &i=hh[_u],_v,_w,_c;_v=e[i].t,_w=e[i].v,_c=e[i].c,i;i=e[i].nex)\n\nint n,m;\nint x[N],y[N];\nLL val[N],ans=-LLINF;\nint xL[N],xR[N],yL[N],yR[N];\n\nvector<pii> L,R,U,D;\n\nqueue<int> q;\nbool vising[N];\nLL d[N];\nbool spfa(){\n    memset(d,0x3f,sizeof(d));\n    q.push(s),d[s]=0;\n    while(!q.empty()){\n        int u=q.front(); q.pop();\n        vising[u]=0;\n        FORe(i,u,v,w,c){\n            if(!w||d[v]<=d[u]+c)continue;\n            d[v]=d[u]+c;\n            if(!vising[v])q.push(v),vising[v]=1;\n        }\n    }\n    return d[t]!=LLINF;\n}\nLL mincost;\nbool vis[N];\nint dfs(int u,int flow){\n    vis[u]=1;\n    if(u==t)return flow;\n    int rest=flow;\n    FORflowe(i,u,v,w,c){\n        if(!rest)break;\n        if(vis[v]&&v!=t||!w||d[v]!=d[u]+c)continue;\n        int k=dfs(v,min(w,1ll*rest));\n        if(k)mincost+=k*c,e[i].v-=k,e[i^1].v+=k,rest-=k;\n        else d[v]=0;\n    }\n    return flow-rest;\n}\nLL go(){\n    int maxflow=0;\n    while(spfa()){\n        memcpy(hh,h,sizeof(h));\n        for(int i;memset(vis,0,sizeof(vis)),(i=dfs(s,INF))&&vis[t];)maxflow+=i;\n    }\n    //printf(\"maxflow=%d,mincost=%lld\\n\",maxflow,mincost);\n    return mincost;\n}\nvoid init(){\n    memset(h,0,sizeof(h));\n    le=1,mincost=0;\n}\nvoid calc(int k){\n    //printf(\"calc(%d)\\n\",k);\n    FOR(i,0,n)xL[i]=yL[i]=-1,xR[i]=yR[i]=INF;\n    xR[k+1]=INF;\n    yR[k+1]=INF;\n    for(pii x:L){\n        xL[x.se+1]=max(xL[x.se+1],x.fi+1); //x[b+1] >= a+1\n        //printf(\"xL[%d]=%d\\n\",x.se+1,x.fi+1);\n    }\n    for(pii x:R)if(k-x.se>=0)xR[k-x.se]=min(xR[k-x.se],x.fi-1); //x[k-b] <= a-1\n    for(pii x:D)yL[x.se+1]=max(yL[x.se+1],x.fi+1);\n    for(pii x:U)if(k-x.se>=0)yR[k-x.se]=min(yR[k-x.se],x.fi-1); //BUG#1:忘判>0\n    FOR(i,1,k)xL[i]=max(xL[i],xL[i-1]);\n    ROF(i,k,1)xR[i]=min(xR[i],xR[i+1]);\n    FOR(i,1,k)yL[i]=max(yL[i],yL[i-1]);\n    ROF(i,k,1)yR[i]=min(yR[i],yR[i+1]);\n    //FOR(i,0,k)printf(\"[%d,%d]%c\",xL[i],xR[i],\" \\n\"[i==k]);\n    //FOR(i,0,k)printf(\"[%d,%d]%c\",yL[i],yR[i],\" \\n\"[i==k]);\n\n    // item: 1 - n, n+1 - 2n\n    // x : 2n+1 - 2n+k\n    // y : 2n+k+1 - 2n+2k\n    // s : 0\n    // t : 2n+2k+1\n    init();\n    s=0,t=2*n+2*k+1;\n    //printf(\"s=%d,t=%d\\n\",s,t);\n    FOR(i,1,k)add_flow(s,2*n+i,1,0);\n    FOR(i,1,k)FOR(j,1,n)if(xL[i]<=x[j]&&x[j]<=xR[i])add_flow(2*n+i,j,INF,0);\n    FOR(i,1,n)add_flow(i,i+n,1,-val[i]);\n    FOR(i,1,k)FOR(j,1,n)if(yL[i]<=y[j]&&y[j]<=yR[i])add_flow(j+n,2*n+k+i,INF,0);\n    FOR(i,1,k)add_flow(2*n+k+i,t,1,0);\n\n    LL res=go();\n    ans=max(ans,-res);\n}\n\nint main(){\n    scanf(\"%d\",&n);\n    FOR(i,1,n)scanf(\"%d%d%lld\",&x[i],&y[i],&val[i]);\n    scanf(\"%d\",&m);\n    FOR(i,1,m){\n        char t[10];\n        int a,b;\n        scanf(\"%s%d%d\",t,&a,&b);\n        if(t[0]=='L')L.pb({a,b});\n        else if(t[0]=='R')R.pb({a,b});\n        else if(t[0]=='U')U.pb({a,b});\n        else D.pb({a,b});\n    }\n    FOR(i,1,n)calc(i);\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<iomanip>\n#include<ctime>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#define sqr(x) ((x)*(x))\n#define fz1(i,n) for ((i)=1;(i)<=(n);(i)++)\n#define fd1(i,n) for ((i)=(n);(i)>=1;(i)--)\n#define fz0g(i,n) for ((i)=0;(i)<=(n);(i)++)\n#define fd0g(i,n) for ((i)=(n);(i)>=0;(i)--)\n#define fz0k(i,n) for ((i)=0;(i)<(n);(i)++)\n#define fd0k(i,n) for ((i)=(long long)((n)-1);(i)>=0;(i)--)\n#define fz(i,x,y) for ((i)=(x);(i)<=(y);(i)++)\n#define fd(i,y,x) for ((i)=(y);(i)>=(x);(i)--)\n#define fzin fz1(i,n)\n#define fzim fz1(i,m)\n#define fzjn fz1(j,n)\n#define fzjm fz1(j,m)\n#define ff(c,itr) for (__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n#define rdst(st,len){static char ss[len];scanf(\" %s\",ss);(st)=ss;}\n//#define T_ long long\nusing namespace std;\n//struct bit{T_ arr[1000005];long long lowbit(long long x){return x&(-x);}void add(long long x,T_ y){for (long long i=x;i<=n;i+=lowbit(i)) arr[i]+=y;}T_ query(long long x){T_ s=0;for (long long i=x;i>0;i-=lowbit(i)) s+=arr[i];return s;}};\n//struct seg{struct treedot{long long l,r;T_ sum,add;void update(T_ x){sum+=(r-l+1)*x; add+=x;}}c[800005];void pushdown(long long id){if (c[id].add){c[id*2].update(c[id].add);c[id*2+1].update(c[id].add);c[id].add=0;}}void pushup(long long id){c[id].sum=c[id*2].sum+c[id*2+1].sum;}void build(long long id,long long l,long long r){if (l>r) return;c[id].l=l;c[id].r=r;c[id].sum=0;c[id].add=0;if (l==r) c[id].sum=0;else{long long mid=l+(r-l)/2;build(id*2,l,mid);build(id*2+1,mid+1,r);pushup(id);}}void update(long long id,long long le,long long ri,T_ x){if (le>c[id].r||ri<c[id].l) return;if (le<=c[id].l&&c[id].r<=ri) c[id].update(x);else{pushdown(id);update(id*2,le,ri,x);update(id*2+1,le,ri,x);pushup(id);}}T_ query(long long id,long long le,long long ri){if (ri<c[id].l||c[id].r<le) return 0;if (le<=c[id].l&&c[id].r<=ri) return c[id].sum;T_ ans=0;pushdown(id);ans+=query(id*2,le,ri);ans+=query(id*2+1,le,ri);pushup(id);return ans;}};\n//struct bit_2d{T_ a[2005][2005];long long lowbit(long long x){return x&(-x);}void add(long long x,long long y,T_ z){long long i,j;for (i=x;i<=2000;i+=lowbit(i)){for (j=y;j<=2000;j+=lowbit(j)){a[i][j]+=z;}}}T_ query(long long x,long long y){long long i,j;T_ s=0;for (i=x;i;i-=lowbit(i)){for (j=y;j;j-=lowbit(j)){s+=a[i][j];}}return s;}T_ query(long long x,long long y,long long xx,long long yy){return query(xx,yy)-query(x-1,yy)-query(xx,y-1)+query(x-1,y-1);}};\nlong long n,m,i,j,k,dis[325],cnt,a[325],b[325],v[325],s=0,t=321,l[325],r[325],u[325],d[325],x,y,cst,inq[325],vis[325],ans;\nvector<long long> allx,ally;\nchar c[325],ca[325],cb[325];\nstruct ii\n{\n\tlong long y,z,d;\n}e[10005];\nvector<long long> bi[10005];\nvoid init()\n{\n\tint i;fz0g(i,321) bi[i].clear();cnt=0;\n}\nvoid add(long long x,long long y,long long z,long long d)\n{\n\tcnt++;bi[x].push_back(cnt*2-2);bi[y].push_back(cnt*2-1);\n\te[cnt*2-2]=(ii){y,z,d};e[cnt*2-1]=(ii){x,0,-d};\n}\nbool bfs(long long s,long long t)\n{\n\tmemset(dis,-0x18,sizeof(dis));dis[s]=0;queue<long long> qx;qx.push(s);inq[s]=1;\n\twhile (!qx.empty()){\n\t\tlong long x=qx.front();qx.pop();inq[x]=0;ff(bi[x],it) if (e[*it].z){\n\t\t\tlong long y=e[*it].y,z=dis[x]+e[*it].d;\n\t\t\tif (dis[y]<z){\n\t\t\t\tdis[y]=z;\n\t\t\t\tif (!inq[y]){\n\t\t\t\t\tinq[y]=1;qx.push(y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}return dis[t]>dis[324];\n}\nlong long dfs(long long x,long long tt,long long flw)\n{\n\tif (x==tt) vis[tt]=1;\n\tif (x==tt||!flw) return flw;if (vis[x])return 0;vis[x]=1;long long ans=0;ff(bi[x],it) if (e[*it].z&&dis[e[*it].y]==dis[x]+e[*it].d){\n\t\tlong long t=dfs(e[*it].y,tt,min(flw,e[*it].z));cst+=t*e[*it].d;ans+=t;flw-=t;e[*it].z-=t;e[(*it)^1].z+=t;if (!flw) break;\n\t}return ans;\n}\nbool dinic(long long s,long long t,long long aa)\n{\n\tlong long ans=0;while (bfs(s,t)){\n\t\tdo{\n\t\t\tmemset(vis,0,sizeof(vis));\n\t\t\tans+=dfs(s,t,aa);\n\t\t}while (vis[t]);\n\t}if (ans==aa) return 1;return 0;\n}\nint main()\n{\n\tscanf(\"%lld\",&n);\n\tfz1(i,n){\n\t\tscanf(\"%lld%lld%lld\",&a[i],&b[i],&v[i]);\n//\t\tallx.push_back(a[i]);ally.push_back(b[i]);\n\t}//sort(allx.begin(),allx.end());allx.resize(unique(allx.begin(),allx.end())-allx.begin());sort(ally.begin(),ally.end());ally.resize(unique(ally.begin(),ally.end())-ally.begin());\n\t/*fz1(i,n){\n\t\ta[i]=upper_bound(allx.begin(),allx.end(),a[i])-allx.begin();\n\t\tb[i]=upper_bound(ally.begin(),ally.end(),b[i])-ally.begin();\n\t}*/\n\tscanf(\"%lld\",&m);fz1(i,m){\n\t\tscanf(\" %c%lld%lld\",&c[i],&ca[i],&cb[i]);\n\t}\n\tans=0;\n\tfz1(i,n){\n\t\tcst=0;init();\n\t\tfz1(j,i){\n\t\t\tl[i]=d[i]=0;\n\t\t\tr[i]=u[i]=0x1818181818181818ll;\n\t\t}\n\t\tfz1(j,m) if (cb[j]<i){\n\t\t\tif (c[j]=='L') l[cb[j]+1]=max(l[cb[j]+1],ca[j]+1ll);\n\t\t\tif (c[j]=='R') r[i-cb[j]]=min(r[i-cb[j]],ca[j]-1ll);\n\t\t\tif (c[j]=='D') d[cb[j]+1]=max(d[cb[j]+1],ca[j]+1ll);\n\t\t\tif (c[j]=='U') u[i-cb[j]]=min(u[i-cb[j]],ca[j]-1ll);\n\t\t}\n\t\tfz(j,2,i){\n\t\t\tl[j]=max(l[j],l[j-1]);\n\t\t\td[j]=max(d[j],d[j-1]);\n\t\t}\n\t\tfd(j,i-1,1){\n\t\t\tr[j]=min(r[j],r[j+1]);\n\t\t\tu[j]=min(u[j],u[j+1]);\n\t\t}\n\t\tfz1(j,i)fz1(k,n){\n\t\t\tif (l[j]<=a[k]&&a[k]<=r[j]){\n\t\t\t\tadd(j,n+k,1,0);\n\t\t\t}\n\t\t\tif (d[j]<=b[k]&&b[k]<=u[j]){\n\t\t\t\tadd(n+n+k,n+n+n+j,1,0);\n\t\t\t}\n\t\t}\n\t\tfz1(j,i){\n\t\t\tadd(s,j,1,0);add(n+n+n+j,t,1,0);\n\t\t}fz1(j,n){\n\t\t\tadd(j+n,j+n+n,1,v[j]);\n\t\t}if (dinic(s,t,i)) ans=max(ans,cst);\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n#define MAXN 100\n#define MAXM 500\n#define LL long long\nconst double eps=1e-10;\ndouble a[MAXM][MAXN];\nint n,m;\nvoid pivot(int r,int c)\n{\n\tdouble tmp=-a[r][c];\n\ta[r][c]=-1;\n\tfor(int i=0;i<=n;i++) a[r][i]/=tmp;\n\tfor(int i=0;i<=m;i++)\n\t\tif(a[i][c]&&i!=r)\n\t\t{\n\t\t\ttmp=a[i][c];a[i][c]=0;\n\t\t\tfor(int j=0;j<=n;j++)\n\t\t\t\ta[i][j]+=tmp*a[r][j];\n\t\t}\n}\nvoid Solve()\n{\n\twhile(1)\n\t{\n\t\tdouble tmp=eps;\n\t\tint i=0,j=0;\n\t\tfor(int k=1;k<=n;k++) if(a[0][k]>tmp) tmp=a[0][j=k];\n\t\tif(!j) break;\n\t\ttmp=1e17;\n\t\tfor(int k=1;k<=m;k++) if(a[k][j]<-eps&&-a[k][0]/a[k][j]<tmp)\n\t\t{\n\t\t\ttmp=-a[k][0]/a[k][j];\n\t\t\ti=k;\n\t\t}\n\t\tpivot(i,j);\n\t}\n\tprintf(\"%.0lf\\n\",ceil(a[0][0]));\n}\nint N,M,x[MAXN],y[MAXN],A;\nchar s[5];\nint main()\n{\n\tscanf(\"%d\",&N);\n\tfor(int i=1;i<=N;i++)\n\t\tscanf(\"%d%d%lf\",&x[i],&y[i],&a[0][i]);\n\tscanf(\"%d\",&M);\n\tfor(int i=1;i<=M;i++)\n\t{\n\t\tscanf(\"%s%d%lf\",s,&A,&a[i][0]);\n\t\tif(s[0]=='L')\n\t\t{\n\t\t\tfor(int j=1;j<=N;j++)\n\t\t\t\tif(x[j]<=A) a[i][j]=-1;\n\t\t}\n\t\telse if(s[0]=='R')\n\t\t{\n\t\t\tfor(int j=1;j<=N;j++)\n\t\t\t\tif(x[j]>=A) a[i][j]=-1;\n\t\t}\n\t\telse if(s[0]=='D')\n\t\t{\n\t\t\tfor(int j=1;j<=N;j++)\n\t\t\t\tif(y[j]<=A) a[i][j]=-1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(int j=1;j<=N;j++)\n\t\t\t\tif(y[j]>=A) a[i][j]=-1;\n\t\t}\n\t}\n\tfor(int i=1;i<=N;i++)\n\t\ta[i+M][0]=1,a[i+M][i]=-1;\n\tn=N;m=M+N;\n\tSolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cctype>\n#include<iostream>\n#include<queue>\n#define RI register int\n#define CI const int&\nusing namespace std;\nconst int N=350,M=(N*N<<1)+(3*N);\nconst long long INF=1e18;\nstruct edge\n{\n\tint to,nxt,v; long long c;\n}e[M<<1]; char opt[N]; long long ans,v[N];\nint n,m,head[N],cnt,x[N],y[N],L[N],R[N],U[N],D[N],a[N],b[N],s,t;\ninline char getch(void)\n{\n\tchar ch; while (!isalpha(ch=getchar())); return ch;\n}\ninline void addedge(CI x,CI y,CI v,const long long& c)\n{\n\te[++cnt]=(edge){y,head[x],v,c}; head[x]=cnt;\n\te[++cnt]=(edge){x,head[y],0,-c}; head[y]=cnt;\n}\n#define to e[i].to\nnamespace NF //Network_Flow\n{\n\tqueue <int> q; int pre[N],lst[N],cap[N]; long long dis[N]; bool vis[N];\n\tinline bool SPFA(CI s,CI t)\n\t{\n\t\tRI i; for (i=s;i<=t;++i) dis[i]=-INF,cap[i]=1e9,pre[i]=-1;\n\t\tpre[s]=0; q.push(s); dis[s]=0; vis[s]=1; while (!q.empty())\n\t\t{\n\t\t\tint now=q.front(); q.pop(); vis[now]=0;\n\t\t\tfor (i=head[now];i;i=e[i].nxt)\n\t\t\tif (e[i].v&&dis[to]<dis[now]+e[i].c)\n\t\t\t{\n\t\t\t\tdis[to]=dis[now]+e[i].c; pre[to]=now; lst[to]=i;\n\t\t\t\tcap[to]=min(cap[now],e[i].v); if (!vis[to]) vis[to]=1,q.push(to);\n\t\t\t}\n\t\t}\n\t\treturn ~pre[t];\n\t}\n\tinline long long MCMF(CI s,CI t)\n\t{\n\t\tlong long ret=0; while (SPFA(s,t))\n\t\t{\n\t\t\tret+=dis[t]*cap[t]; for (int nw=t;nw;nw=pre[nw])\n\t\t\te[lst[nw]].v-=cap[t],e[lst[nw]^1].v+=cap[t];\n\t\t}\n\t\treturn ret;\n\t}\n\tinline void clear(CI n)\n\t{\n\t\tcnt=1; for (RI i=0;i<=n;++i) head[i]=0;\n\t}\n};\n#undef to\ninline long long calc(CI k)\n{\n\tRI i,j; for (i=1;i<=k;++i) L[i]=D[i]=0,R[i]=U[i]=1e9;\n\tfor (NF::clear(2*n+2*k+1),i=1;i<=m;++i) if (b[i]<k) \n\t{\n\t\tif (opt[i]=='L') L[b[i]+1]=a[i]+1;\n\t\tif (opt[i]=='R') R[k-b[i]]=a[i]-1; \n\t\tif (opt[i]=='D') D[b[i]+1]=a[i]+1;\n\t\tif (opt[i]=='U') U[k-b[i]]=a[i]-1; \n\t}\n\tfor (i=2;i<=k;++i) L[i]=max(L[i],L[i-1]),D[i]=max(D[i],D[i-1]);\n\tfor (i=k-1;i;--i) R[i]=min(R[i],R[i+1]),U[i]=min(U[i],U[i+1]);\n\tfor (s=0,t=2*n+2*k+1,i=1;i<=k;++i) addedge(s,i,1,0),addedge(k+2*n+i,t,1,0);\n\tfor (i=1;i<=n;++i) addedge(k+i,k+n+i,1,v[i]);\n\tfor (i=1;i<=k;++i) for (j=1;j<=n;++j)\n\t{\n\t\tif (L[i]<=x[j]&&x[j]<=R[i]) addedge(i,k+j,1,0);\n\t\tif (D[i]<=y[j]&&y[j]<=U[i]) addedge(k+n+j,k+2*n+i,1,0);\n\t}\n\treturn NF::MCMF(s,t);\n}\nint main()\n{\n\tRI i; for (scanf(\"%d\",&n),i=1;i<=n;++i) scanf(\"%d%d%lld\",&x[i],&y[i],&v[i]);\n\tfor (scanf(\"%d\",&m),i=1;i<=m;++i) opt[i]=getch(),scanf(\"%d%d\",&a[i],&b[i]);\n\tfor (i=1;i<=n;++i) ans=max(ans,calc(i)); return printf(\"%lld\",ans),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <assert.h>\n\nusing namespace std;\n\nstruct Jewel\n{\n  int x, y;\n  long long v;\n\n  bool operator<(const Jewel &other) const\n  {\n    return other.v < v;\n  }\n};\n\nstruct Request\n{\n  string t;\n  int a, b;\n  int cnt = 0;\n};\n\nint main()\n{\n  int N;\n  cin >> N;\n  vector<Jewel> jewel(N);\n  for (int i = 0; i < N; i++)\n  {\n    int x, y;\n    long long v;\n    cin >> x >> y >> v;\n    jewel[i] = {x, y, v};\n  }\n  int M;\n  cin >> M;\n  vector<Request> request(M);\n  for (int i = 0; i < M; i++)\n  {\n    string t;\n    int a, b;\n    cin >> t >> a >> b;\n    request[i] = {t, a, b};\n  }\n  sort(jewel.begin(), jewel.end());\n  long long ans = 0;\n  for (Jewel i : jewel)\n  {\n    bool ok = true;\n    for (Request j : request)\n      switch (j.t[0])\n      {\n      case 'L':\n        if (i.x <= j.a && j.b < j.cnt + 1)\n          ok = false;\n        break;\n      case 'R':\n        if (j.a <= i.x && j.b < j.cnt + 1)\n          ok = false;\n        break;\n      case 'D':\n        if (i.y <= j.a && j.b < j.cnt + 1)\n          ok = false;\n        break;\n      case 'U':\n        if (j.a <= i.y && j.b < j.cnt + 1)\n          ok = false;\n        break;\n      }\n    if (!ok)\n      continue;\n    ans += i.v;\n    for (Request &j : request)\n      switch (j.t[0])\n      {\n      case 'L':\n        if (i.x <= j.a)\n          j.cnt++;\n        break;\n      case 'R':\n        if (j.a <= i.x)\n          j.cnt++;\n        break;\n      case 'D':\n        if (i.y <= j.a)\n          j.cnt++;\n        break;\n      case 'U':\n        if (j.a <= i.y)\n          j.cnt++;\n        break;\n      }\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nostream &operator<<(ostream &os, __float128 f) { return os << (LD)f; }\n\n\nstruct Simplex {        // Maximize c*x subject to Ax <= b.\n  using T = LD;         // Initialize the structure, set A, b, c and then run\n  vector<vector<T>> A;  // solve(). Max objective is stored in res. To recover\n  vector<T> b, c;       // the best result, use getVars().\n  T abs(T x) { return x < 0 ? -x : x; }\n\n  int V, E;\n  VI eqIds, varIds, cols;\n  T res;\n  const LD kEps = 1e-9;\n\n  Simplex(int vars, int eqs) : A(eqs, vector<T>(vars)), b(eqs), c(vars),\n                               V(vars), E(eqs), eqIds(eqs), varIds(vars), res(0) {\n    iota(ALL(varIds), 0); iota(ALL(eqIds), vars);\n  }\n\n  void pivot(int eq, int var) {\n    T coef = 1 / A[eq][var];\n    cols.clear();\n    REP (i, V) {\n      if (abs(A[eq][i]) > kEps) { cols.PB(i); A[eq][i] *= coef; }\n    }\n    A[eq][var] *= coef; b[eq] *= coef;\n    REP (row, E) {\n      if (row == eq || abs(A[row][var]) < kEps) { continue; }\n      T k = -A[row][var];\n      A[row][var] = 0;\n      for (int i : cols) { A[row][i] += k * A[eq][i]; }\n      b[row] += k * b[eq];\n    }\n    T q = c[var]; c[var] = 0;\n    for (int i : cols) { c[i] -= q * A[eq][i]; }\n    res += q * b[eq];\n\n    swap(varIds[var], eqIds[eq]);\n  }\n  \n  bool solve() {\n    while (true) {\n      int eq = -1, var = -1;\n      REP (i, E) { if (b[i] < -kEps) { eq = i; break; } }\n      if (eq == -1) { break; }\n      REP (i, V) { if (A[eq][i] < -kEps) { var = i; break; } }\n      if (var == -1) { res = -1e9; return false; /* No solution */ }\n      pivot(eq, var);\n    }\n\n    while (true) {\n      int var = -1, eq = -1;\n      REP (i, V) { if (c[i] > kEps) { var = i; break; } }\n      if (var == -1) { break; }\n      REP (i, E) {\n        if (A[i][var] < kEps) { continue; }\n        if (eq >= 0 && b[i] / A[i][var] >= b[eq] / A[eq][var]) { continue; }\n        eq = i;\n      }\n      if (eq == -1) { res = 1e9; return false; /* Unbounded */ }\n      pivot(eq, var);\n    }\n\n    return true;\n  }\n  \n  vector<T> getVars() {  // Optimal assignment of variables.\n    vector<T> result(V);\n    REP (i, E) { if (eqIds[i] < V) { result[eqIds[i]] = b[i]; } }\n    return result;\n  }\n};\n\nint N, M;\nvector<PII> points;\nVI point_vals;\n\nLL low_bound;\nclock_t time_start;\n\nvoid Solve(Simplex sim) {\n  Simplex sim_copy = sim;\n  assert(sim.solve());\n\n  if (sim.res - 1e-9 < low_bound) { return; }\n  auto vars = sim.getVars();\n\n  if ((clock() - time_start) > 4.9 * CLOCKS_PER_SEC) {\n    cout << low_bound << \"\\n\";\n    exit(0);\n  }\n\n  LL my_low = 0;\n  for (int i = 0; i < N; ++i) {\n    if (vars[i] > .99) {\n      my_low += point_vals[i];\n      //sim_copy.b[M + i * 2] = -1;\n    }\n  }\n\n  maxi(low_bound, my_low);\n  bool had_any = false;\n  for (int i = 0; i < N; ++i) {\n    if (vars[i] > .01 && vars[i] < .989) {\n      had_any = true;\n    }\n  }\n\n  if (had_any) {\n    // take none?\n    for (int i = 0; i < N; ++i) {\n      if (vars[i] > .01 && vars[i] < .989) {\n        sim_copy.b[M + i * 2 + 1] = 0;\n      }\n    }\n    Solve(sim_copy);\n  }\n\n  for (int i = 0; i < N; ++i) {\n    if (vars[i] > .01 && vars[i] < .989) {\n      // take?\n      sim_copy.b[M + i * 2] = -1;\n      Solve(sim_copy);\n      sim_copy.b[M + i * 2] = 0;\n      if (sim.res - 1e-9 < low_bound) { return; }\n    }\n  }\n\n}\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n  time_start = clock();\n\n  cin >> N;\n  points.resize(N);\n  point_vals.resize(N);\n\n  for (int i = 0; i < N; ++i) {\n    cin >> points[i].st >> points[i].nd >> point_vals[i];\n  }\n\n  map<char, function<bool(PII, int)>> checkers = {\n    {'L', [](const PII &pt, int a) { return pt.st <= a; }},\n    {'R', [](const PII &pt, int a) { return pt.st >= a; }},\n    {'D', [](const PII &pt, int a) { return pt.nd <= a; }},\n    {'U', [](const PII &pt, int a) { return pt.nd >= a; }}\n  };\n\n  cin >> M;\n\n  Simplex sim(N, M + 2 * N);\n  for (int i = 0; i < M; ++i) {\n    char type;\n    int a, b;\n    cin >> type >> a >> b;\n\n    for (int j = 0; j < N; ++j) {\n      sim.A[i][j] = checkers[type](points[j], a);\n    }\n    sim.b[i] = b;\n\n    debug(sim.A[i], sim.b[i]);\n  }\n  for (int i = 0; i < N; ++i) {\n    sim.c[i] = point_vals[i];\n    sim.A[M + i * 2][i] = -1;\n    sim.A[M + i * 2 + 1][i] = 1;\n    sim.b[M + i * 2] = 0;\n    sim.b[M + i * 2 + 1] = 1;\n  }\n  auto orig_a = sim.A;\n  auto orig_b = sim.b;\n\n  Solve(sim);\n  cout << low_bound << \"\\n\";\n\n  /*assert(sim.solve());\n  auto vars = sim.getVars();\n\n  vector<int> always, maybe;\n  debug(vars);\n  for (int i = 0; i < N; ++i) {\n    if (vars[i] > 0.7) {\n      always.PB(i);\n    } else if (vars[i] > 0.3) {\n      maybe.PB(i);\n    }\n  }\n\n  debug(always, maybe);\n\n  assert(SZ(maybe) <= 3);\n  LL ans = -1;\n\n  for (LL m = 0; m < (1LL << SZ(maybe)); ++m) {\n    vector<int> mine = always;\n    for (int j = 0; j < SZ(maybe); ++j) {\n      if ((m >> j) & 1) { mine.PB(maybe[j]); }\n    }\n\n    bool fail = false;\n    for (int i = 0; i < M; ++i) {\n      int cnt = 0;\n      for (int j : mine) {\n        if (orig_a[i][j] > 0.5) { ++cnt; }\n      }\n      debug(mine, i, cnt, orig_b[i]);\n      if (cnt > (int)round((LD)orig_b[i])) { debug(i); fail = true; }\n    }\n\n    if (fail) { continue; }\n    LL x = 0;\n    for (int i : mine) {\n      x += point_vals[i];\n    }\n    maxi(ans, x);\n  }\n\n  cout << ans << \"\\n\";*/\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace __gnu_pbds;\nusing namespace std;\n \ntemplate <typename T>\nusing ordered_set =\n\ttree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n \n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n\t*this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n \n#define shandom_ruffle random_shuffle\n \nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=327;\nusing bn=bitset<87>;\nusing ld=long double;\n\nint n;\npii gdz[nax];\nll war[nax];\n\nint m;\nbn podz[nax];\nint ile[nax];\n\nll wyn;\n\nbn ter;\n \nll dajwar()\n{\n\tll ret=0;\n\tfor (int i=1; i<=n; i++)\n\t\tif (ter[i])\n\t\t\tret+=war[i];\n\treturn ret;\n}\n \nint popr()\n{\n\tfor (int i=1; i<=m; i++)\n\t\tif ((podz[i]&ter).count()>ile[i])\n\t\t\treturn 0;\n\treturn 1;\n}\n\nstruct Simplex {        // Maximize c*x subject to Ax <= b.\n  using T = ld;     // Initialize the structure, set A, b, c and then run\n  vector<vector<T>> A;  // solve(). Max objective is stored in res. To recover\n  vector<T> b, c;       // the best result, use getVars().\n  int V, E;\n  vector<int> eqIds, varIds, cols;\n  T res;\n  static constexpr T kEps = 1e-5;\n\n  Simplex(int vars, int eqs) : A(eqs, vector<T>(vars)), b(eqs), c(vars),\n      V(vars), E(eqs), eqIds(eqs), varIds(vars), res(0) {\n    iota(varIds.begin(), varIds.end(), 0);\n    iota(eqIds.begin(), eqIds.end(), vars);\n  }\n\n  void pivot(int eq, int var) {\n    T coef = 1 / A[eq][var];\n    cols.clear();\n    for (int i = 0; i < V; i++) {\n      if (abs(A[eq][i]) > kEps) { cols.push_back(i); A[eq][i] *= coef; }\n    }\n    A[eq][var] *= coef; b[eq] *= coef;\n    for (int row = 0; row < E; row++) {\n      if (row == eq || abs(A[row][var]) < kEps) { continue; }\n      T k = -A[row][var];\n      A[row][var] = 0;\n      for (int i : cols) { A[row][i] += k * A[eq][i]; }\n      b[row] += k * b[eq];\n    }\n    T q = c[var]; c[var] = 0;\n    for (int i : cols) { c[i] -= q * A[eq][i]; }\n    res += q * b[eq];\n    swap(varIds[var], eqIds[eq]);\n  }\n\n  bool solve() {\n    while (true) {\n      int eq = -1, var = -1;\n      for (int i = 0; i < E; i++) { if (b[i] < -kEps) { eq = i; break; } }\n      if (eq == -1) { break; }\n      for (int i = 0; i < V; i++) { if (A[eq][i] < -kEps) { var = i; break; } }\n      if (var == -1) { res = -1e9; return false; /* No solution */ }\n      pivot(eq, var);\n    }\n    while (true) {\n      int var = -1, eq = -1;\n      for (int i = 0; i < V; i++) { if (c[i] > kEps) { var = i; break; } }\n      if (var == -1) { break; }\n      for (int i = 0; i < E; i++) {\n        if (A[i][var] < kEps) { continue; }\n        if (eq >= 0 && b[i] / A[i][var] >= b[eq] / A[eq][var]) { continue; }\n        eq = i;\n      }\n      if (eq == -1) { res = 1e9; return false; /* Unbounded */ }\n      pivot(eq, var);\n    }\n    return true;\n  }\n\n  vector<T> getVars() { // Optimal assignment of variables.\n    vector<T> result(V);\n    for (int i = 0; i < E; i++) if (eqIds[i] < V) result[eqIds[i]] = b[i];\n    return result;\n  }\n};\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(\"%d%d%lld\", &gdz[i].first, &gdz[i].second, &war[i]);\n\tscanf(\"%d\", &m);\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\tchar c;\n\t\tint a, b;\n\t\tscanf(\" %c%d%d\", &c, &a, &b);\n\t\tfor (int j=1; j<=n; j++)\n\t\t{\n\t\t\tif (c=='L' && gdz[j].first<=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='R' && gdz[j].first>=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='D' && gdz[j].second<=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='U' && gdz[j].second>=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t}\n\t\tile[i]=b;\n\t}\n\tSimplex janusz(n, m+2*n);\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tjanusz.c[i]=war[i+1];\n\t}\n\tfor (int i=0; i<m; i++)\n\t{\n\t\tjanusz.b[i]=ile[i+1];\n\t\tfor (int j=0; j<n; j++)\n\t\t\tjanusz.A[i][j]=podz[i+1][j+1];\n\t}\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tjanusz.b[m+i]=1;\n\t\tjanusz.A[m+i][i]=1;\n\t}\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tjanusz.b[m+n+i]=0;\n\t\tjanusz.A[m+n+i][i]=-1;\n\t}\n\tassert(janusz.solve());\n\tauto wez=janusz.getVars();\n\t\n\tfor (int i=0; i<n; i++)\n\t\tter[i+1]=(wez[i]>0.5);\n\t\n\tll sta=dajwar();\n\t\n\twyn=sta;\n\t\n\tassert(popr());\n\t\n\tdebug() << janusz.getVars();\n\tprintf(\"%lld\\n\", wyn);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n\n\n\nclass min_cost_flow {\n\tstruct ed {\n\t\tint rev;\n\t\tlong long int cost;\n\t\tlong long int cap;\n\t\tint to;\n\t\ted(int rev_, long long int cost_, long long int cap_, int to_) {\n\t\t\trev = rev_;\n\t\t\tcost = cost_;\n\t\t\tcap = cap_;\n\t\t\tto = to_;\n\t\t}\n\t};\n\tvector<long long int> prevv;\n\tvector<long long int> pot;\n\tvector<long long int> dist;\n\tvector<long long int> preve;  //直前の辺\n\tvector<vector<ed> > g;  //graph\n\tint sizee = 0;\npublic:\n\tlong long int must;\n\tmin_cost_flow(int n2 = 0) {\n\t\tif (n2 == 0) {\n\t\t\treturn;\n\t\t}\n\t\tmust = 0;\n\t\tsizee = n2;\n\t\tprevv.resize(n2);\n\t\tdist.resize(n2);\n\t\tpot.resize(n2);\n\t\tg.resize(n2);\n\t\tpreve.resize(n2);\n\t}\n\tint sss;\n\tint ttt;\n\tvoid resize(int n2) {\n\t\tn2 += 3;\n\t\tsss = n2 - 2;\n\t\tttt = n2 - 1;\n\t\tsizee = n2;\n\t\tmust = 0;\n\t\tprevv.resize(n2);\n\t\tdist.resize(n2);\n\t\tpot.resize(n2);\n\t\tg.resize(n2);\n\t\tpreve.resize(n2);\n\t}\n\tvoid clear() {\n\t\tsizee = 0;\n\t\tprevv.clear();\n\t\tdist.clear();\n\t\tpot.clear();\n\t\tg.clear();\n\t\tpreve.clear();\n\t}\n\tint size() {\n\t\treturn sizee;\n\t}\n\tvoid add(int from_, int to_, long long int cap_, long long int cost_) {\n\t\tg[from_].push_back(ed(g[to_].size(), cost_, cap_, to_));\n\t\tg[to_].push_back(ed(g[from_].size() - 1, -cost_, 0, from_));\n\t}\n\tvoid add_edge(int from_, int to_, long long int dc,long long int uc, long long int cost_) {\n\t\tadd(from_, to_, uc - dc, cost_);\n\t\tadd(sss, to_, dc, 0);\n\t\tadd(from_, ttt, dc, 0);\n\t\tmust += dc;\n\t}\n\t\n\tlong long int min_cost(int s, int t, long long int f) {\n\t\tconst long long int INF = -1000000001000000000LL;\n\t\tadd(sss, s, f, 0);\n\t\tadd(t, ttt, f, 0);\n\t\ts = sss;\n\t\tt = ttt;\n\t\tf += must;\n\t\tlong long int res = 0;\n\t\tfill(pot.begin(), pot.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tfill(dist.begin(), dist.end(),INF );\n\t\t\tqueue<int> q;\n\t\t\tq.push(s);\n\t\t\tdist[s] = 0;\n\t\t\twhile (!q.empty()) {\n\t\t\t\tint kari = q.front();\n\t\t\t\tq.pop();\n\t\t\t\tfor (int i = 0; i < g[kari].size(); i++) {\n\t\t\t\t\ted &e = g[kari][i];\n\t\t\t\t\tif (e.cap > 0 && (dist[e.to] == INF || dist[e.to] > dist[kari] + e.cost + pot[kari] - pot[e.to])) {\n\t\t\t\t\t\tdist[e.to] = dist[kari] + e.cost + pot[kari] - pot[e.to];\n\t\t\t\t\t\tprevv[e.to] = kari;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tq.push(e.to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == INF) {\n\t\t\t\treturn 114514;  //error\n\t\t\t}\n\t\t\tfor (int i = 0; i < dist.size(); i++) {\n\t\t\t\tpot[i] += dist[i];\n\t\t\t}\n\t\t\tlong long int mint = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tmint = min(mint, g[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= mint;\n\t\t\tres += mint * pot[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\ted &e = g[prevv[v]][preve[v]];\n\t\t\t\te.cap -= mint;\n\t\t\t\tg[v][e.rev].cap += mint;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\nint n;\n\nstruct st {\n\tint a;\n\tint b;\n\tlong long int c;\n};\nvector<st> v;\n\nchar buf[3];\n\nstruct query {\n\tchar z;\n\tint a;\n\tint b;\n};\nvector<query> vq;\n\n#define MAX 115\n\nint limx[MAX];\nint limy[MAX];\nint dwx[MAX];\nint dwy[MAX];\n\nint enx[MAX];\nint eny[MAX];\n\nmin_cost_flow mf;\n\nlong long int calc(int b) {\n\tmf = min_cost_flow();\n\tfor (int i = 0; i < MAX; i++) {\n\t\tlimx[i] = limy[i] = b;\n\t\tdwx[i] = dwy[i] = 0;\n\t}\n\tfor (int i = 0; i < vq.size(); i++) {\n\t\tif (vq[i].z == 'L') {\n\t\t\tlimx[vq[i].a] = min(limx[vq[i].a], vq[i].b);\n\t\t\tcontinue;\n\t\t}\n\t\tif (vq[i].z == 'D') {\n\t\t\tlimy[vq[i].a] = min(limy[vq[i].a], vq[i].b);\n\t\t\tcontinue;\n\t\t}\n\t\tif (vq[i].z == 'R') {\n\t\t\tint sel = b - vq[i].b;\n\t\t\tif (sel >= 0) {\n\t\t\t\tdwx[vq[i].a-1] = max(dwx[vq[i].a-1], sel);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (vq[i].z == 'U') {\n\t\t\tint sel = b - vq[i].b;\n\t\t\tif (sel >= 0) {\n\t\t\t\tdwy[vq[i].a-1] = max(dwy[vq[i].a-1], sel);\n\t\t\t}\n\t\t}\n\t}\n\tmf.resize(MAX * 3);\n\tint ord = 0;\n\tint star=ord++;\n\tint en=ord++;\n\t{\n\t\tint dx = 0;\n\t\tint ux = b;\n\t\tint p = star;\n\t\tfor (int j = MAX - 1; j >= 0; j--) {\n\t\t\tux = limx[j];// min(ux, limx[j]);\n\t\t\tdx = dwx[j];\n\t\t\tif (dx > ux)return 114514;\n\t\t\tint cur = ord++;\n\t\t\tmf.add_edge(p, cur, dx, ux, 0);\n\t\t\tenx[j] = cur;\n\t\t\tp = cur;\n\t\t}\n\t}\n\t{\n\t\tint dy = 0;\n\t\tint uy = b;\n\t\tint p = en;\n\t\tfor (int j = MAX-1; j>=0; j--) {\n\t\t\tuy = limy[j];// min(uy, limy[j]);\n\t\t\tdy = dwy[j];\n\t\t\tif (dy > uy)return 114514;;\n\t\t\tint cur = ord++;\n\t\t\tmf.add_edge(cur,p, dy, uy, 0);\n\t\t\teny[j] = cur;\n\t\t\tp = cur;\n\t\t}\n\t}\n\tfor (int i = 0; i < v.size(); i++) {\n\t\tmf.add_edge(enx[v[i].a], eny[v[i].b], 0, 1, -v[i].c);\n\t}\n\tlong long int cost = mf.min_cost(star, en, b);\n\treturn cost;\n}\n\n\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tint a, b;\n\t\tlong long int c;\n\t\tscanf(\"%d%d%lld\", &a, &b, &c);\n\t\tv.push_back({ a,b,c });\n\t}\n\tint q;\n\tcin >> q;\n\tfor (int i = 1; i <= q; i++) {\n\t\tint a, b;\n\t\tscanf(\"%s\", buf);\n\t\tchar ty = buf[0];\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tvq.push_back({ buf[0],a,b });\n\t}\n\tlong long int ans = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tlong long int w=calc(i);\n\t\t//cout << i << \" \" << w << endl;\n\t\tif (w == 114514)break;\n\t\tans = min(ans, w);\n\t}\n\tprintf(\"%lld\\n\", -ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#define foreach(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\n#ifndef LOCAL\n#define cerr if(0)cout\n#endif\ntypedef long long ll;\nconst int mod = 1e9+7;\n//My i/o stream\nstruct fastio\n{\n\tchar s[100000];\n\tint it, len;\n\tfastio() {it=len=0;}\n\tinline char get()\n\t{\n\t\tif (it<len) return s[it++]; it=0;\n\t\tlen=fread(s, 1, 100000, stdin);\n\t\tif (len==0) return EOF; else return s[it++];\n\t}\n\tbool notend()\n\t{\n\t\tchar c=get();\n\t\twhile (c==' '||c=='\\n') c=get();\n\t\tif (it>0) it--;\n\t\treturn c!=EOF;\n\t}\n}_buff;\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putchar(' ')\n#define putii(x,y) puti(x),puti(y)\n#define putiii(x,y,z) putii(x,y),puti(z)\n#define putsi(x) putnum(x),putchar('\\n')\n#define putsii(x,y) puti(x),putsi(y)\n#define putsiii(x,y,z) putii(x,y),putsi(z)\ninline ll getnum()\n{\n\tll r=0; bool ng=0; char c; c=_buff.get();\n\twhile (c!='-'&&(c<'0'||c>'9')) c=_buff.get();\n\tif (c=='-') ng=1, c=_buff.get();\n\twhile (c>='0'&&c<='9') r=r*10+c-'0', c=_buff.get();\n\treturn ng?-r:r;\n}\ntemplate <class T> inline void putnum(T x)\n{\n\tif (x<0) putchar('-'), x=-x;\n\tregister short a[20]={}, sz=0;\n\twhile (x) a[sz++]=x%10, x/=10;\n\tif(sz==0) putchar('0');\n\tfor (int i=sz-1; i>=0; i--) putchar('0'+a[i]);\n}\ninline char getreal() {char c=_buff.get(); while (c<=32) c=_buff.get(); return c;}\nll qpow(ll x, ll k) {return k==0? 1: 1ll*qpow(1ll*x*x%mod,k>>1)*(k&1?x:1)%mod;}\nconst ll inf = 4e18;\nnamespace F\n{\n\tconst int maxn = 1011, maxe = 100011;\n\tint head[maxn], nxt[maxe], to[maxe], cap[maxe];\n\tll cost[maxe], tot;\n\tll ftot;\n\tvoid init()\n\t{\n\t\tftot = 0;\n\t\ttot = 1;\n\t\tmemset(head, 0, sizeof(head));\n\t}\n\tvoid add_edge(int x, int y, int c, ll w)\n\t{\n//\t\tcerr<<\"add_edge:\"<<x<<\",\"<<y<<\" \"<<c<<\" \"<<w<<endl;\n\t\tnxt[++tot] = head[x];\n\t\thead[x] = tot;\n\t\tto[tot] = y;\n\t\tcap[tot] = c;\n\t\tcost[tot] = w;\n\t\tswap(x, y);\n\t\tnxt[++tot] = head[x];\n\t\thead[x] = tot;\n\t\tto[tot] = y;\n\t\tcap[tot] = 0;\n\t\tcost[tot] = -w;\n\t\tassert(tot<maxe);\n\t}\n\tint q[maxn], qb, qe;\n\tll dis[maxn];\n\tbool inq[maxn];\n\tint qnxt(int x) {return (x+1)%maxn;}\n\tint qpre(int x) {return (x-1+maxn)%maxn;}\n\tvoid balance()\n\t{\n\t\tif (qb!=qe&&dis[q[qpre(qe)]]<dis[q[qb]])\n\t\t{\n\t\t\tswap(q[qpre(qe)], q[qb]);\n\t\t}\n\t}\n\tvoid spfa(int S, int N)\n\t{\n\t\tinq[S] = 1;\n\t\tfor (int i=0; i<=N; i++) dis[i] = inf;\n\t\tdis[S] = 0;\n\t\tqb = qe = 0;\n\t\tq[qe++] = S;\n\t\twhile (qb<qe)\n\t\t{\n\t\t\tint x = q[qb];\n\t\t\tinq[x] = 0;\n\t\t\tqb = qnxt(qb);\n\t\t\tbalance();\n\t\t\tfor (int i = head[x]; i; i=nxt[i])\n\t\t\t{\n\t\t\t\tif (cap[i]&&dis[to[i]]>dis[x]+cost[i])\n\t\t\t\t{\n\t\t\t\t\tdis[to[i]] = dis[x]+cost[i];\n\t\t\t\t\tif (!inq[to[i]])\n\t\t\t\t\t{\n\t\t\t\t\t\tinq[to[i]] = 1;\n\t\t\t\t\t\tq[qe] = to[i];\n\t\t\t\t\t\tqe = qnxt(qe);\n\t\t\t\t\t\tbalance();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tfor (int i=1; i<=N; i++) cerr<<dis[i]<<\" \"; cerr<<endl;\n\t}\n\t\n\tbool vis[maxn];\n\tint dfs(int x, int T, int f)\n\t{\n\t\tif (x==T) return f;\n\t\tvis[x] = 1;\n\t\tint of = f;\n\t\tfor (int i=head[x]; i; i=nxt[i])\n\t\t{\n\t\t\tif (!vis[to[i]]&&cap[i]&&dis[to[i]]==dis[x]+cost[i])\n\t\t\t{\n\t\t\t\tint u = to[i];\n\t\t\t\tint d = dfs(u, T, min(f, cap[i]));\n\t\t\t\tcap[i] -= d;\n\t\t\t\tcap[i^1] += d;\n\t\t\t\tf -= d;\n\t\t\t\tif (!f) return of;\n\t\t\t}\n\t\t}\n\t\treturn of-f;\n\t}\n\tll min_cost_max_flow(int S, int T, int K)\n\t{\n\t\tll ans = 0;\n\t\twhile (true)\n\t\t{\n\t\t\tspfa(S, T);\n\t\t\tif (dis[T]>=inf) return ans;\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\tmemset(vis, 0, sizeof(vis));\n\t\t\t\tint f = dfs(S, T, K);\n\t\t\t\tftot += f;\n\t\t\t\tans += 1ll*f*dis[T];\n\t\t\t\tif (f==0) break;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n};\nint n;\nint tid[256];\npair<int,int> a[88];\nll w[88];\nvector<pair<int,int> > M[4];\npair<int,int> segx[88], segy[88];\nll solve(int K)\n{\n//\tcerr<<\"solve: \"<<K<<endl;\n\tfor (int i=1; i<=K; i++) segx[i] = segy[i] = MP(0, 100);\n\tfor (auto x : M[0])\n\t{\n\t\tfor (int i=x.SS+1; i<=K; i++)\n\t\t{\n\t\t\tsegx[i].FF = max(segx[i].FF, x.FF+1);\n\t\t}\n\t}\n\tfor (auto x : M[1])\n\t{\n\t\tfor (int i=K-x.SS; i>=1; i--)\n\t\t{\n\t\t\tsegx[i].SS = min(segx[i].SS, x.FF-1);\n\t\t}\n\t}\n\tfor (auto x : M[2])\n\t{\n\t\tfor (int i=x.SS+1; i<=K; i++)\n\t\t{\n\t\t\tsegy[i].FF = max(segy[i].FF, x.FF+1);\n\t\t}\n\t}\n\tfor (auto x : M[3])\n\t{\n\t\tfor (int i=K-x.SS; i>=1; i--)\n\t\t{\n\t\t\tsegy[i].SS = min(segy[i].SS, x.FF-1);\n\t\t}\n\t}\n/*\tfor (int i=1; i<=K; i++)\n\t{\n\t\tcerr<<\"(\"<<segx[i].FF<<\",\"<<segx[i].SS<<\") (\"<<segy[i].FF<<\",\"<<segy[i].SS<<\")\"<<endl;\n\t}\n*/\t\n\tint S = 2*K+2*n+1, T = S+1;\n//\tcerr<<\"S=\"<<S<<\" T=\"<<T<<endl;\n\tF::init();\n\tfor (int i=1; i<=K; i++)\n\t{\n\t\tF::add_edge(S, i, 1, 0);\n\t\tF::add_edge(i+K, T, 1, 0);\n\t\tfor (int j=1; j<=n; j++)\n\t\t{\n\t\t\tif (segx[i].FF<=a[j].FF&&a[j].FF<=segx[i].SS)\n\t\t\t{\n\t\t\t\tF::add_edge(i, j+2*K, 1, 0);\n\t\t\t}\n\t\t\tif (segy[i].FF<=a[j].SS&&a[j].SS<=segy[i].SS)\n\t\t\t{\n\t\t\t\tF::add_edge(j+2*K+n, i+K, 1, 0);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1; i<=n; i++) F::add_edge(i+2*K, i+2*K+n, 1, -w[i]);\n\tll ans = F::min_cost_max_flow(S, T, K);\n//\tcerr<<\"F::ftot=\"<<F::ftot<<endl;\n\tif (F::ftot<K) return 0;\n//\tcerr<<\"ans=\"<<ans<<endl;\n\treturn -ans;\n}\nint main()\n{\n\ttid['L'] = 0;\n\ttid['R'] = 1;\n\ttid['D'] = 2;\n\ttid['U'] = 3;\n\tgeti(n);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tll x, y, v;\n\t\tgetiii(x, y, v);\n\t\ta[i] = MP(x, y);\n\t\tw[i] = v;\n\t}\n\tint m;\n\tgeti(m);\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\tchar t;\n\t\tint a, b;\n\t\tt = getreal();\n\t\tgetii(a, b);\n\t\tM[tid[t]].PB(MP(a, b));\n\t}\n\tll ans = 0;\n\tfor (int K=1; K<=n; K++)\n\t{\n\t\tans = max(ans, solve(K));\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=505,M=50005,R=100;\nconst ll inf=0x3f3f3f3f3f3f3f3fll;\nint read(){\n\tint f=1,g=0;\n\tchar ch=getchar();\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-') f=-1;\n\tfor (;isdigit(ch);ch=getchar()) g=g*10+ch-'0';\n\treturn f*g;\n}\nvoid chkmax(int &x,int y){if (x<y) x=y;}\nvoid chkmin(int &x,int y){if (x>y) x=y;}\nint n,m;\nstruct jew{int x,y;ll w;}a[N];\nstruct node{char typ;int x,r;}b[N];\nll cost,ans;\nint S,T,cnt,fir[N],fr[N],siz;\nstruct edge{int u,v;ll w;int fl,nex;}e[M];\nvoid add(int u,int v,ll w,int fl){\n\te[++siz]=(edge){u,v,w,fl,fir[u]};fir[u]=siz;\n\te[++siz]=(edge){v,u,-w,0,fir[v]};fir[v]=siz;\n}\nll dist[N];int que[N*50];bool inq[N];\nvoid dec(int x,int fl){e[x].fl-=fl;e[x^1].fl+=fl;}\nbool spfa(){\n\tmemset(dist,0xc0,8*(cnt+1));\n\tmemset(inq,0,cnt+1);\n\tint l=1,r=1;que[l]=S;dist[S]=0;inq[S]=1;\n\twhile (l<=r){\n\t\tint x=que[l];\n\t\tfor (int i=fir[x];i;i=e[i].nex)\n\t\tif ((e[i].fl)&&(dist[e[i].v]<dist[x]+e[i].w)){\n\t\t\tif (!inq[e[i].v]) {que[++r]=e[i].v;inq[e[i].v]=1;}\n\t\t\tdist[e[i].v]=dist[x]+e[i].w;fr[e[i].v]=i;\n\t\t}\n\t\tinq[x]=0;l++;\n\t}\n\treturn dist[T]>(ll)0xc0c0c0c0c0c0c0c0ll;\n}\nint update(){\n\tint t=0x3f3f3f3f;\n\tfor (int i=fr[T];i;i=fr[e[i].u]) t=min(t,e[i].fl);\n\tcost+=t*dist[T];\n\tfor (int i=fr[T];i;i=fr[e[i].u]) dec(i,t);\n\treturn t;\n}\nint dinic(){\n\tint flow=0;\n\twhile (spfa()) flow+=update();\n\treturn flow;\n}\nint ml[N],mr[N],mu[N],md[N];\nvoid calc(int L){\n\tmemset(fir,0,sizeof(fir));siz=1;\n\tS=0;T=cnt=L*2+R*2+1;\n\tfor (int i=1;i<=n;i++) add(a[i].x,a[i].y+R,a[i].w,1);\n\tfor (int i=1;i<=L;i++) {ml[i]=mu[i]=1,mr[i]=md[i]=R;add(S,R*2+i,0,1);add(R*2+L+i,T,0,1);}\n\tfor (int i=1;i<=m;i++)\n\tif (b[i].r>=L) continue;\n\telse if (b[i].typ=='L') chkmax(ml[b[i].r+1],b[i].x+1);\n\telse if (b[i].typ=='R') chkmin(mr[L-b[i].r],b[i].x-1);\n\telse if (b[i].typ=='D') chkmax(mu[b[i].r+1],b[i].x+1);\n\telse if (b[i].typ=='U') chkmin(md[L-b[i].r],b[i].x-1);\n\tfor (int i=2;i<=L;i++) chkmax(ml[i],ml[i-1]),chkmax(mu[i],mu[i-1]);\n\tfor (int i=L-1;i;i--)  chkmin(mr[i],mr[i+1]),chkmin(md[i],md[i+1]);\n\tfor (int i=1;i<=L;i++){\n\t\tfor (int j=ml[i];j<=mr[i];j++) add(R*2+i,j,0,1);\n\t\tfor (int j=mu[i];j<=md[i];j++) add(j+R,R*2+L+i,0,1);\n\t}\n\tcost=0;\n\tif (dinic()==L){\n\t\tans=max(ans,cost);\n//\t\tfor (int i=1;i<=n;i++) if (!e[i*2].fl) printf(\"%d \",i);\n//\t\tprintf(\"\\n\");\n\t}\n}\nint main(){\n\tn=read();\n\tfor (int i=1;i<=n;i++) scanf(\" %d %d %lld\",&a[i].x,&a[i].y,&a[i].w);\n\tm=read();\n\tfor (int i=1;i<=m;i++) scanf(\" %c %d %d\",&b[i].typ,&b[i].x,&b[i].r);\n\tfor (int i=1;i<=n;i++) calc(i);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n// #include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <set>\n#include <map>\n#include <bitset>\nusing namespace std;\ntypedef long long LL;\ntypedef double db;\nconst int oo=2139063143;\nconst int N=410;\nconst int P=1000000007;\nconst db eps=1e-7;\n#define pritnf printf\n//char buf[1<<22],*p1=buf,*p2=buf,obuf[1<<22],*O=obuf;\n//#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)\ntemplate <typename T>\ninline void sc (T &x)\n{\n    x=0; static int p; p=1; static char c; c=getchar();\n    while (!isdigit(c)) { if (c=='-') p=-1; c=getchar(); }\n    while ( isdigit(c)) { x=(x<<1)+(x<<3)+(c-48); c=getchar(); }\n    x*=p;\n}\ntemplate <typename T>\ninline void print (T x)\n{\n    if (x< 0) putchar('-'),x=-x;\n    if (x>=10) print(x/10);\n    putchar(x%10+'0');\n}\ntemplate <typename T>\ninline void pr (T x) { print(x),putchar('\\n'); }\ntemplate <typename T1,typename T2>\nvoid chkmax (T1 &A,T2 B) { A=A>=B?A:B; }\ntemplate <typename T1,typename T2>\nvoid chkmin (T1 &A,T2 B) { A=A<=B?A:B; }\nstruct EDGE { int v,w; LL c; int nx; }lb[N*N<<3]; int tot=1,top[N];\nvoid add (int u,int v,int w,LL c)\n{\n\tlb[++tot]=(EDGE){v,w, c,top[u]},top[u]=tot;\n\tlb[++tot]=(EDGE){u,0,-c,top[v]},top[v]=tot;\n}\nint s,t;\nLL dis[N]; int flow[N],pre[N],las[N]; bool in[N];\nbool spfa ()\n{\n\tfor (int i=1; i<=t; i++)\n\t\tdis[i]=-1e18,flow[i]=pre[i]=las[i]=0,in[i]=0;\n\tqueue <int> q;\n\tflow[s]=oo,dis[s]=0,q.push (s),in[s]=1;\n\twhile (q.size ())\n\t{\n\t\tint u=q.front (); q.pop (); in[u]=0;\n\t\tfor (int kb=top[u]; kb; kb=lb[kb].nx)\n\t\t{\n\t\t\tint v=lb[kb].v,w=lb[kb].w; LL c=lb[kb].c;\n\t\t\tif (w&&dis[v]< dis[u]+c)\n\t\t\t{\n\t\t\t\tdis[v]=dis[u]+c;\n\t\t\t\tflow[v]=min (flow[u],w);\n\t\t\t\tpre[v]=u,las[v]=kb;\n\t\t\t\tif (!in[v]) q.push (v),in[v]=1;\n\t\t\t}\n\t\t}\n\t}\n\treturn pre[t];\n}\nint maflow; LL macost;\nvoid mcmf ()\n{\n\twhile (spfa ())\n\t{\n\t\tint u=t,fl=flow[t]; maflow+=fl,macost+=dis[t]*fl;\n\t\twhile (u!=s)\n\t\t{\n\t\t\tlb[las[u]].w-=fl,lb[las[u]^1].w+=fl;\n\t\t\tu=pre[u];\n\t\t}\n\t}\n}\nint n,m;\nstruct LY { int x,y; LL w; }p[N];\nint op[N],a[N],b[N],L[N],R[N];\nLL solve (int k)\n{\n\ts=(n+k)*2+1,t=s+1;\n\tmemset (top,0,sizeof (int)*(t+1)),tot=1;\n\tfor (int i=1; i<=n; i++)\n\t\tadd (i,i+n,1,p[i].w);\n\tfor (int i=1; i<=k; i++)\n\t\tadd (s,n*2+i,1,0),add (n*2+k+i,t,1,0);\n\tmemset (L,0,sizeof (int)*(k+2)),memset (R,127,sizeof (int)*(k+2));\n\tfor (int i=1; i<=m; i++) if (b[i]<=k)\n\t{\n\t\tif (op[i]==1) chkmax (L[b[i]+1],a[i]+1);\n\t\telse if (op[i]==2) chkmin (R[k-b[i]],a[i]-1);\n\t}\n\tfor (int i=2; i<=k; i++)\n\t\tchkmax (L[i],L[i-1]);\n\tfor (int i=k-1; i>=1; i--)\n\t\tchkmin (R[i],R[i+1]);\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=1; j<=k; j++) if (L[j]<=p[i].x&&p[i].x<=R[j])\n\t\t\tadd (n*2+j,i,1,0);\n\tmemset (L,0,sizeof (int)*(k+2)),memset (R,127,sizeof (int)*(k+2));\n\tfor (int i=1; i<=m; i++) if (b[i]<=k)\n\t{\n\t\tif (op[i]==3) chkmax (L[b[i]+1],a[i]+1);\n\t\telse if (op[i]==4) chkmin (R[k-b[i]],a[i]-1);\n\t}\n\tfor (int i=2; i<=k; i++)\n\t\tchkmax (L[i],L[i-1]);\n\tfor (int i=k-1; i>=1; i--)\n\t\tchkmin (R[i],R[i+1]);\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=1; j<=k; j++) if (L[j]<=p[i].y&&p[i].y<=R[j])\n\t\t\tadd (n+i,n*2+k+j,1,0);\n\tmaflow=macost=0;\n\tmcmf ();\n\treturn maflow< k?-1:macost;\n}\nint main ()\n{\n    // freopen (\".in\",\"r\",stdin);\n    // freopen (\".out\",\"w\",stdout);\n\tsc(n);\n\tfor (int i=1; i<=n; i++)\n\t\tsc(p[i].x),sc(p[i].y),sc(p[i].w);\n\tsc(m);\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\tchar s[2]; scanf (\"%s\",s);\n\t\tsc(a[i]),sc(b[i]);\n\t\tif (s[0]=='L') op[i]=1;\n\t\telse if (s[0]=='R') op[i]=2;\n\t\telse if (s[0]=='D') op[i]=3;\n\t\telse op[i]=4;\n\t}\n\tLL ans=0;\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tLL g=solve (i);\n\t\tif (g==-1) break;\n\t\tchkmax (ans,g);\n\t}\n\tpr(ans);\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <assert.h>\n\nusing namespace std;\n\nstruct Jewel\n{\n  int x, y;\n  long long v;\n  int cnt = 0;\n\n  bool operator<(const Jewel &other) const\n  {\n    return (other.v == v ? cnt < other.cnt : other.v < v);\n  }\n};\n\nstruct Request\n{\n  string t;\n  int a, b;\n  int cnt = 0;\n};\n\nint main()\n{\n  int N;\n  cin >> N;\n  vector<Jewel> jewel(N);\n  for (int i = 0; i < N; i++)\n  {\n    int x, y;\n    long long v;\n    cin >> x >> y >> v;\n    jewel[i] = {x, y, v};\n  }\n  int M;\n  cin >> M;\n  vector<Request> request(M);\n  for (int i = 0; i < M; i++)\n  {\n    string t;\n    int a, b;\n    cin >> t >> a >> b;\n    request[i] = {t, a, b};\n  }\n  chrono::system_clock::time_point start = chrono::system_clock::now();\n  long long ans = 0;\n  while (chrono::duration_cast<chrono::microseconds>(chrono::system_clock::now() - start).count() / 1000 < 4998)\n  {\n    long long tmp = 0;\n    for (Request &j : request)\n      j.cnt = 0;\n    for (Jewel i : jewel)\n    {\n      bool ok = true;\n      for (Request j : request)\n        switch (j.t[0])\n        {\n        case 'L':\n          if (i.x <= j.a && j.b < j.cnt + 1)\n            ok = false;\n          break;\n        case 'R':\n          if (j.a <= i.x && j.b < j.cnt + 1)\n            ok = false;\n          break;\n        case 'D':\n          if (i.y <= j.a && j.b < j.cnt + 1)\n            ok = false;\n          break;\n        case 'U':\n          if (j.a <= i.y && j.b < j.cnt + 1)\n            ok = false;\n          break;\n        }\n      if (!ok)\n        continue;\n      tmp += i.v;\n      for (Request &j : request)\n        switch (j.t[0])\n        {\n        case 'L':\n          if (i.x <= j.a)\n            j.cnt++;\n          break;\n        case 'R':\n          if (j.a <= i.x)\n            j.cnt++;\n          break;\n        case 'D':\n          if (i.y <= j.a)\n            j.cnt++;\n          break;\n        case 'U':\n          if (j.a <= i.y)\n            j.cnt++;\n          break;\n        }\n    }\n    swap(jewel[rand() % N], jewel[rand() % N]);\n    if (ans < tmp)\n      ans = tmp;\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace __gnu_pbds;\nusing namespace std;\n \ntemplate <typename T>\nusing ordered_set =\n\ttree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n \n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n\t*this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n \n#define shandom_ruffle random_shuffle\n \nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=327;\nusing bn=bitset<87>;\nusing ld=long double;\n\nint n;\npii gdz[nax];\nll war[nax];\n\nint m;\nbn podz[nax];\nint ile[nax];\n\nll wyn;\n\nbn ter;\n \nll dajwar()\n{\n\tll ret=0;\n\tfor (int i=1; i<=n; i++)\n\t\tif (ter[i])\n\t\t\tret+=war[i];\n\treturn ret;\n}\n \nint popr()\n{\n\tfor (int i=1; i<=m; i++)\n\t\tif ((podz[i]&ter).count()>ile[i])\n\t\t\treturn 0;\n\treturn 1;\n}\n\nstruct Simplex {        // Maximize c*x subject to Ax <= b.\n  using T = ld;     // Initialize the structure, set A, b, c and then run\n  vector<vector<T>> A;  // solve(). Max objective is stored in res. To recover\n  vector<T> b, c;       // the best result, use getVars().\n  int V, E;\n  vector<int> eqIds, varIds, cols;\n  T res;\n  static constexpr T kEps = 1e-5;\n\n  Simplex(int vars, int eqs) : A(eqs, vector<T>(vars)), b(eqs), c(vars),\n      V(vars), E(eqs), eqIds(eqs), varIds(vars), res(0) {\n    iota(varIds.begin(), varIds.end(), 0);\n    iota(eqIds.begin(), eqIds.end(), vars);\n  }\n\n  void pivot(int eq, int var) {\n    T coef = 1 / A[eq][var];\n    cols.clear();\n    for (int i = 0; i < V; i++) {\n      if (abs(A[eq][i]) > kEps) { cols.push_back(i); A[eq][i] *= coef; }\n    }\n    A[eq][var] *= coef; b[eq] *= coef;\n    for (int row = 0; row < E; row++) {\n      if (row == eq || abs(A[row][var]) < kEps) { continue; }\n      T k = -A[row][var];\n      A[row][var] = 0;\n      for (int i : cols) { A[row][i] += k * A[eq][i]; }\n      b[row] += k * b[eq];\n    }\n    T q = c[var]; c[var] = 0;\n    for (int i : cols) { c[i] -= q * A[eq][i]; }\n    res += q * b[eq];\n    swap(varIds[var], eqIds[eq]);\n  }\n\n  bool solve() {\n    while (true) {\n      int eq = -1, var = -1;\n      for (int i = 0; i < E; i++) { if (b[i] < -kEps) { eq = i; break; } }\n      if (eq == -1) { break; }\n      for (int i = 0; i < V; i++) { if (A[eq][i] < -kEps) { var = i; break; } }\n      if (var == -1) { res = -1e9; return false; /* No solution */ }\n      pivot(eq, var);\n    }\n    while (true) {\n      int var = -1, eq = -1;\n      for (int i = 0; i < V; i++) { if (c[i] > kEps) { var = i; break; } }\n      if (var == -1) { break; }\n      for (int i = 0; i < E; i++) {\n        if (A[i][var] < kEps) { continue; }\n        if (eq >= 0 && b[i] / A[i][var] >= b[eq] / A[eq][var]) { continue; }\n        eq = i;\n      }\n      if (eq == -1) { res = 1e9; return false; /* Unbounded */ }\n      pivot(eq, var);\n    }\n    return true;\n  }\n\n  vector<T> getVars() { // Optimal assignment of variables.\n    vector<T> result(V);\n    for (int i = 0; i < E; i++) if (eqIds[i] < V) result[eqIds[i]] = b[i];\n    return result;\n  }\n};\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(\"%d%d%lld\", &gdz[i].first, &gdz[i].second, &war[i]);\n\tscanf(\"%d\", &m);\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\tchar c;\n\t\tint a, b;\n\t\tscanf(\" %c%d%d\", &c, &a, &b);\n\t\tfor (int j=1; j<=n; j++)\n\t\t{\n\t\t\tif (c=='L' && gdz[j].first<=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='R' && gdz[j].first>=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='D' && gdz[j].second<=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='U' && gdz[j].second>=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t}\n\t\tile[i]=b;\n\t}\n\tSimplex janusz(n, m+2*n);\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tjanusz.c[i]=war[i+1];\n\t}\n\tfor (int i=0; i<m; i++)\n\t{\n\t\tjanusz.b[i]=ile[i+1];\n\t\tfor (int j=0; j<n; j++)\n\t\t\tjanusz.A[i][j]=podz[i+1][j+1];\n\t}\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tjanusz.b[m+i]=1;\n\t\tjanusz.A[m+i][i]=1;\n\t}\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tjanusz.b[m+n+i]=0;\n\t\tjanusz.A[m+n+i][i]=-1;\n\t}\n\tassert(janusz.solve());\n\tauto wez=janusz.getVars();\n\t\n\tfor (int i=0; i<n; i++)\n\t\tter[i+1]=(wez[i]>0.5);\n\t\n\twhile(!popr())\n\t\tter[rand()%n+1]=0;\n\t\n\tll sta=dajwar();\n\tconst int czes=5e5;\n\tconst int res=7e4;\n\tfor (int h=0; h%czes || (clock()<=4.5*CLOCKS_PER_SEC); h++)\n\t{\n\t\tif (!(rand()%res))\n\t\t{\n\t\t\tter.reset();\n\t\t\tvi kol(n);\n\t\t\tiota(kol.begin(), kol.end(), 1);\n\t\t\tshandom_ruffle(kol.begin(), kol.end());\n\t\t\tfor (int i : kol)\n\t\t\t{\n\t\t\t\tter[i]=1;\n\t\t\t\tif (!popr())\n\t\t\t\t\tter[i]=0;\n\t\t\t}\n\t\t\tsta=dajwar();\n\t\t\twyn=max(wyn, sta);\n\t\t}\n\t\tbn pam=ter;\n\t\tint r=rand()%2+1;\n\t\tfor (int i=0; i<r; i++)\n\t\t\tter.flip(rand()%n+1);\n\t\tif (!popr())\n\t\t{\n\t\t\tter=pam;\n\t\t\tcontinue;\n\t\t}\n\t\tll now=dajwar();\n\t\tif (now>=sta || !(rand()%5000))\n\t\t{\n\t\t\tsta=now;\n\t\t\twyn=max(wyn, now);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tter=pam;\n\t\t}\n\t}\n\t\n\tdebug() << janusz.getVars();\n\tprintf(\"%lld\\n\", wyn);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define MN 100\n#define S 0\n#define T 201\n#define SS 202\n#define TT 203\n#define INF 2000000000\ninline ll read()\n{\n    ll x=0,f=1;char c=getchar();\n    while(c<'0'||c>'9'){if(c=='-') f=-1;c=getchar();}\n    while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}\n    return x*f;\n}\nchar ch[5];\nint n,m,d[MN+5],u[MN+5],l[MN+5],r[MN+5],rk[MN+5],xx[MN+5],yy[MN+5];\nll v[MN+5],ans=0,now,pi,dis[TT+5];\n\nbool inq[TT+5],mark[TT+5];\nint cnt,head[TT+5],q[TT+5],top,tail,in[TT+5];\nstruct edge{int to,next,w;ll c;}e[T*T];\ninline void ins(int f,int t,int w,ll v)\n{\n    e[++cnt]=(edge){t,head[f],w, v};head[f]=cnt;\n    e[++cnt]=(edge){f,head[t],0,-v};head[t]=cnt;\n}\ninline void Ins(int f,int t,int L,int R,ll v){if(L>R)--now;in[t]+=L;in[f]-=L;if(R>L)ins(f,t,R-L,v);}\ninline int nxt(int x){return ++x>TT?0:x;}\ninline int lst(int x){return --x<0?TT:x;}\nbool Label(int from,int to)\n{\n    memset(dis,63,sizeof(dis));dis[to]=0;\n    q[top=1]=to;tail=0;inq[to]=1;\n    while(top!=tail)\n    {\n        int x=q[tail=nxt(tail)];\n        for(int i=head[x];i;i=e[i].next)\n            if(e[i^1].w&&dis[x]+e[i^1].c<dis[e[i].to])\n            {\n                dis[e[i].to]=dis[x]+e[i^1].c;\n                if(!inq[e[i].to])\n                {\n                    inq[e[i].to]=1;\n                    if(dis[e[i].to]<dis[nxt(tail)]) q[tail]=e[i].to,tail=lst(tail);\n                    else q[top=nxt(top)]=e[i].to;\n                }\n            }\n        inq[x]=0;\n    }\n    if(dis[from]>1e17) return false;\n    for(int i=1;i<=TT;++i) for(int j=head[i];j;j=e[j].next)\n        e[j].c+=dis[e[j].to]-dis[i];\n    pi+=dis[from];return true;\n}\n\nint dfs(int x,int to,int f)\n{\n    if(x==to) return now+=pi*f,f;mark[x]=1;\n    int used=0;\n    for(int i=head[x];i;i=e[i].next)\n        if(!mark[e[i].to]&&!e[i].c&&e[i].w)\n        {\n            int w=dfs(e[i].to,to,min(f-used,e[i].w));\n            e[i].w-=w;e[i^1].w+=w;\n            used+=w;if(used==f) return f;\n        }\n    return used;\n}\n\nint main()\n{\n    n=read();\n    for(int i=1;i<=MN;++i) d[i]=u[i]=l[i]=r[i]=n;\n    for(int i=1;i<=n;++i)  \n        xx[i]=read(),yy[i]=read(),v[i]=read();\n    m=read();\n    for(int i=1,j,k;i<=m;++i)\n    {\n        scanf(\"%s%d%d\",ch+1,&j,&k);\n        if(ch[1]=='L') l[j]=k; if(ch[1]=='R') r[j]=k;\n        if(ch[1]=='U') u[j]=k; if(ch[1]=='D') d[j]=k;\n    }\n    for(int i=2;i<=MN;++i) r[i]=min(r[i],r[i-1]),u[i]=min(u[i],u[i-1]);\n    for(int i=MN;--i>=1;)  l[i]=min(l[i],l[i+1]),d[i]=min(d[i],d[i+1]);\n    for(int t=1;t<=min(min(l[MN],d[MN]),min(u[1],r[1]));++t)\n    {\n        cnt=1;memset(head,0,sizeof(head));now=pi=0;\n        memset(in,0,sizeof(in));\n        for(int i=1;i<=MN;++i) \n        {\n            Ins(i==MN?S:i+1,i,max(0,t-r[i+1]),min(t,l[i]),0);\n            Ins(MN+i,i==MN?T:MN+i+1,max(0,t-u[i+1]),min(t,d[i]),0);\n        }\n        if(now!=0) continue;\n        for(int i=1;i<=n;++i) Ins(xx[i],yy[i]+MN,0,1,-v[i]+1e15);\n        int flow=0,must=0;\n        for(int i=S;i<=T;++i) \n        {\n            if(in[i]>0) ins(SS,i, in[i],0),must+=in[i];\n            if(in[i]<0) ins(i,TT,-in[i],0);\n        }\n        ins(T,S,INF,0);\n        while(Label(SS,TT)) \n            memset(mark,0,sizeof(mark)),flow+=dfs(SS,TT,INF);\n        e[cnt].w=e[cnt-1].w=0;\n        while(Label(S,T))\n            memset(mark,0,sizeof(mark)),flow+=dfs(S,T,INF);\n        if(flow==must) ans=max(ans,-now+t*(ll)(1e15));\n    }\n    cout<<ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n#define MP make_pair\n#define PB push_back\n#define int long long\n#define st first\n#define nd second\n#define rd third\n#define FOR(i, a, b) for(int i =(a); i <=(b); ++i)\n#define RE(i, n) FOR(i, 1, n)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define REP(i, n) for(int i = 0;i <(n); ++i)\n#define VAR(v, i) __typeof(i) v=(i)\n#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define __builtin_ctz __builtin_ctzll\n#define __builtin_clz __builtin_clzll\n#define __builtin_popcount __builtin_popcountll\nusing namespace std;\ntemplate<typename TH> void _dbg(const char* sdbg, TH h) { cerr<<sdbg<<\"=\"<<h<<\"\\n\"; }\ntemplate<typename TH, typename... TA> void _dbg(const char* sdbg, TH h, TA... t) {\n  while(*sdbg != ',') { cerr<<*sdbg++; } cerr<<\"=\"<<h<<\",\"; _dbg(sdbg+1, t...);\n}\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#define debugv(x) {{cerr <<#x <<\" = \"; FORE(itt, (x)) cerr <<*itt <<\", \"; cerr <<\"\\n\"; }}\n#else\n#define debug(...) (__VA_ARGS__)\n#define debugv(x)\n#define cerr if(0)cout\n#endif\n#define next ____next\n#define prev ____prev\n#define left ____left\n#define hash ____hash\ntypedef long long ll;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\ntypedef vector<pair<int, int> > VPII;\ntypedef vector<pair<ll, ll> > VPLL;\n\ntemplate<class C> void mini(C&a4, C b4){a4=min(a4, b4); }\ntemplate<class C> void maxi(C&a4, C b4){a4=max(a4, b4); }\ntemplate<class T1, class T2>\nostream& operator<< (ostream &out, pair<T1, T2> pair) { return out << \"(\" << pair.first << \", \" << pair.second << \")\";}\ntemplate<class A, class B, class C> struct Triple { A first; B second; C third;\n  bool operator<(const Triple& t) const { if (st != t.st) return st < t.st; if (nd != t.nd) return nd < t.nd; return rd < t.rd; } };\ntemplate<class T> void ResizeVec(T&, vector<int>) {}\ntemplate<class T> void ResizeVec(vector<T>& vec, vector<int> sz) {\n  vec.resize(sz[0]); sz.erase(sz.begin()); if (sz.empty()) { return; }\n  for (T& v : vec) { ResizeVec(v, sz); }\n}\ntypedef Triple<int, int, int> TIII;\ntemplate<class A, class B, class C>\nostream& operator<< (ostream &out, Triple<A, B, C> t) { return out << \"(\" << t.st << \", \" << t.nd << \", \" << t.rd << \")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, vector<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, set<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class L, class R> ostream& operator<<(ostream& out, map<L, R> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\n\nstruct Simplex {        // Maximize c*x subject to Ax <= b.\n  using T = LD;     // Initialize the structure, set A, b, c and then run\n  vector<vector<T>> A;  // solve(). Max objective is stored in res. To recover\n  vector<T> b, c;       // the best result, use getVars().\n  \n  int V, E;\n  VI eqIds, varIds, cols;\n  T res;\n  const T kEps = 1e-9;\n  \n  Simplex(int vars, int eqs) : A(eqs, vector<T>(vars)), b(eqs), c(vars),\n  V(vars), E(eqs), eqIds(eqs), varIds(vars), res(0) {\n    iota(ALL(varIds), 0); iota(ALL(eqIds), vars);\n  }\n  \n  void pivot(int eq, int var) {\n    T coef = 1 / A[eq][var];\n    cols.clear();\n    REP (i, V) {\n      if (abs(A[eq][i]) > kEps) { cols.PB(i); A[eq][i] *= coef; }\n    }\n    A[eq][var] *= coef; b[eq] *= coef;\n    REP (row, E) {\n      if (row == eq || abs(A[row][var]) < kEps) { continue; }\n      T k = -A[row][var];\n      A[row][var] = 0;\n      for (int i : cols) { A[row][i] += k * A[eq][i]; }\n      b[row] += k * b[eq];\n    }\n    T q = c[var]; c[var] = 0;\n    for (int i : cols) { c[i] -= q * A[eq][i]; }\n    res += q * b[eq];\n    \n    swap(varIds[var], eqIds[eq]);\n  }\n  \n  bool solve() {\n    while (true) {\n      int eq = -1, var = -1;\n      REP (i, E) { if (b[i] < -kEps) { eq = i; break; } }\n      if (eq == -1) { break; }\n      REP (i, V) { if (A[eq][i] < -kEps) { var = i; break; } }\n      if (var == -1) { res = -1e9; return false; /* No solution */ }\n      pivot(eq, var);\n    }\n    \n    while (true) {\n      int var = -1, eq = -1;\n      REP (i, V) { if (c[i] > kEps) { var = i; break; } }\n      if (var == -1) { break; }\n      REP (i, E) {\n        if (A[i][var] < kEps) { continue; }\n        if (eq >= 0 && b[i] / A[i][var] >= b[eq] / A[eq][var]) { continue; }\n        eq = i;\n      }\n      if (eq == -1) { res = 1e9; return false; /* Unbounded */ }\n      pivot(eq, var);\n    }\n    \n    return true;\n  }\n  \n  vector<T> getVars() {  // Optimal assignment of variables.\n    vector<T> result(V);\n    REP (i, E) { if (eqIds[i] < V) { result[eqIds[i]] = b[i]; } }\n    return result;\n  }\n};\n\n\nconst int N = 333;\nint x[N];\nint y[N];\nint v[N];\n\nint32_t main() {\n\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(10);\n  cerr << fixed << setprecision(10);\n  cin.tie(0);\n  //double beg_clock = 1.0 * clock() / CLOCKS_PER_SEC;\n  \n  int n;\n  cin>>n;\n  REP (i, n) {\n    cin>>x[i]>>y[i]>>v[i];\n    //sim.c.PB(v[i]);\n  }\n  int m;\n  cin>>m;\n  \n  Simplex sim(n, m + 2 * n);\n  REP (i, n) {\n    sim.c[i] = v[i];\n  }\n  REP (j, m) {\n    char t;\n    cin>>t;\n    int a, b;\n    cin>>a>>b;\n    sim.b[j]= b;\n    vector<LD> A;\n    REP (i, n) {\n      if ((t == 'L' && x[i] <= a) || (t == 'R' && x[i] >= a) || (t == 'U' && y[i] >= a) || (t == 'D' && y[i] <= a)) {\n        A.PB(1);\n      } else {\n        A.PB(0);\n      }\n    }\n    sim.A[j] = A;\n  }\n  REP (i, n) {\n    sim.b[m + 2 * i] = 1;\n    sim.b[m + 2 * i + 1] = 0;\n    sim.A[m + 2 * i][i] = 1;\n    sim.A[m + 2 * i + 1][i] = -1;\n  }\n  sim.solve();\n  debug(sim.res);\n  vector<LD> vars = sim.getVars();\n  debug(vars);\n  int R = 0;\n  REP (i, n) {\n    assert(vars[i] < 0.001 || vars[i] > 0.999);\n    if (vars[i] > 0.5) {\n      R += v[i];\n    }\n  }\n  cout<<R<<endl;\n    \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mset(a, b) memset(a, b, sizeof(a))\n#define mcpy(a, b) memcpy(a, b, sizeof(a))\nusing namespace std;\ntypedef long long LL;\nconst int N = 405;\nconst int M = 100005;\nconst LL INF = 0x3f3f3f3f3f3f3f3f;\n\ntemplate <typename T> inline void read(T &AKNOI) {\n\tT x = 0, flag = 1;\n\tchar ch = getchar();\n\twhile (!isdigit(ch)) {\n\t\tif (ch == '-') flag = -1;\n\t\tch = getchar();\n\t}\n\twhile (isdigit(ch)) {\n\t\tx = x * 10 + ch - '0';\n\t\tch = getchar();\n\t}\n\tAKNOI = flag * x;\n}\n\ntemplate <typename T> inline void cmin(T &x, T y) {\n\tif (x > y) x = y;\n}\n\ntemplate <typename T> inline void cmax(T &x, T y) {\n\tif (x < y) x = y;\n}\n\nint tot, S, T, inq[N], pre[N];\nLL dis[N];\nqueue<int> q;\n\nstruct Edge {\n\tint v, w, nxt;\n\tLL c;\n} e[M << 1];\nint first[N], eCnt;\n\ninline void AddEdge(int u, int v, int w, LL c) {\n\te[++eCnt].v = v;\n\te[eCnt].w = w;\n\te[eCnt].c = c;\n\te[eCnt].nxt = first[u];\n\tfirst[u] = eCnt;\n}\n\ninline void Add(int u, int v, int w, LL c) {\n\tAddEdge(u, v, w, c);\n\tAddEdge(v, u, 0, -c);\n}\n\nbool SPFA() {\n\tfor (int i = 1; i <= tot; ++i) {\n\t\tdis[i] = -INF;\n\t}\n\tdis[S] = 0;\n\tq.push(S);\n\twhile (!q.empty()) {\n\t\tint u = q.front();\n\t\tq.pop(); inq[u] = 0;\n\t\tfor (int i = first[u]; i; i = e[i].nxt) {\n\t\t\tint v = e[i].v;\n\t\t\tif (e[i].w && dis[v] < dis[u] + e[i].c) {\n\t\t\t\tdis[v] = dis[u] + e[i].c;\n\t\t\t\tpre[v] = i;\n\t\t\t\tif (!inq[v]) {\n\t\t\t\t\tq.push(v);\n\t\t\t\t\tinq[v] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn (dis[T] > -INF);\n}\n\nLL Update() {\n\tint flow = 100;\n\tfor (int i = pre[T]; i; i = pre[e[i ^ 1].v]) {\n\t\tcmin(flow, e[i].w);\n\t}\n\tfor (int i = pre[T]; i; i = pre[e[i ^ 1].v]) {\n\t\te[i].w -= flow;\n\t\te[i ^ 1].w += flow;\n\t}\n\treturn dis[T] * flow;\n}\n\nLL Costflow() {\n\tLL mxcost = 0;\n\twhile (SPFA()) {\n\t\tmxcost += Update();\n\t}\n\treturn mxcost;\n}\n\nchar qt[N];\nint n, m, X[N], Y[N], qa[N], qb[N];\nLL V[N];\nint lx[N], rx[N], ly[N], ry[N];\n\nLL Work(int x) {\n\tmset(first, 0);\n\teCnt = 1;\n\tS = 201, T = tot = 202;\n\tfor (int i = 1; i <= x; ++i) {\n\t\tlx[i] = ly[i] = 1;\n\t\trx[i] = ry[i] = 100;\n\t}\n\t\n\tfor (int i = 1; i <= m; ++i) {\n\t\tif (qb[i] > x) continue;\n\t\tif (qt[i] == 'L') {\n\t\t\tcmax(lx[qb[i] + 1], qa[i] + 1);\n\t\t} else if (qt[i] == 'R') {\n\t\t\tcmin(rx[x - qb[i]], qa[i] - 1);\n\t\t} else if (qt[i] == 'D') {\n\t\t\tcmax(ly[qb[i] + 1], qa[i] + 1);\n\t\t} else if (qt[i] == 'U') {\n\t\t\tcmin(ry[x - qb[i]], qa[i] - 1);\n\t\t}\n\t}\n\tfor (int i = 2; i <= x; ++i) {\n\t\tcmax(lx[i], lx[i - 1]);\n\t\tcmax(ly[i], ly[i - 1]);\n\t}\n\tfor (int i = x - 1; i >= 1; --i) {\n\t\tcmin(rx[i], rx[i + 1]);\n\t\tcmin(ry[i], ry[i + 1]);\n\t}\n\t\n\tfor (int i = 1; i <= n; ++i) {\n\t\tAdd(X[i], 100 + Y[i], 1, V[i]);\n\t}\n\tfor (int i = 1; i <= x; ++i) {\n\t\tif (lx[i] > rx[i] || ly[i] > ry[i]) return -INF;\n\t\tAdd(S, ++tot, 1, 0);\n\t\tfor (int j = lx[i]; j <= rx[i]; ++j) {\n\t\t\tAdd(tot, j, 1, 0);\n\t\t}\n\t\tAdd(++tot, T, 1, 0);\n\t\tfor (int j = ly[i]; j <= ry[i]; ++j) {\n\t\t\tAdd(100 + j, tot, 1, 0);\n\t\t}\n\t}\n\treturn Costflow();\n}\n\nvoid init() {\n\tread(n);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tread(X[i]); read(Y[i]); read(V[i]);\n\t}\n\tread(m);\n\tfor (int i = 1; i <= m; ++i) {\n\t\tqt[i] = getchar();\n\t\tread(qa[i]); read(qb[i]);\n\t}\n}\n\nvoid solve() {\n\tLL ans = -INF;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tcmax(ans, Work(i));\n\t}\n\tprintf(\"%lld\\n\", ans);\n}\n\nint main() {\n\tinit();\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace mcmf {\n\nconst long long inf = 1000111222000111222LL;\n\nstruct edge {\n    int to, flow, capacity;\n    long long cost;\n\n    edge() {\n    }\n\n    edge(int to, int flow, int capacity, long long cost): to(to), flow(flow), capacity(capacity), cost(cost) {\n    }\n\n};\n\nconst int max_v = 404;\n\nvector<edge> edges;\nvector<int> g[max_v];\n\nvoid clr() {\n    edges.clear();\n    for (int i = 0; i < max_v; ++i) {\n        g[i].clear();\n    }\n}\n\nvoid add_edge(int u, int v, int capacity, long long cost) {\n    g[u].push_back(edges.size());\n    edges.push_back(edge(v, 0, capacity, cost));\n    g[v].push_back(edges.size());\n    edges.push_back(edge(u, 0, 0, -cost));\n}\n\nint parent[max_v], p_id[max_v];\nlong long phi[max_v], dist[max_v];\n\nlong long dijkstra(int s, int t) {\n    for (int i = 0; i <= t; ++i) {\n        dist[i] = inf;\n    }\n    priority_queue<pair<long long, int>> q;\n    dist[s] = 0;\n    q.push({0, s});\n    while (!q.empty()) {\n        pair<long long, int> p = q.top();\n        q.pop();\n        long long d = -p.first, v = p.second;\n        if (d != dist[v]) {\n            continue;\n        }\n        for (int id : g[v]) {\n            if (edges[id].flow == edges[id].capacity) {\n                continue;\n            }\n            int to = edges[id].to;\n            // cout << v << \" \" << dist[v] << \" -> \" << to << \" \" << edges[id].cost << endl;\n            if (dist[v] + edges[id].cost + phi[v] - phi[to] < dist[to]) {\n                dist[to] = dist[v] + edges[id].cost + phi[v] - phi[to];\n                parent[to] = v;\n                p_id[to] = id;\n                q.push({-dist[to], to});\n            }\n        }\n    }\n    if (dist[t] == inf) {\n        return inf;\n    }\n    for (int i = 0; i <= t; ++i) {\n        phi[i] = min(inf, dist[i] + phi[i]);\n    }\n    int v = t;\n    while (v != s) {\n        ++edges[p_id[v]].flow;\n        --edges[p_id[v] ^ 1].flow;\n        v = parent[v];\n    }\n    return phi[t];\n}\n\nlong long min_cost_max_flow(int s, int t, int k) {\n    for (int i = 0; i <= t; ++i) {\n        phi[i] = 0;\n    }\n    long long res = 0;\n    int it = 0;\n    while (true) {\n        long long x = dijkstra(s, t);\n        if (x == inf) {\n            break;\n        }\n        ++it;\n        res += x;\n    }\n    if (it != k) {\n        return 0;\n    }\n    return res;\n}\n\n}\n\nconst int max_n = 105;\nconst int max_c = 333;\nconst long long inf = 1000111222000111LL;\n\nint lx[max_n], rx[max_n], ly[max_n], ry[max_n];\n\nstruct constraint {\n    char tp;\n    int x, cnt;\n\n    void read() {\n        scanf(\"\\n%c%d%d\", &tp, &x, &cnt);\n        --x;\n    }\n\n    void add(int k) {\n        if (tp == 'L') {\n            for (int i = cnt; i < k; ++i) {\n                lx[i] = max(lx[i], x + 1);\n            }\n        } else if (tp == 'D') {\n            for (int i = cnt; i < k; ++i) {\n                ly[i] = max(ly[i], x + 1);\n            }\n        } else if (tp == 'R') {\n            for (int i = 0; i < k - cnt; ++i) {\n                rx[i] = min(rx[i], x - 1);\n            }\n        } else {\n            for (int i = 0; i < k - cnt; ++i) {\n                ry[i] = min(ry[i], x - 1);\n            }\n        }\n    }\n};\n\nint n, m, x[max_n], y[max_n];\nlong long v[max_n];\nconstraint c[max_c];\n\nlong long solve(int k) {\n    for (int i = 0; i < k; ++i) {\n        lx[i] = ly[i] = 0;\n        rx[i] = ry[i] = 99;\n    }\n    for (int i = 0; i < m; ++i) {\n        c[i].add(k);\n    }\n    for (int i = 0; i < k; ++i) {\n        if (lx[i] > rx[i] || ly[i] > ry[i]) {\n            return 0;\n        }\n    }\n    if (0) {\n        cout << k << \": \" << endl;\n        for (int i = 0; i < k; ++i) {\n            cout << lx[i] << \" \" << rx[i] << \", \" << ly[i] << \" \" << ry[i] << endl;\n        }\n        cout << endl;\n    }\n    mcmf::clr();\n    const int max_x = 100;\n    int s = 2 * k + 2 * max_x;\n    int t = s + 1;\n    for (int i = 0; i < k; ++i) {\n        mcmf::add_edge(s, i, 1, 0);\n        for (int x = lx[i]; x <= rx[i]; ++x) {\n            mcmf::add_edge(i, k + x, 1, 0);\n        }\n        mcmf::add_edge(k + 2 * max_x + i, t, 1, 0);\n        for (int y = ly[i]; y <= ry[i]; ++y) {\n            mcmf::add_edge(k + max_x + y, k + 2 * max_x + i, 1, 0);\n        }\n    }\n    for (int i = 0; i < n; ++i) {\n        mcmf::add_edge(k + x[i], k + max_x + y[i], 1, -v[i] + inf);\n    }\n    long long res = -mcmf::min_cost_max_flow(s, t, k);\n    if (res == 0) {\n        return 0;\n    }\n    return res + k * inf;\n}\n\nint main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; ++i) {\n        scanf(\"%d%d%lld\", &x[i], &y[i], &v[i]);\n        --x[i];\n        --y[i];\n    }\n    scanf(\"%d\", &m);\n    for (int i = 0; i < m; ++i) {\n        c[i].read();\n    }\n    long long ans = 0;\n    for (int i = 1; i <= n; ++i) {\n        long long res = solve(i);\n        if (res == 0) {\n            break;\n        }\n        // cout << i << \": \" << solve(i) << endl;\n        ans = max(ans, solve(i));\n    }\n    printf(\"%lld\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<stack>\n#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\nnamespace MIN_COST_MAX_FLOW {\ntypedef LL Flow;\ntypedef LL Cost;\nconst Flow FLOW_INF = 1LL<<60;\nconst Cost COST_INF = 1LL<<60;\n\nconst int SIZE = 65;\nvector<pair<Cost, int> > B[SIZE];\nCost last;\nint sz;\n\nint bsr(Cost c) {\n    if (c == 0) return 0;\n    return __lg(c)+1;\n}\n\nvoid init() {\n    last = sz = 0;\n    REP (i, SIZE) B[i].clear();\n}\n\nvoid push(Cost cst, int v) {\n    assert(cst >= last);\n    sz++;\n    B[bsr(cst^last)].emplace_back(cst, v);\n}\n\npair<Cost, int> pop_min() {\n    assert(sz);\n    if (B[0].empty()) {\n\tint k = 1;\n\twhile (k < SIZE && B[k].empty()) k++;\n\tassert(k < SIZE);\n\tlast = B[k][0].first;\n\tEACH (e, B[k]) amin(last, e->first);\n\tEACH (e, B[k]) B[bsr(e->first^last)].push_back(*e);\n\tB[k].clear();\n    }\n    assert(B[0].size());\n    pair<Cost, int> ret = B[0].back();\n    B[0].pop_back();\n    sz--;\n    return ret;\n}\n\nstruct MinCostMaxFlow {\n    struct Edge {\n\tint dst;\n\tCost cst;\n\tFlow cap;\n\tint rev;\n    };\n    typedef vector<vector<Edge> > Graph;\n    Graph G;\n    MinCostMaxFlow(int N) : G(N) {}\n\n    void add_edge(int u, int v, Cost x, Flow f) {\n\tif (u == v) return;\n\tG[u].push_back((Edge){ v, x, f, (int)G[v].size() });\n\tG[v].push_back((Edge){ u, -x, 0, (int)G[u].size()-1 });\n    }\n\n    Flow flow;\n    Cost cost;\n    Flow solve(int s, int t, Flow limit = FLOW_INF) {\n\tflow = 0;\n\tcost = 0;\n\tvector<Cost>len(G.size()), h(G.size(), 0);\n\tvector<int> prev(G.size()), prev_num(G.size());\n\twhile (limit > 0) {\n\t    init(); push(0, s);\n\t    fill(len.begin(), len.end(), COST_INF);\n\t    fill(prev.begin(), prev.end(), -1);\n\t    len[s] = 0;\n\t    while (sz) {\n\t\tpair<Cost, int> p = pop_min();\n\t\tCost cst = p.first;\n\t\tint v = p.second;\n\t\tif (cst > len[v]) continue;\n\t\tfor (int i=0; i<(int)G[v].size(); i++) {\n\t\t    const Edge &f = G[v][i];\n\t\t    Cost tmp = len[v] + f.cst + h[v] - h[f.dst];\n\t\t    if (f.cap > 0 && len[f.dst] > tmp) {\n\t\t\tlen[f.dst] = tmp;\n\t\t\tpush(tmp, f.dst);\n\t\t\tprev[f.dst] = v; prev_num[f.dst] = i;\n\t\t    }\n\t\t}\n\t    }\n\t    if (prev[t] == -1) return flow;\n\t    for (int i=0; i<(int)G.size(); i++) h[i] += len[i];\n\t    \n\t    Flow f = limit;\n\t    for (int v=t; v!=s; v=prev[v])\n\t\tf = min(f, G[prev[v]][prev_num[v]].cap);\n\t    for (int v=t; v!=s; v=prev[v]) {\n\t\tEdge &e = G[prev[v]][prev_num[v]];\n\t\te.cap -= f;\n\t\tG[e.dst][e.rev].cap += f;\n\t    }\n\t    limit -= f;\n\t    flow += f;\n\t    cost += f * h[t];\n\t}\n\treturn flow;\n    }\n};\n}; // namespace\n\nint N;\nint X[88], Y[88];\nLL V[88];\nint M;\nchar T[333];\nint A[333], B[333];\n\nint Llo[88], Lhi[88], Dlo[88], Dhi[88];\nconst LL BASE = 1LL<<50;\nLL calc(int K) {\n    memset(Lhi, 0x3f, sizeof Lhi);\n    memset(Llo, 0xc0, sizeof Llo);\n    memset(Dhi, 0x3f, sizeof Dhi);\n    memset(Dlo, 0xc0, sizeof Dlo);\n    REP (j, M) {\n\tint a = A[j], b = B[j];\n\tif (b < K) {\n\t    if (T[j] == 'L') amax(Llo[b], a);\n\t    if (T[j] == 'R') amin(Lhi[K-b-1], a);\n\t    if (T[j] == 'D') amax(Dlo[b], a);\n\t    if (T[j] == 'U') amin(Dhi[K-b-1], a);\n\t}\n    }\n    REP (i, K-1) {\n\tamax(Llo[i+1], Llo[i]);\n\tamax(Dlo[i+1], Dlo[i]);\n    }\n    for (int i=K-2; i>=0; i--) {\n\tamin(Lhi[i], Lhi[i+1]);\n\tamin(Dhi[i], Dhi[i+1]);\n    }\n//    rprintf(\"%d\", Llo, Llo+K);\n//    rprintf(\"%d\", Lhi, Lhi+K);\n//    rprintf(\"%d\", Dlo, Dlo+K);\n//    rprintf(\"%d\", Dhi, Dhi+K);\n//\n    const int SRC = K*2+N*2, SNK = SRC+1;\n    MIN_COST_MAX_FLOW::MinCostMaxFlow G(SNK+1);\n    REP (i, N) {\n\tint left = i+K*2, right = left + N;\n\tG.add_edge(left, right, BASE - V[i], 1);\n\tREP (a, K) {\n\t    if (Llo[a] < X[i] && X[i] < Lhi[a]) {\n\t\tG.add_edge(a, left, 0, 1);\n\t    }\n\t    if (Dlo[a] < Y[i] && Y[i] < Dhi[a]) {\n\t\tG.add_edge(right, a+K, 0, 1);\n\t    }\n\t}\n    }\n    REP (a, K) {\n\tG.add_edge(SRC, a, 0, 1);\n\tG.add_edge(a+K, SNK, 0, 1);\n    }\n    G.solve(SRC, SNK);\n    if (G.flow == K) {\n\treturn K * BASE - G.cost;\n    } else {\n\treturn -1;\n    }\n\n}\n\nvoid MAIN() {\n    scanf(\"%d\", &N);\n    REP (i, N) scanf(\"%d%d%lld\", X+i, Y+i, V+i);\n    scanf(\"%d\", &M);\n    REP (i, M) scanf(\"%s%d%d\", T+i, A+i, B+i);\n\n    \n    LL ans = 0;\n    for (int k=1; k<=N; k++) {\n\tLL tmp = calc(k);\n\tif (tmp == -1) break;\n\tamax(ans, tmp);\n    }\n    \n    printf(\"%lld\\n\", ans);\n\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// includes {{{\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<tuple>\n#include<cmath>\n#include<random>\n#include<cassert>\n#include<bitset>\n#include<cstdlib>\n// #include<deque>\n// #include<multiset>\n// #include<cstring>\n// #include<bits/stdc++.h>\n// }}}\nusing namespace std;\nusing ll = long long;\n\n// MinCostFlow(size, inf)\n// MinCostFlow(size, inf, int& s, int& t)\n// addEdge(from, to, capacity, cost, undirected = false)\n// === build(s, t, flow) ===\n// O(FE log V)\n// return mincost\n// return -1 if impossible\n/// --- MinCostFlow {{{ ///\n#include <cassert>\n#include <queue>\n#include <tuple>\n#include <vector>\n// with Dijkstra with Potential\nstruct MinCostFlow {\n  struct Edge {\n    int to;\n    ll cap, cost;\n    size_t rev;\n  };\n  int n;\n  vector< vector< Edge > > graph;\n  vector< ll > h; // potential\n  vector< ll > dist;\n  vector< int > prevv, preve;\n  ll inf;\n  MinCostFlow(int n, ll inf)\n    : n(n), graph(n), h(n), dist(n), prevv(n), preve(n), inf(inf) {}\n  MinCostFlow(int n, ll inf, int &s, int &t) : MinCostFlow(n + 2, inf) {\n    s = n, t = n + 1;\n  }\n  void addEdge(int a, int b, ll cap, ll cost, int undirected = 0) {\n    assert(cost >= 0);\n    assert(0 <= a && a < n);\n    assert(0 <= b && b < n);\n    graph[a].emplace_back((Edge){b, cap, cost, graph[b].size()});\n    graph[b].emplace_back((Edge){a, undirected ? cap : 0, -cost, graph[a].size() - 1});\n  }\n  ll build(int s, int t, ll f) {\n    h.assign(n, 0);\n    ll res = 0;\n    while(f > 0) {\n      dist.assign(n, inf);\n      dist[s] = 0;\n      // Dijkstra with potential\n      using P = pair< ll, int >;\n      priority_queue< P, vector< P >, greater< P > > pq;\n      pq.emplace(0, s);\n      while(pq.size()) {\n        ll d;\n        int v;\n        tie(d, v) = pq.top();\n        pq.pop();\n        if(dist[v] < d) continue;\n        for(size_t i = 0; i < graph[v].size(); i++) {\n          Edge &edge = graph[v][i];\n          ll nd = dist[v] + edge.cost + h[v] - h[edge.to];\n          if(edge.cap > 0 && dist[edge.to] > nd) {\n            dist[edge.to] = nd;\n            pq.emplace(nd, edge.to);\n            prevv[edge.to] = v;\n            preve[edge.to] = i;\n          }\n        }\n      }\n      //\n      if(dist[t] == inf) return -1;\n      for(int v = 0; v < n; v++) h[v] += dist[v];\n\n      ll d = f;\n      for(int v = t; v != s; v = prevv[v]) {\n        d = min(d, graph[prevv[v]][preve[v]].cap);\n      }\n      f -= d;\n      res += d * h[t];\n      for(int v = t; v != s; v = prevv[v]) {\n        Edge &edge = graph[prevv[v]][preve[v]];\n        edge.cap -= d;\n        graph[v][edge.rev].cap += d;\n      }\n    }\n    return res;\n  }\n};\n/// }}}--- ///\n\nll inf = 1e18;\n\nconstexpr int N = 80, M = 320;\n\nint n, m;\nint x[N], y[N];\nll v[N];\nchar type[M];\nint a[M], b[M];\n\nint XL[N], XR[N];\nint YL[N], YR[N];\n\n// smin, smax {{{\ntemplate < class T, class U >\ninline void smin(T &a, const U &b) {\n  a = a < (T) b ? a : b;\n}\ntemplate < class T, class U >\ninline void smax(T &a, const U &b) {\n  a = a < (T) b ? b : a;\n}\n// }}}\n\nll solve(int k) {\n  if(k == 0) return 0;\n  int s, t;\n  MinCostFlow ecas(k + k + n + n, inf, s, t);\n  for(int i = 0; i < k; i++) XL[i] = 0, XR[i] = 100;\n  for(int i = 0; i < k; i++) YL[i] = 0, YR[i] = 100;\n  for(int i = 0; i < m; i++) {\n    if(b[i] >= k) continue;\n    switch(type[i]) {\n      case 'L':\n        smax(XL[b[i]], a[i] + 1);\n        break;\n      case 'R':\n        smin(XR[k - b[i] - 1], a[i] - 1);\n        break;\n      case 'D':\n        smax(YL[b[i]], a[i] + 1);\n        break;\n      case 'U':\n        smin(YR[k - b[i] - 1], a[i] - 1);\n        break;\n    }\n  }\n  for(int i = 0; i + 1 < k; i++) smax(XL[i+1], XL[i]), smax(YL[i+1] , YL[i]);\n  for(int i = k - 2; i >= 0; i--) smin(XR[i], XR[i+1]), smin(YR[i] , YR[i+1]);\n\n  ll bias = 1e15;\n\n  for(int i = 0; i < k; i++) ecas.addEdge(s, i, 1, 0);\n  for(int i = 0; i < k; i++) ecas.addEdge(k + i, t, 1, 0);\n  for(int i = 0; i < n; i++) ecas.addEdge(k + k + i, k + k + n + i, 1, bias - v[i]);\n\n  for(int i = 0; i < k; i++) {\n    for(int j = 0; j < n; j++) {\n      if(XL[i] <= x[j] && x[j] <= XR[i]) {\n        ecas.addEdge(i, k + k + j, 1, 0);\n      }\n      if(YL[i] <= y[j] && y[j] <= YR[i]) {\n        ecas.addEdge(k + k + n + j, k + i, 1, 0);\n      }\n    }\n  }\n\n  ll val = ecas.build(s, t, k);\n  if(val == -1) return -1;\n\n  val = -val + bias * k;\n  return val;\n}\n\n// O(N^4 log N)\nint main() {\n  std::ios::sync_with_stdio(false), std::cin.tie(0);\n\n  cin >> n;\n  for(int i = 0; i < n; i++) cin >> x[i] >> y[i] >> v[i];\n  \n  cin >> m;\n  for(int i = 0; i < m; i++) cin >> type[i] >> a[i] >> b[i];\n\n  ll ans = 0;\n\n  int g = 0;\n  for(int k = 1; k <= n; k++) {\n    auto val = solve(k);\n    // 単調性はないのか？\n    assert(!g || val == -1);\n    if(val != -1) smax(ans, val);\n    else g = 1;\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n\n#define fo(i,j,l) for(int i=j;i<=l;++i)\n#define fd(i,j,l) for(int i=j;i>=l;--i)\n#define eps 1e-4\n\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\nconst ll N=600;\nconst db sj=5e-12;\n\nint f1[N],f2[N];\nint s1[N],s2[N];\nint w[N];\nll x[N],y[N],v[N];\n\nint n,m,oo,a,b,o2;\ndb c[N],s[N][N];\nint bh[N];\ndb d[N];\nint dl[N];\nint g,gs;\ndb ans=0;\nll da=0;\n\ninline db iabs(db gg)\n{return (gg<0)?(-gg):gg;}\n\ninline void trans(int h,int k)\n{\n\tint u=bh[h]; bh[h]=k;\n\tdb xs=-s[h][k];\n\ts[h][k]=0; s[h][u]=-1;\n\tfo(i,1,g)s[h][i]=s[h][i]/xs;\n\tc[h]=c[h]/xs;\n\tfo(i,1,gs)if(i!=h&&s[i][k]!=0&&iabs(s[i][k])>sj){\n\t\tfo(l,1,g)s[i][l]=s[i][l]+s[i][k]*s[h][l];\n\t\tc[i]=c[i]+c[h]*s[i][k];\n\t\ts[i][k]=0;\n\t}\n\tfo(i,1,g)d[i]=d[i]+d[k]*s[h][i];\n\tans=ans+d[k]*c[h];\n\td[k]=0;\n}\n\ninline int find()\n{\n\tint po=0; d[0]=sj;\n\tfo(i,1,g)if(d[i]>d[po])po=i;\n\treturn po;\n}\n\ninline void Simplex()\n{\n\tint x;\n\twhile((x=find())!=0){\n\t\tdouble zd=100000000;\n\t\tint po=0;\n\t\tfo(i,1,gs)if(s[i][x]<-sj)if(c[i]/(-s[i][x])<zd)zd=c[i]/(-s[i][x]),po=i;\n\t\tif(!po)break;\n\t\ttrans(po,x);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfo(i,1,n){\n\t\tscanf(\"%lld%lld%lld\",&x[i],&y[i],&v[i]);\n\t}\n\tfo(i,1,n)d[i]=v[i];\n\tscanf(\"%d\",&gs); m=gs;\n\tfo(i,1,m){\n\t\tchar ch=' ';\n\t\tfor(;ch!='L'&&ch!='R'&&ch!='U'&&ch!='D';ch=getchar());\n\t\tint aa,bb;\n\t\tscanf(\"%d%d\",&aa,&bb);\n\t\tc[i]=bb;\n\t\tif(ch=='L'){fo(l,1,n)if(x[l]<=aa)s[i][l]=-1;}\n\t\tif(ch=='R'){fo(l,1,n)if(x[l]>=aa)s[i][l]=-1;}\n\t\tif(ch=='D'){fo(l,1,n)if(y[l]<=aa)s[i][l]=-1;}\n\t\tif(ch=='U'){fo(l,1,n)if(y[l]>=aa)s[i][l]=-1;}\t\t\n\t}\n\tfo(i,1,n){\n\t\t++gs; c[gs]=1;\n\t\ts[gs][i]=-1;\n\t}\n\tg=m+n;\n\tSimplex();\n\t/*\n\tfo(i,1,gs)if(bh[i]<=n&&(c[i]<-0.1||c[i]>1.1)){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}*/\n\tll da=(ll)(ans+eps);\n\tif(da<0)puts(\"-1\");else cout<<da;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define cmin(a,b) (a>(b)?a=(b),1:0)\n#define cmax(a,b) (a<(b)?a=(b),1:0)\n#define dmin(a,b) ((a)<(b)?(a):(b))\n#define dmax(a,b) ((a)>(b)?(a):(b))\nnamespace io\n{\n\tint F()\n\t{\n\t\t int F=1,n=0;\n\t\t char ch;\n\t\t while((ch=getchar())!='-'&&(ch<'0'||ch>'9'));\n\t\t ch=='-'?F=0:n=ch-'0';\n\t\t while((ch=getchar())>='0'&&ch<='9')n=n*10+ch-'0';\n\t\t return F?n:-n;\n\t}\n\tlong long G()\n\t{\n\t\t long long F=1,n=0;\n\t\t char ch;\n\t\t while((ch=getchar())!='-'&&(ch<'0'||ch>'9'));\n\t\t ch=='-'?F=0:n=ch-'0';\n\t\t while((ch=getchar())>='0'&&ch<='9')n=n*10+ch-'0';\n\t\t return F?n:-n;\n\t}\n}\nstruct edge\n{\n\tint to;\n\tlong long val;\n\tint res;\n\tint next;\n}e[3888];\nint pe=222;\nvoid insert(int a,int to,long long val,int cap)\n{\n\te[pe]=(edge){to,val,cap,e[a].next};\n\te[a].next=pe++;\n}\nvoid addedge(int a,int to,long long val,int cap)\n{\n\tinsert(a,to,val,cap);\n\tinsert(to,a,-val,0);\n}\nint S,T;\nint U[222],D[222],L[222],R[222];\nint x[222],y[222];\nlong long v[222];\nint in[222];\nint q[22222222],hq,tq;\nint vis[2222];\nlong long dis[2222];\nint from[2222],frome[2222];\nint flow;\nbool spfa()\n{\n\tfor(int i=1;i<=T;++i)dis[i]=0x6e6e6e6e6e6e6e6ell;\n\tfor(q[hq=1]=S,tq=2,vis[S]=1,dis[S]=0;hq!=tq;vis[q[hq++]]=0)\n\t\tfor(register int p=e[q[hq]].next;p;p=e[p].next)\n\t\t\tif(e[p].res&&cmin(dis[e[p].to],dis[q[hq]]+e[p].val))\n\t\t\t{\n\t\t\t\tfrom[e[p].to]=q[hq],frome[e[p].to]=p;\n\t\t\t\tif(!vis[e[p].to])vis[e[p].to]=1,q[tq++]=e[p].to;\n\t\t\t}\n\treturn dis[T]!=0x6e6e6e6e6e6e6e6ell;\n}\nlong long ek()\n{\n\tflow=0;\n\tlong long ans=0;\n\twhile(spfa())\n\t{\n\t\tint now=T;\n\t\tint min=0x3f3f3f3f;\n\t\twhile(1)\n\t\t{\n\t\t\tcmin(min,e[frome[now]].res);\n\t\t\tnow=from[now];\n\t\t\tif(now==S)break;\n\t\t}\n\t\tnow=T;\n\t\twhile(1)\n\t\t{\n\t\t\te[frome[now]].res-=min;\n\t\t\te[frome[now]^1].res+=min;\n\t\t\tnow=from[now];\n\t\t\tif(now==S)break;\n\t\t}\n\t\tans+=dis[T]*min;\n\t\tflow+=min;\n\t}\n\treturn ans;\n}\nint main()\n{\n\tint n=io::F();\n\tfor(register int i=1;i<=n;++i)\n\t\tx[i]=io::F(),y[i]=io::F(),v[i]=io::G();\n\tint m=io::F();\n\tfor(register int i=1;i<=m;++i)\n\t{\n\t\tchar s[4];\n\t\tscanf(\"%s\",s);\n\t\tint a=io::F(),b=io::F();\n\t\tif(*s=='U')U[a]=b;\n\t\tif(*s=='D')D[a]=b;\n\t\tif(*s=='L')L[a]=b;\n\t\tif(*s=='R')R[a]=b;\n\t}\n\tfor(register int i=0;i<100;++i)\n\t{\n\t\tif(U[i]==0)U[i]=n;\n\t\tif(D[i]==0)D[i]=n;\n\t\tif(L[i]==0)L[i]=n;\n\t\tif(R[i]==0)R[i]=n;\n\t}\n\tS=201,T=202;\n\tlong long max=0;\n\tint sum;\n\tlong long tmp;\n\tfor(register int s=1;s<=n;++s)\n\t{\n\t\tfor(register int j=1;j<=T;++j)e[j].next=0,in[j]=0;\n\t\tpe=222;\n\t\tif(s>R[1])goto skip;\n\t\tif(s>L[100])goto skip;\n\t\tif(s>U[1])goto skip;\n\t\tif(s>D[100])goto skip;\n\t\tfor(register int i=1;i<100;++i)\n\t\t{\n\t\t\tint lb,rb;\n\t\t\trb=R[i+1],lb=s-L[i];\n\t\t\tif(lb>rb)goto skip;\n\t\t\taddedge(i,i+1,0,rb-lb);\n\t\t\tin[i+1]+=lb;\n\t\t\tin[i]-=lb;\n\t\t\t\n\t\t\trb=D[i],lb=s-U[i+1];\n\t\t\tif(lb>rb)goto skip;\n\t\t\taddedge(i+100,i+101,0,rb-lb);\n\t\t\tin[i+101]+=lb;\n\t\t\tin[i+100]-=lb;\n\t\t}\n\t\t{\n\t\t\tin[1]+=s;\n\t\t\tin[200]-=s;\n\t\t}\n\t\tsum=0;\n\t\tfor(register int i=1;i<=200;++i)\n\t\t\tif(in[i]>0)addedge(S,i,0,in[i]),sum+=in[i];\n\t\t\t\telse if(in[i]<0)addedge(i,T,0,-in[i]);\n\t\tfor(register int i=1;i<=n;++i)\n\t\t\taddedge(x[i],y[i]+100,-v[i],1);\n\t\ttmp=-ek();\n\t\tif(flow!=sum)continue;\n\t\tcmax(max,tmp);\n\t\tskip:;\n\t}\n\tprintf(\"%lld\\n\",max);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<cstdlib>\n#include<cstring>\n#include<queue>\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0' || ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0' && ch<='9')x=x*10+ch-'0',ch=getchar();\n\treturn x*f;\n}\nint stack[20];\ninline void write(int x)\n{\n\tif(x<0){putchar('-');x=-x;}\n\tif(!x){putchar('0');return;}\n\tint top=0;\n\twhile(x)stack[++top]=x%10,x/=10;\n\twhile(top)putchar(stack[top--]+'0');\n}\ninline void pr1(int x){write(x),putchar(' ');}\ninline void pr2(int x){write(x),puts(\"\");}\nconst int inf=0x3f3f3f3f;\nqueue<int>Q;\nstruct edge\n{\n\tint x,y,c,next;long long w;\n}a[30010];int len,last[310];\ninline void trins(int x,int y,int c,long long w)\n{\n\tlen++;\n\ta[len].x=x;a[len].y=y;a[len].c=c;a[len].w=w;\n\ta[len].next=last[x];last[x]=len;\n}\ninline void ins(int x,int y,int c,long long w){trins(x,y,c,w),trins(y,x,0,-w);}\nint st,ed,pre[310],f[310];\nbool v[310];\nlong long d[310]; \ninline bool spfa()\n{\n\tmemset(d,-1,sizeof(d));\n\tmemset(v,false,sizeof(v));\n\tQ.push(st);f[st]=inf,d[st]=0,v[st]=true;\n\twhile(!Q.empty())\n\t{\n\t\tint x=Q.front();Q.pop();\n\t\tfor(int k=last[x];k;k=a[k].next)\n\t\t{\n\t\t\tif(!a[k].c)continue;\n\t\t\tint y=a[k].y;\n\t\t\tif(d[y]<d[x]+a[k].w)\n\t\t\t{\n\t\t\t\td[y]=d[x]+a[k].w;pre[y]=k;f[y]=min(f[x],a[k].c);\n\t\t\t\tif(v[y]==false)v[y]=true,Q.push(y);\n\t\t\t}\n\t\t}v[x]=false;\n\t}\n\tif(d[ed]==-1)return false;\n\telse return true;\n}\nint sum;\nlong long ans;\ninline void solve()\n{\n\tint x=ed;\n\twhile(x!=st)\n\t{\n\t\tint k=pre[x];\n\t\ta[k].c-=f[ed],a[k^1].c+=f[ed];\n\t\tx=a[k].x;\n\t}sum+=f[ed],ans+=f[ed]*d[ed];\n}\nstruct query\n{\n\tint id,x,y;\n}q[350];\nstruct point\n{\n\tint x,y;long long c;\n}p[100];\nint L[2][100],R[2][100];\nchar ss[2];\nint main()\n{\n\t//freopen(\"a.in\",\"r\",stdin);\n\t//freopen(\"a.out\",\"w\",stdout);\n\tint n=read();\n\tfor(int i=1;i<=n;i++)scanf(\"%d%d%lld\",&p[i].x,&p[i].y,&p[i].c);\n\tint m=read();\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%s%d%d\",ss+1,&q[i].x,&q[i].y);\n\t\tif(ss[1]=='L')q[i].id=0;\n\t\tif(ss[1]=='R')q[i].id=2;\n\t\tif(ss[1]=='D')q[i].id=1;\n\t\tif(ss[1]=='U')q[i].id=3;\n\t}\n\tlong long mx=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=i;j++)L[0][j]=L[1][j]=1,R[0][j]=R[1][j]=100;\n\t\tfor(int j=1;j<=m;j++)\n\t\t{\n\t\t\tif(q[j].id<2)L[q[j].id][q[j].y+1]=q[j].x+1;\n\t\t\telse if(i>q[j].y)R[q[j].id-2][i-q[j].y]=q[j].x-1;\n\t\t}\n\t\tfor(int j=2;j<=i;j++)L[0][j]=max(L[0][j],L[0][j-1]),L[1][j]=max(L[1][j],L[1][j-1]);\n\t\tfor(int j=i-1;j>=1;j--)R[0][j]=min(R[0][j],R[0][j+1]),R[1][j]=min(R[1][j],R[1][j+1]);\n\t\tlen=1,memset(last,0,sizeof(last));\n\t\tst=0,ed=2*n+1;\n\t\tfor(int j=1;j<=n;j++)ins(j,j+n,1,p[j].c);\n\t\tint now=ed+1;\n\t\tfor(int j=1;j<=i;j++)\n\t\t{\n\t\t\tins(st,now,1,0),ins(now+1,ed,1,0);\n\t\t\tfor(int k=1;k<=n;k++)\n\t\t\t{\n\t\t\t\tif(p[k].x>=L[0][j] && p[k].x<=R[0][j])ins(now,k,1,0);\n\t\t\t\tif(p[k].y>=L[1][j] && p[k].y<=R[1][j])ins(k+n,now+1,1,0);\n\t\t\t}now+=2;\n\t\t}\n\t\tsum=ans=0;\n\t\twhile(spfa()==true)solve();\n\t\tif(sum==i)mx=max(mx,ans);\n\t}printf(\"%lld\\n\",mx);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 16.03.2019 16:16:57       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring to_string(string s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntypedef long double ld;\n\nconst ld eps = 1e-8;\n\nvector<ld> simplex(vector<vector<ld>> a) {\n  int n = (int) a.size() - 1;\n  int m = (int) a[0].size() - 1;\n  vector<int> left(n + 1);\n  vector<int> up(m + 1);\n  iota(left.begin(), left.end(), m);\n  iota(up.begin(), up.end(), 0);\n  auto pivot = [&](int x, int y) {\n    swap(left[x], up[y]);\n    ld k = a[x][y];\n    a[x][y] = 1;\n    vector<int> pos;\n    for (int j = 0; j <= m; j++) {\n      a[x][j] /= k;\n      if (fabs(a[x][j]) > eps) {\n        pos.push_back(j);\n      }\n    }\n    for (int i = 0; i <= n; i++) {\n      if (fabs(a[i][y]) < eps || i == x) {\n        continue;\n      }\n      k = a[i][y];\n      a[i][y] = 0;\n      for (int j : pos) {\n        a[i][j] -= k * a[x][j];\n      }\n    }\n  };\n  while (1) {\n    int x = -1;\n    for (int i = 1; i <= n; i++) {\n      if (a[i][0] < -eps && (x == -1 || a[i][0] < a[x][0])) {\n        x = i;\n      }\n    }\n    if (x == -1) {\n      break;\n    }\n    int y = -1;\n    for (int j = 1; j <= m; j++) {\n      if (a[x][j] < -eps && (y == -1 || a[x][j] < a[x][y])) {\n        y = j;\n      }\n    }\n    if (y == -1) {\n      return vector<ld>(); // infeasible\n    }\n    pivot(x, y);\n  }\n  while (1) {\n    int y = -1;\n    for (int j = 1; j <= m; j++) {\n      if (a[0][j] > eps && (y == -1 || a[0][j] > a[0][y])) {\n        y = j;\n      }\n    }\n    if (y == -1) {\n      break;\n    }\n    int x = -1;\n    for (int i = 1; i <= n; i++) {\n      if (a[i][y] > eps && (x == -1 || a[i][0] / a[i][y] < a[x][0] / a[x][y])) {\n        x = i;\n      }\n    }\n    if (x == -1) {\n      return vector<ld>(); // unbounded\n    }\n    pivot(x, y);\n  }\n  vector<ld> ans(m + 1);\n  for (int i = 1; i <= n; i++) {\n    if (left[i] <= m) {\n      ans[left[i]] = a[i][0];\n    }\n  }\n  ans[0] = -a[0][0];\n  return ans;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<int> x(n), y(n);\n  vector<long long> z(n);\n  for (int i = 0; i < n; i++) {\n    cin >> x[i] >> y[i] >> z[i];\n  }\n  vector<vector<ld>> mat;\n  {\n    vector<ld> row(n + 1);\n    for (int i = 0; i < n; i++) {\n      row[i + 1] = z[i];\n    }\n    mat.push_back(row);\n  }\n  {\n    for (int i = 0; i < n; i++) {\n      vector<ld> row(n + 1);\n      row[0] = 1;\n      row[i + 1] = 1;\n      mat.push_back(row);\n    }\n  }\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    string foo;\n    int bar, baz;\n    cin >> foo >> bar >> baz;\n    vector<ld> row(n + 1);\n    row[0] = baz;\n    if (foo == \"L\") {\n      for (int i = 0; i < n; i++) if (x[i] <= bar) row[i + 1] = 1;\n    }\n    if (foo == \"R\") {\n      for (int i = 0; i < n; i++) if (x[i] >= bar) row[i + 1] = 1;\n    }\n    if (foo == \"D\") {\n      for (int i = 0; i < n; i++) if (y[i] <= bar) row[i + 1] = 1;\n    }\n    if (foo == \"U\") {\n      for (int i = 0; i < n; i++) if (y[i] >= bar) row[i + 1] = 1;\n    }\n    mat.push_back(row);\n  }\n  mat.emplace_back(n + 1, 1);\n  mat.emplace_back(n + 1, -1);\n  long long ans = 0;\n  for (int cc = 1; cc <= n; cc++) {\n    mat[(int) mat.size() - 2][0] = cc;\n    mat[(int) mat.size() - 1][0] = cc;\n    vector<ld> ret = simplex(mat);\n    if (!ret.empty()) {\n      long long cur = 0;\n      for (int i = 0; i < n; i++) {\n        if (ret[i + 1] > 1 - eps) {\n          cur += z[i];\n        }\n      }\n      ans = max(ans, cur);\n    }\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define inf 0x3f3f3f3f\n\nusing namespace std;\n\ntypedef long long ll;\n\nstruct Edge {\n  int t,f,next;\n  ll v;\n  Edge() {}\n  Edge(int a,int b,ll c,int d):t(a),f(b),v(c),next(d) {}\n};\n\nEdge e[1000000];\nint head[310],vs,vt,tot=-1;\n\nvoid addEdge(int x,int y,int z,ll v) {\n  e[++tot]=Edge(y,z,v,head[x]);\n  head[x]=tot;\n  e[++tot]=Edge(x,0,-v,head[y]);\n  head[y]=tot;\n}\n\nnamespace Flow {\n\nll dis[310];\nint cur[310];\nbool in[310];\nqueue <int> q;\n\nbool spfa() {\n  while (!q.empty()) q.pop();\n  memset(in,0,sizeof(in));\n  for(int i=vs;i<=vt;i++) dis[i]=-1e18;\n  dis[vs]=0;in[vs]=1;\n  q.push(vs);\n  while (!q.empty()) {\n  \tint x=q.front();q.pop();in[x]=0;\n  \tcur[x]=head[x];\n  \tfor(int i=head[x];i!=-1;i=e[i].next)\n  \t  if (e[i].f&&dis[x]+e[i].v>dis[e[i].t]) {\n  \t  \t  int u=e[i].t;\n  \t  \t  dis[u]=dis[x]+e[i].v;\n  \t  \t  if (!in[u]) {\n  \t  \t  \t    in[u]=1;\n  \t  \t  \t    q.push(u);\n\t\t\t  }\n\t\t}\n  }\n  return dis[vt]>-1e18;\n}\n\nint vis[310],cnt;\n\nint dfs(int x,int a) {\n  if (x==vt||!a) return a;\n  vis[x]=cnt;\n  int ans=0;\n  for(int &i=cur[x];i!=-1;i=e[i].next)\n    if (e[i].f&&vis[e[i].t]<cnt&&dis[x]+e[i].v==dis[e[i].t]) {\n    \tint u=e[i].t;\n    \tint f=dfs(u,min(a,e[i].f));\n    \tif (f) {\n    \t\te[i].f-=f;\n    \t\te[i^1].f+=f;\n    \t\tans+=f;\n    \t\ta-=f;\n    \t\tif (!a) break;\n\t\t}\n\t}\n  return ans;\n}\n\nll msmf(int d) {\n  int s1=0;\n  ll s2=0;\n  while (spfa()) {\n  \tint f;\n    do {\n    \tcnt++;\n    \tf=dfs(vs,inf);\n    \ts1+=f;\n    \ts2+=f*dis[vt];\n\t} while (f);\n  }\n  return (s1>=d)?s2:0;\n}\n\n}\n\nstruct Data {\n  int kind,x,y;\n  ll v;\n  Data() {}\n  Data(int a,int b,int c,ll d):kind(a),x(b),y(c),v(d) {}\n};\n\nData p[100],a[400];\nint minx[400],maxx[400],miny[400],maxy[400];\n\nll solve(int n,int m,int k) {\n  memset(head,255,sizeof(head));\n  memset(minx,0,sizeof(minx));\n  memset(maxx,0x3f,sizeof(maxx));\n  memset(miny,0,sizeof(miny));\n  memset(maxy,0x3f,sizeof(maxy));\n  vs=0;vt=2*n+2*k+1;\n  tot=-1;\n  for(int i=1;i<=m;i++)\n    if (a[i].kind==1) {\n    \tif (a[i].y<k) minx[a[i].y+1]=max(minx[a[i].y+1],a[i].x+1);\n\t}\n\telse if (a[i].kind==2) {\n\t\tif (a[i].y<k) maxx[k-a[i].y]=min(maxx[k-a[i].y],a[i].x-1);\n\t}\n\telse if (a[i].kind==3) {\n    \tif (a[i].y<k) miny[a[i].y+1]=max(miny[a[i].y+1],a[i].x+1);\n\t}\n\telse {\n\t\tif (a[i].y<k) maxy[k-a[i].y]=min(maxy[k-a[i].y],a[i].x-1);\n\t}\n  for(int i=1;i<=k;i++) {\n  \tminx[i]=max(minx[i],minx[i-1]);\n  \tminy[i]=max(miny[i],miny[i-1]);\n  }\n  for(int i=k;i>0;i--) {\n  \tmaxx[i]=min(maxx[i],maxx[i+1]);\n  \tmaxy[i]=min(maxy[i],maxy[i+1]);\n  }\n  for(int i=1;i<=n;i++) addEdge(i,n+i,1,p[i].v);\n  for(int i=1;i<=k;i++) {\n  \taddEdge(vs,2*n+i,1,0);\n  \tfor(int j=1;j<=n;j++)\n  \t  if (p[j].x>=minx[i]&&p[j].x<=maxx[i]) addEdge(2*n+i,j,1,0);\n  }\n  for(int i=1;i<=k;i++) {\n  \taddEdge(2*n+k+i,vt,1,0);\n  \tfor(int j=1;j<=n;j++)\n  \t  if (p[j].y>=miny[i]&&p[j].y<=maxy[i]) addEdge(n+j,2*n+k+i,1,0);\n  }\n  return Flow::msmf(k);\n}\n\nint main() {\n  int n;\n  scanf(\"%d\",&n);\n  for(int i=1;i<=n;i++) {\n  \tint x,y;\n  \tll z;\n  \tscanf(\"%d%d%lld\",&x,&y,&z);\n  \tp[i]=Data(0,x,y,z);\n  }\n  int m;\n  scanf(\"%d\",&m);\n  for(int i=1;i<=m;i++) {\n  \tchar str[5];\n  \tint x,y;\n  \tscanf(\"%s%d%d\",str,&x,&y);\n  \tif (str[0]=='L') a[i]=Data(1,x,y,0);\n  \telse if (str[0]=='R') a[i]=Data(2,x,y,0);\n  \telse if (str[0]=='D') a[i]=Data(3,x,y,0);\n  \telse a[i]=Data(4,x,y,0);\n  }\n  ll ans=0;\n  for(int i=1;i<=n;i++)\n    ans=max(ans,solve(n,m,i));\n  printf(\"%lld\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=(a); i<=(b); i++)\n#define per(i,a,b) for (register int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ntemplate<class T> inline void read(T &x){\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ntemplate<class T> inline void umin(T &x, T y){x=x<y?x:y;}\ntemplate<class T> inline void umax(T &x, T y){x=x>y?x:y;}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 2666;\nint n,A[N],B[N];ll C[N],res;\nint D[N],E[N],F[N];\n//namespace flow{//¶àÂ·Ôö¹ã \n\tconst int M = 200000, inf = 0x3f3f3f3f;const ll biginf=1e17;\n\tint S,T,edgenum=1,head[N],cur[N],to[M],nxt[M],cap[M];ll val[M];\n\tinline void addedge(int u, int v, int c, ll w){\n\t\tto[++edgenum]=v;cap[edgenum]=c;val[edgenum]=w;\n\t\tnxt[edgenum]=head[u];head[u]=edgenum;\n\t}\n\tinline void add(int u, int v, int c, ll w){\n\t\tassert(u<=T&&v<=T&&u&&v);w=-w;\n\t\taddedge(u,v,c,w);addedge(v,u,0,-w);\n\t}\n\tint rec[N],q[N];bool vis[N];ll dis[N];\n\tinline void inc(int &x){x++;x=x==N?0:x;}\n\tinline bool spfa(){\n\t\tint f=0,r=1;rep(i,0,T)dis[i]=biginf;dis[T]=0;q[f]=T;\n\t\twhile(f!=r){\n\t\t\tint u=q[f];inc(f);vis[u]=0;\n\t\t\tL(i,u)if(cap[i^1]&&dis[to[i]]>dis[u]+val[i^1]){\n\t\t\t\tdis[to[i]]=dis[u]+val[i^1];rec[to[i]]=i;\n\t\t\t\tif(!vis[to[i]]){\n\t\t\t\t\tq[r]=to[i],inc(r);vis[to[i]]=1;//SLF»á±äÂý£¡£¡ \n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dis[S]<biginf;\n\t}\n\tbool incir[N];\n\tinline int dfs(int u, int flow){\n\t\tif(u==T||!flow)return flow;assert(!incir[u]);int tot=0;incir[u]=1;\n\t\tfor(register int &i=cur[u];i;i=nxt[i])if(cap[i]&&dis[u]==dis[to[i]]+val[i]&&!incir[to[i]]){\n\t\t\tint tmp=dfs(to[i],min(flow,cap[i]));\n\t\t\tcap[i]-=tmp;cap[i^1]+=tmp;tot+=tmp;flow-=tmp;if(!flow)break;\n\t\t}\n\t\tincir[u]=0;return tot;\n\t}\n\tinline ll solve(int need){//ÈÏÎª·ÑÓÃÔÚintÄÚ\n\t\tll res=0;int c=0;\n\t\twhile(spfa()){\n\t\t\tmemcpy(cur,head,4*(T+2));\n\t\t\tint qaq=dfs(S,inf);c+=qaq;res+=qaq*dis[S];\n\t\t}\n\t\treturn -(c==need?res:0);\n\t}\n//}\n\nint main() {\n\tread(n);\n\trep(i,1,n)read(A[i]),read(B[i]),read(C[i]);\n\tint m;read(m);\n\trep(i,1,m){\n\t\tchar t[5];scanf(\"%s\",t);\n\t\tD[i]=t[0],read(E[i]),read(F[i]);\n\t}\n\trep(k,1,n){\n\t\tedgenum=1;rep(i,0,T)head[i]=0;S=2*k+n*2+5;T=S+1;\n\t\trep(i,1,n)add(2*k+i,2*k+n+i,1,C[i]);\n\t\tstatic int l[N],r[N];\n\t\t//x\n\t\trep(i,1,k)l[i]=0,r[i]=1e9;\n\t\trep(i,1,m)\n\t\t\tif(D[i]=='L'){\n\t\t\t\tumax(l[F[i]+1],E[i]+1);\n\t\t\t}\n\t\t\telse if(D[i]=='R'){\n\t\t\t\tif(k-F[i]>=1)umin(r[k-F[i]],E[i]-1);\n\t\t\t}\n\t\trep(i,2,k)umax(l[i],l[i-1]);\n\t\tper(i,k-1,1)umin(r[i],r[i+1]);\n\t//\trep(i,1,k)cerr<<l[i]<<' '<<r[i]<<endl;\n\t\trep(i,1,k){\n\t\t\tadd(S,i,1,0);\n\t\t\trep(j,1,n)if(A[j]>=l[i]&&A[j]<=r[i])\n\t\t\t\tadd(i,2*k+j,1,0);\n\t\t}\n\t\t//y\n\t\trep(i,1,k)l[i]=0,r[i]=1e9;\n\t\trep(i,1,m)\n\t\t\tif(D[i]=='D'){\n\t\t\t\tumax(l[F[i]+1],E[i]+1);\n\t\t\t}\n\t\t\telse if(D[i]=='U'){\n\t\t\t\tif(k-F[i]>=1)umin(r[k-F[i]],E[i]-1);\n\t\t\t}\n\t\trep(i,2,k)umax(l[i],l[i-1]);\n\t\tper(i,k-1,1)umin(r[i],r[i+1]);\n\t\trep(i,1,k){\n\t\t\tadd(k+i,T,1,0);\n\t\t\trep(j,1,n)if(B[j]>=l[i]&&B[j]<=r[i])\n\t\t\t\tadd(2*k+n+j,k+i,1,0);\n\t\t}\n\t\tll tmp=solve(k);umax(res,tmp);\n\t//\tcerr<<\"qwq \"<<k<<' '<<tmp<<endl;\n\t}\n\tcout<<res;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <list>\n#include <time.h>\n#include <math.h>\n#include <random>\n#include <deque>\n#include <queue>\n#include <cassert>\n#include <unordered_map>\n#include <unordered_set>\n#include <iomanip>\n#include <bitset>\n#include <sstream>\n#include <chrono>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef long double dbl;\nconst int INF = 1.01e9;\n \nconst long double EPS = 1e-18;\nbool eq(long double x, long double y) {\n    return fabs(x - y) < EPS;\n}\nbool ls(long double x, long double y) {\n    return x < y && !eq(x, y);\n}\n \nvector<long double> simplex(vector<vector<long double> > a) {\n    int n = a.size() - 1;\n    int m = a[0].size() - 1;\n    vector<int> left(n + 1), up(m + 1);\n    iota(up.begin(), up.end(), 0);\n    iota(left.begin(), left.end(), m);\n    auto pivot = [&](int x, int y) {\n        swap(left[x], up[y]);\n        long double k = a[x][y];\n        a[x][y] = 1;\n        vector<int> vct;\n        for (int j = 0; j <= m; j++) {\n            a[x][j] /= k;\n            if (!eq(a[x][j], 0)) vct.push_back(j);\n        }\n        for (int i = 0; i <= n; i++) {\n            if (eq(a[i][y], 0) || i == x) continue;\n            k = a[i][y];\n            a[i][y] = 0;\n            for (int j : vct) a[i][j] -= k * a[x][j];\n        }\n    };\n    while (1) {\n        int x = -1;\n        for (int i = 1; i <= n; i++) if (ls(a[i][0], 0) && (x == -1 || a[i][0] < a[x][0])) x = i;\n        if (x == -1) break;\n        int y = -1;\n        for (int j = 1; j <= m; j++) if (ls(a[x][j], 0) && (y == -1 || a[x][j] < a[x][y])) y = j;\n        if (y == -1) assert(0); // infeasible\n        pivot(x, y);\n    }\n    while (1) {\n        int y = -1;\n        for (int j = 1; j <= m; j++) if (ls(0, a[0][j]) && (y == -1 || a[0][j] > a[0][y])) y = j;\n        if (y == -1) break;\n        int x = -1;\n        for (int i = 1; i <= n; i++) if (ls(0, a[i][y]) && (x == -1 || a[i][0] / a[i][y] < a[x][0] / a[x][y])) x = i;\n        if (x == -1) assert(0); // unbounded\n        pivot(x, y);\n    }\n    vector<long double> ans(m + 1);\n    for (int i = 1; i <= n; i++) if (left[i] <= m) ans[left[i]] = a[i][0];\n    ans[0] = -a[0][0];\n    return ans;\n}\n\n#ifdef ONPC\n  mt19937 rnd(228);\n#else\n  mt19937 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\n#endif\n\nint main()\n{\n#ifdef ONPC\n  freopen(\"a.in\", \"r\", stdin);\n#endif\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector <int> x(n), y(n);\n  vector <ll> ok;\n  vector <long double> v;\n  vector <pair <ll, int> > e;\n  for (int i = 0; i < n; i++)\n  {\n    cin >> x[i] >> y[i];\n    ll x;\n    cin >> x;\n    ok.push_back(x);\n    v.push_back(x);\n    e.push_back({x, i});\n  }\n  v.insert(v.begin(), 0);\n  int m;\n  cin >> m;\n  vector <vector <long double> > mat;\n  mat.push_back(v);\n  for (int i = 0; i < n; i++)\n  {\n    vector <long double> kek(n + 1);\n    kek[0] = kek[i + 1] = 1;\n    mat.push_back(kek);\n  }\n  vector <vector <int> > simp;\n  for (int i = 0; i < m; i++)\n  {\n    char c;\n    cin >> c;\n    int a;\n    int b;\n    cin >> a >> b;\n    vector <long double> arr = {(long double) b};\n    vector <int> kek = {b};\n    for (int j = 0; j < n; j++)\n    {\n      int grab = 0;\n      if (c == 'L' && x[j] <= a) grab = 1;\n      if (c == 'R' && x[j] >= a) grab = 1;\n      if (c == 'D' && y[j] <= a) grab = 1;\n      if (c == 'U' && y[j] >= a) grab = 1;\n      arr.push_back(grab);\n      kek.push_back(grab);\n    }\n    mat.push_back(arr);\n    simp.push_back(kek);\n  }\n  auto good = [&] (vector <int> grab)\n  {\n    for (auto c : simp)\n    {\n      int sum = 0;\n      for (int i = 1; i <= n; i++) sum += grab[i - 1] * c[i];\n      if (sum > c[0])\n      {\n        return false;\n      }\n    }\n    return true;\n  };\n  auto f = [&] (vector <int> grab)\n  {\n    ll sum = 0;\n    for (int i = 0; i < n; i++)\n    {\n      if (grab[i]) sum += ok[i];\n    }\n    return sum;\n  };\n  vector <int> grab;\n  for (int i = 0; i < n; i++) grab.push_back(0);\n  cout.precision(20);\n  auto solve = [&] ()\n  {\n    auto ret = simplex(mat);\n    sort(e.begin(), e.end());\n    vector <int> me(n);\n    int kek = 0;\n    for (int i = (int) e.size() - 1; i >= 0; i--)\n    {\n      if (!grab[e[i].second] && ret[e[i].second + 1] > EPS)\n      {\n        kek++;\n        me[e[i].second] = true;\n        grab[e[i].second] = true;\n        if (!good(grab)) grab[e[i].second] = false, me[e[i].second] = false;\n      }\n    }\n    int kekos = 0;\n    for (auto &c : mat)\n    {\n      kekos++;\n      if (kekos > n + 1)\n      for (int i = 1; i <= n; i++)\n      {\n        if (me[i - 1] && c[i] > EPS) c[i]--, c[0]--;\n      }\n    }\n    for (int i = 1; i <= n; i++)\n    {\n      if (me[i - 1])\n      {\n        mat[i][0] = 0;\n      }\n    }\n    return kek;\n  };\n  while (solve());\n  bool ch = true;\n  auto relax = [&] (vector <int> grab)\n  {\n    bool ch = true;\n    while (ch)\n    {\n      ch = false;\n      for (int i = (int) e.size() - 1; i >= 0; i--)\n      {\n        if (!grab[e[i].second])\n        {\n          grab[e[i].second] = true;\n          if (good(grab))\n          {\n            ch = true;\n          }\n          else\n          {\n            grab[e[i].second] = false;\n          }\n        }\n      }\n      if (!ch)\n      {\n        for (int i = 0; i < (int) e.size(); i++)\n        {\n          for (int j = i + 1; j < (int) e.size(); j++)\n          {\n            if (e[i].first < e[j].first && grab[e[i].second] && !grab[e[j].second])\n            {\n              auto x = grab;\n              x[e[i].second] = 0;\n              x[e[j].second] = 1;\n              if (good(x))\n              {\n                grab = x;\n                ch = true;\n              }\n            }\n          }\n        }\n      }\n      if (!ch)\n      {\n        for (int i = 0; i < (int) e.size(); i++)\n        {\n          for (int j = i + 1; j < (int) e.size(); j++)\n          {\n            for (int k = j + 1; k < (int) e.size(); k++)\n            {\n              if (e[i].first + e[j].first < e[k].first && grab[e[i].second] && grab[e[j].second] && !grab[e[k].second])\n              {\n                auto x = grab;\n                x[e[i].second] = x[e[j].second] = 0;\n                x[e[k].second] = 1;\n                if (good(x))\n                {\n                  grab = x;\n                  ch = true;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return grab;\n  };\n  auto me = grab;\n  while (ch)\n  {\n    ch = false;\n    auto go = relax(me);\n    if (f(go) > f(me)) ch = true, me = go;\n    if (!ch)\n    {\n      vector <int> p(n);\n      for (int i = 0; i < n; i++) p[i] = i;\n      shuffle(p.begin(), p.end(), rnd);\n      for (int i : p)\n      {\n        if (me[i])\n        {\n          auto was = me;\n          me[i] = 0;\n          auto go = relax(me);\n          if (f(go) > f(was))\n          {\n            me = go;\n            ch = true;\n          }\n          else\n          {\n            me[i] = 1;\n          }\n        }\n      }\n    }\n  }\n  ll best = f(me);\n  cout << best << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<cstdlib>\n#include<cstring>\n#include<queue>\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0' || ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0' && ch<='9')x=x*10+ch-'0',ch=getchar();\n\treturn x*f;\n}\nint stack[20];\ninline void write(int x)\n{\n\tif(x<0){putchar('-');x=-x;}\n\tif(!x){putchar('0');return;}\n\tint top=0;\n\twhile(x)stack[++top]=x%10,x/=10;\n\twhile(top)putchar(stack[top--]+'0');\n}\ninline void pr1(int x){write(x),putchar(' ');}\ninline void pr2(int x){write(x),puts(\"\");}\nconst int inf=0x3f3f3f3f;\nqueue<int>Q;\nstruct edge\n{\n\tint x,y,c,next;long long w;\n}a[30010];int len,last[510];\ninline void trins(int x,int y,int c,long long w)\n{\n\tlen++;\n\ta[len].x=x;a[len].y=y;a[len].c=c;a[len].w=w;\n\ta[len].next=last[x];last[x]=len;\n}\ninline void ins(int x,int y,int c,long long w){trins(x,y,c,w),trins(y,x,0,-w);}\nint st,ed,pre[510],f[510];\nbool v[510];\nlong long d[510]; \ninline bool spfa()\n{\n\tmemset(d,-63,sizeof(d));\n\tmemset(v,false,sizeof(v));\n\tQ.push(st);f[st]=inf,d[st]=0,v[st]=true;f[ed]=-1;\n\twhile(!Q.empty())\n\t{\n\t\tint x=Q.front();Q.pop();\n\t\tfor(int k=last[x];k;k=a[k].next)\n\t\t{\n\t\t\tif(!a[k].c)continue;\n\t\t\tint y=a[k].y;\n\t\t\tif(d[y]<d[x]+a[k].w)\n\t\t\t{\n\t\t\t\td[y]=d[x]+a[k].w;pre[y]=k;f[y]=min(f[x],a[k].c);\n\t\t\t\tif(v[y]==false)v[y]=true,Q.push(y);\n\t\t\t}\n\t\t}v[x]=false;\n\t}\n\tif(f[ed]==-1)return false;\n\telse return true;\n}\nint sum;\nlong long ans;\ninline void solve()\n{\n\tint x=ed;\n\twhile(x!=st)\n\t{\n\t\tint k=pre[x];\n\t\ta[k].c-=f[ed],a[k^1].c+=f[ed];\n\t\tx=a[k].x;\n\t}sum+=f[ed],ans+=f[ed]*d[ed];\n}\nstruct query\n{\n\tint id,x,y;\n}q[350];\nstruct point\n{\n\tint x,y;long long c;\n}p[100];\nint L[2][100],R[2][100];\nchar ss[2];\nint main()\n{\n\t//freopen(\"a.in\",\"r\",stdin);\n\t//freopen(\"a.out\",\"w\",stdout);\n\tint n=read();\n\tfor(int i=1;i<=n;i++)scanf(\"%d%d%lld\",&p[i].x,&p[i].y,&p[i].c);\n\tint m=read();\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%s%d%d\",ss+1,&q[i].x,&q[i].y);\n\t\tif(ss[1]=='L')q[i].id=0;\n\t\tif(ss[1]=='R')q[i].id=2;\n\t\tif(ss[1]=='D')q[i].id=1;\n\t\tif(ss[1]=='U')q[i].id=3;\n\t}\n\tlong long mx=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=i;j++)L[0][j]=L[1][j]=1,R[0][j]=R[1][j]=100;\n\t\tfor(int j=1;j<=m;j++)\n\t\t{\n\t\t\tif(q[j].id<2)L[q[j].id][q[j].y+1]=q[j].x+1;\n\t\t\telse if(i>q[j].y)R[q[j].id-2][i-q[j].y]=q[j].x-1;\n\t\t}\n\t\tfor(int j=2;j<=i;j++)L[0][j]=max(L[0][j],L[0][j-1]),L[1][j]=max(L[1][j],L[1][j-1]);\n\t\tfor(int j=i-1;j>=1;j--)R[0][j]=min(R[0][j],R[0][j+1]),R[1][j]=min(R[1][j],R[1][j+1]);\n\t\tlen=1,memset(last,0,sizeof(last));\n\t\tst=0,ed=2*n+1;\n\t\tfor(int j=1;j<=n;j++)ins(j,j+n,1,p[j].c);\n\t\tint now=ed+1;\n\t\tfor(int j=1;j<=i;j++)\n\t\t{\n\t\t\tins(st,now,1,0),ins(now+1,ed,1,0);\n\t\t\tfor(int k=1;k<=n;k++)\n\t\t\t{\n\t\t\t\tif(p[k].x>=L[0][j] && p[k].x<=R[0][j])ins(now,k,1,0);\n\t\t\t\tif(p[k].y>=L[1][j] && p[k].y<=R[1][j])ins(k+n,now+1,1,0);\n\t\t\t}now+=2;\n\t\t}\n\t\tsum=ans=0;\n\t\twhile(spfa()==true)solve();\n\t\tif(sum==i)mx=max(mx,ans);\n\t}printf(\"%lld\\n\",mx);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define to edge[i].v\n#define mp make_pair\n#define rint register int\n#define fgx cerr<<\"-------------\"<<endl\n#define N 666\n#define add(a,b,c,d) adde(a,b,c,d),adde(b,a,0,-(d))\nusing namespace std;\ntypedef long long ll;\ntypedef long double db;\ntypedef pair<int,ll> pii;\nvoid dbg(){cerr<<endl;}\ntemplate<typename A,typename... B>void dbg(A x,B... y){cerr<<x<<\" \";dbg(y...);}\n#define debug(...) cerr<<#__VA_ARGS__<<\"=\",dbg(__VA_ARGS__)\nint T,tot,head[N],vis[N],pre[N],xl[N],xr[N],yl[N],yr[N],n,m; ll dis[N]; char c[10];\nstruct Edge{int u,v,w,f,next;ll c;}edge[N*N];\ninline void adde(int x,int y,int w,ll c){edge[++tot]=Edge{x,y,w,0,head[x],c};head[x]=tot;}\ninline int spfa()\n{\tfor(rint i=0;i<=T;i++) dis[i]=-1e18; queue<int> q; q.push(0); dis[0]=0; pre[T]=-1;\n\twhile(!q.empty())\n\t{\tint x=q.front(); vis[x]=0; q.pop();\n\t\tfor(rint i=head[x];i;i=edge[i].next)\n\t\tif(dis[to]<dis[x]+edge[i].c&&edge[i].f<edge[i].w)\n\t\t{\tdis[to]=dis[x]+edge[i].c; pre[to]=i;\n\t\t\tif(!vis[to])q.push(to),vis[to]=1;\n\t\t}\n\t}\n\treturn pre[T]!=-1;\n}\ninline pii mcmf(int f=0,ll c=0)\n{\twhile(spfa())\n\t{\tint mn=1e9; for(rint i=pre[T];i;i=pre[edge[i].u]) mn=min(mn,edge[i].w-edge[i].f);\n\t\tf+=mn; c+=dis[T]*mn; for(rint i=pre[T];i;i=pre[edge[i].u]) edge[i].f+=mn,edge[i^1].f-=mn;\n\t}\n\treturn mp(f,c);\n}\nstruct P{int x,y;ll v;}p[N]; struct Q{char c;int x,y;}q[N];\ninline ll gao(int k)\n{\tfor(rint i=0;i<=k+1;i++) xl[i]=yl[i]=1,xr[i]=yr[i]=100;\n\tfor(rint i=1;i<=m;i++)\n\tif(q[i].c=='L'&&q[i].y!=100) xl[q[i].y+1]=max(xl[q[i].y+1],q[i].x+1);\n\telse if(q[i].c=='R'&&k>q[i].y) xr[k-q[i].y]=min(xr[k-q[i].y],q[i].x-1);\n\telse if(q[i].c=='D'&&q[i].y!=100) yl[q[i].y+1]=max(yl[q[i].y+1],q[i].x+1);\n\telse if(q[i].c=='U'&&k>q[i].y) yr[k-q[i].y]=min(yr[k-q[i].y],q[i].x-1);\n\tfor(rint i=1;i<=k;i++) xl[i]=max(xl[i],xl[i-1]),yl[i]=max(yl[i],yl[i-1]);\n\tfor(rint i=k;i>=1;i--) xr[i]=min(xr[i],xr[i+1]),yr[i]=min(yr[i],yr[i+1]);\n\ttot=1; memset(head,0,sizeof(head));\n\tfor(rint i=1;i<=k;i++) add(0,i,1,0);\n\tfor(rint i=1;i<=k;i++) for(rint j=xl[i];j<=xr[i];j++) add(i,k+j,1,0);\n\tfor(rint i=1;i<=n;i++) add(k+p[i].x,k+100+p[i].y,1,p[i].v);\n\tfor(rint i=1;i<=k;i++) for(rint j=yl[i];j<=yr[i];j++) add(k+100+j,k+200+i,1,0);\n\tT=2*k+201; for(rint i=1;i<=k;i++) add(k+200+i,T,1,0);\n\tpii ans=mcmf(); return ans.first==k?ans.second:0;\n}\nint main()\n{\tcin>>n; for(rint i=1;i<=n;i++) scanf(\"%d%d%lld\",&p[i].x,&p[i].y,&p[i].v);\n\tcin>>m; for(rint i=1;i<=m;i++) scanf(\"%s%d%d\",c+1,&q[i].x,&q[i].y),q[i].c=c[1];\n\tll ans=0; for(rint i=1;i<=n;i++) ans=max(ans,gao(i)); cout<<ans;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cctype>\n#include<iostream>\n#include<queue>\n#define RI register int\n#define CI const int&\nusing namespace std;\nconst int N=350,M=N*N<<2;\nconst long long INF=1e18;\nstruct edge\n{\n\tint to,nxt,v; long long c;\n}e[M<<1]; char opt[N]; long long ans,v[N];\nint n,m,head[N],cnt,x[N],y[N],L[N],R[N],U[N],D[N],a[N],b[N],s,t;\ninline char getch(void)\n{\n\tchar ch; while (!isalpha(ch=getchar())); return ch;\n}\ninline void addedge(CI x,CI y,CI v,const long long& c)\n{\n\te[++cnt]=(edge){y,head[x],v,c}; head[x]=cnt;\n\te[++cnt]=(edge){x,head[y],0,-c}; head[y]=cnt;\n}\n#define to e[i].to\nnamespace NF //Network_Flow\n{\n\tqueue <int> q; int pre[N],lst[N],cap[N]; long long dis[N]; bool vis[N];\n\tinline bool SPFA(CI s,CI t)\n\t{\n\t\tRI i; for (i=s;i<=t;++i) dis[i]=-INF,cap[i]=1e9,pre[i]=-1;\n\t\tpre[s]=0; q.push(s); dis[s]=0; vis[s]=1; while (!q.empty())\n\t\t{\n\t\t\tint now=q.front(); q.pop(); vis[now]=0;\n\t\t\tfor (i=head[now];i;i=e[i].nxt)\n\t\t\tif (e[i].v&&dis[to]<dis[now]+e[i].c)\n\t\t\t{\n\t\t\t\tdis[to]=dis[now]+e[i].c; pre[to]=now; lst[to]=i;\n\t\t\t\tcap[to]=min(cap[now],e[i].v); if (!vis[to]) vis[to]=1,q.push(to);\n\t\t\t}\n\t\t}\n\t\treturn ~pre[t];\n\t}\n\tinline long long MCMF(CI s,CI t)\n\t{\n\t\tlong long ret=0; while (SPFA(s,t))\n\t\t{\n\t\t\tret+=dis[t]*cap[t]; for (int nw=t;nw;nw=pre[nw])\n\t\t\te[lst[nw]].v-=cap[t],e[lst[nw]^1].v+=cap[t];\n\t\t}\n\t\treturn ret;\n\t}\n\tinline void clear(CI n)\n\t{\n\t\tcnt=1; for (RI i=0;i<=n;++i) head[i]=0;\n\t}\n};\n#undef to\ninline long long calc(CI k)\n{\n\tRI i,j; for (i=1;i<=k;++i) L[i]=D[i]=0,R[i]=U[i]=1e9;\n\tfor (NF::clear(2*n+2*k+1),i=1;i<=m;++i) if (b[i]<k) \n\t{\n\t\tif (opt[i]=='L') L[b[i]+1]=a[i]+1;\n\t\tif (opt[i]=='R') R[k-b[i]]=a[i]-1; \n\t\tif (opt[i]=='D') D[b[i]+1]=a[i]+1;\n\t\tif (opt[i]=='U') U[k-b[i]]=a[i]-1; \n\t}\n\tfor (i=2;i<=k;++i) L[i]=max(L[i],L[i-1]),D[i]=max(D[i],D[i-1]);\n\tfor (i=k-1;i;--i) R[i]=min(R[i],R[i+1]),U[i]=min(U[i],U[i+1]);\n\tfor (s=0,t=2*n+2*k+1,i=1;i<=k;++i) addedge(s,i,1,0),addedge(k+2*n+i,t,1,0);\n\tfor (i=1;i<=n;++i) addedge(k+i,k+n+i,1,v[i]);\n\tfor (i=1;i<=k;++i) for (j=1;j<=n;++j)\n\t{\n\t\tif (L[i]<=x[j]&&x[j]<=R[i]) addedge(i,k+j,1,0);\n\t\tif (D[i]<=y[j]&&y[j]<=U[i]) addedge(k+n+j,k+2*n+i,1,0);\n\t}\n\treturn NF::MCMF(s,t);\n}\nint main()\n{\n\tRI i; for (scanf(\"%d\",&n),i=1;i<=n;++i) scanf(\"%d%d%lld\",&x[i],&y[i],&v[i]);\n\tfor (scanf(\"%d\",&m),i=1;i<=m;++i) opt[i]=getch(),scanf(\"%d%d\",&a[i],&b[i]);\n\tfor (i=2;i<=n;++i) ans=max(ans,calc(i)); return printf(\"%lld\",ans),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\nnamespace flow{\n\tconst ll __ = 1e6 + 7 , _ = 1e5 + 7;\n\tstruct Edge{ll end , upEd , f , c;}Ed[__];\n\tll head[_] , cntEd , S , T;\n\tvoid clear(){memset(head , 0 , sizeof(head)); cntEd = 1; S = T = 0;}\n\tvoid addEd(ll a , ll b , ll c , ll d){Ed[++cntEd] = (Edge){b , head[a] , c , d}; head[a] = cntEd;}\n\tvoid addE(ll a , ll b , ll c , ll d){addEd(a , b , c , d); addEd(b , a , 0 , -d);}\n\n\tbool vis[_]; queue < ll > q; ll dis[_] , pre[_];\n\tbool bfs(){\n\t\tq.push(S); memset(dis , -0x3f , sizeof(ll) * (T + 2)); dis[S] = 0;\n\t\twhile(!q.empty()){\n\t\t\tll t = q.front(); q.pop(); vis[t] = 0;\n\t\t\tfor(ll i = head[t] ; i ; i = Ed[i].upEd)\n\t\t\t\tif(Ed[i].f && dis[Ed[i].end] < dis[t] + Ed[i].c){\n\t\t\t\t\tdis[Ed[i].end] = dis[t] + Ed[i].c; pre[Ed[i].end] = i;\n\t\t\t\t\tif(!vis[Ed[i].end]){vis[Ed[i].end] = 1; q.push(Ed[i].end);}\n\t\t\t\t}\n\t\t}\n\t\treturn dis[T] != dis[T + 1];\n\t}\n\t\n\tll EK(ll s , ll t , ll tarf , ll tarc){\n\t\tS = s; T = t; ll sum = 0;\n\t\twhile(bfs()){\n\t\t\tll cur = T; --tarf;\n\t\t\twhile(cur != S){\n\t\t\t\tll t = pre[cur]; cur = Ed[t ^ 1].end; --Ed[t].f; ++Ed[t ^ 1].f;\n\t\t\t\tif(Ed[t].c != 1e16) sum += Ed[t].c; else --tarc;\n\t\t\t}\n\t\t}\n\t\treturn !tarf && !tarc ? sum : -1;\n\t}\n}\n\nll bound[2][2][103] , N , M , X[83] , Y[83]; ll v[83];\n\nsigned main(){\n\tcin >> N; for(ll i = 1 ; i <= N ; ++i) cin >> X[i] >> Y[i] >> v[i];\n\tcin >> M; memset(bound , 0x3f , sizeof(bound));\n\tfor(ll i = 1 ; i <= M ; ++i){\n\t\tchar c; ll p , q; cin >> c >> p >> q;\n\t\tswitch(c){\n\t\tcase 'L': bound[0][0][p] = min(bound[0][0][p] , q); break;\n\t\tcase 'R': bound[0][1][p] = min(bound[0][1][p] , q); break;\n\t\tcase 'U': bound[1][0][p] = min(bound[1][0][p] , q); break;\n\t\tcase 'D': bound[1][1][p] = min(bound[1][1][p] , q); break;\n\t\t}\n\t}\n\tll ans = 0;\n\tfor(ll i = 1 ; i <= N ; ++i){\n\t\tflow::clear(); bool flg = bound[0][0][100] >= i && bound[1][1][100] >= i; ll cnt = 0;\n\t\tfor(ll j = 1 ; j <= 100 ; ++j){\n\t\t\tll dwn = max(0ll , i - bound[0][0][j - 1]) , up = bound[0][1][j]; flg &= dwn <= up;\n\t\t\tcnt += dwn; flow::addE(j , j + 1 , dwn , (ll)1e16); flow::addE(j , j + 1 , up - dwn , 0);\n\t\t}\n\t\tfor(ll j = 100 ; j ; --j){\n\t\t\tll dwn = max(0ll , i - bound[1][1][j - 1]) , up = bound[1][0][j]; flg &= dwn <= up;\n\t\t\tcnt += dwn; flow::addE(202 - j , 203 - j , dwn , (ll)1e16); flow::addE(202 - j , 203 - j , up - dwn , 0);\n\t\t}\n\t\tfor(ll j = 1 ; j <= N ; ++j) flow::addE(X[j] + 1 , 202 - Y[j] , 1 , v[j]);\n\t\tflow::addE(0 , 1 , i , 0); if(flg) ans = max(ans , flow::EK(0 , 202 , i , cnt));\n\t}\n\tcout << ans;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\n  _|_|                              _|  _|    _|\n_|    _|  _|  _|_|  _|_|_|_|        _|  _|  _|\n_|    _|  _|_|          _|          _|  _|_|\n_|    _|  _|          _|      _|    _|  _|  _|\n  _|_|    _|        _|_|_|_|    _|_|    _|    _|\n\n*/\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<set>\n//#define ls (rt<<1)\n//#define rs (rt<<1|1)\n#define vi vector<int>\n#define pb push_back\n#define mk make_pair\n#define pii pair<ll,ll>\n#define rep(i,a,b) for(int i=(a),i##end=(b);i<=i##end;i++)\n#define fi first\n#define se second\n#define int long long\ntypedef long long ll;\nusing namespace std;\nconst int maxn=420;\nconst int inf=1e18+100;\nint xl[maxn],xr[maxn],yl[maxn],yr[maxn],s=415,t=416;\nint head[maxn],cnt=1;\nstruct gg{\n    int u,v,w;ll cost;int next;\n    void insert(int U,int V,int W,ll Cost,int Next){\n        u=U,v=V,w=W,cost=Cost,next=Next;\n    }\n}side[maxn*maxn*2];\nstruct Point{\n    int x,y;\n    ll cost=0;\n}point[maxn];\nstruct Lim{\n    int a,b;char c;\n}lim[maxn];\nvoid ins(int u,int v,int w,ll cost){\n    side[++cnt].insert(u,v,w,cost,head[u]);head[u]=cnt;\n    side[++cnt].insert(v,u,0,-cost,head[v]);head[v]=cnt;\n}\nint n,m;\nvoid init(int k){\n   rep(i,1,k)xl[i]=yl[i]=-inf,xr[i]=yr[i]=inf;\n   rep(i,1,m){\n       if(lim[i].c=='L')rep(j,lim[i].b+1,k)xl[j]=max(xl[j],lim[i].a+1);\n       else if(lim[i].c=='R')for(int j=k-lim[i].b;j>0;j--)xr[j]=min(xr[j],lim[i].a-1);\n       else if(lim[i].c=='D')rep(j,lim[i].b+1,k)yl[j]=max(yl[j],lim[i].a+1);\n       else if(lim[i].c=='U')for(int j=k-lim[i].b;j>0;j--)yr[j]=min(yr[j],lim[i].a-1);\n   }\n   memset(head,0,sizeof(head));cnt=1;\n   rep(i,1,k)ins(s,2*n+i,1,0);\n   rep(i,1,k)ins(2*n+k+i,t,1,0);\n   rep(i,1,n){\n        ins(i,n+i,1,point[i].cost);\n        rep(j,1,k){\n            if(xl[j]<=point[i].x&&point[i].x<=xr[j])ins(2*n+j,i,1,0);\n            if(yl[j]<=point[i].y&&point[i].y<=yr[j])ins(n+i,2*n+k+j,1,0);\n        }\n   }\n}\nint rk[maxn],q[maxn];\nll dis[maxn],lenth;\nbool vis[maxn];\nbool spfa(){\n    rep(i,1,maxn-1)dis[i]=-inf;\n    memset(vis,0,sizeof(vis));\n    int hd=1,tl=1;q[hd]=s;vis[s]=1;dis[s]=0;\n    while(hd<=tl){\n        int u=q[hd++];vis[u]=0;//cout<<u<<' '<<endl;\n        for(int i=head[u];i;i=side[i].next){\n            int v=side[i].v;if(!side[i].w)continue;\n            if(dis[u]+side[i].cost>dis[v]){\n                dis[v]=dis[u]+side[i].cost;\n                if(!vis[v])q[++tl]=v;\n                vis[v]=1;\n            }\n        }\n    }\n    if(dis[t]!=-inf)return 1;\n    return 0;\n}\nint dfs(int u,int flow){\n    if(u==t)return flow;\n    vis[u]=1;int tot=0;\n    for(int i=head[u];i;i=side[i].next){\n        int v=side[i].v;if(vis[v]||!side[i].w||dis[v]!=dis[u]+side[i].cost)continue;\n        int sent=dfs(v,min(flow,side[i].w));\n        lenth+=1ll*side[i].cost*sent,side[i].w-=sent,side[i^1].w+=sent,tot+=sent;flow-=sent;\n    }\n   // vis[u]=0;\n    return tot;\n}\npii dinic(){\n    int mxflow=0;lenth=0;\n    while(spfa()){\n        int x;\n        while((x=dfs(s,inf)))mxflow+=x;\n    }\n    return mk(mxflow,lenth);\n}\nchar tmp[3];\nsigned main(){\n    scanf(\"%lld\",&n);\n    rep(i,1,n)scanf(\"%lld%lld%lld\",&point[i].x,&point[i].y,&point[i].cost);\n    scanf(\"%lld\",&m);\n    rep(i,1,m){\n        scanf(\"%s%lld%lld\",tmp+1,&lim[i].a,&lim[i].b);lim[i].c=tmp[1];\n    }\n    ll out=0;\n    rep(k,1,n){\n        init(k);\n        pii ans=dinic();out=max(out,ans.se);//cout<<ans.se<<endl;\n    }\n    cout<<out;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<stack>\n#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\nstruct MinCostMaxFlow {\n    typedef LL Flow;\n    typedef LL Cost;\n    static const Flow FLOW_INF = 1LL<<60;\n    static const Cost COST_INF = 1LL<<60;\n    struct Edge {\n\tint src, dst;\n\tCost cst;\n\tFlow cap;\n\tint rev;\n\tbool operator<(const Edge&y) const {\n\t    return cst > y.cst;\n\t}\n    };\n    typedef vector<vector<Edge> > Graph;\n    Graph G;\n    MinCostMaxFlow(int N) : G(N) {}\n\n    void add_edge(int u, int v, Cost x, Flow f) {\n\tif (u == v) return;\n\tG[u].push_back((Edge){ u, v, x, f, (int)G[v].size() });\n\tG[v].push_back((Edge){ v, u, -x, 0, (int)G[u].size()-1 });\n    }\n\n    Flow flow;\n    Cost cost;\n    Flow solve(int s, int t, Flow limit = FLOW_INF) {\n\tflow = 0;\n\tcost = 0;\n\tvector<Cost>len(G.size()), h(G.size(), 0);\n\tvector<int> prev(G.size()), prev_num(G.size());\n\twhile (limit > 0) {\n\t    priority_queue<Edge> Q;\n\t    Q.push((Edge){-2, s, 0, 0, 0});\n\t    fill(len.begin(), len.end(), COST_INF);\n\t    fill(prev.begin(), prev.end(), -1);\n\t    len[s] = 0;\n\t    while (!Q.empty()) {\n\t\tEdge e = Q.top(); Q.pop();\n\t\tif (e.cst > len[e.dst]) continue;\n\t\tfor (int i=0; i<(int)G[e.dst].size(); i++) {\n\t\t    const Edge &f = G[e.dst][i];\n\t\t    if (f.cap > 0 && len[f.dst] > len[f.src] + f.cst + h[f.src] - h[f.dst]) {\n\t\t\tlen[f.dst] = len[f.src] + f.cst + h[f.src] - h[f.dst];\n\t\t\tQ.push((Edge){ f.src, f.dst, len[f.dst], 0, 0 });\n\t\t\tprev[f.dst] = f.src; prev_num[f.dst] = i;\n\t\t    }\n\t\t}\n\t    }\n\t    if (prev[t] == -1) return flow;\n\t    for (int i=0; i<(int)G.size(); i++) h[i] += len[i];\n\t    \n\t    Flow f = limit;\n\t    for (int v=t; v!=s; v=prev[v])\n\t\tf = min(f, G[prev[v]][prev_num[v]].cap);\n\t    for (int v=t; v!=s; v=prev[v]) {\n\t\tEdge &e = G[prev[v]][prev_num[v]];\n\t\te.cap -= f;\n\t\tG[e.dst][e.rev].cap += f;\n\t    }\n\t    limit -= f;\n\t    flow += f;\n\t    cost += f * h[t];\n\t}\n\treturn flow;\n    }\n};\nconst MinCostMaxFlow::Flow MinCostMaxFlow::FLOW_INF;\nconst MinCostMaxFlow::Cost MinCostMaxFlow::COST_INF;\n\nint N;\nint X[88], Y[88];\nLL V[88];\nint M;\nchar T[333];\nint A[333], B[333];\n\nint Llo[88], Lhi[88], Dlo[88], Dhi[88];\nconst LL BASE = 1LL<<50;\nLL calc(int K) {\n    memset(Lhi, 0x3f, sizeof Lhi);\n    memset(Llo, 0xc0, sizeof Llo);\n    memset(Dhi, 0x3f, sizeof Dhi);\n    memset(Dlo, 0xc0, sizeof Dlo);\n    REP (j, M) {\n\tint a = A[j], b = B[j];\n\tif (b < K) {\n\t    if (T[j] == 'L') amax(Llo[b], a);\n\t    if (T[j] == 'R') amin(Lhi[K-b-1], a);\n\t    if (T[j] == 'D') amax(Dlo[b], a);\n\t    if (T[j] == 'U') amin(Dhi[K-b-1], a);\n\t}\n    }\n    REP (i, K-1) {\n\tamax(Llo[i+1], Llo[i]);\n\tamax(Dlo[i+1], Dlo[i]);\n    }\n    for (int i=K-2; i>=0; i--) {\n\tamin(Lhi[i], Lhi[i+1]);\n\tamin(Dhi[i], Dhi[i+1]);\n    }\n//    rprintf(\"%d\", Llo, Llo+K);\n//    rprintf(\"%d\", Lhi, Lhi+K);\n//    rprintf(\"%d\", Dlo, Dlo+K);\n//    rprintf(\"%d\", Dhi, Dhi+K);\n//\n    const int SRC = K*2+N*2, SNK = SRC+1;\n    MinCostMaxFlow G(SNK+1);\n    REP (i, N) {\n\tint left = i+K*2, right = left + N;\n\tG.add_edge(left, right, BASE - V[i], 1);\n\tREP (a, K) {\n\t    if (Llo[a] < X[i] && X[i] < Lhi[a]) {\n\t\tG.add_edge(a, left, 0, 1);\n\t    }\n\t    if (Dlo[a] < Y[i] && Y[i] < Dhi[a]) {\n\t\tG.add_edge(right, a+K, 0, 1);\n\t    }\n\t}\n    }\n    REP (a, K) {\n\tG.add_edge(SRC, a, 0, 1);\n\tG.add_edge(a+K, SNK, 0, 1);\n    }\n    G.solve(SRC, SNK);\n    if (G.flow == K) {\n\treturn K * BASE - G.cost;\n    } else {\n\treturn -1;\n    }\n\n}\n\nvoid MAIN() {\n    scanf(\"%d\", &N);\n    REP (i, N) scanf(\"%d%d%lld\", X+i, Y+i, V+i);\n    scanf(\"%d\", &M);\n    REP (i, M) scanf(\"%s%d%d\", T+i, A+i, B+i);\n\n    \n    LL ans = 0;\n    for (int k=1; k<=N; k++) {\n\tLL tmp = calc(k);\n\tif (tmp == -1) break;\n\tamax(ans, tmp);\n    }\n    \n    printf(\"%lld\\n\", ans);\n\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<cstring>\nusing namespace std;\n#define N 421\n#define M 38300\nint s[N][3],v[N][2],n,m,l[N][2],r[N][2],head[N],cur[N],cnt,in[N],vis[N];\nchar c[12];\nlong long dis[N],c1[N],as1,as;\nstruct edge{int t,next,v;long long c;}ed[M];\nvoid adde(int f,int t,int v,long long c){ed[++cnt]=(edge){t,head[f],v,c};head[f]=cnt;ed[++cnt]=(edge){f,head[t],0,-c};head[t]=cnt;}\nbool spfa(int s,int t)\n{\n\tmemset(dis,-0x3f,sizeof(dis));\n\tmemcpy(cur,head,sizeof(cur));\n\tqueue<int> tp;\n\ttp.push(s);dis[s]=0;in[s]=1;\n\twhile(!tp.empty())\n\t{\n\t\tint r=tp.front();tp.pop();in[r]=0;\n\t\tfor(int i=head[r];i;i=ed[i].next)\n\t\tif(ed[i].v&&dis[ed[i].t]<dis[r]+ed[i].c)\n\t\t{\n\t\t\tdis[ed[i].t]=dis[r]+ed[i].c;\n\t\t\tif(!in[ed[i].t])in[ed[i].t]=1,tp.push(ed[i].t);\n\t\t}\n\t}\n\treturn dis[t]>-1e18;\n}\nint dfs(int u,int t,int f)\n{\n\tif(!f||u==t)return f;\n\tvis[u]=1;\n\tint tp,as=0;\n\tfor(int& i=cur[u];i;i=ed[i].next)\n\tif(!vis[ed[i].t]&&ed[i].v&&dis[ed[i].t]==dis[u]+ed[i].c&&(tp=dfs(ed[i].t,t,min(f,ed[i].v))))\n\t{\n\t\ted[i].v-=tp;ed[i^1].v+=tp;\n\t\tf-=tp,as+=tp;as1+=ed[i].c*tp;\n\t\tif(!f){vis[u]=0;return as;}\n\t}\n\tvis[u]=0;return as;\n}\nint dinic(int s,int t){int tp=0;while(spfa(s,t))tp+=dfs(s,t,1e8);return tp;}\nint main()\n{\n\tscanf(\"%d\",&n);for(int i=1;i<=n;i++)scanf(\"%d%d%lld\",&v[i][0],&v[i][1],&c1[i]);\n\tscanf(\"%d\",&m);for(int i=1;i<=m;i++){scanf(\"%s%d%d\",c+1,&s[i][1],&s[i][2]);if(c[1]=='U')s[i][0]=0;if(c[1]=='D')s[i][0]=1;if(c[1]=='R')s[i][0]=2;if(c[1]=='L')s[i][0]=3;}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tcnt=1;for(int j=1;j<=402;j++)head[j]=0;\n\t\tfor(int j=1;j<=i;j++)l[j][0]=1,l[j][1]=100,r[j][0]=1,r[j][1]=100;\n\t\tfor(int j=1;j<=m;j++)if(i>s[j][2])\n\t\t{\n\t\t\tint tp=s[j][2];\n\t\t\tif(s[j][0]==1)\n\t\t\t{\n\t\t\t\tfor(int k=1;k<=i-tp;k++)l[k][0]=max(l[k][0],s[j][1]+1);\n\t\t\t}\n\t\t\tif(s[j][0]==0)\n\t\t\t{\n\t\t\t\tfor(int k=tp+1;k<=i;k++)l[k][1]=min(l[k][1],s[j][1]-1);\n\t\t\t}\n\t\t\tif(s[j][0]==3)\n\t\t\t{\n\t\t\t\tfor(int k=1;k<=i-tp;k++)r[k][0]=max(r[k][0],s[j][1]+1);\n\t\t\t}\n\t\t\tif(s[j][0]==2)\n\t\t\t{\n\t\t\t\tfor(int k=tp+1;k<=i;k++)r[k][1]=min(r[k][1],s[j][1]-1);\n\t\t\t}\n\t\t}\n\t\tint s1=401,t=402;\n\t\tfor(int j=1;j<=i;j++)adde(s1,j,1,0);\n\t\tfor(int j=1;j<=i;j++)\n\t\tfor(int k=l[j][0];k<=l[j][1];k++)\n\t\tadde(j,k+100,1,0);\n\t\tfor(int j=1;j<=n;j++)adde(v[j][1]+100,v[j][0]+200,1,c1[j]);\n\t\tfor(int j=1;j<=i;j++)\n\t\tfor(int k=r[j][0];k<=r[j][1];k++)\n\t\tadde(k+200,j+300,1,0);\n\t\tfor(int j=1;j<=i;j++)adde(j+300,t,1,0);\n\t\tas1=0;int tp2=dinic(s1,t);\n\t\tif(tp2==i)as=max(as,as1);\n\t}\n\tprintf(\"%lld\\n\",as);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <assert.h>\n\nusing namespace std;\n\nstruct Jewel\n{\n  int x, y;\n  long long v;\n  int cnt = 0;\n\n  bool operator<(const Jewel &other) const\n  {\n    return (other.v == v ? cnt < other.cnt : other.v < v);\n  }\n};\n\nstruct Request\n{\n  string t;\n  int a, b;\n  int cnt = 0;\n};\n\nint main()\n{\n  int N;\n  cin >> N;\n  vector<Jewel> jewel(N);\n  for (int i = 0; i < N; i++)\n  {\n    int x, y;\n    long long v;\n    cin >> x >> y >> v;\n    jewel[i] = {x, y, v};\n  }\n  int M;\n  cin >> M;\n  vector<Request> request(M);\n  for (int i = 0; i < M; i++)\n  {\n    string t;\n    int a, b;\n    cin >> t >> a >> b;\n    request[i] = {t, a, b};\n  }\n  chrono::system_clock::time_point start = chrono::system_clock::now();\n  long long ans = 0;\n  while (chrono::duration_cast<chrono::microseconds>(chrono::system_clock::now() - start).count() / 1000 < 4993)\n  {\n    long long tmp = 0;\n    for (Request &j : request)\n      j.cnt = 0;\n    for (Jewel i : jewel)\n    {\n      bool ok = true;\n      for (Request j : request)\n        switch (j.t[0])\n        {\n        case 'L':\n          if (i.x <= j.a && j.b < j.cnt + 1)\n            ok = false;\n          break;\n        case 'R':\n          if (j.a <= i.x && j.b < j.cnt + 1)\n            ok = false;\n          break;\n        case 'D':\n          if (i.y <= j.a && j.b < j.cnt + 1)\n            ok = false;\n          break;\n        case 'U':\n          if (j.a <= i.y && j.b < j.cnt + 1)\n            ok = false;\n          break;\n        }\n      if (!ok)\n        continue;\n      tmp += i.v;\n      for (Request &j : request)\n        switch (j.t[0])\n        {\n        case 'L':\n          if (i.x <= j.a)\n            j.cnt++;\n          break;\n        case 'R':\n          if (j.a <= i.x)\n            j.cnt++;\n          break;\n        case 'D':\n          if (i.y <= j.a)\n            j.cnt++;\n          break;\n        case 'U':\n          if (j.a <= i.y)\n            j.cnt++;\n          break;\n        }\n    }\n    swap(jewel[rand() % N], jewel[rand() % N]);\n    if (ans < tmp)\n      ans = tmp;\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace mcmf {\n\nconst long long inf = 1000111222000111222LL;\n\nstruct edge {\n    int to, flow, capacity;\n    long long cost;\n\n    edge() {\n    }\n\n    edge(int to, int flow, int capacity, long long cost): to(to), flow(flow), capacity(capacity), cost(cost) {\n    }\n\n};\n\nconst int max_v = 404;\n\nvector<edge> edges;\nvector<int> g[max_v];\n\nvoid clr() {\n    edges.clear();\n    for (int i = 0; i < max_v; ++i) {\n        g[i].clear();\n    }\n}\n\nvoid add_edge(int u, int v, int capacity, long long cost) {\n    g[u].push_back(edges.size());\n    edges.push_back(edge(v, 0, capacity, cost));\n    g[v].push_back(edges.size());\n    edges.push_back(edge(u, 0, 0, -cost));\n}\n\nint parent[max_v], p_id[max_v];\nlong long phi[max_v], dist[max_v];\n\nlong long dijkstra(int s, int t) {\n    for (int i = 0; i <= t; ++i) {\n        dist[i] = inf;\n    }\n    priority_queue<pair<long long, int>> q;\n    dist[s] = 0;\n    q.push({0, s});\n    while (!q.empty() && dist[t] == inf) {\n        pair<long long, int> p = q.top();\n        q.pop();\n        long long d = -p.first, v = p.second;\n        if (d != dist[v]) {\n            continue;\n        }\n        for (int id : g[v]) {\n            if (edges[id].flow == edges[id].capacity) {\n                continue;\n            }\n            int to = edges[id].to;\n            if (dist[v] + edges[id].cost + phi[v] - phi[to] < dist[to]) {\n                dist[to] = dist[v] + edges[id].cost + phi[v] - phi[to];\n                parent[to] = v;\n                p_id[to] = id;\n                q.push({-dist[to], to});\n            }\n        }\n    }\n    if (dist[t] == inf) {\n        return inf;\n    }\n    for (int i = 0; i <= t; ++i) {\n        phi[i] = min(inf, dist[i] + phi[i]);\n    }\n    int v = t;\n    while (v != s) {\n        ++edges[p_id[v]].flow;\n        --edges[p_id[v] ^ 1].flow;\n        v = parent[v];\n    }\n    return phi[t];\n}\n\nlong long min_cost_max_flow(int s, int t, int k) {\n    for (int i = 0; i <= t; ++i) {\n        phi[i] = 0;\n    }\n    long long res = 0;\n    int it = 0;\n    while (true) {\n        long long x = dijkstra(s, t);\n        if (x == inf) {\n            break;\n        }\n        ++it;\n        res += x;\n    }\n    if (it != k) {\n        return 0;\n    }\n    return res;\n}\n\n}\n\nconst int max_n = 105;\nconst int max_c = 333;\nconst long long inf = 1000111222000111LL;\n\nint lx[max_n], rx[max_n], ly[max_n], ry[max_n];\n\nstruct constraint {\n    char tp;\n    int x, cnt;\n\n    void read() {\n        scanf(\"\\n%c%d%d\", &tp, &x, &cnt);\n        --x;\n    }\n\n    void add(int k) {\n        if (tp == 'L') {\n            for (int i = cnt; i < k; ++i) {\n                lx[i] = max(lx[i], x + 1);\n            }\n        } else if (tp == 'D') {\n            for (int i = cnt; i < k; ++i) {\n                ly[i] = max(ly[i], x + 1);\n            }\n        } else if (tp == 'R') {\n            for (int i = 0; i < k - cnt; ++i) {\n                rx[i] = min(rx[i], x - 1);\n            }\n        } else {\n            for (int i = 0; i < k - cnt; ++i) {\n                ry[i] = min(ry[i], x - 1);\n            }\n        }\n    }\n};\n\nint n, m, x[max_n], y[max_n];\nlong long v[max_n];\nconstraint c[max_c];\n\nlong long solve(int k) {\n    for (int i = 0; i < k; ++i) {\n        lx[i] = ly[i] = 0;\n        rx[i] = ry[i] = 99;\n    }\n    for (int i = 0; i < m; ++i) {\n        c[i].add(k);\n    }\n    for (int i = 0; i < k; ++i) {\n        if (lx[i] > rx[i] || ly[i] > ry[i]) {\n            return 0;\n        }\n    }\n    mcmf::clr();\n    const int max_x = 100;\n    int s = 2 * k + 2 * max_x;\n    int t = s + 1;\n    for (int i = 0; i < k; ++i) {\n        mcmf::add_edge(s, i, 1, 0);\n        for (int x = lx[i]; x <= rx[i]; ++x) {\n            mcmf::add_edge(i, k + x, 1, 0);\n        }\n        mcmf::add_edge(k + 2 * max_x + i, t, 1, 0);\n        for (int y = ly[i]; y <= ry[i]; ++y) {\n            mcmf::add_edge(k + max_x + y, k + 2 * max_x + i, 1, 0);\n        }\n    }\n    for (int i = 0; i < n; ++i) {\n        mcmf::add_edge(k + x[i], k + max_x + y[i], 1, -v[i] + inf);\n    }\n    long long res = -mcmf::min_cost_max_flow(s, t, k);\n    if (res == 0) {\n        return 0;\n    }\n    return res + k * inf;\n}\n\nint main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; ++i) {\n        scanf(\"%d%d%lld\", &x[i], &y[i], &v[i]);\n        --x[i];\n        --y[i];\n    }\n    scanf(\"%d\", &m);\n    for (int i = 0; i < m; ++i) {\n        c[i].read();\n    }\n    long long ans = 0;\n    for (int i = 1; i <= n; ++i) {\n        long long res = solve(i);\n        if (res == 0) {\n            break;\n        }\n        ans = max(ans, res);\n    }\n    printf(\"%lld\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace __gnu_pbds;\nusing namespace std;\n \ntemplate <typename T>\nusing ordered_set =\n\ttree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n \n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n\t*this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n \n#define shandom_ruffle random_shuffle\n \nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=327;\nusing bn=bitset<87>;\n\nint n;\npii gdz[nax];\nll war[nax];\n\nint m;\nbn podz[nax];\nint ile[nax];\n\nll wyn;\n\nbn ter;\n\nll dajwar()\n{\n\tll ret=0;\n\tfor (int i=1; i<=n; i++)\n\t\tif (ter[i])\n\t\t\tret+=war[i];\n\treturn ret;\n}\n\nint popr()\n{\n\tfor (int i=1; i<=m; i++)\n\t\tif ((podz[i]&ter).count()>ile[i])\n\t\t\treturn 0;\n\treturn 1;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(\"%d%d%lld\", &gdz[i].first, &gdz[i].second, &war[i]);\n\tscanf(\"%d\", &m);\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\tchar c;\n\t\tint a, b;\n\t\tscanf(\" %c%d%d\", &c, &a, &b);\n\t\tfor (int j=1; j<=n; j++)\n\t\t{\n\t\t\tif (c=='L' && gdz[j].first<=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='R' && gdz[j].first>=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='D' && gdz[j].second<=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='U' && gdz[j].second>=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t}\n\t\tile[i]=b;\n\t}\n\tll sta=0;\n\tconst int czes=5e5;\n\tconst int res=5e4;\n\tfor (int h=0; h%czes || (clock()<=4.5*CLOCKS_PER_SEC); h++)\n\t{\n\t\tif (!(rand()%res))\n\t\t{\n\t\t\tter.reset();\n\t\t\tsta=0;\n\t\t}\n\t\tbn pam=ter;\n\t\tint r=rand()%3+1;\n\t\tfor (int i=0; i<r; i++)\n\t\t\tter.flip(rand()%n+1);\n\t\tif (!popr())\n\t\t{\n\t\t\tter=pam;\n\t\t\tcontinue;\n\t\t}\n\t\tll now=dajwar();\n\t\tif (now>=sta || !(rand()%250))\n\t\t{\n\t\t\tsta=now;\n\t\t\twyn=max(wyn, now);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tter=pam;\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\\n\", wyn);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#define lop(c,l) for(int c=1;c<=(l);++c)\n#define loop(c,l) for(int c=0;c<(l);++c)\nusing namespace std;\n\n#define int long long\n#define double long double\ntemplate<int Vari,int Crat>\nstruct algo_simplex{\n\tdouble matrix[Crat+1][Vari+1],ans[Vari+1];\n\tint id[Crat<<1|1];\n\tint vari,crat;\n\tdouble target;\n\tconst char* cond;\n\tvoid pivot(const int& l,const int& e){\n\t\tswap(id[vari+l],id[e]);\n\t\tdouble t=matrix[l][e];\n\t\tmatrix[l][e]=1;\n\t\tfor(int j=0;j<=vari;j++) matrix[l][j]/=t;\n\t\tfor(int i=0;i<=crat;i++) if(i!=l&&abs(matrix[i][e])>1e-8){\n\t\t\tt=matrix[i][e];\n\t\t\tmatrix[i][e]=0;\n\t\t\tfor(int j=0;j<=vari;j++) matrix[i][j]-=matrix[l][j]*t;\n\t\t}\n\t}\n\tbool init(){\n\t\twhile(1){\n\t\t\tint l=0,e=0;\n\t\t\tfor(int i=1;i<=crat;i++) if(matrix[i][0]<-1e-8&&(!l||(rand()&1))) l=i;\n\t\t\tif(!l) return 1;\n\t\t\tfor(int j=1;j<=vari;j++) if(matrix[l][j]<-1e-8&&(!e||(rand()&1))) e=j;\n\t\t\tif(!e) return 0;\n\t\t\tpivot(l,e);\n\t\t}\n\t}\n\tbool funct(const int& v,const int& c){\n\t\tsrand(new int()-(int*)NULL);\n\t\tvari=v,crat=c;\n\t\tfor(int i=1;i<=vari;i++) id[i]=i;\n\t\tif(!init())\treturn 0;\n\t\twhile(1){\n\t\t\tint l=0,e=0;\n\t\t\tdouble minn=1e15;\n\t\t\tfor(int j=1;j<=vari&&!e;j++) if(matrix[0][j]>1e-8) e=j;\n\t\t\tif(!e) break;\n\t\t\tfor(int i=1;i<=crat;i++) if(matrix[i][e]>1e-8&&matrix[i][0]/matrix[i][e]<minn) minn=matrix[i][0]/matrix[i][e],l=i;\n\t\t\tif(!l) return 0;\n\t\t\tpivot(l,e);\n\t\t}\n\t\ttarget=-matrix[0][0];\n\t\tfor(int i=1;i<=crat;i++) ans[id[vari+i]]=matrix[i][0];\n\t\treturn 1;\n\t}\n};\nalgo_simplex<80,400> spl;\nstruct loc{\n\tint x,y,v;\n}p[81];\nint n,m,ll,lim;\nchar ch;\nsigned main(signed,char**,char**){\n\tscanf(\"%lld\",&n);\n\tlop(i,n){\n\t\tscanf(\"%lld%lld%lld\",&p[i].x,&p[i].y,&p[i].v);\n\t\tspl.matrix[0][i]=p[i].v;\n\t}\n\tscanf(\"%lld\",&m);\n\tlop(i,m){\n\t\tscanf(\" %c%lld%lld\",&ch,&ll,&lim);\n\t\tswitch(ch){\n\t\t\tcase 'L':{\n\t\t\t\tlop(j,n) if(p[j].x<=ll) spl.matrix[i][j]=1;\n\t\t\t\tspl.matrix[i][0]=lim;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'R':{\n\t\t\t\tlop(j,n) if(p[j].x>=ll) spl.matrix[i][j]=1;\n\t\t\t\tspl.matrix[i][0]=lim;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'D':{\n\t\t\t\tlop(j,n) if(p[j].y<=ll) spl.matrix[i][j]=1;\n\t\t\t\tspl.matrix[i][0]=lim;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'U':{\n\t\t\t\tlop(j,n) if(p[j].y>=ll) spl.matrix[i][j]=1;\n\t\t\t\tspl.matrix[i][0]=lim;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tlop(i,n) spl.matrix[m+i][i]=1,spl.matrix[m+i][0]=1;\n\tspl.funct(n,m+n);\n\tprintf(\"%.0Lf\",spl.target+1e-8);\n\texit(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct edge{\n\tint to,cap;\n\tlong long cst;\n\tint rev;\n};\nvector<edge>G[330];\nvoid addedge(int frm,int to,int cap,long long cst)\n{\n\tG[frm].push_back((edge){to,cap,cst,(int)G[to].size()});\n\tG[to].push_back((edge){frm,0,-cst,(int)G[frm].size()-1});\n}\nbool inq[330];\nlong long dis[330];\nint prv[330],pre[330];\nint T; \nbool maxspfa()\n{\n\tfor(int i=0;i<=T;i++)dis[i]=-1e18;\n\tqueue<int>q;\n\tq.push(0);\n\tdis[0]=0;\n\tinq[0]=true;\n\twhile(!q.empty())\n\t{\n\t\tint x=q.front();\n\t\tq.pop();\n\t\tinq[x]=false;\n\t\tfor(int i=0;i<(int)G[x].size();i++)\n\t\t{\n\t\t\tedge &e=G[x][i];\n\t\t\tif(e.cap && dis[x]+e.cst>dis[e.to])\n\t\t\t{\n\t\t\t\tdis[e.to]=dis[x]+e.cst;\n\t\t\t\tprv[e.to]=x;\n\t\t\t\tpre[e.to]=i;\n\t\t\t\tif(!inq[e.to])\n\t\t\t\t{\n\t\t\t\t\tinq[e.to]=true;\n\t\t\t\t\tq.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn (dis[T]!=-1e18);\n}\nlong long maxcstmaxflow()\n{\n\tint cur=T;\n\twhile(cur)\n\t{\n\t\tedge &e=G[prv[cur]][pre[cur]];\n\t\te.cap--;\n\t\tG[e.to][e.rev].cap++;\n\t\tcur=prv[cur];\n\t}\n\treturn dis[T];\n}\nint n;\nint lx[90],rx[90],ly[90],ry[90];\nint x[90],y[90];\nlong long v[90];\nint m;\nchar ty[10];\nlong long ans;\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%d%d%lld\",x+i,y+i,v+i),rx[i]=ry[i]=101;\n\tscanf(\"%d\",&m);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint a,b;\n\t\tscanf(\"%s%d%d\",ty,&a,&b);\n\t\tif(ty[0]=='L')lx[b+1]=max(lx[b+1],a);\n\t\telse if(ty[0]=='R')rx[b+1]=min(rx[b+1],a);\n\t\telse if(ty[0]=='D')ly[b+1]=max(ly[b+1],a);\n\t\telse ry[b+1]=min(ry[b+1],a);\n\t}\n\tfor(int i=2;i<=n;i++)lx[i]=max(lx[i],lx[i-1]),rx[i]=min(rx[i],rx[i-1]),ly[i]=max(ly[i],ly[i-1]),ry[i]=min(ry[i],ry[i-1]);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tT=n+n+i+i+1;\n\t\tfor(int j=0;j<=T;j++)G[j].clear();\n\t\tfor(int j=1;j<=i;j++)addedge(0,n+n+j,1,0),addedge(n+n+i+j,T,1,0);\n\t\tfor(int j=1;j<=i;j++)\n\t\t{\n\t\t\tfor(int k=1;k<=n;k++)\n\t\t\t{\n\t\t\t\tif(lx[j]<x[k] && x[k]<rx[i+1-j])addedge(n+n+j,k,1,0);\n\t\t\t\tif(ly[j]<y[k] && y[k]<ry[i+1-j])addedge(n+k,n+n+i+j,1,0);\n\t\t\t}\n\t\t}\n\t\tfor(int j=1;j<=n;j++)addedge(j,n+j,1,v[j]);\n\t\tlong long res=0;\n\t\tint cnt=0;\n\t\twhile(maxspfa())res+=maxcstmaxflow(),cnt++;\n\t\tif(cnt<i)continue;\n\t\tlong long sum=0;\n\t\tans=max(ans,res);\n\t}\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int N=505,M=200005;\nint b[N],a[N],z[N],S,T,flag[N],x[N],y[N],opt[N],lx[N],rx[N],ly[N],ry[N],n,m,sl[M],ne[M],fi[N],zz[M],w[M],tot,dis[N],cur[N];\nqueue<int> Q;\nvoid jb(int x,int y,int z,int v){\n\tne[++tot]=fi[x];fi[x]=tot;zz[tot]=y;sl[tot]=z;w[tot]=v;\n\tne[++tot]=fi[y];fi[y]=tot;zz[tot]=x;sl[tot]=0;w[tot]=-v;\n}\nint get(){\n\tchar s[2];\n\tscanf(\"%s\",s);\n\tif (s[0]=='L')return 1;\n\tif (s[0]=='R')return 2;\n\tif (s[0]=='D')return 3;\n\treturn 4;\n}\nint bfs(){\n\tQ.push(S);\n\tmemset(dis,0x3f3f3f3f,sizeof dis);\n\tdis[0]=0;\n\twhile (!Q.empty()){\n\t\tint now=Q.front();Q.pop();\n\t\tflag[now]=0;\n\t\tfor (int i=fi[now];i;i=ne[i])\n\t\t\tif (sl[i]&&dis[zz[i]]>dis[now]+w[i]){\n\t\t\t\tdis[zz[i]]=dis[now]+w[i];\n\t\t\t\tif (!flag[zz[i]]){\n\t\t\t\t\tflag[zz[i]]=1;\n\t\t\t\t\tQ.push(zz[i]);\n\t\t\t\t}\n\t\t\t}\n\t}\n\treturn dis[T]<=1e18;\n}\nint dfs(int x,int y){\n\tif (x==T)return y;\n\tint s=0,b;\n\tflag[x]=1;\n\tfor (int &i=cur[x];i;i=ne[i])\n\t\tif (sl[i]&&!flag[zz[i]]&&dis[zz[i]]==dis[x]+w[i]&&(b=min(sl[i],dfs(zz[i],min(sl[i],y))))){\n\t\t\ts+=b;y-=b;\n\t\t\tsl[i]-=b;\n\t\t\tsl[i^1]+=b;\n\t\t\tif (!y)return s;\n\t\t}\n\treturn s;\n}\nsigned main(){\n\tscanf(\"%lld\",&n);\n\tfor (int i=1;i<=n;i++)scanf(\"%lld%lld%lld\",&x[i],&y[i],&z[i]);\n\tscanf(\"%lld\",&m);\n\tfor (int i=1;i<=m;i++){\n\t\topt[i]=get();\n\t\tscanf(\"%lld%lld\",&a[i],&b[i]);\n\t}\n\tS=0;T=1;\n\tint ans=0;\n\tfor (int k=1;k<=n;k++){\n\t\tmemset(fi,0,sizeof fi);\n\t\ttot=1;\n\t\tfor (int i=1;i<=k;i++)rx[i]=ry[i]=1e9,lx[i]=ly[i]=0;\n\t\tfor (int i=1;i<=m;i++){\n\t\t\tif (opt[i]==1&&b[i]<k)lx[b[i]+1]=max(lx[b[i]+1],a[i]+1);\n\t\t\tif (opt[i]==2&&k>b[i])rx[k-b[i]]=min(rx[k-b[i]],a[i]-1);\n\t\t\tif (opt[i]==3&&b[i]<k)ly[b[i]+1]=max(ly[b[i]+1],a[i]+1);\n\t\t\tif (opt[i]==4&&k>b[i])ry[k-b[i]]=min(ry[k-b[i]],a[i]-1);\n\t\t}\n\t\tfor (int i=2;i<=k;i++)lx[i]=max(lx[i-1],lx[i]);\n\t\tfor (int i=k-1;i;i--)rx[i]=min(rx[i+1],rx[i]);\n\t\tfor (int i=2;i<=k;i++)ly[i]=max(ly[i-1],ly[i]);\n\t\tfor (int i=k-1;i;i--)ry[i]=min(ry[i+1],ry[i]);\n\t\tfor (int i=2;i<=k+1;i++)jb(S,i,1,0);\n\t\tfor (int i=2;i<=k+1;i++)jb(i+k,T,1,0);\n\t\tfor (int i=1;i<=k;i++)\n\t\t\tfor (int j=1;j<=n;j++)\n\t\t\t\tif (lx[i]<=x[j]&&rx[i]>=x[j])jb(i+1,j+2*k+1,1,0);\n\t\tfor (int i=1;i<=k;i++)\n\t\t\tfor (int j=1;j<=n;j++)\n\t\t\t\tif (ly[i]<=y[j]&&ry[i]>=y[j])jb(j+2*k+1+n,i+k+1,1,0);\n\t\tfor (int i=1;i<=n;i++)jb(i+2*k+1,i+n+2*k+1,1,-z[i]);\n\t\tint ansc=0,ansm=0;\n\t\twhile (bfs()){\n\t\t\tfor (int i=0;i<=2*k+1+2*n;i++)cur[i]=fi[i];\n\t\t\tint t=dfs(S,1e9);\n\t\t\tansm+=t;\n\t\t\tansc+=t*dis[T];\n\t\t\tfor (int i=0;i<=2*k+1+2*n;i++)flag[i]=0;\n\t\t}\n\t\tif (ansm==k)ans=max(ans,-ansc);\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n#define LL long long\n#define int long long\nconst int inf=2147483647;\nint read(){\n\tint x=0,f=1;\n\tchar ch=getchar();\n\twhile (ch<'0' || ch>'9'){\n\t\tif (ch=='-') f=-1;\n\t\tch=getchar();\n\t}\n\twhile (ch>='0' && ch<='9'){\n\t\tx=x*10+ch-'0';ch=getchar();\n\t}\n\treturn x*f;\n}\n#define N 450\n#define M 100010\n#define G 85\n#define Q 325\nstruct edge{\n\tint x,y,d,nxt;LL c;\n}E[M];\nchar op[3];\nstruct pt{\n\tint x,y;LL v;\n}p[G];\nstruct query{\n\tint op,a,b;\n}q[Q];\nint ec[N],tot;\nvoid addE(int x,int y,int d,LL c){\n\ttot++;E[tot].x=x;E[tot].y=y;E[tot].d=d;E[tot].c=c;E[tot].nxt=ec[x];ec[x]=tot;\n}\nvoid addEdge(int x,int y,int d,LL c){\n\taddE(x,y,d,c);addE(y,x,0,-c);\n}\nint n,m,S,T;\nLL f[N];int pre[N];bool vis[N];\nbool spfa(){\n\tmemset(f,-63,sizeof(f));f[S]=0;\n\tmemset(vis,0,sizeof(vis));\n\tqueue <int> q;q.push(S);\n\twhile (!q.empty()){\n\t\tint x=q.front();q.pop();vis[x]=false;\n\t\tfor (int i=ec[x];i;i=E[i].nxt){\n\t\t\tint y=E[i].y;\n\t\t\tif (E[i].d>0 && f[x]+E[i].c>f[y]){\n\t\t\t\tpre[y]=i;f[y]=f[x]+E[i].c;\n\t\t\t\tif (!vis[y]) vis[y]=true,q.push(y);\n\t\t\t} \n\t\t}\n\t}\n\tif (f[T]>0) return true;\n\telse return false;\n}\nLL ans2,ans=0;\nvoid work(){\n\tint x=T;\n\twhile (x!=S){\n\t\tans2+=E[pre[x]].c;\n\t\tE[pre[x]].d--;E[pre[x]^1].d++;x=E[pre[x]].x;\n\t}\n}\nint lx[G],rx[G],ly[G],ry[G];\nvoid solve(int k){\n\tmemset(ec,0,sizeof(ec));tot=1;\n\tfor (int i=1;i<=n;++i) addEdge(p[i].x,200+i,1,p[i].v),addEdge(200+i,100+p[i].y,1,0);\n\tfor (int i=1;i<=k;++i) lx[i]=ly[i]=1,rx[i]=ry[i]=100;\n\tfor (int i=1;i<=m;++i){\n\t\tif (q[i].op==0) lx[q[i].b+1]=max(lx[q[i].b+1],q[i].a+1);\n\t\tif (q[i].op==1 && k>q[i].b) rx[k-q[i].b]=min(rx[k-q[i].b],q[i].a-1);\n\t\tif (q[i].op==2) ly[q[i].b+1]=max(ly[q[i].b+1],q[i].a+1);\n\t\tif (q[i].op==3 && k>q[i].b) ry[k-q[i].b]=min(ry[k-q[i].b],q[i].a-1);\n\t}\n\tfor (int i=2;i<=k;++i) lx[i]=max(lx[i],lx[i-1]),ly[i]=max(ly[i],ly[i-1]);\n\tfor (int i=k-1;i;--i) rx[i]=min(rx[i],rx[i+1]),ry[i]=min(ry[i],ry[i+1]);\n\tS=200+n+2*k+1,T=S+1;\n\tfor (int i=1;i<=k;++i){\n\t\tif (lx[i]>rx[i] || ly[i]>ry[i]) return;\n\t\taddEdge(S,200+n+i,1,0);addEdge(200+n+k+i,T,1,0);\n\t\tfor (int j=lx[i];j<=rx[i];++j) addEdge(200+n+i,j,1,0);\n\t\tfor (int j=ly[i];j<=ry[i];++j) addEdge(100+j,200+n+k+i,1,0);\n\t}\n\tint cnt=0;ans2=0;\n\twhile (spfa()) cnt++,work();\n\tif (cnt!=k) return;\n\tans=max(ans,ans2);\n}\nsigned main(){\n\tn=read();for (int i=1;i<=n;++i) p[i].x=read(),p[i].y=read(),p[i].v=read();\n\tm=read();\n\tfor (int i=1;i<=m;++i){\n\t\tscanf(\"%s\",op);\n\t\tq[i].a=read();q[i].b=read();\n\t\tif (op[0]=='L') q[i].op=0;\n\t\tif (op[0]=='R') q[i].op=1;\n\t\tif (op[0]=='D') q[i].op=2;\n\t\tif (op[0]=='U') q[i].op=3;\n\t}\t\n\tfor (int i=1;i<=n;++i) solve(i);\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define re register\nstruct eg\n{\n\tint to,nx,v;\n\tlong long c;\n}e[200100];\nint cnt,q[200100],la[200100],cur[200100],s,t,N;\nlong long ans;\nint num,nm;\nbool bo[200100];\nlong long d[200100];\nunsigned short hd,ta;\ninline void addE(re int a,re int b,re int c,re long long d)\n{\n\te[++cnt]=(eg){b,la[a],c,d};la[a]=cnt;\n\te[++cnt]=(eg){a,la[b],0,-d};la[b]=cnt;\n}\ninline void addE1(re int a,re int b,re int mi,re int mx)\n{\n\tif(mx<mi){nm=1<<30;return;}\n\tmi=std::max(mi,0);nm+=mi;addE(s,b,mi,0);addE(a,t,mi,0);addE(a,b,mx-mi,0);\n}\nbool bfs()\n{\n\tq[0]=s;ta=1;\n\tfor(re int i=1;i<=N;i++)d[i]=-1ll<<60,cur[i]=la[i],bo[i]=0;\n\td[s]=0;bo[s]=1;\n\tfor(hd=0;hd!=ta;hd++)\n\t{\n\t\tre int x=q[hd];//printf(\"*d*%d %lld\\n\",x,d[x]);\n\t\tfor(re int j=la[x];j;j=e[j].nx)if(e[j].v&&d[e[j].to]<d[x]+e[j].c)\n\t\t{\n\t\t\td[e[j].to]=d[x]+e[j].c;\n\t\t\tif(!bo[e[j].to])q[ta++]=e[j].to;\n\t\t}\n\t\tbo[x]=0;\n\t}\n\treturn (d[t]>-1ll<<60);\n}int dfs(re int a,re int fl)\n{\n\tif(a==t)return fl;\n\tbo[a]=1;\n\tre int fi=fl;\n\tfor(re int&i=cur[a];i;i=e[i].nx)if(e[i].v&&!bo[e[i].to]&&d[e[i].to]==d[a]+e[i].c)\n\t{\n\t\tre int t=dfs(e[i].to,std::min(e[i].v,fi));\n\t\tfi-=t;e[i].v-=t;e[i^1].v+=t;\n\t\tif(!fi)return fl;\n\t}\n\treturn fl-fi;\n}\nvoid dinic()\n{\n\twhile(bfs())\n\t{\n\t\tre int x=dfs(s,1<<30);\n\t\tans+=x*d[t];num+=x;\n\t}\n}\nint x[110],y[110],l1[410],l2[410],r1[410],r2[410];\nlong long c[110];\nchar ss[110];\nint main()\n{\n\tre int n,m,a,b;\n\tscanf(\"%d\",&n);\n\tre long long as=0;\n\tfor(re int i=1;i<=n;i++)scanf(\"%d%d%lld\",&x[i],&y[i],&c[i]);\n\tfor(re int i=1;i<=100;i++)l1[i]=l2[i]=r1[i]=r2[i]=n;\n\tscanf(\"%d\",&m);\n\tfor(re int i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%s%d%d\",ss,&a,&b);\n\t\tswitch(ss[0])\n\t\t{\n\t\t\tcase 'L':l1[a]=std::min(l1[a],b);break;\n\t\t\tcase 'R':l2[a]=std::min(l2[a],b);break;\n\t\t\tcase 'D':r1[a]=std::min(r1[a],b);break;\n\t\t\tcase 'U':r2[a]=std::min(r2[a],b);break;\n\t\t}\n\t}\n\tfor(re int i=2;i<=100;i++)l2[a]=std::min(l2[a],l2[a-1]),r2[a]=std::min(r2[a],r2[a-1]);\n\tfor(re int i=99;i;i--)l1[a]=std::min(l1[a],l1[a+1]),r1[a]=std::min(r1[a],r1[a+1]);\n\ts=203;t=204;N=204;\n\tfor(re int i=1;i<=n;i++)\n\t{\n\t\tcnt=1;nm=0;ans=0;num=0;\n\t\tfor(re int j=1;j<=N;j++)la[j]=0;\n\t\tfor(re int j=1;j<=n;j++)addE(x[j],100+y[j],1,c[j]);\n\t\tfor(re int j=1;j<100;j++)\n\t\t{\n\t\t\taddE1(j,j+1,i-l1[j],l2[j+1]);\n\t\t\taddE1(j+101,j+100,i-r1[j],r2[j+1]);\n\t\t}\n\t\taddE(201,1,1<<30,0);addE(101,202,1<<30,0);\n\t\taddE(s,201,i,0);addE(202,t,i,0);nm+=i;\n\t\tif(nm!=(1<<30))dinic();\n\t\tif(num!=nm)break;\n\t\tas=std::max(as,ans);\n\t}\n\tprintf(\"%lld\\n\",as);\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * This line was copied from template\n * This is esol.cpp\n * \n * @author: Nikolay Kalinin\n * @date: Sat, 16 Mar 2019 16:20:18 +0300\n */\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n    #define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing D = double;\nusing uint = unsigned int;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nconst int maxn = 105;\nconst ll inf = 2e18;\nconst int MAXC = maxn;\nconst int infk = maxn;\n\nint x[maxn], y[maxn];\nll v[maxn];\nint n, m;\nint max_down[maxn], max_left[maxn], max_right[maxn], max_up[maxn];\nvector<pair<int, ll>> gr[maxn];\nbool inq[maxn];\nqueue<int> q;\nll d[maxn];\nint curx[maxn], cury[maxn];\nbool taken[maxn];\nint prv[maxn];\nchar s_tmp[5];\n\nbool isok1(int x, int y)\n{\n    for (int i = 0; i < MAXC; i++)\n    {\n        curx[i] = 0;\n        cury[i] = 0;\n    }\n    for (int i = 0; i < n; i++) if ((taken[i] && i != y) || i == x)\n    {\n        curx[::x[i]]++;\n        cury[::y[i]]++;\n    }\n    int cursum = 0;\n    for (int i = 0; i < MAXC; i++)\n    {\n        cursum += curx[i];\n        if (cursum > max_left[i]) return false;\n    }\n    cursum = 0;\n    for (int i = 0; i < MAXC; i++)\n    {\n        cursum += cury[i];\n        if (cursum > max_down[i]) return false;\n    }\n    return true;\n}\n\nbool isok2(int x, int y)\n{\n    for (int i = 0; i < MAXC; i++)\n    {\n        curx[i] = 0;\n        cury[i] = 0;\n    }\n    for (int i = 0; i < n; i++) if ((taken[i] && i != y) || i == x)\n    {\n        curx[::x[i]]++;\n        cury[::y[i]]++;\n    }\n    int cursum = 0;\n    for (int i = MAXC -1; i >= 0; i--)\n    {\n        cursum += curx[i];\n        if (cursum > max_right[i]) return false;\n    }\n    cursum = 0;\n    for (int i = MAXC -1; i >= 0; i--)\n    {\n        cursum += cury[i];\n        if (cursum > max_up[i]) return false;\n    }\n    return true;\n}\n\nvoid addedge(int a, int b, ll c)\n{\n//     cout << \"addedge \" << a << ' ' << b << ' ' << c << endl;\n    gr[a].pb({b, c});\n}\n\nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++)\n    {\n        scanf(\"%d%d%lld\", &x[i], &y[i], &v[i]);\n    }\n    for (int i = 0; i < MAXC; i++)\n    {\n        max_left[i] = infk;\n        max_right[i] = infk;\n        max_down[i] = infk;\n        max_up[i] = infk;\n    }\n    scanf(\"%d\", &m);\n    for (int i = 0; i < m; i++)\n    {\n        int a, b;\n        scanf(\"%s%d%d\", s_tmp, &a, &b);\n        if (s_tmp[0] == 'L') max_left[a] = min(max_left[a], b);\n        if (s_tmp[0] == 'R') max_right[a] = min(max_right[a], b);\n        if (s_tmp[0] == 'U') max_up[a] = min(max_up[a], b);\n        if (s_tmp[0] == 'D') max_down[a] = min(max_down[a], b);\n    }\n    while (true)\n    {\n//         for (int i =0 ; i < n; i++) cout << taken[i];\n//         cout << endl;\n        for (int i = 0; i < n + 2; i++) gr[i].clear();\n        for (int i = 0; i < n; i++) if (!taken[i])\n        {\n            if (isok1(i, -1)) addedge(n, i, 0);\n            if (isok2(i, -1)) addedge(i, n + 1, -v[i]);\n            for (int j = 0; j < n; j++) if (taken[j])\n            {\n                if (isok1(i, j)) addedge(j, i, v[j]);\n                if (isok2(i, j)) addedge(i, j, -v[i]);\n            }\n        }\n        for (int i = 0; i < n + 2; i++) d[i] = inf;\n        d[n] = 0;\n        while (!q.empty()) q.pop();\n        q.push(n);\n        for (int i = 0; i < n + 2; i++) inq[i] = false;\n        inq[n] = true;\n        while (!q.empty())\n        {\n            int cur = q.front();\n            q.pop();\n            inq[cur] = false;\n//             cout << cur << ' ' << d[cur] << endl;\n            for (auto t : gr[cur]) if (d[t.fi] > d[cur] + t.se)\n            {\n                d[t.fi] = d[cur] + t.se;\n                prv[t.fi] = cur;\n                if (!inq[t.fi])\n                {\n                    inq[t.fi] = true;\n                    q.push(t.fi);\n                }\n            }\n        }\n//         cout << d[n + 1] << endl;\n        if (d[n + 1] > inf / 2) break;\n        int cur = n + 1;\n        while (cur != n)\n        {\n//             cout << \"cur = \" << cur << endl;\n            if (cur != n + 1)\n            {\n                taken[cur] = !taken[cur];\n            }\n            cur = prv[cur];\n        }\n    }\n    ll sum = 0;\n    for (int i = 0; i < n; i++) if (taken[i]) sum += v[i];\n    cout << sum << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <list>\n#include <time.h>\n#include <math.h>\n#include <random>\n#include <deque>\n#include <queue>\n#include <cassert>\n#include <unordered_map>\n#include <unordered_set>\n#include <iomanip>\n#include <bitset>\n#include <sstream>\n#include <chrono>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef __float128 dbl;\nconst int INF = 1.01e9;\n\n__float128 fabs(__float128 x)\n{\n  if (x < 0) return -x;\n  return x;\n}\n \nconst __float128 EPS = 1e-25;\nbool eq(__float128 x, __float128 y) {\n    return fabs(x - y) < EPS;\n}\nbool ls(__float128 x, __float128 y) {\n    return x < y && !eq(x, y);\n}\n \nvector<__float128> simplex(vector<vector<__float128> > a) {\n    int n = a.size() - 1;\n    int m = a[0].size() - 1;\n    vector<int> left(n + 1), up(m + 1);\n    iota(up.begin(), up.end(), 0);\n    iota(left.begin(), left.end(), m);\n    auto pivot = [&](int x, int y) {\n        swap(left[x], up[y]);\n        __float128 k = a[x][y];\n        a[x][y] = 1;\n        vector<int> vct;\n        for (int j = 0; j <= m; j++) {\n            a[x][j] /= k;\n            if (!eq(a[x][j], 0)) vct.push_back(j);\n        }\n        for (int i = 0; i <= n; i++) {\n            if (eq(a[i][y], 0) || i == x) continue;\n            k = a[i][y];\n            a[i][y] = 0;\n            for (int j : vct) a[i][j] -= k * a[x][j];\n        }\n    };\n    while (1) {\n        int x = -1;\n        for (int i = 1; i <= n; i++) if (ls(a[i][0], 0) && (x == -1 || a[i][0] < a[x][0])) x = i;\n        if (x == -1) break;\n        int y = -1;\n        for (int j = 1; j <= m; j++) if (ls(a[x][j], 0) && (y == -1 || a[x][j] < a[x][y])) y = j;\n        if (y == -1) assert(0); // infeasible\n        pivot(x, y);\n    }\n    while (1) {\n        int y = -1;\n        for (int j = 1; j <= m; j++) if (ls(0, a[0][j]) && (y == -1 || a[0][j] > a[0][y])) y = j;\n        if (y == -1) break;\n        int x = -1;\n        for (int i = 1; i <= n; i++) if (ls(0, a[i][y]) && (x == -1 || a[i][0] / a[i][y] < a[x][0] / a[x][y])) x = i;\n        if (x == -1) assert(0); // unbounded\n        pivot(x, y);\n    }\n    vector<__float128> ans(m + 1);\n    for (int i = 1; i <= n; i++) if (left[i] <= m) ans[left[i]] = a[i][0];\n    ans[0] = -a[0][0];\n    return ans;\n}\n\n#ifdef ONPC\n  mt19937 rnd(228);\n#else\n  mt19937 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\n#endif\n\nint main()\n{\n#ifdef ONPC\n  freopen(\"a.in\", \"r\", stdin);\n#endif\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector <int> x(n), y(n);\n  vector <ll> ok;\n  vector <__float128> v;\n  vector <pair <ll, int> > e;\n  for (int i = 0; i < n; i++)\n  {\n    cin >> x[i] >> y[i];\n    ll x;\n    cin >> x;\n    ok.push_back(x);\n    v.push_back(x);\n    e.push_back({x, i});\n  }\n  v.insert(v.begin(), 0);\n  int m;\n  cin >> m;\n  vector <vector <__float128> > mat;\n  mat.push_back(v);\n  for (int i = 0; i < n; i++)\n  {\n    vector <__float128> kek(n + 1);\n    kek[0] = kek[i + 1] = 1;\n    mat.push_back(kek);\n  }\n  vector <vector <int> > simp;\n  for (int i = 0; i < m; i++)\n  {\n    char c;\n    cin >> c;\n    int a;\n    int b;\n    cin >> a >> b;\n    vector <__float128> arr = {(__float128) b};\n    vector <int> kek = {b};\n    for (int j = 0; j < n; j++)\n    {\n      int grab = 0;\n      if (c == 'L' && x[j] <= a) grab = 1;\n      if (c == 'R' && x[j] >= a) grab = 1;\n      if (c == 'D' && y[j] <= a) grab = 1;\n      if (c == 'U' && y[j] >= a) grab = 1;\n      arr.push_back(grab);\n      kek.push_back(grab);\n    }\n    mat.push_back(arr);\n    simp.push_back(kek);\n  }\n  auto good = [&] (vector <int> grab)\n  {\n    for (auto c : simp)\n    {\n      int sum = 0;\n      for (int i = 1; i <= n; i++) sum += grab[i - 1] * c[i];\n      if (sum > c[0])\n      {\n        return false;\n      }\n    }\n    return true;\n  };\n  auto f = [&] (vector <int> grab)\n  {\n    ll sum = 0;\n    for (int i = 0; i < n; i++)\n    {\n      if (grab[i]) sum += ok[i];\n    }\n    return sum;\n  };\n  vector <int> grab;\n  for (int i = 0; i < n; i++) grab.push_back(0);\n  cout.precision(20);\n  auto solve = [&] ()\n  {\n    auto ret = simplex(mat);\n    sort(e.begin(), e.end());\n    vector <int> me(n);\n    int x = -1;\n    for (int i = 1; i <= n; i++)\n    {\n      if (grab[i - 1]) continue;\n      grab[i - 1] = true;\n      if (!good(grab))\n      {\n        grab[i - 1] = false;\n        continue;\n      }\n      grab[i - 1] = false;\n      if (x == -1 || ret[i] * ret[i] * ok[i - 1] > ret[x] * ret[x] * ok[x - 1])\n      {\n        x = i;\n      }\n    }\n    if (x == -1 || ret[x] < EPS) return 0ll;\n    x--;\n    me[x] = true;\n    grab[x] = true;\n    if (!good(grab)) grab[x] = false, me[x] = false;\n    int kekos = 0;\n    for (auto &c : mat)\n    {\n      kekos++;\n      if (kekos > n + 1)\n      for (int i = 1; i <= n; i++)\n      {\n        if (me[i - 1] && c[i] > EPS) c[i]--, c[0]--;\n      }\n    }\n    for (int i = 1; i <= n; i++)\n    {\n      if (me[i - 1])\n      {\n        mat[i][0] = 0;\n      }\n    }\n    return ok[x];\n  };\n  ll ans = 0;\n  while (ll t = solve())\n  {\n    ans += t;\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\ntypedef long double T; // long double, Rational, double + mod<P>...\ntypedef vector<T> vd;\ntypedef vector<vd> vvd;\n\nconst T eps = 1e-20, inf = 1/.0;\n#define MP make_pair\n#define ltj(X) if(s == -1 || MP(X[j],N[j]) < MP(X[s],N[s])) s=j\n\nstruct LPSolver {\n\tint m, n;\n\tvi N, B;\n\tvvd D;\n\n\tLPSolver(const vvd& A, const vd& b, const vd& c) :\n\t\tm(sz(b)), n(sz(c)), N(n+1), B(m), D(m+2, vd(n+2)) {\n\t\t\trep(i,0,m) rep(j,0,n) D[i][j] = A[i][j];\n\t\t\trep(i,0,m) { B[i] = n+i; D[i][n] = -1; D[i][n+1] = b[i];}\n\t\t\trep(j,0,n) { N[j] = j; D[m][j] = -c[j]; }\n\t\t\tN[n] = -1; D[m+1][n] = 1;\n\t\t}\n\n\tvoid pivot(int r, int s) {\n\t\tT *a = D[r].data(), inv = 1 / a[s];\n\t\trep(i,0,m+2) if (i != r && abs(D[i][s]) > eps) {\n\t\t\tT *b = D[i].data(), inv2 = b[s] * inv;\n\t\t\trep(j,0,n+2) b[j] -= a[j] * inv2;\n\t\t\tb[s] = a[s] * inv2;\n\t\t}\n\t\trep(j,0,n+2) if (j != s) D[r][j] *= inv;\n\t\trep(i,0,m+2) if (i != r) D[i][s] *= -inv;\n\t\tD[r][s] = inv;\n\t\tswap(B[r], N[s]);\n\t}\n\n\tbool simplex(int phase) {\n\t\tint x = m + phase - 1;\n\t\tfor (;;) {\n\t\t\tint s = -1;\n\t\t\trep(j,0,n+1) if (N[j] != -phase) ltj(D[x]);\n\t\t\tif (D[x][s] >= -eps) return true;\n\t\t\tint r = -1;\n\t\t\trep(i,0,m) {\n\t\t\t\tif (D[i][s] <= eps) continue;\n\t\t\t\tif (r == -1 || MP(D[i][n+1] / D[i][s], B[i])\n\t\t\t\t             < MP(D[r][n+1] / D[r][s], B[r])) r = i;\n\t\t\t}\n\t\t\tif (r == -1) return false;\n\t\t\tpivot(r, s);\n\t\t}\n\t}\n\n\tT solve(vd &x) {\n\t\tint r = 0;\n\t\trep(i,1,m) if (D[i][n+1] < D[r][n+1]) r = i;\n\t\tif (D[r][n+1] < -eps) {\n\t\t\tpivot(r, n);\n\t\t\tif (!simplex(2) || D[m+1][n+1] < -eps) return -inf;\n\t\t\trep(i,0,m) if (B[i] == -1) {\n\t\t\t\tint s = 0;\n\t\t\t\trep(j,1,n+1) ltj(D[i]);\n\t\t\t\tpivot(i, s);\n\t\t\t}\n\t\t}\n\t\tbool ok = simplex(1); x = vd(n);\n\t\trep(i,0,m) if (B[i] < n) x[B[i]] = D[i][n+1];\n\t\treturn ok ? D[m][n+1] : inf;\n\t}\n};\n\nint n, m, x[105], y[105];\nll v[105];\n\nvvd A, A1;\nvd t, b, c, b1, c1, xx;\n\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> x[i] >> y[i] >> v[i];\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tt.clear();\n\t\tt.resize(n);\n\t\tt[i] = -1;\n\t\tA.push_back(t);\n\t\tb.push_back(0);\t\n\t\tt.clear();\n\t\tt.resize(n);\n\t\tt[i] = 1;\n\t\tA.push_back(t);\n\t\tb.push_back(1);\t\t\n\t}\n\tcin >> m;\n\tfor (int i = 0; i < m; ++i) {\n\t\tt.clear();\n\t\tt.resize(n);\n\t\tchar f;\n\t\tint a, bb;\n\t\tcin >> f >> a >> bb;\n\t\tif (f == 'L') {\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\tif (x[j] <= a)\n\t\t\t\t\tt[j] = 1;\n\t\t} if (f == 'R') {\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\tif (x[j] >= a)\n\t\t\t\t\tt[j] = 1;\n\t\t} if (f == 'U') {\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\tif (y[j] >= a)\n\t\t\t\t\tt[j] = 1;\n\t\t} if (f == 'D') {\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\tif (y[j] <= a)\n\t\t\t\t\tt[j] = 1;\n\t\t}\n\t\tA.push_back(t);\n\t\tb.push_back(bb);\n\t}\n\tc.resize(n);\n\tfor (int i = 0; i < n; ++i)\n\t\tc[i] = v[i];\n\tll ans = 0;\n\tfor (int i = 0; i <= n; ++i) {\n\t\tA1 = A, b1 = b, c1 = c;\n\t\tfor (int j = 0; j < n; ++j)\n\t\t\tt[j] = 1;\n\t\tA1.push_back(t);\n\t\tb1.push_back(i+20*eps);\n\t\tfor (int j = 0; j < n; ++j)\n\t\t\tt[j] = -1;\n\t\tA1.push_back(t);\n\t\tb1.push_back(-i+20*eps);\n\t\tans = max(ans, (ll)lround(LPSolver(A1, b1, c1).solve(xx)));\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1145141919810\n#define ll long long\n#define mem(x,y) memset(x,y,sizeof x)\nusing namespace std;\nstruct edge{\n\tint t,next;\n\tll cst;\n\tint rev;\n};\nvector<edge>G[110000];\nvoid add(int f,int t,int next,ll cst){\n\tG[f].push_back((edge){t,next,cst,(int)G[t].size()});\n\tG[t].push_back((edge){f,0,-cst,(int)G[f].size()-1});\n}\nbool used[110000];\nll dis[110000];\nint prv[110000],pre[110000],S,T;\nbool SPFA(){\n\tfor(int i=0;i<=T;i++)dis[i]=-inf;\n\tqueue<int>q;\n\tq.push(0);\n\tdis[0]=0;\n\tused[0]=true;\n\twhile(!q.empty()){\n\t\tint x=q.front();\n\t\tq.pop();\n\t\tused[x]=false;\n\t\tfor(int i=0;i<(int)G[x].size();i++){\n\t\t\tedge &e=G[x][i];\n\t\t\tif(e.next && dis[x]+e.cst>dis[e.t]){\n\t\t\t\tdis[e.t]=dis[x]+e.cst;\n\t\t\t\tprv[e.t]=x;\n\t\t\t\tpre[e.t]=i;\n\t\t\t\tif(!used[e.t]) used[e.t]=1,q.push(e.t);\n\t\t\t}\n\t\t}\n\t}\n\treturn (dis[T]!=-inf);\n}\nint n,m,lx[210],rx[210],ly[210],ry[210],x[210],y[210];\nll v[210],ans;\nll MCMF(){\n\tll nowans=0;\n\twhile(SPFA()){\n\t\tint nowp=T;\n\t\twhile(nowp){\n\t\t\tedge &e=G[prv[nowp]][pre[nowp]];\n\t\t\te.next--;\n\t\t\tG[e.t][e.rev].next++;\n\t\t\tnowp=prv[nowp];\n\t\t}\n\t\tnowans+=dis[T];\n\t}\n\treturn nowans;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d%d%lld\",&x[i],&y[i],&v[i]);\n\tscanf(\"%d\",&m);\n\tfor(int i=1;i<=n;i++) rx[i]=ry[i]=110;\n\tfor(int i=1;i<=m;i++){\n\t\tint a,b;char cc;\n\t\tscanf(\"%s%d%d\",&cc,&a,&b);\n\t\tif(cc=='L')lx[b+1]=max(lx[b+1],a);\n\t\tif(cc=='R')rx[b+1]=min(rx[b+1],a);\n\t\tif(cc=='D')ly[b+1]=max(ly[b+1],a);\n\t\tif(cc=='U')ry[b+1]=min(ry[b+1],a);\n\t}\n\tfor(int i=2;i<=n;i++) lx[i]=max(lx[i],lx[i-1]),rx[i]=min(rx[i],rx[i-1]),ly[i]=max(ly[i],ly[i-1]),ry[i]=min(ry[i],ry[i-1]);\n\tfor(int i=1;i<=n;i++){\n\t\tT=n+n+i+i+1;mem(G,0);\n\t\tfor(int j=1;j<=i;j++) add(0,n+n+j,1,0),add(n+n+i+j,T,1,0);\n\t\tfor(int j=1;j<=i;j++){\n\t\t\tfor(int k=1;k<=n;k++){\n\t\t\t\tif(lx[j]<x[k]&&x[k]<rx[i+1-j]) add(n+n+j,k,1,0);\n\t\t\t\tif(ly[j]<y[k]&&y[k]<ry[i+1-j]) add(n+k,n+n+i+j,1,0);\n\t\t\t}\n\t\t}\n\t\tfor(int j=1;j<=n;j++) add(j,n+j,1,v[j]);\n\t\tans=max(ans,MCMF());\n\t}\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N = 410;\nconst int M = 100010;\n\nstruct edge {\n    int to, next, w; LL c;\n} e[M];\n\nint head[N], ecnt = 1, vis[N], cur[N]; LL dis[N];\n\ninline void adde(int from, int to, int f, LL c) {\n    e[++ecnt] = (edge){to, head[from], f, c}, head[from] = ecnt;\n    e[++ecnt] = (edge){from, head[to], 0, -c}, head[to] = ecnt;\n}\n\ninline bool SPFA(int s, int t) {\n    memset(vis, 0, sizeof(vis)), memset(dis, 0x3f, sizeof(dis)), dis[t] = 0, vis[t] = 1;\n    deque<int> q; q.push_back(t);\n    while (!q.empty()) {\n        int u = q.front(); q.pop_front(), vis[u] = 0;\n        for (int i = head[u];i;i = e[i].next)\n            if (e[i ^ 1].w && dis[e[i].to] > dis[u] - e[i].c) {\n                dis[e[i].to] = dis[u] - e[i].c;\n                if (!vis[e[i].to]) {\n                    vis[e[i].to] = 1;\n                    if (!q.empty() && dis[e[i].to] < dis[q.front()]) q.push_front(e[i].to);\n                    else q.push_back(e[i].to);\n                }\n            }\n    }\n    return dis[s] < 1e17;\n}\n\nLL MCMF;\n\nint DFS(int u, int f, int t) {\n    vis[u] = 1; int res = 0;\n    if (u == t || !f) return f;\n    for (int &i = cur[u], tmp; i; i = e[i].next)\n        if (!vis[e[i].to] && e[i].w && dis[u] - e[i].c == dis[e[i].to] && (tmp = DFS(e[i].to, min(f, e[i].w), t))) {\n            f -= tmp, res += tmp, e[i].w -= tmp, e[i ^ 1].w += tmp, MCMF += (LL)tmp * e[i].c;\n            if (!f) break;\n        }\n    return res;\n}\n\ninline int Dinic(int s, int t) {\n    MCMF = 0; int f = 0;\n    while (SPFA(s, t)) memcpy(cur, head, sizeof(head)), f += DFS(s, 1e9, t);\n    return f;\n}\n\nint x[N], y[N]; char s[N][5]; int a[N], b[N]; LL c[N];\n\nint main() {\n    int n; scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i++) scanf(\"%d%d%lld\", &x[i], &y[i], &c[i]);\n    int m; scanf(\"%d\", &m);\n    for (int i = 1; i <= m; i++) scanf(\"%s%d%d\", s[i] + 1, &a[i], &b[i]);\n    LL res = 0;\n    for (int i = 1; i <= n; i++) {\n        memset(head, 0, sizeof(head)), ecnt = 1;\n        static int xl[N], xr[N], yl[N], yr[N]; \n        memset(xl, 0, sizeof(xl)), memset(yl, 0, sizeof(yl)), memset(xr, 0x3f, sizeof(xr)), memset(yr, 0x3f, sizeof(yr));\n        for (int j = 1; j <= m; j++) if (b[j] < i) {\n            if (s[j][1] == 'L') for (int k = b[j] + 1; k <= i; k++) xl[k] = max(xl[k], a[j] + 1);\n            if (s[j][1] == 'R') for (int k = 1; k <= i - b[j]; k++) xr[k] = min(xr[k], a[j] - 1);\n            if (s[j][1] == 'D') for (int k = b[j] + 1; k <= i; k++) yl[k] = max(yl[k], a[j] + 1);\n            if (s[j][1] == 'U') for (int k = 1; k <= i - b[j]; k++) yr[k] = min(yr[k], a[j] - 1);\n        }\n        int s = 2 * n + 2 * i + 1, t = s + 1;\n        for (int j = 1; j <= i; j++) adde(s, j, 1, 0), adde(j + i + 2 * n, t, 1, 0);\n        for (int j = 1; j <= n; j++) adde(i + j, i + j + n, 1, -c[j]);\n        for (int j = 1; j <= i; j++) \n            for (int k = 1; k <= n; k++) if (xl[j] <= x[k] && x[k] <= xr[j]) adde(j, k + i, 1, 0);\n        for (int j = 1; j <= i; j++)\n            for (int k = 1; k <= n; k++) if (yl[j] <= y[k] && y[k] <= yr[j]) adde(k + i + n, j + i + 2 * n, 1, 0);\n        if (Dinic(s, t) == i) res = max(res, -MCMF);\n    }\n    printf(\"%lld\\n\", res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef HOME\n#define db(x) cerr << #x << \" = \" << x << endl\n#define db3(x, y, z) cerr << \"(\" << #x << \", \" << #y << \", \" << #z << \") = (\" << x << \", \" << y << \", \" << z << \")\" << endl\n#define db2(x, y) cerr << \"(\" << #x << \", \" << #y << \") = (\" << x << \", \" << y << \")\" << endl\n#define dbv(a) cerr << #a << \" = \"; for (auto xxx: a) cerr << xxx  << \" \"; cerr << endl\n#else\n#define db(x) ;\n#define db3(x, y, z) ;\n#define db2(x, y) ;\n#define dbv(a) ;\n#endif\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double dbl;\n\n\nconst int INF = 1.01e9;\nconst int MOD = (int)1e9 + 7;\n\nstruct Item {\n    int x, y;\n    ll val;\n};\n\nstruct Cond {\n    char type;\n    int a, b;\n\n    bool cover(Item it) {\n        if (type == 'L') {\n            return it.x <= a;\n        }\n        if (type == 'R') {\n            return it.x >= a;\n        }\n        if (type == 'D') {\n            return it.y <= a;\n        }\n        if (type == 'U') {\n            return it.y >= a;\n        }\n        assert(0);\n    }\n};\n\nll slow(vector<Item> a, vector<Cond> b) {\n    int n = a.size(), m = b.size();\n    ll ans = 0;\n    for (int mask = 0; mask < (1 << n); mask++) {\n        vector<int> cnt(m);\n        ll sum = 0;\n        for (int i = 0; i < n; i++) {\n            if (!(mask & (1 << i))) continue;\n            sum += a[i].val;\n            for (int j = 0; j < m; j++) {\n                if (b[j].cover(a[i])) {\n                    cnt[j]++;\n                }\n            }\n        }\n        bool bad = 0;\n        for (int i = 0; i < m; i++) {\n            if (cnt[i] > b[i].b) {\n                bad = 1;\n            }\n        }\n        if (bad) continue;\n        ans = max(ans, sum);\n    }\n    return ans;\n}\n\n\nbool eq(dbl a, dbl b) {\n    return fabs(a - b) < 1e-9;\n}\n\nbool ls(dbl a, dbl b) {\n    return !eq(a, b) && a < b;\n}\n\nvector<dbl> simplex(vector<vector<dbl> > a) {\n    int n = a.size() - 1;\n    int m = a[0].size() - 1;\n    vector<int> left(n + 1), up(m + 1);\n    iota(up.begin(), up.end(), 0);\n    iota(left.begin(), left.end(), m);\n    auto pivot = [&](int x, int y) {\n        swap(left[x], up[y]);\n        dbl k = a[x][y];\n        a[x][y] = 1;\n        vector<int> vct;\n        for (int j = 0; j <= m; j++) {\n            a[x][j] /= k;\n            if (!eq(a[x][j], 0)) vct.push_back(j);\n        }\n        for (int i = 0; i <= n; i++) {\n            if (eq(a[i][y], 0) || i == x) continue;\n            k = a[i][y];\n            a[i][y] = 0;\n            for (int j : vct) a[i][j] -= k * a[x][j];\n        }\n    };\n    while (1) {\n        int x = -1;\n        for (int i = 1; i <= n; i++) if (ls(a[i][0], 0) && (x == -1 || a[i][0] < a[x][0])) x = i;\n        if (x == -1) break;\n        int y = -1;\n        for (int j = 1; j <= m; j++) if (ls(a[x][j], 0) && (y == -1 || a[x][j] < a[x][y])) y = j;\n        if (y == -1) assert(0); // infeasible\n        pivot(x, y);\n    }\n    while (1) {\n        int y = -1;\n        for (int j = 1; j <= m; j++) if (ls(0, a[0][j]) && (y == -1 || a[0][j] > a[0][y])) y = j;\n        if (y == -1) break;\n        int x = -1;\n        for (int i = 1; i <= n; i++) if (ls(0, a[i][y]) && (x == -1 || a[i][0] / a[i][y] < a[x][0] / a[x][y])) x = i;\n        if (x == -1) assert(0); // unbounded\n        pivot(x, y);\n    }\n    vector<dbl> ans(m + 1);\n    for (int i = 1; i <= n; i++) if (left[i] <= m) ans[left[i]] = a[i][0];\n    ans[0] = -a[0][0];\n    return ans;\n}\n// j=1..m: x[j]>=0\n// i=1..n: sum(j=1..m) A[i][j]*x[j] <= A[i][0]\n// max sum(j=1..m) A[0][j]*x[j]\n// res[0] is answer\n// res[1..m] is certificate\n\nll fast(vector<Item> a, vector<Cond> b) {\n    int n = a.size(), m = b.size();\n    vector<vector<dbl>> c(m + 1, vector<dbl>(n + 1));\n    for (int i = 0; i < n; i++) {\n        c[0][1 + i] = a[i].val;\n    }\n    for (int i = 0; i < m; i++) {\n        c[1 + i][0] = b[i].b;\n        for (int j = 0; j < n; j++) {\n            if (b[i].cover(a[j])) {\n                c[1 + i][1 + j] = 1;\n            }\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        vector<dbl> cur(n + 1);\n        cur[0] = 1;\n        cur[1 + i] = 1;\n        c.push_back(cur);\n    }\n    auto res = simplex(c);\n    return (ll)round(res[0]);\n}\n\nvoid stress() {\n    for (int it =0;; it++) {\n        mt19937_64 rnd(it);\n        db(it);\n\n\n        int n = rnd() % 10 + 1;\n        vector<Item> a(n);\n        for (int i =0 ; i < n; i++) {\n            a[i].x = rnd() % 100;\n            a[i].y = rnd() % 100;\n            a[i].val = rnd() % (ll)1e15;\n        }\n        int m = rnd() % 10 + 1;\n        vector<Cond> b(m);\n        for (int i = 0; i < m; i++) {\n            b[i].a = rnd() % 100;\n            b[i].b = rnd() % (n + 1);\n            b[i].type = \"ULDR\"[rnd() % 4];\n        }\n\n        auto ans1 = fast(a, b);\n        auto ans2 = slow(a, b);\n        if (ans1 != ans2) {\n            cout << ans1 << \" instead of \" << ans2 << endl;\n            exit(0);\n        }\n    }\n}\n\nint main() {\n#ifdef HOME\n    assert(freopen(\"in\", \"r\", stdin));\n#endif\n//    stress();\n\n    int n;\n    while (scanf(\"%d\", &n) == 1) {\n        vector<Item> a(n);\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d%d%lld\", &a[i].x, &a[i].y, &a[i].val);\n        }\n        int m;\n        scanf(\"%d\", &m);\n        vector<Cond> b(m);\n        for (int i = 0; i < m; i++) {\n            scanf(\" %c%d%d\", &b[i].type, &b[i].a, &b[i].b);\n        }\n\n//        printf(\"%lld\\n\", slow(a, b));\n        printf(\"%lld\\n\", fast(a, b));\n    }\n\n#ifdef HOME\n    cerr << \"time: \" << clock() * 1.0 / CLOCKS_PER_SEC << endl;\n#endif\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n\n#define fo(i,j,l) for(int i=j;i<=l;++i)\n#define fd(i,j,l) for(int i=j;i>=l;--i)\n#define eps 2e-1\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double db;\nconst ll N=1000;\nconst db sj=5e-20,op=1e7;\n\nint f1[N],f2[N];\nint s1[N],s2[N];\nint w[N];\nll x[N],y[N],v[N];\n\nint n,m,oo,a,b,o2;\ndb c[N],s[N][N];\nint bh[N];\ndb d[N];\nint dl[N];\nint g,gs;\ndb ans=0;\nll da=0;\n\ninline db iabs(db gg)\n{return (gg<0)?(-gg):gg;}\n\ninline void trans(int h,int k)\n{\n\tint u=bh[h]; bh[h]=k;\n\tdb xs=-s[h][k];\n\ts[h][k]=0; s[h][u]=-1;\n\tfo(i,1,g)s[h][i]=s[h][i]/xs;\n\tc[h]=c[h]/xs;\n\tfo(i,1,gs)if(i!=h&&s[i][k]!=0){\n\t\tfo(l,1,g)s[i][l]=s[i][l]+s[i][k]*s[h][l];\n\t\tc[i]=c[i]+c[h]*s[i][k];\n\t\ts[i][k]=0;\n\t}\n\tfo(i,1,g)d[i]=d[i]+d[k]*s[h][i];\n\tans=ans+d[k]*c[h];\n\td[k]=0;\n}\n\ninline int find()\n{\n\tint po=0; d[0]=sj;\n\tfo(i,1,g)if(d[i]>d[po])po=i;\n\treturn po;\n}\n\ninline void Simplex()\n{\n\tint x;\n\twhile((x=find())!=0){\n\t\tdouble zd=(db)1e20;\n\t\tint po=0;\n\t\tfo(i,1,gs)if(s[i][x]<-sj)if(c[i]/(-s[i][x])<zd)zd=c[i]/(-s[i][x]),po=i;\n\t\tif(!po)break;\n\t\ttrans(po,x);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfo(i,1,n){\n\t\tscanf(\"%lld%lld%lld\",&x[i],&y[i],&v[i]);\n\t}\n\tfo(i,1,n)d[i]=v[i]/op;\n\tscanf(\"%d\",&gs); m=gs;\n\tfo(i,1,m){\n\t\tchar ch=' ';\n\t\tfor(;ch!='L'&&ch!='R'&&ch!='U'&&ch!='D';ch=getchar());\n\t\tint aa,bb;\n\t\tscanf(\"%d%d\",&aa,&bb);\n\t\tc[i]=bb;\n\t\tif(ch=='L'){fo(l,1,n)if(x[l]<=aa)s[i][l]=-1;}\n\t\tif(ch=='R'){fo(l,1,n)if(x[l]>=aa)s[i][l]=-1;}\n\t\tif(ch=='D'){fo(l,1,n)if(y[l]<=aa)s[i][l]=-1;}\n\t\tif(ch=='U'){fo(l,1,n)if(y[l]>=aa)s[i][l]=-1;}\t\t\n\t}\n\tfo(i,1,n){\n\t\t++gs; c[gs]=1;\n\t\ts[gs][i]=-1;\n\t}\n\tg=m+n;\n\tSimplex();\n\tll da=(ll)(ans*op+eps);\n\tcout<<da;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <list>\n#include <time.h>\n#include <math.h>\n#include <random>\n#include <deque>\n#include <queue>\n#include <cassert>\n#include <unordered_map>\n#include <unordered_set>\n#include <iomanip>\n#include <bitset>\n#include <sstream>\n#include <chrono>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef __float128 dbl;\nconst int INF = 1.01e9;\n\n__float128 fabs(__float128 x)\n{\n  if (x < 0) return -x;\n  return x;\n}\n \nconst __float128 EPS = 1e-25;\nbool eq(__float128 x, __float128 y) {\n    return fabs(x - y) <= 0;\n}\nbool ls(__float128 x, __float128 y) {\n    return x < y && !eq(x, y);\n}\n \nvector<__float128> simplex(vector<vector<__float128> > a) {\n    int n = a.size() - 1;\n    int m = a[0].size() - 1;\n    vector<int> left(n + 1), up(m + 1);\n    iota(up.begin(), up.end(), 0);\n    iota(left.begin(), left.end(), m);\n    auto pivot = [&](int x, int y) {\n        swap(left[x], up[y]);\n        __float128 k = a[x][y];\n        a[x][y] = 1;\n        vector<int> vct;\n        for (int j = 0; j <= m; j++) {\n            a[x][j] /= k;\n            if (!eq(a[x][j], 0)) vct.push_back(j);\n        }\n        for (int i = 0; i <= n; i++) {\n            if (eq(a[i][y], 0) || i == x) continue;\n            k = a[i][y];\n            a[i][y] = 0;\n            for (int j : vct) a[i][j] -= k * a[x][j];\n        }\n    };\n    while (1) {\n        int x = -1;\n        for (int i = 1; i <= n; i++) if (ls(a[i][0], 0) && (x == -1 || a[i][0] < a[x][0])) x = i;\n        if (x == -1) break;\n        int y = -1;\n        for (int j = 1; j <= m; j++) if (ls(a[x][j], 0) && (y == -1 || a[x][j] < a[x][y])) y = j;\n        if (y == -1) assert(0); // infeasible\n        pivot(x, y);\n    }\n    while (1) {\n        int y = -1;\n        for (int j = 1; j <= m; j++) if (ls(0, a[0][j]) && (y == -1 || a[0][j] > a[0][y])) y = j;\n        if (y == -1) break;\n        int x = -1;\n        for (int i = 1; i <= n; i++) if (ls(0, a[i][y]) && (x == -1 || a[i][0] / a[i][y] < a[x][0] / a[x][y])) x = i;\n        if (x == -1) assert(0); // unbounded\n        pivot(x, y);\n    }\n    vector<__float128> ans(m + 1);\n    for (int i = 1; i <= n; i++) if (left[i] <= m) ans[left[i]] = a[i][0];\n    ans[0] = -a[0][0];\n    return ans;\n}\n\n#ifdef ONPC\n  mt19937 rnd(228);\n#else\n  mt19937 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\n#endif\n\nint main()\n{\n#ifdef ONPC\n  freopen(\"a.in\", \"r\", stdin);\n#endif\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector <int> x(n), y(n);\n  vector <ll> ok;\n  vector <__float128> v;\n  vector <pair <ll, int> > e;\n  for (int i = 0; i < n; i++)\n  {\n    cin >> x[i] >> y[i];\n    ll x;\n    cin >> x;\n    ok.push_back(x);\n    v.push_back(x);\n    e.push_back({x, i});\n  }\n  v.insert(v.begin(), 0);\n  int m;\n  cin >> m;\n  vector <vector <__float128> > mat;\n  mat.push_back(v);\n  for (int i = 0; i < n; i++)\n  {\n    vector <__float128> kek(n + 1);\n    kek[0] = kek[i + 1] = 1;\n    mat.push_back(kek);\n  }\n  vector <vector <int> > simp;\n  for (int i = 0; i < m; i++)\n  {\n    char c;\n    cin >> c;\n    int a;\n    int b;\n    cin >> a >> b;\n    vector <__float128> arr = {(__float128) b};\n    vector <int> kek = {b};\n    for (int j = 0; j < n; j++)\n    {\n      int grab = 0;\n      if (c == 'L' && x[j] <= a) grab = 1;\n      if (c == 'R' && x[j] >= a) grab = 1;\n      if (c == 'D' && y[j] <= a) grab = 1;\n      if (c == 'U' && y[j] >= a) grab = 1;\n      arr.push_back(grab);\n      kek.push_back(grab);\n    }\n    mat.push_back(arr);\n    simp.push_back(kek);\n  }\n  auto good = [&] (vector <int> grab)\n  {\n    for (auto c : simp)\n    {\n      int sum = 0;\n      for (int i = 1; i <= n; i++) sum += grab[i - 1] * c[i];\n      if (sum > c[0])\n      {\n        return false;\n      }\n    }\n    return true;\n  };\n  auto f = [&] (vector <int> grab)\n  {\n    ll sum = 0;\n    for (int i = 0; i < n; i++)\n    {\n      if (grab[i]) sum += ok[i];\n    }\n    return sum;\n  };\n  vector <int> grab;\n  for (int i = 0; i < n; i++) grab.push_back(0);\n  cout.precision(20);\n  auto solve = [&] ()\n  {\n    auto ret = simplex(mat);\n    sort(e.begin(), e.end());\n    vector <int> me(n);\n    int x = -1;\n    for (int i = 1; i <= n; i++)\n    {\n      if (grab[i - 1]) continue;\n      grab[i - 1] = true;\n      if (!good(grab))\n      {\n        grab[i - 1] = false;\n        continue;\n      }\n      grab[i - 1] = false;\n      if (x == -1 || ret[i] * ret[i] * ok[i - 1] > ret[x] * ret[x] * ok[x - 1])\n      {\n        x = i;\n      }\n    }\n    if (x == -1 || ret[x] < EPS) return 0ll;\n    x--;\n    me[x] = true;\n    grab[x] = true;\n    if (!good(grab)) grab[x] = false, me[x] = false;\n    int kekos = 0;\n    for (auto &c : mat)\n    {\n      kekos++;\n      if (kekos > n + 1)\n      for (int i = 1; i <= n; i++)\n      {\n        if (me[i - 1] && c[i] > EPS) c[i]--, c[0]--;\n      }\n    }\n    for (int i = 1; i <= n; i++)\n    {\n      if (me[i - 1])\n      {\n        mat[i][0] = 0;\n      }\n    }\n    return ok[x];\n  };\n  ll ans = 0;\n  while (ll t = solve())\n  {\n    ans += t;\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Created by Nikolay Budin\n\n#ifdef LOCAL\n#  define _GLIBCXX_DEBUG\n#else\n// #  define cerr __get_ce\n#endif\n#include <bits/stdc++.h>\n#define ff first\n#define ss second\n#define szof(x) ((int)x.size())\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef unsigned long long ull;\nint const INF = (int)1e9 + 1e3;\nll const INFL = (ll)1e18 + 1e6;\n#ifdef LOCAL\n\tmt19937 tw(9450189);\n#else\n\tmt19937 tw(chrono::high_resolution_clock::now().time_since_epoch().count());\n#endif\nuniform_int_distribution<ll> ll_distr;\nll rnd(ll a, ll b) { return ll_distr(tw) % (b - a + 1) + a; }\n\nstruct big_integer {\nprivate:\n    std::vector<uint32_t> number;\n    void normalize();\n    void negate();\n    \npublic:\n    big_integer();\n    big_integer(int num);\n    big_integer(ll num);\n    big_integer(uint32_t num);\n    big_integer(std::vector<uint32_t> const& _number);\n    explicit big_integer(std::string const& s);\n\n    ~big_integer();\n    \n    big_integer(big_integer const& other);\n\n    void print() const;\n\n    bool get_sign() const;\n\n    size_t size() const;\n    \n    uint32_t operator[](size_t pos) const;\n\n    big_integer& operator=(big_integer const& other);\n\n    big_integer& operator+=(big_integer const& rhs);\n    big_integer& operator-=(big_integer const& rhs);\n    big_integer& operator*=(big_integer const& rhs);\n    big_integer& operator/=(big_integer const& rhs);\n    big_integer& operator%=(big_integer const& rhs);\n\n    big_integer& operator&=(big_integer const& rhs);\n    big_integer& operator|=(big_integer const& rhs);\n    big_integer& operator^=(big_integer const& rhs);\n\n    big_integer& operator<<=(int rhs);\n    big_integer& operator>>=(int rhs);\n\n    big_integer operator+() const;\n    big_integer operator-() const;\n    big_integer operator~() const;\n\n    big_integer& operator++();\n    big_integer operator++(int);\n    big_integer& operator--();\n    big_integer operator--(int);\n\n    friend bool operator==(big_integer const& a, big_integer const& b);\n    friend bool operator!=(big_integer const& a, big_integer const& b);\n    friend bool operator<(big_integer const& a, big_integer const& b);\n    friend bool operator>(big_integer const& a, big_integer const& b);\n    friend bool operator<=(big_integer const& a, big_integer const& b);\n    friend bool operator>=(big_integer const& a, big_integer const& b);\n\n    friend std::string to_string(big_integer const& a);\n};\n\nbool operator==(big_integer const& num1, big_integer const& num2);\nbool operator!=(big_integer const& a, big_integer const& b);\nbool operator<(big_integer const& num1, big_integer const& num2);\nbool operator>(big_integer const& num1, big_integer const& num2);\nbool operator<=(big_integer const& num1, big_integer const& num2);\nbool operator>=(big_integer const& num1, big_integer const& num2);\n\nbig_integer operator+(big_integer num1, big_integer const& num2);\nbig_integer operator-(big_integer num1, big_integer const& num2);\nbig_integer operator*(big_integer a, big_integer const& b);\nbig_integer operator/(big_integer a, big_integer const& b);\nbig_integer operator%(big_integer a, big_integer const& b);\n\nbig_integer operator&(big_integer num1, big_integer const& num2);\nbig_integer operator|(big_integer num1, big_integer const& num2);\nbig_integer operator^(big_integer num1, big_integer const& num2);\n\nbig_integer operator<<(big_integer a, int b);\nbig_integer operator>>(big_integer a, int b);\n\nstd::string to_string(big_integer const& a);\nstd::ostream& operator<<(std::ostream& s, big_integer const& a);\n\nconst big_integer TEN(10), ZERO(0);\nconst uint64_t MASK = (((uint64_t) 1 << 32) - 1);\n\nvoid big_integer::normalize() {\n    //assert(number.back() == 0 || number.back() == MASK);\n    while (number.size() > 1 && number[number.size() - 2] == number.back()) {\n        number.pop_back();\n    }\n}\n\nvoid big_integer::negate() {\n    for (auto& num: number) {\n        num = ~num;\n    }\n    operator+=(big_integer(1));\n}\n\nbig_integer::big_integer() {\n    number = {0};\n}\n\nbig_integer::big_integer(int num) {\n    number = {(uint32_t) num};\n    if (num > 0) {\n        number.push_back(0);\n    }\n    if (num < 0) {\n        number.push_back((uint32_t) -1);\n    }\n    normalize();\n}\n\nbig_integer::big_integer(uint32_t num) {\n    number = {num, 0};\n}\n\nbig_integer::big_integer(ll num) {\n    number = {(uint32_t) num, (uint32_t) (num >> 32)};\n    if (num > 0) {\n        number.push_back(0);\n    }\n    if (num < 0) {\n        number.push_back((uint32_t) -1);\n    }\n    normalize();\n}\n\nbig_integer::big_integer(std::vector<uint32_t> const& _number) {\n    number = _number;\n    while (number.size() > 1 && number[number.size() - 2] == number.back()) {\n        number.pop_back();\n    }\n}\n\nbig_integer::big_integer(std::string const& s) {\n    number = {0};\n    big_integer tp(1);\n    bool sign = 0;\n    if (s[0] == '-') {\n        sign = 1;\n    }\n    \n    for (size_t i = s.size() - 1; ~i; --i) {\n        if ('0' <= s[i] && s[i] <= '9') {\n            operator+=(tp * big_integer(s[i] - '0'));\n            tp *= TEN;\n        }\n    }\n\n    if (sign) {\n        negate();\n    }\n}\n\nbig_integer::~big_integer() {\n}\n\nbig_integer::big_integer(big_integer const& other) {\n    number = other.number;\n}\n\nvoid big_integer::print() const {\n    for (auto num: number) {\n        std::cerr << num << \" \";\n    }\n    std::cerr << std::endl;\n}\n\nbool big_integer::get_sign() const {\n    return number.back();\n}\n\nsize_t big_integer::size() const {\n    return number.size();\n}\n\nuint32_t big_integer::operator[](size_t pos) const {\n    //assert(number.size());\n    return number[std::min(pos, number.size() - 1)];\n}\n\nbig_integer& big_integer::operator=(big_integer const& other) {\n    number = other.number;\n    return *this;\n}\n\nbig_integer& big_integer::operator+=(big_integer const& rhs) {\n    std::vector<uint32_t> v;\n    size_t c = 0;\n    uint64_t now = 0;\n    while (c <= size() || c <= rhs.size()) {\n        now += operator[](c);\n        now += rhs[c];\n        v.push_back(now & MASK);\n        now >>= 32;\n        ++c;\n    }\n    number = v;\n    normalize();\n    return *this;\n}\n\nbig_integer& big_integer::operator-=(big_integer const& rhs) {\n    std::vector<uint32_t> v;\n    size_t c = 0;\n    uint64_t now = 0;\n    while (c <= size() || c <= rhs.size()) {\n        now += rhs[c];\n        v.push_back(operator[](c) - now);\n        if (operator[](c) >= now) {\n            now = 0;\n        } else {\n            now = 1;\n        }\n        ++c;\n    }\n    number = v;\n    normalize();\n    return *this;\n}\n\nbig_integer& big_integer::operator*=(big_integer const& rhs) {\n    bool sign = get_sign() ^ rhs.get_sign();\n    big_integer a = *this;\n    if (a.get_sign() == 1) {\n        a.negate();\n    }\n    big_integer b = rhs;\n    if (b.get_sign() == 1) {\n        b.negate();\n    }\n\n    std::vector<std::pair<uint64_t, uint64_t>> v(a.size() + b.size() - 1);\n    for (size_t i = 0; i < a.size(); ++i) {\n        for (size_t j = 0; j < b.size(); ++j) {\n            uint64_t tmp = (uint64_t) a[i] * b[j];\n            v[i + j].first += tmp & (((uint64_t) 1 << 32 ) - 1);\n            if (i + j + 1 < v.size()) {\n                v[i + j + 1].second += tmp >> 32;\n            }\n        }\n    }\n    number = std::vector<uint32_t>();\n    uint64_t now = 0;\n    for (size_t i = 0; i < v.size(); ++i) {\n        now += v[i].first;\n        now += v[i].second;\n        number.push_back(now & MASK);\n        now >>= 32;\n    }\n    normalize();\n    if (sign) {\n        negate();\n    }\n    return *this;\n}\n\nbig_integer& big_integer::operator/=(big_integer const& rhs) {\n    bool sign = get_sign() ^ rhs.get_sign();\n    if (get_sign() == 1) {\n        negate();\n    }\n    big_integer b = rhs;\n    if (b.get_sign() == 1) {\n        b.negate();\n    }\n    \n    if (*this < b) {\n        number = {0};\n        return *this;\n    }\n\n    std::vector<uint32_t> v(size() - b.size() + 2);\n    for (size_t i = size() - b.size(); ~i; --i) {\n        uint64_t l = 0, r = (uint64_t) 1 << 32;\n        while (r - l > 1) {\n            uint32_t mid = l + (r - l) / 2;\n            \n            uint64_t now = 0;\n            bool flag = true;\n            for (size_t j = 0; j < b.size(); ++j) {\n                now += (uint64_t) b[j] * mid;\n                if ((now & MASK) != number[i + j]) {\n                    flag = (number[i + j] > (now & MASK));\n                }\n                now >>= 32;\n            }\n\n            if (flag) {\n                l = mid;\n            } else {\n                r = mid;\n            }\n        }\n        \n        uint64_t now = 0, nowd = 0;\n        for (size_t j = 0; j < b.size(); ++j) {\n            now += (uint64_t) b[j] * l;\n            nowd += now & MASK;\n            now >>= 32;\n            if (nowd <= number[i + j]) {\n                number[i + j] -= nowd;\n                nowd = 0;\n            } else {\n                number[i + j] -= nowd;\n                nowd = 1;\n            }\n        }\n        v[i] = l;\n    }\n\n    number = v;\n    normalize();\n    if (sign) {\n        negate();\n    }\n    return *this;\n}\n\nbig_integer& big_integer::operator%=(big_integer const& rhs) {\n    bool sign = get_sign();\n    if (get_sign() == 1) {\n        negate();\n    }\n    big_integer b = rhs;\n    if (b.get_sign() == 1) {\n        b.negate();\n    }\n    \n    if (*this < b) {\n        return *this;\n    }\n\n    for (size_t i = size() - b.size(); ~i; --i) {\n        uint64_t l = 0, r = (uint64_t) 1 << 32;\n        while (r - l > 1) {\n            uint32_t mid = l + (r - l) / 2;\n            \n            uint64_t now = 0;\n            bool flag = true;\n            for (size_t j = 0; j < b.size(); ++j) {\n                now += (uint64_t) b[j] * mid;\n                //prod[j] = now & MASK;\n                if ((now & MASK) != number[i + j]) {\n                    flag = (number[i + j] > (now & MASK));\n                }\n                now >>= 32;\n            }\n\n            if (flag) {\n                l = mid;\n            } else {\n                r = mid;\n            }\n        }\n        \n        uint64_t now = 0, nowd = 0;\n        for (size_t j = 0; j < b.size(); ++j) {\n            now += (uint64_t) b[j] * l;\n            nowd += now & MASK;\n            now >>= 32;\n            if (nowd <= number[i + j]) {\n                number[i + j] -= nowd;\n                nowd = 0;\n            } else {\n                number[i + j] -= nowd;\n                nowd = 1;\n            }\n        }\n    }\n\n    normalize();\n    if (sign) {\n        negate();\n    }\n    return *this;\n}\n\nbig_integer& big_integer::operator&=(big_integer const& rhs) {\n    std::vector<uint32_t> v;\n    size_t c = 0;\n    while (c <= size() || c <= rhs.size()) {\n        v.push_back(operator[](c) & rhs[c]);\n        ++c;\n    }\n    number = v;\n    normalize();\n    return *this;\n}\n\nbig_integer& big_integer::operator|=(big_integer const& rhs) {\n    std::vector<uint32_t> v;\n    size_t c = 0;\n    while (c <= size() || c <= rhs.size()) {\n        v.push_back(operator[](c) | rhs[c]);\n        ++c;\n    }\n    number = v;\n    normalize();\n    return *this;\n}\n\nbig_integer& big_integer::operator^=(big_integer const& rhs) {\n    std::vector<uint32_t> v;\n    size_t c = 0;\n    while (c <= size() || c <= rhs.size()) {\n        v.push_back(operator[](c) ^ rhs[c]);\n        ++c;\n    }\n    number = v;\n    normalize();\n    return *this;\n}\n\nbig_integer& big_integer::operator<<=(int rhs) {\n    int d = rhs % 32;\n    int tot = rhs / 32;\n    std::vector<uint32_t> v;\n    for (int i = 0; i < tot; ++i) {\n        v.push_back(0);\n    }\n    size_t c = 0;\n    uint32_t prev = 0;\n    while (c <= size()) {\n        uint32_t tmp = (operator[](c) << d) | prev;\n        v.push_back(tmp);\n        prev = operator[](c) >> (32 - d);\n        ++c;\n    }\n    number = v;\n    normalize();\n    return *this;\n}\n\nbig_integer& big_integer::operator>>=(int rhs) {\n    int d = rhs % 32;\n    int tot = rhs / 32;\n    std::vector<uint32_t> v;\n    size_t c = tot;\n    do {\n        uint32_t tmp = (operator[](c) >> d) | (operator[](c + 1) << (32 - d));\n        v.push_back(tmp);\n        ++c;\n    } while (c <= size() + 1);\n    number = v;\n    normalize();\n    return *this;\n}\n\nbig_integer big_integer::operator+() const {\n    big_integer ret = *this;\n    return ret;\n}\n\nbig_integer big_integer::operator-() const {\n    big_integer ret = *this;\n    ret.negate();\n    return ret;\n}\n\nbig_integer big_integer::operator~() const {\n    std::vector<uint32_t> v;\n    for (size_t i = 0; i < size(); ++i) {\n        v.push_back(~number[i]);\n    }\n    return big_integer(v);\n}\n\nbig_integer& big_integer::operator++() {\n    operator+=(big_integer(1));\n    return *this;\n}\n\nbig_integer big_integer::operator++(int) {\n    big_integer ret = *this;\n    operator+=(big_integer(1));\n    return ret;\n}\n\nbig_integer& big_integer::operator--() {\n    operator-=(big_integer(1));\n    return *this;\n}\n\nbig_integer big_integer::operator--(int) {\n    big_integer ret = *this;\n    operator-=(big_integer(1));\n    return ret;\n}\n\n\n\nbool operator==(big_integer const& a, big_integer const& b) {\n    return a.number == b.number;\n}\n\nbool operator!=(big_integer const& a, big_integer const& b) {\n    return a.number != b.number;\n}\n\nbool operator<(big_integer const& a, big_integer const& b) {\n    if (a.get_sign() != b.get_sign()) {\n        return a.get_sign() > b.get_sign();\n    }\n    \n    if (a.number.size() != b.number.size()) {\n        return a.number.size() < b.number.size();\n    }\n\n    for (size_t i = a.number.size() - 1; ~i; --i) {\n        if (a.number[i] != b.number[i]) {\n            return a.number[i] < b.number[i];\n        }\n    }\n    return false;\n}\n\nbool operator>(big_integer const& a, big_integer const& b) {\n    return !(a == b || a < b);\n}\n\nbool operator<=(big_integer const& a, big_integer const& b) {\n    return a == b || a < b;\n}\n\nbool operator>=(big_integer const& a, big_integer const& b) {\n    return a == b || a > b;\n}\n\nbig_integer operator+(big_integer a, big_integer const& b) {\n    return a += b;\n}\n\nbig_integer operator-(big_integer a, big_integer const& b) {\n    return a -= b;\n}\n\nbig_integer operator*(big_integer a, big_integer const& b) {\n    return a *= b;\n}\n\nbig_integer operator/(big_integer a, big_integer const& b) {\n    return a /= b;\n}\n\nbig_integer operator%(big_integer a, big_integer const& b) {\n    return a %= b;\n}\n\nbig_integer operator&(big_integer a, big_integer const& b) {\n    return a &= b;\n}\n\nbig_integer operator|(big_integer a, big_integer const& b) {\n    return a |= b;\n}\n\nbig_integer operator^(big_integer a, big_integer const& b) {\n    return a ^= b;\n}\n\nbig_integer operator<<(big_integer a, int b) {\n    return a <<= b;\n}\nbig_integer operator>>(big_integer a, int b) {\n    return a >>= b;\n}\n\nstd::string to_string(big_integer const& a) {\n    big_integer tmp = a;\n    std::string ret = \"\";\n    bool sign = 0;\n    if (tmp < ZERO) {\n        tmp = -tmp;\n        sign = 1;\n    }\n    while (tmp > ZERO) {\n        big_integer dig = tmp % TEN;\n        ret += '0' + dig[0];\n        tmp /= TEN;\n    }\n    if (ret.size() == 0) {\n        ret = \"0\";\n    }\n    if (sign) {\n        ret += '-';\n    }\n    reverse(ret.begin(), ret.end());\n    return ret;\n}\n\nstd::ostream& operator<<(std::ostream& s, big_integer const& a) {\n    s << to_string(a);\n    return s;\n}\n\nstruct number {\n\tbig_integer p, q;\n\n\tnumber() : p(0), q(1) {}\n\n\tnumber(ll num) : p(big_integer(num)), q(1) {}\n\n\tnumber(big_integer _p, big_integer _q) : p(_p), q(_q) {\n\t\tif (q < 0) {\n\t\t\tq *= -1;\n\t\t\tp *= -1;\n\t\t}\n\t}\n\n\tnumber operator+(number const& other) const {\n\t\treturn number(p * other.q + q * other.p, q * other.q);\n\t}\n\tnumber operator-(number const& other) const {\n\t\treturn number(p * other.q - q * other.p, q * other.q);\n\t}\n\n\tnumber operator*(number const& other) const {\n\t\treturn number(p * other.p, q * other.q);\n\t}\n\n\tnumber operator/(number const& other) const {\n\t\treturn number(p * other.q, q * other.p);\n\t}\n\n\tnumber& operator/=(number const& other) {\n\t\tauto tmp = *this / other;\n\t\tp = tmp.p;\n\t\tq = tmp.q;\n\t\treturn *this;\n\t}\n\n\tnumber& operator-=(number const& other) {\n\t\tauto tmp = *this - other;\n\t\tp = tmp.p;\n\t\tq = tmp.q;\n\t\treturn *this;\n\t}\n\n\tnumber operator-() const {\n\t\treturn number(-p, q);\n\t}\n\n\tbool operator==(number const& other) const {\n\t\treturn p * other.q == q * other.p;\n\t}\n\n\tbool operator<(number const& other) const {\n\t\treturn p * other.q < q * other.p;\n\t}\n\n\tbool operator>(number const& other) const {\n\t\treturn p * other.q > q * other.p;\n\t}\n};\n\nbool eq(number a, number b) {\n\treturn a == b;\n}\n\nbool ls(number a, number b) {\n\treturn a < b;\n}\n\nvector<number> simplex(vector<vector<number> > a) {\n    int n = a.size() - 1;\n    int m = a[0].size() - 1;\n    vector<int> left(n + 1), up(m + 1);\n    iota(up.begin(), up.end(), 0);\n    iota(left.begin(), left.end(), m);\n    auto pivot = [&](int x, int y) {\n        swap(left[x], up[y]);\n        number k = a[x][y];\n        a[x][y] = 1;\n        vector<int> vct;\n        for (int j = 0; j <= m; j++) {\n            a[x][j] /= k;\n            if (!eq(a[x][j], 0)) vct.push_back(j);\n        }\n        for (int i = 0; i <= n; i++) {\n            if (eq(a[i][y], 0) || i == x) continue;\n            k = a[i][y];\n            a[i][y] = 0;\n            for (int j : vct) a[i][j] -= k * a[x][j];\n        }\n    };\n    while (1) {\n        int x = -1;\n        for (int i = 1; i <= n; i++) if (ls(a[i][0], 0) && (x == -1 || a[i][0] < a[x][0])) x = i;\n        if (x == -1) break;\n        int y = -1;\n        for (int j = 1; j <= m; j++) if (ls(a[x][j], 0) && (y == -1 || a[x][j] < a[x][y])) y = j;\n        if (y == -1) assert(0); // infeasible\n        pivot(x, y);\n    }\n    while (1) {\n        int y = -1;\n        for (int j = 1; j <= m; j++) if (ls(0, a[0][j]) && (y == -1 || a[0][j] > a[0][y])) y = j;\n        if (y == -1) break;\n        int x = -1;\n        for (int i = 1; i <= n; i++) if (ls(0, a[i][y]) && (x == -1 || a[i][0] / a[i][y] < a[x][0] / a[x][y])) x = i;\n        if (x == -1) assert(0); // unbounded\n        pivot(x, y);\n    }\n    vector<number> ans(m + 1);\n    for (int i = 1; i <= n; i++) if (left[i] <= m) ans[left[i]] = a[i][0];\n    ans[0] = -a[0][0];\n    return ans;\n}\n// j=1..m: x[j]>=0\n// i=1..n: sum(j=1..m) A[i][j]*x[j] <= A[i][0]\n// max sum(j=1..m) A[0][j]*x[j]\n// res[0] is answer\n// res[1..m] is certificate\n\nvoid solve() {\n\tint n;\n\tcin >> n;\n\tvector<vector<number>> matr;\n\tvector<pii> coords;\n\tmatr.push_back(vector<number>(n + 1));\n\tfor (int i = 0; i < n; ++i) {\n\t\tint x, y;\n\t\tll w;\n\t\tcin >> x >> y >> w;\n\t\tmatr[0][i + 1] = w;\n\t\tcoords.push_back({x, y});\n\t\tmatr.push_back(vector<number>(n + 1));\n\t\tmatr.back()[0] = 1;\n\t\tmatr.back()[i + 1] = 1;\n\t}\n\n\tint m;\n\tcin >> m;\n\tfor (int i = 0; i < m; ++i) {\n\t\tchar t;\n\t\tint a, b;\n\t\tcin >> t >> a >> b;\n\t\tmatr.push_back(vector<number>(n + 1));\n\t\tmatr.back()[0] = b;\n\t\tif (t == 'L') {\n\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\tif (coords[j].ff <= a) {\n\t\t\t\t\tmatr.back()[j + 1] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (t == 'R') {\n\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\tif (coords[j].ff >= a) {\n\t\t\t\t\tmatr.back()[j + 1] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (t == 'D') {\n\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\tif (coords[j].ss <= a) {\n\t\t\t\t\tmatr.back()[j + 1] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (t == 'U') {\n\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\tif (coords[j].ss >= a) {\n\t\t\t\t\tmatr.back()[j + 1] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tauto res = simplex(matr);\n\tcout << res[0].p << \"\\n\";\n}\n\n\nint main() {\n#ifdef LOCAL\n\tauto start_time = clock();\n\tcerr << setprecision(3) << fixed;\n#endif\n\tcout << setprecision(15) << fixed;\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\n\tint test_count = 1;\n\t// cin >> test_count;\n\tfor (int test = 1; test <= test_count; ++test) {\n\t\tsolve();\n\t}\n\t\n#ifdef LOCAL\n\tauto end_time = clock();\n\tcerr << \"Execution time: \" << (end_time - start_time) * (int)1e3 / CLOCKS_PER_SEC << \" ms\\n\";\n#endif\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<cmath>\nusing namespace std;\n\nconst int N = 410, M = 3010;\n\nint AA[M][N], BB[M];\n\nstruct Simplex {\n\tusing T = long double;\n\tconst T eps = 1e-13;\n\tint n, m;\n\tint Left[M], Down[N];\n\t// time complexity: exponential. fast $O(MN^2)$ in experiment. dependent on the modeling.\n\t// Ax <= b, max c^T x. 최댓값: v, 답 추적: sol[i]. 1 based\n\tT a[M][N], b[M], c[N], v, sol[N];\n\tbool eq(T a, T b) { return fabs(a - b) < eps; }\n\tbool ls(T a, T b) { return a < b && !eq(a, b); }\n\tvoid init(int p, int q) {\n\t\tn = p; m = q; v = 0;\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) a[i][j] = 0;\n\t\t}\n\t\tfor (int i = 1; i <= m; i++) b[i] = 0;\n\t\tfor (int i = 1; i <= n; i++) c[i] = sol[i] = 0;\n\t}\n\tvoid pivot(int x, int y) {\n\t\tswap(Left[x], Down[y]);\n\t\tT k = a[x][y]; a[x][y] = 1;\n\t\tvector<int> nz;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\ta[x][i] /= k;\n\t\t\tif (!eq(a[x][i], 0)) nz.push_back(i);\n\t\t}\n\t\tb[x] /= k;\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tif (i == x || eq(a[i][y], 0)) continue;\n\t\t\tk = a[i][y]; a[i][y] = 0;\n\t\t\tb[i] -= k * b[x];\n\t\t\tfor (int j : nz) a[i][j] -= k * a[x][j];\n\t\t}\n\t\tif (eq(c[y], 0)) return;\n\t\tk = c[y]; c[y] = 0;\n\t\tv += k * b[x];\n\t\tfor (int i : nz) c[i] -= k * a[x][i];\n\t}\n\t// 0: found solution, 1: no feasible solution, 2: unbounded\n\tint solve() {\n\t\tfor (int i = 1; i <= n; i++) Down[i] = i;\n\t\tfor (int i = 1; i <= m; i++) Left[i] = n + i;\n\t\twhile (1) { // Eliminating negative b[i]\n\t\t\tint x = 0, y = 0;\n\t\t\tfor (int i = 1; i <= m; i++) if (ls(b[i], 0) && (x == 0 || b[i] < b[x])) x = i;\n\t\t\tif (x == 0) break;\n\t\t\tfor (int i = 1; i <= n; i++) if (ls(a[x][i], 0) && (y == 0 || a[x][i] < a[x][y])) y = i;\n\t\t\tif (y == 0) return 1;\n\t\t\tpivot(x, y);\n\t\t}\n\t\twhile (1) {\n\t\t\tint x = 0, y = 0;\n\t\t\tfor (int i = 1; i <= n; i++)\n\t\t\t\tif (ls(0, c[i]) && (!y || c[i] > c[y])) y = i;\n\t\t\tif (y == 0) break;\n\t\t\tfor (int i = 1; i <= m; i++)\n\t\t\t\tif (ls(0, a[i][y]) && (!x || b[i] / a[i][y] < b[x] / a[x][y])) x = i;\n\t\t\tif (x == 0) return 2;\n\t\t\tpivot(x, y);\n\t\t}\n\t\tfor (int i = 1; i <= m; i++) if (Left[i] <= n) sol[Left[i]] = b[i];\n\t\treturn 0;\n\t}\n}SS;\n\nstruct point {\n\tint x, y;\n}w[81];\nlong long cost[81];\n\nstruct AA {\n\tint a;\n\tlong double t;\n\tbool operator<(const AA &p)const {\n\t\treturn t < p.t;\n\t}\n}ord[81];\n\nint main() {\n\tint n, m;\n\tint i, j, k;\n\tscanf(\"%d\", &n);\n\tfor (i = 1; i <= n; i++) {\n\t\tlong long t;\n\t\tscanf(\"%d%d%lld\", &w[i].x, &w[i].y, &cost[i]);\n\t}\n\tscanf(\"%d\", &m);\n\n\tSS.init(n, n+m);\n\tfor (i = 1; i <= n; i++) {\n\t\tSS.c[i] = cost[i];\n\t}\n\tfor (i = 1; i <= m; i++) {\n\t\tchar pp[3];\n\t\tint a, b;\n\t\tscanf(\"%s\", pp);\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tSS.b[i] = b;\n\t\tBB[i] = b;\n\t\tif (pp[0] == 'L') {\n\t\t\tfor (j = 1; j <= n; j++) {\n\t\t\t\tif (w[j].x <= a) {\n\t\t\t\t\tSS.a[i][j] = 1;\n\t\t\t\t\tAA[i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (pp[0] == 'R') {\n\t\t\tfor (j = 1; j <= n; j++) {\n\t\t\t\tif (w[j].x >= a) {\n\t\t\t\t\tSS.a[i][j] = 1;\n\t\t\t\t\tAA[i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (pp[0] == 'D') {\n\t\t\tfor (j = 1; j <= n; j++) {\n\t\t\t\tif (w[j].y <= a) {\n\t\t\t\t\tSS.a[i][j] = 1;\n\t\t\t\t\tAA[i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (pp[0] == 'U') {\n\t\t\tfor (j = 1; j <= n; j++) {\n\t\t\t\tif (w[j].y >= a) {\n\t\t\t\t\tSS.a[i][j] = 1;\n\t\t\t\t\tAA[i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 1; i <= n; i++) {\n\t\tSS.a[i + m][i] = 1;\n\t\tSS.b[i + m] = 1;\n\t}\n\tSS.solve();\n\tfor (i = 1; i <= n; i++) {\n\t\tord[i] = { i,SS.sol[i] };\n\t}\n\tsort(ord + 1, ord + n + 1);\n\tfor (i = 1; i <= n; i++) {\n\t\tfor (j = 1; j <= m; j++) {\n\t\t\tint c = 0;\n\t\t\tfor (k = i; k <= n; k++) {\n\t\t\t\tif (AA[j][ord[k].a])c++;\n\t\t\t}\n\t\t\tif (BB[j] < c)break;\n\t\t}\n\t\tif (j == m + 1) {\n\t\t\tlong long res = 0;\n\t\t\tfor (j = i; j <= n; j++) {\n\t\t\t\tres += cost[ord[j].a];\n\t\t\t}\n\t\t\tprintf(\"%lld\\n\", res);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tputs(\"0\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define itn int\n#define all(x) (x).begin(), (x).end()\n#define make_unique(x) sort(all((x))); (x).resize(unique(all((x))) - (x).begin())\n\n#define random_shuffle(...) shuffle(__VA_ARGS__, rng)\n#define rand() rng()\n\nusing namespace std;\n\ninline int nxt() {\n\tint x;\n\tscanf(\"%d\", &x);\n\treturn x;\n}\n\n#define sz(x) ((int) (x).size())\n#define forn(i,n) for (int i = 0; i < int(n); ++i)\n\ntypedef long long ll;\ntypedef long long i64;\ntypedef long double ld;\nconst int inf = int(1e9) + int(1e5);\nconst ll infl = ll(2e18) + ll(1e10);\n\nconst int maxn = 505;\nconst int maxm = 505;\n\nconst ld eps = 1e-9;\n\nbool eq(ld a, ld b) {\n    return fabsl(a - b) < eps;\n}\n\n//BEGIN_CODE\nnamespace Simplex {\n\nld D[maxm][maxn]; // [n+2][m+2]\nint B[maxm];\nint N[maxn];\nld x[maxn];\nint n, m;\n\n//x >= 0, Ax <= b, c^Tx -> max\nvoid init(int _n, int _m, ld A[][maxn], ld *b, ld *c) {\n    n = _n, m = _m;\n    forn (i, m)\n        forn (j, n)\n            D[i][j] = -A[i][j];\n    forn (i, m) {\n        D[i][n] = 1;\n        D[i][n + 1] = b[i];\n    }\n    forn (j, n) {\n        D[m][j] = c[j];\n        D[m + 1][j] = 0;\n    }\n    D[m][n + 1] = D[m][n] = D[m + 1][n + 1] = 0;\n    D[m + 1][n] = -1;\n    iota(B, B + m, n);\n    iota(N, N + n, 0);\n    N[n] = -1;\n}\n\nvoid pivot(int b, int nb) {\n    assert(D[b][nb] != 0);\n    ld q = 1. / -D[b][nb];\n    D[b][nb] = -1;\n    forn (i, n + 2)\n        D[b][i] *= q;\n    forn (i, m + 2) {\n        if (i == b)\n            continue;\n        ld coef = D[i][nb];\n        D[i][nb] = 0;\n        forn (j, n + 2)\n            D[i][j] += coef * D[b][j];\n    }\n    swap(B[b], N[nb]);\n}\n\nbool betterN(int f, int i, int j) {\n    if (eq(D[f][i], D[f][j]))\n        return N[i] < N[j];\n    return D[f][i] > D[f][j];\n}\n\nbool betterB(int nb, int i, int j) {\n    ld ai = D[i][n + 1] / D[i][nb];\n    ld aj = D[j][n + 1] / D[j][nb];\n    if (eq(ai, aj))\n        return B[i] < B[j];\n    return ai > aj;\n}\n\nbool simplex(int phase) {\n    int f = phase == 1 ? m : m + 1;\n    while (true) {\n        int nb = -1;\n        forn (i, n + 1) {\n            if (N[i] == -1 && phase == 1)\n                continue;\n            if (nb == -1 || betterN(f, i, nb))\n                nb = i;\n        }\n        if (D[f][nb] <= eps)\n            return phase == 1;\n        assert(nb != -1);\n\n        int b = -1;\n        forn (i, m) {\n            if (D[i][nb] >= -eps)\n                continue;\n            if (b == -1 || betterB(nb, i, b))\n                b = i;\n        }\n        if (b == -1)\n            return false;\n        pivot(b, nb);\n        if (N[nb] == -1 && phase == 2)\n            return true;\n    }\n}\n\nld solve() {\n    int b = -1;\n    forn (i, m) {\n        if (b == -1 || D[i][n + 1] < D[b][n + 1])\n            b = i;\n    }\n    assert(b != -1);\n    if (D[b][n + 1] < -eps) {\n        pivot(b, n);\n        if (!simplex(2) || D[m + 1][n + 1] < -eps)\n            return -infl;\n    }\n    if (!simplex(1))\n        return infl;\n\n    forn (i, n)\n        x[i] = 0;\n    forn (i, m)\n        if (B[i] < n)\n            x[B[i]] = D[i][n + 1];\n\n    return D[m][n + 1];\n}\n\n} //Simplex\n//END_CODE\n\nstruct Treasure {\n\tint x, y;\n\tlong long v;\n\n\tvoid scan() {\n\t\tscanf(\"%d%d%lld\", &x, &y, &v);\n\t}\n};\n\nstruct Constraint {\n\tchar t;\n\tint a, b;\n\n\tvoid scan() {\n\t\tcin >> t >> a >> b;\n\t}\n\n\tbool isAbout(const Treasure& tr) const {\n\t\tif (t == 'D') {\n\t\t\treturn tr.y <= a;\n\t\t} else if (t == 'U') {\n\t\t\treturn tr.y >= a;\n\t\t} else if (t == 'L') {\n\t\t\treturn tr.x <= a;\n\t\t} else if (t == 'R') {\n\t\t\treturn tr.x >= a;\n\t\t} else {\n\t\t\tassert(false);\n\t\t}\n\t}\n};\n\nld a[maxm][maxn];\nld b[maxm];\nld c[maxn];\n\nint main() {\n\tmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n\tint n = nxt();\n\tvector<Treasure> trs(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\ttrs[i].scan();\n\t}\n\n\tint m = nxt();\n\tvector<Constraint> crs(m);\n\tfor (int i = 0; i < m; ++i) {\n\t\tcrs[i].scan();\n\t}\n\n\tfor (int i = 0; i < m; ++i) {\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\ta[i][j] = crs[i].isAbout(trs[j]);\n\t\t}\n\t\tb[i] = crs[i].b;\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\ta[m + i][i] = 1;\n\t\tb[m + i] = 1;\n\t\tc[i] = trs[i].v;\n\t}\n\n\tSimplex::init(n, n + m, a, b, c);\n\tSimplex::solve();\n\n\tlong long ans = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tans += trs[i].v * (int)(roundl(Simplex::x[i]));\n\t}\n\tcout << ans << \"\\n\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\nconst ll MAX=1000000000000010;\nint n,m,cnt=-1,s=0,t,head[1010],x[200],y[200],lx[200],rx[200],ly[200],ry[200],a[200],b[200];\nll ans=0,tot=0,val[200],dis[500];\nbool vis[500];\nchar ch[200][10];\nstruct edge{\n\tint u,v,w,nxt;\n\tll f;\n}e[200010];\n\nvoid add(int u,int v,int w,ll f){\n\te[++cnt]=(edge){u,v,w,head[u],f};\n\thead[u]=cnt;\n}\nvoid addedge(int u,int v,int w,ll f){\n\tadd(u,v,w,f);add(v,u,0,-f);\n}\n\nvoid init(int K){\n\tcnt=-1;t=490;tot=0;\n\tmemset(head,-1,sizeof(head));\n\tfor(int i=0;i<=n+1;i++)lx[i]=ly[i]=1,rx[i]=ry[i]=100;\n}\n\nbool spfa(){\n\tmemset(dis,0x3f,sizeof(dis));\n\tmemset(vis,0,sizeof(vis));\n\tqueue<int>que;\n\tque.push(s);dis[s]=0;\n\twhile(!que.empty()){\n\t\tint u=que.front();que.pop();vis[u]=0;\n\t\tfor(int i=head[u];~i;i=e[i].nxt)\n\t\t  if(e[i].w&&dis[e[i].v]>dis[u]+e[i].f){\n\t\t  \tdis[e[i].v]=dis[u]+e[i].f;\n\t\t  \tif(!vis[e[i].v])vis[e[i].v]=1,que.push(e[i].v);\n\t\t  }\n\t}\n\treturn dis[t]!=0x3f3f3f3f3f3f3f3f;\n}\nint dfs(int u,int a){\n\tif(u==t||!a)return a;\n\tvis[u]=1;\n\tint ret=0,tmp;\n\tfor(int i=head[u];~i;i=e[i].nxt)\n\t  if(e[i].w&&!vis[e[i].v]&&dis[e[i].v]==dis[u]+e[i].f){\n\t  \ttmp=dfs(e[i].v,min(a,e[i].w));\n\t  \tif(!tmp)continue;\n\t  \te[i].w-=tmp;e[i^1].w+=tmp;\n\t  \tret+=tmp;a-=tmp;tot+=e[i].f*tmp;\n\t  \tif(!a)break;\n\t  }\n\treturn ret;\n}\nint dinic(){\n\tint ret=0;\n\twhile(spfa())\n\t  ret+=dfs(s,0x3f3f3f3f);\n\treturn ret;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%d%d%lld\",&x[i],&y[i],&val[i]);\n\tscanf(\"%d\",&m);\n\tfor(int i=1;i<=m;i++)scanf(\"%s%d%d\",ch[i],&a[i],&b[i]);\n\tfor(int K=1;K<=n;K++){\n\t\tinit(K);\n\t\tfor(int i=1;i<=m;i++){\n\t\t\tif(ch[i][0]=='L')lx[b[i]+1]=a[i]+1;\n\t\t\tif(ch[i][0]=='R')rx[K-b[i]]=a[i]-1;\n\t\t\tif(ch[i][0]=='D')ly[b[i]+1]=a[i]+1;\n\t\t\tif(ch[i][0]=='U')ry[K-b[i]]=a[i]-1;\n\t\t}\n\t\tfor(int i=2;i<=K;i++)lx[i]=max(lx[i-1],lx[i]),ly[i]=max(ly[i-1],ly[i]);\n\t\tfor(int i=K-1;i>=1;i--)rx[i]=min(rx[i+1],rx[i]),ry[i]=min(ry[i+1],ry[i]);\n\t\tfor(int i=1;i<=K;i++){\n\t\t\taddedge(s,i,1,0),addedge(K+200+i,t,1,0);\n\t\t\tfor(int j=lx[i];j<=rx[i];j++)addedge(i,K+j,1,0);\n\t\t\tfor(int j=ly[i];j<=ry[i];j++)addedge(K+100+j,K+200+i,1,0);\n\t\t}\n\t\tfor(int i=1;i<=n;i++)addedge(K+x[i],K+100+y[i],1,-val[i]);\n\t\tdinic();\n\t\tans=max(ans,-tot);\n\t}\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst LL INF = 0x3f3f3f3f3f3f3f;\n\nnamespace flow\n{\n\tconst int MAXN = 400;\n\tstruct edge\n\t{\n\t\tint to, cap;\n\t\tLL cost;\n\t};\n\tint n, m;\n\tedge ed[20005];\n\tvector<int> G[405];\n\t\n\tvoid clear()\n\t{\n\t\tm = 0;\n\t\trep(i, n) G[i].clear();\n\t}\n\t\n\tvoid add_edge(int u, int v, int fl, LL co)\n\t{\n\t\ted[m].to = v; ed[m].cap = fl; ed[m].cost = co; G[u].push_back(m); m ++;\n\t\ted[m].to = u; ed[m].cap = 0; ed[m].cost = -co; G[v].push_back(m); m ++;\n\t}\n\t\n\tLL h[405];\n\tLL pat[405];\n\tint prev[405];\n\tbool vis[405];\n\t\n\tbool dijk(int s, int t)\n\t{\n\t\trep(i, n) {\n\t\t\tpat[i] = INF;\n\t\t\tvis[i] = false;\n\t\t}\n\t\tpat[s] = 0;\n\t\tpriority_queue<pair<LL, int> > que;\n\t\tque.push(MP(0, s));\n\t\t\n\t\twhile(!que.empty()) {\n\t\t\tint cur = que.top().second;\n\t\t\tque.pop();\n\t\t\tif(vis[cur]) continue;\n\t\t\tvis[cur] = true;\n\t\t\trep(i, G[cur].size()) {\n\t\t\t\tint ce = G[cur][i];\n\t\t\t\tif(ed[ce].cap == 0) continue;\n\t\t\t\tif(pat[ed[ce].to] > pat[cur] + ed[ce].cost) {\n\t\t\t\t\tpat[ed[ce].to] = pat[cur] + ed[ce].cost;\n\t\t\t\t\tprev[ed[ce].to] = ce;\n\t\t\t\t\tque.push(MP(-pat[ed[ce].to], ed[ce].to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn pat[t] != INF;\n\t}\n\t\n\tLL mcf(int s, int t, int mf)\n\t{\n\t\trep(i, n) h[i] = 0;\n\t\tLL ans = 0;\n\t\twhile(dijk(s, t)) {\n\t\t\t//in this occasion flow must be 1\n\t\t\tint cur = t, cf = 1;\n\t\t\twhile(cur != s) {\n\t\t\t\ted[prev[cur]].cap -= cf;\n\t\t\t\ted[prev[cur] ^ 1].cap += cf;\n\t\t\t\tcur = ed[prev[cur] ^ 1].to;\n\t\t\t}\n\t\t\trep(i, m) ed[i].cost += pat[ed[i ^ 1].to] - pat[ed[i].to];\n\t\t\trep(i, m) h[i] += pat[i];\n\t\t\tans += h[t] * cf;\n\t\t\tmf --;\n\t\t\tif(mf == 0) return ans;\n\t\t}\n\t\treturn -1;\n\t}\n}\n\nint n, x[85], y[85];\nLL v[85];\nint m, a[325], b[325];\nchar t[325];\nLL ans;\n\nint minx[85], maxx[85], miny[85], maxy[85];\nLL solve(int tot)\n{\n\trep(i, n) {\n\t\tminx[i] = miny[i] = -INF;\n\t\tmaxx[i] = maxy[i] = INF;\n\t}\n\t\n\trep(i, m) if(b[i] < tot) {\n\t\tif(t[i] == 'L') minx[b[i]] = max(minx[b[i]], a[i] + 1);\n\t\telse if(t[i] == 'R') maxx[tot - b[i] - 1] = min(maxx[tot - b[i] - 1], a[i] - 1);\n\t\telse if(t[i] == 'D') miny[b[i]] = max(miny[b[i]], a[i] + 1);\n\t\telse if(t[i] == 'U') maxy[tot - b[i] - 1] = min(maxy[tot - b[i] - 1], a[i] - 1);\n\t}\n\trep(i, tot - 1) {\n\t\tminx[i + 1] = max(minx[i], minx[i + 1]);\n\t\tminy[i + 1] = max(miny[i], miny[i + 1]);\n\t}\n\tfor(int i = tot - 1; i > 0; i --) {\n\t\tmaxx[i - 1] = min(maxx[i - 1], maxx[i]);\n\t\tmaxy[i - 1] = min(maxy[i - 1], maxy[i]);\n\t}\n\t\n\tflow::n = 2 + tot * 2 + n * 2;\n\tflow::clear();\n\trep(i, tot) flow::add_edge(tot * 2 + n * 2, i, 1, 0);\n\trep(i, tot) rep(j, n) if(x[j] >= minx[i] && x[j] <= maxx[i])\n\tflow::add_edge(i, j + tot * 2, 1, 0);\n\trep(i, n) flow::add_edge(i + tot * 2, i + tot * 2 + n, 1, INF - v[i]);\n\trep(i, tot) rep(j, n) if(y[j] >= miny[i] && y[j] <= maxy[i])\n\tflow::add_edge(j + tot * 2 + n, i + tot, 1, 0);\n\trep(i, tot) flow::add_edge(i + tot, tot * 2 + n * 2 + 1, 1, 0);\n\t\n\tLL ret = flow::mcf(flow::n - 2, flow::n - 1, tot);\n\t\n\treturn ret == -1 ? -1 : INF * tot - ret;\n}\n\nint main()\n{\n\tcin >> n;\n\trep(i, n) cin >> x[i] >> y[i] >> v[i];\n\tcin >> m;\n\trep(i, m) cin >> t[i] >> a[i] >> b[i];\n\tfor(int t = 0; t <= n; t ++)\n\tans = max(ans, solve(t));\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long double ld;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst long long infll = (long long) 1.01e18;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1);\n\n#ifdef DEBUG\nmt19937 mrand(300); \n#else\nmt19937 mrand(chrono::steady_clock::now().time_since_epoch().count()); \n#endif\n\nint rnd(int x) {\n  return mrand() % x;\n}\n\nvoid precalc() {\n}\n\nconst int maxn = 85, maxm = 405;\nint n;\nint xs[maxn][2];\nlong long vs[maxn];\nint m;\nint qs[maxm][3];\n\nbool read() {\n  if (scanf(\"%d\", &n) < 1) {\n    return false;\n  }\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d%d%lld\", &xs[i][0], &xs[i][1], &vs[i]);\n  }\n  scanf(\"%d\", &m);\n  for (int i = 0; i < m; i++) {\n    char tmp[10];\n    int a, b;\n    scanf(\"%s%d%d\", tmp, &a, &b);\n    char t = tmp[0];\n    qs[i][0] = (t == 'L' ? 0 : (t == 'R' ? 1 : (t == 'D' ? 2 : 3)));\n    qs[i][1] = a;\n    qs[i][2] = b;\n  }\n  return true;\n}\n\nint a[maxn];\n\nconst int maxx = 105;\nint cnt[maxx];\n\nbool check(int t) {\n  for (int dir = 0; dir < 4; dir++) {\n    if (t == 0) {\n      if (dir & 1) {\n        continue;\n      }\n    } else {\n      if (!(dir & 1)) {\n        continue;\n      }\n    }\n    memset(cnt, 0, sizeof(cnt));\n    for (int i = 0; i < n; i++) {\n      if (!a[i]) {\n        continue;\n      }\n      int x = (dir == 0 ? xs[i][0] : (dir == 1 ? maxx - xs[i][0] - 1 : (dir == 2 ? xs[i][1] : maxx - xs[i][1] - 1)));\n      cnt[x]++;\n    }\n    for (int i = 1; i < maxx; i++) {\n      cnt[i] += cnt[i - 1];\n    }\n    for (int i = 0; i < m; i++) {\n      if (qs[i][0] != dir) {\n        continue;\n      }\n      int x = (!(dir & 1) ? qs[i][1] : maxx - qs[i][1] - 1);\n      int b = qs[i][2];\n      if (cnt[x] > b) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nvector<int> g[maxn];\npair<long long, int> d[maxn];\nint p[maxn];\nint inside[maxn];\nvector<int> q;\n\nbool augment(long long &res) {\n  for (int i = 0; i < n + 2; i++) {\n    g[i].clear();\n  }\n  int s = n, t = n + 1;\n  for (int i = 0; i < n; i++) {\n    if (a[i]) {\n      continue;\n    }\n    {\n      a[i] = true;\n      if (check(0)) {\n        g[i].push_back(t);\n      }\n      if (check(1)) {\n        g[s].push_back(i);\n      }\n      a[i] = false;\n    }\n    for (int j = 0; j < n; j++) {\n      if (!a[j]) {\n        continue;\n      }\n      a[i] = true;\n      a[j] = false;\n      if (check(0)) {\n        g[i].push_back(j);\n      }\n      if (check(1)) {\n        g[j].push_back(i);\n      }\n      a[i] = false;\n      a[j] = true;\n    }\n  }\n  q.clear();\n  for (int i = 0; i < n + 2; i++) {\n    inside[i] = false;\n    d[i] = make_pair(infll, inf);\n    p[i] = -1;\n  }\n  d[s] = make_pair(0, 0);\n  q.push_back(s);\n  inside[s] = true;\n  for (int l = 0; l < sz(q); l++) {\n    int v = q[l];\n    inside[v] = false;\n    for (int i = 0; i < sz(g[v]); i++) {\n      int u = g[v][i];\n      long long w = (u < n ? (a[u] ? vs[u] : -vs[u]) : 0);\n      pair<long long, int> nd = make_pair(d[v].first + w, d[v].second + 1);\n      if (nd < d[u]) {\n        d[u] = nd;\n        p[u] = v;\n        if (!inside[u]) {\n          q.push_back(u);\n          inside[u] = true;\n        }\n      }\n    }\n  }\n  if (d[t].first >= infll) {\n    return false;\n  }\n  long long val = 0;\n  int v = p[t];\n  while (v != s) {\n    if (a[v]) {\n      val -= vs[v];\n    } else {\n      val += vs[v];\n    }\n    a[v] = !a[v];\n    v = p[v];\n  }\n  if (val < 0) {\n    return false;\n  }\n  res += val;\n  return true;\n}\n\nvoid solve() {\n  for (int i = 0; i < n; i++) {\n    a[i] = false;\n  }\n  long long res = 0;\n  while (augment(res)) ;\n  printf(\"%lld\\n\", res);\n}\n\nint main() {\n  precalc();\n#ifdef DEBUG\n  assert(freopen(TASK \".in\", \"r\", stdin));\n  assert(freopen(TASK \".out\", \"w\", stdout));\n#endif\n  while (read()) {\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#define mp(a, b) make_pair(a, b)\n//#define int long long\nusing namespace std;\ntypedef pair<int, long long> pp;\nconst int maxn = 100100;\nconst long long oo = 1e17;\nconst int ioo = 1e9;\nstruct edges\n{\n\tint to, next, f;\n\tlong long c;\n}edge[maxn << 1];\nint point[maxn] = {0}, te = 1;\nvoid add(int a, int b, int c, long long d)\n{\n\tte ++;\n\tedge[te].to = b;\n\tedge[te].next = point[a];\n\tedge[te].f = c;\n\tedge[te].c = d;\n\tpoint[a] = te;\n}\nvoid adde(int a, int b, int c, long long d)\n{\n\t//cout << a << \" \" << b << \" \" << c << \" \" << d << endl;\n\tadd(a, b, c, d);\n\tadd(b, a, 0, -d);\n}\nint st = 0, ed = 0;\nlong long dis[maxn];\nqueue<int> q;\nbool in[maxn];\nbool spfa()\n{\n\tfor(int i = st; i <= ed; i ++)\n\t\tdis[i] = oo;\n\tdis[st] = 0;\n\tq.push(st);\n\tin[st] = 1;\n\twhile(!q.empty())\n\t{\n\t\tint now = q.front();\n\t\tq.pop();\n\t\tin[now] = 0;\n\t\tfor(int e = point[now]; e; e = edge[e].next)\n\t\t\tif(edge[e].f && dis[edge[e].to] > dis[now] + edge[e].c)\n\t\t\t{\n\t\t\t\tdis[edge[e].to] = dis[now] + edge[e].c;\n\t\t\t\tif(!in[edge[e].to])\n\t\t\t\t{\n\t\t\t\t\tin[edge[e].to] = 1;\n\t\t\t\t\tq.push(edge[e].to);\n\t\t\t\t}\n\t\t\t}\n\t}\n\treturn dis[ed] < oo;\n}\nint cur[maxn];\nbool flag[maxn] = {0};\npp dfs(int now, int min0)\n{\n\tif(now == ed || min0 == 0)\n\t\treturn mp(min0, 0);\n\tflag[now] = 1;\n\tpp flow;\n\tflow.first = flow.second = 0;\n\tfor(int &e = cur[now]; e; e = edge[e].next)\n\t\tif(edge[e].f && dis[edge[e].to] == dis[now] + edge[e].c && !flag[edge[e].to])\n\t\t{\n\t\t\tpp ff = dfs(edge[e].to, min(min0, edge[e].f));\n\t\t\tif(ff.first)\n\t\t\t{\n\t\t\t\tedge[e].f -= ff.first;\n\t\t\t\tmin0 -= ff.first;\n\t\t\t\tedge[e ^ 1].f += ff.first;\n\t\t\t\tflow.first += ff.first;\n\t\t\t\tflow.second += edge[e].c * ff.first + ff.second;\n\t\t\t\tif(min0 == 0)\n\t\t\t\t{\n\t\t\t\t\tflag[now] = 0;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tflag[now] = 0;\n\treturn flow;\n}\npp sum;\nvoid dinic()\n{\n\tsum.first = sum.second = 0;\n\twhile(spfa())\n\t{\n\t\tfor(int i = st; i <= ed; i ++)\n\t\t\tcur[i] = point[i];\n\t\tpp a = dfs(st, ioo);\n\t\tsum.first += a.first;\n\t\tsum.second += a.second;\n\t}\n}\nlong long ans = 0;\nint n, m;\nint x[maxn], y[maxn];\nlong long v[maxn];\nstruct cons\n{\n\tchar t;\n\tint a, b;\n}con[maxn];\nint xmn[maxn], xmx[maxn], ymn[maxn], ymx[maxn];\nvoid work(int k)\n{\n\tte = 1;\n\tfor(int i = st; i <= ed; i ++)\n\t\tpoint[i] = 0;\n\tst = 0, ed = k * 2 + n * 2 + 1;\n\tfor(int i = 1; i <= k; i ++)\n\t\txmx[i] = ymx[i] = ioo;\n\tfor(int i = 1; i <= m; i ++)\n\t{\n\t\tif(con[i].t == 'L' && con[i].b < k)\n\t\t\txmn[con[i].b + 1] = max(xmn[con[i].b + 1], con[i].a + 1);\n\t\telse if(con[i].t == 'R' && con[i].b < k)\n\t\t\txmx[k - con[i].b] = min(xmx[k - con[i].b], con[i].a - 1);\n\t\telse if(con[i].t == 'D' && con[i].b < k)\n\t\t\tymn[con[i].b + 1] = max(ymn[con[i].b + 1], con[i].a + 1);\n\t\telse if(con[i].t == 'U' && con[i].b < k)\n\t\t\tymx[k - con[i].b] = min(con[i].a - 1, ymx[k - con[i].b]);\n\t}\n\tfor(int i = 2; i <= k; i ++)\n\t{\n\t\txmn[i] = max(xmn[i - 1], xmn[i]);\n\t\tymn[i] = max(ymn[i - 1], ymn[i]);\n\t}\n\tfor(int i = k - 1; i >= 1; i --)\n\t{\n\t\txmx[i] = min(xmx[i], xmx[i + 1]);\n\t\tymx[i] = min(ymx[i], ymx[i + 1]);\n\t}\n\t/*\n\tfor(int i = 1; i <= k; i ++)\n\t\tcout << i << \" \" << xmn[i] << \" \" << xmx[i] << \" \" << ymn[i] << \" \" << ymx[i] << endl;\n\t*/\n\tfor(int i = 1; i <= k; i ++)\n\t\tadde(st, i, 1, 0);\n\tfor(int i = 1; i <= k; i ++)\n\t{\n\t\tfor(int j = 1; j <= n; j ++)\n\t\t\tif(xmn[i] <= x[j] && x[j] <= xmx[i])\n\t\t\t\tadde(i, j + k, 1, 0);\n\t}\n\tfor(int i = 1; i <= n; i ++)\n\t\tadde(i + k, i + n + k, 1, -v[i]);\n\tfor(int i = 1; i <= k; i ++)\n\t{\n\t\tfor(int j = 1; j <= n; j ++)\n\t\t\tif(ymn[i] <= y[j] && y[j] <= ymx[i])\n\t\t\t\tadde(j + n + k, i + n + k + n, 1, 0);\n\t}\n\tfor(int i = 1; i <= k; i ++)\n\t\tadde(i + n + n + k, ed, 1, 0);\n\tdinic();\n\t//cout << sum.first << endl;\n\tif(sum.first == k)\n\t\tans = max(ans, -sum.second);\n}\nsigned main()\n{\n\tstd::ios::sync_with_stdio(false);\n\tcin >> n;\n\tfor(int i = 1; i <= n; i ++)\n\t\tcin >> x[i] >> y[i] >> v[i];\n\tcin >> m;\n\tfor(int i = 1; i <= m; i ++)\n\t\tcin >> con[i].t >> con[i].a >> con[i].b;\n\tst = 0;\n\t//work(3);\n\t\n\tfor(int k = 1; k <= n; k ++)\n\t\twork(k);\n\t\t\n\tcout << ans << endl;\n\treturn 0;\n}\n/*\n4\n1 6 6\n1 2 2\n9 3 9\n6 4 4\n4\nD 10 1\nL 8 2\nD 1 1\nR 4 1\n*/"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-03-27 10:28:38\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\n#define i64 long long\ni64 read()\n{\n\ti64 r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\nconst int N=2010;\nnamespace run\n{\n\tconst i64 inf=1ll<<60;\n\ti64 n,px[N],sx[N],py[N],sy[N],begin[N],next[N<<2],to[N<<2],w[N<<2],c[N<<2],e,S,T,m,x[N],y[N],v[N],ans,l,sw,sc;\n\ti64 d[N],q[N*N],_l,_r,pre[N],vis[N];\n\tvoid add(i64 u,i64 v,i64 W,i64 C){ e++; next[e]=begin[u]; begin[u]=e; to[e]=v; w[e]=W; c[e]=C; }\n\tvoid Add(i64 u,i64 v,i64 w,i64 c){ /*printf(\"%I64d %I64d %I64d\\n\",u,v,c);*/ add(u,v,w,c); add(v,u,0,-c); }\n#define fo(i,a) for(int i=begin[a];i;i=next[i])\n\tint bfs()\n\t{\n\t\tfr(i,1,m){ d[i]=-inf; pre[i]=0; vis[i]=0; }\n\t\tq[_l=_r=1]=S; d[S]=0;\n\t\twhile(_l<=_r)\n\t\t{\n\t\t\tint u=q[_l++]; vis[u]=0;\n//\t\t\tprintf(\"%d\\n\",u);\n\t\t\tfo(i,u) if(w[i]&&d[u]+c[i]>d[to[i]])\n\t\t\t{\n\t\t\t\td[to[i]]=d[u]+c[i]; pre[to[i]]=i;\n\t\t\t\tif(!vis[to[i]]){ q[++_r]=to[i]; vis[to[i]]=1; }\n\t\t\t}\n\t\t}\n\t\treturn d[T]!=-inf;\n\t}\n\ti64 solve(int c)\n\t{\n\t\tmemset(begin,0,sizeof(begin)); e=1; S=n+n+c+c+1; T=n+n+c+c+2; m=T;\n//\t\tprintf(\"%d %I64d %I64d\\n\",c,S,T);\n\t\tfr(i,1,n) Add(i,i+n,1,v[i]);\n\t\tfr(j,1,c){ Add(S,j+n+n,1,0); Add(j+n+n+c,T,1,0); }\n\t\tfr(i,1,n) fr(j,1,c) if(px[x[i]]>=j&&sx[x[i]]>=c-j+1) Add(j+n+n,i,1,0);\n\t\tfr(i,1,n) fr(j,1,c) if(py[y[i]]>=j&&sy[y[i]]>=c-j+1) Add(i+n,j+n+n+c,1,0);\n\t\tsw=sc=0;\n\t\twhile(bfs())\n\t\t{\n//\t\t\tprintf(\"%I64d\\n\",d[T]);\n\t\t\tint u=T; sw++;\n\t\t\twhile(u!=S){ w[pre[u]]--; w[pre[u]^1]++; sc+=::run::c[pre[u]]; u=to[pre[u]^1]; }\n\t\t}\n//\t\tprintf(\"%d %I64d\\n\",c,sw==c?sc:0);\n\t\treturn sw==c?sc:0;\n\t}\n\tint main()\n\t{\n\t\tn=read(); l=100;\n\t\tfr(i,1,n){ x[i]=read(); y[i]=read(); v[i]=read(); }\n\t\tfr(i,0,l+1) px[i]=sx[i]=py[i]=sy[i]=n;\n\t\tfr(i,1,read())\n\t\t{\n\t\t\tchar opt[N]; i64 a,b;\n\t\t\tscanf(\"%s\",opt); a=read(); b=read();\n\t\t\tif(*opt=='L') px[a]=std::min(px[a],b);\n\t\t\tif(*opt=='R') sx[a]=std::min(sx[a],b);\n\t\t\tif(*opt=='D') py[a]=std::min(py[a],b);\n\t\t\tif(*opt=='U') sy[a]=std::min(sy[a],b);\n\t\t}\n\t\tfr(i,1,l){ sx[i]=std::min(sx[i],sx[i-1]); sy[i]=std::min(sy[i],sy[i-1]); }\n\t\tfd(i,l,1){ px[i]=std::min(px[i],px[i+1]); py[i]=std::min(py[i],py[i+1]); }\n//\t\tfr(i,1,n) printf(\"%I64d %I64d %I64d %I64d\\n\", );\n\t\tfr(i,1,n){ i64 k=solve(i); ans=std::max(ans,k); if(!k) break; }\n\t\tprintf(\"%lld\\n\",ans);\n\t\treturn 0;\n\t}\n}\nint main(){ return run::main(); }"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 505\n#define inf 1000000007\nusing namespace std;\ntypedef long long ll;\nll read()\n{\n    ll x=0,f=1;\n    char ch=getchar();\n    while(ch-'0'<0||ch-'0'>9){if(ch=='-') f=-1;ch=getchar();}\n    while(ch-'0'>=0&&ch-'0'<=9){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nint n,m,s,t;\nstruct P{\n    int x,y;\n    ll v;\n}p[85];\nstruct X{\n    char d;\n    int a,b;\n}co[325];\nint Lx[85],Rx[85],Ly[85],Ry[85];\nint head[325],nxt[140010],to[140010],c[140010],tot;\nll v[140010];\nvoid add(int x,int y,int z,ll u)\n{\n    tot++;\n    nxt[tot]=head[x];\n    head[x]=tot;\n    to[tot]=y;\n    c[tot]=z;\n    v[tot]=u;\n}\nvoid addx(int x,int y,int z,ll u)\n{\n    add(x,y,z,u);\n    add(y,x,0,-u);\n}\nll ans,res,dis[325];\nint vis[325],pre[325],pre_num[325];\nqueue<int>q;\nint spfa()\n{\n    for(int i=1;i<=t;i++)  dis[i]=-1e18;\n    dis[s]=0;q.push(s);vis[s]=1;\n    while(q.size())\n    {\n        int now=q.front();q.pop();vis[now]=0;\n        for(int i=head[now];i;i=nxt[i])\n        {\n            if(dis[to[i]]<dis[now]+v[i]&&c[i])\n            {\n                dis[to[i]]=dis[now]+v[i];\n                pre[to[i]]=now;\n                pre_num[to[i]]=i;\n                if(!vis[to[i]])  q.push(to[i]),vis[to[i]]=1;\n            }\n        }\n    }\n    if(dis[t]==-1e18)  return 0;\n    int di=inf;\n    for(int i=t;i!=s;i=pre[i])  di=min(di,c[pre_num[i]]);\n    for(int i=t;i!=s;i=pre[i])  c[pre_num[i]]-=di,c[pre_num[i]^1]+=di;\n    ans+=dis[t]*di;\n    return di;\n}\nint main()\n{\n    n=read();\n    for(int i=1;i<=n;i++)  p[i].x=read(),p[i].y=read(),p[i].v=read();\n    m=read();\n    for(int i=1;i<=m;i++)  co[i].d=getchar(),co[i].a=read(),co[i].b=read();\n    for(int k=1;k<=n;k++)\n    {\n        tot=1;memset(head,0,sizeof(head));\n        s=2*k+2*n+1;t=s+1;\n        for(int i=1;i<=k;i++)  addx(s,i,1,0);\n        for(int i=k+2*n+1;i<=2*n+2*k;i++)  addx(i,t,1,0);\n        for(int i=k+1;i<=k+n;i++)  addx(i,i+n,1,p[i-k].v);\n        for(int i=1;i<=k;i++)  Lx[i]=Ly[i]=0,Rx[i]=Ry[i]=inf;\n        for(int i=1;i<=m;i++)\n        {\n            if(co[i].d=='U')\n            {\n                for(int j=1;j<=k-co[i].b;j++)  Ry[j]=min(Ry[j],co[i].a-1);\n            }\n            if(co[i].d=='D')\n            {\n                for(int j=co[i].b+1;j<=k;j++)  Ly[j]=max(Ly[j],co[i].a+1);\n            }\n            if(co[i].d=='L')\n            {\n                for(int j=co[i].b+1;j<=k;j++)  Lx[j]=max(Lx[j],co[i].a+1);\n            }\n            if(co[i].d=='R')\n            {\n                for(int j=1;j<=k-co[i].b;j++)  Rx[j]=min(Rx[j],co[i].a-1);\n            }\n        }\n        for(int i=1;i<=k;i++)\n          for(int j=1;j<=n;j++)\n            if(Lx[i]<=p[j].x&&p[j].x<=Rx[i])  addx(i,k+j,1,0);\n        for(int i=1;i<=k;i++)\n          for(int j=1;j<=n;j++)\n            if(Ly[i]<=p[j].y&&p[j].y<=Ry[i])  addx(k+n+j,k+2*n+i,1,0);\n        ans=0;\n        while(spfa()){};\n        res=max(res,ans);   \n    }\n    cout<<res<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define N 1010\n#define M 200010\n#define int long long\n#define INF 4611686018427387904LL\ninline int read() {\n    int x=0;\n    char ch=getchar();\n    while (!isdigit(ch)) ch=getchar();\n    while (isdigit(ch)) x=x*10+ch-'0',ch=getchar();\n    return x;\n}\nstruct Point {\n    int x,y,val;\n}p[N];\nstruct opt {\n    char ch; int x,y;\n}a[N];\nint tot=1;\nint fir[N],nex[M],got[M],tak[M],cst[M];\ninline void AddEdge(int x,int y,int z,int w) { \n    nex[++tot]=fir[x],fir[x]=tot,got[tot]=y,tak[tot]=z,cst[tot]=w;\n}\ninline void Add(int x,int y,int z,int w) {\n    AddEdge(x,y,z,w),AddEdge(y,x,0,-w);\n}\nint xl[N],xr[N],yl[N],yr[N];\nint vis[N],dis[N],pre[N],que[N];\ninline int spfa(int s,int t) {\n    int l=1,r=1;\n    for (int i=1;i<=t;i++) vis[i]=false,dis[i]=-INF,pre[i]=0;\n    que[1]=s,dis[s]=0;\n    while (l<=r) {\n        int x=que[l];\n        for (int i=fir[x];i;i=nex[i]) {\n            int y=got[i],w=cst[i];\n            if (!tak[i] || dis[x]+w<=dis[y]) continue;\n            dis[y]=dis[x]+w,pre[y]=i;\n            if (!vis[y]) vis[y]=true,que[++r]=y;\n        }\n        ++l,vis[x]=false;\n    }\n    return dis[t]!=-INF;\n}\ninline int getflow(int s,int t) {\n    int flow=INF;\n    for (int i=t;i!=s;i=got[pre[i]^1]) {\n        flow=min(flow,tak[pre[i]]);\n    }\n    return flow;\n}\ninline void update(int s,int t,int flow,int &Maxflow,int &Mincost) {\n    Maxflow+=flow,Mincost+=flow*dis[t];\n    for (int i=t;i!=s;i=got[pre[i]^1]) {\n        tak[pre[i]]-=flow,tak[pre[i]^1]+=flow;\n    }\n}\ninline int solve(int s,int t) {\n    int Maxflow=0,Mincost=0;\n    while (spfa(s,t)) {\n        update(s,t,getflow(s,t),Maxflow,Mincost);\n    }\n    return Mincost;\n}\nsigned main() {\n    int n=read();\n    for (int i=1;i<=n;i++)\n        p[i].x=read(),p[i].y=read(),p[i].val=read();\n    int m=read(),res=0;\n    for (int i=1;i<=m;i++) {\n        char ch=getchar();\n        while (ch!='U' && ch!='D' && ch!='L' && ch!='R') ch=getchar();\n        a[i].ch=ch,a[i].x=read(),a[i].y=read();\n    }\n    for (int k=1;k<=n;k++) {\n        tot=1,memset(fir,0,sizeof(fir));\n        int s=(k<<1)+(n<<1)+1,t=s+1;\n        for (int i=1;i<=k;i++) Add(s,i,1,0);\n        for (int i=k+2*n+1;i<=2*k+2*n;i++) Add(i,t,1,0);\n        for (int i=k+1;i<=k+n;i++) Add(i,i+n,1,p[i-k].val);\n        for (int i=1;i<=k;i++) xl[i]=yl[i]=0,xr[i]=yr[i]=INF;\n        for (int i=1;i<=m;i++) {\n            if (a[i].ch=='U') for (int j=1;j<=k-a[i].y;j++) yr[j]=min(yr[j],a[i].x-1);\n            if (a[i].ch=='D') for (int j=a[i].y+1;j<=k;j++) yl[j]=max(yl[j],a[i].x+1);\n            if (a[i].ch=='L') for (int j=a[i].y+1;j<=k;j++) xl[j]=max(xl[j],a[i].x+1);\n            if (a[i].ch=='R') for (int j=1;j<=k-a[i].y;j++) xr[j]=min(xr[j],a[i].x-1);\n        }\n        for (int i=1;i<=k;i++) for (int j=1;j<=n;j++)\n            if (xl[i]<=p[j].x && p[j].x<=xr[i]) Add(i,j+k,1,0);\n        for (int i=1;i<=k;i++) for (int j=1;j<=n;j++)\n            if (yl[i]<=p[j].y && p[j].y<=yr[i]) Add(j+k+n,i+k+2*n,1,0);\n        res=max(res,solve(s,t));\n    }\n    cout<<res<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\n  _|_|                              _|  _|    _|\n_|    _|  _|  _|_|  _|_|_|_|        _|  _|  _|\n_|    _|  _|_|          _|          _|  _|_|\n_|    _|  _|          _|      _|    _|  _|  _|\n  _|_|    _|        _|_|_|_|    _|_|    _|    _|\n\n*/\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<set>\n//#define ls (rt<<1)\n//#define rs (rt<<1|1)\n#define vi vector<int>\n#define pb push_back\n#define mk make_pair\n#define pii pair<ll,ll>\n#define rep(i,a,b) for(int i=(a),i##end=(b);i<=i##end;i++)\n#define fi first\n#define se second\n#define int long long\ntypedef long long ll;\nusing namespace std;\nconst int maxn=420;\nconst int inf=1e18+100;\nint xl[maxn],xr[maxn],yl[maxn],yr[maxn],s=415,t=416;\nint head[maxn],cnt=1;\nstruct gg{\n    int u,v,w;ll cost;int next;\n    void insert(int U,int V,int W,ll Cost,int Next){\n        u=U,v=V,w=W,cost=Cost,next=Next;\n    }\n}side[(maxn*maxn)*2];\nstruct Point{\n    int x,y;\n    ll cost=0;\n}point[maxn];\nstruct Lim{\n    int a,b;char c;\n}lim[maxn];\nvoid ins(int u,int v,int w,ll cost){\n    side[++cnt].insert(u,v,w,cost,head[u]);head[u]=cnt;\n    side[++cnt].insert(v,u,0,-cost,head[v]);head[v]=cnt;\n}\nint n,m;\nvoid init(int k){\n    rep(i,1,k)xl[i]=yl[i]=-inf,xr[i]=yr[i]=inf;\n    rep(i,1,m){\n        if(lim[i].c=='L')rep(j,lim[i].b+1,k)xl[j]=max(xl[j],lim[i].a+1);\n        else if(lim[i].c=='R')for(int j=k-lim[i].b;j>0;j--)xr[j]=min(xr[j],lim[i].a-1);\n        else if(lim[i].c=='D')rep(j,lim[i].b+1,k)yl[j]=max(yl[j],lim[i].a+1);\n        else if(lim[i].c=='U')for(int j=k-lim[i].b;j>0;j--)yr[j]=min(yr[j],lim[i].a-1);\n    }\n    memset(head,0,sizeof(head));cnt=1;\n    rep(i,1,k)ins(s,2*n+i,1,0);\n    rep(i,1,k)ins(2*n+k+i,t,1,0);\n    rep(i,1,n){\n        ins(i,n+i,1,point[i].cost);\n        rep(j,1,k){\n            if(xl[j]<=point[i].x&&point[i].x<=xr[j])ins(2*n+j,i,1,0);\n            if(yl[j]<=point[i].y&&point[i].y<=yr[j])ins(n+i,2*n+k+j,1,0);\n        }\n    }\n}\nint q[maxn*30];\nll dis[maxn],lenth;\nbool vis[maxn];\nbool spfa(){\n    rep(i,1,maxn-1)dis[i]=-inf;\n    memset(vis,0,sizeof(vis));\n    int hd=1,tl=1;q[hd]=s;vis[s]=1;dis[s]=0;\n    while(hd<=tl){\n        int u=q[hd++];vis[u]=0;//cout<<u<<' '<<endl;\n        for(int i=head[u];i;i=side[i].next){\n            int v=side[i].v;if(!side[i].w)continue;\n            if(dis[u]+side[i].cost>dis[v]){\n                dis[v]=dis[u]+side[i].cost;\n                if(!vis[v])q[++tl]=v;\n                vis[v]=1;\n            }\n        }\n    }\n    if(dis[t]!=-inf)return 1;\n    return 0;\n}\nint dfs(int u,int flow){\n    if(u==t)return flow;\n    vis[u]=1;int tot=0;\n    for(int i=head[u];i;i=side[i].next){\n        int v=side[i].v;if(vis[v]||!side[i].w||dis[v]!=dis[u]+side[i].cost)continue;\n        int sent=dfs(v,min(flow,side[i].w));\n        lenth+=1ll*side[i].cost*sent,side[i].w-=sent,side[i^1].w+=sent,tot+=sent;flow-=sent;\n    }\n    // vis[u]=0;\n    return tot;\n}\npii dinic(){\n    int mxflow=0;lenth=0;\n    while(spfa()){\n        int x;\n        while((x=dfs(s,inf)))mxflow+=x;\n    }\n    return mk(mxflow,lenth);\n}\nchar tmp[3];\nsigned main(){\n    scanf(\"%lld\",&n);\n    rep(i,1,n)scanf(\"%lld%lld%lld\",&point[i].x,&point[i].y,&point[i].cost);\n    scanf(\"%lld\",&m);\n    rep(i,1,m){\n        scanf(\"%s%lld%lld\",tmp+1,&lim[i].a,&lim[i].b);lim[i].c=tmp[1];\n    }\n    ll out=0;\n    rep(k,1,n){\n        init(k);\n        pii ans=dinic();out=max(out,ans.se);//cout<<ans.se<<endl;\n    }\n    cout<<out;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<queue>\nusing namespace std;\ntypedef long long ll;\nconst int N=1000005;\nqueue<int> q;\nint n,m,x[N],y[N],lt1[N],rt1[N],lt2[N],rt2[N],a[400],b[400],Flow,pre[N],lst[N],A[N],i,j,k,l,head[N],adj[N],nxt[N],flow[N],cap[N],cnt;\nbool v[N];\nll val[N],cost[N],Cost,dis[N],ans;\nchar s[400][10];\nvoid addedge(int u,int v,int w,ll c)\n{\n\tadj[++l]=v;\n\tnxt[l]=head[u];\n\thead[u]=l;\n\tflow[l]=0;\n\tcap[l]=w;\n\tcost[l]=c;\n\tadj[++l]=u;\n\tnxt[l]=head[v];\n\thead[v]=l;\n\tflow[l]=0;\n\tcap[l]=0;\n\tcost[l]=-c;\n}\nbool spfa()\n{\n\tint i,j;\n\tfor(i=1;i<=cnt;++i)\n\t\tdis[i]=-(1ll<<60),v[i]=false;\n\tdis[cnt-1]=0;\n\tq.push(cnt-1);\n\tv[cnt-1]=true;\n\tA[cnt-1]=1<<30;\n\twhile(!q.empty())\n\t{\n\t\ti=q.front();\n\t\tq.pop();\n\t\tfor(j=head[i];j;j=nxt[j])\n\t\t\tif(flow[j]<cap[j]&&dis[i]+cost[j]>dis[adj[j]])\n\t\t\t{\n\t\t\t\tdis[adj[j]]=dis[i]+cost[j];\n\t\t\t\tA[adj[j]]=min(A[i],cap[j]-flow[j]);\n\t\t\t\tpre[adj[j]]=i;\n\t\t\t\tlst[adj[j]]=j;\n\t\t\t\tif(!v[adj[j]])\n\t\t\t\t{\n\t\t\t\t\tv[adj[j]]=true;\n\t\t\t\t\tq.push(adj[j]);\n\t\t\t\t}\n\t\t\t}\n\t}\n\tif(dis[cnt]==-(1ll<<60))\n\t\treturn false;\n\tFlow+=A[cnt];\n\tCost+=A[cnt]*dis[cnt];\n\ti=cnt;\n\twhile(i!=cnt-1)\n\t{\n\t\tflow[lst[i]]+=A[cnt];\n\t\tflow[lst[i]&1?lst[i]+1:lst[i]-1]-=A[cnt];\n\t\ti=pre[i];\n\t}\n\treturn true;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;++i)\n\t\tscanf(\"%d%d%lld\",x+i,y+i,val+i);\n\tscanf(\"%d\",&m);\n\tfor(i=1;i<=m;++i)\n\t\tscanf(\"%s%d%d\",s[i],a+i,b+i);\n\tfor(i=1;i<=n;++i)\n\t{\n\t\tfor(j=1;j<=i;++j)\n\t\t\tlt1[j]=lt2[j]=1,rt1[j]=rt2[j]=100;\n\t\tfor(j=1;j<=m;++j)\n\t\tif(b[j]<i)\n\t\t{\n\t\t\tif(s[j][0]=='L')\n\t\t\t\tlt1[b[j]+1]=max(lt1[b[j]+1],a[j]+1);\n\t\t\telse if(s[j][0]=='R')\n\t\t\t\trt1[i-b[j]]=min(rt1[i-b[j]],a[j]-1);\n\t\t\telse if(s[j][0]=='D')\n\t\t\t\tlt2[b[j]+1]=max(lt2[b[j]+1],a[j]+1);\n\t\t\telse\n\t\t\t\trt2[i-b[j]]=min(rt2[i-b[j]],a[j]-1);\n\t\t}\n\t\tfor(j=2;j<=i;++j)\n\t\t{\n\t\t\tlt1[j]=max(lt1[j-1],lt1[j]);\n\t\t\tlt2[j]=max(lt2[j-1],lt2[j]);\n\t\t}\n\t\tfor(j=i-1;j>=1;--j)\n\t\t{\n\t\t\trt1[j]=min(rt1[j+1],rt1[j]);\n\t\t\trt2[j]=min(rt2[j+1],rt2[j]);\n\t\t}\n\t\tfor(j=1;j<=2+2*n+2*i;++j)\n\t\t\thead[j]=0;\n\t\tl=0;\n\t\tfor(j=1;j<=i;++j)\n\t\t{\n\t\t\taddedge(2*n+2*i+1,j,1,0);\n\t\t\taddedge(i+j,2*n+2*i+2,1,0);\n\t\t\tfor(k=1;k<=n;++k)\n\t\t\t{\n\t\t\t\tif(x[k]>=lt1[j]&&x[k]<=rt1[j])\n\t\t\t\t\taddedge(j,2*i+k,1,0);\n\t\t\t\tif(y[k]>=lt2[j]&&y[k]<=rt2[j])\n\t\t\t\t\taddedge(2*i+n+k,i+j,1,0);\n\t\t\t}\n\t\t}\n\t\tfor(j=1;j<=n;++j)\n\t\t\taddedge(2*i+j,2*i+n+j,1,val[j]);\n\t\tcnt=2+2*n+2*i;\n\t\tCost=Flow=0;\n\t\twhile(spfa());\n\t\tif(Flow<i)\n\t\t\tbreak;\n\t\tans=max(ans,Cost);\n\t}\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nostream &operator<<(ostream &os, __float128 f) { return os << (LD)f; }\n\n\nstruct Simplex {        // Maximize c*x subject to Ax <= b.\n  using T = LD;         // Initialize the structure, set A, b, c and then run\n  vector<vector<T>> A;  // solve(). Max objective is stored in res. To recover\n  vector<T> b, c;       // the best result, use getVars().\n  T abs(T x) { return x < 0 ? -x : x; }\n\n  int V, E;\n  VI eqIds, varIds, cols;\n  T res;\n  const LD kEps = 1e-9;\n\n  Simplex(int vars, int eqs) : A(eqs, vector<T>(vars)), b(eqs), c(vars),\n                               V(vars), E(eqs), eqIds(eqs), varIds(vars), res(0) {\n    iota(ALL(varIds), 0); iota(ALL(eqIds), vars);\n  }\n\n  void pivot(int eq, int var) {\n    T coef = 1 / A[eq][var];\n    cols.clear();\n    REP (i, V) {\n      if (abs(A[eq][i]) > kEps) { cols.PB(i); A[eq][i] *= coef; }\n    }\n    A[eq][var] *= coef; b[eq] *= coef;\n    REP (row, E) {\n      if (row == eq || abs(A[row][var]) < kEps) { continue; }\n      T k = -A[row][var];\n      A[row][var] = 0;\n      for (int i : cols) { A[row][i] += k * A[eq][i]; }\n      b[row] += k * b[eq];\n    }\n    T q = c[var]; c[var] = 0;\n    for (int i : cols) { c[i] -= q * A[eq][i]; }\n    res += q * b[eq];\n\n    swap(varIds[var], eqIds[eq]);\n  }\n  \n  bool solve() {\n    while (true) {\n      int eq = -1, var = -1;\n      REP (i, E) { if (b[i] < -kEps) { eq = i; break; } }\n      if (eq == -1) { break; }\n      REP (i, V) { if (A[eq][i] < -kEps) { var = i; break; } }\n      if (var == -1) { res = -1e9; return false; /* No solution */ }\n      pivot(eq, var);\n    }\n\n    while (true) {\n      int var = -1, eq = -1;\n      REP (i, V) { if (c[i] > kEps) { var = i; break; } }\n      if (var == -1) { break; }\n      REP (i, E) {\n        if (A[i][var] < kEps) { continue; }\n        if (eq >= 0 && b[i] / A[i][var] >= b[eq] / A[eq][var]) { continue; }\n        eq = i;\n      }\n      if (eq == -1) { res = 1e9; return false; /* Unbounded */ }\n      pivot(eq, var);\n    }\n\n    return true;\n  }\n  \n  vector<T> getVars() {  // Optimal assignment of variables.\n    vector<T> result(V);\n    REP (i, E) { if (eqIds[i] < V) { result[eqIds[i]] = b[i]; } }\n    return result;\n  }\n};\n\nint N, M;\nvector<PII> points;\nVI point_vals;\n\nLL low_bound;\nclock_t time_start;\n\nvoid Solve(Simplex sim) {\n  Simplex sim_copy = sim;\n  assert(sim.solve());\n\n  if (sim.res - 1e-9 < low_bound) { return; }\n  auto vars = sim.getVars();\n\n  if ((clock() - time_start) > 4.9 * CLOCKS_PER_SEC) {\n    cout << low_bound << \"\\n\";\n    exit(0);\n  }\n\n  LL my_low = 0;\n  for (int i = 0; i < N; ++i) {\n    if (vars[i] > .99) {\n      my_low += point_vals[i];\n      //sim_copy.b[M + i * 2] = -1;\n    }\n  }\n\n  maxi(low_bound, my_low);\n  bool had_any = false;\n  for (int i = 0; i < N; ++i) {\n    if (vars[i] > .01 && vars[i] < .989) {\n      assert(vars[i] > .49 && vars[i] < .51);\n      had_any = true;\n    }\n  }\n\n  if (had_any) {\n    // take none?\n    for (int i = 0; i < N; ++i) {\n      if (vars[i] > .01 && vars[i] < .989) {\n        sim_copy.b[M + i * 2 + 1] = 0;\n      }\n    }\n    Solve(sim_copy);\n    for (int i = 0; i < N; ++i) {\n      if (vars[i] > .01 && vars[i] < .989) {\n        sim_copy.b[M + i * 2 + 1] = 1;\n      }\n    }\n  }\n\n  for (int i = 0; i < N; ++i) {\n    if (vars[i] > .01 && vars[i] < .989) {\n      // take?\n      sim_copy.b[M + i * 2] = -1;\n      Solve(sim_copy);\n      sim_copy.b[M + i * 2] = 0;\n      if (sim.res - 1e-9 < low_bound) { return; }\n    }\n  }\n\n}\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n  time_start = clock();\n\n  cin >> N;\n  points.resize(N);\n  point_vals.resize(N);\n\n  for (int i = 0; i < N; ++i) {\n    cin >> points[i].st >> points[i].nd >> point_vals[i];\n  }\n\n  map<char, function<bool(PII, int)>> checkers = {\n    {'L', [](const PII &pt, int a) { return pt.st <= a; }},\n    {'R', [](const PII &pt, int a) { return pt.st >= a; }},\n    {'D', [](const PII &pt, int a) { return pt.nd <= a; }},\n    {'U', [](const PII &pt, int a) { return pt.nd >= a; }}\n  };\n\n  cin >> M;\n\n  Simplex sim(N, M + 2 * N);\n  for (int i = 0; i < M; ++i) {\n    char type;\n    int a, b;\n    cin >> type >> a >> b;\n\n    for (int j = 0; j < N; ++j) {\n      sim.A[i][j] = checkers[type](points[j], a);\n    }\n    sim.b[i] = b;\n\n    debug(sim.A[i], sim.b[i]);\n  }\n  for (int i = 0; i < N; ++i) {\n    sim.c[i] = point_vals[i];\n    sim.A[M + i * 2][i] = -1;\n    sim.A[M + i * 2 + 1][i] = 1;\n    sim.b[M + i * 2] = 0;\n    sim.b[M + i * 2 + 1] = 1;\n  }\n  auto orig_a = sim.A;\n  auto orig_b = sim.b;\n\n  Solve(sim);\n  cout << low_bound << \"\\n\";\n\n  /*assert(sim.solve());\n  auto vars = sim.getVars();\n\n  vector<int> always, maybe;\n  debug(vars);\n  for (int i = 0; i < N; ++i) {\n    if (vars[i] > 0.7) {\n      always.PB(i);\n    } else if (vars[i] > 0.3) {\n      maybe.PB(i);\n    }\n  }\n\n  debug(always, maybe);\n\n  assert(SZ(maybe) <= 3);\n  LL ans = -1;\n\n  for (LL m = 0; m < (1LL << SZ(maybe)); ++m) {\n    vector<int> mine = always;\n    for (int j = 0; j < SZ(maybe); ++j) {\n      if ((m >> j) & 1) { mine.PB(maybe[j]); }\n    }\n\n    bool fail = false;\n    for (int i = 0; i < M; ++i) {\n      int cnt = 0;\n      for (int j : mine) {\n        if (orig_a[i][j] > 0.5) { ++cnt; }\n      }\n      debug(mine, i, cnt, orig_b[i]);\n      if (cnt > (int)round((LD)orig_b[i])) { debug(i); fail = true; }\n    }\n\n    if (fail) { continue; }\n    LL x = 0;\n    for (int i : mine) {\n      x += point_vals[i];\n    }\n    maxi(ans, x);\n  }\n\n  cout << ans << \"\\n\";*/\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <list>\n#include <time.h>\n#include <math.h>\n#include <random>\n#include <deque>\n#include <queue>\n#include <cassert>\n#include <unordered_map>\n#include <unordered_set>\n#include <iomanip>\n#include <bitset>\n#include <sstream>\n#include <chrono>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef long double dbl;\nconst int INF = 1.01e9;\n \nconst long double EPS = 1e-9;\nbool eq(long double x, long double y) {\n    return fabs(x - y) < EPS;\n}\nbool ls(long double x, long double y) {\n    return x < y && !eq(x, y);\n}\n \nvector<long double> simplex(vector<vector<long double> > a) {\n    int n = a.size() - 1;\n    int m = a[0].size() - 1;\n    vector<int> left(n + 1), up(m + 1);\n    iota(up.begin(), up.end(), 0);\n    iota(left.begin(), left.end(), m);\n    auto pivot = [&](int x, int y) {\n        swap(left[x], up[y]);\n        long double k = a[x][y];\n        a[x][y] = 1;\n        vector<int> vct;\n        for (int j = 0; j <= m; j++) {\n            a[x][j] /= k;\n            if (!eq(a[x][j], 0)) vct.push_back(j);\n        }\n        for (int i = 0; i <= n; i++) {\n            if (eq(a[i][y], 0) || i == x) continue;\n            k = a[i][y];\n            a[i][y] = 0;\n            for (int j : vct) a[i][j] -= k * a[x][j];\n        }\n    };\n    while (1) {\n        int x = -1;\n        for (int i = 1; i <= n; i++) if (ls(a[i][0], 0) && (x == -1 || a[i][0] < a[x][0])) x = i;\n        if (x == -1) break;\n        int y = -1;\n        for (int j = 1; j <= m; j++) if (ls(a[x][j], 0) && (y == -1 || a[x][j] < a[x][y])) y = j;\n        if (y == -1) assert(0); // infeasible\n        pivot(x, y);\n    }\n    while (1) {\n        int y = -1;\n        for (int j = 1; j <= m; j++) if (ls(0, a[0][j]) && (y == -1 || a[0][j] > a[0][y])) y = j;\n        if (y == -1) break;\n        int x = -1;\n        for (int i = 1; i <= n; i++) if (ls(0, a[i][y]) && (x == -1 || a[i][0] / a[i][y] < a[x][0] / a[x][y])) x = i;\n        if (x == -1) assert(0); // unbounded\n        pivot(x, y);\n    }\n    vector<long double> ans(m + 1);\n    for (int i = 1; i <= n; i++) if (left[i] <= m) ans[left[i]] = a[i][0];\n    ans[0] = -a[0][0];\n    return ans;\n}\n\n#ifdef ONPC\n  mt19937 rnd(228);\n#else\n  mt19937 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\n#endif\n\nint main()\n{\n#ifdef ONPC\n  freopen(\"a.in\", \"r\", stdin);\n#endif\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector <int> x(n), y(n);\n  vector <long double> v;\n  for (int i = 0; i < n; i++)\n  {\n    cin >> x[i] >> y[i];\n    long double x;\n    cin >> x;\n    v.push_back(x);\n  }\n  v.insert(v.begin(), 0);\n  int m;\n  cin >> m;\n  vector <vector <long double> > mat;\n  mat.push_back(v);\n  for (int i = 0; i < n; i++)\n  {\n    vector <long double> kek(n + 1);\n    kek[0] = kek[i + 1] = 1;\n    mat.push_back(kek);\n  }\n  for (int i = 0; i < m; i++)\n  {\n    char c;\n    cin >> c;\n    int a;\n    long double b;\n    cin >> a >> b;\n    vector <long double> arr = {b};\n    for (int j = 0; j < n; j++)\n    {\n      int grab = 0;\n      if (c == 'L' && x[j] <= a) grab = 1;\n      if (c == 'R' && x[j] >= a) grab = 1;\n      if (c == 'D' && y[j] <= a) grab = 1;\n      if (c == 'U' && y[j] >= a) grab = 1;\n      arr.push_back(grab);\n    }\n    mat.push_back(arr);\n  }\n  auto ret = simplex(mat);\n  ll ans = 0;\n  for (int i = 1; i < (int) ret.size(); i++)\n  {\n    if (ret[i] >= 0.5)\n    {\n      ans += v[i];\n    }\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nostream &operator<<(ostream &os, __float128 f) { return os << (LD)f; }\n\n\nstruct Simplex {        // Maximize c*x subject to Ax <= b.\n  using T = __float128; // Initialize the structure, set A, b, c and then run\n  vector<vector<T>> A;  // solve(). Max objective is stored in res. To recover\n  vector<T> b, c;       // the best result, use getVars().\n  T abs(T x) { return x < 0 ? -x : x; }\n\n  int V, E;\n  VI eqIds, varIds, cols;\n  T res;\n  const LD kEps = 1e-9;\n\n  Simplex(int vars, int eqs) : A(eqs, vector<T>(vars)), b(eqs), c(vars),\n                               V(vars), E(eqs), eqIds(eqs), varIds(vars), res(0) {\n    iota(ALL(varIds), 0); iota(ALL(eqIds), vars);\n  }\n\n  void pivot(int eq, int var) {\n    T coef = 1 / A[eq][var];\n    cols.clear();\n    REP (i, V) {\n      if (abs(A[eq][i]) > kEps) { cols.PB(i); A[eq][i] *= coef; }\n    }\n    A[eq][var] *= coef; b[eq] *= coef;\n    REP (row, E) {\n      if (row == eq || abs(A[row][var]) < kEps) { continue; }\n      T k = -A[row][var];\n      A[row][var] = 0;\n      for (int i : cols) { A[row][i] += k * A[eq][i]; }\n      b[row] += k * b[eq];\n    }\n    T q = c[var]; c[var] = 0;\n    for (int i : cols) { c[i] -= q * A[eq][i]; }\n    res += q * b[eq];\n\n    swap(varIds[var], eqIds[eq]);\n  }\n  \n  bool solve() {\n    while (true) {\n      int eq = -1, var = -1;\n      REP (i, E) { if (b[i] < -kEps) { eq = i; break; } }\n      if (eq == -1) { break; }\n      REP (i, V) { if (A[eq][i] < -kEps) { var = i; break; } }\n      if (var == -1) { res = -1e9; return false; /* No solution */ }\n      pivot(eq, var);\n    }\n\n    while (true) {\n      int var = -1, eq = -1;\n      REP (i, V) { if (c[i] > kEps) { var = i; break; } }\n      if (var == -1) { break; }\n      REP (i, E) {\n        if (A[i][var] < kEps) { continue; }\n        if (eq >= 0 && b[i] / A[i][var] >= b[eq] / A[eq][var]) { continue; }\n        eq = i;\n      }\n      if (eq == -1) { res = 1e9; return false; /* Unbounded */ }\n      pivot(eq, var);\n    }\n\n    return true;\n  }\n  \n  vector<T> getVars() {  // Optimal assignment of variables.\n    vector<T> result(V);\n    REP (i, E) { if (eqIds[i] < V) { result[eqIds[i]] = b[i]; } }\n    return result;\n  }\n};\n\nint N, M;\nvector<PII> points;\nVI point_vals;\n\nLL Solve(Simplex sim, LL low_bound) {\n  Simplex sim_copy = sim;\n  assert(sim.solve());\n\n  if (sim.res - 1e-9 < low_bound) { return 0; }\n  auto vars = sim.getVars();\n\n  LL my_low = 0;\n  for (int i = 0; i < N; ++i) {\n    if (vars[i] > .99) {\n      my_low += point_vals[i];\n      //sim_copy.b[M + i * 2] = -1;\n    }\n  }\n\n  maxi(low_bound, my_low);\n\n  for (int i = 0; i < N; ++i) {\n    if (vars[i] > .01 && vars[i] < .989) {\n      // take?\n      sim_copy.b[M + i * 2] = -1;\n      maxi(low_bound, Solve(sim_copy, low_bound));\n      // don't take?\n      sim_copy.b[M + i * 2] = 0;\n      sim_copy.b[M + i * 2 + 1] = 0;\n      maxi(low_bound, Solve(sim_copy, low_bound));\n      break;\n    }\n  }\n\n  return low_bound;\n}\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n\n  cin >> N;\n  points.resize(N);\n  point_vals.resize(N);\n\n  for (int i = 0; i < N; ++i) {\n    cin >> points[i].st >> points[i].nd >> point_vals[i];\n  }\n\n  map<char, function<bool(PII, int)>> checkers = {\n    {'L', [](const PII &pt, int a) { return pt.st <= a; }},\n    {'R', [](const PII &pt, int a) { return pt.st >= a; }},\n    {'D', [](const PII &pt, int a) { return pt.nd <= a; }},\n    {'U', [](const PII &pt, int a) { return pt.nd >= a; }}\n  };\n\n  cin >> M;\n\n  Simplex sim(N, M + 2 * N);\n  for (int i = 0; i < M; ++i) {\n    char type;\n    int a, b;\n    cin >> type >> a >> b;\n\n    for (int j = 0; j < N; ++j) {\n      sim.A[i][j] = checkers[type](points[j], a);\n    }\n    sim.b[i] = b;\n\n    debug(sim.A[i], sim.b[i]);\n  }\n  for (int i = 0; i < N; ++i) {\n    sim.c[i] = point_vals[i];\n    sim.A[M + i * 2][i] = -1;\n    sim.A[M + i * 2 + 1][i] = 1;\n    sim.b[M + i * 2] = 0;\n    sim.b[M + i * 2 + 1] = 1;\n  }\n  auto orig_a = sim.A;\n  auto orig_b = sim.b;\n\n  cout << Solve(sim, 0) << \"\\n\";\n\n  /*assert(sim.solve());\n  auto vars = sim.getVars();\n\n  vector<int> always, maybe;\n  debug(vars);\n  for (int i = 0; i < N; ++i) {\n    if (vars[i] > 0.7) {\n      always.PB(i);\n    } else if (vars[i] > 0.3) {\n      maybe.PB(i);\n    }\n  }\n\n  debug(always, maybe);\n\n  assert(SZ(maybe) <= 3);\n  LL ans = -1;\n\n  for (LL m = 0; m < (1LL << SZ(maybe)); ++m) {\n    vector<int> mine = always;\n    for (int j = 0; j < SZ(maybe); ++j) {\n      if ((m >> j) & 1) { mine.PB(maybe[j]); }\n    }\n\n    bool fail = false;\n    for (int i = 0; i < M; ++i) {\n      int cnt = 0;\n      for (int j : mine) {\n        if (orig_a[i][j] > 0.5) { ++cnt; }\n      }\n      debug(mine, i, cnt, orig_b[i]);\n      if (cnt > (int)round((LD)orig_b[i])) { debug(i); fail = true; }\n    }\n\n    if (fail) { continue; }\n    LL x = 0;\n    for (int i : mine) {\n      x += point_vals[i];\n    }\n    maxi(ans, x);\n  }\n\n  cout << ans << \"\\n\";*/\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <assert.h>\n#include <setjmp.h>\n#include <string.h>\n#define V 204\n#define MAXE 23333\n#define S 202\n#define T 203\n#define Min(x, y) ((x)<(y)?(x):(y))\n#define Max(x, y) ((x)>(y)?(x):(y))\n#define CMin(x, y) ((y)<x?(x=(y), 1):0)\n#define CMax(x, y) (x<(y)?(x=(y), 1):0)\n#define meow(args...) fprintf(stderr, args)\nint e, x[80], y[80], lim[4][102], head[V], next[MAXE], to[MAXE], cap[MAXE], from[V], diff[V];\nlong long v[80], cost[MAXE], dis[V], maxcost;\njmp_buf env;\nvoid adde(int u, int v, int w, long long c)\n{\n\tnext[e]=head[u], to[e]=v, cap[e]=w, cost[e]= c, head[u]=e++;\n\tnext[e]=head[v], to[e]=u, cap[e]=0, cost[e]=-c, head[v]=e++;\n}\nvoid add_edge(int u, int v, int max, int min, long long c)\n{\n\tCMax(min, 0);\n\tif(min>max) longjmp(env, 1);\n\tif(min<max) adde(u, v, max-min, c);\n\tdiff[u]+=min;\n\tdiff[v]-=min;\n\tmaxcost+=min*c;\n}\nint ford()\n{\n\tstatic int inq[V], queue[65536];\n\tunsigned short qhead=0, qtail=0;\n\tmemset(dis, 192, V*sizeof(long long));\n\tdis[S]=0;\n\tinq[queue[qtail++]=S]=1;\n\twhile(qhead!=qtail) {\n\t\tint x=queue[qhead++], i;\n\t\tinq[x]=0;\n\t\tfor(i=head[x]; ~i; i=next[i])\n\t\t\tif(cap[i] && CMax(dis[to[i]], dis[x]+cost[i])) {\n\t\t\t\tfrom[to[i]]=i;\n\t\t\t\tif(!inq[to[i]]) inq[queue[qtail++]=to[i]]=1;\n\t\t\t}\n\t}\n\treturn dis[T]>=-1e18;\n}\nint main()\n{\n\tint n, m, i, j;\n\tlong long ans=0;\n\tscanf(\"%d\", &n);\n\tfor(i=0; i<n; ++i) scanf(\"%d%d%lld\", &x[i], &y[i], &v[i]);\n\tscanf(\"%d\", &m);\n\tfor(i=0; i<4; ++i) for(j=1; j<=100; ++j) lim[i][j]=n;\n\tfor(i=0; i<m; ++i) {\n\t\tchar d[2];\n\t\tint a, b;\n\t\tscanf(\"%s%d%d\", d, &a, &b);\n\t\tlim[(d[0]=='R')+2*(d[0]=='U')+3*(d[0]=='D')][a]=b;\n\t}\n\tif(!setjmp(env)) {\n\t\tfor(j=1; j<=lim[1][1] && j<=lim[3][100]; ++j) {\n\t\t\tmaxcost=0;\n\t\t\tmemset(head, -1, V*sizeof(int));\n\t\t\tmemset(diff, 0, V*sizeof(int));\n\t\t\te=0;\n\t\t\tfor(i=1; i<=100; ++i) {\n\t\t\t\tadd_edge(i-1, i, lim[2][i], j-lim[3][i-1], 0);\n\t\t\t\tadd_edge(i+100, i+101, lim[0][i], j-lim[1][i+1], 0);\n\t\t\t}\n\t\t\tfor(i=0; i<n; ++i) adde(y[i], x[i]+100, 1, v[i]);\n\t\t\tadd_edge(201, 0, j, j, 0);\n\t\t\tfor(i=0; i<202; ++i) {\n\t\t\t\tif(diff[i]>0) adde(i, T,  diff[i], 0);\n\t\t\t\tif(diff[i]<0) adde(S, i, -diff[i], 0);\n\t\t\t}\n\t\t\twhile(ford()) {\n\t\t\t\tint flow=1e9;\n\t\t\t\tfor(i=T; i!=S; i=to[from[i]^1]) CMin(flow, cap[from[i]]);\n\t\t\t\tmaxcost+=flow*dis[T];\n\t\t\t\tfor(i=T; i!=S; i=to[from[i]^1]) {\n\t\t\t\t\tcap[from[i]]-=flow;\n\t\t\t\t\tcap[from[i]^1]+=flow;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(i=head[S]; ~i; i=next[i]) if(cap[i]) longjmp(env, 1);\n\t\t\tCMax(ans, maxcost);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nint M;\n\nbool CanAchieve(const VI &numbers, int bound) {\n  const int S = SZ(numbers);\n\n  vector<int> max_small(S);// min_large(S), max_large(S);\n  int rptr_small = S - 1;\n  for (int lptr = 0; lptr < S; ++lptr) {\n    while (rptr_small >= 0 && numbers[lptr] + numbers[rptr_small] > bound) { --rptr_small; }\n    //while (rptr_large >= 0 && numbers[lptr] + numbers[rptr_large] > bound + M) { --rptr_large; }\n    //while (lptr_large > 0 && numbers[lptr] + numbers[lptr_large-1] >= M) { --lptr_large; }\n    max_small[lptr] = rptr_small;\n    //max_large[lptr] = rptr_large;\n    //min_large[lptr] = lptr_large;\n  }\n\n  vector<int> left_large(S), right_large(S);\n  int lptr_left = 0, lptr_right = -1;\n  for (int rptr = S - 1; rptr >= 0; --rptr) {\n    while (lptr_left < S && numbers[rptr] + numbers[lptr_left] < M) { ++lptr_left; }\n    while (lptr_right < S-1 && numbers[rptr] + numbers[lptr_right+1] <= M+bound) { ++lptr_right; }\n    left_large[rptr] = lptr_left;\n    right_large[rptr] = lptr_right;\n  }\n\n  debug(numbers, bound, max_small, left_large, right_large);\n\n  int max_left = 0;\n  {\n    int bound_left = 1e9;\n    for (int size_left = 2; size_left <= S; size_left += 2) {\n      const int loc = size_left / 2 - 1;\n      const int mright = max_small[loc];\n      mini(bound_left, mright + loc + 1);\n      debug(size_left, loc, mright, bound_left);\n      if (size_left <= bound_left) {\n        max_left = size_left;\n      }\n    }\n  }\n\n  debug(max_left);\n\n  int max_right = 0;\n  {\n    int cur_low_right = -1;\n    int cur_top_right = 1e9;\n\n    for (int size_right = 2; size_right <= S; size_right += 2) {\n      const int loc = S - size_right / 2;\n      const int mtop = left_large[loc];\n      mini(cur_top_right, loc - mtop + size_right - 1);\n      const int mlow = right_large[loc];\n      maxi(cur_low_right, loc - mlow + size_right - 1);\n      debug(size_right, cur_low_right, cur_top_right);\n      if (cur_low_right <= size_right && size_right <= cur_top_right) {\n        max_right = size_right;\n      }\n    }\n  }\n\n  debug(max_left, max_right, S);\n\n  return max_left + max_right >= S;\n}\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n\n\n  int N;\n  cin >> N >> M;\n  vector<int> numbers(2 * N);\n\n  for (int &x : numbers) { cin >> x; }\n  sort(ALL(numbers));\n\n  int L = -1, R = M - 1;\n  while (R - L > 1) {\n    const int mid = (L + R) / 2;\n    if (CanAchieve(numbers, mid)) {\n      R = mid;\n    } else {\n      L = mid;\n    }\n  }\n\n  cout << R << \"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n\n#define fo(i,j,l) for(int i=j;i<=l;++i)\n#define fd(i,j,l) for(int i=j;i>=l;--i)\n\nusing namespace std;\ntypedef long long ll;\nconst ll N=600,M=N*10,maxn=1e18;\n\nbool bz[N];\nint x[N],y[N];\nll v[N];\nint la[N],lb[M],ne[M],le[M];\nll cost[M];\nint fr[N],f1[N];\n\nint n,m,oo,S,T;\nchar c[N];\nint a[N],b[N],d[M];\nint p[N][2],q[N][2];\nll dis[N];\nll rec;\n\ninline ll max(ll a,ll b)\n{return a>b?a:b;}\n\ninline int min(int a,int b)\n{return a<b?a:b;}\n\ninline void llb(int a,int b,int c,ll co)\n{\n\tne[++oo]=la[a]; la[a]=oo; lb[oo]=b;\n\tle[oo]=c; cost[oo]=co; \n}\n\ninline void gg(int a,int b,int c,ll d)\n{\n\tllb(a,b,c,d); llb(b,a,0,-d);\n}\n\ninline bool flow()\n{\n\tfo(i,1,T)dis[i]=maxn;\n\tdis[S]=0;\n\tint l=0,r=1; d[1]=S; bz[S]=true;\n\twhile(l<r){\n\t\tint o=d[++l];\n\t\tfor(int y=la[o];y;y=ne[y])\n\t\tif(dis[o]-cost[y]<dis[lb[y]]&&le[y]==1){\n\t\t\tdis[lb[y]]=dis[o]-cost[y];\n\t\t\tfr[lb[y]]=o; f1[lb[y]]=y;\n\t\t\tif(!bz[lb[y]])d[++r]=lb[y],bz[lb[y]]=true;\n\t\t}\n\t\tbz[o]=false;\n\t}\n\tif(dis[T]==maxn)return false;\n\trec=0;\n\tfor(int u=T;u!=S;u=fr[u]){\n\t\tint k=f1[u];\n\t\tle[k]=0;\n\t\tle[k^1]=1;\n\t\trec=rec+cost[k];\n\t}\n\treturn true;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfo(i,1,n)scanf(\"%d%d%lld\",&x[i],&y[i],&v[i]);\n\tscanf(\"%d\",&m);\n\tfo(i,1,m){\n\t\tchar ch=' ';\n\t\tfor(;ch!='L'&&ch!='R'&&ch!='D'&&ch!='U';ch=getchar());\n\t\tc[i]=ch;\n\t\tscanf(\"%d%d\",&a[i],&b[i]);\n\t}\n\tll ans=0;\n\tfo(i,1,n){\n\t\tfo(l,1,i)p[l][0]=1,p[l][1]=100;\n\t\tfo(l,1,i)q[l][0]=1,q[l][1]=100;\n\t\tfo(l,1,m)\n\t\tif(c[l]=='L'&&b[l]<i){\n\t\t\tfo(j,b[l]+1,i)p[j][0]=max(p[j][0],a[l]+1);\n\t\t} else if(c[l]=='R'&&b[l]<i){\n\t\t\tfo(j,1,i-b[l])p[j][1]=min(p[j][1],a[l]-1);\n\t\t} else if(c[l]=='U'&&b[l]<i){\n\t\t\tfo(j,1,i-b[l])q[j][1]=min(q[j][1],a[l]-1);\n\t\t} else if(c[l]=='D'&&b[l]<i){\n\t\t\tfo(j,b[l]+1,i)q[j][0]=max(q[j][0],a[l]+1);\n\t\t}\n\t\tint ok=0;\n\t\tfo(l,1,i)if(p[l][0]>p[l][1]||q[l][0]>q[l][1]){ok=1; break;}\n\t\tif(ok)continue;\n\t\too=1;\n\t\tS=2*i+200+1,T=S+1;\n\t\tfo(j,1,T)la[j]=0;\n\t\tfo(l,1,i)gg(S,l,1,0);\n\t\tfo(l,1,i)gg(i+200+l,T,1,0);\n\t\tfo(j,1,i)fo(l,p[j][0],p[j][1])gg(j,i+l,1,0);\n\t\tfo(j,1,i)fo(l,q[j][0],q[j][1])gg(100+i+l,200+i+j,1,0);\n\t\tfo(l,1,n)gg(i+x[l],i+100+y[l],1,v[l]);\n\t\tll da=0; int cs=0;\n\t\twhile(flow()){\n\t\t\tda=da+rec;\n\t\t\t++cs;\n\t\t}\n\t\tif(cs==i)ans=max(ans,da);\n\t}\n\tcout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 100\n#define M 400\n#define V 200\n#define E 1000\n#define INF 1000000000000000000LL\nusing namespace std;\nint n;\nstruct jewel{int x,y;long long v;}J[N];\nstruct table{\n    int n,a[N];\n    void add(int x){a[++n]=x;}\n    void su(){sort(a+1,a+n+1);n=unique(a+1,a+n+1)-a-1;}\n    int lst(int x){return upper_bound(a+1,a+n+1,x)-a-1;}\n    int nxt(int x){return lower_bound(a+1,a+n+1,x)-a;}\n}X,Y;\nint m;\nstruct cond{char t;int a,b;}C[M];\nint e,head[V],nxt[E],to[E],cap[E],op[E];\nlong long val[E];\nvoid add(int x,int y,int c,long long v){\n    nxt[++e]=head[x],to[head[x]=e]=y,cap[e]=c,val[e]=v,op[e]=e+1;\n    nxt[++e]=head[y],to[head[y]=e]=x,cap[e]=0,val[e]=-v,op[e]=e-1;\n}\nint S,T,from[V],from_edge[V];\nlong long f[V];\nbool vis[V];\nqueue <int> q;\nlong long spfa(){\n    for(int i=0;i<=X.n+Y.n+3;++i)f[i]=-INF*2;\n    f[S]=0,vis[S]=1,q.push(S);\n    while(!q.empty()){\n        int x=q.front();\n        vis[x]=0,q.pop();\n        for(int i=head[x];i;i=nxt[i])\n            if(cap[i] && f[x]+val[i]>f[to[i]]){\n\t\t    \tf[to[i]]=f[x]+val[i];\n\t\t\t\tfrom[to[i]]=x,from_edge[to[i]]=i;\n\t\t    \tif(!vis[to[i]])vis[to[i]]=1,q.push(to[i]);\n\t\t    }\n    }\n    return f[T];\n}\nint flow;\nlong long cost;\nvoid augment(){\n    int delta=N;\n    for(int i=T;i!=S;i=from[i])delta=min(delta,cap[from_edge[i]]);\n    flow+=delta;\n    for(int i=T;i!=S;i=from[i]){\n\t\tcap[from_edge[i]]-=delta;\n        cap[op[from_edge[i]]]+=delta;\n        if(val[from_edge[i]]==-INF)continue;\n\t\tcost+=val[from_edge[i]]*delta;\n    }\n}\nint R_min[N],R_max[N],U_min[N],U_max[N];\nint in[V];\nlong long solve(int k){\n    int s=0,t=X.n+1,ss=X.n+Y.n+2,tt=X.n+Y.n+3;\n    e=0;for(int i=0;i<=X.n+Y.n+3;++i)head[i]=0;\n    for(int i=1;i<=X.n+1;++i)R_min[i]=0,R_max[i]=N;\n    for(int i=1;i<=Y.n+1;++i)U_min[i]=0,U_max[i]=N;\n    R_max[X.n+1]=U_max[Y.n+1]=0;\n    R_min[1]=R_max[1]=k;\n    for(int i=1;i<=m;++i)\n        if(C[i].t=='L')R_min[C[i].a+1]=max(R_min[C[i].a+1],k-C[i].b);\n        else if(C[i].t=='R')R_max[C[i].a]=min(R_max[C[i].a],C[i].b);\n        else if(C[i].t=='D')U_min[C[i].a+1]=max(U_min[C[i].a+1],k-C[i].b);\n        else U_max[C[i].a]=min(U_max[C[i].a],C[i].b);\n    for(int i=1;i<=X.n+1;++i)\n        if(R_min[i]>R_max[i])return 0;\n    for(int i=1;i<=Y.n+1;++i)\n        if(U_min[i]>U_max[i])return 0;\n    for(int i=0;i<=X.n+Y.n+1;++i)in[i]=0;\n    for(int i=1;i<=X.n;++i){\n        add(i-1,i,R_max[i]-R_min[i],0);\n        in[i]+=R_min[i],in[i-1]-=R_min[i];\n    }\n    for(int i=1;i<=n;++i)add(X.nxt(J[i].x),t+Y.nxt(J[i].y),1,J[i].v);\n    for(int i=1;i<=Y.n;++i){\n        add(t+i,t+i-1,U_max[i]-U_min[i],0);\n        in[t+i]-=U_min[i],in[t+i-1]+=U_min[i];\n    }\n    int total=0;\n    for(int i=0;i<=X.n+Y.n+1;++i)\n        if(in[i]>0)total+=in[i],add(ss,i,in[i],0);\n        else if(in[i]<0)add(i,tt,-in[i],0);\n    add(t,s,N,-INF);\n    S=ss,T=tt,flow=0,cost=0;\n    while(spfa()>-INF*2)augment();\n    if(flow<total)return 0;\n    S=s,T=t;\n    head[s]=nxt[head[s]];\n    head[e]=nxt[head[t]];\n    while(spfa()>0)augment();\n    return cost;\n}\nint main(){\n    cin>>n;\n    X.n=Y.n=0;\n    X.add(0),Y.add(0);\n    X.add(101),Y.add(101);\n    for(int i=1;i<=n;++i){\n        cin>>J[i].x>>J[i].y>>J[i].v;\n        X.add(J[i].x),Y.add(J[i].y);\n    }\n    X.su(),Y.su();\n    cin>>m;\n    for(int i=1;i<=m;++i){\n        char ch=getchar();\n        while(ch!='L' && ch!='R' && ch!='D' && ch!='U')ch=getchar();\n        C[i].t=ch;\n        cin>>C[i].a>>C[i].b;\n        if(ch=='L')C[i].a=X.lst(C[i].a);\n        else if(ch=='R')C[i].a=X.nxt(C[i].a);\n        else if(ch=='D')C[i].a=Y.lst(C[i].a);\n        else C[i].a=Y.nxt(C[i].a);\n    }\n    long long ans=0;\n    for(int i=1;i<=n;++i)ans=max(ans,solve(i));\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 16.03.2019 16:16:57       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long double ld;\n\nconst ld eps = 1e-8;\n\nvector<ld> simplex(vector<vector<ld>> a) {\n  int n = (int) a.size() - 1;\n  int m = (int) a[0].size() - 1;\n  vector<int> left(n + 1);\n  vector<int> up(m + 1);\n  iota(left.begin(), left.end(), m);\n  iota(up.begin(), up.end(), 0);\n  auto pivot = [&](int x, int y) {\n    swap(left[x], up[y]);\n    ld k = a[x][y];\n    a[x][y] = 1;\n    vector<int> pos;\n    for (int j = 0; j <= m; j++) {\n      a[x][j] /= k;\n      if (fabs(a[x][j]) > eps) {\n        pos.push_back(j);\n      }\n    }\n    for (int i = 0; i <= n; i++) {\n      if (fabs(a[i][y]) < eps || i == x) {\n        continue;\n      }\n      k = a[i][y];\n      a[i][y] = 0;\n      for (int j : pos) {\n        a[i][j] -= k * a[x][j];\n      }\n    }\n  };\n  while (1) {\n    int x = -1;\n    for (int i = 1; i <= n; i++) {\n      if (a[i][0] < -eps && (x == -1 || a[i][0] < a[x][0])) {\n        x = i;\n      }\n    }\n    if (x == -1) {\n      break;\n    }\n    int y = -1;\n    for (int j = 1; j <= m; j++) {\n      if (a[x][j] < -eps && (y == -1 || a[x][j] < a[x][y])) {\n        y = j;\n      }\n    }\n    if (y == -1) {\n      return vector<ld>(); // infeasible\n    }\n    pivot(x, y);\n  }\n  while (1) {\n    int y = -1;\n    for (int j = 1; j <= m; j++) {\n      if (a[0][j] > eps && (y == -1 || a[0][j] > a[0][y])) {\n        y = j;\n      }\n    }\n    if (y == -1) {\n      break;\n    }\n    int x = -1;\n    for (int i = 1; i <= n; i++) {\n      if (a[i][y] > eps && (x == -1 || a[i][0] / a[i][y] < a[x][0] / a[x][y])) {\n        x = i;\n      }\n    }\n    if (x == -1) {\n      return vector<ld>(); // unbounded\n    }\n    pivot(x, y);\n  }\n  vector<ld> ans(m + 1);\n  for (int i = 1; i <= n; i++) {\n    if (left[i] <= m) {\n      ans[left[i]] = a[i][0];\n    }\n  }\n  ans[0] = -a[0][0];\n  return ans;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<int> x(n), y(n);\n  vector<long long> z(n);\n  for (int i = 0; i < n; i++) {\n    cin >> x[i] >> y[i] >> z[i];\n  }\n  vector<vector<ld>> mat;\n  {\n    vector<ld> row(n + 1);\n    for (int i = 0; i < n; i++) {\n      row[i + 1] = z[i];\n    }\n    mat.push_back(row);\n  }\n  {\n    for (int i = 0; i < n; i++) {\n      vector<ld> row(n + 1);\n      row[0] = 1;\n      row[i + 1] = 1;\n      mat.push_back(row);\n    }\n  }\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    string foo;\n    int bar, baz;\n    cin >> foo >> bar >> baz;\n    vector<ld> row(n + 1);\n    row[0] = baz;\n    if (foo == \"L\") {\n      for (int i = 0; i < n; i++) if (x[i] <= bar) row[i + 1] = 1;\n    }\n    if (foo == \"R\") {\n      for (int i = 0; i < n; i++) if (x[i] >= bar) row[i + 1] = 1;\n    }\n    if (foo == \"D\") {\n      for (int i = 0; i < n; i++) if (y[i] <= bar) row[i + 1] = 1;\n    }\n    if (foo == \"U\") {\n      for (int i = 0; i < n; i++) if (y[i] >= bar) row[i + 1] = 1;\n    }\n    mat.push_back(row);\n  }\n  vector<ld> ret = simplex(mat);\n  cout << (long long) ret[0] << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\n#include<complex>\nusing namespace std;\n#define MOD 1000000007\n#define MOD2 998244353\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\n#define PI 3.1415926535897932384626433832795028\ntypedef long long Int;\ntypedef pair<Int, Int> P;\ntypedef long double Real;\ntypedef complex<Real> CP;\n\nclass Edge{\npublic:\n    Int from, to, rev;\n    Int cost, lim;\n    Edge(Int from, Int to, Int cost, Int lim = -1, Int rev = -1):\n        from(from),to(to),cost(cost),lim(lim),rev(rev){}\n};\n\n\nclass Graph{\npublic:\n    Int n;\n    Int m;\n    vector<vector<Edge>> edge;\n    Graph(Int n = 0):n(n),m(0){\n        edge = vector<vector<Edge>>(n);\n    }\n    void add_edge(Int from, Int to, Int cost = 1, Int lim = -1)\n        {\n            if(lim == -1){\n                edge[from].push_back(Edge(from, to, cost));\n                return;\n            }\n            edge[from].push_back(Edge(from, to, cost, lim, edge[to].size()));\n            edge[to].push_back(Edge(to, from, -cost, 0, edge[from].size() - 1));\n        }\n};\n\nclass MinCostFlow{\npublic:\n    priority_queue<P, vector<P>, greater<P> > pq;\n    vector<Int> dist;\n    vector<Int> before;\n    vector<Int> index;\n    vector<Int> potential;\n    MinCostFlow(){}\n    \n    void Dijkstra(Graph &g, Int s){\n        fill(dist.begin(), dist.end(), LINF);\n        pq.push(P(0, s));\n        dist[s] = 0;\n\n        while(!pq.empty()){\n            P tmp = pq.top();pq.pop();\n            Int from = tmp.second;\n            if(tmp.first > dist[from])continue;\n            for(Int i = 0;i < g.edge[from].size();i++){\n                auto e = g.edge[from][i];\n                auto cost = e.cost + potential[e.from] - potential[e.to];\n                if(e.lim == 0)continue;\n                if(dist[e.to] <= dist[from] + cost)continue;\n                dist[e.to] = dist[from] + cost;\n                before[e.to] =from;\n                index[e.to] = i;\n                pq.push(P(dist[e.to], e.to));\n            }\n        }\n        for(int i = 0;i < g.n;i++){\n            dist[i] += potential[i];\n            potential[i] = dist[i];\n        }\n    }\n\n    \n    Int mcf(Graph &g, Int s, Int t, Int f){\n        Int res = 0;\n        dist = vector<Int>(g.n);\n        potential = vector<Int>(g.n);\n        before = vector<Int>(g.n);\n        index = vector<Int>(g.n);\n        while(f){\n            Dijkstra(g, s);\n            Int flow = f;\n            for(Int now = t;now != s;){\n                Int last = before[now];\n                Int ind = index[now];\n                auto &e = g.edge[last][ind];\n                if(e.lim == 0 || e.to != now)return -1;\n                flow = min(flow, e.lim);\n                now = last;\n            }\n            for(Int now = t;now != s;){\n                Int last = before[now];\n                Int ind = index[now];\n                auto &e = g.edge[last][ind];\n                e.lim -= flow;\n                g.edge[e.to][e.rev].lim += flow;\n                res += e.cost * flow;\n                now = last;\n            }\n            f -= flow;\n            if(flow==0)return -1;\n        }\n        return res;\n    }\n};\n\nInt n, m;\nInt x[88], y[88], v[88];\nchar dir[352];\nInt a[352], b[352];\nInt solve(Int F){\n    Graph g(206);\n    Int B = 102;\n    Int Big = 1000000000000000ll;\n    Int s = 101, t = 101 + B, S = 204, T= 205;\n    vector<Int> xupper(101, INF), xlower(101, 0);\n    vector<Int> yupper(101, INF), ylower(101, 0);\n    for(int i = 0;i < m;i++){\n        if(dir[i] == 'L')xupper[a[i]] = min(xupper[a[i]], b[i]);\n        if(dir[i] == 'R')xlower[a[i]-1] = max(xlower[a[i]-1], F - b[i]);\n        if(dir[i] == 'D')yupper[a[i]] = min(yupper[a[i]], b[i]);\n        if(dir[i] == 'U')ylower[a[i]-1] = max(ylower[a[i]-1], F - b[i]);\n    }\n    for(int i = 0;i < n;i++) g.add_edge(x[i], y[i] + B, Big-v[i], 1);\n    Int flow = F;\n    for(int i = 0;i <= 100;i++){\n        if(xupper[i] < xlower[i])return 0;\n        if(yupper[i] < ylower[i])return 0;\n        flow += xlower[i] + ylower[i];\n        g.add_edge(i+1, i, 0, xupper[i]-xlower[i]);\n        g.add_edge(B+i, B+i+1, 0, yupper[i]-ylower[i]);\n        g.add_edge(S, i, 0, xlower[i]);\n        g.add_edge(i+1, T, 0, xlower[i]);\n        g.add_edge(S, B+i+1, 0, ylower[i]);\n        g.add_edge(B+i, T, 0, ylower[i]);\n    }\n    g.add_edge(S, s, 0, F);\n    g.add_edge(t, T, 0, F);\n    MinCostFlow mcf;\n    auto ans = mcf.mcf(g, S, T, flow);\n    if(ans == -1)return 0;\n    return Big*F-ans;\n\n}\n\n\nint main(){\n    cin >> n;\n    for(int i = 0;i < n;i++){\n        cin >> x[i] >> y[i] >> v[i];\n    }\n    cin >> m;\n    for(int i = 0;i < m;i++){\n        cin >> dir[i] >> a[i] >> b[i];\n    }\n    Int ans = 0;\n    for(int i = 1;i <= n;i++){\n        auto tmp = solve(i);\n        ans = max(ans, tmp);\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<map>\n#include<bitset>\n#include<set>\n#define N (100010)\n#define P ()\n#define M ()\n#define inf (0x7f7f7f7f)\n#define rg register int\n#define Label puts(\"NAIVE\")\n#define spa print(' ')\n#define ent print('\\n')\n#define rand() (((rand())<<(15))^(rand()))\n#define file(s) freopen(s\".in\",\"r\",stdin),freopen(s\".out\",\"w\",stdout)\ntypedef long double ld;\ntypedef long long LL;\ntypedef unsigned long long ull;\nusing namespace std;\nnamespace fastIO1{\n\tinline char read(){\n\t\tstatic const int IN_LEN=1000000;\n\t\tstatic char buf[IN_LEN],*s,*t;\n\t\treturn (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);\n\t}\n\ttemplate<class T>\n\tinline void read(T &x){\n\t\tstatic bool iosig;\n\t\tstatic char c;\n\t\tfor(iosig=false,c=read();!isdigit(c);c=read()){\n\t\t\tif(c=='-')iosig=true;\n\t\t\tif(c==-1)return;\n\t\t}\n\t\tfor(x=0;isdigit(c);c=read())x=((x+(x<<2))<<1)+(c^'0');\n\t\tif(iosig)x=-x;\n\t}\n\tinline char readc(char &c){\n\t\tfor(c=read();!isalpha(c)&&!isdigit(c);c=read())\n\t\tif(c==-1)return 0;\n\t}\n\tconst int OUT_LEN = 10000000;\n\tchar obuf[OUT_LEN],*ooh=obuf;\n\tinline void print(char c){\n\t\tif(ooh==obuf+OUT_LEN)fwrite(obuf,1,OUT_LEN,stdout),ooh=obuf;\n\t\t*ooh++=c;\n\t}\n\ttemplate<class T>\n\tinline void print(T x){\n\t\tstatic int buf[30],cnt;\n\t\tif(x==0)print('0');\n\t\telse{\n\t\t\tif(x<0)print('-'),x=-x;\n\t\t\tfor(cnt=0;x;x/=10)buf[++cnt]=x%10+48;\n\t\t\twhile(cnt)print((char)buf[cnt--]);\n\t\t}\n\t}\n\tinline void flush(){fwrite(obuf,1,ooh-obuf,stdout);}\n}\nnamespace fastIO2{\n\ttemplate<class T>\n\tinline void read(T &x){\n\t\tstatic bool iosig;\n\t\tstatic char c;\n\t\tfor(iosig=false,c=getchar();!isdigit(c);c=getchar()){\n\t\t\tif(c=='-')iosig=true;\n\t\t\tif(c==-1)return;\n\t\t}\n\t\tfor(x=0;isdigit(c);c=getchar())x=((x+(x<<2))<<1)+(c^'0');\n\t\tif(iosig)x=-x;\n\t}\n}\nusing namespace fastIO1;\nstruct limits{int l,op,x;}q[N];\nstruct points{int x,y;LL w;}a[N];\nint n,m,E=1,S,T,V,fl,lx[N],rx[N],ly[N],ry[N];\nint fi[N],ne[N],b[N],cap[N],pre[N],prv[N];\nbool vis[N]; LL ans,mx,ot,c[N],dis[N];\nvoid add(int x,int y,int cp,LL cost){\n//\tprintf(\"%d--%lld-->%d\\n\",x,cost,y);\n\tne[++E]=fi[x],fi[x]=E,b[E]=y;\n\tcap[E]=cp,c[E]=cost;\n\tne[++E]=fi[y],fi[y]=E,b[E]=x;\n\tcap[E]=0,c[E]=-cost;\n}\nvoid mcmf(int S,int T,int flow,int cnt){\n\twhile(flow){\n\t\tfor(int i=1;i<=V;i++)dis[i]=1e18,vis[i]=0;\n\t\tdis[S]=0; queue<int> Q; Q.push(S),vis[S]=1;\n\t\twhile(!Q.empty()){\n\t\t\tint u=Q.front();Q.pop(),vis[u]=0;\n\t\t\tif(dis[u]==1e18)continue;\n\t\t\tfor(int i=fi[u];i;i=ne[i]){\n\t\t\t\tint v=b[i];\n\t\t\t\tif(cap[i]>0&&dis[u]+c[i]<dis[v]){\n                    dis[v]=dis[u]+c[i];\n                    prv[v]=u,pre[v]=i;\n                    if(!vis[v])Q.push(v),vis[v]=1;\n                }\n\t\t\t}\n\t\t}\n\t\tif(dis[T]==1e18)break;\n\t\tint w=flow;\n\t\tfor(int i=T;i!=S;i=prv[i])\n\t\tw=min(w,cap[pre[i]]);\n\t\tflow-=w,mx+=dis[T],fl+=w;\n\t\tfor(int i=T;i!=S;i=prv[i]){\n\t\t\tint e=pre[i];\n\t\t\tcap[e]-=w,cap[e^1]+=w;\n\t\t}\n\t}\n}\nvoid solve(int cnt){\n\tmemset(fi,0,n*32),E=1,fl=0;\n\tmemset(rx,inf,(n+3)<<2);\n\tmemset(lx,0,(n+3)<<2);\n\tmemset(ry,inf,(n+3)<<2);\n\tmemset(ly,0,(n+3)<<2);\n//\tcout<<cnt<<endl;\n\tfor(int j=1;j<=m;j++){\n\t\tint t=(q[j].op&1)?q[j].x+1:cnt-q[j].x;\n//\t\tcout<<j<<\" \"<<t<<endl;\n\t\tif(t>cnt||t<=0)continue;\n\t\t\n\t\tif(q[j].op==1)lx[t]=max(lx[t],q[j].l+1);\n\t\telse if(q[j].op==2)rx[t]=min(rx[t],q[j].l-1);\n\t\telse if(q[j].op==3)ly[t]=max(ly[t],q[j].l+1);\n\t\telse ry[t]=min(ry[t],q[j].l-1);\n\t}\n\tfor(int i=2;i<=cnt;i++)lx[i]=max(lx[i-1],lx[i]),ly[i]=max(ly[i-1],ly[i]);\n\tfor(int i=cnt;i;i--)rx[i]=min(rx[i+1],rx[i]),ry[i]=min(ry[i+1],ry[i]);\n//\tfor(int j=1;j<=cnt;j++)cout<<lx[j]<<\" \"<<rx[j]<<endl;\n//\tfor(int j=1;j<=cnt;j++)cout<<ly[j]<<\" \"<<ry[j]<<endl;\n//\tfor(int j=1;j<=cnt;j++)cout<\n\tS=2*(n+cnt)+1,T=S+1,V=T;\n\tfor(int i=1;i<=n;i++)add(i,i+n,1,-a[i].w);\n\tfor(int i=1;i<=cnt;i++){\n\t\tif(lx[i]>rx[i]||ly[i]>ry[i])return;\n\t\tfor(int j=1;j<=n;j++)\n\t\tif(lx[i]<=a[j].x&&a[j].x<=rx[i])\n\t\tadd(i+2*n,j,1,0);\n\t\tfor(int j=1;j<=n;j++)\n\t\tif(ly[i]<=a[j].y&&a[j].y<=ry[i])\n\t\tadd(j+n,i+2*n+cnt,1,0);\n\t\tadd(S,i+2*n,1,0),add(i+2*n+cnt,T,1,0);\n\t}\n\tmx=0,mcmf(S,T,inf,cnt),ot=max(ot,-mx);\n//\tcout<<cnt<<\" \"<<fl<<\" \"<<mx<<endl;\n//\tcout<<\"ans=\"<<-ans<<endl;\n//\tputs(\"--------------\");\n}\nint main(){\n\tread(n);\n\tfor(int i=1;i<=n;i++)read(a[i].x),read(a[i].y),read(a[i].w); read(m);\n\tfor(int i=1;i<=m;i++){\n\t\tchar ch; readc(ch),read(q[i].l),read(q[i].x);\n\t\tq[i].op=(ch=='L')?1:ch=='R'?2:ch=='D'?3:4;\n\t}\n\tfor(int i=1;i<=n;i++)solve(i); cout<<ot;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\n  _|_|                              _|  _|    _|\n_|    _|  _|  _|_|  _|_|_|_|        _|  _|  _|\n_|    _|  _|_|          _|          _|  _|_|\n_|    _|  _|          _|      _|    _|  _|  _|\n  _|_|    _|        _|_|_|_|    _|_|    _|    _|\n\n*/\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<set>\n//#define ls (rt<<1)\n//#define rs (rt<<1|1)\n#define vi vector<int>\n#define pb push_back\n#define mk make_pair\n#define pii pair<ll,ll>\n#define rep(i,a,b) for(int i=(a),i##end=(b);i<=i##end;i++)\n#define fi first\n#define se second\ntypedef long long ll;\nusing namespace std;\nconst int maxn=420;\nconst int inf=1e9+100;\nint xl[maxn],xr[maxn],yl[maxn],yr[maxn],s=415,t=416;\nint head[maxn],cnt=1;\nstruct gg{\n    int u,v,w;ll cost;int next;\n    void insert(int U,int V,int W,ll Cost,int Next){\n        u=U,v=V,w=W,cost=Cost,next=Next;\n    }\n}side[(maxn*82)*2];\nstruct Point{\n    int x,y;\n    ll cost=0;\n}point[maxn];\nstruct Lim{\n    int a,b;char c;\n}lim[maxn];\nvoid ins(int u,int v,int w,ll cost){\n    side[++cnt].insert(u,v,w,cost,head[u]);head[u]=cnt;\n    side[++cnt].insert(v,u,0,-cost,head[v]);head[v]=cnt;\n}\nint n,m;\nvoid init(int k){\n   rep(i,1,k)xl[i]=yl[i]=-inf,xr[i]=yr[i]=inf;\n   rep(i,1,m){\n       if(lim[i].c=='L')rep(j,lim[i].b+1,k)xl[j]=max(xl[j],lim[i].a+1);\n       else if(lim[i].c=='R')for(int j=k-lim[i].b;j>0;j--)xr[j]=min(xr[j],lim[i].a-1);\n       else if(lim[i].c=='D')rep(j,lim[i].b+1,k)yl[j]=max(yl[j],lim[i].a+1);\n       else if(lim[i].c=='U')for(int j=k-lim[i].b;j>0;j--)yr[j]=min(yr[j],lim[i].a-1);\n   }\n   memset(head,0,sizeof(head));cnt=1;\n   rep(i,1,k)ins(s,2*n+i,1,0);\n   rep(i,1,k)ins(2*n+k+i,t,1,0);\n   rep(i,1,n){\n        ins(i,n+i,1,point[i].cost);\n        rep(j,1,k){\n            if(xl[j]<=point[i].x&&point[i].x<=xr[j])ins(2*n+j,i,1,0);\n            if(yl[j]<=point[i].y&&point[i].y<=yr[j])ins(n+i,2*n+k+j,1,0);\n        }\n   }\n}\nint rk[maxn],q[maxn];\nll dis[maxn],lenth;\nbool vis[maxn];\nbool spfa(){\n    rep(i,1,maxn-1)dis[i]=-inf;\n    memset(vis,0,sizeof(vis));\n    int hd=1,tl=1;q[hd]=s;vis[s]=1;dis[s]=0;\n    while(hd<=tl){\n        int u=q[hd++];vis[u]=0;//cout<<u<<' '<<endl;\n        for(int i=head[u];i;i=side[i].next){\n            int v=side[i].v;if(!side[i].w)continue;\n            if(dis[u]+side[i].cost>dis[v]){\n                dis[v]=dis[u]+side[i].cost;\n                if(!vis[v])q[++tl]=v;\n                vis[v]=1;\n            }\n        }\n    }\n    if(dis[t]>0)return 1;\n    return 0;\n}\nint dfs(int u,int flow){\n    if(u==t)return flow;\n    vis[u]=1;int tot=0;\n    for(int i=head[u];i;i=side[i].next){\n        int v=side[i].v;if(vis[v]||!side[i].w||dis[v]!=dis[u]+side[i].cost)continue;\n        int sent=dfs(v,min(flow,side[i].w));\n        lenth+=1ll*side[i].cost*sent,side[i].w-=sent,side[i^1].w+=sent,tot+=sent;flow-=sent;\n    }\n   // vis[u]=0;\n    return tot;\n}\npii dinic(){\n    int mxflow=0;lenth=0;\n    while(spfa()){\n        int x;\n        while((x=dfs(s,inf)))mxflow+=x;\n    }\n    return mk(mxflow,lenth);\n}\nchar tmp[3];\nint main(){\n    scanf(\"%d\",&n);\n    rep(i,1,n)scanf(\"%d%d%lld\",&point[i].x,&point[i].y,&point[i].cost);\n    scanf(\"%d\",&m);\n    rep(i,1,m){\n        scanf(\"%s%d%d\",tmp+1,&lim[i].a,&lim[i].b);lim[i].c=tmp[1];\n    }\n    ll out=0;\n    rep(k,1,n){\n        init(k);\n        pii ans=dinic();out=max(out,ans.se);//cout<<ans.se<<endl;\n    }\n    cout<<out;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=505,M=50005,R=100;\nconst ll inf=0x3f3f3f3f3f3f3f3fll;\nint read(){\n\tint f=1,g=0;\n\tchar ch=getchar();\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-') f=-1;\n\tfor (;isdigit(ch);ch=getchar()) g=g*10+ch-'0';\n\treturn f*g;\n}\nvoid chkmax(int &x,int y){if (x<y) x=y;}\nvoid chkmin(int &x,int y){if (x>y) x=y;}\nint n,m;\nstruct jew{int x,y;ll w;}a[N];\nstruct node{char typ;int x,r;}b[N];\nll cost,ans;\nint S,T,cnt,fir[N],fr[N],siz;\nstruct edge{int u,v;ll w;int fl,nex;}e[M];\nvoid add(int u,int v,ll w,int fl){\n\te[++siz]=(edge){u,v,w,fl,fir[u]};fir[u]=siz;\n\te[++siz]=(edge){v,u,-w,0,fir[v]};fir[v]=siz;\n}\nll dist[N];int que[N*50];bool inq[N];\nvoid dec(int x,int fl){e[x].fl-=fl;e[x^1].fl+=fl;}\nbool spfa(){\n\tmemset(dist,0xc0,8*(cnt+1));\n\tmemset(inq,0,cnt+1);\n\tint l=1,r=1;que[l]=S;dist[S]=0;inq[S]=1;\n\twhile (l<=r){\n\t\tint x=que[l];\n\t\tfor (int i=fir[x];i;i=e[i].nex)\n\t\tif ((e[i].fl)&&(dist[e[i].v]<dist[x]+e[i].w)){\n\t\t\tif (!inq[e[i].v]) {que[++r]=e[i].v;inq[e[i].v]=1;}\n\t\t\tdist[e[i].v]=dist[x]+e[i].w;fr[e[i].v]=i;\n\t\t}\n\t\tinq[x]=0;l++;\n\t}\n\treturn dist[T]>0;\n}\nint update(){\n\tint t=0x3f3f3f3f;\n\tfor (int i=fr[T];i;i=fr[e[i].u]) t=min(t,e[i].fl);\n\tcost+=t*dist[T];\n\tfor (int i=fr[T];i;i=fr[e[i].u]) dec(i,t);\n\treturn t;\n}\nint dinic(){\n\tint flow=0;\n\twhile (spfa()) flow+=update();\n\treturn flow;\n}\nint ml[N],mr[N],mu[N],md[N];\nvoid calc(int L){\n\tmemset(fir,0,sizeof(fir));siz=1;\n\tS=0;T=cnt=L*2+R*2+1;\n\tfor (int i=1;i<=n;i++) add(a[i].x,a[i].y+R,a[i].w,1);\n\tfor (int i=1;i<=L;i++) {ml[i]=mu[i]=1,mr[i]=md[i]=R;add(S,R*2+i,0,1);add(R*2+L+i,T,0,1);}\n\tfor (int i=1;i<=m;i++)\n\tif (b[i].r>=L) continue;\n\telse if (b[i].typ=='L') chkmax(ml[b[i].r+1],b[i].x+1);\n\telse if (b[i].typ=='R') chkmin(mr[L-b[i].r],b[i].x-1);\n\telse if (b[i].typ=='D') chkmax(mu[b[i].r+1],b[i].x+1);\n\telse if (b[i].typ=='U') chkmin(md[L-b[i].r],b[i].x-1);\n\tfor (int i=2;i<=L;i++) chkmax(ml[i],ml[i-1]),chkmax(mu[i],mu[i-1]);\n\tfor (int i=L-1;i;i--)  chkmin(md[i],md[i+1]),chkmin(md[i],md[i+1]);\n\tfor (int i=1;i<=L;i++){\n\t\tfor (int j=ml[i];j<=mr[i];j++) add(R*2+i,j,0,1);\n\t\tfor (int j=mu[i];j<=md[i];j++) add(j+R,R*2+L+i,0,1);\n\t}\n\tcost=0;\n\tif (dinic()==L) ans=max(ans,cost);\n//\tfor (int i=1;i<=n;i++) if (!e[i*2].fl) printf(\"%d \",i);\n//\tprintf(\"\\n\");\n}\nint main(){\n\tn=read();\n\tfor (int i=1;i<=n;i++) scanf(\" %d %d %lld\",&a[i].x,&a[i].y,&a[i].w);\n\tm=read();\n\tfor (int i=1;i<=m;i++) scanf(\" %c %d %d\",&b[i].typ,&b[i].x,&b[i].r);\n\tfor (int i=1;i<=n;i++) calc(i);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define Rep(i,a,b) for(register int i=(a);i<=int(b);++i)\n#define Dep(i,a,b) for(register int i=(a);i>=int(b);--i)\n#define rep(i,a,b) for(register int i=(a);i<int(b);++i)\n#define mem(x,v) memset(x,v,sizeof(x))\n#define fi first\n#define se second\n#define gc getchar\n#define pc putchar\ninline ll read(){\n    ll x=0,f=1;char c=gc();\n    for(;!isdigit(c);c=gc())if(c=='-')f=-1;\n    for(;isdigit(c);c=gc())x=(x<<1)+(x<<3)+(c^48);\n    return x*f;\n}\ninline void write(ll x){if(x<0)x=-x,pc('-');if(x>=10)write(x/10);putchar(x%10+'0');}\ninline void wri(ll x){write(x);pc(' ');}\ninline void writeln(ll x){write(x);pc('\\n');}\n#define int ll\nconst int maxn = 2005;\nstruct Edge{\n\tint to,nxt,cap;\n\tll v;\n\tEdge(){}\n\tEdge(int to,int nxt,int cap,ll v):\n\t\tto(to),nxt(nxt),cap(cap),v(v){}\n}edge[maxn*maxn];\nint first[maxn],nume;\nint tot,S,T,idx[maxn],idy[maxn];\nvoid Addedge(int a,int b,int c,ll v){\n//\tprintf(\"_%d -> %d{%d %d}\\n\",a,b,c,v);\n\tedge[nume] = Edge(b,first[a],c,v);first[a] = nume++;\n\tedge[nume] = Edge(a,first[b],0,-v);first[b] = nume++;\n}\nll dis[maxn];\nint q[maxn*maxn],vis[maxn],from[maxn];\nbool spfa(){\n\tRep(i,1,tot) dis[i] = -(1ll<<62),vis[i] = 0,from[i] = 0;\n\tint front=0,rear=0;\n\tq[rear++] = S;dis[S] = 0;vis[S] = true;\n\twhile(front < rear){\n\t\tint u = q[front++];vis[u] = false;\n\t\tfor(int e=first[u];~e;e=edge[e].nxt){\n\t\t\tif(dis[edge[e].to] < dis[u] + edge[e].v && edge[e].cap){\n\t\t\t\tdis[edge[e].to] = dis[u] + edge[e].v;\n\t\t\t\tfrom[edge[e].to] = e;\n\t\t\t\tif(!vis[edge[e].to]){\n\t\t\t\t\tvis[edge[e].to] = true;\n\t\t\t\t\tq[rear++] = edge[e].to;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dis[T] != -(1ll<<62);\n}\nvoid del(){\n\tfor(int e=from[T];e;e=from[edge[e^1].to]){\n\t\tedge[e].cap--,edge[e^1].cap++;\n\t}\n}\nstruct que{\n\tchar s[10];\n\tint x,cnt;\n}qq[maxn];\nint n,Q,x[maxn],y[maxn],mn[maxn],mx[maxn];\nll v[maxn];\nconst int MX = 100;\nll work(int cnt){\n\tmemset(first,-1,sizeof(first));nume = 0;\n\ttot = 0;S = ++tot;T = ++tot;\n\tRep(i,1,MX) idx[i] = ++tot,idy[i] = ++tot;\n\tRep(i,1,n) Addedge(idx[x[i]],idy[y[i]],1,v[i]);\n\t\n\t\tRep(i,0,cnt+1) mx[i]=MX,mn[i]=1;\n\t\tRep(i,1,Q){\n\t\t\tif (qq[i].s[0]=='L'&&cnt>=qq[i].cnt+1){\n\t\t\t\tmn[qq[i].cnt+1]=max(mn[qq[i].cnt+1],qq[i].x+1);\n//\t\t\t\tprintf(\"Mn(%d) [%d]\\n\",qq[i].cnt+1,qq[i].x+1);\n\t\t\t}\n\t\t\tif (qq[i].s[0]=='R'&&cnt>=qq[i].cnt+1)\n\t\t\t\tmx[cnt-qq[i].cnt]=min(mx[cnt-qq[i].cnt],qq[i].x-1);\n\t\t}\n\t\tRep(i,1,cnt) mn[i]=max(mn[i],mn[i-1]);\n\t\tDep(i,cnt,1) mx[i]=min(mx[i],mx[i+1]);\n//\t\tRep(i,1,cnt){\n//\t\t\tprintf(\"{%d %d}\\n\",mn[i],mx[i]);\n//\t\t}\n\t\tRep(i,1,cnt){\n\t\t\tint tmp=++tot;\n\t\t\tif (mn[i]>mx[i]) return 0;\n\t\t\tAddedge(S,tmp,1,0);\n\t\t\tRep(j,mn[i],mx[i])\n\t\t\t\tAddedge(tmp,idx[j],1,0);\n\t\t}\n\n\t\tRep(i,0,cnt+1) mx[i]=MX,mn[i]=1;\n\t\tRep(i,1,Q){\n\t\t\tif (qq[i].s[0]=='D'&&cnt>=qq[i].cnt+1)\n\t\t\t\tmn[qq[i].cnt+1]=max(mn[qq[i].cnt+1],qq[i].x+1);\n\t\t\tif (qq[i].s[0]=='U'&&cnt>=qq[i].cnt+1)\n\t\t\t\tmx[cnt-qq[i].cnt]=min(mx[cnt-qq[i].cnt],qq[i].x-1);\n\t\t}\n\t\tRep(i,1,cnt) mn[i]=max(mn[i],mn[i-1]);\n\t\tDep(i,cnt,1) mx[i]=min(mx[i],mx[i+1]);\n\t\tRep(i,1,cnt){\n\t\t\tint tmp=++tot;\n\t\t\tif (mn[i]>mx[i]) return 0;\n\t\t\tAddedge(tmp,T,1,0);\n\t\t\tRep(j,mn[i],mx[i])\n\t\t\t\tAddedge(idy[j],tmp,1,0);\n\t\t}\n\tll ans = 0;\n\tRep(i,1,cnt){\n\t\tif(!spfa()) return 0;\n\t\tans += dis[T];\n\t\tdel();\n\t}\n//\tprintf(\"%lld %lld\\n\",cnt,ans);\n\treturn ans;\n}\nsigned main(){\n\tn = read();\n\tRep(i,1,n){\n\t\tx[i] = read(),y[i] = read(),v[i] = read();\n\t}\n\tQ = read();\n\tRep(i,1,Q){\n\t\tscanf(\"%s\",qq[i].s);qq[i] . x = read(),qq[i] . cnt = read();\n\t}\n\tll ans = 0;\n\tRep(i,1,n) ans=max(ans,work(i));\n\twriteln(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef HOME\n#define db(x) cerr << #x << \" = \" << x << endl\n#define db3(x, y, z) cerr << \"(\" << #x << \", \" << #y << \", \" << #z << \") = (\" << x << \", \" << y << \", \" << z << \")\" << endl\n#define db2(x, y) cerr << \"(\" << #x << \", \" << #y << \") = (\" << x << \", \" << y << \")\" << endl\n#define dbv(a) cerr << #a << \" = \"; for (auto xxx: a) cerr << xxx  << \" \"; cerr << endl\n#else\n#define db(x) ;\n#define db3(x, y, z) ;\n#define db2(x, y) ;\n#define dbv(a) ;\n#endif\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double dbl;\n\n\nconst int INF = 1.01e9;\nconst int MOD = (int)1e9 + 7;\n\nstruct Item {\n    int x, y;\n    ll val;\n};\n\nstruct Cond {\n    char type;\n    int a, b;\n\n    bool cover(Item it) {\n        if (type == 'L') {\n            return it.x <= a;\n        }\n        if (type == 'R') {\n            return it.x >= a;\n        }\n        if (type == 'D') {\n            return it.y <= a;\n        }\n        if (type == 'U') {\n            return it.y >= a;\n        }\n        assert(0);\n    }\n};\n\nll slow(vector<Item> a, vector<Cond> b) {\n    int n = a.size(), m = b.size();\n    ll ans = 0;\n    for (int mask = 0; mask < (1 << n); mask++) {\n        vector<int> cnt(m);\n        ll sum = 0;\n        for (int i = 0; i < n; i++) {\n            if (!(mask & (1 << i))) continue;\n            sum += a[i].val;\n            for (int j = 0; j < m; j++) {\n                if (b[j].cover(a[i])) {\n                    cnt[j]++;\n                }\n            }\n        }\n        bool bad = 0;\n        for (int i = 0; i < m; i++) {\n            if (cnt[i] > b[i].b) {\n                bad = 1;\n            }\n        }\n        if (bad) continue;\n        ans = max(ans, sum);\n    }\n    return ans;\n}\n\n\nbool eq(dbl a, dbl b) {\n    return fabs(a - b) < 1e-9;\n}\n\nbool ls(dbl a, dbl b) {\n    return !eq(a, b) && a < b;\n}\n\nvector<dbl> supersimplex(vector<vector<dbl> > a) {\n    int n = a.size() - 1;\n    int m = a[0].size() - 1;\n    vector<int> left(n + 1), up(m + 1);\n    iota(up.begin(), up.end(), 0);\n    iota(left.begin(), left.end(), m);\n    while (1) {\n        auto pivot = [&](int x, int y) {\n            swap(left[x], up[y]);\n            dbl k = a[x][y];\n            a[x][y] = 1;\n            vector<int> vct;\n            for (int j = 0; j <= m; j++) {\n                a[x][j] /= k;\n                if (!eq(a[x][j], 0)) vct.push_back(j);\n            }\n            for (int i = 0; i <= n; i++) {\n                if (eq(a[i][y], 0) || i == x) continue;\n                k = a[i][y];\n                a[i][y] = 0;\n                for (int j : vct) a[i][j] -= k * a[x][j];\n            }\n        };\n        while (1) {\n            int x = -1;\n            for (int i = 1; i <= n; i++) if (ls(a[i][0], 0) && (x == -1 || a[i][0] < a[x][0])) x = i;\n            if (x == -1) break;\n            int y = -1;\n            for (int j = 1; j <= m; j++) if (ls(a[x][j], 0) && (y == -1 || a[x][j] < a[x][y])) y = j;\n            if (y == -1) return vector<dbl>(m, 0);\n            pivot(x, y);\n        }\n        while (1) {\n            int y = -1;\n            for (int j = 1; j <= m; j++) if (ls(0, a[0][j]) && (y == -1 || a[0][j] > a[0][y])) y = j;\n            if (y == -1) break;\n            int x = -1;\n            for (int i = 1; i <= n; i++)\n                if (ls(0, a[i][y]) && (x == -1 || a[i][0] / a[i][y] < a[x][0] / a[x][y]))\n                    x = i;\n            if (x == -1) assert(0); // unbounded\n            pivot(x, y);\n        }\n\n        vector<int> v;\n        vector<dbl> ans(m + 1);\n        for (int i = 1; i <= n; i++) if (left[i] <= m) ans[left[i]] = a[i][0];\n        ans[0] = -a[0][0];\n        for (int i = 1; i <= m; i++) {\n            if (!eq(ans[i], floor(ans[i])) && !eq(ans[i], floor(ans[i]) + 1)) {\n                v.push_back(i);\n            }\n        }\n        if (v.empty()) {\n            return ans;\n        }\n        for (int i = 0; i <= n; i++) {\n            for (int j = 0; j < (int)v.size(); j++) {\n                a[i].push_back(0);\n            }\n        }\n        for (int i = 0; i < (int)v.size(); i++) {\n            vector<dbl> cur(a[0].size());\n            cur[m + 1 + i] = 1;\n            for (int j = 0; j <= m; j++) {\n                cur[j] = floor(a[v[i]][j]) - a[v[i]][j];\n            }\n            a.push_back(cur);\n        }\n        m += v.size();\n        n += v.size();\n        up.resize(up.size() + v.size());\n        left.resize(left.size() + v.size());\n    }\n}\n// j=1..m: x[j]>=0\n// i=1..n: sum(j=1..m) A[i][j]*x[j] <= A[i][0]\n// max sum(j=1..m) A[0][j]*x[j]\n// res[0] is answer\n// res[1..m] is certificate\n\nll fast(vector<Item> a, vector<Cond> b) {\n    int n = a.size(), m = b.size();\n    vector<vector<dbl>> c(m + 1, vector<dbl>(n + 1));\n    for (int i = 0; i < n; i++) {\n        c[0][1 + i] = a[i].val;\n    }\n    for (int i = 0; i < m; i++) {\n        c[1 + i][0] = b[i].b;\n        for (int j = 0; j < n; j++) {\n            if (b[i].cover(a[j])) {\n                c[1 + i][1 + j] = 1;\n            }\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        vector<dbl> cur(n + 1);\n        cur[0] = 1;\n        cur[1 + i] = 1;\n        c.push_back(cur);\n    }\n    return (ll)round(supersimplex(c)[0]);\n}\n\nvoid stress() {\n    for (int it =0;; it++) {\n        mt19937_64 rnd(it);\n        db(it);\n\n\n        int n = rnd() % 10 + 1;\n        vector<Item> a(n);\n        for (int i =0 ; i < n; i++) {\n            a[i].x = rnd() % 100;\n            a[i].y = rnd() % 100;\n            a[i].val = rnd() % (ll)1e15;\n        }\n        int m = rnd() % 10 + 1;\n        vector<Cond> b(m);\n        for (int i = 0; i < m; i++) {\n            b[i].a = rnd() % 100;\n            b[i].b = rnd() % (n + 1);\n            b[i].type = \"ULDR\"[rnd() % 4];\n        }\n\n        auto ans1 = fast(a, b);\n        auto ans2 = slow(a, b);\n        if (ans1 != ans2) {\n            cout << ans1 << \" instead of \" << ans2 << endl;\n            exit(0);\n        }\n    }\n}\n\nint main() {\n#ifdef HOME\n    assert(freopen(\"in\", \"r\", stdin));\n    stress();\n#endif\n\n    int n;\n    while (scanf(\"%d\", &n) == 1) {\n        vector<Item> a(n);\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d%d%lld\", &a[i].x, &a[i].y, &a[i].val);\n        }\n        int m;\n        scanf(\"%d\", &m);\n        vector<Cond> b(m);\n        for (int i = 0; i < m; i++) {\n            scanf(\" %c%d%d\", &b[i].type, &b[i].a, &b[i].b);\n        }\n\n//        printf(\"%lld\\n\", slow(a, b));\n        printf(\"%lld\\n\", fast(a, b));\n    }\n\n#ifdef HOME\n    cerr << \"time: \" << clock() * 1.0 / CLOCKS_PER_SEC << endl;\n#endif\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#define int long long\n#define S 1\n#define T 2\n#define X(x) x + 1000\n#define Y(x) x + 2000\n#define LX(x) 3000 + x\n#define LY(x) 4000 + x\n\nconst int N = 5e3 + 35, M = 4e6 + 64, INF = 0x3f3f3f3f3f3f3f3f;\nconst char _[] = \"UDLR\";\nstruct edge {\n\tint to, next, w;\n\tint c;\n} e[M << 1];\nint head[N], cnt = 1;\nvoid addedge(int x, int y, int z, int w) {\n\te[++cnt] = (edge){y, head[x], z, w}, head[x] = cnt;\n\te[++cnt] = (edge){x, head[y], 0, -w}, head[y] = cnt;\n}\nvoid ek(int s, int t, int& n, int& m) {\n\tstd::queue<int> q;\n\tstatic int dis[N], fl[N], pre[N], vis[N];\n\tfor (n = m = 0; (memset(dis, 0x3f, sizeof dis), fl[s] = INF, dis[s] = 0), 1; n += fl[t], m += fl[t] * dis[t]) {\n\t\tfor (q.push(s); !q.empty(); q.pop())\n\t\t\tfor (int x = q.front(), i = head[x], nx = vis[x] = 0; i; i = e[i].next)\n\t\t\t\tif (dis[nx = e[i].to] > dis[x] + e[i].c && e[i].w)\n\t\t\t\t\tdis[nx] = dis[x] + e[i].c, pre[nx] = i, fl[nx] = std::min(fl[x], e[i].w),\n\t\t\t\t\t(vis[nx] || (q.push(nx), vis[nx] = 1));\n\t\tif (dis[t] == INF) return;\n\t\tfor (int i = pre[t]; i; i = pre[e[i ^ 1].to]) e[i].w -= fl[t], e[i ^ 1].w += fl[t];\n\t}\n}\n\nint n, m, op[N], a[N], b[N], x[N], y[N], z[N];\nint check(int k) {\n\tstatic int U[N], D[N], L[N], R[N];\n\tfor (int i = 1; i <= k; i++) L[i] = D[i] = 0, R[i] = U[i] = 100;\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (op[i] == 0) U[k - b[i]] = a[i] - 1;\n\t\tif (op[i] == 1) D[b[i] + 1] = a[i] + 1;\n\t\tif (op[i] == 2) L[b[i] + 1] = a[i] + 1;\n\t\tif (op[i] == 3) R[k - b[i]] = a[i] - 1;\n\t}\n\tfor (int i = 2; i <= k; i++) L[i] = std::max(L[i], L[i - 1]), D[i] = std::max(D[i], D[i - 1]);\n\tfor (int i = k - 1; i >= 1; i--) R[i] = std::min(R[i], R[i + 1]), U[i] = std::min(U[i], U[i + 1]);\n\tmemset(head, 0, sizeof head), cnt = 1;\n\tfor (int i = 1; i <= n; i++) addedge(X(x[i]), Y(y[i]), 1, -z[i]);\n\tfor (int i = 1; i <= k; i++) {\n\t\tif (L[i] > R[i] || D[i] > U[i]) return 0;\n\t\taddedge(S, LX(i), 1, 0), addedge(LY(i), T, 1, 0);\n\t\tfor (int j = L[i]; j <= R[i]; j++) addedge(LX(i), X(j), 1, 0);\n\t\tfor (int j = D[i]; j <= U[i]; j++) addedge(Y(j), LY(i), 1, 0);\n\t}\n\tint n, m;\n\tek(S, T, n, m);\n\treturn n == k ? -m : 0;\n}\n\nint phead[N], pcnt;\nchar c[2];\nint ans;\nsigned main() {\n\tscanf(\"%lld\", &n);\n\tfor (int i = 1; i <= n; i++) scanf(\"%lld%lld%lld\", x + i, y + i, z + i);\n\tscanf(\"%lld\", &m);\n\tfor (int i = 1; i <= m; i++) scanf(\"%s%lld%lld\", c, a + i, b + i), op[i] = strchr(_, *c) - _;\n\tfor (int i = 1; i <= n; i++) ans = std::max(ans, check(i));\n\tprintf(\"%lld\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace __gnu_pbds;\nusing namespace std;\n \ntemplate <typename T>\nusing ordered_set =\n\ttree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n \n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n\t*this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n \n#define shandom_ruffle random_shuffle\n \nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=327;\nusing bn=bitset<87>;\nusing ld=long double;\n\nint n;\npii gdz[nax];\nll war[nax];\n\nint m;\nbn podz[nax];\nint ile[nax];\n\nll wyn;\n\nbn ter;\n \nll dajwar()\n{\n\tll ret=0;\n\tfor (int i=1; i<=n; i++)\n\t\tif (ter[i])\n\t\t\tret+=war[i];\n\treturn ret;\n}\n \nint popr()\n{\n\tfor (int i=1; i<=m; i++)\n\t\tif ((podz[i]&ter).count()>ile[i])\n\t\t\treturn 0;\n\treturn 1;\n}\n\nvi kol;\n\nstruct Simplex {        // Maximize c*x subject to Ax <= b.\n  using T = ld;     // Initialize the structure, set A, b, c and then run\n  vector<vector<T>> A;  // solve(). Max objective is stored in res. To recover\n  vector<T> b, c;       // the best result, use getVars().\n  int V, E;\n  vector<int> eqIds, varIds, cols;\n  T res;\n  static constexpr T kEps = 1e-17;\n\n  Simplex(int vars, int eqs) : A(eqs, vector<T>(vars)), b(eqs), c(vars),\n      V(vars), E(eqs), eqIds(eqs), varIds(vars), res(0) {\n    iota(varIds.begin(), varIds.end(), 0);\n    iota(eqIds.begin(), eqIds.end(), vars);\n  }\n\n  void pivot(int eq, int var) {\n    T coef = 1 / A[eq][var];\n    cols.clear();\n    for (int i = 0; i < V; i++) {\n      if (abs(A[eq][i]) > kEps) { cols.push_back(i); A[eq][i] *= coef; }\n    }\n    A[eq][var] *= coef; b[eq] *= coef;\n    for (int row = 0; row < E; row++) {\n      if (row == eq || abs(A[row][var]) < kEps) { continue; }\n      T k = -A[row][var];\n      A[row][var] = 0;\n      for (int i : cols) { A[row][i] += k * A[eq][i]; }\n      b[row] += k * b[eq];\n    }\n    T q = c[var]; c[var] = 0;\n    for (int i : cols) { c[i] -= q * A[eq][i]; }\n    res += q * b[eq];\n    swap(varIds[var], eqIds[eq]);\n  }\n\n  bool solve() {\n    while (true) {\n      int eq = -1, var = -1;\n      for (int i = 0; i < E; i++) { if (b[i] < -kEps) { eq = i; break; } }\n      if (eq == -1) { break; }\n      for (int i = 0; i < V; i++) { if (A[eq][i] < -kEps) { var = i; break; } }\n      if (var == -1) { res = -1e9; return false; /* No solution */ }\n      pivot(eq, var);\n    }\n    while (true) {\n      int var = -1, eq = -1;\n      for (int i = 0; i < V; i++) { if (c[i] > kEps) { var = i; break; } }\n      if (var == -1) { break; }\n      for (int i = 0; i < E; i++) {\n        if (A[i][var] < kEps) { continue; }\n        if (eq >= 0 && b[i] / A[i][var] >= b[eq] / A[eq][var]) { continue; }\n        eq = i;\n      }\n      if (eq == -1) { res = 1e9; return false; /* Unbounded */ }\n      pivot(eq, var);\n    }\n    return true;\n  }\n\n  vector<T> getVars() { // Optimal assignment of variables.\n    vector<T> result(V);\n    for (int i = 0; i < E; i++) if (eqIds[i] < V) result[eqIds[i]] = b[i];\n    return result;\n  }\n};\n\nvoid zmien(ld &v)\n{\n\tv*=(800+(rand()%401))/1000.0;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(\"%d%d%lld\", &gdz[i].first, &gdz[i].second, &war[i]);\n\tscanf(\"%d\", &m);\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\tchar c;\n\t\tint a, b;\n\t\tscanf(\" %c%d%d\", &c, &a, &b);\n\t\tfor (int j=1; j<=n; j++)\n\t\t{\n\t\t\tif (c=='L' && gdz[j].first<=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='R' && gdz[j].first>=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='D' && gdz[j].second<=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='U' && gdz[j].second>=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t}\n\t\tile[i]=b;\n\t}\n\tfor (int h=0; h<400; h++)\n\t{\n\t\tSimplex janusz(n, m+2*n);\n\t\tfor (int i=0; i<n; i++)\n\t\t{\n\t\t\tjanusz.c[i]=war[i+1];\n\t\t\tif (h)\n\t\t\t\tzmien(janusz.c[i]);\n\t\t}\n\t\tfor (int i=0; i<m; i++)\n\t\t{\n\t\t\tjanusz.b[i]=ile[i+1];\n\t\t\tfor (int j=0; j<n; j++)\n\t\t\t\tjanusz.A[i][j]=podz[i+1][j+1];\n\t\t}\n\t\tfor (int i=0; i<n; i++)\n\t\t{\n\t\t\tjanusz.b[m+i]=1;\n\t\t\tjanusz.A[m+i][i]=1;\n\t\t}\n\t\tfor (int i=0; i<n; i++)\n\t\t{\n\t\t\tjanusz.b[m+n+i]=0;\n\t\t\tjanusz.A[m+n+i][i]=-1;\n\t\t}\n\t\tassert(janusz.solve());\n\t\tauto wez=janusz.getVars();\n\t\t\n\t\tvector <pair<ld,int> > wek;\n\t\tfor (int i=1; i<=n; i++)\n\t\t\twek.push_back({wez[i-1], i});\n\t\t\n\t\tsort(wek.begin(), wek.end());\n\t\treverse(wek.begin(), wek.end());\n\t\t\n\t\tter.reset();\n\t\t\n\t\tfor (auto i : wek)\n\t\t{\n\t\t\tter[i.second]=1;\n\t\t\tif (!popr())\n\t\t\t\tter[i.second]=0;\n\t\t}\n\t\twyn=max(wyn, dajwar());\n\t}\n\t\n\tprintf(\"%lld\\n\", wyn);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int ll\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define Rep(i,a,b) for(register int i=(a);i<=int(b);++i)\n#define Dep(i,a,b) for(register int i=(a);i>=int(b);--i)\n#define rep(i,a,b) for(register int i=(a);i<int(b);++i)\n#define mem(x,v) memset(x,v,sizeof(x))\n#define fi first\n#define se second\n#define gc getchar\n#define pc putchar\ninline ll read(){\n    ll x=0,f=1;char c=gc();\n    for(;!isdigit(c);c=gc())if(c=='-')f=-1;\n    for(;isdigit(c);c=gc())x=(x<<1)+(x<<3)+(c^48);\n    return x*f;\n}\ninline void write(ll x){if(x<0)x=-x,pc('-');if(x>=10)write(x/10);putchar(x%10+'0');}\ninline void wri(ll x){write(x);pc(' ');}\ninline void writeln(ll x){write(x);pc('\\n');}\nconst int maxn = 2005;\nstruct Edge{\n\tint to,nxt,cap;\n\tll v;\n\tEdge(){}\n\tEdge(int to,int nxt,int cap,ll v):\n\t\tto(to),nxt(nxt),cap(cap),v(v){}\n}edge[maxn*maxn];\nint first[maxn],nume;\nint tot,S,T,idx[maxn],idy[maxn];\nvoid Addedge(int a,int b,int c,ll v){\n//\tprintf(\"_%d -> %d{%d %d}\\n\",a,b,c,v);\n\tedge[nume] = Edge(b,first[a],c,v);first[a] = nume++;\n\tedge[nume] = Edge(a,first[b],0,-v);first[b] = nume++;\n}\nll dis[maxn];\nint q[maxn*maxn],vis[maxn],from[maxn];\nbool spfa(){\n\tRep(i,1,tot) dis[i] = -(1ll<<62),vis[i] = 0,from[i] = -1;\n\tint front=0,rear=0;\n\tq[rear++] = S;dis[S] = 0;vis[S] = true;\n\twhile(front < rear){\n\t\tint u = q[front++];vis[u] = false;\n\t\tfor(int e=first[u];~e;e=edge[e].nxt){\n\t\t\tif(dis[edge[e].to] < dis[u] + edge[e].v && edge[e].cap){\n\t\t\t\tdis[edge[e].to] = dis[u] + edge[e].v;\n\t\t\t\tfrom[edge[e].to] = e;\n\t\t\t\tif(!vis[edge[e].to]){\n\t\t\t\t\tvis[edge[e].to] = true;\n\t\t\t\t\tq[rear++] = edge[e].to;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dis[T] != -(1ll<<62);\n}\nvoid del(){\n\tfor(int e=from[T];~e;e=from[edge[e^1].to]){\n\t\tedge[e].cap--,edge[e^1].cap++;\n\t}\n}\nstruct que{\n\tchar s[10];\n\tint x,cnt;\n}qq[maxn];\nint n,Q,x[maxn],y[maxn],mn[maxn],mx[maxn];\nll v[maxn];\nconst int MX = 100;\nll work(int cnt){\n\tmemset(first,-1,sizeof(first));nume = 0;\n\ttot = 0;S = ++tot;T = ++tot;\n\tRep(i,1,MX) idx[i] = ++tot,idy[i] = ++tot;\n\tRep(i,1,n) Addedge(idx[x[i]],idy[y[i]],1,v[i]);\n\t\n\t\tRep(i,0,cnt+1) mx[i]=MX,mn[i]=1;\n\t\tRep(i,1,Q){\n\t\t\tif (qq[i].s[0]=='L'&&cnt>=qq[i].cnt+1)\n\t\t\t\tmn[qq[i].cnt+1]=max(mn[qq[i].cnt+1],qq[i].x+1);\n\t\t\tif (qq[i].s[0]=='R'&&cnt>=qq[i].cnt+1)\n\t\t\t\tmx[cnt-qq[i].cnt]=min(mx[cnt-qq[i].cnt],qq[i].x-1);\n\t\t}\n\t\tRep(i,1,cnt) mn[i]=max(mn[i],mn[i-1]);\n\t\tDep(i,cnt,1) mx[i]=min(mx[i],mx[i+1]);\n\t\tRep(i,1,cnt){\n\t\t\tint tmp=++tot;\n\t\t\tif (mn[i]>mx[i]) return 0;\n\t\t\tAddedge(S,tmp,1,0);\n\t\t\tRep(j,mn[i],mx[i])\n\t\t\t\tAddedge(tmp,idx[j],1,0);\n\t\t}\n\n\t\tRep(i,0,cnt+1) mx[i]=MX,mn[i]=1;\n\t\tRep(i,1,Q){\n\t\t\tif (qq[i].s[0]=='D'&&cnt>=qq[i].cnt+1)\n\t\t\t\tmn[qq[i].cnt+1]=max(mn[qq[i].cnt+1],qq[i].x+1);\n\t\t\tif (qq[i].s[0]=='U'&&cnt>=qq[i].cnt+1)\n\t\t\t\tmx[cnt-qq[i].cnt]=min(mx[cnt-qq[i].cnt],qq[i].x-1);\n\t\t}\n\t\tRep(i,1,cnt) mn[i]=max(mn[i],mn[i-1]);\n\t\tDep(i,cnt,1) mx[i]=min(mx[i],mx[i+1]);\n\t\tRep(i,1,cnt){\n\t\t\tint tmp=++tot;\n\t\t\tif (mn[i]>mx[i]) return 0;\n\t\t\tAddedge(tmp,T,1,0);\n\t\t\tRep(j,mn[i],mx[i])\n\t\t\t\tAddedge(idy[j],tmp,1,0);\n\t\t}\n\tll ans = 0;\n\tRep(i,1,cnt){\n\t\tif(!spfa()) return 0;\n\t\tans += dis[T]; del();\n\t}\n\treturn ans;\n}\nsigned main(){\n\tscanf(\"%d\",&n);\n\tRep(i,1,n) scanf(\"%d%d%lld\",&x[i],&y[i],&v[i]);\n\tscanf(\"%d\",&Q);\n\tRep(i,1,Q) scanf(\"%s%d%d\",qq[i].s,&qq[i].x,&qq[i].cnt);\n\tll ans = 0;\n\tRep(i,1,n) ans=max(ans,work(i));\n\twriteln(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for((i)=1;(i)<=(n);(i)++) \nusing namespace std;\nint n,m,i,j,px[85],py[85],qa[85],qb[85],s,t,tot;\nchar qt[85];\nint mix[85],miy[85],mxx[85],mxy[85];\nstruct edge{\n\tint y,z;long long d;\n}e[2000005];\nint vis[325],iq[325];\nlong long ans,cst,dis[325],pv[85];\nvector<int> adj[325];\nvoid add(int x,int y,int z,long long d){\n\t++tot;\n\tadj[x].push_back(tot*2-2);\n\tadj[y].push_back(tot*2-1);\n\te[tot*2-2]=(edge){y,z,d};\n\te[tot*2-1]=(edge){x,0,-d}; \n}\nbool bfs(int s,int t){\n\tmemset(dis,-0x3f,sizeof(dis));\n\tdis[s]=0;queue<int> q;q.push(s);\n\twhile(!q.empty()){\n\t\tint x=q.front();q.pop();iq[x]=0;\n\t\tfor(int i=0;i<adj[x].size();i++){\n\t\t\tint t=adj[x][i];\n\t\t\tif(e[t].z&&dis[e[t].y]<dis[x]+e[t].d){\n\t\t\t\tdis[e[t].y]=dis[x]+e[t].d;\n\t\t\t\tif(!iq[e[t].y]){q.push(e[t].y);iq[e[t].y]=1;}\n\t\t\t}\n\t\t}\n\t}\n\treturn dis[t]>dis[0];\n}\nint dfs(int x,int tt,int fw){\n\tif(!fw) return 0; \n\tif(x==tt) return vis[x]=1,fw;\n\tif(vis[x]) return 0;vis[x]=1;\n\tint res=0;\n\tfor(int i=0;i<adj[x].size();i++){\n\t\tint y=adj[x][i];\n\t\tif(e[y].z&&dis[e[y].y]==dis[x]+e[y].d){\n\t\t\tint t=dfs(e[y].y,tt,min(fw,e[y].z));\n\t\t\tfw-=t;res+=t;e[y].z-=t;e[y^1].z+=t;\n\t\t\tcst+=e[y].d*t;\n\t\t}\n\t}\n\treturn res;\n}\nint dinic(int s,int t){\n\tint ans=0;\n\twhile(bfs(s,t)){\n\t\tdo{\n\t\t\tmemset(vis,0,sizeof(vis));\n\t\t\tans+=dfs(s,t,0x3f3f3f3f);\n\t\t}while(vis[t]);\n\t}\n\treturn ans;\n}\nlong long calc(int k){\n\tint i,j;\n\trep(i,k){\n\t\tmix[i]=miy[i]=0;\n\t\tmxx[i]=mxy[i]=101;\n\t}\n\trep(i,m){\n\t\tif(qb[i]<k){\n\t\t\tif(qt[i]=='L') mix[qb[i]+1]=qa[i]+1;\n\t\t\tif(qt[i]=='R') mxx[k-qb[i]]=qa[i]-1; \n\t\t\tif(qt[i]=='D') miy[qb[i]+1]=qa[i]+1;\n\t\t\tif(qt[i]=='U') mxy[k-qb[i]]=qa[i]-1; \n\t\t}\n\t}\n\tfor(i=2;i<=k;i++){\n\t\tmix[i]=max(mix[i],mix[i-1]);\n\t\tmiy[i]=max(miy[i],miy[i-1]);\n\t}\n\tfor(i=k-1;i;i--){\n\t\tmxx[i]=min(mxx[i],mxx[i+1]);\n\t\tmxy[i]=min(mxy[i],mxy[i+1]);\n\t}\n\trep(i,4*n+2){\n\t\tadj[i].clear();\n\t}\n\ttot=0;\n\trep(i,k){\n\t\tadd(s,n+i,1,0);\n\t\tadd(n+n+i,t,1,0);\n\t}\n\trep(i,n){\n\t\tadd(i,n+n+n+i,1,pv[i]);\n\t\trep(j,k){\n\t\t\tif(mix[j]<=px[i]&&px[i]<=mxx[j]){\n\t\t\t\tadd(n+j,i,1,0);\n\t\t\t}\n\t\t\tif(miy[j]<=py[i]&&py[i]<=mxy[j]){\n\t\t\t\tadd(n+n+n+i,n+n+j,1,0);\n\t\t\t}\n\t\t}\n\t}\n\tcst=0;\n\tif(dinic(s,t)!=k) return 0;\n/*\tif(k==4){\n\t\tfor(i=0;i<tot*2;i+=2){\n\t\t\tif(1<=e[i].y&&e[i].y<=n&&n+1<=e[i^1].y&&e[i^1].y<=n+n&&!e[i].z){\n\t\t\t\tcerr<<e[i].y<<endl;\n\t\t\t}\n\t\t}\n\t}*/\n\treturn cst;\n}\nint main(){\n\tcin>>n;s=4*n+1;t=4*n+2;\n\trep(i,n){\n\t\tcin>>px[i]>>py[i]>>pv[i];\n\t}\n\tcin>>m;\n\trep(i,m){\n\t\tcin>>qt[i]>>qa[i]>>qb[i];\n\t}\n\trep(i,n){\n\t\tans=max(ans,calc(i));\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long LL;\nconst int MAXN = 510;\nconst int INF = 0x3f3f3f3f;\nconst int MAXE = MAXN * MAXN * 10;\nconst LL NINF = 0xcfcfcfcfcfcfcfcf;\nint head[MAXN], nxt[MAXE], to[MAXE], val[MAXE], tot = 1;\nLL cost[MAXE];\nvoid addedge(int b, int e, int v, LL c) {\n\tnxt[++tot] = head[b]; to[head[b] = tot] = e; val[tot] = v; cost[tot] = c;\n\tnxt[++tot] = head[e]; to[head[e] = tot] = b; val[tot] = 0; cost[tot] = -c;\n}\nLL dis[MAXN]; bool inq[MAXN];\nstd::queue<int> q;\nint S, T, idx;\nbool bellmanford() {\n\tmemset(dis, 0xcf, idx + 1 << 3);\n\tdis[S] = 0; inq[S] = true; q.push(S);\n\twhile (!q.empty()) {\n\t\tint t = q.front(); q.pop(); inq[t] = false;\n\t\tfor (int i = head[t]; i; i = nxt[i])\n\t\t\tif (val[i] && dis[to[i]] < dis[t] + cost[i]) {\n\t\t\t\tdis[to[i]] = dis[t] + cost[i];\n\t\t\t\tif (!inq[to[i]]) {\n\t\t\t\t\tinq[to[i]] = true;\n\t\t\t\t\tq.push(to[i]);\n\t\t\t\t}\n\t\t\t}\n\t}\n\treturn dis[T] != NINF;\n}\nint dinic(int u, int minv) {\n\tif (u == T || !minv) return minv;\n\tint res = 0, t;\n\tinq[u] = true;\n\tfor (int & i = head[u]; i; i = nxt[i])\n\t\tif (val[i] && !inq[to[i]] && dis[to[i]] == dis[u] + cost[i] && (t = dinic(to[i], std::min(minv, val[i])))) {\n\t\t\tminv -= t;\n\t\t\tres += t;\n\t\t\tval[i] -= t;\n\t\t\tval[i ^ 1] += t;\n\t\t\tif (!minv) break;\n\t\t}\n\tinq[u] = false;\n\tif (!res) dis[u] = NINF;\n\treturn res;\n}\nLL flow(int & fl) {\n\tstatic int th[MAXN];\n\tmemcpy(th, head, idx + 1 << 2);\n\tLL res = 0; int t;\n\twhile (bellmanford()) {\n\t\tt = dinic(S, INF);\n\t\tfl -= t, res += t * dis[T];\n\t\tmemcpy(head, th, idx + 1 << 2);\n\t}\n\treturn res;\n}\nint n, m;\nint xs[MAXN], ys[MAXN];\nint ts[MAXN], as[MAXN], bs[MAXN];\nLL vs[MAXN];\nint xl[MAXN], xr[MAXN], yl[MAXN], yr[MAXN];\nvoid getmax(int & x, int y) { x < y ? x = y : 0; }\nvoid getmin(int & x, int y) { x > y ? x = y : 0; }\nconst int R = 100;\nLL solve(int K) {\n\tmemset(head, 0, idx + 1 << 2); tot = 1, idx = R << 1 | 1;\n\tfor (int i = 1; i <= n; ++i)\n\t\taddedge(xs[i], ys[i] + R, 1, vs[i]);\n\tfor (int i = 0; i <= K + 1; ++i)\n\t\txl[i] = yl[i] = 1, xr[i] = yr[i] = R;\n\tfor (int i = 1; i <= m; ++i) if (bs[i] <= K)\n\t\tswitch (ts[i]) {\n\t\t\tcase 'L': getmax(xl[bs[i] + 1], as[i] + 1); break;\n\t\t\tcase 'R': getmin(xr[K - bs[i]], as[i] - 1); break;\n\t\t\tcase 'D': getmax(yl[bs[i] + 1], as[i] + 1); break;\n\t\t\tcase 'U': getmin(yr[K - bs[i]], as[i] - 1); break;\n\t\t}\n\tfor (int i = 1; i <= K; ++i)\n\t\tgetmax(xl[i], xl[i - 1]), getmax(yl[i], yl[i - 1]);\n\tfor (int i = K; i; --i)\n\t\tgetmin(xr[i], xr[i + 1]), getmin(yr[i], yr[i + 1]);\n\tfor (int i = 1; i <= K; ++i) {\n\t\taddedge(S, ++idx, 1, 0);\n\t\tfor (int j = xl[i]; j <= xr[i]; ++j)\n\t\t\taddedge(idx, j, 1, 0);\n\t\taddedge(++idx, T, 1, 0);\n\t\tfor (int j = yl[i]; j <= yr[i]; ++j)\n\t\t\taddedge(j + R, idx, 1, 0);\n\t}\n\tLL res = flow(K);\n\treturn K ? NINF : res;\n}\n\nint main() {\n\tstd::ios_base::sync_with_stdio(false), std::cin.tie(0);\n\tstd::cin >> n;\n\tfor (int i = 1; i <= n; ++i)\n\t\tstd::cin >> xs[i] >> ys[i] >> vs[i];\n\tstd::cin >> m;\n\tstatic char buf[10];\n\tfor (int i = 1; i <= m; ++i)\n\t\tstd::cin >> buf >> as[i] >> bs[i], ts[i] = *buf;\n\tLL ans = 0;\n\tS = 0, T = idx = R << 1 | 1;\n\tfor (int i = 1; i <= n; ++i)\n\t\tans = std::max(ans, solve(i));\n\tstd::cout << ans << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef HOME\n#define db(x) cerr << #x << \" = \" << x << endl\n#define db3(x, y, z) cerr << \"(\" << #x << \", \" << #y << \", \" << #z << \") = (\" << x << \", \" << y << \", \" << z << \")\" << endl\n#define db2(x, y) cerr << \"(\" << #x << \", \" << #y << \") = (\" << x << \", \" << y << \")\" << endl\n#define dbv(a) cerr << #a << \" = \"; for (auto xxx: a) cerr << xxx  << \" \"; cerr << endl\n#else\n#define db(x) ;\n#define db3(x, y, z) ;\n#define db2(x, y) ;\n#define dbv(a) ;\n#endif\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double dbl;\n\n\nconst int INF = 1.01e9;\nconst int MOD = (int)1e9 + 7;\n\nstruct Item {\n    int x, y;\n    ll val;\n};\n\nstruct Cond {\n    char type;\n    int a, b;\n\n    bool cover(Item it) {\n        if (type == 'L') {\n            return it.x <= a;\n        }\n        if (type == 'R') {\n            return it.x >= a;\n        }\n        if (type == 'D') {\n            return it.y <= a;\n        }\n        if (type == 'U') {\n            return it.y >= a;\n        }\n        assert(0);\n    }\n};\n\nll slow(vector<Item> a, vector<Cond> b) {\n    int n = a.size(), m = b.size();\n    ll ans = 0;\n    for (int mask = 0; mask < (1 << n); mask++) {\n        vector<int> cnt(m);\n        ll sum = 0;\n        for (int i = 0; i < n; i++) {\n            if (!(mask & (1 << i))) continue;\n            sum += a[i].val;\n            for (int j = 0; j < m; j++) {\n                if (b[j].cover(a[i])) {\n                    cnt[j]++;\n                }\n            }\n        }\n        bool bad = 0;\n        for (int i = 0; i < m; i++) {\n            if (cnt[i] > b[i].b) {\n                bad = 1;\n            }\n        }\n        if (bad) continue;\n        ans = max(ans, sum);\n    }\n    return ans;\n}\n\n\nbool eq(dbl a, dbl b) {\n    return fabs(a - b) < 1e-9;\n}\n\nbool ls(dbl a, dbl b) {\n    return !eq(a, b) && a < b;\n}\n\nvector<dbl> supersimplex(vector<vector<dbl> > a) {\n    int n = a.size() - 1;\n    int m = a[0].size() - 1;\n    vector<int> left(n + 1), up(m + 1);\n    iota(up.begin(), up.end(), 0);\n    iota(left.begin(), left.end(), m);\n    while (1) {\n        auto pivot = [&](int x, int y) {\n            swap(left[x], up[y]);\n            dbl k = a[x][y];\n            a[x][y] = 1;\n            vector<int> vct;\n            for (int j = 0; j <= m; j++) {\n                a[x][j] /= k;\n                if (!eq(a[x][j], 0)) vct.push_back(j);\n            }\n            for (int i = 0; i <= n; i++) {\n                if (eq(a[i][y], 0) || i == x) continue;\n                k = a[i][y];\n                a[i][y] = 0;\n                for (int j : vct) a[i][j] -= k * a[x][j];\n            }\n        };\n        while (1) {\n            int x = -1;\n            for (int i = 1; i <= n; i++) if (ls(a[i][0], 0) && (x == -1 || a[i][0] < a[x][0])) x = i;\n            if (x == -1) break;\n            int y = -1;\n            for (int j = 1; j <= m; j++) if (ls(a[x][j], 0) && (y == -1 || a[x][j] < a[x][y])) y = j;\n            if (y == -1) assert(0); // infeasible\n            pivot(x, y);\n        }\n        while (1) {\n            int y = -1;\n            for (int j = 1; j <= m; j++) if (ls(0, a[0][j]) && (y == -1 || a[0][j] > a[0][y])) y = j;\n            if (y == -1) break;\n            int x = -1;\n            for (int i = 1; i <= n; i++)\n                if (ls(0, a[i][y]) && (x == -1 || a[i][0] / a[i][y] < a[x][0] / a[x][y]))\n                    x = i;\n            if (x == -1) assert(0); // unbounded\n            pivot(x, y);\n        }\n\n        vector<int> v;\n        vector<dbl> ans(m + 1);\n        for (int i = 1; i <= n; i++) if (left[i] <= m) ans[left[i]] = a[i][0];\n        ans[0] = -a[0][0];\n        for (int i = 1; i <= m; i++) {\n            if (!eq(ans[i], floor(ans[i])) && !eq(ans[i], floor(ans[i]) + 1)) {\n                v.push_back(i);\n            }\n        }\n        if (v.empty()) {\n            return ans;\n        }\n        for (int i = 0; i <= n; i++) {\n            for (int j = 0; j < (int)v.size(); j++) {\n                a[i].push_back(0);\n            }\n        }\n        for (int i = 0; i < (int)v.size(); i++) {\n            vector<dbl> cur(a[0].size());\n            cur[m + 1 + i] = 1;\n            for (int j = 0; j <= m; j++) {\n                cur[j] = floor(a[v[i]][j]) - a[v[i]][j];\n            }\n            a.push_back(cur);\n        }\n        m += v.size();\n        n += v.size();\n        up.resize(up.size() + n);\n        left.resize(left.size() + n);\n    }\n}\n// j=1..m: x[j]>=0\n// i=1..n: sum(j=1..m) A[i][j]*x[j] <= A[i][0]\n// max sum(j=1..m) A[0][j]*x[j]\n// res[0] is answer\n// res[1..m] is certificate\n\n\n//vector<dbl> supersimplex(vector<vector<dbl> > a) {\n//    while (1) {\n//        int n = a.size() - 1;\n//        int m = a[0].size() - 1;\n//\n//        auto res = solve(a);\n//        int mx = 1;\n//        for (int i = 1; i <= (int)res.size(); i++) {\n//            if (min(res[i] - 0, 1 - res[i]) > min(res[mx] - 0, 1 - res[mx])) {\n//                mx = i;\n//            }\n//        }\n//        if (eq(res[mx], 0) || eq(res[mx], 1)) return res;\n//\n//\n//        for (int i = 1; i <= (int)res.size(); i++) {\n//            if (!eq(0, res[i]) && !eq(1, res[i])) {\n//                vector<dbl> cur(a[0].size() + 1);\n//                cur[0] = floor(a[i][0]) - a[i][0];\n//                for (int j =1 )\n//            }\n//        }\n//    }\n//}\n\nll blyat(vector<Item> a, vector<Cond> b) {\n    int n = a.size(), m = b.size();\n    vector<vector<dbl>> c(m + 1, vector<dbl>(n + 1));\n    for (int i = 0; i < n; i++) {\n        c[0][1 + i] = a[i].val;\n    }\n    for (int i = 0; i < m; i++) {\n        c[1 + i][0] = b[i].b;\n        for (int j = 0; j < n; j++) {\n            if (b[i].cover(a[j])) {\n                c[1 + i][1 + j] = 1;\n            }\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        vector<dbl> cur(n + 1);\n        cur[0] = 1;\n        cur[1 + i] = 1;\n        c.push_back(cur);\n    }\n    auto res = supersimplex(c);\n//    ll ans = 0;\n//    for (int i = 0; i < n; i++) {\n//        if (res[1 + i] > 0.5) {\n//            ans += a[i].val;\n//        }\n//    }\n//    return ans;\n    int cnt = 0;\n    vector<int> v;\n    for (int i = 0; i < n; i++) {\n        if (!eq(0, res[1 + i]) && !eq(1, res[1 + i])) {\n//            cnt++;\n            v.push_back(i);\n        }\n    }\n    static int mx = 0;\n    cnt = v.size();\n    mx = max(mx, cnt);\n    //db2(cnt, mx);\n\n    ll cres = 0;\n    for (int mask = 0; mask < (1LL << (int)v.size()); mask++) {\n        if (mask > 40) break;\n        vector<int> cov(m);\n        ll cost = 0;\n        for (int i = 0; i < n; i++) {\n            if (eq(1, res[1 + i])) {\n                cost += a[i].val;\n                for (int j = 0; j < m; j++) {\n                    cov[j] += b[j].cover(a[i]);\n                }\n            }\n        }\n        for (int i = 0; i <(int)v.size(); i++) {\n            if (mask & (1 << i)) {\n                cost += a[v[i]].val;\n                for (int j= 0; j < m; j++) {\n                    cov[j] += b[j].cover(a[v[i]]);\n                }\n            }\n        }\n        bool ok = 1;\n        for (int j = 0; j < m; j++) ok &= cov[j] <= b[j].b;\n        if (ok) cres = max(cres, cost);\n    }\n    return cres;\n    return (ll)round(res[0]);\n}\n\nll fast(vector<Item> a, vector<Cond> b) {\n    dbl start = clock() / (dbl)CLOCKS_PER_SEC;\n\n    dbl TL = 0.001;\n    auto fail = [&]() {\n        return clock() / (dbl)CLOCKS_PER_SEC - start > TL;\n    };\n\n    int n = a.size();\n    ll ans = blyat(a, b);\n    return ans;\n    for (int i = 0; i < n; i++) {\n        if (fail()) return ans;\n        auto na = a;\n        na.erase(na.begin() + i);\n        ans =max(ans, blyat(na, b));\n    }\n    while (1) {\n        if (fail()) return ans;\n        auto na = a;\n        random_shuffle(na.begin(), na.end());\n        int k = rand() % max(5, n / 6) + 2;\n        k = min(n, k);\n        na.resize(n - k);\n        //na.resize(rand() % (n - (n + 1) / 2) + (n + 1) / 2);\n        ans =max(ans, blyat(na, b));\n    }\n    return ans;\n}\n\nvoid stress() {\n    for (int it = 810;; it++) {\n        mt19937_64 rnd(it);\n        db(it);\n\n\n        int n = rnd() % 15 + 1;\n        vector<Item> a(n);\n        for (int i =0 ; i < n; i++) {\n            a[i].x = rnd() % 100;\n            a[i].y = rnd() % 100;\n            a[i].val = rnd() % (ll)1e15;\n        }\n        int m = rnd() % 15 + 1;\n        vector<Cond> b(m);\n        for (int i = 0; i < m; i++) {\n            b[i].a = rnd() % 100;\n            b[i].b = rnd() % (n + 1);\n            b[i].type = \"ULDR\"[rnd() % 4];\n        }\n\n        auto ans1 = fast(a, b);\n        auto ans2 = slow(a, b);\n        if (ans1 != ans2) {\n            cout << ans1 << \" instead of \" << ans2 << endl;\n            exit(0);\n        }\n    }\n}\n\nint main() {\n#ifdef HOME\n    assert(freopen(\"in\", \"r\", stdin));\n    stress();\n#endif\n\n    int n;\n    while (scanf(\"%d\", &n) == 1) {\n        vector<Item> a(n);\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d%d%lld\", &a[i].x, &a[i].y, &a[i].val);\n        }\n        int m;\n        scanf(\"%d\", &m);\n        vector<Cond> b(m);\n        for (int i = 0; i < m; i++) {\n            scanf(\" %c%d%d\", &b[i].type, &b[i].a, &b[i].b);\n        }\n\n//        printf(\"%lld\\n\", slow(a, b));\n        printf(\"%lld\\n\", fast(a, b));\n    }\n\n#ifdef HOME\n    cerr << \"time: \" << clock() * 1.0 / CLOCKS_PER_SEC << endl;\n#endif\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fo(i,a,b)for(int i=a,_e=b;i<=_e;++i)\n#define fd(i,a,b)for(int i=b,_e=a;i>=_e;--i)\n#define ll long long\n#define db double\nusing namespace std;\nconst int N=500,mo=1e9+7;\nint n,x[100],y[100];\nll v[100];\nint m,A,b;\nll ans,a[N][N];\nchar c;\nvoid simplex(int x,int y,int n,int m){\n\tans+=a[0][x]*a[y][0];\n\tfo(i,0,n){\n\t\tif(i==y||a[i][x]==0)continue;\n\t\tfo(j,0,m)if(j!=x)a[i][j]-=a[i][x]*a[y][j];\n\t\ta[i][x]-=a[i][x]*a[y][x];\n\t}\n}\nvoid solve(int n,int m){\n\tfor(;;){\n\t\tint x=0;\n\t\tfo(i,1,m)if(a[0][i]>0){x=i;break;}\n\t\tif(!x)return;\n\t\tint y=0;ll mi=1e18;\n\t\tfo(i,1,n)if(a[i][x]>0&&mi>a[i][0])y=i,mi=a[i][0];\n\t\tsimplex(x,y,n,m);\n\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfo(i,1,n)scanf(\"%d%d%lld\",&x[i],&y[i],&v[i]),a[0][i]=v[i];\n\tscanf(\"%d\\n\",&m);\n\tfo(i,1,m){\n\t\tc=getchar();\n\t\tscanf(\"%d%d\\n\",&A,&b);\n\t\tfo(j,1,n){\n\t\t\tif(c=='L'&&x[j]<=A)a[i][j]=1;\n\t\t\tif(c=='R'&&x[j]>=A)a[i][j]=1;\n\t\t\tif(c=='D'&&y[j]<=A)a[i][j]=1;\n\t\t\tif(c=='U'&&y[j]>=A)a[i][j]=1;\n\t\t}\n\t\ta[i][0]=b;\n\t}\n\tfo(i,m+1,m+n)a[i][0]=1,a[i][i-m]=1;\n\tsolve(m+n,n);\n\tprintf(\"%lld\\n\",(ll)ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof x)\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define fi first\n#define se second\n#define y0 _y0\n#define y1 _y1\n#define outval(x) cerr<<#x\" = \"<<x<<endl\n#define outtag(x) cerr<<\"-----------------\"#x\"-----------------\\n\"\n#define outarr(a,L,R) cerr<<#a\"[\"<<L<<\"..\"<<R<<\"] = \";\\\n                    For(_x,L,R) cerr<<a[_x]<<\" \";cerr<<endl;\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair <int,int> pii;\nLL read(){\n    LL x=0,f=0;\n    char ch=getchar();\n    while (!isdigit(ch))\n        f=ch=='-',ch=getchar();\n    while (isdigit(ch))\n        x=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n    return f?-x:x;\n}\nconst int N=85,M=325;\nconst LL LLINF=1e18;\nint n,m;\nstruct Node{\n\tint x,y;\n\tLL v;\n}a[N];\nstruct Limit{\n\tchar c;\n\tint a,b;\n}l[M];\nnamespace flows{\n\tconst int N=85*4,M=85*85*2*2;\n\tstruct Edge{\n\t\tint x,y,nxt,cap;\n\t\tLL cost;\n\t\tEdge(){}\n\t\tEdge(int _x,int _y,int _nxt,int _cap,LL _cost){\n\t\t\tx=_x,y=_y,nxt=_nxt,cap=_cap,cost=_cost;\n\t\t}\n\t}e[M];\n\tint n,S,T,cnt;\n\tint fst[N],cur[N],vis[N];\n\tLL dis[N];\n\tvoid clear(int _n,int _S,int _T){\n\t\tn=_n,S=_S,T=_T;\n\t\tclr(fst),cnt=1;\n\t}\n\tvoid Add(int x,int y,int cap,LL cost){\n\t\te[++cnt]=Edge(x,y,fst[x],cap,cost),fst[x]=cnt;\n\t\te[++cnt]=Edge(y,x,fst[y],0,-cost),fst[y]=cnt;\n\t}\n\tint bfs(){\n\t\tstatic queue <int> q;\n\t\twhile (!q.empty())\n\t\t\tq.pop();\n\t\tFor(i,1,n)\n\t\t\tdis[i]=-LLINF,vis[i]=0;\n\t\tdis[S]=0,q.push(S);\n\t\twhile (!q.empty()){\n\t\t\tint x=q.front();\n\t\t\tq.pop();\n\t\t\tvis[x]=0;\n\t\t\tfor (int i=fst[x];i;i=e[i].nxt){\n\t\t\t\tint y=e[i].y;\n\t\t\t\tif (e[i].cap&&dis[x]+e[i].cost>dis[y]){\n\t\t\t\t\tdis[y]=dis[x]+e[i].cost;\n\t\t\t\t\tif (!vis[y]){\n\t\t\t\t\t\tvis[y]=1;\n\t\t\t\t\t\tq.push(y);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dis[T]>-LLINF;\n\t}\n\tint dfs(int x,int Lim){\n\t\tif (x==T||!Lim)\n\t\t\treturn Lim;\n\t\tint rem=Lim;\n\t\tvis[x]=1;\n\t\tfor (int &i=cur[x];i;i=e[i].nxt){\n\t\t\tint y=e[i].y;\n\t\t\tif (!vis[y]&&e[i].cap&&dis[x]+e[i].cost==dis[y]){\n\t\t\t\tint d=dfs(y,min(rem,e[i].cap));\n\t\t\t\trem-=d,e[i].cap-=d,e[i^1].cap+=d;\n\t\t\t}\n\t\t}\n\t\tvis[x]=0;\n\t\treturn Lim-rem;\n\t}\n\tLL Dinic(){\n\t\tLL cost=0;\n\t\twhile (bfs()){\n\t\t\tclr(vis);\n\t\t\tFor(i,1,n)\n\t\t\t\tcur[i]=fst[i];\n\t\t\tint d=dfs(S,1e9);\n\t\t\tcost+=dis[T]*d;\n\t\t}\n\t\treturn cost;\n\t}\n}\nvoid ckmax(int &x,int y){\n\tif (x<y)\n\t\tx=y;\n}\nvoid ckmin(int &x,int y){\n\tif (x>y)\n\t\tx=y;\n}\nint x0[N],x1[N],y0[N],y1[N];\nint main(){\n\tn=read();\n\tFor(i,1,n)\n\t\ta[i].x=read(),a[i].y=read(),a[i].v=read();\n\tm=read();\n\tFor(i,1,m){\n\t\tchar s[10];\n\t\tcin>>s>>l[i].a>>l[i].b;\n\t\tl[i].c=s[0];\n\t}\n\tLL ans=0;\n\tFor(k,1,n){\n\t\tint S=(n+k)*2+1,T=S+1;\n\t\tflows::clear(T,S,T);\n\t\tFor(i,0,k+1){\n\t\t\tx0[i]=y0[i]=0;\n\t\t\tx1[i]=y1[i]=101;\n\t\t}\n\t\tFor(i,1,m){\n\t\t\tif (l[i].b>=k)\n\t\t\t\tcontinue;\n\t\t\tif (l[i].c=='L')\n\t\t\t\tckmax(x0[l[i].b+1],l[i].a);\n\t\t\tif (l[i].c=='R')\n\t\t\t\tckmin(x1[k-l[i].b],l[i].a);\n\t\t\tif (l[i].c=='D')\n\t\t\t\tckmax(y0[l[i].b+1],l[i].a);\n\t\t\tif (l[i].c=='U')\n\t\t\t\tckmin(y1[k-l[i].b],l[i].a);\n\t\t}\n\t\tFor(i,1,k){\n\t\t\tckmax(x0[i],x0[i-1]);\n\t\t\tckmax(y0[i],y0[i-1]);\n\t\t}\n\t\tFod(i,k,1){\n\t\t\tckmin(x1[i],x1[i+1]);\n\t\t\tckmin(y1[i],y1[i+1]);\n\t\t}\n\t\tFor(i,1,n)\n\t\t\tflows::Add(i,i+n,1,a[i].v);\n\t\tFor(i,1,k){\n\t\t\tflows::Add(S,i+n*2,1,0);\n\t\t\tflows::Add(i+n*2+k,T,1,0);\n\t\t\tFor(j,1,n){\n\t\t\t\tif (x0[i]<a[j].x&&a[j].x<x1[i])\n\t\t\t\t\tflows::Add(i+n*2,j,1,0);\n\t\t\t\tif (y0[i]<a[j].y&&a[j].y<y1[i])\n\t\t\t\t\tflows::Add(j+n,i+n*2+k,1,0);\n\t\t\t}\n\t\t}\n\t\tans=max(ans,flows::Dinic());\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define itn int\n#define all(x) (x).begin(), (x).end()\n#define make_unique(x) sort(all((x))); (x).resize(unique(all((x))) - (x).begin())\n\n#define random_shuffle(...) shuffle(__VA_ARGS__, rng)\n#define rand() rng()\n\nusing namespace std;\n\ninline int nxt() {\n\tint x;\n\tscanf(\"%d\", &x);\n\treturn x;\n}\n\n#define sz(x) ((int) (x).size())\n#define forn(i,n) for (int i = 0; i < int(n); ++i)\n\ntypedef long long ll;\ntypedef long long i64;\ntypedef long double ld;\nconst int inf = int(1e9) + int(1e5);\nconst ll infl = ll(2e18) + ll(1e10);\n\nconst int maxn = 505;\nconst int maxm = 505;\n\nconst ld eps = 1e-1;\n\nbool eq(ld a, ld b) {\n    return fabsl(a - b) < eps;\n}\n\n//BEGIN_CODE\nnamespace Simplex {\n\nld D[maxm][maxn]; // [n+2][m+2]\nint B[maxm];\nint N[maxn];\nld x[maxn];\nint n, m;\n\n//x >= 0, Ax <= b, c^Tx -> max\nvoid init(int _n, int _m, ld A[][maxn], ld *b, ld *c) {\n    n = _n, m = _m;\n    forn (i, m)\n        forn (j, n)\n            D[i][j] = -A[i][j];\n    forn (i, m) {\n        D[i][n] = 1;\n        D[i][n + 1] = b[i];\n    }\n    forn (j, n) {\n        D[m][j] = c[j];\n        D[m + 1][j] = 0;\n    }\n    D[m][n + 1] = D[m][n] = D[m + 1][n + 1] = 0;\n    D[m + 1][n] = -1;\n    iota(B, B + m, n);\n    iota(N, N + n, 0);\n    N[n] = -1;\n}\n\nvoid pivot(int b, int nb) {\n    assert(D[b][nb] != 0);\n    ld q = 1. / -D[b][nb];\n    D[b][nb] = -1;\n    forn (i, n + 2)\n        D[b][i] *= q;\n    forn (i, m + 2) {\n        if (i == b)\n            continue;\n        ld coef = D[i][nb];\n        D[i][nb] = 0;\n        forn (j, n + 2)\n            D[i][j] += coef * D[b][j];\n    }\n    swap(B[b], N[nb]);\n}\n\nbool betterN(int f, int i, int j) {\n    if (eq(D[f][i], D[f][j]))\n        return N[i] < N[j];\n    return D[f][i] > D[f][j];\n}\n\nbool betterB(int nb, int i, int j) {\n    ld ai = D[i][n + 1] / D[i][nb];\n    ld aj = D[j][n + 1] / D[j][nb];\n    if (eq(ai, aj))\n        return B[i] < B[j];\n    return ai > aj;\n}\n\nbool simplex(int phase) {\n    int f = phase == 1 ? m : m + 1;\n    while (true) {\n        int nb = -1;\n        forn (i, n + 1) {\n            if (N[i] == -1 && phase == 1)\n                continue;\n            if (nb == -1 || betterN(f, i, nb))\n                nb = i;\n        }\n        if (D[f][nb] <= eps)\n            return phase == 1;\n        assert(nb != -1);\n\n        int b = -1;\n        forn (i, m) {\n            if (D[i][nb] >= -eps)\n                continue;\n            if (b == -1 || betterB(nb, i, b))\n                b = i;\n        }\n        if (b == -1)\n            return false;\n        pivot(b, nb);\n        if (N[nb] == -1 && phase == 2)\n            return true;\n    }\n}\n\nld solve() {\n    int b = -1;\n    forn (i, m) {\n        if (b == -1 || D[i][n + 1] < D[b][n + 1])\n            b = i;\n    }\n    assert(b != -1);\n    if (D[b][n + 1] < -eps) {\n        pivot(b, n);\n        if (!simplex(2) || D[m + 1][n + 1] < -eps)\n            return -infl;\n    }\n    if (!simplex(1))\n        return infl;\n\n    forn (i, n)\n        x[i] = 0;\n    forn (i, m)\n        if (B[i] < n)\n            x[B[i]] = D[i][n + 1];\n\n    return D[m][n + 1];\n}\n\n} //Simplex\n//END_CODE\n\nstruct Treasure {\n\tint x, y;\n\tlong long v;\n\n\tvoid scan() {\n\t\tscanf(\"%d%d%lld\", &x, &y, &v);\n\t}\n};\n\nstruct Constraint {\n\tchar t;\n\tint a, b;\n\n\tvoid scan() {\n\t\tcin >> t >> a >> b;\n\t}\n\n\tbool isAbout(const Treasure& tr) const {\n\t\tif (t == 'D') {\n\t\t\treturn tr.y <= a;\n\t\t} else if (t == 'U') {\n\t\t\treturn tr.y >= a;\n\t\t} else if (t == 'L') {\n\t\t\treturn tr.x <= a;\n\t\t} else if (t == 'R') {\n\t\t\treturn tr.x >= a;\n\t\t} else {\n\t\t\tassert(false);\n\t\t}\n\t}\n};\n\nld a[maxm][maxn];\nld b[maxm];\nld c[maxn];\n\nint main() {\n\tmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n\tint n = nxt();\n\tvector<Treasure> trs(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\ttrs[i].scan();\n\t}\n\n\tint m = nxt();\n\tvector<Constraint> crs(m);\n\tfor (int i = 0; i < m; ++i) {\n\t\tcrs[i].scan();\n\t}\n\n\tfor (int i = 0; i < m; ++i) {\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\ta[i][j] = crs[i].isAbout(trs[j]);\n\t\t}\n\t\tb[i] = crs[i].b;\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\ta[m + i][i] = 1;\n\t\tb[m + i] = 1;\n\t\tc[i] = trs[i].v;\n\t}\n\n\tSimplex::init(n, n + m, a, b, c);\n\t// Simplex::solve();\n\n\tlong double ans = Simplex::solve();\n\t// for (int i = 0; i < n; ++i) {\n\t// \tans += trs[i].v * (int)(roundl(Simplex::x[i]));\n\t// }\n\tcout << (long long)roundl(ans) << \"\\n\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MV = 815;\nconst int ME = 1200006;\nconst ll oo = 1e18;\n\ntemplate <typename T> void cmin(T &x, const T &y)\n{\n\tif(y < x) x = y;\n}\n\ntemplate <typename T> void cmax(T &x, const T &y)\n{\n\tif(y > x) x = y;\n}\n\ntemplate <typename T> void read(T &x)\n{\n\tx = 0; char c = getchar(); bool f = 0;\n\twhile(!isdigit(c) && c!='-') c = getchar();\n\tif(c == '-') f = 1, c = getchar();\n\twhile(isdigit(c)) x = x*10+c-'0', c = getchar();\n\tif(f) x = -x;\n}\n\nstruct edge\n{\n\tint u, v, f;\n\tll c;\n\tint n;\n\n\tedge (const int &u0 = 0, const int &v0 = 0, const ll &f0 = 0, const ll &c0 = 0, const int &n0 = 0) : u(u0), v(v0), f(f0), c(c0), n(n0) {}\n};\n\nstruct GRAPH\n{\n\tedge e[ME];\n\tint fst[MV], lnum;\n\n\tvoid init() {memset(fst, 0xff, sizeof(fst)); lnum = -1;}\n\t\n\tGRAPH () {init();}\n\t\n\tvoid addeg(int nu, int nv, ll nc, int nf)\n\t{\n\t\te[++lnum] = edge(nu, nv, nf, nc, fst[nu]), fst[nu] = lnum;\n\t\te[++lnum] = edge(nv, nu, 0, -nc, fst[nv]), fst[nv] = lnum;\n\t}\n\t\n\tint que[MV], inq[MV], cur[MV];\n\tll dis[MV];\n\t\n\tbool spfa(int frm, int tar)\n\t{\n\t\tint h = 1, t = 1, x, y;\n\t\tmemset(dis, 0x9f, sizeof(dis));\n\t\tdis[frm] = 0;\n\t\tque[h] = frm;\n\t\tinq[frm] = 1;\n\t\twhile(h >= t)\n\t\t{\n\t\t\tx = que[(t++)%MV];\n\t\t\tinq[x] = 0;\n\t\t\tfor(int i=fst[x]; ~i; i=e[i].n)\n\t\t\t{\n\t\t\t\ty = e[i].v;\n\t\t\t\tif(e[i].f && dis[y]<dis[x]+e[i].c)\n\t\t\t\t{\n\t\t\t\t\tdis[y] = dis[x] + e[i].c;\n\t\t\t\t\tif(!inq[y]) que[(++h)%MV] = y, inq[y] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn (dis[tar] > -oo);\n\t}\n\t\n\tint dinic(int x, int t, int f)\n\t{\n\t\tif(x == t) return f;\n\t\tint a, y, now = 0;\n\t\tinq[x] = 1;\n\t\tfor(int &i=cur[x]; ~i; i=e[i].n)\n\t\t{\n\t\t\ty = e[i].v;\n\t\t\tif(dis[y]==dis[x]+e[i].c && e[i].f && !inq[y])\n\t\t\t{\n\t\t\t\ta = dinic(y, t, min(e[i].f, f-now));\n\t\t\t\tnow += a;\n\t\t\t\te[i].f -= a;\n\t\t\t\te[i^1].f += a;\n\t\t\t\tif(now == f) break;\n\t\t\t}\n\t\t}\n\t\tinq[x] = 0;\n\t\treturn now;\n\t}\n\t\n\tpair<int, ll> costf(int s, int t)\n\t{\n\t\tll cost = 0;\n\t\tint flow = 0;\n\t\twhile(spfa(s, t))\n\t\t{\n\t\t\tmemmove(cur, fst, sizeof(cur));\n\t\t\tint new_flow = dinic(s, t, ME);\n\t\t\tcost += dis[t] * new_flow;\n\t\t\tflow += new_flow;\n\t\t}\n\t\treturn make_pair(flow, cost);\n\t}\n} G;\n\nint n, m;\nint lx[MV], rx[MV];\nint ly[MV], ry[MV];\nint px[MV], py[MV];\nll pv[MV];\nchar qc[MV];\nint qa[MV], qb[MV];\nint global_s, global_t;\n\nvoid input()\n{\n\tread(n);\n\tfor(int i=1; i<=n; i++) read(px[i]), read(py[i]), read(pv[i]);\n\tread(m);\n\tfor(int i=1; i<=n; i++) lx[i] = 1, rx[i] = 100, ly[i] = 1, ry[i] = 100;\n\tfor(int i=1; i<=m; i++)\n\t{\n\t\tqc[i] = getchar();\n\t\twhile(!isalpha(qc[i])) qc[i] = getchar();\n\t\tread(qa[i]), read(qb[i]);\n\t}\n}\n\nvoid build(int num)\n{\n\tfor(int i=1; i<=num; i++) lx[i] = ly[i] = 1, rx[i] = ry[i] = 100;\n\tfor(int i=1; i<=m; i++)\n\t{\n\t\tif(qb[i] > num) continue;\n\t\tif(qc[i] == 'L') cmax(lx[qb[i]+1], qa[i]+1);\n\t\tif(qc[i] == 'R') cmin(rx[num-qb[i]], qa[i]-1);\n\t\tif(qc[i] == 'D') cmax(ly[qb[i]+1], qa[i]+1);\n\t\tif(qc[i] == 'U') cmin(ry[num-qb[i]], qa[i]-1);\n\t}\n\tfor(int i=2; i<=num; i++) cmax(lx[i], lx[i-1]), cmax(ly[i], ly[i-1]);\n\tfor(int i=num-1; i>=1; i--) cmin(rx[i], rx[i+1]), cmin(ry[i], ry[i+1]);\n\tG.init();\n\tfor(int i=1; i<=num; i++)\n\t{\n\t\tfor(int j=1; j<=n; j++)\n\t\t{\n\t\t\tif(lx[i]<=px[j] && px[j]<=rx[i]) G.addeg(i, num*2+j, 0, 1);\n\t\t\tif(ly[i]<=py[j] && py[j]<=ry[i]) G.addeg(num*2+n+j, num+i, 0, 1);\n\t\t}\n\t}\n\tfor(int i=1; i<=n; i++) G.addeg(num*2+i, num*2+n+i, pv[i], 1);\n\tglobal_s = num*2+n*2+1, global_t = global_s+1;\n\tfor(int i=1; i<=num; i++) G.addeg(global_s, i, 0, 1), G.addeg(num+i, global_t, 0, 1);\n}\n\nvoid work()\n{\n\tll ans = 0;\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tbuild(i);\n\t\tauto ret = G.costf(global_s, global_t);\n\t\tif(ret.first != i) break;\n\t\telse cmax(ans, ret.second);\n\t}\n\tprintf(\"%lld\\n\", ans);\n}\n\nint main()\n{\n\tinput();\n\twork();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define REV(i,n) for(ll (i) = (n) - 1;(i) >= 0;--i)\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {REP(WW,n)cerr << v[WW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,WW,HH) {REP(W_,WW){REP(H_,HH)cerr << v[W_][H_] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n#define fastcin() cin.tie(0);ios::sync_with_stdio(false)\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nclass minCostFlow {\n\n\tstruct edge { ll to, cap, cost, rev; };\n\n\tll V;\n\tvector<vector<edge>> G;\n\tvector<ll> dist;\n\tvector<ll> prevv;\n\tvector<ll> preve;\n\npublic:\n\n\tminCostFlow(ll n): G(n), dist(n), prevv(n), preve(n), V(n){\n\t}\n\n\tvoid addEdge(ll from, ll to, ll cap, ll cost) {\n\t\tG[from].push_back((edge){to, cap, cost, (ll)G[to].size()});\n\t\tG[to].push_back((edge){from, 0, -cost, (ll)G[from].size() - 1});\n\t}\n\n\tll solve(ll s, ll t, ll f) {\n\t\tll ret = 0;\n\t\twhile(f > 0) {\n\t\t\tfill(dist.begin(), dist.end(), LLINF);\n\t\t\tdist[s] = 0;\n\t\t\tbool update = true;\n\t\t\twhile(update) {\n\t\t\t\tupdate = false;\n\t\t\t\tfor(ll v = 0;v < V;v++) {\n\t\t\t\t\tif(dist[v] == LLINF)continue;\n\t\t\t\t\tfor(ll i = 0;i < G[v].size();i++) {\n\t\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\t\tif(e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n\t\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dist[t] == LLINF) {\n\t\t\t\treturn LLINF;//流せない\n\t\t\t}\n\n\t\t\tll d = f;\n\t\t\tfor(ll v = t;v != s;v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tret += d * dist[t];\n\t\t\tfor(ll v = t;v != s;v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n};\n\nll check(vector<pair<P, ll>> v, vector<pair<char, P>> t, int k){\n\tll cost = 1000000000000000LL;\n\tint n = v.size();\n\tint m = t.size();\n\t\n\tvector<P> ver(k, MP(0, LLINF));\n\tvector<P> hor(k, MP(0, LLINF));\n\t\n\tREP(i, m){\n\t\tchar c = t[i].FI;\n\t\tP p = t[i].SE;\n\t\tif(c == 'L'){\n\t\t\tif(p.SE >= k)continue;\n\t\t\thor[p.SE].FI = max(hor[p.SE].FI, p.FI + 1);\n\t\t}\n\t\telse if(c == 'R'){\n\t\t\tif(k - p.SE - 1 < 0)continue;\n\t\t\thor[k - p.SE - 1].SE = min(hor[k - p.SE - 1].SE, p.FI - 1);\n\t\t}\n\t\telse if(c == 'D'){\n\t\t\tif(p.SE >= k)continue;\n\t\t\tver[p.SE].FI = max(ver[p.SE].FI, p.FI + 1);\n\t\t}\n\t\telse {\n\t\t\tif(k - p.SE - 1 < 0)continue;\n\t\t\tver[k - p.SE - 1].SE = min(ver[k - p.SE - 1].SE, p.FI - 1);\n\t\t}\n\t}\n\t\n\tREP(i, k - 1){\n\t\tver[i + 1].FI = max(ver[i + 1].FI, ver[i].FI);\n\t\thor[i + 1].FI = max(hor[i + 1].FI, hor[i].FI);\n\t\tver[k - i - 2].SE = min(ver[k - i - 2].SE, ver[k - i - 1].SE); \n\t\thor[k - i - 2].SE = min(hor[k - i - 2].SE, hor[k - i - 1].SE); \n\t}\n\t\n\t//REP(i, k)cout << \"(\" << hor[i].FI << \", \" << hor[i].SE << \") \";cout << endl;\n\t//REP(i, k)cout << \"(\" << ver[i].FI << \", \" << ver[i].SE << \") \";cout << endl;\n\t\n\tminCostFlow mcf(2 * (n + k) + 10);\n\t\n\tll s = 2 * (k + n);\n\tll g = 2 * (k + n) + 1;\n\t\n\tREP(i, k){\n\t\tll idA = 2 * n + i;\n\t\tll idB = 2 * n + k + i;\n\t\tmcf.addEdge(s, idA, 1, 0);\n\t\tmcf.addEdge(idB, g, 1, 0);\n\t}\n\t\n\tREP(i, n){\n\t\tP now = v[i].FI;\n\t\tll val = v[i].SE;\n\t\tll idA = i;\n\t\tll idB = i + n;\n\t\tmcf.addEdge(idA, idB, 1, cost - val);\n\t\tREP(j, k){\n\t\t\tll idC = 2 * n + j;\n\t\t\tll idD = 2 * n + k + j;\n\t\t\tif(now.FI >= hor[j].FI && now.FI <= hor[j].SE){\n\t\t\t\tmcf.addEdge(idC, idA, 1, 0);\n\t\t\t}\n\t\t\tif(now.SE >= ver[j].FI && now.SE <= ver[j].SE){\n\t\t\t\tmcf.addEdge(idB, idD, 1, 0);\n\t\t\t}\n\t\t}\n\t}\n\tll ret = k * cost - mcf.solve(s, g, k);\n\t//cout << \"check \" << k << \" \" << ret << endl;\n\treturn ret;\n}\n\nint main(){\n\t\n\tll n;cin >> n;\n\tvector<pair<P, ll>> v(n);\n\tREP(i, n)cin >> v[i].FI.FI >> v[i].FI.SE >> v[i].SE;\n\tll m;cin >> m;\n\tvector<pair<char, P>> t(m);\n\tREP(i, m)cin >> t[i].FI >> t[i].SE.FI >> t[i].SE.SE;\n\t\n\tll ans = 0;\n\t\n\tfor(ll i = 1;i <= n;i++){\n\t\tans = max(ans, check(v, t, i));\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define Rep(i,a,b) for(register int i=(a);i<=int(b);++i)\n#define Dep(i,a,b) for(register int i=(a);i>=int(b);--i)\n#define rep(i,a,b) for(register int i=(a);i<int(b);++i)\n#define mem(x,v) memset(x,v,sizeof(x))\n#define fi first\n#define se second\n#define gc getchar\n#define pc putchar\ninline ll read(){\n    ll x=0,f=1;char c=gc();\n    for(;!isdigit(c);c=gc())if(c=='-')f=-1;\n    for(;isdigit(c);c=gc())x=(x<<1)+(x<<3)+(c^48);\n    return x*f;\n}\ninline void write(ll x){if(x<0)x=-x,pc('-');if(x>=10)write(x/10);putchar(x%10+'0');}\ninline void wri(ll x){write(x);pc(' ');}\ninline void writeln(ll x){write(x);pc('\\n');}\nconst int maxn = 1005;\nstruct Edge{\n\tint to,nxt,cap;\n\tll v;\n\tEdge(){}\n\tEdge(int to,int nxt,int cap,ll v):\n\t\tto(to),nxt(nxt),cap(cap),v(v){}\n}edge[maxn*maxn];\nint first[maxn],nume;\nint tot,S,T,idx[maxn],idy[maxn];\nvoid Addedge(int a,int b,int c,ll v){\n//\tprintf(\"_%d -> %d{%d %d}\\n\",a,b,c,v);\n\tedge[nume] = Edge(b,first[a],c,v);first[a] = nume++;\n\tedge[nume] = Edge(a,first[b],0,-v);first[b] = nume++;\n}\nll dis[maxn];\nint q[maxn*maxn],vis[maxn],from[maxn];\nbool spfa(){\n\tRep(i,1,tot) dis[i] = -(1ll<<62),vis[i] = 0;\n\tint front=0,rear=0;\n\tq[rear++] = S;dis[S] = 0;vis[S] = true;\n\twhile(front < rear){\n\t\tint u = q[front++];vis[u] = false;\n\t\tfor(int e=first[u];~e;e=edge[e].nxt){\n\t\t\tif(dis[edge[e].to] < dis[u] + edge[e].v && edge[e].cap){\n\t\t\t\tdis[edge[e].to] = dis[u] + edge[e].v;\n\t\t\t\tfrom[edge[e].to] = e;\n\t\t\t\tif(!vis[edge[e].to]){\n\t\t\t\t\tvis[edge[e].to] = true;\n\t\t\t\t\tq[rear++] = edge[e].to;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dis[T] != -(1ll<<62);\n}\nvoid del(){\n\tfor(int e=from[T];e;e=from[edge[e^1].to]){\n\t\tedge[e].cap--,edge[e^1].cap++;\n\t}\n}\nstruct que{\n\tchar s[10];\n\tint x,cnt;\n}qq[maxn];\nint n,Q,x[maxn],y[maxn],mn[maxn],mx[maxn];\nll v[maxn];\nconst int MX = 100;\nll work(int cnt){\n\tmemset(first,-1,sizeof(first));nume = 0;\n\ttot = 0;S = ++tot;T = ++tot;\n\tRep(i,1,MX) idx[i] = ++tot,idy[i] = ++tot;\n\tRep(i,1,n) Addedge(idx[x[i]],idy[y[i]],1,v[i]);\n\t\n\t\tRep(i,0,cnt+1) mx[i]=MX,mn[i]=1;\n\t\tRep(i,1,Q){\n\t\t\tif (qq[i].s[0]=='L'&&cnt>=qq[i].cnt+1){\n\t\t\t\tmn[qq[i].cnt+1]=max(mn[qq[i].cnt+1],qq[i].x+1);\n//\t\t\t\tprintf(\"Mn(%d) [%d]\\n\",qq[i].cnt+1,qq[i].x+1);\n\t\t\t}\n\t\t\tif (qq[i].s[0]=='R'&&cnt>=qq[i].cnt+1)\n\t\t\t\tmx[cnt-qq[i].cnt]=min(mx[cnt-qq[i].cnt],qq[i].x-1);\n\t\t}\n\t\tRep(i,1,cnt) mn[i]=max(mn[i],mn[i-1]);\n\t\tDep(i,cnt,1) mx[i]=min(mx[i],mx[i+1]);\n//\t\tRep(i,1,cnt){\n//\t\t\tprintf(\"{%d %d}\\n\",mn[i],mx[i]);\n//\t\t}\n\t\tRep(i,1,cnt){\n\t\t\tint tmp=++tot;\n\t\t\tif (mn[i]>mx[i]) return 0;\n\t\t\tAddedge(S,tmp,1,0);\n\t\t\tRep(j,mn[i],mx[i])\n\t\t\t\tAddedge(tmp,idx[j],1,0);\n\t\t}\n\n\t\tRep(i,0,cnt+1) mx[i]=MX,mn[i]=1;\n\t\tRep(i,1,Q){\n\t\t\tif (qq[i].s[0]=='D'&&cnt>=qq[i].cnt+1)\n\t\t\t\tmn[qq[i].cnt+1]=max(mn[qq[i].cnt+1],qq[i].x+1);\n\t\t\tif (qq[i].s[0]=='U'&&cnt>=qq[i].cnt+1)\n\t\t\t\tmx[cnt-qq[i].cnt]=min(mx[cnt-qq[i].cnt],qq[i].x-1);\n\t\t}\n\t\tRep(i,1,cnt) mn[i]=max(mn[i],mn[i-1]);\n\t\tDep(i,cnt,1) mx[i]=min(mx[i],mx[i+1]);\n\t\tRep(i,1,cnt){\n\t\t\tint tmp=++tot;\n\t\t\tif (mn[i]>mx[i]) return 0;\n\t\t\tAddedge(tmp,T,1,0);\n\t\t\tRep(j,mn[i],mx[i])\n\t\t\t\tAddedge(idy[j],tmp,1,0);\n\t\t}\n\tll ans = 0;\n\tRep(i,1,cnt){\n\t\tif(!spfa()) return 0;\n\t\tans += dis[T];\n\t\tdel();\n\t}\n//\tprintf(\"%lld %lld\\n\",cnt,ans);\n\treturn ans;\n}\nint main(){\n\tn = read();\n\tRep(i,1,n){\n\t\tx[i] = read(),y[i] = read(),v[i] = read();\n\t}\n\tQ = read();\n\tRep(i,1,Q){\n\t\tscanf(\"%s\",qq[i].s);qq[i] . x = read(),qq[i] . cnt = read();\n\t}ll ans = 0;\n//\twork(1);\n//\treturn 0;\n\tRep(i,1,n) ans=max(ans,work(i));\n\twriteln(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n \nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n \n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n \ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n \ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n \ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n \n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n \nstruct Simplex {        // Maximize c*x subject to Ax <= b.\n  using T = LD;         // Initialize the structure, set A, b, c and then run\n  vector<vector<T>> A;  // solve(). Max objective is stored in res. To recover\n  vector<T> b, c;       // the best result, use getVars().\n \n  int V, E;\n  VI eqIds, varIds, cols;\n  T res;\n  const T kEps = 1e-9;\n \n  Simplex(int vars, int eqs) : A(eqs, vector<T>(vars)), b(eqs), c(vars),\n                               V(vars), E(eqs), eqIds(eqs), varIds(vars), res(0) {\n    iota(ALL(varIds), 0); iota(ALL(eqIds), vars);\n  }\n \n  void pivot(int eq, int var) {\n    T coef = 1 / A[eq][var];\n    cols.clear();\n    REP (i, V) {\n      if (abs(A[eq][i]) > kEps) { cols.PB(i); A[eq][i] *= coef; }\n    }\n    A[eq][var] *= coef; b[eq] *= coef;\n    REP (row, E) {\n      if (row == eq || abs(A[row][var]) < kEps) { continue; }\n      T k = -A[row][var];\n      A[row][var] = 0;\n      for (int i : cols) { A[row][i] += k * A[eq][i]; }\n      b[row] += k * b[eq];\n    }\n    T q = c[var]; c[var] = 0;\n    for (int i : cols) { c[i] -= q * A[eq][i]; }\n    res += q * b[eq];\n \n    swap(varIds[var], eqIds[eq]);\n  }\n  \n  bool solve() {\n    while (true) {\n      int eq = -1, var = -1;\n      REP (i, E) { if (b[i] < -kEps) { eq = i; break; } }\n      if (eq == -1) { break; }\n      REP (i, V) { if (A[eq][i] < -kEps) { var = i; break; } }\n      if (var == -1) { res = -1e9; return false; /* No solution */ }\n      pivot(eq, var);\n    }\n \n    while (true) {\n      int var = -1, eq = -1;\n      REP (i, V) { if (c[i] > kEps) { var = i; break; } }\n      if (var == -1) { break; }\n      REP (i, E) {\n        if (A[i][var] < kEps) { continue; }\n        if (eq >= 0 && b[i] / A[i][var] >= b[eq] / A[eq][var]) { continue; }\n        eq = i;\n      }\n      if (eq == -1) { res = 1e9; return false; /* Unbounded */ }\n      pivot(eq, var);\n    }\n \n    return true;\n  }\n  \n  vector<T> getVars() {  // Optimal assignment of variables.\n    vector<T> result(V);\n    REP (i, E) { if (eqIds[i] < V) { result[eqIds[i]] = b[i]; } }\n    return result;\n  }\n};\n \nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n \n  int N, M;\n  cin >> N;\n  vector<PII> points(N);\n  vector<int> point_vals(N);\n \n  for (int i = 0; i < N; ++i) {\n    cin >> points[i].st >> points[i].nd >> point_vals[i];\n  }\n \n  map<char, function<bool(PII, int)>> checkers = {\n    {'L', [](const PII &pt, int a) { return pt.st <= a; }},\n    {'R', [](const PII &pt, int a) { return pt.st >= a; }},\n    {'D', [](const PII &pt, int a) { return pt.nd <= a; }},\n    {'U', [](const PII &pt, int a) { return pt.nd >= a; }}\n  };\n \n  cin >> M;\n\n  LL best_ans = 0;\n\n  vector<tuple<char, int, int>> infos;\n\n  for (int i = 0; i < M; ++i) {\n    char type;\n    int a, b;\n    cin >> type >> a >> b;\n    infos.emplace_back(type, a, b);\n  }\n \n  for (int num_set = 0; num_set <= N; ++num_set) {\n    Simplex sim(N, M + 2 * N + 2);\n    for (int i = 0; i < M; ++i) {\n      char type;\n      int a, b;\n      tie(type, a, b) = infos[i];\n   \n      for (int j = 0; j < N; ++j) {\n        sim.A[i][j] = checkers[type](points[j], a);\n      }\n      sim.b[i] = b;\n   \n      debug(sim.A[i], sim.b[i]);\n    }\n    for (int i = 0; i < N; ++i) {\n      sim.c[i] = point_vals[i];\n      sim.A[M + i * 2][i] = -1;\n      sim.A[M + i * 2 + 1][i] = 1;\n      sim.b[M + i * 2] = 0;\n      sim.b[M + i * 2 + 1] = 1;\n\n      sim.A[M + 2 * N][i] = 1;\n      sim.A[M + 2 * N + 1][i] = -1;\n    }\n\n    sim.b[M + 2 * N] = num_set;\n    sim.b[M + 2 * N + 1] = -num_set;\n   \n    if (sim.solve()) {\n      maxi(best_ans, (LL)sim.res);\n    }\n  }\n\n  cout << best_ans << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define fst first\n#define snd second\n#define SZ(u) ((int) (u).size())\n#define ALL(u) (u).begin(), (u).end()\n\ninline void proc_status()\n{\n\tifstream t(\"/proc/self/status\");\n\tcerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate<typename T> inline T read()\n{\n\tregister T sum(0), fg(1);\n\tregister char ch(getchar());\n\tfor(; !isdigit(ch); ch = getchar()) if(ch == '-') fg = -1;\n\tfor(;  isdigit(ch); ch = getchar()) sum = sum * 10 - '0' + ch;\n\treturn sum * fg;\n}\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\nconst int MAXN = 80, MAXM = 320;\n\nstruct point\n{\n\tint x, y;\n\tLL w;\n\n\tpoint() { }\n\tpoint(int _x, int _y, LL _w): x(_x), y(_y), w(_w) { }\n};\n\nint n, m;\n\npoint A[MAXN + 5];\n\nstruct lim\n{\n\tint l, r;\n\n\tlim() { }\n\tlim(int _l, int _r): l(_l), r(_r) { }\n};\n\nint l0[MAXN + 5], r0[MAXN + 5], l1[MAXN + 5], r1[MAXN + 5];\n\ninline char safe_getchar()\n{\n\tregister char ch(getchar());\n\twhile(!isupper(ch)) ch = getchar();\n\treturn ch;\n}\n\ninline void input()\n{\n\tn = read<int>();\n\tfor(int i = 1; i <= n; ++i) A[i].x = read<int>(), A[i].y = read<int>(), A[i].w = read<LL>();\n\n\tm = read<int>();\n\tfor(int i = 1; i <= n; ++i) l0[i] = l1[i] = 0, r0[i] = r1[i] = 101;\n\tfor(int i = 1; i <= m; ++i)\n\t{\n\t\tchar type = safe_getchar();\n\t\tint a = read<int>(), b = read<int>();\n\t\tif(type == 'L') chkmax(l0[b + 1], a);\n\t\telse if(type == 'R') chkmin(r0[b + 1], a);\n\t\telse if(type == 'D') chkmax(l1[b + 1], a);\n\t\telse if(type == 'U') chkmin(r1[b + 1], a);\n\t\telse assert(0);\n\t}\n}\n\nnamespace FLOW\n{\n\tconst int MAXV = MAXN * 3 + 2;\n\tconst int MAXE = MAXN * MAXN * 2 + MAXN * 3;\n\n\tstruct edge\n\t{\n\t\tint adj, nxt, c;\n\t\tLL w;\n\n\t\tedge() { }\n\t\tedge(int _adj, int _nxt, int _c, LL _w): adj(_adj), nxt(_nxt), c(_c), w(_w) { }\n\t};\n\n\tedge e[MAXE * 2 + 5];\n\tint st[MAXV + 5], edge_cnt;\n\n\tinline void real_add_edge(int u, int v, int c, LL w, int type = 1)\n\t{\n\t\te[edge_cnt] = edge(v, st[u], c, w), st[u] = edge_cnt++;\n\t\tif(type) real_add_edge(v, u, 0, -w, 0);\n\t}\n\n\tinline void init(int N)\n\t{\n\t\tfor(int i = 1; i <= N; ++i) st[i] = -1;\n\t\tedge_cnt = 0;\n\t}\n\n\tnamespace cache\n\t{\n\t\tstruct EDGE\n\t\t{\n\t\t\tint u, v, c;\n\t\t\tLL w;\n\n\t\t\tEDGE() { }\n\t\t\tEDGE(int _u, int _v, int _c, LL _w): u(_u), v(_v), c(_c), w(_w) { }\n\t\t};\n\n\t\tEDGE stk[MAXE + 5];\n\t\tint top = 0;\n\t}\n\n\tinline void add_edge(int u, int v, int c, LL w)\n\t{\n\t\tusing namespace cache;\n\t\tstk[++top] = EDGE(u, v, c, w);\n\t}\n\n\tinline void build_graph(int N)\n\t{\n\t\tinit(N);\n\t\tusing namespace cache;\n\n\t\twhile(top > 0) real_add_edge(stk[top].u, stk[top].v, stk[top].c, stk[top].w), --top;\n\t}\n\n\tconst LL INF = LLONG_MAX / 2;\n\n\tint cur[MAXV + 5];\n\tLL d[MAXV + 5];\n\n\tinline LL SPFA(int S, int T, int N)\n\t{\n\t\tstatic queue<int> q;\n\t\tstatic int inq[MAXV + 5];\n\t\tfor(int i = 1; i <= N; ++i) inq[i] = 0, d[i] = -INF;\n\n\t\td[S] = 0, q.push(S);\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tint u = q.front();\n\t\t\tinq[u] = 0, q.pop();\n\t\t\tcur[u] = st[u];\n\n\t\t\tfor(int i = st[u]; ~i; i = e[i].nxt)\n\t\t\t{\n\t\t\t\tint v = e[i].adj;\n\t\t\t\tif(e[i].c > 0 && chkmax(d[v], d[u] + e[i].w) && !inq[v]) inq[v] = 1, q.push(v);\n\t\t\t}\n\t\t}\n\n\t\treturn d[T];\n\t}\n\n\tint vis[MAXN + 5];\n\n\tinline int dfs(int u, int T, int low)\n\t{\n\t\tif(u == T) return low;\n\n\t\tvis[u] = 1;\n\t\tint sum = 0;\n\t\tfor(int k, &i = cur[u]; ~i; i = e[i].nxt)\n\t\t{\n\t\t\tint v = e[i].adj;\n\t\t\tif(!vis[v] && d[v] == d[u] + e[i].w && e[i].c > 0 && (k = dfs(v, T, min(low, e[i].c))) > 0)\n\t\t\t{\n\t\t\t\te[i].c -= k;\n\t\t\t\te[i ^ 1].c += k;\n\t\t\t\tlow -= k;\n\t\t\t\tsum += k;\n\t\t\t\tif(low == 0) { vis[u] = 0; return sum; }\n\t\t\t}\n\t\t}\n\t\tvis[u] = 0;\n\t\treturn sum;\n\t}\n\n\tinline pair<int, LL> solve(int S, int T, int N)\n\t{\n\t\tbuild_graph(N);\n\n\t\tint flow = 0;\n\t\tLL sum = 0;\n\t\tfor(LL cost; (cost = SPFA(S, T, N)) != -INF; )\n\t\t\tfor(int k; (k = dfs(S, T, INT_MAX)) > 0; )\n\t\t\t{\n\t\t\t\tflow += k;\n\t\t\t\tsum += cost * k;\n\t\t\t}\n\t\treturn mp(flow, sum);\n\t}\n}\n\ninline void solve()\n{\n\tLL ans = 0;\n\tfor(int k = 1; k <= n; ++k)\n\t{\n\t\tstatic int X[MAXN + 5], Y[MAXN + 5];\n\n\t\tint cnt = 0, S = 0, T = 0;\n\t\tS = ++cnt, T = ++cnt;\n\t\tfor(int i = 1; i <= k; ++i)\n\t\t{\n\t\t\tX[i] = ++cnt, Y[i] = ++cnt;\n\t\t\tFLOW::add_edge(S, X[i], 1, 0);\n\t\t\tFLOW::add_edge(Y[i], T, 1, 0);\n\t\t}\n\n\t\tstatic pii p[MAXN + 5], q[MAXN + 5];\n\n\t\tfor(int i = 1; i <= k; ++i) p[i] = q[i] = mp(0, 101);\n\t\tfor(int i = 1; i <= k; ++i)\n\t\t{\n\t\t\tchkmax(p[i].fst, l0[i]);\n\t\t\tchkmin(p[i].snd, r0[k - i + 1]);\n\t\t\tchkmax(q[i].fst, l1[i]);\n\t\t\tchkmin(q[i].snd, r1[k - i + 1]);\n\t\t}\n\t\tfor(int i = 2; i <= k; ++i)\n\t\t{\n\t\t\tchkmax(p[i].fst, p[i - 1].fst);\n\t\t\tchkmax(q[i].fst, q[i - 1].fst);\n\t\t}\n\t\tfor(int i = k - 1; i >= 1; --i)\n\t\t{\n\t\t\tchkmin(p[i].snd, p[i + 1].snd);\n\t\t\tchkmin(q[i].snd, q[i + 1].snd);\n\t\t}\n\n\t\tstatic int in[MAXN + 5], out[MAXN + 5];\n\n\t\tfor(int i = 1; i <= n; ++i)\n\t\t{\n\t\t\tin[i] = ++cnt, out[i] = ++cnt;\n\t\t\tFLOW::add_edge(in[i], out[i], 1, A[i].w);\n\t\t\tfor(int j = 1; j <= k; ++j) if(p[j].fst < A[i].x && A[i].x < p[j].snd) FLOW::add_edge(X[j], in[i], 1, 0);\n\t\t\tfor(int j = 1; j <= k; ++j) if(q[j].fst < A[i].y && A[i].y < q[j].snd) FLOW::add_edge(out[i], Y[j], 1, 0);\n\t\t}\n\n\t\tauto res = FLOW::solve(S, T, cnt);\n\t\tif(res.fst == k) chkmax(ans, res.snd);\n\t}\n\n\tprintf(\"%lld\\n\", ans);\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n//\tfreopen(\"E.in\", \"r\", stdin);\n//\tfreopen(\"E.out\", \"w\", stdout);\n#endif\n\n\tinput();\n\tsolve();\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define MAXN 400\n#define MAXM 100000\n#define INF 2000000000\n#define INF2 1000000000000000000LL\n#define LL long long\nLL sumcost,C[MAXM],val[MAXN],ans,d[MAXN];\nint Adj[MAXN],V[MAXM],nxt[MAXM],W[MAXM],c=1;\nvoid AddEdge(int u,int v,int w,LL cost)\n{\n\tc++;V[c]=v,W[c]=w,C[c]=cost,nxt[c]=Adj[u];Adj[u]=c;\n\tc++;V[c]=u,W[c]=0,C[c]=-cost,nxt[c]=Adj[v];Adj[v]=c;\n}\nint tg[MAXN],h[MAXN],id,S,T,F,n,m;\nint dfs(int u,int in)\n{\n\ttg[u]=id;\n\tif(u==T)\n\t{\n\t\tF+=in;\n\t\treturn in;\n\t}\n\tfor(int i=h[u];i;i=nxt[i])\n\t\tif(tg[V[i]]!=id&&W[i]>0&&d[V[i]]+C[i]==d[u])\n\t\t{\n\t\t\tint nf=dfs(V[i],min(in,W[i]));\n\t\t\tif(nf)\n\t\t\t{\n\t\t\t\tW[i]-=nf,W[i^1]+=nf,h[u]=i;sumcost+=C[i]*nf;\n\t\t\t\treturn nf;\n\t\t\t}\n\t\t}\n\th[u]=0;\n\treturn 0;\n}\nbool Find()\n{\n\tLL k=-INF2;\n\tfor(int u=S;u<=T;u++)\n\t\tif(tg[u]==id)\n\t\t\tfor(int i=Adj[u];i;i=nxt[i])\n\t\t\t\tif(tg[V[i]]!=id&&W[i]>0)\n\t\t\t\t\tk=max(k,d[V[i]]+C[i]-d[u]);\n\tif(k==-INF2) return 0;\n\tfor(int u=S;u<=T;u++) if(tg[u]==id) d[u]+=k;\n\treturn 1;\n}\nvoid ZKW()\n{\n\tfor(int i=S;i<=T;i++) d[i]=0;\n\tF=0,sumcost=0;\n\tdo\n\t{\n\t\tid++;\n\t\tfor(int i=S;i<=T;i++) h[i]=Adj[i];\n\t\twhile(dfs(S,INF)) id++;\n\t}while(Find());\n}\nvoid Min(int &x,int y)\n{\n\tif(y<x) x=y;\n}\nvoid Max(int &x,int y)\n{\n\tif(y>x) x=y;\n}\nint a[MAXM],b[MAXM],t[MAXM],p[MAXN][4],x[MAXN],y[MAXN];\nvoid Solve(int tot)\n{\n\tmemset(Adj,0,sizeof Adj);c=1;\n\tfor(int i=1;i<=tot;i++) p[i][0]=p[i][2]=1,p[i][1]=p[i][3]=100;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tif(b[i]>=tot) continue;\n\t\tif(t[i]&1) Min(p[tot-b[i]][t[i]],a[i]-1);\n\t\telse Max(p[b[i]+1][t[i]],a[i]+1);\n\t}\n\tfor(int i=2;i<=tot;i++)\n\t{\n\t\tMax(p[i][0],p[i-1][0]);\n\t\tMax(p[i][2],p[i-1][2]);\n\t}\n\tfor(int i=tot-1;i>=1;i--)\n\t{\n\t\tMin(p[i][1],p[i+1][1]);\n\t\tMin(p[i][3],p[i+1][3]);\n\t}\n\tS=1,T=2*tot+2*n+2;\n\tint k=tot*2+1;\n\tfor(int i=1;i<=tot;i++)\n\t\tAddEdge(S,i*2,1,0),AddEdge(i*2+1,T,1,0);\n\tfor(int i=1;i<=n;i++) AddEdge(k+i,k+n+i,1,val[i]);\n\tfor(int i=1;i<=tot;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tif(p[i][0]<=x[j]&&x[j]<=p[i][1]) AddEdge(i*2,k+j,1,0);\n\t\t\tif(p[i][2]<=y[j]&&y[j]<=p[i][3]) AddEdge(k+n+j,i*2+1,1,0);\n\t\t}\n\tZKW();\n\tif(F==tot) ans=max(ans,sumcost);\n}\nint main()\n{\n\tchar s[5];\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d%d%lld\",&x[i],&y[i],&val[i]);\n\tscanf(\"%d\",&m);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%s%d%d\",s,&a[i],&b[i]);\n\t\tif(s[0]=='L') t[i]=0;\n\t\telse if(s[0]=='R') t[i]=1;\n\t\telse if(s[0]=='D') t[i]=2;\n\t\telse t[i]=3;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tSolve(i);\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nconst int S=0,T=400;\nint N;\nstruct edge{\n\tint s,t,cap;long long v;int nxt;\n}e[50005];\nint e_cnt,last[405];\nvoid addedge(int u,int v,int cap,long long l){\n\te[e_cnt]=(edge){u,v,cap,l,last[u]};\n\tlast[u]=e_cnt++;\n\te[e_cnt]=(edge){v,u,0,-l,last[v]};\n\tlast[v]=e_cnt++;\n}\npriority_queue<pair<long long,int> > q;\nlong long d[405];int fa[405];\nbool dinic(){\n\tmemset(d,129,sizeof(d));\n\td[S]=0;\n\tq.push(make_pair(d[S],S));\n\tfor(int i=1;i<=N;i++){\n\t\tif(q.empty())break;\n\t\tpair<long long,int> t;\n\t\twhile(!q.empty()){\n\t\t\tt=q.top(); q.pop();\n\t\t\tif(t.first==d[t.second])break;\n\t\t}\n\t\tif(t.first!=d[t.second])break;\n\t\tint x=t.second;\n\t\tif(x==T)return true;\n\t\tfor(int i=last[x];i!=-1;i=e[i].nxt)if(e[i].cap&&d[e[i].t]<d[x]+e[i].v){\n\t\t\td[e[i].t]=d[x]+e[i].v;\n\t\t\tfa[e[i].t]=i;\n\t\t\tq.push(make_pair(d[e[i].t],e[i].t));\n\t\t}\n\t}\n\treturn false;\n}\npair<int,long long> solve(){\n\tint flow=0;long long cost=0;\n\twhile(dinic()){\n\t\tflow++;\n\t\tint u=T;\n\t\twhile(u!=S){\n\t\t\tcost+=e[fa[u]].v;\n\t\t\te[fa[u]].cap=0;\n\t\t\te[fa[u]^1].cap=1;\n\t\t\tu=e[fa[u]].s;\n\t\t}\n\t}\n\treturn make_pair(flow,cost);\n}\nint x[85],y[85];long long v[85];\nint t[325],a[325],b[325];\nint L[85][2],R[85][2];\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d%d%lld\",&x[i],&y[i],&v[i]);\n\t}\n\tint m;\n\tscanf(\"%d\",&m);\n\tfor(int i=1;i<=m;i++){\n\t\tchar c=getchar();\n\t\twhile(c<'A'||c>'Z')c=getchar();\n\t\tif(c=='L')t[i]=0;\n\t\tif(c=='R')t[i]=1;\n\t\tif(c=='D')t[i]=2;\n\t\tif(c=='U')t[i]=3;\n\t\tscanf(\"%d%d\",&a[i],&b[i]);\n\t}\n\tlong long ans=0;\n\tfor(int supy=1;supy<=n;supy++){\n\t\tmemset(R,63,sizeof(R));\n\t\tfor(int j=1;j<=m;j++)if(b[j]<supy){\n\t\t\tif(t[j]&1)R[supy-b[j]][t[j]>>1]=min(R[supy-b[j]][t[j]>>1],a[j]-1);\n\t\t\telse L[b[j]+1][t[j]>>1]=max(L[b[j]+1][t[j]>>1],a[j]+1);\n\t\t}\n\t\tfor(int i=2;i<=supy;i++)for(int j=0;j<2;j++)L[i][j]=max(L[i][j],L[i-1][j]);\n\t\tfor(int i=supy-1;i>0;i--)for(int j=0;j<2;j++)R[i][j]=min(R[i][j],R[i+1][j]);\n\t\t// for(int i=1;i<=supy;i++)printf(\"%d %d\\n\",L[i][0],R[i][0]);\n\t\t// for(int i=1;i<=supy;i++)printf(\"%d %d\\n\",L[i][1],R[i][1]);\n\t\te_cnt=0;\n\t\tmemset(last,-1,sizeof(last));\n\t\tfor(int i=1;i<=supy;i++)addedge(S,i,1,0),addedge(i+supy,T,1,0);\n\t\tfor(int i=1;i<=n;i++)addedge(i+2*supy,i+n+2*supy,1,v[i]);\n\t\tfor(int i=1;i<=supy;i++)\n\t\t\tfor(int j=1;j<=n;j++)if(x[j]>=L[i][0]&&x[j]<=R[i][0])addedge(i,j+2*supy,1,0);\n\t\tfor(int i=1;i<=supy;i++)\n\t\t\tfor(int j=1;j<=n;j++)if(y[j]>=L[i][1]&&y[j]<=R[i][1])addedge(j+n+2*supy,i+supy,1,0);\n\t\tN=2*supy+2*n+2;\n\t\tpair<int,long long>res=solve();\n\t\tif(res.first==supy)ans=max(ans,res.second);\n\t\t// printf(\"%d %d %lld\\n\",supy,res.first,res.second);\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mset(a, b) memset(a, b, sizeof(a))\n#define mcpy(a, b) memcpy(a, b, sizeof(a))\nusing namespace std;\ntypedef long long LL;\nconst int N = 405;\nconst int M = 100005;\nconst LL INF = 0x3f3f3f3f3f3f3f3f;\n\ntemplate <typename T> inline void read(T &AKNOI) {\n\tT x = 0, flag = 1;\n\tchar ch = getchar();\n\twhile (!isdigit(ch)) {\n\t\tif (ch == '-') flag = -1;\n\t\tch = getchar();\n\t}\n\twhile (isdigit(ch)) {\n\t\tx = x * 10 + ch - '0';\n\t\tch = getchar();\n\t}\n\tAKNOI = flag * x;\n}\n\ntemplate <typename T> inline void cmin(T &x, T y) {\n\tif (x > y) x = y;\n}\n\ntemplate <typename T> inline void cmax(T &x, T y) {\n\tif (x < y) x = y;\n}\n\nint tot, S, T, inq[N], pre[N];\nLL dis[N];\nqueue<int> q;\n\nstruct Edge {\n\tint v, w, nxt;\n\tLL c;\n} e[M << 1];\nint first[N], eCnt;\n\ninline void AddEdge(int u, int v, int w, LL c) {\n\te[++eCnt].v = v;\n\te[eCnt].w = w;\n\te[eCnt].c = c;\n\te[eCnt].nxt = first[u];\n\tfirst[u] = eCnt;\n}\n\ninline void Add(int u, int v, int w, LL c) {\n\tAddEdge(u, v, w, c);\n\tAddEdge(v, u, 0, -c);\n}\n\nbool SPFA() {\n\tfor (int i = 1; i <= tot; ++i) {\n\t\tdis[i] = -INF;\n\t}\n\tdis[S] = 0;\n\tq.push(S);\n\twhile (!q.empty()) {\n\t\tint u = q.front();\n\t\tq.pop(); inq[u] = 0;\n\t\tfor (int i = first[u]; i; i = e[i].nxt) {\n\t\t\tint v = e[i].v;\n\t\t\tif (e[i].w && dis[v] < dis[u] + e[i].c) {\n\t\t\t\tdis[v] = dis[u] + e[i].c;\n\t\t\t\tpre[v] = i;\n\t\t\t\tif (!inq[v]) {\n\t\t\t\t\tq.push(v);\n\t\t\t\t\tinq[v] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn (dis[T] > -INF);\n}\n\nLL Update() {\n\tint flow = 100;\n\tfor (int i = pre[T]; i; i = pre[e[i ^ 1].v]) {\n\t\tcmin(flow, e[i].w);\n\t}\n\tfor (int i = pre[T]; i; i = pre[e[i ^ 1].v]) {\n\t\te[i].w -= flow;\n\t\te[i ^ 1].w += flow;\n\t}\n\treturn dis[T] * flow;\n}\n\nLL Costflow() {\n\tLL mxcost = 0;\n\twhile (SPFA()) {\n\t\tmxcost += Update();\n\t}\n\treturn mxcost;\n}\n\nchar qt[N];\nint n, m, X[N], Y[N], qa[N], qb[N];\nLL V[N];\nint lx[N], rx[N], ly[N], ry[N];\n\nLL Work(int x) {\n\tmset(first, 0);\n\teCnt = 1;\n\tS = 201, T = tot = 202;\n\tfor (int i = 1; i <= x; ++i) {\n\t\tlx[i] = ly[i] = 1;\n\t\trx[i] = ry[i] = 100;\n\t}\n\t\n\tfor (int i = 1; i <= m; ++i) {\n\t\tif (qb[i] > x) continue;\n\t\tif (qt[i] == 'L') {\n\t\t\tcmax(lx[qb[i] + 1], qa[i] + 1);\n\t\t} else if (qt[i] == 'R') {\n\t\t\tcmin(rx[x - qb[i]], qa[i] - 1);\n\t\t} else if (qt[i] == 'D') {\n\t\t\tcmax(ly[qb[i] + 1], qa[i] + 1);\n\t\t} else if (qt[i] == 'U') {\n\t\t\tcmin(ry[x - qb[i]], qa[i] - 1);\n\t\t}\n\t}\n\tfor (int i = 2; i <= x; ++i) {\n\t\tcmax(lx[i], lx[i - 1]);\n\t\tcmax(ly[i], ly[i - 1]);\n\t}\n\tfor (int i = x - 1; i >= 1; --i) {\n\t\tcmin(rx[i], rx[i + 1]);\n\t\tcmin(ry[i], ry[i + 1]);\n\t}\n\t\n\tfor (int i = 1; i <= n; ++i) {\n\t\tAdd(X[i], 100 + Y[i], 1, V[i]);\n\t}\n\tfor (int i = 1; i <= x; ++i) {\n\t\tif (lx[i] > rx[i] || ly[i] > ry[i]) return -INF;\n\t\tAdd(S, ++tot, 1, 0);\n\t\tfor (int j = lx[i]; j <= rx[i]; ++j) {\n\t\t\tAdd(tot, j, 1, 0);\n\t\t}\n\t\tAdd(++tot, T, 1, 0);\n\t\tfor (int j = ly[i]; j <= ry[i]; ++j) {\n\t\t\tAdd(100 + j, tot, 1, 0);\n\t\t}\n\t}\n\treturn Costflow();\n}\n\nvoid init() {\n\tread(n);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tread(X[i]); read(Y[i]); read(V[i]);\n\t}\n\tread(m);\n\tfor (int i = 1; i <= m; ++i) {\n\t\tqt[i] = getchar();\n\t\tread(qa[i]); read(qb[i]);\n\t}\n}\n\nvoid solve() {\n\tLL ans = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tcmax(ans, Work(i));\n\t}\n\tprintf(\"%lld\\n\", ans);\n}\n\nint main() {\n\tinit();\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define to edge[i].v\n#define mp make_pair\n#define rint register int\n#define fgx cerr<<\"-------------\"<<endl\n#define N 666\n#define add(a,b,c,d) adde(a,b,c,d),adde(b,a,0,-(d))\nusing namespace std;\ntypedef long long ll;\ntypedef long double db;\ntypedef pair<int,ll> pii;\nvoid dbg(){cerr<<endl;}\ntemplate<typename A,typename... B>void dbg(A x,B... y){cerr<<x<<\" \";dbg(y...);}\n#define debug(...) cerr<<#__VA_ARGS__<<\"=\",dbg(__VA_ARGS__)\nint T,tot,head[N],vis[N],pre[N],xl[N],xr[N],yl[N],yr[N],n,m; ll dis[N]; char c[10];\nstruct Edge{int u,v,w,f,next;ll c;}edge[N*N];\ninline void adde(int x,int y,int w,ll c){edge[++tot]=Edge{x,y,w,0,head[x],c};head[x]=tot;}\ninline int spfa()\n{\tfor(rint i=0;i<=T;i++) dis[i]=-1e18; queue<int> q; q.push(0); dis[0]=0; pre[T]=-1;\n\twhile(!q.empty())\n\t{\tint x=q.front(); vis[x]=0; q.pop();\n\t\tfor(rint i=head[x];i;i=edge[i].next)\n\t\tif(dis[to]<dis[x]+edge[i].c&&edge[i].f<edge[i].w)\n\t\t{\tdis[to]=dis[x]+edge[i].c; pre[to]=i;\n\t\t\tif(!vis[to])q.push(to),vis[to]=1;\n\t\t}\n\t}\n\treturn pre[T]!=-1;\n}\ninline pii mcmf(int f=0,ll c=0)\n{\twhile(spfa())\n\t{\tint mn=1e9; for(rint i=pre[T];i;i=pre[edge[i].u]) mn=min(mn,edge[i].w-edge[i].f);\n\t\tf+=mn; c+=dis[T]*mn; for(rint i=pre[T];i;i=pre[edge[i].u]) edge[i].f+=mn,edge[i^1].f-=mn;\n\t}\n\treturn mp(f,c);\n}\nstruct P{int x,y;ll v;}p[N]; struct Q{char c;int x,y;}q[N];\ninline ll gao(int k)\n{\tfor(rint i=0;i<=k+1;i++) xl[i]=yl[i]=1,xr[i]=yr[i]=100;\n\tfor(rint i=1;i<=m;i++)\n\tif(q[i].c=='L') xl[q[i].y+1]=max(xl[q[i].y+1],q[i].x+1);\n\telse if(q[i].c=='R') xr[k-q[i].y]=min(xr[k-q[i].y],q[i].x-1);\n\telse if(q[i].c=='D') yl[q[i].y+1]=max(yl[q[i].y+1],q[i].x+1);\n\telse yr[k-q[i].y]=min(yr[k-q[i].y],q[i].x-1);\n\tfor(rint i=1;i<=k;i++) xl[i]=max(xl[i],xl[i-1]),yl[i]=max(yl[i],yl[i-1]);\n\tfor(rint i=k;i>=1;i--) xr[i]=min(xr[i],xr[i+1]),yr[i]=min(yr[i],yr[i+1]);\n\ttot=1; memset(head,0,sizeof(head));\n\tfor(rint i=1;i<=k;i++) add(0,i,1,0);\n\tfor(rint i=1;i<=k;i++) for(rint j=xl[i];j<=xr[i];j++) add(i,k+j,1,0);\n\tfor(rint i=1;i<=n;i++) add(k+p[i].x,k+100+p[i].y,1,p[i].v);\n\tfor(rint i=1;i<=k;i++) for(rint j=yl[i];j<=yr[i];j++) add(k+100+j,k+200+i,1,0);\n\tT=2*k+201; for(rint i=1;i<=k;i++) add(k+200+i,T,1,0);\n\tpii ans=mcmf(); return ans.first==k?ans.second:0;\n}\nint main()\n{\tcin>>n; for(rint i=1;i<=n;i++) scanf(\"%d%d%lld\",&p[i].x,&p[i].y,&p[i].v);\n\tcin>>m; for(rint i=1;i<=m;i++) scanf(\"%s%d%d\",c+1,&q[i].x,&q[i].y),q[i].c=c[1];\n\tll ans=0; for(rint i=1;i<=n;i++) ans=max(ans,gao(i)); cout<<ans;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define nn 808\n#define ll long long \n\nnamespace ene{\n\tvector<ll> v[nn],cap[nn],cost[nn],rev[nn];\n\tvoid clear()\n\t{\n\t\tfor(ll i=0;i<nn;i++) v[i].clear(),cap[i].clear(),cost[i].clear(),rev[i].clear();\n\t}\n\tvoid link(ll x,ll y,ll c,ll d)\n\t{\n\t\trev[x].push_back(v[y].size());rev[y].push_back(v[x].size());\n\t\tv[x].push_back(y);v[y].push_back(x);\n\t\tcap[x].push_back(c);cap[y].push_back(0);\n\t\tcost[x].push_back(d);cost[y].push_back(-d);\n\t}\n\t\n\tll ss;ll vis[nn];\n\tll prex[nn],prei[nn];ll dist[nn];\n\tvoid spfa(ll s)\n\t{\n\t\tfor(ll i=0;i<nn;i++) dist[i]=-1e18;\n\t\tqueue<ll> q;q.push(s);dist[s]=0;vis[s]=1;\n\t\twhile(q.size())\n\t\t{\n\t\t\tll x=q.front();q.pop();vis[x]=0;\n\t\t\tfor(ll i=0;i<v[x].size();i++)\n\t\t\t{\n\t\t\t\tll y=v[x][i];\n\t\t\t\tif(dist[y]<dist[x]+cost[x][i] and cap[x][i])\n\t\t\t\t{\n\t\t\t\t\tdist[y]=dist[x]+cost[x][i],prex[y]=x,prei[y]=i;\n\t\t\t\t\tif(!vis[y]) q.push(y);vis[y]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll dfs(ll y,ll f)\n\t{\n\t\tif(y==ss) return f;\n\t\tll x=prex[y],i=prei[y],j=rev[x][i];\n\t\tf=dfs(x,min(f,cap[x][i]));\n\t\tcap[x][i]-=f,cap[y][j]+=f;\n\t\treturn f;\n\t}\n\tll solve(ll s,ll t,ll n)\n\t{\n\t\tss=s;ll ans=0;\n\t\twhile(1)\n\t\t{\n\t\t\tspfa(s);if(dist[t]<-1e17) break;\n\t\t\tll tp=dfs(t,1e18);\n\t\t\ttp=min(tp,n);n-=tp;\n\t\t\tans+=tp*dist[t];\n\t\t}\n\t\tif(n) return -1e18;\n\t\treturn ans;\n\t}\n\n};\n\nll n,m;\nll xans[nn],yans[nn];ll val[nn];\nll s=nn-1,t=nn-2;\nll morex[nn],morey[nn],lessx[nn],lessy[nn];\nchar str[nn][3];ll xx[nn],kk[nn];\nll output=0;\nvoid solve(ll guess)\n{\n\tene::clear();set<ll> sx,sy;map<ll,ll> mx,my;\n\tfor(ll i=1;i<=n;i++) sx.insert(xans[i]),sy.insert(yans[i]);\t\n\t\n\tsx.insert(1e16),sy.insert(1e16);\n\t\n\tll tot=0;ll xn,yn;\n\tfor(set<ll>::iterator it=sx.begin();it!=sx.end();it++) mx[*it]=++tot;xn=tot;\n\tfor(set<ll>::iterator it=sy.begin();it!=sy.end();it++) my[*it]=++tot;yn=tot;\n\t\n\tfor(ll i=1;i<=n;i++) ene::link(mx[xans[i]],my[yans[i]],1,val[i]);\n\t\n\tmemset(morex,0x3f,sizeof morex);memset(morey,0x3f,sizeof morey);\n\tmemset(lessx,0,sizeof lessx);memset(lessy,0,sizeof lessy);\n\t\n\tfor(ll i=1;i<=m;i++)\n\t{\n\t\tll x=xx[i],k=kk[i];\n\t\tif(str[i][0]=='R')\n\t\t{\n\t\t\tk++;\n\t\t\tll tx=*sx.lower_bound(x);\n\t\t\tif(k<=xn)morex[k]=min(morex[k],mx[tx]-1);\n\t\t}\n\t\telse if(str[i][0]=='U')\n\t\t{\n\t\t\tk++;k+=xn;\n\t\t\tll ty=*sy.lower_bound(x);\n\t\t\tif(k<=yn)morey[k]=min(morey[k],my[ty]-1);\n\t\t}\n\t\telse if(str[i][0]=='L')\n\t\t{\n\t\t\tk=guess-k;\n\t\t\tll tx=*sx.upper_bound(x);\n\t\t\tif(k>=1)lessx[k]=max(lessx[k],mx[tx]);\n\t\t}\n\t\telse if(str[i][0]=='D')\n\t\t{\n\t\t\tk=guess-k+xn;\n\t\t\tll ty=*sy.upper_bound(x);\n\t\t\tif(k>=xn+1)lessy[k]=max(lessy[k],my[ty]);\n\t\t}\n\t}\n\t\n\t\t\n\tfor(ll i=2;i<=xn;i++) morex[i]=min(morex[i-1],morex[i]);\n\tfor(ll i=xn;i>=2;i--) lessx[i-1]=max(lessx[i-1],lessx[i]); \n\tfor(ll i=xn+2;i<=yn;i++) morey[i]=min(morey[i-1],morey[i]);\n\tfor(ll i=yn;i>=xn+2;i--) lessy[i-1]=max(lessy[i-1],lessy[i]);\n\t\n\tfor(ll i=1;i<=xn;i++)\n\t{\n\t\t++tot;ene::link(s,tot,1,0);\n\t\tfor(ll j=1;j<=xn;j++)\n\t\t\tif(j>=lessx[i] and j<=morex[i])\n\t\t\t\tene::link(tot,j,1,0);\n\t}\n\tfor(ll i=xn+1;i<=yn;i++)\n\t{\n\t\t++tot;ene::link(tot,t,1,0);\n\t\tfor(ll j=xn+1;j<=yn;j++)\n\t\t\tif(j>=lessy[i] and j<=morey[i])\n\t\t\t\tene::link(j,tot,1,0);\n\t}\n\t\n\toutput=max(output,ene::solve(s,t,guess));\n}\n\nsigned main()\n{\n\tscanf(\"%lld\",&n);for(ll i=1;i<=n;i++) scanf(\"%lld%lld%lld\",&xans[i],&yans[i],&val[i]);\n\tscanf(\"%lld\",&m);for(ll i=1;i<=m;i++) scanf(\"%s%lld%lld\",str[i],&xx[i],&kk[i]);\n\t\n\tfor(ll i=1;i<=n;i++) solve(i);\n\t\n\tcout<<output<<\"\\n\";\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nnamespace mcmf {\nstruct Edge {\n  int to, cap;\n  ll cost;\n  int rev;\n};\nvector<vector<Edge> > adj;\nvoid clear(int S, int T) {\n  adj.clear();\n  adj.resize(T + 1);\n}\nvoid add(int u, int v, int cap, ll cost) {\n  adj[u].push_back({v, cap, cost, adj[v].size()});\n  adj[v].push_back({u, 0, -cost, adj[u].size() - 1});\n}\nll solve(int S, int T) {\n  ll ans = 0;\n  while (true) {\n    vector<pair<int, int> > from(T + 1);\n    vector<ll> dist(T + 1, LLONG_MAX);\n    vector<bool> in_que(T + 1);\n    queue<int> que;\n    que.push(S);\n    dist[S] = 0;\n    in_que[S] = true;\n    while (!que.empty()) {\n      int u = que.front();\n      que.pop();\n      for (int i = 0; i < adj[u].size(); i++) {\n        auto e = adj[u][i];\n        if (e.cap && dist[e.to] > dist[u] + e.cost) {\n          dist[e.to] = dist[u] + e.cost;\n          from[e.to] = {u, i};\n          if (!in_que[e.to]) {\n            in_que[e.to] = true;\n            que.push(e.to);\n          }\n        }\n      }\n      in_que[u] = false;\n    }\n    if (dist[T] >= LLONG_MAX) {\n      return ans;\n    }\n    int cap = INT_MAX;\n    for (int u = T; u != S; u = from[u].first) {\n      cap = min(cap, adj[from[u].first][from[u].second].cap);\n    }\n    ans += cap * dist[T];\n    for (int u = T; u != S; u = from[u].first) {\n      auto &e = adj[from[u].first][from[u].second];\n      e.cap -= cap;\n      adj[u][e.rev].cap += cap;\n    }\n  }\n}\n}\nconst int LIMIT = 100;\nint main() {\n  do {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n  } while (false);\n  int n;\n  cin >> n;\n  vector<int> x(n), y(n);\n  vector<ll> w(n);\n  for (int i = 0; i < n; i++) {\n    cin >> x[i] >> y[i] >> w[i];\n  }\n  int m;\n  cin >> m;\n  vector<char> dir(m);\n  vector<int> a(m), b(m);\n  for (int i = 0; i < m; i++) {\n    cin >> dir[i] >> a[i] >> b[i];\n  }\n  ll ans = 0;\n  for (int k = 1; k <= n; k++) {\n    vector<int> xl(k + 1), yl(k + 1), xr(k + 1, LIMIT), yr(k + 1, LIMIT);\n    for (int i = 0; i < m; i++) {\n      if (b[i] < k) {\n        if (dir[i] == 'L') {\n          xl[b[i] + 1] = max(xl[b[i] + 1], a[i] + 1);\n        } else if (dir[i] == 'R') {\n          xr[k - b[i]] = min(xr[k - b[i]], a[i] - 1);\n        } else if (dir[i] == 'U') {\n          yr[k - b[i]] = min(yr[k - b[i]], a[i] - 1);\n        } else if (dir[i] == 'D') {\n          yl[b[i] + 1] = max(yl[b[i] + 1], a[i] + 1);\n        }\n      }\n    }\n    for (int i = 2; i <= k; i++) {\n      xl[i] = max(xl[i - 1], xl[i]);\n      yl[i] = max(yl[i - 1], yl[i]);\n    }\n    for (int i = k - 1; i; i--) {\n      xr[i] = min(xr[i], xr[i + 1]);\n      yr[i] = min(yr[i], yr[i + 1]);\n    }\n    mcmf::clear(0, k * 2 + LIMIT * 2 + 1);\n    for (int i = 1; i <= k; i++) {\n      mcmf::add(0, i, 1, 0);\n      for (int j = xl[i]; j <= xr[i]; j++) {\n        mcmf::add(i, k * 2 + j, 1, 0);\n      }\n      for (int j = yl[i]; j <= yr[i]; j++) {\n        mcmf::add(k * 2 + LIMIT + j, k + i, 1, 0);\n      }\n      mcmf::add(k + i, k * 2 + LIMIT * 2 + 1, 1, 0);\n    }\n    for (int i = 0; i < n; i++) {\n      mcmf::add(k * 2 + x[i], k * 2 + LIMIT + y[i], 1, -w[i]);\n    }\n    ans = max(ans, -mcmf::solve(0, k * 2 + LIMIT * 2 + 1));\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ref(i,x,y)for(int i=x;i<=y;++i)\n#define def(i,x,y)for(int i=x;i>=y;--i)\n#define fi first\n#define se second\n#define int long long\n#define pb push_back\ntypedef long long LL;\nconst int N=421;\nint n,m;\nint lx[2][N],ly[2][N];\nstruct dot{int x,y,v,id;}p[N],px[N],py[N];\nbool cmpx(dot a,dot b){return a.x<b.x;}\nbool cmpy(dot a,dot b){return a.y<b.y;}\nvoid smin(int&a,int b){if(b<a)a=b;}\nvoid smax(int&a,int b){if(b>a)a=b;}\nnamespace eden{\n\tint w[N][N],c[N][N],op,ed;\n\tvoid init(){\n\t\tmemset(w,0,sizeof w);\n\t\tmemset(c,0,sizeof c);\n\t}\n\tvoid add(int x,int y,int ww,int cc){\n\t\tw[x][y]=ww;w[y][x]=0;\n\t\tc[x][y]=cc;c[y][x]=-cc;\n\t}\n\tqueue<int> q;bool vis[N];int dis[N],pre[N];\n\tbool spfa(){\n\t\tmemset(vis,0,sizeof vis);\n\t\tmemset(pre,0,sizeof pre);\n\t\twhile(!q.empty())q.pop();\n\t\tref(i,1,ed)dis[i]=(LL)1e18;\n\t\tdis[op]=0;q.push(op);vis[op]=1;\n\t\twhile(!q.empty()){\n\t\t\tint u=q.front();q.pop();vis[u]=0;\n\t\t\tref(v,1,ed)if(w[u][v]&&dis[u]+c[u][v]<dis[v]){\n\t\t\t\tdis[v]=dis[u]+c[u][v];pre[v]=u;\n\t\t\t\tif(!vis[v])vis[v]=1,q.push(v);\n\t\t\t}\n\t\t}\n\t\treturn (dis[ed]<(LL)1e18);\n\t}\n\tpair<int,int> run(){\n\t\tint fw=0,res=0;\n\t\twhile(spfa()){\n\t\t\tfw++;res+=dis[ed];\n\t\t\tfor(int i=ed;i!=op;i=pre[i])\n\t\t\t\tw[pre[i]][i]--,w[i][pre[i]]++;\n\t\t}\n\t\treturn make_pair(fw,res);\n\t}\n}\nsigned main(){\n\tcin>>n;\n\tref(i,1,n)cin>>p[i].x>>p[i].y>>p[i].v;\n\tref(i,1,n)p[i].id=i;\n\tref(i,1,n)px[i]=p[i];\n\tref(i,1,n)py[i]=p[i];\n\tsort(px+1,px+n+1,cmpx);\n\tsort(py+1,py+n+1,cmpy);\n\tcin>>m;\n\tref(i,1,n)lx[0][i]=ly[0][i]=n+1;\n\tref(i,1,n)lx[1][i]=ly[1][i]=0;\n\tref(i,1,m){\n\t\tchar c;int a,b;cin>>c>>a>>b;\n\t\tif(c=='L'){\n\t\t\tint pos=0;\n\t\t\tref(j,1,n)if(px[j].x<=a)pos=j;\n\t\t\tif(pos>b)smin(lx[0][pos-b],pos);\n\t\t}\n\t\tif(c=='R'){\n\t\t\tint pos=n+1;\n\t\t\tdef(j,n,1)if(px[j].x>=a)pos=j;\n\t\t\tif(n+1-pos>b)smax(lx[1][n+1-pos-b],pos);\n\t\t}\n\t\tif(c=='D'){\n\t\t\tint pos=0;\n\t\t\tref(j,1,n)if(py[j].y<=a)pos=j;\n\t\t\tif(pos>b)smin(ly[0][pos-b],pos);\n\t\t}\n\t\tif(c=='U'){\n\t\t\tint pos=n+1;\n\t\t\tdef(j,n,1)if(py[j].y>=a)pos=j;\n\t\t\tif(n+1-pos>b)smax(ly[1][n+1-pos-b],pos);\n\t\t}\n\t}\n\tdef(i,n-1,1)smin(lx[0][i],lx[0][i+1]);\n\tdef(i,n-1,1)smin(ly[0][i],ly[0][i+1]);\n\tdef(i,n-1,1)smax(lx[1][i],lx[1][i+1]);\n\tdef(i,n-1,1)smax(ly[1][i],ly[1][i+1]);\n\tint ans=0,sum=0;\n\tref(i,1,n)ans+=p[i].v,sum+=p[i].v;\n\tref(S,0,n){\n\t\tif(S<n){\n\t\t\tif(lx[0][S+1]<=n||ly[0][S+1]<=n)continue;\n\t\t\tif(lx[1][S+1]>=1||ly[1][S+1]>=1)continue;\n\t\t}\n\t\tbool fg=1;\n\t\tref(i,1,S)if(lx[1][S+1-i]>lx[0][i]){fg=0;break;}\n\t\tref(i,1,S)if(ly[1][S+1-i]>ly[0][i]){fg=0;break;}\n\t\tif(!fg)continue;\n\t\teden::init();\n\t\teden::op=n+n+n+n+1;eden::ed=eden::op+1;\n\t\tref(i,1,S)ref(j,max(1LL,lx[1][S+1-i]),min(n,lx[0][i]))\n\t\t\teden::add(i,n+px[j].id,1,0);\n\t\tref(i,1,n)eden::add(n+i,n+n+i,1,p[i].v);\n\t\tref(i,1,S)ref(j,max(1LL,ly[1][S+1-i]),min(n,ly[0][i]))\n\t\t\teden::add(n+n+py[j].id,n+n+n+i,1,0);\n\t\tref(i,1,S)eden::add(eden::op,i,1,0);\n\t\tref(i,1,S)eden::add(n+n+n+i,eden::ed,1,0);\n\t\tpair<int,int> pp=eden::run();\n\t\tif(pp.fi==S)ans=min(ans,pp.se);\n\t}\n\tcout<<sum-ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#define foreach(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\n#ifndef LOCAL\n#define cerr if(0)cout\n#endif\ntypedef long long ll;\nconst int mod = 1e9+7;\n//My i/o stream\nstruct fastio\n{\n\tchar s[100000];\n\tint it, len;\n\tfastio() {it=len=0;}\n\tinline char get()\n\t{\n\t\tif (it<len) return s[it++]; it=0;\n\t\tlen=fread(s, 1, 100000, stdin);\n\t\tif (len==0) return EOF; else return s[it++];\n\t}\n\tbool notend()\n\t{\n\t\tchar c=get();\n\t\twhile (c==' '||c=='\\n') c=get();\n\t\tif (it>0) it--;\n\t\treturn c!=EOF;\n\t}\n}_buff;\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putchar(' ')\n#define putii(x,y) puti(x),puti(y)\n#define putiii(x,y,z) putii(x,y),puti(z)\n#define putsi(x) putnum(x),putchar('\\n')\n#define putsii(x,y) puti(x),putsi(y)\n#define putsiii(x,y,z) putii(x,y),putsi(z)\ninline ll getnum()\n{\n\tll r=0; bool ng=0; char c; c=_buff.get();\n\twhile (c!='-'&&(c<'0'||c>'9')) c=_buff.get();\n\tif (c=='-') ng=1, c=_buff.get();\n\twhile (c>='0'&&c<='9') r=r*10+c-'0', c=_buff.get();\n\treturn ng?-r:r;\n}\ntemplate <class T> inline void putnum(T x)\n{\n\tif (x<0) putchar('-'), x=-x;\n\tregister short a[20]={}, sz=0;\n\twhile (x) a[sz++]=x%10, x/=10;\n\tif(sz==0) putchar('0');\n\tfor (int i=sz-1; i>=0; i--) putchar('0'+a[i]);\n}\ninline char getreal() {char c=_buff.get(); while (c<=32) c=_buff.get(); return c;}\nll qpow(ll x, ll k) {return k==0? 1: 1ll*qpow(1ll*x*x%mod,k>>1)*(k&1?x:1)%mod;}\nconst ll inf = 4e18;\nnamespace F\n{\n\tconst int maxn = 1011, maxe = 100011;\n\tint head[maxn], nxt[maxe], to[maxe], cap[maxe];\n\tll cost[maxe], tot;\n\tll ftot;\n\tvoid init()\n\t{\n\t\tftot = 0;\n\t\ttot = 1;\n\t\tmemset(head, 0, sizeof(head));\n\t}\n\tvoid add_edge(int x, int y, int c, ll w)\n\t{\n\t\tassert(x<maxn&&y<maxn);\n//\t\tcerr<<\"add_edge:\"<<x<<\",\"<<y<<\" \"<<c<<\" \"<<w<<endl;\n\t\tnxt[++tot] = head[x];\n\t\thead[x] = tot;\n\t\tto[tot] = y;\n\t\tcap[tot] = c;\n\t\tcost[tot] = w;\n\t\tswap(x, y);\n\t\tnxt[++tot] = head[x];\n\t\thead[x] = tot;\n\t\tto[tot] = y;\n\t\tcap[tot] = 0;\n\t\tcost[tot] = -w;\n\t\tassert(tot<maxe);\n\t}\n\tint q[maxn], qb, qe;\n\tll dis[maxn];\n\tbool inq[maxn];\n\tint qnxt(int x) {return (x+1)%maxn;}\n\tint qpre(int x) {return (x-1+maxn)%maxn;}\n\tvoid balance()\n\t{\n\t\tif (qb!=qe&&dis[q[qpre(qe)]]<dis[q[qb]])\n\t\t{\n\t\t\tswap(q[qpre(qe)], q[qb]);\n\t\t}\n\t}\n\tvoid spfa(int S, int N)\n\t{\n\t\tinq[S] = 1;\n\t\tfor (int i=0; i<=N; i++) dis[i] = inf;\n\t\tdis[S] = 0;\n\t\tqb = qe = 0;\n\t\tq[qe++] = S;\n\t\twhile (qb<qe)\n\t\t{\n\t\t\tint x = q[qb];\n\t\t\tinq[x] = 0;\n\t\t\tqb = qnxt(qb);\n\t\t\tbalance();\n\t\t\tfor (int i = head[x]; i; i=nxt[i])\n\t\t\t{\n\t\t\t\tif (cap[i]&&dis[to[i]]>dis[x]+cost[i])\n\t\t\t\t{\n\t\t\t\t\tdis[to[i]] = dis[x]+cost[i];\n\t\t\t\t\tif (!inq[to[i]])\n\t\t\t\t\t{\n\t\t\t\t\t\tinq[to[i]] = 1;\n\t\t\t\t\t\tq[qe] = to[i];\n\t\t\t\t\t\tqe = qnxt(qe);\n\t\t\t\t\t\tbalance();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tfor (int i=1; i<=N; i++) cerr<<dis[i]<<\" \"; cerr<<endl;\n\t}\n\t\n\tbool vis[maxn];\n\tint dfs(int x, int T, int f)\n\t{\n\t\tif (x==T) return f;\n\t\tvis[x] = 1;\n\t\tint of = f;\n\t\tfor (int i=head[x]; i; i=nxt[i])\n\t\t{\n\t\t\tif (!vis[to[i]]&&cap[i]&&dis[to[i]]==dis[x]+cost[i])\n\t\t\t{\n\t\t\t\tint u = to[i];\n\t\t\t\tint d = dfs(u, T, min(f, cap[i]));\n\t\t\t\tcap[i] -= d;\n\t\t\t\tcap[i^1] += d;\n\t\t\t\tf -= d;\n\t\t\t\tif (!f) return of;\n\t\t\t}\n\t\t}\n\t\treturn of-f;\n\t}\n\tll min_cost_max_flow(int S, int T, int K)\n\t{\n\t\tll ans = 0;\n\t\twhile (true)\n\t\t{\n\t\t\tspfa(S, T);\n\t\t\tif (dis[T]>=inf) return ans;\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\tmemset(vis, 0, sizeof(vis));\n\t\t\t\tint f = dfs(S, T, K);\n\t\t\t\tftot += f;\n\t\t\t\tans += 1ll*f*dis[T];\n\t\t\t\tif (f==0) break;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n};\nint n;\nint tid[256];\npair<int,int> a[88];\nll w[88];\nvector<pair<int,int> > M[4];\npair<int,int> segx[88], segy[88];\nll solve(int K)\n{\n//\tcerr<<\"solve: \"<<K<<endl;\n\tfor (int i=1; i<=K; i++) segx[i] = segy[i] = MP(0, 100);\n\tfor (auto x : M[0])\n\t{\n\t\tfor (int i=x.SS+1; i<=K; i++)\n\t\t{\n\t\t\tsegx[i].FF = max(segx[i].FF, x.FF+1);\n\t\t}\n\t}\n\tfor (auto x : M[1])\n\t{\n\t\tfor (int i=K-x.SS; i>=1; i--)\n\t\t{\n\t\t\tsegx[i].SS = min(segx[i].SS, x.FF-1);\n\t\t}\n\t}\n\tfor (auto x : M[2])\n\t{\n\t\tfor (int i=x.SS+1; i<=K; i++)\n\t\t{\n\t\t\tsegy[i].FF = max(segy[i].FF, x.FF+1);\n\t\t}\n\t}\n\tfor (auto x : M[3])\n\t{\n\t\tfor (int i=K-x.SS; i>=1; i--)\n\t\t{\n\t\t\tsegy[i].SS = min(segy[i].SS, x.FF-1);\n\t\t}\n\t}\n\tint S = 2*K+2*n+1, T = S+1;\n\tF::init();\n\tfor (int i=1; i<=K; i++)\n\t{\n\t\tF::add_edge(S, i, 1, 0);\n\t\tF::add_edge(i+K, T, 1, 0);\n\t\tfor (int j=1; j<=n; j++)\n\t\t{\n\t\t\tif (segx[i].FF<=a[j].FF&&a[j].FF<=segx[i].SS)\n\t\t\t{\n\t\t\t\tF::add_edge(i, j+2*K, 1, 0);\n\t\t\t}\n\t\t\tif (segy[i].FF<=a[j].SS&&a[j].SS<=segy[i].SS)\n\t\t\t{\n\t\t\t\tF::add_edge(j+2*K+n, i+K, 1, 0);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1; i<=n; i++) F::add_edge(i+2*K, i+2*K+n, 1, -w[i]);\n\tll ans = F::min_cost_max_flow(S, T, K);\n//\tcerr<<\"F::ftot=\"<<F::ftot<<endl;\n\tassert(F::ftot>=0&&F::ftot<=K);\n\tif (F::ftot<K) return 0;\n//\tcerr<<\"ans=\"<<ans<<endl;\n\treturn -ans;\n}\nint main()\n{\n\ttid['L'] = 0;\n\ttid['R'] = 1;\n\ttid['D'] = 2;\n\ttid['U'] = 3;\n\tgeti(n);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tll x, y, v;\n\t\tgetiii(x, y, v);\n\t\ta[i] = MP(x, y);\n\t\tw[i] = v;\n\t}\n\tint m;\n\tgeti(m);\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\tchar t;\n\t\tint a, b;\n\t\tt = getreal();\n\t\tgetii(a, b);\n\t\tM[tid[t]].PB(MP(a, b));\n\t}\n\tll ans = 0;\n\tfor (int K=1; K<=n; K++)\n\t{\n\t\tans = max(ans, solve(K));\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef xay5421\n#define D(...) fprintf(stderr,__VA_ARGS__)\n#else\n#define D(...) ((void)0)\n#define NDEBUG\n#endif\n#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\nusing namespace std;\ntypedef long long LL;\ntemplate<typename T>void umax(T&x,const T&y){if(x<y)x=y;}\ntemplate<typename T>void umin(T&x,const T&y){if(x>y)x=y;}\nconst int N=1005,M=1000005,INF=0X3F3F3F3F;\nconst LL INFLL=0X3F3F3F3F3F3F3F3FLL;\nint n,m,K,S,T,x[N],y[N],lb[2][N],rb[2][N],pre[N];LL v[N];\nLL ans,dis[N];\nbool vis[N];\nstruct data{\n\tchar c;\n\tint a,b;\n}A[N];\nint pp,lnk[N],nxt[M],to[M],we[M];LL co[M];\nvoid ae(int k1,int k2,int k3,LL k4){\n\tD(\"%d %d %d %lld\\n\",k1,k2,k3,k4);\n\tto[++pp]=k2,we[pp]=k3,co[pp]=k4,nxt[pp]=lnk[k1],lnk[k1]=pp;\n\tto[++pp]=k1,we[pp]=0,co[pp]=-k4,nxt[pp]=lnk[k2],lnk[k2]=pp;\n}\nqueue<int>q;\nbool spfa(){\n\trep(i,1,T)dis[i]=-INFLL,pre[i]=0;\n\tdis[S]=0;\n\twhile(!q.empty())q.pop();\n\tq.push(S),vis[S]=1;\n\twhile(!q.empty()){\n\t\tint k1=q.front();\n\t\tvis[k1]=0;\n\t\tq.pop();\n\t\tfor(int i=lnk[k1];i;i=nxt[i])if(we[i]&&dis[k1]+co[i]>dis[to[i]]){\n\t\t\tdis[to[i]]=dis[k1]+co[i];\n\t\t\tpre[to[i]]=i;\n\t\t\tif(!vis[to[i]])q.push(to[i]),vis[to[i]]=1;\n\t\t}\n\t}\n\treturn dis[T]>=0;\n}\nLL mcmf(int K){\n\tLL mc=0,mf=0;\n\twhile(spfa()){\n\t\tint flow=INF;\n\t\tfor(int i=pre[T];i;i=pre[to[i^1]])flow=min(flow,we[i]);\n\t\tfor(int i=pre[T];i;i=pre[to[i^1]])we[i]-=flow,we[i^1]+=flow;\n\t\tmf+=flow;\n\t\tmc+=1LL*dis[T]*flow;\n\t}\n\tif(mf==K)return mc;\n\treturn D(\"bad %d\\n\",K),0;\n}\nint main(){\n\tcin>>n;\n\trep(i,1,n)cin>>x[i]>>y[i]>>v[i];\n\tcin>>m;\n\trep(i,1,m)cin>>A[i].c>>A[i].a>>A[i].b;\n\tS=n*4+1,T=n*4+2;\n\tfor(K=1;K<=n;++K){\n\t\trep(i,1,K)lb[0][i]=lb[1][i]=0,rb[0][i]=rb[1][i]=INF;\n\t\trep(i,1,m){\n\t\t\tif(A[i].c=='L'){\n\t\t\t\trep(j,A[i].b+1,K)umax(lb[0][j],A[i].a+1);\n\t\t\t}else if(A[i].c=='R'){\n\t\t\t\trep(j,1,K-A[i].b)umin(rb[0][j],A[i].a-1);\n\t\t\t}else if(A[i].c=='U'){\n\t\t\t\trep(j,1,K-A[i].b)umin(rb[1][j],A[i].a-1);\n\t\t\t}else{\n\t\t\t\trep(j,A[i].b+1,K)umax(lb[1][j],A[i].a+1);\n\t\t\t}\n\t\t}\n\t\tpp=1;\n\t\trep(i,1,T)lnk[i]=0;\n\t\trep(i,1,K)ae(S,i,1,0);\n\t\trep(i,1,K){\n\t\t\trep(j,1,n)if(lb[0][i]<=x[j]&&x[j]<=rb[0][i])ae(i,K+j,1,0);\n\t\t}\n\t\trep(i,1,n){\n\t\t\tae(K+i,K+n+i,1,v[i]);\n\t\t}\n\t\trep(i,1,K){\n\t\t\trep(j,1,n)if(lb[1][i]<=y[j]&&y[j]<=rb[1][i])ae(K+n+j,K+n+n+i,1,0);\n\t\t}\n\t\trep(i,1,K){\n\t\t\tae(K+n+n+i,T,1,0);\n\t\t}\n\t\tans=max(ans,mcmf(K));\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1145141919810000\n#define ll long long\n#define mem(x,y) memset(x,y,sizeof x)\nusing namespace std;\nstruct edge{\n\tint t,next;\n\tll cst;\n\tint rev;\n};\nvector<edge>G[110000];\nvoid add(int f,int t,int next,ll cst){\n\tG[f].push_back((edge){t,next,cst,(int)G[t].size()});\n\tG[t].push_back((edge){f,0,-cst,(int)G[f].size()-1});\n}\nbool used[110000];\nll dis[110000];\nint prv[110000],pre[110000],S,T;\nbool SPFA(){\n\tfor(int i=0;i<=T;i++)dis[i]=-inf;\n\tqueue<int>q;\n\tq.push(0);\n\tdis[0]=0;\n\tused[0]=true;\n\twhile(!q.empty()){\n\t\tint x=q.front();\n\t\tq.pop();\n\t\tused[x]=false;\n\t\tfor(int i=0;i<(int)G[x].size();i++){\n\t\t\tedge &e=G[x][i];\n\t\t\tif(e.next && dis[x]+e.cst>dis[e.t]){\n\t\t\t\tdis[e.t]=dis[x]+e.cst;\n\t\t\t\tprv[e.t]=x;\n\t\t\t\tpre[e.t]=i;\n\t\t\t\tif(!used[e.t]) used[e.t]=1,q.push(e.t);\n\t\t\t}\n\t\t}\n\t}\n\treturn (dis[T]!=-inf);\n}\nint n,m,lx[210],rx[210],ly[210],ry[210],x[210],y[210];\nll v[210],ans;\nll MCMF(){\n\tll nowans=0;\n\twhile(SPFA()){\n\t\tint nowp=T;\n\t\twhile(nowp){\n\t\t\tedge &e=G[prv[nowp]][pre[nowp]];\n\t\t\te.next--;\n\t\t\tG[e.t][e.rev].next++;\n\t\t\tnowp=prv[nowp];\n\t\t}\n\t\tnowans+=dis[T];\n\t}\n\treturn nowans;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d%d%lld\",&x[i],&y[i],&v[i]);\n\tscanf(\"%d\",&m);\n\tfor(int i=1;i<=n;i++) rx[i]=ry[i]=110;\n\tfor(int i=1;i<=m;i++){\n\t\tint a,b;char cc;\n\t\tscanf(\"%s%d%d\",&cc,&a,&b);\n\t\tif(cc=='L')lx[b+1]=max(lx[b+1],a);\n\t\tif(cc=='R')rx[b+1]=min(rx[b+1],a);\n\t\tif(cc=='D')ly[b+1]=max(ly[b+1],a);\n\t\tif(cc=='U')ry[b+1]=min(ry[b+1],a);\n\t}\n\tfor(int i=2;i<=n;i++) lx[i]=max(lx[i],lx[i-1]),rx[i]=min(rx[i],rx[i-1]),ly[i]=max(ly[i],ly[i-1]),ry[i]=min(ry[i],ry[i-1]);\n\tfor(int i=1;i<=n;i++){\n\t\tT=n+n+i+i+1;mem(G,0);\n\t\tfor(int j=1;j<=i;j++) add(0,n+n+j,1,0),add(n+n+i+j,T,1,0);\n\t\tfor(int j=1;j<=i;j++){\n\t\t\tfor(int k=1;k<=n;k++){\n\t\t\t\tif(lx[j]<x[k]&&x[k]<rx[i+1-j]) add(n+n+j,k,1,0);\n\t\t\t\tif(ly[j]<y[k]&&y[k]<ry[i+1-j]) add(n+k,n+n+i+j,1,0);\n\t\t\t}\n\t\t}\n\t\tfor(int j=1;j<=n;j++) add(j,n+j,1,v[j]);\n\t\tans=max(ans,MCMF());\n\t}\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <list>\n#include <time.h>\n#include <math.h>\n#include <random>\n#include <deque>\n#include <queue>\n#include <cassert>\n#include <unordered_map>\n#include <unordered_set>\n#include <iomanip>\n#include <bitset>\n#include <sstream>\n#include <chrono>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef long double dbl;\nconst int INF = 1.01e9;\n \nconst long double EPS = 1e-18;\nbool eq(long double x, long double y) {\n    return fabs(x - y) < EPS;\n}\nbool ls(long double x, long double y) {\n    return x < y && !eq(x, y);\n}\n \nvector<long double> simplex(vector<vector<long double> > a) {\n    int n = a.size() - 1;\n    int m = a[0].size() - 1;\n    vector<int> left(n + 1), up(m + 1);\n    iota(up.begin(), up.end(), 0);\n    iota(left.begin(), left.end(), m);\n    auto pivot = [&](int x, int y) {\n        swap(left[x], up[y]);\n        long double k = a[x][y];\n        a[x][y] = 1;\n        vector<int> vct;\n        for (int j = 0; j <= m; j++) {\n            a[x][j] /= k;\n            if (!eq(a[x][j], 0)) vct.push_back(j);\n        }\n        for (int i = 0; i <= n; i++) {\n            if (eq(a[i][y], 0) || i == x) continue;\n            k = a[i][y];\n            a[i][y] = 0;\n            for (int j : vct) a[i][j] -= k * a[x][j];\n        }\n    };\n    while (1) {\n        int x = -1;\n        for (int i = 1; i <= n; i++) if (ls(a[i][0], 0) && (x == -1 || a[i][0] < a[x][0])) x = i;\n        if (x == -1) break;\n        int y = -1;\n        for (int j = 1; j <= m; j++) if (ls(a[x][j], 0) && (y == -1 || a[x][j] < a[x][y])) y = j;\n        if (y == -1) assert(0); // infeasible\n        pivot(x, y);\n    }\n    while (1) {\n        int y = -1;\n        for (int j = 1; j <= m; j++) if (ls(0, a[0][j]) && (y == -1 || a[0][j] > a[0][y])) y = j;\n        if (y == -1) break;\n        int x = -1;\n        for (int i = 1; i <= n; i++) if (ls(0, a[i][y]) && (x == -1 || a[i][0] / a[i][y] < a[x][0] / a[x][y])) x = i;\n        if (x == -1) assert(0); // unbounded\n        pivot(x, y);\n    }\n    vector<long double> ans(m + 1);\n    for (int i = 1; i <= n; i++) if (left[i] <= m) ans[left[i]] = a[i][0];\n    ans[0] = -a[0][0];\n    return ans;\n}\n\n#ifdef ONPC\n  mt19937 rnd(228);\n#else\n  mt19937 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\n#endif\n\nint main()\n{\n#ifdef ONPC\n  freopen(\"a.in\", \"r\", stdin);\n#endif\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector <int> x(n), y(n);\n  vector <ll> ok;\n  vector <long double> v;\n  vector <pair <ll, int> > e;\n  for (int i = 0; i < n; i++)\n  {\n    cin >> x[i] >> y[i];\n    ll x;\n    cin >> x;\n    ok.push_back(x);\n    v.push_back(x);\n    e.push_back({x, i});\n  }\n  v.insert(v.begin(), 0);\n  int m;\n  cin >> m;\n  vector <vector <long double> > mat;\n  mat.push_back(v);\n  for (int i = 0; i < n; i++)\n  {\n    vector <long double> kek(n + 1);\n    kek[0] = kek[i + 1] = 1;\n    mat.push_back(kek);\n  }\n  vector <vector <int> > simp;\n  for (int i = 0; i < m; i++)\n  {\n    char c;\n    cin >> c;\n    int a;\n    int b;\n    cin >> a >> b;\n    vector <long double> arr = {(long double) b};\n    vector <int> kek = {b};\n    for (int j = 0; j < n; j++)\n    {\n      int grab = 0;\n      if (c == 'L' && x[j] <= a) grab = 1;\n      if (c == 'R' && x[j] >= a) grab = 1;\n      if (c == 'D' && y[j] <= a) grab = 1;\n      if (c == 'U' && y[j] >= a) grab = 1;\n      arr.push_back(grab);\n      kek.push_back(grab);\n    }\n    mat.push_back(arr);\n    simp.push_back(kek);\n  }\n  auto good = [&] (vector <int> grab)\n  {\n    for (auto c : simp)\n    {\n      int sum = 0;\n      for (int i = 1; i <= n; i++) sum += grab[i - 1] * c[i];\n      if (sum > c[0])\n      {\n        return false;\n      }\n    }\n    return true;\n  };\n  auto f = [&] (vector <int> grab)\n  {\n    ll sum = 0;\n    for (int i = 0; i < n; i++)\n    {\n      if (grab[i]) sum += ok[i];\n    }\n    return sum;\n  };\n  vector <int> grab;\n  for (int i = 0; i < n; i++) grab.push_back(0);\n  cout.precision(20);\n  auto solve = [&] ()\n  {\n    auto ret = simplex(mat);\n    sort(e.begin(), e.end());\n    vector <int> me(n);\n    int x = -1;\n    for (int i = 1; i <= n; i++)\n    {\n      if (grab[i - 1]) continue;\n      if (x == -1 || ret[i] > ret[x])\n      {\n        x = i;\n      }\n    }\n    if (x == -1 || ret[x] < EPS) return 0ll;\n    x--;\n    me[x] = true;\n    grab[x] = true;\n    if (!good(grab)) grab[x] = false, me[x] = false;\n    int kekos = 0;\n    for (auto &c : mat)\n    {\n      kekos++;\n      if (kekos > n + 1)\n      for (int i = 1; i <= n; i++)\n      {\n        if (me[i - 1] && c[i] > EPS) c[i]--, c[0]--;\n      }\n    }\n    for (int i = 1; i <= n; i++)\n    {\n      if (me[i - 1])\n      {\n        mat[i][0] = 0;\n      }\n    }\n    return ok[x];\n  };\n  ll ans = 0;\n  while (ll t = solve())\n  {\n    ans += t;\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\n  _|_|                              _|  _|    _|\n_|    _|  _|  _|_|  _|_|_|_|        _|  _|  _|\n_|    _|  _|_|          _|          _|  _|_|\n_|    _|  _|          _|      _|    _|  _|  _|\n  _|_|    _|        _|_|_|_|    _|_|    _|    _|\n\n*/\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<set>\n//#define ls (rt<<1)\n//#define rs (rt<<1|1)\n#define vi vector<int>\n#define pb push_back\n#define mk make_pair\n#define pii pair<ll,ll>\n#define rep(i,a,b) for(int i=(a),i##end=(b);i<=i##end;i++)\n#define fi first\n#define se second\n#define int long long\ntypedef long long ll;\nusing namespace std;\nconst int maxn=420;\nconst int inf=1e18+100;\nint xl[maxn],xr[maxn],yl[maxn],yr[maxn],s=415,t=416;\nint head[maxn],cnt=1;\nstruct gg{\n    int u,v,w;ll cost;int next;\n    void insert(int U,int V,int W,ll Cost,int Next){\n        u=U,v=V,w=W,cost=Cost,next=Next;\n    }\n}side[(maxn*maxn)*2];\nstruct Point{\n    int x,y;\n    ll cost=0;\n}point[maxn];\nstruct Lim{\n    int a,b;char c;\n}lim[maxn];\nvoid ins(int u,int v,int w,ll cost){\n    side[++cnt].insert(u,v,w,cost,head[u]);head[u]=cnt;\n    side[++cnt].insert(v,u,0,-cost,head[v]);head[v]=cnt;\n}\nint n,m;\nvoid init(int k){\n    rep(i,1,k)xl[i]=yl[i]=-inf,xr[i]=yr[i]=inf;\n    rep(i,1,m){\n        if(lim[i].c=='L')rep(j,lim[i].b+1,k)xl[j]=max(xl[j],lim[i].a+1);\n        else if(lim[i].c=='R')for(int j=k-lim[i].b;j>0;j--)xr[j]=min(xr[j],lim[i].a-1);\n        else if(lim[i].c=='D')rep(j,lim[i].b+1,k)yl[j]=max(yl[j],lim[i].a+1);\n        else if(lim[i].c=='U')for(int j=k-lim[i].b;j>0;j--)yr[j]=min(yr[j],lim[i].a-1);\n    }\n    memset(head,0,sizeof(head));cnt=1;\n    rep(i,1,k)ins(s,2*n+i,1,0);\n    rep(i,1,k)ins(2*n+k+i,t,1,0);\n    rep(i,1,n){\n        ins(i,n+i,1,point[i].cost);\n        rep(j,1,k){\n            if(xl[j]<=point[i].x&&point[i].x<=xr[j])ins(2*n+j,i,1,0);\n            if(yl[j]<=point[i].y&&point[i].y<=yr[j])ins(n+i,2*n+k+j,1,0);\n        }\n    }\n}\nint q[maxn*30];\nll dis[maxn],lenth;\nbool vis[maxn];\nbool spfa(){\n    rep(i,1,maxn-1)dis[i]=-inf;\n    memset(vis,0,sizeof(vis));\n    int hd=1,tl=1;q[hd]=s;vis[s]=1;dis[s]=0;\n    while(hd<=tl){\n        int u=q[hd++];vis[u]=0;//cout<<u<<' '<<endl;\n        for(int i=head[u];i;i=side[i].next){\n            int v=side[i].v;if(!side[i].w)continue;\n            if(dis[u]+side[i].cost>dis[v]){\n                dis[v]=dis[u]+side[i].cost;\n                if(!vis[v])q[++tl]=v;\n                vis[v]=1;\n            }\n        }\n    }\n    if(dis[t]!=-inf)return 1;\n    return 0;\n}\nint dfs(int u,int flow){\n    if(u==t)return flow;\n    vis[u]=1;int tot=0;\n    for(int i=head[u];i;i=side[i].next){\n        int v=side[i].v;if(vis[v]||!side[i].w||dis[v]!=dis[u]+side[i].cost)continue;\n        int sent=dfs(v,min(flow,side[i].w));\n        lenth+=1ll*side[i].cost*sent,side[i].w-=sent,side[i^1].w+=sent,tot+=sent;flow-=sent;\n    }\n    // vis[u]=0;\n    return tot;\n}\npii dinic(){\n    int mxflow=0;lenth=0;\n    while(spfa()){\n        int x;\n        while((x=dfs(s,inf)))mxflow+=x;\n    }\n    return mk(mxflow,lenth);\n}\nchar tmp[3];\nsigned main(){\n    scanf(\"%lld\",&n);\n    rep(i,1,n)scanf(\"%lld%lld%lld\",&point[i].x,&point[i].y,&point[i].cost);\n    scanf(\"%lld\",&m);\n    rep(i,1,m){\n        scanf(\"%s%lld%lld\",tmp+1,&lim[i].a,&lim[i].b);lim[i].c=tmp[1];\n    }\n    ll out=0;\n    rep(k,1,n){\n        init(k);\n        pii ans=dinic();\n        if(ans.fi==k)out=max(out,ans.se);//cout<<ans.se<<endl;\n    }\n    cout<<out;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//problem:agc031_e\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mk make_pair\n#define lob lower_bound\n#define upb upper_bound\n#define fst first\n#define scd second\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ninline int read(){\n\tint f=1,x=0;char ch=getchar();\n\twhile(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}\n\twhile(isdigit(ch)){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\ninline ll readll(){\n\tll f=1,x=0;char ch=getchar();\n\twhile(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}\n\twhile(isdigit(ch)){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nint n,m,x[85],y[85],limxl[105],limxr[105],limyl[105],limyr[105],xL[85],xR[85],yL[85],yR[85];\nll val[85];\nconst ll INF=1e18;\nstruct EDGE{int nxt,to,w;ll c;}edge[6000000];\nint head[5005],tot,nodecnt;\ninline void add_edge(int u,int v,int w,ll c){\n\tedge[++tot].nxt=head[u],edge[tot].to=v,edge[tot].w=w,edge[tot].c=c,head[u]=tot;\n\tedge[++tot].nxt=head[v],edge[tot].to=u,edge[tot].w=0,edge[tot].c=-c,head[v]=tot;\n}\nint pre[5005];\nbool inq[5005];\nll dis[5005];\nbool spfa(int s,int t){\n\tfor(int i=1;i<=nodecnt;++i)inq[i]=0,dis[i]=-INF,pre[i]=0;\n\tqueue<int>q;q.push(s);dis[s]=0;\n\twhile(!q.empty()){\n\t\tint u=q.front();q.pop();inq[u]=0;\n\t\tfor(int i=head[u];i;i=edge[i].nxt){\n\t\t\tint v=edge[i].to;\n\t\t\tif(edge[i].w&&dis[v]<dis[u]+edge[i].c){\n\t\t\t\tdis[v]=dis[u]+edge[i].c;\n\t\t\t\tpre[v]=i;\n\t\t\t\tif(!inq[v]){\n\t\t\t\t\tinq[v]=1;\n\t\t\t\t\tq.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dis[t]!=-INF;\n}\nll solve(int num){\n\tfor(int i=1;i<=num;++i)xL[i]=yL[i]=1,xR[i]=yR[i]=100;\t\n\tfor(int i=1;i<=100;++i){\n\t\tif(limxl[i]<num)xL[limxl[i]+1]=max(xL[limxl[i]+1],i+1);\n\t\tif(limxr[i]<num)xR[num-limxr[i]]=min(xR[num-limxr[i]],i-1);\n\t\tif(limyl[i]<num)yL[limyl[i]+1]=max(yL[limyl[i]+1],i+1);\n\t\tif(limyr[i]<num)yR[num-limyr[i]]=min(yR[num-limyr[i]],i-1);\n\t}\n//\tcout<<\"--------- solveing \"<<num<<\" --------\"<<endl;\n\tfor(int i=num-1;i>=1;--i)xR[i]=min(xR[i],xR[i+1]),yR[i]=min(yR[i],yR[i+1]);\n\tfor(int i=2;i<=num;++i)xL[i]=max(xL[i],xL[i-1]),yL[i]=max(yL[i],yL[i-1]);\n//\tfor(int i=1;i<=num;++i){\n//\t\tcout<<i<<\" \"<<xL[i]<<\" \"<<xR[i]<<endl;\n//\t\tcout<<i<<\" \"<<yL[i]<<\" \"<<yR[i]<<endl;\n//\t}\n\tfor(int i=1;i<=num;++i)if(xL[i]>xR[i]||yL[i]>yR[i])return -1;\n\ttot=1;for(int i=1;i<=nodecnt;++i)head[i]=0;\n\tfor(int i=1;i<=n;++i)add_edge(i,n+i,1,val[i]);\n\tfor(int i=1;i<=num;++i){\n\t\tfor(int j=1;j<=n;++j){\n\t\t\tif(xL[i]<=x[j]&&xR[i]>=x[j])add_edge(n*2+i,j,1,0);\n\t\t\tif(yL[i]<=y[j]&&yR[i]>=y[j])add_edge(n+j,n*2+num+i,1,0);\n\t\t}\n\t}\n\tint s=n*2+num*2+1,t=s+1;nodecnt=t;\n\tfor(int i=1;i<=num;++i)add_edge(s,n*2+i,1,0),add_edge(n*2+num+i,t,1,0);\n\tll ans=0;\n\twhile(spfa(s,t)){\n\t\tint fl=1e9;\n\t\tfor(int i=pre[t];i;i=pre[edge[i^1].to]){\n\t\t\tfl=min(fl,edge[i].w);\n\t\t}\n\t\tfor(int i=pre[t];i;i=pre[edge[i^1].to]){\n\t\t\tans+=edge[i].c*fl;\n\t\t\tedge[i].w-=fl;\n\t\t\tedge[i^1].w+=fl;\n\t\t}\n\t}\n//\tcout<<\"** \"<<num<<\" \"<<ans<<endl;\n\treturn ans;\n}\nint main() {\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i)scanf(\"%d%d%lld\",x+i,y+i,val+i);\n\tfor(int i=1;i<=100;++i)limxl[i]=n,limxr[i]=n,limyl[i]=n,limyr[i]=n;\n\tscanf(\"%d\",&m);\n\tfor(int i=1;i<=m;++i){\n\t\tchar s[5];int a,b;scanf(\"%s%d%d\",s,&a,&b);\n\t\tif(s[0]=='L')limxl[a]=min(limxl[a],b);\n\t\telse if(s[0]=='R')limxr[a]=min(limxr[a],b);\n\t\telse if(s[0]=='D')limyl[a]=min(limyl[a],b);\n\t\telse if(s[0]=='U')limyr[a]=min(limyr[a],b);else assert(0);\n\t}\n\tll ans=0;\n\tfor(int i=1;i<=n;++i)ans=max(ans,solve(i));\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for((i)=1;(i)<=(n);(i)++) \nusing namespace std;\nint n,m,i,j,px[85],py[85],pv[85],qa[85],qb[85],ans,s,t,tot,cst;\nchar qt[85];\nint mix[85],miy[85],mxx[85],mxy[85];\nstruct edge{\n\tint y,z,d;\n}e[2000005];\nint vis[245],dis[245],iq[245]; \nvector<int> adj[245];\nvoid add(int x,int y,int z,int d){\n\t++tot;\n\tadj[x].push_back(tot*2-2);\n\tadj[y].push_back(tot*2-1);\n\te[tot*2-2]=(edge){y,z,d};\n\te[tot*2-1]=(edge){x,0,-d}; \n}\nbool bfs(int s,int t){\n\tmemset(dis,-0x3f,sizeof(dis));\n\tdis[s]=0;queue<int> q;q.push(s);\n\twhile(!q.empty()){\n\t\tint x=q.front();q.pop();iq[x]=0;\n\t\tfor(int i=0;i<adj[x].size();i++){\n\t\t\tint t=adj[x][i];\n\t\t\tif(e[t].z&&dis[e[t].y]<dis[x]+e[t].d){\n\t\t\t\tdis[e[t].y]=dis[x]+e[t].d;\n\t\t\t\tif(!iq[e[t].y]){q.push(e[t].y);iq[e[t].y]=1;}\n\t\t\t}\n\t\t}\n\t}\n\treturn dis[t]>dis[0];\n}\nint dfs(int x,int tt,int fw){\n\tif(!fw) return 0; \n\tif(x==tt) return vis[x]=1,fw;\n\tif(vis[x]) return 0;vis[x]=1;\n\tint res=0;\n\tfor(int i=0;i<adj[x].size();i++){\n\t\tint y=adj[x][i];\n\t\tif(e[y].z&&dis[e[y].y]==dis[x]+e[y].d){\n\t\t\tint t=dfs(e[y].y,tt,min(fw,e[y].z));\n\t\t\tfw-=t;res+=t;e[y].z-=t;e[y^1].z+=t;\n\t\t\tcst+=e[y].d*t;\n\t\t}\n\t}\n\treturn res;\n}\nint dinic(int s,int t){\n\tint ans=0;\n\twhile(bfs(s,t)){\n\t\tdo{\n\t\t\tmemset(vis,0,sizeof(vis));\n\t\t\tans+=dfs(s,t,0x3f3f3f3f);\n\t\t}while(vis[t]);\n\t}\n\treturn ans;\n}\nint calc(int k){\n\tint i,j;\n\trep(i,k){\n\t\tmix[i]=miy[i]=0;\n\t\tmxx[i]=mxy[i]=101;\n\t}\n\trep(i,m){\n\t\tif(qb[i]<k){\n\t\t\tif(qt[i]=='L') mix[qb[i]+1]=qa[i]+1;\n\t\t\tif(qt[i]=='R') mxx[k-qb[i]]=qa[i]-1; \n\t\t\tif(qt[i]=='D') mix[qb[i]+1]=qa[i]+1;\n\t\t\tif(qt[i]=='U') mxx[k-qb[i]]=qa[i]-1; \n\t\t}\n\t}\n\trep(i,3*n+2){\n\t\tadj[i].clear();\n\t}\n\ttot=0;\n\trep(i,k){\n\t\tadd(s,n+i,1,0);\n\t\tadd(n+n+i,t,1,0);\n\t}\n\trep(i,n){\n\t\trep(j,k){\n\t\t\tif(mix[j]<=px[i]&&px[i]<=mxx[j]){\n\t\t\t\tadd(n+j,i,1,pv[i]);\n\t\t\t}\n\t\t\tif(miy[j]<=py[i]&&py[i]<=mxy[j]){\n\t\t\t\tadd(i,n+n+j,1,0);\n\t\t\t}\n\t\t}\n\t}\n\tcst=0;\n\tif(dinic(s,t)!=k) return 0;\n\treturn cst;\n}\nint main(){\n\tcin>>n;s=3*n+1;t=3*n+2;\n\trep(i,n){\n\t\tcin>>px[i]>>py[i]>>pv[i];\n\t}\n\tcin>>m;\n\trep(i,m){\n\t\tcin>>qt[i]>>qa[i]>>qb[i];\n\t}\n\trep(i,n){\n\t\tans=max(ans,calc(i));\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int maxn = 320, maxm = 1e5;\nconst ll lim = 1e15, inf = 1e18;\nint n, x[maxn + 3], y[maxn + 3], m, a[maxn + 3], b[maxn + 3];\nint l[maxn + 3], r[maxn + 3], u[maxn + 3], d[maxn + 3];\nint tot, wei[maxm + 3], ter[maxm + 3], nxt[maxm + 3], lnk[maxn + 3];\nint src, snk, pre[maxn + 3];\nbool in[maxn + 3];\nll v[maxn + 3], len[maxm + 3], dist[maxm + 3];\nchar s[maxn + 3];\n\nint func(int x) {\n\treturn x & 1 ? x + 1 : x - 1;\n}\n\nvoid add(int u, int v, int w, ll l) {\n\tter[++tot] = v, wei[tot] = w, len[tot] = l;\n\tnxt[tot] = lnk[u], lnk[u] = tot;\n}\n\nvoid add_f(int u, int v, int w, ll l) {\n\tadd(u, v, w, l);\n\tadd(v, u, 0, -l);\n}\n\nbool spfa() {\n\tqueue<int> Q;\n\tQ.push(src), in[src] = true;\n\tfill(dist + 1, dist + snk + 1, inf);\n\tdist[src] = 0;\n\twhile (!Q.empty()) {\n\t\tint u = Q.front();\n\t\tQ.pop();\n\t\tin[u] = false;\n\t\tll l = 0;\n\t\tfor (int i = lnk[u], v; i; i = nxt[i]) {\n\t\t\tv = ter[i], l = len[i];\n\t\t\tif (wei[i] && dist[u] + l < dist[v]) {\n\t\t\t\tdist[v] = dist[u] + l;\n\t\t\t\tpre[v] = i;\n\t\t\t\tif (!in[v]) {\n\t\t\t\t\tin[v] = true;\n\t\t\t\t\tQ.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dist[snk] != inf;\n}\n\nvoid flow(int &res, ll &ans) {\n\twhile (spfa()) {\n\t\tint x = snk;\n\t\twhile (x != src) {\n\t\t\twei[pre[x]]--, wei[func(pre[x])]++;\n\t\t\tx = ter[func(pre[x])];\n\t\t}\n\t\tres++;\n\t\tans += dist[snk];\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%d %d %lld\", &x[i], &y[i], &v[i]);\n\t}\n\tscanf(\"%d\", &m);\n\tfor (int i = 1; i <= m; i++) {\n\t\tchar t[5];\n\t\tscanf(\"%s %d %d\", t + 1, &a[i], &b[i]);\n\t\ts[i] = t[1];\n\t\tif (s[i] == 'U') {\n\t\t\ts[i] = 'D';\n\t\t} else if (s[i] == 'D') {\n\t\t\ts[i] = 'U';\n\t\t}\n\t}\n\tll ans = 0;\n\tfor (int T = 1; T <= n; T++) {\n\t\tfill(l + 1, l + T + 1, 1);\n\t\tfill(r + 1, r + T + 1, 100);\n\t\tfill(u + 1, u + T + 1, 1);\n\t\tfill(d + 1, d + T + 1, 100);\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tif (b[i] + 1 > T) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (s[i] == 'L') {\n\t\t\t\tl[b[i] + 1] = max(l[b[i] + 1], a[i] + 1);\n\t\t\t} else if (s[i] == 'R') {\n\t\t\t\tr[T - b[i]] = min(r[T - b[i]], a[i] - 1);\n\t\t\t} else if (s[i] == 'U') {\n\t\t\t\tu[b[i] + 1] = max(u[b[i] + 1], a[i] + 1);\n\t\t\t} else if (s[i] == 'D') {\n\t\t\t\td[T - b[i]] = min(d[T - b[i]], a[i] - 1);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 2; i <= T; i++) {\n\t\t\tl[i] = max(l[i], l[i - 1]);\n\t\t\tu[i] = max(u[i], u[i - 1]);\n\t\t}\n\t\tfor (int i = T - 1; i; i--) {\n\t\t\tr[i] = min(r[i], r[i + 1]);\n\t\t\td[i] = min(d[i], d[i + 1]);\n\t\t}\n\t\tsrc = n * 4 + 1, snk = src + 1;\n\t\ttot = 0;\n\t\tfill(lnk + 1, lnk + snk + 1, 0);\n\t\tfor (int i = 1; i <= T; i++) {\n\t\t\tadd_f(src, i, 1, 0);\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tif (x[j] >= l[i] && x[j] <= r[i]) {\n\t\t\t\t\tadd_f(i, j + n, 1, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tadd_f(i + n, i + n * 2, 1, lim - v[i]);\n\t\t}\n\t\tfor (int i = 1; i <= T; i++) {\n\t\t\tadd_f(i + n * 3, snk, 1, 0);\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tif (y[j] >= u[i] && y[j] <= d[i]) {\n\t\t\t\t\tadd_f(j + n * 2, i + n * 3, 1, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint fl = 0;\n\t\tll mx = 0;\n\t\tflow(fl, mx);\n\t\tif (fl == T && T * lim - mx > ans) {\n\t\t\tans = T * lim - mx;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nstruct Simplex {        // Maximize c*x subject to Ax <= b.\n  using T = LD;         // Initialize the structure, set A, b, c and then run\n  vector<vector<T>> A;  // solve(). Max objective is stored in res. To recover\n  vector<T> b, c;       // the best result, use getVars().\n\n  int V, E;\n  VI eqIds, varIds, cols;\n  T res;\n  const T kEps = 1e-9;\n\n  Simplex(int vars, int eqs) : A(eqs, vector<T>(vars)), b(eqs), c(vars),\n                               V(vars), E(eqs), eqIds(eqs), varIds(vars), res(0) {\n    iota(ALL(varIds), 0); iota(ALL(eqIds), vars);\n  }\n\n  void pivot(int eq, int var) {\n    T coef = 1 / A[eq][var];\n    cols.clear();\n    REP (i, V) {\n      if (abs(A[eq][i]) > kEps) { cols.PB(i); A[eq][i] *= coef; }\n    }\n    A[eq][var] *= coef; b[eq] *= coef;\n    REP (row, E) {\n      if (row == eq || abs(A[row][var]) < kEps) { continue; }\n      T k = -A[row][var];\n      A[row][var] = 0;\n      for (int i : cols) { A[row][i] += k * A[eq][i]; }\n      b[row] += k * b[eq];\n    }\n    T q = c[var]; c[var] = 0;\n    for (int i : cols) { c[i] -= q * A[eq][i]; }\n    res += q * b[eq];\n\n    swap(varIds[var], eqIds[eq]);\n  }\n  \n  bool solve() {\n    while (true) {\n      int eq = -1, var = -1;\n      REP (i, E) { if (b[i] < -kEps) { eq = i; break; } }\n      if (eq == -1) { break; }\n      REP (i, V) { if (A[eq][i] < -kEps) { var = i; break; } }\n      if (var == -1) { res = -1e9; return false; /* No solution */ }\n      pivot(eq, var);\n    }\n\n    while (true) {\n      int var = -1, eq = -1;\n      REP (i, V) { if (c[i] > kEps) { var = i; break; } }\n      if (var == -1) { break; }\n      REP (i, E) {\n        if (A[i][var] < kEps) { continue; }\n        if (eq >= 0 && b[i] / A[i][var] >= b[eq] / A[eq][var]) { continue; }\n        eq = i;\n      }\n      if (eq == -1) { res = 1e9; return false; /* Unbounded */ }\n      pivot(eq, var);\n    }\n\n    return true;\n  }\n  \n  vector<T> getVars() {  // Optimal assignment of variables.\n    vector<T> result(V);\n    REP (i, E) { if (eqIds[i] < V) { result[eqIds[i]] = b[i]; } }\n    return result;\n  }\n};\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n\n  int N, M;\n  cin >> N;\n  vector<PII> points(N);\n  vector<int> point_vals(N);\n\n  for (int i = 0; i < N; ++i) {\n    cin >> points[i].st >> points[i].nd >> point_vals[i];\n  }\n\n  map<char, function<bool(PII, int)>> checkers = {\n    {'L', [](const PII &pt, int a) { return pt.st <= a; }},\n    {'R', [](const PII &pt, int a) { return pt.st >= a; }},\n    {'D', [](const PII &pt, int a) { return pt.nd <= a; }},\n    {'U', [](const PII &pt, int a) { return pt.nd >= a; }}\n  };\n\n  cin >> M;\n\n  Simplex sim(N, M + 2 * N);\n  for (int i = 0; i < M; ++i) {\n    char type;\n    int a, b;\n    cin >> type >> a >> b;\n\n    for (int j = 0; j < N; ++j) {\n      sim.A[i][j] = checkers[type](points[j], a);\n    }\n    sim.b[i] = b;\n\n    debug(sim.A[i], sim.b[i]);\n  }\n  for (int i = 0; i < N; ++i) {\n    sim.c[i] = point_vals[i];\n    sim.A[M + i * 2][i] = -1;\n    sim.A[M + i * 2 + 1][i] = 1;\n    sim.b[M + i * 2] = 0;\n    sim.b[M + i * 2 + 1] = 1;\n  }\n\n  assert(sim.solve());\n  cout << (LL)sim.res << \"\\n\";\n  debug(sim.getVars());\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cassert>\n\n#define pb push_back\n#define fir first\n#define sec second\n#define forto(_) for (int e = last[_], v = E[e].to; e; v = E[e = E[e].next].to)\n#define forback(_) for (int _ = T; _ ^ S; _ = pre[_])\n\ntypedef long long LL;\n\nconst int kMaxn = 85, kMaxe = 2e4;\nconst LL kInf64 = 1e15 + 5;\n\ntypedef std::pair<int, int> Pii;\ntypedef int IArn[kMaxn];\ntypedef int IArv[kMaxn << 2];\n\nstruct Edge {\n\tint to, capt;\n\tLL cost;\n\tint next;\n} E[kMaxe << 1];\n\nint n, m, tote, S, T;\nIArn X, Y, L, R, U, D;\nIArv last, pre, pree;\nLL V[kMaxn], dist[kMaxn << 2];\nstd::vector<Pii> con[4];\nchar IN[5];\n\ninline void AddEdge(int u, int v, int cap, LL cst) {\n\tE[++tote] = (Edge){v, cap, cst, last[u]}, last[u] = tote;\n\tassert(E[tote].cost == cst);\n\tE[++tote] = (Edge){u, 0, -cst, last[v]}, last[v] = tote;\n}\ntemplate <typename T>\nvoid Umin(T & x, T y) {\n\tx > y ? x = y : 0;\n}\ntemplate <typename T>\nvoid Umax(T & x, T y) {\n\tx < y ? x = y : 0;\n}\nLL Mcf(int);\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d%d%lld\", X + i, Y + i, V + i);\n\t}\n\tscanf(\"%d\", &m);\n\tfor (int i = 0, ai, bi; i < m; i++) {\n\t\tscanf(\"%s%d%d\", IN, &ai, &bi);\n\t\tswitch (IN[0]) {\n\t\t\tcase 'L' :\n\t\t\t\tcon[0].pb(Pii(ai, bi));\n\t\t\t\tbreak;\n\t\t\tcase 'R' :\n\t\t\t\tcon[1].pb(Pii(ai, bi));\n\t\t\t\tbreak;\n\t\t\tcase 'D' :\n\t\t\t\tcon[2].pb(Pii(ai, bi));\n\t\t\t\tbreak;\n\t\t\tcase 'U' :\n\t\t\t\tcon[3].pb(Pii(ai, bi));\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tL[i] = D[i] = 1;\n\t}\n\tfor (auto & p : con[0]) {\n\t\tUmax(L[p.sec + 1], p.fir + 1);\n\t}\n\tfor (auto & p : con[2]) {\n\t\tUmax(D[p.sec + 1], p.fir + 1);\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tUmax(L[i], L[i - 1]);\n\t\tUmax(D[i], D[i - 1]);\n\t}\n\n\tLL ans = 0;\n\tfor (int k = 1; k <= n; k++) {\n\t\tfor (int i = 1; i <= k; i++) {\n\t\t\tR[i] = U[i] = 1000;\n\t\t}\n\t\tfor (auto & p : con[1]) {\n\t\t\tif (k <= p.sec) continue;\n\t\t\tUmin(R[k - p.sec], p.fir - 1);\n\t\t}\n\t\tfor (auto & p : con[3]) {\n\t\t\tif (k <= p.sec) continue;\n\t\t\tUmin(U[k - p.sec], p.fir - 1);\n\t\t}\n\t\tfor (int i = k - 1; i > 0; i--) {\n\t\t\tUmin(R[i], R[i + 1]);\n\t\t\tUmin(U[i], U[i + 1]);\n\t\t}\n\n\t\ttote = 1;\n\t\tmemset(last, 0, sizeof last);\n\t\tT = (S = k + n + n + k + 1) + 1;\n\t\tfor (int i = 1; i <= k; i++) {\n\t\t\tAddEdge(S, i, 1, 0);\n\t\t\tAddEdge(k + n + n + i, T, 1, 0);\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tif (L[i] <= X[j] && X[j] <= R[i]) {\n\t\t\t\t\tAddEdge(i, k + j, 1, 0);\n\t\t\t\t}\n\t\t\t\tif (D[i] <= Y[j] && Y[j] <= U[i]) {\n\t\t\t\t\tAddEdge(k + n + j, k + n + n + i, 1, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tAddEdge(k + i, k + n + i, 1, kInf64 - V[i]);\n\t\t}\n\n\t\tans = std::max(ans, Mcf(k));\n\t}\n\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n\nbool Spfa() {\n\tstatic std::queue<int> que;\n\tstatic int inque[kMaxn << 2];\n\n\tmemset(pre, 0xff, sizeof pre);\n\tmemset(dist, 0x7f, sizeof dist);\n\n\tfor (dist[S] = 0, que.push(S), inque[S] = 1; !que.empty(); ) {\n\t\tint u = que.front(); que.pop();\n\t\tforto(u) {\n\t\t\tif (E[e].capt > 0 && dist[v] > dist[u] + E[e].cost) {\n\t\t\t\tdist[v] = dist[u] + E[e].cost;\n\t\t\t\tpre[v] = u, pree[v] = e;\n\t\t\t\tif (!inque[v]) {\n\t\t\t\t\tque.push(v), inque[v] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tinque[u] = 0;\n\t}\n\treturn ~pre[T];\n}\n\nLL Mcf(int maxf) {\n\tLL tot = 0, sumf = 0;\n\twhile (Spfa()) {\n\t\tint flow = 100000;\n\t\tforback(u) {\n\t\t\tflow = std::min(flow, E[pree[u]].capt);\n\t\t}\n\t\ttot += 1ll * flow * dist[T], sumf += flow;\n\t\tforback(u) {\n\t\t\tE[pree[u]].capt -= flow;\n\t\t\tE[pree[u] ^ 1].capt += flow;\n\t\t}\n\t}\n\treturn sumf >= maxf ? maxf * kInf64 - tot : 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef double db;\n#define go(u) for(int i = head[u], v = e[i].to; i; i=e[i].lst, v=e[i].to)\n#define rep(i, a, b) for(int i = a; i <= b; ++i)\n#define pb push_back\n#define re(x) memset(x, 0, sizeof x)\ninline int gi() {\n    int x = 0,f = 1;\n    char ch = getchar();\n    while(!isdigit(ch)) { if(ch == '-') f = -1; ch = getchar();}\n    while(isdigit(ch)) { x = (x << 3) + (x << 1) + ch - 48; ch = getchar();}\n    return x * f;\n}\ntemplate <typename T> inline bool Max(T &a, T b){return a < b ? a = b, 1 : 0;}\ntemplate <typename T> inline bool Min(T &a, T b){return a > b ? a = b, 1 : 0;}\nconst int N = 407;\nconst int inf = 1e9;\nconst LL INF = 1e18;\nint n, m;\nint x[N], y[N], a[N], b[N], type[N], L[N], R[N];\nLL ans, w[N];\nchar s[10];\nnamespace MCMF {\n\tint S, T, edc;\n\tint head[N], vis[N], cur[N];\n\tLL dis[N];\n\tstruct edge { int lst, to, cap, flow;LL c;}e[N * N * 2];\n\tvoid Add(int a, int b, int c, LL d) {\n\t\te[++edc] = (edge) { head[a], b, c, 0, -d}, head[a] = edc;\n\t\te[++edc] = (edge) { head[b], a, 0, 0, d}, head[b] = edc;\n\t}\n\tbool spfa() {\n\t\tmemcpy(cur, head, sizeof cur);\n\t\tfill(dis, dis + N, INF);\n\t\tdis[S] = 0;\n\t\tqueue<int>Q; Q.push(S);\n\t\twhile(!Q.empty()) {\n\t\t\tint u = Q.front();Q.pop();\n\t\t\tvis[u] = 0;\n\t\t\tgo(u) if(e[i].cap - e[i].flow > 0 && Min(dis[v], dis[u] + e[i].c)) {\n\t\t\t\tif(!vis[v])\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t\treturn dis[T] != INF;\n\t}\n\ttypedef pair<int, LL> pii;\n\t#define mp make_pair\n\tpii dfs(int u, int b) {\n\t\tif(u == T || !b) return mp(b, 0);\n\t\tvis[u] = 1;\n\t\tpii res(0, 0), t;\n\t\tfor(int &i = cur[u], v = e[i].to; i; i = e[i].lst, v = e[i].to) \n\t\tif(e[i].cap - e[i].flow > 0 && dis[u] + e[i].c == dis[v] && !vis[v]) {\n\t\t\tt = dfs(v, min(b, e[i].cap - e[i].flow));\n\t\t\tres.first += t.first;\n\t\t\tres.second += t.second + e[i].c * t.first;\n\t\t\te[i].flow += t.first;\n\t\t\te[i ^ 1].flow -= t.first;\n\t\t\tb -= t.first;\n\t\t\tif(!b) break;\n\t\t}\n\t\tvis[u] = 0;\n\t\treturn res;\n\t}\n\tLL mcmf() {\n\t\tLL res = 0;\n\t\twhile(spfa()) {\n\t\t\tres += dfs(S, inf).second;\n\t\t}\n\t\treturn -res;\n\t}\n}\nint id(char c) {\n\tif(c == 'L') return 0;\n\tif(c == 'R') return 1;\n\tif(c == 'D') return 2;\n\tif(c == 'U') return 3;\n}\nint main() {\n#ifdef fwat\n//\tfreopen(\"data.in\", \"r\", stdin);\n#endif\n\tusing namespace MCMF;\n\tn = gi();\n\trep(i, 1, n) x[i] = gi(), y[i] = gi(), scanf(\"%lld\", &w[i]);\n\tm = gi();\n\trep(i, 1, m) {\n\t\tscanf(\"%s%d%d\", s, &a[i], &b[i]);\n\t\ttype[i] = id(s[0]);\n\t}\n\tS = 401, T = 402;\n\tfor(int tot = n; tot; --tot) {\n\t\tedc = 1;\n\t\tre(head);\n\t\trep(i, 1, tot) L[i] = 1, R[i] = 100;\n\t\trep(i, 1, m) {\n\t\t\tif(type[i] == 0) for(int j = b[i] + 1; j <= tot; ++j) Max(L[j], a[i] + 1);\n\t\t\tif(type[i] == 1) for(int j = tot - b[i]; j > 0; --j)  Min(R[j], a[i] - 1);\n\t\t}\n\t\trep(i, 1, tot) {\n\t\t\tAdd(S, i, 1, 0);\n\t\t\trep(j, L[i], R[i]) Add(i, j + 100, 1, 0);\n\t\t}\n\t\trep(i, 1, tot) L[i] = 1, R[i] = 100;\n\t\trep(i, 1, m) {\n\t\t\tif(type[i] == 2) for(int j = b[i] + 1; j <= tot; ++j) Max(L[j], a[i] + 1);\n\t\t\tif(type[i] == 3) for(int j = tot - b[i]; j > 0; --j)  Min(R[j], a[i] - 1);\n\t\t}\n\t\trep(i, 1, tot) {\n\t\t\tAdd(i + 300, T, 1, 0);\n\t\t\trep(j, L[i], R[i]) Add(j + 200, i + 300, 1, 0);\n\t\t}\n\t\trep(i, 1, n) Add(x[i] + 100, y[i] + 200, 1, w[i]);\n\t\tMax(ans, mcmf());\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cassert>\n\n#define pb push_back\n#define fir first\n#define sec second\n#define forto(_) for (int e = last[_], v = E[e].to; e; v = E[e = E[e].next].to)\n#define forback(_) for (int _ = T; _ ^ S; _ = pre[_])\n\ntypedef long long LL;\n\nconst int kMaxn = 85, kMaxe = 2e4;\nconst LL kInf64 = 1e15 + 5;\n\ntypedef std::pair<int, int> Pii;\ntypedef int IArn[kMaxn];\ntypedef int IArv[kMaxn << 2];\n\nstruct Edge {\n\tint to, capt;\n\tLL cost;\n\tint next;\n} E[kMaxe << 1];\n\nint n, m, tote, S, T;\nIArn X, Y, L, R, U, D;\nIArv last, pre, pree;\nLL V[kMaxn], dist[kMaxn << 2];\nstd::vector<Pii> con[4];\nchar IN[5];\n\ninline void AddEdge(int u, int v, int cap, LL cst) {\n\tE[++tote] = (Edge){v, cap, cst, last[u]}, last[u] = tote;\n\tassert(E[tote].cost == cst);\n\tE[++tote] = (Edge){u, 0, -cst, last[v]}, last[v] = tote;\n}\ntemplate <typename T>\nvoid Umin(T & x, T y) {\n\tx > y ? x = y : 0;\n}\ntemplate <typename T>\nvoid Umax(T & x, T y) {\n\tx < y ? x = y : 0;\n}\nLL Mcf(int);\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d%d%lld\", X + i, Y + i, V + i);\n\t}\n\tscanf(\"%d\", &m);\n\tfor (int i = 0, ai, bi; i < m; i++) {\n\t\tscanf(\"%s%d%d\", IN, &ai, &bi);\n\t\tswitch (IN[0]) {\n\t\t\tcase 'L' :\n\t\t\t\tcon[0].pb(Pii(ai, bi));\n\t\t\t\tbreak;\n\t\t\tcase 'R' :\n\t\t\t\tcon[1].pb(Pii(ai, bi));\n\t\t\t\tbreak;\n\t\t\tcase 'D' :\n\t\t\t\tcon[2].pb(Pii(ai, bi));\n\t\t\t\tbreak;\n\t\t\tcase 'U' :\n\t\t\t\tcon[3].pb(Pii(ai, bi));\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n/*\tfor (int i = 1; i <= n; i++) {\n\t\tL[i] = D[i] = 1;\n\t}\n\tfor (auto & p : con[0]) {\n\t\tUmax(L[p.sec + 1], p.fir + 1);\n\t}\n\tfor (auto & p : con[2]) {\n\t\tUmax(D[p.sec + 1], p.fir + 1);\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tUmax(L[i], L[i - 1]);\n\t\tUmax(D[i], D[i - 1]);\n\t}*/\n\n\tLL ans = 0;\n\tfor (int k = 1; k <= n; k++) {\n\t\tfor (int i = 1; i <= k; i++) {\n\t\t\tR[i] = U[i] = 1000;\n\t\t\tL[i] = D[i] = 0;\n\t\t}\n\t\tfor (auto & p : con[1]) {\n\t\t\tif (k <= p.sec) continue;\n\t\t\tUmin(R[k - p.sec], p.fir - 1);\n\t\t}\n\t\tfor (auto & p : con[3]) {\n\t\t\tif (k <= p.sec) continue;\n\t\t\tUmin(U[k - p.sec], p.fir - 1);\n\t\t}\n\t\tfor (int i = k - 1; i > 0; i--) {\n\t\t\tUmin(R[i], R[i + 1]);\n\t\t\tUmin(U[i], U[i + 1]);\n\t\t}\n\t\tfor (auto & p : con[0]) {\n\t\t\tif (k <= p.sec) continue;\n\t\t\tUmax(L[p.sec + 1], p.fir + 1);\n\t\t}\n\t\tfor (auto & p : con[2]) {\n\t\t\tif (k <= p.sec) continue;\n\t\t\tUmax(D[p.sec + 1], p.fir + 1);\n\t\t}\n\n\t\ttote = 1;\n\t\tmemset(last, 0, sizeof last);\n\t\tT = (S = k + n + n + k + 1) + 1;\n\t\tfor (int i = 1; i <= k; i++) {\n\t\t\tAddEdge(S, i, 1, 0);\n\t\t\tAddEdge(k + n + n + i, T, 1, 0);\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tif (L[i] <= X[j] && X[j] <= R[i]) {\n\t\t\t\t\tAddEdge(i, k + j, 1, 0);\n\t\t\t\t}\n\t\t\t\tif (D[i] <= Y[j] && Y[j] <= U[i]) {\n\t\t\t\t\tAddEdge(k + n + j, k + n + n + i, 1, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tAddEdge(k + i, k + n + i, 1, kInf64 - V[i]);\n\t\t}\n\n\t\tans = std::max(ans, Mcf(k));\n\t}\n\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n\nbool Spfa() {\n\tstatic std::queue<int> que;\n\tstatic int inque[kMaxn << 2];\n\n\tmemset(pre, 0xff, sizeof pre);\n\tmemset(dist, 0x7f, sizeof dist);\n\n\tfor (dist[S] = 0, que.push(S), inque[S] = 1; !que.empty(); ) {\n\t\tint u = que.front(); que.pop();\n\t\tforto(u) {\n\t\t\tif (E[e].capt > 0 && dist[v] > dist[u] + E[e].cost) {\n\t\t\t\tdist[v] = dist[u] + E[e].cost;\n\t\t\t\tpre[v] = u, pree[v] = e;\n\t\t\t\tif (!inque[v]) {\n\t\t\t\t\tque.push(v), inque[v] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tinque[u] = 0;\n\t}\n\treturn ~pre[T];\n}\n\nLL Mcf(int maxf) {\n\tLL tot = 0, sumf = 0;\n\twhile (Spfa()) {\n\t\tint flow = 100000;\n\t\tforback(u) {\n\t\t\tflow = std::min(flow, E[pree[u]].capt);\n\t\t}\n\t\ttot += 1ll * flow * dist[T], sumf += flow;\n\t\tforback(u) {\n\t\t\tE[pree[u]].capt -= flow;\n\t\t\tE[pree[u] ^ 1].capt += flow;\n\t\t}\n\t}\n\treturn sumf >= maxf ? maxf * kInf64 - tot : 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace __gnu_pbds;\nusing namespace std;\n \ntemplate <typename T>\nusing ordered_set =\n\ttree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n \n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n\t*this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n \n#define shandom_ruffle random_shuffle\n \nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=327;\nusing bn=bitset<87>;\nusing ld=long double;\n\nint n;\npii gdz[nax];\nll war[nax];\n\nint m;\nbn podz[nax];\nint ile[nax];\n\nll wyn;\n\nbn ter;\n \nll dajwar()\n{\n\tll ret=0;\n\tfor (int i=1; i<=n; i++)\n\t\tif (ter[i])\n\t\t\tret+=war[i];\n\treturn ret;\n}\n \nint popr()\n{\n\tfor (int i=1; i<=m; i++)\n\t\tif ((podz[i]&ter).count()>ile[i])\n\t\t\treturn 0;\n\treturn 1;\n}\n\nvi kol;\n\nstruct Simplex {        // Maximize c*x subject to Ax <= b.\n  using T = ld;     // Initialize the structure, set A, b, c and then run\n  vector<vector<T>> A;  // solve(). Max objective is stored in res. To recover\n  vector<T> b, c;       // the best result, use getVars().\n  int V, E;\n  vector<int> eqIds, varIds, cols;\n  T res;\n  static constexpr T kEps = 1e-5;\n\n  Simplex(int vars, int eqs) : A(eqs, vector<T>(vars)), b(eqs), c(vars),\n      V(vars), E(eqs), eqIds(eqs), varIds(vars), res(0) {\n    iota(varIds.begin(), varIds.end(), 0);\n    iota(eqIds.begin(), eqIds.end(), vars);\n  }\n\n  void pivot(int eq, int var) {\n    T coef = 1 / A[eq][var];\n    cols.clear();\n    for (int i = 0; i < V; i++) {\n      if (abs(A[eq][i]) > kEps) { cols.push_back(i); A[eq][i] *= coef; }\n    }\n    A[eq][var] *= coef; b[eq] *= coef;\n    for (int row = 0; row < E; row++) {\n      if (row == eq || abs(A[row][var]) < kEps) { continue; }\n      T k = -A[row][var];\n      A[row][var] = 0;\n      for (int i : cols) { A[row][i] += k * A[eq][i]; }\n      b[row] += k * b[eq];\n    }\n    T q = c[var]; c[var] = 0;\n    for (int i : cols) { c[i] -= q * A[eq][i]; }\n    res += q * b[eq];\n    swap(varIds[var], eqIds[eq]);\n  }\n\n  bool solve() {\n    while (true) {\n      int eq = -1, var = -1;\n      for (int i = 0; i < E; i++) { if (b[i] < -kEps) { eq = i; break; } }\n      if (eq == -1) { break; }\n      for (int i = 0; i < V; i++) { if (A[eq][i] < -kEps) { var = i; break; } }\n      if (var == -1) { res = -1e9; return false; /* No solution */ }\n      pivot(eq, var);\n    }\n    while (true) {\n      int var = -1, eq = -1;\n      for (int i = 0; i < V; i++) { if (c[i] > kEps) { var = i; break; } }\n      if (var == -1) { break; }\n      for (int i = 0; i < E; i++) {\n        if (A[i][var] < kEps) { continue; }\n        if (eq >= 0 && b[i] / A[i][var] >= b[eq] / A[eq][var]) { continue; }\n        eq = i;\n      }\n      if (eq == -1) { res = 1e9; return false; /* Unbounded */ }\n      pivot(eq, var);\n    }\n    return true;\n  }\n\n  vector<T> getVars() { // Optimal assignment of variables.\n    vector<T> result(V);\n    for (int i = 0; i < E; i++) if (eqIds[i] < V) result[eqIds[i]] = b[i];\n    return result;\n  }\n};\n\nvoid rek(int v, int jesz)\n{\n\tif (popr())\n\t\twyn=max(wyn, dajwar());\n\tif (!jesz)\n\t\treturn;\n\tfor (int i=v; i<=n; i++)\n\t{\n\t\tter.flip(i);\n\t\trek(i+1, jesz-1);\n\t\tter.flip(i);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(\"%d%d%lld\", &gdz[i].first, &gdz[i].second, &war[i]);\n\tscanf(\"%d\", &m);\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\tchar c;\n\t\tint a, b;\n\t\tscanf(\" %c%d%d\", &c, &a, &b);\n\t\tfor (int j=1; j<=n; j++)\n\t\t{\n\t\t\tif (c=='L' && gdz[j].first<=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='R' && gdz[j].first>=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='D' && gdz[j].second<=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='U' && gdz[j].second>=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t}\n\t\tile[i]=b;\n\t}\n\tSimplex janusz(n, m+2*n);\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tjanusz.c[i]=war[i+1];\n\t}\n\tfor (int i=0; i<m; i++)\n\t{\n\t\tjanusz.b[i]=ile[i+1];\n\t\tfor (int j=0; j<n; j++)\n\t\t\tjanusz.A[i][j]=podz[i+1][j+1];\n\t}\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tjanusz.b[m+i]=1;\n\t\tjanusz.A[m+i][i]=1;\n\t}\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tjanusz.b[m+n+i]=0;\n\t\tjanusz.A[m+n+i][i]=-1;\n\t}\n\tassert(janusz.solve());\n\tauto wez=janusz.getVars();\n\t\n\tvector <pair<ld,int> > wek;\n\tfor (int i=1; i<=n; i++)\n\t\twek.push_back({wez[i-1], i});\n\t\n\tsort(wek.begin(), wek.end());\n\treverse(wek.begin(), wek.end());\n\t\n\tfor (auto i : wek)\n\t{\n\t\tter[i.second]=1;\n\t\tif (!popr())\n\t\t\tter[i.second]=0;\n\t}\n\t\n\trek(1, 4+(n<=70));\n\t\n\tdebug() << janusz.getVars();\n\tprintf(\"%lld\\n\", wyn);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cstring>\n#include<cmath>\n#include<cstdio>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nlong long read()\n{\n\tchar c=getchar();\n\tlong long res=0;\n\twhile(c<'0'||c>'9') c=getchar();\n\twhile(c>='0'&&c<='9') res=(res<<1)+(res<<3)+(c^48),c=getchar();\n\treturn res;\n}\nint n,m,s,t,h[405],cnt=1,lx[205],rx[205],ly[205],ry[205],p[405],pre[405];\nlong long d[405],ans,sum;\nbool vis[405];\nchar op[10];\nstruct Edge\n{\n\tint to,next,d;\n\tlong long v;\n}w[100005];\nstruct node\n{\n\tint x,y;\n\tlong long v;\n}a[100005];\nstruct que\n{\n\tint op,x,v;\n}b[100005];\nvoid add(int x,int y,int d,long long v)\n{\n\tw[++cnt]=(Edge){y,h[x],d,v};\n\th[x]=cnt;\n\tw[++cnt]=(Edge){x,h[y],0,-v};\n\th[y]=cnt;\n}\nbool Spfa()\n{\n\tmemset(d,0x3f,sizeof(d));\n\td[s]=0;p[s]=0x3f3f3f3f;p[t]=0;\n\tqueue<int> q;\n\tq.push(s);\n\twhile(!q.empty())\n\t{\n\t\tint u=q.front();\n\t\tq.pop();\n\t\tvis[u]=0;\n\t\tfor(int i=h[u];i;i=w[i].next)\n\t\t{\n\t\t\tint to=w[i].to;\n\t\t\tif(w[i].d&&d[to]>d[u]+w[i].v)\n\t\t\t{\n\t\t\t\td[to]=d[u]+w[i].v;\n\t\t\t\tp[to]=min(p[u],w[i].d);pre[to]=i;\n\t\t\t\tif(!vis[to]) q.push(to),vis[to]=1;\n\t\t\t}\n\t\t}\n\t}\n\treturn p[t];\n}\nvoid Solve()\n{\n\tsum+=p[t]*d[t];\n\tint now=t;\n\twhile(now!=s)\n\t{\n\t\tw[pre[now]].d-=p[t];\n\t\tw[pre[now]^1].d+=p[t];\n\t\tnow=w[pre[now]^1].to;\n\t}\n}\nvoid EK()\n{\n\tsum=0;\n\twhile(Spfa()) Solve();\n}\nint main()\n{\n\tn=read();\n\tfor(int i=1;i<=n;i++) a[i].x=read(),a[i].y=read(),a[i].v=read();\n\tm=read();\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%s\",op);\n\t\tif(op[0]=='L') b[i].op=1;\n\t\telse if(op[0]=='R') b[i].op=2;\n\t\telse if(op[0]=='D') b[i].op=3;\n\t\telse b[i].op=4;\n\t\tb[i].x=read(),b[i].v=read();\n\t}\n\tfor(int k=1;k<=n;k++)\n\t{\n\t\tmemset(h,0,sizeof(h));cnt=1;\n\t\ts=0,t=2*k+2*n+1;\n\t\tfor(int i=1;i<=k;i++) add(s,i,1,0),add(i+2*n+k,t,1,0);\n\t\tmemset(lx,0,sizeof(lx));memset(rx,0x3f,sizeof(rx));\n\t\tmemset(ly,0,sizeof(ly));memset(ry,0x3f,sizeof(ry));\n\t\tfor(int i=1;i<=m;i++)\n\t\t{\n\t\t\tif(b[i].op==1) for(int j=b[i].v+1;j<=k;j++) lx[j]=max(lx[j],b[i].x+1);\n\t\t\telse if(b[i].op==2) for(int j=1;j<=k-b[i].v;j++) rx[j]=min(rx[j],b[i].x-1);\n\t\t\telse if(b[i].op==3) for(int j=b[i].v+1;j<=k;j++) ly[j]=max(ly[j],b[i].x+1);\n\t\t\telse for(int j=1;j<=k-b[i].v;j++) ry[j]=min(ry[j],b[i].x-1);\n\t\t}\n\t\tfor(int i=1;i<=n;i++) add(i+k,i+n+k,1,a[i].v);\n\t\tfor(int i=1;i<=k;i++)\n\t\tfor(int j=1;j<=n;j++) if(lx[i]<=a[j].x&&a[j].x<=rx[i]) add(i,j+k,1,0);\n\t\tfor(int i=1;i<=k;i++)\n\t\tfor(int j=1;j<=n;j++) if(ly[i]<=a[j].y&&a[j].y<=ry[i]) add(j+k+n,2*n+i+k,1,0);\n\t\tEK();\n\t\tans=max(ans,sum);\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace mcmf {\n\nconst long long inf = 1000111222000111222LL;\n\nstruct edge {\n    int to, flow, capacity;\n    long long cost;\n\n    edge() {\n    }\n\n    edge(int to, int flow, int capacity, long long cost): to(to), flow(flow), capacity(capacity), cost(cost) {\n    }\n\n};\n\nconst int max_v = 404;\n\nvector<edge> edges;\nvector<int> g[max_v];\n\nvoid clr() {\n    edges.clear();\n    for (int i = 0; i < max_v; ++i) {\n        g[i].clear();\n    }\n}\n\nvoid add_edge(int u, int v, int capacity, long long cost) {\n    g[u].push_back(edges.size());\n    edges.push_back(edge(v, 0, capacity, cost));\n    g[v].push_back(edges.size());\n    edges.push_back(edge(u, 0, 0, -cost));\n}\n\nint parent[max_v], p_id[max_v];\nlong long phi[max_v], dist[max_v];\n\nlong long dijkstra(int s, int t) {\n    for (int i = 0; i <= t; ++i) {\n        dist[i] = inf;\n    }\n    priority_queue<pair<long long, int>> q;\n    dist[s] = 0;\n    q.push({0, s});\n    while (!q.empty()) {\n        pair<long long, int> p = q.top();\n        q.pop();\n        long long d = -p.first, v = p.second;\n        if (d != dist[v]) {\n            continue;\n        }\n        for (int id : g[v]) {\n            if (edges[id].flow == edges[id].capacity) {\n                continue;\n            }\n            int to = edges[id].to;\n            assert(edges[id].cost + phi[v] - phi[to] >= 0);\n            if (dist[v] + edges[id].cost + phi[v] - phi[to] < dist[to]) {\n                dist[to] = dist[v] + edges[id].cost + phi[v] - phi[to];\n                parent[to] = v;\n                p_id[to] = id;\n                q.push({-dist[to], to});\n            }\n        }\n    }\n    if (dist[t] == inf) {\n        return inf;\n    }\n    for (int i = 0; i <= t; ++i) {\n        phi[i] = min(inf, dist[i] + phi[i]);\n    }\n    int v = t;\n    while (v != s) {\n        ++edges[p_id[v]].flow;\n        --edges[p_id[v] ^ 1].flow;\n        v = parent[v];\n    }\n    return phi[t];\n}\n\nlong long min_cost_max_flow(int s, int t, int k) {\n    for (int i = 0; i <= t; ++i) {\n        phi[i] = 0;\n    }\n    long long res = 0;\n    int it = 0;\n    while (true) {\n        long long x = dijkstra(s, t);\n        if (x == inf) {\n            break;\n        }\n        ++it;\n        res += x;\n    }\n    if (it != k) {\n        return 0;\n    }\n    return res;\n}\n\n}\n\nconst int max_n = 105;\nconst int max_c = 333;\nconst long long inf = 1000111222000111LL;\n\nint lx[max_n], rx[max_n], ly[max_n], ry[max_n];\n\nstruct constraint {\n    char tp;\n    int x, cnt;\n\n    void read() {\n        scanf(\"\\n%c%d%d\", &tp, &x, &cnt);\n        --x;\n    }\n\n    void add(int k) {\n        if (tp == 'L') {\n            for (int i = cnt; i < k; ++i) {\n                lx[i] = max(lx[i], x + 1);\n            }\n        } else if (tp == 'D') {\n            for (int i = cnt; i < k; ++i) {\n                ly[i] = max(ly[i], x + 1);\n            }\n        } else if (tp == 'R') {\n            for (int i = 0; i < k - cnt; ++i) {\n                rx[i] = min(rx[i], x - 1);\n            }\n        } else {\n            for (int i = 0; i < k - cnt; ++i) {\n                ry[i] = min(ry[i], x - 1);\n            }\n        }\n    }\n};\n\nint n, m, x[max_n], y[max_n];\nlong long v[max_n];\nconstraint c[max_c];\n\nlong long solve(int k) {\n    for (int i = 0; i < k; ++i) {\n        lx[i] = ly[i] = 0;\n        rx[i] = ry[i] = 99;\n    }\n    for (int i = 0; i < m; ++i) {\n        c[i].add(k);\n    }\n    for (int i = 0; i < k; ++i) {\n        if (lx[i] > rx[i] || ly[i] > ry[i]) {\n            return 0;\n        }\n    }\n    mcmf::clr();\n    const int max_x = 100;\n    int s = 2 * k + 2 * max_x;\n    int t = s + 1;\n    for (int i = 0; i < k; ++i) {\n        mcmf::add_edge(s, i, 1, 0);\n        for (int x = lx[i]; x <= rx[i]; ++x) {\n            mcmf::add_edge(i, k + x, 1, 0);\n        }\n        mcmf::add_edge(k + 2 * max_x + i, t, 1, 0);\n        for (int y = ly[i]; y <= ry[i]; ++y) {\n            mcmf::add_edge(k + max_x + y, k + 2 * max_x + i, 1, 0);\n        }\n    }\n    for (int i = 0; i < n; ++i) {\n        mcmf::add_edge(k + x[i], k + max_x + y[i], 1, -v[i] + inf);\n    }\n    long long res = -mcmf::min_cost_max_flow(s, t, k);\n    if (res == 0) {\n        return 0;\n    }\n    return res + k * inf;\n}\n\nint main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; ++i) {\n        scanf(\"%d%d%lld\", &x[i], &y[i], &v[i]);\n        --x[i];\n        --y[i];\n    }\n    scanf(\"%d\", &m);\n    for (int i = 0; i < m; ++i) {\n        c[i].read();\n    }\n    long long ans = 0;\n    for (int i = 1; i <= n; ++i) {\n        long long res = solve(i);\n        if (res == 0) {\n            break;\n        }\n        ans = max(ans, res);\n    }\n    printf(\"%lld\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int mod = 1e9 + 7;\nconst int inf = (1 << 30) - 1;\nconst int64 infll = (1LL << 61) - 1;\n\nstruct IoSetup {\n  IoSetup() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    cerr << fixed << setprecision(10);\n  }\n} iosetup;\n\ntemplate< typename T >\nostream &operator<<(ostream &os, const vector< T > &v) {\n  for(int i = 0; i < (int) v.size(); i++) {\n    os << v[i] << (i + 1 != v.size() ? \" \" : \"\");\n  }\n  return os;\n}\n\ntemplate< typename T >\nistream &operator>>(istream &is, vector< T > &v) {\n  for(T &in : v) is >> in;\n  return is;\n}\n\ntemplate< typename T1, typename T2 >\ninline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\ntemplate< typename T1, typename T2 >\ninline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\ntemplate< typename T = int64 >\nvector< T > make_v(size_t a) {\n  return vector< T >(a);\n}\n\ntemplate< typename T, typename... Ts >\nauto make_v(size_t a, Ts... ts) {\n  return vector< decltype(make_v< T >(ts...)) >(a, make_v< T >(ts...));\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value == 0 >::type fill_v(T &t, const V &v) {\n  t = v;\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value != 0 >::type fill_v(T &t, const V &v) {\n  for(auto &e : t) fill_v(e, v);\n}\n\n\nint N, M;\nint L[100], R[100], U[100], D[100];\n\nint main() {\n  cin >> N;\n  vector< pair< int, pair< int, int64 > > > mx;\n  for(int i = 0; i < N; i++) {\n    int x, y;\n    int64 v;\n    cin >> x >> y >> v;\n    --x, --y;\n    mx.emplace_back(x, make_pair(y, v));\n  }\n  cin >> M;\n  for(int i = 0; i < 100; i++) {\n    L[i] = R[i] = U[i] = D[i] = N;\n  }\n  for(int i = 0; i < M; i++) {\n    char t;\n    int a, b;\n    cin >> t >> a >> b;\n    --a;\n    if(t == 'L') L[a] = min(L[a], b);\n    else if(t == 'R') R[a] = min(R[a], b);\n    else if(t == 'D') D[a] = min(D[a], b);\n    else U[a] = min(U[a], b);\n  }\n  for(int i = 98; i >= 0; i--) {\n    L[i] = min(L[i], L[i + 1]);\n    D[i] = min(D[i], D[i + 1]);\n  }\n  for(int i = 1; i < 100; i++) {\n    R[i] = min(R[i], R[i - 1]);\n    U[i] = min(U[i], U[i - 1]);\n  }\n\n  sort(begin(mx), end(mx));\n  map< multiset< int >, int64 > dp[81][81];\n\n  multiset< int > st;\n  dp[0][N][st] = 0;\n  // used, min\n  int64 ret = 0;\n  for(auto &p : mx) { // 80\n    for(int j = N; j >= 0; j--) { // 80\n      for(int k = N; k >= 0; k--) { // 80\n        for(auto o : dp[j][k]) {\n          if(j + 1 <= L[p.first] && min(k, R[p.first]) - 1 >= 0) {\n\n            multiset< int > renew = o.first;\n            renew.emplace(p.second.first);\n            int sum = 0;\n            bool f = true;\n            for(auto &it : renew) {\n              ++sum;\n              if(sum > D[it]) f = false;\n            }\n            sum = 0;\n            auto it = end(renew);\n            do {\n              --it;\n              ++sum;\n              if(sum > U[*it]) f = false;\n            } while(it != begin(renew));\n\n            if(f) {\n              chmax(dp[j + 1][min(k, R[p.first]) - 1][renew], o.second + p.second.second);\n              chmax(ret, o.second + p.second.second);\n            }\n\n          }\n        }\n      }\n    }\n  }\n  cout << ret << endl;\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nostream &operator<<(ostream &os, __float128 f) { return os << (LD)f; }\n\n\nstruct Simplex {        // Maximize c*x subject to Ax <= b.\n  using T = LD;         // Initialize the structure, set A, b, c and then run\n  vector<vector<T>> A;  // solve(). Max objective is stored in res. To recover\n  vector<T> b, c;       // the best result, use getVars().\n  T abs(T x) { return x < 0 ? -x : x; }\n\n  int V, E;\n  VI eqIds, varIds, cols;\n  T res;\n  const LD kEps = 1e-9;\n\n  Simplex(int vars, int eqs) : A(eqs, vector<T>(vars)), b(eqs), c(vars),\n                               V(vars), E(eqs), eqIds(eqs), varIds(vars), res(0) {\n    iota(ALL(varIds), 0); iota(ALL(eqIds), vars);\n  }\n\n  void pivot(int eq, int var) {\n    T coef = 1 / A[eq][var];\n    cols.clear();\n    REP (i, V) {\n      if (abs(A[eq][i]) > kEps) { cols.PB(i); A[eq][i] *= coef; }\n    }\n    A[eq][var] *= coef; b[eq] *= coef;\n    REP (row, E) {\n      if (row == eq || abs(A[row][var]) < kEps) { continue; }\n      T k = -A[row][var];\n      A[row][var] = 0;\n      for (int i : cols) { A[row][i] += k * A[eq][i]; }\n      b[row] += k * b[eq];\n    }\n    T q = c[var]; c[var] = 0;\n    for (int i : cols) { c[i] -= q * A[eq][i]; }\n    res += q * b[eq];\n\n    swap(varIds[var], eqIds[eq]);\n  }\n  \n  bool solve() {\n    while (true) {\n      int eq = -1, var = -1;\n      REP (i, E) { if (b[i] < -kEps) { eq = i; break; } }\n      if (eq == -1) { break; }\n      REP (i, V) { if (A[eq][i] < -kEps) { var = i; break; } }\n      if (var == -1) { res = -1e9; return false; /* No solution */ }\n      pivot(eq, var);\n    }\n\n    while (true) {\n      int var = -1, eq = -1;\n      REP (i, V) { if (c[i] > kEps) { var = i; break; } }\n      if (var == -1) { break; }\n      REP (i, E) {\n        if (A[i][var] < kEps) { continue; }\n        if (eq >= 0 && b[i] / A[i][var] >= b[eq] / A[eq][var]) { continue; }\n        eq = i;\n      }\n      if (eq == -1) { res = 1e9; return false; /* Unbounded */ }\n      pivot(eq, var);\n    }\n\n    return true;\n  }\n  \n  vector<T> getVars() {  // Optimal assignment of variables.\n    vector<T> result(V);\n    REP (i, E) { if (eqIds[i] < V) { result[eqIds[i]] = b[i]; } }\n    return result;\n  }\n};\n\nint N, M;\nvector<PII> points;\nVI point_vals;\n\nLL low_bound;\nclock_t time_start;\n\nvoid Solve(Simplex sim) {\n  Simplex sim_copy = sim;\n  assert(sim.solve());\n\n  if (sim.res - 1e-9 < low_bound) { return; }\n  auto vars = sim.getVars();\n\n  if ((clock() - time_start) > 4.85 * CLOCKS_PER_SEC) {\n    cout << low_bound << \"\\n\";\n    exit(0);\n  }\n\n  LL my_low = 0;\n  for (int i = 0; i < N; ++i) {\n    if (vars[i] > .99) {\n      my_low += point_vals[i];\n      //sim_copy.b[M + i * 2] = -1;\n    }\n  }\n\n  maxi(low_bound, my_low);\n\n  bool had_any = false;\n  for (int i = 0; i < N; ++i) {\n    if (vars[i] > .01 && vars[i] < .989) {\n      had_any = true;\n      // take?\n      sim_copy.b[M + i * 2] = -1;\n      Solve(sim_copy);\n      sim_copy.b[M + i * 2] = 0;\n      if (sim.res - 1e-9 < low_bound) { return; }\n    }\n  }\n\n  if (had_any) {\n    // take none?\n    for (int i = 0; i < N; ++i) {\n      if (vars[i] > .01 && vars[i] < .989) {\n        sim_copy.b[M + i * 2 + 1] = 0;\n      }\n    }\n    Solve(sim_copy);\n  }\n}\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n  time_start = clock();\n\n  cin >> N;\n  points.resize(N);\n  point_vals.resize(N);\n\n  for (int i = 0; i < N; ++i) {\n    cin >> points[i].st >> points[i].nd >> point_vals[i];\n  }\n\n  map<char, function<bool(PII, int)>> checkers = {\n    {'L', [](const PII &pt, int a) { return pt.st <= a; }},\n    {'R', [](const PII &pt, int a) { return pt.st >= a; }},\n    {'D', [](const PII &pt, int a) { return pt.nd <= a; }},\n    {'U', [](const PII &pt, int a) { return pt.nd >= a; }}\n  };\n\n  cin >> M;\n\n  Simplex sim(N, M + 2 * N);\n  for (int i = 0; i < M; ++i) {\n    char type;\n    int a, b;\n    cin >> type >> a >> b;\n\n    for (int j = 0; j < N; ++j) {\n      sim.A[i][j] = checkers[type](points[j], a);\n    }\n    sim.b[i] = b;\n\n    debug(sim.A[i], sim.b[i]);\n  }\n  for (int i = 0; i < N; ++i) {\n    sim.c[i] = point_vals[i];\n    sim.A[M + i * 2][i] = -1;\n    sim.A[M + i * 2 + 1][i] = 1;\n    sim.b[M + i * 2] = 0;\n    sim.b[M + i * 2 + 1] = 1;\n  }\n  auto orig_a = sim.A;\n  auto orig_b = sim.b;\n\n  Solve(sim);\n  cout << low_bound << \"\\n\";\n\n  /*assert(sim.solve());\n  auto vars = sim.getVars();\n\n  vector<int> always, maybe;\n  debug(vars);\n  for (int i = 0; i < N; ++i) {\n    if (vars[i] > 0.7) {\n      always.PB(i);\n    } else if (vars[i] > 0.3) {\n      maybe.PB(i);\n    }\n  }\n\n  debug(always, maybe);\n\n  assert(SZ(maybe) <= 3);\n  LL ans = -1;\n\n  for (LL m = 0; m < (1LL << SZ(maybe)); ++m) {\n    vector<int> mine = always;\n    for (int j = 0; j < SZ(maybe); ++j) {\n      if ((m >> j) & 1) { mine.PB(maybe[j]); }\n    }\n\n    bool fail = false;\n    for (int i = 0; i < M; ++i) {\n      int cnt = 0;\n      for (int j : mine) {\n        if (orig_a[i][j] > 0.5) { ++cnt; }\n      }\n      debug(mine, i, cnt, orig_b[i]);\n      if (cnt > (int)round((LD)orig_b[i])) { debug(i); fail = true; }\n    }\n\n    if (fail) { continue; }\n    LL x = 0;\n    for (int i : mine) {\n      x += point_vals[i];\n    }\n    maxi(ans, x);\n  }\n\n  cout << ans << \"\\n\";*/\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// たかが80個の宝石を盗むだけでいちいち捕まるようでは甘え。\n// スライ・クーパーなら今頃探偵に捕まらずに全部回収できてた。\n\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst long double EPS=1e-9;\nconst long double PI=acos(-1.0);\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\nlong double ABS(long double a){return max(a,-a);}\n\n\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tlong long ret=0;\n\tfor(int i=0;i<a;i++){\n\t\tint p,q;\n\t\tlong long r;scanf(\"%d%d%lld\",&p,&q,&r);\n\t\tret+=r;\n\t}printf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cctype>\n#include<iostream>\n#include<queue>\n#define RI register int\n#define CI const int&\nusing namespace std;\nconst int N=350,M=N*N<<1;\nconst long long INF=1e18;\nstruct edge\n{\n\tint to,nxt,v; long long c;\n}e[M<<1]; char opt[N]; long long ans,v[N];\nint n,m,head[N],cnt,x[N],y[N],L[N],R[N],U[N],D[N],a[N],b[N],s,t;\ninline char getch(void)\n{\n\tchar ch; while (!isalpha(ch=getchar())); return ch;\n}\ninline void addedge(CI x,CI y,CI v,const long long& c)\n{\n\te[++cnt]=(edge){y,head[x],v,c}; head[x]=cnt;\n\te[++cnt]=(edge){x,head[y],0,-c}; head[y]=cnt;\n}\n#define to e[i].to\nnamespace NF //Network_Flow\n{\n\tqueue <int> q; int pre[N],lst[N],cap[N]; long long dis[N]; bool vis[N];\n\tinline bool SPFA(CI s,CI t)\n\t{\n\t\tRI i; for (i=s;i<=t;++i) dis[i]=-INF,cap[i]=1e9,pre[i]=-1;\n\t\tpre[s]=0; q.push(s); dis[s]=0; vis[s]=1; while (!q.empty())\n\t\t{\n\t\t\tint now=q.front(); q.pop(); vis[now]=0;\n\t\t\tfor (i=head[now];i;i=e[i].nxt)\n\t\t\tif (e[i].v&&dis[to]<dis[now]+e[i].c)\n\t\t\t{\n\t\t\t\tdis[to]=dis[now]+e[i].c; pre[to]=now; lst[to]=i;\n\t\t\t\tcap[to]=min(cap[now],e[i].v); if (!vis[to]) vis[to]=1,q.push(to);\n\t\t\t}\n\t\t}\n\t\treturn ~pre[t];\n\t}\n\tinline long long MCMF(CI s,CI t)\n\t{\n\t\tlong long ret=0; while (SPFA(s,t))\n\t\t{\n\t\t\tret+=dis[t]*cap[t]; for (int nw=t;nw;nw=pre[nw])\n\t\t\te[lst[nw]].v-=cap[t],e[lst[nw]^1].v+=cap[t];\n\t\t}\n\t\treturn ret;\n\t}\n\tinline void clear(CI n)\n\t{\n\t\tcnt=1; for (RI i=0;i<=n;++i) head[i]=0;\n\t}\n};\n#undef to\ninline long long calc(CI k)\n{\n\tRI i,j; for (i=1;i<=k;++i) L[i]=D[i]=0,R[i]=U[i]=1e9;\n\tfor (NF::clear(2*n+2*k+1),i=1;i<=m;++i) if (b[i]<k) \n\t{\n\t\tif (opt[i]=='L') L[b[i]+1]=a[i]+1;\n\t\tif (opt[i]=='R') R[k-b[i]]=a[i]-1; \n\t\tif (opt[i]=='D') D[b[i]+1]=a[i]+1;\n\t\tif (opt[i]=='U') U[k-b[i]]=a[i]-1; \n\t}\n\tfor (i=2;i<=k;++i) L[i]=max(L[i],L[i-1]),D[i]=max(D[i],D[i-1]);\n\tfor (i=k-1;i;--i) R[i]=min(R[i],R[i+1]),U[i]=min(U[i],U[i+1]);\n\tfor (s=0,t=2*n+2*k+1,i=1;i<=k;++i) addedge(s,i,1,0),addedge(k+2*n+i,t,1,0);\n\tfor (i=1;i<=n;++i) addedge(k+i,k+n+i,1,v[i]);\n\tfor (i=1;i<=k;++i) for (j=1;j<=n;++j)\n\t{\n\t\tif (L[i]<=x[j]&&x[j]<=R[i]) addedge(i,k+j,1,0);\n\t\tif (D[i]<=y[j]&&y[j]<=U[i]) addedge(k+n+j,k+2*n+i,1,0);\n\t}\n\treturn NF::MCMF(s,t);\n}\nint main()\n{\n\tRI i; for (scanf(\"%d\",&n),i=1;i<=n;++i) scanf(\"%d%d%lld\",&x[i],&y[i],&v[i]);\n\tfor (scanf(\"%d\",&m),i=1;i<=m;++i) opt[i]=getch(),scanf(\"%d%d\",&a[i],&b[i]);\n\tfor (i=2;i<=n;++i) ans=max(ans,calc(i)); return printf(\"%lld\",ans),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 100 , M = 400 , V = N + M << 1 , E = N + N * M * 2 + M * 2 , INF = 0x3f3f3f3f;\nint n,m,x[N],y[N],a[N],b[N],u[N],d[N],l[N],r[N]; char op[N];\nint t(1),Head[V],vis[V],S,T; deque <int> q; ll Delta,dis[V],v[N],Ans;\nstruct Edge { int u,v,next,val; ll cos; } e[E*2];\ntemplate<class T> inline T Read(void)\n{\n    T x = 0; bool w = 0; char ch = ' ';\n    while ( !isdigit(ch) ) w |= ch == '-' , ch = getchar();\n    while ( isdigit(ch) ) x = x * 10 + ch - 48 , ch = getchar();\n    return w ? -x : x;\n}\ninline void Input(void)\n{\n    n = Read<int>();\n    for (int i = 1; i <= n; i++)\n        x[i] = Read<int>() , y[i] = Read<int>() , v[i] = Read<ll>();\n    m = Read<int>();\n    for (int i = 1; i <= m; i++)\n    {\n        char c = ' ';\n        while ( isspace(c) ) c = getchar();\n        op[i] = c , a[i] = Read<int>() , b[i] = Read<int>();\n    }\n}\ninline void Insert(int x,int y,ll c,int v)\n{\n    e[++t] = (Edge){ x , y , Head[x] , v , c } , Head[x] = t;\n    e[++t] = (Edge){ y , x , Head[y] , 0 , -c } , Head[y] = t;\n}\ninline void Build(int k)\n{\n    for (int i = 1; i <= k; i++)\n        u[i] = r[i] = INF , l[i] = d[i] = 0;\n    for (int i = 1; i <= m; i++)\n        if ( b[i] < k )\n        {\n            // if ( op[i] == 'L' ) l[b[i]+1] = max( l[b[i]+1] , a[i] + 1 );\n            // if ( op[i] == 'R' ) r[k-b[i]] = min( r[k-b[i]] , a[i] - 1 );\n            // if ( op[i] == 'D' ) d[b[i]+1] = max( d[b[i]+1] , a[i] + 1 );\n            // if ( op[i] == 'U' ) u[k-b[i]] = min( u[k-b[i]] , a[i] - 1 );\n            if ( op[i] == 'L' ) l[b[i]+1] = a[i] + 1;\n            if ( op[i] == 'R' ) r[k-b[i]] = a[i] - 1;\n            if ( op[i] == 'D' ) d[b[i]+1] = a[i] + 1;\n            if ( op[i] == 'U' ) u[k-b[i]] = a[i] - 1;\n        }\n    for (int i = 2; i <= k; i++) l[i] = max( l[i] , l[i-1] ) , d[i] = max( d[i] , d[i-1] );\n    for (int i = k-1; i >= 1; i--) r[i] = min( r[i] , r[i+1] ) , u[i] = min( u[i] , u[i+1] );\n    memset( Head , 0 , sizeof Head );\n    S = ( n + k ) << 1 | 1 , T = ( n + k + 1 ) * 2 , t = 1 , Delta = 0;\n    for (int i = 1; i <= n; i++) Insert( i , i+n , v[i] , 1 );\n    for (int i = 1; i <= k; i++)\n    {\n        Insert( S , n*2+i , 0 , 1 ) , Insert( n*2+k+i , T , 0 , 1 );\n        for (int j = 1; j <= n; j++)\n        {\n            if ( l[i] <= x[j] && x[j] <= r[i] ) Insert( n*2+i , j , 0 , 1 );\n            if ( d[i] <= y[j] && y[j] <= u[i] ) Insert( j+n , n*2+k+i , 0 , 1 );\n        }\n    }\n    // printf( \"t = %d\\n\" , t );\n}\ninline bool Relabel(void)\n{\n    memset( dis , 0xcf , sizeof dis );\n    memset( vis , 0x00 , sizeof vis );\n    dis[T] = 0 , vis[T] = 1 , q.push_back(T);\n    while ( !q.empty() )\n    {\n        // puts(\"SPFAing\");\n        int x = q.front(); q.pop_front() , vis[x] = 0;\n        if ( q.size() > 1 && dis[q.front()] < dis[q.back()] )\n            swap( q.front() , q.back() );\n        for (int i = Head[x] , y; i; i = e[i].next)\n            if ( e[i^1].val && dis[ y = e[i].v ] < dis[x] + e[i^1].cos )\n            {\n                dis[y] = dis[x] + e[i^1].cos;\n                // printf( \"dis[%d] = %lld\\n\" , y , dis[y] );\n                if ( vis[y] ) continue;\n                vis[y] = true , q.push_back(y);\n                if ( q.size() > 1 && dis[q.front()] < dis[q.back()] )\n                    swap( q.front() , q.back() );\n            }\n    }\n    // printf( \"d[%d] = %lld\\n\" , S , dis[S] );\n    return dis[S] != dis[0];\n}\ninline int Dinic(int x,int flow)\n{\n    if ( x == T || !flow ) return flow;\n    int residue = flow; vis[x] = true;\n    for (int i = Head[x] , y; i; i = e[i].next)\n        if ( e[i].val && !vis[ y = e[i].v ] && !e[i].cos )\n        {\n            int k = Dinic( y , min( e[i].val , residue ) );\n            e[i].val -= k , e[i^1].val += k;\n            if ( ( residue -= k ) == 0 ) break;\n        }\n    return flow - residue;\n}\ninline pair<int,ll> PrimalDual(void)\n{\n    int Maxflow = 0 , Flow = 0; ll Maxcost = 0;\n    while ( Relabel() )\n    {\n        for (int i = 2; i <= t; i++)\n            e[i].cos += dis[e[i].v] - dis[e[i].u];\n        Delta += dis[S] , memset( vis , 0 , sizeof vis );\n        // printf( \"Delta = %lld\\n\" , Delta );\n        while ( Flow = Dinic( S , INF ) )\n            Maxflow += Flow , Maxcost += 1LL * Flow * Delta ,\n            memset( vis , 0 , sizeof vis ) /*, printf( \"Dinicing Flow = %d\\n\" , Flow ) */;\n    }\n    return make_pair( Maxflow , Maxcost );\n}\nint main(void)\n{\n    Input();\n    for (int i = 1; i <= n; i++)\n        Build(i) , Ans = max( Ans , PrimalDual().second );\n    printf( \"%lld\\n\" , Ans );\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n#define LL long long\n#define fgx cerr<<\"--------------\"<<endl;\n#define dgx cerr<<\"==============\"<<endl;\n\ninline LL read(){\n\tLL x=0,f=1; char c=getchar();\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0';\n\treturn x*f;\n}\nconst LL MAXN = 500010;\nconst LL INF = 1e16;\n\nLL N; LL d[2][MAXN+1],V[MAXN+1];\nLL Cost[MAXN+1]; LL Node[MAXN+1],Next[MAXN+1],C[MAXN+1],Root[MAXN+1];\nLL cnt; LL S,T;\ninline void addedge(LL u,LL v,LL c,LL w){ Cost[cnt]=w; C[cnt]=c; Node[cnt]=v; Next[cnt]=Root[u]; Root[u]=cnt++; }\ninline void insert(LL u,LL v,LL c,LL w){ w=-w; addedge(u,v,c,w); addedge(v,u,0,-w); return ; }\nLL dis[MAXN+1]; bool inq[MAXN+1];\nLL ans,ret;\ninline bool BFS(){\n\tdeque<LL> que; for(LL i=0;i<=T;i++) dis[i]=INF,inq[i]=0;\n\tdis[T]=0; que.push_back(T); inq[T]=true;\n\tint td=0;\n\twhile(!que.empty()){\n\t    LL k=que.front(); que.pop_front(); ++td;\n\t\tfor(LL x=Root[k];x!=-1;x=Next[x]){\n\t\t    LL v=Node[x];\n\t\t    if(C[x^1]>0&&dis[v]>dis[k]-Cost[x]){\n\t\t        dis[v]=dis[k]-Cost[x];\n\t\t\t\tif(!inq[v]){\n\t\t\t\t\tinq[v]=true;\n\t\t\t\t    if(que.empty()||dis[v]<=dis[que.front()]) que.push_front(v);\n\t\t\t\t    else que.push_back(v);\n\t\t\t    }\n\t\t    }\n\t    }inq[k]=false;\n\t}  return dis[S]<INF;\n} LL fans;\ninline LL DFS(LL k,LL t){\n    if(k==T) {inq[k]=1;return t;} \n\tinq[k]=1; LL res=0;\n\tfor(LL x=Root[k];x!=-1;x=Next[x]){\n\t    LL v=Node[x];\n\t    if(C[x]>0&&!inq[v]&&dis[v]==dis[k]-Cost[x]){\n\t        LL tmp=DFS(v,min(t,C[x]));\n\t\t\tif(!tmp) continue; C[x]-=tmp; C[x^1]+=tmp;\n\t\t\tres+=tmp; t-=tmp; fans+=(LL)tmp*Cost[x]; if(!t) return res;\t\n\t    }\n    } return res;\n}\n#define fr first\n#define sc second\ninline void Max(LL &a,LL b){ a=max(a,b); }\ninline void Min(LL &a,LL b){ a=min(a,b); }\nLL L[2][MAXN+1],R[2][MAXN+1];\nLL M; char ch[5];\nvector<pair<LL,LL> > vec[4];\nint sta[MAXN+1],sta2[MAXN+1],sta3[MAXN+1];\ninline void check(LL K){\n\tfor(LL i=0;i<=K+1;i++) L[0][i]=L[1][i]=1,R[0][i]=R[1][i]=100; cnt=0;\n\tfor(LL i=0;i<=N*2+2*K+1;i++) Root[i]=-1;\n\tfor(LL i=0,l=vec[0].size();i<l;i++) Max(L[0][vec[0][i].fr+1],vec[0][i].sc+1);\n\tfor(LL i=0,l=vec[1].size();i<l;i++) if(vec[1][i].fr<K) Min(R[0][K-vec[1][i].fr],vec[1][i].sc-1);\n\tfor(LL i=0,l=vec[2].size();i<l;i++) Max(L[1][vec[2][i].fr+1],vec[2][i].sc+1);\n\tfor(LL i=0,l=vec[3].size();i<l;i++) if(vec[3][i].fr<K) Min(R[1][K-vec[3][i].fr],vec[3][i].sc-1);\n\tS=0,T=N*2+K*2+1; int top=0,top2=0,top3=0;\n\tfor(LL i=1;i<=N;i++) insert(i,N+i,1,V[i]),sta[++top]=cnt-2;\n\tfor(LL i=0;i<2;i++){\n\t\tfor(LL j=1;j<=K;j++) L[i][j]=max(L[i][j],L[i][j-1]);\n\t\tfor(LL j=K-1;j>=0;j--) R[i][j]=min(R[i][j],R[i][j+1]);\n\t\tfor(LL j=1;j<=K;j++){\n\t\t\tif(!i) insert(S,N*2+j,1,0),sta2[++top2]=cnt-2;\n\t\t\telse insert(N*2+K+j,T,1,0),sta3[++top3]=cnt-2;\n\t\t\t\n\t\t\t\t\t//if(K==5&&!i) cout<<\"gg:\"<<L[i][j]<<\" \"<<R[i][j]<<endl;\n\t\t\tfor(LL k=1;k<=N;k++){\n\t\t\t\tif(d[i][k]>=L[i][j]&&d[i][k]<=R[i][j]){\n\t\t\t\t\tif(K==5&&!i&&j==5) cout<<k<<endl;\n\t\t\t\t\tif(!i) insert(N*2+j,k,1,0);\n\t\t\t\t\telse insert(N+k,N*2+K+j,1,0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} fans=0;\n\tret=0; while(BFS()) ret+=DFS(S,INF);\n\tans=max(ans,-fans); //cout<<-fans<<\" \"<<ret<<\" \"<<K<<endl;\n\t//for(int i=1;i<=top;i++) cout<<C[sta[i]]<<\" \"; cout<<endl; for(int i=1;i<=top2;i++) cout<<C[sta2[i]]<<\" \"; cout<<endl;for(int i=1;i<=top3;i++) cout<<C[sta3[i]]<<\" \"; cout<<endl; \n\t return ; \n}\n\nint main(){\n\t//freopen(\"a.in\",\"r\",stdin);\n\t//freopen(\"a2.out\",\"w\",stdout);\n\tN=read();\n\tmemset(Root,-1,sizeof(Root));\n\tfor(LL i=1;i<=N;i++){\n\t\td[0][i]=read(),d[1][i]=read(),V[i]=read();\n\t} M=read();\n\tfor(LL i=1;i<=M;i++){\n\t\tscanf(\"%s\",ch+1); LL a=read(),b=read();\n\t\tLL opr; if(ch[1]=='L') opr=0;\n\t\telse if(ch[1]=='R') opr=1;\n\t\telse if(ch[1]=='U') opr=3;\n\t\telse opr=2; vec[opr].push_back(make_pair(b,a));\n\t}\n\tfor(LL i=0;i<4;i++) sort(vec[i].begin(),vec[i].end());\n\tfor(LL K=1;K<=N;K++) check(K);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\nusing namespace std;\ntypedef long long ll;\nconst ll N=1e4+10,inf=1e18;\nll w[N],ne[N],la[N],len[N],cst[N],t=1;\nll d[N],dep[N],s[N],ans,S,T,vis[N],cur[N];\nvoid alink(ll x,ll y,ll z,ll l){\n\tw[++t]=y;\n\tne[t]=la[x];\n\tla[x]=t;\n\tlen[t]=z;\n\tcst[t]=l;\n}\nvoid link(ll x,ll y,ll z,ll l){\n\talink(x,y,z,l);\n\talink(y,x,0,-l);\n}\nvoid clear(){\n\tfor (ll i=1;i<=T;i++)la[i]=0;\n\tt=1;\n}\nll spfa(){\n\tfor (ll i=1;i<=T;i++)s[i]=-inf,vis[i]=0;\n\tll l=0,r=1;\n\ts[S]=0,d[1]=S,vis[S]=1;\n\twhile (l<r){\n\t\tll x=d[++l];\n\t\tfor (ll y=la[x];y;y=ne[y]){\n\t\t\tll z=w[y];\n\t\t\tif (s[z]<s[x]+cst[y]&&len[y]){\n\t\t\t\ts[z]=s[x]+cst[y];\n\t\t\t\tif (!vis[z]){\n\t\t\t\t\td[++r]=z;\n\t\t\t\t\tvis[z]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvis[x]=0;\n\t}\n\tl=0,r=1;vis[S]=1;\n\twhile (l<r){\n\t\tll x=d[++l];\n\t\tcur[x]=la[x];\n\t\tfor (ll y=la[x];y;y=ne[y]){\n\t\t\tll z=w[y];\n\t\t\tif (s[z]==s[x]+cst[y]&&len[y]&&!vis[z]){\n\t\t\t\tdep[z]=dep[x]+1;\n\t\t\t\tvis[z]=1;\n\t\t\t\td[++r]=z;\n\t\t\t}\n\t\t}\n\t}\n\treturn vis[T];\n}\nll flow(ll x,ll val){\n\tif (x==T)return val;\n\tll v1=val;\n\tfor (ll y=cur[x];y;cur[x]=y=ne[y]){\n\t\tll z=w[y];\n\t\tif (dep[z]!=dep[x]+1||!len[y]||s[z]!=s[x]+cst[y])continue;\n\t\tll use=flow(z,min(len[y],val));\n\t\tval-=use;\n\t\tlen[y]-=use;\n\t\tlen[y^1]+=use;\n\t\tans+=use*cst[y];\n\t\tif (!val)return v1;\n\t}return v1-val;\n}\nll n,px[N],py[N],val[N];\nll L[N],R[N],U[N],D[N];\nll ty[N],lim[N],lc[N],k;\nll z1[N],z2[N],c1[N],c2[N];\nint main(){\n\tcin>>n;\n\tfor (ll i=1;i<=n;i++)scanf(\"%lld%lld%lld\",&px[i],&py[i],&val[i]);\n\tcin>>k;\n\tfor (ll i=1;i<=k;i++){\n\t\tscanf(\"\\n\");\n\t\tty[i]=getchar();\n\t\tscanf(\"%lld%lld\",&lc[i],&lim[i]);\n\t}\n\tt=0;\n\tfor (ll i=1;i<=n;i++)\n\t\tz1[i]=++t,z2[i]=++t,L[i]=0,R[i]=100,U[i]=100,D[i]=0,c1[i]=++t,c2[i]=++t;\n\tS=++t,T=++t;t=1;\n\tll max1=0;\n\tfor (ll K=1;K<=n;K++){\n\t\tfor (ll i=1;i<=n;i++)\n\t\t\tL[i]=0,R[i]=100,U[i]=100,D[i]=0;\n\t\tans=0;clear();\n\t\tfor (ll i=1;i<=k;i++){\n\t\t\tif (ty[i]=='L'){\n\t\t\t\tfor (ll j=lim[i]+1;j<=K;j++)\n\t\t\t\t\tL[j]=max(L[j],lc[i]+1);\n\t\t\t}\n\t\t\tif (ty[i]=='R'){\n\t\t\t\tfor (ll j=1;j<=K-lim[i];j++)\n\t\t\t\t\tR[j]=min(R[j],lc[i]-1);\n\t\t\t}\n\t\t\tif (ty[i]=='U'){\n\t\t\t\tfor (ll j=1;j<=K-lim[i];j++)\n\t\t\t\t\tU[j]=min(U[j],lc[i]-1);\n\t\t\t}\n\t\t\tif (ty[i]=='D'){\n\t\t\t\tfor (ll j=lim[i]+1;j<=K;j++)\n\t\t\t\t\tD[j]=max(D[j],lc[i]+1);\n\t\t\t}\n\t\t}\n\t\tfor (ll i=1;i<=K;i++)link(S,z1[i],1,0),link(z2[i],T,1,0);\n\t\tfor (ll i=1;i<=K;i++){\n\t\t\tfor (ll j=1;j<=n;j++){\n\t\t\t\tif (L[i]<=px[j]&&px[j]<=R[i])\n\t\t\t\t\tlink(z1[i],c1[j],1,0);\n\t\t\t\tif (D[i]<=py[j]&&py[j]<=U[i])\n\t\t\t\t\tlink(c2[j],z2[i],1,0);\n\t\t\t}\n\t\t}\n\t\tfor (ll i=1;i<=n;i++)link(c1[i],c2[i],1,val[i]);\n\t\twhile (spfa()){\n\t\t\tif (s[T]>0)flow(S,1<<30);\n\t\t\telse break;\n\t\t}\n\t\tmax1=max(max1,ans);\n\t}\n\tcout<<max1<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint N, M, x[100], y[100], x_code[100], y_code[100], in_code[100], out_code[100], lX[100], lY[100], rX[100], rY[100], lim[100], coord[100];\nlong long v[100];\nchar type[100];\nconst long long INF = 1LL << 60;\n\nclass maxFlowMinCut\n{\npublic:\n    int S, D, N, t[300], c[300][300], f[300][300];\n    bool inQ[300];\n    long long d[300], bani[300][300];\n    vector < int > v[300];\n\n    void addEdge (int x, int y, int cap, long long ban)\n    {\n        c[x][y] = cap, c[y][x] = 0;\n        bani[x][y] = ban, bani[y][x] = -ban;\n        v[x].push_back (y);\n        v[y].push_back (x);\n    }\n\n    bool bellman ()\n    {\n        queue < int > cc;\n        for (int i=1; i<=N; i++)\n            t[i] = -1, d[i] = INF, inQ[i] = 0;\n        t[S] = 0, d[S] = 0, inQ[S] = 1;\n        cc.push (S);\n        while (!cc.empty ())\n        {\n            int nod = cc.front ();\n            cc.pop (), inQ[nod] = 0;\n            for (auto it : v[nod])\n                if (c[nod][it] > f[nod][it] && d[nod] + bani[nod][it] < d[it])\n                {\n                    d[it] = d[nod] + bani[nod][it];\n                    t[it] = nod;\n                    if (!inQ[it])\n                        inQ[it] = 1,\n                        cc.push (it);\n                }\n        }\n        return (d[D] < INF);\n    }\n\n    pair < int, long long > minCostMaxFlow ()\n    {\n        int cap = 0;\n        long long ban = 0;\n        while (bellman ())\n        {\n            int minC = 1e9;\n            for (int i=D; i != S; i = t[i])\n                minC = min (minC, c[t[i]][i] - f[t[i]][i]);\n            for (int i=D; i != S; i = t[i])\n                f[t[i]][i] += minC,\n                f[i][t[i]] -= minC;\n            cap += minC, ban += 1LL * minC * d[D];\n        }\n        return {cap, ban};\n    }\n\n    void clear ()\n    {\n        for (int i=1; i<=N; i++)\n        {\n            for (auto j : v[i])\n                c[i][j] = c[j][i] = 0,\n                f[i][j] = f[j][i] = 0,\n                bani[i][j] = bani[j][i] = 0LL;\n            v[i].clear ();\n        }\n        S = D = N = 0;\n    }\n}net;\n\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nscanf (\"%d\", &N);\nfor (int i=1; i<=N; i++)\n    scanf (\"%d %d %lld\", &x[i], &y[i], &v[i]);\nscanf (\"%d\\n\", &M);\nfor (int i=1; i<=M; i++)\n    scanf (\"%c %d %d\\n\", &type[i], &coord[i], &lim[i]);\nlong long best = 0;\nfor (int K=1; K<=N; K++)\n{\n    net.clear (), net.S = 1, net.D = net.N = 2;\n    for (int i=1; i<=K; i++)\n        x_code[i] = ++net.N,\n        net.addEdge (net.S, x_code[i], 1, 0);\n    for (int i=1; i<=N; i++)\n        in_code[i] = ++net.N,\n        out_code[i] = ++net.N,\n        net.addEdge (in_code[i], out_code[i], 1, -v[i]);\n    for (int i=1; i<=K; i++)\n        y_code[i] = ++net.N,\n        net.addEdge (y_code[i], net.D, 1, 0);\n    for (int i=1; i<=K; i++)\n        lX[i] = lY[i] = 0,\n        rX[i] = rY[i] = 200;\n    for (int i=1; i<=M; i++)\n    {\n        if (type[i] == 'L' && lim[i] < K) lX[lim[i] + 1] = max (lX[lim[i] + 1], coord[i] + 1);\n        if (type[i] == 'R' && lim[i] < K) rX[K - lim[i]] = min (rX[K - lim[i]], coord[i] - 1);\n        if (type[i] == 'D' && lim[i] < K) lY[lim[i] + 1] = max (lY[lim[i] + 1], coord[i] + 1);\n        if (type[i] == 'U' && lim[i] < K) rY[K - lim[i]] = min (rY[K - lim[i]], coord[i] - 1);\n    }\n    for (int i=2; i<=K; i++)\n        lX[i] = max (lX[i], lX[i - 1]),\n        lY[i] = max (lY[i], lY[i - 1]);\n    for (int i=K - 1; i>=1; i--)\n        rX[i] = min (rX[i], rX[i + 1]),\n        rY[i] = min (rY[i], rY[i + 1]);\n    for (int i=1; i<=K; i++)\n        for (int j=1; j<=N; j++)\n        {\n            if (lX[i] <= x[j] && x[j] <= rX[i])\n                net.addEdge (x_code[i], in_code[j], 1, 0);\n            if (lY[i] <= y[j] && y[j] <= rY[i])\n                net.addEdge (out_code[j], y_code[i], 1, 0);\n        }\n/*    for (int i=1; i<=N; i++)\n        if (i == 1 || (5 <= i && i <= 7))\n            printf (\"%d %d\\n\", x[i], y[i]);\n    for (int i=1; i<=K; i++)\n        printf (\"[%d %d] [%d %d]\\n\", lX[i], rX[i], lY[i], rY[i]);*/\n    auto ans = net.minCostMaxFlow ();\n    //printf (\"%d -> %lld\\n\", ans.first, -ans.second);\n    if (ans.first != K)\n        break;\n    if (-ans.second > best)\n        best = -ans.second;\n}\nprintf (\"%lld\\n\", best);\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace __gnu_pbds;\nusing namespace std;\n \ntemplate <typename T>\nusing ordered_set =\n\ttree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n \n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n\t*this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n \n#define shandom_ruffle random_shuffle\n \nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=327;\nusing bn=bitset<87>;\n\nint n;\npii gdz[nax];\nll war[nax];\n\nint m;\nbn podz[nax];\nint ile[nax];\n\nll wyn;\n\nbn ter;\n\nll dajwar()\n{\n\tll ret=0;\n\tfor (int i=1; i<=n; i++)\n\t\tif (ter[i])\n\t\t\tret+=war[i];\n\treturn ret;\n}\n\nint popr()\n{\n\tfor (int i=1; i<=m; i++)\n\t\tif ((podz[i]&ter).count()>ile[i])\n\t\t\treturn 0;\n\treturn 1;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(\"%d%d%lld\", &gdz[i].first, &gdz[i].second, &war[i]);\n\tscanf(\"%d\", &m);\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\tchar c;\n\t\tint a, b;\n\t\tscanf(\" %c%d%d\", &c, &a, &b);\n\t\tfor (int j=1; j<=n; j++)\n\t\t{\n\t\t\tif (c=='L' && gdz[j].first<=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='R' && gdz[j].first>=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='D' && gdz[j].second<=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='U' && gdz[j].second>=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t}\n\t\tile[i]=b;\n\t}\n\tll sta=0;\n\tconst int czes=5e5;\n\tconst int res=7e4;\n\tfor (int h=0; h%czes || (clock()<=4.5*CLOCKS_PER_SEC); h++)\n\t{\n\t\tif (!(rand()%res))\n\t\t{\n\t\t\tter.reset();\n\t\t\tvi kol(n);\n\t\t\tiota(kol.begin(), kol.end(), 1);\n\t\t\tshandom_ruffle(kol.begin(), kol.end());\n\t\t\tfor (int i : kol)\n\t\t\t{\n\t\t\t\tter[i]=1;\n\t\t\t\tif (!popr())\n\t\t\t\t\tter[i]=0;\n\t\t\t}\n\t\t\tsta=dajwar();\n\t\t\twyn=max(wyn, sta);\n\t\t}\n\t\tbn pam=ter;\n\t\tint r=rand()%2+1;\n\t\tfor (int i=0; i<r; i++)\n\t\t\tter.flip(rand()%n+1);\n\t\tif (!popr())\n\t\t{\n\t\t\tter=pam;\n\t\t\tcontinue;\n\t\t}\n\t\tll now=dajwar();\n\t\tif (now>=sta || !(rand()%5000))\n\t\t{\n\t\t\tsta=now;\n\t\t\twyn=max(wyn, now);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tter=pam;\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\\n\", wyn);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define fst first\n#define snd second\n#define SZ(u) ((int) (u).size())\n#define ALL(u) (u).begin(), (u).end()\n\ninline void proc_status()\n{\n\tifstream t(\"/proc/self/status\");\n\tcerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate<typename T> inline T read()\n{\n\tregister T sum(0), fg(1);\n\tregister char ch(getchar());\n\tfor(; !isdigit(ch); ch = getchar()) if(ch == '-') fg = -1;\n\tfor(;  isdigit(ch); ch = getchar()) sum = sum * 10 - '0' + ch;\n\treturn sum * fg;\n}\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\nconst int MAXN = 80, MAXM = 320;\n\nstruct point\n{\n\tint x, y;\n\tLL w;\n\n\tpoint() { }\n\tpoint(int _x, int _y, LL _w): x(_x), y(_y), w(_w) { }\n};\n\nint n, m;\n\npoint A[MAXN + 5];\n\nstruct lim\n{\n\tint l, r;\n\n\tlim() { }\n\tlim(int _l, int _r): l(_l), r(_r) { }\n};\n\nint l0[MAXN + 5], r0[MAXN + 5], l1[MAXN + 5], r1[MAXN + 5];\n\ninline char safe_getchar()\n{\n\tregister char ch(getchar());\n\twhile(!isupper(ch)) ch = getchar();\n\treturn ch;\n}\n\ninline void input()\n{\n\tn = read<int>();\n\tfor(int i = 1; i <= n; ++i) A[i].x = read<int>(), A[i].y = read<int>(), A[i].w = read<LL>();\n\n\tm = read<int>();\n\tfor(int i = 1; i <= n; ++i) l0[i] = l1[i] = 0, r0[i] = r1[i] = 101;\n\tfor(int i = 1; i <= m; ++i)\n\t{\n\t\tchar type = safe_getchar();\n\t\tint a = read<int>(), b = read<int>();\n\t\tif(type == 'L') chkmax(l0[b + 1], a);\n\t\telse if(type == 'R') chkmin(r0[b + 1], a);\n\t\telse if(type == 'D') chkmax(l1[b + 1], a);\n\t\telse if(type == 'U') chkmin(r1[b + 1], a);\n\t\telse assert(0);\n\t}\n}\n\nnamespace FLOW\n{\n\tconst int MAXV = MAXN * 4 + 2;\n\tconst int MAXE = MAXN * MAXN * 2 + MAXN * 3;\n\n\tstruct edge\n\t{\n\t\tint adj, nxt, c;\n\t\tLL w;\n\n\t\tedge() { }\n\t\tedge(int _adj, int _nxt, int _c, LL _w): adj(_adj), nxt(_nxt), c(_c), w(_w) { }\n\t};\n\n\tedge e[MAXE * 2 + 5];\n\tint st[MAXV + 5], edge_cnt;\n\n\tinline void real_add_edge(int u, int v, int c, LL w, int type = 1)\n\t{\n\t\te[edge_cnt] = edge(v, st[u], c, w), st[u] = edge_cnt++;\n\t\tif(type) real_add_edge(v, u, 0, -w, 0);\n\t}\n\n\tinline void init(int N)\n\t{\n\t\tfor(int i = 1; i <= N; ++i) st[i] = -1;\n\t\tedge_cnt = 0;\n\t}\n\n\tnamespace cache\n\t{\n\t\tstruct EDGE\n\t\t{\n\t\t\tint u, v, c;\n\t\t\tLL w;\n\n\t\t\tEDGE() { }\n\t\t\tEDGE(int _u, int _v, int _c, LL _w): u(_u), v(_v), c(_c), w(_w) { }\n\t\t};\n\n\t\tEDGE stk[MAXE + 5];\n\t\tint top = 0;\n\t}\n\n\tinline void add_edge(int u, int v, int c, LL w)\n\t{\n\t\tusing namespace cache;\n\t\tstk[++top] = EDGE(u, v, c, w);\n\t}\n\n\tinline void build_graph(int N)\n\t{\n\t\tinit(N);\n\t\tusing namespace cache;\n\n\t\twhile(top > 0) real_add_edge(stk[top].u, stk[top].v, stk[top].c, stk[top].w), --top;\n\t}\n\n\tconst LL INF = LLONG_MAX / 2;\n\n\tint cur[MAXV + 5];\n\tLL d[MAXV + 5];\n\n\tinline LL SPFA(int S, int T, int N)\n\t{\n\t\tstatic queue<int> q;\n\t\tstatic int inq[MAXV + 5];\n\t\tfor(int i = 1; i <= N; ++i) inq[i] = 0, d[i] = -INF;\n\n\t\td[S] = 0, q.push(S);\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tint u = q.front();\n\t\t\tinq[u] = 0, q.pop();\n\t\t\tcur[u] = st[u];\n\n\t\t\tfor(int i = st[u]; ~i; i = e[i].nxt)\n\t\t\t{\n\t\t\t\tint v = e[i].adj;\n\t\t\t\tif(e[i].c > 0 && chkmax(d[v], d[u] + e[i].w) && !inq[v]) inq[v] = 1, q.push(v);\n\t\t\t}\n\t\t}\n\n\t\treturn d[T];\n\t}\n\n\tint vis[MAXV + 5];\n\n\tinline int dfs(int u, int T, int low)\n\t{\n\t\tif(u == T) return low;\n\n\t\tvis[u] = 1;\n\t\tint sum = 0;\n\t\tfor(int k, &i = cur[u]; ~i; i = e[i].nxt)\n\t\t{\n\t\t\tint v = e[i].adj;\n\t\t\tif(!vis[v] && d[v] == d[u] + e[i].w && e[i].c > 0 && (k = dfs(v, T, min(low, e[i].c))) > 0)\n\t\t\t{\n\t\t\t\te[i].c -= k;\n\t\t\t\te[i ^ 1].c += k;\n\t\t\t\tlow -= k;\n\t\t\t\tsum += k;\n\t\t\t\tif(low == 0) { vis[u] = 0; return sum; }\n\t\t\t}\n\t\t}\n\t\tvis[u] = 0;\n\t\treturn sum;\n\t}\n\n\tinline pair<int, LL> solve(int S, int T, int N)\n\t{\n\t\tbuild_graph(N);\n\n\t\tint flow = 0;\n\t\tLL sum = 0;\n\t\tfor(LL cost; (cost = SPFA(S, T, N)) != -INF; )\n\t\t\tfor(int k; (k = dfs(S, T, INT_MAX)) > 0; )\n\t\t\t{\n\t\t\t\tflow += k;\n\t\t\t\tsum += cost * k;\n\t\t\t}\n\t\treturn mp(flow, sum);\n\t}\n}\n\ninline void solve()\n{\n\tLL ans = 0;\n\tfor(int k = 1; k <= n; ++k)\n\t{\n\t\tstatic int X[MAXN + 5], Y[MAXN + 5];\n\n\t\tint cnt = 0, S = 0, T = 0;\n\t\tS = ++cnt, T = ++cnt;\n\t\tfor(int i = 1; i <= k; ++i)\n\t\t{\n\t\t\tX[i] = ++cnt, Y[i] = ++cnt;\n\t\t\tFLOW::add_edge(S, X[i], 1, 0);\n\t\t\tFLOW::add_edge(Y[i], T, 1, 0);\n\t\t}\n\n\t\tstatic pii p[MAXN + 5], q[MAXN + 5];\n\n\t\tfor(int i = 1; i <= k; ++i) p[i] = q[i] = mp(0, 101);\n\t\tfor(int i = 1; i <= k; ++i)\n\t\t{\n\t\t\tchkmax(p[i].fst, l0[i]);\n\t\t\tchkmin(p[i].snd, r0[k - i + 1]);\n\t\t\tchkmax(q[i].fst, l1[i]);\n\t\t\tchkmin(q[i].snd, r1[k - i + 1]);\n\t\t}\n\t\tfor(int i = 2; i <= k; ++i)\n\t\t{\n\t\t\tchkmax(p[i].fst, p[i - 1].fst);\n\t\t\tchkmax(q[i].fst, q[i - 1].fst);\n\t\t}\n\t\tfor(int i = k - 1; i >= 1; --i)\n\t\t{\n\t\t\tchkmin(p[i].snd, p[i + 1].snd);\n\t\t\tchkmin(q[i].snd, q[i + 1].snd);\n\t\t}\n\n\t\tstatic int in[MAXN + 5], out[MAXN + 5];\n\n\t\tfor(int i = 1; i <= n; ++i)\n\t\t{\n\t\t\tin[i] = ++cnt, out[i] = ++cnt;\n\t\t\tFLOW::add_edge(in[i], out[i], 1, A[i].w);\n\t\t\tfor(int j = 1; j <= k; ++j) if(p[j].fst < A[i].x && A[i].x < p[j].snd) FLOW::add_edge(X[j], in[i], 1, 0);\n\t\t\tfor(int j = 1; j <= k; ++j) if(q[j].fst < A[i].y && A[i].y < q[j].snd) FLOW::add_edge(out[i], Y[j], 1, 0);\n\t\t}\n\n\t\tauto res = FLOW::solve(S, T, cnt);\n\t\tif(res.fst == k) chkmax(ans, res.snd);\n\t}\n\n\tprintf(\"%lld\\n\", ans);\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n//\tfreopen(\"E.in\", \"r\", stdin);\n//\tfreopen(\"E.out\", \"w\", stdout);\n#endif\n\n\tinput();\n\tsolve();\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=505,M=50005,R=100;\nconst ll inf=0x3f3f3f3f3f3f3f3fll;\nint read(){\n\tint f=1,g=0;\n\tchar ch=getchar();\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-') f=-1;\n\tfor (;isdigit(ch);ch=getchar()) g=g*10+ch-'0';\n\treturn f*g;\n}\nvoid chkmax(int &x,int y){if (x<y) x=y;}\nvoid chkmin(int &x,int y){if (x>y) x=y;}\nint n,m;\nstruct jew{int x,y;ll w;}a[N];\nstruct node{char typ;int x,r;}b[N];\nll cost,ans;\nint S,T,cnt,fir[N],fr[N],siz;\nstruct edge{int u,v;ll w;int fl,nex;}e[M];\nvoid add(int u,int v,ll w,int fl){\n\te[++siz]=(edge){u,v,w,fl,fir[u]};fir[u]=siz;\n\te[++siz]=(edge){v,u,-w,0,fir[v]};fir[v]=siz;\n}\nll dist[N];int que[N*50];bool inq[N];\nvoid dec(int x,int fl){e[x].fl-=fl;e[x^1].fl+=fl;}\nbool spfa(){\n\tmemset(dist,-1,8*(cnt+1));\n\tmemset(inq,0,cnt+1);\n\tint l=1,r=1;que[l]=S;dist[S]=0;inq[S]=1;\n\twhile (l<=r){\n\t\tint x=que[l];\n\t\tfor (int i=fir[x];i;i=e[i].nex)\n\t\tif ((e[i].fl)&&(dist[e[i].v]<dist[x]+e[i].w)){\n\t\t\tif (!inq[e[i].v]) {que[++r]=e[i].v;inq[e[i].v]=1;}\n\t\t\tdist[e[i].v]=dist[x]+e[i].w;fr[e[i].v]=i;\n\t\t}\n\t\tinq[x]=0;l++;\n\t}\n\treturn dist[T]>0;\n}\nint update(){\n\tint t=0x3f3f3f3f;\n\tfor (int i=fr[T];i;i=fr[e[i].u]) t=min(t,e[i].fl);\n\tcost+=t*dist[T];\n\tfor (int i=fr[T];i;i=fr[e[i].u]) dec(i,t);\n\treturn t;\n}\nint dinic(){\n\tint flow=0;\n\twhile (spfa()) flow+=update();\n\treturn flow;\n}\nint ml[N],mr[N],mu[N],md[N];\nvoid calc(int L){\n\tmemset(fir,0,sizeof(fir));siz=1;\n\tS=0;T=cnt=L*2+R*2+1;\n\tfor (int i=1;i<=n;i++) add(a[i].x,a[i].y+R,a[i].w,1);\n\tfor (int i=1;i<=L;i++) {ml[i]=mu[i]=1,mr[i]=md[i]=R;add(S,R*2+i,0,1);add(R*2+L+i,T,0,1);}\n\tfor (int i=1;i<=m;i++)\n\tif (b[i].r>=L) continue;\n\telse if (b[i].typ=='L') chkmax(ml[b[i].r+1],b[i].x+1);\n\telse if (b[i].typ=='R') chkmin(mr[L-b[i].r],b[i].x-1);\n\telse if (b[i].typ=='D') chkmax(mu[b[i].r+1],b[i].x+1);\n\telse if (b[i].typ=='U') chkmin(md[L-b[i].r],b[i].x-1);\n\tfor (int i=2;i<=L;i++) chkmax(ml[i],ml[i-1]),chkmax(mu[i],mu[i-1]);\n\tfor (int i=L-1;i;i--)  chkmin(md[i],md[i+1]),chkmin(md[i],md[i+1]);\n\tfor (int i=1;i<=L;i++){\n\t\tfor (int j=ml[i];j<=mr[i];j++) add(R*2+i,j,0,1);\n\t\tfor (int j=mu[i];j<=md[i];j++) add(j+R,R*2+L+i,0,1);\n\t}\n\tcost=0;\n\tif (dinic()==L) ans=max(ans,cost);\n//\tfor (int i=1;i<=n;i++) if (!e[i*2].fl) printf(\"%d \",i);\n//\tprintf(\"\\n\");\n}\nint main(){\n\tn=read();\n\tfor (int i=1;i<=n;i++) scanf(\" %d %d %lld\",&a[i].x,&a[i].y,&a[i].w);\n\tm=read();\n\tfor (int i=1;i<=m;i++) scanf(\" %c %d %d\",&b[i].typ,&b[i].x,&b[i].r);\n\tfor (int i=1;i<=n;i++) calc(i);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>/*{{{*/\n#include<cctype>\n#include<cassert>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<ctime>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<set>\n#include<vector>\nusing namespace std;\ntypedef pair<int,int> pii;\n#define fi first\n#define se second\n#define pb push_back\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define ROF(i,a,b) for(int i=(a);i>=(b);--i)\nnamespace RA{\n    int r(int p){return 1ll*rand()*rand()%p;}\n    int r(int L,int R){return r(R-L+1)+L;}\n}/*}}}*/\n/******************heading******************/\ntypedef long long LL;\nconst LL LLINF=0x3f3f3f3f3f3f3f3f;\nconst int N=330,INF=0x3f3f3f3f;\n\nint s,t;\nstruct qxx{int nex,t,v;LL c;};\nqxx e[N*N*4];\nLL h[N],hh[N],le=1;\nvoid add_path(int f,int t,int v,LL c){e[++le]=(qxx){h[f],t,v,c},h[f]=le;}\nvoid add_flow(int f,int t,int v,LL c){\n    //printf(\"add_flow(%d,%d,%d,%lld)\\n\",f,t,v,c);\n    add_path(f,t,v,c),add_path(t,f,0,-c);}\n#define FORe(i,_u,_v,_w,_c)     for(LL i=h[_u],_v,_w,_c;_v=e[i].t,_w=e[i].v,_c=e[i].c,i;i=e[i].nex)\n#define FORflowe(i,_u,_v,_w,_c) for(LL &i=hh[_u],_v,_w,_c;_v=e[i].t,_w=e[i].v,_c=e[i].c,i;i=e[i].nex)\n\nint n,m;\nint x[N],y[N];\nLL val[N],ans=-LLINF;\nint xL[N],xR[N],yL[N],yR[N];\n\nvector<pii> L,R,U,D;\n\nqueue<int> q;\nbool vising[N];\nLL d[N];\nbool spfa(){\n    memset(d,0x3f,sizeof(d));\n    q.push(s),d[s]=0;\n    while(!q.empty()){\n        int u=q.front();q.pop();\n        vising[u]=0;\n        FORe(i,u,v,w,c){\n            if(!w||d[v]<=d[u]+c)continue;\n            d[v]=d[u]+c;\n            if(!vising[v])q.push(v),vising[v]=1;\n        }\n    }\n    return d[t]!=LLINF;\n}\nLL mincost;\nbool vis[N];\nint dfs(int u,int flow){\n    //printf(\"dfs(%d,%d)\\n\",u,flow);\n    vis[u]=1;\n    if(u==t)return flow;\n    int rest=flow;\n    FORflowe(i,u,v,w,c){\n        if(!rest)break;\n        if(vis[v]&&v!=t||!w||d[v]!=d[u]+c)continue;\n        int k=dfs(v,min(w,1ll*rest));\n        if(k)mincost+=k*c,e[i].v-=k,e[i^1].v+=k,rest-=k;\n        else d[v]=0;\n    }\n    return flow-rest;\n}\nLL go(){\n    int maxflow=0;\n    while(spfa()){\n        //puts(\"GG\");\n        memcpy(hh,h,sizeof(h));\n        for(int i;memset(vis,0,sizeof(vis)),(i=dfs(s,INF))&&vis[t];)maxflow+=i;\n    }\n    //printf(\"maxflow=%d,mincost=%lld\\n\",maxflow,mincost);\n    return mincost;\n}\nvoid init(){\n    memset(h,0,sizeof(h));\n    le=1,mincost=0;\n}\nvoid calc(int k){\n    //printf(\"calc(%d)\\n\",k);\n    for(pii x:L)xL[x.se+1]=x.fi+1; //x[b+1] >= a+1\n    for(pii x:R)xR[k-x.se]=x.fi-1; //x[k-b] <= a-1\n    for(pii x:D)yL[x.se+1]=x.fi+1;\n    for(pii x:U)yR[k-x.se]=x.fi-1;\n    xR[k+1]=INF;\n    FOR(i,1,k)if(!xL[i])xL[i]=xL[i-1];\n    ROF(i,k,1)if(!xR[i])xR[i]=xR[i+1];\n    yR[k+1]=INF;\n    FOR(i,1,k)if(!yL[i])yL[i]=yL[i-1];\n    ROF(i,k,1)if(!yR[i])yR[i]=yR[i+1];\n    //FOR(i,1,k)printf(\"[%d,%d]%c\",xL[i],xR[i],\" \\n\"[i==k]);\n    //FOR(i,1,k)printf(\"[%d,%d]%c\",yL[i],yR[i],\" \\n\"[i==k]);\n\n    // item: 1 - n, n+1 - 2n\n    // x : 2n+1 - 2n+k\n    // y : 2n+k+1 - 2n+2k\n    // s : 0\n    // t : 2n+2k+1\n    init();\n    s=0,t=2*n+2*k+1;\n    //printf(\"s=%d,t=%d\\n\",s,t);\n    FOR(i,1,k)add_flow(s,2*n+i,1,0);\n    FOR(i,1,k)FOR(j,1,n)if(xL[i]<=x[j]&&x[j]<=xR[i])add_flow(2*n+i,j,INF,0);\n    FOR(i,1,n)add_flow(i,i+n,1,-val[i]);\n    FOR(i,1,k)FOR(j,1,n)if(yL[i]<=y[j]&&y[j]<=yR[i])add_flow(j+n,2*n+k+i,INF,0);\n    FOR(i,1,k)add_flow(2*n+k+i,t,1,0);\n\n    LL res=go();\n    ans=max(ans,-res);\n}\n\nint main(){\n    scanf(\"%d\",&n);\n    FOR(i,1,n)scanf(\"%d%d%lld\",&x[i],&y[i],&val[i]);\n    scanf(\"%d\",&m);\n    FOR(i,1,m){\n        char t[10];\n        int a,b;\n        scanf(\"%s%d%d\",t,&a,&b);\n        if(t[0]=='L')L.pb({a,b});\n        else if(t[0]=='R')R.pb({a,b});\n        else if(t[0]=='U')U.pb({a,b});\n        else D.pb({a,b});\n    }\n    FOR(i,1,n)calc(i);\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-03-27 10:28:38\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\n#define i64 long long\ni64 read()\n{\n\ti64 r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\nconst int N=2010;\nnamespace run\n{\n\tconst i64 inf=1ll<<60;\n\ti64 n,px[N],sx[N],py[N],sy[N],begin[N],next[N<<2],to[N<<2],w[N<<2],c[N<<2],e,S,T,m,x[N],y[N],v[N],ans,l,sw,sc;\n\ti64 d[N],q[N*N],_l,_r,pre[N],vis[N];\n\tvoid add(i64 u,i64 v,i64 W,i64 C){ e++; next[e]=begin[u]; begin[u]=e; to[e]=v; w[e]=W; c[e]=C; }\n\tvoid Add(i64 u,i64 v,i64 w,i64 c){ /*printf(\"%I64d %I64d %I64d\\n\",u,v,c);*/ add(u,v,w,c); add(v,u,0,-c); }\n#define fo(i,a) for(int i=begin[a];i;i=next[i])\n\tint bfs()\n\t{\n\t\tfr(i,1,m){ d[i]=-inf; pre[i]=0; vis[i]=0; }\n\t\tq[_l=_r=1]=S; d[S]=0;\n\t\twhile(_l<=_r)\n\t\t{\n\t\t\tint u=q[_l++]; vis[u]=0;\n//\t\t\tprintf(\"%d\\n\",u);\n\t\t\tfo(i,u) if(w[i]&&d[u]+c[i]>d[to[i]])\n\t\t\t{\n\t\t\t\td[to[i]]=d[u]+c[i]; pre[to[i]]=i;\n\t\t\t\tif(!vis[to[i]]){ q[++_r]=to[i]; vis[to[i]]=1; }\n\t\t\t}\n\t\t}\n\t\treturn d[T]!=-inf;\n\t}\n\ti64 solve(int c)\n\t{\n\t\tmemset(begin,0,sizeof(begin)); e=1; S=n+n+c+c+1; T=n+n+c+c+2; m=T;\n//\t\tprintf(\"%d %I64d %I64d\\n\",c,S,T);\n\t\tfr(i,1,n) Add(i,i+n,1,v[i]);\n\t\tfr(j,1,c){ Add(S,j+n+n,1,0); Add(j+n+n+c,T,1,0); }\n\t\tfr(i,1,n) fr(j,1,c) if(px[x[i]]>=j&&sx[x[i]]>=c-j+1) Add(j+n+n,i,1,0);\n\t\tfr(i,1,n) fr(j,1,c) if(py[y[i]]>=j&&sy[y[i]]>=c-j+1) Add(i+n,j+n+n+c,1,0);\n\t\tsw=sc=0;\n\t\twhile(bfs())\n\t\t{\n//\t\t\tprintf(\"%I64d\\n\",d[T]);\n\t\t\tint u=T; sw++;\n\t\t\twhile(u!=S){ w[pre[u]]--; w[pre[u]^1]++; sc+=::run::c[pre[u]]; u=to[pre[u]^1]; }\n\t\t}\n//\t\tprintf(\"%d %I64d\\n\",c,sw==c?sc:0);\n\t\treturn sw==c?sc:0;\n\t}\n\tint main()\n\t{\n\t\tn=read(); l=100;\n\t\tfr(i,1,n){ x[i]=read(); y[i]=read(); v[i]=read(); }\n\t\tfr(i,0,l+1) px[i]=sx[i]=py[i]=sy[i]=n;\n\t\tfr(i,1,read())\n\t\t{\n\t\t\tchar opt[N]; i64 a,b;\n\t\t\tscanf(\"%s\",opt); a=read(); b=read();\n\t\t\tif(*opt=='L') px[a]=std::min(px[a],b);\n\t\t\tif(*opt=='R') sx[a]=std::min(sx[a],b);\n\t\t\tif(*opt=='D') py[a]=std::min(py[a],b);\n\t\t\tif(*opt=='U') sy[a]=std::min(sy[a],b);\n\t\t}\n\t\tfr(i,1,l){ sx[i]=std::min(sx[i],sx[i-1]); sy[i]=std::min(sy[i],sy[i-1]); }\n\t\tfd(i,l,1){ px[i]=std::min(px[i],px[i+1]); py[i]=std::min(py[i],py[i+1]); }\n//\t\tfr(i,1,n) printf(\"%I64d %I64d %I64d %I64d\\n\", );\n\t\tfr(i,1,n) ans=std::max(ans,solve(i));\n\t\tprintf(\"%lld\\n\",ans);\n\t\treturn 0;\n\t}\n}\nint main(){ return run::main(); }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst double eps = 1e-9;\n\ndouble s[410][110], c[110]; int n, m;\n\ninline void pivot(int x, int y) {\n    double tmp = s[y][x]; s[y][x] = -1;\n    for (int i = 1; i <= n + 1; i++) s[y][i] /= -tmp;\n    for (int i = 1; i <= m; i++) if (i != y) {\n        tmp = s[i][x], s[i][x] = 0;\n        if (-eps < tmp && tmp < eps) continue;\n        for (int j = 1; j <= n + 1; j++) s[i][j] += s[y][j] * tmp;\n    }\n    tmp = c[x], c[x] = 0;\n    for (int i = 1; i <= n + 1; i++) c[i] += s[y][i] * tmp;\n}\n\ninline double LP() {\n    for (int cur = 0, pos = 0; ; pivot(cur, pos), pos = cur = 0) {\n        for (int i = 1; i <= n; i++) if (c[i] > eps) cur = i;\n        if (!cur) return c[n + 1];\n        double mn = 1e100;\n        for (int i = 1; i <= m; i++) if (s[i][cur] < -eps) {\n            double tmp = s[i][n + 1] / -s[i][cur];\n            if (tmp < mn) mn = tmp, pos = i;\n        }\n        if (!pos) return 1e100;\n    }\n}\n\nint x[110], y[110];\n\nint main() {\n    int n, tp = 0; scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i++) \n        scanf(\"%d%d%lf\", &x[i], &y[i], &c[i]), s[++tp][i] = -1, s[tp][n + 1] = 1;\n    int m; scanf(\"%d\", &m);\n    while (m--) {\n        char st[5]; int a, b; scanf(\"%s%d%d\", st + 1, &a, &b), tp++, s[tp][n + 1] = b;\n        if (st[1] == 'L') {\n            for (int i = 1; i <= n; i++) if (x[i] <= a) s[tp][i] = -1;\n        } else if (st[1] == 'R') {\n            for (int i = 1; i <= n; i++) if (x[i] >= a) s[tp][i] = -1;\n        } else if (st[1] == 'D') {\n            for (int i = 1; i <= n; i++) if (y[i] <= a) s[tp][i] = -1;\n        } else for (int i = 1; i <= n; i++) if (y[i] >= a) s[tp][i] = -1;\n    }\n    ::m = tp, ::n = n, printf(\"%lld\\n\", (long long)(LP() + 0.5));\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <iostream>\n#include <queue>\n\n#define DEBUG() std::cerr << __FUNCTION__ << \" \" << __LINE__ << std::endl\n\nusing i64 = long long;\n\nnamespace flw {\n\tconst int N = 5000 + 7;\n\tconst int INF = 1 << 28;\n\tstruct flow {\n\t\tint n, st, ed;\n\t\tint vis[N];\n\t\ti64 dis[N];\n\t\tstruct edge {\n\t\t\tint to, nex, cap; i64 wei;\n\t\t} e[N];\n\t\tint fir[N], cur[N], eid;\n\t\tint maxflow;\n\t\ti64 mincost;\n\t\t\n\t\tvoid init() {\n\t\t\teid = 1;\n\t\t\tstd::fill(fir + 1, fir + n + 1, 0);\n\t\t\tst = ed = n = 0;\n\t\t}\n\t\tvoid addedge(int u, int v, int c, i64 w) {\n\t\t\te[++eid] = (edge){ v, fir[u], c, w }, fir[u] = eid;\n\t\t}\n\t\tvoid addflow(int u, int v, int c, i64 w) {\n\t\t\taddedge(u, v, c, w), addedge(v, u, 0, -w);\n\t\t}\n\t\tvoid dinic() {\n\t\t\tmaxflow = mincost = 0;\n\t\t\tint f;\n\t\t\twhile (bfs())\n\t\t\t\twhile (f = dfs(st, INF)) maxflow += f, mincost += f * dis[st];\n\t\t}\n\t\tint bfs() {\n\t\t\tstd::fill(dis + 1, dis + n + 1, 1ll << 60),\n\t\t\tstd::fill(vis + 1, vis + n + 1, 0);\n\t\t\tstd::copy(fir + 1, fir + n + 1, cur + 1);\n\t\t\tstatic std::queue<int> q;\n\t\t\tdis[ed] = 0, vis[ed] = 1, q.push(ed);\n\t\t\tfor (int s; q.size(); ) {\n\t\t\t\ts = q.front(), q.pop();\n\t\t\t\tfor (int i = fir[s]; i; i = e[i].nex)\n\t\t\t\t\tif (e[i ^ 1].cap && dis[e[i].to] > dis[s] - e[i].wei) {\n\t\t\t\t\t\tdis[e[i].to] = dis[s] - e[i].wei;\n\t\t\t\t\t\tif (!vis[e[i].to])\n\t\t\t\t\t\t\tvis[e[i].to] = 1, q.push(e[i].to);\n\t\t\t\t\t}\n\t\t\t\tvis[s] = 0;\n\t\t\t}\n\t\t\treturn dis[st] < 1ll << 60;\n\t\t}\n\t\ti64 dfs(int s, int f) {\n\t\t\tif (s == ed) return f;\n\t\t\tvis[s] = 1;\n\t\t\tint u = 0, t;\n\t\t\tfor (int& i = cur[s]; i; i = e[i].nex) {\n\t\t\t\tif (!e[i].cap || vis[e[i].to] || dis[s] != dis[e[i].to] + e[i].wei) continue;\n\t\t\t\tt = dfs(e[i].to, std::min(f - u, e[i].cap));\n\t\t\t\te[i].cap -= t, e[i ^ 1].cap += t, u += t;\n\t\t\t\tif (f == u) break;\n\t\t\t}\n\t\t\treturn vis[s] = 0, u;\n\t\t}\n\t};\n}\n\nconst int X = 100 + 7, N = 80 + 7;\n\nint n, m;\nint u[N], v[N];\ni64 w[N];\nint x[N], y[N], z[N];\nint llm[N], rlm[N], dlm[N], ulm[N];\nflw::flow f;\ni64 ans;\n\nint main() {\n//\tfreopen(\"code.in\", \"r\", stdin);\n//\tfreopen(\"code.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i)\n\t\tscanf(\"%d%d%lld\", u + i, v + i, w + i);\n\tscanf(\"%d\", &m);\n\tfor (int i = 1; i <= m; ++i) {\n\t\tchar c[3];\n\t\tscanf(\"%s%d%d\", c, x + i, y + i);\n\t\tif (y[i] >= n) { --i; --m; continue; }\n\t\tz[i] = c[0];\n\t}\n\t\n\tfor (int k = 1; k <= n; ++k) {\n\t\tf.init();\n\t\tf.st = 2 * (n + k) + 1, f.ed = f.n = f.st + 1;\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t\tf.addflow(i, n + i, 1, -w[i]);\n\t\tmemset(llm, 0, sizeof llm);\n\t\tmemset(dlm, 0, sizeof dlm);\n\t\tmemset(rlm, 0x3f, sizeof rlm);\n\t\tmemset(ulm, 0x3f, sizeof ulm);\n\t\tfor (int i = 1; i <= m; ++i) {\n\t\t\tif (y[i] >= k) continue;\n\t\t\tif (z[i] == 'L') llm[y[i] + 1] = std::max(llm[y[i] + 1], x[i] + 1);\n\t\t\tif (z[i] == 'R') rlm[k - y[i]] = std::min(rlm[k - y[i]], x[i] - 1);\n\t\t\tif (z[i] == 'D') dlm[y[i] + 1] = std::max(dlm[y[i] + 1], x[i] + 1);\n\t\t\tif (z[i] == 'U') ulm[k - y[i]] = std::min(ulm[k - y[i]], x[i] - 1);\n\t\t}\n\t\tfor (int i = 1; i <= k; ++i)\n\t\t\tllm[i] = std::max(llm[i], llm[i - 1]),\n\t\t\tdlm[i] = std::max(dlm[i], dlm[i - 1]);\n\t\tfor (int i = k; i; --i)\n\t\t\trlm[i] = std::min(rlm[i], rlm[i + 1]),\n\t\t\tulm[i] = std::min(ulm[i], ulm[i + 1]);\n\t\tfor (int i = 1; i <= k; ++i) {\n\t\t\tf.addflow(f.st, 2 * n + i, 1, 0);\n\t\t\tf.addflow(2 * n + k + i, f.ed, 1, 0);\n\t\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\t\tif (llm[i] <= u[j] && u[j] <= rlm[i]) f.addflow(2 * n + i, j, 1, 0);\n\t\t\t\tif (dlm[i] <= v[j] && v[j] <= ulm[i]) f.addflow(n + j, 2 * n + k + i, 1, 0);\n\t\t\t}\n\t\t}\n\t\tf.dinic();\n\t\tif (f.maxflow == k) ans = std::max(ans, -f.mincost);\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//2019.5.25 by ljz\n#include<bits/stdc++.h>\nusing namespace std;\n#define res register int\n#define LL long long\n#define inf 0x3f3f3f3f\n#define INF 1000000000000000LL\n#define eps 1e-10\n#define RG register\n#define db double\n#define pc(x) __builtin_popcount(x)\ntypedef pair<int,int> Pair;\n#define mp make_pair\n#define fi first\n#define se second\n#define gc getchar\n//inline char gc() {\n//    static char buf[100000],*p1,*p2;\n//    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n//}\ninline int read() {\n    res s=0,ch=gc();\n    while(ch<'0'||ch>'9')ch=gc();\n    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=gc();\n    return s;\n}\ninline LL Read() {\n    RG LL s=0;\n    res ch=gc();\n    while(ch<'0'||ch>'9')ch=gc();\n    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=gc();\n    return s;\n}\ninline void swap(res &x,res &y) {\n    x^=y^=x^=y;\n}\n//mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nconst int N=4e2+10;\nnamespace MAIN {\n    int n,m;\n    char str[10];\n    LL v[N];\n    int x[N],y[N],t[N],a[N],b[N];\n    struct E{\n        int next,to,flow;\n        LL cost;\n        E() {}\n        E(res next,res to,res flow,RG LL cost):next(next),to(to),flow(flow),cost(cost) {}\n    }edge[N*N];\n    int head[N],cnt;\n    inline void addedge(const res &u,const res &v,const res &f,const RG LL &c){\n        edge[++cnt]=E(head[u],v,f,c),head[u]=cnt;\n        edge[++cnt]=E(head[v],u,0,-c),head[v]=cnt;\n    }\n    LL dis[N];\n    int Q[N*N],he,ta,S,T,vis[N],pre[N];\n    inline bool spfa(RG LL &ret){\n        for(res i=S;i<=T;i++)dis[i]=INF;\n        Q[he=ta=1]=S,vis[S]=1,dis[S]=0;\n        while(he<=ta){\n            res u=Q[he++];\n            vis[u]=0;\n            for(res i=head[u];~i;i=edge[i].next){\n                res tox=edge[i].to;\n                if(dis[tox]>dis[u]+edge[i].cost&&edge[i].flow){\n                    dis[tox]=dis[u]+edge[i].cost,pre[tox]=i;\n                    if(!vis[tox])vis[tox]=1,Q[++ta]=tox;\n                }\n            }\n        }\n        if(dis[T]==INF)return 0;\n        ret+=dis[T];\n        for(res i=T;i!=S;i=edge[pre[i]^1].to)edge[pre[i]].flow--,edge[pre[i]^1].flow++;\n        return 1;\n    }\n    int L[N],R[N],D[N],U[N];\n    inline LL calc(const res &k){\n        for(res i=1;i<=k;i++)L[i]=D[i]=0,R[i]=U[i]=inf;\n        for(res i=1;i<=m;i++)\n            if(b[i]<k){\n                if(t[i]==0)L[b[i]+1]=a[i]+1;\n                if(t[i]==1)R[k-b[i]]=a[i]-1;\n                if(t[i]==2)D[b[i]+1]=a[i]+1;\n                if(t[i]==3)U[k-b[i]]=a[i]-1;\n            }\n        for(res i=2;i<=k;i++)L[i]=max(L[i],L[i-1]),D[i]=max(D[i],D[i-1]);\n        for(res i=k-1;i;i--)R[i]=min(R[i],R[i+1]),U[i]=min(U[i],U[i+1]);\n        S=0,T=(n+k)<<1|1;\n        for(res i=S;i<=T;i++)head[i]=-1;\n        cnt=-1;\n        for(res i=1;i<=n;i++)addedge(i,i+n,1,-v[i]-INF);\n        for(res i=1;i<=k;i++){\n            addedge(S,i+n*2,1,0),addedge(i+k+n*2,T,1,0);\n            for(res j=1;j<=n;j++){\n                if(L[i]<=x[j]&&x[j]<=R[i])addedge(i+n*2,j,1,0);\n                if(D[i]<=y[j]&&y[j]<=U[i])addedge(j+n,i+k+n*2,1,0);\n            }\n        }\n        RG LL ret=0;\n        while(spfa(ret));\n        return -ret-INF*k;\n    }\n    LL ans;\n    inline int get(const RG char *st){\n        return st[0]=='L'?0:(st[0]=='R'?1:(st[0]=='D'?2:3));\n    }\n    inline void MAIN(){\n        n=read();\n        for(res i=1;i<=n;i++)x[i]=read(),y[i]=read(),v[i]=Read();\n        m=read();\n        for(res i=1;i<=m;i++)scanf(\"%s\",str),t[i]=get(str),a[i]=read(),b[i]=read();\n        for(res i=1;i<=n;i++)ans=max(ans,calc(i));\n        printf(\"%lld\\n\",ans);\n    }\n}\nint main() {\n//    srand((unsigned)time(NULL));\n//    freopen(\"zao.in\",\"r\",stdin);\n//    freopen(\"std.out\",\"w\",stdout);\n    MAIN::MAIN();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define llong long long\n#define mkpr make_pair\n#define pii pair<int,int>\n#define riterator reverse_iterator\nusing namespace std;\n\ninline int read()\n{\n\tint x = 0,f = 1; char ch = getchar();\n\tfor(;!isdigit(ch);ch=getchar()) {if(ch=='-') f = -1;}\n\tfor(; isdigit(ch);ch=getchar()) {x = x*10+ch-48;}\n\treturn x*f;\n}\n\n\n\nnamespace NetFlow\n{\n\tconst int N = 206;\n\tconst int M = 284;\n\t#define lllong __int128\n\tconst lllong INF = 2e17;\n\tconst lllong INF2 = 1e22;\nvoid write_lll(lllong x)\n{\n\tint outputbuf[50]; int len=0; if(x<0) {printf(\"-\"); x = -x;}\n\twhile(x) {outputbuf[len++] = x%10; x/=10;}\n\tfor(int i=len-1; i>=0; i--) printf(\"%d\",outputbuf[i]);\n}\n\tstruct AEdge\n\t{\n\t\tint u,v,wl,wr; lllong c;\n\t} ae[M+3];\n\tstruct Edge\n\t{\n\t\tint u,v,nxt,w; lllong c;\n\t} e[(M<<2)+3];\n\tint fe[N+3];\n\tlllong dis[N+3];\n\tint que[N+5];\n\tbool inq[N+3];\n\tint lst[N+3];\n\tint n,m,en,s,t; lllong mf,mc;\n\tvoid init()\n\t{\n\t\tmemset(ae,0,sizeof(ae)); memset(e,0,sizeof(e)); memset(fe,0,sizeof(fe)); memset(dis,0,sizeof(dis)); memset(que,0,sizeof(que)); memset(inq,0,sizeof(inq)); memset(lst,0,sizeof(lst));\n\t\tn = m = s = t = 0; mf = mc = (lllong)0;\n\t}\n\tvoid addedge0(int u,int v,int w,lllong c)\n\t{\n//\t\tprintf(\"adde' %d %d %d %lld\\n\",u,v,w,c);\n\t\ten++; e[en].u = u,e[en].v = v,e[en].w = w,e[en].c = c;\n\t\te[en].nxt = fe[u]; fe[u] = en;\n\t\ten++; e[en].u = v,e[en].v = u,e[en].w = 0,e[en].c = -c;\n\t\te[en].nxt = fe[v]; fe[v] = en;\n\t}\n\tbool spfa()\n\t{\n\t\tfor(int i=1; i<=n; i++) dis[i] = -INF2;\n\t\tint hd = 1,tl = 2; que[1] = s; dis[1] = 0;\n\t\twhile(hd!=tl)\n\t\t{\n\t\t\tint u = que[hd]; hd++; if(hd>n+1) hd-=n+1;\n\t\t\tfor(int i=fe[u]; i; i=e[i].nxt)\n\t\t\t{\n\t\t\t\tint v = e[i].v;\n\t\t\t\tif(e[i].w>0&&dis[e[i].v]<dis[u]+e[i].c)\n\t\t\t\t{\n\t\t\t\t\tdis[e[i].v] = dis[u]+e[i].c; lst[e[i].v] = i;\n\t\t\t\t\tif(!inq[e[i].v])\n\t\t\t\t\t{\n\t\t\t\t\t\tinq[e[i].v] = true;\n\t\t\t\t\t\tque[tl] = e[i].v; tl++; if(tl>n+1) tl-=n+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tinq[u] = false;\n\t\t}\n\t\treturn dis[t]!=-INF2;\n\t}\n\tvoid calcflow()\n\t{\n\t\tint flow = 1e5;\n\t\tfor(int u=t; u!=s; u=e[lst[u]].u)\n\t\t{\n\t\t\tflow = min(flow,e[lst[u]].w);\n\t\t}\n\t\tfor(int u=t; u!=s; u=e[lst[u]].u)\n\t\t{\n\t\t\te[lst[u]].w -= flow; e[lst[u]^1].w += flow;\n\t\t}\n\t\tmf += flow; mc += dis[t]*(lllong)flow;\n\t}\n\tvoid mfmc()\n\t{\n\t\tmf = mc = 0; while(spfa()) {calcflow();}\n\t}\n\tvoid addedge(int u,int v,int wl,int wr,llong c)\n\t{\n//\t\tprintf(\"+ %d %d %d %d %lld\\n\",u,v,wl,wr,c);\n\t\tm++; ae[m].u = u,ae[m].v = v,ae[m].wl = wl,ae[m].wr = wr,ae[m].c = c;\n\t}\n\tllong flow(int _n,int _s,int _t,int _mf)\n\t{\n\t\tn = _n,s = _s,t = _t; en = 1; lllong ret = 0ll;\n\t\tfor(int i=1; i<=m; i++)\n\t\t{\n\t\t\tif(ae[i].wl) {addedge0(ae[i].u,ae[i].v,ae[i].wl,INF); ret += (ae[i].c-INF)*(lllong)ae[i].wl;}\n\t\t\taddedge0(ae[i].u,ae[i].v,ae[i].wr-ae[i].wl,ae[i].c);\n\t\t}\n\t\tmfmc();\n//\t\tprintf(\"mf=\"); write_lll(mf); printf(\" mc=\"); write_lll(mc); printf(\" ret=\"); write_lll(ret); puts(\"\");\n\t\tif(mf!=_mf||mc+ret<(lllong)0) {return -1ll;}\n\t\treturn mc+ret;\n\t}\n}\n\nconst int N = 100;\nstruct Element\n{\n\tint x,y; llong w;\n} a[N+3];\nstruct Condition\n{\n\tint typ,x,y;\n} b[N*4+3];\nint alx[N+3],aly[N+3],arx[N+3],ary[N+3];\nint n,m,mx; llong ans;\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tscanf(\"%d%d%lld\",&a[i].x,&a[i].y,&a[i].w); mx = max(mx,max(a[i].x,a[i].y));\n\t}\n\tscanf(\"%d\",&m);\n\tfor(int i=1; i<=m; i++)\n\t{\n\t\tchar str[5]; scanf(\"%s%d%d\",str,&b[i].x,&b[i].y); mx = max(mx,b[i].x);\n\t\tb[i].typ = (str[0]=='L'?0:(str[0]=='R'?1:(str[0]=='D'?2:3)));\n\t}\n\tmx++;\n\tfor(int k=1; k<=n; k++)\n\t{\n//\t\tprintf(\"\\nk=%d\\n\",k);\n\t\tfor(int i=0; i<=mx; i++) alx[i] = 0,arx[i] = k,aly[i] = 0,ary[i] = k;\n\t\tfor(int i=1; i<=m; i++)\n\t\t{\n\t\t\tif(b[i].typ==0)\n\t\t\t{\n\t\t\t\talx[b[i].x+1] = max(alx[b[i].x+1],k-b[i].y);\n\t\t\t}\n\t\t\telse if(b[i].typ==1)\n\t\t\t{\n\t\t\t\tarx[b[i].x] = min(arx[b[i].x],b[i].y);\n\t\t\t}\n\t\t\telse if(b[i].typ==2)\n\t\t\t{\n\t\t\t\tary[b[i].x] = min(ary[b[i].x],b[i].y);\n\t\t\t}\n\t\t\telse if(b[i].typ==3)\n\t\t\t{\n\t\t\t\taly[b[i].x-1] = max(aly[b[i].x-1],k-b[i].y);\n\t\t\t}\n\t\t}\n\t\tbool ok = true;\n\t\tfor(int i=0; i<=mx; i++) {if(alx[i]>arx[i]||aly[i]>ary[i]) {ok = false; break;}}\n\t\tif(!ok) continue;\n//\t\tprintf(\"x: \"); for(int i=0; i<=mx; i++) printf(\"[%d,%d] \",alx[i],arx[i]); puts(\"\");\n//\t\tprintf(\"y: \"); for(int i=0; i<=mx; i++) printf(\"[%d,%d] \",aly[i],ary[i]); puts(\"\");\n\t\tNetFlow::init();\n\t\tfor(int i=0; i<=mx; i++)\n\t\t{\n\t\t\tNetFlow::addedge(i==0?1:i+2,i+3,alx[i],arx[i],0ll);\n\t\t}\n\t\tfor(int i=0; i<=mx; i++)\n\t\t{\n\t\t\tNetFlow::addedge(i+mx+4,i==mx?2:i+mx+5,aly[i],ary[i],0ll);\n\t\t}\n\t\tfor(int i=1; i<=n; i++)\n\t\t{\n\t\t\tNetFlow::addedge(a[i].x+3,a[i].y+mx+4,0,1,a[i].w);\n\t\t}\n\t\tllong cur = NetFlow::flow(mx+mx+4,1,2,k);\n\t\tassert(cur>=-1);\n//\t\tprintf(\"cur=%lld\\n\",cur);\n\t\tans = max(ans,cur);\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MV = 815;\nconst int ME = 1200006;\nconst ll oo = 1e18;\n\ntemplate <typename T> void cmin(T &x, const T &y)\n{\n\tif(y < x) x = y;\n}\n\ntemplate <typename T> void cmax(T &x, const T &y)\n{\n\tif(y > x) x = y;\n}\n\ntemplate <typename T> void read(T &x)\n{\n\tx = 0; char c = getchar(); bool f = 0;\n\twhile(!isdigit(c) && c!='-') c = getchar();\n\tif(c == '-') f = 1, c = getchar();\n\twhile(isdigit(c)) x = x*10+c-'0', c = getchar();\n\tif(f) x = -x;\n}\n\nstruct edge\n{\n\tint u, v, f;\n\tll c;\n\tint n;\n\n\tedge (const int &u0 = 0, const int &v0 = 0, const ll &f0 = 0, const ll &c0 = 0, const int &n0 = 0) : u(u0), v(v0), f(f0), c(c0), n(n0) {}\n};\n\nstruct GRAPH\n{\n\tedge e[ME];\n\tint fst[MV], lnum;\n\n\tvoid init() {memset(fst, 0xff, sizeof(fst)); lnum = -1;}\n\t\n\tGRAPH () {init();}\n\t\n\tvoid addeg(int nu, int nv, ll nc, int nf)\n\t{\n\t\te[++lnum] = edge(nu, nv, nf, nc, fst[nu]), fst[nu] = lnum;\n\t\te[++lnum] = edge(nv, nu, 0, -nc, fst[nv]), fst[nv] = lnum;\n\t}\n\t\n\tint que[MV], inq[MV], cur[MV];\n\tll dis[MV];\n\t\n\tbool spfa(int frm, int tar)\n\t{\n\t\tint h = 1, t = 1, x, y;\n\t\tmemset(dis, 0x9f, sizeof(dis));\n\t\tdis[frm] = 0;\n\t\tque[h] = frm;\n\t\tinq[frm] = 1;\n\t\twhile(h >= t)\n\t\t{\n\t\t\tx = que[(t++)%MV];\n\t\t\tinq[x] = 0;\n\t\t\tfor(int i=fst[x]; ~i; i=e[i].n)\n\t\t\t{\n\t\t\t\ty = e[i].v;\n\t\t\t\tif(e[i].f && dis[y]<dis[x]+e[i].c)\n\t\t\t\t{\n\t\t\t\t\tdis[y] = dis[x] + e[i].c;\n\t\t\t\t\tif(!inq[y]) que[(++h)%MV] = y, inq[y] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn (dis[tar] > -oo);\n\t}\n\t\n\tint dinic(int x, int t, int f)\n\t{\n\t\tif(x == t) return f;\n\t\tint a, y, now = 0;\n\t\tinq[x] = 1;\n\t\tfor(int &i=cur[x]; ~i; i=e[i].n)\n\t\t{\n\t\t\ty = e[i].v;\n\t\t\tif(dis[y]==dis[x]+e[i].c && e[i].f && !inq[y])\n\t\t\t{\n\t\t\t\ta = dinic(y, t, min(e[i].f, f-now));\n\t\t\t\tnow += a;\n\t\t\t\te[i].f -= a;\n\t\t\t\te[i^1].f += a;\n\t\t\t\tif(now == f) break;\n\t\t\t}\n\t\t}\n\t\tinq[x] = 0;\n\t\treturn now;\n\t}\n\t\n\tpair<int, ll> costf(int s, int t)\n\t{\n\t\tll cost = 0;\n\t\tint flow = 0;\n\t\twhile(spfa(s, t))\n\t\t{\n\t\t\tmemmove(cur, fst, sizeof(cur));\n\t\t\tint new_flow = dinic(s, t, ME);\n\t\t\tcost += dis[t] * new_flow;\n\t\t\tflow += new_flow;\n\t\t}\n\t\treturn make_pair(flow, cost);\n\t}\n} G;\n\nint n, m;\nint lx[MV], rx[MV];\nint ly[MV], ry[MV];\nint px[MV], py[MV];\nll pv[MV];\nchar qc[MV];\nint qa[MV], qb[MV];\nint global_s, global_t;\n\nvoid input()\n{\n\tread(n);\n\tfor(int i=1; i<=n; i++) read(px[i]), read(py[i]), read(pv[i]);\n\tread(m);\n\tfor(int i=1; i<=n; i++) lx[i] = 1, rx[i] = 100, ly[i] = 1, ry[i] = 100;\n\tfor(int i=1; i<=m; i++)\n\t{\n\t\tqc[i] = getchar();\n\t\twhile(!isalpha(qc[i])) qc[i] = getchar();\n\t\tread(qa[i]), read(qb[i]);\n\t}\n}\n\nvoid build(int num)\n{\n\tfor(int i=1; i<=num; i++) lx[i] = ly[i] = 1, rx[i] = ry[i] = 100;\n\tfor(int i=1; i<=m; i++)\n\t{\n\t\tif(qb[i] > num) continue;\n\t\tif(qc[i] == 'L') cmax(lx[qb[i]+1], qa[i]+1);\n\t\tif(qc[i] == 'R') cmin(rx[num-qb[i]], qa[i]-1);\n\t\tif(qc[i] == 'D') cmax(ly[qb[i]+1], qa[i]+1);\n\t\tif(qc[i] == 'U') cmin(ry[num-qb[i]], qa[i]-1);\n\t}\n\tfor(int i=1; i<=num; i++) cmax(lx[i], lx[i-1]), cmax(ly[i], ly[i-1]);\n\tfor(int i=num; i>=1; i--) cmin(rx[i], rx[i+1]), cmin(ry[i], ry[i+1]);\n\tG.init();\n\tfor(int i=1; i<=num; i++)\n\t{\n\t\tfor(int j=1; j<=n; j++)\n\t\t{\n\t\t\tif(lx[i]<=px[j] && px[j]<=rx[i]) G.addeg(i, num*2+j, 0, 1);\n\t\t\tif(ly[i]<=py[j] && py[j]<=ry[i]) G.addeg(num*2+n+j, num+i, 0, 1);\n\t\t}\n\t}\n\tfor(int i=1; i<=n; i++) G.addeg(num*2+i, num*2+n+i, pv[i], 1);\n\tglobal_s = num*2+n*2+1, global_t = global_s+1;\n\tfor(int i=1; i<=num; i++) G.addeg(global_s, i, 0, 1), G.addeg(num+i, global_t, 0, 1);\n}\n\nvoid work()\n{\n\tll ans = 0;\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tbuild(i);\n\t\tauto ret = G.costf(global_s, global_t);\n\t\tif(ret.first != i) break;\n\t\telse cmax(ans, ret.second);\n\t}\n\tprintf(\"%lld\\n\", ans);\n}\n\nint main()\n{\n\tinput();\n\twork();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <list>\n#include <time.h>\n#include <math.h>\n#include <random>\n#include <deque>\n#include <queue>\n#include <cassert>\n#include <unordered_map>\n#include <unordered_set>\n#include <iomanip>\n#include <bitset>\n#include <sstream>\n#include <chrono>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef long double dbl;\nconst int INF = 1.01e9;\n \nconst long double EPS = 1e-18;\nbool eq(long double x, long double y) {\n    return fabs(x - y) < EPS;\n}\nbool ls(long double x, long double y) {\n    return x < y && !eq(x, y);\n}\n \nvector<long double> simplex(vector<vector<long double> > a) {\n    int n = a.size() - 1;\n    int m = a[0].size() - 1;\n    vector<int> left(n + 1), up(m + 1);\n    iota(up.begin(), up.end(), 0);\n    iota(left.begin(), left.end(), m);\n    auto pivot = [&](int x, int y) {\n        swap(left[x], up[y]);\n        long double k = a[x][y];\n        a[x][y] = 1;\n        vector<int> vct;\n        for (int j = 0; j <= m; j++) {\n            a[x][j] /= k;\n            if (!eq(a[x][j], 0)) vct.push_back(j);\n        }\n        for (int i = 0; i <= n; i++) {\n            if (eq(a[i][y], 0) || i == x) continue;\n            k = a[i][y];\n            a[i][y] = 0;\n            for (int j : vct) a[i][j] -= k * a[x][j];\n        }\n    };\n    while (1) {\n        int x = -1;\n        for (int i = 1; i <= n; i++) if (ls(a[i][0], 0) && (x == -1 || a[i][0] < a[x][0])) x = i;\n        if (x == -1) break;\n        int y = -1;\n        for (int j = 1; j <= m; j++) if (ls(a[x][j], 0) && (y == -1 || a[x][j] < a[x][y])) y = j;\n        if (y == -1) assert(0); // infeasible\n        pivot(x, y);\n    }\n    while (1) {\n        int y = -1;\n        for (int j = 1; j <= m; j++) if (ls(0, a[0][j]) && (y == -1 || a[0][j] > a[0][y])) y = j;\n        if (y == -1) break;\n        int x = -1;\n        for (int i = 1; i <= n; i++) if (ls(0, a[i][y]) && (x == -1 || a[i][0] / a[i][y] < a[x][0] / a[x][y])) x = i;\n        if (x == -1) assert(0); // unbounded\n        pivot(x, y);\n    }\n    vector<long double> ans(m + 1);\n    for (int i = 1; i <= n; i++) if (left[i] <= m) ans[left[i]] = a[i][0];\n    ans[0] = -a[0][0];\n    return ans;\n}\n\n#ifdef ONPC\n  mt19937 rnd(228);\n#else\n  mt19937 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\n#endif\n\nint main()\n{\n#ifdef ONPC\n  freopen(\"a.in\", \"r\", stdin);\n#endif\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector <int> x(n), y(n);\n  vector <ll> ok;\n  vector <long double> v;\n  vector <pair <ll, int> > e;\n  for (int i = 0; i < n; i++)\n  {\n    cin >> x[i] >> y[i];\n    ll x;\n    cin >> x;\n    ok.push_back(x);\n    v.push_back(x);\n    e.push_back({x, i});\n  }\n  v.insert(v.begin(), 0);\n  int m;\n  cin >> m;\n  vector <vector <long double> > mat;\n  mat.push_back(v);\n  for (int i = 0; i < n; i++)\n  {\n    vector <long double> kek(n + 1);\n    kek[0] = kek[i + 1] = 1;\n    mat.push_back(kek);\n  }\n  vector <vector <int> > simp;\n  for (int i = 0; i < m; i++)\n  {\n    char c;\n    cin >> c;\n    int a;\n    int b;\n    cin >> a >> b;\n    vector <long double> arr = {(long double) b};\n    vector <int> kek = {b};\n    for (int j = 0; j < n; j++)\n    {\n      int grab = 0;\n      if (c == 'L' && x[j] <= a) grab = 1;\n      if (c == 'R' && x[j] >= a) grab = 1;\n      if (c == 'D' && y[j] <= a) grab = 1;\n      if (c == 'U' && y[j] >= a) grab = 1;\n      arr.push_back(grab);\n      kek.push_back(grab);\n    }\n    mat.push_back(arr);\n    simp.push_back(kek);\n  }\n  auto good = [&] (vector <int> grab)\n  {\n    for (auto c : simp)\n    {\n      int sum = 0;\n      for (int i = 1; i <= n; i++) sum += grab[i - 1] * c[i];\n      if (sum > c[0])\n      {\n        return false;\n      }\n    }\n    return true;\n  };\n  auto f = [&] (vector <int> grab)\n  {\n    ll sum = 0;\n    for (int i = 0; i < n; i++)\n    {\n      if (grab[i]) sum += ok[i];\n    }\n    return sum;\n  };\n  vector <int> grab;\n  for (int i = 0; i < n; i++) grab.push_back(0);\n  cout.precision(20);\n  auto solve = [&] ()\n  {\n    auto ret = simplex(mat);\n    sort(e.begin(), e.end());\n    vector <int> me(n);\n    int kek = 0;\n    for (int i = (int) e.size() - 1; i >= 0; i--)\n    {\n      if (!grab[e[i].second] && ret[e[i].second + 1] > EPS)\n      {\n        kek++;\n        me[e[i].second] = true;\n        grab[e[i].second] = true;\n        if (!good(grab)) grab[e[i].second] = false, me[e[i].second] = false;\n      }\n    }\n    int kekos = 0;\n    for (auto &c : mat)\n    {\n      kekos++;\n      if (kekos >= n + 1)\n      for (int i = 1; i <= n; i++)\n      {\n        if (me[i - 1] && c[i] > EPS) c[i]--, c[0]--;\n      }\n    }\n    for (int i = 1; i <= n; i++)\n    {\n      if (me[i - 1])\n      {\n        mat[i][0] = 0;\n      }\n    }\n    return kek;\n  };\n  while (solve());\n  bool ch = true;\n  while (ch)\n  {\n    ch = false;\n    for (int i = (int) e.size() - 1; i >= 0; i--)\n    {\n      if (!grab[e[i].second])\n      {\n        grab[e[i].second] = true;\n        if (good(grab))\n        {\n          ch = true;\n        }\n        else\n        {\n          grab[e[i].second] = false;\n        }\n      }\n    }\n    if (!ch)\n    {\n      for (int i = 0; i < (int) e.size(); i++)\n      {\n        for (int j = i + 1; j < (int) e.size(); j++)\n        {\n          if (e[i].first < e[j].first && grab[e[i].second] && !grab[e[j].second])\n          {\n            auto x = grab;\n            swap(x[e[i].second], x[e[j].second]);\n            if (good(x))\n            {\n              grab = x;\n              ch = true;\n            }\n          }\n        }\n      }\n    }\n  }\n  ll best = f(grab);\n  cout << best << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define ll long long\n#define inf 0x3f3f3f3f3f3f3f3f\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\nchar buf[1<<21],*p1=buf,*p2=buf;\ninline char getc(){return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;}\nll read(){\n    R ll res,f=1;R char ch;\n    while((ch=getc())>'9'||ch<'0')(ch=='-')&&(f=-1);\n    for(res=ch-'0';(ch=getc())>='0'&&ch<='9';res=res*10+ch-'0');\n    return res*f;\n}\ninline char getop(){R char ch;while((ch=getc())>'Z'||ch<'A');return ch;}\nconst int N=505;\nstruct eg{int v,nx,w;ll c;}e[N*N];int head[N],tot;\ninline void add(R int u,R int v,R ll c){\n\te[++tot]={v,head[u],1,c},head[u]=tot,\n\te[++tot]={u,head[v],0,-c},head[v]=tot;\n}\nint x[N],y[N],a[N],b[N],t[N],LL[N],RR[N],DD[N],UU[N],vis[N],pe[N],n,m,S,T;\nll v[N],dis[N],res,ans;queue<int>q;\nbool spfa(){\n\tmemset(dis,0,sizeof(dis));\n\tdis[S]=0,q.push(S);\n\twhile(!q.empty()){\n\t\tint u=q.front();q.pop(),vis[u]=0;\n\t\tgo(u)if(e[i].w&&(cmax(dis[v],dis[u]+e[i].c)?pe[v]=i,1:0)&&!vis[v])q.push(v),vis[v]=1;\n\t}\n\tif(!dis[T])return false;\n\tres+=dis[T];\n\tfor(R int i=T;i!=S;i=e[pe[i]^1].v)--e[pe[i]].w,++e[pe[i]^1].w;\n\treturn true;\n}\nll calc(int k){\n\tfp(i,1,k)LL[i]=DD[i]=0,RR[i]=UU[i]=19260817;\n\tfp(i,1,m)if(b[i]<k){\n\t\tswitch(t[i]){\n\t\t\tcase 'L':LL[b[i]+1]=a[i]+1;break;\n\t\t\tcase 'R':RR[k-b[i]]=a[i]-1;break;\n\t\t\tcase 'D':DD[b[i]+1]=a[i]+1;break;\n\t\t\tcase 'U':UU[k-b[i]]=a[i]-1;break;\n\t\t}\n\t}\n\tfp(i,2,k)cmax(LL[i],LL[i-1]),cmax(DD[i],DD[i-1]);\n\tfd(i,k-1,1)cmin(RR[i],RR[i+1]),cmin(UU[i],UU[i+1]);\n\tmemset(head,0,sizeof(head)),tot=1;\n\tS=0,T=(n+k)<<1|1;\n\tfp(i,1,n)add(i,n+i,v[i]);\n\tfp(i,1,k){\n\t\tadd(S,n+n+i,0),add(n+n+k+i,T,0);\n\t\tfp(j,1,n){\n\t\t\tif(x[j]>=LL[i]&&x[j]<=RR[i])add(n+n+i,j,0);\n\t\t\tif(y[j]>=DD[i]&&y[j]<=UU[i])add(n+j,n+n+k+i,0);\n\t\t}\n\t}\n\tres=0;while(spfa());\n\treturn res;\n}\nint main(){\n//\tfreopen(\"testdata.in\",\"r\",stdin);\n\tn=read();\n\tfp(i,1,n)x[i]=read(),y[i]=read(),v[i]=read();\n\tm=read();\n\tfp(i,1,m)t[i]=getop(),a[i]=read(),b[i]=read();\n\tfp(i,1,n)cmax(ans,calc(i));\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <vector>\n#include <bitset>\n#include <cstdio>\n#include <cctype>\n#include <string>\n#include <numeric>\n#include <cstring>\n#include <cassert>\n#include <climits>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\n#include <functional>\nusing namespace std ;\n#define rep(i, a, b) for (register int i = (a); i <= (b); ++i)\n#define per(i, a, b) for (register int i = (a); i >= (b); --i)\n#define loop(it, v) for (auto it = v.begin(); it != v.end(); it++)\n#define cont(i, x) for (register int i = head[x]; i; i = edge[i].nex)\n#define clr(a) memset(a, 0, sizeof(a))\n#define ass(a, cnt) memset(a, cnt, sizeof(a))\n#define cop(a, b) memcpy(a, b, sizeof(a))\n#define lowbit(x) (x & -x)\n#define all(x) x.begin(), x.end()\n#define SC(t, x) static_cast <t> (x)\n#define ub upper_bound\n#define lb lower_bound\n#define pqueue priority_queue\n#define mp make_pair\n#define pb push_back\n#define pof pop_front\n#define pob pop_back\n#define fi first\n#define se second\n#define y1 y1_\n#define Pi acos(-1.0)\n#define iv inline void\n#define enter putchar('\\n')\n#define siz(x) ((int)x.size())\n#define file(x) freopen(x\".in\", \"r\", stdin),freopen(x\".out\", \"w\", stdout)\ntypedef double db ;\ntypedef long long ll ;\ntypedef unsigned long long ull ;\ntypedef pair <int, int> pii ;\ntypedef vector <int> vi ;\ntypedef vector <pii> vii ;\ntypedef queue <int> qi ;\ntypedef queue <pii> qii ;\ntypedef set <int> si ;\ntypedef map <int, int> mii ;\ntypedef map <string, int> msi ;\nconst int maxn = 2e5 + 5 ;\nconst int inf = 0x3f3f3f3f ;\nconst int iinf = 1 << 30 ;\nconst ll linf = 2e18 ;\nconst ll mod = 998244353 ;\nconst double eps = 1e-7 ;\ntemplate <class T = int> T read()\n{\n\tT f = 1, a = 0;\n\tchar ch = getchar() ;\n\twhile (!isdigit(ch)) { if (ch == '-') f = -1 ; ch = getchar() ; }\n\twhile (isdigit(ch)) { a =  (a << 3) + (a << 1) + ch - '0' ; ch = getchar() ; }\n\treturn a * f ;\n}\n\n#define int ll\n#define inf linf\n\nnamespace mcmf\n{\n\tconst int maxm = 10 * maxn;\n\tint n, s, t;\n\tstruct node\n\t{\n\t\tint nex, to, val, cost;\n\t}\n\tedge[maxm];\n\tint head[maxn], tot = 1;\n\tvoid add_path(int u, int v, int w, int c)\n\t{\n\t\tedge[++ tot] = (node){head[u], v, w, c};\n\t\thead[u] = tot;\n\t}\n\tvoid add_flow(int u, int v, int w, int c)\n\t{\n\t\tadd_path(u, v, w, c);\n\t\tadd_path(v, u, 0, -c);\n\t}\n\tint dist[maxn], pre[maxn], lim[maxn], vis[maxn];\n\tbool spfa()\n\t{\n\t\trep(i, 1, n) dist[i] = inf;\n\t\tqi q;\n\t\tq.push(s), dist[s] = 0, lim[s] = inf, lim[t] = 0;\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tint now = q.front();\n\t\t\tq.pop();\n\t\t\tvis[now] = 0;\n\t\t\tcont(i, now)\n\t\t\t{\n\t\t\t\tint to = edge[i].to, val = edge[i].val, cost = edge[i].cost;\n\t\t\t\tif(!val || dist[to] <= dist[now] + cost) continue;\n\t\t\t\tdist[to] = dist[now] + cost, lim[to] = min(lim[now], val), pre[to] = i ^ 1;\n\t\t\t\tif(!vis[to]) q.push(to), vis[to] = 1;\n\t\t\t}\n\t\t}\n\t\treturn lim[t];\n\t}\n\tint maxflow, mincost;\n\tvoid updata()\n\t{\n\t\tmaxflow += lim[t];\n\t\tfor(int i = t; i != s; i = edge[pre[i]].to)\n\t\t{\n\t\t\tedge[pre[i]].val += lim[t], edge[pre[i] ^ 1].val -= lim[t];\n\t\t\tmincost += lim[t] * edge[pre[i] ^ 1].cost;\n\t\t}\n\t}\n\tvoid clear()\n\t{\n\t\trep(i, 1, n) head[i] = 0;\n\t\ttot = 1;\n\t\tmaxflow = mincost = 0;\n\t}\n}\n\nint n, x[maxn], y[maxn], w[maxn], ans;\n\nint m, t[maxn], a[maxn], b[maxn], pos[maxn];\n\nint minn[maxn], maxx[maxn];\n\nvoid solve(int sum)\n{\n\t// puts(\"------------solve-------------\");\n\t// printf(\"sum : %lld\\n\", sum);\n\tmcmf :: n = 2 * (sum + n + 1);\n\trep(i, 1, sum << 1) maxx[i] = inf, minn[i] = 0;\n\trep(i, 1, m)\n\t{\n\t\tif(b[i] >= sum) continue;\n\t\tif(t[i] == 1) minn[b[i] + 1] = max(minn[b[i] + 1], a[i] + 1);\n\t\tif(t[i] == 2) maxx[sum - b[i]] = min(maxx[sum - b[i]], a[i] - 1);\n\t\tif(t[i] == 3) minn[b[i] + 1 + sum] = max(minn[b[i] + 1 + sum], a[i] + 1);\n\t\tif(t[i] == 4) maxx[sum - b[i] + sum] = min(maxx[sum - b[i] + sum], a[i] - 1);\n\t}\n\trep(i, 2, sum) minn[i] = max(minn[i], minn[i - 1]);\n\tper(i, sum - 1, 1) maxx[i] = min(maxx[i], maxx[i + 1]);\n\trep(i, sum + 2, sum + sum) minn[i] = max(minn[i], minn[i - 1]);\n\tper(i, sum + sum - 1, sum + 1) maxx[i] = min(maxx[i], maxx[i + 1]);\n\t// rep(i, 1, sum)\n\t// {\n\t// \tprintf(\"i : %lld\\n\", i);\n\t// \tputs(\"x : \");\n\t// \tprintf(\"%lld %lld\\n\", minn[i], maxx[i]);\n\t// \tputs(\"y : \");\n\t// \tprintf(\"%lld %lld\\n\", minn[sum + i], maxx[sum + i]);\n\t// }\n\t// puts(\"add_limit success\");\n\tmcmf :: s = mcmf :: n, mcmf :: t = mcmf :: n - 1;\n\trep(i, 1, sum) mcmf :: add_flow(mcmf :: s, i, 1, 0), mcmf :: add_flow(sum + n + n + i, mcmf :: t, 1, 0);\n\trep(i, 1, n)\n\t{\n\t\tmcmf :: add_flow(sum + i, sum + n + i, 1, -w[i]);\n\t\tpos[i] = mcmf :: tot;\n\t\trep(j, 1, sum)\n\t\t{\n\t\t\tif(x[i] >= minn[j] && x[i] <= maxx[j]) mcmf :: add_flow(j, sum + i, 1, 0);\n\t\t\tif(y[i] >= minn[j + sum] && y[i] <= maxx[j + sum]) mcmf :: add_flow(sum + n + i, sum + n + n + j, 1, 0);\n\t\t}\n\t}\n\t// puts(\"build_graph success\");\n\twhile (mcmf :: spfa()) mcmf :: updata();\n\tans = min(ans, mcmf :: mincost);\n\t// printf(\"mincost : %lld\\n\", mcmf :: mincost);\n\t// puts(\"choose : \");\n\t// rep(i, 1, n) if(mcmf :: edge[pos[i]].val == 1) printf(\"%lld \", i);\n\t// enter;\n\tmcmf :: clear();\n\treturn ;\n}\n\nsigned main()\n{\n\tscanf(\"%lld\", &n);\n\trep(i, 1, n) scanf(\"%lld %lld %lld\", &x[i], &y[i], &w[i]);\n\tscanf(\"%lld\", &m);\n\trep(i, 1, m)\n\t{\n\t\tchar tmp;\n\t\tscanf(\"%s\", &tmp);\n\t\tif(tmp == 'L') t[i] = 1;\n\t\tif(tmp == 'R') t[i] = 2;\n\t\tif(tmp == 'D') t[i] = 3;\n\t\tif(tmp == 'U') t[i] = 4;\n\t\tscanf(\"%lld %lld\", &a[i], &b[i]);\n\t}\n\trep(i, 1, n) solve(i);\n\tprintf(\"%lld\\n\", -ans);\n\treturn 0;\n}\n\n\n/*\n\n7\n1 3 6\n1 5 9\n3 1 8\n4 3 8\n6 2 9\n5 4 11\n5 7 10\n4\nL 3 1\nR 2 3\nD 5 3\nU 4 2\n\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define INF 1e15\nusing namespace std;\nstruct Po{int x,y;ll z;}v[85];\nstruct Qu{char ch;int x,y;}c[410];\nstruct Info{int nu,ne,qu;ll co;}a[5010];\nint m,n,s,t,l[85],r[85],b[1010],num,li[100010],la[5010],zh[5010];\nbool vi[5010];\nll nu,ansn,di[5010];\nvoid jb(int x,int y,ll z){\n\ta[++num].nu=y;a[num].ne=b[x];b[x]=num;a[num].co=z;a[num].qu=1;\n\ta[++num].nu=x;a[num].ne=b[y];b[y]=num;a[num].co=-z;a[num].qu=0;\n}\nll que(){\n\tfor (int i=1;i<=t;i++) vi[i]=1,di[i]=INF,la[i]=0,zh[i]=0;\n\tdi[s]=0;vi[s]=0;\n\tint l=1,r=1;li[l]=s;\n\twhile (l<=r){\n\t\tfor (int y=b[li[l]];y;y=a[y].ne){\n\t\t\tif (a[y].qu!=0&&di[a[y].nu]>di[li[l]]+a[y].co){\n\t\t\t\tdi[a[y].nu]=di[li[l]]+a[y].co;\n\t\t\t\tla[a[y].nu]=li[l];zh[a[y].nu]=y;\n\t\t\t\tif (vi[a[y].nu]){li[++r]=a[y].nu;vi[a[y].nu]=0;}\n\t\t\t}\n\t\t}\n\t\tvi[li[l]]=0;\n\t\tl++;\n\t}\n//\tfor (int i=1;i<=t;i++) cout<<i<<' '<<di[i]<<' '<<vi[i]<<' '<<la[i]<<' '<<zh[i]<<endl;\n\tif (di[t]==INF)return -INF;\n\tfor (int i=t;i!=s;i=la[i]){a[zh[i]].qu=0;a[zh[i]^1].qu=1;}\n\treturn INF-di[t];\n}\nint main(){\n\tcin>>n;\n\tfor (int i=1;i<=n;i++)cin>>v[i].x>>v[i].y>>v[i].z;\n\tcin>>m;\n\tfor (int i=1;i<=m;i++) cin>>c[i].ch>>c[i].x>>c[i].y;\n\tfor (int k=1;k<=n;k++){\n\t\tmemset(b,0,sizeof(b));num=1;nu=0;\n\t\ts=n+n+k+k+1;t=n+n+k+k+2;\n\t\tfor (int i=1;i<=k;i++) jb(s,i,0),jb(i+k,t,0);\n\t\tfor (int i=1;i<=k;i++) l[i]=1,r[i]=100;\n\t\tfor (int i=1;i<=m;i++){\n\t\t\tif (c[i].ch=='L'&&c[i].y<k)l[c[i].y+1]=max(l[c[i].y+1],c[i].x+1);\n\t\t\tif (c[i].ch=='R'&&c[i].y<k)r[k-c[i].y]=min(r[k-c[i].y],c[i].x-1);\n\t\t}\n\t\tfor (int i=2;i<=k;i++)l[i]=max(l[i],l[i-1]);\n\t\tfor (int i=k-1;i>=1;i--)r[i]=min(r[i],r[i+1]);\n\t\tfor (int i=1;i<=k;i++)\n\t\t\tfor (int j=1;j<=n;j++)\n\t\t\t\tif (v[j].x>=l[i]&&v[j].x<=r[i])jb(i,j+k+k,0);\n\t\tfor (int i=1;i<=k;i++) l[i]=1,r[i]=100;\n\t\tfor (int i=1;i<=m;i++){\n\t\t\tif (c[i].ch=='D'&&c[i].y<k)l[c[i].y+1]=max(l[c[i].y+1],c[i].x+1);\n\t\t\tif (c[i].ch=='U'&&c[i].y<k)r[k-c[i].y]=min(r[k-c[i].y],c[i].x-1);\n\t\t}\n\t\tfor (int i=2;i<=k;i++)l[i]=max(l[i],l[i-1]);\n\t\tfor (int i=k-1;i>=1;i--)r[i]=min(r[i],r[i+1]);\n\t\tfor (int i=1;i<=k;i++)\n\t\t\tfor (int j=1;j<=n;j++)\n\t\t\t\tif (v[j].y>=l[i]&&v[j].y<=r[i])jb(j+k+k+n,i+k,0);\n\t\tfor (int i=1;i<=n;i++)jb(i+k+k,i+k+k+n,INF-v[i].z);\n\t\tfor (int i=1;i<=k;i++)nu+=que();\n\t\tansn=max(ansn,nu);\n\t}\n\tcout<<ansn<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <sstream>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <cstdlib>\n#include <cstdio>\n#include <iterator>\n#include <functional>\n#include <bitset>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\nclock_t __my_start_clock = clock();\n#else\n#define eprintf(...)\n#endif\n\n#define TIMESTAMP(x) eprintf(\"[\"#x\"] Time : %.3lf s.\\n\", (clock() - __my_start_clock)*1.0/CLOCKS_PER_SEC)\n#define TIMESTAMPf(x,...) eprintf(\"[\" x \"] Time : %.3lf s.\\n\", __VA_ARGS__, (clock() - __my_start_clock)*1.0/CLOCKS_PER_SEC)\n\n#define db(x) cerr << #x << \" = \" << x << endl\n#define db2(x, y) cerr << \"(\" << #x << \", \" << #y << \") = (\" << x << \", \" << y << \")\\n\";\n#define db3(x, y, z) cerr << \"(\" << #x << \", \" << #y << \", \" << #z << \") = (\" << x << \", \" << y << \", \" << z << \")\\n\"\n#define dbv(a) cerr << #a << \" = \"; for (auto xxxx: a) cerr << xxxx << \" \"; cerr << endl\n\n\nusing namespace std;\n\n#ifdef LOCAL\nstatic struct __timestamper {\n  string what;\n  __timestamper(const char* what) : what(what){};\n  __timestamper(const string& what) : what(what){};\n  ~__timestamper(){\n    TIMESTAMPf(\"%s\", what.data());\n\t}\n} __TIMESTAMPER(\"end\");\n#else \nstruct __timestamper {};\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\n\nclass MinCostMaxFlow {\npublic:\n  typedef long long flow_type;\n  typedef long long cost_type;\n  const flow_type FLOW_INF = 1LL << 60;\n  const cost_type COST_INF = 1LL << 60;\nprivate:\n  struct Edge {\n    int to, next;\n    flow_type f, c;\n    cost_type w;\n  };\n\n  int n;\n  vector<int> head;\n  vector<cost_type> phi;\n  vector<Edge> es;\n  cost_type cost;\n\n  cost_type get_cost(int id) {\n    cost_type res = es[id].w - phi[es[id].to] + phi[es[id ^ 1].to];\n    assert(es[id].c > 0 && res >= 0);\n    return res;\n  }\n\n  void pushFlow(int eid, flow_type val) {\n    es[eid].f += val, es[eid].c -= val;\n    es[eid ^ 1].f -= val, es[eid ^ 1].c += val;\n    cost += es[eid].w * val;\n  }\n\n\n  flow_type dijkstra(int s, int t, flow_type limit) {\n    vector<cost_type > d(n, COST_INF);\n    vector<int> pe(n, -1);\n    d[s] = 0;\n\n    priority_queue<pair<cost_type, int>> q;\n    q.push({-d[s], s});\n\n    while (!q.empty()) {\n      auto x = q.top();\n      q.pop();\n\n      int id = x.second;\n      if (x.first != -d[id]) continue;\n\n      for (int e = head[id]; e != -1; e = es[e].next) {\n        if (es[e].c == 0) continue;\n        int to = es[e].to;\n        if (d[to] > d[id] + get_cost(e)) {\n          d[to] = d[id] + get_cost(e);\n          q.push({-d[to], to});\n          pe[to] = e;\n        }\n      }\n    }\n\n    for (int i = 0; i < n; i++) {\n      phi[i] += d[i];\n    }\n\n    if (pe[t] == -1) return 0;\n\n    flow_type res = FLOW_INF;\n    if (limit > 0) res = min(res, limit);\n    int v = t;\n    while (v != s) {\n      res = min(res, es[pe[v]].c);\n      v = es[pe[v] ^ 1].to;\n    }\n    v = t;\n    while (v != s) {\n      pushFlow(pe[v], res);\n      v = es[pe[v] ^ 1].to;\n    }\n    return res;\n  };\n\npublic:\n  explicit MinCostMaxFlow(int n) : n(n), head(n, -1), phi(n, 0), cost(0) {}\n\n  int addEdge(int from, int to, flow_type c, cost_type w) {\n    int id = (int) es.size();\n    es.push_back({to, head[from], 0, c, w});\n    head[from] = id;\n    es.push_back({from, head[to], 0, 0, -w});\n    head[to] = id ^ 1;\n    return id;\n  }\n\n  pair<flow_type, cost_type> getFlow(int s, int t, flow_type k = -1) {\n    flow_type res = 0;\n\n    while (true) {\n      flow_type cur = dijkstra(s, t, k - res);\n      res += cur;\n      if (cur == 0 || res == k) break;\n    }\n\n    return {res, cost};\n  }\n};\n\nclass MinCostLRFlow {\n  MinCostMaxFlow flow;\n  MinCostMaxFlow::flow_type need;\npublic:\n\n  int n;\n  MinCostLRFlow(int n) : flow(n + 2), need(0), n(n) {}\n\n  MinCostMaxFlow::cost_type getFlow(int s, int t) {\n    flow.addEdge(t, s, flow.FLOW_INF, 0);\n    auto res = flow.getFlow(n, n + 1);\n    if (res.first != need) {\n      return -1;\n    }\n    return res.second;\n  }\n\n  void addEdge(int from, int to, int l, int r, MinCostMaxFlow::cost_type cost) {\n//    eprintf(\"[%d, %d] from %d to %d, cost = %lld\\n\", from, to, l, r, cost);\n    flow.addEdge(from, to, r - l, cost);\n    if (l) {\n      flow.addEdge(n, to, l, cost);\n      flow.addEdge(from, n + 1, l, 0);\n      need += l;\n    }\n  }\n};\n\nstruct point {\n  int x, y;\n  ll w;\n};\n\nstruct restriction {\n  char ty;\n  int a, b;\n};\n\nint main() {\n#ifdef LOCAL\n  freopen(\"e.in\", \"r\", stdin);\n  freopen(\"e.out\", \"w\", stdout);\n#endif\n\n  int n;\n  while (scanf(\"%d\", &n) == 1) {\n    vector<point> ps(n);\n    for (int i = 0; i < n; i++) {\n      scanf(\"%d%d%lld\", &ps[i].x, &ps[i].y, &ps[i].w);\n    }\n    int m;\n    scanf(\"%d\", &m);\n    vector<restriction> rs(m);\n    for (int i = 0; i < m; i++) {\n      scanf(\" %c%d%d\", &rs[i].ty, &rs[i].a, &rs[i].b);\n    }\n\n    vector<int> xs, ys;\n    ll sum = 0;\n    for (int i = 0; i < n; i++) {\n      xs.push_back(ps[i].x);\n      ys.push_back(ps[i].y);\n      sum += ps[i].w;\n    }\n\n    for (int i = 0; i < m; i++) {\n      if (rs[i].ty == 'U' || rs[i].ty == 'D') {\n        ys.push_back(rs[i].a);\n      } else {\n        xs.push_back(rs[i].a);\n      }\n    }\n\n    sort(xs.begin(), xs.end()), xs.erase(unique(xs.begin(), xs.end()), xs.end());\n    sort(ys.begin(), ys.end()), ys.erase(unique(ys.begin(), ys.end()), ys.end());\n\n    ll ans = -1;\n    for (int remove = 0; remove <= n; remove++) {\n//      eprintf(\"remove = %d\\n\", remove);\n      MinCostLRFlow flow(2 + 2 * (int)xs.size() + 2 * (int)ys.size());\n      int x_start = 0;\n      int y_start = x_start + (int)xs.size();\n      int x_sum_start = y_start + (int)ys.size();\n      int y_sum_start = x_sum_start + (int)xs.size();\n      int s = y_sum_start + (int)ys.size();\n      int t = s + 1;\n      assert(t == flow.n - 1);\n      for (const auto &p : ps) {\n        int x = lower_bound(xs.begin(), xs.end(), p.x) - xs.begin();\n        int y = lower_bound(ys.begin(), ys.end(), p.y) - ys.begin();\n        flow.addEdge(x, y + y_start, 0, 1, p.w);\n      }\n\n      bool fail = false;\n\n      flow.addEdge(s, y_sum_start - 1, remove, remove, 0);\n      for (int i = 0; i < (int)xs.size(); i++) {\n        flow.addEdge(x_sum_start + i, x_start + i, 0, n, 0);\n        if (i != 0) {\n          int lf = 0;\n          int rg = n;\n\n          int cnt = 0;\n          for (const auto &p : ps) {\n            if (p.x <= xs[i - 1]) {\n              cnt++;\n            }\n          }\n\n          for (const auto& r : rs) {\n            if (r.ty == 'L' && r.a >= xs[i - 1]) {\n              lf = max(lf, cnt - r.b);\n            } else if (r.ty == 'R' && r.a <= xs[i]) {\n              rg = min(rg, r.b + cnt - (n - remove));\n            }\n          }\n\n          if (lf > rg) {\n            fail = true;\n          } else {\n            flow.addEdge(i + x_sum_start, i - 1 + x_sum_start, lf, rg, 0);\n          }\n        }\n      }\n\n      for (int i = 0; i < (int)ys.size(); i++) {\n        flow.addEdge(y_start + i, y_sum_start + i, 0, n, 0);\n        if (i != 0) {\n          int lf = 0;\n          int rg = n;\n          int cnt = 0;\n          for (const auto &p : ps) {\n            if (p.y <= ys[i - 1]) {\n              cnt++;\n            }\n          }\n\n          for (const auto& r : rs) {\n            if (r.ty == 'D' && r.a >= ys[i - 1]) {\n              lf = max(lf, cnt - r.b);\n            } else if (r.ty == 'U' && r.a <= ys[i]) {\n              rg = min(rg, r.b + cnt - (n - remove));\n            }\n          }\n          if (lf > rg) {\n            fail = true;\n          } else {\n            flow.addEdge(i + y_sum_start - 1, i + y_sum_start, lf, rg, 0);\n          }\n        }\n      }\n      flow.addEdge(y_sum_start + (int)ys.size() - 1, t, 0, n, 0);\n\n      if (!fail) {\n        ll res = flow.getFlow(s, t);\n//        eprintf(\"res = %lld\\n\", res);\n        if (res != -1) {\n          ans = max(ans, sum - res);\n        }\n      }\n    }\n    printf(\"%lld\\n\", ans);\n\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define all(x) (x).begin (),(x).end()\n#define sqrt(x) sqrt(abs(x))\n#define re return\n#define sz(x) ((int)(x).size ())\n#define prev PREV\n#define next NEXT\n\nusing ll = long long;\nusing ii = pair<int, int>;\nusing ld = long double;\nusing D = double;\nusing vi = vector<int>;\nusing vii = vector<ii>;\nusing vvi = vector<vi>;\nusing vs = vector<string>;\n\ntemplate<typename T> T abs (T x) { re x < 0 ? -x : x; }\ntemplate<typename T> T sgn (T x) { re x < 0 ? -1 : (x > 0 ? 1 : 0); }\ntemplate<typename T> T sqr (T x) { re x * x; }\ntemplate<typename T> T gcd (T a, T b) { re a != 0 ? gcd (b % a, a) : b; }\n\nconst int inf = 1e9;\nconst ll INF = 1e15;\n\nint n;\nint m;\nint o, e;\nint x[200];\nint y[200];\nll val[200];\nint a[400];\nint b[400];\nstring t[400];\nvi vx, vy;\nint lx[200];\nint rx[200];\nint ly[200];\nint ry[200];\n\nvii v[2000];\nint ec[200000];\nll ef[200000];\nll d[2000];\nll p[2000];\nint mark[2000];\nint prev[2000];\nint preve[2000];\nset<pair<ll, int> > all;\n\n\nvoid addedge (int a, int b, int c, ll d) {\n//\tprintf (\"%d %d %d %I64d\\n\", a, b, c, d);\n\tv[a].pb (mp (b, e));\n\tec[e] = c;\n\tef[e] = d;\n\te++;\n\tv[b].pb (mp (a, e));\n\tec[e] = 0;\n\tef[e] = -d;\n\te++;\n}\n\nll go (int S, int T) {\n\tall.clear ();\n\tfor (int i = 0; i < o; i++) {\n\t\tmark[i] = 0;\n\t\td[i] = 1e18;\n\t}\n\tmark[S] = 1;\n\td[S] = 0;\n\tall.insert (mp (0, S));\n\twhile (!all.empty ()) {\n\t\tint x = all.begin ()->se;\n//\t\tprintf (\"%d\\n\", x);\n\t\tmark[x] = 2;\n\t\tall.erase (all.begin ());\n\t\tfor (int i = 0; i < sz (v[x]); i++) {\n\t\t\tint y = v[x][i].fi;\n\t\t\tint z = v[x][i].se;\n\t\t\tif (ec[z] > 0 && d[x] + p[x] + ef[z] - p[y] < d[y]) {\n\t\t\t\tif (mark[y] == 1) all.erase (mp (d[y], y));\n\t\t\t\td[y] = d[x] + p[x] + ef[z] - p[y];\n\t\t\t\tprev[y] = x;\n\t\t\t\tpreve[y] = z;\n\t\t\t\tmark[y] = 1;\n\t\t\t\tall.insert (mp (d[y], y));\n\t\t\t}\n\t\t}\n\t}\n\tif (mark[T] == 0) re -1;\n\tll ans = d[T] - p[S] + p[T];\n\tfor (int i = 0; i < o; i++)\n\t\tif (mark[i])\n\t\t\tp[i] += d[i];\n\tre ans;\n}\n\nll calc (int h) {\n\tint ox = sz (vx);\n\tint oy = sz (vy);\n\tfor (int i = 0; i < ox; i++) {\n\t\tlx[i] = 0;\n\t\trx[i] = h;\n\t\tfor (int j = 0; j < m; j++)\n\t\t\tif (t[j] == \"L\") {\n\t\t\t\tif (vx[i] <= a[j]) rx[i] = min (rx[i], b[j]);\n\t\t\t} else\n\t\t\tif (t[j] == \"R\") {\n\t\t\t\tif (vx[i] >= a[j] - 1) lx[i] = max (lx[i], h - b[j]);\n\t\t\t}\n\t\tif (lx[i] > rx[i]) re -1;\t\n\t}\n\tfor (int i = 0; i < oy; i++) {\n\t\tly[i] = 0;\n\t\try[i] = h;\n\t\tfor (int j = 0; j < m; j++)\n\t\t\tif (t[j] == \"D\") {\n\t\t\t\tif (vy[i] <= a[j]) ry[i] = min (ry[i], b[j]);\n\t\t\t} else\n\t\t\tif (t[j] == \"U\") {\n\t\t\t\tif (vy[i] >= a[j] - 1) ly[i] = max (ly[i], h - b[j]);\n\t\t\t}\n\t\tif (ly[i] > ry[i]) re -1;\t\n\t}\n\to = 2 * ox + 2 * oy + 2 * n + 5;\n\te = 0;\n\tfor (int i = 0; i < o; i++) v[i].clear ();\n\tint req = 0;\n\taddedge (o - 4, 2 * n + 2 * (ox - 1), inf, 0);\n\tfor (int i = 0; i < ox; i++) {\n//\t\tprintf (\"x %d: %d %d\\n\", vx[i], lx[i], rx[i]);\n\t\treq += lx[i];\n\t\taddedge (2 * n + 2 * i, 2 * n + 2 * i + 1, rx[i] - lx[i], 0);\n\t\taddedge (o - 2, 2 * n + 2 * i + 1, lx[i], 0);\n\t\taddedge (2 * n + 2 * i, o - 1, lx[i], 0);\n\t\tif (i > 0) addedge (2 * n + 2 * i + 1, 2 * n + 2 * (i - 1), inf, 0);\n\t}\n\taddedge (2 * n + 2 * ox + 2 * (oy - 1) + 1, o - 3, inf, 0);\n\tfor (int i = 0; i < oy; i++) {\n//\t\tprintf (\"y %d: %d %d\\n\", vy[i], ly[i], ry[i]);\n\t\treq += ly[i];\n\t\taddedge (2 * n + 2 * ox + 2 * i, 2 * n + 2 * ox + 2 * i + 1, ry[i] - ly[i], 0);\n\t\taddedge (o - 2, 2 * n + 2 * ox + 2 * i + 1, ly[i], 0);\n\t\taddedge (2 * n + 2 * ox + 2 * i, o - 1, ly[i], 0);\n\t\tif (i > 0) addedge (2 * n + 2 * ox + 2 * (i - 1) + 1, 2 * n + 2 * ox + 2 * i, inf, 0);\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\taddedge (2 * i, 2 * i + 1, 1, INF - val[i]);\n\t\tint j = 0;\n\t\twhile (vx[j] < x[i]) j++;\n\t\taddedge (2 * n + 2 * j + 1, 2 * i, inf, 0);\n\t\tj = 0;\n\t\twhile (vy[j] < y[i]) j++;\n\t\taddedge (2 * i + 1, 2 * n + 2 * ox + 2 * j, inf, 0);\n\t}\n\treq += h;\n\taddedge (o - 3, o - 5, inf, 0);\n\taddedge (o - 2, o - 4, h, 0);\n\taddedge (o - 5, o - 1, h, 0);\n\tll ans = 0;\n\tfor (int i = 0; i < o; i++) p[i] = 0;\n\tfor (int i = 0; i < req; i++) {\n\t\tll tmp = go (o - 2, o - 1);\n//\t\tprintf (\"%d: %d = %I64d\\n\", h, i, INF - tmp);\n\t\tif (tmp == -1) re -1;\n\t\tans += tmp;\n\t\tint j = o - 1;\n\t\twhile (j != o - 2) {\n\t\t\tint k = prev[j];\n\t\t\tint z = preve[j];\n\t\t\tec[z]--;\n\t\t\tec[z ^ 1]++;\n//\t\t\tprintf (\"%d -> %d = %d\\n\", k / 2, j / 2, ec[z]);\n\t\t\tj = k;\n\t\t}\n\t}\n\tll tmp = go (o - 2, o - 1);\n\tre h * INF - ans;\n}\n\nint main () {\n\tcin >> n;\n\tfor (int i = 0; i < 100; i++) {\n\t\tvx.pb (i + 1);\n\t\tvy.pb (i + 1);\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x[i] >> y[i] >> val[i];\n\t\tvx.pb (x[i]);\n\t\tvy.pb (y[i]);\n\t}\t\n\tcin >> m;\n\tfor (int i = 0; i < m; i++) {\n\t\tcin >> t[i] >> a[i] >> b[i];\n\t\tif (t[i] == \"L\" || t[i] == \"R\") vx.pb (a[i]); else vy.pb (a[i]);\n\t}\n\tsort (all (vx));\n\tvx.resize (unique (all (vx)) - vx.begin ());\n\tsort (all (vy));\n\tvy.resize (unique (all (vy)) - vy.begin ());\n\tll ans = 0;\n\tfor (int t = 0; t <= n; t++) {\n\t\tll tmp = calc (t);\n\t\tans = max (ans, tmp);\n//\t\tcout << t << \" \" << tmp << endl;\n\t}\t\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int mod = 1e9 + 7;\nconst int inf = (1 << 30) - 1;\nconst int64 infll = (1LL << 61) - 1;\n\nstruct IoSetup {\n  IoSetup() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    cerr << fixed << setprecision(10);\n  }\n} iosetup;\n\ntemplate< typename T >\nostream &operator<<(ostream &os, const vector< T > &v) {\n  for(int i = 0; i < (int) v.size(); i++) {\n    os << v[i] << (i + 1 != v.size() ? \" \" : \"\");\n  }\n  return os;\n}\n\ntemplate< typename T >\nistream &operator>>(istream &is, vector< T > &v) {\n  for(T &in : v) is >> in;\n  return is;\n}\n\ntemplate< typename T1, typename T2 >\ninline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\ntemplate< typename T1, typename T2 >\ninline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\ntemplate< typename T = int64 >\nvector< T > make_v(size_t a) {\n  return vector< T >(a);\n}\n\ntemplate< typename T, typename... Ts >\nauto make_v(size_t a, Ts... ts) {\n  return vector< decltype(make_v< T >(ts...)) >(a, make_v< T >(ts...));\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value == 0 >::type fill_v(T &t, const V &v) {\n  t = v;\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value != 0 >::type fill_v(T &t, const V &v) {\n  for(auto &e : t) fill_v(e, v);\n}\n\n\nint N, M;\nint L[100], R[100], U[100], D[100];\n\nint main() {\n  cin >> N;\n  vector< pair< int, pair< int, int64 > > > mx;\n  for(int i = 0; i < N; i++) {\n    int x, y;\n    int64 v;\n    cin >> x >> y >> v;\n    --x, --y;\n    mx.emplace_back(x, make_pair(y, v));\n  }\n  cin >> M;\n  for(int i = 0; i < 100; i++) {\n    L[i] = R[i] = U[i] = D[i] = N;\n  }\n  for(int i = 0; i < M; i++) {\n    char t;\n    int a, b;\n    cin >> t >> a >> b;\n    --a;\n    if(t == 'L') L[a] = min(L[a], b);\n    else if(t == 'R') R[a] = min(R[a], b);\n    else if(t == 'D') D[a] = min(D[a], b);\n    else U[a] = min(U[a], b);\n  }\n  for(int i = 98; i >= 0; i--) {\n    L[i] = min(L[i], L[i + 1]);\n    D[i] = min(D[i], D[i + 1]);\n  }\n  for(int i = 1; i < 100; i++) {\n    R[i] = min(R[i], R[i - 1]);\n    U[i] = min(U[i], U[i - 1]);\n  }\n\n  sort(begin(mx), end(mx));\n  map< vector< int >, int64 > dp[81][81];\n\n  vector< int > used(100);\n  dp[0][N][used] = 0;\n  // used, min\n  int64 ret = 0;\n  for(auto &p : mx) { // 80\n    for(int j = N; j >= 0; j--) { // 80\n      for(int k = N; k >= 0; k--) { // 80\n        for(auto o : dp[j][k]) {\n          if(j + 1 <= L[p.first] && min(k, R[p.first]) - 1 >= 0) {\n\n            vector< int > renew = o.first;\n            renew[p.second.first]++;\n            int sum = 0;\n            bool f = true;\n            for(int l = 0; l < 100; l++) {\n              sum += renew[l];\n              if(sum > D[l]) f = false;\n            }\n            sum = 0;\n            for(int l = 99; l >= 0; l--) {\n              sum += renew[l];\n              if(sum > U[l]) f = false;\n            }\n\n            if(f) {\n              chmax(dp[j + 1][min(k, R[p.first]) - 1][renew], o.second + p.second.second);\n              chmax(ret, o.second + p.second.second);\n            }\n\n          }\n        }\n      }\n    }\n  }\n  cout << ret << endl;\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 85 * 2 + 5;\nconst int M = N * N;\n\ntypedef long long LL;\nconst LL Base = 1e15, INF = 1e18;\n\nint n, v, m, T[N], a[N], b[N], num, L[N], R[N], U[N], D[N];\nchar s[N];\nlong long ans = 0;\n\nstruct NODE {\n\tint x, y;\n\tlong long v;\n\tvoid input() {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tscanf(\"%lld\", &v);\n\t}\n}P[N];\n\nint chg(char c) {\n\tif(c == 'L') return 0;\n\tif(c == 'R') return 1;\n\tif(c == 'D') return 2;\n\treturn 3;\n}\n\nnamespace CostFlow {\n\t\n\tint fir[N], ne[M], to[M], C[M], cnt, s, t, vis[N], tim, pre[N];\n\tLL dis[N], Cost[M], res;\n\t\n\tvoid init() {\n\t\tres = 0;\n\t\tmemset(fir, 0, sizeof(fir));\n\t\tcnt = 1;\n\t}\n\t\n\tvoid add(int x, int y, int fl, LL Co) {\n\t\tne[++ cnt] = fir[x];\n\t\tfir[x] = cnt;\n\t\tto[cnt] = y;\n\t\tC[cnt] = fl;\n\t\tCost[cnt] = Co;\n\t}\n\t\n\tvoid link(int x, int y, int fl, LL Co) {\n\t\tadd(x, y, fl, Co);\n\t\tadd(y, x, 0, -Co);\n\t}\n\t\n\t#define Foreachson(i, x) for(int i = fir[x]; i; i = ne[i])\n\t\n\tbool inq[N];\n\t\n\tbool SPFA(int s, int t) {\n\t\tqueue <int> q;\n\t\twhile(!q.empty()) q.pop();\n\t\tfor(int i = s; i <= t; ++ i) dis[i] = -1, inq[i] = 0, pre[i] = 0;\n\t\tdis[s] = 0;\n\t\tq.push(s); inq[s] = 1;\n\t\twhile(!q.empty()) {\n\t\t\tint ind = q.front(); inq[ind] = 0;\n\t\t\tq.pop();\n\t\t\tForeachson(i, ind) if(C[i]) {\n\t\t\t\tint V = to[i];\n\t\t\t\tif(dis[V] < dis[ind] + Cost[i]) {\n\t\t\t\t\tdis[V] = dis[ind] + Cost[i];\n\t\t\t\t\tpre[V] = i;\n\t\t\t\t\tif(!inq[V]) q.push(V), inq[V] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dis[t] == -1) return 0;\n\t\treturn 1;\n\t}\n\t\n\tLL CostFlow() {\n\t\tLL res = 0;\n\t\tint tot = 0;\n\t\twhile(SPFA(s, t)) {\n\t\t\tres += dis[t];\n\t\t\t++ tot;\n\t\t\tint now = t;\n\t\t\twhile(now != s) {\n\t\t\t\t-- C[pre[now]]; ++ C[pre[now] ^ 1];\n\t\t\t\tnow = to[pre[now] ^ 1];\n\t\t\t}\n\t\t}\n\t\t//cerr << tot << endl;\n\t\treturn res;\n\t}\n}\n\nLL solve(int num) {\n\tfor(int i = 1; i <= num; ++ i) L[i] = D[i] = 0, R[i] = U[i] = 101;\n\tfor(int i = 1; i <= m; ++ i) {\n\t\tif(b[i] >= num) continue;\n\t\tif(T[i] == 0) L[b[i] + 1] = max(L[b[i] + 1], a[i] + 1);\n\t\tif(T[i] == 2) D[b[i] + 1] = max(D[b[i] + 1], a[i] + 1);\n\t\tif(T[i] == 1) R[num - b[i]] = min(R[num - b[i]], a[i] - 1);\n\t\tif(T[i] == 3) U[num - b[i]] = min(U[num - b[i]], a[i] - 1);\n\t}\n\tfor(int i = 1; i < num; ++ i) {\n\t\tL[i + 1] = max(L[i + 1], L[i]);\n\t\tD[i + 1] = max(D[i + 1], D[i]);\n\t}\n\tfor(int i = num - 1; i >= 1; -- i) {\n\t\tU[i] = min(U[i], U[i + 1]);\n\t\tR[i] = min(R[i], R[i + 1]);\n\t}\n\tCostFlow :: init();\n\tint s = 1, t = 2 * num + 2 * n + 2;\n\tCostFlow :: s = 1, CostFlow :: t = 2 * num + 2 * n + 2;\n\t\n\tfor(int i = 1; i <= num; ++ i)\n\tCostFlow :: link(s, 2 * n + 1 + i, 1, 0), \n\tCostFlow :: link(2 * n + 1 + num + i, t, 1, 0);\n\t\n\tfor(int i = 1; i <= n; ++ i) {\n\t\tCostFlow :: link(i * 2, i * 2 + 1, 1, P[i].v);\n\t\tfor(int j = 1; j <= num; ++ j) {\n\t\t\tif(L[j] <= P[i].x && P[i].x <= R[j]) {\n\t\t\t\tCostFlow :: link(2 * n + 1 + j, i * 2, 1, 0);\n\t\t\t}\n\t\t\tif(D[j] <= P[i].y && P[i].y <= U[j]) {\n\t\t\t\tCostFlow :: link(i * 2 + 1, 2 * n + num + 1 + j, 1, 0);\n\t\t\t}\n\t\t}\n\t}\n\tLL res = CostFlow :: CostFlow();\n\t//cerr << num <<\" \" << res << endl;\n\treturn res;\n}\n\nint main(void) {\n\tcin >> n;\n\tfor(int i = 1; i <= n; ++ i) P[i].input();\n\tcin >> m;\n\tfor(int i = 1; i <= m; ++ i) {\n\t\tscanf(\"%s\", s);\n\t\tT[i] = chg(s[0]);\n\t\tscanf(\"%d%d\", &a[i], &b[i]);\n\t}\n\tfor(num = 1; num <= n; ++ num) {\n\t\tans = max(ans, solve(num));\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<cmath>\nusing namespace std;\n\nconst int N = 410, M = 3010;\n\nint AA[M][N], BB[M];\n\nstruct Simplex {\n\tusing T = long double;\n\tconst T eps = 1e-10;\n\tint n, m;\n\tint Left[M], Down[N];\n\t// time complexity: exponential. fast $O(MN^2)$ in experiment. dependent on the modeling.\n\t// Ax <= b, max c^T x. 최댓값: v, 답 추적: sol[i]. 1 based\n\tT a[M][N], b[M], c[N], v, sol[N];\n\tbool eq(T a, T b) { return fabs(a - b) < eps; }\n\tbool ls(T a, T b) { return a < b && !eq(a, b); }\n\tvoid init(int p, int q) {\n\t\tn = p; m = q; v = 0;\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) a[i][j] = 0;\n\t\t}\n\t\tfor (int i = 1; i <= m; i++) b[i] = 0;\n\t\tfor (int i = 1; i <= n; i++) c[i] = sol[i] = 0;\n\t}\n\tvoid pivot(int x, int y) {\n\t\tswap(Left[x], Down[y]);\n\t\tT k = a[x][y]; a[x][y] = 1;\n\t\tvector<int> nz;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\ta[x][i] /= k;\n\t\t\tif (!eq(a[x][i], 0)) nz.push_back(i);\n\t\t}\n\t\tb[x] /= k;\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tif (i == x || eq(a[i][y], 0)) continue;\n\t\t\tk = a[i][y]; a[i][y] = 0;\n\t\t\tb[i] -= k * b[x];\n\t\t\tfor (int j : nz) a[i][j] -= k * a[x][j];\n\t\t}\n\t\tif (eq(c[y], 0)) return;\n\t\tk = c[y]; c[y] = 0;\n\t\tv += k * b[x];\n\t\tfor (int i : nz) c[i] -= k * a[x][i];\n\t}\n\t// 0: found solution, 1: no feasible solution, 2: unbounded\n\tint solve() {\n\t\tfor (int i = 1; i <= n; i++) Down[i] = i;\n\t\tfor (int i = 1; i <= m; i++) Left[i] = n + i;\n\t\twhile (1) { // Eliminating negative b[i]\n\t\t\tint x = 0, y = 0;\n\t\t\tfor (int i = 1; i <= m; i++) if (ls(b[i], 0) && (x == 0 || b[i] < b[x])) x = i;\n\t\t\tif (x == 0) break;\n\t\t\tfor (int i = 1; i <= n; i++) if (ls(a[x][i], 0) && (y == 0 || a[x][i] < a[x][y])) y = i;\n\t\t\tif (y == 0) return 1;\n\t\t\tpivot(x, y);\n\t\t}\n\t\twhile (1) {\n\t\t\tint x = 0, y = 0;\n\t\t\tfor (int i = 1; i <= n; i++)\n\t\t\t\tif (ls(0, c[i]) && (!y || c[i] > c[y])) y = i;\n\t\t\tif (y == 0) break;\n\t\t\tfor (int i = 1; i <= m; i++)\n\t\t\t\tif (ls(0, a[i][y]) && (!x || b[i] / a[i][y] < b[x] / a[x][y])) x = i;\n\t\t\tif (x == 0) return 2;\n\t\t\tpivot(x, y);\n\t\t}\n\t\tfor (int i = 1; i <= m; i++) if (Left[i] <= n) sol[Left[i]] = b[i];\n\t\treturn 0;\n\t}\n}SS;\n\nstruct point {\n\tint x, y;\n}w[81];\nlong long cost[81];\n\nstruct AA {\n\tint a;\n\tlong double t;\n\tbool operator<(const AA &p)const {\n\t\treturn t < p.t;\n\t}\n}ord[81];\n\nint main() {\n\tint n, m;\n\tint i, j, k;\n\tscanf(\"%d\", &n);\n\tfor (i = 1; i <= n; i++) {\n\t\tlong long t;\n\t\tscanf(\"%d%d%lld\", &w[i].x, &w[i].y, &cost[i]);\n\t}\n\tscanf(\"%d\", &m);\n\n\tSS.init(n, n+m);\n\tfor (i = 1; i <= n; i++) {\n\t\tSS.c[i] = cost[i];\n\t}\n\tfor (i = 1; i <= m; i++) {\n\t\tchar pp[3];\n\t\tint a, b;\n\t\tscanf(\"%s\", pp);\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tSS.b[i] = b;\n\t\tBB[i] = b;\n\t\tif (pp[0] == 'L') {\n\t\t\tfor (j = 1; j <= n; j++) {\n\t\t\t\tif (w[j].x <= a) {\n\t\t\t\t\tSS.a[i][j] = 1;\n\t\t\t\t\tAA[i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (pp[0] == 'R') {\n\t\t\tfor (j = 1; j <= n; j++) {\n\t\t\t\tif (w[j].x >= a) {\n\t\t\t\t\tSS.a[i][j] = 1;\n\t\t\t\t\tAA[i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (pp[0] == 'D') {\n\t\t\tfor (j = 1; j <= n; j++) {\n\t\t\t\tif (w[j].y <= a) {\n\t\t\t\t\tSS.a[i][j] = 1;\n\t\t\t\t\tAA[i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (pp[0] == 'U') {\n\t\t\tfor (j = 1; j <= n; j++) {\n\t\t\t\tif (w[j].y >= a) {\n\t\t\t\t\tSS.a[i][j] = 1;\n\t\t\t\t\tAA[i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 1; i <= n; i++) {\n\t\tSS.a[i + m][i] = 1;\n\t\tSS.b[i + m] = 1;\n\t}\n\tSS.solve();\n\tfor (i = 1; i <= n; i++) {\n\t\tord[i] = { i,SS.sol[i] };\n\t}\n\tsort(ord + 1, ord + n + 1);\n\tfor (i = 1; i <= n; i++) {\n\t\tfor (j = 1; j <= m; j++) {\n\t\t\tint c = 0;\n\t\t\tfor (k = i; k <= n; k++) {\n\t\t\t\tif (AA[j][ord[k].a])c++;\n\t\t\t}\n\t\t\tif (BB[j] < c)break;\n\t\t}\n\t\tif (j == m + 1) {\n\t\t\tlong long res = 0;\n\t\t\tfor (j = i; j <= n; j++) {\n\t\t\t\tres += cost[ord[j].a];\n\t\t\t}\n\t\t\tprintf(\"%lld\\n\", res);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tputs(\"0\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\ntypedef long double louble;\n\n#define so(a) ((int)((a).size()))\n\ntemplate<typename T1,typename T2> inline T1 max(T1 a,T2 b){return a<b?b:a;}\ntemplate<typename T1,typename T2> inline T1 min(T1 a,T2 b){return a<b?a:b;}\n\nconst char lf = '\\n';\n\nnamespace ae86\n{\n\tconst int bufl = 1 << 15;\n\n\tchar buf[bufl],*s=buf,*t=buf;\n\n\tinline int fetch()\n\t{\n\t\tif(s==t){t=(s=buf)+fread(buf,1,bufl,stdin);if(s==t)return EOF;}\n\t\treturn *s++;\n\t}\n\n\tinline lint ty()\n\t{\n\t\tlint a=0;int b=1,c=fetch();\n\t\twhile(!isdigit(c))b^=c=='-',c=fetch();\n\t\twhile(isdigit(c))a=a*10+c-48,c=fetch();\n\t\treturn b?a:-a;\n\t}\n\n\tinline int tc()\n\t{\n\t\tint c=fetch();\n\t\twhile(c<=32 && c!=EOF)c=fetch();\n\t\treturn c;\n\t}\n}\nusing ae86::ty;\nusing ae86::tc;\n\nconst int _ = 407 , inf = 0x3f3f3f3f;\nconst lint V = 1e16 , linf = 0x3f3f3f3f3f3f3f3f;\n\nstruct costflow\n{\n\tstatic const int _n = _ , _e = _ * 9999;\n\n\tint to[_e],ne[_e],he[_n],ecnt;\n\tlint ev[_e],ec[_e];\n\n\tvoid adde(int a,int b,lint c,lint d){to[++ecnt]=b,ev[ecnt]=c,ec[ecnt]=d,ne[ecnt]=he[a],he[a]=ecnt;}\n\tvoid addde(int a,int b,lint c,lint d){adde(a,b,c,d),adde(b,a,0,-d);}\n\n\tint S,T,ed[_n],dcnt;\n\tlint dis[_n];int pv[_n],pe[_n];\n\t\n\tint bfs()\n\t{\n\t\tmemset(dis,63,sizeof(lint)*(dcnt+2));\n\t\tmemset(pv,0,sizeof(int)*(dcnt+2));\n\t\tmemset(pe,0,sizeof(int)*(dcnt+2));\n\t\tmemset(ed,0,sizeof(int)*(dcnt+2));\n\t\t\n\t\tqueue<int> q;\n\t\tdis[S]=0,ed[S]=1,q.emplace(S);\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tint a=q.front();\n\t\t\tq.pop(),ed[a]=0;\n\t\t\tfor(int i=he[a];i;i=ne[i])\n\t\t\t{\n\t\t\t\tif(!ev[i])continue;\n\t\t\t\tint b=to[i];\n\t\t\t\tif(dis[a]+ec[i]>=dis[b])continue;\n\t\t\t\tdis[b]=dis[a]+ec[i],pe[b]=i,pv[b]=a;\n\t\t\t\tif(!ed[b])q.emplace(b),ed[b]=1;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn dis[T]<linf;\n\t}\n\n\tpair<lint,lint> run(int s,int t)\n\t{\n\t\tS=s,T=t;\n\t\tlint sflw=0,scos=0;\n\t\twhile(bfs())\n\t\t{\n\t\t\tlint dlt=linf;\n\t\t\tfor(int i=T;i!=S;i=pv[i])dlt=min(dlt,ev[pe[i]]);\n\t\t\tsflw+=dlt,scos+=dis[T]*dlt;\n\t\t\tfor(int i=T;i!=S;i=pv[i])ev[pe[i]]-=dlt,ev[pe[i]^1]+=dlt;\n\t\t}\n\t\treturn make_pair(sflw,scos);\n\t}\n\t\n\tvoid cls()\n\t{\n\t\tmemset(he,0,sizeof(he)),ecnt=1,dcnt=0;\n\t}\n}f;\n\nint n,m,px[_],py[_];lint pv[_];\nint dir[_]={0},loc[_]={0},lim[_]={0};\n\nint ll[_],rr[_],uu[_],dd[_];\n\nlint finder(int tar)\n{\n\tf.cls();\n\n\tfor(int i=1;i<=tar;i++)ll[i]=dd[i]=0,rr[i]=uu[i]=inf;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tif(lim[i]>=tar)continue;\n\t\tif(dir[i]=='L')ll[lim[i]+1]=loc[i]+1;\n\t\tif(dir[i]=='R')rr[tar-lim[i]]=loc[i]-1;\n\t\tif(dir[i]=='D')dd[lim[i]+1]=loc[i]+1;\n\t\tif(dir[i]=='U')uu[tar-lim[i]]=loc[i]-1;\n\t}\n\n\tfor(int i=2;i<=tar;i++)ll[i]=max(ll[i],ll[i-1]),dd[i]=max(dd[i],dd[i-1]);\n\tfor(int i=tar-1;i>=1;i--)rr[i]=min(rr[i],rr[i+1]),uu[i]=min(uu[i],uu[i+1]);\n\n\tf.dcnt=n+n+tar+tar;\n\tint s=++f.dcnt,t=++f.dcnt;\n\n\tfor(int i=1;i<=n;i++)f.addde(i,n+i,1,-pv[i]-V);\n\tfor(int i=1;i<=tar;i++)\n\t{\n\t\tf.addde(s,n+n+i,1,0),f.addde(n+n+tar+i,t,1,0);\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tif(ll[i]<=px[j] && px[j]<=rr[i])f.addde(n+n+i,j,1,0);\n\t\t\tif(dd[i]<=py[j] && py[j]<=uu[i])f.addde(n+j,n+n+tar+i,1,0);\n\t\t}\n\t}\n\n\tauto res=f.run(s,t);\n\tif(res.first<tar)return -1;\n\treturn -res.second-V*tar;\n}\n\nint main()\n{\n\tios::sync_with_stdio(0),cout.tie(nullptr);\n\n\tn=ty();\n\tfor(int i=1;i<=n;i++)px[i]=ty(),py[i]=ty(),pv[i]=ty();\n\tm=ty();\n\tfor(int i=1;i<=m;i++)dir[i]=tc(),loc[i]=ty(),lim[i]=ty();\n\t\n\tlint ans=0;\n\tfor(int i=1;i<=n;i++)ans=max(ans,finder(i));\n\tcout<<ans<<lf;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst long long inf=1000000000000000000ll;\nlong long ans,v[111];\nint lx[111],rx[111],ly[111],ry[111],n,x[111],y[111],m,a[331],b[331];\nchar s[331][3];\n\nnamespace flow\n{\n\tstruct node{int to,next,c; long long val;}e[200010];\n\tint n,cnt,hd[410],q[100010],l,r,x,la[410];\n\tlong long dis[410];\n\tbool inq[410];\n\tvoid init(int N)\n\t{\n\t\tn=N,cnt=1;\n\t\tfor (int i=1; i<=n; i++) hd[i]=0;\n\t}\n\tvoid addedge(int x,int y,int c,long long v)\n\t{\n\t\te[++cnt]=(node){y,hd[x],c,v},hd[x]=cnt;\n\t\te[++cnt]=(node){x,hd[y],0,-v},hd[y]=cnt;\n\t}\n\tpair<int,long long> solve()\n\t{\n\t\tint f=0;\n\t\tlong long ans=0;\n\t\twhile (1)\n\t\t{\n\t\t\tdis[1]=0,q[l=r=1]=1,inq[1]=1,la[1]=0;\n\t\t\tfor (int i=2; i<=n; i++) inq[i]=0,dis[i]=inf,la[i]=0;\n\t\t\twhile (l<=r)\n\t\t\t{\n\t\t\t\tx=q[l++];\n\t\t\t\tfor (int i=hd[x]; i; i=e[i].next)\n\t\t\t\t\tif (e[i].c&&dis[e[i].to]>dis[x]+e[i].val)\n\t\t\t\t\t{\n\t\t\t\t\t\tdis[e[i].to]=dis[x]+e[i].val,la[e[i].to]=i;\n\t\t\t\t\t\tif (!inq[e[i].to]) inq[e[i].to]=1,q[++r]=e[i].to;\n\t\t\t\t\t}\n\t\t\t\tinq[x]=0;\n\t\t\t}\n\t\t\tif (dis[n]==inf) break;\n\t\t\tx=n; int nw=1000000000;\n\t\t\twhile (la[x]) nw=min(nw,e[la[x]].c),x=e[la[x]^1].to;\n\t\t\tx=n,f+=nw;\n\t\t\twhile (la[x]) e[la[x]].c-=nw,e[la[x]^1].c+=nw,ans+=e[la[x]].val*nw,x=e[la[x]^1].to;\n\t\t}\n\t\treturn make_pair(f,ans);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\",&n),ans=0;\n\tfor (int i=1; i<=n; i++) scanf(\"%d%d%lld\",&x[i],&y[i],&v[i]);\n\tscanf(\"%d\",&m);\n\tfor (int i=1; i<=m; i++) scanf(\"%s%d%d\",s[i],&a[i],&b[i]);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tflow::init(i*2+n*2+2);\n\t\tfor (int j=1; j<=i; j++) lx[j]=ly[j]=1,rx[j]=ry[j]=100;\n\t\tfor (int j=1; j<=m; j++)\n\t\t\tif (s[j][0]=='U') {if (b[j]<i) ry[i-b[j]]=min(ry[i-b[j]],a[j]-1);} else\n\t\t\tif (s[j][0]=='D') {if (b[j]<i) ly[b[j]+1]=max(ly[b[j]+1],a[j]+1);} else\n\t\t\tif (s[j][0]=='L') {if (b[j]<i) lx[b[j]+1]=max(lx[b[j]+1],a[j]+1);} else\n\t\t\tif (s[j][0]=='R') {if (b[j]<i) rx[i-b[j]]=min(rx[i-b[j]],a[j]-1);}\n\t\tfor (int j=2; j<=i; j++) lx[j]=max(lx[j],lx[j-1]),ly[j]=max(ly[j],ly[j-1]);\n\t\tfor (int j=i-1; j; j--) rx[j]=min(rx[j],rx[j+1]),ry[j]=min(ry[j],ry[j+1]);\n\t\tfor (int j=1; j<=i; j++) \n\t\t{\n\t\t\tflow::addedge(1,j+1,1,0);\n\t\t\tfor (int k=1; k<=n; k++)\n\t\t\t\tif (x[k]>=lx[j]&&x[k]<=rx[j]) flow::addedge(j+1,k+i+1,1,0);\n\t\t\tflow::addedge(j+i+2*n+1,i*2+n*2+2,1,0);\n\t\t\tfor (int k=1; k<=n; k++)\n\t\t\t\tif (y[k]>=ly[j]&&y[k]<=ry[j]) flow::addedge(k+i+n+1,j+i+2*n+1,1,0);\n\t\t}\n\t\tfor (int j=1; j<=n; j++) flow::addedge(j+i+1,j+i+n+1,1,-v[j]);\n\t\tpair<int,long long> nw=flow::solve();\n\t\tif (nw.first==i&&-nw.second>ans) ans=-nw.second;\n\t}\n\treturn printf(\"%lld\\n\",ans),0;\n}"
  },
  {
    "language": "C++",
    "code": "// luogu-judger-enable-o2\n#include<bits/stdc++.h>\n#define ll long long\n#define uint unsigned\n#define ull unsigned ll\n#define db double\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pli pair<ll,int>\n#define vi vector<int>\n#define vpi vector<pii >\n#define IT iterator\n \n#define PB push_back\n#define MK make_pair\n#define LB lower_bound\n#define UB upper_bound\n#define y1 wzpakking\n#define fi first\n#define se second\n#define BG begin\n#define ED end\n \n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a))\n#define CPY(a,b) memcpy(a,b,sizeof(a))\n#define sqr(x) (1ll*x*x)\n \n#define LS3 k*2,l,mid\n#define RS3 k*2+1,mid+1,r\n#define LS5 k*2,l,mid,x,y\n#define RS5 k*2+1,mid+1,r,x,y\n#define GET pushdown(k);int mid=(l+r)/2\n#define inf (1<<30)\nusing namespace std;\nconst int N=1000;\nstruct edge{\n\tint from,to,next,f;\n\tll v;\n}e[N*N];\nint head[N],tot;\nint nd,S,T,idx[N],idy[N];\nvoid add(int x,int y,int f,ll v){\n\te[++tot]=(edge){x,y,head[x],f,v};\n\thead[x]=tot;\n\te[++tot]=(edge){y,x,head[y],0,-v};\n\thead[y]=tot;\n}\nll dis[N];\nint q[N*N],vis[N],from[N];\nbool bfs(){\n\tFor(i,1,nd) dis[i]=-(1ll<<62),vis[i]=0;\n\tint h=0,t=1;\n\tq[1]=S; dis[S]=0;\n\twhile (h!=t){\n\t\tint x=q[++h]; vis[x]=0;\n\t\tfor (int i=head[x];i;i=e[i].next)\n\t\t\tif (dis[e[i].to]<dis[x]+e[i].v&&e[i].f){\n\t\t\t\tdis[e[i].to]=dis[x]+e[i].v;\n\t\t\t\tfrom[e[i].to]=i;\n\t\t\t\tif (!vis[e[i].to]){\n\t\t\t\t\tvis[e[i].to]=1;\n\t\t\t\t\tq[++t]=e[i].to;\n\t\t\t\t}\n\t\t\t}\n\t}\n\treturn dis[T]!=-(1ll<<62);\n}\nvoid del(){\n\tfor (int i=from[T];i;i=from[e[i].from])\n\t\te[i].f--,e[i^1].f++;\n}\nstruct que{\n\tchar s[10];\n\tint x,cnt;\n}qq[N];\nint n,Q;\nint x[N],y[N];\nint mn[N],mx[N];\nll v[N];\nconst int MX=100;\nll work(int cnt){\n\tnd=0; S=++nd; T=++nd; tot=1;\n\tmemset(head,0,sizeof(head));\n\tFor(i,1,MX) idx[i]=++nd,idy[i]=++nd;\n\tFor(i,1,n) add(idx[x[i]],idy[y[i]],1,v[i]);\n\t{\n\t\tFor(i,0,cnt+1) mx[i]=MX,mn[i]=1;\n\t\tFor(i,1,Q){\n\t\t\tif (qq[i].s[0]=='L'&&cnt>=qq[i].cnt+1)\n\t\t\t\tmn[qq[i].cnt+1]=max(mn[qq[i].cnt+1],qq[i].x+1);\n\t\t\tif (qq[i].s[0]=='R'&&cnt>=qq[i].cnt+1)\n\t\t\t\tmx[cnt-qq[i].cnt]=min(mx[cnt-qq[i].cnt],qq[i].x-1);\n\t\t}\n\t\tFor(i,1,cnt) mn[i]=max(mn[i],mn[i-1]);\n\t\tRep(i,cnt,1) mx[i]=min(mx[i],mx[i+1]);\n\t\tFor(i,1,cnt){\n\t\t\tint tmp=++nd;\n\t\t\tif (mn[i]>mx[i]) return 0;\n\t\t\tadd(S,tmp,1,0);\n\t\t\tFor(j,mn[i],mx[i])\n\t\t\t\tadd(tmp,idx[j],1,0);\n\t\t}\n\t}\n\t{\n\t\tFor(i,0,cnt+1) mx[i]=MX,mn[i]=1;\n\t\tFor(i,1,Q){\n\t\t\tif (qq[i].s[0]=='D'&&cnt>=qq[i].cnt+1)\n\t\t\t\tmn[qq[i].cnt+1]=max(mn[qq[i].cnt+1],qq[i].x+1);\n\t\t\tif (qq[i].s[0]=='U'&&cnt>=qq[i].cnt+1)\n\t\t\t\tmx[cnt-qq[i].cnt]=min(mx[cnt-qq[i].cnt],qq[i].x-1);\n\t\t}\n\t\tFor(i,1,cnt) mn[i]=max(mn[i],mn[i-1]);\n\t\tRep(i,cnt,1) mx[i]=min(mx[i],mx[i+1]);\n\t\tFor(i,1,cnt){\n\t\t\tint tmp=++nd;\n\t\t\tif (mn[i]>mx[i]) return 0;\n\t\t\tadd(tmp,T,1,0);\n\t\t\tFor(j,mn[i],mx[i])\n\t\t\t\tadd(idy[j],tmp,1,0);\n\t\t}\n\t}//buildy\n\tll ans=0;\n\tFor(i,1,cnt){\n\t\tif (!bfs()) return 0;\n\t\tans+=dis[T]; del();\n\t}\n\treturn ans;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tFor(i,1,n) scanf(\"%d%d%lld\",&x[i],&y[i],&v[i]);\n\tscanf(\"%d\",&Q);\n\tFor(i,1,Q) scanf(\"%s%d%d\",qq[i].s,&qq[i].x,&qq[i].cnt);\n\tll ans=0;\n\tFor(i,1,n) ans=max(ans,work(i));\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nnamespace simplex{\n    using T = ll;\n    const int N = 444, M = 33333;\n    int n,m;\n    int left[M],down[N];\n    T a[M][N], b[M], c[N], v, sol[N];\n    void init(int p,int q){\n        n = p, m = q, v = 0;\n        for(int i=1;i<=m;i++){\n            for(int j=1;j<=n;j++){\n                a[i][j] = 0;\n            }\n            b[i] = 0;\n        }\n        for(int i=1;i<=n;i++) c[i] = sol[i] = 0;\n    }\n    void pivot(int x,int y){\n        swap(left[x],down[y]);\n        T k = a[x][y]; a[x][y] = 1;\n        vector<int> nz;\n        for(int i=1;i<=n;i++){\n            a[x][i] /= k;\n            if(a[x][i]) nz.push_back(i);\n        }\n        b[x] /= k;\n        for(int i=1;i<=m;i++){\n            if(i==x||a[i][y]==0) continue;\n            k = a[i][y]; a[i][y] = 0;\n            b[i] -= k * b[x];\n            for(int j: nz) a[i][j] -= k * a[x][j];\n        }\n        if(c[y]==0) return;\n        k = c[y]; c[y] = 0;\n        v += k * b[x];\n        for(int i: nz) c[i] -= k * a[x][i];\n    }\n    int solve(){\n        for(int i=1;i<=n;i++) down[i] = i;\n        for(int i=1;i<=m;i++) left[i] = n + i;\n        while(1){\n            int x = 0, y = 0;\n            for(int i=1;i<=m;i++) if(b[i]<0&&(x==0||b[i]<b[x])) x = i;\n            if(x==0) break;\n            for(int i=1;i<=n;i++) if(a[x][i]<0&&(y==0||a[x][i]<a[x][y])) y = i;\n            if(y==0) return 1;\n            pivot(x,y);\n        }\n        while(1){\n            int x = 0, y = 0;\n            for(int i=1;i<=n;i++) if(0<c[i]&&(!y||c[i]>c[y])) y = i;\n            if(y==0) break;\n            for(int i=1;i<=m;i++) if(0<a[i][y]&&(!x||b[i]/a[i][y]<b[x]/a[x][y])) x = i;\n            if(x==0) return 2;\n            pivot(x,y);\n        }\n        for(int i=1;i<=m;i++) if(left[i]<=n) sol[left[i]] = b[i];\n        return 0;\n    }\n}\nconst int N = 100 + 10;\nint x[N],y[N]; ll w[N];\nint main(){\n    int n; scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++) scanf(\"%d%d%lld\",&x[i],&y[i],&w[i]);\n    int m; scanf(\"%d\",&m);\n    simplex::init(n,n+m);\n    for(int i=1;i<=n;i++) simplex::c[i] = w[i];\n    int cnt = 0;\n    for(int i=1;i<=n;i++){\n        cnt++;\n        simplex::a[cnt][i] = 1, simplex::b[cnt] = 1;\n    }\n    while(m--){\n        char s[3]; int a,b; scanf(\"%s%d%d\",s,&a,&b);\n        cnt++;\n        simplex::b[cnt] = b;\n        if(s[0]=='L'){\n            for(int i=1;i<=n;i++){\n                if(x[i]<=a) simplex::a[cnt][i] = 1;\n            }\n        }\n        if(s[0]=='R'){\n            for(int i=1;i<=n;i++){\n                if(x[i]>=a) simplex::a[cnt][i] = 1;\n            }\n        }\n        if(s[0]=='D'){\n            for(int i=1;i<=n;i++){\n                if(y[i]<=a) simplex::a[cnt][i] = 1;\n            }\n        }\n        if(s[0]=='U'){\n            for(int i=1;i<=n;i++){\n                if(y[i]>=a) simplex::a[cnt][i] = 1;\n            }\n        }\n    }\n    assert(simplex::solve()==0);\n    printf(\"%lld\\n\",simplex::v);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\nconst ll MAX=1000000000000010;\nint n,m,cnt=-1,s=0,t,head[1010],x[200],y[200],lx[200],rx[200],ly[200],ry[200],a[200],b[200];\nll ans=0,tot=0,val[200],dis[500];\nbool vis[500];\nchar ch[200][10];\nstruct edge{\n\tint u,v,w,nxt;\n\tll f;\n}e[200010];\n\nvoid add(int u,int v,int w,ll f){\n\te[++cnt]=(edge){u,v,w,head[u],f};\n\thead[u]=cnt;\n}\nvoid addedge(int u,int v,int w,ll f){\n\tadd(u,v,w,f);add(v,u,0,-f);\n}\n\nvoid init(int K){\n\tcnt=-1;t=490;tot=0;\n\tmemset(head,-1,sizeof(head));\n\tfor(int i=0;i<=n+1;i++)lx[i]=ly[i]=1,rx[i]=ry[i]=100;\n}\n\n//bool spfa(){\n//\tmemset(dis,0x3f,sizeof(dis));\n//\tmemset(vis,0,sizeof(vis));\n//\tqueue<int>que;\n//\tque.push(s);dis[s]=0;\n//\twhile(!que.empty()){\n//\t\tint u=que.front();que.pop();vis[u]=0;\n//\t\tfor(int i=head[u];~i;i=e[i].nxt)\n//\t\t  if(e[i].w&&dis[e[i].v]>dis[u]+e[i].f){\n//\t\t  \tdis[e[i].v]=dis[u]+e[i].f;\n//\t\t  \tif(!vis[e[i].v])vis[e[i].v]=1,que.push(e[i].v);\n//\t\t  }\n//\t}\n//\treturn dis[t]!=0x3f3f3f3f3f3f3f3f;\n//}\n//int dfs(int u,int a){\n//\tif(u==t||!a)return a;\n//\tint ret=0,tmp;\n//\tfor(int i=head[u];~i;i=e[i].nxt)\n//\t  if(e[i].w&&!vis[e[i].v]&&dis[e[i].v]==dis[u]+e[i].f){\n//\t  \ttmp=dfs(e[i].v,min(a,e[i].w));\n//\t  \tif(!tmp)continue;\n//\t  \te[i].w-=tmp;e[i].w+=tmp;\n//\t  \tret+=tmp;a-=tmp;tot+=e[i].f*tmp;\n//\t  \tif(!a)break;\n//\t  }\n//\treturn ret;\n//}\n//int dinic(){\n//\tint ret=0;\n//\twhile(spfa())\n//\t  ret+=dfs(s,0x3f3f3f3f);\n//\treturn ret;\n//}\n\nbool spfa(){\n\tmemset(vis,0,sizeof(vis));\n\tmemset(dis,0x3f,sizeof(dis));\n\tqueue<int>que;\n\tdis[s]=0;que.push(s);\n\twhile(!que.empty()){\n\t\tint u=que.front();\n\t\tque.pop();vis[u]=0;\n\t\tfor(int i=head[u];~i;i=e[i].nxt)\n\t\t  if(e[i].w&&dis[e[i].v]>dis[u]+e[i].f){\n\t\t  \tdis[e[i].v]=dis[u]+e[i].f;\n\t\t  \tif(!vis[e[i].v])vis[e[i].v]=1,que.push(e[i].v);\n\t\t  }\n\t}\n\treturn dis[t]!=0x3f3f3f3f3f3f3f3f;\n}\nint dfs(int u,int a){\n\tif(u==t||a==0)return a;\n\tint ret=0;\n\tvis[u]=1;\n\tfor(int i=head[u];~i;i=e[i].nxt)\n\t  if(!vis[e[i].v]&&e[i].w&&dis[e[i].v]==dis[u]+e[i].f){\n\t  \tint t=dfs(e[i].v,min(e[i].w,a-ret));\n\t  \tif(!t)continue;\n\t  \te[i].w-=t;e[i^1].w+=t;\n\t  \tret+=t;tot+=t*e[i].f;\n\t  \tif(a<=ret)break;\n\t  }\n\treturn ret;\n}\nvoid dinic(){\n\twhile(spfa())\n\t  dfs(s,0x3f3f3f3f);\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%d%d%lld\",&x[i],&y[i],&val[i]);\n\tscanf(\"%d\",&m);\n\tfor(int i=1;i<=m;i++)scanf(\"%s%d%d\",ch[i],&a[i],&b[i]);\n\tfor(int K=1;K<=n;K++){\n\t\tinit(K);\n\t\tfor(int i=1;i<=m;i++){\n\t\t\tif(ch[i][0]=='L')lx[b[i]+1]=a[i]+1;\n\t\t\tif(ch[i][0]=='R')rx[K-b[i]]=a[i]-1;\n\t\t\tif(ch[i][0]=='D')ly[b[i]+1]=a[i]+1;\n\t\t\tif(ch[i][0]=='U')ry[K-b[i]]=a[i]-1;\n\t\t}\n\t\tfor(int i=2;i<=K;i++)lx[i]=max(lx[i-1],lx[i]),ly[i]=max(ly[i-1],ly[i]);\n\t\tfor(int i=K-1;i>=1;i--)rx[i]=min(rx[i-1],rx[i]),ry[i]=min(ry[i-1],ry[i]);\n\t\tfor(int i=1;i<=K;i++){\n\t\t\taddedge(s,i,1,0),addedge(K+200+i,t,1,0);\n\t\t\tfor(int j=lx[i];j<=rx[i];j++)addedge(i,K+j,1,0);\n\t\t\tfor(int j=ly[i];j<=ry[i];j++)addedge(K+100+j,K+200+i,1,0);\n\t\t}\n\t\tfor(int i=1;i<=n;i++)addedge(K+x[i],K+100+y[i],1,-val[i]);\n//\t\tfor(int i=0;i<=cnt;i+=2)printf(\"%d %d %d %lld\\n\",e[i].u,e[i].v,e[i].w,e[i].f);\n\t\tdinic();\n//\t\tint num=0;\n//\t\tfor(int i=head[s];~i;i=e[i].nxt)\n//\t\t  if(!e[i].w)\n//\t\t    num++;\n\t\tans=max(ans,-tot);\n\t}\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n#define MAXN 500\n#define MAXM 500\n#define LL long long\nconst double eps=1e-13;\ndouble a[MAXM][MAXN];\nint n,m;\nvoid pivot(int r,int c)\n{\n\tdouble tmp=-a[r][c];\n\ta[r][c]=-1;\n\tfor(int i=0;i<=n;i++) a[r][i]/=tmp;\n\tfor(int i=0;i<=m;i++)\n\t\tif(a[i][c]&&i!=r)\n\t\t{\n\t\t\ttmp=a[i][c];a[i][c]=0;\n\t\t\tfor(int j=0;j<=n;j++)\n\t\t\t\ta[i][j]+=tmp*a[r][j];\n\t\t}\n}\nvoid Solve()\n{\n\twhile(1)\n\t{\n\t\tint i=0,j=0;\n\t\tdouble tmp=eps;\n\t\tfor(int k=1;k<=n;k++) if(a[0][k]>tmp) tmp=a[0][j=k];\n\t\tif(!j) break;\n\t\ttmp=1e9;\n\t\tfor(int k=1;k<=m;k++) if(a[k][j]<-eps&&-a[k][0]/a[k][j]<tmp)\n\t\t{\n\t\t\ti=k;tmp=-a[k][0]/a[k][j];\n\t\t}\n\t\tpivot(i,j);\n\t}\n\tprintf(\"%.0lf\\n\",ceil(a[0][0]));\n}\nint N,M,x[MAXN],y[MAXN],A;\nchar s[5];\nint main()\n{\n\tscanf(\"%d\",&N);\n\tfor(int i=1;i<=N;i++)\n\t\tscanf(\"%d%d%lf\",&x[i],&y[i],&a[0][i]);\n\tscanf(\"%d\",&M);\n\tfor(int i=1;i<=M;i++)\n\t{\n\t\tscanf(\"%s%d%lf\",s,&A,&a[i][0]);\n\t\tif(s[0]=='L')\n\t\t{\n\t\t\tfor(int j=1;j<=N;j++)\n\t\t\t\tif(x[j]<=A) a[i][j]=-1;\n\t\t}\n\t\telse if(s[0]=='R')\n\t\t{\n\t\t\tfor(int j=1;j<=N;j++)\n\t\t\t\tif(x[j]>=A) a[i][j]=-1;\n\t\t}\n\t\telse if(s[0]=='D')\n\t\t{\n\t\t\tfor(int j=1;j<=N;j++)\n\t\t\t\tif(y[j]<=A) a[i][j]=-1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(int j=1;j<=N;j++)\n\t\t\t\tif(y[j]>=A) a[i][j]=-1;\n\t\t}\n\t}\n\tfor(int i=1;i<=N;i++)\n\t\ta[i+M][0]=1,a[i+M][i]=-1;\n\tn=N;m=M+N;\n\tSolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<queue>\n#define ll long long\nusing namespace std;\nconst int INF=2147483647;\nstruct Edge\n{\n\tint to,nxt;\n\tint flow;\n\tll cost;\n}e[10005];\nint n,m,s,t,edgenum,head[1005],f[1005],pre[1005],x[85],y[85],a[325],b[325],l1[85],r1[85],l2[85],r2[85];\nll dis[1005],val[85];\nbool flag[1005];\nchar ti[325];\nqueue<int>q;\nvoid add(int u,int v,int f,ll c)\n{\n\te[++edgenum].cost=c;\n\te[edgenum].flow=f;\n\te[edgenum].to=v;\n\te[edgenum].nxt=head[u];\n\thead[u]=edgenum;\n}\nbool SPFA()\n{\n\tfor(int i=1;i<=t;i++)\n\t  dis[i]=1e18,flag[i]=0,f[i]=0;\n\tdis[s]=0;\n\tf[s]=INF;\n\tflag[s]=1;\n\tq.push(s);\n\twhile(!q.empty())\n\t{\n\t\tint node=q.front();\n\t\tq.pop();\n\t\tflag[node]=0;\n\t\tfor(int hd=head[node];hd;hd=e[hd].nxt)\n\t\t{\n\t\t\tint to=e[hd].to;\n\t\t\tif(flag[to])continue;\n\t\t\tif(e[hd].flow==0)continue;\n\t\t\tif(dis[to]>dis[node]+e[hd].cost)\n\t\t\t{\n\t\t\t\tdis[to]=dis[node]+e[hd].cost;\n\t\t\t\tf[to]=min(f[node],e[hd].flow);\n\t\t\t\tpre[to]=hd;\n\t\t\t\tq.push(to);\n\t\t\t}\n\t\t}\n\t}\n\treturn dis[t]<0;\n}\nll EK()\n{\n\tll ans=0;\n\twhile(SPFA())\n\t{\n\t\tans+=f[t]*dis[t];\n\t\tint x=t;\n\t\twhile(x)\n\t\t{\n\t\t\te[pre[x]].flow-=f[t];\n\t\t\te[pre[x]^1].flow+=f[t];\n\t\t\tx=e[pre[x]^1].to;\n\t\t}\n\t}\n\treturn ans;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t  scanf(\"%d%d%lld\",&x[i],&y[i],&val[i]);\n\tscanf(\"%d\",&m);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\twhile(ti[i]<'A'||ti[i]>'Z')ti[i]=(char)getchar();\n\t\tscanf(\"%d%d\",&b[i],&a[i]);\n\t}\n\tll ans=0;\n\tfor(int c=1;c<=n;c++)\n\t{\n\t\tfor(int i=1;i<=c;i++)l1[i]=l2[i]=1,r1[i]=r2[i]=100;\n\t\tfor(int i=1;i<=m;i++)\n\t\t{\n\t\t\tif(ti[i]=='L')if(a[i]+1<=c)l1[a[i]+1]=max(l1[a[i]+1],b[i]+1);\n\t\t\tif(ti[i]=='R')if(a[i]+1<=c)r1[c-a[i]]=min(r1[c-a[i]],b[i]-1);\n\t\t\tif(ti[i]=='D')if(a[i]+1<=c)l2[a[i]+1]=max(l2[a[i]+1],b[i]+1);\n\t\t\tif(ti[i]=='U')if(a[i]+1<=c)r2[c-a[i]]=min(r2[c-a[i]],b[i]-1);\n\t\t}\n\t\tfor(int i=2;i<=c;i++)\n\t\t{\n\t\t\tl1[i]=max(l1[i],l1[i-1]);\n\t\t\tl2[i]=max(l2[i],l2[i-1]);\n\t\t}\n\t\tfor(int i=c-1;i>=1;i--)\n\t\t{\n\t\t\tr1[i]=min(r1[i],r1[i+1]);\n\t\t\tr2[i]=min(r2[i],r2[i+1]);\n\t\t}\n\t\tbool flag=1;\n\t\tfor(int i=1;i<=c;i++)\n\t\t{\n\t\t\tif(l1[i]>r1[i])flag=0;\n\t\t\tif(l2[i]>r2[i])flag=0;\n\t\t}\n\t\tif(!flag)continue;\n\t\ts=2*c+2*n+1,t=2*c+2*n+2;\n\t\tedgenum=1;\n\t\tfor(int i=1;i<=t;i++)head[i]=0;\n\t\tfor(int i=1;i<=c;i++)\n\t\t{\n\t\t\tadd(s,i+2*n,1,0);\n\t\t\tadd(i+2*n,s,0,0);\n\t\t\tadd(i+2*n+c,t,1,0);\n\t\t\tadd(t,i+2*n+c,0,0);\n\t\t\tfor(int j=1;j<=n;j++)\n\t\t\t{\n\t\t\t\tif(x[j]>=l1[i]&&x[j]<=r1[i])\n\t\t\t\t{\n\t\t\t\t\tadd(i+2*n,j,1,0);\n\t\t\t\t\tadd(j,i+2*n,0,0);\n\t\t\t\t}\n\t\t\t\tif(y[j]>=l2[i]&&y[j]<=r2[i])\n\t\t\t\t{\n\t\t\t\t\tadd(j+n,i+2*n+c,1,0);\n\t\t\t\t\tadd(i+2*n+c,j+n,0,0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tadd(i,i+n,1,-val[i]);\n\t\t\tadd(i+n,i,0,val[i]);\n\t\t}\n\t\tans=max(ans,-EK());\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define all(x) (x).begin (),(x).end()\n#define sqrt(x) sqrt(abs(x))\n#define re return\n#define sz(x) ((int)(x).size ())\n#define prev PREV\n#define next NEXT\n\nusing ll = long long;\nusing ii = pair<int, int>;\nusing ld = long double;\nusing D = double;\nusing vi = vector<int>;\nusing vii = vector<ii>;\nusing vvi = vector<vi>;\nusing vs = vector<string>;\n\ntemplate<typename T> T abs (T x) { re x < 0 ? -x : x; }\ntemplate<typename T> T sgn (T x) { re x < 0 ? -1 : (x > 0 ? 1 : 0); }\ntemplate<typename T> T sqr (T x) { re x * x; }\ntemplate<typename T> T gcd (T a, T b) { re a != 0 ? gcd (b % a, a) : b; }\n\nconst int inf = 1e9;\nconst ll INF = 1e15;\n\nint n;\nint m;\nint o, e;\nint x[200];\nint y[200];\nll val[200];\nint a[400];\nint b[400];\nstring t[400];\nvi vx, vy;\nint lx[200];\nint rx[200];\nint ly[200];\nint ry[200];\n\nvii v[2000];\nint ec[200000];\nll ef[200000];\nll d[2000];\nll p[2000];\nint mark[2000];\nint prev[2000];\nint preve[2000];\nset<pair<ll, int> > all;\n\n\nvoid addedge (int a, int b, int c, ll d) {\n//\tprintf (\"%d %d %d %I64d\\n\", a, b, c, d);\n\tv[a].pb (mp (b, e));\n\tec[e] = c;\n\tef[e] = d;\n\te++;\n\tv[b].pb (mp (a, e));\n\tec[e] = 0;\n\tef[e] = -d;\n\te++;\n}\n\nll go (int S, int T) {\n\tall.clear ();\n\tfor (int i = 0; i < o; i++) {\n\t\tmark[i] = 0;\n\t\td[i] = 1e18;\n\t}\n\tmark[S] = 1;\n\td[S] = 0;\n\tall.insert (mp (0, S));\n\twhile (!all.empty ()) {\n\t\tint x = all.begin ()->se;\n//\t\tprintf (\"%d\\n\", x);\n\t\tmark[x] = 2;\n\t\tall.erase (all.begin ());\n\t\tfor (int i = 0; i < sz (v[x]); i++) {\n\t\t\tint y = v[x][i].fi;\n\t\t\tint z = v[x][i].se;\n\t\t\tif (ec[z] > 0 && d[x] + p[x] + ef[z] - p[y] < d[y]) {\n\t\t\t\tif (mark[y] == 1) all.erase (mp (d[y], y));\n\t\t\t\td[y] = d[x] + p[x] + ef[z] - p[y];\n\t\t\t\tprev[y] = x;\n\t\t\t\tpreve[y] = z;\n\t\t\t\tmark[y] = 1;\n\t\t\t\tall.insert (mp (d[y], y));\n\t\t\t}\n\t\t}\n\t}\n\tif (mark[T] == 0) re -1;\n\tll ans = d[T] - p[S] + p[T];\n\tfor (int i = 0; i < o; i++)\n\t\tif (mark[i])\n\t\t\tp[i] += d[i];\n\tre ans;\n}\n\nll calc (int h) {\n\tint ox = sz (vx);\n\tint oy = sz (vy);\n\tfor (int i = 0; i < ox; i++) {\n\t\tlx[i] = 0;\n\t\trx[i] = h;\n\t\tfor (int j = 0; j < m; j++)\n\t\t\tif (t[j] == \"L\") {\n\t\t\t\tif (vx[i] <= a[j]) rx[i] = min (rx[i], b[j]);\n\t\t\t} else\n\t\t\tif (t[j] == \"R\") {\n\t\t\t\tif (vx[i] >= a[j] - 1) lx[i] = max (lx[i], h - b[j]);\n\t\t\t}\n\t\tif (lx[i] > rx[i]) re -1;\t\n\t}\n\tfor (int i = 0; i < oy; i++) {\n\t\tly[i] = 0;\n\t\try[i] = h;\n\t\tfor (int j = 0; j < m; j++)\n\t\t\tif (t[j] == \"D\") {\n\t\t\t\tif (vy[i] <= a[j]) ry[i] = min (ry[i], b[j]);\n\t\t\t} else\n\t\t\tif (t[j] == \"U\") {\n\t\t\t\tif (vy[i] >= a[j] - 1) ly[i] = max (ly[i], h - b[j]);\n\t\t\t}\n\t\tif (ly[i] > ry[i]) re -1;\t\n\t}\n\to = 2 * ox + 2 * oy + 2 * n + 5;\n\te = 0;\n\tfor (int i = 0; i < o; i++) v[i].clear ();\n\tint req = 0;\n\taddedge (o - 4, 2 * n + 2 * (ox - 1), inf, 0);\n\tfor (int i = 0; i < ox; i++) {\n//\t\tprintf (\"x %d: %d %d\\n\", vx[i], lx[i], rx[i]);\n\t\treq += lx[i];\n\t\taddedge (2 * n + 2 * i, 2 * n + 2 * i + 1, rx[i] - lx[i], 0);\n\t\taddedge (o - 2, 2 * n + 2 * i + 1, lx[i], 0);\n\t\taddedge (2 * n + 2 * i, o - 1, lx[i], 0);\n\t\tif (i > 0) addedge (2 * n + 2 * i + 1, 2 * n + 2 * (i - 1), inf, 0);\n\t}\n\taddedge (2 * n + 2 * ox + 2 * (oy - 1) + 1, o - 3, inf, 0);\n\tfor (int i = 0; i < oy; i++) {\n//\t\tprintf (\"y %d: %d %d\\n\", vy[i], ly[i], ry[i]);\n\t\treq += ly[i];\n\t\taddedge (2 * n + 2 * ox + 2 * i, 2 * n + 2 * ox + 2 * i + 1, ry[i] - ly[i], 0);\n\t\taddedge (o - 2, 2 * n + 2 * ox + 2 * i + 1, ly[i], 0);\n\t\taddedge (2 * n + 2 * ox + 2 * i, o - 1, ly[i], 0);\n\t\tif (i > 0) addedge (2 * n + 2 * ox + 2 * (i - 1) + 1, 2 * n + 2 * ox + 2 * i, inf, 0);\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\taddedge (2 * i, 2 * i + 1, 1, INF - val[i]);\n\t\tint j = 0;\n\t\twhile (vx[j] < x[i]) j++;\n\t\taddedge (2 * n + 2 * j + 1, 2 * i, inf, 0);\n\t\tj = 0;\n\t\twhile (vy[j] < y[i]) j++;\n\t\taddedge (2 * i + 1, 2 * n + 2 * ox + 2 * j, inf, 0);\n\t}\n\treq += h;\n\taddedge (o - 3, o - 5, inf, 0);\n\taddedge (o - 2, o - 4, h, 0);\n\taddedge (o - 5, o - 1, h, 0);\n\tll ans = 0;\n\tfor (int i = 0; i < o; i++) p[i] = 0;\n\tfor (int i = 0; i < req; i++) {\n\t\tll tmp = go (o - 2, o - 1);\n//\t\tprintf (\"%d: %d = %I64d\\n\", h, i, INF - tmp);\n\t\tif (tmp == -1) re -1;\n\t\tans += tmp;\n\t\tint j = o - 1;\n\t\twhile (j != o - 2) {\n\t\t\tint k = prev[j];\n\t\t\tint z = preve[j];\n\t\t\tec[z]--;\n\t\t\tec[z ^ 1]++;\n//\t\t\tprintf (\"%d -> %d = %d\\n\", k / 2, j / 2, ec[z]);\n\t\t\tj = k;\n\t\t}\n\t}\n\tll tmp = go (o - 2, o - 1);\n\tre h * INF - ans;\n}\n\nint main () {\n\tcin >> n;\n\tfor (int i = 0; i < 100; i++) {\n\t\tvx.pb (i + 1);\n\t\tvy.pb (i + 1);\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x[i] >> y[i] >> val[i];\n\t\tvx.pb (x[i]);\n\t\tvy.pb (y[i]);\n\t}\t\n\tcin >> m;\n\tfor (int i = 0; i < m; i++) {\n\t\tcin >> t[i] >> a[i] >> b[i];\n\t\tif (t[i] == \"L\" || t[i] == \"R\") vx.pb (a[i]); else vy.pb (a[i]);\n\t}\n\tsort (all (vx));\n\tvx.resize (unique (all (vx)) - vx.begin ());\n\tsort (all (vy));\n\tvy.resize (unique (all (vy)) - vy.begin ());\n\tll ans = 0;\n\tint l = 0, r = n + 1;\n\twhile (r - l  > 1) {\n\t\tint s = (l + r) / 2;\n\t\tll tmp = calc (s);\n\t\tif (tmp != -1) {\n\t\t\tl = s;\n\t\t\tans = tmp;\n\t\t} else r = s;\n\t}\n/*\tfor (int t = 0; t <= n; t++) {\n\t\tll tmp = calc (t);\n\t\tans = max (ans, tmp);\n\t}\t*/\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair < int , int > pii;\ntypedef pair < LL , int > pli;\nconst LL INF=(LL)(1e15+5),LINF=(LL)(2e18+5);\nint n,m,x[80],y[80],px[80],py[80];\nLL v[80];\nchar readch(){\n\tchar c=getchar();\n\twhile(c!='L' && c!='R' && c!='U' && c!='D'){\n\t\tc=getchar();\n\t}\n\treturn c;\n}\nnamespace flows{\n\tstruct edge{\n\t\tint v,f,r;\n\t\tLL c;\n\t\tvoid set(int V,int F,int R,LL C){\n\t\t\tv=V;f=F;r=R;c=C;\n\t\t}\n\t}tmp;\n\tvector < edge > adj[505];\n\tpriority_queue < pli > pq;\n\tint predv[505],prede[505],flow;\n\tLL f[505],dis[505],cost;\n\tvoid init(){\n\t\tint i;\n\t\tfor(i=0;i<505;++i) adj[i].clear();\n\t\tmemset(f,0,sizeof(f));\n\t\tflow=0;cost=0ll;\n\t}\n\tvoid addedge(int u,int v,int f,LL c){\n\t\ttmp.set(v,f,(int)adj[v].size(),c);\n\t\tadj[u].push_back(tmp);\n\t\ttmp.set(u,0,(int)adj[u].size()-1,-c);\n\t\tadj[v].push_back(tmp);\n\t}\n\tvoid dijkstra(){\n\t\tint i,j,k;\n\t\tfill(dis,dis+505,LINF);\n\t\tdis[0]=0ll;\n\t\tpq.push(mpr(0ll,0));\n\t\twhile(!pq.empty()){\n\t\t\tLL D=-pq.top().first;\n\t\t\tint cur=pq.top().second;\n\t\t\tpq.pop();\n\t\t\tif(dis[cur]!=D) continue;\n\t\t\tfor(i=0;i<(int)adj[cur].size();++i){\n\t\t\t\tif(!adj[cur][i].f) continue;\n\t\t\t\tint v=adj[cur][i].v;\n\t\t\t\tLL l=adj[cur][i].c+f[cur]-f[v];\n\t\t\t\tif(D+l<dis[v]){\n\t\t\t\t\tdis[v]=D+l;\n\t\t\t\t\tpredv[v]=cur;\n\t\t\t\t\tpreve[v]=i;\n\t\t\t\t\tpq.push(mpr(-dis[v],v));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmemcpy(f,dis,sizeof(f));\n\t}\n\tvoid mincostflow(){\n\t\tint i,j,k;\n\t\t\n\t}\n};\nbool cmpx(int a,int b){\n\treturn x[a]<x[b];\n}\nbool cmpy(int a,int b){\n\treturn y[a]<y[b];\n}\nchar TP[405];\nint D[405],V[405];\nvector < pii > consx,consy;\nLL solve(int tot){\n\tint i,j,k;\n\tconsx.clear();\n\tconsy.clear();\n\tfor(i=0;i<m;++i){\n\t\tif(TP[i]=='L')\n\t\t\tconsx.push_back(mpr(D[i],V[i]));\n\t\telse if(TP[i]=='R' && V[i]<tot)\n\t\t\tconsx.push_back(mpr(D[i]-1,-tot+V[i]));\n\t\telse if(TP[i]=='D')\n\t\t\tconsy.push_back(mpr(D[i],V[i]));\n\t\telse if(TP[i]=='U' && V[i]<tot)\n\t\t\tconsy.push_back(mpr(D[i]-1,-tot+V[i]));\n\t}\n\tsort(consx.begin(),consx.end());\n\tsort(consy.begin(),consy.end());\n\tflows::init();\n\t// 0: super source  1: original source  2: extra source\n\tflows::addedge(0,1,tot,0);\n\tflows::addedge(4,3,tot,0);\n\tint extraflow=0,ptr=n-1,pr=1,SX=(int)consx.size();\n\tfor(i=SX-1;i>=0;--i){\n\t\tint d=consx[i].first,f=consx[i].second;\n\t\twhile(ptr>=0 && x[px[ptr]]>d){\n\t\t\tflows::addedge(pr,6+SX+px[ptr],1,0);\n\t\t\t--ptr;\n\t\t}\n\t\tif(f<0){\n\t\t\tf=-f;\n\t\t\textraflow+=f;\n\t\t\tflows::addedge(2,i+6,f,0);\n\t\t\tflows::addedge(pr,5,f,0);\n\t\t\tflows::addedge(pr,i+6,tot-f,0);\n\t\t}\n\t\telse flows::addedge(pr,i+6,f);\n\t\tpr=i+6;\n\t}\n\twhile(ptr>=0){\n\t\tflows::addedge(pr,6+SX+px[ptr],1,0);\n\t\t--ptr;\n\t}\n\tfor(i=0;i<n;++i){\n\t\tflows::addedge(6+SX+i,6+SX+n+i,1,INF-v[i]);\n\t}\n\tptr=0;pr=-1;\n\tint pf;\n\tfor(i=0;i<(int)consy.size();++i){\n\t\tint d=consy[i].first,cur=6+SX+n*2+i;\n\t\twhile(ptr<n && y[py[ptr]]<=d){\n\t\t\tflows::addedge(6+SX+n+py[ptr],cur,1,0);\n\t\t\t++ptr;\n\t\t}\n\t\tif(pr!=-1){\n\t\t\tif(pf<0){\n\t\t\t\tpf=-pf;\n\t\t\t\textraflow+=pf;\n\t\t\t\tflows::addedge(2,cur,pf,0);\n\t\t\t\tflows::addedge(pr,5,pf,0);\n\t\t\t\tflows::addedge(pr,cur,tot-pf,0);\n\t\t\t}\n\t\t\telse flows::addedge(pr,cur,pf,0);\n\t\t}\n\t\tpf=consy[i].second;\n\t\tpr=cur;\n\t}\n\tflows::addedge(2,0,extraflow,0);\n\tflows::addedge(5,3,extraflow,0);\n\tflows::mincostflow();\n\tif(flows::flow==extraflow+tot)\n\t\treturn INF*(LL)tot-flows::cost;\n\treturn 0ll;\n}\nint main(){\n\tint i,j,k;\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;++i){\n\t\tscanf(\"%d%d%lld\",x+i,y+i,v+i);\n\t\t--x[i];--y[i];\n\t\tpx[i]=i;\n\t\tpy[i]=i;\n\t}\n\tscanf(\"%d\",&m);\n\tfor(i=0;i<m;++i){\n\t\tTP[i]=readch();\n\t\tscanf(\"%d%d\",D+i,V+i);\n\t\t--D[i];\n\t}\n\tsort(px,px+n,cmpx);\n\tsort(py,py+n,cmpy);\n\tLL res=0ll;\n\tfor(i=0;i<=n;++i){\n\t\tUMAX(res,solve(i));\n\t}\n\tprintf(\"%lld\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,a,b) for(int i=(a),_ed=(b);i<=_ed;++i)\n#define DREP(i,a,b) for(int i=(a),_ed=(b);i>=_ed;--i)\n#define mp(x,y) make_pair((x),(y))\n#define sz(x) (int)(x).size()\n#define pb push_back\ntypedef long long ll;\ntypedef pair<int,int> pii;\ninline ll read(){\n    register ll x=0,f=1;register char ch=getchar();\n    while(!isdigit(ch)){if(ch=='-')f=0;ch=getchar();}\n    while(isdigit(ch)){x=x*10+(ch^'0');ch=getchar();}\n    return f?x:-x;\n}\n\nconst int inf=1e9;\nconst ll INF=1e16;\nint n,m;char ch[10];\nstruct node{int x,y;ll v;} a[85];\nstruct query{int op,a,b;} q[325];\ninline void chkmax(int& x,int y){x=x>y?x:y;}\ninline void chkmin(int& x,int y){x=x<y?x:y;}\n\nint s,t,num,head[325],vis[325],flow[325],id[325],pre[325];\nll dis[325],ans;\nstruct edge{int to,next,flo;ll val;} e[200005];\ninline void add(int u,int v,int f,ll w){\n\te[++num]=(edge){v,head[u],f,w},head[u]=num;\n\te[++num]=(edge){u,head[v],0,-w},head[v]=num;\n}\n\nbool bfs(){\n\tqueue<int> q;\n\tREP(i,1,324)dis[i]=-INF;\n\tmemset(vis,0,sizeof vis);\n\tdis[s]=0,flow[s]=inf,q.push(s),vis[s]=1;\n\twhile(!q.empty()){\n\t\tint u=q.front();q.pop(),vis[u]=0;\n\t\tfor(int i=head[u];i;i=e[i].next){\n\t\t\tint v=e[i].to;\n\t\t\tif(!e[i].flo||dis[v]>=dis[u]+e[i].val)continue;\n\t\t\tdis[v]=dis[u]+e[i].val;\n\t\t\tflow[v]=min(flow[u],e[i].flo);\n\t\t\tid[v]=i,pre[v]=u;\n\t\t\tif(!vis[v])vis[v]=1,q.push(v);\n\t\t}\n\t}\n\treturn dis[t]>-INF;\n}\nll network(){\n\tll ans=0;\n\twhile(bfs()){\n\t\tans+=dis[t]*flow[t];\n\t\tint p=t;\n\t\twhile(p^s)e[id[p]].flo-=flow[t],e[id[p]^1].flo+=flow[t],p=pre[p];\n\t}\n\treturn ans;\n}\n\nvoid work(int K){\n\tint L[165],R[165];\n\tnum=1,memset(head,0,sizeof head);\n\ts=n+n+K+K+1,t=s+1;\n\tREP(i,1,n)add(i,n+i,1,a[i].v);\n\tmemset(L,0,sizeof L),memset(R,0x3f,sizeof R);\n\tREP(t,1,m){\n\t\tif(q[t].op==0)REP(i,q[t].b+1,K)chkmax(L[i],q[t].a+1);\n\t\telse if(q[t].op==1)REP(i,1,K-q[t].b)chkmin(R[i],q[t].a-1);\n\t\telse if(q[t].op==2)REP(i,q[t].b+1,K)chkmax(L[K+i],q[t].a+1);\n\t\telse REP(i,1,K-q[t].b)chkmin(R[K+i],q[t].a-1);\n\t}\n\tREP(i,1,K){\n\t\tadd(s,n+n+i,1,0);\n\t\tREP(j,1,n)if(L[i]<=a[j].x&&a[j].x<=R[i])add(n+n+i,j,1,0);\n\t}\n\tREP(i,K+1,K+K){\n\t\tadd(n+n+i,t,1,0);\n\t\tREP(j,1,n)if(L[i]<=a[j].y&&a[j].y<=R[i])add(n+j,n+n+i,1,0);\n\t}\n\tans=max(ans,network());\n}\n\nint main(){\n\t// freopen(\"in.in\",\"r\",stdin);\n\tn=read();\n\tREP(i,1,n)a[i]=(node){read(),read(),read()};\n\tm=read();\n\tREP(i,1,m){\n\t\tscanf(\"%s\",ch);int o;\n\t\tif(ch[0]=='L')o=0;\n\t\telse if(ch[0]=='R')o=1;\n\t\telse if(ch[0]=='D')o=2;\n\t\telse o=3;\n\t\tq[i]=(query){o,read(),read()};\n\t}\n\tREP(i,1,n)\n\t\twork(i);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n\n#define fo(i,j,l) for(int i=j;i<=l;++i)\n#define fd(i,j,l) for(int i=j;i>=l;--i)\n#define eps 3e-1\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double db;\nconst ll N=1000;\nconst db sj=5e-20,op=1e4;\n\nint f1[N],f2[N];\nint s1[N],s2[N];\nint w[N];\nll x[N],y[N],v[N];\n\nint n,m,oo,a,b,o2;\ndb c[N],s[N][N];\nint bh[N];\ndb d[N];\nint dl[N];\nint g,gs;\ndb ans=0;\nll da=0;\n\ninline db iabs(db gg)\n{return (gg<0)?(-gg):gg;}\n\ninline void trans(int h,int k)\n{\n\tint u=bh[h]; bh[h]=k;\n\tdb xs=-s[h][k];\n\ts[h][k]=0; s[h][u]=-1;\n\tfo(i,1,g)s[h][i]=s[h][i]/xs;\n\tc[h]=c[h]/xs;\n\tfo(i,1,gs)if(i!=h&&s[i][k]!=0&&iabs(s[i][k])>sj){\n\t\tfo(l,1,g)s[i][l]=s[i][l]+s[i][k]*s[h][l];\n\t\tc[i]=c[i]+c[h]*s[i][k];\n\t\ts[i][k]=0;\n\t}\n\tfo(i,1,g)d[i]=d[i]+d[k]*s[h][i];\n\tans=ans+d[k]*c[h];\n\td[k]=0;\n}\n\ninline int find()\n{\n\tint po=0; d[0]=sj;\n\tfo(i,1,g)if(d[i]>d[po])po=i;\n\treturn po;\n}\n\ninline void Simplex()\n{\n\tint x;\n\twhile((x=find())!=0){\n\t\tdouble zd=(db)1e18;\n\t\tint po=0;\n\t\tfo(i,1,gs)if(s[i][x]<-sj)if(c[i]/(-s[i][x])<zd)zd=c[i]/(-s[i][x]),po=i;\n\t\tif(!po)break;\n\t\ttrans(po,x);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfo(i,1,n){\n\t\tscanf(\"%lld%lld%lld\",&x[i],&y[i],&v[i]);\n\t}\n\tfo(i,1,n)d[i]=v[i]/op;\n\tscanf(\"%d\",&gs); m=gs;\n\tfo(i,1,m){\n\t\tchar ch=' ';\n\t\tfor(;ch!='L'&&ch!='R'&&ch!='U'&&ch!='D';ch=getchar());\n\t\tint aa,bb;\n\t\tscanf(\"%d%d\",&aa,&bb);\n\t\tc[i]=bb;\n\t\tif(ch=='L'){fo(l,1,n)if(x[l]<=aa)s[i][l]=-1;}\n\t\tif(ch=='R'){fo(l,1,n)if(x[l]>=aa)s[i][l]=-1;}\n\t\tif(ch=='D'){fo(l,1,n)if(y[l]<=aa)s[i][l]=-1;}\n\t\tif(ch=='U'){fo(l,1,n)if(y[l]>=aa)s[i][l]=-1;}\t\t\n\t}\n\tfo(i,1,n){\n\t\t++gs; c[gs]=1;\n\t\ts[gs][i]=-1;\n\t}\n\tg=m+n;\n\tSimplex();\n\tll da=(ll)(ans*op+eps);\n\tcout<<da;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define mpr make_pair\ntypedef long long LL;\ntypedef pair < int , int > pii;\ntypedef pair < LL , int > pli;\nconst LL INF=(LL)(1e15+5),LINF=(LL)(2e18+5);\nint n,m,x[80],y[80],px[80],py[80];\nLL v[80];\nchar readch(){\n\tchar c=getchar();\n\twhile(c!='L' && c!='R' && c!='U' && c!='D'){\n\t\tc=getchar();\n\t}\n\treturn c;\n}\nnamespace flows{\n\tstruct edge{\n\t\tint v,f,r;\n\t\tLL c;\n\t\tvoid set(int V,int F,int R,LL C){\n\t\t\tv=V;f=F;r=R;c=C;\n\t\t}\n\t}tmp;\n\tvector < edge > adj[505];\n\tpriority_queue < pli > pq;\n\tint predv[505],prede[505],flow;\n\tLL f[505],dis[505],cost;\n\tvoid init(){\n\t\tint i;\n\t\tfor(i=0;i<505;++i) adj[i].clear();\n\t\tmemset(f,0,sizeof(f));\n\t\tflow=0;cost=0ll;\n\t}\n\tvoid addedge(int u,int v,int f,LL c){\n\t\ttmp.set(v,f,(int)adj[v].size(),c);\n\t\tadj[u].push_back(tmp);\n\t\ttmp.set(u,0,(int)adj[u].size()-1,-c);\n\t\tadj[v].push_back(tmp);\n\t}\n\tvoid dijkstra(){\n\t\tint i,j,k;\n\t\tfill(dis,dis+505,LINF);\n\t\tdis[0]=0ll;\n\t\tpq.push(mpr(0ll,0));\n\t\twhile(!pq.empty()){\n\t\t\tLL D=-pq.top().first;\n\t\t\tint cur=pq.top().second;\n\t\t\tpq.pop();\n\t\t\tif(dis[cur]!=D) continue;\n\t\t\tfor(i=0;i<(int)adj[cur].size();++i){\n\t\t\t\tif(!adj[cur][i].f) continue;\n\t\t\t\tint v=adj[cur][i].v;\n\t\t\t\tLL l=adj[cur][i].c+f[cur]-f[v];\n\t\t\t\tif(D+l<dis[v]){\n\t\t\t\t\tdis[v]=D+l;\n\t\t\t\t\tpredv[v]=cur;\n\t\t\t\t\tprede[v]=i;\n\t\t\t\t\tpq.push(mpr(-dis[v],v));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmemcpy(f,dis,sizeof(f));\n\t}\n\tvoid mincostflow(){\n\t\tint i,j,k;\n\t\twhile(1){\n\t\t\tdijkstra();\n\t\t\tif(dis[3]==LINF) return;\n\t\t\tLL c=0ll;\n\t\t\tint f=10000;\n\t\t\tfor(i=3;i;i=predv[i]){\n\t\t\t\tedge &E=adj[predv[i]][prede[i]];\n\t\t\t\tf=min(f,E.f);\n\t\t\t\tc+=E.c;\n\t\t\t}\n\t\t\tflow+=f;\n\t\t\tcost+=c*(LL)f;\n\t\t\tfor(i=3;i;i=predv[i]){\n\t\t\t\tedge &E=adj[predv[i]][prede[i]];\n\t\t\t\tE.f-=f;\n\t\t\t\tadj[i][E.r].f+=f;\n\t\t\t}\n\t\t}\n\t}\n};\nbool cmpx(int a,int b){\n\treturn x[a]<x[b];\n}\nbool cmpy(int a,int b){\n\treturn y[a]<y[b];\n}\nchar TP[405];\nint D[405],V[405];\nvector < pii > consx,consy;\nLL solve(int tot){\n\tint i,j,k;\n\tconsx.clear();\n\tconsy.clear();\n\tfor(i=0;i<m;++i){\n\t\tif(TP[i]=='L')\n\t\t\tconsx.push_back(mpr(D[i],V[i]));\n\t\telse if(TP[i]=='R' && V[i]<tot)\n\t\t\tconsx.push_back(mpr(D[i]-1,-tot+V[i]));\n\t\telse if(TP[i]=='D')\n\t\t\tconsy.push_back(mpr(D[i],V[i]));\n\t\telse if(TP[i]=='U' && V[i]<tot)\n\t\t\tconsy.push_back(mpr(D[i]-1,-tot+V[i]));\n\t}\n\tsort(consx.begin(),consx.end());\n\tsort(consy.begin(),consy.end());\n\tflows::init();\n\t// 0: super source  1: original source  2: extra source\n\tflows::addedge(0,1,tot,0);\n\tflows::addedge(4,3,tot,0);\n\tint extraflow=0,ptr=n-1,pr=1,SX=(int)consx.size();\n\tfor(i=SX-1;i>=0;--i){\n\t\tint d=consx[i].first,f=consx[i].second;\n\t\twhile(ptr>=0 && x[px[ptr]]>d){\n\t\t\tflows::addedge(pr,6+SX+px[ptr],1,0);\n\t\t\t--ptr;\n\t\t}\n\t\tif(f<0){\n\t\t\tf=-f;\n\t\t\textraflow+=f;\n\t\t\tflows::addedge(2,i+6,f,0);\n\t\t\tflows::addedge(pr,5,f,0);\n\t\t\tflows::addedge(pr,i+6,tot-f,0);\n\t\t}\n\t\telse flows::addedge(pr,i+6,f,0);\n\t\tpr=i+6;\n\t}\n\twhile(ptr>=0){\n\t\tflows::addedge(pr,6+SX+px[ptr],1,0);\n\t\t--ptr;\n\t}\n\tfor(i=0;i<n;++i){\n\t\tflows::addedge(6+SX+i,6+SX+n+i,1,INF-v[i]);\n\t}\n\tptr=0;pr=-1;\n\tint pf;\n\tfor(i=0;i<(int)consy.size();++i){\n\t\tint d=consy[i].first,cur=6+SX+n*2+i;\n\t\twhile(ptr<n && y[py[ptr]]<=d){\n\t\t\tflows::addedge(6+SX+n+py[ptr],cur,1,0);\n\t\t\t++ptr;\n\t\t}\n\t\tif(pr!=-1){\n\t\t\tif(pf<0){\n\t\t\t\tpf=-pf;\n\t\t\t\textraflow+=pf;\n\t\t\t\tflows::addedge(2,cur,pf,0);\n\t\t\t\tflows::addedge(pr,5,pf,0);\n\t\t\t\tflows::addedge(pr,cur,tot-pf,0);\n\t\t\t}\n\t\t\telse flows::addedge(pr,cur,pf,0);\n\t\t}\n\t\tpf=consy[i].second;\n\t\tpr=cur;\n\t}\n\tflows::addedge(2,0,extraflow,0);\n\tflows::addedge(5,3,extraflow,0);\n\tflows::mincostflow();\n\tif(flows::flow==extraflow+tot)\n\t\treturn INF*(LL)tot-flows::cost;\n\treturn 0ll;\n}\nint main(){\n\tint i,j,k;\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;++i){\n\t\tscanf(\"%d%d%lld\",x+i,y+i,v+i);\n\t\t--x[i];--y[i];\n\t\tpx[i]=i;\n\t\tpy[i]=i;\n\t}\n\tscanf(\"%d\",&m);\n\tfor(i=0;i<m;++i){\n\t\tTP[i]=readch();\n\t\tscanf(\"%d%d\",D+i,V+i);\n\t\t--D[i];\n\t}\n\tsort(px,px+n,cmpx);\n\tsort(py,py+n,cmpy);\n\tLL res=0ll;\n\tfor(i=0;i<=n;++i){\n\t\tres=max(res,solve(i));\n\t}\n\tprintf(\"%lld\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\n#include<queue>\nusing namespace std;\nconst long long INF=1e18;\nstruct Graph{\n\tstruct Edge{\n\t\tint v;\n\t\tint c;\n\t\tlong long cost;\n\t\tint nxt;\n\t}e[100010];int tot;\n\tint first[210];\n\tvoid build(int u,int v,int c,long long cost)\n\t{\n\t\te[++tot]=(Edge){v,c,cost,first[u]};\n\t\tfirst[u]=tot;\n\t\treturn ;\n\t}\n\tvoid adde(int u,int v,int c,long long cost)\n\t{\n\t\tbuild(u,v,c,cost);\n\t\tbuild(v,u,0,-cost);\n\t\treturn ;\n\t}\n\tvoid reset()\n\t{\n\t\tmemset(first,0,sizeof(first));\n\t\ttot=1;\n\t\treturn ;\n\t}\n\tlong long dis[210];\n\tint pren[210],pree[210];\n\tbool book[210];\n\tint S,T;\n\tbool spfa()\n\t{\n\t\tqueue<int>q;\n\t\tfor(int i=S;i<=T;i++)\n\t\t\tdis[i]=-INF;\n\t\tbook[S]=true;\n\t\tdis[S]=0;\n\t\tq.push(S);\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tint u=q.front();\n\t\t\tq.pop();book[u]=false;\n\t\t\tfor(int i=first[u];i;i=e[i].nxt)\n\t\t\t\tif(e[i].c&&dis[u]+e[i].cost>dis[e[i].v])\n\t\t\t\t{\n\t\t\t\t\tdis[e[i].v]=dis[u]+e[i].cost;\n\t\t\t\t\tpren[e[i].v]=u;\n\t\t\t\t\tpree[e[i].v]=i;\n\t\t\t\t\tif(!book[e[i].v])\n\t\t\t\t\t{\n\t\t\t\t\t\tbook[e[i].v]=true;\n\t\t\t\t\t\tq.push(e[i].v);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\treturn dis[T]>-INF;\n\t}\n\tlong long solve()\n\t{\n\t\tlong long ans=0;\n\t\twhile(spfa())\n\t\t{\n\t\t\tans+=dis[T];\n\t\t\tfor(int i=T;i!=S;i=pren[i])\n\t\t\t{\n\t\t\t\tint ee=pree[i];\n\t\t\t\te[ee].c--;\n\t\t\t\te[ee^1].c++;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n}G;\nint n,m;\nint l[110],r[110],d[110],u[110];\nint L[81],R[81],D[81],U[81];\nint x[81],y[81];\nlong long v[81];\nlong long solve(int k)\n{\n\tG.reset();\n\tfor(int i=1;i<=k;i++)\n\t\tL[i]=D[i]=1,R[i]=U[i]=100;\n\tfor(int i=1;i<=100;i++)\n\t{\n\t\t//l\n\t\tif(l[i]+1<=k)L[l[i]+1]=max(L[l[i]+1],i+1);\n\t\t//d\n\t\tif(d[i]+1<=k)D[d[i]+1]=max(D[d[i]+1],i+1);\n\t\t//r\n\t\tif(k-r[i]>0)R[k-r[i]]=min(R[k-r[i]],i-1);\n\t\t//u\n\t\tif(k-u[i]>0)U[k-u[i]]=min(U[k-u[i]],i-1);\n\t}\n\tfor(int i=2;i<=k;i++)\n\t\tL[i]=max(L[i],L[i-1]),\n\t\tD[i]=max(D[i],D[i-1]);\n\tfor(int i=k-1;i>=1;i--)\n\t\tR[i]=min(R[i],R[i+1]),\n\t\tU[i]=min(U[i],U[i+1]);\n\tG.S=0;G.T=k+n+n+k+1;\n\tfor(int i=1;i<=k;i++)\n\t{\n\t\tG.adde(G.S,i,1,0);\n\t\tG.adde(k+n+n+i,G.T,1,0);\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tG.adde(k+i,k+n+i,1,v[i]);\n\t\tfor(int j=1;j<=k;j++)\n\t\t{\n\t\t\tif(L[j]<=x[i]&&x[i]<=R[j])\n\t\t\t\tG.adde(j,k+i,1,0);\n\t\t\tif(D[j]<=y[i]&&y[i]<=U[j])\n\t\t\t\tG.adde(k+n+i,k+n+n+j,1,0);\n\t\t}\n\t}\n\treturn G.solve();\n}\nchar s[5];\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d %d %lld\",&x[i],&y[i],&v[i]);\n\tfor(int i=1;i<=100;i++)\n\t\tl[i]=r[i]=u[i]=d[i]=n;\n\tscanf(\"%d\",&m);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%s\",s);\n\t\tint a,b;scanf(\"%d %d\",&a,&b);\n\t\tif(s[0]=='L')l[a]=min(l[a],b);\n\t\tif(s[0]=='R')r[a]=min(r[a],b);\n\t\tif(s[0]=='D')d[a]=min(d[a],b);\n\t\tif(s[0]=='U')u[a]=min(u[a],b);\n\t}\n\tlong long ans=0;\n\tfor(int i=1;i<=n;i++)\n\t\tans=max(ans,solve(i));\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n#define LL long long\n#define fgx cerr<<\"--------------\"<<endl;\n#define dgx cerr<<\"==============\"<<endl;\n\ninline LL read(){\n\tLL x=0,f=1; char c=getchar();\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0';\n\treturn x*f;\n}\nconst LL MAXN = 100010;\nconst LL INF = 1000000000;\n\nLL N; LL d[2][MAXN+1],V[MAXN+1];\nLL Cost[MAXN+1]; LL Node[MAXN+1],Next[MAXN+1],C[MAXN+1],Root[MAXN+1];\nLL cnt; LL S,T;\ninline void addedge(LL u,LL v,LL c,LL w){ Cost[cnt]=w; C[cnt]=c; Node[cnt]=v; Next[cnt]=Root[u]; Root[u]=cnt++; }\ninline void insert(LL u,LL v,LL c,LL w){ w=-w; addedge(u,v,c,w); addedge(v,u,0,-w); return ; }\nLL dis[MAXN+1]; bool inq[MAXN+1];\nLL ans,ret;\ninline bool BFS(){\n\tmemset(inq,false,sizeof(inq));\n\tdeque<LL> que; for(LL i=0;i<=T;i++) dis[i]=INF;\n\tdis[T]=0; que.push_back(T); inq[T]=true;\n\twhile(!que.empty()){\n\t    LL k=que.front(); que.pop_front();\n\t\tfor(LL x=Root[k];x!=-1;x=Next[x]){\n\t\t    LL v=Node[x];\n\t\t    if(C[x^1]>0&&dis[v]>dis[k]-Cost[x]){\n\t\t        dis[v]=dis[k]-Cost[x];\n\t\t\t\tif(!inq[v]){\n\t\t\t\t\tinq[v]=true;\n\t\t\t\t    if(que.empty()||dis[v]<=dis[que.front()]) que.push_front(v);\n\t\t\t\t    else que.push_back(v);\n\t\t\t    }\n\t\t    }\n\t    }inq[k]=false;\n\t} return dis[S]<INF;\n} LL fans;\ninline LL DFS(LL k,LL t){\n    if(k==T) {inq[k]=1;return t;} \n\tinq[k]=1; LL res=0;\n\tfor(LL x=Root[k];x!=-1;x=Next[x]){\n\t    LL v=Node[x];\n\t    if(C[x]>0&&!inq[v]&&dis[v]==dis[k]-Cost[x]){\n\t        LL tmp=DFS(v,min(t,C[x]));\n\t\t\tif(!tmp) continue; C[x]-=tmp; C[x^1]+=tmp;\n\t\t\tres+=tmp; t-=tmp; fans+=(LL)tmp*Cost[x]; if(!t) return res;\t\n\t    }\n    } return res;\n}\n#define fr first\n#define sc second\ninline void Max(LL &a,LL b){ a=max(a,b); }\ninline void Min(LL &a,LL b){ a=min(a,b); }\nLL L[2][MAXN+1],R[2][MAXN+1];\nLL M; char ch[5];\nvector<pair<LL,LL> > vec[4];\ninline void check(LL K){\n\tfor(LL i=0;i<=100;i++) L[0][i]=L[1][i]=1,R[0][i]=R[1][i]=100; cnt=0;\n\tfor(LL i=0;i<=N*2+2*K+1;i++) Root[i]=-1;\n\tfor(LL i=0,l=vec[0].size();i<l;i++) Max(L[0][vec[0][i].fr+1],vec[0][i].sc+1);\n\tfor(LL i=0,l=vec[1].size();i<l;i++) if(vec[1][i].fr<K) Min(R[0][K-vec[1][i].fr],vec[1][i].sc-1);\n\tfor(LL i=0,l=vec[2].size();i<l;i++) Max(L[1][vec[2][i].fr+1],vec[2][i].sc+1);\n\tfor(LL i=0,l=vec[3].size();i<l;i++) if(vec[3][i].fr<K) Min(R[1][K-vec[3][i].fr],vec[3][i].sc-1);\n\tS=0,T=N*2+K*2+1; for(LL i=1;i<=N;i++) insert(i,N+i,1,V[i]);\n\tfor(LL i=0;i<2;i++){\n\t\tfor(LL j=1;j<=100;j++) L[i][j]=max(L[i][j],L[i][j-1]);\n\t\tfor(LL j=99;j>=0;j--) R[i][j]=min(R[i][j],R[i][j+1]);\n\t\tfor(LL j=1;j<=K;j++){\n\t\t\tif(!i) insert(S,N*2+j,1,0);\n\t\t\telse insert(N*2+K+j,T,1,0);\n\t\t\tfor(LL k=1;k<=N;k++){\n\t\t\t\tif(d[i][k]>=L[i][j]&&d[i][k]<=R[i][j]){\n\t\t\t\t\tif(!i) insert(N*2+j,k,1,0);\n\t\t\t\t\telse insert(N+k,N*2+K+j,1,0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} fans=0;\n\tret=0; while(BFS()) ret+=DFS(S,INF);\n\tans=max(ans,-fans); return ; \n}\n\nint main(){\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tN=read();\n\tmemset(Root,-1,sizeof(Root));\n\tfor(LL i=1;i<=N;i++){\n\t\td[0][i]=read(),d[1][i]=read(),V[i]=read();\n\t} M=read();\n\tfor(LL i=1;i<=M;i++){\n\t\tscanf(\"%s\",ch+1); LL a=read(),b=read();\n\t\tLL opr; if(ch[1]=='L') opr=0;\n\t\telse if(ch[1]=='R') opr=1;\n\t\telse if(ch[1]=='U') opr=3;\n\t\telse opr=2; vec[opr].push_back(make_pair(b,a));\n\t}\n\tfor(LL i=1;i<=4;i++) sort(vec[i].begin(),vec[i].end());\n\tfor(LL K=1;K<=N;K++) check(K);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint N, M, x[100], y[100], x_code[100], y_code[100], in_code[100], out_code[100], lX[100], lY[100], rX[100], rY[100], lim[100], coord[100];\nlong long v[100];\nchar type[100];\nconst long long INF = 1LL << 60;\n\nclass maxFlowMinCut\n{\npublic:\n    int S, D, N, t[400], c[400][400], f[400][400];\n    bool inQ[400];\n    long long d[400], bani[400][400];\n    vector < int > v[400];\n\n    void addEdge (int x, int y, int cap, long long ban)\n    {\n        c[x][y] = cap, c[y][x] = 0;\n        bani[x][y] = ban, bani[y][x] = -ban;\n        v[x].push_back (y);\n        v[y].push_back (x);\n    }\n\n    bool bellman ()\n    {\n        queue < int > cc;\n        for (int i=1; i<=N; i++)\n            t[i] = -1, d[i] = INF, inQ[i] = 0;\n        t[S] = 0, d[S] = 0, inQ[S] = 1;\n        cc.push (S);\n        while (!cc.empty ())\n        {\n            int nod = cc.front ();\n            cc.pop (), inQ[nod] = 0;\n            for (auto it : v[nod])\n                if (c[nod][it] > f[nod][it] && d[nod] + bani[nod][it] < d[it])\n                {\n                    d[it] = d[nod] + bani[nod][it];\n                    t[it] = nod;\n                    if (!inQ[it])\n                        inQ[it] = 1,\n                        cc.push (it);\n                }\n        }\n        return (d[D] < INF);\n    }\n\n    pair < int, long long > minCostMaxFlow ()\n    {\n        int cap = 0;\n        long long ban = 0;\n        while (bellman ())\n        {\n            int minC = 1e9;\n            for (int i=D; i != S; i = t[i])\n                minC = min (minC, c[t[i]][i] - f[t[i]][i]);\n            for (int i=D; i != S; i = t[i])\n                f[t[i]][i] += minC,\n                f[i][t[i]] -= minC;\n            cap += minC, ban += 1LL * minC * d[D];\n        }\n        return {cap, ban};\n    }\n\n    void clear ()\n    {\n        for (int i=1; i<=N; i++)\n        {\n            for (auto j : v[i])\n                c[i][j] = c[j][i] = 0,\n                f[i][j] = f[j][i] = 0,\n                bani[i][j] = bani[j][i] = 0LL;\n            v[i].clear ();\n        }\n        S = D = N = 0;\n    }\n}net;\n\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nscanf (\"%d\", &N);\nfor (int i=1; i<=N; i++)\n    scanf (\"%d %d %lld\", &x[i], &y[i], &v[i]);\nscanf (\"%d\\n\", &M);\nfor (int i=1; i<=M; i++)\n    scanf (\"%c %d %d\\n\", &type[i], &coord[i], &lim[i]);\nlong long best = 0;\nfor (int K=1; K<=N; K++)\n{\n    net.clear (), net.S = 1, net.D = net.N = 2;\n    for (int i=1; i<=K; i++)\n        x_code[i] = ++net.N,\n        net.addEdge (net.S, x_code[i], 1, 0);\n    for (int i=1; i<=N; i++)\n        in_code[i] = ++net.N,\n        out_code[i] = ++net.N,\n        net.addEdge (in_code[i], out_code[i], 1, -v[i]);\n    for (int i=1; i<=K; i++)\n        y_code[i] = ++net.N,\n        net.addEdge (y_code[i], net.D, 1, 0);\n    for (int i=1; i<=K; i++)\n        lX[i] = lY[i] = 0,\n        rX[i] = rY[i] = 200;\n    for (int i=1; i<=M; i++)\n    {\n        if (type[i] == 'L' && lim[i] < K) lX[lim[i] + 1] = max (lX[lim[i] + 1], coord[i] + 1);\n        if (type[i] == 'R' && lim[i] < K) rX[K - lim[i]] = min (rX[K - lim[i]], coord[i] - 1);\n        if (type[i] == 'D' && lim[i] < K) lY[lim[i] + 1] = max (lY[lim[i] + 1], coord[i] + 1);\n        if (type[i] == 'U' && lim[i] < K) rY[K - lim[i]] = min (rY[K - lim[i]], coord[i] - 1);\n    }\n    for (int i=2; i<=K; i++)\n        lX[i] = max (lX[i], lX[i - 1]),\n        lY[i] = max (lY[i], lY[i - 1]);\n    for (int i=K - 1; i>=1; i--)\n        rX[i] = min (rX[i], rX[i + 1]),\n        rY[i] = min (rY[i], rY[i + 1]);\n    for (int i=1; i<=K; i++)\n        for (int j=1; j<=N; j++)\n        {\n            if (lX[i] <= x[j] && x[j] <= rX[i])\n                net.addEdge (x_code[i], in_code[j], 1, 0);\n            if (lY[i] <= y[j] && y[j] <= rY[i])\n                net.addEdge (out_code[j], y_code[i], 1, 0);\n        }\n/*    for (int i=1; i<=N; i++)\n        if (i == 1 || (5 <= i && i <= 7))\n            printf (\"%d %d\\n\", x[i], y[i]);\n    for (int i=1; i<=K; i++)\n        printf (\"[%d %d] [%d %d]\\n\", lX[i], rX[i], lY[i], rY[i]);*/\n    auto ans = net.minCostMaxFlow ();\n    //printf (\"%d -> %lld\\n\", ans.first, -ans.second);\n    if (ans.first != K)\n        break;\n    if (-ans.second > best)\n        best = -ans.second;\n}\nprintf (\"%lld\\n\", best);\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define TRACE(x) x\n#define WATCH(x) TRACE(cout << #x\" = \" << x << endl)\n#define WATCHR(a, b) TRACE(for (auto it=a; it!=b;) cout << *(it++) << \" \"; cout << endl)\n#define WATCHC(V) TRACE({cout << #V\" = \"; WATCHR(V.begin(), V.end());})\n\n#define all(x) (x).begin(), (x).end()\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate<typename F, typename C> struct min_cost_flow {\n    static constexpr int bits = 63 - __builtin_clzll(numeric_limits<F>::max());\n\n    int V;\n    vvi adj;\n    vi dest;\n    vector<F> cap;\n    vector<C> cost;\n\n    min_cost_flow(int V = 0) : V(V) {\n        adj.resize(V);\n    }\n\n    void __arc(int u, int v, F f, C c) {\n        adj[u].push_back(dest.size());\n        dest.push_back(v);\n        cap.push_back(f);\n        cost.push_back(c);\n    }\n\n    // Inserts a directed edge u --> v with capacity f and cost c.\n    void arc(int u, int v, F f, C c) {\n        __arc(u, v, f, c);\n        __arc(v, u, F(0), -c);\n    }\n\n    bool dijkstra(auto& imb, auto& flow, auto& pot, F delta) {\n        priority_queue<tuple<C, int, int>> q;\n        vi ent(V, -2);\n        vector<C> dist(V, numeric_limits<C>::max());\n        for (int v = 0; v < V; v++) if (imb[v] >= delta) {\n            dist[v] = 0;\n            q.push(make_tuple(0., v, -1));\n        }\n\n        while (!q.empty()) {\n            C d; int v, f; tie(d, v, f) = q.top(); q.pop();\n            if (ent[v] != -2) continue;\n            dist[v] = -d; ent[v] = f;\n            for (int e : adj[v]) if (cap[e] - flow[e] >= delta) {\n                double cd = dist[v] + (cost[e] + pot[v] - pot[dest[e]]);\n                if (cd < dist[dest[e]]) {\n                    dist[dest[e]] = cd;\n                    q.push(make_tuple(-cd, dest[e], e ));\n                }\n            }\n        }\n\n        for (int v = 0; v < V; v++) if (ent[v] != -2 && imb[v] <= -delta) {\n            for (int u = 0; u < V; u++) pot[u] += dist[u];\n            for (int e = ent[v]; ~e; e = ent[dest[e^1]]) {\n                flow[e] += delta;\n                flow[e^1] -= delta;\n                imb[dest[e]] += delta;\n                imb[dest[e^1]] -= delta;\n            }\n            return true;\n        }\n        return false;\n    }\n\n    // O(E^2 * log V * bits)\n    pair<bool, C> solve(vector<F>& imb) {\n        vector<F> flow(cap.size());\n        vector<C> pot(V);\n        for (F delta = 1ll << bits; delta; delta >>= 1) {\n            for (int e = 0; e < dest.size(); e++) {\n                int u = dest[e^1], v = dest[e];\n                F res = cap[e] - flow[e];\n                if (res >= delta && cost[e] + pot[u] - pot[v] < 0) {\n                    flow[e^1] -= res;\n                    flow[e] += res;\n                    imb[u] -= res;\n                    imb[v] += res;\n                }\n            }\n            while (dijkstra(imb, flow, pot, delta));\n        }\n\n        C ans = 0;\n        for (int e = 0; e < dest.size(); e++) if (flow[e] > 0)  {\n            ans += flow[e] * cost[e];\n        }\n        return { imb == vector<F>(V, 0), ans };\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n\n    int N, M;\n    cin >> N;\n\n    vi x(N), y(N); vll val(N);\n    for (int i = 0; i < N; i++) {\n        cin >> x[i] >> y[i] >> val[i];\n    }\n\n    cin >> M;\n    string dir(M, '.'); vi loc(M), qua(M);\n    for (int i = 0; i < M; i++) {\n        cin >> dir[i] >> loc[i] >> qua[i];\n    }\n\n    auto pmin = [](vi& v, int inx, int val) {\n        if (inx >= 0 && inx < v.size()) v[inx] = min(v[inx], val);\n    };\n    auto pmax = [](vi& v, int inx, int val) {\n        if (inx >= 0 && inx < v.size()) v[inx] = max(v[inx], val);\n    };\n    auto best = [&](int K) {\n        vi xlo(K, 1), xhi(K, 100), ylo(K, 1), yhi(K, 100);\n        for (int i = 0; i < M; i++) {\n            if (dir[i] == 'L') pmax(xlo, qua[i], loc[i] + 1);\n            if (dir[i] == 'R') pmin(xhi, K - 1 - qua[i], loc[i] - 1);\n            if (dir[i] == 'D') pmax(ylo, qua[i], loc[i] + 1);\n            if (dir[i] == 'U') pmin(yhi, K - 1 - qua[i], loc[i] - 1);\n        }\n        for (int i = 1; i < K; i++) {\n            xlo[i] = max(xlo[i], xlo[i-1]);\n            ylo[i] = max(ylo[i], ylo[i-1]);\n        }\n        for (int i = K - 2; i >= 0; i--) {\n            xhi[i] = min(xhi[i], xhi[i+1]);\n            yhi[i] = min(yhi[i], yhi[i+1]);\n        }\n\n        const int V = 1 + K + 2 * N + K + 1;\n        const int SRC = 0, XL = 1, JL = 1 + K, YL = 1 + K + 2 * N, SNK = V - 1;\n\n        min_cost_flow<int, ll> g(V);\n        for (int i = 0; i < K; i++) {\n            g.arc(SRC, XL + i, 1, 0);\n            for (int j = 0; j < N; j++) {\n                if (xlo[i] <= x[j] && x[j] <= xhi[i])\n                    g.arc(XL + i, JL + j, 1, 0);\n            }\n            g.arc(YL + i, SNK, 1, 0);\n            for (int j = 0; j < N; j++) {\n                if (ylo[i] <= y[j] && y[j] <= yhi[i])\n                    g.arc(JL + N + j, YL + i, 1, 0);\n            }\n        }\n        const ll MAXV = 1e15;\n        for (int j = 0; j < N; j++) {\n            g.arc(JL + j, JL + N + j, 1, MAXV - val[j]);\n        }\n\n        vi imb(V);\n        imb[SRC] = K;\n        imb[SNK] = -K;\n        auto res = g.solve(imb);\n        return res.first ? MAXV * K - res.second : 0ll;\n    };\n\n    ll ans = 0;\n    for (int k = 1; k <= N; k++)\n        ans = max(ans, best(k));\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<queue>\nusing namespace std;\nconst int maxn = 1e5+5;\nint en[maxn],nt[maxn],la[maxn],v[maxn],owo;\n//owo 1 !!!\nlong long len[maxn];\nvoid adg(int x,int y,int vv,long long le) {\n\ten[++owo]=y; nt[owo]=la[x]; la[x] = owo; len[owo] = le; v[owo] = vv;\n\ten[++owo]=x; nt[owo]=la[y]; la[y] = owo; len[owo] = -le; v[owo] = 0;\n}\nlong long ANS;\nint N,M,tot,QD,ZD;\nint X[maxn],Y[maxn];\nlong long V[maxn];\nchar ss[10],T[maxn];\nint A[maxn],B[maxn];\nint Lx[105],Rx[105];\nint Ly[105],Ry[105];\nint IDX[maxn],IDY[maxn],IDB[maxn];\nqueue<int>Q;\nlong long dis[maxn];\nint path[maxn],epath[maxn];\nbool rd[maxn];\nlong long MAXVAL;\nbool spfa() {\n\tfor(int i=1;i<=tot;i++) {\n\t\tdis[i] = -0x3f3f3f3f; rd[i] = 0;\n\t}\n\trd[QD] = 1; dis[QD] = 0;\n\tQ.push(QD);\n\twhile(Q.size()) {\n\t\tint x = Q.front(); Q.pop(); rd[x] = 0;\n\t\tfor(int it=la[x];it;it=nt[it]) {\n\t\t\tint y = en[it];\n\t\t\tif(v[it]&&dis[y] < dis[x] + len[it]) {\n\t\t\t\tdis[y] = dis[x] + len[it];\n\t\t\t\tpath[y] = x; epath[y] = it;\n\t\t\t\tif(!rd[y]) Q.push(y),rd[y]=1;\n\t\t\t}\n\t\t}\n\t}\n\tif(dis[ZD]<=0) return 0;\n\tint p = ZD;\n\tfor(;p!=QD;p=path[p])\n\t\tv[epath[p]]--,v[epath[p]^1]++;\n\tMAXVAL += dis[ZD];\n\treturn 1;\n}\n\nvoid solve(int K) {\n\tfor(int i=1;i<=tot;i++) la[i] = 0; \n\towo = 1; tot = 0;\n\tfor(int i=1;i<=100;i++) {\n\t\tIDX[i] = ++tot; IDY[i] = ++tot; \n\t}\n\tfor(int i=1;i<=N;i++) {\n\t\tIDB[i] = ++tot;\n\t\tadg(IDX[X[i]],IDB[i],1,V[i]);\n\t\tadg(IDB[i],IDY[Y[i]],1,0);\n\t}\n\t\n\tfill(Lx+1,Lx+1+K,1); fill(Rx+1,Rx+1+K,100);\n\tfill(Ly+1,Ly+1+K,1); fill(Ry+1,Ry+1+K,100);\n\t\n\tfor(int i=1;i<=M;i++) {\n\t\tif(T[i]=='L') Lx[B[i]+1] = max(Lx[B[i]+1],A[i]+1);\n\t\telse if(T[i]=='R'&&K>B[i]) Rx[K-B[i]] = min(Rx[K-B[i]],A[i]-1);\n\t\telse if(T[i]=='D') Ly[B[i]+1] = max(Ly[B[i]+1],A[i]+1);\n\t\telse if(T[i]=='U'&&K>B[i]) Ry[K-B[i]] = min(Ry[K-B[i]],A[i]-1);\n\t}\n\tfor(int i=2;i<=K;i++) Lx[i] = max(Lx[i],Lx[i-1]),Ly[i] = max(Ly[i],Ly[i-1]);\n\tfor(int i=K-1;i>=1;i--) Rx[i] = min(Rx[i],Rx[i+1]),Ry[i] = min(Ry[i],Ry[i+1]);\n\tQD = ++tot; ZD = ++tot;\n\tfor(int i=1;i<=K;i++) {\n\t\tif( (Lx[i] > Rx[i]) || (Ly[i]>Ry[i]) ) return;\n\t\tint p = ++tot; int q = ++tot;\n\t\tadg(QD,p,1,0); \n\t\tadg(q,ZD,1,0);\n\t\tfor(int j=Lx[i];j<=Rx[i];j++) adg(p,IDX[j],1,0);\n\t\tfor(int j=Ly[i];j<=Ry[i];j++) adg(IDY[j],q,1,0);\n\t}\n\tint flow = 0;\n\tMAXVAL = 0;\n\twhile(spfa()) flow++;\n\tif(flow!=K) return;\n\tANS = max(ANS,MAXVAL);\n}\nint main() {\n\tscanf(\"%d\",&N);\n\tfor(int i=1;i<=N;i++) {\n\t\tscanf(\"%d%d%lld\",&X[i],&Y[i],&V[i]);\n\t}\n\tscanf(\"%d\",&M);\n\tfor(int i=1;i<=M;i++) {\n\t\tscanf(\"%s%d%d\",&ss[1],&A[i],&B[i]);\n\t\tT[i] = ss[1];\n\t}\n\tfor(int i=1;i<=N;i++) solve(i);\n\tprintf(\"%lld\",ANS);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <assert.h>\n\nusing namespace std;\n\nstruct Jewel\n{\n  int x, y;\n  long long v;\n  int cnt = 0;\n\n  bool operator<(const Jewel &other) const\n  {\n    return (other.v == v ? cnt < other.cnt : other.v < v);\n  }\n};\n\nstruct Request\n{\n  string t;\n  int a, b;\n  int cnt = 0;\n};\n\nint main()\n{\n  int N;\n  cin >> N;\n  vector<Jewel> jewel(N);\n  for (int i = 0; i < N; i++)\n  {\n    int x, y;\n    long long v;\n    cin >> x >> y >> v;\n    jewel[i] = {x, y, v};\n  }\n  int M;\n  cin >> M;\n  vector<Request> request(M);\n  for (int i = 0; i < M; i++)\n  {\n    string t;\n    int a, b;\n    cin >> t >> a >> b;\n    request[i] = {t, a, b};\n  }\n  chrono::system_clock::time_point start = chrono::system_clock::now();\n  long long ans = 0;\n  while (chrono::duration_cast<chrono::microseconds>(chrono::system_clock::now() - start).count() / 1000 < 4998)\n  {\n    long long tmp = 0;\n    for (Request &j : request)\n      j.cnt = 0;\n    for (Jewel i : jewel)\n    {\n      bool ok = true;\n      for (Request j : request)\n        switch (j.t[0])\n        {\n        case 'L':\n          if (i.x <= j.a && j.b < j.cnt + 1)\n            ok = false;\n          break;\n        case 'R':\n          if (j.a <= i.x && j.b < j.cnt + 1)\n            ok = false;\n          break;\n        case 'D':\n          if (i.y <= j.a && j.b < j.cnt + 1)\n            ok = false;\n          break;\n        case 'U':\n          if (j.a <= i.y && j.b < j.cnt + 1)\n            ok = false;\n          break;\n        }\n      if (!ok)\n        continue;\n      tmp += i.v;\n      for (Request &j : request)\n        switch (j.t[0])\n        {\n        case 'L':\n          if (i.x <= j.a)\n            j.cnt++;\n          break;\n        case 'R':\n          if (j.a <= i.x)\n            j.cnt++;\n          break;\n        case 'D':\n          if (i.y <= j.a)\n            j.cnt++;\n          break;\n        case 'U':\n          if (j.a <= i.y)\n            j.cnt++;\n          break;\n        }\n    }\n    swap(jewel[rand() % N], jewel[rand() % N]);\n    if (ans < tmp)\n      ans = tmp;\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\ntemplate<typename T>\nstruct PrimalDual{\n  struct edge{\n    Int to;\n    T cap,cost;\n    Int rev;\n    edge(){}\n    edge(Int to,T cap,T cost,Int rev):to(to),cap(cap),cost(cost),rev(rev){}\n  };\n  \n  T INF;\n  vector<vector<edge> > G;\n  vector<T> h,dist;\n  vector<Int> prevv,preve;\n\n  PrimalDual(){}\n  PrimalDual(Int n,T INF):INF(INF),G(n),h(n),dist(n),prevv(n),preve(n){}\n  \n  void add_edge(Int from,Int to,T cap,T cost){\n    G[from].emplace_back(to,cap,cost,G[to].size());\n    G[to].emplace_back(from,0,-cost,G[from].size()-1);\n  }\n\n  T flow(Int s,Int t,T f,Int &ok){    \n    T res=0;\n    fill(h.begin(),h.end(),0);\n    while(f>0){\n      using P = pair<T, Int>;\n      priority_queue<P,vector<P>,greater<P> > que;\n      fill(dist.begin(),dist.end(),INF);\n      \n      dist[s]=0;\n      que.emplace(dist[s],s);\n      while(!que.empty()){\n        P p=que.top();que.pop();\n        Int v=p.second;\n        if(dist[v]<p.first) continue;\n        for(Int i=0;i<(Int)G[v].size();i++){\n          edge &e=G[v][i];\n          if(e.cap==0) continue;\n          if(dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n            dist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n            prevv[e.to]=v;\n            preve[e.to]=i;\n            que.emplace(dist[e.to],e.to);\n          }\n        }\n      }\n      if(dist[t]==INF) return ok=0;\n      \n      for(Int v=0;v<(Int)h.size();v++) h[v]+=dist[v];\n\n      T d=f;\n      for(Int v=t;v!=s;v=prevv[v])\n        d=min(d,G[prevv[v]][preve[v]].cap);\n      \n      f-=d;\n      res+=d*h[t];\n      for(Int v=t;v!=s;v=prevv[v]){\n        edge &e=G[prevv[v]][preve[v]];\n        e.cap-=d;\n        G[v][e.rev].cap+=d;\n      }\n    }\n    ok=1;\n    return res;\n  }\n};\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<Int> xs(n),ys(n),vs(n);\n  for(Int i=0;i<n;i++) cin>>xs[i]>>ys[i]>>vs[i];\n\n  Int m;\n  cin>>m;\n  vector<char> ts(m);\n  vector<Int> as(m),bs(m);\n  for(Int i=0;i<m;i++) cin>>ts[i]>>as[i]>>bs[i];\n\n  const Int INF = 1e16;\n  vector<Int> ls(n,-INF),rs(n,INF),ds(n,-INF),us(n,INF);\n  for(Int i=0;i<m;i++){\n    if(ts[i]=='L') chmax(ls[bs[i]],as[i]);\n    if(ts[i]=='R') chmin(rs[bs[i]],as[i]);\n    if(ts[i]=='D') chmax(ds[bs[i]],as[i]);\n    if(ts[i]=='U') chmin(us[bs[i]],as[i]);\n  }\n  for(Int i=0;i+1<n;i++){\n    chmax(ls[i+1],ls[i]);\n    chmin(rs[i+1],rs[i]);\n    chmax(ds[i+1],ds[i]);\n    chmin(us[i+1],us[i]);\n  }\n  \n  Int ans=0;\n  for(Int k=1;k<=n;k++){\n    PrimalDual<Int> G(k*2+n*2+2,INF);\n    Int S=k*2+n*2,T=k*2+n*2+1;\n    for(Int i=0;i<k;i++){\n      G.add_edge(S,i,1,0);\n      G.add_edge(k+i,T,1,0);\n    }    \n    \n    for(Int p=0;p<n;p++){\n      G.add_edge(k*2+p,k*2+n+p,1,-vs[p]);      \n      for(Int i=0;i<k;i++){\n        if(xs[p]<=ls[i]) continue;\n        if(xs[p]>=rs[k-(i+1)]) continue;\n        for(Int j=0;j<k;j++){\n          if(ys[p]<=ds[j]) continue;\n          if(ys[p]>=us[k-(j+1)]) continue;          \n          G.add_edge(i,k*2+p,1,0);     \n          G.add_edge(k*2+n+p,k+j,1,0);\n        }\n      }\n    }\n    \n    Int ok=1;\n    Int res=G.flow(S,T,k,ok);    \n    if(!ok) break;\n    chmax(ans,-res);\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<queue>\n#define int long long\nusing namespace std;\nconst int INF=0x3f3f3f3f;\ntypedef long long ll;\nint n,m,s,t;\nll ans,Ans,dist[350];\nint maxflow,vis[350];\nint edgenum,W[26500],V[26500],Next[26500],F[26500],Head[350];\nint lx[350],rx[350],ly[350],ry[350];\nstruct node{ int x,y,v;} p[350];\nstruct node2{ int t,a,b;} q[350];\nchar Getchar(){\n    static char now[1<<20],*S,*T;\n    if (T==S){\n        T=(S=now)+fread(now,1,1<<20,stdin);\n        if (T==S) return EOF;\n    }\n    return *S++;\n}\nint read(){\n    int x=0,f=1;\n    char ch=Getchar();\n    while (ch<'0'||ch>'9'){\n        if (ch=='-') f=-1;\n        ch=Getchar();\n    }\n    while (ch<='9'&&ch>='0') x=x*10+ch-'0',ch=Getchar();\n    return x*f;\n}\nchar readop(){\n    char ch=Getchar();\n    while (ch<'A'||ch>'Z') ch=Getchar();\n    return ch;\n}\nvoid addedge(int u,int v,int w,int f){\n    V[++edgenum]=v; F[edgenum]=f; W[edgenum]=w;\n    Next[edgenum]=Head[u];\n    Head[u]=edgenum;\n}\nvoid Addedge(int u,int v,int w,int f){\n//\tprintf(\"%d %d %d %d\\n\",u,v,w,f);\n    addedge(u,v,w,f);\n    addedge(v,u,0,-f);\n}\nbool spfa(){\n    memset(vis,false,sizeof(vis));\n    memset(dist,0x3f,sizeof(dist));\n    dist[s]=0;\n    vis[s]=true;\n    queue<int> que;\n    que.push(s);\n    while (!que.empty()){\n        int u=que.front(); que.pop();\n        vis[u]=false;\n        for (int e=Head[u];e;e=Next[e]){\n            int d=V[e];\n            if (dist[d]>dist[u]+F[e]&&W[e]){\n                dist[d]=dist[u]+F[e];\n                if (!vis[d]){\n                    que.push(d);\n                    vis[d]=true;\n                }\n            }\n        }\n    }\n    return dist[t]<INF;\n}\nint dfs(int u,int flow){\n    if (u==t){ \n        vis[t]=true; maxflow+=flow;\n        return flow;\n    }\n    int used=0;\n    vis[u]=true;\n    for (int e=Head[u];e;e=Next[e]){\n        int d=V[e];\n        if ((!vis[d]||d==t)&&W[e]&&dist[d]==dist[u]+F[e]){\n            int minflow=dfs(d,min(flow-used,W[e]));\n            if (minflow!=0) ans+=F[e]*minflow,W[e]-=minflow,W[e^1]+=minflow,used+=minflow;\n            if (used==flow) break;\n        }\n    }\n    return used;\n}\nvoid mincostmaxflow(){\n\tans=0; maxflow=0;\n    while (spfa()){\n        vis[t]=1;\n        while (vis[t]){\n            memset(vis,false,sizeof(vis));\n            dfs(s,INF); \n        }\n    }\n}\nvoid solve(int k){\n\tedgenum=1; memset(Head,0,sizeof(Head));\n\ts=k+n+n+k+1; t=s+1;\n\tfor (int i=1;i<=k;i++) Addedge(s,i,1,0),Addedge(k+n+n+i,t,1,0);\n\tfor (int i=1;i<=n;i++) Addedge(k+i,k+n+i,1,-p[i].v);\n    for (int i=1;i<=k;i++) lx[i]=0,ly[i]=0,rx[i]=INF,ry[i]=INF;\n\tfor (int i=1;i<=m;i++)\n\t\tswitch (q[i].t){\n\t\t\tcase 'U': for (int j=1;j<=k-q[i].b;j++) ry[j]=min(ry[j],q[i].a-1); break;\n\t\t\tcase 'D': for (int j=q[i].b+1;j<=k;j++) ly[j]=max(ly[j],q[i].a+1); break;\n\t\t\tcase 'L': for (int j=q[i].b+1;j<=k;j++) lx[j]=max(lx[j],q[i].a+1); break;\n\t\t\tcase 'R': for (int j=1;j<=k-q[i].b;j++) rx[j]=min(rx[j],q[i].a-1); break;\n\t\t}\n    for (int i=1;i<=k;i++)\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tif (lx[i]<=p[j].x&&p[j].x<=rx[i]) Addedge(i,k+j,1,0);\n    for (int i=1;i<=k;i++)\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tif (ly[i]<=p[j].y&&p[j].y<=ry[i]) Addedge(k+n+j,k+n+n+i,1,0);\n\tmincostmaxflow(); Ans=max(Ans,-ans);\n}\nsigned main(){\n\tn=read();\n\tfor (int i=1;i<=n;i++){\n\t\tp[i].x=read();\n\t\tp[i].y=read();\n\t\tp[i].v=read();\n\t}\n\tm=read();\n\tfor (int i=1;i<=m;i++){\n\t\tq[i].t=readop();\n\t\tq[i].a=read();\n\t\tq[i].b=read();\n\t}\n\tfor (int k=1;k<=n;k++) solve(k);\n\tprintf(\"%lld\\n\",Ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace __gnu_pbds;\nusing namespace std;\n \ntemplate <typename T>\nusing ordered_set =\n\ttree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n \n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n\t*this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n \n#define shandom_ruffle random_shuffle\n \nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=327;\nusing bn=bitset<87>;\nusing ld=long double;\n\nint n;\npii gdz[nax];\nll war[nax];\n\nint m;\nbn podz[nax];\nint ile[nax];\n\nll wyn;\n\nbn ter;\n \nll dajwar()\n{\n\tll ret=0;\n\tfor (int i=1; i<=n; i++)\n\t\tif (ter[i])\n\t\t\tret+=war[i];\n\treturn ret;\n}\n \nint popr()\n{\n\tfor (int i=1; i<=m; i++)\n\t\tif ((podz[i]&ter).count()>ile[i])\n\t\t\treturn 0;\n\treturn 1;\n}\n\nstruct Simplex {        // Maximize c*x subject to Ax <= b.\n  using T = ld;     // Initialize the structure, set A, b, c and then run\n  vector<vector<T>> A;  // solve(). Max objective is stored in res. To recover\n  vector<T> b, c;       // the best result, use getVars().\n  int V, E;\n  vector<int> eqIds, varIds, cols;\n  T res;\n  static constexpr T kEps = 1e-5;\n\n  Simplex(int vars, int eqs) : A(eqs, vector<T>(vars)), b(eqs), c(vars),\n      V(vars), E(eqs), eqIds(eqs), varIds(vars), res(0) {\n    iota(varIds.begin(), varIds.end(), 0);\n    iota(eqIds.begin(), eqIds.end(), vars);\n  }\n\n  void pivot(int eq, int var) {\n    T coef = 1 / A[eq][var];\n    cols.clear();\n    for (int i = 0; i < V; i++) {\n      if (abs(A[eq][i]) > kEps) { cols.push_back(i); A[eq][i] *= coef; }\n    }\n    A[eq][var] *= coef; b[eq] *= coef;\n    for (int row = 0; row < E; row++) {\n      if (row == eq || abs(A[row][var]) < kEps) { continue; }\n      T k = -A[row][var];\n      A[row][var] = 0;\n      for (int i : cols) { A[row][i] += k * A[eq][i]; }\n      b[row] += k * b[eq];\n    }\n    T q = c[var]; c[var] = 0;\n    for (int i : cols) { c[i] -= q * A[eq][i]; }\n    res += q * b[eq];\n    swap(varIds[var], eqIds[eq]);\n  }\n\n  bool solve() {\n    while (true) {\n      int eq = -1, var = -1;\n      for (int i = 0; i < E; i++) { if (b[i] < -kEps) { eq = i; break; } }\n      if (eq == -1) { break; }\n      for (int i = 0; i < V; i++) { if (A[eq][i] < -kEps) { var = i; break; } }\n      if (var == -1) { res = -1e9; return false; /* No solution */ }\n      pivot(eq, var);\n    }\n    while (true) {\n      int var = -1, eq = -1;\n      for (int i = 0; i < V; i++) { if (c[i] > kEps) { var = i; break; } }\n      if (var == -1) { break; }\n      for (int i = 0; i < E; i++) {\n        if (A[i][var] < kEps) { continue; }\n        if (eq >= 0 && b[i] / A[i][var] >= b[eq] / A[eq][var]) { continue; }\n        eq = i;\n      }\n      if (eq == -1) { res = 1e9; return false; /* Unbounded */ }\n      pivot(eq, var);\n    }\n    return true;\n  }\n\n  vector<T> getVars() { // Optimal assignment of variables.\n    vector<T> result(V);\n    for (int i = 0; i < E; i++) if (eqIds[i] < V) result[eqIds[i]] = b[i];\n    return result;\n  }\n};\n\nvoid rek(int v, int jesz)\n{\n\tif (popr())\n\t\twyn=max(wyn, dajwar());\n\tif (!jesz)\n\t\treturn;\n\tfor (int i=v; i<=n; i++)\n\t{\n\t\tter.flip(i);\n\t\trek(i+1, jesz-1);\n\t\tter.flip(i);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(\"%d%d%lld\", &gdz[i].first, &gdz[i].second, &war[i]);\n\tscanf(\"%d\", &m);\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\tchar c;\n\t\tint a, b;\n\t\tscanf(\" %c%d%d\", &c, &a, &b);\n\t\tfor (int j=1; j<=n; j++)\n\t\t{\n\t\t\tif (c=='L' && gdz[j].first<=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='R' && gdz[j].first>=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='D' && gdz[j].second<=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='U' && gdz[j].second>=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t}\n\t\tile[i]=b;\n\t}\n\tSimplex janusz(n, m+2*n);\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tjanusz.c[i]=war[i+1];\n\t}\n\tfor (int i=0; i<m; i++)\n\t{\n\t\tjanusz.b[i]=ile[i+1];\n\t\tfor (int j=0; j<n; j++)\n\t\t\tjanusz.A[i][j]=podz[i+1][j+1];\n\t}\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tjanusz.b[m+i]=1;\n\t\tjanusz.A[m+i][i]=1;\n\t}\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tjanusz.b[m+n+i]=0;\n\t\tjanusz.A[m+n+i][i]=-1;\n\t}\n\tassert(janusz.solve());\n\tauto wez=janusz.getVars();\n\t\n\tfor (int i=0; i<n; i++)\n\t\tter[i+1]=(wez[i]>0.5);\n\t\n\tll sta=dajwar();\n\t\n\twhile(popr())\n\t{\n\t\tint czy=0;\n\t\tfor (int i=1; i<=n; i++)\n\t\t{\n\t\t\tif (!ter[i])\n\t\t\t{\n\t\t\t\tter[i]=1;\n\t\t\t\tif (popr())\n\t\t\t\t\tczy=1;\n\t\t\t\telse\n\t\t\t\t\tter[i]=0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (!czy)\n\t\t\tbreak;\n\t}\n\t\n\trek(1, 4+(n<=50));\n\t\n\tdebug() << janusz.getVars();\n\tprintf(\"%lld\\n\", wyn);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n#define REP(i, a, n) for(LL i = (a), i##_max = (n); i < i##_max; ++i)\n#define REM(i, a, n) for(LL i = (LL)(n) - 1, i##min = (a); i >= i##min; --i)\n#define ALL(arr) (arr).begin(), (arr).end()\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP {cin.tie(NULL); ios::sync_with_stdio(false);}\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst string INFSTR = \"\\x7f\";\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate<class T>\nT Compare(T left, T right) { return left > right ? 1 : (left < right ? -1 : 0); }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\ntemplate <class T>\nT Next() { T buf; cin >> buf; return buf; }\n\n#ifdef ONLY_MY_ENVIR\n#include \"IntMod.h\"\n#include \"UnionFind.h\"\n#include \"Graph.h\"\n#include \"Range.h\"\n#include \"Global.h\"\n#include \"FlowSolver.h\"\n#include \"Tree.h\"\n#include \"SuffixArray.h\"\n#include \"Matrix.h\"\n#include \"SegmentTree.h\"\n#include \"SegmentTree2D.h\"\n#include \"BIT.h\"\n#include \"Rational.h\"\n#include \"Position.h\"\n#include \"Factorization.h\"\n#include \"Math.h\"\n#include \"LazySegmentTree.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>> (istream& ist, __int128& val) { LL tmp;  ist >> tmp; val = tmp; return ist; }\nostream& operator<< (ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\n#if 1234567891\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\n// template <class T>\n// auto Is(const T& value) { return [value](const auto& comparand) -> bool { return comparand == value; }; }\n#endif\n\nint N, M;\nint x[80], y[80];\nLLL v[80];\nchar t[320];\nint a[320], b[320];\nbool lim[320][80];\nint c[320];\n\nvoid pre() {\n\tREP(j, 0, M) {\n\t\tREP(i, 0, N) {\n\t\t\tbool ng = false;\n\t\t\tswitch (t[j]) {\n\t\t\tcase 'L': ng = (x[i] <= a[j]); break;\n\t\t\tcase 'R': ng = (x[i] >= a[j]); break;\n\t\t\tcase 'D': ng = (y[i] <= a[j]); break;\n\t\t\tcase 'U': ng = (y[i] >= a[j]); break;\n\t\t\t}\n\t\t\tif (ng) lim[j][i] = true;\n\t\t}\n\t}\n}\n\nLLL estimate(int i, bool inc) {\n\tLLL delta = inc ? v[i] : -v[i];\n\tconst LLL penalty = 1e23;\n\tif (inc) {\n\t\tREP(j, 0, M) {\n\t\t\tif (lim[j][i]) {\n\t\t\t\tif (c[j] == b[j]) delta -= penalty;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tREP(j, 0, M) {\n\t\t\tif (lim[j][i]) {\n\t\t\t\tif (c[j] == b[j] + 1) delta += penalty;\n\t\t\t}\n\t\t}\n\t}\n\treturn delta;\n}\n\nvoid change(int i, bool inc) {\n\tif (inc) {\n\t\tREP(j, 0, M) {\n\t\t\tif (lim[j][i]) {\n\t\t\t\t++c[j];\n\t\t\t}\n\t\t}\n\t} else {\n\t\tREP(j, 0, M) {\n\t\t\tif (lim[j][i]) {\n\t\t\t\t--c[j];\n\t\t\t}\n\t\t}\n\t}\n}\n\nLLL sub() {\n\tpre();\n\tmt19937 mt;\n\tvector<bool> ans(N, false);\n\tLLL score = 0;\n\tLLL mx = score;\n\tdouble temp_start = 1e18;\n\tdouble temp_end = 0.1;\n\tdouble temp = 5;\n\n\tconst int times = 10000000;\n\tREP(z, 0, times) {\n\t\tint i = mt() % N;\n\n\t\tLLL pre_score = score;\n\n\t\tans[i] = !ans[i];\n\n\t\tLLL delta = estimate(i, ans[i]);\n\t\tscore = pre_score + delta;\n\t\tmx = max(mx, score);\n\t\tbool accepted = delta > 0 ||\n\t\t\t-delta < temp * 10 && exp(delta / temp) * (1ULL << 32) >= mt();\n\n\t\tif (accepted) {\n\t\t\tchange(i, ans[i]);\n\t\t} else {\n\t\t\tans[i] = !ans[i];\n\t\t\tscore = pre_score;\n\t\t}\n\n\t\tif (z % 2048 == 0) {\n\t\t\tdouble ratio = z / (double)times;\n\t\t\ttemp = pow(temp_start, 1 - ratio) * pow(temp_end, ratio);\n\t\t\tcerr << temp << '\\t' << score << endl;\n\t\t}\n\t}\n\treturn mx;\n}\n\nint main() {\n\tcin >> N;\n\tREP(i, 0, N) {\n\t\tcin >> x[i] >> y[i] >> v[i];\n\t}\n\tcin >> M;\n\tREP(j, 0, M) {\n\t\tcin >> t[j] >> a[j] >> b[j];\n\t}\n\n\tcout << sub() << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<queue>\n#define ll long long\nusing namespace std;\nconst int INF=2147483647;\nstruct Edge\n{\n\tint to,nxt;\n\tint flow;\n\tll cost;\n}e[100005];\nint n,m,s,t,edgenum,head[1005],f[1005],pre[1005],x[85],y[85],a[325],b[325],l1[85],r1[85],l2[85],r2[85];\nll dis[1005],val[85];\nbool flag[1005];\nchar ti[325];\nqueue<int>q;\nvoid add(int u,int v,int f,ll c)\n{\n\te[++edgenum].cost=c;\n\te[edgenum].flow=f;\n\te[edgenum].to=v;\n\te[edgenum].nxt=head[u];\n\thead[u]=edgenum;\n}\nbool SPFA()\n{\n\tfor(int i=1;i<=t;i++)\n\t  dis[i]=1e18,flag[i]=0,f[i]=0;\n\tdis[s]=0;\n\tf[s]=INF;\n\tflag[s]=1;\n\tq.push(s);\n\twhile(!q.empty())\n\t{\n\t\tint node=q.front();\n\t\tq.pop();\n\t\tflag[node]=0;\n\t\tfor(int hd=head[node];hd;hd=e[hd].nxt)\n\t\t{\n\t\t\tint to=e[hd].to;\n\t\t\tif(flag[to])continue;\n\t\t\tif(e[hd].flow==0)continue;\n\t\t\tif(dis[to]>dis[node]+e[hd].cost)\n\t\t\t{\n\t\t\t\tdis[to]=dis[node]+e[hd].cost;\n\t\t\t\tf[to]=min(f[node],e[hd].flow);\n\t\t\t\tpre[to]=hd;\n\t\t\t\tq.push(to);\n\t\t\t}\n\t\t}\n\t}\n\treturn dis[t]<0;\n}\nll EK()\n{\n\tll ans=0;\n\twhile(SPFA())\n\t{\n\t\tans+=f[t]*dis[t];\n\t\tint x=t;\n\t\twhile(x)\n\t\t{\n\t\t\te[pre[x]].flow-=f[t];\n\t\t\te[pre[x]^1].flow+=f[t];\n\t\t\tx=e[pre[x]^1].to;\n\t\t}\n\t}\n\treturn ans;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t  scanf(\"%d%d%lld\",&x[i],&y[i],&val[i]);\n\tscanf(\"%d\",&m);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\twhile(ti[i]<'A'||ti[i]>'Z')ti[i]=(char)getchar();\n\t\tscanf(\"%d%d\",&b[i],&a[i]);\n\t}\n\tll ans=0;\n\tfor(int c=1;c<=n;c++)\n\t{\n\t\tfor(int i=1;i<=c;i++)l1[i]=l2[i]=1,r1[i]=r2[i]=100;\n\t\tfor(int i=1;i<=m;i++)\n\t\t{\n\t\t\tif(ti[i]=='L')if(a[i]+1<=c)l1[a[i]+1]=max(l1[a[i]+1],b[i]+1);\n\t\t\tif(ti[i]=='R')if(a[i]+1<=c)r1[c-a[i]]=min(r1[c-a[i]],b[i]-1);\n\t\t\tif(ti[i]=='D')if(a[i]+1<=c)l2[a[i]+1]=max(l2[a[i]+1],b[i]+1);\n\t\t\tif(ti[i]=='U')if(a[i]+1<=c)r2[c-a[i]]=min(r2[c-a[i]],b[i]-1);\n\t\t}\n\t\tfor(int i=2;i<=c;i++)\n\t\t{\n\t\t\tl1[i]=max(l1[i],l1[i-1]);\n\t\t\tl2[i]=max(l2[i],l2[i-1]);\n\t\t}\n\t\tfor(int i=c-1;i>=1;i--)\n\t\t{\n\t\t\tr1[i]=min(r1[i],r1[i+1]);\n\t\t\tr2[i]=min(r2[i],r2[i+1]);\n\t\t}\n\t\tbool flag=1;\n\t\tfor(int i=1;i<=c;i++)\n\t\t{\n\t\t\tif(l1[i]>r1[i])flag=0;\n\t\t\tif(l2[i]>r2[i])flag=0;\n\t\t}\n\t\tif(!flag)continue;\n\t\ts=2*c+2*n+1,t=2*c+2*n+2;\n\t\tedgenum=1;\n\t\tfor(int i=1;i<=t;i++)head[i]=0;\n\t\tfor(int i=1;i<=c;i++)\n\t\t{\n\t\t\tadd(s,i+2*n,1,0);\n\t\t\tadd(i+2*n,s,0,0);\n\t\t\tadd(i+2*n+c,t,1,0);\n\t\t\tadd(t,i+2*n+c,0,0);\n\t\t\tfor(int j=1;j<=n;j++)\n\t\t\t{\n\t\t\t\tif(x[j]>=l1[i]&&x[j]<=r1[i])\n\t\t\t\t{\n\t\t\t\t\tadd(i+2*n,j,1,0);\n\t\t\t\t\tadd(j,i+2*n,0,0);\n\t\t\t\t}\n\t\t\t\tif(y[j]>=l2[i]&&y[j]<=r2[i])\n\t\t\t\t{\n\t\t\t\t\tadd(j+n,i+2*n+c,1,0);\n\t\t\t\t\tadd(i+2*n+c,j+n,0,0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tadd(i,i+n,1,-val[i]);\n\t\t\tadd(i+n,i,0,val[i]);\n\t\t}\n\t\tans=max(ans,-EK());\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<set>\n#include<map>\nusing std::cin;using std::cerr;\nusing std::max;using std::min;\n#define N 400\n#define inf 1e18\n#define ll long long\n#define db double\n#define dbg1(x) cerr<<#x<<\"=\"<<(x)<<\" \"\n#define dbg2(x) cerr<<#x<<\"=\"<<(x)<<\"\\n\"\nint n,m,L[N],R[N],D[N],U[N];ll ans;\nstruct point{int x,y;ll v;}A[N];\nstruct info{char op;int x,y;}B[N];\nclass Flow\n{\n\tstd::queue<int>q;\n\tint ecnt,last[N],S,T,inq[N],from[N];ll dist[N];\n\tstruct road{int to,f,nex;ll v;}e[N*N];\n\tvoid adde(int u,int v,int w,ll co)\n\t{\n\t\te[++ecnt]=(road){v,w,last[u],co},last[u]=ecnt;\n\t\te[++ecnt]=(road){u,0,last[v],-co},last[v]=ecnt;\n\t}\n\tbool spfa()\n\t{\n\t\tfor(int i=S;i<=T;i++) dist[i]=-inf,inq[i]=0;\n\t\tfor(q.push(S),dist[S]=0;!q.empty();)\n\t\t{\n\t\t\tint top=q.front();inq[top]=0,q.pop();\n\t\t\tfor(int k=last[top];k;k=e[k].nex)\n\t\t\t\tif(dist[e[k].to]<dist[top]+e[k].v&&e[k].f)\n\t\t\t\t{\n\t\t\t\t\tdist[e[k].to]=dist[top]+e[k].v,from[e[k].to]=k;\n\t\t\t\t\tif(!inq[e[k].to]) inq[e[k].to]=1,q.push(e[k].to);\n\t\t\t\t}\n\t\t}\n\t\treturn dist[T]>-inf;\n\t}\n\tll mcf()\n\t{\n\t\tfor(int k=from[T];k;k=from[e[k^1].to]) e[k].f-=1,e[k^1].f+=1;\n\t\treturn dist[T];\n\t}\npublic:\n\tvoid setmap(int x)\n\t{\n\t\tS=0,T=x+n<<1|1,ecnt=1;\n\t\tfor(int i=S;i<=T;i++) last[i]=0;\n\t\tfor(int i=1;i<=x;i++)\n\t\t{\n\t\t\tadde(S,i,1,0),adde(x+n+n+i,T,1,0);\n\t\t\tfor(int j=1;j<=n;j++)\n\t\t\t{\n\t\t\t\tif(A[j].x>=L[i]&&A[j].x<=R[i]) adde(i,x+j,1,0);\n\t\t\t\tif(A[j].y>=D[i]&&A[j].y<=U[i]) adde(x+n+j,x+n+n+i,1,0);\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=n;i++) adde(x+i,x+n+i,1,A[i].v);\n\t}\n\tll MaxcostMaxflow() {ll res=0;while(spfa()) res+=mcf();return res;}\n}F;\nll Solve(int x)\n{\n\tfor(int i=1;i<=x;i++) L[i]=D[i]=0,R[i]=U[i]=999;\n\tfor(int i=1;i<=m;i++) if(B[i].y<x)\n\t{\n\t\tif(B[i].op=='L') L[B[i].y+1]=max(L[B[i].y+1],B[i].x+1);\n\t\tif(B[i].op=='R') R[x-B[i].y]=min(R[x-B[i].y],B[i].x-1);\n\t\tif(B[i].op=='D') D[B[i].y+1]=max(D[B[i].y+1],B[i].x+1);\n\t\tif(B[i].op=='U') U[x-B[i].y]=min(U[x-B[i].y],B[i].x-1);\n\t}\n\tfor(int i=1;i<=x;i++) L[i]=max(L[i],L[i-1]),D[i]=max(D[i],D[i-1]);\n\tfor(int i=x-1;i;i--) R[i]=min(R[i],R[i+1]),U[i]=min(U[i],U[i+1]);\n\tfor(int i=1;i<=x;i++) if(L[i]>R[i]||D[i]>U[i]) return -inf;\n\tF.setmap(x);\n\treturn F.MaxcostMaxflow();\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d%d%lld\",&A[i].x,&A[i].y,&A[i].v);\n\tscanf(\"%d\",&m);\n\tfor(int i=1;i<=m;i++) scanf(\" %c%d%d\",&B[i].op,&B[i].x,&B[i].y);\n\tfor(int i=1;i<=n;i++) ans=max(ans,Solve(i));\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n\nusing namespace std;\nconst int N=105,NN=N<<1,M=N*N;\nconst LL inf=1ll<<55;\nLL rd()\n{\n    LL x=0,w=1;char ch=0;\n    while(ch<'0'||ch>'9'){if(ch=='-') w=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+(ch^48);ch=getchar();}\n    return x*w;\n}\nstruct node\n{\n\tLL x,y;\n\tnode(LL nx=0,LL ny=0){x=nx,y=ny;}\n\tbool operator < (const node &bb) const {return x!=bb.x?x<bb.x:y<bb.y;}\n\tnode operator + (const node &bb) const {return (node){x+bb.x,y+bb.y};}\n}w[M],di[NN];\nint to[M],nt[M],c[M],hd[NN],tot=1,ps,pt,fw[NN],pr[NN],v[NN];\nLL s1,s2,ans;\nvoid adde(int x,int y,int z,LL z1,LL z2)\n{\n\t++tot,to[tot]=y,nt[tot]=hd[x],c[tot]=z,w[tot]=(node){+z1,+z2},hd[x]=tot;\n\t++tot,to[tot]=x,nt[tot]=hd[y],c[tot]=0,w[tot]=(node){-z1,-z2},hd[y]=tot;\n\ts1-=z*z1;\n}\nvoid csfl()\n{\n\tqueue<int> q;\n\twhile(1)\n\t{\n\t\tfor(int i=1;i<=pt;++i) di[i]=(node){-inf,-inf};\n\t\tdi[ps]=(node){0,0},fw[ps]=1<<30,v[ps]=1,q.push(ps);\n\t\tfw[pt]=0;\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tint x=q.front();\n\t\t\tq.pop();\n\t\t\tfor(int i=hd[x];i;i=nt[i])\n\t\t\t{\n\t\t\t\tint y=to[i];\n\t\t\t\tif(c[i]>0&&di[y]<di[x]+w[i])\n\t\t\t\t{\n\t\t\t\t\tdi[y]=di[x]+w[i];\n\t\t\t\t\tpr[y]=i,fw[y]=min(fw[x],c[i]);\n\t\t\t\t\tif(!v[y]) v[y]=1,q.push(y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tv[x]=0;\n\t\t}\n\t\tif(!fw[pt]) return;\n\t\ts1+=di[pt].x*fw[pt],s2+=di[pt].y*fw[pt];\n\t\tint x=pt;\n\t\twhile(x!=ps)\n\t\t{\n\t\t\tint i=pr[x];\n\t\t\tc[i]-=fw[pt],c[i^1]+=fw[pt];\n\t\t\tx=to[i^1];\n\t\t}\n\t}\n}\nint n,m,t=100;\nchar cc[2];\nLL a[N][3],b[N<<2][3],px[N][2],py[N][2];\nmap<char,int> id;\n\nint main()\n{\n//////\n\tid['L']=0,id['R']=1,id['D']=2,id['U']=3;\n\tn=rd();\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=0;j<=2;++j)\n\t\t\ta[i][j]=rd();\n\tm=rd();\n\tfor(int i=1;i<=m;++i)\n\t{\n\t\tscanf(\"%s\",cc),b[i][0]=id[cc[0]];\n\t\tb[i][1]=rd(),b[i][2]=rd();\n\t}\n\tps=0,pt=203;\n\tint yyb=201,zsy=202;\n\tfor(int h=1;h<=n;++h)\n\t{\n\t\tmemset(hd,0,sizeof(int)*(pt+1)),tot=1,s1=s2=0;\n\t\tfor(int i=1;i<=t;++i) px[i][0]=0,px[i][1]=1<<30;\n\t\tfor(int i=1;i<=t;++i) py[i][0]=0,py[i][1]=1<<30;\n\t\tfor(int i=1;i<=m;++i)\n\t\t{\n\t\t\tif(b[i][0]==0) px[b[i][1]][1]=min(px[b[i][1]][1],b[i][2]);\n\t\t\tif(b[i][0]==1) px[b[i][1]-1][0]=max(px[b[i][1]-1][0],h-b[i][2]);\n\t\t\tif(b[i][0]==2) py[b[i][1]][1]=min(py[b[i][1]][1],b[i][2]);\n\t\t\tif(b[i][0]==3) py[b[i][1]-1][0]=max(py[b[i][1]-1][0],h-b[i][2]);\n\t\t}\n\t\tadde(ps,yyb,h,1,0);\n\t\tbool o=1;\n\t\tint np=yyb;\n\t\tfor(int i=t;i;--i)\n\t\t{\n\t\t\tif(px[i][0]>px[i][1]){o=0;break;}\n\t\t\tadde(np,i,px[i][0],1,0),adde(np,i,px[i][1]-px[i][0],0,0);\n\t\t\tnp=i;\n\t\t}\n\t\tnp=zsy;\n\t\tfor(int i=t;i;--i)\n\t\t{\n\t\t\tif(py[i][0]>py[i][1]){o=0;break;}\n\t\t\tadde(i+t,np,py[i][0],1,0),adde(i+t,np,py[i][1]-py[i][0],0,0);\n\t\t\tnp=i+t;\n\t\t}\n\t\tadde(zsy,pt,h,1,0);\n\t\tif(!o) continue;\n\t\tfor(int i=1;i<=n;++i) adde(a[i][0],a[i][1]+t,1,0,a[i][2]);\n\t\tcsfl();\n\t\tif(s1>=0) ans=max(ans,s2);\n\t}\n\tprintf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n\n#define fo(i,j,l) for(int i=j;i<=l;++i)\n#define fd(i,j,l) for(int i=j;i>=l;--i)\n#define eps 1e-1\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double db;\nconst ll N=1000;\nconst db sj=5e-20;\n\nint f1[N],f2[N];\nint s1[N],s2[N];\nint w[N];\nll x[N],y[N],v[N];\n\nint n,m,oo,a,b,o2;\ndb c[N],s[N][N];\nint bh[N];\ndb d[N];\nint dl[N];\nint g,gs;\ndb ans=0;\nll da=0;\n\ninline db iabs(db gg)\n{return (gg<0)?(-gg):gg;}\n\ninline void trans(int h,int k)\n{\n\tint u=bh[h]; bh[h]=k;\n\tdb xs=-s[h][k];\n\ts[h][k]=0; s[h][u]=-1;\n\tfo(i,1,g)s[h][i]=s[h][i]/xs;\n\tc[h]=c[h]/xs;\n\tfo(i,1,gs)if(i!=h&&s[i][k]!=0&&iabs(s[i][k])>sj){\n\t\tfo(l,1,g)s[i][l]=s[i][l]+s[i][k]*s[h][l];\n\t\tc[i]=c[i]+c[h]*s[i][k];\n\t\ts[i][k]=0;\n\t}\n\tfo(i,1,g)d[i]=d[i]+d[k]*s[h][i];\n\tans=ans+d[k]*c[h];\n\td[k]=0;\n}\n\ninline int find()\n{\n\tint po=0; d[0]=sj;\n\tfo(i,1,g)if(d[i]>d[po])po=i;\n\treturn po;\n}\n\ninline void Simplex()\n{\n\tint x;\n\twhile((x=find())!=0){\n\t\tdouble zd=100000000;\n\t\tint po=0;\n\t\tfo(i,1,gs)if(s[i][x]<-sj)if(c[i]/(-s[i][x])<zd)zd=c[i]/(-s[i][x]),po=i;\n\t\tif(!po)break;\n\t\ttrans(po,x);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfo(i,1,n){\n\t\tscanf(\"%lld%lld%lld\",&x[i],&y[i],&v[i]);\n\t}\n\tfo(i,1,n)d[i]=v[i];\n\tscanf(\"%d\",&gs); m=gs;\n\tfo(i,1,m){\n\t\tchar ch=' ';\n\t\tfor(;ch!='L'&&ch!='R'&&ch!='U'&&ch!='D';ch=getchar());\n\t\tint aa,bb;\n\t\tscanf(\"%d%d\",&aa,&bb);\n\t\tc[i]=bb;\n\t\tif(ch=='L'){fo(l,1,n)if(x[l]<=aa)s[i][l]=-1;}\n\t\tif(ch=='R'){fo(l,1,n)if(x[l]>=aa)s[i][l]=-1;}\n\t\tif(ch=='D'){fo(l,1,n)if(y[l]<=aa)s[i][l]=-1;}\n\t\tif(ch=='U'){fo(l,1,n)if(y[l]>=aa)s[i][l]=-1;}\t\t\n\t}\n\tfo(i,1,n){\n\t\t++gs; c[gs]=1;\n\t\ts[gs][i]=-1;\n\t}\n\tg=m+n;\n\tSimplex();\n\tll da=(ll)(ans+eps);\n\tif(da<0)puts(\"-1\");else cout<<da;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\nconst int N = 108, M = 324;\n\nstruct jewel {\n\tint x, y; ll v;\n\tjewel * read() {return scanf(\"%d%d%lld\", &x, &y, &v), this;}\n} a[N];\n\nstruct condition {\n\tchar ty;\n\tint pos, lim;\n\tcondition * read() {static char _[4]; return scanf(\"%s%d%d\", _, &pos, &lim), ty = *_, this;}\n} c[M];\n\nint n, m;\nint xl[N], xu[N], yl[N], yu[N];\n\ninline void up(int &x, const int y) {x < y ? x = y : 0;}\ninline void down(int &x, const int y) {x > y ? x = y : 0;}\ninline void up(ll &x, const ll y) {x < y ? x = y : 0;}\n\nnamespace CF {\n\t#define ad(x) ((x - 1 ^ 1) + 1)\n\n\tconst int N = 400, M = 100000;\n\tconst ll INF = 0x7f7f7f7f7f7f7f7fll;\n\n\tstruct edge {\n\t\tint u, v, f; ll c;\n\t\tedge (int u0 = 0, int v0 = 0, ll c0 = 0, int f0 = 0) : u(u0), v(v0), f(f0), c(c0) {}\n\t} e[M];\n\n\tint V = 2, E = 0, si = 1, ti = 2, flow;\n\tll cost;\n\tint first[N], next[M];\n\tint cur[N], que[M << 1];\n\tll dep[N];\n\tbool in_que[N], used[N];\n\n\tinline void addedge(int u, int v, ll c, int f) {\n\t\te[++E] = edge(u, v, c, f), next[E] = first[u], first[u] = E;\n\t\te[++E] = edge(v, u, -c), next[E] = first[v], first[v] = E;\n\t}\n\n\tbool bfs() {\n\t\tint h = M, t = h + 1, i, x, y;\n\t\tmemset(dep, 127, sizeof dep);\n\t\tque[h] = ti, dep[ti] = 0, in_que[ti] = true;\n\t\tfor (; h < t; ) {\n\t\t\tx = que[h++], in_que[x] = false;\n\t\t\tfor (i = first[x]; i; i = next[i])\n\t\t\t\tif (dep[y = e[i].v] > dep[x] - e[i].c && e[ad(i)].f) {\n\t\t\t\t\tdep[y] = dep[x] - e[i].c;\n\t\t\t\t\tif (!in_que[y])\n\t\t\t\t\t\tin_que[y] = true, (dep[y] >= dep[que[h]] ? que[t++] : que[--h]) = y;\n\t\t\t\t}\n\t\t}\n\t\treturn dep[si] < INF;\n\t}\n\n\tint dfs(int x, int lim) {\n\t\tint a, c, f = 0;\n\t\tif (x == ti || !lim) return lim;\n\t\tused[x] = true;\n\t\tfor (int &i = cur[x]; i; i = next[i])\n\t\t\tif (dep[e[i].v] == dep[x] - e[i].c && e[i].f && !used[e[i].v]) {\n\t\t\t\ta = std::min(lim - f, e[i].f);\n\t\t\t\tc = dfs(e[i].v, a);\n\t\t\t\te[i].f -= c, e[ad(i)].f += c;\n\t\t\t\tif ((f += c) == lim) return f;\n\t\t\t}\n\t\treturn f;\n\t}\n\n\tinline void reset() {E = 0, memset(first, 0, sizeof first);}\n\n\tvoid Dinic() {\n\t\tint f;\n\t\tfor (cost = flow = 0; bfs(); ) {\n\t\t\tmemcpy(cur, first, sizeof cur);\n\t\t\tmemset(used, 0, sizeof used);\n\t\t\tflow += f = dfs(si, INT_MAX);\n\t\t\tcost += dep[si] * f;\n\t\t}\n\t}\n}\n\nll solve(int num) {\n\tint i, j;\n\tstd::fill(xl, xl + num, 1), std::fill(xu, xu + num, 100);\n\tstd::fill(yl, yl + num, 1), std::fill(yu, yu + num, 100);\n\tfor (i = 0; i < m; ++i) if (c[i].lim < num)\n\t\tswitch (c[i].ty) {\n\t\t\tcase 76: up(xl[ c[i].lim ], c[i].pos + 1); break;\n\t\t\tcase 68: up(yl[ c[i].lim ], c[i].pos + 1); break;\n\t\t\tcase 82: down(xu[ num - c[i].lim - 1 ], c[i].pos - 1); break;\n\t\t\tcase 85: down(yu[ num - c[i].lim - 1 ], c[i].pos - 1); break;\n\t\t}\n\tfor (i = 1; i < num; ++i) up(xl[i], xl[i - 1]), up(yl[i], yl[i - 1]);\n\tfor (i = num - 2; i >= 0; --i) down(xu[i], xu[i + 1]), down(yu[i], yu[i + 1]);\n\tCF::reset();\n\tfor (i = 0; i < num; ++i) {\n\t\tCF::addedge(1, 203 + i, 0, 1), CF::addedge(203 + num + i, 2, 0, 1);\n\t\tfor (j = xl[i]; j <= xu[i]; ++j) CF::addedge(203 + i, 2 + j, 0, 1);\n\t\tfor (j = yl[i]; j <= yu[i]; ++j) CF::addedge(102 + j, 203 + num + i, 0, 1);\n\t}\n\tfor (i = 0; i < n; ++i) CF::addedge(2 + a[i].x, 102 + a[i].y, -a[i].v, 1);\n\tCF::Dinic();\n\treturn CF::flow == num ? -CF::cost : 0;\n}\n\nint main() {\n\tint i; ll ans = 0;\n\tscanf(\"%d\", &n);\n\tfor (i = 0; i < n; ++i) a[i].read();\n\tscanf(\"%d\", &m);\n\tfor (i = 0; i < m; ++i) c[i].read();\n\tfor (i = 1; i <= n; ++i) up(ans, solve(i));\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\n#define pb push_back\n#define fir first\n#define sec second\n#define forto(_) for (int e = last[_], v = E[e].to; e; v = E[e = E[e].next].to)\n#define forback(_) for (int _ = T; _ ^ S; _ = pre[_])\n\ntypedef long long LL;\n\nconst int kMaxn = 85, kMaxe = 2e4;\nconst LL kInf64 = 1e15;\n\ntypedef std::pair<int, int> Pii;\ntypedef int IArn[kMaxn];\ntypedef int IArv[kMaxn << 2];\n\nstruct Edge {\n\tint to, capt;\n\tLL cost;\n\tint next;\n} E[kMaxe << 1];\n\nint n, m, tote, S, T;\nIArn X, Y, L, R, U, D;\nIArv last, pre, pree;\nLL V[kMaxn], dist[kMaxn << 2];\nstd::vector<Pii> con[4];\nchar IN[5];\n\ninline void AddEdge(int u, int v, int cap, LL cst) {\n\tE[++tote] = (Edge){v, cap, cst, last[u]}, last[u] = tote;\n\tE[++tote] = (Edge){u, 0, -cst, last[v]}, last[v] = tote;\n}\nLL Mcf();\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d%d%lld\", X + i, Y + i, V + i);\n\t}\n\tscanf(\"%d\", &m);\n\tfor (int i = 0, ai, bi; i < m; i++) {\n\t\tscanf(\"%s%d%d\", IN, &ai, &bi);\n\t\tswitch (IN[0]) {\n\t\t\tcase 'L' :\n\t\t\t\tcon[0].pb(Pii(ai, bi));\n\t\t\t\tbreak;\n\t\t\tcase 'R' :\n\t\t\t\tcon[1].pb(Pii(ai, bi));\n\t\t\t\tbreak;\n\t\t\tcase 'D' :\n\t\t\t\tcon[2].pb(Pii(ai, bi));\n\t\t\t\tbreak;\n\t\t\tcase 'U' :\n\t\t\t\tcon[3].pb(Pii(ai, bi));\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < 4; i++) {\n\t\tstd::vector<Pii> & cur = con[i];\n\t\tif (i & 1) std::sort(cur.begin(), cur.end(), std::greater<Pii>());\n\t\telse std::sort(cur.begin(), cur.end());\n\t\tint back = 0;\n\t\tfor (auto & p : cur) {\n\t\t\tfor (; back && p.sec <= cur[back - 1].sec; --back);\n\t\t\tcur[back++] = p;\n\t\t}\n\t\tcur.erase(cur.begin() + back, cur.end());\n\t}\t\n\tfor (int i = 1; i <= n; i++) {\n\t\tL[i] = D[i] = 1;\n\t}\n\tfor (auto & p : con[0]) {\n\t\tL[p.sec + 1] = p.fir + 1;\n\t}\n\tfor (auto & p : con[2]) {\n\t\tD[p.sec + 1] = p.fir + 1;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tL[i] = std::max(L[i], L[i - 1]);\n\t\tD[i] = std::max(D[i], D[i - 1]);\n\t}\n\n\tLL ans = 0;\n\tfor (int k = 1; k <= n; k++) {\n\t\tfor (int i = 0; i <= k; i++) {\n\t\t\tR[i] = U[i] = 100;\n\t\t}\n\t\tfor (auto & p : con[1]) {\n\t\t\tif (k <= p.sec) continue;\n\t\t\tR[k - p.sec] = p.fir - 1;\n\t\t}\n\t\tfor (auto & p : con[3]) {\n\t\t\tif (k <= p.sec) continue;\n\t\t\tU[k - p.sec] = p.fir - 1;\n\t\t}\n\t\tfor (int i = k - 1; i > 0; i--) {\n\t\t\tR[i] = std::min(R[i + 1], R[i]);\n\t\t\tU[i] = std::min(U[i + 1], U[i]);\n\t\t}\n\n\t\ttote = 1;\n\t\tmemset(last, 0, sizeof last);\n\t\tT = (S = k + n + n + k + 1) + 1;\n\t\tfor (int i = 1; i <= k; i++) {\n\t\t\tAddEdge(S, i, 1, 0);\n\t\t\tAddEdge(k + n + n + i, T, 1, 0);\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tif (L[i] <= X[j] && X[j] <= R[i]) {\n\t\t\t\t\tAddEdge(i, k + j, 1, 0);\n\t\t\t\t}\n\t\t\t\tif (D[i] <= Y[j] && Y[j] <= U[i]) {\n\t\t\t\t\tAddEdge(k + n + j, k + n + n + i, 1, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tAddEdge(k + i, k + n + i, 1, kInf64 - V[i]);\n\t\t}\n\t\tans = std::max(ans, Mcf());\n\t}\n\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n\nbool Spfa() {\n\tstatic std::queue<int> que;\n\tstatic int inque[kMaxn << 2];\n\n\tmemset(pre, 0xff, sizeof pre);\n\tmemset(dist, 0x7f, sizeof dist);\n\n\tfor (dist[S] = 0, que.push(S), inque[S] = 1; !que.empty(); ) {\n\t\tint u = que.front(); que.pop();\n\t\tforto(u) {\n\t\t\tif (E[e].capt > 0 && dist[v] > dist[u] + E[e].cost) {\n\t\t\t\tdist[v] = dist[u] + E[e].cost;\n\t\t\t\tpre[v] = u, pree[v] = e;\n\t\t\t\tif (!inque[v]) {\n\t\t\t\t\tque.push(v), inque[v] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tinque[u] = 0;\n\t}\n\treturn ~pre[T];\n}\n\nLL Mcf() {\n\tLL tot = 0, sumf = 0;\n\twhile (Spfa()) {\n\t\tint flow = 100000;\n\t\tforback(u) {\n\t\t\tflow = std::min(flow, E[pree[u]].capt);\n\t\t}\n\t\ttot += 1ll * flow * dist[T], sumf += flow;\n\t\tforback(u) {\n\t\t\tE[pree[u]].capt -= flow;\n\t\t\tE[pree[u] ^ 1].capt += flow;\n\t\t}\n\t}\n\treturn sumf * kInf64 - tot;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MV = 815;\nconst int ME = 1200006;\nconst ll oo = 1e18;\n\ntemplate <typename T> void cmin(T &x, const T &y)\n{\n\tif(y < x) x = y;\n}\n\ntemplate <typename T> void cmax(T &x, const T &y)\n{\n\tif(y > x) x = y;\n}\n\ntemplate <typename T> void read(T &x)\n{\n\tx = 0; char c = getchar(); bool f = 0;\n\twhile(!isdigit(c) && c!='-') c = getchar();\n\tif(c == '-') f = 1, c = getchar();\n\twhile(isdigit(c)) x = x*10+c-'0', c = getchar();\n\tif(f) x = -x;\n}\n\nstruct EDGE\n{\n\tint v;\n\tll w;\n\tint c;\n\n\tEDGE (const int &v0 = 0, const ll &w0 = 0, const int &c0 = 0) : v(v0), w(w0), c(c0) {}\n};\n\nstruct GRAPH\n{\n\tint fst[MV], nxt[ME], lnum;\n\tint q[MV], pre[MV], inq[MV];\n\tEDGE e[ME];\n\tll dis[MV];\n\n\tvoid init()\n\t{\n\t\tmemset(fst, 0xff, sizeof(fst));\n\t\tlnum = -1;\n\t}\n\n\tGRAPH () {init();}\n\n\tvoid addeg(int nu, int nv, ll nw, int nc)\n\t{\n\t\tnxt[++lnum] = fst[nu];\n\t\te[lnum] = EDGE(nv, nw, nc);\n\t\tfst[nu] = lnum;\n\t\tnxt[++lnum] = fst[nv];\n\t\te[lnum] = EDGE(nu, -nw, 0);\n\t\tfst[nv] = lnum;\n\t}\n\n\tint spfa(int &flow, ll &cost, int frm, int tar)\n\t{\n\t\tint h=0, t=1, x, y, mxf = ME, now;\n\t\tll cst = 0;\n\t\tmemset(dis, 0x9f, sizeof(dis));\n\t\tmemset(inq, 0, sizeof(inq));\n\t\tmemset(pre, 0, sizeof(pre));\n\t\tq[++h] = frm;\n\t\tdis[frm] = 0;\n\t\tpre[frm] = -1;\n\t\twhile(h >= t)\n\t\t{\n\t\t\tx = q[(t++)%MV];\n\t\t\tinq[x] = 0;\n\t\t\tfor(int i=fst[x]; i!=-1; i=nxt[i])\n\t\t\t{\n\t\t\t\ty = e[i].v;\n\t\t\t\tif(e[i].c && dis[y]<dis[x]+e[i].w)\n\t\t\t\t{\n\t\t\t\t\tdis[y] = dis[x]+e[i].w;\n\t\t\t\t\tpre[y] = i;\n\t\t\t\t\tif(!inq[y]) q[(++h)%MV] = y, inq[y] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dis[tar] < -oo) return 0;\n\t\tnow = pre[tar];\n\t\twhile(now != -1)\n\t\t{\n\t\t\tmxf = min(mxf, e[now].c);\n\t\t\tcst += e[now].w;\n\t\t\tnow = pre[e[now^1].v];\n\t\t}\n\t\tnow = pre[tar];\n\t\twhile(now != -1)\n\t\t{\n\t\t\te[now].c -= mxf;\n\t\t\te[now^1].c += mxf;\n\t\t\tnow = pre[e[now^1].v];\n\t\t}\n\t\tflow += mxf;\n\t\tcost += cst*mxf;\n\t\treturn 1;\n\t}\n\n\tpair<int, ll> mcf(int s, int t)\n\t{\n\t\tint flow = 0;\n\t\tll cost = 0;\n\t\twhile(spfa(flow, cost, s, t));\n\t\treturn make_pair(flow, cost);\n\t}\n} G;\n\nint n, m;\nint lx[MV], rx[MV];\nint ly[MV], ry[MV];\nint px[MV], py[MV];\nll pv[MV];\nchar qc[MV];\nint qa[MV], qb[MV];\nint global_s, global_t;\n\nvoid input()\n{\n\tread(n);\n\tfor(int i=1; i<=n; i++) read(px[i]), read(py[i]), read(pv[i]);\n\tread(m);\n\tfor(int i=1; i<=n; i++) lx[i] = 1, rx[i] = 100, ly[i] = 1, ry[i] = 100;\n\tfor(int i=1; i<=m; i++)\n\t{\n\t\tqc[i] = getchar();\n\t\twhile(!isalpha(qc[i])) qc[i] = getchar();\n\t\tread(qa[i]), read(qb[i]);\n\t}\n}\n\nvoid build(int num)\n{\n\tfor(int i=1; i<=num; i++) lx[i] = ly[i] = 1, rx[i] = ry[i] = 100;\n\tfor(int i=1; i<=m; i++)\n\t{\n\t\tif(qb[i] > num) continue;\n\t\tif(qc[i] == 'L') cmax(lx[qb[i]+1], qa[i]+1);\n\t\tif(qc[i] == 'R') cmin(rx[num-qb[i]], qa[i]-1);\n\t\tif(qc[i] == 'D') cmax(ly[qb[i]+1], qa[i]+1);\n\t\tif(qc[i] == 'U') cmin(ry[num-qb[i]], qa[i]-1);\n\t}\n\tfor(int i=1; i<=num; i++) cmax(lx[i], lx[i-1]), cmax(ly[i], ly[i-1]);\n\tfor(int i=num; i>=1; i--) cmin(rx[i], rx[i+1]), cmin(ry[i], ry[i+1]);\n\tG.init();\n\tfor(int i=1; i<=num; i++)\n\t{\n\t\tfor(int j=1; j<=n; j++)\n\t\t{\n\t\t\tif(lx[i]<=px[j] && px[j]<=rx[i]) G.addeg(i, num*2+j, 0, 1);\n\t\t\tif(ly[i]<=py[j] && py[j]<=ry[i]) G.addeg(num*2+n+j, num+i, 0, 1);\n\t\t}\n\t}\n\tfor(int i=1; i<=n; i++) G.addeg(num*2+i, num*2+n+i, pv[i], 1);\n\tglobal_s = num*2+n*2+1, global_t = global_s+1;\n\tfor(int i=1; i<=num; i++) G.addeg(global_s, i, 0, 1), G.addeg(num+i, global_t, 0, 1);\n}\n\nvoid work()\n{\n\tll ans = 0;\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tbuild(i);\n\t\tauto ret = G.mcf(global_s, global_t);\n\t\tif(ret.first == i) cmax(ans, ret.second);\n\t}\n\tprintf(\"%lld\\n\", ans);\n}\n\nint main()\n{\n\tinput();\n\twork();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nclass MinCostFlow {\nprivate:\n    const int n;\n    vector<tuple<int, long long, int>> e;\n    vector<vector<int>> g;\n    vector<long long> h, dis;\n    vector<int> pre;\n    bool dijkstra(int s, int t) {\n        dis.assign(n, 1E18);\n        pre.assign(n, -1);\n        priority_queue<pair<long long, int>> que;\n        dis[s] = 0;\n        que.emplace(0, s);\n        while (!que.empty()) {\n            int u;\n            long long d;\n            tie(d, u) = que.top();\n            d = -d;\n            que.pop();\n            if (dis[u] != d)\n                continue;\n            for (int i : g[u]) {\n                int v, c;\n                long long f;\n                tie(v, f, c) = e[i];\n                if (c > 0 && dis[v] > d + h[u] - h[v] + f) {\n                    dis[v] = d + h[u] - h[v] + f;\n                    pre[v] = i;\n                    que.emplace(-dis[v], v);\n                }\n            }\n        }\n        return dis[t] != 1E18;\n    }\npublic:\n    MinCostFlow(int n) : n(n), g(n) {}\n    void addEdge(int u, int v, long long f, int c) {\n        g[u].push_back(e.size());\n        e.emplace_back(v, f, c);\n        g[v].push_back(e.size());\n        e.emplace_back(u, -f, 0);\n    }\n    pair<int, long long> minCostMaxFlow(const int s, const int t) {\n        int flow = 0;\n        long long cost = 0;\n        h.assign(n, 0);\n        while (dijkstra(s, t)) {\n            for (int i = 0; i < n; ++i)\n                h[i] += dis[i];\n            for (int i = t; i != s; i = get<0>(e[pre[i] ^ 1])) {\n                --get<2>(e[pre[i]]);\n                ++get<2>(e[pre[i] ^ 1]);\n            }\n            ++flow;\n            cost += h[t];\n        }\n        return {flow, cost};\n    }\n};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin >> n;\n    vector<int> x(n), y(n);\n    vector<long long> v(n);\n    for (int i = 0; i < n; ++i)\n        cin >> x[i] >> y[i] >> v[i];\n    int m;\n    cin >> m;\n    vector<int> l(n, 1), r(n, 100), d(n, 1), u(n, 100);\n    for (int i = 0; i < m; ++i) {\n        char t;\n        int a, b;\n        cin >> t >> a >> b;\n        if (t == 'L') {\n            l[b] = max(l[b], a + 1);\n        } else if (t == 'R') {\n            r[b] = min(r[b], a - 1);\n        } else if (t == 'D') {\n            d[b] = max(d[b], a + 1);\n        } else {\n            u[b] = min(u[b], a - 1);\n        }\n    }\n    for (int i = 1; i < n; ++i) {\n        l[i] = max(l[i], l[i - 1]);\n        r[i] = min(r[i], r[i - 1]);\n        d[i] = max(d[i], d[i - 1]);\n        u[i] = min(u[i], u[i - 1]);\n    }\n    long long ans = 0;\n    for (int k = 1; k <= n; ++k) {\n        MinCostFlow flow(2 * (n + k + 1));\n        const int s = 2 * (n + k), t = s + 1;\n        for (int i = 0; i < n; ++i)\n            flow.addEdge(i, i + n, 1E15 - v[i], 1);\n        for (int i = 0; i < k; ++i) {\n            flow.addEdge(s, i + 2 * n, 0, 1);\n            flow.addEdge(i + 2 * n + k, t, 0, 1);\n            for (int j = 0; j < n; ++j) {\n                if (l[i] <= x[j] && x[j] <= r[k - i - 1])\n                    flow.addEdge(i + 2 * n, j, 0, 1);\n                if (d[i] <= y[j] && y[j] <= u[k - i - 1])\n                    flow.addEdge(j + n, i + 2 * n + k, 0, 1);\n            }\n        }\n        auto f = flow.minCostMaxFlow(s, t);\n        if (f.first != k)\n            break;\n        ans = max(ans, k * (long long)1E15 - f.second);\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 1000005\nint tot,last[N],to[N],Next[N],flow[N];\nlong long val[N],dis[N];\nint e[N],q[10000005],S,T,Lx[N],Rx[N],Ly[N],Ry[N];\nint X[N],Y[N],n,m,pre[N];\nstruct node {\n  \tint id,x,y;\n}b[N],A[N];\nstruct pa {\n  \tint x,y;\n  \tlong long v;\n}a[N];\ninline void add(int x,int y,int f,long long v) {\n  Next[++tot]=last[x]; last[x]=tot; to[tot]=y; flow[tot]=f; val[tot]=v;\n}\n#define inf 1000000000000000000ll\ninline bool spfa() {\n  \tfor (int i=S;i<=T;i++) pre[i]=0,dis[i]=-inf,e[i]=0;\n  \tdis[S]=0; e[S]=1;\n  \tint l=0,r=1; q[1]=S;\n  \twhile (l<r) {\n      \tint k=q[++l];\n      \tfor (int i=last[k];i;i=Next[i]) {\n          \tif (!flow[i]||dis[to[i]]>=dis[S]+val[i]) continue;\n          \tdis[to[i]]=dis[S]+val[i];\n          \tpre[to[i]]=i;\n          \tif (!e[to[i]]) e[q[++r]=to[i]]=1;\n        }\n      \te[k]=0;\n    }\n  \treturn dis[T]!=-inf;\n}\ninline long long dinic(int y) {\n  \tlong long ans=0;\n  \tint s=0;\n  \twhile (spfa()) {\n      \ts++;\n      \tfor (int x=T;x!=S;x=to[pre[x]^1]) flow[pre[x]]--,flow[pre[x]^1]++,ans+=val[pre[x]];\n    }\n  \tif (s!=y) return 0;\n  \treturn ans;\n}\ninline long long work(int x) {\n  for (int i=1;i<=m;i++) if (b[i].id&1) A[i]=b[i];\n  else A[i]=node{b[i].id,x-b[i].x,b[i].y};\n  for (int i=1;i<=x;i++) X[i]=2*n+i,Y[i]=2*n+i+x;\n  S=0,T=Y[x]+1;\n  for (int i=S;i<=T;i++) last[i]=0;\n  tot=1;\n  for (int i=1;i<=x;i++) Lx[i]=Ly[i]=1,Rx[i]=Ry[i]=100;\n  for (int i=1;i<=m;i++) {\n  \tif (A[i].x<0||(A[i].x==0&&!(A[i].id&1))) continue;\n    if (A[i].id==1) Lx[A[i].x+1]=max(Lx[A[i].x+1],A[i].y+1);\n    else if (A[i].id==2) Rx[A[i].x]=min(Rx[A[i].x],A[i].y);\n    else if (A[i].id==3) Ly[A[i].x+1]=max(Ly[A[i].x+1],A[i].y+1);\n    else Ry[A[i].x]=min(Ry[A[i].x],A[i].y);\n  }\n  for (int i=1;i<=x;i++) Lx[i]=max(Lx[i],Lx[i-1]),Ly[i]=max(Ly[i],Ly[i-1]);\n  for (int i=x-1;i;i--) Rx[i]=min(Rx[i],Rx[i+1]),Ry[i]=min(Ry[i],Ry[i+1]);\n  for (int i=1;i<=x;i++) if (Lx[i]>Rx[i]) return false;\n  for (int i=1;i<=x;i++) add(S,X[i],1,0),add(X[i],S,0,0),add(Y[i],T,1,0),add(T,Y[i],0,0);\n  for (int i=1;i<=x;i++)\n  for (int j=1;j<=n;j++) {\n    \tif (a[j].x>=Lx[i]&&a[j].x<=Rx[i]) add(X[i],j,1,0),add(j,X[i],0,0);\n    \tif (a[j].y>=Ly[i]&&a[j].y<=Ry[i]) add(j+n,Y[i],1,0),add(Y[i],j+n,0,0);\n  }\n  for (int i=1;i<=n;i++) add(i,i+n,1,a[i].v),add(i+n,i,0,-a[i].v);\n  return dinic(x);\n}\nchar c[15];\nint main() {\n\t//freopen(\"0.in\",\"r\",stdin);\n  scanf(\"%d\",&n);\n  for (int i=1;i<=n;i++) scanf(\"%d%d%lld\",&a[i].x,&a[i].y,&a[i].v);\n  scanf(\"%d\",&m);\n  for (int i=1;i<=m;i++) {\n    \tscanf(\"%s\",c);\n    \tscanf(\"%d%d\",&b[i].y,&b[i].x);\n    \tif (c[0]=='L') b[i].id=1;\n    \tif (c[0]=='R') b[i].id=2;\n    \tif (c[0]=='D') b[i].id=3;\n    \tif (c[0]=='U') b[i].id=4;\n  }\n  long long ans=0;\n  for (int i=1;i<=n;i++) \n\tans=max(ans,work(i));\n  printf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN=500;\nconst int MAXGN=4*MAXN+2;\nconst int MAXGM=5*MAXN;\n\ntypedef struct MCMF {\n\tint n,m;\n\tvector<int> ghead,gnxt,gto,gcap; vector<ll> gcost;\n\n\tvector<ll> d; vector<int> bck; vector<ll> pot;\n\n\t//int ghead[MAXGN],gnxt[2*MAXGM],gto[2*MAXGM],gcap[2*MAXGM],gcost[2*MAXGM];\n\t//int d[MAXGN]; int bck[MAXGN];\n\t//int pot[MAXGN];\n\n\tvoid init(int _n) { n=_n,m=0; ghead=vector<int>(n,-1); gnxt.clear(),gto.clear(),gcap.clear(),gcost.clear(); d=vector<ll>(n); bck=vector<int>(n); pot=vector<ll>(n,0); }\n\tvoid addedge(int a,int b,int c,ll d) {\n\t\tgnxt.PB(ghead[a]); ghead[a]=m; gto.PB(b); gcap.PB(c); gcost.PB(+d); ++m;\n\t\tgnxt.PB(ghead[b]); ghead[b]=m; gto.PB(a); gcap.PB(0); gcost.PB(-d); ++m;\n\t\t//printf(\"adding edge %d-%d with cap %d and cost %lld\\n\",a,b,c,d);\n\t}\n\tpair<int,ll> solve(int s,int t) {\n\t\t//REP(i,n) { printf(\"%d:\",i); for(int x=ghead[i];x!=-1;x=gnxt[x]) printf(\" %d\",gto[x]); puts(\"\"); }\n\n\t\tREP(i,n) d[i]=LLONG_MAX,bck[i]=-1; d[s]=0,bck[s]=-2;\n\t\twhile(true) {\n\t\t\tbool change=false;\n\t\t\tREP(at,n) if(d[at]!=LLONG_MAX) for(int x=ghead[at];x!=-1;x=gnxt[x]) if(gcap[x]>0) {\n\t\t\t\tint to=gto[x]; if(d[at]+gcost[x]>=d[to]) continue;\n\t\t\t\td[to]=d[at]+gcost[x]; bck[to]=x^1; change=true;\n\t\t\t}\n\t\t\tif(!change) break;\n\t\t}\n\t\tif(d[t]==LLONG_MAX) return MP(0,0);\n\t\tREP(i,n) pot[i]=d[i];\n\n\n\t\tpair<int,ll> ret=MP(0,0LL);\n\t\twhile(true) {\n\t\t\tREP(i,n) d[i]=LLONG_MAX,bck[i]=-1; d[s]=0,bck[s]=-2;\n\t\t\tpriority_queue<pair<ll,int> > q; q.push(MP(-d[s],s));\n\t\t\twhile(!q.empty()) {\n\t\t\t\tll cost=-q.top().first; int at=q.top().second; q.pop();\n\t\t\t\tif(cost>d[at]) continue;\n\t\t\t\tfor(int x=ghead[at];x!=-1;x=gnxt[x]) if(gcap[x]>0) {\n\t\t\t\t\tint to=gto[x]; ll rcost=gcost[x]-pot[at]+pot[to]; if(d[at]+rcost>=d[to]) continue;\n\t\t\t\t\td[to]=d[at]+rcost; bck[to]=x^1; q.push(MP(-d[to],to));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(d[t]==LLONG_MAX) break;\n\t\t\t//printf(\"%d\\n\",d[t]-pot[t]);\n\t\t\t++ret.first,ret.second+=d[t]-pot[t];\n\t\t\tREP(i,n) if(d[i]!=LLONG_MAX) pot[i]-=d[i];\n\n\t\t\tfor(int at=t;at!=s;at=gto[bck[at]]) {\n\t\t\t\t//printf(\"%d \",at);\n\t\t\t\t++gcap[bck[at]]; --gcap[bck[at]^1];\n\t\t\t}\n\t\t\t//printf(\"%d \",s);\n\t\t\t//puts(\"\");\n\t\t}\n\t\treturn ret;\n\t}\n} MCMF;\nMCMF g;\n\n\nconst int MAXP=80;\nconst int MAXCOND=320;\nstruct P { int x,y; ll val; };\nstruct Cond { int pos,lim; };\nbool operator<(const Cond &a,const Cond &b) { if(a.pos!=b.pos) return a.pos<b.pos; return a.lim>b.lim; }\n\nint np;\nP p[MAXP];\nint ncond;\nvector<Cond> lcond,rcond,ucond,dcond;\nCond cond[MAXCOND];\n\nvector<int> lx,hx,ly,hy;\n\nvector<int> calcbound(int want,vector<Cond> cond,bool inv) {\n\tif(inv) REPSZ(i,cond) cond[i].pos=-cond[i].pos;\n\tsort(cond.begin(),cond.end());\n\tint nsz=0; REPSZ(i,cond) { while(nsz>0&&cond[nsz-1].lim>=cond[i].lim) --nsz; cond[nsz++]=cond[i]; } cond.resize(nsz);\n\tvector<int> ret(want); int at=0; REPSZ(i,ret) { while(at<SZ(cond)&&cond[at].lim<=i) ++at; ret[i]=at==0?INT_MIN:cond[at-1].pos+1; }\n\tif(inv) { reverse(ret.begin(),ret.end()); REPSZ(i,ret) if(ret[i]==INT_MIN) ret[i]=INT_MAX; else ret[i]=-ret[i]; }\n\treturn ret;\n}\n\nll calc(int want) {\n\tint sid,tid; vector<int> xcondid(want),ycondid(want),lpid(np),rpid(np);\n\tint nid=0; sid=nid++; tid=nid++; REP(i,want) xcondid[i]=nid++; REP(i,want) ycondid[i]=nid++; REP(i,np) lpid[i]=nid++,rpid[i]=nid++;\n\tg.init(nid);\n\tREP(i,want) g.addedge(sid,xcondid[i],1,0);\n\tREP(i,want) REP(j,np) if(lx[i]<=p[j].x&&p[j].x<=hx[i]) g.addedge(xcondid[i],lpid[j],1,0);\n\tREP(j,np) g.addedge(lpid[j],rpid[j],1,-p[j].val);\n\tREP(j,np) REP(i,want) if(ly[i]<=p[j].y&&p[j].y<=hy[i]) g.addedge(rpid[j],ycondid[i],1,0);\n\tREP(i,want) g.addedge(ycondid[i],tid,1,0);\n\treturn -g.solve(sid,tid).second;\n}\n\nll solve() {\n\tll ret=0;\n\tFORE(want,1,np) {\n\t\tlx=calcbound(want,lcond,false);\n\t\thx=calcbound(want,rcond,true);\n\t\tly=calcbound(want,dcond,false);\n\t\thy=calcbound(want,ucond,true);\n\t\tbool ok=true; REP(i,want) if(lx[i]>hx[i]||ly[i]>hy[i]) ok=false; if(!ok) continue;\n\t\t//printf(\"want=%d\\n\",want);\n\t\t//printf(\"lx:\"); REPSZ(i,lx) printf(\" %d\",lx[i]); puts(\"\");\n\t\t//printf(\"hx:\"); REPSZ(i,hx) printf(\" %d\",hx[i]); puts(\"\");\n\t\t//printf(\"ly:\"); REPSZ(i,ly) printf(\" %d\",ly[i]); puts(\"\");\n\t\t//printf(\"hy:\"); REPSZ(i,hy) printf(\" %d\",hy[i]); puts(\"\");\n\t\tll cur=calc(want);\n\t\t//printf(\"->%lld\\n\",cur);\n\t\tret=max(ret,cur);\n\t}\n\treturn ret;\n}\n\nvoid run() {\n\tscanf(\"%d\",&np);\n\tREP(i,np) scanf(\"%d%d%lld\",&p[i].x,&p[i].y,&p[i].val);\n\tscanf(\"%d\",&ncond);\n\tlcond.clear(),rcond.clear(),ucond.clear(),dcond.clear(); REP(i,ncond) { char kind; scanf(\" %c\",&kind); Cond cond; scanf(\" %d%d\",&cond.pos,&cond.lim); if(kind=='L') lcond.PB(cond); else if(kind=='R') rcond.PB(cond); else if(kind=='D') dcond.PB(cond); else if(kind=='U') ucond.PB(cond); else assert(false); }\n\tprintf(\"%lld\\n\",solve());\n}\n\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <list>\n#include <time.h>\n#include <math.h>\n#include <random>\n#include <deque>\n#include <queue>\n#include <cassert>\n#include <unordered_map>\n#include <unordered_set>\n#include <iomanip>\n#include <bitset>\n#include <sstream>\n#include <chrono>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef long double dbl;\nconst int INF = 1.01e9;\n \nconst long double EPS = 1e-18;\nbool eq(long double x, long double y) {\n    return fabs(x - y) < EPS;\n}\nbool ls(long double x, long double y) {\n    return x < y && !eq(x, y);\n}\n \nvector<long double> simplex(vector<vector<long double> > a) {\n    int n = a.size() - 1;\n    int m = a[0].size() - 1;\n    vector<int> left(n + 1), up(m + 1);\n    iota(up.begin(), up.end(), 0);\n    iota(left.begin(), left.end(), m);\n    auto pivot = [&](int x, int y) {\n        swap(left[x], up[y]);\n        long double k = a[x][y];\n        a[x][y] = 1;\n        vector<int> vct;\n        for (int j = 0; j <= m; j++) {\n            a[x][j] /= k;\n            if (!eq(a[x][j], 0)) vct.push_back(j);\n        }\n        for (int i = 0; i <= n; i++) {\n            if (eq(a[i][y], 0) || i == x) continue;\n            k = a[i][y];\n            a[i][y] = 0;\n            for (int j : vct) a[i][j] -= k * a[x][j];\n        }\n    };\n    while (1) {\n        int x = -1;\n        for (int i = 1; i <= n; i++) if (ls(a[i][0], 0) && (x == -1 || a[i][0] < a[x][0])) x = i;\n        if (x == -1) break;\n        int y = -1;\n        for (int j = 1; j <= m; j++) if (ls(a[x][j], 0) && (y == -1 || a[x][j] < a[x][y])) y = j;\n        if (y == -1) assert(0); // infeasible\n        pivot(x, y);\n    }\n    while (1) {\n        int y = -1;\n        for (int j = 1; j <= m; j++) if (ls(0, a[0][j]) && (y == -1 || a[0][j] > a[0][y])) y = j;\n        if (y == -1) break;\n        int x = -1;\n        for (int i = 1; i <= n; i++) if (ls(0, a[i][y]) && (x == -1 || a[i][0] / a[i][y] < a[x][0] / a[x][y])) x = i;\n        if (x == -1) assert(0); // unbounded\n        pivot(x, y);\n    }\n    vector<long double> ans(m + 1);\n    for (int i = 1; i <= n; i++) if (left[i] <= m) ans[left[i]] = a[i][0];\n    ans[0] = -a[0][0];\n    return ans;\n}\n\n#ifdef ONPC\n  mt19937 rnd(228);\n#else\n  mt19937 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\n#endif\n\nint main()\n{\n#ifdef ONPC\n  freopen(\"a.in\", \"r\", stdin);\n#endif\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector <int> x(n), y(n);\n  vector <ll> ok;\n  vector <long double> v;\n  vector <pair <ll, int> > e;\n  for (int i = 0; i < n; i++)\n  {\n    cin >> x[i] >> y[i];\n    ll x;\n    cin >> x;\n    ok.push_back(x);\n    v.push_back(x);\n    e.push_back({x, i});\n  }\n  v.insert(v.begin(), 0);\n  int m;\n  cin >> m;\n  vector <vector <long double> > mat;\n  mat.push_back(v);\n  for (int i = 0; i < n; i++)\n  {\n    vector <long double> kek(n + 1);\n    kek[0] = kek[i + 1] = 1;\n    mat.push_back(kek);\n  }\n  vector <vector <int> > simp;\n  for (int i = 0; i < m; i++)\n  {\n    char c;\n    cin >> c;\n    int a;\n    int b;\n    cin >> a >> b;\n    vector <long double> arr = {(long double) b};\n    vector <int> kek = {b};\n    for (int j = 0; j < n; j++)\n    {\n      int grab = 0;\n      if (c == 'L' && x[j] <= a) grab = 1;\n      if (c == 'R' && x[j] >= a) grab = 1;\n      if (c == 'D' && y[j] <= a) grab = 1;\n      if (c == 'U' && y[j] >= a) grab = 1;\n      arr.push_back(grab);\n      kek.push_back(grab);\n    }\n    mat.push_back(arr);\n    simp.push_back(kek);\n  }\n  auto good = [&] (vector <int> grab)\n  {\n    for (auto c : simp)\n    {\n      int sum = 0;\n      for (int i = 1; i <= n; i++) sum += grab[i - 1] * c[i];\n      if (sum > c[0])\n      {\n        return false;\n      }\n    }\n    return true;\n  };\n  auto f = [&] (vector <int> grab)\n  {\n    ll sum = 0;\n    for (int i = 0; i < n; i++)\n    {\n      if (grab[i]) sum += ok[i];\n    }\n    return sum;\n  };\n  vector <int> grab;\n  for (int i = 0; i < n; i++) grab.push_back(0);\n  cout.precision(20);\n  auto solve = [&] ()\n  {\n    auto ret = simplex(mat);\n    sort(e.begin(), e.end());\n    vector <int> me(n);\n    int x = -1;\n    for (int i = 1; i <= n; i++)\n    {\n      if (grab[i - 1]) continue;\n      if (x == -1 || ret[i] * ok[i - 1] > ret[x] * ok[x - 1])\n      {\n        x = i;\n      }\n    }\n    if (x == -1 || ret[x] < EPS) return 0ll;\n    x--;\n    me[x] = true;\n    grab[x] = true;\n    if (!good(grab)) grab[x] = false, me[x] = false;\n    int kekos = 0;\n    for (auto &c : mat)\n    {\n      kekos++;\n      if (kekos > n + 1)\n      for (int i = 1; i <= n; i++)\n      {\n        if (me[i - 1] && c[i] > EPS) c[i]--, c[0]--;\n      }\n    }\n    for (int i = 1; i <= n; i++)\n    {\n      if (me[i - 1])\n      {\n        mat[i][0] = 0;\n      }\n    }\n    return ok[x];\n  };\n  ll ans = 0;\n  while (ll t = solve())\n  {\n    ans += t;\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<set>\n//#define ls (rt<<1)\n//#define rs (rt<<1|1)\n#define vi vector<int>\n#define pb push_back\n#define mk make_pair\n#define pii pair<ll,ll>\n#define rep(i,a,b) for(int i=(a),i##end=(b);i<=i##end;i++)\n#define fi first\n#define se second\n#define int long long\ntypedef long long ll;\nusing namespace std;\nconst int maxn=720;\nconst int inf=1e18+100;\nint xl[maxn],xr[maxn],yl[maxn],yr[maxn],s=415,t=416;\nint head[maxn],cnt=1;\nstruct gg{\n    int u,v,w;ll cost;int next;\n    void insert(int U,int V,int W,ll Cost,int Next){\n        u=U,v=V,w=W,cost=Cost,next=Next;\n    }\n}side[(maxn*82)*2*4];\nstruct Point{\n    int x,y;\n    ll cost=0;\n}point[maxn];\nstruct Lim{\n    int a,b;char c;\n}lim[maxn];\nvoid ins(int u,int v,int w,ll cost){\n    side[++cnt].insert(u,v,w,cost,head[u]);head[u]=cnt;\n    side[++cnt].insert(v,u,0,-cost,head[v]);head[v]=cnt;\n}\nint n,m;\nvoid init(int k){\n   rep(i,1,k)xl[i]=yl[i]=-inf,xr[i]=yr[i]=inf;\n   rep(i,1,m){\n       if(lim[i].c=='L')rep(j,lim[i].b+1,k)xl[j]=max(xl[j],lim[i].a+1);\n       else if(lim[i].c=='R')for(int j=k-lim[i].b;j>0;j--)xr[j]=min(xr[j],lim[i].a-1);\n       else if(lim[i].c=='D')rep(j,lim[i].b+1,k)yl[j]=max(yl[j],lim[i].a+1);\n       else if(lim[i].c=='U')for(int j=k-lim[i].b;j>0;j--)yr[j]=min(yr[j],lim[i].a-1);\n   }\n   memset(head,0,sizeof(head));cnt=1;\n   rep(i,1,k)ins(s,2*n+i,1,0);\n   rep(i,1,k)ins(2*n+k+i,t,1,0);\n   rep(i,1,n){\n        ins(i,n+i,1,point[i].cost);\n        rep(j,1,k){\n            if(xl[j]<=point[i].x&&point[i].x<=xr[j])ins(2*n+j,i,1,0);\n            if(yl[j]<=point[i].y&&point[i].y<=yr[j])ins(n+i,2*n+k+j,1,0);\n        }\n   }\n}\nint rk[maxn],q[maxn];\nll dis[maxn],lenth;\nbool vis[maxn];\nbool spfa(){\n    rep(i,1,maxn-1)dis[i]=-inf;\n    memset(vis,0,sizeof(vis));\n    int hd=1,tl=1;q[hd]=s;vis[s]=1;dis[s]=0;\n    while(hd<=tl){\n        int u=q[hd++];vis[u]=0;//cout<<u<<' '<<endl;\n        for(int i=head[u];i;i=side[i].next){\n            int v=side[i].v;if(!side[i].w)continue;\n            if(dis[u]+side[i].cost>dis[v]){\n                dis[v]=dis[u]+side[i].cost;\n                if(!vis[v])q[++tl]=v;\n                vis[v]=1;\n            }\n        }\n    }\n    if(dis[t]!=-inf)return 1;\n    return 0;\n}\nint dfs(int u,int flow){\n    if(u==t)return flow;\n    vis[u]=1;int tot=0;\n    for(int i=head[u];i;i=side[i].next){\n        int v=side[i].v;if(vis[v]||!side[i].w||dis[v]!=dis[u]+side[i].cost)continue;\n        int sent=dfs(v,min(flow,side[i].w));\n        lenth+=1ll*side[i].cost*sent,side[i].w-=sent,side[i^1].w+=sent,tot+=sent;flow-=sent;\n    }\n   // vis[u]=0;\n    return tot;\n}\npii dinic(){\n    int mxflow=0;lenth=0;\n    while(spfa()){\n        int x;\n        while((x=dfs(s,inf)))mxflow+=x;\n    }\n    return mk(mxflow,lenth);\n}\nchar tmp[3];\nsigned main(){\n    scanf(\"%lld\",&n);\n    rep(i,1,n)scanf(\"%lld%lld%lld\",&point[i].x,&point[i].y,&point[i].cost);\n    scanf(\"%lld\",&m);\n    rep(i,1,m){\n        scanf(\"%s%lld%lld\",tmp+1,&lim[i].a,&lim[i].b);lim[i].c=tmp[1];\n    }\n    ll out=0;\n    rep(k,1,n){\n        init(k);\n        pii ans=dinic();out=max(out,ans.se);//cout<<ans.se<<endl;\n    }\n    cout<<out;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint N, M, x[100], y[100], x_code[100], y_code[100], in_code[100], out_code[100], lX[100], lY[100], rX[100], rY[100], lim[400], coord[400];\nlong long v[100];\nchar type[400];\nconst long long INF = 1LL << 60;\n\nclass maxFlowMinCut\n{\npublic:\n    int S, D, N, t[400], c[400][400], f[400][400];\n    bool inQ[400];\n    long long d[400], bani[400][400];\n    vector < int > v[400];\n\n    void addEdge (int x, int y, int cap, long long ban)\n    {\n        c[x][y] = cap, c[y][x] = 0;\n        bani[x][y] = ban, bani[y][x] = -ban;\n        v[x].push_back (y);\n        v[y].push_back (x);\n    }\n\n    bool bellman ()\n    {\n        queue < int > cc;\n        for (int i=1; i<=N; i++)\n            t[i] = -1, d[i] = INF, inQ[i] = 0;\n        t[S] = 0, d[S] = 0, inQ[S] = 1;\n        cc.push (S);\n        while (!cc.empty ())\n        {\n            int nod = cc.front ();\n            cc.pop (), inQ[nod] = 0;\n            for (auto it : v[nod])\n                if (c[nod][it] > f[nod][it] && d[nod] + bani[nod][it] < d[it])\n                {\n                    d[it] = d[nod] + bani[nod][it];\n                    t[it] = nod;\n                    if (!inQ[it])\n                        inQ[it] = 1,\n                        cc.push (it);\n                }\n        }\n        return (d[D] < INF);\n    }\n\n    pair < int, long long > minCostMaxFlow ()\n    {\n        int cap = 0;\n        long long ban = 0;\n        while (bellman ())\n        {\n            int minC = 1e9;\n            for (int i=D; i != S; i = t[i])\n                minC = min (minC, c[t[i]][i] - f[t[i]][i]);\n            for (int i=D; i != S; i = t[i])\n                f[t[i]][i] += minC,\n                f[i][t[i]] -= minC;\n            cap += minC, ban += 1LL * minC * d[D];\n        }\n        return {cap, ban};\n    }\n\n    void clear ()\n    {\n        for (int i=1; i<=N; i++)\n        {\n            for (auto j : v[i])\n                c[i][j] = c[j][i] = 0,\n                f[i][j] = f[j][i] = 0,\n                bani[i][j] = bani[j][i] = 0LL;\n            v[i].clear ();\n        }\n        S = D = N = 0;\n    }\n}net;\n\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nscanf (\"%d\", &N);\nfor (int i=1; i<=N; i++)\n    scanf (\"%d %d %lld\", &x[i], &y[i], &v[i]);\nscanf (\"%d\\n\", &M);\nfor (int i=1; i<=M; i++)\n    scanf (\"%c %d %d\\n\", &type[i], &coord[i], &lim[i]);\nlong long best = 0;\nfor (int K=1; K<=N; K++)\n{\n    net.clear (), net.S = 1, net.D = net.N = 2;\n    for (int i=1; i<=K; i++)\n        x_code[i] = ++net.N,\n        net.addEdge (net.S, x_code[i], 1, 0);\n    for (int i=1; i<=N; i++)\n        in_code[i] = ++net.N,\n        out_code[i] = ++net.N,\n        net.addEdge (in_code[i], out_code[i], 1, -v[i]);\n    for (int i=1; i<=K; i++)\n        y_code[i] = ++net.N,\n        net.addEdge (y_code[i], net.D, 1, 0);\n    for (int i=1; i<=K; i++)\n        lX[i] = lY[i] = 0,\n        rX[i] = rY[i] = 200;\n    for (int i=1; i<=M; i++)\n    {\n        if (type[i] == 'L' && lim[i] < K) lX[lim[i] + 1] = max (lX[lim[i] + 1], coord[i] + 1);\n        if (type[i] == 'R' && lim[i] < K) rX[K - lim[i]] = min (rX[K - lim[i]], coord[i] - 1);\n        if (type[i] == 'D' && lim[i] < K) lY[lim[i] + 1] = max (lY[lim[i] + 1], coord[i] + 1);\n        if (type[i] == 'U' && lim[i] < K) rY[K - lim[i]] = min (rY[K - lim[i]], coord[i] - 1);\n    }\n    for (int i=2; i<=K; i++)\n        lX[i] = max (lX[i], lX[i - 1]),\n        lY[i] = max (lY[i], lY[i - 1]);\n    for (int i=K - 1; i>=1; i--)\n        rX[i] = min (rX[i], rX[i + 1]),\n        rY[i] = min (rY[i], rY[i + 1]);\n    for (int i=1; i<=K; i++)\n        for (int j=1; j<=N; j++)\n        {\n            if (lX[i] <= x[j] && x[j] <= rX[i])\n                net.addEdge (x_code[i], in_code[j], 1, 0);\n            if (lY[i] <= y[j] && y[j] <= rY[i])\n                net.addEdge (out_code[j], y_code[i], 1, 0);\n        }\n/*    for (int i=1; i<=N; i++)\n        if (i == 1 || (5 <= i && i <= 7))\n            printf (\"%d %d\\n\", x[i], y[i]);\n    for (int i=1; i<=K; i++)\n        printf (\"[%d %d] [%d %d]\\n\", lX[i], rX[i], lY[i], rY[i]);*/\n    auto ans = net.minCostMaxFlow ();\n    //printf (\"%d -> %lld\\n\", ans.first, -ans.second);\n    if (ans.first == K)\n    {\n        if (-ans.second > best)\n            best = -ans.second;\n    }\n}\nprintf (\"%lld\\n\", best);\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=505,M=50005,R=100;\nconst ll inf=0x3f3f3f3f3f3f3f3fll;\nint read(){\n\tint f=1,g=0;\n\tchar ch=getchar();\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-') f=-1;\n\tfor (;isdigit(ch);ch=getchar()) g=g*10+ch-'0';\n\treturn f*g;\n}\nvoid chkmax(int &x,int y){if (x<y) x=y;}\nvoid chkmin(int &x,int y){if (x>y) x=y;}\nint n,m;\nstruct jew{int x,y;ll w;}a[N];\nstruct node{char typ;int x,r;}b[N];\nll cost,ans;\nint S,T,cnt,fir[N],fr[N],siz;\nstruct edge{int u,v;ll w;int fl,nex;}e[M];\nvoid add(int u,int v,ll w,int fl){\n\te[++siz]=(edge){u,v,w,fl,fir[u]};fir[u]=siz;\n\te[++siz]=(edge){v,u,-w,0,fir[v]};fir[v]=siz;\n}\nll dist[N];int que[N*50];bool inq[N];\nvoid dec(int x,int fl){e[x].fl-=fl;e[x^1].fl+=fl;}\nbool spfa(){\n\tmemset(dist,0xc0,8*(cnt+1));\n\tmemset(inq,0,cnt+1);\n\tint l=1,r=1;que[l]=S;dist[S]=0;inq[S]=1;\n\twhile (l<=r){\n\t\tint x=que[l];\n\t\tfor (int i=fir[x];i;i=e[i].nex)\n\t\tif ((e[i].fl)&&(dist[e[i].v]<dist[x]+e[i].w)){\n\t\t\tif (!inq[e[i].v]) {que[++r]=e[i].v;inq[e[i].v]=1;}\n\t\t\tdist[e[i].v]=dist[x]+e[i].w;fr[e[i].v]=i;\n\t\t}\n\t\tinq[x]=0;l++;\n\t}\n\treturn dist[T]>(ll)0xc0c0c0c0c0c0c0c0ll;\n}\nint update(){\n\tint t=0x3f3f3f3f;\n\tfor (int i=fr[T];i;i=fr[e[i].u]) t=min(t,e[i].fl);\n\tcost+=t*dist[T];\n\tfor (int i=fr[T];i;i=fr[e[i].u]) dec(i,t);\n\treturn t;\n}\nint dinic(){\n\tint flow=0;\n\twhile (spfa()) flow+=update();\n\treturn flow;\n}\nint ml[N],mr[N],mu[N],md[N];\nvoid calc(int L){\n\tmemset(fir,0,sizeof(fir));siz=1;\n\tS=0;T=cnt=L*2+R*2+1;\n\tfor (int i=1;i<=n;i++) add(a[i].x,a[i].y+R,a[i].w,1);\n\tfor (int i=1;i<=L;i++) {ml[i]=mu[i]=1,mr[i]=md[i]=R;add(S,R*2+i,0,1);add(R*2+L+i,T,0,1);}\n\tfor (int i=1;i<=m;i++)\n\tif (b[i].r>=L) continue;\n\telse if (b[i].typ=='L') chkmax(ml[b[i].r+1],b[i].x+1);\n\telse if (b[i].typ=='R') chkmin(mr[L-b[i].r],b[i].x-1);\n\telse if (b[i].typ=='D') chkmax(mu[b[i].r+1],b[i].x+1);\n\telse if (b[i].typ=='U') chkmin(md[L-b[i].r],b[i].x-1);\n\tfor (int i=2;i<=L;i++) chkmax(ml[i],ml[i-1]),chkmax(mu[i],mu[i-1]);\n\tfor (int i=L-1;i;i--)  chkmin(md[i],md[i+1]),chkmin(md[i],md[i+1]);\n\tfor (int i=1;i<=L;i++){\n\t\tfor (int j=ml[i];j<=mr[i];j++) add(R*2+i,j,0,1);\n\t\tfor (int j=mu[i];j<=md[i];j++) add(j+R,R*2+L+i,0,1);\n\t}\n\tcost=0;\n\tif (dinic()==L) ans=max(ans,cost);\n//\tfor (int i=1;i<=n;i++) if (!e[i*2].fl) printf(\"%d \",i);\n//\tprintf(\"\\n\");\n}\nint main(){\n\tn=read();\n\tfor (int i=1;i<=n;i++) scanf(\" %d %d %lld\",&a[i].x,&a[i].y,&a[i].w);\n\tm=read();\n\tfor (int i=1;i<=m;i++) scanf(\" %c %d %d\",&b[i].typ,&b[i].x,&b[i].r);\n\tfor (int i=1;i<=n;i++) calc(i);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef HOME\n#define db(x) cerr << #x << \" = \" << x << endl\n#define db3(x, y, z) cerr << \"(\" << #x << \", \" << #y << \", \" << #z << \") = (\" << x << \", \" << y << \", \" << z << \")\" << endl\n#define db2(x, y) cerr << \"(\" << #x << \", \" << #y << \") = (\" << x << \", \" << y << \")\" << endl\n#define dbv(a) cerr << #a << \" = \"; for (auto xxx: a) cerr << xxx  << \" \"; cerr << endl\n#else\n#define db(x) ;\n#define db3(x, y, z) ;\n#define db2(x, y) ;\n#define dbv(a) ;\n#endif\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double dbl;\n\n\nconst int INF = 1.01e9;\nconst int MOD = (int)1e9 + 7;\n\nstruct Item {\n    int x, y;\n    ll val;\n};\n\nstruct Cond {\n    char type;\n    int a, b;\n\n    bool cover(Item it) {\n        if (type == 'L') {\n            return it.x <= a;\n        }\n        if (type == 'R') {\n            return it.x >= a;\n        }\n        if (type == 'D') {\n            return it.y <= a;\n        }\n        if (type == 'U') {\n            return it.y >= a;\n        }\n        assert(0);\n    }\n};\n\nll slow(vector<Item> a, vector<Cond> b) {\n    int n = a.size(), m = b.size();\n    ll ans = 0;\n    for (int mask = 0; mask < (1 << n); mask++) {\n        vector<int> cnt(m);\n        ll sum = 0;\n        for (int i = 0; i < n; i++) {\n            if (!(mask & (1 << i))) continue;\n            sum += a[i].val;\n            for (int j = 0; j < m; j++) {\n                if (b[j].cover(a[i])) {\n                    cnt[j]++;\n                }\n            }\n        }\n        bool bad = 0;\n        for (int i = 0; i < m; i++) {\n            if (cnt[i] > b[i].b) {\n                bad = 1;\n            }\n        }\n        if (bad) continue;\n        ans = max(ans, sum);\n    }\n    return ans;\n}\n\n\nbool eq(dbl a, dbl b) {\n    return fabs(a - b) < 1e-9;\n}\n\nbool ls(dbl a, dbl b) {\n    return !eq(a, b) && a < b;\n}\n\nvector<dbl> simplex(vector<vector<dbl> > a) {\n    int n = a.size() - 1;\n    int m = a[0].size() - 1;\n    vector<int> left(n + 1), up(m + 1);\n    iota(up.begin(), up.end(), 0);\n    iota(left.begin(), left.end(), m);\n    while (1) {\n        auto pivot = [&](int x, int y) {\n            swap(left[x], up[y]);\n            dbl k = a[x][y];\n            a[x][y] = 1;\n            vector<int> vct;\n            for (int j = 0; j <= m; j++) {\n                a[x][j] /= k;\n                if (!eq(a[x][j], 0)) vct.push_back(j);\n            }\n            for (int i = 0; i <= n; i++) {\n                if (eq(a[i][y], 0) || i == x) continue;\n                k = a[i][y];\n                a[i][y] = 0;\n                for (int j : vct) a[i][j] -= k * a[x][j];\n            }\n        };\n        while (1) {\n            int x = -1;\n            for (int i = 1; i <= n; i++) if (ls(a[i][0], 0) && (x == -1 || a[i][0] < a[x][0])) x = i;\n            if (x == -1) break;\n            int y = -1;\n            for (int j = 1; j <= m; j++) if (ls(a[x][j], 0) && (y == -1 || a[x][j] < a[x][y])) y = j;\n            if (y == -1) return vector<dbl>(m, 0);\n            pivot(x, y);\n        }\n        while (1) {\n            int y = -1;\n            for (int j = 1; j <= m; j++) if (ls(0, a[0][j]) && (y == -1 || a[0][j] > a[0][y])) y = j;\n            if (y == -1) break;\n            int x = -1;\n            for (int i = 1; i <= n; i++)\n                if (ls(0, a[i][y]) && (x == -1 || a[i][0] / a[i][y] < a[x][0] / a[x][y]))\n                    x = i;\n            if (x == -1) assert(0); // unbounded\n            pivot(x, y);\n        }\n\n        vector<int> v;\n        vector<dbl> ans(m + 1);\n        for (int i = 1; i <= n; i++) if (left[i] <= m) ans[left[i]] = a[i][0];\n        ans[0] = -a[0][0];\n        for (int i = 1; i <= m; i++) {\n            if (!eq(ans[i], floor(ans[i])) && !eq(ans[i], floor(ans[i]) + 1)) {\n                v.push_back(i);\n            }\n        }\n        if (v.empty()) {\n            return ans;\n        }\n        for (int i = 0; i <= n; i++) {\n            for (int j = 0; j < (int)v.size(); j++) {\n                a[i].push_back(0);\n            }\n        }\n        for (int i = 0; i < (int)v.size(); i++) {\n            vector<dbl> cur(a[0].size());\n            cur[m + 1 + i] = 1;\n            for (int j = 0; j <= m; j++) {\n                cur[j] = floor(a[v[i]][j]) - a[v[i]][j];\n            }\n            a.push_back(cur);\n        }\n        m += v.size();\n        n += v.size();\n        up.resize(up.size() + v.size());\n        left.resize(left.size() + v.size());\n    }\n}\n// j=1..m: x[j]>=0\n// i=1..n: sum(j=1..m) A[i][j]*x[j] <= A[i][0]\n// max sum(j=1..m) A[0][j]*x[j]\n// res[0] is answer\n// res[1..m] is certificate\n\nll fast(vector<Item> a, vector<Cond> b) {\n    int n = a.size(), m = b.size();\n    vector<vector<dbl>> c(m + 1, vector<dbl>(n + 1));\n    for (int i = 0; i < n; i++) {\n        c[0][1 + i] = a[i].val;\n    }\n    for (int i = 0; i < m; i++) {\n        c[1 + i][0] = b[i].b;\n        for (int j = 0; j < n; j++) {\n            if (b[i].cover(a[j])) {\n                c[1 + i][1 + j] = 1;\n            }\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        vector<dbl> cur(n + 1);\n        cur[0] = 1;\n        cur[1 + i] = 1;\n        c.push_back(cur);\n    }\n    ll res = 0;\n    for (int cnt = 1; cnt <= n; cnt++) {\n        auto cc = c;\n        vector<dbl> cur(n + 1, 1);\n        cur[0] = cnt;\n        cc.push_back(cur);\n        for (auto &x : cur) x *= -1;\n        cc.push_back(cur);\n        res = max(res, (ll)round(simplex(cc)[0]));\n    }\n    return res;\n}\n\nvoid stress() {\n    for (int it =0;; it++) {\n        mt19937_64 rnd(it);\n        db(it);\n\n\n        int n = rnd() % 10 + 1;\n        vector<Item> a(n);\n        for (int i =0 ; i < n; i++) {\n            a[i].x = rnd() % 100;\n            a[i].y = rnd() % 100;\n            a[i].val = rnd() % (ll)1e15;\n        }\n        int m = rnd() % 10 + 1;\n        vector<Cond> b(m);\n        for (int i = 0; i < m; i++) {\n            b[i].a = rnd() % 100;\n            b[i].b = rnd() % (n + 1);\n            b[i].type = \"ULDR\"[rnd() % 4];\n        }\n\n        auto ans1 = fast(a, b);\n        auto ans2 = slow(a, b);\n        if (ans1 != ans2) {\n            cout << ans1 << \" instead of \" << ans2 << endl;\n            exit(0);\n        }\n    }\n}\n\nint main() {\n#ifdef HOME\n    assert(freopen(\"in\", \"r\", stdin));\n    stress();\n#endif\n\n    int n;\n    while (scanf(\"%d\", &n) == 1) {\n        vector<Item> a(n);\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d%d%lld\", &a[i].x, &a[i].y, &a[i].val);\n        }\n        int m;\n        scanf(\"%d\", &m);\n        vector<Cond> b(m);\n        for (int i = 0; i < m; i++) {\n            scanf(\" %c%d%d\", &b[i].type, &b[i].a, &b[i].b);\n        }\n\n//        printf(\"%lld\\n\", slow(a, b));\n        printf(\"%lld\\n\", fast(a, b));\n    }\n\n#ifdef HOME\n    cerr << \"time: \" << clock() * 1.0 / CLOCKS_PER_SEC << endl;\n#endif\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <queue>\nusing namespace std;\nconst int Q=1000,P=1<<18;\n#define ll long long\nint las[Q],e[P],nn[P],c[Q];\nll v[P];\nqueue<int> q;\nint S,T;\nconst ll inf=100000000000000000LL;\nll dis[Q];\nint inc;\nvoid iNS(int x,int y,int z,ll w)\n{\n    e[++inc]=y;\n    nn[inc]=las[x];\n    las[x]=inc;\n    c[inc]=z;\n    v[inc]=w;\n}\nvoid ins(int x,int y,int z,ll w)\n{\n    iNS(x,y,z,w),iNS(y,x,0,-w);\n}\nint ch[Q];\nint pn[Q],pt[Q];\nint Spfa()\n{\n    for(int i=1;i<=T;i++)\n        dis[i]=-inf;\n    dis[S]=0;\n    q.push(S);\n    while(q.size()){\n        int x=q.front();q.pop();\n        ch[x]=0;\n        for(int t=las[x];t;t=nn[t]){\n            int y=e[t];\n            if(c[t]&&dis[x]+v[t]>dis[y]){\n                dis[y]=dis[x]+v[t];\n                pn[y]=x,pt[y]=t;\n                if(!ch[y])ch[y]=1,q.push(y);\n            }\n        }\n    }\n    return dis[T]>-inf;\n}\nll tmp,als=0;\nvoid Upd()\n{\n    tmp+=dis[T];\n    for(int now=T;now!=S;now=pn[now]){\n        int nt=pt[now];\n        --c[nt],++c[nt^1];\n    }\n}\nint n,m;\nint X[Q],Y[Q];\nint A[Q],B[Q];\nchar ty[Q][5];\nll V[Q];\nint L[Q],R[Q];\nint U[Q],D[Q];\ninline void Gmax(int &a,int b)\n{a<b?a=b:1;}\ninline void Gmin(int &a,int b)\n{a>b?a=b:1;}\nvoid Deal(int Num)\n{\n    S=(Num<<1)+(n<<1)+1,T=S+1;\n    for(int i=1;i<=T;i++)\n        las[i]=0;\n    inc=1;\n    for(int i=1;i<=Num;i++)L[i]=D[i]=-998244353,R[i]=U[i]=998244353;\n    for(int i=1;i<=m;i++){\n        if(Num<=B[i])continue;\n        if(ty[i][0]=='L')Gmax(L[B[i]+1],A[i]+1);\n        if(ty[i][0]=='D')Gmax(D[B[i]+1],A[i]+1);\n        if(ty[i][0]=='R')Gmin(R[Num-B[i]],A[i]-1);\n        if(ty[i][0]=='U')Gmin(U[Num-B[i]],A[i]-1);\n    }\n    for(int i=2;i<=Num;i++)\n        Gmax(L[i],L[i-1]),Gmax(D[i],D[i-1]);\n    for(int i=Num-1;i;--i)\n        Gmin(R[i],R[i+1]),Gmin(U[i],U[i+1]);\n    int ini=(Num<<1);\n    for(int i=1;i<=Num;i++){\n        ins(S,i,1,0),ins(i+Num,T,1,0);\n        for(int j=1;j<=n;j++)\n            if(X[j]>=L[i]&&X[j]<=R[i])\n                ins(i,ini+j,1,0);\n        for(int j=1;j<=n;j++)\n            if(Y[j]>=D[i]&&Y[j]<=U[i])\n                ins(ini+n+j,i+Num,1,0);\n    }\n    for(int i=1;i<=n;i++)\n        ins(i+ini,i+ini+n,1,V[i]);\n    tmp=0;\n    int tim=0;\n    while(Spfa())Upd(),++tim;\n    if(tim==Num)als=max(als,tmp);\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)\n        scanf(\"%d%d%lld\",&X[i],&Y[i],&V[i]);\n    scanf(\"%d\",&m);\n    for(int i=1;i<=m;i++)\n        scanf(\"%s%d%d\",ty[i],&A[i],&B[i]);\n    for(int i=1;i<=n;i++)\n        Deal(i);\n    printf(\"%lld\\n\",als);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define REV(i,n) for(ll (i) = (n) - 1;(i) >= 0;--i)\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {REP(WW,n)cerr << v[WW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,WW,HH) {REP(W_,WW){REP(H_,HH)cerr << v[W_][H_] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n#define fastcin() cin.tie(0);ios::sync_with_stdio(false)\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nclass minCostFlow {\n\n\tstruct edge { ll to, cap, cost, rev; };\n\n\tll V;\n\tvector<vector<edge>> G;\n\tvector<ll> dist;\n\tvector<ll> prevv;\n\tvector<ll> preve;\n\npublic:\n\n\tminCostFlow(ll n): G(n), dist(n), prevv(n), preve(n), V(n){\n\t}\n\n\tvoid addEdge(ll from, ll to, ll cap, ll cost) {\n\t\tG[from].push_back((edge){to, cap, cost, (ll)G[to].size()});\n\t\tG[to].push_back((edge){from, 0, -cost, (ll)G[from].size() - 1});\n\t}\n\n\tll solve(ll s, ll t, ll f) {\n\t\tll ret = 0;\n\t\twhile(f > 0) {\n\t\t\tfill(dist.begin(), dist.end(), LLINF);\n\t\t\tdist[s] = 0;\n\t\t\tbool update = true;\n\t\t\twhile(update) {\n\t\t\t\tupdate = false;\n\t\t\t\tfor(ll v = 0;v < V;v++) {\n\t\t\t\t\tif(dist[v] == LLINF)continue;\n\t\t\t\t\tfor(ll i = 0;i < G[v].size();i++) {\n\t\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\t\tif(e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n\t\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dist[t] == LLINF) {\n\t\t\t\treturn LLINF;//流せない\n\t\t\t}\n\n\t\t\tll d = f;\n\t\t\tfor(ll v = t;v != s;v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tret += d * dist[t];\n\t\t\tfor(ll v = t;v != s;v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n};\n\nll check(vector<pair<P, ll>> v, vector<pair<char, P>> t, int k){\n\tll cost = 1000000000000000LL;\n\tint n = v.size();\n\tint m = t.size();\n\t\n\tvector<P> ver(k, MP(0, LLINF));\n\tvector<P> hor(k, MP(0, LLINF));\n\t\n\tREP(i, m){\n\t\tchar c = t[i].FI;\n\t\tP p = t[i].SE;\n\t\tif(c == 'L'){\n\t\t\tif(p.SE >= k)continue;\n\t\t\thor[p.SE].FI = max(hor[p.SE].FI, p.FI + 1);\n\t\t}\n\t\telse if(c == 'R'){\n\t\t\tif(k - p.SE - 1 < 0)continue;\n\t\t\thor[k - p.SE - 1].SE = min(hor[k - p.SE - 1].SE, p.FI - 1);\n\t\t}\n\t\telse if(c == 'D'){\n\t\t\tif(p.SE >= k)continue;\n\t\t\tver[p.SE].FI = max(ver[p.SE].FI, p.FI + 1);\n\t\t}\n\t\telse {\n\t\t\tif(k - p.SE - 1 < 0)continue;\n\t\t\tver[k - p.SE - 1].SE = min(ver[k - p.SE - 1].SE, p.FI - 1);\n\t\t}\n\t}\n\t\n\tREP(i, k - 1){\n\t\tver[i + 1].FI = max(ver[i + 1].FI, ver[i].FI);\n\t\thor[i + 1].FI = max(hor[i + 1].FI, hor[i].FI);\n\t\tver[k - i - 2].SE = min(ver[k - i - 2].SE, ver[k - i - 1].SE); \n\t\thor[k - i - 2].SE = min(hor[k - i - 2].SE, hor[k - i - 1].SE); \n\t}\n\t\n\t//REP(i, k)cout << \"(\" << hor[i].FI << \", \" << hor[i].SE << \") \";cout << endl;\n\t//REP(i, k)cout << \"(\" << ver[i].FI << \", \" << ver[i].SE << \") \";cout << endl;\n\t\n\tminCostFlow mcf(10000);\n\t\n\tll s = 2 * (k + n);\n\tll g = 2 * (k + n) + 1;\n\t\n\tREP(i, k){\n\t\tll idA = 2 * n + i;\n\t\tll idB = 2 * n + k + i;\n\t\tmcf.addEdge(s, idA, 1, 0);\n\t\tmcf.addEdge(idB, g, 1, 0);\n\t}\n\t\n\tREP(i, n){\n\t\tP now = v[i].FI;\n\t\tll val = v[i].SE;\n\t\tll idA = i;\n\t\tll idB = i + n;\n\t\tmcf.addEdge(idA, idB, 1, cost - val);\n\t\tREP(j, m){\n\t\t\tll idC = 2 * n + j;\n\t\t\tll idD = 2 * n + k + j;\n\t\t\tif(now.FI >= hor[j].FI && now.FI <= hor[j].SE){\n\t\t\t\tmcf.addEdge(idC, idA, 1, 0);\n\t\t\t}\n\t\t\tif(now.SE >= ver[j].FI && now.SE <= ver[j].SE){\n\t\t\t\tmcf.addEdge(idB, idD, 1, 0);\n\t\t\t}\n\t\t}\n\t}\n\tll ret = k * cost - mcf.solve(s, g, k);\n\t//cout << \"check \" << k << \" \" << ret << endl;\n\treturn ret;\n}\n\nint main(){\n\t\n\tll n;cin >> n;\n\tvector<pair<P, ll>> v(n);\n\tREP(i, n)cin >> v[i].FI.FI >> v[i].FI.SE >> v[i].SE;\n\tll m;cin >> m;\n\tvector<pair<char, P>> t(m);\n\tREP(i, m)cin >> t[i].FI >> t[i].SE.FI >> t[i].SE.SE;\n\t\n\tll ans = 0;\n\t\n\tfor(ll i = 1;i <= n;i++){\n\t\tans = max(ans, check(v, t, i));\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\nusing namespace std;\ntypedef long long ll;\n#define N 50015\nconst int inf=20040322;\nstruct edge{int to,nxxt,len;ll co;}e[N<<3];\nint n,m,a[N][2],head[N],cnt=2;\nll va[N],cost[N],ans;\nchar ch[3];\nqueue<int>q;\nbool inq[N];\nint b[N][3],lx[N],rx[N],ly[N],ry[N],S,T,flow[N],pre[N],la[N];\ninline void ins(int u,int v,int w,ll c)\n{e[cnt].to=v;e[cnt].len=w;e[cnt].co=c;e[cnt].nxxt=head[u];head[u]=cnt++;}\ninline bool spfa()\n{\n\tfor(int i=1;i<=T;i++)inq[i]=0,flow[i]=inf,cost[i]=-1e18;pre[T]=-1;\n\tq.push(S);cost[S]=0;inq[S]=1;\n\twhile(!q.empty())\n\t{\n\t\tint a1=q.front();q.pop();inq[a1]=0;\n\t\tfor(int i=head[a1];i;i=e[i].nxxt)\n\t\t{\n\t\t\tint t1=e[i].to;\n\t\t\tif(cost[t1]<cost[a1]+e[i].co&&e[i].len)\n\t\t\t{\n\t\t\t\tcost[t1]=cost[a1]+e[i].co;\n\t\t\t\tflow[t1]=min(flow[a1],e[i].len);\n\t\t\t\tpre[t1]=a1,la[t1]=i;\n\t\t\t\tif(!inq[t1])inq[t1]=1,q.push(t1);\n\t\t\t}\n\t\t}\n\t}return pre[T]!=-1;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%d%d%lld\",&a[i][0],&a[i][1],&va[i]);\n\tscanf(\"%d\",&m);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%s\",ch);\n\t\tif(ch[0]=='L')b[i][0]=0;\n\t\telse if(ch[0]=='R')b[i][0]=1;\n\t\telse if(ch[0]=='D')b[i][0]=2;\n\t\telse b[i][0]=3;\n\t\tscanf(\"%d%d\",&b[i][1],&b[i][2]);\n\t}\n\tfor(int k=1;k<=n;k++)\n\t{//printf(\"%d times\\n\",k);\n\t\tfor(int i=1;i<=k;i++)lx[i]=ly[i]=0,rx[i]=ry[i]=inf;\n\t\tfor(int i=1;i<=m;i++)\n\t\t{\n\t\t\tif(b[i][0]==0)for(int j=b[i][2]+1;j<=k;j++)lx[j]=max(lx[j],b[i][1]+1);\n\t\t\telse if(b[i][0]==1)for(int j=1;j<=k-b[i][2];j++)rx[j]=min(rx[j],b[i][1]-1);\n\t\t\telse if(b[i][0]==2)for(int j=b[i][2]+1;j<=k;j++)ly[j]=max(ly[j],b[i][1]+1);\n\t\t\telse for(int j=1;j<=k-b[i][2];j++)ry[j]=min(ry[j],b[i][1]-1);\n\t\t}bool flag=true;\n\t\tfor(int i=1;i<=k;i++)if(lx[i]>rx[i]||ly[i]>ry[i]){flag=false;break;}\n\t\tif(!flag)continue;\n\t\tS=2*k+2*n+1,T=S+1;\n\t\tfor(int i=1;i<=T;i++)head[i]=0;cnt=2;\n\t\tfor(int i=1;i<=k;i++)\n\t\t{\n\t\t\tins(S,2*n+i,1,0);ins(2*n+i,S,0,0);\n\t\t\tins(2*n+k+i,T,1,0);ins(T,2*n+k+i,0,0);\n\t\t\tfor(int j=1;j<=n;j++)\n\t\t\t{\n\t\t\t\tif(lx[i]<=a[j][0]&&a[j][0]<=rx[i])ins(2*n+i,j,1,0),ins(j,2*n+i,0,0);\n\t\t\t\tif(ly[i]<=a[j][1]&&a[j][1]<=ry[i])ins(n+j,2*n+k+i,1,0),ins(2*n+k+i,n+j,0,0);\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=n;i++)ins(i,n+i,1,va[i]),ins(n+i,i,0,-va[i]);\n\t\tll sum=0;\n\t\twhile(spfa())\n\t\t{\n\t\t\tsum+=cost[T]*flow[T];\n\t\t\tint x=T;\n\t\t\twhile(x^S){e[la[x]].len-=flow[T],e[la[x]^1].len+=flow[T],x=pre[x];}\n\t\t}\n\t\tans=max(ans,sum);\n\t}printf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<map>\n#include<bitset>\n#include<set>\n#define N (100010)\n#define P ()\n#define M ()\n#define inf (0x7f7f7f7f)\n#define rg register int\n#define Label puts(\"NAIVE\")\n#define spa print(' ')\n#define ent print('\\n')\n#define rand() (((rand())<<(15))^(rand()))\n#define file(s) freopen(s\".in\",\"r\",stdin),freopen(s\".out\",\"w\",stdout)\ntypedef long double ld;\ntypedef long long LL;\ntypedef unsigned long long ull;\nusing namespace std;\nnamespace fastIO1{\n\tinline char read(){\n\t\tstatic const int IN_LEN=1000000;\n\t\tstatic char buf[IN_LEN],*s,*t;\n\t\treturn (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);\n\t}\n\ttemplate<class T>\n\tinline void read(T &x){\n\t\tstatic bool iosig;\n\t\tstatic char c;\n\t\tfor(iosig=false,c=read();!isdigit(c);c=read()){\n\t\t\tif(c=='-')iosig=true;\n\t\t\tif(c==-1)return;\n\t\t}\n\t\tfor(x=0;isdigit(c);c=read())x=((x+(x<<2))<<1)+(c^'0');\n\t\tif(iosig)x=-x;\n\t}\n\tinline char readc(char &c){\n\t\tfor(c=read();!isalpha(c)&&!isdigit(c);c=read())\n\t\tif(c==-1)return 0;\n\t}\n\tconst int OUT_LEN = 10000000;\n\tchar obuf[OUT_LEN],*ooh=obuf;\n\tinline void print(char c){\n\t\tif(ooh==obuf+OUT_LEN)fwrite(obuf,1,OUT_LEN,stdout),ooh=obuf;\n\t\t*ooh++=c;\n\t}\n\ttemplate<class T>\n\tinline void print(T x){\n\t\tstatic int buf[30],cnt;\n\t\tif(x==0)print('0');\n\t\telse{\n\t\t\tif(x<0)print('-'),x=-x;\n\t\t\tfor(cnt=0;x;x/=10)buf[++cnt]=x%10+48;\n\t\t\twhile(cnt)print((char)buf[cnt--]);\n\t\t}\n\t}\n\tinline void flush(){fwrite(obuf,1,ooh-obuf,stdout);}\n}\nnamespace fastIO2{\n\ttemplate<class T>\n\tinline void read(T &x){\n\t\tstatic bool iosig;\n\t\tstatic char c;\n\t\tfor(iosig=false,c=getchar();!isdigit(c);c=getchar()){\n\t\t\tif(c=='-')iosig=true;\n\t\t\tif(c==-1)return;\n\t\t}\n\t\tfor(x=0;isdigit(c);c=getchar())x=((x+(x<<2))<<1)+(c^'0');\n\t\tif(iosig)x=-x;\n\t}\n}\nusing namespace fastIO1;\nstruct limits{int l,op,x;}q[N];\nstruct points{int x,y;LL w;}a[N];\nint n,m,E=1,S,T,V,lx[N],rx[N],ly[N],ry[N];\nint fi[N],ne[N],b[N],cap[N],pre[N],prv[N];\nbool vis[N]; LL ans,mx,ot,c[N],dis[N];\nvoid add(int x,int y,int cp,LL cost){\n//\tprintf(\"%d--%lld-->%d\\n\",x,cost,y);\n\tne[++E]=fi[x],fi[x]=E,b[E]=y;\n\tcap[E]=cp,c[E]=cost;\n\tne[++E]=fi[y],fi[y]=E,b[E]=x;\n\tcap[E]=0,c[E]=-cost;\n}\nvoid mcmf(int S,int T,int flow){\n\twhile(flow){\n\t\tfor(int i=1;i<=V;i++)dis[i]=1e18,vis[i]=0;\n\t\tdis[S]=0; queue<int> Q; Q.push(S),vis[S]=1;\n\t\twhile(!Q.empty()){\n\t\t\tint u=Q.front();Q.pop(),vis[u]=0;\n\t\t\tif(dis[u]==1e18)continue;\n\t\t\tfor(int i=fi[u];i;i=ne[i]){\n\t\t\t\tint v=b[i];\n\t\t\t\tif(cap[i]>0&&dis[u]+c[i]<dis[v]){\n                    dis[v]=dis[u]+c[i];\n                    prv[v]=u,pre[v]=i;\n                    if(!vis[v])Q.push(v),vis[v]=1;\n                }\n\t\t\t}\n\t\t}\n\t\tif(dis[T]==1e18)break;\n\t\tint w=flow;\n\t\tfor(int i=T;i!=S;i=prv[i])\n\t\tw=min(w,cap[pre[i]]);\n\t\tflow-=w,mx+=dis[T];\n\t\tfor(int i=T;i!=S;i=prv[i]){\n\t\t\tint e=pre[i];\n\t\t\tcap[e]-=w,cap[e^1]+=w;\n\t\t}\n\t}\n}\nvoid solve(int cnt){\n\tmemset(fi,0,n*32),E=1;\n\tmemset(rx,inf,(n+3)<<2);\n\tmemset(lx,0,(n+3)<<2);\n\tmemset(ry,inf,(n+3)<<2);\n\tmemset(ly,0,(n+3)<<2);\n\tfor(int j=1;j<=m;j++){\n\t\tint t=(q[j].op&1)?q[j].x+1:cnt-q[j].x;\n\t\tif(t>cnt||t<=0)continue;\n\t\tif(q[j].op==1)lx[t]=max(lx[t],q[j].l+1);\n\t\telse if(q[j].op==2)rx[t]=min(rx[t],q[j].l-1);\n\t\telse if(q[j].op==3)ly[t]=max(ly[t],q[j].l+1);\n\t\telse ry[t]=min(ry[t],q[j].l-1);\n\t}\n\tfor(int i=2;i<=cnt;i++)lx[i]=max(lx[i-1],lx[i]),ly[i]=max(ly[i-1],ly[i]);\n\tfor(int i=cnt;i;i--)rx[i]=min(rx[i+1],rx[i]),ry[i]=min(ry[i+1],ry[i]);\n\tS=2*(n+cnt)+1,T=S+1,V=T;\n\tfor(int i=1;i<=n;i++)add(i,i+n,1,-a[i].w);\n\tfor(int i=1;i<=cnt;i++){\n\t\tif(lx[i]>rx[i]||ly[i]>ry[i])return;\n\t\tfor(int j=1;j<=n;j++)\n\t\tif(lx[i]<=a[j].x&&a[j].x<=rx[i])\n\t\tadd(i+2*n,j,1,0);\n\t\tfor(int j=1;j<=n;j++)\n\t\tif(ly[i]<=a[j].y&&a[j].y<=ry[i])\n\t\tadd(j+n,i+2*n+cnt,1,0);\n\t\tadd(S,i+2*n,1,0),add(i+2*n+cnt,T,1,0);\n\t}\n\tmx=0,mcmf(S,T,inf),ot=max(ot,-mx);\n}\nint main(){\n\tread(n);\n\tfor(int i=1;i<=n;i++)read(a[i].x),read(a[i].y),read(a[i].w); read(m);\n\tfor(int i=1;i<=m;i++){\n\t\tchar ch; readc(ch),read(q[i].l),read(q[i].x);\n\t\tq[i].op=(ch=='L')?1:ch=='R'?2:ch=='D'?3:4;\n\t}\n\tfor(int i=1;i<=n;i++)solve(i); cout<<ot;\n}"
  },
  {
    "language": "C++",
    "code": "// Author -- Frame\n\n#include<bits/stdc++.h>\n\n#define lowbit(x) ((x)&(-x))\n#define Finline __inline__ __attribute__ ((always_inline))\n#define DEBUG fprintf(stderr,\"Running on Line %d in Function %s\\n\",__LINE__,__FUNCTION__)\n#define SZ(x) ((int)x.size())\n#define mkpr std::make_pair\n#define pb push_back\n\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> pi;\ntypedef std::pair<ll,ll> pl;\n\nconst int inf=0x3f3f3f3f,Inf=0x7fffffff;\nconst ll INF=0x3f3f3f3f3f3f3f3f;\n\nFinline uint rnd()\n{\n\tstatic uint seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\ntemplate <typename _Tp>_Tp gcd(const _Tp &a,const _Tp &b){return (!b)?a:gcd(b,a%b);}\ntemplate <typename _Tp>Finline _Tp abs(const _Tp &a){return a>=0?a:-a;}\ntemplate <typename _Tp>Finline _Tp max(const _Tp &a,const _Tp &b){return a<b?b:a;}\ntemplate <typename _Tp>Finline _Tp min(const _Tp &a,const _Tp &b){return a<b?a:b;}\ntemplate <typename _Tp>Finline void chmax(_Tp &a,const _Tp &b){(a<b)&&(a=b);}\ntemplate <typename _Tp>Finline void chmin(_Tp &a,const _Tp &b){(b<a)&&(a=b);}\ntemplate <typename _Tp>Finline void read(_Tp &x)\n{\n\tchar ch(getchar());\n\tbool f(false);\n\twhile(ch<48||ch>57) f|=ch==45,ch=getchar();\n\tx=ch&15,ch=getchar();\n\twhile(ch>=48&&ch<=57) x=(((x<<2)+x)<<1)+(ch&15),ch=getchar();\n\tif(f) x=-x;\n}\ntemplate <typename _Tp,typename... Args>Finline void read(_Tp &t,Args &...args){read(t);read(args...);}\nFinline int read_str(char *s)\n{\n\tchar ch(getchar());\n\twhile(ch==' '||ch=='\\r'||ch=='\\n') ch=getchar();\n\tchar *tar=s;\n\t*tar=ch,ch=getchar();\n\twhile(ch!=' '&&ch!='\\r'&&ch!='\\n'&&ch!=EOF) *(++tar)=ch,ch=getchar();\n\treturn tar-s+1;\n}\n\nconst int N=205;\nint x[N],y[N];\nll val[N];\nstruct edge{\n\tint v,nxt,w;\n\tll cost;\n}c[N*N<<3];\nint front[N],edge_cnt;\nFinline void addedge(int u,int v,int w,ll cost)\n{\n\tc[++edge_cnt]=(edge){v,front[u],w,cost};\n\tfront[u]=edge_cnt;\n\t\n\tc[++edge_cnt]=(edge){u,front[v],0,-cost};\n\tfront[v]=edge_cnt;\n}\nchar opt[325];\nint C[325],D[325];\nint L[N],R[N];\nint S,T;\nll dep[N];\nint cur[N];\nint _q[N*N],_l,_r;\nbool inq[N];\nbool bfs()\n{\n\tmemcpy(cur,front,sizeof(cur));\n\tmemset(dep,63,sizeof(dep));\n\tmemset(inq,0,sizeof(inq));\n\t_q[_l=_r=1]=S;\n\tdep[S]=0;\n\twhile(_l!=_r+1)\n\t{\n\t\tint x=_q[_l++];\n\t\tinq[x]=false;\n\t\tfor(int i=front[x];~i;i=c[i].nxt)\n\t\t{\n\t\t\tint v=c[i].v;\n\t\t\tif(c[i].w&&dep[v]>dep[x]+c[i].cost)\n\t\t\t{\n\t\t\t\tdep[v]=dep[x]+c[i].cost;\n\t\t\t\tif(!inq[v]) inq[v]=true,_q[++_r]=v;\n\t\t\t}\n\t\t}\n\t}\n\treturn dep[T]<INF;\n}\nint dfs(int x,int flow)\n{\n\tif(x==T||!flow) return flow;\n\tinq[x]=true;\n\tint f=0,rf;\n\tfor(int &i=cur[x];~i;i=c[i].nxt)\n\t{\n\t\tif(!inq[c[i].v]&&dep[c[i].v]==dep[x]+c[i].cost&&(rf=dfs(c[i].v,min(flow,c[i].w))))\n\t\t{\n\t\t\tflow-=rf,f+=rf;\n\t\t\tc[i].w-=rf,c[i^1].w+=rf;\n\t\t\tif(!flow) return f;\n\t\t}\n\t}\n\treturn f;\n}\npl dinic()\n{\n\tint res=0;\n\tll ans=0;\n\twhile(bfs())\n\t{\n\t\tint tmp=dfs(S,inf);\n\t\tres+=tmp;\n\t\tans+=1ll*tmp*dep[T];\n\t}\n\treturn mkpr(res,ans);\n}\nint main()\n{\n\tint n,m;\n\tread(n);\n\tfor(int i=1;i<=n;++i) read(x[i],y[i],val[i]);\n\tread(m);\n\tfor(int i=1;i<=m;++i)\n\t{\n\t\tchar ch=getchar();\n\t\twhile(!isalpha(ch)) ch=getchar();\n\t\topt[i]=ch;\n\t\tread(C[i],D[i]);\n\t}\n\tll res=0;\n\tfor(int k=1;k<=n;++k)\n\t{\n\t\tedge_cnt=-1;\n\t\tmemset(front,255,sizeof(front));\n\t\tmemset(L,-63,sizeof(L)),memset(R,63,sizeof(R));\n\t\tfor(int i=1;i<=m;++i)\n\t\t{\n\t\t\tif(D[i]>=k) continue;\n\t\t\tif(opt[i]=='L') chmax(L[D[i]+1],C[i]+1);\n\t\t\telse if(opt[i]=='R') chmin(R[k-D[i]],C[i]-1);\n\t\t\telse if(opt[i]=='D') chmax(L[D[i]+1+k],C[i]+1);\n\t\t\telse chmin(R[k-D[i]+k],C[i]-1);\n\t\t}\n\t\tfor(int i=2;i<=k;++i) chmax(L[i],L[i-1]);\n\t\tfor(int i=k-1;i>=1;--i) chmin(R[i],R[i+1]);\n\t\tfor(int i=k+2;i<=k+k;++i) chmax(L[i],L[i-1]);\n\t\tfor(int i=k+k-1;i>k;--i) chmin(R[i],R[i+1]);\n\t\tS=n+n+k+k+1;\n\t\tT=S+1;\n\t\tfor(int i=1;i<=k;++i)\n\t\t{\n\t\t\taddedge(S,i,1,0);\n\t\t\taddedge(i+k,T,1,0);\n\t\t\tfor(int j=1;j<=n;++j)\n\t\t\t{\n\t\t\t\tif(x[j]>=L[i]&&x[j]<=R[i]) addedge(i,j+k+k,1,0);\n\t\t\t\tif(y[j]>=L[i+k]&&y[j]<=R[i+k]) addedge(j+k+k+n,i+k,1,0);\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=n;++i) addedge(i+k+k,i+k+k+n,1,-val[i]);\n\t\tpl ans=dinic();\n\t\tif(ans.first==k) chmax(res,-ans.second);\n\t}\n\tprintf(\"%lld\\n\",res);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 16.03.2019 16:16:57       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring to_string(string s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntypedef long double ld;\n\nconst ld eps = 1e-8;\n\nvector<ld> simplex(vector<vector<ld>> a) {\n  int n = (int) a.size() - 1;\n  int m = (int) a[0].size() - 1;\n  vector<int> left(n + 1);\n  vector<int> up(m + 1);\n  iota(left.begin(), left.end(), m);\n  iota(up.begin(), up.end(), 0);\n  auto pivot = [&](int x, int y) {\n    swap(left[x], up[y]);\n    ld k = a[x][y];\n    a[x][y] = 1;\n    vector<int> pos;\n    for (int j = 0; j <= m; j++) {\n      a[x][j] /= k;\n      if (fabs(a[x][j]) > eps) {\n        pos.push_back(j);\n      }\n    }\n    for (int i = 0; i <= n; i++) {\n      if (fabs(a[i][y]) < eps || i == x) {\n        continue;\n      }\n      k = a[i][y];\n      a[i][y] = 0;\n      for (int j : pos) {\n        a[i][j] -= k * a[x][j];\n      }\n    }\n  };\n  while (1) {\n    int x = -1;\n    for (int i = 1; i <= n; i++) {\n      if (a[i][0] < -eps && (x == -1 || a[i][0] < a[x][0])) {\n        x = i;\n      }\n    }\n    if (x == -1) {\n      break;\n    }\n    int y = -1;\n    for (int j = 1; j <= m; j++) {\n      if (a[x][j] < -eps && (y == -1 || a[x][j] < a[x][y])) {\n        y = j;\n      }\n    }\n    if (y == -1) {\n      return vector<ld>(); // infeasible\n    }\n    pivot(x, y);\n  }\n  while (1) {\n    int y = -1;\n    for (int j = 1; j <= m; j++) {\n      if (a[0][j] > eps && (y == -1 || a[0][j] > a[0][y])) {\n        y = j;\n      }\n    }\n    if (y == -1) {\n      break;\n    }\n    int x = -1;\n    for (int i = 1; i <= n; i++) {\n      if (a[i][y] > eps && (x == -1 || a[i][0] / a[i][y] < a[x][0] / a[x][y])) {\n        x = i;\n      }\n    }\n    if (x == -1) {\n      return vector<ld>(); // unbounded\n    }\n    pivot(x, y);\n  }\n  vector<ld> ans(m + 1);\n  for (int i = 1; i <= n; i++) {\n    if (left[i] <= m) {\n      ans[left[i]] = a[i][0];\n    }\n  }\n  ans[0] = -a[0][0];\n  return ans;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<int> x(n), y(n);\n  vector<long long> z(n);\n  for (int i = 0; i < n; i++) {\n    cin >> x[i] >> y[i] >> z[i];\n  }\n  vector<vector<ld>> mat;\n  {\n    vector<ld> row(n + 1);\n    for (int i = 0; i < n; i++) {\n      row[i + 1] = z[i];\n    }\n    mat.push_back(row);\n  }\n  {\n    for (int i = 0; i < n; i++) {\n      vector<ld> row(n + 1);\n      row[0] = 1;\n      row[i + 1] = 1;\n      mat.push_back(row);\n    }\n  }\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    string foo;\n    int bar, baz;\n    cin >> foo >> bar >> baz;\n    vector<ld> row(n + 1);\n    row[0] = baz;\n    if (foo == \"L\") {\n      for (int i = 0; i < n; i++) if (x[i] <= bar) row[i + 1] = 1;\n    }\n    if (foo == \"R\") {\n      for (int i = 0; i < n; i++) if (x[i] >= bar) row[i + 1] = 1;\n    }\n    if (foo == \"D\") {\n      for (int i = 0; i < n; i++) if (y[i] <= bar) row[i + 1] = 1;\n    }\n    if (foo == \"U\") {\n      for (int i = 0; i < n; i++) if (y[i] >= bar) row[i + 1] = 1;\n    }\n    mat.push_back(row);\n  }\n  mat.emplace_back(n + 1, 1);\n  mat.emplace_back(n + 1, -1);\n  long long ans = 0;\n  for (int cc = 1; cc <= n; cc++) {\n    mat[(int) mat.size() - 2][0] = cc;\n    mat[(int) mat.size() - 1][0] = -cc;\n    vector<ld> ret = simplex(mat);\n    if (!ret.empty()) {\n      long long cur = 0;\n      for (int i = 0; i < n; i++) {\n        if (ret[i + 1] > 1 - eps) {\n          cur += z[i];\n        }\n      }\n      ans = max(ans, cur);\n    }\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace __gnu_pbds;\nusing namespace std;\n \ntemplate <typename T>\nusing ordered_set =\n\ttree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n \n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n\t*this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n \n#define shandom_ruffle random_shuffle\n \nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=327;\nusing bn=bitset<87>;\nusing ld=long double;\n\nint n;\npii gdz[nax];\nll war[nax];\n\nint m;\nbn podz[nax];\nint ile[nax];\n\nll wyn;\n\nstruct Simplex {        // Maximize c*x subject to Ax <= b.\n  using T = ld;     // Initialize the structure, set A, b, c and then run\n  vector<vector<T>> A;  // solve(). Max objective is stored in res. To recover\n  vector<T> b, c;       // the best result, use getVars().\n  int V, E;\n  vector<int> eqIds, varIds, cols;\n  T res;\n  static constexpr T kEps = 1e-17;\n\n  Simplex(int vars, int eqs) : A(eqs, vector<T>(vars)), b(eqs), c(vars),\n      V(vars), E(eqs), eqIds(eqs), varIds(vars), res(0) {\n    iota(varIds.begin(), varIds.end(), 0);\n    iota(eqIds.begin(), eqIds.end(), vars);\n  }\n\n  void pivot(int eq, int var) {\n    T coef = 1 / A[eq][var];\n    cols.clear();\n    for (int i = 0; i < V; i++) {\n      if (abs(A[eq][i]) > kEps) { cols.push_back(i); A[eq][i] *= coef; }\n    }\n    A[eq][var] *= coef; b[eq] *= coef;\n    for (int row = 0; row < E; row++) {\n      if (row == eq || abs(A[row][var]) < kEps) { continue; }\n      T k = -A[row][var];\n      A[row][var] = 0;\n      for (int i : cols) { A[row][i] += k * A[eq][i]; }\n      b[row] += k * b[eq];\n    }\n    T q = c[var]; c[var] = 0;\n    for (int i : cols) { c[i] -= q * A[eq][i]; }\n    res += q * b[eq];\n    swap(varIds[var], eqIds[eq]);\n  }\n\n  bool solve() {\n    while (true) {\n      int eq = -1, var = -1;\n      for (int i = 0; i < E; i++) { if (b[i] < -kEps) { eq = i; break; } }\n      if (eq == -1) { break; }\n      for (int i = 0; i < V; i++) { if (A[eq][i] < -kEps) { var = i; break; } }\n      if (var == -1) { res = -1e9; return false; /* No solution */ }\n      pivot(eq, var);\n    }\n    while (true) {\n      int var = -1, eq = -1;\n      for (int i = 0; i < V; i++) { if (c[i] > kEps) { var = i; break; } }\n      if (var == -1) { break; }\n      for (int i = 0; i < E; i++) {\n        if (A[i][var] < kEps) { continue; }\n        if (eq >= 0 && b[i] / A[i][var] >= b[eq] / A[eq][var]) { continue; }\n        eq = i;\n      }\n      if (eq == -1) { res = 1e9; return false; /* Unbounded */ }\n      pivot(eq, var);\n    }\n    return true;\n  }\n\n  vector<T> getVars() { // Optimal assignment of variables.\n    vector<T> result(V);\n    for (int i = 0; i < E; i++) if (eqIds[i] < V) result[eqIds[i]] = b[i];\n    return result;\n  }\n};\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(\"%d%d%lld\", &gdz[i].first, &gdz[i].second, &war[i]);\n\tscanf(\"%d\", &m);\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\tchar c;\n\t\tint a, b;\n\t\tscanf(\" %c%d%d\", &c, &a, &b);\n\t\tfor (int j=1; j<=n; j++)\n\t\t{\n\t\t\tif (c=='L' && gdz[j].first<=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='R' && gdz[j].first>=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='D' && gdz[j].second<=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='U' && gdz[j].second>=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t}\n\t\tile[i]=b;\n\t}\n\tSimplex janusz(n, m+2*n);\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tjanusz.c[i]=war[i+1];\n\t}\n\tfor (int i=0; i<m; i++)\n\t{\n\t\tjanusz.b[i]=ile[i+1];\n\t\tfor (int j=0; j<n; j++)\n\t\t\tjanusz.A[i][j]=podz[i+1][j+1];\n\t}\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tjanusz.b[m+i]=1;\n\t\tjanusz.A[m+i][i]=1;\n\t}\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tjanusz.b[m+n+i]=0;\n\t\tjanusz.A[m+n+i][i]=-1;\n\t}\n\tassert(janusz.solve());\n\tld wez=janusz.res;\n\tdebug() << imie(wez);\n\tdebug() << janusz.getVars();\n\tprintf(\"%lld\\n\", llround(wez));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n#define REP(i, a, n) for(LL i = (a), i##_max = (n); i < i##_max; ++i)\n#define REM(i, a, n) for(LL i = (LL)(n) - 1, i##min = (a); i >= i##min; --i)\n#define ALL(arr) (arr).begin(), (arr).end()\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP {cin.tie(NULL); ios::sync_with_stdio(false);}\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst string INFSTR = \"\\x7f\";\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate<class T>\nT Compare(T left, T right) { return left > right ? 1 : (left < right ? -1 : 0); }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\ntemplate <class T>\nT Next() { T buf; cin >> buf; return buf; }\n\n#ifdef ONLY_MY_ENVIR\n#include \"IntMod.h\"\n#include \"UnionFind.h\"\n#include \"Graph.h\"\n#include \"Range.h\"\n#include \"Global.h\"\n#include \"FlowSolver.h\"\n#include \"Tree.h\"\n#include \"SuffixArray.h\"\n#include \"Matrix.h\"\n#include \"SegmentTree.h\"\n#include \"SegmentTree2D.h\"\n#include \"BIT.h\"\n#include \"Rational.h\"\n#include \"Position.h\"\n#include \"Factorization.h\"\n#include \"Math.h\"\n#include \"LazySegmentTree.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>> (istream& ist, __int128& val) { LL tmp;  ist >> tmp; val = tmp; return ist; }\nostream& operator<< (ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\n#if 1234567891\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\n// template <class T>\n// auto Is(const T& value) { return [value](const auto& comparand) -> bool { return comparand == value; }; }\n#endif\n\nint N, M;\nint x[80], y[80];\nLLL v[80];\nchar t[320];\nint a[320], b[320];\nbool lim[320][80];\nint c[320];\n\nvoid pre() {\n\tREP(j, 0, M) {\n\t\tREP(i, 0, N) {\n\t\t\tbool ng = false;\n\t\t\tswitch (t[j]) {\n\t\t\tcase 'L': ng = (x[i] <= a[j]); break;\n\t\t\tcase 'R': ng = (x[i] >= a[j]); break;\n\t\t\tcase 'D': ng = (y[i] <= a[j]); break;\n\t\t\tcase 'U': ng = (y[i] >= a[j]); break;\n\t\t\t}\n\t\t\tif (ng) lim[j][i] = true;\n\t\t}\n\t}\n}\n\nLLL calc_score(const vector<bool>& ans) {\n\tLLL score = 0;\n\tREP(i, 0, N) {\n\t\tif (ans[i]) {\n\t\t\tscore += v[i];\n\t\t}\n\t}\n\n\tREP(j, 0, M) {\n\t\tint cnt = 0;\n\t\tREP(i, 0, N) {\n\t\t\tif (!ans[i]) continue;\n\t\t\tif (!lim[j][i]) continue;\n\t\t\t++cnt;\n\t\t}\n\t\tif (cnt > b[j]) {\n\t\t\tscore -= 1e18;\n\t\t}\n\t}\n\treturn score;\n}\n\nLLL estimate(int i, bool inc) {\n\tLLL delta = inc ? v[i] : -v[i];\n\tconst LLL penalty = 1e18;\n\tif (inc) {\n\t\tREP(j, 0, M) {\n\t\t\tif (lim[j][i]) {\n\t\t\t\tif (c[j] == b[j]) delta -= penalty;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tREP(j, 0, M) {\n\t\t\tif (lim[j][i]) {\n\t\t\t\tif (c[j] == b[j] + 1) delta += penalty;\n\t\t\t}\n\t\t}\n\t}\n\treturn delta;\n}\n\nvoid change(int i, bool inc) {\n\tif (inc) {\n\t\tREP(j, 0, M) {\n\t\t\tif (lim[j][i]) {\n\t\t\t\t++c[j];\n\t\t\t}\n\t\t}\n\t} else {\n\t\tREP(j, 0, M) {\n\t\t\tif (lim[j][i]) {\n\t\t\t\t--c[j];\n\t\t\t}\n\t\t}\n\t}\n}\n\nLLL sub() {\n\tpre();\n\tmt19937 mt;\n\tvector<bool> ans(N, false);\n\tLLL score = 0;\n\tLLL mx = score;\n\tdouble temp_start = 1e15;\n\tdouble temp_end = 0.1;\n\tdouble temp = 5;\n\n\tconst int times = 1000000;\n\tREP(z, 0, times) {\n\t\tint i = mt() % N;\n\n\t\tLLL pre_score = score;\n\n\t\tans[i] = !ans[i];\n\n\t\tLLL delta = estimate(i, ans[i]);\n\t\tscore = pre_score + delta;\n\t\tmx = max(mx, score);\n\t\tbool accepted = delta > 0 ||\n\t\t\t-delta < temp * 10 && exp(delta / temp) * (1ULL << 32) >= mt();\n\n\t\tif (accepted) {\n\t\t\tchange(i, ans[i]);\n\t\t} else {\n\t\t\tans[i] = !ans[i];\n\t\t\tscore = pre_score;\n\t\t}\n\n\t\tif (z % 2048 == 0) {\n\t\t\tdouble ratio = z / (double)times;\n\t\t\ttemp = pow(temp_start, 1 - ratio) * pow(temp_end, ratio);\n\t\t\tcerr << temp << '\\t' << score << endl;\n\t\t}\n\t}\n\treturn mx;\n}\n\nint main() {\n\tcin >> N;\n\tREP(i, 0, N) {\n\t\tcin >> x[i] >> y[i] >> v[i];\n\t}\n\tcin >> M;\n\tREP(j, 0, M) {\n\t\tcin >> t[j] >> a[j] >> b[j];\n\t}\n\n\tcout << sub() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//2019.5.25 by ljz\n#include<bits/stdc++.h>\nusing namespace std;\n#define res register int\n#define LL long long\n#define inf 0x3f3f3f3f\n#define INF 0x3f3f3f3f3f3f\n#define eps 1e-10\n#define RG register\n#define db double\n#define pc(x) __builtin_popcount(x)\ntypedef pair<int,int> Pair;\n#define mp make_pair\n#define fi first\n#define se second\n#define gc getchar\n//inline char gc() {\n//    static char buf[100000],*p1,*p2;\n//    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n//}\ninline int read() {\n    res s=0,ch=gc();\n    while(ch<'0'||ch>'9')ch=gc();\n    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=gc();\n    return s;\n}\ninline LL Read() {\n    RG LL s=0;\n    res ch=gc();\n    while(ch<'0'||ch>'9')ch=gc();\n    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=gc();\n    return s;\n}\ninline void swap(res &x,res &y) {\n    x^=y^=x^=y;\n}\n//mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nconst int N=1e3+10;\nnamespace MAIN {\n    int n,m;\n    char str[10];\n    LL v[N];\n    int x[N],y[N],t[N],a[N],b[N];\n    struct E{\n        int next,to,flow;\n        LL cost;\n        E() {}\n        E(res next,res to,res flow,RG LL cost):next(next),to(to),flow(flow),cost(cost) {}\n    }edge[N<<1];\n    int head[N],cnt;\n    inline void addedge(const res &u,const res &v,const res &f,const RG LL &c){\n        edge[++cnt]=E(head[u],v,f,c),head[u]=cnt;\n        edge[++cnt]=E(head[v],u,0,-c),head[v]=cnt;\n    }\n    LL dis[N];\n    int Q[N*N],he,ta,S,T,vis[N],pre[N];\n    inline bool spfa(RG LL &ret){\n        for(res i=S;i<=T;i++)dis[i]=INF;\n        Q[he=ta=1]=S,vis[S]=1,dis[S]=0;\n        while(he<=ta){\n            res u=Q[he++];\n            vis[u]=0;\n            for(res i=head[u];~i;i=edge[i].next){\n                res tox=edge[i].to;\n                if(dis[tox]>dis[u]+edge[i].cost&&edge[i].flow){\n                    dis[tox]=dis[u]+edge[i].cost,pre[tox]=i;\n                    if(!vis[tox])vis[tox]=1,Q[++ta]=tox;\n                }\n            }\n        }\n        if(dis[T]==INF)return 0;\n        ret+=dis[T];\n        for(res i=T;i!=S;i=edge[pre[i]^1].to)edge[pre[i]].flow--,edge[pre[i]^1].flow++;\n        return 1;\n    }\n    int L[N],R[N],D[N],U[N];\n    inline LL calc(const res &k){\n        for(res i=1;i<=k;i++)L[i]=D[i]=0,R[i]=U[i]=inf;\n        for(res i=1;i<=m;i++)\n            if(b[i]<k){\n                if(t[i]==0)L[b[i]+1]=a[i]+1;\n                if(t[i]==1)R[k-b[i]]=a[i]-1;\n                if(t[i]==2)D[b[i]+1]=a[i]+1;\n                if(t[i]==3)U[k-b[i]]=a[i]-1;\n            }\n        for(res i=2;i<=k;i++)L[i]=max(L[i],L[i-1]),D[i]=max(D[i],D[i-1]);\n        for(res i=k-1;i;i--)R[i]=min(R[i],R[i+1]),U[i]=min(U[i],U[i+1]);\n        S=0,T=(n+k)<<1|1;\n        for(res i=S;i<=T;i++)head[i]=-1;\n        cnt=-1;\n        for(res i=1;i<=n;i++)addedge(i,i+n,1,-v[i]-INF);\n        for(res i=1;i<=k;i++){\n            addedge(S,i+n*2,1,0),addedge(i+k+n*2,T,1,0);\n            for(res j=1;j<=n;j++){\n                if(L[i]<=x[j]&&x[j]<=R[i])addedge(i+n*2,j,1,0);\n                if(D[i]<=y[j]&&y[j]<=U[i])addedge(j+n,i+k+n*2,1,0);\n            }\n        }\n        RG LL ret=0;\n        while(spfa(ret));\n        return -ret-INF*k;\n    }\n    LL ans;\n    inline int get(const RG char *st){\n        return st[0]=='L'?0:(st[0]=='R'?1:(st[0]=='D'?2:3));\n    }\n    inline void MAIN(){\n        n=read();\n        for(res i=1;i<=n;i++)x[i]=read(),y[i]=read(),v[i]=Read();\n        m=read();\n        for(res i=1;i<=m;i++)scanf(\"%s\",str),t[i]=get(str),a[i]=read(),b[i]=read();\n        for(res i=1;i<=n;i++)ans=max(ans,calc(i));\n        printf(\"%lld\\n\",ans);\n    }\n}\nint main() {\n//    srand((unsigned)time(NULL));\n//    freopen(\"zao.in\",\"r\",stdin);\n//    freopen(\"std.out\",\"w\",stdout);\n    MAIN::MAIN();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\nint n, m, i, dest, srs;\nlong long sol;\nstruct str1{\n    int x, y;\n    long long c;\n};\nstr1 wn[85];\nstruct str2{\n    char tip;\n    int p, nr;\n};\nstr2 wm[330];\nint c[400][400], f[400][400], xst[85], xdr[85], yst[85], ydr[85], viz[400], t[400];\nlong long z[400][400], d[400];\nvector<int> v[400];\nqueue<int> cd;\nvoid muchie(int x, int y, int cc, long long cost){\n    v[x].push_back(y);\n    v[y].push_back(x);\n    c[x][y] = cc;\n    z[x][y] = cost;\n    z[y][x] = -cost;\n}\nvoid bf(){\n    int i, nod, vecin;\n    for(i = 0; i <= dest; i++){\n        d[i] = 1000000000000000000LL;\n        t[i] = -1;\n        viz[i] = 0;\n    }\n    d[srs] = 0;\n    cd.push(srs);\n    while(!cd.empty()){\n        nod = cd.front();\n        cd.pop();\n        viz[nod] = 0;\n        for(i = 0; i < v[nod].size(); i++){\n            vecin = v[nod][i];\n            if(d[vecin] > d[nod] + z[nod][vecin] && c[nod][vecin] > f[nod][vecin]){\n                d[vecin] = d[nod] + z[nod][vecin];\n                t[vecin] = nod;\n                if(viz[vecin] == 0){\n                    viz[vecin] = 1;\n                    cd.push(vecin);\n                }\n            }\n        }\n    }\n}\nlong long solve(int k){\n    int i, j, u, sum, minim;\n    long long sol = 0;\n    for(i = 1; i <= k; i++){\n        xst[i] = yst[i] = 0;\n        xdr[i] = ydr[i] = 101;\n    }\n    for(i = 1; i <= m; i++){\n        if(wm[i].tip == 'L'){\n            if(wm[i].nr + 1 <= k){\n                xst[ wm[i].nr + 1] = max(xst[ wm[i].nr + 1], wm[i].p + 1);\n            }\n        }\n        if(wm[i].tip == 'R'){\n            if(k - wm[i].nr > 0){\n                xdr[ k - wm[i].nr ] = min(xdr[ k - wm[i].nr ], wm[i].p - 1);\n            }\n        }\n        if(wm[i].tip == 'D'){\n            if(wm[i].nr + 1 <= k){\n                yst[ wm[i].nr + 1] = max(yst[ wm[i].nr + 1], wm[i].p + 1);\n            }\n        }\n        if(wm[i].tip == 'U'){\n            if(k - wm[i].nr > 0){\n                ydr[ k - wm[i].nr ] = min(ydr[ k - wm[i].nr ], wm[i].p - 1);\n            }\n        }\n    }\n    for(i = 2; i <= k; i++){\n        xst[i] = max(xst[i], xst[i - 1]);\n        yst[i] = max(yst[i], yst[i - 1]);\n    }\n    for(i = k - 1; i >= 1; i--){\n        xdr[i] = min(xdr[i], xdr[i + 1]);\n        ydr[i] = min(ydr[i], ydr[i + 1]);\n    }\n    dest = k * 2 + 200 + 1;\n    srs = 0;\n    for(i = srs; i <= dest; i++){\n        v[i].clear();\n        for(j = srs; j <= dest; j++){\n            f[i][j] = c[i][j] = z[i][j] = 0;\n        }\n    }\n    for(i = 1; i <= k; i++){\n        muchie(0, i, 1, 0);\n        muchie(k + 200 + i, dest, 1, 0);\n    }\n    for(i = 1; i <= 100; i++){\n        for(j = 1; j <= k; j++){\n            if(i >= xst[j] && i <= xdr[j]){\n                muchie(j, k + i, 1, 0);\n            }\n            if(i >= yst[j] && i <= ydr[j]){\n                muchie(k + 100 + i, j + k + 200, 1, 0);\n            }\n        }\n    }\n    for(i = 1; i <= n; i++){\n        muchie(k + wn[i].x, k + 100 + wn[i].y, 1, 1000000000000000LL - wn[i].c);\n    }\n    sum = 0;\n    for(i = 1; i <= k; i++){\n        bf();\n        if(t[dest] == -1){\n            break;\n        }\n        minim = 1000;\n        sol += 1000000000000000LL - d[dest];\n        for(u = dest; t[u] != -1; u = t[u]){\n            minim = min(minim, c[ t[u] ][u] - f[ t[u] ][u]);\n        }\n        sum += minim;\n        for(u = dest; t[u] != -1; u = t[u]){\n            f[ t[u] ][u] += minim;\n            f[u][ t[u] ] -= minim;\n        }\n    }\n    if(sum == k){\n        return sol;\n    }\n    else{\n        return -100000000000000LL;\n    }\n}\nint main(){\n    cin>> n;\n    for(i = 1; i <= n; i++){\n        cin>> wn[i].x >> wn[i].y >> wn[i].c;\n    }\n    cin>> m;\n    for(i = 1; i <= m; i++){\n        cin>> wm[i].tip >> wm[i].p >> wm[i].nr;\n    }\n    for(i = 1; i <= n; i++){\n        sol = max(sol, solve(i));\n    }\n    cout<< sol;\n}\n"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#define foreach(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\n#ifndef LOCAL\n#define cerr if(0)cout\n#endif\ntypedef long long ll;\nconst int mod = 1e9+7;\n//My i/o stream\nstruct fastio\n{\n\tchar s[100000];\n\tint it, len;\n\tfastio() {it=len=0;}\n\tinline char get()\n\t{\n\t\tif (it<len) return s[it++]; it=0;\n\t\tlen=fread(s, 1, 100000, stdin);\n\t\tif (len==0) return EOF; else return s[it++];\n\t}\n\tbool notend()\n\t{\n\t\tchar c=get();\n\t\twhile (c==' '||c=='\\n') c=get();\n\t\tif (it>0) it--;\n\t\treturn c!=EOF;\n\t}\n}_buff;\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putchar(' ')\n#define putii(x,y) puti(x),puti(y)\n#define putiii(x,y,z) putii(x,y),puti(z)\n#define putsi(x) putnum(x),putchar('\\n')\n#define putsii(x,y) puti(x),putsi(y)\n#define putsiii(x,y,z) putii(x,y),putsi(z)\ninline ll getnum()\n{\n\tll r=0; bool ng=0; char c; c=_buff.get();\n\twhile (c!='-'&&(c<'0'||c>'9')) c=_buff.get();\n\tif (c=='-') ng=1, c=_buff.get();\n\twhile (c>='0'&&c<='9') r=r*10+c-'0', c=_buff.get();\n\treturn ng?-r:r;\n}\ntemplate <class T> inline void putnum(T x)\n{\n\tif (x<0) putchar('-'), x=-x;\n\tregister short a[20]={}, sz=0;\n\twhile (x) a[sz++]=x%10, x/=10;\n\tif(sz==0) putchar('0');\n\tfor (int i=sz-1; i>=0; i--) putchar('0'+a[i]);\n}\ninline char getreal() {char c=_buff.get(); while (c<=32) c=_buff.get(); return c;}\nll qpow(ll x, ll k) {return k==0? 1: 1ll*qpow(1ll*x*x%mod,k>>1)*(k&1?x:1)%mod;}\nconst ll inf = 4e18;\nnamespace F\n{\n\tconst int maxn = 400, maxe = 100011;\n\tint head[maxn], nxt[maxe], to[maxe], cap[maxe];\n\tll cost[maxe], tot;\n\tvoid init()\n\t{\n\t\ttot = 1;\n\t\tmemset(head, 0, sizeof(head));\n\t}\n\tvoid add_edge(int x, int y, int c, ll w)\n\t{\n//\t\tcerr<<\"add_edge:\"<<x<<\",\"<<y<<\" \"<<c<<\" \"<<w<<endl;\n\t\tnxt[++tot] = head[x];\n\t\thead[x] = tot;\n\t\tto[tot] = y;\n\t\tcap[tot] = c;\n\t\tcost[tot] = w;\n\t\tswap(x, y);\n\t\tnxt[++tot] = head[x];\n\t\thead[x] = tot;\n\t\tto[tot] = y;\n\t\tcap[tot] = 0;\n\t\tcost[tot] = -w;\n\t\tassert(tot<maxe);\n\t}\n\tint q[maxn], qb, qe;\n\tll dis[maxn];\n\tbool inq[maxn];\n\tint qnxt(int x) {return (x+1)%maxn;}\n\tint qpre(int x) {return (x-1+maxn)%maxn;}\n\tvoid balance()\n\t{\n\t\tif (qb!=qe&&dis[q[qpre(qe)]]<dis[q[qb]])\n\t\t{\n\t\t\tswap(q[qpre(qe)], q[qb]);\n\t\t}\n\t}\n\tvoid spfa(int S, int N)\n\t{\n\t\tinq[S] = 1;\n\t\tfor (int i=0; i<=N; i++) dis[i] = inf;\n\t\tdis[S] = 0;\n\t\tqb = qe = 0;\n\t\tq[qe++] = S;\n\t\twhile (qb!=qe)\n\t\t{\n\t\t\tint x = q[qb];\n\t\t\tinq[x] = 0;\n\t\t\tqb = qnxt(qb);\n\t\t\tbalance();\n\t\t\tfor (int i = head[x]; i; i=nxt[i])\n\t\t\t{\n\t\t\t\tif (cap[i]&&dis[to[i]]>dis[x]+cost[i])\n\t\t\t\t{\n\t\t\t\t\tdis[to[i]] = dis[x]+cost[i];\n\t\t\t\t\tif (!inq[to[i]])\n\t\t\t\t\t{\n\t\t\t\t\t\tinq[to[i]] = 1;\n\t\t\t\t\t\tq[qe] = to[i];\n\t\t\t\t\t\tqe = qnxt(qe);\n\t\t\t\t\t\tbalance();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tfor (int i=1; i<=N; i++) cerr<<dis[i]<<\" \"; cerr<<endl;\n\t}\n\t\n\tbool vis[maxn];\n\tint dfs(int x, int T, int f)\n\t{\n\t\tif (x==T) return f;\n\t\tvis[x] = 1;\n\t\tint of = f;\n\t\tfor (int i=head[x]; i; i=nxt[i])\n\t\t{\n\t\t\tif (!vis[to[i]]&&cap[i]&&dis[to[i]]==dis[x]+cost[i])\n\t\t\t{\n\t\t\t\tint u = to[i];\n\t\t\t\tint d = dfs(u, T, min(f, cap[i]));\n\t\t\t\tcap[i] -= d;\n\t\t\t\tcap[i^1] += d;\n\t\t\t\tf -= d;\n\t\t\t\tif (!f) return of;\n\t\t\t}\n\t\t}\n\t\treturn of-f;\n\t}\n\tpair<int, ll> min_cost_flow(int S, int T, int K)\n\t{\n\t\tll ans = 0;\n\t\tint flow = 0;\n\t\twhile (flow<K)\n\t\t{\n\t\t\tspfa(S, T);\n\t\t\tif (dis[T]>=inf) break;\n\t\t\twhile (flow<K)\n\t\t\t{\n\t\t\t\tmemset(vis, 0, sizeof(vis));\n\t\t\t\tint f = dfs(S, T, K-flow);\n\t\t\t\tans += 1ll*f*dis[T];\n\t\t\t\tflow += f;\n\t\t\t\tif (f==0) break;\n\t\t\t}\n\t\t}\n\t\treturn MP(flow, ans);\n\t}\n};\nint n;\nint tid[256];\npair<int,int> a[88];\nll w[88];\nvector<pair<int,int> > M[4];\npair<int,int> segx[88], segy[88];\nll solve(int K)\n{\n//\tcerr<<\"solve: \"<<K<<endl;\n\tfor (int i=1; i<=K; i++) segx[i] = segy[i] = MP(0, 100);\n\tfor (auto x : M[0])\n\t{\n\t\tfor (int i=x.SS+1; i<=K; i++)\n\t\t{\n\t\t\tsegx[i].FF = max(segx[i].FF, x.FF+1);\n\t\t}\n\t}\n\tfor (auto x : M[1])\n\t{\n\t\tfor (int i=K-x.SS; i>=1; i--)\n\t\t{\n\t\t\tsegx[i].SS = min(segx[i].SS, x.FF-1);\n\t\t}\n\t}\n\tfor (auto x : M[2])\n\t{\n\t\tfor (int i=x.SS+1; i<=K; i++)\n\t\t{\n\t\t\tsegy[i].FF = max(segy[i].FF, x.FF+1);\n\t\t}\n\t}\n\tfor (auto x : M[3])\n\t{\n\t\tfor (int i=K-x.SS; i>=1; i--)\n\t\t{\n\t\t\tsegy[i].SS = min(segy[i].SS, x.FF-1);\n\t\t}\n\t}\n\tint S = 2*K+2*n+1, T = S+1;\n\tF::init();\n\tfor (int i=1; i<=K; i++)\n\t{\n\t\tF::add_edge(S, i, 1, 0);\n\t\tF::add_edge(i+K, T, 1, 0);\n\t\tfor (int j=1; j<=n; j++)\n\t\t{\n\t\t\tif (segx[i].FF<=a[j].FF&&a[j].FF<=segx[i].SS)\n\t\t\t{\n\t\t\t\tF::add_edge(i, j+2*K, 1, 0);\n\t\t\t}\n\t\t\tif (segy[i].FF<=a[j].SS&&a[j].SS<=segy[i].SS)\n\t\t\t{\n\t\t\t\tF::add_edge(j+2*K+n, i+K, 1, 0);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1; i<=n; i++) F::add_edge(i+2*K, i+2*K+n, 1, -w[i]);\n\tpair<int, ll> ans = F::min_cost_flow(S, T, K);\n//\tcerr<<\"F::ftot=\"<<F::ftot<<endl;\n\tif (ans.FF<K) return 0;\n//\tcerr<<\"ans=\"<<ans<<endl;\n\treturn -ans.SS;\n}\nint main()\n{\n\ttid['L'] = 0;\n\ttid['R'] = 1;\n\ttid['D'] = 2;\n\ttid['U'] = 3;\n\tgeti(n);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tll x, y, v;\n\t\tgetiii(x, y, v);\n\t\ta[i] = MP(x, y);\n\t\tw[i] = v;\n\t}\n\tint m;\n\tgeti(m);\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\tchar t;\n\t\tint a, b;\n\t\tt = getreal();\n\t\tgetii(a, b);\n\t\tM[tid[t]].PB(MP(a, b));\n\t}\n\tll ans = 0;\n\tfor (int K=1; K<=n; K++)\n\t{\n\t\tans = max(ans, solve(K));\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<double, double> pdd;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\n//const int mod = ;\n\nstruct J {\n  int x, y, ind;\n  ll cost;\n};\n\nvi dx(100, 100), ux(100, 100), dy(100, 100), uy(100, 100);\nvector<J> v;\nvi best;\nll best_score = 0;\n\nll eval(const vi& x) {\n  ll score = 0;\n  for (int i = 0; i < v.size(); ++i) score += v[i].cost * x[i];\n  return score;\n}\n\nvoid update(const vi& x) {\n  ll score = eval(x);\n  if (score > best_score) {\n    best = x;\n    best_score = score;\n  }\n}\n\nint tmpx[100], tmpy[100];\nbool valid_add(int ind, const vi& x) {\n  memset(tmpx, 0, sizeof(tmpx));\n  memset(tmpy, 0, sizeof(tmpy));\n  for (int i = 0; i < x.size(); ++i) if (x[i] || i == ind) {\n    tmpx[v[i].x]++;\n    tmpy[v[i].y]++;\n  }\n  int sx = 0;\n  for (int i = 0; i < 100; ++i) {\n    sx += tmpx[i];\n    if (sx > dx[i]) return false;\n  }\n  sx = 0;\n  for (int i = 99; i >= 0; --i) {\n    sx += tmpx[i];\n    if (sx > ux[i]) return false;\n  }\n  int sy = 0;\n  for (int i = 0; i < 100; ++i) {\n    sy += tmpy[i];\n    if (sy > dy[i]) return false;\n  }\n  sy = 0;\n  for (int i = 99; i >= 0; --i) {\n    sy += tmpy[i];\n    if (sy > uy[i]) return false;\n  }\n  return true;\n}\n\nvoid f(vi x) {\n  ll score = eval(x);\n  for (int t = 0; t < 10; ++t) {\n    ll s0 = score;\n    for (int i = 0; i < x.size(); ++i) {\n      vi y = x;\n      y[i] = 0;\n      if (t % 2) {\n        for (int j = 0; j < x.size(); ++j) if (j != i) {\n          if (valid_add(j, y)) {\n            y[j] = 1;\n          }\n        }\n      } else {\n        for (int j = x.size() - 1; j >= 0; --j) if (j != i) {\n          if (valid_add(j, y)) {\n            y[j] = 1;\n          }\n        }\n      }\n      ll cand = eval(y);\n      if (cand > score) {\n        score = cand;\n        x = y;\n      }\n    }\n    if (score == s0) break;\n  }\n  update(x);\n}\n\nvoid greedy(int type) {\n  vector<J> ts = v;\n  if (type == 0) {\n    sort(ts.rbegin(), ts.rend(), [&](const auto& a, const auto& b){return a.cost < b.cost;});\n  } else {\n    vd mulx(v.size(), 1e-10), muly(v.size(), 1e-10);\n    vd mul(v.size());\n    for (int i = 0; i < v.size(); ++i) {\n      for (int x = v[i].x; x < 100; ++x) if (ux[x] != 100) {\n        mulx[i] += 1. / ux[x];\n      }\n      for (int x = 0; x <= v[i].x; ++x) if (dx[x] != 100) {\n        mulx[i] += 1. / dx[x];\n      }\n      for (int y = v[i].y; y < 100; ++y) if (uy[y] != 100) {\n        muly[i] += 1. / uy[y];\n      }\n      for (int y = 0; y <= v[i].y; ++y) if (dy[y] != 100) {\n        muly[i] += 1. / dy[y];\n      }\n      if (type == 1) {\n        mul[i] = 1. / (mulx[i] + muly[i]);\n      } else if (type == 2) {\n        mul[i] = 1. / (mulx[i]);\n      } else if (type == 3) {\n        mul[i] = 1. / (muly[i]);\n      } else if (type == 5) {\n        mul[i] = 1. / sqrt(mulx[i] + muly[i]);\n      }\n    }\n    sort(ts.rbegin(), ts.rend(), [&](const auto& a, const auto& b){return a.cost * mul[a.ind] < b.cost * mul[b.ind];});\n  }\n  vi x(v.size());\n  for (int i = 0; i < ts.size(); ++i) {\n    int ind = ts[i].ind;\n    if (valid_add(ind, x)) {\n//      cerr << ind << endl;\n      x[ind] = 1;\n    }\n  }\n  f(x);\n//  update(x);\n}\n\nint main() {\n  std::ios::sync_with_stdio(false); std::cin.tie(0);\n  int n;\n  cin >> n;\n  v.resize(n);\n  for (int i = 0; i < n; ++i) {\n    cin >> v[i].x >> v[i].y >> v[i].cost;\n    --v[i].x; --v[i].y;\n    v[i].ind = i;\n  }\n  int m;\n  cin >> m;\n  for (int i = 0; i < m; ++i) {\n    string t;\n    int a, b;\n    cin >> t >> a >> b;\n    --a;\n    if (t == \"L\") {\n      dx[a] = b;\n    }\n    if (t == \"R\") {\n      ux[a] = b;\n    }\n    if (t == \"D\") {\n      dy[a] = b;\n    }\n    if (t == \"U\") {\n      uy[a] = b;\n    }\n  }\n  for (int t = 0; t < 6; ++t) {\n    greedy(t);\n  }\n  cout << best_score << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define I inline\n#define fi first\n#define se second\n#define R register\n#define LL long long\n#define mp make_pair\n#define reg register int\n#define pii pair<int,int>\n#define fo(i, a, b) for(reg i = a; i <= b; i++)\n#define fd(i, a, b) for(reg i = a; i >= b; i--)\n#define cr const reg&\nusing namespace std;\nconst int inf = 2147483647;\nconst int N = 81, M = 101, K = 321;\nconst int H = 2 * (M + N);\n\nI int _max(cr x, cr y) {return x > y ? x : y;}\nI int _min(cr x, cr y) {return x < y ? x : y;}\nI LL read() {\n\tLL x = 0, f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') x = (x << 3) + (x << 1) + (ch ^ 48), ch = getchar();\n\treturn x * f;\n}\nI void ptt(LL x) {if(x >= 10) ptt(x / 10); putchar(x % 10 + '0');}\nI void put(LL x) {x < 0 ? putchar('-'), ptt(-x) : ptt(x);}\nI void pr1(LL x) {put(x), putchar(' ');}\nI void pr2(LL x) {put(x), puts(\"\");}\n\nstruct edge {\n\tint x, y, c; LL d; int next;\n} e[1000001]; int len, last[H];\nstruct node {int x, y; LL t;} a[K], b[N];\nint lx[101], rx[101], ly[101], ry[101];\nint st, ed, pre[H]; LL d[H];\nint n, m; LL ans;\nqueue<int> q;\nchar ss[10];\nbool v[H];\n\nI void ins(cr x, cr y, cr c, LL d) {\n\te[++len] = edge{x, y, c, d, last[x]}, last[x] = len;\n\te[++len] = edge{y, x, 0, -d, last[y]}, last[y] = len;\n}\n\nI bool spfa() {\n\tq.push(st);\n\tmemset(v, 0, sizeof(v)); v[st] = 1;\n\tmemset(d, 63, sizeof(d)); d[st] = 0;\n\twhile(!q.empty()) {\n\t\treg x = q.front(); q.pop();\n\t\tfor(reg k = last[x]; k; k = e[k].next) {\n\t\t\treg y = e[k].y;\n\t\t\tif(d[y] > d[x] + e[k].d && e[k].c) {\n\t\t\t\td[y] = d[x] + e[k].d, pre[y] = k;\n\t\t\t\tif(!v[y]) v[y] = 1, q.push(y);\n\t\t\t}\n\t\t} v[x] = 0;\n\t} if(d[ed] < 0) return 1;\n\treturn 0;\n}\n\nI void Flow(cr k) {\n\tLL sum = 0; reg s = 0;\n\twhile(spfa()) {\n\t\tsum += d[ed], s++;\n\t\tfor(reg x = ed; x != st; x = e[pre[x]].x) e[pre[x]].c--, e[pre[x] ^ 1].c++;\n\t} if(k != s) return ;\n\tans = max(ans, -sum);\n}\n\nI void solve(cr k) {\n\tlen = 1, memset(last, 0, sizeof(last));\n\tst = 0, ed = 200 + 2 * k + 1;\n\tfo(i, 1, n) ins(b[i].x, b[i].y + 100, 1, -b[i].t);\n\tfo(i, 1, k) rx[i] = ry[i] = 100, lx[i] = ly[i] = 1;\n\tfo(i, 1, m) {\n\t\tif(a[i].t == 'L') lx[a[i].y + 1] = _max(lx[a[i].y + 1], a[i].x + 1);\n\t\tif(a[i].t == 'R' && k > a[i].y) rx[k - a[i].y] = _min(rx[k - a[i].y], a[i].x - 1);\n\t\tif(a[i].t == 'D') ly[a[i].y + 1] = _max(ly[a[i].y + 1], a[i].x + 1);\n\t\tif(a[i].t == 'U' && k > a[i].y) ry[k - a[i].y] = _min(ry[k - a[i].y], a[i].x - 1);\n\t} fo(i, 2, k) lx[i] = _max(lx[i], lx[i - 1]), ly[i] = _max(ly[i], ly[i - 1]);\n\tfd(i, k - 1, 1) rx[i] = _min(rx[i], rx[i + 1]), ry[i] = _min(ry[i], ry[i + 1]);\n\tfo(i, 1, k) {\n\t\tif(lx[i] > rx[i] || ly[i] > ry[i]) continue;\n\t\tins(st, 200 + i, 1, 0), ins(200 + i + k, ed, 1, 0);\n\t\tfo(j, lx[i], rx[i]) ins(200 + i, j, 1, 0);\n\t\tfo(j, ly[i], ry[i]) ins(j + 100, 200 + i + k, 1, 0);\n\t} Flow(k);\n}\n\nint main() {\n\tn = read();\n\tfo(i, 1, n) b[i].x = read(), b[i].y = read(), b[i].t = read();\n\tm = read();\n\tfo(i, 1, m) scanf(\"%s\", ss + 1), a[i].t = ss[1], a[i].x = read(), a[i].y = read();\n\tfo(i, 1, n) solve(i);\n\tpr2(ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#define M 20000\n#define N 400\nint A[N],B[N],E[N],F[N],G[N],H[N],I[N],J[N],S,T,a[N],b[M],c[M],g[N],i,j,k,l,m,n,q[N],r,t,x;bool d[M],h[N];long long C[N],e[M],f[N],y,z;char D[N];\ninline int add(int u,int v,long long w){b[++t]=a[u],c[a[u]=t]=v,d[t]=true,e[t]=w,b[++t]=a[v],c[a[v]=t]=u,d[t]=false,e[t]=-w;}\nint u;\ninline bool bfs()\n{\n    for(q[l=0]=S,r=1,memset(f+1,0x80,T<<3);l!=r;)for(h[u=q[l++]]=false,i=a[u],l=l==N?0:l;i;i=b[i])if(d[i]&&f[c[i]]<f[u]+e[i])if(f[c[i]]=f[u]+e[g[c[i]]=i],!h[c[i]])h[q[r++]=c[i]]=true,r=r==N?0:r;\n    if(f[T]==0x8080808080808080ll)return false;\n    for(x++,y+=f[i=T];i!=S;i=c[g[i]^1])d[g[i]]=false,d[g[i]^1]=true;\n    return true;\n}\ninline bool solve()\n{\n    t=1,x=y=0,T=n+n+k+k+1,memset(a,0,T<<2);\n    for(i=1;i<=k;i++)G[i]=I[i]=1,H[i]=J[i]=100,add(S,n+n+i,0),add(n+n+k+i,T,0);\n    for(i=1;i<=n;i++)add(i,n+i,C[i]);\n    for(i=1;i<=m;i++)\n    if(D[i]=='L')F[i]<k?G[F[i]+1]=E[i]+1<G[F[i]+1]?G[F[i]+1]:E[i]+1:0;\n    else if(D[i]=='R')F[i]<k?H[k-F[i]]=E[i]-1<H[k-F[i]]?E[i]-1:H[k-F[i]]:0;\n    else if(D[i]=='D')F[i]<k?I[F[i]+1]=E[i]+1<I[F[i]+1]?I[F[i]+1]:E[i]+1:0;\n    else F[i]<k?J[k-F[i]]=E[i]-1<J[k-F[i]]?E[i]-1:J[k-F[i]]:0;\n    for(i=2;i<=k;i++)G[i]=G[i-1]<G[i]?G[i]:G[i-1],I[i]=I[i-1]<I[i]?I[i]:I[i-1];\n    for(i=k;--i;)H[i]=H[i]<H[i+1]?H[i]:H[i+1],J[i]=J[i]<J[i+1]?J[i]:J[i+1];\n    for(i=1;i<=k;i++)for(j=1;j<=n;j++)if(G[i]<=A[j]&&A[j]<=H[i])add(n+n+i,j,0);\n    for(i=1;i<=k;i++)for(j=1;j<=n;j++)if(I[i]<=B[j]&&B[j]<=J[i])add(n+j,n+n+k+i,0);\n    while(bfs());\n    return x==k;\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    for(i=1;i<=n;i++)scanf(\"%d%d%lld\",A+i,B+i,C+i);\n    scanf(\"%d\",&m);\n    for(i=1;i<=m;i++)scanf(\"%s%d%d\",D+i,E+i,F+i);\n    for(k=1;solve();k++)z=y<z?z:y;\n    return 0*printf(\"%lld\\n\",z);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 400 , INF = 0x3f3f3f3f;\nint n,m,x[N],y[N],a[N],b[N],u[N],d[N],l[N],r[N]; char op[N];\nint t(1),Head[N],vis[N],S,T; deque <int> q; ll Delta,dis[N],v[N],Ans;\nstruct Edge { int u,v,next,val; ll cos; } e[N*N*4];\ntemplate<class T> inline T Read(void)\n{\n    T x = 0; bool w = 0; char ch = ' ';\n    while ( !isdigit(ch) ) w |= ch == '-' , ch = getchar();\n    while ( isdigit(ch) ) x = x * 10 + ch - 48 , ch = getchar();\n    return w ? -x : x;\n}\ninline void Input(void)\n{\n    n = Read<int>();\n    for (int i = 1; i <= n; i++)\n        x[i] = Read<int>() , y[i] = Read<int>() , v[i] = Read<ll>();\n    m = Read<int>();\n    for (int i = 1; i <= m; i++)\n    {\n        char c = ' ';\n        while ( isspace(c) ) c = getchar();\n        op[i] = c , a[i] = Read<int>() , b[i] = Read<int>();\n    }\n}\ninline void Insert(int x,int y,ll c,int v)\n{\n    e[++t] = (Edge){ x , y , Head[x] , v , c } , Head[x] = t;\n    e[++t] = (Edge){ y , x , Head[y] , 0 , -c } , Head[y] = t;\n}\ninline void Build(int k)\n{\n    for (int i = 1; i <= k; i++)\n        u[i] = r[i] = INF , l[i] = d[i] = 0;\n    for (int i = 1; i <= m; i++)\n        if ( b[i] < k )\n        {\n            if ( op[i] == 'L' ) l[b[i]+1] = max( l[b[i]+1] , a[i] + 1 );\n            if ( op[i] == 'R' ) r[k-b[i]] = min( r[k-b[i]] , a[i] - 1 );\n            if ( op[i] == 'D' ) d[b[i]+1] = max( d[b[i]+1] , a[i] + 1 );\n            if ( op[i] == 'U' ) u[k-b[i]] = min( u[k-b[i]] , a[i] - 1 );\n            // if ( op[i] == 'L' ) l[b[i]+1] = a[i] + 1;\n            // if ( op[i] == 'R' ) r[k-b[i]] = a[i] - 1;\n            // if ( op[i] == 'D' ) d[b[i]+1] = a[i] + 1;\n            // if ( op[i] == 'U' ) u[k-b[i]] = a[i] - 1;\n        }\n    for (int i = 2; i <= k; i++) l[i] = max( l[i] , l[i-1] ) , d[i] = max( d[i] , d[i-1] );\n    for (int i = k-1; i >= 1; i--) r[i] = min( r[i] , r[i+1] ) , u[i] = min( u[i] , u[i+1] );\n    memset( Head , 0 , sizeof Head );\n    S = ( n + k ) << 1 | 1 , T = ( n + k + 1 ) * 2 , t = 1 , Delta = 0;\n    for (int i = 1; i <= n; i++) Insert( i , i+n , v[i] , 1 );\n    for (int i = 1; i <= k; i++)\n    {\n        Insert( S , n*2+i , 0 , 1 ) , Insert( n*2+k+i , T , 0 , 1 );\n        for (int j = 1; j <= n; j++)\n        {\n            if ( l[i] <= x[j] && x[j] <= r[i] ) Insert( n*2+i , j , 0 , 1 );\n            if ( d[i] <= y[j] && y[j] <= u[i] ) Insert( j+n , n*2+k+i , 0 , 1 );\n        }\n    }\n    // printf( \"t = %d\\n\" , t );\n}\ninline bool Relabel(void)\n{\n    memset( dis , 0xcf , sizeof dis );\n    memset( vis , 0x00 , sizeof vis );\n    dis[T] = 0 , vis[T] = 1 , q.push_back(T);\n    while ( !q.empty() )\n    {\n        // puts(\"SPFAing\");\n        int x = q.front(); q.pop_front() , vis[x] = 0;\n        if ( q.size() > 1 && dis[q.front()] < dis[q.back()] )\n            swap( q.front() , q.back() );\n        for (int i = Head[x] , y; i; i = e[i].next)\n            if ( e[i^1].val && dis[ y = e[i].v ] < dis[x] + e[i^1].cos )\n            {\n                dis[y] = dis[x] + e[i^1].cos;\n                // printf( \"dis[%d] = %lld\\n\" , y , dis[y] );\n                if ( vis[y] ) continue;\n                vis[y] = true , q.push_back(y);\n                if ( q.size() > 1 && dis[q.front()] < dis[q.back()] )\n                    swap( q.front() , q.back() );\n            }\n    }\n    // printf( \"d[%d] = %lld\\n\" , S , dis[S] );\n    return dis[S] != dis[0];\n}\ninline int Dinic(int x,int flow)\n{\n    if ( x == T || !flow ) return flow;\n    int residue = flow; vis[x] = true;\n    for (int i = Head[x] , y; i; i = e[i].next)\n        if ( e[i].val && !vis[ y = e[i].v ] && !e[i].cos )\n        {\n            int k = Dinic( y , min( e[i].val , residue ) );\n            e[i].val -= k , e[i^1].val += k;\n            if ( ( residue -= k ) == 0 ) break;\n        }\n    return flow - residue;\n}\ninline pair<int,ll> PrimalDual(void)\n{\n    int Maxflow = 0 , Flow = 0; ll Maxcost = 0;\n    while ( Relabel() )\n    {\n        for (int i = 2; i <= t; i++)\n            e[i].cos += dis[e[i].v] - dis[e[i].u];\n        Delta += dis[S] , memset( vis , 0 , sizeof vis );\n        // printf( \"Delta = %lld\\n\" , Delta );\n        while ( Flow = Dinic( S , INF ) )\n            Maxflow += Flow , Maxcost += 1LL * Flow * Delta ,\n            memset( vis , 0 , sizeof vis ) /*, printf( \"Dinicing Flow = %d\\n\" , Flow ) */;\n    }\n    return make_pair( Maxflow , Maxcost );\n}\nint main(void)\n{\n    Input();\n    for (int i = 1; i <= n; i++)\n        Build(i) , Ans = max( Ans , PrimalDual().second );\n    printf( \"%lld\\n\" , Ans );\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\ntemplate<typename T>\nstruct PrimalDual{\n  struct edge{\n    Int to;\n    T cap,cost;\n    Int rev;\n    edge(){}\n    edge(Int to,T cap,T cost,Int rev):to(to),cap(cap),cost(cost),rev(rev){}\n  };\n  \n  T INF;\n  vector<vector<edge> > G;\n  vector<T> h,dist;\n  vector<Int> prevv,preve;\n\n  PrimalDual(){}\n  PrimalDual(Int n,T INF):INF(INF),G(n),h(n),dist(n),prevv(n),preve(n){}\n  \n  void add_edge(Int from,Int to,T cap,T cost){\n    G[from].emplace_back(to,cap,cost,G[to].size());\n    G[to].emplace_back(from,0,-cost,G[from].size()-1);\n  }\n\n  T flow(Int s,Int t,T f,Int &ok){    \n    T res=0;\n    fill(h.begin(),h.end(),0);\n    while(f>0){\n      using P = pair<T, Int>;\n      priority_queue<P,vector<P>,greater<P> > que;\n      fill(dist.begin(),dist.end(),INF);\n      \n      dist[s]=0;\n      que.emplace(dist[s],s);\n      while(!que.empty()){\n        P p=que.top();que.pop();\n        Int v=p.second;\n        if(dist[v]<p.first) continue;\n        for(Int i=0;i<(Int)G[v].size();i++){\n          edge &e=G[v][i];\n          if(e.cap==0) continue;\n          if(dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n            dist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n            prevv[e.to]=v;\n            preve[e.to]=i;\n            que.emplace(dist[e.to],e.to);\n          }\n        }\n      }\n      if(dist[t]==INF) return ok=0;\n      \n      for(Int v=0;v<(Int)h.size();v++) h[v]+=dist[v];\n\n      T d=f;\n      for(Int v=t;v!=s;v=prevv[v])\n        d=min(d,G[prevv[v]][preve[v]].cap);\n      \n      f-=d;\n      res+=d*h[t];\n      for(Int v=t;v!=s;v=prevv[v]){\n        edge &e=G[prevv[v]][preve[v]];\n        e.cap-=d;\n        G[v][e.rev].cap+=d;\n      }\n    }\n    ok=1;\n    return res;\n  }\n};\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<Int> xs(n),ys(n),vs(n);\n  for(Int i=0;i<n;i++) cin>>xs[i]>>ys[i]>>vs[i];\n\n  Int m;\n  cin>>m;\n  vector<char> ts(m);\n  vector<Int> as(m),bs(m);\n  for(Int i=0;i<m;i++) cin>>ts[i]>>as[i]>>bs[i];\n\n  const Int INF = 1e16;\n  vector<Int> ls(n,-INF),rs(n,INF),ds(n,-INF),us(n,INF);\n  for(Int i=0;i<m;i++){\n    if(ts[i]=='L') chmax(ls[bs[i]],as[i]);\n    if(ts[i]=='R') chmin(rs[bs[i]],as[i]);\n    if(ts[i]=='D') chmax(ds[bs[i]],as[i]);\n    if(ts[i]=='U') chmin(us[bs[i]],as[i]);\n  }\n  for(Int i=0;i+1<n;i++){\n    chmax(ls[i+1],ls[i]);\n    chmin(rs[i+1],rs[i]);\n    chmax(ds[i+1],ds[i]);\n    chmin(us[i+1],us[i]);\n  }\n  \n  Int ans=0;\n  for(Int k=1;k<=n;k++){\n    PrimalDual<Int> G(k*2+n*2+2,INF);\n    Int S=k*2+n*2,T=k*2+n*2+1;\n    for(Int i=0;i<k;i++){\n      G.add_edge(S,i,1,0);\n      G.add_edge(k+i,T,1,0);\n    }    \n    \n    for(Int p=0;p<n;p++){\n      G.add_edge(k*2+p,k*2+n+p,1,INF-vs[p]);      \n      for(Int i=0;i<k;i++){\n        for(Int j=0;j<k;j++){\n          if(xs[p]<=ls[i]) continue;\n          if(xs[p]>=rs[k-(i+1)]) continue;\n          if(ys[p]<=ds[j]) continue;\n          if(ys[p]>=us[k-(j+1)]) continue;          \n          G.add_edge(i,k*2+p,1,0);     \n          G.add_edge(k*2+n+p,k+j,1,0);\n        }\n      }\n    }\n    \n    Int ok=1;\n    Int res=G.flow(S,T,k,ok);    \n    if(!ok) break;\n    chmax(ans,INF*k-res);\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// luogu-judger-enable-o2\n#include<bits/stdc++.h>\n#define ll long long\n#define uint unsigned\n#define ull unsigned ll\n#define db double\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pli pair<ll,int>\n#define vi vector<int>\n#define vpi vector<pii >\n#define IT iterator\n \n#define PB push_back\n#define MK make_pair\n#define LB lower_bound\n#define UB upper_bound\n#define y1 wzpakking\n#define fi first\n#define se second\n#define BG begin\n#define ED end\n \n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a))\n#define CPY(a,b) memcpy(a,b,sizeof(a))\n#define sqr(x) (1ll*x*x)\n \n#define LS3 k*2,l,mid\n#define RS3 k*2+1,mid+1,r\n#define LS5 k*2,l,mid,x,y\n#define RS5 k*2+1,mid+1,r,x,y\n#define GET pushdown(k);int mid=(l+r)/2\n#define inf (1<<30)\nusing namespace std;\nconst int N=1000;\nstruct edge{\n\tint from,to,next,f;\n\tll v;\n}e[N*N];\nint head[N],tot;\nint nd,S,T,idx[N],idy[N];\nvoid add(int x,int y,int f,ll v){\n\te[++tot]=(edge){x,y,head[x],f,v};\n\thead[x]=tot;\n\te[++tot]=(edge){y,x,head[y],0,-v};\n\thead[y]=tot;\n}\nll dis[N];\nint q[N*N],vis[N],from[N];\nbool bfs(){\n\tFor(i,1,nd) dis[i]=-(1ll<<62),vis[i]=0;\n\tint h=0,t=1;\n\tq[1]=S; dis[S]=0;\n\twhile (h!=t){\n\t\tint x=q[++h]; vis[x]=1;\n\t\tfor (int i=head[x];i;i=e[i].next)\n\t\t\tif (dis[e[i].to]<dis[x]+e[i].v&&e[i].f){\n\t\t\t\tdis[e[i].to]=dis[x]+e[i].v;\n\t\t\t\tfrom[e[i].to]=i;\n\t\t\t\tif (!vis[e[i].to]){\n\t\t\t\t\tvis[e[i].to]=1;\n\t\t\t\t\tq[++t]=e[i].to;\n\t\t\t\t}\n\t\t\t}\n\t}\n\treturn dis[T]!=-(1ll<<62);\n}\nvoid del(){\n\tfor (int i=from[T];i;i=from[e[i].from])\n\t\te[i].f--,e[i^1].f++;\n}\nstruct que{\n\tchar s[10];\n\tint x,cnt;\n}qq[N];\nint n,Q;\nint x[N],y[N];\nint mn[N],mx[N];\nll v[N];\nconst int MX=100;\nll work(int cnt){\n\tnd=0; S=++nd; T=++nd; tot=1;\n\tmemset(head,0,sizeof(head));\n\tFor(i,1,MX) idx[i]=++nd,idy[i]=++nd;\n\tFor(i,1,n) add(idx[x[i]],idy[y[i]],1,v[i]);\n\t{\n\t\tFor(i,0,cnt+1) mx[i]=MX,mn[i]=1;\n\t\tFor(i,1,Q){\n\t\t\tif (qq[i].s[0]=='L'&&cnt>=qq[i].cnt+1)\n\t\t\t\tmn[qq[i].cnt+1]=max(mn[qq[i].cnt+1],qq[i].x+1);\n\t\t\tif (qq[i].s[0]=='R'&&cnt>=qq[i].cnt+1)\n\t\t\t\tmx[cnt-qq[i].cnt]=min(mx[cnt-qq[i].cnt],qq[i].x-1);\n\t\t}\n\t\tFor(i,1,cnt) mn[i]=max(mn[i],mn[i-1]);\n\t\tRep(i,cnt,1) mx[i]=min(mx[i],mx[i+1]);\n\t\tFor(i,1,cnt){\n\t\t\tint tmp=++nd;\n\t\t\tif (mn[i]>mx[i]) return 0;\n\t\t\tadd(S,tmp,1,0);\n\t\t\tFor(j,mn[i],mx[i])\n\t\t\t\tadd(tmp,idx[j],1,0);\n\t\t}\n\t}\n\t{\n\t\tFor(i,0,cnt+1) mx[i]=MX,mn[i]=1;\n\t\tFor(i,1,Q){\n\t\t\tif (qq[i].s[0]=='D'&&cnt>=qq[i].cnt+1)\n\t\t\t\tmn[qq[i].cnt+1]=max(mn[qq[i].cnt+1],qq[i].x+1);\n\t\t\tif (qq[i].s[0]=='U'&&cnt>=qq[i].cnt+1)\n\t\t\t\tmx[cnt-qq[i].cnt]=min(mx[cnt-qq[i].cnt],qq[i].x-1);\n\t\t}\n\t\tFor(i,1,cnt) mn[i]=max(mn[i],mn[i-1]);\n\t\tRep(i,cnt,1) mx[i]=min(mx[i],mx[i+1]);\n\t\tFor(i,1,cnt){\n\t\t\tint tmp=++nd;\n\t\t\tif (mn[i]>mx[i]) return 0;\n\t\t\tadd(tmp,T,1,0);\n\t\t\tFor(j,mn[i],mx[i])\n\t\t\t\tadd(idy[j],tmp,1,0);\n\t\t}\n\t}//buildy\n\tll ans=0;\n\tFor(i,1,cnt){\n\t\tif (!bfs()) return 0;\n\t\tans+=dis[T]; del();\n\t}\n\treturn ans;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tFor(i,1,n) scanf(\"%d%d%lld\",&x[i],&y[i],&v[i]);\n\tscanf(\"%d\",&Q);\n\tFor(i,1,Q) scanf(\"%s%d%d\",qq[i].s,&qq[i].x,&qq[i].cnt);\n\tll ans=0;\n\tFor(i,1,n) ans=max(ans,work(i));\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n#define LL long long\nconst int inf=2147483647;\nint read(){\n\tint x=0,f=1;\n\tchar ch=getchar();\n\twhile (ch<'0' || ch>'9'){\n\t\tif (ch=='-') f=-1;\n\t\tch=getchar();\n\t}\n\twhile (ch>='0' && ch<='9'){\n\t\tx=x*10+ch-'0';ch=getchar();\n\t}\n\treturn x*f;\n}\n#define N 450\n#define M 100010\n#define G 85\n#define Q 325\nstruct edge{\n\tint x,y,d,nxt;LL c;\n}E[M];\nchar op[3];\nstruct pt{\n\tint x,y;LL v;\n}p[G];\nstruct query{\n\tint op,a,b;\n}q[Q];\nint ec[N],tot;\nvoid addE(int x,int y,int d,LL c){\n\ttot++;E[tot].x=x;E[tot].y=y;E[tot].d=d;E[tot].c=c;E[tot].nxt=ec[x];ec[x]=tot;\n}\nvoid addEdge(int x,int y,int d,LL c){\n\taddE(x,y,d,c);addE(y,x,0,-c);\n}\nint n,m,S,T;\nLL f[N];int pre[N];bool vis[N];\nbool spfa(){\n\tmemset(f,-63,sizeof(f));f[S]=0;\n\tmemset(vis,0,sizeof(vis));\n\tqueue <int> q;q.push(S);\n\twhile (!q.empty()){\n\t\tint x=q.front();q.pop();vis[x]=false;\n\t\tfor (int i=ec[x];i;i=E[i].nxt){\n\t\t\tint y=E[i].y;\n\t\t\tif (E[i].d>0 && f[x]+E[i].c>f[y]){\n\t\t\t\tpre[y]=i;f[y]=f[x]+E[i].c;\n\t\t\t\tif (!vis[y]) vis[y]=true,q.push(y);\n\t\t\t} \n\t\t}\n\t}\n\tif (f[T]>0) return true;\n\telse return false;\n}\nLL ans2,ans=0;\nvoid work(){\n\tint x=T;\n\twhile (x!=S){\n\t\tans2+=E[pre[x]].c;\n\t\tE[pre[x]].d--;E[pre[x]^1].d++;x=E[pre[x]].x;\n\t}\n}\nint lx[G],rx[G],ly[G],ry[G];\nvoid solve(int k){\n\tmemset(ec,0,sizeof(ec));tot=1;\n\tfor (int i=1;i<=n;++i) addEdge(p[i].x,200+i,1,p[i].v),addEdge(200+i,100+p[i].y,1,0);\n\tfor (int i=1;i<=k;++i) lx[i]=ly[i]=1,rx[i]=ry[i]=100;\n\tfor (int i=1;i<=m;++i){\n\t\tif (q[i].op==0) lx[q[i].b+1]=max(lx[q[i].b+1],q[i].a+1);\n\t\tif (q[i].op==1 && k>q[i].b) rx[k-q[i].b]=min(rx[k-q[i].b],q[i].a-1);\n\t\tif (q[i].op==2) ly[q[i].b+1]=max(ly[q[i].b+1],q[i].a+1);\n\t\tif (q[i].op==3 && k>q[i].b) ry[k-q[i].b]=min(ry[k-q[i].b],q[i].a-1);\n\t}\n\tfor (int i=2;i<=k;++i) lx[i]=max(lx[i],lx[i-1]),ly[i]=max(ly[i],ly[i-1]);\n\tfor (int i=k-1;i;--i) rx[i]=min(rx[i],rx[i+1]),ry[i]=min(ry[i],ry[i+1]);\n\tS=200+n+2*k+1,T=S+1;\n\tfor (int i=1;i<=k;++i){\n\t\tif (lx[i]>rx[i] || ly[i]>ry[i]) return;\n\t\taddEdge(S,200+n+i,1,0);addEdge(200+n+k+i,T,1,0);\n\t\tfor (int j=lx[i];j<=rx[i];++j) addEdge(200+n+i,j,1,0);\n\t\tfor (int j=ly[i];j<=ry[i];++j) addEdge(100+j,200+n+k+i,1,0);\n\t}\n\tint cnt=0;ans2=0;\n\twhile (spfa()) cnt++,work();\n\tif (cnt!=k) return;\n\tans=max(ans,ans2);\n}\nsigned main(){\n\tn=read();for (int i=1;i<=n;++i) p[i].x=read(),p[i].y=read(),p[i].v=read();\n\tm=read();\n\tfor (int i=1;i<=m;++i){\n\t\tscanf(\"%s\",op);\n\t\tq[i].a=read();q[i].b=read();\n\t\tif (op[0]=='L') q[i].op=0;\n\t\tif (op[0]=='R') q[i].op=1;\n\t\tif (op[0]=='D') q[i].op=2;\n\t\tif (op[0]=='U') q[i].op=3;\n\t}\t\n\tfor (int i=1;i<=n;++i) solve(i);\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\nconst int INF(0X3F3F3F3F);\ntypedef long long int LL;\n\nnamespace G\n{\n\tconst int Max_V(85 * 2);\n\tconst int Max_E(85 * 10);\n\tint V, S, T, Head[Max_V], Total, To[Max_E], Next[Max_E], Cap[Max_E], Flow[Max_E];\n\tLL Weight[Max_E];\n\tvoid clear()\n\t{\n\t\tfor (int i = 1;i <= V;++i)\n\t\t\tHead[i] = 0;\n\t\tfor (int i = 2;i <= Total + 1;++i)\n\t\t\tTo[i] = Next[i] = Cap[i] = Flow[i] = Weight[i] = 0;\n\t\tV = S = T = Total = 0;\n\t}\n\tinline void Add_Edge(int tot, int s, int t, int c, LL w)\n\t{\n\t\tTo[tot] = t, Next[tot] = Head[s], Head[s] = tot, Cap[tot] = c, Flow[tot] = 0, Weight[tot] = w;\n\t}\n\tinline void Add_Link(int s, int t, int c, LL w)\n\t{\n\t\tTotal += 2, Add_Edge(Total, s, t, c, w), Add_Edge(Total ^ 1, t, s, 0, -w);\n\t}\n\tLL Dist[Max_V];\n\tbool InQ[Max_V], done[Max_V];\n\tbool SPFA()\n\t{\n\t\tqueue<int> Q;\n\t\tmemset(Dist, -0X3F, sizeof(Dist)), Dist[S] = 0LL;\n\t\tmemset(done, false, sizeof(done)), Q.push(S), InQ[S] = true;\n\t\tfor (int u;Q.empty() == false;)\n\t\t{\n\t\t\tu = Q.front(), Q.pop(), InQ[u] = false, done[u] = true;\n\t\t\tfor (int i = Head[u], v;i;i = Next[i])\n\t\t\t\tif (Cap[i] > Flow[i] && Dist[v = To[i]] < Dist[u] + Weight[i])\n\t\t\t\t{\n\t\t\t\t\tDist[v] = Dist[u] + Weight[i];\n\t\t\t\t\tif (!InQ[v])\n\t\t\t\t\t\tQ.push(v), InQ[v] = true;\n\t\t\t\t}\n\t\t}\n\t\treturn done[T];\n\t}\n\tint Cur[Max_V];\n\tint DFS(int u, int a)\n\t{\n\t\tif (u == T || a == 0)\n\t\t\treturn a;\n\t\tint Ans(0);\n\t\tdone[u] = true;\n\t\tfor (int &i = Cur[u], v, f;i;i = Next[i])\n\t\t\tif (Dist[v = To[i]] == Dist[u] + Weight[i] && !done[v] && (f = DFS(v, min(a, Cap[i] - Flow[i]))) > 0)\n\t\t\t{\n\t\t\t\tAns += f, Flow[i] += f, Flow[i ^ 1] -= f;\n\t\t\t\tif ((a -= f) == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\tdone[u] = false;\n\t\treturn Ans;\n\t}\n\tvoid MCMF(int &FLOW, LL &COST)\n\t{\n\t\tfor (int f;SPFA();)\n\t\t{\n\t\t\tfor (int i = 1;i <= V;++i)\n\t\t\t\tCur[i] = Head[i], done[i] = false;\n\t\t\tFLOW -= (f = DFS(S, INF)), COST += Dist[T] * f;\n\t\t}\n\t}\n}\n\nconst int Max_N(85);\nconst int Max_M(325);\n\nint N, X[Max_N], Y[Max_N], PX[Max_N], PY[Max_N], XL[Max_N], XR[Max_N], YL[Max_N], YR[Max_N], M, T[Max_M], A[Max_M], B[Max_M];\nLL V[Max_N], Ans;\n\ninline bool comp_X(int a, int b)\n{\n\treturn X[a] < X[b];\n}\n\ninline bool comp_Y(int a, int b)\n{\n\treturn Y[a] < Y[b];\n}\n\n/*\n枚举选的宝石总数Sum，那么可以变成对于每个前缀选的宝石数量都有一个区间的限制。在X轴和Y轴上分别可以列出方程\nX轴的方程组： \n0 = 0\nX[1] = XV[1]\nX[1] + X[2] = XV[2]\n...\nX[1] + X[2] + ... + X[N] = Sum\nY轴的方程组： \n0 = 0\nY[1] = YV[1]\nY[1] + Y[2] = YV[2]\n...\nY[1] + Y[2] + ... + Y[N] = Sum\n对于每个XV[i]，有XL[i] <= XV[i] <= XR[i]的限制；对于每个YV[i]，有YL[i] <= YV[i] <= YR[i]的限制\n对于每个轴的方程组，两两差分。那么每个XV和YV出现了恰好两次，系数分别是+1和-1。每个X和Y出现了恰好一次\n那么对于点(x, y)，X[x]和Y[y]是同一个变量。所以这些变量可以看做出现了恰好两次，系数分别是+1和-1\n然后用流量平衡建图，可以得到一个最大费用可行流问题 \n*/\nint main()\n{\n\tscanf(\"%d\", &N);\n\tfor (int i = 1;i <= N;++i)\n\t\tscanf(\"%d%d%lld\", X + i, Y + i, V + i), PX[i] = PY[i] = i;\n\tsort(PX + 1, PX + 1 + N, comp_X), sort(PY + 1, PY + 1 + N, comp_Y);\n\tscanf(\"%d\", &M);\n\tfor (int i = 1;i <= M;++i)\n\t{\n\t\tchar op[10];\n\t\tscanf(\"%s%d%d\", op, A + i, B + i);\n\t\tif (*op == 'L')\n\t\t\tT[i] = 1;\n\t\tif (*op == 'R')\n\t\t\tT[i] = 2;\n\t\tif (*op == 'D')\n\t\t\tT[i] = 3;\n\t\tif (*op == 'U')\n\t\t\tT[i] = 4;\n\t}\n\tfor (int Sum = 1;Sum <= N;++Sum)\n\t{\n\t\tXL[0] = YL[0] = XR[0] = YR[0] = 0;\n\t\tfor (int i = 1;i <= N - 1;++i)\n\t\t\tXL[i] = YL[i] = 0, XR[i] = YR[i] = Sum;\n\t\tXL[N] = YL[N] = XR[N] = YR[N];\n\t\tfor (int i = 1;i <= M;++i)\n\t\t{\n\t\t\tif (T[i] == 1)\n\t\t\t\tif (X[PX[1]] <= A[i])\n\t\t\t\t\tfor (int j = 1;j <= N;++j)\n\t\t\t\t\t\tif (j == N || X[PX[j + 1]] > A[i])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tXR[j] = min(XR[j], B[i]);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\tif (T[i] == 2)\n\t\t\t\tif (A[i] <= X[PX[N]])\n\t\t\t\t\tfor (int j = N - 1;j >= 0;--j)\n\t\t\t\t\t\tif (j == 0 || A[i] > X[PX[j]])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tXL[j] = max(XL[j], Sum - B[i]);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\tif (T[i] == 3)\n\t\t\t\tif (Y[PY[1]] <= A[i])\n\t\t\t\t\tfor (int j = 1;j <= N;++j)\n\t\t\t\t\t\tif (j == N || Y[PY[j + 1]] > A[i])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tYR[j] = min(YR[j], B[i]);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\tif (T[i] == 4)\n\t\t\t\tif (A[i] <= Y[PY[N]])\n\t\t\t\t\tfor (int j = N - 1;j >= 0;--j)\n\t\t\t\t\t\tif (j == 0 || A[i] > Y[PY[j]])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tYL[j] = max(YL[j], Sum - B[i]);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t}\n\t\tfor (int i = 0;i <= N;++i)\n\t\t\tif (XL[i] > XR[i] || YL[i] > YR[i])\n\t\t\t\tgoto loop;\n\t\tint FLOW(0);\n\t\tLL COST(0LL);\n\t\tG::clear(), G::V = N + N + 2, G::S = N + N + 1, G::T = N + N + 2;\n\t\tfor (int i = 1, x, y;i <= N;++i)\n\t\t{\n\t\t\tfor (x = 1;x <= N;++x)\n\t\t\t\tif (PX[x] == i)\n\t\t\t\t\tbreak;\n\t\t\tfor (y = 1;y <= N;++y)\n\t\t\t\tif (PY[y] == i)\n\t\t\t\t\tbreak;\n\t\t\tCOST += V[i], ++FLOW, G::Add_Link(G::S, x, 1, 0LL), G::Add_Link(N + y, G::T, 1, 0LL);\n\t\t\tG::Add_Link(x, N + y, 1, -V[i]);\n\t\t}\n\t\tfor (int i = 1;i <= N - 1;++i)\n\t\t{\n\t\t\tif (XL[i])\n\t\t\t\tG::Add_Link(G::S, i + 1, XL[i], 0LL), G::Add_Link(i, G::T, XL[i], 0LL), FLOW += XL[i];\n\t\t\tif (XR[i] - XL[i])\n\t\t\t\tG::Add_Link(i, i + 1, XR[i] - XL[i], 0LL);\n\t\t}\n\t\tfor (int i = 1;i <= N - 1;++i)\n\t\t{\n\t\t\tif (YL[i])\n\t\t\t\tG::Add_Link(G::S, N + i, YL[i], 0LL), G::Add_Link(N + (i + 1), G::T, YL[i], 0LL), FLOW += YL[i];\n\t\t\tif (YR[i] - YL[i])\n\t\t\t\tG::Add_Link(N + (i + 1), N + i, YR[i] - YL[i], 0LL);\n\t\t}\n\t\tFLOW += Sum, G::Add_Link(N, G::T, Sum, 0LL), G::Add_Link(G::S, N + N, Sum, 0LL);\n\t\tG::MCMF(FLOW, COST);\n\t\tif (FLOW)\n\t\t\tgoto loop;\n\t\tAns = max(Ans, COST);\n\t}\n\tloop :\n\tprintf(\"%lld\", Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<stack>\n#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\nstruct MinCostMaxFlow {\n    typedef LL Flow;\n    typedef LL Cost;\n    static const Flow FLOW_INF = 1LL<<60;\n    static const Cost COST_INF = 1LL<<60;\n    struct Edge {\n\tint src, dst;\n\tCost cst;\n\tFlow cap;\n\tint rev;\n\tbool operator<(const Edge&y) const {\n\t    return cst > y.cst;\n\t}\n    };\n    typedef vector<vector<Edge> > Graph;\n    Graph G;\n    MinCostMaxFlow(int N) : G(N) {}\n    // directed\n    void add_edge(int u, int v, Cost x, Flow f) {\n\tG[u].push_back((Edge){ u, v, x, f, (int)G[v].size() });\n\tG[v].push_back((Edge){ v, u, -x, 0, (int)G[u].size()-1 });\n    }\n\n    Flow flow;\n    Cost cost;\n    Flow solve(int s, int t, Flow limit = FLOW_INF) {\n\tflow = 0;\n\tcost = 0;\n\tvector<Cost>len, h(G.size(), 0);\n\tvector<int> prev, prev_num;\n\twhile (limit > 0) {\n\t    priority_queue<Edge> Q;\n\t    Q.push((Edge){-2, s, 0, 0, 0});\n\t    len.assign(G.size(), COST_INF);\n\t    prev.assign(G.size(), -1); prev_num.assign(G.size(), -1);\n\t    len[s] = 0;\n\t    while (!Q.empty()) {\n\t\tEdge e = Q.top(); Q.pop();\n\t\tif (e.cst > len[e.dst]) continue;\n\t\tif (e.dst == t) break;\n\t\tfor (int i=0; i<(int)G[e.dst].size(); i++) {\n\t\t    const Edge &f = G[e.dst][i];\n\t\t    if (f.cap > 0 && len[f.dst] > len[f.src] + f.cst + h[f.src] - h[f.dst]) {\n\t\t\tlen[f.dst] = len[f.src] + f.cst + h[f.src] - h[f.dst];\n\t\t\tQ.push((Edge){ f.src, f.dst, len[f.dst], 0, 0 });\n\t\t\tprev[f.dst] = f.src; prev_num[f.dst] = i;\n\t\t    }\n\t\t}\n\t    }\n\t    if (prev[t] == -1) return flow;\n\t    for (int i=0; i<(int)G.size(); i++) h[i] += len[i];\n\t    \n\t    Flow f = limit;\n\t    for (int v=t; v!=s; v=prev[v])\n\t\tf = min(f, G[prev[v]][prev_num[v]].cap);\n\t    for (int v=t; v!=s; v=prev[v]) {\n\t\tEdge &e = G[prev[v]][prev_num[v]];\n\t\te.cap -= f;\n\t\tG[e.dst][e.rev].cap += f;\n\t    }\n\t    limit -= f;\n\t    flow += f;\n\t    cost += f * h[t];\n\t}\n\treturn flow;\n    }\n};\nconst MinCostMaxFlow::Flow MinCostMaxFlow::FLOW_INF;\nconst MinCostMaxFlow::Cost MinCostMaxFlow::COST_INF;\n\nint N;\nint X[88], Y[88];\nLL V[88];\nint M;\nchar T[333];\nint A[333], B[333];\n\nint Llo[88], Lhi[88], Dlo[88], Dhi[88];\nconst LL BASE = 1LL<<50;\nLL calc(int K) {\n    memset(Lhi, 0x3f, sizeof Lhi);\n    memset(Llo, 0xc0, sizeof Llo);\n    memset(Dhi, 0x3f, sizeof Dhi);\n    memset(Dlo, 0xc0, sizeof Dlo);\n    REP (j, M) {\n\tint a = A[j], b = B[j];\n\tif (b < K) {\n\t    if (T[j] == 'L') amax(Llo[b], a);\n\t    if (T[j] == 'R') amin(Lhi[K-b-1], a);\n\t    if (T[j] == 'D') amax(Dlo[b], a);\n\t    if (T[j] == 'U') amin(Dhi[K-b-1], a);\n\t}\n    }\n    REP (i, K-1) {\n\tamax(Llo[i+1], Llo[i]);\n\tamax(Dlo[i+1], Dlo[i]);\n    }\n    for (int i=K-2; i>=0; i--) {\n\tamin(Lhi[i], Lhi[i+1]);\n\tamin(Dhi[i], Dhi[i+1]);\n    }\n//    rprintf(\"%d\", Llo, Llo+K);\n//    rprintf(\"%d\", Lhi, Lhi+K);\n//    rprintf(\"%d\", Dlo, Dlo+K);\n//    rprintf(\"%d\", Dhi, Dhi+K);\n//\n    const int SRC = K*2+N*2, SNK = SRC+1;\n    MinCostMaxFlow G(SNK+1);\n    REP (i, N) {\n\tint left = i+K*2, right = left + N;\n\tG.add_edge(left, right, BASE - V[i], 1);\n\tREP (a, K) {\n\t    if (Llo[a] < X[i] && X[i] < Lhi[a]) {\n\t\tG.add_edge(a, left, 0, 1);\n\t    }\n\t    if (Dlo[a] < Y[i] && Y[i] < Dhi[a]) {\n\t\tG.add_edge(right, a+K, 0, 1);\n\t    }\n\t}\n    }\n    REP (a, K) {\n\tG.add_edge(SRC, a, 0, 1);\n\tG.add_edge(a+K, SNK, 0, 1);\n    }\n    G.solve(SRC, SNK);\n    if (G.flow == K) {\n\treturn K * BASE - G.cost;\n    } else {\n\treturn -1;\n    }\n\n}\n\nvoid MAIN() {\n    scanf(\"%d\", &N);\n    REP (i, N) scanf(\"%d%d%lld\", X+i, Y+i, V+i);\n    scanf(\"%d\", &M);\n    REP (i, M) scanf(\"%s%d%d\", T+i, A+i, B+i);\n\n    \n    LL ans = 0;\n    for (int k=1; k<=N; k++) {\n\tLL tmp = calc(k);\n\tif (tmp == -1) break;\n\tamax(ans, tmp);\n    }\n    \n    printf(\"%lld\\n\", ans);\n\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef HOME\n#define db(x) cerr << #x << \" = \" << x << endl\n#define db3(x, y, z) cerr << \"(\" << #x << \", \" << #y << \", \" << #z << \") = (\" << x << \", \" << y << \", \" << z << \")\" << endl\n#define db2(x, y) cerr << \"(\" << #x << \", \" << #y << \") = (\" << x << \", \" << y << \")\" << endl\n#define dbv(a) cerr << #a << \" = \"; for (auto xxx: a) cerr << xxx  << \" \"; cerr << endl\n#else\n#define db(x) ;\n#define db3(x, y, z) ;\n#define db2(x, y) ;\n#define dbv(a) ;\n#endif\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double dbl;\n\n\nconst int INF = 1.01e9;\nconst int MOD = (int)1e9 + 7;\n\nstruct Item {\n    int x, y;\n    ll val;\n};\n\nstruct Cond {\n    char type;\n    int a, b;\n\n    bool cover(Item it) {\n        if (type == 'L') {\n            return it.x <= a;\n        }\n        if (type == 'R') {\n            return it.x >= a;\n        }\n        if (type == 'D') {\n            return it.y <= a;\n        }\n        if (type == 'U') {\n            return it.y >= a;\n        }\n        assert(0);\n    }\n};\n\nll slow(vector<Item> a, vector<Cond> b) {\n    int n = a.size(), m = b.size();\n    ll ans = 0;\n    for (int mask = 0; mask < (1 << n); mask++) {\n        vector<int> cnt(m);\n        ll sum = 0;\n        for (int i = 0; i < n; i++) {\n            if (!(mask & (1 << i))) continue;\n            sum += a[i].val;\n            for (int j = 0; j < m; j++) {\n                if (b[j].cover(a[i])) {\n                    cnt[j]++;\n                }\n            }\n        }\n        bool bad = 0;\n        for (int i = 0; i < m; i++) {\n            if (cnt[i] > b[i].b) {\n                bad = 1;\n            }\n        }\n        if (bad) continue;\n        ans = max(ans, sum);\n    }\n    return ans;\n}\n\n\nbool eq(dbl a, dbl b) {\n    return fabs(a - b) < 1e-9;\n}\n\nbool ls(dbl a, dbl b) {\n    return !eq(a, b) && a < b;\n}\n\nvector<dbl> simplex(vector<vector<dbl> > a) {\n    int n = a.size() - 1;\n    int m = a[0].size() - 1;\n    vector<int> left(n + 1), up(m + 1);\n    iota(up.begin(), up.end(), 0);\n    iota(left.begin(), left.end(), m);\n    auto pivot = [&](int x, int y) {\n        swap(left[x], up[y]);\n        dbl k = a[x][y];\n        a[x][y] = 1;\n        vector<int> vct;\n        for (int j = 0; j <= m; j++) {\n            a[x][j] /= k;\n            if (!eq(a[x][j], 0)) vct.push_back(j);\n        }\n        for (int i = 0; i <= n; i++) {\n            if (eq(a[i][y], 0) || i == x) continue;\n            k = a[i][y];\n            a[i][y] = 0;\n            for (int j : vct) a[i][j] -= k * a[x][j];\n        }\n    };\n    while (1) {\n        int x = -1;\n        for (int i = 1; i <= n; i++) if (ls(a[i][0], 0) && (x == -1 || a[i][0] < a[x][0])) x = i;\n        if (x == -1) break;\n        int y = -1;\n        for (int j = 1; j <= m; j++) if (ls(a[x][j], 0) && (y == -1 || a[x][j] < a[x][y])) y = j;\n        if (y == -1) return vector<dbl>(m + 1, 0);\n        pivot(x, y);\n    }\n    while (1) {\n        int y = -1;\n        for (int j = 1; j <= m; j++) if (ls(0, a[0][j]) && (y == -1 || a[0][j] > a[0][y])) y = j;\n        if (y == -1) break;\n        int x = -1;\n        for (int i = 1; i <= n; i++) if (ls(0, a[i][y]) && (x == -1 || a[i][0] / a[i][y] < a[x][0] / a[x][y])) x = i;\n        if (x == -1) assert(0); // unbounded\n        pivot(x, y);\n    }\n    vector<dbl> ans(m + 1);\n    for (int i = 1; i <= n; i++) if (left[i] <= m) ans[left[i]] = a[i][0];\n    ans[0] = -a[0][0];\n    return ans;\n}\n// j=1..m: x[j]>=0\n// i=1..n: sum(j=1..m) A[i][j]*x[j] <= A[i][0]\n// max sum(j=1..m) A[0][j]*x[j]\n// res[0] is answer\n// res[1..m] is certificate\n\nll fast(vector<Item> a, vector<Cond> b) {\n    int n = a.size(), m = b.size();\n    vector<vector<dbl>> c(m + 1, vector<dbl>(n + 1));\n    for (int i = 0; i < n; i++) {\n        c[0][1 + i] = a[i].val;\n    }\n    for (int i = 0; i < m; i++) {\n        c[1 + i][0] = b[i].b;\n        for (int j = 0; j < n; j++) {\n            if (b[i].cover(a[j])) {\n                c[1 + i][1 + j] = 1;\n            }\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        vector<dbl> cur(n + 1);\n        cur[0] = 1;\n        cur[1 + i] = 1;\n        c.push_back(cur);\n    }\n    ll res = 0;\n    for (int cnt = 1; cnt <= n; cnt++) {\n        auto cc = c;\n        vector<dbl> cur(n + 1, 1);\n        cur[0] = cnt;\n        cc.push_back(cur);\n        for (auto &x : cur) x *= -1;\n        cc.push_back(cur);\n        res = max(res, (ll)round(simplex(cc)[0]));\n    }\n    return res;\n}\n\nvoid stress() {\n    for (int it =0;; it++) {\n        mt19937_64 rnd(it);\n        db(it);\n\n\n        int n = rnd() % 10 + 1;\n        vector<Item> a(n);\n        for (int i =0 ; i < n; i++) {\n            a[i].x = rnd() % 100;\n            a[i].y = rnd() % 100;\n            a[i].val = rnd() % (ll)1e15;\n        }\n        int m = rnd() % 10 + 1;\n        vector<Cond> b(m);\n        for (int i = 0; i < m; i++) {\n            b[i].a = rnd() % 100;\n            b[i].b = rnd() % (n + 1);\n            b[i].type = \"ULDR\"[rnd() % 4];\n        }\n\n        auto ans1 = fast(a, b);\n        auto ans2 = slow(a, b);\n        if (ans1 != ans2) {\n            cout << ans1 << \" instead of \" << ans2 << endl;\n            exit(0);\n        }\n    }\n}\n\nint main() {\n#ifdef HOME\n    assert(freopen(\"in\", \"r\", stdin));\n#endif\n//    stress();\n\n    int n;\n    while (scanf(\"%d\", &n) == 1) {\n        vector<Item> a(n);\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d%d%lld\", &a[i].x, &a[i].y, &a[i].val);\n        }\n        int m;\n        scanf(\"%d\", &m);\n        vector<Cond> b(m);\n        for (int i = 0; i < m; i++) {\n            scanf(\" %c%d%d\", &b[i].type, &b[i].a, &b[i].b);\n        }\n\n//        printf(\"%lld\\n\", slow(a, b));\n        printf(\"%lld\\n\", fast(a, b));\n    }\n\n#ifdef HOME\n    cerr << \"time: \" << clock() * 1.0 / CLOCKS_PER_SEC << endl;\n#endif\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ri register int\ntypedef long long ll;\n#define rll register ll\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\t// input a signed integer\n\ttemplate <class I>\n\tinline void gi (I &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = (x << 1) + (x << 3) + (c & 15); x *= f;\n\t}\n\t// input a letter\n\ttemplate <class I>\n\tinline void get (I &x) {\n\t\tfor (c = gc(); c < 'A' || c > 'Z'; c = gc()) ;\n\t\tx = c;\n\t}\n\t// print a signed integer\n\ttemplate <class I>\n\tinline void print (I x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t}\n\t//no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io :: gi;\nusing io :: get;\nusing io :: putc;\nusing io :: print;\nconst int N=85,M=105,inf=2e9,L=325;\nconst ll INF=1e8;\nint flag,x0[N],y0[N],lx[M],rx[M],ly[M],ry[M];\nll v0[N];\nstruct node{\n\tchar op;\n\tint a,b;\n}q[L];\ninline void chmin(int &x,ri y){\n\tx=min(x,y);\n}\ninline void chmax(int &x,ri y){\n\tx=max(x,y);\n}\nnamespace G{\n\tconst int _N=(M<<1)+N,_M=(M<<1)+(N<<1); \n\tconst ll INF=1e18;\n\tint size,s,t,m,a[_M],b[_M],c[_M],d[_M],deg[_N],\n\ttot=1,head[_N],nxt[_M<<2],adj[_M<<2],cap[_M<<2],q[_M<<5],S,T,flow,sum,vis[_N],cur[_N];\n\tll cost,dis[_N],val[_M<<2],e[_M];\n\tinline void addedge(ri x,ri y,ri c,rll w){\n\t\tnxt[++tot]=head[x];\n\t\tadj[head[x]=tot]=y;\n\t\tcap[tot]=c;\n\t\tval[tot]=w;\n\t}\n\tinline void Add(ri x,ri y,ri c,rll v){\n\t\taddedge(x,y,c,v);\n\t\taddedge(y,x,0,-v);\n\t}\n\tinline void add(ri x,ri y,ri lower,ri upper,rll cost){\n\t\tif(lower>upper) flag=0;\n\t\t++m;\n\t\ta[m]=x;\n\t\tb[m]=y;\n\t\tc[m]=lower;\n\t\td[m]=upper;\n\t\te[m]=cost;\n\t}\n\tinline void build(){\n\t\tri i;\n\t\tcost=0;\n\t\tfor(i=1;i<=m;++i)\n\t\t\tdeg[a[i]]-=c[i],\n\t\t\tdeg[b[i]]+=c[i],\n\t\t\tcost+=c[i]*e[i],\n\t\t\tAdd(a[i],b[i],d[i]-c[i],e[i]);\n\t\tS=size+1;\n\t\tT=size+2;\n\t\tsum=0;\n\t\tfor(i=1;i<=size;++i){\n\t\t\tif(deg[i]>0) Add(S,i, deg[i],0),sum+=deg[i];\n\t\t\tif(deg[i]<0) Add(i,T,-deg[i],0);\n\t\t}\n\t\tAdd(t,s,inf,0);\n\t\tsize+=2;\n\t}\n\tinline bool spfa(){\n\t\tri l,r,x,y,i;\n\t\tfor(i=1;i<=size;++i) dis[i]=-INF,vis[i]=0,cur[i]=head[i];\n\t\tq[l=r=1]=S;dis[S]=0; \n\t\twhile(l<=r){\n\t\t\tx=q[l++];vis[x]=0; \n\t\t\tfor(i=head[x];i;i=nxt[i])\n\t\t\t\tif(cap[i]&&dis[y=adj[i]]<dis[x]+val[i]){\n\t\t\t\t\tdis[y]=dis[x]+val[i];\n\t\t\t\t\tif(!vis[y]) q[++r]=y,vis[y]=1;\n\t\t\t\t}\n\t\t}\n\t\treturn dis[T]>-INF;\n\t}\n\tinline int dfs(ri x,ri now){\n\t\tif(x==T) return now;\n\t\tvis[x]=1;\n\t\tri y,tmp,res=0;\n\t\tfor(int &i=cur[x];i;i=nxt[i])\n\t\t\tif(!vis[y=adj[i]]&&cap[i]&&dis[y]==dis[x]+val[i])\n\t\t\t\tif(cap[i]-=(tmp=dfs(y,min(now-res,cap[i]))),cap[i^1]+=tmp,(res+=tmp)==now)\n\t\t\t\t\treturn vis[x]=false,res;\n\t\treturn res;\n\t}\n\tinline ll costflow(){\n\t\tri tmp;\n\t\tflow=0;\n\t\twhile(spfa())\n\t\t\ttmp=dfs(S,inf),\n\t\t\tflow+=tmp,\n\t\t\tcost+=tmp*dis[T];\n\t\tif(flow!=sum) return -INF;\n\t\treturn cost;\n\t}\n\tinline void clear(){\n\t\ttot=1;m=0;\n\t\tfor(ri i=1;i<=size;++i) head[i]=deg[i]=0;\n\t}\n}\nint posx[M],posy[M];\nint main(){\n\tri n,m,i,k,limx,limy;\n\tgi(n);\n\tlimx=limy=0;\n\tfor(i=1;i<=n;++i)\n\t\tgi(x0[i]),gi(y0[i]),gi(v0[i]),\n\t\tlimx=max(limx,x0[i]),\n\t\tlimy=max(limy,y0[i]);\n\tgi(m);\n\tfor(i=1;i<=m;++i){\n\t\tget(q[i].op);gi(q[i].a);gi(q[i].b);\n\t\tif(q[i].op=='L'||q[i].op=='R')\n\t\t\tlimx=max(limx,q[i].a);\n\t\telse\n\t\t\tlimy=max(limy,q[i].a);\n\t}\n\trll ans=0; \n\tfor(k=1;k<=n;++k){\n\t\tfor(i=1;i<=limx;++i)\n\t\t\tlx[i]=0,\n\t\t\trx[i]=inf;\n\t\tfor(i=1;i<=limy;++i)\n\t\t\tly[i]=0,\n\t\t\try[i]=inf;\n\t\tflag=1;\n\t\tfor(i=1;i<=m;++i)\n\t\t\tif(q[i].op=='L')\n\t\t\t\tchmin(rx[q[i].a],q[i].b);\n\t\t\telse if(q[i].op=='R'){\n\t\t\t\tif(q[i].a-1==0){\n\t\t\t\t\tif(k-q[i].b>0){\n\t\t\t\t\t\tflag=0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tchmax(lx[q[i].a-1],k-q[i].b);\n\t\t\t}\n\t\t\telse if(q[i].op=='D')\n\t\t\t\tchmin(ry[q[i].a],q[i].b);\n\t\t\telse{\n\t\t\t\tif(q[i].a-1==0){\n\t\t\t\t\tif(k-q[i].b>0){\n\t\t\t\t\t\tflag=0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tchmax(ly[q[i].a-1],k-q[i].b);\n\t\t\t}\n\t\tif(!flag) continue;\n\t\tfor(i=1;i<=limx;++i)\n\t\t\tlx[i]=max(lx[i-1],lx[i]);\n\t\tfor(i=limx-1;i;--i)\n\t\t\trx[i]=min(rx[i+1],rx[i]);\n\t\tfor(i=1;i<=limy;++i)\n\t\t\tly[i]=max(ly[i-1],ly[i]);\n\t\tfor(i=limy-1;i;--i)\n\t\t\try[i]=min(ry[i+1],ry[i]);\n\t\tG::size=n;\n\t\tfor(i=1;i<=limx;++i)\n\t\t\tposx[i]=++G::size;\n\t\tfor(i=1;i<=limy;++i)\n\t\t\tposy[i]=++G::size;\n\t\tG::s=++G::size;\n\t\tG::t=++G::size;\n\t\tG::add(G::s,posx[limx],max(k,lx[limx]),min(k,rx[limx]),0);\n\t\tfor(i=limx-1;i;--i)\n\t\t\tG::add(posx[i+1],posx[i],lx[i],rx[i],0);\n\t\tG::add(posy[limy],G::t,ly[limy],ry[limy],0);\n\t\tfor(i=1;i<limy;++i)\n\t\t\tG::add(posy[i],posy[i+1],ly[i],ry[i],0);\n\t\tfor(i=1;i<=n;++i)\n\t\t\tG::add(posx[x0[i]],i,0,1,v0[i]),\n\t\t\tG::add(i,posy[y0[i]],0,1,0);\n\t\tif(!flag) continue;\n\t\tG::build();\n\t\tans=max(ans,G::costflow());\n\t\tG::clear();\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <cstdint>\n#include <unordered_set>\n#include <unordered_map>\n\nusing namespace std;\n\nusing Int = long long;\n\ntemplate <class T1, class T2> ostream &operator<<(ostream &os, const pair<T1, T2> &a) { return os << \"(\" << a.first << \", \" << a.second << \")\"; };\ntemplate <class T> void pv(T a, T b) { for (T i = a; i != b; ++i) cout << *i << \" \"; cout << endl; }\ntemplate <class T> void chmin(T &t, const T &f) { if (t > f) t = f; }\ntemplate <class T> void chmax(T &t, const T &f) { if (t < f) t = f; }\n\n\n\nnamespace MCF {\n\t#define MAXN 100010\n\t#define MAXM 100010\n\t#define wint int\n\t#define cint Int\n\tconst wint wEPS = 0;\n\tconst wint wINF = 1001001001;\n\tconst cint cEPS = 0;\n\tconst cint cINF = 1001001001001001001LL;\n\tint n, m, ptr[MAXN], next[MAXM], zu[MAXM];\n\twint capa[MAXM], tof;\n\tcint cost[MAXM], toc, d[MAXN], pot[MAXN];\n\tint vis[MAXN], pree[MAXN];\n\tvoid init(int _n) {\n\t\tn = _n; m = 0; memset(ptr, ~0, n * sizeof(int));\n\t}\n\tvoid ae(int u, int v, wint w, cint c) {\n\t\tnext[m] = ptr[u]; ptr[u] = m; zu[m] = v; capa[m] = w; cost[m] = +c; ++m;\n\t\tnext[m] = ptr[v]; ptr[v] = m; zu[m] = u; capa[m] = 0; cost[m] = -c; ++m;\n\t}\n\tbool solve(int src, int ink, wint flo = wINF) {\n\t\twint f;\n\t\tcint c, cc;\n\t\tint i, u, v;\n\t\tmemset(pot, 0, n * sizeof(cint));\n\t//*\n\t\tfor (bool cont = 1; cont; ) {\n\t\t\tcont = 0;\n\t\t\tfor (u = 0; u < n; ++u) for (i = ptr[u]; ~i; i = next[i]) if (capa[i] > wEPS) {\n\t\t\t\tif (pot[zu[i]] > pot[u] + cost[i] + cEPS) {\n\t\t\t\t\tpot[zu[i]] = pot[u] + cost[i]; cont = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t//*/\n\t\tfor (toc = 0, tof = 0; tof + wEPS < flo; ) {\n\t\t\ttypedef pair<cint,int> node;\n\t\t\tpriority_queue< node,vector<node>,greater<node> > q;\n\t\t\tfor (u = 0; u < n; ++u) { d[u] = cINF; vis[u] = 0; }\n\t\t\tfor (q.push(make_pair(d[src] = 0, src)); !q.empty(); ) {\n\t\t\t\tc = q.top().first; u = q.top().second; q.pop();\n\t\t\t\tif (vis[u]++) continue;\n\t\t\t\tfor (i = ptr[u]; ~i; i = next[i]) if (capa[i] > wEPS) {\n\t\t\t\t\tcc = c + cost[i] + pot[u] - pot[v = zu[i]];\n\t\t\t\t\tif (d[v] > cc) { q.push(make_pair(d[v] = cc, v)); pree[v] = i; }\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!vis[ink]) return 0;\n\t\t\tf = flo - tof;\n\t\t\tfor (v = ink; v != src; v = zu[i ^ 1]) { i = pree[v]; chmin(f, capa[i]); }\n\t\t\tfor (v = ink; v != src; v = zu[i ^ 1]) { i = pree[v]; capa[i] -= f; capa[i ^ 1] += f; }\n\t\t\ttof += f;\n\t\t\ttoc += f * (d[ink] - pot[src] + pot[ink]);\n\t\t\tfor (u = 0; u < n; ++u) pot[u] += d[u];\n\t\t}\n\t\treturn 1;\n\t}\n}\n\n\nconst int LIM = 200;\n\nint N;\nvector<int> X, Y;\nvector<Int> V;\nint M;\nvector<char> T;\nvector<int> A, B;\n\nint main() {\n  for (; ~scanf(\"%d\", &N); ) {\n    X.resize(N);\n    Y.resize(N);\n    V.resize(N);\n    for (int j = 0; j < N; ++j) {\n      scanf(\"%d%d%lld\", &X[j], &Y[j], &V[j]);\n    }\n    scanf(\"%d\", &M);\n    T.resize(M);\n    A.resize(M);\n    B.resize(M);\n    for (int i = 0; i < M; ++i) {\n      scanf(\" %c%d%d\", &T[i], &A[i], &B[i]);\n    }\n    \n    Int ans = 0;\n    for (int K = 1; K <= N; ++K) {\n      cerr << \"K = \" << K << endl;\n      vector<int> minX(K, -LIM);\n      vector<int> maxX(K, +LIM);\n      vector<int> minY(K, -LIM);\n      vector<int> maxY(K, +LIM);\n      for (int i = 0; i < M; ++i) {\n        switch (T[i]) {\n          case 'L': {\n            // at most B[i] from x <= A[i]\n            for (int u = B[i]; u < K; ++u) {\n              chmax(minX[u], A[i] + 1);\n            }\n          } break;\n          case 'R': {\n            // at least K - B[i] from x <= A[i] - 1\n            const int b = max(K - B[i], 0);\n            for (int u = 0; u < b; ++u) {\n              chmin(maxX[u], A[i] - 1);\n            }\n          } break;\n          case 'D': {\n            // at most B[i] from y <= A[i]\n            for (int v = B[i]; v < K; ++v) {\n              chmax(minY[v], A[i] + 1);\n            }\n          } break;\n          case 'U': {\n            // at least K - B[i] from y <= A[i] - 1\n            const int b = max(K - B[i], 0);\n            for (int v = 0; v < b; ++v) {\n              chmin(maxY[v], A[i] - 1);\n            }\n          } break;\n          default: assert(false);\n        }\n      }\n      // cerr << \"  minX = \"; pv(minX.begin(), minX.end());\n      // cerr << \"  maxX = \"; pv(maxX.begin(), maxX.end());\n      // cerr << \"  minY = \"; pv(minY.begin(), minY.end());\n      // cerr << \"  maxY = \"; pv(maxY.begin(), maxY.end());\n      MCF::init(2 + K + K + N + N);\n      for (int u = 0; u < K; ++u) {\n        MCF::ae(0, 2 + u, 1, 0);\n      }\n      for (int v = 0; v < K; ++v) {\n        MCF::ae(2 + K + v, 1, 1, 0);\n      }\n      for (int j = 0; j < N; ++j) {\n        MCF::ae(2 + K + K + j, 2 + K + K + N + j, 1, -V[j]);\n      }\n      for (int u = 0; u < K; ++u) {\n        for (int j = 0; j < N; ++j) {\n          if (minX[u] <= X[j] && X[j] <= maxX[u]) {\n            MCF::ae(2 + u, 2 + K + K + j, 1, 0);\n          }\n        }\n      }\n      for (int v = 0; v < K; ++v) {\n        for (int j = 0; j < N; ++j) {\n          if (minY[v] <= Y[j] && Y[j] <= maxY[v]) {\n            MCF::ae(2 + K + K + N + j, 2 + K + v, 1, 0);\n          }\n        }\n      }\n      const bool status = MCF::solve(0, 1, K);\n      cerr << \"  status = \" << status << endl;\n      if (status) {\n        chmax(ans, -MCF::toc);\n      }\n    }\n    printf(\"%lld\\n\", ans);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\n  _|_|                              _|  _|    _|\n_|    _|  _|  _|_|  _|_|_|_|        _|  _|  _|\n_|    _|  _|_|          _|          _|  _|_|\n_|    _|  _|          _|      _|    _|  _|  _|\n  _|_|    _|        _|_|_|_|    _|_|    _|    _|\n\n*/\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<set>\n//#define ls (rt<<1)\n//#define rs (rt<<1|1)\n#define vi vector<int>\n#define pb push_back\n#define mk make_pair\n#define pii pair<ll,ll>\n#define rep(i,a,b) for(int i=(a),i##end=(b);i<=i##end;i++)\n#define fi first\n#define se second\n#define int long long\ntypedef long long ll;\nusing namespace std;\nconst int maxn=420;\nconst int inf=1e18+100;\nint xl[maxn],xr[maxn],yl[maxn],yr[maxn],s=415,t=416;\nint head[maxn],cnt=1;\nstruct gg{\n    int u,v,w;ll cost;int next;\n    void insert(int U,int V,int W,ll Cost,int Next){\n        u=U,v=V,w=W,cost=Cost,next=Next;\n    }\n}side[(maxn*maxn)*2];\nstruct Point{\n    int x,y;\n    ll cost=0;\n}point[maxn];\nstruct Lim{\n    int a,b;char c;\n}lim[maxn];\nvoid ins(int u,int v,int w,ll cost){\n    side[++cnt].insert(u,v,w,cost,head[u]);head[u]=cnt;\n    side[++cnt].insert(v,u,0,-cost,head[v]);head[v]=cnt;\n}\nint n,m;\nvoid init(int k){\n    rep(i,1,k)xl[i]=yl[i]=-inf,xr[i]=yr[i]=inf;\n    rep(i,1,m){\n        if(lim[i].c=='L')rep(j,lim[i].b+1,k)xl[j]=max(xl[j],lim[i].a+1);\n        else if(lim[i].c=='R')for(int j=k-lim[i].b;j>0;j--)xr[j]=min(xr[j],lim[i].a-1);\n        else if(lim[i].c=='D')rep(j,lim[i].b+1,k)yl[j]=max(yl[j],lim[i].a+1);\n        else if(lim[i].c=='U')for(int j=k-lim[i].b;j>0;j--)yr[j]=min(yr[j],lim[i].a-1);\n    }\n    memset(head,0,sizeof(head));cnt=1;\n    rep(i,1,k)ins(s,2*n+i,1,0);\n    rep(i,1,k)ins(2*n+k+i,t,1,0);\n    rep(i,1,n){\n        ins(i,n+i,1,point[i].cost);\n        rep(j,1,k){\n            if(xl[j]<=point[i].x&&point[i].x<=xr[j])ins(2*n+j,i,1,0);\n            if(yl[j]<=point[i].y&&point[i].y<=yr[j])ins(n+i,2*n+k+j,1,0);\n        }\n    }\n}\nint q[maxn*30];\nll dis[maxn],lenth;\nbool vis[maxn];\nbool spfa(){\n    rep(i,1,maxn-1)dis[i]=-inf;\n    memset(vis,0,sizeof(vis));\n    int hd=1,tl=1;q[hd]=s;vis[s]=1;dis[s]=0;\n    while(hd<=tl){\n        int u=q[hd++];vis[u]=0;//cout<<u<<' '<<endl;\n        for(int i=head[u];i;i=side[i].next){\n            int v=side[i].v;if(!side[i].w)continue;\n            if(dis[u]+side[i].cost>dis[v]){\n                dis[v]=dis[u]+side[i].cost;\n                if(!vis[v])q[++tl]=v;\n                vis[v]=1;\n            }\n        }\n    }\n    if(dis[t]!=-inf)return 1;\n    return 0;\n}\nint dfs(int u,int flow){\n    if(u==t)return flow;\n    vis[u]=1;int tot=0;\n    for(int i=head[u];i;i=side[i].next){\n        int v=side[i].v;if(vis[v]||!side[i].w||dis[v]!=dis[u]+side[i].cost)continue;\n        int sent=dfs(v,min(flow,side[i].w));\n        lenth+=1ll*side[i].cost*sent,side[i].w-=sent,side[i^1].w+=sent,tot+=sent;flow-=sent;\n    }\n    // vis[u]=0;\n    return tot;\n}\npii dinic(){\n    int mxflow=0;lenth=0;\n    while(spfa()){\n        int x;\n        while((x=dfs(s,inf)))mxflow+=x;\n    }\n    return mk(mxflow,lenth);\n}\nchar tmp[3];\nsigned main(){\n    scanf(\"%lld\",&n);\n    rep(i,1,n)scanf(\"%lld%lld%lld\",&point[i].x,&point[i].y,&point[i].cost);\n    scanf(\"%lld\",&m);\n    rep(i,1,m){\n        scanf(\"%s%lld%lld\",tmp+1,&lim[i].a,&lim[i].b);lim[i].c=tmp[1];\n    }\n    ll out=0;\n    rep(k,1,n){\n        init(k);\n        pii ans=dinic();out=max(out,ans.se);//cout<<ans.se<<endl;\n    }\n    cout<<out;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define DEBUG 0\n\n/**\n * File    : E.cpp\n * Author  : Kazune Takahashi\n * Created : 2019-5-31 23:21:39\n * Powered by Visual Studio Code\n */\n\n#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <complex>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <functional>\n#include <random>\n#include <chrono>\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef tuple<ll, int> Info;\n\nstruct Edge\n{\n  int to;\n  ll cap, cost;\n  int rev;\n};\n\nclass MinCostFlow\n{\n  int N;\n  vector<Edge> *G;\n  ll *h, *dist;\n  int *prev_v, *prev_e;\n  ll INFTY = 10000000000000010;\n\npublic:\n  MinCostFlow() {}\n\n  MinCostFlow(int n) : N(n)\n  {\n    G = new vector<Edge>[n];\n    h = new ll[n];\n    dist = new ll[n];\n    prev_v = new int[n];\n    prev_e = new int[n];\n  }\n\n  void add_edge(int from, int to, ll cap, ll cost)\n  {\n    G[from].push_back((Edge){to, cap, cost, (int)G[to].size()});\n    G[to].push_back((Edge){from, 0, -cost, (int)G[from].size() - 1});\n  }\n\n  ll min_cost_flow(int s, int t, ll f)\n  {\n    ll res = 0;\n    fill(h, h + N, 0);\n    while (f > 0)\n    {\n      priority_queue<Info, vector<Info>, greater<Info>> Q;\n      fill(dist, dist + N, INFTY);\n      dist[s] = 0;\n      Q.push(Info(0, s));\n      while (!Q.empty())\n      {\n        Info p = Q.top();\n        Q.pop();\n        int v = get<1>(p);\n        if (dist[v] < get<0>(p))\n        {\n          continue;\n        }\n        for (auto i = 0; i < (int)G[v].size(); i++)\n        {\n          Edge &e = G[v][i];\n          ll tmp = dist[v] + e.cost + h[v] - h[e.to];\n          if (e.cap > 0 && dist[e.to] > tmp)\n          {\n            dist[e.to] = tmp;\n            prev_v[e.to] = v;\n            prev_e[e.to] = i;\n            Q.push(Info(dist[e.to], e.to));\n          }\n        }\n      }\n      if (dist[t] == INFTY)\n      {\n        return -1;\n      }\n      for (auto v = 0; v < N; v++)\n      {\n        h[v] += dist[v];\n      }\n      ll d = f;\n      for (auto v = t; v != s; v = prev_v[v])\n      {\n        d = min(d, G[prev_v[v]][prev_e[v]].cap);\n      }\n      f -= d;\n      res += d * h[t];\n      for (auto v = t; v != s; v = prev_v[v])\n      {\n        Edge &e = G[prev_v[v]][prev_e[v]];\n        e.cap -= d;\n        G[v][e.rev].cap += d;\n      }\n    }\n    return res;\n  }\n};\n\nint N;\nint x[100], y[100];\nll v[100];\nint M;\nchar t[400];\nint a[400];\nint b[400];\nint K;\nMinCostFlow flow;\nll C = 1000000000000010;\n\nll ans = 0;\n\nvoid solve()\n{\n  vector<int> lx(K, -1);\n  vector<int> rx(K, 101);\n  vector<int> ly(K, -1);\n  vector<int> ry(K, 101);\n  for (auto i = 0; i < M; i++)\n  {\n    if (t[i] == 'L')\n    {\n      for (auto j = b[i]; j < K; j++)\n      {\n        lx[j] = max(lx[j], a[i]);\n      }\n    }\n    else if (t[i] == 'R')\n    {\n      for (auto j = 0; j < K - b[i]; j++)\n      {\n        rx[j] = min(rx[j], a[i]);\n      }\n    }\n    else if (t[i] == 'D')\n    {\n      for (auto j = b[i]; j < K; j++)\n      {\n        ly[j] = max(ly[j], a[i]);\n      }\n    }\n    else if (t[i] == 'U')\n    {\n      for (auto j = 0; j < K - b[i]; j++)\n      {\n        ry[j] = min(ry[j], a[i]);\n      }\n    }\n    else\n    {\n      assert(false);\n    }\n  }\n#if DEBUG == 1\n  cerr << \"K = \" << K << endl;\n  for (auto i = 0; i < K; i++)\n  {\n    cerr << \"lx[\" << i << \"] = \" << lx[i] << \", rx[\" << i << \"] = \" << rx[i] << endl;\n  }\n  for (auto i = 0; i < K; i++)\n  {\n    cerr << \"ly[\" << i << \"] = \" << ly[i] << \", ry[\" << i << \"] = \" << ry[i] << endl;\n  }\n#endif\n  flow = MinCostFlow(402);\n  for (auto i = 0; i < K; i++)\n  {\n    flow.add_edge(400, i, 1, 0);\n  }\n  for (auto i = 0; i < K; i++)\n  {\n    for (auto j = 0; j < N; j++)\n    {\n      if (lx[i] < x[j] && x[j] < rx[i])\n      {\n        flow.add_edge(i, 100 + j, 1, 0);\n      }\n    }\n  }\n  for (auto j = 0; j < N; j++)\n  {\n    flow.add_edge(100 + j, 200 + j, 1, C - v[j]);\n  }\n  for (auto i = 0; i < K; i++)\n  {\n    for (auto j = 0; j < N; j++)\n    {\n      if (ly[i] < y[j] && y[j] < ry[i])\n      {\n        flow.add_edge(200 + j, 300 + i, 1, 0);\n      }\n    }\n  }\n  for (auto i = 0; i < K; i++)\n  {\n    flow.add_edge(300 + i, 401, 1, 0);\n  }\n  ll X = flow.min_cost_flow(400, 401, K);\n  if (X >= 0)\n  {\n    ans = max(ans, C * K - X);\n  }\n}\n\nint main()\n{\n  cin >> N;\n  for (auto i = 0; i < N; i++)\n  {\n    cin >> x[i] >> y[i] >> v[i];\n  }\n  cin >> M;\n  for (auto i = 0; i < M; i++)\n  {\n    cin >> t[i] >> a[i] >> b[i];\n  }\n  for (K = 1; K <= N; K++)\n  {\n    solve();\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FOR(i,a,b) for (int i=a;i<=b;++i)\n#define REP(i,n) FOR(i,1,n)\n#define REP_0N(i,n) FOR(i,0,n)\n#define N 1005\n#define M 1005\nusing namespace std;\ntypedef __float128 ld;\nconst ld eps=1e-3; ld inf=1e18;\nint n,m,id[N],tp[N];\nld a[M][N],T,sum[N][M],A[N],d[N],x[N];\nint B[N];\nchar c[N];\nstruct node {\n    int x,y;\n    long long v;\n}b[N];\ninline void pivot(int r,int c) {\n    swap(id[r+n],id[c]);\n    ld t=-a[r][c];\n    a[r][c]=-1;\n    REP_0N(i,n) a[r][i]/=t;\n    REP_0N(i,m)\n    if (a[i][c]&&r!=i) {\n        t=a[i][c];\n        a[i][c]=0;\n        REP_0N(j,n) a[i][j]+=t*a[r][j];\n    }\n}\nvoid solve() {\n    ld t;\n    REP(i,n) id[i]=i;\n    while (true) {\n        int i=0,j=0; ld w=-eps;\n        REP(k,m) if (a[k][0]<w) w=a[i=k][0];\n        if (!i) break;\n        REP(k,n) if (a[i][k]>eps) {j=k; break;}\n        if (!j) return ;\n        pivot(i,j);\n    }\n    while (true) {\n        int i=0,j=0; ld w=eps;\n        REP(k,n) if (a[0][k]>w) w=a[0][j=k];\n        if (!j) break;\n        w=inf;\n        REP(k,m) if (a[k][j]<-eps&&(t=-a[k][0]/a[k][j])<w) w=t,i=k;\n        if (!i) return ;\n        pivot(i,j);\n    }\n    FOR(i,n+1,n+m) tp[id[i]]=i-n;\n    REP(i,n) x[i]=tp[i]?a[tp[i]][0]:0;\n    return ;\n}\nint main() {\n    scanf(\"%d\",&n);\n    for (int i=1;i<=n;i++) {\n        scanf(\"%d%d%lld\",&b[i].x,&b[i].y,&b[i].v);\n        a[0][i]=b[i].v;\n    }\n    scanf(\"%d\",&m);\n    for (int i=1;i<=m;i++) {\n        scanf(\"%s\",c);\n        int x,y;\n        scanf(\"%d%d\",&x,&y);\n        a[i][0]=y;\n        if (c[0]=='L') {\n            for (int j=1;j<=n;j++) if (b[j].x<=x) a[i][j]=-1;\n        }\n        else if (c[0]=='R') {\n            for (int j=1;j<=n;j++) if (b[j].x>=x) a[i][j]=-1;\n        }\n        else if (c[0]=='D') {\n            for (int j=1;j<=n;j++) if (b[j].y<=x) a[i][j]=-1;\n        }\n        else if (c[0]=='U') {\n            for (int j=1;j<=n;j++) if (b[j].y>=x) a[i][j]=-1;\n        }\n    }\n    for (int i=1;i<=n;i++) {\n        a[++m][0]=1;\n        a[m][i]=-1;\n    }\n    solve();\n    long long ans=0;\n    for (int i=1;i<=n;i++) if (x[i]>eps) ans+=b[i].v;//ans+=b[i].v*x[i];\n    printf(\"%lld\\n\",ans);\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define itn int\n#define all(x) (x).begin(), (x).end()\n#define make_unique(x) sort(all((x))); (x).resize(unique(all((x))) - (x).begin())\n\n#define random_shuffle(...) shuffle(__VA_ARGS__, rng)\n#define rand() rng()\n\nusing namespace std;\n\ninline int nxt() {\n\tint x;\n\tscanf(\"%d\", &x);\n\treturn x;\n}\n\n#define sz(x) ((int) (x).size())\n#define forn(i,n) for (int i = 0; i < int(n); ++i)\n\ntypedef long long ll;\ntypedef long long i64;\ntypedef long double ld;\nconst int inf = int(1e9) + int(1e5);\nconst ll infl = ll(2e18) + ll(1e10);\n\nconst int maxn = 505;\nconst int maxm = 505;\n\nconst ld eps = 1e-4;\n\nbool eq(ld a, ld b) {\n    return fabsl(a - b) < eps;\n}\n\n//BEGIN_CODE\nnamespace Simplex {\n\nld D[maxm][maxn]; // [n+2][m+2]\nint B[maxm];\nint N[maxn];\nld x[maxn];\nint n, m;\n\n//x >= 0, Ax <= b, c^Tx -> max\nvoid init(int _n, int _m, ld A[][maxn], ld *b, ld *c) {\n    n = _n, m = _m;\n    forn (i, m)\n        forn (j, n)\n            D[i][j] = -A[i][j];\n    forn (i, m) {\n        D[i][n] = 1;\n        D[i][n + 1] = b[i];\n    }\n    forn (j, n) {\n        D[m][j] = c[j];\n        D[m + 1][j] = 0;\n    }\n    D[m][n + 1] = D[m][n] = D[m + 1][n + 1] = 0;\n    D[m + 1][n] = -1;\n    iota(B, B + m, n);\n    iota(N, N + n, 0);\n    N[n] = -1;\n}\n\nvoid pivot(int b, int nb) {\n    assert(D[b][nb] != 0);\n    ld q = 1. / -D[b][nb];\n    D[b][nb] = -1;\n    forn (i, n + 2)\n        D[b][i] *= q;\n    forn (i, m + 2) {\n        if (i == b)\n            continue;\n        ld coef = D[i][nb];\n        D[i][nb] = 0;\n        forn (j, n + 2)\n            D[i][j] += coef * D[b][j];\n    }\n    swap(B[b], N[nb]);\n}\n\nbool betterN(int f, int i, int j) {\n    if (eq(D[f][i], D[f][j]))\n        return N[i] < N[j];\n    return D[f][i] > D[f][j];\n}\n\nbool betterB(int nb, int i, int j) {\n    ld ai = D[i][n + 1] / D[i][nb];\n    ld aj = D[j][n + 1] / D[j][nb];\n    if (eq(ai, aj))\n        return B[i] < B[j];\n    return ai > aj;\n}\n\nbool simplex(int phase) {\n    int f = phase == 1 ? m : m + 1;\n    while (true) {\n        int nb = -1;\n        forn (i, n + 1) {\n            if (N[i] == -1 && phase == 1)\n                continue;\n            if (nb == -1 || betterN(f, i, nb))\n                nb = i;\n        }\n        if (D[f][nb] <= eps)\n            return phase == 1;\n        assert(nb != -1);\n\n        int b = -1;\n        forn (i, m) {\n            if (D[i][nb] >= -eps)\n                continue;\n            if (b == -1 || betterB(nb, i, b))\n                b = i;\n        }\n        if (b == -1)\n            return false;\n        pivot(b, nb);\n        if (N[nb] == -1 && phase == 2)\n            return true;\n    }\n}\n\nld solve() {\n    int b = -1;\n    forn (i, m) {\n        if (b == -1 || D[i][n + 1] < D[b][n + 1])\n            b = i;\n    }\n    assert(b != -1);\n    if (D[b][n + 1] < -eps) {\n        pivot(b, n);\n        if (!simplex(2) || D[m + 1][n + 1] < -eps)\n            return -infl;\n    }\n    if (!simplex(1))\n        return infl;\n\n    forn (i, n)\n        x[i] = 0;\n    forn (i, m)\n        if (B[i] < n)\n            x[B[i]] = D[i][n + 1];\n\n    return D[m][n + 1];\n}\n\n} //Simplex\n//END_CODE\n\nstruct Treasure {\n\tint x, y;\n\tlong long v;\n\n\tvoid scan() {\n\t\tscanf(\"%d%d%lld\", &x, &y, &v);\n\t}\n};\n\nstruct Constraint {\n\tchar t;\n\tint a, b;\n\n\tvoid scan() {\n\t\tcin >> t >> a >> b;\n\t}\n\n\tbool isAbout(const Treasure& tr) const {\n\t\tif (t == 'D') {\n\t\t\treturn tr.y <= a;\n\t\t} else if (t == 'U') {\n\t\t\treturn tr.y >= a;\n\t\t} else if (t == 'L') {\n\t\t\treturn tr.x <= a;\n\t\t} else if (t == 'R') {\n\t\t\treturn tr.x >= a;\n\t\t} else {\n\t\t\tassert(false);\n\t\t}\n\t}\n};\n\nld a[maxm][maxn];\nld b[maxm];\nld c[maxn];\n\nint main() {\n\tmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n\tint n = nxt();\n\tvector<Treasure> trs(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\ttrs[i].scan();\n\t}\n\n\tint m = nxt();\n\tvector<Constraint> crs(m);\n\tfor (int i = 0; i < m; ++i) {\n\t\tcrs[i].scan();\n\t}\n\n\tfor (int i = 0; i < m; ++i) {\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\ta[i][j] = crs[i].isAbout(trs[j]);\n\t\t}\n\t\tb[i] = crs[i].b;\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\ta[m + i][i] = 1;\n\t\tb[m + i] = 1;\n\t\tc[i] = trs[i].v;\n\t}\n\n\tSimplex::init(n, n + m, a, b, c);\n\t// Simplex::solve();\n\n\tSimplex::solve();\n\t// for (int i = 0; i < n; ++i) {\n\t// \tans += trs[i].v * (int)(roundl(Simplex::x[i]));\n\t// }\n\tmap<long long, ld> M;\n\tfor (int i = 0; i < n; ++i) {\n\t\tM[trs[i].v] += Simplex::x[i];\n\t}\n\tlong long ans = 0;\n\tfor (auto p : M) {\n\t\tans += (long long)roundl(p.second) * p.first;\n\t}\n\tcout << ans << \"\\n\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=505,M=20005,R=100;\nconst ll inf=0x3f3f3f3f3f3f3f3fll;\nint read(){\n\tint f=1,g=0;\n\tchar ch=getchar();\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-') f=-1;\n\tfor (;isdigit(ch);ch=getchar()) g=g*10+ch-'0';\n\treturn f*g;\n}\nvoid chkmax(int &x,int y){if (x<y) x=y;}\nvoid chkmin(int &x,int y){if (x>y) x=y;}\nint n,m;\nstruct jew{int x,y;ll w;}a[N];\nstruct node{char typ;int x,r;}b[N];\nll cost,ans;\nint S,T,cnt,fir[N],fr[N],siz;\nstruct edge{int u,v;ll w;int fl,nex;}e[M];\nvoid add(int u,int v,ll w,int fl){\n\te[++siz]=(edge){u,v,w,fl,fir[u]};fir[u]=siz;\n\te[++siz]=(edge){v,u,-w,0,fir[v]};fir[v]=siz;\n}\nll dist[N];int que[N*50];bool inq[N];\nvoid dec(int x,int fl){e[x].fl-=fl;e[x^1].fl+=fl;}\nbool spfa(){\n\tmemset(dist,-1,8*(cnt+1));\n\tmemset(inq,0,cnt+1);\n\tint l=1,r=1;que[l]=S;dist[S]=0;inq[S]=1;\n\twhile (l<=r){\n\t\tint x=que[l];\n\t\tfor (int i=fir[x];i;i=e[i].nex)\n\t\tif ((e[i].fl)&&(dist[e[i].v]<dist[x]+e[i].w)){\n\t\t\tif (!inq[e[i].v]) {que[++r]=e[i].v;inq[e[i].v]=1;}\n\t\t\tdist[e[i].v]=dist[x]+e[i].w;fr[e[i].v]=i;\n\t\t}\n\t\tinq[x]=0;l++;\n\t}\n\treturn dist[T]>0;\n}\nint update(){\n\tint t=0x3f3f3f3f;\n\tfor (int i=fr[T];i;i=fr[e[i].u]) t=min(t,e[i].fl);\n\tcost+=t*dist[T];\n\tfor (int i=fr[T];i;i=fr[e[i].u]) dec(i,t);\n\treturn t;\n}\nint dinic(){\n\tint flow=0;\n\twhile (spfa()) flow+=update();\n\treturn flow;\n}\nint ml[N],mr[N],mu[N],md[N];\nvoid calc(int L){\n\tmemset(fir,0,sizeof(fir));siz=1;\n\tS=0;T=cnt=L*2+R*2+1;\n\tfor (int i=1;i<=n;i++) add(a[i].x,a[i].y+R,a[i].w,1);\n\tfor (int i=1;i<=L;i++) {ml[i]=mu[i]=1,mr[i]=md[i]=R;add(S,R*2+i,0,1);add(R*2+L+i,T,0,1);}\n\tfor (int i=1;i<=m;i++)\n\tif (b[i].r>=L) continue;\n\telse if (b[i].typ=='L') chkmax(ml[b[i].r+1],b[i].x+1);\n\telse if (b[i].typ=='R') chkmin(mr[L-b[i].r],b[i].x-1);\n\telse if (b[i].typ=='D') chkmax(mu[b[i].r+1],b[i].x+1);\n\telse if (b[i].typ=='U') chkmin(md[L-b[i].r],b[i].x-1);\n\tfor (int i=2;i<=L;i++) chkmax(ml[i],ml[i-1]),chkmax(mu[i],mu[i-1]);\n\tfor (int i=L-1;i;i--)  chkmin(md[i],md[i+1]),chkmin(md[i],md[i+1]);\n\tfor (int i=1;i<=L;i++){\n\t\tfor (int j=ml[i];j<=mr[i];j++) add(R*2+i,j,0,1);\n\t\tfor (int j=mu[i];j<=md[i];j++) add(j+R,R*2+L+i,0,1);\n\t}\n\tcost=0;\n\tif (dinic()==L) ans=max(ans,cost);\n//\tfor (int i=1;i<=n;i++) if (!e[i*2].fl) printf(\"%d \",i);\n//\tprintf(\"\\n\");\n}\nint main(){\n\tn=read();\n\tfor (int i=1;i<=n;i++) scanf(\" %d %d %lld\",&a[i].x,&a[i].y,&a[i].w);\n\tm=read();\n\tfor (int i=1;i<=m;i++) scanf(\" %c %d %d\",&b[i].typ,&b[i].x,&b[i].r);\n\tfor (int i=1;i<=n;i++) calc(i);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define ll long long\n#define inf 0x3f3f3f3f3f3f3f3f\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\nchar buf[1<<21],*p1=buf,*p2=buf;\ninline char getc(){return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;}\nll read(){\n    R ll res,f=1;R char ch;\n    while((ch=getc())>'9'||ch<'0')(ch=='-')&&(f=-1);\n    for(res=ch-'0';(ch=getc())>='0'&&ch<='9';res=res*10+ch-'0');\n    return res*f;\n}\ninline char getop(){R char ch;while((ch=getc())>'Z'||ch<'A');return ch;}\nconst int N=505;\nstruct eg{int v,nx,w;ll c;}e[N*N];int head[N],tot;\ninline void add(R int u,R int v,R ll c){\n\te[++tot]={v,head[u],1,c},head[u]=tot,\n\te[++tot]={u,head[v],0,-c},head[v]=tot;\n}\nint x[N],y[N],a[N],b[N],t[N],LL[N],RR[N],DD[N],UU[N],vis[N],pe[N],n,m,S,T;\nll v[N],dis[N],res,ans;queue<int>q;\nbool spfa(){\n\tmemset(dis,0x3f,sizeof(dis));\n\tdis[S]=0,q.push(S);\n\twhile(!q.empty()){\n\t\tint u=q.front();q.pop(),vis[u]=0;\n\t\tgo(u)if(e[i].w&&(cmin(dis[v],dis[u]+e[i].c)?pe[v]=i,1:0)&&!vis[v])q.push(v),vis[v]=1;\n\t}\n\tif(dis[T]==inf)return false;\n\tres+=dis[T];\n\tfor(R int i=T;i!=S;i=e[pe[i]^1].v)--e[pe[i]].w,++e[pe[i]^1].w;\n\treturn true;\n}\nll calc(int k){\n\tfp(i,1,k)LL[i]=DD[i]=0,RR[i]=UU[i]=19260817;\n\tfp(i,1,m)if(b[i]<k){\n\t\tswitch(t[i]){\n\t\t\tcase 'L':LL[b[i]+1]=a[i]+1;break;\n\t\t\tcase 'R':RR[k-b[i]]=a[i]-1;break;\n\t\t\tcase 'D':DD[b[i]+1]=a[i]+1;break;\n\t\t\tcase 'U':UU[k-b[i]]=a[i]-1;break;\n\t\t}\n\t}\n\tfp(i,2,k)cmax(LL[i],LL[i-1]),cmax(DD[i],DD[i-1]);\n\tfd(i,k-1,1)cmin(RR[i],RR[i+1]),cmin(UU[i],UU[i+1]);\n\tmemset(head,0,sizeof(head)),tot=1;\n\tS=0,T=(n+k)<<1|1;\n\tfp(i,1,n)add(i,n+i,-v[i]);\n\tfp(i,1,k){\n\t\tadd(S,n+n+i,0),add(n+n+k+i,T,0);\n\t\tfp(j,1,n){\n\t\t\tif(x[j]>=LL[i]&&x[j]<=RR[i])add(n+n+i,j,0);\n\t\t\tif(y[j]>=DD[i]&&y[j]<=UU[i])add(n+j,n+n+k+i,0);\n\t\t}\n\t}\n\tres=0;while(spfa());\n\treturn -res;\n}\nint main(){\n//\tfreopen(\"testdata.in\",\"r\",stdin);\n\tn=read();\n\tfp(i,1,n)x[i]=read(),y[i]=read(),v[i]=read();\n\tm=read();\n\tfp(i,1,m)t[i]=getop(),a[i]=read(),b[i]=read();\n\tfp(i,1,n)cmax(ans,calc(i));\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int64;\nconst int _inf = 1e8;\nnamespace Flow {\n\nconst int V = 505 , E = 200010;\nconst int64 inf = 1e18;\n\nint head[V] , cnt , S , T;\nstruct Edge {\n    int to , next , flow;\n    int64 cost;\n}edge[E];\nvoid init(int s , int t) {\n    memset(head , 0 , sizeof(head));\n    cnt = 1;\n    S = s , T = t;\n}\nvoid addedge(int x , int y , int flow , int64 cost) {\n    edge[++cnt] = (Edge) {y , head[x] , flow , cost}; head[x] = cnt;\n    edge[++cnt] = (Edge) {x , head[y] , 0 , -cost}; head[y] = cnt;\n}\n\nint64 dis[V];\nint flow[V] , pre[V];\nbool vis[V];\n\n//鏈€澶ц垂鐢ㄦ渶澶ф祦\nbool spfa() {\n    for(int i = 0 ; i < V ; ++i) dis[i] = -inf , flow[i] = 0;\n    queue<int> q; q.push(S);\n    dis[S] = 0 , flow[S] = _inf;\n    do {\n        int x = q.front() ; q.pop();\n        vis[x] = 0;\n        for(int i = head[x] ; i ; i = edge[i].next) {\n            int y = edge[i].to;\n            if(edge[i].flow > 0 && dis[y] < dis[x] + edge[i].cost) {\n                dis[y] = dis[x] + edge[i].cost;\n                pre[y] = i;\n                flow[y] = min(flow[x] , edge[i].flow);\n                if(!vis[y]) vis[y] = 1 , q.push(y);\n            }\n        }\n    }while(q.size());\n    return flow[T] > 0;\n}\nvoid EK(int& fl , int64& cs) {\n    fl = 0 , cs = 0;\n    while(spfa()) {\n        cs += dis[T] * flow[T];\n        fl += flow[T];\n        for(int x = T ; x != S ; x = edge[pre[x]^1].to) {\n            edge[pre[x]^1].flow += flow[T];\n            edge[pre[x]].flow -= flow[T];\n        }\n    }\n}\n\n}\n\nconst int N = 85 , M = 322;\n\nint n , m;\nstruct Jew {int x , y ; int64 w ;} jew[N];\nstruct Lim {char c ; int a , b ;} lim[M];\n\nvoid readin(){\n    scanf(\"%d\" , &n);\n    for(int i = 1 ; i <= n ; ++i) scanf(\"%d %d %lld\" , &jew[i].x , &jew[i].y , &jew[i].w);\n    scanf(\"%d\" , &m);\n    for(int i = 1 ; i <= m ; ++i) scanf(\"\\n%c %d %d\" , &lim[i].c , &lim[i].a , &lim[i].b);\n}\n\nint xl[N] , xr[N] , yl[N] , yr[N];\n\ntemplate<typename T> inline void chkmax(T &x , T y) {if(x < y) x = y;}\ntemplate<typename T> inline void chkmin(T &x , T y) {if(y < x) x = y;}\n\nvoid init(int k) {\n    for(int i = 1 ; i <= k ; ++i) {\n        xl[i] = yl[i] = -_inf;\n        xr[i] = yr[i] = _inf;\n    }\n    for(int i = 1 ; i <= m ; ++i) \n        switch (lim[i].c)\n        {\n        case 'L':\n            for(int j = lim[i].b + 1 ; j <= k ; ++j)\n                chkmax(xl[j] , lim[i].a + 1);\n            break;\n        case 'R':\n            for(int j = k - lim[i].b ; j > 0; --j)\n                chkmin(xr[j] , lim[i].a - 1);\n            break;\n        case 'D':\n            for(int j = lim[i].b + 1 ; j <= k ; ++j)\n                chkmax(yl[j] , lim[i].a + 1);\n            break;\n        case 'U':\n            for(int j = k - lim[i].b ; j > 0; --j)\n                chkmin(yr[j] , lim[i].a - 1);\n            break;\n        }\n}\n\nint64 solve(int k) {\n    Flow::init(2*(n+k)+1 , 2*(n+k)+2);\n    for(int i = 1 ; i <= k ; ++i) {\n        Flow::addedge(Flow::S , 2*n+i , 1 , 0);\n        Flow::addedge(2*n+k+i, Flow::T , 1 , 0);\n    }\n    for(int i = 1 ; i <= n ; ++i) \n        Flow::addedge(i , n + i , 1 , jew[i].w);\n    for(int i = 1 ; i <= n ; ++i) \n        for(int j = 1 ; j <= k ; ++j) {\n            if(jew[i].x >= xl[j] && jew[i].x <= xr[j])\n                Flow::addedge(2*n+j , i , 1 , 0);\n            if(jew[i].y >= yl[j] && jew[i].y <= yr[j])\n                Flow::addedge(i+n , 2*n+k+j , 1 , 0);\n        }\n    int fl ; int64 cs;\n    Flow::EK(fl , cs);\n    if(fl != k) return 0;\n    return cs;\n}\n\nint64 ans;\nint main() {\n    readin();\n    for(int k = 1 ; k <= n ; ++k)\n        init(k) , chkmax(ans , solve(k));\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <list>\n#include <time.h>\n#include <math.h>\n#include <random>\n#include <deque>\n#include <queue>\n#include <cassert>\n#include <unordered_map>\n#include <unordered_set>\n#include <iomanip>\n#include <bitset>\n#include <sstream>\n#include <chrono>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef __float128 dbl;\nconst int INF = 1.01e9;\n \nconst __float128 EPS = 1e-25;\nbool eq(__float128 x, __float128 y) {\n    return fabs(x - y) < EPS;\n}\nbool ls(__float128 x, __float128 y) {\n    return x < y && !eq(x, y);\n}\n \nvector<__float128> simplex(vector<vector<__float128> > a) {\n    int n = a.size() - 1;\n    int m = a[0].size() - 1;\n    vector<int> left(n + 1), up(m + 1);\n    iota(up.begin(), up.end(), 0);\n    iota(left.begin(), left.end(), m);\n    auto pivot = [&](int x, int y) {\n        swap(left[x], up[y]);\n        __float128 k = a[x][y];\n        a[x][y] = 1;\n        vector<int> vct;\n        for (int j = 0; j <= m; j++) {\n            a[x][j] /= k;\n            if (!eq(a[x][j], 0)) vct.push_back(j);\n        }\n        for (int i = 0; i <= n; i++) {\n            if (eq(a[i][y], 0) || i == x) continue;\n            k = a[i][y];\n            a[i][y] = 0;\n            for (int j : vct) a[i][j] -= k * a[x][j];\n        }\n    };\n    while (1) {\n        int x = -1;\n        for (int i = 1; i <= n; i++) if (ls(a[i][0], 0) && (x == -1 || a[i][0] < a[x][0])) x = i;\n        if (x == -1) break;\n        int y = -1;\n        for (int j = 1; j <= m; j++) if (ls(a[x][j], 0) && (y == -1 || a[x][j] < a[x][y])) y = j;\n        if (y == -1) assert(0); // infeasible\n        pivot(x, y);\n    }\n    while (1) {\n        int y = -1;\n        for (int j = 1; j <= m; j++) if (ls(0, a[0][j]) && (y == -1 || a[0][j] > a[0][y])) y = j;\n        if (y == -1) break;\n        int x = -1;\n        for (int i = 1; i <= n; i++) if (ls(0, a[i][y]) && (x == -1 || a[i][0] / a[i][y] < a[x][0] / a[x][y])) x = i;\n        if (x == -1) assert(0); // unbounded\n        pivot(x, y);\n    }\n    vector<__float128> ans(m + 1);\n    for (int i = 1; i <= n; i++) if (left[i] <= m) ans[left[i]] = a[i][0];\n    ans[0] = -a[0][0];\n    return ans;\n}\n\n#ifdef ONPC\n  mt19937 rnd(228);\n#else\n  mt19937 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\n#endif\n\nint main()\n{\n#ifdef ONPC\n  freopen(\"a.in\", \"r\", stdin);\n#endif\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector <int> x(n), y(n);\n  vector <ll> ok;\n  vector <__float128> v;\n  vector <pair <ll, int> > e;\n  for (int i = 0; i < n; i++)\n  {\n    cin >> x[i] >> y[i];\n    ll x;\n    cin >> x;\n    ok.push_back(x);\n    v.push_back(x);\n    e.push_back({x, i});\n  }\n  v.insert(v.begin(), 0);\n  int m;\n  cin >> m;\n  vector <vector <__float128> > mat;\n  mat.push_back(v);\n  for (int i = 0; i < n; i++)\n  {\n    vector <__float128> kek(n + 1);\n    kek[0] = kek[i + 1] = 1;\n    mat.push_back(kek);\n  }\n  vector <vector <int> > simp;\n  for (int i = 0; i < m; i++)\n  {\n    char c;\n    cin >> c;\n    int a;\n    int b;\n    cin >> a >> b;\n    vector <__float128> arr = {(__float128) b};\n    vector <int> kek = {b};\n    for (int j = 0; j < n; j++)\n    {\n      int grab = 0;\n      if (c == 'L' && x[j] <= a) grab = 1;\n      if (c == 'R' && x[j] >= a) grab = 1;\n      if (c == 'D' && y[j] <= a) grab = 1;\n      if (c == 'U' && y[j] >= a) grab = 1;\n      arr.push_back(grab);\n      kek.push_back(grab);\n    }\n    mat.push_back(arr);\n    simp.push_back(kek);\n  }\n  auto good = [&] (vector <int> grab)\n  {\n    for (auto c : simp)\n    {\n      int sum = 0;\n      for (int i = 1; i <= n; i++) sum += grab[i - 1] * c[i];\n      if (sum > c[0])\n      {\n        return false;\n      }\n    }\n    return true;\n  };\n  auto f = [&] (vector <int> grab)\n  {\n    ll sum = 0;\n    for (int i = 0; i < n; i++)\n    {\n      if (grab[i]) sum += ok[i];\n    }\n    return sum;\n  };\n  vector <int> grab;\n  for (int i = 0; i < n; i++) grab.push_back(0);\n  cout.precision(20);\n  auto solve = [&] ()\n  {\n    auto ret = simplex(mat);\n    sort(e.begin(), e.end());\n    vector <int> me(n);\n    int x = -1;\n    for (int i = 1; i <= n; i++)\n    {\n      if (grab[i - 1]) continue;\n      grab[x - 1] = true;\n      if (!good(grab))\n      {\n        grab[x - 1] = false;\n        continue;\n      }\n      if (x == -1 || ret[i] > ret[x])\n      {\n        x = i;\n      }\n    }\n    if (x == -1 || ret[x] < EPS) return 0ll;\n    x--;\n    me[x] = true;\n    grab[x] = true;\n    if (!good(grab)) grab[x] = false, me[x] = false;\n    int kekos = 0;\n    for (auto &c : mat)\n    {\n      kekos++;\n      if (kekos > n + 1)\n      for (int i = 1; i <= n; i++)\n      {\n        if (me[i - 1] && c[i] > EPS) c[i]--, c[0]--;\n      }\n    }\n    for (int i = 1; i <= n; i++)\n    {\n      if (me[i - 1])\n      {\n        mat[i][0] = 0;\n      }\n    }\n    return ok[x];\n  };\n  ll ans = 0;\n  while (ll t = solve())\n  {\n    ans += t;\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#define M 5010\n#define int long long\n#define clr(X) memset(X, 0, sizeof X)\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int Lim = 105;\n\nint Head[M], Next[M], Go[M], Cost[M], Fl[M], Cnt = 1;\n\nint n, A[M], B[M], C[M], Q, op[M], QA[M], QB[M];\n\nbool vis[M];\n\nint Dis[M], Pr[M], mxF[M];\n\nll nwans = 0, totans = 0; // getmax!\n\n/*struct node {\n    int dis, v;\n    node() {}\n    node(int _1, int _2) {dis = _1, v = _2;}\n    node operator < (const node& X) const {return dis > X.dis;}\n};\n\npriority_queue <node> Q;*/\n\nvoid SPFA(int S) {\n    memset(Dis, 63, sizeof Dis), clr(Pr), clr(mxF), clr(vis), mxF[S] = 1e9;\n    Dis[S] = 0;\n    vector <int> V(1, S);\n    for(int i = 0; i < V.size(); i++) {\n        int x = V[i], ds = Dis[x];\n        vis[x] = 0;\n        for(int T = Head[x]; T; T = Next[T])\n            if(Fl[T] && Dis[Go[T]] > ds + Cost[T]) {\n                Dis[Go[T]] = ds + Cost[T];\n                mxF[Go[T]] = min(mxF[x], Fl[T]);\n                Pr[Go[T]] = T ^ 1;\n                if(!vis[Go[T]]) vis[Go[T]] = 1, V.push_back(Go[T]);\n            }\n    }\n}\n\nint MMP(int SS, int TT, int f) {\n    int ans = 0, fl = 0;\n    for(; ;) {\n        SPFA(SS);\n        if(Dis[TT] > 1e18) {\n            if(fl != f) return 0;\n            return ans;\n        }\n        ans += mxF[TT] * Dis[TT], fl += mxF[TT];\n        for(int i = TT; i != SS; i = Go[Pr[i]]) {\n            Fl[Pr[i]] += mxF[TT];\n            Fl[Pr[i] ^ 1] -= mxF[TT];\n        }\n    }\n}\n\nconst int SS = 500, TT = 501;\n\nint Deg[M];\n\nvoid addedge(int a, int b, int f, int c) {\n    Go[++Cnt] = b;\n    Next[Cnt] = Head[a];\n    Head[a] = Cnt;\n    Fl[Cnt] = f;\n    Cost[Cnt] = c;\n}\nvoid dealedge(int a, int b, int lw, int hi, int c) {\n    //nwans += c * lw;\n    addedge(a, b, hi - lw, c);\n    addedge(b, a, 0, -c);\n    Deg[b] += lw;\n    Deg[a] -= lw;\n}\n\nvoid cmax(int &x, int y) {if(x < y) x = y;}\nvoid cmin(int &x, int y) {if(x > y) x = y;}\n\nsigned main() {\n    scanf(\"%lld\", &n);\n    for(int i = 1; i <= n; i++) {\n        scanf(\"%lld%lld%lld\", &A[i], &B[i], &C[i]);\n    }\n    scanf(\"%lld\", &Q);\n    for(int i = 1; i <= Q; i++) {\n        char ch[3];\n        scanf(\"%s\", ch);\n        op[i] = ch[0];\n        scanf(\"%lld%lld\", &QA[i], &QB[i]);\n    }\n    for(int TTT = 0; TTT <= n; TTT++) {\n        clr(Head), Cnt = 1;\n        clr(Deg);\n        dealedge(207, 1, TTT, TTT, 0);\n        int XXMx[111], XXMn[111], YYMx[111], YYMn[111];\n        memset(XXMx, 0, sizeof XXMx);\n        memset(YYMx, 0, sizeof YYMx);\n        memset(XXMn, 1, sizeof XXMn);\n        memset(YYMn, 1, sizeof YYMn);\n        int flag = 1;\n        for(int i = 1; i <= Q; i++) {\n            int o = op[i];\n            if(o == 'R') {\n                cmin(XXMn[QA[i]], QB[i]);\n            } else if(o == 'L') {\n                cmax(XXMx[QA[i] + 1], TTT - QB[i]);\n            } else if(o == 'D') {\n                cmin(YYMn[QA[i]], QB[i]);\n            } else {\n                cmax(YYMx[QA[i] - 1], TTT - QB[i]);\n            }\n        }\n        if(!flag) continue;\n        for(int i = 0; i <= 100; i++){\n            if(XXMx[i + 1] > XXMn[i + 1]) flag = 0;dealedge(i + 2, i + 3, XXMx[i + 1], XXMn[i + 1], 0);}\n        for(int i = 0; i <= 100; i++) {\n            if(YYMx[i] > YYMn[i]) flag = 0;dealedge(104 + i, 105 + i, YYMx[i], YYMn[i], 0);\n        }\n        if(!flag) continue;\n        dealedge(1, 2, 0, 233333, 0);\n        dealedge(205, 207, 0, 233333, 0);\n        for(int i = 1; i <= n; i++)\n            dealedge(1 + A[i], 104 + B[i], 0, 1, -C[i]);\n        for(int i = 1; i <= 207; i++)\n            if(Deg[i] > 0) {\n                addedge(SS, i, Deg[i], 0);\n                addedge(i, SS, 0, 0);\n            } else if(Deg[i] < 0) {\n                addedge(i, TT, -Deg[i], 0);\n                addedge(TT, i, 0, 0);\n            }\n        int tottot = 0;\n        for(int i = 1; i <= 207; i++) if(Deg[i] > 0) tottot += Deg[i];\n        totans = max(totans, -MMP(SS, TT, tottot));\n    }\n    printf(\"%lld\\n\", totans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=505,M=50005,R=100;\nconst ll inf=0x3f3f3f3f3f3f3f3fll;\nint read(){\n\tint f=1,g=0;\n\tchar ch=getchar();\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-') f=-1;\n\tfor (;isdigit(ch);ch=getchar()) g=g*10+ch-'0';\n\treturn f*g;\n}\nvoid chkmax(int &x,int y){if (x<y) x=y;}\nvoid chkmin(int &x,int y){if (x>y) x=y;}\nint n,m;\nstruct jew{int x,y;ll w;}a[N];\nstruct node{char typ;int x,r;}b[N];\nll cost,ans;\nint S,T,cnt,fir[N],fr[N],siz;\nstruct edge{int u,v;ll w;int fl,nex;}e[M];\nvoid add(int u,int v,ll w,int fl){\n\te[++siz]=(edge){u,v,w,fl,fir[u]};fir[u]=siz;\n\te[++siz]=(edge){v,u,-w,0,fir[v]};fir[v]=siz;\n}\nll dist[N];int que[N*50];bool inq[N];\nvoid dec(int x,int fl){e[x].fl-=fl;e[x^1].fl+=fl;}\nbool spfa(){\n\tmemset(dist,0xc0,8*(cnt+1));\n\tmemset(inq,0,cnt+1);\n\tint l=1,r=1;que[l]=S;dist[S]=0;inq[S]=1;\n\twhile (l<=r){\n\t\tint x=que[l];\n\t\tfor (int i=fir[x];i;i=e[i].nex)\n\t\tif ((e[i].fl)&&(dist[e[i].v]<dist[x]+e[i].w)){\n\t\t\tif (!inq[e[i].v]) {que[++r]=e[i].v;inq[e[i].v]=1;}\n\t\t\tdist[e[i].v]=dist[x]+e[i].w;fr[e[i].v]=i;\n\t\t}\n\t\tinq[x]=0;l++;\n\t}\n\treturn dist[T]>(ll)0xc0c0c0c0c0c0c0c0ll;\n}\nint update(){\n\tint t=0x3f3f3f3f;\n\tfor (int i=fr[T];i;i=fr[e[i].u]) t=min(t,e[i].fl);\n\tcost+=t*dist[T];\n\tfor (int i=fr[T];i;i=fr[e[i].u]) dec(i,t);\n\treturn t;\n}\nint dinic(){\n\tint flow=0;\n\twhile (spfa()) flow+=update();\n\treturn flow;\n}\nint ml[N],mr[N],mu[N],md[N];\nvoid calc(int L){\n\tmemset(fir,0,sizeof(fir));siz=1;\n\tS=0;T=cnt=L*2+R*2+1;\n\tfor (int i=1;i<=n;i++) add(a[i].x,a[i].y+R,a[i].w,1);\n\tfor (int i=1;i<=L;i++) {ml[i]=mu[i]=1,mr[i]=md[i]=R;add(S,R*2+i,0,1);add(R*2+L+i,T,0,1);}\n\tfor (int i=1;i<=m;i++)\n\tif (b[i].r>=L) continue;\n\telse if (b[i].typ=='L') chkmax(ml[b[i].r+1],b[i].x+1);\n\telse if (b[i].typ=='R') chkmin(mr[L-b[i].r],b[i].x-1);\n\telse if (b[i].typ=='D') chkmax(mu[b[i].r+1],b[i].x+1);\n\telse if (b[i].typ=='U') chkmin(md[L-b[i].r],b[i].x-1);\n\tfor (int i=2;i<=L;i++) chkmax(ml[i],ml[i-1]),chkmax(mu[i],mu[i-1]);\n\tfor (int i=L-1;i;i--)  chkmin(md[i],md[i+1]),chkmin(md[i],md[i+1]);\n\tfor (int i=1;i<=L;i++){\n\t\tfor (int j=ml[i];j<=mr[i];j++) add(R*2+i,j,0,1);\n\t\tfor (int j=mu[i];j<=md[i];j++) add(j+R,R*2+L+i,0,1);\n\t}\n\tcost=0;\n\tif (dinic()==L) ans=max(ans,cost);\n//\tfor (int i=1;i<=n;i++) if (!e[i*2].fl) printf(\"%d \",i);\n//\tprintf(\"\\n\");\n}\nint main(){\n\tn=read();\n\tfor (int i=1;i<=n;i++) scanf(\" %d %d %lld\",&a[i].x,&a[i].y,&a[i].w);\n\tm=read();\n\tfor (int i=1;i<=m;i++) scanf(\" %c %d %d\",&b[i].typ,&b[i].x,&b[i].r);\n\tfor (int i=1;i<=n;i++) calc(i);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 1000005\nint tot,last[N],to[N],Next[N],flow[N];\nlong long val[N],dis[N];\nint e[N],q[10000005],S,T,Lx[N],Rx[N],Ly[N],Ry[N];\nint X[N],Y[N],n,m,pre[N];\nstruct node {\n  \tint id,x,y;\n}b[N],A[N];\nstruct pa {\n  \tint x,y;\n  \tlong long v;\n}a[N];\ninline void add(int x,int y,int f,long long v) {\n  Next[++tot]=last[x]; last[x]=tot; to[tot]=y; flow[tot]=f; val[tot]=v;\n}\n#define inf 1000000000000000000ll\ninline bool spfa() {\n  \tfor (int i=S;i<=T;i++) pre[i]=0,dis[i]=-inf,e[i]=0;\n  \tdis[S]=0; e[S]=1;\n  \tint l=0,r=1; q[1]=S;\n  \twhile (l<r) {\n      \tint k=q[++l];\n      \tfor (int i=last[k];i;i=Next[i]) {\n          \tif (!flow[i]||dis[to[i]]>=dis[S]+val[i]) continue;\n          \tdis[to[i]]=dis[S]+val[i];\n          \tpre[to[i]]=i;\n          \tif (!e[to[i]]) e[q[++r]=to[i]]=1;\n        }\n      \te[k]=0;\n    }\n  \treturn dis[T]!=-inf;\n}\ninline long long dinic(int y) {\n  \tlong long ans=0;\n  \tint s=0;\n  \twhile (spfa()) {\n      \ts++;\n      \tfor (int x=T;x!=S;x=to[pre[x]^1]) flow[pre[x]]--,flow[pre[x]^1]++,ans+=val[pre[x]];\n    }\n  \tif (s!=y) return 0;\n  \treturn ans;\n}\ninline long long work(int x) {\n  for (int i=1;i<=m;i++) if (b[i].id&1) A[i]=b[i];\n  else A[i]=node{b[i].id,x-b[i].x,b[i].y};\n  for (int i=1;i<=m;i++) if (A[i].x<0||(A[i].x==0&&!(A[i].id&1))) return 0;\n  for (int i=1;i<=x;i++) X[i]=2*n+i,Y[i]=2*n+i+x;\n  S=0,T=Y[x]+1;\n  for (int i=S;i<=T;i++) last[i]=0;\n  tot=1;\n  for (int i=1;i<=x;i++) Lx[i]=Ly[i]=1,Rx[i]=Ry[i]=100;\n  for (int i=1;i<=m;i++) {\n    if (A[i].id==1) Lx[A[i].x+1]=max(Lx[A[i].x+1],A[i].y+1);\n    else if (A[i].id==2) Rx[A[i].x]=min(Rx[A[i].x],A[i].y);\n    else if (A[i].id==3) Ly[A[i].x+1]=max(Ly[A[i].x+1],A[i].y+1);\n    else Ry[A[i].x]=min(Ry[A[i].x],A[i].y);\n  }\n  for (int i=1;i<=x;i++) Lx[i]=max(Lx[i],Lx[i-1]),Ly[i]=max(Ly[i],Ly[i-1]);\n  for (int i=x-1;i;i--) Rx[i]=min(Rx[i],Rx[i+1]),Ry[i]=min(Ry[i],Ry[i+1]);\n  for (int i=1;i<=x;i++) if (Lx[i]>Rx[i]) return false;\n  for (int i=1;i<=x;i++) add(S,X[i],1,0),add(X[i],S,0,0),add(Y[i],T,1,0),add(T,Y[i],0,0);\n  for (int i=1;i<=x;i++)\n  for (int j=1;j<=n;j++) {\n    \tif (a[j].x>=Lx[i]&&a[j].x<=Rx[i]) add(X[i],j,1,0),add(j,X[i],0,0);\n    \tif (a[j].y>=Ly[i]&&a[j].y<=Ry[i]) add(j+n,Y[i],1,0),add(Y[i],j+n,0,0);\n  }\n  for (int i=1;i<=n;i++) add(i,i+n,1,a[i].v),add(i+n,i,0,-a[i].v);\n  return dinic(x);\n}\nchar c[15];\nint main() {\n  scanf(\"%d\",&n);\n  for (int i=1;i<=n;i++) scanf(\"%d%d%lld\",&a[i].x,&a[i].y,&a[i].v);\n  scanf(\"%d\",&m);\n  for (int i=1;i<=m;i++) {\n    \tscanf(\"%s\",c);\n    \tscanf(\"%d%d\",&b[i].y,&b[i].x);\n    \tif (c[0]=='L') b[i].id=1;\n    \tif (c[0]=='R') b[i].id=2;\n    \tif (c[0]=='D') b[i].id=3;\n    \tif (c[0]=='U') b[i].id=4;\n  }\n  long long ans=0;\n  for (int i=1;i<=n;i++) \n\tans=max(ans,work(i));\n  printf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define beg(x) x.begin()\n#define en(x) x.end()\n#define all(x) beg(x), en(x)\n#define resz resize\n\nconst int MOD = 1000000007; // 998244353\nconst ll INF = 1e18;\nconst int MX = 100001;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\ntemplate<class A, class B> A operator+=(A& l, const B& r) { return l = l+r; }\ntemplate<class A, class B> A operator-=(A& l, const B& r) { return l = l-r; }\ntemplate<class A, class B> A operator*=(A& l, const B& r) { return l = l*r; }\ntemplate<class A, class B> A operator/=(A& l, const B& r) { return l = l/r; }\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { \n        re(first); re(rest...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        pr(first); pr(rest...); \n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(\"{\",x.f,\", \",x.s,\"}\"); \n    }\n    template<class T> void prContain(const T& x) {\n        pr(\"{\");\n        bool fst = 1; trav(a,x) pr(!fst?\", \":\"\",a), fst = 0; \n        pr(\"}\");\n    }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n    \n    void ps() { pr(\"\\n\"); } \n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) { \n        pr(first,\" \"); ps(rest...); // print w/ spaces\n    }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n    a %= b; if (a == 0) return b == 1 ? 0 : -1;\n    T x = invGeneral(b,a); \n    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modInt {\n    T val;\n    T mod = 0;\n    // static const T mod = MOD;\n\n    void normalize() {\n        if (mod == 0) return;\n        val %= mod; if (val < 0) val += mod;\n    }\n    modInt(T v = 0, T m = 0) : val(v), mod(m) { normalize(); }\n    // modInt(T v = 0, T m = 0) : val(v) { normalize(); }\n\n    explicit operator T() const { return val; }\n    friend ostream& operator<<(ostream& os, const modInt& a) { return os << a.val; }\n    friend bool operator==(const modInt& a, const modInt& b) { return a.val == b.val; }\n    friend bool operator!=(const modInt& a, const modInt& b) { return !(a == b); }\n\n    friend void check(modInt& a, modInt& b) { // make sure all operations are valid\n        // comment out if mod is static const\n        if (a.mod > 0 && b.mod > 0) { assert(a.mod == b.mod); return; }\n        T mod = max(a.mod,b.mod); if (mod == 0) mod = MOD;\n        if (a.mod != mod) { a.mod = mod; a.normalize(); }\n        if (b.mod != mod) { b.mod = mod; b.normalize(); }\n    }\n    friend modInt operator+(modInt a, modInt b) {\n        check(a,b); a.val += (T)b;\n        if (a.val >= a.mod) a.val -= a.mod;\n        return a;\n    }\n    friend modInt operator-(modInt a, modInt b) {\n        check(a,b); a.val -= (T)b; \n        if (a.val < 0) a.val += a.mod; \n        return a;\n    }\n    friend modInt operator-(const modInt& a) { return modInt(0)-a; }\n\n    friend modInt operator*(modInt a, modInt b) {\n        check(a,b); a.val = (ll)a.val*(T)b%a.mod; return a;\n    }\n    friend modInt exp(modInt a, ll p) {\n        modInt ans(1,a.mod);\n        for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n        return ans;\n    }\n    friend modInt inv(const modInt& a) {\n        return {invGeneral(a.val,a.mod),a.mod};\n        // return exp(b,b.mod-2) if prime\n    }\n    friend modInt operator/(modInt a, modInt b) { \n        check(a,b); return a*inv(b); \n    }\n};\n\ntypedef modInt<int> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\n\ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\n\ntemplate<class T> T poll(pqg<T>& x) {\n    T y = x.top(); x.pop();\n    return y;\n}\n\ntemplate<int SZ> struct mcf { // assume no negative cycles\n    struct Edge { int v, rev; ll flow, cap, cost; };\n\n    vector<Edge> adj[SZ];\n\n    void addEdge(int u, int v, ll cap, ll cost) {\n        Edge a{v, sz(adj[v]), 0, cap, cost}, b{u, sz(adj[u]), 0, 0, -cost};\n        adj[u].pb(a), adj[v].pb(b);\n    }\n\n    int ST, EN;\n    pi pre[SZ]; // previous vertex, edge label on path\n    pl cost[SZ]; // tot cost of path, amount of flow\n    ll totFlow, totCost, curCost;\n\n    void reweight() { // ensures all non-negative edge weights\n    \tF0R(i,SZ) trav(p,adj[i]) p.cost += cost[i].f-cost[p.v].f;\n    }\n\n    bool spfa() { // reweighting will ensure that there will be negative weights only during the first time you run this\n        F0R(i,SZ) cost[i] = {INF,0};\n        cost[ST] = {0,INF};\n        pqg<pair<ll,int>> todo; todo.push({0,ST});\n\n        while (sz(todo)) {\n            auto x = poll(todo); if (x.f > cost[x.s].f) continue;\n            trav(a,adj[x.s]) if (x.f+a.cost < cost[a.v].f && a.flow < a.cap) {\n                pre[a.v] = {x.s,a.rev};\n                cost[a.v] = {x.f+a.cost, min(a.cap-a.flow,cost[x.s].s)};\n                todo.push({cost[a.v].f,a.v});\n            }\n        }\n\n        curCost += cost[EN].f; return cost[EN].s;\n    }\n\n    void backtrack() {\n        auto f = cost[EN].s; totFlow += f, totCost += curCost*f;\n        for (int x = EN; x != ST; x = pre[x].f) {\n            adj[x][pre[x].s].flow -= f;\n            adj[pre[x].f][adj[x][pre[x].s].rev].flow += f;\n        }\n    }\n\n    pl minCostFlow(int _ST, int _EN) {\n        ST = _ST, EN = _EN; totFlow = totCost = curCost = 0;\n        spfa();\n        while (1) {\n            reweight();\n            if (!spfa()) return {totFlow, totCost};\n            backtrack();\n        }\n    }\n};\n\nll ans;\n\nint N,M;\nvpi L,R,U,D;\nvi l,r,d,u;\nvector<array<ll,3>> v;\n\nvoid nor(vpi& v) {\n    if (sz(v)) ckmin(v[0].s,N);\n    FOR(i,1,sz(v)) ckmin(v[i].s,v[i-1].s);\n}\n\nvoid init() {\n    setIO(); re(N);\n    v.resz(N); re(v);\n    re(M);\n    F0R(i,M) {\n        char t; int a,b; re(t,a,b);\n        switch(t) {\n            case 'L': L.pb({a,b});\n            break;\n            case 'R': R.pb({a,b});\n            break;\n            case 'U': U.pb({a,b});\n            break;\n            case 'D': D.pb({a,b});\n            break;\n        }\n    }\n    sort(L.rbegin(), L.rend()); nor(L);\n    sort(all(R)); nor(R);\n    sort(D.rbegin(), D.rend()); nor(D);\n    sort(all(U)); nor(U);\n}\n\nvoid test(int num) {\n    mcf<322> m;\n    FOR(i,1,num+1) {\n        m.addEdge(0,i,1,0);\n        // ps(\"HAH\",l[i-1],)\n        F0R(j,N) if (l[i-1] <= v[j][0] && v[j][0] <= r[num-i]) m.addEdge(i,num+1+j,1,0); // x,y,value\n    }\n    F0R(i,N) m.addEdge(num+1+i,num+1+i+N,1,-v[i][2]);\n    FOR(i,1,num+1) {\n        m.addEdge(num+2*N+i,2*N+2*num+1,1,0);\n        F0R(j,N) if (d[i-1] <= v[j][1] && v[j][1] <= u[num-i]) m.addEdge(num+N+j+1,num+2*N+i,1,0);\n    }\n    auto a = m.minCostFlow(0,2*N+2*num+1);\n    // ps(\"HUH\",num,a);\n    if (a.f != num) {\n        cout << ans;\n        exit(0);\n    }\n    ckmax(ans,-a.s);\n}\n\nint main() {\n    init();\n    pi lst = {1,0}; reverse(all(L));\n    F0R(i,sz(L)) {\n        F0R(j,L[i].s-lst.s) l.pb(lst.f);\n        lst = {L[i].f+1,L[i].s};\n    }\n    F0R(i,N-lst.s) l.pb(lst.f);\n    \n    lst = {100,0}; reverse(all(R));\n    F0R(i,sz(R)) {\n        F0R(j,R[i].s-lst.s) r.pb(lst.f);\n        lst = {R[i].f-1,R[i].s};\n    }\n    F0R(i,N-lst.s) r.pb(lst.f);\n    \n    lst = {1,0}; reverse(all(D));\n    F0R(i,sz(D)) {\n        F0R(j,D[i].s-lst.s) d.pb(lst.f);\n        lst = {D[i].f+1,D[i].s};\n    }\n    F0R(i,N-lst.s) d.pb(lst.f);\n    \n    lst = {100,0}; reverse(all(U));\n    F0R(i,sz(U)) {\n        F0R(j,U[i].s-lst.s) u.pb(lst.f);\n        lst = {U[i].f-1,U[i].s};\n    }\n    F0R(i,N-lst.s) u.pb(lst.f);\n    // ps(l,r,d,u);\n    FOR(i,1,N+1) test(i);\n    ps(ans);\n    \n}\n\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define itn int\n#define all(x) (x).begin(), (x).end()\n#define make_unique(x) sort(all((x))); (x).resize(unique(all((x))) - (x).begin())\n\n#define random_shuffle(...) shuffle(__VA_ARGS__, rng)\n#define rand() rng()\n\nusing namespace std;\n\ninline int nxt() {\n\tint x;\n\tscanf(\"%d\", &x);\n\treturn x;\n}\n\n#define sz(x) ((int) (x).size())\n#define forn(i,n) for (int i = 0; i < int(n); ++i)\n\ntypedef long long ll;\ntypedef long long i64;\ntypedef long double ld;\nconst int inf = int(1e9) + int(1e5);\nconst ll infl = ll(2e18) + ll(1e10);\n\nconst int maxn = 505;\nconst int maxm = 505;\n\nconst ld eps = 1e-6;\n\nbool eq(ld a, ld b) {\n    return fabsl(a - b) < eps;\n}\n\n//BEGIN_CODE\nnamespace Simplex {\n\nld D[maxm][maxn]; // [n+2][m+2]\nint B[maxm];\nint N[maxn];\nld x[maxn];\nint n, m;\n\n//x >= 0, Ax <= b, c^Tx -> max\nvoid init(int _n, int _m, ld A[][maxn], ld *b, ld *c) {\n    n = _n, m = _m;\n    forn (i, m)\n        forn (j, n)\n            D[i][j] = -A[i][j];\n    forn (i, m) {\n        D[i][n] = 1;\n        D[i][n + 1] = b[i];\n    }\n    forn (j, n) {\n        D[m][j] = c[j];\n        D[m + 1][j] = 0;\n    }\n    D[m][n + 1] = D[m][n] = D[m + 1][n + 1] = 0;\n    D[m + 1][n] = -1;\n    iota(B, B + m, n);\n    iota(N, N + n, 0);\n    N[n] = -1;\n}\n\nvoid pivot(int b, int nb) {\n    assert(D[b][nb] != 0);\n    ld q = 1. / -D[b][nb];\n    D[b][nb] = -1;\n    forn (i, n + 2)\n        D[b][i] *= q;\n    forn (i, m + 2) {\n        if (i == b)\n            continue;\n        ld coef = D[i][nb];\n        D[i][nb] = 0;\n        forn (j, n + 2)\n            D[i][j] += coef * D[b][j];\n    }\n    swap(B[b], N[nb]);\n}\n\nbool betterN(int f, int i, int j) {\n    if (eq(D[f][i], D[f][j]))\n        return N[i] < N[j];\n    return D[f][i] > D[f][j];\n}\n\nbool betterB(int nb, int i, int j) {\n    ld ai = D[i][n + 1] / D[i][nb];\n    ld aj = D[j][n + 1] / D[j][nb];\n    if (eq(ai, aj))\n        return B[i] < B[j];\n    return ai > aj;\n}\n\nbool simplex(int phase) {\n    int f = phase == 1 ? m : m + 1;\n    while (true) {\n        int nb = -1;\n        forn (i, n + 1) {\n            if (N[i] == -1 && phase == 1)\n                continue;\n            if (nb == -1 || betterN(f, i, nb))\n                nb = i;\n        }\n        if (D[f][nb] <= eps)\n            return phase == 1;\n        assert(nb != -1);\n\n        int b = -1;\n        forn (i, m) {\n            if (D[i][nb] >= -eps)\n                continue;\n            if (b == -1 || betterB(nb, i, b))\n                b = i;\n        }\n        if (b == -1)\n            return false;\n        pivot(b, nb);\n        if (N[nb] == -1 && phase == 2)\n            return true;\n    }\n}\n\nld solve() {\n    int b = -1;\n    forn (i, m) {\n        if (b == -1 || D[i][n + 1] < D[b][n + 1])\n            b = i;\n    }\n    assert(b != -1);\n    if (D[b][n + 1] < -eps) {\n        pivot(b, n);\n        if (!simplex(2) || D[m + 1][n + 1] < -eps)\n            return -infl;\n    }\n    if (!simplex(1))\n        return infl;\n\n    forn (i, n)\n        x[i] = 0;\n    forn (i, m)\n        if (B[i] < n)\n            x[B[i]] = D[i][n + 1];\n\n    return D[m][n + 1];\n}\n\n} //Simplex\n//END_CODE\n\nstruct Treasure {\n\tint x, y;\n\tlong long v;\n\n\tvoid scan() {\n\t\tscanf(\"%d%d%lld\", &x, &y, &v);\n\t}\n};\n\nstruct Constraint {\n\tchar t;\n\tint a, b;\n\n\tvoid scan() {\n\t\tcin >> t >> a >> b;\n\t}\n\n\tbool isAbout(const Treasure& tr) const {\n\t\tif (t == 'D') {\n\t\t\treturn tr.y <= a;\n\t\t} else if (t == 'U') {\n\t\t\treturn tr.y >= a;\n\t\t} else if (t == 'L') {\n\t\t\treturn tr.x <= a;\n\t\t} else if (t == 'R') {\n\t\t\treturn tr.x >= a;\n\t\t} else {\n\t\t\tassert(false);\n\t\t}\n\t}\n};\n\nld a[maxm][maxn];\nld b[maxm];\nld c[maxn];\n\nint main() {\n\tmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n\tint n = nxt();\n\tvector<Treasure> trs(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\ttrs[i].scan();\n\t}\n\n\tint m = nxt();\n\tvector<Constraint> crs(m);\n\tfor (int i = 0; i < m; ++i) {\n\t\tcrs[i].scan();\n\t}\n\n\tfor (int i = 0; i < m; ++i) {\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\ta[i][j] = crs[i].isAbout(trs[j]);\n\t\t}\n\t\tb[i] = crs[i].b;\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\ta[m + i][i] = 1;\n\t\tb[m + i] = 1;\n\t\tc[i] = trs[i].v;\n\t}\n\n\tSimplex::init(n, n + m, a, b, c);\n\tSimplex::solve();\n\n\tlong long ans = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tans += trs[i].v * (int)(roundl(Simplex::x[i]));\n\t}\n\tcout << ans << \"\\n\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace __gnu_pbds;\nusing namespace std;\n \ntemplate <typename T>\nusing ordered_set =\n\ttree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n \n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n\t*this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n \n#define shandom_ruffle random_shuffle\n \nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=327;\nusing bn=bitset<87>;\nusing ld=long double;\n\nint n;\npii gdz[nax];\nll war[nax];\n\nint m;\nbn podz[nax];\nint ile[nax];\n\nll wyn;\n\nbn ter;\n \nll dajwar()\n{\n\tll ret=0;\n\tfor (int i=1; i<=n; i++)\n\t\tif (ter[i])\n\t\t\tret+=war[i];\n\treturn ret;\n}\n \nint popr()\n{\n\tfor (int i=1; i<=m; i++)\n\t\tif ((podz[i]&ter).count()>ile[i])\n\t\t\treturn 0;\n\treturn 1;\n}\n\nvi kol;\n\nstruct Simplex {        // Maximize c*x subject to Ax <= b.\n  using T = ld;     // Initialize the structure, set A, b, c and then run\n  vector<vector<T>> A;  // solve(). Max objective is stored in res. To recover\n  vector<T> b, c;       // the best result, use getVars().\n  int V, E;\n  vector<int> eqIds, varIds, cols;\n  T res;\n  static constexpr T kEps = 1e-5;\n\n  Simplex(int vars, int eqs) : A(eqs, vector<T>(vars)), b(eqs), c(vars),\n      V(vars), E(eqs), eqIds(eqs), varIds(vars), res(0) {\n    iota(varIds.begin(), varIds.end(), 0);\n    iota(eqIds.begin(), eqIds.end(), vars);\n  }\n\n  void pivot(int eq, int var) {\n    T coef = 1 / A[eq][var];\n    cols.clear();\n    for (int i = 0; i < V; i++) {\n      if (abs(A[eq][i]) > kEps) { cols.push_back(i); A[eq][i] *= coef; }\n    }\n    A[eq][var] *= coef; b[eq] *= coef;\n    for (int row = 0; row < E; row++) {\n      if (row == eq || abs(A[row][var]) < kEps) { continue; }\n      T k = -A[row][var];\n      A[row][var] = 0;\n      for (int i : cols) { A[row][i] += k * A[eq][i]; }\n      b[row] += k * b[eq];\n    }\n    T q = c[var]; c[var] = 0;\n    for (int i : cols) { c[i] -= q * A[eq][i]; }\n    res += q * b[eq];\n    swap(varIds[var], eqIds[eq]);\n  }\n\n  bool solve() {\n    while (true) {\n      int eq = -1, var = -1;\n      for (int i = 0; i < E; i++) { if (b[i] < -kEps) { eq = i; break; } }\n      if (eq == -1) { break; }\n      for (int i = 0; i < V; i++) { if (A[eq][i] < -kEps) { var = i; break; } }\n      if (var == -1) { res = -1e9; return false; /* No solution */ }\n      pivot(eq, var);\n    }\n    while (true) {\n      int var = -1, eq = -1;\n      for (int i = 0; i < V; i++) { if (c[i] > kEps) { var = i; break; } }\n      if (var == -1) { break; }\n      for (int i = 0; i < E; i++) {\n        if (A[i][var] < kEps) { continue; }\n        if (eq >= 0 && b[i] / A[i][var] >= b[eq] / A[eq][var]) { continue; }\n        eq = i;\n      }\n      if (eq == -1) { res = 1e9; return false; /* Unbounded */ }\n      pivot(eq, var);\n    }\n    return true;\n  }\n\n  vector<T> getVars() { // Optimal assignment of variables.\n    vector<T> result(V);\n    for (int i = 0; i < E; i++) if (eqIds[i] < V) result[eqIds[i]] = b[i];\n    return result;\n  }\n};\n\nvoid rek(int v, int jesz)\n{\n\tif (popr())\n\t\twyn=max(wyn, dajwar());\n\tif (!jesz)\n\t\treturn;\n\tfor (int i=v; i<=n; i++)\n\t{\n\t\tter.flip(i);\n\t\trek(i+1, jesz-1);\n\t\tter.flip(i);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(\"%d%d%lld\", &gdz[i].first, &gdz[i].second, &war[i]);\n\tscanf(\"%d\", &m);\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\tchar c;\n\t\tint a, b;\n\t\tscanf(\" %c%d%d\", &c, &a, &b);\n\t\tfor (int j=1; j<=n; j++)\n\t\t{\n\t\t\tif (c=='L' && gdz[j].first<=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='R' && gdz[j].first>=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='D' && gdz[j].second<=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='U' && gdz[j].second>=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t}\n\t\tile[i]=b;\n\t}\n\tSimplex janusz(n, m+2*n);\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tjanusz.c[i]=war[i+1];\n\t}\n\tfor (int i=0; i<m; i++)\n\t{\n\t\tjanusz.b[i]=ile[i+1];\n\t\tfor (int j=0; j<n; j++)\n\t\t\tjanusz.A[i][j]=podz[i+1][j+1];\n\t}\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tjanusz.b[m+i]=1;\n\t\tjanusz.A[m+i][i]=1;\n\t}\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tjanusz.b[m+n+i]=0;\n\t\tjanusz.A[m+n+i][i]=-1;\n\t}\n\tassert(janusz.solve());\n\tauto wez=janusz.getVars();\n\t\n\tvector <pair<ld,int> > wek;\n\tfor (int i=1; i<=n; i++)\n\t\twek.push_back({wez[i], i});\n\t\n\tsort(wek.begin(), wek.end());\n\treverse(wek.begin(), wek.end());\n\t\n\tfor (auto i : wek)\n\t{\n\t\tter[i.second]=1;\n\t\tif (!popr())\n\t\t\tter[i.second]=0;\n\t}\n\t\n\trek(1, 4+(n<=70));\n\t\n\tdebug() << janusz.getVars();\n\tprintf(\"%lld\\n\", wyn);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 432, inf = 1e9;\nconst long long llinf = 1e18;\n\nstruct edge_t {\n  int to, cap, flow;\n  long long cost;\n\n  edge_t() {\n  }\n\n  edge_t(int to, int cap, int flow, long long cost): to(to), cap(cap), flow(flow), cost(cost) {\n  }\n};\n\nclass flow_t {\n  int n, s, t, cur[N];\n  vector<edge_t> edges;\n  vector<int> adj[N];\n  long long d[N];\n  bool visit[N], inq[N];\n\n  bool bfs() {\n    for (int i = 0; i < n; ++i) {\n      d[i] = llinf;\n    }\n    memset(cur, 0, sizeof cur);\n    memset(visit, false, sizeof visit);\n    memset(inq, false, sizeof inq);\n    queue<int> q;\n    q.push(s);\n    d[s] = 0;\n    while (!q.empty()) {\n      int x = q.front();\n      q.pop();\n      inq[x] = false;\n      for (auto i : adj[x]) {\n        edge_t e = edges[i];\n        if (e.flow < e.cap && d[e.to] > d[x] + e.cost) {\n          d[e.to] = d[x] + e.cost;\n          if (!inq[e.to]) {\n            inq[e.to] = true;\n            q.push(e.to);\n          }\n        }\n      }\n    }\n    return d[t] != llinf;\n  }\n\n  pair<int, long long> dfs(int x, int a) {\n    if (x == t || !a) {\n      return pair<int, long long>(a, 0);\n    } else {\n      visit[x] = true;\n      pair<int, long long> result(0, 0);\n      for (int& i = cur[x]; i < adj[x].size(); ++i) {\n        edge_t& e = edges[adj[x][i]];\n        if (d[e.to] == d[x] + e.cost && !visit[e.to]) {\n          pair<int, long long> go = dfs(e.to, min(a, e.cap - e.flow));\n          if (go.first > 0) {\n            e.flow += go.first;\n            edges[adj[x][i] ^ 1].flow -= go.first;\n            result.first += go.first;\n            result.second += go.second + go.first * e.cost;\n            a -= go.first;\n            if (!a) {\n              break;\n            }\n          }\n        }\n      }\n      return result;\n    }\n  }\n\n public:\n  flow_t() {\n  }\n\n  flow_t(int n, int s, int t): n(n), s(s), t(t) {\n  }\n\n  void add_edge(int x, int y, int cap, long long cost) {\n    edges.emplace_back(y, cap, 0, cost);\n    edges.emplace_back(x, 0, 0, -cost);\n    adj[x].push_back(edges.size() - 2);\n    adj[y].push_back(edges.size() - 1);\n  }\n\n  pair<int, long long> min_cost_max_flow() {\n    pair<int, long long> result(0, 0);\n    while (bfs()) {\n      pair<int, long long> t = dfs(s, inf);\n      result.first += t.first;\n      result.second += t.second;\n    }\n    return result;\n  }\n};\n\nint n, m, x[N], y[N], a[N], b[N], l[N], r[N];\nlong long w[N];\nstring t[N];\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n;\n  for (int i = 1; i <= n; ++i) {\n    cin >> x[i] >> y[i] >> w[i];\n  }\n  cin >> m;\n  for (int i = 1; i <= m; ++i) {\n    cin >> t[i] >> a[i] >> b[i];\n  }\n  long long answer = 0;\n  auto solve = [&] (int take) {\n    for (int i = 1; i <= take; ++i) {\n      l[i] = l[take + i] = 1;\n      r[i] = r[take + i] = 100;\n    }\n    for (int i = 1; i <= m; ++i) {\n      if (b[i] < take) {\n        if (t[i] == \"L\") {\n          l[b[i] + 1] = a[i] + 1;\n        }\n        if (t[i] == \"R\") {\n          r[take - b[i]] = a[i] - 1;\n        }\n        if (t[i] == \"D\") {\n          l[b[i] + 1 + take] = a[i] + 1;\n        }\n        if (t[i] == \"U\") {\n          r[take - b[i] + take] = a[i] - 1;\n        }\n      }\n    }\n    for (int i = 2; i <= take; ++i) {\n      l[i] = max(l[i], l[i - 1]);\n      l[take + i] = max(l[take + i], l[take + i - 1]);\n    }\n    for (int i = take - 1; i; --i) {\n      r[i] = min(r[i], r[i + 1]);\n      r[take + i] = min(r[take + i], r[take + i + 1]);\n    }\n    int s = 0, t = 200 + take * 2 + 1;\n    flow_t graph(t + 1, s, t);\n    for (int i = 1; i <= take; ++i) {\n      if (l[i] > r[i] || l[take + i] > r[take + i]) {\n        return 0ll;\n      }\n      graph.add_edge(s, 200 + i, 1, 0);\n      graph.add_edge(200 + take + i, t, 1, 0);\n      for (int j = l[i]; j <= r[i]; ++j) {\n        graph.add_edge(200 + i, j, 1, 0);\n      }\n      for (int j = l[take + i]; j <= r[take + i]; ++j) {\n        graph.add_edge(100 + j, 200 + take + i, 1, 0);\n      }\n    }\n    for (int i = 1; i <= n; ++i) {\n      graph.add_edge(x[i], 100 + y[i], 1, -w[i]);\n    }\n    return -graph.min_cost_max_flow().second;\n  };\n  for (int take = 1; take <= n; ++take) {\n    answer = max(answer, solve(take));\n  }\n  cout << answer << '\\n';\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace __gnu_pbds;\nusing namespace std;\n \ntemplate <typename T>\nusing ordered_set =\n\ttree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n \n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n\t*this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n \n#define shandom_ruffle random_shuffle\n \nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=327;\nusing bn=bitset<87>;\nusing ld=long double;\n\nint n;\npii gdz[nax];\nll war[nax];\n\nint m;\nbn podz[nax];\nint ile[nax];\n\nll wyn;\n\nbn ter;\n \nll dajwar()\n{\n\tll ret=0;\n\tfor (int i=1; i<=n; i++)\n\t\tif (ter[i])\n\t\t\tret+=war[i];\n\treturn ret;\n}\n \nint popr()\n{\n\tfor (int i=1; i<=m; i++)\n\t\tif ((podz[i]&ter).count()>ile[i])\n\t\t\treturn 0;\n\treturn 1;\n}\n\nstruct Simplex {        // Maximize c*x subject to Ax <= b.\n  using T = ld;     // Initialize the structure, set A, b, c and then run\n  vector<vector<T>> A;  // solve(). Max objective is stored in res. To recover\n  vector<T> b, c;       // the best result, use getVars().\n  int V, E;\n  vector<int> eqIds, varIds, cols;\n  T res;\n  static constexpr T kEps = 1e-5;\n\n  Simplex(int vars, int eqs) : A(eqs, vector<T>(vars)), b(eqs), c(vars),\n      V(vars), E(eqs), eqIds(eqs), varIds(vars), res(0) {\n    iota(varIds.begin(), varIds.end(), 0);\n    iota(eqIds.begin(), eqIds.end(), vars);\n  }\n\n  void pivot(int eq, int var) {\n    T coef = 1 / A[eq][var];\n    cols.clear();\n    for (int i = 0; i < V; i++) {\n      if (abs(A[eq][i]) > kEps) { cols.push_back(i); A[eq][i] *= coef; }\n    }\n    A[eq][var] *= coef; b[eq] *= coef;\n    for (int row = 0; row < E; row++) {\n      if (row == eq || abs(A[row][var]) < kEps) { continue; }\n      T k = -A[row][var];\n      A[row][var] = 0;\n      for (int i : cols) { A[row][i] += k * A[eq][i]; }\n      b[row] += k * b[eq];\n    }\n    T q = c[var]; c[var] = 0;\n    for (int i : cols) { c[i] -= q * A[eq][i]; }\n    res += q * b[eq];\n    swap(varIds[var], eqIds[eq]);\n  }\n\n  bool solve() {\n    while (true) {\n      int eq = -1, var = -1;\n      for (int i = 0; i < E; i++) { if (b[i] < -kEps) { eq = i; break; } }\n      if (eq == -1) { break; }\n      for (int i = 0; i < V; i++) { if (A[eq][i] < -kEps) { var = i; break; } }\n      if (var == -1) { res = -1e9; return false; /* No solution */ }\n      pivot(eq, var);\n    }\n    while (true) {\n      int var = -1, eq = -1;\n      for (int i = 0; i < V; i++) { if (c[i] > kEps) { var = i; break; } }\n      if (var == -1) { break; }\n      for (int i = 0; i < E; i++) {\n        if (A[i][var] < kEps) { continue; }\n        if (eq >= 0 && b[i] / A[i][var] >= b[eq] / A[eq][var]) { continue; }\n        eq = i;\n      }\n      if (eq == -1) { res = 1e9; return false; /* Unbounded */ }\n      pivot(eq, var);\n    }\n    return true;\n  }\n\n  vector<T> getVars() { // Optimal assignment of variables.\n    vector<T> result(V);\n    for (int i = 0; i < E; i++) if (eqIds[i] < V) result[eqIds[i]] = b[i];\n    return result;\n  }\n};\n\nvoid rek(int v, int jesz)\n{\n\tif (popr())\n\t\twyn=max(wyn, dajwar());\n\tif (!jesz)\n\t\treturn;\n\tfor (int i=v; i<=n; i++)\n\t{\n\t\tter.flip(i);\n\t\trek(i+1, jesz-1);\n\t\tter.flip(i);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(\"%d%d%lld\", &gdz[i].first, &gdz[i].second, &war[i]);\n\tscanf(\"%d\", &m);\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\tchar c;\n\t\tint a, b;\n\t\tscanf(\" %c%d%d\", &c, &a, &b);\n\t\tfor (int j=1; j<=n; j++)\n\t\t{\n\t\t\tif (c=='L' && gdz[j].first<=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='R' && gdz[j].first>=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='D' && gdz[j].second<=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='U' && gdz[j].second>=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t}\n\t\tile[i]=b;\n\t}\n\tSimplex janusz(n, m+2*n);\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tjanusz.c[i]=war[i+1];\n\t}\n\tfor (int i=0; i<m; i++)\n\t{\n\t\tjanusz.b[i]=ile[i+1];\n\t\tfor (int j=0; j<n; j++)\n\t\t\tjanusz.A[i][j]=podz[i+1][j+1];\n\t}\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tjanusz.b[m+i]=1;\n\t\tjanusz.A[m+i][i]=1;\n\t}\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tjanusz.b[m+n+i]=0;\n\t\tjanusz.A[m+n+i][i]=-1;\n\t}\n\tassert(janusz.solve());\n\tauto wez=janusz.getVars();\n\t\n\tfor (int i=0; i<n; i++)\n\t\tter[i+1]=(wez[i]>0.5);\n\t\n\tll sta=dajwar();\n\t\n\twhile(popr())\n\t{\n\t\tint czy=0;\n\t\tfor (int i=1; i<=n; i++)\n\t\t{\n\t\t\tif (!ter[i])\n\t\t\t{\n\t\t\t\tter[i]=1;\n\t\t\t\tif (popr())\n\t\t\t\t\tczy=1;\n\t\t\t\telse\n\t\t\t\t\tter[i]=0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (!czy)\n\t\t\tbreak;\n\t}\n\t\n\trek(1, 4+(n<=65));\n\t\n\tdebug() << janusz.getVars();\n\tprintf(\"%lld\\n\", wyn);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#define M_ 201000\n#define N_ 10100\nusing namespace std;\n\nstruct MinimumCostFlow {\n\tstruct Edge {\n\t\tint b, e, f;\n\t\tlong long c;\n\t}E[M_];\n\tint EC, source, sink, n, Q[M_*2], InQ[N_], Path[N_], flow;\n\tvector<int>G[N_];\n\tlong long D[N_], INF = 4e18, res;\n\n\tvoid init(int N, int S, int T) {\n\t\tn = N, source = S, sink = T;\n\t\tflow = EC = 0;\n\t\tres = 0;\n\t\tfor (int i = 0; i <= n; i++)G[i].clear();\n\t}\n\n\tvoid Add_Edge(int b, int e, int f, long long c) {\n\t\tG[b].push_back(EC);\n\t\tG[e].push_back(EC + 1);\n\t\tE[EC++] = { b,e,f,c };\n\t\tE[EC++] = { e,b,0,-c };\n\t}\n\n\tbool SPFA() {\n\t\tint i, head = 0, tail = 0;\n\t\tfor (i = 0; i <= n; i++)D[i] = -INF, Path[i] = 0, InQ[i] = 0;\n\t\tD[source] = 0; Q[++tail] = source, InQ[source] = 1;\n\t\twhile (head < tail) {\n\t\t\tint x = Q[++head];\n\t\t\tInQ[x] = 0;\n\t\t\tfor (auto &t : G[x]) {\n\t\t\t\tif (E[t].f) {\n\t\t\t\t\tif (D[E[t].e] < D[E[t].b] + E[t].c) {\n\t\t\t\t\t\tD[E[t].e] = D[E[t].b] + E[t].c;\n\t\t\t\t\t\tPath[E[t].e] = t;\n\t\t\t\t\t\tif (!InQ[E[t].e]) {\n\t\t\t\t\t\t\tInQ[E[t].e] = 1;\n\t\t\t\t\t\t\tQ[++tail] = E[t].e;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (D[sink] == -INF)return false;\n\t\tint x = sink;\n\t\twhile (x != source) {\n\t\t\tE[Path[x]].f--;\n\t\t\tE[Path[x] ^ 1].f++;\n\t\t\tx = E[Path[x]].b;\n\t\t}\n\t\tres += D[sink];\n\t\treturn true;\n\t}\n\n\tvoid MCMF() {\n\t\twhile (SPFA())flow++;\n\t}\n\n}MCF;\n\nstruct point {\n\tint x, y;\n\tlong long c;\n}w[81];\nstruct Query {\n\tchar ch;\n\tint a, c;\n}U[320];\nint n, m, L1[110], R1[110], L2[110], R2[110];\n\nlong long Solve(int K) {\n\tint i, j;\n\tfor (i = 0; i <= K + 1; i++) {\n\t\tL1[i] = L2[i] = 0;\n\t\tR1[i] = R2[i] = 100;\n\t}\n\tfor (i = 1; i <= m; i++) {\n\t\tif (U[i].c >= K)continue;\n\t\tif (U[i].ch == 'L') {\n\t\t\tL1[U[i].c + 1] = max(L1[U[i].c + 1], U[i].a + 1);\n\t\t}\n\t\tif (U[i].ch == 'R') {\n\t\t\tR1[K - U[i].c] = min(R1[K - U[i].c], U[i].a - 1);\n\t\t}\n\t\tif (U[i].ch == 'D') {\n\t\t\tL2[U[i].c + 1] = max(L2[U[i].c + 1], U[i].a + 1);\n\t\t}\n\t\tif (U[i].ch == 'U') {\n\t\t\tR2[K - U[i].c] = min(R2[K - U[i].c], U[i].a - 1);\n\t\t}\n\t}\n\tfor (i = 1; i <= K; i++) {\n\t\tL1[i] = max(L1[i - 1], L1[i]);\n\t\tL2[i] = max(L2[i - 1], L2[i]);\n\t}\n\tfor (i = K; i >= 1; i--) {\n\t\tR1[i] = min(R1[i + 1], R1[i]);\n\t\tR2[i] = min(R2[i + 1], R2[i]);\n\t}\n\tMCF.init(2 + K * 2 + 100 * 2, 1 + K * 2 + 100 * 2, 2 + K * 2 + 100 * 2);\n\tfor (i = 1; i <= K; i++) {\n\t\tMCF.Add_Edge(MCF.source, i, 1, 0);\n\t\tMCF.Add_Edge(i + K, MCF.sink, 1, 0);\n\t\tfor (j = L1[i]; j <= R1[i]; j++) {\n\t\t\tMCF.Add_Edge(i, K + K + j, 1, 0);\n\t\t}\n\t\tfor (j = L2[i]; j <= R2[i]; j++) {\n\t\t\tMCF.Add_Edge(K + K + 100 + j, K + i, 1, 0);\n\t\t}\n\t}\n\tfor (i = 1; i <= n; i++) {\n\t\tMCF.Add_Edge(K + K + w[i].x, K + K + 100 + w[i].y, 1, w[i].c);\n\t}\n\tMCF.MCMF();\n\tif (MCF.flow == K)return MCF.res;\n\treturn 0ll;\n}\n\nint main() {\n\tint i;\n\tscanf(\"%d\", &n);\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(\"%d%d%lld\", &w[i].x, &w[i].y, &w[i].c);\n\t}\n\tscanf(\"%d\", &m);\n\tfor (i = 1; i <= m; i++) {\n\t\tchar pp[3];\n\t\tint a, b;\n\t\tscanf(\"%s%d%d\", pp, &a, &b);\n\t\tU[i] = { pp[0],a,b };\n\t}\n\tlong long res = 0;\n\tfor (i = 1; i <= n; i++)res = max(res,Solve(i));\n\tprintf(\"%lld\\n\", res);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n\n#define fo(i,j,l) for(int i=j;i<=l;++i)\n#define fd(i,j,l) for(int i=j;i>=l;--i)\n#define eps 3e-1\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double db;\nconst ll N=1000;\nconst db sj=5e-20,op=1e7;\n\nint f1[N],f2[N];\nint s1[N],s2[N];\nint w[N];\nll x[N],y[N],v[N];\n\nint n,m,oo,a,b,o2;\ndb c[N],s[N][N];\nint bh[N];\ndb d[N];\nint dl[N];\nint g,gs;\ndb ans=0;\nll da=0;\n\ninline db iabs(db gg)\n{return (gg<0)?(-gg):gg;}\n\ninline void trans(int h,int k)\n{\n\tint u=bh[h]; bh[h]=k;\n\tdb xs=-s[h][k];\n\ts[h][k]=0; s[h][u]=-1;\n\tfo(i,1,g)s[h][i]=s[h][i]/xs;\n\tc[h]=c[h]/xs;\n\tfo(i,1,gs)if(i!=h&&s[i][k]!=0&&iabs(s[i][k])>sj){\n\t\tfo(l,1,g)s[i][l]=s[i][l]+s[i][k]*s[h][l];\n\t\tc[i]=c[i]+c[h]*s[i][k];\n\t\ts[i][k]=0;\n\t}\n\tfo(i,1,g)d[i]=d[i]+d[k]*s[h][i];\n\tans=ans+d[k]*c[h];\n\td[k]=0;\n}\n\ninline int find()\n{\n\tint po=0; d[0]=sj;\n\tfo(i,1,g)if(d[i]>d[po])po=i;\n\treturn po;\n}\n\ninline void Simplex()\n{\n\tint x;\n\twhile((x=find())!=0){\n\t\tdouble zd=100000000;\n\t\tint po=0;\n\t\tfo(i,1,gs)if(s[i][x]<-sj)if(c[i]/(-s[i][x])<zd)zd=c[i]/(-s[i][x]),po=i;\n\t\tif(!po)break;\n\t\ttrans(po,x);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfo(i,1,n){\n\t\tscanf(\"%lld%lld%lld\",&x[i],&y[i],&v[i]);\n\t}\n\tfo(i,1,n)d[i]=v[i]/op;\n\tscanf(\"%d\",&gs); m=gs;\n\tfo(i,1,m){\n\t\tchar ch=' ';\n\t\tfor(;ch!='L'&&ch!='R'&&ch!='U'&&ch!='D';ch=getchar());\n\t\tint aa,bb;\n\t\tscanf(\"%d%d\",&aa,&bb);\n\t\tc[i]=bb;\n\t\tif(ch=='L'){fo(l,1,n)if(x[l]<=aa)s[i][l]=-1;}\n\t\tif(ch=='R'){fo(l,1,n)if(x[l]>=aa)s[i][l]=-1;}\n\t\tif(ch=='D'){fo(l,1,n)if(y[l]<=aa)s[i][l]=-1;}\n\t\tif(ch=='U'){fo(l,1,n)if(y[l]>=aa)s[i][l]=-1;}\t\t\n\t}\n\tfo(i,1,n){\n\t\t++gs; c[gs]=1;\n\t\ts[gs][i]=-1;\n\t}\n\tg=m+n;\n\tSimplex();\n\tll da=(ll)(ans*op+eps);\n\tcout<<da;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n#define MAXN 100\n#define MAXM 500\n#define LL long long\nconst double eps=1e-10;\ndouble a[MAXM][MAXN];\nint n,m;\nvoid pivot(int r,int c)\n{\n\tdouble tmp=-a[r][c];\n\ta[r][c]=-1;\n\tfor(int i=0;i<=n;i++) a[r][i]/=tmp;\n\tfor(int i=0;i<=m;i++)\n\t\tif(a[i][c]&&i!=r)\n\t\t{\n\t\t\ttmp=a[i][c];a[i][c]=0;\n\t\t\tfor(int j=0;j<=n;j++)\n\t\t\t\ta[i][j]+=tmp*a[r][j];\n\t\t}\n}\nvoid Solve()\n{\n\twhile(1)\n\t{\n\t\tdouble tmp=eps;\n\t\tint i=0,j=0;\n\t\tfor(int k=1;k<=n;k++) if(a[0][k]>tmp) tmp=a[0][j=k];\n\t\tif(!j) break;\n\t\ttmp=1e17;\n\t\tfor(int k=1;k<=m;k++) if(a[k][j]<-eps&&-a[k][0]/a[k][j]<tmp)\n\t\t{\n\t\t\ttmp=-a[k][0]/a[k][j];\n\t\t\ti=k;\n\t\t}\n\t\tpivot(i,j);\n\t}\n\tprintf(\"%.0lf\\n\",a[0][0]);\n}\nint N,M,x[MAXN],y[MAXN],A;\nchar s[5];\nint main()\n{\n\tscanf(\"%d\",&N);\n\tfor(int i=1;i<=N;i++)\n\t\tscanf(\"%d%d%lf\",&x[i],&y[i],&a[0][i]);\n\tscanf(\"%d\",&M);\n\tfor(int i=1;i<=M;i++)\n\t{\n\t\tscanf(\"%s%d%lf\",s,&A,&a[i][0]);\n\t\tif(s[0]=='L')\n\t\t{\n\t\t\tfor(int j=1;j<=N;j++)\n\t\t\t\tif(x[j]<=A) a[i][j]=-1;\n\t\t}\n\t\telse if(s[0]=='R')\n\t\t{\n\t\t\tfor(int j=1;j<=N;j++)\n\t\t\t\tif(x[j]>=A) a[i][j]=-1;\n\t\t}\n\t\telse if(s[0]=='D')\n\t\t{\n\t\t\tfor(int j=1;j<=N;j++)\n\t\t\t\tif(y[j]<=A) a[i][j]=-1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(int j=1;j<=N;j++)\n\t\t\t\tif(y[j]>=A) a[i][j]=-1;\n\t\t}\n\t}\n\tfor(int i=1;i<=N;i++)\n\t\ta[i+M][0]=1,a[i+M][i]=-1;\n\tn=N;m=M+N;\n\tSolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define REV(i,n) for(ll (i) = (n) - 1;(i) >= 0;--i)\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {REP(WW,n)cerr << v[WW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,WW,HH) {REP(W_,WW){REP(H_,HH)cerr << v[W_][H_] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n#define fastcin() cin.tie(0);ios::sync_with_stdio(false)\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nclass minCostFlow {\n\n\tstruct edge { ll to, cap, cost, rev; };\n\n\tll V;\n\tvector<vector<edge>> G;\n\tvector<ll> dist;\n\tvector<ll> prevv;\n\tvector<ll> preve;\n\npublic:\n\n\tminCostFlow(ll n): G(n), dist(n), prevv(n), preve(n), V(n){\n\t}\n\n\tvoid addEdge(ll from, ll to, ll cap, ll cost) {\n\t\tG[from].push_back((edge){to, cap, cost, (ll)G[to].size()});\n\t\tG[to].push_back((edge){from, 0, -cost, (ll)G[from].size() - 1});\n\t}\n\n\tll solve(ll s, ll t, ll f) {\n\t\tll ret = 0;\n\t\twhile(f > 0) {\n\t\t\tfill(dist.begin(), dist.end(), LLINF);\n\t\t\tdist[s] = 0;\n\t\t\tbool update = true;\n\t\t\twhile(update) {\n\t\t\t\tupdate = false;\n\t\t\t\tfor(ll v = 0;v < V;v++) {\n\t\t\t\t\tif(dist[v] == LLINF)continue;\n\t\t\t\t\tfor(ll i = 0;i < G[v].size();i++) {\n\t\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\t\tif(e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n\t\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dist[t] == LLINF) {\n\t\t\t\treturn LLINF;//流せない\n\t\t\t}\n\n\t\t\tll d = f;\n\t\t\tfor(ll v = t;v != s;v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tret += d * dist[t];\n\t\t\tfor(ll v = t;v != s;v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n};\n\nll check(vector<pair<P, ll>> &v, vector<pair<char, P>> &t, int k){\n\tll cost = 1000000000000000LL;\n\tint n = v.size();\n\tint m = t.size();\n\t\n\tvector<P> ver(k, MP(0, LLINF));\n\tvector<P> hor(k, MP(0, LLINF));\n\t\n\tREP(i, m){\n\t\tchar c = t[i].FI;\n\t\tP p = t[i].SE;\n\t\tif(c == 'L'){\n\t\t\tif(p.SE >= k)continue;\n\t\t\thor[p.SE].FI = max(hor[p.SE].FI, p.FI + 1);\n\t\t}\n\t\telse if(c == 'R'){\n\t\t\tif(k - p.SE - 1 < 0)continue;\n\t\t\thor[k - p.SE - 1].SE = min(hor[k - p.SE - 1].SE, p.FI - 1);\n\t\t}\n\t\telse if(c == 'D'){\n\t\t\tif(p.SE >= k)continue;\n\t\t\tver[p.SE].FI = max(ver[p.SE].FI, p.FI + 1);\n\t\t}\n\t\telse {\n\t\t\tif(k - p.SE - 1 < 0)continue;\n\t\t\tver[k - p.SE - 1].SE = min(ver[k - p.SE - 1].SE, p.FI - 1);\n\t\t}\n\t}\n\t\n\tREP(i, k - 1){\n\t\tver[i + 1].FI = max(ver[i + 1].FI, ver[i].FI);\n\t\thor[i + 1].FI = max(hor[i + 1].FI, hor[i].FI);\n\t\tver[k - i - 2].SE = min(ver[k - i - 2].SE, ver[k - i - 1].SE); \n\t\thor[k - i - 2].SE = min(hor[k - i - 2].SE, hor[k - i - 1].SE); \n\t}\n\t\n\t//REP(i, k)cout << \"(\" << hor[i].FI << \", \" << hor[i].SE << \") \";cout << endl;\n\t//REP(i, k)cout << \"(\" << ver[i].FI << \", \" << ver[i].SE << \") \";cout << endl;\n\t\n\tminCostFlow mcf(2 * (n + m) + 10);\n\t\n\tll s = 2 * (m + n);\n\tll g = 2 * (m + n) + 1;\n\t\n\tREP(i, m){\n\t\tll idA = 2 * n + i;\n\t\tll idB = 2 * n + m + i;\n\t\tmcf.addEdge(s, idA, 1, 0);\n\t\tmcf.addEdge(idB, g, 1, 0);\n\t}\n\t\n\tREP(i, n){\n\t\tP now = v[i].FI;\n\t\tll val = v[i].SE;\n\t\tll idA = i;\n\t\tll idB = i + n;\n\t\tmcf.addEdge(idA, idB, 1, cost - val);\n\t\tREP(j, m){\n\t\t\tll idC = 2 * n + j;\n\t\t\tll idD = 2 * n + m + j;\n\t\t\tif(now.FI >= hor[j].FI && now.FI <= hor[j].SE){\n\t\t\t\tmcf.addEdge(idC, idA, 1, 0);\n\t\t\t}\n\t\t\tif(now.SE >= ver[j].FI && now.SE <= ver[j].SE){\n\t\t\t\tmcf.addEdge(idB, idD, 1, 0);\n\t\t\t}\n\t\t}\n\t}\n\tll ret = k * cost - mcf.solve(s, g, k);\n\t//cout << \"check \" << k << \" \" << ret << endl;\n\treturn ret;\n}\n\nint main(){\n\t\n\tint n;cin >> n;\n\tvector<pair<P, ll>> v(n);\n\tREP(i, n)cin >> v[i].FI.FI >> v[i].FI.SE >> v[i].SE;\n\tint m;cin >> m;\n\tvector<pair<char, P>> t(m);\n\tREP(i, m)cin >> t[i].FI >> t[i].SE.FI >> t[i].SE.SE;\n\t\n\tll ans = 0;\n\t\n\tfor(int i = 1;i <= n;i++){\n\t\tans = max(ans, check(v, t, i));\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#define lop(c,l) for(int c=1;c<=(l);++c)\n#define loop(c,l) for(int c=0;c<(l);++c)\nusing namespace std;\n\n#define int long long\n#define double long double\n#define inf 1e14\n#define eps 1e-14\ntemplate<int Vari,int Crat>\nstruct algo_simplex{\n\tdouble matrix[Crat+1][Vari+1],ans[Vari+1];\n\tint id[Crat<<1|1];\n\tint vari,crat;\n\tdouble target;\n\tconst char* cond;\n\tvoid pivot(const int& l,const int& e){\n\t\tswap(id[vari+l],id[e]);\n\t\tdouble t=matrix[l][e];\n\t\tmatrix[l][e]=1;\n\t\tfor(int j=0;j<=vari;j++) matrix[l][j]/=t;\n\t\tfor(int i=0;i<=crat;i++) if(i!=l&&abs(matrix[i][e])>1e-8){\n\t\t\tt=matrix[i][e];\n\t\t\tmatrix[i][e]=0;\n\t\t\tfor(int j=0;j<=vari;j++) matrix[i][j]-=matrix[l][j]*t;\n\t\t}\n\t}\n\tbool init(){\n\t\twhile(1){\n\t\t\tint l=0,e=0;\n\t\t\tfor(int i=1;i<=crat;i++) if(matrix[i][0]<-eps&&(!l||(rand()&1))) l=i;\n\t\t\tif(!l) return 1;\n\t\t\tfor(int j=1;j<=vari;j++) if(matrix[l][j]<-eps&&(!e||(rand()&1))) e=j;\n\t\t\tif(!e) return 0;\n\t\t\tpivot(l,e);\n\t\t}\n\t}\n\tbool funct(const int& v,const int& c){\n\t\tsrand(new int()-(int*)NULL);\n\t\tvari=v,crat=c;\n\t\tfor(int i=1;i<=vari;i++) id[i]=i;\n\t\tif(!init())\treturn 0;\n\t\twhile(1){\n\t\t\tint l=0,e=0;\n\t\t\tdouble minn=inf;\n\t\t\tfor(int j=1;j<=vari&&!e;j++) if(matrix[0][j]>eps) e=j;\n\t\t\tif(!e) break;\n\t\t\tfor(int i=1;i<=crat;i++) if(matrix[i][e]>eps&&matrix[i][0]/matrix[i][e]<minn) minn=matrix[i][0]/matrix[i][e],l=i;\n\t\t\tif(!l) return 0;\n\t\t\tpivot(l,e);\n\t\t}\n\t\ttarget=-matrix[0][0];\n\t\tfor(int i=1;i<=crat;i++) ans[id[vari+i]]=matrix[i][0];\n\t\treturn 1;\n\t}\n};\nalgo_simplex<80,400> spl;\nstruct loc{\n\tint x,y,v;\n}p[81];\nint n,m,ll,lim;\nchar ch;\nsigned main(signed,char**,char**){\n\tscanf(\"%lld\",&n);\n\tlop(i,n){\n\t\tscanf(\"%lld%lld%lld\",&p[i].x,&p[i].y,&p[i].v);\n\t\tspl.matrix[0][i]=p[i].v;\n\t}\n\tscanf(\"%lld\",&m);\n\tlop(i,m){\n\t\tscanf(\" %c%lld%lld\",&ch,&ll,&lim);\n\t\tswitch(ch){\n\t\t\tcase 'L':{\n\t\t\t\tlop(j,n) if(p[j].x<=ll) spl.matrix[i][j]=1;\n\t\t\t\tspl.matrix[i][0]=lim;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'R':{\n\t\t\t\tlop(j,n) if(p[j].x>=ll) spl.matrix[i][j]=1;\n\t\t\t\tspl.matrix[i][0]=lim;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'D':{\n\t\t\t\tlop(j,n) if(p[j].y<=ll) spl.matrix[i][j]=1;\n\t\t\t\tspl.matrix[i][0]=lim;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'U':{\n\t\t\t\tlop(j,n) if(p[j].y>=ll) spl.matrix[i][j]=1;\n\t\t\t\tspl.matrix[i][0]=lim;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tlop(i,n) spl.matrix[m+i][i]=1,spl.matrix[m+i][0]=1;\n\tspl.funct(n,m+n);\n\tprintf(\"%.0Lf\",abs(spl.target));\n\texit(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FOR(i,a,b) for (int i=a;i<=b;++i)\n#define REP(i,n) FOR(i,1,n)\n#define REP_0N(i,n) FOR(i,0,n)\n#define N 1005\n#define M 1005\nusing namespace std;\ntypedef long double ld;\nconst ld eps=0; ld inf=1e18;\nint n,m,id[N],tp[N];\nld a[M][N],T,sum[N][M],A[N],d[N],x[N];\nint B[N];\nchar c[N];\nstruct node {\n    int x,y;\n    long long v;\n}b[N];\ninline void pivot(int r,int c) {\n    swap(id[r+n],id[c]);\n    ld t=-a[r][c];\n    a[r][c]=-1;\n    REP_0N(i,n) a[r][i]/=t;\n    REP_0N(i,m)\n    if (a[i][c]&&r!=i) {\n        t=a[i][c];\n        a[i][c]=0;\n        REP_0N(j,n) a[i][j]+=t*a[r][j];\n    }\n}\ninline void solve() {\n    ld t;\n    REP(i,n) id[i]=i;\n    while (true) {\n        int i=0,j=0; ld w=0;\n        REP(k,m) if (a[k][0]<w) w=a[i=k][0];\n        if (!i) break;\n        REP(k,n) if (a[i][k]>0) {j=k; break;}\n        if (!j) return ;\n        pivot(i,j);\n    }\n    while (true) {\n        int i=0,j=0; ld w=0;\n        REP(k,n) if (a[0][k]>w) w=a[0][j=k];\n        if (!j) break;\n        w=inf;\n        REP(k,m) if (a[k][j]<0&&(t=-a[k][0]/a[k][j])<w) w=t,i=k;\n        if (!i) return ;\n        pivot(i,j);\n    }\n    FOR(i,n+1,n+m) tp[id[i]]=i-n;\n    REP(i,n) x[i]=tp[i]?a[tp[i]][0]:0;\n}\nint main() {\n    scanf(\"%d\",&n);\n    for (int i=1;i<=n;i++) {\n        scanf(\"%d%d%lld\",&b[i].x,&b[i].y,&b[i].v);\n        a[0][i]=b[i].v;\n    }\n    scanf(\"%d\",&m);\n    for (int i=1;i<=m;i++) {\n        scanf(\"%s\",c);\n        int x,y;\n        scanf(\"%d%d\",&x,&y);\n        a[i][0]=y;\n        if (c[0]=='L') {\n            for (int j=1;j<=n;j++) if (b[j].x<=x) a[i][j]=-1;\n        }\n        else if (c[0]=='R') {\n            for (int j=1;j<=n;j++) if (b[j].x>=x) a[i][j]=-1;\n        }\n        else if (c[0]=='D') {\n            for (int j=1;j<=n;j++) if (b[j].y<=x) a[i][j]=-1;\n        }\n        else if (c[0]=='U') {\n            for (int j=1;j<=n;j++) if (b[j].y>=x) a[i][j]=-1;\n        }\n    }\n    for (int i=1;i<=n;i++) {\n        a[++m][0]=1;\n        a[m][i]=-1;\n    }\n    solve();\n    ld ans=0;\n    for (int i=1;i<=n;i++) ans+=b[i].v*x[i];\n    printf(\"%lld\\n\",(long long)(ans+0.5));\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst long long inf=1000000000000000000ll;\nlong long ans,v[111];\nint lx[111],rx[111],ly[111],ry[111],n,x[111],y[111],m,a[111],b[111];\nchar s[111][3];\n\nnamespace flow\n{\n\tstruct node{int to,next,c; long long val;}e[200010];\n\tint n,cnt,hd[410],q[100010],l,r,x,la[410];\n\tlong long dis[410];\n\tbool inq[410];\n\tvoid init(int N)\n\t{\n\t\tn=N,cnt=1;\n\t\tfor (int i=1; i<=n; i++) hd[i]=0;\n\t}\n\tvoid addedge(int x,int y,int c,long long v)\n\t{\n\t\te[++cnt]=(node){y,hd[x],c,v},hd[x]=cnt;\n\t\te[++cnt]=(node){x,hd[y],0,-v},hd[y]=cnt;\n\t}\n\tpair<int,long long> solve()\n\t{\n\t\tint f=0;\n\t\tlong long ans=0;\n\t\twhile (1)\n\t\t{\n\t\t\tdis[1]=0,q[l=r=1]=1,inq[1]=1,la[1]=0;\n\t\t\tfor (int i=2; i<=n; i++) inq[i]=0,dis[i]=inf;\n\t\t\twhile (l<=r)\n\t\t\t{\n\t\t\t\tx=q[l++];\n\t\t\t\tfor (int i=hd[x]; i; i=e[i].next)\n\t\t\t\t\tif (e[i].c&&dis[e[i].to]>dis[x]+e[i].val)\n\t\t\t\t\t{\n\t\t\t\t\t\tdis[e[i].to]=dis[x]+e[i].val,la[e[i].to]=i;\n\t\t\t\t\t\tif (!inq[e[i].to]) inq[e[i].to]=1,q[++r]=e[i].to;\n\t\t\t\t\t}\n\t\t\t\tinq[x]=0;\n\t\t\t}\n\t\t\tif (dis[n]==inf) break;\n\t\t\tx=n; int nw=1000000000;\n\t\t\twhile (la[x]) nw=min(nw,e[la[x]].c),x=e[la[x]^1].to;\n\t\t\tx=n,f+=nw;\n\t\t\twhile (la[x]) e[la[x]].c-=nw,e[la[x]^1].c+=nw,ans+=e[la[x]].val*nw,x=e[la[x]^1].to;\n\t\t}\n\t\treturn make_pair(f,ans);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\",&n),ans=0;\n\tfor (int i=1; i<=n; i++) scanf(\"%d%d%lld\",&x[i],&y[i],&v[i]);\n\tscanf(\"%d\",&m);\n\tfor (int i=1; i<=m; i++) scanf(\"%s%d%d\",s[i],&a[i],&b[i]);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tflow::init(i*2+n*2+2);\n\t\tfor (int j=1; j<=i; j++) lx[j]=ly[j]=1,rx[j]=ry[j]=100;\n\t\tfor (int j=1; j<=m; j++)\n\t\t\tif (s[j][0]=='U') {if (b[j]<i) ry[i-b[j]]=min(ry[i-b[j]],a[j]-1);} else\n\t\t\tif (s[j][0]=='D') {if (b[j]<i) ly[b[j]+1]=max(ly[b[j]+1],a[j]+1);} else\n\t\t\tif (s[j][0]=='L') {if (b[j]<i) lx[b[j]+1]=max(lx[b[j]+1],a[j]+1);} else\n\t\t\tif (s[j][0]=='R') {if (b[j]<i) rx[i-b[j]]=min(rx[i-b[j]],a[j]-1);}\n\t\tfor (int j=2; j<=i; j++) lx[j]=max(lx[j],lx[j-1]),ly[j]=max(ly[j],ly[j-1]);\n\t\tfor (int j=i-1; j; j--) rx[j]=min(rx[j],rx[j+1]),ry[j]=min(ry[j],ry[j+1]);\n\t\tfor (int j=1; j<=i; j++) \n\t\t{\n\t\t\tflow::addedge(1,j+1,1,0);\n\t\t\tfor (int k=1; k<=n; k++)\n\t\t\t\tif (x[k]>=lx[j]&&x[k]<=rx[j]) flow::addedge(j+1,k+i+1,1,0);\n\t\t\tflow::addedge(j+i+2*n+1,i*2+n*2+2,1,0);\n\t\t\tfor (int k=1; k<=n; k++)\n\t\t\t\tif (y[k]>=ly[j]&&y[k]<=ry[j]) flow::addedge(k+i+n+1,j+i+2*n+1,1,0);\n\t\t}\n\t\tfor (int j=1; j<=n; j++) flow::addedge(j+i+1,j+i+n+1,1,-v[j]);\n\t\tpair<int,long long> nw=flow::solve();\n\t\tif (nw.first==i&&-nw.second>ans) ans=-nw.second;\n\t}\n\treturn printf(\"%lld\\n\",ans),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\ntypedef double T; // long double, Rational, double + mod<P>...\ntypedef vector<T> vd;\ntypedef vector<vd> vvd;\n\nconst T eps = 1e-8, inf = 1/.0;\n#define MP make_pair\n#define ltj(X) if(s == -1 || MP(X[j],N[j]) < MP(X[s],N[s])) s=j\n\nstruct LPSolver {\n\tint m, n;\n\tvi N, B;\n\tvvd D;\n\n\tLPSolver(const vvd& A, const vd& b, const vd& c) :\n\t\tm(sz(b)), n(sz(c)), N(n+1), B(m), D(m+2, vd(n+2)) {\n\t\t\trep(i,0,m) rep(j,0,n) D[i][j] = A[i][j];\n\t\t\trep(i,0,m) { B[i] = n+i; D[i][n] = -1; D[i][n+1] = b[i];}\n\t\t\trep(j,0,n) { N[j] = j; D[m][j] = -c[j]; }\n\t\t\tN[n] = -1; D[m+1][n] = 1;\n\t\t}\n\n\tvoid pivot(int r, int s) {\n\t\tT *a = D[r].data(), inv = 1 / a[s];\n\t\trep(i,0,m+2) if (i != r && abs(D[i][s]) > eps) {\n\t\t\tT *b = D[i].data(), inv2 = b[s] * inv;\n\t\t\trep(j,0,n+2) b[j] -= a[j] * inv2;\n\t\t\tb[s] = a[s] * inv2;\n\t\t}\n\t\trep(j,0,n+2) if (j != s) D[r][j] *= inv;\n\t\trep(i,0,m+2) if (i != r) D[i][s] *= -inv;\n\t\tD[r][s] = inv;\n\t\tswap(B[r], N[s]);\n\t}\n\n\tbool simplex(int phase) {\n\t\tint x = m + phase - 1;\n\t\tfor (;;) {\n\t\t\tint s = -1;\n\t\t\trep(j,0,n+1) if (N[j] != -phase) ltj(D[x]);\n\t\t\tif (D[x][s] >= -eps) return true;\n\t\t\tint r = -1;\n\t\t\trep(i,0,m) {\n\t\t\t\tif (D[i][s] <= eps) continue;\n\t\t\t\tif (r == -1 || MP(D[i][n+1] / D[i][s], B[i])\n\t\t\t\t             < MP(D[r][n+1] / D[r][s], B[r])) r = i;\n\t\t\t}\n\t\t\tif (r == -1) return false;\n\t\t\tpivot(r, s);\n\t\t}\n\t}\n\n\tT solve(vd &x) {\n\t\tint r = 0;\n\t\trep(i,1,m) if (D[i][n+1] < D[r][n+1]) r = i;\n\t\tif (D[r][n+1] < -eps) {\n\t\t\tpivot(r, n);\n\t\t\tif (!simplex(2) || D[m+1][n+1] < -eps) return -inf;\n\t\t\trep(i,0,m) if (B[i] == -1) {\n\t\t\t\tint s = 0;\n\t\t\t\trep(j,1,n+1) ltj(D[i]);\n\t\t\t\tpivot(i, s);\n\t\t\t}\n\t\t}\n\t\tbool ok = simplex(1); x = vd(n);\n\t\trep(i,0,m) if (B[i] < n) x[B[i]] = D[i][n+1];\n\t\treturn ok ? D[m][n+1] : inf;\n\t}\n};\n\nint n, m, x[105], y[105];\nll v[105];\n\nvvd A, A1;\nvd t, b, c, b1, c1, xx;\n\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> x[i] >> y[i] >> v[i];\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tt.clear();\n\t\tt.resize(n);\n\t\tt[i] = -1;\n\t\tA.push_back(t);\n\t\tb.push_back(0);\t\n\t\tt.clear();\n\t\tt.resize(n);\n\t\tt[i] = 1;\n\t\tA.push_back(t);\n\t\tb.push_back(1);\t\t\n\t}\n\tcin >> m;\n\tfor (int i = 0; i < m; ++i) {\n\t\tt.clear();\n\t\tt.resize(n);\n\t\tchar f;\n\t\tint a, bb;\n\t\tcin >> f >> a >> bb;\n\t\tif (f == 'L') {\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\tif (x[j] <= a)\n\t\t\t\t\tt[j] = 1;\n\t\t} if (f == 'R') {\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\tif (x[j] >= a)\n\t\t\t\t\tt[j] = 1;\n\t\t} if (f == 'U') {\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\tif (y[j] >= a)\n\t\t\t\t\tt[j] = 1;\n\t\t} if (f == 'D') {\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\tif (y[j] <= a)\n\t\t\t\t\tt[j] = 1;\n\t\t}\n\t\tA.push_back(t);\n\t\tb.push_back(bb);\n\t}\n\tc.resize(n);\n\tfor (int i = 0; i < n; ++i)\n\t\tc[i] = v[i];\n\tll ans = 0;\n\tfor (int i = 0; i <= n; ++i) {\n\t\tA1 = A, b1 = b, c1 = c;\n\t\tfor (int j = 0; j < n; ++j)\n\t\t\tt[j] = 1;\n\t\tA1.push_back(t);\n\t\tb1.push_back(i);\n\t\tfor (int j = 0; j < n; ++j)\n\t\t\tt[j] = -1;\n\t\tA1.push_back(t);\n\t\tb1.push_back(-i);\n\t\tans = max(ans, (ll)lround(LPSolver(A1, b1, c1).solve(xx)));\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<double, double> pdd;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\n//const int mod = ;\n\nstruct J {\n  int x, y, ind;\n  ll cost;\n};\n\nvi dx(100, 100), ux(100, 100), dy(100, 100), uy(100, 100);\nvector<J> v;\nvi best;\nll best_score = 0;\n\nll eval(const vi& x) {\n  ll score = 0;\n  for (int i = 0; i < v.size(); ++i) score += v[i].cost * x[i];\n  return score;\n}\n\nvoid update(const vi& x) {\n  ll score = eval(x);\n  if (score > best_score) {\n    best = x;\n    best_score = score;\n  }\n}\n\nint tmpx[100], tmpy[100];\nbool valid_add(int ind, const vi& x) {\n  memset(tmpx, 0, sizeof(tmpx));\n  memset(tmpy, 0, sizeof(tmpy));\n  for (int i = 0; i < x.size(); ++i) if (x[i] || i == ind) {\n    tmpx[v[i].x]++;\n    tmpy[v[i].y]++;\n  }\n  int sx = 0;\n  for (int i = 0; i < 100; ++i) {\n    sx += tmpx[i];\n    if (sx > dx[i]) return false;\n  }\n  sx = 0;\n  for (int i = 99; i >= 0; --i) {\n    sx += tmpx[i];\n    if (sx > ux[i]) return false;\n  }\n  int sy = 0;\n  for (int i = 0; i < 100; ++i) {\n    sy += tmpy[i];\n    if (sy > dy[i]) return false;\n  }\n  sy = 0;\n  for (int i = 99; i >= 0; --i) {\n    sy += tmpy[i];\n    if (sy > uy[i]) return false;\n  }\n  return true;\n}\n\nvoid greedy(int type) {\n  vector<J> ts = v;\n  if (type == 0) {\n    sort(ts.rbegin(), ts.rend(), [&](const auto& a, const auto& b){return a.cost < b.cost;});\n  } else {\n    vd mulx(v.size(), 1e-10), muly(v.size(), 1e-10);\n    vd mul(v.size());\n    for (int i = 0; i < v.size(); ++i) {\n      for (int x = v[i].x; x < 100; ++x) if (ux[x] != 100) {\n        mulx[i] += 1. / ux[x];\n      }\n      for (int x = 0; x <= v[i].x; ++x) if (dx[x] != 100) {\n        mulx[i] += 1. / dx[x];\n      }\n      for (int y = v[i].y; y < 100; ++y) if (uy[y] != 100) {\n        muly[i] += 1. / uy[y];\n      }\n      for (int y = 0; y <= v[i].y; ++y) if (dy[y] != 100) {\n        muly[i] += 1. / dy[y];\n      }\n      mul[i] = 1. / (mulx[i] + muly[i]);\n    }\n    sort(ts.rbegin(), ts.rend(), [&](const auto& a, const auto& b){return a.cost * mul[a.ind] < b.cost * mul[b.ind];});\n  }\n  vi x(v.size());\n  for (int i = 0; i < ts.size(); ++i) {\n    int ind = ts[i].ind;\n    if (valid_add(ind, x)) {\n//      cerr << ind << endl;\n      x[ind] = 1;\n    }\n  }\n  update(x);\n}\n\nint main() {\n  std::ios::sync_with_stdio(false); std::cin.tie(0);\n  int n;\n  cin >> n;\n  v.resize(n);\n  for (int i = 0; i < n; ++i) {\n    cin >> v[i].x >> v[i].y >> v[i].cost;\n    --v[i].x; --v[i].y;\n    v[i].ind = i;\n  }\n  int m;\n  cin >> m;\n  for (int i = 0; i < m; ++i) {\n    string t;\n    int a, b;\n    cin >> t >> a >> b;\n    --a;\n    if (t == \"L\") {\n      dx[a] = b;\n    }\n    if (t == \"R\") {\n      ux[a] = b;\n    }\n    if (t == \"D\") {\n      dy[a] = b;\n    }\n    if (t == \"U\") {\n      uy[a] = b;\n    }\n  }\n  greedy(0);\n  greedy(1);\n  cout << best_score << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MV = 815;\nconst int ME = 1200006;\nconst ll oo = 1e18;\n\ntemplate <typename T> void cmin(T &x, const T &y)\n{\n\tif(y < x) x = y;\n}\n\ntemplate <typename T> void cmax(T &x, const T &y)\n{\n\tif(y > x) x = y;\n}\n\ntemplate <typename T> void read(T &x)\n{\n\tx = 0; char c = getchar(); bool f = 0;\n\twhile(!isdigit(c) && c!='-') c = getchar();\n\tif(c == '-') f = 1, c = getchar();\n\twhile(isdigit(c)) x = x*10+c-'0', c = getchar();\n\tif(f) x = -x;\n}\n\nstruct EDGE\n{\n\tint v;\n\tll w;\n\tint c;\n\n\tEDGE (const int &v0 = 0, const ll &w0 = 0, const int &c0 = 0) : v(v0), w(w0), c(c0) {}\n};\n\nstruct GRAPH\n{\n\tint fst[MV],nxt[ME],u[ME],v[ME],w[ME],lnum;\n\tll c[ME];\n\tint n,m,s,t;\n\n\tvoid init()\n\t{\n\t\tmemset(fst,0xff,sizeof(fst));\n\t\tlnum=-1;\n\t}\n\n\tvoid addeg(int nu,int nv,ll nc,int nw)\n\t{\n\t\tlnum++;\n\t\tnxt[lnum]=fst[nu];\n\t\tfst[nu]=lnum;\n\t\tu[lnum]=nu;\n\t\tv[lnum]=nv;\n\t\tw[lnum]=nw;\n\t\tc[lnum]=nc;\n\t\tlnum++;\n\t\tnxt[lnum]=fst[nv];\n\t\tfst[nv]=lnum;\n\t\tu[lnum]=nv;\n\t\tv[lnum]=nu;\n\t\tw[lnum]=0;\n\t\tc[lnum]=-nc;\n\t}\n\n\t//滚动!!!\n\n\tll dist[MV];\n\tint book[MV],q[MV],pre[MV],frnt,rare,now;\n\tint spfa(int frm,int to,int &flow,ll &cost)\n\t{\n\t\tmemset(dist,0x9f,sizeof(dist));\n\t\tfrnt=rare=1;\n\t\tq[rare]=frm;\n\t\tdist[frm]=0;\n\t\tbook[frm]=1;\n\t\tpre[frm]=-1;\n\t\twhile(frnt>=rare)\n\t\t{\n\t\t\tbook[q[rare]]=0;\n\t\t\tnow=q[rare++];\n\t\t\tfor(int i=fst[now];i!=-1;i=nxt[i])\n\t\t\t{\n\t\t\t\tif(w[i]>0&&dist[v[i]]<dist[now]+c[i])\n\t\t\t\t{\n\t\t\t\t\tdist[v[i]]=dist[now]+c[i];\n\t\t\t\t\tpre[v[i]]=i;\n\t\t\t\t\tif(book[v[i]]==0)\n\t\t\t\t\t{\n\t\t\t\t\t\tbook[v[i]]=1;\n\t\t\t\t\t\tq[++frnt]=v[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dist[to]<-oo)return 0;\n\t\tint mxfl=ME;\n\t\tll mxcs=0;\n\t\tnow=pre[to];\n\t\twhile(now!=-1)\n\t\t{\n\t\t\tmxfl=min(mxfl,w[now]);\n\t\t\tmxcs+=c[now];\n\t\t\tnow=pre[u[now]];\n\t\t}\n\t\tnow=pre[to];\n\t\twhile(now!=-1)\n\t\t{\n\t\t\tw[now]-=mxfl;\n\t\t\tw[now^1]+=mxfl;\n\t\t\tnow=pre[u[now]];\n\t\t}\n\t\tflow+=mxfl;\n\t\tcost+=mxcs*mxfl;\n\t\treturn 1;\n\t}\n\n\tpair<int, ll> mcf(int from,int to)\n\t{\n\t\tint flow=0;\n\t\tll cost=0;\n\t\twhile(spfa(from,to,flow,cost));\n\t\treturn make_pair(flow, cost);\n\t}\n} G;\n\n/*struct GRAPH\n{\n\tint fst[MV], nxt[ME], lnum;\n\tint q[MV], pre[MV], inq[MV];\n\tEDGE e[ME];\n\tll dis[MV];\n\n\tvoid init()\n\t{\n\t\tmemset(fst, 0xff, sizeof(fst));\n\t\tlnum = -1;\n\t}\n\n\tGRAPH () {init();}\n\n\tvoid addeg(int nu, int nv, ll nw, int nc)\n\t{\n\t\tnxt[++lnum] = fst[nu];\n\t\te[lnum] = EDGE(nv, nw, nc);\n\t\tfst[nu] = lnum;\n\t\tnxt[++lnum] = fst[nv];\n\t\te[lnum] = EDGE(nu, -nw, 0);\n\t\tfst[nv] = lnum;\n\t}\n\n\tint spfa(int &flow, ll &cost, int frm, int tar)\n\t{\n\t\tint h=0, t=1, x, y, mxf = ME, now;\n\t\tll cst = 0;\n\t\tmemset(dis, 0x9f, sizeof(dis));\n\t\tmemset(inq, 0, sizeof(inq));\n\t\tmemset(pre, 0, sizeof(pre));\n\t\tq[++h] = frm;\n\t\tdis[frm] = 0;\n\t\tpre[frm] = -1;\n\t\twhile(h >= t)\n\t\t{\n\t\t\tx = q[(t++)%MV];\n\t\t\tinq[x] = 0;\n\t\t\tfor(int i=fst[x]; i!=-1; i=nxt[i])\n\t\t\t{\n\t\t\t\ty = e[i].v;\n\t\t\t\tif(e[i].c && dis[y]<dis[x]+e[i].w)\n\t\t\t\t{\n\t\t\t\t\tdis[y] = dis[x]+e[i].w;\n\t\t\t\t\tpre[y] = i;\n\t\t\t\t\tif(!inq[y]) q[(++h)%MV] = y, inq[y] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dis[tar] < -oo) return 0;\n\t\tnow = pre[tar];\n\t\twhile(now != -1)\n\t\t{\n\t\t\tmxf = min(mxf, e[now].c);\n\t\t\tcst += e[now].w;\n\t\t\tnow = pre[e[now^1].v];\n\t\t}\n\t\tnow = pre[tar];\n\t\twhile(now != -1)\n\t\t{\n\t\t\te[now].c -= mxf;\n\t\t\te[now^1].c += mxf;\n\t\t\tnow = pre[e[now^1].v];\n\t\t}\n\t\tflow += mxf;\n\t\tcost += cst*mxf;\n\t\treturn 1;\n\t}\n\n\tpair<int, ll> mcf(int s, int t)\n\t{\n\t\tint flow = 0;\n\t\tll cost = 0;\n\t\twhile(spfa(flow, cost, s, t));\n\t\treturn make_pair(flow, cost);\n\t}\n} G;*/\n\nint n, m;\nint lx[MV], rx[MV];\nint ly[MV], ry[MV];\nint px[MV], py[MV];\nll pv[MV];\nchar qc[MV];\nint qa[MV], qb[MV];\nint global_s, global_t;\n\nvoid input()\n{\n\tread(n);\n\tfor(int i=1; i<=n; i++) read(px[i]), read(py[i]), read(pv[i]);\n\tread(m);\n\tfor(int i=1; i<=n; i++) lx[i] = 1, rx[i] = 100, ly[i] = 1, ry[i] = 100;\n\tfor(int i=1; i<=m; i++)\n\t{\n\t\tqc[i] = getchar();\n\t\twhile(!isalpha(qc[i])) qc[i] = getchar();\n\t\tread(qa[i]), read(qb[i]);\n\t}\n}\n\nvoid build(int num)\n{\n\tfor(int i=1; i<=num; i++) lx[i] = ly[i] = 1, rx[i] = ry[i] = 100;\n\tfor(int i=1; i<=m; i++)\n\t{\n\t\tif(qb[i] > num) continue;\n\t\tif(qc[i] == 'L') cmax(lx[qb[i]+1], qa[i]+1);\n\t\tif(qc[i] == 'R') cmin(rx[num-qb[i]], qa[i]-1);\n\t\tif(qc[i] == 'D') cmax(ly[qb[i]+1], qa[i]+1);\n\t\tif(qc[i] == 'U') cmin(ry[num-qb[i]], qa[i]-1);\n\t}\n\tfor(int i=1; i<=num; i++) cmax(lx[i], lx[i-1]), cmax(ly[i], ly[i-1]);\n\tfor(int i=num; i>=1; i--) cmin(rx[i], rx[i+1]), cmin(ry[i], ry[i+1]);\n\tG.init();\n\tfor(int i=1; i<=num; i++)\n\t{\n\t\tfor(int j=1; j<=n; j++)\n\t\t{\n\t\t\tif(lx[i]<=px[j] && px[j]<=rx[i]) G.addeg(i, num*2+j, 0, 1);\n\t\t\tif(ly[i]<=py[j] && py[j]<=ry[i]) G.addeg(num*2+n+j, num+i, 0, 1);\n\t\t}\n\t}\n\tfor(int i=1; i<=n; i++) G.addeg(num*2+i, num*2+n+i, pv[i], 1);\n\tglobal_s = num*2+n*2+1, global_t = global_s+1;\n\tfor(int i=1; i<=num; i++) G.addeg(global_s, i, 0, 1), G.addeg(num+i, global_t, 0, 1);\n}\n\nvoid work()\n{\n\tll ans = 0;\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tbuild(i);\n\t\tauto ret = G.mcf(global_s, global_t);\n\t\tif(ret.first != i) break;\n\t\telse cmax(ans, ret.second);\n\t}\n\tprintf(\"%lld\\n\", ans);\n}\n\nint main()\n{\n\tinput();\n\twork();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//2019.5.25 by ljz\n#include<bits/stdc++.h>\nusing namespace std;\n#define res register int\n#define LL long long\n#define inf 0x3f3f3f3f\n#define INF 0x3f3f3f3f3f3f\n#define eps 1e-10\n#define RG register\n#define db double\n#define pc(x) __builtin_popcount(x)\ntypedef pair<int,int> Pair;\n#define mp make_pair\n#define fi first\n#define se second\n#define gc getchar\n//inline char gc() {\n//    static char buf[100000],*p1,*p2;\n//    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n//}\ninline int read() {\n    res s=0,ch=gc();\n    while(ch<'0'||ch>'9')ch=gc();\n    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=gc();\n    return s;\n}\ninline LL Read() {\n    RG LL s=0;\n    res ch=gc();\n    while(ch<'0'||ch>'9')ch=gc();\n    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=gc();\n    return s;\n}\ninline void swap(res &x,res &y) {\n    x^=y^=x^=y;\n}\n//mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nconst int N=4e2+10;\nnamespace MAIN {\n    int n,m;\n    char str[10];\n    LL v[N];\n    int x[N],y[N],t[N],a[N],b[N];\n    struct E{\n        int next,to,flow;\n        LL cost;\n        E() {}\n        E(res next,res to,res flow,RG LL cost):next(next),to(to),flow(flow),cost(cost) {}\n    }edge[N<<1];\n    int head[N],cnt;\n    inline void addedge(const res &u,const res &v,const res &f,const RG LL &c){\n        edge[++cnt]=E(head[u],v,f,c),head[u]=cnt;\n        edge[++cnt]=E(head[v],u,0,-c),head[v]=cnt;\n    }\n    LL dis[N];\n    int Q[N*N],he,ta,S,T,vis[N],pre[N];\n    inline bool spfa(RG LL &ret){\n        for(res i=S;i<=T;i++)dis[i]=INF;\n        Q[he=ta=1]=S,vis[S]=1,dis[S]=0;\n        while(he<=ta){\n            res u=Q[he++];\n            vis[u]=0;\n            for(res i=head[u];~i;i=edge[i].next){\n                res tox=edge[i].to;\n                if(dis[tox]>dis[u]+edge[i].cost&&edge[i].flow){\n                    dis[tox]=dis[u]+edge[i].cost,pre[tox]=i;\n                    if(!vis[tox])vis[tox]=1,Q[++ta]=tox;\n                }\n            }\n        }\n        if(dis[T]==INF)return 0;\n        ret+=dis[T];\n        for(res i=T;i!=S;i=edge[pre[i]^1].to)edge[pre[i]].flow--,edge[pre[i]^1].flow++;\n        return 1;\n    }\n    int L[N],R[N],D[N],U[N];\n    inline LL calc(const res &k){\n        for(res i=1;i<=k;i++)L[i]=D[i]=0,R[i]=U[i]=inf;\n        for(res i=1;i<=m;i++)\n            if(b[i]<k){\n                if(t[i]==0)L[b[i]+1]=a[i]+1;\n                if(t[i]==1)R[k-b[i]]=a[i]-1;\n                if(t[i]==2)D[b[i]+1]=a[i]+1;\n                if(t[i]==3)U[k-b[i]]=a[i]-1;\n            }\n        for(res i=2;i<=k;i++)L[i]=max(L[i],L[i-1]),D[i]=max(D[i],D[i-1]);\n        for(res i=k-1;i;i--)R[i]=min(R[i],R[i+1]),U[i]=min(U[i],U[i+1]);\n        S=0,T=(n+k)<<1|1;\n        for(res i=S;i<=T;i++)head[i]=-1;\n        cnt=-1;\n        for(res i=1;i<=n;i++)addedge(i,i+n,1,-v[i]-INF);\n        for(res i=1;i<=k;i++){\n            addedge(S,i+n*2,1,0),addedge(i+k+n*2,T,1,0);\n            for(res j=1;j<=n;j++){\n                if(L[i]<=x[j]&&x[j]<=R[i])addedge(i+n*2,j,1,0);\n                if(D[i]<=y[j]&&y[j]<=U[i])addedge(j+n,i+k+n*2,1,0);\n            }\n        }\n        RG LL ret=0;\n        while(spfa(ret));\n        return -ret-INF*k;\n    }\n    LL ans;\n    inline int get(const RG char *st){\n        return st[0]=='L'?0:(st[0]=='R'?1:(st[0]=='D'?2:3));\n    }\n    inline void MAIN(){\n        n=read();\n        for(res i=1;i<=n;i++)x[i]=read(),y[i]=read(),v[i]=Read();\n        m=read();\n        for(res i=1;i<=m;i++)scanf(\"%s\",str),t[i]=get(str),a[i]=read(),b[i]=read();\n        for(res i=1;i<=n;i++)ans=max(ans,calc(i));\n        printf(\"%lld\\n\",ans);\n    }\n}\nint main() {\n//    srand((unsigned)time(NULL));\n//    freopen(\"zao.in\",\"r\",stdin);\n//    freopen(\"std.out\",\"w\",stdout);\n    MAIN::MAIN();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 666;\n\ntypedef int flow_t;\ntypedef long long cost_t;\n\nconst flow_t flow_inf = 1e9;\nconst cost_t cost_inf = 4e18;\n\nnamespace flow {\nstruct edge {\n  int to, rev;\n  flow_t cap;\n  cost_t cost;\n\n  edge(int _to, int _rev, flow_t _cap, cost_t _cost)\n    : to(_to), rev(_rev), cap(_cap), cost(_cost) {}\n};\n\nvector<edge> g[N];\nint ptr[N];\nbool vis[N];\nflow_t flow;\ncost_t cost;\nint n, sv, tv;\ncost_t dist[N];\n\nvoid init(int _n, int _sv, int _tv) {\n  n = _n;\n  sv = _sv;\n  tv = _tv;\n  for (int i = 0; i < n; i++) {\n    g[i].clear();\n  }\n  flow = cost = 0;\n}\n\nvoid add(int from, int to, flow_t c, cost_t w) {\n  g[from].push_back(edge(to, (int)g[to].size(), c, w));\n  g[to].push_back(edge(from, (int)g[from].size() - 1, 0, -w));\n}\n\nbool expath() {\n  for (int i = 0; i < n; i++) {\n    vis[i] = false;\n    dist[i] = cost_inf;\n  }\n  queue<int> que;\n  que.push(sv);\n  dist[sv] = 0;\n  while (!que.empty()) {\n    int v = que.front();\n    que.pop();\n    vis[v] = false;\n    for (int i = 0; i < (int)g[v].size(); i++) {\n      edge& e = g[v][i];\n      if (e.cap && dist[e.to] > dist[v] + e.cost) {\n        dist[e.to] = dist[v] + e.cost;\n        if (!vis[e.to]) {\n          vis[e.to] = true;\n          que.push(e.to);\n        }\n      }\n    }\n  }\n  return dist[tv] != cost_inf;\n}\n\nflow_t dfs(int v, flow_t r) {\n  if (v == tv) {\n    return r;\n  }\n  flow_t res = 0;\n  vis[v] = true;\n  for (int& i = ptr[v]; i < (int)g[v].size(); i++) {\n    edge& e = g[v][i];\n    if (e.cap && dist[e.to] == dist[v] + e.cost && !vis[e.to]) {\n      flow_t d = dfs(e.to, min(r - res, e.cap));\n      e.cap -= d;\n      g[e.to][e.rev].cap += d;\n      res += d;\n      if (res == r) {\n        vis[v] = false; \n        return r;\n      }\n    }\n  }\n  return res;\n}\n\npair<flow_t, cost_t> exec(flow_t r) {\n  while (expath()) {\n    fill_n(ptr, n, 0);\n    flow_t d = dfs(sv, r - flow);\n    flow += d;\n    cost += d * dist[tv];\n  }\n  return make_pair(flow, cost);\n}\n}\n\nusing flow::sv;\nusing flow::tv;\nusing flow::init;\nusing flow::exec;\nusing flow::add;\n\nint n, m;\nint L[N], R[N], D[N], U[N];\nint low[N], high[N];\nint x[N], y[N];\nlong long z[N];\n\nlong long solve(int take) {\n  init(2 * (1 + take + n), 0, 1);\n  for (int i = 0; i < n; i++) {\n    add(2 + take + i, 2 + take + n + i, 1, -z[i]);\n  }\n  for (int i = 0; i < take; i++) {\n    add(sv, 2 + i, 1, 0);\n    add(2 + take + n + n + i, tv, 1, 0);\n  }\n  {\n    for (int i = 0; i < take; i++) {\n      low[i] = 0;\n      high[i] = N;\n    }\n    for (int i = 0; i < N; i++) {\n      if (L[i] < take) {\n        low[L[i]] = max(low[L[i]], i + 1);\n      }\n      if (R[i] < take) {\n        high[take - 1 - R[i]] = min(high[take - 1 - R[i]], i - 1);\n      }\n    }\n    for (int i = 1; i < take; i++) {\n      low[i] = max(low[i - 1], low[i]);\n    }\n    for (int i = take - 2; i >= 0; i--) {\n      high[i] = min(high[i], high[i + 1]);\n    }\n    for (int i = 0; i < take; i++) {\n      for (int j = 0; j < n; j++) {\n        if (low[i] <= x[j] && x[j] <= high[i]) {\n          add(2 + i, 2 + take + j, 1, 0);\n        }\n      }\n    }\n  }\n  { \n    for (int i = 0; i < take; i++) {\n      low[i] = 0;\n      high[i] = N;\n    }\n    for (int i = 0; i < N; i++) {\n      if (D[i] < take) {\n        low[D[i]] = max(low[D[i]], i + 1);\n      }\n      if (U[i] < take) {\n        high[take - 1 - U[i]] = min(high[take - 1 - U[i]], i - 1);\n      }\n    }\n    for (int i = 1; i < take; i++) {\n      low[i] = max(low[i - 1], low[i]);\n    }\n    for (int i = take - 2; i >= 0; i--) {\n      high[i] = min(high[i], high[i + 1]);\n    }\n    for (int i = 0; i < take; i++) {\n      for (int j = 0; j < n; j++) {\n        if (low[i] <= y[j] && y[j] <= high[i]) {\n          add(2 + take + n + j, 2 + take + n + n + i, 1, 0);\n        }\n      }\n    }\n  }\n  return -exec(take).second;\n}\n\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d %d %lld\", &x[i], &y[i], &z[i]);\n  }\n  for (int i = 0; i < N; i++) {\n    L[i] = n;\n    R[i] = n;\n    D[i] = n;\n    U[i] = n;\n  }\n  scanf(\"%d\", &m);\n  for (int i = 0; i < m; i++) {\n    char type;\n    int a, b;\n    scanf(\" %c %d %d\", &type, &a, &b);\n    if (type == 'L') L[a] = min(L[a], b);\n    if (type == 'R') R[a] = min(R[a], b);\n    if (type == 'D') D[a] = min(D[a], b);\n    if (type == 'U') U[a] = min(U[a], b);\n  }\n  long long ans = 0;\n  for (int take = 1; take <= n; take++) {\n    ans = max(ans, solve(take));\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int maxn = 100005;\nconst int INF = 1e9;\nconst ll INF_LL = 1e18, bound = 1e15+3;\n\nint e_num = 1, S, T, maxf = 0;\nll mincost = 0;\nint hed[maxn];\nll ct[maxn];\nstruct Edge {\n  int from, to, nxt, c;\n  ll cost;\n} edge[maxn];\nvoid addedge(int from, int to, int c, ll cost) {\n  edge[++e_num] = (Edge){from, to, hed[from], c, cost};\n  hed[from] = e_num;\n}\nvoid adde(int from, int to, int c, ll cost) {\n  addedge(from, to, c, cost);\n  addedge(to, from, 0, -cost);\n}\nqueue<int> q;\n#define prev prv\nint inq[maxn], prev[maxn], pree[maxn];\nbool SPFA() {\n  for (int i = 0; i <= T; i++) ct[i] = INF_LL;\n  inq[S] = 1;\n  ct[S] = 0;\n  q.push(S);\n  while (!q.empty()) {\n    int cur = q.front();\n    q.pop();\n    for (int i = hed[cur]; i; i = edge[i].nxt) {\n      int to = edge[i].to;\n      if (ct[to] > ct[cur] + edge[i].cost && edge[i].c) {\n        if (!inq[to]) {\n          inq[to] = 1;\n          q.push(to);\n        }\n        ct[to] = ct[cur] + edge[i].cost;\n        prev[to] = cur;\n        pree[to] = i;\n      }\n    }\n    inq[cur] = 0;\n  }\n  if (ct[T] == INF_LL) return 0;\n  int flow = INF;\n  for (int cur = T; prev[cur]; cur = prev[cur]) {\n    int ed = pree[cur];\n    flow = min(flow, edge[ed].c);\n  }\n  for (int cur = T; prev[cur]; cur = prev[cur]) {\n    int ed = pree[cur];\n    edge[ed].c -= flow;\n    edge[ed ^ 1].c += flow;\n  }\n  maxf += flow;\n  mincost += flow * ct[T];\n  return 1;\n}\n\nconst int N = 233;\nint n, m, L[N], R[N], U[N], D[N], x[N], y[N];\nint type[N], tt[N], vv[N];\nll v[N];\n\nll Main(int k) {\n  memset(L, 0, sizeof L);\n  memset(D, 0, sizeof D);\n  memset(R, 0x3f, sizeof R);\n  memset(U, 0x3f, sizeof U);\n  for (int x = 1; x <= m; x++) {\n    int t = tt[x], v = vv[x];\n    if (type[x] == 'L') {\n      for (int i = v + 1; i <= k; i++) {\n        L[i] = max(L[i], t + 1);\n      }\n    } else if (type[x] == 'R') {\n      for (int i = 1; i <= k - v; i++) {\n        R[i] = min(R[i], t - 1);\n      }\n    } else if (type[x] == 'D') {\n      for (int i = v + 1; i <= k; i++) {\n        D[i] = max(D[i], t + 1);\n      }\n    } else {\n      for (int i = 1; i <= k - v; i++) {\n        U[i] = min(U[i], t - 1);\n      }\n    }\n  }\n  S = n * 4 + 1, T = n * 4 + 2;\n  mincost = maxf = 0;\n  e_num = 1;\n  memset(hed, 0, sizeof hed);\n  for (int i = 1; i <= k; i++) {\n    adde(S, i, 1, 0);\n    adde(i + k, T, 1, 0);\n    for (int j = 1; j <= n; j++) {\n      if (L[i] <= x[j] && x[j] <= R[i]) {\n        adde(i, j + k + k, 1, 0);\n      }\n      if (D[i] <= y[j] && y[j] <= U[i]) {\n        adde(j + k + k + n, i + k, 1, 0);\n      }\n    }\n  }\n  for (int j = 1; j <= n; j++) {\n    adde(j + k + k, j + k + k + n, 1, bound - v[j]);\n  }\n  while (SPFA());\n  if (maxf != k) return 0;\n  return maxf * bound - mincost;\n}\n\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d%d%lld\", &x[i], &y[i], &v[i]);\n  }\n  scanf(\"%d\", &m);\n  for (int i = 1; i <= m; i++) {\n    char c[4];\n    scanf(\"%s%d%d\", c, &tt[i], &vv[i]);\n    type[i] = c[0];\n  }\n  ll ans = 0;\n  for (int i = 1; i <= n; i++) {\n    ans = max(ans, Main(i));\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntemplate<typename T>inline T read(){\n\tT f=0,x=0;char c=getchar();\n\twhile(!isdigit(c)) f=c=='-',c=getchar();\n\twhile(isdigit(c)) x=x*10+c-48,c=getchar();\n\treturn f?-x:x;\n}\n#define int long long\nnamespace run{\n\tinline char getc(){\n\t\tchar c=getchar();\n\t\twhile(c!='L' && c!='R' && c!='U' && c!='D') c=getchar();\n\t\treturn c;\n\t}\n\n\tconst int N=20009,inf=1e18;\n\tint head[N],nex[N],to[N],w[N],fl[N],cnt=1;\n\tinline void add(int u,int v,int flow,int c){\n\t//\tcout<<u<<\" \"<<v<<\" \"<<flow<<\" \"<<c<<endl;\n\t\tnex[++cnt]=head[u],head[u]=cnt,to[cnt]=v,w[cnt]=c,fl[cnt]=flow;\n\t\tnex[++cnt]=head[v],head[v]=cnt,to[cnt]=u,w[cnt]=-c,fl[cnt]=0;\n\t}\n\tint S,T,dist[N],vis[N],pre[N],mnfl[N];\n\tqueue<int> q;\n\tinline bool spfa(){\n\t\tfor(int i=1;i<=T;i++) dist[i]=-inf;\n\t\tdist[S]=0,q.push(S),mnfl[S]=inf;\n\n\t\twhile(!q.empty()){\n\t\t\tint u=q.front();q.pop();\n\t\t\tvis[u]=0;\n\t\t\tfor(int i=head[u];i;i=nex[i]){\n\t\t\t\tif(fl[i]>0 && dist[to[i]]<dist[u]+w[i]){\n\t\t\t\t\tdist[to[i]]=dist[u]+w[i],pre[to[i]]=i;\n\t\t\t\t\tmnfl[to[i]]=min(mnfl[u],fl[i]);\n\t\t\t\t\tif(!vis[to[i]]) q.push(to[i]),vis[to[i]]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dist[T]==-inf) return 0;\n\t\treturn 1;\n\t}\n\tinline void upd(){\n\t\tint tmp=T;\n\t\twhile(tmp!=S){\n\t\t\tint nxt=to[pre[tmp]^1];\n\t\t\tfl[pre[tmp]]-=mnfl[T],fl[pre[tmp]^1]+=mnfl[T];\n\t\t\ttmp=nxt;\n\t\t}\n\t}\n\n\ttypedef pair<int,int> P;\n\tint n,X[N],Y[N],V[N],m,A[N],B[N];char s[N];\n\tP L[N],R[N];\n\tint main(){\n\t\tn=read<int>();\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tX[i]=read<int>(),Y[i]=read<int>(),V[i]=read<int>();\n\t\tm=read<int>();\n\t\tfor(int i=1;i<=m;i++)\n\t\t\ts[i]=getc(),A[i]=read<int>(),B[i]=read<int>();\n\t\t\n\t\tint ans=0;\n\t\tfor(int k=1;k<=n;k++){\n\t\t\tfor(int i=1;i<=2*n+2*k+2;i++) head[i]=0;\n\t\t\tcnt=1;\n\t\t\tfor(int i=1;i<=k;i++) L[i]=P(-inf,inf),R[i]=P(-inf,inf);\n\t\t\tfor(int i=1;i<=m;i++){\n\t\t\t\tif(s[i]=='L') for(int j=B[i]+1;j<=k;j++) L[j].first=max(L[j].first,A[i]+1);\n\t\t\t\tif(s[i]=='R') for(int j=1;j<=k-B[i];j++) L[j].second=min(L[j].second,A[i]-1);\n\t\t\t\tif(s[i]=='D') for(int j=B[i]+1;j<=k;j++) R[j].first=max(R[j].first,A[i]+1);\n\t\t\t\tif(s[i]=='U') for(int j=1;j<=k-B[i];j++) R[j].second=min(R[j].second,A[i]-1);\n\t\t\t}\n\n\t\t\tfor(int i=1;i<=k;i++)\n\t\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\t\tif(L[i].first<=X[j] && X[j]<=L[i].second) add(i,j+k,1,0);\n\t\t\t\t\tif(R[i].first<=Y[j] && Y[j]<=R[i].second) add(k+n+j,i+k+2*n,1,0);\n\t\t\t\t}\n\n\t\t\tS=2*k+2*n+1,T=S+1;\n\t\t\tfor(int i=1;i<=k;i++) add(S,i,1,0),add(i+k+2*n,T,1,0);\n\t\t\tfor(int i=1;i<=n;i++) add(i+k,i+k+n,1,V[i]);\n\n\t\t\tint ret=0;\n\t\t\twhile(spfa()) ret+=dist[T]*mnfl[T],upd();\n\t\t\tans=max(ans,ret);\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t\treturn 0;\n\t}\n}\n#undef int\nint main(){\n#ifdef my\n\tfreopen(\".in\",\"r\",stdin);\n\tfreopen(\".out\",\"w\",stdout);\n#endif\n\treturn run::main();\n}"
  },
  {
    "language": "C++",
    "code": "// Author -- Frame\n\n#include<bits/stdc++.h>\n\n#define lowbit(x) ((x)&(-x))\n#define Finline __inline__ __attribute__ ((always_inline))\n#define DEBUG fprintf(stderr,\"Running on Line %d in Function %s\\n\",__LINE__,__FUNCTION__)\n#define SZ(x) ((int)x.size())\n#define mkpr std::make_pair\n#define pb push_back\n\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> pi;\ntypedef std::pair<ll,ll> pl;\n\nconst int inf=0x3f3f3f3f,Inf=0x7fffffff;\nconst ll INF=0x3f3f3f3f3f3f3f3f;\n\nFinline uint rnd()\n{\n\tstatic uint seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\ntemplate <typename _Tp>_Tp gcd(const _Tp &a,const _Tp &b){return (!b)?a:gcd(b,a%b);}\ntemplate <typename _Tp>Finline _Tp abs(const _Tp &a){return a>=0?a:-a;}\ntemplate <typename _Tp>Finline _Tp max(const _Tp &a,const _Tp &b){return a<b?b:a;}\ntemplate <typename _Tp>Finline _Tp min(const _Tp &a,const _Tp &b){return a<b?a:b;}\ntemplate <typename _Tp>Finline void chmax(_Tp &a,const _Tp &b){(a<b)&&(a=b);}\ntemplate <typename _Tp>Finline void chmin(_Tp &a,const _Tp &b){(b<a)&&(a=b);}\ntemplate <typename _Tp>Finline void read(_Tp &x)\n{\n\tchar ch(getchar());\n\tbool f(false);\n\twhile(ch<48||ch>57) f|=ch==45,ch=getchar();\n\tx=ch&15,ch=getchar();\n\twhile(ch>=48&&ch<=57) x=(((x<<2)+x)<<1)+(ch&15),ch=getchar();\n\tif(f) x=-x;\n}\ntemplate <typename _Tp,typename... Args>Finline void read(_Tp &t,Args &...args){read(t);read(args...);}\nFinline int read_str(char *s)\n{\n\tchar ch(getchar());\n\twhile(ch==' '||ch=='\\r'||ch=='\\n') ch=getchar();\n\tchar *tar=s;\n\t*tar=ch,ch=getchar();\n\twhile(ch!=' '&&ch!='\\r'&&ch!='\\n'&&ch!=EOF) *(++tar)=ch,ch=getchar();\n\treturn tar-s+1;\n}\n\nconst int N=405;\nint x[N],y[N];\nll val[N];\nstruct edge{\n\tint v,nxt,w;\n\tll cost;\n}c[N*N<<3];\nint front[N],edge_cnt;\nFinline void addedge(int u,int v,int w,ll cost)\n{\n\tc[++edge_cnt]=(edge){v,front[u],w,cost};\n\tfront[u]=edge_cnt;\n\t\n\tc[++edge_cnt]=(edge){u,front[v],0,-cost};\n\tfront[v]=edge_cnt;\n}\nchar opt[N];\nint C[N],D[N];\nint L[N],R[N];\nint S,T;\nll dep[N];\nint cur[N];\nint _q[N*N],_l,_r;\nbool inq[N];\nbool bfs()\n{\n\tmemcpy(cur,front,sizeof(cur));\n\tmemset(dep,63,sizeof(dep));\n\tmemset(inq,0,sizeof(inq));\n\t_q[_l=_r=1]=S;\n\tdep[S]=0;\n\twhile(_l!=_r+1)\n\t{\n\t\tint x=_q[_l++];\n\t\tinq[x]=false;\n\t\tfor(int i=front[x];~i;i=c[i].nxt)\n\t\t{\n\t\t\tint v=c[i].v;\n\t\t\tif(c[i].w&&dep[v]>dep[x]+c[i].cost)\n\t\t\t{\n\t\t\t\tdep[v]=dep[x]+c[i].cost;\n\t\t\t\tif(!inq[v]) inq[v]=true,_q[++_r]=v;\n\t\t\t}\n\t\t}\n\t}\n\treturn dep[T]<INF;\n}\nint dfs(int x,int flow)\n{\n\tif(x==T||!flow) return flow;\n\tinq[x]=true;\n\tint f=0,rf;\n\tfor(int &i=cur[x];~i;i=c[i].nxt)\n\t{\n\t\tif(!inq[c[i].v]&&dep[c[i].v]==dep[x]+c[i].cost&&(rf=dfs(c[i].v,min(flow,c[i].w))))\n\t\t{\n\t\t\tflow-=rf,f+=rf;\n\t\t\tc[i].w-=rf,c[i^1].w+=rf;\n\t\t\tif(!flow) return f;\n\t\t}\n\t}\n\treturn f;\n}\npl dinic()\n{\n\tint res=0;\n\tll ans=0;\n\twhile(bfs())\n\t{\n\t\tint tmp=dfs(S,inf);\n\t\tres+=tmp;\n\t\tans+=1ll*tmp*dep[T];\n\t}\n\treturn mkpr(res,ans);\n}\nint main()\n{\n\tint n,m;\n\tread(n);\n\tfor(int i=1;i<=n;++i) read(x[i],y[i],val[i]);\n\tread(m);\n\tfor(int i=1;i<=m;++i)\n\t{\n\t\tchar ch=getchar();\n\t\twhile(!isalpha(ch)) ch=getchar();\n\t\topt[i]=ch;\n\t\tread(C[i],D[i]);\n\t}\n\tll res=0;\n\tfor(int k=1;k<=n;++k)\n\t{\n\t\tedge_cnt=-1;\n\t\tmemset(front,255,sizeof(front));\n\t\tmemset(L,-63,sizeof(L)),memset(R,63,sizeof(R));\n\t\tfor(int i=1;i<=m;++i)\n\t\t{\n\t\t\tif(D[i]>=k) continue;\n\t\t\tif(opt[i]=='L') chmax(L[D[i]+1],C[i]+1);\n\t\t\telse if(opt[i]=='R') chmin(R[k-D[i]],C[i]-1);\n\t\t\telse if(opt[i]=='D') chmax(L[D[i]+1+k],C[i]+1);\n\t\t\telse chmin(R[k-D[i]+k],C[i]-1);\n\t\t}\n\t\tfor(int i=2;i<=k;++i) chmax(L[i],L[i-1]);\n\t\tfor(int i=k-1;i>=1;--i) chmin(R[i],R[i+1]);\n\t\tfor(int i=k+2;i<=k+k;++i) chmax(L[i],L[i-1]);\n\t\tfor(int i=k+k-1;i>k;--i) chmin(R[i],R[i+1]);\n\t\tS=n+n+k+k+1;\n\t\tT=S+1;\n\t\tfor(int i=1;i<=k;++i)\n\t\t{\n\t\t\taddedge(S,i,1,0);\n\t\t\taddedge(i+k,T,1,0);\n\t\t\tfor(int j=1;j<=n;++j)\n\t\t\t{\n\t\t\t\tif(x[j]>=L[i]&&x[j]<=R[i]) addedge(i,j+k+k,1,0);\n\t\t\t\tif(y[j]>=L[i+k]&&y[j]<=R[i+k]) addedge(j+k+k+n,i+k,1,0);\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=n;++i) addedge(i+k+k,i+k+k+n,1,-val[i]);\n\t\tpl ans=dinic();\n\t\tif(ans.first==k) chmax(res,-ans.second);\n\t}\n\tprintf(\"%lld\\n\",res);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int N=505,M=200005;\nint b[N],a[N],z[N],S,T,flag[N],x[N],y[N],opt[N],lx[N],rx[N],ly[N],ry[N],n,m,sl[M],ne[M],fi[N],zz[M],w[M],tot,dis[N],cur[N];\nqueue<int> Q;\nvoid jb(int x,int y,int z,int v){\n\tne[++tot]=fi[x];fi[x]=tot;zz[tot]=y;sl[tot]=z;w[tot]=v;\n\tne[++tot]=fi[y];fi[y]=tot;zz[tot]=x;sl[tot]=0;w[tot]=-v;\n}\nint get(){\n\tchar s[2];\n\tscanf(\"%s\",s);\n\tif (s[0]=='L')return 1;\n\tif (s[0]=='R')return 2;\n\tif (s[0]=='D')return 3;\n\treturn 4;\n}\nint bfs(){\n\tQ.push(S);\n\tmemset(dis,0x3f3f3f3f,sizeof dis);\n\tdis[0]=0;\n\twhile (!Q.empty()){\n\t\tint now=Q.front();Q.pop();\n\t\tflag[now]=0;\n\t\tfor (int i=fi[now];i;i=ne[i])\n\t\t\tif (sl[i]&&dis[zz[i]]>dis[now]+w[i]){\n\t\t\t\tdis[zz[i]]=dis[now]+w[i];\n\t\t\t\tif (!flag[zz[i]]){\n\t\t\t\t\tflag[zz[i]]=1;\n\t\t\t\t\tQ.push(zz[i]);\n\t\t\t\t}\n\t\t\t}\n\t}\n\treturn dis[T]<=1e18;\n}\nint dfs(int x,int y){\n\tif (x==T)return y;\n\tint s=0,b;\n\tflag[x]=1;\n\tfor (int &i=cur[x];i;i=ne[i])\n\t\tif (sl[i]&&!flag[zz[i]]&&dis[zz[i]]==dis[x]+w[i]&&(b=min(sl[i],dfs(zz[i],min(sl[i],y))))){\n\t\t\ts+=b;y-=b;\n\t\t\tsl[i]-=b;\n\t\t\tsl[i^1]+=b;\n\t\t\tif (!y)return s;\n\t\t}\n\treturn s;\n}\nsigned main(){\n\tscanf(\"%lld\",&n);\n\tfor (int i=1;i<=n;i++)scanf(\"%lld%lld%lld\",&x[i],&y[i],&z[i]);\n\tscanf(\"%lld\",&m);\n\tfor (int i=1;i<=m;i++){\n\t\topt[i]=get();\n\t\tscanf(\"%lld%lld\",&a[i],&b[i]);\n\t}\n\tS=0;T=1;\n\tint ans=0;\n\tfor (int k=1;k<=n;k++){\n\t\tmemset(fi,0,sizeof fi);\n\t\ttot=1;\n\t\tfor (int i=1;i<=k;i++)rx[i]=ry[i]=1e9,lx[i]=ly[i]=0;\n\t\tfor (int i=1;i<=m;i++){\n\t\t\tif (opt[i]==1&&b[i]<k)lx[b[i]+1]=max(lx[i],a[i]+1);\n\t\t\tif (opt[i]==2&&k>b[i])rx[k-b[i]]=min(rx[k-b[i]],a[i]-1);\n\t\t\tif (opt[i]==3&&b[i]<k)ly[b[i]+1]=max(ly[i],a[i]+1);\n\t\t\tif (opt[i]==4&&k>b[i])ry[k-b[i]]=min(ry[k-b[i]],a[i]-1);\n\t\t}\n\t\tfor (int i=2;i<=k;i++)lx[i]=max(lx[i-1],lx[i]);\n\t\tfor (int i=k-1;i;i--)rx[i]=min(rx[i+1],rx[i]);\n\t\tfor (int i=2;i<=k;i++)ly[i]=max(ly[i-1],ly[i]);\n\t\tfor (int i=k-1;i;i--)ry[i]=min(ry[i+1],ry[i]);\n\t\tfor (int i=2;i<=k+1;i++)jb(S,i,1,0);\n\t\tfor (int i=2;i<=k+1;i++)jb(i+k,T,1,0);\n\t\tfor (int i=1;i<=k;i++)\n\t\t\tfor (int j=1;j<=n;j++)\n\t\t\t\tif (lx[i]<=x[j]&&rx[i]>=x[j])jb(i+1,j+2*k+1,1,0);\n\t\tfor (int i=1;i<=k;i++)\n\t\t\tfor (int j=1;j<=n;j++)\n\t\t\t\tif (ly[i]<=y[j]&&ry[i]>=y[j])jb(j+2*k+1+n,i+k+1,1,0);\n\t\tfor (int i=1;i<=n;i++)jb(i+2*k+1,i+n+2*k+1,1,-z[i]);\n\t\tint ansc=0,ansm=0;\n\t\twhile (bfs()){\n\t\t\tfor (int i=0;i<=2*k+1+2*n;i++)cur[i]=fi[i];\n\t\t\tint t=dfs(S,1e9);\n\t\t\tansm+=t;\n\t\t\tansc+=t*dis[T];\n\t\t\tfor (int i=0;i<=2*k+1+2*n;i++)flag[i]=0;\n\t\t}\n\t\tif (ansm==k)ans=max(ans,-ansc);\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint m, n, x[85], y[85];\nint a[333], b[333];\nchar t[333];\nbool taken[85];\nlong long ans, sum, v[85];\nint l[105], r[105], d[105], u[105];\nbool check() {\n\tfor(int i = 0; i < m; ++i) {\n\t\tswitch(t[i]) {\n\t\t\tcase 'L':{\n\t\t\t\tif(l[a[i]] > b[i]) return 0;\n\t\t\t\tbreak;\n\t\t\t} \n\t\t\tcase 'R':{\n\t\t\t\tif(r[a[i]] > b[i]) return 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'U':{\n\t\t\t\tif(u[a[i]] > b[i]) return 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'D': {\n\t\t\t\tif(d[a[i]] > b[i]) return 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}\nvoid add(int k, int f) {\n\tfor(int i = 1; i <= x[k]; ++i) r[i] += f;\n\tfor(int i = x[k]; i <= 100; ++i) l[i] += f;\n\tfor(int i = 1; i <= y[k]; ++i) u[i] += f;\n\tfor(int i = y[k]; i <= 100; ++i) d[i] += f;\n}\nvoid climb() {\n\tbool flag = 1;\n\twhile(flag) {\n\t\tflag = 0;\n\t\tint k = 0;\n\t\tlong long mx = 0;\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tif(!taken[i]) {\n\t\t\t\tadd(i, 1);\n\t\t\t\tif(check() && v[i] > mx) mx = v[i], k = i;\n\t\t\t\tadd(i, -1);\n\t\t\t}\n\t\tif(mx) {\n\t\t\tflag = 1;\n\t\t\tadd(k, 1);\n\t\t\ttaken[k] = 1;\n\t\t\tsum += mx;\n\t\t}\n\t}\n\t/*if(sum == 39ll) {\n\t\tprintf(\"%d %d %d %d\\n\", l[3], r[2], d[5], u[4]);\n\t}*/\n\tans = max(ans, sum);\n}\nint main() {\n\tsrand(time(0));\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; ++i)\n\t\tscanf(\"%d%d%lld\", x+i, y+i, v+i);\n\tscanf(\"%d\", &m);\n\tchar s[5];\n\tfor(int i = 0; i < m; ++i)\n\t\tscanf(\"%s%d%d\", s, a+i, b+i), t[i] = s[0];\n\tint T = 100000;\n\tfor(int i = 0; i < T; ++i) {\n\t\tsum = 0;\n\t\tfor(int j = 1; j <= 100; ++j)\n\t\t\tl[j] = r[j] = d[j] = u[j] = 0;\n\t\tfor(int j = 0; j < n; ++j) {\n\t\t\ttaken[j] = rand() % 2;\n\t\t\tif(taken[j]) add(j, 1), sum += v[j];\n\t\t}\n\t\tif(check()) \n\t\t{\n\t\t\tclimb();\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#define foreach(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\n#ifndef LOCAL\n#define cerr if(0)cout\n#endif\ntypedef long long ll;\nconst int mod = 1e9+7;\n//My i/o stream\nstruct fastio\n{\n\tchar s[100000];\n\tint it, len;\n\tfastio() {it=len=0;}\n\tinline char get()\n\t{\n\t\tif (it<len) return s[it++]; it=0;\n\t\tlen=fread(s, 1, 100000, stdin);\n\t\tif (len==0) return EOF; else return s[it++];\n\t}\n\tbool notend()\n\t{\n\t\tchar c=get();\n\t\twhile (c==' '||c=='\\n') c=get();\n\t\tif (it>0) it--;\n\t\treturn c!=EOF;\n\t}\n}_buff;\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putchar(' ')\n#define putii(x,y) puti(x),puti(y)\n#define putiii(x,y,z) putii(x,y),puti(z)\n#define putsi(x) putnum(x),putchar('\\n')\n#define putsii(x,y) puti(x),putsi(y)\n#define putsiii(x,y,z) putii(x,y),putsi(z)\ninline ll getnum()\n{\n\tll r=0; bool ng=0; char c; c=_buff.get();\n\twhile (c!='-'&&(c<'0'||c>'9')) c=_buff.get();\n\tif (c=='-') ng=1, c=_buff.get();\n\twhile (c>='0'&&c<='9') r=r*10+c-'0', c=_buff.get();\n\treturn ng?-r:r;\n}\ntemplate <class T> inline void putnum(T x)\n{\n\tif (x<0) putchar('-'), x=-x;\n\tregister short a[20]={}, sz=0;\n\twhile (x) a[sz++]=x%10, x/=10;\n\tif(sz==0) putchar('0');\n\tfor (int i=sz-1; i>=0; i--) putchar('0'+a[i]);\n}\ninline char getreal() {char c=_buff.get(); while (c<=32) c=_buff.get(); return c;}\nll qpow(ll x, ll k) {return k==0? 1: 1ll*qpow(1ll*x*x%mod,k>>1)*(k&1?x:1)%mod;}\nconst ll inf = 4e18;\nnamespace F\n{\n\tconst int maxn = 1011, maxe = 20011;\n\tint head[maxn], nxt[maxe], to[maxe], cap[maxe];\n\tll cost[maxe], tot;\n\tll ftot;\n\tvoid init()\n\t{\n\t\ttot = 1;\n\t\tmemset(head, 0, sizeof(head));\n\t}\n\tvoid add_edge(int x, int y, int c, ll w)\n\t{\n//\t\tcerr<<\"add_edge:\"<<x<<\",\"<<y<<\" \"<<c<<\" \"<<w<<endl;\n\t\tnxt[++tot] = head[x];\n\t\thead[x] = tot;\n\t\tto[tot] = y;\n\t\tcap[tot] = c;\n\t\tcost[tot] = w;\n\t\tswap(x, y);\n\t\tnxt[++tot] = head[x];\n\t\thead[x] = tot;\n\t\tto[tot] = y;\n\t\tcap[tot] = 0;\n\t\tcost[tot] = -w;\n\t}\n\tint q[maxn], qb, qe;\n\tll dis[maxn];\n\tbool inq[maxn];\n\tint qnxt(int x) {return (x+1)%maxn;}\n\tint qpre(int x) {return (x-1+maxn)%maxn;}\n\tvoid balance()\n\t{\n\t\tif (qb!=qe&&dis[q[qpre(qe)]]<dis[q[qb]])\n\t\t{\n\t\t\tswap(q[qpre(qe)], q[qb]);\n\t\t}\n\t}\n\tvoid spfa(int S, int N)\n\t{\n\t\tinq[S] = 1;\n\t\tfor (int i=0; i<=N; i++) dis[i] = inf;\n\t\tdis[S] = 0;\n\t\tqb = qe = 0;\n\t\tq[qe++] = S;\n\t\twhile (qb<qe)\n\t\t{\n\t\t\tint x = q[qb];\n\t\t\tinq[x] = 0;\n\t\t\tqb = qnxt(qb);\n\t\t\tbalance();\n\t\t\tfor (int i = head[x]; i; i=nxt[i])\n\t\t\t{\n\t\t\t\tif (cap[i]&&dis[to[i]]>dis[x]+cost[i])\n\t\t\t\t{\n\t\t\t\t\tdis[to[i]] = dis[x]+cost[i];\n\t\t\t\t\tif (!inq[to[i]])\n\t\t\t\t\t{\n\t\t\t\t\t\tinq[to[i]] = 1;\n\t\t\t\t\t\tq[qe] = to[i];\n\t\t\t\t\t\tqe = qnxt(qe);\n\t\t\t\t\t\tbalance();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tfor (int i=1; i<=N; i++) cerr<<dis[i]<<\" \"; cerr<<endl;\n\t}\n\t\n\tbool vis[maxn];\n\tint dfs(int x, int T, int f)\n\t{\n\t\tif (x==T) return f;\n\t\tvis[x] = 1;\n\t\tint of = f;\n\t\tfor (int i=head[x]; i; i=nxt[i])\n\t\t{\n\t\t\tif (!vis[to[i]]&&cap[i]&&dis[to[i]]==dis[x]+cost[i])\n\t\t\t{\n\t\t\t\tint u = to[i];\n\t\t\t\tint d = dfs(u, T, min(f, cap[i]));\n\t\t\t\tcap[i] -= d;\n\t\t\t\tcap[i^1] += d;\n\t\t\t\tf -= d;\n\t\t\t\tif (!f) return of;\n\t\t\t}\n\t\t}\n\t\treturn of-f;\n\t}\n\tll min_cost_max_flow(int S, int T, int K)\n\t{\n\t\tll ans = 0;\n\t\twhile (true)\n\t\t{\n\t\t\tspfa(S, T);\n\t\t\tif (dis[T]>=inf) return ans;\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\tmemset(vis, 0, sizeof(vis));\n\t\t\t\tint f = dfs(S, T, K);\n\t\t\t\tftot += f;\n\t\t\t\tans += 1ll*f*dis[T];\n\t\t\t\tif (f==0) break;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n};\nint n;\nint tid[256];\npair<int,int> a[88];\nll w[88];\nvector<pair<int,int> > M[4];\npair<int,int> segx[88], segy[88];\nll solve(int K)\n{\n//\tcerr<<\"solve: \"<<K<<endl;\n\tfor (int i=1; i<=K; i++) segx[i] = segy[i] = MP(0, 100);\n\tfor (auto x : M[0])\n\t{\n\t\tfor (int i=x.SS+1; i<=K; i++)\n\t\t{\n\t\t\tsegx[i].FF = max(segx[i].FF, x.FF+1);\n\t\t}\n\t}\n\tfor (auto x : M[1])\n\t{\n\t\tfor (int i=K-x.SS; i>=1; i--)\n\t\t{\n\t\t\tsegx[i].SS = min(segx[i].SS, x.FF-1);\n\t\t}\n\t}\n\tfor (auto x : M[2])\n\t{\n\t\tfor (int i=x.SS+1; i<=K; i++)\n\t\t{\n\t\t\tsegy[i].FF = max(segy[i].FF, x.FF+1);\n\t\t}\n\t}\n\tfor (auto x : M[3])\n\t{\n\t\tfor (int i=K-x.SS; i>=1; i--)\n\t\t{\n\t\t\tsegy[i].SS = min(segy[i].SS, x.FF-1);\n\t\t}\n\t}\n/*\tfor (int i=1; i<=K; i++)\n\t{\n\t\tcerr<<\"(\"<<segx[i].FF<<\",\"<<segx[i].SS<<\") (\"<<segy[i].FF<<\",\"<<segy[i].SS<<\")\"<<endl;\n\t}\n*/\t\n\tint S = 2*K+2*n+1, T = S+1;\n//\tcerr<<\"S=\"<<S<<\" T=\"<<T<<endl;\n\tF::init();\n\tfor (int i=1; i<=K; i++)\n\t{\n\t\tF::add_edge(S, i, 1, 0);\n\t\tF::add_edge(i+K, T, 1, 0);\n\t\tfor (int j=1; j<=n; j++)\n\t\t{\n\t\t\tif (segx[i].FF<=a[j].FF&&a[j].FF<=segx[i].SS)\n\t\t\t{\n\t\t\t\tF::add_edge(i, j+2*K, 1, 0);\n\t\t\t}\n\t\t\tif (segy[i].FF<=a[j].SS&&a[j].SS<=segy[i].SS)\n\t\t\t{\n\t\t\t\tF::add_edge(j+2*K+n, i+K, 1, 0);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1; i<=n; i++) F::add_edge(i+2*K, i+2*K+n, 1, -w[i]);\n\tll ans = F::min_cost_max_flow(S, T, K);\n//\tcerr<<\"F::ftot=\"<<F::ftot<<endl;\n\tif (F::ftot<K) return 0;\n//\tcerr<<\"ans=\"<<ans<<endl;\n\treturn -ans;\n}\nint main()\n{\n\ttid['L'] = 0;\n\ttid['R'] = 1;\n\ttid['D'] = 2;\n\ttid['U'] = 3;\n\tgeti(n);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tll x, y, v;\n\t\tgetiii(x, y, v);\n\t\ta[i] = MP(x, y);\n\t\tw[i] = v;\n\t}\n\tint m;\n\tgeti(m);\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\tchar t;\n\t\tint a, b;\n\t\tt = getreal();\n\t\tgetii(a, b);\n\t\tM[tid[t]].PB(MP(a, b));\n\t}\n\tll ans = 0;\n\tfor (int K=1; K<=n; K++)\n\t{\n\t\tans = max(ans, solve(K));\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* cerberus97 - Hanit Banga */\n\n#include <iostream>\n#include <iomanip>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define pb push_back\n#define fast_cin() ios_base::sync_with_stdio(false); cin.tie(NULL)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\n\nconst int N = 1e5 + 10;\n\n// Two-phase simplex algorithm for solving linear programs of the form\n//\n//     maximize     c^T x\n//     subject to   Ax <= b\n//                  x >= 0\n//\n// INPUT: A -- an m x n matrix\n//        b -- an m-dimensional vector\n//        c -- an n-dimensional vector\n//        x -- a vector where the optimal solution will be stored\n//\n// OUTPUT: value of the optimal solution (infinity if unbounded\n//         above, nan if infeasible)\n//\n// To use this code, create an LPSolver object with A, b, and c as\n// arguments.  Then, call Solve(x).\n\ntypedef long double DOUBLE;\ntypedef vector<DOUBLE> VD;\ntypedef vector<VD> VVD;\ntypedef vector<int> VI;\n\nconst DOUBLE EPS = 1e-9;\n\nstruct LPSolver {\n  int m, n;\n  VI B, N;\n  VVD D;\n\n  LPSolver(const VVD &A, const VD &b, const VD &c) :\n    m(b.size()), n(c.size()), N(n+1), B(m), D(m+2, VD(n+2)) {\n    for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) D[i][j] = A[i][j];\n    for (int i = 0; i < m; i++) { B[i] = n+i; D[i][n] = -1; D[i][n+1] = b[i]; }\n    for (int j = 0; j < n; j++) { N[j] = j; D[m][j] = -c[j]; }\n    N[n] = -1; D[m+1][n] = 1;\n  }\n\n  void Pivot(int r, int s) {\n    DOUBLE inv = 1.0 / D[r][s];\n    for (int i = 0; i < m+2; i++) if (i != r)\n      for (int j = 0; j < n+2; j++) if (j != s)\n        D[i][j] -= D[r][j] * D[i][s] * inv;\n    for (int j = 0; j < n+2; j++) if (j != s) D[r][j] *= inv;\n    for (int i = 0; i < m+2; i++) if (i != r) D[i][s] *= -inv;\n    D[r][s] = inv;\n    swap(B[r], N[s]);\n  }\n\n  bool Simplex(int phase) {\n    int x = phase == 1 ? m+1 : m;\n    while (true) {\n      int s = -1;\n      for (int j = 0; j <= n; j++) {\n        if (phase == 2 && N[j] == -1) continue;\n        if (s == -1 || D[x][j] < D[x][s] || D[x][j] == D[x][s] && N[j] < N[s]) s = j;\n      }\n      if (s < 0 || D[x][s] > -EPS) return true;\n      int r = -1;\n      for (int i = 0; i < m; i++) {\n        if (D[i][s] < EPS) continue;\n        if (r == -1 || D[i][n+1] / D[i][s] < D[r][n+1] / D[r][s] ||\n            D[i][n+1] / D[i][s] == D[r][n+1] / D[r][s] && B[i] < B[r]) r = i;\n      }\n      if (r == -1) return false;\n      Pivot(r, s);\n    }\n  }\n\n  DOUBLE Solve(VD &x) {\n    int r = 0;\n    for (int i = 1; i < m; i++) if (D[i][n+1] < D[r][n+1]) r = i;\n    if (D[r][n+1] <= -EPS) {\n      Pivot(r, n);\n      if (!Simplex(1) || D[m+1][n+1] < -EPS) return -numeric_limits<DOUBLE>::infinity();\n      for (int i = 0; i < m; i++) if (B[i] == -1) {\n        int s = -1;\n        for (int j = 0; j <= n; j++)\n          if (s == -1 || D[i][j] < D[i][s] || D[i][j] == D[i][s] && N[j] < N[s]) s = j;\n        Pivot(i, s);\n      }\n    }\n    if (!Simplex(2)) return numeric_limits<DOUBLE>::infinity();\n    x = VD(n);\n    for (int i = 0; i < m; i++) if (B[i] < n) x[B[i]] = D[i][n+1];\n    return D[m][n+1];\n  }\n};\n\nconst int P = 100, M = 350;\n\nint x[P], y[P]; ll v[P];\nchar t[M]; int a[M], b[M];\n\nint main() {\n\tfast_cin();\n\tint n; cin >> n;\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> x[i] >> y[i] >> v[i];\n\t}\n\tint m; cin >> m;\n\tfor (int i = 0; i < m; ++i) {\n\t\tcin >> t[i] >> a[i] >> b[i];\n\t}\n\tVVD A(m + n, VD(n));\n\tVD B(m + n);\n\tVD C(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tC[i] = v[i];\n\t}\n\tfor (int i = 0; i < m; ++i) {\n\t\tB[i] = b[i];\n\t}\n\tfor (int i = m; i < m + n; ++i) {\n\t\tB[i] = 1;\n\t}\n\tfor (int i = 0; i < m; ++i) {\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tif (t[i] == 'L') {\n\t\t\t\tA[i][j] = (x[j] <= a[i]);\n\t\t\t} else if (t[i] == 'R') {\n\t\t\t\tA[i][j] = (x[j] >= a[i]);\n\t\t\t} else if (t[i] == 'D') {\n\t\t\t\tA[i][j] = (y[j] <= a[i]);\n\t\t\t} else {\n\t\t\t\tA[i][j] = (y[j] >= a[i]);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = m; i < m + n; ++i) {\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tA[i][j] = 0;\n\t\t}\n\t\tA[i][i - m] = 1;\n\t}\n\tVD X(n);\n\tLPSolver LPS(A, B, C);\n\tcout << ll(LPS.Solve(X) + 0.5) << endl;\n\t// cout << LPS.Solve(X) << endl;\n\t// for (auto &i : X) {\n\t// \tcout << i << ' ';\n\t// }\n}"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#define foreach(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\n#ifndef LOCAL\n#define cerr if(0)cout\n#endif\ntypedef long long ll;\nconst int mod = 1e9+7;\n//My i/o stream\nstruct fastio\n{\n\tchar s[100000];\n\tint it, len;\n\tfastio() {it=len=0;}\n\tinline char get()\n\t{\n\t\tif (it<len) return s[it++]; it=0;\n\t\tlen=fread(s, 1, 100000, stdin);\n\t\tif (len==0) return EOF; else return s[it++];\n\t}\n\tbool notend()\n\t{\n\t\tchar c=get();\n\t\twhile (c==' '||c=='\\n') c=get();\n\t\tif (it>0) it--;\n\t\treturn c!=EOF;\n\t}\n}_buff;\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putchar(' ')\n#define putii(x,y) puti(x),puti(y)\n#define putiii(x,y,z) putii(x,y),puti(z)\n#define putsi(x) putnum(x),putchar('\\n')\n#define putsii(x,y) puti(x),putsi(y)\n#define putsiii(x,y,z) putii(x,y),putsi(z)\ninline ll getnum()\n{\n\tll r=0; bool ng=0; char c; c=_buff.get();\n\twhile (c!='-'&&(c<'0'||c>'9')) c=_buff.get();\n\tif (c=='-') ng=1, c=_buff.get();\n\twhile (c>='0'&&c<='9') r=r*10+c-'0', c=_buff.get();\n\treturn ng?-r:r;\n}\ntemplate <class T> inline void putnum(T x)\n{\n\tif (x<0) putchar('-'), x=-x;\n\tregister short a[20]={}, sz=0;\n\twhile (x) a[sz++]=x%10, x/=10;\n\tif(sz==0) putchar('0');\n\tfor (int i=sz-1; i>=0; i--) putchar('0'+a[i]);\n}\ninline char getreal() {char c=_buff.get(); while (c<=32) c=_buff.get(); return c;}\nll qpow(ll x, ll k) {return k==0? 1: 1ll*qpow(1ll*x*x%mod,k>>1)*(k&1?x:1)%mod;}\nconst ll inf = 4e18;\nnamespace F\n{\n\tconst int maxn = 2011, maxe = 100011;\n\tint head[maxn], nxt[maxe], to[maxe], cap[maxe];\n\tll cost[maxe], tot;\n\tll ftot;\n\tvoid init()\n\t{\n\t\tftot = 0;\n\t\ttot = 1;\n\t\tmemset(head, 0, sizeof(head));\n\t}\n\tvoid add_edge(int x, int y, int c, ll w)\n\t{\n\t\tassert(x<maxn&&y<maxn);\n//\t\tcerr<<\"add_edge:\"<<x<<\",\"<<y<<\" \"<<c<<\" \"<<w<<endl;\n\t\tnxt[++tot] = head[x];\n\t\thead[x] = tot;\n\t\tto[tot] = y;\n\t\tcap[tot] = c;\n\t\tcost[tot] = w;\n\t\tswap(x, y);\n\t\tnxt[++tot] = head[x];\n\t\thead[x] = tot;\n\t\tto[tot] = y;\n\t\tcap[tot] = 0;\n\t\tcost[tot] = -w;\n\t\tassert(tot<maxe);\n\t}\n\tint q[maxn], qb, qe;\n\tll dis[maxn];\n\tbool inq[maxn];\n\tint qnxt(int x) {return (x+1)%maxn;}\n\tint qpre(int x) {return (x-1+maxn)%maxn;}\n\tvoid balance()\n\t{\n\t\tif (qb!=qe&&dis[q[qpre(qe)]]<dis[q[qb]])\n\t\t{\n\t\t\tswap(q[qpre(qe)], q[qb]);\n\t\t}\n\t}\n\tvoid spfa(int S, int N)\n\t{\n\t\tinq[S] = 1;\n\t\tfor (int i=0; i<=N; i++) dis[i] = inf;\n\t\tdis[S] = 0;\n\t\tqb = qe = 0;\n\t\tq[qe++] = S;\n\t\twhile (qb<qe)\n\t\t{\n\t\t\tint x = q[qb];\n\t\t\tinq[x] = 0;\n\t\t\tqb = qnxt(qb);\n\t\t\tbalance();\n\t\t\tfor (int i = head[x]; i; i=nxt[i])\n\t\t\t{\n\t\t\t\tif (cap[i]&&dis[to[i]]>dis[x]+cost[i])\n\t\t\t\t{\n\t\t\t\t\tdis[to[i]] = dis[x]+cost[i];\n\t\t\t\t\tif (!inq[to[i]])\n\t\t\t\t\t{\n\t\t\t\t\t\tinq[to[i]] = 1;\n\t\t\t\t\t\tq[qe] = to[i];\n\t\t\t\t\t\tqe = qnxt(qe);\n\t\t\t\t\t\tbalance();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tfor (int i=1; i<=N; i++) cerr<<dis[i]<<\" \"; cerr<<endl;\n\t}\n\t\n\tbool vis[maxn];\n\tint dfs(int x, int T, int f)\n\t{\n\t\tif (x==T) return f;\n\t\tvis[x] = 1;\n\t\tint of = f;\n\t\tfor (int i=head[x]; i; i=nxt[i])\n\t\t{\n\t\t\tif (!vis[to[i]]&&cap[i]&&dis[to[i]]==dis[x]+cost[i])\n\t\t\t{\n\t\t\t\tint u = to[i];\n\t\t\t\tint d = dfs(u, T, min(f, cap[i]));\n\t\t\t\tcap[i] -= d;\n\t\t\t\tcap[i^1] += d;\n\t\t\t\tf -= d;\n\t\t\t\tif (!f) return of;\n\t\t\t}\n\t\t}\n\t\treturn of-f;\n\t}\n\tll min_cost_max_flow(int S, int T, int K)\n\t{\n\t\tll ans = 0;\n\t\twhile (true)\n\t\t{\n\t\t\tspfa(S, T);\n\t\t\tif (dis[T]>=inf) return ans;\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\tmemset(vis, 0, sizeof(vis));\n\t\t\t\tint f = dfs(S, T, K);\n\t\t\t\tftot += f;\n\t\t\t\tans += 1ll*f*dis[T];\n\t\t\t\tif (f==0) break;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n};\nint n;\nint tid[256];\npair<int,int> a[88];\nll w[88];\nvector<pair<int,int> > M[4];\npair<int,int> segx[88], segy[88];\nll solve(int K)\n{\n//\tcerr<<\"solve: \"<<K<<endl;\n\tfor (int i=1; i<=K; i++) segx[i] = segy[i] = MP(0, 100);\n\tfor (auto x : M[0])\n\t{\n\t\tfor (int i=x.SS+1; i<=K; i++)\n\t\t{\n\t\t\tsegx[i].FF = max(segx[i].FF, x.FF+1);\n\t\t}\n\t}\n\tfor (auto x : M[1])\n\t{\n\t\tfor (int i=K-x.SS; i>=1; i--)\n\t\t{\n\t\t\tsegx[i].SS = min(segx[i].SS, x.FF-1);\n\t\t}\n\t}\n\tfor (auto x : M[2])\n\t{\n\t\tfor (int i=x.SS+1; i<=K; i++)\n\t\t{\n\t\t\tsegy[i].FF = max(segy[i].FF, x.FF+1);\n\t\t}\n\t}\n\tfor (auto x : M[3])\n\t{\n\t\tfor (int i=K-x.SS; i>=1; i--)\n\t\t{\n\t\t\tsegy[i].SS = min(segy[i].SS, x.FF-1);\n\t\t}\n\t}\n\tint S = 2*K+2*n+1, T = S+1;\n\tF::init();\n\tfor (int i=1; i<=K; i++)\n\t{\n\t\tF::add_edge(S, i, 1, 0);\n\t\tF::add_edge(i+K, T, 1, 0);\n\t\tfor (int j=1; j<=n; j++)\n\t\t{\n\t\t\tif (segx[i].FF<=a[j].FF&&a[j].FF<=segx[i].SS)\n\t\t\t{\n\t\t\t\tF::add_edge(i, j+2*K, 1, 0);\n\t\t\t}\n\t\t\tif (segy[i].FF<=a[j].SS&&a[j].SS<=segy[i].SS)\n\t\t\t{\n\t\t\t\tF::add_edge(j+2*K+n, i+K, 1, 0);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1; i<=n; i++) F::add_edge(i+2*K, i+2*K+n, 1, -w[i]);\n\tll ans = F::min_cost_max_flow(S, T, K);\n//\tcerr<<\"F::ftot=\"<<F::ftot<<endl;\n\tassert(F::ftot>=0&&F::ftot<=K);\n\tif (F::ftot<K) return 0;\n//\tcerr<<\"ans=\"<<ans<<endl;\n\treturn -ans;\n}\nint main()\n{\n\ttid['L'] = 0;\n\ttid['R'] = 1;\n\ttid['D'] = 2;\n\ttid['U'] = 3;\n\tgeti(n);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tll x, y, v;\n\t\tgetiii(x, y, v);\n\t\ta[i] = MP(x, y);\n\t\tw[i] = v;\n\t}\n\tint m;\n\tgeti(m);\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\tchar t;\n\t\tint a, b;\n\t\tt = getreal();\n\t\tgetii(a, b);\n\t\tM[tid[t]].PB(MP(a, b));\n\t}\n\tll ans = 0;\n\tfor (int K=1; K<=n; K++)\n\t{\n\t\tans = max(ans, solve(K));\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define TRACE(x) x\n#define WATCH(x) TRACE(cout << #x\" = \" << x << endl)\n#define WATCHR(a, b) TRACE(for (auto it=a; it!=b;) cout << *(it++) << \" \"; cout << endl)\n#define WATCHC(V) TRACE({cout << #V\" = \"; WATCHR(V.begin(), V.end());})\n\n#define all(x) (x).begin(), (x).end()\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate<typename F, typename C> struct min_cost_flow {\n    static constexpr int bits = 63 - __builtin_clzll(numeric_limits<F>::max());\n\n    int V;\n    vvi adj;\n    vi dest;\n    vector<F> cap;\n    vector<C> cost;\n\n    min_cost_flow(int V = 0) : V(V) {\n        adj.resize(V);\n    }\n\n    void __arc(int u, int v, F f, C c) {\n        adj[u].push_back(dest.size());\n        dest.push_back(v);\n        cap.push_back(f);\n        cost.push_back(c);\n    }\n\n    // Inserts a directed edge u --> v with capacity f and cost c.\n    void arc(int u, int v, F f, C c) {\n        __arc(u, v, f, c);\n        __arc(v, u, F(0), -c);\n    }\n\n    bool dijkstra(auto& imb, auto& flow, auto& pot, F delta) {\n        priority_queue<tuple<C, int, int>> q;\n        vi ent(V, -2);\n        vector<C> dist(V, numeric_limits<C>::max());\n        for (int v = 0; v < V; v++) if (imb[v] >= delta)\n            q.push({ 0., v, -1 });\n\n        while (!q.empty()) {\n            C d; int v, f; tie(d, v, f) = q.top(); q.pop();\n            if (ent[v] != -2) continue;\n            dist[v] = -d; ent[v] = f;\n            for (int e : adj[v]) if (cap[e] - flow[e] >= delta)\n                q.push({ d - (cost[e] + pot[v] - pot[dest[e]]), dest[e], e });\n        }\n\n        for (int v = 0; v < V; v++) if (ent[v] != -2 && imb[v] <= -delta) {\n            for (int u = 0; u < V; u++) pot[u] += dist[u];\n            for (int e = ent[v]; ~e; e = ent[dest[e^1]]) {\n                flow[e] += delta;\n                flow[e^1] -= delta;\n                imb[dest[e]] += delta;\n                imb[dest[e^1]] -= delta;\n            }\n            return true;\n        }\n        return false;\n    }\n\n    // O(E^2 * log V * bits)\n    pair<bool, C> solve(vector<F>& imb) {\n        vector<F> flow(cap.size());\n        vector<C> pot(V);\n        for (F delta = 1ll << bits; delta; delta >>= 1) {\n            for (int e = 0; e < dest.size(); e++) {\n                int u = dest[e^1], v = dest[e];\n                F res = cap[e] - flow[e];\n                if (res >= delta && cost[e] + pot[u] - pot[v] < 0) {\n                    flow[e^1] -= res;\n                    flow[e] += res;\n                    imb[u] -= res;\n                    imb[v] += res;\n                }\n            }\n            while (dijkstra(imb, flow, pot, delta));\n        }\n\n        C ans = 0;\n        for (int e = 0; e < dest.size(); e++) if (flow[e] > 0)  {\n            ans += flow[e] * cost[e];\n        }\n        return { imb == vector<F>(V, 0), ans };\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n\n    int N, M;\n    cin >> N;\n\n    vi x(N), y(N); vll val(N);\n    for (int i = 0; i < N; i++) {\n        cin >> x[i] >> y[i] >> val[i];\n    }\n\n    cin >> M;\n    string dir(M, '.'); vi loc(M), qua(M);\n    for (int i = 0; i < M; i++) {\n        cin >> dir[i] >> loc[i] >> qua[i];\n    }\n\n    auto pmin = [](vi& v, int inx, int val) {\n        if (inx >= 0 && inx < v.size()) v[inx] = min(v[inx], val);\n    };\n    auto pmax = [](vi& v, int inx, int val) {\n        if (inx >= 0 && inx < v.size()) v[inx] = max(v[inx], val);\n    };\n    auto best = [&](int K) {\n        vi xlo(K, 1), xhi(K, 100), ylo(K, 1), yhi(K, 100);\n        for (int i = 0; i < M; i++) {\n            if (dir[i] == 'L') pmax(xlo, qua[i], loc[i] + 1);\n            if (dir[i] == 'R') pmin(xhi, K - 1 - qua[i], loc[i] - 1);\n            if (dir[i] == 'D') pmax(ylo, qua[i], loc[i] + 1);\n            if (dir[i] == 'U') pmin(yhi, K - 1 - qua[i], loc[i] - 1);\n        }\n        for (int i = 1; i < K; i++) {\n            xlo[i] = max(xlo[i], xlo[i-1]);\n            ylo[i] = max(ylo[i], ylo[i-1]);\n        }\n        for (int i = K - 2; i >= 0; i--) {\n            xhi[i] = min(xhi[i], xhi[i+1]);\n            yhi[i] = min(yhi[i], yhi[i+1]);\n        }\n\n        const int V = 1 + K + 2 * N + K + 1;\n        const int SRC = 0, XL = 1, JL = 1 + K, YL = 1 + K + 2 * N, SNK = V - 1;\n\n        min_cost_flow<int, ll> g(V);\n        for (int i = 0; i < K; i++) {\n            g.arc(SRC, XL + i, 1, 0);\n            for (int j = 0; j < N; j++) {\n                if (xlo[i] <= x[j] && x[j] <= xhi[i])\n                    g.arc(XL + i, JL + j, 1, 0);\n            }\n            g.arc(YL + i, SNK, 1, 0);\n            for (int j = 0; j < N; j++) {\n                if (ylo[i] <= y[j] && y[j] <= yhi[i])\n                    g.arc(JL + N + j, YL + i, 1, 0);\n            }\n        }\n        const ll MAXV = 1e15;\n        for (int j = 0; j < N; j++) {\n            g.arc(JL + j, JL + N + j, 1, MAXV - val[j]);\n        }\n\n        vi imb(V);\n        imb[SRC] = K;\n        imb[SNK] = -K;\n        auto res = g.solve(imb);\n        return res.first ? MAXV * K - res.second : 0ll;\n    };\n\n    ll ans = 0;\n    for (int k = 1; k <= N; k++)\n        ans = max(ans, best(k));\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#define lop(c,l) for(int c=1;c<=(l);++c)\n#define loop(c,l) for(int c=0;c<(l);++c)\nusing namespace std;\n\n#define int long long\n#define double long double\n#define inf 1e14\n#define eps 1e-14\ntemplate<int Vari,int Crat>\nstruct algo_simplex{\n\tdouble matrix[Crat+1][Vari+1],ans[Vari+1];\n\tint id[Crat<<1|1];\n\tint vari,crat,target;\n\tvoid pivot(const int& l,const int& e){\n\t\tswap(id[vari+l],id[e]);\n\t\tdouble t=matrix[l][e];\n\t\tmatrix[l][e]=1;\n\t\tfor(int j=0;j<=vari;j++) matrix[l][j]/=t;\n\t\tfor(int i=0;i<=crat;i++) if(i!=l&&abs(matrix[i][e])>eps){\n\t\t\tt=matrix[i][e];\n\t\t\tmatrix[i][e]=0;\n\t\t\tfor(int j=0;j<=vari;j++) matrix[i][j]-=matrix[l][j]*t;\n\t\t}\n\t}\n\tbool init(){\n\t\twhile(1){\n\t\t\tint l=0,e=0;\n\t\t\tfor(int i=1;i<=crat;i++) if(matrix[i][0]<-eps&&(!l||(rand()&1))) l=i;\n\t\t\tif(!l) return 1;\n\t\t\tfor(int j=1;j<=vari;j++) if(matrix[l][j]<-eps&&(!e||(rand()&1))) e=j;\n\t\t\tif(!e) return 0;\n\t\t\tpivot(l,e);\n\t\t}\n\t}\n\tbool funct(const int& v,const int& c){\n\t\tsrand(new int()-(int*)NULL);\n\t\tvari=v,crat=c;\n\t\tfor(int i=1;i<=vari;i++) id[i]=i;\n\t\tif(!init())\treturn 0;\n\t\twhile(1){\n\t\t\tint l=0,e=0,minn=inf;\n\t\t\tfor(int j=1;j<=vari&&!e;j++) if(matrix[0][j]>eps) e=j;\n\t\t\tif(!e) break;\n\t\t\tfor(int i=1;i<=crat;i++) if(matrix[i][e]>eps&&matrix[i][0]/matrix[i][e]<minn) minn=matrix[i][0]/matrix[i][e],l=i;\n\t\t\tif(!l) return 0;\n\t\t\tpivot(l,e);\n\t\t}\n\t\ttarget=-matrix[0][0];\n\t\tfor(int i=1;i<=crat;i++) ans[id[vari+i]]=matrix[i][0];\n\t\treturn 1;\n\t}\n};\nalgo_simplex<80,400> spl;\nstruct loc{\n\tint x,y,v;\n}p[81];\nint n,m,ll,lim;\nchar ch;\nsigned main(signed,char**,char**){\n\tscanf(\"%lld\",&n);\n\tlop(i,n){\n\t\tscanf(\"%lld%lld%lld\",&p[i].x,&p[i].y,&p[i].v);\n\t\tspl.matrix[0][i]=p[i].v;\n\t}\n\tscanf(\"%lld\",&m);\n\tlop(i,m){\n\t\tscanf(\" %c%lld%lld\",&ch,&ll,&lim);\n\t\tswitch(ch){\n\t\t\tcase 'L':{\n\t\t\t\tlop(j,n) if(p[j].x<=ll) spl.matrix[i][j]=1;\n\t\t\t\tspl.matrix[i][0]=lim;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'R':{\n\t\t\t\tlop(j,n) if(p[j].x>=ll) spl.matrix[i][j]=1;\n\t\t\t\tspl.matrix[i][0]=lim;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'D':{\n\t\t\t\tlop(j,n) if(p[j].y<=ll) spl.matrix[i][j]=1;\n\t\t\t\tspl.matrix[i][0]=lim;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'U':{\n\t\t\t\tlop(j,n) if(p[j].y>=ll) spl.matrix[i][j]=1;\n\t\t\t\tspl.matrix[i][0]=lim;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tlop(i,n) spl.matrix[m+i][i]=1,spl.matrix[m+i][0]=1;\n\tspl.funct(n,m+n);\n\tprintf(\"%lld\",spl.target);\n\texit(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define pb push_back\n#define mk make_pair\n#define rint register int\nusing namespace std;\ninline int read(){int w=1,s=0;char ch=getchar();while(!isdigit(ch)){if(ch=='-')w=-1;ch=getchar();}while(isdigit(ch)){s=s*10+ch-'0';ch=getchar();}return w*s;}\nstruct node{int to,next,flow;ll w;} e[1000010];\nint h[2100],tot=1,n,X[1000100],Y[1000100],m;\nll Ans=0,V[1000010];int opt[100001],A[10010],B[10010],S,T,L[2010],R[2001];\nint inq[2019],flow[2019],Pre[2019],edg[2019];ll dis[2019];\ninline void add(int from,int to,int flow,ll w)\n{\n\te[++tot].next=h[from];h[from]=tot;e[tot].to=to;e[tot].flow=flow;e[tot].w=w;\n\te[++tot].next=h[to]  ;h[to]=tot;  e[tot].to=from;e[tot].flow=0;e[tot].w=-w;\n}\nqueue<int> q;\ninline bool Spfa()\n{\n\tq.push(S);\n\tmemset(dis,-0x3f,sizeof(dis));inq[S]=0;\n\tflow[S]=1e9;\n\tdis[S]=0;\n\twhile(!q.empty())\n\t{\n\t\tint u=q.front();q.pop();\n\t\tinq[u]=0;\n\t\tfor(rint i=h[u];i;i=e[i].next)\n\t\t{\tint to=e[i].to;if(!e[i].flow) continue;\n\t\t\tif(dis[to]<dis[u]+e[i].w)\n\t\t\t{\tdis[to]=dis[u]+e[i].w;\n\t\t\t\tflow[to]=min(flow[u],e[i].flow);\n\t\t\t\tPre[to]=u;edg[to]=i;\n\t\t\t\tif(!inq[to]) q.push(to),inq[to]=1;\n\t\t\t}\n\t\t}\n\t}return dis[T]>=0;\n}\ninline void MCMF(int mid)\n{\n\tint fw=0;ll C=0;\n\twhile(Spfa())\n\t{\n\t\tint k=T;\n\t\twhile(k!=S)\n\t\t{\n\t\t\te[edg[k]].flow-=flow[T];\n\t\t\te[edg[k]^1].flow+=flow[T];\n\t\t\tk=Pre[k];\n\t\t}\n\t\tfw+=flow[T];\n\t\tC+=dis[T];\n\t}\n\tif(fw==mid) Ans=max(Ans,C);\n}\ninline void Solve()\n{\n\tS=4*n+1,T=S+1;\n\tfor(rint i=1;i<=n;++i)\n\t{\n\t\ttot=1;\n\t\tmemset(h,0,sizeof(h));\n\t\tmemset(L,0,sizeof(L));\n\t\tmemset(R,0x3f,sizeof(R));\n\t\tfor(rint j=1;j<=i;++j) add(S,n+n+j,1,0),add(n+n+j+i,T,1,0);\n\t\tfor(rint j=1;j<=n;++j) add(j,n+j,1,V[j]);\n\t\tfor(rint j=1;j<=m;++j)\n\t\t{\n\t\t\tif(B[j]>=i) continue; \n\t\t\tif(opt[j]==0)\n\t\t\t\tR[i-B[j]]=min(A[j]-1,R[i-B[j]]);\n\t\t\telse if(opt[j]==1)\n\t\t\t\tL[B[j]+1]=max(A[j]+1,L[B[j]+1]);\n\t\t}\n\t\tfor(rint j=2;j<=i;++j) L[j]=max(L[j-1],L[j]);\n\t\tfor(rint j=i-1;j>=1;--j) R[j]=min(R[j+1],R[j]);\n\t\tfor(rint j=1;j<=i;++j)\n\t\t\tfor(rint k=1;k<=n;++k)\n\t\t\t\tif(X[k]>=L[j]&&X[k]<=R[j]) add(n+n+j,k,1,0);\n\t\tmemset(L,0,sizeof(L));\n\t\tmemset(R,0x3f,sizeof(R));\n\t\tfor(rint j=1;j<=m;++j)\n\t\t{\n\t\t\tif(B[j]>=i) continue; \n\t\t\tif(opt[j]==2)\n\t\t\t\tR[i-B[j]]=min(A[j]-1,R[i-B[j]]);\n\t\t\telse if(opt[j]==3)\n\t\t\t\tL[B[j]+1]=max(A[j]+1,L[B[j]+1]);\n\t\t}\n\t\tfor(rint j=2;j<=i;++j) L[j]=max(L[j-1],L[j]);\n\t\tfor(rint j=i-1;j>=1;--j) R[j]=min(R[j+1],R[j]);\n\t\tfor(rint j=1;j<=i;++j)\n\t\t\tfor(rint k=1;k<=n;++k)\n\t\t\t\tif(Y[k]>=L[j]&&Y[k]<=R[j]) add(n+k,n+n+i+j,1,0);\n\t\tMCMF(i);\n\t}\n}\nint main()\n{\t\n\tn=read();\n\tfor(rint i=1;i<=n;++i) X[i]=read(),Y[i]=read(),cin>>V[i];\n\tm=read();\n\tfor(rint i=1;i<=m;++i)\n\t{\n\t\tchar s[10];scanf(\"%s\",s+1);\n\t\tif(s[1]=='L') opt[i]=1;\n\t\tif(s[1]=='R') opt[i]=0;\n\t\tif(s[1]=='D') opt[i]=3;\n\t\tif(s[1]=='U') opt[i]=2;\n\t\tA[i]=read(),B[i]=read();\n\t}\n\tSolve();\n\tcout<<Ans;\n\treturn 0;\n}\t"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<queue>\nusing namespace std;\n#define ll long long\nll gi(){\n\tll x=0,w=1;char ch=getchar();\n\twhile((ch<'0'||ch>'9')&&ch!='-')ch=getchar();\n\tif(ch=='-')w=0,ch=getchar();\n\twhile(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();\n\treturn w?x:-x;\n}\nint gc(){\n\tchar ch=getchar();\n\twhile(ch<'A'||ch>'Z')ch=getchar();\n\treturn ch;\n}\nconst int N=405;\nstruct edge{int to,nxt,w;ll cost;}E[N*N];\nint n,m,x[N],y[N],t[N],a[N],b[N],L[N],R[N],D[N],U[N],head[N],cnt,S,T,vis[N],pe[N];\nll v[N],dis[N],ans;queue<int>Q;\nvoid link(int u,int v,ll w){\n\tE[++cnt]=(edge){v,head[u],1,w};head[u]=cnt;\n\tE[++cnt]=(edge){u,head[v],0,-w};head[v]=cnt;\n}\nbool spfa(ll &res){\n\tmemset(dis,63,sizeof(dis));\n\tdis[S]=0;Q.push(S);\n\twhile(!Q.empty()){\n\t\tint u=Q.front();Q.pop();vis[u]=0;\n\t\tfor(int i=head[u],v;i;i=E[i].nxt)\n\t\t\tif(E[i].w&&dis[v=E[i].to]>dis[u]+E[i].cost){\n\t\t\t\tdis[v]=dis[u]+E[i].cost;pe[v]=i;\n\t\t\t\tif(!vis[v])vis[v]=1,Q.push(v);\n\t\t\t}\n\t}\n\tif(dis[T]==dis[0])return false;res+=dis[T];\n\tfor(int i=T;i!=S;i=E[pe[i]^1].to)--E[pe[i]].w,++E[pe[i]^1].w;\n\treturn true;\n}\nll cal(int k){\n\tfor(int i=1;i<=k;++i)L[i]=D[i]=0,R[i]=U[i]=233;\n\tfor(int i=1;i<=m;++i)\n\t\tif(b[i]<k){\n\t\t\tif(t[i]=='L')L[b[i]+1]=a[i]+1;\n\t\t\tif(t[i]=='R')R[k-b[i]]=a[i]-1;\n\t\t\tif(t[i]=='D')D[b[i]+1]=a[i]+1;\n\t\t\tif(t[i]=='U')U[k-b[i]]=a[i]-1;\n\t\t}\n\tfor(int i=2;i<=k;++i)L[i]=max(L[i],L[i-1]),D[i]=max(D[i],D[i-1]);\n\tfor(int i=k-1;i;--i)R[i]=min(R[i],R[i+1]),U[i]=min(U[i],U[i+1]);\n\tmemset(head,0,sizeof(head));cnt=1;S=n+k<<1|1;T=n+k+1<<1;\n\tfor(int i=1;i<=n;++i)link(i,n+i,-v[i]-1000000000000000ll);\n\tfor(int i=1;i<=k;++i){\n\t\tlink(S,n+n+i,0);link(n+n+k+i,T,0);\n\t\tfor(int j=1;j<=n;++j){\n\t\t\tif(L[i]<=x[j]&&x[j]<=R[i])link(n+n+i,j,0);\n\t\t\tif(D[i]<=y[j]&&y[j]<=U[i])link(n+j,n+n+k+i,0);\n\t\t}\n\t}\n\tll res=0;while(spfa(res));return -res-1000000000000000ll*k;\n}\nint main(){\n\tn=gi();\n\tfor(int i=1;i<=n;++i)x[i]=gi(),y[i]=gi(),v[i]=gi();\n\tm=gi();\n\tfor(int i=1;i<=m;++i)t[i]=gc(),a[i]=gi(),b[i]=gi();\n\tfor(int i=1;i<=n;++i)ans=max(ans,cal(i));\n\tprintf(\"%lld\\n\",ans);return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for((i)=1;(i)<=(n);(i)++) \nusing namespace std;\nint n,m,i,j,px[405],py[405],qa[405],qb[405],s,t,tot;\nchar qt[405];\nint mix[405],miy[405],mxx[405],mxy[405];\nstruct edge{\n\tint y,z;long long d;\n}e[2000005];\nint vis[405],iq[405];\nlong long ans,cst,dis[405],pv[405];\nvector<int> adj[405];\nvoid add(int x,int y,int z,long long d){\n\t++tot;\n\tadj[x].push_back(tot*2-2);\n\tadj[y].push_back(tot*2-1);\n\te[tot*2-2]=(edge){y,z,d};\n\te[tot*2-1]=(edge){x,0,-d}; \n}\nbool bfs(int s,int t){\n\tmemset(dis,-0x3f,sizeof(dis));\n\tdis[s]=0;queue<int> q;q.push(s);\n\twhile(!q.empty()){\n\t\tint x=q.front();q.pop();iq[x]=0;\n\t\tfor(int i=0;i<adj[x].size();i++){\n\t\t\tint t=adj[x][i];\n\t\t\tif(e[t].z&&dis[e[t].y]<dis[x]+e[t].d){\n\t\t\t\tdis[e[t].y]=dis[x]+e[t].d;\n\t\t\t\tif(!iq[e[t].y]){q.push(e[t].y);iq[e[t].y]=1;}\n\t\t\t}\n\t\t}\n\t}\n\treturn dis[t]>dis[0];\n}\nint dfs(int x,int tt,int fw){\n\tif(!fw) return 0; \n\tif(x==tt) return vis[x]=1,fw;\n\tif(vis[x]) return 0;vis[x]=1;\n\tint res=0;\n\tfor(int i=0;i<adj[x].size();i++){\n\t\tint y=adj[x][i];\n\t\tif(e[y].z&&dis[e[y].y]==dis[x]+e[y].d){\n\t\t\tint t=dfs(e[y].y,tt,min(fw,e[y].z));\n\t\t\tfw-=t;res+=t;e[y].z-=t;e[y^1].z+=t;\n\t\t\tcst+=e[y].d*t;\n\t\t}\n\t}\n\treturn res;\n}\nint dinic(int s,int t){\n\tint ans=0;\n\twhile(bfs(s,t)){\n\t\tdo{\n\t\t\tmemset(vis,0,sizeof(vis));\n\t\t\tans+=dfs(s,t,0x3f3f3f3f);\n\t\t}while(vis[t]);\n\t}\n\treturn ans;\n}\nlong long calc(int k){\n\tint i,j;\n\trep(i,k){\n\t\tmix[i]=miy[i]=0;\n\t\tmxx[i]=mxy[i]=101;\n\t}\n\trep(i,m){\n\t\tif(qb[i]<k){\n\t\t\tif(qt[i]=='L') mix[qb[i]+1]=qa[i]+1;\n\t\t\tif(qt[i]=='R') mxx[k-qb[i]]=qa[i]-1; \n\t\t\tif(qt[i]=='D') miy[qb[i]+1]=qa[i]+1;\n\t\t\tif(qt[i]=='U') mxy[k-qb[i]]=qa[i]-1; \n\t\t}\n\t}\n\tfor(i=2;i<=k;i++){\n\t\tmix[i]=max(mix[i],mix[i-1]);\n\t\tmiy[i]=max(miy[i],miy[i-1]);\n\t}\n\tfor(i=k-1;i;i--){\n\t\tmxx[i]=min(mxx[i],mxx[i+1]);\n\t\tmxy[i]=min(mxy[i],mxy[i+1]);\n\t}\n\trep(i,4*n+2){\n\t\tadj[i].clear();\n\t}\n\ttot=0;\n\trep(i,k){\n\t\tadd(s,n+i,1,0);\n\t\tadd(n+n+i,t,1,0);\n\t}\n\trep(i,n){\n\t\tadd(i,n+n+n+i,1,pv[i]);\n\t\trep(j,k){\n\t\t\tif(mix[j]<=px[i]&&px[i]<=mxx[j]){\n\t\t\t\tadd(n+j,i,1,0);\n\t\t\t}\n\t\t\tif(miy[j]<=py[i]&&py[i]<=mxy[j]){\n\t\t\t\tadd(n+n+n+i,n+n+j,1,0);\n\t\t\t}\n\t\t}\n\t}\n\tcst=0;\n\tif(dinic(s,t)!=k) return 0;\n/*\tif(k==4){\n\t\tfor(i=0;i<tot*2;i+=2){\n\t\t\tif(1<=e[i].y&&e[i].y<=n&&n+1<=e[i^1].y&&e[i^1].y<=n+n&&!e[i].z){\n\t\t\t\tcerr<<e[i].y<<endl;\n\t\t\t}\n\t\t}\n\t}*/\n\treturn cst;\n}\nint main(){\n\tcin>>n;s=4*n+1;t=4*n+2;\n\trep(i,n){\n\t\tcin>>px[i]>>py[i]>>pv[i];\n\t}\n\tcin>>m;\n\trep(i,m){\n\t\tcin>>qt[i]>>qa[i]>>qb[i];\n\t}\n\trep(i,n){\n\t\tans=max(ans,calc(i));\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define INF 1e15\nusing namespace std;\nstruct Po{int x,y;ll z;}v[85];\nstruct Qu{char ch;int x,y;}c[410];\nstruct Info{int nu,ne,qu;ll co;}a[500010];\nint m,n,s,t,l[85],r[85],b[1010],num,li[500010],la[5010],zh[5010];\nbool vi[5010];\nll nu,ansn,di[5010];\nvoid jb(int x,int y,ll z){\n\ta[++num].nu=y;a[num].ne=b[x];b[x]=num;a[num].co=z;a[num].qu=1;\n\ta[++num].nu=x;a[num].ne=b[y];b[y]=num;a[num].co=-z;a[num].qu=0;\n}\nll que(){\n\tfor (int i=1;i<=t;i++) vi[i]=1,di[i]=INF,la[i]=0,zh[i]=0;\n\tdi[s]=0;vi[s]=0;\n\tint l=1,r=1;li[l]=s;\n\twhile (l<=r){\n\t\tfor (int y=b[li[l]];y;y=a[y].ne){\n\t\t\tif (a[y].qu!=0&&di[a[y].nu]>di[li[l]]+a[y].co){\n\t\t\t\tdi[a[y].nu]=di[li[l]]+a[y].co;\n\t\t\t\tla[a[y].nu]=li[l];zh[a[y].nu]=y;\n\t\t\t\tif (vi[a[y].nu]){li[++r]=a[y].nu;vi[a[y].nu]=0;}\n\t\t\t}\n\t\t}\n\t\tvi[li[l]]=0;\n\t\tl++;\n\t}\n//\tfor (int i=1;i<=t;i++) cout<<i<<' '<<di[i]<<' '<<vi[i]<<' '<<la[i]<<' '<<zh[i]<<endl;\n\tif (di[t]==INF)return -INF;\n\tfor (int i=t;i!=s;i=la[i]){a[zh[i]].qu=0;a[zh[i]^1].qu=1;}\n\treturn INF-di[t];\n}\nint main(){\n\tcin>>n;\n\tfor (int i=1;i<=n;i++)cin>>v[i].x>>v[i].y>>v[i].z;\n\tcin>>m;\n\tfor (int i=1;i<=m;i++) cin>>c[i].ch>>c[i].x>>c[i].y;\n\tfor (int k=1;k<=n;k++){\n\t\tmemset(b,0,sizeof(b));num=1;nu=0;\n\t\ts=n+n+k+k+1;t=n+n+k+k+2;\n\t\tfor (int i=1;i<=k;i++) jb(s,i,0),jb(i+k,t,0);\n\t\tfor (int i=1;i<=k;i++) l[i]=1,r[i]=100;\n\t\tfor (int i=1;i<=m;i++){\n\t\t\tif (c[i].ch=='L'&&c[i].y<k)l[c[i].y+1]=max(l[c[i].y+1],c[i].x+1);\n\t\t\tif (c[i].ch=='R'&&c[i].y<k)r[k-c[i].y]=min(r[k-c[i].y],c[i].x-1);\n\t\t}\n\t\tfor (int i=2;i<=k;i++)l[i]=max(l[i],l[i-1]);\n\t\tfor (int i=k-1;i>=1;i--)r[i]=min(r[i],r[i+1]);\n\t\tfor (int i=1;i<=k;i++)\n\t\t\tfor (int j=1;j<=n;j++)\n\t\t\t\tif (v[j].x>=l[i]&&v[j].x<=r[i])jb(i,j+k+k,0);\n\t\tfor (int i=1;i<=k;i++) l[i]=1,r[i]=100;\n\t\tfor (int i=1;i<=m;i++){\n\t\t\tif (c[i].ch=='D'&&c[i].y<k)l[c[i].y+1]=max(l[c[i].y+1],c[i].x+1);\n\t\t\tif (c[i].ch=='U'&&c[i].y<k)r[k-c[i].y]=min(r[k-c[i].y],c[i].x-1);\n\t\t}\n\t\tfor (int i=2;i<=k;i++)l[i]=max(l[i],l[i-1]);\n\t\tfor (int i=k-1;i>=1;i--)r[i]=min(r[i],r[i+1]);\n\t\tfor (int i=1;i<=k;i++)\n\t\t\tfor (int j=1;j<=n;j++)\n\t\t\t\tif (v[j].y>=l[i]&&v[j].y<=r[i])jb(j+k+k+n,i+k,0);\n\t\tfor (int i=1;i<=n;i++)jb(i+k+k,i+k+k+n,INF-v[i].z);\n\t\tfor (int i=1;i<=k;i++)nu+=que();\n\t\tansn=max(ansn,nu);\n\t}\n\tcout<<ansn<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <ctime>\n#include <cassert>\n#include <unordered_map>\n#include <fstream>\n#include <random>\n#include <cstring>\n#include <bitset>\n#include <functional>\n#include <tuple>\n#include <complex>\n#include <chrono>\n#include <climits>\n\n#define all(a) (a).begin(), (a).end()\n#define sz(a) (int)(a).size()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef unsigned int uint;\n\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\n// default_random_engine generator;\n// mt19937 rnd(1);\n\nvector<int> operator*(const vector<int> &a, const vector<int> &b) {\n    int n = sz(a);\n    vector<int> res(n);\n    for (int i = 0; i < n; ++i) {\n        res[i] = a[b[i]];\n    }\n    return res;\n}\n\nvector<int> id(int n) {\n    vector<int> res(n);\n    for (int i = 0; i < n; ++i) {\n        res[i] = i;\n    }\n    return res;\n}\n\nvector<int> binPow(vector<int> a, int m) {\n    int n = sz(a);\n    vector<int> res = id(n);\n    for (; m > 0; m >>= 1) {\n        if (m & 1) {\n            res = res * a;\n        }\n        a = a * a;\n    }\n    return res;\n}\n\nvector<int> rev(const vector<int> &a) {\n    int n = sz(a);\n    vector<int> res(n);\n    for (int i = 0; i < n; ++i) {\n        res[a[i]] = i;\n    }\n    return res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    // freopen(\"input.txt\", \"r\", stdin);\n    // freopen(\"output.txt\", \"w\", stdout);\n\n    vector<int> u = {2, 1, 3, 0};\n    // vector<int> v = {3, 0, 2, 1};\n    vector<int> v = {2, 1, 3, 0};\n\n    int n, k;\n    cin >> n >> k;\n\n    vector<int> p(n), q(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> p[i];\n        --p[i];\n    }\n    for (int j = 0; j < n; ++j) {\n        cin >> q[j];\n        --q[j];\n    }\n\n    --k;\n    if (k == 0) {\n        for (int el : p) {\n            cout << el + 1 << \" \";\n        }\n        cout << endl;\n        return 0;\n    } \n    if (k == 1) {\n        for (int el : q) {\n            cout << el + 1 << \" \";\n        }\n        cout << endl;\n        return 0;\n    }\n\n    int s = k + (k - 1) / 3;\n    int a = (s + 1) / 2 + 1;\n    int b = (s + 1) / 2 - 1;\n    if (a + b > s) {\n        --a;\n    }\n\n    vector<vector<int>> perm(4);\n    perm[0] = p;\n    perm[1] = rev(p);\n    perm[2] = q;\n    perm[3] = rev(q);\n\n    vector<int> f = id(n); \n    vector<int> g = id(n);\n    for (int i = 0; i < 4; ++i) {\n        f = f * perm[u[i]];\n        g = g * perm[v[i]];\n    }\n\n    f = binPow(f, a / 4);\n    g = binPow(g, b / 4);\n\n    for (int i = 0; i < a % 4; ++i) {\n        f = f * perm[u[i]];\n    }\n    for (int i = 0; i < b % 4; ++i) {\n        g = g * perm[v[i]];\n    }\n\n    vector<int> res = f * rev(g);\n\n    for (int i = 0; i < n; ++i) {\n        cout << res[i] + 1 << \" \";\n    }\n    cout << endl;\n\n    // int k;\n    // cin >> k;\n\n    // vector<vector<int>> w;\n    // w.push_back({0});\n    // w.push_back({2});\n\n    // for (int i = 2; i < k; ++i) {\n    //     vector<int> nxt = w.back();\n    //     vector<int> arr = w[sz(w) - 2];\n    //     for (int i = 0; i < sz(arr); ++i) {\n    //         arr[i] ^= 1;\n    //     }\n    //     reverse(all(arr));\n\n    //     for (int i = 0; i < sz(arr); ++i) {\n    //         if ((arr[i] ^ nxt.back()) == 1) {\n    //             nxt.pop_back();\n    //         } else {\n    //             nxt.push_back(arr[i]);\n    //         }\n    //     }\n\n    //     w.push_back(nxt);\n    // }\n\n\n    // vector<int> u = {2, 1, 3, 0};\n    // vector<int> v = {3, 0, 2, 1};\n\n    // for (int i = 0; i < k; ++i) {\n    //     int a = 0, b = 0;\n    //     for (int j = 0; j < sz(w[i]); ++j) {\n    //         if (w[i][j] != u[j % 4]) {\n    //             break;\n    //         }\n    //         ++a;\n    //     }\n    //     reverse(all(w[i]));\n    //     for (int j = 0; j < sz(w[i]); ++j) {\n    //         if (w[i][j] != v[j % 4]) {\n    //             break;\n    //         }\n    //         ++b;\n    //     }\n    //     reverse(all(w[i]));\n\n    //     // cout << i << \" \" << sz(w[i]) << \" \" << a << \" \" << b << endl;\n\n    //     int s = i + (i - 1) / 3;\n    //     int aa = (s + 1) / 2 + 1;\n    //     int bb = (s + 1) / 2 - 1;\n\n    //     if (i >= 2) {\n    //         assert(s == sz(w[i]));\n    //         assert(a == aa);\n    //         assert(b == bb);\n\n    //     }\n        \n\n    //     // cout << i << \" \" << s << \" \" << aa << \" \" << bb << endl;\n    // } \n\n    // for (int i = 0; i < k; ++i) {\n    //     // if (i % 3 != 1) {\n    //     //     continue;\n    //     // }\n    //     for (int el : w[i]) {\n    //         cout << el << \" \";\n    //     }\n    //     cout << endl;\n    // }\n\n    // int n, k;\n    // cin >> n >> k;\n\n    // vector<vector<int>> a(2, vector<int>(n));\n\n    // for (int i = 0; i < 2; ++i) {\n    //     for (int j = 0; j < n; ++j) {\n    //         cin >> a[i][j];\n    //         --a[i][j];\n    //     }\n    // } \n\n    // while (sz(a) < k) {\n    //     int m = sz(a);\n    //     a.push_back(vector<int>(n));\n\n    //     vector<int> r(n);\n    //     for (int i = 0; i < n; ++i) {\n    //         r[a[m - 2][i]] = i;\n    //     }\n\n    //     for (int i = 0; i < n; ++i) {\n    //         a[m][i] = a[m - 1][r[i]];\n    //     }\n    // }\n\n    // for (int i = 0; i < n; ++i) {\n    //     cout << a[k - 1][i] + 1 << \" \";\n    // }\n    // cout << endl;\n\n\n        \n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nconst int S=0,T=1,SS=2,TT=3,siz=100;\nconst long long inf=1000000000000000ll;\nint n,m,x[110],y[110],r[400][3],d[400];\nlong long v[110],ans;\nstruct bian\n{\n\tint nxt,to,f;\n\tlong long w;\n}bi[10010];\nint head[220],num;\nvoid add(int from,int to,int f,long long w)\n{\n\tbi[++num].nxt=head[from];\n\thead[from]=num;\n\tbi[num].to=to;\n\tbi[num].f=f;\n\tbi[num].w=w;\n}\nvoid ADD(int from,int to,int f,long long w){add(from,to,f,w),add(to,from,0,-w);}\nint lox[110],hix[110],loy[110],hiy[110];\nqueue<int>q;\nlong long dis[220];\nint fb[220];\nbool in[220];\n/*void bfs(int s)\n{\n\tq.push(s);fb[s]=0;\n\tmemset(dis,-1,sizeof(dis));\n\tdis[s]=0;\n\tint x,y;\n\twhile(!q.empty())\n\t{\n\t\tx=q.front();q.pop();\n\t//\tprintf(\"%d %lld\\n\",x,dis[x]);\n\t\tfor(int i=head[x];i;i=bi[i].nxt)\n\t\t\tif(bi[i].f)\n\t\t\t{\n\t\t\t\ty=bi[i].to;\n\t\t\t\tif(dis[y]==-1)dis[y]=dis[x]+bi[i].w,q.push(y),fb[y]=i;\n\t\t\t}\n\t}\n}*/\nbool spfa()\n{\n\tq.push(SS);fb[SS]=0;\n\tmemset(dis,0xc0,sizeof(dis));\n\tdis[SS]=0;\n\tint x,y;\n\twhile(!q.empty())\n\t{\n\t\tx=q.front();q.pop();in[x]=0;\n\t//\tprintf(\"%d %lld\\n\",x,dis[x]);\n\t\tfor(int i=head[x];i;i=bi[i].nxt)\n\t\t\tif(bi[i].f)\n\t\t\t{\n\t\t\t\ty=bi[i].to;\n\t\t\t\tif(dis[x]+bi[i].w>dis[y])\n\t\t\t\t{\n\t\t\t\t//\tprintf(\"u %d %d\\n\",x,y);\n\t\t\t\t\tdis[y]=dis[x]+bi[i].w;\n\t\t\t\t\tfb[y]=i;\n\t\t\t\t\tif(!in[y])in[y]=1,q.push(y);\n\t\t\t\t}\n\t\t\t}\n\t}\n\treturn dis[TT]!=0xc0c0c0c0c0c0c0c0ll;\n}\nvoid solve(int cnt)\n{\n//\tprintf(\"%d:\\n\",cnt);\n\tnum=1;\n\tmemset(head,0,sizeof(head));\n\tmemset(d,0,sizeof(d));\n\tfor(int i=1;i<=siz;++i)lox[i]=loy[i]=0,hix[i]=hiy[i]=cnt;\n\tfor(int i=1;i<=m;++i)\n\t\tif(r[i][0]=='L')hix[r[i][1]]=r[i][2];\n\t\telse if(r[i][0]=='R')lox[r[i][1]-1]=cnt-r[i][2]>0?cnt-r[i][2]:0;\n\t\telse if(r[i][0]=='D')hiy[r[i][1]]=r[i][2];\n\t\telse loy[r[i][1]-1]=cnt-r[i][2]>0?cnt-r[i][2]:0;\n/*\tfor(int i=siz-1;i;--i)\n\t{\n\t\tif(lox[i+1]>lox[i])lox[i]=lox[i+1];\n\t\tif(hix[i+1]<hix[i])hix[i]=hix[i+1];\n\t}\n\tfor(int i=2;i<=siz;++i)\n\t{\n\t\tif(loy[i-1]>loy[i])loy[i]=loy[i-1];\n\t\tif(hiy[i-1]<hiy[i])hiy[i]=hiy[i-1];\n\t}*/\n/*\tfor(int i=1;i<=siz;++i)printf(\"%d \",lox[i]);printf(\"\\n\");\n\tfor(int i=1;i<=siz;++i)printf(\"%d \",hix[i]);printf(\"\\n\");\n\tfor(int i=1;i<=siz;++i)printf(\"%d \",loy[i]);printf(\"\\n\");\n\tfor(int i=1;i<=siz;++i)printf(\"%d \",hiy[i]);printf(\"\\n\");\t*/\n\tfor(int i=1;i<=siz;++i)\n\t{\n\t\tif(lox[i]>hix[i])return;\n\t\td[3+i]+=lox[i];\n\t\tif(i<siz)d[4+i]-=lox[i],ADD(4+i,3+i,hix[i]-lox[i],0);\n\t\telse d[S]-=lox[i],ADD(S,3+i,hix[i]-lox[i],0);\n\t}\n\tfor(int i=1;i<=siz;++i)\n\t{\n\t\tif(loy[i]>hiy[i])return;\n\t\td[3+siz+i]-=loy[i];\n\t\tif(i<siz)d[4+siz+i]+=loy[i],ADD(3+siz+i,4+siz+i,hiy[i]-loy[i],0);\n\t\telse d[T]+=loy[i],ADD(3+siz+i,T,hiy[i]-loy[i],0);\n\t}\n\tfor(int i=1;i<=n;++i)ADD(3+x[i],3+siz+y[i],1,v[i]);\n\td[S]+=cnt,d[T]-=cnt;\n\tint sum=0;\n\tlong long cost=0;\n\tfor(int i=0;i<=2*siz+3;++i)\n\t\tif(d[i]>0)ADD(SS,i,d[i],0),sum+=d[i];\n\t\telse if(d[i]<0)ADD(i,TT,-d[i],0);\n//\tADD(T,S,0x3f3f3f3f,0);\n//\tfor(int i=0;i<=2*siz+3;++i)\n//\t\tfor(int j=head[i];j;j=bi[j].nxt)\n//\t\t\tif(bi[j].f)printf(\"%d %d %d %lld\\n\",i,bi[j].to,bi[j].f,bi[j].w);\n\twhile(spfa())\n\t{\n\t//\tbfs(SS);\n\t//\tif(dis[TT]==-1)break;\n\t\t--sum;cost+=dis[TT];\n\t\tint x=TT;\n\t\twhile(x!=SS)--bi[fb[x]].f,++bi[fb[x]^1].f,x=bi[fb[x]^1].to;\n\t}\n//\tprintf(\"%d\\n\",sum);\n//\tbi[head[S]].f=0,bi[head[T]].f=0;\n\tif(sum)return;\n/*\twhile(1)\n\t{\n\t\tspfa(S);\n\t\tif(dis[T]<=0)break;\n\t//\tprintf(\"%lld\\n\",dis[T]);\n\t\tcost+=dis[T];\n\t\tint x=T;\n\t\twhile(x!=S)--bi[fb[x]].f,++bi[fb[x]^1].f,x=bi[fb[x]^1].to;\n\t}*/\n//\tprintf(\"%lld\\n\",cost);\n//\tprintf(\"%lld\\n\",cost+cnt*inf);\n\tans=max(ans,cost);\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i)scanf(\"%d %d %lld\",&x[i],&y[i],&v[i]);\n\tscanf(\"%d\",&m);\n\tfor(int i=1;i<=m;++i)scanf(\" %c %d %d\",&r[i][0],&r[i][1],&r[i][2]);\n\tfor(int i=1;i<=n;++i)solve(i);\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cassert>\n\n#define pb push_back\n#define fir first\n#define sec second\n#define forto(_) for (int e = last[_], v = E[e].to; e; v = E[e = E[e].next].to)\n#define forback(_) for (int _ = T; _ ^ S; _ = pre[_])\n\ntypedef long long LL;\n\nconst int kMaxn = 85, kMaxe = 2e4;\nconst LL kInf64 = 1e15 + 5;\n\ntypedef std::pair<int, int> Pii;\ntypedef int IArn[kMaxn];\ntypedef int IArv[kMaxn << 2];\n\nstruct Edge {\n\tint to, capt;\n\tLL cost;\n\tint next;\n} E[kMaxe << 1];\n\nint n, m, tote, S, T;\nIArn X, Y, L, R, U, D;\nIArv last, pre, pree;\nLL V[kMaxn], dist[kMaxn << 2];\nstd::vector<Pii> con[4];\nchar IN[5];\n\ninline void AddEdge(int u, int v, int cap, LL cst) {\n\tE[++tote] = (Edge){v, cap, cst, last[u]}, last[u] = tote;\n\tassert(E[tote].cost == cst);\n\tE[++tote] = (Edge){u, 0, -cst, last[v]}, last[v] = tote;\n}\ntemplate <typename T>\nvoid Umin(T & x, T y) {\n\tx > y ? x = y : 0;\n}\ntemplate <typename T>\nvoid Umax(T & x, T y) {\n\tx < y ? x = y : 0;\n}\nLL Mcf(int);\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%d%d%lld\", X + i, Y + i, V + i);\n\t}\n\tscanf(\"%d\", &m);\n\tfor (int i = 0, ai, bi; i < m; i++) {\n\t\tscanf(\"%s%d%d\", IN, &ai, &bi);\n\t\tswitch (IN[0]) {\n\t\t\tcase 'L' :\n\t\t\t\tcon[0].pb(Pii(ai, bi));\n\t\t\t\tbreak;\n\t\t\tcase 'R' :\n\t\t\t\tcon[1].pb(Pii(ai, bi));\n\t\t\t\tbreak;\n\t\t\tcase 'D' :\n\t\t\t\tcon[2].pb(Pii(ai, bi));\n\t\t\t\tbreak;\n\t\t\tcase 'U' :\n\t\t\t\tcon[3].pb(Pii(ai, bi));\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (int i = 0; i <= n; i++) {\n\t\tL[i] = D[i] = 1;\n\t}\n\tfor (auto & p : con[0]) {\n\t\tUmax(L[p.sec + 1], p.fir + 1);\n\t}\n\tfor (auto & p : con[2]) {\n\t\tUmax(D[p.sec + 1], p.fir + 1);\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tUmax(L[i], L[i - 1]);\n\t\tUmax(D[i], D[i - 1]);\n\t}\n\n\tLL ans = 0;\n\tfor (int k = 1; k <= n; k++) {\n\t\tfor (int i = 1; i <= k; i++) {\n\t\t\tR[i] = U[i] = 100;\n\t\t}\n\t\tfor (auto & p : con[1]) {\n\t\t\tif (k <= p.sec) continue;\n\t\t\tUmin(R[k - p.sec], p.fir - 1);\n\t\t}\n\t\tfor (auto & p : con[3]) {\n\t\t\tif (k <= p.sec) continue;\n\t\t\tUmin(U[k - p.sec], p.fir - 1);\n\t\t}\n\t\tfor (int i = k - 1; i > 0; i--) {\n\t\t\tUmin(R[i], R[i + 1]);\n\t\t\tUmin(U[i], U[i + 1]);\n\t\t}\n\n\n\t\ttote = 1;\n\t\tmemset(last, 0, sizeof last);\n\t\tT = (S = k + n + n + k + 1) + 1;\n\t\tfor (int i = 1; i <= k; i++) {\n\t\t\tAddEdge(S, i, 1, 0);\n\t\t\tAddEdge(k + n + n + i, T, 1, 0);\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tif (L[i] <= X[j] && X[j] <= R[i]) {\n\t\t\t\t\tAddEdge(i, k + j, 1, 0);\n\t\t\t\t}\n\t\t\t\tif (D[i] <= Y[j] && Y[j] <= U[i]) {\n\t\t\t\t\tAddEdge(k + n + j, k + n + n + i, 1, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tAddEdge(k + i, k + n + i, 1, kInf64 - V[i]);\n\t\t}\n\n\t\tans = std::max(ans, Mcf(k));\n\t}\n\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n\nbool Spfa() {\n\tstatic std::queue<int> que;\n\tstatic int inque[kMaxn << 2];\n\n\tmemset(pre, 0xff, sizeof pre);\n\tmemset(dist, 0x7f, sizeof dist);\n\n\tfor (dist[S] = 0, que.push(S), inque[S] = 1; !que.empty(); ) {\n\t\tint u = que.front(); que.pop();\n\t\tforto(u) {\n\t\t\tif (E[e].capt > 0 && dist[v] > dist[u] + E[e].cost) {\n\t\t\t\tdist[v] = dist[u] + E[e].cost;\n\t\t\t\tpre[v] = u, pree[v] = e;\n\t\t\t\tif (!inque[v]) {\n\t\t\t\t\tque.push(v), inque[v] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tinque[u] = 0;\n\t}\n\treturn ~pre[T];\n}\n\nLL Mcf(int maxf) {\n\tLL tot = 0, sumf = 0;\n\twhile (Spfa()) {\n\t\tint flow = 100000;\n\t\tforback(u) {\n\t\t\tflow = std::min(flow, E[pree[u]].capt);\n\t\t}\n\t\ttot += 1ll * flow * dist[T], sumf += flow;\n\t\tforback(u) {\n\t\t\tE[pree[u]].capt -= flow;\n\t\t\tE[pree[u] ^ 1].capt += flow;\n\t\t}\n\t}\n\treturn sumf >= maxf ? maxf * kInf64 - tot : 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\ntemplate<typename tn> void read(tn &a){\n\ttn x=0,f=1; char c=' ';\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0';\n\ta=x*f;\n}\nconst int N = 410;\nstruct edge{int v,nxt,f;ll w;}e[N*N*4];\nint head[N],in[N],fr[N],n,x[N],y[N],m,a[N],b[N],tot,t,flow;\nll d[N],val[N],ans;\nchar c[N];\nvoid add(int x,int y,int f,ll w){\n\te[++tot]={y,head[x],f,w};\n\thead[x]=tot;\n\te[++tot]={x,head[y],0,-w};\n\thead[y]=tot;\n}\nbool spfa(){\n\tmemset(d,192,sizeof(d));d[0]=0;\n\tqueue<int> q;q.push(0);\n\twhile(!q.empty()){\n\t\tint u=q.front();q.pop();in[u]=0;\n\t\tfor(int i=head[u];i;i=e[i].nxt)\n\t\t\tif(e[i].f&&d[e[i].v]<d[u]+e[i].w){\n\t\t\t\td[e[i].v]=d[u]+e[i].w;\n\t\t\t\tfr[e[i].v]=i;\n\t\t\t\tif(!in[e[i].v]) q.push(e[i].v),in[e[i].v]=1;\n\t\t\t}\n\t}\n\treturn d[t]>-1e18;\n}\nvoid update(){\n\tans+=d[t];flow++;\n\tfor(int x=t;x;x=e[fr[x]^1].v)\n\t\te[fr[x]].f--,e[fr[x]^1].f++;\n}\nll EK(){\n\tflow=ans=0;\n\twhile(spfa()) update();\n\treturn ans;\n}\nint main(){\n\tread(n);\n\tfor(int i=1;i<=n;i++)\n\t\tread(x[i]),read(y[i]),read(val[i]);\n\tread(m);\n\tfor(int i=1;i<=m;i++)\n\t\tcin>>c[i],read(a[i]),read(b[i]);\n\tll mx=0;\n\tfor(int k=1;k<=n;k++){\n\t\ttot=1;t=2*k+2*n+1;\n\t\tmemset(head,0,sizeof(head));\n\t\tfor(int j=1;j<=k;j++){\n\t\t\tint xl=0,xr=110,yl=0,yr=110;\n\t\t\tfor(int i=1;i<=m;i++){\n\t\t\t\tif(c[i]=='L'&&b[i]<j) xl=max(xl,a[i]+1);\n\t\t\t\tif(c[i]=='R'&&b[i]<k-j+1) xr=min(xr,a[i]-1);\n\t\t\t\tif(c[i]=='D'&&b[i]<j) yl=max(yl,a[i]+1);\n\t\t\t\tif(c[i]=='U'&&b[i]<k-j+1) yr=min(yr,a[i]-1);\n\t\t\t}\n\t\t\tadd(0,j,1,0);\n\t\t\tfor(int i=1;i<=n;i++)\n\t\t\t\tif(x[i]>=xl&&x[i]<=xr) add(j,i+k,1,0);\n\t\t\tadd(j+k+n+n,t,1,0);\n\t\t\tfor(int i=1;i<=n;i++)\n\t\t\t\tif(y[i]>=yl&&y[i]<=yr) add(i+k+n,j+k+n+n,1,0);\n\t\t}\n\t\tfor(int i=1;i<=n;i++) add(i+k,i+k+n,1,val[i]);\n\t\tmx=max(mx,EK());\n\t}\n\tcout<<mx<<'\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Fail puts(\"NO\"),exit(0);\n#define eps 1e-10\n#define maxn 505\n#define maxm 100010\n#define inf 1000000007\n#define mod 1000000007\n#define pi acos(-1)\n#define mp(x,y) make_pair(x,y)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int>pii;\ntypedef bitset<maxn> bit;\nll read()\n{\n    ll x=0,f=1;\n    char ch=getchar();\n    while(ch-'0'<0||ch-'0'>9){if(ch=='-') f=-1;ch=getchar();}\n    while(ch-'0'>=0&&ch-'0'<=9){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nint n,m,s,t;\nstruct P{\n    int x,y;\n    ll v;\n}p[85];\nstruct X{\n    char d;\n    int a,b;\n}co[325];\nint Lx[85],Rx[85],Ly[85],Ry[85];\nint head[325],nxt[140010],to[140010],c[140010],tot;\nll v[140010];\nvoid add(int x,int y,int z,ll u)\n{\n    tot++;\n    nxt[tot]=head[x];\n    head[x]=tot;\n    to[tot]=y;\n    c[tot]=z;\n    v[tot]=u;\n}\nvoid addx(int x,int y,int z,ll u)\n{\n    add(x,y,z,u);\n    add(y,x,0,-u);\n}\nll ans,res,dis[325];\nint vis[325],pre[325],pre_num[325];\nqueue<int>q;\nint spfa()\n{\n    for(int i=1;i<=t;i++)  dis[i]=-1e18;\n    dis[s]=0;q.push(s);vis[s]=1;\n    while(q.size())\n    {\n        int now=q.front();q.pop();vis[now]=0;\n        for(int i=head[now];i;i=nxt[i])\n        {\n            if(dis[to[i]]<dis[now]+v[i]&&c[i])\n            {\n                dis[to[i]]=dis[now]+v[i];\n                pre[to[i]]=now;\n                pre_num[to[i]]=i;\n                if(!vis[to[i]])  q.push(to[i]),vis[to[i]]=1;\n            }\n        }\n    }\n    if(dis[t]==-1e18)  return 0;\n    int di=inf;\n    for(int i=t;i!=s;i=pre[i])  di=min(di,c[pre_num[i]]);\n    for(int i=t;i!=s;i=pre[i])  c[pre_num[i]]-=di,c[pre_num[i]^1]+=di;\n    ans+=dis[t]*di;\n    return di;\n}\nint main()\n{\n    n=read();\n    for(int i=1;i<=n;i++)  p[i].x=read(),p[i].y=read(),p[i].v=read();\n    m=read();\n    for(int i=1;i<=m;i++)  co[i].d=getchar(),co[i].a=read(),co[i].b=read();\n    for(int k=1;k<=n;k++)\n    {\n        tot=1;memset(head,0,sizeof(head));\n        s=2*k+2*n+1;t=s+1;\n        for(int i=1;i<=k;i++)  addx(s,i,1,0);\n        for(int i=k+2*n+1;i<=2*n+2*k;i++)  addx(i,t,1,0);\n        for(int i=k+1;i<=k+n;i++)  addx(i,i+n,1,p[i-k].v);\n        for(int i=1;i<=k;i++)  Lx[i]=Ly[i]=0,Rx[i]=Ry[i]=inf;\n        for(int i=1;i<=m;i++)\n        {\n            if(co[i].d=='U')\n            {\n                for(int j=1;j<=k-co[i].b;j++)  Ry[j]=min(Ry[j],co[i].a-1);\n            }\n            if(co[i].d=='D')\n            {\n                for(int j=co[i].b+1;j<=k;j++)  Ly[j]=max(Ly[j],co[i].a+1);\n            }\n            if(co[i].d=='L')\n            {\n                for(int j=co[i].b+1;j<=k;j++)  Lx[j]=max(Lx[j],co[i].a+1);\n            }\n            if(co[i].d=='R')\n            {\n                for(int j=1;j<=k-co[i].b;j++)  Rx[j]=min(Rx[j],co[i].a-1);\n            }\n        }\n        for(int i=1;i<=k;i++)\n          for(int j=1;j<=n;j++)\n            if(Lx[i]<=p[j].x&&p[j].x<=Rx[i])  addx(i,k+j,1,0);\n        for(int i=1;i<=k;i++)\n          for(int j=1;j<=n;j++)\n            if(Ly[i]<=p[j].y&&p[j].y<=Ry[i])  addx(k+n+j,k+2*n+i,1,0);\n        ans=0;\n        while(spfa()){};\n        res=max(res,ans);   \n    }\n    cout<<res<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define INF int(1e9)\n#define Inf ll(1e18) \n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=1;i<=(n);i++)\n#define mp make_pair\n#define pb push_back\n#define fst first\n#define snd second\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst int maxn=605;\nconst int maxm=maxn*maxn;\nint n,m;\nchar op[maxn],s[maxn];\nint a[maxn],b[maxn],x[maxn],y[maxn],lim_mnx[maxn],lim_mxx[maxn],lim_mny[maxn],lim_mxy[maxn];\nll v[maxn];\n\nnamespace Flow{\n\tint tot,S,T,V,ansf;\n\tbool in[maxn],vis[maxn];\n\tint head[maxn],nxt[maxm*2],to[maxm*2],cap[maxm*2];\n\tll dist[maxn],cost[maxm*2],ansc;\n\tqueue<int>q;\n\tvoid init(){\n\t\ttot=0;\n\t\tmemset(head,-1,sizeof(head));\n\t}\n\tvoid addedge(int u,int v,int c,ll co){\n\t\tnxt[tot]=head[u];to[tot]=v;cap[tot]=c;cost[tot]=co;head[u]=tot++;\n\t\tnxt[tot]=head[v];to[tot]=u;cap[tot]=0;cost[tot]=-co;head[v]=tot++;\n\t}\n\tvoid spfa(){\n\t\trep(i,V)in[i]=false,dist[i]=Inf;\n\t\tdist[S]=0;\n\t\tin[S]=true;\n\t\tq.push(S);\n\t\twhile(!q.empty()){\n\t\t\tint x=q.front();q.pop();\n\t\t\tin[x]=false;\n\t\t\tfor(int i=head[x];~i;i=nxt[i]){\n\t\t\t\tif(cap[i]&&dist[to[i]]>dist[x]+cost[i]){\n\t\t\t\t\tdist[to[i]]=dist[x]+cost[i];\n\t\t\t\t\tif(!in[to[i]])in[to[i]]=true,q.push(to[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i,V)if(i!=T)dist[i]=dist[T]-dist[i];\n\t\tdist[T]=0;\n\t}\n\tbool modify(){\n\t\tll d=Inf;\n\t\trep(i,V)if(vis[i]){\n\t\t\tfor(int j=head[i];~j;j=nxt[j]){\n\t\t\t\tif(cap[j]&&!vis[to[j]])d=min(d,dist[to[j]]+cost[j]-dist[i]);\n\t\t\t}\n\t\t}\n\t\tif(d==Inf)return false;\n\t\trep(i,V)if(vis[i])dist[i]+=d;\n\t\treturn true; \n\t}\n\tint dfs(int x,int f){\n\t\tvis[x]=true;\n\t\tif(x==T){\n\t\t\tansc+=dist[S]*f;\n\t\t\tansf+=f;\n\t\t\treturn f;\n\t\t}\n\t\tint gf=0;\n\t\tfor(int i=head[x];~i;i=nxt[i]){\n\t\t\tif(!vis[to[i]]&&cap[i]&&dist[to[i]]+cost[i]==dist[x]){\n\t\t\t\tint d=dfs(to[i],min(cap[i],f-gf));\n\t\t\t\tcap[i]-=d;\n\t\t\t\tcap[i^1]+=d;\n\t\t\t\tgf+=d;\n\t\t\t\tif(gf==f)break;\n\t\t\t}\n\t\t}\n\t\treturn gf;\n\t}\n\tpair<int,ll>work(){\n\t\tansc=ansf=0;\n\t\tspfa();\n\t\tfor(;;){\n\t\t\tfor(;;){\n\t\t\t\trep(i,V)vis[i]=false;\n\t\t\t\tint d=dfs(S,INF);\n\t\t\t\tif(!d)break;\n\t\t\t}\n\t\t\tif(!modify())break;\n\t\t}\n\t\treturn mp(ansf,ansc);\n\t}\n}\n\nll calc(int f){\n\tFlow::init();\n\tFlow::S=402;Flow::T=403;Flow::V=404;\n\trep(i,102)lim_mnx[i]=lim_mny[i]=0,lim_mxx[i]=lim_mxy[i]=n;\n\trep(i,m){\n\t\tif(op[i]=='L')lim_mxx[a[i]]=min(lim_mxx[a[i]],b[i]);\n\t\telse if(op[i]=='R')lim_mnx[a[i]-1]=max(lim_mnx[a[i]-1],f-b[i]);\n\t\telse if(op[i]=='D')lim_mxy[a[i]]=min(lim_mxy[a[i]],b[i]);\n\t\telse lim_mny[a[i]-1]=max(lim_mny[a[i]-1],f-b[i]);\n\t}\n\tfor(int i=100;i>=1;i--){\n\t\tlim_mxx[i]=min(lim_mxx[i],lim_mxx[i+1]);\n\t\tlim_mxy[i]=min(lim_mxy[i],lim_mxy[i+1]);\n\t}\n\tREP(i,100){\n\t\tlim_mnx[i]=max(lim_mnx[i],lim_mnx[i-1]);\n\t\tlim_mny[i]=max(lim_mny[i],lim_mny[i-1]);\n\t}\n\tint tot=0;\n\tREP(i,100){\n\t\tif(lim_mnx[i]>lim_mxx[i])return 0;\n\t\tif(lim_mny[i]>lim_mxy[i])return 0;\n\t\tint cur=lim_mnx[i]-lim_mnx[i-1];\n\t\tif(cur>0)Flow::addedge(Flow::S,i,cur,0),tot+=cur;\n\t\telse if(cur<0)Flow::addedge(i,Flow::T,-cur,0);\n\t\tif(i==100)Flow::addedge(0,i,lim_mxx[i]-lim_mnx[i],0);\n\t\telse Flow::addedge(i+1,i,lim_mxx[i]-lim_mnx[i],0);\n\t\tFlow::addedge(i,i+100,n,0); \n\t\tcur=lim_mny[i-1]-lim_mny[i];\n\t\tif(cur>0)Flow::addedge(Flow::S,i+300,cur,0),tot+=cur;\n\t\telse if(cur<0)Flow::addedge(i+300,Flow::T,-cur,0);\n\t\tif(i==100)Flow::addedge(i+300,401,lim_mxy[i]-lim_mny[i],0);\n\t\telse Flow::addedge(i+300,i+300+1,lim_mxy[i]-lim_mny[i],0);\n\t\tFlow::addedge(i+200,i+300,n,0); \n\t}\n\tif(lim_mnx[100])Flow::addedge(0,Flow::T,lim_mnx[100],0);\n\tif(lim_mny[100]){\n\t\ttot+=lim_mny[100];\n\t\tFlow::addedge(Flow::S,401,lim_mny[100],0);\n\t}\n\trep(i,n)Flow::addedge(x[i]+100,y[i]+200,1,-v[i]);\n\tFlow::addedge(Flow::S,0,f,0);\n\tFlow::addedge(401,Flow::T,f,0);\n\tpair<int,ll>ans=Flow::work();\n\tif(ans.fst!=f+tot)return 0;\n\treturn -ans.snd;\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\trep(i,n)scanf(\"%d%d%lld\",&x[i],&y[i],&v[i]);\n\tscanf(\"%d\",&m);\n\trep(i,m){\n\t\tscanf(\"%s%d%d\",s,&a[i],&b[i]);\n\t\top[i]=s[0];\n\t}\n\tll ans=0;\n\tREP(i,n)ans=max(ans,calc(i));\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nnamespace simplex {\n    using T = long double;\n    const int N = 410, M = 30010;\n    const T eps = 1e-7;\n    int n, m;\n    int Left[M], Down[N];\n    // Ax <= b, max c^T x\n    // result : v, xi = sol[i]. 1 based\n    T a[M][N], b[M], c[N], v, sol[N];\n\n    bool eq(T a, T b) { return fabs(a - b) < eps;  }\n    bool ls(T a, T b) { return a < b && !eq(a, b); }\n\n    void init(int p, int q) {\n        n = p; m = q; v = 0;\n        for(int i = 1; i <= m; i++){\n            for(int j = 1; j <= n; j++) a[i][j]=0;\n        }\n        for(int i = 1; i <= m; i++) b[i]=0;\n        for(int i = 1; i <= n; i++) c[i]=sol[i]=0;\n    }\n\n    void pivot(int x,int y) {\n        swap(Left[x], Down[y]);\n        T k = a[x][y]; a[x][y] = 1;\n        vector<int> nz;\n        for(int i = 1; i <= n; i++){\n            a[x][i] /= k;\n            if(!eq(a[x][i], 0)) nz.push_back(i);\n        }\n        b[x] /= k;\n\n        for(int i = 1; i <= m; i++){\n            if(i == x || eq(a[i][y], 0)) continue;\n            k = a[i][y]; a[i][y] = 0;\n            b[i] -= k*b[x];\n            for(int j : nz) a[i][j] -= k*a[x][j];\n        }\n        if(eq(c[y], 0)) return;\n        k = c[y]; c[y] = 0;\n        v += k*b[x];\n        for(int i : nz) c[i] -= k*a[x][i];\n    }\n\n    // 0: found solution, 1: no feasible solution, 2: unbounded\n    int solve() {\n        for(int i = 1; i <= n; i++) Down[i] = i;\n        for(int i = 1; i <= m; i++) Left[i] = n+i;\n        while(1) { // Eliminating negative b[i]\n            int x = 0, y = 0;\n            for(int i = 1; i <= m; i++) if (ls(b[i], 0) && (x == 0 || b[i] < b[x])) x = i;\n            if(x == 0) break;\n            for(int i = 1; i <= n; i++) if (ls(a[x][i], 0) && (y == 0 || a[x][i] < a[x][y])) y = i;\n            if(y == 0) return 1;\n            pivot(x, y);\n        }\n        while(1) {\n            int x = 0, y = 0;\n            for(int i = 1; i <= n; i++)\n                if (ls(0, c[i]) && (!y || c[i] > c[y])) y = i;\n            if(y == 0) break;\n            for(int i = 1; i <= m; i++)\n                if (ls(0, a[i][y]) && (!x || b[i]/a[i][y] < b[x]/a[x][y])) x = i;\n            if(x == 0) return 2;\n            pivot(x, y);\n        }\n        for(int i = 1; i <= m; i++) if(Left[i] <= n) sol[Left[i]] = b[i];\n        return 0;\n    }\n}\nconst int N = 100 + 10;\nint x[N],y[N]; ll w[N];\nint main(){\n    int n; scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++) scanf(\"%d%d%lld\",&x[i],&y[i],&w[i]);\n    int m; scanf(\"%d\",&m);\n    simplex::init(n,n+m);\n    for(int i=1;i<=n;i++) simplex::c[i] = w[i];\n    int cnt = 0;\n    for(int i=1;i<=n;i++){\n        cnt++;\n        simplex::a[cnt][i] = 1, simplex::b[cnt] = 1;\n    }\n    while(m--){\n        char s[3]; int a,b; scanf(\"%s%d%d\",s,&a,&b);\n        cnt++;\n        simplex::b[cnt] = b;\n        if(s[0]=='L'){\n            for(int i=1;i<=n;i++){\n                if(x[i]<=a) simplex::a[cnt][i] = 1;\n            }\n        }\n        if(s[0]=='R'){\n            for(int i=1;i<=n;i++){\n                if(x[i]>=a) simplex::a[cnt][i] = 1;\n            }\n        }\n        if(s[0]=='D'){\n            for(int i=1;i<=n;i++){\n                if(y[i]<=a) simplex::a[cnt][i] = 1;\n            }\n        }\n        if(s[0]=='U'){\n            for(int i=1;i<=n;i++){\n                if(y[i]>=a) simplex::a[cnt][i] = 1;\n            }\n        }\n    }\n    assert(simplex::solve()==0);\n    printf(\"%lld\\n\",(ll)simplex::v);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cctype>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing i64=long long;\nconst int N=507,V=327,E=140007;const i64 inf=1e18;\nint n,m,s,t,tot,head[V],vis[V];i64 cost,dis[V];\nstruct edge{int v,f;i64 c;int next;}e[E];\nstruct node{int x,y;i64 v;}p[N];\nstruct opt{int o,a,b;}op[N];\nint read(){int x=0;int c=getchar();while(isspace(c))c=getchar();while(isdigit(c))(x*=10)+=c&15,c=getchar();return x;}\ni64 raed(){i64 x=0;int c=getchar();while(isspace(c))c=getchar();while(isdigit(c))(x*=10)+=c&15,c=getchar();return x;}\nvoid add(int u,int v,int f,i64 c){e[++tot]={v,f,c,head[u]},head[u]=tot,e[++tot]={u,0,-c,head[v]},head[v]=tot;}\nint update()\n{\n    i64 mn=inf;\n    for(int u=1;u<=t;++u) if(vis[u]) for(int i=head[u];i;i=e[i].next) if(!vis[e[i].v]&&e[i].f) mn=std::min(mn,dis[e[i].v]+e[i].c-dis[u]);\n    if(mn==inf) return 0;\n    for(int u=1;u<=t;++u) if(vis[u]) dis[u]+=mn;\n    return 1;\n}\nint dfs(int u,int res)\n{\n    if(u==t) return cost-=dis[s]*res,res;\n    int use=0;vis[u]=1;\n    for(int i=head[u],t;i;i=e[i].next)\n\tif(!vis[e[i].v]&&e[i].f&&dis[u]==dis[e[i].v]+e[i].c)\n\t{\n\t    t=dfs(e[i].v,std::min(res-use,e[i].f)),use+=t,e[i].f-=t,e[i^1].f+=t;\n\t    if(use==res) return use;\n\t}\n    return use;\n}\nvoid solve(int k)\n{\n    static int lx[N],rx[N],ly[N],ry[N];\n    tot=1,cost=0,s=2*k+2*n+1,t=s+1,memset(head+1,0,t<<2),memset(dis+1,0,t<<3);\n    memset(lx+1,0,k<<2),memset(ly+1,0,k<<2),memset(rx+1,0x7f,k<<2),memset(ry+1,0x7f,k<<2);\n    for(int i=1;i<=k;++i) add(s,i,1,0),add(i+n+n+k,t,1,0);\n    for(int i=1;i<=n;++i) add(i+k,i+n+k,1,-p[i].v);\n    for(int i=1;i<=m;++i)\n\tswitch(op[i].o)\n\t{\n\tcase'U':for(int j=1;j<=k-op[i].b;++j)ry[j]=std::min(ry[j],op[i].a-1);break;\n\tcase'D':for(int j=op[i].b+1;j<=k;++j)ly[j]=std::max(ly[j],op[i].a+1);break;\n\tcase'L':for(int j=op[i].b+1;j<=k;++j)lx[j]=std::max(lx[j],op[i].a+1);break;\n\tcase'R':for(int j=1;j<=k-op[i].b;++j)rx[j]=std::min(rx[j],op[i].a-1);break;\n\t}\n    for(int i=1;i<=k;++i) for(int j=1;j<=n;++j) if(lx[i]<=p[j].x&&p[j].x<=rx[i]) add(i,j+k,1,0);\n    for(int i=1;i<=k;++i) for(int j=1;j<=n;++j) if(ly[i]<=p[j].y&&p[j].y<=ry[i]) add(j+n+k,i+n+n+k,1,0);\n    do do memset(vis+1,0,t<<2);while(dfs(s,1e9));while(update());\n}\nint main()\n{\n    i64 ans=0;\n    n=read();for(int i=1;i<=n;++i) p[i]={read(),read(),raed()};\n    m=read();for(int i=1;i<=m;++i) op[i]={getchar(),read(),read()};\n    for(int k=1;k<=n;++k) solve(k),ans=std::max(ans,cost);\n    printf(\"%lld\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cassert>\n\n#define pb push_back\n#define fir first\n#define sec second\n#define forto(_) for (int e = last[_], v = E[e].to; e; v = E[e = E[e].next].to)\n#define forback(_) for (int _ = T; _ ^ S; _ = pre[_])\n\ntypedef long long LL;\n\nconst int kMaxn = 85, kMaxe = 2e4;\nconst LL kInf64 = 1e15;\n\ntypedef std::pair<int, int> Pii;\ntypedef int IArn[kMaxn];\ntypedef int IArv[kMaxn << 2];\n\nstruct Edge {\n\tint to, capt;\n\tLL cost;\n\tint next;\n} E[kMaxe << 1];\n\nint n, m, tote, S, T;\nIArn X, Y, L, R, U, D;\nIArv last, pre, pree;\nLL V[kMaxn], dist[kMaxn << 2];\nstd::vector<Pii> con[4];\nchar IN[5];\n\ninline void AddEdge(int u, int v, int cap, LL cst) {\n\tassert(u < kMaxn * 4);\n\tassert(v < kMaxn * 4);\n\tE[++tote] = (Edge){v, cap, cst, last[u]}, last[u] = tote;\n\tE[++tote] = (Edge){u, 0, -cst, last[v]}, last[v] = tote;\n}\nLL Mcf();\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d%d%lld\", X + i, Y + i, V + i);\n\t}\n\tscanf(\"%d\", &m);\n\tfor (int i = 0, ai, bi; i < m; i++) {\n\t\tscanf(\"%s%d%d\", IN, &ai, &bi);\n\t\tswitch (IN[0]) {\n\t\t\tcase 'L' :\n\t\t\t\tcon[0].pb(Pii(ai, bi));\n\t\t\t\tbreak;\n\t\t\tcase 'R' :\n\t\t\t\tcon[1].pb(Pii(ai, bi));\n\t\t\t\tbreak;\n\t\t\tcase 'D' :\n\t\t\t\tcon[2].pb(Pii(ai, bi));\n\t\t\t\tbreak;\n\t\t\tcase 'U' :\n\t\t\t\tcon[3].pb(Pii(ai, bi));\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tL[i] = D[i] = 1;\n\t}\n\tfor (auto & p : con[0]) {\n\t\tL[p.sec + 1] = p.fir + 1;\n\t}\n\tfor (auto & p : con[2]) {\n\t\tD[p.sec + 1] = p.fir + 1;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tL[i] = std::max(L[i], L[i - 1]);\n\t\tD[i] = std::max(D[i], D[i - 1]);\n\t}\n\n\tLL ans = 0;\n\tfor (int k = 1; k <= n; k++) {\n\t\tfor (int i = 1; i <= k; i++) {\n\t\t\tR[i] = U[i] = 100;\n\t\t}\n\t\tfor (auto & p : con[1]) {\n\t\t\tif (k <= p.sec) continue;\n\t\t\tR[k - p.sec] = p.fir - 1;\n\t\t}\n\t\tfor (auto & p : con[3]) {\n\t\t\tif (k <= p.sec) continue;\n\t\t\tU[k - p.sec] = p.fir - 1;\n\t\t}\n\t\tfor (int i = k - 1; i > 0; i--) {\n\t\t\tR[i] = std::min(R[i + 1], R[i]);\n\t\t\tU[i] = std::min(U[i + 1], U[i]);\n\t\t}\n\n\t\ttote = 1;\n\t\tmemset(last, 0, sizeof last);\n\t\tT = (S = k + n + n + k + 1) + 1;\n\t\tfor (int i = 1; i <= k; i++) {\n\t\t\tAddEdge(S, i, 1, 0);\n\t\t\tAddEdge(k + n + n + i, T, 1, 0);\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tif (L[i] <= X[j] && X[j] <= R[i]) {\n\t\t\t\t\tAddEdge(i, k + j, 1, 0);\n\t\t\t\t}\n\t\t\t\tif (D[i] <= Y[j] && Y[j] <= U[i]) {\n\t\t\t\t\tAddEdge(k + n + j, k + n + n + i, 1, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tAddEdge(k + i, k + n + i, 1, kInf64 - V[i]);\n\t\t}\n\n\t\tans = std::max(ans, Mcf());\n\t}\n\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n\nbool Spfa() {\n\tstatic std::queue<int> que;\n\tstatic int inque[kMaxn << 2];\n\n\tmemset(pre, 0xff, sizeof pre);\n\tmemset(dist, 0x7f, sizeof dist);\n\n\tfor (dist[S] = 0, que.push(S), inque[S] = 1; !que.empty(); ) {\n\t\tint u = que.front(); que.pop();\n\t\tforto(u) {\n\t\t\tif (E[e].capt > 0 && dist[v] > dist[u] + E[e].cost) {\n\t\t\t\tdist[v] = dist[u] + E[e].cost;\n\t\t\t\tpre[v] = u, pree[v] = e;\n\t\t\t\tif (!inque[v]) {\n\t\t\t\t\tque.push(v), inque[v] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tinque[u] = 0;\n\t}\n\treturn ~pre[T];\n}\n\nLL Mcf() {\n\tLL tot = 0, sumf = 0;\n\twhile (Spfa()) {\n\t\tint flow = 100000;\n\t\tforback(u) {\n\t\t\tflow = std::min(flow, E[pree[u]].capt);\n\t\t}\n\t\ttot += 1ll * flow * dist[T], sumf += flow;\n\t\tforback(u) {\n\t\t\tE[pree[u]].capt -= flow;\n\t\t\tE[pree[u] ^ 1].capt += flow;\n\t\t}\n\t}\n\treturn sumf * kInf64 - tot;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define REV(i,n) for(ll (i) = (n) - 1;(i) >= 0;--i)\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {REP(WW,n)cerr << v[WW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,WW,HH) {REP(W_,WW){REP(H_,HH)cerr << v[W_][H_] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n#define fastcin() cin.tie(0);ios::sync_with_stdio(false)\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nclass minCostFlow {\n\n\tstruct edge { ll to, cap, cost, rev; };\n\n\tll V;\n\tvector<vector<edge>> G;\n\tvector<ll> dist;\n\tvector<ll> prevv;\n\tvector<ll> preve;\n\npublic:\n\n\tminCostFlow(ll n): G(n), dist(n), prevv(n), preve(n), V(n){\n\t}\n\n\tvoid addEdge(ll from, ll to, ll cap, ll cost) {\n\t\tG[from].push_back((edge){to, cap, cost, (ll)G[to].size()});\n\t\tG[to].push_back((edge){from, 0, -cost, (ll)G[from].size() - 1});\n\t}\n\n\tll solve(ll s, ll t, ll f) {\n\t\tll ret = 0;\n\t\twhile(f > 0) {\n\t\t\tfill(dist.begin(), dist.end(), LLINF);\n\t\t\tdist[s] = 0;\n\t\t\tbool update = true;\n\t\t\twhile(update) {\n\t\t\t\tupdate = false;\n\t\t\t\tfor(ll v = 0;v < V;v++) {\n\t\t\t\t\tif(dist[v] == LLINF)continue;\n\t\t\t\t\tfor(ll i = 0;i < G[v].size();i++) {\n\t\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\t\tif(e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n\t\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dist[t] == LLINF) {\n\t\t\t\treturn LLINF;//流せない\n\t\t\t}\n\n\t\t\tll d = f;\n\t\t\tfor(ll v = t;v != s;v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tret += d * dist[t];\n\t\t\tfor(ll v = t;v != s;v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n};\n\nll check(vector<pair<P, ll>> v, vector<pair<char, P>> t, int k){\n\tll cost = 1000000000000000LL;\n\tint n = v.size();\n\tint m = t.size();\n\t\n\tvector<P> ver(k, MP(0, LLINF));\n\tvector<P> hor(k, MP(0, LLINF));\n\t\n\tREP(i, m){\n\t\tchar c = t[i].FI;\n\t\tP p = t[i].SE;\n\t\tif(c == 'L'){\n\t\t\tif(p.SE >= k)continue;\n\t\t\thor[p.SE].FI = max(hor[p.SE].FI, p.FI + 1);\n\t\t}\n\t\telse if(c == 'R'){\n\t\t\tif(k - p.SE - 1 < 0)continue;\n\t\t\thor[k - p.SE - 1].SE = min(hor[k - p.SE - 1].SE, p.FI - 1);\n\t\t}\n\t\telse if(c == 'D'){\n\t\t\tif(p.SE >= k)continue;\n\t\t\tver[p.SE].FI = max(ver[p.SE].FI, p.FI + 1);\n\t\t}\n\t\telse {\n\t\t\tif(k - p.SE - 1 < 0)continue;\n\t\t\tver[k - p.SE - 1].SE = min(ver[k - p.SE - 1].SE, p.FI - 1);\n\t\t}\n\t}\n\t\n\tREP(i, k - 1){\n\t\tver[i + 1].FI = max(ver[i + 1].FI, ver[i].FI);\n\t\thor[i + 1].FI = max(hor[i + 1].FI, hor[i].FI);\n\t\tver[k - i - 2].SE = min(ver[k - i - 2].SE, ver[k - i - 1].SE); \n\t\thor[k - i - 2].SE = min(hor[k - i - 2].SE, hor[k - i - 1].SE); \n\t}\n\t\n\t//REP(i, k)cout << \"(\" << hor[i].FI << \", \" << hor[i].SE << \") \";cout << endl;\n\t//REP(i, k)cout << \"(\" << ver[i].FI << \", \" << ver[i].SE << \") \";cout << endl;\n\t\n\tminCostFlow mcf(2 * (n + m) + 10);\n\t\n\tll s = 2 * (m + n);\n\tll g = 2 * (m + n) + 1;\n\t\n\tREP(i, k){\n\t\tll idA = 2 * n + i;\n\t\tll idB = 2 * n + m + i;\n\t\tmcf.addEdge(s, idA, 1, 0);\n\t\tmcf.addEdge(idB, g, 1, 0);\n\t}\n\t\n\tREP(i, n){\n\t\tP now = v[i].FI;\n\t\tll val = v[i].SE;\n\t\tll idA = i;\n\t\tll idB = i + n;\n\t\tmcf.addEdge(idA, idB, 1, cost - val);\n\t\tREP(j, m){\n\t\t\tll idC = 2 * n + j;\n\t\t\tll idD = 2 * n + m + j;\n\t\t\tif(now.FI >= hor[j].FI && now.FI <= hor[j].SE){\n\t\t\t\tmcf.addEdge(idC, idA, 1, 0);\n\t\t\t}\n\t\t\tif(now.SE >= ver[j].FI && now.SE <= ver[j].SE){\n\t\t\t\tmcf.addEdge(idB, idD, 1, 0);\n\t\t\t}\n\t\t}\n\t}\n\tll ret = k * cost - mcf.solve(s, g, k);\n\t//cout << \"check \" << k << \" \" << ret << endl;\n\treturn ret;\n}\n\nint main(){\n\t\n\tll n;cin >> n;\n\tvector<pair<P, ll>> v(n);\n\tREP(i, n)cin >> v[i].FI.FI >> v[i].FI.SE >> v[i].SE;\n\tll m;cin >> m;\n\tvector<pair<char, P>> t(m);\n\tREP(i, m)cin >> t[i].FI >> t[i].SE.FI >> t[i].SE.SE;\n\t\n\tll ans = 0;\n\t\n\tfor(ll i = 1;i <= n;i++){\n\t\tans = max(ans, check(v, t, i));\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\n// need\n#include <iostream>\n#include <algorithm>\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n//#include <deque>\n#include <valarray>\n#include <unordered_map>\n#include <unordered_set>\n#include <array>\n// stream\n//#include <istream>\n#include <sstream>\n//#include <ostream>\n#include <fstream>\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int w_=0; w_<n; ++w_){MACRO_VEC_ROW_Scan(w_, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& R:c)for(auto& w:R)std::cin>>w;\n// output\n#define OUT(dist) std::cout<<(dist);\n#define FOUT(n, dist) std::cout<<std::fixed<<std::setprecision(n)<<(dist);\n#define SOUT(n, c, dist) std::cout<<std::setw(n)<<std::setfill(c)<<(dist);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(w, n) std::cout<<(w + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(dist) {std::cerr << #dist << \"\\t:\" << (dist) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(w, a, n) for(int w=(a);w<(n);++w)\n#define RFOR(w, a, n) for(int w=(n)-1;w>=(a);--w)\n#define REP(w, n) for(int w=0;w<int(n);++w)\n#define RREP(w, n) for(int w=int(n)-1;w>=0;--w)\n#define FORLL(w, a, n) for(ll w=ll(a);w<ll(n);++w)\n#define RFORLL(w, a, n) for(ll w=ll(n)-1;w>=ll(a);--w)\n#define REPLL(w, n) for(ll w=0;w<ll(n);++w)\n#define RREPLL(w, n) for(ll w=ll(n)-1;w>=0;--w)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<class T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<class T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\n//void CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n// test\ntemplate<class T> using V = std::vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n#define random_shuffle \"USE std::shuffle!\";\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-6;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n// ------------>8------------------------------------->8------------\n\nclass PrimalDual {\n\tconst int INF = (1LL << 60) - 1;\n\tstruct Edge { int to, cap, cost, rev; };\n\n\tint N;\n\tstd::vector<std::vector<Edge>> g;\n\tstd::vector<int> h, dist, preV, preE;\n\npublic:\n\tPrimalDual(int n) : N(n), g(n), h(n), dist(n), preV(n, -1), preE(n, -1) {}\n\n\t// fromからtoへの辺(容量cap, コストcost)を張る\n\tvoid addEdge(int from, int to, int cap, int cost) {\n\t\tg[from].emplace_back(Edge{ to, cap, cost, (int)g[to].size() });\n\t\tg[to].emplace_back(Edge{ from, 0, -cost, (int)g[from].size() - 1 });\n\t}\n\n\t// sからtに流量fの最小費用流を求める (流せなければ-1)\n\tint minCostFlow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.assign(N, 0);\n\t\tusing P = std::pair<int, int>;\n\t\twhile (f > 0) {\n\t\t\tstd::priority_queue<P, std::vector<P>, std::greater<P>> pq;\n\t\t\tdist.assign(N, INF);\n\t\t\tdist[s] = 0;\n\t\t\tpq.push(P(0, s));\n\t\t\twhile (!pq.empty()) {\n\t\t\t\tP p = pq.top(); pq.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first) continue;\n\t\t\t\tfor (int i = 0; i < g[v].size(); ++i) {\n\t\t\t\t\tEdge& e = g[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tpreV[e.to] = v;\n\t\t\t\t\t\tpreE[e.to] = i;\n\t\t\t\t\t\tpq.push(P(dist[e.to], e.to));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == INF) return -1;\n\t\t\tfor (int v = 0; v < N; ++v) h[v] += dist[v];\n\n\t\t\t// s-t間の最短経路に流す\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = preV[v]) {\n\t\t\t\td = std::min(d, g[preV[v]][preE[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d * h[t];\n\t\t\tfor (int v = t; v != s; v = preV[v]) {\n\t\t\t\tEdge& e = g[preV[v]][preE[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tg[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\nint n, m;\nV<int> x, y, v, a, b;\nV<char> t;\n\nint calc(int k) {\n\tV<int> L(k, 1), R(k, 100), D(k, 1), U(k, 100);\n\tREP(i, m) {\n\t\t/* */if (t[i] == 'L') {\n\t\t\tif (!IN(0, b[i], k)) continue;\n\t\t\tL[b[i]] = a[i] + 1;\n\t\t}\n\t\telse if (t[i] == 'R') {\n\t\t\tif (!IN(0, k - 1 - b[i], k)) continue;\n\t\t\tR[k - 1 - b[i]] = a[i] - 1;\n\t\t}\n\t\telse if (t[i] == 'D') {\n\t\t\tif (!IN(0, b[i], k)) continue;\n\t\t\tD[b[i]] = a[i] + 1;\n\t\t}\n\t\telse {\n\t\t\tif (!IN(0, k - 1 - b[i], k)) continue;\n\t\t\tU[k - 1 - b[i]] = a[i] - 1;\n\t\t}\n\t}\n\n\tREP(i, k - 1) {\n\t\tCHMAX(L[i + 1], L[i]);\n\t\tCHMAX(D[i + 1], D[i]);\n\t}\n\tRREP(i, k - 1) {\n\t\tCHMIN(R[i], R[i + 1]);\n\t\tCHMIN(U[i], U[i + 1]);\n\t}\n\n\tPrimalDual pd(1 + k + n + n + k + 1);\n\tconst int X0 = 0, X1 = X0 + 1, X2 = X1 + k, X3 = X2 + n, X4 = X3 + n, X5 = X4 + k;\n\tconst int S = X0, T = X5;\n\n\t{ // X0 -> X1\n\t\tREP(i, k) pd.addEdge(X0, X1 + i, 1, 0);\n\t}\n\t{ // X1 -> X2\n\t\tREP(i, k) REP(j, n) if (IN(L[i], x[j], R[i] + 1)) pd.addEdge(X1 + i, X2 + j, 1, 0);\n\t}\n\t{ // X2 -> X3\n\t\tREP(i, n) pd.addEdge(X2 + i, X3 + i, 1, INFLL - v[i]);\n\t}\n\t{ // X3 -> X4\n\t\tREP(i, k) REP(j, n) if (IN(D[i], y[j], U[i] + 1)) pd.addEdge(X3 + j, X4 + i, 1, 0);\n\t}\n\t{ // X4 -> X5\n\t\tREP(i, k) pd.addEdge(X4 + i, X5, 1, 0);\n\t}\n\n\tint cost = pd.minCostFlow(S, T, k);\n\tif (cost == -1) return -1;\n\tcost -= INFLL * k;\n\treturn -cost;\n}\n\nsigned main() {\n\tINIT;\n\n\tstd::cin >> n;\n\tx.resize(n); y.resize(n); v.resize(n);\n\tREP(i, n) std::cin >> x[i] >> y[i] >> v[i];\n\tstd::cin >> m;\n\tt.resize(m); a.resize(m); b.resize(m);\n\tREP(i, m) std::cin >> t[i] >> a[i] >> b[i];\n\n\tint ans = 0;\n\tFOR(k, 1, n + 1) CHMAX(ans, calc(k));\n\tOUT(ans)BR;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define llong long long\n#define mkpr make_pair\n#define pii pair<int,int>\n#define riterator reverse_iterator\nusing namespace std;\n\ninline int read()\n{\n\tint x = 0,f = 1; char ch = getchar();\n\tfor(;!isdigit(ch);ch=getchar()) {if(ch=='-') f = -1;}\n\tfor(; isdigit(ch);ch=getchar()) {x = x*10+ch-48;}\n\treturn x*f;\n}\n\nnamespace NetFlow\n{\n\tconst int N = 206;\n\tconst int M = 284;\n\t#define lllong __int128\n\tconst lllong INF = 2e17;\n\tconst lllong INF2 = 1e22;\n\tstruct AEdge\n\t{\n\t\tint u,v,wl,wr; lllong c;\n\t} ae[M+3];\n\tstruct Edge\n\t{\n\t\tint u,v,nxt,w; lllong c;\n\t} e[(M<<2)+3];\n\tint fe[N+3];\n\tlllong dis[N+3];\n\tint que[N+5];\n\tbool inq[N+3];\n\tint lst[N+3];\n\tint n,m,en,s,t; lllong mf,mc;\n\tvoid init()\n\t{\n\t\tmemset(ae,0,sizeof(ae)); memset(e,0,sizeof(e)); memset(fe,0,sizeof(fe)); memset(dis,0,sizeof(dis)); memset(que,0,sizeof(que)); memset(inq,0,sizeof(inq)); memset(lst,0,sizeof(lst));\n\t\tn = m = s = t = 0; mf = mc = (lllong)0;\n\t}\n\tvoid addedge0(int u,int v,int w,lllong c)\n\t{\n//\t\tprintf(\"adde' %d %d %d %lld\\n\",u,v,w,c);\n\t\ten++; e[en].u = u,e[en].v = v,e[en].w = w,e[en].c = c;\n\t\te[en].nxt = fe[u]; fe[u] = en;\n\t\ten++; e[en].u = v,e[en].v = u,e[en].w = 0,e[en].c = -c;\n\t\te[en].nxt = fe[v]; fe[v] = en;\n\t}\n\tbool spfa()\n\t{\n\t\tfor(int i=1; i<=n; i++) dis[i] = -INF2;\n\t\tint hd = 1,tl = 2; que[1] = s; dis[1] = 0;\n\t\twhile(hd!=tl)\n\t\t{\n\t\t\tint u = que[hd]; hd++; if(hd>n+1) hd-=n+1;\n\t\t\tfor(int i=fe[u]; i; i=e[i].nxt)\n\t\t\t{\n\t\t\t\tint v = e[i].v;\n\t\t\t\tif(e[i].w>0&&dis[e[i].v]<dis[u]+e[i].c)\n\t\t\t\t{\n\t\t\t\t\tdis[e[i].v] = dis[u]+e[i].c; lst[e[i].v] = i;\n\t\t\t\t\tif(!inq[e[i].v])\n\t\t\t\t\t{\n\t\t\t\t\t\tinq[e[i].v] = true;\n\t\t\t\t\t\tque[tl] = e[i].v; tl++; if(tl>n+1) tl-=n+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tinq[u] = false;\n\t\t}\n\t\treturn dis[t]!=-INF2;\n\t}\n\tvoid calcflow()\n\t{\n\t\tint flow = 1e5;\n\t\tfor(int u=t; u!=s; u=e[lst[u]].u)\n\t\t{\n\t\t\tflow = min(flow,e[lst[u]].w);\n\t\t}\n\t\tfor(int u=t; u!=s; u=e[lst[u]].u)\n\t\t{\n\t\t\te[lst[u]].w -= flow; e[lst[u]^1].w += flow;\n\t\t}\n\t\tmf += flow; mc += 1ll*flow*dis[t];\n\t}\n\tvoid mfmc()\n\t{\n\t\tmf = mc = 0; while(spfa()) {calcflow();}\n\t}\n\tvoid addedge(int u,int v,int wl,int wr,llong c)\n\t{\n//\t\tprintf(\"+ %d %d %d %d %lld\\n\",u,v,wl,wr,c);\n\t\tm++; ae[m].u = u,ae[m].v = v,ae[m].wl = wl,ae[m].wr = wr,ae[m].c = c;\n\t}\n\tllong flow(int _n,int _s,int _t,int _mf)\n\t{\n\t\tn = _n,s = _s,t = _t; en = 1; lllong ret = 0ll;\n\t\tfor(int i=1; i<=m; i++)\n\t\t{\n\t\t\tif(ae[i].wl) {addedge0(ae[i].u,ae[i].v,ae[i].wl,INF); ret += (ae[i].c-INF)*(lllong)ae[i].wl;}\n\t\t\taddedge0(ae[i].u,ae[i].v,ae[i].wr-ae[i].wl,ae[i].c);\n\t\t}\n\t\tmfmc();\n\t\tif(mf!=_mf||mc+ret>=INF/2) {return -1ll;}\n\t\treturn mc+ret;\n\t}\n}\n\nconst int N = 100;\nstruct Element\n{\n\tint x,y; llong w;\n} a[N+3];\nstruct Condition\n{\n\tint typ,x,y;\n} b[N+3];\nint alx[N+3],aly[N+3],arx[N+3],ary[N+3];\nint n,m,mx; llong ans;\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tscanf(\"%d%d%lld\",&a[i].x,&a[i].y,&a[i].w); mx = max(mx,max(a[i].x,a[i].y));\n\t}\n\tscanf(\"%d\",&m);\n\tfor(int i=1; i<=m; i++)\n\t{\n\t\tchar str[5]; scanf(\"%s%d%d\",str,&b[i].x,&b[i].y); mx = max(mx,b[i].x);\n\t\tb[i].typ = (str[0]=='L'?0:(str[0]=='R'?1:(str[0]=='D'?2:3)));\n\t}\n\tmx++;\n\tfor(int k=1; k<=n; k++)\n\t{\n//\t\tprintf(\"\\nk=%d\\n\",k);\n\t\tfor(int i=0; i<=mx; i++) alx[i] = 0,arx[i] = k,aly[i] = 0,ary[i] = k;\n\t\tfor(int i=1; i<=m; i++)\n\t\t{\n\t\t\tif(b[i].typ==0)\n\t\t\t{\n\t\t\t\talx[b[i].x+1] = max(alx[b[i].x],k-b[i].y);\n\t\t\t}\n\t\t\telse if(b[i].typ==1)\n\t\t\t{\n\t\t\t\tarx[b[i].x] = min(arx[b[i].x],b[i].y);\n\t\t\t}\n\t\t\telse if(b[i].typ==2)\n\t\t\t{\n\t\t\t\tary[b[i].x] = min(ary[b[i].x],b[i].y);\n\t\t\t}\n\t\t\telse if(b[i].typ==3)\n\t\t\t{\n\t\t\t\taly[b[i].x-1] = max(aly[b[i].x],k-b[i].y);\n\t\t\t}\n\t\t}\n//\t\tprintf(\"x: \"); for(int i=0; i<=mx; i++) printf(\"[%d,%d] \",alx[i],arx[i]); puts(\"\");\n//\t\tprintf(\"y: \"); for(int i=0; i<=mx; i++) printf(\"[%d,%d] \",aly[i],ary[i]); puts(\"\");\n\t\tbool ok = true;\n\t\tfor(int i=0; i<=mx; i++) {if(alx[i]>arx[i]||aly[i]>ary[i]) {ok = false; break;}}\n\t\tif(!ok) continue;\n\t\tNetFlow::init();\n\t\tfor(int i=0; i<=mx; i++)\n\t\t{\n\t\t\tNetFlow::addedge(i==0?1:i+2,i+3,alx[i],arx[i],0ll);\n\t\t}\n\t\tfor(int i=0; i<=mx; i++)\n\t\t{\n\t\t\tNetFlow::addedge(i+mx+4,i==mx?2:i+mx+5,aly[i],ary[i],0ll);\n\t\t}\n\t\tfor(int i=1; i<=n; i++)\n\t\t{\n\t\t\tNetFlow::addedge(a[i].x+3,a[i].y+mx+4,0,1,a[i].w);\n\t\t}\n\t\tllong cur = NetFlow::flow(mx+mx+4,1,2,k);\n//\t\tprintf(\"cur=%lld\\n\",cur);\n\t\tans = max(ans,cur);\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ref(i,x,y)for(int i=x;i<=y;++i)\n#define def(i,x,y)for(int i=x;i>=y;--i)\n#define fi first\n#define se second\n#define int long long\n#define pb push_back\ntypedef long long LL;\nconst int N=301;\nint n,m;\nint lx[2][N],ly[2][N];\nstruct dot{int x,y,v,id;}p[N],px[N],py[N];\nbool cmpx(dot a,dot b){return a.x<b.x;}\nbool cmpy(dot a,dot b){return a.y<b.y;}\nvoid smin(int&a,int b){if(b<a)a=b;}\nvoid smax(int&a,int b){if(b>a)a=b;}\nnamespace eden{\n\tint w[N][N],c[N][N],op,ed;\n\tvoid init(){\n\t\tmemset(w,0,sizeof w);\n\t\tmemset(c,0,sizeof c);\n\t}\n\tvoid add(int x,int y,int ww,int cc){\n\t\tw[x][y]=ww;w[y][x]=0;\n\t\tc[x][y]=cc;c[y][x]=-cc;\n\t}\n\tqueue<int> q;bool vis[N];int dis[N],pre[N];\n\tbool spfa(){\n\t\tmemset(vis,0,sizeof vis);\n\t\tmemset(pre,0,sizeof pre);\n\t\twhile(!q.empty())q.pop();\n\t\tref(i,1,ed)dis[i]=(LL)1e18;\n\t\tdis[op]=0;q.push(op);vis[op]=1;\n\t\twhile(!q.empty()){\n\t\t\tint u=q.front();q.pop();vis[u]=0;\n\t\t\tref(v,1,ed)if(w[u][v]&&dis[u]+c[u][v]<dis[v]){\n\t\t\t\tdis[v]=dis[u]+c[u][v];pre[v]=u;\n\t\t\t\tif(!vis[v])vis[v]=1,q.push(v);\n\t\t\t}\n\t\t}\n\t\treturn (dis[ed]<(LL)1e18);\n\t}\n\tpair<int,int> run(){\n\t\tint fw=0,res=0;\n\t\twhile(spfa()){\n\t\t\tfw++;res+=dis[ed];\n\t\t\tfor(int i=ed;i!=op;i=pre[i])\n\t\t\t\tw[pre[i]][i]--,w[i][pre[i]]++;\n\t\t}\n\t\treturn make_pair(fw,res);\n\t}\n}\nsigned main(){\n\tcin>>n;\n\tref(i,1,n)cin>>p[i].x>>p[i].y>>p[i].v;\n\tref(i,1,n)p[i].id=i;\n\tref(i,1,n)px[i]=p[i];\n\tref(i,1,n)py[i]=p[i];\n\tsort(px+1,px+n+1,cmpx);\n\tsort(py+1,py+n+1,cmpy);\n\tcin>>m;\n\tref(i,1,n)lx[0][i]=ly[0][i]=n+1;\n\tref(i,1,n)lx[1][i]=ly[1][i]=0;\n\tref(i,1,m){\n\t\tchar c;int a,b;cin>>c>>a>>b;\n\t\tif(c=='L'){\n\t\t\tint pos=0;\n\t\t\tref(j,1,n)if(px[j].x<=a)pos=j;\n\t\t\tif(pos>b)smin(lx[0][pos-b],pos);\n\t\t}\n\t\tif(c=='R'){\n\t\t\tint pos=n+1;\n\t\t\tdef(j,n,1)if(px[j].x>=a)pos=j;\n\t\t\tif(n+1-pos>b)smax(lx[1][n+1-pos-b],pos);\n\t\t}\n\t\tif(c=='D'){\n\t\t\tint pos=0;\n\t\t\tref(j,1,n)if(py[j].y<=a)pos=j;\n\t\t\tif(pos>b)smin(ly[0][pos-b],pos);\n\t\t}\n\t\tif(c=='U'){\n\t\t\tint pos=n+1;\n\t\t\tdef(j,n,1)if(py[j].y>=a)pos=j;\n\t\t\tif(n+1-pos>b)smax(ly[1][n+1-pos-b],pos);\n\t\t}\n\t}\n\tdef(i,n-1,1)smin(lx[0][i],lx[0][i+1]);\n\tdef(i,n-1,1)smin(ly[0][i],ly[0][i+1]);\n\tdef(i,n-1,1)smax(lx[1][i],lx[1][i+1]);\n\tdef(i,n-1,1)smax(ly[1][i],ly[1][i+1]);\n\tint ans=0,sum=0;\n\tref(i,1,n)ans+=p[i].v,sum+=p[i].v;\n\tref(S,0,n){\n\t\tif(S<n){\n\t\t\tif(lx[0][S+1]<=n||ly[0][S+1]<=n)continue;\n\t\t\tif(lx[1][S+1]>=1&&ly[1][S+1]>=1)continue;\n\t\t}\n\t\tbool fg=1;\n\t\tref(i,1,S)if(lx[1][S+1-i]>lx[0][i]){fg=0;break;}\n\t\tref(i,1,S)if(ly[1][S+1-i]>ly[0][i]){fg=0;break;}\n\t\tif(!fg)continue;\n\t\teden::init();\n\t\teden::op=n+n+n+n+1;eden::ed=eden::op+1;\n\t\tref(i,1,S)ref(j,max(1LL,lx[1][S+1-i]),min(n,lx[0][i]))\n\t\t\teden::add(i,n+px[j].id,1,0);\n\t\tref(i,1,n)eden::add(n+i,n+n+i,1,p[i].v);\n\t\tref(i,1,S)ref(j,max(1LL,ly[1][S+1-i]),min(n,ly[0][i]))\n\t\t\teden::add(n+n+py[j].id,n+n+n+i,1,0);\n\t\tref(i,1,S)eden::add(eden::op,i,1,0);\n\t\tref(i,1,S)eden::add(n+n+n+i,eden::ed,1,0);\n\t\tpair<int,int> pp=eden::run();\n\t\tif(pp.fi==S)ans=min(ans,pp.se);\n\t}\n\tcout<<sum-ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\ntypedef long double T; // long double, Rational, double + mod<P>...\ntypedef vector<T> vd;\ntypedef vector<vd> vvd;\n\nconst T eps = 1e-20, inf = 1/.0;\n#define MP make_pair\n#define ltj(X) if(s == -1 || MP(X[j],N[j]) < MP(X[s],N[s])) s=j\n\nstruct LPSolver {\n\tint m, n;\n\tvi N, B;\n\tvvd D;\n\n\tLPSolver(const vvd& A, const vd& b, const vd& c) :\n\t\tm(sz(b)), n(sz(c)), N(n+1), B(m), D(m+2, vd(n+2)) {\n\t\t\trep(i,0,m) rep(j,0,n) D[i][j] = A[i][j];\n\t\t\trep(i,0,m) { B[i] = n+i; D[i][n] = -1; D[i][n+1] = b[i];}\n\t\t\trep(j,0,n) { N[j] = j; D[m][j] = -c[j]; }\n\t\t\tN[n] = -1; D[m+1][n] = 1;\n\t\t}\n\n\tvoid pivot(int r, int s) {\n\t\tT *a = D[r].data(), inv = 1 / a[s];\n\t\trep(i,0,m+2) if (i != r && abs(D[i][s]) > eps) {\n\t\t\tT *b = D[i].data(), inv2 = b[s] * inv;\n\t\t\trep(j,0,n+2) b[j] -= a[j] * inv2;\n\t\t\tb[s] = a[s] * inv2;\n\t\t}\n\t\trep(j,0,n+2) if (j != s) D[r][j] *= inv;\n\t\trep(i,0,m+2) if (i != r) D[i][s] *= -inv;\n\t\tD[r][s] = inv;\n\t\tswap(B[r], N[s]);\n\t}\n\n\tbool simplex(int phase) {\n\t\tint x = m + phase - 1;\n\t\tfor (;;) {\n\t\t\tint s = -1;\n\t\t\trep(j,0,n+1) if (N[j] != -phase) ltj(D[x]);\n\t\t\tif (D[x][s] >= -eps) return true;\n\t\t\tint r = -1;\n\t\t\trep(i,0,m) {\n\t\t\t\tif (D[i][s] <= eps) continue;\n\t\t\t\tif (r == -1 || MP(D[i][n+1] / D[i][s], B[i])\n\t\t\t\t             < MP(D[r][n+1] / D[r][s], B[r])) r = i;\n\t\t\t}\n\t\t\tif (r == -1) return false;\n\t\t\tpivot(r, s);\n\t\t}\n\t}\n\n\tT solve(vd &x) {\n\t\tint r = 0;\n\t\trep(i,1,m) if (D[i][n+1] < D[r][n+1]) r = i;\n\t\tif (D[r][n+1] < -eps) {\n\t\t\tpivot(r, n);\n\t\t\tif (!simplex(2) || D[m+1][n+1] < -eps) return -inf;\n\t\t\trep(i,0,m) if (B[i] == -1) {\n\t\t\t\tint s = 0;\n\t\t\t\trep(j,1,n+1) ltj(D[i]);\n\t\t\t\tpivot(i, s);\n\t\t\t}\n\t\t}\n\t\tbool ok = simplex(1); x = vd(n);\n\t\trep(i,0,m) if (B[i] < n) x[B[i]] = D[i][n+1];\n\t\treturn ok ? D[m][n+1] : inf;\n\t}\n};\n\nint n, m, x[105], y[105];\nll v[105];\n\nvvd A, A1;\nvd t, b, c, b1, c1, xx;\n\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> x[i] >> y[i] >> v[i];\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tt.clear();\n\t\tt.resize(n);\n\t\tt[i] = -1;\n\t\tA.push_back(t);\n\t\tb.push_back(0);\t\n\t\tt.clear();\n\t\tt.resize(n);\n\t\tt[i] = 1;\n\t\tA.push_back(t);\n\t\tb.push_back(1);\t\t\n\t}\n\tcin >> m;\n\tfor (int i = 0; i < m; ++i) {\n\t\tt.clear();\n\t\tt.resize(n);\n\t\tchar f;\n\t\tint a, bb;\n\t\tcin >> f >> a >> bb;\n\t\tif (f == 'L') {\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\tif (x[j] <= a)\n\t\t\t\t\tt[j] = 1;\n\t\t} if (f == 'R') {\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\tif (x[j] >= a)\n\t\t\t\t\tt[j] = 1;\n\t\t} if (f == 'U') {\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\tif (y[j] >= a)\n\t\t\t\t\tt[j] = 1;\n\t\t} if (f == 'D') {\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\tif (y[j] <= a)\n\t\t\t\t\tt[j] = 1;\n\t\t}\n\t\tA.push_back(t);\n\t\tb.push_back(bb);\n\t}\n\tc.resize(n);\n\tfor (int i = 0; i < n; ++i)\n\t\tc[i] = v[i];\n\tll ans = 0;\n\tfor (int i = 0; i <= n; ++i) {\n\t\tA1 = A, b1 = b, c1 = c;\n\t\tfor (int j = 0; j < n; ++j)\n\t\t\tt[j] = 1;\n\t\tA1.push_back(t);\n\t\tb1.push_back(i+20*eps);\n\t\tfor (int j = 0; j < n; ++j)\n\t\t\tt[j] = -1;\n\t\tA1.push_back(t);\n\t\tb1.push_back(-i-20*eps);\n\t\tans = max(ans, (ll)lround(LPSolver(A1, b1, c1).solve(xx)));\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=505,M=50005,R=100;\nconst ll inf=0x3f3f3f3f3f3f3f3fll;\nint read(){\n\tint f=1,g=0;\n\tchar ch=getchar();\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-') f=-1;\n\tfor (;isdigit(ch);ch=getchar()) g=g*10+ch-'0';\n\treturn f*g;\n}\nvoid chkmax(int &x,int y){if (x<y) x=y;}\nvoid chkmin(int &x,int y){if (x>y) x=y;}\nint n,m;\nstruct jew{int x,y;ll w;}a[N];\nstruct node{char typ;int x,r;}b[N];\nll cost,ans;\nint S,T,cnt,fir[N],fr[N],siz;\nstruct edge{int u,v;ll w;int fl,nex;}e[M];\nvoid add(int u,int v,ll w,int fl){\n\te[++siz]=(edge){u,v,w,fl,fir[u]};fir[u]=siz;\n\te[++siz]=(edge){v,u,-w,0,fir[v]};fir[v]=siz;\n}\nll dist[N];int que[N*50];bool inq[N];\nvoid dec(int x,int fl){e[x].fl-=fl;e[x^1].fl+=fl;}\nbool spfa(){\n\tmemset(dist,0xc0,8*(cnt+1));\n\tmemset(inq,0,cnt+1);\n\tint l=1,r=1;que[l]=S;dist[S]=0;inq[S]=1;\n\twhile (l<=r){\n\t\tint x=que[l];\n\t\tfor (int i=fir[x];i;i=e[i].nex)\n\t\tif ((e[i].fl)&&(dist[e[i].v]<dist[x]+e[i].w)){\n\t\t\tif (!inq[e[i].v]) {que[++r]=e[i].v;inq[e[i].v]=1;}\n\t\t\tdist[e[i].v]=dist[x]+e[i].w;fr[e[i].v]=i;\n\t\t}\n\t\tinq[x]=0;l++;\n\t}\n\treturn dist[T]>(ll)0xc0c0c0c0c0c0c0c0ll;\n}\nint update(){\n\tint t=0x3f3f3f3f;\n\tfor (int i=fr[T];i;i=fr[e[i].u]) t=min(t,e[i].fl);\n\tcost+=t*dist[T];\n\tfor (int i=fr[T];i;i=fr[e[i].u]) dec(i,t);\n\treturn t;\n}\nint dinic(){\n\tint flow=0;\n\twhile (spfa()) flow+=update();\n\treturn flow;\n}\nint ml[N],mr[N],mu[N],md[N];\nvoid calc(int L){\n\tmemset(fir,0,sizeof(fir));siz=1;\n\tS=0;T=cnt=L*2+R*2+1;\n\tfor (int i=1;i<=n;i++) add(a[i].x,a[i].y+R,a[i].w,1);\n\tfor (int i=1;i<=L;i++) {ml[i]=mu[i]=1,mr[i]=md[i]=R;add(S,R*2+i,0,1);add(R*2+L+i,T,0,1);}\n\tfor (int i=1;i<=m;i++)\n\tif (b[i].r>=L) continue;\n\telse if (b[i].typ=='L') chkmax(ml[b[i].r+1],b[i].x+1);\n\telse if (b[i].typ=='R') chkmin(mr[L-b[i].r],b[i].x-1);\n\telse if (b[i].typ=='D') chkmax(mu[b[i].r+1],b[i].x+1);\n\telse if (b[i].typ=='U') chkmin(md[L-b[i].r],b[i].x-1);\n\tfor (int i=2;i<=L;i++) chkmax(ml[i],ml[i-1]),chkmax(mu[i],mu[i-1]);\n\tfor (int i=L-1;i;i--)  chkmin(md[i],md[i+1]),chkmin(md[i],md[i+1]);\n\tfor (int i=1;i<=L;i++){\n\t\tfor (int j=ml[i];j<=mr[i];j++) add(R*2+i,j,0,1);\n\t\tfor (int j=mu[i];j<=md[i];j++) add(j+R,R*2+L+i,0,1);\n\t}\n\tcost=0;\n\tif (dinic()==L) ans=max(ans,cost);\n//\tfor (int i=1;i<=n;i++) if (!e[i*2].fl) printf(\"%d \",i);\n//\tprintf(\"\\n\");\n}\nint main(){\n\tn=read();\n\tfor (int i=1;i<=n;i++) scanf(\" %d %d %lld\",&a[i].x,&a[i].y,&a[i].w);\n\tm=read();\n\tfor (int i=1;i<=m;i++) scanf(\" %c %d %d\",&b[i].typ,&b[i].x,&b[i].r);\n\tfor (int i=1;i<=n;i++) calc(i);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define itn int\n#define all(x) (x).begin(), (x).end()\n#define make_unique(x) sort(all((x))); (x).resize(unique(all((x))) - (x).begin())\n\n#define random_shuffle(...) shuffle(__VA_ARGS__, rng)\n#define rand() rng()\n\nusing namespace std;\n\ninline int nxt() {\n\tint x;\n\tscanf(\"%d\", &x);\n\treturn x;\n}\n\n#define sz(x) ((int) (x).size())\n#define forn(i,n) for (int i = 0; i < int(n); ++i)\n\ntypedef long long ll;\ntypedef long long i64;\ntypedef long double ld;\nconst int inf = int(1e9) + int(1e5);\nconst ll infl = ll(2e18) + ll(1e10);\n\nconst int maxn = 505;\nconst int maxm = 505;\n\nconst ld eps = 1e-9;\n\nbool eq(ld a, ld b) {\n    return fabsl(a - b) < eps;\n}\n\n//BEGIN_CODE\nnamespace Simplex {\n\nld D[maxm][maxn]; // [n+2][m+2]\nint B[maxm];\nint N[maxn];\nld x[maxn];\nint n, m;\n\n//x >= 0, Ax <= b, c^Tx -> max\nvoid init(int _n, int _m, ld A[][maxn], ld *b, ld *c) {\n    n = _n, m = _m;\n    forn (i, m)\n        forn (j, n)\n            D[i][j] = -A[i][j];\n    forn (i, m) {\n        D[i][n] = 1;\n        D[i][n + 1] = b[i];\n    }\n    forn (j, n) {\n        D[m][j] = c[j];\n        D[m + 1][j] = 0;\n    }\n    D[m][n + 1] = D[m][n] = D[m + 1][n + 1] = 0;\n    D[m + 1][n] = -1;\n    iota(B, B + m, n);\n    iota(N, N + n, 0);\n    N[n] = -1;\n}\n\nvoid pivot(int b, int nb) {\n    assert(D[b][nb] != 0);\n    ld q = 1. / -D[b][nb];\n    D[b][nb] = -1;\n    forn (i, n + 2)\n        D[b][i] *= q;\n    forn (i, m + 2) {\n        if (i == b)\n            continue;\n        ld coef = D[i][nb];\n        D[i][nb] = 0;\n        forn (j, n + 2)\n            D[i][j] += coef * D[b][j];\n    }\n    swap(B[b], N[nb]);\n}\n\nbool betterN(int f, int i, int j) {\n    if (eq(D[f][i], D[f][j]))\n        return N[i] < N[j];\n    return D[f][i] > D[f][j];\n}\n\nbool betterB(int nb, int i, int j) {\n    ld ai = D[i][n + 1] / D[i][nb];\n    ld aj = D[j][n + 1] / D[j][nb];\n    if (eq(ai, aj))\n        return B[i] < B[j];\n    return ai > aj;\n}\n\nbool simplex(int phase) {\n    int f = phase == 1 ? m : m + 1;\n    while (true) {\n        int nb = -1;\n        forn (i, n + 1) {\n            if (N[i] == -1 && phase == 1)\n                continue;\n            if (nb == -1 || betterN(f, i, nb))\n                nb = i;\n        }\n        if (D[f][nb] <= eps)\n            return phase == 1;\n        assert(nb != -1);\n\n        int b = -1;\n        forn (i, m) {\n            if (D[i][nb] >= -eps)\n                continue;\n            if (b == -1 || betterB(nb, i, b))\n                b = i;\n        }\n        if (b == -1)\n            return false;\n        pivot(b, nb);\n        if (N[nb] == -1 && phase == 2)\n            return true;\n    }\n}\n\nld solve() {\n    int b = -1;\n    forn (i, m) {\n        if (b == -1 || D[i][n + 1] < D[b][n + 1])\n            b = i;\n    }\n    assert(b != -1);\n    if (D[b][n + 1] < -eps) {\n        pivot(b, n);\n        if (!simplex(2) || D[m + 1][n + 1] < -eps)\n            return -infl;\n    }\n    if (!simplex(1))\n        return infl;\n\n    forn (i, n)\n        x[i] = 0;\n    forn (i, m)\n        if (B[i] < n)\n            x[B[i]] = D[i][n + 1];\n\n    return D[m][n + 1];\n}\n\n} //Simplex\n//END_CODE\n\nstruct Treasure {\n\tint x, y;\n\tlong long v;\n\n\tvoid scan() {\n\t\tscanf(\"%d%d%lld\", &x, &y, &v);\n\t}\n};\n\nstruct Constraint {\n\tchar t;\n\tint a, b;\n\n\tvoid scan() {\n\t\tcin >> t >> a >> b;\n\t}\n\n\tbool isAbout(const Treasure& tr) const {\n\t\tif (t == 'D') {\n\t\t\treturn tr.y <= a;\n\t\t} else if (t == 'U') {\n\t\t\treturn tr.y >= a;\n\t\t} else if (t == 'L') {\n\t\t\treturn tr.x <= a;\n\t\t} else if (t == 'R') {\n\t\t\treturn tr.x >= a;\n\t\t} else {\n\t\t\tassert(false);\n\t\t}\n\t}\n};\n\nld a[maxm][maxn];\nld b[maxm];\nld c[maxn];\n\nint main() {\n\tmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n\tint n = nxt();\n\tvector<Treasure> trs(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\ttrs[i].scan();\n\t}\n\n\tint m = nxt();\n\tvector<Constraint> crs(m);\n\tfor (int i = 0; i < m; ++i) {\n\t\tcrs[i].scan();\n\t}\n\n\tfor (int i = 0; i < m; ++i) {\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\ta[i][j] = crs[i].isAbout(trs[j]);\n\t\t}\n\t\tb[i] = crs[i].b;\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\ta[m + i][i] = 1;\n\t\tb[m + i] = 1;\n\t\tc[i] = trs[i].v * 1e-7;\n\t}\n\n\tSimplex::init(n, n + m, a, b, c);\n\tSimplex::solve();\n\n\tlong long ans = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tans += trs[i].v * (int)(roundl(Simplex::x[i]));\n\t}\n\tcout << ans << \"\\n\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstring>\n#include <cstdio>\nusing ll = long long;\nint lst[405], to[200005], pre[200005], cap[200005], tot;\nint que[2000005], path[405], sum[405];\nbool in[405], vis[405];\nll dis[405], cost[200005];\ninline void add_edge(int u, int v, int _cap, ll _cost)\n{\n\tauto _add = [&] (int x, int y, int ca, ll co)\n\t{\n\t\tto[tot] = y;\n\t\tpre[tot] = lst[x];\n\t\tcap[tot] = ca;\n\t\tcost[tot] = co;\n\t\tlst[x] = tot++;\n\t};\n\t_add(u, v, _cap, _cost);\n\t_add(v, u, 0, -_cost);\n}\nint dfs(int u, int t, int rem)\n{\n\tif (u == t)\n\t\treturn rem;\n\tvis[u] = true;\n\tint ans = 0;\n\tfor (int i = lst[u]; ~i; i = pre[i])\n\t{\n\t\tif (vis[to[i]] || !cap[i] || dis[to[i]] != dis[u] + cost[i])\n\t\t\tcontinue;\n\t\tint v = to[i], res = dfs(v, t, std::min(rem - ans, cap[i]));\n\t\tcap[i] -= res;\n\t\tcap[i ^ 1] += res;\n\t\tans += res;\n\t\tif (ans == rem)\n\t\t\treturn ans;\n\t}\n\treturn ans;\n}\ninline ll min_cost_max_flow(int s, int t)\n{\n\tll res = 0;\n\twhile (true)\n\t{\n\t\tmemset(dis, 0x3f, sizeof(dis));\n\t\tmemset(in, false, sizeof(in));\n\t\tint he = 0, ta = 0;\n\t\tque[ta++] = s;\n\t\tdis[s] = 0;\n\t\tin[s] = true;\n\t\tauto update = [&] { if (he < ta && dis[que[he]] > dis[que[ta - 1]]) std::swap(que[he], que[ta - 1]); };\n\t\twhile (he < ta)\n\t\t{\n\t\t\tint u = que[he++];\n\t\t\tin[u] = false;\n\t\t\tupdate();\n\t\t\tfor (int i = lst[u]; ~i; i = pre[i])\n\t\t\t{\n\t\t\t\tif (cap[i] && dis[to[i]] > dis[u] + cost[i])\n\t\t\t\t{\n\t\t\t\t\tpath[to[i]] = i;\n\t\t\t\t\tdis[to[i]] = dis[u] + cost[i];\n\t\t\t\t\tif (!in[to[i]])\n\t\t\t\t\t{\n\t\t\t\t\t\tin[to[i]] = true;\n\t\t\t\t\t\tque[ta++] = to[i];\n\t\t\t\t\t\tupdate();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dis[t] >= 1e18)\n\t\t\tbreak;\n\t\twhile (true)\n\t\t{\n\t\t\tfor (int i = 0; i < ta; i++)\n\t\t\t\tvis[que[i]] = false;\n\t\t\tint mn = dfs(s, t, 1e9);\n\t\t\tif (!mn)\n\t\t\t\tbreak;\n\t\t\tres += mn * dis[t];\n\t\t}\n\t}\n\treturn res;\n}\nconstexpr int LIM = 100;\nstruct { int x, y; ll w; } arr[105];\nstruct { char tp; int a, b; } qry[105];\nint xl[105], xr[105], yl[105], yr[105];\nint main()\n{\n\t// freopen(\"AGC031-E.in\", \"r\", stdin);\n\tint n, q;\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(\"%d%d%lld\", &arr[i].x, &arr[i].y, &arr[i].w);\n\tscanf(\"%d\", &q);\n\tfor (int i = 0; i < q; i++)\n\t\tscanf(\" %c%d%d\", &qry[i].tp, &qry[i].a, &qry[i].b);\n\tll ans = 0;\n\tfor (int k = 1; k <= n; k++)\n\t{\n\t\tfor (int i = 1; i <= k; i++)\n\t\t{\n\t\t\txl[i] = yl[i] = 0;\n\t\t\txr[i] = yr[i] = LIM;\n\t\t}\n\t\tfor (int i = 0; i < q; i++)\n\t\t{\n\t\t\tif (qry[i].b >= k)\n\t\t\t\tcontinue;\n\t\t\tif (qry[i].tp == 'L' || qry[i].tp == 'D')\n\t\t\t{\n\t\t\t\tint *res = qry[i].tp == 'L' ? xl : yl;\n\t\t\t\tres[qry[i].b + 1] = std::max(res[qry[i].b + 1], qry[i].a + 1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint *res = qry[i].tp == 'R' ? xr : yr;\n\t\t\t\tres[k - qry[i].b] = std::min(res[k - qry[i].b], qry[i].a - 1);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 2; i <= k; i++)\n\t\t{\n\t\t\txl[i] = std::max(xl[i], xl[i - 1]);\n\t\t\tyl[i] = std::max(yl[i], yl[i - 1]);\n\t\t}\n\t\tfor (int i = k - 1; i; i--)\n\t\t{\n\t\t\txr[i] = std::min(xr[i], xr[i + 1]);\n\t\t\tyr[i] = std::min(yr[i], yr[i + 1]);\n\t\t}\n\t\tmemset(lst, -1, sizeof(lst));\n\t\ttot = 0;\n\t\tfor (int i = 1; i <= k; i++)\n\t\t{\n\t\t\tadd_edge(0, i, 1, 0);\n\t\t\tadd_edge(k + i, k * 2 + LIM * 2 + 1, 1, 0);\n\t\t\tfor (int j = xl[i]; j <= xr[i]; j++)\n\t\t\t\tadd_edge(i, k * 2 + j, 1, 0);\n\t\t\tfor (int j = yl[i]; j <= yr[i]; j++)\n\t\t\t\tadd_edge(k * 2 + LIM + j, k + i, 1, 0);\n\t\t}\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tadd_edge(k * 2 + arr[i].x, k * 2 + LIM + arr[i].y, 1, -arr[i].w);\n\t\tans = std::max(ans, -min_cost_max_flow(0, k * 2 + LIM * 2 + 1));\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef long long ll;\nconst int N = 100 , M = 400 , V = N + M << 1 , E = N + N * M * 2 + M * 2 , INF = 0x3f3f3f3f;\nint n,m,x[N],y[N],a[N],b[N],u[N],d[N],l[N],r[N]; char op[N];\nint t(1),Head[V],vis[V],S,T; deque <int> q; ll Delta,dis[V],v[N],Ans;\nstruct Edge { int u,v,next,val; ll cos; } e[E*2];\ntemplate<class T> inline T Read(void)\n{\n    T x = 0; bool w = 0; char ch = ' ';\n    while ( !isdigit(ch) ) w |= ch == '-' , ch = getchar();\n    while ( isdigit(ch) ) x = x * 10 + ch - 48 , ch = getchar();\n    return w ? -x : x;\n}\ninline void Input(void)\n{\n    n = Read<int>();\n    for (int i = 1; i <= n; i++)\n        x[i] = Read<int>() , y[i] = Read<int>() , v[i] = Read<ll>();\n    m = Read<int>();\n    for (int i = 1; i <= m; i++)\n    {\n        char c = ' ';\n        while ( isspace(c) ) c = getchar();\n        op[i] = c , a[i] = Read<int>() , b[i] = Read<int>();\n    }\n}\ninline void Insert(int x,int y,ll c,int v)\n{\n    e[++t] = (Edge){ x , y , Head[x] , v , c } , Head[x] = t;\n    e[++t] = (Edge){ y , x , Head[y] , 0 , -c } , Head[y] = t;\n}\ninline void Build(int k)\n{\n    for (int i = 1; i <= k; i++)\n        u[i] = r[i] = INF , l[i] = d[i] = 0;\n    for (int i = 1; i <= m; i++)\n        if ( b[i] < k )\n        {\n            if ( op[i] == 'L' ) l[b[i]+1] = max( l[b[i]+1] , a[i] + 1 );\n            if ( op[i] == 'R' ) r[k-b[i]] = min( r[k-b[i]] , a[i] - 1 );\n            if ( op[i] == 'D' ) d[b[i]+1] = max( d[b[i]+1] , a[i] + 1 );\n            if ( op[i] == 'U' ) u[k-b[i]] = min( u[k-b[i]] , a[i] - 1 );\n            // if ( op[i] == 'L' ) l[b[i]+1] = a[i] + 1;\n            // if ( op[i] == 'R' ) r[k-b[i]] = a[i] - 1;\n            // if ( op[i] == 'D' ) d[b[i]+1] = a[i] + 1;\n            // if ( op[i] == 'U' ) u[k-b[i]] = a[i] - 1;\n        }\n    for (int i = 2; i <= k; i++) l[i] = max( l[i] , l[i-1] ) , d[i] = max( d[i] , d[i-1] );\n    for (int i = k-1; i >= 1; i--) r[i] = min( r[i] , r[i+1] ) , u[i] = min( u[i] , u[i+1] );\n    memset( Head , 0 , sizeof Head );\n    S = ( n + k ) << 1 | 1 , T = ( n + k + 1 ) * 2 , t = 1 , Delta = 0;\n    for (int i = 1; i <= n; i++) Insert( i , i+n , v[i] , 1 );\n    for (int i = 1; i <= k; i++)\n    {\n        Insert( S , n*2+i , 0 , 1 ) , Insert( n*2+k+i , T , 0 , 1 );\n        for (int j = 1; j <= n; j++)\n        {\n            if ( l[i] <= x[j] && x[j] <= r[i] ) Insert( n*2+i , j , 0 , 1 );\n            if ( d[i] <= y[j] && y[j] <= u[i] ) Insert( j+n , n*2+k+i , 0 , 1 );\n        }\n    }\n    // printf( \"t = %d\\n\" , t );\n}\ninline bool Relabel(void)\n{\n    memset( dis , 0xcf , sizeof dis );\n    memset( vis , 0x00 , sizeof vis );\n    dis[T] = 0 , vis[T] = 1 , q.push_back(T);\n    while ( !q.empty() )\n    {\n        // puts(\"SPFAing\");\n        int x = q.front(); q.pop_front() , vis[x] = 0;\n        if ( q.size() > 1 && dis[q.front()] < dis[q.back()] )\n            swap( q.front() , q.back() );\n        for (int i = Head[x] , y; i; i = e[i].next)\n            if ( e[i^1].val && dis[ y = e[i].v ] < dis[x] + e[i^1].cos )\n            {\n                dis[y] = dis[x] + e[i^1].cos;\n                // printf( \"dis[%d] = %lld\\n\" , y , dis[y] );\n                if ( vis[y] ) continue;\n                vis[y] = true , q.push_back(y);\n                if ( q.size() > 1 && dis[q.front()] < dis[q.back()] )\n                    swap( q.front() , q.back() );\n            }\n    }\n    // printf( \"d[%d] = %lld\\n\" , S , dis[S] );\n    return dis[S] != dis[0];\n}\ninline int Dinic(int x,int flow)\n{\n    if ( x == T || !flow ) return flow;\n    int residue = flow; vis[x] = true;\n    for (int i = Head[x] , y; i; i = e[i].next)\n        if ( e[i].val && !vis[ y = e[i].v ] && !e[i].cos )\n        {\n            int k = Dinic( y , min( e[i].val , residue ) );\n            e[i].val -= k , e[i^1].val += k;\n            if ( ( residue -= k ) == 0 ) break;\n        }\n    return flow - residue;\n}\ninline pair<int,ll> PrimalDual(void)\n{\n    int Maxflow = 0 , Flow = 0; ll Maxcost = 0;\n    while ( Relabel() )\n    {\n        for (int i = 2; i <= t; i++)\n            e[i].cos += dis[e[i].v] - dis[e[i].u];\n        Delta += dis[S] , memset( vis , 0 , sizeof vis );\n        // printf( \"Delta = %lld\\n\" , Delta );\n        while ( Flow = Dinic( S , INF ) )\n            Maxflow += Flow , Maxcost += 1LL * Flow * Delta ,\n            memset( vis , 0 , sizeof vis ) /*, printf( \"Dinicing Flow = %d\\n\" , Flow ) */;\n    }\n    return make_pair( Maxflow , Maxcost );\n}\nsigned main(void)\n{\n    Input();\n    for (int i = 1; i <= n; i++)\n        Build(i) , Ans = max( Ans , PrimalDual().second );\n    printf( \"%lld\\n\" , Ans );\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace __gnu_pbds;\nusing namespace std;\n \ntemplate <typename T>\nusing ordered_set =\n\ttree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n \n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n\t*this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n \n#define shandom_ruffle random_shuffle\n \nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=327;\nusing bn=bitset<87>;\n\nint n;\npii gdz[nax];\nll war[nax];\n\nint m;\nbn podz[nax];\nint ile[nax];\n\nll wyn;\n\nbn ter;\n\nll dajwar()\n{\n\tll ret=0;\n\tfor (int i=1; i<=n; i++)\n\t\tif (ter[i])\n\t\t\tret+=war[i];\n\treturn ret;\n}\n\nint popr()\n{\n\tfor (int i=1; i<=m; i++)\n\t\tif ((podz[i]&ter).count()>ile[i])\n\t\t\treturn 0;\n\treturn 1;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(\"%d%d%lld\", &gdz[i].first, &gdz[i].second, &war[i]);\n\tscanf(\"%d\", &m);\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\tchar c;\n\t\tint a, b;\n\t\tscanf(\" %c%d%d\", &c, &a, &b);\n\t\tfor (int j=1; j<=n; j++)\n\t\t{\n\t\t\tif (c=='L' && gdz[j].first<=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='R' && gdz[j].first>=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='D' && gdz[j].second<=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='U' && gdz[j].second>=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t}\n\t\tile[i]=b;\n\t}\n\tll sta=0;\n\tconst int czes=5e5;\n\tconst int res=7e4;\n\tfor (int h=0; h%czes || (clock()<=4.5*CLOCKS_PER_SEC); h++)\n\t{\n\t\tif (!(rand()%res))\n\t\t{\n\t\t\tter.reset();\n\t\t\tvi kol(n);\n\t\t\tiota(kol.begin(), kol.end(), 1);\n\t\t\tshandom_ruffle(kol.begin(), kol.end());\n\t\t\tfor (int i : kol)\n\t\t\t{\n\t\t\t\tter[i]=1;\n\t\t\t\tif (!popr())\n\t\t\t\t\tter[i]=0;\n\t\t\t}\n\t\t\tsta=dajwar();\n\t\t\twyn=max(wyn, sta);\n\t\t}\n\t\tbn pam=ter;\n\t\tint r=rand()%2+1;\n\t\tfor (int i=0; i<r; i++)\n\t\t\tter.flip(rand()%n+1);\n\t\tif (!popr())\n\t\t{\n\t\t\tter=pam;\n\t\t\tcontinue;\n\t\t}\n\t\tll now=dajwar();\n\t\tif (now>=sta || !(rand()%500))\n\t\t{\n\t\t\tsta=now;\n\t\t\twyn=max(wyn, now);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tter=pam;\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\\n\", wyn);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\nconst int INF(0X3F3F3F3F);\ntypedef long long int LL;\n\nnamespace G\n{\n\tconst int Max_V(85 * 2);\n\tconst int Max_E(85 * 30);\n\tint V, S, T, Head[Max_V], Total, To[Max_E], Next[Max_E], Cap[Max_E], Flow[Max_E];\n\tLL Weight[Max_E];\n\tvoid clear()\n\t{\n\t\tfor (int i = 1;i <= V;++i)\n\t\t\tHead[i] = 0;\n\t\tfor (int i = 2;i <= Total + 1;++i)\n\t\t\tTo[i] = Next[i] = Cap[i] = Flow[i] = Weight[i] = 0;\n\t\tV = S = T = Total = 0;\n\t}\n\tinline void Add_Edge(int tot, int s, int t, int c, LL w)\n\t{\n\t\tTo[tot] = t, Next[tot] = Head[s], Head[s] = tot, Cap[tot] = c, Flow[tot] = 0, Weight[tot] = w;\n\t}\n\tinline void Add_Link(int s, int t, int c, LL w)\n\t{\n\t\tTotal += 2, Add_Edge(Total, s, t, c, w), Add_Edge(Total ^ 1, t, s, 0, -w);\n\t}\n\tLL Dist[Max_V];\n\tbool InQ[Max_V], done[Max_V];\n\tbool SPFA()\n\t{\n\t\tqueue<int> Q;\n\t\tmemset(Dist, -0X3F, sizeof(Dist)), Dist[S] = 0LL;\n\t\tmemset(done, false, sizeof(done)), Q.push(S), InQ[S] = true;\n\t\tfor (int u;Q.empty() == false;)\n\t\t{\n\t\t\tu = Q.front(), Q.pop(), InQ[u] = false, done[u] = true;\n\t\t\tfor (int i = Head[u], v;i;i = Next[i])\n\t\t\t\tif (Cap[i] > Flow[i] && Dist[v = To[i]] < Dist[u] + Weight[i])\n\t\t\t\t{\n\t\t\t\t\tDist[v] = Dist[u] + Weight[i];\n\t\t\t\t\tif (!InQ[v])\n\t\t\t\t\t\tQ.push(v), InQ[v] = true;\n\t\t\t\t}\n\t\t}\n\t\treturn done[T];\n\t}\n\tint Cur[Max_V];\n\tint DFS(int u, int a)\n\t{\n\t\tif (u == T || a == 0)\n\t\t\treturn a;\n\t\tint Ans(0);\n\t\tdone[u] = true;\n\t\tfor (int &i = Cur[u], v, f;i;i = Next[i])\n\t\t\tif (Dist[v = To[i]] == Dist[u] + Weight[i] && !done[v] && (f = DFS(v, min(a, Cap[i] - Flow[i]))) > 0)\n\t\t\t{\n\t\t\t\tAns += f, Flow[i] += f, Flow[i ^ 1] -= f;\n\t\t\t\tif ((a -= f) == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\tdone[u] = false;\n\t\treturn Ans;\n\t}\n\tvoid MCMF(int &FLOW, LL &COST)\n\t{\n\t\tfor (int f;SPFA();)\n\t\t{\n\t\t\tfor (int i = 1;i <= V;++i)\n\t\t\t\tCur[i] = Head[i], done[i] = false;\n\t\t\tFLOW -= (f = DFS(S, INF)), COST += Dist[T] * f;\n\t\t}\n\t}\n}\n\nconst int Max_N(85);\nconst int Max_M(325);\n\nint N, X[Max_N], Y[Max_N], PX[Max_N], PY[Max_N], XL[Max_N], XR[Max_N], YL[Max_N], YR[Max_N], M, T[Max_M], A[Max_M], B[Max_M];\nLL V[Max_N], Ans;\n\ninline bool comp_X(int a, int b)\n{\n\treturn X[a] < X[b];\n}\n\ninline bool comp_Y(int a, int b)\n{\n\treturn Y[a] < Y[b];\n}\n\n/*\n枚举选的宝石总数Sum，那么可以变成对于每个前缀选的宝石数量都有一个区间的限制。在X轴和Y轴上分别可以列出方程\nX轴的方程组： \n0 = 0\nX[1] = XV[1]\nX[1] + X[2] = XV[2]\n...\nX[1] + X[2] + ... + X[N] = Sum\nY轴的方程组： \n0 = 0\nY[1] = YV[1]\nY[1] + Y[2] = YV[2]\n...\nY[1] + Y[2] + ... + Y[N] = Sum\n对于每个XV[i]，有XL[i] <= XV[i] <= XR[i]的限制；对于每个YV[i]，有YL[i] <= YV[i] <= YR[i]的限制\n对于每个轴的方程组，两两差分。那么每个XV和YV出现了恰好两次，系数分别是+1和-1。每个X和Y出现了恰好一次\n那么对于点(x, y)，X[x]和Y[y]是同一个变量。所以这些变量可以看做出现了恰好两次，系数分别是+1和-1\n然后用流量平衡建图，可以得到一个最大费用可行流问题 \n*/\nint main()\n{\n\tscanf(\"%d\", &N);\n\tfor (int i = 1;i <= N;++i)\n\t\tscanf(\"%d%d%lld\", X + i, Y + i, V + i), PX[i] = PY[i] = i;\n\tsort(PX + 1, PX + 1 + N, comp_X), sort(PY + 1, PY + 1 + N, comp_Y);\n\tscanf(\"%d\", &M);\n\tfor (int i = 1;i <= M;++i)\n\t{\n\t\tchar op[10];\n\t\tscanf(\"%s%d%d\", op, A + i, B + i);\n\t\tif (*op == 'L')\n\t\t\tT[i] = 1;\n\t\tif (*op == 'R')\n\t\t\tT[i] = 2;\n\t\tif (*op == 'D')\n\t\t\tT[i] = 3;\n\t\tif (*op == 'U')\n\t\t\tT[i] = 4;\n\t}\n\tfor (int Sum = 1;Sum <= N;++Sum)\n\t{\n\t\tXL[0] = YL[0] = XR[0] = YR[0] = 0;\n\t\tfor (int i = 1;i <= N - 1;++i)\n\t\t\tXL[i] = YL[i] = 0, XR[i] = YR[i] = Sum;\n\t\tXL[N] = YL[N] = XR[N] = YR[N] = Sum;\n\t\tfor (int i = 1;i <= M;++i)\n\t\t{\n\t\t\tif (T[i] == 1)\n\t\t\t\tif (X[PX[1]] <= A[i])\n\t\t\t\t\tfor (int j = 1;j <= N;++j)\n\t\t\t\t\t\tif (j == N || X[PX[j + 1]] > A[i])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tXR[j] = min(XR[j], B[i]);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\tif (T[i] == 2)\n\t\t\t\tif (A[i] <= X[PX[N]])\n\t\t\t\t\tfor (int j = N - 1;j >= 0;--j)\n\t\t\t\t\t\tif (j == 0 || A[i] > X[PX[j]])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tXL[j] = max(XL[j], Sum - B[i]);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\tif (T[i] == 3)\n\t\t\t\tif (Y[PY[1]] <= A[i])\n\t\t\t\t\tfor (int j = 1;j <= N;++j)\n\t\t\t\t\t\tif (j == N || Y[PY[j + 1]] > A[i])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tYR[j] = min(YR[j], B[i]);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\tif (T[i] == 4)\n\t\t\t\tif (A[i] <= Y[PY[N]])\n\t\t\t\t\tfor (int j = N - 1;j >= 0;--j)\n\t\t\t\t\t\tif (j == 0 || A[i] > Y[PY[j]])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tYL[j] = max(YL[j], Sum - B[i]);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t}\n\t\tfor (int i = 0;i <= N;++i)\n\t\t\tif (XL[i] > XR[i] || YL[i] > YR[i])\n\t\t\t\tgoto loop;\n\t\tint FLOW(0);\n\t\tLL COST(0LL);\n\t\tG::clear(), G::V = N + N + 2, G::S = N + N + 1, G::T = N + N + 2;\n\t\tfor (int i = 1, x, y;i <= N;++i)\n\t\t{\n\t\t\tfor (x = 1;x <= N;++x)\n\t\t\t\tif (PX[x] == i)\n\t\t\t\t\tbreak;\n\t\t\tfor (y = 1;y <= N;++y)\n\t\t\t\tif (PY[y] == i)\n\t\t\t\t\tbreak;\n\t\t\tCOST += V[i], ++FLOW, G::Add_Link(G::S, x, 1, 0LL), G::Add_Link(N + y, G::T, 1, 0LL);\n\t\t\tG::Add_Link(x, N + y, 1, -V[i]);\n\t\t}\n\t\tfor (int i = 1;i <= N - 1;++i)\n\t\t{\n\t\t\tif (XL[i])\n\t\t\t\tG::Add_Link(G::S, i + 1, XL[i], 0LL), G::Add_Link(i, G::T, XL[i], 0LL), FLOW += XL[i];\n\t\t\tif (XR[i] - XL[i])\n\t\t\t\tG::Add_Link(i, i + 1, XR[i] - XL[i], 0LL);\n\t\t}\n\t\tfor (int i = 1;i <= N - 1;++i)\n\t\t{\n\t\t\tif (YL[i])\n\t\t\t\tG::Add_Link(G::S, N + i, YL[i], 0LL), G::Add_Link(N + (i + 1), G::T, YL[i], 0LL), FLOW += YL[i];\n\t\t\tif (YR[i] - YL[i])\n\t\t\t\tG::Add_Link(N + (i + 1), N + i, YR[i] - YL[i], 0LL);\n\t\t}\n\t\tFLOW += Sum, G::Add_Link(N, G::T, Sum, 0LL), G::Add_Link(G::S, N + N, Sum, 0LL);\n\t\tG::MCMF(FLOW, COST);\n\t\tif (FLOW)\n\t\t\tgoto loop;\n\t\tAns = max(Ans, COST);\n\t}\n\tloop :\n\tprintf(\"%lld\", Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define CO const\n#define IN inline\ntypedef long long int64;\n\ntemplate<class T> IN T read(){\n\tT x=0,w=1;char c=getchar();\n\tfor(;!isdigit(c);c=getchar())if(c=='-') w=-w;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0';\n\treturn x*w;\n}\ntemplate<class T> IN T read(T&x){\n\treturn x=read<T>();\n}\n\nCO int N=400;\nCO int64 inf=1e18;\nnamespace flow{\n\tint n,S,T;\n\tstruct edge {int v,c;int64 w;int a;};\n\tvector<edge> to[N];\n\tint64 dis[N];int vis[N];\n\n\tIN void init(int n){\n\t\tflow::n=n,S=n-1,T=n;\n\t\tfor(int i=1;i<=n;++i) to[i].clear();\n\t}\n\tIN void link(int u,int v,int c,int64 w){\n\t\tto[u].push_back({v,c,w}),to[v].push_back({u,0,-w});\n\t\tto[u].back().a=to[v].size()-1,to[v].back().a=to[u].size()-1;\n\t}\n\tbool bfs(){\n\t\tfill(dis+1,dis+n+1,-inf),dis[T]=0;\n\t\tdeque<int> Q={T};vis[T]=1;\n\t\twhile(Q.size()){\n\t\t\tint u=Q.front();\n\t\t\tQ.pop_front(),vis[u]=0;\n\t\t\tfor(CO edge&e:to[u])if(to[e.v][e.a].c){\n\t\t\t\tif(dis[e.v]<dis[u]-e.w){ // edit 1: -w\n\t\t\t\t\tdis[e.v]=dis[u]-e.w;\n\t\t\t\t\tif(vis[e.v]) continue;\n\t\t\t\t\tif(Q.size() and dis[e.v]>=dis[Q.front()])\n\t\t\t\t\t\tQ.push_front(e.v);\n\t\t\t\t\telse Q.push_back(e.v);\n\t\t\t\t\tvis[e.v]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dis[S]>-inf;\n\t}\n\tint dfs(int u,int lim){\n\t\tif(u==T) return lim;\n\t\tvis[u]=1;\n\t\tint rest=lim;\n\t\tfor(edge&e:to[u])if(!vis[e.v] and e.c and dis[e.v]==dis[u]-e.w){\n\t\t\tint delta=dfs(e.v,min(e.c,rest));\n\t\t\tif(!delta) {dis[e.v]=-inf;continue;}\n\t\t\trest-=delta,e.c-=delta,to[e.v][e.a].c+=delta;\n\t\t\tif(!rest) break;\n\t\t}\n\t\tvis[u]=0;\n\t\treturn lim-rest;\n\t}\n\tint64 main(){\n\t\tint64 ans=0;\n\t\twhile(bfs()) ans+=dfs(S,1e9)*dis[S];\n\t\treturn ans;\n\t}\n}\n\nint n,X[N],Y[N];int64 V[N];\nint m,O[N],A[N],B[N];\nint L[N],R[N],D[N],U[N];\n\nint64 solve(int s){\n\tfill(L+1,L+s+1,0),fill(D+1,D+s+1,0);\n\tfill(R+1,R+s+1,233),fill(U+1,U+s+1,233);\n\tfor(int i=1;i<=m;++i)if(B[i]<s){\n\t\tif(O[i]=='L') L[B[i]+1]=A[i]+1;\n\t\telse if(O[i]=='R') R[s-B[i]]=A[i]-1;\n\t\telse if(O[i]=='D') D[B[i]+1]=A[i]+1;\n\t\telse U[s-B[i]]=A[i]-1;\n\t}\n\tfor(int i=2;i<=s;++i){\n\t\tL[i]=max(L[i],L[i-1]);\n\t\tD[i]=max(D[i],D[i-1]);\n\t}\n\tfor(int i=s-1;i>=1;--i){\n\t\tR[i]=min(R[i],R[i+1]);\n\t\tU[i]=min(U[i],U[i+1]);\n\t}\n\tflow::init(2*n+2*s+2);\n\tfor(int i=1;i<=n;++i) flow::link(i,i+n,1,V[i]);\n\tfor(int i=1;i<=s;++i){\n\t\tflow::link(flow::S,i+2*n,1,0),flow::link(i+2*n+s,flow::T,1,0);\n\t\tfor(int j=1;j<=n;++j){\n\t\t\tif(L[i]<=X[j] and X[j]<=R[i]) flow::link(i+2*n,j,1,0);\n\t\t\tif(D[i]<=Y[j] and Y[j]<=U[i]) flow::link(j+n,i+2*n+s,1,0);\n\t\t}\n\t}\n\treturn flow::main();\n}\nint main(){\n\tread(n);\n\tfor(int i=1;i<=n;++i) read(X[i]),read(Y[i]),read(V[i]);\n\tread(m);\n\tfor(int i=1;i<=m;++i){\n\t\tchar opt[2];scanf(\"%s\",opt);\n\t\tO[i]=opt[0],read(A[i]),read(B[i]);\n\t}\n\tint64 ans=0;\n\tfor(int i=1;i<=n;++i) ans=max(ans,solve(i));\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MV = 815;\nconst int ME = 1200006;\nconst ll oo = 1e18;\n\ntemplate <typename T> void cmin(T &x, const T &y)\n{\n\tif(y < x) x = y;\n}\n\ntemplate <typename T> void cmax(T &x, const T &y)\n{\n\tif(y > x) x = y;\n}\n\ntemplate <typename T> void read(T &x)\n{\n\tx = 0; char c = getchar(); bool f = 0;\n\twhile(!isdigit(c) && c!='-') c = getchar();\n\tif(c == '-') f = 1, c = getchar();\n\twhile(isdigit(c)) x = x*10+c-'0', c = getchar();\n\tif(f) x = -x;\n}\n\nstruct edge\n{\n\tint u, v, f;\n\tll c;\n\tint n;\n\n\tedge (const int &u0 = 0, const int &v0 = 0, const ll &f0 = 0, const ll &c0 = 0, const int &n0 = 0) : u(u0), v(v0), f(f0), c(c0), n(n0) {}\n};\n\nstruct GRAPH\n{\n\tedge e[ME];\n\tint fst[MV], lnum;\n\n\tvoid init() {memset(fst, 0xff, sizeof(fst)); lnum = -1;}\n\t\n\tGRAPH () {init();}\n\t\n\tvoid addeg(int nu, int nv, ll nc, int nf)\n\t{\n\t\te[++lnum] = edge(nu, nv, nf, nc, fst[nu]), fst[nu] = lnum;\n\t\te[++lnum] = edge(nv, nu, 0, -nc, fst[nv]), fst[nv] = lnum;\n\t}\n\t\n\tint que[MV], inq[MV], cur[MV];\n\tll dis[MV];\n\t\n\tbool spfa(int frm, int tar)\n\t{\n\t\tint h = 1, t = 1, x, y;\n\t\tmemset(dis, 0x9f, sizeof(dis));\n\t\tdis[frm] = 0;\n\t\tque[h] = frm;\n\t\tinq[frm] = 1;\n\t\twhile(h >= t)\n\t\t{\n\t\t\tx = que[(t++)%MV];\n\t\t\tinq[x] = 0;\n\t\t\tfor(int i=fst[x]; ~i; i=e[i].n)\n\t\t\t{\n\t\t\t\ty = e[i].v;\n\t\t\t\tif(e[i].f && dis[y]<dis[x]+e[i].c)\n\t\t\t\t{\n\t\t\t\t\tdis[y] = dis[x] + e[i].c;\n\t\t\t\t\tif(!inq[y]) que[(++h)%MV] = y, inq[y] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn (dis[tar] > -oo);\n\t}\n\t\n\tint dinic(int x, int t, int f)\n\t{\n\t\tif(x == t) return f;\n\t\tint a, y, now = 0;\n\t\tinq[x] = 1;\n\t\tfor(int &i=cur[x]; ~i; i=e[i].n)\n\t\t{\n\t\t\ty = e[i].v;\n\t\t\tif(dis[y]==dis[x]+e[i].c && e[i].f && !inq[y])\n\t\t\t{\n\t\t\t\ta = dinic(y, t, min(e[i].f, f-now));\n\t\t\t\tnow += a;\n\t\t\t\te[i].f -= a;\n\t\t\t\te[i^1].f += a;\n\t\t\t\tif(now == f) break;\n\t\t\t}\n\t\t}\n\t\tinq[x] = 0;\n\t\treturn now;\n\t}\n\t\n\tpair<int, ll> costf(int s, int t)\n\t{\n\t\tll cost = 0;\n\t\tint flow = 0;\n\t\twhile(spfa(s, t))\n\t\t{\n\t\t\tmemmove(cur, fst, sizeof(cur));\n\t\t\tint new_flow = dinic(s, t, ME);\n\t\t\tcost += dis[t] * new_flow;\n\t\t\tflow += new_flow;\n\t\t}\n\t\treturn make_pair(flow, cost);\n\t}\n} G;\n\nint n, m;\nint lx[MV], rx[MV];\nint ly[MV], ry[MV];\nint px[MV], py[MV];\nll pv[MV];\nchar qc[MV];\nint qa[MV], qb[MV];\nint global_s, global_t;\n\nvoid input()\n{\n\tread(n);\n\tfor(int i=1; i<=n; i++) read(px[i]), read(py[i]), read(pv[i]);\n\tread(m);\n\tfor(int i=1; i<=n; i++) lx[i] = 1, rx[i] = 100, ly[i] = 1, ry[i] = 100;\n\tfor(int i=1; i<=m; i++)\n\t{\n\t\tqc[i] = getchar();\n\t\twhile(!isalpha(qc[i])) qc[i] = getchar();\n\t\tread(qa[i]), read(qb[i]);\n\t}\n}\n\nvoid build(int num)\n{\n\tfor(int i=0; i<=num+1; i++) lx[i] = ly[i] = 1, rx[i] = ry[i] = 100;\n\tfor(int i=1; i<=m; i++)\n\t{\n\t\tif(qb[i] > num) continue;\n\t\tif(qc[i] == 'L') cmax(lx[qb[i]+1], qa[i]+1);\n\t\tif(qc[i] == 'R') cmin(rx[num-qb[i]], qa[i]-1);\n\t\tif(qc[i] == 'D') cmax(ly[qb[i]+1], qa[i]+1);\n\t\tif(qc[i] == 'U') cmin(ry[num-qb[i]], qa[i]-1);\n\t}\n\tfor(int i=1; i<=num; i++) cmax(lx[i], lx[i-1]), cmax(ly[i], ly[i-1]);\n\tfor(int i=num; i>=1; i--) cmin(rx[i], rx[i+1]), cmin(ry[i], ry[i+1]);\n\tG.init();\n\tfor(int i=1; i<=num; i++)\n\t{\n\t\tfor(int j=1; j<=n; j++)\n\t\t{\n\t\t\tif(lx[i]<=px[j] && px[j]<=rx[i]) G.addeg(i, num*2+j, 0, 1);\n\t\t\tif(ly[i]<=py[j] && py[j]<=ry[i]) G.addeg(num*2+n+j, num+i, 0, 1);\n\t\t}\n\t}\n\tfor(int i=1; i<=n; i++) G.addeg(num*2+i, num*2+n+i, pv[i], 1);\n\tglobal_s = num*2+n*2+1, global_t = global_s+1;\n\tfor(int i=1; i<=num; i++) G.addeg(global_s, i, 0, 1), G.addeg(num+i, global_t, 0, 1);\n}\n\nvoid work()\n{\n\tll ans = 0;\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tbuild(i);\n\t\tauto ret = G.costf(global_s, global_t);\n\t\tif(ret.first != i) break;\n\t\telse cmax(ans, ret.second);\n\t}\n\tprintf(\"%lld\\n\", ans);\n}\n\nint main()\n{\n\tinput();\n\twork();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nll modinv(ll a, ll m) {\n\tassert(m > 0);\n\tif (m == 1) return 0;\n\ta %= m;\n\tif (a < 0) a += m;\n\tassert(a != 0);\n\tif (a == 1) return 1;\n\treturn m - modinv(m, a) * m / a;\n}\n\nint main(){\n\tint n, m, q;\n\tcin >> n >> m >> q;\n\tll mod;\n\tcin >> mod;\n\tvector<vector<pair<int,ll>>> edges(n);\n\tint make3 = 0;\n\tif(mod % 3 != 0){\n\t\tmake3 = 1;\n\t\tmod *= 3;\n\t}\n\tll L = 0;\n\tfor(int i = 0; i < m; i++){\n\t\tint a, b;\n\t\tll c;\n\t\tcin >> a >> b >> c;\n\t\tif(make3) c *= 3;\n\t\ta--; b--;\n\t\tedges[a].push_back({b, c});\n\t\tedges[b].push_back({a, c});\n\t\tif(i == 0) L = c;\n\t\tmod = __gcd(abs(3 * (c - L)), mod);\n\t}\n\tL %= mod;\n\tfor(int i = 0; i < n; i++){\n\t\tfor(auto& e : edges[i]){\n\t\t\te.second = e.second % mod;\n\t\t\tassert((e.second - L) * 3 % mod == 0);\n\t\t\t//e.second = (e.second - L + mod) % mod;\n\t\t\t//assert(e.second * 3 % mod == 0);\n\t\t}\n\t}\n\tvector<pair<int,int> > from0(n, {-1, -1});\n\tvector<pair<int,int> > to0(n, {-1, -1});\n\tfrom0[0] = to0[0] = {1, 0};\n\tvector<int> bfs = {0};\n\tint _s = 0;\n\twhile(_s < int(bfs.size())){\n\t\tint a = bfs[_s]; _s++;\n\t\tfor(auto e : edges[a]){\n\t\t\tint v = e.first;\n\t\t\tif(from0[v].first == -1){\n\t\t\t\tbfs.push_back(v);\n\t\t\t\tfrom0[v] = {2 * from0[a].first % mod, (2 * from0[a].second + e.second) % mod};\n\t\t\t\tto0[v] = {2 * to0[a].first % mod, (to0[a].first * e.second + to0[a].second) % mod};\n\t\t\t}\n\t\t}\n\t}\n\tassert(int(bfs.size()) == n);\n\n\tvector<int> dlog(mod, 0);\n\tvector<int> el(mod, -1);\n\tint ord2 = 0;\n\t{\n\t\tll b = 1 % mod;\n\t\tint z = 0;\n\t\twhile(1){\n\t\t\tz++;\n\t\t\tb = (2 * b) % mod;\n\t\t\tif(b % mod == 1 % mod) break;\n\t\t}\n\t\tord2 = z;\n\t}\n\tassert(ord2 % 2 == 0);\n\tfor(int i = 0; i < mod; i++){\n\t\tif(el[i] == -1){\n\t\t\tint z = 0;\n\t\t\tll b = i % mod;\n\t\t\twhile(1){\n\t\t\t\tassert(el[b] == -1);\n\t\t\t\tel[b] = i; dlog[b] = z;\n\t\t\t\tb = (2 * b) % mod;\n\t\t\t\tz++;\n\t\t\t\tif(b == i) break;\n\t\t\t}\n\t\t}\n\t}\n\tvector<vector<vector<int> > > vis(n, vector<vector<int> >(3, vector<int>(3, 0)));\n\tvector<pair<int, pair<int,int> > > g;\n\tg.push_back({0, {1, 0}});\n\tvis[0][1][0] = 1;\n\t_s = 0;\n\n\tll QQQ = mod / 3;\n\twhile(_s < g.size()){\n\t\tint v = g[_s].first;\n\t\tint X = g[_s].second.first;\n\t\tint Y = g[_s].second.second;\n\t\t_s++;\n\t\tfor(auto e : edges[v]){\n\t\t\tll len = (e.second - L + mod) % mod;\n\t\t\t//assert(len % QQQ == 0);\n\t\t\tint newv = e.first;\n\t\t\tint newX = (3-X) % 3;\n\t\t\tint newY = ((len - Y * QQQ + mod) % mod) / QQQ;\n\t\t\t//assert(newX >= 0 && newY >= 0 && newX <= 2 && newY <= 2);\n\t\t\tif(!vis[newv][newX][newY]){\n\t\t\t\tg.push_back({newv, {newX, newY}});\n\t\t\t\tvis[newv][newX][newY] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int _ = 0; _ < q; _++){\n\t\tint s, t; ll r;\n\t\tcin >> s >> t >> r;\n\t\ts--; t--;\n\t\tif(make3) r *= 3;\n\t\tr %= mod;\n\t\tll st = to0[t].second;\n\t\tll en = ((r - from0[s].second) % mod) * modinv(from0[s].first, mod) % mod;\n\t\tif(en < 0) en += mod;\n\t\tst = (st + L) % mod;\n\t\ten = (en + L) % mod;\n\t\tint done = 0;\n\t\tfor(int j = 0; j < 3; j++){\n\t\t\tfor(int k = 0; k < 3; k++){\n\t\t\t\tif(!vis[0][j][k]) continue;\n\t\t\t\tll new_st = (st * j + k * QQQ) % mod;\n\t\t\t\tif(new_st < 0) new_st += mod;\n\t\t\t\tif(el[new_st] == el[en]){\n\t\t\t\t\tint dl = dlog[new_st] - dlog[en];\n\t\t\t\t\tif((dl & 1) == 0){\n\t\t\t\t\t\tdone = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(done){\n\t\t\tcout << \"YES\" << '\\n';\n\t\t} else {\n\t\t\tcout << \"NO\" << '\\n';\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 1000005\nint tot,last[N],to[N],Next[N],flow[N];\nlong long val[N],dis[N];\nint e[N],q[10000005],S,T,Lx[N],Rx[N],Ly[N],Ry[N];\nint X[N],Y[N],n,m,pre[N];\nstruct node {\n  \tint id,x,y;\n}b[N],A[N];\nstruct pa {\n  \tint x;\n  \tlong long y;\n}a[N];\ninline void add(int x,int y,int f,long long v) {\n  Next[++tot]=last[x]; last[x]=tot; to[tot]=y; flow[tot]=f; val[tot]=v;\n}\n#define inf 1000000000000000000ll\ninline bool spfa() {\n  \tfor (int i=S;i<=T;i++) dis[i]=inf,e[i]=0;\n  \tdis[S]=0; e[S]=1;\n  \tint l=0,r=1; q[1]=S;\n  \twhile (l<r) {\n      \tint k=q[++l];\n      \tfor (int i=last[k];i;i=Next[i]) {\n          \tif (!flow[i]||dis[to[i]]<=dis[S]+val[i]) continue;\n          \tdis[to[i]]=dis[S]+val[i];\n          \tpre[to[i]]=i;\n          \tif (!e[to[i]]) e[q[++r]=to[i]]=1;\n        }\n      \te[k]=0;\n    }\n  \treturn dis[T]!=inf;\n}\ninline long long dinic(int y) {\n  \tlong long ans=0;\n  \tint s=0;\n  \twhile (spfa()) {\n      \ts++;\n      \tfor (int x=T;x!=S;x=to[pre[x]^1]) flow[pre[x]]--,flow[pre[x]^1]++,ans+=val[pre[x]];\n    }\n  \tif (s!=y) return 0;\n  \treturn ans;\n}\ninline long long work(int x) {\n  for (int i=1;i<=m;i++) if (b[i].id&1) A[i]=b[i];\n  else A[i]=node{b[i].id,x-b[i].x,b[i].y+1};\n  for (int i=1;i<=x;i++) X[i]=2*n+i,Y[i]=2*n+i+x;\n  S=0,T=Y[x]+1;\n  for (int i=S;i<=T;i++) last[i]=0;\n  tot=1;\n  for (int i=1;i<=x;i++) Lx[i]=Ly[i]=1,Rx[i]=Ry[i]=100;\n  for (int i=1;i<=m;i++) {\n    if (A[i].id==1) Lx[A[i].x+1]=max(Lx[A[i].x+1],A[i].y+1);\n    else if (A[i].id==2) Rx[A[i].x]=min(Rx[A[i].x],A[i].y);\n    else if (A[i].id==3) Ly[A[i].x+1]=max(Ly[A[i].x+1],A[i].y+1);\n    else Ry[A[i].x]=min(Ry[A[i].x],A[i].y);\n  }\n  for (int i=1;i<=x;i++) Lx[i]=max(Lx[i],Lx[i-1]),Ly[i]=max(Ly[i],Ly[i-1]);\n  for (int i=x-1;i;i--) Rx[i]=min(Rx[i],Rx[i+1]),Ry[i]=min(Ry[i],Ry[i+1]);\n  for (int i=1;i<=x;i++) if (Lx[i]>Rx[i]) return false;\n  for (int i=1;i<=x;i++) add(S,X[i],1,0),add(X[i],S,0,0),add(Y[i],T,1,0),add(T,Y[i],0,0);\n  for (int i=1;i<=x;i++) \n  for (int j=1;j<=n;j++) {\n    \tif (a[j].x>=Lx[i]&&a[j].x<=Rx[i]) add(X[i],j,1,0),add(j,X[i],0,0);\n    \tif (a[j].y>=Ly[i]&&a[j].y<=Ry[i]) add(j+n,Y[i],1,0),add(Y[i],j+n,0,0);\n  }\n  for (int i=1;i<=n;i++) add(i,i+n,1,a[i].y),add(i+n,i,0,-a[i].y);\n  return dinic(x);\n}\nchar c[15];\nint main() {\n  scanf(\"%d\",&n);\n  for (int i=1;i<=n;i++) scanf(\"%d%lld\",&a[i].x,&a[i].y);\n  scanf(\"%d\",&m);\n  for (int i=1;i<=m;i++) {\n    \tscanf(\"%s\",c);\n    \tscanf(\"%d%d\",&b[i].x,&b[i].y);\n    \tif (c=='L') b[i].id=1;\n    \tif (c=='R') b[i].id=2;\n    \tif (c=='D') b[i].id=3;\n    \tif (c=='U') b[i].id=4;\n  }\n  long long ans=0;\n  for (int i=1;i<=n;i++) ans=max(ans,work(i));\n  printf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#define M 5010\n#define int long long\n#define clr(X) memset(X, 0, sizeof X)\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int Lim = 105;\n\nint Head[M], Next[M], Go[M], Cost[M], Fl[M], Cnt = 1;\n\nint n, A[M], B[M], C[M], Q, op[M], QA[M], QB[M];\n\nbool vis[M];\n\nint Dis[M], Pr[M], mxF[M];\n\nll nwans = 0, totans = 0; // getmax!\n\n/*struct node {\n    int dis, v;\n    node() {}\n    node(int _1, int _2) {dis = _1, v = _2;}\n    node operator < (const node& X) const {return dis > X.dis;}\n};\n\npriority_queue <node> Q;*/\n\nvoid SPFA(int S) {\n    memset(Dis, 63, sizeof Dis), clr(Pr), clr(mxF), clr(vis), mxF[S] = 1e9;\n    Dis[S] = 0;\n    vector <int> V(1, S);\n    for(int i = 0; i < V.size(); i++) {\n        int x = V[i], ds = Dis[x];\n        vis[x] = 0;\n        for(int T = Head[x]; T; T = Next[T])\n            if(Fl[T] && Dis[Go[T]] > ds + Cost[T]) {\n                Dis[Go[T]] = ds + Cost[T];\n                mxF[Go[T]] = min(mxF[x], Fl[T]);\n                Pr[Go[T]] = T ^ 1;\n                if(!vis[Go[T]]) vis[Go[T]] = 1, V.push_back(Go[T]);\n            }\n    }\n}\n\nint MMP(int SS, int TT, int f) {\n    int ans = 0, fl = 0;\n    for(; ;) {\n        SPFA(SS);\n        if(Dis[TT] > 1e18) {\n            if(fl < f) return 0;\n            return ans;\n        }\n        ans += mxF[TT] * Dis[TT], fl += mxF[TT];\n        for(int i = TT; i != SS; i = Go[Pr[i]]) {\n            Fl[Pr[i]] += mxF[TT];\n            Fl[Pr[i] ^ 1] -= mxF[TT];\n        }\n    }\n}\n\nconst int SS = 500, TT = 501;\n\nint Deg[M];\n\nvoid addedge(int a, int b, int f, int c) {\n    Go[++Cnt] = b;\n    Next[Cnt] = Head[a];\n    Head[a] = Cnt;\n    Fl[Cnt] = f;\n    Cost[Cnt] = c;\n}\nvoid dealedge(int a, int b, int lw, int hi, int c) {\n    //nwans += c * lw;\n    addedge(a, b, hi - lw, c);\n    addedge(b, a, 0, -c);\n    Deg[b] += lw;\n    Deg[a] -= lw;\n}\n\nvoid cmax(int &x, int y) {if(x < y) x = y;}\nvoid cmin(int &x, int y) {if(x > y) x = y;}\n\nsigned main() {\n    scanf(\"%lld\", &n);\n    for(int i = 1; i <= n; i++) {\n        scanf(\"%lld%lld%lld\", &A[i], &B[i], &C[i]);\n    }\n    scanf(\"%lld\", &Q);\n    for(int i = 1; i <= Q; i++) {\n        char ch[3];\n        scanf(\"%s\", ch);\n        op[i] = ch[0];\n        scanf(\"%lld%lld\", &QA[i], &QB[i]);\n    }\n    for(int TTT = 0; TTT <= n; TTT++) {\n        clr(Head), Cnt = 1;\n        clr(Deg);\n        dealedge(207, 1, TTT, TTT, 0);\n        int XXMx[111], XXMn[111], YYMx[111], YYMn[111];\n        memset(XXMx, 0, sizeof XXMx);\n        memset(YYMx, 0, sizeof YYMx);\n        memset(XXMn, 1, sizeof XXMn);\n        memset(YYMn, 1, sizeof YYMn);\n        int flag = 1;\n        for(int i = 1; i <= Q; i++) {\n            int o = op[i];\n            if(o == 'R') {\n                cmin(XXMn[QA[i]], QB[i]);\n            } else if(o == 'L') {\n                cmax(XXMx[QA[i] + 1], TTT - QB[i]);\n            } else if(o == 'D') {\n                cmin(YYMn[QA[i]], QB[i]);\n            } else {\n                cmax(YYMx[QA[i] - 1], TTT - QB[i]);\n            }\n        }\n        if(!flag) continue;\n        for(int i = 0; i <= 100; i++){\n            if(XXMx[i + 1] > XXMn[i + 1]) flag = 0;dealedge(i + 2, i + 3, XXMx[i + 1], XXMn[i + 1], 0);}\n        for(int i = 0; i <= 100; i++) {\n            if(YYMx[i] > YYMn[i]) flag = 0;dealedge(104 + i, 105 + i, YYMx[i], YYMn[i], 0);\n        }\n        if(!flag) continue;\n        dealedge(1, 2, 0, 233333, 0);\n        dealedge(205, 207, 0, 233333, 0);\n        for(int i = 1; i <= n; i++)\n            dealedge(1 + A[i], 104 + B[i], 0, 1, -C[i]);\n        for(int i = 1; i <= 207; i++)\n            if(Deg[i] > 0) {\n                addedge(SS, i, Deg[i], 0);\n                addedge(i, SS, 0, 0);\n            } else if(Deg[i] < 0) {\n                addedge(i, TT, -Deg[i], 0);\n                addedge(TT, i, 0, 0);\n            }\n        int tottot = 0;\n        for(int i = 1; i <= 207; i++) if(Deg[i] > 0) tottot += Deg[i];\n        totans = max(totans, -MMP(SS, TT, tottot));\n    }\n    printf(\"%lld\\n\", totans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <list>\n#include <time.h>\n#include <math.h>\n#include <random>\n#include <deque>\n#include <queue>\n#include <cassert>\n#include <unordered_map>\n#include <unordered_set>\n#include <iomanip>\n#include <bitset>\n#include <sstream>\n#include <chrono>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef __float128 dbl;\nconst int INF = 1.01e9;\n\n__float128 fabs(__float128 x)\n{\n  if (x < 0) return -x;\n  return x;\n}\n \nconst __float128 EPS = 1e-25;\nbool eq(__float128 x, __float128 y) {\n    return fabs(x - y) < EPS;\n}\nbool ls(__float128 x, __float128 y) {\n    return x < y && !eq(x, y);\n}\n \nvector<__float128> simplex(vector<vector<__float128> > a) {\n    int n = a.size() - 1;\n    int m = a[0].size() - 1;\n    vector<int> left(n + 1), up(m + 1);\n    iota(up.begin(), up.end(), 0);\n    iota(left.begin(), left.end(), m);\n    auto pivot = [&](int x, int y) {\n        swap(left[x], up[y]);\n        __float128 k = a[x][y];\n        a[x][y] = 1;\n        vector<int> vct;\n        for (int j = 0; j <= m; j++) {\n            a[x][j] /= k;\n            if (!eq(a[x][j], 0)) vct.push_back(j);\n        }\n        for (int i = 0; i <= n; i++) {\n            if (eq(a[i][y], 0) || i == x) continue;\n            k = a[i][y];\n            a[i][y] = 0;\n            for (int j : vct) a[i][j] -= k * a[x][j];\n        }\n    };\n    while (1) {\n        int x = -1;\n        for (int i = 1; i <= n; i++) if (ls(a[i][0], 0) && (x == -1 || a[i][0] < a[x][0])) x = i;\n        if (x == -1) break;\n        int y = -1;\n        for (int j = 1; j <= m; j++) if (ls(a[x][j], 0) && (y == -1 || a[x][j] < a[x][y])) y = j;\n        if (y == -1) assert(0); // infeasible\n        pivot(x, y);\n    }\n    while (1) {\n        int y = -1;\n        for (int j = 1; j <= m; j++) if (ls(0, a[0][j]) && (y == -1 || a[0][j] > a[0][y])) y = j;\n        if (y == -1) break;\n        int x = -1;\n        for (int i = 1; i <= n; i++) if (ls(0, a[i][y]) && (x == -1 || a[i][0] / a[i][y] < a[x][0] / a[x][y])) x = i;\n        if (x == -1) assert(0); // unbounded\n        pivot(x, y);\n    }\n    vector<__float128> ans(m + 1);\n    for (int i = 1; i <= n; i++) if (left[i] <= m) ans[left[i]] = a[i][0];\n    ans[0] = -a[0][0];\n    return ans;\n}\n\n#ifdef ONPC\n  mt19937 rnd(228);\n#else\n  mt19937 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\n#endif\n\nint main()\n{\n#ifdef ONPC\n  freopen(\"a.in\", \"r\", stdin);\n#endif\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector <int> x(n), y(n);\n  vector <ll> ok;\n  vector <__float128> v;\n  vector <pair <ll, int> > e;\n  for (int i = 0; i < n; i++)\n  {\n    cin >> x[i] >> y[i];\n    ll x;\n    cin >> x;\n    ok.push_back(x);\n    v.push_back(x);\n    e.push_back({x, i});\n  }\n  v.insert(v.begin(), 0);\n  int m;\n  cin >> m;\n  vector <vector <__float128> > mat;\n  mat.push_back(v);\n  for (int i = 0; i < n; i++)\n  {\n    vector <__float128> kek(n + 1);\n    kek[0] = kek[i + 1] = 1;\n    mat.push_back(kek);\n  }\n  vector <vector <int> > simp;\n  for (int i = 0; i < m; i++)\n  {\n    char c;\n    cin >> c;\n    int a;\n    int b;\n    cin >> a >> b;\n    vector <__float128> arr = {(__float128) b};\n    vector <int> kek = {b};\n    for (int j = 0; j < n; j++)\n    {\n      int grab = 0;\n      if (c == 'L' && x[j] <= a) grab = 1;\n      if (c == 'R' && x[j] >= a) grab = 1;\n      if (c == 'D' && y[j] <= a) grab = 1;\n      if (c == 'U' && y[j] >= a) grab = 1;\n      arr.push_back(grab);\n      kek.push_back(grab);\n    }\n    mat.push_back(arr);\n    simp.push_back(kek);\n  }\n  auto good = [&] (vector <int> grab)\n  {\n    for (auto c : simp)\n    {\n      int sum = 0;\n      for (int i = 1; i <= n; i++) sum += grab[i - 1] * c[i];\n      if (sum > c[0])\n      {\n        return false;\n      }\n    }\n    return true;\n  };\n  auto f = [&] (vector <int> grab)\n  {\n    ll sum = 0;\n    for (int i = 0; i < n; i++)\n    {\n      if (grab[i]) sum += ok[i];\n    }\n    return sum;\n  };\n  vector <int> grab;\n  for (int i = 0; i < n; i++) grab.push_back(0);\n  cout.precision(20);\n  auto solve = [&] ()\n  {\n    auto ret = simplex(mat);\n    sort(e.begin(), e.end());\n    vector <int> me(n);\n    int x = -1;\n    for (int i = 1; i <= n; i++)\n    {\n      if (grab[i - 1]) continue;\n      grab[i - 1] = true;\n      if (!good(grab))\n      {\n        grab[i - 1] = false;\n        continue;\n      }\n      grab[i - 1] = false;\n      if (x == -1 || ret[i] > ret[x])\n      {\n        x = i;\n      }\n    }\n    if (x == -1 || ret[x] < EPS) return 0ll;\n    x--;\n    me[x] = true;\n    grab[x] = true;\n    if (!good(grab)) grab[x] = false, me[x] = false;\n    int kekos = 0;\n    for (auto &c : mat)\n    {\n      kekos++;\n      if (kekos > n + 1)\n      for (int i = 1; i <= n; i++)\n      {\n        if (me[i - 1] && c[i] > EPS) c[i]--, c[0]--;\n      }\n    }\n    for (int i = 1; i <= n; i++)\n    {\n      if (me[i - 1])\n      {\n        mat[i][0] = 0;\n      }\n    }\n    return ok[x];\n  };\n  ll ans = 0;\n  while (ll t = solve())\n  {\n    ans += t;\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n#define LL long long\n#define fgx cerr<<\"--------------\"<<endl;\n#define dgx cerr<<\"==============\"<<endl;\n\ninline LL read(){\n\tLL x=0,f=1; char c=getchar();\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0';\n\treturn x*f;\n}\nconst LL MAXN = 500010;\nconst LL INF = 1e17;\n\nLL N; LL d[2][MAXN+1],V[MAXN+1];\nLL Cost[MAXN+1]; LL Node[MAXN+1],Next[MAXN+1],C[MAXN+1],Root[MAXN+1];\nLL cnt; LL S,T;\ninline void addedge(LL u,LL v,LL c,LL w){ Cost[cnt]=w; C[cnt]=c; Node[cnt]=v; Next[cnt]=Root[u]; Root[u]=cnt++; }\ninline void insert(LL u,LL v,LL c,LL w){ w=-w; addedge(u,v,c,w); addedge(v,u,0,-w); return ; }\nLL dis[MAXN+1]; bool inq[MAXN+1];\nLL ans,ret;\ninline bool BFS(){\n\tdeque<LL> que; for(LL i=0;i<=T;i++) dis[i]=INF,inq[i]=0;\n\tdis[T]=0; que.push_back(T); inq[T]=true;\n\tint td=0;\n\twhile(!que.empty()){\n\t    LL k=que.front(); que.pop_front(); ++td;\n\t\tfor(LL x=Root[k];x!=-1;x=Next[x]){\n\t\t    LL v=Node[x];\n\t\t    if(C[x^1]>0&&dis[v]>dis[k]-Cost[x]){\n\t\t        dis[v]=dis[k]-Cost[x];\n\t\t\t\tif(!inq[v]){\n\t\t\t\t\tinq[v]=true;\n\t\t\t\t    if(que.empty()||dis[v]<=dis[que.front()]) que.push_front(v);\n\t\t\t\t    else que.push_back(v);\n\t\t\t    }\n\t\t    }\n\t    }inq[k]=false;\n\t}  return dis[S]<INF;\n} LL fans;\ninline LL DFS(LL k,LL t){\n    if(k==T) {inq[k]=1;return t;} \n\tinq[k]=1; LL res=0;\n\tfor(LL x=Root[k];x!=-1;x=Next[x]){\n\t    LL v=Node[x];\n\t    if(C[x]>0&&!inq[v]&&dis[v]==dis[k]-Cost[x]){\n\t        LL tmp=DFS(v,min(t,C[x]));\n\t\t\tif(!tmp) continue; C[x]-=tmp; C[x^1]+=tmp;\n\t\t\tres+=tmp; t-=tmp; fans+=(LL)tmp*Cost[x]; if(!t) return res;\t\n\t    }\n    } return res;\n}\n#define fr first\n#define sc second\ninline void Max(LL &a,LL b){ a=max(a,b); }\ninline void Min(LL &a,LL b){ a=min(a,b); }\nLL L[2][MAXN+1],R[2][MAXN+1];\nLL M; char ch[5];\nvector<pair<LL,LL> > vec[4];\nint sta[MAXN+1],sta2[MAXN+1],sta3[MAXN+1];\ninline void check(LL K){\n\tfor(LL i=0;i<=K+1;i++) L[0][i]=L[1][i]=1,R[0][i]=R[1][i]=100; cnt=0;\n\tfor(LL i=0;i<=N*2+2*K+1;i++) Root[i]=-1;\n\tfor(LL i=0,l=vec[0].size();i<l;i++) Max(L[0][vec[0][i].fr+1],vec[0][i].sc+1);\n\tfor(LL i=0,l=vec[1].size();i<l;i++) if(vec[1][i].fr<K) Min(R[0][K-vec[1][i].fr],vec[1][i].sc-1);\n\tfor(LL i=0,l=vec[2].size();i<l;i++) Max(L[1][vec[2][i].fr+1],vec[2][i].sc+1);\n\tfor(LL i=0,l=vec[3].size();i<l;i++) if(vec[3][i].fr<K) Min(R[1][K-vec[3][i].fr],vec[3][i].sc-1);\n\tS=0,T=N*2+K*2+1; int top=0,top2=0,top3=0;\n\tfor(LL i=1;i<=N;i++) insert(i,N+i,1,V[i]),sta[++top]=cnt-2;\n\tfor(LL i=0;i<2;i++){\n\t\tfor(LL j=1;j<=K;j++) L[i][j]=max(L[i][j],L[i][j-1]);\n\t\tfor(LL j=K-1;j>=0;j--) R[i][j]=min(R[i][j],R[i][j+1]);\n\t\tfor(LL j=1;j<=K;j++){\n\t\t\tif(!i) insert(S,N*2+j,1,0),sta2[++top2]=cnt-2;\n\t\t\telse insert(N*2+K+j,T,1,0),sta3[++top3]=cnt-2;\n\t\t\t\n\t\t\t\t\t//if(K==5&&!i) cout<<\"gg:\"<<L[i][j]<<\" \"<<R[i][j]<<endl;\n\t\t\tfor(LL k=1;k<=N;k++){\n\t\t\t\tif(d[i][k]>=L[i][j]&&d[i][k]<=R[i][j]){\n\t\t\t\t\tif(K==5&&!i&&j==5) cout<<k<<endl;\n\t\t\t\t\tif(!i) insert(N*2+j,k,1,0);\n\t\t\t\t\telse insert(N+k,N*2+K+j,1,0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} fans=0;\n\tret=0; while(BFS()) ret+=DFS(S,INF);\n\tans=max(ans,-fans); //cout<<-fans<<\" \"<<ret<<\" \"<<K<<endl;\n\t//for(int i=1;i<=top;i++) cout<<C[sta[i]]<<\" \"; cout<<endl; for(int i=1;i<=top2;i++) cout<<C[sta2[i]]<<\" \"; cout<<endl;for(int i=1;i<=top3;i++) cout<<C[sta3[i]]<<\" \"; cout<<endl; \n\t return ; \n}\n\nint main(){\n\t//freopen(\"a.in\",\"r\",stdin);\n\t//freopen(\"a2.out\",\"w\",stdout);\n\tN=read();\n\tmemset(Root,-1,sizeof(Root));\n\tfor(LL i=1;i<=N;i++){\n\t\td[0][i]=read(),d[1][i]=read(),V[i]=read();\n\t} M=read();\n\tfor(LL i=1;i<=M;i++){\n\t\tscanf(\"%s\",ch+1); LL a=read(),b=read();\n\t\tLL opr; if(ch[1]=='L') opr=0;\n\t\telse if(ch[1]=='R') opr=1;\n\t\telse if(ch[1]=='U') opr=3;\n\t\telse opr=2; vec[opr].push_back(make_pair(b,a));\n\t}\n\tfor(LL i=0;i<4;i++) sort(vec[i].begin(),vec[i].end());\n\tfor(LL K=1;K<=N;K++) check(K);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<queue>\n#include<climits>\n\ntypedef long long LL;\nconst int maxn = 1e5 + 10, maxm = 4e5 + 10;\nusing namespace std;\n\nLL read()\n{\n\tLL x = 0, f = 1; char c = getchar();\n\twhile(!isdigit(c)) { if(c == '-') f = 0; c = getchar(); }\n\twhile(isdigit(c)) { x = (x << 3) + (x << 1) + (c ^ 48); c = getchar(); }\n\treturn f ? x : -x;\n}\n\nint e, s, t, nxt[maxm], head[maxn], cap[maxm], from[maxm], flow[maxm], to[maxm];\nint inq[maxn], a[maxn], p[maxn];\nLL cost[maxm], d[maxn];\n\nvoid add(int x, int y, int z, LL w)\n{\n\tto[++e] = y; nxt[e] = head[x]; head[x] = e; cap[e] = z; cost[e] = w; from[e] = x;\n\tto[++e] = x; nxt[e] = head[y]; head[y] = e; cap[e] = 0; cost[e] = -w; from[e] = y;\n}\n\nint spfa()\n{\n\tqueue<int> Q;\n\tQ.push(s); inq[s] = 1; a[s] = 0x3f3f3f3f;\n\tfor(int i = 1; i <= t; ++i) d[i] = -LLONG_MAX;\n\td[s] = 0;\n\twhile(!Q.empty())\n\t{\n\t\tint u = Q.front(); Q.pop();\n\t\tinq[u] = 0; \n\t\tfor(int i = head[u]; i; i = nxt[i])\n\t\t{\n\t\t\tint v = to[i];\n\t\t\tif(d[v] < d[u] + cost[i] && cap[i] > flow[i])\n\t\t\t{\n\t\t\t\td[v] = d[u] + cost[i]; p[v] = i; a[v] = min(a[u], cap[i] - flow[i]);\n \t\t\t\tif(!inq[v]) Q.push(v), inq[v] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif(d[t] == -LLONG_MAX) return 0;\n\n\tint u = t;\n\twhile(u != s)\n\t{\n\t\tflow[p[u]] += a[u]; flow[p[u] ^ 1] -= a[u];\n\t\tu = from[p[u]];\n\t}\n\treturn 1;\n}\n\nLL ans;\nvoid gao(int k)\n{\n\tint Flow = 0; LL C = 0;\n\twhile(spfa()) Flow += a[t], C += d[t] * a[t];\n\tif(Flow == k) ans = max(ans, C);\n}\n\nchar S[3];\n#define a zjmtaimei\nint a[maxn], b[maxn], ty[maxn], x[maxn], y[maxn]; LL v[maxn];\nint xz[maxn], hk[maxn];\n\nint main()\n{\n\tint n = read();\n\tfor(int i = 1; i <= n; ++i) x[i] = read(), y[i] = read(), v[i] = read();\n\tint m = read();\n\tfor(int i = 1; i <= m; ++i) \n\t{\n\t\tscanf(\"%s\", S);\n\t\tty[i] = S[0]; a[i] = read(); b[i] = read();\n\t}\n\n\tfor(int k = 1; k <= n; ++k)\n\t{\n\t\tfor(int i = 1; i <= k; ++i) xz[i] = 0, hk[i] = INT_MAX;\n\t\tfor(int i = 1; i <= m; ++i)\n\t\t{\n\t\t\tif(ty[i] == 'L') xz[b[i] + 1] = max(xz[b[i] + 1], a[i] + 1);\n\t\t\tif(k - b[i] > 0 && ty[i] == 'R') hk[k - b[i]] = min(hk[k - b[i]], a[i] - 1);\n\t\t}\n\t\tfor(int i = k - 1; i >= 1; --i) hk[i] = min(hk[i + 1], hk[i]);\n\t\tfor(int i = 2; i <= k; ++i) xz[i] = max(xz[i], xz[i - 1]);\n\n//\t\tfor(int i = 1; i <= k; ++i) cout << xz[i] << ' ' << hk[i] << endl;\n\n\t\te = 1; memset(head, 0, sizeof(head)); memset(flow, 0, sizeof(flow));\n\t\tfor(int i = 1; i <= k; ++i)\n\t\t\tfor(int j = 1; j <= n; ++j)\n\t\t\t\tif(xz[i] <= x[j] && x[j] <= hk[i]) add(i, j + k, 1, v[j]);\n\n\t\tfor(int i = 1; i <= n; ++i) add(i + k, i + n + k, 1, 0);\n\n\t\tfor(int i = 1; i <= k; ++i) xz[i] = 0, hk[i] = INT_MAX;\n\t\tfor(int i = 1; i <= m; ++i)\n\t\t{\n\t\t\tif(ty[i] == 'D') xz[b[i] + 1] = max(xz[b[i] + 1], a[i] + 1);\n\t\t\tif(k - b[i] > 0 && ty[i] == 'U') hk[k - b[i]] = min(hk[k - b[i]], a[i] - 1);\n\t\t}\n\t\tfor(int i = k - 1; i >= 1; --i) hk[i] = min(hk[i + 1], hk[i]);\n\t\tfor(int i = 2; i <= k; ++i) xz[i] = max(xz[i], xz[i - 1]);\n\n\t\tfor(int i = 1; i <= k; ++i)\n\t\t\tfor(int j = 1; j <= n; ++j)\n\t\t\t\tif(xz[i] <= y[j] && y[j] <= hk[i]) add(j + k + n, i + k + n + n, 1, 0);\n\t\ts = 2 * k + n * 2 + 1; t = 2 * k + n * 2 + 2;\n\t\tfor(int i = 1; i <= k; ++i) add(s, i, 1, 0), add(i + k + n + n, t, 1, 0);\n\n\t\tgao(k);\n\t\t/*\n\t\tfor(int u = 1; u <= k; ++u)\n\t\t{\n\t\t\tfor(int i = head[u]; i; i = nxt[i])\n\t\t\t{\n\t\t\t\tint v = to[i];\n\t\t\t\tif(v != s && flow[i] == 1) cout << '*' << u << ' ' << v - k << endl;\n\t\t\t}\n\t\t}\n\n\t\tfor(int u = 1; u <= k; ++u)\n\t\t{\n\t\t\tfor(int i = head[u + k + 2 * n]; i; i = nxt[i])\n\t\t\t{\n\t\t\t\tint v = to[i];\n\t\t\t\tif(v != t && flow[i] == -1) cout << '*' << u << ' ' << v - n - k << endl;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 1; i <= k; ++i) cout << xz[i] << ' ' << hk[i] << endl;\n\t\t*/\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int N=505,M=200005;\nint b[N],a[N],z[N],S,T,flag[N],x[N],y[N],opt[N],lx[N],rx[N],ly[N],ry[N],n,m,sl[M],ne[M],fi[N],zz[M],w[M],tot,dis[N],cur[N];\nqueue<int> Q;\nvoid jb(int x,int y,int z,int v){\n\tne[++tot]=fi[x];fi[x]=tot;zz[tot]=y;sl[tot]=z;w[tot]=v;\n\tne[++tot]=fi[y];fi[y]=tot;zz[tot]=x;sl[tot]=0;w[tot]=-v;\n}\nint get(){\n\tchar s[2];\n\tscanf(\"%s\",s);\n\tif (s[0]=='L')return 1;\n\tif (s[0]=='R')return 2;\n\tif (s[0]=='D')return 3;\n\treturn 4;\n}\nint bfs(){\n\tQ.push(S);\n\tmemset(dis,0x3f3f3f3f,sizeof dis);\n\tdis[0]=0;\n\twhile (!Q.empty()){\n\t\tint now=Q.front();Q.pop();\n\t\tflag[now]=0;\n\t\tfor (int i=fi[now];i;i=ne[i])\n\t\t\tif (sl[i]&&dis[zz[i]]>dis[now]+w[i]){\n\t\t\t\tdis[zz[i]]=dis[now]+w[i];\n\t\t\t\tif (!flag[zz[i]]){\n\t\t\t\t\tflag[zz[i]]=1;\n\t\t\t\t\tQ.push(zz[i]);\n\t\t\t\t}\n\t\t\t}\n\t}\n\treturn dis[T]<=1e18;\n}\nint dfs(int x,int y){\n\tif (x==T)return y;\n\tint s=0,b;\n\tflag[x]=1;\n\tfor (int &i=cur[x];i;i=ne[i])\n\t\tif (sl[i]&&!flag[zz[i]]&&dis[zz[i]]==dis[x]+w[i]&&(b=min(sl[i],dfs(zz[i],min(sl[i],y))))){\n\t\t\ts+=b;y-=b;\n\t\t\tsl[i]-=b;\n\t\t\tsl[i^1]+=b;\n\t\t\tif (!y)return s;\n\t\t}\n\treturn s;\n}\nsigned main(){\n\tscanf(\"%lld\",&n);\n\tfor (int i=1;i<=n;i++)scanf(\"%lld%lld%lld\",&x[i],&y[i],&z[i]);\n\tscanf(\"%lld\",&m);\n\tfor (int i=1;i<=m;i++){\n\t\topt[i]=get();\n\t\tscanf(\"%lld%lld\",&a[i],&b[i]);\n\t}\n\tS=0;T=1;\n\tint ans=0;\n\tfor (int k=1;k<=n;k++){\n\t\tmemset(fi,0,sizeof fi);\n\t\ttot=1;\n\t\tfor (int i=1;i<=k;i++)rx[i]=ry[i]=1e9,lx[i]=ly[i]=0;\n\t\tfor (int i=1;i<=m;i++){\n\t\t\tif (opt[i]==1)lx[b[i]+1]=max(lx[i],a[i]+1);\n\t\t\tif (opt[i]==2&&k>b[i])rx[k-b[i]]=min(rx[k-b[i]],a[i]-1);\n\t\t\tif (opt[i]==3)ly[b[i]+1]=max(ly[i],a[i]+1);\n\t\t\tif (opt[i]==4&&k>b[i])ry[k-b[i]]=min(ry[k-b[i]],a[i]-1);\n\t\t}\n\t\tfor (int i=2;i<=k;i++)lx[i]=max(lx[i-1],lx[i]);\n\t\tfor (int i=k-1;i;i--)rx[i]=min(rx[i+1],rx[i]);\n\t\tfor (int i=2;i<=k;i++)ly[i]=max(ly[i-1],ly[i]);\n\t\tfor (int i=k-1;i;i--)ry[i]=min(ry[i+1],ry[i]);\n\t\tfor (int i=2;i<=k+1;i++)jb(S,i,1,0);\n\t\tfor (int i=2;i<=k+1;i++)jb(i+k,T,1,0);\n\t\tfor (int i=1;i<=k;i++)\n\t\t\tfor (int j=1;j<=n;j++)\n\t\t\t\tif (lx[i]<=x[j]&&rx[i]>=x[j])jb(i+1,j+2*k+1,1,0);\n\t\tfor (int i=1;i<=k;i++)\n\t\t\tfor (int j=1;j<=n;j++)\n\t\t\t\tif (ly[i]<=y[j]&&ry[i]>=y[j])jb(j+2*k+1+n,i+k+1,1,0);\n\t\tfor (int i=1;i<=n;i++)jb(i+2*k+1,i+n+2*k+1,1,-z[i]);\n\t\tint ansc=0,ansm=0;\n\t\twhile (bfs()){\n\t\t\tfor (int i=0;i<=2*k+1+2*n;i++)cur[i]=fi[i];\n\t\t\tint t=dfs(S,1e9);\n\t\t\tansm+=t;\n\t\t\tansc+=t*dis[T];\n\t\t\tfor (int i=0;i<=2*k+1+2*n;i++)flag[i]=0;\n\t\t}\n\t\tif (ansm==k)ans=max(ans,-ansc);\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-03-27 10:28:38\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\n#define i64 long long\ni64 read()\n{\n\ti64 r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\nconst int N=100010,M=10000010;\nnamespace run\n{\n\tconst i64 inf=1ll<<60;\n\ti64 n,px[N],sx[N],py[N],sy[N],begin[N],next[N],to[N],w[N],c[N],e,S,T,m,x[N],y[N],v[N],ans,l,sw,sc;\n\ti64 d[N],q[M],_l,_r,pre[N],vis[N];\n\tvoid add(i64 u,i64 v,i64 W,i64 C){ e++; next[e]=begin[u]; begin[u]=e; to[e]=v; w[e]=W; c[e]=C; }\n\tvoid Add(i64 u,i64 v,i64 w,i64 c){ /*printf(\"%I64d %I64d %I64d\\n\",u,v,c);*/ add(u,v,w,c); add(v,u,0,-c); }\n#define fo(i,a) for(int i=begin[a];i;i=next[i])\n\tint bfs()\n\t{\n\t\tfr(i,1,m){ d[i]=inf; pre[i]=0; vis[i]=0; }\n\t\tq[_l=_r=1]=S; d[S]=0;\n\t\twhile(_l<=_r)\n\t\t{\n\t\t\tint u=q[_l++]; vis[u]=0;\n//\t\t\tprintf(\"%d\\n\",u);\n\t\t\tfo(i,u) if(w[i]&&d[u]+c[i]<d[to[i]])\n\t\t\t{\n\t\t\t\td[to[i]]=d[u]+c[i]; pre[to[i]]=i;\n\t\t\t\tif(!vis[to[i]]){ q[++_r]=to[i]; vis[to[i]]=1; }\n\t\t\t}\n\t\t}\n\t\treturn d[T]!=inf;\n\t}\n\ti64 solve(int c)\n\t{\n\t\tmemset(begin,0,sizeof(begin)); e=1; S=n+n+c+c+1; T=n+n+c+c+2; m=T;\n//\t\tprintf(\"%d %I64d %I64d\\n\",c,S,T);\n\t\tfr(i,1,n) Add(i,i+n,1,-v[i]);\n\t\tfr(j,1,c){ Add(S,j+n+n,1,0); Add(j+n+n+c,T,1,0); }\n\t\tfr(i,1,n) fr(j,1,c) if(px[x[i]]>=j&&sx[x[i]]>=c-j+1) Add(j+n+n,i,1,0);\n\t\tfr(i,1,n) fr(j,1,c) if(py[y[i]]>=j&&sy[y[i]]>=c-j+1) Add(i+n,j+n+n+c,1,0);\n\t\tsw=sc=0;\n\t\tfr(i,1,c) if(bfs())\n\t\t{\n//\t\t\tprintf(\"%I64d\\n\",d[T]);\n\t\t\tint u=T; sw++;\n\t\t\twhile(u!=S){ w[pre[u]]--; w[pre[u]^1]++; sc-=::run::c[pre[u]]; u=to[pre[u]^1]; }\n\t\t}\n\t\telse return 0;\n//\t\tprintf(\"%d %I64d\\n\",c,sw==c?sc:0);\n\t\treturn sc;\n\t}\n\tint main()\n\t{\n\t\tn=read(); l=100;\n\t\tfr(i,1,n){ x[i]=read(); y[i]=read(); v[i]=read(); }\n\t\tfr(i,0,l+1) px[i]=sx[i]=py[i]=sy[i]=n;\n\t\tfr(i,1,read())\n\t\t{\n\t\t\tchar opt[N]; i64 a,b;\n\t\t\tscanf(\"%s\",opt); a=read(); b=read();\n\t\t\tif(*opt=='L') px[a]=std::min(px[a],b);\n\t\t\tif(*opt=='R') sx[a]=std::min(sx[a],b);\n\t\t\tif(*opt=='D') py[a]=std::min(py[a],b);\n\t\t\tif(*opt=='U') sy[a]=std::min(sy[a],b);\n\t\t}\n\t\tfr(i,1,l){ sx[i]=std::min(sx[i],sx[i-1]); sy[i]=std::min(sy[i],sy[i-1]); }\n\t\tfd(i,l,1){ px[i]=std::min(px[i],px[i+1]); py[i]=std::min(py[i],py[i+1]); }\n//\t\tfr(i,1,n) printf(\"%I64d %I64d %I64d %I64d\\n\", );\n\t\tfr(i,1,n){ i64 k=solve(i); ans=std::max(ans,k); if(!k) break; }\n\t\tprintf(\"%lld\\n\",ans);\n\t\treturn 0;\n\t}\n}\nint main(){ return run::main(); }"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 19.01.2020 03:02:31       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T, typename C>\nclass mcmf {\n public:\n  static constexpr T eps = (T) 1e-9;\n\n  struct edge {\n    int from;\n    int to;\n    T c;\n    T f;\n    C cost;\n  };\n\n  vector<vector<int>> g;\n  vector<edge> edges;\n  vector<C> d;\n  vector<int> q;\n  vector<bool> in_queue;\n  vector<int> pe;\n  int n;\n  int st, fin;\n  T flow;\n  C cost;\n\n  mcmf(int _n, int _st, int _fin) : n(_n), st(_st), fin(_fin) {\n    assert(0 <= st && st < n && 0 <= fin && fin < n && st != fin);\n    g.resize(n);\n    d.resize(n);\n    in_queue.resize(n);\n    pe.resize(n);\n    flow = 0;\n    cost = 0;\n  }\n\n  void clear_flow() {\n    for (const edge &e : edges) {\n      e.f = 0;\n    }\n    flow = 0;\n  }\n   \n  void add(int from, int to, T forward_cap, T backward_cap, C cost) {\n    assert(0 <= from && from < n && 0 <= to && to < n);\n    g[from].push_back((int) edges.size());\n    edges.push_back({from, to, forward_cap, 0, cost});\n    g[to].push_back((int) edges.size());\n    edges.push_back({to, from, backward_cap, 0, -cost});\n  }\n\n  bool expath() {\n    fill(d.begin(), d.end(), numeric_limits<C>::max());\n    q.clear();\n    q.push_back(st);\n    d[st] = 0;\n    in_queue[st] = true;\n    int beg = 0;\n    bool found = false;\n    while (beg < (int) q.size()) {\n      int i = q[beg++];\n      if (i == fin) {\n        found = true;\n      }\n      in_queue[i] = false;\n      for (int id : g[i]) {\n        const edge &e = edges[id];\n        if (e.c - e.f > eps && d[i] + e.cost < d[e.to]) {\n          d[e.to] = d[i] + e.cost;\n          pe[e.to] = id;\n          if (!in_queue[e.to]) {\n            q.push_back(e.to);\n            in_queue[e.to] = true;\n          }\n        }\n      }\n    }\n    if (found) {\n      T push = numeric_limits<T>::max();\n      int v = fin;\n      while (v != st) {\n        const edge &e = edges[pe[v]];\n        push = min(push, e.c - e.f);\n        v = e.from;\n      }\n      v = fin;\n      while (v != st) {\n        edge &e = edges[pe[v]];\n        e.f += push;\n        edge &back = edges[pe[v] ^ 1];\n        back.f -= push;\n        v = e.from;\n      }\n      flow += push;\n      cost += push * d[fin];\n    }\n    return found;\n  }\n   \n  pair<T, C> max_flow_min_cost() {\n    while (expath()) {}\n    return {flow, cost};\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<int> x(n), y(n);\n  vector<long long> v(n);\n  for (int i = 0; i < n; i++) {\n    cin >> x[i] >> y[i] >> v[i];\n  }\n  int m;\n  cin >> m;\n  vector<char> t(m);\n  vector<int> a(m), b(m);\n  for (int i = 0; i < m; i++) {\n    cin >> t[i] >> a[i] >> b[i];\n  } \n  long long ans = 0;\n  const int M = 100;\n  for (int k = 1; k <= n; k++) {\n    vector<int> lx(M + 1, 0), rx(M + 1, k);\n    vector<int> ly(M + 1, 0), ry(M + 1, k);\n    for (int i = 0; i < m; i++) {\n      if (b[i] >= k) {\n        continue;\n      }\n      if (t[i] == 'L') {\n        lx[a[i]] = max(lx[a[i]], k - b[i]);\n      }\n      if (t[i] == 'D') {\n        ry[a[i]] = min(ry[a[i]], b[i]);\n      }\n      if (t[i] == 'R') {\n        rx[a[i] - 1] = min(rx[a[i] - 1], b[i]);\n      }\n      if (t[i] == 'U') {\n        ly[a[i] - 1] = max(ly[a[i] - 1], k - b[i]);\n      }\n    }\n    mcmf<int, long long> f(1 + (M + 2) + (M + 2) + 1, 0, 1 + (M + 2) + (M + 2));\n    bool fail = false;\n    int expected = 0;\n    for (int i = 0; i <= M; i++) {\n      if (lx[i] > rx[i]) {\n        fail = true;\n        break;\n      }\n      f.add(1 + i, 1 + i + 1, rx[i] - lx[i], 0, 0);\n      f.add(f.st, 1 + i + 1, lx[i], 0, 0);\n      f.add(1 + i, f.fin, lx[i], 0, 0);\n      expected += lx[i];\n    }\n    for (int i = 0; i <= M; i++) {\n      if (ly[i] > ry[i]) {\n        fail = true;\n        break;\n      }\n      f.add(1 + (M + 2) + i, 1 + (M + 2) + i + 1, ry[i] - ly[i], 0, 0);\n      f.add(f.st, 1 + (M + 2) + i + 1, ly[i], 0, 0);\n      f.add(1 + (M + 2) + i, f.fin, ly[i], 0, 0);\n      expected += ly[i];\n    }\n    if (fail) {\n      continue;\n    }\n    for (int i = 0; i < n; i++) {\n      f.add(1 + x[i], 1 + (M + 2) + y[i], 1, 0, -v[i]);\n    }\n    f.add(f.st, 1, k, 0, 0);\n    f.add(1 + (M + 2) + (M + 1), f.fin, k, 0, 0);\n    expected += k;\n    auto p = f.max_flow_min_cost();\n    assert(p.first <= expected);\n    if (p.first == expected) {\n      ans = max(ans, -p.second);\n    }\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n\n#define fo(i,j,l) for(int i=j;i<=l;++i)\n#define fd(i,j,l) for(int i=j;i>=l;--i)\n#define eps 3e-1\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double db;\nconst ll N=1000;\nconst db sj=5e-20,op=1e7;\n\nint f1[N],f2[N];\nint s1[N],s2[N];\nint w[N];\nll x[N],y[N],v[N];\n\nint n,m,oo,a,b,o2;\ndb c[N],s[N][N];\nint bh[N];\ndb d[N];\nint dl[N];\nint g,gs;\ndb ans=0;\nll da=0;\n\ninline db iabs(db gg)\n{return (gg<0)?(-gg):gg;}\n\ninline void trans(int h,int k)\n{\n\tint u=bh[h]; bh[h]=k;\n\tdb xs=-s[h][k];\n\ts[h][k]=0; s[h][u]=-1;\n\tfo(i,1,g)s[h][i]=s[h][i]/xs;\n\tc[h]=c[h]/xs;\n\tfo(i,1,gs)if(i!=h&&s[i][k]!=0){\n\t\tfo(l,1,g)s[i][l]=s[i][l]+s[i][k]*s[h][l];\n\t\tc[i]=c[i]+c[h]*s[i][k];\n\t\ts[i][k]=0;\n\t}\n\tfo(i,1,g)d[i]=d[i]+d[k]*s[h][i];\n\tans=ans+d[k]*c[h];\n\td[k]=0;\n}\n\ninline int find()\n{\n\tint po=0; d[0]=sj;\n\tfo(i,1,g)if(d[i]>d[po])po=i;\n\treturn po;\n}\n\ninline void Simplex()\n{\n\tint x;\n\twhile((x=find())!=0){\n\t\tdouble zd=(db)1e18;\n\t\tint po=0;\n\t\tfo(i,1,gs)if(s[i][x]<-sj)if(c[i]/(-s[i][x])<zd)zd=c[i]/(-s[i][x]),po=i;\n\t\tif(!po)break;\n\t\ttrans(po,x);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfo(i,1,n){\n\t\tscanf(\"%lld%lld%lld\",&x[i],&y[i],&v[i]);\n\t}\n\tfo(i,1,n)d[i]=v[i]/op;\n\tscanf(\"%d\",&gs); m=gs;\n\tfo(i,1,m){\n\t\tchar ch=' ';\n\t\tfor(;ch!='L'&&ch!='R'&&ch!='U'&&ch!='D';ch=getchar());\n\t\tint aa,bb;\n\t\tscanf(\"%d%d\",&aa,&bb);\n\t\tc[i]=bb;\n\t\tif(ch=='L'){fo(l,1,n)if(x[l]<=aa)s[i][l]=-1;}\n\t\tif(ch=='R'){fo(l,1,n)if(x[l]>=aa)s[i][l]=-1;}\n\t\tif(ch=='D'){fo(l,1,n)if(y[l]<=aa)s[i][l]=-1;}\n\t\tif(ch=='U'){fo(l,1,n)if(y[l]>=aa)s[i][l]=-1;}\t\t\n\t}\n\tfo(i,1,n){\n\t\t++gs; c[gs]=1;\n\t\ts[gs][i]=-1;\n\t}\n\tg=m+n;\n\tSimplex();\n\tll da=(ll)(ans*op+eps);\n\tcout<<da;\n}"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace __gnu_pbds;\nusing namespace std;\n \ntemplate <typename T>\nusing ordered_set =\n\ttree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n \n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n\t*this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n \n#define shandom_ruffle random_shuffle\n \nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=327;\nusing bn=bitset<87>;\nusing ld=long double;\n\nint n;\npii gdz[nax];\nll war[nax];\n\nint m;\nbn podz[nax];\nint ile[nax];\n\nll wyn;\n\nbn ter;\n \nll dajwar()\n{\n\tll ret=0;\n\tfor (int i=1; i<=n; i++)\n\t\tif (ter[i])\n\t\t\tret+=war[i];\n\treturn ret;\n}\n \nint popr()\n{\n\tfor (int i=1; i<=m; i++)\n\t\tif ((podz[i]&ter).count()>ile[i])\n\t\t\treturn 0;\n\treturn 1;\n}\n\nvi kol;\n\nstruct Simplex {        // Maximize c*x subject to Ax <= b.\n  using T = ld;     // Initialize the structure, set A, b, c and then run\n  vector<vector<T>> A;  // solve(). Max objective is stored in res. To recover\n  vector<T> b, c;       // the best result, use getVars().\n  int V, E;\n  vector<int> eqIds, varIds, cols;\n  T res;\n  static constexpr T kEps = 1e-8;\n\n  Simplex(int vars, int eqs) : A(eqs, vector<T>(vars)), b(eqs), c(vars),\n      V(vars), E(eqs), eqIds(eqs), varIds(vars), res(0) {\n    iota(varIds.begin(), varIds.end(), 0);\n    iota(eqIds.begin(), eqIds.end(), vars);\n  }\n\n  void pivot(int eq, int var) {\n    T coef = 1 / A[eq][var];\n    cols.clear();\n    for (int i = 0; i < V; i++) {\n      if (abs(A[eq][i]) > kEps) { cols.push_back(i); A[eq][i] *= coef; }\n    }\n    A[eq][var] *= coef; b[eq] *= coef;\n    for (int row = 0; row < E; row++) {\n      if (row == eq || abs(A[row][var]) < kEps) { continue; }\n      T k = -A[row][var];\n      A[row][var] = 0;\n      for (int i : cols) { A[row][i] += k * A[eq][i]; }\n      b[row] += k * b[eq];\n    }\n    T q = c[var]; c[var] = 0;\n    for (int i : cols) { c[i] -= q * A[eq][i]; }\n    res += q * b[eq];\n    swap(varIds[var], eqIds[eq]);\n  }\n\n  bool solve() {\n    while (true) {\n      int eq = -1, var = -1;\n      for (int i = 0; i < E; i++) { if (b[i] < -kEps) { eq = i; break; } }\n      if (eq == -1) { break; }\n      for (int i = 0; i < V; i++) { if (A[eq][i] < -kEps) { var = i; break; } }\n      if (var == -1) { res = -1e9; return false; /* No solution */ }\n      pivot(eq, var);\n    }\n    while (true) {\n      int var = -1, eq = -1;\n      for (int i = 0; i < V; i++) { if (c[i] > kEps) { var = i; break; } }\n      if (var == -1) { break; }\n      for (int i = 0; i < E; i++) {\n        if (A[i][var] < kEps) { continue; }\n        if (eq >= 0 && b[i] / A[i][var] >= b[eq] / A[eq][var]) { continue; }\n        eq = i;\n      }\n      if (eq == -1) { res = 1e9; return false; /* Unbounded */ }\n      pivot(eq, var);\n    }\n    return true;\n  }\n\n  vector<T> getVars() { // Optimal assignment of variables.\n    vector<T> result(V);\n    for (int i = 0; i < E; i++) if (eqIds[i] < V) result[eqIds[i]] = b[i];\n    return result;\n  }\n};\n\nvoid zmien(ld &v)\n{\n\tv*=(900+(rand()%201))/1000.0;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(\"%d%d%lld\", &gdz[i].first, &gdz[i].second, &war[i]);\n\tscanf(\"%d\", &m);\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\tchar c;\n\t\tint a, b;\n\t\tscanf(\" %c%d%d\", &c, &a, &b);\n\t\tfor (int j=1; j<=n; j++)\n\t\t{\n\t\t\tif (c=='L' && gdz[j].first<=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='R' && gdz[j].first>=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='D' && gdz[j].second<=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t\tif (c=='U' && gdz[j].second>=a)\n\t\t\t\tpodz[i][j]=1;\n\t\t}\n\t\tile[i]=b;\n\t}\n\tfor (int h=0; h<100; h++)\n\t{\n\t\tSimplex janusz(n, m+2*n);\n\t\tfor (int i=0; i<n; i++)\n\t\t{\n\t\t\tjanusz.c[i]=war[i+1];\n\t\t\tif (h)\n\t\t\t\tzmien(janusz.c[i]);\n\t\t}\n\t\tfor (int i=0; i<m; i++)\n\t\t{\n\t\t\tjanusz.b[i]=ile[i+1];\n\t\t\tfor (int j=0; j<n; j++)\n\t\t\t\tjanusz.A[i][j]=podz[i+1][j+1];\n\t\t}\n\t\tfor (int i=0; i<n; i++)\n\t\t{\n\t\t\tjanusz.b[m+i]=1;\n\t\t\tjanusz.A[m+i][i]=1;\n\t\t}\n\t\tfor (int i=0; i<n; i++)\n\t\t{\n\t\t\tjanusz.b[m+n+i]=0;\n\t\t\tjanusz.A[m+n+i][i]=-1;\n\t\t}\n\t\tassert(janusz.solve());\n\t\tauto wez=janusz.getVars();\n\t\t\n\t\tvector <pair<ld,int> > wek;\n\t\tfor (int i=1; i<=n; i++)\n\t\t\twek.push_back({wez[i-1], i});\n\t\t\n\t\tsort(wek.begin(), wek.end());\n\t\treverse(wek.begin(), wek.end());\n\t\t\n\t\tter.reset();\n\t\t\n\t\tfor (auto i : wek)\n\t\t{\n\t\t\tter[i.second]=1;\n\t\t\tif (!popr())\n\t\t\t\tter[i.second]=0;\n\t\t}\n\t\twyn=max(wyn, dajwar());\n\t}\n\t\n\tprintf(\"%lld\\n\", wyn);\n\treturn 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.math.BigInteger;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author ilyakor\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskE solver = new TaskE();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskE {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n//        Random random = new Random(0xdead);\n\n            int n = in.nextInt();\n//        int n = 80;\n            int[] X = new int[n];\n            int[] Y = new int[n];\n            long[] V = new long[n];\n            for (int i = 0; i < n; ++i) {\n                X[i] = in.nextInt();\n                Y[i] = in.nextInt();\n                V[i] = in.nextLong();\n//            X[i] = random.nextInt(100);\n//            Y[i] = random.nextInt(100);\n//            V[i] = Math.abs(random.nextLong() % (long)(1e15));\n            }\n            int m = in.nextInt();\n//        int m = 320;\n            int[] T = new int[m];\n            int[] coord = new int[m];\n            int[] lim = new int[m];\n            boolean[][] matches = new boolean[m][n];\n            for (int i = 0; i < m; ++i) {\n                char c = in.nextToken().toCharArray()[0];\n//            char c = \"LRDU\".charAt(random.nextInt(4));\n                T[i] = c;\n                coord[i] = in.nextInt();\n                lim[i] = in.nextInt();\n//            coord[i] = random.nextInt(100);\n//            lim[i] = random.nextInt(1000);\n                for (int j = 0; j < n; ++j) {\n                    if (c == 'L') matches[i][j] = (X[j] <= coord[i]);\n                    if (c == 'R') matches[i][j] = (X[j] >= coord[i]);\n                    if (c == 'D') matches[i][j] = (Y[j] <= coord[i]);\n                    if (c == 'U') matches[i][j] = (Y[j] >= coord[i]);\n                }\n            }\n\n            Rational[][] a = new Rational[m + 2 * n][n];\n            for (int i = 0; i < m; ++i)\n                for (int j = 0; j < n; ++j)\n                    a[i][j] = matches[i][j] ? Rational.ONE : Rational.ZERO;\n            for (int i = 0; i < n; ++i)\n                for (int j = 0; j < n; ++j) {\n                    a[m + i][j] = (i == j ? Rational.ONE : Rational.ZERO);\n                    a[m + n + i][j] = (i == j ? Rational.ONE : Rational.ZERO).negate();\n                }\n            Rational[] b = new Rational[m + 2 * n];\n            for (int i = 0; i < m; ++i)\n                b[i] = Rational.valueOf(lim[i]);\n            for (int i = 0; i < n; ++i) {\n                b[m + i] = Rational.ONE;\n                b[m + n + i] = Rational.ZERO;\n            }\n            Rational[] c = new Rational[n];\n            for (int i = 0; i < n; ++i)\n                c[i] = Rational.valueOf(V[i]);\n//        Rational[] x = new Rational[n];\n            Rational res = Simplex.simplex(a, b, c, null);\n            if (res == null)\n                out.printLine(0);\n            else\n                out.printLine(Math.max(0, res.longValue()));\n        }\n\n    }\n\n    static class Rational implements Comparable<Rational> {\n        BigInteger num;\n        BigInteger den;\n        public static final Rational ZERO = new Rational(0);\n        public static final Rational ONE = new Rational(1);\n        public static final Rational POSITIVE_INFINITY = new Rational(1, 0);\n\n        public Rational(long num) {\n            this.num = BigInteger.valueOf(num);\n            this.den = BigInteger.ONE;\n        }\n\n        public Rational(long num, long den) {\n            this(BigInteger.valueOf(num), BigInteger.valueOf(den));\n        }\n\n        public Rational(BigInteger num, BigInteger den) {\n            this.num = num;\n            this.den = den;\n            reduce();\n        }\n\n        void reduce() {\n            if (!den.abs().equals(BigInteger.ONE)) {\n                BigInteger gcd = num.gcd(den);\n                if (gcd.signum() != 0 && !gcd.equals(BigInteger.ONE)) {\n                    num = num.divide(gcd);\n                    den = den.divide(gcd);\n                }\n            }\n            if (den.signum() < 0 || den.signum() == 0 && num.signum() < 0) {\n                num = num.negate();\n                den = den.negate();\n            }\n        }\n\n        public Rational add(Rational r) {\n            return new Rational(num.multiply(r.den).add(r.num.multiply(den)), den.multiply(r.den));\n        }\n\n        public Rational sub(Rational r) {\n            return new Rational(num.multiply(r.den).subtract(r.num.multiply(den)), den.multiply(r.den));\n        }\n\n        public Rational mul(Rational r) {\n            return new Rational(num.multiply(r.num), den.multiply(r.den));\n        }\n\n        public Rational div(Rational r) {\n            return new Rational(num.multiply(r.den), den.multiply(r.num));\n        }\n\n        public Rational negate() {\n            return new Rational(num.negate(), den);\n        }\n\n        public Rational inverse() {\n            return new Rational(den, num);\n        }\n\n        public int signum() {\n            return num.signum();\n        }\n\n        public long longValue() {\n            reduce();\n            Assert.assertTrue(num.mod(den).equals(BigInteger.ZERO));\n            return num.divide(den).longValue();\n        }\n\n        public int compareTo(Rational other) {\n            return (num.multiply(other.den).compareTo(other.num.multiply(den)));\n        }\n\n        public boolean equals(Object obj) {\n            return num.equals(((Rational) obj).num) && den.equals(((Rational) obj).den);\n        }\n\n        public int hashCode() {\n            return num.hashCode() * 31 + den.hashCode();\n        }\n\n        public String toString() {\n            return num + \"/\" + den;\n        }\n\n        public static Rational valueOf(long x) {\n            return new Rational(x);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buffer = new byte[10000];\n        private int cur;\n        private int count;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public static boolean isSpace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public int read() {\n            if (count == -1) {\n                throw new InputMismatchException();\n            }\n            try {\n                if (cur >= count) {\n                    cur = 0;\n                    count = stream.read(buffer);\n                    if (count <= 0)\n                        return -1;\n                }\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            return buffer[cur++];\n        }\n\n        public int readSkipSpace() {\n            int c;\n            do {\n                c = read();\n            } while (isSpace(c));\n            return c;\n        }\n\n        public String nextToken() {\n            int c = readSkipSpace();\n            StringBuilder sb = new StringBuilder();\n            while (!isSpace(c)) {\n                sb.append((char) c);\n                c = read();\n            }\n            return sb.toString();\n        }\n\n        public int nextInt() {\n            int sgn = 1;\n            int c = readSkipSpace();\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res = res * 10 + c - '0';\n                c = read();\n            } while (!isSpace(c));\n            res *= sgn;\n            return res;\n        }\n\n        public long nextLong() {\n            long sgn = 1;\n            int c = readSkipSpace();\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res = res * 10L + (long) (c - '0');\n                c = read();\n            } while (!isSpace(c));\n            res *= sgn;\n            return res;\n        }\n\n    }\n\n    static class Assert {\n        public static void assertTrue(boolean flag) {\n//        if (!flag)\n//        while (true);\n            if (!flag)\n                throw new AssertionError();\n        }\n\n    }\n\n    static class Simplex {\n        public static Rational simplex(Rational[][] A, Rational[] b, Rational[] c, Rational[] x) {\n            int m = A.length;\n            int n = A[0].length + 1;\n            int[] index = new int[n + m];\n            for (int i = 0; i < n + m; i++) {\n                index[i] = i;\n            }\n            Rational[][] a = new Rational[m + 2][n + 1];\n            for (Rational[] a1 : a) {\n                Arrays.fill(a1, Rational.ZERO);\n            }\n            int L = m;\n            for (int i = 0; i < m; i++) {\n                for (int j = 0; j < n - 1; j++) {\n                    a[i][j] = A[i][j].negate();\n                }\n                a[i][n - 1] = Rational.ONE;\n                a[i][n] = b[i];\n                if (a[L][n].compareTo(a[i][n]) > 0) {\n                    L = i;\n                }\n            }\n            for (int j = 0; j < n - 1; j++) {\n                a[m][j] = c[j];\n            }\n            a[m + 1][n - 1] = Rational.ONE.negate();\n            for (int E = n - 1; ; ) {\n                if (L < m) {\n                    int t = index[E];\n                    index[E] = index[L + n];\n                    index[L + n] = t;\n                    a[L][E] = a[L][E].inverse();\n                    for (int j = 0; j <= n; j++) {\n                        if (j != E) {\n                            a[L][j] = a[L][j].mul(a[L][E].negate());\n                        }\n                    }\n                    for (int i = 0; i <= m + 1; i++) {\n                        if (i != L) {\n                            for (int j = 0; j <= n; j++) {\n                                if (j != E) {\n                                    a[i][j] = a[i][j].add(a[L][j].mul(a[i][E]));\n                                }\n                            }\n                            a[i][E] = a[i][E].mul(a[L][E]);\n                        }\n                    }\n                }\n                E = -1;\n                for (int j = 0; j < n; j++) {\n                    if (E < 0 || index[E] > index[j]) {\n                        if (a[m + 1][j].signum() > 0 || a[m + 1][j].signum() == 0 && a[m][j].signum() > 0) {\n                            E = j;\n                        }\n                    }\n                }\n                if (E < 0) {\n                    break;\n                }\n                L = -1;\n                for (int i = 0; i < m; i++) {\n                    if (a[i][E].signum() < 0) {\n                        Rational d;\n                        if (L < 0 || (d = a[L][n].div(a[L][E]).sub(a[i][n].div(a[i][E]))).signum() < 0 || d.signum() == 0\n                                && index[L + n] > index[i + n]) {\n                            L = i;\n                        }\n                    }\n                }\n                if (L < 0) {\n                    return Rational.POSITIVE_INFINITY;\n                }\n            }\n            if (a[m + 1][n].signum() < 0) {\n                return null;\n            }\n            if (x != null) {\n                Arrays.fill(x, Rational.ZERO);\n                for (int i = 0; i < m; i++)\n                    if (index[n + i] < n - 1)\n                        x[index[n + i]] = a[i][n];\n            }\n            return a[m][n];\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(objects[i]);\n            }\n        }\n\n        public void printLine(Object... objects) {\n            print(objects);\n            writer.println();\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n\n\tstatic final long C = BigInteger.TEN.pow(15).longValueExact();\n\n\tstatic class Jewel {\n\t\tint x, y;\n\t\tlong val;\n\n\t\tpublic Jewel(int x, int y, long val) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.val = val;\n\t\t}\n\t}\n\n\tvoid submit() {\n\t\tint n = nextInt();\n\n\t\tint bigN = n + 100;\n\n\t\tJewel[] a = new Jewel[n];\n\n\t\tint[] allX = new int[n];\n\t\tint[] allY = new int[n];\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x = nextInt();\n\t\t\tint y = nextInt();\n\t\t\tallX[i] = x;\n\t\t\tallY[i] = y;\n\t\t\tlong v = nextLong();\n\n\t\t\ta[i] = new Jewel(x, y, v);\n\t\t}\n\n\t\tallX = unique(allX);\n\t\tallY = unique(allY);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i].x = Arrays.binarySearch(allX, a[i].x);\n\t\t\ta[i].y = Arrays.binarySearch(allY, a[i].y);\n\t\t}\n\n\t\tint szX = allX.length;\n\t\tint szY = allY.length;\n\n\t\tint m = nextInt();\n\n\t\tint[] lowX = new int[szX + 1];\n\t\tint[] highX = new int[szX + 1];\n\t\tint[] lowY = new int[szY + 1];\n\t\tint[] highY = new int[szY + 1];\n\n\t\tArrays.fill(lowX, -bigN);\n\t\tArrays.fill(highX, bigN);\n\t\tArrays.fill(lowY, -bigN);\n\t\tArrays.fill(highY, bigN);\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tchar type = nextChar();\n\t\t\tint coord = nextInt();\n\t\t\tint val = nextInt();\n\n\t\t\tif (type == 'L') {\n\t\t\t\tint idx = Arrays.binarySearch(allX, coord);\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tidx = -idx - 2;\n\t\t\t\t}\n\t\t\t\tlowX[idx + 1] = Math.max(lowX[idx + 1], -val);\n\t\t\t} else if (type == 'R') {\n\t\t\t\tint idx = Arrays.binarySearch(allX, coord);\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tidx = -idx - 1;\n\t\t\t\t}\n\t\t\t\thighX[idx] = Math.min(highX[idx], val);\n\t\t\t} else if (type == 'D') {\n\t\t\t\tint idx = Arrays.binarySearch(allY, coord);\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tidx = -idx - 2;\n\t\t\t\t}\n\t\t\t\tlowY[idx + 1] = Math.max(lowY[idx + 1], -val);\n\t\t\t} else if (type == 'U') {\n\t\t\t\tint idx = Arrays.binarySearch(allY, coord);\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tidx = -idx - 1;\n\t\t\t\t}\n\t\t\t\thighY[idx] = Math.min(highY[idx], val);\n\t\t\t} else {\n\t\t\t\tthrow new AssertionError();\n\t\t\t}\n\t\t}\n\n\t\tlong ans = 0;\n\n\t\tint gN = 4 + szX + szY + 2 * n;\n\n\t\touter: for (int pick = 1; pick <= n; pick++) {\n\n\t\t\t{\n\t\t\t\tint low = pick + lowX[szX];\n\t\t\t\tint high = highX[szX];\n\t\t\t\tif (!(low <= 0 && 0 <= high)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t{\n\t\t\t\tint low = pick + lowY[szY];\n\t\t\t\tint high = highY[szY];\n\t\t\t\tif (!(low <= 0 && 0 <= high)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tMinCostFlowGraph g = new MinCostFlowGraph(4 + szX + szY + 2 * n,\n\t\t\t\t\tgN - 4, gN - 3);\n\n\t\t\tint s = gN - 2;\n\t\t\tint t = gN - 1;\n\n\t\t\tif (pick + lowX[0] > highX[0]) {\n\t\t\t\tcontinue outer;\n\t\t\t}\n\t\t\tg.addLowerBound(s, 2 * n, pick, pick);\n\t\t\tfor (int i = 1; i < szX; i++) {\n\t\t\t\tint low = Math.max(pick + lowX[i], 0);\n\t\t\t\tint high = Math.min(highX[i], pick);\n\t\t\t\tif (low > high) {\n\t\t\t\t\tcontinue outer;\n\t\t\t\t}\n\t\t\t\tg.addLowerBound(2 * n + i - 1, 2 * n + i, low, high);\n\t\t\t}\n\n\t\t\tif (pick + lowY[0] > highY[0]) {\n\t\t\t\tcontinue outer;\n\t\t\t}\n\t\t\tg.addLowerBound(2 * n + szX, t, pick, pick);\n\t\t\tfor (int i = 1; i < szY; i++) {\n\t\t\t\tint low = Math.max(pick + lowY[i], 0);\n\t\t\t\tint high = Math.min(highY[i], pick);\n\t\t\t\tif (low > high) {\n\t\t\t\t\tcontinue outer;\n\t\t\t\t}\n\t\t\t\tg.addLowerBound(2 * n + szX + i, 2 * n + szX + i - 1, low, high);\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t// x >= ... -> jewel -> y >= ...\n\t\t\t\tg.addEdge(2 * n + a[i].x, i, 1, 0);\n\t\t\t\tg.addEdge(i + n, 2 * n + szX + a[i].y, 1, 0);\n\n\t\t\t\t// edge for jewel\n\t\t\t\tg.addEdge(i, i + n, 1, -a[i].val);\n\t\t\t}\n\n\t\t\tg.addEdge(t, s, pick + 100, 0);\n\n\t\t\tlong[] flow = g.maxFlowMinCost();\n\t\t\tif (g.needFlow != flow[0]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// System.err.println(pick + \" \" + (C * pick - flow[1]));\n\n\t\t\tans = Math.max(ans, -flow[1]);\n\t\t}\n\n\t\tout.println(ans);\n\t}\n\n\t// !!!!!!!!! ADD LONG\n\tstatic class MinCostFlowGraph {\n\n\t\tint needFlow = 0;\n\n\t\tint N, S, T;\n\t\tstatic final long INF = Long.MAX_VALUE / 3;\n\n\t\tList<MinCostFlowEdge>[] g;\n\t\tfinal private long[] d;\n\t\tprivate MinCostFlowEdge[] from;\n\n\t\tpublic MinCostFlowGraph(int n, int s, int t) {\n\t\t\tN = n;\n\t\t\tS = s;\n\t\t\tT = t;\n\t\t\tg = new List[N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t}\n\t\t\td = new long[N];\n\t\t\tfrom = new MinCostFlowEdge[N];\n\t\t}\n\n\t\tvoid addLowerBound(int v1, int v2, int lowCap, int highCap) {\n\n\t\t\tneedFlow += lowCap;\n\n\t\t\tif (lowCap > highCap) {\n\t\t\t\tthrow new AssertionError();\n\t\t\t}\n\n\t\t\taddEdge(S, v2, lowCap, 0);\n\t\t\taddEdge(v1, T, lowCap, 0);\n\t\t\taddEdge(v1, v2, highCap - lowCap, 0);\n\t\t}\n\n\t\tvoid addEdge(int v1, int v2, int cap, long cost) {\n\n\t\t\t// System.err.println(v1 + \" -> \" + v2 + \" \" + cap + \"/\" + cost);\n\n\t\t\tMinCostFlowEdge e1 = new MinCostFlowEdge(v2, cap, cost);\n\t\t\tMinCostFlowEdge e2 = new MinCostFlowEdge(v1, 0, -cost);\n\t\t\te1.rev = e2;\n\t\t\te2.rev = e1;\n\t\t\tg[v1].add(e1);\n\t\t\tg[v2].add(e2);\n\t\t}\n\n\t\tlong[] augmentFlowLevit() {\n\t\t\tArrayDeque<Integer> que = new ArrayDeque<>();\n\t\t\tque.add(S);\n\n\t\t\tArrays.fill(d, INF);\n\t\t\td[S] = 0;\n\n\t\t\tboolean[] inQ = new boolean[N];\n\t\t\tinQ[S] = true;\n\n\t\t\twhile (!que.isEmpty()) {\n\t\t\t\tint v = que.poll();\n\t\t\t\tinQ[v] = false;\n\n\t\t\t\tfor (MinCostFlowEdge e : g[v]) {\n\t\t\t\t\tif (e.flow == e.cap) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (d[e.to] > d[v] + e.cost) {\n\t\t\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\t\t\tfrom[e.to] = e;\n\n\t\t\t\t\t\tif (!inQ[e.to]) {\n\t\t\t\t\t\t\tque.add(e.to);\n\t\t\t\t\t\t\tinQ[e.to] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (d[T] == INF) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tlong addFlow = Long.MAX_VALUE;\n\t\t\tlong costPerFlowUnit = 0;\n\n\t\t\tfor (int v = T; v != S; v = from[v].rev.to) {\n\t\t\t\tMinCostFlowEdge e = from[v];\n\t\t\t\taddFlow = Math.min(addFlow, e.cap - e.flow);\n\t\t\t\tcostPerFlowUnit += e.cost;\n\t\t\t}\n\n\t\t\tfor (int v = T; v != S; v = from[v].rev.to) {\n\t\t\t\tMinCostFlowEdge e = from[v];\n\t\t\t\te.flow += addFlow;\n\t\t\t\te.rev.flow -= addFlow;\n\t\t\t}\n\n\t\t\treturn new long[] { addFlow, costPerFlowUnit };\n\t\t}\n\n\t\t// long[] augmentFlow() {\n\t\t// // returns null if it can't be augmented\n\t\t// // throw new\n\t\t// // AssertionError(\"Uncomment one of findPath implementations\");\n\t\t// if (d[T] == INF) {\n\t\t// return null;\n\t\t// }\n\t\t// for (int i = 0; i < N; i++) {\n\t\t// if (vis[i]) {\n\t\t// phi[i] += d[i] - d[T];\n\t\t// }\n\t\t// }\n\t\t//\n\t\t// long addFlow = flowLeft;\n\t\t// long costPerFlowUnit = 0;\n\t\t//\n\t\t// for (int v = T; v != S; v = from[v].rev.to) {\n\t\t// MinCostFlowEdge e = from[v];\n\t\t// addFlow = Math.min(addFlow, e.cap - e.flow);\n\t\t// costPerFlowUnit += e.cost;\n\t\t// }\n\t\t//\n\t\t// for (int v = T; v != S; v = from[v].rev.to) {\n\t\t// MinCostFlowEdge e = from[v];\n\t\t// e.flow += addFlow;\n\t\t// e.rev.flow -= addFlow;\n\t\t// }\n\t\t//\n\t\t// return new long[] { addFlow, costPerFlowUnit };\n\t\t// }\n\n\t\tlong[] maxFlowMinCost() {\n\t\t\tlong[] ret = new long[2];\n\t\t\twhile (true) {\n\t\t\t\tlong[] delta = augmentFlowLevit();\n\t\t\t\tif (delta == null)\n\t\t\t\t\tbreak;\n\t\t\t\tret[0] += delta[0];\n\t\t\t\tret[1] += delta[0] * delta[1];\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tstatic class MinCostFlowEdge {\n\t\tint to;\n\t\tint flow, cap;\n\n\t\tlong cost;\n\n\t\tMinCostFlowEdge rev;\n\n\t\tpublic MinCostFlowEdge(int to, int cap, long cost) {\n\t\t\tthis.to = to;\n\t\t\tthis.cap = cap;\n\t\t\tthis.cost = cost;\n\t\t}\n\t}\n\n\tint[] unique(int[] a) {\n\t\ta = a.clone();\n\t\tint sz = 0;\n\t\tArrays.sort(a);\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tif (sz == 0 || a[i] != a[sz - 1]) {\n\t\t\t\ta[sz++] = a[i];\n\t\t\t}\n\t\t}\n\t\treturn Arrays.copyOf(a, sz);\n\t}\n\n\tvoid test() {\n\n\t}\n\n\tvoid stress() {\n\t\tfor (int tst = 0;; tst++) {\n\t\t\tif (false) {\n\t\t\t\tthrow new AssertionError();\n\t\t\t}\n\t\t\tSystem.err.println(tst);\n\t\t}\n\t}\n\n\tMain() throws IOException {\n\t\tis = System.in;\n\t\tout = new PrintWriter(System.out);\n\t\tsubmit();\n\t\t// stress();\n\t\t// test();\n\t\tout.close();\n\t}\n\n\tstatic final Random rng = new Random();\n\n\tstatic int rand(int l, int r) {\n\t\treturn l + rng.nextInt(r - l + 1);\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main();\n\t}\n\n\tprivate InputStream is;\n\tPrintWriter out;\n\n\tprivate byte[] buf = new byte[1 << 14];\n\tprivate int bufSz = 0, bufPtr = 0;\n\n\tprivate int readByte() {\n\t\tif (bufSz == -1)\n\t\t\tthrow new RuntimeException(\"Reading past EOF\");\n\t\tif (bufPtr >= bufSz) {\n\t\t\tbufPtr = 0;\n\t\t\ttry {\n\t\t\t\tbufSz = is.read(buf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t\tif (bufSz <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn buf[bufPtr++];\n\t}\n\n\tprivate boolean isTrash(int c) {\n\t\treturn c < 33 || c > 126;\n\t}\n\n\tprivate int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isTrash(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tString nextToken() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!isTrash(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tString nextString() {\n\t\tint b = readByte();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!isTrash(b) || b == ' ') {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tdouble nextDouble() {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n\tchar nextChar() {\n\t\treturn (char) skip();\n\t}\n\n\tint nextInt() {\n\t\tint ret = 0;\n\t\tint b = skip();\n\t\tif (b != '-' && (b < '0' || b > '9')) {\n\t\t\tthrow new InputMismatchException();\n\t\t}\n\t\tboolean neg = false;\n\t\tif (b == '-') {\n\t\t\tneg = true;\n\t\t\tb = readByte();\n\t\t}\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tret = ret * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\tif (b != -1 && !isTrash(b)) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\treturn neg ? -ret : ret;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tlong nextLong() {\n\t\tlong ret = 0;\n\t\tint b = skip();\n\t\tif (b != '-' && (b < '0' || b > '9')) {\n\t\t\tthrow new InputMismatchException();\n\t\t}\n\t\tboolean neg = false;\n\t\tif (b == '-') {\n\t\t\tneg = true;\n\t\t\tb = readByte();\n\t\t}\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tret = ret * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\tif (b != -1 && !isTrash(b)) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\treturn neg ? -ret : ret;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.math.BigInteger;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author ilyakor\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskE solver = new TaskE();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskE {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n//        Random random = new Random(0xdead);\n\n            int n = in.nextInt();\n//        int n = 80;\n            int[] X = new int[n];\n            int[] Y = new int[n];\n            long[] V = new long[n];\n            for (int i = 0; i < n; ++i) {\n                X[i] = in.nextInt();\n                Y[i] = in.nextInt();\n                V[i] = in.nextLong();\n//            X[i] = random.nextInt(100);\n//            Y[i] = random.nextInt(100);\n//            V[i] = Math.abs(random.nextLong() % (long)(1e15));\n            }\n            int m = in.nextInt();\n//        int m = 320;\n            int[] T = new int[m];\n            int[] coord = new int[m];\n            int[] lim = new int[m];\n            boolean[][] matches = new boolean[m][n];\n            for (int i = 0; i < m; ++i) {\n                char c = in.nextToken().toCharArray()[0];\n//            char c = \"LRDU\".charAt(random.nextInt(4));\n                T[i] = c;\n                coord[i] = in.nextInt();\n                lim[i] = in.nextInt();\n//            coord[i] = random.nextInt(100);\n//            lim[i] = random.nextInt(1000);\n                for (int j = 0; j < n; ++j) {\n                    if (c == 'L') matches[i][j] = (X[j] <= coord[i]);\n                    if (c == 'R') matches[i][j] = (X[j] >= coord[i]);\n                    if (c == 'D') matches[i][j] = (Y[j] <= coord[i]);\n                    if (c == 'U') matches[i][j] = (Y[j] >= coord[i]);\n                }\n            }\n\n            Rational[][] a = new Rational[m + n][n];\n            for (int i = 0; i < m; ++i)\n                for (int j = 0; j < n; ++j)\n                    a[i][j] = matches[i][j] ? Rational.ONE : Rational.ZERO;\n            for (int i = 0; i < n; ++i)\n                for (int j = 0; j < n; ++j)\n                    a[m + i][j] = (i == j ? Rational.ONE : Rational.ZERO);\n            Rational[] b = new Rational[m + n];\n            for (int i = 0; i < m; ++i)\n                b[i] = Rational.valueOf(lim[i]);\n            for (int i = 0; i < n; ++i)\n                b[m + i] = Rational.ONE;\n            Rational[] c = new Rational[n];\n            for (int i = 0; i < n; ++i)\n                c[i] = Rational.valueOf(V[i]);\n            Rational[] x = new Rational[n];\n            Rational res = Simplex.simplex(a, b, c, x);\n            out.printLine(res.longValue());\n        }\n\n    }\n\n    static class Rational implements Comparable<Rational> {\n        BigInteger num;\n        BigInteger den;\n        public static final Rational ZERO = new Rational(0);\n        public static final Rational ONE = new Rational(1);\n        public static final Rational POSITIVE_INFINITY = new Rational(1, 0);\n\n        public Rational(long num) {\n            this.num = BigInteger.valueOf(num);\n            this.den = BigInteger.ONE;\n        }\n\n        public Rational(long num, long den) {\n            this(BigInteger.valueOf(num), BigInteger.valueOf(den));\n        }\n\n        public Rational(BigInteger num, BigInteger den) {\n            this.num = num;\n            this.den = den;\n            reduce();\n        }\n\n        void reduce() {\n            if (!den.abs().equals(BigInteger.ONE)) {\n                BigInteger gcd = num.gcd(den);\n                if (gcd.signum() != 0 && !gcd.equals(BigInteger.ONE)) {\n                    num = num.divide(gcd);\n                    den = den.divide(gcd);\n                }\n            }\n            if (den.signum() < 0 || den.signum() == 0 && num.signum() < 0) {\n                num = num.negate();\n                den = den.negate();\n            }\n        }\n\n        public Rational add(Rational r) {\n            return new Rational(num.multiply(r.den).add(r.num.multiply(den)), den.multiply(r.den));\n        }\n\n        public Rational sub(Rational r) {\n            return new Rational(num.multiply(r.den).subtract(r.num.multiply(den)), den.multiply(r.den));\n        }\n\n        public Rational mul(Rational r) {\n            return new Rational(num.multiply(r.num), den.multiply(r.den));\n        }\n\n        public Rational div(Rational r) {\n            return new Rational(num.multiply(r.den), den.multiply(r.num));\n        }\n\n        public Rational negate() {\n            return new Rational(num.negate(), den);\n        }\n\n        public Rational inverse() {\n            return new Rational(den, num);\n        }\n\n        public int signum() {\n            return num.signum();\n        }\n\n        public long longValue() {\n            Assert.assertTrue(num.longValue() % den.longValue() == 0);\n            return num.longValue() / den.longValue();\n        }\n\n        public int compareTo(Rational other) {\n            return (num.multiply(other.den).compareTo(other.num.multiply(den)));\n        }\n\n        public boolean equals(Object obj) {\n            return num.equals(((Rational) obj).num) && den.equals(((Rational) obj).den);\n        }\n\n        public int hashCode() {\n            return num.hashCode() * 31 + den.hashCode();\n        }\n\n        public String toString() {\n            return num + \"/\" + den;\n        }\n\n        public static Rational valueOf(long x) {\n            return new Rational(x);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buffer = new byte[10000];\n        private int cur;\n        private int count;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public static boolean isSpace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public int read() {\n            if (count == -1) {\n                throw new InputMismatchException();\n            }\n            try {\n                if (cur >= count) {\n                    cur = 0;\n                    count = stream.read(buffer);\n                    if (count <= 0)\n                        return -1;\n                }\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            return buffer[cur++];\n        }\n\n        public int readSkipSpace() {\n            int c;\n            do {\n                c = read();\n            } while (isSpace(c));\n            return c;\n        }\n\n        public String nextToken() {\n            int c = readSkipSpace();\n            StringBuilder sb = new StringBuilder();\n            while (!isSpace(c)) {\n                sb.append((char) c);\n                c = read();\n            }\n            return sb.toString();\n        }\n\n        public int nextInt() {\n            int sgn = 1;\n            int c = readSkipSpace();\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res = res * 10 + c - '0';\n                c = read();\n            } while (!isSpace(c));\n            res *= sgn;\n            return res;\n        }\n\n        public long nextLong() {\n            long sgn = 1;\n            int c = readSkipSpace();\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res = res * 10L + (long) (c - '0');\n                c = read();\n            } while (!isSpace(c));\n            res *= sgn;\n            return res;\n        }\n\n    }\n\n    static class Assert {\n        public static void assertTrue(boolean flag) {\n//        if (!flag)\n//        while (true);\n            if (!flag)\n                throw new AssertionError();\n        }\n\n    }\n\n    static class Simplex {\n        public static Rational simplex(Rational[][] A, Rational[] b, Rational[] c, Rational[] x) {\n            int m = A.length;\n            int n = A[0].length + 1;\n            int[] index = new int[n + m];\n            for (int i = 0; i < n + m; i++) {\n                index[i] = i;\n            }\n            Rational[][] a = new Rational[m + 2][n + 1];\n            for (Rational[] a1 : a) {\n                Arrays.fill(a1, Rational.ZERO);\n            }\n            int L = m;\n            for (int i = 0; i < m; i++) {\n                for (int j = 0; j < n - 1; j++) {\n                    a[i][j] = A[i][j].negate();\n                }\n                a[i][n - 1] = Rational.ONE;\n                a[i][n] = b[i];\n                if (a[L][n].compareTo(a[i][n]) > 0) {\n                    L = i;\n                }\n            }\n            for (int j = 0; j < n - 1; j++) {\n                a[m][j] = c[j];\n            }\n            a[m + 1][n - 1] = Rational.ONE.negate();\n            for (int E = n - 1; ; ) {\n                if (L < m) {\n                    int t = index[E];\n                    index[E] = index[L + n];\n                    index[L + n] = t;\n                    a[L][E] = a[L][E].inverse();\n                    for (int j = 0; j <= n; j++) {\n                        if (j != E) {\n                            a[L][j] = a[L][j].mul(a[L][E].negate());\n                        }\n                    }\n                    for (int i = 0; i <= m + 1; i++) {\n                        if (i != L) {\n                            for (int j = 0; j <= n; j++) {\n                                if (j != E) {\n                                    a[i][j] = a[i][j].add(a[L][j].mul(a[i][E]));\n                                }\n                            }\n                            a[i][E] = a[i][E].mul(a[L][E]);\n                        }\n                    }\n                }\n                E = -1;\n                for (int j = 0; j < n; j++) {\n                    if (E < 0 || index[E] > index[j]) {\n                        if (a[m + 1][j].signum() > 0 || a[m + 1][j].signum() == 0 && a[m][j].signum() > 0) {\n                            E = j;\n                        }\n                    }\n                }\n                if (E < 0) {\n                    break;\n                }\n                L = -1;\n                for (int i = 0; i < m; i++) {\n                    if (a[i][E].signum() < 0) {\n                        Rational d;\n                        if (L < 0 || (d = a[L][n].div(a[L][E]).sub(a[i][n].div(a[i][E]))).signum() < 0 || d.signum() == 0\n                                && index[L + n] > index[i + n]) {\n                            L = i;\n                        }\n                    }\n                }\n                if (L < 0) {\n                    return Rational.POSITIVE_INFINITY;\n                }\n            }\n            if (a[m + 1][n].signum() < 0) {\n                return null;\n            }\n            if (x != null) {\n                Arrays.fill(x, Rational.ZERO);\n                for (int i = 0; i < m; i++)\n                    if (index[n + i] < n - 1)\n                        x[index[n + i]] = a[i][n];\n            }\n            return a[m][n];\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(objects[i]);\n            }\n        }\n\n        public void printLine(Object... objects) {\n            print(objects);\n            writer.println();\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n\n\tstatic class Jewel {\n\t\tint x, y;\n\t\tlong val;\n\n\t\tpublic Jewel(int x, int y, long val) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.val = val;\n\t\t}\n\t}\n\n\tvoid submit() {\n\t\tint n = nextInt();\n\n\t\tint bigN = n + 100;\n\n\t\tJewel[] a = new Jewel[n];\n\n\t\tint[] allX = new int[n];\n\t\tint[] allY = new int[n];\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x = nextInt();\n\t\t\tint y = nextInt();\n\t\t\tallX[i] = x;\n\t\t\tallY[i] = y;\n\t\t\tlong v = nextLong();\n\n\t\t\ta[i] = new Jewel(x, y, v);\n\t\t}\n\n\t\tallX = unique(allX);\n\t\tallY = unique(allY);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i].x = Arrays.binarySearch(allX, a[i].x);\n\t\t\ta[i].y = Arrays.binarySearch(allY, a[i].y);\n\t\t}\n\n\t\tint szX = allX.length;\n\t\tint szY = allY.length;\n\n\t\tint m = nextInt();\n\n\t\tint[] lowX = new int[szX + 1];\n\t\tint[] highX = new int[szX + 1];\n\t\tint[] lowY = new int[szY + 1];\n\t\tint[] highY = new int[szY + 1];\n\n\t\tArrays.fill(lowX, -bigN);\n\t\tArrays.fill(highX, bigN);\n\t\tArrays.fill(lowY, -bigN);\n\t\tArrays.fill(highY, bigN);\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tchar type = nextChar();\n\t\t\tint coord = nextInt();\n\t\t\tint val = nextInt();\n\n\t\t\tif (type == 'L') {\n\t\t\t\tint idx = Arrays.binarySearch(allX, coord);\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tidx = -idx - 2;\n\t\t\t\t}\n\t\t\t\tlowX[idx + 1] = Math.max(lowX[idx + 1], -val);\n\t\t\t} else if (type == 'R') {\n\t\t\t\tint idx = Arrays.binarySearch(allX, coord);\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tidx = -idx - 1;\n\t\t\t\t}\n\t\t\t\thighX[idx] = Math.min(highX[idx], val);\n\t\t\t} else if (type == 'D') {\n\t\t\t\tint idx = Arrays.binarySearch(allY, coord);\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tidx = -idx - 2;\n\t\t\t\t}\n\t\t\t\tlowY[idx + 1] = Math.max(lowY[idx + 1], -val);\n\t\t\t} else if (type == 'U') {\n\t\t\t\tint idx = Arrays.binarySearch(allY, coord);\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tidx = -idx - 1;\n\t\t\t\t}\n\t\t\t\thighY[idx] = Math.min(highY[idx], val);\n\t\t\t} else {\n\t\t\t\tthrow new AssertionError();\n\t\t\t}\n\t\t}\n\n\t\tlong ans = 0;\n\n\t\tint gN = 4 + szX + szY + 2 * n;\n\n\t\touter: for (int pick = 1; pick <= n; pick++) {\n\n\t\t\t{\n\t\t\t\tint low = pick + lowX[szX];\n\t\t\t\tint high = highX[szX];\n\t\t\t\tif (!(low <= 0 && 0 <= high)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t{\n\t\t\t\tint low = pick + lowY[szY];\n\t\t\t\tint high = highY[szY];\n\t\t\t\tif (!(low <= 0 && 0 <= high)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t{\n\t\t\t\tint low = pick + lowX[0];\n\t\t\t\tint high = highX[0];\n\t\t\t\tif (!(low <= pick && pick <= high)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t{\n\t\t\t\tint low = pick + lowY[0];\n\t\t\t\tint high = highY[0];\n\t\t\t\tif (!(low <= pick && pick <= high)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tMinCostFlowGraph g = new MinCostFlowGraph(4 + szX + szY + 2 * n,\n\t\t\t\t\tgN - 4, gN - 3);\n\n\t\t\tint s = gN - 2;\n\t\t\tint t = gN - 1;\n\n\t\t\tg.addLowerBound(s, 2 * n, pick, pick);\n\t\t\tfor (int i = 1; i < szX; i++) {\n\t\t\t\tint low = Math.max(pick + lowX[i], 0);\n\t\t\t\tint high = Math.min(highX[i], pick);\n\t\t\t\tif (low > high) {\n\t\t\t\t\tcontinue outer;\n\t\t\t\t}\n\t\t\t\tg.addLowerBound(2 * n + i - 1, 2 * n + i, low, high);\n\t\t\t}\n\n\t\t\tg.addLowerBound(2 * n + szX, t, pick, pick);\n\t\t\tfor (int i = 1; i < szY; i++) {\n\t\t\t\tint low = Math.max(pick + lowY[i], 0);\n\t\t\t\tint high = Math.min(highY[i], pick);\n\t\t\t\tif (low > high) {\n\t\t\t\t\tcontinue outer;\n\t\t\t\t}\n\t\t\t\tg.addLowerBound(2 * n + szX + i, 2 * n + szX + i - 1, low, high);\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t// x >= ... -> jewel -> y >= ...\n\t\t\t\tg.addEdge(2 * n + a[i].x, i, 1, 0);\n\t\t\t\tg.addEdge(i + n, 2 * n + szX + a[i].y, 1, 0);\n\n\t\t\t\t// edge for jewel\n\t\t\t\tg.addEdge(i, i + n, 1, -a[i].val);\n\t\t\t}\n\n\t\t\tg.addEdge(t, s, pick + 100, 0);\n\n\t\t\tlong[] flow = g.maxFlowMinCost();\n\t\t\tif (g.needFlow != flow[0]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// System.err.println(pick + \" \" + (C * pick - flow[1]));\n\n\t\t\tans = Math.max(ans, -flow[1]);\n\t\t}\n\n\t\tout.println(ans);\n\t}\n\n\t// !!!!!!!!! ADD LONG\n\tstatic class MinCostFlowGraph {\n\n\t\tint needFlow = 0;\n\n\t\tint N, S, T;\n\t\tstatic final long INF = Long.MAX_VALUE / 3;\n\n\t\tList<MinCostFlowEdge>[] g;\n\t\tfinal private long[] d;\n\t\tprivate MinCostFlowEdge[] from;\n\n\t\tpublic MinCostFlowGraph(int n, int s, int t) {\n\t\t\tN = n;\n\t\t\tS = s;\n\t\t\tT = t;\n\t\t\tg = new List[N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t}\n\t\t\td = new long[N];\n\t\t\tfrom = new MinCostFlowEdge[N];\n\t\t}\n\n\t\tvoid addLowerBound(int v1, int v2, int lowCap, int highCap) {\n\n\t\t\tneedFlow += lowCap;\n\n\t\t\tif (lowCap > highCap) {\n\t\t\t\tthrow new AssertionError();\n\t\t\t}\n\n\t\t\taddEdge(S, v2, lowCap, 0);\n\t\t\taddEdge(v1, T, lowCap, 0);\n\t\t\taddEdge(v1, v2, highCap - lowCap, 0);\n\t\t}\n\n\t\tvoid addEdge(int v1, int v2, int cap, long cost) {\n\n\t\t\t// System.err.println(v1 + \" -> \" + v2 + \" \" + cap + \"/\" + cost);\n\n\t\t\tMinCostFlowEdge e1 = new MinCostFlowEdge(v2, cap, cost);\n\t\t\tMinCostFlowEdge e2 = new MinCostFlowEdge(v1, 0, -cost);\n\t\t\te1.rev = e2;\n\t\t\te2.rev = e1;\n\t\t\tg[v1].add(e1);\n\t\t\tg[v2].add(e2);\n\t\t}\n\n\t\tlong[] augmentFlowLevit() {\n\t\t\tArrayDeque<Integer> que = new ArrayDeque<>();\n\t\t\tque.add(S);\n\n\t\t\tArrays.fill(d, INF);\n\t\t\td[S] = 0;\n\n\t\t\tboolean[] inQ = new boolean[N];\n\t\t\tinQ[S] = true;\n\n\t\t\twhile (!que.isEmpty()) {\n\t\t\t\tint v = que.poll();\n\t\t\t\tinQ[v] = false;\n\n\t\t\t\tfor (MinCostFlowEdge e : g[v]) {\n\t\t\t\t\tif (e.flow == e.cap) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (d[e.to] > d[v] + e.cost) {\n\t\t\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\t\t\tfrom[e.to] = e;\n\n\t\t\t\t\t\tif (!inQ[e.to]) {\n\t\t\t\t\t\t\tque.add(e.to);\n\t\t\t\t\t\t\tinQ[e.to] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (d[T] == INF) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tlong addFlow = Long.MAX_VALUE;\n\t\t\tlong costPerFlowUnit = 0;\n\n\t\t\tfor (int v = T; v != S; v = from[v].rev.to) {\n\t\t\t\tMinCostFlowEdge e = from[v];\n\t\t\t\taddFlow = Math.min(addFlow, e.cap - e.flow);\n\t\t\t\tcostPerFlowUnit += e.cost;\n\t\t\t}\n\n\t\t\tfor (int v = T; v != S; v = from[v].rev.to) {\n\t\t\t\tMinCostFlowEdge e = from[v];\n\t\t\t\te.flow += addFlow;\n\t\t\t\te.rev.flow -= addFlow;\n\t\t\t}\n\n\t\t\treturn new long[] { addFlow, costPerFlowUnit };\n\t\t}\n\n\t\t// long[] augmentFlow() {\n\t\t// // returns null if it can't be augmented\n\t\t// // throw new\n\t\t// // AssertionError(\"Uncomment one of findPath implementations\");\n\t\t// if (d[T] == INF) {\n\t\t// return null;\n\t\t// }\n\t\t// for (int i = 0; i < N; i++) {\n\t\t// if (vis[i]) {\n\t\t// phi[i] += d[i] - d[T];\n\t\t// }\n\t\t// }\n\t\t//\n\t\t// long addFlow = flowLeft;\n\t\t// long costPerFlowUnit = 0;\n\t\t//\n\t\t// for (int v = T; v != S; v = from[v].rev.to) {\n\t\t// MinCostFlowEdge e = from[v];\n\t\t// addFlow = Math.min(addFlow, e.cap - e.flow);\n\t\t// costPerFlowUnit += e.cost;\n\t\t// }\n\t\t//\n\t\t// for (int v = T; v != S; v = from[v].rev.to) {\n\t\t// MinCostFlowEdge e = from[v];\n\t\t// e.flow += addFlow;\n\t\t// e.rev.flow -= addFlow;\n\t\t// }\n\t\t//\n\t\t// return new long[] { addFlow, costPerFlowUnit };\n\t\t// }\n\n\t\tlong[] maxFlowMinCost() {\n\t\t\tlong[] ret = new long[2];\n\t\t\twhile (true) {\n\t\t\t\tlong[] delta = augmentFlowLevit();\n\t\t\t\tif (delta == null)\n\t\t\t\t\tbreak;\n\t\t\t\tret[0] += delta[0];\n\t\t\t\tret[1] += delta[0] * delta[1];\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tstatic class MinCostFlowEdge {\n\t\tint to;\n\t\tint flow, cap;\n\n\t\tlong cost;\n\n\t\tMinCostFlowEdge rev;\n\n\t\tpublic MinCostFlowEdge(int to, int cap, long cost) {\n\t\t\tthis.to = to;\n\t\t\tthis.cap = cap;\n\t\t\tthis.cost = cost;\n\t\t}\n\t}\n\n\tint[] unique(int[] a) {\n\t\ta = a.clone();\n\t\tint sz = 0;\n\t\tArrays.sort(a);\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tif (sz == 0 || a[i] != a[sz - 1]) {\n\t\t\t\ta[sz++] = a[i];\n\t\t\t}\n\t\t}\n\t\treturn Arrays.copyOf(a, sz);\n\t}\n\n\tvoid test() {\n\n\t}\n\n\tvoid stress() {\n\t\tfor (int tst = 0;; tst++) {\n\t\t\tif (false) {\n\t\t\t\tthrow new AssertionError();\n\t\t\t}\n\t\t\tSystem.err.println(tst);\n\t\t}\n\t}\n\n\tMain() throws IOException {\n\t\tis = System.in;\n\t\tout = new PrintWriter(System.out);\n\t\tsubmit();\n\t\t// stress();\n\t\t// test();\n\t\tout.close();\n\t}\n\n\tstatic final Random rng = new Random();\n\n\tstatic int rand(int l, int r) {\n\t\treturn l + rng.nextInt(r - l + 1);\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main();\n\t}\n\n\tprivate InputStream is;\n\tPrintWriter out;\n\n\tprivate byte[] buf = new byte[1 << 14];\n\tprivate int bufSz = 0, bufPtr = 0;\n\n\tprivate int readByte() {\n\t\tif (bufSz == -1)\n\t\t\tthrow new RuntimeException(\"Reading past EOF\");\n\t\tif (bufPtr >= bufSz) {\n\t\t\tbufPtr = 0;\n\t\t\ttry {\n\t\t\t\tbufSz = is.read(buf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t\tif (bufSz <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn buf[bufPtr++];\n\t}\n\n\tprivate boolean isTrash(int c) {\n\t\treturn c < 33 || c > 126;\n\t}\n\n\tprivate int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isTrash(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tString nextToken() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!isTrash(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tString nextString() {\n\t\tint b = readByte();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!isTrash(b) || b == ' ') {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tdouble nextDouble() {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n\tchar nextChar() {\n\t\treturn (char) skip();\n\t}\n\n\tint nextInt() {\n\t\tint ret = 0;\n\t\tint b = skip();\n\t\tif (b != '-' && (b < '0' || b > '9')) {\n\t\t\tthrow new InputMismatchException();\n\t\t}\n\t\tboolean neg = false;\n\t\tif (b == '-') {\n\t\t\tneg = true;\n\t\t\tb = readByte();\n\t\t}\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tret = ret * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\tif (b != -1 && !isTrash(b)) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\treturn neg ? -ret : ret;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tlong nextLong() {\n\t\tlong ret = 0;\n\t\tint b = skip();\n\t\tif (b != '-' && (b < '0' || b > '9')) {\n\t\t\tthrow new InputMismatchException();\n\t\t}\n\t\tboolean neg = false;\n\t\tif (b == '-') {\n\t\t\tneg = true;\n\t\t\tb = readByte();\n\t\t}\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tret = ret * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\tif (b != -1 && !isTrash(b)) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\treturn neg ? -ret : ret;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n\n\tstatic final long C = BigInteger.TEN.pow(15).longValueExact();\n\n\tstatic class Jewel {\n\t\tint x, y;\n\t\tlong val;\n\n\t\tpublic Jewel(int x, int y, long val) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.val = val;\n\t\t}\n\t}\n\n\tvoid submit() {\n\t\tint n = nextInt();\n\n\t\tint bigN = n + 100;\n\n\t\tJewel[] a = new Jewel[n];\n\n\t\tint[] allX = new int[n];\n\t\tint[] allY = new int[n];\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x = nextInt();\n\t\t\tint y = nextInt();\n\t\t\tallX[i] = x;\n\t\t\tallY[i] = y;\n\t\t\tlong v = nextLong();\n\n\t\t\ta[i] = new Jewel(x, y, C - v);\n\t\t}\n\n\t\tallX = unique(allX);\n\t\tallY = unique(allY);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i].x = Arrays.binarySearch(allX, a[i].x);\n\t\t\ta[i].y = Arrays.binarySearch(allY, a[i].y);\n\t\t}\n\n\t\tint szX = allX.length;\n\t\tint szY = allY.length;\n\n\t\tint m = nextInt();\n\n\t\tint[] lowX = new int[szX + 1];\n\t\tint[] highX = new int[szX + 1];\n\t\tint[] lowY = new int[szY + 1];\n\t\tint[] highY = new int[szY + 1];\n\n\t\tArrays.fill(lowX, -bigN);\n\t\tArrays.fill(highX, bigN);\n\t\tArrays.fill(lowY, -bigN);\n\t\tArrays.fill(highY, bigN);\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tchar type = nextChar();\n\t\t\tint coord = nextInt();\n\t\t\tint val = nextInt();\n\n\t\t\tif (type == 'L') {\n\t\t\t\tint idx = Arrays.binarySearch(allX, coord);\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tidx = -idx - 2;\n\t\t\t\t}\n\t\t\t\tlowX[idx + 1] = Math.max(lowX[idx + 1], -val);\n\t\t\t} else if (type == 'R') {\n\t\t\t\tint idx = Arrays.binarySearch(allX, coord);\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tidx = -idx - 1;\n\t\t\t\t}\n\t\t\t\thighX[idx] = Math.min(highX[idx], val);\n\t\t\t} else if (type == 'D') {\n\t\t\t\tint idx = Arrays.binarySearch(allY, coord);\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tidx = -idx - 2;\n\t\t\t\t}\n\t\t\t\tlowY[idx + 1] = Math.max(lowY[idx + 1], -val);\n\t\t\t} else if (type == 'U') {\n\t\t\t\tint idx = Arrays.binarySearch(allY, coord);\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tidx = -idx - 1;\n\t\t\t\t}\n\t\t\t\thighY[idx] = Math.min(highY[idx], val);\n\t\t\t} else {\n\t\t\t\tthrow new AssertionError();\n\t\t\t}\n\t\t}\n\n\t\tlong ans = 0;\n\n\t\tint gN = 4 + szX + szY + 2 * n;\n\n\t\touter: for (int pick = 1; pick <= n; pick++) {\n\n\t\t\t{\n\t\t\t\tint low = pick + lowX[szX];\n\t\t\t\tint high = highX[szX];\n\t\t\t\tif (!(low <= 0 && 0 <= high)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t{\n\t\t\t\tint low = pick + lowY[szY];\n\t\t\t\tint high = highY[szY];\n\t\t\t\tif (!(low <= 0 && 0 <= high)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tMinCostFlowGraph g = new MinCostFlowGraph(4 + szX + szY + 2 * n,\n\t\t\t\t\tgN - 4, gN - 3);\n\n\t\t\tint s = gN - 2;\n\t\t\tint t = gN - 1;\n\n\t\t\tif (pick + lowX[0] > highX[0]) {\n\t\t\t\tcontinue outer;\n\t\t\t}\n\t\t\tg.addLowerBound(s, 2 * n, pick, pick);\n\t\t\tfor (int i = 1; i < szX; i++) {\n\t\t\t\tint low = Math.max(pick + lowX[i], 0);\n\t\t\t\tint high = Math.min(highX[i], pick);\n\t\t\t\tif (low > high) {\n\t\t\t\t\tcontinue outer;\n\t\t\t\t}\n\t\t\t\tg.addLowerBound(2 * n + i - 1, 2 * n + i, low, high);\n\t\t\t}\n\n\t\t\tif (pick + lowY[0] > highY[0]) {\n\t\t\t\tcontinue outer;\n\t\t\t}\n\t\t\tg.addLowerBound(2 * n + szX, t, pick, pick);\n\t\t\tfor (int i = 1; i < szY; i++) {\n\t\t\t\tint low = Math.max(pick + lowY[i], 0);\n\t\t\t\tint high = Math.min(highY[i], pick);\n\t\t\t\tif (low > high) {\n\t\t\t\t\tcontinue outer;\n\t\t\t\t}\n\t\t\t\tg.addLowerBound(2 * n + szX + i, 2 * n + szX + i - 1, low, high);\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t// x >= ... -> jewel -> y >= ...\n\t\t\t\tg.addEdge(2 * n + a[i].x, i, 1, 0);\n\t\t\t\tg.addEdge(i + n, 2 * n + szX + a[i].y, 1, 0);\n\n\t\t\t\t// edge for jewel\n\t\t\t\tg.addEdge(i, i + n, 1, a[i].val);\n\t\t\t}\n\t\t\t\n\t\t\tg.addEdge(t, s, pick + 100, 0);\n\t\t\t\n\t\t\tlong[] flow = g.maxFlowMinCost();\n\t\t\tif (g.needFlow != flow[0]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n//\t\t\tSystem.err.println(pick + \" \" + (C * pick - flow[1]));\n\t\t\t\n\t\t\tans = Math.max(ans, C * pick - flow[1]);\n\t\t}\n\t\t\n\t\tout.println(ans);\n\t}\n\n\t// !!!!!!!!! ADD LONG\n\tstatic class MinCostFlowGraph {\n\t\t\n\t\tint needFlow = 0;\n\t\t\n\t\t\n\t\tint N, S, T;\n\t\tstatic final long INF = Long.MAX_VALUE / 3;\n\n\t\tList<MinCostFlowEdge>[] g;\n\t\tprivate long[] phi;\n\t\tfinal private long[] d;\n\t\tprivate boolean[] vis;\n\t\tprivate MinCostFlowEdge[] from;\n\n\t\tpublic MinCostFlowGraph(int n, int s, int t) {\n\t\t\tN = n;\n\t\t\tS = s;\n\t\t\tT = t;\n\t\t\tg = new List[N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tphi = new long[N];\n\t\t\tvis = new boolean[N];\n\t\t\td = new long[N];\n\t\t\tfrom = new MinCostFlowEdge[N];\n\n\t\t\tcache = new Integer[N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tcache[i] = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tvoid addLowerBound(int v1, int v2, int lowCap, int highCap) {\n\t\t\t\n\t\t\tneedFlow += lowCap;\n\t\t\t\n\t\t\tif (lowCap > highCap) {\n\t\t\t\tthrow new AssertionError();\n\t\t\t}\n\t\t\t\n\t\t\taddEdge(S, v2, lowCap, 0);\n\t\t\taddEdge(v1, T, lowCap, 0);\n\t\t\taddEdge(v1, v2, highCap - lowCap, 0);\n\t\t}\n\n\t\tvoid addEdge(int v1, int v2, int cap, long cost) {\n\t\t\t\n//\t\t\tSystem.err.println(v1 + \" -> \" + v2 + \" \" + cap + \"/\" + cost);\n\t\t\t\n\t\t\tMinCostFlowEdge e1 = new MinCostFlowEdge(v2, cap, cost);\n\t\t\tMinCostFlowEdge e2 = new MinCostFlowEdge(v1, 0, -cost);\n\t\t\te1.rev = e2;\n\t\t\te2.rev = e1;\n\t\t\tg[v1].add(e1);\n\t\t\tg[v2].add(e2);\n\t\t}\n\n\t\tInteger[] cache;\n\t\tTreeSet<Integer> set = new TreeSet<>();\n\n\t\tComparator<Integer> byDist = new Comparator<Integer>() {\n\n\t\t\t@Override\n\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\treturn Long.compare(d[o1], d[o2]);\n\t\t\t}\n\t\t};\n\n\t\tvoid findPathELogV() {\n\t\t\tset.clear();\n\t\t\tset.add(cache[S]);\n\t\t\tArrays.fill(d, INF);\n\t\t\tArrays.fill(vis, false);\n\t\t\td[S] = 0;\n\t\t\twhile (!set.isEmpty()) {\n\t\t\t\tint v = set.pollFirst();\n\t\t\t\tvis[v] = true;\n\t\t\t\tif (v == T)\n\t\t\t\t\tbreak;\n\t\t\t\tList<MinCostFlowEdge> adj = g[v];\n\t\t\t\tfor (int i = 0; i < adj.size(); i++) {\n\t\t\t\t\tMinCostFlowEdge e = adj.get(i);\n\t\t\t\t\tif (e.flow == e.cap)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (d[e.to] > d[v] + e.cost + phi[v] - phi[e.to]) {\n\t\t\t\t\t\tset.remove(cache[e.to]);\n\t\t\t\t\t\td[e.to] = d[v] + e.cost + phi[v] - phi[e.to];\n\t\t\t\t\t\tset.add(cache[e.to]);\n\t\t\t\t\t\tfrom[e.to] = e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid findPathV2() {\n\t\t\tArrays.fill(d, INF);\n\t\t\tArrays.fill(vis, false);\n\t\t\td[S] = 0;\n\t\t\twhile (true) {\n\t\t\t\tint v = -1;\n\t\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\t\tif (!vis[i] && (v == -1 || d[i] < d[v])) {\n\t\t\t\t\t\tv = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvis[v] = true;\n\t\t\t\tif (v == T)\n\t\t\t\t\tbreak;\n\t\t\t\tList<MinCostFlowEdge> adj = g[v];\n\t\t\t\tfor (int i = 0; i < adj.size(); i++) {\n\t\t\t\t\tMinCostFlowEdge e = adj.get(i);\n\t\t\t\t\tif (e.flow == e.cap)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (d[e.to] > d[v] + e.cost + phi[v] - phi[e.to]) {\n\t\t\t\t\t\td[e.to] = d[v] + e.cost + phi[v] - phi[e.to];\n\t\t\t\t\t\tfrom[e.to] = e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlong[] augmentFlow(long flowLeft) {\n\t\t\t// returns null if it can't be augmented\n\t\t\t// throw new\n\t\t\t// AssertionError(\"Uncomment one of findPath implementations\");\n//\t\t\tfindPathELogV();\n\t\t\t findPathV2();\n\t\t\tif (d[T] == INF) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tif (vis[i]) {\n\t\t\t\t\tphi[i] += d[i] - d[T];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlong addFlow = flowLeft;\n\t\t\tlong costPerFlowUnit = 0;\n\n\t\t\tfor (int v = T; v != S; v = from[v].rev.to) {\n\t\t\t\tMinCostFlowEdge e = from[v];\n\t\t\t\taddFlow = Math.min(addFlow, e.cap - e.flow);\n\t\t\t\tcostPerFlowUnit += e.cost;\n\t\t\t}\n\n\t\t\tfor (int v = T; v != S; v = from[v].rev.to) {\n\t\t\t\tMinCostFlowEdge e = from[v];\n\t\t\t\te.flow += addFlow;\n\t\t\t\te.rev.flow -= addFlow;\n\t\t\t}\n\n\t\t\treturn new long[] { addFlow, costPerFlowUnit };\n\t\t}\n\n\t\tlong[] maxFlowMinCost() {\n\t\t\tlong[] ret = new long[2];\n\t\t\twhile (true) {\n\t\t\t\tlong[] delta = augmentFlow(INF);\n\t\t\t\tif (delta == null)\n\t\t\t\t\tbreak;\n\t\t\t\tret[0] += delta[0];\n\t\t\t\tret[1] += delta[0] * delta[1];\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tstatic class MinCostFlowEdge {\n\t\tint to;\n\t\tint flow, cap;\n\n\t\tlong cost;\n\n\t\tMinCostFlowEdge rev;\n\n\t\tpublic MinCostFlowEdge(int to, int cap, long cost) {\n\t\t\tthis.to = to;\n\t\t\tthis.cap = cap;\n\t\t\tthis.cost = cost;\n\t\t}\n\t}\n\n\tint[] unique(int[] a) {\n\t\ta = a.clone();\n\t\tint sz = 0;\n\t\tArrays.sort(a);\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tif (sz == 0 || a[i] != a[sz - 1]) {\n\t\t\t\ta[sz++] = a[i];\n\t\t\t}\n\t\t}\n\t\treturn Arrays.copyOf(a, sz);\n\t}\n\n\tvoid test() {\n\n\t}\n\n\tvoid stress() {\n\t\tfor (int tst = 0;; tst++) {\n\t\t\tif (false) {\n\t\t\t\tthrow new AssertionError();\n\t\t\t}\n\t\t\tSystem.err.println(tst);\n\t\t}\n\t}\n\n\tMain() throws IOException {\n\t\tis = System.in;\n\t\tout = new PrintWriter(System.out);\n\t\tsubmit();\n\t\t// stress();\n\t\t// test();\n\t\tout.close();\n\t}\n\n\tstatic final Random rng = new Random();\n\n\tstatic int rand(int l, int r) {\n\t\treturn l + rng.nextInt(r - l + 1);\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main();\n\t}\n\n\tprivate InputStream is;\n\tPrintWriter out;\n\n\tprivate byte[] buf = new byte[1 << 14];\n\tprivate int bufSz = 0, bufPtr = 0;\n\n\tprivate int readByte() {\n\t\tif (bufSz == -1)\n\t\t\tthrow new RuntimeException(\"Reading past EOF\");\n\t\tif (bufPtr >= bufSz) {\n\t\t\tbufPtr = 0;\n\t\t\ttry {\n\t\t\t\tbufSz = is.read(buf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t\tif (bufSz <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn buf[bufPtr++];\n\t}\n\n\tprivate boolean isTrash(int c) {\n\t\treturn c < 33 || c > 126;\n\t}\n\n\tprivate int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isTrash(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tString nextToken() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!isTrash(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tString nextString() {\n\t\tint b = readByte();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!isTrash(b) || b == ' ') {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tdouble nextDouble() {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n\tchar nextChar() {\n\t\treturn (char) skip();\n\t}\n\n\tint nextInt() {\n\t\tint ret = 0;\n\t\tint b = skip();\n\t\tif (b != '-' && (b < '0' || b > '9')) {\n\t\t\tthrow new InputMismatchException();\n\t\t}\n\t\tboolean neg = false;\n\t\tif (b == '-') {\n\t\t\tneg = true;\n\t\t\tb = readByte();\n\t\t}\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tret = ret * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\tif (b != -1 && !isTrash(b)) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\treturn neg ? -ret : ret;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tlong nextLong() {\n\t\tlong ret = 0;\n\t\tint b = skip();\n\t\tif (b != '-' && (b < '0' || b > '9')) {\n\t\t\tthrow new InputMismatchException();\n\t\t}\n\t\tboolean neg = false;\n\t\tif (b == '-') {\n\t\t\tneg = true;\n\t\t\tb = readByte();\n\t\t}\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tret = ret * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\tif (b != -1 && !isTrash(b)) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\treturn neg ? -ret : ret;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.PrintStream;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.util.Random;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.math.BigInteger;\nimport java.util.Collections;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author ilyakor\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskE solver = new TaskE();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskE {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            Random random = new Random(0xdead);\n\n//        for (int it = 0; it < 10000; ++it) {\n//            int n = random.nextInt(32) + 1;\n//            int[] X = new int[n];\n//            int[] Y = new int[n];\n//            long[] V = new long[n];\n//            for (int i = 0;i < n; ++i) {\n//              X[i] = random.nextInt(100);\n//              Y[i] = random.nextInt(100);\n//              V[i] = Math.abs(random.nextLong() % (long)(1e15)) + 1;\n//            }\n//            int m = random.nextInt(32);\n//            int[] T = new int[m];\n//            int[] coord = new int[m];\n//            int[] lim = new int[m];\n//            for (int i = 0; i < m; ++i) {\n//                char c = \"LRDU\".charAt(random.nextInt(4));\n//                T[i] = c;\n//                coord[i] = random.nextInt(100);\n//                lim[i] = random.nextInt(100);\n//            }\n//            long res = megaSolve(n, X, Y, V, m, T, coord, lim);\n////            res.longValue();\n//            System.err.println(it);\n//        }\n\n            int n = in.nextInt();\n//        int n = 80;\n            int[] X = new int[n];\n            int[] Y = new int[n];\n            long[] V = new long[n];\n            for (int i = 0; i < n; ++i) {\n                X[i] = in.nextInt();\n                Y[i] = in.nextInt();\n                V[i] = in.nextLong();\n//            X[i] = random.nextInt(100);\n//            Y[i] = random.nextInt(100);\n//            V[i] = Math.abs(random.nextLong() % (long)(1e15));\n            }\n            int m = in.nextInt();\n//        int m = 320;\n            int[] T = new int[m];\n            int[] coord = new int[m];\n            int[] lim = new int[m];\n            for (int i = 0; i < m; ++i) {\n                char c = in.nextToken().toCharArray()[0];\n//            char c = \"LRDU\".charAt(random.nextInt(4));\n                T[i] = c;\n                coord[i] = in.nextInt();\n                lim[i] = in.nextInt();\n//            coord[i] = random.nextInt(100);\n//            lim[i] = random.nextInt(1000);\n\n            }\n\n            long res = megaSolve(n, X, Y, V, m, T, coord, lim);\n            out.printLine(Math.max(0, res));\n        }\n\n        public long megaSolve(int n, int[] x, int[] y, long[] v, int m, int[] t, int[] coord, int[] lim) {\n            boolean[][] matches = new boolean[m][n];\n\n            for (int i = 0; i < m; ++i) {\n                char c = (char) t[i];\n                for (int j = 0; j < n; ++j) {\n                    if (c == 'L') matches[i][j] = (x[j] <= coord[i]);\n                    if (c == 'R') matches[i][j] = (x[j] >= coord[i]);\n                    if (c == 'D') matches[i][j] = (y[j] <= coord[i]);\n                    if (c == 'U') matches[i][j] = (y[j] >= coord[i]);\n                }\n            }\n\n            Rational[][] a = new Rational[m + n][n];\n            for (int i = 0; i < m; ++i)\n                for (int j = 0; j < n; ++j)\n                    a[i][j] = matches[i][j] ? Rational.ONE : Rational.ZERO;\n            for (int i = 0; i < n; ++i)\n                for (int j = 0; j < n; ++j) {\n                    a[m + i][j] = (i == j ? Rational.ONE : Rational.ZERO);\n//                a[m + n + i][j] = (i == j ? Rational.ONE : Rational.ZERO).negate();\n                }\n            Rational[] b = new Rational[m + n];\n            for (int i = 0; i < m; ++i)\n                b[i] = Rational.valueOf(lim[i]);\n            for (int i = 0; i < n; ++i) {\n                b[m + i] = Rational.ONE;\n//            b[m + n + i] = Rational.ZERO;\n            }\n            Rational[] c = new Rational[n];\n            for (int i = 0; i < n; ++i)\n                c[i] = Rational.valueOf(v[i]);\n            Rational[] X = new Rational[n];\n            Simplex.simplex(a, b, c, X);\n//        for (int i = 0; i < n; ++i)\n//            System.err.print(v[i] + \" * \" + X[i].toString() + \" \");\n//        System.err.println();\n            int[] vals = new int[n];\n            int nhalf = 0;\n            for (int i = 0; i < n; ++i) {\n                Rational cur = X[i].mul(Rational.valueOf(12));\n                vals[i] = (int) cur.longValue();\n                if (vals[i] != 0 && vals[i] != 12) ++nhalf;\n//            if (X[i].den.equals(BigInteger.ONE)) {\n//                vals[i] = X[i].num.equals(BigInteger.ONE) ? 2 : 0;\n//            } else {\n//                Assert.assertTrue(X[i].den.equals(BigInteger.valueOf(2)));\n//                vals[i] = X[i].num.equals(BigInteger.ONE) ? 1 : 0;\n//                if (vals[i] == 1) ++nhalf;\n//            }\n            }\n\n            long res = 0;\n            for (int i = 0; i < n; ++i)\n                if (vals[i] == 12)\n                    res += v[i];\n            int[] sat = new int[m];\n            for (int i = 0; i < n; ++i)\n                for (int j = 0; j < m; ++j)\n                    if (matches[j][i])\n                        sat[j] += vals[i];\n\n            ArrayList<Integer>[] g = new ArrayList[nhalf];\n            long[] nv = new long[nhalf];\n            for (int i = 0; i < g.length; ++i)\n                g[i] = new ArrayList<>();\n            nhalf = 0;\n            for (int i = 0; i < n; ++i) {\n                if (vals[i] == 0 || vals[i] == 12) continue;\n                nv[nhalf] = v[i];\n                for (int j = 0; j < m; ++j)\n                    if (matches[j][i]) {\n                        Assert.assertTrue(sat[j] <= 12 * lim[j]);\n                        if (sat[j] > 12 * (lim[j] - 1))\n                            g[nhalf].add(j);\n                    }\n                ++nhalf;\n            }\n            Assert.assertTrue(nhalf == g.length);\n            res += brute(g, nv);\n            return res;\n        }\n\n        private long brute(ArrayList<Integer>[] g, long[] v) {\n            int n = g.length;\n            if (n == 0) return 0;\n            ArrayList<Integer>[] rg = new ArrayList[400];\n            for (int i = 0; i < rg.length; ++i)\n                rg[i] = new ArrayList<>();\n            for (int i = 0; i < n; ++i) {\n                Assert.assertTrue(!g[i].isEmpty());\n                for (int x : g[i])\n                    rg[x].add(i);\n            }\n            ArrayList<Integer> order = new ArrayList<>();\n            for (int i = 0; i < n; ++i)\n                order.add(i);\n            Random random = new Random(0xbeef);\n            long res = 0;\n            for (int it = 0; it < 1000; ++it) {\n                Collections.shuffle(order, random);\n                long cur = 0;\n                boolean[] alive = new boolean[n];\n                Arrays.fill(alive, true);\n                for (int x : order) {\n                    if (!alive[x]) continue;\n                    cur += v[x];\n                    for (int y : g[x])\n                        for (int z : rg[y])\n                            alive[z] = false;\n                }\n                res = Math.max(res, cur);\n            }\n            if (res == 0) {\n                System.err.println(n);\n                for (int i = 0; i < n; ++i)\n                    System.err.println(v[i]);\n            }\n            Assert.assertTrue(res > 0);\n            return res;\n        }\n\n    }\n\n    static class Simplex {\n        public static Rational simplex(Rational[][] A, Rational[] b, Rational[] c, Rational[] x) {\n            int m = A.length;\n            int n = A[0].length + 1;\n            int[] index = new int[n + m];\n            for (int i = 0; i < n + m; i++) {\n                index[i] = i;\n            }\n            Rational[][] a = new Rational[m + 2][n + 1];\n            for (Rational[] a1 : a) {\n                Arrays.fill(a1, Rational.ZERO);\n            }\n            int L = m;\n            for (int i = 0; i < m; i++) {\n                for (int j = 0; j < n - 1; j++) {\n                    a[i][j] = A[i][j].negate();\n                }\n                a[i][n - 1] = Rational.ONE;\n                a[i][n] = b[i];\n                if (a[L][n].compareTo(a[i][n]) > 0) {\n                    L = i;\n                }\n            }\n            for (int j = 0; j < n - 1; j++) {\n                a[m][j] = c[j];\n            }\n            a[m + 1][n - 1] = Rational.ONE.negate();\n            for (int E = n - 1; ; ) {\n                if (L < m) {\n                    int t = index[E];\n                    index[E] = index[L + n];\n                    index[L + n] = t;\n                    a[L][E] = a[L][E].inverse();\n                    for (int j = 0; j <= n; j++) {\n                        if (j != E) {\n                            a[L][j] = a[L][j].mul(a[L][E].negate());\n                        }\n                    }\n                    for (int i = 0; i <= m + 1; i++) {\n                        if (i != L) {\n                            for (int j = 0; j <= n; j++) {\n                                if (j != E) {\n                                    a[i][j] = a[i][j].add(a[L][j].mul(a[i][E]));\n                                }\n                            }\n                            a[i][E] = a[i][E].mul(a[L][E]);\n                        }\n                    }\n                }\n                E = -1;\n                for (int j = 0; j < n; j++) {\n                    if (E < 0 || index[E] > index[j]) {\n                        if (a[m + 1][j].signum() > 0 || a[m + 1][j].signum() == 0 && a[m][j].signum() > 0) {\n                            E = j;\n                        }\n                    }\n                }\n                if (E < 0) {\n                    break;\n                }\n                L = -1;\n                for (int i = 0; i < m; i++) {\n                    if (a[i][E].signum() < 0) {\n                        Rational d;\n                        if (L < 0 || (d = a[L][n].div(a[L][E]).sub(a[i][n].div(a[i][E]))).signum() < 0 || d.signum() == 0\n                                && index[L + n] > index[i + n]) {\n                            L = i;\n                        }\n                    }\n                }\n                if (L < 0) {\n                    return Rational.POSITIVE_INFINITY;\n                }\n            }\n            if (a[m + 1][n].signum() < 0) {\n                return null;\n            }\n            if (x != null) {\n                Arrays.fill(x, Rational.ZERO);\n                for (int i = 0; i < m; i++)\n                    if (index[n + i] < n - 1)\n                        x[index[n + i]] = a[i][n];\n            }\n            return a[m][n];\n        }\n\n    }\n\n    static class Assert {\n        public static void assertTrue(boolean flag) {\n//        if (!flag)\n//        while (true);\n            if (!flag)\n                throw new AssertionError();\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buffer = new byte[10000];\n        private int cur;\n        private int count;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public static boolean isSpace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public int read() {\n            if (count == -1) {\n                throw new InputMismatchException();\n            }\n            try {\n                if (cur >= count) {\n                    cur = 0;\n                    count = stream.read(buffer);\n                    if (count <= 0)\n                        return -1;\n                }\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            return buffer[cur++];\n        }\n\n        public int readSkipSpace() {\n            int c;\n            do {\n                c = read();\n            } while (isSpace(c));\n            return c;\n        }\n\n        public String nextToken() {\n            int c = readSkipSpace();\n            StringBuilder sb = new StringBuilder();\n            while (!isSpace(c)) {\n                sb.append((char) c);\n                c = read();\n            }\n            return sb.toString();\n        }\n\n        public int nextInt() {\n            int sgn = 1;\n            int c = readSkipSpace();\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res = res * 10 + c - '0';\n                c = read();\n            } while (!isSpace(c));\n            res *= sgn;\n            return res;\n        }\n\n        public long nextLong() {\n            long sgn = 1;\n            int c = readSkipSpace();\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res = res * 10L + (long) (c - '0');\n                c = read();\n            } while (!isSpace(c));\n            res *= sgn;\n            return res;\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(objects[i]);\n            }\n        }\n\n        public void printLine(Object... objects) {\n            print(objects);\n            writer.println();\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n    }\n\n    static class Rational implements Comparable<Rational> {\n        public BigInteger num;\n        public BigInteger den;\n        public static final Rational ZERO = new Rational(0);\n        public static final Rational ONE = new Rational(1);\n        public static final Rational POSITIVE_INFINITY = new Rational(1, 0);\n\n        public Rational(long num) {\n            this.num = BigInteger.valueOf(num);\n            this.den = BigInteger.ONE;\n        }\n\n        public Rational(long num, long den) {\n            this(BigInteger.valueOf(num), BigInteger.valueOf(den));\n        }\n\n        public Rational(BigInteger num, BigInteger den) {\n            this.num = num;\n            this.den = den;\n            reduce();\n        }\n\n        void reduce() {\n            if (!den.abs().equals(BigInteger.ONE)) {\n                BigInteger gcd = num.gcd(den);\n                if (gcd.signum() != 0 && !gcd.equals(BigInteger.ONE)) {\n                    num = num.divide(gcd);\n                    den = den.divide(gcd);\n                }\n            }\n            if (den.signum() < 0 || den.signum() == 0 && num.signum() < 0) {\n                num = num.negate();\n                den = den.negate();\n            }\n        }\n\n        public Rational add(Rational r) {\n            return new Rational(num.multiply(r.den).add(r.num.multiply(den)), den.multiply(r.den));\n        }\n\n        public Rational sub(Rational r) {\n            return new Rational(num.multiply(r.den).subtract(r.num.multiply(den)), den.multiply(r.den));\n        }\n\n        public Rational mul(Rational r) {\n            return new Rational(num.multiply(r.num), den.multiply(r.den));\n        }\n\n        public Rational div(Rational r) {\n            return new Rational(num.multiply(r.den), den.multiply(r.num));\n        }\n\n        public Rational negate() {\n            return new Rational(num.negate(), den);\n        }\n\n        public Rational inverse() {\n            return new Rational(den, num);\n        }\n\n        public int signum() {\n            return num.signum();\n        }\n\n        public long longValue() {\n            reduce();\n            boolean okish = num.mod(den).equals(BigInteger.ZERO);\n            if (!okish) {\n                System.err.println(num + \" / \" + den);\n                throw new RuntimeException();\n            }\n            return num.divide(den).longValue();\n        }\n\n        public int compareTo(Rational other) {\n            return (num.multiply(other.den).compareTo(other.num.multiply(den)));\n        }\n\n        public boolean equals(Object obj) {\n            return num.equals(((Rational) obj).num) && den.equals(((Rational) obj).den);\n        }\n\n        public int hashCode() {\n            return num.hashCode() * 31 + den.hashCode();\n        }\n\n        public String toString() {\n            return num + \"/\" + den;\n        }\n\n        public static Rational valueOf(long x) {\n            return new Rational(x);\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n\n\tstatic final long C = BigInteger.TEN.pow(15).longValueExact();\n\n\tstatic class Jewel {\n\t\tint x, y;\n\t\tlong val;\n\n\t\tpublic Jewel(int x, int y, long val) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.val = val;\n\t\t}\n\t}\n\n\tvoid submit() {\n\t\tint n = nextInt();\n\n\t\tint bigN = n + 100;\n\n\t\tJewel[] a = new Jewel[n];\n\n\t\tint[] allX = new int[n];\n\t\tint[] allY = new int[n];\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x = nextInt();\n\t\t\tint y = nextInt();\n\t\t\tallX[i] = x;\n\t\t\tallY[i] = y;\n\t\t\tlong v = nextLong();\n\n\t\t\ta[i] = new Jewel(x, y, C - v);\n\t\t}\n\n\t\tallX = unique(allX);\n\t\tallY = unique(allY);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i].x = Arrays.binarySearch(allX, a[i].x);\n\t\t\ta[i].y = Arrays.binarySearch(allY, a[i].y);\n\t\t}\n\n\t\tint szX = allX.length;\n\t\tint szY = allY.length;\n\n\t\tint m = nextInt();\n\n\t\tint[] lowX = new int[szX + 1];\n\t\tint[] highX = new int[szX + 1];\n\t\tint[] lowY = new int[szY + 1];\n\t\tint[] highY = new int[szY + 1];\n\n\t\tArrays.fill(lowX, -bigN);\n\t\tArrays.fill(highX, bigN);\n\t\tArrays.fill(lowY, -bigN);\n\t\tArrays.fill(highY, bigN);\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tchar type = nextChar();\n\t\t\tint coord = nextInt();\n\t\t\tint val = nextInt();\n\n\t\t\tif (type == 'L') {\n\t\t\t\tint idx = Arrays.binarySearch(allX, coord);\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tidx = -idx - 2;\n\t\t\t\t}\n\t\t\t\tlowX[idx + 1] = Math.max(lowX[idx + 1], -val);\n\t\t\t} else if (type == 'R') {\n\t\t\t\tint idx = Arrays.binarySearch(allX, coord);\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tidx = -idx - 1;\n\t\t\t\t}\n\t\t\t\thighX[idx] = Math.min(highX[idx], val);\n\t\t\t} else if (type == 'D') {\n\t\t\t\tint idx = Arrays.binarySearch(allY, coord);\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tidx = -idx - 2;\n\t\t\t\t}\n\t\t\t\tlowY[idx + 1] = Math.max(lowY[idx + 1], -val);\n\t\t\t} else if (type == 'U') {\n\t\t\t\tint idx = Arrays.binarySearch(allY, coord);\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tidx = -idx - 1;\n\t\t\t\t}\n\t\t\t\thighY[idx] = Math.min(highY[idx], val);\n\t\t\t} else {\n\t\t\t\tthrow new AssertionError();\n\t\t\t}\n\t\t}\n\n\t\tlong ans = 0;\n\n\t\tint gN = 4 + szX + szY + 2 * n;\n\n\t\touter: for (int pick = 1; pick <= n; pick++) {\n\n\t\t\t{\n\t\t\t\tint low = pick + lowX[szX];\n\t\t\t\tint high = highX[szX];\n\t\t\t\tif (!(low <= 0 && 0 <= high)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t{\n\t\t\t\tint low = pick + lowY[szY];\n\t\t\t\tint high = highY[szY];\n\t\t\t\tif (!(low <= 0 && 0 <= high)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tMinCostFlowGraph g = new MinCostFlowGraph(4 + szX + szY + 2 * n,\n\t\t\t\t\tgN - 4, gN - 3);\n\n\t\t\tint s = gN - 2;\n\t\t\tint t = gN - 1;\n\n\t\t\tif (pick + lowX[0] > highX[0]) {\n\t\t\t\tcontinue outer;\n\t\t\t}\n\t\t\tg.addLowerBound(s, 2 * n, pick, pick);\n\t\t\tfor (int i = 1; i < szX; i++) {\n\t\t\t\tint low = Math.max(pick + lowX[i], 0);\n\t\t\t\tint high = Math.min(highX[i], pick);\n\t\t\t\tif (low > high) {\n\t\t\t\t\tcontinue outer;\n\t\t\t\t}\n\t\t\t\tg.addLowerBound(2 * n + i - 1, 2 * n + i, low, high);\n\t\t\t}\n\n\t\t\tif (pick + lowY[0] > highY[0]) {\n\t\t\t\tcontinue outer;\n\t\t\t}\n\t\t\tg.addLowerBound(2 * n + szX, t, pick, pick);\n\t\t\tfor (int i = 1; i < szY; i++) {\n\t\t\t\tint low = Math.max(pick + lowY[i], 0);\n\t\t\t\tint high = Math.min(highY[i], pick);\n\t\t\t\tif (low > high) {\n\t\t\t\t\tcontinue outer;\n\t\t\t\t}\n\t\t\t\tg.addLowerBound(2 * n + szX + i, 2 * n + szX + i - 1, low, high);\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t// x >= ... -> jewel -> y >= ...\n\t\t\t\tg.addEdge(2 * n + a[i].x, i, 1, 0);\n\t\t\t\tg.addEdge(i + n, 2 * n + szX + a[i].y, 1, 0);\n\n\t\t\t\t// edge for jewel\n\t\t\t\tg.addEdge(i, i + n, 1, a[i].val);\n\t\t\t}\n\t\t\t\n\t\t\tg.addEdge(t, s, pick + 100, 0);\n\t\t\t\n\t\t\tlong[] flow = g.maxFlowMinCost();\n\t\t\tif (g.needFlow != flow[0]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n//\t\t\tSystem.err.println(pick + \" \" + (C * pick - flow[1]));\n\t\t\t\n\t\t\tans = Math.max(ans, C * pick - flow[1]);\n\t\t}\n\t\t\n\t\tout.println(ans);\n\t}\n\n\t// !!!!!!!!! ADD LONG\n\tstatic class MinCostFlowGraph {\n\t\t\n\t\tint needFlow = 0;\n\t\t\n\t\t\n\t\tint N, S, T;\n\t\tstatic final long INF = Long.MAX_VALUE / 3;\n\n\t\tList<MinCostFlowEdge>[] g;\n\t\tprivate long[] phi;\n\t\tfinal private long[] d;\n\t\tprivate boolean[] vis;\n\t\tprivate MinCostFlowEdge[] from;\n\n\t\tpublic MinCostFlowGraph(int n, int s, int t) {\n\t\t\tN = n;\n\t\t\tS = s;\n\t\t\tT = t;\n\t\t\tg = new List[N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tphi = new long[N];\n\t\t\tvis = new boolean[N];\n\t\t\td = new long[N];\n\t\t\tfrom = new MinCostFlowEdge[N];\n\n\t\t\tcache = new Integer[N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tcache[i] = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tvoid addLowerBound(int v1, int v2, int lowCap, int highCap) {\n\t\t\t\n\t\t\tneedFlow += lowCap;\n\t\t\t\n\t\t\tif (lowCap > highCap) {\n\t\t\t\tthrow new AssertionError();\n\t\t\t}\n\t\t\t\n\t\t\taddEdge(S, v2, lowCap, 0);\n\t\t\taddEdge(v1, T, lowCap, 0);\n\t\t\taddEdge(v1, v2, highCap - lowCap, 0);\n\t\t}\n\n\t\tvoid addEdge(int v1, int v2, int cap, long cost) {\n\t\t\t\n//\t\t\tSystem.err.println(v1 + \" -> \" + v2 + \" \" + cap + \"/\" + cost);\n\t\t\t\n\t\t\tMinCostFlowEdge e1 = new MinCostFlowEdge(v2, cap, cost);\n\t\t\tMinCostFlowEdge e2 = new MinCostFlowEdge(v1, 0, -cost);\n\t\t\te1.rev = e2;\n\t\t\te2.rev = e1;\n\t\t\tg[v1].add(e1);\n\t\t\tg[v2].add(e2);\n\t\t}\n\n\t\tInteger[] cache;\n\t\tTreeSet<Integer> set = new TreeSet<>();\n\n\t\tComparator<Integer> byDist = new Comparator<Integer>() {\n\n\t\t\t@Override\n\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\treturn Long.compare(d[o1], d[o2]);\n\t\t\t}\n\t\t};\n\n\t\tvoid findPathELogV() {\n\t\t\tset.clear();\n\t\t\tset.add(cache[S]);\n\t\t\tArrays.fill(d, INF);\n\t\t\tArrays.fill(vis, false);\n\t\t\td[S] = 0;\n\t\t\twhile (!set.isEmpty()) {\n\t\t\t\tint v = set.pollFirst();\n\t\t\t\tvis[v] = true;\n\t\t\t\tif (v == T)\n\t\t\t\t\tbreak;\n\t\t\t\tList<MinCostFlowEdge> adj = g[v];\n\t\t\t\tfor (int i = 0; i < adj.size(); i++) {\n\t\t\t\t\tMinCostFlowEdge e = adj.get(i);\n\t\t\t\t\tif (e.flow == e.cap)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (d[e.to] > d[v] + e.cost + phi[v] - phi[e.to]) {\n\t\t\t\t\t\tset.remove(cache[e.to]);\n\t\t\t\t\t\td[e.to] = d[v] + e.cost + phi[v] - phi[e.to];\n\t\t\t\t\t\tset.add(cache[e.to]);\n\t\t\t\t\t\tfrom[e.to] = e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid findPathV2() {\n\t\t\tArrays.fill(d, INF);\n\t\t\tArrays.fill(vis, false);\n\t\t\td[S] = 0;\n\t\t\twhile (true) {\n\t\t\t\tint v = -1;\n\t\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\t\tif (!vis[i] && (v == -1 || d[i] < d[v])) {\n\t\t\t\t\t\tv = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvis[v] = true;\n\t\t\t\tif (v == T)\n\t\t\t\t\tbreak;\n\t\t\t\tList<MinCostFlowEdge> adj = g[v];\n\t\t\t\tfor (int i = 0; i < adj.size(); i++) {\n\t\t\t\t\tMinCostFlowEdge e = adj.get(i);\n\t\t\t\t\tif (e.flow == e.cap)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (d[e.to] > d[v] + e.cost + phi[v] - phi[e.to]) {\n\t\t\t\t\t\td[e.to] = d[v] + e.cost + phi[v] - phi[e.to];\n\t\t\t\t\t\tfrom[e.to] = e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlong[] augmentFlow(long flowLeft) {\n\t\t\t// returns null if it can't be augmented\n\t\t\t// throw new\n\t\t\t// AssertionError(\"Uncomment one of findPath implementations\");\n\t\t\tfindPathELogV();\n\t\t\t// findPathV2();\n\t\t\tif (d[T] == INF) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tif (vis[i]) {\n\t\t\t\t\tphi[i] += d[i] - d[T];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlong addFlow = flowLeft;\n\t\t\tlong costPerFlowUnit = 0;\n\n\t\t\tfor (int v = T; v != S; v = from[v].rev.to) {\n\t\t\t\tMinCostFlowEdge e = from[v];\n\t\t\t\taddFlow = Math.min(addFlow, e.cap - e.flow);\n\t\t\t\tcostPerFlowUnit += e.cost;\n\t\t\t}\n\n\t\t\tfor (int v = T; v != S; v = from[v].rev.to) {\n\t\t\t\tMinCostFlowEdge e = from[v];\n\t\t\t\te.flow += addFlow;\n\t\t\t\te.rev.flow -= addFlow;\n\t\t\t}\n\n\t\t\treturn new long[] { addFlow, costPerFlowUnit };\n\t\t}\n\n\t\tlong[] maxFlowMinCost() {\n\t\t\tlong[] ret = new long[2];\n\t\t\twhile (true) {\n\t\t\t\tlong[] delta = augmentFlow(INF);\n\t\t\t\tif (delta == null)\n\t\t\t\t\tbreak;\n\t\t\t\tret[0] += delta[0];\n\t\t\t\tret[1] += delta[0] * delta[1];\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tstatic class MinCostFlowEdge {\n\t\tint to;\n\t\tint flow, cap;\n\n\t\tlong cost;\n\n\t\tMinCostFlowEdge rev;\n\n\t\tpublic MinCostFlowEdge(int to, int cap, long cost) {\n\t\t\tthis.to = to;\n\t\t\tthis.cap = cap;\n\t\t\tthis.cost = cost;\n\t\t}\n\t}\n\n\tint[] unique(int[] a) {\n\t\ta = a.clone();\n\t\tint sz = 0;\n\t\tArrays.sort(a);\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tif (sz == 0 || a[i] != a[sz - 1]) {\n\t\t\t\ta[sz++] = a[i];\n\t\t\t}\n\t\t}\n\t\treturn Arrays.copyOf(a, sz);\n\t}\n\n\tvoid test() {\n\n\t}\n\n\tvoid stress() {\n\t\tfor (int tst = 0;; tst++) {\n\t\t\tif (false) {\n\t\t\t\tthrow new AssertionError();\n\t\t\t}\n\t\t\tSystem.err.println(tst);\n\t\t}\n\t}\n\n\tMain() throws IOException {\n\t\tis = System.in;\n\t\tout = new PrintWriter(System.out);\n\t\tsubmit();\n\t\t// stress();\n\t\t// test();\n\t\tout.close();\n\t}\n\n\tstatic final Random rng = new Random();\n\n\tstatic int rand(int l, int r) {\n\t\treturn l + rng.nextInt(r - l + 1);\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main();\n\t}\n\n\tprivate InputStream is;\n\tPrintWriter out;\n\n\tprivate byte[] buf = new byte[1 << 14];\n\tprivate int bufSz = 0, bufPtr = 0;\n\n\tprivate int readByte() {\n\t\tif (bufSz == -1)\n\t\t\tthrow new RuntimeException(\"Reading past EOF\");\n\t\tif (bufPtr >= bufSz) {\n\t\t\tbufPtr = 0;\n\t\t\ttry {\n\t\t\t\tbufSz = is.read(buf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t\tif (bufSz <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn buf[bufPtr++];\n\t}\n\n\tprivate boolean isTrash(int c) {\n\t\treturn c < 33 || c > 126;\n\t}\n\n\tprivate int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isTrash(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tString nextToken() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!isTrash(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tString nextString() {\n\t\tint b = readByte();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!isTrash(b) || b == ' ') {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tdouble nextDouble() {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n\tchar nextChar() {\n\t\treturn (char) skip();\n\t}\n\n\tint nextInt() {\n\t\tint ret = 0;\n\t\tint b = skip();\n\t\tif (b != '-' && (b < '0' || b > '9')) {\n\t\t\tthrow new InputMismatchException();\n\t\t}\n\t\tboolean neg = false;\n\t\tif (b == '-') {\n\t\t\tneg = true;\n\t\t\tb = readByte();\n\t\t}\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tret = ret * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\tif (b != -1 && !isTrash(b)) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\treturn neg ? -ret : ret;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tlong nextLong() {\n\t\tlong ret = 0;\n\t\tint b = skip();\n\t\tif (b != '-' && (b < '0' || b > '9')) {\n\t\t\tthrow new InputMismatchException();\n\t\t}\n\t\tboolean neg = false;\n\t\tif (b == '-') {\n\t\t\tneg = true;\n\t\t\tb = readByte();\n\t\t}\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tret = ret * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\tif (b != -1 && !isTrash(b)) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\treturn neg ? -ret : ret;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.PrintStream;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.util.Random;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.math.BigInteger;\nimport java.util.Collections;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author ilyakor\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskE solver = new TaskE();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskE {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            Random random = new Random(0xdead);\n\n//        for (int it = 0; it < 10000; ++it) {\n//            int n = random.nextInt(32) + 1;\n//            int[] X = new int[n];\n//            int[] Y = new int[n];\n//            long[] V = new long[n];\n//            for (int i = 0;i < n; ++i) {\n//              X[i] = random.nextInt(100);\n//              Y[i] = random.nextInt(100);\n//              V[i] = Math.abs(random.nextLong() % (long)(1e15)) + 1;\n//            }\n//            int m = random.nextInt(32);\n//            int[] T = new int[m];\n//            int[] coord = new int[m];\n//            int[] lim = new int[m];\n//            for (int i = 0; i < m; ++i) {\n//                char c = \"LRDU\".charAt(random.nextInt(4));\n//                T[i] = c;\n//                coord[i] = random.nextInt(100);\n//                lim[i] = random.nextInt(100);\n//            }\n//            long res = megaSolve(n, X, Y, V, m, T, coord, lim);\n////            res.longValue();\n//            System.err.println(it);\n//        }\n\n            int n = in.nextInt();\n//        int n = 80;\n            int[] X = new int[n];\n            int[] Y = new int[n];\n            long[] V = new long[n];\n            for (int i = 0; i < n; ++i) {\n                X[i] = in.nextInt();\n                Y[i] = in.nextInt();\n                V[i] = in.nextLong();\n//            X[i] = random.nextInt(100);\n//            Y[i] = random.nextInt(100);\n//            V[i] = Math.abs(random.nextLong() % (long)(1e15));\n            }\n            int m = in.nextInt();\n//        int m = 320;\n            int[] T = new int[m];\n            int[] coord = new int[m];\n            int[] lim = new int[m];\n            for (int i = 0; i < m; ++i) {\n                char c = in.nextToken().toCharArray()[0];\n//            char c = \"LRDU\".charAt(random.nextInt(4));\n                T[i] = c;\n                coord[i] = in.nextInt();\n                lim[i] = in.nextInt();\n//            coord[i] = random.nextInt(100);\n//            lim[i] = random.nextInt(1000);\n\n            }\n\n            long res = megaSolve(n, X, Y, V, m, T, coord, lim);\n            out.printLine(Math.max(0, res));\n        }\n\n        public long megaSolve(int n, int[] x, int[] y, long[] v, int m, int[] t, int[] coord, int[] lim) {\n            boolean[][] matches = new boolean[m][n];\n\n            for (int i = 0; i < m; ++i) {\n                char c = (char) t[i];\n                for (int j = 0; j < n; ++j) {\n                    if (c == 'L') matches[i][j] = (x[j] <= coord[i]);\n                    if (c == 'R') matches[i][j] = (x[j] >= coord[i]);\n                    if (c == 'D') matches[i][j] = (y[j] <= coord[i]);\n                    if (c == 'U') matches[i][j] = (y[j] >= coord[i]);\n                }\n            }\n\n            Rational[][] a = new Rational[m + n][n];\n            for (int i = 0; i < m; ++i)\n                for (int j = 0; j < n; ++j)\n                    a[i][j] = matches[i][j] ? Rational.ONE : Rational.ZERO;\n            for (int i = 0; i < n; ++i)\n                for (int j = 0; j < n; ++j) {\n                    a[m + i][j] = (i == j ? Rational.ONE : Rational.ZERO);\n//                a[m + n + i][j] = (i == j ? Rational.ONE : Rational.ZERO).negate();\n                }\n            Rational[] b = new Rational[m + n];\n            for (int i = 0; i < m; ++i)\n                b[i] = Rational.valueOf(lim[i]);\n            for (int i = 0; i < n; ++i) {\n                b[m + i] = Rational.ONE;\n//            b[m + n + i] = Rational.ZERO;\n            }\n            Rational[] c = new Rational[n];\n            for (int i = 0; i < n; ++i)\n                c[i] = Rational.valueOf(v[i]);\n            Rational[] X = new Rational[n];\n            Simplex.simplex(a, b, c, X);\n//        for (int i = 0; i < n; ++i)\n//            System.err.print(v[i] + \" * \" + X[i].toString() + \" \");\n//        System.err.println();\n            int[] vals = new int[n];\n            int nhalf = 0;\n            for (int i = 0; i < n; ++i) {\n                if (X[i].den.equals(BigInteger.ONE)) {\n                    vals[i] = X[i].num.equals(BigInteger.ONE) ? 2 : 0;\n                } else {\n                    Assert.assertTrue(X[i].den.equals(BigInteger.valueOf(2)));\n                    vals[i] = X[i].num.equals(BigInteger.ONE) ? 1 : 0;\n                    if (vals[i] == 1) ++nhalf;\n                }\n            }\n\n            long res = 0;\n            for (int i = 0; i < n; ++i)\n                if (vals[i] == 2)\n                    res += v[i];\n            int[] sat = new int[m];\n            for (int i = 0; i < n; ++i)\n                for (int j = 0; j < m; ++j)\n                    if (matches[j][i])\n                        sat[j] += vals[i];\n\n            ArrayList<Integer>[] g = new ArrayList[nhalf];\n            long[] nv = new long[nhalf];\n            for (int i = 0; i < g.length; ++i)\n                g[i] = new ArrayList<>();\n            nhalf = 0;\n            for (int i = 0; i < n; ++i) {\n                if (vals[i] != 1) continue;\n                nv[nhalf] = v[i];\n                for (int j = 0; j < m; ++j) {\n                    Assert.assertTrue(sat[j] <= 2 * lim[j]);\n                    if (sat[j] == 2 * lim[j])\n                        g[nhalf].add(j);\n                }\n                ++nhalf;\n            }\n            res += brute(g, nv);\n            return res;\n        }\n\n        private long brute(ArrayList<Integer>[] g, long[] v) {\n            int n = g.length;\n            if (n == 0) return 0;\n            ArrayList<Integer>[] rg = new ArrayList[400];\n            for (int i = 0; i < rg.length; ++i)\n                rg[i] = new ArrayList<>();\n            for (int i = 0; i < n; ++i) {\n                Assert.assertTrue(!g[i].isEmpty());\n                for (int x : g[i])\n                    rg[x].add(i);\n            }\n            ArrayList<Integer> order = new ArrayList<>();\n            for (int i = 0; i < n; ++i)\n                order.add(i);\n            Random random = new Random(0xbeef);\n            long res = 0;\n            for (int it = 0; it < 1000; ++it) {\n                Collections.shuffle(order, random);\n                long cur = 0;\n                boolean[] alive = new boolean[n];\n                Arrays.fill(alive, true);\n                for (int x : order) {\n                    if (!alive[x]) continue;\n                    cur += v[x];\n                    for (int y : g[x])\n                        for (int z : rg[y])\n                            alive[z] = false;\n                }\n                res = Math.max(res, cur);\n            }\n            if (res == 0) {\n                System.err.println(n);\n                for (int i = 0; i < n; ++i)\n                    System.err.println(v[i]);\n            }\n            Assert.assertTrue(res > 0);\n            return res;\n        }\n\n    }\n\n    static class Simplex {\n        public static Rational simplex(Rational[][] A, Rational[] b, Rational[] c, Rational[] x) {\n            int m = A.length;\n            int n = A[0].length + 1;\n            int[] index = new int[n + m];\n            for (int i = 0; i < n + m; i++) {\n                index[i] = i;\n            }\n            Rational[][] a = new Rational[m + 2][n + 1];\n            for (Rational[] a1 : a) {\n                Arrays.fill(a1, Rational.ZERO);\n            }\n            int L = m;\n            for (int i = 0; i < m; i++) {\n                for (int j = 0; j < n - 1; j++) {\n                    a[i][j] = A[i][j].negate();\n                }\n                a[i][n - 1] = Rational.ONE;\n                a[i][n] = b[i];\n                if (a[L][n].compareTo(a[i][n]) > 0) {\n                    L = i;\n                }\n            }\n            for (int j = 0; j < n - 1; j++) {\n                a[m][j] = c[j];\n            }\n            a[m + 1][n - 1] = Rational.ONE.negate();\n            for (int E = n - 1; ; ) {\n                if (L < m) {\n                    int t = index[E];\n                    index[E] = index[L + n];\n                    index[L + n] = t;\n                    a[L][E] = a[L][E].inverse();\n                    for (int j = 0; j <= n; j++) {\n                        if (j != E) {\n                            a[L][j] = a[L][j].mul(a[L][E].negate());\n                        }\n                    }\n                    for (int i = 0; i <= m + 1; i++) {\n                        if (i != L) {\n                            for (int j = 0; j <= n; j++) {\n                                if (j != E) {\n                                    a[i][j] = a[i][j].add(a[L][j].mul(a[i][E]));\n                                }\n                            }\n                            a[i][E] = a[i][E].mul(a[L][E]);\n                        }\n                    }\n                }\n                E = -1;\n                for (int j = 0; j < n; j++) {\n                    if (E < 0 || index[E] > index[j]) {\n                        if (a[m + 1][j].signum() > 0 || a[m + 1][j].signum() == 0 && a[m][j].signum() > 0) {\n                            E = j;\n                        }\n                    }\n                }\n                if (E < 0) {\n                    break;\n                }\n                L = -1;\n                for (int i = 0; i < m; i++) {\n                    if (a[i][E].signum() < 0) {\n                        Rational d;\n                        if (L < 0 || (d = a[L][n].div(a[L][E]).sub(a[i][n].div(a[i][E]))).signum() < 0 || d.signum() == 0\n                                && index[L + n] > index[i + n]) {\n                            L = i;\n                        }\n                    }\n                }\n                if (L < 0) {\n                    return Rational.POSITIVE_INFINITY;\n                }\n            }\n            if (a[m + 1][n].signum() < 0) {\n                return null;\n            }\n            if (x != null) {\n                Arrays.fill(x, Rational.ZERO);\n                for (int i = 0; i < m; i++)\n                    if (index[n + i] < n - 1)\n                        x[index[n + i]] = a[i][n];\n            }\n            return a[m][n];\n        }\n\n    }\n\n    static class Assert {\n        public static void assertTrue(boolean flag) {\n//        if (!flag)\n//        while (true);\n            if (!flag)\n                throw new AssertionError();\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buffer = new byte[10000];\n        private int cur;\n        private int count;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public static boolean isSpace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public int read() {\n            if (count == -1) {\n                throw new InputMismatchException();\n            }\n            try {\n                if (cur >= count) {\n                    cur = 0;\n                    count = stream.read(buffer);\n                    if (count <= 0)\n                        return -1;\n                }\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            return buffer[cur++];\n        }\n\n        public int readSkipSpace() {\n            int c;\n            do {\n                c = read();\n            } while (isSpace(c));\n            return c;\n        }\n\n        public String nextToken() {\n            int c = readSkipSpace();\n            StringBuilder sb = new StringBuilder();\n            while (!isSpace(c)) {\n                sb.append((char) c);\n                c = read();\n            }\n            return sb.toString();\n        }\n\n        public int nextInt() {\n            int sgn = 1;\n            int c = readSkipSpace();\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res = res * 10 + c - '0';\n                c = read();\n            } while (!isSpace(c));\n            res *= sgn;\n            return res;\n        }\n\n        public long nextLong() {\n            long sgn = 1;\n            int c = readSkipSpace();\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res = res * 10L + (long) (c - '0');\n                c = read();\n            } while (!isSpace(c));\n            res *= sgn;\n            return res;\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(objects[i]);\n            }\n        }\n\n        public void printLine(Object... objects) {\n            print(objects);\n            writer.println();\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n    }\n\n    static class Rational implements Comparable<Rational> {\n        public BigInteger num;\n        public BigInteger den;\n        public static final Rational ZERO = new Rational(0);\n        public static final Rational ONE = new Rational(1);\n        public static final Rational POSITIVE_INFINITY = new Rational(1, 0);\n\n        public Rational(long num) {\n            this.num = BigInteger.valueOf(num);\n            this.den = BigInteger.ONE;\n        }\n\n        public Rational(long num, long den) {\n            this(BigInteger.valueOf(num), BigInteger.valueOf(den));\n        }\n\n        public Rational(BigInteger num, BigInteger den) {\n            this.num = num;\n            this.den = den;\n            reduce();\n        }\n\n        void reduce() {\n            if (!den.abs().equals(BigInteger.ONE)) {\n                BigInteger gcd = num.gcd(den);\n                if (gcd.signum() != 0 && !gcd.equals(BigInteger.ONE)) {\n                    num = num.divide(gcd);\n                    den = den.divide(gcd);\n                }\n            }\n            if (den.signum() < 0 || den.signum() == 0 && num.signum() < 0) {\n                num = num.negate();\n                den = den.negate();\n            }\n        }\n\n        public Rational add(Rational r) {\n            return new Rational(num.multiply(r.den).add(r.num.multiply(den)), den.multiply(r.den));\n        }\n\n        public Rational sub(Rational r) {\n            return new Rational(num.multiply(r.den).subtract(r.num.multiply(den)), den.multiply(r.den));\n        }\n\n        public Rational mul(Rational r) {\n            return new Rational(num.multiply(r.num), den.multiply(r.den));\n        }\n\n        public Rational div(Rational r) {\n            return new Rational(num.multiply(r.den), den.multiply(r.num));\n        }\n\n        public Rational negate() {\n            return new Rational(num.negate(), den);\n        }\n\n        public Rational inverse() {\n            return new Rational(den, num);\n        }\n\n        public int signum() {\n            return num.signum();\n        }\n\n        public int compareTo(Rational other) {\n            return (num.multiply(other.den).compareTo(other.num.multiply(den)));\n        }\n\n        public boolean equals(Object obj) {\n            return num.equals(((Rational) obj).num) && den.equals(((Rational) obj).den);\n        }\n\n        public int hashCode() {\n            return num.hashCode() * 31 + den.hashCode();\n        }\n\n        public String toString() {\n            return num + \"/\" + den;\n        }\n\n        public static Rational valueOf(long x) {\n            return new Rational(x);\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing Debug = System.Diagnostics.Trace;\nusing SB = System.Text.StringBuilder;\nusing static System.Math;\nusing Number = System.Int32;\n\nusing C = System.Int32;\nusing V = System.Int64;\nnamespace Program {\n\tpublic class Solver {\n\t\tRandom rnd = new Random();\n\t\tpublic void Solve() {\n\t\t\tvar n = ri;\n\t\t\tvar P = Enumerate(n, x => new KeyValuePair<int[], long>(new int[] { ri, ri }, rl));\n\t\t\tvar m = ri;\n\t\t\tvar Q = Enumerate(m, x => new KeyValuePair<char, int[]>(rs[0], new int[] { ri, ri }));\n\t\t\tvar ans = 0L;\n\n\t\t\tconst int X = 102;\n\t\t\tfor (int k = 1; k <= n; k++) {\n\t\t\t\tvar G = new MinCostFlow(2 * X + 2);\n\t\t\t\tvar src = 2 * X;\n\t\t\t\tvar sink = src + 1;\n\n\t\t\t\tvar s = new string[] { \"LR\", \"DU\" };\n\t\t\t\tfor (int p = 0; p < 2; p++) {\n\t\t\t\t\tvar pat = s[p];\n\t\t\t\t\tvar R = new int[X];\n\t\t\t\t\tvar L = new int[X];\n\t\t\t\t\tfor (int i = 0; i < X; i++) R[i] = k;\n\t\t\t\t\tforeach (var x in Q) {\n\t\t\t\t\t\tvar u = x.Value[0];\n\t\t\t\t\t\tvar v = Min(k, x.Value[1]);\n\t\t\t\t\t\tif (x.Key == pat[0]) {\n\t\t\t\t\t\t\tR[u] = Min(R[u], v);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (x.Key == pat[1]) {\n\t\t\t\t\t\t\tL[u - 1] = Max(L[u - 1], k - v);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tL[X - 1] = R[X - 1] = k;\n\t\t\t\t\tfor (int i = 1; i < X; i++)\n\t\t\t\t\t\tL[i] = Max(L[i], L[i - 1]);\n\t\t\t\t\tfor (int i = X - 2; i >= 0; i--)\n\t\t\t\t\t\tR[i] = Min(R[i], R[i + 1]);\n\t\t\t\t\tDebug.WriteLine(L.AsJoinedString());\n\t\t\t\t\tDebug.WriteLine(R.AsJoinedString());\n\n\t\t\t\t\t//x座標が i 以下のやつは L[i] 以上 R[i] 以下\n\t\t\t\t\tfor (int i = 0; i < X; i++) {\n\t\t\t\t\t\tif (p == 0) {\n\t\t\t\t\t\t\tvar cap = i == 0 ? L[i] : L[i] - L[i - 1];\n\t\t\t\t\t\t\tG.AddDirectedEdge(src, i, cap, 0);\n\t\t\t\t\t\t\tif (i > 0)\n\t\t\t\t\t\t\t\tG.AddDirectedEdge(i, i - 1, R[i - 1] - L[i - 1], 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tvar cap = i == 0 ? L[i] : L[i] - L[i - 1];\n\t\t\t\t\t\t\tG.AddDirectedEdge(X + i, sink, cap, 0);\n\t\t\t\t\t\t\tif (i > 0)\n\t\t\t\t\t\t\t\tG.AddDirectedEdge(X + i - 1, X + i, R[i - 1] - L[i - 1], 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tforeach (var x in P) {\n\t\t\t\t\tvar u = x.Key;\n\t\t\t\t\tvar v = x.Value;\n\t\t\t\t\tDebug.WriteLine($\"{u[0]} {u[1]} {v}\");\n\t\t\t\t\tG.AddDirectedEdge(u[0], X + u[1], 1, -v);\n\t\t\t\t}\n\n\t\t\t\tvar res = G.Execute(src, sink, k);\n\t\t\t\tDebug.WriteLine(res);\n\t\t\t\tif (res.Key == k) ans = Max(ans, -res.Value);\n\t\t\t\t/*\n\t\t\t\tfor (int i = 0; i < X; i++)\n\t\t\t\t\tforeach (var e in G.G[i])\n\t\t\t\t\t\tif (e.To >= X && e.To != src && e.Cap == 0)\n\t\t\t\t\t\t\tConsole.WriteLine($\"{i} {e.To - X} {-e.Cost}\");\n\t\t\t\t\t\t\t*/\n\t\t\t}\n\t\t\tConsole.WriteLine(ans);\n\t\t}\n\n\t\tconst long INF = 1L << 60;\n\t\tstatic int[] dx = { -1, 0, 1, 0 };\n\t\tstatic int[] dy = { 0, 1, 0, -1 };\n\t\tint ri { get { return sc.Integer(); } }\n\t\tlong rl { get { return sc.Long(); } }\n\t\tdouble rd { get { return sc.Double(); } }\n\t\tstring rs { get { return sc.Scan(); } }\n\t\tpublic IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n\t\tstatic T[] Enumerate<T>(int n, Func<int, T> f) {\n\t\t\tvar a = new T[n];\n\t\t\tfor (int i = 0; i < a.Length; ++i) a[i] = f(i);\n\t\t\treturn a;\n\t\t}\n\t\tstatic public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n\t}\n}\n\n#region main\nstatic class Ex {\n\tstatic public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n\tstatic public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n\t\treturn string.Join(st, ie);\n\t}\n\tstatic public void Main() {\n\t\tConsole.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = true });\n\t\tvar solver = new Program.Solver();\n\t\t//* \n\t\tvar t = new System.Threading.Thread(solver.Solve, 50000000);\n\t\tt.Start();\n\t\tt.Join();\n\t\t//*/\n\t\t// solver.Solve();\n\t\tConsole.Out.Flush();\n\t}\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n\tusing System.IO;\n\tusing System.Text;\n\tusing System.Globalization;\n\n\tpublic class Printer : StreamWriter {\n\t\tpublic override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n\t\tpublic Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n\t}\n\n\tpublic class StreamScanner {\n\t\tpublic StreamScanner(Stream stream) { str = stream; }\n\n\t\tpublic readonly Stream str;\n\t\tprivate readonly byte[] buf = new byte[1024];\n\t\tprivate int len, ptr;\n\t\tpublic bool isEof = false;\n\t\tpublic bool IsEndOfStream { get { return isEof; } }\n\n\t\tprivate byte read() {\n\t\t\tif (isEof) return 0;\n\t\t\tif (ptr >= len) {\n\t\t\t\tptr = 0;\n\t\t\t\tif ((len = str.Read(buf, 0, 1024)) <= 0) {\n\t\t\t\t\tisEof = true;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn buf[ptr++];\n\t\t}\n\n\t\tpublic char Char() {\n\t\t\tbyte b = 0;\n\t\t\tdo b = read(); while ((b < 33 || 126 < b) && !isEof);\n\t\t\treturn (char)b;\n\t\t}\n\t\tpublic string Scan() {\n\t\t\tvar sb = new StringBuilder();\n\t\t\tfor (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n\t\t\treturn sb.ToString();\n\t\t}\n\t\tpublic string ScanLine() {\n\t\t\tvar sb = new StringBuilder();\n\t\t\tfor (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n\t\t\treturn sb.ToString();\n\t\t}\n\t\tpublic long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n\t\tpublic int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n\t\tpublic double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n\t}\n}\n\n#endregion\n\n#region Set\n/// <summary>\n/// 要素の追加、削除、検索、取得が可能な集合を表します．\n/// </summary>\n/// <typeparam name=\"T\">優先度付きキュー内の要素の型を指定します．</typeparam>\n/// <remarks>内部的にはAVL木によって実装されています．</remarks>\npublic class Set<T> {\n\tNode root;\n\treadonly IComparer<T> comparer;\n\treadonly Node nil;\n\t/// <summary>\n\t/// 多重集合かどうかを表します．\n\t/// </summary>\n\tpublic bool IsMultiSet { get; set; }\n\tpublic Set(IComparer<T> comparer) {\n\t\tnil = new Node(default(T));\n\t\troot = nil;\n\t\tthis.comparer = comparer;\n\t}\n\tpublic Set(Comparison<T> comaprison) : this(Comparer<T>.Create(comaprison)) { }\n\tpublic Set() : this(Comparer<T>.Default) { }\n\t/// <summary>\n\t/// 要素をコレクションに追加します．\n\t/// </summary>\n\t/// <remarks>この操作は計算量 O(log N) で実行されます．</remarks>\n\tpublic bool Add(T v) {\n\t\treturn insert(ref root, v);\n\t}\n\t/// <summary>\n\t/// v が存在するならコレクションから削除します．\n\t/// </summary>\n\t/// <remarks>この操作は計算量 O(log N) で実行されます．</remarks>\n\tpublic bool Remove(T v) {\n\t\treturn remove(ref root, v);\n\t}\n\t/// <summary>\n\t/// 0-indexed で index 番目の要素をコレクションから取得します．．\n\t/// </summary>\n\t/// <remarks>この操作は計算量 O(log N) で実行されます．</remarks>\n\tpublic T this[int index] { get { return find(root, index); } }\n\tpublic int Count { get { return root.Count; } }\n\tpublic void RemoveAt(int k) {\n\t\tif (k < 0 || k >= root.Count) throw new ArgumentOutOfRangeException();\n\t\tremoveAt(ref root, k);\n\t}\n\t/// <summary>\n\t/// このコレクションに含まれる要素を昇順に並べて返します．\n\t/// </summary>\n\t/// <remarks>この操作は計算量 O(N) で実行されます．</remarks>\n\tpublic T[] Items {\n\t\tget {\n\t\t\tvar ret = new T[root.Count];\n\t\t\tvar k = 0;\n\t\t\twalk(root, ret, ref k);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tvoid walk(Node t, T[] a, ref int k) {\n\t\tif (t.Count == 0) return;\n\t\twalk(t.lst, a, ref k);\n\t\ta[k++] = t.Key;\n\t\twalk(t.rst, a, ref k);\n\t}\n\n\tbool insert(ref Node t, T key) {\n\t\tif (t.Count == 0) { t = new Node(key); t.lst = t.rst = nil; t.Update(); return true; }\n\t\tvar cmp = comparer.Compare(t.Key, key);\n\t\tbool res;\n\t\tif (cmp > 0)\n\t\t\tres = insert(ref t.lst, key);\n\t\telse if (cmp == 0) {\n\t\t\tif (IsMultiSet) res = insert(ref t.lst, key);\n\t\t\telse return false;\n\t\t}\n\t\telse res = insert(ref t.rst, key);\n\t\tbalance(ref t);\n\t\treturn res;\n\t}\n\tbool remove(ref Node t, T key) {\n\t\tif (t.Count == 0) return false;\n\t\tvar cmp = comparer.Compare(key, t.Key);\n\t\tbool ret;\n\t\tif (cmp < 0) ret = remove(ref t.lst, key);\n\t\telse if (cmp > 0) ret = remove(ref t.rst, key);\n\t\telse {\n\t\t\tret = true;\n\t\t\tvar k = t.lst.Count;\n\t\t\tif (k == 0) { t = t.rst; return true; }\n\t\t\tif (t.rst.Count == 0) { t = t.lst; return true; }\n\n\n\t\t\tt.Key = find(t.lst, k - 1);\n\t\t\tremoveAt(ref t.lst, k - 1);\n\t\t}\n\t\tbalance(ref t);\n\t\treturn ret;\n\t}\n\tvoid removeAt(ref Node t, int k) {\n\t\tvar cnt = t.lst.Count;\n\t\tif (cnt < k) removeAt(ref t.rst, k - cnt - 1);\n\t\telse if (cnt > k) removeAt(ref t.lst, k);\n\t\telse {\n\t\t\tif (cnt == 0) { t = t.rst; return; }\n\t\t\tif (t.rst.Count == 0) { t = t.lst; return; }\n\n\t\t\tt.Key = find(t.lst, k - 1);\n\t\t\tremoveAt(ref t.lst, k - 1);\n\t\t}\n\t\tbalance(ref t);\n\t}\n\tvoid balance(ref Node t) {\n\t\tvar balance = t.lst.Height - t.rst.Height;\n\t\tif (balance == -2) {\n\t\t\tif (t.rst.lst.Height - t.rst.rst.Height > 0) { rotR(ref t.rst); }\n\t\t\trotL(ref t);\n\t\t}\n\t\telse if (balance == 2) {\n\t\t\tif (t.lst.lst.Height - t.lst.rst.Height < 0) rotL(ref t.lst);\n\t\t\trotR(ref t);\n\t\t}\n\t\telse t.Update();\n\t}\n\n\tT find(Node t, int k) {\n\t\tif (k < 0 || k > root.Count) throw new ArgumentOutOfRangeException();\n\t\tfor (; ; )\n\t\t{\n\t\t\tif (k == t.lst.Count) return t.Key;\n\t\t\telse if (k < t.lst.Count) t = t.lst;\n\t\t\telse { k -= t.lst.Count + 1; t = t.rst; }\n\t\t}\n\t}\n\t/// <summary>\n\t/// コレクションに含まれる要素であって、 v 以上の最小の要素の番号を返します。\n\t/// </summary>\n\t/// <remarks>この操作は計算量 O(log N) で実行されます．</remarks>\n\tpublic int LowerBound(T v) {\n\t\tvar k = 0;\n\t\tvar t = root;\n\t\tfor (; ; )\n\t\t{\n\t\t\tif (t.Count == 0) return k;\n\t\t\tif (comparer.Compare(v, t.Key) <= 0) t = t.lst;\n\t\t\telse { k += t.lst.Count + 1; t = t.rst; }\n\t\t}\n\t}\n\t/// <summary>\n\t/// コレクションに含まれる要素であって、 v より真に大きい、最小の要素の番号を返します。\n\t/// </summary>\n\t/// <remarks>この操作は計算量 O(log N) で実行されます．</remarks>\n\tpublic int UpperBound(T v) {\n\t\tvar k = 0;\n\t\tvar t = root;\n\t\tfor (; ; )\n\t\t{\n\t\t\tif (t.Count == 0) return k;\n\t\t\tif (comparer.Compare(t.Key, v) <= 0) { k += t.lst.Count + 1; t = t.rst; }\n\t\t\telse t = t.lst;\n\t\t}\n\t}\n\n\tvoid rotR(ref Node t) {\n\t\tvar l = t.lst;\n\t\tt.lst = l.rst;\n\t\tl.rst = t;\n\t\tt.Update();\n\t\tl.Update();\n\t\tt = l;\n\t}\n\tvoid rotL(ref Node t) {\n\t\tvar r = t.rst;\n\t\tt.rst = r.lst;\n\t\tr.lst = t;\n\t\tt.Update();\n\t\tr.Update();\n\t\tt = r;\n\t}\n\n\n\tclass Node {\n\t\tpublic Node(T key) {\n\t\t\tKey = key;\n\t\t}\n\t\tpublic int Count { get; private set; }\n\t\tpublic sbyte Height { get; private set; }\n\t\tpublic T Key { get; set; }\n\t\tpublic Node lst, rst;\n\t\tpublic void Update() {\n\t\t\tCount = 1 + lst.Count + rst.Count;\n\t\t\tHeight = (sbyte)(1 + Math.Max(lst.Height, rst.Height));\n\t\t}\n\t\tpublic override string ToString() {\n\t\t\treturn string.Format(\"Count = {0}, Key = {1}\", Count, Key);\n\t\t}\n\t}\n}\n#endregion\n\n#region Mincost Flow\n/// <summary>\n/// 辺の追加を行い，最小費用流を求めることが可能なグラフです．\n/// </summary>\npublic class MinCostFlow {\n\tbool hasng;\n\tpublic readonly List<Edge>[] G;\n\t/// <summary>\n\t/// 頂点数 <paramref name=\"V\"/> で辺が存在しないグラフを構築します．\n\t/// </summary>\n\t/// <param name=\"V\">頂点の数</param>\n\t/// <remarks>この操作は O(<paramref name=\"V\"/>) で実行されます．</remarks>\n\tpublic MinCostFlow(int V) {\n\t\tG = new List<Edge>[V];\n\t\tfor (int i = 0; i < V; i++)\n\t\t\tG[i] = new List<Edge>();\n\n\t}\n\t/// <summary>\n\t/// 頂点 <paramref name=\"from\"/> から頂点 <paramref name=\"to\"/> への容量 <paramref name=\"cap\"/> ，コスト <paramref name=\"cost\"/> の有向辺を追加します．\n\t/// </summary>\n\t/// <param name=\"from\">始点となる頂点の 0-indexed での番号</param>\n\t/// <param name=\"to\">終点となる頂点の 0-indexed での番号</param>\n\t/// <param name=\"cap\">辺の容量</param>\n\t/// <param name=\"cost\">辺のコスト</param>\n\t/// <remarks>この操作は O(1) で実行されます．</remarks>\n\tpublic void AddDirectedEdge(int from, int to, C cap, V cost) {\n\t\taddEdge(from, to, cap, 0, cost);\n\t}\n\n\t/// <summary>\n\t/// 頂点 <paramref name=\"src\"/> から頂点 <paramref name=\"sink\"/> へ最大で流量 <paramref name=\"f\"/> だけ最小費用フローを流します．\n\t/// </summary>\n\t/// <param name=\"src\">ソースとなる頂点の 0-indexed での番号</param>\n\t/// <param name=\"sink\">シンクとなる頂点の 0-indexed での番号</param>\n\t/// <param name=\"f\">ソースからシンクへと流す最大の容量．-1を指定した場合，最小費用最大流を求める．</param>\n\t/// <param name=\"inf\">ソースからシンクまでの距離の最大値</param>\n\t/// <remarks>この操作はPrimal Dual法に基づき，最悪計算量 O(VE + FE log V) で実行されます．Vは頂点の数，Eは辺の数，Fは流量を表します．</remarks>\n\tpublic KeyValuePair<C, V> Execute(int src, int sink, C f = C.MaxValue, V inf = V.MaxValue / 3) {\n\t\tvar n = G.Length;\n\t\tvar dist = new V[n];\n\t\tvar prev = new int[n];\n\t\tvar prevEdge = new Edge[n];\n\t\tvar potential = new V[n];\n\n\n\t\tC flow = 0;\n\t\tV cost = 0;\n\t\tvar first = hasng;\n\t\twhile (f > 0) {\n\t\t\tfor (int i = 0; i < G.Length; i++)\n\t\t\t\tdist[i] = inf;\n\n\t\t\t//shortest path\n\t\t\tif (first)//spfa\n\t\t\t{\n\t\t\t\tvar q = new Queue<int>();\n\t\t\t\tq.Enqueue(src); dist[src] = 0;\n\t\t\t\tvar inQ = new bool[n];\n\t\t\t\twhile (q.Count > 0) {\n\t\t\t\t\tvar p = q.Dequeue();\n\t\t\t\t\tinQ[p] = false;\n\t\t\t\t\tforeach (var e in G[p]) {\n\t\t\t\t\t\tvar t = e.To;\n\t\t\t\t\t\tvar d = dist[p] + e.Cost;\n\t\t\t\t\t\tif (e.Cap > 0 && d < dist[t]) {\n\t\t\t\t\t\t\tif (!inQ[t]) {\n\t\t\t\t\t\t\t\tinQ[t] = true;\n\t\t\t\t\t\t\t\tq.Enqueue(t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdist[t] = d; prev[t] = p; prevEdge[t] = e;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfirst = false;\n\t\t\t}\n\t\t\telse//dijkstra\n\t\t\t{\n\t\t\t\tvar vis = new bool[n];\n\t\t\t\tvar pq = new PriorityQueue<KeyValuePair<int, V>>((l, r) => l.Value.CompareTo(r.Value));\n\t\t\t\tpq.Enqueue(new KeyValuePair<int, V>(src, 0));\n\t\t\t\tdist[src] = 0;\n\t\t\t\twhile (pq.Count > 0) {\n\t\t\t\t\tvar p = pq.Dequeue().Key;\n\t\t\t\t\tif (vis[p]) continue;\n\t\t\t\t\tvis[p] = true;\n\t\t\t\t\tforeach (var e in G[p]) {\n\t\t\t\t\t\tif (e.Cap <= 0) continue;\n\t\t\t\t\t\tvar t = e.To;\n\t\t\t\t\t\tif (vis[t]) continue;\n\t\t\t\t\t\tvar d = dist[p] + e.Cost + potential[p] - potential[t];\n\t\t\t\t\t\tif (dist[t] > d) {\n\t\t\t\t\t\t\tdist[t] = d; prev[t] = p; prevEdge[t] = e;\n\t\t\t\t\t\t\tpq.Enqueue(new KeyValuePair<int, V>(t, d));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\t\t\t}\n\n\n\t\t\t//update\n\t\t\t{\n\t\t\t\tif (dist[sink] == inf) break;\n\t\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\t\tpotential[i] = Math.Min(inf, potential[i] + dist[i]);\n\t\t\t\tC df = f;\n\t\t\t\tV d = 0;\n\t\t\t\tfor (var v = sink; v != src; v = prev[v]) {\n\t\t\t\t\tvar e = prevEdge[v];\n\t\t\t\t\tdf = Math.Min(df, e.Cap); d += e.Cost;\n\t\t\t\t}\n\t\t\t\tf -= df; cost += df * d; flow += df;\n\t\t\t\tfor (var v = sink; v != src; v = prev[v]) {\n\t\t\t\t\tvar e = prevEdge[v];\n\t\t\t\t\te.Cap -= df; e.Rev.Cap += df;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\treturn new KeyValuePair<C, V>(flow, cost);\n\t}\n\tvoid addEdge(int f, int t, C c1, C c2, V e) {\n\t\tif (e < 0) hasng = true;\n\t\tvar a = new Edge(t, c1, e);\n\t\tvar b = new Edge(f, c2, -e);\n\t\tEdge.Link(a, b);\n\t\tG[f].Add(a);\n\t\tG[t].Add(b);\n\t}\n\tpublic class Edge {\n\t\tpublic static void Link(Edge e1, Edge e2) {\n\t\t\te1.Rev = e2; e2.Rev = e1;\n\t\t}\n\t\tpublic int To { get; private set; }\n\t\tpublic Edge Rev { get; private set; }\n\t\tpublic V Cost { get; private set; }\n\t\tpublic C Cap { get; set; }\n\t\tpublic Edge(int t, C c, V e) {\n\t\t\tTo = t;\n\t\t\tCap = c;\n\t\t\tCost = e;\n\t\t}\n\t\tpublic override string ToString() {\n\t\t\treturn string.Format(\"to: {0}, cap: {1}\", To, Cap);\n\t\t}\n\t}\n}\n#endregion\n#region PriorityQueue\n/// <summary>\n/// 指定した型のインスタンスを最も価値が低い順に取り出すことが可能な可変サイズのコレクションを表します．\n/// </summary>\n/// <typeparam name=\"T\">優先度付きキュー内の要素の型を指定します．</typeparam>\n/// <remarks>内部的にはバイナリヒープによって実装されています．</remarks>\npublic class PriorityQueue<T> {\n\treadonly List<T> heap = new List<T>();\n\treadonly Comparison<T> cmp;\n\n\t/// <summary>\n\t/// デフォルトの比較子を使用してインスタンスを初期化します．\n\t/// </summary>\n\t/// <remarks>この操作は O(1) で実行されます．</remarks>\n\tpublic PriorityQueue() { cmp = Comparer<T>.Default.Compare; }\n\n\t/// <summary>\n\t/// デリゲートで表されるような比較関数を使用してインスタンスを初期化します．\n\t/// </summary>\n\t/// <param name=\"comparison\"></param>\n\t/// <remarks>この操作は O(1) で実行されます．</remarks>\n\tpublic PriorityQueue(Comparison<T> comparison) { cmp = comparison; }\n\n\t/// <summary>\n\t/// 指定された比較子を使用してインスタンスを初期化します．\n\t/// </summary>\n\t/// <param name=\"comparer\"></param>\n\t/// <remarks>この操作は O(1) で実行されます．</remarks>\n\tpublic PriorityQueue(IComparer<T> comparer) { cmp = comparer.Compare; }\n\n\t/// <summary>\n\t/// 優先度付きキューに要素を追加します．\n\t/// </summary>\n\t/// <param name=\"item\">優先度付きキューに追加される要素</param>\n\t/// <remarks>最悪計算量 O(log N) で実行されます．</remarks>\n\tpublic void Enqueue(T item) {\n\t\tvar pos = heap.Count;\n\t\theap.Add(item);\n\t\twhile (pos > 0) {\n\t\t\tvar par = (pos - 1) / 2;\n\t\t\tif (cmp(heap[par], item) <= 0)\n\t\t\t\tbreak;\n\t\t\theap[pos] = heap[par];\n\t\t\tpos = par;\n\t\t}\n\t\theap[pos] = item;\n\n\t}\n\n\t/// <summary>\n\t/// 優先度付きキューから最も価値が低い要素を削除し，返します．\n\t/// </summary>\n\t/// <returns>優先度付きキューから削除された要素．</returns>\n\t/// <remarks>最悪計算量 O(log N) で実行されます．</remarks>\n\tpublic T Dequeue() {\n\t\tvar ret = heap[0];\n\t\tvar pos = 0;\n\t\tvar x = heap[heap.Count - 1];\n\n\t\twhile (pos * 2 + 1 < heap.Count - 1) {\n\t\t\tvar lch = pos * 2 + 1;\n\t\t\tvar rch = pos * 2 + 2;\n\t\t\tif (rch < heap.Count - 1 && cmp(heap[rch], heap[lch]) < 0) lch = rch;\n\t\t\tif (cmp(heap[lch], x) >= 0)\n\t\t\t\tbreak;\n\t\t\theap[pos] = heap[lch];\n\t\t\tpos = lch;\n\t\t}\n\t\theap[pos] = x;\n\t\theap.RemoveAt(heap.Count - 1);\n\t\treturn ret;\n\n\t}\n\t/// <summary>\n\t///  優先度付きキューに含まれる最も価値が低い要素を削除せずに返します．\n\t/// </summary>\n\t/// <returns>優先度付きキューに含まれる最も価値が低い要素．</returns>\n\t/// <remarks>この操作は O(1) で実行されます．</remarks>\n\tpublic T Peek() { return heap[0]; }\n\n\t/// <summary>\n\t/// 優先度付きキュー内の要素の数を取得します．\n\t/// </summary>\n\t/// <returns>優先度付キュー内にある要素の数</returns>\n\t/// <remarks>最悪計算量 O(1) で実行されます．</remarks>\n\tpublic int Count { get { return heap.Count; } }\n\t/// <summary>\n\t/// 優先度付きキュー内に要素が存在するかどうかを O(1) で判定します．\n\t/// </summary>\n\t/// <returns>優先度付キュー内にある要素が存在するならば true，そうでなければ　false．</returns>\n\t/// <remarks>この操作は O(1) で実行されます．</remarks>\n\tpublic bool Any() { return heap.Count > 0; }\n\n\t/// <summary>\n\t/// 優先度付きキューに含まれる要素を昇順に並べて返します．\n\t/// </summary>\n\t/// <remarks>この操作は計算量 O(N log N) で実行されます．</remarks>\n\tpublic T[] Items {\n\t\tget {\n\t\t\tvar ret = heap.ToArray();\n\t\t\tArray.Sort(ret, cmp);\n\t\t\treturn ret;\n\t\t}\n\t}\n}\n#endregion\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput=sys.stdin.readline\nsys.setrecursionlimit(10**9)\nfrom bisect import bisect_left,bisect_right\n\nclass MinCostFlow:\n    def __init__(self,n):\n        self.n=n\n        self.edges=[[] for i in range(n)]\n    def add_edge(self,fr,to,cap,cost):\n        self.edges[fr].append([to,cap,cost,len(self.edges[to])])\n        self.edges[to].append([fr,0,-cost,len(self.edges[fr])-1])\n    def MinCost(self,source,sink,flow):\n        inf=10**15+1\n        n,E=self.n,self.edges\n        prev_v,prev_e=[0]*n,[0]*n\n        mincost=0\n        while flow:\n            dist=[inf]*n\n            dist[source]=0\n            flag=True\n            while flag:\n                flag=False\n                for v in range(n):\n                    if dist[v]==inf:\n                        continue\n                    Ev=E[v]\n                    for i in range(len(Ev)):\n                        to,cap,cost,rev=Ev[i]\n                        if cap>0 and dist[v]+cost<dist[to]:\n                            dist[to]=dist[v]+cost\n                            prev_v[to],prev_e[to]=v,i\n                            flag=True\n            if dist[sink]==inf:\n                return -1\n            f=flow\n            v=sink\n            while v!=source:\n                f=min(f,E[prev_v[v]][prev_e[v]][1])\n                v=prev_v[v]\n            flow-=f\n            mincost+=f*dist[sink]\n            v=sink\n            while v!=source:\n                E[prev_v[v]][prev_e[v]][1]-=f\n                rev=E[prev_v[v]][prev_e[v]][3]\n                E[v][rev][1]+=f\n                v=prev_v[v]\n        return mincost\n\nn=int(input())\nJ=[]\nL_org,D_org=[1]*n,[1]*n\nfor _ in range(n):\n    x,y,v=map(int,input().split())\n    J.append((x,y,v))\nm=int(input())\nT=[]\nfor _ in range(m):\n    t,a,b=input().split()\n    a,b=int(a),int(b)\n    T.append((t,a,b))\n    if t=='L':\n        L_org[b]=a+1\n    elif t=='D':\n        D_org[b]=a+1\nfor i in range(1,n):\n    L_org[i]=max(L_org[i-1],L_org[i])\n    D_org[i]=max(D_org[i-1],D_org[i])\n\ndef solve(k):\n    L,D=L_org[:k],D_org[:k]\n    R,U=[100]*k,[100]*k\n    for t,a,b in T:\n        if k-b-1>=0:\n            if t=='R':\n                R[k-b-1]=a-1\n            elif t=='U':\n                U[k-b-1]=a-1\n    for i in range(k-2,-1,-1):\n        R[i]=min(R[i],R[i+1])\n        U[i]=min(U[i],U[i+1])\n    solver=MinCostFlow(2*n+2*k+2)\n    for i in range(1,k+1):\n        solver.add_edge(0,i,1,0)\n        solver.add_edge(2*n+k+i,2*n+2*k+1,1,0)\n    for i in range(n):\n        v=J[i][2]\n        solver.add_edge(k+i+1,n+k+i+1,1,-v)\n    for i in range(n):\n        x,y=J[i][0],J[i][1]\n        l=bisect_right(L,x)\n        r=bisect_left(R,x)+1\n        d=bisect_right(D,y)\n        u=bisect_left(U,y)+1\n        for j in range(r,l+1):\n            solver.add_edge(j,k+i+1,1,0)\n        for j in range(u,d+1):\n            solver.add_edge(n+k+i+1,2*n+k+j,1,0)    \n    return -solver.MinCost(0,2*n+2*k+1,k)\n\nans=0\nk=1\nwhile True:\n    tmp=solve(k)\n    ans=max(ans,tmp)\n    if tmp==-1 or k==n:\n        break\n    k+=1\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "import sys\ninput=sys.stdin.readline\nsys.setrecursionlimit(10**9)\nfrom bisect import bisect_left,bisect_right\n\nclass MinCostFlow:\n    def __init__(self,n):\n        self.n=n\n        self.edges=[[] for i in range(n)]\n    def add_edge(self,fr,to,cap,cost):\n        self.edges[fr].append([to,cap,cost,len(self.edges[to])])\n        self.edges[to].append([fr,0,-cost,len(self.edges[fr])-1])\n    def MinCost(self,source,sink,flow):\n        inf=10**15+1\n        n,E=self.n,self.edges\n        prev_v,prev_e=[0]*n,[0]*n\n        mincost=0\n        while flow:\n            dist=[inf]*n\n            dist[source]=0\n            flag=True\n            while flag:\n                flag=False\n                for v in range(n):\n                    if dist[v]==inf:\n                        continue\n                    Ev=E[v]\n                    for i in range(len(Ev)):\n                        to,cap,cost,rev=Ev[i]\n                        if cap>0 and dist[v]+cost<dist[to]:\n                            dist[to]=dist[v]+cost\n                            prev_v[to],prev_e[to]=v,i\n                            flag=True\n            if dist[sink]==inf:\n                return 1\n            f=flow\n            v=sink\n            while v!=source:\n                f=min(f,E[prev_v[v]][prev_e[v]][1])\n                v=prev_v[v]\n            flow-=f\n            mincost+=f*dist[sink]\n            v=sink\n            while v!=source:\n                E[prev_v[v]][prev_e[v]][1]-=f\n                rev=E[prev_v[v]][prev_e[v]][3]\n                E[v][rev][1]+=f\n                v=prev_v[v]\n        return mincost\n\nn=int(input())\nJ=[]\nL_org,D_org=[1]*n,[1]*n\nfor _ in range(n):\n    x,y,v=map(int,input().split())\n    J.append((x,y,v))\nm=int(input())\nT=[]\nfor _ in range(m):\n    t,a,b=input().split()\n    a,b=int(a),int(b)\n    T.append((t,a,b))\n    if t=='L':\n        L_org[b]=a+1\n    elif t=='D':\n        D_org[b]=a+1\nfor i in range(1,n):\n    L_org[i]=max(L_org[i-1],L_org[i])\n    D_org[i]=max(D_org[i-1],D_org[i])\n\ndef solve(k):\n    L,D=L_org[:k],D_org[:k]\n    R,U=[100]*k,[100]*k\n    for t,a,b in T:\n        if k-b-1>=0:\n            if t=='R':\n                R[k-b-1]=a-1\n            elif t=='U':\n                U[k-b-1]=a-1\n    for i in range(k-2,-1,-1):\n        R[i]=min(R[i],R[i+1])\n        U[i]=min(U[i],U[i+1])\n    solver=MinCostFlow(2*n+2*k+2)\n    for i in range(1,k+1):\n        solver.add_edge(0,i,1,0)\n        solver.add_edge(2*n+k+i,2*n+2*k+1,1,0)\n    for i in range(n):\n        v=J[i][2]\n        solver.add_edge(k+i+1,n+k+i+1,1,-v)\n    for i in range(n):\n        x,y=J[i][0],J[i][1]\n        l=bisect_right(L,x)\n        r=bisect_left(R,x)+1\n        d=bisect_right(D,y)\n        u=bisect_left(U,y)+1\n        for j in range(r,l+1):\n            solver.add_edge(j,k+i+1,1,0)\n        for j in range(u,d+1):\n            solver.add_edge(n+k+i+1,2*n+k+j,1,0)    \n    return -solver.MinCost(0,2*n+2*k+1,k)\n\nans=0\nk=1\nwhile True:\n    tmp=solve(k)\n    ans=max(ans,tmp)\n    if tmp==-1 or k==n:\n        break\n    k+=1\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "import sys\ninput=sys.stdin.readline\nsys.setrecursionlimit(10**9)\nfrom collections import deque\nfrom bisect import bisect_left,bisect_right\n\nclass MinCostFlow:\n    def __init__(self,n):\n        self.n=n\n        self.edges=[[] for i in range(n)]\n    def add_edge(self,fr,to,cap,cost):\n        self.edges[fr].append([to,cap,cost,len(self.edges[to])])\n        self.edges[to].append([fr,0,-cost,len(self.edges[fr])-1])\n    def MinCost(self,source,sink,flow):\n        inf=10**15+1\n        n=self.n; E=self.edges\n        mincost=0\n        prev_v=[0]*n; prev_e=[0]*n\n        while flow:\n            dist=[inf]*n\n            dist[source]=0\n            q=deque([source])\n            Flag=[False]*n\n            Flag[source]=True\n            while q:\n                v=q.popleft()\n                if not Flag[v]:\n                    continue\n                Flag[v]=False\n                for i,(to,cap,cost,_) in enumerate(E[v]):\n                    if cap>0 and dist[to]>dist[v]+cost:\n                        dist[to]=dist[v]+cost\n                        prev_v[to],prev_e[to]=v,i\n                        q.append(to)\n                        Flag[to]=True\n            if dist[sink]==inf:\n                return 1\n            f,v=flow,sink\n            while v!=source:\n                f=min(f,E[prev_v[v]][prev_e[v]][1])\n                v=prev_v[v]\n            flow-=f\n            mincost+=f*dist[sink]\n            v=sink\n            while v!=source:\n                E[prev_v[v]][prev_e[v]][1]-=f\n                rev=E[prev_v[v]][prev_e[v]][3]\n                E[v][rev][1]+=f\n                v=prev_v[v]\n        return mincost\n\nn=int(input())\nJ=[]\nL_org,D_org=[1]*n,[1]*n\nfor _ in range(n):\n    x,y,v=map(int,input().split())\n    J.append((x,y,v))\nm=int(input())\nT=[]\nfor _ in range(m):\n    t,a,b=input().split()\n    a,b=int(a),int(b)\n    T.append((t,a,b))\n    if t=='L':\n        L_org[b]=a+1\n    elif t=='D':\n        D_org[b]=a+1\nfor i in range(1,n):\n    L_org[i]=max(L_org[i-1],L_org[i])\n    D_org[i]=max(D_org[i-1],D_org[i])\n\ndef solve(k):\n    L,D=L_org[:k],D_org[:k]\n    R,U=[100]*k,[100]*k\n    for t,a,b in T:\n        if k-b-1>=0:\n            if t=='R':\n                R[k-b-1]=a-1\n            elif t=='U':\n                U[k-b-1]=a-1\n    for i in range(k-2,-1,-1):\n        R[i]=min(R[i],R[i+1])\n        U[i]=min(U[i],U[i+1])\n    solver=MinCostFlow(2*n+2*k+2)\n    for i in range(1,k+1):\n        solver.add_edge(0,i,1,0)\n        solver.add_edge(2*n+k+i,2*n+2*k+1,1,0)\n    for i in range(n):\n        v=J[i][2]\n        solver.add_edge(k+i+1,n+k+i+1,1,-v)\n    for i in range(n):\n        x,y=J[i][0],J[i][1]\n        l=bisect_right(L,x)\n        r=bisect_left(R,x)+1\n        d=bisect_right(D,y)\n        u=bisect_left(U,y)+1\n        for j in range(r,l+1):\n            solver.add_edge(j,k+i+1,1,0)\n        for j in range(u,d+1):\n            solver.add_edge(n+k+i+1,2*n+k+j,1,0)    \n    return -solver.MinCost(0,2*n+2*k+1,k)\n\nans=0\nk=1\nwhile True:\n    tmp=solve(k)\n    ans=max(ans,tmp)\n    if tmp==-1 or k==n:\n        break\n    k+=1\nprint(ans)"
  }
]