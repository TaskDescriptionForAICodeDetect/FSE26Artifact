[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 200\n#define MAX_M 200\n\ntypedef struct {\n    int x, y, value;\n} Jewel;\n\nint max(int a, int b) {\n    return a > b ? a : b;\n}\n\nint solve(int N, int M, Jewel jewels[], int conditions[][3]) {\n    int dp[MAX_N + 1][MAX_N + 1];\n    memset(dp, 0, sizeof(dp));\n\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            for (int k = 0; k < M; k++) {\n                int type = conditions[k][0];\n                int coord = conditions[k][1];\n                int limit = conditions[k][2];\n\n                if (type == 1 && jewels[i].x == coord) continue;\n                if (type == 2 && jewels[i].y == coord) continue;\n                if (type == 3 && (jewels[i].x + jewels[j].x) > limit) continue;\n                if (type == 4 && (jewels[i].y + jewels[j].y) > limit) continue;\n            }\n\n            dp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j]);\n            if (i != j) {\n                dp[i + 1][j + 1] = max(dp[i + 1][j + 1], dp[i][j] + jewels[i].value + jewels[j].value);\n            }\n        }\n    }\n\n    return dp[N][N];\n}\n\nint main() {\n    int N, M;\n    Jewel jewels[MAX_N];\n    int conditions[MAX_M][3];\n\n    scanf(\"%d %d\", &N, &M);\n\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d %d\", &jewels[i].x, &jewels[i].y, &jewels[i].value);\n    }\n\n    for (int i = 0; i < M; i++) {\n        scanf(\"%d %d %d\", &conditions[i][0], &conditions[i][1], &conditions[i][2]);\n    }\n\n    int max_value = solve(N, M, jewels, conditions);\n    printf(\"%d\\n\", max_value);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:53:57"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\ntypedef struct {\n    int x, y, v;\n} Jewel;\n\ntypedef struct {\n    char axis;\n    int value;\n    int limit;\n} Condition;\n\nint N, M;\nJewel jewels[100];\nCondition conditions[100];\nint max_sum = 0;\n\nvoid dfs(int index, int current_sum, int* x_counts, int* y_counts) {\n    if (index == N) {\n        int valid = 1;\n        for (int i = 0; i < M; i++) {\n            if (conditions[i].axis == 'x') {\n                if (x_counts[conditions[i].value] > conditions[i].limit) {\n                    valid = 0;\n                    break;\n                }\n            } else {\n                if (y_counts[conditions[i].value] > conditions[i].limit) {\n                    valid = 0;\n                    break;\n                }\n            }\n        }\n        if (valid && current_sum > max_sum) {\n            max_sum = current_sum;\n        }\n        return;\n    }\n\n    // Option 1: Do not take the jewel\n    dfs(index + 1, current_sum, x_counts, y_counts);\n\n    // Option 2: Take the jewel\n    x_counts[jewels[index].x]++;\n    y_counts[jewels[index].y]++;\n    dfs(index + 1, current_sum + jewels[index].v, x_counts, y_counts);\n    x_counts[jewels[index].x]--;\n    y_counts[jewels[index].y]--;\n}\n\nint main() {\n    scanf(\"%d\", &N);\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d %d\", &jewels[i].x, &jewels[i].y, &jewels[i].v);\n    }\n    scanf(\"%d\", &M);\n    for (int i = 0; i < M; i++) {\n        scanf(\" %c %d %d\", &conditions[i].axis, &conditions[i].value, &conditions[i].limit);\n    }\n\n    int x_counts[101] = {0};\n    int y_counts[101] = {0};\n    dfs(0, 0, x_counts, y_counts);\n\n    printf(\"%d\\n\", max_sum);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:54:20"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <queue>\n#include <climits>\n#include <cassert>\n\nusing namespace std;\n\nstruct Edge {\n    int to, rev;\n    long long cap;\n    Edge(int to, int rev, long long cap) : to(to), rev(rev), cap(cap) {}\n};\n\nclass MaxFlow {\nprivate:\n    vector<vector<Edge>> G;\n    vector<int> level, iter;\n    int size;\n\n    void bfs(int s) {\n        level.assign(size, -1);\n        queue<int> q;\n        level[s] = 0;\n        q.push(s);\n        while (!q.empty()) {\n            int v = q.front();\n            q.pop();\n            for (const Edge &e : G[v]) {\n                if (e.cap > 0 && level[e.to] < 0) {\n                    level[e.to] = level[v] + 1;\n                    q.push(e.to);\n                }\n            }\n        }\n    }\n\n    long long dfs(int v, int t, long long f) {\n        if (v == t) return f;\n        for (int &i = iter[v]; i < G[v].size(); ++i) {\n            Edge &e = G[v][i];\n            if (e.cap > 0 && level[v] < level[e.to]) {\n                long long d = dfs(e.to, t, min(f, e.cap));\n                if (d > 0) {\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\npublic:\n    MaxFlow(int n) {\n        size = n;\n        G.resize(n);\n    }\n\n    void add_edge(int from, int to, long long cap) {\n        G[from].emplace_back(to, G[to].size(), cap);\n        G[to].emplace_back(from, G[from].size() - 1, 0);\n    }\n\n    long long max_flow(int s, int t) {\n        long long flow = 0;\n        while (true) {\n            bfs(s);\n            if (level[t] < 0) return flow;\n            iter.assign(size, 0);\n            long long f;\n            while ((f = dfs(s, t, LLONG_MAX)) > 0) {\n                flow += f;\n            }\n        }\n    }\n};\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    vector<int> X(N), Y(N), V(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> X[i] >> Y[i] >> V[i];\n    }\n\n    vector<pair<char, int>> conditions(M);\n    for (int i = 0; i < M; ++i) {\n        cin >> conditions[i].first >> conditions[i].second;\n    }\n\n    set<int> xs, ys;\n    map<int, int> x_to_idx, y_to_idx;\n    for (int x : X) xs.insert(x);\n    for (int y : Y) ys.insert(y);\n\n    int x_cnt = 0, y_cnt = 0;\n    for (int x : xs) x_to_idx[x] = x_cnt++;\n    for (int y : ys) y_to_idx[y] = y_cnt++;\n\n    int total = 2 + x_cnt + y_cnt + N;\n    int S = x_cnt + y_cnt + N, T = S + 1;\n\n    MaxFlow mf(total);\n\n    for (int i = 0; i < N; ++i) {\n        int x_node = x_to_idx[X[i]];\n        int y_node = y_to_idx[Y[i]] + x_cnt;\n        int jewel_node = x_cnt + y_cnt + i;\n        mf.add_edge(x_node, jewel_node, V[i]);\n        mf.add_edge(y_node, jewel_node, V[i]);\n        mf.add_edge(jewel_node, T, V[i]);\n    }\n\n    vector<int> x_limits(x_cnt, INT_MAX);\n    vector<int> y_limits(y_cnt, INT_MAX);\n\n    for (auto &cond : conditions) {\n        char c = cond.first;\n        int a = cond.second;\n        if (c == 'x') {\n            if (x_to_idx.count(a)) {\n                int idx = x_to_idx[a];\n                x_limits[idx] = min(x_limits[idx], cond.second);\n            }\n        } else if (c == 'y') {\n            if (y_to_idx.count(a)) {\n                int idx = y_to_idx[a];\n                y_limits[idx] = min(y_limits[idx], cond.second);\n            }\n        }\n    }\n\n    for (int i = 0; i < x_cnt; ++i) {\n        mf.add_edge(S, i, x_limits[i]);\n    }\n\n    for (int i = 0; i < y_cnt; ++i) {\n        mf.add_edge(S, x_cnt + i, y_limits[i]);\n    }\n\n    cout << mf.max_flow(S, T) << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:55:27"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class JewelThief {\n    static class Jewel {\n        int x, y, v;\n        Jewel(int x, int y, int v) {\n            this.x = x;\n            this.y = y;\n            this.v = v;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int M = sc.nextInt();\n        List<Jewel> jewels = new ArrayList<>();\n        for (int i = 0; i < N; i++) {\n            int x = sc.nextInt();\n            int y = sc.nextInt();\n            int v = sc.nextInt();\n            jewels.add(new Jewel(x, y, v));\n        }\n\n        List<int[]> xConditions = new ArrayList<>();\n        List<int[]> yConditions = new ArrayList<>();\n        for (int i = 0; i < M; i++) {\n            char c = sc.next().charAt(0);\n            int a = sc.nextInt();\n            int b = sc.nextInt();\n            if (c == 'x') {\n                xConditions.add(new int[]{a, b});\n            } else {\n                yConditions.add(new int[]{a, b});\n            }\n        }\n\n        int maxSum = 0;\n        for (Jewel jewel : jewels) {\n            boolean valid = true;\n            for (int[] cond : xConditions) {\n                int a = cond[0];\n                int b = cond[1];\n                if (jewel.x < a || jewel.x > b) {\n                    valid = false;\n                    break;\n                }\n            }\n            for (int[] cond : yConditions) {\n                int a = cond[0];\n                int b = cond[1];\n                if (jewel.y < a || jewel.y > b) {\n                    valid = false;\n                    break;\n                }\n            }\n            if (valid) {\n                maxSum += jewel.v;\n            }\n        }\n\n        System.out.println(maxSum);\n        sc.close();\n    }\n}",
    "timestamp": "2025-08-05 22:55:47"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class JewelHeist {\n    static class Jewel {\n        int x, y, value;\n        Jewel(int x, int y, int value) {\n            this.x = x;\n            this.y = y;\n            this.value = value;\n        }\n    }\n\n    static class Condition {\n        boolean isX;\n        int coordinate;\n        int limit;\n        Condition(boolean isX, int coordinate, int limit) {\n            this.isX = isX;\n            this.coordinate = coordinate;\n            this.limit = limit;\n        }\n    }\n\n    public static int maxStolenValue(int N, Jewel[] jewels, int M, Condition[] conditions) {\n        return solve(0, jewels, conditions, new HashMap<>());\n    }\n\n    private static int solve(int index, Jewel[] jewels, Condition[] conditions, Map<String, Integer> memo) {\n        if (index == jewels.length) {\n            return checkConditions(jewels, conditions) ? 0 : Integer.MIN_VALUE;\n        }\n\n        String key = index + \"\";\n        if (memo.containsKey(key)) {\n            return memo.get(key);\n        }\n\n        int takeJewel = jewels[index].value + \n            solve(index + 1, jewels, conditions, memo);\n        int skipJewel = solve(index + 1, jewels, conditions, memo);\n\n        int maxValue = Math.max(takeJewel, skipJewel);\n        memo.put(key, maxValue);\n        return maxValue;\n    }\n\n    private static boolean checkConditions(Jewel[] jewels, Condition[] conditions) {\n        for (Condition condition : conditions) {\n            int count = 0;\n            for (Jewel jewel : jewels) {\n                if (condition.isX && jewel.x == condition.coordinate) count++;\n                if (!condition.isX && jewel.y == condition.coordinate) count++;\n            }\n            if (count > condition.limit) return false;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        Jewel[] jewels = new Jewel[N];\n        for (int i = 0; i < N; i++) {\n            jewels[i] = new Jewel(scanner.nextInt(), scanner.nextInt(), scanner.nextInt());\n        }\n        int M = scanner.nextInt();\n        Condition[] conditions = new Condition[M];\n        for (int i = 0; i < M; i++) {\n            boolean isX = scanner.next().equals(\"X\");\n            conditions[i] = new Condition(isX, scanner.nextInt(), scanner.nextInt());\n        }\n        System.out.println(maxStolenValue(N, jewels, M, conditions));\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 22:55:59"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int MAXN = 200;\n\nstruct Jewel {\n    int x, y, value;\n};\n\nint solve(int N, int M, vector<Jewel>& jewels, vector<pair<char, pair<int, int>>>& conditions) {\n    int maxValue = 0;\n    \n    // Try all possible subsets of jewels\n    for (int mask = 0; mask < (1 << N); mask++) {\n        vector<Jewel> stolenJewels;\n        int currentValue = 0;\n        \n        // Select jewels in current subset\n        for (int i = 0; i < N; i++) {\n            if (mask & (1 << i)) {\n                stolenJewels.push_back(jewels[i]);\n                currentValue += jewels[i].value;\n            }\n        }\n        \n        // Check all conditions\n        bool validSubset = true;\n        for (auto& condition : conditions) {\n            char coord = condition.first;\n            int limit = condition.second.first;\n            int count = condition.second.second;\n            \n            int coordCount = 0;\n            for (auto& jewel : stolenJewels) {\n                if ((coord == 'x' && jewel.x == limit) || \n                    (coord == 'y' && jewel.y == limit)) {\n                    coordCount++;\n                }\n            }\n            \n            if (coordCount > count) {\n                validSubset = false;\n                break;\n            }\n        }\n        \n        if (validSubset) {\n            maxValue = max(maxValue, currentValue);\n        }\n    }\n    \n    return maxValue;\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    \n    vector<Jewel> jewels(N);\n    for (int i = 0; i < N; i++) {\n        cin >> jewels[i].x >> jewels[i].y >> jewels[i].value;\n    }\n    \n    vector<pair<char, pair<int, int>>> conditions(M);\n    for (int i = 0; i < M; i++) {\n        cin >> conditions[i].first >> conditions[i].second.first >> conditions[i].second.second;\n    }\n    \n    cout << solve(N, M, jewels, conditions) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:56:07"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from itertools import combinations\nfrom collections import defaultdict\n\ndef max_value_of_jewels(N, jewels, M, conditions):\n    def is_valid(comb):\n        x_limits = defaultdict(int)\n        y_limits = defaultdict(int)\n        for x, y, _ in comb:\n            x_limits[x] += 1\n            y_limits[y] += 1\n        for limit in conditions:\n            axis, val, max_count = limit\n            if axis == 'x' and x_limits[val] > max_count:\n                return False\n            if axis == 'y' and y_limits[val] > max_count:\n                return False\n        return True\n\n    max_value = 0\n    \n    for r in range(1, N + 1):\n        for comb in combinations(jewels, r):\n            if is_valid(comb):\n                max_value = max(max_value, sum(value for _, _, value in comb))\n\n    return max_value\n\n\n# Example usage:\nN = 5\njewels = [(1, 1, 100), (1, 2, 200), (2, 2, 150), (3, 3, 300), (3, 4, 400)]\nM = 2\nconditions = [('x', 1, 1), ('y', 2, 1)]\n\nmax_value = max_value_of_jewels(N, jewels, M, conditions)\nprint(max_value)  # Output the answer",
    "timestamp": "2025-08-13 12:58:07"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class JewelThief {\n    static class Jewel {\n        int x, y, value;\n        Jewel(int x, int y, int value) {\n            this.x = x;\n            this.y = y;\n            this.value = value;\n        }\n    }\n\n    static class Condition {\n        char coord; // 'x' or 'y'\n        int limit;\n        Condition(char coord, int limit) {\n            this.coord = coord;\n            this.limit = limit;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        int N = sc.nextInt();\n        Jewel[] jewels = new Jewel[N];\n        for (int i = 0; i < N; i++) {\n            int x = sc.nextInt();\n            int y = sc.nextInt();\n            int value = sc.nextInt();\n            jewels[i] = new Jewel(x, y, value);\n        }\n        \n        int M = sc.nextInt();\n        List<Condition> conditions = new ArrayList<>();\n        for (int i = 0; i < M; i++) {\n            char coord = sc.next().charAt(0);\n            int limit = sc.nextInt();\n            conditions.add(new Condition(coord, limit));\n        }\n        \n        System.out.println(maxSumOfJewels(jewels, conditions));\n        sc.close();\n    }\n\n    private static int maxSumOfJewels(Jewel[] jewels, List<Condition> conditions) {\n        int maxSum = 0;\n\n        // For each subset of jewels, check if it satisfies all conditions\n        int totalJewels = jewels.length;\n        for (int i = 0; i < (1 << totalJewels); i++) {\n            List<Jewel> subset = new ArrayList<>();\n            for (int j = 0; j < totalJewels; j++) {\n                if ((i & (1 << j)) != 0) {\n                    subset.add(jewels[j]);\n                }\n            }\n            \n            if (checkConditions(subset, conditions)) {\n                int currentSum = subset.stream().mapToInt(jewel -> jewel.value).sum();\n                maxSum = Math.max(maxSum, currentSum);\n            }\n        }\n\n        return maxSum;\n    }\n\n    private static boolean checkConditions(List<Jewel> subset, List<Condition> conditions) {\n        for (Condition condition : conditions) {\n            int count = 0;\n            for (Jewel jewel : subset) {\n                if ((condition.coord == 'x' && jewel.x <= condition.limit) || \n                    (condition.coord == 'y' && jewel.y <= condition.limit)) {\n                    count++;\n                }\n            }\n            if (count > condition.limit) {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
    "timestamp": "2025-08-13 12:58:13"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int x, y, value;\n} Jewel;\n\ntypedef struct {\n    char type; // 'x' or 'y'\n    int limit, max_count;\n} Condition;\n\nint compareJewelValues(const void *a, const void *b) {\n    return ((Jewel*)b)->value - ((Jewel*)a)->value;\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n    Jewel jewels[N];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d %d\", &jewels[i].x, &jewels[i].y, &jewels[i].value);\n    }\n    Condition conditions[M];\n    for (int i = 0; i < M; i++) {\n        getchar(); // to consume new line or whitespace\n        scanf(\"%c %d %d\", &conditions[i].type, &conditions[i].limit, &conditions[i].max_count);\n    }\n\n    qsort(jewels, N, sizeof(Jewel), compareJewelValues);\n\n    int result = 0;\n    int jewelsCountX[N+1], jewelsCountY[N+1];\n    for (int i = 0; i <= N; i++) {\n        jewelsCountX[i] = jewelsCountY[i] = 0;\n    }\n\n    for (int i = 0; i < N; i++) {\n        int canSteal = 1;\n        for (int j = 0; j < M; j++) {\n            if (conditions[j].type == 'x' && jewels[i].x == conditions[j].limit) {\n                if (jewelsCountX[jewels[i].x] >= conditions[j].max_count) {\n                    canSteal = 0;\n                    break;\n                }\n            }\n            if (conditions[j].type == 'y' && jewels[i].y == conditions[j].limit) {\n                if (jewelsCountY[jewels[i].y] >= conditions[j].max_count) {\n                    canSteal = 0;\n                    break;\n                }\n            }\n        }\n\n        if (canSteal) {\n            result += jewels[i].value;\n            jewelsCountX[jewels[i].x]++;\n            jewelsCountY[jewels[i].y]++;\n        }\n    }\n\n    printf(\"%d\\n\", result);\n    return 0;\n}",
    "timestamp": "2025-08-13 12:58:22"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function maxJewelsValue(N, M, jewels, conditions) {\n  jewels.sort((a, b) => b.value - a.value);\n\n  let maxValue = 0;\n  let stolenJewels = [];\n  for (let { x, y, value } of jewels) {\n    let valid = true;\n    let selectedJewels = [...stolenJewels];\n    \n    for (let i = 0; i < M; i++) {\n      const condition = conditions[i];\n      const count = selectedJewels.reduce((count, jewel) =>\n        count + (condition.type === 'x' && jewel.x === condition.coord ||\n                 condition.type === 'y' && jewel.y === condition.coord), 0);\n      \n      if (count + (condition.type === 'x' && x === condition.coord ||\n                   condition.type === 'y' && y === condition.coord) > condition.limit) {\n        valid = false;\n        break;\n      }\n    }\n\n    if (valid) {\n      stolenJewels.push({ x, y, value });\n      maxValue += value;\n    }\n  }\n\n  return maxValue;\n}",
    "timestamp": "2025-08-13 12:58:25"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_jewel_theft(N, jewels, M, conditions):\n    # Create a dynamic programming solution\n    # Use bitmask to represent stolen jewels\n    max_value = 0\n    \n    # Try all possible combinations of jewels\n    for mask in range(1 << N):\n        # Check if the current combination satisfies all conditions\n        valid_combination = True\n        x_count = [0] * 101  # Assuming x coordinates are in range 0-100\n        y_count = [0] * 101  # Assuming y coordinates are in range 0-100\n        current_value = 0\n        \n        # Count jewels for each condition\n        for i in range(N):\n            if mask & (1 << i):\n                x_coord, y_coord, value = jewels[i]\n                x_count[x_coord] += 1\n                y_count[y_coord] += 1\n                current_value += value\n        \n        # Check all conditions\n        for condition in conditions:\n            coord_type, coord, limit = condition\n            if coord_type == 'x':\n                if x_count[coord] > limit:\n                    valid_combination = False\n                    break\n            else:  # y coordinate\n                if y_count[coord] > limit:\n                    valid_combination = False\n                    break\n        \n        # Update max value if combination is valid\n        if valid_combination:\n            max_value = max(max_value, current_value)\n    \n    return max_value\n\n# Input parsing and function call\ndef main():\n    # Read input\n    N, M = map(int, input().split())\n    \n    # Read jewel details\n    jewels = []\n    for _ in range(N):\n        x, y, value = map(int, input().split())\n        jewels.append((x, y, value))\n    \n    # Read conditions\n    conditions = []\n    for _ in range(M):\n        coord_type, coord, limit = input().split()\n        conditions.append((coord_type, int(coord), int(limit)))\n    \n    # Solve and print result\n    result = solve_jewel_theft(N, jewels, M, conditions)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 12:58:34"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function maxJewelValue(N, jewels, M, conditions) {\n    const dp = new Array(1 << N).fill(0);\n    \n    for (let mask = 0; mask < (1 << N); mask++) {\n        let totalValue = 0;\n        let xCoords = new Set();\n        let yCoords = new Set();\n        \n        for (let i = 0; i < N; i++) {\n            if (mask & (1 << i)) {\n                totalValue += jewels[i].value;\n                xCoords.add(jewels[i].x);\n                yCoords.add(jewels[i].y);\n            }\n        }\n        \n        let validConditions = true;\n        for (let condition of conditions) {\n            const type = condition.type;\n            const coord = condition.coord;\n            const limit = condition.limit;\n            \n            let count = 0;\n            for (let i = 0; i < N; i++) {\n                if (mask & (1 << i)) {\n                    if (type === 'x' && jewels[i].x === coord) count++;\n                    if (type === 'y' && jewels[i].y === coord) count++;\n                }\n            }\n            \n            if (count > limit) {\n                validConditions = false;\n                break;\n            }\n        }\n        \n        if (validConditions) {\n            dp[mask] = totalValue;\n        }\n    }\n    \n    return Math.max(...dp);\n}",
    "timestamp": "2025-08-13 12:58:41"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import defaultdict\n\ndef solve():\n    input = sys.stdin.read().split()\n    ptr = 0\n    N = int(input[ptr])\n    ptr += 1\n    jewels = []\n    x_set = set()\n    y_set = set()\n    for _ in range(N):\n        x = int(input[ptr])\n        y = int(input[ptr+1])\n        v = int(input[ptr+2])\n        ptr +=3\n        jewels.append((x, y, v))\n        x_set.add(x)\n        y_set.add(y)\n    \n    M = int(input[ptr])\n    ptr +=1\n    conditions = []\n    for _ in range(M):\n        t = input[ptr]\n        a = int(input[ptr+1])\n        b = int(input[ptr+2])\n        ptr +=3\n        conditions.append((t, a, b))\n    \n    # Coordinate compression\n    sorted_x = sorted(x_set)\n    x_to_idx = {x: i for i, x in enumerate(sorted_x)}\n    sorted_y = sorted(y_set)\n    y_to_idx = {y: i for i, y in enumerate(sorted_y)}\n    \n    # Initialize counts and values for each x and y\n    x_counts = defaultdict(int)\n    y_counts = defaultdict(int)\n    x_values = defaultdict(int)\n    y_values = defaultdict(int)\n    \n    for x, y, v in jewels:\n        x_idx = x_to_idx[x]\n        y_idx = y_to_idx[y]\n        x_counts[x_idx] += 1\n        y_counts[y_idx] += 1\n        x_values[x_idx] += v\n        y_values[y_idx] += v\n    \n    # Initialize DP tables\n    max_x = len(sorted_x)\n    max_y = len(sorted_y)\n    \n    # DP[i][j] = max value with i x's and j y's selected\n    dp = [[-1 for _ in range(max_y +1)] for __ in range(max_x +1)]\n    dp[0][0] = 0\n    \n    for i in range(max_x +1):\n        for j in range(max_y +1):\n            if dp[i][j] == -1:\n                continue\n            if i < max_x:\n                new_val = dp[i][j] + x_values[i]\n                if dp[i+1][j] < new_val:\n                    dp[i+1][j] = new_val\n            if j < max_y:\n                new_val = dp[i][j] + y_values[j]\n                if dp[i][j+1] < new_val:\n                    dp[i][j+1] = new_val\n    \n    # Check conditions\n    max_total = 0\n    for i in range(max_x +1):\n        for j in range(max_y +1):\n            if dp[i][j] == -1:\n                continue\n            valid = True\n            for t, a, b in conditions:\n                if t == 'x':\n                    if i > a:\n                        valid = False\n                        break\n                elif t == 'y':\n                    if j > a:\n                        valid = False\n                        break\n                elif t == 'xy':\n                    if i + j > a:\n                        valid = False\n                        break\n            if valid and dp[i][j] > max_total:\n                max_total = dp[i][j]\n    \n    print(max_total)\n\nsolve()",
    "timestamp": "2025-08-13 12:58:58"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve() {\n    const readline = require('readline');\n    const rl = readline.createInterface({\n        input: process.stdin,\n        output: process.stdout\n    });\n\n    let N, M;\n    let jewels = [];\n    let conditions = [];\n    let lineCount = 0;\n\n    rl.on('line', (line) => {\n        if (lineCount === 0) {\n            [N, M] = line.trim().split(' ').map(Number);\n            lineCount++;\n        } else if (lineCount <= N) {\n            const [x, y, v] = line.trim().split(' ').map(Number);\n            jewels.push({ x, y, v });\n            lineCount++;\n        } else if (lineCount <= N + M) {\n            const [t, a] = line.trim().split(' ').map(Number);\n            conditions.push({ t, a });\n            lineCount++;\n        }\n        if (lineCount === N + M + 1) {\n            rl.close();\n        }\n    });\n\n    rl.on('close', () => {\n        const xSet = new Set();\n        const ySet = new Set();\n        jewels.forEach(j => {\n            xSet.add(j.x);\n            ySet.add(j.y);\n        });\n        const xList = Array.from(xSet).sort((a, b) => a - b);\n        const yList = Array.from(ySet).sort((a, b) => a - b);\n\n        const xMap = new Map();\n        const yMap = new Map();\n        xList.forEach((x, idx) => xMap.set(x, idx));\n        yList.forEach((y, idx) => yMap.set(y, idx));\n\n        const xLimits = new Array(xList.length).fill(Infinity);\n        const yLimits = new Array(yList.length).fill(Infinity);\n        conditions.forEach(cond => {\n            if (cond.t === 1) {\n                const idx = xMap.get(cond.a);\n                if (idx !== undefined) {\n                    xLimits[idx] = 0;\n                }\n            } else {\n                const idx = yMap.get(cond.a);\n                if (idx !== undefined) {\n                    yLimits[idx] = 0;\n                }\n            }\n        });\n\n        const dp = new Array(xList.length + 1).fill().map(() => \n            new Array(yList.length + 1).fill(-Infinity)\n        );\n        dp[0][0] = 0;\n\n        for (const jewel of jewels) {\n            const xIdx = xMap.get(jewel.x);\n            const yIdx = yMap.get(jewel.y);\n            for (let i = xList.length; i >= 0; i--) {\n                for (let j = yList.length; j >= 0; j--) {\n                    if (dp[i][j] === -Infinity) continue;\n                    const newX = Math.max(i, xIdx + 1);\n                    const newY = Math.max(j, yIdx + 1);\n                    if (newX <= xList.length && newY <= yList.length) {\n                        const xLimit = xLimits[newX - 1] === undefined ? Infinity : xLimits[newX - 1];\n                        const yLimit = yLimits[newY - 1] === undefined ? Infinity : yLimits[newY - 1];\n                        if ((newX - i <= xLimit || xLimit === Infinity) && \n                            (newY - j <= yLimit || yLimit === Infinity)) {\n                            if (dp[newX][newY] < dp[i][j] + jewel.v) {\n                                dp[newX][newY] = dp[i][j] + jewel.v;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        let max = 0;\n        for (let i = 0; i <= xList.length; i++) {\n            for (let j = 0; j <= yList.length; j++) {\n                if (dp[i][j] > max) {\n                    max = dp[i][j];\n                }\n            }\n        }\n        console.log(max);\n    });\n}\n\nsolve();",
    "timestamp": "2025-08-13 12:59:21"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <numeric>\n\nusing namespace std;\n\nstruct Jewel {\n    int x, y, value;\n};\n\nstruct Condition {\n    char type;\n    int coordinate, limit;\n};\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n\n    vector<Jewel> jewels(N);\n    for (int i = 0; i < N; i++) {\n        cin >> jewels[i].x >> jewels[i].y >> jewels[i].value;\n    }\n\n    vector<Condition> conditions(M);\n    for (int i = 0; i < M; i++) {\n        cin >> conditions[i].type >> conditions[i].coordinate >> conditions[i].limit;\n    }\n\n    auto adhereToConditions = [&](const vector<int>& selection) -> bool {\n        for (const auto& condition : conditions) {\n            int count = 0;\n            for (int index : selection) {\n                if ((condition.type == 'x' && jewels[index].x == condition.coordinate) ||\n                    (condition.type == 'y' && jewels[index].y == condition.coordinate)) {\n                    count++;\n                }\n                if (count > condition.limit) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    };\n\n    int max_value = 0;\n    int num_combinations = 1 << N;\n    for (int mask = 0; mask < num_combinations; mask++) {\n        vector<int> selection;\n        int current_value = 0;\n        for (int i = 0; i < N; i++) {\n            if (mask & (1 << i)) {\n                selection.push_back(i);\n                current_value += jewels[i].value;\n            }\n        }\n        if (adhereToConditions(selection)) {\n            max_value = max(max_value, current_value);\n        }\n    }\n\n    cout << max_value << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 14:37:26"
  }
]