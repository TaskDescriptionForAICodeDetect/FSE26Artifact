[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\ntypedef struct {\n    int to;\n    int score;\n} Edge;\n\ntypedef struct {\n    Edge* edges;\n    int edge_count;\n} Cone;\n\ntypedef struct {\n    int cone;\n    int arrows;\n    int score;\n    int* path;\n} State;\n\nint main() {\n    int N, M, K, S;\n    scanf(\"%d %d %d %d\", &N, &M, &K, &S);\n    S--; // converting to 0-based index\n\n    Cone* cones = (Cone*)malloc(N * sizeof(Cone));\n    for (int i = 0; i < N; i++) {\n        cones[i].edges = NULL;\n        cones[i].edge_count = 0;\n    }\n\n    for (int i = 0; i < M; i++) {\n        int u, v, s;\n        scanf(\"%d %d %d\", &u, &v, &s);\n        u--; v--; // converting to 0-based index\n        cones[u].edge_count++;\n        cones[u].edges = (Edge*)realloc(cones[u].edges, cones[u].edge_count * sizeof(Edge));\n        cones[u].edges[cones[u].edge_count - 1].to = v;\n        cones[u].edges[cones[u].edge_count - 1].score = s;\n    }\n\n    State* queue = (State*)malloc(1000000 * sizeof(State));\n    int front = 0, rear = 0;\n\n    queue[rear].cone = S;\n    queue[rear].arrows = 0;\n    queue[rear].score = 0;\n    queue[rear].path = (int*)malloc(sizeof(int));\n    queue[rear].path[0] = S + 1; // converting back to 1-based index\n    rear++;\n\n    int* min_arrows = (int*)malloc(N * sizeof(int));\n    for (int i = 0; i < N; i++) {\n        min_arrows[i] = INT_MAX;\n    }\n\n    int result_arrows = -1;\n    int* result_path = NULL;\n\n    while (front < rear) {\n        State current = queue[front++];\n\n        if (current.score >= K) {\n            if (result_arrows == -1 || current.arrows < result_arrows) {\n                result_arrows = current.arrows;\n                free(result_path);\n                result_path = current.path;\n            } else {\n                free(current.path);\n            }\n            continue;\n        }\n\n        if (current.arrows >= 100) {\n            free(current.path);\n            continue;\n        }\n\n        if (current.arrows >= min_arrows[current.cone]) {\n            free(current.path);\n            continue;\n        }\n        min_arrows[current.cone] = current.arrows;\n\n        Cone* cone = &cones[current.cone];\n        for (int i = 0; i < cone->edge_count; i++) {\n            Edge edge = cone->edges[i];\n            State next;\n            next.cone = edge.to;\n            next.arrows = current.arrows + 1;\n            next.score = current.score + edge.score;\n            next.path = (int*)malloc((current.arrows + 2) * sizeof(int));\n            for (int j = 0; j <= current.arrows; j++) {\n                next.path[j] = current.path[j];\n            }\n            next.path[next.arrows] = edge.to + 1; // converting back to 1-based index\n            queue[rear++] = next;\n        }\n        free(current.path);\n    }\n\n    if (result_arrows != -1) {\n        printf(\"%d\\n\", result_arrows);\n        if (result_arrows <= 100) {\n            for (int i = 0; i <= result_arrows; i++) {\n                printf(\"%d \", result_path[i]);\n            }\n            printf(\"\\n\");\n        }\n        free(result_path);\n    } else {\n        printf(\"-1\\n\");\n    }\n\n    for (int i = 0; i < N; i++) {\n        free(cones[i].edges);\n    }\n    free(cones);\n    free(queue);\n    free(min_arrows);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:31:57"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n#include <unordered_map>\n#include <algorithm>\n\nusing namespace std;\n\nstruct State {\n    int cone;\n    int score;\n    int arrows;\n    vector<int> path;\n};\n\nvector<int> solve(int N, const vector<vector<pair<int, int>>>& adj, int start, int K) {\n    queue<State> q;\n    unordered_map<int, unordered_map<int, int>> visited;\n\n    q.push({start, 0, 0, {start}});\n    visited[start][0] = 0;\n\n    while (!q.empty()) {\n        State current = q.front();\n        q.pop();\n\n        if (current.score >= K) {\n            if (current.arrows <= 100) {\n                return current.path;\n            } else {\n                return {current.arrows};\n            }\n        }\n\n        for (const auto& edge : adj[current.cone]) {\n            int next_cone = edge.first;\n            int next_score = current.score + edge.second;\n            int next_arrows = current.arrows + 1;\n\n            if (next_arrows > 100) continue;\n\n            if (visited[next_cone].find(next_score) == visited[next_cone].end() || \n                visited[next_cone][next_score] > next_arrows) {\n                visited[next_cone][next_score] = next_arrows;\n                vector<int> next_path = current.path;\n                next_path.push_back(next_cone);\n                q.push({next_cone, next_score, next_arrows, next_path});\n            }\n        }\n    }\n\n    return {-1};\n}\n\nint main() {\n    int N, M, start, K;\n    cin >> N >> M >> start >> K;\n\n    vector<vector<pair<int, int>>> adj(N + 1);\n    for (int i = 0; i < M; ++i) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        adj[u].emplace_back(v, w);\n    }\n\n    vector<int> result = solve(N, adj, start, K);\n\n    if (result.size() == 1 && result[0] == -1) {\n        cout << -1 << endl;\n    } else if (result.size() == 1) {\n        cout << result[0] << endl;\n    } else {\n        cout << result.size() - 1 << endl;\n        for (int i = 0; i < result.size(); ++i) {\n            if (i > 0) cout << \" \";\n            cout << result[i];\n        }\n        cout << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:32:22"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Solution {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n        int K = scanner.nextInt();\n        int start = scanner.nextInt();\n\n        Map<Integer, List<int[]>> graph = new HashMap<>();\n        for (int i = 0; i < M; i++) {\n            int from = scanner.nextInt();\n            int to = scanner.nextInt();\n            int score = scanner.nextInt();\n            graph.computeIfAbsent(from, k -> new ArrayList<>()).add(new int[]{to, score});\n        }\n\n        Queue<int[]> queue = new LinkedList<>();\n        Map<Integer, Integer> visited = new HashMap<>();\n        Map<Integer, List<Integer>> path = new HashMap<>();\n\n        queue.offer(new int[]{start, 0});\n        visited.put(start, 0);\n        path.put(start, new ArrayList<>(Collections.singletonList(start)));\n\n        int resultArrows = -1;\n        List<Integer> resultPath = null;\n\n        while (!queue.isEmpty()) {\n            int[] current = queue.poll();\n            int cone = current[0];\n            int totalScore = current[1];\n\n            if (totalScore >= K) {\n                resultArrows = path.get(cone).size() - 1;\n                resultPath = path.get(cone);\n                break;\n            }\n\n            if (path.get(cone).size() > 100) {\n                continue;\n            }\n\n            if (graph.containsKey(cone)) {\n                for (int[] edge : graph.get(cone)) {\n                    int nextCone = edge[0];\n                    int nextScore = totalScore + edge[1];\n                    int arrowsUsed = path.get(cone).size();\n\n                    if (!visited.containsKey(nextCone) || visited.get(nextCone) < nextScore) {\n                        visited.put(nextCone, nextScore);\n                        List<Integer> newPath = new ArrayList<>(path.get(cone));\n                        newPath.add(nextCone);\n                        path.put(nextCone, newPath);\n                        queue.offer(new int[]{nextCone, nextScore});\n                    }\n                }\n            }\n        }\n\n        if (resultArrows != -1) {\n            if (resultArrows <= 100) {\n                System.out.println(resultArrows);\n                for (int i = 0; i < resultPath.size(); i++) {\n                    if (i > 0) {\n                        System.out.print(\" \");\n                    }\n                    System.out.print(resultPath.get(i));\n                }\n                System.out.println();\n            } else {\n                System.out.println(resultArrows);\n            }\n        } else {\n            System.out.println(-1);\n        }\n    }\n}",
    "timestamp": "2025-08-05 21:32:46"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Solution {\n    public static int[] findOptimalPath(int N, int[][] arrows, int K) {\n        Map<Integer, List<int[]>> graph = new HashMap<>();\n        for (int[] arrow : arrows) {\n            graph.putIfAbsent(arrow[0], new ArrayList<>());\n            graph.get(arrow[0]).add(new int[]{arrow[1], arrow[2]});\n        }\n\n        PriorityQueue<PathState> pq = new PriorityQueue<>((a, b) -> {\n            if (a.totalArrows != b.totalArrows) return a.totalArrows - b.totalArrows;\n            return a.score - b.score;\n        });\n\n        for (int start = 1; start <= N; start++) {\n            boolean[] visited = new boolean[N + 1];\n            pq.clear();\n            pq.offer(new PathState(start, start, 0, 0, new ArrayList<>()));\n\n            while (!pq.isEmpty()) {\n                PathState current = pq.poll();\n\n                if (current.score >= K) {\n                    if (current.totalArrows > 100) {\n                        return new int[]{current.totalArrows};\n                    }\n                    int[] result = new int[current.path.size() + 1];\n                    result[0] = current.totalArrows;\n                    for (int i = 0; i < current.path.size(); i++) {\n                        result[i + 1] = current.path.get(i);\n                    }\n                    return result;\n                }\n\n                if (visited[current.node]) continue;\n                visited[current.node] = true;\n\n                if (graph.containsKey(current.node)) {\n                    for (int[] neighbor : graph.get(current.node)) {\n                        List<Integer> newPath = new ArrayList<>(current.path);\n                        newPath.add(neighbor[0]);\n                        pq.offer(new PathState(\n                            neighbor[0],\n                            start,\n                            current.score + neighbor[1],\n                            current.totalArrows + 1,\n                            newPath\n                        ));\n                    }\n                }\n            }\n        }\n\n        return new int[]{-1};\n    }\n\n    static class PathState {\n        int node;\n        int startNode;\n        int score;\n        int totalArrows;\n        List<Integer> path;\n\n        PathState(int node, int startNode, int score, int totalArrows, List<Integer> path) {\n            this.node = node;\n            this.startNode = startNode;\n            this.score = score;\n            this.totalArrows = totalArrows;\n            this.path = path;\n        }\n    }\n}",
    "timestamp": "2025-08-05 21:32:55"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_CONES 1000\n#define MAX_ARROWS 10000\n#define MAX_OUTPUT_ARROWS 100\n\ntypedef struct {\n    int dest;\n    int score;\n} Arrow;\n\ntypedef struct {\n    int score;\n    int prev_cone;\n    int num_arrows;\n} PathInfo;\n\nint solve_sports_days(int N, int K, int start, Arrow arrows[][MAX_CONES], int cone_scores[]) {\n    PathInfo dp[MAX_CONES];\n    int path[MAX_ARROWS];\n    \n    for (int i = 0; i < N; i++) {\n        dp[i].score = INT_MIN;\n        dp[i].prev_cone = -1;\n        dp[i].num_arrows = 0;\n    }\n    \n    dp[start].score = cone_scores[start];\n    \n    for (int k = 0; k < N; k++) {\n        for (int i = 0; i < N; i++) {\n            if (dp[i].score == INT_MIN) continue;\n            \n            for (int j = 0; j < N; j++) {\n                if (arrows[i][j].dest != -1) {\n                    int new_score = dp[i].score + arrows[i][j].score + cone_scores[j];\n                    int new_arrows = dp[i].num_arrows + 1;\n                    \n                    if (new_score > dp[j].score || \n                        (new_score == dp[j].score && new_arrows < dp[j].num_arrows)) {\n                        dp[j].score = new_score;\n                        dp[j].prev_cone = i;\n                        dp[j].num_arrows = new_arrows;\n                    }\n                }\n            }\n        }\n    }\n    \n    int best_cone = -1;\n    int min_arrows = INT_MAX;\n    \n    for (int i = 0; i < N; i++) {\n        if (dp[i].score >= K && dp[i].num_arrows < min_arrows) {\n            best_cone = i;\n            min_arrows = dp[i].num_arrows;\n        }\n    }\n    \n    if (best_cone == -1) return -1;\n    \n    if (min_arrows > MAX_OUTPUT_ARROWS) {\n        return min_arrows;\n    }\n    \n    int current = best_cone;\n    int path_len = 0;\n    \n    while (current != -1) {\n        path[path_len++] = current;\n        current = dp[current].prev_cone;\n    }\n    \n    printf(\"%d\\n\", min_arrows);\n    \n    for (int i = path_len - 1; i >= 0; i--) {\n        printf(\"%d \", path[i]);\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}\n\nint main() {\n    int N, K, start;\n    scanf(\"%d %d %d\", &N, &K, &start);\n    \n    int cone_scores[MAX_CONES];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &cone_scores[i]);\n    }\n    \n    Arrow arrows[MAX_CONES][MAX_CONES];\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            arrows[i][j].dest = -1;\n        }\n    }\n    \n    int M;\n    scanf(\"%d\", &M);\n    \n    for (int i = 0; i < M; i++) {\n        int u, v, score;\n        scanf(\"%d %d %d\", &u, &v, &score);\n        arrows[u][v].dest = v;\n        arrows[u][v].score = score;\n    }\n    \n    return solve_sports_days(N, K, start, arrows, cone_scores);\n}",
    "timestamp": "2025-08-05 21:33:08"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n#include <algorithm>\n\nusing namespace std;\n\nstruct State {\n    int cone;\n    int totalScore;\n    int arrows;\n    vector<int> path;\n};\n\nint main() {\n    int N, M, K;\n    cin >> N >> M >> K;\n\n    vector<vector<pair<int, int>>> graph(N + 1);\n    for (int i = 0; i < M; i++) {\n        int u, v, score;\n        cin >> u >> v >> score;\n        graph[u].push_back({v, score});\n    }\n\n    vector<int> startCones(N);\n    for (int i = 0; i < N; i++) {\n        cin >> startCones[i];\n    }\n\n    int minArrows = INT_MAX;\n    vector<int> bestPath;\n\n    for (int start : startCones) {\n        vector<vector<int>> minScores(N + 1, vector<int>(K + 1, INT_MAX));\n        queue<State> q;\n        q.push({start, 0, 0, {start}});\n        minScores[start][0] = 0;\n\n        while (!q.empty()) {\n            State current = q.front();\n            q.pop();\n\n            if (current.totalScore >= K) {\n                if (current.arrows < minArrows || \n                    (current.arrows == minArrows && \n                     (bestPath.empty() || current.path < bestPath))) {\n                    minArrows = current.arrows;\n                    bestPath = current.path;\n                }\n                continue;\n            }\n\n            if (current.arrows >= 100) continue;\n\n            for (auto& edge : graph[current.cone]) {\n                int nextCone = edge.first;\n                int edgeScore = edge.second;\n                int newScore = min(K, current.totalScore + edgeScore);\n\n                if (current.arrows + 1 < minScores[nextCone][newScore]) {\n                    minScores[nextCone][newScore] = current.arrows + 1;\n                    State next = current;\n                    next.cone = nextCone;\n                    next.totalScore = newScore;\n                    next.arrows++;\n                    next.path.push_back(nextCone);\n                    q.push(next);\n                }\n            }\n        }\n    }\n\n    if (minArrows == INT_MAX) {\n        cout << -1 << endl;\n    } else if (minArrows > 100) {\n        cout << minArrows << endl;\n    } else {\n        cout << minArrows << endl;\n        for (int cone : bestPath) {\n            cout << cone << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:33:17"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict, deque\n\ndef sports_days(cones, arrows, K):\n    graph = defaultdict(list)\n    for start, end, score in arrows:\n        graph[start].append((end, score))\n    \n    # Breadth First Search to find the optimal path\n    queue = deque([(cone, 0, 0, [cone]) for cone in cones])  # (current cone, score, arrows, path)\n    visited = {(cone, 0): 0 for cone in cones}\n    \n    while queue:\n        current_cone, current_score, num_arrows, path = queue.popleft()\n        \n        if current_score >= K:\n            if num_arrows > 100:\n                return num_arrows\n            else:\n                return num_arrows, path\n        \n        for next_cone, score in graph[current_cone]:\n            next_score = current_score + score\n            if next_score >= K:\n                if num_arrows + 1 > 100:\n                    return num_arrows + 1\n                else:\n                    return num_arrows + 1, path + [next_cone]\n            \n            if (next_cone, next_score) not in visited or visited[(next_cone, next_score)] > num_arrows + 1:\n                visited[(next_cone, next_score)] = num_arrows + 1\n                queue.append((next_cone, next_score, num_arrows + 1, path + [next_cone]))\n\n    return -1\n\n# Example usage:\ncones = [1, 2, 3]  # Starting choices\narrows = [(1, 2, 10), (2, 3, 5), (1, 3, 15)]  # List of (start_cone, end_cone, score)\nK = 15\nprint(sports_days(cones, arrows, K))",
    "timestamp": "2025-08-13 06:59:11"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class SportsDays2 {\n\n    static class Arrow {\n        int to, score;\n\n        Arrow(int to, int score) {\n            this.to = to;\n            this.score = score;\n        }\n    }\n\n    public static String solve(int n, int start, int K, List<List<Arrow>> graph) {\n        // Min-heap to store the paths based on the number of arrows used\n        PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[1]));\n        pq.offer(new int[] {start, 0, 0, start}); // coneIndex, score, arrowsUsed, path\n\n        Set<String> visited = new HashSet<>();\n        String targetPath = null;\n        int maxArrows = Integer.MAX_VALUE;\n\n        while (!pq.isEmpty()) {\n            int[] current = pq.poll();\n            int coneIndex = current[0];\n            int score = current[1];\n            int arrowsUsed = current[2];\n            int path = current[3];\n\n            if (score >= K) {\n                targetPath = path + \"\";\n                maxArrows = arrowsUsed;\n                break;\n            }\n            \n            // Check if the current path is already visited\n            String visitKey = coneIndex + \",\" + score + \",\" + arrowsUsed;\n            if (visited.contains(visitKey)) continue;\n            visited.add(visitKey);\n\n            // Explore the directional arrows from current cone\n            if (arrowsUsed < 100) {\n                for (Arrow arrow : graph.get(coneIndex)) {\n                    pq.offer(new int[] {arrow.to, score + arrow.score, arrowsUsed + 1, path * n + arrow.to});\n                }\n            }\n        }\n\n        // Return -1 if no valid path found\n        if (targetPath == null) return \"-1\";\n\n        // Return number of arrows and path if arrows <= 100, else return only number of arrows\n        return arrowsUsed <= 100 ? arrowsUsed + \"\\n\" + decodePath(targetPath, n) : arrowsUsed + \"\";\n    }\n\n    private static String decodePath(String path, int n) {\n        List<Integer> cones = new ArrayList<>();\n        while (path.length() > 1) {\n            cones.add(Integer.parseInt(path.substring(path.length() - 1)));\n            path = path.substring(0, path.length() - 1);\n        }\n        cones.add(Integer.parseInt(path)); // adding the start cone\n\n        Collections.reverse(cones);\n        StringBuilder sb = new StringBuilder();\n        for (int cone : cones) {\n            sb.append(cone).append(\" \");\n        }\n        return sb.toString().trim();\n    }\n\n    // Usage Example:\n    public static void main(String[] args) {\n        int n = 4; // number of cones\n        int start = 0; // starting cone\n        int K = 7; // minimum score required\n\n        // List adjacency list representation of the graph\n        List<List<Arrow>> graph = new ArrayList<>();\n        for (int i = 0; i < n; i++) graph.add(new ArrayList<>());\n\n        graph.get(0).add(new Arrow(1, 3));\n        graph.get(0).add(new Arrow(2, 2));\n        graph.get(1).add(new Arrow(3, 5));\n        graph.get(2).add(new Arrow(3, 4));\n\n        System.out.println(solve(n, start, K, graph));\n    }\n}",
    "timestamp": "2025-08-13 06:59:20"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_CONES 1000\n#define MAX_ARROWS 100\n\ntypedef struct {\n    int dest;\n    int score;\n} Arrow;\n\ntypedef struct {\n    int num_arrows;\n    Arrow arrows[MAX_ARROWS];\n} Cone;\n\nint min_arrows = INT_MAX;\nint best_sequence[MAX_CONES];\nint current_sequence[MAX_CONES];\nint target_score;\nint cone_count;\n\nCone cones[MAX_CONES];\n\nint dfs(int current_cone, int current_score, int arrows_used) {\n    if (current_score >= target_score) {\n        if (arrows_used < min_arrows) {\n            min_arrows = arrows_used;\n            for (int i = 0; i < arrows_used; i++) {\n                best_sequence[i] = current_sequence[i];\n            }\n        }\n        return 0;\n    }\n\n    if (arrows_used >= min_arrows || arrows_used > MAX_ARROWS) {\n        return -1;\n    }\n\n    for (int i = 0; i < cones[current_cone].num_arrows; i++) {\n        int next_cone = cones[current_cone].arrows[i].dest;\n        int score_gain = cones[current_cone].arrows[i].score;\n\n        current_sequence[arrows_used] = next_cone;\n        dfs(next_cone, current_score + score_gain, arrows_used + 1);\n        current_sequence[arrows_used] = current_cone; // backtrack\n    }\n\n    return min_arrows;\n}\n\nint main() {\n    int k;\n    scanf(\"%d %d\", &cone_count, &k);\n\n    target_score = k;\n\n    for (int i = 0; i < cone_count; i++) {\n        int num_arrows;\n        scanf(\"%d\", &num_arrows);\n        cones[i].num_arrows = num_arrows;\n\n        for (int j = 0; j < num_arrows; j++) {\n            int dest, score;\n            scanf(\"%d %d\", &dest, &score);\n\n            cones[i].arrows[j].dest = dest;\n            cones[i].arrows[j].score = score;\n        }\n    }\n\n    for (int i = 0; i < cone_count; i++) {\n        current_sequence[0] = i;\n        dfs(i, 0, 0);\n    }\n\n    if (min_arrows == INT_MAX) {\n        printf(\"-1\\n\");\n    } else {\n        if (min_arrows > MAX_ARROWS) {\n            printf(\"%d\\n\", min_arrows);\n        } else {\n            printf(\"%d\\n\", min_arrows);\n            for (int i = 0; i < min_arrows; i++) {\n                printf(\"%d \", best_sequence[i]);\n            }\n            printf(\"\\n\");\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 06:59:29"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict, deque\n\ndef find_optimal_path(N, arrows, K):\n    graph = defaultdict(list)\n    for start, end, score in arrows:\n        graph[start].append((end, score))\n    \n    def bfs():\n        queue = deque([(start, 0, 0, [start]) for start in range(1, N+1)])\n        visited = set()\n        \n        while queue:\n            node, total_score, arrows_used, path = queue.popleft()\n            \n            if total_score >= K:\n                return (arrows_used, path) if arrows_used <= 100 else arrows_used\n            \n            if (node, total_score) in visited or arrows_used > 100:\n                continue\n            \n            visited.add((node, total_score))\n            \n            for next_node, arrow_score in graph[node]:\n                new_score = total_score + arrow_score\n                new_path = path + [next_node]\n                queue.append((next_node, new_score, arrows_used + 1, new_path))\n        \n        return -1\n    \n    result = bfs()\n    return result\n\ndef main():\n    N, M, K = map(int, input().split())\n    arrows = []\n    for _ in range(M):\n        start, end, score = map(int, input().split())\n        arrows.append((start, end, score))\n    \n    result = find_optimal_path(N, arrows, K)\n    \n    if result == -1:\n        print(-1)\n    elif isinstance(result, int):\n        print(result)\n    else:\n        arrows_used, path = result\n        print(arrows_used)\n        print(' '.join(map(str, path)))\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 06:59:45"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    N, M, K, start = map(int, sys.stdin.readline().split())\n    adj = [[] for _ in range(N+1)]\n    for _ in range(M):\n        a, b, c = map(int, sys.stdin.readline().split())\n        adj[a].append((b, c))\n    \n    # We'll use BFS with states (current_node, current_score)\n    # And track the path length and path itself\n    visited = {}\n    queue = deque()\n    queue.append((start, 0, 0, [start]))\n    visited[(start, 0)] = 0  # (node, score) -> steps\n    \n    found = False\n    result_steps = -1\n    result_path = []\n    \n    while queue:\n        node, score, steps, path = queue.popleft()\n        \n        if score >= K:\n            found = True\n            result_steps = steps\n            result_path = path\n            break\n        \n        for neighbor, cost in adj[node]:\n            new_score = score + cost\n            new_steps = steps + 1\n            new_path = path + [neighbor]\n            \n            if new_steps > 100:\n                continue\n            \n            if (neighbor, new_score) not in visited or new_steps < visited[(neighbor, new_score)]:\n                visited[(neighbor, new_score)] = new_steps\n                queue.append((neighbor, new_score, new_steps, new_path))\n    \n    if found:\n        if result_steps <= 100:\n            print(result_steps)\n            print(' '.join(map(str, result_path)))\n        else:\n            print(result_steps)\n    else:\n        print(-1)\n\nsolve()",
    "timestamp": "2025-08-13 06:59:59"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <limits>\n\nusing namespace std;\n\n// Define a struct to represent a state in the BFS\nstruct State {\n    int coneIndex;\n    int currentScore;\n    vector<int> path;\n};\n\n// Function to find the least number of arrows needed to achieve score K\npair<int, vector<int>> findMinimumArrows(int numCones, int startCone, int K, const vector<map<int, int>>& graph) {\n    // Priority queue for BFS: state with fewer arrows and higher scores come first\n    priority_queue<State, vector<State>, greater<>> pq;\n    pq.push({startCone, 0, {startCone}});\n\n    // Visited map to track the best score achievable at each cone\n    map<int, int> visited;\n    visited[startCone] = 0;\n\n    while (!pq.empty()) {\n        State current = pq.top();\n        pq.pop();\n\n        if (current.currentScore >= K) {\n            // If more than 100 arrows are needed, just return count\n            if (current.path.size() > 100) {\n                return {current.path.size(), {}};\n            } else {\n                return {current.path.size() - 1, current.path};\n            }\n        }\n\n        for (const auto& [nextCone, score] : graph[current.coneIndex]) {\n            int newScore = current.currentScore + score;\n            vector<int> newPath = current.path;\n            newPath.push_back(nextCone);\n\n            if (visited.find(nextCone) == visited.end() || visited[nextCone] < newScore) {\n                visited[nextCone] = newScore;\n                pq.push({nextCone, newScore, newPath});\n            }\n        }\n    }\n    \n    return {-1, {}};\n}\n\nint main() {\n    int numCones = 5;\n    int startCone = 0;\n    int K = 20;\n    vector<map<int, int>> graph = {\n        {{1, 10}, {2, 5}},\n        {{3, 10}},\n        {{3, 10}, {4, 1}},\n        {{4, 5}},\n        {}\n    };\n\n    auto result = findMinimumArrows(numCones, startCone, K, graph);\n\n    if (result.first == -1) {\n        cout << -1 << endl;\n    } else {\n        cout << result.first << endl;\n        if (!result.second.empty()) {\n            for (int cone : result.second) {\n                cout << cone << \" \";\n            }\n            cout << endl;\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:35:03"
  }
]