[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n\nusing vint = vector<int>;\n\nconst int inf = 1LL<<55;\n\nint V, E, K;\nvector<vint> A;\n\nvector<vint> calc(int m) {\n  //cout<<m<<endl;\n  vector<vint> B = A;\n  vector<vint> res(V, vint(V, -inf));\n  for(int i = 0; i < V; ++i) res[i][i] = 0;\n  while(m > 0) {\n    if(m&1) {\n      vector<vint> tmp(V, vint(V, -inf));\n      for(int i = 0; i < V; ++i) tmp[i][i] = 0;      \n      for(int k = 0; k < V; ++k) {\t\n\tfor(int i = 0; i < V; ++i) {\n\t  for(int j = 0; j < V; ++j) {\n\t    tmp[i][j] = max(tmp[i][j], res[i][k]+B[k][j]);\n\t  }\n\t}\n      }\n      res = tmp;\n    }\n    vector<vint> tmp(V, vint(V, -inf));\n    for(int i = 0; i < V; ++i) tmp[i][i] = 0;\n    for(int k = 0; k < V; ++k) {\n      for(int i = 0; i < V; ++i) {\n\tfor(int j = 0; j < V; ++j) {\n\t  tmp[i][j] = max(tmp[i][j], B[i][k]+B[k][j]);\n\t}\n      }\n    }\n    B = tmp;    \n    m >>= 1;\n  }\n  /*\n  for(int i = 0; i < V; ++i) {\n    for(int j = 0; j < V; ++j) cout << res[i][j] << \" \\n\"[j==V-1];\n  }\n  /*/\n  return res;\n}\n\n\nint check(int m) {\n  vector<vint> B = calc(m);\n  int res = 0;\n  for(int i = 0; i < V; ++i) {\n    for(int j = 0; j < V; ++j) {\n      res = max(res, B[i][j]);\n    }\n  }\n  return res;\n}\n\nsigned main() {\n  cin >> V >> E >> K;\n  A.resize(V, vint(V, -inf));\n  for(int i = 0; i < V; ++i) A[i][i] = 0;\n  for(int i = 0; i < E; ++i) {\n    int u, v, c;\n    cin >> u >> v >> c;\n    A[u][v] = max(A[u][v], c);\n  }\n  /*\n  for(int i = 0; i < V; ++i) {\n    for(int j = 0; j < V; ++j) cout << A[i][j] << \" \\n\"[j==V-1];\n  } \n  /*/ \n  int lb = 0, ub = 1111111;\n  while(lb+1 < ub) {\n    int mb = (lb+ub)/2;\n    if(check(mb) >= K) ub = mb;\n    else lb = mb;\n  }\n  if(ub == 1111111) {\n    cout << -1 << endl;\n    return 0;\n  }\n  cout << ub << endl;  \n  int ans = check(ub);\n  //cout << ans << endl;\n  //cout<<check(34)<<endl;\n  if(ub <= 100) {\n    vector<vint> rev(ub+1, vint(V, -1));\n    vector<vint> B(V, vint(V, -inf));\n    for(int i = 0; i < V; ++i) B[i][i] = 0;\n    for(int l = 0; l < ub; ++l) {\n      vector<vint> tmp(V, vint(V, -inf));\n      for(int i = 0; i < V; ++i) tmp[i][i] = 0;\n      for(int k = 0; k < V; ++k) {      \n\tfor(int i = 0; i < V; ++i) {\n\t  for(int j = 0; j < V; ++j) {\n\t    if(tmp[i][j] < B[i][k]+A[k][j]) {\n\t      tmp[i][j] = B[i][k]+A[k][j];\n\t      rev[l+1][j] = k;\n\t    }\n\t  }\n\t}\n      }\n      B = tmp;\n    }\n    int idx = -1;\n    for(int i = 0; i < V && idx == -1; ++i) {\n      for(int j = 0; j < V && idx == -1; ++j) {\n\tif(ans == B[i][j]) idx = j;\n      }\n    }\n    vint vec;\n    for(int l = ub; l >= 0; --l) {\n      vec.push_back(idx);\n      idx = rev[l][idx];\n    }\n    reverse(vec.begin(), vec.end());\n    for(int i = 0; i < (int)vec.size(); ++i) cout << vec[i] << \" \\n\"[i==(int)vec.size()-1];\n  }\n\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nconst int LK = 20;\nconst int N = 150;\n\nusing pi = pair<int,int>;\nusing P = pair<pi,pi>;\nusing R = pair<int,pi>;\n\nint a[LK][N][N];\n// 復元用\nP r[7][N][N];\n\nconst int INF = 19191919;\nint dp[LK+1][N][2];\nvector<R> dr[LK+1][N][2];\n\nint main(){\n    int V,E,K;\n    scanf(\" %d %d %d\", &V, &E, &K);\n\n    memset(a,-1,sizeof(a));\n\n    rep(i,E){\n        int from,to,c;\n        scanf(\" %d %d %d\", &from, &to, &c);\n        a[0][from][to] = max(a[0][from][to], c);\n    }\n\n    rep(i,V)rep(j,V){\n        if(a[0][i][j]>0) r[0][i][j] = {{i,i},{j,j}};\n    }\n\n    for(int i=1; i<LK; ++i){\n        rep(from,V)rep(to,V){\n            rep(ch,V){\n                int vf = a[i-1][from][ch];\n                int vt = a[i-1][ch][to];\n                if(vf == -1 || vt == -1) continue;\n\n                int val = vf+vt;\n                if(val > a[i][from][to]){\n                    a[i][from][to] = val;\n                    if(i<7) r[i][from][to] = {{from,ch},{ch,to}};\n                }\n            }\n        }\n    }\n\n    vector<int> route;\n    int ng=0, ok=K+1;\n    while(ok-ng>1){\n        int mid = (ng+ok)/2;\n\n        rep(i,LK+1)rep(j,N)rep(k,2){\n            dp[i][j][k] = -INF;\n            dr[i][j][k].clear();\n        }\n        rep(i,V) dp[0][i][1] = 0;\n\n        for(int b=LK-1; b>=0; --b){\n            int i = LK-1 - b;\n            int bb = mid>>b&1;\n\n            rep(j,V)rep(k,2)if(dp[i][j][k]>=0){\n                // printf(\" %d %d %d  %d\\n\",i,j,k,dp[i][j][k]);\n\n                // not move\n                if(bb == 0){\n                    if(dp[i+1][j][k] < dp[i][j][k]){\n                        dp[i+1][j][k] = dp[i][j][k];\n                        if(mid <= 100){\n                            dr[i+1][j][k] = dr[i][j][k];\n                        }\n                    }\n                }\n                else{\n                    if(dp[i+1][j][0] < dp[i][j][k]){\n                        dp[i+1][j][0] = dp[i][j][k];\n                        if(mid <= 100){\n                            dr[i+1][j][0] = dr[i][j][k];\n                        }\n                    }\n                }\n\n                // move\n                if(k==1 && bb==0) continue;\n                rep(nx,V)if(a[b][j][nx]>0){\n                    if(dp[i+1][nx][k] < dp[i][j][k]+a[b][j][nx]){\n                        dp[i+1][nx][k] = dp[i][j][k]+a[b][j][nx];\n                        if(mid <= 100){\n                            dr[i+1][nx][k] = dr[i][j][k];\n                            dr[i+1][nx][k].pb({b,{j,nx}});\n                        }\n                    }\n                }\n            }\n        }\n\n        int ans = -INF;\n        rep(i,V)rep(j,2) ans = max(ans,dp[LK][i][j]);\n        // dbg(mid); dbg(ans);\n\n        // 復元\n        vector<int> tmp;\n        if(mid <= 100){\n            rep(i,V)rep(j,2){\n                if(ans == dp[LK][i][j]){\n                    // printf(\" --- %d %d\\n\",i,j);\n                    tmp.clear();\n                    bool is_first = true;\n                    for(const auto dd:dr[LK][i][j]){\n                        if(is_first){\n                            tmp.pb(dd.se.fi);\n                            is_first = false;\n                        }\n\n                        queue<R> que;\n                        que.push(dd);\n                        // dbg(dd);\n                        while(!que.empty()){\n                            R now = que.front();\n                            que.pop();\n                            // dbg(now);\n                            int u = now.se.fi, v = now.se.se;\n                            if(now.fi == 0) tmp.pb(v);\n                            else{\n                                pi tl = r[now.fi][u][v].fi;\n                                que.push({now.fi-1,tl});\n                                pi tr = r[now.fi][u][v].se;\n                                que.push({now.fi-1,tr});\n                            }\n                        }\n                    }\n                }\n            }\n            // dbg(tmp);\n        }\n\n        if(ans >= K){\n            ok = mid;\n            route = tmp;\n        }\n        else ng = mid;\n    }\n\n    if(ok == K+1) printf(\"-1\\n\");\n    else{\n        printf(\"%d\\n\", ok);\n        if(ok <= 100){\n            assert(route.size() == ok+1);\n            rep(i,ok+1) printf(\"%d%c\", route[i], \" \\n\"[i==ok]);\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<int(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nconstexpr int INF = 1000000000;\n\nusing Array = vector<int>;\nusing Matrix = vector<Array>;\n\nMatrix mul(const Matrix& lhs, const Matrix& rhs) {\n  int r = lhs.size();\n  Matrix res(r, Array(r, -INF));\n  REP(i,r) REP(k,r) REP(j,r) {\n    res[i][j] = max(res[i][j], lhs[i][k] + rhs[k][j]);\n  }\n  return res;\n}\n\nMatrix pow(const Matrix& mat, int index) {\n  if (index == 0) {\n    int v = mat.size();\n    Matrix res(v, Array(v, -INF));\n    REP(i,v) res[i][i] = 0;\n    return res;\n  }\n  if (index == 1) return mat;\n  if ((index % 2) == 1) {\n    return mul(mat, pow(mat, index-1));\n  }\n  return pow(mul(mat, mat), index/2);\n}\n\nint main() {\n  int v,e,k;\n  cin>>v>>e>>k;\n  Matrix mat(v, Array(v, -INF));\n  REP(i,e) {\n    int s,t,c;\n    cin>>s>>t>>c;\n    mat[s][t] = max(mat[s][t], c);\n  }\n  int idx = 0;\n  auto pmat = pow(mat, v*100);\n  vector<int> score(v, 0);\n  for (; idx < k; idx += v*100) {\n    vector<int> tmp(v, -INF);\n    REP(i,v)REP(j,v) tmp[j] = max(tmp[j], score[i] + mat[i][j]);\n    int mx = -INF;\n    REP(i,v) mx = max(mx, tmp[i]);\n    swap(score, tmp);\n    if (mx >= k - v*100) {\n      break;\n    }\n  }\n  pmat = pow(mat, idx);\n  REP(i,v) score[i] = -INF;\n  REP(i,v)REP(j,v) score[j] = max(score[j], pmat[i][j]);\n  bool ok = false;\n  REP(cnt,200 * v+1) {\n    vector<int> tmp(v, -INF);\n    REP(i,v)REP(j,v) tmp[j] = max(tmp[j], score[i] + mat[i][j]);\n    int mx = -INF;\n    REP(i,v) mx = max(mx, tmp[i]);\n    swap(score, tmp);\n    if (mx >= k) {\n      idx += cnt + 1;\n      ok = true;\n      break;\n    }\n  }\n  if (ok && idx <= k) {\n    cout << idx << endl;\n  } else {\n    cout << -1 << endl;\n    return 0;\n  }\n  if (idx > 100) {\n    return 0;\n  }\n  vector<vector<int>> vscore;\n  REP(i,v) score[i] = 0;\n  REP(cnt,idx) {\n    vector<int> tmp(v, -INF);\n    REP(i,v)REP(j,v) tmp[j] = max(tmp[j], score[i] + mat[i][j]);\n    int mx = -INF;\n    REP(i,v) mx = max(mx, tmp[i]);\n    vscore.push_back(score);\n    swap(score, tmp);\n  }\n  int t = 0;\n  int mx = -INF;\n  REP(i,v) {\n    if (score[i] > mx) {\n      mx = score[i];\n      t = i;\n    }\n  }\n  vector<int> res;\n  res.push_back(t);\n  for (int i = idx-1; i >= 0; --i) {\n    int nt = 0;\n    int nmx = -INF;\n    REP(j,v) {\n      if (vscore[i][j] + mat[j][t] == mx) {\n        nt = j;\n        nmx = vscore[i][j];\n      }\n    }\n    t = nt;\n    mx = nmx;\n    res.push_back(t);\n  }\n  reverse(ALL(res));\n  REP(i,res.size()) {\n    if (i) cout << ' ';\n    cout << res[i];\n  }\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// template {{{\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define loop(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rep(i, n) loop(i, 0, n)\n#define rloop(i, a, b) for (int i = (int)(b) - 1; i >= (int)(a); i--)\n#define rrep(i, n) rloop(i, 0, n)\n#define eb emplace_back\n#define ef emplace_front\n#define pb pop_back\n#define pf pop_front\n#define all(c) std::begin(c), std::end(c)\n#define mp std::make_pair\n#define mt std::make_tuple\n#define fi first\n#define se second\n#define popcnt __builtin_popcountll\n\nusing uint = unsigned;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n\ntemplate<typename T>\nusing max_pq = priority_queue<T, vector<T>, less<T>>;\n\ntemplate<typename T>\nusing min_pq = priority_queue<T, vector<T>, greater<T>>;\n\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9 + 10;\nconst ll LLINF = 1e18 + 10;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\nconst int dx8[] = {-1, -1, 0, 1, 1, 1, 0, -1};\nconst int dy8[] = {0, -1, -1, -1, 0, 1, 1, 1};\n\ntemplate<typename T>\ninline T sq(T x){ return x * x; }\n\ntemplate<typename T, typename U>\ninline bool chmax(T &x, U y){ if (x >= y) return false; x = y; return true; }\n\ntemplate<typename T, typename U>\ninline bool chmin(T &x, U y){ if (x <= y) return false; x = y; return true; }\n\ntemplate<typename T>\ninline void sort(T &c){ std::sort(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void reverse(T &c){ std::reverse(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void unique(T &c){ std::sort(std::begin(c), std::end(c)); c.erase(std::unique(all(c)), std::end(c)); }\n\n// }}}\n\nint n, m, k;\nint g[150][150];\n\npair<int, vector<int>> calc(int x, bool build = false)\n{\n\tvector<vector<int>> dp(x + 1, vector<int>(n, 0));\n\tvector<vector<int>> pr(x + 1, vector<int>(n, -1));\n\trep(i, x) rep(j, n) rep(k, n){\n\t\tif (chmax(dp[i + 1][k], dp[i][j] + g[j][k])){\n\t\t\tpr[i + 1][k] = j;\n\t\t}\n\t}\n\n\tpair<int, vector<int>> res;\n\tint p = 0;\n\trep(i, n){\n\t\tif (chmax(res.fi, dp[x][i])){\n\t\t\tp = i;\n\t\t}\n\t}\n\tif (build){\n\t\trrep(i, x){\n\t\t\tres.se.eb(p);\n\t\t\tp = pr[i + 1][p];\n\t\t}\n\t\tres.se.eb(p);\n\t\treverse(res.se);\n\t}\n\n\treturn res;\n}\n\nvector<vector<int>> add(const vector<vector<int>> &a, const vector<vector<int>> &b)\n{\n\tvector<vector<int>> res(n, vector<int>(n, -INF));\n\trep(k, n) rep(i, n) rep(j, n){\n\t\tchmax(res[i][j], a[i][k] + b[k][j]);\n\t}\n\treturn res;\n}\n\nint calc2(int x)\n{\n\tvector<vector<int>> a(n, vector<int>(n));\n\trep(i, n) rep(j, n) a[i][j] = i == j ? 0 : -INF;\n\tauto b = a;\n\trep(i, n) rep(j, n) b[i][j] = g[i][j];\n\twhile (x){\n\t\tif (x & 1) a = add(a, b);\n\t\tb = add(b, b);\n\t\tx >>= 1;\n\t}\n\n\tint res = 0;\n\trep(i, n) rep(j, n) chmax(res, a[i][j]);\n\treturn res;\n}\n\nbool cond(int x)\n{\n\tif (x <= 100) return calc(x).fi >= k;\n\treturn calc2(x) >= k;\n}\n\nint main()\n{\n\tcin >> n >> m >> k;\n\trep(i, n) rep(j, n) g[i][j] = -INF;\n\trep(i, m){\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\tchmax(g[a][b], c);\n\t}\n\n\tint lb = 0, ub = 1000010;\n\twhile (ub - lb > 1){\n\t\tint md = (lb + ub) / 2;\n\t\t(cond(md) ? ub : lb) = md;\n\t}\n\t\n\tint res = ub;\n\t\n\tif (res > 1000000){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\t\n\tcout << res << endl;\n\t\n\tif (res <= 100){\n\t\tauto v = calc(res, true).se;\n\t\trep(i, v.size()){\n\t\t\tcout << v[i] << \"\\n \"[i < v.size() - 1];\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<int(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nconstexpr int64_t INF = INT64_C(1000000000000000000);\n\nusing Array = vector<int64_t>;\nusing Matrix = vector<Array>;\n\nMatrix mul(const Matrix& lhs, const Matrix& rhs) {\n  int r = lhs.size();\n  Matrix res(r, Array(r, -INF));\n  REP(i,r) REP(k,r) REP(j,r) {\n    res[i][j] = max(res[i][j], lhs[i][k] + rhs[k][j]);\n  }\n  return res;\n}\n\nMatrix pow(const Matrix& mat, int64_t index) {\n  if (index == 1) return mat;\n  if ((index % 2) == 1) {\n    return mul(mat, pow(mat, index-1));\n  }\n  return pow(mul(mat, mat), index/2);\n}\n\nint main() {\n  int64_t v,e,k;\n  cin>>v>>e>>k;\n  Matrix mat(v, Array(v, -INF));\n  REP(i,e) {\n    int64_t s,t,c;\n    cin>>s>>t>>c;\n    mat[s][t] = max(mat[s][t], c);\n  }\n  int64_t hi = 1;\n  Matrix m2 = mat;\n  while (true) {\n    hi *= 2;\n    m2 = mul(m2, m2);\n    int64_t mx = -INF;\n    REP(i,v)REP(j,v) mx = max(mx, m2[i][j]);\n    if (mx >= k) break;\n    if (mx < 0) break;\n  }\n  int64_t lo = 0;\n  while (hi - lo > 1) {\n    int64_t mid = (hi + lo) / 2;\n    auto pmat = pow(mat, mid);\n    int64_t mx = -INF;\n    REP(i,v)REP(j,v) mx = max(mx, pmat[i][j]);\n    if (mx < 0) {\n      hi = mid;\n    } else if (mx >= k) {\n      hi = mid;\n    } else {\n      lo = mid;\n    }\n  }\n  auto pmat = pow(mat, hi);\n  int64_t mx = -INF;\n  REP(i,v)REP(j,v) mx = max(mx, pmat[i][j]);\n  if (mx < k) {\n    cout << -1 << endl;\n    return 0;\n  } \n  cout << hi << endl;\n  if (hi > 100) {\n    return 0;\n  }\n  vector<Matrix> vmat;\n  Matrix m(v, Array(v, 0));\n  REP(i,hi) {\n    vmat.push_back(m);\n    m = mul(mat, m);\n  }\n  int s=0,t=0;\n  REP(i,v)REP(j,v) {\n    if (pmat[i][j] == mx) {\n      s = i;\n      t = j;\n    }\n  }\n  vector<int> res;\n  for (int i = hi-1; i >= 0; --i) {\n    res.push_back(t);\n    int nt=0;\n    int64_t nmx=0;\n    REP(j,v) {\n      if (vmat[i][s][j] + mat[j][t] == mx) {\n        nt = j;\n        nmx = vmat[i][s][j];\n      }\n    }\n    t = nt;\n    mx = nmx;\n  }\n  cout << s;\n  reverse(ALL(res));\n  for (int r:res) cout << ' ' << r;\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i< (int)(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define iter(c) __typeof((c).begin())\n#define pb(e) push_back(e)\n#define foreach(c, i) for(iter(c) i = (c).begin(); i != c.end(); ++i)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> vec;\ntypedef vector<vec> mat;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\n\nconst int sz = 25;\nmat memo[sz];\nll g[200][200];\nint dp[200][200];\nint pre[200][200];\n\nmat mul(const mat &A, const mat &B){\n  int n = A.size();\n  int m = B[0].size();\n  mat C(n, vec(m, 0));\n  rep(i, n)rep(j, m)rep(k, A[0].size()){\n    if(A[i][k] > 0 && B[k][j] > 0) C[i][j] = max(A[i][k] + B[k][j], C[i][j]);\n  }\n  return C;\n}\n\nvoid init(int V, int E){\n  mat A = mat(V, vec(V, 0));\n  int f, t;\n  ll c;\n  rep(i, E){\n    cin >> f >> t >> c;\n    A[f][t] = max(A[f][t], c);\n    g[f][t] = max(g[f][t], c);\n  }\n  memo[0] = A;\n  rep(i, sz - 1) memo[i+1] = mul(memo[i], memo[i]);\n}\n\nvoid calc(int V, int R, int K){\n  rep(i, R)rep(j, V)rep(k, V){\n    if(g[j][k] > 0 && (i == 0 || dp[i][j] > 0) && dp[i+1][k] < dp[i][j] + g[j][k]){\n      dp[i+1][k] = dp[i][j] + g[j][k];\n      pre[i+1][k] = j;\n    }\n  }\n\n  int v = 0;\n  rep(i, V) if(dp[R][i] >= K) v = i;\n  \n  vector<int> res;\n  res.push_back(v);\n  for(int i = R; i > 0; i--){\n    v = pre[i][v];\n    res.push_back(v);\n  }\n  //cout << res.size() << endl;\n  reverse(res.begin(), res.end());\n  rep(i, res.size()) cout << res[i] << (i == (int)res.size() - 1 ? '\\n' : ' ');\n}\n\nint main(){\n  int V, E, K, i, res = 0;\n  cin >> V >> E >> K;\n  init(V, E);\n\n  mat A;\n  \n  for(i = sz - 1; i >= 0; i--){\n    bool ok = false;\n    rep(j, V)rep(k, V) if(j != k && memo[i][j][k] >= K) ok = true;\n    if(!ok){\n      res += 1 << i;\n      A = memo[i--];\n      break;\n    }\n  }\n  \n  for(; i >= 0; i--){\n    mat B = mul(A, memo[i]);\n    bool ok = false;\n    rep(j, V)rep(k, V) if(j != k && B[j][k] >= K){\n      ok = true;\n      break;\n    }\n    if(!ok){\n      res += 1 << i;\n      A = B;\n    }\n  }\n  res++;\n  //resは経由する矢印の数\n  \n  if(res == (1 << sz)){\n    cout << -1 << endl;\n  }else {\n    cout << res << endl;\n    if(res  <= 100) calc(V, res, K);\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<int(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nconstexpr int64_t INF = INT64_C(1000000000000000000);\n\nusing Array = vector<int64_t>;\nusing Matrix = vector<Array>;\n\nMatrix mul(const Matrix& lhs, const Matrix& rhs) {\n  int r = lhs.size();\n  Matrix res(r, Array(r, -INF));\n  REP(i,r) REP(k,r) REP(j,r) {\n    res[i][j] = max(res[i][j], lhs[i][k] + rhs[k][j]);\n  }\n  return res;\n}\n\nMatrix pow(const Matrix& mat, int64_t index) {\n  if (index == 1) return mat;\n  if ((index % 2) == 1) {\n    return mul(mat, pow(mat, index-1));\n  }\n  return pow(mul(mat, mat), index/2);\n}\n\nint main() {\n  int64_t v,e,k;\n  cin>>v>>e>>k;\n  Matrix mat(v, Array(v, -INF));\n  REP(i,e) {\n    int64_t s,t,c;\n    cin>>s>>t>>c;\n    mat[s][t] = max(mat[s][t], c);\n  }\n  vector<Matrix> vmat;\n  Matrix m(v, Array(v, -INF));\n  REP(i,v) m[i][i] = 0;\n  vmat.push_back(m);\n  REP(i,v) {\n    m = mul(mat, m);\n    vmat.push_back(m);\n  }\n  int64_t mx = -INF;\n  int64_t hi = k;\n  REP(idx,v)REP(i,v)REP(j,v) {\n    if (vmat[idx+1][i][j] >= k) {\n      if (idx < hi) {\n        hi = idx;\n        mx = max(mx, vmat[idx+1][i][j]);\n      }\n    }\n  }\n  if (mx < k) {\n    hi = k;\n    int64_t lo = v;\n    while (hi - lo > 1) {\n      int64_t mid = (hi + lo) / 2;\n      auto pmat = pow(mat, mid);\n      int64_t mx = -INF;\n      REP(i,v)REP(j,v) mx = max(mx, pmat[i][j]);\n      if (mx < 0) {\n        hi = mid;\n      } else if (mx >= k) {\n        hi = mid;\n      } else {\n        lo = mid;\n      }\n    }\n  }\n  auto pmat = pow(mat, hi);\n  mx = -INF;\n  REP(i,v)REP(j,v) mx = max(mx, pmat[i][j]);\n  if (mx < k) {\n    cout << -1 << endl;\n    return 0;\n  } \n  cout << hi << endl;\n  if (hi > 100) {\n    return 0;\n  }\n  int s=0,t=0;\n  REP(i,v)REP(j,v) {\n    if (pmat[i][j] == mx) {\n      s = i;\n      t = j;\n    }\n  }\n  vector<int> res;\n  res.push_back(t);\n  for (int i = hi-1; i >= 0; --i) {\n    int nt=0;\n    int64_t nmx=0;\n    REP(j,v) {\n      if (vmat[i][s][j] + mat[j][t] == mx) {\n        nt = j;\n        nmx = vmat[i][s][j];\n      }\n    }\n    t = nt;\n    mx = nmx;\n    res.push_back(t);\n  }\n  reverse(ALL(res));\n  REP(i,res.size()) {\n    if (i) cout << ' ';\n    cout << res[i];\n  }\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> mat;\nmat op(mat a,mat b){\n\tint N=a.size();\n\tmat c(N,vi(N,-1));\n\trep(i,N) rep(j,N) rep(k,N) if(a[i][j]>=0&&b[j][k]>=0) chmax(c[i][k],a[i][j]+b[j][k]);\n\treturn c;\n}\nint getmx(mat a){\n\tint N=a.size();\n\tint mx=-1;\n\trep(i,N) rep(j,N) chmax(mx,a[i][j]);\n\treturn mx;\n}\nint main(){\n\tint N,M,K;\n\tint dp[151][150]={};\n\tint from[151][150]={};\n\tcin>>N>>M>>K;\n\tmat m(N,vi(N,0));\n\trep(i,N) rep(j,N) m[i][j]=-1;\n\trep(i,M){\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;\n\t\tchmax(m[a][b],c);\n\t}\n\trep(i,N) rep(j,N) if(i!=j) dp[i][j]=-1;\n\trep(i,150){\n\t\trep(v,N) rep(u,N){\n\t\t\tif(m[v][u]<0||dp[i][v]<0) continue;\n\t\t\tif(dp[i+1][u]<dp[i][v]+m[v][u]){\n\t\t\t\tdp[i+1][u]=dp[i][v]+m[v][u];\n\t\t\t\tfrom[i+1][u]=v;\n\t\t\t}\n\t\t}\n\t\tint mx=-1;\n\t\trep(v,N) chmax(mx,dp[i+1][v]);\n\t\tif(mx>=K){\n\t\t\tif(i>100){\n\t\t\t\tcout<<i<<endl;\n\t\t\t\treturn 0;\n\t\t\t}else{\n\t\t\t\tint x=-1;\n\t\t\t\trep(v,N) if(mx==dp[i+1][v]) x=v;\n\t\t\t\tvector<int> ans;\n\t\t\t\tans.pb(x);\n\t\t\t\tfor(int j=i+1;j>0;j--) ans.pb(from[j][x]),x=from[j][x];\n\t\t\t\treverse(all(ans));\n\t\t\t\tcout<<i+1<<endl;\n\t\t\t\trep(i,ans.size()) cout<<ans[i]<<(i+1==ans.size()?\"\\n\":\" \");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tif(i==149&&mx==0){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tmat ms[21];\n\tms[0]=m;\n\trep(i,20) ms[i+1]=op(ms[i],ms[i]);\n\tmat x(N,vi(N,-1));\n\trep(i,N) x[i][i]=0;\n\tint ans=0;\n\tfor(int i=20;i>=0;i--){\n\t\tmat nx=op(x,ms[i]);\n\t\tif(getmx(nx)<K){\n\t\t\tx=nx;\n\t\t\tans+=(1<<i);\n\t\t}\n\t}\n\tcout<<ans+1<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <queue>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#include <cstdio>\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\n#include <set>\nusing namespace std;\n\nint g[150][150];\npair<int, vector<int> > loop[150][160];\npair<int, vector<int> > p1[150][160];\npair<int, vector<int> > p2[150][160];\npair<int, vector<int> > tmp[160][150];\n\nint main(){\n  const int v = max(getInt(), 150);\n  const int e = getInt();\n  const int kk = getInt();\n\n  REP(i,v) REP(j,v) g[i][j] = -1;\n\n  REP(i,e){\n    const int v1 = getInt();\n    const int v2 = getInt();\n    const int c  = getInt();\n    g[v1][v2] = max(g[v1][v2], c);\n  }\n\n  REP(s,v){\n    REP(i,v + 10) REP(j,v) tmp[i][j] = make_pair(-1, vector<int>());\n\n    tmp[0][s] = make_pair(0, vector<int>());\n\n    REP(c, v + 5){\n      loop[s][c] = tmp[c][s];\n      p1[s][c] = tmp[c][0]; REP(i,v) p1[s][c] = max(p1[s][c], tmp[c][i]);\n\n      REP(i,v) if(tmp[c][i].first != -1){\n        vector<int> vv = tmp[c][i].second;\n        vv.push_back(0);\n        REP(j,v) if(g[i][j] != -1){\n          const int pp = tmp[c][i].first + g[i][j];\n          vv[c] = j;\n          tmp[c + 1][j] = max(tmp[c + 1][j], make_pair(pp, vv));\n        }\n      }\n    }\n  }\n\n  REP(i,v) REP(j,i) swap(g[i][j], g[j][i]);\n\n  REP(s,v){\n    REP(i,v + 10) REP(j,v) tmp[i][j] = make_pair(-1, vector<int>());\n\n    tmp[0][s] = make_pair(0, vector<int>());\n\n    REP(c, v + 5){\n      // loop[s][c] = tmp[c][s];\n      p2[s][c] = tmp[c][0]; REP(i,v) p2[s][c] = max(p2[s][c], tmp[c][i]);\n\n      REP(i,v) if(tmp[c][i].first != -1){\n        vector<int> vv = tmp[c][i].second;\n        vv.push_back(0);\n        REP(j,v) if(g[i][j] != -1){\n          const int pp = tmp[c][i].first + g[i][j];\n          vv[c] = j;\n          tmp[c + 1][j] = max(tmp[c + 1][j], make_pair(pp, vv));\n        }\n      }\n    }\n  }\n\n  REP(i,v) REP(j,i) swap(g[i][j], g[j][i]);\n\n  const int inf = 10000000;\n  pair<int, pair<int, pair<int, pair<int, pair<int, int> > > > > ans;\n  ans.first = inf;\n\n  REP(s,v){\n    REP(i,v + 2) REP(j,v + 2) REP(k, v + 2){\n      if(p1[s][i].first != -1 &&\n         p2[s][j].first != -1 &&\n         loop[s][k].first != -1){\n        const int pt = p1[s][i].first +\n          p2[s][j].first;\n\n        if(pt >= kk){\n          ans = min(ans, make_pair(i + j + k, make_pair(s, make_pair(i, make_pair(j, make_pair(k, 0))))));\n        }else{\n          if(loop[s][k].first > 0){\n            const int diff = kk - pt;\n            const int cnt = (diff + loop[s][k].first - 1) / loop[s][k].first;\n            ans = min(ans, make_pair(i + j + k * cnt, make_pair(s, make_pair(i, make_pair(j, make_pair(k, cnt))))));\n          }\n        }\n      }\n    }\n  }\n\n  if(ans.first == inf){\n    printf(\"-1\\n\");\n  }else{\n    printf(\"%d\\n\", ans.first);\n\n    if(ans.first <= 100){\n      const int s = ans.second.first;\n      const int i = ans.second.second.first;\n      const int j = ans.second.second.second.first;\n      const int k = ans.second.second.second.second.first;\n      const int c = ans.second.second.second.second.second;\n\n      vector<int> v;\n\n      {\n        REP(ii, j) v.push_back(p2[s][j].second[j - ii - 1]);\n      }\n      v.push_back(s);\n\n      REP(cc,c){\n        REP(ii, k) v.push_back(loop[s][k].second[ii]);\n      }\n\n      {\n        REP(ii, i) v.push_back(p1[s][i].second[ii]);\n      }\n\n      REP(i,v.size()) printf(\"%d%c\", v[i], i == (int)v.size() - 1 ? '\\n' : ' ');\n      /*\n      int a = 0;\n      REP(i, v.size() - 1)\n        a += g[v[i]][v[i + 1]];\n      printf(\"a: %d\\n\", a);\n      */\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// template {{{\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define loop(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rep(i, n) loop(i, 0, n)\n#define rloop(i, a, b) for (int i = (int)(b) - 1; i >= (int)(a); i--)\n#define rrep(i, n) rloop(i, 0, n)\n#define eb emplace_back\n#define ef emplace_front\n#define pb pop_back\n#define pf pop_front\n#define all(c) std::begin(c), std::end(c)\n#define mp std::make_pair\n#define mt std::make_tuple\n#define fi first\n#define se second\n#define popcnt __builtin_popcountll\n\nusing uint = unsigned;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n\ntemplate<typename T>\nusing max_pq = priority_queue<T, vector<T>, less<T>>;\n\ntemplate<typename T>\nusing min_pq = priority_queue<T, vector<T>, greater<T>>;\n\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9 + 10;\nconst ll LLINF = 1e18 + 10;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\nconst int dx8[] = {-1, -1, 0, 1, 1, 1, 0, -1};\nconst int dy8[] = {0, -1, -1, -1, 0, 1, 1, 1};\n\ntemplate<typename T>\ninline T sq(T x){ return x * x; }\n\ntemplate<typename T, typename U>\ninline bool chmax(T &x, U y){ if (x >= y) return false; x = y; return true; }\n\ntemplate<typename T, typename U>\ninline bool chmin(T &x, U y){ if (x <= y) return false; x = y; return true; }\n\ntemplate<typename T>\ninline void sort(T &c){ std::sort(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void reverse(T &c){ std::reverse(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void unique(T &c){ std::sort(std::begin(c), std::end(c)); c.erase(std::unique(all(c)), std::end(c)); }\n\n// }}}\n\nint n, m, k;\nint g[150][150];\n\npair<int, vector<int>> calc(int x, bool build = false)\n{\n\tvector<vector<int>> dp(x + 1, vector<int>(n, 0));\n\tvector<vector<int>> pr(x + 1, vector<int>(n, -1));\n\trep(i, x) rep(j, n) rep(k, n){\n\t\tif (chmax(dp[i + 1][k], dp[i][j] + g[j][k])){\n\t\t\tpr[i + 1][k] = j;\n\t\t}\n\t}\n\n\tpair<int, vector<int>> res;\n\tint p = 0;\n\trep(i, n){\n\t\tif (chmax(res.fi, dp[x][i])){\n\t\t\tp = i;\n\t\t}\n\t}\n\tif (build){\n\t\trrep(i, x){\n\t\t\tres.se.eb(p);\n\t\t\tp = pr[i + 1][p];\n\t\t}\n\t\tres.se.eb(p);\n\t\treverse(res.se);\n\t}\n\n\treturn res;\n}\n\nvector<vector<int>> add(const vector<vector<int>> &a, const vector<vector<int>> &b)\n{\n\tvector<vector<int>> res(n, vector<int>(n, -INF));\n\trep(i, n) rep(j, n){\n\t\tchmax(res[i][j], max(a[i][j], b[i][j]));\n\t}\n\trep(k, n) rep(i, n) rep(j, n){\n\t\tchmax(res[i][j], a[i][k] + b[k][j]);\n\t}\n\treturn res;\n}\n\nint calc2(int x)\n{\n\tvector<vector<int>> a(n, vector<int>(n));\n\trep(i, n) rep(j, n) a[i][j] = i == j ? 0 : -INF;\n\tauto b = a;\n\trep(i, n) rep(j, n) b[i][j] = g[i][j];\n\twhile (x){\n\t\tif (x & 1) a = add(a, b);\n\t\tb = add(b, b);\n\t\tx >>= 1;\n\t}\n\n\tint res = 0;\n\trep(i, n) rep(j, n) chmax(res, a[i][j]);\n\treturn res;\n}\n\nbool cond(int x)\n{\n\tif (x <= 100) return calc(x).fi >= k;\n\treturn calc2(x) >= k;\n}\n\nint main()\n{\n\tcin >> n >> m >> k;\n\trep(i, n) rep(j, n) g[i][j] = -INF;\n\trep(i, m){\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\tchmax(g[a][b], c);\n\t}\n\n\tint lb = 0, ub = 1000010;\n\twhile (ub - lb > 1){\n\t\tint md = (lb + ub) / 2;\n\t\t(cond(md) ? ub : lb) = md;\n\t}\n\t\n\tint res = ub;\n\t\n\tif (res > 1000000){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\t\n\tcout << res << endl;\n\t\n\tif (res <= 100){\n\t\tauto v = calc(res, true).se;\n\t\trep(i, v.size()){\n\t\t\tcout << v[i] << \"\\n \"[i < v.size() - 1];\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<int(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nconstexpr int INF = 1000000000;\n\nusing Array = vector<int>;\nusing Matrix = vector<Array>;\n\nMatrix mul(const Matrix& lhs, const Matrix& rhs) {\n  int r = lhs.size();\n  Matrix res(r, Array(r, -INF));\n  REP(i,r) REP(k,r) REP(j,r) {\n    res[i][j] = max(res[i][j], lhs[i][k] + rhs[k][j]);\n  }\n  return res;\n}\n\nMatrix pow(const Matrix& mat, int index) {\n  if (index == 1) return mat;\n  if ((index % 2) == 1) {\n    return mul(mat, pow(mat, index-1));\n  }\n  return pow(mul(mat, mat), index/2);\n}\n\nint main() {\n  int v,e,k;\n  cin>>v>>e>>k;\n  Matrix mat(v, Array(v, -INF));\n  REP(i,e) {\n    int s,t,c;\n    cin>>s>>t>>c;\n    mat[s][t] = max(mat[s][t], c);\n  }\n  vector<vector<int>> vscore;\n  vector<int> score(v, 0);\n  int lo = INF;\n  REP(cnt,k) {\n    vector<int> tmp(v, -INF);\n    REP(i,v)REP(j,v) tmp[j] = max(tmp[j], score[i] + mat[i][j]);\n    int mx = -INF;\n    REP(i,v) mx = max(mx, tmp[i]);\n    if (cnt < 100) vscore.push_back(score);\n    swap(score, tmp);\n    if (mx >= k) {\n      lo = cnt + 1;\n      break;\n    }\n  }\n  if (lo <= k) {\n    cout << lo << endl;\n  } else {\n    cout << -1 << endl;\n  }\n  if (lo > 100) {\n    return 0;\n  }\n  int t = 0;\n  int mx = -INF;\n  REP(i,v) {\n    if (score[i] > mx) {\n      mx = score[i];\n      t = i;\n    }\n  }\n  vector<int> res;\n  res.push_back(t);\n  for (int i = lo-1; i >= 0; --i) {\n    int nt = 0;\n    int nmx = -INF;\n    REP(j,v) {\n      if (vscore[i][j] + mat[j][t] == mx) {\n        nt = j;\n        nmx = vscore[i][j];\n      }\n    }\n    t = nt;\n    mx = nmx;\n    res.push_back(t);\n  }\n  reverse(ALL(res));\n  REP(i,res.size()) {\n    if (i) cout << ' ';\n    cout << res[i];\n  }\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<int(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nconstexpr int64_t INF = INT64_C(1000000000000000000);\n\nusing Array = vector<int64_t>;\nusing Matrix = vector<Array>;\n\nMatrix mul(const Matrix& lhs, const Matrix& rhs) {\n  int r = lhs.size();\n  Matrix res(r, Array(r, -INF));\n  REP(i,r) REP(k,r) REP(j,r) {\n    res[i][j] = max(res[i][j], lhs[i][k] + rhs[k][j]);\n  }\n  return res;\n}\n\nMatrix pow(const Matrix& mat, int64_t index) {\n  if (index == 1) return mat;\n  if ((index % 2) == 1) {\n    return mul(mat, pow(mat, index-1));\n  }\n  return pow(mul(mat, mat), index/2);\n}\n\nint main() {\n  int64_t v,e,k;\n  cin>>v>>e>>k;\n  Matrix mat(v, Array(v, -INF));\n  REP(i,e) {\n    int64_t s,t,c;\n    cin>>s>>t>>c;\n    mat[s][t] = max(mat[s][t], c);\n  }\n  vector<Matrix> vmat;\n  Matrix m(v, Array(v, -INF));\n  REP(i,v) m[i][i] = 0;\n  vmat.push_back(m);\n  REP(i,max(INT64_C(100),v)) {\n    m = mul(mat, m);\n    vmat.push_back(m);\n  }\n  int64_t mx = -INF;\n  int64_t hi = k;\n  REP(idx,v)REP(i,v)REP(j,v) {\n    if (vmat[idx+1][i][j] >= k) {\n      if (idx < hi) {\n        hi = idx+1;\n        mx = max(mx, vmat[idx+1][i][j]);\n      }\n    }\n  }\n  int64_t mx2 = 0;\n  REP(i,v)REP(j,v) mx2 = max(mx2, vmat[v][i][j]);\n  if (mx2 > 0 && mx < k) {\n    hi = k;\n    int64_t lo = v;\n    while (hi - lo > 1) {\n      int64_t mid = (hi + lo) / 2;\n      auto pmat = pow(mat, mid);\n      int64_t mx = -INF;\n      REP(i,v)REP(j,v) mx = max(mx, pmat[i][j]);\n      if (mx < 0) {\n        hi = mid;\n      } else if (mx >= k) {\n        hi = mid;\n      } else {\n        lo = mid;\n      }\n    }\n  }\n  auto pmat = pow(mat, hi);\n  mx = -INF;\n  REP(i,v)REP(j,v) mx = max(mx, pmat[i][j]);\n  if (mx < k) {\n    cout << -1 << endl;\n    return 0;\n  } \n  cout << hi << endl;\n  if (hi > 100) {\n    return 0;\n  }\n  int s=0,t=0;\n  REP(i,v)REP(j,v) {\n    if (pmat[i][j] == mx) {\n      s = i;\n      t = j;\n    }\n  }\n  vector<int> res;\n  res.push_back(t);\n  for (int i = hi-1; i >= 0; --i) {\n    int nt=0;\n    int64_t nmx=0;\n    REP(j,v) {\n      if (vmat[i][s][j] + mat[j][t] == mx) {\n        nt = j;\n        nmx = vmat[i][s][j];\n      }\n    }\n    t = nt;\n    mx = nmx;\n    res.push_back(t);\n  }\n  reverse(ALL(res));\n  REP(i,res.size()) {\n    if (i) cout << ' ';\n    cout << res[i];\n  }\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\nint V,E,K;\nconst int INF = (1<<29);\nmat G;\n\nmat g[30];\nmat u[30];\n\nint add(int a,int b){\n  if(a==-INF||b==-INF)return -INF;\n  return min(a+b,K);\n}\n\npair<mat,mat> merge(mat A,mat B, bool flag=false){\n  mat X( V, vec(V, -INF) );\n  mat Y( V, vec(V, -INF) );\n  \n  for(int from=0;from<V;from++){\n    for(int to=0;to<V;to++){\n      for(int ex=0;ex<V;ex++){\n        int cost=add(A[from][ex],B[ex][to]);\n        if(X[from][to]<cost){\n          X[from][to]=cost;\n          Y[from][to]=ex;\n        }\n      }\n    }\n  }\n  return make_pair(X,Y);\n}\n\n\nint calc(int m,int &si,int &ti){\n  mat t;\n  for(int i=0;i<30;i++){\n    if(m>>i&1){\n      if(t.empty()){\n        t=g[i];\n      }else{\n        t=merge(t,g[i]).first;\n      }\n    }\n  }\n  \n  int res=-INF;\n  for(int i=0;i<V;i++){\n    for(int j=0;j<V;j++){\n      if(res<t[i][j]){\n        si=i;\n        ti=j;\n        res=t[i][j];\n      }\n    }\n  }\n  return res;\n}\n\nvoid Dfs(vec& s,int from,int to,int len){\n  if(len==0)return;\n  \n  for(int i=0;i<30;i++){\n    if(~len>>i&1)continue;\n    int ex=u[i][from][to];\n\n    if(i==0){\n      if(len>=2)s.push_back(ex);\n      Dfs(s,ex,to,len-1);\n    }else{\n      int sub=(1<<i)/2;\n      Dfs(s,from,ex,sub);\n      s.push_back(ex);\n      Dfs(s,ex,to,len-sub);\n    }\n    break;\n  }\n}\n\nint main(){\n\n  cin>>V>>E>>K;\n  G=mat( V, vec(V, -INF) );\n  \n  g[0]=u[0]=G;\n  for(int i=0;i<V;i++)g[0][i][i]=0;\n  \n  for(int i=0;i<E;i++){\n    int a,b,c;\n    cin>>a>>b>>c;\n    assert(a!=b);\n    G[a][b]=max(G[a][b],c);\n    \n    g[0][a][b]=max(g[0][a][b],c);\n    u[0][a][b]=b;\n  }\n\n  \n  for(int i=1;i<30;i++){\n    pair<mat,mat> temp=merge(g[i-1],g[i-1]);\n    g[i]=temp.first;\n    u[i]=temp.second;\n  }\n  \n  int si,ti;\n  int left=1,right=K+1,mid;\n\n  while( left < right ){\n    mid=(left+right)/2;\n    if( calc(mid,si,ti) >= K ){\n      right=mid;\n    }else{\n      left=mid+1;\n    }\n  }\n\n  for(int i=0;i<V;i++)g[0][i][i]=-INF;\n  for(int i=1;i<30;i++){\n    pair<mat,mat> temp=merge(g[i-1],g[i-1]);\n    g[i]=temp.first;\n    u[i]=temp.second;\n  }\n  \n  calc(left,si,ti);\n  \n  if(left==K+1){\n    cout<<-1<<endl;\n  }else{\n    cout<<left<<endl;\n    if(left<=100){\n      vec tab;\n      tab.push_back(si);\n      Dfs(tab,si,ti,left);\n      tab.push_back(ti);\n      \n      int sum=0;\n      assert( left+1==(int)tab.size() );\n      for(int i=0;i<(int)tab.size();i++){\n        if(i>0 && G[ tab[i-1]][ tab[i] ] == -INF ){\n          assert(0);\n        }\n        if(i>0)sum+=G[ tab[i-1]][ tab[i] ];\n        if(i)cout<<' ';\n        cout<<tab[i];\n      }\n      cout<<endl;\n      assert(sum>=K);\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<int(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nconstexpr int INF = 1000000000;\n\nusing Array = vector<int>;\nusing Matrix = vector<Array>;\n\nMatrix mul(const Matrix& lhs, const Matrix& rhs) {\n  int r = lhs.size();\n  Matrix res(r, Array(r, -INF));\n  REP(i,r) REP(k,r) REP(j,r) {\n    res[i][j] = max(res[i][j], lhs[i][k] + rhs[k][j]);\n  }\n  return res;\n}\n\nMatrix pow(const Matrix& mat, int index) {\n  if (index == 0) {\n    int v = mat.size();\n    Matrix res(v, Array(v, -INF));\n    REP(i,v) res[i][i] = 0;\n    return res;\n  }\n  if (index == 1) return mat;\n  if ((index % 2) == 1) {\n    return mul(mat, pow(mat, index-1));\n  }\n  return pow(mul(mat, mat), index/2);\n}\n\nint main() {\n  int v,e,k;\n  cin>>v>>e>>k;\n  Matrix mat(v, Array(v, -INF));\n  REP(i,e) {\n    int s,t,c;\n    cin>>s>>t>>c;\n    mat[s][t] = max(mat[s][t], c);\n  }\n  int hi = k;\n  int lo = 0;\n  while (hi - lo > 1) {\n    int mid = (hi + lo) / 2;\n    auto pmat = pow(mat, mid);\n    int mx = -INF;\n    REP(i,v)REP(j,v) mx = max(mx, pmat[i][j]);\n    if (mx > k - 100 * v) {\n      hi = mid;\n    } else {\n      lo = mid;\n    }\n  }\n  lo = max(0, lo - v * 100);\n  auto pmat = pow(mat, lo);\n  vector<int> score(v, -INF);\n  REP(i,v)REP(j,v) score[j] = max(score[j], pmat[i][j]);\n  REP(cnt,k) {\n    vector<int> tmp(v, -INF);\n    REP(i,v)REP(j,v) tmp[j] = max(tmp[j], score[i] + mat[i][j]);\n    int mx = -INF;\n    REP(i,v) mx = max(mx, tmp[i]);\n    swap(score, tmp);\n    if (mx >= k) {\n      lo += cnt + 1;\n      break;\n    }\n  }\n  if (lo > 0 && lo <= k) {\n    cout << lo << endl;\n  } else {\n    cout << -1 << endl;\n    return 0;\n  }\n  if (hi > 100) {\n    return 0;\n  }\n  vector<vector<int>> vscore;\n  REP(i,v) score[i] = 0;\n  REP(cnt,lo) {\n    vector<int> tmp(v, -INF);\n    REP(i,v)REP(j,v) tmp[j] = max(tmp[j], score[i] + mat[i][j]);\n    int mx = -INF;\n    REP(i,v) mx = max(mx, tmp[i]);\n    vscore.push_back(score);\n    swap(score, tmp);\n  }\n  int t = 0;\n  int mx = -INF;\n  REP(i,v) {\n    if (score[i] > mx) {\n      mx = score[i];\n      t = i;\n    }\n  }\n  vector<int> res;\n  res.push_back(t);\n  for (int i = lo-1; i >= 0; --i) {\n    int nt = 0;\n    int nmx = -INF;\n    REP(j,v) {\n      if (vscore[i][j] + mat[j][t] == mx) {\n        nt = j;\n        nmx = vscore[i][j];\n      }\n    }\n    t = nt;\n    mx = nmx;\n    res.push_back(t);\n  }\n  reverse(ALL(res));\n  REP(i,res.size()) {\n    if (i) cout << ' ';\n    cout << res[i];\n  }\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <complex>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<58;\nconst double pi=acos(-1);\nconst double eps=1e-7;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nint n,m,K;\nvvp g;\n\nint main(){\n\tcin>>n>>m>>K;\n\tg=vvp(n);\n\tfor(int i=0;i<m;i++){\n\t\tint u,v,c;\n\t\tcin>>u>>v>>c;\n\t\tg[u].push_back({v,c});\n\t}\n\tvvi dp(101,vi(n));\n\tint V=-1,num=0;\n\tfor(int i=1;i<=100;i++){\n\t\tfor(int j=0;j<n;j++) for(int k=0;k<g[j].size();k++){\n\t\t\tP p=g[j][k];\n\t\t\tint v=p.first,c=p.second;\n\t\t\tdp[i][v]=max(dp[i][v],dp[i-1][j]+c);\n\t\t}\n\t\tfor(int j=0;j<n;j++) if(dp[i][j]>=K){\n\t\t\tV=j;\n\t\t\tnum=i;\n\t\t}\n\t\tif(V!=-1) break;\n\t}\n\tif(V!=-1){\n\t\tvi res(num+1);\n\t\tres[num]=V;\n\t\tfor(int i=num;i>0;i--) for(int j=0;j<n;j++) for(int k=0;k<g[j].size();k++){\n\t\t\tP p=g[j][k];\n\t\t\tint v=p.first,c=p.second;\n\t\t\tif(v==res[i]&&dp[i][res[i]]==dp[i-1][j]+c) res[i-1]=j;\n\t\t}\n\t\tcout<<num<<endl<<res[0];\n\t\tfor(int j=1;j<=num;j++) cout<<' '<<res[j];\n\t\tcout<<endl;\n\t\treturn 0;\n\t}\n\tvvi DP(21,vi(n));\n/*\tfor(int i=1;i<21;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tfor(int )\n\t\t}\n\t}*/\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> mat;\nmat op(mat a,mat b){\n\tint N=a.size();\n\tmat c(N,vi(N,-1));\n\trep(i,N) rep(j,N) rep(k,N) if(a[i][j]>=0&&b[j][k]>=0) chmax(c[i][k],a[i][j]+b[j][k]);\n\treturn c;\n}\nint getmx(mat a){\n\tint N=a.size();\n\tint mx=-1;\n\trep(i,N) rep(j,N) chmax(mx,a[i][j]);\n\treturn mx;\n}\nint main(){\n\tint N,M,K;\n\tint dp[151][150]={};\n\tint from[151][150]={};\n\tcin>>N>>M>>K;\n\tmat m(N,vi(N,0));\n\trep(i,N) rep(j,N) m[i][j]=-1;\n\trep(i,M){\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;\n\t\tchmax(m[a][b],c);\n\t}\n\trep1(i,150) rep(j,N) dp[i][j]=-1;\n\trep(i,150){\n\t\trep(v,N) rep(u,N){\n\t\t\tif(m[v][u]<0||dp[i][v]<0) continue;\n\t\t\tif(dp[i+1][u]<dp[i][v]+m[v][u]){\n\t\t\t\tdp[i+1][u]=dp[i][v]+m[v][u];\n\t\t\t\tfrom[i+1][u]=v;\n\t\t\t}\n\t\t}\n\t\tint mx=-1;\n\t\trep(v,N) chmax(mx,dp[i+1][v]);\n\t\tif(mx>=K){\n\t\t\tif(i>100){\n\t\t\t\tcout<<i<<endl;\n\t\t\t\treturn 0;\n\t\t\t}else{\n\t\t\t\tint x=-1;\n\t\t\t\trep(v,N) if(mx==dp[i+1][v]) x=v;\n\t\t\t\tvector<int> ans;\n\t\t\t\tans.pb(x);\n\t\t\t\tfor(int j=i+1;j>0;j--) ans.pb(from[j][x]),x=from[j][x];\n\t\t\t\treverse(all(ans));\n\t\t\t\tcout<<i+1<<endl;\n\t\t\t\trep(i,ans.size()) cout<<ans[i]<<(i+1==ans.size()?\"\\n\":\" \");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tif(i==149&&mx==-1){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tmat ms[21];\n\tms[0]=m;\n\trep(i,20) ms[i+1]=op(ms[i],ms[i]);\n\tmat x(N,vi(N,-1));\n\trep(i,N) x[i][i]=0;\n\tint ans=0;\n\tfor(int i=20;i>=0;i--){\n\t\tmat nx=op(x,ms[i]);\n\t\tif(getmx(nx)<K){\n\t\t\tx=nx;\n\t\t\tans+=(1<<i);\n\t\t}\n\t}\n\tcout<<ans+1<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\nint V,E,K;\nconst int INF = (1<<30);\nmat G;\n\nmat g[30];\nmat u[30];\n\nint add(int a,int b){\n  if(a==-INF||b==-INF)return -INF;\n  return min(a+b,K);\n}\n\npair<mat,mat> merge(mat A,mat B, bool flag=false){\n  mat X( V, vec(V, -INF) );\n  mat Y( V, vec(V, -INF) );\n  \n  for(int from=0;from<V;from++){\n    for(int to=0;to<V;to++){\n      for(int ex=0;ex<V;ex++){\n        int cost=add(A[from][ex],B[ex][to]);\n        if(X[from][to]<cost){\n          X[from][to]=cost;\n          Y[from][to]=ex;\n        }\n      }\n    }\n  }\n  return make_pair(X,Y);\n}\n\n\nint calc(int m,int &si,int &ti){\n  mat t;\n  for(int i=0;i<30;i++){\n    if(m>>i&1){\n      if(t.empty()){\n        t=g[i];\n      }else{\n        t=merge(t,g[i]).first;\n      }\n    }\n  }\n  \n  int res=-INF;\n  for(int i=0;i<V;i++){\n    for(int j=0;j<V;j++){\n      if(res<t[i][j]){\n        si=i;\n        ti=j;\n        res=t[i][j];\n      }\n    }\n  }\n  return res;\n}\n\nvoid Dfs(vec& s,int from,int to,int len){\n  if(len==0)return;\n  \n  for(int i=0;i<30;i++){\n    if(~len>>i&1)continue;\n    int ex=u[i][from][to];\n\n    if(i==0){\n      if(len>=2)s.push_back(ex);\n      Dfs(s,ex,to,len-1);\n    }else{\n      int sub=(1<<i)/2;\n      Dfs(s,from,ex,sub);\n      s.push_back(ex);\n      Dfs(s,ex,to,len-sub);\n    }\n    break;\n  }\n}\n\nint main(){\n  cin>>V>>E>>K;\n  G=mat( V, vec(V, -INF) );\n  \n  g[0]=u[0]=G;\n  for(int i=0;i<V;i++)g[0][i][i]=0;\n  \n  for(int i=0;i<E;i++){\n    int a,b,c;\n    cin>>a>>b>>c;\n    G[a][b]=max(G[a][b],c);\n    \n    g[0][a][b]=max(g[0][a][b],c);\n    u[0][a][b]=b;\n  }\n\n  \n  for(int i=1;i<30;i++){\n    pair<mat,mat> temp=merge(g[i-1],g[i-1]);\n    g[i]=temp.first;\n    u[i]=temp.second;\n  }\n\n\n  int si,ti;\n  int left=1,right=K+1,mid;\n\n  while( left < right ){\n    mid=(left+right)/2;\n    if( calc(mid,si,ti) >= K ){\n      right=mid;\n    }else{\n      left=mid+1;\n    }\n  }\n\n  for(int i=0;i<V;i++)g[0][i][i]=-INF;\n  for(int i=1;i<30;i++){\n    pair<mat,mat> temp=merge(g[i-1],g[i-1]);\n    g[i]=temp.first;\n    u[i]=temp.second;\n  }\n  \n  if(left==K+1){\n    cout<<-1<<endl;\n  }else{\n    cout<<left<<endl;\n    if(left<=100){\n      vec tab;\n      tab.push_back(si);\n      Dfs(tab,si,ti,left);\n      tab.push_back(ti);\n      //      cout<<tab.size()<<endl;\n      int sum=0;\n      assert( left +1 == (int)tab.size() );\n      for(int i=0;i<(int)tab.size();i++){\n        if(i>0 && G[ tab[i-1]][ tab[i] ] == -INF ){\n          assert(0);\n        }\n        if(i>0)   sum+=G[ tab[i-1]][ tab[i] ];\n        if(i)cout<<' ';\n        cout<<tab[i];\n      }\n      cout<<endl;\n      assert(sum>=K);\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int logMaxStep = 30;\n\ntypedef long long ll;\ntypedef vector< vector<ll> > Graph;\n\nint GetLogStep(int S) {\n\tint res;\n\tfor (res = 0; (1 << res) <= S; ++res);\n\treturn res;\n}\nGraph nextG(const Graph& g1, const Graph& g2) {\n\tint N = g1.size();\n\tGraph res(N, vector<ll>(N, 0));\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tfor (int k = 0; k < N; ++k) {\n\t\t\t\tif (g1[i][k] > 0 && g2[k][j] > 0) {\n\t\t\t\t\tres[i][j] = max(res[i][j], g1[i][k]+g2[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nvector<int> nextDP(vector<ll>& dp, Graph& g) {\n\tint N = g.size();\n\tvector<int> prevV(N, -1);\n\tvector<ll> ndp(N, -1);\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tif (dp[i] >= 0 && g[i][j] > 0) {\n\t\t\t\tif (dp[i]+g[i][j] > ndp[j]) {\n\t\t\t\t\tndp[j] = dp[i]+g[i][j];\n\t\t\t\t\tprevV[j] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tdp[i] = ndp[i];\n\t}\n\treturn prevV;\n}\nll GetMaxScore(vector<Graph>& powG, int S) {\n\tint N = powG[0].size();\n\tint logS = GetLogStep(S);\n\tvector<ll> dp(N, 0);\n\tfor (int i = 0; i < logS; ++i) {\n\t\tGraph& g = powG[i];\n\t\tif ( (1 << i) & S ) {\n\t\t\tnextDP(dp, g);\n\t\t}\n\t}\n\tll res = -1;\n\tfor (int i = 0; i < dp.size(); ++i) {\n\t\tres = max(res, dp[i]);\n\t}\n\treturn res;\n}\nll check200Step(Graph& G, int K) {\n\tint N = G.size();\n\tvector<ll> dp(N, 0);\n\tvector< vector<int> > prevV;\n\tll lastAns = -1;\n\tfor (int t = 0; t < 1000; ++t) {\n\t\tprevV.push_back( nextDP(dp, G) );\n\t\tint aid = 0;\n\t\tfor (int i = 0; i < dp.size(); ++i) {\n\t\t\tif (dp[i] > dp[aid]) aid = i;\n\t\t}\n\t\tif (dp[aid] >= K) {\n\t\t\tcout << t+1 << endl;\n\t\t\tif (t+1 <= 100) {\n\t\t\t\tvector<int> vl;\n\t\t\t\tint v = aid; vl.push_back(v);\n\t\t\t\tfor (int i = t; i >= 0; --i) {\n\t\t\t\t\tv = prevV[i][v];\n\t\t\t\t\tvl.push_back(v);\n\t\t\t\t}\n\t\t\t\treverse(vl.begin(), vl.end());\n\t\t\t\tfor (int i = 0; i < vl.size(); ++i) {\n\t\t\t\t\tif (i) cout << \" \";\n\t\t\t\t\tcout << vl[i];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t\treturn -2;\n\t\t}\n\t\tlastAns = dp[aid];\n\t}\n\treturn lastAns;\n}\nint main() {\n\tint N, E, K; cin >> N >> E >> K;\n\tGraph G(N, vector<ll>(N, 0));\n\tfor (int i = 0; i < E; ++i) {\n\t\tint a, b; ll c; cin >> a >> b >> c;\n\t\tG[a][b] = max(G[a][b], c);\n\t}\n\tll result = check200Step(G, K);\n\tif (result > 0) {\n\t\tvector<Graph> powG(logMaxStep+1); powG[0] = G;\n\t\tfor (int i = 0; i < logMaxStep; ++i) {\n\t\t\tpowG[i+1] = nextG(powG[i], powG[i]);\n\t\t}\n/*\n\t\tfor (int i = N; i <= N+100; ++i) {\n\t\t\tif (GetMaxScore(powG, i+1) >= result) {\n\t\t\t\tassert(GetMaxScore(powG, i+1) > GetMaxScore(powG, i));\n\t\t\t}\n\t\t}\n*/\n\t\tint ans = K;\n\t\tfor (int rest = 0; rest < N; ++rest) {\n\t\t\tint l = 0, r = K/N+2;\n\t\t\twhile (r-l > 1) {\n\t\t\t\tint m = (l + r)/2;\n\t\t\t\tif ( GetMaxScore(powG, m * N + rest) >= K ) {\n\t\t\t\t\tr = m;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tl = m;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = min(ans, r*N+rest);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\telse if (result == -1) {\n\t\tcout << -1 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\ntypedef long long int Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\n\nbool operator < (const Edge &e, const Edge &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<vector<pair<vector<int>, long long int>>>type;\nint V, E, K;\n type time(const type&lts, const type&rts, const bool flag) {\n\ttype squs(V,vector<pair<vector<int>,long long int>>(V));\n\tfor (int i = 0; i < V; ++i) {\n\t\tfor (int j = 0; j < V; ++j) {\n\t\t\tif (i == j)squs[i][j] = make_pair(vector<int>(), 0ll);\n\t\t\telse squs[i][j] = make_pair(vector<int>(), static_cast<long long>(-1e17));\n\t\t}\n\t}\n\tlong long int amax = 0;\n\tfor (int k = 0; k < V; ++k) {\n\t\tfor (int i = 0; i < V; ++i) {\n\t\t\tfor (int j = 0; j < V; ++j) {\n\t\t\t\tif (squs[i][j].second <lts[i][k].second + rts[k][j].second) {\n\t\t\t\t\tsqus[i][j].second = lts[i][k].second + rts[k][j].second;\n\t\t\t\t\tamax = max(amax, squs[i][j].second);\n\t\t\t\t\tif (flag) {\n\t\t\t\t\t\tsqus[i][j].first.clear();\n\t\t\t\t\t\tsqus[i][j].first.insert(squs[i][j].first.end(), lts[i][k].first.begin(), lts[i][k].first.end());\n\t\t\t\t\t\tsqus[i][j].first.insert(squs[i][j].first.end(), rts[k][j].first.begin(), rts[k][j].first.end());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn squs;\n}\ntype square(const type&ts,bool flag) {\n\tconst type lts(ts);\n\tconst type rts(ts);\n\treturn time(lts, rts, flag);\n}\n\ntype power(const type&ts,const long long  int num,const bool flag) {\n\tassert(num);\n\tif (num == 1)return ts;\n\telse {\n\t\ttype pot(square(power(ts,num/2,flag),flag));\n\t\tif (num % 2) {\n\t\t\tpot = time(pot, ts, flag);\n\t\t}\n\t\treturn pot;\n\t}\n}\nvector<int>ans;\nbool check(const type &ts,const long long int run,const int point,const bool flag) {\n\t\n\ttype t(power(ts, run, flag&&run <= 100));\n\tlong long int amax = 0;\n\tfor (int i = 0; i < V; ++i) {\n\t\tfor (int j = 0; j < V; ++j) {\n\t\t\tif (amax < t[i][j].second) {\n\t\t\t\tamax = t[i][j].second;\n\t\t\t\tif (run <= 100&&flag) {\n\t\t\t\t\t\n\t\t\t\t\tans = t[i][j].first;\n\t\t\t\t\tans.insert(ans.begin(), i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (amax >= point)return true;\n\telse return false;\n}\n\nint main() { cin >> V >> E >> K;\n\ttype times(V, vector<pair<vector<int>,long long int>>(V, make_pair(vector<int>(),static_cast<long long int>(-1e18))));\n\tfor (int i = 0; i < E; ++i) {\n\t\tlong long int a, b, c; cin >> a >> b >> c;\n\n\t\ttimes[a][b].second = max(times[a][b].second, c);\n\t\ttimes[a][b].first = vector<int>(1,b);\n\t}\n\tfor (int i = 0; i < V; ++i) {\n\t\ttimes[i][i] = make_pair(vector<int>(1,i),0);\n\t\t\n\t}\n\tlong long int amin = 1;\n\tlong long int amax = 1e9;\n\twhile (amin + 1 != amax) {\n\t\tlong long int amid((amin + amax) / 2);\n\t\tif (check(times,amid, K)) {\n\t\t\tamax = amid;\n\t\t}\n\t\telse {\n\t\t\tamin = amid;\n\t\t}\n\t}\n\tif (amax > 1e8) {\n\t\tcout << -1 << endl;\n\t}\n\telse {\n\t\tcheck(times, amax, K);\n\t\tcout << amax << endl;\n\t\tif (amax <= 100) {\n\t\t\tfor (int i = 0; i < ans.size(); ++i) {\n\t\t\t\tcout << ans[i];\n\t\t\t\tif (i != ans.size() - 1)cout << \" \";\n\t\t\t\telse cout << endl;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstruct edge{\n\tint t;\n\tint c;\n\tedge(){}\n\tedge(int tt,int cc){\n\t\tt=tt;\n\t\tc=cc;\n\t}\n};\n\nint n,m,tgt;\nvector<edge> G[151];\nint dp[151][151];\nint prev[151][151];\nint cyc_max[151][151];\nint to_max[151][151];\nint from_max[151][151];\nint ft_max[301][301];\n\nbool C(int v){\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<=min(n*2,v);j++){\n\t\t\tll all=ft_max[i][j];\n\t\t\tif(all>=(ll)tgt)return true;\n\t\t\tll rest=v-j;\n\t\t\tfor(int l=1;l<=n;l++){\n\t\t\t\tll va=(ll)rest/l;\n\t\t\t\tif(all+va*cyc_max[i][l]>=(ll)tgt)return true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nvoid get_route(int size){\n\tmemset(dp,-1,sizeof(dp));\n\tmemset(dp[0],0,sizeof(dp[0]));\n\tfor(int i=0;i<size;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(dp[i][j]>=0){\n\t\t\t\tfor(int l=0;l<G[j].size();l++){\n\t\t\t\t\tedge e=G[j][l];\n\t\t\t\t\tif(dp[i+1][e.t]<dp[i][j]+e.c){\n\t\t\t\t\t\tdp[i+1][e.t]=dp[i][j]+e.c;\n\t\t\t\t\t\tprev[i+1][e.t]=j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint maxi=tgt;\n\tfor(int i=0;i<n;i++){\n\t\tmaxi=max(maxi,dp[size][i]);\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tif(dp[size][i]>=maxi){\n\t\t\tint now=i;\n\t\t\tvector<int> ans;\n\t\t\tfor(int j=0;j<size;j++){\n\t\t\t\tans.push_back(now);\n\t\t\t\tnow=prev[size-j][now];\n\t\t\t}\n\t\t\tans.push_back(now);\n\t\t\treverse(ans.begin(),ans.end());\n\t\t\tfor(int j=0;j<=size;j++){\n\t\t\t\tprintf(\"%d%c\",ans[j],j==size?'\\n':' ');\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nint main(void){\n\tscanf(\"%d%d%d\",&n,&m,&tgt);\n\tfor(int i=0;i<m;i++){\n\t\tint f,t,c;\n\t\tscanf(\"%d%d%d\",&f,&t,&c);\n\t\tG[f].push_back(edge(t,c));\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tdp[0][i]=0;\n\t\tfor(int j=0;j<n;j++){\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\tif(dp[j][k]>=0){\n\t\t\t\t\tfor(int l=0;l<G[k].size();l++){\n\t\t\t\t\t\tedge e=G[k][l];\n\t\t\t\t\t\tdp[j+1][e.t]=max(dp[j+1][e.t],dp[j][k]+e.c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcyc_max[i][j+1]=dp[j+1][i];\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\tfrom_max[i][j+1]=max(from_max[i][j+1],dp[j+1][k]);\n\t\t\t\tto_max[k][j+1]=max(to_max[k][j+1],dp[j+1][k]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tfor(int k=0;k<=n;k++){\n\t\t\t\tft_max[i][j+k]=max(ft_max[i][j+k],from_max[i][j]+to_max[i][k]);\n\t\t\t}\n\t\t}\n\t}\n\tint l=-1,r=10000007;\n\twhile(l+1<r){\n\t\tint mid=(l+r)/2;\n\t\tif(C(mid))r=mid;\n\t\telse l=mid;\n\t}\n\tif(r==10000007){\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tprintf(\"%d\\n\",r);\n\tif(r<=100){\n\t\tget_route(r);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\nint V,E,K;\nconst int INF = (1<<30);\nmat G;\n\nmat g[30];\nmat u[30];\n\nint add(int a,int b){\n  if(a==-INF||b==-INF)return -INF;\n  return min(a+b,K);\n}\n\npair<mat,mat> merge(mat A,mat B, bool flag=false){\n  mat X( V, vec(V, -INF) );\n  mat Y( V, vec(V, -INF) );\n  \n  for(int from=0;from<V;from++){\n    for(int to=0;to<V;to++){\n      for(int ex=0;ex<V;ex++){\n        int cost=add(A[from][ex],B[ex][to]);\n        if(X[from][to]<cost){\n          X[from][to]=cost;\n          Y[from][to]=ex;\n        }\n      }\n    }\n  }\n  return make_pair(X,Y);\n}\n\n\nint calc(int m,int &si,int &ti){\n  mat t;\n  for(int i=0;i<30;i++){\n    if(m>>i&1){\n      if(t.empty()){\n        t=g[i];\n      }else{\n        t=merge(t,g[i]).first;\n      }\n    }\n  }\n  \n  int res=-INF;\n  for(int i=0;i<V;i++){\n    for(int j=0;j<V;j++){\n      if(res<t[i][j]){\n        si=i;\n        ti=j;\n        res=t[i][j];\n      }\n    }\n  }\n  return res;\n}\n\nvoid Dfs(vec& s,int from,int to,int len){\n  if(len==0)return;\n  \n  for(int i=0;i<30;i++){\n    if(~len>>i&1)continue;\n    int ex=u[i][from][to];\n\n    if(i==0){\n      if(len>=2)s.push_back(ex);\n      Dfs(s,ex,to,len-1);\n    }else{\n      int sub=(1<<i)/2;\n      Dfs(s,from,ex,sub);\n      s.push_back(ex);\n      Dfs(s,ex,to,len-sub);\n    }\n    break;\n  }\n}\n\nint main(){\n  cin>>V>>E>>K;\n  G=mat( V, vec(V, -INF) );\n  \n  g[0]=u[0]=G;\n  for(int i=0;i<V;i++)g[0][i][i]=0;\n  \n  for(int i=0;i<E;i++){\n    int a,b,c;\n    cin>>a>>b>>c;\n    G[a][b]=max(G[a][b],c);\n    \n    g[0][a][b]=max(g[0][a][b],c);\n    u[0][a][b]=b;\n  }\n\n  \n  for(int i=1;i<30;i++){\n    pair<mat,mat> temp=merge(g[i-1],g[i-1]);\n    g[i]=temp.first;\n    u[i]=temp.second;\n  }\n\n\n  int si,ti;\n  int left=1,right=K+1,mid;\n\n  while( left < right ){\n    mid=(left+right)/2;\n    if( calc(mid,si,ti) >= K ){\n      right=mid;\n    }else{\n      left=mid+1;\n    }\n  }\n\n  for(int i=0;i<V;i++)g[0][i][i]=-INF;\n  for(int i=1;i<30;i++){\n    pair<mat,mat> temp=merge(g[i-1],g[i-1]);\n    g[i]=temp.first;\n    u[i]=temp.second;\n  }\n  \n  if(left==K+1){\n    cout<<-1<<endl;\n  }else{\n    cout<<left<<endl;\n    if(left<=100){\n      vec tab;\n      tab.push_back(si);\n      Dfs(tab,si,ti,left);\n      tab.push_back(ti);\n      //      cout<<tab.size()<<endl;\n      for(int i=0;i<(int)tab.size();i++){\n        if(i>0 && G[ tab[i-1]][ tab[i] ] == -INF ){\n          assert(0);\n        }\n        if(i)cout<<' ';\n        cout<<tab[i];\n      }\n      cout<<endl;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> mat;\nmat op(mat a,mat b){\n\tint N=a.size();\n\tmat c=a;\n\trep(i,N) rep(j,N) rep(k,N) if(a[i][j]>=0&&b[j][k]>=0) chmax(c[i][k],a[i][j]+b[j][k]);\n\treturn c;\n}\nint getmx(mat a){\n\tint N=a.size();\n\tint mx=-1;\n\trep(i,N) rep(j,N) chmax(mx,a[i][j]);\n\treturn mx;\n}\nint main(){\n\tint N,M,K;\n\tint dp[151][150]={};\n\tint from[151][150]={};\n\tcin>>N>>M>>K;\n\tmat m(N,vi(N,0));\n\trep(i,N) rep(j,N) m[i][j]=-1;\n\trep(i,M){\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;\n\t\tchmax(m[a][b],c);\n\t}\n\trep1(i,150) rep(j,N) dp[i][j]=-1;\n\trep(i,150){\n\t\trep(v,N) rep(u,N){\n\t\t\tif(m[v][u]<0||dp[i][v]<0) continue;\n\t\t\tif(dp[i+1][u]<dp[i][v]+m[v][u]){\n\t\t\t\tdp[i+1][u]=dp[i][v]+m[v][u];\n\t\t\t\tfrom[i+1][u]=v;\n\t\t\t}\n\t\t}\n\t\tint mx=-1;\n\t\trep(v,N) chmax(mx,dp[i+1][v]);\n\t\tif(mx>=K){\n\t\t\tif(i>100){\n\t\t\t\tcout<<i<<endl;\n\t\t\t\treturn 0;\n\t\t\t}else{\n\t\t\t\tint x=-1;\n\t\t\t\trep(v,N) if(mx==dp[i+1][v]) x=v;\n\t\t\t\tvector<int> ans;\n\t\t\t\tans.pb(x);\n\t\t\t\tfor(int j=i+1;j>0;j--) ans.pb(from[j][x]),x=from[j][x];\n\t\t\t\treverse(all(ans));\n\t\t\t\tcout<<i+1<<endl;\n\t\t\t\trep(i,ans.size()) cout<<ans[i]<<(i+1==ans.size()?\"\\n\":\" \");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tif(i==149&&mx==-1){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tmat ms[20];\n\tms[0]=m;\n\trep(i,19) ms[i+1]=op(ms[i],ms[i]);\n\tmat x(N,vi(N,-1));\n\trep(i,N) x[i][i]=0;\n\tint ans=0;\n\tfor(int i=19;i>=0;i--){\n\t\tmat nx=op(x,ms[i]);\n\t\tif(getmx(nx)<K){\n\t\t\tx=nx;\n\t\t\tans+=(1<<i);\n\t\t}\n\t}\n\tcout<<ans+1<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nint n, m, k;\ntypedef vector<vi> M;\nM operator*(const M &a, const M &b){\n\tM c(a.size(), vi(a.size()));\n\trep(i, n) rep(j, n) c[i][j] = max(a[i][j], b[i][j]);\n\trep(l, n) rep(i, n) rep(j, n) if(a[i][l] >= 0 && b[l][j] >= 0){\n\t\tc[i][j] = max(c[i][j], a[i][l] + b[l][j]);\n\t\tif(c[i][j] >= k) c[i][j] = k;\n\t}\n\treturn c;\n}\nint dp[128][150], prev[128][150];\nvoid solve(const M &e, int it){\n\tmemset(dp, -1, sizeof(dp));\n\trep(i, n) dp[0][i] = 0;\n\tint ai, al, mx = 0;\n\t\n\trep(i, it) rep(j, n) if(dp[i][j] >= 0){\n\t\trep(l, n) if(e[j][l] >= 0 && dp[i + 1][l] < dp[i][j] + e[j][l]){\n\t\t\tdp[i + 1][l] = dp[i][j] + e[j][l];\n\t\t\tprev[i + 1][l] = j;\n\t\t\tif(dp[i + 1][l] >= k && dp[i + 1][l] > mx){\n\t\t\t\tai = i + 1; al = l; mx = dp[i + 1][l];\n\t\t\t}\n\t\t}\n\t}\n\tEND:\n\tvi ans;\n\tfor(; ai >= 0; ai--){\n\t\tans.pb(al);\n\t\tif(ai > 0) al = prev[ai][al];\n\t}\n\treverse(all(ans));\n\trep(i, ans.size()) cout << ans[i] << (i == ans.size() - 1 ? \"\\n\" : \" \");\n}\nint main(){\n\tcin >> n >> m >> k;\n\tM e(n, vi(n, -1)), p(n, vi(n, -1));\n\tM pw[20];\n\t\n\trep(i, m){\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\te[a][b] = max(e[a][b], c);\n\t}\n\t\n\trep(i, n) p[i][i] = 0;\n\tpw[0] = e;\n\trep(i, 19) pw[i + 1] = pw[i] * pw[i];\n\t\n\tint ans = 0;\n\tbool can = 0;\n\tfor(int i = 19; i >= 0; i--){\n\t\tM pp = p * pw[i];\n\t\t\n\t\tbool ok = 0;\n\t\trep(j, n) rep(l, n) if(pp[j][l] >= k) ok = can = 1;\n\t\tif(!ok) p = pp, ans += 1 << i;\n\t}\n\tif(!can){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tans++;\n\tcout << ans << endl;\n\tif(ans <= 100) solve(e, ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <queue>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#include <cstdio>\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\n#include <set>\nusing namespace std;\n\nint g[150][150];\npair<int, vector<int> > loop[150][160];\npair<int, vector<int> > p1[150][160];\npair<int, vector<int> > p2[150][160];\npair<int, vector<int> > tmp[160][150];\n\nint main(){\n  const int v = max(getInt(), 150);\n  const int e = getInt();\n  const int kk = getInt();\n\n  REP(i,v) REP(j,v) g[i][j] = -1;\n\n  REP(i,e){\n    const int v1 = getInt();\n    const int v2 = getInt();\n    const int c  = getInt();\n    g[v1][v2] = max(g[v1][v2], c);\n  }\n\n  REP(s,v){\n    REP(i,v + 10) REP(j,v) tmp[i][j] = make_pair(-1, vector<int>());\n\n    tmp[0][s] = make_pair(0, vector<int>());\n\n    REP(c, v + 5){\n      loop[s][c] = tmp[c][s];\n      p1[s][c] = tmp[c][0]; REP(i,v) p1[s][c] = max(p1[s][c], tmp[c][i]);\n\n      REP(i,v) if(tmp[c][i].first != -1){\n        vector<int> vv = tmp[c][i].second;\n        vv.push_back(0);\n        REP(j,v) if(g[i][j] != -1){\n          const int pp = tmp[c][i].first + g[i][j];\n          vv[c] = j;\n          tmp[c + 1][j] = max(tmp[c + 1][j], make_pair(pp, vv));\n        }\n      }\n    }\n  }\n\n  REP(i,v) REP(j,i) swap(g[i][j], g[j][i]);\n\n  REP(s,v){\n    REP(i,v + 10) REP(j,v) tmp[i][j] = make_pair(-1, vector<int>());\n\n    tmp[0][s] = make_pair(0, vector<int>());\n\n    REP(c, v + 5){\n      // loop[s][c] = tmp[c][s];\n      p2[s][c] = tmp[c][0]; REP(i,v) p2[s][c] = max(p2[s][c], tmp[c][i]);\n\n      REP(i,v) if(tmp[c][i].first != -1){\n        vector<int> vv = tmp[c][i].second;\n        vv.push_back(0);\n        REP(j,v) if(g[i][j] != -1){\n          const int pp = tmp[c][i].first + g[i][j];\n          vv[c] = j;\n          tmp[c + 1][j] = max(tmp[c + 1][j], make_pair(pp, vv));\n        }\n      }\n    }\n  }\n\n  REP(i,v) REP(j,i) swap(g[i][j], g[j][i]);\n\n  const int inf = 10000000;\n  pair<int, pair<int, pair<int, pair<int, pair<int, int> > > > > ans;\n  ans.first = inf;\n\n  REP(s,v){\n    REP(i,v + 2) REP(j,v + 2) REP(k, v + 2){\n      if(p1[s][i].first != -1 &&\n         p2[s][j].first != -1 &&\n         loop[s][k].first != -1){\n        const int pt = p1[s][i].first +\n          p2[s][j].first;\n\n        if(pt >= kk){\n          ans = min(ans, make_pair(i + j + k, make_pair(s, make_pair(i, make_pair(j, make_pair(k, 0))))));\n        }else{\n          if(loop[s][k].first > 0){\n            const int diff = kk - pt;\n            const int cnt = (diff + loop[s][k].first - 1) / loop[s][k].first;\n            ans = min(ans, make_pair(i + j + k * cnt, make_pair(s, make_pair(i, make_pair(j, make_pair(k, cnt))))));\n          }\n        }\n      }\n    }\n  }\n\n  if(ans.first == inf){\n    printf(\"-1\\n\");\n    puts(\"\");\n  }else{\n    printf(\"%d\\n\", ans.first);\n\n    if(ans.first <= 100){\n      const int s = ans.second.first;\n      const int i = ans.second.second.first;\n      const int j = ans.second.second.second.first;\n      const int k = ans.second.second.second.second.first;\n      const int c = ans.second.second.second.second.second;\n\n      vector<int> v;\n\n      {\n        REP(ii, j) v.push_back(p2[s][j].second[j - ii - 1]);\n      }\n      v.push_back(s);\n\n      REP(cc,c){\n        REP(ii, k) v.push_back(loop[s][k].second[ii]);\n      }\n\n      {\n        REP(ii, i) v.push_back(p1[s][i].second[ii]);\n      }\n\n      REP(i,v.size()) printf(\"%d%c\", v[i], i == (int)v.size() - 1 ? '\\n' : ' ');\n      /*\n      int a = 0;\n      REP(i, v.size() - 1)\n        a += g[v[i]][v[i + 1]];\n      printf(\"a: %d\\n\", a);\n      */\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int64 LINF = 1LL << 60;\nconst int INF = 1 << 30;\n\nint V, E, K;\nint64 g[31][150][150];\n\nint main() {\n  fill_n(**g, 31 * 150 * 150, -LINF);\n\n  cin >> V >> E >> K;\n  for(int i = 0; i < E; i++) {\n    g[0][i][i] = 0;\n  }\n  for(int i = 0; i < E; i++) {\n    int a, b;\n    int64 c;\n    cin >> a >> b >> c;\n    g[0][a][b] = max(g[0][a][b], c);\n  }\n\n  for(int i = 0; i < 30; i++) {\n    for(int j = 0; j < V; j++) {\n      for(int k = 0; k < V; k++) {\n        for(int l = 0; l < V; l++) {\n          g[i + 1][k][l] = max(g[i + 1][k][l], g[i][k][j] + g[i][j][l]);\n        }\n      }\n    }\n  }\n\n\n  auto check = [&](int bit) {\n    vector< int64 > dp(V);\n    for(int k = 30; k >= 0; k--) {\n      if((bit >> k) & 1) {\n        vector< int64 > dp2(V);\n        for(int i = 0; i < V; i++) {\n          for(int j = 0; j < V; j++) {\n            dp2[j] = max(dp2[j], dp[i] + g[k][i][j]);\n          }\n        }\n        dp.swap(dp2);\n      }\n    }\n    return *max_element(begin(dp), end(dp)) >= K;\n  };\n\n  int ok = INF, ng = 0;\n  while(ok - ng > 1) {\n    int mid = (ok + ng) / 2;\n    if(check(mid)) ok = mid;\n    else ng = mid;\n  }\n\n  if(ok == INF) {\n    cout << -1 << endl;\n  } else {\n    cout << ok << endl;\n\n    if(ok <= 100) {\n      int64 dp[101][150] = {{}}, pv[101][150];\n      for(int i = 0; i < ok; i++) {\n        for(int j = 0; j < V; j++) {\n          for(int k = 0; k < V; k++) {\n            if(dp[i][j] + g[0][j][k] > dp[i + 1][k]) {\n              dp[i + 1][k] = dp[i][j] + g[0][j][k];\n              pv[i + 1][k] = j;\n            }\n          }\n        }\n      }\n      int high = -1;\n      for(int i = 0; i < V; i++) {\n        if(dp[ok][i] >= K) high = i;\n      }\n      vector< int > route;\n      for(int i = ok; i >= 0; i--) {\n        route.push_back(high);\n        high = pv[i][high];\n      }\n      reverse(begin(route), end(route));\n      for(int i = 0; i < route.size(); i++) {\n        if(i) cout << \" \";\n        cout << route[i];\n      }\n      cout << endl;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// template {{{\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define loop(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rep(i, n) loop(i, 0, n)\n#define rloop(i, a, b) for (int i = (int)(b) - 1; i >= (int)(a); i--)\n#define rrep(i, n) rloop(i, 0, n)\n#define eb emplace_back\n#define ef emplace_front\n#define pb pop_back\n#define pf pop_front\n#define all(c) std::begin(c), std::end(c)\n#define mp std::make_pair\n#define mt std::make_tuple\n#define fi first\n#define se second\n#define popcnt __builtin_popcountll\n\nusing uint = unsigned;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n\ntemplate<typename T>\nusing max_pq = priority_queue<T, vector<T>, less<T>>;\n\ntemplate<typename T>\nusing min_pq = priority_queue<T, vector<T>, greater<T>>;\n\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9 + 10;\nconst ll LLINF = 1e18 + 10;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\nconst int dx8[] = {-1, -1, 0, 1, 1, 1, 0, -1};\nconst int dy8[] = {0, -1, -1, -1, 0, 1, 1, 1};\n\ntemplate<typename T>\ninline T sq(T x){ return x * x; }\n\ntemplate<typename T, typename U>\ninline bool chmax(T &x, U y){ if (x >= y) return false; x = y; return true; }\n\ntemplate<typename T, typename U>\ninline bool chmin(T &x, U y){ if (x <= y) return false; x = y; return true; }\n\ntemplate<typename T>\ninline void sort(T &c){ std::sort(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void reverse(T &c){ std::reverse(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void unique(T &c){ std::sort(std::begin(c), std::end(c)); c.erase(std::unique(all(c)), std::end(c)); }\n\n// }}}\n\nint n, m, k;\nint g[150][150];\n\npair<int, vector<int>> calc(int x, bool build = false)\n{\n\tvector<vector<int>> dp(x + 1, vector<int>(n, 0));\n\tvector<vector<int>> pr(x + 1, vector<int>(n, -1));\n\trep(i, x) rep(j, n) rep(k, n){\n\t\tif (chmax(dp[i + 1][k], dp[i][j] + g[j][k])){\n\t\t\tpr[i + 1][k] = j;\n\t\t}\n\t}\n\n\tpair<int, vector<int>> res;\n\tint p = 0;\n\trep(i, n){\n\t\tif (chmax(res.fi, dp[x][i])){\n\t\t\tp = i;\n\t\t}\n\t}\n\tif (build){\n\t\trrep(i, x){\n\t\t\tres.se.eb(p);\n\t\t\tp = pr[i + 1][p];\n\t\t}\n\t\tres.se.eb(p);\n\t\treverse(res.se);\n\t}\n\n\treturn res;\n}\n\nvector<vector<int>> add(const vector<vector<int>> &a, const vector<vector<int>> &b)\n{\n\tvector<vector<int>> res(n, vector<int>(n, -INF));\n\trep(k, n) rep(i, n) rep(j, n){\n\t\tchmax(res[i][j], a[i][k] + b[k][j]);\n\t}\n\treturn res;\n}\n\nint calc2(int x)\n{\n\tvector<vector<int>> a(n, vector<int>(n));\n\trep(i, n) rep(j, n) a[i][j] = i == j ? 0 : -INF;\n\tauto b = a;\n\trep(i, n) rep(j, n) b[i][j] = g[i][j];\n\twhile (x){\n\t\tif (x & 1) a = add(a, b);\n\t\tb = add(b, b);\n\t\tx >>= 1;\n\t}\n\n\tint res = 0;\n\trep(i, n) rep(j, n) chmax(res, a[i][j]);\n\treturn res;\n}\n\nbool cond(int x)\n{\n\tif (x <= 100) return calc(x).fi >= k;\n\treturn calc2(x) >= k;\n}\n\nint main()\n{\n\tcin >> n >> m >> k;\n\trep(i, n) rep(j, n) g[i][j] = -INF;\n\trep(i, m){\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\tchmax(g[a][b], c);\n\t}\n\n\tint lb = 0, ub = 100010;\n\twhile (ub - lb > 1){\n\t\tint md = (lb + ub) / 2;\n\t\t(cond(md) ? ub : lb) = md;\n\t}\n\t\n\tint res = ub;\n\n\tif (res > 100000){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\t\n\tcout << res << endl;\n\t\n\tif (res <= 100){\n\t\tauto v = calc(res, true).se;\n\t\trep(i, res){\n\t\t\tcout << v[i] << \"\\n \"[i < res - 1];\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n\nusing vint = vector<int>;\n\nconst int inf = 1LL<<55;\n\nint V, E, K;\nvector<vint> A;\n\nvector<vint> calc(int m) {\n  //cout<<m<<endl;\n  vector<vint> B = A;\n  vector<vint> res(V, vint(V, -inf));\n  for(int i = 0; i < V; ++i) res[i][i] = 0;\n  while(m > 0) {\n    if(m&1) {\n      vector<vint> tmp(V, vint(V, -inf));\n      for(int i = 0; i < V; ++i) tmp[i][i] = 0;      \n      for(int k = 0; k < V; ++k) {\t\n\tfor(int i = 0; i < V; ++i) {\n\t  for(int j = 0; j < V; ++j) {\n\t    tmp[i][j] = max(tmp[i][j], res[i][k]+B[k][j]);\n\t  }\n\t}\n      }\n      res = tmp;\n    }\n    vector<vint> tmp(V, vint(V, -inf));\n    for(int i = 0; i < V; ++i) tmp[i][i] = 0;\n    for(int k = 0; k < V; ++k) {\n      for(int i = 0; i < V; ++i) {\n\tfor(int j = 0; j < V; ++j) {\n\t  tmp[i][j] = max(tmp[i][j], B[i][k]+B[k][j]);\n\t}\n      }\n    }\n    B = tmp;    \n    m >>= 1;\n  }\n  /*\n  for(int i = 0; i < V; ++i) {\n    for(int j = 0; j < V; ++j) cout << res[i][j] << \" \\n\"[j==V-1];\n  }\n  /*/\n  return res;\n}\n\n\nint check(int m) {\n  vector<vint> B = calc(m);\n  int res = 0;\n  for(int i = 0; i < V; ++i) {\n    for(int j = 0; j < V; ++j) {\n      res = max(res, B[i][j]);\n    }\n  }\n  return res;\n}\n\nsigned main() {\n  cin >> V >> E >> K;\n  A.resize(V, vint(V, -inf));\n  for(int i = 0; i < V; ++i) A[i][i] = 0;\n  for(int i = 0; i < E; ++i) {\n    int u, v, c;\n    cin >> u >> v >> c;\n    A[u][v] = max(A[u][v], c);\n  }\n  /*\n  for(int i = 0; i < V; ++i) {\n    for(int j = 0; j < V; ++j) cout << A[i][j] << \" \\n\"[j==V-1];\n  } \n  /*/ \n  int lb = -1, ub = 1111111;\n  while(lb+1 < ub) {\n    int mb = (lb+ub)/2;\n    if(check(mb) >= K) ub = mb;\n    else lb = mb;\n  }\n  if(ub == 1111111) {\n    cout << -1 << endl;\n    return 0;\n  }\n  cout << ub << endl;  \n  int ans = check(ub);\n  //cout << ans << endl;\n  //cout<<check(34)<<endl;\n  if(ub <= 100) {\n    vector<vint> rev(ub+1, vint(V, -1));\n    vector<vint> B(V, vint(V, -inf));\n    for(int i = 0; i < V; ++i) B[i][i] = 0;\n    for(int l = 0; l < ub; ++l) {\n      vector<vint> tmp(V, vint(V, -inf));\n      for(int i = 0; i < V; ++i) tmp[i][i] = 0;\n      for(int k = 0; k < V; ++k) {      \n\tfor(int i = 0; i < V; ++i) {\n\t  for(int j = 0; j < V; ++j) {\n\t    if(tmp[i][j] < B[i][k]+A[k][j]) {\n\t      tmp[i][j] = B[i][k]+A[k][j];\n\t      rev[l+1][j] = k;\n\t    }\n\t  }\n\t}\n      }\n      B = tmp;\n    }\n    int idx = -1;\n    for(int i = 0; i < V && idx == -1; ++i) {\n      for(int j = 0; j < V && idx == -1; ++j) {\n\tif(ans == B[i][j]) idx = j;\n      }\n    }\n    vint vec;\n    for(int l = ub; l > 0; --l) {\n      vec.push_back(idx);\n      idx = rev[l][idx];\n    }\n    reverse(vec.begin(), vec.end());\n    for(int i = 0; i < (int)vec.size(); ++i) cout << vec[i] << \" \\n\"[i==(int)vec.size()-1];\n  }\n\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int logMaxStep = 30;\n\ntypedef long long ll;\ntypedef vector< vector<ll> > Graph;\n\nint GetLogStep(int S) {\n\tint res;\n\tfor (res = 0; (1 << res) <= S; ++res);\n\treturn res;\n}\nGraph nextG(const Graph& g1, const Graph& g2) {\n\tint N = g1.size();\n\tGraph res(N, vector<ll>(N, 0));\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tfor (int k = 0; k < N; ++k) {\n\t\t\t\tif (g1[i][k] > 0 && g2[k][j] > 0) {\n\t\t\t\t\tres[i][j] = max(res[i][j], g1[i][k]+g2[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nvector<int> nextDP(vector<ll>& dp, Graph& g) {\n\tint N = g.size();\n\tvector<int> prevV(N, -1);\n\tvector<ll> ndp(N, -1);\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tif (dp[i] >= 0 && g[i][j] > 0) {\n\t\t\t\tif (dp[i]+g[i][j] > ndp[j]) {\n\t\t\t\t\tndp[j] = dp[i]+g[i][j];\n\t\t\t\t\tprevV[j] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tdp[i] = ndp[i];\n\t}\n\treturn prevV;\n}\nll GetMaxScore(vector<Graph>& powG, int S) {\n\tint N = powG[0].size();\n\tint logS = GetLogStep(S);\n\tvector<ll> dp(N, 0);\n\tfor (int i = 0; i < logS; ++i) {\n\t\tGraph& g = powG[i];\n\t\tif ( (1 << i) & S ) {\n\t\t\tnextDP(dp, g);\n\t\t}\n\t}\n\tll res = -1;\n\tfor (int i = 0; i < dp.size(); ++i) {\n\t\tres = max(res, dp[i]);\n\t}\n\treturn res;\n}\nint check1000Step(Graph& G, int K) {\n\tint N = G.size();\n\tvector<ll> dp(N, 0);\n\tvector< vector<int> > prevV;\n\tll lastAns = -1;\n\tfor (int t = 0; t < 1000; ++t) {\n\t\tprevV.push_back( nextDP(dp, G) );\n\t\tint aid = 0;\n\t\tfor (int i = 0; i < dp.size(); ++i) {\n\t\t\tif (dp[i] > dp[aid]) aid = i;\n\t\t}\n\t\tif (dp[aid] >= K) {\n\t\t\tcout << t+1 << endl;\n\t\t\tif (t+1 <= 100) {\n\t\t\t\tvector<int> vl;\n\t\t\t\tint v = aid; vl.push_back(v);\n\t\t\t\tfor (int i = t; i >= 0; --i) {\n\t\t\t\t\tv = prevV[i][v];\n\t\t\t\t\tvl.push_back(v);\n\t\t\t\t}\n\t\t\t\treverse(vl.begin(), vl.end());\n\t\t\t\tfor (int i = 0; i < vl.size(); ++i) {\n\t\t\t\t\tif (i) cout << \" \";\n\t\t\t\t\tcout << vl[i];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t\treturn -2;\n\t\t}\n\t\tlastAns = dp[aid];\n\t}\n\treturn lastAns;\n}\nint main() {\n\tint N, E, K; cin >> N >> E >> K;\n\tGraph G(N, vector<ll>(N, 0));\n\tfor (int i = 0; i < E; ++i) {\n\t\tint a, b; ll c; cin >> a >> b >> c;\n\t\tG[a][b] = max(G[a][b], c);\n\t}\n\tint result = check1000Step(G, K);\n\tif (result > 0) {\n\t\tvector<Graph> powG(logMaxStep+1); powG[0] = G;\n\t\tfor (int i = 0; i < logMaxStep; ++i) {\n\t\t\tpowG[i+1] = nextG(powG[i], powG[i]);\n\t\t}\n\n\t\tfor (int i = N; i <= N+100; ++i) {\n\t\t\tif (GetMaxScore(powG, i+1) >= result) {\n\t\t\t\tassert(GetMaxScore(powG, i+1) > GetMaxScore(powG, i));\n\t\t\t}\n\t\t}\n\t\tint l = 0, r = K+1;\n\t\tfor (int t = 0; t < logMaxStep; ++t) {\n\t\t\tint m = (l + r) / 2;\n\t\t\tif ( GetMaxScore(powG, m) >= K ) {\n\t\t\t\tr = m;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tl = m;\n\t\t\t}\n\t\t}\n\t\tassert(r - l <= 1);\n\t\tassert(r <= K);\n\t\tcout << r << endl;\n\t}\n\telse if (result == -1) {\n\t\tcout << -1 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n\nconst int logMaxStep = 30;\n\ntypedef long long ll;\ntypedef vector< vector<ll> > Graph;\n\nint GetLogStep(int S) {\n\tint res;\n\tfor (res = 0; (1 << res) <= S; ++res);\n\treturn res;\n}\nGraph nextG(const Graph& g1, const Graph& g2) {\n\tint N = g1.size();\n\tGraph res(N, vector<ll>(N, 0));\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tfor (int k = 0; k < N; ++k) {\n\t\t\t\tif (g1[i][k] > 0 && g2[k][j] > 0) {\n\t\t\t\t\tres[i][j] = max(res[i][j], g1[i][k]+g2[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nvector<int> nextDP(vector<ll>& dp, Graph& g) {\n\tint N = g.size();\n\tvector<int> prevV(N, -1);\n\tvector<ll> ndp(N, -1);\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tif (dp[i] >= 0 && g[i][j] > 0) {\n\t\t\t\tif (dp[i]+g[i][j] > ndp[j]) {\n\t\t\t\t\tndp[j] = dp[i]+g[i][j];\n\t\t\t\t\tprevV[j] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tdp[i] = ndp[i];\n\t}\n\treturn prevV;\n}\nll GetMaxScore(vector<Graph>& powG, int S) {\n\tint N = powG[0].size();\n\tint logS = GetLogStep(S);\n\tvector<ll> dp(N, 0);\n\tfor (int i = 0; i < logS; ++i) {\n\t\tGraph& g = powG[i];\n\t\tif ( (1 << i) & S ) {\n\t\t\tnextDP(dp, g);\n\t\t}\n\t}\n\tll res = -1;\n\tfor (int i = 0; i < dp.size(); ++i) {\n\t\tres = max(res, dp[i]);\n\t}\n\treturn res;\n}\nbool check200Step(Graph& G, int K) {\n\tint N = G.size();\n\tvector<ll> dp(N, 0);\n\tvector< vector<int> > prevV;\n\tfor (int t = 0; t < 200; ++t) {\n\t\tprevV.push_back( nextDP(dp, G) );\n\t\tint aid = 0;\n\t\tfor (int i = 0; i < dp.size(); ++i) {\n\t\t\tif (dp[i] > dp[aid]) aid = i;\n\t\t}\n\t\tif (dp[aid] >= K) {\n\t\t\tcout << t+1 << endl;\n\t\t\tif (t+1 <= 100) {\n\t\t\t\tvector<int> vl;\n\t\t\t\tint v = aid; vl.push_back(v);\n\t\t\t\tfor (int i = t; i >= 0; --i) {\n\t\t\t\t\tv = prevV[i][v];\n\t\t\t\t\tvl.push_back(v);\n\t\t\t\t}\n\t\t\t\treverse(vl.begin(), vl.end());\n\t\t\t\tfor (int i = 0; i < vl.size(); ++i) {\n\t\t\t\t\tif (i) cout << \" \";\n\t\t\t\t\tcout << vl[i];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nsigned main() {\n\tint N, E, K; cin >> N >> E >> K;\n\tGraph G(N, vector<ll>(N, 0));\n\tfor (int i = 0; i < E; ++i) {\n\t\tint a, b; ll c; cin >> a >> b >> c;\n\t\tG[a][b] = max(G[a][b], c);\n\t}\n\tif ( !check200Step(G, K) ) {\n\t\tvector<Graph> powG(logMaxStep+1); powG[0] = G;\n\t\tfor (int i = 0; i < logMaxStep; ++i) {\n\t\t\tpowG[i+1] = nextG(powG[i], powG[i]);\n\t\t}\n\n\t\tint l = 0, r = K+1;\n\t\tfor (int t = 0; t < logMaxStep; ++t) {\n\t\t\tint m = (l + r) / 2;\n\t\t\tif ( GetMaxScore(powG, m) >= K ) {\n\t\t\t\tr = m;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tl = m;\n\t\t\t}\n\t\t}\n\t\tif (r > K) {\n\t\t\tcout << -1 << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << r << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<int(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nconstexpr int64_t INF = INT64_C(1000000000000000000);\n\nusing Array = vector<int64_t>;\nusing Matrix = vector<Array>;\n\nMatrix mul(const Matrix& lhs, const Matrix& rhs) {\n  int r = lhs.size();\n  Matrix res(r, Array(r, -INF));\n  REP(i,r) REP(k,r) REP(j,r) {\n    res[i][j] = max(res[i][j], lhs[i][k] + rhs[k][j]);\n  }\n  return res;\n}\n\nMatrix pow(const Matrix& mat, int64_t index) {\n  if (index == 1) return mat;\n  if ((index % 2) == 1) {\n    return mul(mat, pow(mat, index-1));\n  }\n  return pow(mul(mat, mat), index/2);\n}\n\nint main() {\n  int64_t v,e,k;\n  cin>>v>>e>>k;\n  Matrix mat(v, Array(v, -INF));\n  REP(i,e) {\n    int64_t s,t,c;\n    cin>>s>>t>>c;\n    mat[s][t] = max(mat[s][t], c);\n  }\n  vector<Matrix> vmat;\n  Matrix m(v, Array(v, -INF));\n  REP(i,v) m[i][i] = 0;\n  vmat.push_back(m);\n  REP(i,max(INT64_C(100),v)) {\n    m = mul(mat, m);\n    vmat.push_back(m);\n  }\n  int64_t mx = -INF;\n  int64_t hi = INF;\n  FOR(idx,1,v+1)REP(i,v)REP(j,v) {\n    if (vmat[idx][i][j] >= k) {\n      if (idx < hi) {\n        hi = idx;\n      }\n    }\n    mx = max(mx, vmat[idx][i][j]);\n  }\n  int64_t mx2 = -INF;\n  FOR(i,2,v+1)REP(j,v) mx2 = max(mx2, vmat[i][j][j]);\n  if (mx2 > 0 && mx < k && k > v) {\n    hi = k;\n    int64_t lo = v;\n    while (hi - lo > 1) {\n      int64_t mid = (hi + lo) / 2;\n      auto pmat = pow(mat, mid);\n      int64_t mx = -INF;\n      REP(i,v)REP(j,v) mx = max(mx, pmat[i][j]);\n      if (mx < 0) {\n        hi = mid;\n      } else if (mx >= k) {\n        hi = mid;\n      } else {\n        lo = mid;\n      }\n    }\n  }\n  if (hi == INF) {\n    cout << -1 << endl;\n    return 0;\n  }\n  auto pmat = pow(mat, hi);\n  mx = -INF;\n  REP(i,v)REP(j,v) mx = max(mx, pmat[i][j]);\n  if (mx < k) {\n    cout << -1 << endl;\n    return 0;\n  } \n  cout << hi << endl;\n  if (hi > 100) {\n    return 0;\n  }\n  int s=0,t=0;\n  REP(i,v)REP(j,v) {\n    if (pmat[i][j] == mx) {\n      s = i;\n      t = j;\n    }\n  }\n  vector<int> res;\n  res.push_back(t);\n  for (int i = hi-1; i >= 0; --i) {\n    int nt=0;\n    int64_t nmx=0;\n    REP(j,v) {\n      if (vmat[i][s][j] + mat[j][t] == mx) {\n        nt = j;\n        nmx = vmat[i][s][j];\n      }\n    }\n    t = nt;\n    mx = nmx;\n    res.push_back(t);\n  }\n  reverse(ALL(res));\n  REP(i,res.size()) {\n    if (i) cout << ' ';\n    cout << res[i];\n  }\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n#define for_rev(i,a,b) for(int i=(a);i>=(b);--i)\n\nstruct Edge { int to, c; };\n\nvoid maxUpdate(int& a, int b) { a = max(a, b); }\n\nint V, K, E, score[21][155][155], score_buf[2][155][155], dp[110][155], prv[110][155];\nvector< vector< Edge > > adj;\n\nvoid restore(int step) {\n\tmemset(dp, 0, sizeof(dp));\n\tmemset(prv, -1, sizeof(prv));\n\t\n\tfor_(h,0,step) for_(v,0,V) {\n\t\tfor (Edge e : adj[v]) {\n\t\t\tif (dp[h + 1][e.to] < dp[h][v] + e.c) {\n\t\t\t\tdp[h + 1][e.to] = dp[h][v] + e.c;\n\t\t\t\tprv[h + 1][e.to] = v;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor_(v,0,V) {\n\t\tif (dp[step][v] >= K) {\n\t\t\tvector< int > path;\n\t\t\t\n\t\t\tint c = step;\n\t\t\t\n\t\t\twhile (v != -1) {\n\t\t\t\tpath.push_back(v);\n\t\t\t\tv = prv[c][v];\n\t\t\t\t--c;\n\t\t\t}\n\t\t\t\n\t\t\treverse(path.begin(), path.end());\n\t\t\t\n\t\t\tfor_(i,0,step+1) cout << path[i] << (i < step ? \" \" : \"\\n\");\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid warshall() {\n\tfor_(h,1,21) for_(u,0,V) for_(v,0,V) for_(k,0,V) {\n\t\tmaxUpdate(score[h][u][v], score[h - 1][u][k] + score[h - 1][k][v]);\n\t}\n}\n\nint calcScore(int step) {\n\tmemset(score_buf[0], 0, sizeof(score_buf[0]));\n\t\n\tfor_rev(h,20,0) {\n\t\tif (step >> h & 1) {\n\t\t\tmemset(score_buf[1], 0, sizeof(score_buf[1]));\n\t\t\t\n\t\t\tfor_(u,0,V) for_(v,0,V) for_(k,0,V) {\n\t\t\t\tmaxUpdate(score_buf[1][u][v], score_buf[0][u][k] + score[h][k][v]);\n\t\t\t\tif (score_buf[1][u][v] >= K) return score_buf[1][u][v];\n\t\t\t}\n\t\t\t\n\t\t\tfor_(u,0,V) for_(v,0,V) score_buf[0][u][v] = score_buf[1][u][v];\n\t\t}\n\t}\n\t\n\treturn -1;\n}\n\nint calcMinStep() {\n\tint lb = 0, ub = (int)1e6 + 10;\n\t\n\twhile (ub - lb > 1) {\n\t\tint med = (lb + ub) / 2;\n\t\tif (calcScore(med) >= K) ub = med;\n\t\telse lb = med;\n\t}\n\t\n\treturn ub;\n}\n\nvoid solve() {\n\twarshall();\n\t\n\tint min_step = calcMinStep();\n\t\n\tcout << (min_step > (int)1e6 ? -1 : min_step) << endl;\n\t\n\tif (min_step <= 100) restore(min_step);\n}\n\nint main() {\n\tcin >> V >> E >> K;\n\t\n\tadj.assign(V, vector< Edge >());\n\tfor_(h,0,21) for_(u,0,V) for_(v,0,V) score[h][u][v] = -(int)1e9;\n\t\n\tfor_(i,0,E) {\n\t\tint u, v, c;\n\t\tcin >> u >> v >> c;\n\t\tmaxUpdate(score[0][u][v], c);\n\t\tadj[u].push_back(Edge{v, c});\n\t}\n\t\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstruct edge{\n\tint t;\n\tint c;\n\tedge(){}\n\tedge(int tt,int cc){\n\t\tt=tt;\n\t\tc=cc;\n\t}\n};\n\nint n,m,tgt;\nvector<edge> G[151];\nint dp[151][151];\nint prev[151][151];\nint cyc_max[151][151];\nint to_max[151][151];\nint from_max[151][151];\n\nbool C(int v){\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<=min(n,v);j++){\n\t\t\tif(to_max[i][j]>=tgt)return true;\n\t\t\tif(from_max[i][j]>=tgt)return true;\n\t\t\tfor(int k=0;k<=min(n,v-j);k++){\n\t\t\t\tll all=to_max[i][j]+from_max[i][k];\n\t\t\t\tif(all>=(ll)tgt)return true;\n\t\t\t\tll rest=v-j-k;\n\t\t\t\tfor(int l=1;l<=n;l++){\n\t\t\t\t\tll va=(ll)rest/l;\n\t\t\t\t\tif(all+va*cyc_max[i][l]>=(ll)tgt)return true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nvoid get_route(int size){\n\tmemset(dp,-1,sizeof(dp));\n\tmemset(dp[0],0,sizeof(dp[0]));\n\tfor(int i=0;i<size;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(dp[i][j]>=0){\n\t\t\t\tfor(int l=0;l<G[j].size();l++){\n\t\t\t\t\tedge e=G[j][l];\n\t\t\t\t\tif(dp[i+1][e.t]<dp[i][j]+e.c){\n\t\t\t\t\t\tdp[i+1][e.t]=dp[i][j]+e.c;\n\t\t\t\t\t\tprev[i+1][e.t]=j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tif(dp[size][i]>=tgt){\n\t\t\tint now=i;\n\t\t\tvector<int> ans;\n\t\t\tfor(int j=0;j<size;j++){\n\t\t\t\tans.push_back(now);\n\t\t\t\tnow=prev[size-j][now];\n\t\t\t}\n\t\t\tans.push_back(now);\n\t\t\treverse(ans.begin(),ans.end());\n\t\t\tfor(int j=0;j<=size;j++){\n\t\t\t\tprintf(\"%d%c\",ans[j],j==size?'\\n':' ');\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nint main(void){\n\tscanf(\"%d%d%d\",&n,&m,&tgt);\n\tfor(int i=0;i<m;i++){\n\t\tint f,t,c;\n\t\tscanf(\"%d%d%d\",&f,&t,&c);\n\t\tG[f].push_back(edge(t,c));\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tdp[0][i]=0;\n\t\tfor(int j=0;j<n;j++){\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\tif(dp[j][k]>=0){\n\t\t\t\t\tfor(int l=0;l<G[k].size();l++){\n\t\t\t\t\t\tedge e=G[k][l];\n\t\t\t\t\t\tdp[j+1][e.t]=max(dp[j+1][e.t],dp[j][k]+e.c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcyc_max[i][j+1]=dp[j+1][i];\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\tfrom_max[i][j+1]=max(from_max[i][j+1],dp[j+1][k]);\n\t\t\t\tto_max[k][j+1]=max(to_max[k][j+1],dp[j+1][k]);\n\t\t\t}\n\t\t}\n\t}\n\tint l=-1,r=1000000007;\n\twhile(l+1<r){\n\t\tint mid=(l+r)/2;\n\t\tif(C(mid))r=mid;\n\t\telse l=mid;\n\t}\n\tif(r==1000000007){\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tprintf(\"%d\\n\",r);\n\tif(r<=100){\n\t\tget_route(r);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<int(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nconstexpr int INF = 1000000000;\n\nusing Array = vector<int>;\nusing Matrix = vector<Array>;\n\nMatrix mul(const Matrix& lhs, const Matrix& rhs) {\n  int r = lhs.size();\n  Matrix res(r, Array(r, -INF));\n  REP(i,r) REP(k,r) REP(j,r) {\n    res[i][j] = max(res[i][j], lhs[i][k] + rhs[k][j]);\n  }\n  return res;\n}\n\nMatrix pow(const Matrix& mat, int index) {\n  if (index == 0) {\n    int v = mat.size();\n    Matrix res(v, Array(v, -INF));\n    REP(i,v) res[i][i] = 0;\n    return res;\n  }\n  if (index == 1) return mat;\n  if ((index % 2) == 1) {\n    return mul(mat, pow(mat, index-1));\n  }\n  return pow(mul(mat, mat), index/2);\n}\n\nint main() {\n  int v,e,k;\n  cin>>v>>e>>k;\n  Matrix mat(v, Array(v, -INF));\n  REP(i,e) {\n    int s,t,c;\n    cin>>s>>t>>c;\n    mat[s][t] = max(mat[s][t], c);\n  }\n  int hi = k;\n  int lo = 0;\n  while (hi - lo > 1) {\n    int mid = (hi + lo) / 2;\n    auto pmat = pow(mat, mid);\n    int mx = -INF;\n    REP(i,v)REP(j,v) mx = max(mx, pmat[i][j]);\n    if (mx >= k) {\n      hi = mid;\n    } else {\n      lo = mid;\n    }\n  }\n  lo = max(0, lo - v * 200);\n  auto pmat = pow(mat, lo);\n  vector<int> score(v, -INF);\n  REP(i,v)REP(j,v) score[j] = max(score[j], pmat[i][j]);\n  REP(cnt,200 * v+1) {\n    vector<int> tmp(v, -INF);\n    REP(i,v)REP(j,v) tmp[j] = max(tmp[j], score[i] + mat[i][j]);\n    int mx = -INF;\n    REP(i,v) mx = max(mx, tmp[i]);\n    swap(score, tmp);\n    if (mx >= k) {\n      lo += cnt + 1;\n      break;\n    }\n  }\n  if (lo > 0 && lo <= k) {\n    cout << lo << endl;\n  } else {\n    cout << -1 << endl;\n    return 0;\n  }\n  if (hi > 100) {\n    return 0;\n  }\n  vector<vector<int>> vscore;\n  REP(i,v) score[i] = 0;\n  REP(cnt,lo) {\n    vector<int> tmp(v, -INF);\n    REP(i,v)REP(j,v) tmp[j] = max(tmp[j], score[i] + mat[i][j]);\n    int mx = -INF;\n    REP(i,v) mx = max(mx, tmp[i]);\n    vscore.push_back(score);\n    swap(score, tmp);\n  }\n  int t = 0;\n  int mx = -INF;\n  REP(i,v) {\n    if (score[i] > mx) {\n      mx = score[i];\n      t = i;\n    }\n  }\n  vector<int> res;\n  res.push_back(t);\n  for (int i = lo-1; i >= 0; --i) {\n    int nt = 0;\n    int nmx = -INF;\n    REP(j,v) {\n      if (vscore[i][j] + mat[j][t] == mx) {\n        nt = j;\n        nmx = vscore[i][j];\n      }\n    }\n    t = nt;\n    mx = nmx;\n    res.push_back(t);\n  }\n  reverse(ALL(res));\n  REP(i,res.size()) {\n    if (i) cout << ' ';\n    cout << res[i];\n  }\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<int(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nconstexpr int INF = 1000000000;\n\nusing Array = vector<int>;\nusing Matrix = vector<Array>;\n\nMatrix mul(const Matrix& lhs, const Matrix& rhs) {\n  int r = lhs.size();\n  Matrix res(r, Array(r, -INF));\n  REP(i,r) REP(k,r) REP(j,r) {\n    res[i][j] = max(res[i][j], lhs[i][k] + rhs[k][j]);\n  }\n  return res;\n}\n\nMatrix pow(const Matrix& mat, int index) {\n  if (index == 0) {\n    int v = mat.size();\n    Matrix res(v, Array(v, -INF));\n    REP(i,v) res[i][i] = 0;\n    return res;\n  }\n  if (index == 1) return mat;\n  if ((index % 2) == 1) {\n    return mul(mat, pow(mat, index-1));\n  }\n  return pow(mul(mat, mat), index/2);\n}\n\nint main() {\n  int v,e,k;\n  cin>>v>>e>>k;\n  Matrix mat(v, Array(v, -INF));\n  REP(i,e) {\n    int s,t,c;\n    cin>>s>>t>>c;\n    mat[s][t] = max(mat[s][t], c);\n  }\n  int idx = 0;\n  auto pmat = pow(mat, v*100);\n  vector<int> score(v, 0);\n  for (; idx < k; idx += v*100) {\n    vector<int> tmp(v, -INF);\n    REP(i,v)REP(j,v) tmp[j] = max(tmp[j], score[i] + mat[i][j]);\n    int mx = -INF;\n    REP(i,v) mx = max(mx, tmp[i]);\n    swap(score, tmp);\n    if (mx >= k - v*100) {\n      break;\n    }\n  }\n  if (idx > k) idx -= v*100;\n  pmat = pow(mat, idx);\n  REP(i,v) score[i] = -INF;\n  REP(i,v)REP(j,v) score[j] = max(score[j], pmat[i][j]);\n  REP(cnt,200 * v+1) {\n    vector<int> tmp(v, -INF);\n    REP(i,v)REP(j,v) tmp[j] = max(tmp[j], score[i] + mat[i][j]);\n    int mx = -INF;\n    REP(i,v) mx = max(mx, tmp[i]);\n    swap(score, tmp);\n    if (mx >= k) {\n      idx += cnt + 1;\n      break;\n    }\n  }\n  if (idx <= k) {\n    cout << idx << endl;\n  } else {\n    cout << -1 << endl;\n    return 0;\n  }\n  if (idx > 100) {\n    return 0;\n  }\n  vector<vector<int>> vscore;\n  REP(i,v) score[i] = 0;\n  REP(cnt,idx) {\n    vector<int> tmp(v, -INF);\n    REP(i,v)REP(j,v) tmp[j] = max(tmp[j], score[i] + mat[i][j]);\n    int mx = -INF;\n    REP(i,v) mx = max(mx, tmp[i]);\n    vscore.push_back(score);\n    swap(score, tmp);\n  }\n  int t = 0;\n  int mx = -INF;\n  REP(i,v) {\n    if (score[i] > mx) {\n      mx = score[i];\n      t = i;\n    }\n  }\n  vector<int> res;\n  res.push_back(t);\n  for (int i = idx-1; i >= 0; --i) {\n    int nt = 0;\n    int nmx = -INF;\n    REP(j,v) {\n      if (vscore[i][j] + mat[j][t] == mx) {\n        nt = j;\n        nmx = vscore[i][j];\n      }\n    }\n    t = nt;\n    mx = nmx;\n    res.push_back(t);\n  }\n  reverse(ALL(res));\n  REP(i,res.size()) {\n    if (i) cout << ' ';\n    cout << res[i];\n  }\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\ntypedef long long int Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\n\nbool operator < (const Edge &e, const Edge &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<vector<pair<vector<int>, long long int>>>type;\nint V, E, K;\n type time(const type&lts, const type&rts, const bool flag) {\n\ttype squs(V,vector<pair<vector<int>,long long int>>(V));\n\tfor (int i = 0; i < V; ++i) {\n\t\tfor (int j = 0; j < V; ++j) {\n\t\t\tif (i == j)squs[i][j] = make_pair(vector<int>(), 0ll);\n\t\t\telse squs[i][j] = make_pair(vector<int>(), static_cast<long long>(-1e17));\n\t\t}\n\t}\n\tlong long int amax = 0;\n\tfor (int k = 0; k < V; ++k) {\n\t\tfor (int i = 0; i < V; ++i) {\n\t\t\tfor (int j = 0; j < V; ++j) {\n\t\t\t\tif (squs[i][j].second <lts[i][k].second + rts[k][j].second) {\n\t\t\t\t\tsqus[i][j].second = lts[i][k].second + rts[k][j].second;\n\t\t\t\t\tamax = max(amax, squs[i][j].second);\n\t\t\t\t\tif (flag) {\n\t\t\t\t\t\tsqus[i][j].first.clear();\n\t\t\t\t\t\tsqus[i][j].first.insert(squs[i][j].first.end(), lts[i][k].first.begin(), lts[i][k].first.end());\n\t\t\t\t\t\tsqus[i][j].first.insert(squs[i][j].first.end(), rts[k][j].first.begin(), rts[k][j].first.end());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn squs;\n}\ntype square(const type&ts,bool flag) {\n\treturn time(ts, ts, flag);\n}\n\ntype power(const type&ts,const long long  int num,const bool flag) {\n\tassert(num);\n\tif (num == 1)return ts;\n\telse {\n\t\ttype pot(square(power(ts,num/2,flag),flag));\n\t\tif (num % 2) {\n\t\t\tpot = time(pot, ts, flag);\n\t\t}\n\t\treturn pot;\n\t}\n}\nvector<int>ans;\nbool check(const type &ts,const long long int run,const int point,const bool flag) {\n\t\n\ttype t(power(ts, run, flag&&run <= 100));\n\tlong long int amax = 0;\n\tfor (int i = 0; i < V; ++i) {\n\t\tfor (int j = 0; j < V; ++j) {\n\t\t\tif (amax < t[i][j].second) {\n\t\t\t\tamax = t[i][j].second;\n\t\t\t\tif (run <= 100&&flag) {\n\t\t\t\t\tans = t[i][j].first;\n\t\t\t\t\tans.insert(ans.begin(), i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (amax >= point)return true;\n\telse return false;\n}\n\nint main() { cin >> V >> E >> K;\n\ttype times(V, vector<pair<vector<int>,long long int>>(V, make_pair(vector<int>(),static_cast<long long int>(-1e18))));\n\tfor (int i = 0; i < E; ++i) {\n\t\tlong long int a, b, c; cin >> a >> b >> c;\n\n\t\ttimes[a][b].second = max(times[a][b].second, c);\n\t\ttimes[a][b].first = vector<int>(1,b);\n\t}\n\tfor (int i = 0; i < V; ++i) {\n\t\ttimes[i][i] = make_pair(vector<int>(1,i),0);\n\t\t\n\t}\n\tlong long int amin = 1;\n\tlong long int amax = 1e9;\n\twhile (amin + 1 != amax) {\n\t\tlong long int amid((amin + amax) / 2);\n\t\tif (check(times,amid, K,false)) {\n\t\t\tamax = amid;\n\t\t}\n\t\telse {\n\t\t\tamin = amid;\n\t\t}\n\t}\n\tif (amax > 1e8) {\n\t\tcout << -1 << endl;\n\t}\n\telse {\n\t\tcheck(times, amax, K,true);\n\t\tcout << amax << endl;\n\t\tif (amax <= 100) {\n\t\t\tfor (int i = 0; i < ans.size(); ++i) {\n\t\t\t\tcout << ans[i];\n\t\t\t\tif (i != ans.size() - 1)cout << \" \";\n\t\t\t\telse cout << endl;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nint n, m, k;\ntypedef vector<vi> M;\nM operator*(const M &a, const M &b){\n\tM c(a.size(), vi(a.size(), -1));\n\trep(l, n) rep(i, n) rep(j, n) if(a[i][l] >= 0 && b[l][j] >= 0){\n\t\tc[i][j] = max(c[i][j], a[i][l] + b[l][j]);\n\t\tif(c[i][j] >= k) c[i][j] = k;\n\t}\n\treturn c;\n}\nint dp[128][150], prev[128][150];\nvoid solve(const M &e){\n\tmemset(dp, -1, sizeof(dp));\n\trep(i, n) dp[0][i] = 0;\n\tint ai, al;\n\trep(i, 100) rep(j, n) if(dp[i][j] >= 0){\n\t\trep(l, n) if(e[j][l] >= 0 && dp[i + 1][l] < dp[i][j] + e[j][l]){\n\t\t\tdp[i + 1][l] = min(k, dp[i][j] + e[j][l]);\n\t\t\tprev[i + 1][l] = j;\n\t\t\tif(dp[i + 1][l] >= k){\n\t\t\t\tai = i + 1; al = l;\n\t\t\t\tgoto END;\n\t\t\t}\n\t\t}\n\t}\n\tEND:\n\tvi ans;\n\tfor(; ai >= 0; ai--){\n\t\tans.pb(al);\n\t\tif(ai > 0) al = prev[ai][al];\n\t}\n\treverse(all(ans));\n\trep(i, ans.size()) cout << ans[i] << (i == ans.size() - 1 ? \"\\n\" : \" \");\n}\nint main(){\n\tcin >> n >> m >> k;\n\tM e(n, vi(n, -1)), p(n, vi(n, -1));\n\tM pw[20];\n\t\n\trep(i, m){\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\te[a][b] = max(e[a][b], c);\n\t}\n\t\n\trep(i, n) p[i][i] = 0;\n\tpw[0] = e;\n\trep(i, 19) pw[i + 1] = pw[i] * pw[i];\n\tint ans = 0;\n\tbool can = 0;\n\tfor(int i = 19; i >= 0; i--){\n\t\tM pp = p * pw[i];\n\t\tbool ok = 0;\n\t\trep(j, n) rep(l, n) if(pp[j][l] >= k) ok = can = 1;\n\t\tif(!ok) p = pp, ans += 1 << i;\n\t}\n\tif(!can){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tans++;\n\tcout << ans << endl;\n\tif(ans <= 100) solve(e);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\ntypedef long long int Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\n\nbool operator < (const Edge &e, const Edge &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<vector<pair<vector<int>, long long int>>>type;\nint V, E, K;\n type time(const type&lts, const type&rts, const bool flag) {\n\ttype squs(V,vector<pair<vector<int>,long long int>>(V));\n\tfor (int i = 0; i < V; ++i) {\n\t\tfor (int j = 0; j < V; ++j) {\n\t\t\tif (i == j)squs[i][j] = make_pair(vector<int>(), 0ll);\n\t\t\telse squs[i][j] = make_pair(vector<int>(), static_cast<long long>(-1e17));\n\t\t}\n\t}\n\tlong long int amax = 0;\n\tfor (int k = 0; k < V; ++k) {\n\t\tfor (int i = 0; i < V; ++i) {\n\t\t\tfor (int j = 0; j < V; ++j) {\n\t\t\t\tif (squs[i][j].second <lts[i][k].second + rts[k][j].second) {\n\t\t\t\t\tsqus[i][j].second = lts[i][k].second + rts[k][j].second;\n\t\t\t\t\tamax = max(amax, squs[i][j].second);\n\t\t\t\t\tif (flag) {\n\t\t\t\t\t\tsqus[i][j].first.clear();\n\t\t\t\t\t\tsqus[i][j].first.insert(squs[i][j].first.end(), lts[i][k].first.begin(), lts[i][k].first.end());\n\t\t\t\t\t\tsqus[i][j].first.insert(squs[i][j].first.end(), rts[k][j].first.begin(), rts[k][j].first.end());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn squs;\n}\ntype square(const type&ts,bool flag) {\n\tconst type lts(ts);\n\tconst type rts(ts);\n\treturn time(lts, rts, flag);\n}\n\ntype power(const type&ts,const long long  int num,const bool flag) {\n\tassert(num);\n\tif (num == 1)return ts;\n\telse {\n\t\ttype pot(square(power(ts,num/2,flag),flag));\n\t\tif (num % 2) {\n\t\t\tpot = time(pot, ts, flag);\n\t\t}\n\t\treturn pot;\n\t}\n}\nvector<int>ans;\nbool check(const type &ts,const long long int run,const int point) {\n\t\n\ttype t(power(ts, run, run <= 100));\n\tlong long int amax = 0;\n\tfor (int i = 0; i < V; ++i) {\n\t\tfor (int j = 0; j < V; ++j) {\n\t\t\tif (amax < t[i][j].second) {\n\t\t\t\tamax = t[i][j].second;\n\t\t\t\tif (run <= 100) {\n\t\t\t\t\t\n\t\t\t\t\tans = t[i][j].first;\n\t\t\t\t\tans.insert(ans.begin(), i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (amax >= point)return true;\n\telse return false;\n}\n\nint main() { cin >> V >> E >> K;\n\ttype times(V, vector<pair<vector<int>,long long int>>(V, make_pair(vector<int>(),static_cast<long long int>(-1e18))));\n\tfor (int i = 0; i < E; ++i) {\n\t\tlong long int a, b, c; cin >> a >> b >> c;\n\n\t\ttimes[a][b].second = max(times[a][b].second, c);\n\t\ttimes[a][b].first = vector<int>(1,b);\n\t}\n\tfor (int i = 0; i < V; ++i) {\n\t\ttimes[i][i] = make_pair(vector<int>(1,i),0);\n\t\t\n\t}\n\tlong long int amin = 1;\n\tlong long int amax = 1e9;\n\twhile (amin + 1 != amax) {\n\t\tlong long int amid((amin + amax) / 2);\n\t\tif (check(times,amid, K)) {\n\t\t\tamax = amid;\n\t\t}\n\t\telse {\n\t\t\tamin = amid;\n\t\t}\n\t}\n\tif (amax > 1e8) {\n\t\tcout << -1 << endl;\n\t}\n\telse {\n\t\tcheck(times, amax, K);\n\t\tcout << amax << endl;\n\t\tif (amax <= 100) {\n\t\t\tfor (int i = 0; i < ans.size(); ++i) {\n\t\t\t\tcout << ans[i];\n\t\t\t\tif (i != ans.size() - 1)cout << \" \";\n\t\t\t\telse cout << endl;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//AOJproplem2432\n//stl????????????\n//I don't know STL???\n//I plactice now???\n//OH! WRONG ANSWER!!\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#define bigas(a,b) if(a<b){a=b;}\nusing namespace std;\nint main(void){\n\tint h=0,i=0,j=0,m=0,ex=0,ans=0,V,E,K,x,y,z;\n\tstatic int ya[20][150][150]={0};//ya[i][x][y]???x??????y???2^i??¬???????????´????????¢??°?????????\n\tstatic int gen[150]={0};//gen[x]???x??´??????????????§?????°\n\tstatic int ima[150]={0};\n\tstatic int pre[101][150]={0};//??????????????\\??????\n\tstatic int poi[101][150]={0};//??????\n\tfor(h=0;h<18;h++){\n\t\tfor(i=0;i<150;i++){\n\t\t\tfor(j=0;j<150;j++){\n\t\t\t\tya[h][i][j]=-(1<<30);\n\t\t\t\tif(i==j){ya[h][i][j]=0;}\n\t\t\t}\n\t\t}\n\t}\n\tscanf(\"%d %d %d\",&V,&E,&K);\n\tfor(i=0;i<E;i++){\n\t\tscanf(\"%d %d %d\",&x,&y,&z);\n\t\tbigas(ya[0][x][y],z);\n\t}\n\tfor(h=1;h<101;h++){\n\t\tfor(i=0;i<V;i++){\n\t\t\tfor(j=0;j<V;j++){\n\t\t\t\tif(poi[h][j]<poi[h-1][i]+ya[0][i][j]){\n\t\t\t\t\tpoi[h][j]=poi[h-1][i]+ya[0][i][j];\n\t\t\t\t\tpre[h][j]=i;\n\t\t\t\t\tif(poi[h][j]>=K){ex=1;K=poi[h][j];ans=j;}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ex==1){break;}\n\t}\n\tif(ex==1){\n\t\tprintf(\"%d\\n\",h);\n\t\tima[h]=ans;\n\t\tfor(i=h-1;i>=0;i--){\n\t\t\tima[i]=pre[i+1][ima[i+1]];\n\t\t}\n\t\tfor(i=0;i<=h;i++){\n\t\t\tprintf(\"%d \",ima[i]);\n\t\t}\n\t\treturn 0;\n\t}\n\th=0,i=0,j=0,m=0,ex=0,ans=0;\n\t\n\t//??????????????§????????????????§£???\n\tfor(h=1;h<20;h++){//2^i??¬????±???????\n\t\tfor(i=0;i<V;i++){//i??????\n\t\t\tfor(j=0;j<V;j++){//j?????§\n\t\t\t\tfor(m=0;m<V;m++){//m????????£???\n\t\t\t\t\tbigas(ya[h][i][j],ya[h-1][i][m]+ya[h-1][m][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//??????????????¬??°??????????????§????±???????\n\tfor(h=19;h>=0;h--){\n\t\tfor(i=0;i<V;i++){\n\t\t\tfor(j=0;j<V;j++){\n\t\t\t\tbigas(ima[j],gen[i]+ya[h][i][j]);\n\t\t\t\tif(ima[j]>=K){ex=1;break;}\n\t\t\t}\n\t\t}\n\t\tif(ex==0){\n\t\t\tans+=(1<<h);\n\t\t\tfor(i=0;i<V;i++){\n\t\t\tgen[i]=ima[i];\n\t\t\t}\n\t\t}else{\n\t\t\tfor(i=0;i<V;i++){\n\t\t\tima[i]=gen[i];\n\t\t\t}\n\t\t}\n\t\tex=0;\n\t}\n\tans++;\n\tif(ans+500<(1<<20)){printf(\"%d\\n\",ans);}else{printf(\"-1\\n\");}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <vector>\n#include <valarray>\n#include <array>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <random>\n#include <bitset>\n \nusing namespace std;\ntypedef long long ll;\n\nconst ll INF = 1LL<<40;\n\nstruct Matrix {\n    typedef ll D;\n    vector<valarray<D>> d;\n    int N, M;\n    Matrix(int N, int M) : N(N), M(M) {\n        d.resize(N);\n        for (int i = 0; i < N; i++) {\n            d[i] = valarray<D>(INF, M);\n        }\n    }\n\n    valarray<D>& operator[](int p) {\n        return d[p];\n    }\n\n    const valarray<D>& operator[](int p) const {\n        return d[p];\n    }\n\n    Matrix& operator=(const Matrix &other) {\n        copy_n(other.d.begin(), N, d.begin());\n        return *this;\n    }\n\n    Matrix operator*(const Matrix &right) {\n        Matrix res(N, right.M), r(right.M, right.N);\n        for (int i = 0; i < right.M; i++) {\n            for (int j = 0; j < right.N; j++) {\n                r[i][j] = right[j][i];\n            }\n        }\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < right.M; j++) {\n                res[i][j] = min(INF, (d[i]+r[j]).min());\n            }\n        }\n        return res;\n    }\n\n    Matrix pow(ll p) {\n        Matrix res(N, M), buf = *this;\n        for (int i = 0; i < N; i++) res[i][i] = D(0);\n        while (p != 0) {\n            if (p % 2) {\n                res = res*buf;\n            }\n            buf = buf*buf;\n            p /= 2;\n        }\n        return res;\n    }\n};\n\nconst int MN = 160;\n\ntypedef tuple<int, int, ll> T;\n\nll dist[MN], dist2[MN];\nint back[110][MN];\n\nint main() {\n    int V, E; ll K;\n    cin >> V >> E >> K; V++;\n    vector<T> v;\n    for (int i = 0; i < E; i++) {\n        int a, b; ll c;\n        cin >> a >> b >> c;\n        v.push_back(T(a, b, -c));\n    }\n    for (int i = 0; i < V-1; i++) {\n        v.push_back(T(V-1, i, 0));\n    }\n\n    fill_n(dist, MN, INF);\n    dist[V-1] = 0;\n    for (int i = 0; i < 101; i++) {\n        copy_n(dist, MN, dist2);\n        for (T t: v) {\n            int a, b; ll c;\n            tie(a, b, c) = t;\n            if (dist[a] == INF) continue;\n            if (dist2[b] < dist[a]+c) continue;\n            dist2[b] = dist[a]+c;\n            back[i][b] = a;\n        }\n        copy_n(dist2, MN, dist);\n\n        int f = -1, d = 0;\n        for (int j = 0; j < V-1; j++) {\n            if (-K < dist[j]) continue;\n            if (d < dist[j]) continue;\n            d = dist[j];\n            f = j;\n        }\n        if (f == -1) continue;\n        cout << i << endl;\n        int jj = f;\n        vector<int> res;\n        res.push_back(jj);\n        for (int k = i; k > 0; k--) {\n            res.push_back(back[k][jj]);\n            jj = back[k][jj];\n        }\n        reverse(res.begin(), res.end());\n        for (int r: res) {\n            cout << r << \" \";\n        } cout << endl;\n        return 0;\n    }\n\n\n    Matrix base(V, V);\n    for (T t: v) {\n        int a, b; ll c;\n        tie(a, b, c) = t;\n        base[a][b] = min(base[a][b], c);\n    }\n\n    int l = 0, r = 2000000;\n    while (r-l > 1) {\n        int md = (l+r)/2;\n        Matrix bb = base.pow(md);\n        bool f = false;\n        for (int i = 0; i < V; i++) {\n            for (int j = 0; j < V; j++) {\n                if (bb[i][j] <= -K) {\n                    f = true;\n                }\n            }\n        }\n//        cout << md << \" \" << f << endl;\n        if (!f) {\n            l = md;\n        } else {\n            r = md;\n        }\n    }\n    if (r == 2000000) {\n        cout << -1 << endl;\n    } else {\n        cout << r << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\ntypedef long long int Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\n\nbool operator < (const Edge &e, const Edge &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<vector<pair<vector<int>, long long int>>>type;\nint V, E, K;\n type time(const type&lts, const type&rts, const bool flag) {\n\ttype squs(V,vector<pair<vector<int>,long long int>>(V));\n\tfor (int i = 0; i < V; ++i) {\n\t\tfor (int j = 0; j < V; ++j) {\n\t\t\tif (i == j)squs[i][j] = make_pair(vector<int>(), 0ll);\n\t\t\telse squs[i][j] = make_pair(vector<int>(), static_cast<long long>(-1e17));\n\t\t}\n\t}\n\tfor (int k = 0; k < V; ++k) {\n\t\tfor (int i = 0; i < V; ++i) {\n\t\t\tfor (int j = 0; j < V; ++j) {\n\t\t\t\tif (squs[i][j].second <lts[i][k].second + rts[k][j].second) {\n\t\t\t\t\tsqus[i][j].second = lts[i][k].second + rts[k][j].second;\n\t\t\t\t\tif (flag) {\n\t\t\t\t\t\tsqus[i][j].first.clear();\n\t\t\t\t\t\tsqus[i][j].first.insert(squs[i][j].first.end(), lts[i][k].first.begin(), lts[i][k].first.end());\n\t\t\t\t\t\tsqus[i][j].first.insert(squs[i][j].first.end(), rts[k][j].first.begin(), rts[k][j].first.end());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn squs;\n}\ntype square(const type&ts,bool flag) {\n\treturn time(ts, ts, flag);\n}\n\ntype power(const type&ts,const long long  int num,const bool flag) {\n\tassert(num);\n\tif (num == 1)return ts;\n\telse {\n\t\ttype pot(square(power(ts,num/2,flag),flag));\n\t\tif (num % 2) {\n\t\t\tpot = time(pot, ts, flag);\n\t\t}\n\t\treturn pot;\n\t}\n}\nvector<int>ans;\nbool check(const type &ts,const long long int run,const int point,const bool flag) {\n\t\n\ttype t(power(ts, run, flag&&run <= 100));\n\tlong long int amax = 0;\n\tfor (int i = 0; i < V; ++i) {\n\t\tfor (int j = 0; j < V; ++j) {\n\t\t\tif (amax < t[i][j].second) {\n\t\t\t\tamax = t[i][j].second;\n\t\t\t\tif (run <= 100&&flag) {\n\t\t\t\t\tans.push_back(i);\n\t\t\t\t\tans.insert(ans.end(), t[i][j].first.begin(),t[i][j].first.end());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (amax >= point)return true;\n\telse return false;\n}\n\nint main() { cin >> V >> E >> K;\n\ttype times(V, vector<pair<vector<int>,long long int>>(V, make_pair(vector<int>(),static_cast<long long int>(-1e18))));\n\tfor (int i = 0; i < E; ++i) {\n\t\tlong long int a, b, c; cin >> a >> b >> c;\n\n\t\ttimes[a][b].second = max(times[a][b].second, c);\n\t\ttimes[a][b].first = vector<int>(1,b);\n\t}\n\tfor (int i = 0; i < V; ++i) {\n\t\ttimes[i][i] = make_pair(vector<int>(1,i),0);\n\t\t\n\t}\n\tlong long int amin = 0;\n\tlong long int amax = 1e6+10;\n\twhile (amin + 1 != amax) {\n\t\tlong long int amid((amin + amax) / 2);\n\t\tif (check(times,amid, K,false)) {\n\t\t\tamax = amid;\n\t\t}\n\t\telse {\n\t\t\tamin = amid;\n\t\t}\n\t}\n\tif (amax >1e6+5) {\n\t\tcout << -1 << endl;\n\t}\n\telse {\n\t\tcheck(times, amax, K,true);\n\t\tcout << amax << endl;\n\t\tif (amax <= 100) {\n\t\t\tfor (int i = 0; i < ans.size(); ++i) {\n\t\t\t\tcout << ans[i];\n\t\t\t\tif (i != ans.size() - 1)cout << \" \";\n\t\t\t\telse cout << endl;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n#define for_rev(i,a,b) for(int i=(a);i>=(b);--i)\n\nstruct Edge { int to, c; };\n\nvoid maxUpdate(int& a, int b) { a = max(a, b); }\n\nconst int mINF = (-1) * (int)1e9 / 2;\n\nint V, K, E, score[21][155][155], score_buf[2][155][155], dp[155][155], prv[155][155];\nvector< vector< Edge > > adj;\n\nvoid restore(int step, int v) {\n\tint c = step;\n\tvector< int > path;\n\t\n\twhile (v != -1) {\n\t\tpath.push_back(v);\n\t\tv = prv[c--][v];\n\t}\n\t\n\treverse(path.begin(), path.end());\n\tfor_(i,0,step+1) cout << path[i] << (i < step ? \" \" : \"\\n\");\n}\n\nbool shortPhase() {\n\tmemset(dp, -1, sizeof(dp));\n\tmemset(prv, -1, sizeof(prv));\n\t\n\tfor_(v,0,V) dp[0][v] = 0;\n\t\n\tint max_score = -1, step = -1, terminal = -1;\n\t\n\tfor_(i,0,150) {\n\t\tfor_(v,0,V) {\n\t\t\tif (dp[i][v] == -1) continue;\n\t\t\n\t\t\tfor (Edge e : adj[v]) {\n\t\t\t\tif (dp[i + 1][e.to] < dp[i][v] + e.c) {\n\t\t\t\t\tdp[i + 1][e.to] = dp[i][v] + e.c;\n\t\t\t\t\tprv[i + 1][e.to] = v;\n\t\t\t\t\t\n\t\t\t\t\tif (max_score < dp[i + 1][e.to]) {\n\t\t\t\t\t\tmax_score = dp[i + 1][e.to];\n\t\t\t\t\t\tterminal = e.to;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (max_score >= K) {\n\t\t\tstep = i + 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tif (max_score >= K) {\n\t\tcout << step << endl;\n\t\trestore(step, terminal);\n\t\treturn true;\n\t}\n\t\n\tif (max_score == -1) {\n\t\tcout << -1 << endl;\n\t\treturn true;\n\t}\n\t\n\treturn false;\n}\n\nvoid warshall() {\n\tfor_(h,1,21) for_(u,0,V) for_(v,0,V) for_(k,0,V) {\n\t\tif (score[h - 1][u][k] >= 0 && score[h - 1][k][v] >= 0) {\n\t\t\tmaxUpdate(score[h][u][v], score[h - 1][u][k] + score[h - 1][k][v]);\n\t\t}\n\t}\n}\n\nint calcMinStep() {\n\tint res = 0;\n\t\n\tmemset(score_buf, -1, sizeof(score_buf));\n\tfor_(v,0,V) score_buf[0][v][v] = 0;\n\t\n\tfor_rev(h,20,0) {\n\t\tmemset(score_buf[1], -1, sizeof(score_buf[1]));\n\t\tbool flag = false;\n\t\t\n\t\tfor_(u,0,V) for_(v,0,V) for_(k,0,V) {\n\t\t\tif (score_buf[0][u][k] >= 0 && score[h][k][v] >= 0) {\n\t\t\t\tmaxUpdate(score_buf[1][u][v], score_buf[0][u][k] + score[h][k][v]);\n\t\t\t\tif (score_buf[1][u][v] >= K) flag = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (!flag) {\n\t\t\tswap(score_buf[0], score_buf[1]);\n\t\t\tres += 1 << h;\n\t\t}\n\t}\n\t\n\treturn res + 1;\n}\n\nvoid solve() {\n\twarshall();\n\tif (!shortPhase()) cout << calcMinStep() << endl;\n}\n\nint main() {\n\tcin >> V >> E >> K;\n\t\n\tadj.assign(V, vector< Edge >());\n\tmemset(score, -1, sizeof(score));\n\t\n\tfor_(i,0,E) {\n\t\tint u, v, c;\n\t\tcin >> u >> v >> c;\n\t\tmaxUpdate(score[0][u][v], c);\n\t\tadj[u].push_back(Edge{v, c});\n\t}\n\t\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\nint V,E,K;\nconst int INF = (1<<30);\nmat G;\n\nmat g[30];\nmat u[30];\n\nint add(int a,int b){\n  if(a==-INF||b==-INF)return -INF;\n  return min(a+b,K);\n}\n\npair<mat,mat> merge(mat A,mat B, bool flag=false){\n  mat X( V, vec(V, -INF) );\n  mat Y( V, vec(V, -INF) );\n  \n  for(int from=0;from<V;from++){\n    for(int to=0;to<V;to++){\n      for(int ex=0;ex<V;ex++){\n        int cost=add(A[from][ex],B[ex][to]);\n        if(X[from][to]<cost){\n          X[from][to]=cost;\n          Y[from][to]=ex;\n        }\n      }\n    }\n  }\n  return make_pair(X,Y);\n}\n\n\nint calc(int m,int &si,int &ti){\n  mat t;\n  for(int i=0;i<30;i++){\n    if(m>>i&1){\n      if(t.empty()){\n        t=g[i];\n      }else{\n        t=merge(t,g[i]).first;\n      }\n    }\n  }\n  \n  int res=-INF;\n  for(int i=0;i<V;i++){\n    for(int j=0;j<V;j++){\n      if(res<t[i][j]){\n        si=i;\n        ti=j;\n        res=t[i][j];\n      }\n    }\n  }\n  return res;\n}\n\nvoid Dfs(vec& s,int from,int to,int len){\n  if(len==0)return;\n  \n  for(int i=0;i<30;i++){\n    if(~len>>i&1)continue;\n    int ex=u[i][from][to];\n\n    if(i==0){\n      if(len>=2)s.push_back(ex);\n      Dfs(s,ex,to,len-1);\n    }else{\n      int sub=(1<<i)/2;\n      Dfs(s,from,ex,sub);\n      s.push_back(ex);\n      Dfs(s,ex,to,len-sub);\n    }\n    break;\n  }\n}\n\nint main(){\n  cin>>V>>E>>K;\n  G=mat( V, vec(V, -INF) );\n  \n  g[0]=u[0]=G;\n  for(int i=0;i<V;i++)g[0][i][i]=0;\n  \n  for(int i=0;i<E;i++){\n    int a,b,c;\n    cin>>a>>b>>c;\n    G[a][b]=max(G[a][b],c);\n    \n    g[0][a][b]=max(g[0][a][b],c);\n    u[0][a][b]=b;\n  }\n\n  \n  for(int i=1;i<30;i++){\n    pair<mat,mat> temp=merge(g[i-1],g[i-1]);\n    g[i]=temp.first;\n    u[i]=temp.second;\n  }\n\n\n  int si,ti;\n  int left=1,right=K+1,mid;\n\n  while( left < right ){\n    mid=(left+right)/2;\n    if( calc(mid,si,ti) >= K ){\n      right=mid;\n    }else{\n      left=mid+1;\n    }\n  }\n\n  for(int i=0;i<V;i++)g[0][i][i]=-INF;\n  for(int i=1;i<30;i++){\n    pair<mat,mat> temp=merge(g[i-1],g[i-1]);\n    g[i]=temp.first;\n    u[i]=temp.second;\n  }\n  \n  if(left==K+1){\n    assert(0);\n    cout<<-1<<endl;\n  }else{\n    cout<<left<<endl;\n    if(left<=100){\n      vec tab;\n      tab.push_back(si);\n      Dfs(tab,si,ti,left);\n      tab.push_back(ti);\n      //      cout<<tab.size()<<endl;\n      int sum=0;\n      assert( left +1 == (int)tab.size() );\n      for(int i=0;i<(int)tab.size();i++){\n        if(i>0 && G[ tab[i-1]][ tab[i] ] == -INF ){\n          assert(0);\n        }\n        if(i>0)   sum+=G[ tab[i-1]][ tab[i] ];\n        if(i)cout<<' ';\n        cout<<tab[i];\n      }\n      cout<<endl;\n      assert(sum>=K);\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int logMaxStep = 30;\n\ntypedef long long ll;\ntypedef vector< vector<ll> > Graph;\n\nint GetLogStep(int S) {\n\tint res;\n\tfor (res = 0; (1 << res) <= S; ++res);\n\treturn res;\n}\nGraph nextG(const Graph& g1, const Graph& g2) {\n\tint N = g1.size();\n\tGraph res(N, vector<ll>(N, 0));\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tfor (int k = 0; k < N; ++k) {\n\t\t\t\tif (g1[i][k] > 0 && g2[k][j] > 0) {\n\t\t\t\t\tres[i][j] = max(res[i][j], g1[i][k]+g2[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nvector<int> nextDP(vector<ll>& dp, Graph& g) {\n\tint N = g.size();\n\tvector<int> prevV(N, -1);\n\tvector<ll> ndp(N, -1);\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tif (dp[i] >= 0 && g[i][j] > 0) {\n\t\t\t\tif (dp[i]+g[i][j] > ndp[j]) {\n\t\t\t\t\tndp[j] = dp[i]+g[i][j];\n\t\t\t\t\tprevV[j] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tdp[i] = ndp[i];\n\t}\n\treturn prevV;\n}\nll GetMaxScore(Graph& G, int S) {\n\tint N = G.size();\n\tGraph g = G;\n\tint logS = GetLogStep(S);\n\tvector<ll> dp(N, 0);\n\tfor (int i = 0; i < logS; ++i) {\n\t\tif ( (1 << i) & S ) {\n\t\t\tnextDP(dp, g);\n\t\t}\n\t\tg = nextG(g, g);\n\t}\n\tll res = -1;\n\tfor (int i = 0; i < dp.size(); ++i) {\n\t\tres = max(res, dp[i]);\n\t}\n\treturn res;\n}\nbool check200Step(Graph& G, int K) {\n\tint N = G.size();\n\tvector<ll> dp(N, 0);\n\tvector< vector<int> > prevV;\n\tfor (int t = 0; t < 200; ++t) {\n\t\tprevV.push_back( nextDP(dp, G) );\n\t\tint aid = 0;\n\t\tfor (int i = 0; i < dp.size(); ++i) {\n\t\t\tif (dp[i] > dp[aid]) aid = i;\n\t\t}\n\t\tif (dp[aid] >= K) {\n\t\t\tcout << t+1 << endl;\n\t\t\tif (t+1 <= 100) {\n\t\t\t\tvector<int> vl;\n\t\t\t\tint v = aid; vl.push_back(v);\n\t\t\t\tfor (int i = t; i >= 0; --i) {\n\t\t\t\t\tv = prevV[i][v];\n\t\t\t\t\tvl.push_back(v);\n\t\t\t\t}\n\t\t\t\treverse(vl.begin(), vl.end());\n\t\t\t\tfor (int i = 0; i < vl.size(); ++i) {\n\t\t\t\t\tif (i) cout << \" \";\n\t\t\t\t\tcout << vl[i];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint main() {\n\tint N, E, K; cin >> N >> E >> K;\n\tGraph G(N, vector<ll>(N, 0));\n\tfor (int i = 0; i < E; ++i) {\n\t\tint a, b; ll c; cin >> a >> b >> c;\n\t\tG[a][b] = max(G[a][b], c);\n\t}\n\tif ( !check200Step(G, K) ) {\n//\t\tcout << \"OH...\" << endl;\n\t\tint l = 0, r = K+1;\n\t\tfor (int t = 0; t < logMaxStep; ++t) {\n\t\t\tint m = (l + r) / 2;\n\t\t\tif ( GetMaxScore(G, m) >= K ) {\n\t\t\t\tr = m;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tl = m;\n\t\t\t}\n\t\t}\n\t\tif (r > K) {\n\t\t\tcout << -1 << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << r << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#define bigas(a,b) if(a<b){a=b;}\nusing namespace std;\nint main(void){\n\tint h=0,i=0,j=0,m=0,ex=0,ans=0,V,E,K,x,y,z;\n\tstatic int ya[18][150][150]={0};//ya[i][x][y]???x??????y???2^i??¬???????????´????????¢??°?????????\n\tstatic int gen[150]={0};//gen[x]???x??´??????????????§?????°\n\tstatic int ima[150]={0};\n\tstatic int pre[101][150]={0};//??????????????\\??????\n\tstatic int poi[101][150]={0};//??????\n\tscanf(\"%d %d %d\",&V,&E,&K);\n\tfor(i=0;i<E;i++){\n\t\tscanf(\"%d %d %d\",&x,&y,&z);\n\t\tbigas(ya[0][x][y],z);\n\t}\n\tfor(h=1;h<101;h++){\n\t\tfor(i=0;i<V;i++){\n\t\t\tfor(j=0;j<V;j++){\n\t\t\t\tif(poi[h][j]<poi[h-1][i]+ya[0][i][j]){\n\t\t\t\t\tpoi[h][j]=poi[h-1][i]+ya[0][i][j];\n\t\t\t\t\tpre[h][j]=i;\n\t\t\t\t\tif(poi[h][j]>K){ex=1;K=poi[h][j];ans=j;}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ex==1){break;}\n\t}\n\tif(ex==1){\n\t\tprintf(\"%d\\n\",h);\n\t\tima[h]=ans;\n\t\tfor(i=h-1;i>=0;i--){\n\t\t\tima[i]=pre[i+1][ima[i+1]];\n\t\t}\n\t\tfor(i=0;i<=h;i++){\n\t\t\tprintf(\"%d \",ima[i]);\n\t\t}\n\t\treturn 0;\n\t}\n\tfor(h=1;h<17;h++){//2^i??¬????±???????\n\t\tfor(i=0;i<V;i++){//i??????\n\t\t\tfor(j=0;j<V;j++){//j?????§\n\t\t\t\tfor(m=0;m<V;m++){//m????????£???\n\t\t\t\t\tbigas(ya[h][i][j],ya[h-1][i][m]+ya[h-1][m][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//??????????????¬??°??????????????§????±???????\n\tfor(h=17;h>=0;h--){\n\t\tfor(i=0;i<V;i++){\n\t\t\tfor(j=0;j<V;j++){\n\t\t\t\tima[j]=gen[i]+ya[h][i][j];\n\t\t\t\tif(ima[j]>=K){ex=1;break;}\n\t\t\t}\n\t\t\tif(ex==1){break;}\n\t\t}\n\t\tif(ex==0){\n\t\t\tans+=(1<<h);\n\t\t\tfor(i=0;i<V;i++){\n\t\t\tgen[i]=ima[i];\n\t\t\t}\n\t\t}\n\t\tex=0;\n\t}\n\tans++;\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n#define for_rev(i,a,b) for(int i=(a);i>=(b);--i)\n\nstruct Edge { int to, c; };\n\nvoid maxUpdate(int& a, int b) { a = max(a, b); }\n\nconst int mINF = (-1) * (int)1e9 / 2;\n\nint V, K, E, score[21][155][155], score_buf[2][155][155], dp[110][155], prv[110][155];\nvector< vector< Edge > > adj;\n\nvoid restore(int step) {\n\tmemset(dp, -1, sizeof(dp));\n\tmemset(prv, -1, sizeof(prv));\n\t\n\tfor_(v,0,V) dp[0][v] = 0;\n\t\n\tfor_(h,0,step) for_(v,0,V) {\n\t\tif (dp[h][v] == -1) continue;\n\t\t\n\t\tfor (Edge e : adj[v]) {\n\t\t\tif (dp[h + 1][e.to] < dp[h][v] + e.c) {\n\t\t\t\tdp[h + 1][e.to] = dp[h][v] + e.c;\n\t\t\t\tprv[h + 1][e.to] = v;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint max_score = 0, t = -1;\n\t\n\tfor_(v,0,V) {\n\t\tif (max_score < dp[step][v]) {\n\t\t\tmax_score = dp[step][v];\n\t\t\tt = v;\n\t\t}\n\t}\n\t\n\tvector< int > path;\n\tint c = step;\n\t\n\twhile (t != -1) {\n\t\tpath.push_back(t);\n\t\tt = prv[c][t];\n\t\t--c;\n\t}\n\t\n\treverse(path.begin(), path.end());\n\t\n\tfor_(i,0,step+1) cout << path[i] << (i < step ? \" \" : \"\\n\");\n}\n\nvoid warshall() {\n\tfor_(h,1,21) for_(u,0,V) for_(v,0,V) for_(k,0,V) {\n\t\tmaxUpdate(score[h][u][v], score[h - 1][u][k] + score[h - 1][k][v]);\n\t}\n}\n\nint calcScore(int step) {\t\n\tfor_(u,0,V) for_(v,0,V) score_buf[0][u][v] = (u == v ? 0 : mINF);\n\t\n\tfor_rev(h,20,0) {\n\t\tif (step >> h & 1) {\n\t\t\tmemset(score_buf[1], 0, sizeof(score_buf[1]));\n\t\t\t\n\t\t\tfor_(u,0,V) for_(v,0,V) for_(k,0,V) {\n\t\t\t\tmaxUpdate(score_buf[1][u][v], score_buf[0][u][k] + score[h][k][v]);\n\t\t\t\tif (score_buf[1][u][v] >= K) return score_buf[1][u][v];\n\t\t\t}\n\t\t\t\n\t\t\tfor_(u,0,V) for_(v,0,V) {\n\t\t\t\tscore_buf[0][u][v] = (score_buf[1][u][v] > 0 ? score_buf[1][u][v] : mINF);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn -1;\n}\n\nint calcMinStep() {\n\tfor_(u,0,V) for_(v,0,V) score_buf[0][u][v] = (u == v ? 0 : mINF);\n\t\n\tint res = 0;\n\t\n\tfor_rev(h,20,0) {\n\t\tmemset(score_buf[1], 0, sizeof(score_buf[1]));\n\t\t\n\t\tbool flag = false;\n\t\t\n\t\tfor_(u,0,V) for_(v,0,V) for_(k,0,V) {\n\t\t\tmaxUpdate(score_buf[1][u][v], score_buf[0][u][k] + score[h][k][v]);\n\t\t\tflag |= (score_buf[1][u][v] >= K);\n\t\t}\n\t\t\n\t\tif (!flag) {\n\t\t\tfor_(u,0,V) for_(v,0,V) {\n\t\t\t\tscore_buf[0][u][v] = (score_buf[1][u][v] > 0 ? score_buf[1][u][v] : mINF);\n\t\t\t}\n\t\t\t\n\t\t\tres += 1 << h;\n\t\t}\n\t}\n\t\n\treturn res + 1;\n}\n\nvoid solve() {\n\twarshall();\n\t\n\tfor_(step,1,101) {\n\t\tif (calcScore(step) >= K) {\n\t\t\tcout << step << endl;\n\t\t\trestore(step);\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\tint min_step = calcMinStep();\n\t\n\tcout << (min_step > (int)1e6 ? -1 : min_step) << endl;\n}\n\nint main() {\n\tcin >> V >> E >> K;\n\t\n\tfor_(h,0,21) for_(u,0,V) for_(v,0,V) score[h][u][v] = mINF;\n\t\n\tfor_(i,0,E) {\n\t\tint u, v, c;\n\t\tcin >> u >> v >> c;\n\t\tmaxUpdate(score[0][u][v], c);\n\t}\n\t\n\tadj.assign(V, vector< Edge >());\n\t\n\tfor_(u,0,V) for_(v,0,V) {\n\t\tif (score[0][u][v] > 0) adj[u].push_back(Edge{v, score[0][u][v]});\n\t}\n\t\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<int(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nconstexpr int64_t INF = INT64_C(1000000000000000000);\n\nusing Array = vector<int64_t>;\nusing Matrix = vector<Array>;\n\nMatrix mul(const Matrix& lhs, const Matrix& rhs) {\n  int r = lhs.size();\n  Matrix res(r, Array(r, -INF));\n  REP(i,r) REP(k,r) REP(j,r) {\n    res[i][j] = max(res[i][j], lhs[i][k] + rhs[k][j]);\n  }\n  return res;\n}\n\nMatrix pow(const Matrix& mat, int64_t index) {\n  if (index == 1) return mat;\n  if ((index % 2) == 1) {\n    return mul(mat, pow(mat, index-1));\n  }\n  return pow(mul(mat, mat), index/2);\n}\n\nint main() {\n  int64_t v,e,k;\n  cin>>v>>e>>k;\n  Matrix mat(v, Array(v, -INF));\n  REP(i,e) {\n    int64_t s,t,c;\n    cin>>s>>t>>c;\n    mat[s][t] = max(mat[s][t], c);\n  }\n  int64_t hi = 1;\n  Matrix m2 = mat;\n  while (true) {\n    hi *= 2;\n    m2 = mul(m2, m2);\n    int64_t mx = -INF;\n    REP(i,v)REP(j,v) mx = max(mx, m2[i][j]);\n    if (mx >= k) break;\n    if (mx <= 0) break;\n  }\n  int64_t lo = 0;\n  while (hi - lo > 1) {\n    int64_t mid = (hi + lo) / 2;\n    auto pmat = pow(mat, mid);\n    int64_t mx = -INF;\n    REP(i,v)REP(j,v) mx = max(mx, pmat[i][j]);\n    if (mx <= 0) {\n      hi = mid;\n    } else if (mx >= k) {\n      hi = mid;\n    } else {\n      lo = mid;\n    }\n  }\n  auto pmat = pow(mat, hi);\n  int64_t mx = -INF;\n  REP(i,v)REP(j,v) mx = max(mx, pmat[i][j]);\n  if (mx < k) {\n    cout << -1 << endl;\n    return 0;\n  } \n  cout << hi << endl;\n  if (hi > 100) {\n    return 0;\n  }\n  vector<Matrix> vmat;\n  Matrix m(v, Array(v, -INF));\n  REP(i,v) m[i][i] = 0;\n  REP(i,hi) {\n    vmat.push_back(m);\n    m = mul(mat, m);\n  }\n  int s=0,t=0;\n  REP(i,v)REP(j,v) {\n    if (pmat[i][j] == mx) {\n      s = i;\n      t = j;\n    }\n  }\n  vector<int> res;\n  for (int i = hi-1; i >= 0; --i) {\n    res.push_back(t);\n    int nt=0;\n    int64_t nmx=0;\n    REP(j,v) {\n      if (vmat[i][s][j] + mat[j][t] == mx) {\n        nt = j;\n        nmx = vmat[i][s][j];\n      }\n    }\n    t = nt;\n    mx = nmx;\n  }\n  cout << s;\n  reverse(ALL(res));\n  for (int r:res) cout << ' ' << r;\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nint n, m, k;\ntypedef vector<vi> M;\nM operator*(const M &a, const M &b){\n\tM c(a.size(), vi(a.size()));\n\trep(i, n) rep(j, n) c[i][j] = max(a[i][j], b[i][j]);\n\trep(l, n) rep(i, n) rep(j, n) if(a[i][l] >= 0 && b[l][j] >= 0){\n\t\tc[i][j] = max(c[i][j], a[i][l] + b[l][j]);\n\t\tif(c[i][j] >= k) c[i][j] = k;\n\t}\n\treturn c;\n}\nint dp[128][150], prev[128][150];\nvoid solve(const M &e, int it){\n\tmemset(dp, -1, sizeof(dp));\n\trep(i, n) dp[0][i] = 0;\n\tint ai, al, mx = 0;\n\trep(i, it) rep(j, n) if(dp[i][j] >= 0){\n\t\trep(l, n) if(e[j][l] >= 0 && dp[i + 1][l] < dp[i][j] + e[j][l]){\n\t\t\tdp[i + 1][l] = dp[i][j] + e[j][l];\n\t\t\tprev[i + 1][l] = j;\n\t\t\tif(dp[i + 1][l] >= k && dp[i + 1][l] > mx){\n\t\t\t\tai = i + 1; al = l; mx = dp[i + 1][l];\n\t\t\t\tgoto END;\n\t\t\t}\n\t\t}\n\t}\n\tEND:\n\tvi ans;\n\tfor(; ai >= 0; ai--){\n\t\tans.pb(al);\n\t\tif(ai > 0) al = prev[ai][al];\n\t}\n\treverse(all(ans));\n\trep(i, ans.size()) cout << ans[i] << (i == ans.size() - 1 ? \"\\n\" : \" \");\n}\nint main(){\n\tcin >> n >> m >> k;\n\tM e(n, vi(n, -1)), p(n, vi(n, -1));\n\tM pw[20];\n\t\n\trep(i, m){\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\te[a][b] = max(e[a][b], c);\n\t}\n\t\n\trep(i, n) p[i][i] = 0;\n\tpw[0] = e;\n\trep(i, 19) pw[i + 1] = pw[i] * pw[i];\n\t\n\tint ans = 0;\n\tbool can = 0;\n\tfor(int i = 19; i >= 0; i--){\n\t\tM pp = p * pw[i];\n\t\t\n\t\tbool ok = 0;\n\t\trep(j, n) rep(l, n) if(pp[j][l] >= k) ok = can = 1;\n\t\tif(!ok) p = pp, ans += 1 << i;\n\t}\n\tif(!can){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tans++;\n\tcout << ans << endl;\n\tif(ans <= 100) solve(e, ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\nint V,E,K;\nconst int INF = (1<<29);\nmat G;\n\nmat g[30];\nmat u[30];\n\nint add(int a,int b){\n  if(a==-INF||b==-INF)return -INF;\n  return min(a+b,K);\n}\n\npair<mat,mat> merge(mat A,mat B, bool flag=false){\n  mat X( V, vec(V, -INF) );\n  mat Y( V, vec(V, -INF) );\n  \n  for(int from=0;from<V;from++){\n    for(int to=0;to<V;to++){\n      for(int ex=0;ex<V;ex++){\n        int cost=add(A[from][ex],B[ex][to]);\n        if(X[from][to]<cost){\n          X[from][to]=cost;\n          Y[from][to]=ex;\n        }\n      }\n    }\n  }\n  return make_pair(X,Y);\n}\n\n\nint calc(int m,int &si,int &ti){\n  mat t;\n  for(int i=0;i<30;i++){\n    if(m>>i&1){\n      if(t.empty()){\n        t=g[i];\n      }else{\n        t=merge(t,g[i]).first;\n      }\n    }\n  }\n  \n  int res=-INF;\n  for(int i=0;i<V;i++){\n    for(int j=0;j<V;j++){\n      if(res<t[i][j]){\n        si=i;\n        ti=j;\n        res=t[i][j];\n      }\n    }\n  }\n  return res;\n}\n\nvoid Dfs(vec& s,int from,int to,int len){\n  if(len==0)return;\n  \n  for(int i=0;i<30;i++){\n    if(~len>>i&1)continue;\n    int ex=u[i][from][to];\n\n    if(i==0){\n      if(len>=2)s.push_back(ex);\n      Dfs(s,ex,to,len-1);\n    }else{\n      int sub=(1<<i)/2;\n      Dfs(s,from,ex,sub);\n      s.push_back(ex);\n      Dfs(s,ex,to,len-sub);\n    }\n    break;\n  }\n}\n\nint main(){\n\n  cin>>V>>E>>K;\n  G=mat( V, vec(V, -INF) );\n  \n  g[0]=u[0]=G;\n  for(int i=0;i<V;i++)g[0][i][i]=0;\n  \n  for(int i=0;i<E;i++){\n    int a,b,c;\n    cin>>a>>b>>c;\n    assert(a!=b);\n    G[a][b]=max(G[a][b],c);\n    \n    g[0][a][b]=max(g[0][a][b],c);\n    u[0][a][b]=b;\n  }\n\n  \n  for(int i=1;i<30;i++){\n    pair<mat,mat> temp=merge(g[i-1],g[i-1]);\n    g[i]=temp.first;\n    u[i]=temp.second;\n  }\n\n\n  int si,ti;\n  int left=1,right=K+1,mid;\n\n  while( left < right ){\n    mid=(left+right)/2;\n    if( calc(mid,si,ti) >= K ){\n      right=mid;\n    }else{\n      left=mid+1;\n    }\n  }\n\n  for(int i=0;i<V;i++)g[0][i][i]=-INF;\n  for(int i=1;i<30;i++){\n    pair<mat,mat> temp=merge(g[i-1],g[i-1]);\n    g[i]=temp.first;\n    u[i]=temp.second;\n  }\n  \n  if(left==K+1){\n    cout<<-1<<endl;\n  }else{\n    cout<<left<<endl;\n    if(left<=100){\n      vec tab;\n      tab.push_back(si);\n      Dfs(tab,si,ti,left);\n      tab.push_back(ti);\n      \n      int sum=0;\n      assert( left+1==(int)tab.size() );\n      for(int i=0;i<(int)tab.size();i++){\n        if(i>0 && G[ tab[i-1]][ tab[i] ] == -INF ){\n          assert(0);\n        }\n        if(i>0)sum+=G[ tab[i-1]][ tab[i] ];\n        if(i)cout<<' ';\n        cout<<tab[i];\n      }\n      cout<<endl;\n      assert(sum>=K);\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <vector>\n#include <valarray>\n#include <array>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <random>\n#include <bitset>\n \nusing namespace std;\ntypedef long long ll;\n\nconst ll INF = 1LL<<40;\n\nstruct Matrix {\n    typedef ll D;\n    vector<valarray<D>> d;\n    int N, M;\n    Matrix(int N, int M) : N(N), M(M) {\n        d.resize(N);\n        for (int i = 0; i < N; i++) {\n            d[i] = valarray<D>(INF, M);\n        }\n    }\n\n    valarray<D>& operator[](int p) {\n        return d[p];\n    }\n\n    const valarray<D>& operator[](int p) const {\n        return d[p];\n    }\n\n    Matrix& operator=(const Matrix &other) {\n        copy_n(other.d.begin(), N, d.begin());\n        return *this;\n    }\n\n    Matrix operator*(const Matrix &right) {\n        Matrix res(N, right.M), r(right.M, right.N);\n        for (int i = 0; i < right.M; i++) {\n            for (int j = 0; j < right.N; j++) {\n                r[i][j] = right[j][i];\n            }\n        }\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < right.M; j++) {\n                res[i][j] = min(INF, (d[i]+r[j]).min());\n            }\n        }\n        return res;\n    }\n\n    Matrix pow(ll p) {\n        Matrix res(N, M), buf = *this;\n        for (int i = 0; i < N; i++) res[i][i] = D(0);\n        while (p != 0) {\n            if (p % 2) {\n                res = res*buf;\n            }\n            buf = buf*buf;\n            p /= 2;\n        }\n        return res;\n    }\n};\n\nconst int MN = 160;\n\ntypedef tuple<int, int, ll> T;\n\nll dist[MN], dist2[MN];\nint back[110][MN];\n\nint main() {\n    int V, E; ll K;\n    cin >> V >> E >> K; V++;\n    vector<T> v;\n    for (int i = 0; i < E; i++) {\n        int a, b; ll c;\n        cin >> a >> b >> c;\n        v.push_back(T(a, b, -c));\n    }\n    for (int i = 0; i < V-1; i++) {\n        v.push_back(T(V-1, i, 0));\n    }\n\n    fill_n(dist, MN, INF);\n    dist[V-1] = 0;\n    for (int i = 0; i < 101; i++) {\n        copy_n(dist, MN, dist2);\n        for (T t: v) {\n            int a, b; ll c;\n            tie(a, b, c) = t;\n            if (dist[a] == INF) continue;\n            if (dist2[b] < dist[a]+c) continue;\n            dist2[b] = dist[a]+c;\n            back[i][b] = a;\n        }\n        copy_n(dist2, MN, dist);\n\n        int f = -1, d = 0;\n        for (int j = 0; j < V-1; j++) {\n            if (-K < dist[j]) continue;\n            if (d < dist[j]) continue;\n            d = dist[j];\n            f = j;\n        }\n        if (f == -1) continue;\n        cout << i << endl;\n        int jj = f;\n        vector<int> res;\n        res.push_back(jj);\n        for (int k = i; k > 0; k--) {\n            res.push_back(back[k][jj]);\n            jj = back[k][jj];\n        }\n        reverse(res.begin(), res.end());\n        for (int r: res) {\n            cout << r << \" \";\n        } cout << endl;\n        return 0;\n    }\n\n\n    Matrix base(V, V);\n    for (T t: v) {\n        int a, b; ll c;\n        tie(a, b, c) = t;\n        base[a][b] = min(base[a][b], c);\n    }\n\n    int l = 0, r = 1000000;\n    while (r-l > 1) {\n        int md = (l+r)/2;\n        Matrix bb = base.pow(md);\n        bool f = false;\n        for (int i = 0; i < V; i++) {\n            for (int j = 0; j < V; j++) {\n                if (bb[i][j] <= -K) {\n                    f = true;\n                }\n            }\n        }\n//        cout << md << \" \" << f << endl;\n        if (!f) {\n            l = md;\n        } else {\n            r = md;\n        }\n    }\n    if (r == 1000000) {\n        cout << -1 << endl;\n    } else {\n        cout << r << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nvoid chmin(int &x,int y){ x = min(x,y); }\nvoid chmax(int &x,int y){ x = max(x,y); }\nint n,m,s;\nint val[155][155][21];\nint c[155][155][21];\nP pre[155][155][21];\nvector<int>path[155][155][7];\nint main(){\n\tcin >> n >> m >> s;\n\tfor(int i=0;i<m;i++){\n\t\tint a,b,c; cin >> a >> b >> c;\n\t\tif(val[a][b][0]<c){val[a][b][0] = c; path[a][b][0].pb(a); path[a][b][0].pb(b); }\n\t}\n\tfor(int q=0;q<20;q++){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tif(!val[i][j][q] || !val[j][k][q]) continue;\n\t\t\t\t\tif(val[i][k][q+1]<val[i][j][q]+val[j][k][q]){\n\t\t\t\t\t\tval[i][k][q+1] = val[i][j][q]+val[j][k][q];\n\t\t\t\t\t\tif(q+1 < 7){\n\t\t\t\t\t\t\tpath[i][k][q+1].clear();\n\t\t\t\t\t\t\tfor(int ii=0;ii<path[i][j][q].size();ii++) path[i][k][q+1].pb(path[i][j][q][ii]);\n\t\t\t\t\t\t\tfor(int ii=1;ii<path[j][k][q].size();ii++) path[i][k][q+1].pb(path[j][k][q][ii]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint L = 0,R = s+1; //(L,R]\n\twhile(R-L > 1){\n\t\tint mid = (L+R)/2;\n\t\tint v[155][155][2]={};\n\t\tint cur = 0,nxt = 1;\n\t\tfor(int q=0;q<20;q++){\n\t\t\tif(!((mid>>q)&1)) continue;\n\t\t\tfor(int i=0;i<n;i++) for(int j=0;j<n;j++) v[i][j][nxt] = 0;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tfor(int k=0;k<n;k++){ if(!val[j][k][q]) continue;\n\t\t\t\t\t\tchmax(v[i][k][nxt],v[i][j][cur]+val[j][k][q]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(cur,nxt);\n\t\t}\n\t\tfor(int i=0;i<n;i++) for(int j=0;j<n;j++){\n\t\t\tif(v[i][j][cur] >= s) goto ok;\n\t\t}\n\t\tL = mid; continue; ok: R = mid;\n\t}\n\tif(R == s+1){\n\t\tputs(\"-1\"); return 0;\n\t}\n\tprintf(\"%d\\n\",R);\n\tif(R>100) return 0;\n\t\n\tvector<int>ans;\n\tint num = 0;\n\tfor(int q=0;q<20;q++){\n\t\tif(!((R>>q)&1)) continue;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tif(val[j][k][q] && c[i][k][num+1]<c[i][j][num]+val[j][k][q]){\n\t\t\t\t\t\tc[i][k][num+1] = c[i][j][num]+val[j][k][q];\n\t\t\t\t\t\tpre[i][k][num+1] = mp(j,q);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnum++;\n\t}\n\tint S,G,MX = 0;\n\tfor(int i=0;i<n;i++) for(int j=0;j<n;j++){\n\t\tif(MX < c[i][j][num]){\n\t\t\tMX = c[i][j][num]; S = i; G = j;\n\t\t}\n\t}\n\tans.pb(G);\n\twhile(num){\n\t\t//val[pre[S][G][num].fi][G][pre[S][G][num].sc]\n\t\tint a = pre[S][G][num].fi, b = pre[S][G][num].sc; //cout << a << \" \" << b << endl;\n\t\tfor(int i=path[a][G][b].size()-2;i>=0;i--) ans.pb(path[a][G][b][i]);\n\t\tG = a; num--;\n\t}\n\treverse(ans.begin(),ans.end());\n\tfor(int i=0;i<ans.size();i++){\n\t\tprintf(\"%d \",ans[i]);\n\t}\n\tputs(\"\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcountll\n\n#define INF INT_MAX/3\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\nmat operator*(const mat& a,const mat& b){\n  int n=a.size();\n  mat res(n,vec(n,-INF));\n  rep(k,n)rep(i,n)rep(j,n){\n    maxch(res[i][j],a[i][j]); maxch(res[i][j],b[i][j]);\n    if(a[i][k]==-INF||b[k][j]==-INF)continue;\n    maxch(res[i][j],a[i][k]+b[k][j]);\n  }\n  return res;\n}\n\nvector<mat> p2;\n\nmat pow(int sz,int n){\n  mat res(sz,vec(sz,0));\n  rep(i,20){\n    if((n>>i)&1)res=res*p2[i];\n  }\n  return res;\n}\n\nint N,M,K;\n\nsigned main(){\n  scanf(\"%d%d%d\",&N,&M,&K);\n  mat d(N,vec(N,-INF));\n  rep(i,M){\n    int a,b,c;\n    scanf(\"%d%d%d\",&a,&b,&c);\n    maxch(d[a][b],c);\n  }\n\n  mat cm=d;\n  rep(i,20){\n    p2.push_back(cm); cm=cm*cm;\n  }\n\n  int maxl=K;\n  int lb=0,ub=K+1;\n  while(ub-lb>1){\n    int X=(ub+lb)/2;\n    mat tmp=pow(N,X);\n    bool ok=false,dame=true;\n    rep(i,N){\n      rep(j,N){\n        if(tmp[i][j]>=0)dame=false;\n        if(tmp[i][j]>=K){\n          ok=true; break;\n        }\n      }\n      if(ok)break;\n    }\n    if(dame){\n      ub=X; maxl=X-1;\n      continue;\n    }\n    if(ok)ub=X;\n    else lb=X;\n  }\n\n  if(ub==maxl+1) cout<<-1<<endl;\n  else cout<<ub<<endl;\n\n  if(ub<=100&&ub<=maxl){\n    vector<mat> ms;\n    mat crt(N,vec(N,-INF));\n    rep(i,N)crt[i][i]=0;\n    ms.push_back(crt);\n    rep(i,ub){\n      crt=crt*d;\n      ms.push_back(crt);\n    }\n    int s=-1,t=-1,mx=0;\n    rep(i,N)rep(j,N)if(crt[i][j]>=K&&crt[i][j]>mx){\n      s=i; t=j; mx=crt[i][j];\n    }\n    vector<int> res;\n    res.push_back(t);\n    for(int i=ms.size()-1;i>0;i--){\n      rep(j,N){\n        if(j==t)continue;\n        if(ms[i-1][s][j]+d[j][t]==ms[i][s][t]){\n          t=j; break;\n        }\n      }\n      res.push_back(t);\n    }\n    reverse(all(res));\n    cout<<res[0];\n    repl(i,1,res.size())cout<<\" \"<<res[i];\n    cout<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 151;\n\ntemplate<typename T> class mat : public vector<vector<T> > {\nprivate:\n    int r,c;    //行,列\npublic:\n    int row() const {\n        return r;\n    }\n    int column() const {\n        return c;\n    }\n    mat(int n,int m,T val = 0){\n        this->r = n,this->c = m;\n        rep(i,n){\n            this->push_back(vector<T>(m,val));\n        }\n    }\n    mat operator+(const mat& another){\n        if(this->r != another.r && this->c != another.c){\n            cout << \"足し算失敗(サイズ不一致)\" << endl;\n            exit(1);\n        }\n        mat<T> X(this->r,this->c);\n        rep(i,this->r){\n            rep(j,this->c){\n                X[i][j] = (*this)[i][j] + another[i][j];\n            }\n        }\n        return X;\n    }\n    mat operator+(const T val){\n        mat<T> X(this->r,this->c);\n        rep(i,this->r){\n            rep(j,this->c){\n                X[i][j] = (*this)[i][j] + val;\n            }\n        }\n        return X;\n    }\n    mat operator-(const mat& another){\n        if(this->r != another.r && this->c != another.c){\n            cout << \"引き算失敗(サイズ不一致)\" << endl;\n            exit(1);\n        }\n        mat<T> X(this->r,this->c);\n        rep(i,this->r){\n            rep(j,this->c){\n                X[i][j] = (*this)[i][j] - another[i][j];\n            }\n        }\n        return X;\n    }\n    mat operator-(const T val){\n        mat<T> X(this->r,this->c);\n        rep(i,this->r){\n            rep(j,this->c){\n                X[i][j] = (*this)[i][j] - val;\n            }\n        }\n        return X;\n    }\n    vector<T> operator*(const vector<T>& another){\n        if(this->c != (int)another.size()){\n            cout << \"掛け算失敗(サイズ不一致)\" << endl;\n            exit(1);\n        }\n        vector<T> vec(this->r,0);\n        rep(i,this->r){\n            rep(j,this->c){\n                vec[i] += (*this)[i][j] * another[j];\n            }\n        }\n        return vec;\n    }\n    mat operator*(const mat& another){\n        if(this->c != another.r){\n            cout << \"掛け算失敗(サイズ不一致)\" << endl;\n            exit(1);\n        }\n        mat<T> X(this->r,another.c);\n        rep(i,this->r){\n            rep(k,this->c){\n                rep(j,another.c){\n\t\t\t\t\tif((*this)[i][k] && another[k][j]){\n\t\t\t\t\t\tcmx(X[i][j],(*this)[i][k]+another[k][j]);\n\t\t\t\t\t}\n                }\n            }\n        }\n        return X;\n    }\n    mat operator-(){\n        mat<T> X(this->r,this->c);\n        rep(i,this->r){\n            rep(j,this->c){\n                X[i][j] = -(*this)[i][j];\n            }\n        }\n        return X;\n    }\n    void print(){\n        rep(i,this->r){\n            rep(j,(this->c)-1){\n                cout << (*this)[i][j] << \",\";\n            }\n            cout << (*this)[i][(this->c)-1] << endl;\n        }\n    }\n};\n\ntemplate<typename T> mat<T> pow(mat<T> A,ll cnt)\n{\n    if(A.row() != A.column()){\n        cout << \"累乗不可\" << endl;\n    }\n\tmat<T> B = A;\n\t--cnt;\n\twhile(cnt>0){\n\t\tif(cnt & 1){\n\t\t\tB = B*A;\n\t\t}\n\t\tA = A*A;\n\t\tcnt >>= 1;\n\t}\n\treturn B;\n}\n\nstruct edge{\n\tint to,cost;\n};\n\nvector<edge> G[MAX_N];\n\nbool possible(mat<int>& A,const int cri,const int K)\n{\n\tint n = A.row();\n\tmat<int> res = pow(A,cri);\n\tint mx = 0;\n\trep(i,n){\n\t\trep(j,n){\n\t\t\tcmx(mx,res[i][j]);\n\t\t}\n\t}\n\treturn (mx >= K);\n}\n\nint mx[101][151];\nint pre[101][151];\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n,m,K;\n\tcin >> n >> m >> K;\n\tmat<int> A(n,n);\n\trep(i,m){\n\t\tint a,b,c;\n\t\tcin >> a >> b >> c;\n\t\tcmx(A[a][b],c);\n\t}\n\trep(i,n){\n\t\trep(j,n){\n\t\t\tif(A[i][j]){\n\t\t\t\tG[i].pb((edge){j,A[i][j]});\n\t\t\t}\n\t\t}\n\t}\n\tif(!possible(A,K,K)){\n\t\tcout << \"-1\\n\";\n\t\treturn 0;\n\t}\n\tint l = 0,r = K;\n\twhile(r-l>1){\n\t\tint mid = (l+r)/2;\n\t\tif(possible(A,mid,K)){\n\t\t\tr = mid;\n\t\t}else{\n\t\t\tl = mid;\n\t\t}\n\t}\n\tcout << r << \"\\n\";\n\tif(r > 100){\n\t\treturn 0;\n\t}\n\tr++;\n\trep(i,r){\n\t\trep(j,n){\n\t\t\teach(e,G[j]){\n\t\t\t\tif(mx[i+1][e.to] < mx[i][j] + e.cost){\n\t\t\t\t\tmx[i+1][e.to] = mx[i][j] + e.cost;\n\t\t\t\t\tpre[i+1][e.to] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint cri = *max_element(mx[r],mx[r]+n);\n\tvector<int> ans;\n\trep(i,n){\n\t\tif(mx[r][i] == cri){\n\t\t\tint nw;\n\t\t\tfor(int j=r;j>=1;j--){\n\t\t\t\tnw = pre[j][nw];\n\t\t\t\tans.pb(nw);\n\t\t\t}\n\t\t\treverse(all(ans));\n\t\t\teach(it,ans){\n\t\t\t\tcout << it << \" \";\n\t\t\t}\n\t\t\tcout << \"\\n\";\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\nint V,E,K;\nconst int INF = (1<<29);\nmat G;\n\nmat g[30];\nmat u[30];\n\nint add(int a,int b){\n  if(a==-INF||b==-INF)return -INF;\n  return min(a+b,INF);\n}\n\npair<mat,mat> merge(mat A,mat B, bool flag=false){\n  mat X( V, vec(V, -INF) );\n  mat Y( V, vec(V, -INF) );\n  \n  for(int from=0;from<V;from++){\n    for(int to=0;to<V;to++){\n      for(int ex=0;ex<V;ex++){\n        int cost=add(A[from][ex],B[ex][to]);\n        if(X[from][to]<cost){\n          X[from][to]=cost;\n          Y[from][to]=ex;\n        }\n      }\n    }\n  }\n  return make_pair(X,Y);\n}\n\n\nint calc(int m,int &si,int &ti){\n  mat t;\n  for(int i=0;i<30;i++){\n    if(m>>i&1){\n      if(t.empty()){\n        t=g[i];\n      }else{\n        t=merge(t,g[i]).first;\n      }\n    }\n  }\n  \n  int res=-INF;\n  for(int i=0;i<V;i++){\n    for(int j=0;j<V;j++){\n      if(res<t[i][j]){\n        si=i;\n        ti=j;\n        res=t[i][j];\n      }\n    }\n  }\n  return res;\n}\n\nvoid Dfs(vec& s,int from,int to,int len){\n  if(len<=1)return;\n  if(len==(len&-len)){\n\n    for(int i=0;i<30;i++){\n      if(len>>i&1){\n        int ex=u[i][from][to];\n        Dfs(s,from,ex,len/2);\n        s.push_back(ex);\n        Dfs(s,ex,to,len/2);\n        return;\n      }\n    }\n  }\n  \n  mat t=mat( V, vec(V,-INF) );\n  for(int i=0;i<V;i++)t[i][i]=0;\n  \n  int ex=-1;\n  int sub=-1;\n  \n  for(int i=0;i<30;i++){\n    if(~len>>i&1)continue;\n    pair<mat,mat> tmp=merge(t, g[i]);\n    ex=tmp.second[from][to];\n    sub=(1<<i);\n  }\n\n  Dfs(s,from,ex,sub);\n  s.push_back(ex);\n  Dfs(s,ex,to,len-sub);\n}\n\nint main(){\n  cin>>V>>E>>K;\n  G=mat( V, vec(V, -INF) );\n  g[0]=u[0]=G;\n  for(int i=0;i<V;i++)g[0][i][i]=0;\n  for(int i=0;i<E;i++){\n    int a,b,c;\n    cin>>a>>b>>c;\n    G[a][b]=max(G[a][b],c);\n    if(g[0][a][b]<c){\n      g[0][a][b]=c;\n      u[0][a][b]=b;\n    }\n  }\n  \n  for(int i=1;i<30;i++){\n    pair<mat,mat> temp=merge(g[i-1],g[i-1]);\n    g[i]=temp.first;\n    u[i]=temp.second;\n  }\n  int left=1,right=K+1,mid,si,ti;\n  while( left < right ){\n    mid=(left+right)/2;\n    if( calc(mid,si,ti) >= K ){\n      right=mid;\n    }else{\n      left=mid+1;\n    }\n  }\n\n  for(int i=0;i<V;i++)g[0][i][i]=-INF;\n  for(int i=1;i<30;i++){\n    pair<mat,mat> temp=merge(g[i-1],g[i-1]);\n    g[i]=temp.first;\n    u[i]=temp.second;\n  }\n  \n  if(left==K+1){\n    cout<<-1<<endl;\n  }else{\n    cout<<left<<endl;\n    if(left<=100){\n      vec tab;\n      tab.push_back(si);\n      Dfs(tab,si,ti,left);\n      tab.push_back(ti);\n\n      int sum=0;\n      for(int i=0;i<(int)tab.size();i++){\n\n        \n        if(i>0){\n          int cost=G[ tab[i-1] ][ tab[i] ];\n          if(cost == -INF ){\n            assert(0);\n          }else{\n            sum=add(sum,cost);\n          }\n        }\n        \n        if(i)cout<<' ';\n        cout<<tab[i];\n      }\n      cout<<endl;\n      assert( sum >= K );\n    }\n  }\n  return 0;\n}\n\n  \n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int logMaxStep = 30;\n\ntypedef long long ll;\ntypedef vector< vector<ll> > Graph;\n\nint GetLogStep(int S) {\n\tint res;\n\tfor (res = 0; (1 << res) <= S; ++res);\n\treturn res;\n}\nGraph nextG(const Graph& g1, const Graph& g2) {\n\tint N = g1.size();\n\tGraph res(N, vector<ll>(N, 0));\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tfor (int k = 0; k < N; ++k) {\n\t\t\t\tif (g1[i][k] > 0 && g2[k][j] > 0) {\n\t\t\t\t\tres[i][j] = max(res[i][j], g1[i][k]+g2[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nvector<int> nextDP(vector<ll>& dp, Graph& g) {\n\tint N = g.size();\n\tvector<int> prevV(N, -1);\n\tvector<ll> ndp(N, -1);\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tif (dp[i] >= 0 && g[i][j] > 0) {\n\t\t\t\tif (dp[i]+g[i][j] > ndp[j]) {\n\t\t\t\t\tndp[j] = dp[i]+g[i][j];\n\t\t\t\t\tprevV[j] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tdp[i] = ndp[i];\n\t}\n\treturn prevV;\n}\nll GetMaxScore(vector<Graph>& powG, int S) {\n\tint N = powG[0].size();\n\tint logS = GetLogStep(S);\n\tvector<ll> dp(N, 0);\n\tfor (int i = 0; i < logS; ++i) {\n\t\tGraph& g = powG[i];\n\t\tif ( (1 << i) & S ) {\n\t\t\tnextDP(dp, g);\n\t\t}\n\t}\n\tll res = -1;\n\tfor (int i = 0; i < dp.size(); ++i) {\n\t\tres = max(res, dp[i]);\n\t}\n\treturn res;\n}\nbool check200Step(Graph& G, int K) {\n\tint N = G.size();\n\tvector<ll> dp(N, 0);\n\tvector< vector<int> > prevV;\n\tfor (int t = 0; t < 200; ++t) {\n\t\tprevV.push_back( nextDP(dp, G) );\n\t\tint aid = 0;\n\t\tfor (int i = 0; i < dp.size(); ++i) {\n\t\t\tif (dp[i] > dp[aid]) aid = i;\n\t\t}\n\t\tif (dp[aid] >= K) {\n\t\t\tcout << t+1 << endl;\n\t\t\tif (t+1 <= 100) {\n\t\t\t\tvector<int> vl;\n\t\t\t\tint v = aid; vl.push_back(v);\n\t\t\t\tfor (int i = t; i >= 0; --i) {\n\t\t\t\t\tv = prevV[i][v];\n\t\t\t\t\tvl.push_back(v);\n\t\t\t\t}\n\t\t\t\treverse(vl.begin(), vl.end());\n\t\t\t\tfor (int i = 0; i < vl.size(); ++i) {\n\t\t\t\t\tif (i) cout << \" \";\n\t\t\t\t\tcout << vl[i];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint main() {\n\tint N, E, K; cin >> N >> E >> K;\n\tGraph G(N, vector<ll>(N, 0));\n\tfor (int i = 0; i < E; ++i) {\n\t\tint a, b; ll c; cin >> a >> b >> c;\n\t\tG[a][b] = max(G[a][b], c);\n\t}\n\tif ( !check200Step(G, K) ) {\n\t\tvector<Graph> powG(logMaxStep+1); powG[0] = G;\n\t\tfor (int i = 0; i < logMaxStep; ++i) {\n\t\t\tpowG[i+1] = nextG(powG[i], powG[i]);\n\t\t}\n\n\t\tint l = 0, r = K+1;\n\t\tfor (int t = 0; t < logMaxStep; ++t) {\n\t\t\tint m = (l + r) / 2;\n\t\t\tif ( GetMaxScore(powG, m) >= K ) {\n\t\t\t\tr = m;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tl = m;\n\t\t\t}\n\t\t}\n\t\tif (r > K) {\n\t\t\tcout << -1 << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << r << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing i64 = long long;\n\nconst i64 MOD = 1e9 + 7;\nconst i64 INF = i64(1e18) + 7;\n\n\ntemplate <typename T>\nbool chmin(T& x, T y){\n    if(x > y){\n        x = y;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool chmax(T& x, T y){\n    if(x < y){\n        x = y;\n        return true;\n    }\n    return false;\n}\n\n\ntemplate <typename T>\nstruct Matrix{\n    static i64 k_;\n    int h, w;\n    vector<T> v;\n\n    Matrix() : h(1), w(1), v(1, 1){}\n    Matrix(int h, int w) : h(h), w(w), v(h * w, -INF){}\n\n    Matrix(vector<vector<T>> v_) : h(v_.size()), w(v_[0].size()), v(h * w){\n        for(int i = 0; i < h; ++i)\n            for(int j = 0; j < w; ++j)\n                v[i * w + j] = v_[i][j];\n    }\n\n    static Matrix makeUnit(int n){\n        Matrix mat(n, n);\n        for(int i = 0; i < n; ++i)\n            mat.v[i * n + i] = 0;\n        return mat;\n    }\n\n    Matrix pow(i64 x){\n        assert(h == w);\n        auto mat = x & 1 ? *this : makeUnit(h);\n        auto u = *this;\n        while(u = u * u, x >>= 1)\n            if(x & 1)\n                mat *= u;\n        return mat;\n    }\n\n    Matrix operator*(const Matrix& mat){\n        assert(w == mat.h);\n        Matrix ret(h, mat.w);\n        for(int i = 0; i < h; ++i)\n            for(int k = 0; k < w; ++k)\n                for(int j = 0; j < mat.w; ++j){\n                    if(v[i * w + k] < 0 || mat.v[k * mat.w + j] < 0)\n                        continue;\n                    chmax(ret.v[i * mat.w + j], v[i * w + k] + mat.v[k * mat.w + j]);\n                    chmin(ret.v[i * mat.w + j], k_);\n                }\n        return ret;\n    }\n\n    Matrix& operator*=(const Matrix& mat){return *this = *this * mat;}\n};\n\n\ntemplate<> i64 Matrix<i64>::k_ = 0;\n\n\nsigned main(){\n    int n, m, k;\n    cin >> n >> m >> k;\n    vector<int> a(m), b(m), c(m);\n    for(int i = 0; i < m; ++i)\n        cin >> a[i] >> b[i] >> c[i];\n\n    vector<vector<int>> dp(n, vector<int>(101, -MOD));\n    vector<vector<int>> prev(n, vector<int>(101, -1));\n    for(int i = 0; i < n; ++i)\n        dp[i][0] = 0;\n\n    for(int j = 0; j < 100; ++j){\n        int ma = 0;\n        int ma_idx = 0;\n        for(int i = 0; i < m; ++i){\n            int from = a[i];\n            int to = b[i];\n            int cost = c[i];\n            if(chmax(dp[to][j + 1], dp[from][j] + cost)){\n                prev[to][j + 1] = from;\n            }\n            if(chmax(ma, dp[to][j + 1])){\n                ma_idx = to;\n            }\n        }\n        if(ma >= k){\n            int p = ma_idx;\n            int q = j + 1;\n            vector<int> v{p};\n            while(q){\n                p = prev[p][q];\n                v.push_back(p);\n                --q;\n            }\n            cout << j + 1 << endl;\n            reverse(v.begin(), v.end());\n            for(int i = 0; i < v.size(); ++i)\n                cout << v[i] << \" \\n\"[i == v.size() - 1];\n            return 0;\n        }\n    }\n\n    vector<vector<i64>> v(n, vector<i64>(n, -INF));\n    for(int i = 0; i < n; ++i)\n        v[i][i] = 0;\n    for(int i = 0; i < m; ++i){\n        chmax(v[a[i]][b[i]], 1LL * c[i]);\n    }\n\n    Matrix<i64>::k_ = k;\n\n    auto f = [&](i64 val){\n        auto mat = Matrix<i64>(v).pow(val);\n        return *max_element(mat.v.begin(), mat.v.end()) >= k;\n    };\n\n    i64 ng = 0, ok = k + 1;\n    while(ok - ng > 1){\n        i64 mid = (ok + ng) / 2;\n        (f(mid) ? ok : ng) = mid;\n    }\n\n    if(ok == k + 1){\n        cout << -1 << endl;\n        return 0;\n    }\n    cout << ok << endl;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\nint V,E,K;\nconst int INF = (1<<30);\nmat G;\n\nmat g[30];\nmat u[30];\n\nint add(int a,int b){\n  if(a==-INF||b==-INF)return -INF;\n  return min(a+b,K);\n}\n\npair<mat,mat> merge(mat A,mat B, bool flag=false){\n  mat X( V, vec(V, -INF) );\n  mat Y( V, vec(V, -INF) );\n  \n  for(int from=0;from<V;from++){\n    for(int to=0;to<V;to++){\n      for(int ex=0;ex<V;ex++){\n        int cost=add(A[from][ex],B[ex][to]);\n        if(X[from][to]<cost){\n          X[from][to]=cost;\n          Y[from][to]=ex;\n        }\n      }\n    }\n  }\n  return make_pair(X,Y);\n}\n\n\nint calc(int m,int &si,int &ti){\n  mat t;\n  for(int i=0;i<30;i++){\n    if(m>>i&1){\n      if(t.empty()){\n        t=g[i];\n      }else{\n        t=merge(t,g[i]).first;\n      }\n    }\n  }\n  \n  int res=-INF;\n  for(int i=0;i<V;i++){\n    for(int j=0;j<V;j++){\n      if(res<t[i][j]){\n        si=i;\n        ti=j;\n        res=t[i][j];\n      }\n    }\n  }\n  return res;\n}\n\nvoid Dfs(vec& s,int from,int to,int len){\n  if(len==0)return;\n  \n  for(int i=0;i<30;i++){\n    if(~len>>i&1)continue;\n    int ex=u[i][from][to];\n\n    if(i==0){\n      if(len>=2)s.push_back(ex);\n      Dfs(s,ex,to,len-1);\n    }else{\n      int sub=(1<<i)/2;\n      Dfs(s,from,ex,sub);\n      s.push_back(ex);\n      Dfs(s,ex,to,len-sub);\n    }\n    break;\n  }\n}\n\nint main(){\n  cin>>V>>E>>K;\n  G=mat( V, vec(V, -INF) );\n  for(int i=0;i<V;i++)G[i][i]=0;\n  \n  g[0]=u[0]=G;\n  for(int i=0;i<E;i++){\n    int a,b,c;\n    cin>>a>>b>>c;\n    G[a][b]=max(G[a][b],c);\n    \n    g[0][a][b]=max(g[0][a][b],c);\n    u[0][a][b]=b;\n  }\n\n  \n  for(int i=1;i<30;i++){\n    pair<mat,mat> temp=merge(g[i-1],g[i-1]);\n    g[i]=temp.first;\n    u[i]=temp.second;\n  }\n\n\n  int si,ti;\n  int left=1,right=K+1,mid;\n\n  while( left < right ){\n    mid=(left+right)/2;\n    if( calc(mid,si,ti) >= K ){\n      right=mid;\n    }else{\n      left=mid+1;\n    }\n  }\n\n  for(int i=0;i<V;i++)g[0][i][i]=-INF;\n  for(int i=1;i<30;i++){\n    pair<mat,mat> temp=merge(g[i-1],g[i-1]);\n    g[i]=temp.first;\n    u[i]=temp.second;\n  }\n  \n  if(left==K+1){\n    cout<<-1<<endl;\n  }else{\n    cout<<left<<endl;\n    if(left<=100){\n      vec tab;\n      tab.push_back(si);\n      Dfs(tab,si,ti,left);\n      tab.push_back(ti);\n      //      cout<<tab.size()<<endl;\n      for(int i=0;i<(int)tab.size();i++){\n        if(i>0 && G[ tab[i-1]][ tab[i] ] == -INF ){\n          assert(0);\n        }\n        if(i)cout<<' ';\n        cout<<tab[i];\n      }\n      cout<<endl;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\ntypedef long long int Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\n\nbool operator < (const Edge &e, const Edge &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<vector<pair<vector<int>, long long int>>>type;\nint V, E, K;\n type time(const type&lts, const type&rts, const bool flag) {\n\ttype squs(V,vector<pair<vector<int>,long long int>>(V));\n\tfor (int i = 0; i < V; ++i) {\n\t\tfor (int j = 0; j < V; ++j) {\n\t\t\tif (i == j)squs[i][j] = make_pair(vector<int>(), 0ll);\n\t\t\telse squs[i][j] = make_pair(vector<int>(), static_cast<long long>(-1e17));\n\t\t}\n\t}\n\tlong long int amax = 0;\n\tfor (int k = 0; k < V; ++k) {\n\t\tfor (int i = 0; i < V; ++i) {\n\t\t\tfor (int j = 0; j < V; ++j) {\n\t\t\t\tif (squs[i][j].second <lts[i][k].second + rts[k][j].second) {\n\t\t\t\t\tsqus[i][j].second = lts[i][k].second + rts[k][j].second;\n\t\t\t\t\tamax = max(amax, squs[i][j].second);\n\t\t\t\t\tif (flag) {\n\t\t\t\t\t\tsqus[i][j].first.clear();\n\t\t\t\t\t\tsqus[i][j].first.insert(squs[i][j].first.end(), lts[i][k].first.begin(), lts[i][k].first.end());\n\t\t\t\t\t\tsqus[i][j].first.insert(squs[i][j].first.end(), rts[k][j].first.begin(), rts[k][j].first.end());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn squs;\n}\ntype square(const type&ts,bool flag) {\n\tconst type lts(ts);\n\tconst type rts(ts);\n\treturn time(lts, rts, flag);\n}\n\ntype power(const type&ts,const long long  int num,const bool flag) {\n\tassert(num);\n\tif (num == 1)return ts;\n\telse {\n\t\ttype pot(square(power(ts,num/2,flag),flag));\n\t\tif (num % 2) {\n\t\t\tpot = time(pot, ts, flag);\n\t\t}\n\t\treturn pot;\n\t}\n}\nvector<int>ans;\nbool check(const type &ts,const long long int run,const int point,const bool flag) {\n\t\n\ttype t(power(ts, run, flag&&run <= 100));\n\tlong long int amax = 0;\n\tfor (int i = 0; i < V; ++i) {\n\t\tfor (int j = 0; j < V; ++j) {\n\t\t\tif (amax < t[i][j].second) {\n\t\t\t\tamax = t[i][j].second;\n\t\t\t\tif (run <= 100&&flag) {\n\t\t\t\t\t\n\t\t\t\t\tans = t[i][j].first;\n\t\t\t\t\tans.insert(ans.begin(), i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (amax >= point)return true;\n\telse return false;\n}\n\nint main() { cin >> V >> E >> K;\n\ttype times(V, vector<pair<vector<int>,long long int>>(V, make_pair(vector<int>(),static_cast<long long int>(-1e18))));\n\tfor (int i = 0; i < E; ++i) {\n\t\tlong long int a, b, c; cin >> a >> b >> c;\n\n\t\ttimes[a][b].second = max(times[a][b].second, c);\n\t\ttimes[a][b].first = vector<int>(1,b);\n\t}\n\tfor (int i = 0; i < V; ++i) {\n\t\ttimes[i][i] = make_pair(vector<int>(1,i),0);\n\t\t\n\t}\n\tlong long int amin = 1;\n\tlong long int amax = 1e9;\n\twhile (amin + 1 != amax) {\n\t\tlong long int amid((amin + amax) / 2);\n\t\tif (check(times,amid, K,false)) {\n\t\t\tamax = amid;\n\t\t}\n\t\telse {\n\t\t\tamin = amid;\n\t\t}\n\t}\n\tif (amax > 1e8) {\n\t\tcout << -1 << endl;\n\t}\n\telse {\n\t\tcheck(times, amax, K,true);\n\t\tcout << amax << endl;\n\t\tif (amax <= 100) {\n\t\t\tfor (int i = 0; i < ans.size(); ++i) {\n\t\t\t\tcout << ans[i];\n\t\t\t\tif (i != ans.size() - 1)cout << \" \";\n\t\t\t\telse cout << endl;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<int(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nconstexpr int64_t INF = INT64_C(1000000000000000000);\n\nusing Array = vector<int64_t>;\nusing Matrix = vector<Array>;\n\nMatrix mul(const Matrix& lhs, const Matrix& rhs) {\n  int r = lhs.size();\n  Matrix res(r, Array(r, -INF));\n  REP(i,r) REP(k,r) REP(j,r) {\n    res[i][j] = max(res[i][j], lhs[i][k] + rhs[k][j]);\n  }\n  return res;\n}\n\nMatrix pow(const Matrix& mat, int64_t index) {\n  if (index == 1) return mat;\n  if ((index % 2) == 1) {\n    return mul(mat, pow(mat, index-1));\n  }\n  return pow(mul(mat, mat), index/2);\n}\n\nint main() {\n  int64_t v,e,k;\n  cin>>v>>e>>k;\n  Matrix mat(v, Array(v, -INF));\n  REP(i,e) {\n    int64_t s,t,c;\n    cin>>s>>t>>c;\n    mat[s][t] = max(mat[s][t], c);\n  }\n  vector<Matrix> vmat;\n  Matrix m(v, Array(v, -INF));\n  REP(i,v) m[i][i] = 0;\n  vmat.push_back(m);\n  REP(i,v) {\n    m = mul(mat, m);\n    vmat.push_back(m);\n  }\n  int64_t mx = -INF;\n  int64_t hi = k;\n  REP(idx,v)REP(i,v)REP(j,v) {\n    if (vmat[idx+1][i][j] >= k) {\n      if (idx < hi) {\n        hi = idx;\n        mx = max(mx, vmat[idx+1][i][j]);\n      }\n    }\n  }\n  if (mx < k) {\n    hi = k;\n    int64_t lo = v;\n    while (hi - lo > 1) {\n      int64_t mid = (hi + lo) / 2;\n      auto pmat = pow(mat, mid);\n      int64_t mx = -INF;\n      REP(i,v)REP(j,v) mx = max(mx, pmat[i][j]);\n      if (mx < 0) {\n        hi = mid;\n      } else if (mx >= k) {\n        hi = mid;\n      } else {\n        lo = mid;\n      }\n    }\n  }\n  auto pmat = pow(mat, hi);\n  mx = -INF;\n  REP(i,v)REP(j,v) mx = max(mx, pmat[i][j]);\n  if (mx < k) {\n    cout << -1 << endl;\n    return 0;\n  } \n  cout << hi << endl;\n  if (hi > 100) {\n    return 0;\n  }\n  FOR(i,v,hi) {\n    m = mul(mat, m);\n    vmat.push_back(m);\n  }\n  int s=0,t=0;\n  REP(i,v)REP(j,v) {\n    if (pmat[i][j] == mx) {\n      s = i;\n      t = j;\n    }\n  }\n  vector<int> res;\n  res.push_back(t);\n  for (int i = hi-1; i >= 0; --i) {\n    int nt=0;\n    int64_t nmx=0;\n    REP(j,v) {\n      if (vmat[i][s][j] + mat[j][t] == mx) {\n        nt = j;\n        nmx = vmat[i][s][j];\n      }\n    }\n    t = nt;\n    mx = nmx;\n    res.push_back(t);\n  }\n  reverse(ALL(res));\n  REP(i,res.size()) {\n    if (i) cout << ' ';\n    cout << res[i];\n  }\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\nint V,E,K;\nconst int INF = (1<<29);\nmat G;\n\nmat g[30];\nmat u[30];\n\nint add(int a,int b){\n  if(a==-INF||b==-INF)return -INF;\n  return min(a+b,K);\n}\n\npair<mat,mat> merge(mat A,mat B, bool flag=false){\n  mat X( V, vec(V, -INF) );\n  mat Y( V, vec(V, -INF) );\n  \n  for(int from=0;from<V;from++){\n    for(int to=0;to<V;to++){\n      for(int ex=0;ex<V;ex++){\n        int cost=add(A[from][ex],B[ex][to]);\n        if(X[from][to]<cost){\n          X[from][to]=cost;\n          Y[from][to]=ex;\n        }\n      }\n    }\n  }\n  return make_pair(X,Y);\n}\n\n\nint calc(int m,int &si,int &ti){\n  mat t;\n  for(int i=0;i<30;i++){\n    if(m>>i&1){\n      if(t.empty()){\n        t=g[i];\n      }else{\n        t=merge(t,g[i]).first;\n      }\n    }\n  }\n  \n  int res=-INF;\n  for(int i=0;i<V;i++){\n    for(int j=0;j<V;j++){\n      if(res<t[i][j]){\n        si=i;\n        ti=j;\n        res=t[i][j];\n      }\n    }\n  }\n  return res;\n}\n\nvoid Dfs(vec& s,int from,int to,int len){\n  if(len==0)return;\n  \n  for(int i=0;i<30;i++){\n    if(~len>>i&1)continue;\n    int ex=u[i][from][to];\n\n    if(i==0){\n      if(len>=2)s.push_back(ex);\n      Dfs(s,ex,to,len-1);\n    }else{\n      int sub=(1<<i)/2;\n      Dfs(s,from,ex,sub);\n      s.push_back(ex);\n      Dfs(s,ex,to,len-sub);\n    }\n    break;\n  }\n}\n\nint main(){\n\n  cin>>V>>E>>K;\n  G=mat( V, vec(V, -INF) );\n  \n  g[0]=u[0]=G;\n  for(int i=0;i<V;i++)g[0][i][i]=0;\n  \n  for(int i=0;i<E;i++){\n    int a,b,c;\n    cin>>a>>b>>c;\n    assert(a!=b);\n    G[a][b]=max(G[a][b],c);\n    \n    g[0][a][b]=max(g[0][a][b],c);\n    u[0][a][b]=b;\n  }\n\n  \n  for(int i=1;i<30;i++){\n    pair<mat,mat> temp=merge(g[i-1],g[i-1]);\n    g[i]=temp.first;\n    u[i]=temp.second;\n  }\n  \n  int si,ti;\n  int left=1,right=K+1,mid;\n\n  while( left < right ){\n    mid=(left+right)/2;\n    if( calc(mid,si,ti) >= K ){\n      right=mid;\n    }else{\n      left=mid+1;\n    }\n  }\n  /*\n  for(int i=0;i<V;i++)g[0][i][i]=-INF;\n  for(int i=1;i<30;i++){\n    pair<mat,mat> temp=merge(g[i-1],g[i-1]);\n    g[i]=temp.first;\n    u[i]=temp.second;\n  }\n  */\n  calc(left,si,ti);\n  \n  if(left==K+1){\n    cout<<-1<<endl;\n  }else{\n    cout<<left<<endl;\n    if(left<=100){\n      vec tab;\n      tab.push_back(si);\n      Dfs(tab,si,ti,left);\n      tab.push_back(ti);\n      \n      int sum=0;\n      assert( left+1==(int)tab.size() );\n      for(int i=0;i<(int)tab.size();i++){\n        if(i>0 && G[ tab[i-1]][ tab[i] ] == -INF ){\n          assert(0);\n        }\n        if(i>0)sum+=G[ tab[i-1]][ tab[i] ];\n        if(i)cout<<' ';\n        cout<<tab[i];\n      }\n      cout<<endl;\n      assert(sum>=K);\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 151;\n\ntemplate<typename T> class mat : public vector<vector<T> > {\nprivate:\n    int r,c;    //行,列\npublic:\n    int row() const {\n        return r;\n    }\n    int column() const {\n        return c;\n    }\n    mat(int n,int m,T val = 0){\n        this->r = n,this->c = m;\n        rep(i,n){\n            this->push_back(vector<T>(m,val));\n        }\n    }\n    mat operator+(const mat& another){\n        if(this->r != another.r && this->c != another.c){\n            cout << \"足し算失敗(サイズ不一致)\" << endl;\n            exit(1);\n        }\n        mat<T> X(this->r,this->c);\n        rep(i,this->r){\n            rep(j,this->c){\n                X[i][j] = (*this)[i][j] + another[i][j];\n            }\n        }\n        return X;\n    }\n    mat operator+(const T val){\n        mat<T> X(this->r,this->c);\n        rep(i,this->r){\n            rep(j,this->c){\n                X[i][j] = (*this)[i][j] + val;\n            }\n        }\n        return X;\n    }\n    mat operator-(const mat& another){\n        if(this->r != another.r && this->c != another.c){\n            cout << \"引き算失敗(サイズ不一致)\" << endl;\n            exit(1);\n        }\n        mat<T> X(this->r,this->c);\n        rep(i,this->r){\n            rep(j,this->c){\n                X[i][j] = (*this)[i][j] - another[i][j];\n            }\n        }\n        return X;\n    }\n    mat operator-(const T val){\n        mat<T> X(this->r,this->c);\n        rep(i,this->r){\n            rep(j,this->c){\n                X[i][j] = (*this)[i][j] - val;\n            }\n        }\n        return X;\n    }\n    vector<T> operator*(const vector<T>& another){\n        if(this->c != (int)another.size()){\n            cout << \"掛け算失敗(サイズ不一致)\" << endl;\n            exit(1);\n        }\n        vector<T> vec(this->r,0);\n        rep(i,this->r){\n            rep(j,this->c){\n                vec[i] += (*this)[i][j] * another[j];\n            }\n        }\n        return vec;\n    }\n    mat operator*(const mat& another){\n        if(this->c != another.r){\n            cout << \"掛け算失敗(サイズ不一致)\" << endl;\n            exit(1);\n        }\n        mat<T> X(this->r,another.c);\n        rep(i,this->r){\n            rep(k,this->c){\n                rep(j,another.c){\n\t\t\t\t\tif((*this)[i][k] && another[k][j]){\n\t\t\t\t\t\tcmx(X[i][j],(*this)[i][k]+another[k][j]);\n\t\t\t\t\t}\n                }\n            }\n        }\n        return X;\n    }\n    mat operator-(){\n        mat<T> X(this->r,this->c);\n        rep(i,this->r){\n            rep(j,this->c){\n                X[i][j] = -(*this)[i][j];\n            }\n        }\n        return X;\n    }\n    void print(){\n        rep(i,this->r){\n            rep(j,(this->c)-1){\n                cout << (*this)[i][j] << \",\";\n            }\n            cout << (*this)[i][(this->c)-1] << endl;\n        }\n    }\n};\n\ntemplate<typename T> mat<T> pow(mat<T> A,ll cnt)\n{\n    if(A.row() != A.column()){\n        cout << \"累乗不可\" << endl;\n    }\n\tmat<T> B = A;\n\t--cnt;\n\twhile(cnt>0){\n\t\tif(cnt & 1){\n\t\t\tB = B*A;\n\t\t}\n\t\tA = A*A;\n\t\tcnt >>= 1;\n\t}\n\treturn B;\n}\n\nstruct edge{\n\tint to,cost;\n};\n\nvector<edge> G[MAX_N];\n\nbool possible(mat<int>& A,const int cri,const int K)\n{\n\tint n = A.row();\n\tmat<int> res = pow(A,cri);\n\tint mx = 0;\n\trep(i,n){\n\t\trep(j,n){\n\t\t\tcmx(mx,res[i][j]);\n\t\t}\n\t}\n\treturn (mx >= K);\n}\n\nint mx[101][151];\nint pre[101][151];\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n,m,K;\n\tcin >> n >> m >> K;\n\tmat<int> A(n,n);\n\trep(i,m){\n\t\tint a,b,c;\n\t\tcin >> a >> b >> c;\n\t\tcmx(A[a][b],c);\n\t}\n\trep(i,n){\n\t\trep(j,n){\n\t\t\tif(A[i][j]){\n\t\t\t\tG[i].pb((edge){j,A[i][j]});\n\t\t\t}\n\t\t}\n\t}\n\tif(!possible(A,K,K)){\n\t\tcout << \"-1\\n\";\n\t\treturn 0;\n\t}\n\tint l = 0,r = K;\n\twhile(r-l>1){\n\t\tint mid = (l+r)/2;\n\t\tif(possible(A,mid,K)){\n\t\t\tr = mid;\n\t\t}else{\n\t\t\tl = mid;\n\t\t}\n\t}\n\tcout << r << \"\\n\";\n\tif(r > 100){\n\t\treturn 0;\n\t}\n\trep(i,r){\n\t\trep(j,n){\n\t\t\teach(e,G[j]){\n\t\t\t\tif(mx[i+1][e.to] < mx[i][j] + e.cost){\n\t\t\t\t\tmx[i+1][e.to] = mx[i][j] + e.cost;\n\t\t\t\t\tpre[i+1][e.to] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint cri = *max_element(mx[r],mx[r]+n);\n\tvector<int> ans;\n\trep(i,n){\n\t\tif(mx[r][i] == cri){\n\t\t\tint nw = i;\n\t\t\trrep(j,r+1){\n\t\t\t\tans.pb(nw);\n\t\t\t\tnw = pre[j][nw];\n\t\t\t}\n\t\t\treverse(all(ans));\n\t\t\teach(it,ans){\n\t\t\t\tcout << it << \" \";\n\t\t\t}\n\t\t\tcout << \"\\n\";\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int64 LINF = 1LL << 60;\nconst int INF = 1 << 30;\n\nint V, E, K;\nint64 g[31][150][150];\n\nint main() {\n  fill_n(**g, 31 * 150 * 150, -LINF);\n\n  cin >> V >> E >> K;\n  for(int i = 0; i < E; i++) {\n    g[0][i][i] = 0;\n  }\n  for(int i = 0; i < E; i++) {\n    int a, b;\n    int64 c;\n    cin >> a >> b >> c;\n    g[0][a][b] = max(g[0][a][b], c);\n  }\n\n  for(int i = 0; i < 30; i++) {\n    for(int j = 0; j < V; j++) {\n      for(int k = 0; k < V; k++) {\n        for(int l = 0; l < V; l++) {\n          g[i + 1][k][l] = max(g[i + 1][k][l], g[i][k][j] + g[i][j][l]);\n        }\n      }\n    }\n  }\n\n\n  auto check = [&](int bit) {\n    vector< int64 > dp(V);\n    for(int k = 30; k >= 0; k--) {\n      if((bit >> k) & 1) {\n        vector< int64 > dp2(V);\n        for(int i = 0; i < V; i++) {\n          for(int j = 0; j < V; j++) {\n            dp2[j] = max(dp2[j], dp[i] + g[k][i][j]);\n          }\n        }\n        dp.swap(dp2);\n      }\n    }\n    return *max_element(begin(dp), end(dp)) >= K;\n  };\n\n  int ok = INF, ng = 0;\n  while(ok - ng > 1) {\n    int mid = (ok + ng) / 2;\n    if(check(mid)) ok = mid;\n    else ng = mid;\n  }\n\n  if(ok == INF) {\n    cout << -1 << endl;\n  } else {\n    cout << ok << endl;\n\n    if(ok <= 100) {\n      int64 dp[101][150] = {{}}, pv[101][150];\n      for(int i = 0; i < ok; i++) {\n        for(int j = 0; j < V; j++) {\n          for(int k = 0; k < V; k++) {\n            if(dp[i][j] + g[0][j][k] > dp[i + 1][k]) {\n              dp[i + 1][k] = dp[i][j] + g[0][j][k];\n              pv[i + 1][k] = j;\n            }\n          }\n        }\n      }\n      int high = 00;\n      for(int i = 0; i < V; i++) {\n        if(dp[ok][i] >= dp[ok][high]) high = i;\n      }\n      vector< int > route;\n      for(int i = ok; i >= 0; i--) {\n        route.push_back(high);\n        high = pv[i][high];\n      }\n      reverse(begin(route), end(route));\n      for(int i = 0; i < route.size(); i++) {\n        if(i) cout << \" \";\n        cout << route[i];\n      }\n      cout << endl;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\nint V,E,K;\nconst int INF = (1<<29);\nmat G;\n\nmat g[30];\nmat u[30];\n\nint add(int a,int b){\n  if(a==-INF||b==-INF)return -INF;\n  return min(a+b,INF);\n}\n\npair<mat,mat> merge(mat A,mat B, bool flag=false){\n  mat X( V, vec(V, -INF) );\n  mat Y( V, vec(V, -INF) );\n  \n  for(int from=0;from<V;from++){\n    for(int to=0;to<V;to++){\n      for(int ex=0;ex<V;ex++){\n        int cost=add(A[from][ex],B[ex][to]);\n        if(X[from][to]<cost){\n          X[from][to]=cost;\n          Y[from][to]=ex;\n        }\n      }\n    }\n  }\n  return make_pair(X,Y);\n}\n\n\nint calc(int m,int &si,int &ti){\n  mat t;\n  for(int i=0;i<30;i++){\n    if(m>>i&1){\n      if(t.empty()){\n        t=g[i];\n      }else{\n        t=merge(t,g[i]).first;\n      }\n    }\n  }\n  \n  int res=-INF;\n  for(int i=0;i<V;i++){\n    for(int j=0;j<V;j++){\n      if(res<t[i][j]){\n        si=i;\n        ti=j;\n        res=t[i][j];\n      }\n    }\n  }\n  return res;\n}\n\nvoid Dfs(vec& s,int from,int to,int len){\n  if(len<=1)return;\n  if(len==(len&-len)){\n\n    for(int i=0;i<30;i++){\n      if(len>>i&1){\n        int ex=u[i][from][to];\n        Dfs(s,from,ex,len/2);\n        s.push_back(ex);\n        //        cout<<i<<' '<<from<<' '<<to<<' '<<ex<<endl;\n        Dfs(s,ex,to,len/2);\n        return;\n      }\n    }\n  }\n  \n  mat t=mat( V, vec(V,-INF) );\n  for(int i=0;i<V;i++)t[i][i]=0;\n  \n  int ex=-1;\n  int sub=-1;\n  \n  for(int i=0;i<30;i++){\n    if(~len>>i&1)continue;\n    pair<mat,mat> tmp=merge(t, g[i]);\n    ex=tmp.second[from][to];\n    sub=(1<<i);\n  }\n\n  Dfs(s,from,ex,len-sub);\n  s.push_back(ex);\n  Dfs(s,ex,to,sub);\n}\n\nint main(){\n  cin>>V>>E>>K;\n  G=mat( V, vec(V, -INF) );\n  g[0]=u[0]=G;\n  for(int i=0;i<V;i++)g[0][i][i]=0;\n  for(int i=0;i<E;i++){\n    int a,b,c;\n    cin>>a>>b>>c;\n    assert(a!=b);\n    G[a][b]=max(G[a][b],c);\n    g[0][a][b]=max(g[0][a][b],c);\n    u[0][a][b]=b;\n  }\n  for(int i=1;i<30;i++){\n    pair<mat,mat> temp=merge(g[i-1],g[i-1]);\n    g[i]=temp.first;\n    u[i]=temp.second;\n  }\n  int left=1,right=K+1,mid,si,ti;\n  while( left < right ){\n    mid=(left+right)/2;\n    if( calc(mid,si,ti) >= K ){\n      right=mid;\n    }else{\n      left=mid+1;\n    }\n  }\n  for(int i=0;i<V;i++)g[0][i][i]=-INF;\n  for(int i=1;i<30;i++){\n    pair<mat,mat> temp=merge(g[i-1],g[i-1]);\n    g[i]=temp.first;\n    u[i]=temp.second;\n  }\n  calc(left,si,ti);\n  if(left==K+1){\n    cout<<-1<<endl;\n  }else{\n    cout<<left<<endl;\n    if(left<=100){\n      vec tab;\n      tab.push_back(si);\n      Dfs(tab,si,ti,left);\n      tab.push_back(ti);\n\n      for(int i=0;i<(int)tab.size();i++){\n\n        \n        if(i>0 && G[ tab[i-1] ][ tab[i] ] == -INF ){\n          assert(0);\n        }\n        \n        if(i)cout<<' ';\n        cout<<tab[i];\n      }\n      cout<<endl;\n    }\n  }\n  return 0;\n}\n\n  \n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n\nusing vint = vector<int>;\n\nconst int inf = 1LL<<55;\n\nint V, E, K;\nvector<vint> A;\n\nvector<vint> calc(int m) {\n  vector<vint> B = A;\n  vector<vint> res(V, vint(V, -inf));\n  for(int i = 0; i < V; ++i) res[i][i] = 0;\n  while(m > 0) {\n    if(m&1) {\n      vector<vint> tmp(V, vint(V, -inf));\n      for(int i = 0; i < V; ++i) tmp[i][i] = 0;\n      for(int k = 0; k < V; ++k) {\n\tfor(int i = 0; i < V; ++i) {\n\t  for(int j = 0; j < V; ++j) {\n\t    tmp[i][j] = max(tmp[i][j], res[i][k]+B[k][j]);\n\t  }\n\t}\n      }\n      res = tmp;\n    }\n    vector<vint> tmp(V, vint(V, -inf));\n    for(int i = 0; i < V; ++i) tmp[i][i] = 0;\n    for(int k = 0; k < V; ++k) {\n      for(int i = 0; i < V; ++i) {\n\tfor(int j = 0; j < V; ++j) {\n\t  tmp[i][j] = max(tmp[i][j], B[i][k]+B[k][j]);\n\t}\n      }\n    }\n    B = tmp;\n    m >>= 1;\n  }\n  return res;\n}\n\n\nint check(int m) {\n  vector<vint> B = calc(m);\n  int res = 0;\n  for(int i = 0; i < V; ++i) {\n    for(int j = 0; j < V; ++j) {\n      res = max(res, B[i][j]);\n    }\n  }\n  return res;\n}\n\nsigned main() {\n  cin >> V >> E >> K;\n  A.resize(V, vint(V, -inf));\n  for(int i = 0; i < V; ++i) A[i][i] = 0;\n  for(int i = 0; i < E; ++i) {\n    int u, v, c;\n    cin >> u >> v >> c;\n    A[u][v] = max(A[u][v], c);\n  }\n  int lb = -1, ub = 1111111;\n  while(lb+1 < ub) {\n    int mb = (lb+ub)/2;\n    if(check(mb) >= K) ub = mb;\n    else lb = mb;\n  }\n  if(ub == 1111111) {\n    cout << -1 << endl;\n    return 0;\n  }\n  cout << ub << endl;\n  int ans = check(ub);\n  if(ub <= 100) {\n    vector<vint> rev(ub+1, vint(V, -1));\n    vector<vint> dp(ub+1, vint(V, 0));\n    for(int i = 0; i < ub; ++i) {\n      for(int j = 0; j < V; ++j) {\n\tfor(int k = 0; k < V; ++k) {\n\t  if(dp[i+1][k] < dp[i][j]+A[j][k]) {\n\t    dp[i+1][k] = dp[i][j]+A[j][k];\n\t    rev[i+1][k] = j;\n\t  }\n\t}\n      }\n    }\n    int idx = -1;\n    for(int i = 0; i < V && idx == -1; ++i) {\n      if(ans == dp[ub][i]) idx = i;\n    }\n    vint vec;\n    for(int l = ub; l > 0; --l) {\n      vec.push_back(idx);\n      idx = rev[l][idx];\n    }\n    reverse(vec.begin(), vec.end());\n    for(int i = 0; i < (int)vec.size(); ++i) {\n      cout << vec[i] << \" \\n\"[i==(int)vec.size()-1];\n    }\n  }\n\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<int(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nconstexpr int64_t INF = INT64_C(1000000000000000000);\n\nusing Array = vector<int64_t>;\nusing Matrix = vector<Array>;\n\nMatrix mul(const Matrix& lhs, const Matrix& rhs) {\n  int r = lhs.size();\n  Matrix res(r, Array(r, -INF));\n  REP(i,r) REP(k,r) REP(j,r) {\n    res[i][j] = max(res[i][j], lhs[i][k] + rhs[k][j]);\n  }\n  return res;\n}\n\nMatrix pow(const Matrix& mat, int64_t index) {\n  if (index == 1) return mat;\n  if ((index % 2) == 1) {\n    return mul(mat, pow(mat, index-1));\n  }\n  return pow(mul(mat, mat), index/2);\n}\n\nint main() {\n  int64_t v,e,k;\n  cin>>v>>e>>k;\n  Matrix mat(v, Array(v, -INF));\n  REP(i,e) {\n    int64_t s,t,c;\n    cin>>s>>t>>c;\n    mat[s][t] = max(mat[s][t], c);\n  }\n  int64_t hi = k;\n  int64_t lo = 0;\n  while (hi - lo > 1) {\n    int64_t mid = (hi + lo) / 2;\n    auto pmat = pow(mat, mid);\n    int64_t mx = -INF;\n    REP(i,v)REP(j,v) mx = max(mx, pmat[i][j]);\n    if (mx < 0) {\n      hi = mid;\n    } else if (mx >= k) {\n      hi = mid;\n    } else {\n      lo = mid;\n    }\n  }\n  auto pmat = pow(mat, hi);\n  int64_t mx = -INF;\n  REP(i,v)REP(j,v) mx = max(mx, pmat[i][j]);\n  if (mx < k) {\n    cout << -1 << endl;\n    return 0;\n  } \n  cout << hi << endl;\n  if (hi > 100) {\n    return 0;\n  }\n  vector<Matrix> vmat;\n  Matrix m(v, Array(v, -INF));\n  REP(i,v) m[i][i] = 0;\n  REP(i,hi) {\n    vmat.push_back(m);\n    m = mul(mat, m);\n  }\n  int s=0,t=0;\n  REP(i,v)REP(j,v) {\n    if (pmat[i][j] == mx) {\n      s = i;\n      t = j;\n    }\n  }\n  vector<int> res;\n  for (int i = hi-1; i >= 0; --i) {\n    res.push_back(t);\n    int nt=0;\n    int64_t nmx=0;\n    REP(j,v) {\n      if (vmat[i][s][j] + mat[j][t] == mx) {\n        nt = j;\n        nmx = vmat[i][s][j];\n      }\n    }\n    t = nt;\n    mx = nmx;\n  }\n  cout << s;\n  reverse(ALL(res));\n  for (int r:res) cout << ' ' << r;\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  int V,E,K;\n  cin>>V>>E>>K;\n  vector<vector<int> > d[99];\n  d[0]=vector<vector<int> >(V,vector<int>(V,-1));\n  for(int i=0;i<E;i++){\n    int v1,v2,c;\n    cin>>v1>>v2>>c;\n    d[0][v1][v2]=max(d[0][v1][v2],c);\n  }\n  for(int i=0;i<V;i++){\n    d[0][i][i]=0;\n  }\n  int mx=-1;\n  for(int i=0;i<20;i++){\n    d[i+1]=vector<vector<int> >(V,vector<int>(V,-1));\n    for(int j=0;j<V;j++){\n      for(int k=0;k<V;k++){\n\tfor(int l=0;l<V;l++){\n\t  if(d[i][k][j]>=0&&d[i][j][l]>=0){\n\t    d[i+1][k][l]=max(d[i+1][k][l],d[i][k][j]+d[i][j][l]);\n\t    mx=max(mx,d[i+1][k][l]);\n\t  }\n\t}\n      }\n    }\n  }\n  if(mx<K){\n    cout<<-1<<endl;\n  }else{\n    int l=0,h=1<<20;\n    while(h-l>1){\n      int m=(h+l)/2;\n      vector<int> v(V);\n      int mmx=-1;\n      for(int i=0;i<20;i++){\n\tif(m>>i&1){\n\t  vector<int> org=v;\n\t  for(int j=0;j<V;j++){\n\t    for(int k=0;k<V;k++){\n\t      if(d[i][k][j]>=0){\n\t\tv[j]=max(v[j],org[k]+d[i][k][j]);\n\t\tmmx=max(mmx,v[j]);\n\t      }\n\t    }\n\t  }\n\t}\n      }\n      ((mmx<K)?l:h)=m;\n    }\n    cout<<h<<endl;\n    if(h<=100){\n      int c[101][150];\n      fill(*begin(c),*end(c),-1);\n      int p[101][150];\n      for(int i=1;i<=h;i++){\n\tfor(int j=0;j<V;j++){\n\t  for(int k=0;k<V;k++){\n\t    if(d[0][k][j]>=0&&c[i][j]<c[i-1][k]+d[0][k][j]){\n\t      c[i][j]=c[i-1][k]+d[0][k][j];\n\t      p[i][j]=k;\n\t    }\n\t  }\n\t}\n      }\n      int x[101];\n      x[h]=max_element(begin(c[h]),end(c[h]))-begin(c[h]);\n      for(int i=h;i-1>=0;i--){\n\tx[i-1]=p[i][x[i]];\n      }\n      for(int i=0;i<=h;i++){\n\tcout<<x[i]<<\" \\n\"[i==h];\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\nusing namespace std;\nint dp1[160][160];\nint rev[160][160];\nint dp2[160][160];\nint g[160][160];\nint dp3[160][160];\nint sg[160][160];\nint cost[310][160];\nint main(){\n\tint a,b,c;\n\tscanf(\"%d%d%d\",&a,&b,&c);\n\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++){\n\t\tg[i][j]=-1;\n\t}\n\tfor(int i=0;i<b;i++){\n\t\tint p,q,r;\n\t\tscanf(\"%d%d%d\",&p,&q,&r);\n\t\tif(!~g[p][q]||g[p][q]<r){\n\t\t\tg[p][q]=r;\n\t\t}\n\t}\n\tfor(int i=0;i<160;i++)for(int j=0;j<160;j++){\n\t\tdp1[i][j]=dp2[i][j]=-99999999;\n\t}\n\tfor(int i=0;i<a;i++)dp1[0][i]=dp2[0][i]=0;\n\tfor(int i=0;i<155;i++){\n\t\tfor(int j=0;j<a;j++){\n\t\t\tfor(int k=0;k<a;k++){\n\t\t\t\tif(~g[j][k]&&dp1[i][j]>=0){\n\t\t\t\t\tif(dp1[i+1][k]<dp1[i][j]+g[j][k]){\n\t\t\t\t\t\tdp1[i+1][k]=dp1[i][j]+g[j][k];\n\t\t\t\t\t\trev[i+1][k]=j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(~g[k][j]&&dp2[i][j]>=0){\n\t\t\t\t\tdp2[i+1][k]=max(dp2[i+1][k],dp2[i][j]+g[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=100;i++){\n\t\tint ms=0;\n\t\tint at=0;\n\t\tfor(int j=0;j<a;j++){\n\t\t\tif(ms<dp1[i][j]){\n\t\t\t\tms=dp1[i][j];\n\t\t\t\tat=j;\n\t\t\t}\n\t\t}\n\t\tif(ms>=c){\n\t\t\tprintf(\"%d\\n\",i);\n\t\t\tstack<int>S;\n\t\t\tfor(int j=i;j>=0;j--){\n\t\t\t\tS.push(at);\n\t\t\t\tat=rev[j][at];\n\t\t\t}\n\t\t\tfor(int j=0;j<=i;j++){\n\t\t\t\tif(j)printf(\" \");\n\t\t\t\tprintf(\"%d\",S.top());\n\t\t\t\tS.pop();\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(int i=0;i<a;i++){\n\t\tfor(int j=0;j<160;j++)for(int k=0;k<160;k++)sg[j][k]=-999999999;\n\t\tsg[0][i]=0;\n\t\tfor(int j=0;j<a;j++){\n\t\t\tfor(int k=0;k<a;k++){\n\t\t\t\tif(sg[j][k]<0)continue;\n\t\t\t\tfor(int l=0;l<a;l++){\n\t\t\t\t\tif(!~g[k][l])continue;\n\t\t\t\t\tsg[j+1][l]=max(sg[j+1][l],sg[j][k]+g[k][l]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<=a;j++)dp3[i][j]=sg[j][i];\n\t}\n\tint ret=99999999;\n\tfor(int i=0;i<a;i++){\n\t\tfor(int j=0;j<a;j++){\n\t\t\tfor(int k=0;k<a;k++){\n\t\t\t\tfor(int l=0;l<=a;l++){\n\t\t\t\t\tint t=dp1[i][j]+dp2[k][j];\n\t\t\t\t\tif(c<=t){\n\t\t\t\t\t\tret=min(ret,i+k);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(dp3[j][l]<=0)continue;\n\t\t\t\t\tret=min(ret,i+k+((c-t)+dp3[j][l]-1)/dp3[j][l]*l);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(ret>9999999){\n\t\tret=-1;\n\t}\n\tprintf(\"%d\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int logMaxStep = 30;\n\ntypedef long long ll;\ntypedef vector< vector<ll> > Graph;\n\nint GetLogStep(int S) {\n\tint res;\n\tfor (res = 0; (1 << res) <= S; ++res);\n\treturn res;\n}\nGraph nextG(const Graph& g1, const Graph& g2) {\n\tint N = g1.size();\n\tGraph res(N, vector<ll>(N, 0));\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tfor (int k = 0; k < N; ++k) {\n\t\t\t\tif (g1[i][k] > 0 && g2[k][j] > 0) {\n\t\t\t\t\tres[i][j] = max(res[i][j], g1[i][k]+g2[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nvector<int> nextDP(vector<ll>& dp, Graph& g) {\n\tint N = g.size();\n\tvector<int> prevV(N, -1);\n\tvector<ll> ndp(N, -1);\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tif (dp[i] >= 0 && g[i][j] > 0) {\n\t\t\t\tif (dp[i]+g[i][j] > ndp[j]) {\n\t\t\t\t\tndp[j] = dp[i]+g[i][j];\n\t\t\t\t\tprevV[j] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tdp[i] = ndp[i];\n\t}\n\treturn prevV;\n}\nll GetMaxScore(vector<Graph>& powG, int S) {\n\tint N = powG[0].size();\n\tint logS = GetLogStep(S);\n\tvector<ll> dp(N, 0);\n\tfor (int i = 0; i < logS; ++i) {\n\t\tGraph& g = powG[i];\n\t\tif ( (1 << i) & S ) {\n\t\t\tnextDP(dp, g);\n\t\t}\n\t}\n\tll res = -1;\n\tfor (int i = 0; i < dp.size(); ++i) {\n\t\tres = max(res, dp[i]);\n\t}\n\treturn res;\n}\nint check200Step(Graph& G, int K) {\n\tint N = G.size();\n\tvector<ll> dp(N, 0);\n\tvector< vector<int> > prevV;\n\tll lastAns = -1;\n\tfor (int t = 0; t < 1000; ++t) {\n\t\tprevV.push_back( nextDP(dp, G) );\n\t\tint aid = 0;\n\t\tfor (int i = 0; i < dp.size(); ++i) {\n\t\t\tif (dp[i] > dp[aid]) aid = i;\n\t\t}\n\t\tif (dp[aid] >= K) {\n\t\t\tcout << t+1 << endl;\n\t\t\tif (t+1 <= 100) {\n\t\t\t\tvector<int> vl;\n\t\t\t\tint v = aid; vl.push_back(v);\n\t\t\t\tfor (int i = t; i >= 0; --i) {\n\t\t\t\t\tv = prevV[i][v];\n\t\t\t\t\tvl.push_back(v);\n\t\t\t\t}\n\t\t\t\treverse(vl.begin(), vl.end());\n\t\t\t\tfor (int i = 0; i < vl.size(); ++i) {\n\t\t\t\t\tif (i) cout << \" \";\n\t\t\t\t\tcout << vl[i];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t\treturn -2;\n\t\t}\n\t\tlastAns = dp[aid];\n\t}\n\treturn lastAns;\n}\nint main() {\n\tint N, E, K; cin >> N >> E >> K;\n\tGraph G(N, vector<ll>(N, 0));\n\tfor (int i = 0; i < E; ++i) {\n\t\tint a, b; ll c; cin >> a >> b >> c;\n\t\tG[a][b] = max(G[a][b], c);\n\t}\n\tint result = check1000Step(G, K);\n\tif (result > 0) {\n\t\tvector<Graph> powG(logMaxStep+1); powG[0] = G;\n\t\tfor (int i = 0; i < logMaxStep; ++i) {\n\t\t\tpowG[i+1] = nextG(powG[i], powG[i]);\n\t\t}\n\n\t\tfor (int i = N; i <= N+100; ++i) {\n\t\t\tif (GetMaxScore(powG, i+1) >= result) {\n\t\t\t\tassert(GetMaxScore(powG, i+1) > GetMaxScore(powG, i));\n\t\t\t}\n\t\t}\n\t\tint l = 0, r = K+1;\n\t\tfor (int t = 0; t < logMaxStep; ++t) {\n\t\t\tint m = (l + r) / 2;\n\t\t\tif ( GetMaxScore(powG, m) >= K ) {\n\t\t\t\tr = m;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tl = m;\n\t\t\t}\n\t\t}\n\t\tassert(r - l <= 1);\n\t\tassert(r <= K);\n\t\tcout << r << endl;\n\t}\n\telse if (result == -1) {\n\t\tcout << -1 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\nint V,E,K;\nconst int INF = (1<<29);\nmat G;\n\nmat g[30];\nmat u[30];\n\nint add(int a,int b){\n  if(a==-INF||b==-INF)return -INF;\n  return min(a+b,INF);\n}\n\npair<mat,mat> merge(mat A,mat B, bool flag=false){\n  mat X( V, vec(V, -INF) );\n  mat Y( V, vec(V, -INF) );\n  \n  for(int from=0;from<V;from++){\n    for(int to=0;to<V;to++){\n      for(int ex=0;ex<V;ex++){\n        int cost=add(A[from][ex],B[ex][to]);\n        if(X[from][to]<cost){\n          X[from][to]=cost;\n          Y[from][to]=ex;\n        }\n      }\n    }\n  }\n  return make_pair(X,Y);\n}\n\n\nint calc(int m,int &si,int &ti){\n  mat t;\n  for(int i=0;i<30;i++){\n    if(m>>i&1){\n      if(t.empty()){\n        t=g[i];\n      }else{\n        t=merge(t,g[i]).first;\n      }\n    }\n  }\n  \n  int res=-INF;\n  for(int i=0;i<V;i++){\n    for(int j=0;j<V;j++){\n      if(res<t[i][j]){\n        si=i;\n        ti=j;\n        res=t[i][j];\n      }\n    }\n  }\n  return res;\n}\n\nvoid Dfs(vec& s,int from,int to,int len){\n  if(len<=1)return;\n  if(len==(len&-len)){\n\n    for(int i=0;i<30;i++){\n      if(len>>i&1){\n        int ex=u[i][from][to];\n        Dfs(s,from,ex,len/2);\n        s.push_back(ex);\n        //        cout<<i<<' '<<from<<' '<<to<<' '<<ex<<endl;\n        Dfs(s,ex,to,len/2);\n        return;\n      }\n    }\n  }\n  \n  mat t=mat( V, vec(V,-INF) );\n  for(int i=0;i<V;i++)t[i][i]=0;\n  \n  int ex=-1;\n  int sub=-1;\n  \n  for(int i=0;i<30;i++){\n    if(~len>>i&1)continue;\n    pair<mat,mat> tmp=merge(t, g[i]);\n    ex=tmp.second[from][to];\n    sub=(1<<i);\n  }\n\n  Dfs(s,from,ex,len-sub);\n  s.push_back(ex);\n  Dfs(s,ex,to,sub);\n}\n\nint main(){\n  cin>>V>>E>>K;\n  G=mat( V, vec(V, -INF) );\n  g[0]=u[0]=G;\n  for(int i=0;i<V;i++)g[0][i][i]=0;\n  for(int i=0;i<E;i++){\n    int a,b,c;\n    cin>>a>>b>>c;\n    assert(a!=b);\n    G[a][b]=max(G[a][b],c);\n    g[0][a][b]=max(g[0][a][b],c);\n    u[0][a][b]=b;\n  }\n  for(int i=1;i<30;i++){\n    pair<mat,mat> temp=merge(g[i-1],g[i-1]);\n    g[i]=temp.first;\n    u[i]=temp.second;\n  }\n  int left=1,right=K+1,mid,si,ti;\n  while( left < right ){\n    mid=(left+right)/2;\n    if( calc(mid,si,ti) >= K ){\n      right=mid;\n    }else{\n      left=mid+1;\n    }\n  }\n  for(int i=0;i<V;i++)g[0][i][i]=-INF;\n  for(int i=1;i<30;i++){\n    pair<mat,mat> temp=merge(g[i-1],g[i-1]);\n    g[i]=temp.first;\n    u[i]=temp.second;\n  }\n  assert(  calc(left,si,ti) >= K );\n  \n  if(left==K+1){\n    cout<<-1<<endl;\n  }else{\n    cout<<left<<endl;\n    if(left<=100){\n      vec tab;\n      tab.push_back(si);\n      Dfs(tab,si,ti,left);\n      tab.push_back(ti);\n\n      \n      for(int i=0;i<(int)tab.size();i++){\n\n        \n        if(i>0){\n          int cost=G[ tab[i-1] ][ tab[i] ];\n          if(cost == -INF ){\n            assert(0);\n          }else{\n            \n          }\n        }\n        \n        if(i)cout<<' ';\n        cout<<tab[i];\n      }\n      cout<<endl;\n    }\n  }\n  return 0;\n}\n\n  \n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 151;\n\ntemplate<typename T> class mat : public vector<vector<T> > {\nprivate:\n    int r,c;    //行,列\npublic:\n    int row() const {\n        return r;\n    }\n    int column() const {\n        return c;\n    }\n    mat(int n,int m,T val = 0){\n        this->r = n,this->c = m;\n        rep(i,n){\n            this->push_back(vector<T>(m,val));\n        }\n    }\n    mat operator+(const mat& another){\n        if(this->r != another.r && this->c != another.c){\n            cout << \"足し算失敗(サイズ不一致)\" << endl;\n            exit(1);\n        }\n        mat<T> X(this->r,this->c);\n        rep(i,this->r){\n            rep(j,this->c){\n                X[i][j] = (*this)[i][j] + another[i][j];\n            }\n        }\n        return X;\n    }\n    mat operator+(const T val){\n        mat<T> X(this->r,this->c);\n        rep(i,this->r){\n            rep(j,this->c){\n                X[i][j] = (*this)[i][j] + val;\n            }\n        }\n        return X;\n    }\n    mat operator-(const mat& another){\n        if(this->r != another.r && this->c != another.c){\n            cout << \"引き算失敗(サイズ不一致)\" << endl;\n            exit(1);\n        }\n        mat<T> X(this->r,this->c);\n        rep(i,this->r){\n            rep(j,this->c){\n                X[i][j] = (*this)[i][j] - another[i][j];\n            }\n        }\n        return X;\n    }\n    mat operator-(const T val){\n        mat<T> X(this->r,this->c);\n        rep(i,this->r){\n            rep(j,this->c){\n                X[i][j] = (*this)[i][j] - val;\n            }\n        }\n        return X;\n    }\n    vector<T> operator*(const vector<T>& another){\n        if(this->c != (int)another.size()){\n            cout << \"掛け算失敗(サイズ不一致)\" << endl;\n            exit(1);\n        }\n        vector<T> vec(this->r,0);\n        rep(i,this->r){\n            rep(j,this->c){\n                vec[i] += (*this)[i][j] * another[j];\n            }\n        }\n        return vec;\n    }\n    mat operator*(const mat& another){\n        if(this->c != another.r){\n            cout << \"掛け算失敗(サイズ不一致)\" << endl;\n            exit(1);\n        }\n        mat<T> X = *this;\n        rep(i,this->r){\n            for(int k=0;k<this->c;k++){\n\t\t\t\tif((*this)[i][k]){\n                \tfor(int j=0;j<another.c;j++){\n\t\t\t\t\t\tif(another[k][j]){\n\t\t\t\t\t\t\tcmx(X[i][j],(*this)[i][k]+another[k][j]);\n\t\t\t\t\t\t}\n                \t}\n\t\t\t\t}\n            }\n        }\n        return X;\n    }\n    mat operator-(){\n        mat<T> X(this->r,this->c);\n        rep(i,this->r){\n            rep(j,this->c){\n                X[i][j] = -(*this)[i][j];\n            }\n        }\n        return X;\n    }\n    void print(){\n        rep(i,this->r){\n            rep(j,(this->c)-1){\n                cout << (*this)[i][j] << \",\";\n            }\n            cout << (*this)[i][(this->c)-1] << endl;\n        }\n    }\n};\n\ntemplate<typename T> mat<T> pow(mat<T> A,ll cnt)\n{\n    if(A.row() != A.column()){\n        cout << \"累乗不可\" << endl;\n    }\n\tmat<T> B = A;\n\t--cnt;\n\twhile(cnt>0){\n\t\tif(cnt & 1){\n\t\t\tB = B*A;\n\t\t}\n\t\tA = A*A;\n\t\tcnt >>= 1;\n\t}\n\treturn B;\n}\n\nstruct edge{\n\tint to,cost;\n};\n\nvector<edge> G[MAX_N];\n\nbool possible(mat<int>& A,const int cri,const int K)\n{\n\tint n = A.row();\n\tmat<int> res = pow(A,cri);\n\tint mx = 0;\n\trep(i,n){\n\t\trep(j,n){\n\t\t\tcmx(mx,res[i][j]);\n\t\t}\n\t}\n\treturn (mx >= K);\n}\n\nint mx[101][151];\nint pre[101][151];\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n,m,K;\n\tcin >> n >> m >> K;\n\t// n = (n+3)/4*4;\n\tmat<int> A(n,n);\n\trep(i,m){\n\t\tint a,b,c;\n\t\tcin >> a >> b >> c;\n\t\tcmx(A[a][b],c);\n\t}\n\trep(i,n){\n\t\trep(j,n){\n\t\t\tif(A[i][j]){\n\t\t\t\tG[i].pb((edge){j,A[i][j]});\n\t\t\t}\n\t\t}\n\t}\n\tmat<int> res = pow(A,100);\n\tif(!possible(A,K,K)){\n\t\tcout << \"-1\\n\";\n\t\treturn 0;\n\t}\n\tint l = 0,r = K;\n\twhile(r-l>1){\n\t\tint mid = (l+r)/2;\n\t\tif(possible(A,mid,K)){\n\t\t\tr = mid;\n\t\t}else{\n\t\t\tl = mid;\n\t\t}\n\t}\n\tcout << r << \"\\n\";\n\tif(r > 100){\n\t\treturn 0;\n\t}\n\trep(i,r){\n\t\trep(j,n){\n\t\t\teach(e,G[j]){\n\t\t\t\tif(mx[i+1][e.to] < mx[i][j] + e.cost){\n\t\t\t\t\tmx[i+1][e.to] = mx[i][j] + e.cost;\n\t\t\t\t\tpre[i+1][e.to] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint cri = *max_element(mx[r],mx[r]+n);\n\tvector<int> ans;\n\trep(i,n){\n\t\tif(mx[r][i] == cri){\n\t\t\tint nw = i;\n\t\t\trrep(j,r+1){\n\t\t\t\tans.pb(nw);\n\t\t\t\tnw = pre[j][nw];\n\t\t\t}\n\t\t\treverse(all(ans));\n\t\t\teach(it,ans){\n\t\t\t\tcout << it << \" \";\n\t\t\t}\n\t\t\tcout << \"\\n\";\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 151;\n\ntemplate<typename T> class mat : public vector<vector<T> > {\nprivate:\n    int r,c;    //行,列\npublic:\n    int row() const {\n        return r;\n    }\n    int column() const {\n        return c;\n    }\n    mat(int n,int m,T val = 0){\n        this->r = n,this->c = m;\n        rep(i,n){\n            this->push_back(vector<T>(m,val));\n        }\n    }\n    mat operator+(const mat& another){\n        if(this->r != another.r && this->c != another.c){\n            cout << \"足し算失敗(サイズ不一致)\" << endl;\n            exit(1);\n        }\n        mat<T> X(this->r,this->c);\n        rep(i,this->r){\n            rep(j,this->c){\n                X[i][j] = (*this)[i][j] + another[i][j];\n            }\n        }\n        return X;\n    }\n    mat operator+(const T val){\n        mat<T> X(this->r,this->c);\n        rep(i,this->r){\n            rep(j,this->c){\n                X[i][j] = (*this)[i][j] + val;\n            }\n        }\n        return X;\n    }\n    mat operator-(const mat& another){\n        if(this->r != another.r && this->c != another.c){\n            cout << \"引き算失敗(サイズ不一致)\" << endl;\n            exit(1);\n        }\n        mat<T> X(this->r,this->c);\n        rep(i,this->r){\n            rep(j,this->c){\n                X[i][j] = (*this)[i][j] - another[i][j];\n            }\n        }\n        return X;\n    }\n    mat operator-(const T val){\n        mat<T> X(this->r,this->c);\n        rep(i,this->r){\n            rep(j,this->c){\n                X[i][j] = (*this)[i][j] - val;\n            }\n        }\n        return X;\n    }\n    vector<T> operator*(const vector<T>& another){\n        if(this->c != (int)another.size()){\n            cout << \"掛け算失敗(サイズ不一致)\" << endl;\n            exit(1);\n        }\n        vector<T> vec(this->r,0);\n        rep(i,this->r){\n            rep(j,this->c){\n                vec[i] += (*this)[i][j] * another[j];\n            }\n        }\n        return vec;\n    }\n    mat operator*(const mat& another){\n        if(this->c != another.r){\n            cout << \"掛け算失敗(サイズ不一致)\" << endl;\n            exit(1);\n        }\n        mat<T> X(this->r,another.c);\n        rep(i,this->r){\n            rep(k,this->c){\n                rep(j,another.c){\n\t\t\t\t\tif((*this)[i][k] && another[k][j]){\n\t\t\t\t\t\tcmx(X[i][j],(*this)[i][k]+another[k][j]);\n\t\t\t\t\t}\n                }\n            }\n        }\n        return X;\n    }\n    mat operator-(){\n        mat<T> X(this->r,this->c);\n        rep(i,this->r){\n            rep(j,this->c){\n                X[i][j] = -(*this)[i][j];\n            }\n        }\n        return X;\n    }\n    void print(){\n        rep(i,this->r){\n            rep(j,(this->c)-1){\n                cout << (*this)[i][j] << \",\";\n            }\n            cout << (*this)[i][(this->c)-1] << endl;\n        }\n    }\n};\n\ntemplate<typename T> mat<T> pow(mat<T> A,ll cnt)\n{\n    if(A.row() != A.column()){\n        cout << \"累乗不可\" << endl;\n    }\n\tmat<T> B = A;\n\t--cnt;\n\twhile(cnt>0){\n\t\tif(cnt & 1){\n\t\t\tB = B*A;\n\t\t}\n\t\tA = A*A;\n\t\tcnt >>= 1;\n\t}\n\treturn B;\n}\n\nstruct edge{\n\tint to,cost;\n};\n\nvector<edge> G[MAX_N];\n\nbool possible(mat<int>& A,const int cri,const int K)\n{\n\tint n = A.row();\n\tmat<int> res = pow(A,cri);\n\tint mx = 0;\n\trep(i,n){\n\t\trep(j,n){\n\t\t\tcmx(mx,res[i][j]);\n\t\t}\n\t}\n\treturn (mx >= K);\n}\n\nint mx[101][151];\nint pre[101][151];\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n,m,K;\n\tcin >> n >> m >> K;\n\tmat<int> A(n,n);\n\trep(i,m){\n\t\tint a,b,c;\n\t\tcin >> a >> b >> c;\n\t\tcmx(A[a][b],c);\n\t}\n\trep(i,n){\n\t\trep(j,n){\n\t\t\tif(A[i][j]){\n\t\t\t\tG[i].pb((edge){j,A[i][j]});\n\t\t\t}\n\t\t}\n\t}\n\tif(!possible(A,K,K)){\n\t\tcout << \"-1\\n\";\n\t\treturn 0;\n\t}\n\tint l = 0,r = K;\n\twhile(r-l>1){\n\t\tint mid = (l+r)/2;\n\t\tif(possible(A,mid,K)){\n\t\t\tr = mid;\n\t\t}else{\n\t\t\tl = mid;\n\t\t}\n\t}\n\tcout << r << \"\\n\";\n\tif(r > 100){\n\t\treturn 0;\n\t}\n\trep(i,r){\n\t\trep(j,n){\n\t\t\teach(e,G[j]){\n\t\t\t\tif(mx[i+1][e.to] < mx[i][j] + e.cost){\n\t\t\t\t\tmx[i+1][e.to] = mx[i][j] + e.cost;\n\t\t\t\t\tpre[i+1][e.to] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint cri = *max_element(mx[r],mx[r]+n);\n\tvector<int> ans;\n\trep(i,n){\n\t\tif(mx[r][i] == cri){\n\t\t\tint nw;\n\t\t\tfor(int j=r;j>=0;j--){\n\t\t\t\tans.pb(nw);\n\t\t\t\tnw = pre[j][nw];\n\t\t\t}\n\t\t\treverse(all(ans));\n\t\t\teach(it,ans){\n\t\t\t\tcout << it << \" \";\n\t\t\t}\n\t\t\tcout << \"\\n\";\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  int V,E,K;\n  cin>>V>>E>>K;\n  vector<vector<int> > d[99];\n  d[0]=vector<vector<int> >(V,vector<int>(V,-1));\n  for(int i=0;i<E;i++){\n    int v1,v2,c;\n    cin>>v1>>v2>>c;\n    d[0][v1][v2]=max(d[0][v1][v2],c);\n  }\n  for(int i=0;i<V;i++){\n    d[0][i][i]=0;\n  }\n  int mx=-1;\n  for(int i=0;i<20;i++){\n    d[i+1]=vector<vector<int> >(V,vector<int>(V,-1));\n    for(int j=0;j<V;j++){\n      for(int k=0;k<V;k++){\n\tfor(int l=0;l<V;l++){\n\t  if(d[i][k][j]>=0&&d[i][j][l]>=0){\n\t    d[i+1][k][l]=max(d[i+1][k][l],d[i][k][j]+d[i][j][l]);\n\t    mx=max(mx,d[i+1][k][l]);\n\t  }\n\t}\n      }\n    }\n  }\n  if(mx<K){\n    cout<<-1<<endl;\n  }else{\n    int l=0,h=1<<20;\n    while(h-l>1){\n      int m=(h+l)/2;\n      vector<int> v(V);\n      int mmx=-1;\n      for(int i=0;i<20;i++){\n\tif(m>>i&1){\n\t  vector<int> org=v;\n\t  for(int j=0;j<V;j++){\n\t    for(int k=0;k<V;k++){\n\t      if(d[i][k][j]>=0){\n\t\tv[j]=max(v[j],org[k]+d[i][k][j]);\n\t\tmmx=max(mmx,v[j]);\n\t      }\n\t    }\n\t  }\n\t}\n      }\n      ((mmx<K)?l:h)=m;\n    }\n    cout<<h<<endl;\n    if(h<=100){\n      int c[101][100];\n      fill(*begin(c),*end(c),-1);\n      int p[101][100];\n      for(int i=1;i<=h;i++){\n\tfor(int j=0;j<V;j++){\n\t  for(int k=0;k<V;k++){\n\t    if(d[0][k][j]>=0&&c[i][j]<c[i-1][k]+d[0][k][j]){\n\t      c[i][j]=c[i-1][k]+d[0][k][j];\n\t      p[i][j]=k;\n\t    }\n\t  }\n\t}\n      }\n      int x[101];\n      x[h]=max_element(begin(c[h]),end(c[h]))-begin(c[h]);\n      for(int i=h;i-1>=0;i--){\n\tx[i-1]=p[i][x[i]];\n      }\n      for(int i=0;i<=h;i++){\n\tcout<<x[i]<<\" \\n\"[i==h];\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<int(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nconstexpr int INF = 1000000000;\n\nusing Array = vector<int>;\nusing Matrix = vector<Array>;\n\nMatrix mul(const Matrix& lhs, const Matrix& rhs) {\n  int r = lhs.size();\n  Matrix res(r, Array(r, -INF));\n  REP(i,r) REP(k,r) REP(j,r) {\n    res[i][j] = max(res[i][j], lhs[i][k] + rhs[k][j]);\n  }\n  return res;\n}\n\nMatrix pow(const Matrix& mat, int index) {\n  if (index == 0) {\n    int v = mat.size();\n    Matrix res(v, Array(v, -INF));\n    REP(i,v) res[i][i] = 0;\n    return res;\n  }\n  if (index == 1) return mat;\n  if ((index % 2) == 1) {\n    return mul(mat, pow(mat, index-1));\n  }\n  return pow(mul(mat, mat), index/2);\n}\n\nint main() {\n  int v,e,k;\n  cin>>v>>e>>k;\n  Matrix mat(v, Array(v, -INF));\n  REP(i,e) {\n    int s,t,c;\n    cin>>s>>t>>c;\n    mat[s][t] = max(mat[s][t], c);\n  }\n  int hi = k;\n  int lo = 0;\n  while (hi - lo > 1) {\n    int mid = (hi + lo) / 2;\n    auto pmat = pow(mat, mid);\n    int mx = -INF;\n    REP(i,v)REP(j,v) mx = max(mx, pmat[i][j]);\n    if (mx > k - 100 * v) {\n      hi = mid;\n    } else {\n      lo = mid;\n    }\n  }\n  auto pmat = pow(mat, lo);\n  vector<int> score(v, -INF);\n  REP(i,v)REP(j,v) score[j] = max(score[j], pmat[i][j]);\n  REP(cnt,k) {\n    vector<int> tmp(v, -INF);\n    REP(i,v)REP(j,v) tmp[j] = max(tmp[j], score[i] + mat[i][j]);\n    int mx = -INF;\n    REP(i,v) mx = max(mx, tmp[i]);\n    swap(score, tmp);\n    if (mx >= k) {\n      lo += cnt + 1;\n      break;\n    }\n  }\n  if (lo > 0 && lo <= k) {\n    cout << lo << endl;\n  } else {\n    cout << -1 << endl;\n    return 0;\n  }\n  if (hi > 100) {\n    return 0;\n  }\n  vector<vector<int>> vscore;\n  REP(i,v) score[i] = 0;\n  REP(cnt,lo) {\n    vector<int> tmp(v, -INF);\n    REP(i,v)REP(j,v) tmp[j] = max(tmp[j], score[i] + mat[i][j]);\n    int mx = -INF;\n    REP(i,v) mx = max(mx, tmp[i]);\n    vscore.push_back(score);\n    swap(score, tmp);\n  }\n  int t = 0;\n  int mx = -INF;\n  REP(i,v) {\n    if (score[i] > mx) {\n      mx = score[i];\n      t = i;\n    }\n  }\n  vector<int> res;\n  res.push_back(t);\n  for (int i = lo-1; i >= 0; --i) {\n    int nt = 0;\n    int nmx = -INF;\n    REP(j,v) {\n      if (vscore[i][j] + mat[j][t] == mx) {\n        nt = j;\n        nmx = vscore[i][j];\n      }\n    }\n    t = nt;\n    mx = nmx;\n    res.push_back(t);\n  }\n  reverse(ALL(res));\n  REP(i,res.size()) {\n    if (i) cout << ' ';\n    cout << res[i];\n  }\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#define bigas(a,b) if(a<b){a=b;}\nusing namespace std;\nint main(void){\n\tint h=0,i=0,j=0,m=0,ex=0,ans=0,V,E,K,x,y,z;\n\tstatic int ya[20][150][150]={0};//ya[i][x][y]???x??????y???2^i??¬???????????´????????¢??°?????????\n\tstatic int gen[150]={0};//gen[x]???x??´??????????????§?????°\n\tstatic int ima[150]={0};\n\tstatic int pre[101][150]={0};//??????????????\\??????\n\tstatic int poi[101][150]={0};//??????\n\tfor(h=0;h<20;h++){\n\t\tfor(i=0;i<150;i++){\n\t\t\tfor(j=0;j<150;j++){\n\t\t\t\tya[h][i][j]=-(1<<30);\n\t\t\t\tif(i==j){ya[h][i][j]=0;}\n\t\t\t}\n\t\t}\n\t}\n\tscanf(\"%d %d %d\",&V,&E,&K);\n\tfor(i=0;i<E;i++){\n\t\tscanf(\"%d %d %d\",&x,&y,&z);\n\t\tbigas(ya[0][x][y],z);\n\t}\n\tfor(h=1;h<101;h++){\n\t\tfor(i=0;i<V;i++){\n\t\t\tfor(j=0;j<V;j++){\n\t\t\t\tif(poi[h][j]<poi[h-1][i]+ya[0][i][j]){\n\t\t\t\t\tpoi[h][j]=poi[h-1][i]+ya[0][i][j];\n\t\t\t\t\tpre[h][j]=i;\n\t\t\t\t\tif(poi[h][j]>=K){ex=1;K=poi[h][j];ans=j;}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ex==1){break;}\n\t}\n\tif(ex==1){\n\t\tprintf(\"%d\\n\",h);\n\t\tima[h]=ans;\n\t\tfor(i=h-1;i>=0;i--){\n\t\t\tima[i]=pre[i+1][ima[i+1]];\n\t\t}\n\t\tfor(i=0;i<=h;i++){\n\t\t\tprintf(\"%d \",ima[i]);\n\t\t}\n\t\treturn 0;\n\t}\n\th=0,i=0,j=0,m=0,ex=0,ans=0;\n\t\n\t//??????????????§????????????????§£???\n\tfor(h=1;h<20;h++){//2^i??¬????±???????\n\t\tfor(i=0;i<V;i++){//i??????\n\t\t\tfor(j=0;j<V;j++){//j?????§\n\t\t\t\tfor(m=0;m<V;m++){//m????????£???\n\t\t\t\t\tbigas(ya[h][i][j],ya[h-1][i][m]+ya[h-1][m][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//??????????????¬??°??????????????§????±???????\n\tfor(h=19;h>=0;h--){\n\t\tfor(i=0;i<V;i++){\n\t\t\tfor(j=0;j<V;j++){\n\t\t\t\tbigas(ima[j],gen[i]+ya[h][i][j]);\n\t\t\t\tif(ima[j]>=K){ex=1;break;}\n\t\t\t}\n\t\t}\n\t\tif(ex==0){\n\t\t\tans+=(1<<h);\n\t\t\tfor(i=0;i<V;i++){\n\t\t\tgen[i]=ima[i];\n\t\t\t}\n\t\t}else{\n\t\t\tfor(i=0;i<V;i++){\n\t\t\tima[i]=gen[i];\n\t\t\t}\n\t\t}\n\t\tex=0;\n\t}\n\tans++;\n\tif(ans+500<(1<<20)){printf(\"%d\\n\",ans);}else{printf(\"-1\\n\");}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\ntypedef vector<vector<pair<vector<int>, long long int>>>type;\n\nint V, E, K;\n type time(const type&lts, const type&rts, const bool flag) {\n\ttype squs(V,vector<pair<vector<int>,long long int>>(V));\n\tfor (int i = 0; i < V; ++i) {\n\t\tfor (int j = 0; j < V; ++j) {\n\t\t\tif (i == j)squs[i][j] = make_pair(vector<int>(), 0ll);\n\t\t\telse squs[i][j] = make_pair(vector<int>(), static_cast<long long>(-1e17));\n\t\t}\n\t}\n\tvector<vector<int>>ps(V, vector <int>(V));\n\tfor (int k = 0; k < V; ++k) {\n\t\tfor (int i = 0; i < V; ++i) {\n\t\t\tfor (int j = 0; j < V; ++j) {\n\t\t\t\tif (squs[i][j].second <lts[i][k].second + rts[k][j].second) {\n\t\t\t\t\tsqus[i][j].second = lts[i][k].second + rts[k][j].second;\n\t\t\t\t\tif (flag) {\n\t\t\t\t\t\tps[i][j] = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif (flag) {\n\t\tfor (int i = 0; i < V; ++i) {\n\t\t\tfor (int j = 0; j < V; ++j) {\n\t\t\t\tconst int k = ps[i][j];\n\t\t\t\tsqus[i][j].first.clear();\n\t\t\t\tsqus[i][j].first.insert(squs[i][j].first.end(), lts[i][k].first.begin(), lts[i][k].first.end());\n\t\t\t\tsqus[i][j].first.insert(squs[i][j].first.end(), rts[k][j].first.begin(), rts[k][j].first.end());\n\t\t\t}\n\t\t}\n\t}\n\treturn squs;\n}\ntype square(const type&ts,bool flag) {\n\treturn time(ts, ts, flag);\n}\n\ntype power(const type&ts,const long long  int num,const bool flag) {\n\tassert(num);\n\tif (num == 1)return ts;\n\telse {\n\t\ttype pot(square(power(ts,num/2,flag),flag));\n\t\tif (num % 2) {\n\t\t\tpot = time(pot, ts, flag);\n\t\t}\n\t\treturn pot;\n\t}\n}\nvector<int>ans;\nbool check(const type &ts,const long long int run,const int point,const bool flag) {\n\t\n\ttype t(power(ts, run, flag&&run <= 100));\n\tlong long int amax = 0;\n\tint ai = -1;\n\tint aj = -1;\n\tfor (int i = 0; i < V; ++i) {\n\t\tfor (int j = 0; j < V; ++j) {\n\t\t\tif (amax < t[i][j].second) {\n\t\t\t\tamax = t[i][j].second;\n\t\t\t\tai = i;\n\t\t\t\taj = j;\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}if (run <= 100 && flag) {\n\t\tans.clear();\n\t\tans.push_back(ai);\n\t\tans.insert(ans.end(), t[ai][aj].first.begin(), t[ai][aj].first.end());\n\t}\n\tif (amax >= point)return true;\n\telse return false;\n}\n\nint main() { cin >> V >> E >> K;\n\ttype times(V, vector<pair<vector<int>,long long int>>(V, make_pair(vector<int>(),static_cast<long long int>(-1e18))));\n\tfor (int i = 0; i < E; ++i) {\n\t\tlong long int a, b, c; cin >> a >> b >> c;\n\n\t\ttimes[a][b].second = max(times[a][b].second, c);\n\t\ttimes[a][b].first = vector<int>(1,b);\n\t}\n\tfor (int i = 0; i < V; ++i) {\n\t\ttimes[i][i] = make_pair(vector<int>(1,i),0);\n\t\t\n\t}\n\tlong long int amin = 0;\n\tlong long int amax = 1e6+10;\n\twhile (amin + 1 != amax) {\n\t\tlong long int amid((amin + amax) / 2);\n\t\tif (check(times,amid, K,false)) {\n\t\t\tamax = amid;\n\t\t}\n\t\telse {\n\t\t\tamin = amid;\n\t\t}\n\t}\n\tif (amax >1e6+5) {\n\t\tcout << -1 << endl;\n\t}\n\telse {\n\t\tcheck(times, amax, K,true);\n\t\tcout << amax << endl;\n\t\tif (amax <= 100) {\n\t\t\tfor (int i = 0; i < ans.size(); ++i) {\n\t\t\t\tcout << ans[i];\n\t\t\t\tif (i != ans.size() - 1)cout << \" \";\n\t\t\t\telse cout << endl;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 151;\n\ntemplate<typename T> class mat : public vector<vector<T> > {\nprivate:\n    int r,c;    //行,列\npublic:\n    int row() const {\n        return r;\n    }\n    int column() const {\n        return c;\n    }\n    mat(int n,int m,T val = 0){\n        this->r = n,this->c = m;\n        rep(i,n){\n            this->push_back(vector<T>(m,val));\n        }\n    }\n    mat operator+(const mat& another){\n        if(this->r != another.r && this->c != another.c){\n            cout << \"足し算失敗(サイズ不一致)\" << endl;\n            exit(1);\n        }\n        mat<T> X(this->r,this->c);\n        rep(i,this->r){\n            rep(j,this->c){\n                X[i][j] = (*this)[i][j] + another[i][j];\n            }\n        }\n        return X;\n    }\n    mat operator+(const T val){\n        mat<T> X(this->r,this->c);\n        rep(i,this->r){\n            rep(j,this->c){\n                X[i][j] = (*this)[i][j] + val;\n            }\n        }\n        return X;\n    }\n    mat operator-(const mat& another){\n        if(this->r != another.r && this->c != another.c){\n            cout << \"引き算失敗(サイズ不一致)\" << endl;\n            exit(1);\n        }\n        mat<T> X(this->r,this->c);\n        rep(i,this->r){\n            rep(j,this->c){\n                X[i][j] = (*this)[i][j] - another[i][j];\n            }\n        }\n        return X;\n    }\n    mat operator-(const T val){\n        mat<T> X(this->r,this->c);\n        rep(i,this->r){\n            rep(j,this->c){\n                X[i][j] = (*this)[i][j] - val;\n            }\n        }\n        return X;\n    }\n    vector<T> operator*(const vector<T>& another){\n        if(this->c != (int)another.size()){\n            cout << \"掛け算失敗(サイズ不一致)\" << endl;\n            exit(1);\n        }\n        vector<T> vec(this->r,0);\n        rep(i,this->r){\n            rep(j,this->c){\n                vec[i] += (*this)[i][j] * another[j];\n            }\n        }\n        return vec;\n    }\n    mat operator*(const mat& another){\n        if(this->c != another.r){\n            cout << \"掛け算失敗(サイズ不一致)\" << endl;\n            exit(1);\n        }\n        mat<T> X = *this;\n        rep(i,this->r){\n            for(int k=0;k<this->c;k+=4){\n                for(int j=0;j<another.c;j+=2){\n\t\t\t\t\tif((*this)[i][k]){\n\t\t\t\t\t\tif(another[k][j]){\n\t\t\t\t\t\t\tcmx(X[i][j],(*this)[i][k]+another[k][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(another[k][j+1]){\n\t\t\t\t\t\t\tcmx(X[i][j+1],(*this)[i][k]+another[k][j+1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif((*this)[i][k+1]){\n\t\t\t\t\t\tif(another[k+1][j]){\n\t\t\t\t\t\t\tcmx(X[i][j],(*this)[i][k+1]+another[k+1][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(another[k+1][j+1]){\n\t\t\t\t\t\t\tcmx(X[i][j+1],(*this)[i][k+1]+another[k+1][j+1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif((*this)[i][k+2]){\n\t\t\t\t\t\tif(another[k+2][j]){\n\t\t\t\t\t\t\tcmx(X[i][j],(*this)[i][k+2]+another[k+2][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(another[k+2][j+1]){\n\t\t\t\t\t\t\tcmx(X[i][j+1],(*this)[i][k+2]+another[k+2][j+1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif((*this)[i][k+3]){\n\t\t\t\t\t\tif(another[k+3][j]){\n\t\t\t\t\t\t\tcmx(X[i][j],(*this)[i][k+3]+another[k+3][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(another[k+3][j+1]){\n\t\t\t\t\t\t\tcmx(X[i][j+1],(*this)[i][k+3]+another[k+3][j+1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n            }\n        }\n        return X;\n    }\n    mat operator-(){\n        mat<T> X(this->r,this->c);\n        rep(i,this->r){\n            rep(j,this->c){\n                X[i][j] = -(*this)[i][j];\n            }\n        }\n        return X;\n    }\n    void print(){\n        rep(i,this->r){\n            rep(j,(this->c)-1){\n                cout << (*this)[i][j] << \",\";\n            }\n            cout << (*this)[i][(this->c)-1] << endl;\n        }\n    }\n};\n\ntemplate<typename T> mat<T> pow(mat<T> A,ll cnt)\n{\n    if(A.row() != A.column()){\n        cout << \"累乗不可\" << endl;\n    }\n\tmat<T> B = A;\n\t--cnt;\n\twhile(cnt>0){\n\t\tif(cnt & 1){\n\t\t\tB = B*A;\n\t\t}\n\t\tA = A*A;\n\t\tcnt >>= 1;\n\t}\n\treturn B;\n}\n\nstruct edge{\n\tint to,cost;\n};\n\nvector<edge> G[MAX_N];\n\nbool possible(mat<int>& A,const int cri,const int K)\n{\n\tint n = A.row();\n\tmat<int> res = pow(A,cri);\n\tint mx = 0;\n\trep(i,n){\n\t\trep(j,n){\n\t\t\tcmx(mx,res[i][j]);\n\t\t}\n\t}\n\treturn (mx >= K);\n}\n\nint mx[101][151];\nint pre[101][151];\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n,m,K;\n\tcin >> n >> m >> K;\n\tn = (n+3)/4*4;\n\tmat<int> A(n,n);\n\trep(i,m){\n\t\tint a,b,c;\n\t\tcin >> a >> b >> c;\n\t\tcmx(A[a][b],c);\n\t}\n\trep(i,n){\n\t\trep(j,n){\n\t\t\tif(A[i][j]){\n\t\t\t\tG[i].pb((edge){j,A[i][j]});\n\t\t\t}\n\t\t}\n\t}\n\tmat<int> res = pow(A,100);\n\tif(!possible(A,K,K)){\n\t\tcout << \"-1\\n\";\n\t\treturn 0;\n\t}\n\tint l = 0,r = K;\n\twhile(r-l>1){\n\t\tint mid = (l+r)/2;\n\t\tif(possible(A,mid,K)){\n\t\t\tr = mid;\n\t\t}else{\n\t\t\tl = mid;\n\t\t}\n\t}\n\tcout << r << \"\\n\";\n\tif(r > 100){\n\t\treturn 0;\n\t}\n\trep(i,r){\n\t\trep(j,n){\n\t\t\teach(e,G[j]){\n\t\t\t\tif(mx[i+1][e.to] < mx[i][j] + e.cost){\n\t\t\t\t\tmx[i+1][e.to] = mx[i][j] + e.cost;\n\t\t\t\t\tpre[i+1][e.to] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint cri = *max_element(mx[r],mx[r]+n);\n\tvector<int> ans;\n\trep(i,n){\n\t\tif(mx[r][i] == cri){\n\t\t\tint nw = i;\n\t\t\trrep(j,r+1){\n\t\t\t\tans.pb(nw);\n\t\t\t\tnw = pre[j][nw];\n\t\t\t}\n\t\t\treverse(all(ans));\n\t\t\teach(it,ans){\n\t\t\t\tcout << it << \" \";\n\t\t\t}\n\t\t\tcout << \"\\n\";\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int logMaxStep = 30;\n\ntypedef long long ll;\ntypedef vector< vector<ll> > Graph;\n\nint GetLogStep(int S) {\n\tint res;\n\tfor (res = 0; (1 << res) <= S; ++res);\n\treturn res;\n}\nGraph nextG(const Graph& g1, const Graph& g2) {\n\tint N = g1.size();\n\tGraph res(N, vector<ll>(N, 0));\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tfor (int k = 0; k < N; ++k) {\n\t\t\t\tif (g1[i][k] > 0 && g2[k][j] > 0) {\n\t\t\t\t\tres[i][j] = max(res[i][j], g1[i][k]+g2[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nvector<int> nextDP(vector<ll>& dp, Graph& g) {\n\tint N = g.size();\n\tvector<int> prevV(N, -1);\n\tvector<ll> ndp(N, -1);\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tif (dp[i] >= 0 && g[i][j] > 0) {\n\t\t\t\tif (dp[i]+g[i][j] > ndp[j]) {\n\t\t\t\t\tndp[j] = dp[i]+g[i][j];\n\t\t\t\t\tprevV[j] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tdp[i] = ndp[i];\n\t}\n\treturn prevV;\n}\nll GetMaxScore(vector<Graph>& powG, int S) {\n\tint N = powG[0].size();\n\tint logS = GetLogStep(S);\n\tvector<ll> dp(N, 0);\n\tfor (int i = 0; i < logS; ++i) {\n\t\tGraph& g = powG[i];\n\t\tif ( (1 << i) & S ) {\n\t\t\tnextDP(dp, g);\n\t\t}\n\t}\n\tll res = -1;\n\tfor (int i = 0; i < dp.size(); ++i) {\n\t\tres = max(res, dp[i]);\n\t}\n\treturn res;\n}\nbool check200Step(Graph& G, int K) {\n\tint N = G.size();\n\tvector<ll> dp(N, 0);\n\tvector< vector<int> > prevV;\n\tll lastAns = -1;\n\tfor (int t = 0; t < 200; ++t) {\n\t\tprevV.push_back( nextDP(dp, G) );\n\t\tint aid = 0;\n\t\tfor (int i = 0; i < dp.size(); ++i) {\n\t\t\tif (dp[i] > dp[aid]) aid = i;\n\t\t}\n\t\tif (dp[aid] >= K) {\n\t\t\tcout << t+1 << endl;\n\t\t\tif (t+1 <= 100) {\n\t\t\t\tvector<int> vl;\n\t\t\t\tint v = aid; vl.push_back(v);\n\t\t\t\tfor (int i = t; i >= 0; --i) {\n\t\t\t\t\tv = prevV[i][v];\n\t\t\t\t\tvl.push_back(v);\n\t\t\t\t}\n\t\t\t\treverse(vl.begin(), vl.end());\n\t\t\t\tfor (int i = 0; i < vl.size(); ++i) {\n\t\t\t\t\tif (i) cout << \" \";\n\t\t\t\t\tcout << vl[i];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t\tlastAns = dp[aid];\n\t}\n\tif (lastAns < 0) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\nint main() {\n\tint N, E, K; cin >> N >> E >> K;\n\tGraph G(N, vector<ll>(N, 0));\n\tfor (int i = 0; i < E; ++i) {\n\t\tint a, b; ll c; cin >> a >> b >> c;\n\t\tG[a][b] = max(G[a][b], c);\n\t}\n\tint result = check200Step(G, K);\n\tif (result == 0) {\n\t\tvector<Graph> powG(logMaxStep+1); powG[0] = G;\n\t\tfor (int i = 0; i < logMaxStep; ++i) {\n\t\t\tpowG[i+1] = nextG(powG[i], powG[i]);\n\t\t}\n\n\t\tint l = 0, r = K+1;\n\t\tfor (int t = 0; t < logMaxStep; ++t) {\n\t\t\tint m = (l + r) / 2;\n\t\t\tif ( GetMaxScore(powG, m) >= K ) {\n\t\t\t\tr = m;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tl = m;\n\t\t\t}\n\t\t}\n\t\tassert(r <= K);\n\t\tcout << r << endl;\n\t}\n\telse if (result == -1) {\n\t\tcout << -1 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#define bigas(a,b) if(a<b){a=b;}\nusing namespace std;\nint main(void){\n\tint h=0,i=0,j=0,m=0,ex=0,ans=0,V,E,K,x,y,z;\n\tstatic int ya[18][150][150]={0};//ya[i][x][y]???x??????y???2^i??¬???????????´????????¢??°?????????\n\tstatic int gen[150]={0};//gen[x]???x??´??????????????§?????°\n\tstatic int ima[150]={0};\n\tstatic int pre[101][150]={0};//??????????????\\??????\n\tstatic int poi[101][150]={0};//??????\n\tscanf(\"%d %d %d\",&V,&E,&K);\n\tfor(i=0;i<E;i++){\n\t\tscanf(\"%d %d %d\",&x,&y,&z);\n\t\tbigas(ya[0][x][y],z);\n\t}\n\tfor(h=1;h<101;h++){\n\t\tfor(i=0;i<V;i++){\n\t\t\tfor(j=0;j<V;j++){\n\t\t\t\tif(poi[h][j]<poi[h-1][i]+ya[0][i][j]){\n\t\t\t\t\tpoi[h][j]=poi[h-1][i]+ya[0][i][j];\n\t\t\t\t\tpre[h][j]=i;\n\t\t\t\t\tif(poi[h][j]>K){ex=1;K=poi[h][j];ans=j;}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ex==1){break;}\n\t}\n\tif(ex==1){\n\t\tprintf(\"%d\\n\",h);\n\t\tima[h]=ans;\n\t\tfor(i=h-1;i>=0;i--){\n\t\t\tima[i]=pre[i+1][ima[i+1]];\n\t\t}\n\t\tfor(i=0;i<=h;i++){\n\t\t\tprintf(\"%d \",ima[i]);\n\t\t}\n\t\treturn 0;\n\t}\n\tfor(h=1;h<17;h++){//2^i??¬????±???????\n\t\tfor(i=0;i<V;i++){//i??????\n\t\t\tfor(j=0;j<V;j++){//j?????§\n\t\t\t\tfor(m=0;m<V;m++){//m????????£???\n\t\t\t\t\tbigas{ya[h][i][j],ya[h-1][i][m]+ya[h-1][m][j]};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//??????????????¬??°??????????????§????±???????\n\tfor(h=17;h>=0;h--){\n\t\tfor(i=0;i<V;i++){\n\t\t\tfor(j=0;j<V;j++){\n\t\t\t\tima[j]=gen[i]+ya[h][i][j];\n\t\t\t\tif(ima[j]>=K){ex=1;break;}\n\t\t\t}\n\t\t\tif(ex==1){break;}\n\t\t}\n\t\tif(ex==0){\n\t\t\tans+=(1<<h);\n\t\t\tfor(i=0;i<V;i++){\n\t\t\tgen[i]=ima[i];\n\t\t\t}\n\t\t}\n\t\tex=0;\n\t}\n\tans++;\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i< (int)(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define iter(c) __typeof((c).begin())\n#define pb(e) push_back(e)\n#define foreach(c, i) for(iter(c) i = (c).begin(); i != c.end(); ++i)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> vec;\ntypedef vector<vec> mat;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\n\nconst int sz = 25;\nmat memo[sz];\nll g[200][200];\nint dp[200][200];\nint pre[200][200];\n\nmat mul(const mat &A, const mat &B){\n  int n = A.size();\n  int m = B[0].size();\n  mat C(n, vec(m, 0));\n  rep(i, n)rep(j, m)rep(k, A[0].size()){\n    if(A[i][k] > 0 && B[k][j] > 0) C[i][j] = max(A[i][k] + B[k][j], C[i][j]);\n  }\n  return C;\n}\n\nvoid init(int V, int E){\n  mat A = mat(V, vec(V, 0));\n  int f, t;\n  ll c;\n  rep(i, E){\n    cin >> f >> t >> c;\n    A[f][t] = max(A[f][t], c);\n    g[f][t] = max(g[f][t], c);\n  }\n  memo[0] = A;\n  rep(i, sz - 1) memo[i+1] = mul(memo[i], memo[i]);\n}\n\nvoid calc(int V, int R, int K){\n  rep(i, R)rep(j, V)rep(k, V){\n    if(g[j][k] > 0 && (i == 0 || dp[i][j] > 0) && dp[i+1][k] < dp[i][j] + g[j][k]){\n      dp[i+1][k] = dp[i][j] + g[j][k];\n      pre[i+1][k] = j;\n    }\n  }\n\n  int v = 0;\n  int best = -1;\n  rep(i, V) if(dp[R][i] > best){\n    v = i;\n    best = dp[R][i];\n  }\n  \n  vector<int> res;\n  res.push_back(v);\n  for(int i = R; i > 0; i--){\n    v = pre[i][v];\n    res.push_back(v);\n  }\n  //cout << res.size() << endl;\n  reverse(res.begin(), res.end());\n  rep(i, res.size()) cout << res[i] << (i == (int)res.size() - 1 ? '\\n' : ' ');\n}\n\nint main(){\n  int V, E, K, i, res = 0;\n  cin >> V >> E >> K;\n  init(V, E);\n\n  mat A;\n  \n  for(i = sz - 1; i >= 0; i--){\n    bool ok = false;\n    rep(j, V)rep(k, V) if(j != k && memo[i][j][k] >= K) ok = true;\n    if(!ok){\n      res += 1 << i;\n      A = memo[i--];\n      break;\n    }\n  }\n  \n  for(; i >= 0; i--){\n    mat B = mul(A, memo[i]);\n    bool ok = false;\n    rep(j, V)rep(k, V) if(j != k && B[j][k] >= K){\n      ok = true;\n      break;\n    }\n    if(!ok){\n      res += 1 << i;\n      A = B;\n    }\n  }\n  res++;\n  //resは経由する矢印の数\n  \n  if(res == (1 << sz)){\n    cout << -1 << endl;\n  }else {\n    cout << res << endl;\n    if(res  <= 100) calc(V, res, K);\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int logMaxStep = 30;\n\ntypedef long long ll;\ntypedef vector< vector<ll> > Graph;\n\nint GetLogStep(int S) {\n\tint res;\n\tfor (res = 0; (1 << res) <= S; ++res);\n\treturn res;\n}\nGraph nextG(const Graph& g1, const Graph& g2) {\n\tint N = g1.size();\n\tGraph res(N, vector<ll>(N, 0));\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tfor (int k = 0; k < N; ++k) {\n\t\t\t\tif (g1[i][k] > 0 && g2[k][j] > 0) {\n\t\t\t\t\tres[i][j] = max(res[i][j], g1[i][k]+g2[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nvector<int> nextDP(vector<ll>& dp, Graph& g) {\n\tint N = g.size();\n\tvector<int> prevV(N, -1);\n\tvector<ll> ndp(N, -1);\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tif (dp[i] >= 0 && g[i][j] > 0) {\n\t\t\t\tif (dp[i]+g[i][j] > ndp[j]) {\n\t\t\t\t\tndp[j] = dp[i]+g[i][j];\n\t\t\t\t\tprevV[j] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tdp[i] = ndp[i];\n\t}\n\treturn prevV;\n}\nll GetMaxScore(vector<Graph>& powG, int S) {\n\tint N = powG[0].size();\n\tint logS = GetLogStep(S);\n\tvector<ll> dp(N, 0);\n\tfor (int i = 0; i < logS; ++i) {\n\t\tGraph& g = powG[i];\n\t\tif ( (1 << i) & S ) {\n\t\t\tnextDP(dp, g);\n\t\t}\n\t}\n\tll res = -1;\n\tfor (int i = 0; i < dp.size(); ++i) {\n\t\tres = max(res, dp[i]);\n\t}\n\treturn res;\n}\nint check200Step(Graph& G, int K) {\n\tint N = G.size();\n\tvector<ll> dp(N, 0);\n\tvector< vector<int> > prevV;\n\tll lastAns = -1;\n\tfor (int t = 0; t < 200; ++t) {\n\t\tprevV.push_back( nextDP(dp, G) );\n\t\tint aid = 0;\n\t\tfor (int i = 0; i < dp.size(); ++i) {\n\t\t\tif (dp[i] > dp[aid]) aid = i;\n\t\t}\n\t\tif (dp[aid] >= K) {\n\t\t\tcout << t+1 << endl;\n\t\t\tif (t+1 <= 100) {\n\t\t\t\tvector<int> vl;\n\t\t\t\tint v = aid; vl.push_back(v);\n\t\t\t\tfor (int i = t; i >= 0; --i) {\n\t\t\t\t\tv = prevV[i][v];\n\t\t\t\t\tvl.push_back(v);\n\t\t\t\t}\n\t\t\t\treverse(vl.begin(), vl.end());\n\t\t\t\tfor (int i = 0; i < vl.size(); ++i) {\n\t\t\t\t\tif (i) cout << \" \";\n\t\t\t\t\tcout << vl[i];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t\tlastAns = dp[aid];\n\t}\n\tif (lastAns < 0) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\nint main() {\n\tint N, E, K; cin >> N >> E >> K;\n\tGraph G(N, vector<ll>(N, 0));\n\tfor (int i = 0; i < E; ++i) {\n\t\tint a, b; ll c; cin >> a >> b >> c;\n\t\tG[a][b] = max(G[a][b], c);\n\t}\n\tint result = check200Step(G, K);\n\tif (result == 0) {\n\t\tvector<Graph> powG(logMaxStep+1); powG[0] = G;\n\t\tfor (int i = 0; i < logMaxStep; ++i) {\n\t\t\tpowG[i+1] = nextG(powG[i], powG[i]);\n\t\t}\n\n\t\tfor (int i = N; i <= N+100; ++i) {\n\t\t\tassert(GetMaxScore(powG, i+1) > GetMaxScore(powG, i));\n\t\t}\n\t\tint l = 0, r = K+1;\n\t\tfor (int t = 0; t < logMaxStep; ++t) {\n\t\t\tint m = (l + r) / 2;\n\t\t\tif ( GetMaxScore(powG, m) >= K ) {\n\t\t\t\tr = m;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tl = m;\n\t\t\t}\n\t\t}\n\t\tassert(r - l <= 1);\n\t\tassert(r <= K);\n\t\tcout << r << endl;\n\t}\n\telse if (result == -1) {\n\t\tcout << -1 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\nint V,E,K;\nconst int INF = (1<<30);\nmat G;\n\nmat g[30];\nmat u[30];\n\nint add(int a,int b){\n  if(a==-INF||b==-INF)return -INF;\n  return min(a+b,K);\n}\n\npair<mat,mat> merge(mat A,mat B, bool flag=false){\n  mat X( V, vec(V, -INF) );\n  mat Y( V, vec(V, -INF) );\n  \n  for(int from=0;from<V;from++){\n    for(int to=0;to<V;to++){\n      for(int ex=0;ex<V;ex++){\n        int cost=add(A[from][ex],B[ex][to]);\n        if(X[from][to]<cost){\n          X[from][to]=cost;\n          Y[from][to]=ex;\n        }\n      }\n    }\n  }\n  return make_pair(X,Y);\n}\n\n\nint calc(int m,int &si,int &ti){\n  mat t;\n  for(int i=0;i<30;i++){\n    if(m>>i&1){\n      if(t.empty()){\n        t=g[i];\n      }else{\n        t=merge(t,g[i]).first;\n      }\n    }\n  }\n  \n  int res=-INF;\n  for(int i=0;i<V;i++){\n    for(int j=0;j<V;j++){\n      if(res<t[i][j]){\n        si=i;\n        ti=j;\n        res=t[i][j];\n      }\n    }\n  }\n  return res;\n}\n\nvoid Dfs(vec& s,int from,int to,int len){\n  if(len==0)return;\n  \n  for(int i=0;i<30;i++){\n    if(~len>>i&1)continue;\n    int ex=u[i][from][to];\n\n    if(i==0){\n      if(len>=2)s.push_back(ex);\n      Dfs(s,ex,to,len-1);\n    }else{\n      int sub=(1<<i)/2;\n      Dfs(s,from,ex,sub);\n      s.push_back(ex);\n      Dfs(s,ex,to,len-sub);\n    }\n    break;\n  }\n}\n\nint main(){\n  cin>>V>>E>>K;\n  G=mat( V, vec(V, -INF) );\n  for(int i=0;i<V;i++)G[i][i]=0;\n  \n  g[0]=u[0]=G;\n  for(int i=0;i<E;i++){\n    int a,b,c;\n    cin>>a>>b>>c;\n    G[a][b]=max(G[a][b],c);\n    \n    g[0][a][b]=max(g[0][a][b],c);\n    u[0][a][b]=b;\n  }\n\n  \n  for(int i=1;i<30;i++){\n    pair<mat,mat> temp=merge(g[i-1],g[i-1]);\n    g[i]=temp.first;\n    u[i]=temp.second;\n  }\n\n\n  int si,ti;\n  int left=1,right=K+1,mid;\n\n  while( left < right ){\n    mid=(left+right)/2;\n    if( calc(mid,si,ti) >= K ){\n      right=mid;\n    }else{\n      left=mid+1;\n    }\n  }\n\n  for(int i=0;i<V;i++)g[0][i][i]=-INF;\n  for(int i=1;i<30;i++){\n    pair<mat,mat> temp=merge(g[i-1],g[i-1]);\n    g[i]=temp.first;\n    u[i]=temp.second;\n  }\n  \n  if(left==K+1){\n    cout<<-1<<endl;\n  }else{\n    cout<<left<<endl;\n    if(left<=100){\n      vec tab;\n      tab.push_back(si);\n      Dfs(tab,si,ti,left);\n      tab.push_back(ti);\n      //      cout<<tab.size()<<endl;\n      for(int i=0;i<(int)tab.size();i++){\n        if(i)cout<<' ';\n        cout<<tab[i];\n      }\n      cout<<endl;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<int(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nconstexpr int INF = 1000000000;\n\nusing Array = vector<int>;\nusing Matrix = vector<Array>;\n\nMatrix mul(const Matrix& lhs, const Matrix& rhs) {\n  int r = lhs.size();\n  Matrix res(r, Array(r, -INF));\n  REP(i,r) REP(k,r) REP(j,r) {\n    res[i][j] = max(res[i][j], lhs[i][k] + rhs[k][j]);\n  }\n  return res;\n}\n\nMatrix pow(const Matrix& mat, int index) {\n  if (index == 0) {\n    int v = mat.size();\n    Matrix res(v, Array(v, -INF));\n    REP(i,v) res[i][i] = 0;\n    return res;\n  }\n  if (index == 1) return mat;\n  if ((index % 2) == 1) {\n    return mul(mat, pow(mat, index-1));\n  }\n  return pow(mul(mat, mat), index/2);\n}\n\nint main() {\n  int v,e,k;\n  cin>>v>>e>>k;\n  Matrix mat(v, Array(v, -INF));\n  REP(i,e) {\n    int s,t,c;\n    cin>>s>>t>>c;\n    mat[s][t] = max(mat[s][t], c);\n  }\n  int hi = k;\n  int lo = 0;\n  while (hi - lo > 1) {\n    int mid = (hi + lo) / 2;\n    auto pmat = pow(mat, mid);\n    int mx = -INF;\n    REP(i,v)REP(j,v) mx = max(mx, pmat[i][j]);\n    if (mx > k - 100 * v) {\n      hi = mid;\n    } else {\n      lo = mid;\n    }\n  }\n  lo = max(0, lo - v * 100);\n  auto pmat = pow(mat, lo);\n  vector<int> score(v, -INF);\n  REP(i,v)REP(j,v) score[j] = max(score[j], pmat[i][j]);\n  REP(cnt,200 * v) {\n    vector<int> tmp(v, -INF);\n    REP(i,v)REP(j,v) tmp[j] = max(tmp[j], score[i] + mat[i][j]);\n    int mx = -INF;\n    REP(i,v) mx = max(mx, tmp[i]);\n    swap(score, tmp);\n    if (mx >= k) {\n      lo += cnt + 1;\n      break;\n    }\n  }\n  if (lo > 0 && lo <= k) {\n    cout << lo << endl;\n  } else {\n    cout << -1 << endl;\n    return 0;\n  }\n  if (hi > 100) {\n    return 0;\n  }\n  vector<vector<int>> vscore;\n  REP(i,v) score[i] = 0;\n  REP(cnt,lo) {\n    vector<int> tmp(v, -INF);\n    REP(i,v)REP(j,v) tmp[j] = max(tmp[j], score[i] + mat[i][j]);\n    int mx = -INF;\n    REP(i,v) mx = max(mx, tmp[i]);\n    vscore.push_back(score);\n    swap(score, tmp);\n  }\n  int t = 0;\n  int mx = -INF;\n  REP(i,v) {\n    if (score[i] > mx) {\n      mx = score[i];\n      t = i;\n    }\n  }\n  vector<int> res;\n  res.push_back(t);\n  for (int i = lo-1; i >= 0; --i) {\n    int nt = 0;\n    int nmx = -INF;\n    REP(j,v) {\n      if (vscore[i][j] + mat[j][t] == mx) {\n        nt = j;\n        nmx = vscore[i][j];\n      }\n    }\n    t = nt;\n    mx = nmx;\n    res.push_back(t);\n  }\n  reverse(ALL(res));\n  REP(i,res.size()) {\n    if (i) cout << ' ';\n    cout << res[i];\n  }\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\ntypedef long long int Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\n\nbool operator < (const Edge &e, const Edge &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<vector<pair<vector<int>, long long int>>>type;\nint V, E, K;\n type time(const type&lts, const type&rts, const bool flag) {\n\ttype squs(V,vector<pair<vector<int>,long long int>>(V));\n\tfor (int i = 0; i < V; ++i) {\n\t\tfor (int j = 0; j < V; ++j) {\n\t\t\tif (i == j)squs[i][j] = make_pair(vector<int>(), 0ll);\n\t\t\telse squs[i][j] = make_pair(vector<int>(), static_cast<long long>(-1e17));\n\t\t}\n\t}\n\tfor (int k = 0; k < V; ++k) {\n\t\tfor (int i = 0; i < V; ++i) {\n\t\t\tfor (int j = 0; j < V; ++j) {\n\t\t\t\tif (squs[i][j].second <lts[i][k].second + rts[k][j].second) {\n\t\t\t\t\tsqus[i][j].second = lts[i][k].second + rts[k][j].second;\n\t\t\t\t\tif (flag) {\n\t\t\t\t\t\tsqus[i][j].first.clear();\n\t\t\t\t\t\tsqus[i][j].first.insert(squs[i][j].first.end(), lts[i][k].first.begin(), lts[i][k].first.end());\n\t\t\t\t\t\tsqus[i][j].first.insert(squs[i][j].first.end(), rts[k][j].first.begin(), rts[k][j].first.end());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn squs;\n}\ntype square(const type&ts,bool flag) {\n\treturn time(ts, ts, flag);\n}\n\ntype power(const type&ts,const long long  int num,const bool flag) {\n\tassert(num);\n\tif (num == 1)return ts;\n\telse {\n\t\ttype pot(square(power(ts,num/2,flag),flag));\n\t\tif (num % 2) {\n\t\t\tpot = time(pot, ts, flag);\n\t\t}\n\t\treturn pot;\n\t}\n}\nvector<int>ans;\nbool check(const type &ts,const long long int run,const int point,const bool flag) {\n\t\n\ttype t(power(ts, run, flag&&run <= 100));\n\tlong long int amax = 0;\n\tfor (int i = 0; i < V; ++i) {\n\t\tfor (int j = 0; j < V; ++j) {\n\t\t\tif (amax < t[i][j].second) {\n\t\t\t\tamax = t[i][j].second;\n\t\t\t\tif (run <= 100&&flag) {\n\t\t\t\t\tans = t[i][j].first;\n\t\t\t\t\tans.insert(ans.begin(), i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (amax >= point)return true;\n\telse return false;\n}\n\nint main() { cin >> V >> E >> K;\n\ttype times(V, vector<pair<vector<int>,long long int>>(V, make_pair(vector<int>(),static_cast<long long int>(-1e18))));\n\tfor (int i = 0; i < E; ++i) {\n\t\tlong long int a, b, c; cin >> a >> b >> c;\n\n\t\ttimes[a][b].second = max(times[a][b].second, c);\n\t\ttimes[a][b].first = vector<int>(1,b);\n\t}\n\tfor (int i = 0; i < V; ++i) {\n\t\ttimes[i][i] = make_pair(vector<int>(1,i),0);\n\t\t\n\t}\n\tlong long int amin = 0;\n\tlong long int amax = 2e6;\n\twhile (amin + 1 != amax) {\n\t\tlong long int amid((amin + amax) / 2);\n\t\tif (check(times,amid, K,false)) {\n\t\t\tamax = amid;\n\t\t}\n\t\telse {\n\t\t\tamin = amid;\n\t\t}\n\t}\n\tif (amax >2e6-10) {\n\t\tcout << -1 << endl;\n\t}\n\telse {\n\t\tcheck(times, amax, K,true);\n\t\tcout << amax << endl;\n\t\tif (amax <= 100) {\n\t\t\tfor (int i = 0; i < ans.size(); ++i) {\n\t\t\t\tcout << ans[i];\n\t\t\t\tif (i != ans.size() - 1)cout << \" \";\n\t\t\t\telse cout << endl;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<int(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nconstexpr int INF = 1000000000;\n\nusing Array = vector<int>;\nusing Matrix = vector<Array>;\n\nMatrix mul(const Matrix& lhs, const Matrix& rhs) {\n  int r = lhs.size();\n  Matrix res(r, Array(r, -INF));\n  REP(i,r) REP(k,r) REP(j,r) {\n    res[i][j] = max(res[i][j], lhs[i][k] + rhs[k][j]);\n  }\n  return res;\n}\n\nMatrix pow(const Matrix& mat, int index) {\n  if (index == 0) {\n    int v = mat.size();\n    Matrix res(v, Array(v, -INF));\n    REP(i,v) res[i][i] = 0;\n    return res;\n  }\n  if (index == 1) return mat;\n  if ((index % 2) == 1) {\n    return mul(mat, pow(mat, index-1));\n  }\n  return pow(mul(mat, mat), index/2);\n}\n\nint main() {\n  int v,e,k;\n  cin>>v>>e>>k;\n  Matrix mat(v, Array(v, -INF));\n  REP(i,e) {\n    int s,t,c;\n    cin>>s>>t>>c;\n    mat[s][t] = max(mat[s][t], c);\n  }\n  vector<int> score(v, 0);\n  int hi = k;\n  int lo = 0;\n  while (hi - lo > 100 * v) {\n    int mid = (hi + lo) / 2;\n    auto pmat = pow(mat, mid);\n    int mx = -INF;\n    REP(i,v)REP(j,v) mx = max(mx, pmat[i][j]);\n    if (mx > k - 100 * v) {\n      hi = mid;\n    } else {\n      lo = mid;\n    }\n  }\n  auto pmat = pow(mat, lo);\n  REP(i,v)REP(j,v) score[j] = max(score[j], pmat[i][j]);\n  REP(cnt,k) {\n    vector<int> tmp(v, -INF);\n    REP(i,v)REP(j,v) tmp[j] = max(tmp[j], score[i] + mat[i][j]);\n    int mx = -INF;\n    REP(i,v) mx = max(mx, tmp[i]);\n    swap(score, tmp);\n    if (mx >= k) {\n      lo += cnt + 1;\n      break;\n    }\n  }\n  if (lo > 0 && lo <= k) {\n    cout << lo << endl;\n  } else {\n    cout << -1 << endl;\n    return 0;\n  }\n  if (hi > 100) {\n    return 0;\n  }\n  vector<vector<int>> vscore;\n  REP(i,v) score[i] = 0;\n  REP(cnt,lo) {\n    vector<int> tmp(v, -INF);\n    REP(i,v)REP(j,v) tmp[j] = max(tmp[j], score[i] + mat[i][j]);\n    int mx = -INF;\n    REP(i,v) mx = max(mx, tmp[i]);\n    vscore.push_back(score);\n    swap(score, tmp);\n  }\n  int t = 0;\n  int mx = -INF;\n  REP(i,v) {\n    if (score[i] > mx) {\n      mx = score[i];\n      t = i;\n    }\n  }\n  vector<int> res;\n  res.push_back(t);\n  for (int i = lo-1; i >= 0; --i) {\n    int nt = 0;\n    int nmx = -INF;\n    REP(j,v) {\n      if (vscore[i][j] + mat[j][t] == mx) {\n        nt = j;\n        nmx = vscore[i][j];\n      }\n    }\n    t = nt;\n    mx = nmx;\n    res.push_back(t);\n  }\n  reverse(ALL(res));\n  REP(i,res.size()) {\n    if (i) cout << ' ';\n    cout << res[i];\n  }\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\ntypedef long long int Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\n\nbool operator < (const Edge &e, const Edge &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<vector<pair<vector<int>, long long int>>>type;\nint V, E, K;\n type time(const type&lts, const type&rts, const bool flag) {\n\ttype squs(V,vector<pair<vector<int>,long long int>>(V));\n\tfor (int i = 0; i < V; ++i) {\n\t\tfor (int j = 0; j < V; ++j) {\n\t\t\tif (i == j)squs[i][j] = make_pair(vector<int>(), 0ll);\n\t\t\telse squs[i][j] = make_pair(vector<int>(), static_cast<long long>(-1e17));\n\t\t}\n\t}\n\tfor (int k = 0; k < V; ++k) {\n\t\tfor (int i = 0; i < V; ++i) {\n\t\t\tfor (int j = 0; j < V; ++j) {\n\t\t\t\tif (squs[i][j].second <lts[i][k].second + rts[k][j].second) {\n\t\t\t\t\tsqus[i][j].second = lts[i][k].second + rts[k][j].second;\n\t\t\t\t\tif (flag) {\n\t\t\t\t\t\tsqus[i][j].first.clear();\n\t\t\t\t\t\tsqus[i][j].first.insert(squs[i][j].first.end(), lts[i][k].first.begin(), lts[i][k].first.end());\n\t\t\t\t\t\tsqus[i][j].first.insert(squs[i][j].first.end(), rts[k][j].first.begin(), rts[k][j].first.end());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn squs;\n}\ntype square(const type&ts,bool flag) {\n\treturn time(ts, ts, flag);\n}\n\ntype power(const type&ts,const long long  int num,const bool flag) {\n\tassert(num);\n\tif (num == 1)return ts;\n\telse {\n\t\ttype pot(square(power(ts,num/2,flag),flag));\n\t\tif (num % 2) {\n\t\t\tpot = time(pot, ts, flag);\n\t\t}\n\t\treturn pot;\n\t}\n}\nvector<int>ans;\nbool check(const type &ts,const long long int run,const int point,const bool flag) {\n\t\n\ttype t(power(ts, run, flag&&run <= 100));\n\tlong long int amax = 0;\n\tint ai = -1;\n\tint aj = -1;\n\tfor (int i = 0; i < V; ++i) {\n\t\tfor (int j = 0; j < V; ++j) {\n\t\t\tif (amax < t[i][j].second) {\n\t\t\t\tamax = t[i][j].second;\n\t\t\t\tai = i;\n\t\t\t\taj = j;\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}if (run <= 100 && flag) {\n\t\tans.clear();\n\t\tans.push_back(ai);\n\t\tans.insert(ans.end(), t[ai][aj].first.begin(), t[ai][aj].first.end());\n\t}\n\tif (amax >= point)return true;\n\telse return false;\n}\n\nint main() { cin >> V >> E >> K;\n\ttype times(V, vector<pair<vector<int>,long long int>>(V, make_pair(vector<int>(),static_cast<long long int>(-1e18))));\n\tfor (int i = 0; i < E; ++i) {\n\t\tlong long int a, b, c; cin >> a >> b >> c;\n\n\t\ttimes[a][b].second = max(times[a][b].second, c);\n\t\ttimes[a][b].first = vector<int>(1,b);\n\t}\n\tfor (int i = 0; i < V; ++i) {\n\t\ttimes[i][i] = make_pair(vector<int>(1,i),0);\n\t\t\n\t}\n\tlong long int amin = 0;\n\tlong long int amax = 1e6+10;\n\twhile (amin + 1 != amax) {\n\t\tlong long int amid((amin + amax) / 2);\n\t\tif (check(times,amid, K,false)) {\n\t\t\tamax = amid;\n\t\t}\n\t\telse {\n\t\t\tamin = amid;\n\t\t}\n\t}\n\tif (amax >1e6+5) {\n\t\tcout << -1 << endl;\n\t}\n\telse {\n\t\tcheck(times, amax, K,true);\n\t\tcout << amax << endl;\n\t\tif (amax <= 100) {\n\t\t\tfor (int i = 0; i < ans.size(); ++i) {\n\t\t\t\tcout << ans[i];\n\t\t\t\tif (i != ans.size() - 1)cout << \" \";\n\t\t\t\telse cout << endl;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n//stl????????????\n//I don't know STL???\n//I plactice now???\n//OH! WRONG ANSWER!!\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#define bigas(a,b) if(a<b){a=b;}\nusing namespace std;\nint main(void){\n\tint h=0,i=0,j=0,m=0,ex=0,ans=0,V,E,K,x,y,z;\n\tstatic int ya[18][150][150]={0};//ya[i][x][y]???x??????y???2^i??¬???????????´????????¢??°?????????\n\tstatic int gen[150]={0};//gen[x]???x??´??????????????§?????°\n\tstatic int ima[150]={0};\n\tstatic int pre[101][150]={0};//??????????????\\??????\n\tstatic int poi[101][150]={0};//??????\n\tfor(h=0;h<18;h++){\n\t\tfor(i=0;i<150;i++){\n\t\t\tfor(j=0;j<150;j++){\n\t\t\t\tya[h][i][j]=-(1<<30);\n\t\t\t\tif(i==j){ya[h][i][j]=0;}\n\t\t\t}\n\t\t}\n\t}\n\tscanf(\"%d %d %d\",&V,&E,&K);\n\tfor(i=0;i<E;i++){\n\t\tscanf(\"%d %d %d\",&x,&y,&z);\n\t\tbigas(ya[0][x][y],z);\n\t}\n\tfor(h=1;h<101;h++){\n\t\tfor(i=0;i<V;i++){\n\t\t\tfor(j=0;j<V;j++){\n\t\t\t\tif(poi[h][j]<poi[h-1][i]+ya[0][i][j]){\n\t\t\t\t\tpoi[h][j]=poi[h-1][i]+ya[0][i][j];\n\t\t\t\t\tpre[h][j]=i;\n\t\t\t\t\tif(poi[h][j]>=K){ex=1;K=poi[h][j];ans=j;}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ex==1){break;}\n\t}\n\tif(ex==1){\n\t\tprintf(\"%d\\n\",h);\n\t\tima[h]=ans;\n\t\tfor(i=h-1;i>=0;i--){\n\t\t\tima[i]=pre[i+1][ima[i+1]];\n\t\t}\n\t\tfor(i=0;i<=h;i++){\n\t\t\tprintf(\"%d \",ima[i]);\n\t\t}\n\t\treturn 0;\n\t}\n\th=0,i=0,j=0,m=0,ex=0,ans=0;\n\t\n\t//??????????????§????????????????§£???\n\tfor(h=1;h<18;h++){//2^i??¬????±???????\n\t\tfor(i=0;i<V;i++){//i??????\n\t\t\tfor(j=0;j<V;j++){//j?????§\n\t\t\t\tfor(m=0;m<V;m++){//m????????£???\n\t\t\t\t\tbigas(ya[h][i][j],ya[h-1][i][m]+ya[h-1][m][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//??????????????¬??°??????????????§????±???????\n\tfor(h=17;h>=0;h--){\n\t\tfor(i=0;i<V;i++){\n\t\t\tfor(j=0;j<V;j++){\n\t\t\t\tbigas(ima[j],gen[i]+ya[h][i][j]);\n\t\t\t\tif(ima[j]>=K){ex=1;break;}\n\t\t\t}\n\t\t}\n\t\tif(ex==0){\n\t\t\tans+=(1<<h);\n\t\t\tfor(i=0;i<V;i++){\n\t\t\tgen[i]=ima[i];\n\t\t\t}\n\t\t}else{\n\t\t\tfor(i=0;i<V;i++){\n\t\t\tima[i]=gen[i];\n\t\t\t}\n\t\t}\n\t\tex=0;\n\t}\n\tans++;\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<int(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nconstexpr int64_t INF = INT64_C(1000000000000000000);\n\nusing Array = vector<int64_t>;\nusing Matrix = vector<Array>;\n\nMatrix mul(const Matrix& lhs, const Matrix& rhs) {\n  int r = lhs.size();\n  Matrix res(r, Array(r, -INF));\n  REP(i,r) REP(k,r) REP(j,r) {\n    res[i][j] = max(res[i][j], lhs[i][k] + rhs[k][j]);\n  }\n  return res;\n}\n\nMatrix pow(const Matrix& mat, int64_t index) {\n  if (index == 1) return mat;\n  if ((index % 2) == 1) {\n    return mul(mat, pow(mat, index-1));\n  }\n  return pow(mul(mat, mat), index/2);\n}\n\nint main() {\n  int64_t v,e,k;\n  cin>>v>>e>>k;\n  Matrix mat(v, Array(v, -INF));\n  REP(i,e) {\n    int64_t s,t,c;\n    cin>>s>>t>>c;\n    mat[s][t] = max(mat[s][t], c);\n  }\n  int64_t hi = k;\n  int64_t lo = 0;\n  while (hi - lo > 1) {\n    int64_t mid = (hi + lo) / 2;\n    auto pmat = pow(mat, mid);\n    int64_t mx = -INF;\n    REP(i,v)REP(j,v) mx = max(mx, pmat[i][j]);\n    if (mx < 0) {\n      hi = mid;\n    } else if (mx >= k) {\n      hi = mid;\n    } else {\n      lo = mid;\n    }\n  }\n  auto pmat = pow(mat, hi);\n  int64_t mx = -INF;\n  REP(i,v)REP(j,v) mx = max(mx, pmat[i][j]);\n  if (mx < k) {\n    cout << -1 << endl;\n    return 0;\n  } \n  cout << hi << endl;\n  if (hi > 100) {\n    return 0;\n  }\n  vector<Matrix> vmat;\n  Matrix m(v, Array(v, -INF));\n  REP(i,v) m[i][i] = 0;\n  REP(i,hi) {\n    vmat.push_back(m);\n    m = mul(mat, m);\n  }\n  int s=0,t=0;\n  REP(i,v)REP(j,v) {\n    if (pmat[i][j] == mx) {\n      s = i;\n      t = j;\n    }\n  }\n  vector<int> res;\n  for (int i = hi-1; i >= 0; --i) {\n    res.push_back(t);\n    int nt=0;\n    int64_t nmx=0;\n    REP(j,v) {\n      if (vmat[i][s][j] + mat[j][t] == mx) {\n        nt = j;\n        nmx = vmat[i][s][j];\n      }\n    }\n    t = nt;\n    mx = nmx;\n  }\n  assert(t == s);\n  cout << s;\n  reverse(ALL(res));\n  for (int r:res) cout << ' ' << r;\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> mat;\nmat op(mat a,mat b){\n\tint N=a.size();\n\tmat c(N,vi(N,-1));\n\trep(i,N) rep(j,N) rep(k,N) if(a[i][j]>=0&&b[j][k]>=0) chmax(c[i][k],a[i][j]+b[j][k]);\n\treturn c;\n}\nint getmx(mat a){\n\tint N=a.size();\n\tint mx=-1;\n\trep(i,N) rep(j,N) chmax(mx,a[i][j]);\n\treturn mx;\n}\nint main(){\n\tint N,M,K;\n\tint dp[151][150]={};\n\tint from[151][150]={};\n\tcin>>N>>M>>K;\n\tmat m(N,vi(N,0));\n\trep(i,N) rep(j,N) m[i][j]=-1;\n\trep(i,M){\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;\n\t\tchmax(m[a][b],c);\n\t}\n\trep1(i,150) rep(j,N) dp[i][j]=-1;\n\trep(i,150){\n\t\trep(v,N) rep(u,N){\n\t\t\tif(m[v][u]<0||dp[i][v]<0) continue;\n\t\t\tif(dp[i+1][u]<dp[i][v]+m[v][u]){\n\t\t\t\tdp[i+1][u]=dp[i][v]+m[v][u];\n\t\t\t\tfrom[i+1][u]=v;\n\t\t\t}\n\t\t}\n\t\tint mx=-1;\n\t\trep(v,N) chmax(mx,dp[i+1][v]);\n\t\tif(mx>=K){\n\t\t\tif(i>100){\n\t\t\t\tcout<<i<<endl;\n\t\t\t\treturn 0;\n\t\t\t}else{\n\t\t\t\tint x=-1;\n\t\t\t\trep(v,N) if(mx==dp[i+1][v]) x=v;\n\t\t\t\tvector<int> ans;\n\t\t\t\tans.pb(x);\n\t\t\t\tfor(int j=i+1;j>0;j--) ans.pb(from[j][x]),x=from[j][x];\n\t\t\t\treverse(all(ans));\n\t\t\t\tcout<<i+1<<endl;\n\t\t\t\trep(i,ans.size()) cout<<ans[i]<<(i+1==ans.size()?\"\\n\":\" \");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tif(i==149&&mx==0){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tmat ms[21];\n\tms[0]=m;\n\trep(i,20) ms[i+1]=op(ms[i],ms[i]);\n\tmat x(N,vi(N,-1));\n\trep(i,N) x[i][i]=0;\n\tint ans=0;\n\tfor(int i=20;i>=0;i--){\n\t\tmat nx=op(x,ms[i]);\n\t\tif(getmx(nx)<K){\n\t\t\tx=nx;\n\t\t\tans+=(1<<i);\n\t\t}\n\t}\n\tcout<<ans+1<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <queue>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#include <cstdio>\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\n#include <set>\nusing namespace std;\n\nint g[150][150];\npair<int, vector<int> > loop[150][160];\npair<int, vector<int> > p1[150][160];\npair<int, vector<int> > p2[150][160];\npair<int, vector<int> > tmp[160][150];\n\nint main(){\n  const int v = getInt();\n  const int e = getInt();\n  const int kk = getInt();\n\n  REP(i,v) REP(j,v) g[i][j] = -1;\n\n  REP(i,e){\n    const int v1 = getInt();\n    const int v2 = getInt();\n    const int c  = getInt();\n    g[v1][v2] = max(g[v1][v2], c);\n  }\n\n  REP(s,v){\n    REP(i,v + 10) REP(j,v) tmp[i][j] = make_pair(-1, vector<int>());\n\n    tmp[0][s] = make_pair(0, vector<int>());\n\n    REP(c, v + 5){\n      loop[s][c] = tmp[c][s];\n      p1[s][c] = tmp[c][0]; REP(i,v) p1[s][c] = max(p1[s][c], tmp[c][i]);\n\n      REP(i,v) if(tmp[c][i].first != -1){\n        vector<int> vv = tmp[c][i].second;\n        vv.push_back(0);\n        REP(j,v) if(g[i][j] != -1){\n          const int pp = tmp[c][i].first + g[i][j];\n          vv[c] = j;\n          tmp[c + 1][j] = max(tmp[c + 1][j], make_pair(pp, vv));\n        }\n      }\n    }\n  }\n\n  REP(i,v) REP(j,i) swap(g[i][j], g[j][i]);\n\n  REP(s,v){\n    REP(i,v + 10) REP(j,v) tmp[i][j] = make_pair(-1, vector<int>());\n\n    tmp[0][s] = make_pair(0, vector<int>());\n\n    REP(c, v + 5){\n      // loop[s][c] = tmp[c][s];\n      p2[s][c] = tmp[c][0]; REP(i,v) p2[s][c] = max(p2[s][c], tmp[c][i]);\n\n      REP(i,v) if(tmp[c][i].first != -1){\n        vector<int> vv = tmp[c][i].second;\n        vv.push_back(0);\n        REP(j,v) if(g[i][j] != -1){\n          const int pp = tmp[c][i].first + g[i][j];\n          vv[c] = j;\n          tmp[c + 1][j] = max(tmp[c + 1][j], make_pair(pp, vv));\n        }\n      }\n    }\n  }\n\n  REP(i,v) REP(j,i) swap(g[i][j], g[j][i]);\n\n  const int inf = 10000000;\n  pair<int, pair<int, pair<int, pair<int, pair<int, int> > > > > ans;\n  ans.first = inf;\n\n  REP(s,v){\n    REP(i,v + 2) REP(j,v + 2) REP(k, v + 2){\n      if(p1[s][i].first != -1 &&\n         p2[s][j].first != -1 &&\n         loop[s][k].first != -1){\n        const int pt = p1[s][i].first +\n          p2[s][j].first;\n\n        if(pt >= kk){\n          ans = min(ans, make_pair(i + j + k, make_pair(s, make_pair(i, make_pair(j, make_pair(k, 0))))));\n        }else{\n          if(loop[s][k].first > 0){\n            const int diff = kk - pt;\n            const int cnt = (diff + loop[s][k].first - 1) / loop[s][k].first;\n            ans = min(ans, make_pair(i + j + k * cnt, make_pair(s, make_pair(i, make_pair(j, make_pair(k, cnt))))));\n          }\n        }\n      }\n    }\n  }\n\n  if(ans.first == inf){\n    printf(\"-1\\n\");\n    puts(\"\");\n  }else{\n    printf(\"%d\\n\", ans.first);\n\n    if(ans.first <= 100){\n      const int s = ans.second.first;\n      const int i = ans.second.second.first;\n      const int j = ans.second.second.second.first;\n      const int k = ans.second.second.second.second.first;\n      const int c = ans.second.second.second.second.second;\n\n      vector<int> v;\n\n      {\n        REP(ii, j) v.push_back(p2[s][j].second[j - ii - 1]);\n      }\n      v.push_back(s);\n\n      REP(cc,c){\n        REP(ii, k) v.push_back(loop[s][k].second[ii]);\n      }\n\n      {\n        REP(ii, i) v.push_back(p1[s][i].second[ii]);\n      }\n\n      REP(i,v.size()) printf(\"%d%c\", v[i], i == (int)v.size() - 1 ? '\\n' : ' ');\n      /*\n      int a = 0;\n      REP(i, v.size() - 1)\n        a += g[v[i]][v[i + 1]];\n      printf(\"a: %d\\n\", a);\n      */\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\nint V,E,K;\nconst int INF = (1<<29);\nmat G;\n\nmat g[30];\nmat u[30];\n\nint add(int a,int b){\n  if(a==-INF||b==-INF)return -INF;\n  return min(a+b,INF);\n}\n\npair<mat,mat> merge(mat A,mat B, bool flag=false){\n  mat X( V, vec(V, -INF) );\n  mat Y( V, vec(V, -INF) );\n  \n  for(int from=0;from<V;from++){\n    for(int to=0;to<V;to++){\n      for(int ex=0;ex<V;ex++){\n        int cost=add(A[from][ex],B[ex][to]);\n        if(X[from][to]<cost){\n          X[from][to]=cost;\n          Y[from][to]=ex;\n        }\n      }\n    }\n  }\n  return make_pair(X,Y);\n}\n\n\nint calc(int m,int &si,int &ti){\n  mat t;\n  for(int i=0;i<30;i++){\n    if(m>>i&1){\n      if(t.empty()){\n        t=g[i];\n      }else{\n        t=merge(t,g[i]).first;\n      }\n    }\n  }\n  \n  int res=-INF;\n  for(int i=0;i<V;i++){\n    for(int j=0;j<V;j++){\n      if(res<t[i][j]){\n        si=i;\n        ti=j;\n        res=t[i][j];\n      }\n    }\n  }\n  return res;\n}\n\nvoid Dfs(vec& s,int from,int to,int len){\n  if(len<=1)return;\n  if(len==(len&-len)){\n\n    for(int i=0;i<30;i++){\n      if(len>>i&1){\n        int ex=u[i][from][to];\n        Dfs(s,from,ex,len/2);\n        s.push_back(ex);\n        Dfs(s,ex,to,len/2);\n        return;\n      }\n    }\n  }\n  \n  mat t=mat( V, vec(V,-INF) );\n  for(int i=0;i<V;i++)t[i][i]=0;\n  \n  int ex=-1;\n  int sub=-1;\n  \n  for(int i=0;i<30;i++){\n    if(~len>>i&1)continue;\n    pair<mat,mat> tmp=merge(t, g[i]);\n    t=tmp.first;\n    ex=tmp.second[from][to];\n    sub=(1<<i);\n  }\n\n  Dfs(s,from,ex,sub);\n  s.push_back(ex);\n  Dfs(s,ex,to,len-sub);\n}\n\nint main(){\n  cin>>V>>E>>K;\n  G=mat( V, vec(V, -INF) );\n  g[0]=u[0]=G;\n  for(int i=0;i<V;i++)g[0][i][i]=0;\n  for(int i=0;i<E;i++){\n    int a,b,c;\n    cin>>a>>b>>c;\n    G[a][b]=max(G[a][b],c);\n    if(g[0][a][b]<c){\n      g[0][a][b]=c;\n      u[0][a][b]=b;\n    }\n  }\n  \n  for(int i=1;i<30;i++){\n    pair<mat,mat> temp=merge(g[i-1],g[i-1]);\n    g[i]=temp.first;\n    u[i]=temp.second;\n  }\n  int left=1,right=K+1,mid,si,ti;\n  while( left < right ){\n    mid=(left+right)/2;\n    if( calc(mid,si,ti) >= K ){\n      right=mid;\n    }else{\n      left=mid+1;\n    }\n  }\n\n  for(int i=0;i<V;i++)g[0][i][i]=-INF;\n  for(int i=1;i<30;i++){\n    pair<mat,mat> temp=merge(g[i-1],g[i-1]);\n    g[i]=temp.first;\n    u[i]=temp.second;\n  }\n  \n  if(left==K+1){\n    cout<<-1<<endl;\n  }else{\n    cout<<left<<endl;\n    if(left<=100){\n      vec tab;\n      tab.push_back(si);\n      Dfs(tab,si,ti,left);\n      tab.push_back(ti);\n\n      int sum=0;\n      for(int i=0;i<(int)tab.size();i++){\n\n        \n        if(i>0){\n          int cost=G[ tab[i-1] ][ tab[i] ];\n          if(cost == -INF ){\n            assert(0);\n          }else{\n            sum=add(sum,cost);\n          }\n        }\n        \n        if(i)cout<<' ';\n        cout<<tab[i];\n      }\n      cout<<endl;\n      assert( sum == calc(left,si,ti) );\n    }\n  }\n  return 0;\n}\n\n  \n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<int(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nconstexpr int64_t INF = INT64_C(1000000000000000000);\n\nusing Array = vector<int64_t>;\nusing Matrix = vector<Array>;\n\nMatrix mul(const Matrix& lhs, const Matrix& rhs) {\n  int r = lhs.size();\n  Matrix res(r, Array(r, -INF));\n  REP(i,r) REP(k,r) REP(j,r) {\n    res[i][j] = max(res[i][j], lhs[i][k] + rhs[k][j]);\n  }\n  return res;\n}\n\nMatrix pow(const Matrix& mat, int64_t index) {\n  if (index == 1) return mat;\n  if ((index % 2) == 1) {\n    return mul(mat, pow(mat, index-1));\n  }\n  return pow(mul(mat, mat), index/2);\n}\n\nint main() {\n  int64_t v,e,k;\n  cin>>v>>e>>k;\n  Matrix mat(v, Array(v, -INF));\n  REP(i,e) {\n    int64_t s,t,c;\n    cin>>s>>t>>c;\n    mat[s][t] = max(mat[s][t], c);\n  }\n  int64_t hi = 1;\n  Matrix m2 = mat;\n  while (true) {\n    hi *= 2;\n    m2 = mul(m2, m2);\n    int64_t mx = -INF;\n    REP(i,v)REP(j,v) mx = max(mx, m2[i][j]);\n    if (mx >= k) break;\n    if (mx <= 0) break;\n  }\n  int64_t lo = 0;\n  while (hi - lo > 1) {\n    int64_t mid = (hi + lo) / 2;\n    auto pmat = pow(mat, mid);\n    int64_t mx = -INF;\n    REP(i,v)REP(j,v) mx = max(mx, pmat[i][j]);\n    if (mx <= 0) {\n      hi = mid;\n    } else if (mx >= k) {\n      hi = mid;\n    } else {\n      lo = mid;\n    }\n  }\n  auto pmat = pow(mat, hi);\n  int64_t mx = -INF;\n  REP(i,v)REP(j,v) mx = max(mx, pmat[i][j]);\n  if (mx < k) {\n    cout << -1 << endl;\n    return 0;\n  } \n  cout << hi << endl;\n  if (hi > 100) {\n    return 0;\n  }\n  vector<Matrix> vmat;\n  Matrix m(v, Array(v, 0));\n  REP(i,hi) {\n    vmat.push_back(m);\n    m = mul(mat, m);\n  }\n  int s=0,t=0;\n  REP(i,v)REP(j,v) {\n    if (pmat[i][j] == mx) {\n      s = i;\n      t = j;\n    }\n  }\n  vector<int> res;\n  for (int i = hi-1; i >= 0; --i) {\n    res.push_back(t);\n    int nt=0;\n    int64_t nmx=0;\n    REP(j,v) {\n      if (vmat[i][s][j] + mat[j][t] == mx) {\n        nt = j;\n        nmx = vmat[i][s][j];\n      }\n    }\n    t = nt;\n    mx = nmx;\n  }\n  cout << s;\n  reverse(ALL(res));\n  for (int r:res) cout << ' ' << r;\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<int(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nconstexpr int64_t INF = INT64_C(1000000000000000000);\n\nusing Array = vector<int64_t>;\nusing Matrix = vector<Array>;\n\nMatrix mul(const Matrix& lhs, const Matrix& rhs) {\n  int r = lhs.size();\n  Matrix res(r, Array(r, -INF));\n  REP(i,r) REP(k,r) REP(j,r) {\n    res[i][j] = max(res[i][j], lhs[i][k] + rhs[k][j]);\n  }\n  return res;\n}\n\nMatrix pow(const Matrix& mat, int64_t index) {\n  if (index == 1) return mat;\n  if ((index % 2) == 1) {\n    return mul(mat, pow(mat, index-1));\n  }\n  return pow(mul(mat, mat), index/2);\n}\n\nint main() {\n  int64_t v,e,k;\n  cin>>v>>e>>k;\n  Matrix mat(v, Array(v, -INF));\n  REP(i,e) {\n    int64_t s,t,c;\n    cin>>s>>t>>c;\n    mat[s][t] = max(mat[s][t], c);\n  }\n  vector<Matrix> vmat;\n  Matrix m(v, Array(v, -INF));\n  REP(i,v) m[i][i] = 0;\n  vmat.push_back(m);\n  REP(i,v) {\n    m = mul(mat, m);\n    vmat.push_back(m);\n  }\n  int64_t mx = -INF;\n  int64_t hi = k;\n  REP(idx,v)REP(i,v)REP(j,v) {\n    if (vmat[idx+1][i][j] >= k) {\n      if (idx < hi) {\n        hi = idx+1;\n        mx = max(mx, vmat[idx+1][i][j]);\n      }\n    }\n  }\n  if (mx < k) {\n    hi = k;\n    int64_t lo = v;\n    while (hi - lo > 1) {\n      int64_t mid = (hi + lo) / 2;\n      auto pmat = pow(mat, mid);\n      int64_t mx = -INF;\n      REP(i,v)REP(j,v) mx = max(mx, pmat[i][j]);\n      if (mx < 0) {\n        hi = mid;\n      } else if (mx >= k) {\n        hi = mid;\n      } else {\n        lo = mid;\n      }\n    }\n  }\n  auto pmat = pow(mat, hi);\n  mx = -INF;\n  REP(i,v)REP(j,v) mx = max(mx, pmat[i][j]);\n  if (mx < k) {\n    cout << -1 << endl;\n    return 0;\n  } \n  cout << hi << endl;\n  if (hi > 100) {\n    return 0;\n  }\n  FOR(i,v,hi) {\n    m = mul(mat, m);\n    vmat.push_back(m);\n  }\n  int s=0,t=0;\n  REP(i,v)REP(j,v) {\n    if (pmat[i][j] == mx) {\n      s = i;\n      t = j;\n    }\n  }\n  vector<int> res;\n  res.push_back(t);\n  for (int i = hi-1; i >= 0; --i) {\n    int nt=0;\n    int64_t nmx=0;\n    REP(j,v) {\n      if (vmat[i][s][j] + mat[j][t] == mx) {\n        nt = j;\n        nmx = vmat[i][s][j];\n      }\n    }\n    t = nt;\n    mx = nmx;\n    res.push_back(t);\n  }\n  reverse(ALL(res));\n  REP(i,res.size()) {\n    if (i) cout << ' ';\n    cout << res[i];\n  }\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<int(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nconstexpr int64_t INF = INT64_C(1000000000000000000);\n\nusing Array = vector<int64_t>;\nusing Matrix = vector<Array>;\n\nMatrix mul(const Matrix& lhs, const Matrix& rhs) {\n  int r = lhs.size();\n  Matrix res(r, Array(r, -INF));\n  REP(i,r) REP(k,r) REP(j,r) {\n    res[i][j] = max(res[i][j], lhs[i][k] + rhs[k][j]);\n  }\n  return res;\n}\n\nMatrix pow(const Matrix& mat, int64_t index) {\n  if (index == 1) return mat;\n  if ((index % 2) == 1) {\n    return mul(mat, pow(mat, index-1));\n  }\n  return pow(mul(mat, mat), index/2);\n}\n\nint main() {\n  int64_t v,e,k;\n  cin>>v>>e>>k;\n  Matrix mat(v, Array(v, -INF));\n  REP(i,e) {\n    int64_t s,t,c;\n    cin>>s>>t>>c;\n    mat[s][t] = max(mat[s][t], c);\n  }\n  int64_t hi = k*v;\n  int64_t lo = 0;\n  while (hi - lo > 1) {\n    int64_t mid = (hi + lo) / 2;\n    auto pmat = pow(mat, mid);\n    int64_t mx = -INF;\n    REP(i,v)REP(j,v) mx = max(mx, pmat[i][j]);\n    if (mx < 0) {\n      hi = mid;\n    } else if (mx >= k) {\n      hi = mid;\n    } else {\n      lo = mid;\n    }\n  }\n  auto pmat = pow(mat, hi);\n  int64_t mx = -INF;\n  REP(i,v)REP(j,v) mx = max(mx, pmat[i][j]);\n  if (mx < k) {\n    cout << -1 << endl;\n    return 0;\n  } \n  cout << hi << endl;\n  if (hi > 100) {\n    return 0;\n  }\n  vector<Matrix> vmat;\n  Matrix m(v, Array(v, 0));\n  REP(i,hi) {\n    vmat.push_back(m);\n    m = mul(mat, m);\n  }\n  int s=0,t=0;\n  REP(i,v)REP(j,v) {\n    if (pmat[i][j] == mx) {\n      s = i;\n      t = j;\n    }\n  }\n  vector<int> res;\n  for (int i = hi-1; i >= 0; --i) {\n    res.push_back(t);\n    int nt=0;\n    int nmx=0;\n    REP(j,v) {\n      if (vmat[i][s][j] + mat[j][t] == mx) {\n        nt = j;\n        nmx = vmat[i][s][j];\n      }\n    }\n    t = nt;\n    mx = nmx;\n  }\n  cout << s;\n  reverse(ALL(res));\n  for (int r:res) cout << ' ' << r;\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n \nint V,E,K;\nconst int INF = (1<<29);\nmat G;\n \nmat g[30];\nmat u[30];\n \nint add(int a,int b){\n  if(a==-INF||b==-INF)return -INF;\n  return min(a+b,INF);\n}\n \npair<mat,mat> merge(mat A,mat B, bool flag=false){\n  mat X( V, vec(V, -INF) );\n  mat Y( V, vec(V, -INF) );\n   \n  for(int from=0;from<V;from++){\n    for(int to=0;to<V;to++){\n      for(int ex=0;ex<V;ex++){\n        int cost=add(A[from][ex],B[ex][to]);\n        if(X[from][to]<cost){\n          X[from][to]=cost;\n          Y[from][to]=ex;\n        }\n      }\n    }\n  }\n  return make_pair(X,Y);\n}\n \n \nint calc(int m,int &si,int &ti){\n  mat t;\n  for(int i=0;i<30;i++){\n    if(m>>i&1){\n      if(t.empty()){\n        t=g[i];\n      }else{\n        t=merge(t,g[i]).first;\n      }\n    }\n  }\n   \n  int res=-INF;\n  for(int i=0;i<V;i++){\n    for(int j=0;j<V;j++){\n      if(res<t[i][j]){\n        si=i;\n        ti=j;\n        res=t[i][j];\n      }\n    }\n  }\n  return res;\n}\n \nvoid Dfs(vec& s,int from,int to,int len){\n  if(len==0)return;\n   \n  for(int i=0;i<30;i++){\n    if(~len>>i&1)continue;\n    int ex=u[i][from][to];\n \n    if(i==0){\n      if(len>=2)s.push_back(ex);\n      Dfs(s,ex,to,len-1);\n    }else{\n      int sub=(1<<i)/2;\n      Dfs(s,from,ex,sub);\n      s.push_back(ex);\n      Dfs(s,ex,to,len-sub);\n    }\n    break;\n  }\n}\n \nint main(){\n \n  cin>>V>>E>>K;\n  G=mat( V, vec(V, -INF) );\n   \n  g[0]=u[0]=G;\n  for(int i=0;i<V;i++)g[0][i][i]=0;\n   \n  for(int i=0;i<E;i++){\n    int a,b,c;\n    cin>>a>>b>>c;\n    assert(a!=b);\n    G[a][b]=max(G[a][b],c);\n     \n    g[0][a][b]=max(g[0][a][b],c);\n    u[0][a][b]=b;\n  }\n \n   \n  for(int i=1;i<30;i++){\n    pair<mat,mat> temp=merge(g[i-1],g[i-1]);\n    g[i]=temp.first;\n    u[i]=temp.second;\n  }\n   \n  int si,ti;\n  int left=1,right=K+1,mid;\n \n  while( left < right ){\n    mid=(left+right)/2;\n    if( calc(mid,si,ti) >= K ){\n      right=mid;\n    }else{\n      left=mid+1;\n    }\n  }\n\n  for(int i=0;i<V;i++)g[0][i][i]=-INF;\n  for(int i=1;i<30;i++){\n    pair<mat,mat> temp=merge(g[i-1],g[i-1]);\n    g[i]=temp.first;\n    u[i]=temp.second;\n  }\n\n  calc(left,si,ti);\n   \n  if(left==K+1){\n    cout<<-1<<endl;\n  }else{\n    cout<<left<<endl;\n    if(left<=100){\n      vec tab;\n      tab.push_back(si);\n      Dfs(tab,si,ti,left);\n      tab.push_back(ti);\n       \n      int sum=0;\n      assert( left+1==(int)tab.size() );\n      for(int i=0;i<(int)tab.size();i++){\n        if(i>0 && G[ tab[i-1]][ tab[i] ] == -INF ){\n          assert(0);\n        }\n        if(i>0)sum=add(sum,G[ tab[i-1]][ tab[i] ]);\n        if(i)cout<<' ';\n        cout<<tab[i];\n      }\n      cout<<endl;\n      assert(sum == calc(left,si,ti) );\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstruct edge{\n\tint t;\n\tint c;\n\tedge(){}\n\tedge(int tt,int cc){\n\t\tt=tt;\n\t\tc=cc;\n\t}\n};\n\nint n,m,tgt;\nvector<edge> G[151];\nint dp[151][151];\nint prev[151][151];\nint cyc_max[151][151];\nint to_max[151][151];\nint from_max[151][151];\nint ft_max[301][151];\n\nbool C(int v){\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<=min(n*2,v);j++){\n\t\t\tll all=ft_max[i][j];\n\t\t\tif(all>=(ll)tgt)return true;\n\t\t\tll rest=v-j;\n\t\t\tfor(int l=1;l<=n;l++){\n\t\t\t\tll va=(ll)rest/l;\n\t\t\t\tif(all+va*cyc_max[i][l]>=(ll)tgt)return true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nvoid get_route(int size){\n\tmemset(dp,-1,sizeof(dp));\n\tmemset(dp[0],0,sizeof(dp[0]));\n\tfor(int i=0;i<size;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(dp[i][j]>=0){\n\t\t\t\tfor(int l=0;l<G[j].size();l++){\n\t\t\t\t\tedge e=G[j][l];\n\t\t\t\t\tif(dp[i+1][e.t]<dp[i][j]+e.c){\n\t\t\t\t\t\tdp[i+1][e.t]=dp[i][j]+e.c;\n\t\t\t\t\t\tprev[i+1][e.t]=j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint maxi=tgt;\n\tfor(int i=0;i<n;i++){\n\t\tmaxi=max(maxi,dp[size][i]);\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tif(dp[size][i]>=maxi){\n\t\t\tint now=i;\n\t\t\tvector<int> ans;\n\t\t\tfor(int j=0;j<size;j++){\n\t\t\t\tans.push_back(now);\n\t\t\t\tnow=prev[size-j][now];\n\t\t\t}\n\t\t\tans.push_back(now);\n\t\t\treverse(ans.begin(),ans.end());\n\t\t\tfor(int j=0;j<=size;j++){\n\t\t\t\tprintf(\"%d%c\",ans[j],j==size?'\\n':' ');\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nint main(void){\n\tscanf(\"%d%d%d\",&n,&m,&tgt);\n\tfor(int i=0;i<m;i++){\n\t\tint f,t,c;\n\t\tscanf(\"%d%d%d\",&f,&t,&c);\n\t\tG[f].push_back(edge(t,c));\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tdp[0][i]=0;\n\t\tfor(int j=0;j<n;j++){\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\tif(dp[j][k]>=0){\n\t\t\t\t\tfor(int l=0;l<G[k].size();l++){\n\t\t\t\t\t\tedge e=G[k][l];\n\t\t\t\t\t\tdp[j+1][e.t]=max(dp[j+1][e.t],dp[j][k]+e.c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcyc_max[i][j+1]=dp[j+1][i];\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\tfrom_max[i][j+1]=max(from_max[i][j+1],dp[j+1][k]);\n\t\t\t\tto_max[k][j+1]=max(to_max[k][j+1],dp[j+1][k]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tfor(int k=0;k<=n;k++){\n\t\t\t\tft_max[i][j+k]=max(ft_max[i][j+k],from_max[i][j]+to_max[i][k]);\n\t\t\t}\n\t\t}\n\t}\n\tint l=-1,r=10000007;\n\twhile(l+1<r){\n\t\tint mid=(l+r)/2;\n\t\tif(C(mid))r=mid;\n\t\telse l=mid;\n\t}\n\tif(r==10000007){\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tprintf(\"%d\\n\",r);\n\tC(r);\n\tif(r<=100){\n\t\tget_route(r);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int64 LINF = 1LL << 60;\nconst int INF = 1 << 26;\n\nint V, E, K;\nint64 g[26][150][150];\n\nint main() {\n  fill_n(**g, 26 * 150 * 150, -LINF);\n\n  cin >> V >> E >> K;\n  for(int i = 0; i < V; i++) {\n    g[0][i][i] = 0;\n  }\n  for(int i = 0; i < E; i++) {\n    int a, b;\n    int64 c;\n    cin >> a >> b >> c;\n    g[0][a][b] = max(g[0][a][b], c);\n  }\n\n  for(int i = 0; i < 25; i++) {\n    for(int j = 0; j < V; j++) {\n      for(int k = 0; k < V; k++) {\n        for(int l = 0; l < V; l++) {\n          g[i + 1][k][l] = max(g[i + 1][k][l], g[i][k][j] + g[i][j][l]);\n        }\n      }\n    }\n  }\n\n\n  auto check = [&](int bit) {\n    vector< int64 > dp(V);\n    for(int k = 30; k >= 0; k--) {\n      if((bit >> k) & 1) {\n        vector< int64 > dp2(V);\n        for(int i = 0; i < V; i++) {\n          for(int j = 0; j < V; j++) {\n            dp2[j] = max(dp2[j], dp[i] + g[k][i][j]);\n          }\n        }\n        dp.swap(dp2);\n      }\n    }\n    return *max_element(begin(dp), end(dp)) >= K;\n  };\n\n  int ok = INF, ng = 0;\n  while(ok - ng > 1) {\n    int mid = (ok + ng) / 2;\n    if(check(mid)) ok = mid;\n    else ng = mid;\n  }\n\n  if(ok == INF) {\n    cout << -1 << endl;\n  } else {\n    cout << ok << endl;\n\n    if(ok <= 100) {\n      int64 dp[101][150] = {{}}, pv[101][150];\n      for(int i = 0; i < ok; i++) {\n        for(int j = 0; j < V; j++) {\n          for(int k = 0; k < V; k++) {\n            if(dp[i][j] + g[0][j][k] > dp[i + 1][k]) {\n              dp[i + 1][k] = dp[i][j] + g[0][j][k];\n              pv[i + 1][k] = j;\n            }\n          }\n        }\n      }\n      int high = 0;\n      for(int i = 0; i < V; i++) {\n        if(dp[ok][i] >= dp[ok][high]) high = i;\n      }\n      vector< int > route;\n      for(int i = ok; i >= 0; i--) {\n        route.push_back(high);\n        high = pv[i][high];\n      }\n      reverse(begin(route), end(route));\n      for(int i = 0; i < route.size(); i++) {\n        if(i) cout << \" \";\n        cout << route[i];\n      }\n      cout << endl;\n    }\n  }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n#define for_rev(i,a,b) for(int i=(a);i>=(b);--i)\n\ntypedef vector< int > Ary;\ntypedef vector< Ary > Mat;\n\nstruct Edge { int to, c; };\n\nvoid maxUpdate(int& a, int b) { a = max(a, b); }\n\nvoid mul(Mat& res, Mat& a, Mat& b) {\n\tint N = a.size();\n\tres = a;\n\t\n\tfor_(i,0,N) for_(j,0,N) for_(k,0,N) {\n\t\tif (a[i][k] >= 0 && b[k][j] >= 0) maxUpdate(res[i][j], a[i][k] + b[k][j]);\n\t}\n}\n\nint V, K, E, dp[110][155], prv[110][155];\nvector< vector< Edge > > adj;\n\nvoid restore(int step, int v) {\n\tint c = step;\n\tvector< int > path;\n\t\n\twhile (v != -1) {\n\t\tpath.push_back(v);\n\t\tv = prv[c--][v];\n\t}\n\t\n\treverse(path.begin(), path.end());\n\tfor_(i,0,step+1) cout << path[i] << (i < step ? \" \" : \"\\n\");\n}\n\nbool shortPhase() {\n\tmemset(dp, -1, sizeof(dp));\n\tmemset(prv, -1, sizeof(prv));\n\t\n\tfor_(v,0,V) dp[0][v] = 0;\n\t\n\tint max_score = -1, step = -1, terminal = -1;\n\t\n\tfor_(i,0,100) {\n\t\tfor_(v,0,V) {\n\t\t\tif (dp[i][v] == -1) continue;\n\t\t\n\t\t\tfor (Edge e : adj[v]) {\n\t\t\t\tif (dp[i + 1][e.to] < dp[i][v] + e.c) {\n\t\t\t\t\tdp[i + 1][e.to] = dp[i][v] + e.c;\n\t\t\t\t\tprv[i + 1][e.to] = v;\n\t\t\t\t\t\n\t\t\t\t\tif (max_score < dp[i + 1][e.to]) {\n\t\t\t\t\t\tmax_score = dp[i + 1][e.to];\n\t\t\t\t\t\tterminal = e.to;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (max_score >= K) {\n\t\t\tstep = i + 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tif (max_score >= K) {\n\t\tcout << step << endl;\n\t\trestore(step, terminal);\n\t\treturn true;\n\t}\n\t\n\treturn false;\n}\n\nint calcMinStep() {\n\tMat mat[20], ini(V, Ary(V, -1));\n\t\n\tfor_(v,0,V) for (Edge e : adj[v]) {\n\t\tmaxUpdate(ini[v][e.to], e.c);\n\t}\n\t\n\tmat[0] = ini;\n\tfor_(i,0,19) mul(mat[i + 1], mat[i], mat[i]);\n\t\n\tint res = 0;\n\t\n\tMat x(V, Ary(V, -1)), nx;\n\tfor_(v,0,V) x[v][v] = 0;\n\t\n\tfor_rev(h,19,0) {\n\t\tmul(nx, x, mat[h]);\n\t\t\n\t\tint max_score = 0;\n\t\tfor_(u,0,V) for_(v,0,V) maxUpdate(max_score, nx[u][v]);\n\t\t\n\t\tif (max_score < K) {\n\t\t\tx = nx;\n\t\t\tres += 1 << h;\n\t\t}\n\t}\n\t\n\treturn res + 1;\n}\n\nvoid solve() {\n\tif (!shortPhase()) {\n\t\tint ans = calcMinStep();\n\t\tcout << (ans > (int)1e6 ? -1 : ans) << endl;\n\t}\n}\n\nint main() {\n\tcin >> V >> E >> K;\n\t\n\tadj.assign(V, vector< Edge >());\n\t\n\tfor_(i,0,E) {\n\t\tint u, v, c;\n\t\tcin >> u >> v >> c;\n\t\tadj[u].push_back(Edge{v, c});\n\t}\n\t\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<int(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nconstexpr int INF = 1000000000;\n\nusing Array = vector<int>;\nusing Matrix = vector<Array>;\n\nMatrix mul(const Matrix& lhs, const Matrix& rhs) {\n  int r = lhs.size();\n  Matrix res(r, Array(r, -INF));\n  REP(i,r) REP(k,r) REP(j,r) {\n    res[i][j] = max(res[i][j], lhs[i][k] + rhs[k][j]);\n  }\n  return res;\n}\n\nMatrix pow(const Matrix& mat, int index) {\n  if (index == 0) {\n    int v = mat.size();\n    Matrix res(v, Array(v, -INF));\n    REP(i,v) res[i][i] = 0;\n    return res;\n  }\n  if (index == 1) return mat;\n  if ((index % 2) == 1) {\n    return mul(mat, pow(mat, index-1));\n  }\n  return pow(mul(mat, mat), index/2);\n}\n\nint main() {\n  int v,e,k;\n  cin>>v>>e>>k;\n  Matrix mat(v, Array(v, -INF));\n  REP(i,e) {\n    int s,t,c;\n    cin>>s>>t>>c;\n    mat[s][t] = max(mat[s][t], c);\n  }\n  int hi = k;\n  int lo = 0;\n  while (hi - lo > 1) {\n    int mid = (hi + lo) / 2;\n    auto pmat = pow(mat, mid);\n    int mx = -INF;\n    REP(i,v)REP(j,v) mx = max(mx, pmat[i][j]);\n    if (mx > k) {\n      hi = mid;\n    } else {\n      lo = mid;\n    }\n  }\n  lo = max(0, lo - v * 100);\n  auto pmat = pow(mat, lo);\n  vector<int> score(v, -INF);\n  REP(i,v)REP(j,v) score[j] = max(score[j], pmat[i][j]);\n  REP(cnt,300 * v) {\n    vector<int> tmp(v, -INF);\n    REP(i,v)REP(j,v) tmp[j] = max(tmp[j], score[i] + mat[i][j]);\n    int mx = -INF;\n    REP(i,v) mx = max(mx, tmp[i]);\n    swap(score, tmp);\n    if (mx >= k) {\n      lo += cnt + 1;\n      break;\n    }\n  }\n  if (lo > 0 && lo <= k) {\n    cout << lo << endl;\n  } else {\n    cout << -1 << endl;\n    return 0;\n  }\n  if (hi > 100) {\n    return 0;\n  }\n  vector<vector<int>> vscore;\n  REP(i,v) score[i] = 0;\n  REP(cnt,lo) {\n    vector<int> tmp(v, -INF);\n    REP(i,v)REP(j,v) tmp[j] = max(tmp[j], score[i] + mat[i][j]);\n    int mx = -INF;\n    REP(i,v) mx = max(mx, tmp[i]);\n    vscore.push_back(score);\n    swap(score, tmp);\n  }\n  int t = 0;\n  int mx = -INF;\n  REP(i,v) {\n    if (score[i] > mx) {\n      mx = score[i];\n      t = i;\n    }\n  }\n  vector<int> res;\n  res.push_back(t);\n  for (int i = lo-1; i >= 0; --i) {\n    int nt = 0;\n    int nmx = -INF;\n    REP(j,v) {\n      if (vscore[i][j] + mat[j][t] == mx) {\n        nt = j;\n        nmx = vscore[i][j];\n      }\n    }\n    t = nt;\n    mx = nmx;\n    res.push_back(t);\n  }\n  reverse(ALL(res));\n  REP(i,res.size()) {\n    if (i) cout << ' ';\n    cout << res[i];\n  }\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstruct edge{\n\tint t;\n\tint c;\n\tedge(){}\n\tedge(int tt,int cc){\n\t\tt=tt;\n\t\tc=cc;\n\t}\n};\n\nint n,m,tgt;\nvector<edge> G[151];\nint dp[151][151];\nint prev[151][151];\nint cyc_max[151][151];\nint to_max[151][151];\nint from_max[151][151];\nint ft_max[301][151];\n\nbool C(int v){\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<=min(n*2,v);j++){\n\t\t\tll all=ft_max[i][j];\n\t\t\tif(all>=(ll)tgt)return true;\n\t\t\tll rest=v-j;\n\t\t\tfor(int l=1;l<=n;l++){\n\t\t\t\tll va=(ll)rest/l;\n\t\t\t\tif(all+va*cyc_max[i][l]>=(ll)tgt)return true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nvoid get_route(int size){\n\tmemset(dp,-1,sizeof(dp));\n\tmemset(dp[0],0,sizeof(dp[0]));\n\tfor(int i=0;i<size;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(dp[i][j]>=0){\n\t\t\t\tfor(int l=0;l<G[j].size();l++){\n\t\t\t\t\tedge e=G[j][l];\n\t\t\t\t\tif(dp[i+1][e.t]<dp[i][j]+e.c){\n\t\t\t\t\t\tdp[i+1][e.t]=dp[i][j]+e.c;\n\t\t\t\t\t\tprev[i+1][e.t]=j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tif(dp[size][i]>=tgt){\n\t\t\tint now=i;\n\t\t\tvector<int> ans;\n\t\t\tfor(int j=0;j<size;j++){\n\t\t\t\tans.push_back(now);\n\t\t\t\tnow=prev[size-j][now];\n\t\t\t}\n\t\t\tans.push_back(now);\n\t\t\treverse(ans.begin(),ans.end());\n\t\t\tfor(int j=0;j<=size;j++){\n\t\t\t\tprintf(\"%d%c\",ans[j],j==size?'\\n':' ');\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nint main(void){\n\tscanf(\"%d%d%d\",&n,&m,&tgt);\n\tfor(int i=0;i<m;i++){\n\t\tint f,t,c;\n\t\tscanf(\"%d%d%d\",&f,&t,&c);\n\t\tG[f].push_back(edge(t,c));\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tdp[0][i]=0;\n\t\tfor(int j=0;j<n;j++){\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\tif(dp[j][k]>=0){\n\t\t\t\t\tfor(int l=0;l<G[k].size();l++){\n\t\t\t\t\t\tedge e=G[k][l];\n\t\t\t\t\t\tdp[j+1][e.t]=max(dp[j+1][e.t],dp[j][k]+e.c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcyc_max[i][j+1]=dp[j+1][i];\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\tfrom_max[i][j+1]=max(from_max[i][j+1],dp[j+1][k]);\n\t\t\t\tto_max[k][j+1]=max(to_max[k][j+1],dp[j+1][k]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tfor(int k=0;k<=n;k++){\n\t\t\t\tft_max[i][j+k]=max(ft_max[i][j+k],from_max[i][j]+to_max[i][k]);\n\t\t\t}\n\t\t}\n\t}\n\tint l=-1,r=10000007;\n\twhile(l+1<r){\n\t\tint mid=(l+r)/2;\n\t\tif(C(mid))r=mid;\n\t\telse l=mid;\n\t}\n\tif(r==10000007){\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tprintf(\"%d\\n\",r);\n\tif(r<=100){\n\t\tget_route(r);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\nint V,E,K;\nconst int INF = (1<<29);\nmat G;\n\nmat g[30];\nmat u[30];\n\nint add(int a,int b){\n  if(a==-INF||b==-INF)return -INF;\n  return min(a+b,INF);\n}\n\npair<mat,mat> merge(mat A,mat B, bool flag=false){\n  mat X( V, vec(V, -INF) );\n  mat Y( V, vec(V, -INF) );\n  \n  for(int from=0;from<V;from++){\n    for(int to=0;to<V;to++){\n      for(int ex=0;ex<V;ex++){\n        int cost=add(A[from][ex],B[ex][to]);\n        if(X[from][to]<cost){\n          X[from][to]=cost;\n          Y[from][to]=ex;\n        }\n      }\n    }\n  }\n  return make_pair(X,Y);\n}\n\n\nint calc(int m,int &si,int &ti){\n  mat t;\n  for(int i=0;i<30;i++){\n    if(m>>i&1){\n      if(t.empty()){\n        t=g[i];\n      }else{\n        t=merge(t,g[i]).first;\n      }\n    }\n  }\n  \n  int res=-INF;\n  for(int i=0;i<V;i++){\n    for(int j=0;j<V;j++){\n      if(res<t[i][j]){\n        si=i;\n        ti=j;\n        res=t[i][j];\n      }\n    }\n  }\n  return res;\n}\n\nvoid Dfs(vec& s,int from,int to,int len){\n  if(len<=1)return;\n  if(len==(len&-len)){\n\n    for(int i=0;i<30;i++){\n      if(len>>i&1){\n        int ex=u[i][from][to];\n        Dfs(s,from,ex,len/2);\n        s.push_back(ex);\n        Dfs(s,ex,to,len/2);\n        return;\n      }\n    }\n  }\n  \n  mat t=mat( V, vec(V,-INF) );\n  for(int i=0;i<V;i++)t[i][i]=0;\n  \n  int ex=-1;\n  int sub=-1;\n  \n  for(int i=0;i<30;i++){\n    if(~len>>i&1)continue;\n    pair<mat,mat> tmp=merge(t, g[i]);\n    t=tmp.first;\n    ex=tmp.second[from][to];\n    sub=(1<<i);\n  }\n\n  Dfs(s,from,ex,sub);\n  s.push_back(ex);\n  Dfs(s,ex,to,len-sub);\n}\n\nint main(){\n  cin>>V>>E>>K;\n  G=mat( V, vec(V, -INF) );\n  g[0]=u[0]=G;\n  for(int i=0;i<V;i++)g[0][i][i]=0;\n  for(int i=0;i<E;i++){\n    int a,b,c;\n    cin>>a>>b>>c;\n    G[a][b]=max(G[a][b],c);\n    if(g[0][a][b]<c){\n      g[0][a][b]=c;\n      u[0][a][b]=b;\n    }\n  }\n  \n  for(int i=1;i<30;i++){\n    pair<mat,mat> temp=merge(g[i-1],g[i-1]);\n    g[i]=temp.first;\n    u[i]=temp.second;\n  }\n  int left=1,right=K+1,mid,si,ti;\n  while( left < right ){\n    mid=(left+right)/2;\n    if( calc(mid,si,ti) >= K ){\n      right=mid;\n    }else{\n      left=mid+1;\n    }\n  }\n\n  for(int i=0;i<V;i++)g[0][i][i]=-INF;\n  for(int i=1;i<30;i++){\n    pair<mat,mat> temp=merge(g[i-1],g[i-1]);\n    g[i]=temp.first;\n    u[i]=temp.second;\n  }\n  \n  if(left==K+1){\n    cout<<-1<<endl;\n  }else{\n    cout<<left<<endl;\n    if(left<=100){\n      vec tab;\n      tab.push_back(si);\n      Dfs(tab,si,ti,left);\n      tab.push_back(ti);\n\n      int sum=0;\n      for(int i=0;i<(int)tab.size();i++){\n\n        \n        if(i>0){\n          int cost=G[ tab[i-1] ][ tab[i] ];\n          if(cost == -INF ){\n            assert(0);\n          }else{\n            sum=add(sum,cost);\n          }\n        }\n        \n        if(i)cout<<' ';\n        cout<<tab[i];\n      }\n      cout<<endl;\n      assert( sum >= K );\n    }\n  }\n  return 0;\n}\n\n  \n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int logMaxStep = 30;\n\ntypedef long long ll;\ntypedef vector< vector<ll> > Graph;\n\nint GetLogStep(int S) {\n\tint res;\n\tfor (res = 0; (1 << res) <= S; ++res);\n\treturn res;\n}\nGraph nextG(const Graph& g1, const Graph& g2) {\n\tint N = g1.size();\n\tGraph res(N, vector<ll>(N, 0));\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tfor (int k = 0; k < N; ++k) {\n\t\t\t\tif (g1[i][k] > 0 && g2[k][j] > 0) {\n\t\t\t\t\tres[i][j] = max(res[i][j], g1[i][k]+g2[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nvector<int> nextDP(vector<ll>& dp, Graph& g) {\n\tint N = g.size();\n\tvector<int> prevV(N, -1);\n\tvector<ll> ndp(N, -1);\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tif (dp[i] >= 0 && g[i][j] > 0) {\n\t\t\t\tif (dp[i]+g[i][j] > ndp[j]) {\n\t\t\t\t\tndp[j] = dp[i]+g[i][j];\n\t\t\t\t\tprevV[j] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tdp[i] = ndp[i];\n\t}\n\treturn prevV;\n}\nll GetMaxScore(vector<Graph>& powG, int S) {\n\tint N = powG[0].size();\n\tint logS = GetLogStep(S);\n\tvector<ll> dp(N, 0);\n\tfor (int i = 0; i < logS; ++i) {\n\t\tGraph& g = powG[i];\n\t\tif ( (1 << i) & S ) {\n\t\t\tnextDP(dp, g);\n\t\t}\n\t}\n\tll res = -1;\n\tfor (int i = 0; i < dp.size(); ++i) {\n\t\tres = max(res, dp[i]);\n\t}\n\treturn res;\n}\nint check200Step(Graph& G, int K) {\n\tint N = G.size();\n\tvector<ll> dp(N, 0);\n\tvector< vector<int> > prevV;\n\tll lastAns = -1;\n\tfor (int t = 0; t < 200; ++t) {\n\t\tprevV.push_back( nextDP(dp, G) );\n\t\tint aid = 0;\n\t\tfor (int i = 0; i < dp.size(); ++i) {\n\t\t\tif (dp[i] > dp[aid]) aid = i;\n\t\t}\n\t\tif (dp[aid] >= K) {\n\t\t\tcout << t+1 << endl;\n\t\t\tif (t+1 <= 100) {\n\t\t\t\tvector<int> vl;\n\t\t\t\tint v = aid; vl.push_back(v);\n\t\t\t\tfor (int i = t; i >= 0; --i) {\n\t\t\t\t\tv = prevV[i][v];\n\t\t\t\t\tvl.push_back(v);\n\t\t\t\t}\n\t\t\t\treverse(vl.begin(), vl.end());\n\t\t\t\tfor (int i = 0; i < vl.size(); ++i) {\n\t\t\t\t\tif (i) cout << \" \";\n\t\t\t\t\tcout << vl[i];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t\treturn -2;\n\t\t}\n\t\tlastAns = dp[aid];\n\t}\n\treturn lastAns;\n}\nint main() {\n\tint N, E, K; cin >> N >> E >> K;\n\tGraph G(N, vector<ll>(N, 0));\n\tfor (int i = 0; i < E; ++i) {\n\t\tint a, b; ll c; cin >> a >> b >> c;\n\t\tG[a][b] = max(G[a][b], c);\n\t}\n\tint result = check200Step(G, K);\n\tif (result > 0) {\n\t\tvector<Graph> powG(logMaxStep+1); powG[0] = G;\n\t\tfor (int i = 0; i < logMaxStep; ++i) {\n\t\t\tpowG[i+1] = nextG(powG[i], powG[i]);\n\t\t}\n\n\t\tfor (int i = N; i <= N+100; ++i) {\n\t\t\tif (GetMaxScore(powG, i+1) >= result) {\n\t\t\t\tassert(GetMaxScore(powG, i+1) > GetMaxScore(powG, i));\n\t\t\t}\n\t\t}\n\t\tint l = 0, r = K+1;\n\t\tfor (int t = 0; t < logMaxStep; ++t) {\n\t\t\tint m = (l + r) / 2;\n\t\t\tif ( GetMaxScore(powG, m) >= K ) {\n\t\t\t\tr = m;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tl = m;\n\t\t\t}\n\t\t}\n\t\tassert(r - l <= 1);\n\t\tassert(r <= K);\n\t\tcout << r << endl;\n\t}\n\telse if (result == -1) {\n\t\tcout << -1 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\ntypedef vector<ll> Array;\ntypedef vector<Array> Matrix;\n\nostream& operator<<(ostream &os, const Array &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\nostream& operator<<(ostream &os, const Matrix &t) {\nFOR(it,t)os<<*it<<endl;return os;\n}\n\n\nMatrix mul(const Matrix &a,const Matrix &b){\n\tMatrix res(a.size(),Array(b[0].size(), -INF));\n\tREP(i,a.size()){\n\t\tREP(j,b[0].size()){\n\t\t\tREP(k,a[0].size()){\n\t\t\t\tres[i][j] = max(res[i][j], a[i][k]+b[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nMatrix pow(const Matrix &a,ll b){\n\tif(b==0){\n\t\tMatrix res(a.size(),Array(a.size(), -INF));\n\t\tREP(i,a.size())res[i][i]=0;\n\t\treturn res;\n\t}\n\tMatrix res=pow(mul(a,a),b/2);\n\tif(b&1)res=mul(res,a);\n\treturn res;\n}\n\nint N, M, K;\n\nmain(){\n\tcin >> N >> M >> K;\n\tMatrix one(N, Array(N, -INF));\n\tREP(i, N) one[i][i] = 0;\n\tREP(i, M){\n\t\tint u, v;\n\t\tll x;\n\t\tcin >> u >> v >> x;\n\t\tone[u][v] = max(one[u][v], x);\n\t}\n\n\tint l = 0, r = 1000001;\n\twhile(l<r-1){\n\t\tint med=(l+r)/2;\n\t\tMatrix res = pow(one, med);\n\t\tint f = 0;\n\t\tREP(i, N)REP(j, N) f |= res[i][j] >= K;\n\t\tif(f) r = med;\n\t\telse l = med;\n\t}\n\t\n\tif(r == 1000001) puts(\"-1\");\n\telse printf(\"%d\\n\", r);\n\tif(r <= 100){\n\t\tvector<Matrix> Mats(r+1, Matrix(N, Array(N, -INF)));\n\t\tMats[1] = one;\n\t\tREP(i, N) Mats[0][i][i] = 0;\n\t\tREP(i, r) Mats[i+1] = mul(Mats[i], Mats[1]);\n\t\tint st=0, ed=0, mx=Mats[r][0][0];\n\t\tREP(i, N)REP(j, N) if(Mats[r][i][j] > Mats[r][st][ed]) st=i,ed=j,mx=Mats[r][i][j];\n\t\tprintf(\"%d\", st);\n\t\tREP(i, r){\n\t\t\tint k = 0;\n\t\t\tREP(j, N) if(one[st][j] + Mats[r-i-1][j][ed] == mx){\n\t\t\t\tprintf(\" %d\", j);\n\t\t\t\tmx -= one[st][j];\n\t\t\t\tst = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n//stl????????????\n//I don't know STL???\n//I plactice now???\n//OH! WRONG ANSWER!!\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#define bigas(a,b) if(a<b){a=b;}\nusing namespace std;\nint main(void){\n\tint h=0,i=0,j=0,m=0,ex=0,ans=0,V,E,K,x,y,z;\n\tstatic int ya[18][150][150]={0};//ya[i][x][y]???x??????y???2^i??¬???????????´????????¢??°?????????\n\tstatic int gen[150]={0};//gen[x]???x??´??????????????§?????°\n\tstatic int ima[150]={0};\n\tstatic int pre[101][150]={0};//??????????????\\??????\n\tstatic int poi[101][150]={0};//??????\n\tfor(h=0;h<18;h++){\n\t\tfor(i=0;i<150;i++){\n\t\t\tfor(j=0;j<150;j++){\n\t\t\t\tya[h][i][j]=-(1<<30);\n\t\t\t\tif(i==j){ya[h][i][j]=0;}\n\t\t\t}\n\t\t}\n\t}\n\tscanf(\"%d %d %d\",&V,&E,&K);\n\tfor(i=0;i<E;i++){\n\t\tscanf(\"%d %d %d\",&x,&y,&z);\n\t\tbigas(ya[0][x][y],z);\n\t}\n\tfor(h=1;h<101;h++){\n\t\tfor(i=0;i<V;i++){\n\t\t\tfor(j=0;j<V;j++){\n\t\t\t\tif(poi[h][j]<poi[h-1][i]+ya[0][i][j]){\n\t\t\t\t\tpoi[h][j]=poi[h-1][i]+ya[0][i][j];\n\t\t\t\t\tpre[h][j]=i;\n\t\t\t\t\tif(poi[h][j]>=K){ex=1;K=poi[h][j];ans=j;}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ex==1){break;}\n\t}\n\tif(ex==1){\n\t\tprintf(\"%d\\n\",h);\n\t\tima[h]=ans;\n\t\tfor(i=h-1;i>=0;i--){\n\t\t\tima[i]=pre[i+1][ima[i+1]];\n\t\t}\n\t\tfor(i=0;i<=h;i++){\n\t\t\tprintf(\"%d \",ima[i]);\n\t\t}\n\t\treturn 0;\n\t}\n\th=0,i=0,j=0,m=0,ex=0,ans=0;\n\t\n\t//??????????????§????????????????§£???\n\tfor(h=1;h<18;h++){//2^i??¬????±???????\n\t\tfor(i=0;i<V;i++){//i??????\n\t\t\tfor(j=0;j<V;j++){//j?????§\n\t\t\t\tfor(m=0;m<V;m++){//m????????£???\n\t\t\t\t\tbigas(ya[h][i][j],ya[h-1][i][m]+ya[h-1][m][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//??????????????¬??°??????????????§????±???????\n\tfor(h=17;h>=0;h--){\n\t\tfor(i=0;i<V;i++){\n\t\t\tfor(j=0;j<V;j++){\n\t\t\t\tbigas(ima[j],gen[i]+ya[h][i][j]);\n\t\t\t\tif(ima[j]>=K){ex=1;break;}\n\t\t\t}\n\t\t}\n\t\tif(ex==0){\n\t\t\tans+=(1<<h);\n\t\t\tfor(i=0;i<V;i++){\n\t\t\tgen[i]=ima[i];\n\t\t\t}\n\t\t}else{\n\t\t\tfor(i=0;i<V;i++){\n\t\t\tima[i]=gen[i];\n\t\t\t}\n\t\t}\n\t\tex=0;\n\t}\n\tans++;\n\tif(ans+500<(1<<18)){printf(\"%d\\n\",ans);}else{printf(\"-1\\n\");}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\nint V,E,K;\nconst int INF = (1<<30);\nmat G;\n\nmat g[30];\nmat u[30];\n\nint add(int a,int b){\n  if(a==-INF||b==-INF)return -INF;\n  return min(a+b,K);\n}\n\npair<mat,mat> merge(mat A,mat B, bool flag=false){\n  mat X( V, vec(V, -INF) );\n  mat Y( V, vec(V, -INF) );\n  \n  for(int from=0;from<V;from++){\n    for(int to=0;to<V;to++){\n      for(int ex=0;ex<V;ex++){\n        int cost=add(A[from][ex],B[ex][to]);\n        if(X[from][to]<cost){\n          X[from][to]=cost;\n          Y[from][to]=ex;\n        }\n      }\n    }\n  }\n  return make_pair(X,Y);\n}\n\n\nint calc(int m,int &si,int &ti){\n  mat t;\n  for(int i=0;i<30;i++){\n    if(m>>i&1){\n      if(t.empty()){\n        t=g[i];\n      }else{\n        t=merge(t,g[i]).first;\n      }\n    }\n  }\n  \n  int res=-INF;\n  for(int i=0;i<V;i++){\n    for(int j=0;j<V;j++){\n      if(res<t[i][j]){\n        si=i;\n        ti=j;\n        res=t[i][j];\n      }\n    }\n  }\n  return res;\n}\n\nvoid Dfs(vec& s,int from,int to,int len){\n  if(len==0)return;\n  \n  for(int i=0;i<30;i++){\n    if(~len>>i&1)continue;\n    int ex=u[i][from][to];\n\n    if(i==0){\n      if(len>=2)s.push_back(ex);\n      Dfs(s,ex,to,len-1);\n    }else{\n      int sub=(1<<i)/2;\n      Dfs(s,from,ex,sub);\n      s.push_back(ex);\n      Dfs(s,ex,to,len-sub);\n    }\n    break;\n  }\n}\n\nint main(){\n  cin>>V>>E>>K;\n  G=mat( V, vec(V, -INF) );\n  \n  g[0]=u[0]=G;\n  for(int i=0;i<V;i++)g[0][i][i]=0;\n  \n  for(int i=0;i<E;i++){\n    int a,b,c;\n    cin>>a>>b>>c;\n    G[a][b]=max(G[a][b],c);\n    \n    g[0][a][b]=max(g[0][a][b],c);\n    u[0][a][b]=b;\n  }\n\n  \n  for(int i=1;i<30;i++){\n    pair<mat,mat> temp=merge(g[i-1],g[i-1]);\n    g[i]=temp.first;\n    u[i]=temp.second;\n  }\n\n\n  int si,ti;\n  int left=1,right=K+1,mid;\n\n  while( left < right ){\n    mid=(left+right)/2;\n    if( calc(mid,si,ti) >= K ){\n      right=mid;\n    }else{\n      left=mid+1;\n    }\n  }\n\n  for(int i=0;i<V;i++)g[0][i][i]=-INF;\n  for(int i=1;i<30;i++){\n    pair<mat,mat> temp=merge(g[i-1],g[i-1]);\n    g[i]=temp.first;\n    u[i]=temp.second;\n  }\n  \n  if(left==K+1){\n    cout<<-1<<endl;\n  }else{\n    cout<<left<<endl;\n    if(left<100){\n      vec tab;\n      tab.push_back(si);\n      Dfs(tab,si,ti,left);\n      tab.push_back(ti);\n      \n      int sum=0;\n      assert( left+1 == (int)tab.size() );\n      for(int i=0;i<(int)tab.size();i++){\n        if(i>0 && G[ tab[i-1]][ tab[i] ] == -INF ){\n          assert(0);\n        }\n        if(i>0)sum+=G[ tab[i-1]][ tab[i] ];\n        if(i)cout<<' ';\n        cout<<tab[i];\n      }\n      cout<<endl;\n      assert(sum>=K);\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint V,E,K;\nint W[155][155];\nint dp[155][111];\nint pv[155][111];\nconst int INF = (1<<28);\nbool update(int &a,int b){\n  if( a < b ) {\n    a = b; return true;\n  }\n  return false;\n}\nbool solve1(){\n  for(int st=0;st<100;st++)\n    for(int i=0;i<V;i++)\n      for(int to=0;to<V;to++)\n        if( W[i][to] ) \n          if( update( dp[st+1][to], dp[st][i] + W[i][to] ) )\n            pv[st+1][to] = i;\n      \n  for(int st=1;st<=100;st++){\n    int id = 0;\n    for(int v=0;v<V;v++)\n      if( dp[st][id] < dp[st][v] ) id = v;\n    if( dp[st][id] >= K ) {\n\n      int cst = st, cv = id;\n      cout << st << endl;\n      vector<int> res;\n      while( cst > 0 ) {\n        res.emplace_back( cv );\n        cv = pv[cst][cv];\n        cst--;\n      }\n      res.emplace_back( cv );\n      reverse( res.begin(), res.end() );\n      for( int i = 0; i < res.size(); i++ ){\n        if( i )  cout << \" \" ;\n        cout << res[i];\n      }\n      cout << endl;\n      return true;\n    }\n  }\n  return false;  \n}\n\n\n\nvector<vector<int>> M;\nvector<vector<int>> calc( const vector<vector<int>>& a, const vector<vector<int>>& b ) {\n  vector<vector<int>> c(V,vector<int>(V,-INF));\n  for(int i=0;i<V;i++)\n    for(int j=0;j<V;j++)\n      for(int k=0;k<V;k++)\n        update( c[i][j], a[i][k] + b[k][j] );      \n  return c;  \n}\n\n\nvoid view(vector<vector<int>> mat){\n  cout << \"view\" << endl;\n  for(int i=0;i<V;i++) {\n    for(int j=0;j<V;j++) cout << mat[i][j] << \" \";\n    cout << endl;\n  }\n}\nbool check(int h){\n  vector<vector<int>> A(V,vector<int>(V,-INF));\n  for(int i=0;i<V;i++)\n    A[i][i] = 0;\n  vector<vector<int>> X = M;\n  while(h){\n    if( h&1 ) \n      A = calc( A, X );\n    X = calc( X, X );\n    h >>= 1;\n  }\n  for(int i=0;i<V;i++)\n    for(int j=0;j<V;j++)\n      if( A[i][j] >= K )\n        return true;      \n  return false;\n}\n\nint solve2(){\n  M = vector<vector<int>>(V,vector<int>(V));  \n  for(int i=0;i<V;i++)\n    for(int j=0;j<V;j++)\n      if( W[i][j] )\n        M[i][j] = W[i][j];\n      else\n        M[i][j] = -INF;\n\n\n\n  int st = 1, ed = 1000001;\n  int res = ed;\n  \n  while( st <= ed ){\n    int h = (st+ed)/2;\n    if( check( h ) ) {\n      res = h;\n      ed = h-1;\n    } else\n      st = h+1;\n  }\n  if( res > K ) {\n    cout << -1 << endl;\n  } else {\n    cout << res << endl;\n  }\n}\n\nint main(){\n  cin >> V >> E >> K;\n  for(int i=0;i<E;i++){\n    int a,b,c; cin >> a >> b >> c;\n    W[a][b] = max( W[a][b], c );\n  }\n  if( solve1() ) return 0;\n  solve2();  \n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int logMaxStep = 40;\n\ntypedef long long ll;\ntypedef vector< vector<ll> > Graph;\n\nint GetLogStep(int S) {\n\tint res;\n\tfor (res = 0; (1 << res) <= S; ++res);\n\treturn res;\n}\nGraph nextG(const Graph& g1, const Graph& g2) {\n\tint N = g1.size();\n\tGraph res(N, vector<ll>(N, 0));\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tfor (int k = 0; k < N; ++k) {\n\t\t\t\tif (g1[i][k] > 0 && g2[k][j] > 0) {\n\t\t\t\t\tres[i][j] = max(res[i][j], g1[i][k]+g2[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nvector<int> nextDP(vector<ll>& dp, Graph& g) {\n\tint N = g.size();\n\tvector<int> prevV(N, -1);\n\tvector<ll> ndp(N, -1);\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tif (dp[i] >= 0 && g[i][j] > 0) {\n\t\t\t\tif (dp[i]+g[i][j] > ndp[j]) {\n\t\t\t\t\tndp[j] = dp[i]+g[i][j];\n\t\t\t\t\tprevV[j] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tdp[i] = ndp[i];\n\t}\n\treturn prevV;\n}\nll GetMaxScore(vector<Graph>& powG, int S) {\n\tint N = powG[0].size();\n\tint logS = GetLogStep(S);\n\tvector<ll> dp(N, 0);\n\tfor (int i = 0; i < logS; ++i) {\n\t\tGraph& g = powG[i];\n\t\tif ( (1 << i) & S ) {\n\t\t\tnextDP(dp, g);\n\t\t}\n\t}\n\tll res = -1;\n\tfor (int i = 0; i < dp.size(); ++i) {\n\t\tres = max(res, dp[i]);\n\t}\n\treturn res;\n}\nint check200Step(Graph& G, int K) {\n\tint N = G.size();\n\tvector<ll> dp(N, 0);\n\tvector< vector<int> > prevV;\n\tll lastAns = -1;\n\tfor (int t = 0; t < 400; ++t) {\n\t\tprevV.push_back( nextDP(dp, G) );\n\t\tint aid = 0;\n\t\tfor (int i = 0; i < dp.size(); ++i) {\n\t\t\tif (dp[i] > dp[aid]) aid = i;\n\t\t}\n\t\tif (dp[aid] >= K) {\n\t\t\tcout << t+1 << endl;\n\t\t\tif (t+1 <= 100) {\n\t\t\t\tvector<int> vl;\n\t\t\t\tint v = aid; vl.push_back(v);\n\t\t\t\tfor (int i = t; i >= 0; --i) {\n\t\t\t\t\tv = prevV[i][v];\n\t\t\t\t\tvl.push_back(v);\n\t\t\t\t}\n\t\t\t\treverse(vl.begin(), vl.end());\n\t\t\t\tfor (int i = 0; i < vl.size(); ++i) {\n\t\t\t\t\tif (i) cout << \" \";\n\t\t\t\t\tcout << vl[i];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t\tlastAns = dp[aid];\n\t}\n\tif (lastAns < 0) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\nint main() {\n\tint N, E, K; cin >> N >> E >> K;\n\tGraph G(N, vector<ll>(N, 0));\n\tfor (int i = 0; i < E; ++i) {\n\t\tint a, b; ll c; cin >> a >> b >> c;\n\t\tG[a][b] = max(G[a][b], c);\n\t}\n\tint result = check200Step(G, K);\n\tif (result == 0) {\n\t\tvector<Graph> powG(logMaxStep+1); powG[0] = G;\n\t\tfor (int i = 0; i < logMaxStep; ++i) {\n\t\t\tpowG[i+1] = nextG(powG[i], powG[i]);\n\t\t}\n\n\t\tint l = 0, r = K+1;\n\t\tfor (int t = 0; t < logMaxStep; ++t) {\n\t\t\tint m = (l + r) / 2;\n\t\t\tif ( GetMaxScore(powG, m) >= K ) {\n\t\t\t\tr = m;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tl = m;\n\t\t\t}\n\t\t}\n\t\tassert(r - l <= 1);\n\t\tassert(r <= K);\n\t\tcout << r << endl;\n\t}\n\telse if (result == -1) {\n\t\tcout << -1 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\ntypedef vector<ll> Array;\ntypedef vector<Array> Matrix;\n\nostream& operator<<(ostream &os, const Array &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\nostream& operator<<(ostream &os, const Matrix &t) {\nFOR(it,t)os<<*it<<endl;return os;\n}\n\n\nMatrix mul(const Matrix &a,const Matrix &b){\n\tMatrix res(a.size(),Array(b[0].size(), -INF));\n\tREP(i,a.size()){\n\t\tREP(j,b[0].size()){\n\t\t\tREP(k,a[0].size()){\n\t\t\t\tres[i][j] = max(res[i][j], a[i][k]+b[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nMatrix pow(const Matrix &a,ll b){\n\tif(b==0){\n\t\tMatrix res(a.size(),Array(a.size(), -INF));\n\t\tREP(i,a.size())res[i][i]=0;\n\t\treturn res;\n\t}\n\tMatrix res=pow(mul(a,a),b/2);\n\tif(b&1)res=mul(res,a);\n\treturn res;\n}\n\nint N, M, K;\n\nmain(){\n\tcin >> N >> M >> K;\n\tMatrix one(N, Array(N, -INF));\n\tREP(i, M){\n\t\tint u, v;\n\t\tll x;\n\t\tcin >> u >> v >> x;\n\t\tone[u][v] = max(one[u][v], x);\n\t}\n\n\tint l = 0, r = 1000001;\n\twhile(l<r-1){\n\t\tint med=(l+r)/2;\n\t\tMatrix res = pow(one, med);\n\t\tint f = 0;\n\t\tREP(i, N)REP(j, N) f |= res[i][j] >= K;\n\t\tif(f) r = med;\n\t\telse l = med;\n\t}\n\t\n\tif(r == 1000001) puts(\"-1\");\n\telse printf(\"%d\\n\", r);\n\tif(r <= 100){\n\t\tvector<Matrix> Mats(r+1, Matrix(N, Array(N, -INF)));\n\t\tMats[1] = one;\n\t\tREP(i, N) Mats[0][i][i] = 0;\n\t\tREP(i, r) Mats[i+1] = mul(Mats[i], Mats[1]);\n\t\tint st=0, ed=0, mx=Mats[r][0][0];\n\t\tREP(i, N)REP(j, N) if(Mats[r][i][j] > Mats[r][st][ed]) st=i,ed=j,mx=Mats[r][i][j];\n\t\tREP(i, r){\n\t\t\tif(!i) continue;\n\t\t\tint k = 0;\n\t\t\tREP(j, N) if(Mats[1][st][j] + Mats[r-i][j][ed] == mx){\n\t\t\t\tprintf(\"%d \", st, j, ed);\n\t\t\t\tmx -= Mats[1][st][j];\n\t\t\t\tst = j;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ed);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\nint V,E,K;\nconst int INF = (1<<29);\nmat G;\n\nmat g[30];\nmat u[30];\n\nint add(int a,int b){\n  if(a==-INF||b==-INF)return -INF;\n  return min(a+b,INF);\n}\n\npair<mat,mat> merge(mat A,mat B, bool flag=false){\n  mat X( V, vec(V, -INF) );\n  mat Y( V, vec(V, -INF) );\n  \n  for(int from=0;from<V;from++){\n    for(int to=0;to<V;to++){\n      for(int ex=0;ex<V;ex++){\n        int cost=add(A[from][ex],B[ex][to]);\n        if(X[from][to]<cost){\n          X[from][to]=cost;\n          Y[from][to]=ex;\n        }\n      }\n    }\n  }\n  return make_pair(X,Y);\n}\n\n\nint calc(int m,int &si,int &ti){\n  mat t;\n  for(int i=0;i<30;i++){\n    if(m>>i&1){\n      if(t.empty()){\n        t=g[i];\n      }else{\n        t=merge(t,g[i]).first;\n      }\n    }\n  }\n  \n  int res=-INF;\n  for(int i=0;i<V;i++){\n    for(int j=0;j<V;j++){\n      if(res<t[i][j]){\n        si=i;\n        ti=j;\n        res=t[i][j];\n      }\n    }\n  }\n  return res;\n}\n\nvoid Dfs(vec& s,int from,int to,int len){\n  if(len<=1)return;\n  if(len==(len&-len)){\n\n    for(int i=0;i<30;i++){\n      if(len>>i&1){\n        int ex=u[i][from][to];\n        Dfs(s,from,ex,len/2);\n        s.push_back(ex);\n        Dfs(s,ex,to,len/2);\n        return;\n      }\n    }\n  }\n  \n  mat t=mat( V, vec(V,-INF) );\n  for(int i=0;i<V;i++)t[i][i]=0;\n  \n  int ex=-1;\n  int sub=-1;\n  \n  for(int i=0;i<30;i++){\n    if(~len>>i&1)continue;\n    pair<mat,mat> tmp=merge(t, g[i]);\n    ex=tmp.second[from][to];\n    sub=(1<<i);\n  }\n\n  Dfs(s,from,ex,sub);\n  s.push_back(ex);\n  Dfs(s,ex,to,len-sub);\n}\n\nint main(){\n  cin>>V>>E>>K;\n  G=mat( V, vec(V, -INF) );\n  g[0]=u[0]=G;\n  for(int i=0;i<V;i++)g[0][i][i]=0;\n  for(int i=0;i<E;i++){\n    int a,b,c;\n    cin>>a>>b>>c;\n    assert(a!=b);\n    G[a][b]=max(G[a][b],c);\n    if(g[0][a][b]<c){\n      g[0][a][b]=c;\n      u[0][a][b]=b;\n    }\n  }\n  \n  for(int i=1;i<30;i++){\n    pair<mat,mat> temp=merge(g[i-1],g[i-1]);\n    g[i]=temp.first;\n    u[i]=temp.second;\n  }\n  int left=1,right=K+1,mid,si,ti;\n  while( left < right ){\n    mid=(left+right)/2;\n    if( calc(mid,si,ti) >= K ){\n      right=mid;\n    }else{\n      left=mid+1;\n    }\n  }\n\n  for(int i=0;i<V;i++)g[0][i][i]=-INF;\n  for(int i=1;i<30;i++){\n    pair<mat,mat> temp=merge(g[i-1],g[i-1]);\n    g[i]=temp.first;\n    u[i]=temp.second;\n  }\n\n  assert(  calc(left,si,ti) >= K );\n  \n  if(left==K+1){\n    cout<<-1<<endl;\n  }else{\n    cout<<left<<endl;\n    if(left<=100){\n      vec tab;\n      tab.push_back(si);\n      Dfs(tab,si,ti,left);\n      tab.push_back(ti);\n\n      int sum=0;\n      for(int i=0;i<(int)tab.size();i++){\n\n        \n        if(i>0){\n          int cost=G[ tab[i-1] ][ tab[i] ];\n          if(cost == -INF ){\n            assert(0);\n          }else{\n            sum=add(sum,cost);\n          }\n        }\n        \n        if(i)cout<<' ';\n        cout<<tab[i];\n      }\n      cout<<endl;\n      assert( sum == calc(left,si,ti) );\n      \n    }\n  }\n  return 0;\n}\n\n  \n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i< (int)(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define iter(c) __typeof((c).begin())\n#define pb(e) push_back(e)\n#define foreach(c, i) for(iter(c) i = (c).begin(); i != c.end(); ++i)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> vec;\ntypedef vector<vec> mat;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\n\nconst int sz = 25;\nmat memo[sz];\nll g[200][200];\nint dp[200][200];\nint pre[200][200];\n\nmat mul(const mat &A, const mat &B){\n  int n = A.size();\n  int m = B[0].size();\n  mat C(n, vec(m, 0));\n  rep(i, n)rep(j, m)rep(k, A[0].size()){\n    if(A[i][k] > 0 && B[k][j] > 0) C[i][j] = max(A[i][k] + B[k][j], C[i][j]);\n  }\n  return C;\n}\n\nvoid init(int V, int E){\n  mat A = mat(V, vec(V, 0));\n  int f, t;\n  ll c;\n  rep(i, E){\n    cin >> f >> t >> c;\n    A[f][t] = max(A[f][t], c);\n    g[f][t] = max(g[f][t], c);\n  }\n  memo[0] = A;\n  rep(i, sz - 1) memo[i+1] = mul(memo[i], memo[i]);\n}\n\nvoid calc(int V, int R, int K){\n  rep(i, R)rep(j, V)rep(k, V){\n    if(g[j][k] > 0 && (i == 0 || dp[i][j] > 0) && dp[i+1][k] < dp[i][j] + g[j][k]){\n      dp[i+1][k] = dp[i][j] + g[j][k];\n      pre[i+1][k] = j;\n    }\n  }\n\n  int v = 0;\n  int best = -1;\n  rep(i, V) if(dp[R][i] > best){\n    v = i;\n    best = dp[R][i];\n  }\n  \n  vector<int> res;\n  res.push_back(v);\n  for(int i = R; i > 0; i--){\n    v = pre[i][v];\n    res.push_back(v);\n  }\n  //cout << res.size() << endl;\n  reverse(res.begin(), res.end());\n  rep(i, res.size()) cout << res[i] << (i == (int)res.size() - 1 ? '\\n' : ' ');\n}\n\nint main(){\n  int V, E, K, i, res = 0;\n  cin >> V >> E >> K;\n  init(V, E);\n  \n  mat A;\n  for(i = sz - 1; i >= 0; i--){\n    bool ok = false;\n    rep(j, V)rep(k, V) if(memo[i][j][k] >= K) ok = true;\n    if(!ok){\n      res += 1 << i;\n      A = memo[i--];\n      break;\n    }\n  }\n  \n  for(; i >= 0; i--){\n    mat B = mul(A, memo[i]);\n    bool ok = false;\n    rep(j, V)rep(k, V) if(B[j][k] >= K) ok = true;\n    if(!ok){\n      res += 1 << i;\n      A = B;\n    }\n  }\n  res++;\n  //resは経由する矢印の数\n  if(res == (1 << sz)){\n    cout << -1 << endl;\n  }else {\n    cout << res << endl;\n    if(res  <= 100) calc(V, res, K);\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <vector>\n#include <valarray>\n#include <array>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <random>\n#include <bitset>\n \nusing namespace std;\ntypedef long long ll;\n\nconst ll INF = 1LL<<40;\n\nstruct Matrix {\n    typedef ll D;\n    vector<valarray<D>> d;\n    int N, M;\n    Matrix(int N, int M) : N(N), M(M) {\n        d.resize(N);\n        for (int i = 0; i < N; i++) {\n            d[i] = valarray<D>(INF, M);\n        }\n    }\n\n    valarray<D>& operator[](int p) {\n        return d[p];\n    }\n\n    const valarray<D>& operator[](int p) const {\n        return d[p];\n    }\n\n    Matrix& operator=(const Matrix &other) {\n        copy_n(other.d.begin(), N, d.begin());\n        return *this;\n    }\n\n    Matrix operator*(const Matrix &right) {\n        Matrix res(N, right.M), r(right.M, right.N);\n        for (int i = 0; i < right.M; i++) {\n            for (int j = 0; j < right.N; j++) {\n                r[i][j] = right[j][i];\n            }\n        }\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < right.M; j++) {\n                res[i][j] = min(INF, (d[i]+r[j]).min());\n            }\n        }\n        return res;\n    }\n\n    Matrix pow(ll p) {\n        Matrix res(N, M), buf = *this;\n        for (int i = 0; i < N; i++) res[i][i] = D(0);\n        while (p != 0) {\n            if (p % 2) {\n                res = res*buf;\n            }\n            buf = buf*buf;\n            p /= 2;\n        }\n        return res;\n    }\n};\n\nconst int MN = 160;\n\ntypedef tuple<int, int, ll> T;\n\nll dist[MN], dist2[MN];\nint back[110][MN];\n\nint main() {\n    int V, E; ll K;\n    cin >> V >> E >> K; V++;\n    vector<T> v;\n    for (int i = 0; i < E; i++) {\n        int a, b; ll c;\n        cin >> a >> b >> c;\n        v.push_back(T(a, b, -c));\n    }\n    for (int i = 0; i < V-1; i++) {\n        v.push_back(T(V-1, i, 0));\n    }\n\n    fill_n(dist, MN, INF);\n    dist[V-1] = 0;\n    for (int i = 0; i < 101; i++) {\n        copy_n(dist, MN, dist2);\n        for (T t: v) {\n            int a, b; ll c;\n            tie(a, b, c) = t;\n            if (dist[a] == INF) continue;\n            if (dist2[b] < dist[a]+c) continue;\n            dist2[b] = dist[a]+c;\n            back[i][b] = a;\n        }\n        copy_n(dist2, MN, dist);\n\n        for (int j = 0; j < V; j++) {\n            if (dist[j] <= -K) {\n                cout << i << endl;\n                int jj = j;\n                vector<int> res;\n                res.push_back(jj);\n                for (int k = i; k > 0; k--) {\n                    res.push_back(back[k][jj]);\n                    jj = back[k][jj];\n                }\n                reverse(res.begin(), res.end());\n                for (int r: res) {\n                    cout << r << \" \";\n                } cout << endl;\n                return 0;\n            }\n        }\n    }\n\n\n    Matrix base(V, V);\n    for (T t: v) {\n        int a, b; ll c;\n        tie(a, b, c) = t;\n        base[a][b] = min(base[a][b], c);\n    }\n\n    int l = 0, r = 1000000;\n    while (r-l > 1) {\n        int md = (l+r)/2;\n        Matrix bb = base.pow(md);\n        bool f = false;\n        for (int i = 0; i < V; i++) {\n            for (int j = 0; j < V; j++) {\n                if (bb[i][j] <= -K) {\n                    f = true;\n                }\n            }\n        }\n//        cout << md << \" \" << f << endl;\n        if (!f) {\n            l = md;\n        } else {\n            r = md;\n        }\n    }\n    if (r == 1000000) {\n        cout << -1 << endl;\n    } else {\n        cout << r << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 151;\n\ntemplate<typename T> class mat : public vector<vector<T> > {\nprivate:\n    int r,c;    //行,列\npublic:\n    int row() const {\n        return r;\n    }\n    int column() const {\n        return c;\n    }\n    mat(int n,int m,T val = 0){\n        this->r = n,this->c = m;\n        rep(i,n){\n            this->push_back(vector<T>(m,val));\n        }\n    }\n    mat operator+(const mat& another){\n        if(this->r != another.r && this->c != another.c){\n            cout << \"足し算失敗(サイズ不一致)\" << endl;\n            exit(1);\n        }\n        mat<T> X(this->r,this->c);\n        rep(i,this->r){\n            rep(j,this->c){\n                X[i][j] = (*this)[i][j] + another[i][j];\n            }\n        }\n        return X;\n    }\n    mat operator+(const T val){\n        mat<T> X(this->r,this->c);\n        rep(i,this->r){\n            rep(j,this->c){\n                X[i][j] = (*this)[i][j] + val;\n            }\n        }\n        return X;\n    }\n    mat operator-(const mat& another){\n        if(this->r != another.r && this->c != another.c){\n            cout << \"引き算失敗(サイズ不一致)\" << endl;\n            exit(1);\n        }\n        mat<T> X(this->r,this->c);\n        rep(i,this->r){\n            rep(j,this->c){\n                X[i][j] = (*this)[i][j] - another[i][j];\n            }\n        }\n        return X;\n    }\n    mat operator-(const T val){\n        mat<T> X(this->r,this->c);\n        rep(i,this->r){\n            rep(j,this->c){\n                X[i][j] = (*this)[i][j] - val;\n            }\n        }\n        return X;\n    }\n    vector<T> operator*(const vector<T>& another){\n        if(this->c != (int)another.size()){\n            cout << \"掛け算失敗(サイズ不一致)\" << endl;\n            exit(1);\n        }\n        vector<T> vec(this->r,0);\n        rep(i,this->r){\n            rep(j,this->c){\n                vec[i] += (*this)[i][j] * another[j];\n            }\n        }\n        return vec;\n    }\n    mat operator*(const mat& another){\n        if(this->c != another.r){\n            cout << \"掛け算失敗(サイズ不一致)\" << endl;\n            exit(1);\n        }\n        mat<T> X(this->r,another.c);\n        rep(i,this->r){\n            rep(k,this->c){\n                rep(j,another.c){\n\t\t\t\t\tif((*this)[i][k] && another[k][j]){\n\t\t\t\t\t\tcmx(X[i][j],(*this)[i][k]+another[k][j]);\n\t\t\t\t\t}\n                }\n            }\n        }\n        return X;\n    }\n    mat operator-(){\n        mat<T> X(this->r,this->c);\n        rep(i,this->r){\n            rep(j,this->c){\n                X[i][j] = -(*this)[i][j];\n            }\n        }\n        return X;\n    }\n    void print(){\n        rep(i,this->r){\n            rep(j,(this->c)-1){\n                cout << (*this)[i][j] << \",\";\n            }\n            cout << (*this)[i][(this->c)-1] << endl;\n        }\n    }\n};\n\ntemplate<typename T> mat<T> pow(mat<T> A,ll cnt)\n{\n    if(A.row() != A.column()){\n        cout << \"累乗不可\" << endl;\n    }\n\tmat<T> B = A;\n\t--cnt;\n\twhile(cnt>0){\n\t\tif(cnt & 1){\n\t\t\tB = B*A;\n\t\t}\n\t\tA = A*A;\n\t\tcnt >>= 1;\n\t}\n\treturn B;\n}\n\nstruct edge{\n\tint to,cost;\n};\n\nvector<edge> G[MAX_N];\n\nbool possible(mat<int>& A,const int cri,const int K)\n{\n\tint n = A.row();\n\tmat<int> res = pow(A,cri);\n\tint mx = 0;\n\trep(i,n){\n\t\trep(j,n){\n\t\t\tcmx(mx,res[i][j]);\n\t\t}\n\t}\n\treturn (mx >= K);\n}\n\nint mx[101][151];\nint pre[101][151];\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n,m,K;\n\tcin >> n >> m >> K;\n\tmat<int> A(n,n);\n\trep(i,m){\n\t\tint a,b,c;\n\t\tcin >> a >> b >> c;\n\t\tcmx(A[a][b],c);\n\t}\n\trep(i,n){\n\t\trep(j,n){\n\t\t\tif(A[i][j]){\n\t\t\t\tG[i].pb((edge){j,A[i][j]});\n\t\t\t}\n\t\t}\n\t}\n\tif(!possible(A,K,K)){\n\t\tcout << \"-1\\n\";\n\t\treturn 0;\n\t}\n\tint l = 0,r = K;\n\twhile(r-l>1){\n\t\tint mid = (l+r)/2;\n\t\tif(possible(A,mid,K)){\n\t\t\tr = mid;\n\t\t}else{\n\t\t\tl = mid;\n\t\t}\n\t}\n\tcout << r << \"\\n\";\n\tif(r > 100){\n\t\treturn 0;\n\t}\n\trep(i,r){\n\t\trep(j,n){\n\t\t\teach(e,G[j]){\n\t\t\t\tif(mx[i+1][e.to] < mx[i][j] + e.cost){\n\t\t\t\t\tmx[i+1][e.to] = mx[i][j] + e.cost;\n\t\t\t\t\tpre[i+1][e.to] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint cri = *max_element(mx[r],mx[r]+n);\n\tvector<int> ans;\n\trep(i,n){\n\t\tif(mx[r][i] == cri){\n\t\t\tint nw;\n\t\t\trrep(j,r+1){\n\t\t\t\tans.pb(nw);\n\t\t\t\tnw = pre[j][nw];\n\t\t\t}\n\t\t\treverse(all(ans));\n\t\t\teach(it,ans){\n\t\t\t\tcout << it << \" \";\n\t\t\t}\n\t\t\tcout << \"\\n\";\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\nint V,E,K;\nconst int INF = (1<<29);\nmat G;\n\nmat g[30];\nmat u[30];\n\nint add(int a,int b){\n  if(a==-INF||b==-INF)return -INF;\n  return min(a+b,INF);\n}\n\npair<mat,mat> merge(mat A,mat B, bool flag=false){\n  mat X( V, vec(V, -INF) );\n  mat Y( V, vec(V, -INF) );\n  \n  for(int from=0;from<V;from++){\n    for(int to=0;to<V;to++){\n      for(int ex=0;ex<V;ex++){\n        int cost=add(A[from][ex],B[ex][to]);\n        if(X[from][to]<cost){\n          X[from][to]=cost;\n          Y[from][to]=ex;\n        }\n      }\n    }\n  }\n  return make_pair(X,Y);\n}\n\n\nint calc(int m,int &si,int &ti){\n  mat t;\n  for(int i=0;i<30;i++){\n    if(m>>i&1){\n      if(t.empty()){\n        t=g[i];\n      }else{\n        t=merge(t,g[i]).first;\n      }\n    }\n  }\n  \n  int res=-INF;\n  for(int i=0;i<V;i++){\n    for(int j=0;j<V;j++){\n      if(res<t[i][j]){\n        si=i;\n        ti=j;\n        res=t[i][j];\n      }\n    }\n  }\n  return res;\n}\n\nvoid Dfs(vec& s,int from,int to,int len){\n  if(len<=1)return;\n  if(len==(len&-len)){\n\n    for(int i=0;i<30;i++){\n      if(len>>i&1){\n        int ex=u[i][from][to];\n        Dfs(s,from,ex,len/2);\n        s.push_back(ex);\n        Dfs(s,ex,to,len/2);\n        return;\n      }\n    }\n  }\n  \n  mat t;\n  \n  int ex=-1;\n  int sub=-1;\n  \n  for(int i=0;i<30;i++){\n    if(~len>>i&1)continue;\n    if(t.empty()){\n      t=g[i];\n      continue;\n    }\n    pair<mat,mat> tmp=merge(t, g[i]);\n    t=tmp.first;\n    ex=tmp.second[from][to];\n    sub=(1<<i);\n  }\n\n  Dfs(s,from,ex,len-sub);\n  s.push_back(ex);\n  Dfs(s,ex,to,sub);\n}\n\nint main(){\n  cin>>V>>E>>K;\n  G=mat( V, vec(V, -INF) );\n  g[0]=u[0]=G;\n  for(int i=0;i<V;i++)g[0][i][i]=0;\n  for(int i=0;i<E;i++){\n    int a,b,c;\n    cin>>a>>b>>c;\n    G[a][b]=max(G[a][b],c);\n    if(g[0][a][b]<c){\n      g[0][a][b]=c;\n      u[0][a][b]=b;\n    }\n  }\n  \n  for(int i=1;i<30;i++){\n    pair<mat,mat> temp=merge(g[i-1],g[i-1]);\n    g[i]=temp.first;\n    u[i]=temp.second;\n  }\n  int left=1,right=K+1,mid,si,ti;\n  while( left < right ){\n    mid=(left+right)/2;\n    if( calc(mid,si,ti) >= K ){\n      right=mid;\n    }else{\n      left=mid+1;\n    }\n  }\n  \n  for(int i=0;i<V;i++)g[0][i][i]=-INF;\n  for(int i=1;i<30;i++){\n    pair<mat,mat> temp=merge(g[i-1],g[i-1]);\n    g[i]=temp.first;\n    u[i]=temp.second;\n  }\n  calc(left,si,ti);\n  \n  if(left==K+1){\n    cout<<-1<<endl;\n  }else{\n    cout<<left<<endl;\n    if(left<=100){\n      vec tab;\n      tab.push_back(si);\n      Dfs(tab,si,ti,left);\n      tab.push_back(ti);\n\n      int sum=0;\n      for(int i=0;i<(int)tab.size();i++){\n\n        \n        if(i>0){\n          int cost=G[ tab[i-1] ][ tab[i] ];\n          if(cost == -INF ){\n            assert(0);\n          }else{\n            sum=add(sum,cost);\n          }\n        }\n        \n        if(i)cout<<' ';\n        cout<<tab[i];\n      }\n      cout<<endl;\n      //cout<<sum<<' '<<calc(left,si,ti)<<endl;\n      assert( sum == calc(left,si,ti) );\n    }\n  }\n  return 0;\n}\n\n  \n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing matrix = vector<vector<int>>;\n\nmatrix mat_op(matrix a, matrix b) {\n    const int n = a.size();\n    matrix res(n, vector<int>(n, -1));\n    for(int k = 0; k < n; ++k) {\n        for(int i = 0; i < n; ++i) {\n            for(int j = 0; j < n; ++j) {\n                if(a[i][k] == -1 || b[k][j] == -1) continue;\n                res[i][j] = max(res[i][j], a[i][k] + b[k][j]);\n            }\n        }\n    }\n    return res;\n}\n\nmatrix matpow(matrix a, int n) {\n    const int V = a.size();\n    matrix res(V, vector<int>(V, -1));\n    for(int i = 0; i < V; ++i) {\n        res[i][i] = 0;\n    }\n    while(n > 0) {\n        if(n & 1) res = mat_op(move(res), a);\n        a = mat_op(a, a);\n        n >>= 1;\n    }\n    return res;\n}\n\n\nint main() {\n    int V, E, K; cin >> V >> E >> K;\n    matrix a(V, vector<int>(V, -1));\n    for(int i = 0; i < V; ++i) {\n        a[i][i] = 0;\n    }\n    for(int i = 0; i < E; ++i) {\n        int u, v, c; cin >> u >> v >> c;\n        a[u][v] = max(a[u][v], c);\n    }\n\n    auto check = [&] (int cnt) {\n        const auto res = matpow(a, cnt);\n        for(int i = 0; i < V; ++i) {\n            for(int j = 0; j < V; ++j) {\n                if(res[i][j] >= K) return true;\n            }\n        }\n        return false;\n    };\n    int lb = 0, ub = K + 1;\n    while(ub - lb > 1) {\n        const auto mid = (lb + ub) >> 1;\n        (check(mid) ? ub : lb) = mid;\n    }\n\n    if(ub == K + 1) {\n        cout << -1 << endl;\n        return 0;\n    }\n\n    cout << ub << endl;\n    if(ub <= 100) {\n        vector<int> dp(V);\n        vector<vector<int>> path(V);\n        for(int i = 0; i < V; ++i) {\n            path[i] = {i};\n        }\n        for(int i = 0; i < ub; ++i) {\n            vector<int> ndp(V, -1), nfrom(V, -1);\n            vector<vector<int>> npath(V);\n            for(int from = 0; from < V; ++from) {\n                if(dp[from] == -1) continue;\n                for(int to = 0; to < V; ++to) {\n                    if(from == to || a[from][to] == -1) continue;\n                    if(ndp[to] < dp[from] + a[from][to]) {\n                        ndp[to] = dp[from] + a[from][to];\n                        nfrom[to] = from;\n                    }\n                }\n            }\n            for(int j = 0; j < V; ++j) {\n                if(nfrom[j] == -1) continue;\n                npath[j] = path[nfrom[j]];\n                npath[j].push_back(j);\n            }\n            dp = move(ndp);\n            path = move(npath);\n        }\n        vector<int> ans_path;\n        int maxi = -1;\n        for(int i = 0; i < V; ++i) {\n            if(dp[i] > maxi) {\n                maxi = dp[i];\n                ans_path = path[i];\n            }\n        }\n        for(int i = 0; i <= ub; ++i) {\n            cout << ans_path[i] << \" \\n\"[i == ub];\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n\nusing vint = vector<int>;\n\nconst int inf = 1LL<<55;\n\nint V, E, K;\nvector<vint> A;\n\nvector<vint> calc(int m) {\n  vector<vint> B = A;\n  vector<vint> res(V, vint(V, -inf));\n  for(int i = 0; i < V; ++i) res[i][i] = 0;\n  while(m > 0) {\n    if(m&1) {\n      vector<vint> tmp(V, vint(V, -inf));\n      for(int i = 0; i < V; ++i) tmp[i][i] = 0;\n      for(int k = 0; k < V; ++k) {\n\tfor(int i = 0; i < V; ++i) {\n\t  for(int j = 0; j < V; ++j) {\n\t    tmp[i][j] = max(tmp[i][j], res[i][k]+B[k][j]);\n\t  }\n\t}\n      }\n      res = tmp;\n    }\n    vector<vint> tmp(V, vint(V, -inf));\n    for(int i = 0; i < V; ++i) tmp[i][i] = 0;\n    for(int k = 0; k < V; ++k) {\n      for(int i = 0; i < V; ++i) {\n\tfor(int j = 0; j < V; ++j) {\n\t  tmp[i][j] = max(tmp[i][j], B[i][k]+B[k][j]);\n\t}\n      }\n    }\n    B = tmp;\n    m >>= 1;\n  }\n  return res;\n}\n\n\nint check(int m) {\n  vector<vint> B = calc(m);\n  int res = 0;\n  for(int i = 0; i < V; ++i) {\n    for(int j = 0; j < V; ++j) {\n      res = max(res, B[i][j]);\n    }\n  }\n  return res;\n}\n\nsigned main() {\n  cin >> V >> E >> K;\n  A.resize(V, vint(V, -inf));\n  for(int i = 0; i < V; ++i) A[i][i] = 0;\n  for(int i = 0; i < E; ++i) {\n    int u, v, c;\n    cin >> u >> v >> c;\n    A[u][v] = max(A[u][v], c);\n  }\n  int lb = -1, ub = 1111111;\n  while(lb+1 < ub) {\n    int mb = (lb+ub)/2;\n    if(check(mb) >= K) ub = mb;\n    else lb = mb;\n  }\n  if(ub == 1111111) {\n    cout << -1 << endl;\n    return 0;\n  }\n  cout << ub << endl;\n  int ans = check(ub);\n  if(ub <= 100) {\n    vector<vint> rev(ub+1, vint(V, -1));\n    vector<vint> dp(ub+1, vint(V, 0));\n    for(int i = 0; i < ub; ++i) {\n      for(int j = 0; j < V; ++j) {\n\tfor(int k = 0; k < V; ++k) {\n\t  if(dp[i+1][k] < dp[i][j]+A[j][k]) {\n\t    dp[i+1][k] = dp[i][j]+A[j][k];\n\t    rev[i+1][k] = j;\n\t  }\n\t}\n      }\n    }\n    int idx = -1;\n    for(int i = 0; i < V && idx == -1; ++i) {\n      if(ans == dp[ub][i]) idx = i;\n    }\n    vint vec;\n    for(int l = ub; l >= 0; --l) {\n      vec.push_back(idx);\n      idx = rev[l][idx];\n    }\n    reverse(vec.begin(), vec.end());\n    for(int i = 0; i < (int)vec.size(); ++i) {\n      cout << vec[i] << \" \\n\"[i==(int)vec.size()-1];\n    }\n  }\n\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstruct edge{\n\tint t;\n\tint c;\n\tedge(){}\n\tedge(int tt,int cc){\n\t\tt=tt;\n\t\tc=cc;\n\t}\n};\n\nint n,m,tgt;\nvector<edge> G[151];\nint dp[151][151];\nint prev[151][151];\nint cyc_max[151][151];\nint to_max[151][151];\nint from_max[151][151];\nint ft_max[301][151];\n\nbool C(int v){\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<=min(n*2,v);j++){\n\t\t\tll all=ft_max[i][j];\n\t\t\tif(all>=(ll)tgt)return true;\n\t\t\tll rest=v-j;\n\t\t\tfor(int l=1;l<=n;l++){\n\t\t\t\tll va=(ll)rest/l;\n\t\t\t\tif(all+va*cyc_max[i][l]>=(ll)tgt)return true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nvoid get_route(int size){\n\tmemset(dp,-1,sizeof(dp));\n\tmemset(dp[0],0,sizeof(dp[0]));\n\tfor(int i=0;i<size;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(dp[i][j]>=0){\n\t\t\t\tfor(int l=0;l<G[j].size();l++){\n\t\t\t\t\tedge e=G[j][l];\n\t\t\t\t\tif(dp[i+1][e.t]<dp[i][j]+e.c){\n\t\t\t\t\t\tdp[i+1][e.t]=dp[i][j]+e.c;\n\t\t\t\t\t\tprev[i+1][e.t]=j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tif(dp[size][i]>=tgt){\n\t\t\tint now=i;\n\t\t\tvector<int> ans;\n\t\t\tfor(int j=0;j<size;j++){\n\t\t\t\tans.push_back(now);\n\t\t\t\tnow=prev[size-j][now];\n\t\t\t}\n\t\t\tans.push_back(now);\n\t\t\treverse(ans.begin(),ans.end());\n\t\t\tfor(int j=0;j<=size;j++){\n\t\t\t\tprintf(\"%d%c\",ans[j],j==size?'\\n':' ');\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nint main(void){\n\tscanf(\"%d%d%d\",&n,&m,&tgt);\n\tfor(int i=0;i<m;i++){\n\t\tint f,t,c;\n\t\tscanf(\"%d%d%d\",&f,&t,&c);\n\t\tG[f].push_back(edge(t,c));\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tdp[0][i]=0;\n\t\tfor(int j=0;j<n;j++){\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\tif(dp[j][k]>=0){\n\t\t\t\t\tfor(int l=0;l<G[k].size();l++){\n\t\t\t\t\t\tedge e=G[k][l];\n\t\t\t\t\t\tdp[j+1][e.t]=max(dp[j+1][e.t],dp[j][k]+e.c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcyc_max[i][j+1]=dp[j+1][i];\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\tfrom_max[i][j+1]=max(from_max[i][j+1],dp[j+1][k]);\n\t\t\t\tto_max[k][j+1]=max(to_max[k][j+1],dp[j+1][k]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tfor(int k=0;k<=n;k++){\n\t\t\t\tft_max[i][j+k]=max(ft_max[i][j+k],from_max[i][j]+to_max[i][k]);\n\t\t\t}\n\t\t}\n\t}\n\tint l=-1,r=10000007;\n\twhile(l+1<r){\n\t\tint mid=(l+r)/2;\n\t\tif(C(mid))r=mid;\n\t\telse l=mid;\n\t}\n\tif(r==10000007){\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tprintf(\"%d\\n\",r);\n\tif(r<=100){\n\t\tget_route(r);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//AOJproplem2432\n//stl????????????\n//I don't know STL???\n//I plactice now???\n//OH! WRONG ANSWER!!\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#define bigas(a,b) if(a<b){a=b;}\nusing namespace std;\nint main(void){\n\tint h=0,i=0,j=0,m=0,ex=0,ans=0,V,E,K,x,y,z;\n\tstatic int ya[18][150][150]={0};//ya[i][x][y]???x??????y???2^i??¬???????????´????????¢??°?????????\n\tstatic int gen[150]={0};//gen[x]???x??´??????????????§?????°\n\tstatic int ima[150]={0};\n\tstatic int pre[101][150]={0};//??????????????\\??????\n\tstatic int poi[101][150]={0};//??????\n\tfor(h=0;h<18;h++){\n\t\tfor(i=0;i<150;i++){\n\t\t\tfor(j=0;j<150;j++){\n\t\t\t\tya[h][i][j]=-(1<<30);\n\t\t\t\tif(i==j){ya[h][i][j]=0;}\n\t\t\t}\n\t\t}\n\t}\n\tscanf(\"%d %d %d\",&V,&E,&K);\n\tfor(i=0;i<E;i++){\n\t\tscanf(\"%d %d %d\",&x,&y,&z);\n\t\tbigas(ya[0][x][y],z);\n\t}\n\tfor(h=1;h<101;h++){\n\t\tfor(i=0;i<V;i++){\n\t\t\tfor(j=0;j<V;j++){\n\t\t\t\tif(poi[h][j]<poi[h-1][i]+ya[0][i][j]){\n\t\t\t\t\tpoi[h][j]=poi[h-1][i]+ya[0][i][j];\n\t\t\t\t\tpre[h][j]=i;\n\t\t\t\t\tif(poi[h][j]>=K){ex=1;K=poi[h][j];ans=j;}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ex==1){break;}\n\t}\n\tif(ex==1){\n\t\tprintf(\"%d\\n\",h);\n\t\tima[h]=ans;\n\t\tfor(i=h-1;i>=0;i--){\n\t\t\tima[i]=pre[i+1][ima[i+1]];\n\t\t}\n\t\tfor(i=0;i<=h;i++){\n\t\t\tprintf(\"%d \",ima[i]);\n\t\t}\n\t\treturn 0;\n\t}\n\th=0,i=0,j=0,m=0,ex=0,ans=0;\n\t\n\t//??????????????§????????????????§£???\n\tfor(h=1;h<18;h++){//2^i??¬????±???????\n\t\tfor(i=0;i<V;i++){//i??????\n\t\t\tfor(j=0;j<V;j++){//j?????§\n\t\t\t\tfor(m=0;m<V;m++){//m????????£???\n\t\t\t\t\tbigas(ya[h][i][j],ya[h-1][i][m]+ya[h-1][m][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//??????????????¬??°??????????????§????±???????\n\tfor(h=17;h>=0;h--){\n\t\tfor(i=0;i<V;i++){\n\t\t\tfor(j=0;j<V;j++){\n\t\t\t\tbigas(ima[j],gen[i]+ya[h][i][j]);\n\t\t\t\tif(ima[j]>=K){ex=1;break;}\n\t\t\t}\n\t\t}\n\t\tif(ex==0){\n\t\t\tans+=(1<<h);\n\t\t\tfor(i=0;i<V;i++){\n\t\t\tgen[i]=ima[i];\n\t\t\t}\n\t\t}else{\n\t\t\tfor(i=0;i<V;i++){\n\t\t\tima[i]=gen[i];\n\t\t\t}\n\t\t}\n\t\tex=0;\n\t}\n\tans++;\n\tif(ans+500<(1<<18)){printf(\"%d\\n\",ans);}else{printf(\"-1\\n\");}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n \nint V,E,K;\nconst int INF = (1<<29);\nmat G;\n \nmat g[30];\nmat u[30];\n \nint add(int a,int b){\n  if(a==-INF||b==-INF)return -INF;\n  return min(a+b,INF);\n}\n \npair<mat,mat> merge(mat A,mat B, bool flag=false){\n  mat X( V, vec(V, -INF) );\n  mat Y( V, vec(V, -INF) );\n   \n  for(int from=0;from<V;from++){\n    for(int to=0;to<V;to++){\n      for(int ex=0;ex<V;ex++){\n        int cost=add(A[from][ex],B[ex][to]);\n        if(X[from][to]<cost){\n          X[from][to]=cost;\n          Y[from][to]=ex;\n        }\n      }\n    }\n  }\n  return make_pair(X,Y);\n}\n \n \nint calc(int m,int &si,int &ti){\n  mat t;\n  for(int i=0;i<30;i++){\n    if(m>>i&1){\n      if(t.empty()){\n        t=g[i];\n      }else{\n        t=merge(t,g[i]).first;\n      }\n    }\n  }\n   \n  int res=-INF;\n  for(int i=0;i<V;i++){\n    for(int j=0;j<V;j++){\n      if(res<t[i][j]){\n        si=i;\n        ti=j;\n        res=t[i][j];\n      }\n    }\n  }\n  return res;\n}\n \nvoid Dfs(vec& s,int from,int to,int len){\n  if(len==0)return;\n   \n  for(int i=0;i<30;i++){\n    if(~len>>i&1)continue;\n    int ex=u[i][from][to];\n \n    if(i==0){\n      if(len>=2)s.push_back(ex);\n      Dfs(s,ex,to,len-1);\n    }else{\n      int sub=(1<<i)/2;\n      Dfs(s,from,ex,sub);\n      s.push_back(ex);\n      Dfs(s,ex,to,len-sub);\n    }\n    break;\n  }\n}\n \nint main(){\n \n  cin>>V>>E>>K;\n  G=mat( V, vec(V, -INF) );\n   \n  g[0]=u[0]=G;\n  for(int i=0;i<V;i++)g[0][i][i]=0;\n   \n  for(int i=0;i<E;i++){\n    int a,b,c;\n    cin>>a>>b>>c;\n    assert(a!=b);\n    G[a][b]=max(G[a][b],c);\n     \n    g[0][a][b]=max(g[0][a][b],c);\n    u[0][a][b]=b;\n  }\n \n   \n  for(int i=1;i<30;i++){\n    pair<mat,mat> temp=merge(g[i-1],g[i-1]);\n    g[i]=temp.first;\n    u[i]=temp.second;\n  }\n   \n  int si,ti;\n  int left=1,right=K+1,mid;\n \n  while( left < right ){\n    mid=(left+right)/2;\n    if( calc(mid,si,ti) >= K ){\n      right=mid;\n    }else{\n      left=mid+1;\n    }\n  }\n  /*\n  for(int i=0;i<V;i++)g[0][i][i]=-INF;\n  for(int i=1;i<30;i++){\n    pair<mat,mat> temp=merge(g[i-1],g[i-1]);\n    g[i]=temp.first;\n    u[i]=temp.second;\n  }\n  */\n  calc(left,si,ti);\n   \n  if(left==K+1){\n    cout<<-1<<endl;\n  }else{\n    cout<<left<<endl;\n    if(left<=100){\n      vec tab;\n      tab.push_back(si);\n      Dfs(tab,si,ti,left);\n      tab.push_back(ti);\n       \n      int sum=0;\n      assert( left+1==(int)tab.size() );\n      for(int i=0;i<(int)tab.size();i++){\n        if(i>0 && G[ tab[i-1]][ tab[i] ] == -INF ){\n          assert(0);\n        }\n        if(i>0)sum+=G[ tab[i-1]][ tab[i] ];\n        if(i)cout<<' ';\n        cout<<tab[i];\n      }\n      cout<<endl;\n      assert(sum == calc(left,si,ti) );\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int logMaxStep = 30;\n\ntypedef long long ll;\ntypedef vector< vector<ll> > Graph;\n\nint GetLogStep(int S) {\n\tint res;\n\tfor (res = 0; (1 << res) <= S; ++res);\n\treturn res;\n}\nGraph nextG(const Graph& g1, const Graph& g2) {\n\tint N = g1.size();\n\tGraph res(N, vector<ll>(N, 0));\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tfor (int k = 0; k < N; ++k) {\n\t\t\t\tif (g1[i][k] > 0 && g2[k][j] > 0) {\n\t\t\t\t\tres[i][j] = max(res[i][j], g1[i][k]+g2[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nvector<int> nextDP(vector<ll>& dp, Graph& g) {\n\tint N = g.size();\n\tvector<int> prevV(N, -1);\n\tvector<ll> ndp(N, -1);\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tif (dp[i] >= 0 && g[i][j] > 0) {\n\t\t\t\tif (dp[i]+g[i][j] > ndp[j]) {\n\t\t\t\t\tndp[j] = dp[i]+g[i][j];\n\t\t\t\t\tprevV[j] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tdp[i] = ndp[i];\n\t}\n\treturn prevV;\n}\nll GetMaxScore(vector<Graph>& powG, int S) {\n\tint N = powG[0].size();\n\tint logS = GetLogStep(S);\n\tvector<ll> dp(N, 0);\n\tfor (int i = 0; i < logS; ++i) {\n\t\tGraph& g = powG[i];\n\t\tif ( (1 << i) & S ) {\n\t\t\tnextDP(dp, g);\n\t\t}\n\t}\n\tll res = -1;\n\tfor (int i = 0; i < dp.size(); ++i) {\n\t\tres = max(res, dp[i]);\n\t}\n\treturn res;\n}\nint check200Step(Graph& G, int K) {\n\tint N = G.size();\n\tvector<ll> dp(N, 0);\n\tvector< vector<int> > prevV;\n\tll lastAns = -1;\n\tfor (int t = 0; t < 200; ++t) {\n\t\tprevV.push_back( nextDP(dp, G) );\n\t\tint aid = 0;\n\t\tfor (int i = 0; i < dp.size(); ++i) {\n\t\t\tif (dp[i] > dp[aid]) aid = i;\n\t\t}\n\t\tif (dp[aid] >= K) {\n\t\t\tcout << t+1 << endl;\n\t\t\tif (t+1 <= 100) {\n\t\t\t\tvector<int> vl;\n\t\t\t\tint v = aid; vl.push_back(v);\n\t\t\t\tfor (int i = t; i >= 0; --i) {\n\t\t\t\t\tv = prevV[i][v];\n\t\t\t\t\tvl.push_back(v);\n\t\t\t\t}\n\t\t\t\treverse(vl.begin(), vl.end());\n\t\t\t\tfor (int i = 0; i < vl.size(); ++i) {\n\t\t\t\t\tif (i) cout << \" \";\n\t\t\t\t\tcout << vl[i];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t\tlastAns = dp[aid];\n\t}\n\tif (lastAns < 0) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\nint main() {\n\tint N, E, K; cin >> N >> E >> K;\n\tGraph G(N, vector<ll>(N, 0));\n\tfor (int i = 0; i < E; ++i) {\n\t\tint a, b; ll c; cin >> a >> b >> c;\n\t\tG[a][b] = max(G[a][b], c);\n\t}\n\tint result = check200Step(G, K);\n\tif (result == 0) {\n\t\tvector<Graph> powG(logMaxStep+1); powG[0] = G;\n\t\tfor (int i = 0; i < logMaxStep; ++i) {\n\t\t\tpowG[i+1] = nextG(powG[i], powG[i]);\n\t\t}\n\n\t\tint l = 0, r = K+1;\n\t\tfor (int t = 0; t < logMaxStep; ++t) {\n\t\t\tint m = (l + r) / 2;\n\t\t\tif ( GetMaxScore(powG, m) >= K ) {\n\t\t\t\tr = m;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tl = m;\n\t\t\t}\n\t\t}\n\t\tassert(r <= K);\n\t\tcout << r << endl;\n\t}\n\telse if (result == -1) {\n\t\tcout << -1 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\ntypedef long long int Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\n\nbool operator < (const Edge &e, const Edge &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<vector<pair<vector<int>, long long int>>>type;\nint V, E, K;\n type time(const type&lts, const type&rts, const bool flag) {\n\ttype squs(V,vector<pair<vector<int>,long long int>>(V));\n\tfor (int i = 0; i < V; ++i) {\n\t\tfor (int j = 0; j < V; ++j) {\n\t\t\tif (i == j)squs[i][j] = make_pair(vector<int>(), 0ll);\n\t\t\telse squs[i][j] = make_pair(vector<int>(), static_cast<long long>(-1e17));\n\t\t}\n\t}\n\tfor (int k = 0; k < V; ++k) {\n\t\tfor (int i = 0; i < V; ++i) {\n\t\t\tfor (int j = 0; j < V; ++j) {\n\t\t\t\tif (squs[i][j].second <lts[i][k].second + rts[k][j].second) {\n\t\t\t\t\tsqus[i][j].second = lts[i][k].second + rts[k][j].second;\n\t\t\t\t\tif (flag) {\n\t\t\t\t\t\tsqus[i][j].first.clear();\n\t\t\t\t\t\tsqus[i][j].first.insert(squs[i][j].first.end(), lts[i][k].first.begin(), lts[i][k].first.end());\n\t\t\t\t\t\tsqus[i][j].first.insert(squs[i][j].first.end(), rts[k][j].first.begin(), rts[k][j].first.end());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn squs;\n}\ntype square(const type&ts,bool flag) {\n\treturn time(ts, ts, flag);\n}\n\ntype power(const type&ts,const long long  int num,const bool flag) {\n\tassert(num);\n\tif (num == 1)return ts;\n\telse {\n\t\ttype pot(square(power(ts,num/2,flag),flag));\n\t\tif (num % 2) {\n\t\t\tpot = time(pot, ts, flag);\n\t\t}\n\t\treturn pot;\n\t}\n}\nvector<int>ans;\nbool check(const type &ts,const long long int run,const int point,const bool flag) {\n\t\n\ttype t(power(ts, run, flag&&run <= 100));\n\tlong long int amax = 0;\n\tfor (int i = 0; i < V; ++i) {\n\t\tfor (int j = 0; j < V; ++j) {\n\t\t\tif (amax < t[i][j].second) {\n\t\t\t\tamax = t[i][j].second;\n\t\t\t\tif (run <= 100&&flag) {\n\t\t\t\t\tans.clear();\n\t\t\t\t\tans.push_back(i);\n\t\t\t\t\tans.insert(ans.end(), t[i][j].first.begin(),t[i][j].first.end());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (amax >= point)return true;\n\telse return false;\n}\n\nint main() { cin >> V >> E >> K;\n\ttype times(V, vector<pair<vector<int>,long long int>>(V, make_pair(vector<int>(),static_cast<long long int>(-1e18))));\n\tfor (int i = 0; i < E; ++i) {\n\t\tlong long int a, b, c; cin >> a >> b >> c;\n\n\t\ttimes[a][b].second = max(times[a][b].second, c);\n\t\ttimes[a][b].first = vector<int>(1,b);\n\t}\n\tfor (int i = 0; i < V; ++i) {\n\t\ttimes[i][i] = make_pair(vector<int>(1,i),0);\n\t\t\n\t}\n\tlong long int amin = 0;\n\tlong long int amax = 1e6+10;\n\twhile (amin + 1 != amax) {\n\t\tlong long int amid((amin + amax) / 2);\n\t\tif (check(times,amid, K,false)) {\n\t\t\tamax = amid;\n\t\t}\n\t\telse {\n\t\t\tamin = amid;\n\t\t}\n\t}\n\tif (amax >1e6+5) {\n\t\tcout << -1 << endl;\n\t}\n\telse {\n\t\tcheck(times, amax, K,true);\n\t\tcout << amax << endl;\n\t\tif (amax <= 100) {\n\t\t\tfor (int i = 0; i < ans.size(); ++i) {\n\t\t\t\tcout << ans[i];\n\t\t\t\tif (i != ans.size() - 1)cout << \" \";\n\t\t\t\telse cout << endl;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<int(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nconstexpr int INF = 1000000000;\n\nusing Array = vector<int>;\nusing Matrix = vector<Array>;\n\nMatrix mul(const Matrix& lhs, const Matrix& rhs) {\n  int r = lhs.size();\n  Matrix res(r, Array(r, -INF));\n  REP(i,r) REP(k,r) REP(j,r) {\n    res[i][j] = max(res[i][j], lhs[i][k] + rhs[k][j]);\n  }\n  return res;\n}\n\nMatrix pow(const Matrix& mat, int index) {\n  if (index == 0) {\n    int v = mat.size();\n    Matrix res(v, Array(v, -INF));\n    REP(i,v) res[i][i] = 0;\n    return res;\n  }\n  if (index == 1) return mat;\n  if ((index % 2) == 1) {\n    return mul(mat, pow(mat, index-1));\n  }\n  return pow(mul(mat, mat), index/2);\n}\n\nint main() {\n  int v,e,k;\n  cin>>v>>e>>k;\n  Matrix mat(v, Array(v, -INF));\n  REP(i,e) {\n    int s,t,c;\n    cin>>s>>t>>c;\n    mat[s][t] = max(mat[s][t], c);\n  }\n  int idx = 0;\n  auto pmat = pow(mat, v*100);\n  vector<int> score(v, 0);\n  for (; idx < k; idx += v*100) {\n    vector<int> tmp(v, -INF);\n    REP(i,v)REP(j,v) tmp[j] = max(tmp[j], score[i] + pmat[i][j]);\n    int mx = -INF;\n    REP(i,v) mx = max(mx, tmp[i]);\n    swap(score, tmp);\n    if (mx >= k - v*100) {\n      break;\n    }\n  }\n  pmat = pow(mat, idx);\n  REP(i,v) score[i] = -INF;\n  REP(i,v)REP(j,v) score[j] = max(score[j], pmat[i][j]);\n  bool ok = false;\n  REP(cnt,200 * v+1) {\n    vector<int> tmp(v, -INF);\n    REP(i,v)REP(j,v) tmp[j] = max(tmp[j], score[i] + mat[i][j]);\n    int mx = -INF;\n    REP(i,v) mx = max(mx, tmp[i]);\n    swap(score, tmp);\n    if (mx >= k) {\n      idx += cnt + 1;\n      ok = true;\n      break;\n    }\n  }\n  if (ok && idx <= k) {\n    cout << idx << endl;\n  } else {\n    cout << -1 << endl;\n    return 0;\n  }\n  if (idx > 100) {\n    return 0;\n  }\n  vector<vector<int>> vscore;\n  REP(i,v) score[i] = 0;\n  REP(cnt,idx) {\n    vector<int> tmp(v, -INF);\n    REP(i,v)REP(j,v) tmp[j] = max(tmp[j], score[i] + mat[i][j]);\n    int mx = -INF;\n    REP(i,v) mx = max(mx, tmp[i]);\n    vscore.push_back(score);\n    swap(score, tmp);\n  }\n  int t = 0;\n  int mx = -INF;\n  REP(i,v) {\n    if (score[i] > mx) {\n      mx = score[i];\n      t = i;\n    }\n  }\n  vector<int> res;\n  res.push_back(t);\n  for (int i = idx-1; i >= 0; --i) {\n    int nt = 0;\n    int nmx = -INF;\n    REP(j,v) {\n      if (vscore[i][j] + mat[j][t] == mx) {\n        nt = j;\n        nmx = vscore[i][j];\n      }\n    }\n    t = nt;\n    mx = nmx;\n    res.push_back(t);\n  }\n  reverse(ALL(res));\n  REP(i,res.size()) {\n    if (i) cout << ' ';\n    cout << res[i];\n  }\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<int(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nconstexpr int64_t INF = INT64_C(1000000000000000000);\n\nusing Array = vector<int64_t>;\nusing Matrix = vector<Array>;\n\nMatrix mul(const Matrix& lhs, const Matrix& rhs) {\n  int r = lhs.size();\n  Matrix res(r, Array(r, -INF));\n  REP(i,r) REP(k,r) REP(j,r) {\n    res[i][j] = max(res[i][j], lhs[i][k] + rhs[k][j]);\n  }\n  return res;\n}\n\nMatrix pow(const Matrix& mat, int64_t index) {\n  if (index == 1) return mat;\n  if ((index % 2) == 1) {\n    return mul(mat, pow(mat, index-1));\n  }\n  return pow(mul(mat, mat), index/2);\n}\n\nint main() {\n  int64_t v,e,k;\n  cin>>v>>e>>k;\n  Matrix mat(v, Array(v, -INF));\n  REP(i,e) {\n    int64_t s,t,c;\n    cin>>s>>t>>c;\n    mat[s][t] = max(mat[s][t], c);\n  }\n  vector<Matrix> vmat;\n  Matrix m(v, Array(v, -INF));\n  REP(i,v) m[i][i] = 0;\n  vmat.push_back(m);\n  REP(i,max(100,v)) {\n    m = mul(mat, m);\n    vmat.push_back(m);\n  }\n  int64_t mx = -INF;\n  int64_t hi = k;\n  REP(idx,v)REP(i,v)REP(j,v) {\n    if (vmat[idx+1][i][j] >= k) {\n      if (idx < hi) {\n        hi = idx+1;\n        mx = max(mx, vmat[idx+1][i][j]);\n      }\n    }\n  }\n  int mx2 = 0;\n  REP(i,v)REP(j,v) mx2 = max(mx2, vmat[v][i][j]);\n  if (mx2 > 0 && mx < k) {\n    hi = k;\n    int64_t lo = v;\n    while (hi - lo > 1) {\n      int64_t mid = (hi + lo) / 2;\n      auto pmat = pow(mat, mid);\n      int64_t mx = -INF;\n      REP(i,v)REP(j,v) mx = max(mx, pmat[i][j]);\n      if (mx < 0) {\n        hi = mid;\n      } else if (mx >= k) {\n        hi = mid;\n      } else {\n        lo = mid;\n      }\n    }\n  }\n  auto pmat = pow(mat, hi);\n  mx = -INF;\n  REP(i,v)REP(j,v) mx = max(mx, pmat[i][j]);\n  if (mx < k) {\n    cout << -1 << endl;\n    return 0;\n  } \n  cout << hi << endl;\n  if (hi > 100) {\n    return 0;\n  }\n  int s=0,t=0;\n  REP(i,v)REP(j,v) {\n    if (pmat[i][j] == mx) {\n      s = i;\n      t = j;\n    }\n  }\n  vector<int> res;\n  res.push_back(t);\n  for (int i = hi-1; i >= 0; --i) {\n    int nt=0;\n    int64_t nmx=0;\n    REP(j,v) {\n      if (vmat[i][s][j] + mat[j][t] == mx) {\n        nt = j;\n        nmx = vmat[i][s][j];\n      }\n    }\n    t = nt;\n    mx = nmx;\n    res.push_back(t);\n  }\n  reverse(ALL(res));\n  REP(i,res.size()) {\n    if (i) cout << ' ';\n    cout << res[i];\n  }\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nvoid chmin(int &x,int y){ x = min(x,y); }\nvoid chmax(int &x,int y){ x = max(x,y); }\nint n,m,s;\nint val[155][155][21];\nint c[155][155][21];\nP pre[155][155][21];\nvector<int>path[155][155][7];\nint main(){\n\tcin >> n >> m >> s;\n\tfor(int i=0;i<155;i++) for(int j=0;j<155;j++) for(int k=0;k<21;k++){\n\t\t if(i!=j){\n\t\t \tval[i][j][k] = -INF; c[i][j][k] = -INF;\n\t\t }\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tint a,b,c; cin >> a >> b >> c;\n\t\tif(val[a][b][0]<c){\n\t\t\tval[a][b][0] = c; path[a][b][0].clear(); path[a][b][0].pb(a); path[a][b][0].pb(b);\n\t\t}\n\t}\n\tfor(int q=0;q<20;q++){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tif(val[i][j][q]<0 || val[j][k][q]<0) continue;\n\t\t\t\t\tif(val[i][k][q+1]<val[i][j][q]+val[j][k][q]){\n\t\t\t\t\t\tval[i][k][q+1] = val[i][j][q]+val[j][k][q];\n\t\t\t\t\t\tif(q+1 < 7){\n\t\t\t\t\t\t\tpath[i][k][q+1].clear();\n\t\t\t\t\t\t\tfor(int ii=0;ii<path[i][j][q].size();ii++) path[i][k][q+1].pb(path[i][j][q][ii]);\n\t\t\t\t\t\t\tfor(int ii=1;ii<path[j][k][q].size();ii++) path[i][k][q+1].pb(path[j][k][q][ii]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint L = 0,R = s+1; //(L,R]\n\twhile(R-L > 1){\n\t\tint mid = (L+R)/2;\n\t\tint v[155][155][2]={};\n\t\tfor(int i=0;i<155;i++) for(int j=0;j<155;j++) if(i!=j){v[i][j][0] = v[i][j][1] = -INF;}\n\t\tint cur = 0,nxt = 1;\n\t\tfor(int q=0;q<20;q++){\n\t\t\tif(!((mid>>q)&1)) continue;\n\t\t\tfor(int i=0;i<n;i++) for(int j=0;j<n;j++) v[i][j][nxt] = -INF;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\t\tif(v[i][j][cur]<0 || val[j][k][q]<0) continue;\n\t\t\t\t\t\tchmax(v[i][k][nxt],v[i][j][cur]+val[j][k][q]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(cur,nxt);\n\t\t}\n\t\tfor(int i=0;i<n;i++) for(int j=0;j<n;j++){\n\t\t\tif(v[i][j][cur] >= s) goto ok;\n\t\t}\n\t\tL = mid; continue; ok: R = mid;\n\t}\n\tif(R == s+1){\n\t\tputs(\"-1\"); return 0;\n\t}\n\tprintf(\"%d\\n\",R);\n\tif(R>100) return 0;\n\t\n\tvector<int>ans;\n\tint num = 0;\n\tfor(int q=0;q<20;q++){\n\t\tif(!((R>>q)&1)) continue;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tif(val[j][k][q]>=0 && c[i][j][num]>=0 && c[i][k][num+1]<c[i][j][num]+val[j][k][q]){\n\t\t\t\t\t\tc[i][k][num+1] = c[i][j][num]+val[j][k][q];\n\t\t\t\t\t\tpre[i][k][num+1] = mp(j,q);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnum++;\n\t}\n\tint S,G,MX = 0;\n\tfor(int i=0;i<n;i++) for(int j=0;j<n;j++){\n\t\tif(MX < c[i][j][num]){\n\t\t\tMX = c[i][j][num]; S = i; G = j;\n\t\t}\n\t}\n\tans.pb(G);\n\twhile(num){\n\t\t//val[pre[S][G][num].fi][G][pre[S][G][num].sc]\n\t\tint a = pre[S][G][num].fi, b = pre[S][G][num].sc; //cout << a << \" \" << b << endl;\n\t\tfor(int i=path[a][G][b].size()-2;i>=0;i--) ans.pb(path[a][G][b][i]);\n\t\tG = a; num--;\n\t}\n\treverse(ans.begin(),ans.end());\n\tfor(int i=0;i<ans.size();i++){\n\t\tprintf(\"%d \",ans[i]);\n\t}\n\tputs(\"\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int64 LINF = 1LL << 60;\nconst int INF = 1 << 30;\n\nint V, E, K;\nint64 g[31][150][150];\n\nint main() {\n  fill_n(**g, 31 * 150 * 150, -LINF);\n\n  cin >> V >> E >> K;\n  for(int i = 0; i < V; i++) {\n    g[0][i][i] = 0;\n  }\n  for(int i = 0; i < E; i++) {\n    int a, b;\n    int64 c;\n    cin >> a >> b >> c;\n    g[0][a][b] = max(g[0][a][b], c);\n  }\n\n  for(int i = 0; i < 30; i++) {\n    for(int j = 0; j < V; j++) {\n      for(int k = 0; k < V; k++) {\n        for(int l = 0; l < V; l++) {\n          g[i + 1][k][l] = max(g[i + 1][k][l], g[i][k][j] + g[i][j][l]);\n        }\n      }\n    }\n  }\n\n\n  auto check = [&](int bit) {\n    vector< int64 > dp(V);\n    for(int k = 30; k >= 0; k--) {\n      if((bit >> k) & 1) {\n        vector< int64 > dp2(V);\n        for(int i = 0; i < V; i++) {\n          for(int j = 0; j < V; j++) {\n            dp2[j] = max(dp2[j], dp[i] + g[k][i][j]);\n          }\n        }\n        dp.swap(dp2);\n      }\n    }\n    return *max_element(begin(dp), end(dp)) >= K;\n  };\n\n  int ok = INF, ng = 0;\n  while(ok - ng > 1) {\n    int mid = (ok + ng) / 2;\n    if(check(mid)) ok = mid;\n    else ng = mid;\n  }\n\n  if(ok == INF) {\n    cout << -1 << endl;\n  } else {\n    cout << ok << endl;\n\n    if(ok <= 100) {\n      int64 dp[101][150] = {{}}, pv[101][150];\n      for(int i = 0; i < ok; i++) {\n        for(int j = 0; j < V; j++) {\n          for(int k = 0; k < V; k++) {\n            if(dp[i][j] + g[0][j][k] > dp[i + 1][k]) {\n              dp[i + 1][k] = dp[i][j] + g[0][j][k];\n              pv[i + 1][k] = j;\n            }\n          }\n        }\n      }\n      int high = 00;\n      for(int i = 0; i < V; i++) {\n        if(dp[ok][i] >= dp[ok][high]) high = i;\n      }\n      vector< int > route;\n      for(int i = ok; i >= 0; i--) {\n        route.push_back(high);\n        high = pv[i][high];\n      }\n      reverse(begin(route), end(route));\n      for(int i = 0; i < route.size(); i++) {\n        if(i) cout << \" \";\n        cout << route[i];\n      }\n      cout << endl;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<int(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nconstexpr int64_t INF = INT64_C(1000000000000000000);\n\nusing Array = vector<int64_t>;\nusing Matrix = vector<Array>;\n\nMatrix mul(const Matrix& lhs, const Matrix& rhs) {\n  int r = lhs.size();\n  Matrix res(r, Array(r, -INF));\n  REP(i,r) REP(k,r) REP(j,r) {\n    res[i][j] = max(res[i][j], lhs[i][k] + rhs[k][j]);\n  }\n  return res;\n}\n\nMatrix pow(const Matrix& mat, int64_t index) {\n  if (index == 1) return mat;\n  if ((index % 2) == 1) {\n    return mul(mat, pow(mat, index-1));\n  }\n  return pow(mul(mat, mat), index/2);\n}\n\nint main() {\n  int64_t v,e,k;\n  cin>>v>>e>>k;\n  Matrix mat(v, Array(v, -INF));\n  REP(i,e) {\n    int64_t s,t,c;\n    cin>>s>>t>>c;\n    mat[s][t] = max(mat[s][t], c);\n  }\n  int64_t hi = 1;\n  Matrix m2 = mat;\n  while (true) {\n    hi *= 2;\n    m2 = mul(m2, m2);\n    int64_t mx = -INF;\n    REP(i,v)REP(j,v) mx = max(mx, m2[i][j]);\n    if (mx >= k) break;\n    if (mx < 0) break;\n  }\n  int64_t lo = 0;\n  while (hi - lo > 1) {\n    int64_t mid = (hi + lo) / 2;\n    auto pmat = pow(mat, mid);\n    int64_t mx = -INF;\n    REP(i,v)REP(j,v) mx = max(mx, pmat[i][j]);\n    if (mx < 0) {\n      hi = mid;\n    } else if (mx >= k) {\n      hi = mid;\n    } else {\n      lo = mid;\n    }\n  }\n  auto pmat = pow(mat, hi);\n  int64_t mx = -INF;\n  REP(i,v)REP(j,v) mx = max(mx, pmat[i][j]);\n  if (mx < k) {\n    cout << -1 << endl;\n    return 0;\n  } \n  cout << hi << endl;\n  if (hi > 100) {\n    return 0;\n  }\n  vector<Matrix> vmat;\n  Matrix m(v, Array(v, 0));\n  REP(i,hi) {\n    vmat.push_back(m);\n    m = mul(mat, m);\n  }\n  int s=0,t=0;\n  REP(i,v)REP(j,v) {\n    if (pmat[i][j] == mx) {\n      s = i;\n      t = j;\n    }\n  }\n  vector<int> res;\n  for (int i = hi-1; i >= 0; --i) {\n    res.push_back(t);\n    int nt=0;\n    int nmx=0;\n    REP(j,v) {\n      if (vmat[i][s][j] + mat[j][t] == mx) {\n        nt = j;\n        nmx = vmat[i][s][j];\n      }\n    }\n    t = nt;\n    mx = nmx;\n  }\n  cout << s;\n  reverse(ALL(res));\n  for (int r:res) cout << ' ' << r;\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <stack>\nusing namespace std;\n\ntypedef pair<int,int> pii;\ntypedef vector<vector<int> > table;\n\nconst int INF = (int)1e9;\n\nint V, E, K;\ntable unit;\n\ninline void update(int &a, int b){\n\tif( a < b ) a = b;\n}\n\nvoid mul(table &t1, const table &t2){\n\ttable tmp = unit;\n\tfor(int i = 0; i < V; ++i)\n\tfor(int j = 0; j < V; ++j)\n\tfor(int k = 0; k < V; ++k){\n\t\tupdate(tmp[i][k], t1[i][j] + t2[j][k]);\n\t}\n\tt1.swap(tmp);\n}\n\npii maxindex(const table &t){\n\tint mi = 0, mj = 0;\n\tfor(int i = 0; i < V; ++i)\n\tfor(int j = 0; j < V; ++j){\n\t\tif( t[i][j] > t[mi][mj] ){\n\t\t\tmi = i;\n\t\t\tmj = j;\n\t\t}\n\t}\n\treturn pii(mi, mj);\n}\n\ninline table pow(int k, const vector<table> &tbls){\n\ttable t = unit;\n\tfor(int i = 0; (1 << i) <= k; ++i){\n\t\tif( (1 << i) & k )\n\t\t\tmul(t, tbls[i]);\n\t}\n\treturn t;\n}\n\nint main(){\n\tscanf(\"%d%d%d\", &V, &E, &K);\n\t\n\tunit.assign(V, vector<int>(V, -INF) );\n\tfor(int i = 0; i < V; ++i){\n\t\tunit[i][i] = 0;\n\t}\n\t\n\tint s, f, c;\n\ttable t0 = unit;\n\tfor(int i = 0; i < E; ++i){\n\t\tscanf(\"%d%d%d\", &s, &f, &c);\n\t\tupdate(t0[s][f], c);\n\t}\n\n\tvector<table> tbls;\n\ttbls.reserve(32);\n\t\n\ttable t1 = t0;\n\tfor(int i = 0; ; ++i){\n\t\ttbls.push_back(t1);\n\t\t\n\t\tpii p = maxindex(t1);\n\t\tif( t1[p.first][p.second] >= K ) break;\n\t\t\n\t\tif( i >= 30 ){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tmul(t1, t1);\n\t}\n\n\tint right = 1 << (tbls.size() - 1);\n\tint left = right / 2;\n\twhile(left < right){\n\t\tint mid = (left + right) / 2;\n\t\t\n\t\tt1 = pow(mid, tbls);\n\t\tpii p = maxindex(t1);\n\n\t\tif( t1[p.first][p.second] >= K ){\n\t\t\tright = mid;\n\t\t}\n\t\telse{\n\t\t\tleft = mid + 1;\n\t\t}\n\t}\n\t\n\tprintf(\"%d\\n\", left);\n\tif( left > 100 ) return 0;\n\n\tf = maxindex( pow(left, tbls) ).second;\n\tvector<vector<int> > from(left, vector<int>(V, -1) );\n\n\tvector<int> c1(V, 0), c2(V, -INF);\n\tfor(int i = 0; i < left; ++i){\n\t\tfor(int j = 0; j < V; ++j)\n\t\tfor(int k = 0; k < V; ++k){\n\t\t\tif( c2[k] < c1[j] + t0[j][k] ){\n\t\t\t\tc2[k] = c1[j] + t0[j][k];\n\t\t\t\tfrom[i][k] = j;\n\t\t\t}\n\t\t}\n\t\t\n\t\tc1.swap(c2);\n\t\tfill(c2.begin(), c2.end(), -INF);\n\t}\n\n\tstack<int> st;\n\tfor(int i = left - 1; i >= 0; --i){\n\t\tst.push(f);\n\t\tf = from[i][f];\n\t}\n\n\tprintf(\"%d\", f);\n\twhile( !st.empty() ){\n\t\tprintf(\" %d\", st.top() );\n\t\tst.pop();\n\t}\n\tputs(\"\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\nint V,E,K;\nconst int INF = (1<<29);\nmat G;\n\nmat g[30];\nmat u[30];\n\nint add(int a,int b){\n  if(a==-INF||b==-INF)return -INF;\n  return min(a+b,K);\n}\n\npair<mat,mat> merge(mat A,mat B, bool flag=false){\n  mat X( V, vec(V, -INF) );\n  mat Y( V, vec(V, -INF) );\n  \n  for(int from=0;from<V;from++){\n    for(int to=0;to<V;to++){\n      for(int ex=0;ex<V;ex++){\n        int cost=add(A[from][ex],B[ex][to]);\n        if(X[from][to]<cost){\n          X[from][to]=cost;\n          Y[from][to]=ex;\n        }\n      }\n    }\n  }\n  return make_pair(X,Y);\n}\n\n\nint calc(int m,int &si,int &ti){\n  mat t;\n  for(int i=0;i<30;i++){\n    if(m>>i&1){\n      if(t.empty()){\n        t=g[i];\n      }else{\n        t=merge(t,g[i]).first;\n      }\n    }\n  }\n  \n  int res=-INF;\n  for(int i=0;i<V;i++){\n    for(int j=0;j<V;j++){\n      if(res<t[i][j]){\n        si=i;\n        ti=j;\n        res=t[i][j];\n      }\n    }\n  }\n  return res;\n}\n\nvoid Dfs(vec& s,int from,int to,int len){\n  if(len==0)return;\n  \n  for(int i=0;i<30;i++){\n    if(~len>>i&1)continue;\n    int ex=u[i][from][to];\n\n    if(i==0){\n      if(len>=2)s.push_back(ex);\n      Dfs(s,ex,to,len-1);\n    }else{\n      int sub=(1<<i)/2;\n      Dfs(s,from,ex,sub);\n      s.push_back(ex);\n      Dfs(s,ex,to,len-sub);\n    }\n    break;\n  }\n}\n\nint main(){\n\n  cin>>V>>E>>K;\n  G=mat( V, vec(V, -INF) );\n  \n  g[0]=u[0]=G;\n  for(int i=0;i<V;i++)g[0][i][i]=0;\n  \n  for(int i=0;i<E;i++){\n    int a,b,c;\n    cin>>a>>b>>c;\n    assert(a!=b);\n    G[a][b]=max(G[a][b],c);\n    \n    g[0][a][b]=max(g[0][a][b],c);\n    u[0][a][b]=b;\n  }\n\n  \n  for(int i=1;i<30;i++){\n    pair<mat,mat> temp=merge(g[i-1],g[i-1]);\n    g[i]=temp.first;\n    u[i]=temp.second;\n  }\n  \n  int si,ti;\n  int left=1,right=K+1,mid;\n\n  while( left < right ){\n    mid=(left+right)/2;\n    if( calc(mid,si,ti) >= K ){\n      right=mid;\n    }else{\n      left=mid+1;\n    }\n  }\n  /*\n  for(int i=0;i<V;i++)g[0][i][i]=-INF;\n  for(int i=1;i<30;i++){\n    pair<mat,mat> temp=merge(g[i-1],g[i-1]);\n    g[i]=temp.first;\n    u[i]=temp.second;\n  }\n  */\n  calc(left,si,ti);\n  \n  if(left==K+1){\n    cout<<-1<<endl;\n  }else{\n    cout<<left<<endl;\n    if(left<=100){\n      vec tab;\n      tab.push_back(si);\n      Dfs(tab,si,ti,left);\n      tab.push_back(ti);\n      \n      int sum=0;\n      assert( left+1==(int)tab.size() );\n      for(int i=0;i<(int)tab.size();i++){\n        if(i>0 && G[ tab[i-1]][ tab[i] ] == -INF ){\n          assert(0);\n        }\n        if(i>0)sum+=G[ tab[i-1]][ tab[i] ];\n        if(i)cout<<' ';\n        cout<<tab[i];\n      }\n      cout<<endl;\n      assert(sum == calc(left,si,ti) );\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// template {{{\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define loop(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rep(i, n) loop(i, 0, n)\n#define rloop(i, a, b) for (int i = (int)(b) - 1; i >= (int)(a); i--)\n#define rrep(i, n) rloop(i, 0, n)\n#define eb emplace_back\n#define ef emplace_front\n#define pb pop_back\n#define pf pop_front\n#define all(c) std::begin(c), std::end(c)\n#define mp std::make_pair\n#define mt std::make_tuple\n#define fi first\n#define se second\n#define popcnt __builtin_popcountll\n\nusing uint = unsigned;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n\ntemplate<typename T>\nusing max_pq = priority_queue<T, vector<T>, less<T>>;\n\ntemplate<typename T>\nusing min_pq = priority_queue<T, vector<T>, greater<T>>;\n\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9 + 10;\nconst ll LLINF = 1e18 + 10;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\nconst int dx8[] = {-1, -1, 0, 1, 1, 1, 0, -1};\nconst int dy8[] = {0, -1, -1, -1, 0, 1, 1, 1};\n\ntemplate<typename T>\ninline T sq(T x){ return x * x; }\n\ntemplate<typename T, typename U>\ninline bool chmax(T &x, U y){ if (x >= y) return false; x = y; return true; }\n\ntemplate<typename T, typename U>\ninline bool chmin(T &x, U y){ if (x <= y) return false; x = y; return true; }\n\ntemplate<typename T>\ninline void sort(T &c){ std::sort(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void reverse(T &c){ std::reverse(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void unique(T &c){ std::sort(std::begin(c), std::end(c)); c.erase(std::unique(all(c)), std::end(c)); }\n\n// }}}\n\nint n, m, k;\nint g[150][150];\n\npair<int, vector<int>> calc(int x, bool build = false)\n{\n\tvector<vector<int>> dp(x + 1, vector<int>(n, 0));\n\tvector<vector<int>> pr(x + 1, vector<int>(n, -1));\n\trep(i, x) rep(j, n) rep(k, n){\n\t\tif (chmax(dp[i + 1][k], dp[i][j] + g[j][k])){\n\t\t\tpr[i + 1][k] = j;\n\t\t}\n\t}\n\n\tpair<int, vector<int>> res;\n\tint p = 0;\n\trep(i, n){\n\t\tif (chmax(res.fi, dp[x][i])){\n\t\t\tp = i;\n\t\t}\n\t}\n\tif (build){\n\t\trrep(i, x){\n\t\t\tres.se.eb(p);\n\t\t\tp = pr[i + 1][p];\n\t\t}\n\t\tres.se.eb(p);\n\t\treverse(res.se);\n\t}\n\n\treturn res;\n}\n\nvector<vector<int>> add(const vector<vector<int>> &a, const vector<vector<int>> &b)\n{\n\tvector<vector<int>> res(n, vector<int>(n, -INF));\n\trep(k, n) rep(i, n) rep(j, n){\n\t\tchmax(res[i][j], a[i][k] + b[k][j]);\n\t}\n\treturn res;\n}\n\nint calc2(int x)\n{\n\tvector<vector<int>> a(n, vector<int>(n));\n\trep(i, n) rep(j, n) a[i][j] = i == j ? 0 : -INF;\n\tauto b = a;\n\trep(i, n) rep(j, n) b[i][j] = g[i][j];\n\twhile (x){\n\t\tif (x & 1) a = add(a, b);\n\t\tb = add(b, b);\n\t\tx >>= 1;\n\t}\n\n\tint res = 0;\n\trep(i, n) rep(j, n) chmax(res, a[i][j]);\n\treturn res;\n}\n\nbool cond(int x)\n{\n\tif (x <= 100) return calc(x).fi >= k;\n\treturn calc2(x) >= k;\n}\n\nint main()\n{\n\tcin >> n >> m >> k;\n\trep(i, n) rep(j, n) g[i][j] = -INF;\n\trep(i, m){\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\tchmax(g[a][b], c);\n\t}\n\n\tint lb = 0, ub = 100010;\n\twhile (ub - lb > 1){\n\t\tint md = (lb + ub) / 2;\n\t\t(cond(md) ? ub : lb) = md;\n\t}\n\t\n\tint res = ub;\n\t\n\tif (res > 100000){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\t\n\tcout << res << endl;\n\t\n\tif (res <= 100){\n\t\tauto v = calc(res, true).se;\n\t\trep(i, v.size()){\n\t\t\tcout << v[i] << \"\\n \"[i < v.size() - 1];\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing matrix = vector<vector<ll>>;\n\nconst ll INF = 1e9;\n\nmatrix prod(const matrix& a, const matrix& b){\n\tint n = a.size();\n\tmatrix res(n, vector<ll>(n, -INF));\n\tfor(int i = 0;i < n;i++){\n\t\tfor(int j = 0;j < n;j++){\n\t\t\tfor(int k = 0;k < n;k++){\n\t\t\t\tres[i][k] = max(res[i][k], a[i][j] + b[j][k]);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nmatrix power(matrix a, int x){\n\tint n = a.size();\n\tmatrix res(n, vector<ll>(n, -INF));\n\tfor(int i = 0;i < n;i++) res[i][i] = 0;\n\twhile(x){\n\t\tif(x & 1) res = prod(a, res);\n\t\ta = prod(a, a);\n\t\tx >>= 1;\n\t}\n\treturn res;\n}\n\nint main() {\n\tint V, E, K;\n\tcin >> V >> E >> K;\n\tmatrix G(V, vector<ll>(V, -INF));\n\tfor(int i = 0;i < V;i++) G[i][i] = 0;\n\tfor(int i = 0;i < E;i++){\n\t\tint u, v;\n\t\tll c;\n\t\tcin >> u >> v >> c;\n\t\tG[u][v] = max(G[u][v], c);\n\t}\n\tint lb = 0, ub = K + 1;\n\twhile(ub - lb > 1){\n\t\tint m = (lb + ub) >> 1;\n\t\tauto v = power(G, m);\n\t\tll ma = 0;\n\t\tfor(int i = 0;i < V;i++) ma = max(ma, *max_element(v[i].begin(), v[i].end()));\n\t\tif(ma >= K){\n\t\t\tub = m;\n\t\t}\n\t\telse{\n\t\t\tlb = m;\n\t\t}\n\t}\n\tif(ub == K + 1){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tcout << ub << endl;\n\tif(ub > 100) return 0;\n\tvector<vector<ll>> dp(ub + 1, vector<ll>(V, -INF));\n\tfor(int i = 0;i < V;i++) dp[0][i] = 0;\n\tfor(int x = 0;x < ub;x++){\n\t\tfor(int i = 0;i < V;i++){\n\t\t\tfor(int j = 0;j < V;j++){\n\t\t\t\tdp[x + 1][j] = max(dp[x + 1][j], dp[x][i] + G[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tint pos = 0;\n\tfor(int i = 0;i < V;i++){\n\t\tif(dp[ub][i] > dp[ub][pos]) pos = i;\n\t}\n\tvector<int> res;\n\tres.push_back(pos);\n\tfor(int i = ub;i > 0;i--){\n\t\tfor(int to = 0;to < V;to++){\n\t\t\tif(dp[i - 1][to] + G[to][pos] == dp[i][pos]){\n\t\t\t\tres.push_back(to);\n\t\t\t\tpos = to;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tassert((int)res.size() == ub + 1);\n\treverse(res.begin(), res.end());\n\tfor(int i = 0;i <= ub;i++){\n\t\tcout << res[i] << \" \\n\"[i == ub];\n\t}\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//BEGIN CUT HERE\ntemplate<size_t N,typename R>\nstruct SquareMatrix{\n  typedef array<R, N> arr;\n  typedef array<arr, N> mat;\n  mat dat;\n  \n  SquareMatrix(){\n    for(size_t i=0;i<N;i++)\n      for(size_t j=0;j<N;j++)\n        dat[i][j]=R::add_identity();\n  }\n  SquareMatrix& operator=(const SquareMatrix& a){\n    dat=a.dat;\n    return (*this);\n  }\n  bool operator==(const SquareMatrix& a) const{\n    return dat==a.dat;\n  }\n  \n  size_t size() const{return N;};\n  arr& operator[](size_t k){return dat[k];};\n  const arr& operator[](size_t k) const {return dat[k];};\n  \n  static SquareMatrix add_identity(){return SquareMatrix();}  \n  static SquareMatrix mul_identity(){\n    SquareMatrix res;\n    for(size_t i=0;i<N;i++) res[i][i]=R::mul_identity();\n    return res;\n  }\n  \n  SquareMatrix operator*(const SquareMatrix &B) const{\n    SquareMatrix res=add_identity();\n    for(size_t i=0;i<N;i++)\n      for(size_t j=0;j<N;j++)\n        for(size_t k=0;k<N;k++)\n          res[i][j]=res[i][j]+(dat[i][k]*B[k][j]);\n    return res;\n  }\n  \n  SquareMatrix operator+(const SquareMatrix &B) const{\n    SquareMatrix res=add_identity();\n    for(size_t i=0;i<N;i++)\n      for(size_t j=0;j<N;j++)\n        res[i][j]=dat[i][j]+B[i][j];\n    return res;\n  }\n  \n  SquareMatrix pow(long long n) const{\n    SquareMatrix a=*this,res=mul_identity();    \n    while(n){\n      if(n&1) res=res*a;      \n      a=a*a;      \n      n>>=1;\n    }\n    return res;\n  }\n};\n//END CUT HERE\n\ntemplate<typename T,T MOD = 1000000007>\nstruct Mint{\n  T v;\n  Mint():v(0){}\n  Mint(signed v):v(v){}\n  Mint(long long t){v=t%MOD;if(v<0) v+=MOD;}\n\n  Mint pow(long long k){\n    Mint res(1),tmp(v);\n    while(k){\n      if(k&1) res*=tmp;\n      tmp*=tmp;\n      k>>=1;\n    }\n    return res;\n  }\n  \n  static Mint add_identity(){return Mint(0);}\n  static Mint mul_identity(){return Mint(1);}\n  \n  Mint inv(){return pow(MOD-2);}\n  \n  Mint& operator+=(Mint a){v+=a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator-=(Mint a){v+=MOD-a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator*=(Mint a){v=1LL*v*a.v%MOD;return *this;}\n  Mint& operator/=(Mint a){return (*this)*=a.inv();}\n  \n  Mint operator+(Mint a) const{return Mint(v)+=a;};\n  Mint operator-(Mint a) const{return Mint(v)-=a;};\n  Mint operator*(Mint a) const{return Mint(v)*=a;};\n  Mint operator/(Mint a) const{return Mint(v)/=a;};\n\n  Mint operator-(){return v?MOD-v:v;}\n\n  bool operator==(const Mint a)const{return v==a.v;}\n  bool operator!=(const Mint a)const{return v!=a.v;}\n  bool operator <(const Mint a)const{return v <a.v;}\n};\n\n\nstruct FastIO{\n  FastIO(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n  }\n}fastio_beet;\n\n\ntemplate<typename T>\nvector<T> compress(vector<T> v){\n  sort(v.begin(),v.end());\n  v.erase(unique(v.begin(),v.end()),v.end());\n  return v;\n}\n\ntemplate<typename T>\nmap<T, Int> dict(const vector<T> &v){\n  map<T, Int> res;\n  for(Int i=0;i<(Int)v.size();i++)\n    res[v[i]]=i;\n  return res;\n}\n\ntemplate <typename T, typename F>\nstruct SegmentTree{\n  Int n;\n  F f;\n  T ti;\n  vector<T> dat;\n  SegmentTree(){};\n  SegmentTree(F f,T ti):f(f),ti(ti){}\n  void init(Int n_){    \n    n=1;\n    while(n<n_) n<<=1;\n    dat.assign(n<<1,ti);\n  }\n  void build(const vector<T> &v){\n    Int n_=v.size();\n    init(n_);\n    for(Int i=0;i<n_;i++) dat[n+i]=v[i];\n    for(Int i=n-1;i;i--)\n      dat[i]=f(dat[(i<<1)|0],dat[(i<<1)|1]);\n  }\n  void set_val(Int k,T x){\n    dat[k+=n]=x;\n    while(k>>=1)\n      dat[k]=f(dat[(k<<1)|0],dat[(k<<1)|1]);    \n  }\n  T query(Int a,Int b){\n    T vl=ti,vr=ti;\n    for(Int l=a+n,r=b+n;l<r;l>>=1,r>>=1) {\n      if(l&1) vl=f(vl,dat[l++]);\n      if(r&1) vr=f(dat[--r],vr);\n    }\n    return f(vl,vr);\n  }\n};\n\n//INSERT ABOVE HERE\nsigned YAHOO2019_FINAL_D(){\n  using M = Mint<Int>; \n  using MM = SquareMatrix<2, M>;\n\n  Int n,q;\n  cin>>n>>q;\n  vector<Int> ts(q),ls(q),rs(q),ps(q);\n  for(Int i=0;i<q;i++){\n    cin>>ts[i];\n    if(ts[i]==1) cin>>ps[i];\n    if(ts[i]==2) cin>>ls[i]>>rs[i];\n  }\n  vector<Int> vs;\n  for(Int i=0;i<q;i++){\n    if(ts[i]==1){\n      vs.emplace_back(ps[i]);\n      vs.emplace_back(ps[i]+1);  \n      vs.emplace_back(ps[i]+2);   \n      vs.emplace_back(ps[i]+3);      \n    }\n    if(ts[i]==2){\n      vs.emplace_back(ls[i]);\n      vs.emplace_back(ls[i]+1);\n      vs.emplace_back(rs[i]);\n      vs.emplace_back(rs[i]+1);\n    }\n  }\n  vs.emplace_back(0);\n  vs.emplace_back(n+1);\n  vs=compress(vs);\n  auto ms=dict(vs);\n  \n  MM A;\n  A[0][0]=M(1);A[0][1]=M(1);\n  A[1][0]=M(1);A[1][1]=M(0);\n\n  vector<MM> vt(vs.size()-1,A);\n  for(Int i=0;i+1<(Int)vs.size();i++){\n    vt[i]=A.pow(vs[i+1]-vs[i]);\n  }\n\n  MM I=MM::mul_identity();\n  auto f=[&](MM a,MM b){return b*a;};\n  SegmentTree<MM, decltype(f)> seg(f,I);\n  seg.build(vt);\n  \n  vector<Int> used(vs.size(),0);  \n  for(Int i=0;i<q;i++){\n    if(ts[i]==1){\n      Int k=ms[ps[i]];\n      used[k]^=1;\n      MM B;\n      for(Int j=k;j<=k+2;j++){\n        if(used[j]){\n          B[0][0]=M(0);B[0][1]=M(0);\n          B[1][0]=M(1);B[1][1]=M(0);        \n        }else{\n          B[0][0]=M(!used[j-1]);B[0][1]=M(!used[j-2]);\n          B[1][0]=M(1);B[1][1]=M(0);\n        }\n        seg.set_val(j,B);   \n      }\n    }\n    if(ts[i]==2){    \n      Int l=ms[ls[i]],r=ms[rs[i]];\n      if(used[l]){\n        cout<<0<<\"\\n\";\n        continue;\n      }\n      auto B=seg.query(l+1,r+1);\n      cout<<B[0][0].v<<\"\\n\";\n    }\n  }\n  cout<<flush;\n  return 0;\n}\n/*\n  verified on 2019/02/23\n  https://atcoder.jp/contests/yahoo-procon2019-final/tasks/yahoo_procon2019_final_d\n*/\n\nsigned DDCC2019_FINAL_D(){\n  string s;\n  cin>>s;\n\n  struct M{\n    uint32_t v;    \n    M(){*this=add_identity();}\n    M(uint32_t v):v(v){}\n    M operator+(const M &a)const{return M(v+a.v);}\n    M operator*(const M &a)const{return M(v*a.v);}\n    static M add_identity(){return M(0);}\n    static M mul_identity(){return M(1);}\n  };\n  \n  using SM = SquareMatrix<6, M>;\n \n  auto f=[](SM a,SM b){return a*b;};\n  SM ti=SM::mul_identity();\n  SegmentTree<SM, decltype(f)> seg(f,ti);\n  vector<SM> vt(s.size(),ti);\n  for(int i=0;i<(int)s.size();i++){\n    if(s[i]=='D') vt[i][0][1]=1;\n    if(s[i]=='I') vt[i][1][2]=1;\n    if(s[i]=='S') vt[i][2][3]=1;\n    if(s[i]=='C') vt[i][3][4]=1;\n    if(s[i]=='O') vt[i][4][5]=1;\n  }\n  seg.build(vt);\n  \n  int q;\n  cin>>q;\n  for(int i=0;i<q;i++){\n    int l,r;\n    cin>>l>>r;\n    l--;\n    cout<<seg.query(l,r)[0][5].v<<\"\\n\";\n  }\n  cout<<flush;\n  return 0;\n}\n/*\n  verified on 2019/02/23\n  https://atcoder.jp/contests/ddcc2019-final/tasks/ddcc2019_final_d\n*/\n\nsigned AOJ_2397(){\n  const int MAX = 80;\n  const int MOD = 1e9+9;\n  using M = Mint<int, MOD>;\n  using SM = SquareMatrix<MAX, M>;\n\n  using ll = long long;\n  ll w,h,n;\n  ll cnt=0;\n  while(cin>>w>>h>>n,w){\n    vector<ll> x(n),y(n);\n    for(int i=0;i<n;i++) cin>>x[i]>>y[i];\n    {\n      using P = pair<ll, ll>;\n      vector<P> vp;\n      for(int i=0;i<n;i++) vp.emplace_back(y[i],x[i]);\n      sort(vp.begin(),vp.end());\n      for(int i=0;i<n;i++) tie(y[i],x[i])=vp[i];\n    }\n    SM b;\n    for(int i=0;i<w;i++){\n      b[i][i]=M(1);\n      if(i-1>=0) b[i][i-1]=M(1);\n      if(i+1<w)  b[i][i+1]=M(1);\n    }\n    ll d=1;\n    SM res=SM::mul_identity();    \n    for(int k=0;k<n;k++){\n      if(y[k]==d) continue;\n      res=b.pow(y[k]-d-1)*res;\n      int j=k;\n      SM c(b);\n      while(j<n&&y[k]==y[j]){\n        for(int i=0;i<w;i++) c[x[j]-1][i]=0;\n        j++;\n      }\n      res=c*res;\n      d=y[k];\n    }\n    res=b.pow(h-d)*res;\n    cout<<\"Case \"<<++cnt<<\": \"<<res[w-1][0].v<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2019/04/11\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2397\n*/\n\nsigned AOJ_2432(){  \n  const int MAX = 160;\n  const int INF = 1e8;\n\n  struct M{\n    int v;\n    M(){*this=add_identity();}\n    M(int v):v(v){}\n    M operator+(const M &a)const{return M(max(v,a.v));}\n    M operator*(const M &a)const{return M(v+a.v);}\n    static M add_identity(){return M(-INF);}\n    static M mul_identity(){return M(0);}\n  };\n  using SM = SquareMatrix<MAX, M>;\n\n  int n,m,k;\n  cin>>n>>m>>k;\n  vector<SM> vs(1),ws(1);\n  \n  for(int i=0;i<n;i++){\n    vs[0][i][i]=0;\n    ws[0][i][i]=0;\n  }\n  \n  for(int i=0;i<m;i++){\n    int a,b,c;\n    cin>>a>>b>>c;\n    chmax(vs[0][a][b].v,c);\n  }\n  \n  for(int t=0;t<20;t++){\n    SM tv=vs[t]*vs[t];\n    SM tw=vs[t]*ws[t];\n    vs.emplace_back(tv);    \n    ws.emplace_back(tw); \n  }\n  \n  auto len=[&](SM &sm)->int{\n             int res=0;\n             for(int i=0;i<n;i++)\n               for(int j=0;j<n;j++)\n                 chmax(res,sm[i][j].v);\n             return res;\n           };\n\n  if(len(vs.back())<k){\n    cout<<-1<<endl;\n    return 0;\n  }\n\n  int ans=0;\n  SM res(ws[0]);\n  for(int t=20;t>=0;t--){\n    SM tmp=res*ws[t];\n    SM nxt=res*vs[t];\n    if(len(tmp)<k){\n      res.dat=nxt.dat;\n      ans+=1<<t;\n    }\n  }\n  cout<<ans<<endl;\n  if(ans>100) return 0;\n\n  int dp[MAX][MAX];\n  int pr[MAX][MAX];\n  for(int i=0;i<MAX;i++){\n    for(int j=0;j<MAX;j++){\n      dp[i][j]=-INF;\n      pr[i][j]=-1;\n    }\n  }\n  for(int v=0;v<n;v++) dp[0][v]=0;\n  for(int i=0;i<ans;i++){\n    for(int v=0;v<n;v++){\n      for(int u=0;u<n;u++){\n        if(dp[i+1][u]<dp[i][v]+vs[0][v][u].v){\n          dp[i+1][u]=dp[i][v]+vs[0][v][u].v;\n          pr[i+1][u]=v;\n        }\n      }\n    }\n  }\n  int pos=0;\n  for(int v=0;v<n;v++)\n    if(dp[ans][v]>dp[ans][pos]) pos=v;\n\n  vector<int> vx;\n  for(int i=ans;i>=0;i--){\n    vx.emplace_back(pos);\n    pos=pr[i][pos];    \n  }\n  reverse(vx.begin(),vx.end());\n  for(int i=0;i<=ans;i++){\n    if(i) cout<<\" \";\n    cout<<vx[i];\n  }\n  cout<<endl;\n  return 0;\n}\n/*\n  verified on 2019/04/11\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2432\n*/\n\nsigned main(){  \n  //YAHOO2019_FINAL_D();\n  //DDCC2019_FINAL_D();\n  //AOJ_2397();\n  AOJ_2432();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\nusing namespace std;\nint dp1[160][160];\nint rev[160][160];\nint dp2[160][160];\nint g[160][160];\nint dp3[160][160];\nint sg[160][160];\nint cost[310][160];\nint main(){\n\tint a,b,c;\n\tscanf(\"%d%d%d\",&a,&b,&c);\n\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++){\n\t\tg[i][j]=-99999999;\n\t}\n\tfor(int i=0;i<b;i++){\n\t\tint p,q,r;\n\t\tscanf(\"%d%d%d\",&p,&q,&r);\n\t\tif(!~g[p][q]||g[p][q]<r){\n\t\t\tg[p][q]=r;\n\t\t}\n\t}\n\tfor(int i=0;i<160;i++)for(int j=0;j<160;j++){\n\t\tdp1[i][j]=dp2[i][j]=-999999999;\n\t}\n\tfor(int i=0;i<a;i++)dp1[0][i]=dp2[0][i]=0;\n\tfor(int i=0;i<155;i++){\n\t\tfor(int j=0;j<a;j++){\n\t\t\tfor(int k=0;k<a;k++){\n\t\t\t\tif(dp1[i][j]>=0){\n\t\t\t\t\tif(dp1[i+1][k]<dp1[i][j]+g[j][k]){\n\t\t\t\t\t\tdp1[i+1][k]=dp1[i][j]+g[j][k];\n\t\t\t\t\t\trev[i+1][k]=j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(dp2[i][j]>=0){\n\t\t\t\t\tdp2[i+1][k]=max(dp2[i+1][k],dp2[i][j]+g[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=100;i++){\n\t\tint ms=0;\n\t\tint at=0;\n\t\tfor(int j=0;j<a;j++){\n\t\t\tif(ms<dp1[i][j]){\n\t\t\t\tms=dp1[i][j];\n\t\t\t\tat=j;\n\t\t\t}\n\t\t}\n\t\tif(ms>=c){\n\t\t\tprintf(\"%d\\n\",i);\n\t\t\tstack<int>S;\n\t\t\tfor(int j=i;j>=0;j--){\n\t\t\t\tS.push(at);\n\t\t\t\tat=rev[j][at];\n\t\t\t}\n\t\t\tfor(int j=0;j<=i;j++){\n\t\t\t\tif(j)printf(\" \");\n\t\t\t\tprintf(\"%d\",S.top());\n\t\t\t\tS.pop();\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(int i=0;i<a;i++){\n\t\tfor(int j=0;j<160;j++)for(int k=0;k<160;k++)sg[j][k]=-999999999;\n\t\tsg[0][i]=0;\n\t\tfor(int j=0;j<a;j++){\n\t\t\tfor(int k=0;k<a;k++){\n\t\t\t\tif(sg[j][k]<0)continue;\n\t\t\t\tfor(int l=0;l<a;l++){\n\t\t\t\t\tsg[j+1][l]=max(sg[j+1][l],sg[j][k]+g[k][l]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<=a;j++)dp3[i][j]=sg[j][i];\n\t}\n\tint ret=99999999;\n\tfor(int i=0;i<a;i++){\n\t\tfor(int j=0;j<a;j++){\n\t\t\tfor(int k=0;k<a;k++){\n\t\t\t\tfor(int l=0;l<=a;l++){\n\t\t\t\t\tint t=dp1[i][j]+dp2[k][j];\n\t\t\t\t\tif(c<=t){\n\t\t\t\t\t\tret=min(ret,i+k);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(dp3[j][l]<=0)continue;\n\t\t\t\t\tret=min(ret,i+k+((c-t)+dp3[j][l]-1)/dp3[j][l]*l);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(ret>9999999){\n\t\tret=-1;\n\t}\n\tprintf(\"%d\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int64 LINF = 1LL << 60;\nconst int INF = 1 << 30;\n\nint V, E, K;\nint64 g[31][150][150];\n\nint main() {\n  fill_n(**g, 31 * 150 * 150, -LINF);\n\n  cin >> V >> E >> K;\n  for(int i = 0; i < V; i++) {\n    g[0][i][i] = 0;\n  }\n  for(int i = 0; i < E; i++) {\n    int a, b;\n    int64 c;\n    cin >> a >> b >> c;\n    g[0][a][b] = max(g[0][a][b], c);\n  }\n\n  for(int i = 0; i < 30; i++) {\n    for(int j = 0; j < V; j++) {\n      for(int k = 0; k < V; k++) {\n        for(int l = 0; l < V; l++) {\n          g[i + 1][k][l] = max(g[i + 1][k][l], g[i][k][j] + g[i][j][l]);\n        }\n      }\n    }\n  }\n\n\n  auto check = [&](int bit) {\n    vector< int64 > dp(V);\n    for(int k = 30; k >= 0; k--) {\n      if((bit >> k) & 1) {\n        vector< int64 > dp2(V);\n        for(int i = 0; i < V; i++) {\n          for(int j = 0; j < V; j++) {\n            dp2[j] = max(dp2[j], dp[i] + g[k][i][j]);\n          }\n        }\n        dp.swap(dp2);\n      }\n    }\n    return *max_element(begin(dp), end(dp)) >= K;\n  };\n\n  int ok = INF, ng = 0;\n  while(ok - ng > 1) {\n    int mid = (ok + ng) / 2;\n    if(check(mid)) ok = mid;\n    else ng = mid;\n  }\n\n  if(ok == INF) {\n    cout << -1 << endl;\n  } else {\n    cout << ok << endl;\n\n    if(ok <= 100) {\n      int64 dp[101][150] = {{}}, pv[101][150];\n      for(int i = 0; i < ok; i++) {\n        for(int j = 0; j < V; j++) {\n          for(int k = 0; k < V; k++) {\n            if(dp[i][j] + g[0][j][k] > dp[i + 1][k]) {\n              dp[i + 1][k] = dp[i][j] + g[0][j][k];\n              pv[i + 1][k] = j;\n            }\n          }\n        }\n      }\n      int high = 0;\n      for(int i = 0; i < V; i++) {\n        if(dp[ok][i] >= dp[ok][high]) high = i;\n      }\n      vector< int > route;\n      for(int i = ok; i >= 0; i--) {\n        route.push_back(high);\n        high = pv[i][high];\n      }\n      reverse(begin(route), end(route));\n      for(int i = 0; i < route.size(); i++) {\n        if(i) cout << \" \";\n        cout << route[i];\n      }\n      cout << endl;\n    }\n  }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<int(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nconstexpr int64_t INF = INT64_C(1000000000000000000);\n\nusing Array = vector<int64_t>;\nusing Matrix = vector<Array>;\n\nMatrix mul(const Matrix& lhs, const Matrix& rhs) {\n  int r = lhs.size();\n  Matrix res(r, Array(r, -INF));\n  REP(i,r) REP(k,r) REP(j,r) {\n    res[i][j] = max(res[i][j], lhs[i][k] + rhs[k][j]);\n  }\n  return res;\n}\n\nMatrix pow(const Matrix& mat, int64_t index) {\n  if (index == 1) return mat;\n  if ((index % 2) == 1) {\n    return mul(mat, pow(mat, index-1));\n  }\n  return pow(mul(mat, mat), index/2);\n}\n\nint main() {\n  int64_t v,e,k;\n  cin>>v>>e>>k;\n  Matrix mat(v, Array(v, -INF));\n  REP(i,e) {\n    int64_t s,t,c;\n    cin>>s>>t>>c;\n    mat[s][t] = max(mat[s][t], c);\n  }\n  vector<Matrix> vmat;\n  Matrix m(v, Array(v, -INF));\n  REP(i,v) m[i][i] = 0;\n  vmat.push_back(m);\n  REP(i,max(INT64_C(100),v)) {\n    m = mul(mat, m);\n    vmat.push_back(m);\n  }\n  int64_t mx = -INF;\n  int64_t hi = INF;\n  FOR(idx,1,v+1)REP(i,v)REP(j,v) {\n    if (vmat[idx][i][j] >= k) {\n      if (idx < hi) {\n        hi = idx;\n      }\n    }\n    mx = max(mx, vmat[idx][i][j]);\n  }\n  int64_t mx2 = -INF;\n  FOR(i,2,v+1)REP(j,v) mx2 = max(mx2, vmat[i][j][j]);\n  if (mx2 > 0 && mx < k) {\n    hi = k;\n    int64_t lo = v;\n    while (hi - lo > 1) {\n      int64_t mid = (hi + lo) / 2;\n      auto pmat = pow(mat, mid);\n      int64_t mx = -INF;\n      REP(i,v)REP(j,v) mx = max(mx, pmat[i][j]);\n      if (mx < 0) {\n        hi = mid;\n      } else if (mx >= k) {\n        hi = mid;\n      } else {\n        lo = mid;\n      }\n    }\n  }\n  auto pmat = pow(mat, hi);\n  mx = -INF;\n  REP(i,v)REP(j,v) mx = max(mx, pmat[i][j]);\n  if (mx < k) {\n    cout << -1 << endl;\n    return 0;\n  } \n  cout << hi << endl;\n  if (hi > 100) {\n    return 0;\n  }\n  int s=0,t=0;\n  REP(i,v)REP(j,v) {\n    if (pmat[i][j] == mx) {\n      s = i;\n      t = j;\n    }\n  }\n  vector<int> res;\n  res.push_back(t);\n  for (int i = hi-1; i >= 0; --i) {\n    int nt=0;\n    int64_t nmx=0;\n    REP(j,v) {\n      if (vmat[i][s][j] + mat[j][t] == mx) {\n        nt = j;\n        nmx = vmat[i][s][j];\n      }\n    }\n    t = nt;\n    mx = nmx;\n    res.push_back(t);\n  }\n  reverse(ALL(res));\n  REP(i,res.size()) {\n    if (i) cout << ' ';\n    cout << res[i];\n  }\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<int(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nconstexpr int64_t INF = INT64_C(1000000000000000000);\n\nusing Array = vector<int64_t>;\nusing Matrix = vector<Array>;\n\nMatrix mul(const Matrix& lhs, const Matrix& rhs) {\n  int r = lhs.size();\n  Matrix res(r, Array(r, -INF));\n  REP(i,r) REP(k,r) REP(j,r) {\n    res[i][j] = max(res[i][j], lhs[i][k] + rhs[k][j]);\n  }\n  return res;\n}\n\nMatrix pow(const Matrix& mat, int64_t index) {\n  if (index == 1) return mat;\n  if ((index % 2) == 1) {\n    return mul(mat, pow(mat, index-1));\n  }\n  return pow(mul(mat, mat), index/2);\n}\n\nint main() {\n  int64_t v,e,k;\n  cin>>v>>e>>k;\n  Matrix mat(v, Array(v, -INF));\n  REP(i,e) {\n    int64_t s,t,c;\n    cin>>s>>t>>c;\n    mat[s][t] = max(mat[s][t], c);\n  }\n  vector<Matrix> vmat;\n  Matrix m(v, Array(v, -INF));\n  REP(i,v) m[i][i] = 0;\n  vmat.push_back(m);\n  REP(i,max(INT64_C(100),v)) {\n    m = mul(mat, m);\n    vmat.push_back(m);\n  }\n  int64_t mx = -INF;\n  int64_t hi = INF;\n  FOR(idx,1,v+1)REP(i,v)REP(j,v) {\n    if (vmat[idx][i][j] >= k) {\n      if (idx < hi) {\n        hi = idx;\n      }\n    }\n    mx = max(mx, vmat[idx][i][j]);\n  }\n  int64_t mx2 = -INF;\n  FOR(i,2,v+1)REP(j,v) mx2 = max(mx2, vmat[i][j][j]);\n  if (mx2 > 0 && mx < k && k > v) {\n    hi = k;\n    int64_t lo = v;\n    while (hi - lo > 1) {\n      int64_t mid = (hi + lo) / 2;\n      auto pmat = pow(mat, mid);\n      int64_t mx = -INF;\n      REP(i,v)REP(j,v) mx = max(mx, pmat[i][j]);\n      if (mx < 0) {\n        hi = mid;\n      } else if (mx >= k) {\n        hi = mid;\n      } else {\n        lo = mid;\n      }\n    }\n  }\n  auto pmat = pow(mat, hi);\n  mx = -INF;\n  REP(i,v)REP(j,v) mx = max(mx, pmat[i][j]);\n  if (mx < k) {\n    cout << -1 << endl;\n    return 0;\n  } \n  cout << hi << endl;\n  if (hi > 100) {\n    return 0;\n  }\n  int s=0,t=0;\n  REP(i,v)REP(j,v) {\n    if (pmat[i][j] == mx) {\n      s = i;\n      t = j;\n    }\n  }\n  vector<int> res;\n  res.push_back(t);\n  for (int i = hi-1; i >= 0; --i) {\n    int nt=0;\n    int64_t nmx=0;\n    REP(j,v) {\n      if (vmat[i][s][j] + mat[j][t] == mx) {\n        nt = j;\n        nmx = vmat[i][s][j];\n      }\n    }\n    t = nt;\n    mx = nmx;\n    res.push_back(t);\n  }\n  reverse(ALL(res));\n  REP(i,res.size()) {\n    if (i) cout << ' ';\n    cout << res[i];\n  }\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n#define for_rev(i,a,b) for(int i=(a);i>=(b);--i)\n\nstruct Edge { int to, c; };\n\nvoid maxUpdate(int& a, int b) { a = max(a, b); }\n\nconst int mINF = (-1) * (int)1e9 / 2;\n\nint V, K, E, score[21][155][155], score_buf[2][155][155], dp[155][155], prv[155][155];\nvector< vector< Edge > > adj;\n\nvoid restore(int step, int v) {\n\tint c = step;\n\tvector< int > path;\n\t\n\twhile (v != -1) {\n\t\tpath.push_back(v);\n\t\tv = prv[c--][v];\n\t}\n\t\n\treverse(path.begin(), path.end());\n\tfor_(i,0,step+1) cout << path[i] << (i < step ? \" \" : \"\\n\");\n}\n\nbool shortPhase() {\n\tmemset(dp, -1, sizeof(dp));\n\tmemset(prv, -1, sizeof(prv));\n\t\n\tfor_(v,0,V) dp[0][v] = 0;\n\t\n\tint max_score = -1, step = -1, terminal = -1;\n\t\n\tfor_(i,0,150) {\n\t\tfor_(v,0,V) {\n\t\t\tif (dp[i][v] == -1) continue;\n\t\t\n\t\t\tfor (Edge e : adj[v]) {\n\t\t\t\tif (dp[i + 1][e.to] < dp[i][v] + e.c) {\n\t\t\t\t\tdp[i + 1][e.to] = dp[i][v] + e.c;\n\t\t\t\t\tprv[i + 1][e.to] = v;\n\t\t\t\t\t\n\t\t\t\t\tif (max_score < dp[i + 1][e.to]) {\n\t\t\t\t\t\tmax_score = dp[i + 1][e.to];\n\t\t\t\t\t\tterminal = e.to;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (max_score >= K) {\n\t\t\tstep = i + 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tif (max_score >= K) {\n\t\tcout << step << endl;\n\t\trestore(step, terminal);\n\t\treturn true;\n\t}\n\t\n\tif (max_score == -1) {\n\t\tcout << -1 << endl;\n\t\treturn true;\n\t}\n\t\n\treturn false;\n}\n\nvoid warshall() {\n\tfor_(h,1,21) for_(u,0,V) for_(v,0,V) for_(k,0,V) {\n\t\tif (score[h - 1][u][k] >= 0 && score[h - 1][k][v] >= 0) {\n\t\t\tmaxUpdate(score[h][u][v], score[h - 1][u][k] + score[h - 1][k][v]);\n\t\t}\n\t}\n}\n\nint calcMinStep() {\n\tint res = 0;\n\t\n\tmemset(score_buf, -1, sizeof(score_buf));\n\tfor_(v,0,V) score_buf[0][v][v] = 0;\n\t\n\tfor_rev(h,20,0) {\n\t\tmemset(score_buf[1], -1, sizeof(score_buf[1]));\n\t\tbool flag = false;\n\t\t\n\t\tfor_(u,0,V) for_(v,0,V) for_(k,0,V) {\n\t\t\tif (score_buf[0][u][k] >= 0 && score[h][k][v] >= 0) {\n\t\t\t\tmaxUpdate(score_buf[1][u][v], score_buf[0][u][k] + score[h][k][v]);\n\t\t\t\tif (score_buf[1][u][v] >= K) flag = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (!flag) {\n\t\t\tswap(score_buf[0], score_buf[1]);\n\t\t\tres += 1 << h;\n\t\t}\n\t}\n\t\n\treturn res + 1;\n}\n\nvoid solve() {\n\tif (!shortPhase()) {\n\t\twarshall();\n\t\tint ans = calcMinStep();\n\t\tcout << (ans > (int)1e6 ? -1 : ans) << endl;\n\t}\n}\n\nint main() {\n\tcin >> V >> E >> K;\n\t\n\tadj.assign(V, vector< Edge >());\n\tmemset(score, -1, sizeof(score));\n\t\n\tfor_(i,0,E) {\n\t\tint u, v, c;\n\t\tcin >> u >> v >> c;\n\t\tmaxUpdate(score[0][u][v], c);\n\t\tadj[u].push_back(Edge{v, c});\n\t}\n\t\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\nint V,E,K;\nconst int INF = (1<<29);\nmat G;\n\nmat g[30];\nmat u[30];\n\nint add(int a,int b){\n  if(a==-INF||b==-INF)return -INF;\n  return min(a+b,INF);\n}\n\npair<mat,mat> merge(mat A,mat B, bool flag=false){\n  mat X( V, vec(V, -INF) );\n  mat Y( V, vec(V, -INF) );\n  \n  for(int from=0;from<V;from++){\n    for(int to=0;to<V;to++){\n      for(int ex=0;ex<V;ex++){\n        int cost=add(A[from][ex],B[ex][to]);\n        if(X[from][to]<cost){\n          X[from][to]=cost;\n          Y[from][to]=ex;\n        }\n      }\n    }\n  }\n  return make_pair(X,Y);\n}\n\n\nint calc(int m,int &si,int &ti){\n  mat t;\n  for(int i=0;i<30;i++){\n    if(m>>i&1){\n      if(t.empty()){\n        t=g[i];\n      }else{\n        t=merge(t,g[i]).first;\n      }\n    }\n  }\n  \n  int res=-INF;\n  for(int i=0;i<V;i++){\n    for(int j=0;j<V;j++){\n      if(res<t[i][j]){\n        si=i;\n        ti=j;\n        res=t[i][j];\n      }\n    }\n  }\n  return res;\n}\n\nvoid Dfs(vec& s,int from,int to,int len){\n  if(len<=1)return;\n  if(len==(len&-len)){\n\n    for(int i=0;i<30;i++){\n      if(len>>i&1){\n        int ex=u[i][from][to];\n        Dfs(s,from,ex,len/2);\n        s.push_back(ex);\n        Dfs(s,ex,to,len/2);\n        return;\n      }\n    }\n  }\n  \n  mat t=mat( V, vec(V,-INF) );\n  for(int i=0;i<V;i++)t[i][i]=0;\n  \n  int ex=-1;\n  int sub=-1;\n  \n  for(int i=0;i<30;i++){\n    if(~len>>i&1)continue;\n    pair<mat,mat> tmp=merge(t, g[i]);\n    ex=tmp.second[from][to];\n    sub=(1<<i);\n  }\n\n  Dfs(s,from,ex,len-sub);\n  s.push_back(ex);\n  Dfs(s,ex,to,sub);\n}\n\nint main(){\n  cin>>V>>E>>K;\n  G=mat( V, vec(V, -INF) );\n  g[0]=u[0]=G;\n  for(int i=0;i<V;i++)g[0][i][i]=0;\n  for(int i=0;i<E;i++){\n    int a,b,c;\n    cin>>a>>b>>c;\n    assert(a!=b);\n    G[a][b]=max(G[a][b],c);\n    if(g[0][a][b]<c){\n      g[0][a][b]=c;\n      u[0][a][b]=b;\n    }\n  }\n  \n  for(int i=1;i<30;i++){\n    pair<mat,mat> temp=merge(g[i-1],g[i-1]);\n    g[i]=temp.first;\n    u[i]=temp.second;\n  }\n  int left=1,right=K+1,mid,si,ti;\n  while( left < right ){\n    mid=(left+right)/2;\n    if( calc(mid,si,ti) >= K ){\n      right=mid;\n    }else{\n      left=mid+1;\n    }\n  }\n  /*\n  for(int i=0;i<V;i++)g[0][i][i]=-INF;\n  for(int i=1;i<30;i++){\n    pair<mat,mat> temp=merge(g[i-1],g[i-1]);\n    g[i]=temp.first;\n    u[i]=temp.second;\n  }\n  */\n  assert(  calc(left,si,ti) >= K );\n  \n  if(left==K+1){\n    cout<<-1<<endl;\n  }else{\n    cout<<left<<endl;\n    if(left<=100){\n      vec tab;\n      tab.push_back(si);\n      Dfs(tab,si,ti,left);\n      tab.push_back(ti);\n\n      int sum=0;\n      for(int i=0;i<(int)tab.size();i++){\n\n        \n        if(i>0){\n          int cost=G[ tab[i-1] ][ tab[i] ];\n          if(cost == -INF ){\n            assert(0);\n          }else{\n            sum=add(sum,cost);\n          }\n        }\n        \n        if(i)cout<<' ';\n        cout<<tab[i];\n      }\n      cout<<endl;\n      assert( sum == calc(left,si,ti) );\n      \n    }\n  }\n  return 0;\n}\n\n  \n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 151;\n\ntemplate<typename T> class mat : public vector<vector<T> > {\nprivate:\n    int r,c;    //行,列\npublic:\n    int row() const {\n        return r;\n    }\n    int column() const {\n        return c;\n    }\n    mat(int n,int m,T val = 0){\n        this->r = n,this->c = m;\n        rep(i,n){\n            this->push_back(vector<T>(m,val));\n        }\n    }\n    mat operator+(const mat& another){\n        if(this->r != another.r && this->c != another.c){\n            cout << \"足し算失敗(サイズ不一致)\" << endl;\n            exit(1);\n        }\n        mat<T> X(this->r,this->c);\n        rep(i,this->r){\n            rep(j,this->c){\n                X[i][j] = (*this)[i][j] + another[i][j];\n            }\n        }\n        return X;\n    }\n    mat operator+(const T val){\n        mat<T> X(this->r,this->c);\n        rep(i,this->r){\n            rep(j,this->c){\n                X[i][j] = (*this)[i][j] + val;\n            }\n        }\n        return X;\n    }\n    mat operator-(const mat& another){\n        if(this->r != another.r && this->c != another.c){\n            cout << \"引き算失敗(サイズ不一致)\" << endl;\n            exit(1);\n        }\n        mat<T> X(this->r,this->c);\n        rep(i,this->r){\n            rep(j,this->c){\n                X[i][j] = (*this)[i][j] - another[i][j];\n            }\n        }\n        return X;\n    }\n    mat operator-(const T val){\n        mat<T> X(this->r,this->c);\n        rep(i,this->r){\n            rep(j,this->c){\n                X[i][j] = (*this)[i][j] - val;\n            }\n        }\n        return X;\n    }\n    vector<T> operator*(const vector<T>& another){\n        if(this->c != (int)another.size()){\n            cout << \"掛け算失敗(サイズ不一致)\" << endl;\n            exit(1);\n        }\n        vector<T> vec(this->r,0);\n        rep(i,this->r){\n            rep(j,this->c){\n                vec[i] += (*this)[i][j] * another[j];\n            }\n        }\n        return vec;\n    }\n    mat operator*(const mat& another){\n        if(this->c != another.r){\n            cout << \"掛け算失敗(サイズ不一致)\" << endl;\n            exit(1);\n        }\n        mat<T> X = *this;\n        rep(i,this->r){\n            for(int k=0;k<this->c;k+=4){\n                for(int j=0;j<another.c;j+=2){\n\t\t\t\t\tif((*this)[i][k]){\n\t\t\t\t\t\tif(another[k][j]){\n\t\t\t\t\t\t\tcmx(X[i][j],(*this)[i][k]+another[k][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(another[k][j+1]){\n\t\t\t\t\t\t\tcmx(X[i][j],(*this)[i][k]+another[k][j+1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif((*this)[i][k+1]){\n\t\t\t\t\t\tif(another[k+1][j]){\n\t\t\t\t\t\t\tcmx(X[i][j],(*this)[i][k+1]+another[k+1][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(another[k+1][j+1]){\n\t\t\t\t\t\t\tcmx(X[i][j],(*this)[i][k+1]+another[k+1][j+1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif((*this)[i][k+2]){\n\t\t\t\t\t\tif(another[k+2][j]){\n\t\t\t\t\t\t\tcmx(X[i][j],(*this)[i][k+2]+another[k+2][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(another[k+2][j+1]){\n\t\t\t\t\t\t\tcmx(X[i][j],(*this)[i][k+2]+another[k+2][j+1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif((*this)[i][k+3]){\n\t\t\t\t\t\tif(another[k+3][j]){\n\t\t\t\t\t\t\tcmx(X[i][j],(*this)[i][k+3]+another[k+3][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(another[k+3][j+1]){\n\t\t\t\t\t\t\tcmx(X[i][j],(*this)[i][k+3]+another[k+3][j+1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n            }\n        }\n        return X;\n    }\n    mat operator-(){\n        mat<T> X(this->r,this->c);\n        rep(i,this->r){\n            rep(j,this->c){\n                X[i][j] = -(*this)[i][j];\n            }\n        }\n        return X;\n    }\n    void print(){\n        rep(i,this->r){\n            rep(j,(this->c)-1){\n                cout << (*this)[i][j] << \",\";\n            }\n            cout << (*this)[i][(this->c)-1] << endl;\n        }\n    }\n};\n\ntemplate<typename T> mat<T> pow(mat<T> A,ll cnt)\n{\n    if(A.row() != A.column()){\n        cout << \"累乗不可\" << endl;\n    }\n\tmat<T> B = A;\n\t--cnt;\n\twhile(cnt>0){\n\t\tif(cnt & 1){\n\t\t\tB = B*A;\n\t\t}\n\t\tA = A*A;\n\t\tcnt >>= 1;\n\t}\n\treturn B;\n}\n\nstruct edge{\n\tint to,cost;\n};\n\nvector<edge> G[MAX_N];\n\nbool possible(mat<int>& A,const int cri,const int K)\n{\n\tint n = A.row();\n\tmat<int> res = pow(A,cri);\n\tint mx = 0;\n\trep(i,n){\n\t\trep(j,n){\n\t\t\tcmx(mx,res[i][j]);\n\t\t}\n\t}\n\treturn (mx >= K);\n}\n\nint mx[101][151];\nint pre[101][151];\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n,m,K;\n\tcin >> n >> m >> K;\n\tn = (n+3)/4*4;\n\tmat<int> A(n,n);\n\trep(i,m){\n\t\tint a,b,c;\n\t\tcin >> a >> b >> c;\n\t\tcmx(A[a][b],c);\n\t}\n\trep(i,n){\n\t\trep(j,n){\n\t\t\tif(A[i][j]){\n\t\t\t\tG[i].pb((edge){j,A[i][j]});\n\t\t\t}\n\t\t}\n\t}\n\tmat<int> res = pow(A,100);\n\tif(!possible(A,K,K)){\n\t\tcout << \"-1\\n\";\n\t\treturn 0;\n\t}\n\tint l = 0,r = K;\n\twhile(r-l>1){\n\t\tint mid = (l+r)/2;\n\t\tif(possible(A,mid,K)){\n\t\t\tr = mid;\n\t\t}else{\n\t\t\tl = mid;\n\t\t}\n\t}\n\tcout << r << \"\\n\";\n\tif(r > 100){\n\t\treturn 0;\n\t}\n\trep(i,r){\n\t\trep(j,n){\n\t\t\teach(e,G[j]){\n\t\t\t\tif(mx[i+1][e.to] < mx[i][j] + e.cost){\n\t\t\t\t\tmx[i+1][e.to] = mx[i][j] + e.cost;\n\t\t\t\t\tpre[i+1][e.to] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint cri = *max_element(mx[r],mx[r]+n);\n\tvector<int> ans;\n\trep(i,n){\n\t\tif(mx[r][i] == cri){\n\t\t\tint nw = i;\n\t\t\trrep(j,r+1){\n\t\t\t\tans.pb(nw);\n\t\t\t\tnw = pre[j][nw];\n\t\t\t}\n\t\t\treverse(all(ans));\n\t\t\teach(it,ans){\n\t\t\t\tcout << it << \" \";\n\t\t\t}\n\t\t\tcout << \"\\n\";\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <queue>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#include <cstdio>\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\n#include <set>\nusing namespace std;\n\nint g[150][150];\npair<int, vector<int> > loop[150][160];\npair<int, vector<int> > p1[150][160];\npair<int, vector<int> > p2[150][160];\npair<int, vector<int> > tmp[160][150];\n\nint main(){\n  const int v = getInt();\n  const int e = getInt();\n  const int kk = getInt();\n\n  REP(i,v) REP(j,v) g[i][j] = -1;\n\n  REP(i,e){\n    const int v1 = getInt();\n    const int v2 = getInt();\n    const int c  = getInt();\n    g[v1][v2] = max(g[v1][v2], c);\n  }\n\n  REP(s,v){\n    REP(i,v + 10) REP(j,v) tmp[i][j] = make_pair(-1, vector<int>());\n\n    tmp[0][s] = make_pair(0, vector<int>());\n\n    REP(c, v + 5){\n      loop[s][c] = tmp[c][s];\n      p1[s][c] = tmp[c][0]; REP(i,v) p1[s][c] = max(p1[s][c], tmp[c][i]);\n\n      REP(i,v) if(tmp[c][i].first != -1){\n        vector<int> vv = tmp[c][i].second;\n        vv.push_back(0);\n        REP(j,v) if(g[i][j] != -1){\n          const int pp = tmp[c][i].first + g[i][j];\n          vv[c] = j;\n          tmp[c + 1][j] = max(tmp[c + 1][j], make_pair(pp, vv));\n        }\n      }\n    }\n  }\n\n  REP(i,v) REP(j,i) swap(g[i][j], g[j][i]);\n\n  REP(s,v){\n    REP(i,v + 10) REP(j,v) tmp[i][j] = make_pair(-1, vector<int>());\n\n    tmp[0][s] = make_pair(0, vector<int>());\n\n    REP(c, v + 5){\n      // loop[s][c] = tmp[c][s];\n      p2[s][c] = tmp[c][0]; REP(i,v) p2[s][c] = max(p2[s][c], tmp[c][i]);\n\n      REP(i,v) if(tmp[c][i].first != -1){\n        vector<int> vv = tmp[c][i].second;\n        vv.push_back(0);\n        REP(j,v) if(g[i][j] != -1){\n          const int pp = tmp[c][i].first + g[i][j];\n          vv[c] = j;\n          tmp[c + 1][j] = max(tmp[c + 1][j], make_pair(pp, vv));\n        }\n      }\n    }\n  }\n\n  REP(i,v) REP(j,i) swap(g[i][j], g[j][i]);\n\n  const int inf = 10000000;\n  pair<int, pair<int, pair<int, pair<int, pair<int, int> > > > > ans;\n  ans.first = inf;\n\n  REP(s,v){\n    REP(i,v + 2) REP(j,v + 2) REP(k, v + 2){\n      if(p1[s][i].first != -1 &&\n         p2[s][j].first != -1 &&\n         loop[s][k].first != -1){\n        const int pt = p1[s][i].first +\n          p2[s][j].first;\n\n        if(pt >= kk){\n          ans = min(ans, make_pair(i + j + k, make_pair(s, make_pair(i, make_pair(j, make_pair(k, 0))))));\n        }else{\n          if(loop[s][k].first > 0){\n            const int diff = kk - pt;\n            const int cnt = (diff + loop[s][k].first - 1) / loop[s][k].first;\n            ans = min(ans, make_pair(i + j + k * cnt, make_pair(s, make_pair(i, make_pair(j, make_pair(k, cnt))))));\n          }\n        }\n      }\n    }\n  }\n\n  if(ans.first == inf){\n    printf(\"-1\\n\");\n  }else{\n    printf(\"%d\\n\", ans.first);\n\n    if(ans.first <= 100){\n      const int s = ans.second.first;\n      const int i = ans.second.second.first;\n      const int j = ans.second.second.second.first;\n      const int k = ans.second.second.second.second.first;\n      const int c = ans.second.second.second.second.second;\n\n      vector<int> v;\n\n      {\n        REP(ii, j) v.push_back(p2[s][j].second[j - ii - 1]);\n      }\n      v.push_back(s);\n\n      REP(cc,c){\n        REP(ii, k) v.push_back(loop[s][k].second[ii]);\n      }\n\n      {\n        REP(ii, i) v.push_back(p1[s][i].second[ii]);\n      }\n\n      REP(i,v.size()) printf(\"%d%c\", v[i], i == (int)v.size() - 1 ? '\\n' : ' ');\n      /*\n      int a = 0;\n      REP(i, v.size() - 1)\n        a += g[v[i]][v[i + 1]];\n      printf(\"a: %d\\n\", a);\n      */\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\nint V,E,K;\nconst int INF = (1<<30);\nmat G;\n\nmat g[30];\nmat u[30];\n\nint add(int a,int b){\n  if(a==-INF||b==-INF)return -INF;\n  return min(a+b,K);\n}\n\npair<mat,mat> merge(mat A,mat B, bool flag=false){\n  mat X( V, vec(V, -INF) );\n  mat Y( V, vec(V, -INF) );\n  \n  for(int from=0;from<V;from++){\n    for(int to=0;to<V;to++){\n      for(int ex=0;ex<V;ex++){\n        int cost=add(A[from][ex],B[ex][to]);\n        if(X[from][to]<cost){\n          X[from][to]=cost;\n          Y[from][to]=ex;\n        }\n      }\n    }\n  }\n  return make_pair(X,Y);\n}\n\n\nint calc(int m,int &si,int &ti){\n  mat t;\n  for(int i=0;i<30;i++){\n    if(m>>i&1){\n      if(t.empty()){\n        t=g[i];\n      }else{\n        t=merge(t,g[i]).first;\n      }\n    }\n  }\n  \n  int res=-INF;\n  for(int i=0;i<V;i++){\n    for(int j=0;j<V;j++){\n      if(res<t[i][j]){\n        si=i;\n        ti=j;\n        res=t[i][j];\n      }\n    }\n  }\n  return res;\n}\n\nvoid Dfs(vec& s,int from,int to,int len){\n  if(len==0)return;\n  \n  for(int i=0;i<30;i++){\n    if(~len>>i&1)continue;\n    int ex=u[i][from][to];\n\n    if(i==0){\n      if(len>=2)s.push_back(ex);\n      Dfs(s,ex,to,len-1);\n    }else{\n      int sub=(1<<i)/2;\n      Dfs(s,from,ex,sub);\n      s.push_back(ex);\n      Dfs(s,ex,to,len-sub);\n    }\n    break;\n  }\n}\n\nint main(){\n  cin>>V>>E>>K;\n  G=mat( V, vec(V, -INF) );\n  \n  g[0]=u[0]=G;\n  for(int i=0;i<V;i++)g[0][i][i]=0;\n  \n  for(int i=0;i<E;i++){\n    int a,b,c;\n    cin>>a>>b>>c;\n    G[a][b]=max(G[a][b],c);\n    \n    g[0][a][b]=max(g[0][a][b],c);\n    u[0][a][b]=b;\n  }\n\n  \n  for(int i=1;i<30;i++){\n    pair<mat,mat> temp=merge(g[i-1],g[i-1]);\n    g[i]=temp.first;\n    u[i]=temp.second;\n  }\n\n\n  int si,ti;\n  int left=1,right=K+1,mid;\n\n  while( left < right ){\n    mid=(left+right)/2;\n    if( calc(mid,si,ti) >= K ){\n      right=mid;\n    }else{\n      left=mid+1;\n    }\n  }\n\n  for(int i=0;i<V;i++)g[0][i][i]=-INF;\n  for(int i=1;i<30;i++){\n    pair<mat,mat> temp=merge(g[i-1],g[i-1]);\n    g[i]=temp.first;\n    u[i]=temp.second;\n  }\n  \n  if(left==K+1){\n    cout<<-1<<endl;\n  }else{\n    cout<<left<<endl;\n    if(left<=100){\n      vec tab;\n      tab.push_back(si);\n      Dfs(tab,si,ti,left);\n      tab.push_back(ti);\n      //      cout<<tab.size()<<endl;\n\n      assert( left +1 == (int)tab.size() );\n      for(int i=0;i<(int)tab.size();i++){\n        if(i>0 && G[ tab[i-1]][ tab[i] ] == -INF ){\n          assert(0);\n        }\n        if(i)cout<<' ';\n        cout<<tab[i];\n      }\n      cout<<endl;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 151;\n\ntemplate<typename T> class mat : public vector<vector<T> > {\nprivate:\n    int r,c;    //行,列\npublic:\n    int row() const {\n        return r;\n    }\n    int column() const {\n        return c;\n    }\n    mat(int n,int m,T val = 0){\n        this->r = n,this->c = m;\n        rep(i,n){\n            this->push_back(vector<T>(m,val));\n        }\n    }\n    mat operator+(const mat& another){\n        if(this->r != another.r && this->c != another.c){\n            cout << \"足し算失敗(サイズ不一致)\" << endl;\n            exit(1);\n        }\n        mat<T> X(this->r,this->c);\n        rep(i,this->r){\n            rep(j,this->c){\n                X[i][j] = (*this)[i][j] + another[i][j];\n            }\n        }\n        return X;\n    }\n    mat operator+(const T val){\n        mat<T> X(this->r,this->c);\n        rep(i,this->r){\n            rep(j,this->c){\n                X[i][j] = (*this)[i][j] + val;\n            }\n        }\n        return X;\n    }\n    mat operator-(const mat& another){\n        if(this->r != another.r && this->c != another.c){\n            cout << \"引き算失敗(サイズ不一致)\" << endl;\n            exit(1);\n        }\n        mat<T> X(this->r,this->c);\n        rep(i,this->r){\n            rep(j,this->c){\n                X[i][j] = (*this)[i][j] - another[i][j];\n            }\n        }\n        return X;\n    }\n    mat operator-(const T val){\n        mat<T> X(this->r,this->c);\n        rep(i,this->r){\n            rep(j,this->c){\n                X[i][j] = (*this)[i][j] - val;\n            }\n        }\n        return X;\n    }\n    vector<T> operator*(const vector<T>& another){\n        if(this->c != (int)another.size()){\n            cout << \"掛け算失敗(サイズ不一致)\" << endl;\n            exit(1);\n        }\n        vector<T> vec(this->r,0);\n        rep(i,this->r){\n            rep(j,this->c){\n                vec[i] += (*this)[i][j] * another[j];\n            }\n        }\n        return vec;\n    }\n    mat operator*(const mat& another){\n        if(this->c != another.r){\n            cout << \"掛け算失敗(サイズ不一致)\" << endl;\n            exit(1);\n        }\n        mat<T> X = *this;\n        rep(i,this->r){\n            rep(k,this->c){\n                rep(j,another.c){\n\t\t\t\t\tif((*this)[i][k] && another[k][j]){\n\t\t\t\t\t\tcmx(X[i][j],(*this)[i][k]+another[k][j]);\n\t\t\t\t\t}\n                }\n            }\n        }\n        return X;\n    }\n    mat operator-(){\n        mat<T> X(this->r,this->c);\n        rep(i,this->r){\n            rep(j,this->c){\n                X[i][j] = -(*this)[i][j];\n            }\n        }\n        return X;\n    }\n    void print(){\n        rep(i,this->r){\n            rep(j,(this->c)-1){\n                cout << (*this)[i][j] << \",\";\n            }\n            cout << (*this)[i][(this->c)-1] << endl;\n        }\n    }\n};\n\ntemplate<typename T> mat<T> pow(mat<T> A,ll cnt)\n{\n    if(A.row() != A.column()){\n        cout << \"累乗不可\" << endl;\n    }\n\tmat<T> B = A;\n\t--cnt;\n\twhile(cnt>0){\n\t\tif(cnt & 1){\n\t\t\tB = B*A;\n\t\t}\n\t\tA = A*A;\n\t\tcnt >>= 1;\n\t}\n\treturn B;\n}\n\nstruct edge{\n\tint to,cost;\n};\n\nvector<edge> G[MAX_N];\n\nbool possible(mat<int>& A,const int cri,const int K)\n{\n\tint n = A.row();\n\tmat<int> res = pow(A,cri);\n\tint mx = 0;\n\trep(i,n){\n\t\trep(j,n){\n\t\t\tcmx(mx,res[i][j]);\n\t\t}\n\t}\n\treturn (mx >= K);\n}\n\nint mx[101][151];\nint pre[101][151];\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n,m,K;\n\tcin >> n >> m >> K;\n\tmat<int> A(n,n);\n\trep(i,m){\n\t\tint a,b,c;\n\t\tcin >> a >> b >> c;\n\t\tcmx(A[a][b],c);\n\t}\n\trep(i,n){\n\t\trep(j,n){\n\t\t\tif(A[i][j]){\n\t\t\t\tG[i].pb((edge){j,A[i][j]});\n\t\t\t}\n\t\t}\n\t}\n\tmat<int> res = pow(A,100);\n\tif(!possible(A,K,K)){\n\t\tcout << \"-1\\n\";\n\t\treturn 0;\n\t}\n\tint l = 0,r = K;\n\twhile(r-l>1){\n\t\tint mid = (l+r)/2;\n\t\tif(possible(A,mid,K)){\n\t\t\tr = mid;\n\t\t}else{\n\t\t\tl = mid;\n\t\t}\n\t}\n\tcout << r << \"\\n\";\n\tif(r > 100){\n\t\treturn 0;\n\t}\n\trep(i,r){\n\t\trep(j,n){\n\t\t\teach(e,G[j]){\n\t\t\t\tif(mx[i+1][e.to] < mx[i][j] + e.cost){\n\t\t\t\t\tmx[i+1][e.to] = mx[i][j] + e.cost;\n\t\t\t\t\tpre[i+1][e.to] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint cri = *max_element(mx[r],mx[r]+n);\n\tvector<int> ans;\n\trep(i,n){\n\t\tif(mx[r][i] == cri){\n\t\t\tint nw = i;\n\t\t\trrep(j,r+1){\n\t\t\t\tans.pb(nw);\n\t\t\t\tnw = pre[j][nw];\n\t\t\t}\n\t\t\treverse(all(ans));\n\t\t\teach(it,ans){\n\t\t\t\tcout << it << \" \";\n\t\t\t}\n\t\t\tcout << \"\\n\";\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 155\n#define SIZE 21\n\nint V,E,K;\nint POW[SIZE];\nint pow_max_value[SIZE][NUM][NUM];\nint sum_value[NUM][NUM],work[NUM][NUM];\nint dp[NUM][NUM],pre[NUM][NUM];\n\nvoid init_work(){\n\tfor(int i = 0; i < V; i++){\n\t\tfor(int k = 0; k < V; k++){\n\t\t\tif(i != k){\n\t\t\t\twork[i][k] = -BIG_NUM;\n\t\t\t}else{\n\t\t\t\twork[i][k] = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\n\tPOW[0] = 1;\n\tfor(int i = 1; i < SIZE; i++){\n\t\tPOW[i] = POW[i-1]*2;\n\t}\n\n\tscanf(\"%d %d %d\",&V,&E,&K);\n\n\tfor(int i = 0; i < SIZE; i++){\n\t\tfor(int a = 0; a < V; a++){\n\t\t\tfor(int b = 0; b < V; b++){\n\t\t\t\tif(a != b){\n\t\t\t\t\tpow_max_value[i][a][b] = -BIG_NUM;\n\t\t\t\t}else{\n\t\t\t\t\tpow_max_value[i][a][b] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint tmp_from,tmp_to,value;\n\n\tfor(int loop = 0; loop < E; loop++){\n\n\t\tscanf(\"%d %d %d\",&tmp_from,&tmp_to,&value);\n\n\t\tpow_max_value[0][tmp_from][tmp_to] = max(pow_max_value[0][tmp_from][tmp_to],value);\n\t}\n\n\n\t//DAG対策\n\tfor(int count = 0; count <= 150; count++){\n\t\tfor(int loc = 0; loc < V; loc++){\n\t\t\tif(count > 0){\n\t\t\t\tdp[count][loc] = -BIG_NUM;\n\t\t\t}else{\n\t\t\t\tdp[count][loc] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int count = 1; count <= 150; count++){\n\t\tfor(int from = 0; from < V; from++){\n\t\t\tif(dp[count-1][from] == -BIG_NUM)continue;\n\t\t\tfor(int to = 0; to < V; to++){\n\t\t\t\tif(pow_max_value[0][from][to] == -BIG_NUM)continue;\n\t\t\t\tif(dp[count][to] < dp[count-1][from]+pow_max_value[0][from][to]){\n\t\t\t\t\tdp[count][to] = dp[count-1][from]+pow_max_value[0][from][to];\n\t\t\t\t\tpre[count][to] = from;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int count = 1; count <= 150; count++){\n\t\tint tmp_max = 0;\n\t\tint tmp_node;\n\t\tfor(int loc = 0; loc < V; loc++){\n\t\t\tif(tmp_max < dp[count][loc]){\n\t\t\t\ttmp_max = dp[count][loc];\n\t\t\t\ttmp_node = loc;\n\t\t\t}\n\t\t}\n\t\tif(tmp_max >= K){\n\n\t\t\tprintf(\"%d\\n\",count);\n\t\t\tif(count > 100){\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tstack<int> S;\n\n\t\t\tS.push(tmp_node);\n\n\t\t\tfor(int i = count; i >= 1; i--){\n\t\t\t\tS.push(pre[i][tmp_node]);\n\t\t\t\ttmp_node = pre[i][tmp_node];\n\t\t\t}\n\n\t\t\tprintf(\"%d\",S.top());\n\t\t\tS.pop();\n\n\t\t\twhile(!S.empty()){\n\t\t\t\tprintf(\" %d\",S.top());\n\t\t\t\tS.pop();\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t//ダブリング\n\tfor(int i = 1; i < SIZE; i++){\n\t\tfor(int mid = 0; mid < V; mid++){\n\t\t\tfor(int start = 0; start < V; start++){\n\t\t\t\tif(pow_max_value[i-1][start][mid] == -BIG_NUM)continue;\n\t\t\t\tfor(int goal = 0; goal < V; goal++){\n\t\t\t\t\tif(pow_max_value[i-1][mid][goal] == -BIG_NUM)continue;\n\n\t\t\t\t\tpow_max_value[i][start][goal] = max(pow_max_value[i][start][goal],\n\t\t\t\t\t\t\tpow_max_value[i-1][start][mid]+pow_max_value[i-1][mid][goal]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint left = 1,right = K,mid = (left+right);\n\tint ans = -1;\n\tbool is_First;\n\tint maximum = 0;\n\n\twhile(left <= right){ //2分探索\n\n\t\tint tmp_count = mid;\n\t\tis_First = true;\n\n\t\tfor(int i = 20; i >= 0; i--){\n\t\t\tif(tmp_count < POW[i])continue;\n\t\t\ttmp_count -= POW[i];\n\n\t\t\tif(is_First){\n\n\t\t\t\t//初めてのPOW\n\t\t\t\tfor(int from = 0; from < V; from++){\n\t\t\t\t\tfor(int to = 0; to < V; to++){\n\t\t\t\t\t\tsum_value[from][to] = pow_max_value[i][from][to];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tis_First = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tinit_work(); //★★workを介さないと、足し過ぎが発生する★★\n\n\t\t\tfor(int mid = 0; mid < V; mid++){\n\t\t\t\tfor(int start = 0; start < V; start++){\n\t\t\t\t\tif(sum_value[start][mid] < 0)continue;\n\t\t\t\t\tfor(int goal = 0; goal < V; goal++){\n\t\t\t\t\t\tif(pow_max_value[i][mid][goal] < 0)continue;\n\n\t\t\t\t\t\twork[start][goal] = max(work[start][goal],sum_value[start][mid]+pow_max_value[i][mid][goal]);\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int from = 0; from < V; from++){\n\t\t\t\tfor(int to = 0; to < V; to++){\n\t\t\t\t\tsum_value[from][to] = work[from][to];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmaximum = 0;\n\t\tfor(int from = 0; from < V; from++){\n\t\t\tfor(int to = 0; to < V; to++){\n\t\t\t\tmaximum = max(maximum,sum_value[from][to]);\n\t\t\t}\n\t\t}\n\n\t\tif(maximum >= K){\n\t\t\tans = mid;\n\t\t\tright = mid-1;\n\t\t}else{\n\t\t\tleft = mid+1;\n\t\t}\n\t\tmid = (left+right)/2;\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\nint V,E,K;\nconst int INF = (1<<29);\nmat G;\n\nmat g[30];\nmat u[30];\n\nint add(int a,int b){\n  if(a==-INF||b==-INF)return -INF;\n  return min(a+b,INF);\n}\n\npair<mat,mat> merge(mat A,mat B, bool flag=false){\n  mat X( V, vec(V, -INF) );\n  mat Y( V, vec(V, -INF) );\n  \n  for(int from=0;from<V;from++){\n    for(int to=0;to<V;to++){\n      for(int ex=0;ex<V;ex++){\n        int cost=add(A[from][ex],B[ex][to]);\n        if(X[from][to]<cost){\n          X[from][to]=cost;\n          Y[from][to]=ex;\n        }\n      }\n    }\n  }\n  return make_pair(X,Y);\n}\n\n\nint calc(int m,int &si,int &ti){\n  mat t;\n  for(int i=0;i<30;i++){\n    if(m>>i&1){\n      if(t.empty()){\n        t=g[i];\n      }else{\n        t=merge(t,g[i]).first;\n      }\n    }\n  }\n  \n  int res=-INF;\n  for(int i=0;i<V;i++){\n    for(int j=0;j<V;j++){\n      if(res<t[i][j]){\n        si=i;\n        ti=j;\n        res=t[i][j];\n      }\n    }\n  }\n  return res;\n}\n\nvoid Dfs(vec& s,int from,int to,int len){\n  if(len<=1)return;\n  if(len==(len&-len)){\n\n    for(int i=0;i<30;i++){\n      if(len>>i&1){\n        int ex=u[i][from][to];\n        Dfs(s,from,ex,len/2);\n        s.push_back(ex);\n        Dfs(s,ex,to,len/2);\n        return;\n      }\n    }\n  }\n  \n  mat t=mat( V, vec(V,-INF) );\n  for(int i=0;i<V;i++)t[i][i]=0;\n  \n  int ex=-1;\n  int sub=-1;\n  \n  for(int i=0;i<30;i++){\n    if(~len>>i&1)continue;\n    pair<mat,mat> tmp=merge(t, g[i]);\n    ex=tmp.second[from][to];\n    sub=(1<<i);\n  }\n\n  Dfs(s,from,ex,sub);\n  s.push_back(ex);\n  Dfs(s,ex,to,len-sub);\n}\n\nint main(){\n  cin>>V>>E>>K;\n  G=mat( V, vec(V, -INF) );\n  g[0]=u[0]=G;\n  for(int i=0;i<V;i++)g[0][i][i]=0;\n  for(int i=0;i<E;i++){\n    int a,b,c;\n    cin>>a>>b>>c;\n    G[a][b]=max(G[a][b],c);\n    if(g[0][a][b]<c){\n      g[0][a][b]=c;\n      u[0][a][b]=b;\n    }\n  }\n  \n  for(int i=1;i<30;i++){\n    pair<mat,mat> temp=merge(g[i-1],g[i-1]);\n    g[i]=temp.first;\n    u[i]=temp.second;\n  }\n  int left=1,right=K+1,mid,si,ti;\n  while( left < right ){\n    mid=(left+right)/2;\n    if( calc(mid,si,ti) >= K ){\n      right=mid;\n    }else{\n      left=mid+1;\n    }\n  }\n\n  for(int i=0;i<V;i++)g[0][i][i]=-INF;\n  for(int i=1;i<30;i++){\n    pair<mat,mat> temp=merge(g[i-1],g[i-1]);\n    g[i]=temp.first;\n    u[i]=temp.second;\n  }\n  \n  if(left==K+1){\n    cout<<-1<<endl;\n  }else{\n    cout<<left<<endl;\n    if(left<=100){\n      vec tab;\n      tab.push_back(si);\n      Dfs(tab,si,ti,left);\n      tab.push_back(ti);\n\n      int sum=0;\n      for(int i=0;i<(int)tab.size();i++){\n\n        \n        if(i>0){\n          int cost=G[ tab[i-1] ][ tab[i] ];\n          if(cost == -INF ){\n            assert(0);\n          }else{\n            sum=add(sum,cost);\n          }\n        }\n        \n        if(i)cout<<' ';\n        cout<<tab[i];\n      }\n      cout<<endl;\n    }\n  }\n  return 0;\n}\n\n  \n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i< (int)(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define iter(c) __typeof((c).begin())\n#define pb(e) push_back(e)\n#define foreach(c, i) for(iter(c) i = (c).begin(); i != c.end(); ++i)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> vec;\ntypedef vector<vec> mat;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\n\nconst int sz = 25;\nmat memo[sz];\nll g[200][200];\nint dp[200][200];\nint pre[200][200];\n\nmat mul(const mat &A, const mat &B){\n  int n = A.size();\n  mat C = A;\n  rep(i, n)rep(j, n)rep(k, n){\n    if(A[i][k] > 0 && B[k][j] > 0) C[i][j] = max(A[i][k] + B[k][j], C[i][j]);\n  }\n  return C;\n}\n\nvoid init(int V, int E){\n  mat A = mat(V, vec(V, 0));\n  int f, t;\n  ll c;\n  rep(i, E){\n    cin >> f >> t >> c;\n    A[f][t] = max(A[f][t], c);\n    g[f][t] = max(g[f][t], c);\n  }\n  memo[0] = A;\n  rep(i, sz - 1) memo[i+1] = mul(memo[i], memo[i]);\n}\n\nvoid calc(int V, int R, int K){\n  rep(i, R)rep(j, V)rep(k, V){\n    if(g[j][k] > 0 && (i == 0 || dp[i][j] > 0) && dp[i+1][k] < dp[i][j] + g[j][k]){\n      dp[i+1][k] = dp[i][j] + g[j][k];\n      pre[i+1][k] = j;\n    }\n  }\n\n  int v = 0;\n  int best = -1;\n  rep(i, V) if(dp[R][i] > best){\n    v = i;\n    best = dp[R][i];\n  }\n  \n  vector<int> res;\n  res.push_back(v);\n  for(int i = R; i > 0; i--){\n    v = pre[i][v];\n    res.push_back(v);\n  }\n  //cout << res.size() << endl;\n  reverse(res.begin(), res.end());\n  rep(i, res.size()) cout << res[i] << (i == (int)res.size() - 1 ? '\\n' : ' ');\n}\n\nint main(){\n  int V, E, K, i, res = 0;\n  cin >> V >> E >> K;\n  init(V, E);\n  \n  mat A;\n  bool f = false;\n  \n  for(i = sz - 1; i >= 0; i--){\n    bool ok = false;\n    mat B = f ? mul(A, memo[i]) : memo[i];\n    rep(j, V)rep(k, V) if(B[j][k] >= K) ok = true;\n    if(!ok){\n      res += 1 << i;\n      A = B;\n      f = true;\n    }\n  }\n  \n  res++;\n  //resは経由する矢印の数\n  if(res == (1 << sz)){\n    cout << -1 << endl;\n  }else {\n    cout << res << endl;\n    if(res  <= 100) calc(V, res, K);\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<queue>\n#include<iomanip>\n#include<math.h>\n#include<bitset>\n#include<cassert>\n#include<random>\n#include<time.h>\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing P=pair<int,int>;\n#define MOD 1000000007LL\n#define INF 1000000000LL\n#define EPS 1e-10\n#define FOR(i,n,m) for(ll i=n;i<(ll)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v)  sort(ALL(v));v.erase(unique(ALL(v)),v.end());\n#define pb push_back\n\n/* --------------------------------------- */\n\nll v, e, k;\nll dp[30][150][150];\n\nvoid solve(ll r) {\n\tvector<ll> tmp(v, 0);\n\tvector<vector<ll>> back(r,vector<ll>(v, -1));\n\tREP(i,r) {\n\t\tvector<ll> ntmp(v,-1);\n\t\tREP(j,v) REP(k,v) {\n\t\t\tif(tmp[j] == -1 || dp[0][j][k] == -1) continue;\n\t\t\tif(ntmp[k] < tmp[j] + dp[0][j][k]) {\n\t\t\t\tntmp[k] = tmp[j] + dp[0][j][k];\n\t\t\t\tback[i][k] = j;\n\t\t\t}\n\t\t}\n\t\ttmp = ntmp;\n\t}\n\tvector<ll> ans;\n\tll maxi = 0;\n\tREP(i,v) maxi = max(maxi,tmp[i]);\n\tREP(i,v) {\n\t\tif(tmp[i] == maxi) {\n\t\t\tll pos = i;\n\t\t\tREP(j,r) {\n\t\t\t\tans.pb(pos);\n\t\t\t\tpos = back[r - 1 - j][pos];\n\t\t\t}\n\t\t\tans.pb(pos);\n\t\t\treverse(ALL(ans));\n\t\t\tbreak;\n\t\t}\n\t}\n\tDUMP(ans);\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcin >> v >> e >> k;\n\tREP(i,30) REP(j,v) REP(k,v) dp[i][j][k] = -1;\n\tREP(i,e) {\n\t\tll a, b, c;\n\t\tcin >> a >> b >> c;\n\t\tdp[0][a][b] = max(dp[0][a][b], c);\n\t}\n\tif(k == 0) {\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\tFOR(i,1,30) REP(j,v) REP(k,v) {\n\t\tdp[i][j][k] = dp[i - 1][j][k];\n\t\tREP(l,v) {\n\t\t\tif(dp[i - 1][j][l] == -1 || dp[i - 1][l][k] == -1) continue;\n\t\t\tdp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][l] + dp[i - 1][l][k]);\n\t\t}\n\t}\n\tll l = 0, r = INF;\n\twhile(r - l > 1) {\n\t\tll m = (l + r) / 2;\n\t\tbitset<30> bit(m);\n\t\tvector<ll> dp2(v, 0);\n\t\tREP(i,30) {\n\t\t\tif(!bit[i]) continue;\n\t\t\tvector<ll> tmp(v, 0);\n\t\t\tREP(j,v) REP(k,v) {\n\t\t\t\tif(dp[i][j][k] == -1) continue;\n\t\t\t\ttmp[k] = max(tmp[k], dp2[j] + dp[i][j][k]);\n\t\t\t}\n\t\t\tdp2 = tmp;\n\t\t}\n\t\tll maxi = 0;\n\t\tREP(i,v) maxi = max(maxi, dp2[i]);\n\t\tif(maxi >= k) r = m;\n\t\telse l = m;\n\t}\n\tif(r == INF) {\n\t\tcout << -1 << endl;\n\t}\n\tcout << r << endl;\n\tif(r <= 100) solve(r);\n\treturn 0;\n}\n\n/* --------------------------------------- */\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<int(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nconstexpr int INF = 1000000000;\n\nusing Array = vector<int>;\nusing Matrix = vector<Array>;\n\nMatrix mul(const Matrix& lhs, const Matrix& rhs) {\n  int r = lhs.size();\n  Matrix res(r, Array(r, -INF));\n  REP(i,r) REP(k,r) REP(j,r) {\n    res[i][j] = max(res[i][j], lhs[i][k] + rhs[k][j]);\n  }\n  return res;\n}\n\nMatrix pow(const Matrix& mat, int index) {\n  if (index == 0) {\n    int v = mat.size();\n    Matrix res(v, Array(v, -INF));\n    REP(i,v) res[i][i] = 0;\n    return res;\n  }\n  if (index == 1) return mat;\n  if ((index % 2) == 1) {\n    return mul(mat, pow(mat, index-1));\n  }\n  return pow(mul(mat, mat), index/2);\n}\n\nint main() {\n  int v,e,k;\n  cin>>v>>e>>k;\n  Matrix mat(v, Array(v, -INF));\n  REP(i,e) {\n    int s,t,c;\n    cin>>s>>t>>c;\n    mat[s][t] = max(mat[s][t], c);\n  }\n  int idx = 0;\n  auto pmat = pow(mat, v*100);\n  vector<int> score(v, 0);\n  for (; idx < k; idx += v*100) {\n    vector<int> tmp(v, -INF);\n    REP(i,v)REP(j,v) tmp[j] = max(tmp[j], score[i] + pmat[i][j]);\n    int mx = -INF;\n    REP(i,v) mx = max(mx, tmp[i]);\n    swap(score, tmp);\n    if (mx >= k - v*200) {\n      break;\n    }\n  }\n  pmat = pow(mat, idx);\n  REP(i,v) score[i] = -INF;\n  REP(i,v)REP(j,v) score[j] = max(score[j], pmat[i][j]);\n  bool ok = false;\n  REP(cnt,200 * v+1) {\n    vector<int> tmp(v, -INF);\n    REP(i,v)REP(j,v) tmp[j] = max(tmp[j], score[i] + mat[i][j]);\n    int mx = -INF;\n    REP(i,v) mx = max(mx, tmp[i]);\n    swap(score, tmp);\n    if (mx >= k) {\n      idx += cnt + 1;\n      ok = true;\n      break;\n    }\n  }\n  if (ok && idx <= k) {\n    cout << idx << endl;\n  } else {\n    cout << -1 << endl;\n    return 0;\n  }\n  if (idx > 100) {\n    return 0;\n  }\n  vector<vector<int>> vscore;\n  REP(i,v) score[i] = 0;\n  REP(cnt,idx) {\n    vector<int> tmp(v, -INF);\n    REP(i,v)REP(j,v) tmp[j] = max(tmp[j], score[i] + mat[i][j]);\n    int mx = -INF;\n    REP(i,v) mx = max(mx, tmp[i]);\n    vscore.push_back(score);\n    swap(score, tmp);\n  }\n  int t = 0;\n  int mx = -INF;\n  REP(i,v) {\n    if (score[i] > mx) {\n      mx = score[i];\n      t = i;\n    }\n  }\n  vector<int> res;\n  res.push_back(t);\n  for (int i = idx-1; i >= 0; --i) {\n    int nt = 0;\n    int nmx = -INF;\n    REP(j,v) {\n      if (vscore[i][j] + mat[j][t] == mx) {\n        nt = j;\n        nmx = vscore[i][j];\n      }\n    }\n    t = nt;\n    mx = nmx;\n    res.push_back(t);\n  }\n  reverse(ALL(res));\n  REP(i,res.size()) {\n    if (i) cout << ' ';\n    cout << res[i];\n  }\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstruct edge{\n\tint t;\n\tint c;\n\tedge(){}\n\tedge(int tt,int cc){\n\t\tt=tt;\n\t\tc=cc;\n\t}\n};\n\nint n,m,tgt;\nvector<edge> G[151];\nint dp[151][151];\nint prev[151][151];\nint cyc_max[151][151];\nint to_max[151][151];\nint from_max[151][151];\n\nbool C(int v){\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<=min(n,v);j++){\n\t\t\tfor(int k=0;k<=min(n,v-j);k++){\n\t\t\t\tll all=to_max[i][j]+from_max[i][k];\n\t\t\t\tif(all>=(ll)tgt)return true;\n\t\t\t\tll rest=v-j-k;\n\t\t\t\tfor(int l=1;l<=n;l++){\n\t\t\t\t\tll va=(ll)rest/l;\n\t\t\t\t\tif(all+va*cyc_max[i][l]>=(ll)tgt)return true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nvoid get_route(int size){\n\tmemset(dp,-1,sizeof(dp));\n\tmemset(dp[0],0,sizeof(dp[0]));\n\tfor(int i=0;i<size;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(dp[i][j]>=0){\n\t\t\t\tfor(int l=0;l<G[j].size();l++){\n\t\t\t\t\tedge e=G[j][l];\n\t\t\t\t\tif(dp[i+1][e.t]<dp[i][j]+e.c){\n\t\t\t\t\t\tdp[i+1][e.t]=dp[i][j]+e.c;\n\t\t\t\t\t\tprev[i+1][e.t]=j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tif(dp[size][i]>=tgt){\n\t\t\tint now=i;\n\t\t\tvector<int> ans;\n\t\t\tfor(int j=0;j<size;j++){\n\t\t\t\tans.push_back(now);\n\t\t\t\tnow=prev[size-j][now];\n\t\t\t}\n\t\t\tans.push_back(now);\n\t\t\treverse(ans.begin(),ans.end());\n\t\t\tfor(int j=0;j<=size;j++){\n\t\t\t\tprintf(\"%d%c\",ans[j],j==size?'\\n':' ');\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nint main(void){\n\tscanf(\"%d%d%d\",&n,&m,&tgt);\n\tfor(int i=0;i<m;i++){\n\t\tint f,t,c;\n\t\tscanf(\"%d%d%d\",&f,&t,&c);\n\t\tG[f].push_back(edge(t,c));\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tdp[0][i]=0;\n\t\tfor(int j=0;j<n;j++){\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\tif(dp[j][k]>=0){\n\t\t\t\t\tfor(int l=0;l<G[k].size();l++){\n\t\t\t\t\t\tedge e=G[k][l];\n\t\t\t\t\t\tdp[j+1][e.t]=max(dp[j+1][e.t],dp[j][k]+e.c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcyc_max[i][j+1]=dp[j+1][i];\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\tfrom_max[i][j+1]=max(from_max[i][j+1],dp[j+1][k]);\n\t\t\t\tto_max[k][j+1]=max(to_max[k][j+1],dp[j+1][k]);\n\t\t\t}\n\t\t}\n\t}\n\tint l=-1,r=1000000007;\n\twhile(l+1<r){\n\t\tint mid=(l+r)/2;\n\t\tif(C(mid))r=mid;\n\t\telse l=mid;\n\t}\n\tif(r==1000000007){\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tprintf(\"%d\\n\",r);\n\tif(r<=100){\n\t\tget_route(r);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<int(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nconstexpr int INF = 1000000000;\n\nusing Array = vector<int>;\nusing Matrix = vector<Array>;\n\nMatrix mul(const Matrix& lhs, const Matrix& rhs) {\n  int r = lhs.size();\n  Matrix res(r, Array(r, -INF));\n  REP(i,r) REP(k,r) REP(j,r) {\n    res[i][j] = max(res[i][j], lhs[i][k] + rhs[k][j]);\n  }\n  return res;\n}\n\nMatrix pow(const Matrix& mat, int index) {\n  if (index == 0) {\n    int v = mat.size();\n    Matrix res(v, Array(v, -INF));\n    REP(i,v) res[i][i] = 0;\n    return res;\n  }\n  if (index == 1) return mat;\n  if ((index % 2) == 1) {\n    return mul(mat, pow(mat, index-1));\n  }\n  return pow(mul(mat, mat), index/2);\n}\n\nint main() {\n  int v,e,k;\n  cin>>v>>e>>k;\n  Matrix mat(v, Array(v, -INF));\n  REP(i,e) {\n    int s,t,c;\n    cin>>s>>t>>c;\n    mat[s][t] = max(mat[s][t], c);\n  }\n  int hi = k;\n  int lo = 0;\n  while (hi - lo > 100 * v) {\n    int mid = (hi + lo) / 2;\n    auto pmat = pow(mat, mid);\n    int mx = -INF;\n    REP(i,v)REP(j,v) mx = max(mx, pmat[i][j]);\n    if (mx > k - 100 * v) {\n      hi = mid;\n    } else {\n      lo = mid;\n    }\n  }\n  auto pmat = pow(mat, lo);\n  vector<int> score(v, -INF);\n  REP(i,v)REP(j,v) score[j] = max(score[j], pmat[i][j]);\n  REP(cnt,k) {\n    vector<int> tmp(v, -INF);\n    REP(i,v)REP(j,v) tmp[j] = max(tmp[j], score[i] + mat[i][j]);\n    int mx = -INF;\n    REP(i,v) mx = max(mx, tmp[i]);\n    swap(score, tmp);\n    if (mx >= k) {\n      lo += cnt + 1;\n      break;\n    }\n  }\n  if (lo > 0 && lo <= k) {\n    cout << lo << endl;\n  } else {\n    cout << -1 << endl;\n    return 0;\n  }\n  if (hi > 100) {\n    return 0;\n  }\n  vector<vector<int>> vscore;\n  REP(i,v) score[i] = 0;\n  REP(cnt,lo) {\n    vector<int> tmp(v, -INF);\n    REP(i,v)REP(j,v) tmp[j] = max(tmp[j], score[i] + mat[i][j]);\n    int mx = -INF;\n    REP(i,v) mx = max(mx, tmp[i]);\n    vscore.push_back(score);\n    swap(score, tmp);\n  }\n  int t = 0;\n  int mx = -INF;\n  REP(i,v) {\n    if (score[i] > mx) {\n      mx = score[i];\n      t = i;\n    }\n  }\n  vector<int> res;\n  res.push_back(t);\n  for (int i = lo-1; i >= 0; --i) {\n    int nt = 0;\n    int nmx = -INF;\n    REP(j,v) {\n      if (vscore[i][j] + mat[j][t] == mx) {\n        nt = j;\n        nmx = vscore[i][j];\n      }\n    }\n    t = nt;\n    mx = nmx;\n    res.push_back(t);\n  }\n  reverse(ALL(res));\n  REP(i,res.size()) {\n    if (i) cout << ' ';\n    cout << res[i];\n  }\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n#define for_rev(i,a,b) for(int i=(a);i>=(b);--i)\n\nstruct Edge { int to, c; };\n\nvoid maxUpdate(int& a, int b) { a = max(a, b); }\n\nint V, K, E, score[21][155][155], score_buf[2][155][155], dp[110][155], prv[110][155];\nvector< vector< Edge > > adj;\n\nvoid restore(int step) {\n\tmemset(dp, 0, sizeof(dp));\n\tmemset(prv, -1, sizeof(prv));\n\t\n\tfor_(h,0,step) for_(v,0,V) {\n\t\tfor (Edge e : adj[v]) {\n\t\t\tif (dp[h + 1][e.to] < dp[h][v] + e.c) {\n\t\t\t\tdp[h + 1][e.to] = dp[h][v] + e.c;\n\t\t\t\tprv[h + 1][e.to] = v;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint max_score = 0, t = -1;\n\t\n\tfor_(v,0,V) {\n\t\tif (max_score < dp[step][v]) {\n\t\t\tmax_score = dp[step][v];\n\t\t\tt = v;\n\t\t}\n\t}\n\t\n\tvector< int > path;\n\tint c = step;\n\t\n\twhile (t != -1) {\n\t\tpath.push_back(t);\n\t\tt = prv[c][t];\n\t\t--c;\n\t}\n\t\n\treverse(path.begin(), path.end());\n\t\n\tfor_(i,0,step+1) cout << path[i] << (i < step ? \" \" : \"\\n\");\n}\n\nvoid warshall() {\n\tfor_(h,1,21) for_(u,0,V) for_(v,0,V) for_(k,0,V) {\n\t\tmaxUpdate(score[h][u][v], score[h - 1][u][k] + score[h - 1][k][v]);\n\t}\n}\n\nint calcScore(int step) {\n\tmemset(score_buf[0], 0, sizeof(score_buf[0]));\n\t\n\tfor_rev(h,20,0) {\n\t\tif (step >> h & 1) {\n\t\t\tmemset(score_buf[1], 0, sizeof(score_buf[1]));\n\t\t\t\n\t\t\tfor_(u,0,V) for_(v,0,V) for_(k,0,V) {\n\t\t\t\tmaxUpdate(score_buf[1][u][v], score_buf[0][u][k] + score[h][k][v]);\n\t\t\t\tif (score_buf[1][u][v] >= K) return score_buf[1][u][v];\n\t\t\t}\n\t\t\t\n\t\t\tfor_(u,0,V) for_(v,0,V) score_buf[0][u][v] = score_buf[1][u][v];\n\t\t}\n\t}\n\t\n\treturn -1;\n}\n\nint calcMinStep() {\n\tint lb = 1, ub = (int)1e6 + 10;\n\t\n\twhile (ub - lb > 1) {\n\t\tint med = (lb + ub) / 2;\n\t\tif (calcScore(med) >= K) ub = med;\n\t\telse lb = med;\n\t}\n\t\n\treturn ub;\n}\n\nvoid solve() {\n\twarshall();\n\t\n\tint min_step = calcMinStep();\n\t\n\tcout << (min_step > (int)1e6 ? -1 : min_step) << endl;\n\t\n\tif (min_step <= 100) restore(min_step);\n}\n\nint main() {\n\tcin >> V >> E >> K;\n\t\n\tadj.assign(V, vector< Edge >());\n\tfor_(h,0,21) for_(u,0,V) for_(v,0,V) score[h][u][v] = -(int)1e9;\n\t\n\tfor_(i,0,E) {\n\t\tint u, v, c;\n\t\tcin >> u >> v >> c;\n\t\tmaxUpdate(score[0][u][v], c);\n\t\tadj[u].push_back(Edge{v, c});\n\t}\n\t\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#ifndef LOCAL\n#define debug(x) ;\n#else\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\ntemplate <typename T1, typename T2>\nostream &operator<<(ostream &out, const pair<T1, T2> &p) {\n  out << \"{\" << p.first << \", \" << p.second << \"}\";\n  return out;\n}\n\ntemplate <typename T>\nostream &operator<<(ostream &out, const vector<T> &v) {\n  out << '{';\n  for (const T &item : v) out << item << \", \";\n  out << \"\\b\\b}\";\n  return out;\n}\n#endif\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 150\n\nll dist[21][SIZE][SIZE];\nll tmp[2][SIZE][SIZE];\nll dp[101][SIZE];\nll back[101][SIZE];\n\nint main(){\n  int V, E, K;\n\n  cin >> V >> E >> K;\n\n  for (int i=0; i<V; i++)\n    for (int j=0; j<V; j++)\n      for (int k=0; k<=20; k++)\n        dist[k][i][j] = i == j ? 0 : -LLINF;\n\n  for (int i=0; i<E; i++) {\n    int u, v, c;\n    cin >> u >> v >> c;\n    dist[0][u][v] = max(dist[0][u][v], (ll)c);\n  }\n\n  for (int b=0; b<20; b++) {\n    for (int i=0; i<V; i++) {\n      for (int j=0; j<V; j++) {\n        for (int k=0; k<V; k++) {\n          dist[b+1][i][k] = max(dist[b+1][i][k], dist[b][i][j] + dist[b][j][k]);\n        }\n      }\n    }\n  }\n\n  int l = 1, r = K + 1;\n\n  while (l < r) {\n    int mid = (l + r) / 2;\n\n    int s = 0, t = 1;\n\n    for (int i=0; i<V; i++) {\n      for (int j=0; j<V; j++) {\n        tmp[s][i][j] = i == j ? 0 : -LLINF;\n      }\n    }\n\n    int w = mid;\n    for (int b=0; w; b++) {\n      if (w & 1) {\n        for (int i=0; i<V; i++)\n          for (int j=0; j<V; j++)\n            tmp[t][i][j] = -LLINF;\n\n        for (int i=0; i<V; i++)\n          for (int j=0; j<V; j++)\n            for (int k=0; k<V; k++){\n              tmp[t][i][k] = max(tmp[t][i][k], dist[b][i][j] + tmp[s][j][k]);\n              //tmp[t][i][k] = max(tmp[t][i][k], tmp[s][i][j] + dist[b][j][k]);\n            }\n\n        swap(s, t);\n      }\n\n      w /= 2;\n    }\n\n    ll maxDist = -LLINF;\n\n    for (int i=0; i<V; i++)\n      for (int j=0; j<V; j++)\n        maxDist = max(maxDist, tmp[s][i][j]);\n\n    debug(mid);\n    debug(maxDist);\n\n    if (maxDist >= K) {\n      r = mid;\n    } else {\n      l = mid + 1;\n    }\n  }\n\n  int ans = l == K+1 ? -1 : l;\n\n  cout << ans << endl;\n\n  if (ans < 0 || 100 < ans) {\n    return 0;\n  }\n\n  for (int i=0; i<V; i++) {\n    dp[0][i] = 0;\n    for (int j=1; j<=ans; j++) {\n      dp[j][i] = -LLINF;\n    }\n  }\n\n  for (int i=0; i<ans; i++) {\n    for (int j=0; j<V; j++) {\n      for (int k=0; k<V; k++) {\n        if (dp[i+1][k] < dp[i][j] + dist[0][j][k])\n          back[i+1][k] = j;\n        dp[i+1][k] = max(dp[i+1][k], dp[i][j] + dist[0][j][k]);\n      }\n    }\n  }\n\n  vector<int> vec;\n\n  ll maxDP = -LLINF;\n  int now;\n  for (int i=0; i<V; i++) {\n    if (maxDP < dp[ans][i]) {\n      now = i;\n      maxDP = dp[ans][i];\n    }\n  }\n\n  for (int i=ans; i>=0; i--) {\n    vec.push_back(now);\n    now = back[i][now];\n  }\n\n  for (int i=vec.size()-1; i>=0; i--) {\n    printf(\"%d%c\", vec[i], \" \\n\"[i==0]);\n  }\n\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Edge{\n    int from,to;\n    int cost;\n};\nusing Graph=vector<vector<Edge>>;\n\nconst int LOG=22;\nvoid cmax(int &lhs,int rhs){\n    lhs=max(lhs,rhs);\n}\nint main(){\n    int V,E,K;\n    cin>>V>>E>>K;\n    Graph g(V);\n    for(int i=0;i<E;i++){\n        int x,y,c;\n        cin>>x>>y>>c;\n        g[x].push_back({x,y,c});\n    }\n    vector<vector<vector<int>>> w(LOG,vector<vector<int>>(V,vector<int>(V,-1e9)));\n    for(int i=0;i<V;i++){\n        w[0][i][i]=0;\n        for(auto &e:g[i]){\n            cmax(w[0][e.from][e.to],e.cost);\n        }\n    }\n    for(int k=0;k+1<LOG;k++){\n        for(int i=0;i<V;i++){\n            for(int j=0;j<V;j++){\n                for(int mid=0;mid<V;mid++){\n                    cmax(w[k+1][i][j],w[k][i][mid]+w[k][mid][j]);\n                }\n            }\n        }\n    }\n\n    int lb=0;\n    int ub=1e6+2;\n    while(ub-lb>1){\n        int mid=(lb+ub)/2;\n        vector<int> dp(V,0);\n        int res=0;\n        for(int i=LOG-1;i>=0;i--){\n            cmax(res,*max_element(dp.begin(),dp.end()));\n            if((mid>>i)&1){\n                vector<int> next(V,-1e9);\n                for(int j=0;j<V;j++){\n                    for(int k=0;k<V;k++){\n                        cmax(next[k],dp[j]+w[i][j][k]);\n                    }\n                }\n                dp=next;\n            }\n        }\n        cmax(res,*max_element(dp.begin(),dp.end()));\n        if(res>=K){\n            ub=mid;\n        }\n        else{\n            lb=mid;\n        }\n    }\n    if(ub>K){\n        cout<<-1<<endl;\n        return 0;\n    }\n    else{\n        cout<<ub<<endl;\n        if(ub<=100){\n            vector<vector<int>> dp(ub+1,vector<int>(V,0));\n            vector<vector<int>> prev(ub+1,vector<int>(V,-1e9));\n            for(int i=0;i<ub;i++){\n                for(int j=0;j<V;j++){\n                    for(auto &e:g[j]){\n                        if(dp[i+1][e.to]<dp[i][e.from]+e.cost){\n                            dp[i+1][e.to]=dp[i][e.from]+e.cost;\n                            prev[i+1][e.to]=e.from;\n                        }\n                    }\n                }\n            }\n            int x=max_element(dp[ub].begin(),dp[ub].end())-dp[ub].begin();\n            vector<int> res(ub+1);\n            for(int i=0;i<ub;i++){\n                res[i]=x;\n                x=prev[ub-i][x];\n            }\n            res[ub]=x;\n            reverse(res.begin(),res.end());\n            for(int i=0;i<=ub;i++){\n                cout<<res[i]<<(i+1==ub ? \"\\n\" : \" \");\n            }\n        }\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<ll(n);++i)\n#define RREP(i,n) for(ll i=ll(n)-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<ll(n);++i)\n#define RFOR(i,m,n) for(ll i=ll(n)-1;i>=ll(m);--i)\n#define ALL(v) (v).begin(),(v).end()\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconstexpr int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconstexpr int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vvi = vector<vi>;\nusing vvl = vector<vl>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\ntemplate <class T> bool chmin(T &a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate <class T> bool chmax(T &a, T b) { if (a < b) { a = b; return true; } return false; }\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n, m, k;\n\tcin >> n >> m >> k;\n\tvvi v(n, vi(n, -INF));\n\tREP(i, m) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\tchmax(v[a][b], c);\n\t}\n\tvector<vvi> d;\n\td.push_back(v);\n\twhile (1) {\n\t\tvvi t = d.back(), a = d.back();\n\t\tREP(i, n)REP(j, n)REP(k, n) {\n\t\t\tif (t[i][k] != -INF && t[k][j] != -INF && t[i][k] + t[k][j] > a[i][j]) {\n\t\t\t\ta[i][j] = t[i][k] + t[k][j];\n\t\t\t}\n\t\t}\n\t\tint m = 0;\n\t\tREP(i, n)REP(j, n)chmax(m, a[i][j]);\n\n\t\tif (d.back() == a)break;\n\t\td.push_back(a);\n\t\tif (m >= k)break;\n\t}\n\t{\n\t\tint m = 0;\n\t\tREP(i, n)REP(j, n)chmax(m, d.back()[i][j]);\n\t\tif (m < k) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tint l = -1, r = (1 << (d.size() + 1)) - 1;\n\twhile (r - l > 1) {\n\t\tint mid = (r + l) / 2;\n\t\tvvi a(n, vi(n, -INF));\n\t\tREP(i, n)a[i][i] = 0;\n\t\tREP(f, d.size()) {\n\t\t\tif (mid&(1 << f)) {\n\t\t\t\tvvi t = d[f], next = a;\n\t\t\t\tREP(k, n)REP(i, n)REP(j, n) {\n\t\t\t\t\tif (a[i][k] != -INF && t[k][j] != -INF && a[i][k] + t[k][j] > next[i][j]) {\n\t\t\t\t\t\tnext[i][j] = a[i][k] + t[k][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ta = next;\n\t\t\t}\n\t\t}\n\t\tint m = 0;\n\t\tREP(i, n)REP(j, n)chmax(m, a[i][j]);\n\t\tif (m >= k)r = mid;\n\t\telse l = mid;\n\t}\n\n\tcout << r << endl;\n\n\tif (r <= 100) {\n\t\tvector<vvi> p;\n\t\t{\n\t\t\tvvi tmp(n, vi(n, -INF));\n\t\t\tREP(i, n)tmp[i][i] = 0;\n\t\t\tp.push_back(tmp);\n\t\t}\n\t\tREP(i, r) {\n\t\t\tvvi t = p.back(), a(n, vi(n, -INF));\n\t\t\tREP(i, n)a[i][i] = 0;\n\t\t\tREP(i, n)REP(j, n)REP(k, n) {\n\t\t\t\tif (t[i][k] != -INF && v[k][j] != -INF && t[i][k] + v[k][j] > a[i][j]) {\n\t\t\t\t\ta[i][j] = t[i][k] + v[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tp.push_back(a);\n\t\t}\n\t\tvi ans;\n\t\tint x = -1, y = -1;\n\t\tint t = 0;\n\t\tREP(i, n)REP(j, n)if (p.back()[i][j] >= t) {\n\t\t\tx = i;\n\t\t\ty = j;\n\t\t\tt = p.back()[i][j];\n\t\t}\n\n\t\tREP(f, r) {\n\t\t\tREP(k, n) {\n\t\t\t\tif (v[x][k] + p[r - f - 1][k][y] == p[r - f][x][y]) {\n\t\t\t\t\tans.push_back(x);\n\t\t\t\t\tx = k;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\n\n\t\t\t}\n\t\t}\n\t\tans.push_back(y);\n\t\tREP(i, r + 1)cout << ans[i] << \" \\n\"[i == r];\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\nint V,E,K;\nconst int INF = (1<<29);\nmat G;\n\nmat g[30];\nmat u[30];\n\nint add(int a,int b){\n  if(a==-INF||b==-INF)return -INF;\n  return min(a+b,INF);\n}\n\npair<mat,mat> merge(mat A,mat B, bool flag=false){\n  mat X( V, vec(V, -INF) );\n  mat Y( V, vec(V, -INF) );\n  \n  for(int from=0;from<V;from++){\n    for(int to=0;to<V;to++){\n      for(int ex=0;ex<V;ex++){\n        int cost=add(A[from][ex],B[ex][to]);\n        if(X[from][to]<cost){\n          X[from][to]=cost;\n          Y[from][to]=ex;\n        }\n      }\n    }\n  }\n  return make_pair(X,Y);\n}\n\n\nint calc(int m,int &si,int &ti){\n  mat t;\n  for(int i=0;i<30;i++){\n    if(m>>i&1){\n      if(t.empty()){\n        t=g[i];\n      }else{\n        t=merge(t,g[i]).first;\n      }\n    }\n  }\n  \n  int res=-INF;\n  for(int i=0;i<V;i++){\n    for(int j=0;j<V;j++){\n      if(res<t[i][j]){\n        si=i;\n        ti=j;\n        res=t[i][j];\n      }\n    }\n  }\n  return res;\n}\n\nvoid Dfs(vec& s,int from,int to,int len){\n  if(len<=1)return;\n  if(len==(len&-len)){\n\n    for(int i=0;i<30;i++){\n      if(len>>i&1){\n        int ex=u[i][from][to];\n        Dfs(s,from,ex,len/2);\n        s.push_back(ex);\n        Dfs(s,ex,to,len/2);\n        return;\n      }\n    }\n  }\n  \n  mat t;\n  \n  int ex=-1;\n  int sub=-1;\n  \n  for(int i=0;i<30;i++){\n    if(~len>>i&1)continue;\n    if(t.empty()){\n      t=g[i];\n      continue;\n    }\n    pair<mat,mat> tmp=merge(t, g[i]);\n    t=tmp.first;\n    ex=tmp.second[from][to];\n    sub=(1<<i);\n  }\n\n  Dfs(s,from,ex,len-sub);\n  s.push_back(ex);\n  Dfs(s,ex,to,sub);\n}\n\nint main(){\n  cin>>V>>E>>K;\n  G=mat( V, vec(V, -INF) );\n  g[0]=u[0]=G;\n  for(int i=0;i<V;i++)g[0][i][i]=0;\n  for(int i=0;i<E;i++){\n    int a,b,c;\n    cin>>a>>b>>c;\n    G[a][b]=max(G[a][b],c);\n    if(g[0][a][b]<c){\n      g[0][a][b]=c;\n      u[0][a][b]=b;\n    }\n  }\n  \n  for(int i=1;i<30;i++){\n    pair<mat,mat> temp=merge(g[i-1],g[i-1]);\n    g[i]=temp.first;\n    u[i]=temp.second;\n  }\n  int left=1,right=K+1,mid,si,ti;\n  while( left < right ){\n    mid=(left+right)/2;\n    if( calc(mid,si,ti) >= K ){\n      right=mid;\n    }else{\n      left=mid+1;\n    }\n  }\n\n  for(int i=0;i<V;i++)g[0][i][i]=-INF;\n  for(int i=1;i<30;i++){\n    pair<mat,mat> temp=merge(g[i-1],g[i-1]);\n    g[i]=temp.first;\n    u[i]=temp.second;\n  }\n  \n  if(left==K+1){\n    cout<<-1<<endl;\n  }else{\n    cout<<left<<endl;\n    if(left<=100){\n      vec tab;\n      tab.push_back(si);\n      Dfs(tab,si,ti,left);\n      tab.push_back(ti);\n\n      int sum=0;\n      for(int i=0;i<(int)tab.size();i++){\n\n        \n        if(i>0){\n          int cost=G[ tab[i-1] ][ tab[i] ];\n          if(cost == -INF ){\n            assert(0);\n          }else{\n            sum=add(sum,cost);\n          }\n        }\n        \n        if(i)cout<<' ';\n        cout<<tab[i];\n      }\n      cout<<endl;\n      cout<<sum<<' '<<calc(left,si,ti)<<endl;\n      assert( sum == calc(left,si,ti) );\n    }\n  }\n  return 0;\n}\n\n  \n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<int(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nconstexpr int INF = 1000000000;\n\nusing Array = vector<int>;\nusing Matrix = vector<Array>;\n\nMatrix mul(const Matrix& lhs, const Matrix& rhs) {\n  int r = lhs.size();\n  Matrix res(r, Array(r, -INF));\n  REP(i,r) REP(k,r) REP(j,r) {\n    res[i][j] = max(res[i][j], lhs[i][k] + rhs[k][j]);\n  }\n  return res;\n}\n\nMatrix pow(const Matrix& mat, int index) {\n  if (index == 0) {\n    int v = mat.size();\n    Matrix res(v, Array(v, -INF));\n    REP(i,v) res[i][i] = 0;\n    return res;\n  }\n  if (index == 1) return mat;\n  if ((index % 2) == 1) {\n    return mul(mat, pow(mat, index-1));\n  }\n  return pow(mul(mat, mat), index/2);\n}\n\nint main() {\n  int v,e,k;\n  cin>>v>>e>>k;\n  Matrix mat(v, Array(v, -INF));\n  REP(i,e) {\n    int s,t,c;\n    cin>>s>>t>>c;\n    mat[s][t] = max(mat[s][t], c);\n  }\n  int hi = k;\n  int lo = 0;\n  while (hi - lo > 1) {\n    int mid = (hi + lo) / 2;\n    auto pmat = pow(mat, mid);\n    int mx = -INF;\n    REP(i,v)REP(j,v) mx = max(mx, pmat[i][j]);\n    if (mx > k - 100 * v) {\n      hi = mid;\n    } else {\n      lo = mid;\n    }\n  }\n  lo = max(0, lo - v * 100);\n  auto pmat = pow(mat, lo);\n  vector<int> score(v, -INF);\n  REP(i,v)REP(j,v) score[j] = max(score[j], pmat[i][j]);\n  REP(cnt,300 * v) {\n    vector<int> tmp(v, -INF);\n    REP(i,v)REP(j,v) tmp[j] = max(tmp[j], score[i] + mat[i][j]);\n    int mx = -INF;\n    REP(i,v) mx = max(mx, tmp[i]);\n    swap(score, tmp);\n    if (mx >= k) {\n      lo += cnt + 1;\n      break;\n    }\n  }\n  if (lo > 0 && lo <= k) {\n    cout << lo << endl;\n  } else {\n    cout << -1 << endl;\n    return 0;\n  }\n  if (hi > 100) {\n    return 0;\n  }\n  vector<vector<int>> vscore;\n  REP(i,v) score[i] = 0;\n  REP(cnt,lo) {\n    vector<int> tmp(v, -INF);\n    REP(i,v)REP(j,v) tmp[j] = max(tmp[j], score[i] + mat[i][j]);\n    int mx = -INF;\n    REP(i,v) mx = max(mx, tmp[i]);\n    vscore.push_back(score);\n    swap(score, tmp);\n  }\n  int t = 0;\n  int mx = -INF;\n  REP(i,v) {\n    if (score[i] > mx) {\n      mx = score[i];\n      t = i;\n    }\n  }\n  vector<int> res;\n  res.push_back(t);\n  for (int i = lo-1; i >= 0; --i) {\n    int nt = 0;\n    int nmx = -INF;\n    REP(j,v) {\n      if (vscore[i][j] + mat[j][t] == mx) {\n        nt = j;\n        nmx = vscore[i][j];\n      }\n    }\n    t = nt;\n    mx = nmx;\n    res.push_back(t);\n  }\n  reverse(ALL(res));\n  REP(i,res.size()) {\n    if (i) cout << ' ';\n    cout << res[i];\n  }\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n#define for_rev(i,a,b) for(int i=(a);i>=(b);--i)\n\ntypedef vector< int > Ary;\ntypedef vector< Ary > Mat;\n\nstruct Edge { int to, c; };\n\nvoid maxUpdate(int& a, int b) { a = max(a, b); }\n\nvoid mul(Mat& res, Mat& a, Mat& b) {\n\tint N = a.size();\n\tres = a;\n\t\n\tfor_(i,0,N) for_(j,0,N) for_(k,0,N) {\n\t\tif (a[i][k] >= 0 && b[k][j] >= 0) maxUpdate(res[i][j], a[i][k] + b[k][j]);\n\t}\n}\n\nint V, K, E, dp[155][155], prv[155][155];\nvector< vector< Edge > > adj;\n\nvoid restore(int step, int v) {\n\tint c = step;\n\tvector< int > path;\n\t\n\twhile (v != -1) {\n\t\tpath.push_back(v);\n\t\tv = prv[c--][v];\n\t}\n\t\n\treverse(path.begin(), path.end());\n\tfor_(i,0,step+1) cout << path[i] << (i < step ? \" \" : \"\\n\");\n}\n\nbool shortPhase() {\n\tmemset(dp, -1, sizeof(dp));\n\tmemset(prv, -1, sizeof(prv));\n\t\n\tfor_(v,0,V) dp[0][v] = 0;\n\t\n\tint max_score = -1, step = -1, terminal = -1;\n\t\n\tfor_(i,0,150) {\n\t\tfor_(v,0,V) {\n\t\t\tif (dp[i][v] == -1) continue;\n\t\t\n\t\t\tfor (Edge e : adj[v]) {\n\t\t\t\tif (dp[i + 1][e.to] < dp[i][v] + e.c) {\n\t\t\t\t\tdp[i + 1][e.to] = dp[i][v] + e.c;\n\t\t\t\t\tprv[i + 1][e.to] = v;\n\t\t\t\t\t\n\t\t\t\t\tif (max_score < dp[i + 1][e.to]) {\n\t\t\t\t\t\tmax_score = dp[i + 1][e.to];\n\t\t\t\t\t\tterminal = e.to;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (max_score >= K) {\n\t\t\tstep = i + 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tif (max_score >= K) {\n\t\tcout << step << endl;\n\t\trestore(step, terminal);\n\t\treturn true;\n\t}\n\t\n\tif (max_score == -1) {\n\t\tcout << -1 << endl;\n\t\treturn true;\n\t}\n\t\n\treturn false;\n}\n\nint calcMinStep() {\n\tMat mat[21], ini(V, Ary(V, -1));\n\t\n\tfor_(v,0,V) for (Edge e : adj[v]) {\n\t\tmaxUpdate(ini[v][e.to], e.c);\n\t}\n\t\n\tmat[0] = ini;\n\tfor_(i,0,20) mul(mat[i + 1], mat[i], mat[i]);\n\t\n\tint res = 0;\n\t\n\tMat x(V, Ary(V, -1)), nx;\n\tfor_(v,0,V) x[v][v] = 0;\n\t\n\tfor_rev(h,19,0) {\n\t\tmul(nx, x, mat[h]);\n\t\t\n\t\tint max_score = 0;\n\t\tfor_(u,0,V) for_(v,0,V) maxUpdate(max_score, nx[u][v]);\n\t\t\n\t\tif (max_score < K) {\n\t\t\tx = nx;\n\t\t\tres += 1 << h;\n\t\t}\n\t}\n\t\n\treturn res + 1;\n}\n\nvoid solve() {\n\tif (!shortPhase()) {\n\t\tint ans = calcMinStep();\n\t\tcout << (ans > (int)1e6 ? -1 : ans) << endl;\n\t}\n}\n\nint main() {\n\tcin >> V >> E >> K;\n\t\n\tadj.assign(V, vector< Edge >());\n\t\n\tfor_(i,0,E) {\n\t\tint u, v, c;\n\t\tcin >> u >> v >> c;\n\t\tadj[u].push_back(Edge{v, c});\n\t}\n\t\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\nint V,E,K;\nconst int INF = (1<<29);\nmat G;\n\nmat g[30];\nmat u[30];\n\nint add(int a,int b){\n  if(a==-INF||b==-INF)return -INF;\n  return min(a+b,INF);\n}\n\npair<mat,mat> merge(mat A,mat B, bool flag=false){\n  mat X( V, vec(V, -INF) );\n  mat Y( V, vec(V, -INF) );\n  \n  for(int from=0;from<V;from++){\n    for(int to=0;to<V;to++){\n      for(int ex=0;ex<V;ex++){\n        int cost=add(A[from][ex],B[ex][to]);\n        if(X[from][to]<cost){\n          X[from][to]=cost;\n          Y[from][to]=ex;\n        }\n      }\n    }\n  }\n  return make_pair(X,Y);\n}\n\n\nint calc(int m,int &si,int &ti){\n  mat t;\n  for(int i=0;i<30;i++){\n    if(m>>i&1){\n      if(t.empty()){\n        t=g[i];\n      }else{\n        t=merge(t,g[i]).first;\n      }\n    }\n  }\n  \n  int res=-INF;\n  for(int i=0;i<V;i++){\n    for(int j=0;j<V;j++){\n      if(res<t[i][j]){\n        si=i;\n        ti=j;\n        res=t[i][j];\n      }\n    }\n  }\n  return res;\n}\n\nvoid Dfs(vec& s,int from,int to,int len){\n  if(len<=1)return;\n  if(len==(len&-len)){\n\n    for(int i=0;i<30;i++){\n      if(len>>i&1){\n        int ex=u[i][from][to];\n        Dfs(s,from,ex,len/2);\n        s.push_back(ex);\n        //        cout<<i<<' '<<from<<' '<<to<<' '<<ex<<endl;\n        Dfs(s,ex,to,len/2);\n        return;\n      }\n    }\n  }\n  \n  mat t=mat( V, vec(V,-INF) );\n  for(int i=0;i<V;i++)t[i][i]=0;\n  \n  int ex=-1;\n  int sub=-1;\n  \n  for(int i=0;i<30;i++){\n    if(~len>>i&1)continue;\n    pair<mat,mat> tmp=merge(t, g[i]);\n    ex=tmp.second[from][to];\n    sub=(1<<i);\n  }\n\n  Dfs(s,from,ex,len-sub);\n  s.push_back(ex);\n  Dfs(s,ex,to,sub);\n}\n\nint main(){\n  cin>>V>>E>>K;\n  G=mat( V, vec(V, -INF) );\n  g[0]=u[0]=G;\n  for(int i=0;i<V;i++)g[0][i][i]=0;\n  for(int i=0;i<E;i++){\n    int a,b,c;\n    cin>>a>>b>>c;\n    assert(a!=b);\n    G[a][b]=max(G[a][b],c);\n    g[0][a][b]=max(g[0][a][b],c);\n    u[0][a][b]=b;\n  }\n  for(int i=1;i<30;i++){\n    pair<mat,mat> temp=merge(g[i-1],g[i-1]);\n    g[i]=temp.first;\n    u[i]=temp.second;\n  }\n  int left=1,right=K+1,mid,si,ti;\n  while( left < right ){\n    mid=(left+right)/2;\n    if( calc(mid,si,ti) >= K ){\n      right=mid;\n    }else{\n      left=mid+1;\n    }\n  }\n  for(int i=0;i<V;i++)g[0][i][i]=-INF;\n  for(int i=1;i<30;i++){\n    pair<mat,mat> temp=merge(g[i-1],g[i-1]);\n    g[i]=temp.first;\n    u[i]=temp.second;\n  }\n  assert(  calc(left,si,ti) >= K );\n  \n  if(left==K+1){\n    cout<<-1<<endl;\n  }else{\n    cout<<left<<endl;\n    if(left<=100){\n      vec tab;\n      tab.push_back(si);\n      Dfs(tab,si,ti,left);\n      tab.push_back(ti);\n\n      int sum=0;\n      for(int i=0;i<(int)tab.size();i++){\n\n        \n        if(i>0){\n          int cost=G[ tab[i-1] ][ tab[i] ];\n          if(cost == -INF ){\n            assert(0);\n          }else{\n            sum=add(sum,cost);\n          }\n        }\n        \n        if(i)cout<<' ';\n        cout<<tab[i];\n      }\n      cout<<endl;\n      assert( sum == calc(left,si,ti) );\n      \n    }\n  }\n  return 0;\n}\n\n  \n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nint n, m, k;\ntypedef vector<vi> M;\nM operator*(const M &a, const M &b){\n\tM c(a.size(), vi(a.size()));\n\trep(i, n) rep(j, n) c[i][j] = max(a[i][j], b[i][j]);\n\trep(l, n) rep(i, n) rep(j, n) if(a[i][l] >= 0 && b[l][j] >= 0){\n\t\tc[i][j] = max(c[i][j], a[i][l] + b[l][j]);\n\t\tif(c[i][j] >= k) c[i][j] = k;\n\t}\n\treturn c;\n}\nint dp[128][150], prev[128][150];\nvoid solve(const M &e){\n\tmemset(dp, -1, sizeof(dp));\n\trep(i, n) dp[0][i] = 0;\n\tint ai, al;\n\trep(i, 100) rep(j, n) if(dp[i][j] >= 0){\n\t\trep(l, n) if(e[j][l] >= 0 && dp[i + 1][l] < dp[i][j] + e[j][l]){\n\t\t\tdp[i + 1][l] = min(k, dp[i][j] + e[j][l]);\n\t\t\tprev[i + 1][l] = j;\n\t\t\tif(dp[i + 1][l] >= k){\n\t\t\t\tai = i + 1; al = l;\n\t\t\t\tgoto END;\n\t\t\t}\n\t\t}\n\t}\n\tEND:\n\tvi ans;\n\tfor(; ai >= 0; ai--){\n\t\tans.pb(al);\n\t\tif(ai > 0) al = prev[ai][al];\n\t}\n\treverse(all(ans));\n\trep(i, ans.size()) cout << ans[i] << (i == ans.size() - 1 ? \"\\n\" : \" \");\n}\nint main(){\n\tcin >> n >> m >> k;\n\tM e(n, vi(n, -1)), p(n, vi(n, -1));\n\tM pw[20];\n\t\n\trep(i, m){\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\te[a][b] = max(e[a][b], c);\n\t}\n\t\n\trep(i, n) p[i][i] = 0;\n\tpw[0] = e;\n\trep(i, 19) pw[i + 1] = pw[i] * pw[i];\n\t\n\tint ans = 0;\n\tbool can = 0;\n\tfor(int i = 19; i >= 0; i--){\n\t\tM pp = p * pw[i];\n\t\t\n\t\tbool ok = 0;\n\t\trep(j, n) rep(l, n) if(pp[j][l] >= k) ok = can = 1;\n\t\tif(!ok) p = pp, ans += 1 << i;\n\t}\n\tif(!can){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tans++;\n\tcout << ans << endl;\n\tif(ans <= 100) solve(e);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<int(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nconstexpr int INF = 1000000000;\n\nusing Array = vector<int>;\nusing Matrix = vector<Array>;\n\nMatrix mul(const Matrix& lhs, const Matrix& rhs) {\n  int r = lhs.size();\n  Matrix res(r, Array(r, -INF));\n  REP(i,r) REP(k,r) REP(j,r) {\n    res[i][j] = max(res[i][j], lhs[i][k] + rhs[k][j]);\n  }\n  return res;\n}\n\nMatrix pow(const Matrix& mat, int index) {\n  if (index == 1) return mat;\n  if ((index % 2) == 1) {\n    return mul(mat, pow(mat, index-1));\n  }\n  return pow(mul(mat, mat), index/2);\n}\n\nint main() {\n  int v,e,k;\n  cin>>v>>e>>k;\n  Matrix mat(v, Array(v, -INF));\n  REP(i,e) {\n    int s,t,c;\n    cin>>s>>t>>c;\n    mat[s][t] = max(mat[s][t], c);\n  }\n  vector<vector<int>> vscore;\n  vscore.reserve(100);\n  vector<int> score(v, 0);\n  vector<int> tmp(v);\n  int lo = INF;\n  REP(cnt,k) {\n    REP(i,v) tmp[i] = -INF;\n    REP(i,v)REP(j,v) tmp[j] = max(tmp[j], score[i] + mat[i][j]);\n    int mx = -INF;\n    REP(i,v) mx = max(mx, tmp[i]);\n    if (cnt < 100) vscore.push_back(score);\n    swap(score, tmp);\n    if (mx >= k) {\n      lo = cnt + 1;\n      break;\n    }\n  }\n  if (lo <= k) {\n    cout << lo << endl;\n  } else {\n    cout << -1 << endl;\n  }\n  if (lo > 100) {\n    return 0;\n  }\n  int t = 0;\n  int mx = -INF;\n  REP(i,v) {\n    if (score[i] > mx) {\n      mx = score[i];\n      t = i;\n    }\n  }\n  vector<int> res;\n  res.push_back(t);\n  for (int i = lo-1; i >= 0; --i) {\n    int nt = 0;\n    int nmx = -INF;\n    REP(j,v) {\n      if (vscore[i][j] + mat[j][t] == mx) {\n        nt = j;\n        nmx = vscore[i][j];\n      }\n    }\n    t = nt;\n    mx = nmx;\n    res.push_back(t);\n  }\n  reverse(ALL(res));\n  REP(i,res.size()) {\n    if (i) cout << ' ';\n    cout << res[i];\n  }\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 151;\n\ntemplate<typename T> class mat : public vector<vector<T> > {\nprivate:\n    int r,c;    //行,列\npublic:\n    int row() const {\n        return r;\n    }\n    int column() const {\n        return c;\n    }\n    mat(int n,int m,T val = 0){\n        this->r = n,this->c = m;\n        rep(i,n){\n            this->push_back(vector<T>(m,val));\n        }\n    }\n    mat operator+(const mat& another){\n        if(this->r != another.r && this->c != another.c){\n            cout << \"足し算失敗(サイズ不一致)\" << endl;\n            exit(1);\n        }\n        mat<T> X(this->r,this->c);\n        rep(i,this->r){\n            rep(j,this->c){\n                X[i][j] = (*this)[i][j] + another[i][j];\n            }\n        }\n        return X;\n    }\n    mat operator+(const T val){\n        mat<T> X(this->r,this->c);\n        rep(i,this->r){\n            rep(j,this->c){\n                X[i][j] = (*this)[i][j] + val;\n            }\n        }\n        return X;\n    }\n    mat operator-(const mat& another){\n        if(this->r != another.r && this->c != another.c){\n            cout << \"引き算失敗(サイズ不一致)\" << endl;\n            exit(1);\n        }\n        mat<T> X(this->r,this->c);\n        rep(i,this->r){\n            rep(j,this->c){\n                X[i][j] = (*this)[i][j] - another[i][j];\n            }\n        }\n        return X;\n    }\n    mat operator-(const T val){\n        mat<T> X(this->r,this->c);\n        rep(i,this->r){\n            rep(j,this->c){\n                X[i][j] = (*this)[i][j] - val;\n            }\n        }\n        return X;\n    }\n    vector<T> operator*(const vector<T>& another){\n        if(this->c != (int)another.size()){\n            cout << \"掛け算失敗(サイズ不一致)\" << endl;\n            exit(1);\n        }\n        vector<T> vec(this->r,0);\n        rep(i,this->r){\n            rep(j,this->c){\n                vec[i] += (*this)[i][j] * another[j];\n            }\n        }\n        return vec;\n    }\n    mat operator*(const mat& another){\n        if(this->c != another.r){\n            cout << \"掛け算失敗(サイズ不一致)\" << endl;\n            exit(1);\n        }\n        mat<T> X(this->r,another.c);\n        rep(i,this->r){\n            rep(k,this->c){\n                rep(j,another.c){\n\t\t\t\t\tif(k == j || ((*this)[i][k] && another[k][j])){\n\t\t\t\t\t\tcmx(X[i][j],(*this)[i][k]+another[k][j]);\n\t\t\t\t\t}\n                }\n            }\n        }\n        return X;\n    }\n    mat operator-(){\n        mat<T> X(this->r,this->c);\n        rep(i,this->r){\n            rep(j,this->c){\n                X[i][j] = -(*this)[i][j];\n            }\n        }\n        return X;\n    }\n    void print(){\n        rep(i,this->r){\n            rep(j,(this->c)-1){\n                cout << (*this)[i][j] << \",\";\n            }\n            cout << (*this)[i][(this->c)-1] << endl;\n        }\n    }\n};\n\ntemplate<typename T> mat<T> pow(mat<T> A,ll cnt)\n{\n    if(A.row() != A.column()){\n        cout << \"累乗不可\" << endl;\n    }\n\tmat<T> B = A;\n\t--cnt;\n\twhile(cnt>0){\n\t\tif(cnt & 1){\n\t\t\tB = B*A;\n\t\t}\n\t\tA = A*A;\n\t\tcnt >>= 1;\n\t}\n\treturn B;\n}\n\nstruct edge{\n\tint to,cost;\n};\n\nvector<edge> G[MAX_N];\n\nbool possible(mat<int>& A,const int cri,const int K)\n{\n\tint n = A.row();\n\tmat<int> res = pow(A,cri);\n\tint mx = 0;\n\trep(i,n){\n\t\trep(j,n){\n\t\t\tcmx(mx,res[i][j]);\n\t\t}\n\t}\n\treturn (mx >= K);\n}\n\nint mx[101][151];\nint pre[101][151];\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n,m,K;\n\tcin >> n >> m >> K;\n\tmat<int> A(n,n);\n\trep(i,m){\n\t\tint a,b,c;\n\t\tcin >> a >> b >> c;\n\t\tcmx(A[a][b],c);\n\t}\n\trep(i,n){\n\t\trep(j,n){\n\t\t\tif(A[i][j]){\n\t\t\t\tG[i].pb((edge){j,A[i][j]});\n\t\t\t}\n\t\t}\n\t}\n\tmat<int> res = pow(A,100);\n\tif(!possible(A,K,K)){\n\t\tcout << \"-1\\n\";\n\t\treturn 0;\n\t}\n\tint l = 0,r = K;\n\twhile(r-l>1){\n\t\tint mid = (l+r)/2;\n\t\tif(possible(A,mid,K)){\n\t\t\tr = mid;\n\t\t}else{\n\t\t\tl = mid;\n\t\t}\n\t}\n\tcout << r << \"\\n\";\n\tif(r > 100){\n\t\treturn 0;\n\t}\n\trep(i,r){\n\t\trep(j,n){\n\t\t\teach(e,G[j]){\n\t\t\t\tif(mx[i+1][e.to] < mx[i][j] + e.cost){\n\t\t\t\t\tmx[i+1][e.to] = mx[i][j] + e.cost;\n\t\t\t\t\tpre[i+1][e.to] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint cri = *max_element(mx[r],mx[r]+n);\n\tvector<int> ans;\n\trep(i,n){\n\t\tif(mx[r][i] == cri){\n\t\t\tint nw = i;\n\t\t\trrep(j,r+1){\n\t\t\t\tans.pb(nw);\n\t\t\t\tnw = pre[j][nw];\n\t\t\t}\n\t\t\treverse(all(ans));\n\t\t\teach(it,ans){\n\t\t\t\tcout << it << \" \";\n\t\t\t}\n\t\t\tcout << \"\\n\";\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 151;\n\ntemplate<typename T> class mat : public vector<vector<T> > {\nprivate:\n    int r,c;    //行,列\npublic:\n    int row() const {\n        return r;\n    }\n    int column() const {\n        return c;\n    }\n    mat(int n,int m,T val = 0){\n        this->r = n,this->c = m;\n        rep(i,n){\n            this->push_back(vector<T>(m,val));\n        }\n    }\n    mat operator+(const mat& another){\n        if(this->r != another.r && this->c != another.c){\n            cout << \"足し算失敗(サイズ不一致)\" << endl;\n            exit(1);\n        }\n        mat<T> X(this->r,this->c);\n        rep(i,this->r){\n            rep(j,this->c){\n                X[i][j] = (*this)[i][j] + another[i][j];\n            }\n        }\n        return X;\n    }\n    mat operator+(const T val){\n        mat<T> X(this->r,this->c);\n        rep(i,this->r){\n            rep(j,this->c){\n                X[i][j] = (*this)[i][j] + val;\n            }\n        }\n        return X;\n    }\n    mat operator-(const mat& another){\n        if(this->r != another.r && this->c != another.c){\n            cout << \"引き算失敗(サイズ不一致)\" << endl;\n            exit(1);\n        }\n        mat<T> X(this->r,this->c);\n        rep(i,this->r){\n            rep(j,this->c){\n                X[i][j] = (*this)[i][j] - another[i][j];\n            }\n        }\n        return X;\n    }\n    mat operator-(const T val){\n        mat<T> X(this->r,this->c);\n        rep(i,this->r){\n            rep(j,this->c){\n                X[i][j] = (*this)[i][j] - val;\n            }\n        }\n        return X;\n    }\n    vector<T> operator*(const vector<T>& another){\n        if(this->c != (int)another.size()){\n            cout << \"掛け算失敗(サイズ不一致)\" << endl;\n            exit(1);\n        }\n        vector<T> vec(this->r,0);\n        rep(i,this->r){\n            rep(j,this->c){\n                vec[i] += (*this)[i][j] * another[j];\n            }\n        }\n        return vec;\n    }\n    mat operator*(const mat& another){\n        if(this->c != another.r){\n            cout << \"掛け算失敗(サイズ不一致)\" << endl;\n            exit(1);\n        }\n        mat<T> X(this->r,another.c);\n        rep(i,this->r){\n            rep(k,this->c){\n                rep(j,another.c){\n\t\t\t\t\tif((*this)[i][k] && another[k][j]){\n\t\t\t\t\t\tcmx(X[i][j],(*this)[i][k]+another[k][j]);\n\t\t\t\t\t}\n                }\n            }\n        }\n        return X;\n    }\n    mat operator-(){\n        mat<T> X(this->r,this->c);\n        rep(i,this->r){\n            rep(j,this->c){\n                X[i][j] = -(*this)[i][j];\n            }\n        }\n        return X;\n    }\n    void print(){\n        rep(i,this->r){\n            rep(j,(this->c)-1){\n                cout << (*this)[i][j] << \",\";\n            }\n            cout << (*this)[i][(this->c)-1] << endl;\n        }\n    }\n};\n\ntemplate<typename T> mat<T> pow(mat<T> A,ll cnt)\n{\n    if(A.row() != A.column()){\n        cout << \"累乗不可\" << endl;\n    }\n\tmat<T> B = A;\n\t--cnt;\n\twhile(cnt>0){\n\t\tif(cnt & 1){\n\t\t\tB = B*A;\n\t\t}\n\t\tA = A*A;\n\t\tcnt >>= 1;\n\t}\n\treturn B;\n}\n\nstruct edge{\n\tint to,cost;\n};\n\nvector<edge> G[MAX_N];\n\nbool possible(mat<int>& A,const int cri,const int K)\n{\n\tint n = A.row();\n\tmat<int> res = pow(A,cri);\n\tint mx = 0;\n\trep(i,n){\n\t\trep(j,n){\n\t\t\tcmx(mx,res[i][j]);\n\t\t}\n\t}\n\treturn (mx >= K);\n}\n\nint mx[101][151];\nint pre[101][151];\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n,m,K;\n\tcin >> n >> m >> K;\n\tmat<int> A(n,n);\n\trep(i,m){\n\t\tint a,b,c;\n\t\tcin >> a >> b >> c;\n\t\tcmx(A[a][b],c);\n\t}\n\trep(i,n){\n\t\trep(j,n){\n\t\t\tif(A[i][j]){\n\t\t\t\tG[i].pb((edge){j,A[i][j]});\n\t\t\t}\n\t\t}\n\t}\n\tif(!possible(A,K,K)){\n\t\tcout << \"-1\\n\";\n\t\treturn 0;\n\t}\n\tint l = 0,r = K;\n\twhile(r-l>1){\n\t\tint mid = (l+r)/2;\n\t\tif(possible(A,mid,K)){\n\t\t\tr = mid;\n\t\t}else{\n\t\t\tl = mid;\n\t\t}\n\t}\n\tcout << r << \"\\n\";\n\tif(r > 100){\n\t\treturn 0;\n\t}\n\trep(i,r){\n\t\trep(j,n){\n\t\t\teach(e,G[j]){\n\t\t\t\tif(mx[i+1][e.to] < mx[i][j] + e.cost){\n\t\t\t\t\tmx[i+1][e.to] = mx[i][j] + e.cost;\n\t\t\t\t\tpre[i+1][e.to] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint cri = *max_element(mx[r],mx[r]+n);\n\tvector<int> ans;\n\trep(i,n){\n\t\tif(mx[r][i] == cri){\n\t\t\tint nw;\n\t\t\tfor(int j=r;j>=1;j--){\n\t\t\t\tnw = pre[j][nw];\n\t\t\t\tans.pb(nw);\n\t\t\t}\n\t\t\treverse(all(ans));\n\t\t\teach(it,ans){\n\t\t\t\tcout << it << \" \";\n\t\t\t}\n\t\t\tcout << \"\\n\";\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<int(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nconstexpr int64_t INF = INT64_C(1000000000000000000);\n\nusing Array = vector<int64_t>;\nusing Matrix = vector<Array>;\n\nMatrix mul(const Matrix& lhs, const Matrix& rhs) {\n  int r = lhs.size();\n  Matrix res(r, Array(r, -INF));\n  REP(i,r) REP(k,r) REP(j,r) {\n    res[i][j] = max(res[i][j], lhs[i][k] + rhs[k][j]);\n  }\n  return res;\n}\n\nMatrix pow(const Matrix& mat, int64_t index) {\n  if (index == 1) return mat;\n  if ((index % 2) == 1) {\n    return mul(mat, pow(mat, index-1));\n  }\n  return pow(mul(mat, mat), index/2);\n}\n\nint main() {\n  int64_t v,e,k;\n  cin>>v>>e>>k;\n  Matrix mat(v, Array(v, -INF));\n  REP(i,e) {\n    int64_t s,t,c;\n    cin>>s>>t>>c;\n    mat[s][t] = max(mat[s][t], c);\n  }\n  int64_t hi = k;\n  int64_t lo = 0;\n  while (hi - lo > 1) {\n    int64_t mid = (hi + lo) / 2;\n    auto pmat = pow(mat, mid);\n    int64_t mx = -INF;\n    REP(i,v)REP(j,v) mx = max(mx, pmat[i][j]);\n    if (mx <= 0) {\n      hi = mid;\n    } else if (mx >= k) {\n      hi = mid;\n    } else {\n      lo = mid;\n    }\n  }\n  auto pmat = pow(mat, hi);\n  int64_t mx = -INF;\n  REP(i,v)REP(j,v) mx = max(mx, pmat[i][j]);\n  if (mx < k) {\n    cout << -1 << endl;\n    return 0;\n  } \n  cout << hi << endl;\n  if (hi > 100) {\n    return 0;\n  }\n  vector<Matrix> vmat;\n  Matrix m(v, Array(v, -INF));\n  REP(i,v) m[i][i] = 0;\n  REP(i,hi) {\n    vmat.push_back(m);\n    m = mul(mat, m);\n  }\n  int s=0,t=0;\n  REP(i,v)REP(j,v) {\n    if (pmat[i][j] == mx) {\n      s = i;\n      t = j;\n    }\n  }\n  vector<int> res;\n  for (int i = hi-1; i >= 0; --i) {\n    res.push_back(t);\n    int nt=0;\n    int64_t nmx=0;\n    REP(j,v) {\n      if (vmat[i][s][j] + mat[j][t] == mx) {\n        nt = j;\n        nmx = vmat[i][s][j];\n      }\n    }\n    t = nt;\n    mx = nmx;\n  }\n  cout << s;\n  reverse(ALL(res));\n  for (int r:res) cout << ' ' << r;\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<int(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nconstexpr int64_t INF = INT64_C(1000000000000000000);\n\nusing Array = vector<int64_t>;\nusing Matrix = vector<Array>;\n\nMatrix mul(const Matrix& lhs, const Matrix& rhs) {\n  int r = lhs.size();\n  Matrix res(r, Array(r, -INF));\n  REP(i,r) REP(k,r) REP(j,r) {\n    res[i][j] = max(res[i][j], lhs[i][k] + rhs[k][j]);\n  }\n  return res;\n}\n\nMatrix pow(const Matrix& mat, int64_t index) {\n  if (index == 1) return mat;\n  if ((index % 2) == 1) {\n    return mul(mat, pow(mat, index-1));\n  }\n  return pow(mul(mat, mat), index/2);\n}\n\nint main() {\n  int64_t v,e,k;\n  cin>>v>>e>>k;\n  Matrix mat(v, Array(v, -INF));\n  REP(i,e) {\n    int64_t s,t,c;\n    cin>>s>>t>>c;\n    mat[s][t] = max(mat[s][t], c);\n  }\n  int64_t hi = k;\n  int64_t lo = 0;\n  while (hi - lo > 1) {\n    int64_t mid = (hi + lo) / 2;\n    auto pmat = pow(mat, mid);\n    int64_t mx = -INF;\n    REP(i,v)REP(j,v) mx = max(mx, pmat[i][j]);\n    if (mx < 0) {\n      hi = mid;\n    } else if (mx >= k) {\n      hi = mid;\n    } else {\n      lo = mid;\n    }\n  }\n  auto pmat = pow(mat, hi);\n  int64_t mx = -INF;\n  REP(i,v)REP(j,v) mx = max(mx, pmat[i][j]);\n  if (mx < k) {\n    cout << -1 << endl;\n    return 0;\n  } \n  cout << hi << endl;\n  if (hi > 100) {\n    return 0;\n  }\n  vector<Matrix> vmat;\n  Matrix m(v, Array(v, -INF));\n  REP(i,v) m[i][i] = 0;\n  REP(i,hi) {\n    vmat.push_back(m);\n    m = mul(mat, m);\n  }\n  int s=0,t=0;\n  REP(i,v)REP(j,v) {\n    if (pmat[i][j] == mx) {\n      s = i;\n      t = j;\n    }\n  }\n  vector<int> res;\n  res.push_back(t);\n  for (int i = hi-1; i >= 0; --i) {\n    int nt=0;\n    int64_t nmx=0;\n    REP(j,v) {\n      if (vmat[i][s][j] + mat[j][t] == mx) {\n        nt = j;\n        nmx = vmat[i][s][j];\n      }\n    }\n    t = nt;\n    mx = nmx;\n    res.push_back(t);\n  }\n  reverse(ALL(res));\n  REP(i,res.size()) {\n    if (i) cout << ' ';\n    cout << res[i];\n  }\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing matrix = vector<vector<ll>>;\n\nconst ll INF = 1e9;\n\nmatrix prod(const matrix& a, const matrix& b){\n\tint n = a.size();\n\tmatrix res(n, vector<ll>(n, -INF));\n\tfor(int i = 0;i < n;i++){\n\t\tfor(int j = 0;j < n;j++){\n\t\t\tfor(int k = 0;k < n;k++){\n\t\t\t\tres[i][k] = max(res[i][k], a[i][j] + b[j][k]);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nmatrix power(matrix a, int x){\n\tint n = a.size();\n\tmatrix res(n, vector<ll>(n, -INF));\n\tfor(int i = 0;i < n;i++) res[i][i] = 0;\n\twhile(x){\n\t\tif(x & 1) res = prod(a, res);\n\t\ta = prod(a, a);\n\t\tx >>= 1;\n\t}\n\treturn res;\n}\n\nint main() {\n\tint V, E, K;\n\tcin >> V >> E >> K;\n\tmatrix G(V, vector<ll>(V, -INF));\n\tfor(int i = 0;i < V;i++) G[i][i] = 0;\n\tfor(int i = 0;i < E;i++){\n\t\tint u, v;\n\t\tll c;\n\t\tcin >> u >> v >> c;\n\t\tG[u][v] = max(G[u][v], c);\n\t}\n\tint lb = 0, ub = K + 1;\n\twhile(ub - lb > 1){\n\t\tint m = (lb + ub) >> 1;\n\t\tauto v = power(G, m);\n\t\tll ma = 0;\n\t\tfor(int i = 0;i < V;i++) ma = max(ma, *max_element(v[i].begin(), v[i].end()));\n\t\tif(ma >= K){\n\t\t\tub = m;\n\t\t}\n\t\telse{\n\t\t\tlb = m;\n\t\t}\n\t}\n\tif(ub == K + 1){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tcout << ub << endl;\n\tif(ub > 100) return 0;\n\tvector<vector<ll>> dp(ub + 1, vector<ll>(V, -INF));\n\tfor(int i = 0;i < V;i++) dp[0][i] = 0;\n\tfor(int x = 0;x < ub;x++){\n\t\tfor(int i = 0;i < V;i++){\n\t\t\tfor(int j = 0;j < V;j++){\n\t\t\t\tdp[x + 1][j] = max(dp[x + 1][j], dp[x][i] + G[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tint pos = 0;\n\tfor(int i = 0;i < V;i++){\n\t\tif(dp[ub][i] > dp[ub][pos]) pos = i;\n\t}\n\tvector<int> res;\n\tres.push_back(pos);\n\tfor(int i = ub;i > 0;i--){\n\t\tfor(int to = 0;to < V;to++){\n\t\t\tif(dp[i - 1][to] + G[to][pos] == dp[i][pos]){\n\t\t\t\tres.push_back(to);\n\t\t\t\tpos = to;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tassert((int)res.size() == ub + 1);\n\treverse(res.begin(), res.end());\n\tfor(int i = 0;i <= ub;i++){\n\t\tcout << res[i] << \" \\n\"[i == ub];\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint V,E,K;\nint W[155][155];\nint dp[155][111];\nint pv[155][111];\nconst int INF = (1<<28);\nbool update(int &a,int b){\n  if( a < b ) {\n    a = b; return true;\n  }\n  return false;\n}\nbool solve1(){\n  for(int st=0;st<100;st++)\n    for(int i=0;i<V;i++)\n      for(int to=0;to<V;to++)\n        if( W[i][to] ) \n          if( update( dp[st+1][to], dp[st][i] + W[i][to] ) )\n            pv[st+1][to] = i;\n      \n  for(int st=1;st<=100;st++){\n    int id = 0;\n    for(int v=0;v<V;v++)\n      if( dp[st][id] < dp[st][v] ) id = v;\n    if( dp[st][id] >= K ) {\n\n      int cst = st, cv = id;\n      cout << st << endl;\n      vector<int> res;\n      while( cst > 0 ) {\n        res.emplace_back( cv );\n        cv = pv[cst][cv];\n        cst--;\n      }\n      res.emplace_back( cv );\n      reverse( res.begin(), res.end() );\n      for( int i = 0; i < res.size(); i++ ){\n        if( i )  cout << \" \" ;\n        cout << res[i];\n      }\n      cout << endl;\n      return true;\n    }\n  }\n  return false;  \n}\n\n\n\nvector<vector<int>> M;\nvector<vector<int>> calc( const vector<vector<int>>& a, const vector<vector<int>>& b ) {\n  vector<vector<int>> c(V,vector<int>(V,-INF));\n  for(int i=0;i<V;i++)\n    for(int j=0;j<V;j++)\n      for(int k=0;k<V;k++)\n        update( c[i][j], a[i][k] + b[k][j] );      \n  return c;  \n}\n\n\nvoid view(vector<vector<int>> mat){\n  cout << \"view\" << endl;\n  for(int i=0;i<V;i++) {\n    for(int j=0;j<V;j++) cout << mat[i][j] << \" \";\n    cout << endl;\n  }\n}\nint check(int h){\n  vector<vector<int>> A(V,vector<int>(V,-INF));\n  for(int i=0;i<V;i++)\n    A[i][i] = 0;\n  vector<vector<int>> X = M;\n  while(h){\n    if( h&1 ) \n      A = calc( A, X );\n    X = calc( X, X );\n    h >>= 1;\n  }\n  bool pf = false;\n  for(int i=0;i<V;i++)\n    for(int j=0;j<V;j++)\n      if( A[i][j] >= K ){\n        return 1;\n      } else if( A[i][j]>0 )\n        pf = true;\n  if( pf ) return 0;\n  return 2;\n}\n\nint solve2(){\n  M = vector<vector<int>>(V,vector<int>(V));  \n  for(int i=0;i<V;i++)\n    for(int j=0;j<V;j++)\n      if( W[i][j] )\n        M[i][j] = W[i][j];\n      else\n        M[i][j] = -INF;\n\n\n\n  int st = 1, ed = 1000001;\n  int res = ed;\n  \n  while( st <= ed ){\n    int h = (st+ed)/2;\n    int tf = check(h);\n    if( tf ) {\n      if( tf == 1 ) res = h;\n      ed = h-1;\n    } else\n      st = h+1;\n  }\n  if( res > K ) {\n    cout << -1 << endl;\n  } else {\n    cout << res << endl;\n  }\n}\n\nint main(){\n  cin >> V >> E >> K;\n  for(int i=0;i<E;i++){\n    int a,b,c; cin >> a >> b >> c;\n    W[a][b] = max( W[a][b], c );\n  }\n  if( solve1() ) return 0;\n  solve2();  \n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n\nusing vint = vector<int>;\n\nconst int inf = 1LL<<55;\n\nint V, E, K;\nvector<vint> A;\n\nvector<vint> calc(int m) {\n  //cout<<m<<endl;\n  vector<vint> B = A;\n  vector<vint> res(V, vint(V, -inf));\n  for(int i = 0; i < V; ++i) res[i][i] = 0;\n  while(m > 0) {\n    if(m&1) {\n      vector<vint> tmp(V, vint(V, -inf));\n      for(int i = 0; i < V; ++i) tmp[i][i] = 0;      \n      for(int k = 0; k < V; ++k) {\t\n\tfor(int i = 0; i < V; ++i) {\n\t  for(int j = 0; j < V; ++j) {\n\t    tmp[i][j] = max(tmp[i][j], res[i][k]+B[k][j]);\n\t  }\n\t}\n      }\n      res = tmp;\n    }\n    vector<vint> tmp(V, vint(V, -inf));\n    for(int i = 0; i < V; ++i) tmp[i][i] = 0;\n    for(int k = 0; k < V; ++k) {\n      for(int i = 0; i < V; ++i) {\n\tfor(int j = 0; j < V; ++j) {\n\t  tmp[i][j] = max(tmp[i][j], B[i][k]+B[k][j]);\n\t}\n      }\n    }\n    B = tmp;    \n    m >>= 1;\n  }\n  /*\n  for(int i = 0; i < V; ++i) {\n    for(int j = 0; j < V; ++j) cout << res[i][j] << \" \\n\"[j==V-1];\n  }\n  /*/\n  return res;\n}\n\n\nint check(int m) {\n  vector<vint> B = calc(m);\n  int res = 0;\n  for(int i = 0; i < V; ++i) {\n    for(int j = 0; j < V; ++j) {\n      res = max(res, B[i][j]);\n    }\n  }\n  return res;\n}\n\nsigned main() {\n  cin >> V >> E >> K;\n  A.resize(V, vint(V, -inf));\n  for(int i = 0; i < V; ++i) A[i][i] = 0;\n  for(int i = 0; i < E; ++i) {\n    int u, v, c;\n    cin >> u >> v >> c;\n    A[u][v] = max(A[u][v], c);\n  }\n  /*\n  for(int i = 0; i < V; ++i) {\n    for(int j = 0; j < V; ++j) cout << A[i][j] << \" \\n\"[j==V-1];\n  } \n  /*/ \n  int lb = 0, ub = 1111111;\n  while(lb+1 < ub) {\n    int mb = (lb+ub)/2;\n    if(check(mb) >= K) ub = mb;\n    else lb = mb;\n  }\n  if(ub == 1111111) {\n    cout << -1 << endl;\n    return 0;\n  }\n  cout << ub << endl;  \n  int ans = check(ub);\n  //cout << ans << endl;\n  //cout<<check(34)<<endl;\n  if(ub <= 100) {\n    vector<vint> rev(ub+1, vint(V, -1));\n    vector<vint> B(V, vint(V, -inf));\n    for(int i = 0; i < V; ++i) B[i][i] = 0;\n    for(int l = 0; l < ub; ++l) {\n      vector<vint> tmp(V, vint(V, -inf));\n      for(int i = 0; i < V; ++i) tmp[i][i] = 0;\n      for(int k = 0; k < V; ++k) {      \n\tfor(int i = 0; i < V; ++i) {\n\t  for(int j = 0; j < V; ++j) {\n\t    if(tmp[i][j] < B[i][k]+A[k][j]) {\n\t      tmp[i][j] = B[i][k]+A[k][j];\n\t      rev[l+1][j] = k;\n\t    }\n\t  }\n\t}\n      }\n      B = tmp;\n    }\n    int idx = -1;\n    for(int i = 0; i < V && idx == -1; ++i) {\n      for(int j = 0; j < V && idx == -1; ++j) {\n\tif(ans == B[i][j]) idx = j;\n      }\n    }\n    vint vec;\n    for(int l = ub; l > 0; --l) {\n      vec.push_back(idx);\n      idx = rev[l][idx];\n    }\n    reverse(vec.begin(), vec.end());\n    for(int i = 0; i < (int)vec.size(); ++i) cout << vec[i] << \" \\n\"[i==(int)vec.size()-1];\n  }\n\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\tint V = ni();\n\t\tint E = ni();\n\t\tint K = ni();\n\n\t\tArrayList<Edge>[] g = new ArrayList[V];\n\t\tfor (int i = 0; i < V; ++i)\n\t\t\tg[i] = new ArrayList<>();\n\n\t\tfor (int i = 0; i < E; ++i) {\n\t\t\tint src = ni();\n\t\t\tint dst = ni();\n\t\t\tint c = ni();\n\t\t\tg[src].add(new Edge(src, dst, c));\n\t\t}\n\n\t\tint[][][] score = new int[20][V][V];\n\n\t\tfor (ArrayList<Edge> lis : g) {\n\t\t\tfor (Edge e : lis) {\n\t\t\t\tscore[0][e.src][e.dst] = Math.max(score[0][e.src][e.dst], e.c);\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 1; i < 20; ++i) {\n\t\t\tfor (int from = 0; from < V; ++from) {\n\t\t\t\tfor (int to = 0; to < V; ++to) {\n\t\t\t\t\tfor (int med = 0; med < V; ++med) {\n\t\t\t\t\t\tif (score[i - 1][from][med] != 0 && score[i - 1][med][to] != 0)\n\t\t\t\t\t\t\tscore[i][from][to] = Math.max(score[i][from][to],\n\t\t\t\t\t\t\t\t\tscore[i - 1][from][med] + score[i - 1][med][to]);\n\t\t\t\t\t\tscore[i][from][to] = Math.max(score[i][from][to], score[0][from][to]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// 150*20*150=\n\t\tint[] cur = new int[V];\n\t\tint sum = 0;\n\t\tboolean ok = false;\n\n\t\touter: for (int i = 19; i >= 0; --i) {\n\t\t\tfor (int dst = 0; dst < V; ++dst) {\n\t\t\t\tfor (int med = 0; med < V; ++med) {\n\t\t\t\t\tif (cur[med] + score[i][med][dst] >= K) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint[] next = new int[V];\n\t\t\tfor (int dst = 0; dst < V; ++dst) {\n\t\t\t\tfor (int med = 0; med < V; ++med) {\n\t\t\t\t\tif (score[i][med][dst] != 0)\n\t\t\t\t\t\tnext[dst] = Math.max(next[dst], cur[med] + score[i][med][dst]);\n\t\t\t\t}\n\t\t\t\tnext[dst]=Math.max(next[dst], cur[dst]);\n\t\t\t}\n\n\t\t\tcur = Arrays.copyOf(next, V);\n\t\t\tsum += 1 << i;\n\t\t}\n\n\t\tif (ok) {\n\t\t\tout.println(++sum);\n\t\t\tif (sum <= 100) {\n\n\t\t\t\tint[][] track = new int[sum][V];\n\t\t\t\tint[][] max = new int[sum][V];\n\n\t\t\t\tfor (int i = 0; i < sum; i++) {\n\t\t\t\t\tfor (ArrayList<Edge> lis : g) {\n\t\t\t\t\t\tfor (Edge e : lis) {\n\n\t\t\t\t\t\t\tint nc = e.c;\n\t\t\t\t\t\t\tif (i != 0) {\n\t\t\t\t\t\t\t\tif (max[i - 1][e.src] == 0)\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\tnc += max[i - 1][e.src];\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (max[i][e.dst] < nc) {\n\t\t\t\t\t\t\t\ttrack[i][e.dst] = e.src;\n\t\t\t\t\t\t\t\tmax[i][e.dst] = nc;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tint m = 0;\n\t\t\t\tint v = -1;\n\t\t\t\tfor (int i = 0; i < V; ++i) {\n\t\t\t\t\tif (max[sum - 1][i] > m) {\n\t\t\t\t\t\tm = max[sum - 1][i];\n\t\t\t\t\t\tv = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tArrayDeque<Integer> stack = new ArrayDeque<>();\n\t\t\t\tstack.addFirst(v);\n\t\t\t\tfor (int i = sum - 1; i >= 0; --i) {\n\t\t\t\t\tstack.addFirst(track[i][v]);\n\t\t\t\t\tv = track[i][v];\n\t\t\t\t}\n\n\t\t\t\tfor (int i = 0; i <= sum; i++) {\n\t\t\t\t\tout.print(stack.pollFirst() + (i != sum ? \" \" : \"\\n\"));\n\t\t\t\t}\n\t\t\t}\n\t\t} else\n\t\t\tout.println(-1);\n\t}\n\n\tclass Edge {\n\t\tint src;\n\t\tint dst;\n\t\tint c;\n\n\t\tpublic Edge(int src, int dst, int c) {\n\t\t\tthis.src = src;\n\t\t\tthis.dst = dst;\n\t\t\tthis.c = c;\n\t\t}\n\n\t}\n\n\tvoid run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolver();\n\t\tout.flush();\n\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\tint V = ni();\n\t\tint E = ni();\n\t\tint K = ni();\n\n\t\tArrayList<Edge>[] g = new ArrayList[V];\n\t\tfor (int i = 0; i < V; ++i)\n\t\t\tg[i] = new ArrayList<>();\n\n\t\tfor (int i = 0; i < E; ++i) {\n\t\t\tint src = ni();\n\t\t\tint dst = ni();\n\t\t\tint c = ni();\n\t\t\tg[src].add(new Edge(src, dst, c));\n\t\t}\n\n\t\tint[][][] score = new int[20][V][V];\n\n\t\tfor (ArrayList<Edge> lis : g) {\n\t\t\tfor (Edge e : lis) {\n\t\t\t\tscore[0][e.src][e.dst] = Math.max(score[0][e.src][e.dst], e.c);\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 1; i < 20; ++i) {\n\t\t\tfor (int from = 0; from < V; ++from) {\n\t\t\t\tfor (int to = 0; to < V; ++to) {\n\t\t\t\t\tfor (int med = 0; med < V; ++med) {\n\t\t\t\t\t\tif (score[i - 1][from][med] != 0 && score[i - 1][med][to] != 0)\n\t\t\t\t\t\t\tscore[i][from][to] = Math.max(score[i][from][to],\n\t\t\t\t\t\t\t\t\tscore[i - 1][from][med] + score[i - 1][med][to]);\n\t\t\t\t\t\tscore[i][from][to] = Math.max(score[i][from][to], score[0][from][to]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// 150*20*150=\n\t\tint[] cur = new int[V];\n\t\tint sum = 0;\n\t\tboolean ok = false;\n\n\t\touter: for (int i = 19; i >= 0; --i) {\n\t\t\tfor (int dst = 0; dst < V; ++dst) {\n\t\t\t\tfor (int med = 0; med < V; ++med) {\n\t\t\t\t\tif (cur[med] + score[i][med][dst] >= K) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint[] next = new int[V];\n\t\t\tfor (int dst = 0; dst < V; ++dst) {\n\t\t\t\tfor (int med = 0; med < V; ++med) {\n\t\t\t\t\tif (score[i][med][dst] != 0)\n\t\t\t\t\t\tnext[dst] = Math.max(next[dst], cur[med] + score[i][med][dst]);\n\t\t\t\t}\n\t\t\t\tnext[dst]=Math.max(next[dst], cur[dst]);\n\t\t\t}\n\n\t\t\tcur = Arrays.copyOf(next, V);\n\t\t\tsum += 1 << i;\n\t\t}\n\n\t\tif (ok) {\n\t\t\tout.println(++sum);\n\t\t\tif (sum <= 100) {\n\n\t\t\t\tint[][] track = new int[sum][V];\n\t\t\t\tint[][] max = new int[sum][V];\n\n\t\t\t\tfor (int i = 0; i < sum; i++) {\n\t\t\t\t\tfor (ArrayList<Edge> lis : g) {\n\t\t\t\t\t\tfor (Edge e : lis) {\n\n\t\t\t\t\t\t\tint nc = e.c;\n\t\t\t\t\t\t\tif (i != 0) {\n\t\t\t\t\t\t\t\tif (max[i - 1][e.src] == 0)\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\tnc += max[i - 1][e.src];\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (max[i][e.dst] < nc) {\n\t\t\t\t\t\t\t\ttrack[i][e.dst] = e.src;\n\t\t\t\t\t\t\t\tmax[i][e.dst] = nc;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tint m = 0;\n\t\t\t\tint v = -1;\n\t\t\t\tfor (int i = 0; i < V; ++i) {\n\t\t\t\t\tif (max[sum - 1][i] > m) {\n\t\t\t\t\t\tm = max[sum - 1][i];\n\t\t\t\t\t\tv = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tArrayDeque<Integer> stack = new ArrayDeque<>();\n\t\t\t\tstack.addFirst(v);\n\t\t\t\tfor (int i = sum - 1; i >= 0; --i) {\n\t\t\t\t\tstack.addFirst(track[i][v]);\n\t\t\t\t\tv = track[i][v];\n\t\t\t\t}\n\n\t\t\t\tfor (int i = 0; i <= sum; i++) {\n\t\t\t\t\tout.print(stack.pollFirst() + (i != sum ? \" \" : \"\\n\"));\n\t\t\t\t}\n\t\t\t}\n\t\t} else\n\t\t\tout.println(-1);\n\t}\n\n\tclass Edge {\n\t\tint src;\n\t\tint dst;\n\t\tint c;\n\n\t\tpublic Edge(int src, int dst, int c) {\n\t\t\tthis.src = src;\n\t\t\tthis.dst = dst;\n\t\t\tthis.c = c;\n\t\t}\n\n\t}\n\n\tvoid run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolver();\n\t\tout.flush();\n\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\tint V = ni();\n\t\tint E = ni();\n\t\tint K = ni();\n\n\t\tArrayList<Edge>[] g = new ArrayList[V];\n\t\tfor (int i = 0; i < V; ++i)\n\t\t\tg[i] = new ArrayList<>();\n\n\t\tfor (int i = 0; i < E; ++i) {\n\t\t\tint src = ni();\n\t\t\tint dst = ni();\n\t\t\tint c = ni();\n\t\t\tg[src].add(new Edge(src, dst, c));\n\t\t}\n\n\t\tint[][][] score = new int[20][V][V];\n\n\t\tfor (ArrayList<Edge> lis : g) {\n\t\t\tfor (Edge e : lis) {\n\t\t\t\tscore[0][e.src][e.dst] = Math.max(score[0][e.src][e.dst], e.c);\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 1; i < 20; ++i) {\n\t\t\tfor (int from = 0; from < V; ++from) {\n\t\t\t\tfor (int to = 0; to < V; ++to) {\n\t\t\t\t\tfor (int med = 0; med < V; ++med) {\n\t\t\t\t\t\tif (score[i - 1][from][med] != 0 && score[i - 1][med][to] != 0)\n\t\t\t\t\t\t\tscore[i][from][to] = Math.max(score[i][from][to],\n\t\t\t\t\t\t\t\t\tscore[i - 1][from][med] + score[i - 1][med][to]);\n\t\t\t\t\t\tscore[i][from][to] = Math.max(score[i][from][to], score[0][from][to]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// 150*20*150=\n\t\tint[] cur = new int[V];\n\t\tint sum = 0;\n\t\tboolean ok = false;\n\n\t\touter: for (int i = 19; i >= 0; --i) {\n\t\t\tfor (int dst = 0; dst < V; ++dst) {\n\t\t\t\tfor (int med = 0; med < V; ++med) {\n\t\t\t\t\tif (cur[med] + score[i][med][dst] >= K) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint[] next = new int[V];\n\t\t\tfor (int dst = 0; dst < V; ++dst) {\n\t\t\t\tfor (int med = 0; med < V; ++med) {\n\t\t\t\t\tif (score[i][med][dst] != 0)\n\t\t\t\t\t\tnext[dst] = Math.max(next[dst], cur[med] + score[i][med][dst]);\n\t\t\t\t}\n\t\t\t\tnext[dst]=Math.max(next[dst], cur[dst]);\n\t\t\t}\n\n\t\t\tcur = Arrays.copyOf(next, V);\n\t\t\tsum += 1 << i;\n\t\t}\n\n\t\tif (ok) {\n\t\t\tout.println(++sum);\n\t\t\tif (sum <= 100) {\n\n\t\t\t\tint[][] track = new int[sum][V];\n\t\t\t\tint[][] max = new int[sum][V];\n\n\t\t\t\tfor (int i = 0; i < sum; i++) {\n\t\t\t\t\tfor (ArrayList<Edge> lis : g) {\n\t\t\t\t\t\tfor (Edge e : lis) {\n\n\t\t\t\t\t\t\tint nc = e.c;\n\t\t\t\t\t\t\tif (i != 0) {\n\t\t\t\t\t\t\t\tif (max[i - 1][e.src] == 0)\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\tnc += max[i - 1][e.src];\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (max[i][e.dst] < nc) {\n\t\t\t\t\t\t\t\ttrack[i][e.dst] = e.src;\n\t\t\t\t\t\t\t\tmax[i][e.dst] = nc;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tint m = 0;\n\t\t\t\tint v = -1;\n\t\t\t\tfor (int i = 0; i < V; ++i) {\n\t\t\t\t\tif (max[sum - 1][i] > m) {\n\t\t\t\t\t\tm = max[sum - 1][i];\n\t\t\t\t\t\tv = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tArrayDeque<Integer> stack = new ArrayDeque<>();\n\t\t\t\tstack.addFirst(v);\n\t\t\t\tfor (int i = sum - 1; i >= 0; --i) {\n\t\t\t\t\tstack.addFirst(track[i][v]);\n\t\t\t\t\tv = track[i][v];\n\t\t\t\t}\n\n\t\t\t\tfor (int i = 0; i <= sum; i++) {\n\t\t\t\t\tout.print(stack.pollFirst() + (i != sum ? \" \" : \"\\n\"));\n\t\t\t\t}\n\t\t\t}\n\t\t} else\n\t\t\tout.println(-1);\n\t}\n\n\tclass Edge {\n\t\tint src;\n\t\tint dst;\n\t\tint c;\n\n\t\tpublic Edge(int src, int dst, int c) {\n\t\t\tthis.src = src;\n\t\t\tthis.dst = dst;\n\t\t\tthis.c = c;\n\t\t}\n\n\t}\n\n\tvoid run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolver();\n\t\tout.flush();\n\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\tint V = ni();\n\t\tint E = ni();\n\t\tint K = ni();\n\n\t\tArrayList<Edge>[] g = new ArrayList[V];\n\t\tfor (int i = 0; i < V; ++i)\n\t\t\tg[i] = new ArrayList<>();\n\n\t\tfor (int i = 0; i < E; ++i) {\n\t\t\tint src = ni();\n\t\t\tint dst = ni();\n\t\t\tint c = ni();\n\t\t\tg[src].add(new Edge(src, dst, c));\n\t\t}\n\n\t\tint[][][] score = new int[20][V][V];\n\n\t\tfor (ArrayList<Edge> lis : g) {\n\t\t\tfor (Edge e : lis) {\n\t\t\t\tscore[0][e.src][e.dst] = Math.max(score[0][e.src][e.dst], e.c);\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 1; i < 20; ++i) {\n\t\t\tfor (int from = 0; from < V; ++from) {\n\t\t\t\tfor (int to = 0; to < V; ++to) {\n\t\t\t\t\tfor (int med = 0; med < V; ++med) {\n\t\t\t\t\t\tif (score[i - 1][from][med] != 0 && score[i - 1][med][to] != 0)\n\t\t\t\t\t\t\tscore[i][from][to] = Math.max(score[i][from][to],\n\t\t\t\t\t\t\t\t\tscore[i - 1][from][med] + score[i - 1][med][to]);\n\t\t\t\t\t\tscore[i][from][to] = Math.max(score[i][from][to], score[0][from][to]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// 150*20*150=\n\t\tint[] cur = new int[V];\n\t\tint sum = 0;\n\t\tboolean ok = false;\n\n\t\touter: for (int i = 19; i >= 0; --i) {\n\t\t\tfor (int dst = 0; dst < V; ++dst) {\n\t\t\t\tfor (int med = 0; med < V; ++med) {\n\t\t\t\t\tif (cur[med] + score[i][med][dst] >= K) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint[] next = new int[V];\n\t\t\tfor (int dst = 0; dst < V; ++dst) {\n\t\t\t\tfor (int med = 0; med < V; ++med) {\n\t\t\t\t\tif (score[i][med][dst] != 0)\n\t\t\t\t\t\tnext[dst] = Math.max(next[dst], cur[med] + score[i][med][dst]);\n\t\t\t\t}\n\t\t\t\tnext[dst]=Math.max(next[dst], cur[dst]);\n\t\t\t}\n\n\t\t\tcur = Arrays.copyOf(next, V);\n\t\t\tsum += 1 << i;\n\t\t}\n\n\t\tif (ok) {\n\t\t\tout.println(++sum);\n\t\t\tif (sum <= 100) {\n\n\t\t\t\tint[][] track = new int[sum][V];\n\t\t\t\tint[][] max = new int[sum][V];\n\n\t\t\t\tfor (int i = 0; i < sum; i++) {\n\t\t\t\t\tfor (ArrayList<Edge> lis : g) {\n\t\t\t\t\t\tfor (Edge e : lis) {\n\n\t\t\t\t\t\t\tint nc = e.c;\n\t\t\t\t\t\t\tif (i != 0) {\n\t\t\t\t\t\t\t\tif (max[i - 1][e.src] == 0)\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\tnc += max[i - 1][e.src];\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (max[i][e.dst] < nc) {\n\t\t\t\t\t\t\t\ttrack[i][e.dst] = e.src;\n\t\t\t\t\t\t\t\tmax[i][e.dst] = nc;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tint m = 0;\n\t\t\t\tint v = -1;\n\t\t\t\tfor (int i = 0; i < V; ++i) {\n\t\t\t\t\tif (max[sum - 1][i] > m) {\n\t\t\t\t\t\tm = max[sum - 1][i];\n\t\t\t\t\t\tv = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tArrayDeque<Integer> stack = new ArrayDeque<>();\n\t\t\t\tstack.addFirst(v);\n\t\t\t\tfor (int i = sum - 1; i >= 0; --i) {\n\t\t\t\t\tstack.addFirst(track[i][v]);\n\t\t\t\t\tv = track[i][v];\n\t\t\t\t}\n\n\t\t\t\tfor (int i = 0; i <= sum; i++) {\n\t\t\t\t\tout.print(stack.pollFirst() + (i != sum ? \" \" : \"\\n\"));\n\t\t\t\t}\n\t\t\t}\n\t\t} else\n\t\t\tout.println(-1);\n\t}\n\n\tclass Edge {\n\t\tint src;\n\t\tint dst;\n\t\tint c;\n\n\t\tpublic Edge(int src, int dst, int c) {\n\t\t\tthis.src = src;\n\t\t\tthis.dst = dst;\n\t\t\tthis.c = c;\n\t\t}\n\n\t}\n\n\tvoid run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolver();\n\t\tout.flush();\n\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\tint V = ni();\n\t\tint E = ni();\n\t\tint K = ni();\n\n\t\tArrayList<Edge>[] g = new ArrayList[V];\n\t\tfor (int i = 0; i < V; ++i)\n\t\t\tg[i] = new ArrayList<>();\n\n\t\tfor (int i = 0; i < E; ++i) {\n\t\t\tint src = ni();\n\t\t\tint dst = ni();\n\t\t\tint c = ni();\n\t\t\tg[src].add(new Edge(src, dst, c));\n\t\t}\n\n\t\tint[][][] score = new int[20][V][V];\n\n\t\tfor (ArrayList<Edge> lis : g) {\n\t\t\tfor (Edge e : lis) {\n\t\t\t\tscore[0][e.src][e.dst] = Math.max(score[0][e.src][e.dst], e.c);\n\t\t\t}\n\t\t}\n\n\t\t// 21*150*150*150=7*10^7\n\t\tfor (int i = 1; i < 20; ++i) {\n\t\t\tfor (int from = 0; from < V; ++from) {\n\t\t\t\tfor (int to = 0; to < V; ++to) {\n\t\t\t\t\tfor (int med = 0; med < V; ++med) {\n\t\t\t\t\t\tif (score[i - 1][from][med] == 0 || score[i - 1][med][to] == 0)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tscore[i][from][to] = Math.max(score[i][from][to],\n\t\t\t\t\t\t\t\tscore[i - 1][from][med] + score[i - 1][med][to]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// 150*20*150=\n\t\tint ans = (1 << 30);\n\n\t\tint[] cur = new int[V];\n\t\tint sum = 0;\n\t\tboolean ok = false;\n\n\t\touter: for (int i = 19; i >= 0; --i) {\n\t\t\tfor (int dst = 0; dst < V; ++dst) {\n\t\t\t\tfor (int med = 0; med < V; ++med) {\n\t\t\t\t\tif (score[i][med][dst] == 0 || (sum != 0 && cur[med] == 0))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (cur[med] + score[i][med][dst] >= K) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint[] next = new int[V];\n\t\t\tfor (int dst = 0; dst < V; ++dst) {\n\t\t\t\tfor (int med = 0; med < V; ++med) {\n\t\t\t\t\tif (score[i][med][dst] == 0 || (sum != 0 && cur[med] == 0))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tnext[dst] = Math.max(next[dst], cur[med] + score[i][med][dst]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcur = Arrays.copyOf(next, V);\n\n\t\t\tsum += 1 << i;\n\t\t}\n\n\n\t\tif (ok) {\n\t\t\tans=Math.min(ans,sum);\n\t\t\tSystem.out.println(++ans);\n\t\t\tif (ans <= 100) {\n\n\t\t\t\tint[][] track = new int[ans][V];\n\t\t\t\tint[][] max = new int[ans][V];\n\t\t\t\tfor (int i = 0; i < ans; i++) {\n\t\t\t\t\tfor (ArrayList<Edge> lis : g) {\n\t\t\t\t\t\tfor (Edge e : lis) {\n\n\t\t\t\t\t\t\tint nc = e.c;\n\t\t\t\t\t\t\tif (i != 0) {\n\t\t\t\t\t\t\t\tif (max[i - 1][e.src] == 0)\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\tnc += max[i - 1][e.src];\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (max[i][e.dst] < nc) {\n\t\t\t\t\t\t\t\ttrack[i][e.dst] = e.src;\n\t\t\t\t\t\t\t\tmax[i][e.dst] = nc;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tint m = 0;\n\t\t\t\tint v = -1;\n\t\t\t\tfor (int i = 0; i < V; ++i) {\n\t\t\t\t\tif (max[ans - 1][i] > m) {\n\t\t\t\t\t\tm = max[ans - 1][i];\n\t\t\t\t\t\tv = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tArrayDeque<Integer> stack = new ArrayDeque<>();\n\t\t\t\tstack.addFirst(v);\n\t\t\t\tfor (int i = ans - 1; i >= 0; --i) {\n\t\t\t\t\tstack.addFirst(track[i][v]);\n\t\t\t\t\tv = track[i][v];\n\t\t\t\t}\n\n\t\t\t\tfor (int i = 0; i <= ans; i++) {\n\t\t\t\t\tSystem.out.print(stack.pollFirst() + (i != ans ? \" \" : \"\\n\"));\n\t\t\t\t}\n\t\t\t}\n\t\t} else\n\t\t\tSystem.out.println(-1);\n\t}\n\n\tclass Edge {\n\t\tint src;\n\t\tint dst;\n\t\tint c;\n\n\t\tpublic Edge(int src, int dst, int c) {\n\t\t\tthis.src = src;\n\t\t\tthis.dst = dst;\n\t\t\tthis.c = c;\n\t\t}\n\n\t}\n\n\tvoid run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolver();\n\t\tout.flush();\n\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\tint V = ni();\n\t\tint E = ni();\n\t\tint K = ni();\n\n\t\tArrayList<Edge>[] g = new ArrayList[V];\n\t\tfor (int i = 0; i < V; ++i)\n\t\t\tg[i] = new ArrayList<>();\n\n\t\tfor (int i = 0; i < E; ++i) {\n\t\t\tint src = ni();\n\t\t\tint dst = ni();\n\t\t\tint c = ni();\n\t\t\tg[src].add(new Edge(src, dst, c));\n\t\t}\n\n\t\tint[][][] score = new int[20][V][V];\n\n\t\tfor (ArrayList<Edge> lis : g) {\n\t\t\tfor (Edge e : lis) {\n\t\t\t\tscore[0][e.src][e.dst] = Math.max(score[0][e.src][e.dst], e.c);\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 1; i < 20; ++i) {\n\t\t\tfor (int from = 0; from < V; ++from) {\n\t\t\t\tfor (int to = 0; to < V; ++to) {\n\t\t\t\t\tfor (int med = 0; med < V; ++med) {\n\t\t\t\t\t\tif (score[i - 1][from][med] != 0 && score[i - 1][med][to] != 0)\n\t\t\t\t\t\t\tscore[i][from][to] = Math.max(score[i][from][to],\n\t\t\t\t\t\t\t\t\tscore[i - 1][from][med] + score[i - 1][med][to]);\n\t\t\t\t\t\tscore[i][from][to] = Math.max(score[i][from][to], score[0][from][to]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint[] cur = new int[V];\n\t\tint sum = 0;\n\t\tboolean ok = false;\n\n\t\touter: for (int i = 19; i >= 0; --i) {\n\t\t\tfor (int dst = 0; dst < V; ++dst) {\n\t\t\t\tfor (int med = 0; med < V; ++med) {\n\t\t\t\t\tif (cur[med] + score[i][med][dst] >= K) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint[] next = new int[V];\n\t\t\tfor (int dst = 0; dst < V; ++dst) {\n\t\t\t\tfor (int med = 0; med < V; ++med) {\n\t\t\t\t\tif (score[i][med][dst] != 0)\n\t\t\t\t\t\tnext[dst] = Math.max(next[dst], cur[med] + score[i][med][dst]);\n\t\t\t\t}\n\t\t\t\tnext[dst]=Math.max(next[dst], cur[dst]);\n\t\t\t}\n\n\t\t\tcur = Arrays.copyOf(next, V);\n\t\t\tsum += 1 << i;\n\t\t}\n\n\t\tif (ok) {\n\t\t\tout.println(++sum);\n\t\t\tif (sum <= 100) {\n\n\t\t\t\tint[][] track = new int[sum][V];\n\t\t\t\tint[][] max = new int[sum][V];\n\n\t\t\t\tfor (int i = 0; i < sum; i++) {\n\t\t\t\t\tfor (ArrayList<Edge> lis : g) {\n\t\t\t\t\t\tfor (Edge e : lis) {\n\n\t\t\t\t\t\t\tint nc = e.c;\n\t\t\t\t\t\t\tif (i != 0) {\n\t\t\t\t\t\t\t\tif (max[i - 1][e.src] == 0)\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\tnc += max[i - 1][e.src];\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (max[i][e.dst] < nc) {\n\t\t\t\t\t\t\t\ttrack[i][e.dst] = e.src;\n\t\t\t\t\t\t\t\tmax[i][e.dst] = nc;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tint m = 0;\n\t\t\t\tint v = -1;\n\t\t\t\tfor (int i = 0; i < V; ++i) {\n\t\t\t\t\tif (max[sum - 1][i] > m) {\n\t\t\t\t\t\tm = max[sum - 1][i];\n\t\t\t\t\t\tv = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tArrayDeque<Integer> stack = new ArrayDeque<>();\n\t\t\t\tstack.addFirst(v);\n\t\t\t\tfor (int i = sum - 1; i >= 0; --i) {\n\t\t\t\t\tstack.addFirst(track[i][v]);\n\t\t\t\t\tv = track[i][v];\n\t\t\t\t}\n\n\t\t\t\tfor (int i = 0; i <= sum; i++) {\n\t\t\t\t\tout.print(stack.pollFirst() + (i != sum ? \" \" : \"\\n\"));\n\t\t\t\t}\n\t\t\t}\n\t\t} else\n\t\t\tout.println(-1);\n\t}\n\n\tclass Edge {\n\t\tint src;\n\t\tint dst;\n\t\tint c;\n\n\t\tpublic Edge(int src, int dst, int c) {\n\t\t\tthis.src = src;\n\t\t\tthis.dst = dst;\n\t\t\tthis.c = c;\n\t\t}\n\n\t}\n\n\tvoid run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolver();\n\t\tout.flush();\n\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\tint V = ni();\n\t\tint E = ni();\n\t\tint K = ni();\n\n\t\tArrayList<Edge>[] g = new ArrayList[V];\n\t\tfor (int i = 0; i < V; ++i)\n\t\t\tg[i] = new ArrayList<>();\n\n\t\tfor (int i = 0; i < E; ++i) {\n\t\t\tint src = ni();\n\t\t\tint dst = ni();\n\t\t\tint c = ni();\n\t\t\tg[src].add(new Edge(src, dst, c));\n\t\t}\n\n\t\tint[][][] score = new int[20][V][V];\n\n\t\tfor (ArrayList<Edge> lis : g) {\n\t\t\tfor (Edge e : lis) {\n\t\t\t\tscore[0][e.src][e.dst] = Math.max(score[0][e.src][e.dst], e.c);\n\t\t\t}\n\t\t}\n\n\t\t// 21*150*150*150=7*10^7\n\t\tfor (int i = 1; i < 20; ++i) {\n\t\t\tfor (int from = 0; from < V; ++from) {\n\t\t\t\tfor (int to = 0; to < V; ++to) {\n\t\t\t\t\tfor (int med = 0; med < V; ++med) {\n\t\t\t\t\t\tif (score[i - 1][from][med] == 0 || score[i - 1][med][to] == 0)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tscore[i][from][to] = Math.max(score[i][from][to],\n\t\t\t\t\t\t\t\tscore[i - 1][from][med] + score[i - 1][med][to]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// 150*20*150=\n\t\tint ans = (1 << 30);\n\n\t\tint[] cur = new int[V];\n\t\tint sum = 0;\n\t\tboolean ok = false;\n\n\t\touter: for (int i = 19; i >= 0; --i) {\n\t\t\tfor (int dst = 0; dst < V; ++dst) {\n\t\t\t\tfor (int med = 0; med < V; ++med) {\n\t\t\t\t\tif (score[i][med][dst] == 0 || (sum != 0 && cur[med] == 0))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (cur[med] + score[i][med][dst] >= K) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint[] next = new int[V];\n\t\t\tfor (int dst = 0; dst < V; ++dst) {\n\t\t\t\tfor (int med = 0; med < V; ++med) {\n\t\t\t\t\tif (score[i][med][dst] == 0 || (sum != 0 && cur[med] == 0))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tnext[dst] = Math.max(next[dst], cur[med] + score[i][med][dst]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcur = Arrays.copyOf(next, V);\n\n\t\t\tsum += 1 << i;\n\t\t}\n\n\t\tif (ok) {\n\t\t\tans = Math.min(ans, sum);\n\t\t\tSystem.out.println(++ans);\n\t\t\tif (ans <= 100) {\n\n\t\t\t\tint[][] track = new int[ans][V];\n\t\t\t\tint[][] max = new int[ans][V];\n\t\t\t\tfor (int i = 0; i < ans; i++) {\n\t\t\t\t\tfor (ArrayList<Edge> lis : g) {\n\t\t\t\t\t\tfor (Edge e : lis) {\n\n\t\t\t\t\t\t\tint nc = e.c;\n\t\t\t\t\t\t\tif (i != 0) {\n\t\t\t\t\t\t\t\tif (max[i - 1][e.src] == 0)\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\tnc += max[i - 1][e.src];\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (max[i][e.dst] < nc) {\n\t\t\t\t\t\t\t\ttrack[i][e.dst] = e.src;\n\t\t\t\t\t\t\t\tmax[i][e.dst] = nc;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tint m = 0;\n\t\t\t\tint v = -1;\n\t\t\t\tfor (int i = 0; i < V; ++i) {\n\t\t\t\t\tif (max[ans - 1][i] > m) {\n\t\t\t\t\t\tm = max[ans - 1][i];\n\t\t\t\t\t\tv = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tArrayDeque<Integer> stack = new ArrayDeque<>();\n\t\t\t\tstack.addFirst(v);\n\t\t\t\tfor (int i = ans - 1; i >= 0; --i) {\n\t\t\t\t\tstack.addFirst(track[i][v]);\n\t\t\t\t\tv = track[i][v];\n\t\t\t\t}\n\n\t\t\t\tfor (int i = 0; i <= ans; i++) {\n\t\t\t\t\tSystem.out.print(stack.pollFirst() + (i != ans ? \" \" : \"\\n\"));\n\t\t\t\t}\n\t\t\t}\n\t\t} else\n\t\t\tSystem.out.println(-1);\n\t}\n\n\tclass Edge {\n\t\tint src;\n\t\tint dst;\n\t\tint c;\n\n\t\tpublic Edge(int src, int dst, int c) {\n\t\t\tthis.src = src;\n\t\t\tthis.dst = dst;\n\t\t\tthis.c = c;\n\t\t}\n\n\t}\n\n\tvoid run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolver();\n\t\tout.flush();\n\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\tint V = ni();\n\t\tint E = ni();\n\t\tint K = ni();\n\n\t\tArrayList<Edge>[] g = new ArrayList[V];\n\t\tfor (int i = 0; i < V; ++i)\n\t\t\tg[i] = new ArrayList<>();\n\n\t\tfor (int i = 0; i < E; ++i) {\n\t\t\tint src = ni();\n\t\t\tint dst = ni();\n\t\t\tint c = ni();\n\t\t\tg[src].add(new Edge(src, dst, c));\n\t\t}\n\n\t\tint[][][] score = new int[20][V][V];\n\n\t\tfor (ArrayList<Edge> lis : g) {\n\t\t\tfor (Edge e : lis) {\n\t\t\t\tscore[0][e.src][e.dst] = Math.max(score[0][e.src][e.dst], e.c);\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 1; i < 20; ++i) {\n\t\t\tfor (int from = 0; from < V; ++from) {\n\t\t\t\tfor (int to = 0; to < V; ++to) {\n\t\t\t\t\tfor (int med = 0; med < V; ++med) {\n\t\t\t\t\t\tif (score[i - 1][from][med] != 0 && score[i - 1][med][to] != 0)\n\t\t\t\t\t\t\tscore[i][from][to] = Math.max(score[i][from][to],\n\t\t\t\t\t\t\t\t\tscore[i - 1][from][med] + score[i - 1][med][to]);\n\t\t\t\t\t\tscore[i][from][to] = Math.max(score[i][from][to], score[0][from][to]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint[] cur = new int[V];\n\t\tint sum = 0;\n\t\tboolean ok = false;\n\n\t\touter: for (int i = 19; i >= 0; --i) {\n\t\t\tfor (int dst = 0; dst < V; ++dst) {\n\t\t\t\tfor (int med = 0; med < V; ++med) {\n\t\t\t\t\tif (cur[med] + score[i][med][dst] >= K) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint[] next = new int[V];\n\t\t\tfor (int dst = 0; dst < V; ++dst) {\n\t\t\t\tfor (int med = 0; med < V; ++med) {\n\t\t\t\t\tif (score[i][med][dst] != 0)\n\t\t\t\t\t\tnext[dst] = Math.max(next[dst], cur[med] + score[i][med][dst]);\n\t\t\t\t}\n\t\t\t\tnext[dst]=Math.max(next[dst], cur[dst]);\n\t\t\t}\n\n\t\t\tcur = Arrays.copyOf(next, V);\n\t\t\tsum += 1 << i;\n\t\t}\n\n\t\tif (ok) {\n\t\t\tout.println(++sum);\n\t\t\tif (sum <= 100) {\n\n\t\t\t\tint[][] track = new int[sum][V];\n\t\t\t\tint[][] max = new int[sum][V];\n\n\t\t\t\tfor (int i = 0; i < sum; i++) {\n\t\t\t\t\tfor (ArrayList<Edge> lis : g) {\n\t\t\t\t\t\tfor (Edge e : lis) {\n\n\t\t\t\t\t\t\tint nc = e.c;\n\t\t\t\t\t\t\tif (i != 0) {\n\t\t\t\t\t\t\t\tif (max[i - 1][e.src] == 0)\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\tnc += max[i - 1][e.src];\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (max[i][e.dst] < nc) {\n\t\t\t\t\t\t\t\ttrack[i][e.dst] = e.src;\n\t\t\t\t\t\t\t\tmax[i][e.dst] = nc;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tint m = 0;\n\t\t\t\tint v = -1;\n\t\t\t\tfor (int i = 0; i < V; ++i) {\n\t\t\t\t\tif (max[sum - 1][i] > m) {\n\t\t\t\t\t\tm = max[sum - 1][i];\n\t\t\t\t\t\tv = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tArrayDeque<Integer> stack = new ArrayDeque<>();\n\t\t\t\tstack.addFirst(v);\n\t\t\t\tfor (int i = sum - 1; i >= 0; --i) {\n\t\t\t\t\tstack.addFirst(track[i][v]);\n\t\t\t\t\tv = track[i][v];\n\t\t\t\t}\n\n\t\t\t\tfor (int i = 0; i <= sum; i++) {\n\t\t\t\t\tout.print(stack.pollFirst() + (i != sum ? \" \" : \"\\n\"));\n\t\t\t\t}\n\t\t\t}\n\t\t} else\n\t\t\tout.println(-1);\n\t}\n\n\tclass Edge {\n\t\tint src;\n\t\tint dst;\n\t\tint c;\n\n\t\tpublic Edge(int src, int dst, int c) {\n\t\t\tthis.src = src;\n\t\t\tthis.dst = dst;\n\t\t\tthis.c = c;\n\t\t}\n\n\t}\n\n\tvoid run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolver();\n\t\tout.flush();\n\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\tint V = ni();\n\t\tint E = ni();\n\t\tint K = ni();\n\n\t\tArrayList<Edge>[] g = new ArrayList[V];\n\t\tfor (int i = 0; i < V; ++i)\n\t\t\tg[i] = new ArrayList<>();\n\n\t\tfor (int i = 0; i < E; ++i) {\n\t\t\tint src = ni();\n\t\t\tint dst = ni();\n\t\t\tint c = ni();\n\t\t\tg[src].add(new Edge(src, dst, c));\n\t\t}\n\n\t\tint[][][] score = new int[20][V][V];\n\n\t\tfor (ArrayList<Edge> lis : g) {\n\t\t\tfor (Edge e : lis) {\n\t\t\t\tscore[0][e.src][e.dst] = Math.max(score[0][e.src][e.dst], e.c);\n\t\t\t}\n\t\t}\n\n\t\t// 21*150*150*150*21*21=7*10^7\n\t\tfor (int i = 1; i < 20; ++i) {\n\t\t\tfor (int from = 0; from < V; ++from) {\n\t\t\t\tfor (int to = 0; to < V; ++to) {\n\t\t\t\t\tfor (int med = 0; med < V; ++med) {\n\t\t\t\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\t\t\t\tfor (int k = 0; k < i; k++) {\n\t\t\t\t\t\t\t\tif (score[j][from][med] == 0 || score[k][med][to] == 0)\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\tscore[i][from][to] = Math.max(score[i][from][to],\n\t\t\t\t\t\t\t\t\t\tscore[j][from][med] + score[k][med][to]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// 150*20*150=\n\t\tint[] cur = new int[V];\n\t\tint sum = 0;\n\t\tboolean ok = false;\n\n\t\touter: for (int i = 19; i >= 0; --i) {\n\t\t\tfor (int dst = 0; dst < V; ++dst) {\n\t\t\t\tfor (int med = 0; med < V; ++med) {\n\t\t\t\t\tif (cur[med] + score[i][med][dst] >= K) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint[] next = new int[V];\n\t\t\tfor (int dst = 0; dst < V; ++dst) {\n\t\t\t\tfor (int med = 0; med < V; ++med) {\n\t\t\t\t\tnext[dst] = Math.max(next[dst], cur[med] + score[i][med][dst]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcur = Arrays.copyOf(next, V);\n\t\t\tsum += 1 << i;\n\t\t}\n\n\t\tif (ok) {\n\t\t\tSystem.out.println(++sum);\n\t\t\tif (sum <= 100) {\n\n\t\t\t\tint[][] track = new int[sum][V];\n\t\t\t\tint[][] max = new int[sum][V];\n\n\t\t\t\tfor (int i = 0; i < sum; i++) {\n\t\t\t\t\tfor (ArrayList<Edge> lis : g) {\n\t\t\t\t\t\tfor (Edge e : lis) {\n\n\t\t\t\t\t\t\tint nc = e.c;\n\t\t\t\t\t\t\tif (i != 0) {\n\t\t\t\t\t\t\t\tif (max[i - 1][e.src] == 0)\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\tnc += max[i - 1][e.src];\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (max[i][e.dst] < nc) {\n\t\t\t\t\t\t\t\ttrack[i][e.dst] = e.src;\n\t\t\t\t\t\t\t\tmax[i][e.dst] = nc;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tint m = 0;\n\t\t\t\tint v = -1;\n\t\t\t\tfor (int i = 0; i < V; ++i) {\n\t\t\t\t\tif (max[sum - 1][i] > m) {\n\t\t\t\t\t\tm = max[sum - 1][i];\n\t\t\t\t\t\tv = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tArrayDeque<Integer> stack = new ArrayDeque<>();\n\t\t\t\tstack.addFirst(v);\n\t\t\t\tfor (int i = sum - 1; i >= 0; --i) {\n\t\t\t\t\tstack.addFirst(track[i][v]);\n\t\t\t\t\tv = track[i][v];\n\t\t\t\t}\n\n\t\t\t\tfor (int i = 0; i <= sum; i++) {\n\t\t\t\t\tSystem.out.print(stack.pollFirst() + (i != sum ? \" \" : \"\\n\"));\n\t\t\t\t}\n\t\t\t}\n\t\t} else\n\t\t\tSystem.out.println(-1);\n\t}\n\n\tclass Edge {\n\t\tint src;\n\t\tint dst;\n\t\tint c;\n\n\t\tpublic Edge(int src, int dst, int c) {\n\t\t\tthis.src = src;\n\t\t\tthis.dst = dst;\n\t\t\tthis.c = c;\n\t\t}\n\n\t}\n\n\tvoid run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolver();\n\t\tout.flush();\n\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\tint V = ni();\n\t\tint E = ni();\n\t\tint K = ni();\n\n\t\tArrayList<Edge>[] g = new ArrayList[V];\n\t\tfor (int i = 0; i < V; ++i)\n\t\t\tg[i] = new ArrayList<>();\n\n\t\tfor (int i = 0; i < E; ++i) {\n\t\t\tint src = ni();\n\t\t\tint dst = ni();\n\t\t\tint c = ni();\n\t\t\tg[src].add(new Edge(src, dst, c));\n\t\t}\n\n\t\tint[][][] score = new int[20][V][V];\n\n\t\tfor (ArrayList<Edge> lis : g) {\n\t\t\tfor (Edge e : lis) {\n\t\t\t\tscore[0][e.src][e.dst] = Math.max(score[0][e.src][e.dst], e.c);\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 1; i < 20; ++i) {\n\t\t\tfor (int from = 0; from < V; ++from) {\n\t\t\t\tfor (int to = 0; to < V; ++to) {\n\t\t\t\t\tfor (int med = 0; med < V; ++med) {\n\t\t\t\t\t\tif (score[i - 1][from][med] != 0 && score[i - 1][med][to] != 0)\n\t\t\t\t\t\t\tscore[i][from][to] = Math.max(score[i][from][to],\n\t\t\t\t\t\t\t\t\tscore[i - 1][from][med] + score[i - 1][med][to]);\n\t\t\t\t\t\tscore[i][from][to] = Math.max(score[i][from][to], score[0][from][to]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// 150*20*150=\n\t\tint[] cur = new int[V];\n\t\tint sum = 0;\n\t\tboolean ok = false;\n\n\t\touter: for (int i = 19; i >= 0; --i) {\n\t\t\tfor (int dst = 0; dst < V; ++dst) {\n\t\t\t\tfor (int med = 0; med < V; ++med) {\n\t\t\t\t\tif (cur[med] + score[i][med][dst] >= K) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint[] next = new int[V];\n\t\t\tfor (int dst = 0; dst < V; ++dst) {\n\t\t\t\tfor (int med = 0; med < V; ++med) {\n\t\t\t\t\tif (score[i][med][dst] != 0)\n\t\t\t\t\t\tnext[dst] = Math.max(next[dst], cur[med] + score[i][med][dst]);\n\t\t\t\t}\n\t\t\t\tnext[dst]=Math.max(next[dst], cur[dst]);\n\t\t\t}\n\n\t\t\tcur = Arrays.copyOf(next, V);\n\t\t\tsum += 1 << i;\n\t\t}\n\n\t\tif (ok) {\n\t\t\tout.println(++sum);\n\t\t\tif (sum <= 100) {\n\n\t\t\t\tint[][] track = new int[sum][V];\n\t\t\t\tint[][] max = new int[sum][V];\n\n\t\t\t\tfor (int i = 0; i < sum; i++) {\n\t\t\t\t\tfor (ArrayList<Edge> lis : g) {\n\t\t\t\t\t\tfor (Edge e : lis) {\n\n\t\t\t\t\t\t\tint nc = e.c;\n\t\t\t\t\t\t\tif (i != 0) {\n\t\t\t\t\t\t\t\tif (max[i - 1][e.src] == 0)\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\tnc += max[i - 1][e.src];\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (max[i][e.dst] < nc) {\n\t\t\t\t\t\t\t\ttrack[i][e.dst] = e.src;\n\t\t\t\t\t\t\t\tmax[i][e.dst] = nc;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tint m = 0;\n\t\t\t\tint v = -1;\n\t\t\t\tfor (int i = 0; i < V; ++i) {\n\t\t\t\t\tif (max[sum - 1][i] > m) {\n\t\t\t\t\t\tm = max[sum - 1][i];\n\t\t\t\t\t\tv = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tArrayDeque<Integer> stack = new ArrayDeque<>();\n\t\t\t\tstack.addFirst(v);\n\t\t\t\tfor (int i = sum - 1; i >= 0; --i) {\n\t\t\t\t\tstack.addFirst(track[i][v]);\n\t\t\t\t\tv = track[i][v];\n\t\t\t\t}\n\n\t\t\t\tfor (int i = 0; i <= sum; i++) {\n\t\t\t\t\tout.print(stack.pollFirst() + (i != sum ? \" \" : \"\\n\"));\n\t\t\t\t}\n\t\t\t}\n\t\t} else\n\t\t\tout.println(-1);\n\t}\n\n\tclass Edge {\n\t\tint src;\n\t\tint dst;\n\t\tint c;\n\n\t\tpublic Edge(int src, int dst, int c) {\n\t\t\tthis.src = src;\n\t\t\tthis.dst = dst;\n\t\t\tthis.c = c;\n\t\t}\n\n\t}\n\n\tvoid run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolver();\n\t\tout.flush();\n\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class Main{\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\tint V = ni();\n\t\tint E = ni();\n\t\tint K = ni();\n\n\t\tArrayList<Edge>[] g = new ArrayList[V];\n\t\tfor (int i = 0; i < V; ++i)\n\t\t\tg[i] = new ArrayList<>();\n\n\t\tfor (int i = 0; i < E; ++i) {\n\t\t\tint src = ni();\n\t\t\tint dst = ni();\n\t\t\tint c = ni();\n\t\t\tg[src].add(new Edge(src, dst, c));\n\t\t}\n\n\t\tint[][][] score = new int[20][V][V];\n\n\t\tfor (ArrayList<Edge> lis : g) {\n\t\t\tfor (Edge e : lis) {\n\t\t\t\tscore[0][e.src][e.dst] = Math.max(score[0][e.src][e.dst], e.c);\n\t\t\t}\n\t\t}\n\n\t\t// 21*150*150*150=7*10^7\n\t\tfor (int i = 1; i < 20; ++i) {\n\t\t\tfor (int from = 0; from < V; ++from) {\n\t\t\t\tfor (int to = 0; to < V; ++to) {\n\t\t\t\t\tfor (int med = 0; med < V; ++med) {\n\t\t\t\t\t\tif (score[i - 1][from][med] != 0 && score[i - 1][med][to] != 0)\n\t\t\t\t\t\t\tscore[i][from][to] = Math.max(score[i][from][to],\n\t\t\t\t\t\t\t\t\tscore[i - 1][from][med] + score[i - 1][med][to]);\n\t\t\t\t\t\tscore[i][from][to] = Math.max(score[i][from][to], score[0][from][to]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// 150*20*150=\n\t\tint[] cur = new int[V];\n\t\tint sum = 0;\n\t\tboolean ok = false;\n\n\t\touter: for (int i = 19; i >= 0; --i) {\n\t\t\tfor (int dst = 0; dst < V; ++dst) {\n\t\t\t\tfor (int med = 0; med < V; ++med) {\n\t\t\t\t\tif (cur[med] + score[i][med][dst] >= K) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint[] next = new int[V];\n\t\t\tfor (int dst = 0; dst < V; ++dst) {\n\t\t\t\tfor (int med = 0; med < V; ++med) {\n\t\t\t\t\tif (score[i][med][dst] != 0)\n\t\t\t\t\t\tnext[dst] = Math.max(next[dst], cur[med] + score[i][med][dst]);\n\t\t\t\t}\n\t\t\t\tnext[dst]=Math.max(next[dst], cur[dst]);\n\t\t\t}\n\n\t\t\tcur = Arrays.copyOf(next, V);\n\t\t\tsum += 1 << i;\n\t\t}\n\n\t\tif (ok) {\n\t\t\tSystem.out.println(++sum);\n\t\t\tif (sum <= 100) {\n\n\t\t\t\tint[][] track = new int[sum][V];\n\t\t\t\tint[][] max = new int[sum][V];\n\n\t\t\t\tfor (int i = 0; i < sum; i++) {\n\t\t\t\t\tfor (ArrayList<Edge> lis : g) {\n\t\t\t\t\t\tfor (Edge e : lis) {\n\n\t\t\t\t\t\t\tint nc = e.c;\n\t\t\t\t\t\t\tif (i != 0) {\n\t\t\t\t\t\t\t\tif (max[i - 1][e.src] == 0)\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\tnc += max[i - 1][e.src];\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (max[i][e.dst] < nc) {\n\t\t\t\t\t\t\t\ttrack[i][e.dst] = e.src;\n\t\t\t\t\t\t\t\tmax[i][e.dst] = nc;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tint m = 0;\n\t\t\t\tint v = -1;\n\t\t\t\tfor (int i = 0; i < V; ++i) {\n\t\t\t\t\tif (max[sum - 1][i] > m) {\n\t\t\t\t\t\tm = max[sum - 1][i];\n\t\t\t\t\t\tv = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tArrayDeque<Integer> stack = new ArrayDeque<>();\n\t\t\t\tstack.addFirst(v);\n\t\t\t\tfor (int i = sum - 1; i >= 0; --i) {\n\t\t\t\t\tstack.addFirst(track[i][v]);\n\t\t\t\t\tv = track[i][v];\n\t\t\t\t}\n\n\t\t\t\tfor (int i = 0; i <= sum; i++) {\n\t\t\t\t\tSystem.out.print(stack.pollFirst() + (i != sum ? \" \" : \"\\n\"));\n\t\t\t\t}\n\t\t\t}\n\t\t} else\n\t\t\tSystem.out.println(-1);\n\t}\n\n\tclass Edge {\n\t\tint src;\n\t\tint dst;\n\t\tint c;\n\n\t\tpublic Edge(int src, int dst, int c) {\n\t\t\tthis.src = src;\n\t\t\tthis.dst = dst;\n\t\t\tthis.c = c;\n\t\t}\n\n\t}\n\n\tvoid run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolver();\n\t\tout.flush();\n\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\tint V = ni();\n\t\tint E = ni();\n\t\tint K = ni();\n\n\t\tArrayList<Edge>[] g = new ArrayList[V];\n\t\tfor (int i = 0; i < V; ++i)\n\t\t\tg[i] = new ArrayList<>();\n\n\t\tfor (int i = 0; i < E; ++i) {\n\t\t\tint src = ni();\n\t\t\tint dst = ni();\n\t\t\tint c = ni();\n\t\t\tg[src].add(new Edge(src, dst, c));\n\t\t}\n\n\t\tint[][][] score = new int[20][V][V];\n\n\t\tfor (ArrayList<Edge> lis : g) {\n\t\t\tfor (Edge e : lis) {\n\t\t\t\tscore[0][e.src][e.dst] = Math.max(score[0][e.src][e.dst], e.c);\n\t\t\t}\n\t\t}\n\n\t\t// 21*150*150*150=7*10^7\n\t\tfor (int i = 1; i < 20; ++i) {\n\t\t\tfor (int from = 0; from < V; ++from) {\n\t\t\t\tfor (int to = 0; to < V; ++to) {\n\t\t\t\t\tfor (int med = 0; med < V; ++med) {\n\t\t\t\t\t\tif (score[i - 1][from][med] == 0 || score[i - 1][med][to] == 0)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tscore[i][from][to] = Math.max(score[i][from][to],\n\t\t\t\t\t\t\t\tscore[i - 1][from][med] + score[i - 1][med][to]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// 150*20*150=\n\t\tint ans = (1 << 30);\n\n\t\tint[] cur = new int[V];\n\t\tint sum = 0;\n\t\tboolean ok = false;\n\t\t// src->med:cur\n\t\t// med->dst:score\n\t\touter: for (int i = 19; i >= 0; --i) {\n\t\t\tfor (int dst = 0; dst < V; ++dst) {\n\t\t\t\tfor (int med = 0; med < V; ++med) {\n\t\t\t\t\tif (sum != 0 && score[i][med][dst] == 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (cur[med] + score[i][med][dst] >= K) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint[] next = new int[V];\n\t\t\tfor (int dst = 0; dst < V; ++dst) {\n\t\t\t\tfor (int med = 0; med < V; ++med) {\n\t\t\t\t\tif (sum != 0 && score[i][med][dst] == 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tnext[dst] = Math.max(next[dst], cur[med] + score[i][med][dst]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcur = Arrays.copyOf(next, V);\n\n\t\t\tsum += 1 << i;\n\t\t}\n\n\t\tif (ok) {\n\t\t\tans = Math.min(ans, sum);\n\t\t}\n\n\t\tif (ans != 1 << 30) {\n\t\t\tSystem.out.println(++ans);\n\t\t\tif (ans <= 100) {\n\n\t\t\t\tint[][] track = new int[ans][V];// [v][k]k?????§v?????°???????????¨????????´????????????\n\t\t\t\tint[][] max = new int[ans][V];// [v][k]\n\t\t\t\tfor (int i = 0; i < ans; i++) {\n\t\t\t\t\tfor (ArrayList<Edge> lis : g) {\n\t\t\t\t\t\tfor (Edge e : lis) {\n\n\t\t\t\t\t\t\tint nc = e.c;\n\t\t\t\t\t\t\tif (i != 0) {\n\t\t\t\t\t\t\t\tif (max[i - 1][e.src] == 0)\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\tnc += max[i - 1][e.src];\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (max[i][e.dst] < nc) {\n\t\t\t\t\t\t\t\ttrack[i][e.dst] = e.src;\n\t\t\t\t\t\t\t\tmax[i][e.dst] = nc;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tint m = 0;\n\t\t\t\tint v = -1;\n\t\t\t\tfor (int i = 0; i < V; ++i) {\n\t\t\t\t\tif (max[ans - 1][i] > m) {\n\t\t\t\t\t\tm = max[ans - 1][i];\n\t\t\t\t\t\tv = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tArrayDeque<Integer> stack = new ArrayDeque<>();\n\t\t\t\tstack.addFirst(v);\n\t\t\t\tfor (int i = ans - 1; i >= 0; --i) {\n\t\t\t\t\tstack.addFirst(track[i][v]);\n\t\t\t\t\tv = track[i][v];\n\t\t\t\t}\n\n\t\t\t\tfor (int i = 0; i <= ans; i++) {\n\t\t\t\t\tSystem.out.print(stack.pollFirst() + (i != ans ? \" \" : \"\\n\"));\n\t\t\t\t}\n\t\t\t}\n\t\t} else\n\t\t\tSystem.out.println(-1);\n\t}\n\n\tclass Edge {\n\t\tint src;\n\t\tint dst;\n\t\tint c;\n\n\t\tpublic Edge(int src, int dst, int c) {\n\t\t\tthis.src = src;\n\t\t\tthis.dst = dst;\n\t\t\tthis.c = c;\n\t\t}\n\n\t}\n\n\tvoid run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolver();\n\t\tout.flush();\n\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\tint V = ni();\n\t\tint E = ni();\n\t\tint K = ni();\n\n\t\tArrayList<Edge>[] g = new ArrayList[V];\n\t\tfor (int i = 0; i < V; ++i)\n\t\t\tg[i] = new ArrayList<>();\n\n\t\tfor (int i = 0; i < E; ++i) {\n\t\t\tint src = ni();\n\t\t\tint dst = ni();\n\t\t\tint c = ni();\n\t\t\tg[src].add(new Edge(src, dst, c));\n\t\t}\n\n\t\tint[][][] score = new int[20][V][V];\n\n\t\tfor (ArrayList<Edge> lis : g) {\n\t\t\tfor (Edge e : lis) {\n\t\t\t\tscore[0][e.src][e.dst] = Math.max(score[0][e.src][e.dst], e.c);\n\t\t\t}\n\t\t}\n\n\t\t// 21*150*150*150=7*10^7\n\t\tfor (int i = 1; i < 20; ++i) {\n\t\t\tfor (int from = 0; from < V; ++from) {\n\t\t\t\tfor (int to = 0; to < V; ++to) {\n\t\t\t\t\tfor (int med = 0; med < V; ++med) {\n\t\t\t\t\t\tif (score[i - 1][from][med] == 0 || score[i - 1][med][to] == 0)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tscore[i][from][to] = Math.max(score[i][from][to],\n\t\t\t\t\t\t\t\tscore[i - 1][from][med] + score[i - 1][med][to]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// 150*20*150=\n\t\tint ans = (1 << 30);\n\n\t\tint[] cur = new int[V];\n\t\tint sum = 0;\n\t\tboolean ok = false;\n\t\t// src->med:cur\n\t\t// med->dst:score\n\t\touter: for (int i = 19; i >= 0; --i) {\n\t\t\tfor (int dst = 0; dst < V; ++dst) {\n\t\t\t\tfor (int med = 0; med < V; ++med) {\n\t\t\t\t\tif (sum != 0 && score[i][med][dst] == 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (cur[med] + score[i][med][dst] >= K) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint[] next = new int[V];\n\t\t\tfor (int dst = 0; dst < V; ++dst) {\n\t\t\t\tfor (int med = 0; med < V; ++med) {\n\t\t\t\t\tif (sum != 0 && score[i][med][dst] == 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tnext[dst] = Math.max(next[dst], cur[med] + score[i][med][dst]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcur = Arrays.copyOf(next, V);\n\n\t\t\tsum += 1 << i;\n\t\t}\n\n\t\tif (ok) {\n\t\t\tans = Math.min(ans, sum);\n\t\t}\n\n\t\tif (ans != 1 << 30) {\n\t\t\tSystem.out.println(++ans);\n\t\t\tif (ans <= 100) {\n\n\t\t\t\tint[][] track = new int[ans][V];// [v][k]k?????§v?????°???????????¨????????´????????????\n\t\t\t\tint[][] max = new int[ans][V];// [v][k]\n\t\t\t\tfor (int i = 0; i < ans; i++) {\n\t\t\t\t\tfor (ArrayList<Edge> lis : g) {\n\t\t\t\t\t\tfor (Edge e : lis) {\n\n\t\t\t\t\t\t\tint nc = e.c;\n\t\t\t\t\t\t\tif (i != 0) {\n\t\t\t\t\t\t\t\tif (max[i - 1][e.src] == 0)\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\tnc += max[i - 1][e.src];\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (max[i][e.dst] < nc) {\n\t\t\t\t\t\t\t\ttrack[i][e.dst] = e.src;\n\t\t\t\t\t\t\t\tmax[i][e.dst] = nc;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tint m = 0;\n\t\t\t\tint v = -1;\n\t\t\t\tfor (int i = 0; i < V; ++i) {\n\t\t\t\t\tif (max[ans - 1][i] > m) {\n\t\t\t\t\t\tm = max[ans - 1][i];\n\t\t\t\t\t\tv = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tArrayDeque<Integer> stack = new ArrayDeque<>();\n\t\t\t\tstack.addFirst(v);\n\t\t\t\tfor (int i = ans - 1; i >= 0; --i) {\n\t\t\t\t\tstack.addFirst(track[i][v]);\n\t\t\t\t\tv = track[i][v];\n\t\t\t\t}\n\n\t\t\t\tfor (int i = 0; i <= ans; i++) {\n\t\t\t\t\tSystem.out.print(stack.pollFirst() + (i != ans ? \" \" : \"\\n\"));\n\t\t\t\t}\n\t\t\t}\n\t\t} else\n\t\t\tSystem.out.println(-1);\n\t}\n\n\tclass Edge {\n\t\tint src;\n\t\tint dst;\n\t\tint c;\n\n\t\tpublic Edge(int src, int dst, int c) {\n\t\t\tthis.src = src;\n\t\t\tthis.dst = dst;\n\t\t\tthis.c = c;\n\t\t}\n\n\t}\n\n\tvoid run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolver();\n\t\tout.flush();\n\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\tint V = ni();\n\t\tint E = ni();\n\t\tint K = ni();\n\n\t\tArrayList<Edge>[] g = new ArrayList[V];\n\t\tfor (int i = 0; i < V; ++i)\n\t\t\tg[i] = new ArrayList<>();\n\n\t\tfor (int i = 0; i < E; ++i) {\n\t\t\tint src = ni();\n\t\t\tint dst = ni();\n\t\t\tint c = ni();\n\t\t\tg[src].add(new Edge(src, dst, c));\n\t\t}\n\n\t\tint[][][] score = new int[20][V][V];\n\n\t\tfor (ArrayList<Edge> lis : g) {\n\t\t\tfor (Edge e : lis) {\n\t\t\t\tscore[0][e.src][e.dst] = Math.max(score[0][e.src][e.dst], e.c);\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 1; i < 20; ++i) {\n\t\t\tfor (int from = 0; from < V; ++from) {\n\t\t\t\tfor (int to = 0; to < V; ++to) {\n\t\t\t\t\tfor (int med = 0; med < V; ++med) {\n\t\t\t\t\t\tif (score[i - 1][from][med] != 0 && score[i - 1][med][to] != 0)\n\t\t\t\t\t\t\tscore[i][from][to] = Math.max(score[i][from][to],\n\t\t\t\t\t\t\t\t\tscore[i - 1][from][med] + score[i - 1][med][to]);\n\t\t\t\t\t\tscore[i][from][to] = Math.max(score[i][from][to], score[0][from][to]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint[] cur = new int[V];\n\t\tint sum = 0;\n\t\tboolean ok = false;\n\n\t\touter: for (int i = 19; i >= 0; --i) {\n\t\t\tfor (int dst = 0; dst < V; ++dst) {\n\t\t\t\tfor (int med = 0; med < V; ++med) {\n\t\t\t\t\tif (cur[med] + score[i][med][dst] >= K) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint[] next = new int[V];\n\t\t\tfor (int dst = 0; dst < V; ++dst) {\n\t\t\t\tfor (int med = 0; med < V; ++med) {\n\t\t\t\t\tif (score[i][med][dst] != 0)\n\t\t\t\t\t\tnext[dst] = Math.max(next[dst], cur[med] + score[i][med][dst]);\n\t\t\t\t}\n\t\t\t\tnext[dst]=Math.max(next[dst], cur[dst]);\n\t\t\t}\n\n\t\t\tcur = Arrays.copyOf(next, V);\n\t\t\tsum += 1 << i;\n\t\t}\n\n\t\tif (ok) {\n\t\t\tout.println(++sum);\n\t\t\tif (sum <= 100) {\n\n\t\t\t\tint[][] track = new int[sum][V];\n\t\t\t\tint[][] max = new int[sum][V];\n\n\t\t\t\tfor (int i = 0; i < sum; i++) {\n\t\t\t\t\tfor (ArrayList<Edge> lis : g) {\n\t\t\t\t\t\tfor (Edge e : lis) {\n\n\t\t\t\t\t\t\tint nc = e.c;\n\t\t\t\t\t\t\tif (i != 0) {\n\t\t\t\t\t\t\t\tif (max[i - 1][e.src] == 0)\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\tnc += max[i - 1][e.src];\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (max[i][e.dst] < nc) {\n\t\t\t\t\t\t\t\ttrack[i][e.dst] = e.src;\n\t\t\t\t\t\t\t\tmax[i][e.dst] = nc;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tint m = 0;\n\t\t\t\tint v = -1;\n\t\t\t\tfor (int i = 0; i < V; ++i) {\n\t\t\t\t\tif (max[sum - 1][i] > m) {\n\t\t\t\t\t\tm = max[sum - 1][i];\n\t\t\t\t\t\tv = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tArrayDeque<Integer> stack = new ArrayDeque<>();\n\t\t\t\tstack.addFirst(v);\n\t\t\t\tfor (int i = sum - 1; i >= 0; --i) {\n\t\t\t\t\tstack.addFirst(track[i][v]);\n\t\t\t\t\tv = track[i][v];\n\t\t\t\t}\n\n\t\t\t\tfor (int i = 0; i <= sum; i++) {\n\t\t\t\t\tout.print(stack.pollFirst() + (i != sum ? \" \" : \"\\n\"));\n\t\t\t\t}\n\t\t\t}\n\t\t} else\n\t\t\tout.println(-1);\n\t}\n\n\tclass Edge {\n\t\tint src;\n\t\tint dst;\n\t\tint c;\n\n\t\tpublic Edge(int src, int dst, int c) {\n\t\t\tthis.src = src;\n\t\t\tthis.dst = dst;\n\t\t\tthis.c = c;\n\t\t}\n\n\t}\n\n\tvoid run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolver();\n\t\tout.flush();\n\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\tvoid solver() {\n\t\tint V = ni();\n\t\tint E = ni();\n\t\tint K = ni();\n\n\t\tArrayList<Edge>[] g = new ArrayList[V];\n\t\tfor (int i = 0; i < V; ++i)\n\t\t\tg[i] = new ArrayList<>();\n\n\t\tfor (int i = 0; i < E; ++i) {\n\t\t\tint src = ni();\n\t\t\tint dst = ni();\n\t\t\tint c = ni();\n\t\t\tg[src].add(new Edge(src, dst, c));\n\t\t}\n\n\t\tint[][][] score = new int[20][V][V];\n\n\t\tfor (ArrayList<Edge> lis : g) {\n\t\t\tfor (Edge e : lis) {\n\t\t\t\tscore[0][e.src][e.dst] = Math.max(score[0][e.src][e.dst], e.c);\n\t\t\t}\n\t\t}\n\n\t\t// 21*150*150*150=7*10^7\n\t\tfor (int i = 1; i < 20; ++i) {\n\t\t\tfor (int from = 0; from < V; ++from) {\n\t\t\t\tfor (int to = 0; to < V; ++to) {\n\t\t\t\t\tfor (int med = 0; med < V; ++med) {\n\t\t\t\t\t\tif (score[i - 1][from][med] == 0 || score[i - 1][med][to] == 0)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tscore[i][from][to] = Math.max(score[i][from][to],\n\t\t\t\t\t\t\t\tscore[i - 1][from][med] + score[i - 1][med][to]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// 150*20*150=\n\t\tint ans = (1 << 30);\n\n\t\tint[] cur = new int[V];\n\t\tint sum = 0;\n\t\tboolean ok = false;\n\t\t// src->med:cur\n\t\t// med->dst:score\n\t\touter: for (int i = 19; i >= 0; --i) {\n\t\t\tfor (int dst = 0; dst < V; ++dst) {\n\t\t\t\tfor (int med = 0; med < V; ++med) {\n\t\t\t\t\tif (sum != 0 && score[i][med][dst] == 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (cur[med] + score[i][med][dst] >= K) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint[] next = new int[V];\n\t\t\tfor (int dst = 0; dst < V; ++dst) {\n\t\t\t\tfor (int med = 0; med < V; ++med) {\n\t\t\t\t\tif (sum != 0 && score[i][med][dst] == 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tnext[dst] = Math.max(next[dst], cur[med] + score[i][med][dst]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcur = Arrays.copyOf(next, V);\n\n\t\t\tsum += 1 << i;\n\t\t}\n\n\t\tif (ok) {\n\t\t\tans = Math.min(ans, sum);\n\t\t}\n\n\t\tif (ans != 1 << 30) {\n\t\t\tSystem.out.println(++ans);\n\t\t\tif (ans <= 100) {\n\n\t\t\t\tint[][] track = new int[ans][V];// [v][k]k?????§v?????°???????????¨????????´????????????\n\t\t\t\tint[][] max = new int[ans][V];// [v][k]\n\t\t\t\tfor (int i = 0; i < ans; i++) {\n\t\t\t\t\tfor (ArrayList<Edge> lis : g) {\n\t\t\t\t\t\tfor (Edge e : lis) {\n\n\t\t\t\t\t\t\tint nc = e.c;\n\t\t\t\t\t\t\tif (i != 0) {\n\t\t\t\t\t\t\t\tif (max[i - 1][e.src] == 0)\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\tnc += max[i - 1][e.src];\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (max[i][e.dst] < nc) {\n\t\t\t\t\t\t\t\ttrack[i][e.dst] = e.src;\n\t\t\t\t\t\t\t\tmax[i][e.dst] = nc;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tint m = 0;\n\t\t\t\tint v = -1;\n\t\t\t\tfor (int i = 0; i < V; ++i) {\n\t\t\t\t\tif (max[ans - 1][i] > m) {\n\t\t\t\t\t\tm = max[ans - 1][i];\n\t\t\t\t\t\tv = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tArrayDeque<Integer> stack = new ArrayDeque<>();\n\t\t\t\tstack.addFirst(v);\n\t\t\t\tfor (int i = ans - 1; i >= 0; --i) {\n\t\t\t\t\tstack.addFirst(track[i][v]);\n\t\t\t\t\tv = track[i][v];\n\t\t\t\t}\n\n\t\t\t\tfor (int i = 0; i <= ans; i++) {\n\t\t\t\t\tSystem.out.print(stack.pollFirst() + (i != ans ? \" \" : \"\\n\"));\n\t\t\t\t}\n\t\t\t}\n\t\t} else\n\t\t\tSystem.out.println(-1);\n\t}\n\n\tclass Edge {\n\t\tint src;\n\t\tint dst;\n\t\tint c;\n\n\t\tpublic Edge(int src, int dst, int c) {\n\t\t\tthis.src = src;\n\t\t\tthis.dst = dst;\n\t\t\tthis.c = c;\n\t\t}\n\n\t}\n\n\tvoid run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolver();\n\t\tout.flush();\n\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\tint V = ni();\n\t\tint E = ni();\n\t\tint K = ni();\n\n\t\tArrayList<Edge>[] g = new ArrayList[V];\n\t\tfor (int i = 0; i < V; ++i)\n\t\t\tg[i] = new ArrayList<>();\n\n\t\tfor (int i = 0; i < E; ++i) {\n\t\t\tint src = ni();\n\t\t\tint dst = ni();\n\t\t\tint c = ni();\n\t\t\tg[src].add(new Edge(src, dst, c));\n\t\t}\n\n\t\tint[][][] score = new int[20][V][V];\n\n\t\tfor (ArrayList<Edge> lis : g) {\n\t\t\tfor (Edge e : lis) {\n\t\t\t\tscore[0][e.src][e.dst] = Math.max(score[0][e.src][e.dst], e.c);\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 1; i < 20; ++i) {\n\t\t\tfor (int from = 0; from < V; ++from) {\n\t\t\t\tfor (int to = 0; to < V; ++to) {\n\t\t\t\t\tfor (int med = 0; med < V; ++med) {\n\t\t\t\t\t\tif (score[i - 1][from][med] != 0 && score[i - 1][med][to] != 0)\n\t\t\t\t\t\t\tscore[i][from][to] = Math.max(score[i][from][to],\n\t\t\t\t\t\t\t\t\tscore[i - 1][from][med] + score[i - 1][med][to]);\n\t\t\t\t\t\tscore[i][from][to] = Math.max(score[i][from][to], score[0][from][to]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// 150*20*150=\n\t\tint[] cur = new int[V];\n\t\tint sum = 0;\n\t\tboolean ok = false;\n\n\t\touter: for (int i = 19; i >= 0; --i) {\n\t\t\tfor (int dst = 0; dst < V; ++dst) {\n\t\t\t\tfor (int med = 0; med < V; ++med) {\n\t\t\t\t\tif (cur[med] + score[i][med][dst] >= K) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint[] next = new int[V];\n\t\t\tfor (int dst = 0; dst < V; ++dst) {\n\t\t\t\tfor (int med = 0; med < V; ++med) {\n\t\t\t\t\tif (score[i][med][dst] != 0)\n\t\t\t\t\t\tnext[dst] = Math.max(next[dst], cur[med] + score[i][med][dst]);\n\t\t\t\t}\n\t\t\t\tnext[dst]=Math.max(next[dst], cur[dst]);\n\t\t\t}\n\n\t\t\tcur = Arrays.copyOf(next, V);\n\t\t\tsum += 1 << i;\n\t\t}\n\n\t\tif (ok) {\n\t\t\tout.println(++sum);\n\t\t\tif (sum <= 100) {\n\n\t\t\t\tint[][] track = new int[sum][V];\n\t\t\t\tint[][] max = new int[sum][V];\n\n\t\t\t\tfor (int i = 0; i < sum; i++) {\n\t\t\t\t\tfor (ArrayList<Edge> lis : g) {\n\t\t\t\t\t\tfor (Edge e : lis) {\n\n\t\t\t\t\t\t\tint nc = e.c;\n\t\t\t\t\t\t\tif (i != 0) {\n\t\t\t\t\t\t\t\tif (max[i - 1][e.src] == 0)\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\tnc += max[i - 1][e.src];\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (max[i][e.dst] < nc) {\n\t\t\t\t\t\t\t\ttrack[i][e.dst] = e.src;\n\t\t\t\t\t\t\t\tmax[i][e.dst] = nc;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tint m = 0;\n\t\t\t\tint v = -1;\n\t\t\t\tfor (int i = 0; i < V; ++i) {\n\t\t\t\t\tif (max[sum - 1][i] > m) {\n\t\t\t\t\t\tm = max[sum - 1][i];\n\t\t\t\t\t\tv = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tArrayDeque<Integer> stack = new ArrayDeque<>();\n\t\t\t\tstack.addFirst(v);\n\t\t\t\tfor (int i = sum - 1; i >= 0; --i) {\n\t\t\t\t\tstack.addFirst(track[i][v]);\n\t\t\t\t\tv = track[i][v];\n\t\t\t\t}\n\n\t\t\t\tfor (int i = 0; i <= sum; i++) {\n\t\t\t\t\tout.print(stack.pollFirst() + (i != sum ? \" \" : \"\\n\"));\n\t\t\t\t}\n\t\t\t}\n\t\t} else\n\t\t\tout.println(-1);\n\t}\n\n\tclass Edge {\n\t\tint src;\n\t\tint dst;\n\t\tint c;\n\n\t\tpublic Edge(int src, int dst, int c) {\n\t\t\tthis.src = src;\n\t\t\tthis.dst = dst;\n\t\t\tthis.c = c;\n\t\t}\n\n\t}\n\n\tvoid run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolver();\n\t\tout.flush();\n\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class Main{\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\tint V = ni();\n\t\tint E = ni();\n\t\tint K = ni();\n\n\t\tArrayList<Edge>[] g = new ArrayList[V];\n\t\tfor (int i = 0; i < V; ++i)\n\t\t\tg[i] = new ArrayList<>();\n\n\t\tfor (int i = 0; i < E; ++i) {\n\t\t\tint src = ni();\n\t\t\tint dst = ni();\n\t\t\tint c = ni();\n\t\t\tg[src].add(new Edge(src, dst, c));\n\t\t}\n\n\t\tint[][][] score = new int[20][V][V];\n\n\t\tfor (ArrayList<Edge> lis : g) {\n\t\t\tfor (Edge e : lis) {\n\t\t\t\tscore[0][e.src][e.dst] = Math.max(score[0][e.src][e.dst], e.c);\n\t\t\t}\n\t\t}\n\n\t\t// 21*150*150*150=7*10^7\n\t\tfor (int i = 1; i < 20; ++i) {\n\t\t\tfor (int from = 0; from < V; ++from) {\n\t\t\t\tfor (int to = 0; to < V; ++to) {\n\t\t\t\t\tfor (int med = 0; med < V; ++med) {\n\t\t\t\t\t\tif (score[i - 1][from][med] == 0 || score[i - 1][med][to] == 0)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tscore[i][from][to] = Math.max(score[i][from][to],\n\t\t\t\t\t\t\t\tscore[i - 1][from][med] + score[i - 1][med][to]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// 150*20*150=\n\t\tint ans = (1 << 30);\n\n\t\tint[] cur = new int[V];\n\t\tint sum = 0;\n\t\tboolean ok = false;\n\n\t\touter: for (int i = 19; i >= 0; --i) {\n\t\t\tfor (int dst = 0; dst < V; ++dst) {\n\t\t\t\tfor (int med = 0; med < V; ++med) {\n\t\t\t\t\tif (score[i][med][dst] == 0 || (sum != 0 && cur[med] == 0))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (cur[med] + score[i][med][dst] >= K) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint[] next = new int[V];\n\t\t\tfor (int dst = 0; dst < V; ++dst) {\n\t\t\t\tfor (int med = 0; med < V; ++med) {\n\t\t\t\t\tif (score[i][med][dst] == 0 || (sum != 0 && cur[med] == 0))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tnext[dst] = Math.max(next[dst], cur[med] + score[i][med][dst]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcur = Arrays.copyOf(next, V);\n\n\t\t\tsum += 1 << i;\n\t\t}\n\n\t\tif (ok) {\n\t\t\tans = Math.min(ans, sum);\n\t\t}\n\n\t\tif (ans != 1 << 30) {\n\t\t\tSystem.out.println(++ans);\n\t\t\tif (ans <= 100) {\n\n\t\t\t\tint[][] track = new int[ans][V];\n\t\t\t\tint[][] max = new int[ans][V];\n\t\t\t\tfor (int i = 0; i < ans; i++) {\n\t\t\t\t\tfor (ArrayList<Edge> lis : g) {\n\t\t\t\t\t\tfor (Edge e : lis) {\n\n\t\t\t\t\t\t\tint nc = e.c;\n\t\t\t\t\t\t\tif (i != 0) {\n\t\t\t\t\t\t\t\tif (max[i - 1][e.src] == 0)\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\tnc += max[i - 1][e.src];\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (max[i][e.dst] < nc) {\n\t\t\t\t\t\t\t\ttrack[i][e.dst] = e.src;\n\t\t\t\t\t\t\t\tmax[i][e.dst] = nc;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tint m = 0;\n\t\t\t\tint v = -1;\n\t\t\t\tfor (int i = 0; i < V; ++i) {\n\t\t\t\t\tif (max[ans - 1][i] > m) {\n\t\t\t\t\t\tm = max[ans - 1][i];\n\t\t\t\t\t\tv = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tArrayDeque<Integer> stack = new ArrayDeque<>();\n\t\t\t\tstack.addFirst(v);\n\t\t\t\tfor (int i = ans - 1; i >= 0; --i) {\n\t\t\t\t\tstack.addFirst(track[i][v]);\n\t\t\t\t\tv = track[i][v];\n\t\t\t\t}\n\n\t\t\t\tfor (int i = 0; i <= ans; i++) {\n\t\t\t\t\tSystem.out.print(stack.pollFirst() + (i != ans ? \" \" : \"\\n\"));\n\t\t\t\t}\n\t\t\t}\n\t\t} else\n\t\t\tSystem.out.println(-1);\n\t}\n\n\tclass Edge {\n\t\tint src;\n\t\tint dst;\n\t\tint c;\n\n\t\tpublic Edge(int src, int dst, int c) {\n\t\t\tthis.src = src;\n\t\t\tthis.dst = dst;\n\t\t\tthis.c = c;\n\t\t}\n\n\t}\n\n\tvoid run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolver();\n\t\tout.flush();\n\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Ruby",
    "code": "require 'tsort'\nclass Hash\n  include TSort\n  alias tsort_each_node each_key\n  def tsort_each_child(u, &block)\n    self[u].each_key(&block) if self[u]\n  end\nend\n\nn, m, k = gets.split.map(&:to_i)\n\nmatrices = []\na = Array.new(n).map { Array.new(n, -10*k) }\n(0..n-1).each {|i| a[i][i] = 0 }\ng = Hash[(0..n-1).map {|i| [i, Hash.new(0)] }]\nm.times do\n  i, j, c = gets.split.map(&:to_i)\n  a[i][j] = c if c > a[i][j]\n  g[i][j] = c if c > g[i][j]\nend\nmatrices << a\n\nbegin\n  # DAG\n  g.tsort\n  l = Marshal.load(Marshal.dump(g))\n  d = 1\n  score = (l.values.map {|h| h.values.max || -1 }.max || -1)\n  until score >= k || l.empty?\n    d += 1\n    new_l = {}\n    g.each do |i, h|\n      h.each do |j, c1|\n        if l[j]\n          l[j].each do |k, c2|\n            new_l[i] ||= Hash.new(0)\n            new_l[i][k] = c1 + c2 if new_l[i][k] < c1 + c2\n          end\n        end\n      end\n    end\n    l = new_l\n    score = (l.values.map {|h| h.values.max || -1 }.max || -1)\n  end\n\n  if l.empty?\n    p -1\n    exit\n  end\n  p d\n\n  s = t = nil\n  (0..n-1).each do |i|\n    (0..n-1).each do |j|\n      if l[i] && l[i][j] == score\n        s = i\n        t = j\n        break\n      end\n    end\n    break if s\n  end\n  \n  paths = (0..n-1).map {|i| i == t ? [t] : nil }\n  lens = (0..n-1).map {|i| i == t ? 0 : -Float::INFINITY }\n  d.times do\n    new_paths = Array.new(n)\n    new_lens = Array.new(n, -Float::INFINITY)\n    (0..n-1).each do |i|\n      j = g[i].keys.max_by {|j| g[i][j] + lens[j] }\n      if j\n        new_lens[i] = g[i][j] + lens[j]\n        new_paths[i] = (paths[j] ? [i] + paths[j] : nil)\n      end\n    end\n    paths = new_paths\n    lens = new_lens\n  end\n  puts paths[s] * \" \"\n\n  exit\nrescue TSort::Cyclic\n  # do nothing\nend\n\n\nuntil matrices[-1].map {|row| row.max }.max >= k\n  a = matrices[-1]\n  b = Array.new(n).map { Array.new(n, -10*k) }\n  (0..n-1).each do |i|\n    (0..n-1).each do |j|\n      (0..n-1).each do |k|\n        x = a[i][k] + a[k][j]\n        b[i][j] = x if x > b[i][j]\n      end\n    end\n  end\n  matrices << b\nend\n\nif matrices.size == 1\n  a = matrices[0]\n  d = 1\nelse\n  d = 1 << matrices.size - 2\n  a = matrices[-2]\n  (matrices.size - 2).downto(0) do |i|\n    b = matrices[i]\n    c = Array.new(n).map { Array.new(n, -10*k) }\n    (0..n-1).each do |i|\n      (0..n-1).each do |j|\n        (0..n-1).each do |k|\n          x = a[i][k] + b[k][j]\n          c[i][j] = x if x > c[i][j]\n        end\n      end\n    end\n    if c.map {|row| row.max }.max < k\n      a = c\n      d += (1 << i)\n    end\n  end\nend\n\nscore = a.map {|row| row.max }.max\nif score < k\n  d += 1\n  c = Array.new(n).map { Array.new(n, -Float::INFINITY) }\n  (0..n-1).each do |i|\n    (0..n-1).each do |j|\n      c[i][j] = (0..n-1).map {|k| a[i][k] + matrices[0][k][j] }.max\n    end\n  end\n  a = c\n  score = a.map {|row| row.max }.max\nend\np d\n\nif d <= 1000\n  s = t = nil\n  (0..n-1).each do |i|\n    (0..n-1).each do |j|\n      if a[i][j] == score\n        s, t = i, j\n        break\n      end\n    end\n    break if s\n  end\n\n  paths = (0..n-1).map {|i| i == t ? [t] : nil }\n  lens = (0..n-1).map {|i| i == t ? 0 : -Float::INFINITY }\n  d.times do\n    new_paths = Array.new(n)\n    new_lens = Array.new(n, -Float::INFINITY)\n    (0..n-1).each do |i|\n      j = g[i].keys.max_by {|j| g[i][j] + lens[j] }\n      if j\n        new_lens[i] = g[i][j] + lens[j]\n        new_paths[i] = (paths[j] ? [i] + paths[j] : nil)\n      end\n    end\n    paths = new_paths\n    lens = new_lens\n  end\n  puts paths[s] * \" \"\nend\n\n"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop, heapify\nimport sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\ndef solve():\n    N, M, K = map(int, readline().split())\n    INF = 10**18\n    E = [[-INF]*N for i in range(N)]\n    for i in range(M):\n        a, b, c = map(int, readline().split())\n        E[a][b] = max(E[a][b], c)\n    G = [[] for i in range(N)]\n    for v in range(N):\n        for w in range(N):\n            if E[v][w] >= 0:\n                G[v].append((w, E[v][w]))\n    T = 100\n    dist = [[0]*(T+1) for i in range(N)]\n    prv = [[None]*(T+1) for i in range(N)]\n    que = []\n    for i in range(N):\n        que.append((0, i, 0))\n    t0 = T+1\n    while que:\n        cost, v, t = heappop(que)\n        cost = -cost\n        if cost >= K and t < t0:\n            t0 = t\n        if cost < dist[v][t] or t == T:\n            continue\n        for w, d in G[v]:\n            if dist[w][t+1] < cost + d:\n                dist[w][t+1] = cost + d\n                prv[w][t+1] = v\n                heappush(que, (-(cost + d), w, t+1))\n    if t0 != T+1:\n        v0 = 0; d = 0\n        for v in range(N):\n            e = dist[v][t0]\n            if d < e:\n                d = e\n                v0 = v\n        res = [v0]\n        v = v0; t = t0\n        while t > 0:\n            v = prv[v][t]; t -= 1\n            res.append(v)\n        res.reverse()\n        write(\"%d\\n\" % t0)\n        write(\" \".join(map(str, res)))\n        write(\"\\n\")\n        return\n\n    for v in range(N):\n        E[v][v] = 0\n    E2 = [[-INF]*N for i in range(N)]\n    A = (K-1).bit_length()\n    RS = [E]\n    for k in range(A):\n        F = [[-INF]*N for i in range(N)]\n        for v in range(N):\n            for w in range(N):\n                E2[w][v] = E[v][w]\n        ok = 0\n        for i in range(N):\n            Ei = E[i]\n            for j in range(N):\n                Ej = E2[j]\n                F[i][j] = r = max((a+b for a, b in zip(Ei, Ej) if a >= 0 and b >= 0), default = -INF)\n                if r >= K:\n                    ok = 1\n        RS.append(F)\n        E = F\n        if ok:\n            A = k\n            break\n\n    D = [0]*N\n    ans = 0\n    for i in range(A, -1, -1):\n        E = RS[i]\n        D0 = [0]*N\n        ok = 0\n        for v in range(N):\n            D0[v] = r = max((a + e[v] for a, e in zip(D, E) if e[v]), default = -INF)\n            if r >= K:\n                ok = 1\n        if not ok:\n            ans += 1 << i\n            D = D0\n    ans += 1\n    if ans > K:\n        write(\"-1\\n\")\n    else:\n        write(\"%d\\n\" % ans)\nsolve()\n"
  }
]