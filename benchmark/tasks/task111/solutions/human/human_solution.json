[
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<cstdio>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\n#define X real()\n#define Y imag()\n\ntypedef long double D;\ntypedef complex<D> P;\ntypedef pair<P, P> L;\ntypedef vector<P> Pol;\n\nconst D INF = 1e40;\nconst D EPS = 1e-8;\nconst D PI = acos(-1);\n\nint sig(D r) {return (r < -EPS) ? -1 : (r > EPS) ? 1 : 0;}\nbool eq(D a, D b) {return abs(a - b) < EPS;}\nbool near(P a, P b) {return abs(a - b) < EPS;}\n\n// 内積\nD dot(P a, P b) {return a.X * b.X + a.Y * b.Y;}\n// 外積\nD det(P a, P b) {return a.X * b.Y - a.Y * b.X;}\n\n// 線分のベクトル\nP vec(L a) {return a.second - a.first;}\n\n// 線分abに対する点xの位置\nenum CCW{FRONT = 1, RIGHT = 2, BACK = 4, LEFT = 8, ON = 16};\nint ccw(L s, P p) {\n  P a = vec(s);\n  p -= s.first;\n  D cr = det(a, p);\n  if (eq(cr, 0)) {\n    if (sig(dot(a, p)) < 0) return BACK;\n    if (sig(norm(a) - norm(p)) < 0) return FRONT;\n    return ON;\n  }\n  return (cr > 0) ? LEFT : RIGHT;\n}\n\n// 角度\nD ang(P p) {D theta = arg(p); return sig(theta - PI) < 0 ? theta : -PI;}\n// 有向角度\nD ang(P base, P a, P b) {return ang((b - base) / (a - base));}\n\n// 射影\nP proj(P a, P b) {return a * dot(a, b) / norm(a);}\nP perp(L l, P p) {return l.first + proj(vec(l), p - l.first);}\nP refl(L l, P p) {return perp(l, p) * (D)2 - p;}\n\n// 交差判定\nbool iLL(L a, L b) {return !eq(det(vec(a), vec(b)), 0);}\nbool eqL(L a, L b) {return !iLL(a, b) && eq(det(vec(a), b.first - a.first), 0);}\nbool iLS(L a, L b) {return sig(det(vec(a), b.first - a.first)) * sig(det(vec(a), b.second - a.first)) <= 0;}\nbool iLSs(L a, L b) {return sig(det(vec(a), b.first - a.first)) * sig(det(vec(a), b.second - a.first)) < 0;}\nbool iSS(L a, L b) {\n  int cwa = ccw(a, b.first) | ccw(a, b.second);\n  int cwb = ccw(b, a.first) | ccw(b, a.second);\n  return ((cwa | cwb) & ON) || ((cwa & cwb) == (LEFT | RIGHT));\n}\nbool iSSs(L a, L b) {return ((ccw(a, b.first) | ccw(a, b.second)) & (ccw(b, a.first) | ccw(b, a.second))) == (LEFT | RIGHT);}\n\n// 交点\nP pLL(L a, L b) {return a.first + vec(a) * (det(vec(b), b.first - a.first) / det(vec(b), vec(a)));}\n\n// 距離\nD dLP(L l, P x) {return abs(det(vec(l), x - l.first)) / abs(vec(l));}\nD dSP(L s, P x) {\n  if (sig(dot(vec(s), x - s.first)) <= 0) return abs(x - s.first);\n  if (sig(dot(-vec(s), x - s.second)) <= 0) return abs(x - s.second);\n  return dLP(s, x);\n}\nD dLL(L a, L b) {return iLL(a, b) ? 0 : dLP(a, b.first);}\nD dLS(L a, L b) {return iLS(a, b) ? 0 : min(dLP(a, b.first), dLP(a, b.second));}\nD dSS(L a, L b) {return iSS(a, b) ? 0 : min(min(dSP(a, b.first), dSP(a, b.second)), min(dSP(b, a.first), dSP(b, a.second)));}\n\n// 比較関数\nnamespace std {\n  bool operator<(P a, P b) {return eq(a.X, b.X) ? a.Y < b.Y : a.X < b.X;}\n}\nL sortBase;\nbool lessArg(P a, P b) {\n  D ang1 = ang(sortBase.first, sortBase.second, a);\n  D ang2 = ang(sortBase.first, sortBase.second, b);\n  return eq(ang1, ang2) ? norm(a) > norm(b) : ang1 < ang2;\n}\n\n// 円\nstruct C{\n  P c; D r;\n  C() {}\n  C(P c, D r) : c(c), r(r) {}\n};\n\n// 2円の位置関係\nenum RELATION{SAME = 1, CONTAIN = 2, OVER = 4, NO_CROSS = 8, ONE_CROSS = 16, ONE_CONTAIN_CROSS = 32, ONE_OVER_CROSS = 64, TWO_CROSS = 128};\nint cRel(C c1, C c2) {\n  D d = abs(c1.c - c2.c);\n  if (near(c1.c, c2.c) && eq(c1.r, c2.r)) return SAME;\n  if (sig(d - (c1.r - c2.r)) < 0) return OVER;\n  if (sig(d - (c2.r - c1.r)) < 0) return CONTAIN;\n  if (eq(d, c1.r - c2.r)) return ONE_OVER_CROSS;\n  if (eq(d, c2.r - c1.r)) return ONE_CONTAIN_CROSS;\n  if (eq(d, c1.r + c2.r)) return ONE_CROSS;\n  if (sig(d - (c1.r + c2.r)) > 0) return NO_CROSS;\n  return TWO_CROSS;\n}\n\n// 点が円に含まれるか\nbool iCP(C c, P p) {return sig(abs(p - c.c) - c.r) <= 0;}\n// 交差判定\nbool iCL(C c, L l) {return sig(c.r - dLP(l, c.c)) >= 0;}\n// 円と交差せず完全に含まれても良い場合は&&以降を削除\nbool iCS(C c, L s) {return iCL(c, s) && sig(c.r - max(abs(s.first - c.c), abs(s.second - c.c))) <= 0;}\nbool iCC(C a, C b) {return sig(abs(a.c - b.c) - abs(a.r - b.r) >= 0) && sig(abs(a.c - b.c) - a.r - b.r) <= 0;}\n\n// 交点\npair<P, P> pCC(C a, C b) {\n  D x = (norm(a.c - b.c) + a.r * a.r - b.r * b.r) / (2 * abs(a.c - b.c));\n  P e = (b.c - a.c) / abs(b.c - a.c);\n  P y = e * P(0, sqrt(max(a.r * a.r - x * x, (D)0)));\n  return make_pair(a.c + e * x - y, a.c + e * x + y);\n}\npair<P, P> pCL(C c, L l) {\n  P x = perp(l, c.c);\n  P y = vec(l) / abs(vec(l)) * sqrt(max(c.r * c.r - norm(x - c.c), (D)0));\n  return make_pair(x - y, x + y);\n}\n\n// 角の内外判定 角abの内部にあれば正、辺上は0、外部は負\nint sAP(P a, P b, P c) {return sig(det(a, c)) - sig(det(b, c)) - sig(det(a, b));}\n\n// 多角形の面積\nD aPol(Pol vp) {\n  D ret = 0;\n  rep (i, vp.size()) ret += det(vp[i], vp[(i + 1) % vp.size()]);\n  return ret / 2;\n}\n\n// 三角形の面積\nD aTri(D a, D b, D c){\n  D s = (a + b + c) / 2;\n  return sqrt(max(s * (s - a) * (s - b) * (s - c), (D)0));\n}\n\n// 多角形の内外判定 内部:1、周上:0、外部:-1\nint sGP(Pol pol, P p) {\n  int side = -1;\n  rep (i, pol.size()) {\n    P p0 = pol[i] - p, p1 = pol[(i + 1) % pol.size()] - p;\n    if (sig(det(p0, p1)) == 0 && sig(dot(p0, p1)) <= 0) return 0;\n    if (p0.Y > p1.Y) swap(p0, p1);\n    if (sig(p0.Y) <= 0 && 0 < sig(p1.Y) && sig(det(p0, p1)) > 0) side *= -1;\n  }\n  return side;\n}\n\n// 凸包\nPol convexHull(Pol p) {\n  int m = 0;\n  vector<P> q(p.size() * 2);\n  sort(p.begin(), p.end());\n  for (int i = 0; i < int(p.size()); q[m++] = p[i++]) for (; m > 1 && sig(det(q[m - 1] - q[m - 2], p[i] - q[m - 2])) <= 0; --m);\n  for (int i = p.size() - 2, r = m; i >= 0; q[m++] = p[i--]) for (; m > r && sig(det(q[m - 1] - q[m - 2], p[i] - q[m - 2])) <= 0; --m);\n  q.resize(m - 1);\n  return q;\n}\n\n// 凸包カット\nPol convexCut(Pol p, L l) {\n  vector<P> q;\n  rep (i, p.size()) {\n    if (ccw(l, p[i]) & (LEFT | BACK | ON | FRONT)) q.push_back(p[i]);\n    if (iLSs(l, L(p[i], p[(i + 1) % p.size()]))) q.push_back(pLL(l, L(p[i], p[(i + 1) % p.size()])));\n  }\n  return q;\n}\n\n// 線分をマージする\nvector<L> merge(vector<L> s) {\n  rep (i, s.size()) if (s[i].second < s[i].first) swap(s[i].first, s[i].second);\n  sort(s.begin(), s.end());\n  rep (i, s.size()) rep (j, i) if (iSS(s[i], s[j]) && !iLL(s[i], s[j])) {\n    s[j].second = max(s[i].second, s[j].second);\n    s.erase(s.begin() + i--);\n    break;\n  }\n  return s;\n}\n\n// 線分アレンジメント 隣の点への辺のみを持つ\npair<vector<P>, vector<vector<int> > > sArr(vector<L> s) {\n  s = merge(s);\n  vector<P> vp;\n  rep (i, s.size()) {\n    vp.push_back(s[i].first);\n    vp.push_back(s[i].second);\n  }\n  rep (i, s.size()) rep (j, i) if (iSS(s[i], s[j])) {\n    vp.push_back(pLL(s[i], s[j]));\n  }\n  sort(vp.begin(), vp.end());\n  vp.erase(unique(vp.begin(), vp.end(), near), vp.end());\n  vector<vector<int> > g(vp.size());\n  rep (i, s.size()) {\n    vector<pair<D, int> > v;\n    rep (j, vp.size()) if (ccw(s[i], vp[j]) == ON) v.push_back(make_pair(norm(vp[j] - s[i].first), j));\n    sort(v.begin(), v.end());\n    rep (j, v.size() - 1) {\n      g[v[j + 1].second].push_back(v[j].second);\n      g[v[j].second].push_back(v[j + 1].second);\n    }\n  }\n  return make_pair(vp, g);\n}\n\nvector<Pol> dual(vector<L> s) {\n  pair<vector<P>, vector<vector<int> > > arr = sArr(s);\n  vector<P> vp = arr.first;\n  vector<vector<int> > edge = arr.second;\n  vector<vector<bool> > used(edge.size());\n  rep (i, edge.size()) rep (j, edge[i].size()) used[i].push_back(false);\n  vector<Pol> vpol;\n  rep (i, edge.size()) rep (j, edge[i].size()) if (!used[i][j]) {\n    Pol pol;\n    pol.push_back(vp[i]);\n    used[i][j] = true;\n    int pre = i, now = edge[i][j];\n    while (now != i) {\n      pol.push_back(vp[now]);\n      D a = -4;\n      int next = -1;\n      rep (k, edge[now].size()) {\n\tD aa = ang(vp[now], (D)2 * vp[now] - vp[pre], vp[edge[now][k]]);\n\tif (eq(aa, PI)) aa = -PI;\n\tif (a < aa) {\n\t  a = aa;\n\t  next = k;\n\t}\n      }\n      used[now][next] = true;\n      pre = now;\n      now = edge[pre][next];\n    }\n    vpol.push_back(pol);\n  }\n  return vpol;\n}\n\nint main() {\n  while (true) {\n    int c, w;\n    cin >> c >> w;\n    if (c == 0 && w == 0) break;\n    vector<P> vp(c);\n    vector<L> vl(w);\n    rep (i, c) cin >> vp[i].X >> vp[i].Y;\n    rep (i, w) {\n      int s, t;\n      cin >> s >> t;\n      --s; --t;\n      vl[i] = L(vp[s], vp[t]);\n    }\n    vector<Pol> vpol = dual(vl);\n    vector<int> dis;\n    priority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > > que;\n    rep (i, vpol.size()) {\n      if (aPol(vpol[i]) < 0) {\n\tque.push(make_pair(0, i));\n      }\n      dis.push_back(int(1e9));\n    }\n    vector<vector<int> > edge(vpol.size());\n    rep (i, vpol.size()) rep (j, i) rep (ii, vpol[i].size()) rep (jj, vpol[j].size()) {\n      if (near(vpol[i][ii], vpol[j][(jj + 1) % vpol[j].size()]) && near(vpol[i][(ii + 1) % vpol[i].size()], vpol[j][jj])) {\n\tedge[i].push_back(j);\n\tedge[j].push_back(i);\t\n      }\n    }\n    while (!que.empty()) {\n      pair<int, int> now = que.top();\n      que.pop();\n      if (dis[now.second] <= now.first) continue;\n      dis[now.second] = now.first;\n      rep (i, edge[now.second].size()) que.push(make_pair(now.first + 1, edge[now.second][i]));\n    }\n    int res = 0;\n    rep (i, dis.size()) res = max(res, dis[i]);\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <functional>\n#include <iterator>\n#include <limits>\n#include <numeric>\n#include <utility>\n#include <cmath>\n#include <cassert>\n#include <cstdio>\n\nusing namespace std; using namespace placeholders;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector< int > VI;\ntypedef vector< vector< int > > VVI;\ntypedef vector< string > VS;\ntypedef stringstream SS;\ntypedef pair< int, int > PII;\ntypedef vector< pair< int, int > > VPII;\n#define VT( T ) vector< T >\n#define VVT( T ) vector< vector< T > >\n#define LIM( T ) numeric_limits< T >\n\ntemplate < typename T > inline istream& operator>>( istream &s, vector< T > &v ){ for ( T &t : v ) { s >> t; } return s; }\ntemplate < typename T > inline ostream& operator<<( ostream &s, const vector< T > &v ){ for ( int i = 0; i < int( v.size() ); ++i ){ s << ( \" \" + !i ) << v[i]; } return s; }\ntemplate < typename T > inline T fromString( const string &s ) { T res; istringstream iss( s ); iss >> res; return res; };\ntemplate < typename T > inline string toString( const T &a ) { ostringstream oss; oss << a; return oss.str(); };\n\n#define REP2( i, n ) REP3( i, 0, n )\n#define REP3( i, m, n ) for ( int i = ( int )( m ); i < ( int )( n ); ++i )\n#define GET_REP( a, b, c, F, ... ) F\n#define REP( ... ) GET_REP( __VA_ARGS__, REP3, REP2 )( __VA_ARGS__ )\n#define FOR( e, c ) for ( auto &e : c )\n#define ALL( c ) ( c ).begin(), ( c ).end()\n#define AALL( a, t ) ( t* )a, ( t* )a + sizeof( a ) / sizeof( t )\n#define DRANGE( c, p ) ( c ).begin(), ( c ).begin() + p, ( c ).end()\n\n#define SZ( v ) ( (int)( v ).size() )\n#define PB push_back\n#define EM emplace\n#define EB emplace_back\n#define BI back_inserter\n\n#define EXIST( c, e ) ( ( c ).find( e ) != ( c ).end() )\n\n#define MP make_pair\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\n#include <complex>\ntypedef complex< double > Point;\nconstexpr double EPS = 1e-8;\nconstexpr double PI = acos( -1 );\nconstexpr Point O( 0, 0 );\n\n// 入力ストリームから実数二つをとって Point へ\nistream& operator>> ( istream &s, Point &a )\n{\n\tdouble r, i;\n\ts >> r >> i;\n\ta = Point( r, i );\n\treturn s;\n}\n\n// 偏角\nstruct CompArg : public binary_function<Point,Point,bool>\n{\n\tbool operator ()( const Point &a, const Point &b ) const\n\t{\n\t\treturn arg( a ) < arg( b );\n\t}\n};\n\n// 内積（ドット積）\ndouble dot( const Point &a, const Point &b )\n{\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\n\n// 外積（クロス積）\ndouble cross( const Point &a, const Point &b )\n{\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\n\nclass DualGraph\n{\n\ttypedef std::tuple< int, int, int, Point > Edge;\n\t// ( to, rev-edge, edge id, angle )\n\n\tconst int N;\n\tint M;\n\tconst std::vector< Point > ps_;\n\tstd::vector< std::vector< Edge > > G;\n\tstd::vector< std::vector< int > > edge_indices_, edge_poss_;\n\tstd::vector< std::vector< bool > > used_;\n\n\tint outer_ = -1;\n\tstd::vector< std::vector< Point > > areas_;\n\n\tstd::vector< std::vector< int > > intersects_;\n\npublic:\n\tDualGraph( const std::vector< Point > &ps ) :\n\t\tN( ps.size() ), M( 0 ), ps_( ps ), G( N ), edge_indices_( N ), edge_poss_( N ), used_( N )\n\t{\n\t\treturn;\n\t}\n\n\tvoid connect( const int a, const int b )\n\t{\n\t\tG[a].emplace_back( b, G[b].size(), M, ps_[b] - ps_[a] );\n\t\tG[b].emplace_back( a, G[a].size() - 1, M, ps_[a] - ps_[b] );\n\t\t++M;\n\n\t\treturn;\n\t}\n\n\tvoid solve()\n\t{\n\t\tsort_edges();\n\n\t\tfor ( int v = 0; v < N; ++v )\n\t\t{\n\t\t\tfor ( int i = 0; i < int( G[v].size() ); ++i )\n\t\t\t{\n\t\t\t\tif ( used_[v][i] )\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tdfs( v, i );\n\t\t\t}\n\t\t}\n\n\t\treturn;\n\t}\n\nprivate:\n\tvoid sort_edges()\n\t{\n\t\tCompArg comp;\n\t\tfor ( int v = 0; v < N; ++v )\n\t\t{\n\t\t\tedge_indices_[v].resize( G[v].size() );\n\t\t\tstd::iota( begin( edge_indices_[v] ), end( edge_indices_[v] ), 0 );\n\n\t\t\tstd::sort( begin( edge_indices_[v] ), end( edge_indices_[v] ), \n\t\t\t\t\t[&]( const int i, const int j ){ return comp( get< 3 >( G[v][i] ), get< 3 >( G[v][j] ) ); } );\n\n\t\t\tedge_poss_[v].resize( G[v].size() );\n\t\t\tfor ( int i = 0; i < int( G[v].size() ); ++i )\n\t\t\t{\n\t\t\t\tedge_poss_[v][ edge_indices_[v][i] ] = i;\n\t\t\t}\n\n\t\t\tused_[v].resize( G[v].size() );\n\t\t}\n\t\tintersects_.resize( M );\n\n\t\treturn;\n\t}\n\n\tvoid dfs( const int sv, const int se )\n\t{\n\t\tstd::vector< Point > area;\n\n\t\tfor ( int v = sv, e = se; area.empty() || v != sv; )\n\t\t{\n\t\t\tused_[v][e] = true;\n\t\t\tarea.push_back( ps_[v] );\n\t\t\tintersects_[ get< 2 >( G[v][e] ) ].push_back( areas_.size() );\n\n\t\t\tconst int r = get< 1 >( G[v][e] );\n\t\t\tv = get< 0 >( G[v][e] );\n\t\t\te = edge_indices_[v][ ( edge_poss_[v][r] + G[v].size() - 1 ) % G[v].size() ];\n\t\t}\n\n\t\t{\n\t\t\tdouble theta = 0;\n\t\t\tfor ( int i = 0; i < int( area.size() ); ++i )\n\t\t\t{\n\t\t\t\tconst Point p1 = area[ ( i + 1 ) % area.size() ] - area[i];\n\t\t\t\tconst Point p2 = area[ ( i + 2 ) % area.size() ] - area[i];\n\t\t\t\ttheta += atan2( cross( p1, p2 ), dot( p1, p2 ) );\n\t\t\t}\n\t\t\tif ( theta < 0 )\n\t\t\t{\n\t\t\t\touter_ = areas_.size();\n\t\t\t}\n\t\t}\n\n\t\tareas_.push_back( area );\n\t\t\n\t\treturn;\n\t}\n\n\t// results\npublic:\n\tint area_number() const\n\t{\n\t\treturn areas_.size();\n\t}\n\n\tstd::vector< std::vector< Point > > areas() const\n\t{\n\t\treturn areas_;\n\t}\n\n\tstd::vector< std::pair< int, int > > edges() const\n\t{\n\t\tstd::vector< std::pair< int, int > > res;\n\t\tfor ( auto &row : intersects_ )\n\t\t{\n\t\t\tres.emplace_back( row[0], row[1] );\n\t\t}\n\t\treturn res;\n\t}\n\n\tint outer() const\n\t{\n\t\treturn outer_;\n\t}\n};\n\nconstexpr int INF = LIM( int )::max() / 2;\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\tfor ( int N, M; cin >> N >> M && ( N | M ); )\n\t{\n\t\tVT( Point ) ps( N );\n\t\tcin >> ps;\n\n\t\tVI s( M ), t( M );\n\t\tREP( i, M )\n\t\t{\n\t\t\tcin >> s[i] >> t[i];\n\t\t\t--s[i], --t[i];\n\t\t}\n\n\t\tDualGraph dualgraph( ps );\n\t\tREP( i, M )\n\t\t{\n\t\t\tdualgraph.connect( s[i], t[i] );\n\t\t}\n\t\tdualgraph.solve();\n\n\t\tconst int V = dualgraph.area_number();\n\t\tVVI G( V );\n\t\t{\n\t\t\tVPII es = dualgraph.edges();\n\t\t\tFOR( e, es )\n\t\t\t{\n\t\t\t\tconst int a = e.fst, b = e.snd;\n\t\t\t\tG[a].PB( b );\n\t\t\t\tG[b].PB( a );\n\t\t\t}\n\t\t}\n\n\t\tVI distances( V, INF );\n\t\tdistances[ dualgraph.outer() ] = 0;\n\n\t\tqueue< int > que;\n\t\tque.push( dualgraph.outer() );\n\n\t\twhile ( !que.empty() )\n\t\t{\n\t\t\tconst int u = que.front();\n\t\t\tque.pop();\n\n\t\t\tFOR( v, G[u] )\n\t\t\t{\n\t\t\t\tif ( distances[u] + 1 < distances[v] )\n\t\t\t\t{\n\t\t\t\t\tdistances[v] = distances[u] + 1;\n\t\t\t\t\tque.push( v );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << *max_element( ALL( distances ) ) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "int leftmost;\nint outside_color;\n\n// Library.\n#include<cassert>\n#include<map>\n#include<vector>\n#include<cmath>\n#include<queue>\n#include<algorithm>\n// Type.\ntypedef int Label;\ntypedef double Weight;\n// Class.\ntemplate<typename Vertex, typename Edge>\nclass PlaneGraph {\npublic:\n  void insert(const Vertex& v);\n  void insert(Edge e);\n  const PlaneGraph<Vertex, Edge> dualgraph() const;\n  const std::map<Label, Weight> Dijkstra(const Label& start) const;\nprivate:\n  void dualgraph_color(std::map<Label, std::map<Label, int>>& color, int c, const Edge& e, const std::map<Label, std::vector<Edge>>& edge) const;\n  std::map<Label, Vertex> V;\n  std::map<Label, std::vector<Edge>> E;\n};\n// Implement.\ntemplate<typename Vertex, typename Edge>\nvoid PlaneGraph<Vertex, Edge>::insert(const Vertex& v) {\n  V[v.label] = v;\n}\ntemplate<typename Vertex, typename Edge>\nvoid PlaneGraph<Vertex, Edge>::insert(Edge e) {\n  assert(V.find(e.from) != std::end(V));\n  assert(V.find(e.to) != std::end(V));\n  E[e.from].push_back(e);\n  std::swap(e.from, e.to);\n  E[e.from].push_back(e);\n}\ntemplate<typename Vertex, typename Edge>\nconst PlaneGraph<Vertex, Edge> PlaneGraph<Vertex, Edge>::dualgraph() const {\n  // Sort edges counterclockwise.\n  auto edge = E;\n  for(auto& list: edge) if(!list.second.empty()) {\n    std::sort(std::begin(list.second), std::end(list.second), [&](const Edge& lhs, const Edge& rhs) {\n      double l = std::atan2(V.at(lhs.to).y - V.at(lhs.from).y, V.at(lhs.to).x - V.at(lhs.from).x);\n      double r = std::atan2(V.at(rhs.to).y - V.at(rhs.from).y, V.at(rhs.to).x - V.at(rhs.from).x);\n      return l < r;\n    });\n    list.second.push_back(list.second.front());\n  }\n  // Color edges.\n  std::map<Label, std::map<Label, int>> color;\n  int c = 1;\n  for(const auto& list: edge) {\n    for(const auto& e: list.second) if(!color[e.from].count(e.to)) dualgraph_color(color, c++, e, edge);\n    if(list.first == leftmost) outside_color = color[list.second.front().from][list.second.front().to];\n  }\n  // Construct the dualgraph.\n  PlaneGraph<Vertex, Edge> result;\n  std::vector<std::vector<bool>> used(c, std::vector<bool>(c, false));\n  for(int i = 1; i < c; ++i) result.insert(Vertex({i}));\n  for(const auto& list: E) for(const auto& e: list.second) if(!used[color[e.from][e.to]][color[e.to][e.from]]) {\n    used[color[e.from][e.to]][color[e.to][e.from]] = true;\n    used[color[e.to][e.from]][color[e.from][e.to]] = true;\n    result.insert(Edge({color[e.from][e.to], color[e.to][e.from], 1}));\n  }\n  return result;\n}\ntemplate<typename Vertex, typename Edge>\nvoid PlaneGraph<Vertex, Edge>::dualgraph_color(std::map<Label, std::map<Label, int>>& color, int c, const Edge& e, const std::map<Label, std::vector<Edge>>& edge) const {\n  color[e.from][e.to] = c;\n  for(auto it = edge.at(e.to).rbegin(); it != edge.at(e.to).rend(); ++it) if(it->to == e.from) {\n    ++it;\n    if(!color[it->from].count(it->to)) dualgraph_color(color, c, *it, edge);\n    break;\n  }\n}\ntemplate<typename Vertex, typename Edge>\nconst std::map<Label, Weight> PlaneGraph<Vertex, Edge>::Dijkstra(const Label& start) const {\n  std::map<Label, Weight> result;\n  std::priority_queue<Edge, std::vector<Edge>, std::function<bool(Edge, Edge)>> q([](Edge lhs, Edge rhs) {\n    return lhs.weight >= rhs.weight;\n  });\n  q.push(Edge({start, start, 0}));\n  while(!q.empty()) {\n    auto cur = q.top();\n    q.pop();\n    result[cur.to] = cur.weight;\n    for(const auto& nex: E.at(cur.to)) if(!result.count(nex.to)) q.push(Edge({nex.from, nex.to, cur.weight + nex.weight}));\n  }\n  return result;\n}\n////////////////////////////////////////\n// Configuration.\nstruct Vertex {Label label; double x, y;};\nstruct Edge {Label from, to; Weight weight;};\n////////////////////////////////////////\n#include<bits/stdc++.h>\nusing namespace std;\nint main() {\n  int C, W;\n  while(cin >> C >> W, C | W) {\n    vector<Vertex> pillar;\n    int leftmost_x = 1000;\n    for(int i = 0; i < C; ++i) {\n      double x, y;\n      cin >> x >> y;\n      pillar.push_back({i, x, y});\n      if(leftmost < x) continue;\n      leftmost_x = x;\n      leftmost = i;\n    }\n    PlaneGraph<Vertex, Edge> G;\n    for(const auto& p: pillar) G.insert(p);\n    for(int i = 0; i < W; ++i) {\n      int s, t;\n      cin >> s >> t;\n      --s; --t;\n      G.insert(Edge({s, t, 1}));\n    }\n    auto D = G.dualgraph();\n    auto distance = D.Dijkstra(outside_color);\n    double answer = 0;\n    for(const auto& d: distance) answer = max(answer, d.second);\n    cout << answer << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <vector>\n#include <valarray>\n#include <array>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <random>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\ntypedef long double R;\ntypedef complex<R> P;\n\nconst R EPS = 1e-10;\nconst R PI = acos((R)(-1));\n\nint sgn(R a) {\n    if (a < -EPS) return -1;\n    if (a > EPS) return 1;\n    return 0;\n}\n\nR cross(P a, P b) { return a.real()*b.imag() - a.imag()*b.real(); }\n\ntypedef vector<P> Pol;\n\nP cu(const Pol &p, int i) {\n    int s = p.size();\n    return p[(i%s+s)%s];\n}\n\nR area_naive(const Pol &p) {\n    R u = 0;\n    for (int i = 0; i < (int)p.size(); i++) {\n        u += cross(cu(p, i), cu(p, i+1));\n    }\n    return u/2;\n}\n\nR area(const Pol &p) {\n    return abs(area_naive(p));\n}\n\n/*\n -1 -> clock\n 0 -> non polygon\n 1 -> counter clock\n */\nbool iscclock(const Pol &p) {\n    return sgn(area_naive(p));\n}\n\nint dualGraph(P p[], vector<int> g[], int n,\n    Pol pol[], vector<int> rg[]) {\n    map<pair<int, int>, int> mp;\n    for (int i = 0; i < n; i++) {\n        sort(g[i].begin(), g[i].end(), [&](int l, int r){\n            return arg(p[l]-p[i]) > arg(p[r]-p[i]);\n        });\n        for (int j = 0; j < (int)g[i].size(); j++) {\n            mp[make_pair(i, g[i][j])] = j;\n        }\n    }\n\n    vector<vector<int>> idx(n), rev(n);\n    for (int i = 0; i < n; i++) {\n        idx[i] = vector<int>(g[i].size(), -3);\n        rev[i].resize(g[i].size());\n        for (int j = 0; j < (int)g[i].size(); j++) {\n            rev[i][j] = mp[make_pair(g[i][j], i)];\n        }\n    }\n\n    int idc = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < (int)g[i].size(); j++) {\n            if (idx[i][j] != -3) continue;\n            Pol po;\n            int ii = i, jj = j;\n            while (idx[ii][jj] != -2) {\n                po.push_back(p[ii]);\n                idx[ii][jj] = -2;\n                int ni = g[ii][jj];\n                int nj = (rev[ii][jj]+1) % g[ni].size();\n                ii = ni; jj = nj;\n            }\n            int id;\n            if (area(po) == 0 || !iscclock(po)) {\n                id = -1;\n            } else {\n                id = idc;\n                pol[idc] = po;\n                idc++;\n            }\n            while (idx[ii][jj] == -2) {\n                idx[ii][jj] = id;\n                int ni = g[ii][jj];\n                int nj = (rev[ii][jj]+1) % g[ni].size();\n                ii = ni; jj = nj;\n            }\n        }\n    }\n\n    for (int i = 0; i < idc; i++) {\n        rg[i].clear();\n    }\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < (int)g[i].size(); j++) {\n            if (idx[i][j] < 0) continue;\n            rg[idx[i][j]].push_back(idx[g[i][j]][rev[i][j]]);\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        sort(rg[i].begin(), rg[i].end());\n        rg[i].erase(unique(rg[i].begin(), rg[i].end()), rg[i].end());\n    }\n\n    return idc;\n}\n\nconst int MN = 110;\nP p[MN];\nvector<int> g[MN];\n\nPol pol[2*MN];\nvector<int> rg[2*MN];\n\nint dist[2*MN][2*MN];\n\nbool solve() {\n    int c, w;\n    cin >> c >> w;\n    if (!c) return false;\n\n    for (int i = 0; i < c; i++) {\n        R x, y;\n        cin >> x >> y;\n        p[i] = P(x, y);\n        g[i].clear();\n    }\n\n    for (int i = 0; i < w; i++) {\n        int s, t;\n        cin >> s >> t; s--; t--;\n        g[s].push_back(t);\n        g[t].push_back(s);\n    }\n\n    int m = dualGraph(p, g, c, pol, rg);\n\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < m; j++) {\n            dist[i][j] = 10000;\n        }\n        for (int d: rg[i]) {\n            dist[i][d] = 1;\n        }\n        dist[i][i] = 0;\n    }\n\n    for (int k = 0; k < m; k++) {\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < m; j++) {\n                dist[i][j] = min(dist[i][j], dist[i][k]+dist[k][j]);\n            }\n        }\n    }\n\n    int ma = 0;\n    for (int i = 0; i < m; i++) {\n        ma = max(ma, dist[0][i]);\n    }\n    cout << ma << endl;\n    return true;\n}\n\n\nint main() {\n    while (solve()) {}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<utility>\n#include<map>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n\nusing namespace std;\n\nstruct Point{\n\tint x,y;\n\tint id;\n\tPoint(){}\n\tPoint(int a,int b,int c):x(a),y(b),id(c){}\n};\n\nPoint points[110];\nint pid[110];\n\nbool cmp(const Point &p1,const Point &p2)\n{\n\tif(p1.x!=p2.x) return p1.x<p2.x;\n\treturn p1.y<p2.y;\n}\n\nint center;\n\nbool cmp_angle(const int &id1,const int &id2)\n{\n\tint center=pid[::center];\n\tint id1_=pid[id1],id2_=pid[id2];\n\tint dx1=points[id1_].x-points[center].x;\n\tint dy1=points[id1_].y-points[center].y;\n\tint dx2=points[id2_].x-points[center].x;\n\tint dy2=points[id2_].y-points[center].y;\n\t//(-y,x)\n\tdouble ang1=atan2(dx1,-dy1);\n\tdouble ang2=atan2(dx2,-dy2);\n\treturn ang1<ang2;\n}\n/*\nstruct cmp_angle_{\n\tbool operator()(const int &id1,const int &id2)\n\t{\n\tint center=pid[::center];\n\tint id1_=pid[id1],id2_=pid[id2];\n\tint dx1=points[id1_].x-points[center].x;\n\tint dy1=points[id1_].y-points[center].y;\n\tint dx2=points[id2_].x-points[center].x;\n\tint dy2=points[id2_].y-points[center].y;\n\t//(-y,x)\n\tdouble ang1=atan2(dx1,-dy1);\n\tdouble ang2=atan2(dx2,-dy2);\n\treturn ang1<ang2;\n\t}\n};*/\n\nvector<int> G[110];\n\nvector<vector<int> > vs;\nvector<int> dG[550];\n//bool con[550][550];\n\ntypedef pair<int,int> P;\n\nmap<P,int> cnt;\nqueue<P> que;\n\nvoid init()\n{\n\tvs.clear();\n\tfor(int i=0;i<110;i++) G[i].clear();\n\tfor(int i=0;i<550;i++) dG[i].clear();\n\tcnt.clear();\n}\n\nvector<int> res;\nvoid stroke(int u,int v,int st)\n{\n\t//u->v\n\tP p=P(min(u,v),max(u,v));\n\tif(cnt[p]==0)\n\t{\n\t\tque.push(P(v,u));\n\t}\n\tcnt[p]++;\n\tif(v==st) return;\n\tif(u==st) res.push_back(u);\n\tres.push_back(v);\n//\tprintf(\"x%dx\\n\",v);\n\tcenter=v;\n\tint id=distance(G[v].begin(),lower_bound(G[v].begin(),G[v].end(),u,cmp_angle));\n//\tprintf(\"%d::%d %d\\n\",v,G[v].size(),id);\n\tif(id==G[v].size()-1) id=0;\n\telse id++;\n\tint nxt=G[v][id];\n\tstroke(v,nxt,st);\n}\n\nvoid getGraph()\n{\n\tint V=vs.size();\n\tfor(int i=0;i<V;i++) for(int j=i+1;j<V;j++)\n\t{\n\t\tint ni=vs[i].size(),nj=vs[j].size();\n\t\tbool flg=false;\n\t\tfor(int iid=0;iid<ni;iid++) for(int jid=0;jid<nj;jid++)\n\t\t{\n\t\t\tint niid=iid==ni-1?0:iid+1;\n\t\t\tint njid=jid==nj-1?0:jid+1;\n\t\t\tif(vs[i][iid]==vs[j][njid]&&vs[i][niid]==vs[j][jid]) flg=true;\n\t\t}\n\t\tif(flg)\n\t\t{\n\t\t\tdG[i].push_back(j);\n\t\t\tdG[j].push_back(i);\n\t\t}\n\t//\tcon[i][j]=flg;\n\t//\tcon[j][i]=flg;\n\t}\n}\n\nint getMostOutSide()\n{\n\tint u=points[0].id;\n\tint v=G[u][0];\n//\tprintf(\"----------------%d %d\\n\",u,v);\n//\tprintf(\"%d %d %d %d\\n\",points[u].x,points[u].y,points[v].x,points[v].y);\n\tfor(int i=0;i<vs.size();i++)\n\t{\n\t\tfor(int j=0;j+1<vs[i].size();j++)\n\t\t{\n\t\t\tif(vs[i][j]==u&&vs[i][j+1]==v) return i;\n\t\t}\n\t\tif(vs[i][vs[i].size()-1]==u&&vs[i][0]==v) return i;\n\t}\n\treturn -1;\n}\n\nint dis[550];\nqueue<int> bfs_que;\nvoid bfs(int s)\n{\n//\tprintf(\"xxxxxxxxxxxxxxxxxxxxx\\n\");\n\twhile(!bfs_que.empty()) bfs_que.pop();\n\tbfs_que.push(s);\n\tfor(int i=0;i<550;i++) dis[i]=1<<29;\n\tdis[s]=0;\n\tbfs_que.push(s);\n\twhile(!bfs_que.empty())\n\t{\n\t\tint v=bfs_que.front();\n//\t\tprintf(\"bfs %d\\n\",v);\n\t\tbfs_que.pop();\n\t\tfor(int i=0;i<dG[v].size();i++)\n\t\t{\n\t\t\tint u=dG[v][i];\n\t\t\tint nd=dis[v]+1;\n\t\t\tif(nd>=dis[u]) continue;\n\t\t\tdis[u]=nd;\n\t\t\tbfs_que.push(u);\n\t\t}\n\t}\n}\n\nvoid outputdG()\n{\n\tprintf(\"-----dual\\n\");\n\tfor(int i=0;i<vs.size();i++)\n\t{\n\t\tprintf(\"%d-\",i);\n\t\tfor(int j=0;j<dG[i].size();j++)\n\t\t{\n\t\t\tprintf(\"%d \",dG[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}\n\nint main()\n{\n\twhile(true)\n\t{\n\t\tint C,W;\n\t\tscanf(\"%d%d\",&C,&W);\n\t\tif(C==0) break;\n\t\tinit();\n\t\tfor(int i=0;i<C;i++)\n\t\t{\n\t\t\tint x,y;\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\tpoints[i]=Point(x,y,i);\n\t\t}\n\t\tsort(points,points+C,cmp);\n\t\tfor(int i=0;i<C;i++) pid[points[i].id]=i;\n\t\tint su=-1,sv=-1;\n\t\tfor(int i=0;i<W;i++)\n\t\t{\n\t\t\tint u,v;\n\t\t\tscanf(\"%d%d\",&u,&v);\n\t\t\tu--;v--;\n\t\t\tG[u].push_back(v);\n\t\t\tG[v].push_back(u);\n\t\t\tsu=u,sv=v;\n\t\t}\n\t\tfor(int i=0;i<C;i++)\n\t\t{\n\t\t\tcenter=i;\n\t\t\tsort(G[i].begin(),G[i].end(),cmp_angle);\n//\t\t\tprintf(\"%d:::\",i);\n//\t\t\tfor(int j=0;j<G[i].size();j++) printf(\"%d \",G[i][j]);\n//\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tque.push(P(min(su,sv),max(su,sv)));\n\t\twhile(!que.empty())\n\t\t{\n\t\t\tP p=que.front();\n\t\t\tque.pop();\n\t\t\tint u=p.first,v=p.second;\n//\t\t\tprintf(\"pop %d %d\\n\",u,v);\n\t\t\tP pp=P(min(u,v),max(u,v));\n\t\t\tif(cnt[pp]==2) continue;\n\t\t//\tbool flg;\n\t\t//\tif(cnt[pp]==1) flg=false;\n\t\t//\telse flg=true;\n\t\t\tres.clear();\n\t\t\tstroke(u,v,u);\n\t\t\tvs.push_back(res);\n//\t\t\tfor(int i=0;i<res.size();i++) printf(\"%d \",res[i]);\n//\t\t\tprintf(\"aaa\\n\");\n\t\t//\tcnt[pp]++;\n\t\t//\tif(flg) que.push(P(v,u));\n\t\t}\n//\t\tfor(int i=0;i<vs.size();i++)\n//\t\t{\n//\t\t\tvector<int> vec=vs[i];\n//\t\t\tprintf(\"a:\");\n//\t\t\tfor(int j=0;j<vec.size();j++) printf(\"%d \",vec[j]);\n//\t\t\tprintf(\"\\n\");\n//\t\t}\n\t\tgetGraph();\n\t\tint out=getMostOutSide();\n\t\tbfs(out);\n\t\tint ans=0;\n\t\tfor(int i=0;i<vs.size();i++) ans=max(ans,dis[i]);\n//\t\toutputdG();\n//\t\tprintf(\"---------%d--------------ans=%d\\n\",out,ans);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n#include<utility>\n#include<cstring>\n#include<vector>\n#include<queue>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define fs first\n#define sc second\nusing namespace std;\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\nconst D EPS = 1e-9;\nconst D PI = acos(-1);\n\nD dot(P x,P y){return real(conj(x)*y);}\nD cross(P x,P y){return imag(conj(x)*y);}\nD arg(P a,P b,P c){return acos(dot(b-a,c-a)/(abs(b-a)*abs(c-a)));}\n\nint c,w;\nD x,y;\nP p[110];\npair<int,int> l[330];\nint g[330][2];\nvector<int> wall[110];\nint s,t;\nint dis[1100];\n\nint main(){\n  while(cin >> c >> w, c){\n    rep(i,c){\n      cin >> x >> y; p[i] = P(x,y);\n      wall[i].clear();\n    }\n\n    rep(i,w){\n      cin >> s >> t; s--; t--;\n      l[i] = make_pair(s,t);\n      wall[s].push_back(t); wall[t].push_back(s);\n    }\n\n    rep(i,c){\n      for(int j=1;j<(int)wall[i].size();j++){\n\tfor(int k=j+1;k<(int)wall[i].size();k++){\n\t  D s1 = arg(p[i],p[wall[i][0]],p[wall[i][j]]);\n\t  if(cross(p[wall[i][0]]-p[i],p[wall[i][j]]-p[i])<EPS)s1 = 2*PI-s1;\n\t  D s2 = arg(p[i],p[wall[i][0]],p[wall[i][k]]); \n\t  if(cross(p[wall[i][0]]-p[i],p[wall[i][k]]-p[i])<EPS)s2 = 2*PI-s2;\n\t  if(s1<s2)swap(wall[i][j],wall[i][k]);\n\t}\n      }\n    }\n    /*\n    rep(i,c){\n      rep(j,wall[i].size())cout << wall[i][j] << \" \" ;cout << endl;\n    }\n    cout << endl;\n    */\n\n    memset(dis,-1,sizeof(dis));\n    memset(g,-1,sizeof(g));\n    int group = 0;\n\n    rep(i,c){\n      rep(j,wall[i].size()){\n\tint cur = -1, dir = -1;\n\trep(k,w){\n\t  if(i == l[k].fs && wall[i][j] == l[k].sc){\n\t    cur = k; dir = 0; break;\n\t  }\n\t  if(i == l[k].sc && wall[i][j] == l[k].fs){\n\t    cur = k; dir = 1;  break;\n\t  }\n\t}\n\tif(g[cur][dir]>=0)continue;\n\n\tD area = 0;\n\twhile(true){\n\t  //cout << cur+1 << \" \" << dir << endl;\n\t  g[cur][dir] = group;\n\t  \n\t  int node = dir?l[cur].fs:l[cur].sc;\n\t  int prv = dir?l[cur].sc:l[cur].fs;\n\t  //cout << \"[\" << prv+1 << \", \" << node+1 << \"]\" << endl; \n\t  rep(k,wall[node].size()){\n\t    if(wall[node][k] == prv){\n\t      int nxt = wall[node][(k+1)%wall[node].size()];\n\t      area += cross(p[prv]-p[node],p[nxt]-p[node]);\n\t      prv = node;\n\t      node = nxt;\n\t      break;\n\t    }\n\t  }\n\n\t  rep(k,w){\n\t    if(prv == l[k].fs && node == l[k].sc){\n\t      cur = k; dir = 0; break;\n\t    }\n\t    if(prv == l[k].sc && node == l[k].fs){\n\t      cur = k; dir = 1;  break;\n\t    }\n\t  }\n\t  if(g[cur][dir]>=0)break;\n\t}\n\t//cout << area << endl;\n\t//cout << endl;\n\tif(area>EPS)dis[group] = 0;\n\tgroup++;\n      }\n    }\n\n    //cout << group << endl;\n\n    bool adj[1100][1100];\n    memset(adj,0,sizeof(adj));\n    rep(i,w){\n      adj[g[i][0]][g[i][1]] = adj[g[i][1]][g[i][0]] = 1;\n    }\n\n    /*\n    rep(i,group){\n      rep(j,group)cout << adj[i][j] << \" \";cout << endl;\n    }\n    */\n\n    queue<int> q;\n    rep(i,group){\n      if(dis[i] == 0)q.push(i);\n    }\n\n    int ans = 0;\n    while(q.size()){\n      int now = q.front(); q.pop();\n      rep(i,group){\n\tif(adj[now][i] && dis[i]<0){\n\t  ans = dis[i] = dis[now] + 1;\n\t  q.push(i);\n\t}\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cassert>\nusing namespace std;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n\treturn abs(a.real()-b.real()) > EPS ? real(a) < real(b) : imag(a) + EPS < imag(b);\n    //return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\nP readPoint(){\n\tdouble x,y;\n\tcin >> x >> y;\n\treturn P(x,y);\n}\n\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\ntypedef vector<P> G;\n\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\n\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\nP reflection(const L &l, const P &p) {\n  return p + 2. * (projection(l, p) - p);\n}\ndouble distanceLP(const L &l, const P &p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\n#define rep(i,N) for(int i = 0 ; i < N ; i++)\nP ps[110];\nvector<int> g[110];\n\nvector<int> normalize(vector<int> v){\n\tauto it = min_element(v.begin(),v.end());\n\trotate(v.begin(),it,v.end());\n\treturn v;\n}\n\nint done[110];\nvoid f(int a,int b,int s,vector<int> &v){\n\tv.push_back(b);\n\tif( b == s ) return;\n\tif( done[b]++ ) throw 0;\n\tsort(g[b].begin(),g[b].end(),[&](int x,int y){\n\t\tP A = ps[x] - ps[b];\n\t\tP B = ps[y] - ps[b];\n\t\treturn cross(A,B) > 0;\n\t});\n\trotate(g[b].begin(),find(g[b].begin(),g[b].end(),a),g[b].end());\n\tf(b,g[b][1],s,v);\n}\n\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n\ndouble area2(const G& P) {\n  double A = 0;\n  for (int i = 0; i < P.size(); ++i) \n    A += cross(curr(P, i), next(P, i));\n  return A;\n}\n\nint main(){\n\t\n\tint C,W;\n\twhile( cin >> C >> W && (C||W) ){\n\t\trep(i,C) ps[i] = readPoint();\n\t\trep(i,C) g[i].clear();\n\t\trep(i,W){\n\t\t\tint a,b;\n\t\t\tcin >> a >> b;\n\t\t\t--a,--b;\n\t\t\tg[a].push_back(b);\n\t\t\tg[b].push_back(a);\n\t\t}\n\t\tvector< vector<int> > poly;\n\t\tset< set<int> > prevs; \n\t\trep(i,C){\n\t\t\trep(j,g[i].size()){\n\t\t\t\ttry{\n\t\t\t\t\tmemset(done,0,sizeof(done));\n\t\t\t\t\tvector<int> v;\n\t\t\t\t\tf(i,g[i][j],i,v);\n\t\t\t\t\tif( prevs.count(set<int>(v.begin(),v.end())) ) continue;\n\t\t\t\t\tpoly.push_back(normalize(v));\n\t\t\t\t\tprevs.insert(set<int>(v.begin(),v.end()));\n\t\t\t\t}catch(int x){\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(poly.begin(),poly.end());\n\t\tpoly.erase(unique(poly.begin(),poly.end()),poly.end());\n\t\tsort(poly.begin(),poly.end(),[&](vector<int> a,vector<int> b){\n\t\t\tvector<P> g1,g2;\n\t\t\trep(k,a.size()) g1.push_back(ps[a[k]]);\n\t\t\trep(k,b.size()) g2.push_back(ps[b[k]]);\n\t\t\treturn abs(area2(g1)) > abs(area2(g2));\n\t\t});\n\t\tmap< pair<int,int>, vector<int> > edgs;\n\t\tfor(int i = 0 ; i < poly.size() ; i++){\n\t\t\tfor(int j = 0 ; j < poly[i].size() ; j++){\n\t\t\t\tint A = curr(poly[i],j);\n\t\t\t\t//cout << A << \" \";\n\t\t\t\tint B = next(poly[i],j);\n\t\t\t\tif( A > B ) swap(A,B);\n\t\t\t\tedgs[pair<int,int>(A,B)].push_back(i);\n\t\t\t}\n\t\t\t//cout << endl;\n\t\t}\n\t\tint M = poly.size();\n\t\tint wf[M][M];\n\t\trep(i,M) rep(j,M){\n\t\t\twf[i][j] = i==j?0:1e9;\n\t\t}\n\t\t\n\t\tfor( auto x : edgs ){\n\t\t\tvector<int> v = x.second;\n\t\t\tif( v.size() < 2 ) v.push_back(0);\n\t\t\tassert( v.size() != 3 );\n\t\t\tif( v[0] != v[1] ) wf[v[0]][v[1]] = wf[v[1]][v[0]] = 1;\n\t\t}\n\t\trep(i,M)rep(j,M)rep(k,M) wf[j][k] = min(wf[j][i]+wf[i][k],wf[j][k]);\n\t\tint ans = 1;\n\t\trep(i,M){\n\t\t\tans = max(ans,wf[i][0]);\n\t\t}\n\t\tcout << ans << endl;\n\t\t\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<int,pair<bool,double>> P2;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define min_3(a,b,c) min(a,min(b,c))\n#define max_3(a,b,c) max(a,max(b,c))\n#define mp1(a,b,c) P1(a,P(b,c))\n#define mp2(a,b,c) P2(a,pair<bool,double>(b,c))\n#define pque(a) priority_queue<a>\n#define rpque(a) priority_queue<a,vector<a>,greater<a>>\n\nconst int INF=1000000000;\nconst int dre_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dre_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\nconst int kaijou[10]={1,1,2,6,24,120,720,5040,40320,362880};\n\nbool com(P2 x,P2 y){\n\tif(x.sc.fr!=y.sc.fr)return x.sc.fr;\n\treturn x.sc.sc>=y.sc.sc;\n}\n\nint main(){\n\twhile(1){\n\t\tint c,w;\n\t\tint x[110],y[110];\n\t\tint s,t;\n\t\t\n\t\tscanf(\"%d%d\",&c,&w); if(c==0&&w==0)break;\n\t\trep1(i,c)scanf(\"%d%d\",&x[i],&y[i]);\n\t\t\n\t\tvector<P1> V_;\n\t\trep1(i,c){\n\t\t\tV_.pb(mp1(x[i],y[i],i));\n\t\t}\n\t\tsor(V_);\n\t\tvector<P2> vec_[110];\n\t\trep1(i,c){\n\t\t\tvec_[i].pb(mp2(0,false,-INF));\n\t\t\trep1(j,c){\n\t\t\t\tif(i==j)continue;\n\t\t\t\tif(x[i]<x[j]){\n\t\t\t\t\tvec_[i].pb(mp2(j,true,(double)(y[j]-y[i])/(x[j]-x[i])));\n\t\t\t\t}\n\t\t\t\telse if(x[i]>x[j]){\n\t\t\t\t\tvec_[i].pb(mp2(j,false,(double)(y[j]-y[i])/(x[j]-x[i])));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(y[j]>y[i])vec_[i].pb(mp2(j,true,(double)INF));\n\t\t\t\t\telse vec_[i].pb(mp2(j,true,(double)-INF));\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(vec_[i].begin(),vec_[i].end(),com);\n\t\t}\n\t\t\n\t\tint v,e;\n\t\tvector<int> V;\n\t\tbool edge[110][110];\n\t\tvector<int> vec[110];\n\t\t\n\t\tv=c; e=w;\n\t\trep(i,c)V.pb(V_[i].sc.sc);\n\t\trep(i,110)rep(j,110)edge[i][j]=false;\n\t\trep(i,e){\n\t\t\tscanf(\"%d%d\",&s,&t);\n\t\t\tedge[s][t]=true;\n\t\t\tedge[t][s]=true;\n\t\t}\n\t\trep1(i,c){\n\t\t\trep(j,vec_[i].size()){\n\t\t\t\tvec[i].pb(vec_[i][j].fr);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ret=0;\n\t\twhile(e>0){\n\t\t\tret++;\n\t\t\t\n\t\t\tint a=-1;\n\t\t\trep(i,V.size()){\n\t\t\t\trep(j,105){\n\t\t\t\t\tif(edge[V[i]][j]){a=V[i]; break;}\n\t\t\t\t}\n\t\t\t\tif(a!=-1)break;\n\t\t\t}\n\t\t\t\n\t\t\tint b=0,c=a;\n\t\t\twhile(1){\n\t\t\t\trep(i,vec[c].size()){\n\t\t\t\t\tif(vec[c][i]==b){\n\t\t\t\t\t\ti++; i%=vec[c].size();\n\t\t\t\t\t\twhile(!edge[c][vec[c][i]]){\n\t\t\t\t\t\t\ti++; i%=vec[c].size();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tedge[c][vec[c][i]]=false;\n\t\t\t\t\t\tedge[vec[c][i]][c]=false;\n\t\t\t\t\t\te--;\n\t\t\t\t\t\tb=c;\n\t\t\t\t\t\tc=vec[c][i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(c==a)break;\n\t\t\t}\n\t\t\t\n\t\t\tbool updata=true;\n\t\t\twhile(updata){\n\t\t\t\tupdata=false;\n\t\t\t\trep(i,110){\n\t\t\t\t\tint cnt=0;\n\t\t\t\t\tint t=-1;\n\t\t\t\t\trep(j,110){\n\t\t\t\t\t\tif(edge[i][j]){cnt++; t=j;}\n\t\t\t\t\t}\n\t\t\t\t\tif(cnt==1){\n\t\t\t\t\t\tupdata=true;\n\t\t\t\t\t\tedge[i][t]=false;\n\t\t\t\t\t\tedge[t][i]=false;\n\t\t\t\t\t\te--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<int,pair<bool,double> > P2;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define min_3(a,b,c) min(a,min(b,c))\n#define max_3(a,b,c) max(a,max(b,c))\n#define mp1(a,b,c) P1(a,P(b,c))\n#define mp2(a,b,c) P2(a,pair<bool,double>(b,c))\n#define pque(a) priority_queue<a>\n#define rpque(a) priority_queue<a,vector<a>,greater<a>>\n\nconst int INF=1000000000;\nconst int dre_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dre_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\nconst int kaijou[10]={1,1,2,6,24,120,720,5040,40320,362880};\n\nbool com(P2 x,P2 y){\n\tif(x.sc.fr!=y.sc.fr)return x.sc.fr;\n\treturn x.sc.sc>=y.sc.sc;\n}\n\nint main(){\n\tstatic int v,w;\n\tstatic int x[310],y[310];\n\tstatic int s,t;\n\tstatic vector<P1> V_;\n\tstatic vector<P2> vec_[310];\n\tstatic int e;\n\tstatic vector<int> V; \n\tstatic bool edge[310][310];\n\tstatic vector<int> vec[310]; \n\tint ppp=0;\n\twhile(1){\n\t\tscanf(\"%d%d\",&v,&w); if(v==0&&w==0)break;\n\t\trep1(i,v)scanf(\"%d%d\",&x[i],&y[i]);\n\t\t\n\t\tV_.clear();\n\t\trep1(i,v){\n\t\t\tV_.pb(mp1(x[i],-y[i],i));\n\t\t}\n\t\tsor(V_);\n\t\trep1(i,v){\n\t\t\tvec_[i].clear();\n\t\t\tvec_[i].pb(mp2(0,false,-INF));\n\t\t\trep1(j,v){\n\t\t\t\tif(i==j)continue;\n\t\t\t\tif(x[i]<x[j]){\n\t\t\t\t\tvec_[i].pb(mp2(j,true,(double)(y[j]-y[i])/(x[j]-x[i])));\n\t\t\t\t}\n\t\t\t\telse if(x[i]>x[j]){\n\t\t\t\t\tvec_[i].pb(mp2(j,false,(double)(y[j]-y[i])/(x[j]-x[i])));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(y[j]>y[i])vec_[i].pb(mp2(j,true,(double)INF));\n\t\t\t\t\telse vec_[i].pb(mp2(j,true,(double)-INF));\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(vec_[i].begin(),vec_[i].end(),com);\n\t\t}\n\t\t\n\t\tV.clear();\n\t\t\n\t\te=w;\n\t\trep(i,v)V.pb(V_[i].sc.sc);\n\t\trep(i,305)rep(j,305)edge[i][j]=false;\n\t\trep(i,e){\n\t\t\tscanf(\"%d%d\",&s,&t);\n\t\t\tedge[s][t]=true;\n\t\t\tedge[t][s]=true;\n\t\t}\n\t\trep1(i,v){\n\t\t\tvec[i].clear();\n\t\t\trep(j,vec_[i].size()){\n\t\t\t\tvec[i].pb(vec_[i][j].fr);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ret=0;\n\t\twhile(e>0){\n\t\t\tret++;\n\t\t\t\n\t\t\tint a=-1;\n\t\t\trep(i,V.size()){\n\t\t\t\trep(j,105){\n\t\t\t\t\tif(edge[V[i]][j]){a=V[i]; break;}\n\t\t\t\t}\n\t\t\t\tif(a!=-1)break;\n\t\t\t}\n\t\t\t\n\t\t\tint b=0,c=a;\n\t\t\twhile(1){\n\t\t\t\tif(c==-1||vec[c].size()==0)break;\n\t\t\t\trep(i,vec[c].size()){\n\t\t\t\t\tif(vec[c][i]==b){\n\t\t\t\t\t\ti++; i%=vec[c].size();\n\t\t\t\t\t\twhile(!edge[c][vec[c][i]]){\n\t\t\t\t\t\t\ti++; i%=vec[c].size();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tedge[c][vec[c][i]]=false;\n\t\t\t\t\t\tedge[vec[c][i]][c]=false;\n\t\t\t\t\t\te--;\n\t\t\t\t\t\tb=c;\n\t\t\t\t\t\tc=vec[c][i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(c==a)break;\n\t\t\t}\n\t\t\t\n\t\t\tbool updata=true;\n\t\t\twhile(updata){\n\t\t\t\tupdata=false;\n\t\t\t\trep1(i,v){\n\t\t\t\t\tint cnt=0;\n\t\t\t\t\tint t=105;\n\t\t\t\t\trep1(j,v){\n\t\t\t\t\t\tif(edge[i][j]){cnt++; t=j;}\n\t\t\t\t\t}\n\t\t\t\t\tif(cnt==1){\n\t\t\t\t\t\tupdata=true;\n\t\t\t\t\t\tedge[i][t]=false;\n\t\t\t\t\t\tedge[t][i]=false;\n\t\t\t\t\t\te--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\",ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n#define _all(arg) begin(arg),end(arg)\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\nusing R=long double;\nusing edge=tuple<R,int>;\n\nconst int limit=310;\nint x[limit],y[limit];\n\nint main(void){\n\tint n,m;\n\twhile(cin >> n >> m,n){\n\t\trep(i,n) cin >> x[i] >> y[i];\n\n\t\tvector<edge> graph[limit];\n\t\tvector<int> used[limit];\n\n\t\trep(i,m){\n\t\t\tint s,t;\n\t\t\tcin >> s >> t;\n\t\t\ts--,t--;\n\t\t\tgraph[s].push_back(make_tuple(atan2(y[t]-y[s],x[t]-x[s]),t));\n\t\t\tused[s].push_back(-1);\n\t\t\tgraph[t].push_back(make_tuple(atan2(y[s]-y[t],x[s]-x[t]),s));\n\t\t\tused[t].push_back(-1);\n\t\t}\n\n\t\trep(v,n) sort(_all(graph[v]));\n\t\t\n\t\tint all=0;\n\t\trep(v,n){\n\t\t\trep(i,graph[v].size()){\n\t\t\t\tif(used[v][i]!=-1) continue;\n\t\t\t\t\n\t\t\t\tint cur=v,idx=i;\n\t\t\t\tdo{\n\t\t\t\t\tused[cur][idx]=all;\n\t\t\t\t\tint nxt=get<1>(graph[cur][idx]),nidx=0;\n\t\t\t\t\trep(j,graph[nxt].size()) if(get<1>(graph[nxt][j])==cur) nidx=(j+1)%int(graph[nxt].size());\n\t\t\t\t\tcur=nxt,idx=nidx;\n\t\t\t\t}while(cur!=v);\n\t\t\t\tall++;\n\t\t\t}\n\t\t}\n\t\n\t\tint dual[limit][limit];\n\t\trep(i,all)rep(j,all) dual[i][j]=(i==j)?0:(1<<20);\n\n\t\tint outer=used[min_element(x,x+n)-x][0];\n\t\t\n\t\trep(v,n){\n\t\t\trep(i,graph[v].size()){\n\t\t\t\tint v2=get<1>(graph[v][i]),j=0;\n\t\t\t\twhile(get<1>(graph[v2][j])!=v) j++;\n\n\t\t\t\tdual[used[v][i]][used[v2][j]]=1;\n\t\t\t\tdual[used[v2][j]][used[v][i]]=1;\n\t\t\t}\n\t\t}\n\n\t\trep(k,all)rep(i,all)rep(j,all) chmin(dual[i][j],dual[i][k]+dual[k][j]);\n\t\tint ans=1;\n\t\trep(v,all) chmax(ans,dual[outer][v]);\n\t\tcout << ans << endl;\n\t}\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<utility>\n#include<map>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n\nusing namespace std;\n\nstruct Point{\n\tint x,y;\n\tint id;\n\tPoint(){}\n\tPoint(int a,int b,int c):x(a),y(b),id(c){}\n};\n\nPoint points[110];\nint pid[110];\n\nbool cmp(const Point &p1,const Point &p2)\n{\n\tif(p1.x!=p2.x) return p1.x<p2.x;\n\treturn p1.y<p2.y;\n}\n\nint center;\n\nbool cmp_angle(const int &id1,const int &id2)\n{\n\tint center=pid[::center];\n\tint id1_=pid[id1],id2_=pid[id2];\n\tint dx1=points[id1_].x-points[center].x;\n\tint dy1=points[id1_].y-points[center].y;\n\tint dx2=points[id2_].x-points[center].x;\n\tint dy2=points[id2_].y-points[center].y;\n\t//(-y,x)\n\tdouble ang1=atan2(dx1,-dy1);\n\tdouble ang2=atan2(dx2,-dy2);\n\treturn ang1<ang2;\n}\n/*\nstruct cmp_angle_{\n\tbool operator()(const int &id1,const int &id2)\n\t{\n\tint center=pid[::center];\n\tint id1_=pid[id1],id2_=pid[id2];\n\tint dx1=points[id1_].x-points[center].x;\n\tint dy1=points[id1_].y-points[center].y;\n\tint dx2=points[id2_].x-points[center].x;\n\tint dy2=points[id2_].y-points[center].y;\n\t//(-y,x)\n\tdouble ang1=atan2(dx1,-dy1);\n\tdouble ang2=atan2(dx2,-dy2);\n\treturn ang1<ang2;\n\t}\n};*/\n\nvector<int> G[110];\n\nvector<vector<int> > vs;\nvector<int> dG[750];\n//bool con[550][550];\n\ntypedef pair<int,int> P;\n\nmap<P,int> cnt;\nqueue<P> que;\n\nvoid init()\n{\n\tvs.clear();\n\tfor(int i=0;i<110;i++) G[i].clear();\n\tfor(int i=0;i<550;i++) dG[i].clear();\n\tcnt.clear();\n}\n\nvector<int> res;\nvoid stroke(int u,int v,int st)\n{\n\t//u->v\n\tP p=P(min(u,v),max(u,v));\n\tif(cnt[p]==0)\n\t{\n\t\tque.push(P(v,u));\n\t}\n\tcnt[p]++;\n\tif(v==st) return;\n\tif(u==st) res.push_back(u);\n\tres.push_back(v);\n//\tprintf(\"x%dx\\n\",v);\n\tcenter=v;\n\tint id=distance(G[v].begin(),lower_bound(G[v].begin(),G[v].end(),u,cmp_angle));\n//\tprintf(\"%d::%d %d\\n\",v,G[v].size(),id);\n\tif(id==G[v].size()-1) id=0;\n\telse id++;\n\tint nxt=G[v][id];\n\tstroke(v,nxt,st);\n}\n\nvoid getGraph(int W)\n{\n\tint n=0;\n\tint V=vs.size();\n\tfor(int i=0;i<V;i++) for(int j=i+1;j<V;j++)\n\t{\n\t\tint ni=vs[i].size(),nj=vs[j].size();\n\t\tbool flg=false;\n\t\tfor(int iid=0;iid<ni;iid++) for(int jid=0;jid<nj;jid++)\n\t\t{\n\t\t\tint niid=iid==ni-1?0:iid+1;\n\t\t\tint njid=jid==nj-1?0:jid+1;\n\t\t\tif(vs[i][iid]==vs[j][njid]&&vs[i][niid]==vs[j][jid])\n\t\t\t{\n\t\t\t\tflg=true;\n\t\t\t\tn++;\n\t\t\t}\n\t\t}\n\t\tif(flg)\n\t\t{\n\t\t\tdG[i].push_back(j);\n\t\t\tdG[j].push_back(i);\n\t\t}\n\t//\tcon[i][j]=flg;\n\t//\tcon[j][i]=flg;\n\t}\n//\tif(n!=W) for(;;);\n}\n\nint getMostOutSide()\n{\n\tint u=points[0].id;\n\tint v=G[u][0];\n//\tprintf(\"----------------%d %d\\n\",u,v);\n//\tprintf(\"%d %d %d %d\\n\",points[u].x,points[u].y,points[v].x,points[v].y);\n\tfor(int i=0;i<vs.size();i++)\n\t{\n\t\tfor(int j=0;j+1<vs[i].size();j++)\n\t\t{\n\t\t\tif(vs[i][j]==u&&vs[i][j+1]==v) return i;\n\t\t}\n\t\tif(vs[i][vs[i].size()-1]==u&&vs[i][0]==v) return i;\n\t}\n//\tfor(;;);\n\treturn -1;\n}\n\nvoid check(int a)\n{\n\tif(cnt.size()<a) for(;;);\n/*\tmap<P,int>::iterator it=cnt.begin();\n\tfor(;it!=cnt.end();it++)\n\t{\n\t\tint b=it->second;\n\t\tif(b!=2) for(;;);\n\t}*/\n}\n\nint dis[750];\nqueue<int> bfs_que;\nvoid bfs(int s)\n{\n//\tprintf(\"xxxxxxxxxxxxxxxxxxxxx\\n\");\n\twhile(!bfs_que.empty()) bfs_que.pop();\n\tbfs_que.push(s);\n\tfor(int i=0;i<550;i++) dis[i]=1<<29;\n\tdis[s]=0;\n\tbfs_que.push(s);\n\twhile(!bfs_que.empty())\n\t{\n\t\tint v=bfs_que.front();\n//\t\tprintf(\"bfs %d\\n\",v);\n\t\tbfs_que.pop();\n\t\tfor(int i=0;i<dG[v].size();i++)\n\t\t{\n\t\t\tint u=dG[v][i];\n\t\t\tint nd=dis[v]+1;\n\t\t\tif(nd>=dis[u]) continue;\n\t\t\tdis[u]=nd;\n\t\t\tbfs_que.push(u);\n\t\t}\n\t}\n}\n\nvoid outputdG()\n{\n\tprintf(\"-----dual\\n\");\n\tfor(int i=0;i<vs.size();i++)\n\t{\n\t\tprintf(\"%d-\",i);\n\t\tfor(int j=0;j<dG[i].size();j++)\n\t\t{\n\t\t\tprintf(\"%d \",dG[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}\n\nint main()\n{\n\twhile(true)\n\t{\n\t\tint C,W;\n\t\tscanf(\"%d%d\",&C,&W);\n\t\tif(C==0) break;\n\t\tinit();\n\t\tfor(int i=0;i<C;i++)\n\t\t{\n\t\t\tint x,y;\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\tpoints[i]=Point(x,y,i);\n\t\t}\n\t\tsort(points,points+C,cmp);\n\t\tfor(int i=0;i<C;i++) pid[points[i].id]=i;\n\t\tint su=-1,sv=-1;\n\t\tfor(int i=0;i<W;i++)\n\t\t{\n\t\t\tint u,v;\n\t\t\tscanf(\"%d%d\",&u,&v);\n\t\t\tu--;v--;\n\t\t\tG[u].push_back(v);\n\t\t\tG[v].push_back(u);\n\t\t\tsu=u,sv=v;\n\t\t}\n\t\tfor(int i=0;i<C;i++)\n\t\t{\n\t\t\tcenter=i;\n\t\t\tsort(G[i].begin(),G[i].end(),cmp_angle);\n//\t\t\tprintf(\"%d:::\",i);\n//\t\t\tfor(int j=0;j<G[i].size();j++) printf(\"%d \",G[i][j]);\n//\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tque.push(P(min(su,sv),max(su,sv)));\n\t\twhile(!que.empty())\n\t\t{\n\t\t\tP p=que.front();\n\t\t\tque.pop();\n\t\t\tint u=p.first,v=p.second;\n//\t\t\tprintf(\"pop %d %d\\n\",u,v);\n\t\t\tP pp=P(min(u,v),max(u,v));\n\t//\t\tif(cnt[pp]==2) continue;\n\t\t//\tbool flg;\n\t\t//\tif(cnt[pp]==1) flg=false;\n\t\t//\telse flg=true;\n\t\t\tres.clear();\n\t\t\tstroke(u,v,u);\n\t\t\tvs.push_back(res);\n//\t\t\tfor(int i=0;i<res.size();i++) printf(\"%d \",res[i]);\n//\t\t\tprintf(\"aaa\\n\");\n\t\t//\tcnt[pp]++;\n\t\t//\tif(flg) que.push(P(v,u));\n\t\t}\n\t//\tif(vs.size()>500) for(;;);\n//\t\tfor(int i=0;i<vs.size();i++)\n//\t\t{\n//\t\t\tvector<int> vec=vs[i];\n//\t\t\tprintf(\"a:\");\n//\t\t\tfor(int j=0;j<vec.size();j++) printf(\"%d \",vec[j]);\n//\t\t\tprintf(\"\\n\");\n//\t\t}\n\t\tgetGraph(W);\n\t//\tcheck(W);\n\t\tint out=getMostOutSide();\n\t\tbfs(out);\n\t\tint ans=0;\n\t\tfor(int i=0;i<vs.size();i++) ans=max(ans,dis[i]);\n//\t\toutputdG();\n//\t\tprintf(\"---------%d--------------ans=%d\\n\",out,ans);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define M_PI (3.141592653589793)\n\nusing namespace std;\n\nconst double EPS = 1e-10;\n\nclass Point{\npublic:\n    double x, y;\n    int id;\n    Point(double x = 0, double y = 0): x(x), y(y){}\n    Point operator + (Point p){return Point(x + p.x, y + p.y);}\n    Point operator - (Point p){return Point(x - p.x, y - p.y);}\n    Point operator * (double a){return Point(x * a, y * a);}\n    Point operator / (double a){return Point(x / a, y / a);}\n    Point operator * (const Point &a){\n        return Point(x * a.x - y * a.y, x * a.y + y * a.x);\n    }\n    bool operator < (const Point &p) const {\n        return (x != p.x ? x < p.x : y < p.y);\n    }\n    bool operator == (const Point &p) const {\n        return (fabs(x - p.x) < EPS && fabs(y - p.y) < EPS);\n    }\n};\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\ndouble dot(Vector a, Vector b){ return (a.x * b.x + a.y * b.y);}\ndouble norm(Vector a){ return (dot(a, a));}\ndouble abs(Vector a){ return (sqrt(norm(a)));}\ndouble cross(Vector a, Vector b){ return (a.x * b.y - a.y * b.x);}\n\nint ccw(Point p0, Point p1, Point p2)\n{\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if (cross(a, b) > EPS) return (+1); //p0, p1, p2 が反時計周り\n    if (cross(a, b) < -EPS) return (-1);//p0, p1, p2 が時計回り\n    if (dot(a, b) < -EPS) return (+2); //p2--p0--p1 の順で一直線上\n    if (norm(a) < norm(b)) return (-2); //p0--p1--p2 の順で一直線上\n    \n    return (0); //p0--p2--p1 の順で一直線上\n}\n\nPolygon conhel(Polygon& ps)\n{\n    sort(ps.begin(), ps.end());\n    int k = 0, n = (int)ps.size();\n    Polygon qs(n * 2);\n    \n    for (int i = 0; i < n; i++){\n        while (k > 1 && cross(qs[k - 1] - qs[k - 2], ps[i] - qs[k - 1]) < -EPS) k--;\n        qs[k++] = ps[i];\n    }\n    \n    for (int i = n - 2, t = k; i >= 0; i--){\n        while (k > t && cross(qs[k - 1] - qs[k - 2], ps[i] - qs[k - 1]) < -EPS) k--;\n        qs[k++] = ps[i];\n    }\n    \n    qs.resize(k - 1);\n    return (qs);\n}\n\ndouble getCos(Vector a, Vector b)\n{\n    return (dot(a, b) / (abs(a) * abs(b)));\n}\n\ndouble getArg(Vector v)\n{\n    return (atan2(v.y, v.x));\n}\n \nPoint rotate(Point t, Point p, double r)\n{\n    double ta = cos(r) * (t.x - p.x) - sin(r) * (t.y - p.y) + p.x;\n    double tb = sin(r) * (t.x - p.x) + cos(r) * (t.y - p.y) + p.y;\n    return (Point(ta, tb));\n}\n \nint main()\n{\n    int N, M;\n    \n    while (scanf(\"%d %d\", &N, &M) && N){\n        vector<Point> P(N);\n        vector<int> to[128];\n        bool exist[128][128] = {0};\n        \n        for (int i = 0; i < N; i++){\n            scanf(\"%lf %lf\", &P[i].x, &P[i].y);\n            P[i].id = i;\n        }\n        \n        for (int i = 0; i < M; i++){\n            int x, y;\n            scanf(\"%d %d\", &x, &y);\n            to[--x].push_back(--y);\n            to[y].push_back(x);\n            exist[x][y] = exist[y][x] = 1;\n        }\n        \n        Polygon Q = P;\n        Q = conhel(Q);\n        \n        vector<int> belong[128][128];\n        for (int i = 0; i < Q.size(); i++){\n            int u = Q[i].id, v = Q[(i + 1) % Q.size()].id;\n            belong[u][v].push_back(0);\n            belong[v][u].push_back(0);\n        }\n        int k = 1;\n        set<vector<int> > s;\n        \n        for (int i = 0; i < N; i++){\n            for (int j = 0; j < N; j++){\n                if (P[j] < P[i] && exist[i][j] && belong[i][j].size() < 2){\n                    vector<int> v;\n                    v.push_back(i);\n                    v.push_back(j);\n                    \n                    while (1){\n                        int nextP = -1;\n                        int vv = v[v.size() - 1], uu = v[v.size() - 2];\n                        for (int l = 0; l < to[vv].size(); l++){\n                            if (to[vv][l] == vv || to[vv][l] == uu) continue;\n                            double thetaT, thetaC;\n                            thetaT = acos(getCos(P[uu] - P[vv], P[to[vv][l]] - P[vv]));\n                            if (ccw(P[uu], P[vv], P[to[vv][l]]) > 0) thetaT = 2 * M_PI - thetaT;\n                            if (nextP != -1){\n                                thetaC = acos(getCos(P[uu] - P[vv], P[nextP] - P[vv]));\n                                if (ccw(P[uu], P[vv], P[nextP]) > 0) thetaC = 2 * M_PI - thetaC;\n                            }\n                            if (nextP == -1 || thetaT < thetaC) nextP = to[vv][l];\n                            \n                        }\n                        if (nextP == i) break;\n                        v.push_back(nextP);\n                    }\n                    vector<int> ss = v;\n                    sort(ss.begin(), ss.end());\n                    ss.erase(unique(ss.begin(), ss.end()), ss.end());\n                    if (s.find(ss) != s.end()) continue;\n                    else s.insert(ss);\n                    for (int it = 0; it < v.size(); it++){\n                        int uu = v[it], vv = v[(it + 1) % v.size()];\n                        belong[uu][vv].push_back(k);\n                        belong[vv][uu].push_back(k);\n                    }\n                    k++;\n                }\n            }\n        }\n        \n        vector<int> G[1024];\n        \n        for (int i = 0; i < N; i++){\n            for (int j = i + 1; j < N; j++){\n                if (belong[i][j].size()){\n                    assert(belong[i][j].size() != 1);\n                    int u = belong[i][j][0], v = belong[i][j][1];\n                    G[u].push_back(v);\n                    G[v].push_back(u);\n                }\n            }\n        }\n        \n        int ans = 0;\n        int done[1024];\n        fill(done, done + 1024, -1);\n        queue<pair<int, int> > q;\n        \n        for(q.push(make_pair(0, 0)); q.size(); q.pop()){\n            pair<int, int> x = q.front();\n            if (~done[x.first]) continue;\n            done[x.first] = x.second;\n            ans = max(ans, x.second);\n            \n            for (int i = 0; i < G[x.first].size(); i++){\n                q.push(make_pair(G[x.first][i], x.second + 1));\n            }\n        }\n        \n        printf(\"%d\\n\", ans);\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX_C 101\n#define MAX_W 301\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:y<p.y; }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const { return p.p1 == p1 && p.p2 == p2; }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a){ os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\nstruct Edge{\n  int from,to,rev,unique_index;\n  Edge(int from=IINF,int to=IINF):from(from),to(to){}\n};\n\nint C,W,sp;\nPoint ps[MAX_C];\nvector<Edge> G[MAX_C];\nvector<vector<int> > poly;\nbool used[MAX_C][MAX_C];\nint depth[MAX_C];\nint index_list[MAX_C][MAX_C];\nvector<int> bfs_G[MAX_C];\n\nbool cmp(const Edge& a,const Edge& b){\n  Vector vec_a = ps[a.to] - ps[a.from];\n  Vector vec_b = ps[b.to] - ps[b.from];\n  return atan2(vec_a.y,vec_a.x) < atan2(vec_b.y,vec_b.x);\n}\n\nbool getPath(int start_node,int node,int edge,vector<int>& edge_list){\n  //cout << node << \",\" << edge << endl;\n  if( used[node][edge] ){\n    if( !edge_list.empty() && node == start_node ) return true;\n    return false;\n  }\n  used[node][edge] = true;\n\n  int next_node = G[node][edge].to;\n  int next_edge = (G[node][edge].rev+1)%((int)G[next_node].size());\n  edge_list.push_back(G[node][edge].unique_index);\n  if(getPath(start_node,next_node,next_edge,edge_list)){\n    //cout << \"path::\"  << node << \",\" << edge << endl;\n    return true;\n  } else {\n    return used[node][edge] = false;\n  }\n}\n  \nint main(){\n  while(cin>>C>>W,C|W){\n    rep(i,MAX_C)depth[i] = IINF,bfs_G[i].clear(),G[i].clear();\n    rep(i,C)rep(j,C)used[i][j] = false, index_list[i][j] = IINF;\n    depth[0] = 0;\n    poly.clear();\n    sp = 0;\n    rep(i,C) {\n      cin >> ps[i].x >> ps[i].y;\n      ps[i].x += 1000, ps[i].y += 1000;\n      if( ps[i] < ps[sp] ) sp = i;\n    }\n    rep(i,W) {\n      int s,t;\n      cin >> s >> t;\n      s--,t--;\n      G[s].push_back(Edge(s,t));\n      G[t].push_back(Edge(t,s));\n    }\n    rep(i,C)sort(G[i].begin(),G[i].end(),cmp);\n    int dex = 0;\n    rep(i,C){\n      rep(j,(int)G[i].size()){\n\tint to = G[i][j].to;\n\trep(k,(int)G[to].size()){\n\t  if(G[to][k].to == i){\n\t    G[i][j].rev = k;\n\t    if( index_list[i][j] == IINF ){\n\t      assert(index_list[to][k] == IINF);\n\t      index_list[i][j] = index_list[to][k] = dex++;\n\t    }\n\t    G[i][j].unique_index = index_list[i][j];\n\t    break;\n\t  }\n\t}\n      }\n    }\n    /*\n    cout << \"sp = \" << sp << endl;\n    rep(i,C){\n      cout << \"i = \" << i << endl;\n      rep(j,G[i].size()){\n\tcout << \"from = \" << G[i][j].from << \" to = \" << G[i][j].to << \" rev = \" << G[i][j].rev << \" unique = \" << G[i][j].unique_index << endl;\n      }\n    }\n    cout << endl << endl;\n    rep(i,(int)G[sp].size()){\n      if( used[sp][i] ) continue;\n      vector<int> tmp;\n      if( getPath(sp,sp,i,tmp) ) {\n\tpoly.push_back(tmp);\n\tcout << \"[\" << sp << \"][\" << i << \"] : getPath!! : \" << endl;\n      }\n    }\n    */\n    rep(i,C){\n      if( i == sp ) continue;\n      rep(j,G[i].size()){\n\tif( used[i][j] ) continue;\n\tvector<int> tmp;\n\tif( getPath(i,i,j,tmp) ){\n\t  poly.push_back(tmp);\n\t}\n      }\n    }\n\n    rep(i,poly.size()){\n      REP(j,i+1,poly.size()){\n\tbool connect = false;\n\trep(k,poly[i].size()){\n\t  rep(l,poly[j].size()){\n\t    if(poly[i][k] == poly[j][l]){\n\t      connect = true;\n\t      goto Skip;\n\t    }\n\t  }\n\t}\n      Skip:;\n\tif(connect){\n\t  bfs_G[i].push_back(j);\n\t  bfs_G[j].push_back(i);\n\t}\n      }\n    }\n\n    /*\n    cout << \"poly.size() = \" << poly.size() << endl;\n    rep(i,(int)poly.size()){\n      cout << \"poly[\" << i << \"]\" << endl;\n      rep(j,poly[i].size()){\n\tcout << poly[i][j] << \" \";\n      }\n      cout << endl;\n    }\n\n    cout << \"bfs_G = \" << endl;\n    rep(i,poly.size()){\n      cout << \"[\" << i << \"]\" << endl;\n      rep(j,bfs_G[i].size()){\n\tcout << bfs_G[i][j] << \" \";\n      }\n      cout << endl;\n    }\n\n    cout << \"depth[\" << 0 << \"] = \" << depth[0] << endl;\n    */\n    int answer = 0;\n    deque<int> deq;\n    deq.push_back(0);\n    while(!deq.empty()){\n      int cur = deq.front(); deq.pop_front();\n      rep(i,bfs_G[cur].size()){\n\tint next = bfs_G[cur][i];\n\tif( depth[next] == IINF ){\n\t  depth[next] = depth[cur] + 1;\n\t  answer = max(answer,depth[next]);\n\t  deq.push_back(next);\n\t}\n      }\n    }\n    cout << answer << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<queue>\n#include<cassert>\n#include<map>\n#include<set>\nusing namespace std;\n#define rep(i, n) for ( int i = 0; i < n; i++ )\n#define INF (1<<21)\n#define MAX 104\n\nint n, m;\nbool V[MAX][MAX];\nint T[MAX][MAX];\nint F[MAX][MAX];\nint face;\n\nvector<int> G[MAX];\npair<int, int> P[MAX];\n\nvector<vector<pair<int, int> > > R; // room;\n\ndouble angle(int s, int t){\n  return atan2(P[t].second - P[s].second, P[t].first - P[s].first);\n}\n\nvoid parse(int s, int t, bool isouter, int f){\n  if ( V[s][t] || s == t ) return;\n  int cur1 = s, cur2 = t;\n\n  vector<pair<int, int> > room;\n\n  while(1){\n    if ( V[cur1][cur2] ) break;\n    V[cur1][cur2] = true;\n    F[cur1][cur2] = f;\n    room.push_back(make_pair(cur1, cur2));\n    int nx;\n    rep(i, G[cur2].size() ){\n      if ( G[cur2][i] == cur1 ){ nx = i; break; } // next node after counter-clock\n    }\n    nx = (nx+1)%G[cur2].size();\n    cur1 = cur2;\n    cur2 = G[cur2][nx];\n  }\n  R.push_back(room);\n}\n\nbool isConnected(vector<pair<int, int> > &c1, vector<pair<int, int> > &c2){\n  for ( int i = 0; i < c1.size(); i++ ){\n    for ( int j = 0; j < c2.size(); j++ ){\n      pair<int, int> p1 = c1[i];\n      pair<int, int> p2 = c2[j];\n      if ( p1 == p2 ) return true;\n      swap(p2.first, p2.second);\n      if ( p1 == p2 ) return true;\n    }\n  }\n  return false;\n}\n\nvector<vector<int> > makeGraph(){\n  R.clear();\n\n  // sort by angle\n  rep(s, n) {\n    for ( int e = G[s].size()-2; e >= 0; e--)\n      for ( int j = 0; j <= e; j++ )\n\tif ( angle(s, G[s][j]) > angle(s, G[s][j+1]) ) swap(G[s][j], G[s][j+1]);\n  }\n\n  rep(i, n) rep(j, n) V[i][j] = false;\n\n  int bottom = 0;\n  rep(i, n){\n    if ( P[i].second == P[bottom].second ){\n      if ( P[i].first < P[bottom].first ) bottom = i;\n    } else {\n      if ( P[i].second < P[bottom].second ) bottom = i;\n    }\n  }\n\n  face = 0;\n  rep(i, n) rep(j, n) F[i][j] = -1;\n\n  parse(bottom, G[bottom][0], true, face); // the outer\n\n  rep(s, n)  rep(j, G[s].size()){\n    int t =  G[s][j];\n    parse(s, t, false, ++face);\n  }\n\n  rep(i, n) rep(j, n) {\n    if ( F[i][j] == -1 ){\n      assert( F[j][i] == -1);\n      continue;\n    }\n    assert( F[i][j] != F[j][i] );\n  }\n\n\n  vector<vector<int> > g;\n  g.resize(R.size());\n  for ( int i = 0; i < R.size()-1; i++ ){\n    for ( int j = i+1; j < R.size(); j++ ){\n      if ( isConnected(R[i], R[j])) {\n\tg[i].push_back(j);\n\tg[j].push_back(i);\n      }\n    }\n  }\n\n  assert( n - m + R.size() == 2 );\n\n  return g;\n}\n\nint bfs(vector<vector<int> > g){\n  vector<int> d;\n  d.resize(g.size());\n  rep(i, g.size()) d[i] = INF;\n  queue<int> Q;\n  int u, v;\n  for ( d[0] = 0, Q.push(0); !Q.empty(); ){\n    u = Q.front(); Q.pop();\n    for ( int i = 0; i < g[u].size(); i++ ){\n      int v = g[u][i];\n      if ( d[v] != INF ) continue;\n      d[v] = d[u] + 1;\n      Q.push(v);\n    }\n  }\n  int maxv = 0;\n  for ( int i = 0; i < d.size(); i++) maxv = max(maxv, d[i]);\n  return maxv;\n}\n\nmain(){\n  while(1){\n    cin >> n >> m;\n    if ( n == 0 ) break;\n    assert( 3 <= n && n <= 100 );\n    assert( n <= m && m <= 300 );\n    set<pair<int, int> > S;\n    rep(i, n) {\n      cin >> P[i].first >> P[i].second;\n      S.insert( P[i]) ;\n    }\n    assert( S.size() == n );\n    rep(i, n) G[i].clear();\n    map<pair<int, int>, bool> vis;\n    rep(i, m){\n      int s, t;\n      cin >> s >> t;\n      s--; t--;\n      G[s].push_back(t);\n      G[t].push_back(s);\n      T[s][t] = T[t][s] = (i+1); // 0 = outer\n\n      assert( !vis[make_pair(min(s, t), max(s,t))]);\n      vis[make_pair(min(s, t), max(s,t))] = true;\n    }\n    for ( int i = 0; i < n; i++ ){\n      assert( G[i].size() >= 2 );\n    }\n    cout << bfs(makeGraph()) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cassert>\nusing namespace std;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n\treturn abs(a.real()-b.real()) > EPS ? real(a) < real(b) : imag(a) + EPS < imag(b);\n    //return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\nP readPoint(){\n\tdouble x,y;\n\tcin >> x >> y;\n\treturn P(x,y);\n}\n\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\ntypedef vector<P> G;\n\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\n\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\nP reflection(const L &l, const P &p) {\n  return p + 2. * (projection(l, p) - p);\n}\ndouble distanceLP(const L &l, const P &p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\n#define rep(i,N) for(int i = 0 ; i < N ; i++)\nP ps[110];\nvector<int> g[110];\n\nvector<int> normalize(vector<int> v){\n\tauto it = min_element(v.begin(),v.end());\n\trotate(v.begin(),it,v.end());\n\treturn v;\n}\n\nint done[110];\nvoid f(int a,int b,int s,vector<int> &v){\n\tv.push_back(b);\n\tif( b == s ) return;\n\tif( done[b]++ ) throw 0;\n\tsort(g[b].begin(),g[b].end(),[&](int x,int y){\n\t\tP A = ps[x] - ps[b];\n\t\tP B = ps[y] - ps[b];\n\t\treturn cross(A,B) > 0;\n\t});\n\trotate(g[b].begin(),find(g[b].begin(),g[b].end(),a),g[b].end());\n\tf(b,g[b][1],s,v);\n}\n\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n\ndouble area2(const G& P) {\n  double A = 0;\n  for (int i = 0; i < P.size(); ++i) \n    A += cross(curr(P, i), next(P, i));\n  return A;\n}\n\nint main(){\n\t\n\tint C,W;\n\twhile( cin >> C >> W && (C||W) ){\n\t\trep(i,C) ps[i] = readPoint();\n\t\trep(i,C) g[i].clear();\n\t\trep(i,W){\n\t\t\tint a,b;\n\t\t\tcin >> a >> b;\n\t\t\t--a,--b;\n\t\t\tg[a].push_back(b);\n\t\t\tg[b].push_back(a);\n\t\t}\n\t\tvector< vector<int> > poly;\n\t\trep(i,C){\n\t\t\trep(j,g[i].size()){\n\t\t\t\ttry{\n\t\t\t\t\tmemset(done,0,sizeof(done));\n\t\t\t\t\tvector<int> v;\n\t\t\t\t\tf(i,g[i][j],i,v);\n\t\t\t\t\tvector<P> g;\n\t\t\t\t\trep(k,v.size())g.push_back(ps[v[k]]);\n\t\t\t\t\tif( area2(g) > 0 ){ continue; }\n\t\t\t\t\tpoly.push_back(normalize(v));\n\t\t\t\t}catch(int x){\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(poly.begin(),poly.end());\n\t\tpoly.erase(unique(poly.begin(),poly.end()),poly.end());\n\t\t\n\t\tmap< pair<int,int>, vector<int> > edgs;\n\t\tfor(int i = 0 ; i < poly.size() ; i++){\n\t\t\tfor(int j = 0 ; j < poly[i].size() ; j++){\n\t\t\t\tint A = curr(poly[i],j);\n\t\t\t\tint B = next(poly[i],j);\n\t\t\t\tif( A > B ) swap(A,B);\n\t\t\t\tedgs[pair<int,int>(A,B)].push_back(i);\n\t\t\t}\n\t\t}\n\t\tint M = poly.size() + 1;\n\t\tint wf[M][M];\n\t\trep(i,M) rep(j,M){\n\t\t\twf[i][j] = i==j?0:1e9;\n\t\t}\n\t\t\n\t\tfor( auto x : edgs ){\n\t\t\tvector<int> v = x.second;\n\t\t\tif( v.size() < 2 ) v.push_back(M-1);\n\t\t\twf[v[0]][v[1]] = wf[v[1]][v[0]] = 1;\n\t\t}\n\t\trep(i,M)rep(j,M)rep(k,M) wf[j][k] = min(wf[j][i]+wf[i][k],wf[j][k]);\n\t\tint ans = 0;\n\t\trep(i,M){\n\t\t\tans = max(ans,wf[i][M-1]);\n\t\t}\n\t\tassert( ans < 1e9 );\n\t\tcout << ans << endl;\n\t\t\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <queue>\n#include <cstdio>\n#include <cassert>\n#include <algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst double EPS=1e-8;\nconst double PI=acos(-1);\n\nstruct point{\n\tdouble x,y;\n\tpoint():x(0),y(0){}\n\tpoint(double x,double y):x(x),y(y){}\n\tpoint &operator+=(const point &a){ x+=a.x; y+=a.y; return *this; }\n\tpoint &operator-=(const point &a){ x-=a.x; y-=a.y; return *this; }\n\tpoint &operator*=(double c){ x*=c; y*=c; return *this; }\n\tpoint &operator/=(double c){ x/=c; y/=c; return *this; }\n\tpoint operator+(const point &a)const{ return point(x+a.x,y+a.y); }\n\tpoint operator-(const point &a)const{ return point(x-a.x,y-a.y); }\n\tpoint operator/(double c)const{ return point(x/c,y/c); }\n\tpoint operator-()const{ return point(-x,-y); }\n\tbool operator< (const point &a)const{ return x+EPS<a.x || (abs(x-a.x)<EPS && y+EPS<a.y); }\n\tbool operator==(const point &a)const{ return abs(x-a.x)<EPS && abs(y-a.y)<EPS; }\n\tbool operator!=(const point &a)const{ return abs(x-a.x)>EPS || abs(y-a.y)>EPS; }\n};\n\ndouble cross(const point &a,const point &b){ return a.x*b.y-a.y*b.x; }\n\ndouble arg(const point &a){ double t=atan2(a.y,a.x); return t<0?t+2*PI:t; }\n\ntypedef vector<point> polygon;\n\nbool is_ccw(const polygon &F){\n\tint n=F.size();\n\tdouble A=0;\n\trep(i,n) A+=cross(F[i],F[(i+1)%n]);\n\treturn A>-EPS;\n}\n\n// trace the frame of a polygon\nvector<int> trace(int n,const vector<int> *G,int u0,int i0){\n\tvector<int> F;\n\tint u=u0,i=i0;\n\tdo{\n\t\tF.push_back(u);\n\t\tint v=G[u][i];\n\t\tint k=G[v].size();\n\t\trep(j,k) if(G[v][j]==u) i=(j-1+k)%k;\n\t\tu=v;\n\t}while(u!=u0);\n\treturn F;\n}\n\n// normalize the list of vertices\nvector<int> reg(vector<int> a){\n\tint k=min_element(a.begin(),a.end())-a.begin();\n\trep(i,k){\n\t\ta.push_back(a[0]);\n\t\ta.erase(a.begin());\n\t}\n\treturn a;\n}\n\nint main(){\n\tfor(int n,m;scanf(\"%d%d\",&n,&m),n;){\n\t\tpoint P[100];\n\t\trep(u,n) scanf(\"%lf%lf\",&P[u].x,&P[u].y);\n\n\t\tvector<int> G[100];\n\t\trep(i,m){\n\t\t\tint u,v; scanf(\"%d%d\",&u,&v); u--; v--;\n\t\t\tG[u].push_back(v);\n\t\t\tG[v].push_back(u);\n\t\t}\n\n\t\t// angle sort\n\t\trep(u,n){\n\t\t\tint k=G[u].size();\n\t\t\tpair<double,int> A[100];\n\t\t\trep(i,k){\n\t\t\t\tint v=G[u][i];\n\t\t\t\tA[i]=make_pair(arg(P[v]-P[u]),v);\n\t\t\t}\n\t\t\tsort(A,A+k);\n\t\t\trep(i,k) G[u][i]=A[i].second;\n\t\t}\n\n\t\t// decompose to polygons\n\t\tvector< vector<int> > F; // set of polygons\n\t\trep(u,n) rep(i,G[u].size()) F.push_back(reg(trace(n,G,u,i)));\n\t\tsort(F.begin(),F.end());\n\t\tF.erase(unique(F.begin(),F.end()),F.end());\n\n\t\t// find the outside boundary\n\t\tint n2=F.size(),u0=-1;\n\t\trep(u,n2){\n\t\t\tint k=F[u].size();\n\t\t\tpolygon H(k);\n\t\t\trep(i,k) H[i]=P[F[u][i]];\n\t\t\tif(!is_ccw(H)){\n\t\t\t\tassert(u0==-1);\n\t\t\t\tu0=u;\n\t\t\t}\n\t\t}\n\t\tassert(u0!=-1);\n\n\t\t// build the dual graph\n\t\tvector<int> G2[100];\n\t\trep(u,n2) rep(v,u) {\n\t\t\tbool ok=false;\n\t\t\tint nu=F[u].size(),nv=F[v].size();\n\t\t\trep(i,nu) rep(j,nv) if(F[u][i]==F[v][(j+1)%nv] && F[u][(i+1)%nu]==F[v][j]) ok=true;\n\t\t\tif(ok){\n\t\t\t\tG2[u].push_back(v);\n\t\t\t\tG2[v].push_back(u);\n\t\t\t}\n\t\t}\n\n\t\t// BFS\n\t\tint d[100];\n\t\trep(u,n2) d[u]=(u==u0?0:-1);\n\t\tqueue<int> Q;\n\t\tQ.push(u0);\n\t\twhile(!Q.empty()){\n\t\t\tint u=Q.front(); Q.pop();\n\t\t\trep(i,G2[u].size()){\n\t\t\t\tint v=G2[u][i];\n\t\t\t\tif(d[v]==-1) d[v]=d[u]+1, Q.push(v);\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",*max_element(d,d+n2));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<int,pair<bool,double>> P2;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define min_3(a,b,c) min(a,min(b,c))\n#define max_3(a,b,c) max(a,max(b,c))\n#define mp1(a,b,c) P1(a,P(b,c))\n#define mp2(a,b,c) P2(a,pair<bool,double>(b,c))\n#define pque(a) priority_queue<a>\n#define rpque(a) priority_queue<a,vector<a>,greater<a>>\n\nconst int INF=1000000000;\nconst int dre_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dre_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\nconst int kaijou[10]={1,1,2,6,24,120,720,5040,40320,362880};\n\nbool com(P2 x,P2 y){\n\tif(x.sc.fr!=y.sc.fr)return x.sc.fr;\n\treturn x.sc.sc>=y.sc.sc;\n}\n\nint main(){\n\twhile(1){\n\t\tint c,w;\n\t\tint x[110],y[110];\n\t\tint s,t;\n\t\t\n\t\tscanf(\"%d%d\",&c,&w); if(c==0&&w==0)break;\n\t\trep1(i,c)scanf(\"%d%d\",&x[i],&y[i]);\n\t\t\n\t\tvector<P1> V_;\n\t\trep1(i,c){\n\t\t\tV_.pb(mp1(x[i],y[i],i));\n\t\t}\n\t\tsor(V_);\n\t\tvector<P2> vec_[110];\n\t\trep1(i,c){\n\t\t\tvec_[i].pb(mp2(0,false,-INF));\n\t\t\trep1(j,c){\n\t\t\t\tif(i==j)continue;\n\t\t\t\tif(x[i]<x[j]){\n\t\t\t\t\tvec_[i].pb(mp2(j,true,(double)(y[j]-y[i])/(x[j]-x[i])));\n\t\t\t\t}\n\t\t\t\telse if(x[i]>x[j]){\n\t\t\t\t\tvec_[i].pb(mp2(j,false,(double)(y[j]-y[i])/(x[j]-x[i])));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(y[j]>y[i])vec_[i].pb(mp2(j,true,(double)INF));\n\t\t\t\t\telse vec_[i].pb(mp2(j,true,(double)-INF));\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(vec_[i].begin(),vec_[i].end(),com);\n\t\t}\n\t\t\n\t\tint v,e;\n\t\tvector<int> V;\n\t\tbool edge[110][110];\n\t\tvector<int> vec[110];\n\t\t\n\t\tv=c; e=w;\n\t\trep(i,c)V.pb(V_[i].sc.sc);\n\t\trep(i,110)rep(j,110)edge[i][j]=false;\n\t\trep(i,e){\n\t\t\tscanf(\"%d%d\",&s,&t);\n\t\t\tedge[s][t]=true;\n\t\t\tedge[t][s]=true;\n\t\t}\n\t\trep1(i,c){\n\t\t\trep(j,vec_[i].size()){\n\t\t\t\tvec[i].pb(vec_[i][j].fr);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ret=0;\n\t\twhile(e>0){\n\t\t\tret++;\n\t\t\t\n\t\t\tint a=-1;\n\t\t\trep(i,V.size()){\n\t\t\t\trep(j,105){\n\t\t\t\t\tif(edge[V[i]][j]){a=V[i]; break;}\n\t\t\t\t}\n\t\t\t\tif(a!=-1)break;\n\t\t\t}\n\t\t\t\n\t\t\tint b=0,c=a;\n\t\t\twhile(1){\n\t\t\t\trep(i,vec[c].size()){\n\t\t\t\t\tif(vec[c][i]==b){\n\t\t\t\t\t\ti++; i%=vec[c].size();\n\t\t\t\t\t\twhile(!edge[c][vec[c][i]]){\n\t\t\t\t\t\t\ti++; i%=vec[c].size();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tedge[c][vec[c][i]]=false;\n\t\t\t\t\t\tedge[vec[c][i]][c]=false;\n\t\t\t\t\t\te--;\n\t\t\t\t\t\tb=c;\n\t\t\t\t\t\tc=vec[c][i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(c==a)break;\n\t\t\t}\n\t\t\t\n\t\t\tbool updata=true;\n\t\t\twhile(updata){\n\t\t\t\tupdata=false;\n\t\t\t\trep1(i,c){\n\t\t\t\t\tint cnt=0;\n\t\t\t\t\tint t=-1;\n\t\t\t\t\trep1(j,c){\n\t\t\t\t\t\tif(edge[i][j]){cnt++; t=j;}\n\t\t\t\t\t}\n\t\t\t\t\tif(cnt==1){\n\t\t\t\t\t\tupdata=true;\n\t\t\t\t\t\tedge[i][t]=false;\n\t\t\t\t\t\tedge[t][i]=false;\n\t\t\t\t\t\te--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "int bottom;\nint outside_color;\n\n// Library.\n#include<cassert>\n#include<map>\n#include<vector>\n#include<cmath>\n#include<queue>\n#include<algorithm>\n// Type.\ntypedef int Label;\ntypedef int Weight;\n// Class.\ntemplate<typename Vertex, typename Edge>\nclass PlaneGraph {\npublic:\n  void insert(const Vertex& v);\n  void insert(Edge e);\n  const PlaneGraph<Vertex, Edge> dualgraph() const;\n  const std::map<Label, Weight> Dijkstra(const Label& start) const;\nprivate:\n  void dualgraph_color(std::map<Label, std::map<Label, int>>& color, int c, const Edge& e, const std::map<Label, std::vector<Edge>>& edge) const;\n  std::map<Label, Vertex> V;\n  std::map<Label, std::vector<Edge>> E;\n};\n// Implement.\ntemplate<typename Vertex, typename Edge>\nvoid PlaneGraph<Vertex, Edge>::insert(const Vertex& v) {\n  V[v.label] = v;\n}\ntemplate<typename Vertex, typename Edge>\nvoid PlaneGraph<Vertex, Edge>::insert(Edge e) {\n  assert(V.find(e.from) != std::end(V));\n  assert(V.find(e.to) != std::end(V));\n  E[e.from].push_back(e);\n  std::swap(e.from, e.to);\n  E[e.from].push_back(e);\n}\ntemplate<typename Vertex, typename Edge>\nconst PlaneGraph<Vertex, Edge> PlaneGraph<Vertex, Edge>::dualgraph() const {\n  // Sort edges counterclockwise.\n  auto edge = E;\n  for(auto& list: edge) if(!list.second.empty()) {\n    std::sort(std::begin(list.second), std::end(list.second), [&](const Edge& lhs, const Edge& rhs) {\n      double l = std::atan2(V.at(lhs.to).y - V.at(lhs.from).y, V.at(lhs.to).x - V.at(lhs.from).x);\n      double r = std::atan2(V.at(rhs.to).y - V.at(rhs.from).y, V.at(rhs.to).x - V.at(rhs.from).x);\n      return l < r;\n    });\n    list.second.push_back(list.second.front());\n  }\n  // Color edges.\n  std::map<Label, std::map<Label, int>> color;\n  int c = 1;\n  for(const auto& list: edge) {\n    for(const auto& e: list.second) if(!color[e.from].count(e.to)) dualgraph_color(color, c++, e, edge);\n    if(list.first == bottom) outside_color = color[list.second.front().from][list.second.front().to];\n  }\n  // Construct the dualgraph.\n  PlaneGraph<Vertex, Edge> result;\n  std::vector<std::vector<bool>> used(c, std::vector<bool>(c, false));\n  for(int i = 1; i < c; ++i) result.insert(Vertex({i}));\n  for(const auto& list: E) for(const auto& e: list.second) if(!used[color[e.from][e.to]][color[e.to][e.from]]) {\n    used[color[e.from][e.to]][color[e.to][e.from]] = true;\n    used[color[e.to][e.from]][color[e.from][e.to]] = true;\n    result.insert(Edge({color[e.from][e.to], color[e.to][e.from], 1}));\n  }\n  return result;\n}\ntemplate<typename Vertex, typename Edge>\nvoid PlaneGraph<Vertex, Edge>::dualgraph_color(std::map<Label, std::map<Label, int>>& color, int c, const Edge& e, const std::map<Label, std::vector<Edge>>& edge) const {\n  color[e.from][e.to] = c;\n  for(auto it = edge.at(e.to).rbegin(); it != edge.at(e.to).rend(); ++it) if(it->to == e.from) {\n    ++it;\n    if(!color[it->from].count(it->to)) dualgraph_color(color, c, *it, edge);\n    break;\n  }\n}\ntemplate<typename Vertex, typename Edge>\nconst std::map<Label, Weight> PlaneGraph<Vertex, Edge>::Dijkstra(const Label& start) const {\n  std::map<Label, Weight> result;\n  std::priority_queue<Edge, std::vector<Edge>, std::function<bool(Edge, Edge)>> q([](Edge lhs, Edge rhs) {\n    return lhs.weight > rhs.weight;\n  });\n  q.push(Edge({start, start, 0}));\n  while(!q.empty()) {\n    auto cur = q.top();\n    q.pop();\n    if(result.count(cur.to)) continue;\n    result[cur.to] = cur.weight;\n    for(const auto& nex: E.at(cur.to)) if(!result.count(nex.to)) q.push(Edge({nex.from, nex.to, cur.weight + nex.weight}));\n  }\n  return result;\n}\n////////////////////////////////////////\n// Configuration.\nstruct Vertex {Label label; double x, y;};\nstruct Edge {Label from, to; Weight weight;};\n////////////////////////////////////////\n#include<bits/stdc++.h>\nusing namespace std;\nint main() {\n  int C, W;\n  while(cin >> C >> W, C | W) {\n    vector<Vertex> pillar;\n    int bottom_x = 1001, bottom_y = 1001;\n    for(int i = 0; i < C; ++i) {\n      double x, y;\n      cin >> x >> y;\n      pillar.push_back({i, x, y});\n      if(bottom_x < x) continue;\n      if(bottom_x == x && bottom_y < y) continue;\n      bottom_x = x;\n      bottom_y = y;\n      bottom = i;\n    }\n    PlaneGraph<Vertex, Edge> G;\n    for(const auto& p: pillar) G.insert(p);\n    for(int i = 0; i < W; ++i) {\n      int s, t;\n      cin >> s >> t;\n      --s; --t;\n      G.insert(Edge({s, t, 1}));\n    }\n    auto D = G.dualgraph();\n    auto distance = D.Dijkstra(outside_color);\n    double answer = 0;\n    for(const auto& d: distance) answer = max(answer, d.second);\n    cout << answer << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <functional>\n#include <iterator>\n#include <limits>\n#include <numeric>\n#include <utility>\n#include <cmath>\n#include <cassert>\n#include <cstdio>\n\nusing namespace std; using namespace placeholders;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector< int > VI;\ntypedef vector< vector< int > > VVI;\ntypedef vector< string > VS;\ntypedef stringstream SS;\ntypedef pair< int, int > PII;\ntypedef vector< pair< int, int > > VPII;\n#define VT( T ) vector< T >\n#define VVT( T ) vector< vector< T > >\n#define LIM( T ) numeric_limits< T >\n\ntemplate < typename T > inline istream& operator>>( istream &s, vector< T > &v ){ for ( T &t : v ) { s >> t; } return s; }\ntemplate < typename T > inline ostream& operator<<( ostream &s, const vector< T > &v ){ for ( int i = 0; i < int( v.size() ); ++i ){ s << ( \" \" + !i ) << v[i]; } return s; }\ntemplate < typename T > inline T fromString( const string &s ) { T res; istringstream iss( s ); iss >> res; return res; };\ntemplate < typename T > inline string toString( const T &a ) { ostringstream oss; oss << a; return oss.str(); };\n\n#define REP2( i, n ) REP3( i, 0, n )\n#define REP3( i, m, n ) for ( int i = ( int )( m ); i < ( int )( n ); ++i )\n#define GET_REP( a, b, c, F, ... ) F\n#define REP( ... ) GET_REP( __VA_ARGS__, REP3, REP2 )( __VA_ARGS__ )\n#define FOR( e, c ) for ( auto &e : c )\n#define ALL( c ) ( c ).begin(), ( c ).end()\n#define AALL( a, t ) ( t* )a, ( t* )a + sizeof( a ) / sizeof( t )\n#define DRANGE( c, p ) ( c ).begin(), ( c ).begin() + p, ( c ).end()\n\n#define SZ( v ) ( (int)( v ).size() )\n#define PB push_back\n#define EM emplace\n#define EB emplace_back\n#define BI back_inserter\n\n#define EXIST( c, e ) ( ( c ).find( e ) != ( c ).end() )\n\n#define MP make_pair\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\n#include <complex>\ntypedef complex< double > Point;\nconstexpr double EPS = 1e-8;\nconstexpr Point O( 0, 0 );\n\n// 入力ストリームから実数二つをとって Point へ\nistream& operator>> ( istream &s, Point &a )\n{\n\tdouble r, i;\n\ts >> r >> i;\n\ta = Point( r, i );\n\treturn s;\n}\n\n// 偏角\nstruct CompArg : public binary_function<Point,Point,bool>\n{\n\tbool operator ()( const Point &a, const Point &b ) const\n\t{\n\t\treturn arg( a ) < arg( b );\n\t}\n};\n\n// 内積（ドット積）\ndouble dot( const Point &a, const Point &b )\n{\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\n\n// 外積（クロス積）\ndouble cross( const Point &a, const Point &b )\n{\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\n\nclass DualGraph\n{\n\ttypedef std::tuple< int, int, int, Point > Edge;\n\t// ( to, rev-edge, edge id, angle )\n\n\tconst int N;\n\tint M;\n\tconst std::vector< Point > ps_;\n\tstd::vector< std::vector< Edge > > G;\n\tstd::vector< std::vector< int > > edge_indices_, edge_poss_;\n\tstd::vector< std::vector< bool > > used_;\n\n\tint outer_;\n\tstd::vector< std::vector< Point > > areas_;\n\n\tstd::vector< std::vector< int > > intersects_;\n\npublic:\n\tDualGraph( const std::vector< Point > &ps ) :\n\t\tN( ps.size() ), M( 0 ), ps_( ps ), G( N ), edge_indices_( N ), edge_poss_( N ), used_( N ), outer_( -1 )\n\t{\n\t\treturn;\n\t}\n\n\tvoid connect( const int a, const int b )\n\t{\n\t\tG[a].emplace_back( b, G[b].size(), M, ps_[b] - ps_[a] );\n\t\tG[b].emplace_back( a, G[a].size() - 1, M, ps_[a] - ps_[b] );\n\t\t++M;\n\n\t\treturn;\n\t}\n\n\tvoid solve()\n\t{\n\t\tsort_edges();\n\n\t\tfor ( int v = 0; v < N; ++v )\n\t\t{\n\t\t\tfor ( int i = 0; i < int( G[v].size() ); ++i )\n\t\t\t{\n\t\t\t\tif ( used_[v][i] )\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tdfs( v, i );\n\t\t\t}\n\t\t}\n\n\t\treturn;\n\t}\n\nprivate:\n\tvoid sort_edges()\n\t{\n\t\tCompArg comp;\n\t\tfor ( int v = 0; v < N; ++v )\n\t\t{\n\t\t\tedge_indices_[v].resize( G[v].size() );\n\t\t\tstd::iota( begin( edge_indices_[v] ), end( edge_indices_[v] ), 0 );\n\n\t\t\tstd::sort( begin( edge_indices_[v] ), end( edge_indices_[v] ), \n\t\t\t\t\t[&]( const int i, const int j ){ return comp( get< 3 >( G[v][i] ), get< 3 >( G[v][j] ) ); } );\n\n\t\t\tedge_poss_[v].resize( G[v].size() );\n\t\t\tfor ( int i = 0; i < int( G[v].size() ); ++i )\n\t\t\t{\n\t\t\t\tedge_poss_[v][ edge_indices_[v][i] ] = i;\n\t\t\t}\n\n\t\t\tused_[v].resize( G[v].size() );\n\t\t}\n\t\tintersects_.resize( M );\n\n\t\treturn;\n\t}\n\n\tvoid dfs( const int sv, const int se )\n\t{\n\t\tstd::vector< Point > area;\n\n\t\tfor ( int v = sv, e = se; area.empty() || v != sv; )\n\t\t{\n\t\t\tused_[v][e] = true;\n\t\t\tarea.push_back( ps_[v] );\n\t\t\tintersects_[ get< 2 >( G[v][e] ) ].push_back( areas_.size() );\n\n\t\t\tconst int r = get< 1 >( G[v][e] );\n\t\t\tv = get< 0 >( G[v][e] );\n\t\t\te = edge_indices_[v][ ( edge_poss_[v][r] + G[v].size() - 1 ) % G[v].size() ];\n\t\t}\n\n\t\t{\n\t\t\tdouble theta = 0;\n\t\t\tfor ( int i = 0; i < int( area.size() ); ++i )\n\t\t\t{\n\t\t\t\tconst Point p1 = area[ ( i + 1 ) % area.size() ] - area[i];\n\t\t\t\tconst Point p2 = area[ ( i + 2 ) % area.size() ] - area[i];\n\t\t\t\ttheta += atan2( cross( p1, p2 ), dot( p1, p2 ) );\n\t\t\t}\n\t\t\tif ( theta < 0 )\n\t\t\t{\n\t\t\t\touter_ = areas_.size();\n\t\t\t}\n\t\t}\n\n\t\tareas_.push_back( area );\n\t\t\n\t\treturn;\n\t}\n\n\t// results\npublic:\n\tint area_number() const\n\t{\n\t\treturn areas_.size();\n\t}\n\n\tstd::vector< std::vector< Point > > areas() const\n\t{\n\t\treturn areas_;\n\t}\n\n\tstd::vector< std::pair< int, int > > edges() const\n\t{\n\t\tstd::vector< std::pair< int, int > > res;\n\t\tfor ( auto &row : intersects_ )\n\t\t{\n\t\t\tres.emplace_back( row[0], row[1] );\n\t\t}\n\t\treturn res;\n\t}\n\n\tint outer() const\n\t{\n\t\treturn outer_;\n\t}\n};\n\nconstexpr int INF = LIM( int )::max() / 2;\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\tfor ( int N, M; cin >> N >> M && ( N | M ); )\n\t{\n\t\tVT( Point ) ps( N );\n\t\tcin >> ps;\n\n\t\tVI s( M ), t( M );\n\t\tREP( i, M )\n\t\t{\n\t\t\tcin >> s[i] >> t[i];\n\t\t\t--s[i], --t[i];\n\t\t}\n\n\t\tDualGraph dualgraph( ps );\n\t\tREP( i, M )\n\t\t{\n\t\t\tdualgraph.connect( s[i], t[i] );\n\t\t}\n\t\tdualgraph.solve();\n\n\t\tconst int V = dualgraph.area_number();\n\t\tVVI G( V );\n\t\t{\n\t\t\tVPII es = dualgraph.edges();\n\t\t\tFOR( e, es )\n\t\t\t{\n\t\t\t\tconst int a = e.fst, b = e.snd;\n\t\t\t\tG[a].PB( b );\n\t\t\t\tG[b].PB( a );\n\t\t\t}\n\t\t}\n\n\t\tVI distances( V, INF );\n\t\tdistances[ dualgraph.outer() ] = 0;\n\n\t\tqueue< int > que;\n\t\tque.push( dualgraph.outer() );\n\n\t\twhile ( !que.empty() )\n\t\t{\n\t\t\tconst int u = que.front();\n\t\t\tque.pop();\n\n\t\t\tFOR( v, G[u] )\n\t\t\t{\n\t\t\t\tif ( distances[u] + 1 < distances[v] )\n\t\t\t\t{\n\t\t\t\t\tdistances[v] = distances[u] + 1;\n\t\t\t\t\tque.push( v );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << *max_element( ALL( distances ) ) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX_C 101\n#define MAX_W 301\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:y<p.y; }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const { return p.p1 == p1 && p.p2 == p2; }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a){ os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\nstruct Edge{\n  int from,to,rev,unique_index;\n  Edge(int from=IINF,int to=IINF):from(from),to(to){}\n};\n\nconst bool DEBUG = false;\nint C,W,sp;\nPoint ps[MAX_C];\nvector<Edge> G[MAX_C];\nvector<vector<int> > poly;\nbool used[MAX_C][MAX_C];\nint depth[MAX_C];\nint index_list[MAX_C][MAX_C];\nvector<int> bfs_G[MAX_C];\n\nbool cmp(const Edge& a,const Edge& b){\n  Vector vec_a = ps[a.to] - ps[a.from];\n  Vector vec_b = ps[b.to] - ps[b.from];\n  return atan2(vec_a.y,vec_a.x) <= atan2(vec_b.y,vec_b.x);\n}\n\nbool getPath(int start_node,int node,int edge,vector<int>& edge_list){\n  if(DEBUG)cout << __LINE__ << \": \" <<  node << \",\" << edge << endl;\n  if( used[node][edge] ){\n    if( !edge_list.empty() && node == start_node ) return true;\n    return false;\n  }\n  used[node][edge] = true;\n\n  int next_node = G[node][edge].to;\n  int next_edge = (G[node][edge].rev+1)%((int)G[next_node].size());\n  edge_list.push_back(G[node][edge].unique_index);\n  if(getPath(start_node,next_node,next_edge,edge_list)){\n    if(DEBUG)cout << __LINE__ << \": path::\"  << node << \",\" << edge << endl;\n    return true;\n  } else {\n    return used[node][edge] = false;\n  }\n}\n  \nint main(){\n  while(cin>>C>>W,C|W){\n    rep(i,MAX_C)depth[i] = IINF,bfs_G[i].clear(),G[i].clear();\n    rep(i,MAX_C)rep(j,MAX_C)used[i][j] = false, index_list[i][j] = IINF;\n    depth[0] = 0;\n    poly.clear();\n    sp = 0;\n    rep(i,C) {\n      cin >> ps[i].x >> ps[i].y;\n      ps[i].x += 1000, ps[i].y += 1000;\n      if( ps[i] < ps[sp] ) sp = i;\n    }\n    rep(i,W) {\n      int s,t;\n      cin >> s >> t;\n      s--,t--;\n      G[s].push_back(Edge(s,t));\n      G[t].push_back(Edge(t,s));\n    }\n    rep(i,C)sort(G[i].begin(),G[i].end(),cmp);\n    int dex = 0;\n    rep(i,C){\n      rep(j,(int)G[i].size()){\n\tint to = G[i][j].to;\n\trep(k,(int)G[to].size()){\n\t  if(G[to][k].to == i){\n\t    G[i][j].rev = k;\n\t    if( index_list[i][j] == IINF ){\n\t      assert(index_list[to][k] == IINF);\n\t      index_list[i][j] = index_list[to][k] = dex++;\n\t    }\n\t    G[i][j].unique_index = index_list[i][j];\n\t    break;\n\t  }\n\t}\n      }\n    }\n    if(DEBUG){\n      cout << __LINE__ << \":\" << endl;\n      cout << \"sp = \" << sp << endl;\n      rep(i,C){\n\tcout << \"i = \" << i << endl;\n\trep(j,G[i].size()){\n\t  cout << \"from = \" << G[i][j].from << \" to = \" << G[i][j].to << \" rev = \" << G[i][j].rev << \" unique = \" << G[i][j].unique_index << endl;\n\t}\n      }\n      cout << endl << endl;\n      rep(i,(int)G[sp].size()){\n\tif( used[sp][i] ) continue;\n\tvector<int> tmp;\n\tif( getPath(sp,sp,i,tmp) ) {\n\t  poly.push_back(tmp);\n\t  cout << \"[\" << sp << \"][\" << i << \"] : getPath!! : \" << endl;\n\t}\n      }\n    }\n    rep(i,C){\n      if( i == sp ) continue;\n      rep(j,G[i].size()){\n\tif( used[i][j] ) continue;\n\tvector<int> tmp;\n\tif( getPath(i,i,j,tmp) ){\n\t  poly.push_back(tmp);\n\t}\n      }\n    }\n\n    rep(i,poly.size()){\n      REP(j,i+1,poly.size()){\n\tbool connect = false;\n\trep(k,poly[i].size()){\n\t  rep(l,poly[j].size()){\n\t    if(poly[i][k] == poly[j][l]){\n\t      connect = true;\n\t      goto Skip;\n\t    }\n\t  }\n\t}\n      Skip:;\n\tif(connect){\n\t  bfs_G[i].push_back(j);\n\t  bfs_G[j].push_back(i);\n\t}\n      }\n    }\n\n    if(DEBUG){\n      cout << __LINE__ << \":\" << endl;\n      cout << \"poly.size() = \" << poly.size() << endl;\n      rep(i,(int)poly.size()){\n\tcout << \"poly[\" << i << \"]\" << endl;\n\trep(j,poly[i].size()){\n\t  cout << poly[i][j] << \" \";\n\t}\n\tcout << endl;\n      }\n\n      cout << \"bfs_G = \" << endl;\n      rep(i,poly.size()){\n\tcout << \"[\" << i << \"]\" << endl;\n\trep(j,bfs_G[i].size()){\n\t  cout << bfs_G[i][j] << \" \";\n\t}\n\tcout << endl;\n      }\n\n      cout << \"depth[\" << 0 << \"] = \" << depth[0] << endl;\n    }\n    int answer = 0;\n    deque<int> deq;\n    deq.push_back(0);\n    while(!deq.empty()){\n      int cur = deq.front(); deq.pop_front();\n      rep(i,bfs_G[cur].size()){\n\tint next = bfs_G[cur][i];\n\tif( depth[next] == IINF ){\n\t  depth[next] = depth[cur] + 1;\n\t  answer = max(answer,depth[next]);\n\t  deq.push_back(next);\n\t}\n      }\n    }\n    cout << answer << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<int,pair<bool,double> > P2;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define min_3(a,b,c) min(a,min(b,c))\n#define max_3(a,b,c) max(a,max(b,c))\n#define mp1(a,b,c) P1(a,P(b,c))\n#define mp2(a,b,c) P2(a,pair<bool,double>(b,c))\n#define pque(a) priority_queue<a>\n#define rpque(a) priority_queue<a,vector<a>,greater<a>>\n\nconst int INF=1000000000;\nconst int dre_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dre_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\nconst int kaijou[10]={1,1,2,6,24,120,720,5040,40320,362880};\n\nbool com(P2 x,P2 y){\n\tif(x.sc.fr!=y.sc.fr)return x.sc.fr;\n\treturn x.sc.sc>=y.sc.sc;\n}\n\nint main(){\n\tint ppp=0;\n\twhile(1){\n\t\t//ppp++; if(ppp>=6)while(1){}\n\t\tstatic int v,w;\n\t\tstatic int x[310],y[310];\n\t\tstatic int s,t;\n\t\t\n\t\tscanf(\"%d%d\",&v,&w); if(v==0&&w==0)break;\n\t\trep1(i,v)scanf(\"%d%d\",&x[i],&y[i]);\n\t\t\n\t\tstatic vector<P1> V_; V_.clear();\n\t\trep1(i,v){\n\t\t\tV_.pb(mp1(x[i],y[i],i));\n\t\t}\n\t\tsor(V_);\n\t\tstatic vector<P2> vec_[310];\n\t\trep1(i,v){\n\t\t\tvec_[i].clear();\n\t\t\tvec_[i].pb(mp2(0,false,-INF));\n\t\t\trep1(j,v){\n\t\t\t\tif(i==j)continue;\n\t\t\t\tif(x[i]<x[j]){\n\t\t\t\t\tvec_[i].pb(mp2(j,true,(double)(y[j]-y[i])/(x[j]-x[i])));\n\t\t\t\t}\n\t\t\t\telse if(x[i]>x[j]){\n\t\t\t\t\tvec_[i].pb(mp2(j,false,(double)(y[j]-y[i])/(x[j]-x[i])));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(y[j]>y[i])vec_[i].pb(mp2(j,true,(double)INF));\n\t\t\t\t\telse vec_[i].pb(mp2(j,true,(double)-INF));\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(vec_[i].begin(),vec_[i].end(),com);\n\t\t}\n\t\t\n\t\tstatic int e;\n\t\tstatic vector<int> V; V.clear();\n\t\tstatic bool edge[310][310];\n\t\tstatic vector<int> vec[310]; \n\t\t\n\t\te=w;\n\t\trep(i,v)V.pb(V_[i].sc.sc);\n\t\trep(i,310)rep(j,310)edge[i][j]=false;\n\t\trep(i,e){\n\t\t\tscanf(\"%d%d\",&s,&t);\n\t\t\tedge[s][t]=true;\n\t\t\tedge[t][s]=true;\n\t\t}\n\t\trep1(i,v){\n\t\t\tvec[i].clear();\n\t\t\trep(j,vec_[i].size()){\n\t\t\t\tvec[i].pb(vec_[i][j].fr);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ret=0;\n\t\twhile(e>0){\n\t\t\tret++;\n\t\t\t\n\t\t\tint a=-1;\n\t\t\trep(i,V.size()){\n\t\t\t\trep(j,105){\n\t\t\t\t\tif(edge[V[i]][j]){a=V[i]; break;}\n\t\t\t\t}\n\t\t\t\tif(a!=-1)break;\n\t\t\t}\n\t\t\t\n\t\t\tint b=0,c=a;\n\t\t\twhile(1){\n\t\t\t\tif(c==-1||vec[c].size()==0)break;\n\t\t\t\trep(i,vec[c].size()){\n\t\t\t\t\tif(vec[c][i]==b){\n\t\t\t\t\t\ti++; i%=vec[c].size();\n\t\t\t\t\t\twhile(!edge[c][vec[c][i]]){\n\t\t\t\t\t\t\ti++; i%=vec[c].size();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tedge[c][vec[c][i]]=false;\n\t\t\t\t\t\tedge[vec[c][i]][c]=false;\n\t\t\t\t\t\te--;\n\t\t\t\t\t\tb=c;\n\t\t\t\t\t\tc=vec[c][i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(c==a)break;\n\t\t\t}\n\t\t\t\n\t\t\tbool updata=true;\n\t\t\twhile(updata){\n\t\t\t\tupdata=false;\n\t\t\t\trep1(i,v){\n\t\t\t\t\tint cnt=0;\n\t\t\t\t\tint t=105;\n\t\t\t\t\trep1(j,v){\n\t\t\t\t\t\tif(edge[i][j]){cnt++; t=j;}\n\t\t\t\t\t}\n\t\t\t\t\tif(cnt==1){\n\t\t\t\t\t\tupdata=true;\n\t\t\t\t\t\tedge[i][t]=false;\n\t\t\t\t\t\tedge[t][i]=false;\n\t\t\t\t\t\te--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <cmath>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\n#define x first\n#define y second\n\ntypedef pair<int,int> pii;\n\nint C, W;\nvector<pii> pole;\nvector<vector<int> > edge;\nvector<pii> edge_set;\n\nvector<vector<int> > face;\nvector<vector<int> > dual_e;\nvector<pii> dual_edge_set;\n\nvector<int> detect_f(pii start, int cur, int prev) {\n\tvector<int> res;\n\tif(pii(cur,prev) == start) {\n\t\treturn res;\n\t}\n\tif(pii(-1,-1) == start)\n\t\tstart = pii(cur,prev);\n\n\tint bx, by, cx, cy;\n\tdouble mn = 10.0;\n\tint nx = -1;\n\tbx = pole[prev].x;\n\tby = pole[prev].y;\n\tcx = pole[cur].x;\n\tcy = pole[cur].y;\n\tfor(int i = 0; i < edge[cur].size(); i++) {\n\t\tif(edge[cur][i] != prev) {\n\t\t\tdouble theta, phi, ag;\n\t\t\tint ax, ay;\n\t\t\tax = pole[edge[cur][i]].x;\n\t\t\tay = pole[edge[cur][i]].y;\n\t\t\ttheta = atan2(by - cy, bx - cx);\n\t\t\tphi   = atan2(ay - cy, ax - cx);\n\t\t\tag = phi - theta + 4*M_PI;\n\t\t\twhile(ag > 2*M_PI) ag -= 2*M_PI;\n\t\t\tif(ag < mn) {\n\t\t\t\tnx = edge[cur][i];\n\t\t\t\tmn = ag;\n\t\t\t}\n\t\t}\n\t}\n\n\tres = detect_f(start, nx, cur);\n\tres.push_back(cur);\n\treturn res;\n}\n\nint face_indx(vector<int> f) {\n\tfor(int i = 0; i < face.size(); i++) {\n\t\tint sz = face[i].size();\n\t\tif(face[i].size() == f.size()) {\n\t\t\tfor(int j = 0; j < face[i].size(); j++) {\n\t\t\t\tbool flg = true;\n\t\t\t\tfor(int k = 0; k < face[i].size() && flg; k++) {\n\t\t\t\t\tflg = flg && (face[i][(j+k)%sz] == f[k]);\n\t\t\t\t}\n\t\t\t\tif(flg) {\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nvoid mkdual() {\n\tfor(int i = 0; i < edge_set.size(); i++) {\n\t\tpii de, e = edge_set[i];\n\t\tfor(int i_ = 0; i_ < 2; i_++) {\n\t\t\tvector<int> f = detect_f(pii(-1,-1), e.second, e.first);\n\t\t\tint indx;\n\t\t\tindx = face_indx(f);\n\t\t\tif(indx < 0) {\n\t\t\t\tindx = face.size();\n\t\t\t\tface.push_back(f);\n\t\t\t}\n\t\t\tde.first = indx;\n\t\t\tswap(e.first, e.second);\n\t\t\tswap(de.first, de.second);\n\t\t}\n\t\tdual_edge_set.push_back(de);\n\t}\n\tdual_e.resize(face.size());\n\tsort(dual_edge_set.begin(), dual_edge_set.end());\n\tdual_edge_set.erase(unique(dual_edge_set.begin(), dual_edge_set.end()), dual_edge_set.end());\n\tfor(int i = 0; i < dual_edge_set.size(); i++) {\n\t\tdual_e[dual_edge_set[i].first].push_back(dual_edge_set[i].second);\n\t\tdual_e[dual_edge_set[i].second].push_back(dual_edge_set[i].first);\n\t}\n}\n\nint solve() {\n\tint ur = 0;\n\tfor(int i = 0; i < pole.size(); i++) {\n\t\tif(pole[ur] < pole[i])\n\t\t\tur = i;\n\t}\n\tint nx = -1;\n\tdouble mn_arg = 100;\n\tfor(int i = 0; i < edge[ur].size(); i++) {\n\t\tdouble arg;\n\t\targ = atan2(pole[edge[ur][i]].y - pole[ur].y,\n\t\t\t\tpole[edge[ur][i]].x - pole[ur].x) - M_PI / 2.0 + 4 * M_PI;\n\t\twhile(arg > 2 * M_PI) arg -= 2 * M_PI;\n\t\t\n\t\tif(arg < mn_arg) {\n\t\t\tmn_arg = arg;\n\t\t\tnx = edge[ur][i];\n\t\t}\n\t}\n\tint start;\n\tvector<int> mnpath;\n\tpriority_queue<pii> q;\n\tconst int INF = 1e9;\n\tstart = face_indx(detect_f(pii(-1,-1), nx, ur));\n\tmnpath.resize(face.size());\n\tfor(int i = 0; i < mnpath.size(); i++) mnpath[i] = INF;\n\tq.push(pii(0,start));\n\twhile(!q.empty()) {\n\t\tpii a = q.top(); q.pop();\n\t\tif(mnpath[a.second] > -a.first) {\n\t\t\tmnpath[a.second] = -a.first;\n\t\t}\n\t\tfor(int i = 0; i < dual_e[a.second].size(); i++) {\n\t\t\tif(mnpath[dual_e[a.second][i]] > -a.first + 1) {\n\t\t\t\tmnpath[dual_e[a.second][i]] = -a.first + 1;\n\t\t\t\tq.push(pii(a.first -1, dual_e[a.second][i]));\n\t\t\t}\n\t\t}\n\t}\n\tint res = -1;\n\tfor(int i = 0; i < mnpath.size(); i++) {\n\t\tres = max(res, mnpath[i]);\n\t}\n\treturn res;\n}\n\nint main() {\n\twhile(cin >> C >> W, C || W) {\n\t\tpole.clear();\n\t\tedge.clear();\n\t\tedge_set.clear();\n\t\tface.clear();\n\t\tdual_edge_set.clear();\n\t\tdual_e.clear();\n\t\tpole.resize(C);\n\t\tedge.resize(C);\n\t\tfor(int i = 0; i < pole.size(); i++) {\n\t\t\tcin >> pole[i].x >> pole[i].y;\n\t\t}\n\t\tfor(int i = 0; i < W; i++) {\n\t\t\tint a, b;\n\t\t\tcin >> a >> b; a--; b--;\n\t\t\tedge_set.push_back(pii(a,b));\n\t\t\tedge[a].push_back(b);\n\t\t\tedge[b].push_back(a);\n\t\t}\n\t\tmkdual();\n\t\t/*\n\t\tfor(int i = 0; i < face.size(); i++) {\n\t\t\tfor(int j = 0; j < face[i].size(); j++)\n\t\t\t\tcout << face[i][j] << \" \";\n\t\t\tcout << endl;\n\t\t} cout << endl;\n\t\t// */\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <ctime>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <fstream>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <numeric>\n#include <cassert>\nusing namespace std;\n\ntypedef complex<double> P;\n\nint C,W;\n\nint wsc[300] , wtc[300];\nP c[100];\nstruct NODE{\n\tint from,to,id;\n\tdouble rad;\n\tNODE(int from,int to,int id) : from(from) , to(to) , id(id) {}\n\tNODE(){}\n\tvoid rRad(){\n\t\tP v = c[to] - c[from];\n\t\trad = atan2(v.imag(),v.real());\n\t}\n};\nvector<NODE> geo[100];\nbool cmp(const NODE &a,const NODE &b){\n\treturn a.rad > b.rad;\n}\nconst double PI = acos(-1);\nint start;\ndouble fx(double rd){\n\tif( rd < 0 )   rd += 2*PI;\n\tif( rd > 2*PI) rd -= 2*PI;\n\treturn rd;\n}\ndouble R(P a){\n\tdouble rd = atan2(a.imag(),a.real());\n\treturn fx(rd);\n}\nint get(int x,int prev,vector<int> &ad){\n\tif( x == start ) return 1;\n\t\n\tdouble r1 = R(c[x]-c[prev]);\n\tdouble bad = 0;\n\tint o = -1;\n\tint id;\n\tfor(int i = 0 ; i < geo[x].size() ; i++){\n\t\tif( geo[x][i].to == prev ) continue;\n\t\tdouble r2 = R(c[geo[x][i].to]-c[x]);\n\t\tdouble rr = fx(r2-r1);\n\t\tif( 0 < rr && rr < PI ){\n\t\t\tif( rr > bad ){\n\t\t\t\to = geo[x][i].to;\n\t\t\t\tbad = rr;\n\t\t\t\tid = geo[x][i].id;\n\t\t\t}\n\t\t}\n\t}\n\tif( o == -1 ) return 0;\n\t\n\tif( get(o,x,ad) ){\n\t\tad.push_back(id);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nint main(){\n\twhile(cin >> C >> W && C){\n\t\tfor(int i = 0 ; i < 100 ; i++) geo[i].clear();\n\t\tfor(int i = 0 ; i < C ; i++)\n\t\t\tcin >> c[i].real() >> c[i].imag();\n\t\tfor(int i = 0 ; i < W ; i++){\n\t\t\tint s,t;\n\t\t\tcin >> s >> t;\n\t\t\ts--,t--;\n\t\t\tgeo[s].push_back(NODE(s,t,i));\n\t\t\tgeo[s].back().rRad();\n\t\t\tgeo[t].push_back(NODE(t,s,i));\n\t\t\tgeo[t].back().rRad();\n\t\t\twsc[i] = s;\n\t\t\twtc[i] = t;\n\t\t\t\n\t\t}\n\t\tfor(int i = 0 ; i < C ; i++){\n\t\t\tsort(geo[i].begin(),geo[i].end(),cmp);\n\t\t}\n\t\t\n\t\tvector< vector<int> > wallset;\n\t\tfor(int _ = 0 ; _ < 2 ; _++){\n\t\t\tfor(int i = 0 ; i < W ; i++){\n\t\t\t\tstart = wsc[i];\n\t\t\t\tvector<int> a;\n\t\t\t\tif( get(wtc[i],wsc[i],a) ){\n\t\t\t\t\ta.push_back(i);\n\t\t\t\t\tsort(a.begin(),a.end());\n\t\t\t\t\twallset.push_back(a);\n\t\t\t\t}\n\t\t\t\tswap(wsc[i],wtc[i]);\n\t\t\t}\n\t\t}\n\t\tsort(wallset.begin(),wallset.end());\n\t\twallset.erase(unique(wallset.begin(),wallset.end()),wallset.end());\n\t\t\n\t\tint wf[101][101]={};\n\t\tfor(int i = 0 ; i < 101 ; i++)\n\t\t\tfor(int j = 0 ; j < 101 ; j++)\n\t\t\t\twf[i][j] = i==j?0:1e9;\n\t\tint N = wallset.size();\n\t\tvector<int> wall_share[300];\n\t\t\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\tfor(int j = 0 ; j < wallset[i].size() ; j++){\n\t\t\t\twall_share[wallset[i][j]].push_back(i);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0 ; i < W ; i++){\n\t\t\tif( wall_share[i].size() == 1 ){\n\t\t\t\twf[wall_share[i][0]][100] = wf[100][wall_share[i][0]] = 1;\n\t\t\t}else if( wall_share[i].size() == 2 ){\n\t\t\t\twf[wall_share[i][0]][wall_share[i][1]] = wf[wall_share[i][1]][wall_share[i][0]] = 1;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0 ; i < 101 ; i++){\n\t\t\tfor(int j = 0 ; j < 101 ; j++){\n\t\t\t\tfor(int k = 0 ; k < 101 ; k++){\n\t\t\t\t\twf[j][k] = min(wf[j][k],wf[j][i]+wf[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i = 0 ; i < 101 ; i++){\n\t\t\tif( wf[i][100] != 1e9 ) ans = max( ans , wf[i][100] );\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<complex>\n#include<deque>\n#include<vector>\nusing namespace std;\ndouble eps=1e-6;\ndouble x[110];\ndouble y[110];\ndouble px[700];\ndouble py[700];\nint ijk[700];\nint v[700];\nint g[700][700];\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ndouble PI=3.14159265358;\ntypedef complex<double> P;\ntypedef vector<P> G;\n\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n#define se second\n#define fi first\n\nbool intersectSS(const pair<P,P> &s, const pair<P,P> &t) {\n  return ccw(s.fi,s.se,t.fi)*ccw(s.fi,s.se,t.se) <= 0 &&\n         ccw(t.fi,t.se,s.fi)*ccw(t.fi,t.se,s.se) <= 0;\n}\n\nP pt[700];\nP ps[300];\nint s[400];\nint t[400];\ndouble left[400];\ndouble right[400];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<a;i++)scanf(\"%lf%lf\",x+i,y+i);\n\t\tfor(int i=0;i<a;i++){\n\t\t\tdouble X=cos(1)*x[i]-sin(1)*y[i];\n\t\t\tdouble Y=sin(1)*x[i]+cos(1)*y[i];\n\t\t\tx[i]=X;\n\t\t\ty[i]=Y;\n\t\t\tps[i]=P(x[i],y[i]);\n\t\t}\n\t\tfor(int i=0;i<b;i++){\n\t\t\tint p,q;scanf(\"%d%d\",&p,&q);\n\t\t\tp--;q--;\n\t\t\ts[i]=p;t[i]=q;\n\t\t\tpx[i*2]=(x[p]+x[q])/2+eps;\n\t\t\tpy[i*2]=(y[p]+y[q])/2;\n\t\t\tpx[i*2+1]=(x[p]+x[q])/2-eps;\n\t\t\tpy[i*2+1]=(y[p]+y[q])/2;\n\t\t\tpt[i*2]=P(px[i*2],py[i*2]);\n\t\t\tpt[i*2+1]=P(px[i*2+1],py[i*2+1]);\n\t\t}\n\t\tdeque<pair<int,int> >Q;\n\t\tfor(int i=0;i<b*2;i++)for(int j=i+1;j<b*2;j++)g[i][j]=g[j][i]=999999999;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tvector<pair<double,pair<int,int> > >vec;\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tif(s[j]==i){\n\t\t\t\t\tvec.push_back(make_pair(atan2(y[t[j]]-y[i],x[t[j]]-x[i]),make_pair(j,t[j])));\n\t\t\t\t}\n\t\t\t\tif(t[j]==i){\n\t\t\t\t\tvec.push_back(make_pair(atan2(y[s[j]]-y[i],x[s[j]]-x[i]),make_pair(j,s[j])));\n\t\t\t\t}\n\t\t\t}\n\t\t\tstd::sort(vec.begin(),vec.end());\n\t\t\tint sz=vec.size();\n\t\t\tfor(int j=0;j<vec.size();j++){\n\t\t\t\tdouble th=vec[j].first;\n\t\t\t\tdouble th2=vec[(j+1)%sz].first;\n\t\t\t\tif(th>th2)th2+=2*PI;\n\t\t\t\tif(th2-th<=PI+EPS)continue;\n\t\t\t\tfor(int k=0;k<2;k++)for(int l=0;l<2;l++){\n\t\t\t\t\tif(intersectSS(make_pair(pt[vec[j].second.first*2+k],pt[vec[(j+1)%sz].second.first*2+l]),\n\t\t\t\t\tmake_pair(ps[i],ps[vec[j].second.second]))&&intersectSS(make_pair(pt[vec[j].second.first*2+k],pt[vec[(j+1)%sz].second.first*2+l]),\n\t\t\t\t\tmake_pair(ps[i],ps[vec[(j+1)%sz].second.second]))){\n\t\t\t\t\t\tg[vec[j].second.first*2+k][vec[(j+1)%sz].second.first*2+l]=g[vec[(j+1)%sz].second.first*2+l][vec[j].second.first*2+k]=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<b*2;i++){\n\t\t\tijk[i]=999999999;\n\t\t\tv[i]=0;\n\t\t\tbool OK=true;\n\t\t\tint tt=s[i/2];\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tif(tt==s[j]||tt==t[j])continue;\n\t\t\t\tif(intersectSS(make_pair(ps[tt],ps[tt]+(pt[i]-ps[tt])*10000.0),make_pair(ps[s[j]],ps[t[j]]))){\n\t\t\t\t\tOK=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttt=t[i/2];\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tif(tt==s[j]||tt==t[j])continue;\n\t\t\t\tif(intersectSS(make_pair(ps[tt],ps[tt]+(pt[i]-ps[tt])*10000.0),make_pair(ps[s[j]],ps[t[j]]))){\n\t\t\t\t\tOK=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(OK){\n\t\t\t\tijk[i]=0;\n\t\t\t\tQ.push_back(make_pair(0,i));\n\t\t\t}\n\t\t\tfor(int j=i+1;j<b*2;j++){\n\t\t\t\tint cnt=0;\n\t\t\t\tfor(int k=0;k<b;k++){\n\t\t\t\t\tif(intersectSS(make_pair(ps[s[k]],ps[t[k]]),make_pair(pt[i],pt[j]))){\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tif(cnt>1)break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(cnt<2)g[i][j]=g[j][i]=cnt;\n\t\t\t}\n\t\t}\n\t\twhile(Q.size()){\n\t\t\tint cost=-Q.front().first;\n\t\t\tint at=Q.front().second;Q.pop_front();\n\t\t\tif(v[at])continue;\n\t\t\tv[at]=1;\n\t\t\tfor(int i=0;i<b*2;i++){\n\t\t\t\tif(!v[i]&&ijk[i]>cost+g[at][i]){\n\t\t\t\t\tijk[i]=cost+g[at][i];\n\t\t\t\t\tif(g[at][i]==1)Q.push_back(make_pair(-ijk[i],i));\n\t\t\t\t\telse Q.push_front(make_pair(-ijk[i],i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret=0;\n\t\tfor(int i=0;i<b*2;i++)ret=max(ret,ijk[i]);\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <vector>\n#include <valarray>\n#include <array>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <random>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\ntypedef double R;\ntypedef complex<R> P;\n\nconst R EPS = 1e-9;\nconst R PI = acos((R)(-1));\n\nint sgn(R a) {\n    if (a < -EPS) return -1;\n    if (a > EPS) return 1;\n    return 0;\n}\n\nR cross(P a, P b) { return a.real()*b.imag() - a.imag()*b.real(); }\n\ntypedef vector<P> Pol;\n\nP cu(const Pol &p, int i) {\n    int s = p.size();\n    return p[(i%s+s)%s];\n}\n\nR area_naive(const Pol &p) {\n    R u = 0;\n    for (int i = 0; i < (int)p.size(); i++) {\n        u += cross(cu(p, i), cu(p, i+1));\n    }\n    return u/2;\n}\n\nR area(const Pol &p) {\n    return abs(area_naive(p));\n}\n\n/*\n -1 -> clock\n 0 -> non polygon\n 1 -> counter clock\n */\nint iscclock(const Pol &p) {\n    return sgn(area_naive(p));\n}\n\nint dualGraph(P p[], vector<int> g[], int n,\n    Pol pol[], vector<int> rg[]) {\n    map<pair<int, int>, int> mp;\n    for (int i = 0; i < n; i++) {\n        sort(g[i].begin(), g[i].end(), [&](int l, int r){\n            return arg(p[l]-p[i]) > arg(p[r]-p[i]);\n        });\n        for (int j = 0; j < (int)g[i].size(); j++) {\n            mp[make_pair(i, g[i][j])] = j;\n        }\n    }\n\n    vector<vector<int>> idx(n), rev(n);\n    for (int i = 0; i < n; i++) {\n        idx[i] = vector<int>(g[i].size(), -1);\n        rev[i].resize(g[i].size());\n        for (int j = 0; j < (int)g[i].size(); j++) {\n            rev[i][j] = mp[make_pair(g[i][j], i)];\n        }\n    }\n\n    int idc = 1;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < (int)g[i].size(); j++) {\n            if (idx[i][j] != -1) continue;\n            Pol po;\n            int ii = i, jj = j;\n            while (idx[ii][jj] != -2) {\n                po.push_back(p[ii]);\n                idx[ii][jj] = -2;\n                int ni = g[ii][jj];\n                int nj = (rev[ii][jj]+1) % g[ni].size();\n                ii = ni; jj = nj;\n            }\n            int id;\n            if (iscclock(po) != 1) {\n                id = 0;\n            } else {\n                id = idc;\n                pol[idc] = po;\n                idc++;\n            }\n            while (idx[ii][jj] == -2) {\n                idx[ii][jj] = id;\n                int ni = g[ii][jj];\n                int nj = (rev[ii][jj]+1) % g[ni].size();\n                ii = ni; jj = nj;\n            }\n        }\n    }\n\n    for (int i = 0; i < idc; i++) {\n        rg[i].clear();\n    }\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < (int)g[i].size(); j++) {\n            if (idx[i][j] < 0) continue;\n            rg[idx[i][j]].push_back(idx[g[i][j]][rev[i][j]]);\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        sort(rg[i].begin(), rg[i].end());\n        rg[i].erase(unique(rg[i].begin(), rg[i].end()), rg[i].end());\n    }\n\n    return idc;\n}\n\nconst int MN = 110;\nP p[MN];\nvector<int> g[MN];\n\nPol pol[2*MN];\nvector<int> rg[2*MN];\n\nint dist[2*MN][2*MN];\n\nbool solve() {\n    int c, w;\n    cin >> c >> w;\n    if (!c) return false;\n\n    for (int i = 0; i < c; i++) {\n        R x, y;\n        cin >> x >> y;\n        p[i] = P(x, y);\n        g[i].clear();\n    }\n\n    for (int i = 0; i < w; i++) {\n        int s, t;\n        cin >> s >> t; s--; t--;\n        g[s].push_back(t);\n        g[t].push_back(s);\n    }\n\n    int m = dualGraph(p, g, c, pol, rg);\n\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < m; j++) {\n            dist[i][j] = 10000;\n        }\n        for (int d: rg[i]) {\n            dist[i][d] = 1;\n        }\n        dist[i][i] = 0;\n    }\n\n    for (int k = 0; k < m; k++) {\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < m; j++) {\n                dist[i][j] = min(dist[i][j], dist[i][k]+dist[k][j]);\n            }\n        }\n    }\n\n    int ma = 0;\n    for (int i = 0; i < m; i++) {\n        ma = max(ma, dist[0][i]);\n    }\n    cout << ma << endl;\n    return true;\n}\n\n\nint main() {\n    while (solve()) {}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <bitset>\n#include <cmath>\n#include <algorithm>\n\n#define TIMES(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef bitset<300> Spec;\nconst double EPS = 1e-9;\nconst double PI = acos(-1);\n\ndouble normalize(double angle) {\n    if(angle < 0) return angle + 2*PI;\n    return angle;\n}\n\nint cmp(double a, double b) {\n    const double diff = a-b;\n    if(fabs(diff) < EPS) return 0;\n    return diff < 0 ? -1 : 1;\n}\n\ndouble dot(const P &a, const P &b) {\n    return a.real()*b.real() + a.imag()*b.imag();\n}\n\ndouble cross(const P &a, const P &b) {\n    return a.real()*b.imag() - a.imag()*b.real();\n}\n\nint root(int n, vector<int> &roots) {\n    if(roots[n] == n) return n;\n    return roots[n] = root(roots[n], roots);\n}\n\nbool unite(int a, int b, vector<int> &roots) {\n    const int ra = root(a, roots);\n    const int rb = root(b, roots);\n    if(ra == rb) return false;\n    roots[ra] = rb;\n    return true;\n}\n\nbool solve() {\n    int C, W;\n    cin >> C >> W;\n    if(!C && !W) return false;\n\n    vector<P> poles;\n    vector<vector<int>> graph(C);\n    vector<vector<int>> wall_id(C, vector<int>(C));\n    TIMES(_, C) {\n        double x, y;\n        cin >> x >> y;\n        poles.push_back(P(x, y));\n    }\n    TIMES(i, W) {\n        int s, t;\n        cin >> s >> t;\n        --s; --t;\n        graph[s].push_back(t);\n        graph[t].push_back(s);\n        wall_id[s][t] = i*2;\n        wall_id[t][s] = i*2+1;\n    }\n\n    vector<int> roots(W*2);\n    TIMES(i, W*2) {\n        roots[i] = i;\n    }\n    TIMES(i, C) {\n        const P &pi = poles[i];\n        for(int j : graph[i]) {\n            const P &pj = poles[j];\n            const P vec = pj - pi;\n            const double len = abs(vec);\n            int candidate = -1;\n            int sin_sgn = -2;\n            double cos_val = 2;\n            for(int k : graph[j]) {\n                if(k == i) continue;\n                const P vec2 = poles[k] - pj;\n                const int sgn = cmp(cross(vec, vec2), 0);\n                const double cv = dot(vec, vec2) / len / abs(vec2) * sgn;\n                if(sgn > sin_sgn\n                    || (sgn == sin_sgn && cmp(cv, cos_val) < 0))\n                {\n                    candidate = k;\n                    sin_sgn = sgn;\n                    cos_val = cv;\n                }\n            }\n            if(candidate != -1) {\n                if(unite(wall_id[i][j], wall_id[j][candidate], roots) && false) {\n                    cout << \"unitea \" << i << \" \" << j << \" \" << candidate << endl;\n                    TIMES(a, W*2) {\n                        cout << root(a, roots) << ' ';\n                    }\n                    cout << endl;\n                }\n            }\n        }\n    }\n    // Determine outside region\n    const int rightmost = distance(poles.begin(),\n            max_element(poles.begin(), poles.end(), [](const P &a, const P &b) {\n                return a.real() < b.real();\n                }));\n    const int rm_next = *min_element(\n            graph[rightmost].begin(), \n            graph[rightmost].end(),\n            [&poles, rightmost](int a, int b) {\n            const double arga = normalize(arg(poles[a] - poles[rightmost]));\n            const double argb = normalize(arg(poles[b] - poles[rightmost]));\n            return arga < argb;\n            });\n    const int out_id = root(wall_id[rm_next][rightmost], roots);\n\n    Spec init;\n    vector<Spec> areas(W*2);\n    TIMES(i, W*2) {\n        const int area = root(i, roots);\n        areas[area][i/2] = true;\n        if(area == out_id) init[i/2] = true;\n        //cout << area << ' ';\n    }\n    /*\n    for(const Spec &s : areas) {\n        if(s.any()) cout << s << endl;\n    }\n    */\n    //cout << endl;\n    Spec cur = init;\n    //cout << init << endl;\n    int turn = 0;\n    vector<bool> used(W*2, false);\n    while(true) {\n        Spec next = cur;\n        bool changed = false;\n        TIMES(i, W*2) {\n            if(!used[i] && (areas[i] & cur).any()) {\n                next |= areas[i];\n                used[i] = true;\n                changed = true;\n            }\n        }\n        if(!changed) break;\n        cur = next;\n        ++turn;\n    }\n    cout << turn << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<complex>\n#include<deque>\n#include<vector>\nusing namespace std;\ndouble eps=1e-6;\ndouble x[110];\ndouble y[110];\ndouble px[700];\ndouble py[700];\nint ijk[700];\nint v[700];\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ndouble PI=3.14159265358;\nstruct P{\n\tdouble x;double y;\n\tP(){}\n\tP(double X,double Y){\n\t\tx=X;y=Y;\n\t}\n\tP operator+ (const P &a)const{\n\t\treturn P(x+a.x,y+a.y);\n\t}\n\tP operator- (const P &a)const{\n\t\treturn P(x-a.x,y-a.y);\n\t}\n\tP operator* (const double &a)const{\n\t\treturn P(x*a,y*a);\n\t}\n\t/*operator+ (P a){\n\t\treturn P(x+a.x,y+a.y);\n\t}\n\toperator+ (P a){\n\t\treturn P(x+a.x,y+a.y);\n\t}*/\n\t\n};\ninline bool operator < (const P& a, const P& b) {\n    return a.x<b.x||(a.x==b.x&&a.y<b.y);\n}\ninline double cross(const P& a, const P& b) {\n\treturn a.x*b.y-a.y*b.x;\n}\ninline double dot(const P& a, const P& b) {\n\treturn a.x*b.x+a.y*b.y;\n}\n\ninline int ccw(const P &a, const P &b, const P &c) {\n\tb=b-a;c=c-a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (b.x*b.x+b.y*b.y<c.x*c.x+c.y*c.y) return -2;       // a--b--c on line\n  return 0;\n}\n#define se second\n#define fi first\n\nbool intersectSS(const pair<P,P> &s, const pair<P,P> &t) {\n  return ccw(s.fi,s.se,t.fi)*ccw(s.fi,s.se,t.se) <= 0 &&\n         ccw(t.fi,t.se,s.fi)*ccw(t.fi,t.se,s.se) <= 0;\n}\n\nP pt[700];\nP ps[300];\nint s[400];\nint t[400];\ndouble left[400];\ndouble right[400];\nvector<pair<int,int> >g[700];\nint UF[700];\nint FIND(int a){\n\tif(UF[a]<0)return a;\n\treturn UF[a]=FIND(UF[a]);\n}\nvoid UNION(int a,int b){\n\ta=FIND(a);b=FIND(b);if(a==b)return;UF[a]+=UF[b];UF[b]=a;\n}\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<700;i++)UF[i]=-1;\n\t\tfor(int i=0;i<700;i++)g[i].clear();\n\t\tfor(int i=0;i<a;i++)scanf(\"%lf%lf\",x+i,y+i);\n\t\tfor(int i=0;i<a;i++){\n\t\t\tdouble X=cos(1)*x[i]-sin(1)*y[i];\n\t\t\tdouble Y=sin(1)*x[i]+cos(1)*y[i];\n\t\t\tx[i]=X;\n\t\t\ty[i]=Y;\n\t\t\tps[i]=P(x[i],y[i]);\n\t\t}\n\t\tfor(int i=0;i<b;i++){\n\t\t\tint p,q;scanf(\"%d%d\",&p,&q);\n\t\t\tp--;q--;\n\t\t\ts[i]=p;t[i]=q;\n\t\t\tpx[i*2]=(x[p]+x[q])/2+eps;\n\t\t\tpy[i*2]=(y[p]+y[q])/2;\n\t\t\tpx[i*2+1]=(x[p]+x[q])/2-eps;\n\t\t\tpy[i*2+1]=(y[p]+y[q])/2;\n\t\t\tpt[i*2]=P(px[i*2],py[i*2]);\n\t\t\tpt[i*2+1]=P(px[i*2+1],py[i*2+1]);\n\t\t}\n\t\tdeque<pair<int,int> >Q;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tvector<pair<double,pair<int,int> > >vec;\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tif(s[j]==i){\n\t\t\t\t\tvec.push_back(make_pair(atan2(y[t[j]]-y[i],x[t[j]]-x[i]),make_pair(j,t[j])));\n\t\t\t\t}\n\t\t\t\tif(t[j]==i){\n\t\t\t\t\tvec.push_back(make_pair(atan2(y[s[j]]-y[i],x[s[j]]-x[i]),make_pair(j,s[j])));\n\t\t\t\t}\n\t\t\t}\n\t\t\tstd::sort(vec.begin(),vec.end());\n\t\t\tint sz=vec.size();\n\t\t\tfor(int j=0;j<vec.size();j++){\n\t\t\t\tdouble th=vec[j].first;\n\t\t\t\tdouble th2=vec[(j+1)%sz].first;\n\t\t\t\tif(th>th2)th2+=2*PI;\n\t\t\t\tif(th2-th<=PI+EPS)continue;\n\t\t\t\tfor(int k=0;k<2;k++)for(int l=0;l<2;l++){\n\t\t\t\t\tif(intersectSS(make_pair(pt[vec[j].second.first*2+k],pt[vec[(j+1)%sz].second.first*2+l]),\n\t\t\t\t\tmake_pair(ps[i],ps[vec[j].second.second]))&&intersectSS(make_pair(pt[vec[j].second.first*2+k],pt[vec[(j+1)%sz].second.first*2+l]),\n\t\t\t\t\tmake_pair(ps[i],ps[vec[(j+1)%sz].second.second]))){\n\t\t\t\t\t\tg[vec[j].second.first*2+k].push_back(make_pair(vec[(j+1)%sz].second.first*2+l,0));\n\t\t\t\t\t\tg[vec[(j+1)%sz].second.first*2+l].push_back(make_pair(vec[j].second.first*2+k,0));\n\t\t\t\t\t\tUNION(vec[j].second.first*2+k,vec[(j+1)%sz].second.first*2+l);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<b*2;i++){\n\t\t\tijk[i]=999999999;\n\t\t\tv[i]=0;\n\t\t\tbool OK=true;\n\t\t\tint tt=s[i/2];\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tif(tt==s[j]||tt==t[j])continue;\n\t\t\t\tif(intersectSS(make_pair(ps[tt],ps[tt]+(pt[i]-ps[tt])*10000.0),make_pair(ps[s[j]],ps[t[j]]))){\n\t\t\t\t\tOK=false;break;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttt=t[i/2];\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tif(tt==s[j]||tt==t[j])continue;\n\t\t\t\tif(intersectSS(make_pair(ps[tt],ps[tt]+(pt[i]-ps[tt])*10000.0),make_pair(ps[s[j]],ps[t[j]]))){\n\t\t\t\t\tOK=false;break;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(OK){\n\t\t\t\tijk[i]=0;\n\t\t\t\tQ.push_back(make_pair(0,i));\n\t\t\t}\n\t\t\tfor(int j=i+1;j<b*2;j++){\n\t\t\t\tint cnt=0;\n\t\t\t\tif(FIND(i)==FIND(j))continue;\n\t\t\t\tfor(int k=0;k<b;k++){\n\t\t\t\t\tif(intersectSS(make_pair(ps[s[k]],ps[t[k]]),make_pair(pt[i],pt[j]))){\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tif(cnt>1)break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(cnt<2){\n\t\t\t\t\tif(cnt==0){\n\t\t\t\t\t\tUNION(i,j);\n\t\t\t\t\t}\n\t\t\t\t\tg[i].push_back(make_pair(j,cnt));\n\t\t\t\t\tg[j].push_back(make_pair(i,cnt));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(Q.size()){\n\t\t\tint cost=-Q.front().first;\n\t\t\tint at=Q.front().second;Q.pop_front();\n\t\t\tif(v[at])continue;\n\t\t\tv[at]=1;\n\t\t\tfor(int i=0;i<g[at].size();i++){\n\t\t\t\tif(!v[g[at][i].first]&&ijk[g[at][i].first]>cost+g[at][i].second){\n\t\t\t\t\tijk[g[at][i].first]=cost+g[at][i].second;\n\t\t\t\t\tif(g[at][i].second==1)Q.push_back(make_pair(-ijk[g[at][i].first],g[at][i].first));\n\t\t\t\t\telse Q.push_front(make_pair(-ijk[g[at][i].first],g[at][i].first));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret=0;\n\t\tfor(int i=0;i<b*2;i++)ret=max(ret,ijk[i]);\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cassert>\nusing namespace std;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n\treturn abs(a.real()-b.real()) > EPS ? real(a) < real(b) : imag(a) + EPS < imag(b);\n    //return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\nP readPoint(){\n\tdouble x,y;\n\tcin >> x >> y;\n\treturn P(x,y);\n}\n\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\ntypedef vector<P> G;\n\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\n\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\nP reflection(const L &l, const P &p) {\n  return p + 2. * (projection(l, p) - p);\n}\ndouble distanceLP(const L &l, const P &p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\n#define rep(i,N) for(int i = 0 ; i < N ; i++)\nP ps[110];\nvector<int> g[110];\n\nvector<int> normalize(vector<int> v){\n\tauto it = min_element(v.begin(),v.end());\n\trotate(v.begin(),it,v.end());\n\treturn v;\n}\n\nint done[110];\nvoid f(int a,int b,int s,vector<int> &v){\n\tv.push_back(b);\n\tif( b == s ) return;\n\tif( done[b]++ ) throw 0;\n\tsort(g[b].begin(),g[b].end(),[&](int x,int y){\n\t\tP A = ps[x] - ps[b];\n\t\tP B = ps[y] - ps[b];\n\t\treturn cross(A,B) > 0;\n\t});\n\trotate(g[b].begin(),find(g[b].begin(),g[b].end(),a),g[b].end());\n\tf(b,g[b][1],s,v);\n}\n\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n\ndouble area2(const G& P) {\n  double A = 0;\n  for (int i = 0; i < P.size(); ++i) \n    A += cross(curr(P, i), next(P, i));\n  return A;\n}\n\nint main(){\n\t\n\tint C,W;\n\twhile( cin >> C >> W && (C||W) ){\n\t\trep(i,C) ps[i] = readPoint();\n\t\trep(i,C) g[i].clear();\n\t\trep(i,W){\n\t\t\tint a,b;\n\t\t\tcin >> a >> b;\n\t\t\t--a,--b;\n\t\t\tg[a].push_back(b);\n\t\t\tg[b].push_back(a);\n\t\t}\n\t\tvector< vector<int> > poly;\n\t\tset< set<int> > prevs; \n\t\trep(i,C){\n\t\t\trep(j,g[i].size()){\n\t\t\t\ttry{\n\t\t\t\t\tmemset(done,0,sizeof(done));\n\t\t\t\t\tvector<int> v;\n\t\t\t\t\tf(i,g[i][j],i,v);\n\t\t\t\t\tif( prevs.count(set<int>(v.begin(),v.end())) ) continue;\n\t\t\t\t\tpoly.push_back(normalize(v));\n\t\t\t\t\tprevs.insert(set<int>(v.begin(),v.end()));\n\t\t\t\t}catch(int x){\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(poly.begin(),poly.end());\n\t\tpoly.erase(unique(poly.begin(),poly.end()),poly.end());\n\t\tsort(poly.begin(),poly.end(),[&](vector<int> a,vector<int> b){\n\t\t\tvector<P> g1,g2;\n\t\t\trep(k,a.size()) g1.push_back(ps[a[k]]);\n\t\t\trep(k,b.size()) g2.push_back(ps[b[k]]);\n\t\t\treturn abs(area2(g1)) > abs(area2(g2));\n\t\t});\n\t\tmap< pair<int,int>, vector<int> > edgs;\n\t\tfor(int i = 0 ; i < poly.size() ; i++){\n\t\t\tfor(int j = 0 ; j < poly[i].size() ; j++){\n\t\t\t\tint A = curr(poly[i],j);\n\t\t\t\t//cout << A << \" \";\n\t\t\t\tint B = next(poly[i],j);\n\t\t\t\tif( A > B ) swap(A,B);\n\t\t\t\tedgs[pair<int,int>(A,B)].push_back(i);\n\t\t\t}\n\t\t\t//cout << endl;\n\t\t}\n\t\tint M = poly.size();\n\t\tint wf[M][M];\n\t\trep(i,M) rep(j,M){\n\t\t\twf[i][j] = i==j?0:1e9;\n\t\t}\n\t\t\n\t\tfor( auto x : edgs ){\n\t\t\tvector<int> v = x.second;\n\t\t\tif( v.size() < 2 ) v.push_back(0);\n\t\t\tassert( v.size() != 3 );\n\t\t\tif( v[0] != v[1] ) wf[v[0]][v[1]] = wf[v[1]][v[0]] = 1;\n\t\t}\n\t\trep(i,M)rep(j,M)rep(k,M) wf[j][k] = min(wf[j][i]+wf[i][k],wf[j][k]);\n\t\tint ans = 1;\n\t\trep(i,M){\n\t\t\tans = max(ans,wf[i][0]);\n\t\t}\n\t\tcout << ans << endl;\n\t\t\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<int,pair<bool,double>> P2;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define min_3(a,b,c) min(a,min(b,c))\n#define max_3(a,b,c) max(a,max(b,c))\n#define mp1(a,b,c) P1(a,P(b,c))\n#define mp2(a,b,c) P2(a,pair<bool,double>(b,c))\n#define pque(a) priority_queue<a>\n#define rpque(a) priority_queue<a,vector<a>,greater<a>>\n\nconst int INF=1000000000;\nconst int dre_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dre_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\nconst int kaijou[10]={1,1,2,6,24,120,720,5040,40320,362880};\n\nbool com(P2 x,P2 y){\n\tif(x.sc.fr!=y.sc.fr)return x.sc.fr;\n\treturn x.sc.sc>=y.sc.sc;\n}\n\nint main(){\n\twhile(1){\n\t\tint c,w;\n\t\tint x[110],y[110];\n\t\tint s,t;\n\t\t\n\t\tscanf(\"%d%d\",&c,&w); if(c==0&&w==0)break;\n\t\trep1(i,c)scanf(\"%d%d\",&x[i],&y[i]);\n\t\t\n\t\tvector<P1> V_;\n\t\trep1(i,c){\n\t\t\tV_.pb(mp1(x[i],y[i],i));\n\t\t}\n\t\tsor(V_);\n\t\tvector<P2> vec_[110];\n\t\trep1(i,c){\n\t\t\tvec_[i].pb(mp2(0,false,-INF));\n\t\t\trep1(j,c){\n\t\t\t\tif(i==j)continue;\n\t\t\t\tif(x[i]<x[j]){\n\t\t\t\t\tvec_[i].pb(mp2(j,true,(double)(y[j]-y[i])/(x[j]-x[i])));\n\t\t\t\t}\n\t\t\t\telse if(x[i]>x[j]){\n\t\t\t\t\tvec_[i].pb(mp2(j,false,(double)(y[j]-y[i])/(x[j]-x[i])));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(y[j]>y[i])vec_[i].pb(mp2(j,true,(double)INF));\n\t\t\t\t\telse vec_[i].pb(mp2(j,true,(double)-INF));\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(vec_[i].begin(),vec_[i].end(),com);\n\t\t}\n\t\t\n\t\tint v,e;\n\t\tvector<int> V;\n\t\tbool edge[110][110];\n\t\tvector<int> vec[110];\n\t\t\n\t\tv=c; e=w;\n\t\trep(i,c)V.pb(V_[i].sc.sc);\n\t\trep(i,110)rep(j,110)edge[i][j]=false;\n\t\trep(i,e){\n\t\t\tscanf(\"%d%d\",&s,&t);\n\t\t\tedge[s][t]=true;\n\t\t\tedge[t][s]=true;\n\t\t}\n\t\trep1(i,c){\n\t\t\trep(j,vec_[i].size()){\n\t\t\t\tvec[i].pb(vec_[i][j].fr);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ret=0;\n\t\twhile(e>0){\n\t\t\tret++;\n\t\t\t\n\t\t\tint a=-1;\n\t\t\trep(i,V.size()){\n\t\t\t\trep(j,105){\n\t\t\t\t\tif(edge[V[i]][j]){a=V[i]; break;}\n\t\t\t\t}\n\t\t\t\tif(a!=-1)break;\n\t\t\t}\n\t\t\t\n\t\t\tint b=0,c=a;\n\t\t\twhile(1){\n\t\t\t\trep(i,vec[c].size()){\n\t\t\t\t\tif(vec[c][i]==b){\n\t\t\t\t\t\ti++; i%=vec[c].size();\n\t\t\t\t\t\twhile(!edge[c][vec[c][i]]){\n\t\t\t\t\t\t\ti++; i%=vec[c].size();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tedge[c][vec[c][i]]=false;\n\t\t\t\t\t\tedge[vec[c][i]][c]=false;\n\t\t\t\t\t\te--;\n\t\t\t\t\t\tb=c;\n\t\t\t\t\t\tc=vec[c][i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(c==a)break;\n\t\t\t}\n\t\t\t\n\t\t\tbool updata=true;\n\t\t\twhile(updata){\n\t\t\t\tupdata=false;\n\t\t\t\trep(i,105){\n\t\t\t\t\tint cnt=0;\n\t\t\t\t\tint t=105;\n\t\t\t\t\trep(j,105){\n\t\t\t\t\t\tif(edge[i][j]){cnt++; t=j;}\n\t\t\t\t\t}\n\t\t\t\t\tif(cnt==1){\n\t\t\t\t\t\tupdata=true;\n\t\t\t\t\t\tedge[i][t]=false;\n\t\t\t\t\t\tedge[t][i]=false;\n\t\t\t\t\t\te--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<complex>\n#include<deque>\n#include<vector>\nusing namespace std;\ndouble eps=1e-6;\ndouble x[110];\ndouble y[110];\ndouble px[700];\ndouble py[700];\nint ijk[700];\nint v[700];\nint g[700][700];\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ndouble PI=3.14159265358;\nstruct P{\n\tdouble x;double y;\n\tP(){}\n\tP(double X,double Y){\n\t\tx=X;y=Y;\n\t}\n\tP operator+ (P a){\n\t\treturn P(x+a.x,y+a.y);\n\t}\n\tP operator- (P a){\n\t\treturn P(x-a.x,y-a.y);\n\t}\n\tP operator* (double a){\n\t\treturn P(x*a,y*a);\n\t}\n\t/*operator+ (P a){\n\t\treturn P(x+a.x,y+a.y);\n\t}\n\toperator+ (P a){\n\t\treturn P(x+a.x,y+a.y);\n\t}*/\n\t\n};\n  bool operator < (const P& a, const P& b) {\n    return a.x<b.x||(a.x==b.x&&a.y<b.y);\n  }\ndouble cross(const P& a, const P& b) {\n\treturn a.x*b.y-a.y*b.x;\n}\ndouble dot(const P& a, const P& b) {\n\treturn a.x*b.x+a.y*b.y;\n}\n\nint ccw(P a, P b, P c) {\n\tb=b-a;c=c-a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (b.x*b.x+b.y*b.y<c.x*c.x+c.y*c.y) return -2;       // a--b--c on line\n  return 0;\n}\n#define se second\n#define fi first\n\nbool intersectSS(const pair<P,P> &s, const pair<P,P> &t) {\n  return ccw(s.fi,s.se,t.fi)*ccw(s.fi,s.se,t.se) <= 0 &&\n         ccw(t.fi,t.se,s.fi)*ccw(t.fi,t.se,s.se) <= 0;\n}\n\nP pt[700];\nP ps[300];\nint s[400];\nint t[400];\ndouble left[400];\ndouble right[400];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<a;i++)scanf(\"%lf%lf\",x+i,y+i);\n\t\tfor(int i=0;i<a;i++){\n\t\t\tdouble X=cos(1)*x[i]-sin(1)*y[i];\n\t\t\tdouble Y=sin(1)*x[i]+cos(1)*y[i];\n\t\t\tx[i]=X;\n\t\t\ty[i]=Y;\n\t\t\tps[i]=P(x[i],y[i]);\n\t\t}\n\t\tfor(int i=0;i<b;i++){\n\t\t\tint p,q;scanf(\"%d%d\",&p,&q);\n\t\t\tp--;q--;\n\t\t\ts[i]=p;t[i]=q;\n\t\t\tpx[i*2]=(x[p]+x[q])/2+eps;\n\t\t\tpy[i*2]=(y[p]+y[q])/2;\n\t\t\tpx[i*2+1]=(x[p]+x[q])/2-eps;\n\t\t\tpy[i*2+1]=(y[p]+y[q])/2;\n\t\t\tpt[i*2]=P(px[i*2],py[i*2]);\n\t\t\tpt[i*2+1]=P(px[i*2+1],py[i*2+1]);\n\t\t}\n\t\tdeque<pair<int,int> >Q;\n\t\tfor(int i=0;i<b*2;i++)for(int j=i+1;j<b*2;j++)g[i][j]=g[j][i]=999999999;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tvector<pair<double,pair<int,int> > >vec;\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tif(s[j]==i){\n\t\t\t\t\tvec.push_back(make_pair(atan2(y[t[j]]-y[i],x[t[j]]-x[i]),make_pair(j,t[j])));\n\t\t\t\t}\n\t\t\t\tif(t[j]==i){\n\t\t\t\t\tvec.push_back(make_pair(atan2(y[s[j]]-y[i],x[s[j]]-x[i]),make_pair(j,s[j])));\n\t\t\t\t}\n\t\t\t}\n\t\t\tstd::sort(vec.begin(),vec.end());\n\t\t\tint sz=vec.size();\n\t\t\tfor(int j=0;j<vec.size();j++){\n\t\t\t\tdouble th=vec[j].first;\n\t\t\t\tdouble th2=vec[(j+1)%sz].first;\n\t\t\t\tif(th>th2)th2+=2*PI;\n\t\t\t\tif(th2-th<=PI+EPS)continue;\n\t\t\t\tfor(int k=0;k<2;k++)for(int l=0;l<2;l++){\n\t\t\t\t\tif(intersectSS(make_pair(pt[vec[j].second.first*2+k],pt[vec[(j+1)%sz].second.first*2+l]),\n\t\t\t\t\tmake_pair(ps[i],ps[vec[j].second.second]))&&intersectSS(make_pair(pt[vec[j].second.first*2+k],pt[vec[(j+1)%sz].second.first*2+l]),\n\t\t\t\t\tmake_pair(ps[i],ps[vec[(j+1)%sz].second.second]))){\n\t\t\t\t\t\tg[vec[j].second.first*2+k][vec[(j+1)%sz].second.first*2+l]=g[vec[(j+1)%sz].second.first*2+l][vec[j].second.first*2+k]=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<b*2;i++){\n\t\t\tijk[i]=999999999;\n\t\t\tv[i]=0;\n\t\t\tbool OK=true;\n\t\t\tint tt=s[i/2];\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tif(tt==s[j]||tt==t[j])continue;\n\t\t\t\tif(intersectSS(make_pair(ps[tt],ps[tt]+(pt[i]-ps[tt])*10000.0),make_pair(ps[s[j]],ps[t[j]]))){\n\t\t\t\t\tOK=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttt=t[i/2];\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tif(tt==s[j]||tt==t[j])continue;\n\t\t\t\tif(intersectSS(make_pair(ps[tt],ps[tt]+(pt[i]-ps[tt])*10000.0),make_pair(ps[s[j]],ps[t[j]]))){\n\t\t\t\t\tOK=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(OK){\n\t\t\t\tijk[i]=0;\n\t\t\t\tQ.push_back(make_pair(0,i));\n\t\t\t}\n\t\t\tfor(int j=i+1;j<b*2;j++){\n\t\t\t\tint cnt=0;\n\t\t\t\tfor(int k=0;k<b;k++){\n\t\t\t\t\tif(intersectSS(make_pair(ps[s[k]],ps[t[k]]),make_pair(pt[i],pt[j]))){\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tif(cnt>1)break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(cnt<2)g[i][j]=g[j][i]=cnt;\n\t\t\t}\n\t\t}\n\t\twhile(Q.size()){\n\t\t\tint cost=-Q.front().first;\n\t\t\tint at=Q.front().second;Q.pop_front();\n\t\t\tif(v[at])continue;\n\t\t\tv[at]=1;\n\t\t\tfor(int i=0;i<b*2;i++){\n\t\t\t\tif(!v[i]&&ijk[i]>cost+g[at][i]){\n\t\t\t\t\tijk[i]=cost+g[at][i];\n\t\t\t\t\tif(g[at][i]==1)Q.push_back(make_pair(-ijk[i],i));\n\t\t\t\t\telse Q.push_front(make_pair(-ijk[i],i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret=0;\n\t\tfor(int i=0;i<b*2;i++)ret=max(ret,ijk[i]);\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\n \nconst double INF = 1e12;\ntypedef complex<double> P,point;\ntypedef vector<P> G,polygon;\nnamespace std {bool operator < (const P& a, const P& b) {return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);} }\ndouble cross(const P& a, const P& b) {return imag(conj(a)*b);}\ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\n\nint main(){\n\tint C,W;\n\twhile(cin >> C >> W && C){\n\t\tvector<P> p(C);\n\t\tfor(int i = 0 ; i < C ; i++) cin >> p[i].real() >> p[i].imag();\n\t\tmap< P,vector<P> > g;\n\t\tvector< pair<P,P> > e;\n\t\tfor(int i = 0 ; i < W ; i++){\n\t\t\tint a,b;\n\t\t\tcin >> a >> b;\n\t\t\ta--,b--;\n\t\t\tg[p[a]].push_back(p[b]);\n\t\t\tg[p[b]].push_back(p[a]);\n\t\t\te.push_back(make_pair(p[a],p[b]));\n\t\t\te.push_back(make_pair(p[b],p[a]));\n\t\t}\n\t\tvector< vector<P> > wall;\n\t\tset< vector<P> > already;\n\t\t\n\t\tfor(int j = 0 ; j < e.size() ; j++){\n\t\t\tP A = e[j].first;\n\t\t\tP B = e[j].second;\n\t\t\tvector<P> chain;\n\t\t\tchain.push_back(A);\n\t\t\tint fail = 0;\n\t\t\tdo{\n\t\t\t\tchain.push_back(B);\n\t\t\t\tvector< pair<double,P> > pos;\n\t\t\t\tfor(int i = 0 ; i < g[B].size() ; i++){\n\t\t\t\t\tif( g[B][i] != A && cross(B-A,g[B][i]-A) > 0 ){\n\t\t\t\t\t\tP s = A-B;\n\t\t\t\t\t\tP t = g[B][i]-B;\n\t\t\t\t\t\tdouble tmp = acos(dot(s,t) / abs(s) / abs(t));\n\t\t\t\t\t\tpos.push_back(make_pair(tmp,g[B][i]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsort(pos.begin(),pos.end());\n\t\t\t\tif( pos.size() == 0 ){ fail = 1; break; }\n\t\t\t\tA = pos[0].second;\n\t\t\t\tswap(A,B);\n\t\t\t}while( B != e[j].first );\n\t\t\tif( fail ) continue;\n\t\t\tvector<P> key = chain;\n\t\t\tsort(key.begin(),key.end());\n\t\t\tif( !already.count(key) ){\n\t\t\t\twall.push_back(chain);\n\t\t\t\talready.insert(key);\n\t\t\t\t//for(int i = 0 ; i < chain.size() ; i++) cout << chain[i] << \" \"; cout << endl;\n\t\t\t}\n\t\t}\n\t\tvector< vector<int> > wf(wall.size()+1,vector<int>(wall.size()+1));\n\t\tfor(int i = 0 ; i < wf.size() ; i++)\n\t\t\tfor(int j = 0 ; j < wf.size() ; j++)\n\t\t\t\twf[i][j] = i != j ? 1e9 : 0;\n\t\tset< pair<P,P> > usedEdge;\n\t\tfor(int i = 0 ; i < wall.size() ; i++){\n\t\t\tfor(int j = 0 ; j < wall.size() ; j++){\n\t\t\t\tif( i != j ) {\n\t\t\t\t\tset< pair<P,P> > tmp;\n\t\t\t\t\tfor(int k = 0 ; k < wall[i].size() ; k++){\n\t\t\t\t\t\tP a = wall[i][k] , b = wall[i][(k+1)%wall[i].size()];\n\t\t\t\t\t\tif( b < a ) swap(a,b);\n\t\t\t\t\t\ttmp.insert(make_pair(a,b));\n\t\t\t\t\t}\n\t\t\t\t\tint connect = 0;\n\t\t\t\t\tfor(int k = 0 ; k < wall[j].size() ; k++){\n\t\t\t\t\t\tP a = wall[j][k] , b = wall[j][(k+1)%wall[j].size()];\n\t\t\t\t\t\tif( b < a ) swap(a,b);\n\t\t\t\t\t\tif( tmp.count( make_pair(a,b) ) ){\n\t\t\t\t\t\t\tconnect = 1;\n\t\t\t\t\t\t\tusedEdge.insert(make_pair(a,b));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif( connect ) wf[i][j] = wf[j][i] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0 ; i < wall.size() ; i++){\n\t\t\tint connectOutside = 0;\n\t\t\tfor(int k = 0 ; k < wall[i].size() ; k++){\n\t\t\t\tP a = wall[i][k] , b = wall[i][(k+1)%wall[i].size()];\n\t\t\t\tif( b < a ) swap(a,b);\n\t\t\t\tif( !usedEdge.count( make_pair(a,b) ) ) connectOutside = 1;\n\t\t\t}\n\t\t\tif(connectOutside)wf[wall.size()][i] = wf[i][wall.size()] = 1;\n\t\t}\n\t\tfor(int i = 0 ; i < wf.size() ; i++)\n\t\t\tfor(int j = 0 ; j < wf.size() ; j++)\n\t\t\t\tfor(int k = 0 ; k < wf.size() ; k++)\n\t\t\t\t\twf[j][k] = min(wf[j][k],wf[j][i]+wf[i][k]);\n\t\tint res = -1e9;\n\t\tfor(int i = 0 ; i < wall.size() ; i++)\n\t\t\tres = max(res,wf[wall.size()][i]);\n\t\twhile( res == 1e9 );\n\t\tcout << res << endl;\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <queue>\n#include <cstdio>\n#include <cassert>\n#include <algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst double EPS=1e-8;\nconst double PI=acos(-1);\n\nstruct point{\n\tdouble x,y;\n\tpoint():x(0),y(0){}\n\tpoint(double x,double y):x(x),y(y){}\n\tpoint &operator+=(const point &a){ x+=a.x; y+=a.y; return *this; }\n\tpoint &operator-=(const point &a){ x-=a.x; y-=a.y; return *this; }\n\tpoint &operator*=(double c){ x*=c; y*=c; return *this; }\n\tpoint &operator/=(double c){ x/=c; y/=c; return *this; }\n\tpoint operator+(const point &a)const{ return point(x+a.x,y+a.y); }\n\tpoint operator-(const point &a)const{ return point(x-a.x,y-a.y); }\n\tpoint operator/(double c)const{ return point(x/c,y/c); }\n\tpoint operator-()const{ return point(-x,-y); }\n\tbool operator< (const point &a)const{ return x+EPS<a.x || (abs(x-a.x)<EPS && y+EPS<a.y); }\n\tbool operator==(const point &a)const{ return abs(x-a.x)<EPS && abs(y-a.y)<EPS; }\n\tbool operator!=(const point &a)const{ return abs(x-a.x)>EPS || abs(y-a.y)>EPS; }\n};\n\ndouble cross(const point &a,const point &b){ return a.x*b.y-a.y*b.x; }\n\ndouble arg(const point &a){ double t=atan2(a.y,a.x); return t<0?t+2*PI:t; }\n\ntypedef vector<point> polygon;\n\nbool is_ccw(const polygon &F){\n\tint n=F.size();\n\tdouble A=0;\n\trep(i,n) A+=cross(F[i],F[(i+1)%n]);\n\treturn A>-EPS;\n}\n\n// trace the frame of a polygon\nvector<int> trace(int n,const vector<int> *G,int u0,int i0){\n\tvector<int> F;\n\tint u=u0,i=i0;\n\tdo{\n\t\tF.push_back(u);\n\t\tint v=G[u][i];\n\t\tint k=G[v].size();\n\t\trep(j,k) if(G[v][j]==u) i=(j-1+k)%k;\n\t\tu=v;\n\t}while(u!=u0);\n\treturn F;\n}\n\n// normalize the list of vertices\nvector<int> reg(vector<int> a){\n\tint k=min_element(a.begin(),a.end())-a.begin();\n\trep(i,k){\n\t\ta.push_back(a[0]);\n\t\ta.erase(a.begin());\n\t}\n\treturn a;\n}\n\nint main(){\n\tfor(int n,m;scanf(\"%d%d\",&n,&m),n;){\n\t\tpoint P[100];\n\t\trep(u,n) scanf(\"%lf%lf\",&P[u].x,&P[u].y);\n\n\t\tvector<int> G[100];\n\t\trep(i,m){\n\t\t\tint u,v; scanf(\"%d%d\",&u,&v); u--; v--;\n\t\t\tG[u].push_back(v);\n\t\t\tG[v].push_back(u);\n\t\t}\n\n\t\t// angle sort\n\t\trep(u,n){\n\t\t\tint k=G[u].size();\n\t\t\tpair<double,int> A[100];\n\t\t\trep(i,k){\n\t\t\t\tint v=G[u][i];\n\t\t\t\tA[i]=make_pair(arg(P[v]-P[u]),v);\n\t\t\t}\n\t\t\tsort(A,A+k);\n\t\t\trep(i,k) G[u][i]=A[i].second;\n\t\t}\n\n\t\t// decompose to polygons\n\t\tvector< vector<int> > F; // set of polygons\n\t\trep(u,n) rep(i,G[u].size()) F.push_back(reg(trace(n,G,u,i)));\n\t\tsort(F.begin(),F.end());\n\t\tF.erase(unique(F.begin(),F.end()),F.end());\n\n\t\t// find the outside boundary\n\t\tint n2=F.size(),u0=-1;\n\t\trep(u,n2){\n\t\t\tint k=F[u].size();\n\t\t\tpolygon H(k);\n\t\t\trep(i,k) H[i]=P[F[u][i]];\n\t\t\tif(!is_ccw(H)){\n// if(u0!=-1) for(;;);\n//\t\t\t\tassert(u0==-1);\n\t\t\t\tu0=u;\n\t\t\t}\n\t\t}\nif(u0==-1) for(;;);\n\t\tassert(u0!=-1);\n\n\t\t// build the dual graph\n\t\tvector<int> G2[100];\n\t\trep(u,n2) rep(v,u) {\n\t\t\tbool ok=false;\n\t\t\tint nu=F[u].size(),nv=F[v].size();\n\t\t\trep(i,nu) rep(j,nv) if(F[u][i]==F[v][(j+1)%nv] && F[u][(i+1)%nu]==F[v][j]) ok=true;\n\t\t\tif(ok){\n\t\t\t\tG2[u].push_back(v);\n\t\t\t\tG2[v].push_back(u);\n\t\t\t}\n\t\t}\n\n\t\t// BFS\n\t\tint d[100];\n\t\trep(u,n2) d[u]=(u==u0?0:-1);\n\t\tqueue<int> Q;\n\t\tQ.push(u0);\n\t\twhile(!Q.empty()){\n\t\t\tint u=Q.front(); Q.pop();\n\t\t\trep(i,G2[u].size()){\n\t\t\t\tint v=G2[u][i];\n\t\t\t\tif(d[v]==-1) d[v]=d[u]+1, Q.push(v);\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",*max_element(d,d+n2));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for ( int i = 0; i < n; i++ )\n#define INF (1<<21)\n#define MAX 104\nint n, m;\nbool V[MAX][MAX];\nint T[MAX][MAX];\nint F[MAX][MAX];\nint face;\nvector<int> G[MAX];\npair<int, int> P[MAX];\nvector<vector<pair<int, int> > > R; // room;\n\ndouble angle(int s, int t){\n  return atan2(P[t].second - P[s].second, P[t].first - P[s].first);\n}\n\nvoid parse(int s, int t, bool isouter, int f){\n  if ( V[s][t] || s == t ) return;\n  int cur1 = s, cur2 = t;\n  vector<pair<int, int> > room;\n  while(1){\n    if ( V[cur1][cur2] ) break;\n    V[cur1][cur2] = true;\n    F[cur1][cur2] = f;\n    room.push_back(make_pair(cur1, cur2));\n    int nx;\n    rep(i, G[cur2].size() ){\n      if ( G[cur2][i] == cur1 ){ nx = i; break; } // next node after counter-clock\n    }\n    nx = (nx+1)%G[cur2].size();\n    cur1 = cur2;\n    cur2 = G[cur2][nx];\n  }\n  R.push_back(room);\n}\n\nbool isConnected(vector<pair<int, int> > &c1, vector<pair<int, int> > &c2){\n  for ( int i = 0; i < c1.size(); i++ ){\n    for ( int j = 0; j < c2.size(); j++ ){\n      pair<int, int> p1 = c1[i];\n      pair<int, int> p2 = c2[j];\n      if ( p1 == p2 ) return true;\n      swap(p2.first, p2.second);\n      if ( p1 == p2 ) return true;\n    }\n  }\n  return false;\n}\n\nvector<vector<int> > makeGraph(){\n  R.clear();\n  // sort by angle\n  rep(s, n) {\n    for ( int e = G[s].size()-2; e >= 0; e--){\n      for ( int j = 0; j <= e; j++ ){\n    \t  if ( angle(s, G[s][j]) > angle(s, G[s][j+1]) ) swap(G[s][j], G[s][j+1]);\n      }\n    }\n  }\n\n  rep(i, n) rep(j, n) V[i][j] = false;\n\n  int bottom = 0;\n  rep(i, n){\n    if ( P[i].second == P[bottom].second ){\n      if ( P[i].first < P[bottom].first ) bottom = i;\n    } else {\n      if ( P[i].second < P[bottom].second ) bottom = i;\n    }\n  }\n\n  face = 0;\n  rep(i, n) rep(j, n) F[i][j] = -1;\n\n  parse(bottom, G[bottom][0], true, face); // the outer\n\n  rep(s, n)  rep(j, G[s].size()){\n    int t =  G[s][j];\n    parse(s, t, false, ++face);\n  }\n\n  rep(i, n) rep(j, n) {\n    if ( F[i][j] == -1 ){\n      assert( F[j][i] == -1);\n      continue;\n    }\n    assert( F[i][j] != F[j][i] );\n  }\n\n\n  vector<vector<int> > g;\n  g.resize(R.size());\n  for ( int i = 0; i < R.size()-1; i++ ){\n    for ( int j = i+1; j < R.size(); j++ ){\n      if ( isConnected(R[i], R[j])) {\n    g[i].push_back(j);\n    g[j].push_back(i);\n      }\n    }\n  }\n\n  assert( n - m + R.size() == 2 );\n\n  return g;\n}\n\nint bfs(vector<vector<int> > g){\n  vector<int> d;\n  d.resize(g.size());\n  rep(i, g.size()) d[i] = INF;\n  queue<int> Q;\n  int u, v;\n  for ( d[0] = 0, Q.push(0); !Q.empty(); ){\n    u = Q.front(); Q.pop();\n    for ( int i = 0; i < g[u].size(); i++ ){\n      int v = g[u][i];\n      if ( d[v] != INF ) continue;\n      d[v] = d[u] + 1;\n      Q.push(v);\n    }\n  }\n  int maxv = 0;\n  for ( int i = 0; i < d.size(); i++) maxv = max(maxv, d[i]);\n  return maxv;\n}\n\nint main(){\n  while(1){\n    cin >> n >> m;\n    if ( n == 0 ) break;\n    assert( 3 <= n && n <= 100 );\n    assert( n <= m && m <= 300 );\n    set<pair<int, int> > S;\n    rep(i, n) {cin >> P[i].first >> P[i].second;S.insert( P[i]) ;}\n    assert( S.size() == n );\n    rep(i, n) G[i].clear();\n    map<pair<int, int>, bool> vis;\n    rep(i, m){\n      int s, t; cin >> s >> t; s--; t--;\n      G[s].push_back(t);G[t].push_back(s);\n      T[s][t] = T[t][s] = (i+1); // 0 = outer\n      vis[make_pair(min(s, t), max(s,t))] = true;\n    }\n\n    cout << bfs(makeGraph()) << endl;\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <ctime>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <fstream>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <numeric>\n#include <cassert>\nusing namespace std;\n\ntypedef complex<double> P;\nconst double PI = acos(-1);\n\ndouble fx(double rd){\n\twhile( rd < -1e-9 )   rd += 2*PI;\n\twhile( rd >= 2*PI - 1e-9) rd -= 2*PI;\n\treturn rd;\n}\ndouble R(P a){\n\tdouble rd = atan2(a.imag(),a.real());\n\treturn fx(rd);\n}\n\nint C,W;\n\nint wsc[300] , wtc[300];\nP c[100];\nstruct NODE{\n\tint from,to,id;\n\tdouble rad;\n\tNODE(int from,int to,int id) : from(from) , to(to) , id(id) {\n\t\trad = R(c[to]-c[from]);\n\t}\n\tNODE(){}\n};\nbool operator < (const NODE &a,const NODE &b){\n\treturn a.rad < b.rad;\n}\nvector<NODE> geo[100];\nint done[100];\n\nint start;\nint get(int x,int prev,vector<int> &ad){\n\tif( x == start ) return 1;\n\tif( done[x] ) return 0;\n\telse done[x] = true;\n\t\n\tfor(int i = 0 ; i < geo[x].size() ; i++){\n\t\tint y = (i+1)%geo[x].size();\n\t\tif( geo[x][i].to == prev ){\t\t\t\n\t\t\tif( get(geo[x][y].to,x,ad) ){\n\t\t\t\t//ad.push_back(x);\n\t\t\t\tad.push_back(geo[x][y].id);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nnamespace std {bool operator < (const P& a, const P& b) {return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);} }\ndouble cross(const P& a, const P& b) {return imag(conj(a)*b);}\ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;\n\tif (cross(b, c) < 0)   return -1;\n\tif (dot(b, c) < 0) return +2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n// Totsuhou! Andrew's Monotone Chain //\nvector<P> convex_hull(vector<P> ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<P> ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);} };\nstatic const double EPS = 1e-9;\nbool intersectSP(const L &s, const P &p) {return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;}\n\ndouble intersect2SP(const L &s, const P &p) {\n\tcout << \"[\" << s[0] << \",\" << s[1] << \"]\" << \",\" << p << endl;\n\treturn abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]);\n}\n\n\nint main(){\n\twhile(cin >> C >> W && C){\n\t\tfor(int i = 0 ; i < 100 ; i++) geo[i].clear();\n\t\tfor(int i = 0 ; i < C ; i++)\n\t\t\tcin >> c[i].real() >> c[i].imag();\n\t\tfor(int i = 0 ; i < W ; i++){\n\t\t\tint s,t;\n\t\t\tcin >> s >> t;\n\t\t\ts--,t--;\n\t\t\tgeo[s].push_back(NODE(s,t,i));\n\t\t\tgeo[t].push_back(NODE(t,s,i));\n\t\t\twsc[i] = s;\n\t\t\twtc[i] = t;\n\t\t}\n\t\tfor(int i = 0 ; i < 100 ; i++) sort(geo[i].begin(),geo[i].end());\n\t\t\n\t\tvector< vector<int> > wallset;\n\t\tfor(int _ = 0 ; _ < 2 ; _++){\n\t\t\tfor(int i = 0 ; i < W ; i++){\n\t\t\t\tmemset(done,0,sizeof(done));\n\t\t\t\tstart = wsc[i];\n\t\t\t\tvector<int> a;\n\t\t\t\tif( get(wtc[i],wsc[i],a) ){\n\t\t\t\t\t//a.push_back(wsc[i]);\n\t\t\t\t\ta.push_back(i);\n\t\t\t\t\tsort(a.begin(),a.end());\n\t\t\t\t\twallset.push_back(a);\n\t\t\t\t}\n\t\t\t\tswap(wsc[i],wtc[i]);\n\t\t\t}\n\t\t}\n\t\tsort(wallset.begin(),wallset.end());\n\t\twallset.erase(unique(wallset.begin(),wallset.end()),wallset.end());\n\t\t\n\t\t\n\t\tint wf[301][301]={};\n\t\tfor(int i = 0 ; i < 301 ; i++)\n\t\t\tfor(int j = 0 ; j < 301 ; j++)\n\t\t\t\twf[i][j] = i==j?0:1e9;\n\t\tint N = wallset.size();\n\t\tvector<int> wall_share[300];\n\t\t\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\t//cout << \"[\" << i << \"]\" << endl;\n\t\t\tfor(int j = 0 ; j < wallset[i].size() ; j++){\n\t\t\t\twall_share[wallset[i][j]].push_back(i);\n\t\t\t//\tcout << c[wsc[wallset[i][j]]] << \"-\" << c[wtc[wallset[i][j]]] << \" \";\n\t\t\t}\n\t\t\t//cout << endl;\n\t\t}\n\t\tfor(int i = 0 ; i < W ; i++){\n\t\t\tfor(int j = 0 ; j <wall_share[i].size() ; j++){\n\t\t\t\tfor(int k = 0 ; k < wall_share[i].size() ; k++){\n\t\t\t\t\tif(j!=k)wf[wall_share[i][j]][wall_share[i][k]] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<P> p;\n\t\tfor(int i = 0 ; i < C ; i++) p.push_back(c[i]);\n\t\tp = convex_hull(p);\n\t\t//for(int i = 0 ; i < p.size() ; i++) cout << p[i] << \" \";\n\t\t//cout << endl;\n\t\tint soto = -1;\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\tint o = 1;\n\t\t\tfor(int j = 0 ; j < wallset[i].size() ; j++){\n\t\t\t\tint w = 0;\n\t\t\t\tfor(int k = 0 ; k < p.size() ; k++){\n\t\t\t\t\tif( intersectSP(L(p[k],p[(k+1)%p.size()]),c[wsc[wallset[i][j]]]) && intersectSP(L(p[k],p[(k+1)%p.size()]),c[wtc[wallset[i][j]]]) ){\n\t\t\t\t\t\t//cout << \"OK\" << endl;\n\t\t\t\t\t\tw = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!w){\n\t\t\t\t\to = 0;\n\t\t\t\t\t/*cout << \"----------\" << endl;\n\t\t\t\t\tcout << (intersectSP(L(P(2,0),P(8,0)),wsc[wall_share[i][j]]) ) << \" \" << (intersectSP(L(P(2,0),P(8,0)),wtc[wall_share[i][j]])) << endl;\n\t\t\t\t\tcout << (intersect2SP(L(P(2,0),P(8,0)),wsc[wall_share[i][j]]) ) << \" \" << (intersect2SP(L(P(2,0),P(8,0)),wtc[wall_share[i][j]])) << endl;\n\t\t\t\t\t\n\t\t\t\t\tcout << endl;\n\t\t\t\t\t*/\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(o) soto = i ;//, cout << soto << \"<\" << endl;\n\t\t}\n\t\twhile(soto==-1);\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\tfor(int j = 0 ; j < N ; j++){\n\t\t\t\tfor(int k = 0 ; k < N ; k++){\n\t\t\t\t\twf[j][k] = min(wf[j][k],wf[j][i]+wf[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 1;\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\tans = max( ans , wf[i][soto] );\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <iostream>\nusing namespace std;\n#define PI 3.14159265\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> P;\n#define fi first\n#define sc second\nint main()\n{\n\tint c,w;\n\twhile(1)\n\t{\n\t\tint con[105]={};\n\t\tbool used[305]={};\n\t\tP ma[305]={};\n\t\tdouble x[105]={},y[105]={};\n\t\tvector<P>edge[105];\n\t\tfor(int i=0;i<105;i++) edge[i].clear();\n\t\tscanf(\"%d%d\",&c,&w); if(c == 0 && w == 0) return 0;\n\t\tfor(int i=0;i<c;i++)\n\t\t{\n\t\t\tscanf(\"%lf%lf\",&x[i],&y[i]);\n\t\t}\n\t\tfor(int i=0;i<w;i++)\n\t\t{\n\t\t\tint a,b;\n\t\t\tscanf(\"%d%d\",&a,&b);\n\t\t\ta--; b--; con[a]++; con[b]++;\n\t\t\tma[i] = mp(a,b);\n\t\t\tedge[a].pb(mp(b,i));\n\t\t\tedge[b].pb(mp(a,i));\n\t\t}\n\t\tint cnt = 0;\n\t\tint v = c;\n\t\tint e = w;\n\t\twhile(1)\n\t\t{\n\t\t\tif(v-1 == e || v == 0)\n\t\t\t{\n\t\t\t\tprintf(\"%d\\n\",cnt);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcnt++;\n\t\t\tint beg = -1;\n\t\t\tdouble val = -1000000;\n\t\t\tfor(int i=0;i<c;i++)\n\t\t\t{\n\t\t\t\tif(!con[i]) continue;\n\t\t\t\tif(val < y[i])\n\t\t\t\t{\n\t\t\t\t\tval = y[i];\n\t\t\t\t\tbeg = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint cur = beg; bool ch = false;\n\t\t\tbool u[305]={};\n\t\t\tint pre = -1;\n\t\t\twhile(!(cur==beg && ch))\n\t\t\t{\n\t\t\t\tdouble ang;\n\t\t\t\tif(!ch) ang = 0.0;\n\t\t\t\telse ang = atan2(y[pre]-y[cur],x[pre]-x[cur])*180.0/PI;\n\t\t\t\tif(ang < 0.0) ang += 360.0;\n\t\t\t\tch = true;\n\t\t\t\tdouble aq = 1000000.0; int id = -1; int nxt,id2;\n\t\t\t\tfor(int i=0;i<edge[cur].size();i++)\n\t\t\t\t{\n\t\t\t\t\tif(pre == edge[cur][i].fi) id2 = edge[cur][i].sc;\n\t\t\t\t\tif(used[edge[cur][i].sc] || pre == edge[cur][i].fi) continue;\n\n\t\t\t\t\tdouble ang2 = atan2(y[edge[cur][i].fi]-y[cur],x[edge[cur][i].fi]-x[cur])*180.0/PI;\n\t\t\t\t\twhile(ang > ang2) ang2+=360.0;\n\t\t\t\t\tif(aq > ang2-ang)\n\t\t\t\t\t{\n\t\t\t\t\t\taq = ang2-ang;\n\t\t\t\t\t\tnxt = edge[cur][i].fi;\n\t\t\t\t\t\tid = edge[cur][i].sc;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(id == -1) { id = id2; nxt = pre;}\n\t\t\t\tu[id] = true;\n\t\t\t\tpre = cur; cur = nxt; //cout << cur << \" \" << endl;\n\t\t\t}\n\t\t\tfor(int i=0;i<w;i++)\n\t\t\t{\n\t\t\t\tif(used[i]) continue;\n\t\t\t\tif(!u[i]) continue;\n\t\t\t\tused[i] = true; e--;\n\t\t\t\tcon[ma[i].fi]--; con[ma[i].sc]--;\n\t\t\t\tif(con[ma[i].fi] == 0) v--;\n\t\t\t\tif(con[ma[i].sc] == 0) v--;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<int,int> state;\n\nint N,M;\nP t[100];\nint f[100][100];\nint d[100][100];\n\nvoid init(){\n  memset(f,0,sizeof(f));\n  memset(d,1,sizeof(d));\n}\n\nbool check(int from,int to){\n  P base=t[to]-t[from];\n  for(int i=0;i<N;i++){\n    P target=t[i]-t[from];\n    if(imag(target*conj(base))<0)\n      return false;\n  }\n  return true;\n}\n\nint solve(){\n  deque<state> Q;\n  \n  for(int i=0;i<N;i++){\n    for(int j=0;j<N;j++){\n      if(f[i][j]&&check(i,j)){\n        d[i][j]=0;\n        Q.push_front(state(i,j));\n      }\n    }\n  }\n  \n  int ans=0;\n  while(!Q.empty()){\n    state p=Q.front();\n    Q.pop_front();\n    int from=p.first;\n    int to=p.second;\n\n    \n    ans=max(ans,d[from][to]);\n    if(d[from][to]+1<d[to][from]){\n      d[to][from]=d[from][to]+1;\n      Q.push_back(state(to,from));\n    }\n    int id=-1;\n    double mini=1e9;\n    for(int i=0;i<N;i++){\n      if(f[to][i]&&i!=from){\n        if( arg( (t[i]-t[to])*conj(t[to]-t[from]) ) < mini){\n          id=i;\n          mini=arg( (t[i]-t[to])*conj(t[to]-t[from]) );\n        }\n      }\n    }\n\n    if(id!=-1&&d[to][id]>d[from][to]){\n      d[to][id]=d[from][to];\n      Q.push_front(state(to,id));\n    }\n  }\n  return ans;\n}\n\nint main(){\n  while(1){\n    cin>>N>>M;\n    if(N==0&&M==0)break;\n    init();\n    for(int i=0;i<N;i++){\n      int x,y;\n      cin>>x>>y;\n      t[i]=P(x,y);\n    }\n    for(int i=0;i<M;i++){\n      int x,y;\n      cin>>x>>y;\n      x--,y--;\n      f[x][y]=f[y][x]=true;\n    }\n    cout<<solve()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<complex>\n#include<deque>\n#include<vector>\nusing namespace std;\ndouble eps=1e-6;\ndouble x[110];\ndouble y[110];\ndouble px[700];\ndouble py[700];\nint ijk[700];\nint v[700];\nint g[700][700];\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ndouble PI=3.14159265358;\nstruct P{\n\tdouble x;double y;\n\tP(){}\n\tP(double X,double Y){\n\t\tx=X;y=Y;\n\t}\n\tP operator+ (const P &a)const{\n\t\treturn P(x+a.x,y+a.y);\n\t}\n\tP operator- (const P &a)const{\n\t\treturn P(x-a.x,y-a.y);\n\t}\n\tP operator* (const double &a)const{\n\t\treturn P(x*a,y*a);\n\t}\n\t/*operator+ (P a){\n\t\treturn P(x+a.x,y+a.y);\n\t}\n\toperator+ (P a){\n\t\treturn P(x+a.x,y+a.y);\n\t}*/\n\t\n};\n  bool operator < (const P& a, const P& b) {\n    return a.x<b.x||(a.x==b.x&&a.y<b.y);\n  }\ndouble cross(const P& a, const P& b) {\n\treturn a.x*b.y-a.y*b.x;\n}\ndouble dot(const P& a, const P& b) {\n\treturn a.x*b.x+a.y*b.y;\n}\n\nint ccw(P a, P b, P c) {\n\tb=b-a;c=c-a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (b.x*b.x+b.y*b.y<c.x*c.x+c.y*c.y) return -2;       // a--b--c on line\n  return 0;\n}\n#define se second\n#define fi first\n\nbool intersectSS(const pair<P,P> &s, const pair<P,P> &t) {\n  return ccw(s.fi,s.se,t.fi)*ccw(s.fi,s.se,t.se) <= 0 &&\n         ccw(t.fi,t.se,s.fi)*ccw(t.fi,t.se,s.se) <= 0;\n}\n\nP pt[700];\nP ps[300];\nint s[400];\nint t[400];\ndouble left[400];\ndouble right[400];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<a;i++)scanf(\"%lf%lf\",x+i,y+i);\n\t\tfor(int i=0;i<a;i++){\n\t\t\tdouble X=cos(1)*x[i]-sin(1)*y[i];\n\t\t\tdouble Y=sin(1)*x[i]+cos(1)*y[i];\n\t\t\tx[i]=X;\n\t\t\ty[i]=Y;\n\t\t\tps[i]=P(x[i],y[i]);\n\t\t}\n\t\tfor(int i=0;i<b;i++){\n\t\t\tint p,q;scanf(\"%d%d\",&p,&q);\n\t\t\tp--;q--;\n\t\t\ts[i]=p;t[i]=q;\n\t\t\tpx[i*2]=(x[p]+x[q])/2+eps;\n\t\t\tpy[i*2]=(y[p]+y[q])/2;\n\t\t\tpx[i*2+1]=(x[p]+x[q])/2-eps;\n\t\t\tpy[i*2+1]=(y[p]+y[q])/2;\n\t\t\tpt[i*2]=P(px[i*2],py[i*2]);\n\t\t\tpt[i*2+1]=P(px[i*2+1],py[i*2+1]);\n\t\t}\n\t\tdeque<pair<int,int> >Q;\n\t\tfor(int i=0;i<b*2;i++)for(int j=i+1;j<b*2;j++)g[i][j]=g[j][i]=999999999;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tvector<pair<double,pair<int,int> > >vec;\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tif(s[j]==i){\n\t\t\t\t\tvec.push_back(make_pair(atan2(y[t[j]]-y[i],x[t[j]]-x[i]),make_pair(j,t[j])));\n\t\t\t\t}\n\t\t\t\tif(t[j]==i){\n\t\t\t\t\tvec.push_back(make_pair(atan2(y[s[j]]-y[i],x[s[j]]-x[i]),make_pair(j,s[j])));\n\t\t\t\t}\n\t\t\t}\n\t\t\tstd::sort(vec.begin(),vec.end());\n\t\t\tint sz=vec.size();\n\t\t\tfor(int j=0;j<vec.size();j++){\n\t\t\t\tdouble th=vec[j].first;\n\t\t\t\tdouble th2=vec[(j+1)%sz].first;\n\t\t\t\tif(th>th2)th2+=2*PI;\n\t\t\t\tif(th2-th<=PI+EPS)continue;\n\t\t\t\tfor(int k=0;k<2;k++)for(int l=0;l<2;l++){\n\t\t\t\t\tif(intersectSS(make_pair(pt[vec[j].second.first*2+k],pt[vec[(j+1)%sz].second.first*2+l]),\n\t\t\t\t\tmake_pair(ps[i],ps[vec[j].second.second]))&&intersectSS(make_pair(pt[vec[j].second.first*2+k],pt[vec[(j+1)%sz].second.first*2+l]),\n\t\t\t\t\tmake_pair(ps[i],ps[vec[(j+1)%sz].second.second]))){\n\t\t\t\t\t\tg[vec[j].second.first*2+k][vec[(j+1)%sz].second.first*2+l]=g[vec[(j+1)%sz].second.first*2+l][vec[j].second.first*2+k]=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<b*2;i++){\n\t\t\tijk[i]=999999999;\n\t\t\tv[i]=0;\n\t\t\tbool OK=true;\n\t\t\tint tt=s[i/2];\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tif(tt==s[j]||tt==t[j])continue;\n\t\t\t\tif(intersectSS(make_pair(ps[tt],ps[tt]+(pt[i]-ps[tt])*10000.0),make_pair(ps[s[j]],ps[t[j]]))){\n\t\t\t\t\tOK=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttt=t[i/2];\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tif(tt==s[j]||tt==t[j])continue;\n\t\t\t\tif(intersectSS(make_pair(ps[tt],ps[tt]+(pt[i]-ps[tt])*10000.0),make_pair(ps[s[j]],ps[t[j]]))){\n\t\t\t\t\tOK=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(OK){\n\t\t\t\tijk[i]=0;\n\t\t\t\tQ.push_back(make_pair(0,i));\n\t\t\t}\n\t\t\tfor(int j=i+1;j<b*2;j++){\n\t\t\t\tint cnt=0;\n\t\t\t\tfor(int k=0;k<b;k++){\n\t\t\t\t\tif(intersectSS(make_pair(ps[s[k]],ps[t[k]]),make_pair(pt[i],pt[j]))){\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tif(cnt>1)break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(cnt<2)g[i][j]=g[j][i]=cnt;\n\t\t\t}\n\t\t}\n\t\twhile(Q.size()){\n\t\t\tint cost=-Q.front().first;\n\t\t\tint at=Q.front().second;Q.pop_front();\n\t\t\tif(v[at])continue;\n\t\t\tv[at]=1;\n\t\t\tfor(int i=0;i<b*2;i++){\n\t\t\t\tif(!v[i]&&ijk[i]>cost+g[at][i]){\n\t\t\t\t\tijk[i]=cost+g[at][i];\n\t\t\t\t\tif(g[at][i]==1)Q.push_back(make_pair(-ijk[i],i));\n\t\t\t\t\telse Q.push_front(make_pair(-ijk[i],i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret=0;\n\t\tfor(int i=0;i<b*2;i++)ret=max(ret,ijk[i]);\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF (1<<20)\ntypedef pair<double,int> P;\n \n/* 平面幾何の基本要素 */\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a) - (b)) < EPS )\n  \nclass Point { // 点を表すクラス\n  public:\n  double x,y;\n    \n  Point(double x=0,double y=0): x(x),y(y) {}\n    \n  Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n  Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n  Point operator * (double a) { return Point(a * x, a * y); }\n  Point operator / (double a) { return Point(x / a, y / a); }\n  \n  double abs() { return sqrt(norm()); }\n  double norm() { return x * x + y * y; }\n    \n  bool operator < (const Point &p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  \n  bool operator == (const Point &p) const {\n    return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n  }\n};\n  \ntypedef Point Vector; // ベクトルを表す構造体\n  \nstruct Segment { // 線分を表す構造体\n  Point p1,p2;\n};\n  \ntypedef Segment Line; // 直線を表す構造体\n  \nclass Circle { // 円を表すクラス\npublic:\n  Point c;\n  double r;\n  Circle(Point c = Point(), double r = 0.0): c(c),r(r) {}\n};\ntypedef vector < Point > Polygon; // 多角形\n \nPoint post[111];\nvector<P> wall[111];\nint wall_id[333][111];\nint C,W;\nint s[333],c[333];\nbool used[333][111];\nint out_i,out_v;\nint out;\nvector<int> area[333];\nvector<int> edge[333];\nint dis[1000];\n \nvoid make_node(int i,int v,int node_num){\n  vector<int> ret;\n  int sp = i;\n  used[sp][v] = true;\n  ret.push_back(sp);\n  if(i==out_i&&v==out_v) out=node_num;\n  while(1){\n    i = wall[v][(wall_id[i][v]+1)%wall[v].size()].second;\n    if(s[i]==v) v = c[i];\n    else v = s[i];\n    if(i==sp) break;\n    used[i][v] = true;\n    ret.push_back(i);\n    if(i==out_i&&v==out_v) out=node_num;\n  }\n  for(int i=0;i<ret.size();i++) area[ret[i]].push_back(node_num);\n}\n \nvoid bfs(int n,int s){\n  for(int i=0;i<n;i++){\n    dis[i] = -1;\n  }\n  dis[s] = 0;\n  queue<int> que;\n  que.push(s);\n  while(!que.empty()){\n    int v = que.front();\n    que.pop();\n    for(int i=0;i<edge[v].size();i++){\n      if(dis[edge[v][i]] == -1){\n    que.push(edge[v][i]);\n    dis[edge[v][i]] = dis[v]+1;\n      }\n    }\n  }\n}\n \nint main(){\n  while(cin >> C >> W , C){\n    for(int i=0;i<111;i++) wall[i].clear();\n    for(int i=0;i<333;i++){\n      area[i].clear();\n      edge[i].clear();\n    }\n    memset(wall_id,-1,sizeof(wall_id));\n    int lp = 0;\n    for(int i=0;i<C;i++){\n      cin >> post[i].x >> post[i].y;\n      if(post[i].x<post[lp].x) lp = i;\n    }\n    for(int i=0;i<W;i++){\n      cin >> s[i] >> c[i];\n      s[i]--; c[i]--;\n      double dx = post[c[i]].x-post[s[i]].x;\n      double dy = post[c[i]].y-post[s[i]].y;\n      wall[s[i]].push_back(P(atan2(dy,dx),i));\n      wall[c[i]].push_back(P(atan2(-dy,-dx),i));\n    }\n    for(int i=0;i<C;i++) sort(wall[i].begin(),wall[i].end());\n    int bt=0;\n    for(int i=0;i<C;i++){\n      for(int j=0;j<wall[i].size();j++){\n    wall_id[wall[i][j].second][i]=j;\n    if(i==lp){\n      int u,v;\n      if(s[wall[i][j].second]==lp) u = c[wall[i][j].second];\n      else u = s[wall[i][j].second];\n      if(s[wall[i][bt].second]==lp) v = c[wall[i][bt].second];\n      else v = s[wall[i][j].second];\n      double tmp1 = atan2(post[u].y-post[i].y,post[u].x-post[i].x);\n      double tmp2 = atan2(post[v].y-post[i].y,post[v].x-post[i].x);\n      if(tmp1>tmp2) bt = j;\n    }\n      }\n    }\n    out_i = wall[lp][bt].second;\n    out_v = lp;\n    for(int i=0;i<W;i++){\n      for(int j=0;j<C;j++){\n    used[i][j] = false;\n      }\n    }\n    int node_cnt=0;\n    for(int i=0;i<W;i++){\n      if(used[i][s[i]]==false){\n    make_node(i,s[i],node_cnt);\n    node_cnt++;\n      }\n      if(used[i][c[i]]==false){\n    make_node(i,c[i],node_cnt);\n    node_cnt++;\n      }\n    }\n    for(int i=0;i<W;i++){\n      edge[area[i][0]].push_back(area[i][1]);\n      edge[area[i][1]].push_back(area[i][0]);\n    }\n    bfs(node_cnt,out);\n    int ans = 0;\n    for(int i=0;i<node_cnt;i++) ans=max(ans,dis[i]);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<queue>\n#include<tuple>\n#include<functional>\n#include<cfloat>\n#include<algorithm>\n\nconst int NIL = -1;\nconst double INF = DBL_MAX / 3.0;\n\n// Edge\nclass Edge {\npublic:\n    Edge(const int f, const int t, const double w) :from_(f), to_(t), weight_(w), color_(NIL) {}\n    int from() const {return from_;}\n    int to() const {return to_;}\n    double weight() const {return weight_;}\n    int color() const {return color_;}\n    int color(const int c) {return color_ = c;}\n    bool operator<(const Edge& e) const {\n        if(from() != e.from()) return from() < e.from();\n        if(to() != e.to()) return to() < e.to();\n        return weight() < e.weight();\n    }\nprivate:\n    int from_, to_;\n    double weight_;\n    int color_;\n};\n\n// Graph\nclass Graph {\npublic:\n    explicit Graph(int s) :size_(s) {edge_.resize(s);}\n\n    int size() const;\n    const std::vector<Edge>& edge(const int v) const;\n\n    void add(const Edge& e);\n    void add(const int from, const int to, const double weight);\n\n    const std::vector<double> Dijkstra_all(const int start) const;\n\nprivate:\n    int size_;\n    std::vector<std::vector<Edge>> edge_;\n};\n\n// implements\nint Graph::size() const {return size_;}\nconst std::vector<Edge>& Graph::edge(const int v) const {return edge_[v];}\nvoid Graph::add(const Edge& e) {edge_[e.from()].push_back(e);}\nvoid Graph::add(const int from, const int to, const double weight) {edge_[from].push_back(Edge(from, to, weight));}\nconst std::vector<double> Graph::Dijkstra_all(const int start) const {\n    enum {COST, VERTEX};\n    typedef std::tuple<double, int> Node;\n    std::vector<double> result(size(), INF);\n    std::priority_queue<Node, std::vector<Node>, std::greater<Node>> q;\n    q.push(Node(0, start));\n    while(!q.empty()) {\n        double cost = std::get<COST>(q.top());\n        int from = std::get<VERTEX>(q.top());\n        q.pop();\n        if(result[from] <= cost) continue;\n        result[from] = cost;\n        for(const auto& e: edge(from)) q.push(Node(cost + e.weight(), e.to()));\n    }\n    return result;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#include<iostream>\n#include<set>\nusing namespace std;\n\nstruct Point {\n    double x, y;\n    Point() {}\n    Point(const double x, const double y) :x(x), y(y) {}\n};\nbool operator<(const Point& lhs, const Point& rhs) {return lhs.x != rhs.x ? lhs.x < rhs.x : lhs.y < rhs.y;}\n\nint color_size;\n\nvoid dfs(vector<vector<Edge>>& edge, const int previous, const int current) {\n    for(int step = 0; step < 2 * edge[current].size(); ++step) {\n        int i = step % edge[current].size();\n        if(edge[current][i].to() != previous) continue;\n\n        i = (i + 1) % edge[current].size();\n        if(edge[current][i].color() != NIL) return;\n        edge[current][i].color(color_size);\n        dfs(edge, edge[current][i].from(), edge[current][i].to());\n        break;\n    }\n}\n\nint main() {\n    int C, W;\n    while(cin >> C >> W, C | W) {\n        vector<Point> pillar(C);\n        for(auto& p: pillar) cin >> p.x >> p.y;\n        vector<vector<Edge>> edge(C);\n        for(int i = 0; i < W; ++i) {\n            int s, t;\n            cin >> s >> t;\n            --s; --t;\n            edge[s].push_back(Edge(s, t, atan2(pillar[t].y - pillar[s].y, pillar[t].x - pillar[s].x)));\n            edge[t].push_back(Edge(t, s, atan2(pillar[s].y - pillar[t].y, pillar[s].x - pillar[t].x)));\n        }\n\n        // bubble sort\n        for(auto& e: edge) for(int i = 0; i < e.size(); ++i) for(int j = e.size() - 1; j > i; --j)\n            if(e[i].weight() > e[j].weight()) swap(e[i], e[j]);\n\n        // coloring\n        color_size = 0;\n        for(int v = 0; v < C; ++v) for(auto& e: edge[v]) {\n            if(e.color() == NIL) {\n                e.color(color_size);\n                dfs(edge, e.from(), e.to());\n                ++color_size;\n            }\n        }\n\n        // construct the dual graph\n        vector<set<int>> new_edge(color_size);\n        for(int v = 0; v < C; ++v) for(const auto& e: edge[v]) {\n            for(const auto& reverse: edge[e.to()]) {\n                if(reverse.to() != e.from()) continue;\n                new_edge[e.color()].insert(reverse.color());\n                break;\n            }\n        }\n        Graph g(color_size);\n        for(int from = 0; from < new_edge.size(); ++from) for(int to: new_edge[from])\n            g.add(from, to, 1);\n\n        // solve\n        int leftmost = 0;\n        for(int i = 1; i < C; ++i) if(pillar[i] < pillar[leftmost]) leftmost = i;\n        int outside = edge[leftmost].front().color();\n        auto list = g.Dijkstra_all(outside);\n        cout << *max_element(list.begin(), list.end()) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<utility>\n#include<map>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n\nusing namespace std;\n\nstruct Point{\n\tint x,y;\n\tint id;\n\tPoint(){}\n\tPoint(int a,int b,int c):x(a),y(b),id(c){}\n};\n\nPoint points[110];\nint pid[110];\n\nbool cmp(const Point &p1,const Point &p2)\n{\n\tif(p1.x!=p2.x) return p1.x<p2.x;\n\treturn p1.y<p2.y;\n}\n\nint center;\n\nbool cmp_angle(const int &id1,const int &id2)\n{\n\tint center=pid[::center];\n\tint id1_=pid[id1],id2_=pid[id2];\n\tint dx1=points[id1_].x-points[center].x;\n\tint dy1=points[id1_].y-points[center].y;\n\tint dx2=points[id2_].x-points[center].x;\n\tint dy2=points[id2_].y-points[center].y;\n\t//(-y,x)\n\tdouble ang1=atan2(dx1,-dy1);\n\tdouble ang2=atan2(dx2,-dy2);\n\treturn ang1<ang2;\n}\n/*\nstruct cmp_angle_{\n\tbool operator()(const int &id1,const int &id2)\n\t{\n\tint center=pid[::center];\n\tint id1_=pid[id1],id2_=pid[id2];\n\tint dx1=points[id1_].x-points[center].x;\n\tint dy1=points[id1_].y-points[center].y;\n\tint dx2=points[id2_].x-points[center].x;\n\tint dy2=points[id2_].y-points[center].y;\n\t//(-y,x)\n\tdouble ang1=atan2(dx1,-dy1);\n\tdouble ang2=atan2(dx2,-dy2);\n\treturn ang1<ang2;\n\t}\n};*/\n\nvector<int> G[110];\n\nvector<vector<int> > vs;\nvector<int> dG[550];\n//bool con[550][550];\n\ntypedef pair<int,int> P;\n\nmap<P,int> cnt;\nqueue<P> que;\n\nvoid init()\n{\n\tvs.clear();\n\tfor(int i=0;i<110;i++) G[i].clear();\n\tfor(int i=0;i<550;i++) dG[i].clear();\n\tcnt.clear();\n}\n\nvector<int> res;\nvoid stroke(int u,int v,int st)\n{\n\t//u->v\n\tP p=P(min(u,v),max(u,v));\n\tif(cnt[p]==0)\n\t{\n\t\tque.push(P(v,u));\n\t}\n\tcnt[p]++;\n\tif(v==st) return;\n\tif(u==st) res.push_back(u);\n\tres.push_back(v);\n//\tprintf(\"x%dx\\n\",v);\n\tcenter=v;\n\tint id=distance(G[v].begin(),lower_bound(G[v].begin(),G[v].end(),u,cmp_angle));\n//\tprintf(\"%d::%d %d\\n\",v,G[v].size(),id);\n\tif(id==G[v].size()-1) id=0;\n\telse id++;\n\tint nxt=G[v][id];\n\tstroke(v,nxt,st);\n}\n\nvoid getGraph()\n{\n\tint V=vs.size();\n\tfor(int i=0;i<V;i++) for(int j=i+1;j<V;j++)\n\t{\n\t\tint ni=vs[i].size(),nj=vs[j].size();\n\t\tbool flg=false;\n\t\tfor(int iid=0;iid<ni;iid++) for(int jid=0;jid<nj;jid++)\n\t\t{\n\t\t\tint niid=iid==ni-1?0:iid+1;\n\t\t\tint njid=jid==nj-1?0:jid+1;\n\t\t\tif(vs[i][iid]==vs[j][njid]&&vs[i][niid]==vs[j][jid]) flg=true;\n\t\t}\n\t\tif(flg)\n\t\t{\n\t\t\tdG[i].push_back(j);\n\t\t\tdG[j].push_back(i);\n\t\t}\n\t//\tcon[i][j]=flg;\n\t//\tcon[j][i]=flg;\n\t}\n}\n\nint getMostOutSide()\n{\n\tint u=points[0].id;\n\tint v=G[u][0];\n//\tprintf(\"----------------%d %d\\n\",u,v);\n//\tprintf(\"%d %d %d %d\\n\",points[u].x,points[u].y,points[v].x,points[v].y);\n\tfor(int i=0;i<vs.size();i++)\n\t{\n\t\tfor(int j=0;j+1<vs[i].size();j++)\n\t\t{\n\t\t\tif(vs[i][j]==u&&vs[i][j+1]==v) return i;\n\t\t}\n\t\tif(vs[i][vs[i].size()-1]==u&&vs[i][0]==v) return i;\n\t}\n//\tfor(;;);\n\treturn -1;\n}\n\nvoid check(int a)\n{\n\tif(cnt.size()!=a) for(;;);\n\tmap<P,int>::iterator it=cnt.begin();\n\tfor(;it!=cnt.end();it++)\n\t{\n\t\tint b=it->second;\n\t\tif(b!=2) for(;;);\n\t}\n}\n\nint dis[550];\nqueue<int> bfs_que;\nvoid bfs(int s)\n{\n//\tprintf(\"xxxxxxxxxxxxxxxxxxxxx\\n\");\n\twhile(!bfs_que.empty()) bfs_que.pop();\n\tbfs_que.push(s);\n\tfor(int i=0;i<550;i++) dis[i]=1<<29;\n\tdis[s]=0;\n\tbfs_que.push(s);\n\twhile(!bfs_que.empty())\n\t{\n\t\tint v=bfs_que.front();\n//\t\tprintf(\"bfs %d\\n\",v);\n\t\tbfs_que.pop();\n\t\tfor(int i=0;i<dG[v].size();i++)\n\t\t{\n\t\t\tint u=dG[v][i];\n\t\t\tint nd=dis[v]+1;\n\t\t\tif(nd>=dis[u]) continue;\n\t\t\tdis[u]=nd;\n\t\t\tbfs_que.push(u);\n\t\t}\n\t}\n}\n\nvoid outputdG()\n{\n\tprintf(\"-----dual\\n\");\n\tfor(int i=0;i<vs.size();i++)\n\t{\n\t\tprintf(\"%d-\",i);\n\t\tfor(int j=0;j<dG[i].size();j++)\n\t\t{\n\t\t\tprintf(\"%d \",dG[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}\n\nint main()\n{\n\twhile(true)\n\t{\n\t\tint C,W;\n\t\tscanf(\"%d%d\",&C,&W);\n\t\tif(C==0) break;\n\t\tinit();\n\t\tfor(int i=0;i<C;i++)\n\t\t{\n\t\t\tint x,y;\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\tpoints[i]=Point(x,y,i);\n\t\t}\n\t\tsort(points,points+C,cmp);\n\t\tfor(int i=0;i<C;i++) pid[points[i].id]=i;\n\t\tint su=-1,sv=-1;\n\t\tfor(int i=0;i<W;i++)\n\t\t{\n\t\t\tint u,v;\n\t\t\tscanf(\"%d%d\",&u,&v);\n\t\t\tu--;v--;\n\t\t\tG[u].push_back(v);\n\t\t\tG[v].push_back(u);\n\t\t\tsu=u,sv=v;\n\t\t}\n\t\tfor(int i=0;i<C;i++)\n\t\t{\n\t\t\tcenter=i;\n\t\t\tsort(G[i].begin(),G[i].end(),cmp_angle);\n//\t\t\tprintf(\"%d:::\",i);\n//\t\t\tfor(int j=0;j<G[i].size();j++) printf(\"%d \",G[i][j]);\n//\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tque.push(P(min(su,sv),max(su,sv)));\n\t\twhile(!que.empty())\n\t\t{\n\t\t\tP p=que.front();\n\t\t\tque.pop();\n\t\t\tint u=p.first,v=p.second;\n//\t\t\tprintf(\"pop %d %d\\n\",u,v);\n\t\t\tP pp=P(min(u,v),max(u,v));\n\t\t\tif(cnt[pp]==2) continue;\n\t\t//\tbool flg;\n\t\t//\tif(cnt[pp]==1) flg=false;\n\t\t//\telse flg=true;\n\t\t\tres.clear();\n\t\t\tstroke(u,v,u);\n\t\t\tvs.push_back(res);\n//\t\t\tfor(int i=0;i<res.size();i++) printf(\"%d \",res[i]);\n//\t\t\tprintf(\"aaa\\n\");\n\t\t//\tcnt[pp]++;\n\t\t//\tif(flg) que.push(P(v,u));\n\t\t}\n\t\tif(vs.size()>500) for(;;);\n//\t\tfor(int i=0;i<vs.size();i++)\n//\t\t{\n//\t\t\tvector<int> vec=vs[i];\n//\t\t\tprintf(\"a:\");\n//\t\t\tfor(int j=0;j<vec.size();j++) printf(\"%d \",vec[j]);\n//\t\t\tprintf(\"\\n\");\n//\t\t}\n\t\tgetGraph();\n\t\tcheck(W);\n\t\tint out=getMostOutSide();\n\t\tbfs(out);\n\t\tint ans=0;\n\t\tfor(int i=0;i<vs.size();i++) ans=max(ans,dis[i]);\n//\t\toutputdG();\n//\t\tprintf(\"---------%d--------------ans=%d\\n\",out,ans);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <bitset>\n#include <cmath>\n#include <algorithm>\n\n#define TIMES(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef bitset<300> Spec;\nconst double EPS = 1e-9;\nconst double PI = acos(-1);\n\ndouble normalize(double angle) {\n    if(angle < 0) return angle + 2*PI;\n    return angle;\n}\n\nint cmp(double a, double b) {\n    const double diff = a-b;\n    if(fabs(diff) < EPS) return 0;\n    return diff < 0 ? -1 : 1;\n}\n\ndouble dot(const P &a, const P &b) {\n    return a.real()*b.real() + a.imag()*b.imag();\n}\n\ndouble cross(const P &a, const P &b) {\n    return a.real()*b.imag() - a.imag()*b.real();\n}\n\nint root(int n, vector<int> &roots) {\n    if(roots[n] == n) return n;\n    return roots[n] = root(roots[n], roots);\n}\n\nbool unite(int a, int b, vector<int> &roots) {\n    const int ra = root(a, roots);\n    const int rb = root(b, roots);\n    if(ra == rb) return false;\n    roots[ra] = rb;\n    return true;\n}\n\nbool solve() {\n    int C, W;\n    cin >> C >> W;\n    if(!C && !W) return false;\n\n    vector<P> poles;\n    vector<vector<int>> graph(C);\n    vector<vector<int>> wall_id(C, vector<int>(C));\n    TIMES(_, C) {\n        double x, y;\n        cin >> x >> y;\n        poles.push_back(P(x, y));\n    }\n    TIMES(i, W) {\n        int s, t;\n        cin >> s >> t;\n        --s; --t;\n        graph[s].push_back(t);\n        graph[t].push_back(s);\n        wall_id[s][t] = i*2;\n        wall_id[t][s] = i*2+1;\n    }\n\n    vector<int> roots(W*2);\n    TIMES(i, W*2) {\n        roots[i] = i;\n    }\n    TIMES(i, C) {\n        const P &pi = poles[i];\n        for(int j : graph[i]) {\n            const P &pj = poles[j];\n            const P vec = pj - pi;\n            const double len = abs(vec);\n            int candidate = -1;\n            int sin_sgn = -2;\n            double cos_val = 2;\n            for(int k : graph[j]) {\n                if(k == i) continue;\n                const P vec2 = poles[k] - pj;\n                const int sgn = cmp(cross(vec2, vec), 0);\n                const double cv = dot(vec2, vec) / len / abs(vec2) * sgn;\n                if(sgn > sin_sgn\n                    || (sgn == sin_sgn && cmp(cv, cos_val) < 0))\n                {\n                    candidate = k;\n                    sin_sgn = sgn;\n                    cos_val = cv;\n                }\n            }\n            if(candidate != -1) {\n                if(unite(wall_id[i][j], wall_id[j][candidate], roots) && false) {\n                    cout << \"unitea \" << i << \" \" << j << \" \" << candidate << endl;\n                    TIMES(a, W*2) {\n                        cout << root(a, roots) << ' ';\n                    }\n                    cout << endl;\n                }\n            }\n        }\n    }\n    // Determine outside region\n    const int rightmost = distance(poles.begin(),\n            max_element(poles.begin(), poles.end(), [](const P &a, const P &b) {\n                return a.real() < b.real();\n                }));\n    const int rm_next = *min_element(\n            graph[rightmost].begin(), \n            graph[rightmost].end(),\n            [&poles, rightmost](int a, int b) {\n            const double arga = normalize(arg(poles[a] - poles[rightmost]));\n            const double argb = normalize(arg(poles[b] - poles[rightmost]));\n            return arga < argb;\n            });\n    int out_id = root(wall_id[rightmost][rm_next], roots);\n\n    Spec init;\n    vector<Spec> areas(W*2);\n    TIMES(i, W*2) {\n        const int area = root(i, roots);\n        areas[area][i/2] = true;\n        if(area == out_id) init[i/2] = true;\n        //cout << area << ' ';\n    }\n    /*\n    for(const Spec &s : areas) {\n        if(s.any()) cout << s << endl;\n    }\n    */\n    //cout << endl;\n    Spec cur = init;\n    //cout << init << endl;\n    int turn = 0;\n    vector<bool> used(W*2, false);\n    while(true) {\n        Spec next = cur;\n        bool changed = false;\n        TIMES(i, W*2) {\n            if(!used[i] && (areas[i] & cur).any()) {\n                next |= areas[i];\n                used[i] = true;\n                changed = true;\n            }\n        }\n        if(!changed) break;\n        cur = next;\n        ++turn;\n    }\n    cout << turn << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <ctime>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <fstream>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <numeric>\n#include <cassert>\nusing namespace std;\n\ntypedef complex<double> P;\n\nint C,W;\n\nint wsc[300] , wtc[300];\nP c[100];\nstruct NODE{\n\tint from,to,id;\n\tNODE(int from,int to,int id) : from(from) , to(to) , id(id) {}\n\tNODE(){}\n};\nvector<NODE> geo[100];\n\nconst double PI = acos(-1);\nint start;\ndouble fx(double rd){\n\twhile( rd < -1e-9 )   rd += 2*PI;\n\twhile( rd >= 2*PI - 1e-9) rd -= 2*PI;\n\treturn rd;\n}\ndouble R(P a){\n\tdouble rd = atan2(a.imag(),a.real());\n\treturn fx(rd);\n}\nint get(int x,int prev,vector<int> &ad){\n\tif( x == start ) return 1;\n\t\n\tdouble r1 = R(c[x]-c[prev]);\n\tdouble bad = 1e9;\n\tint o = -1;\n\tint id;\n\tfor(int i = 0 ; i < geo[x].size() ; i++){\n\t\tif( geo[x][i].to == prev ) continue;\n\t\tdouble r2 = R(c[geo[x][i].to]-c[x]);\n\t\tdouble rr = fx(r2-r1);\n\t\tif( PI-1e-9 <= rr && rr <= 2*PI + 1e-9 ){\n\t\t\tif( rr < bad ){\n\t\t\t\to = geo[x][i].to;\n\t\t\t\tbad = rr;\n\t\t\t\tid = geo[x][i].id;\n\t\t\t}\n\t\t}\n\t}\n\tif( o == -1 ) return 0;\n\t\n\tif( get(o,x,ad) ){\n\t\tad.push_back(id);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nint main(){\n\twhile(cin >> C >> W && C){\n\t\tfor(int i = 0 ; i < 100 ; i++) geo[i].clear();\n\t\tfor(int i = 0 ; i < C ; i++)\n\t\t\tcin >> c[i].real() >> c[i].imag();\n\t\tfor(int i = 0 ; i < W ; i++){\n\t\t\tint s,t;\n\t\t\tcin >> s >> t;\n\t\t\ts--,t--;\n\t\t\tgeo[s].push_back(NODE(s,t,i));\n\t\t\tgeo[t].push_back(NODE(t,s,i));\n\t\t\twsc[i] = s;\n\t\t\twtc[i] = t;\n\t\t\t\n\t\t}\n\t\t\n\t\tvector< vector<int> > wallset;\n\t\tfor(int _ = 0 ; _ < 2 ; _++){\n\t\t\tfor(int i = 0 ; i < W ; i++){\n\t\t\t\tstart = wsc[i];\n\t\t\t\tvector<int> a;\n\t\t\t\tif( get(wtc[i],wsc[i],a) ){\n\t\t\t\t\ta.push_back(i);\n\t\t\t\t\tsort(a.begin(),a.end());\n\t\t\t\t\twallset.push_back(a);\n\t\t\t\t}\n\t\t\t\tswap(wsc[i],wtc[i]);\n\t\t\t}\n\t\t}\n\t\tsort(wallset.begin(),wallset.end());\n\t\twallset.erase(unique(wallset.begin(),wallset.end()),wallset.end());\n\t\t\n\t\tint wf[101][101]={};\n\t\tfor(int i = 0 ; i < 101 ; i++)\n\t\t\tfor(int j = 0 ; j < 101 ; j++)\n\t\t\t\twf[i][j] = i==j?0:1e9;\n\t\tint N = wallset.size();\n\t\tvector<int> wall_share[300];\n\t\t\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\tfor(int j = 0 ; j < wallset[i].size() ; j++){\n\t\t\t\twall_share[wallset[i][j]].push_back(i);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0 ; i < W ; i++){\n\t\t\tif( wall_share[i].size() == 1 ){\n\t\t\t\twf[wall_share[i][0]][100] = wf[100][wall_share[i][0]] = 1;\n\t\t\t}else if( wall_share[i].size() == 2 ){\n\t\t\t\tfor(int j = 0 ; j <wall_share[i].size() ; j++){\n\t\t\t\t\tfor(int k = 0 ; k < wall_share[i].size() ; k++){\n\t\t\t\t\t\tif(j!=k)wf[wall_share[i][j]][wall_share[i][k]] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0 ; i < 101 ; i++){\n\t\t\tfor(int j = 0 ; j < 101 ; j++){\n\t\t\t\tfor(int k = 0 ; k < 101 ; k++){\n\t\t\t\t\twf[j][k] = min(wf[j][k],wf[j][i]+wf[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\tans = max( ans , wf[i][100] );\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <fstream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <functional>\n#include <ctime>\n#include <numeric>\n#include <unordered_set>\n#include <unordered_map>\n\nusing namespace std;\n\n#define fst first\n#define snd second\n#define all(c) ((c).begin()), ((c).end())\n#define TEST(x,a) { auto y=(x); if (sign(y-a)) { cout << \"line \" << __LINE__  << #x << \" = \" << y << \" != \" << a << endl; exit(-1); } }\n\nconst double EPS = 1e-8;\nint sign(double x) {\n  if (x < -EPS) return -1;\n  if (x > +EPS) return +1;\n  return 0;\n}\nstruct point {\n  typedef double T;\n  T x, y; \n  point &operator+=(point p) { x += p.x; y += p.y; return *this; }\n  point &operator-=(point p) { x -= p.x; y -= p.y; return *this; }\n  point &operator*=(T a)     { x *= a;   y *= a;   return *this; }\n  point &operator/=(T a)     { return *this *= (1.0/a); }\n  point operator-() const    { return {-x, -y}; }\n  bool operator<(point p) const { \n    int s = sign(x - p.x);\n    return s ? s < 0 : sign(y - p.y) < 0;\n  }\n};\nbool operator==(point p, point q) { return !(p < q) && !(q < p); }\npoint operator+(point p, point q) { return p += q; }\npoint operator-(point p, point q) { return p -= q; }\npoint operator*(point::T a, point p) { return p *= a; }\npoint operator*(point p, point::T a) { return p *= a; }\npoint operator/(point p, point::T a) { return p /= a; }\npoint::T dot(point p, point q) { return p.x*q.x+p.y*q.y; }\npoint::T cross(point p, point q) { return p.x*q.y-p.y*q.x; } // left turn > 0\npoint::T norm2(point p) { return dot(p,p); }\npoint orth(point p) { return {-p.y, p.x}; }\npoint::T norm(point p) { return sqrt(dot(p,p)); }\npoint::T arg(point p) { return atan2(p.y, p.x); }\n\nstruct line { point p, q; };\nbool operator==(line l, line m) {\n  return !sign(cross(l.p-l.q,m.p-m.q)) && !sign(cross(l.p-l.q,m.p-l.p));\n}\n\nstruct segment { point p, q; };\nbool operator==(segment l, line m) {\n  return (l.p==m.p && l.q==m.q) || (l.p==m.q && l.q==m.p); // do not consider the direction\n}\nstruct circle { point p; point::T r; };\nbool operator==(circle c, circle d) { return c.p == d.p && !sign(c.r - d.r); }\n\ntypedef vector<point> polygon;\n\nstruct polar_angle {\n  const point o;\n  const int s; // +1 for ccw, -1 for cw\n  polar_angle(point p = {0,0}, int s = +1) : o(p), s(s) { }\n  int quad(point p) const {\n    for (int i = 1; i <= 4; ++i, swap(p.x = -p.x, p.y))\n      if (p.x > 0 && p.y >= 0) return i;\n    return 0;\n  }\n  bool operator()(point p, point q) const {\n    p = p - o; q = q - o;\n    if (quad(p) != quad(q)) return s*quad(p) < s*quad(q);\n    if (cross(p, q)) return s*cross(p, q) > 0;\n    return norm2(p) < norm2(q); // closer first\n  }\n};\n\nvector<point> intersect(segment s, segment t) {\n  auto a = cross(s.q - s.p, t.q - t.p);\n  auto b = cross(t.p - s.p, t.q - t.p); \n  auto c = cross(s.q - s.p, s.p - t.p);\n  if (a < 0) { a = -a; b = -b; c = -c; }\n  if (sign(b) < 0 || sign(a-b) < 0 ||\n      sign(c) < 0 || sign(a-c) < 0) return {};      // disjoint\n  if (sign(a) != 0) return {s.p + b/a*(s.q - s.p)}; // properly crossing\n  vector<point> ps;                                 // same line\n  auto insert_if_possible = [&](point p) {\n    for (auto q: ps) if (sign(dot(p-q, p-q)) == 0) return;\n    ps.push_back(p);\n  };\n  if (sign(dot(s.p-t.p, s.q-t.p)) <= 0) insert_if_possible(t.p);\n  if (sign(dot(s.p-t.q, s.q-t.q)) <= 0) insert_if_possible(t.q);\n  if (sign(dot(t.p-s.p, t.q-s.p)) <= 0) insert_if_possible(s.p);\n  if (sign(dot(t.p-s.q, t.q-s.q)) <= 0) insert_if_possible(s.q);\n  return ps;\n}\n\nstruct arrangement {\n  struct edge {\n    int src, dst;\n    point::T weight;\n    size_t id, rev;\n  };\n  int n;\n  vector<point> ps; // ps[id[p]] = p, id[ps[k]] = k\n  map<point,int> id; \n  vector<vector<edge>> adj;\n\n  arrangement(vector<segment> ss) : n(0) {\n    vector<vector<pair<point::T, int>>> group(ss.size());\n    auto append = [&](int i, point p) {\n      if (!id.count(p)) { id[p] = n++; ps.push_back(p); }\n      group[i].push_back({norm(ss[i].p - p), id[p]});\n    };\n    for (int i = 0; i < ss.size(); ++i) {\n      append(i, ss[i].p); append(i, ss[i].q);\n      for (int j = 0; j < i; ++j) {\n        for (point p: intersect(ss[i], ss[j])) {\n          append(i, p); append(j, p);\n        }\n      }\n    }\n    adj.resize(n);\n    for (auto &vs: group) {\n      sort(all(vs));\n      for (int i = 0; i+1 < vs.size(); ++i) {\n        auto u = vs[i].snd, v = vs[i+1].snd;\n        if (u == v) continue;\n        auto len = vs[i+1].fst - vs[i].fst;\n        adj[u].push_back({u, v, len});\n        adj[v].push_back({v, u, len});\n      }\n    }\n    // remove duplicates and orient edges\n    vector<unordered_map<int, int>> idx(n);\n    for (int u = 0; u < n; ++u) {\n      auto eq = [&](edge e, edge f) { return e.dst == f.dst; };\n      auto lt = [&](edge e, edge f) { return e.dst <  f.dst; };\n      sort(all(adj[u]), lt);\n      adj[u].erase(unique(all(adj[u]), eq), adj[u].end());\n      sort(all(adj[u]), [&](edge e, edge f) {\n        return arg(ps[e.dst] - ps[e.src]) > arg(ps[f.dst] - ps[f.src]);\n      });\n      for (int i = 0; i < adj[u].size(); ++i) {\n        adj[u][i].id = i;\n        int v = adj[u][i].dst;\n        idx[u][v] = i;\n        if (idx[v].count(u)) {\n          int j = idx[v][u];\n          adj[u][i].rev = j;\n          adj[v][j].rev = i;\n        }\n      }\n    }\n  }\n  edge twin(edge e) const { return adj[e.dst][e.rev]; }\n  edge next(edge e) const {\n    int j = adj[e.dst][e.rev].id + 1;\n    if (j >= adj[e.dst].size()) j = 0;\n    return adj[e.dst][j];\n  }\n};\n\nint main() {\n  for (int c, w; ~scanf(\"%d %d\", &c, &w) && c; ) {\n    vector<point> ps(c);\n    for (int i = 0; i < c; ++i) {\n      scanf(\"%lf %lf\", &ps[i].x, &ps[i].y);\n    }\n    vector<segment> ss;\n    for (int i = 0; i < w; ++i) {\n      int u, v; scanf(\"%d %d\", &u, &v);\n      ss.push_back({ps[u-1], ps[v-1]});\n    }\n    arrangement arr(ss);\n\n    int s = 0;\n    for (int i = 1; i < arr.n; ++i) \n      if (arr.ps[s] < arr.ps[i]) s = i;\n    typedef arrangement::edge edge;\n    edge e = arr.adj[s][0]; // outer-face edge\n\n    vector<unordered_map<int,int>> step(arr.n);\n    queue<edge> que;\n    auto proceed = [&](edge s, int value) {\n      if (step[s.src].count(s.dst)) return;\n      edge e = s;\n      do {\n        step[e.src][e.dst] = value;\n        que.push(arr.twin(e));\n        e = arr.next(e);\n      } while (e.src != s.src || e.dst != s.dst);\n    };\n    proceed(e, 0);\n    int ans = 0;\n    while (!que.empty()) {\n      edge e = que.front(); que.pop();\n      ans = step[e.dst][e.src];\n      proceed(e, ans + 1);\n    }\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<int,pair<bool,double> > P2;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define min_3(a,b,c) min(a,min(b,c))\n#define max_3(a,b,c) max(a,max(b,c))\n#define mp1(a,b,c) P1(a,P(b,c))\n#define mp2(a,b,c) P2(a,pair<bool,double>(b,c))\n#define pque(a) priority_queue<a>\n#define rpque(a) priority_queue<a,vector<a>,greater<a>>\n\nconst int INF=1000000000;\nconst int dre_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dre_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\nconst int kaijou[10]={1,1,2,6,24,120,720,5040,40320,362880};\n\nbool com(P2 x,P2 y){\n\tif(x.sc.fr!=y.sc.fr)return x.sc.fr;\n\treturn x.sc.sc>=y.sc.sc;\n}\n\nint main(){\n\twhile(1){\n\t\tint c,w;\n\t\tint x[110],y[110];\n\t\tint s,t;\n\t\t\n\t\tscanf(\"%d%d\",&c,&w); if(c==0&&w==0)break;\n\t\trep1(i,c)scanf(\"%d%d\",&x[i],&y[i]);\n\t\t\n\t\tvector<P1> V_;\n\t\trep1(i,c){\n\t\t\tV_.pb(mp1(x[i],y[i],i));\n\t\t}\n\t\tsor(V_);\n\t\tvector<P2> vec_[110];\n\t\trep1(i,c){\n\t\t\tvec_[i].pb(mp2(0,false,-INF));\n\t\t\trep1(j,c){\n\t\t\t\tif(i==j)continue;\n\t\t\t\tif(x[i]<x[j]){\n\t\t\t\t\tvec_[i].pb(mp2(j,true,(double)(y[j]-y[i])/(x[j]-x[i])));\n\t\t\t\t}\n\t\t\t\telse if(x[i]>x[j]){\n\t\t\t\t\tvec_[i].pb(mp2(j,false,(double)(y[j]-y[i])/(x[j]-x[i])));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(y[j]>y[i])vec_[i].pb(mp2(j,true,(double)INF));\n\t\t\t\t\telse vec_[i].pb(mp2(j,true,(double)-INF));\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(vec_[i].begin(),vec_[i].end(),com);\n\t\t}\n\t\t\n\t\tint v,e;\n\t\tvector<int> V;\n\t\tbool edge[110][110];\n\t\tvector<int> vec[110];\n\t\t\n\t\tv=c; e=w;\n\t\trep(i,c)V.pb(V_[i].sc.sc);\n\t\trep(i,110)rep(j,110)edge[i][j]=false;\n\t\trep(i,e){\n\t\t\tscanf(\"%d%d\",&s,&t);\n\t\t\tedge[s][t]=true;\n\t\t\tedge[t][s]=true;\n\t\t}\n\t\trep1(i,c){\n\t\t\trep(j,vec_[i].size()){\n\t\t\t\tvec[i].pb(vec_[i][j].fr);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ret=0;\n\t\twhile(e>0){\n\t\t\tret++;\n\t\t\t\n\t\t\tint a=-1;\n\t\t\trep(i,V.size()){\n\t\t\t\trep(j,105){\n\t\t\t\t\tif(edge[V[i]][j]){a=V[i]; break;}\n\t\t\t\t}\n\t\t\t\tif(a!=-1)break;\n\t\t\t}\n\t\t\t\n\t\t\tint b=0,c=a;\n\t\t\twhile(1){\n\t\t\t\tif(c==-1||vec[c].size()==0)break;\n\t\t\t\trep(i,vec[c].size()){\n\t\t\t\t\tif(vec[c][i]==b){\n\t\t\t\t\t\ti++; i%=vec[c].size();\n\t\t\t\t\t\twhile(!edge[c][vec[c][i]]){\n\t\t\t\t\t\t\ti++; i%=vec[c].size();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tedge[c][vec[c][i]]=false;\n\t\t\t\t\t\tedge[vec[c][i]][c]=false;\n\t\t\t\t\t\te--;\n\t\t\t\t\t\tb=c;\n\t\t\t\t\t\tc=vec[c][i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(c==a)break;\n\t\t\t}\n\t\t\t\n\t\t\tbool updata=true;\n\t\t\twhile(updata){\n\t\t\t\tupdata=false;\n\t\t\t\trep(i,105){\n\t\t\t\t\tint cnt=0;\n\t\t\t\t\tint t=105;\n\t\t\t\t\trep(j,105){\n\t\t\t\t\t\tif(edge[i][j]){cnt++; t=j;}\n\t\t\t\t\t}\n\t\t\t\t\tif(cnt==1){\n\t\t\t\t\t\tupdata=true;\n\t\t\t\t\t\tedge[i][t]=false;\n\t\t\t\t\t\tedge[t][i]=false;\n\t\t\t\t\t\te--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<complex>\n#include<deque>\n#include<vector>\nusing namespace std;\ndouble eps=1e-6;\ndouble x[110];\ndouble y[110];\ndouble px[700];\ndouble py[700];\nint ijk[700];\nint v[700];\nint g[700][700];\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ndouble PI=3.14159265358;\ntypedef complex<double> P;\ntypedef vector<P> G;\n\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n#define se second\n#define fi first\n\nbool intersectSS(const pair<P,P> &s, const pair<P,P> &t) {\n  return ccw(s.fi,s.se,t.fi)*ccw(s.fi,s.se,t.se) <= 0 &&\n         ccw(t.fi,t.se,s.fi)*ccw(t.fi,t.se,s.se) <= 0;\n}\n\nP pt[700];\nP ps[300];\nint s[400];\nint t[400];\ndouble left[400];\ndouble right[400];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<a;i++)scanf(\"%lf%lf\",x+i,y+i);\n\t\tfor(int i=0;i<a;i++){\n\t\t\tdouble X=cos(1)*x[i]-sin(1)*y[i];\n\t\t\tdouble Y=sin(1)*x[i]+cos(1)*y[i];\n\t\t\tx[i]=X;\n\t\t\ty[i]=Y;\n\t\t\tps[i]=P(x[i],y[i]);\n\t\t}\n\t\tfor(int i=0;i<b;i++){\n\t\t\tint p,q;scanf(\"%d%d\",&p,&q);\n\t\t\tp--;q--;\n\t\t\ts[i]=p;t[i]=q;\n\t\t\tpx[i*2]=(x[p]+x[q])/2+eps;\n\t\t\tpy[i*2]=(y[p]+y[q])/2;\n\t\t\tpx[i*2+1]=(x[p]+x[q])/2-eps;\n\t\t\tpy[i*2+1]=(y[p]+y[q])/2;\n\t\t\tpt[i*2]=P(px[i*2],py[i*2]);\n\t\t\tpt[i*2+1]=P(px[i*2+1],py[i*2+1]);\n\t\t}\n\t\tdeque<pair<int,int> >Q;\n\t\t\n\t\tfor(int i=0;i<b*2;i++){\n\t\t\tijk[i]=999999999;\n\t\t\tv[i]=0;\n\t\t\tbool OK=true;\n\t\t\tint tt=s[i/2];\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tif(tt==s[j]||tt==t[j])continue;\n\t\t\t\tif(intersectSS(make_pair(ps[tt],ps[tt]+(pt[i]-ps[tt])*10000.0),make_pair(ps[s[j]],ps[t[j]]))){\n\t\t\t\t\tOK=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttt=t[i/2];\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tif(tt==s[j]||tt==t[j])continue;\n\t\t\t\tif(intersectSS(make_pair(ps[tt],ps[tt]+(pt[i]-ps[tt])*10000.0),make_pair(ps[s[j]],ps[t[j]]))){\n\t\t\t\t\tOK=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(OK){\n\t\t//\t\tprintf(\" %d\\n\",i);\n\t\t\t\tijk[i]=0;\n\t\t\t\tQ.push_back(make_pair(0,i));\n\t\t\t}\n\t\t\tfor(int j=i+1;j<b*2;j++){\n\t\t\t\tint cnt=0;\n\t\t\t\tfor(int k=0;k<b;k++){\n\t\t\t\t\tif(intersectSS(make_pair(ps[s[k]],ps[t[k]]),make_pair(pt[i],pt[j]))){\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tif(cnt>1)break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(cnt<2)g[i][j]=g[j][i]=cnt;\n\t\t\t\telse g[i][j]=g[j][i]=999999999;\n\t\t\t}\n\t\t}\n\t\n\t\twhile(Q.size()){\n\t\t\tint cost=-Q.front().first;\n\t\t\tint at=Q.front().second;Q.pop_front();\n\t\t\tif(v[at])continue;\n\t\t\tv[at]=1;\n\t\t\tfor(int i=0;i<b*2;i++){\n\t\t\t\tif(!v[i]&&ijk[i]>cost+g[at][i]){\n\t\t\t\t\tijk[i]=cost+g[at][i];\n\t\t\t\t\tif(g[at][i]==1)Q.push_back(make_pair(-ijk[i],i));\n\t\t\t\t\telse Q.push_front(make_pair(-ijk[i],i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret=0;\n\t\tfor(int i=0;i<b*2;i++)ret=max(ret,ijk[i]);\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\n \nconst double INF = 1e12;\ntypedef complex<double> P,point;\ntypedef vector<P> G,polygon;\nnamespace std {bool operator < (const P& a, const P& b) {return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);} }\ndouble cross(const P& a, const P& b) {return imag(conj(a)*b);}\ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\n\nint main(){\n\tint C,W;\n\twhile(cin >> C >> W && C){\n\t\tvector<P> p(C);\n\t\tfor(int i = 0 ; i < C ; i++) cin >> p[i].real() >> p[i].imag();\n\t\tmap< P,vector<P> > g;\n\t\tvector< pair<P,P> > e;\n\t\tfor(int i = 0 ; i < W ; i++){\n\t\t\tint a,b;\n\t\t\tcin >> a >> b;\n\t\t\ta--,b--;\n\t\t\tg[p[a]].push_back(p[b]);\n\t\t\tg[p[b]].push_back(p[a]);\n\t\t\te.push_back(make_pair(p[a],p[b]));\n\t\t\te.push_back(make_pair(p[b],p[a]));\n\t\t}\n\t\tvector< vector<P> > wall;\n\t\tset< vector<P> > already;\n\t\t\n\t\tfor(int j = 0 ; j < e.size() ; j++){\n\t\t\tP A = e[j].first;\n\t\t\tP B = e[j].second;\n\t\t\tvector<P> chain;\n\t\t\tchain.push_back(A);\n\t\t\tint fail = 0;\n\t\t\tdo{\n\t\t\t\tchain.push_back(B);\n\t\t\t\tvector< pair<double,P> > pos;\n\t\t\t\tfor(int i = 0 ; i < g[B].size() ; i++){\n\t\t\t\t\tif( g[B][i] != A && cross(B-A,g[B][i]-A) > -EPS ){\n\t\t\t\t\t\tP s = A-B;\n\t\t\t\t\t\tP t = g[B][i]-B;\n\t\t\t\t\t\tdouble tmp = acos(dot(s,t) / abs(s) / abs(t));\n\t\t\t\t\t\tpos.push_back(make_pair(tmp,g[B][i]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsort(pos.begin(),pos.end());\n\t\t\t\tif( pos.size() == 0 ){ fail = 1; break; }\n\t\t\t\tA = pos[0].second;\n\t\t\t\tswap(A,B);\n\t\t\t}while( B != e[j].first );\n\t\t\tif( fail ) continue;\n\t\t\tvector<P> key = chain;\n\t\t\tsort(key.begin(),key.end());\n\t\t\tif( !already.count(key) ){\n\t\t\t\twall.push_back(chain);\n\t\t\t\talready.insert(key);\n\t\t\t\t//for(int i = 0 ; i < chain.size() ; i++) cout << chain[i] << \" \"; cout << endl;\n\t\t\t}\n\t\t}\n\t\tvector< vector<int> > wf(wall.size()+1,vector<int>(wall.size()+1));\n\t\tfor(int i = 0 ; i < wf.size() ; i++)\n\t\t\tfor(int j = 0 ; j < wf.size() ; j++)\n\t\t\t\twf[i][j] = i != j ? 1e9 : 0;\n\t\tset< pair<P,P> > usedEdge;\n\t\tfor(int i = 0 ; i < wall.size() ; i++){\n\t\t\tfor(int j = 0 ; j < wall.size() ; j++){\n\t\t\t\tif( i != j ) {\n\t\t\t\t\tset< pair<P,P> > tmp;\n\t\t\t\t\tfor(int k = 0 ; k < wall[i].size() ; k++){\n\t\t\t\t\t\tP a = wall[i][k] , b = wall[i][(k+1)%wall[i].size()];\n\t\t\t\t\t\tif( b < a ) swap(a,b);\n\t\t\t\t\t\ttmp.insert(make_pair(a,b));\n\t\t\t\t\t}\n\t\t\t\t\tint connect = 0;\n\t\t\t\t\tfor(int k = 0 ; k < wall[j].size() ; k++){\n\t\t\t\t\t\tP a = wall[j][k] , b = wall[j][(k+1)%wall[j].size()];\n\t\t\t\t\t\tif( b < a ) swap(a,b);\n\t\t\t\t\t\tif( tmp.count( make_pair(a,b) ) ){\n\t\t\t\t\t\t\tconnect = 1;\n\t\t\t\t\t\t\tusedEdge.insert(make_pair(a,b));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif( connect ) wf[i][j] = wf[j][i] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0 ; i < wall.size() ; i++){\n\t\t\tint connectOutside = 0;\n\t\t\tfor(int k = 0 ; k < wall[i].size() ; k++){\n\t\t\t\tP a = wall[i][k] , b = wall[i][(k+1)%wall[i].size()];\n\t\t\t\tif( b < a ) swap(a,b);\n\t\t\t\tif( !usedEdge.count( make_pair(a,b) ) ) connectOutside = 1;\n\t\t\t}\n\t\t\tif(connectOutside)wf[wall.size()][i] = wf[i][wall.size()] = 1;\n\t\t}\n\t\tfor(int i = 0 ; i < wf.size() ; i++)\n\t\t\tfor(int j = 0 ; j < wf.size() ; j++)\n\t\t\t\tfor(int k = 0 ; k < wf.size() ; k++)\n\t\t\t\t\twf[j][k] = min(wf[j][k],wf[j][i]+wf[i][k]);\n\t\tint res = -1e9;\n\t\tfor(int i = 0 ; i < wall.size() ; i++)\n\t\t\tres = max(res,wf[wall.size()][i]);\n\t\tcout << res << endl;\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<complex>\n#include<deque>\n#include<vector>\nusing namespace std;\ndouble eps=1e-6;\ndouble x[110];\ndouble y[110];\ndouble px[700];\ndouble py[700];\nint ijk[700];\nint v[700];\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ndouble PI=3.14159265358;\nstruct P{\n\tdouble x;double y;\n\tP(){}\n\tP(double X,double Y){\n\t\tx=X;y=Y;\n\t}\n\tP operator+ (const P &a)const{\n\t\treturn P(x+a.x,y+a.y);\n\t}\n\tP operator- (const P &a)const{\n\t\treturn P(x-a.x,y-a.y);\n\t}\n\tP operator* (const double &a)const{\n\t\treturn P(x*a,y*a);\n\t}\n\t/*operator+ (P a){\n\t\treturn P(x+a.x,y+a.y);\n\t}\n\toperator+ (P a){\n\t\treturn P(x+a.x,y+a.y);\n\t}*/\n\t\n};\nbool operator < (const P& a, const P& b) {\n    return a.x<b.x||(a.x==b.x&&a.y<b.y);\n}\ndouble cross(const P& a, const P& b) {\n\treturn a.x*b.y-a.y*b.x;\n}\ndouble dot(const P& a, const P& b) {\n\treturn a.x*b.x+a.y*b.y;\n}\n\nint ccw(P a, P b, P c) {\n\tb=b-a;c=c-a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (b.x*b.x+b.y*b.y<c.x*c.x+c.y*c.y) return -2;       // a--b--c on line\n  return 0;\n}\n#define se second\n#define fi first\n\nbool intersectSS(const pair<P,P> &s, const pair<P,P> &t) {\n  return ccw(s.fi,s.se,t.fi)*ccw(s.fi,s.se,t.se) <= 0 &&\n         ccw(t.fi,t.se,s.fi)*ccw(t.fi,t.se,s.se) <= 0;\n}\n\nP pt[700];\nP ps[300];\nint s[400];\nint t[400];\ndouble left[400];\ndouble right[400];\nvector<pair<int,int> >g[700];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<700;i++)g[i].clear();\n\t\tfor(int i=0;i<a;i++)scanf(\"%lf%lf\",x+i,y+i);\n\t\tfor(int i=0;i<a;i++){\n\t\t\tdouble X=cos(1)*x[i]-sin(1)*y[i];\n\t\t\tdouble Y=sin(1)*x[i]+cos(1)*y[i];\n\t\t\tx[i]=X;\n\t\t\ty[i]=Y;\n\t\t\tps[i]=P(x[i],y[i]);\n\t\t}\n\t\tfor(int i=0;i<b;i++){\n\t\t\tint p,q;scanf(\"%d%d\",&p,&q);\n\t\t\tp--;q--;\n\t\t\ts[i]=p;t[i]=q;\n\t\t\tpx[i*2]=(x[p]+x[q])/2+eps;\n\t\t\tpy[i*2]=(y[p]+y[q])/2;\n\t\t\tpx[i*2+1]=(x[p]+x[q])/2-eps;\n\t\t\tpy[i*2+1]=(y[p]+y[q])/2;\n\t\t\tpt[i*2]=P(px[i*2],py[i*2]);\n\t\t\tpt[i*2+1]=P(px[i*2+1],py[i*2+1]);\n\t\t}\n\t\tdeque<pair<int,int> >Q;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tvector<pair<double,pair<int,int> > >vec;\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tif(s[j]==i){\n\t\t\t\t\tvec.push_back(make_pair(atan2(y[t[j]]-y[i],x[t[j]]-x[i]),make_pair(j,t[j])));\n\t\t\t\t}\n\t\t\t\tif(t[j]==i){\n\t\t\t\t\tvec.push_back(make_pair(atan2(y[s[j]]-y[i],x[s[j]]-x[i]),make_pair(j,s[j])));\n\t\t\t\t}\n\t\t\t}\n\t\t\tstd::sort(vec.begin(),vec.end());\n\t\t\tint sz=vec.size();\n\t\t\tfor(int j=0;j<vec.size();j++){\n\t\t\t\tdouble th=vec[j].first;\n\t\t\t\tdouble th2=vec[(j+1)%sz].first;\n\t\t\t\tif(th>th2)th2+=2*PI;\n\t\t\t\tif(th2-th<=PI+EPS)continue;\n\t\t\t\tfor(int k=0;k<2;k++)for(int l=0;l<2;l++){\n\t\t\t\t\tif(intersectSS(make_pair(pt[vec[j].second.first*2+k],pt[vec[(j+1)%sz].second.first*2+l]),\n\t\t\t\t\tmake_pair(ps[i],ps[vec[j].second.second]))&&intersectSS(make_pair(pt[vec[j].second.first*2+k],pt[vec[(j+1)%sz].second.first*2+l]),\n\t\t\t\t\tmake_pair(ps[i],ps[vec[(j+1)%sz].second.second]))){\n\t\t\t\t\t\tg[vec[j].second.first*2+k].push_back(make_pair(vec[(j+1)%sz].second.first*2+l,0));\n\t\t\t\t\t\tg[vec[(j+1)%sz].second.first*2+l].push_back(make_pair(vec[j].second.first*2+k,0));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<b*2;i++){\n\t\t\tijk[i]=999999999;\n\t\t\tv[i]=0;\n\t\t\tbool OK=true;\n\t\t\tint tt=s[i/2];\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tif(tt==s[j]||tt==t[j])continue;\n\t\t\t\tif(intersectSS(make_pair(ps[tt],ps[tt]+(pt[i]-ps[tt])*10000.0),make_pair(ps[s[j]],ps[t[j]]))){\n\t\t\t\t\tOK=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttt=t[i/2];\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tif(tt==s[j]||tt==t[j])continue;\n\t\t\t\tif(intersectSS(make_pair(ps[tt],ps[tt]+(pt[i]-ps[tt])*10000.0),make_pair(ps[s[j]],ps[t[j]]))){\n\t\t\t\t\tOK=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(OK){\n\t\t\t\tijk[i]=0;\n\t\t\t\tQ.push_back(make_pair(0,i));\n\t\t\t}\n\t\t\tfor(int j=i+1;j<b*2;j++){\n\t\t\t\tint cnt=0;\n\t\t\t\tfor(int k=0;k<b;k++){\n\t\t\t\t\tif(intersectSS(make_pair(ps[s[k]],ps[t[k]]),make_pair(pt[i],pt[j]))){\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tif(cnt>1)break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(cnt<2){\n\t\t\t\t\tg[i].push_back(make_pair(j,cnt));\n\t\t\t\t\tg[j].push_back(make_pair(i,cnt));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(Q.size()){\n\t\t\tint cost=-Q.front().first;\n\t\t\tint at=Q.front().second;Q.pop_front();\n\t\t\tif(v[at])continue;\n\t\t\tv[at]=1;\n\t\t\tfor(int i=0;i<g[at].size();i++){\n\t\t\t\tif(!v[g[at][i].first]&&ijk[g[at][i].first]>cost+g[at][i].second){\n\t\t\t\t\tijk[g[at][i].first]=cost+g[at][i].second;\n\t\t\t\t\tif(g[at][i].second==1)Q.push_back(make_pair(-ijk[g[at][i].first],g[at][i].first));\n\t\t\t\t\telse Q.push_front(make_pair(-ijk[g[at][i].first],g[at][i].first));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret=0;\n\t\tfor(int i=0;i<b*2;i++)ret=max(ret,ijk[i]);\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cassert>\nusing namespace std;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n\treturn abs(a.real()-b.real()) > EPS ? real(a) < real(b) : imag(a) + EPS < imag(b);\n    //return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\nP readPoint(){\n\tdouble x,y;\n\tcin >> x >> y;\n\treturn P(x,y);\n}\n\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\ntypedef vector<P> G;\n\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\n\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\nP reflection(const L &l, const P &p) {\n  return p + 2. * (projection(l, p) - p);\n}\ndouble distanceLP(const L &l, const P &p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\n#define rep(i,N) for(int i = 0 ; i < N ; i++)\nP ps[110];\nvector<int> g[110];\n\nvector<int> normalize(vector<int> v){\n\tauto it = min_element(v.begin(),v.end());\n\trotate(v.begin(),it,v.end());\n\treturn v;\n}\n\nint done[110];\nvoid f(int a,int b,int s,vector<int> &v){\n\tv.push_back(b);\n\tif( b == s ) return;\n\tif( done[b]++ ) throw 0;\n\tsort(g[b].begin(),g[b].end(),[&](int x,int y){\n\t\tP A = ps[x] - ps[b];\n\t\tP B = ps[y] - ps[b];\n\t\treturn cross(A,B) > 0;\n\t});\n\t//cout << find(g[b].begin(),g[b].end(),a) -g[b].begin();\n\t//cout << \"[\" << a << \",\" << s << \"] \";\n\t//for(int i = 0 ; i < g[b].size() ; i++)\n\t//\tcout << g[b][i] << \" \";\n\t//cout << endl;\n\trotate(g[b].begin(),find(g[b].begin(),g[b].end(),a),g[b].end());\n\tf(b,g[b][1],s,v);\n}\n\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n\ndouble area2(const G& P) {\n  double A = 0;\n  for (int i = 0; i < P.size(); ++i) \n    A += cross(curr(P, i), next(P, i));\n  return A;\n}\n\nint main(){\n\t\n\tint C,W;\n\twhile( cin >> C >> W && (C||W) ){\n\t\trep(i,C) ps[i] = readPoint();\n\t\trep(i,C) g[i].clear();\n\t\trep(i,W){\n\t\t\tint a,b;\n\t\t\tcin >> a >> b;\n\t\t\t--a,--b;\n\t\t\tg[a].push_back(b);\n\t\t\tg[b].push_back(a);\n\t\t}\n\t\tvector< vector<int> > poly;\n\t\trep(i,C){\n\t\t\trep(j,g[i].size()){\n\t\t\t\ttry{\n\t\t\t\t\tmemset(done,0,sizeof(done));\n\t\t\t\t\tvector<int> v;\n\t\t\t\t\tf(i,g[i][j],i,v);\n\t\t\t\t\tvector<P> g;\n\t\t\t\t\trep(k,v.size())g.push_back(ps[v[k]]);\n\t\t\t\t\tif( area2(g) > 0 ) throw 0;\n\t\t\t\t\tpoly.push_back(normalize(v));\n\t\t\t\t}catch(int x){\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(poly.begin(),poly.end());\n\t\tpoly.erase(unique(poly.begin(),poly.end()),poly.end());\n\t\t\n\t\tmap< pair<int,int>, vector<int> > edgs;\n\t\tfor(int i = 0 ; i < poly.size() ; i++){\n\t\t\tfor(int j = 0 ; j < poly[i].size() ; j++){\n\t\t\t\tint A = curr(poly[i],j);\n\t\t\t\tint B = next(poly[i],j);\n\t\t\t\tif( A > B ) swap(A,B);\n\t\t\t\tedgs[{A,B}].push_back(i);\n\t\t\t}\n\t\t}\n\t\tint M = poly.size() + 1;\n\t\tint wf[M][M];\n\t\trep(i,M) rep(j,M){\n\t\t\twf[i][j] = i==j?0:1e9;\n\t\t}\n\t\t\n\t\tfor( auto x : edgs ){\n\t\t\tvector<int> v = x.second;\n\t\t\tif( v.size() < 2 ) v.push_back(M-1);\n\t\t\twf[v[0]][v[1]] = wf[v[1]][v[0]] = 1;\n\t\t}\n\t\trep(i,M)rep(j,M)rep(k,M) wf[j][k] = min(wf[j][i]+wf[i][k],wf[j][k]);\n\t\tint ans = 0;\n\t\trep(i,M){\n\t\t\tans = max(ans,wf[i][M-1]);\n\t\t}\n\t\tcout << ans << endl;\n\t\t\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n\n/* ??????????????¬ */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\n\nconst ld pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// ????????\\???\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// ????????????????????????\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// ??????\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// ??????\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn Point();\n\t\t}\n\t}\n};\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(nb, nc) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(nb, nc) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n\n\n/* ???????????? */\n\n// ??´?????¨??´??????????????????\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// ????????´????????????\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// ?????????????????????\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// ??????????¶?\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// ??´?????¨??´????????????\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n// ??´?????¨??´????????????\nvector<Point> is_ll2(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tif (cross(sv, tv) != 0)return vector<Point>(1, is_ll(s, t));\n\telse {\n\t\tvector<Point>ans;\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tif (isis_sp(s, t[k]) && find(ans.begin(), ans.end(), t[k]) == ans.end())ans.push_back(t[k]);\n\t\t\tif (isis_sp(t, s[k]) && find(ans.begin(), ans.end(), s[k]) == ans.end())ans.push_back(s[k]);\n\t\t}\n\t\treturn ans;\n\t}\n}\n// ????????¨???????????????\n//???????????£????????¨???????????¨assert(false)\nPoint is_ss(const Line &s, const Line& t) {\n\tif (isis_ss(s, t)) {\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\tif (s[k] == t[l])return s[k];\n\t\t\t}\n\t\t}\n\t\treturn is_ll(s, t);\n\t}\n\telse {\n\t\t//??????isis_ss?????????\n\t\tassert(false);\n\t\treturn Point(0, 0);\n\t}\n}\n// ????????¨???????????????\nvector<Point> is_ss2(const Line &s, const Line& t) {\n\tvector<Point> kouho(is_ll2(s, t));\n\tvector<Point>ans;\n\tfor (auto p : kouho) {\n\t\tif (isis_sp(s, p) && isis_sp(t, p))ans.emplace_back(p);\n\t}\n\treturn ans;\n}\n// ??´?????¨???????????¢\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// ??´?????¨??´???????????¢\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//??´?????¨??´?????????????????????????????????\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0])<eps) ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0])<eps) ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nPoint  inner_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i <static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vertics[0];\n\tLine bi1(bisection(Line(vertics[0], vertics[1]), Line(vertics[0], vertics[2])));\n\tLine bi2(bisection(Line(vertics[1], vertics[2]), Line(vertics[1], vertics[0])));\n\tif (bi1[0] == bi2[0])return bi1[0];\n\telse {\n\t\treturn is_ll(bi1, bi2);\n\t}\n}\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nvector<Point>  ex_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (abs(vertics[0] - vertics[1])<eps || abs(vertics[1] - vertics[2])<eps || (abs(vertics[2] - vertics[0])<eps))return vector<Point>();\n\tvector<Point>ecs;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tLine bi1(bisection(Line(vertics[i], vertics[i] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[i], vertics[(i + 1) % 3])));\n\t\tLine bi2(bisection(Line(vertics[(i + 1) % 3], vertics[(i + 1) % 3] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[(i + 1) % 3], vertics[i])));\n\t\tecs.push_back(is_ll(bi1, bi2));\n\t}\n\treturn ecs;\n}\n\n\n//a,b:??????\n//c:????????§??????\n//???????????´?????????????????¢?????????????±??????????\nvector<Point>  same_dis(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tvertics.push_back(is_ll(ls[0], ls[2]));\n\tvertics.push_back(is_ll(ls[1], ls[2]));\n\n\tif (abs(vertics[0] - vertics[1]) < eps)return vector<Point>{vertics[0]};\n\tLine bis(bisection(ls[0], ls[1]));\n\tvector<Point>ecs;\n\n\tLine abi(bisection(Line(vertics[0], vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, abi));\n\n\n\tLine bbi(bisection(Line(vertics[0], 2.l*vertics[0] - vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, bbi));\n\n\treturn ecs;\n}\n/* ??? */\n\n// ?????¨????????????\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n//???????????????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_circle(const Circle &cir, const  Point& p) {\n\tld dis = abs(cir.p - p);\n\tif (dis > cir.r + eps)return 0;\n\telse if (dis < cir.r - eps)return 2;\n\telse return 1;\n}\n//???lc??????rc??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint circle_in_circle(const Circle &lc, const  Circle&rc) {\n\tld dis = abs(lc.p - rc.p);\n\tif (dis < rc.r - lc.r - eps)return 2;\n\telse if (dis>rc.r - lc.r + eps)return 0;\n\telse return 1;\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n//??????????????????????????¢???\nld two_circle_area(const Circle&l, const Circle&r) {\n\tld dis = abs(l.p - r.p);\n\tif (dis > l.r + r.r)return 0;\n\telse if (dis + r.r < l.r) {\n\t\treturn r.r*r.r*pi;\n\t}\n\telse if (dis + l.r < r.r) {\n\t\treturn l.r*l.r*pi;\n\t}\n\telse {\n\t\tld ans = (l.r)*(l.r)*acos((dis*dis + l.r*l.r - r.r*r.r) / (2 * dis*l.r)) +\n\t\t\t(r.r)*(r.r)*acos((dis*dis + r.r*r.r - l.r*l.r) / (2 * dis*r.r)) -\n\t\t\tsqrt(4 * dis*dis*l.r*l.r - (dis*dis + l.r*l.r - r.r*r.r)*(dis*dis + l.r*l.r - r.r*r.r)) / 2;\n\t\treturn ans;\n\t}\n\n}\n\n/* ????§???¢ */\n\ntypedef vector<Point> Polygon;\n\n// ??¢???\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// ????§???¢????????¢??????\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// ??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//??????????????????2?????????\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// ??????\n// ???????????????????????¨????????????????????§??¨???\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n// ????????????\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ Q,R };\n\treturn polys;\n}\n\n\n/* ??¢??¬??????????????? */\nvoid add_point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, static_cast<Weight>(abs(p[from] - p[to])));\n\t\t}\n\t}\n\treturn g;\n}\nGraph sennbunn_arrangement(const vector<Line>&s) {\n\tvector<Point>crss;\n\tfor (int i = 0; i < static_cast<int>(s.size()); ++i) {\n\t\tfor (int j = i + 1; j < static_cast<int>(s.size()); ++j) {\n\t\t\tif (isis_ss(s[i], s[j])) {\n\t\t\t\tcrss.push_back(is_ll(s[i], s[j]));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i <static_cast<int>(s.size()); ++i) {\n\t\tcrss.push_back(s[i][0]);\n\t\tcrss.push_back(s[i][1]);\n\t}\n\treturn segment_arrangement(s, crss);\n}\n\n//Graph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n//\tint n = p.size(), m = c.size();\n//\tGraph g(n);\n//\tREP(i, m) {\n//\t\tvector<pair<ld, int>> vec;\n//\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n//\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n//\t\tsort(ALL(vec));\n//\t\tREP(j, vec.size() - 1) {\n//\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n//\t\t\tld angle = vec[j + 1].first - vec[j].first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t\tif (vec.size() >= 2) {\n//\t\t\tint from = vec.back().second, to = vec.front().first;\n//\t\t\tld angle = vec.front().first - vec.back().first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\n/* ????????°?????? */\n\n// ?????????????????¢?????¢??¬??????????????????????????????????????°???????????????\n// ?????´?????????????¨?????????§????????´????????????????¨?????????§???????????????\n// ?????° polygon ??????vector<int> ??§??¨?????????????§???¢???????????§?????????\n// vector<int> ??§??¨????????? ????§???¢???i???????????????????????????????????????p????????????????????§?????????\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\nGraph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n\tint N = p.size();\n\tpolygon.clear();\n\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n\tvector<vector<tuple<ld, int, bool>>> tup(N);\n\tREP(i, s.size()) {\n\t\tint a = -1, b = -1;\n\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n\t\tassert(a >= 0 && b >= 0);\n\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n\t}\n\tREP(i, N) sort(ALL(tup[i]));\n\tREP(i, N) {\n\t\tREP(j, tup[i].size()) {\n\t\t\tld angle; int pos = j, from = i, to; bool flag;\n\t\t\ttie(angle, to, flag) = tup[i][j];\n\t\t\tif (flag) continue;\n\t\t\tvector<int> ps;\n\t\t\twhile (!flag) {\n\t\t\t\tps.push_back(from);\n\t\t\t\tget<2>(tup[from][pos]) = true;\n\t\t\t\tseg2p[from][to].push_back(polygon.size());\n\t\t\t\tseg2p[to][from].push_back(polygon.size());\n\t\t\t\tangle += pi + eps;\n\t\t\t\tif (angle > pi) angle -= 2 * pi;\n\t\t\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n\t\t\t\tif (it == tup[to].end()) it = tup[to].begin();\n\t\t\t\tfrom = to; tie(angle, to, flag) = *it;\n\t\t\t\tpos = it - tup[from].begin();\n\t\t\t}\n\t\t\tpolygon.push_back(ps);\n\t\t}\n\t}\n\tGraph g(polygon.size());\n\tREP(i, N) REP(j, i) {\n\t\tif (seg2p[i][j].size() == 2) {\n\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n\t\t\tg[from].push_back(Edge{ from, to,1 });\n\t\t\tg[to].push_back(Edge{ to, from,1 });\n\t\t}\n\t}\n\treturn g;\n}\n\n\nint main() {\n\twhile (1) {\n\t\tint C, W; cin >> C >> W;\n\t\tif (!C)break;\n\t\tvector<Point>ps;\n\t\tfor (int i = 0; i < C; ++i) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tps.emplace_back(x, y);\n\t\t}\n\t\tvector<Line>ls;\n\t\tfor (int i = 0; i < W; ++i) {\n\t\t\tint s, t; cin >> s >> t; s--; t--;\n\t\t\tls.emplace_back(ps[s], ps[t]);\n\t\t}\n\t\tGraph g=dual_graph(ls, ps);\n\t\tvector<int>oks(g.size());\n\t\tqueue<pair<int, int>>que;\n\t\tque.push(make_pair(0, 0));\n\t\toks[0] = true;\n\t\tint ans = 0;\n\t\twhile (!que.empty()) {\n\t\t\tauto p(que.front());\n\t\t\tque.pop();\n\t\t\tans = p.second;\n\t\t\tfor (auto e : g[p.first]) {\n\t\t\t\tif (!oks[e.dst]) {\n\t\t\t\t\toks[e.dst] = true;\n\t\t\t\t\tque.push(make_pair(e.dst, p.second + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <ctime>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <fstream>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <numeric>\n#include <cassert>\nusing namespace std;\n\ntypedef complex<double> P;\nconst double PI = acos(-1);\n\ndouble fx(double rd){\n\twhile( rd < -1e-9 )   rd += 2*PI;\n\twhile( rd >= 2*PI - 1e-9) rd -= 2*PI;\n\treturn rd;\n}\ndouble R(P a){\n\tdouble rd = atan2(a.imag(),a.real());\n\treturn fx(rd);\n}\n\nint C,W;\n\nint wsc[300] , wtc[300];\nP c[100];\nstruct NODE{\n\tint from,to,id;\n\tdouble rad;\n\tNODE(int from,int to,int id) : from(from) , to(to) , id(id) {\n\t\trad = R(c[to]-c[from]);\n\t}\n\tNODE(){}\n};\nbool operator < (const NODE &a,const NODE &b){\n\treturn a.rad < b.rad;\n}\nvector<NODE> geo[100];\nint done[100];\n\nint start;\nint get(int x,int prev,vector<int> &ad){\n\tif( x == start ) return 1;\n\tif( done[x] ) return 0;\n\telse done[x] = true;\n\t\n\tfor(int i = 0 ; i < geo[x].size() ; i++){\n\t\tint y = (i+1)%geo[x].size();\n\t\tif( geo[x][i].to == prev ){\t\t\t\n\t\t\tif( get(geo[x][y].to,x,ad) ){\n\t\t\t\t//ad.push_back(x);\n\t\t\t\tad.push_back(geo[x][y].id);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(){\n\twhile(cin >> C >> W && C){\n\t\tfor(int i = 0 ; i < 100 ; i++) geo[i].clear();\n\t\tfor(int i = 0 ; i < C ; i++)\n\t\t\tcin >> c[i].real() >> c[i].imag();\n\t\tfor(int i = 0 ; i < W ; i++){\n\t\t\tint s,t;\n\t\t\tcin >> s >> t;\n\t\t\ts--,t--;\n\t\t\tgeo[s].push_back(NODE(s,t,i));\n\t\t\tgeo[t].push_back(NODE(t,s,i));\n\t\t\twsc[i] = s;\n\t\t\twtc[i] = t;\n\t\t}\n\t\tfor(int i = 0 ; i < 100 ; i++) sort(geo[i].begin(),geo[i].end());\n\t\t\n\t\tvector< vector<int> > wallset;\n\t\tfor(int _ = 0 ; _ < 2 ; _++){\n\t\t\tfor(int i = 0 ; i < W ; i++){\n\t\t\t\tmemset(done,0,sizeof(done));\n\t\t\t\tstart = wsc[i];\n\t\t\t\tvector<int> a;\n\t\t\t\tif( get(wtc[i],wsc[i],a) ){\n\t\t\t\t\t//a.push_back(wsc[i]);\n\t\t\t\t\ta.push_back(i);\n\t\t\t\t\tsort(a.begin(),a.end());\n\t\t\t\t\twallset.push_back(a);\n\t\t\t\t}\n\t\t\t\tswap(wsc[i],wtc[i]);\n\t\t\t}\n\t\t}\n\t\tsort(wallset.begin(),wallset.end());\n\t\twallset.erase(unique(wallset.begin(),wallset.end()),wallset.end());\n\t\t\n\t\t\n\t\tint wf[301][301]={};\n\t\tfor(int i = 0 ; i < 301 ; i++)\n\t\t\tfor(int j = 0 ; j < 301 ; j++)\n\t\t\t\twf[i][j] = i==j?0:1e9;\n\t\tint N = wallset.size();\n\t\tvector<int> wall_share[300];\n\t\t\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\t//cout << \"[\" << i << \"] : \";\n\t\t\tfor(int j = 0 ; j < wallset[i].size() ; j++){\n\t\t\t\twall_share[wallset[i][j]].push_back(i);\n\t\t\t\t//cout << wsc[wallset[i][j]] << \"-\" << wtc[wallset[i][j]] << \" \";\n\t\t\t}\n\t\t\t//cout << endl;\n\t\t}\n\t\tfor(int i = 0 ; i < W ; i++){\n\t\t\tfor(int j = 0 ; j <wall_share[i].size() ; j++){\n\t\t\t\tfor(int k = 0 ; k < wall_share[i].size() ; k++){\n\t\t\t\t\tif(j!=k)wf[wall_share[i][j]][wall_share[i][k]] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\tfor(int j = 0 ; j < N ; j++){\n\t\t\t\tfor(int k = 0 ; k < N ; k++){\n\t\t\t\t\twf[j][k] = min(wf[j][k],wf[j][i]+wf[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 1;\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\tans = max( ans , wf[i][0] );\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\nusing R=long double;\nusing edge=tuple<R,int>;\n\nint x[110],y[110];\n\nint main(void){\n\tint n,m;\n\twhile(cin >> n >> m,n){\n\t\trep(i,n) cin >> x[i] >> y[i];\n\n\t\tvector<edge> graph[110];\n\t\tvector<int> used[110];\n\n\t\trep(i,m){\n\t\t\tint s,t;\n\t\t\tcin >> s >> t;\n\t\t\ts--,t--;\n\t\t\tgraph[s].push_back(make_tuple(atan2(y[t]-y[s],x[t]-x[s]),t));\n\t\t\tused[s].push_back(-1);\n\t\t\tgraph[t].push_back(make_tuple(atan2(y[s]-y[t],x[s]-x[t]),s));\n\t\t\tused[t].push_back(-1);\n\t\t}\n\n\t\trep(v,n) sort(_all(graph[v]));\n\t\t\n\t\tint all=0;\n\t\trep(v,n){\n\t\t\trep(i,graph[v].size()){\n\t\t\t\tif(used[v][i]!=-1) continue;\n\t\t\t\t\n\t\t\t\tint cur=v,idx=i;\n\t\t\t\tdo{\n\t\t\t\t\tused[cur][idx]=all;\n\t\t\t\t\tint nxt=get<1>(graph[cur][idx]),nidx=0;\n\t\t\t\t\trep(j,graph[nxt].size()) if(get<1>(graph[nxt][j])==cur) nidx=(j+1)%int(graph[nxt].size());\n\t\t\t\t\tcur=nxt,idx=nidx;\n\t\t\t\t}while(cur!=v);\n\t\t\t\tall++;\n\t\t\t}\n\t\t}\n\t\n\t\tint dual[110][110];\n\t\trep(i,all)rep(j,all) dual[i][j]=(i==j)?0:(1<<20);\n\n\t\tint outer=used[min_element(x,x+n)-x][0];\n\t\t\n\t\trep(v,all){\n\t\t\trep(i,graph[v].size()){\n\t\t\t\tint v2=get<1>(graph[v][i]),j=0;\n\t\t\t\twhile(get<1>(graph[v2][j])!=v) j++;\n\n\t\t\t\tdual[used[v][i]][used[v2][j]]=1;\n\t\t\t\tdual[used[v2][j]][used[v][i]]=1;\n\t\t\t}\n\t\t}\n\n\t\trep(k,all)rep(i,all)rep(j,all) chmin(dual[i][j],dual[i][k]+dual[k][j]);\n\t\tint ans=1;\n\t\trep(v,all) chmax(ans,dual[outer][v]);\n\t\tcout << ans << endl;\n\t}\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX_C 501\n#define MAX_W 501\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:y<p.y; }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const { return p.p1 == p1 && p.p2 == p2; }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a){ os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\nstruct Edge{\n  int from,to,rev,unique_index;\n  Edge(int from=IINF,int to=IINF):from(from),to(to){}\n};\n\nconst bool DEBUG = false;\nint C,W,sp;\nPoint ps[MAX_C];\nvector<Edge> G[MAX_C];\nvector<vector<int> > poly;\nbool used[MAX_C][MAX_C];\nint depth[MAX_C];\nint index_list[MAX_C][MAX_C];\nvector<int> bfs_G[MAX_C];\n\nbool cmp(const Edge& a,const Edge& b){\n  Vector vec_a = ps[a.to] - ps[a.from];\n  Vector vec_b = ps[b.to] - ps[b.from];\n  return atan2(vec_a.y,vec_a.x) <= atan2(vec_b.y,vec_b.x);\n}\n\nbool getPath(int start_node,int node,int edge,vector<int>& edge_list){\n  if(DEBUG)cout << __LINE__ << \": \" <<  node << \",\" << edge << endl;\n  if( used[node][edge] ){\n    if( !edge_list.empty() && node == start_node ) return true;\n    return false;\n  }\n  used[node][edge] = true;\n\n  int next_node = G[node][edge].to;\n  int next_edge = (G[node][edge].rev+1)%((int)G[next_node].size());\n  edge_list.push_back(G[node][edge].unique_index);\n  if(getPath(start_node,next_node,next_edge,edge_list)){\n    if(DEBUG)cout << __LINE__ << \": path::\"  << node << \",\" << edge << endl;\n    return true;\n  } else {\n    return used[node][edge] = false;\n  }\n}\n  \nint main(){\n  while(cin>>C>>W,C|W){\n    rep(i,MAX_C)depth[i] = IINF,bfs_G[i].clear(),G[i].clear();\n    rep(i,MAX_C)rep(j,MAX_C)used[i][j] = false, index_list[i][j] = IINF;\n    depth[0] = 0;\n    poly.clear();\n    sp = 0;\n    rep(i,C) {\n      cin >> ps[i].x >> ps[i].y;\n      ps[i].x += 1000, ps[i].y += 1000;\n      if( ps[i] < ps[sp] ) sp = i;\n    }\n    if(DEBUG)cout << sp << \" \" << ps[sp] << endl;\n    rep(i,W) {\n      int s,t;\n      cin >> s >> t;\n      s--,t--;\n      G[s].push_back(Edge(s,t));\n      G[t].push_back(Edge(t,s));\n    }\n    rep(i,C)sort(G[i].begin(),G[i].end(),cmp);\n    int dex = 0;\n    rep(i,C){\n      rep(j,(int)G[i].size()){\n\tint to = G[i][j].to;\n\trep(k,(int)G[to].size()){\n\t  if(G[to][k].to == i){\n\t    G[i][j].rev = k;\n\t    if( index_list[i][j] == IINF ){\n\t      assert(index_list[to][k] == IINF);\n\t      index_list[i][j] = index_list[to][k] = dex++;\n\t    }\n\t    G[i][j].unique_index = index_list[i][j];\n\t    break;\n\t  }\n\t}\n      }\n    }\n    if(DEBUG){\n      cout << __LINE__ << \":\" << endl;\n      cout << \"sp = \" << sp << endl;\n      rep(i,C){\n\tcout << \"i = \" << i << endl;\n\trep(j,G[i].size()){\n\t  cout << \"from = \" << G[i][j].from << \" to = \" << G[i][j].to << \" rev = \" << G[i][j].rev << \" unique = \" << G[i][j].unique_index << endl;\n\t}\n      }\n      cout << endl << endl;\n    }\n      rep(i,(int)G[sp].size()){\n\tif( used[sp][i] ) continue;\n\tvector<int> tmp;\n\tif( getPath(sp,sp,i,tmp) ) {\n\t  poly.push_back(tmp);\n\t  if(DEBUG)cout << \"[\" << sp << \"][\" << i << \"] : getPath!! : \" << endl;\n\t}\n      }\n\n    rep(i,C){\n      if( i == sp ) continue;\n      rep(j,G[i].size()){\n\tif( used[i][j] ) continue;\n\tvector<int> tmp;\n\tif( getPath(i,i,j,tmp) ){\n\t  poly.push_back(tmp);\n\t}\n      }\n    }\n\n    rep(i,poly.size()){\n      REP(j,i+1,poly.size()){\n\tbool connect = false;\n\trep(k,poly[i].size()){\n\t  rep(l,poly[j].size()){\n\t    if(poly[i][k] == poly[j][l]){\n\t      connect = true;\n\t      goto Skip;\n\t    }\n\t  }\n\t}\n      Skip:;\n\tif(connect){\n\t  bfs_G[i].push_back(j);\n\t  bfs_G[j].push_back(i);\n\t}\n      }\n    }\n\n    if(DEBUG){\n      cout << __LINE__ << \":\" << endl;\n      cout << \"poly.size() = \" << poly.size() << endl;\n      rep(i,(int)poly.size()){\n\tcout << \"poly[\" << i << \"]\" << endl;\n\trep(j,poly[i].size()){\n\t  cout << poly[i][j] << \" \";\n\t}\n\tcout << endl;\n      }\n\n      cout << \"bfs_G = \" << endl;\n      rep(i,poly.size()){\n\tcout << \"[\" << i << \"]\" << endl;\n\trep(j,bfs_G[i].size()){\n\t  cout << bfs_G[i][j] << \" \";\n\t}\n\tcout << endl;\n      }\n\n      cout << \"depth[\" << 0 << \"] = \" << depth[0] << endl;\n    }\n    int answer = 0;\n    deque<int> deq;\n    deq.push_back(0);\n    while(!deq.empty()){\n      int cur = deq.front(); deq.pop_front();\n      rep(i,bfs_G[cur].size()){\n\tint next = bfs_G[cur][i];\n\tif( depth[next] == IINF ){\n\t  depth[next] = depth[cur] + 1;\n\t  answer = max(answer,depth[next]);\n\t  deq.push_back(next);\n\t}\n      }\n    }\n    cout << answer << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<int,int> state;\n\nint N,M;\nP t[100];\nint f[100][100];\nint d[100][100];\n\nvoid init(){\n  memset(f,0,sizeof(f));\n  memset(d,1,sizeof(d));\n}\n\nint solve(){\n\n  int si=0,ti;\n  double mini=1e9;\n  for(int i=0;i<N;i++)\n    if(t[i].real()<t[si].real())si=i;\n  \n  deque<state> Q;    \n  for(int i=0;i<N;i++)\n    if(f[si][i] && arg(t[i]-t[si])< mini)\n      ti=i,mini=arg(t[i]-t[si]);\n  Q.push_back(state(si,ti));\n  d[si][ti]=0;\n  \n\n   \n  int ans=0;\n  while(!Q.empty()){\n    state p=Q.front();\n    Q.pop_front();\n    int from=p.first;\n    int to=p.second;\n    ans=max(ans,d[from][to]);\n    \n    if(d[from][to]+1<d[to][from]){\n      d[to][from]=d[from][to]+1;\n      Q.push_back(state(to,from));\n    }\n    int id=-1;\n    double mini=1e9;\n    for(int i=0;i<N;i++){\n      if(f[to][i]&&i!=from){\n        if( arg( (t[i]-t[to])*conj(t[to]-t[from]) ) < mini){\n          id=i;\n          mini=arg( (t[i]-t[to])*conj(t[to]-t[from]) );\n        }\n      }\n    }\n    if(id!=-1&&d[to][id]>d[from][to]){\n      d[to][id]=d[from][to];\n      Q.push_front(state(to,id));\n    }\n  }\n  return ans;\n}\n\nint main(){\n  while(1){\n    cin>>N>>M;\n    if(N==0&&M==0)break;\n    init();\n    for(int i=0;i<N;i++){\n      int x,y;\n      cin>>x>>y;\n      t[i]=P(x,y);\n    }\n    for(int i=0;i<M;i++){\n      int x,y;\n      cin>>x>>y;\n      x--,y--;\n      f[x][y]=f[y][x]=true;\n    }\n    cout<<solve()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<complex>\n#include<deque>\n#include<vector>\nusing namespace std;\ndouble eps=1e-7;\ndouble x[110];\ndouble y[110];\ndouble px[700];\ndouble py[700];\nint ijk[700];\nint v[700];\nint g[700][700];\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ndouble PI=3.14159265358;\ntypedef complex<double> P;\ntypedef vector<P> G;\n\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n#define se second\n#define fi first\n\nbool intersectSS(const pair<P,P> &s, const pair<P,P> &t) {\n  return ccw(s.fi,s.se,t.fi)*ccw(s.fi,s.se,t.se) <= 0 &&\n         ccw(t.fi,t.se,s.fi)*ccw(t.fi,t.se,s.se) <= 0;\n}\n\nP pt[700];\nP ps[300];\nint s[400];\nint t[400];\ndouble left[400];\ndouble right[400];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<a;i++)scanf(\"%lf%lf\",x+i,y+i);\n\t\tfor(int i=0;i<a;i++){\n\t\t\tdouble X=cos(1)*x[i]-sin(1)*y[i];\n\t\t\tdouble Y=sin(1)*x[i]+cos(1)*y[i];\n\t\t\tx[i]=X;\n\t\t\ty[i]=Y;\n\t\t\tps[i]=P(x[i],y[i]);\n\t\t}\n\t\tfor(int i=0;i<b;i++){\n\t\t\tint p,q;scanf(\"%d%d\",&p,&q);\n\t\t\tp--;q--;\n\t\t\ts[i]=p;t[i]=q;\n\t\t\tpx[i*2]=(x[p]+x[q])/2+eps;\n\t\t\tpy[i*2]=(y[p]+y[q])/2;\n\t\t\tpx[i*2+1]=(x[p]+x[q])/2-eps;\n\t\t\tpy[i*2+1]=(y[p]+y[q])/2;\n\t\t\tpt[i*2]=P(px[i*2],py[i*2]);\n\t\t\tpt[i*2+1]=P(px[i*2+1],py[i*2+1]);\n\t\t}\n\t\tdeque<pair<int,int> >Q;\n\t\t\n\t\tfor(int i=0;i<b*2;i++){\n\t\t\tijk[i]=999999999;\n\t\t\tv[i]=0;\n\t\t\tbool OK=true;\n\t\t\tint tt=s[i/2];\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tif(tt==s[j]||tt==t[j])continue;\n\t\t\t\tif(intersectSS(make_pair(ps[tt],ps[tt]+(pt[i]-ps[tt])*10000.0),make_pair(ps[s[j]],ps[t[j]]))){\n\t\t\t\t\tOK=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttt=t[i/2];\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tif(tt==s[j]||tt==t[j])continue;\n\t\t\t\tif(intersectSS(make_pair(ps[tt],ps[tt]+(pt[i]-ps[tt])*10000.0),make_pair(ps[s[j]],ps[t[j]]))){\n\t\t\t\t\tOK=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(OK){\n\t\t//\t\tprintf(\" %d\\n\",i);\n\t\t\t\tijk[i]=0;\n\t\t\t\tQ.push_back(make_pair(0,i));\n\t\t\t}\n\t\t\tfor(int j=i+1;j<b*2;j++){\n\t\t\t\tint cnt=0;\n\t\t\t\tfor(int k=0;k<b;k++){\n\t\t\t\t\tif(intersectSS(make_pair(ps[s[k]],ps[t[k]]),make_pair(pt[i],pt[j]))){\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tif(cnt>1)break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(cnt<2)g[i][j]=g[j][i]=cnt;\n\t\t\t\telse g[i][j]=g[j][i]=999999999;\n\t\t\t}\n\t\t}\n\t\n\t\twhile(Q.size()){\n\t\t\tint cost=-Q.front().first;\n\t\t\tint at=Q.front().second;Q.pop_front();\n\t\t\tif(v[at])continue;\n\t\t\tv[at]=1;\n\t\t\tfor(int i=0;i<b*2;i++){\n\t\t\t\tif(!v[i]&&ijk[i]>cost+g[at][i]){\n\t\t\t\t\tijk[i]=cost+g[at][i];\n\t\t\t\t\tif(g[at][i]==1)Q.push_back(make_pair(-ijk[i],i));\n\t\t\t\t\telse Q.push_front(make_pair(-ijk[i],i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret=0;\n\t\tfor(int i=0;i<b*2;i++)ret=max(ret,ijk[i]);\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<complex>\n#include<deque>\n#include<vector>\nusing namespace std;\ndouble eps=1e-6;\ndouble x[110];\ndouble y[110];\ndouble px[700];\ndouble py[700];\nint ijk[700];\nint v[700];\nint g[700][700];\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ndouble PI=3.14159265358;\ntypedef complex<double> P;\ntypedef vector<P> G;\n\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n#define se second\n#define fi first\n\nbool intersectSS(const pair<P,P> &s, const pair<P,P> &t) {\n  return ccw(s.fi,s.se,t.fi)*ccw(s.fi,s.se,t.se) <= 0 &&\n         ccw(t.fi,t.se,s.fi)*ccw(t.fi,t.se,s.se) <= 0;\n}\n\nP pt[700];\nP ps[300];\nint s[400];\nint t[400];\ndouble left[400];\ndouble right[400];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<a;i++)scanf(\"%lf%lf\",x+i,y+i);\n\t\tfor(int i=0;i<a;i++){\n\t\t\tdouble X=cos(1)*x[i]-sin(1)*y[i];\n\t\t\tdouble Y=sin(1)*x[i]+cos(1)*y[i];\n\t\t\tx[i]=X;\n\t\t\ty[i]=Y;\n\t\t\tps[i]=P(x[i],y[i]);\n\t\t}\n\t\tfor(int i=0;i<b;i++){\n\t\t\tint p,q;scanf(\"%d%d\",&p,&q);\n\t\t\tp--;q--;\n\t\t\ts[i]=p;t[i]=q;\n\t\t\tpx[i*2]=(x[p]+x[q])/2+eps;\n\t\t\tpy[i*2]=(y[p]+y[q])/2;\n\t\t\tpx[i*2+1]=(x[p]+x[q])/2-eps;\n\t\t\tpy[i*2+1]=(y[p]+y[q])/2;\n\t\t\tpt[i*2]=P(px[i*2],py[i*2]);\n\t\t\tpt[i*2+1]=P(px[i*2+1],py[i*2+1]);\n\t\t}\n\t\tdeque<pair<int,int> >Q;\n\t\tfor(int i=0;i<b*2;i++)for(int j=i+1;j<b*2;j++)g[i][j]=g[j][i]=999999999;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tvector<pair<double,int> >vec;\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tif(s[j]==i){\n\t\t\t\t\tvec.push_back(make_pair(atan2(y[t[j]]-y[i],x[t[j]]-x[i]),t[j]));\n\t\t\t\t}\n\t\t\t\tif(t[j]==i){\n\t\t\t\t\tvec.push_back(make_pair(atan2(y[s[j]]-y[i],x[s[j]]-x[i]),s[j]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tstd::sort(vec.begin(),vec.end());\n\t\t\tint sz=vec.size();\n\t\t\tfor(int j=0;j<vec.size();j++){\n\t\t\t\tdouble th=vec[j].first;\n\t\t\t\tdouble th2=vec[(j+1)%sz].first;\n\t\t\t\tif(th>th2)th2+=2*PI;\n\t\t\t\tif(th2-th<=PI+EPS)continue;\n\t\t//\t\tprintf(\"%d %d %d\\n\",i,vec[j].second,vec[(j+1)%sz].second);\n\t\t\t\tfor(int k=0;k<2;k++)for(int l=0;l<2;l++){\n\t\t\t\t\tif(intersectSS(make_pair(pt[vec[j].second*2+k],pt[vec[(j+1)%sz].second*2+l]),\n\t\t\t\t\tmake_pair(ps[i],ps[vec[j].second]))&&intersectSS(make_pair(pt[vec[j].second*2+k],pt[vec[(j+1)%sz].second*2+l]),\n\t\t\t\t\tmake_pair(ps[i],ps[vec[(j+1)%sz].second]))){\n\t\t\t//\t\t\tprintf(\"%d %d\\n\",vec[j].second*2+k,vec[(j+1)%sz].second*2+l);\n\t\t\t\t\t\tg[vec[j].second*2+k][vec[(j+1)%sz].second*2+l]=g[vec[(j+1)%sz].second*2+l][vec[j].second*2+k]=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<b*2;i++){\n\t\t\tijk[i]=999999999;\n\t\t\tv[i]=0;\n\t\t\tbool OK=true;\n\t\t\tint tt=s[i/2];\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tif(tt==s[j]||tt==t[j])continue;\n\t\t\t\tif(intersectSS(make_pair(ps[tt],ps[tt]+(pt[i]-ps[tt])*10000.0),make_pair(ps[s[j]],ps[t[j]]))){\n\t\t\t\t\tOK=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttt=t[i/2];\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tif(tt==s[j]||tt==t[j])continue;\n\t\t\t\tif(intersectSS(make_pair(ps[tt],ps[tt]+(pt[i]-ps[tt])*10000.0),make_pair(ps[s[j]],ps[t[j]]))){\n\t\t\t\t\tOK=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(OK){\n\t\t//\t\tprintf(\" %d\\n\",i);\n\t\t\t\tijk[i]=0;\n\t\t\t\tQ.push_back(make_pair(0,i));\n\t\t\t}\n\t\t\tfor(int j=i+1;j<b*2;j++){\n\t\t\t\tint cnt=0;\n\t\t\t\tfor(int k=0;k<b;k++){\n\t\t\t\t\tif(intersectSS(make_pair(ps[s[k]],ps[t[k]]),make_pair(pt[i],pt[j]))){\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tif(cnt>1)break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(cnt<2)g[i][j]=g[j][i]=cnt;\n\t\t\t//\telse g[i][j]=g[j][i]=999999999;\n\t\t\t}\n\t\t}\n\t\n\t\twhile(Q.size()){\n\t\t\tint cost=-Q.front().first;\n\t\t\tint at=Q.front().second;Q.pop_front();\n\t\t\tif(v[at])continue;\n\t\t\tv[at]=1;\n\t\t\tfor(int i=0;i<b*2;i++){\n\t\t\t\tif(!v[i]&&ijk[i]>cost+g[at][i]){\n\t\t\t\t\tijk[i]=cost+g[at][i];\n\t\t\t\t\tif(g[at][i]==1)Q.push_back(make_pair(-ijk[i],i));\n\t\t\t\t\telse Q.push_front(make_pair(-ijk[i],i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret=0;\n\t\tfor(int i=0;i<b*2;i++)ret=max(ret,ijk[i]);\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define M_PI (3.141592653589793)\n\nusing namespace std;\n\nconst double EPS = 1e-10;\n\nclass Point{\npublic:\n    double x, y;\n    int id;\n    Point(double x = 0, double y = 0): x(x), y(y){}\n    Point operator + (Point p){return Point(x + p.x, y + p.y);}\n    Point operator - (Point p){return Point(x - p.x, y - p.y);}\n    Point operator * (double a){return Point(x * a, y * a);}\n    Point operator / (double a){return Point(x / a, y / a);}\n    Point operator * (const Point &a){\n        return Point(x * a.x - y * a.y, x * a.y + y * a.x);\n    }\n    bool operator < (const Point &p) const {\n        return (x != p.x ? x < p.x : y < p.y);\n    }\n    bool operator == (const Point &p) const {\n        return (fabs(x - p.x) < EPS && fabs(y - p.y) < EPS);\n    }\n};\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\ndouble dot(Vector a, Vector b){return (a.x * b.x + a.y * b.y);}\ndouble abs(Vector a){return (sqrt(dot(a, a)));}\ndouble cross(Vector a, Vector b){return (a.x * b.y - a.y * b.x);}\n\nint ccw(Point p0, Point p1, Point p2)\n{\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if (cross(a, b) > EPS) return (+1); //p0, p1, p2 が反時計周り\n    if (cross(a, b) < -EPS) return (-1);//p0, p1, p2 が時計回り\n    if (dot(a, b) < -EPS) return (+2); //p2--p0--p1 の順で一直線上\n    if (norm(a) < norm(b)) return (-2); //p0--p1--p2 の順で一直線上\n    \n    return (0); //p0--p2--p1 の順で一直線上\n}\n\nPolygon conhel(Polygon& ps)\n{\n    sort(ps.begin(), ps.end());\n    int k = 0, n = (int)ps.size();\n    Polygon qs(n * 2);\n    \n    for (int i = 0; i < n; i++){\n        while (k > 1 && cross(qs[k - 1] - qs[k - 2], ps[i] - qs[k - 1]) < -EPS) k--;\n        qs[k++] = ps[i];\n    }\n    \n    for (int i = n - 2, t = k; i >= 0; i--){\n        while (k > t && cross(qs[k - 1] - qs[k - 2], ps[i] - qs[k - 1]) < -EPS) k--;\n        qs[k++] = ps[i];\n    }\n    \n    qs.resize(k - 1);\n    return (qs);\n}\n\ndouble getCos(Vector a, Vector b)\n{\n    return (dot(a, b) / (abs(a) * abs(b)));\n}\n\ndouble getArg(Vector v)\n{\n    return (atan2(v.y, v.x));\n}\n \nPoint rotate(Point t, Point p, double r)\n{\n    double ta = cos(r) * (t.x - p.x) - sin(r) * (t.y - p.y) + p.x;\n    double tb = sin(r) * (t.x - p.x) + cos(r) * (t.y - p.y) + p.y;\n    return (Point(ta, tb));\n}\n \nint main()\n{\n    int N, M;\n    \n    while (scanf(\"%d %d\", &N, &M) && N){\n        vector<Point> P(N);\n        vector<int> to[128];\n        bool exist[128][128] = {0};\n        \n        for (int i = 0; i < N; i++){\n            scanf(\"%lf %lf\", &P[i].x, &P[i].y);\n            P[i].id = i;\n        }\n        \n        for (int i = 0; i < M; i++){\n            int x, y;\n            scanf(\"%d %d\", &x, &y);\n            to[--x].push_back(--y);\n            to[y].push_back(x);\n            exist[x][y] = exist[y][x] = 1;\n        }\n        \n        Polygon Q = P;\n        Q = conhel(Q);\n        \n        vector<int> belong[128][128];\n        for (int i = 0; i < Q.size(); i++){\n            int u = Q[i].id, v = Q[(i + 1) % Q.size()].id;\n            belong[u][v].push_back(0);\n            belong[v][u].push_back(0);\n        }\n        int k = 1;\n        set<vector<int> > s;\n        \n        for (int i = 0; i < N; i++){\n            for (int j = 0; j < N; j++){\n                if (P[j] < P[i] && exist[i][j] && belong[i][j].size() < 2){\n                    vector<int> v;\n                    v.push_back(i);\n                    v.push_back(j);\n                    \n                    while (1){\n                        int nextP = -1;\n                        int vv = v[v.size() - 1], uu = v[v.size() - 2];\n                        for (int l = 0; l < to[vv].size(); l++){\n                            if (to[vv][l] == vv || to[vv][l] == uu) continue;\n                            double thetaT, thetaC;\n                            thetaT = acos(getCos(P[uu] - P[vv], P[to[vv][l]] - P[vv]));\n                            if (ccw(P[uu], P[vv], P[to[vv][l]]) > 0) thetaT = 2 * M_PI - thetaT;\n                            if (nextP != -1){\n                                thetaC = acos(getCos(P[uu] - P[vv], P[nextP] - P[vv]));\n                                if (ccw(P[uu], P[vv], P[nextP]) > 0) thetaC = 2 * M_PI - thetaC;\n                            }\n                            if (nextP == -1 || thetaT < thetaC) nextP = to[vv][l];\n                            \n                        }\n                        if (nextP == i) break;\n                        v.push_back(nextP);\n                    }\n                    vector<int> ss = v;\n                    sort(ss.begin(), ss.end());\n                    ss.erase(unique(ss.begin(), ss.end()), ss.end());\n                    if (s.find(ss) != s.end()) continue;\n                    else s.insert(ss);\n                    for (int it = 0; it < v.size(); it++){\n                        int uu = v[it], vv = v[(it + 1) % v.size()];\n                        belong[uu][vv].push_back(k);\n                        belong[vv][uu].push_back(k);\n                    }\n                    k++;\n                }\n            }\n        }\n        \n        vector<int> G[1024];\n        \n        for (int i = 0; i < N; i++){\n            for (int j = i + 1; j < N; j++){\n                if (belong[i][j].size()){\n                    assert(belong[i][j].size() == 2);\n                    int u = belong[i][j][0], v = belong[i][j][1];\n                    G[u].push_back(v);\n                    G[v].push_back(u);\n                }\n            }\n        }\n        \n        int ans = 0;\n        int done[1024];\n        fill(done, done + 1024, -1);\n        queue<pair<int, int> > q;\n        \n        for(q.push(make_pair(0, 0)); q.size(); q.pop()){\n            pair<int, int> x = q.front();\n            if (~done[x.first]) continue;\n            done[x.first] = x.second;\n            ans = max(ans, x.second);\n            \n            for (int i = 0; i < G[x.first].size(); i++){\n                q.push(make_pair(G[x.first][i], x.second + 1));\n            }\n        }\n        \n        printf(\"%d\\n\", ans);\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <queue>\n#include <cstdio>\n#include <cassert>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst double EPS=1e-8;\nconst double PI=acos(-1);\n\nstruct point{\n\tdouble x,y;\n\tpoint():x(0),y(0){}\n\tpoint(double x,double y):x(x),y(y){}\n\tpoint &operator+=(const point &a){ x+=a.x; y+=a.y; return *this; }\n\tpoint &operator-=(const point &a){ x-=a.x; y-=a.y; return *this; }\n\tpoint &operator*=(double c){ x*=c; y*=c; return *this; }\n\tpoint &operator/=(double c){ x/=c; y/=c; return *this; }\n\tpoint operator+(const point &a)const{ return point(x+a.x,y+a.y); }\n\tpoint operator-(const point &a)const{ return point(x-a.x,y-a.y); }\n\tpoint operator/(double c)const{ return point(x/c,y/c); }\n\tpoint operator-()const{ return point(-x,-y); }\n\tbool operator< (const point &a)const{ return x+EPS<a.x || (abs(x-a.x)<EPS && y+EPS<a.y); }\n\tbool operator==(const point &a)const{ return abs(x-a.x)<EPS && abs(y-a.y)<EPS; }\n\tbool operator!=(const point &a)const{ return abs(x-a.x)>EPS || abs(y-a.y)>EPS; }\n};\n\ndouble cross(const point &a,const point &b){ return a.x*b.y-a.y*b.x; }\n\ndouble arg(const point &a){ double t=atan2(a.y,a.x); return t<0?t+2*PI:t; }\n\ntypedef vector<point> polygon;\n\nbool is_ccw(const polygon &F){\n\tint n=F.size();\n\tdouble A=0;\n\trep(i,n) A+=cross(F[i],F[(i+1)%n]);\n\treturn A>-EPS;\n}\n\n// trace the frame of a polygon\nvector<int> trace(int n,const vector<int> *G,int u0,int i0){\n\tvector<int> F;\n\tint u=u0,i=i0;\n\tdo{\n\t\tF.push_back(u);\n\t\tint v=G[u][i];\n\t\tint k=G[v].size();\n\t\trep(j,k) if(G[v][j]==u) i=(j-1+k)%k;\n\t\tu=v;\n\t}while(u!=u0);\n\treturn F;\n}\n\n// normalize the list of vertices\nvector<int> reg(vector<int> a){\n\tint k=min_element(a.begin(),a.end())-a.begin();\n\trep(i,k){\n\t\ta.push_back(a[0]);\n\t\ta.erase(a.begin());\n\t}\n\treturn a;\n}\n\nint main(){\n\tfor(int n,m;scanf(\"%d%d\",&n,&m),n;){\n\t\tpoint P[100];\n\t\trep(u,n) scanf(\"%lf%lf\",&P[u].x,&P[u].y);\n\n\t\tvector<int> G[100];\n\t\trep(i,m){\n\t\t\tint u,v; scanf(\"%d%d\",&u,&v); u--; v--;\n\t\t\tG[u].push_back(v);\n\t\t\tG[v].push_back(u);\n\t\t}\n\n\t\t// angle sort\n\t\trep(u,n){\n\t\t\tint k=G[u].size();\n\t\t\tpair<double,int> A[100];\n\t\t\trep(i,k){\n\t\t\t\tint v=G[u][i];\n\t\t\t\tA[i]=make_pair(arg(P[v]-P[u]),v);\n\t\t\t}\n\t\t\tsort(A,A+k);\n\t\t\trep(i,k) G[u][i]=A[i].second;\n\t\t}\n\n\t\t// decompose to polygons\n\t\tvector< vector<int> > F; // set of polygons\n\t\trep(u,n) rep(i,G[u].size()) F.push_back(reg(trace(n,G,u,i)));\n\t\tsort(F.begin(),F.end());\n\t\tF.erase(unique(F.begin(),F.end()),F.end());\n\n\t\t// find the outside boundary\n\t\tint n2=F.size(),u0=-1;\n\t\trep(u,n2){\n\t\t\tint k=F[u].size();\n\t\t\tpolygon H(k);\n\t\t\trep(i,k) H[i]=P[F[u][i]];\n\t\t\tif(!is_ccw(H)){\n\t\t\t\tassert(u0==-1);\n\t\t\t\tu0=u;\n\t\t\t}\n\t\t}\n\t\tassert(u0!=-1);\n\n\t\t// build the dual graph\n\t\tvector<int> G2[100];\n\t\trep(u,n2) rep(v,u) {\n\t\t\tbool ok=false;\n\t\t\tint nu=F[u].size(),nv=F[v].size();\n\t\t\trep(i,nu) rep(j,nv) if(F[u][i]==F[v][(j+1)%nv] && F[u][(i+1)%nu]==F[v][j]) ok=true;\n\t\t\tif(ok){\n\t\t\t\tG2[u].push_back(v);\n\t\t\t\tG2[v].push_back(u);\n\t\t\t}\n\t\t}\n\n\t\t// BFS\n\t\tint d[100];\n\t\trep(u,n2) d[u]=(u==u0?0:-1);\n\t\tqueue<int> Q;\n\t\tQ.push(u0);\n\t\twhile(!Q.empty()){\n\t\t\tint u=Q.front(); Q.pop();\n\t\t\trep(i,G2[u].size()){\n\t\t\t\tint v=G2[u][i];\n\t\t\t\tif(d[v]==-1) d[v]=d[u]+1, Q.push(v);\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",*max_element(d,d+n2));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<complex>\n#include<deque>\n#include<vector>\nusing namespace std;\ndouble eps=1e-6;\ndouble x[110];\ndouble y[110];\ndouble px[700];\ndouble py[700];\nint ijk[700];\nint v[700];\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ndouble PI=3.14159265358;\nstruct P{\n\tdouble x;double y;\n\tP(){}\n\tP(double X,double Y){\n\t\tx=X;y=Y;\n\t}\n\tP operator+ (const P &a)const{\n\t\treturn P(x+a.x,y+a.y);\n\t}\n\tP operator- (const P &a)const{\n\t\treturn P(x-a.x,y-a.y);\n\t}\n\tP operator* (const double &a)const{\n\t\treturn P(x*a,y*a);\n\t}\n\t/*operator+ (P a){\n\t\treturn P(x+a.x,y+a.y);\n\t}\n\toperator+ (P a){\n\t\treturn P(x+a.x,y+a.y);\n\t}*/\n\t\n};\nbool operator < (const P& a, const P& b) {\n    return a.x<b.x||(a.x==b.x&&a.y<b.y);\n}\ndouble cross(const P& a, const P& b) {\n\treturn a.x*b.y-a.y*b.x;\n}\ndouble dot(const P& a, const P& b) {\n\treturn a.x*b.x+a.y*b.y;\n}\n\nint ccw(P a, P b, P c) {\n\tb=b-a;c=c-a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (b.x*b.x+b.y*b.y<c.x*c.x+c.y*c.y) return -2;       // a--b--c on line\n  return 0;\n}\n#define se second\n#define fi first\n\nbool intersectSS(const pair<P,P> &s, const pair<P,P> &t) {\n  return ccw(s.fi,s.se,t.fi)*ccw(s.fi,s.se,t.se) <= 0 &&\n         ccw(t.fi,t.se,s.fi)*ccw(t.fi,t.se,s.se) <= 0;\n}\n\nP pt[700];\nP ps[300];\nint s[400];\nint t[400];\ndouble left[400];\ndouble right[400];\nvector<pair<int,int> >g[700];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<700;i++)g[i].clear();\n\t\tfor(int i=0;i<a;i++)scanf(\"%lf%lf\",x+i,y+i);\n\t\tfor(int i=0;i<a;i++){\n\t\t\tdouble X=cos(1)*x[i]-sin(1)*y[i];\n\t\t\tdouble Y=sin(1)*x[i]+cos(1)*y[i];\n\t\t\tx[i]=X;\n\t\t\ty[i]=Y;\n\t\t\tps[i]=P(x[i],y[i]);\n\t\t}\n\t\tfor(int i=0;i<b;i++){\n\t\t\tint p,q;scanf(\"%d%d\",&p,&q);\n\t\t\tp--;q--;\n\t\t\ts[i]=p;t[i]=q;\n\t\t\tpx[i*2]=(x[p]+x[q])/2+eps;\n\t\t\tpy[i*2]=(y[p]+y[q])/2;\n\t\t\tpx[i*2+1]=(x[p]+x[q])/2-eps;\n\t\t\tpy[i*2+1]=(y[p]+y[q])/2;\n\t\t\tpt[i*2]=P(px[i*2],py[i*2]);\n\t\t\tpt[i*2+1]=P(px[i*2+1],py[i*2+1]);\n\t\t}\n\t\tdeque<pair<int,int> >Q;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tvector<pair<double,pair<int,int> > >vec;\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tif(s[j]==i){\n\t\t\t\t\tvec.push_back(make_pair(atan2(y[t[j]]-y[i],x[t[j]]-x[i]),make_pair(j,t[j])));\n\t\t\t\t}\n\t\t\t\tif(t[j]==i){\n\t\t\t\t\tvec.push_back(make_pair(atan2(y[s[j]]-y[i],x[s[j]]-x[i]),make_pair(j,s[j])));\n\t\t\t\t}\n\t\t\t}\n\t\t\tstd::sort(vec.begin(),vec.end());\n\t\t\tint sz=vec.size();\n\t\t\tfor(int j=0;j<vec.size();j++){\n\t\t\t\tdouble th=vec[j].first;\n\t\t\t\tdouble th2=vec[(j+1)%sz].first;\n\t\t\t\tif(th>th2)th2+=2*PI;\n\t\t\t\tif(th2-th<=PI+EPS)continue;\n\t\t\t\tfor(int k=0;k<2;k++)for(int l=0;l<2;l++){\n\t\t\t\t\tif(intersectSS(make_pair(pt[vec[j].second.first*2+k],pt[vec[(j+1)%sz].second.first*2+l]),\n\t\t\t\t\tmake_pair(ps[i],ps[vec[j].second.second]))&&intersectSS(make_pair(pt[vec[j].second.first*2+k],pt[vec[(j+1)%sz].second.first*2+l]),\n\t\t\t\t\tmake_pair(ps[i],ps[vec[(j+1)%sz].second.second]))){\n\t\t\t\t\t\tg[vec[j].second.first*2+k].push_back(make_pair(vec[(j+1)%sz].second.first*2+l,0));\n\t\t\t\t\t\tg[vec[(j+1)%sz].second.first*2+l].push_back(make_pair(vec[j].second.first*2+k,0));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<b*2;i++){\n\t\t\tijk[i]=999999999;\n\t\t\tv[i]=0;\n\t\t\tbool OK=true;\n\t\t\tint tt=s[i/2];\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tif(tt==s[j]||tt==t[j])continue;\n\t\t\t\tif(intersectSS(make_pair(ps[tt],ps[tt]+(pt[i]-ps[tt])*10000.0),make_pair(ps[s[j]],ps[t[j]]))){\n\t\t\t\t\tOK=false;break;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttt=t[i/2];\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tif(tt==s[j]||tt==t[j])continue;\n\t\t\t\tif(intersectSS(make_pair(ps[tt],ps[tt]+(pt[i]-ps[tt])*10000.0),make_pair(ps[s[j]],ps[t[j]]))){\n\t\t\t\t\tOK=false;break;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(OK){\n\t\t\t\tijk[i]=0;\n\t\t\t\tQ.push_back(make_pair(0,i));\n\t\t\t}\n\t\t\tfor(int j=i+1;j<b*2;j++){\n\t\t\t\tint cnt=0;\n\t\t\t\tfor(int k=0;k<b;k++){\n\t\t\t\t\tif(intersectSS(make_pair(ps[s[k]],ps[t[k]]),make_pair(pt[i],pt[j]))){\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tif(cnt>1)break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(cnt<2){\n\t\t\t\t\tg[i].push_back(make_pair(j,cnt));\n\t\t\t\t\tg[j].push_back(make_pair(i,cnt));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(Q.size()){\n\t\t\tint cost=-Q.front().first;\n\t\t\tint at=Q.front().second;Q.pop_front();\n\t\t\tif(v[at])continue;\n\t\t\tv[at]=1;\n\t\t\tfor(int i=0;i<g[at].size();i++){\n\t\t\t\tif(!v[g[at][i].first]&&ijk[g[at][i].first]>cost+g[at][i].second){\n\t\t\t\t\tijk[g[at][i].first]=cost+g[at][i].second;\n\t\t\t\t\tif(g[at][i].second==1)Q.push_back(make_pair(-ijk[g[at][i].first],g[at][i].first));\n\t\t\t\t\telse Q.push_front(make_pair(-ijk[g[at][i].first],g[at][i].first));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret=0;\n\t\tfor(int i=0;i<b*2;i++)ret=max(ret,ijk[i]);\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<int,pair<bool,double> > P2;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define min_3(a,b,c) min(a,min(b,c))\n#define max_3(a,b,c) max(a,max(b,c))\n#define mp1(a,b,c) P1(a,P(b,c))\n#define mp2(a,b,c) P2(a,pair<bool,double>(b,c))\n#define pque(a) priority_queue<a>\n#define rpque(a) priority_queue<a,vector<a>,greater<a>>\n\nconst int INF=1000000000;\nconst int dre_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dre_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\nconst int kaijou[10]={1,1,2,6,24,120,720,5040,40320,362880};\n\nbool com(P2 x,P2 y){\n\tif(x.sc.fr!=y.sc.fr)return x.sc.fr;\n\treturn x.sc.sc>=y.sc.sc;\n}\n\nint main(){\n\tint ppp=0;\n\twhile(1){\n\t\tppp++; if(ppp>=6)Sleep(100000);\n\t\tstatic int v,w;\n\t\tstatic int x[110],y[110];\n\t\tstatic int s,t;\n\t\t\n\t\tscanf(\"%d%d\",&v,&w); if(v==0&&w==0)break;\n\t\trep1(i,v)scanf(\"%d%d\",&x[i],&y[i]);\n\t\t\n\t\tstatic vector<P1> V_; V_.clear();\n\t\trep1(i,v){\n\t\t\tV_.pb(mp1(x[i],y[i],i));\n\t\t}\n\t\tsor(V_);\n\t\tstatic vector<P2> vec_[110];\n\t\trep1(i,v){\n\t\t\tvec_[i].clear();\n\t\t\tvec_[i].pb(mp2(0,false,-INF));\n\t\t\trep1(j,v){\n\t\t\t\tif(i==j)continue;\n\t\t\t\tif(x[i]<x[j]){\n\t\t\t\t\tvec_[i].pb(mp2(j,true,(double)(y[j]-y[i])/(x[j]-x[i])));\n\t\t\t\t}\n\t\t\t\telse if(x[i]>x[j]){\n\t\t\t\t\tvec_[i].pb(mp2(j,false,(double)(y[j]-y[i])/(x[j]-x[i])));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(y[j]>y[i])vec_[i].pb(mp2(j,true,(double)INF));\n\t\t\t\t\telse vec_[i].pb(mp2(j,true,(double)-INF));\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(vec_[i].begin(),vec_[i].end(),com);\n\t\t}\n\t\t\n\t\tstatic int e;\n\t\tstatic vector<int> V; V.clear();\n\t\tstatic bool edge[110][110];\n\t\tstatic vector<int> vec[110]; \n\t\t\n\t\te=w;\n\t\trep(i,v)V.pb(V_[i].sc.sc);\n\t\trep(i,110)rep(j,110)edge[i][j]=false;\n\t\trep(i,e){\n\t\t\tscanf(\"%d%d\",&s,&t);\n\t\t\tedge[s][t]=true;\n\t\t\tedge[t][s]=true;\n\t\t}\n\t\trep1(i,v){\n\t\t\tvec[i].clear();\n\t\t\trep(j,vec_[i].size()){\n\t\t\t\tvec[i].pb(vec_[i][j].fr);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ret=0;\n\t\twhile(e>0){\n\t\t\tret++;\n\t\t\t\n\t\t\tint a=-1;\n\t\t\trep(i,V.size()){\n\t\t\t\trep(j,105){\n\t\t\t\t\tif(edge[V[i]][j]){a=V[i]; break;}\n\t\t\t\t}\n\t\t\t\tif(a!=-1)break;\n\t\t\t}\n\t\t\t\n\t\t\tint b=0,c=a;\n\t\t\twhile(1){\n\t\t\t\tif(c==-1||vec[c].size()==0)break;\n\t\t\t\trep(i,vec[c].size()){\n\t\t\t\t\tif(vec[c][i]==b){\n\t\t\t\t\t\ti++; i%=vec[c].size();\n\t\t\t\t\t\twhile(!edge[c][vec[c][i]]){\n\t\t\t\t\t\t\ti++; i%=vec[c].size();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tedge[c][vec[c][i]]=false;\n\t\t\t\t\t\tedge[vec[c][i]][c]=false;\n\t\t\t\t\t\te--;\n\t\t\t\t\t\tb=c;\n\t\t\t\t\t\tc=vec[c][i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(c==a)break;\n\t\t\t}\n\t\t\t\n\t\t\tbool updata=true;\n\t\t\twhile(updata){\n\t\t\t\tupdata=false;\n\t\t\t\trep1(i,v){\n\t\t\t\t\tint cnt=0;\n\t\t\t\t\tint t=105;\n\t\t\t\t\trep1(j,v){\n\t\t\t\t\t\tif(edge[i][j]){cnt++; t=j;}\n\t\t\t\t\t}\n\t\t\t\t\tif(cnt==1){\n\t\t\t\t\t\tupdata=true;\n\t\t\t\t\t\tedge[i][t]=false;\n\t\t\t\t\t\tedge[t][i]=false;\n\t\t\t\t\t\te--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#define N 100\n#define M 300\n#define K 600\nusing namespace std;\ntypedef pair<double,int> P;\nint x[N];\nint y[N];\nvector<P> e[N];\nint a[M];\nint b[M];\nint id[M][N];\nbool used[M][N];\nvector<int> adj[M];\nint out_i,out_v;\nint out;\nvector<int> e2[K];\nint dist[K];\n \nint rev(int i,int v){\n    if(a[i]==v)return b[i];\n    else return a[i];\n}\n \nvoid solve(int i,int v,int k){\n    vector<int> res;\n    int s=i;\n    used[s][v]=true;\n    res.push_back(s);\n    if(i==out_i&&v==out_v)out=k;\n    while(1){\n        i=e[v][(id[i][v]+1)%e[v].size()].second;\n        v=rev(i,v);\n        if(i==s)break;\n        used[i][v]=true;\n        res.push_back(i);\n        if(i==out_i&&v==out_v)out=k;\n    }\n    for(i=0;i<res.size();i++)adj[res[i]].push_back(k);\n}\n \nint max(int a,int b){return a>b?a:b;}\n \nvoid bfs(int n,int s){\n    int i;\n    for(i=0;i<n;i++)dist[i]=-1;\n    dist[s]=0;\n    queue<int> que;\n    que.push(s);\n    while(!que.empty()){\n        int v=que.front();\n        que.pop();\n        for(i=0;i<e2[v].size();i++){\n            int u=e2[v][i];\n            if(dist[u]==-1){\n                dist[u]=dist[v]+1;\n                que.push(u);\n            }\n        }\n    }\n}\n \nint main(){\n    while(1){\n        int n,m,i,j;\n        scanf(\"%d %d\",&n,&m);\n        if(n==0&&m==0)break;\n        for(i=0;i<n;i++)e[i].clear();\n        for(i=0;i<m;i++)adj[i].clear();\n        int lf=0;\n        for(i=0;i<n;i++){\n            scanf(\"%d %d\",&x[i],&y[i]);\n            if(x[i]<x[lf])lf=i;\n        }\n        for(i=0;i<m;i++){\n            scanf(\"%d %d\",&a[i],&b[i]);\n            a[i]--;b[i]--;\n            double dx=(double)(x[b[i]]-x[a[i]]);\n            double dy=(double)(y[b[i]]-y[a[i]]);\n            e[a[i]].push_back(P(atan2(dy,dx),i));\n            e[b[i]].push_back(P(atan2(-dy,-dx),i));\n        }\n        for(i=0;i<n;i++)sort(e[i].begin(),e[i].end());\n        int bt=0;\n        for(i=0;i<n;i++){\n            for(j=0;j<e[i].size();j++){\n                id[e[i][j].second][i]=j;\n                if(i==lf){\n                    int u=rev(e[i][j].second,i);\n                    int v=rev(e[i][bt].second,i);\n                    double t1=atan2((double)(y[u]-y[i]),(double)(x[u]-x[i]));\n                    double t2=atan2((double)(y[v]-y[i]),(double)(x[v]-x[i]));\n                    if(t1>t2)bt=j;\n                }\n            }\n        }\n        out_i=e[lf][bt].second;\n        out_v=lf;\n        for(i=0;i<m;i++)for(j=0;j<n;j++)used[i][j]=false;\n        int k=0;\n        for(i=0;i<m;i++){\n            if(!used[i][a[i]]){\n                solve(i,a[i],k);\n                k++;\n            }\n            if(!used[i][b[i]]){\n                solve(i,b[i],k);\n                k++;\n            }\n        }\n        for(i=0;i<k;i++)e2[i].clear();\n        for(i=0;i<m;i++){\n            e2[adj[i][0]].push_back(adj[i][1]);\n            e2[adj[i][1]].push_back(adj[i][0]);\n        }\n        bfs(k,out);\n        int ans=0;\n        for(i=0;i<k;i++)ans=max(ans,dist[i]);\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <ctime>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <fstream>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <numeric>\n#include <cassert>\nusing namespace std;\n\ntypedef complex<double> P;\n\nint C,W;\n\nint wsc[300] , wtc[300];\nP c[100];\nstruct NODE{\n\tint from,to,id;\n\tNODE(int from,int to,int id) : from(from) , to(to) , id(id) {}\n\tNODE(){}\n};\nvector<NODE> geo[100];\n\nconst double PI = acos(-1);\nint start;\ndouble fx(double rd){\n\twhile( rd < -1e-9 )   rd += 2*PI;\n\twhile( rd >= 2*PI - 1e-9) rd -= 2*PI;\n\treturn rd;\n}\ndouble R(P a){\n\tdouble rd = atan2(a.imag(),a.real());\n\treturn fx(rd);\n}\nint get(int x,int prev,vector<int> &ad){\n\tif( x == start ) return 1;\n\t\n\tdouble r1 = R(c[x]-c[prev]);\n\tdouble bad = 0;\n\tint o = -1;\n\tint id;\n\tfor(int i = 0 ; i < geo[x].size() ; i++){\n\t\tif( geo[x][i].to == prev ) continue;\n\t\tdouble r2 = R(c[geo[x][i].to]-c[x]);\n\t\tdouble rr = fx(r2-r1);\n\t\tif( -1e-9 <= rr && rr <= PI + 1e-9 ){\n\t\t\tif( rr > bad ){\n\t\t\t\to = geo[x][i].to;\n\t\t\t\tbad = rr;\n\t\t\t\tid = geo[x][i].id;\n\t\t\t}\n\t\t}\n\t}\n\tif( o == -1 ) return 0;\n\t\n\tif( get(o,x,ad) ){\n\t\tad.push_back(id);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nint main(){\n\twhile(cin >> C >> W && C){\n\t\tfor(int i = 0 ; i < 100 ; i++) geo[i].clear();\n\t\tfor(int i = 0 ; i < C ; i++)\n\t\t\tcin >> c[i].real() >> c[i].imag();\n\t\tfor(int i = 0 ; i < W ; i++){\n\t\t\tint s,t;\n\t\t\tcin >> s >> t;\n\t\t\ts--,t--;\n\t\t\tgeo[s].push_back(NODE(s,t,i));\n\t\t\tgeo[t].push_back(NODE(t,s,i));\n\t\t\twsc[i] = s;\n\t\t\twtc[i] = t;\n\t\t\t\n\t\t}\n\t\t\n\t\tvector< vector<int> > wallset;\n\t\tfor(int _ = 0 ; _ < 2 ; _++){\n\t\t\tfor(int i = 0 ; i < W ; i++){\n\t\t\t\tstart = wsc[i];\n\t\t\t\tvector<int> a;\n\t\t\t\tif( get(wtc[i],wsc[i],a) ){\n\t\t\t\t\ta.push_back(i);\n\t\t\t\t\tsort(a.begin(),a.end());\n\t\t\t\t\twallset.push_back(a);\n\t\t\t\t}\n\t\t\t\tswap(wsc[i],wtc[i]);\n\t\t\t}\n\t\t}\n\t\tsort(wallset.begin(),wallset.end());\n\t\twallset.erase(unique(wallset.begin(),wallset.end()),wallset.end());\n\t\t\n\t\tint wf[101][101]={};\n\t\tfor(int i = 0 ; i < 101 ; i++)\n\t\t\tfor(int j = 0 ; j < 101 ; j++)\n\t\t\t\twf[i][j] = i==j?0:1e9;\n\t\tint N = wallset.size();\n\t\tvector<int> wall_share[300];\n\t\t\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\tfor(int j = 0 ; j < wallset[i].size() ; j++){\n\t\t\t\twall_share[wallset[i][j]].push_back(i);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0 ; i < W ; i++){\n\t\t\tif( wall_share[i].size() == 1 ){\n\t\t\t\twf[wall_share[i][0]][100] = wf[100][wall_share[i][0]] = 1;\n\t\t\t}else if( wall_share[i].size() == 2 ){\n\t\t\t\twf[wall_share[i][0]][wall_share[i][1]] = wf[wall_share[i][1]][wall_share[i][0]] = 1;\n\t\t\t}else{\n\t\t\t}\n\t\t}\n\t\twhile( wallset.size() > 100 );\n\t\tfor(int i = 0 ; i < 101 ; i++){\n\t\t\tfor(int j = 0 ; j < 101 ; j++){\n\t\t\t\tfor(int k = 0 ; k < 101 ; k++){\n\t\t\t\t\twf[j][k] = min(wf[j][k],wf[j][i]+wf[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\tans = max( ans , wf[i][100] );\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// Library.\n#include<cassert>\n#include<map>\n#include<vector>\n#include<cmath>\n#include<queue>\n#include<algorithm>\n// Type.\ntypedef int Label;\ntypedef double Weight;\n// Class.\ntemplate<typename Vertex, typename Edge>\nclass PlaneGraph {\npublic:\n  void insert(const Vertex& v);\n  void insert(Edge e);\n  const PlaneGraph<Vertex, Edge> dualgraph() const;\n  const std::map<Label, Weight> Dijkstra(const Label& start) const;\nprivate:\n  void dualgraph_color(std::map<Label, std::map<Label, int>>& color, int c, const Edge& e, const std::map<Label, std::vector<Edge>>& edge) const;\n  std::map<Label, Vertex> V;\n  std::map<Label, std::vector<Edge>> E;\n};\n// Implement.\ntemplate<typename Vertex, typename Edge>\nvoid PlaneGraph<Vertex, Edge>::insert(const Vertex& v) {\n  V[v.label] = v;\n}\ntemplate<typename Vertex, typename Edge>\nvoid PlaneGraph<Vertex, Edge>::insert(Edge e) {\n  assert(V.find(e.from) != std::end(V));\n  assert(V.find(e.to) != std::end(V));\n  E[e.from].push_back(e);\n  std::swap(e.from, e.to);\n  E[e.from].push_back(e);\n}\ntemplate<typename Vertex, typename Edge>\nconst PlaneGraph<Vertex, Edge> PlaneGraph<Vertex, Edge>::dualgraph() const {\n  // Sort edges counterclockwise.\n  auto edge = E;\n  for(auto& list: edge) if(!list.second.empty()) {\n    std::sort(std::begin(list.second), std::end(list.second), [&](const Edge& lhs, const Edge& rhs) {\n      double l = std::atan2(V.at(lhs.to).y - V.at(lhs.from).y, V.at(lhs.to).x - V.at(lhs.from).x);\n      double r = std::atan2(V.at(rhs.to).y - V.at(rhs.from).y, V.at(rhs.to).x - V.at(rhs.from).x);\n      return l < r;\n    });\n    list.second.push_back(list.second.front());\n  }\n  // Color edges.\n  std::map<Label, std::map<Label, int>> color;\n  int c = 1;\n  for(const auto& list: edge) {\n    for(const auto& e: list.second) if(!color[e.from].count(e.to)) dualgraph_color(color, c++, e, edge);\n    if(list.first == bottom) outside_color = color[list.second.front().from][list.second.front().to];\n  }\n  // Construct the dualgraph.\n  PlaneGraph<Vertex, Edge> result;\n  std::vector<std::vector<bool>> used(c, std::vector<bool>(c, false));\n  for(int i = 1; i < c; ++i) result.insert(Vertex({i}));\n  for(const auto& list: E) for(const auto& e: list.second) if(!used[color[e.from][e.to]][color[e.to][e.from]]) {\n    used[color[e.from][e.to]][color[e.to][e.from]] = true;\n    used[color[e.to][e.from]][color[e.from][e.to]] = true;\n    result.insert(Edge({color[e.from][e.to], color[e.to][e.from], 1}));\n  }\n  return result;\n}\ntemplate<typename Vertex, typename Edge>\nvoid PlaneGraph<Vertex, Edge>::dualgraph_color(std::map<Label, std::map<Label, int>>& color, int c, const Edge& e, const std::map<Label, std::vector<Edge>>& edge) const {\n  color[e.from][e.to] = c;\n  for(auto it = edge.at(e.to).rbegin(); it != edge.at(e.to).rend(); ++it) if(it->to == e.from) {\n    ++it;\n    if(!color[it->from].count(it->to)) dualgraph_color(color, c, *it, edge);\n    break;\n  }\n}\ntemplate<typename Vertex, typename Edge>\nconst std::map<Label, Weight> PlaneGraph<Vertex, Edge>::Dijkstra(const Label& start) const {\n  std::map<Label, Weight> result;\n  std::priority_queue<Edge, std::vector<Edge>, std::function<bool(Edge, Edge)>> q([](Edge lhs, Edge rhs) {\n    return lhs.weight > rhs.weight;\n  });\n  q.push(Edge({start, start, 0}));\n  while(!q.empty()) {\n    auto cur = q.top();\n    q.pop();\n    if(result.count(cur.to)) continue;\n    result[cur.to] = cur.weight;\n    for(const auto& nex: E.at(cur.to)) if(!result.count(nex.to)) q.push(Edge({nex.from, nex.to, cur.weight + nex.weight}));\n  }\n  return result;\n}\n////////////////////////////////////////\n// Configuration.\nstruct Vertex {Label label; double x, y;};\nstruct Edge {Label from, to; Weight weight;};\n////////////////////////////////////////\n#include<bits/stdc++.h>\nusing namespace std;\nint main() {\n  int C, W;\n  while(cin >> C >> W, C | W) {\n    vector<Vertex> pillar;\n    int bottom_x = 1001, bottom_y = 1001;\n    for(int i = 0; i < C; ++i) {\n      double x, y;\n      cin >> x >> y;\n      pillar.push_back({i, x, y});\n      if(bottom_x < x) continue;\n      if(bottom_x == x && bottom_y < y) continue;\n      bottom_x = x;\n      bottom_y = y;\n      bottom = i;\n    }\n    PlaneGraph<Vertex, Edge> G;\n    for(const auto& p: pillar) G.insert(p);\n    for(int i = 0; i < W; ++i) {\n      int s, t;\n      cin >> s >> t;\n      --s; --t;\n      G.insert(Edge({s, t, 1}));\n    }\n    auto D = G.dualgraph();\n    auto distance = D.Dijkstra(outside_color);\n    double answer = 0;\n    for(const auto& d: distance) answer = max(answer, d.second);\n    cout << answer << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#include <climits>\n\nusing namespace std;\n\ntypedef long long lint;\n\n//定数\nconst double EPS = 1e-10;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\nconst int INF = 1001001001;\nconst lint INFLL = 1001001001001001001ll;\n\n//初期化関連\n#define zclear(a) memset((a), 0 ,sizeof(a))\n#define mclear(a) memset((a), -1, sizeof(a))\n\n//デバッグ出力\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nbool eq(double a, double b) //a == b\n{\n    return (fabs(a - b) <= EPS);\n}\n\nbool neq(double a, double b) //a == b\n{\n    return (!eq(a, b));\n}\n  \nbool lt(double a, double b) //a < b\n{\n    return (a - b < -EPS);\n}\n  \nbool leq(double a, double b) //a <= b\n{\n    return (lt(a, b) || eq(a, b));\n}\n  \nbool gt(double a, double b) //a > b\n{\n    return (a - b > +EPS);\n}\n  \nbool geq(double a, double b) //a >= b\n{\n    return (gt(a, b) || eq(a, b));\n}\n\nclass Point{\npublic:\n\tdouble x, y;\n\tint id;\n\tPoint(double x = 0, double y = 0): x(x), y(y){}\n\tPoint operator + (Point p){return Point(x + p.x, y + p.y);}\n\tPoint operator - (Point p){return Point(x - p.x, y - p.y);}\n\tPoint operator * (double a){return Point(x * a, y * a);}\n\tPoint operator / (double a){return Point(x / a, y / a);}\n\tPoint operator * (const Point &a){\n\t\treturn Point(x * a.x - y * a.y, x * a.y + y * a.x);\n\t}\n\tbool operator < (const Point &p) const {\n\t\treturn (x != p.x ? x < p.x : y < p.y);\n\t}\n\tbool operator == (const Point &p) const {\n\t\treturn (fabs(x - p.x) < EPS && fabs(y - p.y) < EPS);\n\t}\n};\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\ndouble norm(Vector a){return (a.x * a.x + a.y * a.y);}\ndouble abs(Vector a){return (sqrt(norm(a)));}\ndouble abs(Vector a, Vector b){return (sqrt(norm(a - b)));}\ndouble dot(Vector a, Vector b){return (a.x * b.x + a.y * b.y);}\ndouble cross(Vector a, Vector b){return (a.x * b.y - a.y * b.x);}\ndouble atan(Vector a){return atan2(a.y, a.x);}\nbool sortX(Point a, Point b){return (a.x != b.x ? lt(a.x, b.x) : lt(a.y, b.y));}\nbool sortY(Point a, Point b){return (a.y != b.y ? lt(a.y, b.y) : lt(a.x, b.x));}\nPoint p;\nbool sortT(Point a, Point b){return (gt(cross(a - p, b - p), 0));}\n\nint ccw(Point p0, Point p1, Point p2)\n{\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > EPS) return (+1); //p0, p1, p2 が反時計周り\n\tif (cross(a, b) < -EPS) return (-1);//p0, p1, p2 が時計回り\n\tif (dot(a, b) < -EPS) return (+2); //p2--p0--p1 の順で一直線上\n\tif (norm(a) < norm(b)) return (-2); //p0--p1--p2 の順で一直線上\n\treturn (0); //p0--p2--p1 の順で一直線上\n}\n\nPolygon normalize(Polygon &v)\n{\n    int pt = 0;\n    for (int i = 1; i < v.size(); i++){\n        if (v[pt].y > v[i].y || (v[pt].y == v[i].y && v[pt].x > v[i].x)){\n            pt = i;\n        }\n    }\n    swap(v[pt], v[0]);\n    p = v[0];\n    sort(v.begin() + 1, v.end(), sortT);\n    return (v);\n}\n\nPolygon conhel(Polygon& ps)\n{\n    sort(ps.begin(), ps.end());\n    int k = 0, n = (int)ps.size();\n    Polygon qs(n * 2);\n      \n    for (int i = 0; i < n; i++){\n      while (k > 1 && cross(qs[k - 1] - qs[k - 2], ps[i] - qs[k - 1]) < -EPS) k--;\n      qs[k++] = ps[i];\n    }\n  \n    for (int i = n - 2, t = k; i >= 0; i--){\n      while (k > t && cross(qs[k - 1] - qs[k - 2], ps[i] - qs[k - 1]) < -EPS) k--;\n      qs[k++] = ps[i];\n    }\n  \n    qs.resize(k - 1);\n    return (qs);\n}\n\ndouble getArea(Polygon t){\n    double ans = 0.0;\n\tt = normalize(t);\n    for (unsigned int i = 0; i < t.size(); i++)\n        ans += cross(t[i] , t[(i + 1) % t.size()]);\n    return (fabs(ans) / 2);\n}\n\nbool isIntersectLL(Point p1, Point p2, Point p3, Point p4)\n{// 同一直線の場合は交差していると判定する.\n\treturn (abs(cross(p2 - p1, p4 - p3)) > EPS || // 傾きが異なる\n\t\tabs(cross(p2 - p1, p4 - p3)) < EPS); // 同じ直線である\n}\nbool isIntersectLS(Point p1, Point p2, Point p3, Point p4)\n{// 同一直線上にある場合も交差と判定\n\treturn (cross(p2 - p1, p3 - p1) * cross(p2 - p1, p4 - p1) < EPS);\n}\nbool isIntersectLP(Point p1, Point p2, Point p)\n{\n\treturn (neq(abs(ccw(p1, p2, p)), 1));\n}\nbool isIntersectSS(Point p1, Point p2, Point p3, Point p4)\n{\n    return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n             ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool isIntersectSP(Point p1, Point p2, Point p)\n{\n\treturn (eq(ccw(p1, p2, p), 0));\n}\nbool isInsideCP(Point c, double r, Point p)\n{\n\treturn (leq(abs(c - p), r));\n}\nbool isInsideCC(Point c1, double r1, Point c2, double r2)\n{\n\treturn (leq(abs(c1 - c2), r1 + r2) && geq(abs(c1 - c2), abs(r1 - r2)));\n}\nbool isInsidePolyP(Polygon gon, Point p)\n{\n    for (int i = 0; i < gon.size(); i++){\n        if (ccw(gon[i], gon[(i + 1) % gon.size()], p) == -1) return (false);\n    }\n    return (true);\n}\n\nPoint projection(Point p1, Point p2, Point p3) //直線p1p2 上への写像\n{\n\tdouble t = dot(p3 - p1, p2 - p1) / norm(p2 - p1);\n\treturn (p1 + (p2 - p1) * t);\n}\nPoint reflection(Point p1, Point p2, Point p3) //直線p1p2 上への反射\n{\n\treturn (p3 + (projection(p1, p2, p3) - p) * 2);\n}\ndouble distanceLP(Point p1, Point p2, Point p)\n{\n\treturn (abs(p - projection(p1, p2, p)));\n}\ndouble distanceLL(Point l1, Point l2, Point m1, Point m2)\n{\n\treturn (isIntersectLL(l1, l2, m1, m2) ? 0 : distanceLP(l1, l2, m1));\n}\ndouble distanceLS(Point l1, Point l2, Point s1, Point s2)\n{\n    if (isIntersectLS(l1, l2, s1, s2)) return (0);\n\treturn (min(distanceLP(l1, l2, s1), distanceLP(l1, l2, s2)));\n}\ndouble distanceSP(Point s1, Point s2, Point p)\n{\n\tPoint r = projection(s1, s2, p);\n\tif (isIntersectSP(s1, s2, r)) return (abs(r - p));\n\treturn (min(abs(s1 - p), abs(s2 - p)));\n}\ndouble distanceSS(Point s1, Point s2, Point t1, Point t2){\n\tif (isIntersectSS(s1, s2, t1, t2)) return (0);\n\treturn (min(min(distanceSP(s1, s2, t1), distanceSP(s1, s2, t2)),\n\t\t\tmin(distanceSP(t1, t2, s1), distanceSP(t1, t2, s2))));\n}\nPoint interPointLL(Point a1, Point a2, Point b1, Point b2)\n{\n\tdouble d = cross(a2 - a1, b2 - b1);\n\tif (abs(d) < EPS) throw \"Segment is Paralell!\";\n\tPoint a = a2 - a1, b = b2 - b1;\n    double t = cross(b, b1 - a1) / cross(b, a);\n    return (a1 + a * t);\n}\nvector<Point> interPointCC(Point c1, double r1, Point c2, double r2)\n{\n\tvector<Point> res;\n\tif (abs(c1 - c2) < EPS) return (vector<Point>()); // 交点が絶対にない\n\tdouble d = abs(c1 - c2);\n\tdouble rc = (d * d + r1 * r1 - r2 * r2) / (2 * d);\n\tdouble rs = sqrt(r1 * r1 - rc * rc);\n\tPoint diff = (c2 - c1) / d;\n\tres.push_back(Point(c1 + diff * Point(rc, rs)));\n\tres.push_back(Point(c1 + diff * Point(rc, -rs)));\n\treturn (res);\n}\nvector<Point> crosspointCL(Point a, double ra, Point b1, Point b2)\n{\n\tvector<Point> res;\n\tdouble dist = distanceLP(b1, b2, a);\n\tif (leq(dist, ra)){\n\t\tPoint s = projection(b1, b2, a);\n\t\tdist = sqrt(ra * ra - dist * dist);\n\t\tPoint t = (b2 - b1) / abs(b2 - b1);\n\t\tres.push_back(s + t * dist);\n\t\tres.push_back(s - t * dist);\n\t}\n\treturn (res);\n}\n\nPoint unitVector(Vector t)\n{\n    double u = abs(t);\n    return (Point(t.x / u , t.y / u));\n}\n\nPoint normalVector(Point p, Point a, Point b)\n{\n    Point v = unitVector(b - a);\n    v = cross(v, p - a) > 0 ? Point(v.y, -v.x) : Point(-v.y, v.x);\n    return v * distanceLP(p, a, b);\n}\n  \ndouble getCos(Vector a, Vector b)\n{\n    return (dot(a, b) / (abs(a) * abs(b)));\n}\n  \ndouble getSin(Vector a, Vector b)\n{\n    double t = getCos(a, b);\n    return (sqrt(1.0 - t * t));\n}\n  \ndouble getArg(Vector v)\n{\n    return (atan2(v.y, v.x));\n}\n\nPoint rotate(Point t, Point p, double r)\n{\n    double ta = cos(r) * (t.x - p.x) - sin(r) * (t.y - p.y) + p.x;\n    double tb = sin(r) * (t.x - p.x) + cos(r) * (t.y - p.y) + p.y;\n    return (Point(ta, tb));\n}\n\nint main()\n{\n\tint N, M;\n\t\n\twhile (scanf(\"%d %d\", &N, &M) && N){\n\t\tvector<Point> P(N);\n\t\tvector<int> to[128];\n\t\tbool exist[128][128] = {0};\n\t\t\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tscanf(\"%lf %lf\", &P[i].x, &P[i].y);\n\t\t\tP[i].id = i;\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < M; i++){\n\t\t\tint x, y;\n\t\t\tscanf(\"%d %d\", &x, &y);\n\t\t\tto[--x].push_back(--y);\n\t\t\tto[y].push_back(x);\n\t\t\texist[x][y] = exist[y][x] = 1;\n\t\t}\n\t\t\n\t\tPolygon Q = P;\n\t\tQ = conhel(Q);\n\t\t\n\t\tvector<int> belong[128][128];\n\t\tfor (int i = 0; i < Q.size(); i++){\n\t\t\tint u = Q[i].id, v = Q[(i + 1) % Q.size()].id;\n\t\t\tbelong[u][v].push_back(0);\n\t\t\tbelong[v][u].push_back(0);\n\t\t}\n\t\tint k = 1;\n\t\tset<vector<int> > s;\n\t\t\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tfor (int j = 0; j < N; j++){\n\t\t\t\tif (P[j] < P[i] && exist[i][j] && belong[i][j].size() < 2){\n\t\t\t\t\tvector<int> v;\n\t\t\t\t\tv.push_back(i);\n\t\t\t\t\tv.push_back(j);\n\t\t\t\t\twhile (1){\n\t\t\t\t\t\tint nextP = -1;\n\t\t\t\t\t\tint vv = v[v.size() - 1], uu = v[v.size() - 2];\n\t\t\t\t\t\tfor (int l = 0; l < to[vv].size(); l++){\n\t\t\t\t\t\t\tif (to[vv][l] == vv || to[vv][l] == uu) continue;\n\t\t\t\t\t\t\tif (ccw(P[uu], P[vv], P[to[vv][l]]) < 0){\n\t\t\t\t\t\t\t\tif (nextP == -1 || getCos(P[uu] - P[vv], P[to[vv][l]] - P[vv]) > getCos(P[uu] - P[vv], P[nextP] - P[vv])) nextP = to[vv][l];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (nextP == i) break;\n\t\t\t\t\t\tv.push_back(nextP);\n\t\t\t\t\t}\n\t\t\t\t\tvector<int> ss = v;\n\t\t\t\t\tsort(ss.begin(), ss.end());\n\t\t\t\t\tif (s.find(ss) != s.end()) continue;\n\t\t\t\t\telse s.insert(ss);\n\t\t\t\t\tfor (int it = 0; it < v.size(); it++){\n\t\t\t\t\t\tint uu = v[it], vv = v[(it + 1) % v.size()];\n\t\t\t\t\t\tbelong[uu][vv].push_back(k);\n\t\t\t\t\t\tbelong[vv][uu].push_back(k);\n\t\t\t\t\t}\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int> G[1024];\n\t\t\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tfor (int j = i + 1; j < N; j++){\n\t\t\t\tif (belong[i][j].size()){\n\t\t\t\t\tassert(belong[i][j].size() == 2);\n\t\t\t\t\tint u = belong[i][j][0], v = belong[i][j][1];\n\t\t\t\t\tG[u].push_back(v);\n\t\t\t\t\tG[v].push_back(u);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tint done[1024];\n\t\tfill(done, done + 1024, -1);\n\t\tqueue<pair<int, int> > q;\n\t\t\n\t\tfor(q.push(make_pair(0, 0)); q.size(); q.pop()){\n\t\t\tpair<int, int> x = q.front();\n\t\t\tif (~done[x.first]) continue;\n\t\t\tdone[x.first] = x.second;\n\t\t\tans = max(ans, x.second);\n\t\t\t\n\t\t\tfor (int i = 0; i < G[x.first].size(); i++){\n\t\t\t\tq.push(make_pair(G[x.first][i], x.second + 1));\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <fstream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <functional>\n#include <ctime>\n#include <numeric>\n#include <unordered_set>\n#include <unordered_map>\n\nusing namespace std;\n\n#define fst first\n#define snd second\n#define all(c) ((c).begin()), ((c).end())\n#define TEST(x,a) { auto y=(x); if (sign(y-a)) { cout << \"line \" << __LINE__  << #x << \" = \" << y << \" != \" << a << endl; exit(-1); } }\n\nconst double EPS = 1e-8;\nint sign(double x) {\n  if (x < -EPS) return -1;\n  if (x > +EPS) return +1;\n  return 0;\n}\nstruct point {\n  typedef double T;\n  T x, y; \n  point &operator+=(point p) { x += p.x; y += p.y; return *this; }\n  point &operator-=(point p) { x -= p.x; y -= p.y; return *this; }\n  point &operator*=(T a)     { x *= a;   y *= a;   return *this; }\n  point &operator/=(T a)     { return *this *= (1.0/a); }\n  point operator-() const    { return {-x, -y}; }\n  bool operator<(point p) const { \n    int s = sign(x - p.x);\n    return s ? s < 0 : sign(y - p.y) < 0;\n  }\n};\nbool operator==(point p, point q) { return !(p < q) && !(q < p); }\npoint operator+(point p, point q) { return p += q; }\npoint operator-(point p, point q) { return p -= q; }\npoint operator*(point::T a, point p) { return p *= a; }\npoint operator*(point p, point::T a) { return p *= a; }\npoint operator/(point p, point::T a) { return p /= a; }\npoint::T dot(point p, point q) { return p.x*q.x+p.y*q.y; }\npoint::T cross(point p, point q) { return p.x*q.y-p.y*q.x; } // left turn > 0\npoint::T norm2(point p) { return dot(p,p); }\npoint orth(point p) { return {-p.y, p.x}; }\npoint::T norm(point p) { return sqrt(dot(p,p)); }\npoint::T arg(point p) { return atan2(p.y, p.x); }\n\nstruct line { point p, q; };\nbool operator==(line l, line m) {\n  return !sign(cross(l.p-l.q,m.p-m.q)) && !sign(cross(l.p-l.q,m.p-l.p));\n}\n\nstruct segment { point p, q; };\nbool operator==(segment l, line m) {\n  return (l.p==m.p && l.q==m.q) || (l.p==m.q && l.q==m.p); // do not consider the direction\n}\nstruct circle { point p; point::T r; };\nbool operator==(circle c, circle d) { return c.p == d.p && !sign(c.r - d.r); }\n\ntypedef vector<point> polygon;\n\nstruct polar_angle {\n  const point o;\n  const int s; // +1 for ccw, -1 for cw\n  polar_angle(point p = {0,0}, int s = +1) : o(p), s(s) { }\n  int quad(point p) const {\n    for (int i = 1; i <= 4; ++i, swap(p.x = -p.x, p.y))\n      if (p.x > 0 && p.y >= 0) return i;\n    return 0;\n  }\n  bool operator()(point p, point q) const {\n    p = p - o; q = q - o;\n    if (quad(p) != quad(q)) return s*quad(p) < s*quad(q);\n    if (cross(p, q)) return s*cross(p, q) > 0;\n    return norm2(p) < norm2(q); // closer first\n  }\n};\n\nvector<point> intersect(segment s, segment t) {\n  auto a = cross(s.q - s.p, t.q - t.p);\n  auto b = cross(t.p - s.p, t.q - t.p); \n  auto c = cross(s.q - s.p, s.p - t.p);\n  if (a < 0) { a = -a; b = -b; c = -c; }\n  if (sign(b) < 0 || sign(a-b) < 0 ||\n      sign(c) < 0 || sign(a-c) < 0) return {};      // disjoint\n  if (sign(a) != 0) return {s.p + b/a*(s.q - s.p)}; // properly crossing\n  vector<point> ps;                                 // same line\n  auto insert_if_possible = [&](point p) {\n    for (auto q: ps) if (sign(dot(p-q, p-q)) == 0) return;\n    ps.push_back(p);\n  };\n  if (sign(dot(s.p-t.p, s.q-t.p)) <= 0) insert_if_possible(t.p);\n  if (sign(dot(s.p-t.q, s.q-t.q)) <= 0) insert_if_possible(t.q);\n  if (sign(dot(t.p-s.p, t.q-s.p)) <= 0) insert_if_possible(s.p);\n  if (sign(dot(t.p-s.q, t.q-s.q)) <= 0) insert_if_possible(s.q);\n  return ps;\n}\n\nstruct arrangement {\n  struct edge {\n    int src, dst;\n    point::T weight;\n    size_t id, rev;\n  };\n  int n;\n  vector<point> ps; // ps[id[p]] = p, id[ps[k]] = k\n  map<point,int> id; \n  vector<vector<edge>> adj;\n\n  arrangement(vector<segment> ss) : n(0) {\n    vector<vector<pair<point::T, int>>> group(ss.size());\n    auto append = [&](int i, point p) {\n      if (!id.count(p)) { id[p] = n++; ps.push_back(p); }\n      group[i].push_back({norm(ss[i].p - p), id[p]});\n    };\n    for (int i = 0; i < ss.size(); ++i) {\n      append(i, ss[i].p); append(i, ss[i].q);\n      for (int j = 0; j < i; ++j) {\n        for (point p: intersect(ss[i], ss[j])) {\n          append(i, p); append(j, p);\n        }\n      }\n    }\n    adj.resize(n);\n    for (auto &vs: group) {\n      sort(all(vs));\n      for (int i = 0; i+1 < vs.size(); ++i) {\n        auto u = vs[i].snd, v = vs[i+1].snd;\n        if (u == v) continue;\n        auto len = vs[i+1].fst - vs[i].fst;\n        adj[u].push_back({u, v, len});\n        adj[v].push_back({v, u, len});\n      }\n    }\n    // remove duplicates and orient edges\n    vector<unordered_map<int, int>> idx(n);\n    for (int u = 0; u < n; ++u) {\n      auto eq = [&](edge e, edge f) { return e.dst == f.dst; };\n      auto lt = [&](edge e, edge f) { return e.dst <  f.dst; };\n      sort(all(adj[u]), lt);\n      adj[u].erase(unique(all(adj[u]), eq), adj[u].end());\n      sort(all(adj[u]), [&](edge e, edge f) {\n        return arg(ps[e.dst] - ps[e.src]) > arg(ps[f.dst] - ps[f.src]);\n      });\n      for (int i = 0; i < adj[u].size(); ++i) {\n        adj[u][i].id = i;\n        int v = adj[u][i].dst;\n        idx[u][v] = i;\n        if (idx[v].count(u)) {\n          int j = idx[v][u];\n          adj[u][i].rev = j;\n          adj[v][j].rev = i;\n        }\n      }\n    }\n  }\n  edge twin(edge e) const { return adj[e.dst][e.rev]; }\n  edge next(edge e) const {\n    int j = adj[e.dst][e.rev].id + 1;\n    if (j >= adj[e.dst].size()) j = 0;\n    return adj[e.dst][j];\n  }\n};\n\nint main() {\n  for (int c, w; ~scanf(\"%d %d\", &c, &w) && c; ) {\n    vector<point> ps(c);\n    for (int i = 0; i < c; ++i) {\n      scanf(\"%lf %lf\", &ps[i].x, &ps[i].y);\n    }\n    vector<segment> ss;\n    for (int i = 0; i < w; ++i) {\n      int u, v; scanf(\"%d %d\", &u, &v);\n      ss.push_back({ps[u-1], ps[v-1]});\n    }\n    arrangement arr(ss);\n\n    int s = 0;\n    for (int i = 1; i < arr.n; ++i) \n      if (arr.ps[s] < arr.ps[i]) s = i;\n    typedef arrangement::edge edge;\n    edge e = arr.adj[s][0]; // outer-face edge\n\n    vector<unordered_map<int,int>> step(arr.n);\n    queue<edge> que;\n    auto proceed = [&](edge s, int value) {\n      if (step[s.src].count(s.dst)) return;\n      edge e = s;\n      do {\n        step[e.src][e.dst] = value;\n        que.push(arr.twin(e));\n        e = arr.next(e);\n      } while (e.src != s.src || e.dst != s.dst);\n    };\n    proceed(e, 0);\n    int ans = 0;\n    while (!que.empty()) {\n      edge e = que.front(); que.pop();\n      ans = step[e.dst][e.src];\n      proceed(e, ans + 1);\n    }\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#include <climits>\n\nusing namespace std;\n\ntypedef long long lint;\n\n//定数\nconst double EPS = 1e-10;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\nconst int INF = 1001001001;\nconst lint INFLL = 1001001001001001001ll;\n\n//初期化関連\n#define zclear(a) memset((a), 0 ,sizeof(a))\n#define mclear(a) memset((a), -1, sizeof(a))\n\n//デバッグ出力\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nbool eq(double a, double b) //a == b\n{\n    return (fabs(a - b) <= EPS);\n}\n\nbool neq(double a, double b) //a == b\n{\n    return (!eq(a, b));\n}\n  \nbool lt(double a, double b) //a < b\n{\n    return (a - b < -EPS);\n}\n  \nbool leq(double a, double b) //a <= b\n{\n    return (lt(a, b) || eq(a, b));\n}\n  \nbool gt(double a, double b) //a > b\n{\n    return (a - b > +EPS);\n}\n  \nbool geq(double a, double b) //a >= b\n{\n    return (gt(a, b) || eq(a, b));\n}\n\nclass Point{\npublic:\n\tdouble x, y;\n\tint id;\n\tPoint(double x = 0, double y = 0): x(x), y(y){}\n\tPoint operator + (Point p){return Point(x + p.x, y + p.y);}\n\tPoint operator - (Point p){return Point(x - p.x, y - p.y);}\n\tPoint operator * (double a){return Point(x * a, y * a);}\n\tPoint operator / (double a){return Point(x / a, y / a);}\n\tPoint operator * (const Point &a){\n\t\treturn Point(x * a.x - y * a.y, x * a.y + y * a.x);\n\t}\n\tbool operator < (const Point &p) const {\n\t\treturn (x != p.x ? x < p.x : y < p.y);\n\t}\n\tbool operator == (const Point &p) const {\n\t\treturn (fabs(x - p.x) < EPS && fabs(y - p.y) < EPS);\n\t}\n};\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\ndouble norm(Vector a){return (a.x * a.x + a.y * a.y);}\ndouble abs(Vector a){return (sqrt(norm(a)));}\ndouble abs(Vector a, Vector b){return (sqrt(norm(a - b)));}\ndouble dot(Vector a, Vector b){return (a.x * b.x + a.y * b.y);}\ndouble cross(Vector a, Vector b){return (a.x * b.y - a.y * b.x);}\ndouble atan(Vector a){return atan2(a.y, a.x);}\nbool sortX(Point a, Point b){return (a.x != b.x ? lt(a.x, b.x) : lt(a.y, b.y));}\nbool sortY(Point a, Point b){return (a.y != b.y ? lt(a.y, b.y) : lt(a.x, b.x));}\nPoint p;\nbool sortT(Point a, Point b){return (gt(cross(a - p, b - p), 0));}\n\nint ccw(Point p0, Point p1, Point p2)\n{\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > EPS) return (+1); //p0, p1, p2 が反時計周り\n\tif (cross(a, b) < -EPS) return (-1);//p0, p1, p2 が時計回り\n\tif (dot(a, b) < -EPS) return (+2); //p2--p0--p1 の順で一直線上\n\tif (norm(a) < norm(b)) return (-2); //p0--p1--p2 の順で一直線上\n\treturn (0); //p0--p2--p1 の順で一直線上\n}\n\nPolygon normalize(Polygon &v)\n{\n    int pt = 0;\n    for (int i = 1; i < v.size(); i++){\n        if (v[pt].y > v[i].y || (v[pt].y == v[i].y && v[pt].x > v[i].x)){\n            pt = i;\n        }\n    }\n    swap(v[pt], v[0]);\n    p = v[0];\n    sort(v.begin() + 1, v.end(), sortT);\n    return (v);\n}\n\nPolygon conhel(Polygon& ps)\n{\n    sort(ps.begin(), ps.end());\n    int k = 0, n = (int)ps.size();\n    Polygon qs(n * 2);\n      \n    for (int i = 0; i < n; i++){\n      while (k > 1 && cross(qs[k - 1] - qs[k - 2], ps[i] - qs[k - 1]) < -EPS) k--;\n      qs[k++] = ps[i];\n    }\n  \n    for (int i = n - 2, t = k; i >= 0; i--){\n      while (k > t && cross(qs[k - 1] - qs[k - 2], ps[i] - qs[k - 1]) < -EPS) k--;\n      qs[k++] = ps[i];\n    }\n  \n    qs.resize(k - 1);\n    return (qs);\n}\n\ndouble getArea(Polygon t){\n    double ans = 0.0;\n\tt = normalize(t);\n    for (unsigned int i = 0; i < t.size(); i++)\n        ans += cross(t[i] , t[(i + 1) % t.size()]);\n    return (fabs(ans) / 2);\n}\n\nbool isIntersectLL(Point p1, Point p2, Point p3, Point p4)\n{// 同一直線の場合は交差していると判定する.\n\treturn (abs(cross(p2 - p1, p4 - p3)) > EPS || // 傾きが異なる\n\t\tabs(cross(p2 - p1, p4 - p3)) < EPS); // 同じ直線である\n}\nbool isIntersectLS(Point p1, Point p2, Point p3, Point p4)\n{// 同一直線上にある場合も交差と判定\n\treturn (cross(p2 - p1, p3 - p1) * cross(p2 - p1, p4 - p1) < EPS);\n}\nbool isIntersectLP(Point p1, Point p2, Point p)\n{\n\treturn (neq(abs(ccw(p1, p2, p)), 1));\n}\nbool isIntersectSS(Point p1, Point p2, Point p3, Point p4)\n{\n    return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n             ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool isIntersectSP(Point p1, Point p2, Point p)\n{\n\treturn (eq(ccw(p1, p2, p), 0));\n}\nbool isInsideCP(Point c, double r, Point p)\n{\n\treturn (leq(abs(c - p), r));\n}\nbool isInsideCC(Point c1, double r1, Point c2, double r2)\n{\n\treturn (leq(abs(c1 - c2), r1 + r2) && geq(abs(c1 - c2), abs(r1 - r2)));\n}\nbool isInsidePolyP(Polygon gon, Point p)\n{\n    for (int i = 0; i < gon.size(); i++){\n        if (ccw(gon[i], gon[(i + 1) % gon.size()], p) == -1) return (false);\n    }\n    return (true);\n}\n\nPoint projection(Point p1, Point p2, Point p3) //直線p1p2 上への写像\n{\n\tdouble t = dot(p3 - p1, p2 - p1) / norm(p2 - p1);\n\treturn (p1 + (p2 - p1) * t);\n}\nPoint reflection(Point p1, Point p2, Point p3) //直線p1p2 上への反射\n{\n\treturn (p3 + (projection(p1, p2, p3) - p) * 2);\n}\ndouble distanceLP(Point p1, Point p2, Point p)\n{\n\treturn (abs(p - projection(p1, p2, p)));\n}\ndouble distanceLL(Point l1, Point l2, Point m1, Point m2)\n{\n\treturn (isIntersectLL(l1, l2, m1, m2) ? 0 : distanceLP(l1, l2, m1));\n}\ndouble distanceLS(Point l1, Point l2, Point s1, Point s2)\n{\n    if (isIntersectLS(l1, l2, s1, s2)) return (0);\n\treturn (min(distanceLP(l1, l2, s1), distanceLP(l1, l2, s2)));\n}\ndouble distanceSP(Point s1, Point s2, Point p)\n{\n\tPoint r = projection(s1, s2, p);\n\tif (isIntersectSP(s1, s2, r)) return (abs(r - p));\n\treturn (min(abs(s1 - p), abs(s2 - p)));\n}\ndouble distanceSS(Point s1, Point s2, Point t1, Point t2){\n\tif (isIntersectSS(s1, s2, t1, t2)) return (0);\n\treturn (min(min(distanceSP(s1, s2, t1), distanceSP(s1, s2, t2)),\n\t\t\tmin(distanceSP(t1, t2, s1), distanceSP(t1, t2, s2))));\n}\nPoint interPointLL(Point a1, Point a2, Point b1, Point b2)\n{\n\tdouble d = cross(a2 - a1, b2 - b1);\n\tif (abs(d) < EPS) throw \"Segment is Paralell!\";\n\tPoint a = a2 - a1, b = b2 - b1;\n    double t = cross(b, b1 - a1) / cross(b, a);\n    return (a1 + a * t);\n}\nvector<Point> interPointCC(Point c1, double r1, Point c2, double r2)\n{\n\tvector<Point> res;\n\tif (abs(c1 - c2) < EPS) return (vector<Point>()); // 交点が絶対にない\n\tdouble d = abs(c1 - c2);\n\tdouble rc = (d * d + r1 * r1 - r2 * r2) / (2 * d);\n\tdouble rs = sqrt(r1 * r1 - rc * rc);\n\tPoint diff = (c2 - c1) / d;\n\tres.push_back(Point(c1 + diff * Point(rc, rs)));\n\tres.push_back(Point(c1 + diff * Point(rc, -rs)));\n\treturn (res);\n}\nvector<Point> crosspointCL(Point a, double ra, Point b1, Point b2)\n{\n\tvector<Point> res;\n\tdouble dist = distanceLP(b1, b2, a);\n\tif (leq(dist, ra)){\n\t\tPoint s = projection(b1, b2, a);\n\t\tdist = sqrt(ra * ra - dist * dist);\n\t\tPoint t = (b2 - b1) / abs(b2 - b1);\n\t\tres.push_back(s + t * dist);\n\t\tres.push_back(s - t * dist);\n\t}\n\treturn (res);\n}\n\nPoint unitVector(Vector t)\n{\n    double u = abs(t);\n    return (Point(t.x / u , t.y / u));\n}\n\nPoint normalVector(Point p, Point a, Point b)\n{\n    Point v = unitVector(b - a);\n    v = cross(v, p - a) > 0 ? Point(v.y, -v.x) : Point(-v.y, v.x);\n    return v * distanceLP(p, a, b);\n}\n  \ndouble getCos(Vector a, Vector b)\n{\n    return (dot(a, b) / (abs(a) * abs(b)));\n}\n  \ndouble getSin(Vector a, Vector b)\n{\n    double t = getCos(a, b);\n    return (sqrt(1.0 - t * t));\n}\n  \ndouble getArg(Vector v)\n{\n    return (atan2(v.y, v.x));\n}\n\nPoint rotate(Point t, Point p, double r)\n{\n    double ta = cos(r) * (t.x - p.x) - sin(r) * (t.y - p.y) + p.x;\n    double tb = sin(r) * (t.x - p.x) + cos(r) * (t.y - p.y) + p.y;\n    return (Point(ta, tb));\n}\n\nint main()\n{\n\tint N, M;\n\t\n\twhile (scanf(\"%d %d\", &N, &M) && N){\n\t\tvector<Point> P(N);\n\t\tvector<int> to[128];\n\t\tbool exist[128][128] = {0};\n\t\t\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tscanf(\"%lf %lf\", &P[i].x, &P[i].y);\n\t\t\tP[i].id = i;\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < M; i++){\n\t\t\tint x, y;\n\t\t\tscanf(\"%d %d\", &x, &y);\n\t\t\tto[--x].push_back(--y);\n\t\t\tto[y].push_back(x);\n\t\t\texist[x][y] = exist[y][x] = 1;\n\t\t}\n\t\t\n\t\tPolygon Q = P;\n\t\tQ = conhel(Q);\n\t\t\n\t\tvector<int> belong[128][128];\n\t\tfor (int i = 0; i < Q.size(); i++){\n\t\t\tint u = Q[i].id, v = Q[(i + 1) % Q.size()].id;\n\t\t\tbelong[u][v].push_back(0);\n\t\t\tbelong[v][u].push_back(0);\n\t\t}\n\t\tint k = 1;\n\t\tset<vector<int> > s;\n\t\t\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tfor (int j = 0; j < N; j++){\n\t\t\t\tif (P[j] < P[i] && exist[i][j] && belong[i][j].size() < 2){\n\t\t\t\t\tvector<int> v;\n\t\t\t\t\tv.push_back(i);\n\t\t\t\t\tv.push_back(j);\n\t\t\t\t\twhile (1){\n\t\t\t\t\t\tint nextP = -1;\n\t\t\t\t\t\tint vv = v[v.size() - 1], uu = v[v.size() - 2];\n\t\t\t\t\t\tfor (int l = 0; l < to[vv].size(); l++){\n\t\t\t\t\t\t\tif (to[vv][l] == vv || to[vv][l] == uu) continue;\n\t\t\t\t\t\t\tif (ccw(P[uu], P[vv], P[to[vv][l]]) < 0){\n\t\t\t\t\t\t\t\tif (nextP == -1 || getCos(P[uu] - P[vv], P[to[vv][l]] - P[vv]) > getCos(P[uu] - P[vv], P[nextP] - P[vv])) nextP = to[vv][l];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tassert(nextP != -1);\n\t\t\t\t\t\tif (nextP == i) break;\n\t\t\t\t\t\tv.push_back(nextP);\n\t\t\t\t\t}\n\t\t\t\t\tvector<int> ss = v;\n\t\t\t\t\tsort(ss.begin(), ss.end());\n\t\t\t\t\tif (s.find(ss) != s.end()) continue;\n\t\t\t\t\telse s.insert(ss);\n\t\t\t\t\tfor (int it = 0; it < v.size(); it++){\n\t\t\t\t\t\tint uu = v[it], vv = v[(it + 1) % v.size()];\n\t\t\t\t\t\tbelong[uu][vv].push_back(k);\n\t\t\t\t\t\tbelong[vv][uu].push_back(k);\n\t\t\t\t\t}\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int> G[1024];\n\t\t\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tfor (int j = i + 1; j < N; j++){\n\t\t\t\tif (belong[i][j].size()){\n\t\t\t\t\tint u = belong[i][j][0], v = belong[i][j][1];\n\t\t\t\t\tG[u].push_back(v);\n\t\t\t\t\tG[v].push_back(u);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tint done[1024];\n\t\tfill(done, done + 1024, -1);\n\t\tqueue<pair<int, int> > q;\n\t\t\n\t\tfor(q.push(make_pair(0, 0)); q.size(); q.pop()){\n\t\t\tpair<int, int> x = q.front();\n\t\t\tif (~done[x.first]) continue;\n\t\t\tdone[x.first] = x.second;\n\t\t\tans = max(ans, x.second);\n\t\t\t\n\t\t\tfor (int i = 0; i < G[x.first].size(); i++){\n\t\t\t\tq.push(make_pair(G[x.first][i], x.second + 1));\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <set>\n#include <cstdlib>\nusing namespace std;\n\nconst double EPS = 1e-10;\nconst double INF = 1e12;\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n#define X real()\n#define Y imag()\n\ntypedef complex<double> P;\ntypedef vector<P> VP;\nstruct L : VP{\n    L(const P& a, const P& b){ resize(2); at(0)=a; at(1)=b; }\n    L(){ resize(2); }\n};\n\nnamespace std{\n    bool operator < (const P &a, const P &b){\n        return !EQ(a.X, b.X)? a.X<b.X : a.Y<b.Y;\n    }\n    bool operator == (const P &a, const P &b){\n        return abs(a-b) < EPS;\n    }\n}\n\ndouble dot(P a, P b){\n    return (conj(a)*b).X;\n}\ndouble cross(P a, P b){\n    return (conj(a)*b).Y;\n}\nint ccw(P a, P b, P c){\n    b -= a;\n    c -= a;\n    if(cross(b,c) > EPS) return +1; //ccw\n    if(cross(b,c) <-EPS) return -1; //cw\n    if(dot(b,c) < EPS) return +2; //c-a-b\n    if(norm(b) < norm(c)) return -2; //a-b-c\n    return 0; //a-c-b\n}\n\nP projection(const L& l, const P& p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1]-l[0], m[1]-m[0]);\n  double B = cross(l[1]-l[0], l[1]-m[0]);\n  return m[0] + B /A *(m[1]-m[0]);\n}\n\ndouble getangle(const P &p, const P &a, const P &b){ //clockwise\n    P proj = projection(L(p,a), b);\n    int minus = (dot(a-p, b-p)>=0)? 1 :-1;\n    if(ccw(p,a,b)!=1){\n        return atan2(abs(b-proj), minus*abs(p-proj));\n    }else{\n        return 2*M_PI - atan2(abs(b-proj), minus*abs(p-proj));\n    }\n}\ndouble getarea(const VP &p) {\n\tdouble ret = 0;\n\tfor (int i=0; i<(int)p.size(); i++){ \n\t\tret += cross(p[i], p[(i+1)%p.size()]);\n\t}\n\treturn ret*0.5;\n}\n\nint leftmostpoint(int &pidx, int &cidx, vector<int> &vec, VP &plist){\n\tP prev = plist[pidx];\n\tP curr = plist[cidx];\n\tint nextidx = -1;\n\tdouble minangle = INF;\n\tfor(int i=0; i<(int)vec.size(); i++){\n\t\tif(vec[i]==pidx) continue;\n\t\tdouble angle = getangle(curr, prev, plist[vec[i]]);\n\t\tif(angle < minangle){\n\t\t\tminangle = angle;\n\t\t\tnextidx = i;\n\t\t}\n\t}\n\tpidx = cidx;\n\tcidx = vec[nextidx];\n\treturn nextidx;\n}\n\nvector<vector<int> > makeDualGraph(vector<vector<int> > &adj, VP &plist, int &out){\n    map<pair<int,int>, int> edgelist;\n    vector<vector<int> > poly;\n    vector<vector<bool> > used(adj.size());\n    for(int i=0; i<(int)adj.size(); i++){\n        used[i] = vector<bool>(adj[i].size(), false);\n    }\n    \n    int numarea=0;\n    for(int i=0; i<(int)adj.size(); i++){\n    \tfor(int j=0; j<(int)adj[i].size(); j++){\n    \t\tif(used[i][j]) continue;\n    \t\tused[i][j] = true;\n    \t\tnumarea++;\n    \t\tvector<int> border;\n    \t\tVP vlist;\n    \t\tborder.push_back(i);\n    \t\tvlist.push_back(plist[i]);\n    \t\tint prev = i;\n    \t\tint curr = adj[i][j];\n    \t\twhile(curr!=i){\n    \t\t\tborder.push_back(curr);\n    \t\t\tvlist.push_back(plist[curr]);\n    \t\t\tint idx = leftmostpoint(prev, curr, adj[curr], plist);\n    \t\t\tused[prev][idx] = true;\n    \t\t}\n    \t\tpoly.push_back(border);\n    \t\tif(getarea(vlist) < 0) out = numarea-1;\n    \t}\n    }\n    \n    vector<vector<int> > dual(numarea);\n    for(int i=0; i<numarea; i++){\n    \tfor(int j=0; j<(int)poly[i].size(); j++){\n    \t\tint a = poly[i][j];\n    \t\tint b = poly[i][(j+1)%(int)poly[i].size()];\n    \t\tpair<int,int> key = make_pair(min(a,b), max(a,b));\n    \t\tif(edgelist.count(key) == 0){\n    \t\t\tedgelist[key] = i;\n    \t\t}else{\n    \t\t\tdual[i].push_back(edgelist[key]);\n    \t\t\tdual[edgelist[key]].push_back(i);\n    \t\t}\n    \t}\n    }\n    \n    for(int i=0; i<(int)dual.size(); i++){\n        sort(dual[i].begin(), dual[i].end());\n        dual[i].erase(unique(dual[i].begin(), dual[i].end()), dual[i].end());\n    }\n    return dual;\n}\n\nint main(){\n\twhile(1){\n\t\tint c,w;\n\t\tcin >> c >> w;\n\t\tif(c==0) break;\n\t\t\n\t\tVP bar(c);\n\t\tfor(int i=0; i<c; i++){\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\tbar[i] = P(x,y);\n\t\t}\n\t\t\n\t\tvector<vector<int> > adj(c);\n\t\tfor(int i=0; i<w; i++){\n\t\t\tint s,t;\n\t\t\tcin >> s >> t;\n\t\t\ts--; t--;\n\t\t\tadj[s].push_back(t);\n\t\t\tadj[t].push_back(s);\n\t\t}\n\t\tint out;\n\t\tvector<vector<int> > dual = makeDualGraph(adj, bar, out);\n\t\t\n\t\tint numarea = dual.size();\n\t\tset<int> reach;\n\t\treach.insert(out);\n\t\tint ans = 0;\n\t\twhile(1){\n\t\t\tif((int)reach.size() == numarea) break;\n\t\t\tset<int> newreach;\n\t\t\tfor(set<int>::iterator itr=reach.begin(); itr!=reach.end(); itr++){\n\t\t\t\tnewreach.insert(*itr);\n\t\t\t\tfor(int i=0; i<(int)dual[*itr].size(); i++){\n\t\t\t\t\tnewreach.insert(dual[*itr][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treach = newreach;\n\t\t\tans++;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <bitset>\n#include <cmath>\n#include <set>\n\n#define TIMES(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef bitset<22> Spec;\nconst double EPS = 1e-9;\n\nstruct Polygon {\n    Spec spec;\n    int id;\n\n    bool operator <(const Polygon &p) const {\n        return spec.to_string() < p.spec.to_string();\n    }\n\n    bool operator ==(const Polygon &p) const {\n        return spec == p.spec;\n    }\n};\n\nint cmp(double a, double b) {\n    const double diff = a-b;\n    if(fabs(diff) < EPS) return 0;\n    return diff < 0 ? -1 : 1;\n}\n\ndouble dot(const P &a, const P &b) {\n    return a.real()*b.real() + a.imag()*b.imag();\n}\n\ndouble cross(const P &a, const P &b) {\n    return a.real()*b.imag() - a.imag()*b.real();\n}\n\nPolygon get_polygon(int a, int b, const vector<P> &poles, const vector<vector<int>> &graph, const vector<vector<int>> &wall_id) {\n    Polygon polygon;\n    polygon.spec[wall_id[a][b]] = true;\n\n    const int start1 = b;\n    const int start2 = a;\n    //cout << b+1 << ' ' << a+1;\n    while(true) {\n        P prev = poles[a];\n        P prev_prev = poles[b];\n        const P vec = -(prev - prev_prev);\n        const double len = abs(vec);\n        int candidate = -1;\n        int cross_sgn = -1;\n        double dot_val = -2;\n        for(int i : graph[a]) {\n            if(i == b) continue;\n            const P vec2 = poles[i] - prev;\n            const double len2 = abs(vec2);\n            int sgn = cmp(cross(vec, vec2), 0);\n            double dv = dot(vec, vec2) / len / len2;\n            //cout << \": \" << i+1 << ' ' << sgn << ' ' << dv << endl;\n            if(sgn > cross_sgn \n                || (sgn == cross_sgn && cmp(dv, dot_val) > 0))\n            {\n                candidate = i;\n                cross_sgn = sgn;\n                dot_val = dv;\n            }\n        }\n        if(candidate == -1) break;\n        const int wid = wall_id[a][candidate];\n        //cout << ',' << candidate+1;\n        if(polygon.spec[wid]) {\n            if(a != start1 || candidate != start2) polygon = Polygon();\n            break;\n        }\n        polygon.spec[wid] = true;\n        b = a; a = candidate;\n    }\n    //cout << endl;\n    return polygon;\n}\n\nint solve_inner(const set<Polygon> &polygons) {\n    Spec outer_wall;\n    outer_wall.flip();\n    for(const Polygon &p1 : polygons) {\n        for(const Polygon &p2 : polygons) {\n            if(p1.id == p2.id) continue;\n            Spec s = p1.spec & p2.spec;\n            if(s.none()) continue;\n            outer_wall &= s.flip();\n        }\n    }\n    Spec seen = outer_wall;\n    TIMES(i, 300) {\n        Spec next = seen;\n        for(const Polygon &p : polygons) {\n            if((seen & p.spec).any()) {\n                next |= p.spec;\n            }\n        }\n        if(seen == next) return i+1;\n        seen = next;\n    }\n    return -1;\n}\n\nbool solve() {\n    int C, W;\n    cin >> C >> W;\n    if(!C && !W) return false;\n\n    vector<P> poles;\n    vector<vector<int>> graph(C);\n    vector<vector<int>> wall_id(C, vector<int>(C, -1));\n    TIMES(_, C) {\n        double x, y;\n        cin >> x >> y;\n        poles.push_back(P(x, y));\n    }\n    TIMES(i, W) {\n        int s, t;\n        cin >> s >> t;\n        --s; --t;\n        graph[s].push_back(t);\n        graph[t].push_back(s);\n        wall_id[s][t] = wall_id[t][s] = i;\n    }\n\n    set<Polygon> polygons;\n    // for each wall and direction\n    TIMES(i, C) {\n        for(int j : graph[i]) {\n            Polygon poly = get_polygon(i, j, poles, graph, wall_id);\n            if(poly.spec.any()) {\n                poly.id = polygons.size();\n                polygons.insert(poly);\n            }\n        }\n    }\n    /*\n    cout << polygons.size() << endl;\n    for(const Polygon &p : polygons) {\n        cout << p.spec << endl;\n    }\n    */\n\n    cout << solve_inner(polygons) << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<int,pair<bool,double> > P2;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define min_3(a,b,c) min(a,min(b,c))\n#define max_3(a,b,c) max(a,max(b,c))\n#define mp1(a,b,c) P1(a,P(b,c))\n#define mp2(a,b,c) P2(a,pair<bool,double>(b,c))\n#define pque(a) priority_queue<a>\n#define rpque(a) priority_queue<a,vector<a>,greater<a>>\n\nconst int INF=1000000000;\nconst int dre_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dre_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\nconst int kaijou[10]={1,1,2,6,24,120,720,5040,40320,362880};\n\nbool com(P2 x,P2 y){\n\tif(x.sc.fr!=y.sc.fr)return x.sc.fr;\n\treturn x.sc.sc>=y.sc.sc;\n}\n\nint main(){\n\tint ppp=0;\n\twhile(1){\n\t\tppp++; if(ppp>=8)return 0;\n\t\tstatic int v,w;\n\t\tstatic int x[110],y[110];\n\t\tstatic int s,t;\n\t\t\n\t\tscanf(\"%d%d\",&v,&w); if(v==0&&w==0)break;\n\t\trep1(i,v)scanf(\"%d%d\",&x[i],&y[i]);\n\t\t\n\t\tstatic vector<P1> V_; V_.clear();\n\t\trep1(i,v){\n\t\t\tV_.pb(mp1(x[i],y[i],i));\n\t\t}\n\t\tsor(V_);\n\t\tstatic vector<P2> vec_[110];\n\t\trep1(i,v){\n\t\t\tvec_[i].clear();\n\t\t\tvec_[i].pb(mp2(0,false,-INF));\n\t\t\trep1(j,v){\n\t\t\t\tif(i==j)continue;\n\t\t\t\tif(x[i]<x[j]){\n\t\t\t\t\tvec_[i].pb(mp2(j,true,(double)(y[j]-y[i])/(x[j]-x[i])));\n\t\t\t\t}\n\t\t\t\telse if(x[i]>x[j]){\n\t\t\t\t\tvec_[i].pb(mp2(j,false,(double)(y[j]-y[i])/(x[j]-x[i])));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(y[j]>y[i])vec_[i].pb(mp2(j,true,(double)INF));\n\t\t\t\t\telse vec_[i].pb(mp2(j,true,(double)-INF));\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(vec_[i].begin(),vec_[i].end(),com);\n\t\t}\n\t\t\n\t\tstatic int e;\n\t\tstatic vector<int> V; V.clear();\n\t\tstatic bool edge[110][110];\n\t\tstatic vector<int> vec[110]; \n\t\t\n\t\te=w;\n\t\trep(i,v)V.pb(V_[i].sc.sc);\n\t\trep(i,110)rep(j,110)edge[i][j]=false;\n\t\trep(i,e){\n\t\t\tscanf(\"%d%d\",&s,&t);\n\t\t\tedge[s][t]=true;\n\t\t\tedge[t][s]=true;\n\t\t}\n\t\trep1(i,v){\n\t\t\tvec[i].clear();\n\t\t\trep(j,vec_[i].size()){\n\t\t\t\tvec[i].pb(vec_[i][j].fr);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ret=0;\n\t\twhile(e>0){\n\t\t\tret++;\n\t\t\t\n\t\t\tint a=-1;\n\t\t\trep(i,V.size()){\n\t\t\t\trep(j,105){\n\t\t\t\t\tif(edge[V[i]][j]){a=V[i]; break;}\n\t\t\t\t}\n\t\t\t\tif(a!=-1)break;\n\t\t\t}\n\t\t\t\n\t\t\tint b=0,c=a;\n\t\t\twhile(1){\n\t\t\t\tif(c==-1||vec[c].size()==0)break;\n\t\t\t\trep(i,vec[c].size()){\n\t\t\t\t\tif(vec[c][i]==b){\n\t\t\t\t\t\ti++; i%=vec[c].size();\n\t\t\t\t\t\twhile(!edge[c][vec[c][i]]){\n\t\t\t\t\t\t\ti++; i%=vec[c].size();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tedge[c][vec[c][i]]=false;\n\t\t\t\t\t\tedge[vec[c][i]][c]=false;\n\t\t\t\t\t\te--;\n\t\t\t\t\t\tb=c;\n\t\t\t\t\t\tc=vec[c][i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(c==a)break;\n\t\t\t}\n\t\t\t\n\t\t\tbool updata=true;\n\t\t\twhile(updata){\n\t\t\t\tupdata=false;\n\t\t\t\trep1(i,v){\n\t\t\t\t\tint cnt=0;\n\t\t\t\t\tint t=105;\n\t\t\t\t\trep1(j,v){\n\t\t\t\t\t\tif(edge[i][j]){cnt++; t=j;}\n\t\t\t\t\t}\n\t\t\t\t\tif(cnt==1){\n\t\t\t\t\t\tupdata=true;\n\t\t\t\t\t\tedge[i][t]=false;\n\t\t\t\t\t\tedge[t][i]=false;\n\t\t\t\t\t\te--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <bitset>\n#include <cmath>\n#include <algorithm>\n\n#define TIMES(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef bitset<600> Spec;\nconst double EPS = 1e-9;\nconst double PI = acos(-1);\n\ndouble normalize(double angle) {\n    if(angle < 0) return angle + 2*PI;\n    return angle;\n}\n\nint cmp(double a, double b) {\n    const double diff = a-b;\n    if(fabs(diff) < EPS) return 0;\n    return diff < 0 ? -1 : 1;\n}\n\ndouble dot(const P &a, const P &b) {\n    return a.real()*b.real() + a.imag()*b.imag();\n}\n\ndouble cross(const P &a, const P &b) {\n    return a.real()*b.imag() - a.imag()*b.real();\n}\n\nint root(int n, vector<int> &roots) {\n    if(roots[n] == n) return n;\n    return roots[n] = root(roots[n], roots);\n}\n\nbool unite(int a, int b, vector<int> &roots) {\n    const int ra = root(a, roots);\n    const int rb = root(b, roots);\n    if(ra == rb) return false;\n    roots[ra] = rb;\n    return true;\n}\n\nbool solve() {\n    int C, W;\n    cin >> C >> W;\n    if(!C && !W) return false;\n\n    vector<P> poles;\n    vector<vector<int>> graph(C);\n    vector<vector<int>> wall_id(C, vector<int>(C));\n    TIMES(_, C) {\n        double x, y;\n        cin >> x >> y;\n        poles.push_back(P(x, y));\n    }\n    TIMES(i, W) {\n        int s, t;\n        cin >> s >> t;\n        --s; --t;\n        graph[s].push_back(t);\n        graph[t].push_back(s);\n        wall_id[s][t] = i*2;\n        wall_id[t][s] = i*2+1;\n    }\n\n    vector<int> roots(W*2);\n    TIMES(i, W*2) {\n        roots[i] = i;\n    }\n    TIMES(i, C) {\n        const P &pi = poles[i];\n        for(int j : graph[i]) {\n            const P &pj = poles[j];\n            const P vec = pj - pi;\n            const double len = abs(vec);\n            int candidate = -1;\n            int sin_sgn = -2;\n            double cos_val = 2;\n            for(int k : graph[j]) {\n                if(k == i) continue;\n                const P vec2 = poles[k] - pj;\n                const int sgn = cmp(cross(vec2, vec), 0);\n                const double cv = dot(vec2, vec) / len / abs(vec2);\n                if(sgn > sin_sgn\n                    || (sgn == sin_sgn && cv < cos_val))\n                {\n                    candidate = k;\n                    sin_sgn = sgn;\n                    cos_val = cv;\n                }\n            }\n            if(candidate != -1) {\n                if(unite(wall_id[i][j], wall_id[j][candidate], roots)) {\n                    //cout << \"unitea \" << i << \" \" << j << \" \" << candidate << endl;\n                }\n            }\n        }\n    }\n    // Determine outside region\n    const int rightmost = distance(poles.begin(),\n            max_element(poles.begin(), poles.end(), [](const P &a, const P &b) {\n                return a.real() < b.real();\n                }));\n    const int rm_next = *max_element(\n            graph[rightmost].begin(), \n            graph[rightmost].end(),\n            [&poles, rightmost](int a, int b) {\n            const double arga = normalize(arg(poles[a] - poles[rightmost]));\n            const double argb = normalize(arg(poles[b] - poles[rightmost]));\n            return arga < argb;\n            });\n    int out_id = root(wall_id[rm_next][rightmost], roots);\n\n    Spec init;\n    vector<Spec> areas(W*2);\n    TIMES(i, W*2) {\n        const int area = root(i, roots);\n        areas[area][i/2] = true;\n        if(area == out_id) init[i/2] = true;\n        //cout << area << ' ';\n    }\n    //cout << endl;\n    Spec cur = init;\n    int turn = 1;\n    while(true) {\n        Spec next = cur;\n        for(const Spec &spec : areas) {\n            if((spec & cur).any()) {\n                next |= spec;\n            }\n        }\n        if(next == cur) break;\n        cur = next;\n        ++turn;\n    }\n    cout << turn << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <ctime>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <fstream>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <numeric>\n#include <cassert>\nusing namespace std;\n\ntypedef complex<double> P;\nconst double PI = acos(-1);\n\ndouble fx(double rd){\n\twhile( rd < -1e-9 )   rd += 2*PI;\n\twhile( rd >= 2*PI - 1e-9) rd -= 2*PI;\n\treturn rd;\n}\ndouble R(P a){\n\tdouble rd = atan2(a.imag(),a.real());\n\treturn fx(rd);\n}\n\nint C,W;\n\nint wsc[300] , wtc[300];\nP c[100];\nstruct NODE{\n\tint from,to,id;\n\tdouble rad;\n\tNODE(int from,int to,int id) : from(from) , to(to) , id(id) {\n\t\trad = R(c[to]-c[from]);\n\t}\n\tNODE(){}\n};\nbool operator < (const NODE &a,const NODE &b){\n\treturn a.rad < b.rad;\n}\nvector<NODE> geo[100];\nint done[100];\n\nint start;\nint get(int x,int prev,vector<int> &ad){\n\tif( x == start ) return 1;\n\tif( done[x] ) return 0;\n\telse done[x] = true;\n\t\n\tfor(int i = 0 ; i < geo[x].size() ; i++){\n\t\tint y = (i+1)%geo[x].size();\n\t\tif( geo[x][i].to == prev ){\t\t\t\n\t\t\tif( get(geo[x][y].to,x,ad) ){\n\t\t\t\t//ad.push_back(x);\n\t\t\t\tad.push_back(geo[x][y].id);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nnamespace std {bool operator < (const P& a, const P& b) {return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);} }\ndouble cross(const P& a, const P& b) {return imag(conj(a)*b);}\ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;\n\tif (cross(b, c) < 0)   return -1;\n\tif (dot(b, c) < 0) return +2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n// Totsuhou! Andrew's Monotone Chain //\nvector<P> convex_hull(vector<P> ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<P> ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);} };\nstatic const double EPS = 1e-9;\nbool intersectSP(const L &s, const P &p) {return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;}\n\ndouble intersect2SP(const L &s, const P &p) {\n\tcout << \"[\" << s[0] << \",\" << s[1] << \"]\" << \",\" << p << endl;\n\treturn abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]);\n}\n\n\nint main(){\n\twhile(cin >> C >> W && C){\n\t\tfor(int i = 0 ; i < 100 ; i++) geo[i].clear();\n\t\tfor(int i = 0 ; i < C ; i++)\n\t\t\tcin >> c[i].real() >> c[i].imag();\n\t\tfor(int i = 0 ; i < W ; i++){\n\t\t\tint s,t;\n\t\t\tcin >> s >> t;\n\t\t\ts--,t--;\n\t\t\tgeo[s].push_back(NODE(s,t,i));\n\t\t\tgeo[t].push_back(NODE(t,s,i));\n\t\t\twsc[i] = s;\n\t\t\twtc[i] = t;\n\t\t}\n\t\tfor(int i = 0 ; i < 100 ; i++) sort(geo[i].begin(),geo[i].end());\n\t\t\n\t\tvector< vector<int> > wallset;\n\t\tfor(int _ = 0 ; _ < 2 ; _++){\n\t\t\tfor(int i = 0 ; i < W ; i++){\n\t\t\t\tmemset(done,0,sizeof(done));\n\t\t\t\tstart = wsc[i];\n\t\t\t\tvector<int> a;\n\t\t\t\tif( get(wtc[i],wsc[i],a) ){\n\t\t\t\t\t//a.push_back(wsc[i]);\n\t\t\t\t\ta.push_back(i);\n\t\t\t\t\tsort(a.begin(),a.end());\n\t\t\t\t\twallset.push_back(a);\n\t\t\t\t}\n\t\t\t\tswap(wsc[i],wtc[i]);\n\t\t\t}\n\t\t}\n\t\tsort(wallset.begin(),wallset.end());\n\t\twallset.erase(unique(wallset.begin(),wallset.end()),wallset.end());\n\t\t\n\t\t\n\t\tint wf[301][301]={};\n\t\tfor(int i = 0 ; i < 301 ; i++)\n\t\t\tfor(int j = 0 ; j < 301 ; j++)\n\t\t\t\twf[i][j] = i==j?0:1e9;\n\t\tint N = wallset.size();\n\t\tvector<int> wall_share[300];\n\t\t\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\t//cout << \"[\" << i << \"]\" << endl;\n\t\t\tfor(int j = 0 ; j < wallset[i].size() ; j++){\n\t\t\t\twall_share[wallset[i][j]].push_back(i);\n\t\t\t//\tcout << c[wsc[wallset[i][j]]] << \"-\" << c[wtc[wallset[i][j]]] << \" \";\n\t\t\t}\n\t\t\t//cout << endl;\n\t\t}\n\t\tfor(int i = 0 ; i < W ; i++){\n\t\t\tfor(int j = 0 ; j <wall_share[i].size() ; j++){\n\t\t\t\tfor(int k = 0 ; k < wall_share[i].size() ; k++){\n\t\t\t\t\tif(j!=k)wf[wall_share[i][j]][wall_share[i][k]] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<P> p;\n\t\tfor(int i = 0 ; i < C ; i++) p.push_back(c[i]);\n\t\tp = convex_hull(p);\n\t\t//for(int i = 0 ; i < p.size() ; i++) cout << p[i] << \" \";\n\t\t//cout << endl;\n\t\tint soto = 0;\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\tint o = 1;\n\t\t\tfor(int j = 0 ; j < wallset[i].size() ; j++){\n\t\t\t\tint w = 0;\n\t\t\t\tfor(int k = 0 ; k < p.size() ; k++){\n\t\t\t\t\tif( intersectSP(L(p[k],p[(k+1)%p.size()]),c[wsc[wallset[i][j]]]) && intersectSP(L(p[k],p[(k+1)%p.size()]),c[wtc[wallset[i][j]]]) ){\n\t\t\t\t\t\t//cout << \"OK\" << endl;\n\t\t\t\t\t\tw = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!w){\n\t\t\t\t\to = 0;\n\t\t\t\t\t/*cout << \"----------\" << endl;\n\t\t\t\t\tcout << (intersectSP(L(P(2,0),P(8,0)),wsc[wall_share[i][j]]) ) << \" \" << (intersectSP(L(P(2,0),P(8,0)),wtc[wall_share[i][j]])) << endl;\n\t\t\t\t\tcout << (intersect2SP(L(P(2,0),P(8,0)),wsc[wall_share[i][j]]) ) << \" \" << (intersect2SP(L(P(2,0),P(8,0)),wtc[wall_share[i][j]])) << endl;\n\t\t\t\t\t\n\t\t\t\t\tcout << endl;\n\t\t\t\t\t*/\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(o) soto = i ;//, cout << soto << \"<\" << endl;\n\t\t}\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\tfor(int j = 0 ; j < N ; j++){\n\t\t\t\tfor(int k = 0 ; k < N ; k++){\n\t\t\t\t\twf[j][k] = min(wf[j][k],wf[j][i]+wf[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 1;\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\tans = max( ans , wf[i][soto] );\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <queue>\n#include <cstdio>\n#include <cassert>\n#include <algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst double EPS=1e-8;\nconst double PI=acos(-1);\n\nstruct point{\n\tdouble x,y;\n\tpoint():x(0),y(0){}\n\tpoint(double x,double y):x(x),y(y){}\n\tpoint &operator+=(const point &a){ x+=a.x; y+=a.y; return *this; }\n\tpoint &operator-=(const point &a){ x-=a.x; y-=a.y; return *this; }\n\tpoint &operator*=(double c){ x*=c; y*=c; return *this; }\n\tpoint &operator/=(double c){ x/=c; y/=c; return *this; }\n\tpoint operator+(const point &a)const{ return point(x+a.x,y+a.y); }\n\tpoint operator-(const point &a)const{ return point(x-a.x,y-a.y); }\n\tpoint operator/(double c)const{ return point(x/c,y/c); }\n\tpoint operator-()const{ return point(-x,-y); }\n\tbool operator< (const point &a)const{ return x+EPS<a.x || (abs(x-a.x)<EPS && y+EPS<a.y); }\n\tbool operator==(const point &a)const{ return abs(x-a.x)<EPS && abs(y-a.y)<EPS; }\n\tbool operator!=(const point &a)const{ return abs(x-a.x)>EPS || abs(y-a.y)>EPS; }\n};\n\ndouble cross(const point &a,const point &b){ return a.x*b.y-a.y*b.x; }\n\ndouble arg(const point &a){ double t=atan2(a.y,a.x); return t<0?t+2*PI:t; }\n\ntypedef vector<point> polygon;\n\nbool is_ccw(const polygon &F){\n\tint n=F.size();\n\tdouble A=0;\n\trep(i,n) A+=cross(F[i],F[(i+1)%n]);\n\treturn A>-EPS;\n}\n\n// trace the frame of a polygon\nvector<int> trace(const vector<int> *G,int u0,int i0){\n\tvector<int> F;\n\tint u=u0,i=i0;\n\tdo{\n\t\tF.push_back(u);\n\t\tint v=G[u][i];\n\t\tint k=G[v].size();\n\t\trep(j,k) if(G[v][j]==u) i=(j-1+k)%k;\n\t\tu=v;\n\t}while(u!=u0 || i!=i0);\n\treturn F;\n}\n\n// normalize the list of vertices\nvector<int> reg(vector<int> a){\n\tint k=min_element(a.begin(),a.end())-a.begin();\n\trep(i,k){\n\t\ta.push_back(a[0]);\n\t\ta.erase(a.begin());\n\t}\n\treturn a;\n}\n\nint main(){\n\tfor(int n,m;scanf(\"%d%d\",&n,&m),n;){\n\t\tpoint P[100];\n\t\trep(u,n) scanf(\"%lf%lf\",&P[u].x,&P[u].y);\n\n\t\tvector<int> G[100];\n\t\trep(i,m){\n\t\t\tint u,v; scanf(\"%d%d\",&u,&v); u--; v--;\n\t\t\tG[u].push_back(v);\n\t\t\tG[v].push_back(u);\n\t\t}\n\n\t\t// angle sort\n\t\trep(u,n){\n\t\t\tint k=G[u].size();\n\t\t\tpair<double,int> A[100];\n\t\t\trep(i,k){\n\t\t\t\tint v=G[u][i];\n\t\t\t\tA[i]=make_pair(arg(P[v]-P[u]),v);\n\t\t\t}\n\t\t\tsort(A,A+k);\n\t\t\trep(i,k) G[u][i]=A[i].second;\n\t\t}\n\n\t\t// decompose to polygons\n\t\tvector< vector<int> > F; // set of polygons\n\t\trep(u,n) rep(i,G[u].size()) F.push_back(reg(trace(G,u,i)));\n\t\tsort(F.begin(),F.end());\n\t\tF.erase(unique(F.begin(),F.end()),F.end());\n\n\t\t// find the outside boundary\n\t\tint n2=F.size(),u0=-1;\n\t\trep(u,n2){\n\t\t\tint k=F[u].size();\n\t\t\tpolygon H(k);\n\t\t\trep(i,k) H[i]=P[F[u][i]];\n\t\t\tif(!is_ccw(H)){\n\t\t\t\tassert(u0==-1);\n\t\t\t\tu0=u;\n\t\t\t}\n\t\t}\n\t\tassert(u0!=-1);\n\n\t\t// build the dual graph\n\t\tvector<int> G2[300];\n\t\trep(u,n2) rep(v,u) {\n\t\t\tbool ok=false;\n\t\t\tint nu=F[u].size(),nv=F[v].size();\n\t\t\trep(i,nu) rep(j,nv) if(F[u][i]==F[v][(j+1)%nv] && F[u][(i+1)%nu]==F[v][j]) ok=true;\n\t\t\tif(ok){\n\t\t\t\tG2[u].push_back(v);\n\t\t\t\tG2[v].push_back(u);\n\t\t\t}\n\t\t}\n\n\t\t// BFS\n\t\tint d[300];\n\t\trep(u,n2) d[u]=(u==u0?0:-1);\n\t\tqueue<int> Q;\n\t\tQ.push(u0);\n\t\twhile(!Q.empty()){\n\t\t\tint u=Q.front(); Q.pop();\n\t\t\trep(i,G2[u].size()){\n\t\t\t\tint v=G2[u][i];\n\t\t\t\tif(d[v]==-1) d[v]=d[u]+1, Q.push(v);\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",*max_element(d,d+n2));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint bottom;\nint outside_color;\n\n// Library.\n#include<cassert>\n#include<map>\n#include<vector>\n#include<cmath>\n#include<queue>\n#include<algorithm>\n// Type.\ntypedef int Label;\ntypedef double Weight;\n// Class.\ntemplate<typename Vertex, typename Edge>\nclass PlaneGraph {\npublic:\n  void insert(const Vertex& v);\n  void insert(Edge e);\n  const PlaneGraph<Vertex, Edge> dualgraph() const;\n  const std::map<Label, Weight> Dijkstra(const Label& start) const;\nprivate:\n  void dualgraph_color(std::map<Label, std::map<Label, int>>& color, int c, const Edge& e, const std::map<Label, std::vector<Edge>>& edge) const;\n  std::map<Label, Vertex> V;\n  std::map<Label, std::vector<Edge>> E;\n};\n// Implement.\ntemplate<typename Vertex, typename Edge>\nvoid PlaneGraph<Vertex, Edge>::insert(const Vertex& v) {\n  V[v.label] = v;\n}\ntemplate<typename Vertex, typename Edge>\nvoid PlaneGraph<Vertex, Edge>::insert(Edge e) {\n  assert(V.find(e.from) != std::end(V));\n  assert(V.find(e.to) != std::end(V));\n  E[e.from].push_back(e);\n  std::swap(e.from, e.to);\n  E[e.from].push_back(e);\n}\ntemplate<typename Vertex, typename Edge>\nconst PlaneGraph<Vertex, Edge> PlaneGraph<Vertex, Edge>::dualgraph() const {\n  // Sort edges counterclockwise.\n  auto edge = E;\n  for(auto& list: edge) if(!list.second.empty()) {\n    std::sort(std::begin(list.second), std::end(list.second), [&](const Edge& lhs, const Edge& rhs) {\n      double l = std::atan2(V.at(lhs.to).y - V.at(lhs.from).y, V.at(lhs.to).x - V.at(lhs.from).x);\n      double r = std::atan2(V.at(rhs.to).y - V.at(rhs.from).y, V.at(rhs.to).x - V.at(rhs.from).x);\n      return l < r;\n    });\n    list.second.push_back(list.second.front());\n  }\n  // Color edges.\n  std::map<Label, std::map<Label, int>> color;\n  int c = 1;\n  for(const auto& list: edge) {\n    for(const auto& e: list.second) if(!color[e.from].count(e.to)) dualgraph_color(color, c++, e, edge);\n    if(list.first == bottom) outside_color = color[list.second.front().from][list.second.front().to];\n  }\n  // Construct the dualgraph.\n  PlaneGraph<Vertex, Edge> result;\n  std::vector<std::vector<bool>> used(c, std::vector<bool>(c, false));\n  for(int i = 1; i < c; ++i) result.insert(Vertex({i}));\n  for(const auto& list: E) for(const auto& e: list.second) if(!used[color[e.from][e.to]][color[e.to][e.from]]) {\n    used[color[e.from][e.to]][color[e.to][e.from]] = true;\n    used[color[e.to][e.from]][color[e.from][e.to]] = true;\n    result.insert(Edge({color[e.from][e.to], color[e.to][e.from], 1}));\n  }\n  return result;\n}\ntemplate<typename Vertex, typename Edge>\nvoid PlaneGraph<Vertex, Edge>::dualgraph_color(std::map<Label, std::map<Label, int>>& color, int c, const Edge& e, const std::map<Label, std::vector<Edge>>& edge) const {\n  color[e.from][e.to] = c;\n  for(auto it = edge.at(e.to).rbegin(); it != edge.at(e.to).rend(); ++it) if(it->to == e.from) {\n    ++it;\n    if(!color[it->from].count(it->to)) dualgraph_color(color, c, *it, edge);\n    break;\n  }\n}\ntemplate<typename Vertex, typename Edge>\nconst std::map<Label, Weight> PlaneGraph<Vertex, Edge>::Dijkstra(const Label& start) const {\n  std::map<Label, Weight> result;\n  std::priority_queue<Edge, std::vector<Edge>, std::function<bool(Edge, Edge)>> q([](Edge lhs, Edge rhs) {\n    return lhs.weight >= rhs.weight;\n  });\n  q.push(Edge({start, start, 0}));\n  while(!q.empty()) {\n    auto cur = q.top();\n    q.pop();\n    result[cur.to] = cur.weight;\n    for(const auto& nex: E.at(cur.to)) if(!result.count(nex.to)) q.push(Edge({nex.from, nex.to, cur.weight + nex.weight}));\n  }\n  return result;\n}\n////////////////////////////////////////\n// Configuration.\nstruct Vertex {Label label; double x, y;};\nstruct Edge {Label from, to; Weight weight;};\n////////////////////////////////////////\n#include<bits/stdc++.h>\nusing namespace std;\nint main() {\n  int C, W;\n  while(cin >> C >> W, C | W) {\n    vector<Vertex> pillar;\n    int bottom_x = 1001, bottom_y = 1001;\n    for(int i = 0; i < C; ++i) {\n      double x, y;\n      cin >> x >> y;\n      pillar.push_back({i, x, y});\n      if(bottom_x < x) continue;\n      if(bottom_x == x && bottom_y < y) continue;\n      bottom_x = x;\n      bottom_y = y;\n      bottom = i;\n    }\n    PlaneGraph<Vertex, Edge> G;\n    for(const auto& p: pillar) G.insert(p);\n    for(int i = 0; i < W; ++i) {\n      int s, t;\n      cin >> s >> t;\n      --s; --t;\n      G.insert(Edge({s, t, 1}));\n    }\n    auto D = G.dualgraph();\n    auto distance = D.Dijkstra(outside_color);\n    double answer = 0;\n    for(const auto& d: distance) answer = max(answer, d.second);\n    cout << answer << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<int,pair<bool,double> > P2;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define min_3(a,b,c) min(a,min(b,c))\n#define max_3(a,b,c) max(a,max(b,c))\n#define mp1(a,b,c) P1(a,P(b,c))\n#define mp2(a,b,c) P2(a,pair<bool,double>(b,c))\n#define pque(a) priority_queue<a>\n#define rpque(a) priority_queue<a,vector<a>,greater<a>>\n\nconst int INF=1000000000;\nconst int dre_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dre_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\nconst int kaijou[10]={1,1,2,6,24,120,720,5040,40320,362880};\n\nbool com(P2 x,P2 y){\n\tif(x.sc.fr!=y.sc.fr)return x.sc.fr;\n\treturn x.sc.sc>=y.sc.sc;\n}\n\nint main(){\n\tint ppp=0;\n\twhile(1){\n\t\tppp++; if(ppp>=5)return 0;\n\t\tstatic int v,w;\n\t\tstatic int x[110],y[110];\n\t\tstatic int s,t;\n\t\t\n\t\tscanf(\"%d%d\",&v,&w); if(v==0&&w==0)break;\n\t\trep1(i,v)scanf(\"%d%d\",&x[i],&y[i]);\n\t\t\n\t\tstatic vector<P1> V_; V_.clear();\n\t\trep1(i,v){\n\t\t\tV_.pb(mp1(x[i],y[i],i));\n\t\t}\n\t\tsor(V_);\n\t\tstatic vector<P2> vec_[110];\n\t\trep1(i,v){\n\t\t\tvec_[i].clear();\n\t\t\tvec_[i].pb(mp2(0,false,-INF));\n\t\t\trep1(j,v){\n\t\t\t\tif(i==j)continue;\n\t\t\t\tif(x[i]<x[j]){\n\t\t\t\t\tvec_[i].pb(mp2(j,true,(double)(y[j]-y[i])/(x[j]-x[i])));\n\t\t\t\t}\n\t\t\t\telse if(x[i]>x[j]){\n\t\t\t\t\tvec_[i].pb(mp2(j,false,(double)(y[j]-y[i])/(x[j]-x[i])));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(y[j]>y[i])vec_[i].pb(mp2(j,true,(double)INF));\n\t\t\t\t\telse vec_[i].pb(mp2(j,true,(double)-INF));\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(vec_[i].begin(),vec_[i].end(),com);\n\t\t}\n\t\t\n\t\tstatic int e;\n\t\tstatic vector<int> V; V.clear();\n\t\tstatic bool edge[110][110];\n\t\tstatic vector<int> vec[110]; \n\t\t\n\t\te=w;\n\t\trep(i,v)V.pb(V_[i].sc.sc);\n\t\trep(i,110)rep(j,110)edge[i][j]=false;\n\t\trep(i,e){\n\t\t\tscanf(\"%d%d\",&s,&t);\n\t\t\tedge[s][t]=true;\n\t\t\tedge[t][s]=true;\n\t\t}\n\t\trep1(i,v){\n\t\t\tvec[i].clear();\n\t\t\trep(j,vec_[i].size()){\n\t\t\t\tvec[i].pb(vec_[i][j].fr);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ret=0;\n\t\twhile(e>0){\n\t\t\tret++;\n\t\t\t\n\t\t\tint a=-1;\n\t\t\trep(i,V.size()){\n\t\t\t\trep(j,105){\n\t\t\t\t\tif(edge[V[i]][j]){a=V[i]; break;}\n\t\t\t\t}\n\t\t\t\tif(a!=-1)break;\n\t\t\t}\n\t\t\t\n\t\t\tint b=0,c=a;\n\t\t\twhile(1){\n\t\t\t\tif(c==-1||vec[c].size()==0)break;\n\t\t\t\trep(i,vec[c].size()){\n\t\t\t\t\tif(vec[c][i]==b){\n\t\t\t\t\t\ti++; i%=vec[c].size();\n\t\t\t\t\t\twhile(!edge[c][vec[c][i]]){\n\t\t\t\t\t\t\ti++; i%=vec[c].size();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tedge[c][vec[c][i]]=false;\n\t\t\t\t\t\tedge[vec[c][i]][c]=false;\n\t\t\t\t\t\te--;\n\t\t\t\t\t\tb=c;\n\t\t\t\t\t\tc=vec[c][i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(c==a)break;\n\t\t\t}\n\t\t\t\n\t\t\tbool updata=true;\n\t\t\twhile(updata){\n\t\t\t\tupdata=false;\n\t\t\t\trep1(i,v){\n\t\t\t\t\tint cnt=0;\n\t\t\t\t\tint t=105;\n\t\t\t\t\trep1(j,v){\n\t\t\t\t\t\tif(edge[i][j]){cnt++; t=j;}\n\t\t\t\t\t}\n\t\t\t\t\tif(cnt==1){\n\t\t\t\t\t\tupdata=true;\n\t\t\t\t\t\tedge[i][t]=false;\n\t\t\t\t\t\tedge[t][i]=false;\n\t\t\t\t\t\te--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<utility>\n#include<map>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n\nusing namespace std;\n\nstruct Point{\n\tint x,y;\n\tint id;\n\tPoint(){}\n\tPoint(int a,int b,int c):x(a),y(b),id(c){}\n};\n\nPoint points[110];\nint pid[110];\n\nbool cmp(const Point &p1,const Point &p2)\n{\n\tif(p1.x!=p2.x) return p1.x<p2.x;\n\treturn p1.y<p2.y;\n}\n\nint center;\n\nbool cmp_angle(const int &id1,const int &id2)\n{\n\tint center=pid[::center];\n\tint id1_=pid[id1],id2_=pid[id2];\n\tint dx1=points[id1_].x-points[center].x;\n\tint dy1=points[id1_].y-points[center].y;\n\tint dx2=points[id2_].x-points[center].x;\n\tint dy2=points[id2_].y-points[center].y;\n\t//(-y,x)\n\tdouble ang1=atan2(dx1,-dy1);\n\tdouble ang2=atan2(dx2,-dy2);\n\treturn ang1<ang2;\n}\n/*\nstruct cmp_angle_{\n\tbool operator()(const int &id1,const int &id2)\n\t{\n\tint center=pid[::center];\n\tint id1_=pid[id1],id2_=pid[id2];\n\tint dx1=points[id1_].x-points[center].x;\n\tint dy1=points[id1_].y-points[center].y;\n\tint dx2=points[id2_].x-points[center].x;\n\tint dy2=points[id2_].y-points[center].y;\n\t//(-y,x)\n\tdouble ang1=atan2(dx1,-dy1);\n\tdouble ang2=atan2(dx2,-dy2);\n\treturn ang1<ang2;\n\t}\n};*/\n\nvector<int> G[110];\n\nvector<vector<int> > vs;\nvector<int> dG[550];\n//bool con[550][550];\n\ntypedef pair<int,int> P;\n\nmap<P,int> cnt;\nqueue<P> que;\n\nvoid init()\n{\n\tvs.clear();\n\tfor(int i=0;i<110;i++) G[i].clear();\n\tfor(int i=0;i<550;i++) dG[i].clear();\n\tcnt.clear();\n}\n\nvector<int> res;\nvoid stroke(int u,int v,int st)\n{\n\t//u->v\n\tP p=P(min(u,v),max(u,v));\n\tif(cnt[p]==0)\n\t{\n\t\tque.push(P(v,u));\n\t}\n\tcnt[p]++;\n\tif(v==st) return;\n\tif(u==st) res.push_back(u);\n\tres.push_back(v);\n//\tprintf(\"x%dx\\n\",v);\n\tcenter=v;\n\tint id=distance(G[v].begin(),lower_bound(G[v].begin(),G[v].end(),u,cmp_angle));\n//\tprintf(\"%d::%d %d\\n\",v,G[v].size(),id);\n\tif(id==G[v].size()-1) id=0;\n\telse id++;\n\tint nxt=G[v][id];\n\tstroke(v,nxt,st);\n}\n\nvoid getGraph()\n{\n\tint V=vs.size();\n\tfor(int i=0;i<V;i++) for(int j=i+1;j<V;j++)\n\t{\n\t\tint ni=vs[i].size(),nj=vs[j].size();\n\t\tbool flg=false;\n\t\tfor(int iid=0;iid<ni;iid++) for(int jid=0;jid<nj;jid++)\n\t\t{\n\t\t\tint niid=iid==ni-1?0:iid+1;\n\t\t\tint njid=jid==nj-1?0:jid+1;\n\t\t\tif(vs[i][iid]==vs[j][njid]&&vs[i][niid]==vs[j][jid]) flg=true;\n\t\t}\n\t\tif(flg)\n\t\t{\n\t\t\tdG[i].push_back(j);\n\t\t\tdG[j].push_back(i);\n\t\t}\n\t//\tcon[i][j]=flg;\n\t//\tcon[j][i]=flg;\n\t}\n}\n\nint getMostOutSide()\n{\n\tint u=points[0].id;\n\tint v=G[u][0];\n//\tprintf(\"----------------%d %d\\n\",u,v);\n//\tprintf(\"%d %d %d %d\\n\",points[u].x,points[u].y,points[v].x,points[v].y);\n\tfor(int i=0;i<vs.size();i++)\n\t{\n\t\tfor(int j=0;j+1<vs[i].size();j++)\n\t\t{\n\t\t\tif(vs[i][j]==u&&vs[i][j+1]==v) return i;\n\t\t}\n\t\tif(vs[i][vs[i].size()-1]==u&&vs[i][0]==v) return i;\n\t}\n\treturn -1;\n}\n\nint dis[550];\nqueue<int> bfs_que;\nvoid bfs(int s)\n{\n//\tprintf(\"xxxxxxxxxxxxxxxxxxxxx\\n\");\n\twhile(!bfs_que.empty()) bfs_que.pop();\n\tbfs_que.push(s);\n\tfor(int i=0;i<550;i++) dis[i]=1<<29;\n\tdis[s]=0;\n\tbfs_que.push(s);\n\twhile(!bfs_que.empty())\n\t{\n\t\tint v=bfs_que.front();\n//\t\tprintf(\"bfs %d\\n\",v);\n\t\tbfs_que.pop();\n\t\tfor(int i=0;i<dG[v].size();i++)\n\t\t{\n\t\t\tint u=dG[v][i];\n\t\t\tint nd=dis[v]+1;\n\t\t\tif(nd>=dis[u]) continue;\n\t\t\tdis[u]=nd;\n\t\t\tbfs_que.push(u);\n\t\t}\n\t}\n}\n\nvoid outputdG()\n{\n\tprintf(\"-----dual\\n\");\n\tfor(int i=0;i<vs.size();i++)\n\t{\n\t\tprintf(\"%d-\",i);\n\t\tfor(int j=0;j<dG[i].size();j++)\n\t\t{\n\t\t\tprintf(\"%d \",dG[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}\n\nint main()\n{\n\twhile(true)\n\t{\n\t\tint C,W;\n\t\tscanf(\"%d%d\",&C,&W);\n\t\tif(C==0) break;\n\t\tinit();\n\t\tfor(int i=0;i<C;i++)\n\t\t{\n\t\t\tint x,y;\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\tpoints[i]=Point(x,y,i);\n\t\t}\n\t\tsort(points,points+C,cmp);\n\t\tfor(int i=0;i<C;i++) pid[points[i].id]=i;\n\t\tint su=-1,sv=-1;\n\t\tfor(int i=0;i<W;i++)\n\t\t{\n\t\t\tint u,v;\n\t\t\tscanf(\"%d%d\",&u,&v);\n\t\t\tu--;v--;\n\t\t\tG[u].push_back(v);\n\t\t\tG[v].push_back(u);\n\t\t\tsu=u,sv=v;\n\t\t}\n\t\tfor(int i=0;i<C;i++)\n\t\t{\n\t\t\tcenter=i;\n\t\t\tsort(G[i].begin(),G[i].end(),cmp_angle);\n//\t\t\tprintf(\"%d:::\",i);\n//\t\t\tfor(int j=0;j<G[i].size();j++) printf(\"%d \",G[i][j]);\n//\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tque.push(P(min(su,sv),max(su,sv)));\n\t\twhile(!que.empty())\n\t\t{\n\t\t\tP p=que.front();\n\t\t\tque.pop();\n\t\t\tint u=p.first,v=p.second;\n//\t\t\tprintf(\"pop %d %d\\n\",u,v);\n\t\t\tP pp=P(min(u,v),max(u,v));\n\t\t\tif(cnt[pp]==2) continue;\n\t\t//\tbool flg;\n\t\t//\tif(cnt[pp]==1) flg=false;\n\t\t//\telse flg=true;\n\t\t\tres.clear();\n\t\t\tstroke(u,v,u);\n\t\t\tvs.push_back(res);\n//\t\t\tfor(int i=0;i<res.size();i++) printf(\"%d \",res[i]);\n//\t\t\tprintf(\"aaa\\n\");\n\t\t//\tcnt[pp]++;\n\t\t//\tif(flg) que.push(P(v,u));\n\t\t}\n\t\tif(vs.size()>500) for(;;);\n//\t\tfor(int i=0;i<vs.size();i++)\n//\t\t{\n//\t\t\tvector<int> vec=vs[i];\n//\t\t\tprintf(\"a:\");\n//\t\t\tfor(int j=0;j<vec.size();j++) printf(\"%d \",vec[j]);\n//\t\t\tprintf(\"\\n\");\n//\t\t}\n\t\tgetGraph();\n\t\tint out=getMostOutSide();\n\t\tbfs(out);\n\t\tint ans=0;\n\t\tfor(int i=0;i<vs.size();i++) ans=max(ans,dis[i]);\n//\t\toutputdG();\n//\t\tprintf(\"---------%d--------------ans=%d\\n\",out,ans);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<utility>\n#include<map>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n\nusing namespace std;\n\nstruct Point{\n\tint x,y;\n\tint id;\n\tPoint(){}\n\tPoint(int a,int b,int c):x(a),y(b),id(c){}\n};\n\nPoint points[110];\nint pid[110];\n\nbool cmp(const Point &p1,const Point &p2)\n{\n\tif(p1.x!=p2.x) return p1.x<p2.x;\n\treturn p1.y<p2.y;\n}\n\nint center;\n\nbool cmp_angle(const int &id1,const int &id2)\n{\n\tint center=pid[::center];\n\tint id1_=pid[id1],id2_=pid[id2];\n\tint dx1=points[id1_].x-points[center].x;\n\tint dy1=points[id1_].y-points[center].y;\n\tint dx2=points[id2_].x-points[center].x;\n\tint dy2=points[id2_].y-points[center].y;\n\t//(-y,x)\n\tdouble ang1=atan2(dx1,-dy1);\n\tdouble ang2=atan2(dx2,-dy2);\n\treturn ang1<ang2;\n}\n/*\nstruct cmp_angle_{\n\tbool operator()(const int &id1,const int &id2)\n\t{\n\tint center=pid[::center];\n\tint id1_=pid[id1],id2_=pid[id2];\n\tint dx1=points[id1_].x-points[center].x;\n\tint dy1=points[id1_].y-points[center].y;\n\tint dx2=points[id2_].x-points[center].x;\n\tint dy2=points[id2_].y-points[center].y;\n\t//(-y,x)\n\tdouble ang1=atan2(dx1,-dy1);\n\tdouble ang2=atan2(dx2,-dy2);\n\treturn ang1<ang2;\n\t}\n};*/\n\nvector<int> G[110];\n\nvector<vector<int> > vs;\nvector<int> dG[550];\n//bool con[550][550];\n\ntypedef pair<int,int> P;\n\nmap<P,int> cnt;\nqueue<P> que;\n\nvoid init()\n{\n\tvs.clear();\n\tfor(int i=0;i<110;i++) G[i].clear();\n\tfor(int i=0;i<550;i++) dG[i].clear();\n\tcnt.clear();\n}\n\nvector<int> res;\nvoid stroke(int u,int v,int st)\n{\n\t//u->v\n\tP p=P(min(u,v),max(u,v));\n\tif(cnt[p]==0)\n\t{\n\t\tque.push(P(v,u));\n\t}\n\tcnt[p]++;\n\tif(v==st) return;\n\tif(u==st) res.push_back(u);\n\tres.push_back(v);\n//\tprintf(\"x%dx\\n\",v);\n\tcenter=v;\n\tint id=distance(G[v].begin(),lower_bound(G[v].begin(),G[v].end(),u,cmp_angle));\n//\tprintf(\"%d::%d %d\\n\",v,G[v].size(),id);\n\tif(id==G[v].size()-1) id=0;\n\telse id++;\n\tint nxt=G[v][id];\n\tstroke(v,nxt,st);\n}\n\nvoid getGraph()\n{\n\tint V=vs.size();\n\tfor(int i=0;i<V;i++) for(int j=i+1;j<V;j++)\n\t{\n\t\tint ni=vs[i].size(),nj=vs[j].size();\n\t\tbool flg=false;\n\t\tfor(int iid=0;iid<ni;iid++) for(int jid=0;jid<nj;jid++)\n\t\t{\n\t\t\tint niid=iid==ni-1?0:iid+1;\n\t\t\tint njid=jid==nj-1?0:jid+1;\n\t\t\tif(vs[i][iid]==vs[j][njid]&&vs[i][niid]==vs[j][jid]) flg=true;\n\t\t}\n\t\tif(flg)\n\t\t{\n\t\t\tdG[i].push_back(j);\n\t\t\tdG[j].push_back(i);\n\t\t}\n\t//\tcon[i][j]=flg;\n\t//\tcon[j][i]=flg;\n\t}\n}\n\nint getMostOutSide()\n{\n\tint u=points[0].id;\n\tint v=G[u][0];\n//\tprintf(\"----------------%d %d\\n\",u,v);\n//\tprintf(\"%d %d %d %d\\n\",points[u].x,points[u].y,points[v].x,points[v].y);\n\tfor(int i=0;i<vs.size();i++)\n\t{\n\t\tfor(int j=0;j+1<vs[i].size();j++)\n\t\t{\n\t\t\tif(vs[i][j]==u&&vs[i][j+1]==v) return i;\n\t\t}\n\t\tif(vs[i][vs[i].size()-1]==u&&vs[i][0]==v) return i;\n\t}\n//\tfor(;;);\n\treturn -1;\n}\n\nvoid check(int a)\n{\n\tif(cnt.size()<a) for(;;);\n/*\tmap<P,int>::iterator it=cnt.begin();\n\tfor(;it!=cnt.end();it++)\n\t{\n\t\tint b=it->second;\n\t\tif(b!=2) for(;;);\n\t}*/\n}\n\nint dis[550];\nqueue<int> bfs_que;\nvoid bfs(int s)\n{\n//\tprintf(\"xxxxxxxxxxxxxxxxxxxxx\\n\");\n\twhile(!bfs_que.empty()) bfs_que.pop();\n\tbfs_que.push(s);\n\tfor(int i=0;i<550;i++) dis[i]=1<<29;\n\tdis[s]=0;\n\tbfs_que.push(s);\n\twhile(!bfs_que.empty())\n\t{\n\t\tint v=bfs_que.front();\n//\t\tprintf(\"bfs %d\\n\",v);\n\t\tbfs_que.pop();\n\t\tfor(int i=0;i<dG[v].size();i++)\n\t\t{\n\t\t\tint u=dG[v][i];\n\t\t\tint nd=dis[v]+1;\n\t\t\tif(nd>=dis[u]) continue;\n\t\t\tdis[u]=nd;\n\t\t\tbfs_que.push(u);\n\t\t}\n\t}\n}\n\nvoid outputdG()\n{\n\tprintf(\"-----dual\\n\");\n\tfor(int i=0;i<vs.size();i++)\n\t{\n\t\tprintf(\"%d-\",i);\n\t\tfor(int j=0;j<dG[i].size();j++)\n\t\t{\n\t\t\tprintf(\"%d \",dG[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}\n\nint main()\n{\n\twhile(true)\n\t{\n\t\tint C,W;\n\t\tscanf(\"%d%d\",&C,&W);\n\t\tif(C==0) break;\n\t\tinit();\n\t\tfor(int i=0;i<C;i++)\n\t\t{\n\t\t\tint x,y;\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\tpoints[i]=Point(x,y,i);\n\t\t}\n\t\tsort(points,points+C,cmp);\n\t\tfor(int i=0;i<C;i++) pid[points[i].id]=i;\n\t\tint su=-1,sv=-1;\n\t\tfor(int i=0;i<W;i++)\n\t\t{\n\t\t\tint u,v;\n\t\t\tscanf(\"%d%d\",&u,&v);\n\t\t\tu--;v--;\n\t\t\tG[u].push_back(v);\n\t\t\tG[v].push_back(u);\n\t\t\tsu=u,sv=v;\n\t\t}\n\t\tfor(int i=0;i<C;i++)\n\t\t{\n\t\t\tcenter=i;\n\t\t\tsort(G[i].begin(),G[i].end(),cmp_angle);\n//\t\t\tprintf(\"%d:::\",i);\n//\t\t\tfor(int j=0;j<G[i].size();j++) printf(\"%d \",G[i][j]);\n//\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tque.push(P(min(su,sv),max(su,sv)));\n\t\twhile(!que.empty())\n\t\t{\n\t\t\tP p=que.front();\n\t\t\tque.pop();\n\t\t\tint u=p.first,v=p.second;\n//\t\t\tprintf(\"pop %d %d\\n\",u,v);\n\t\t\tP pp=P(min(u,v),max(u,v));\n\t\t\tif(cnt[pp]==2) continue;\n\t\t//\tbool flg;\n\t\t//\tif(cnt[pp]==1) flg=false;\n\t\t//\telse flg=true;\n\t\t\tres.clear();\n\t\t\tstroke(u,v,u);\n\t\t\tvs.push_back(res);\n//\t\t\tfor(int i=0;i<res.size();i++) printf(\"%d \",res[i]);\n//\t\t\tprintf(\"aaa\\n\");\n\t\t//\tcnt[pp]++;\n\t\t//\tif(flg) que.push(P(v,u));\n\t\t}\n\t\tif(vs.size()>500) for(;;);\n//\t\tfor(int i=0;i<vs.size();i++)\n//\t\t{\n//\t\t\tvector<int> vec=vs[i];\n//\t\t\tprintf(\"a:\");\n//\t\t\tfor(int j=0;j<vec.size();j++) printf(\"%d \",vec[j]);\n//\t\t\tprintf(\"\\n\");\n//\t\t}\n\t\tgetGraph();\n\t\tcheck(W);\n\t\tint out=getMostOutSide();\n\t\tbfs(out);\n\t\tint ans=0;\n\t\tfor(int i=0;i<vs.size();i++) ans=max(ans,dis[i]);\n//\t\toutputdG();\n//\t\tprintf(\"---------%d--------------ans=%d\\n\",out,ans);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <set>\nusing namespace std;\n\nconst double EPS = 1e-10;\nconst double INF = 1e12;\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n#define X real()\n#define Y imag()\n\ntypedef complex<double> P;\ntypedef vector<P> VP;\nstruct L : VP{\n    L(const P& a, const P& b){ resize(2); at(0)=a; at(1)=b; }\n    L(){ resize(2); }\n};\n\nnamespace std{\n    bool operator < (const P &a, const P &b){\n        return !EQ(a.X, b.X)? a.X<b.X : a.Y<b.Y;\n    }\n    bool operator == (const P &a, const P &b){\n        return abs(a-b) < EPS;\n    }\n}\n\ndouble dot(P a, P b){\n    return (conj(a)*b).X;\n}\ndouble cross(P a, P b){\n    return (conj(a)*b).Y;\n}\nint ccw(P a, P b, P c){\n    b -= a;\n    c -= a;\n    if(cross(b,c) > EPS) return +1; //ccw\n    if(cross(b,c) <-EPS) return -1; //cw\n    if(dot(b,c) < EPS) return +2; //c-a-b\n    if(norm(b) < norm(c)) return -2; //a-b-c\n    return 0; //a-c-b\n}\n\nP projection(const L& l, const P& p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1]-l[0], m[1]-m[0]);\n  double B = cross(l[1]-l[0], l[1]-m[0]);\n  return m[0] + B /A *(m[1]-m[0]);\n}\n\ndouble getangle(const P &p, const P &a, const P &b){ //clockwise\n    P proj = projection(L(p,a), b);\n    int minus = (dot(a-p, b-p)>=0)? 1 :-1;\n    if(ccw(p,a,b)!=1){\n        return atan2(abs(b-proj), minus*abs(p-proj));\n    }else{\n        return 2*M_PI - atan2(abs(b-proj), minus*abs(p-proj));\n    }\n}\n\nvoid trace(int cidx, vector<vector<int> > &adj, map<pair<int,int>, int> &rest, VP &plist, vector<int> &poly, bool outside){\n    P curr = plist[cidx];\n    P prev = P(0, -1);\n    int pidx = -1;\n    poly = vector<int>();\n    bool first=true;\n    while(1){\n        int next = -1;\n        bool rightmost = !first && !outside;\n        double m_angle = rightmost? -INF: INF;\n        for(int i=0; i<(int)adj[cidx].size(); i++){\n            if(adj[cidx][i] == pidx) continue;\n            int imin = min(cidx, adj[cidx][i]);\n            int imax = max(cidx, adj[cidx][i]);\n            if(rest[make_pair(imin, imax)] == 0) continue;\n            double angle = getangle(curr, prev, plist[adj[cidx][i]]);\n            if((rightmost && angle > m_angle) || (!rightmost && angle < m_angle)){\n                next = adj[cidx][i];\n                m_angle = angle;\n            }\n        }\n        if(!first && next == poly[0]) break;\n        poly.push_back(next);\n        prev = curr;\n        pidx = cidx;\n        curr = plist[next];\n        cidx = next;\n        first = false;\n    }\n}\n\nvoid makeDualGraph(vector<vector<int> > &adj, vector<vector<int> > &dual, VP &plist){\n    int n = adj.size();\n    vector<int> degree(n);\n    map<pair<int,int>, int> rest;\n    for(int i=0; i<n; i++){\n        for(int j=0; j<(int)adj[i].size(); j++){\n            if(i<adj[i][j]){\n                rest[make_pair(i, adj[i][j])] = 2;\n            }\n        }\n        degree[i] = adj[i].size()*2;\n    }\n    \n    map<pair<int,int>, int> edgelist;\n    dual = vector<vector<int> >();\n    dual.reserve(200);\n    \n    int sptr=0;\n    int areaidx=-1;\n    bool first = true;\n    while(1){\n        while(sptr<n && degree[sptr]==0) sptr++;\n        if(sptr==n) break;\n        areaidx++;\n        \n        vector<int> border;\n        trace(sptr, adj, rest, plist, border, first);\n        dual.push_back(vector<int>());\n        \n        for(int i=0; i<(int)border.size(); i++){\n            int a = border[i];\n            int b = border[(i+1)%(int)border.size()];\n            if(a>b) swap(a,b);\n            degree[a]--;\n            degree[b]--;\n            rest[make_pair(a,b)]--;\n            if(edgelist.count(make_pair(a,b)) == 0){\n                edgelist[make_pair(a,b)] = areaidx;\n            }else{\n                dual[areaidx].push_back(edgelist[make_pair(a,b)]);\n                dual[edgelist[make_pair(a,b)]].push_back(areaidx);\n            }\n        }\n        first = false;\n    }\n    \n    for(int i=0; i<=areaidx; i++){\n        sort(dual[i].begin(), dual[i].end());\n        dual[i].erase(unique(dual[i].begin(), dual[i].end()), dual[i].end());\n    }\n}\n\nconst int inf = 1e9;\n\nint main(){\n\twhile(1){\n\t\tint c,w;\n\t\tcin >> c >> w;\n\t\tif(c==0) break;\n\t\t\n\t\tvector<pair<P, int> > bar(c);\n\t\tfor(int i=0; i<c; i++){\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\tbar[i] = make_pair(P(x,y), i+1);\n\t\t}\n\t\tsort(bar.begin(), bar.end());\n\t\t\n\t\tvector<int> backref(c+1);\n\t\tVP p(c);\n\t\tfor(int i=0; i<c; i++){\n\t\t\tbackref[bar[i].second] = i;\n\t\t\tp[i] = bar[i].first;\n\t\t}\n\t\t\n\t\tvector<vector<int> > adj(c), dual;\n\t\tfor(int i=0; i<w; i++){\n\t\t\tint s,t;\n\t\t\tcin >> s >> t;\n\t\t\tadj[backref[s]].push_back(backref[t]);\n\t\t\tadj[backref[t]].push_back(backref[s]);\n\t\t}\n\t\tmakeDualGraph(adj, dual, p);\n\t\t\n\t\tint numarea = dual.size();\n\t\tset<int> reach;\n\t\treach.insert(0);\n\t\tint ans = 0;\n\t\twhile(1){\n\t\t\tif((int)reach.size() == numarea) break;\n\t\t\tset<int> newreach;\n\t\t\tfor(set<int>::iterator itr=reach.begin(); itr!=reach.end(); itr++){\n\t\t\t\tnewreach.insert(*itr);\n\t\t\t\tfor(int i=0; i<(int)dual[*itr].size(); i++){\n\t\t\t\t\tnewreach.insert(dual[*itr][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treach = newreach;\n\t\t\tans++;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <set>\n#include <cstdlib>\nusing namespace std;\n\nconst double EPS = 1e-10;\nconst double INF = 1e12;\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n#define X real()\n#define Y imag()\n\ntypedef complex<double> P;\ntypedef vector<P> VP;\nstruct L : VP{\n    L(const P& a, const P& b){ resize(2); at(0)=a; at(1)=b; }\n    L(){ resize(2); }\n};\n\nnamespace std{\n    bool operator < (const P &a, const P &b){\n        return !EQ(a.X, b.X)? a.X<b.X : a.Y<b.Y;\n    }\n    bool operator == (const P &a, const P &b){\n        return abs(a-b) < EPS;\n    }\n}\n\ndouble dot(P a, P b){\n    return (conj(a)*b).X;\n}\ndouble cross(P a, P b){\n    return (conj(a)*b).Y;\n}\nint ccw(P a, P b, P c){\n    b -= a;\n    c -= a;\n    if(cross(b,c) > EPS) return +1; //ccw\n    if(cross(b,c) <-EPS) return -1; //cw\n    if(dot(b,c) < EPS) return +2; //c-a-b\n    if(norm(b) < norm(c)) return -2; //a-b-c\n    return 0; //a-c-b\n}\n\nP projection(const L& l, const P& p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1]-l[0], m[1]-m[0]);\n  double B = cross(l[1]-l[0], l[1]-m[0]);\n  return m[0] + B /A *(m[1]-m[0]);\n}\n\ndouble getangle(const P &p, const P &a, const P &b){ //clockwise\n    P proj = projection(L(p,a), b);\n    int minus = (dot(a-p, b-p)>=0)? 1 :-1;\n    if(ccw(p,a,b)!=1){\n        return atan2(abs(b-proj), minus*abs(p-proj));\n    }else{\n        return 2*M_PI - atan2(abs(b-proj), minus*abs(p-proj));\n    }\n}\n\nvoid trace(int cidx, vector<vector<int> > &adj, map<pair<int,int>, int> &rest, VP &plist, vector<int> &poly, bool outside){\n    P curr = plist[cidx];\n    P prev = P(0, -1);\n    int pidx = -1;\n    poly = vector<int>();\n    bool first=true;\n    while(1){\n        int next = -1;\n        bool rightmost = !first && !outside;\n        double m_angle = rightmost? -INF: INF;\n        for(int i=0; i<(int)adj[cidx].size(); i++){\n            if(adj[cidx][i] == pidx) continue;\n            int imin = min(cidx, adj[cidx][i]);\n            int imax = max(cidx, adj[cidx][i]);\n            if(rest[make_pair(imin, imax)] == 0) continue;\n            double angle = getangle(curr, prev, plist[adj[cidx][i]]);\n            if((rightmost && angle > m_angle) || (!rightmost && angle < m_angle)){\n                next = adj[cidx][i];\n                m_angle = angle;\n            }\n        }\n        if(!first) rest[make_pair(min(cidx,next), max(cidx,next))]--;\n        if(!first && next == poly[0]) break;\n        if(next==-1){\n        \tcout << 1 << endl;\n        \texit(0);\n        }\n        poly.push_back(next);\n        prev = curr;\n        pidx = cidx;\n        curr = plist[next];\n        cidx = next;\n        first = false;\n    }\n}\n\nvoid makeDualGraph(vector<vector<int> > &adj, vector<vector<int> > &dual, VP &plist){\n    int n = adj.size();\n    vector<int> degree(n);\n    map<pair<int,int>, int> rest;\n    for(int i=0; i<n; i++){\n        for(int j=0; j<(int)adj[i].size(); j++){\n            if(i<adj[i][j]){\n                rest[make_pair(i, adj[i][j])] = 2;\n            }\n        }\n        degree[i] = adj[i].size()*2;\n    }\n    \n    map<pair<int,int>, int> edgelist;\n    dual = vector<vector<int> >();\n    dual.reserve(200);\n    \n    int sptr=0;\n    int areaidx=-1;\n    bool first = true;\n    while(1){\n        while(sptr<n && degree[sptr]==0) sptr++;\n        if(sptr==n) break;\n        areaidx++;\n        \n        vector<int> border;\n        trace(sptr, adj, rest, plist, border, first);\n        dual.push_back(vector<int>());\n        \n        for(int i=0; i<(int)border.size(); i++){\n            int a = border[i];\n            int b = border[(i+1)%(int)border.size()];\n            if(a>b) swap(a,b);\n            degree[a]--;\n            degree[b]--;\n            if(edgelist.count(make_pair(a,b)) == 0){\n                edgelist[make_pair(a,b)] = areaidx;\n            }else{\n                dual[areaidx].push_back(edgelist[make_pair(a,b)]);\n                dual[edgelist[make_pair(a,b)]].push_back(areaidx);\n            }\n        }\n        first = false;\n    }\n    \n    for(int i=0; i<=areaidx; i++){\n        sort(dual[i].begin(), dual[i].end());\n        dual[i].erase(unique(dual[i].begin(), dual[i].end()), dual[i].end());\n    }\n}\n\nint main(){\n\twhile(1){\n\t\tint c,w;\n\t\tcin >> c >> w;\n\t\tif(c==0) break;\n\t\t\n\t\tvector<pair<P, int> > bar(c);\n\t\tfor(int i=0; i<c; i++){\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\tbar[i] = make_pair(P(x,y), i+1);\n\t\t}\n\t\tsort(bar.begin(), bar.end());\n\t\t\n\t\tvector<int> backref(c+1);\n\t\tVP p(c);\n\t\tfor(int i=0; i<c; i++){\n\t\t\tbackref[bar[i].second] = i;\n\t\t\tp[i] = bar[i].first;\n\t\t}\n\t\t\n\t\tvector<vector<int> > adj(c), dual;\n\t\tfor(int i=0; i<w; i++){\n\t\t\tint s,t;\n\t\t\tcin >> s >> t;\n\t\t\tadj[backref[s]].push_back(backref[t]);\n\t\t\tadj[backref[t]].push_back(backref[s]);\n\t\t}\n\t\tmakeDualGraph(adj, dual, p);\n\t\t\n\t\tint numarea = dual.size();\n\t\tset<int> reach;\n\t\treach.insert(0);\n\t\tint ans = 0;\n\t\twhile(1){\n\t\t\tif((int)reach.size() == numarea) break;\n\t\t\tset<int> newreach;\n\t\t\tfor(set<int>::iterator itr=reach.begin(); itr!=reach.end(); itr++){\n\t\t\t\tnewreach.insert(*itr);\n\t\t\t\tfor(int i=0; i<(int)dual[*itr].size(); i++){\n\t\t\t\t\tnewreach.insert(dual[*itr][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treach = newreach;\n\t\t\tans++;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#include <climits>\n\nusing namespace std;\n\ntypedef long long lint;\n\n//定数\nconst double EPS = 1e-10;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\nconst int INF = 1001001001;\nconst lint INFLL = 1001001001001001001ll;\n\n//初期化関連\n#define zclear(a) memset((a), 0 ,sizeof(a))\n#define mclear(a) memset((a), -1, sizeof(a))\n\n//デバッグ出力\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nbool eq(double a, double b) //a == b\n{\n    return (fabs(a - b) <= EPS);\n}\n\nbool neq(double a, double b) //a == b\n{\n    return (!eq(a, b));\n}\n  \nbool lt(double a, double b) //a < b\n{\n    return (a - b < -EPS);\n}\n  \nbool leq(double a, double b) //a <= b\n{\n    return (lt(a, b) || eq(a, b));\n}\n  \nbool gt(double a, double b) //a > b\n{\n    return (a - b > +EPS);\n}\n  \nbool geq(double a, double b) //a >= b\n{\n    return (gt(a, b) || eq(a, b));\n}\n\nclass Point{\npublic:\n\tdouble x, y;\n\tint id;\n\tPoint(double x = 0, double y = 0): x(x), y(y){}\n\tPoint operator + (Point p){return Point(x + p.x, y + p.y);}\n\tPoint operator - (Point p){return Point(x - p.x, y - p.y);}\n\tPoint operator * (double a){return Point(x * a, y * a);}\n\tPoint operator / (double a){return Point(x / a, y / a);}\n\tPoint operator * (const Point &a){\n\t\treturn Point(x * a.x - y * a.y, x * a.y + y * a.x);\n\t}\n\tbool operator < (const Point &p) const {\n\t\treturn (x != p.x ? x < p.x : y < p.y);\n\t}\n\tbool operator == (const Point &p) const {\n\t\treturn (fabs(x - p.x) < EPS && fabs(y - p.y) < EPS);\n\t}\n};\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\ndouble norm(Vector a){return (a.x * a.x + a.y * a.y);}\ndouble abs(Vector a){return (sqrt(norm(a)));}\ndouble abs(Vector a, Vector b){return (sqrt(norm(a - b)));}\ndouble dot(Vector a, Vector b){return (a.x * b.x + a.y * b.y);}\ndouble cross(Vector a, Vector b){return (a.x * b.y - a.y * b.x);}\ndouble atan(Vector a){return atan2(a.y, a.x);}\nbool sortX(Point a, Point b){return (a.x != b.x ? lt(a.x, b.x) : lt(a.y, b.y));}\nbool sortY(Point a, Point b){return (a.y != b.y ? lt(a.y, b.y) : lt(a.x, b.x));}\nPoint p;\nbool sortT(Point a, Point b){return (gt(cross(a - p, b - p), 0));}\n\nint ccw(Point p0, Point p1, Point p2)\n{\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > EPS) return (+1); //p0, p1, p2 が反時計周り\n\tif (cross(a, b) < -EPS) return (-1);//p0, p1, p2 が時計回り\n\tif (dot(a, b) < -EPS) return (+2); //p2--p0--p1 の順で一直線上\n\tif (norm(a) < norm(b)) return (-2); //p0--p1--p2 の順で一直線上\n\treturn (0); //p0--p2--p1 の順で一直線上\n}\n\nPolygon normalize(Polygon &v)\n{\n    int pt = 0;\n    for (int i = 1; i < v.size(); i++){\n        if (v[pt].y > v[i].y || (v[pt].y == v[i].y && v[pt].x > v[i].x)){\n            pt = i;\n        }\n    }\n    swap(v[pt], v[0]);\n    p = v[0];\n    sort(v.begin() + 1, v.end(), sortT);\n    return (v);\n}\n\nPolygon conhel(Polygon& ps)\n{\n    sort(ps.begin(), ps.end());\n    int k = 0, n = (int)ps.size();\n    Polygon qs(n * 2);\n      \n    for (int i = 0; i < n; i++){\n      while (k > 1 && cross(qs[k - 1] - qs[k - 2], ps[i] - qs[k - 1]) < -EPS) k--;\n      qs[k++] = ps[i];\n    }\n  \n    for (int i = n - 2, t = k; i >= 0; i--){\n      while (k > t && cross(qs[k - 1] - qs[k - 2], ps[i] - qs[k - 1]) < -EPS) k--;\n      qs[k++] = ps[i];\n    }\n  \n    qs.resize(k - 1);\n    return (qs);\n}\n\ndouble getArea(Polygon t){\n    double ans = 0.0;\n\tt = normalize(t);\n    for (unsigned int i = 0; i < t.size(); i++)\n        ans += cross(t[i] , t[(i + 1) % t.size()]);\n    return (fabs(ans) / 2);\n}\n\nbool isIntersectLL(Point p1, Point p2, Point p3, Point p4)\n{// 同一直線の場合は交差していると判定する.\n\treturn (abs(cross(p2 - p1, p4 - p3)) > EPS || // 傾きが異なる\n\t\tabs(cross(p2 - p1, p4 - p3)) < EPS); // 同じ直線である\n}\nbool isIntersectLS(Point p1, Point p2, Point p3, Point p4)\n{// 同一直線上にある場合も交差と判定\n\treturn (cross(p2 - p1, p3 - p1) * cross(p2 - p1, p4 - p1) < EPS);\n}\nbool isIntersectLP(Point p1, Point p2, Point p)\n{\n\treturn (neq(abs(ccw(p1, p2, p)), 1));\n}\nbool isIntersectSS(Point p1, Point p2, Point p3, Point p4)\n{\n    return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n             ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool isIntersectSP(Point p1, Point p2, Point p)\n{\n\treturn (eq(ccw(p1, p2, p), 0));\n}\nbool isInsideCP(Point c, double r, Point p)\n{\n\treturn (leq(abs(c - p), r));\n}\nbool isInsideCC(Point c1, double r1, Point c2, double r2)\n{\n\treturn (leq(abs(c1 - c2), r1 + r2) && geq(abs(c1 - c2), abs(r1 - r2)));\n}\nbool isInsidePolyP(Polygon gon, Point p)\n{\n    for (int i = 0; i < gon.size(); i++){\n        if (ccw(gon[i], gon[(i + 1) % gon.size()], p) == -1) return (false);\n    }\n    return (true);\n}\n\nPoint projection(Point p1, Point p2, Point p3) //直線p1p2 上への写像\n{\n\tdouble t = dot(p3 - p1, p2 - p1) / norm(p2 - p1);\n\treturn (p1 + (p2 - p1) * t);\n}\nPoint reflection(Point p1, Point p2, Point p3) //直線p1p2 上への反射\n{\n\treturn (p3 + (projection(p1, p2, p3) - p) * 2);\n}\ndouble distanceLP(Point p1, Point p2, Point p)\n{\n\treturn (abs(p - projection(p1, p2, p)));\n}\ndouble distanceLL(Point l1, Point l2, Point m1, Point m2)\n{\n\treturn (isIntersectLL(l1, l2, m1, m2) ? 0 : distanceLP(l1, l2, m1));\n}\ndouble distanceLS(Point l1, Point l2, Point s1, Point s2)\n{\n    if (isIntersectLS(l1, l2, s1, s2)) return (0);\n\treturn (min(distanceLP(l1, l2, s1), distanceLP(l1, l2, s2)));\n}\ndouble distanceSP(Point s1, Point s2, Point p)\n{\n\tPoint r = projection(s1, s2, p);\n\tif (isIntersectSP(s1, s2, r)) return (abs(r - p));\n\treturn (min(abs(s1 - p), abs(s2 - p)));\n}\ndouble distanceSS(Point s1, Point s2, Point t1, Point t2){\n\tif (isIntersectSS(s1, s2, t1, t2)) return (0);\n\treturn (min(min(distanceSP(s1, s2, t1), distanceSP(s1, s2, t2)),\n\t\t\tmin(distanceSP(t1, t2, s1), distanceSP(t1, t2, s2))));\n}\nPoint interPointLL(Point a1, Point a2, Point b1, Point b2)\n{\n\tdouble d = cross(a2 - a1, b2 - b1);\n\tif (abs(d) < EPS) throw \"Segment is Paralell!\";\n\tPoint a = a2 - a1, b = b2 - b1;\n    double t = cross(b, b1 - a1) / cross(b, a);\n    return (a1 + a * t);\n}\nvector<Point> interPointCC(Point c1, double r1, Point c2, double r2)\n{\n\tvector<Point> res;\n\tif (abs(c1 - c2) < EPS) return (vector<Point>()); // 交点が絶対にない\n\tdouble d = abs(c1 - c2);\n\tdouble rc = (d * d + r1 * r1 - r2 * r2) / (2 * d);\n\tdouble rs = sqrt(r1 * r1 - rc * rc);\n\tPoint diff = (c2 - c1) / d;\n\tres.push_back(Point(c1 + diff * Point(rc, rs)));\n\tres.push_back(Point(c1 + diff * Point(rc, -rs)));\n\treturn (res);\n}\nvector<Point> crosspointCL(Point a, double ra, Point b1, Point b2)\n{\n\tvector<Point> res;\n\tdouble dist = distanceLP(b1, b2, a);\n\tif (leq(dist, ra)){\n\t\tPoint s = projection(b1, b2, a);\n\t\tdist = sqrt(ra * ra - dist * dist);\n\t\tPoint t = (b2 - b1) / abs(b2 - b1);\n\t\tres.push_back(s + t * dist);\n\t\tres.push_back(s - t * dist);\n\t}\n\treturn (res);\n}\n\nPoint unitVector(Vector t)\n{\n    double u = abs(t);\n    return (Point(t.x / u , t.y / u));\n}\n\nPoint normalVector(Point p, Point a, Point b)\n{\n    Point v = unitVector(b - a);\n    v = cross(v, p - a) > 0 ? Point(v.y, -v.x) : Point(-v.y, v.x);\n    return v * distanceLP(p, a, b);\n}\n  \ndouble getCos(Vector a, Vector b)\n{\n    return (dot(a, b) / (abs(a) * abs(b)));\n}\n  \ndouble getSin(Vector a, Vector b)\n{\n    double t = getCos(a, b);\n    return (sqrt(1.0 - t * t));\n}\n  \ndouble getArg(Vector v)\n{\n    return (atan2(v.y, v.x));\n}\n\nPoint rotate(Point t, Point p, double r)\n{\n    double ta = cos(r) * (t.x - p.x) - sin(r) * (t.y - p.y) + p.x;\n    double tb = sin(r) * (t.x - p.x) + cos(r) * (t.y - p.y) + p.y;\n    return (Point(ta, tb));\n}\n\nint main()\n{\n\tint N, M;\n\t\n\twhile (scanf(\"%d %d\", &N, &M) && N){\n\t\tvector<Point> P(N);\n\t\tvector<int> to[128];\n\t\tbool exist[128][128] = {0};\n\t\t\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tscanf(\"%lf %lf\", &P[i].x, &P[i].y);\n\t\t\tP[i].id = i;\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < M; i++){\n\t\t\tint x, y;\n\t\t\tscanf(\"%d %d\", &x, &y);\n\t\t\tto[--x].push_back(--y);\n\t\t\tto[y].push_back(x);\n\t\t\texist[x][y] = exist[y][x] = 1;\n\t\t}\n\t\t\n\t\tPolygon Q = P;\n\t\tQ = conhel(Q);\n\t\t\n\t\tvector<int> belong[128][128];\n\t\tfor (int i = 0; i < Q.size(); i++){\n\t\t\tint u = Q[i].id, v = Q[(i + 1) % Q.size()].id;\n\t\t\tbelong[u][v].push_back(0);\n\t\t\tbelong[v][u].push_back(0);\n\t\t}\n\t\tint k = 1;\n\t\tset<vector<int> > s;\n\t\t\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tfor (int j = 0; j < N; j++){\n\t\t\t\tif (P[j] < P[i] && exist[i][j] && belong[i][j].size() < 2){\n\t\t\t\t\tvector<int> v;\n\t\t\t\t\tv.push_back(i);\n\t\t\t\t\tv.push_back(j);\n\t\t\t\t\twhile (1){\n\t\t\t\t\t\tint nextP = -1;\n\t\t\t\t\t\tint vv = v[v.size() - 1], uu = v[v.size() - 2];\n\t\t\t\t\t\tfor (int l = 0; l < to[vv].size(); l++){\n\t\t\t\t\t\t\tif (to[vv][l] == vv || to[vv][l] == uu) continue;\n\t\t\t\t\t\t\tif (ccw(P[uu], P[vv], P[to[vv][l]]) < 0){\n\t\t\t\t\t\t\t\tif (nextP == -1 || getCos(P[uu] - P[vv], P[to[vv][l]] - P[vv]) > getCos(P[uu] - P[vv], P[nextP] - P[vv])) nextP = to[vv][l];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tassert(nextP != -1);\n\t\t\t\t\t\tif (nextP == i) break;\n\t\t\t\t\t\tv.push_back(nextP);\n\t\t\t\t\t}\n\t\t\t\t\tvector<int> ss = v;\n\t\t\t\t\tsort(ss.begin(), ss.end());\n\t\t\t\t\tif (s.find(ss) != s.end()) continue;\n\t\t\t\t\telse s.insert(ss);\n\t\t\t\t\tfor (int it = 0; it < v.size(); it++){\n\t\t\t\t\t\tint uu = v[it], vv = v[(it + 1) % v.size()];\n\t\t\t\t\t\tbelong[uu][vv].push_back(k);\n\t\t\t\t\t\tbelong[vv][uu].push_back(k);\n\t\t\t\t\t}\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int> G[1024];\n\t\t\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tfor (int j = i + 1; j < N; j++){\n\t\t\t\tif (belong[i][j].size() == 2){\n\t\t\t\t\tint u = belong[i][j][0], v = belong[i][j][1];\n\t\t\t\t\tG[u].push_back(v);\n\t\t\t\t\tG[v].push_back(u);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tint done[1024];\n\t\tfill(done, done + 1024, -1);\n\t\tqueue<pair<int, int> > q;\n\t\t\n\t\tfor(q.push(make_pair(0, 0)); q.size(); q.pop()){\n\t\t\tpair<int, int> x = q.front();\n\t\t\tif (~done[x.first]) continue;\n\t\t\tdone[x.first] = x.second;\n\t\t\tans = max(ans, x.second);\n\t\t\t\n\t\t\tfor (int i = 0; i < G[x.first].size(); i++){\n\t\t\t\tq.push(make_pair(G[x.first][i], x.second + 1));\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <vector>\n#include <valarray>\n#include <array>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <random>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\ntypedef double R;\ntypedef complex<R> P;\n\nconst R EPS = 1e-9;\nconst R PI = acos((R)(-1));\n\nint sgn(R a) {\n    if (a < -EPS) return -1;\n    if (a > EPS) return 1;\n    return 0;\n}\n\nR cross(P a, P b) { return a.real()*b.imag() - a.imag()*b.real(); }\n\ntypedef vector<P> Pol;\n\nP cu(const Pol &p, int i) {\n    int s = p.size();\n    return p[(i%s+s)%s];\n}\n\nR area_naive(const Pol &p) {\n    R u = 0;\n    for (int i = 0; i < (int)p.size(); i++) {\n        u += cross(cu(p, i), cu(p, i+1));\n    }\n    return u/2;\n}\n\nR area(const Pol &p) {\n    return abs(area_naive(p));\n}\n\n/*\n -1 -> clock\n 0 -> non polygon\n 1 -> counter clock\n */\nint iscclock(const Pol &p) {\n    return sgn(area_naive(p));\n}\n\nint dualGraph(P p[], vector<int> g[], int n,\n    Pol pol[], vector<int> rg[]) {\n    map<pair<int, int>, int> mp;\n    for (int i = 0; i < n; i++) {\n        sort(g[i].begin(), g[i].end(), [&](int l, int r){\n            return arg(p[l]-p[i]) > arg(p[r]-p[i]);\n        });\n        for (int j = 0; j < (int)g[i].size(); j++) {\n            mp[make_pair(i, g[i][j])] = j;\n        }\n    }\n\n    vector<vector<int>> idx(n), rev(n);\n    for (int i = 0; i < n; i++) {\n        idx[i] = vector<int>(g[i].size(), -1);\n        rev[i].resize(g[i].size());\n        for (int j = 0; j < (int)g[i].size(); j++) {\n            rev[i][j] = mp[make_pair(g[i][j], i)];\n        }\n    }\n\n    int idc = 1;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < (int)g[i].size(); j++) {\n            if (idx[i][j] != -1) continue;\n            Pol po;\n            int ii = i, jj = j;\n            while (idx[ii][jj] != -2) {\n                po.push_back(p[ii]);\n                idx[ii][jj] = -2;\n                int ni = g[ii][jj];\n                int nj = (rev[ii][jj]+1) % g[ni].size();\n                ii = ni; jj = nj;\n            }\n            int id;\n            if (iscclock(po) != 1) {\n                id = 0;\n            } else {\n                id = idc;\n                pol[idc] = po;\n                idc++;\n            }\n            while (idx[ii][jj] == -2) {\n                idx[ii][jj] = id;\n                int ni = g[ii][jj];\n                int nj = (rev[ii][jj]+1) % g[ni].size();\n                ii = ni; jj = nj;\n            }\n        }\n    }\n\n    for (int i = 0; i < idc; i++) {\n        rg[i].clear();\n    }\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < (int)g[i].size(); j++) {\n            if (idx[i][j] < 0) continue;\n            rg[idx[i][j]].push_back(idx[g[i][j]][rev[i][j]]);\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        sort(rg[i].begin(), rg[i].end());\n        rg[i].erase(unique(rg[i].begin(), rg[i].end()), rg[i].end());\n    }\n\n    return idc;\n}\n\nconst int MN = 110;\n\n\nP p[MN];\nvector<int> g[MN];\n\nPol pol[2*MN];\nvector<int> rg[2*MN];\n\nint dist[2*MN][2*MN];\n\nbool solve() {\n    int c, w;\n    cin >> c >> w;\n    if (!c) return false;\n\n    for (int i = 0; i < c; i++) {\n        R x, y;\n        cin >> x >> y;\n        p[i] = P(x, y);\n        g[i].clear();\n    }\n\n    for (int i = 0; i < w; i++) {\n        int s, t;\n        cin >> s >> t; s--; t--;\n        g[s].push_back(t);\n        g[t].push_back(s);\n    }\n\n    dualGraph(p, g, c, pol, rg);\n    int ma = 0;\n    bool used[2*MN] = {};\n    queue<pair<int, int>> q;\n    q.push(make_pair(0, 0));\n    while (q.size()) {\n        int t, di;\n        tie(t, di) = q.front(); q.pop();\n        if (used[t]) continue;\n        used[t] = true;\n        ma = max(ma, di);\n        for (int d: rg[t]) {\n            if (used[d]) continue;\n            q.push(make_pair(d, di+1));\n        }\n    }\n    cout << ma << endl;\n    return true;\n}\n\n\nint main() {\n    while (solve()) {}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <cmath>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\n#define x first\n#define y second\n\ntypedef pair<int,int> pii;\n\nint C, W;\nvector<pii> pole;\nvector<vector<int> > edge;\nvector<pii> edge_set;\n\nvector<vector<int> > face;\nvector<vector<int> > dual_e;\nvector<pii> dual_edge_set;\n\nvector<int> detect_f(int start, int cur, int prev) {\n\tvector<int> res;\n\tif(cur == start) {\n\t\tres.push_back(cur);\n\t\treturn res;\n\t}\n\n\tint bx, by, cx, cy;\n\tdouble mn = 10.0;\n\tint nx = -1;\n\tbx = pole[prev].x;\n\tby = pole[prev].y;\n\tcx = pole[cur].x;\n\tcy = pole[cur].y;\n\tfor(int i = 0; i < edge[cur].size(); i++) {\n\t\tif(edge[cur][i] != prev) {\n\t\t\tdouble theta, phi, ag;\n\t\t\tint ax, ay;\n\t\t\tax = pole[edge[cur][i]].x;\n\t\t\tay = pole[edge[cur][i]].y;\n\t\t\ttheta = atan2(by - cy, bx - cx);\n\t\t\tphi   = atan2(ay - cy, ax - cx);\n\t\t\tag = phi - theta + 4*M_PI;\n\t\t\twhile(ag > 2*M_PI) ag -= 2*M_PI;\n\t\t\tif(ag < mn) {\n\t\t\t\tnx = edge[cur][i];\n\t\t\t\tmn = ag;\n\t\t\t}\n\t\t}\n\t}\n\n\tres = detect_f(start, nx, cur);\n\tres.push_back(cur);\n\treturn res;\n}\n\nint face_indx(vector<int> f) {\n\tfor(int i = 0; i < face.size(); i++) {\n\t\tif(face[i].size() == f.size()) for(int j = 0; j < face[i].size(); j++) {\n\t\t\tbool flg = true;\n\t\t\tfor(int k = 0; k < face[i].size() && flg; k++) {\n\t\t\t\tflg &= face[i][(j+k)%face[i].size()] == f[k];\n\t\t\t}\n\t\t\tif(flg) return i;\n\t\t}\n\t}\n\treturn -1;\n}\n\nvoid mkdual() {\n\tfor(int i = 0; i < edge_set.size(); i++) {\n\t\tpii de, e = edge_set[i];\n\t\tfor(int i_ = 0; i_ < 2; i_++) {\n\t\t\tvector<int> f = detect_f(e.first, e.second, e.first);\n\t\t\tint indx;\n\t\t\tindx = face_indx(f);\n\t\t\tif(indx < 0) {\n\t\t\t\tindx = face.size();\n\t\t\t\tface.push_back(f);\n\t\t\t}\n\t\t\tde.first = indx;\n\t\t\tswap(e.first, e.second);\n\t\t\tswap(de.first, de.second);\n\t\t}\n\t\tdual_edge_set.push_back(de);\n\t}\n\tdual_e.resize(face.size());\n\tsort(dual_edge_set.begin(), dual_edge_set.end());\n\tdual_edge_set.erase(unique(dual_edge_set.begin(), dual_edge_set.end()), dual_edge_set.end());\n\tfor(int i = 0; i < dual_edge_set.size(); i++) {\n\t\tdual_e[dual_edge_set[i].first].push_back(dual_edge_set[i].second);\n\t\tdual_e[dual_edge_set[i].second].push_back(dual_edge_set[i].first);\n\t}\n}\n\nint solve() {\n\tint ur = 0;\n\tfor(int i = 0; i < pole.size(); i++) {\n\t\tif(pole[ur] < pole[i])\n\t\t\tur = i;\n\t}\n\tint nx = -1;\n\tdouble mn_arg = 100;\n\tfor(int i = 0; i < edge[ur].size(); i++) {\n\t\tdouble arg;\n\t\targ = atan2(pole[edge[ur][i]].y - pole[ur].y,\n\t\t\t\tpole[edge[ur][i]].x - pole[ur].x) + 4 * M_PI;\n\t\twhile(arg > 2 * M_PI) arg -= 2 * M_PI;\n\t\t\n\t\tif(arg < mn_arg) {\n\t\t\tmn_arg = arg;\n\t\t\tnx = edge[ur][i];\n\t\t}\n\t}\n\tint start;\n\tvector<int> mnpath;\n\tpriority_queue<pii> q;\n\tconst int INF = 1e9;\n\tstart = face_indx(detect_f(ur, nx, ur));\n\tmnpath.resize(face.size());\n\tfor(int i = 0; i < mnpath.size(); i++) mnpath[i] = INF;\n\tq.push(pii(0,start));\n\twhile(!q.empty()) {\n\t\tpii a = q.top(); q.pop();\n\t\tif(mnpath[a.second] > -a.first) {\n\t\t\tmnpath[a.second] = -a.first;\n\t\t}\n\t\tfor(int i = 0; i < dual_e[a.second].size(); i++) {\n\t\t\tif(mnpath[dual_e[a.second][i]] > -a.first + 1) {\n\t\t\t\tmnpath[dual_e[a.second][i]] = -a.first + 1;\n\t\t\t\tq.push(pii(a.first -1, dual_e[a.second][i]));\n\t\t\t}\n\t\t}\n\t}\n\tint res = -1;\n\tfor(int i = 0; i < mnpath.size(); i++) {\n\t\tres = max(res, mnpath[i]);\n\t}\n\treturn res;\n}\n\nint main() {\n\twhile(cin >> C >> W, C || W) {\n\t\tpole.clear();\n\t\tedge.clear();\n\t\tedge_set.clear();\n\t\tface.clear();\n\t\tdual_edge_set.clear();\n\t\tdual_e.clear();\n\t\tpole.resize(C);\n\t\tedge.resize(C);\n\t\tfor(int i = 0; i < pole.size(); i++) {\n\t\t\tcin >> pole[i].x >> pole[i].y;\n\t\t}\n\t\tfor(int i = 0; i < W; i++) {\n\t\t\tint a, b;\n\t\t\tcin >> a >> b; a--; b--;\n\t\t\tedge_set.push_back(pii(a,b));\n\t\t\tedge[a].push_back(b);\n\t\t\tedge[b].push_back(a);\n\t\t}\n\t\tmkdual();\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n==0) ? 1 : 10*TEN(n-1); }\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\ntemplate<class T> ostream& operator<<(ostream& os, const V<T> &v) {\n    cout << \"[\";\n    for (auto p: v) cout << p << \", \";\n    cout << \"]\";\n    return os;\n}\n\ntemplate<class T>\nstruct Pt2 {\n    T x, y;\n    Pt2() {}\n    Pt2(T _x, T _y) : x(_x), y(_y) {}\n    Pt2 operator+(const Pt2 &r) const { return Pt2(x+r.x, y+r.y); }\n    Pt2 operator-(const Pt2 &r) const { return Pt2(x-r.x, y-r.y); }\n\n    Pt2 operator-() const { return Pt2(-x, -y); }\n\n    T abs() const { return sqrt(x*x + y*y); }\n    T rabs() const { return max(x, y); } // robust abs\n    T arg() const { return atan2(y, x); }\n};\ntemplate<class T> ostream& operator<<(ostream& os, const Pt2<T> &p) {\n    os << \"(\" << p.x << \", \" << p.y << \")\";\n    return os;\n}\n\nusing D = double;\nusing P = Pt2<D>;\n\nconst D PI = acos(D(-1)), EPS = 1e-10;\n\nint sgn(D a) {\n    if (abs(a) <= EPS) return 0;\n    return (a < 0) ? -1 : 1;\n}\n//relative sign\nint rsgn(D a, D f) {\n    if (abs(a) <= f*EPS) return 0;\n    return (a < 0) ? -1 : 1;\n}\nbool near(P a, P b) { return !sgn((a-b).abs()); }\n\nbool lessP(P l, P r) {\n    if (sgn(r.x-l.x)) return l.x < r.x;\n    if (sgn(r.y-l.y)) return l.y < r.y;\n    return false;\n}\n\nD cross(P a, P b) { return a.x*b.y - a.y*b.x; }\nD dot(P a, P b) { return a.x*b.x + a.y*b.y; }\n\n// -2, -1, 0, 1, 2 : front, clock, on, cclock, back\nint ccw(P b, P c) {\n    int s = rsgn(cross(b, c), b.rabs());\n    if (s) return s;\n    if (!sgn(c.rabs()) || !sgn((c-b).rabs())) return 0;\n    if (dot(b, c) < 0) return 2;\n    if (dot(-b, c-b) < 0) return -2;\n    return 0;\n}\nint ccw(P a, P b, P c) { return ccw(b-a, c-a); }\n\nstruct L {\n    P s, t;\n    L() {}\n    L(P s, P t) : s(s), t(t) {}\n    P vec() const { return t-s; }\n    D abs() const { return vec().abs(); }\n    D arg() const { return vec().arg(); }\n};\nint ccw(L l, P p) { return ccw(l.s, l.t, p); }\n\nusing Pol = V<P>;\n\n//cycle at\nconst P& c_at(const Pol &pol, int i) {\n    int n = int(pol.size());\n    assert(0 <= i && i < 2*n);\n    return pol[(i < n) ? i : i-n];\n}\n\nD area2_noabs(const Pol &p) {\n    D u = 0;\n    for (size_t i = 0; i < p.size(); i++) {\n        u += cross(p[i], c_at(p, i+1));\n    }\n    return u;\n}\n\n// -1: cw, 0: line, 1: ccw\nint is_ccw(const Pol &p) {\n    return sgn(area2_noabs(p));\n}\n\n// 0: outside, 1: on line, 2: inside\nint contains(const Pol &pol, P p) {\n    int in = -1;\n    for (int i = 0; i < int(pol.size()); i++) {\n        P a = pol[i], b = c_at(pol, i+1);\n        if (ccw(a, b, p) == 0) return 1;\n        if (a.y > b.y) swap(a, b);\n        if (a.y <= p.y && p.y < b.y && cross(a-p, b-p) < 0) in *= -1;\n    }\n    return in+1;\n}\n\n\n/*\n 双対グラフを作成\n pol, rgの要素は2*n-4個確保しておくこと\n gはめちゃくちゃに破壊される\n もし連結でないグラフ、しかも内包があるグラフに行うとrgは0が複数混入する\n 0は、その連結成分だけに注目したときの外側の意味。本当に外側か判定したいなら\n contains等を使用すること\n */\nstruct DualGraph {\n    V<Pol> pols;\n    VV<int> g;\n};\nDualGraph dualGraph(V<P> ps, VV<int> g) {\n    assert(ps.size() == g.size());\n    int n = int(ps.size());\n    using Pi = pair<int, int>;\n    map<Pi, int> mp;\n    for (int i = 0; i < n; i++) {\n        sort(g[i].begin(), g[i].end());\n        assert(unique(g[i].begin(), g[i].end()) == g[i].end());\n        sort(g[i].begin(), g[i].end(), [&](int l, int r){\n            return (ps[l]-ps[i]).arg() > (ps[r]-ps[i]).arg();\n        });\n        for (int j = 0; j < int(g[i].size()); j++) {\n            mp[Pi(i, g[i][j])] = j;\n        }\n    }\n\n    VV<int> vis(n), rev(n);\n    for (int i = 0; i < n; i++) {\n        vis[i] = V<int>(g[i].size(), -3);\n        for (int d: g[i]) {\n            rev[i].push_back(mp[Pi(d, i)]);\n        }\n    }\n\n    V<Pol> pols;\n    int idc = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < int(g[i].size()); j++) {\n            if (vis[i][j] != -3) continue;\n            Pol pol;\n            int p = i, idx = j;\n            while (vis[p][idx] != -2) {\n                pol.push_back(ps[p]);\n                vis[p][idx] = -2;\n                int np = g[p][idx];\n                int nidx = rev[p][idx]+1;\n                if (nidx == int(g[np].size())) nidx = 0;\n\n                p = np; idx = nidx;\n            }\n            int id = -1;\n            if (is_ccw(pol) == 1) {\n                id = idc;\n                pols.push_back(pol);\n                idc++;\n            }\n//            cout << \"FIND \" << id << \" \" << is_ccw(pol) << \" \" << pol << endl;\n            while (vis[p][idx] == -2) {\n                vis[p][idx] = id;\n                int np = g[p][idx];\n                int nidx = rev[p][idx]+1;\n                if (nidx == int(g[np].size())) nidx = 0;\n\n                p = np; idx = nidx;\n            }\n        }\n    }\n    VV<int> g2(idc+1);\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < int(g[i].size()); j++) {\n            int x = vis[i][j], y = vis[g[i][j]][rev[i][j]];\n            if (x == -1) x = idc;\n            if (y == -1) y = idc;\n            g2[x].push_back(y);\n        }\n    }\n    for (int i = 0; i <= idc; i++) {\n        sort(begin(g2[i]), end(g2[i]));\n        g2[i].erase(unique(begin(g2[i]), end(g2[i])), end(g2[i]));\n    }\n\n    return DualGraph{pols, g2};\n}\n\nbool solve() {\n    int c, w;\n    cin >> c >> w;\n    if (!c) return false;\n    \n    V<P> p(c);\n    for (int i = 0; i < c; i++) {\n        D x, y;\n        cin >> x >> y;\n        p[i] = P(x, y);\n    }\n    \n    VV<int> g(c);\n    for (int i = 0; i < w; i++) {\n        int s, t;\n        cin >> s >> t; s--; t--;\n        g[s].push_back(t);\n        g[t].push_back(s);\n    }\n\n    auto dg = dualGraph(p, g);\n    int n = int(dg.g.size());\n\n    // cout << \"DEBUG: \" << endl;\n    // cout << n << endl;\n    // for (int i = 0; i < n-1; i++) {\n    //     for (P p: dg.pols[i]) {\n    //         cout << p << \", \";\n    //     } cout << endl;\n    // }\n    V<int> dist(n, TEN(9));\n\n    queue<int> q;\n    dist[n-1] = 0;\n    q.push(n-1);\n    while (q.size()) {\n        int p = q.front(); q.pop();\n        for (int d: dg.g[p]) {\n            if (dist[d] <= dist[p] + 1) continue;\n            dist[d] = dist[p] + 1;\n            q.push(d);\n        }\n    }\n    int ma = -1;\n    for (int i = 0; i < n; i++) ma = max(ma, dist[i]);\n    cout << ma << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << setprecision(20);\n\n    while (solve()) {}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <ctime>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <fstream>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <numeric>\n#include <cassert>\nusing namespace std;\n\ntypedef complex<double> P;\nconst double PI = acos(-1);\n\ndouble fx(double rd){\n\twhile( rd < -1e-9 )   rd += 2*PI;\n\twhile( rd >= 2*PI - 1e-9) rd -= 2*PI;\n\treturn rd;\n}\ndouble R(P a){\n\tdouble rd = atan2(a.imag(),a.real());\n\treturn fx(rd);\n}\n\nint C,W;\n\nint wsc[300] , wtc[300];\nP c[100];\nstruct NODE{\n\tint from,to,id;\n\tdouble rad;\n\tNODE(int from,int to,int id) : from(from) , to(to) , id(id) {\n\t\trad = R(c[to]-c[from]);\n\t}\n\tNODE(){}\n};\nbool operator < (const NODE &a,const NODE &b){\n\treturn a.rad < b.rad;\n}\nvector<NODE> geo[100];\nint done[100];\n\nint start;\nint get(int x,int prev,vector<int> &ad){\n\tif( x == start ) return 1;\n\tif( done[x] ) return 0;\n\telse done[x] = true;\n\t\n\tfor(int i = 0 ; i < geo[x].size() ; i++){\n\t\tint y = (i+1)%geo[x].size();\n\t\tif( geo[x][i].to == prev ){\t\t\t\n\t\t\tif( get(geo[x][y].to,x,ad) ){\n\t\t\t\t//ad.push_back(x);\n\t\t\t\tad.push_back(geo[x][y].id);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(){\n\twhile(cin >> C >> W && C){\n\t\tfor(int i = 0 ; i < 100 ; i++) geo[i].clear();\n\t\tfor(int i = 0 ; i < C ; i++)\n\t\t\tcin >> c[i].real() >> c[i].imag();\n\t\tfor(int i = 0 ; i < W ; i++){\n\t\t\tint s,t;\n\t\t\tcin >> s >> t;\n\t\t\ts--,t--;\n\t\t\tgeo[s].push_back(NODE(s,t,i));\n\t\t\tgeo[t].push_back(NODE(t,s,i));\n\t\t\twsc[i] = s;\n\t\t\twtc[i] = t;\n\t\t}\n\t\tfor(int i = 0 ; i < 100 ; i++) sort(geo[i].begin(),geo[i].end());\n\t\t\n\t\tvector< vector<int> > wallset;\n\t\tfor(int _ = 0 ; _ < 2 ; _++){\n\t\t\tfor(int i = 0 ; i < W ; i++){\n\t\t\t\tmemset(done,0,sizeof(done));\n\t\t\t\tstart = wsc[i];\n\t\t\t\tvector<int> a;\n\t\t\t\tif( get(wtc[i],wsc[i],a) ){\n\t\t\t\t\t//a.push_back(wsc[i]);\n\t\t\t\t\ta.push_back(i);\n\t\t\t\t\tsort(a.begin(),a.end());\n\t\t\t\t\twallset.push_back(a);\n\t\t\t\t}\n\t\t\t\tswap(wsc[i],wtc[i]);\n\t\t\t}\n\t\t}\n\t\tsort(wallset.begin(),wallset.end());\n\t\twallset.erase(unique(wallset.begin(),wallset.end()),wallset.end());\n\t\t\n\t\t\n\t\tint wf[301][301]={};\n\t\tfor(int i = 0 ; i < 301 ; i++)\n\t\t\tfor(int j = 0 ; j < 301 ; j++)\n\t\t\t\twf[i][j] = i==j?0:1e9;\n\t\tint N = wallset.size();\n\t\tvector<int> wall_share[300];\n\t\t\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\tfor(int j = 0 ; j < wallset[i].size() ; j++){\n\t\t\t\twall_share[wallset[i][j]].push_back(i);\n\t\t\t\t//cout << wallset[i][j] << \" \";\n\t\t\t}\n\t\t\t//cout << endl;\n\t\t}\n\t\tfor(int i = 0 ; i < W ; i++){\n\t\t\tfor(int j = 0 ; j <wall_share[i].size() ; j++){\n\t\t\t\tfor(int k = 0 ; k < wall_share[i].size() ; k++){\n\t\t\t\t\tif(j!=k)wf[wall_share[i][j]][wall_share[i][k]] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\tfor(int j = 0 ; j < N ; j++){\n\t\t\t\tfor(int k = 0 ; k < N ; k++){\n\t\t\t\t\twf[j][k] = min(wf[j][k],wf[j][i]+wf[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 1;\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\tfor(int j = 0 ; j < N ; j++)\n\t\t\tans = max( ans , wf[i][j] );\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cassert>\nusing namespace std;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n\treturn abs(a.real()-b.real()) > EPS ? real(a) < real(b) : imag(a) + EPS < imag(b);\n    //return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\nP readPoint(){\n\tdouble x,y;\n\tcin >> x >> y;\n\treturn P(x,y);\n}\n\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\ntypedef vector<P> G;\n\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\n\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\nP reflection(const L &l, const P &p) {\n  return p + 2. * (projection(l, p) - p);\n}\ndouble distanceLP(const L &l, const P &p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\n#define rep(i,N) for(int i = 0 ; i < N ; i++)\nP ps[110];\nvector<int> g[110];\n\nvector<int> normalize(vector<int> v){\n\tauto it = min_element(v.begin(),v.end());\n\trotate(v.begin(),it,v.end());\n\treturn v;\n}\n\nint done[110];\nvoid f(int a,int b,int s,vector<int> &v){\n\tv.push_back(b);\n\tif( b == s ) return;\n\tif( done[b]++ ) throw 0;\n\tsort(g[b].begin(),g[b].end(),[&](int x,int y){\n\t\tP A = ps[x] - ps[b];\n\t\tP B = ps[y] - ps[b];\n\t\treturn cross(A,B) > 0;\n\t});\n\trotate(g[b].begin(),find(g[b].begin(),g[b].end(),a),g[b].end());\n\tf(b,g[b][1],s,v);\n}\n\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n\ndouble area2(const G& P) {\n  double A = 0;\n  for (int i = 0; i < P.size(); ++i) \n    A += cross(curr(P, i), next(P, i));\n  return A;\n}\n\nint main(){\n\t\n\tint C,W;\n\twhile( cin >> C >> W && (C||W) ){\n\t\trep(i,C) ps[i] = readPoint();\n\t\trep(i,C) g[i].clear();\n\t\trep(i,W){\n\t\t\tint a,b;\n\t\t\tcin >> a >> b;\n\t\t\t--a,--b;\n\t\t\tg[a].push_back(b);\n\t\t\tg[b].push_back(a);\n\t\t}\n\t\tvector< vector<int> > poly;\n\t\tset< set<int> > prevs; \n\t\trep(i,C){\n\t\t\trep(j,g[i].size()){\n\t\t\t\ttry{\n\t\t\t\t\tmemset(done,0,sizeof(done));\n\t\t\t\t\tvector<int> v;\n\t\t\t\t\tf(i,g[i][j],i,v);\n\t\t\t\t\tif( prevs.count(set<int>(v.begin(),v.end())) ) continue;\n\t\t\t\t\tpoly.push_back(normalize(v));\n\t\t\t\t\tprevs.insert(set<int>(v.begin(),v.end()));\n\t\t\t\t}catch(int x){\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(poly.begin(),poly.end());\n\t\tpoly.erase(unique(poly.begin(),poly.end()),poly.end());\n\t\tsort(poly.begin(),poly.end(),[&](vector<int> a,vector<int> b){\n\t\t\tvector<P> g1,g2;\n\t\t\trep(k,a.size()) g1.push_back(ps[a[k]]);\n\t\t\trep(k,b.size()) g2.push_back(ps[b[k]]);\n\t\t\treturn abs(area2(g1)) > abs(area2(g2));\n\t\t});\n\t\tmap< pair<int,int>, vector<int> > edgs;\n\t\tfor(int i = 0 ; i < poly.size() ; i++){\n\t\t\tfor(int j = 0 ; j < poly[i].size() ; j++){\n\t\t\t\tint A = curr(poly[i],j);\n\t\t\t\t//cout << A << \" \";\n\t\t\t\tint B = next(poly[i],j);\n\t\t\t\tif( A > B ) swap(A,B);\n\t\t\t\tedgs[pair<int,int>(A,B)].push_back(i);\n\t\t\t}\n\t\t\t//cout << endl;\n\t\t}\n\t\tint M = poly.size();\n\t\tint wf[M][M];\n\t\trep(i,M) rep(j,M){\n\t\t\twf[i][j] = i==j?0:1e9;\n\t\t}\n\t\t\n\t\tfor( auto x : edgs ){\n\t\t\tvector<int> v = x.second;\n\t\t\tif( v.size() < 2 ) v.push_back(0);\n\t\t\tassert( v.size() == 2 );\n\t\t\tif( v[0] != v[1] ) wf[v[0]][v[1]] = wf[v[1]][v[0]] = 1;\n\t\t}\n\t\trep(i,M)rep(j,M)rep(k,M) wf[j][k] = min(wf[j][i]+wf[i][k],wf[j][k]);\n\t\tint ans = 1;\n\t\trep(i,M){\n\t\t\tans = max(ans,wf[i][0]);\n\t\t}\n\t\tcout << ans << endl;\n\t\t\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cassert>\nusing namespace std;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n\treturn abs(a.real()-b.real()) > EPS ? real(a) < real(b) : imag(a) + EPS < imag(b);\n    //return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\nP readPoint(){\n\tdouble x,y;\n\tcin >> x >> y;\n\treturn P(x,y);\n}\n\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\ntypedef vector<P> G;\n\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\n\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\nP reflection(const L &l, const P &p) {\n  return p + 2. * (projection(l, p) - p);\n}\ndouble distanceLP(const L &l, const P &p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\n#define rep(i,N) for(int i = 0 ; i < N ; i++)\nP ps[110];\nvector<int> g[110];\n\nvector<int> normalize(vector<int> v){\n\tauto it = min_element(v.begin(),v.end());\n\trotate(v.begin(),it,v.end());\n\treturn v;\n}\n\nint done[110];\nvoid f(int a,int b,int s,vector<int> &v){\n\tv.push_back(b);\n\tif( b == s ) return;\n\tif( done[b]++ ) throw 0;\n\tsort(g[b].begin(),g[b].end(),[&](int x,int y){\n\t\tP A = ps[x] - ps[b];\n\t\tP B = ps[y] - ps[b];\n\t\treturn cross(A,B) > 0;\n\t});\n\trotate(g[b].begin(),find(g[b].begin(),g[b].end(),a),g[b].end());\n\tf(b,g[b][1],s,v);\n}\n\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n\ndouble area2(const G& P) {\n  double A = 0;\n  for (int i = 0; i < P.size(); ++i) \n    A += cross(curr(P, i), next(P, i));\n  return A;\n}\n\nint main(){\n\t\n\tint C,W;\n\twhile( cin >> C >> W && (C||W) ){\n\t\trep(i,C) ps[i] = readPoint();\n\t\trep(i,C) g[i].clear();\n\t\trep(i,W){\n\t\t\tint a,b;\n\t\t\tcin >> a >> b;\n\t\t\t--a,--b;\n\t\t\tg[a].push_back(b);\n\t\t\tg[b].push_back(a);\n\t\t}\n\t\tvector< vector<int> > poly;\n\t\trep(i,C){\n\t\t\trep(j,g[i].size()){\n\t\t\t\ttry{\n\t\t\t\t\tmemset(done,0,sizeof(done));\n\t\t\t\t\tvector<int> v;\n\t\t\t\t\tf(i,g[i][j],i,v);\n\t\t\t\t\tvector<P> g;\n\t\t\t\t\trep(k,v.size())g.push_back(ps[v[k]]);\n\t\t\t\t\tif( area2(g) > 0 ){ continue; }\n\t\t\t\t\tpoly.push_back(normalize(v));\n\t\t\t\t}catch(int x){\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(poly.begin(),poly.end());\n\t\tpoly.erase(unique(poly.begin(),poly.end()),poly.end());\n\t\t\n\t\tmap< pair<int,int>, vector<int> > edgs;\n\t\tfor(int i = 0 ; i < poly.size() ; i++){\n\t\t\tfor(int j = 0 ; j < poly[i].size() ; j++){\n\t\t\t\tint A = curr(poly[i],j);\n\t\t\t\tint B = next(poly[i],j);\n\t\t\t\tif( A > B ) swap(A,B);\n\t\t\t\tedgs[pair<int,int>(A,B)].push_back(i);\n\t\t\t}\n\t\t}\n\t\tint M = poly.size() + 1;\n\t\tint wf[M][M];\n\t\trep(i,M) rep(j,M){\n\t\t\twf[i][j] = i==j?0:1e9;\n\t\t}\n\t\t\n\t\tfor( auto x : edgs ){\n\t\t\tvector<int> v = x.second;\n\t\t\tif( v.size() < 2 ) v.push_back(M-1);\n\t\t\twf[v[0]][v[1]] = wf[v[1]][v[0]] = 1;\n\t\t}\n\t\trep(i,M)rep(j,M)rep(k,M) wf[j][k] = min(wf[j][i]+wf[i][k],wf[j][k]);\n\t\tint ans = 0;\n\t\trep(i,M){\n\t\t\tif( wf[i][M-1] != 1e9 ) \tans = max(ans,wf[i][M-1]);\n\t\t}\n\t\tcout << ans << endl;\n\t\t\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst double EPS = 1e-10;\nconst double INF = 1e12;\ntypedef complex<double> P;\ntypedef pair<P,int> PP;\ntypedef pair<P,P> L;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a)!=real(b)?real(a)<real(b):imag(a)<imag(b);\n  }\n}\nbool cmp(PP aa,PP bb) {\n  P a=aa.first,b=bb.first;\n  return atan2(a.imag(),a.real())<atan2(b.imag(),b.real());\n}\ndouble cross(const P& a, const P& b) {return imag(conj(a)*b);}\ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\ndouble area(vector<P> p) {\n  double a=0;\n  for(int i=0; i<(int)p.size(); i++) a+=cross(p[i],p[(i+1)%p.size()]);\n  return a/2;\n}\n\nint main() {\n  int n,m;\n  while(cin >> n >> m && n) {\n    P a[n];\n    vector<PP> g[n];\n    vector<int> v[n];\n    for(int i=0,x,y; i<n; i++) {\n      cin >> x >> y;\n      a[i]=P(x,y);\n    }\n    for(int i=0,x,y; i<m; i++) {\n      cin >> x >> y;\n      x--,y--;\n      g[x].push_back(PP(a[y]-a[x],y));\n      g[y].push_back(PP(a[x]-a[y],x));\n    }\n    for(int i=0; i<n; i++) {\n      sort(g[i].begin(),g[i].end(),cmp);\n      for(int j=0; j<g[i].size(); j++) v[i].push_back(g[i][j].second);\n    }\n    set<vector<int> > sv;\n    map<int,set<P> > ma;\n    int N=0;\n    for(int i=0; i<n; i++) {\n      for(int j=0; j<v[i].size(); j++) {\n        int x=i,y=v[i][j];\n        vector<int> p;\n        vector<P> p2;\n        while(!ma[N].count(P(min(x,y),max(x,y)))) {\n          p.push_back(x);\n          p2.push_back(a[x]);\n          ma[N].insert(P(min(x,y),max(x,y)));\n          int l=0;\n          for(l=0;l<v[y].size();l++) {\n            if(v[y][l]==x) break;\n          }\n          int yy=v[y][(l-1+v[y].size())%v[y].size()];\n          x=y;\n          y=yy;\n        }\n        sort(p.begin(),p.end());\n        if(area(p2)>0&&!sv.count(p)) {\n          N++;\n          sv.insert(p);\n        } else ma[N].clear();\n      }\n    }\n    int d[N];\n    fill(d,d+N,1<<29);\n    vector<int> e[N];\n    queue<int> que;\n    for(int i=0; i<N; i++) {\n      set<P> s=ma[i];\n      bool f=0;\n      for(set<P>::iterator it=s.begin(); it!=s.end(); it++) {\n        bool ff=0;\n        for(int j=0; j<N; j++) {\n          if(i==j) continue;\n          if(ma[j].count(*it)) {\n            e[i].push_back(j);\n            ff=1;\n          }\n        }\n        if(!ff) f=1;\n      }\n      if(f) {\n        d[i]=1;\n        que.push(i);\n      }\n    }\n    if(N==1) {\n      d[0]=1;\n      que.push(0);\n    }\n    while(!que.empty()) {\n      int x=que.front();que.pop();\n      for(int i=0; i<e[x].size(); i++) {\n        int y=e[x][i];\n        if(d[y]!=1<<29) continue;\n        d[y]=d[x]+1;\n        que.push(y);\n      }\n    }\n    int ans=0;\n    for(int i=0; i<N; i++) ans=max(ans,d[i]);\n    cout << ans << endl;\n    \n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef LOCAL\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\nusing namespace std;\n\nstruct point {\n\tint x, y;\n\texplicit point(double x_ = 0.0, double y_ = 0.0):x(x_), y(y_) {}\n\tpoint(const point &p):x(p.x), y(p.y) {}\n\n\tpoint operator+(const point &p) const {\n\t\treturn point(x + p.x, y + p.y);\n\t}\n\n\tpoint operator-(const point &p) const {\n\t\treturn point(x - p.x, y - p.y);\n\t}\n\n\tpoint operator*(double s) const {\n\t\treturn point(x * s, y * s);\n\t}\n\n\tpoint operator*(const point &p) const {\n\t\treturn point(x * p.x - y * p.y, x * p.y + y * p.x);\n\t}\n\n\tpoint operator/(double s) const {\n\t\treturn point(x / s, y / s);\n\t}\n\n\tbool operator<(const point &p) const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator==(const point &p) const {\n\t\treturn x == p.x && y == p.y;\n\t}\n};\n\ninline double angle(const point &p) {\n\treturn atan2(p.y, p.x);\n}\n\ninline int cross(const point &a, const point &b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\nstruct segment {\n\tpoint a, b;\n\tsegment(const point &a_, const point &b_):a(a_), b(b_){}\n};\n\nstruct edge {\n\tint to;\n\tdouble theta;\n\tbool used;\n\tedge(int to_, double theta_):to(to_), theta(theta_), used(false) {}\n\n\tinline bool operator<(const edge &e) const {\n\t\treturn theta < e.theta;\n\t}\n};\n\ninline istream &operator>>(istream &is, point &p){\n\treturn is >> p.x >> p.y;\n}\n\ninline bool outside(const vector<int> &P, const vector<point> &points) {\n\tconst int n = P.size();\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tconst point &a = points[P[i]];\n\t\tconst point &b = points[P[(i + 1) % n]];\n\t\tconst point &c = points[P[(i + 2) % n]];\n\n\t\tconst int tmp = cross(b - a, c - a);\n\t\tif(tmp != 0) return tmp > 0;\n\t}\n\tassert(false);\n}\n\ninline bool neighbor(const vector<int> &a, const vector<int> &b) {\n\tint pa = a.back();\n\tfor(const auto &ca : a) {\n\n\t\tint pb = b.back();\n\t\tfor(const auto &cb : b) {\n\t\t\tif((pa == pb && ca == cb) || (pa == cb && ca == pb)) return true;\n\t\t\tpb = cb;\n\t\t}\n\n\t\tpa = ca;\n\t}\n\treturn false;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tfor(int n, m; cin >> n >> m && n;) {\n\t\tvector<point> points(n);\n\t\tfor(auto &e : points) cin >> e;\n\n\t\tvector<vector<edge>> G(n);\n\t\tfor(int i = 0; i < m; ++i) {\n\t\t\tint s, t;\n\t\t\tcin >> s >> t;\n\t\t\t--s; --t;\n\t\t\tG[s].emplace_back(t, angle(points[t] - points[s]));\n\t\t\tG[t].emplace_back(s, angle(points[s] - points[t]));\n\t\t}\n\n\t\tfor(auto &edges : G) sort(begin(edges), end(edges));\n\n\t\tint s = -1;\n\n\t\tconst int V = 2 + m - n;\n\t\tvector<vector<int>> faces;\n\t\tfaces.reserve(V);\n\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tfor(int j = 0; j < static_cast<int>(G[i].size()); ++j) {\n\t\t\t\tint v = i;\n\t\t\t\tint e_idx = j;\n\n\t\t\t\tvector<int> P;\n\t\t\t\twhile(true) {\n\t\t\t\t\tedge &e = G[v][e_idx];\n\t\t\t\t\tif(e.used) break;\n\t\t\t\t\te.used = true;\n\n\t\t\t\t\tP.emplace_back(v);\n\n\t\t\t\t\tfor(int k = 0; k < static_cast<int>(G[e.to].size()); ++k) {\n\t\t\t\t\t\tif(G[e.to][k].to == v) {\n\t\t\t\t\t\t\tv = e.to;\n\t\t\t\t\t\t\te_idx = k + 1;\n\t\t\t\t\t\t\tif(e_idx >= static_cast<int>(G[e.to].size())) e_idx = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(P.size() >= 3) {\n\t\t\t\t\tif(s == -1 && outside(P, points)) s = faces.size();\n\t\t\t\t\tfaces.emplace_back(P);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvector<vector<int>> Gf(V);\n\n\t\tfor(int i = 0; i < V; ++i) {\n\t\t\tfor(int j = i + 1; j < V; ++j) {\n\t\t\t\tif(neighbor(faces[i], faces[j])) {\n\t\t\t\t\tGf[i].emplace_back(j);\n\t\t\t\t\tGf[j].emplace_back(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvector<int> dist(V, INT_MAX);\n\t\tqueue<int> que;\n\n\t\tdist[s] = 0;\n\t\tque.push(s);\n\n\t\twhile(!que.empty()) {\n\t\t\tconst int v = que.front();\n\t\t\tque.pop();\n\n\t\t\tfor(const auto &to : Gf[v]) {\n\t\t\t\tif(dist[to] == INT_MAX) {\n\t\t\t\t\tdist[to] = dist[v] + 1;\n\t\t\t\t\tque.push(to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << *max_element(begin(dist), end(dist)) << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <bitset>\n#include <cmath>\n#include <algorithm>\n\n#define TIMES(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef bitset<300> Spec;\nconst double EPS = 1e-9;\nconst double PI = acos(-1);\n\ndouble normalize(double angle) {\n    if(angle < 0) return angle + 2*PI;\n    return angle;\n}\n\nint cmp(double a, double b) {\n    const double diff = a-b;\n    if(fabs(diff) < EPS) return 0;\n    return diff < 0 ? -1 : 1;\n}\n\ndouble dot(const P &a, const P &b) {\n    return a.real()*b.real() + a.imag()*b.imag();\n}\n\ndouble cross(const P &a, const P &b) {\n    return a.real()*b.imag() - a.imag()*b.real();\n}\n\nint root(int n, vector<int> &roots) {\n    if(roots[n] == n) return n;\n    return roots[n] = root(roots[n], roots);\n}\n\nbool unite(int a, int b, vector<int> &roots) {\n    const int ra = root(a, roots);\n    const int rb = root(b, roots);\n    if(ra == rb) return false;\n    roots[ra] = rb;\n    return true;\n}\n\nbool solve() {\n    int C, W;\n    cin >> C >> W;\n    if(!C && !W) return false;\n\n    vector<P> poles;\n    vector<vector<int>> graph(C);\n    vector<vector<int>> wall_id(C, vector<int>(C));\n    TIMES(_, C) {\n        double x, y;\n        cin >> x >> y;\n        poles.push_back(P(x, y));\n    }\n    TIMES(i, W) {\n        int s, t;\n        cin >> s >> t;\n        --s; --t;\n        graph[s].push_back(t);\n        graph[t].push_back(s);\n        wall_id[s][t] = i*2;\n        wall_id[t][s] = i*2+1;\n    }\n\n    vector<int> roots(W*2);\n    TIMES(i, W*2) {\n        roots[i] = i;\n    }\n    TIMES(i, C) {\n        const P &pi = poles[i];\n        for(int j : graph[i]) {\n            const P &pj = poles[j];\n            const P vec = pj - pi;\n            const double len = abs(vec);\n            int candidate = -1;\n            int sin_sgn = -2;\n            double cos_val = 2;\n            for(int k : graph[j]) {\n                if(k == i) continue;\n                const P vec2 = poles[k] - pj;\n                const int sgn = cmp(cross(vec2, vec), 0);\n                const double cv = dot(vec, vec2) / len / abs(vec2) * sgn;\n                if(sgn > sin_sgn\n                    || (sgn == sin_sgn && cmp(cv, cos_val) < 0))\n                {\n                    candidate = k;\n                    sin_sgn = sgn;\n                    cos_val = cv;\n                }\n            }\n            if(candidate != -1) {\n                if(unite(wall_id[i][j], wall_id[j][candidate], roots) && false) {\n                    cout << \"unitea \" << i << \" \" << j << \" \" << candidate << endl;\n                    TIMES(a, W*2) {\n                        cout << root(a, roots) << ' ';\n                    }\n                    cout << endl;\n                }\n            }\n        }\n    }\n    // Determine outside region\n    const int rightmost = distance(poles.begin(),\n            max_element(poles.begin(), poles.end(), [](const P &a, const P &b) {\n                return a.real() < b.real();\n                }));\n    const int rm_next = *min_element(\n            graph[rightmost].begin(), \n            graph[rightmost].end(),\n            [&poles, rightmost](int a, int b) {\n            const double arga = normalize(arg(poles[a] - poles[rightmost]));\n            const double argb = normalize(arg(poles[b] - poles[rightmost]));\n            return arga < argb;\n            });\n    const int out_id = root(wall_id[rm_next][rightmost], roots);\n\n    Spec init;\n    vector<Spec> areas(W*2);\n    TIMES(i, W*2) {\n        const int area = root(i, roots);\n        areas[area][i/2] = true;\n        if(area == out_id) init[i/2] = true;\n        //cout << area << ' ';\n    }\n    /*\n    for(const Spec &s : areas) {\n        if(s.any()) cout << s << endl;\n    }\n    */\n    //cout << endl;\n    Spec cur = init;\n    //cout << init << endl;\n    int turn = 0;\n    vector<bool> used(W*2, false);\n    while(true) {\n        Spec next = cur;\n        bool changed = false;\n        TIMES(i, W*2) {\n            if(!used[i] && (areas[i] & cur).any()) {\n                next |= areas[i];\n                used[i] = true;\n                changed = true;\n            }\n        }\n        if(!changed) break;\n        cur = next;\n        ++turn;\n    }\n    cout << turn << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<climits>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reg(i,a,b) for(int i=(a);i<=(b);i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=(b);i>=(a);i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\ntypedef pair<double,mp> mmp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n\n\nint px[105];\nint py[105];\nint pn,wn;\n\nvector<mmp> ws[105];\n\nvector<mp> vs[1005];\n\nint gone[1005]={};\n\nvoid cons(mmp& ne,int fr){\n\tint to = ne.sec.fir;\n\tint c1 = ne.sec.sec;\n\tne.sec.sec=-1;\n\tmmp& nexte = ne;\n\trep(i,ws[to].size()){\n\t\tmmp e = ws[to][i];\n\t\tif(e.sec.fir == fr){\n\t\t\tnexte = ws[to][ (i+1)%ws[to].size() ];\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tint cw = nexte.sec.sec;\n\tif(cw==-1)return;\n\n\tvs[cw].push_back(mp(c1,0));\n\tvs[c1].push_back(mp(cw,0));\n\t\n\tcons(nexte,to);\t\n\t\n}\n\nint main(void){\n\t\nwhile(1){\n\t\t\n\tscanf(\"%d%d\",&pn,&wn);\n\tif(pn == 0)break;\n\tmemset(gone,0,sizeof(gone));\n\trep(i,105){\n\t\tws[i].clear();\n\t}\n\trep(i,1005){\n\t\tvs[i].clear();\n\t}\n\t\n\t\n\tvector<pair<int,mp> > sv;\n\trep(i,pn){\n\t\tscanf(\"%d%d\",&px[i],&py[i]);\n\t\tsv.push_back(make_pair(i,mp(px[i],py[i])));\n\t}\n\t\n\tsort(sv.begin(),sv.end());\n\t\n\tint nminv = sv[0].first;\n\t\n\trep(i,wn){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\ta--; b--;\n\t\tint nvx = px[b]-px[a];\n\t\tint nvy = py[b]-py[a];\n\t\tws[a].push_back( mmp(atan2(nvy,nvx), mp(b,i*2)) );\n\t\tws[b].push_back( mmp(atan2(-nvy,-nvx), mp(a,i*2+1)) );\n\t\tvs[i*2].push_back( mp(i*2+1,1) );\n\t\tvs[i*2+1].push_back( mp(i*2,1) );\n\t}\n\t\n\trep(i,pn){\n\t\tsort(ws[i].begin(),ws[i].end());\n\t}\n\t\n\tint nsoto = ws[nminv][0].second.second;\n\t\n\t\n\t\n\trep(i,pn){\n\t\trep(j,ws[i].size()){\n\t\t\tif(ws[i][j].sec.sec==-1)continue;\n\t\t\tcons(ws[i][j],i);\n\t\t}\n\t}\n\t\n\t/*\n\tprintf(\"soto .. %d\\n\",nsoto);\n\trep(i,1005){\n\t\trep(j,vs[i].size()){\n\t\t\tprintf(\"(%d %d %d) \",i,vs[i][j].fir,vs[i][j].sec);\n\t\t}\n\t}*/\n\t\n\t\n\tpriority_queue<mp,vector<mp>,greater<mp> > que;\n\tque.push(mp(0,nsoto));\n\t\n\tint ans=0;\n\twhile(!que.empty()){\n\t\tmp pa = que.top();\n\t\tque.pop();\n\t\tint no = pa.sec,\n\t\t\tnc = pa.fir;\n\t\tif(gone[no]!=0)continue;\n\t\tans = max(ans,nc);\n\t\tgone[no]=1;\n\t\trep(i,vs[no].size()){\n\t\t\tint to = vs[no][i].fir;\n\t\t\tif(gone[to])continue;\n\t\t\tque.push( mp(nc + vs[no][i].sec,to));\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\t\n}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<int,pair<bool,double>> P2;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define min_3(a,b,c) min(a,min(b,c))\n#define max_3(a,b,c) max(a,max(b,c))\n#define mp1(a,b,c) P1(a,P(b,c))\n#define mp2(a,b,c) P2(a,pair<bool,double>(b,c))\n#define pque(a) priority_queue<a>\n#define rpque(a) priority_queue<a,vector<a>,greater<a>>\n\nconst int INF=1000000000;\nconst int dre_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dre_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\nconst int kaijou[10]={1,1,2,6,24,120,720,5040,40320,362880};\n\nbool com(P2 x,P2 y){\n\tif(x.sc.fr!=y.sc.fr)return x.sc.fr;\n\treturn x.sc.sc>=y.sc.sc;\n}\n\nint main(){\n\twhile(1){\n\t\tint c,w;\n\t\tint x[110],y[110];\n\t\tint s,t;\n\t\t\n\t\tscanf(\"%d%d\",&c,&w); if(c==0&&w==0)break;\n\t\trep1(i,c)scanf(\"%d%d\",&x[i],&y[i]);\n\t\t\n\t\tvector<P1> V_;\n\t\trep1(i,c){\n\t\t\tV_.pb(mp1(x[i],y[i],i));\n\t\t}\n\t\tsor(V_);\n\t\tvector<P2> vec_[110];\n\t\trep1(i,c){\n\t\t\tvec_[i].pb(mp2(0,false,-INF));\n\t\t\trep1(j,c){\n\t\t\t\tif(i==j)continue;\n\t\t\t\tif(x[i]<x[j]){\n\t\t\t\t\tvec_[i].pb(mp2(j,true,(double)(y[j]-y[i])/(x[j]-x[i])));\n\t\t\t\t}\n\t\t\t\telse if(x[i]>x[j]){\n\t\t\t\t\tvec_[i].pb(mp2(j,false,(double)(y[j]-y[i])/(x[j]-x[i])));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(y[j]>y[i])vec_[i].pb(mp2(j,true,(double)INF));\n\t\t\t\t\telse vec_[i].pb(mp2(j,true,(double)-INF));\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(vec_[i].begin(),vec_[i].end(),com);\n\t\t}\n\t\t\n\t\tint v,e;\n\t\tvector<int> V;\n\t\tbool edge[110][110];\n\t\tvector<int> vec[110];\n\t\t\n\t\tv=c; e=w;\n\t\trep(i,c)V.pb(V_[i].sc.sc);\n\t\trep(i,110)rep(j,110)edge[i][j]=false;\n\t\trep(i,e){\n\t\t\tscanf(\"%d%d\",&s,&t);\n\t\t\tedge[s][t]=true;\n\t\t\tedge[t][s]=true;\n\t\t}\n\t\trep1(i,c){\n\t\t\trep(j,vec_[i].size()){\n\t\t\t\tvec[i].pb(vec_[i][j].fr);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ret=0;\n\t\twhile(e>0){\n\t\t\tret++;\n\t\t\t\n\t\t\tint a=-1;\n\t\t\trep(i,V.size()){\n\t\t\t\trep(j,110){\n\t\t\t\t\tif(edge[V[i]][j]){a=V[i]; break;}\n\t\t\t\t}\n\t\t\t\tif(a!=-1)break;\n\t\t\t}\n\t\t\t\n\t\t\tint b=0,c=a;\n\t\t\twhile(1){\n\t\t\t\trep(i,vec[c].size()){\n\t\t\t\t\tif(vec[c][i]==b){\n\t\t\t\t\t\ti++; i%=vec[c].size();\n\t\t\t\t\t\twhile(!edge[c][vec[c][i]]){\n\t\t\t\t\t\t\ti++; i%=vec[c].size();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tedge[c][vec[c][i]]=false;\n\t\t\t\t\t\tedge[vec[c][i]][c]=false;\n\t\t\t\t\t\te--;\n\t\t\t\t\t\tb=c;\n\t\t\t\t\t\tc=vec[c][i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(c==a)break;\n\t\t\t}\n\t\t\t\n\t\t\tbool updata=true;\n\t\t\twhile(updata){\n\t\t\t\tupdata=false;\n\t\t\t\trep(i,110){\n\t\t\t\t\tint cnt=0;\n\t\t\t\t\tint t=-1;\n\t\t\t\t\trep(j,110){\n\t\t\t\t\t\tif(edge[i][j]){cnt++; t=j;}\n\t\t\t\t\t}\n\t\t\t\t\tif(cnt==1){\n\t\t\t\t\t\tupdata=true;\n\t\t\t\t\t\tedge[i][t]=false;\n\t\t\t\t\t\tedge[t][i]=false;\n\t\t\t\t\t\te--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\n#define each(i,a) for (auto&& i : a)\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    each(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n    rep(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector< vector<T> >& vec) {\n    rep(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\nusing ld = double;\nusing Point = complex<ld>;\nnamespace std {\n    bool operator<(const Point &lhs, const Point &rhs) {\n        if (lhs.real() < rhs.real() - eps) return true;\n        if (lhs.real() > rhs.real() + eps) return false;\n        return lhs.imag() < rhs.imag();\n    }\n}\n\nPoint input_point() {\n    ld x, y;\n    cin >> x >> y;\n    return Point(x, y);\n}\n\nbool eq(ld a, ld b) {\n    return (abs(a - b) < eps);\n}\n\nld dot(Point a, Point b) {\n    return real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n    return imag(conj(a) * b);\n}\n\nclass Line {\npublic:\n    Point a, b;\n    Line () : a(Point(0, 0)), b(Point(0, 0)) {}\n    Line (Point a, Point b) : a(a), b(b) {}\n};\n\nclass Circle {\npublic:\n    Point p;\n    ld r;\n    Circle () : p(Point(0, 0)), r(0) {}\n    Circle (Point p, ld r) : p(p), r(r) {}\n};\n\nint ccw (Point a, Point b, Point c) {\n    b -= a; c -= a;\n    if (cross(b, c) > eps) return 1;\n    if (cross(b, c) < -eps) return -1;\n    if (dot(b, c) < 0) return 2;\n    if (norm(b) < norm(c)) return -2;\n    return 0;\n}\n\nbool isis_ll (Line l, Line m) {\n    return !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls (Line l, Line s) {\n    return isis_ll(l, s) &&\n        (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_ss(Line s, Line t) {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n        ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool isis_lp (Line l, Point p) {\n    return (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp (Line s, Point p) {\n    return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\nPoint proj (Line l, Point p) {\n    ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n    return l.a + t * (l.a - l.b);\n}\n\nPoint is_ll (Line s, Line t) {\n    Point sv = s.b - s.a, tv = t.b - t.a;\n    assert(cross(sv, tv) != 0);\n    return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nld dist_lp (Line l, Point p) {\n    return abs(p - proj(l, p));\n}\n\nld dist_ll (Line l, Line m) {\n    return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls (Line l, Line s) {\n    return isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp (Line s, Point p) {\n    Point r = proj(s, p);\n    return isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss (Line s, Line t) {\n    if (isis_ss(s, t)) return 0;\n    return min({dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b)});\n}\n\nvector<Point> is_cc (Circle c1, Circle c2){\n    vector<Point> res;\n    ld d = abs(c1.p - c2.p);\n    ld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n    ld dfr = c1.r * c1.r - rc * rc;\n    if (abs(dfr) < eps) dfr = 0.0;\n    else if (dfr < 0.0) return res;\n    ld rs = sqrt(dfr);\n    Point diff = (c2.p - c1.p) / d;\n    res.push_back(c1.p + diff * Point(rc, rs));\n    if (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n    return res;\n}\n\nvector<Point> is_lc (Circle c, Line l){\n    vector<Point> res;\n    ld d = dist_lp(l, c.p);\n    if (d < c.r + eps){\n        ld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d);\n        Point nor = (l.a - l.b) / abs(l.a - l.b);\n        res.push_back(proj(l, c.p) + len * nor);\n        res.push_back(proj(l, c.p) - len * nor);\n    }\n    return res;\n}\n\nvector<Point> is_sc(Circle c, Line l){\n    vector<Point> v = is_lc(c, l), res;\n    for (Point p : v)\n        if (isis_sp(l, p)) res.push_back(p);\n    return res;\n}\n\nvector<Line> tangent_cp(Circle c, Point p) {\n    vector<Line> ret;\n    Point v = c.p - p;\n    ld d = abs(v);\n    ld l = sqrt(norm(v) - c.r * c.r);\n    if (isnan((long double)l)) { return ret; }\n    Point v1 = v * Point(l / d,\tc.r / d);\n    Point v2 = v * Point(l / d, -c.r / d);\n    ret.push_back(Line(p, p + v1));\n    if (l < eps) return ret;\n    ret.push_back(Line(p, p + v2));\n    return ret;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n    vector<Line> ret;\n    if (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n        Point center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n        ret = tangent_cp(c1, center);\n    }\n    if (abs(c1.r - c2.r) > eps) {\n        Point out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n        vector<Line> nret = tangent_cp(c1, out);\n        ret.insert(ret.end(), all(nret));\n    }\n    else {\n        Point v = c2.p - c1.p;\n        v /= abs(v);\n        Point q1 = c1.p + v * Point(0,\t1) * c1.r;\n        Point q2 = c1.p + v * Point(0, -1) * c1.r;\n        ret.push_back(Line(q1, q1 + v));\n        ret.push_back(Line(q2, q2 + v));\n    }\n    return ret;\n}\n\ntypedef vector<Point> Polygon;\n\nld area(const Polygon &p) {\n    ld res = 0;\n    int n = p.size();\n    REP(j,n) res += cross(p[j], p[(j+1)%n]);\n    return res / 2;\n}\n\nbool is_counter_clockwise (const Polygon &poly) {\n    ld angle = 0;\n    int n = poly.size();\n    REP(i,n) {\n        Point a = poly[i], b = poly[(i+1)%n], c = poly[(i+2)%n];\n        angle += arg((c - b) / (b - a));\n    }\n    return angle > eps;\n}\n\nint is_in_polygon (const Polygon &poly, Point p) {\n    ld angle = 0;\n    int n = poly.size();\n    REP(i,n) {\n        Point a = poly[i], b = poly[(i+1)%n];\n        if (isis_sp(Line(a, b), p)) return 1;\n        angle += arg((b - p) / (a - p));\n    }\n    return eq(angle, 0) ? 0 : 2;\n}\n\nPolygon convex_hull(vector<Point> ps) {\n    int n = ps.size();\n    int k = 0;\n    sort(ps.begin(), ps.end());\n    Polygon ch(2 * n);\n    for (int i = 0; i < n; ch[k++] = ps[i++])\n        while (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n    for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n        while (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n    ch.resize(k - 1);\n    return ch;\n}\n\nPolygon convex_cut(const Polygon &ps, Line l) {\n    int n = ps.size();\n    Polygon Q;\n    REP(i,n) {\n        Point A = ps[i], B = ps[(i+1)%n];\n        Line m = Line(A, B);\n        if (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n        if (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))\n            Q.push_back(is_ll(l, m));\n    }\n    return Q;\n}\n\nvoid add_point(vector<Point> &ps, Point p) {\n    for (Point q : ps) if (abs(q - p) < eps) return;\n    ps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\nbool operator>(const Edge& e1, const Edge& e2) {\n    return e1.weight > e2.weight;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, int from, int to, Weight weight) {\n    g[from].push_back((Edge){from, to, weight});\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n    int n = p.size(), m = s.size();\n    Graph g(n);\n    REP(i,m) {\n        vector<pair<ld,int>> vec;\n        REP(j,n) if (isis_sp(s[i], p[j]))\n            vec.emplace_back(abs(s[i].a - p[j]), j);\n        sort(all(vec));\n        REP(j,vec.size()-1) {\n            int from = vec[j].second, to = vec[j+1].second;\n            add_edge(g, from, to, abs(p[from] - p[to]));\n        }\n    }\n    return g;\n}\n\nGraph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n    int n = p.size(), m = c.size();\n    Graph g(n);\n    REP(i,m) {\n        vector<pair<ld,int>> vec;\n        REP(j,n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n            vec.emplace_back(arg(c[i].p - p[j]), j);\n        sort(all(vec));\n        REP(j,vec.size()-1) {\n            int from = vec[j].second, to = vec[j+1].second;\n            ld angle = vec[j+1].first - vec[j].first;\n            add_edge(g, from, to, angle * c[i].r);\n        }\n        if (vec.size() >= 2) {\n            int from = vec.back().second, to = vec.front().first;\n            ld angle = vec.front().first - vec.back().first;\n            add_edge(g, from, to, angle * c[i].r);\n        }\n    }\n    return g;\n}\n\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\nGraph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n    int N = p.size();\n    polygon.clear();\n    REP(i,1024) REP(j,1024) seg2p[i][j].clear();\n    vector<vector<tuple<ld,int,bool>>> tup(N);\n    REP(i,s.size()) {\n        int a = -1, b = -1;\n        REP(j,N) if (abs(s[i].a - p[j]) < eps) a = j;\n        REP(j,N) if (abs(s[i].b - p[j]) < eps) b = j;\n        assert(a >= 0 && b >= 0);\n        tup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n        tup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n    }\n    REP(i,N) sort(all(tup[i]));\n    REP(i,N) {\n        REP(j,tup[i].size()) {\n            ld angle; int pos = j, from = i, to; bool flag;\n            tie(angle, to, flag) = tup[i][j];\n            if (flag) continue;\n            vector<int> ps;\n            while (!flag) {\n                ps.push_back(from);\n                get<2>(tup[from][pos]) = true;\n                seg2p[from][to].push_back(polygon.size());\n                seg2p[to][from].push_back(polygon.size());\n                angle += pi + eps;\n                if (angle > pi) angle -= 2 * pi;\n                auto it = lower_bound(all(tup[to]), make_tuple(angle, 0, false));\n                if (it == tup[to].end()) it = tup[to].begin();\n                from = to; tie(angle, to, flag) = *it;\n                pos = it - tup[from].begin();\n            }\n            polygon.push_back(ps);\n        }\n    }\n    Graph g(polygon.size());\n    REP(i,N) REP(j,i) {\n        if (seg2p[i][j].size() == 2) {\n            int from = seg2p[i][j][0];\n            int to = seg2p[i][j][1];\n            int len = 1;\n            // double len = abs(p[i] - p[j]);\n            g[from].push_back((Edge){from, to, len});\n            g[to].push_back((Edge){to, from, len});\n        }\n    }\n    return g;\n}\n\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(int r, int g, int b) {\n    fprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(Point p) {\n    fprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(Line l) {\n    fprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(Line l) {\n    Point v = l.b - l.a;\n    Line m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n    fprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n    int n = p.size();\n    REP(i,n) draw_segment(Line(p[i], p[(i+1)%n]));\n}\n\nvoid draw_circle(Circle c) {\n    fprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\nclass UnionFind {\n    vector<int> par, h;\npublic:\n    UnionFind(int size) {\n        par.assign(size, 0);\n        h.assign(size, 0);\n        REP(i, size) par[i] = i;\n    }\n    void unite(int u, int v) {\n        u = root(u), v = root(v);\n        if (u == v) return;\n        if (h[u] > h[v]) {\n            par[v] = u;\n        }\n        else if (h[u] < h[v]) {\n            par[u] = v;\n        }\n        else {\n            ++h[u];\n            par[v] = u;\n        }\n    }\n    bool isUnited(int u, int v) {\n        return root(u) == root(v);\n    }\n    int root(int v) {\n        if (par[v] == v) return v;\n        return par[v] = root(par[v]);\n    }\n};\nvector<ll> bfs(const Graph& G, const ll s) {\n    const ll n = G.size();\n    vector<ll> dist(n, linf);\n    dist[s] = 0;\n    queue<ll> Q; Q.push(s);\n    while ( !Q.empty() ) {\n        ll v = Q.front(); Q.pop();\n        each(e, G[v]) {\n            if (dist[v]+1 < dist[e.to]) {\n                dist[e.to] = dist[v]+1;\n                Q.push(e.to);\n            }\n        }\n    }\n    return dist;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll n, m;\n    while (cin >> n >> m, n || m) {\n        vector<Line> lines;\n        vector<Point> points;\n        rep(i, n) {\n            points.pb(input_point());\n        }\n        rep(i, m) {\n            ll a, b; cin >> a >> b; --a, --b;\n            lines.pb(Line(points[a], points[b]));\n        }\n        Graph G = dual_graph(lines, points);\n        const ll V = G.size();\n        // rep(i, polygon.size()) {\n        //     each(id, polygon[i]) {\n        //         Point p = points[id];\n        //         cout << \"(\" << p.real() << \", \" << p.imag() << \")\";\n        //     }\n        //     cout << endl;\n        // }\n        // ll s = V-1;\n        ll s = 0;\n        vector<ll> dist = bfs(G, s);\n        ll ans = 0;\n        rep(i, V) chmax(ans, dist[i]);\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<utility>\n#include<map>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n\nusing namespace std;\n\nstruct Point{\n\tint x,y;\n\tint id;\n\tPoint(){}\n\tPoint(int a,int b,int c):x(a),y(b),id(c){}\n};\n\nPoint points[110];\nint pid[110];\n\nbool cmp(const Point &p1,const Point &p2)\n{\n\tif(p1.x!=p2.x) return p1.x<p2.x;\n\treturn p1.y<p2.y;\n}\n\nint center;\n\nbool cmp_angle(const int &id1,const int &id2)\n{\n\tint center=pid[::center];\n\tint id1_=pid[id1],id2_=pid[id2];\n\tint dx1=points[id1_].x-points[center].x;\n\tint dy1=points[id1_].y-points[center].y;\n\tint dx2=points[id2_].x-points[center].x;\n\tint dy2=points[id2_].y-points[center].y;\n\t//(-y,x)\n\tdouble ang1=atan2(dx1,-dy1);\n\tdouble ang2=atan2(dx2,-dy2);\n\treturn ang1<ang2;\n}\n\nvector<int> G[110];\n\nvector<vector<int> > vs;\nvector<int> dG[750];\n\ntypedef pair<int,int> P;\n\nmap<P,int> cnt;\nqueue<P> que;\n\nvoid init()\n{\n\tvs.clear();\n\tfor(int i=0;i<110;i++) G[i].clear();\n\tfor(int i=0;i<550;i++) dG[i].clear();\n\tcnt.clear();\n}\n\nvector<int> res;\nvoid stroke(int u,int v,int st)\n{\n\t//u->v\n\tP p=P(min(u,v),max(u,v));\n\tif(cnt[p]==0)\n\t{\n\t\tque.push(P(v,u));\n\t}\n\tcnt[p]++;\n\tif(v==st) return;\n\tif(u==st) res.push_back(u);\n\tres.push_back(v);\n\tcenter=v;\n\tint id=distance(G[v].begin(),lower_bound(G[v].begin(),G[v].end(),u,cmp_angle));\n\tif(id==G[v].size()-1) id=0;\n\telse id++;\n\tint nxt=G[v][id];\n\tstroke(v,nxt,st);\n}\n\nvoid getGraph(int W)\n{\n\tint n=0;\n\tint V=vs.size();\n\tfor(int i=0;i<V;i++) for(int j=i+1;j<V;j++)\n\t{\n\t\tint ni=vs[i].size(),nj=vs[j].size();\n\t\tbool flg=false;\n\t\tfor(int iid=0;iid<ni;iid++) for(int jid=0;jid<nj;jid++)\n\t\t{\n\t\t\tint niid=iid==ni-1?0:iid+1;\n\t\t\tint njid=jid==nj-1?0:jid+1;\n\t\t\tif(vs[i][iid]==vs[j][njid]&&vs[i][niid]==vs[j][jid])\n\t\t\t{\n\t\t\t\tflg=true;\n\t\t\t\tn++;\n\t\t\t}\n\t\t}\n\t\tif(flg)\n\t\t{\n\t\t\tdG[i].push_back(j);\n\t\t\tdG[j].push_back(i);\n\t\t}\n\t}\n}\n\nvector<int> outSide;\n\nint getMostOutSide()\n{\n\tint u=points[0].id;\n\tint v=G[u][0];\n\tfor(int i=0;i<vs.size();i++)\n\t{\n\t\tfor(int j=0;j+1<vs[i].size();j++)\n\t\t{\n\t\t\tif(vs[i][j]==u&&vs[i][j+1]==v) return i;\n\t\t}\n\t\tif(vs[i][vs[i].size()-1]==u&&vs[i][0]==v) return i;\n\t}\n\treturn -1;\n}\n\n\nint dis[750];\nqueue<int> bfs_que;\nvoid bfs(int s)\n{\n\twhile(!bfs_que.empty()) bfs_que.pop();\n\tbfs_que.push(s);\n\tfor(int i=0;i<750;i++) dis[i]=1<<29;\n\tdis[s]=0;\n\tbfs_que.push(s);\n\twhile(!bfs_que.empty())\n\t{\n\t\tint v=bfs_que.front();\n\t\tbfs_que.pop();\n\t\tfor(int i=0;i<dG[v].size();i++)\n\t\t{\n\t\t\tint u=dG[v][i];\n\t\t\tint nd=dis[v]+1;\n\t\t\tif(nd>=dis[u]) continue;\n\t\t\tdis[u]=nd;\n\t\t\tbfs_que.push(u);\n\t\t}\n\t}\n}\n\n\nint main()\n{\n\twhile(true)\n\t{\n\t\tint C,W;\n\t\tscanf(\"%d%d\",&C,&W);\n\t\tif(C==0) break;\n\t\tinit();\n\t\tfor(int i=0;i<C;i++)\n\t\t{\n\t\t\tint x,y;\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\tpoints[i]=Point(x,y,i);\n\t\t}\n\t\tsort(points,points+C,cmp);\n\t\tfor(int i=0;i<C;i++) pid[points[i].id]=i;\n\t\tint su=-1,sv=-1;\n\t\tfor(int i=0;i<W;i++)\n\t\t{\n\t\t\tint u,v;\n\t\t\tscanf(\"%d%d\",&u,&v);\n\t\t\tu--;v--;\n\t\t\tG[u].push_back(v);\n\t\t\tG[v].push_back(u);\n\t\t\tsu=u,sv=v;\n\t\t\tque.push(P(u,v));\n\t\t\tque.push(P(v,u));\n\t\t}\n\t\tfor(int i=0;i<C;i++)\n\t\t{\n\t\t\tcenter=i;\n\t\t\tsort(G[i].begin(),G[i].end(),cmp_angle);\n\t\t}\n\t//\tque.push(P(min(su,sv),max(su,sv)));\n\t\twhile(!que.empty())\n\t\t{\n\t\t\tP p=que.front();\n\t\t\tque.pop();\n\t\t\tint u=p.first,v=p.second;\n\t\t\tP pp=P(min(u,v),max(u,v));\n\t\t\tif(cnt[pp]==2) continue;\n\t\t\tres.clear();\n\t\t\tstroke(u,v,u);\n\t\t\tvs.push_back(res);\n\t\t}\n\t\tif(cnt.size()<W) for(;;);\n\t\tgetGraph(W);\n\t\tint out=getMostOutSide();\n\t\tbfs(out);\n\t\tint ans=0;\n\t\tfor(int i=0;i<vs.size();i++) ans=max(ans,dis[i]);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<utility>\n#include<map>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n\nusing namespace std;\n\nstruct Point{\n\tint x,y;\n\tint id;\n\tPoint(){}\n\tPoint(int a,int b,int c):x(a),y(b),id(c){}\n};\n\nPoint points[110];\nint pid[110];\n\nbool cmp(const Point &p1,const Point &p2)\n{\n\tif(p1.x!=p2.x) return p1.x<p2.x;\n\treturn p1.y<p2.y;\n}\n\nint center;\n\nbool cmp_angle(const int &id1,const int &id2)\n{\n\tint center=pid[::center];\n\tint id1_=pid[id1],id2_=pid[id2];\n\tint dx1=points[id1_].x-points[center].x;\n\tint dy1=points[id1_].y-points[center].y;\n\tint dx2=points[id2_].x-points[center].x;\n\tint dy2=points[id2_].y-points[center].y;\n\t//(-y,x)\n\tdouble ang1=atan2(dx1,-dy1);\n\tdouble ang2=atan2(dx2,-dy2);\n\treturn ang1<ang2;\n}\n\nvector<int> G[110];\n\nvector<vector<int> > vs;\nvector<int> dG[750];\n\ntypedef pair<int,int> P;\n\nmap<P,int> cnt;\nqueue<P> que;\n\nvoid init()\n{\n\tvs.clear();\n\tfor(int i=0;i<110;i++) G[i].clear();\n\tfor(int i=0;i<550;i++) dG[i].clear();\n\tcnt.clear();\n}\n\nvector<int> res;\nvoid stroke(int u,int v,int st)\n{\n\t//u->v\n\tP p=P(min(u,v),max(u,v));\n\tif(cnt[p]==0)\n\t{\n\t\tque.push(P(v,u));\n\t}\n\tcnt[p]++;\n\tif(v==st) return;\n\tif(u==st) res.push_back(u);\n\tres.push_back(v);\n\tcenter=v;\n\tint id=distance(G[v].begin(),lower_bound(G[v].begin(),G[v].end(),u,cmp_angle));\n\tif(id==G[v].size()-1) id=0;\n\telse id++;\n\tint nxt=G[v][id];\n\tstroke(v,nxt,st);\n}\n\nvoid getGraph(int W)\n{\n\tint n=0;\n\tint V=vs.size();\n\tfor(int i=0;i<V;i++) for(int j=i+1;j<V;j++)\n\t{\n\t\tint ni=vs[i].size(),nj=vs[j].size();\n\t\tbool flg=false;\n\t\tfor(int iid=0;iid<ni;iid++) for(int jid=0;jid<nj;jid++)\n\t\t{\n\t\t\tint niid=iid==ni-1?0:iid+1;\n\t\t\tint njid=jid==nj-1?0:jid+1;\n\t\t\tif(vs[i][iid]==vs[j][njid]&&vs[i][niid]==vs[j][jid])\n\t\t\t{\n\t\t\t\tflg=true;\n\t\t\t\tn++;\n\t\t\t}\n\t\t}\n\t\tif(flg)\n\t\t{\n\t\t\tdG[i].push_back(j);\n\t\t\tdG[j].push_back(i);\n\t\t}\n\t}\n}\n\nvector<int> outSide;\n\nint getMostOutSide()\n{\n\tint u=points[0].id;\n\tint v=G[u][0];\n\tfor(int i=0;i<vs.size();i++)\n\t{\n\t\tfor(int j=0;j+1<vs[i].size();j++)\n\t\t{\n\t\t\tif(vs[i][j]==u&&vs[i][j+1]==v) return i;\n\t\t}\n\t\tif(vs[i][vs[i].size()-1]==u&&vs[i][0]==v) return i;\n\t}\n\treturn -1;\n}\n\n\nint dis[750];\nqueue<int> bfs_que;\nvoid bfs(int s)\n{\n\twhile(!bfs_que.empty()) bfs_que.pop();\n\tbfs_que.push(s);\n\tfor(int i=0;i<750;i++) dis[i]=1<<29;\n\tdis[s]=0;\n\tbfs_que.push(s);\n\twhile(!bfs_que.empty())\n\t{\n\t\tint v=bfs_que.front();\n\t\tbfs_que.pop();\n\t\tfor(int i=0;i<dG[v].size();i++)\n\t\t{\n\t\t\tint u=dG[v][i];\n\t\t\tint nd=dis[v]+1;\n\t\t\tif(nd>=dis[u]) continue;\n\t\t\tdis[u]=nd;\n\t\t\tbfs_que.push(u);\n\t\t}\n\t}\n}\n\n\nint main()\n{\n\twhile(true)\n\t{\n\t\tint C,W;\n\t\tscanf(\"%d%d\",&C,&W);\n\t\tif(C==0) break;\n\t\tinit();\n\t\tfor(int i=0;i<C;i++)\n\t\t{\n\t\t\tint x,y;\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\tpoints[i]=Point(x,y,i);\n\t\t}\n\t\tsort(points,points+C,cmp);\n\t\tfor(int i=0;i<C;i++) pid[points[i].id]=i;\n\t\tint su=-1,sv=-1;\n\t\tfor(int i=0;i<W;i++)\n\t\t{\n\t\t\tint u,v;\n\t\t\tscanf(\"%d%d\",&u,&v);\n\t\t\tu--;v--;\n\t\t\tG[u].push_back(v);\n\t\t\tG[v].push_back(u);\n\t\t\tsu=u,sv=v;\n\t\t}\n\t\tfor(int i=0;i<C;i++)\n\t\t{\n\t\t\tcenter=i;\n\t\t\tsort(G[i].begin(),G[i].end(),cmp_angle);\n\t\t}\n\t\tque.push(P(min(su,sv),max(su,sv)));\n\t\twhile(!que.empty())\n\t\t{\n\t\t\tP p=que.front();\n\t\t\tque.pop();\n\t\t\tint u=p.first,v=p.second;\n\t\t\tP pp=P(min(u,v),max(u,v));\n\t\t\tif(cnt[pp]==2) continue;\n\t\t\tres.clear();\n\t\t\tstroke(u,v,u);\n\t\t\tvs.push_back(res);\n\t\t}\n\t\tgetGraph(W);\n\t\tint out=getMostOutSide();\n\t\tbfs(out);\n\t\tint ans=0;\n\t\tfor(int i=0;i<vs.size();i++) ans=max(ans,dis[i]);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef complex<double> Point;\nstruct Edge{\n    int from, to, id;\n    Edge() {}\n    Edge(int a, int b, int id) : from(a), to(b), id(id) {}\n};\n\ndouble angle(Point a, Point b){\n    double th = arg(conj(a) * b);\n    return (th >= 0) ? th : th + 2.0 * M_PI;\n}\n\nnamespace std{\n    bool operator < (const Point& a, const Point& b){\n        if(a.real() != b.real()) return a.real() < b.real();\n        return a.imag() < b.imag();\n    }\n}\n\nint main(){\n    int N, M;\n    while(cin >> N >> M && N){\n        vector<Point> ps(N);\n        REP(i, N){\n            double x, y;\n            cin >> x >> y;\n            ps[i] = Point(x, y);\n        }\n        vector<Edge> edges;\n        vector<vector<Edge>> G(N);\n        REP(i, M){\n            int a, b;\n            cin >> a >> b;\n            a--; b--;\n            edges.push_back(Edge(a, b, 2 * i));\n            edges.push_back(Edge(b, a, 2 * i + 1));\n            G[a].push_back(edges[2 * i]);\n            G[b].push_back(edges[2 * i + 1]);\n        }\n\n        int F = 0;\n        vector<int> face(2 * M, -1); // ティツセツコテ」ツ?ョテ・ツ渉ウテ・ツ?エテ」ツ?ョテゥツ敖「テ」ツ?ョid\n        for(int i = 0; i < 2 * M; i++){\n            if(face[i] != -1) continue;\n            int cur_e = i;\n            int prev_p = edges[i].from;\n            int cur_p = edges[i].to;\n            while(face[cur_e] == -1){\n                face[cur_e] = F;\n                int next_e = -1;\n                int next_p = -1;\n                double next_arg = 1e16;\n                for(int i = 0; i < G[cur_p].size(); i++){\n                    int to = G[cur_p][i].to;\n                    if(to == prev_p) continue;\n                    double arg = angle(ps[prev_p] - ps[cur_p], ps[to] - ps[cur_p]);\n                    if(next_arg > arg){\n                        next_arg = arg;\n                        next_e = G[cur_p][i].id;\n                        next_p = to;\n                    }\n                }\n                assert(next_e != -1);\n                cur_e = next_e;\n                prev_p = cur_p;\n                cur_p = next_p;\n            }\n            F++;\n        }\n\n        bool connected[600][600] = {};\n        for(int i = 0; i < M; i++){\n            int f1 = face[2 * i];\n            int f2 = face[2 * i + 1];\n            connected[f1][f2] = connected[f2][f1] = true;\n        }\n\n        int base = min_element(ps.begin(), ps.end()) - ps.begin();\n        int start = -1;\n        Edge tmp;\n        double min_agl = 1e8;\n        for(int i = 0; i < G[base].size(); i++){\n            Edge e = G[base][i];\n            double agl = arg(ps[e.to] - ps[e.from]);\n            if(min_agl > agl){\n                min_agl = agl;\n                start = face[e.id];\n                tmp = e;\n            }\n        }\n\n        vector<int> dist(F, -1);\n        queue<int> que;\n        que.push(start);\n        dist[start] = 0;\n        while(!que.empty()){\n            int from = que.front(); que.pop();\n            for(int to = 0; to < F; to++){\n                if(connected[from][to] && dist[to] == -1){\n                    dist[to] = dist[from] + 1;\n                    que.push(to);\n                }\n            }\n        }\n        cout << *max_element(dist.begin(), dist.end()) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<int,pair<bool,double> > P2;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define min_3(a,b,c) min(a,min(b,c))\n#define max_3(a,b,c) max(a,max(b,c))\n#define mp1(a,b,c) P1(a,P(b,c))\n#define mp2(a,b,c) P2(a,pair<bool,double>(b,c))\n#define pque(a) priority_queue<a>\n#define rpque(a) priority_queue<a,vector<a>,greater<a>>\n\nconst int INF=1000000000;\nconst int dre_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dre_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\nconst int kaijou[10]={1,1,2,6,24,120,720,5040,40320,362880};\n\nbool com(P2 x,P2 y){\n\tif(x.sc.fr!=y.sc.fr)return x.sc.fr;\n\treturn x.sc.sc>=y.sc.sc;\n}\n\nint main(){\n\tint ppp=0;\n\twhile(1){\n\t\tppp++; if(ppp>=6)while(1){}\n\t\tstatic int v,w;\n\t\tstatic int x[310],y[310];\n\t\tstatic int s,t;\n\t\t\n\t\tscanf(\"%d%d\",&v,&w); if(v==0&&w==0)break;\n\t\trep1(i,v)scanf(\"%d%d\",&x[i],&y[i]);\n\t\t\n\t\tstatic vector<P1> V_; V_.clear();\n\t\trep1(i,v){\n\t\t\tV_.pb(mp1(x[i],y[i],i));\n\t\t}\n\t\tsor(V_);\n\t\tstatic vector<P2> vec_[310];\n\t\trep1(i,v){\n\t\t\tvec_[i].clear();\n\t\t\tvec_[i].pb(mp2(0,false,-INF));\n\t\t\trep1(j,v){\n\t\t\t\tif(i==j)continue;\n\t\t\t\tif(x[i]<x[j]){\n\t\t\t\t\tvec_[i].pb(mp2(j,true,(double)(y[j]-y[i])/(x[j]-x[i])));\n\t\t\t\t}\n\t\t\t\telse if(x[i]>x[j]){\n\t\t\t\t\tvec_[i].pb(mp2(j,false,(double)(y[j]-y[i])/(x[j]-x[i])));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(y[j]>y[i])vec_[i].pb(mp2(j,true,(double)INF));\n\t\t\t\t\telse vec_[i].pb(mp2(j,true,(double)-INF));\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(vec_[i].begin(),vec_[i].end(),com);\n\t\t}\n\t\t\n\t\tstatic int e;\n\t\tstatic vector<int> V; V.clear();\n\t\tstatic bool edge[310][310];\n\t\tstatic vector<int> vec[310]; \n\t\t\n\t\te=w;\n\t\trep(i,v)V.pb(V_[i].sc.sc);\n\t\trep(i,310)rep(j,310)edge[i][j]=false;\n\t\trep(i,e){\n\t\t\tscanf(\"%d%d\",&s,&t);\n\t\t\tedge[s][t]=true;\n\t\t\tedge[t][s]=true;\n\t\t}\n\t\trep1(i,v){\n\t\t\tvec[i].clear();\n\t\t\trep(j,vec_[i].size()){\n\t\t\t\tvec[i].pb(vec_[i][j].fr);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ret=0;\n\t\twhile(e>0){\n\t\t\tret++;\n\t\t\t\n\t\t\tint a=-1;\n\t\t\trep(i,V.size()){\n\t\t\t\trep(j,105){\n\t\t\t\t\tif(edge[V[i]][j]){a=V[i]; break;}\n\t\t\t\t}\n\t\t\t\tif(a!=-1)break;\n\t\t\t}\n\t\t\t\n\t\t\tint b=0,c=a;\n\t\t\twhile(1){\n\t\t\t\tif(c==-1||vec[c].size()==0)break;\n\t\t\t\trep(i,vec[c].size()){\n\t\t\t\t\tif(vec[c][i]==b){\n\t\t\t\t\t\ti++; i%=vec[c].size();\n\t\t\t\t\t\twhile(!edge[c][vec[c][i]]){\n\t\t\t\t\t\t\ti++; i%=vec[c].size();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tedge[c][vec[c][i]]=false;\n\t\t\t\t\t\tedge[vec[c][i]][c]=false;\n\t\t\t\t\t\te--;\n\t\t\t\t\t\tb=c;\n\t\t\t\t\t\tc=vec[c][i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(c==a)break;\n\t\t\t}\n\t\t\t\n\t\t\tbool updata=true;\n\t\t\twhile(updata){\n\t\t\t\tupdata=false;\n\t\t\t\trep1(i,v){\n\t\t\t\t\tint cnt=0;\n\t\t\t\t\tint t=105;\n\t\t\t\t\trep1(j,v){\n\t\t\t\t\t\tif(edge[i][j]){cnt++; t=j;}\n\t\t\t\t\t}\n\t\t\t\t\tif(cnt==1){\n\t\t\t\t\t\tupdata=true;\n\t\t\t\t\t\tedge[i][t]=false;\n\t\t\t\t\t\tedge[t][i]=false;\n\t\t\t\t\t\te--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cassert>\nusing namespace std;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n\treturn abs(a.real()-b.real()) > EPS ? real(a) < real(b) : imag(a) + EPS < imag(b);\n    //return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\nP readPoint(){\n\tdouble x,y;\n\tcin >> x >> y;\n\treturn P(x,y);\n}\n\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\ntypedef vector<P> G;\n\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\n\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\nP reflection(const L &l, const P &p) {\n  return p + 2. * (projection(l, p) - p);\n}\ndouble distanceLP(const L &l, const P &p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\n#define rep(i,N) for(int i = 0 ; i < N ; i++)\nP ps[110];\nvector<int> g[110];\n\nvector<int> normalize(vector<int> v){\n\tauto it = min_element(v.begin(),v.end());\n\trotate(v.begin(),it,v.end());\n\treturn v;\n}\n\nint done[110];\nvoid f(int a,int b,int s,vector<int> &v){\n\tv.push_back(b);\n\tif( b == s ) return;\n\tif( done[b]++ ) throw 0;\n\tsort(g[b].begin(),g[b].end(),[&](int x,int y){\n\t\tP A = ps[x] - ps[b];\n\t\tP B = ps[y] - ps[b];\n\t\treturn cross(A,B) > 0;\n\t});\n\trotate(g[b].begin(),find(g[b].begin(),g[b].end(),a),g[b].end());\n\tf(b,g[b][1],s,v);\n}\n\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n\ndouble area2(const G& P) {\n  double A = 0;\n  for (int i = 0; i < P.size(); ++i) \n    A += cross(curr(P, i), next(P, i));\n  return A;\n}\n\nint main(){\n\t\n\tint C,W;\n\twhile( cin >> C >> W && (C||W) ){\n\t\trep(i,C) ps[i] = readPoint();\n\t\trep(i,C) g[i].clear();\n\t\trep(i,W){\n\t\t\tint a,b;\n\t\t\tcin >> a >> b;\n\t\t\t--a,--b;\n\t\t\tg[a].push_back(b);\n\t\t\tg[b].push_back(a);\n\t\t}\n\t\tvector< vector<int> > poly;\n\t\trep(i,C){\n\t\t\trep(j,g[i].size()){\n\t\t\t\ttry{\n\t\t\t\t\tmemset(done,0,sizeof(done));\n\t\t\t\t\tvector<int> v;\n\t\t\t\t\tf(i,g[i][j],i,v);\n\t\t\t\t\tvector<P> g;\n\t\t\t\t\trep(k,v.size())g.push_back(ps[v[k]]);\n\t\t\t\t\tif( area2(g) > 0 ){ continue; }\n\t\t\t\t\tpoly.push_back(normalize(v));\n\t\t\t\t}catch(int x){\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(poly.begin(),poly.end());\n\t\tpoly.erase(unique(poly.begin(),poly.end()),poly.end());\n\t\t\n\t\tmap< pair<int,int>, vector<int> > edgs;\n\t\tfor(int i = 0 ; i < poly.size() ; i++){\n\t\t\tfor(int j = 0 ; j < poly[i].size() ; j++){\n\t\t\t\tint A = curr(poly[i],j);\n\t\t\t\tint B = next(poly[i],j);\n\t\t\t\tif( A > B ) swap(A,B);\n\t\t\t\tedgs[pair<int,int>(A,B)].push_back(i);\n\t\t\t}\n\t\t}\n\t\tint M = poly.size() + 1;\n\t\tint wf[M][M];\n\t\trep(i,M) rep(j,M){\n\t\t\twf[i][j] = i==j?0:1e9;\n\t\t}\n\t\t\n\t\tfor( auto x : edgs ){\n\t\t\tvector<int> v = x.second;\n\t\t\tif( v.size() < 2 ) v.push_back(M-1);\n\t\t\twf[v[0]][v[1]] = wf[v[1]][v[0]] = 1;\n\t\t}\n\t\trep(i,M)rep(j,M)rep(k,M) wf[j][k] = min(wf[j][i]+wf[i][k],wf[j][k]);\n\t\tint ans = 1;\n\t\trep(i,M){\n\t\t\tif( wf[i][M-1] != 1e9 )\n\t\t\tans = max(ans,wf[i][M-1]);\n\t\t}\n\t\tcout << ans << endl;\n\t\t\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<complex>\n#include<vector>\nusing namespace std;\ndouble eps=1e-7;\ndouble x[110];\ndouble y[110];\ndouble px[700];\ndouble py[700];\nint ijk[700];\nint v[700];\nint g[700][700];\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ndouble PI=3.14159265358;\ntypedef complex<double> P;\ntypedef vector<P> G;\n\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nP pt[700];\nP ps[300];\nint s[400];\nint t[400];\ndouble left[400];\ndouble right[400];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<a;i++)scanf(\"%lf%lf\",x+i,y+i);\n\t\tfor(int i=0;i<a;i++){\n\t\t\tdouble X=cos(1)*x[i]-sin(1)*y[i];\n\t\t\tdouble Y=sin(1)*x[i]+cos(1)*y[i];\n\t\t\tx[i]=X;\n\t\t\ty[i]=Y;\n\t\t\tps[i]=P(x[i],y[i]);\n\t\t\t\n\t\t}\n\t\tfor(int i=0;i<b;i++){\n\t\t\tint p,q;scanf(\"%d%d\",&p,&q);\n\t\t\tp--;q--;\n\t\t\ts[i]=p;t[i]=q;\n\t\t\tpx[i*2]=(x[p]+x[q])/2+eps;\n\t\t\tpy[i*2]=(y[p]+y[q])/2;\n\t\t\tpx[i*2+1]=(x[p]+x[q])/2-eps;\n\t\t\tpy[i*2+1]=(y[p]+y[q])/2;\n\t\t\tpt[i*2]=P(px[i*2],py[i*2]);\n\t\t\tpt[i*2+1]=P(px[i*2+1],py[i*2+1]);\n\t\t}\n\t\t\n\t\tpriority_queue<pair<int,int> >Q;\n\t\tfor(int i=0;i<b*2;i++){\n\t\t\tijk[i]=999999999;\n\t\t\tv[i]=0;\n\t\t\tbool OK=true;\n\t\t\tint tt=s[i/2];\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tif(tt==s[j]||tt==t[j])continue;\n\t\t\t\tif(intersectSS(L(ps[tt],ps[tt]+(pt[i]-ps[tt])*10000.0),L(ps[s[j]],ps[t[j]]))){\n\t\t\t\t\tOK=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(OK){\n\t\t//\t\tprintf(\" %d\\n\",i);\n\t\t\t\tijk[i]=0;\n\t\t\t\tQ.push(make_pair(0,i));\n\t\t\t}\n\t\t\tfor(int j=0;j<b*2;j++){\n\t\t\t\tif(i==j){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint cnt=0;\n\t\t\t\tfor(int k=0;k<b;k++){\n\t\t\t\t\tif(intersectSS(L(ps[s[k]],ps[t[k]]),L(pt[i],pt[j]))){\n\t\t//\t\t\t\tprintf(\"(%f,%f) (%f,%f): (%f,%f), (%f,%f)\\n\",px[i],py[i],px[j],py[j],x[s[k]],y[s[k]],x[t[k]],y[t[k]]);\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tg[i][j]=cnt;\n\t\t\t}\n\t\t}\n\t\twhile(Q.size()){\n\t\t\tint cost=-Q.top().first;\n\t\t\tint at=Q.top().second;Q.pop();\n\t\t\tif(v[at])continue;\n\t\t\tv[at]=1;\n\t\t\tfor(int i=0;i<b*2;i++){\n\t\t\t\tif(!v[i]&&ijk[i]>cost+g[at][i]){\n\t\t\t\t\tijk[i]=cost+g[at][i];\n\t\t\t\t\tQ.push(make_pair(-ijk[i],i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret=0;\n\t\tfor(int i=0;i<b*2;i++)ret=max(ret,ijk[i]);\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF (1<<20)\ntypedef pair<double,int> P;\n\n/* 平面幾何の基本要素 */\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a) - (b)) < EPS )\n \nclass Point { // 点を表すクラス\n  public:\n  double x,y;\n   \n  Point(double x=0,double y=0): x(x),y(y) {}\n   \n  Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n  Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n  Point operator * (double a) { return Point(a * x, a * y); }\n  Point operator / (double a) { return Point(x / a, y / a); }\n \n  double abs() { return sqrt(norm()); }\n  double norm() { return x * x + y * y; }\n   \n  bool operator < (const Point &p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n \n  bool operator == (const Point &p) const {\n    return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n  }\n};\n \ntypedef Point Vector; // ベクトルを表す構造体\n \nstruct Segment { // 線分を表す構造体\n  Point p1,p2;\n};\n \ntypedef Segment Line; // 直線を表す構造体\n \nclass Circle { // 円を表すクラス\npublic:\n  Point c;\n  double r;\n  Circle(Point c = Point(), double r = 0.0): c(c),r(r) {}\n};\ntypedef vector < Point > Polygon; // 多角形\n\nPoint post[111];\nvector<P> wall[111];\nint wall_id[333][111];\nint C,W;\nint s[333],c[333];\nbool used[333][111];\nint out_i,out_v;\nint out;\nvector<int> area[333];\nvector<int> edge[333];\nint dis[1000];\n\nvoid make_node(int i,int v,int node_num){\n  vector<int> ret;\n  int sp = i;\n  used[sp][v] = true;\n  ret.push_back(sp);\n  if(i==out_i&&v==out_v) out=node_num;\n  while(1){\n    i = wall[v][(wall_id[i][v]+1)%wall[v].size()].second;\n    if(s[i]==v) v = c[i];\n    else v = s[i];\n    if(i==sp) break;\n    used[i][v] = true;\n    ret.push_back(i);\n    if(i==out_i&&v==out_v) out=node_num;\n  }\n  for(int i=0;i<ret.size();i++) area[ret[i]].push_back(node_num);\n}\n\nvoid bfs(int n,int s){\n  for(int i=0;i<n;i++){\n    dis[i] = -1;\n  }\n  dis[s] = 0;\n  queue<int> que;\n  que.push(s);\n  while(!que.empty()){\n    int v = que.front();\n    que.pop();\n    for(int i=0;i<edge[v].size();i++){\n      if(dis[edge[v][i]] == -1){\n\tque.push(edge[v][i]);\n\tdis[edge[v][i]] = dis[v]+1;\n      }\n    }\n  }\n}\n\nint main(){\n  while(cin >> C >> W , C){\n    for(int i=0;i<111;i++) wall[i].clear();\n    for(int i=0;i<333;i++){\n      area[i].clear();\n      edge[i].clear();\n    }\n    memset(wall_id,-1,sizeof(wall_id));\n    int lp = 0;\n    for(int i=0;i<C;i++){\n      cin >> post[i].x >> post[i].y;\n      if(post[i].x<post[lp].x) lp = i;\n    }\n    for(int i=0;i<W;i++){\n      cin >> s[i] >> c[i];\n      s[i]--; c[i]--;\n      double dx = post[c[i]].x-post[s[i]].x;\n      double dy = post[c[i]].y-post[s[i]].y;\n      wall[s[i]].push_back(P(atan2(dy,dx),i));\n      wall[c[i]].push_back(P(atan2(-dy,-dx),i));\n    }\n    for(int i=0;i<C;i++) sort(wall[i].begin(),wall[i].end());\n    int bt=0;\n    for(int i=0;i<C;i++){\n      for(int j=0;j<wall[i].size();j++){\n\twall_id[wall[i][j].second][i]=j;\n\tif(i==lp){\n\t  int u,v;\n\t  if(s[wall[i][j].second]==lp) u = c[wall[i][j].second];\n\t  else u = s[wall[i][j].second];\n\t  if(s[wall[i][bt].second]==lp) v = c[wall[i][bt].second];\n\t  else v = s[wall[i][j].second];\n\t  double tmp1 = atan2(post[u].y-post[i].y,post[u].x-post[i].x);\n\t  double tmp2 = atan2(post[v].y-post[i].y,post[v].x-post[i].x);\n\t  if(tmp1>tmp2) bt = j;\n\t}\n      }\n    }\n    out_i = wall[lp][bt].second;\n    out_v = lp;\n    for(int i=0;i<W;i++){\n      for(int j=0;j<C;j++){\n\tused[i][j] = false;\n      }\n    }\n    int node_cnt=0;\n    for(int i=0;i<W;i++){\n      if(used[i][s[i]]==false){\n\tmake_node(i,s[i],node_cnt);\n\tnode_cnt++;\n      }\n      if(used[i][c[i]]==false){\n\tmake_node(i,c[i],node_cnt);\n\tnode_cnt++;\n      }\n    }\n    for(int i=0;i<W;i++){\n      edge[area[i][0]].push_back(area[i][1]);\n      edge[area[i][1]].push_back(area[i][0]);\n    }\n    bfs(node_cnt,out);\n    int ans = 0;\n    for(int i=0;i<node_cnt;i++) ans=max(ans,dis[i]);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint bottom;\nint outside_color;\n\n// Library.\n#include<cassert>\n#include<map>\n#include<vector>\n#include<cmath>\n#include<queue>\n#include<algorithm>\n// Type.\ntypedef int Label;\ntypedef double Weight;\n// Class.\ntemplate<typename Vertex, typename Edge>\nclass PlaneGraph {\npublic:\n  void insert(const Vertex& v);\n  void insert(Edge e);\n  const PlaneGraph<Vertex, Edge> dualgraph() const;\n  const std::map<Label, Weight> Dijkstra(const Label& start) const;\nprivate:\n  void dualgraph_color(std::map<Label, std::map<Label, int>>& color, int c, const Edge& e, const std::map<Label, std::vector<Edge>>& edge) const;\n  std::map<Label, Vertex> V;\n  std::map<Label, std::vector<Edge>> E;\n};\n// Implement.\ntemplate<typename Vertex, typename Edge>\nvoid PlaneGraph<Vertex, Edge>::insert(const Vertex& v) {\n  V[v.label] = v;\n}\ntemplate<typename Vertex, typename Edge>\nvoid PlaneGraph<Vertex, Edge>::insert(Edge e) {\n  assert(V.find(e.from) != std::end(V));\n  assert(V.find(e.to) != std::end(V));\n  E[e.from].push_back(e);\n  std::swap(e.from, e.to);\n  E[e.from].push_back(e);\n}\ntemplate<typename Vertex, typename Edge>\nconst PlaneGraph<Vertex, Edge> PlaneGraph<Vertex, Edge>::dualgraph() const {\n  // Sort edges counterclockwise.\n  auto edge = E;\n  for(auto& list: edge) if(!list.second.empty()) {\n    std::sort(std::begin(list.second), std::end(list.second), [&](const Edge& lhs, const Edge& rhs) {\n      double l = std::atan2(V.at(lhs.to).y - V.at(lhs.from).y, V.at(lhs.to).x - V.at(lhs.from).x);\n      double r = std::atan2(V.at(rhs.to).y - V.at(rhs.from).y, V.at(rhs.to).x - V.at(rhs.from).x);\n      return l < r;\n    });\n    list.second.push_back(list.second.front());\n  }\n  // Color edges.\n  std::map<Label, std::map<Label, int>> color;\n  int c = 1;\n  for(const auto& list: edge) {\n    for(const auto& e: list.second) if(!color[e.from].count(e.to)) dualgraph_color(color, c++, e, edge);\n    if(list.first == bottom) outside_color = color[list.second.front().from][list.second.front().to];\n  }\n  // Construct the dualgraph.\n  PlaneGraph<Vertex, Edge> result;\n  std::vector<std::vector<bool>> used(c, std::vector<bool>(c, false));\n  for(int i = 1; i < c; ++i) result.insert(Vertex({i}));\n  for(const auto& list: E) for(const auto& e: list.second) if(!used[color[e.from][e.to]][color[e.to][e.from]]) {\n    used[color[e.from][e.to]][color[e.to][e.from]] = true;\n    used[color[e.to][e.from]][color[e.from][e.to]] = true;\n    result.insert(Edge({color[e.from][e.to], color[e.to][e.from], 1}));\n  }\n  return result;\n}\ntemplate<typename Vertex, typename Edge>\nvoid PlaneGraph<Vertex, Edge>::dualgraph_color(std::map<Label, std::map<Label, int>>& color, int c, const Edge& e, const std::map<Label, std::vector<Edge>>& edge) const {\n  color[e.from][e.to] = c;\n  for(auto it = edge.at(e.to).rbegin(); it != edge.at(e.to).rend(); ++it) if(it->to == e.from) {\n    ++it;\n    if(!color[it->from].count(it->to)) dualgraph_color(color, c, *it, edge);\n    break;\n  }\n}\ntemplate<typename Vertex, typename Edge>\nconst std::map<Label, Weight> PlaneGraph<Vertex, Edge>::Dijkstra(const Label& start) const {\n  std::map<Label, Weight> result;\n  std::priority_queue<Edge, std::vector<Edge>, std::function<bool(Edge, Edge)>> q([](Edge lhs, Edge rhs) {\n    return lhs.weight >= rhs.weight;\n  });\n  q.push(Edge({start, start, 0}));\n  while(!q.empty()) {\n    auto cur = q.top();\n    q.pop();\n    result[cur.to] = cur.weight;\n    for(const auto& nex: E.at(cur.to)) if(!result.count(nex.to)) q.push(Edge({nex.from, nex.to, cur.weight + nex.weight}));\n  }\n  return result;\n}\n////////////////////////////////////////\n// Configuration.\nstruct Vertex {Label label; double x, y;};\nstruct Edge {Label from, to; Weight weight;};\n////////////////////////////////////////\n#include<bits/stdc++.h>\nusing namespace std;\nint main() {\n  int C, W;\n  while(cin >> C >> W, C | W) {\n    vector<Vertex> pillar;\n    int bottom_x = 1001, bottom_y = 1001;\n    for(int i = 0; i < C; ++i) {\n      double x, y;\n      cin >> x >> y;\n      pillar.push_back({i, x, y});\n      if(bottom_y < y) continue;\n      if(bottom_y == y && bottom_x < x) continue;\n      bottom_x = x;\n      bottom_y = y;\n      bottom = i;\n    }\n    PlaneGraph<Vertex, Edge> G;\n    for(const auto& p: pillar) G.insert(p);\n    for(int i = 0; i < W; ++i) {\n      int s, t;\n      cin >> s >> t;\n      --s; --t;\n      G.insert(Edge({s, t, 1}));\n    }\n    auto D = G.dualgraph();\n    auto distance = D.Dijkstra(outside_color);\n    double answer = 0;\n    for(const auto& d: distance) answer = max(answer, d.second);\n    cout << answer << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n\n/* ??????????????¬ */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\n\nconst ld pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// ????????\\???\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// ????????????????????????\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// ??????\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// ??????\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn Point();\n\t\t}\n\t}\n};\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(nb, nc) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(nb, nc) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n\n\n/* ???????????? */\n\n// ??´?????¨??´??????????????????\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// ????????´????????????\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// ?????????????????????\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// ??????????¶?\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// ??´?????¨??´????????????\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n// ??´?????¨??´????????????\nvector<Point> is_ll2(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tif (cross(sv, tv) != 0)return vector<Point>(1, is_ll(s, t));\n\telse {\n\t\tvector<Point>ans;\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tif (isis_sp(s, t[k]) && find(ans.begin(), ans.end(), t[k]) == ans.end())ans.push_back(t[k]);\n\t\t\tif (isis_sp(t, s[k]) && find(ans.begin(), ans.end(), s[k]) == ans.end())ans.push_back(s[k]);\n\t\t}\n\t\treturn ans;\n\t}\n}\n// ????????¨???????????????\n//???????????£????????¨???????????¨assert(false)\nPoint is_ss(const Line &s, const Line& t) {\n\tif (isis_ss(s, t)) {\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\tif (s[k] == t[l])return s[k];\n\t\t\t}\n\t\t}\n\t\treturn is_ll(s, t);\n\t}\n\telse {\n\t\t//??????isis_ss?????????\n\t\tassert(false);\n\t\treturn Point(0, 0);\n\t}\n}\n// ????????¨???????????????\nvector<Point> is_ss2(const Line &s, const Line& t) {\n\tvector<Point> kouho(is_ll2(s, t));\n\tvector<Point>ans;\n\tfor (auto p : kouho) {\n\t\tif (isis_sp(s, p) && isis_sp(t, p))ans.emplace_back(p);\n\t}\n\treturn ans;\n}\n// ??´?????¨???????????¢\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// ??´?????¨??´???????????¢\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//??´?????¨??´?????????????????????????????????\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0])<eps) ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0])<eps) ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nPoint  inner_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i <static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vertics[0];\n\tLine bi1(bisection(Line(vertics[0], vertics[1]), Line(vertics[0], vertics[2])));\n\tLine bi2(bisection(Line(vertics[1], vertics[2]), Line(vertics[1], vertics[0])));\n\tif (bi1[0] == bi2[0])return bi1[0];\n\telse {\n\t\treturn is_ll(bi1, bi2);\n\t}\n}\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nvector<Point>  ex_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (abs(vertics[0] - vertics[1])<eps || abs(vertics[1] - vertics[2])<eps || (abs(vertics[2] - vertics[0])<eps))return vector<Point>();\n\tvector<Point>ecs;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tLine bi1(bisection(Line(vertics[i], vertics[i] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[i], vertics[(i + 1) % 3])));\n\t\tLine bi2(bisection(Line(vertics[(i + 1) % 3], vertics[(i + 1) % 3] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[(i + 1) % 3], vertics[i])));\n\t\tecs.push_back(is_ll(bi1, bi2));\n\t}\n\treturn ecs;\n}\n\n\n//a,b:??????\n//c:????????§??????\n//???????????´?????????????????¢?????????????±??????????\nvector<Point>  same_dis(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tvertics.push_back(is_ll(ls[0], ls[2]));\n\tvertics.push_back(is_ll(ls[1], ls[2]));\n\n\tif (abs(vertics[0] - vertics[1]) < eps)return vector<Point>{vertics[0]};\n\tLine bis(bisection(ls[0], ls[1]));\n\tvector<Point>ecs;\n\n\tLine abi(bisection(Line(vertics[0], vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, abi));\n\n\n\tLine bbi(bisection(Line(vertics[0], 2.l*vertics[0] - vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, bbi));\n\n\treturn ecs;\n}\n/* ??? */\n\n// ?????¨????????????\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n//???????????????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_circle(const Circle &cir, const  Point& p) {\n\tld dis = abs(cir.p - p);\n\tif (dis > cir.r + eps)return 0;\n\telse if (dis < cir.r - eps)return 2;\n\telse return 1;\n}\n//???lc??????rc??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint circle_in_circle(const Circle &lc, const  Circle&rc) {\n\tld dis = abs(lc.p - rc.p);\n\tif (dis < rc.r - lc.r - eps)return 2;\n\telse if (dis>rc.r - lc.r + eps)return 0;\n\telse return 1;\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n//??????????????????????????¢???\nld two_circle_area(const Circle&l, const Circle&r) {\n\tld dis = abs(l.p - r.p);\n\tif (dis > l.r + r.r)return 0;\n\telse if (dis + r.r < l.r) {\n\t\treturn r.r*r.r*pi;\n\t}\n\telse if (dis + l.r < r.r) {\n\t\treturn l.r*l.r*pi;\n\t}\n\telse {\n\t\tld ans = (l.r)*(l.r)*acos((dis*dis + l.r*l.r - r.r*r.r) / (2 * dis*l.r)) +\n\t\t\t(r.r)*(r.r)*acos((dis*dis + r.r*r.r - l.r*l.r) / (2 * dis*r.r)) -\n\t\t\tsqrt(4 * dis*dis*l.r*l.r - (dis*dis + l.r*l.r - r.r*r.r)*(dis*dis + l.r*l.r - r.r*r.r)) / 2;\n\t\treturn ans;\n\t}\n\n}\n\n/* ????§???¢ */\n\ntypedef vector<Point> Polygon;\n\n// ??¢???\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// ????§???¢????????¢??????\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// ??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//??????????????????2?????????\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// ??????\n// ???????????????????????¨????????????????????§??¨???\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n// ????????????\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ Q,R };\n\treturn polys;\n}\n\n\n/* ??¢??¬??????????????? */\nvoid add_point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, static_cast<Weight>(abs(p[from] - p[to])));\n\t\t}\n\t}\n\treturn g;\n}\nGraph sennbunn_arrangement(const vector<Line>&s) {\n\tvector<Point>crss;\n\tfor (int i = 0; i < static_cast<int>(s.size()); ++i) {\n\t\tfor (int j = i + 1; j < static_cast<int>(s.size()); ++j) {\n\t\t\tif (isis_ss(s[i], s[j])) {\n\t\t\t\tcrss.push_back(is_ll(s[i], s[j]));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i <static_cast<int>(s.size()); ++i) {\n\t\tcrss.push_back(s[i][0]);\n\t\tcrss.push_back(s[i][1]);\n\t}\n\treturn segment_arrangement(s, crss);\n}\n\n//Graph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n//\tint n = p.size(), m = c.size();\n//\tGraph g(n);\n//\tREP(i, m) {\n//\t\tvector<pair<ld, int>> vec;\n//\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n//\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n//\t\tsort(ALL(vec));\n//\t\tREP(j, vec.size() - 1) {\n//\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n//\t\t\tld angle = vec[j + 1].first - vec[j].first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t\tif (vec.size() >= 2) {\n//\t\t\tint from = vec.back().second, to = vec.front().first;\n//\t\t\tld angle = vec.front().first - vec.back().first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\n/* ????????°?????? */\n\n// ?????????????????¢?????¢??¬??????????????????????????????????????°???????????????\n// ?????´?????????????¨?????????§????????´????????????????¨?????????§???????????????\n// ?????° polygon ??????vector<int> ??§??¨?????????????§???¢???????????§?????????\n// vector<int> ??§??¨????????? ????§???¢???i???????????????????????????????????????p????????????????????§?????????\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\npair<int,Graph> dual_graph(const vector<Line> &s, const vector<Point> &p) {\n\tint N = p.size();\n\tpolygon.clear();\n\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n\tvector<vector<tuple<ld, int, bool>>> tup(N);\n\tREP(i, s.size()) {\n\t\tint a = -1, b = -1;\n\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n\t\tassert(a >= 0 && b >= 0);\n\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n\t}\n\tREP(i, N) sort(ALL(tup[i]));\n\tREP(i, N) {\n\t\tREP(j, tup[i].size()) {\n\t\t\tld angle; int pos = j, from = i, to; bool flag;\n\t\t\ttie(angle, to, flag) = tup[i][j];\n\t\t\tif (flag) continue;\n\t\t\tvector<int> ps;\n\t\t\twhile (!flag) {\n\t\t\t\tps.push_back(from);\n\t\t\t\tget<2>(tup[from][pos]) = true;\n\t\t\t\tseg2p[from][to].push_back(polygon.size());\n\t\t\t\tseg2p[to][from].push_back(polygon.size());\n\t\t\t\tangle += pi + eps;\n\t\t\t\tif (angle > pi) angle -= 2 * pi;\n\t\t\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n\t\t\t\tif (it == tup[to].end()) it = tup[to].begin();\n\t\t\t\tfrom = to; tie(angle, to, flag) = *it;\n\t\t\t\tpos = it - tup[from].begin();\n\t\t\t}\n\t\t\tpolygon.push_back(ps);\n\t\t}\n\t}\n\tint aa=0;\n\tld amax = 0;\n\tfor (int i = 0; i < int(polygon.size()); ++i) {\n\t\tvector<Point>ps;\n\t\tfor (auto id : polygon[i]) {\n\t\t\tps.push_back(p[id]);\n\t\t}\n\t\tld aarea = area(ps);\n\t\tif (amax < aarea) {\n\t\t\taa = i;\n\t\t\tamax = aarea;\n\t\t}\n\t}\n\tGraph g(polygon.size());\n\tREP(i, N) REP(j, i) {\n\t\tif (seg2p[i][j].size() == 2) {\n\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n\t\t\tg[from].push_back(Edge{ from, to,1 });\n\t\t\tg[to].push_back(Edge{ to, from,1 });\n\t\t}\n\t}\n\treturn make_pair(aa,g);\n}\n\n\nint main() {\n\twhile (1) {\n\t\tint C, W; cin >> C >> W;\n\t\tif (!C)break;\n\t\tvector<Point>ps;\n\t\tfor (int i = 0; i < C; ++i) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tps.emplace_back(x, y);\n\t\t}\n\t\tvector<Line>ls;\n\t\tfor (int i = 0; i < W; ++i) {\n\t\t\tint s, t; cin >> s >> t; s--; t--;\n\t\t\tls.emplace_back(ps[s], ps[t]);\n\t\t}\n\t\tauto p=dual_graph(ls, ps);\n\t\tGraph g = p.second;\n\t\tconst int start = p.first;\n\t\tvector<int>oks(g.size());\n\t\tqueue<pair<int, int>>que;\n\t\tque.push(make_pair(start, 0));\n\t\toks[start] = true;\n\t\tint ans = 0;\n\t\twhile (!que.empty()) {\n\t\t\tauto p(que.front());\n\t\t\tque.pop();\n\t\t\tans = p.second;\n\t\t\tfor (auto e : g[p.first]) {\n\t\t\t\tif (!oks[e.dst]) {\n\t\t\t\t\toks[e.dst] = true;\n\t\t\t\t\tque.push(make_pair(e.dst, p.second + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<int,int> state;\n\nint N,M;\nP t[100];\nint f[100][100];\nint d[100][100];\n\nvoid init(){\n  memset(f,0,sizeof(f));\n  memset(d,1,sizeof(d));\n}\n\nint solve(){\n  int si=0,ti;\n  double maxm=-10;\n  for(int i=0;i<N;i++)\n    if(t[si].real()<t[i].real())si=i;\n  \n  for(int i=0;i<N;i++)\n    if(f[si][i] && maxm < arg(t[i]-t[si]))\n      ti=i,maxm=arg(t[i]-t[si]);\n\n  deque<state> Q;  \n  Q.push_back(state(si,ti));\n  d[si][ti]=0;\n  \n  int ans=0;\n  while(!Q.empty()){\n    state p=Q.front();\n    Q.pop_front();\n    int from=p.first;\n    int to=p.second;\n    ans=d[from][to];\n    \n    if(d[from][to]+1<d[to][from]){\n      d[to][from]=d[from][to]+1;\n      Q.push_back(state(to,from));\n    }\n    int id=-1;\n    double mini=1e9;\n    for(int i=0;i<N;i++){\n      if(f[to][i]&&i!=from){\n        if( arg( (t[i]-t[to])*conj(t[to]-t[from]) ) < mini){\n          id=i;\n          mini=arg( (t[i]-t[to])*conj(t[to]-t[from]) );\n        }\n      }\n    }\n    if(id!=-1&&d[to][id]>d[from][to]){\n      d[to][id]=d[from][to];\n      Q.push_front(state(to,id));\n    }\n  }\n  return ans;\n}\n\nint main(){\n  while(1){\n    cin>>N>>M;\n    if(N==0&&M==0)break;\n    init();\n    for(int i=0;i<N;i++){\n      int x,y;\n      cin>>x>>y;\n      t[i]=P(x,y);\n    }\n    for(int i=0;i<M;i++){\n      int x,y;\n      cin>>x>>y;\n      x--,y--;\n      f[x][y]=f[y][x]=true;\n    }\n    cout<<solve()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<climits>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reg(i,a,b) for(int i=(a);i<=(b);i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=(b);i>=(a);i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\ntypedef pair<double,mp> mmp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n\n\nint px[105];\nint py[105];\nint pn,wn;\n\nvector<mmp> ws[105];\n\nvector<mp> vs[1005];\n\nint gone[1005]={};\n\nvoid cons(mmp& ne,int fr){\n\tint to = ne.sec.fir;\n\tint c1 = ne.sec.sec;\n\tne.sec.sec=-1;\n\tmmp& nexte = ne;\n\trep(i,ws[to].size()){\n\t\tmmp e = ws[to][i];\n\t\tif(e.sec.fir == fr){\n\t\t\tnexte = ws[to][ (i+1)%ws[to].size() ];\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tint cw = nexte.sec.sec;\n\tif(cw==-1)return;\n\n\tvs[cw].push_back(mp(c1,0));\n\tvs[c1].push_back(mp(cw,0));\n\t\n\tcons(nexte,to);\t\n\t\n}\n\nint main(void){\n\t\nwhile(1){\n\t\t\n\tscanf(\"%d%d\",&pn,&wn);\n\tif(pn == 0)break;\n\tmemset(px,0,sizeof(px));\n\tmemset(py,0,sizeof(py));\n\tmemset(gone,0,sizeof(gone));\n\trep(i,105){\n\t\tws[i].clear();\n\t}\n\trep(i,1005){\n\t\tvs[i].clear();\n\t}\n\t\n\t\n\tvector<pair<int,mp> > sv;\n\trep(i,pn){\n\t\tscanf(\"%d%d\",&px[i],&py[i]);\n\t\tsv.push_back(make_pair(i,mp(px[i],py[i])));\n\t}\n\t\n\tsort(sv.begin(),sv.end());\n\t\n\tint nminv = sv[0].first;\n\t\n\trep(i,wn){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\ta--; b--;\n\t\tint nvx = px[b]-px[a];\n\t\tint nvy = py[b]-py[a];\n\t\tws[a].push_back( mmp(atan2(nvy,nvx), mp(b,i*2)) );\n\t\tws[b].push_back( mmp(atan2(-nvy,-nvx), mp(a,i*2+1)) );\n\t\tvs[i*2].push_back( mp(i*2+1,1) );\n\t\tvs[i*2+1].push_back( mp(i*2,1) );\n\t}\n\t\n\trep(i,pn){\n\t\tsort(ws[i].begin(),ws[i].end());\n\t}\n\t\n\tint nsoto = ws[nminv][0].second.second;\n\t\n\t\n\t\n\trep(i,pn){\n\t\trep(j,ws[i].size()){\n\t\t\tif(ws[i][j].sec.sec==-1)continue;\n\t\t\tcons(ws[i][j],i);\n\t\t}\n\t}\n\t\n\t/*\n\tprintf(\"soto .. %d\\n\",nsoto);\n\trep(i,1005){\n\t\trep(j,vs[i].size()){\n\t\t\tprintf(\"(%d %d %d) \",i,vs[i][j].fir,vs[i][j].sec);\n\t\t}\n\t}*/\n\t\n\t\n\tpriority_queue<mp,vector<mp>,greater<mp> > que;\n\tque.push(mp(0,nsoto));\n\t\n\tint ans=0;\n\twhile(!que.empty()){\n\t\tmp pa = que.top();\n\t\tque.pop();\n\t\tint no = pa.sec,\n\t\t\tnc = pa.fir;\n\t\tif(gone[no]!=0)continue;\n\t\tans = max(ans,nc);\n\t\tgone[no]=1;\n\t\trep(i,vs[no].size()){\n\t\t\tint to = vs[no][i].fir;\n\t\t\tif(gone[to])continue;\n\t\t\tque.push( mp(nc + vs[no][i].sec,to));\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\t\n}\n\t\n\treturn 0;\n}\n\n\n/*\n4 5\n\n0 0\n1 1\n0 1\n0 2\n\n1 2\n1 3\n2 3\n3 4\n2 4\n\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <fstream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <functional>\n#include <ctime>\n#include <numeric>\n#include <unordered_set>\n#include <unordered_map>\n\nusing namespace std;\n\n#define fst first\n#define snd second\n#define all(c) ((c).begin()), ((c).end())\n#define TEST(x,a) { auto y=(x); if (sign(y-a)) { cout << \"line \" << __LINE__  << #x << \" = \" << y << \" != \" << a << endl; exit(-1); } }\n\nconst double EPS = 1e-8;\nint sign(double x) {\n  if (x < -EPS) return -1;\n  if (x > +EPS) return +1;\n  return 0;\n}\nstruct point {\n  typedef double T;\n  T x, y; \n  point &operator+=(point p) { x += p.x; y += p.y; return *this; }\n  point &operator-=(point p) { x -= p.x; y -= p.y; return *this; }\n  point &operator*=(T a)     { x *= a;   y *= a;   return *this; }\n  point &operator/=(T a)     { return *this *= (1.0/a); }\n  point operator-() const    { return {-x, -y}; }\n  bool operator<(point p) const { \n    int s = sign(x - p.x);\n    return s ? s < 0 : sign(y - p.y) < 0;\n  }\n};\nbool operator==(point p, point q) { return !(p < q) && !(q < p); }\npoint operator+(point p, point q) { return p += q; }\npoint operator-(point p, point q) { return p -= q; }\npoint operator*(point::T a, point p) { return p *= a; }\npoint operator*(point p, point::T a) { return p *= a; }\npoint operator/(point p, point::T a) { return p /= a; }\npoint::T dot(point p, point q) { return p.x*q.x+p.y*q.y; }\npoint::T cross(point p, point q) { return p.x*q.y-p.y*q.x; } // left turn > 0\npoint::T norm2(point p) { return dot(p,p); }\npoint orth(point p) { return {-p.y, p.x}; }\npoint::T norm(point p) { return sqrt(dot(p,p)); }\npoint::T arg(point p) { return atan2(p.y, p.x); }\n\nstruct line { point p, q; };\nbool operator==(line l, line m) {\n  return !sign(cross(l.p-l.q,m.p-m.q)) && !sign(cross(l.p-l.q,m.p-l.p));\n}\n\nstruct segment { point p, q; };\nbool operator==(segment l, line m) {\n  return (l.p==m.p && l.q==m.q) || (l.p==m.q && l.q==m.p); // do not consider the direction\n}\nstruct circle { point p; point::T r; };\nbool operator==(circle c, circle d) { return c.p == d.p && !sign(c.r - d.r); }\n\ntypedef vector<point> polygon;\n\nstruct polar_angle {\n  const point o;\n  const int s; // +1 for ccw, -1 for cw\n  polar_angle(point p = {0,0}, int s = +1) : o(p), s(s) { }\n  int quad(point p) const {\n    for (int i = 1; i <= 4; ++i, swap(p.x = -p.x, p.y))\n      if (p.x > 0 && p.y >= 0) return i;\n    return 0;\n  }\n  bool operator()(point p, point q) const {\n    p = p - o; q = q - o;\n    if (quad(p) != quad(q)) return s*quad(p) < s*quad(q);\n    if (cross(p, q)) return s*cross(p, q) > 0;\n    return norm2(p) < norm2(q); // closer first\n  }\n};\n\nvector<point> intersect(segment s, segment t) {\n  auto a = cross(s.q - s.p, t.q - t.p);\n  auto b = cross(t.p - s.p, t.q - t.p); \n  auto c = cross(s.q - s.p, s.p - t.p);\n  if (a < 0) { a = -a; b = -b; c = -c; }\n  if (sign(b) < 0 || sign(a-b) < 0 ||\n      sign(c) < 0 || sign(a-c) < 0) return {};      // disjoint\n  if (sign(a) != 0) return {s.p + b/a*(s.q - s.p)}; // properly crossing\n  vector<point> ps;                                 // same line\n  auto insert_if_possible = [&](point p) {\n    for (auto q: ps) if (sign(dot(p-q, p-q)) == 0) return;\n    ps.push_back(p);\n  };\n  if (sign(dot(s.p-t.p, s.q-t.p)) <= 0) insert_if_possible(t.p);\n  if (sign(dot(s.p-t.q, s.q-t.q)) <= 0) insert_if_possible(t.q);\n  if (sign(dot(t.p-s.p, t.q-s.p)) <= 0) insert_if_possible(s.p);\n  if (sign(dot(t.p-s.q, t.q-s.q)) <= 0) insert_if_possible(s.q);\n  return ps;\n}\n\nstruct arrangement {\n  struct edge {\n    int src, dst;\n    point::T weight;\n    size_t id, rev;\n  };\n  int n;\n  vector<point> ps; // ps[id[p]] = p, id[ps[k]] = k\n  map<point,int> id; \n  vector<vector<edge>> adj;\n\n  arrangement(vector<segment> ss) : n(0) {\n    vector<vector<pair<point::T, int>>> group(ss.size());\n    auto append = [&](int i, point p) {\n      if (!id.count(p)) { id[p] = n++; ps.push_back(p); }\n      group[i].push_back({norm(ss[i].p - p), id[p]});\n    };\n    for (int i = 0; i < ss.size(); ++i) {\n      append(i, ss[i].p); append(i, ss[i].q);\n      for (int j = 0; j < i; ++j) {\n        for (point p: intersect(ss[i], ss[j])) {\n          append(i, p); append(j, p);\n        }\n      }\n    }\n    adj.resize(n);\n    for (auto &vs: group) {\n      sort(all(vs));\n      for (int i = 0; i+1 < vs.size(); ++i) {\n        auto u = vs[i].snd, v = vs[i+1].snd;\n        if (u == v) continue;\n        auto len = vs[i+1].fst - vs[i].fst;\n        adj[u].push_back({u, v, len});\n        adj[v].push_back({v, u, len});\n      }\n    }\n    // remove duplicates and orient edges\n    vector<unordered_map<int, int>> idx(n);\n    for (int u = 0; u < n; ++u) {\n      auto eq = [&](edge e, edge f) { return e.dst == f.dst; };\n      auto lt = [&](edge e, edge f) { return e.dst <  f.dst; };\n      sort(all(adj[u]), lt);\n      adj[u].erase(unique(all(adj[u]), eq), adj[u].end());\n      sort(all(adj[u]), [&](edge e, edge f) {\n        return arg(ps[e.dst] - ps[e.src]) > arg(ps[f.dst] - ps[f.src]);\n      });\n      for (int i = 0; i < adj[u].size(); ++i) {\n        adj[u][i].id = i;\n        int v = adj[u][i].dst;\n        idx[u][v] = i;\n        if (idx[v].count(u)) {\n          int j = idx[v][u];\n          adj[u][i].rev = j;\n          adj[v][j].rev = i;\n        }\n      }\n    }\n  }\n  edge twin(edge e) const { return adj[e.dst][e.rev]; }\n  edge next(edge e) const {\n    int j = adj[e.dst][e.rev].id + 1;\n    if (j >= adj[e.dst].size()) j = 0;\n    return adj[e.dst][j];\n  }\n};\n\nint main() {\n  for (int c, w; ~scanf(\"%d %d\", &c, &w) && c; ) {\n    vector<point> ps(c);\n    for (int i = 0; i < c; ++i) \n      scanf(\"%lf %lf\", &ps[i].x, &ps[i].y);\n    vector<segment> ss;\n    for (int i = 0; i < w; ++i) {\n      int u, v; scanf(\"%d %d\", &u, &v);\n      ss.push_back({ps[u-1], ps[v-1]});\n    }\n    arrangement arr(ss);\n\n    int s = 0;\n    for (int i = 1; i < c; ++i) \n      if (ps[s] < ps[i]) s = i;\n    typedef arrangement::edge edge;\n    edge e = arr.adj[s][0]; // outer-face edge\n\n    vector<unordered_map<int,int>> step(c);\n    queue<edge> que;\n    auto proceed = [&](edge s, int value) {\n      if (step[s.src].count(s.dst)) return;\n      edge e = s;\n      do {\n        step[e.src][e.dst] = value;\n        que.push(arr.twin(e));\n        e = arr.next(e);\n      } while (e.src != s.src || e.dst != s.dst);\n    };\n    proceed(e, 0);\n    int ans = 0;\n    while (!que.empty()) {\n      edge e = que.front(); que.pop();\n      ans = step[e.dst][e.src];\n      proceed(e, ans + 1);\n    }\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <functional>\n#include <iterator>\n#include <limits>\n#include <numeric>\n#include <utility>\n#include <cmath>\n#include <cassert>\n#include <cstdio>\n\nusing namespace std; using namespace placeholders;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector< int > VI;\ntypedef vector< vector< int > > VVI;\ntypedef vector< string > VS;\ntypedef stringstream SS;\ntypedef pair< int, int > PII;\ntypedef vector< pair< int, int > > VPII;\n#define VT( T ) vector< T >\n#define VVT( T ) vector< vector< T > >\n#define LIM( T ) numeric_limits< T >\n\ntemplate < typename T > inline istream& operator>>( istream &s, vector< T > &v ){ for ( T &t : v ) { s >> t; } return s; }\ntemplate < typename T > inline ostream& operator<<( ostream &s, const vector< T > &v ){ for ( int i = 0; i < int( v.size() ); ++i ){ s << ( \" \" + !i ) << v[i]; } return s; }\ntemplate < typename T > inline T fromString( const string &s ) { T res; istringstream iss( s ); iss >> res; return res; };\ntemplate < typename T > inline string toString( const T &a ) { ostringstream oss; oss << a; return oss.str(); };\n\n#define REP2( i, n ) REP3( i, 0, n )\n#define REP3( i, m, n ) for ( int i = ( int )( m ); i < ( int )( n ); ++i )\n#define GET_REP( a, b, c, F, ... ) F\n#define REP( ... ) GET_REP( __VA_ARGS__, REP3, REP2 )( __VA_ARGS__ )\n#define FOR( e, c ) for ( auto &e : c )\n#define ALL( c ) ( c ).begin(), ( c ).end()\n#define AALL( a, t ) ( t* )a, ( t* )a + sizeof( a ) / sizeof( t )\n#define DRANGE( c, p ) ( c ).begin(), ( c ).begin() + p, ( c ).end()\n\n#define SZ( v ) ( (int)( v ).size() )\n#define PB push_back\n#define EM emplace\n#define EB emplace_back\n#define BI back_inserter\n\n#define EXIST( c, e ) ( ( c ).find( e ) != ( c ).end() )\n\n#define MP make_pair\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\n#include <complex>\nusing Point =  complex< double >;\nconstexpr double EPS = 1e-8;\nconstexpr double PI = acos( -1 );\nconstexpr Point O( 0, 0 );\n\n// 入力ストリームから実数二つをとって Point へ\nistream& operator>> ( istream &s, Point &a )\n{\n\tdouble r, i;\n\ts >> r >> i;\n\ta = Point( r, i );\n\treturn s;\n}\n\n// 偏角\nstruct CompArg : public binary_function<Point,Point,bool>\n{\n\tbool operator ()( const Point &a, const Point &b ) const\n\t{\n\t\treturn arg( a ) < arg( b );\n\t}\n};\n\n// 内積（ドット積）\ndouble dot( const Point &a, const Point &b )\n{\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\n\n// 外積（クロス積）\ndouble cross( const Point &a, const Point &b )\n{\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\n\nclass DualGraph\n{\n\tusing Edge = std::tuple< int, int, int, Point >;\n\t// ( to, rev-edge, edge id, angle )\n\n\tconst int N;\n\tint M;\n\tconst std::vector< Point > ps_;\n\tstd::vector< std::vector< Edge > > G;\n\tstd::vector< std::vector< int > > edge_indices_, edge_poss_;\n\tstd::vector< std::vector< bool > > used_;\n\n\tint outer_ = -1;\n\tstd::vector< std::vector< Point > > areas_;\n\n\tstd::vector< std::vector< int > > intersects_;\n\npublic:\n\tDualGraph( const std::vector< Point > &ps ) :\n\t\tN( ps.size() ), M( 0 ), ps_( ps ), G( N ), edge_indices_( N ), edge_poss_( N ), used_( N )\n\t{\n\t\treturn;\n\t}\n\n\tvoid connect( const int a, const int b )\n\t{\n\t\tG[a].emplace_back( b, G[b].size(), M, ps_[b] - ps_[a] );\n\t\tG[b].emplace_back( a, G[a].size() - 1, M, ps_[a] - ps_[b] );\n\t\t++M;\n\n\t\treturn;\n\t}\n\n\tvoid solve()\n\t{\n\t\tsort_edges();\n\n\t\tfor ( int v = 0; v < N; ++v )\n\t\t{\n\t\t\tfor ( int i = 0; i < int( G[v].size() ); ++i )\n\t\t\t{\n\t\t\t\tif ( used_[v][i] )\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tdfs( v, i );\n\t\t\t}\n\t\t}\n\n\t\treturn;\n\t}\n\nprivate:\n\tvoid sort_edges()\n\t{\n\t\tCompArg comp;\n\t\tfor ( int v = 0; v < N; ++v )\n\t\t{\n\t\t\tedge_indices_[v].resize( G[v].size() );\n\t\t\tstd::iota( begin( edge_indices_[v] ), end( edge_indices_[v] ), 0 );\n\n\t\t\tstd::sort( begin( edge_indices_[v] ), end( edge_indices_[v] ), \n\t\t\t\t\t[&]( const int i, const int j ){ return comp( get< 3 >( G[v][i] ), get< 3 >( G[v][j] ) ); } );\n\n\t\t\tedge_poss_[v].resize( G[v].size() );\n\t\t\tfor ( int i = 0; i < int( G[v].size() ); ++i )\n\t\t\t{\n\t\t\t\tedge_poss_[v][ edge_indices_[v][i] ] = i;\n\t\t\t}\n\n\t\t\tused_[v].resize( G[v].size() );\n\t\t}\n\t\tintersects_.resize( M );\n\n\t\treturn;\n\t}\n\n\tvoid dfs( const int sv, const int se )\n\t{\n\t\tstd::vector< Point > area;\n\n\t\tfor ( int v = sv, e = se; area.empty() || v != sv; )\n\t\t{\n\t\t\tused_[v][e] = true;\n\t\t\tarea.push_back( ps_[v] );\n\t\t\tintersects_[ get< 2 >( G[v][e] ) ].push_back( areas_.size() );\n\n\t\t\tconst int r = get< 1 >( G[v][e] );\n\t\t\tv = get< 0 >( G[v][e] );\n\t\t\te = edge_indices_[v][ ( edge_poss_[v][r] + G[v].size() - 1 ) % G[v].size() ];\n\t\t}\n\n\t\t{\n\t\t\tdouble theta = 0;\n\t\t\tfor ( int i = 0; i < int( area.size() ); ++i )\n\t\t\t{\n\t\t\t\tconst Point p1 = area[ ( i + 1 ) % area.size() ] - area[i];\n\t\t\t\tconst Point p2 = area[ ( i + 2 ) % area.size() ] - area[i];\n\t\t\t\ttheta += atan2( cross( p1, p2 ), dot( p1, p2 ) );\n\t\t\t}\n\t\t\tif ( theta < 0 )\n\t\t\t{\n\t\t\t\touter_ = areas_.size();\n\t\t\t}\n\t\t}\n\n\t\tareas_.push_back( area );\n\t\t\n\t\treturn;\n\t}\n\n\t// results\npublic:\n\tint area_number() const\n\t{\n\t\treturn areas_.size();\n\t}\n\n\tstd::vector< std::vector< Point > > areas() const\n\t{\n\t\treturn areas_;\n\t}\n\n\tstd::vector< std::pair< int, int > > edges() const\n\t{\n\t\tstd::vector< std::pair< int, int > > res;\n\t\tfor ( auto &row : intersects_ )\n\t\t{\n\t\t\tres.emplace_back( row[0], row[1] );\n\t\t}\n\t\treturn res;\n\t}\n\n\tint outer() const\n\t{\n\t\treturn outer_;\n\t}\n};\n\nconstexpr int INF = LIM( int )::max() / 2;\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\tfor ( int N, M; cin >> N >> M && ( N | M ); )\n\t{\n\t\tVT( Point ) ps( N );\n\t\tcin >> ps;\n\n\t\tVI s( M ), t( M );\n\t\tREP( i, M )\n\t\t{\n\t\t\tcin >> s[i] >> t[i];\n\t\t\t--s[i], --t[i];\n\t\t}\n\n\t\tDualGraph dualgraph( ps );\n\t\tREP( i, M )\n\t\t{\n\t\t\tdualgraph.connect( s[i], t[i] );\n\t\t}\n\t\tdualgraph.solve();\n\n\t\tconst int V = dualgraph.area_number();\n\t\tVVI G( V );\n\t\t{\n\t\t\tVPII es = dualgraph.edges();\n\t\t\tFOR( e, es )\n\t\t\t{\n\t\t\t\tconst int a = e.fst, b = e.snd;\n\t\t\t\tG[a].PB( b );\n\t\t\t\tG[b].PB( a );\n\t\t\t}\n\t\t}\n\n\t\tVI distances( V, INF );\n\t\tdistances[ dualgraph.outer() ] = 0;\n\n\t\tqueue< int > que;\n\t\tque.push( dualgraph.outer() );\n\n\t\twhile ( !que.empty() )\n\t\t{\n\t\t\tconst int u = que.front();\n\t\t\tque.pop();\n\n\t\t\tFOR( v, G[u] )\n\t\t\t{\n\t\t\t\tif ( distances[u] + 1 < distances[v] )\n\t\t\t\t{\n\t\t\t\t\tdistances[v] = distances[u] + 1;\n\t\t\t\t\tque.push( v );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << *max_element( ALL( distances ) ) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <bitset>\n#include <cmath>\n#include <algorithm>\n\n#define TIMES(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef bitset<600> Spec;\nconst double EPS = 1e-9;\nconst double PI = acos(-1);\n\nint cmp(double a, double b) {\n    const double diff = a-b;\n    if(fabs(diff) < EPS) return 0;\n    return diff < 0 ? -1 : 1;\n}\n\ndouble dot(const P &a, const P &b) {\n    return a.real()*b.real() + a.imag()*b.imag();\n}\n\ndouble cross(const P &a, const P &b) {\n    return a.real()*b.imag() - a.imag()*b.real();\n}\n\nint root(int n, vector<int> &roots) {\n    if(roots[n] == n) return n;\n    return roots[n] = root(roots[n], roots);\n}\n\nbool unite(int a, int b, vector<int> &roots) {\n    const int ra = root(a, roots);\n    const int rb = root(b, roots);\n    if(ra == rb) return false;\n    roots[ra] = rb;\n    return true;\n}\n\nbool solve() {\n    int C, W;\n    cin >> C >> W;\n    if(!C && !W) return false;\n\n    vector<P> poles;\n    vector<vector<int>> graph(C);\n    vector<vector<int>> wall_id(C, vector<int>(C));\n    TIMES(_, C) {\n        double x, y;\n        cin >> x >> y;\n        poles.push_back(P(x, y));\n    }\n    TIMES(i, W) {\n        int s, t;\n        cin >> s >> t;\n        --s; --t;\n        graph[s].push_back(t);\n        graph[t].push_back(s);\n        wall_id[s][t] = i*2;\n        wall_id[t][s] = i*2+1;\n    }\n\n    vector<int> roots(W*2);\n    TIMES(i, W*2) {\n        roots[i] = i;\n    }\n    TIMES(i, C) {\n        const P &pi = poles[i];\n        for(int j : graph[i]) {\n            const P &pj = poles[j];\n            const P vec = pj - pi;\n            const double len = abs(vec);\n            int candidate = -1;\n            int sin_sgn = -2;\n            double cos_val = 2;\n            for(int k : graph[j]) {\n                if(k == i) continue;\n                const P vec2 = poles[k] - pj;\n                const int sgn = cmp(cross(vec2, vec), 0);\n                const double cv = dot(vec2, vec) / len / abs(vec2);\n                if(sgn > sin_sgn\n                    || (sgn == sin_sgn && cv < cos_val))\n                {\n                    candidate = k;\n                    sin_sgn = sgn;\n                    cos_val = cv;\n                }\n            }\n            if(candidate != -1) {\n                if(unite(wall_id[i][j], wall_id[j][candidate], roots)) {\n                    //cout << \"unitea \" << i << \" \" << j << \" \" << candidate << endl;\n                }\n            }\n        }\n    }\n    // Determine outside region\n    const int rightmost = distance(poles.begin(),\n            max_element(poles.begin(), poles.end(), [](const P &a, const P &b) {\n                return a.real() < b.real();\n                }));\n    const int rm_next = *max_element(\n            graph[rightmost].begin(), \n            graph[rightmost].end(),\n            [&poles, rightmost](int a, int b) {\n            const double arga = arg(poles[a] - poles[rightmost]) + PI;\n            const double argb = arg(poles[b] - poles[rightmost]) + PI;\n            return arga < argb;\n            });\n    int out_id = root(wall_id[rm_next][rightmost], roots);\n\n    Spec init;\n    vector<Spec> areas(W*2);\n    TIMES(i, W*2) {\n        const int area = root(i, roots);\n        areas[area][i/2] = true;\n        if(area == out_id) init[i/2] = true;\n        //cout << area << ' ';\n    }\n    //cout << endl;\n    Spec cur = init;\n    int turn = 1;\n    while(true) {\n        Spec next = cur;\n        for(const Spec &spec : areas) {\n            if((spec & cur).any()) {\n                next |= spec;\n            }\n        }\n        if(next == cur) break;\n        cur = next;\n        ++turn;\n    }\n    cout << turn << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#include <climits>\n\nusing namespace std;\n\ntypedef long long lint;\n\n//定数\nconst double EPS = 1e-10;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\nconst int INF = 1001001001;\nconst lint INFLL = 1001001001001001001ll;\n\n//初期化関連\n#define zclear(a) memset((a), 0 ,sizeof(a))\n#define mclear(a) memset((a), -1, sizeof(a))\n\n//デバッグ出力\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nbool eq(double a, double b) //a == b\n{\n    return (fabs(a - b) <= EPS);\n}\n\nbool neq(double a, double b) //a == b\n{\n    return (!eq(a, b));\n}\n  \nbool lt(double a, double b) //a < b\n{\n    return (a - b < -EPS);\n}\n  \nbool leq(double a, double b) //a <= b\n{\n    return (lt(a, b) || eq(a, b));\n}\n  \nbool gt(double a, double b) //a > b\n{\n    return (a - b > +EPS);\n}\n  \nbool geq(double a, double b) //a >= b\n{\n    return (gt(a, b) || eq(a, b));\n}\n\nclass Point{\npublic:\n\tdouble x, y;\n\tint id;\n\tPoint(double x = 0, double y = 0): x(x), y(y){}\n\tPoint operator + (Point p){return Point(x + p.x, y + p.y);}\n\tPoint operator - (Point p){return Point(x - p.x, y - p.y);}\n\tPoint operator * (double a){return Point(x * a, y * a);}\n\tPoint operator / (double a){return Point(x / a, y / a);}\n\tPoint operator * (const Point &a){\n\t\treturn Point(x * a.x - y * a.y, x * a.y + y * a.x);\n\t}\n\tbool operator < (const Point &p) const {\n\t\treturn (x != p.x ? x < p.x : y < p.y);\n\t}\n\tbool operator == (const Point &p) const {\n\t\treturn (fabs(x - p.x) < EPS && fabs(y - p.y) < EPS);\n\t}\n};\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\ndouble norm(Vector a){return (a.x * a.x + a.y * a.y);}\ndouble abs(Vector a){return (sqrt(norm(a)));}\ndouble abs(Vector a, Vector b){return (sqrt(norm(a - b)));}\ndouble dot(Vector a, Vector b){return (a.x * b.x + a.y * b.y);}\ndouble cross(Vector a, Vector b){return (a.x * b.y - a.y * b.x);}\ndouble atan(Vector a){return atan2(a.y, a.x);}\nbool sortX(Point a, Point b){return (a.x != b.x ? lt(a.x, b.x) : lt(a.y, b.y));}\nbool sortY(Point a, Point b){return (a.y != b.y ? lt(a.y, b.y) : lt(a.x, b.x));}\nPoint p;\nbool sortT(Point a, Point b){return (gt(cross(a - p, b - p), 0));}\n\nint ccw(Point p0, Point p1, Point p2)\n{\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > EPS) return (+1); //p0, p1, p2 が反時計周り\n\tif (cross(a, b) < -EPS) return (-1);//p0, p1, p2 が時計回り\n\tif (dot(a, b) < -EPS) return (+2); //p2--p0--p1 の順で一直線上\n\tif (norm(a) < norm(b)) return (-2); //p0--p1--p2 の順で一直線上\n\treturn (0); //p0--p2--p1 の順で一直線上\n}\n\nPolygon normalize(Polygon &v)\n{\n    int pt = 0;\n    for (int i = 1; i < v.size(); i++){\n        if (v[pt].y > v[i].y || (v[pt].y == v[i].y && v[pt].x > v[i].x)){\n            pt = i;\n        }\n    }\n    swap(v[pt], v[0]);\n    p = v[0];\n    sort(v.begin() + 1, v.end(), sortT);\n    return (v);\n}\n\nPolygon conhel(Polygon& ps)\n{\n    sort(ps.begin(), ps.end());\n    int k = 0, n = (int)ps.size();\n    Polygon qs(n * 2);\n      \n    for (int i = 0; i < n; i++){\n      while (k > 1 && cross(qs[k - 1] - qs[k - 2], ps[i] - qs[k - 1]) < -EPS) k--;\n      qs[k++] = ps[i];\n    }\n  \n    for (int i = n - 2, t = k; i >= 0; i--){\n      while (k > t && cross(qs[k - 1] - qs[k - 2], ps[i] - qs[k - 1]) < -EPS) k--;\n      qs[k++] = ps[i];\n    }\n  \n    qs.resize(k - 1);\n    return (qs);\n}\n\ndouble getArea(Polygon t){\n    double ans = 0.0;\n\tt = normalize(t);\n    for (unsigned int i = 0; i < t.size(); i++)\n        ans += cross(t[i] , t[(i + 1) % t.size()]);\n    return (fabs(ans) / 2);\n}\n\nbool isIntersectLL(Point p1, Point p2, Point p3, Point p4)\n{// 同一直線の場合は交差していると判定する.\n\treturn (abs(cross(p2 - p1, p4 - p3)) > EPS || // 傾きが異なる\n\t\tabs(cross(p2 - p1, p4 - p3)) < EPS); // 同じ直線である\n}\nbool isIntersectLS(Point p1, Point p2, Point p3, Point p4)\n{// 同一直線上にある場合も交差と判定\n\treturn (cross(p2 - p1, p3 - p1) * cross(p2 - p1, p4 - p1) < EPS);\n}\nbool isIntersectLP(Point p1, Point p2, Point p)\n{\n\treturn (neq(abs(ccw(p1, p2, p)), 1));\n}\nbool isIntersectSS(Point p1, Point p2, Point p3, Point p4)\n{\n    return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n             ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool isIntersectSP(Point p1, Point p2, Point p)\n{\n\treturn (eq(ccw(p1, p2, p), 0));\n}\nbool isInsideCP(Point c, double r, Point p)\n{\n\treturn (leq(abs(c - p), r));\n}\nbool isInsideCC(Point c1, double r1, Point c2, double r2)\n{\n\treturn (leq(abs(c1 - c2), r1 + r2) && geq(abs(c1 - c2), abs(r1 - r2)));\n}\nbool isInsidePolyP(Polygon gon, Point p)\n{\n    for (int i = 0; i < gon.size(); i++){\n        if (ccw(gon[i], gon[(i + 1) % gon.size()], p) == -1) return (false);\n    }\n    return (true);\n}\n\nPoint projection(Point p1, Point p2, Point p3) //直線p1p2 上への写像\n{\n\tdouble t = dot(p3 - p1, p2 - p1) / norm(p2 - p1);\n\treturn (p1 + (p2 - p1) * t);\n}\nPoint reflection(Point p1, Point p2, Point p3) //直線p1p2 上への反射\n{\n\treturn (p3 + (projection(p1, p2, p3) - p) * 2);\n}\ndouble distanceLP(Point p1, Point p2, Point p)\n{\n\treturn (abs(p - projection(p1, p2, p)));\n}\ndouble distanceLL(Point l1, Point l2, Point m1, Point m2)\n{\n\treturn (isIntersectLL(l1, l2, m1, m2) ? 0 : distanceLP(l1, l2, m1));\n}\ndouble distanceLS(Point l1, Point l2, Point s1, Point s2)\n{\n    if (isIntersectLS(l1, l2, s1, s2)) return (0);\n\treturn (min(distanceLP(l1, l2, s1), distanceLP(l1, l2, s2)));\n}\ndouble distanceSP(Point s1, Point s2, Point p)\n{\n\tPoint r = projection(s1, s2, p);\n\tif (isIntersectSP(s1, s2, r)) return (abs(r - p));\n\treturn (min(abs(s1 - p), abs(s2 - p)));\n}\ndouble distanceSS(Point s1, Point s2, Point t1, Point t2){\n\tif (isIntersectSS(s1, s2, t1, t2)) return (0);\n\treturn (min(min(distanceSP(s1, s2, t1), distanceSP(s1, s2, t2)),\n\t\t\tmin(distanceSP(t1, t2, s1), distanceSP(t1, t2, s2))));\n}\nPoint interPointLL(Point a1, Point a2, Point b1, Point b2)\n{\n\tdouble d = cross(a2 - a1, b2 - b1);\n\tif (abs(d) < EPS) throw \"Segment is Paralell!\";\n\tPoint a = a2 - a1, b = b2 - b1;\n    double t = cross(b, b1 - a1) / cross(b, a);\n    return (a1 + a * t);\n}\nvector<Point> interPointCC(Point c1, double r1, Point c2, double r2)\n{\n\tvector<Point> res;\n\tif (abs(c1 - c2) < EPS) return (vector<Point>()); // 交点が絶対にない\n\tdouble d = abs(c1 - c2);\n\tdouble rc = (d * d + r1 * r1 - r2 * r2) / (2 * d);\n\tdouble rs = sqrt(r1 * r1 - rc * rc);\n\tPoint diff = (c2 - c1) / d;\n\tres.push_back(Point(c1 + diff * Point(rc, rs)));\n\tres.push_back(Point(c1 + diff * Point(rc, -rs)));\n\treturn (res);\n}\nvector<Point> crosspointCL(Point a, double ra, Point b1, Point b2)\n{\n\tvector<Point> res;\n\tdouble dist = distanceLP(b1, b2, a);\n\tif (leq(dist, ra)){\n\t\tPoint s = projection(b1, b2, a);\n\t\tdist = sqrt(ra * ra - dist * dist);\n\t\tPoint t = (b2 - b1) / abs(b2 - b1);\n\t\tres.push_back(s + t * dist);\n\t\tres.push_back(s - t * dist);\n\t}\n\treturn (res);\n}\n\nPoint unitVector(Vector t)\n{\n    double u = abs(t);\n    return (Point(t.x / u , t.y / u));\n}\n\nPoint normalVector(Point p, Point a, Point b)\n{\n    Point v = unitVector(b - a);\n    v = cross(v, p - a) > 0 ? Point(v.y, -v.x) : Point(-v.y, v.x);\n    return v * distanceLP(p, a, b);\n}\n  \ndouble getCos(Vector a, Vector b)\n{\n    return (dot(a, b) / (abs(a) * abs(b)));\n}\n  \ndouble getSin(Vector a, Vector b)\n{\n    double t = getCos(a, b);\n    return (sqrt(1.0 - t * t));\n}\n  \ndouble getArg(Vector v)\n{\n    return (atan2(v.y, v.x));\n}\n\nPoint rotate(Point t, Point p, double r)\n{\n    double ta = cos(r) * (t.x - p.x) - sin(r) * (t.y - p.y) + p.x;\n    double tb = sin(r) * (t.x - p.x) + cos(r) * (t.y - p.y) + p.y;\n    return (Point(ta, tb));\n}\n\nint main()\n{\n\tint N, M;\n\t\n\twhile (scanf(\"%d %d\", &N, &M) && N){\n\t\tvector<Point> P(N);\n\t\tvector<int> to[128];\n\t\tbool exist[128][128] = {0};\n\t\t\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tscanf(\"%lf %lf\", &P[i].x, &P[i].y);\n\t\t\tP[i].id = i;\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < M; i++){\n\t\t\tint x, y;\n\t\t\tscanf(\"%d %d\", &x, &y);\n\t\t\tto[--x].push_back(--y);\n\t\t\tto[y].push_back(x);\n\t\t\texist[x][y] = exist[y][x] = 1;\n\t\t}\n\t\t\n\t\tPolygon Q = P;\n\t\tQ = conhel(Q);\n\t\t\n\t\tvector<int> belong[128][128];\n\t\tfor (int i = 0; i < Q.size(); i++){\n\t\t\tint u = Q[i].id, v = Q[(i + 1) % Q.size()].id;\n\t\t\tbelong[u][v].push_back(0);\n\t\t\tbelong[v][u].push_back(0);\n\t\t}\n\t\tint k = 1;\n\t\tset<vector<int> > s;\n\t\t\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tfor (int j = 0; j < N; j++){\n\t\t\t\tif (P[j] < P[i] && exist[i][j] && belong[i][j].size() < 2){\n\t\t\t\t\tvector<int> v;\n\t\t\t\t\tv.push_back(i);\n\t\t\t\t\tv.push_back(j);\n\t\t\t\t\twhile (1){\n\t\t\t\t\t\tint nextP = -1;\n\t\t\t\t\t\tint vv = v[v.size() - 1], uu = v[v.size() - 2];\n\t\t\t\t\t\tfor (int l = 0; l < to[vv].size(); l++){\n\t\t\t\t\t\t\tif (to[vv][l] == vv || to[vv][l] == uu) continue;\n\t\t\t\t\t\t\tif (ccw(P[uu], P[vv], P[to[vv][l]]) < 0){\n\t\t\t\t\t\t\t\tif (nextP == -1 || getCos(P[uu] - P[vv], P[to[vv][l]] - P[vv]) > getCos(P[uu] - P[vv], P[nextP] - P[vv])) nextP = to[vv][l];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (nextP == i) break;\n\t\t\t\t\t\tv.push_back(nextP);\n\t\t\t\t\t}\n\t\t\t\t\tvector<int> ss = v;\n\t\t\t\t\tsort(ss.begin(), ss.end());\n\t\t\t\t\tif (s.find(ss) != s.end()) continue;\n\t\t\t\t\telse s.insert(ss);\n\t\t\t\t\tfor (int s = 0; s < v.size(); s++){\n\t\t\t\t\t\tint uu = v[s], vv = v[(s + 1) % v.size()];\n\t\t\t\t\t\tbelong[uu][vv].push_back(k);\n\t\t\t\t\t\tbelong[vv][uu].push_back(k);\n\t\t\t\t\t}\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int> G[128];\n\t\t\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tfor (int j = i + 1; j < N; j++){\n\t\t\t\tif (belong[i][j].size()){\n\t\t\t\t\tassert(belong[i][j].size() == 2);\n\t\t\t\t\tint u = belong[i][j][0], v = belong[i][j][1];\n\t\t\t\t\tG[u].push_back(v);\n\t\t\t\t\tG[v].push_back(u);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tint done[1024];\n\t\tfill(done, done + 1024, -1);\n\t\tqueue<pair<int, int> > q;\n\t\t\n\t\tfor(q.push(make_pair(0, 0)); q.size(); q.pop()){\n\t\t\tpair<int, int> x = q.front();\n\t\t\tif (~done[x.first]) continue;\n\t\t\tdone[x.first] = x.second;\n\t\t\tans = max(ans, x.second);\n\t\t\t\n\t\t\tfor (int i = 0; i < G[x.first].size(); i++){\n\t\t\t\tq.push(make_pair(G[x.first][i], x.second + 1));\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\nusing R=long double;\nusing edge=tuple<R,int>;\n\nint x[110],y[110];\n\nint main(void){\n\tint n,m;\n\twhile(cin >> n >> m,n){\n\t\trep(i,n) cin >> x[i] >> y[i];\n\n\t\tvector<edge> graph[110];\n\t\tvector<int> used[110];\n\n\t\trep(i,m){\n\t\t\tint s,t;\n\t\t\tcin >> s >> t;\n\t\t\ts--,t--;\n\t\t\tgraph[s].push_back(make_tuple(atan2(y[t]-y[s],x[t]-x[s]),t));\n\t\t\tused[s].push_back(-1);\n\t\t\tgraph[t].push_back(make_tuple(atan2(y[s]-y[t],x[s]-x[t]),s));\n\t\t\tused[t].push_back(-1);\n\t\t}\n\n\t\trep(v,n) sort(_all(graph[v]));\n\t\t\n\t\tint all=0;\n\t\trep(v,n){\n\t\t\trep(i,graph[v].size()){\n\t\t\t\tif(used[v][i]!=-1) continue;\n\t\t\t\t\n\t\t\t\tint cur=v,idx=i;\n\t\t\t\tdo{\n\t\t\t\t\tused[cur][idx]=all;\n\t\t\t\t\tint nxt=get<1>(graph[cur][idx]),nidx=0;\n\t\t\t\t\trep(j,graph[nxt].size()) if(get<1>(graph[nxt][j])==cur) nidx=(j+1)%int(graph[nxt].size());\n\t\t\t\t\tcur=nxt,idx=nidx;\n\t\t\t\t}while(cur!=v);\n\t\t\t\tall++;\n\t\t\t}\n\t\t}\n\t\n\t\tint dual[110][110];\n\t\trep(i,all)rep(j,all) dual[i][j]=(i==j)?0:(1<<20);\n\n\t\tint outer=used[min_element(x,x+n)-x][0];\n\t\t\n\t\trep(v,n){\n\t\t\trep(i,graph[v].size()){\n\t\t\t\tint v2=get<1>(graph[v][i]),j=0;\n\t\t\t\twhile(get<1>(graph[v2][j])!=v) j++;\n\n\t\t\t\tdual[used[v][i]][used[v2][j]]=1;\n\t\t\t\tdual[used[v2][j]][used[v][i]]=1;\n\t\t\t}\n\t\t}\n\n\t\trep(k,all)rep(i,all)rep(j,all) chmin(dual[i][j],dual[i][k]+dual[k][j]);\n\t\tint ans=1;\n\t\trep(v,all) chmax(ans,dual[outer][v]);\n\t\tcout << ans << endl;\n\t}\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\n#include <iomanip>\n#include <fstream>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define chmax(a,b) (a<b?(a=b,1):0)\n#define chmin(a,b) (a>b?(a=b,1):0)\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\nconst int INF = 1<<29;\nconst double EPS = 1e-8;\nconst double PI = acos(-1);\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\ntypedef complex<double> P;\nP pIN() { double x,y; cin >> x >> y; return P(x,y); }\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    // if (abs(a-b)<EPS) return 0;\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > EPS)   return +1;       // counter clockwise\n  if (cross(b, c) < -EPS)   return -1;       // clockwise\n  if (dot(b, c) < -EPS)     return +2;       // c--a--b on line\n  if (EPS < norm(b) && norm(b) < norm(c)-EPS) return -2; // a--b--c on line\n  return 0;\n}\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n  L() { resize(2); }\n};\nostream &operator<<(ostream &os, const L &a) {\n  os << a[0] << \" -> \" << a[1];\n  return os;\n}\ntypedef vector<P> G;\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\n\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\n// テ」ツδ凖」ツつッテ」ツδ暗」ツδォテッツスツ?」ツ?凝」ツつ嘉」ツ?ソテ」ツ?淌」ツδ凖」ツつッテ」ツδ暗」ツδォテッツスツづ」ツ?ョティツァツ津・ツコツヲテ」ツ?ョ[0,2pi)\ndouble angle(const P &a, const P &b) {\n  double ret = arg(b)-arg(a);\n  return (ret>=0) ? ret : ret + 2*PI;\n}\n// テ」ツδ凖」ツつッテ」ツδ暗」ツδォaテ」ツ?ィテ」ツδ凖」ツつッテ」ツδ暗」ツδォbテ」ツ?ョテゥツ鳴禿」ツ?ョティツァツ津・ツコツヲ\ndouble angle2(const P &a, const P &b) {\n  return min(angle(a,b), angle(b,a));\n}\ndouble area2(const G& g) {\n  double A = 0;\n  for (int i = 0; i < g.size(); ++i) {\n    A += cross(g[i], g[(i+1)%g.size()]);\n  }\n  return A;\n}\ndouble area(const G&g) {\n  return abs(area2(g)/2);\n}\n\nG getHolesSub(const Graph &g, const vector<P> &ps, int a, int b, map<pii,bool> &visited) {\n  G res;\n  int pre = a;\n  int cur = b;\n  res.push_back(ps[a]);\n  while(cur != a) {\n    visited[pii(pre,cur)] = 1;\n    res.push_back(ps[cur]);\n    P vec = ps[pre]-ps[cur];\n    double minang = -1;\n    int dst = -1;\n    FOR(it, g[cur]) {\n      double tang = angle(vec, ps[it->dst]-ps[cur]);\n      if (chmax(minang, tang)) {\n        dst = it->dst;\n      }\n    }\n    if (dst == -1) return G();\n    pre = cur;\n    cur = dst;\n  }\n  visited[pii(pre,cur)] = 1;\n  if (area2(res) > EPS) return res;\n  return G();\n}\n\nvector<G> getHoles(const Graph &g, const vector<P> &ps) {\n  map<pii, bool> visited;\n  vector<G> ret;\n  REP(i,g.size()) {\n    FOR(it, g[i]) {\n      if (visited.count(pii(it->src,it->dst))) continue;\n      G t = getHolesSub(g, ps, it->src, it->dst, visited);\n      if (t.size()) ret.push_back(t);\n    }\n  }\n  return ret;\n}\n\nL line(const G &g, int i) {\n  return L(g[i],g[(i+1)%g.size()]);\n}\n\nbool eq(const P &a, const P &b) {\n  return abs(a-b) < EPS;\n}\n\nvector<Weight> dijkstra2(const Graph &g, int s) {\n  vector<Weight> dist(g.size(), INF);\n  dist[s] = 0;\n  priority_queue<Edge> Q; // \"e < f\" <=> \"e.weight > f.weight\"\n  for (Q.push(Edge(-2, s, 0)); !Q.empty(); ) {\n    Edge e = Q.top(); Q.pop();\n    if (dist[e.dst] < e.weight) continue;\n    FOR(f,g[e.dst]) {\n      if (dist[f->dst] > e.weight+f->weight) {\n        dist[f->dst] = e.weight+f->weight;\n        Q.push(Edge(f->src, f->dst, e.weight+f->weight));\n      }\n    }\n  }\n  return dist;\n}\n\nint main() {\n  int n,m;\n  while(cin >> n >> m, n || m) {\n    vector<P> ps(n);\n    REP(i,n) ps[i] = pIN();\n    Graph g(n);\n    REP(i,m) {\n      int a, b;\n      cin >> a >> b;\n      a--;b--;\n      g[a].push_back(Edge(a,b,1));\n      g[b].push_back(Edge(b,a,1));\n    }\n    vector<G> gs = getHoles(g,ps);\n    int N = gs.size();\n    Graph g2(N+1);\n    REP(i,N) {\n      REP(j,gs[i].size()) {\n        L l = line(gs[i],j);\n        bool f = 0;\n        REP(i2,N) {\n          if (i2 == i) continue;\n          REP(j2,gs[i2].size()) {\n            L l2 = line(gs[i2], j2);\n            if (eq(l[0],l2[0]) && eq(l[1],l2[1]) ||\n                eq(l[0],l2[1]) && eq(l[1],l2[0])) {\n              f = 1;\n              g2[i].push_back(Edge(i,i2,1));\n            }\n          }\n        }\n        if (!f) {\n          g2[i].push_back(Edge(i,N,1));\n          g2[N].push_back(Edge(N,i,1));\n        }\n      }\n    }\n    // REP(i,N+1) {\n    //   cout << i << \" : \";\n    //   FOR(it, g2[i]) {\n    //     cout << it->dst << \" \";\n    //   }\n    //   cout << endl;\n    // }\n    vector<int> weight = dijkstra2(g2,N);\n    cout << *max_element(ALL(weight)) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\nusing real = double;\nstatic constexpr real EPS = 1e-10;\nstruct Point {\n    real x, y;\n    Point& operator+=(const Point a) { x += a.x; y += a.y;  return *this; }\n    Point& operator-=(const Point a) { x -= a.x; y -= a.y;  return *this; }\n    Point& operator*=(const real k) { x *= k; y *= k;  return *this; }\n    Point& operator/=(const real k) { x /= k; y /= k;  return *this; }\n    Point operator+(const Point a) const {return Point(*this) += a; }\n    Point operator-(const Point a) const {return Point(*this) -= a; }\n    Point operator*(const real k) const {return Point(*this) *= k; }\n    Point operator/(const real k) const {return Point(*this) /= k; }\n    bool operator<(const Point &a) const { return (x != a.x ? x < a.x : y < a.y); }\n    explicit Point(real a = 0, real b = 0) : x(a), y(b) {};\n};\n\nbool sorty(Point a, Point b){\n    return (a.y != b.y ? a.y < b.y : a.x < b.x);\n}\n\nistream& operator>> (istream& s, Point& P){\n    s >> P.x >> P.y;\n    return s;\n}\n\ninline real dot(Point a, Point b){ return a.x*b.x + a.y*b.y; }\ninline real cross(Point a, Point b){ return a.x*b.y - a.y*b.x; }\ninline real abs(Point a){ return sqrt(dot(a, a)); }\n\n\nreal angle(Point A, Point B){\n    return acos(dot(A, B)/abs(A)/abs(B));\n}\n\n\n\nstatic constexpr int COUNTER_CLOCKWISE = 1;\nstatic constexpr int CLOCKWISE = -1;\nstatic constexpr int ONLINE_BACK = 2;\nstatic constexpr int ONLINE_FRONT = -2;\nstatic constexpr int ON_SEGMENT = 0;\n\nint ccw(Point a, Point b, Point c){\n    b -= a; c -= a;\n    if(cross(b, c) > EPS) return COUNTER_CLOCKWISE;\n    if(cross(b, c) < -EPS) return CLOCKWISE;\n    if(dot(b, c) < 0) return ONLINE_BACK;\n    if(abs(b) < abs(c)) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\nstruct Segment {\n    Point a, b;\n    Segment(Point x, Point y) : a(x), b(y) {};\n};\n\nstruct Line {\n    Point a, b;\n    Line(Point x, Point y) : a(x), b(y) {};\n};\n\nstruct Circle{\n    Point c; real r;\n    Circle(Point c, real r): c(c), r(r) {};\n};\n\nusing Polygon = vector<Point>;\n\nbool intersect(Segment s, Segment t){\n    return (ccw(s.a, s.b, t.a)*ccw(s.a, s.b, t.b) <= 0 &&\n            ccw(t.a, t.b, s.a)*ccw(t.a, t.b, s.b) <= 0);\n}\n\nbool intersect(Segment s, Line t){\n    int a = ccw(t.a, t.b, s.a), b = ccw(t.a, t.b, s.b);\n    return (!(a&1) || !(b&1) || a != b);\n}\n\nPoint polar(double r, double t){\n    return Point(r*cos(t), r*sin(t));\n}\n\ndouble arg(Point p){\n    return atan2(p.y, p.x);\n}\n\nreal area(Polygon v){\n    if(v.size() < 3) return 0.0;\n    real ans = 0.0;\n    for (int i = 0; i < v.size(); ++i) {\n        ans += cross(v[i], v[(i+1)%v.size()]);\n    }\n    return ans/2;\n}\n\nclass DualGraph {\n    struct P {\n        int to, nxt, id, id2, rev;\n        P(int to = 0, int nxt = 0, int id = 0, int rev = 0) : to(to), nxt(nxt), id(id), rev(rev), id2(0) {};\n        bool operator!=(P x){ return to != x.to || nxt != x.nxt || id != x.id || rev != x.rev; }\n    };\npublic:\n    int n, m;\n    Polygon v;\n    vector<vector<P>> G_;\n    vector<vector<int>> G;\n    vector<vector<Point>> A;\n    DualGraph(Polygon v) : v(v), n(v.size()), G_(n), m(0) {}\n\n    void add_point(Point P){ v.emplace_back(P); n++; G_.emplace_back(); }\n    void add_edge(int a, int b){\n        G_[a].emplace_back(b, 0, m, 0);\n        G_[b].emplace_back(a, 0, m++, 0);\n    }\n\n    void build(){\n        vector<int> l(m), r(m);\n        for (int i = 0; i < n; ++i) {\n            sort(G_[i].begin(), G_[i].end(), [&](P &a, P &b){ return arg(v[a.to]-v[i]) < arg(v[b.to]-v[i]); });\n            for (int j = 0; j < G_[i].size(); ++j) {\n                G_[i][j].nxt = (j + 1) % G_[i].size();\n                if(i < G_[i][j].to) l[G_[i][j].id] = j;\n                else r[G_[i][j].id] = j;\n            }\n        }\n        for (int i = 0; i < n; ++i) {\n            for (auto &&e : G_[i]) {\n                e.rev = (i < e.to ? r[e.id] : l[e.id]);\n            }\n        }\n        int cur = 1;\n        A = move(vector<vector<Point>>());\n        for (int i = 0; i < n; ++i) {\n            for (auto &&x : G_[i]) {\n                if(x.id2) continue;\n                x.id2 = cur;\n                A.emplace_back();\n                A.back().emplace_back(v[i]);\n                auto e = &x;\n                while(e->to != i){\n                    A.back().emplace_back(v[e->to]);\n                    e = &G_[e->to][G_[e->to][e->rev].nxt];\n                    e->id2 = cur;\n                }\n                cur++;\n            }\n        }\n        for (int i = 0; i < n; ++i) {\n            for (auto &&e : G_[i]) {\n                (i < e.to ? l[e.id] : r[e.id]) = e.id2-1;\n            }\n        }\n        G = move(vector<vector<int>>(A.size()));\n        for (int i = 0; i < m; ++i) {\n            G[l[i]].emplace_back(r[i]);\n            G[r[i]].emplace_back(l[i]);\n        }\n    }\n};\n\n\nvoid solve(int n, int m){\n    Polygon v(n);\n    for (auto &&i : v) cin >> i;\n    DualGraph G(v);\n    for (int i = 0; i < m; ++i) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        a--; b--;\n        G.add_edge(a, b);\n    }\n    G.build();\n    int out = 0;\n    for (int i = 0; i < G.A.size(); ++i) {\n        if(area(G.A[i]) > 0) out = i;\n    }\n    vector<int> dist(G.A.size(), INF<int>);\n    queue<int> Q;\n    dist[out] = 0; Q.emplace(out);\n    while(!Q.empty()){\n        int i = Q.front(); Q.pop();\n        for (auto &&j : G.G[i]) {\n            if(dist[j] == INF<int>){\n                dist[j] = dist[i]+1;\n                Q.emplace(j);\n            }\n        }\n    }\n    cout << *max_element(dist.begin(),dist.end()) << \"\\n\";\n}\n\nint main() {\n    int n, m;\n    while(cin >> n >> m, n){\n        solve(n, m);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cassert>\nusing namespace std;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n\treturn abs(a.real()-b.real()) > EPS ? real(a) < real(b) : imag(a) + EPS < imag(b);\n    //return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\nP readPoint(){\n\tdouble x,y;\n\tcin >> x >> y;\n\treturn P(x,y);\n}\n\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\ntypedef vector<P> G;\n\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\n\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\nP reflection(const L &l, const P &p) {\n  return p + 2. * (projection(l, p) - p);\n}\ndouble distanceLP(const L &l, const P &p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\n#define rep(i,N) for(int i = 0 ; i < N ; i++)\nP ps[110];\nvector<int> g[110];\n\nvector<int> normalize(vector<int> v){\n\tauto it = min_element(v.begin(),v.end());\n\trotate(v.begin(),it,v.end());\n\treturn v;\n}\n\nint done[110];\nvoid f(int a,int b,int s,vector<int> &v){\n\tv.push_back(b);\n\tif( b == s ) return;\n\tif( done[b]++ ) throw 0;\n\tsort(g[b].begin(),g[b].end(),[&](int x,int y){\n\t\tP A = ps[x] - ps[b];\n\t\tP B = ps[y] - ps[b];\n\t\treturn cross(A,B) > 0;\n\t});\n\t//cout << find(g[b].begin(),g[b].end(),a) -g[b].begin();\n\t//cout << \"[\" << a << \",\" << s << \"] \";\n\t//for(int i = 0 ; i < g[b].size() ; i++)\n\t//\tcout << g[b][i] << \" \";\n\t//cout << endl;\n\trotate(g[b].begin(),find(g[b].begin(),g[b].end(),a),g[b].end());\n\tf(b,g[b][1],s,v);\n}\n\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n\ndouble area2(const G& P) {\n  double A = 0;\n  for (int i = 0; i < P.size(); ++i) \n    A += cross(curr(P, i), next(P, i));\n  return A;\n}\n\nint main(){\n\tassert( (normalize({4,2,1,3}) == vector<int>{1,3,4,2}) );\n\t\n\tint C,W;\n\twhile( cin >> C >> W && (C||W) ){\n\t\trep(i,C) ps[i] = readPoint();\n\t\trep(i,C) g[i].clear();\n\t\trep(i,W){\n\t\t\tint a,b;\n\t\t\tcin >> a >> b;\n\t\t\t--a,--b;\n\t\t\tg[a].push_back(b);\n\t\t\tg[b].push_back(a);\n\t\t}\n\t\tvector< vector<int> > poly;\n\t\trep(i,C){\n\t\t\trep(j,g[i].size()){\n\t\t\t\ttry{\n\t\t\t\t\tmemset(done,0,sizeof(done));\n\t\t\t\t\tvector<int> v;\n\t\t\t\t\tf(i,g[i][j],i,v);\n\t\t\t\t\tvector<P> g;\n\t\t\t\t\trep(k,v.size())g.push_back(ps[v[k]]);\n\t\t\t\t\tif( area2(g) > 0 ) throw 0;\n\t\t\t\t\tpoly.push_back(normalize(v));\n\t\t\t\t}catch(int x){\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(poly.begin(),poly.end());\n\t\tpoly.erase(unique(poly.begin(),poly.end()),poly.end());\n\t\t\n\t\tmap< pair<int,int>, vector<int> > edgs;\n\t\tfor(int i = 0 ; i < poly.size() ; i++){\n\t\t\tfor(int j = 0 ; j < poly[i].size() ; j++){\n\t\t\t\tint A = curr(poly[i],j);\n\t\t\t\tint B = next(poly[i],j);\n\t\t\t\tif( A > B ) swap(A,B);\n\t\t\t\tedgs[{A,B}].push_back(i);\n\t\t\t}\n\t\t}\n\t\tint M = poly.size() + 1;\n\t\tint wf[M][M];\n\t\trep(i,M) rep(j,M){\n\t\t\twf[i][j] = i==j?0:1e9;\n\t\t}\n\t\t\n\t\tfor( auto x : edgs ){\n\t\t\tvector<int> v = x.second;\n\t\t\tif( v.size() < 2 ) v.push_back(M-1);\n\t\t\twf[v[0]][v[1]] = wf[v[1]][v[0]] = 1;\n\t\t}\n\t\trep(i,M)rep(j,M)rep(k,M) wf[j][k] = min(wf[j][i]+wf[i][k],wf[j][k]);\n\t\tint ans = 0;\n\t\trep(i,M){\n\t\t\tans = max(ans,wf[i][M-1]);\n\t\t}\n\t\tcout << ans << endl;\n\t\t\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<complex>\n#include<deque>\n#include<vector>\nusing namespace std;\ndouble eps=1e-6;\ndouble x[110];\ndouble y[110];\ndouble px[700];\ndouble py[700];\nint ijk[700];\nint v[700];\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ndouble PI=3.14159265358;\nstruct P{\n\tdouble x;double y;\n\tP(){}\n\tP(double X,double Y){\n\t\tx=X;y=Y;\n\t}\n\tP operator+ (const P &a)const{\n\t\treturn P(x+a.x,y+a.y);\n\t}\n\tP operator- (const P &a)const{\n\t\treturn P(x-a.x,y-a.y);\n\t}\n\tP operator* (const double &a)const{\n\t\treturn P(x*a,y*a);\n\t}\n\t/*operator+ (P a){\n\t\treturn P(x+a.x,y+a.y);\n\t}\n\toperator+ (P a){\n\t\treturn P(x+a.x,y+a.y);\n\t}*/\n\t\n};\ninline bool operator < (const P& a, const P& b) {\n    return a.x<b.x||(a.x==b.x&&a.y<b.y);\n}\ninline double cross(const P& a, const P& b) {\n\treturn a.x*b.y-a.y*b.x;\n}\ninline double dot(const P& a, const P& b) {\n\treturn a.x*b.x+a.y*b.y;\n}\n\nint ccw(P a, P b, P c) {\n\tb=b-a;c=c-a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (b.x*b.x+b.y*b.y<c.x*c.x+c.y*c.y) return -2;       // a--b--c on line\n  return 0;\n}\n#define se second\n#define fi first\n\nbool intersectSS(const pair<P,P> &s, const pair<P,P> &t) {\n  return ccw(s.fi,s.se,t.fi)*ccw(s.fi,s.se,t.se) <= 0 &&\n         ccw(t.fi,t.se,s.fi)*ccw(t.fi,t.se,s.se) <= 0;\n}\n\nP pt[700];\nP ps[300];\nint s[400];\nint t[400];\ndouble left[400];\ndouble right[400];\nvector<pair<int,int> >g[700];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<700;i++)g[i].clear();\n\t\tfor(int i=0;i<a;i++)scanf(\"%lf%lf\",x+i,y+i);\n\t\tfor(int i=0;i<a;i++){\n\t\t\tdouble X=cos(1)*x[i]-sin(1)*y[i];\n\t\t\tdouble Y=sin(1)*x[i]+cos(1)*y[i];\n\t\t\tx[i]=X;\n\t\t\ty[i]=Y;\n\t\t\tps[i]=P(x[i],y[i]);\n\t\t}\n\t\tfor(int i=0;i<b;i++){\n\t\t\tint p,q;scanf(\"%d%d\",&p,&q);\n\t\t\tp--;q--;\n\t\t\ts[i]=p;t[i]=q;\n\t\t\tpx[i*2]=(x[p]+x[q])/2+eps;\n\t\t\tpy[i*2]=(y[p]+y[q])/2;\n\t\t\tpx[i*2+1]=(x[p]+x[q])/2-eps;\n\t\t\tpy[i*2+1]=(y[p]+y[q])/2;\n\t\t\tpt[i*2]=P(px[i*2],py[i*2]);\n\t\t\tpt[i*2+1]=P(px[i*2+1],py[i*2+1]);\n\t\t}\n\t\tdeque<pair<int,int> >Q;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tvector<pair<double,pair<int,int> > >vec;\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tif(s[j]==i){\n\t\t\t\t\tvec.push_back(make_pair(atan2(y[t[j]]-y[i],x[t[j]]-x[i]),make_pair(j,t[j])));\n\t\t\t\t}\n\t\t\t\tif(t[j]==i){\n\t\t\t\t\tvec.push_back(make_pair(atan2(y[s[j]]-y[i],x[s[j]]-x[i]),make_pair(j,s[j])));\n\t\t\t\t}\n\t\t\t}\n\t\t\tstd::sort(vec.begin(),vec.end());\n\t\t\tint sz=vec.size();\n\t\t\tfor(int j=0;j<vec.size();j++){\n\t\t\t\tdouble th=vec[j].first;\n\t\t\t\tdouble th2=vec[(j+1)%sz].first;\n\t\t\t\tif(th>th2)th2+=2*PI;\n\t\t\t\tif(th2-th<=PI+EPS)continue;\n\t\t\t\tfor(int k=0;k<2;k++)for(int l=0;l<2;l++){\n\t\t\t\t\tif(intersectSS(make_pair(pt[vec[j].second.first*2+k],pt[vec[(j+1)%sz].second.first*2+l]),\n\t\t\t\t\tmake_pair(ps[i],ps[vec[j].second.second]))&&intersectSS(make_pair(pt[vec[j].second.first*2+k],pt[vec[(j+1)%sz].second.first*2+l]),\n\t\t\t\t\tmake_pair(ps[i],ps[vec[(j+1)%sz].second.second]))){\n\t\t\t\t\t\tg[vec[j].second.first*2+k].push_back(make_pair(vec[(j+1)%sz].second.first*2+l,0));\n\t\t\t\t\t\tg[vec[(j+1)%sz].second.first*2+l].push_back(make_pair(vec[j].second.first*2+k,0));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<b*2;i++){\n\t\t\tijk[i]=999999999;\n\t\t\tv[i]=0;\n\t\t\tbool OK=true;\n\t\t\tint tt=s[i/2];\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tif(tt==s[j]||tt==t[j])continue;\n\t\t\t\tif(intersectSS(make_pair(ps[tt],ps[tt]+(pt[i]-ps[tt])*10000.0),make_pair(ps[s[j]],ps[t[j]]))){\n\t\t\t\t\tOK=false;break;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttt=t[i/2];\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tif(tt==s[j]||tt==t[j])continue;\n\t\t\t\tif(intersectSS(make_pair(ps[tt],ps[tt]+(pt[i]-ps[tt])*10000.0),make_pair(ps[s[j]],ps[t[j]]))){\n\t\t\t\t\tOK=false;break;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(OK){\n\t\t\t\tijk[i]=0;\n\t\t\t\tQ.push_back(make_pair(0,i));\n\t\t\t}\n\t\t\tfor(int j=i+1;j<b*2;j++){\n\t\t\t\tint cnt=0;\n\t\t\t\tfor(int k=0;k<b;k++){\n\t\t\t\t\tif(intersectSS(make_pair(ps[s[k]],ps[t[k]]),make_pair(pt[i],pt[j]))){\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tif(cnt>1)break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(cnt<2){\n\t\t\t\t\tg[i].push_back(make_pair(j,cnt));\n\t\t\t\t\tg[j].push_back(make_pair(i,cnt));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(Q.size()){\n\t\t\tint cost=-Q.front().first;\n\t\t\tint at=Q.front().second;Q.pop_front();\n\t\t\tif(v[at])continue;\n\t\t\tv[at]=1;\n\t\t\tfor(int i=0;i<g[at].size();i++){\n\t\t\t\tif(!v[g[at][i].first]&&ijk[g[at][i].first]>cost+g[at][i].second){\n\t\t\t\t\tijk[g[at][i].first]=cost+g[at][i].second;\n\t\t\t\t\tif(g[at][i].second==1)Q.push_back(make_pair(-ijk[g[at][i].first],g[at][i].first));\n\t\t\t\t\telse Q.push_front(make_pair(-ijk[g[at][i].first],g[at][i].first));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret=0;\n\t\tfor(int i=0;i<b*2;i++)ret=max(ret,ijk[i]);\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<vector>\n#include<queue>\n#include<tuple>\n#include<functional>\n#include<cfloat>\n#include<algorithm>\n\nconst int NIL = -1;\nconst double INF = DBL_MAX / 3.0;\n\n// Edge\nclass Edge {\npublic:\n    Edge(const int f, const int t, const double w) :from_(f), to_(t), weight_(w), color_(NIL) {}\n    int from() const {return from_;}\n    int to() const {return to_;}\n    double weight() const {return weight_;}\n    int color() const {return color_;}\n    int color(const int c) {return color_ = c;}\n    bool operator<(const Edge& e) const {\n        if(from() != e.from()) return from() < e.from();\n        if(to() != e.to()) return to() < e.to();\n        return weight() < e.weight();\n    }\nprivate:\n    int from_, to_;\n    double weight_;\n    int color_;\n};\n\n// Graph\nclass Graph {\npublic:\n    explicit Graph(int s) :size_(s) {edge_.resize(s);}\n\n    int size() const;\n    const std::vector<Edge>& edge(const int v) const;\n\n    void add(const Edge& e);\n    void add(const int from, const int to, const double weight);\n\n    const std::vector<double> Dijkstra_all(const int start) const;\n\nprivate:\n    int size_;\n    std::vector<std::vector<Edge>> edge_;\n};\n\n// implements\nint Graph::size() const {return size_;}\nconst std::vector<Edge>& Graph::edge(const int v) const {return edge_[v];}\nvoid Graph::add(const Edge& e) {edge_[e.from()].push_back(e);}\nvoid Graph::add(const int from, const int to, const double weight) {edge_[from].push_back(Edge(from, to, weight));}\nconst std::vector<double> Graph::Dijkstra_all(const int start) const {\n    enum {COST, VERTEX};\n    typedef std::tuple<double, int> Node;\n    std::vector<double> result(size(), INF);\n    std::priority_queue<Node, std::vector<Node>, std::greater<Node>> q;\n    q.push(Node(0, start));\n    while(!q.empty()) {\n        double cost = std::get<COST>(q.top());\n        int from = std::get<VERTEX>(q.top());\n        q.pop();\n        if(result[from] <= cost) continue;\n        result[from] = cost;\n        for(const auto& e: edge(from)) q.push(Node(cost + e.weight(), e.to()));\n    }\n    return result;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#include<iostream>\n#include<set>\nusing namespace std;\n\nstruct Point {\n    double x, y;\n    Point() {}\n    Point(const double x, const double y) :x(x), y(y) {}\n};\nbool operator<(const Point& lhs, const Point& rhs) {return lhs.x != rhs.x ? lhs.x < rhs.x : lhs.y < rhs.y;}\nconst Point operator-(const Point& lhs, const Point& rhs) {return Point(lhs.x - rhs.x, lhs.y - rhs.y);}\ndouble cross(const Point& lhs, const Point& rhs) {return lhs.x * rhs.y - lhs.y * rhs.x;}\nenum {CCW = -1, ONLINE, CW};\nint ccw(const Point& a, const Point& b, const Point& c) {\n    if(cross(b - a, c - a) > 0.0) return CCW;\n    if(cross(b - a, c - a) < 0.0) return CCW;\n    return ONLINE;\n}\n\nint color_size;\n\nvoid dfs(vector<vector<Edge>>& edge, const int previous, const int current) {\n    for(int step = 0; step < 2 * edge[current].size(); ++step) {\n        int i = step % edge[current].size();\n        if(edge[current][i].to() != previous) continue;\n\n        i = (i + 1) % edge[current].size();\n        if(edge[current][i].color() != NIL) return;\n        edge[current][i].color(color_size);\n        dfs(edge, edge[current][i].from(), edge[current][i].to());\n        break;\n    }\n}\n\nint main() {\n    int C, W;\n    while(cin >> C >> W, C | W) {\n        vector<Point> pillar(C);\n        for(auto& p: pillar) cin >> p.x >> p.y;\n        vector<vector<Edge>> edge(C);\n        for(int i = 0; i < W; ++i) {\n            int s, t;\n            cin >> s >> t;\n            --s; --t;\n            edge[s].push_back(Edge(s, t, atan2(pillar[t].y - pillar[s].y, pillar[t].x - pillar[s].x)));\n            edge[t].push_back(Edge(t, s, atan2(pillar[s].y - pillar[t].y, pillar[s].x - pillar[t].x)));\n        }\n\n        // bubble sort\n        for(auto& e: edge) for(int i = 0; i < e.size(); ++i) for(int j = e.size() - 1; j > i; --j)\n            if(e[i].weight() > e[j].weight()) swap(e[i], e[j]);\n\n        // coloring\n        color_size = 0;\n        for(int v = 0; v < C; ++v) for(auto& e: edge[v]) {\n            if(e.color() == NIL) {\n                e.color(color_size);\n                dfs(edge, e.from(), e.to());\n                ++color_size;\n            }\n        }\n\n        // construct the dual graph\n        vector<set<int>> new_edge(color_size);\n        for(int v = 0; v < C; ++v) for(const auto& e: edge[v]) {\n            for(const auto& reverse: edge[e.to()]) {\n                if(reverse.to() != e.from()) continue;\n                new_edge[e.color()].insert(reverse.color());\n                break;\n            }\n        }\n        Graph g(color_size);\n        for(int from = 0; from < new_edge.size(); ++from) for(int to: new_edge[from])\n            g.add(from, to, 1);\n\n        // solve\n        int leftmost = 0;\n        for(int i = 1; i < C; ++i) if(pillar[i] < pillar[leftmost]) leftmost = i;\n        int outside = edge[leftmost].front().color();\n        auto list = g.Dijkstra_all(outside);\n        cout << *max_element(list.begin(), list.end()) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<ll(n);++i)\n#define RREP(i,n) for(ll i=ll(n)-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<ll(n);++i)\n#define RFOR(i,m,n) for(ll i=ll(n)-1;i>=ll(m);--i)\n#define ALL(v) (v).begin(),(v).end()\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[aa]; if (aa != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(´・ω・`)(´・ω・`)(´・ω・`)(´・ω・`)(´・ω・`)(´・ω・`)///\n\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n};\n\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;\n\tif (cross(b, c) < -eps) return -1;\n\tif (dot(b, c) < 0) return 2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\nbool isis_ll(Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls(Line l, Line s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_ss(Line s, Line t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool isis_lp(Line l, Point p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\nvector<Point> is_cc(Circle c1, Circle c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res;\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\nvector<Point> is_lc(Circle c, Line l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d);\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nvector<Point> is_sc(Circle c, Line l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<Line> tangent_cp(Circle c, Point p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\ntypedef vector<Point> Polygon;\n\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\nint is_in_polygon(const Polygon &poly, Point p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nPolygon convex_cut(const Polygon &ps, Line l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))\n\t\t\tQ.push_back(is_ll(l, m));\n\t}\n\treturn Q;\n}\n\nvoid add_point(vector<Point> &ps, Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, int from, int to, Weight weight) {\n\tg[from].push_back(Edge { from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, abs(p[from] - p[to]));\n\t\t}\n\t}\n\treturn g;\n}\n\nGraph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n\tint n = p.size(), m = c.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tld angle = vec[j + 1].first - vec[j].first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t\tif (vec.size() >= 2) {\n\t\t\tint from = vec.back().second, to = vec.front().first;\n\t\t\tld angle = vec.front().first - vec.back().first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t}\n\treturn g;\n}\n\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\nGraph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n\tint N = p.size();\n\tpolygon.clear();\n\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n\tvector<vector<tuple<ld, int, bool>>> tup(N);\n\tREP(i, s.size()) {\n\t\tint a = -1, b = -1;\n\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n\t\tassert(a >= 0 && b >= 0);\n\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n\t}\n\tREP(i, N) sort(ALL(tup[i]));\n\tREP(i, N) {\n\t\tREP(j, tup[i].size()) {\n\t\t\tld angle; int pos = j, from = i, to; bool flag;\n\t\t\ttie(angle, to, flag) = tup[i][j];\n\t\t\tif (flag) continue;\n\t\t\tvector<int> ps;\n\t\t\twhile (!flag) {\n\t\t\t\tps.push_back(from);\n\t\t\t\tget<2>(tup[from][pos]) = true;\n\t\t\t\tseg2p[from][to].push_back(polygon.size());\n\t\t\t\tseg2p[to][from].push_back(polygon.size());\n\t\t\t\tangle += pi + eps;\n\t\t\t\tif (angle > pi) angle -= 2 * pi;\n\t\t\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n\t\t\t\tif (it == tup[to].end()) it = tup[to].begin();\n\t\t\t\tfrom = to; tie(angle, to, flag) = *it;\n\t\t\t\tpos = it - tup[from].begin();\n\t\t\t}\n\t\t\tpolygon.push_back(ps);\n\t\t}\n\t}\n\tGraph g(polygon.size());\n\tREP(i, N) REP(j, i) {\n\t\tif (seg2p[i][j].size() == 2) {\n\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n\t\t\tg[from].push_back(Edge{ from, to });\n\t\t\tg[to].push_back(Edge{ to, from });\n\t\t}\n\t}\n\treturn g;\n}\n\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(int r, int g, int b) {\n\tfprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(Point p) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(Line l) {\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(Line l) {\n\tPoint v = l.b - l.a;\n\tLine m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n\tint n = p.size();\n\tREP(i, n) draw_segment(Line(p[i], p[(i + 1) % n]));\n}\n\nvoid draw_circle(Circle c) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint c, w;\n\twhile (cin >> c >> w, c) {\n\t\tvector<Point> p(c);\n\t\tREP(i, c) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tp[i]=Point( x,y );\n\t\t}\n\t\tvector<Line> l(w);\n\t\tREP(i, w) {\n\t\t\tint s, t;\n\t\t\tcin >> s >> t;\n\t\t\ts--; t--;\n\t\t\tl[i] =Line( p[s],p[t] );\n\t\t}\n\t\tGraph g = dual_graph(l, p);\n\t\tint n = g.size();\n\t\tvvi d(n, vi(n, INF));\n\t\tREP(i, n) {\n\t\t\tREP(j, g[i].size()) {\n\t\t\t\tint from = g[i][j].from, to = g[i][j].to;\n\t\t\t\td[from][to] = 1;\n\t\t\t\td[to][from] = 1;\n\t\t\t}\n\t\t}\n\t\tREP(i, n)d[i][i] = 0;\n\t\tREP(k, n) {\n\t\t\tREP(i, n) {\n\t\t\t\tREP(j, n) {\n\t\t\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = -INF;\n\t\tREP(i, n) {\n\t\t\tREP(j, n) {\n\t\t\t\tans = max(ans, d[i][j]);\n\t\t\t}\n\t\t}\n\t\tassert(ans != INF);\n\t\tcout << ans << endl;\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <queue>\n#include <cstdio>\n#include <algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst double EPS=1e-8;\nconst double PI=acos(-1);\n\nstruct point{\n\tdouble x,y;\n\tpoint():x(0),y(0){}\n\tpoint(double x,double y):x(x),y(y){}\n\tpoint operator-(const point &a)const{ return point(x-a.x,y-a.y); }\n};\n\ndouble cross(const point &a,const point &b){ return a.x*b.y-a.y*b.x; }\n\ndouble arg(const point &a){ double t=atan2(a.y,a.x); return t<0?t+2*PI:t; }\n\ntypedef vector<point> polygon;\n\nbool is_ccw(const polygon &F){\n\tint n=F.size();\n\tdouble A=0;\n\trep(i,n) A+=cross(F[i],F[(i+1)%n]);\n\treturn A>-EPS;\n}\n\n// trace the frame of a polygon\nvector<int> trace(const vector<int> *G,int u0,int i0){\n\tvector<int> F;\n\tint u=u0,i=i0;\n\tdo{\n\t\tF.push_back(u);\n\t\tint v=G[u][i];\n\t\tint k=G[v].size();\n\t\trep(j,k) if(G[v][j]==u) i=(j-1+k)%k;\n\t\tu=v;\n\t}while(u!=u0 || i!=i0);\n\treturn F;\n}\n\n// normalize the list of vertices\nvector<int> reg(vector<int> a){\n\tint k=min_element(a.begin(),a.end())-a.begin();\n\trep(i,k){\n\t\ta.push_back(a[0]);\n\t\ta.erase(a.begin());\n\t}\n\treturn a;\n}\n\nint main(){\n\tfor(int n,m;scanf(\"%d%d\",&n,&m),n;){\n\t\tpoint P[100];\n\t\trep(u,n) scanf(\"%lf%lf\",&P[u].x,&P[u].y);\n\n\t\tvector<int> G[100];\n\t\trep(i,m){\n\t\t\tint u,v; scanf(\"%d%d\",&u,&v); u--; v--;\n\t\t\tG[u].push_back(v);\n\t\t\tG[v].push_back(u);\n\t\t}\n\n\t\t// angle sort\n\t\trep(u,n){\n\t\t\tint k=G[u].size();\n\t\t\tpair<double,int> A[100];\n\t\t\trep(i,k){\n\t\t\t\tint v=G[u][i];\n\t\t\t\tA[i]=make_pair(arg(P[v]-P[u]),v);\n\t\t\t}\n\t\t\tsort(A,A+k);\n\t\t\trep(i,k) G[u][i]=A[i].second;\n\t\t}\n\n\t\t// decompose to polygons\n\t\tvector< vector<int> > F; // set of polygons\n\t\trep(u,n) rep(i,G[u].size()) F.push_back(reg(trace(G,u,i)));\n\t\tsort(F.begin(),F.end());\n\t\tF.erase(unique(F.begin(),F.end()),F.end());\n\n\t\t// find the outside boundary\n\t\tint n2=F.size(),u0=-1;\n\t\trep(u,n2){\n\t\t\tint k=F[u].size();\n\t\t\tpolygon H(k);\n\t\t\trep(i,k) H[i]=P[F[u][i]];\n\t\t\tif(!is_ccw(H)) u0=u;\n\t\t}\n\n\t\t// build the dual graph\n\t\tvector<int> G2[300];\n\t\trep(u,n2) rep(v,u) {\n\t\t\tbool ok=false;\n\t\t\tint nu=F[u].size(),nv=F[v].size();\n\t\t\trep(i,nu) rep(j,nv) if(F[u][i]==F[v][(j+1)%nv] && F[u][(i+1)%nu]==F[v][j]) ok=true;\n\t\t\tif(ok){\n\t\t\t\tG2[u].push_back(v);\n\t\t\t\tG2[v].push_back(u);\n\t\t\t}\n\t\t}\n\n\t\t// BFS\n\t\tint d[300];\n\t\trep(u,n2) d[u]=(u==u0?0:-1);\n\t\tqueue<int> Q;\n\t\tQ.push(u0);\n\t\twhile(!Q.empty()){\n\t\t\tint u=Q.front(); Q.pop();\n\t\t\trep(i,G2[u].size()){\n\t\t\t\tint v=G2[u][i];\n\t\t\t\tif(d[v]==-1) d[v]=d[u]+1, Q.push(v);\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",*max_element(d,d+n2));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <vector>\n#include <valarray>\n#include <array>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <random>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\ntypedef long double R;\ntypedef complex<R> P;\n\nconst R EPS = 1e-10;\nconst R PI = acos((R)(-1));\n\nint sgn(R a) {\n    if (a < -EPS) return -1;\n    if (a > EPS) return 1;\n    return 0;\n}\n\nR cross(P a, P b) { return a.real()*b.imag() - a.imag()*b.real(); }\n\ntypedef vector<P> Pol;\n\nP cu(const Pol &p, int i) {\n    int s = p.size();\n    return p[(i%s+s)%s];\n}\n\nR area_naive(const Pol &p) {\n    R u = 0;\n    for (int i = 0; i < (int)p.size(); i++) {\n        u += cross(cu(p, i), cu(p, i+1));\n    }\n    return u/2;\n}\n\nR area(const Pol &p) {\n    return abs(area_naive(p));\n}\n\n/*\n -1 -> clock\n 0 -> non polygon\n 1 -> counter clock\n */\nint iscclock(const Pol &p) {\n    return sgn(area_naive(p));\n}\n\nint dualGraph(P p[], vector<int> g[], int n,\n    Pol pol[], vector<int> rg[]) {\n    map<pair<int, int>, int> mp;\n    for (int i = 0; i < n; i++) {\n        sort(g[i].begin(), g[i].end(), [&](int l, int r){\n            return arg(p[l]-p[i]) > arg(p[r]-p[i]);\n        });\n        for (int j = 0; j < (int)g[i].size(); j++) {\n            mp[make_pair(i, g[i][j])] = j;\n        }\n    }\n\n    vector<vector<int>> idx(n), rev(n);\n    for (int i = 0; i < n; i++) {\n        idx[i] = vector<int>(g[i].size(), -1);\n        rev[i].resize(g[i].size());\n        for (int j = 0; j < (int)g[i].size(); j++) {\n            rev[i][j] = mp[make_pair(g[i][j], i)];\n        }\n    }\n\n    int idc = 1;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < (int)g[i].size(); j++) {\n            if (idx[i][j] != -1) continue;\n            Pol po;\n            int ii = i, jj = j;\n            while (idx[ii][jj] != -2) {\n                po.push_back(p[ii]);\n                idx[ii][jj] = -2;\n                int ni = g[ii][jj];\n                int nj = (rev[ii][jj]+1) % g[ni].size();\n                ii = ni; jj = nj;\n            }\n            int id;\n            if (iscclock(po) != 1) {\n                id = 0;\n            } else {\n                id = idc;\n                pol[idc] = po;\n                idc++;\n            }\n            while (idx[ii][jj] == -2) {\n                idx[ii][jj] = id;\n                int ni = g[ii][jj];\n                int nj = (rev[ii][jj]+1) % g[ni].size();\n                ii = ni; jj = nj;\n            }\n        }\n    }\n\n    for (int i = 0; i < idc; i++) {\n        rg[i].clear();\n    }\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < (int)g[i].size(); j++) {\n            if (idx[i][j] < 0) continue;\n            rg[idx[i][j]].push_back(idx[g[i][j]][rev[i][j]]);\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        sort(rg[i].begin(), rg[i].end());\n        rg[i].erase(unique(rg[i].begin(), rg[i].end()), rg[i].end());\n    }\n\n    return idc;\n}\n\nconst int MN = 110;\nP p[MN];\nvector<int> g[MN];\n\nPol pol[2*MN];\nvector<int> rg[2*MN];\n\nint dist[2*MN][2*MN];\n\nbool solve() {\n    int c, w;\n    cin >> c >> w;\n    if (!c) return false;\n\n    for (int i = 0; i < c; i++) {\n        R x, y;\n        cin >> x >> y;\n        p[i] = P(x, y);\n        g[i].clear();\n    }\n\n    for (int i = 0; i < w; i++) {\n        int s, t;\n        cin >> s >> t; s--; t--;\n        g[s].push_back(t);\n        g[t].push_back(s);\n    }\n\n    int m = dualGraph(p, g, c, pol, rg);\n\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < m; j++) {\n            dist[i][j] = 10000;\n        }\n        for (int d: rg[i]) {\n            dist[i][d] = 1;\n        }\n        dist[i][i] = 0;\n    }\n\n    for (int k = 0; k < m; k++) {\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < m; j++) {\n                dist[i][j] = min(dist[i][j], dist[i][k]+dist[k][j]);\n            }\n        }\n    }\n\n    int ma = 0;\n    for (int i = 0; i < m; i++) {\n        ma = max(ma, dist[0][i]);\n    }\n    cout << ma << endl;\n    return true;\n}\n\n\nint main() {\n    while (solve()) {}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<complex>\n#include<deque>\n#include<vector>\nusing namespace std;\ndouble eps=1e-6;\ndouble x[110];\ndouble y[110];\ndouble px[700];\ndouble py[700];\nint ijk[700];\nint v[700];\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ndouble PI=3.14159265358;\nstruct P{\n\tdouble x;double y;\n\tP(){}\n\tP(double X,double Y){\n\t\tx=X;y=Y;\n\t}\n\tP operator+ (const P &a)const{\n\t\treturn P(x+a.x,y+a.y);\n\t}\n\tP operator- (const P &a)const{\n\t\treturn P(x-a.x,y-a.y);\n\t}\n\tP operator* (const double &a)const{\n\t\treturn P(x*a,y*a);\n\t}\n\t/*operator+ (P a){\n\t\treturn P(x+a.x,y+a.y);\n\t}\n\toperator+ (P a){\n\t\treturn P(x+a.x,y+a.y);\n\t}*/\n\t\n};\ninline bool operator < (const P& a, const P& b) {\n    return a.x<b.x||(a.x==b.x&&a.y<b.y);\n}\ninline double cross(const P& a, const P& b) {\n\treturn a.x*b.y-a.y*b.x;\n}\ninline double dot(const P& a, const P& b) {\n\treturn a.x*b.x+a.y*b.y;\n}\n\nint ccw(P a, P b, P c) {\n\tb=b-a;c=c-a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (b.x*b.x+b.y*b.y<c.x*c.x+c.y*c.y) return -2;       // a--b--c on line\n  return 0;\n}\n#define se second\n#define fi first\n\nbool intersectSS(const pair<P,P> &s, const pair<P,P> &t) {\n  return ccw(s.fi,s.se,t.fi)*ccw(s.fi,s.se,t.se) <= 0 &&\n         ccw(t.fi,t.se,s.fi)*ccw(t.fi,t.se,s.se) <= 0;\n}\n\nP pt[700];\nP ps[300];\nint s[400];\nint t[400];\ndouble left[400];\ndouble right[400];\nvector<pair<int,int> >g[700];\nint UF[700];\nint FIND(int a){\n\tif(UF[a]<0)return a;\n\treturn UF[a]=FIND(UF[a]);\n}\nvoid UNION(int a,int b){\n\ta=FIND(a);b=FIND(b);if(a==b)return;UF[a]+=UF[b];UF[b]=a;\n}\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<700;i++)UF[i]=-1;\n\t\tfor(int i=0;i<700;i++)g[i].clear();\n\t\tfor(int i=0;i<a;i++)scanf(\"%lf%lf\",x+i,y+i);\n\t\tfor(int i=0;i<a;i++){\n\t\t\tdouble X=cos(1)*x[i]-sin(1)*y[i];\n\t\t\tdouble Y=sin(1)*x[i]+cos(1)*y[i];\n\t\t\tx[i]=X;\n\t\t\ty[i]=Y;\n\t\t\tps[i]=P(x[i],y[i]);\n\t\t}\n\t\tfor(int i=0;i<b;i++){\n\t\t\tint p,q;scanf(\"%d%d\",&p,&q);\n\t\t\tp--;q--;\n\t\t\ts[i]=p;t[i]=q;\n\t\t\tpx[i*2]=(x[p]+x[q])/2+eps;\n\t\t\tpy[i*2]=(y[p]+y[q])/2;\n\t\t\tpx[i*2+1]=(x[p]+x[q])/2-eps;\n\t\t\tpy[i*2+1]=(y[p]+y[q])/2;\n\t\t\tpt[i*2]=P(px[i*2],py[i*2]);\n\t\t\tpt[i*2+1]=P(px[i*2+1],py[i*2+1]);\n\t\t}\n\t\tdeque<pair<int,int> >Q;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tvector<pair<double,pair<int,int> > >vec;\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tif(s[j]==i){\n\t\t\t\t\tvec.push_back(make_pair(atan2(y[t[j]]-y[i],x[t[j]]-x[i]),make_pair(j,t[j])));\n\t\t\t\t}\n\t\t\t\tif(t[j]==i){\n\t\t\t\t\tvec.push_back(make_pair(atan2(y[s[j]]-y[i],x[s[j]]-x[i]),make_pair(j,s[j])));\n\t\t\t\t}\n\t\t\t}\n\t\t\tstd::sort(vec.begin(),vec.end());\n\t\t\tint sz=vec.size();\n\t\t\tfor(int j=0;j<vec.size();j++){\n\t\t\t\tdouble th=vec[j].first;\n\t\t\t\tdouble th2=vec[(j+1)%sz].first;\n\t\t\t\tif(th>th2)th2+=2*PI;\n\t\t\t\tif(th2-th<=PI+EPS)continue;\n\t\t\t\tfor(int k=0;k<2;k++)for(int l=0;l<2;l++){\n\t\t\t\t\tif(intersectSS(make_pair(pt[vec[j].second.first*2+k],pt[vec[(j+1)%sz].second.first*2+l]),\n\t\t\t\t\tmake_pair(ps[i],ps[vec[j].second.second]))&&intersectSS(make_pair(pt[vec[j].second.first*2+k],pt[vec[(j+1)%sz].second.first*2+l]),\n\t\t\t\t\tmake_pair(ps[i],ps[vec[(j+1)%sz].second.second]))){\n\t\t\t\t\t\tg[vec[j].second.first*2+k].push_back(make_pair(vec[(j+1)%sz].second.first*2+l,0));\n\t\t\t\t\t\tg[vec[(j+1)%sz].second.first*2+l].push_back(make_pair(vec[j].second.first*2+k,0));\n\t\t\t\t\t\tUNION(vec[j].second.first*2+k,vec[(j+1)%sz].second.first*2+l);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<b*2;i++){\n\t\t\tijk[i]=999999999;\n\t\t\tv[i]=0;\n\t\t\tbool OK=true;\n\t\t\tint tt=s[i/2];\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tif(tt==s[j]||tt==t[j])continue;\n\t\t\t\tif(intersectSS(make_pair(ps[tt],ps[tt]+(pt[i]-ps[tt])*10000.0),make_pair(ps[s[j]],ps[t[j]]))){\n\t\t\t\t\tOK=false;break;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttt=t[i/2];\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tif(tt==s[j]||tt==t[j])continue;\n\t\t\t\tif(intersectSS(make_pair(ps[tt],ps[tt]+(pt[i]-ps[tt])*10000.0),make_pair(ps[s[j]],ps[t[j]]))){\n\t\t\t\t\tOK=false;break;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(OK){\n\t\t\t\tijk[i]=0;\n\t\t\t\tQ.push_back(make_pair(0,i));\n\t\t\t}\n\t\t\tfor(int j=i+1;j<b*2;j++){\n\t\t\t\tint cnt=0;\n\t\t\t\tif(FIND(i)==FIND(j))continue;\n\t\t\t\tfor(int k=0;k<b;k++){\n\t\t\t\t\tif(intersectSS(make_pair(ps[s[k]],ps[t[k]]),make_pair(pt[i],pt[j]))){\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tif(cnt>1)break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(cnt<2){\n\t\t\t\t\tif(cnt==0){\n\t\t\t\t\t\tUNION(i,j);\n\t\t\t\t\t}\n\t\t\t\t\tg[i].push_back(make_pair(j,cnt));\n\t\t\t\t\tg[j].push_back(make_pair(i,cnt));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(Q.size()){\n\t\t\tint cost=-Q.front().first;\n\t\t\tint at=Q.front().second;Q.pop_front();\n\t\t\tif(v[at])continue;\n\t\t\tv[at]=1;\n\t\t\tfor(int i=0;i<g[at].size();i++){\n\t\t\t\tif(!v[g[at][i].first]&&ijk[g[at][i].first]>cost+g[at][i].second){\n\t\t\t\t\tijk[g[at][i].first]=cost+g[at][i].second;\n\t\t\t\t\tif(g[at][i].second==1)Q.push_back(make_pair(-ijk[g[at][i].first],g[at][i].first));\n\t\t\t\t\telse Q.push_front(make_pair(-ijk[g[at][i].first],g[at][i].first));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret=0;\n\t\tfor(int i=0;i<b*2;i++)ret=max(ret,ijk[i]);\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <complex>\n#include <cmath>\nusing namespace std;\n\ntypedef complex<double> P;\n\n\nstruct coninfo{\n\tint rnum, cnum, idx;\n\tdouble arg;\n\n\tconinfo(int cn): rnum(-1), cnum(cn), idx(-1), arg(0.0) {}\n\n\tbool operator< (const coninfo &c) const{\n\t\treturn arg < c.arg;\n\t}\n};\n\ntemplate <class T>\nint nextindex(int i, T &v){\n\tint n = v.size();\n\treturn i + 1 == n ? 0 : i + 1;\n}\n\nbool cmpreal(const P &a, const P &b){\n\treturn real(a) < real(b);\n}\n\nvector<vector<coninfo> > cls;\nint room;\n\nvoid detroom(int c, int idx){\n\twhile(1){\n\t\tint nxtc = cls[c][idx].cnum;\n\t\tint nxti = nextindex(cls[c][idx].idx, cls[nxtc]);\n\t\tif(cls[nxtc][nxti].rnum != -1){\n\t\t\tbreak;\n\t\t}\n\t\tcls[nxtc][nxti].rnum = room;\n\n\t\tc = nxtc;\n\t\tidx = nxti;\n\t}\n\n\t++room;\n}\n\nint solve(int C, int W){\n\tvector<P> cpos(C);\n\n\tcls.assign(C, vector<coninfo>());\n\troom = 0;\n\n\tint x, y, s, t;\n\tfor(int i = 0; i < C; ++i){\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tcpos[i] = P(x, y);\n\t}\n\tfor(int i = 0; i < W; ++i){\n\t\tscanf(\"%d%d\", &s, &t);\n\t\tcls[s-1].push_back(coninfo(t-1));\n\t\tcls[t-1].push_back(coninfo(s-1));\n\t}\n\n\tfor(int i = 0; i < C; ++i){\n\t\tfor(int j = 0; j < cls[i].size(); ++j){\n\t\t\tcls[i][j].arg = arg(cpos[cls[i][j].cnum] - cpos[i]);\n\t\t}\n\t\tsort(cls[i].begin(), cls[i].end());\n\t}\n\n\tfor(int i = 0; i < C; ++i){\n\t\tfor(int j = 0; j < cls[i].size(); ++j){\n\t\t\tint k;\n\t\t\tfor(k = 0; cls[cls[i][j].cnum][k].cnum != i; ++k);\n\t\t\tcls[i][j].idx = k;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < C; ++i){\n\t\tfor(int j = 0; j < cls[i].size(); ++j){\n\t\t\tif(cls[i][j].rnum == -1){\n\t\t\t\tdetroom(i, j);\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<vector<char> > G(room, vector<char>(room));\n\tfor(int i = 0; i < C; ++i){\n\t\tint k = cls[i].size() - 1;\n\t\tfor(int j = 0; j < cls[i].size(); ++j){\n\t\t\tint a = cls[i][k].rnum;\n\t\t\tint b = cls[i][j].rnum;\n\n\t\t\tG[a][b] = G[b][a] = 1;\n\t\t\tk = j;\n\t\t}\n\t}\n\n\tint minidx = min_element(cpos.begin(), cpos.end(), cmpreal) - cpos.begin();\n\tint out = cls[minidx][0].rnum;\n\n\tvector<int> visit(room, -1);\n\tqueue<int> q;\n\tq.push(out);\n\tvisit[out] = 0;\n\twhile(!q.empty()){\n\t\tfor(int i = 0; i < room; ++i){\n\t\t\tif(G[q.front()][i] && visit[i] == -1){\n\t\t\t\tvisit[i] = visit[q.front()] + 1;\n\t\t\t\tq.push(i);\n\t\t\t}\n\t\t}\n\t\tq.pop();\n\t}\n\n\treturn *max_element(visit.begin(), visit.end());\n}\n\nint main(){\n\tint c, w;\n\twhile(scanf(\"%d%d\", &c, &w), c){\n\t\tprintf(\"%d\\n\", solve(c, w));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef LOCAL\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\nusing namespace std;\n\nstruct point {\n\tint x, y;\n\texplicit point(double x_ = 0.0, double y_ = 0.0):x(x_), y(y_) {}\n\tpoint(const point &p):x(p.x), y(p.y) {}\n\n\tpoint operator+(const point &p) const {\n\t\treturn point(x + p.x, y + p.y);\n\t}\n\n\tpoint operator-(const point &p) const {\n\t\treturn point(x - p.x, y - p.y);\n\t}\n};\n\ninline double angle(const point &p) {\n\treturn atan2(p.y, p.x);\n}\n\ninline int cross(const point &a, const point &b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\nstruct edge {\n\tint to;\n\tdouble theta;\n\tbool used;\n\tedge(int to_, double theta_):to(to_), theta(theta_), used(false) {}\n\n\tinline bool operator<(const edge &e) const {\n\t\treturn theta < e.theta;\n\t}\n};\n\ninline istream &operator>>(istream &is, point &p){\n\treturn is >> p.x >> p.y;\n}\n\ninline bool outside(const vector<int> &P, const vector<point> &points) {\n\tdouble res = 0.0;\n\tpoint prev = points[P.back()];\n\n\tfor(const auto &e : P) {\n\t\tconst point &curr = points[e];\n\t\tres += cross(prev, curr);\n\t\tprev = curr;\n\t}\n\treturn res >= 0;\n}\n\ninline bool neighbor(const vector<int> &a, const vector<int> &b) {\n\tint pa = a.back();\n\tfor(const auto &ca : a) {\n\n\t\tint pb = b.back();\n\t\tfor(const auto &cb : b) {\n\t\t\tif((pa == pb && ca == cb) || (pa == cb && ca == pb)) return true;\n\t\t\tpb = cb;\n\t\t}\n\n\t\tpa = ca;\n\t}\n\treturn false;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tfor(int n, m; cin >> n >> m && n;) {\n\t\tvector<point> points(n);\n\t\tfor(auto &e : points) cin >> e;\n\n\t\tvector<vector<edge>> G(n);\n\t\tfor(int i = 0; i < m; ++i) {\n\t\t\tint s, t;\n\t\t\tcin >> s >> t;\n\t\t\t--s; --t;\n\t\t\tG[s].emplace_back(t, angle(points[t] - points[s]));\n\t\t\tG[t].emplace_back(s, angle(points[s] - points[t]));\n\t\t}\n\n\t\tfor(auto &edges : G) sort(begin(edges), end(edges));\n\n\t\tint s = -1;\n\n\t\tconst int V = 2 + m - n;\n\t\tvector<vector<int>> faces;\n\t\tfaces.reserve(V);\n\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tfor(int j = 0; j < static_cast<int>(G[i].size()); ++j) {\n\t\t\t\tint v = i;\n\t\t\t\tint e_idx = j;\n\n\t\t\t\tvector<int> P;\n\t\t\t\twhile(true) {\n\t\t\t\t\tedge &e = G[v][e_idx];\n\t\t\t\t\tif(e.used) break;\n\t\t\t\t\te.used = true;\n\n\t\t\t\t\tP.emplace_back(v);\n\n\t\t\t\t\tfor(int k = 0; k < static_cast<int>(G[e.to].size()); ++k) {\n\t\t\t\t\t\tif(G[e.to][k].to == v) {\n\t\t\t\t\t\t\tv = e.to;\n\t\t\t\t\t\t\te_idx = k + 1;\n\t\t\t\t\t\t\tif(e_idx >= static_cast<int>(G[e.to].size())) e_idx = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(P.size() >= 3) {\n\t\t\t\t\tif(s == -1 && outside(P, points)) s = faces.size();\n\t\t\t\t\tfaces.emplace_back(P);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tassert(s != -1);\n\n\t\tvector<vector<int>> Gf(V);\n\n\t\tfor(int i = 0; i < V; ++i) {\n\t\t\tfor(int j = i + 1; j < V; ++j) {\n\t\t\t\tif(neighbor(faces[i], faces[j])) {\n\t\t\t\t\tGf[i].emplace_back(j);\n\t\t\t\t\tGf[j].emplace_back(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvector<int> dist(V, INT_MAX);\n\t\tqueue<int> que;\n\n\t\tdist[s] = 0;\n\t\tque.push(s);\n\n\t\twhile(!que.empty()) {\n\t\t\tconst int v = que.front();\n\t\t\tque.pop();\n\n\t\t\tfor(const auto &to : Gf[v]) {\n\t\t\t\tif(dist[to] == INT_MAX) {\n\t\t\t\t\tdist[to] = dist[v] + 1;\n\t\t\t\t\tque.push(to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << *max_element(begin(dist), end(dist)) << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cassert>\nusing namespace std;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n\treturn abs(a.real()-b.real()) > EPS ? real(a) < real(b) : imag(a) + EPS < imag(b);\n    //return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\nP readPoint(){\n\tdouble x,y;\n\tcin >> x >> y;\n\treturn P(x,y);\n}\n\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\ntypedef vector<P> G;\n\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\n\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\nP reflection(const L &l, const P &p) {\n  return p + 2. * (projection(l, p) - p);\n}\ndouble distanceLP(const L &l, const P &p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\n#define rep(i,N) for(int i = 0 ; i < N ; i++)\nP ps[110];\nvector<int> g[110];\n\nvector<int> normalize(vector<int> v){\n\tauto it = min_element(v.begin(),v.end());\n\trotate(v.begin(),it,v.end());\n\treturn v;\n}\n\nint done[110];\nvoid f(int a,int b,int s,vector<int> &v){\n\tv.push_back(b);\n\tif( b == s ) return;\n\tif( done[b]++ ) throw 0;\n\tsort(g[b].begin(),g[b].end(),[&](int x,int y){\n\t\tP A = ps[x] - ps[b];\n\t\tP B = ps[y] - ps[b];\n\t\treturn cross(A,B) > 0;\n\t});\n\trotate(g[b].begin(),find(g[b].begin(),g[b].end(),a),g[b].end());\n\tf(b,g[b][1],s,v);\n}\n\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n\ndouble area2(const G& P) {\n  double A = 0;\n  for (int i = 0; i < P.size(); ++i) \n    A += cross(curr(P, i), next(P, i));\n  return A;\n}\n\nint main(){\n\t\n\tint C,W;\n\twhile( cin >> C >> W && (C||W) ){\n\t\trep(i,C) ps[i] = readPoint();\n\t\trep(i,C) g[i].clear();\n\t\trep(i,W){\n\t\t\tint a,b;\n\t\t\tcin >> a >> b;\n\t\t\t--a,--b;\n\t\t\tg[a].push_back(b);\n\t\t\tg[b].push_back(a);\n\t\t}\n\t\tvector< vector<int> > poly;\n\t\trep(i,C){\n\t\t\trep(j,g[i].size()){\n\t\t\t\ttry{\n\t\t\t\t\tmemset(done,0,sizeof(done));\n\t\t\t\t\tvector<int> v;\n\t\t\t\t\tf(i,g[i][j],i,v);\n\t\t\t\t\tvector<P> g;\n\t\t\t\t\trep(k,v.size())g.push_back(ps[v[k]]);\n\t\t\t\t\tif( area2(g) > 0 ){ continue; }\n\t\t\t\t\tpoly.push_back(normalize(v));\n\t\t\t\t}catch(int x){\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(poly.begin(),poly.end());\n\t\tpoly.erase(unique(poly.begin(),poly.end()),poly.end());\n\t\t\n\t\tmap< pair<int,int>, vector<int> > edgs;\n\t\tfor(int i = 0 ; i < poly.size() ; i++){\n\t\t\tfor(int j = 0 ; j < poly[i].size() ; j++){\n\t\t\t\tint A = curr(poly[i],j);\n\t\t\t\tint B = next(poly[i],j);\n\t\t\t\tif( A > B ) swap(A,B);\n\t\t\t\tedgs[pair<int,int>(A,B)].push_back(i);\n\t\t\t}\n\t\t}\n\t\tint M = poly.size() + 1;\n\t\tint wf[M][M];\n\t\trep(i,M) rep(j,M){\n\t\t\twf[i][j] = i==j?0:1e9;\n\t\t}\n\t\t\n\t\tfor( auto x : edgs ){\n\t\t\tvector<int> v = x.second;\n\t\t\tif( v.size() < 2 ) v.push_back(M-1);\n\t\t\tassert( v.size() == 2 );\n\t\t\twf[v[0]][v[1]] = wf[v[1]][v[0]] = 1;\n\t\t}\n\t\trep(i,M)rep(j,M)rep(k,M) wf[j][k] = min(wf[j][i]+wf[i][k],wf[j][k]);\n\t\tint ans = 0;\n\t\trep(i,M){\n\t\t\tans = max(ans,wf[i][M-1]);\n\t\t}\n\t\tcout << ans << endl;\n\t\t\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<climits>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reg(i,a,b) for(int i=(a);i<=(b);i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=(b);i>=(a);i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\ntypedef pair<double,mp> mmp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n\n\nint px[105];\nint py[105];\nint pn,wn;\n\nvector<mmp> ws[105];\n\nvector<mp> vs[1005];\n\nint gone[1005]={};\n\nvoid cons(mmp& ne,int fr){\n\tint to = ne.sec.fir;\n\tint c1 = ne.sec.sec;\n\tne.sec.sec=-1;\n\tmmp& nexte = ne;\n\trep(i,ws[to].size()){\n\t\tmmp e = ws[to][i];\n\t\tif(e.sec.fir == fr){\n\t\t\tnexte = ws[to][ (i+1)%ws[to].size() ];\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tint cw = nexte.sec.sec;\n\tif(cw==-1)return;\n\n\tvs[cw].push_back(mp(c1,0));\n\tvs[c1].push_back(mp(cw,0));\n\t\n\tcons(nexte,to);\t\n\t\n}\n\nint main(void){\n\t\nwhile(1){\n\t\t\n\tscanf(\"%d%d\",&pn,&wn);\n\tif(pn == 0)break;\n\tmemset(px,0,sizeof(px));\n\tmemset(py,0,sizeof(py));\n\tmemset(gone,0,sizeof(gone));\n\trep(i,105){\n\t\tws[i].clear();\n\t}\n\trep(i,1005){\n\t\tvs[i].clear();\n\t}\n\t\n\t\n\tvector<pair<int,mp> > sv;\n\trep(i,pn){\n\t\tscanf(\"%d%d\",&px[i],&py[i]);\n\t\tsv.push_back(make_pair(i,mp(px[i],py[i])));\n\t}\n\t\n\tsort(sv.begin(),sv.end());\n\t\n\tint nminv = sv[0].first;\n\t\n\trep(i,wn){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\ta--; b--;\n\t\tint nvx = px[b]-px[a];\n\t\tint nvy = py[b]-py[a];\n\t\tws[a].push_back( mmp(atan2(nvy,nvx), mp(b,i*2)) );\n\t\tws[b].push_back( mmp(atan2(-nvy,-nvx), mp(a,i*2+1)) );\n\t\tvs[i*2].push_back( mp(i*2+1,1) );\n\t\tvs[i*2+1].push_back( mp(i*2,1) );\n\t}\n\t\n\trep(i,pn){\n\t\tsort(ws[i].begin(),ws[i].end());\n\t}\n\t\n\tint nsoto = ws[nminv][0].second.second;\n\t\n\t\n\t\n\trep(i,pn){\n\t\trep(j,ws[i].size()){\n\t\t\tif(ws[i][j].sec.sec==-1)continue;\n\t\t\tcons(ws[i][j],i);\n\t\t}\n\t}\n\t\n\t/*\n\tprintf(\"soto .. %d\\n\",nsoto);\n\trep(i,1005){\n\t\trep(j,vs[i].size()){\n\t\t\tprintf(\"(%d %d %d) \",i,vs[i][j].fir,vs[i][j].sec);\n\t\t}\n\t}*/\n\t\n\t\n\tpriority_queue<mp,vector<mp>,greater<mp> > que;\n\tque.push(mp(0,nsoto));\n\t\n\tint ans=0;\n\twhile(!que.empty()){\n\t\tmp pa = que.top();\n\t\tque.pop();\n\t\tint no = pa.sec,\n\t\t\tnc = pa.fir;\n\t\tif(gone[no]!=0)continue;\n\t\tans = max(ans,nc);\n\t\tgone[no]=1;\n\t\trep(i,vs[no].size()){\n\t\t\tint to = vs[no][i].fir;\n\t\t\tif(gone[to])continue;\n\t\t\tque.push( mp(nc + vs[no][i].sec,to));\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\t\n}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld INF = 1e10;\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nnamespace std {\n  bool operator<(const Point &lhs, const Point &rhs) {\n    if (lhs.real() < rhs.real() - eps) return true;\n    if (lhs.real() > rhs.real() + eps) return false;\n    return lhs.imag() < rhs.imag();\n  }\n}\n\nPoint input_point() {\n  ld x, y;\n  cin >> x >> y;\n  return Point(x, y);\n}\n\nbool eq(ld a, ld b) {\n  return (abs(a - b) < eps);\n}\n\nld dot(Point a, Point b) {\n  return real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n  return imag(conj(a) * b);\n}\n\nclass Line {\npublic:\n  Point a, b;\n  Line () : a(Point(0, 0)), b(Point(0, 0)) {}\n  Line (Point a, Point b) : a(a), b(b) {}\n};\n\nclass Circle {\npublic:\n  Point p;\n  ld r;\n  Circle () : p(Point(0, 0)), r(0) {}\n  Circle (Point p, ld r) : p(p), r(r) {}\n};\n\nint ccw (Point a, Point b, Point c) {\n  b -= a; c -= a;\n  if (cross(b, c) > eps) return 1;\n  if (cross(b, c) < -eps) return -1;\n  if (dot(b, c) < 0) return 2;\n  if (norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nbool isis_ll (Line l, Line m) {\n  return !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls (Line l, Line s) {\n  return isis_ll(l, s) &&\n    (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_ss(Line s, Line t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n    ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool isis_lp (Line l, Point p) {\n  return (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp (Line s, Point p) {\n  return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\nPoint proj (Line l, Point p) {\n  ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + t * (l.a - l.b);\n}\n\nPoint is_ll (Line s, Line t) {\n  Point sv = s.b - s.a, tv = t.b - t.a;\n  assert(cross(sv, tv) != 0);\n  return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nld dist_lp (Line l, Point p) {\n  return abs(p - proj(l, p));\n}\n\nld dist_ll (Line l, Line m) {\n  return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls (Line l, Line s) {\n  return isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp (Line s, Point p) {\n  Point r = proj(s, p);\n  return isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss (Line s, Line t) {\n  if (isis_ss(s, t)) return 0;\n  return min({dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b)});\n}\n\nvector<Point> is_cc (Circle c1, Circle c2){\n  vector<Point> res;\n  ld d = abs(c1.p - c2.p);\n  ld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n  ld dfr = c1.r * c1.r - rc * rc;\n  if (abs(dfr) < eps) dfr = 0.0;\n  else if (dfr < 0.0) return res;\n  ld rs = sqrt(dfr);\n  Point diff = (c2.p - c1.p) / d;\n  res.push_back(c1.p + diff * Point(rc, rs));\n  if (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n  return res;\n}\n\nvector<Point> is_lc (Circle c, Line l){\n  vector<Point> res;\n  ld d = dist_lp(l, c.p);\n  if (d < c.r + eps){\n    ld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d);\n    Point nor = (l.a - l.b) / abs(l.a - l.b);\n    res.push_back(proj(l, c.p) + len * nor);\n    res.push_back(proj(l, c.p) - len * nor);\n  }\n  return res;\n}\n\nvector<Point> is_sc(Circle c, Line l){\n  vector<Point> v = is_lc(c, l), res;\n  for (Point p : v)\n    if (isis_sp(l, p)) res.push_back(p);\n  return res;\n}\n\nvector<Line> tangent_cp(Circle c, Point p) {\n  vector<Line> ret;\n  Point v = c.p - p;\n  ld d = abs(v);\n  ld l = sqrt(norm(v) - c.r * c.r);\n  if (isnan(l)) { return ret; }\n  Point v1 = v * Point(l / d,  c.r / d);\n  Point v2 = v * Point(l / d, -c.r / d);\n  ret.push_back(Line(p, p + v1));\n  if (l < eps) return ret;\n  ret.push_back(Line(p, p + v2));\n  return ret;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n  vector<Line> ret;\n  if (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n    Point center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n    ret = tangent_cp(c1, center);\n  }\n  if (abs(c1.r - c2.r) > eps) {\n    Point out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n    vector<Line> nret = tangent_cp(c1, out);\n    ret.insert(ret.end(), ALL(nret));\n  }\n  else {\n    Point v = c2.p - c1.p;\n    v /= abs(v);\n    Point q1 = c1.p + v * Point(0,  1) * c1.r;\n    Point q2 = c1.p + v * Point(0, -1) * c1.r;\n    ret.push_back(Line(q1, q1 + v));\n    ret.push_back(Line(q2, q2 + v));\n  }\n  return ret;\n}\n\ntypedef vector<Point> Polygon;\n\nld area(const Polygon &p) {\n  ld res = 0;\n  int n = p.size();\n  REP(j,n) res += cross(p[j], p[(j+1)%n]);\n  return res / 2;\n}\n\nbool is_counter_clockwise (const Polygon &poly) {\n  ld angle = 0;\n  int n = poly.size();\n  REP(i,n) {\n    Point a = poly[i], b = poly[(i+1)%n], c = poly[(i+2)%n];\n    angle += arg((c - b) / (b - a));\n  }\n  return angle > eps;\n}\n\nint is_in_polygon (const Polygon &poly, Point p) {\n  ld angle = 0;\n  int n = poly.size();\n  REP(i,n) {\n    Point a = poly[i], b = poly[(i+1)%n];\n    if (isis_sp(Line(a, b), p)) return 1;\n    angle += arg((b - p) / (a - p));\n  }\n  return eq(angle, 0) ? 0 : 2;\n}\n\nPolygon convex_hull(vector<Point> ps) {\n  int n = ps.size();\n  int k = 0;\n  sort(ps.begin(), ps.end());\n  Polygon ch(2 * n);\n  for (int i = 0; i < n; ch[k++] = ps[i++])\n    while (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n  for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n    while (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n  ch.resize(k - 1);\n  return ch;\n}\n\nPolygon convex_cut(const Polygon &ps, Line l) {\n  int n = ps.size();\n  Polygon Q;\n  REP(i,n) {\n    Point A = ps[i], B = ps[(i+1)%n];\n    Line m = Line(A, B);\n    if (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n    if (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))\n      Q.push_back(is_ll(l, m));\n  }\n  return Q;\n}\n\nvoid add_point(vector<Point> &ps, Point p) {\n  for (Point q : ps) if (abs(q - p) < eps) return;\n  ps.push_back(p);\n}\n\ntypedef ll Weight;\n\nstruct Edge { int from, to; Weight weight;\n  Edge(int from, int to, Weight weight) :\n    from(from), to(to), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.from != f.from ? e.from < f.from : e.to < f.to;\n}\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, int from, int to, Weight weight) {\n  g[from].push_back((Edge){from, to, weight});\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n  int n = p.size(), m = s.size();\n  Graph g(n);\n  REP(i,m) {\n    vector<pair<ld,int>> vec;\n    REP(j,n) if (isis_sp(s[i], p[j]))\n      vec.emplace_back(abs(s[i].a - p[j]), j);\n    sort(ALL(vec));\n    REP(j,vec.size()-1) {\n      int from = vec[j].second, to = vec[j+1].second;\n      add_edge(g, from, to, abs(p[from] - p[to]));\n    }\n  }\n  return g;\n}\n\nGraph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n  int n = p.size(), m = c.size();\n  Graph g(n);\n  REP(i,m) {\n    vector<pair<ld,int>> vec;\n    REP(j,n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n      vec.emplace_back(arg(c[i].p - p[j]), j);\n    sort(ALL(vec));\n    REP(j,vec.size()-1) {\n      int from = vec[j].second, to = vec[j+1].second;\n      ld angle = vec[j+1].first - vec[j].first;\n      add_edge(g, from, to, angle * c[i].r);\n    }\n    if (vec.size() >= 2) {\n      int from = vec.back().second, to = vec.front().first;\n      ld angle = vec.front().first - vec.back().first;\n      add_edge(g, from, to, angle * c[i].r);\n    }\n  }\n  return g;\n}\n\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\nGraph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n  int N = p.size();\n  polygon.clear();\n  REP(i,1024) REP(j,1024) seg2p[i][j].clear();\n  vector<vector<tuple<ld,int,bool>>> tup(N);\n  REP(i,s.size()) {\n    int a = -1, b = -1;\n    REP(j,N) if (abs(s[i].a - p[j]) < eps) a = j;\n    REP(j,N) if (abs(s[i].b - p[j]) < eps) b = j;\n    assert(a >= 0 && b >= 0);\n    tup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n    tup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n  }\n  REP(i,N) sort(ALL(tup[i]));\n  REP(i,N) {\n    REP(j,tup[i].size()) {\n      ld angle; int pos = j, from = i, to; bool flag;\n      tie(angle, to, flag) = tup[i][j];\n      if (flag) continue;\n      vector<int> ps;\n      while (!flag) {\n        ps.push_back(from);\n        get<2>(tup[from][pos]) = true;\n        seg2p[from][to].push_back(polygon.size());\n        seg2p[to][from].push_back(polygon.size());\n        angle += pi + eps;\n        if (angle > pi) angle -= 2 * pi;\n        auto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n        if (it == tup[to].end()) it = tup[to].begin();\n        from = to; tie(angle, to, flag) = *it;\n        pos = it - tup[from].begin();\n      }\n      polygon.push_back(ps);\n    }\n  }\n  for(int i=0;i<polygon.size();i++){\n    Polygon ps;\n    for(int j=0; j<polygon[i].size(); j++)\n      ps.push_back(p[polygon[i][j]]);\n    bool soto = true;\n    for(int i=0;i<p.size();i++){\n      if(is_in_polygon(ps, p[i]) == 0)\n\tsoto=false;\n    }\n    if(soto){\n      vector<int> hoge = polygon[0];\n      vector<int> huga = polygon[i];\n      polygon[0] = huga;\n      polygon[i] = hoge;\n      //cout << \"kore\" << i << endl;\n      break;\n    }\n  }\n  /*cout << endl;\n  for(int i=0;i<polygon.size();i++){\n    for(int j=0;j<polygon[i].size();j++)\n      cout << polygon[i][j] << \" \";\n    cout << endl;\n    }*/\n    \n  Graph g(polygon.size());\n  REP(i,N) REP(j,i) {\n    if (seg2p[i][j].size() == 2) {\n      int from = seg2p[i][j][0], to = seg2p[i][j][1];\n      g[from].push_back(Edge(from, to, 1));\n      g[to].push_back(Edge(to, from, 1));\n    }\n  }\n  return g;\n}\n\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(int r, int g, int b) {\n  fprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(Point p) {\n  fprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(Line l) {\n  fprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(Line l) {\n  Point v = l.b - l.a;\n  Line m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n  fprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n  int n = p.size();\n  REP(i,n) draw_segment(Line(p[i], p[(i+1)%n]));\n}\n\nvoid draw_circle(Circle c) {\n  fprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\n\nvoid shortestPath(const Graph &g, int s,\n\t\t  vector<Weight> &dist, vector<int> &prev) {\n  int n = g.size();\n  dist.assign(n, INF); dist[s] = 0;\n  prev.assign(n, -1);\n  priority_queue<Edge> Q; // \"e < f\" <=> \"e.weight > f.weight\"\n  for (Q.push(Edge(-2, s, 0)); !Q.empty(); ) {\n    Edge e = Q.top(); Q.pop();\n    if (prev[e.to] != -1) continue;\n    prev[e.to] = e.from;\n    for(auto f=g[e.to].begin();f!=g[e.to].end();f++) {\n      if (dist[f->to] > e.weight+f->weight) {\n        dist[f->to] = e.weight+f->weight;\n        Q.push(Edge(f->from, f->to, e.weight+f->weight));\n      }\n    }\n  }\n}\n\nint main(){\n  ll C, W;\n  while(cin >> C >> W, C!=0 || W!=0){\n    vector<Point> v;\n    for(int i=0;i<C;i++)\n      v.push_back(input_point());\n    vector<Line> e;\n    for(int i=0;i<W;i++){\n      ll s,t;\n      cin >> s >> t;\n      s--; t--;\n      e.push_back(Line(v[s], v[t]));\n    }\n    Graph g = dual_graph(e, v);\n    vector<Weight> dist;\n    vector<int> prev;\n    shortestPath(g, 0, dist, prev);\n    ll ans = 0;\n    for(int i=0;i<dist.size();i++)\n      ans = max(ans, dist[i]);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "int bottom;\nint outside_color;\n\n// Library.\n#include<cassert>\n#include<map>\n#include<vector>\n#include<cmath>\n#include<queue>\n#include<algorithm>\n// Type.\ntypedef int Label;\ntypedef double Weight;\n// Class.\ntemplate<typename Vertex, typename Edge>\nclass PlaneGraph {\npublic:\n  void insert(const Vertex& v);\n  void insert(Edge e);\n  const PlaneGraph<Vertex, Edge> dualgraph() const;\n  const std::map<Label, Weight> Dijkstra(const Label& start) const;\nprivate:\n  void dualgraph_color(std::map<Label, std::map<Label, int>>& color, int c, const Edge& e, const std::map<Label, std::vector<Edge>>& edge) const;\n  std::map<Label, Vertex> V;\n  std::map<Label, std::vector<Edge>> E;\n};\n// Implement.\ntemplate<typename Vertex, typename Edge>\nvoid PlaneGraph<Vertex, Edge>::insert(const Vertex& v) {\n  V[v.label] = v;\n}\ntemplate<typename Vertex, typename Edge>\nvoid PlaneGraph<Vertex, Edge>::insert(Edge e) {\n  assert(V.find(e.from) != std::end(V));\n  assert(V.find(e.to) != std::end(V));\n  E[e.from].push_back(e);\n  std::swap(e.from, e.to);\n  E[e.from].push_back(e);\n}\ntemplate<typename Vertex, typename Edge>\nconst PlaneGraph<Vertex, Edge> PlaneGraph<Vertex, Edge>::dualgraph() const {\n  // Sort edges counterclockwise.\n  auto edge = E;\n  for(auto& list: edge) if(!list.second.empty()) {\n    std::sort(std::begin(list.second), std::end(list.second), [&](const Edge& lhs, const Edge& rhs) {\n      double l = std::atan2(V.at(lhs.to).y - V.at(lhs.from).y, V.at(lhs.to).x - V.at(lhs.from).x);\n      double r = std::atan2(V.at(rhs.to).y - V.at(rhs.from).y, V.at(rhs.to).x - V.at(rhs.from).x);\n      return l < r;\n    });\n    list.second.push_back(list.second.front());\n  }\n  // Color edges.\n  std::map<Label, std::map<Label, int>> color;\n  int c = 1;\n  for(const auto& list: edge) {\n    for(const auto& e: list.second) if(!color[e.from].count(e.to)) dualgraph_color(color, c++, e, edge);\n    if(list.first == bottom) outside_color = color[list.second.front().from][list.second.front().to];\n  }\n  // Construct the dualgraph.\n  PlaneGraph<Vertex, Edge> result;\n  std::vector<std::vector<bool>> used(c, std::vector<bool>(c, false));\n  for(int i = 1; i < c; ++i) result.insert(Vertex({i}));\n  for(const auto& list: E) for(const auto& e: list.second) if(!used[color[e.from][e.to]][color[e.to][e.from]]) {\n    used[color[e.from][e.to]][color[e.to][e.from]] = true;\n    used[color[e.to][e.from]][color[e.from][e.to]] = true;\n    result.insert(Edge({color[e.from][e.to], color[e.to][e.from], 1}));\n  }\n  return result;\n}\ntemplate<typename Vertex, typename Edge>\nvoid PlaneGraph<Vertex, Edge>::dualgraph_color(std::map<Label, std::map<Label, int>>& color, int c, const Edge& e, const std::map<Label, std::vector<Edge>>& edge) const {\n  color[e.from][e.to] = c;\n  for(auto it = edge.at(e.to).rbegin(); it != edge.at(e.to).rend(); ++it) if(it->to == e.from) {\n    ++it;\n    if(!color[it->from].count(it->to)) dualgraph_color(color, c, *it, edge);\n    break;\n  }\n}\ntemplate<typename Vertex, typename Edge>\nconst std::map<Label, Weight> PlaneGraph<Vertex, Edge>::Dijkstra(const Label& start) const {\n  std::map<Label, Weight> result;\n  std::priority_queue<Edge, std::vector<Edge>, std::function<bool(Edge, Edge)>> q([](Edge lhs, Edge rhs) {\n    return lhs.weight > rhs.weight;\n  });\n  q.push(Edge({start, start, 0}));\n  while(!q.empty()) {\n    auto cur = q.top();\n    q.pop();\n    if(result.count(cur.to)) continue;\n    result[cur.to] = cur.weight;\n    if(E.count(cur.to)) for(const auto& nex: E.at(cur.to)) if(!result.count(nex.to)) q.push(Edge({nex.from, nex.to, cur.weight + nex.weight}));\n  }\n  return result;\n}\n////////////////////////////////////////\n// Configuration.\nstruct Vertex {Label label; double x, y;};\nstruct Edge {Label from, to; Weight weight;};\n////////////////////////////////////////\n#include<bits/stdc++.h>\nusing namespace std;\nint main() {\n  int C, W;\n  while(cin >> C >> W, C | W) {\n    vector<Vertex> pillar;\n    int bottom_x = 1001, bottom_y = 1001;\n    for(int i = 0; i < C; ++i) {\n      double x, y;\n      cin >> x >> y;\n      pillar.push_back({i, x, y});\n      if(bottom_y < y) continue;\n      if(bottom_y == y && bottom_x < x) continue;\n      bottom_x = x;\n      bottom_y = y;\n      bottom = i;\n    }\n    PlaneGraph<Vertex, Edge> G;\n    for(const auto& p: pillar) G.insert(p);\n    for(int i = 0; i < W; ++i) {\n      int s, t;\n      cin >> s >> t;\n      --s; --t;\n      G.insert(Edge({s, t, 1}));\n    }\n    auto D = G.dualgraph();\n    auto distance = D.Dijkstra(outside_color);\n    double answer = 0;\n    for(const auto& d: distance) answer = max(answer, d.second);\n    cout << answer << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <ctime>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <fstream>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <numeric>\n#include <cassert>\nusing namespace std;\n\ntypedef complex<double> P;\nconst double PI = acos(-1);\n\ndouble fx(double rd){\n\twhile( rd < -1e-9 )   rd += 2*PI;\n\twhile( rd >= 2*PI - 1e-9) rd -= 2*PI;\n\treturn rd;\n}\ndouble R(P a){\n\tdouble rd = atan2(a.imag(),a.real());\n\treturn fx(rd);\n}\n\nint C,W;\n\nint wsc[300] , wtc[300];\nP c[100];\nstruct NODE{\n\tint from,to,id;\n\tdouble rad;\n\tNODE(int from,int to,int id) : from(from) , to(to) , id(id) {\n\t\trad = R(c[to]-c[from]);\n\t}\n\tNODE(){}\n};\nbool operator < (const NODE &a,const NODE &b){\n\treturn a.rad < b.rad;\n}\nvector<NODE> geo[100];\nint done[100];\n\nint start;\nint get(int x,int prev,vector<int> &ad){\n\tif( x == start ) return 1;\n\tif( done[x] ) return 0;\n\telse done[x] = true;\n\t\n\tfor(int i = 0 ; i < geo[x].size() ; i++){\n\t\tint y = (i+1)%geo[x].size();\n\t\tif( geo[x][y].to == prev ){\t\t\t\n\t\t\tif( get(geo[x][i].to,x,ad) ){\n\t\t\t\t//ad.push_back(x);\n\t\t\t\tad.push_back(geo[x][i].id);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nnamespace std {bool operator < (const P& a, const P& b) {return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);} }\ndouble cross(const P& a, const P& b) {return imag(conj(a)*b);}\ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;\n\tif (cross(b, c) < 0)   return -1;\n\tif (dot(b, c) < 0) return +2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n// Totsuhou! Andrew's Monotone Chain //\nvector<P> convex_hull(vector<P> ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<P> ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);} };\nstatic const double EPS = 1e-9;\nbool intersectSP(const L &s, const P &p) {return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;}\n\ndouble intersect2SP(const L &s, const P &p) {\n\tcout << \"[\" << s[0] << \",\" << s[1] << \"]\" << \",\" << p << endl;\n\treturn abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]);\n}\n\n\nint main(){\n\twhile(cin >> C >> W && C){\n\t\tfor(int i = 0 ; i < 100 ; i++) geo[i].clear();\n\t\tfor(int i = 0 ; i < C ; i++)\n\t\t\tcin >> c[i].real() >> c[i].imag();\n\t\tfor(int i = 0 ; i < W ; i++){\n\t\t\tint s,t;\n\t\t\tcin >> s >> t;\n\t\t\ts--,t--;\n\t\t\tgeo[s].push_back(NODE(s,t,i));\n\t\t\tgeo[t].push_back(NODE(t,s,i));\n\t\t\twsc[i] = s;\n\t\t\twtc[i] = t;\n\t\t}\n\t\tfor(int i = 0 ; i < 100 ; i++) sort(geo[i].begin(),geo[i].end());\n\t\t\n\t\tvector< vector<int> > wallset;\n\t\tfor(int _ = 0 ; _ < 2 ; _++){\n\t\t\tfor(int i = 0 ; i < W ; i++){\n\t\t\t\tmemset(done,0,sizeof(done));\n\t\t\t\tstart = wsc[i];\n\t\t\t\tvector<int> a;\n\t\t\t\tif( get(wtc[i],wsc[i],a) ){\n\t\t\t\t\t//a.push_back(wsc[i]);\n\t\t\t\t\ta.push_back(i);\n\t\t\t\t\tsort(a.begin(),a.end());\n\t\t\t\t\twallset.push_back(a);\n\t\t\t\t}\n\t\t\t\tswap(wsc[i],wtc[i]);\n\t\t\t}\n\t\t}\n\t\tsort(wallset.begin(),wallset.end());\n\t\twallset.erase(unique(wallset.begin(),wallset.end()),wallset.end());\n\t\t\n\t\t\n\t\tint wf[301][301]={};\n\t\tfor(int i = 0 ; i < 301 ; i++)\n\t\t\tfor(int j = 0 ; j < 301 ; j++)\n\t\t\t\twf[i][j] = i==j?0:1e9;\n\t\tint N = wallset.size();\n\t\tvector<int> wall_share[300];\n\t\t\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\t//cout << \"[\" << i << \"]\" << endl;\n\t\t\tfor(int j = 0 ; j < wallset[i].size() ; j++){\n\t\t\t\twall_share[wallset[i][j]].push_back(i);\n\t\t\t//\tcout << c[wsc[wallset[i][j]]] << \"-\" << c[wtc[wallset[i][j]]] << \" \";\n\t\t\t}\n\t\t\t//cout << endl;\n\t\t}\n\t\tfor(int i = 0 ; i < W ; i++){\n\t\t\tfor(int j = 0 ; j <wall_share[i].size() ; j++){\n\t\t\t\tfor(int k = 0 ; k < wall_share[i].size() ; k++){\n\t\t\t\t\tif(j!=k)wf[wall_share[i][j]][wall_share[i][k]] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<P> p;\n\t\tfor(int i = 0 ; i < C ; i++) p.push_back(c[i]);\n\t\tp = convex_hull(p);\n\t\t//for(int i = 0 ; i < p.size() ; i++) cout << p[i] << \" \";\n\t\t//cout << endl;\n\t\tint soto = -1;\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\tint o = 1;\n\t\t\tfor(int j = 0 ; j < wallset[i].size() ; j++){\n\t\t\t\tint w = 0;\n\t\t\t\tfor(int k = 0 ; k < p.size() ; k++){\n\t\t\t\t\tif( intersectSP(L(p[k],p[(k+1)%p.size()]),c[wsc[wallset[i][j]]]) && intersectSP(L(p[k],p[(k+1)%p.size()]),c[wtc[wallset[i][j]]]) ){\n\t\t\t\t\t\t//cout << \"OK\" << endl;\n\t\t\t\t\t\tw = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!w){\n\t\t\t\t\to = 0;\n\t\t\t\t\t/*cout << \"----------\" << endl;\n\t\t\t\t\tcout << (intersectSP(L(P(2,0),P(8,0)),wsc[wall_share[i][j]]) ) << \" \" << (intersectSP(L(P(2,0),P(8,0)),wtc[wall_share[i][j]])) << endl;\n\t\t\t\t\tcout << (intersect2SP(L(P(2,0),P(8,0)),wsc[wall_share[i][j]]) ) << \" \" << (intersect2SP(L(P(2,0),P(8,0)),wtc[wall_share[i][j]])) << endl;\n\t\t\t\t\t\n\t\t\t\t\tcout << endl;\n\t\t\t\t\t*/\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(o) soto = i ;//, cout << soto << \"<\" << endl;\n\t\t}\n\t\twhile(soto==-1);\n\t\twhile(N>300);\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\tfor(int j = 0 ; j < N ; j++){\n\t\t\t\tfor(int k = 0 ; k < N ; k++){\n\t\t\t\t\twf[j][k] = min(wf[j][k],wf[j][i]+wf[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 1;\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\tans = max( ans , wf[i][soto] );\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <cmath>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\n#define x first\n#define y second\n\ntypedef pair<int,int> pii;\n\nint C, W;\nvector<pii> pole;\nvector<vector<int> > edge;\nvector<pii> edge_set;\n\nvector<vector<int> > face;\nvector<vector<int> > dual_e;\nvector<pii> dual_edge_set;\n\nvector<int> detect_f(int start, int cur, int prev) {\n\tvector<int> res;\n\tif(cur == start) {\n\t\tres.push_back(cur);\n\t\treturn res;\n\t}\n\n\tint bx, by, cx, cy;\n\tdouble mn = 10.0;\n\tint nx = -1;\n\tbx = pole[prev].x;\n\tby = pole[prev].y;\n\tcx = pole[cur].x;\n\tcy = pole[cur].y;\n\tfor(int i = 0; i < edge[cur].size(); i++) {\n\t\tif(edge[cur][i] != prev) {\n\t\t\tdouble theta, phi, ag;\n\t\t\tint ax, ay;\n\t\t\tax = pole[edge[cur][i]].x;\n\t\t\tay = pole[edge[cur][i]].y;\n\t\t\ttheta = atan2(by - cy, bx - cx);\n\t\t\tphi   = atan2(ay - cy, ax - cx);\n\t\t\tag = phi - theta + 4*M_PI;\n\t\t\twhile(ag > 2*M_PI) ag -= 2*M_PI;\n\t\t\tif(ag < mn) {\n\t\t\t\tnx = edge[cur][i];\n\t\t\t\tmn = ag;\n\t\t\t}\n\t\t}\n\t}\n\n\tres = detect_f(start, nx, cur);\n\tres.push_back(cur);\n\treturn res;\n}\n\nint face_indx(vector<int> f) {\n\tfor(int i = 0; i < face.size(); i++) {\n\t\tif(face[i].size() == f.size()) for(int j = 0; j < face[i].size(); j++) {\n\t\t\tbool flg = true;\n\t\t\tfor(int k = 0; k < face[i].size() && flg; k++) {\n\t\t\t\tflg &= face[i][(j+k)%face[i].size()] == f[k];\n\t\t\t}\n\t\t\tif(flg) return i;\n\t\t}\n\t}\n\treturn -1;\n}\n\nvoid mkdual() {\n\tfor(int i = 0; i < edge_set.size(); i++) {\n\t\tpii de, e = edge_set[i];\n\t\tfor(int i_ = 0; i_ < 2; i_++) {\n\t\t\tvector<int> f = detect_f(e.first, e.second, e.first);\n\t\t\tint indx;\n\t\t\tindx = face_indx(f);\n\t\t\tif(indx < 0) {\n\t\t\t\tindx = face.size();\n\t\t\t\tface.push_back(f);\n\t\t\t}\n\t\t\tde.first = indx;\n\t\t\tswap(e.first, e.second);\n\t\t\tswap(de.first, de.second);\n\t\t}\n\t\tdual_edge_set.push_back(de);\n\t}\n\tdual_e.resize(face.size());\n\tsort(dual_edge_set.begin(), dual_edge_set.end());\n\tdual_edge_set.erase(unique(dual_edge_set.begin(), dual_edge_set.end()), dual_edge_set.end());\n\tfor(int i = 0; i < dual_edge_set.size(); i++) {\n\t\tdual_e[dual_edge_set[i].first].push_back(dual_edge_set[i].second);\n\t\tdual_e[dual_edge_set[i].second].push_back(dual_edge_set[i].first);\n\t}\n}\n\nint solve() {\n\tint ur = 0;\n\tfor(int i = 0; i < pole.size(); i++) {\n\t\tif(pole[ur] < pole[i])\n\t\t\tur = i;\n\t}\n\tint nx = -1;\n\tdouble mx_arg = -1;\n\tfor(int i = 0; i < edge[ur].size(); i++) {\n\t\tdouble arg;\n\t\targ = atan2(pole[edge[ur][i]].y - pole[ur].y,\n\t\t\t\tpole[edge[ur][i]].x - pole[ur].x) - M_PI / 2.0 + 4 * M_PI;\n\t\twhile(arg > 2 * M_PI) arg -= 2 * M_PI;\n\t\t\n\t\tif(arg > mx_arg) {\n\t\t\tmx_arg = arg;\n\t\t\tnx = edge[ur][i];\n\t\t}\n\t}\n\tint start;\n\tvector<int> mnpath;\n\tpriority_queue<pii> q;\n\tconst int INF = 1e9;\n\tstart = face_indx(detect_f(ur, nx, ur));\n\tmnpath.resize(face.size());\n\tfor(int i = 0; i < mnpath.size(); i++) mnpath[i] = INF;\n\tq.push(pii(0,start));\n\twhile(!q.empty()) {\n\t\tpii a = q.top(); q.pop();\n\t\tif(mnpath[a.second] > -a.first) {\n\t\t\tmnpath[a.second] = -a.first;\n\t\t}\n\t\tfor(int i = 0; i < dual_e[a.second].size(); i++) {\n\t\t\tif(mnpath[dual_e[a.second][i]] > -a.first + 1) {\n\t\t\t\tmnpath[dual_e[a.second][i]] = -a.first + 1;\n\t\t\t\tq.push(pii(a.first -1, dual_e[a.second][i]));\n\t\t\t}\n\t\t}\n\t}\n\tint res = -1;\n\tfor(int i = 0; i < mnpath.size(); i++) {\n\t\tres = max(res, mnpath[i]);\n\t}\n\treturn res;\n}\n\nint main() {\n\twhile(cin >> C >> W, C || W) {\n\t\tpole.clear();\n\t\tedge.clear();\n\t\tedge_set.clear();\n\t\tface.clear();\n\t\tdual_edge_set.clear();\n\t\tdual_e.clear();\n\t\tpole.resize(C);\n\t\tedge.resize(C);\n\t\tfor(int i = 0; i < pole.size(); i++) {\n\t\t\tcin >> pole[i].x >> pole[i].y;\n\t\t}\n\t\tfor(int i = 0; i < W; i++) {\n\t\t\tint a, b;\n\t\t\tcin >> a >> b; a--; b--;\n\t\t\tedge_set.push_back(pii(a,b));\n\t\t\tedge[a].push_back(b);\n\t\t\tedge[b].push_back(a);\n\t\t}\n\t\tmkdual();\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<int,pair<bool,double>> P2;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define min_3(a,b,c) min(a,min(b,c))\n#define max_3(a,b,c) max(a,max(b,c))\n#define mp1(a,b,c) P1(a,P(b,c))\n#define mp2(a,b,c) P2(a,pair<bool,double>(b,c))\n#define pque(a) priority_queue<a>\n#define rpque(a) priority_queue<a,vector<a>,greater<a>>\n\nconst int INF=1000000000;\nconst int dre_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dre_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\nconst int kaijou[10]={1,1,2,6,24,120,720,5040,40320,362880};\n\nbool com(P2 x,P2 y){\n\tif(x.sc.fr!=y.sc.fr)return x.sc.fr;\n\treturn x.sc.sc>=y.sc.sc;\n}\n\nint main(){\n\twhile(1){\n\t\tint c,w;\n\t\tint x[110],y[110];\n\t\tint s,t;\n\t\t\n\t\tscanf(\"%d%d\",&c,&w); if(c==0&&w==0)break;\n\t\trep1(i,c)scanf(\"%d%d\",&x[i],&y[i]);\n\t\t\n\t\tvector<P1> V_;\n\t\trep1(i,c){\n\t\t\tV_.pb(mp1(x[i],y[i],i));\n\t\t}\n\t\tsor(V_);\n\t\tvector<P2> vec_[110];\n\t\trep1(i,c){\n\t\t\tvec_[i].pb(mp2(0,false,-INF));\n\t\t\trep1(j,c){\n\t\t\t\tif(i==j)continue;\n\t\t\t\tif(x[i]<x[j]){\n\t\t\t\t\tvec_[i].pb(mp2(j,true,(double)(y[j]-y[i])/(x[j]-x[i])));\n\t\t\t\t}\n\t\t\t\telse if(x[i]>x[j]){\n\t\t\t\t\tvec_[i].pb(mp2(j,false,(double)(y[j]-y[i])/(x[j]-x[i])));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(y[j]>y[i])vec_[i].pb(mp2(j,true,(double)INF));\n\t\t\t\t\telse vec_[i].pb(mp2(j,true,(double)-INF));\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(vec_[i].begin(),vec_[i].end(),com);\n\t\t}\n\t\t\n\t\tint v,e;\n\t\tvector<int> V;\n\t\tbool edge[110][110];\n\t\tvector<int> vec[110];\n\t\t\n\t\tv=c; e=w;\n\t\trep(i,c)V.pb(V_[i].sc.sc);\n\t\trep(i,110)rep(j,110)edge[i][j]=false;\n\t\trep(i,e){\n\t\t\tscanf(\"%d%d\",&s,&t);\n\t\t\tedge[s][t]=true;\n\t\t\tedge[t][s]=true;\n\t\t}\n\t\trep1(i,c){\n\t\t\trep(j,vec_[i].size()){\n\t\t\t\tvec[i].pb(vec_[i][j].fr);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ret=0;\n\t\twhile(e>0){\n\t\t\tret++;\n\t\t\t\n\t\t\tint a=-1;\n\t\t\trep(i,V.size()){\n\t\t\t\trep(j,105){\n\t\t\t\t\tif(edge[V[i]][j]){a=V[i]; break;}\n\t\t\t\t}\n\t\t\t\tif(a!=-1)break;\n\t\t\t}\n\t\t\t\n\t\t\tint b=0,c=a;\n\t\t\twhile(1){\n\t\t\t\trep(i,vec[c].size()){\n\t\t\t\t\tif(vec[c][i]==b){\n\t\t\t\t\t\ti++; i%=vec[c].size();\n\t\t\t\t\t\twhile(!edge[c][vec[c][i]]){\n\t\t\t\t\t\t\ti++; i%=vec[c].size();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tedge[c][vec[c][i]]=false;\n\t\t\t\t\t\tedge[vec[c][i]][c]=false;\n\t\t\t\t\t\te--;\n\t\t\t\t\t\tb=c;\n\t\t\t\t\t\tc=vec[c][i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(c==a)break;\n\t\t\t}\n\t\t\t\n\t\t\tbool updata=true;\n\t\t\twhile(updata){\n\t\t\t\tupdata=false;\n\t\t\t\trep(i,105){\n\t\t\t\t\tint cnt=0;\n\t\t\t\t\tint t=-1;\n\t\t\t\t\trep(j,105){\n\t\t\t\t\t\tif(edge[i][j]){cnt++; t=j;}\n\t\t\t\t\t}\n\t\t\t\t\tif(cnt==1){\n\t\t\t\t\t\tupdata=true;\n\t\t\t\t\t\tedge[i][t]=false;\n\t\t\t\t\t\tedge[t][i]=false;\n\t\t\t\t\t\te--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\n \nconst double INF = 1e12;\ntypedef complex<double> P,point;\ntypedef vector<P> G,polygon;\nnamespace std {bool operator < (const P& a, const P& b) {return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);} }\ndouble cross(const P& a, const P& b) {return imag(conj(a)*b);}\ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);} };\nstruct C {P p; double r;C(const P &p, double r) : p(p), r(r) { } C(){} };\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;\n\tif (cross(b, c) < 0)   return -1;\n\tif (dot(b, c) < 0) return +2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\nvector<point> convex_hull(vector<point> ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<point> ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\nenum { OUT, ON, IN };\nint contains(const polygon& P, const point& p) {\n  bool in = false;\n  for (int i = 0; i < P.size(); ++i) {\n    point a = curr(P,i) - p, b = next(P,i) - p;\n    if (imag(a) > imag(b)) swap(a, b);\n    if (imag(a) <= 0 && 0 < imag(b))\n      if (cross(a, b) < 0) in = !in;\n    if (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n\ndouble calc(P a,P b){\n\tb -= a;\n\treturn atan2(b.imag(),b.real());\n}\n\nvoid erase(vector<P> &g,P b){ g.erase(remove(g.begin(),g.end(),b),g.end()); }\nint main(){\n\tint C,W;\n\twhile(cin >> C >> W && C){\n\t\tvector<P> p(C);\n\t\tfor(int i = 0 ; i < C ; i++) cin >> p[i].real() >> p[i].imag();\n\t\tmap< P,vector<P> > g;\n\t\tvector< pair<P,P> > e;\n\t\tfor(int i = 0 ; i < W ; i++){\n\t\t\tint a,b;\n\t\t\tcin >> a >> b;\n\t\t\ta--,b--;\n\t\t\tg[p[a]].push_back(p[b]);\n\t\t\tg[p[b]].push_back(p[a]);\n\t\t\te.push_back(make_pair(p[a],p[b]));\n\t\t\te.push_back(make_pair(p[b],p[a]));\n\t\t}\n\t\tvector< vector<P> > wall;\n\t\tset< vector<P> > already;\n\t\t\n\t\tfor(int j = 0 ; j < e.size() ; j++){\n\t\t\tP A = e[j].first;\n\t\t\tP B = e[j].second;\n\t\t\tvector<P> chain;\n\t\t\tchain.push_back(A);\n\t\t\tint fail = 0;\n\t\t\tdo{\n\t\t\t\tchain.push_back(B);\n\t\t\t\tvector< pair<double,P> > pos;\n\t\t\t\tfor(int i = 0 ; i < g[B].size() ; i++){\n\t\t\t\t\tif( g[B][i] != A && cross(B-A,g[B][i]-A) > 0 ){\n\t\t\t\t\t\tP s = A-B;\n\t\t\t\t\t\tP t = g[B][i]-B;\n\t\t\t\t\t\tdouble tmp = acos(dot(s,t) / abs(s) / abs(t));\n\t\t\t\t\t\tpos.push_back(make_pair(tmp,g[B][i]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsort(pos.begin(),pos.end());\n\t\t\t\tif( pos.size() == 0 ){ fail = 1; break; }\n\t\t\t\tA = pos[0].second;\n\t\t\t\tswap(A,B);\n\t\t\t}while( B != e[j].first );\n\t\t\tif( fail ) continue;\n\t\t\tvector<P> key = chain;\n\t\t\tsort(key.begin(),key.end());\n\t\t\tif( !already.count(key) ){\n\t\t\t\twall.push_back(chain);\n\t\t\t\talready.insert(key);\n\t\t\t\t//for(int i = 0 ; i < chain.size() ; i++) cout << chain[i] << \" \"; cout << endl;\n\t\t\t}\n\t\t}\n\t\tvector< vector<int> > wf(wall.size()+1,vector<int>(wall.size()+1));\n\t\tfor(int i = 0 ; i < wf.size() ; i++)\n\t\t\tfor(int j = 0 ; j < wf.size() ; j++)\n\t\t\t\twf[i][j] = i != j ? 1e9 : 0;\n\t\tset< pair<P,P> > usedEdge;\n\t\tfor(int i = 0 ; i < wall.size() ; i++){\n\t\t\tfor(int j = 0 ; j < wall.size() ; j++){\n\t\t\t\tif( i != j ) {\n\t\t\t\t\tset< pair<P,P> > tmp;\n\t\t\t\t\tfor(int k = 0 ; k < wall[i].size() ; k++){\n\t\t\t\t\t\tP a = wall[i][k] , b = wall[i][(k+1)%wall[i].size()];\n\t\t\t\t\t\tif( b < a ) swap(a,b);\n\t\t\t\t\t\ttmp.insert(make_pair(a,b));\n\t\t\t\t\t}\n\t\t\t\t\tint connect = 0;\n\t\t\t\t\tfor(int k = 0 ; k < wall[j].size() ; k++){\n\t\t\t\t\t\tP a = wall[j][k] , b = wall[j][(k+1)%wall[j].size()];\n\t\t\t\t\t\tif( b < a ) swap(a,b);\n\t\t\t\t\t\tif( tmp.count( make_pair(a,b) ) ){\n\t\t\t\t\t\t\tconnect = 1;\n\t\t\t\t\t\t\tusedEdge.insert(make_pair(a,b));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif( connect ) wf[i][j] = wf[j][i] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0 ; i < wall.size() ; i++){\n\t\t\tint connectOutside = 0;\n\t\t\tfor(int k = 0 ; k < wall[i].size() ; k++){\n\t\t\t\tP a = wall[i][k] , b = wall[i][(k+1)%wall[i].size()];\n\t\t\t\tif( b < a ) swap(a,b);\n\t\t\t\tif( !usedEdge.count( make_pair(a,b) ) ) connectOutside = 1;\n\t\t\t}\n\t\t\tif(connectOutside)wf[wall.size()][i] = wf[i][wall.size()] = 1;\n\t\t}\n\t\tfor(int i = 0 ; i < wf.size() ; i++)\n\t\t\tfor(int j = 0 ; j < wf.size() ; j++)\n\t\t\t\tfor(int k = 0 ; k < wf.size() ; k++)\n\t\t\t\t\twf[j][k] = min(wf[j][k],wf[j][i]+wf[i][k]);\n\t\tint res = -1e9;\n\t\tfor(int i = 0 ; i < wall.size() ; i++)\n\t\t\tres = max(res,wf[wall.size()][i]);\n\t\tcout << res << endl;\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <unordered_map>\n#include <iterator>\n#include <assert.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nnamespace geom{\n#define X real()\n#define Y imag()\n#define at(i) ((*this)[i])\n#define SELF (*this)\n\tenum {TRUE = 1, FALSE = 0, BORDER = -1};\n\ttypedef int BOOL;\n\ttypedef double R;\n\tconst R INF = 1e8;\n\tconst R EPS = 1e-12;\n\tconst R PI = 3.1415926535897932384626;\n\tinline int sig(const R &x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n\tinline BOOL less(const R &x, const R &y) {return sig(x-y) ? x < y : BORDER;}\n\ttypedef complex<R> P;\n\tinline R norm(const P &p){return p.X*p.X+p.Y*p.Y;}\n\tinline R inp(const P& a, const P& b){return (conj(a)*b).X;}\n\tinline R outp(const P& a, const P& b){return (conj(a)*b).Y;}\n\tinline P unit(const P& p){return p/abs(p);}\n\tinline P proj(const P &s, const P &t){return t*inp(s, t)/norm(t);}\n\tinline int ccw(const P &s, const P &t, const P &p, int adv=0){\n\t\tint res = sig(outp(t-s, p-s));\n\t\tif(res || !adv) return res;\n\t\tif(sig(inp(t-s, p-s)) < 0) return -2;\t// p-s-t\n\t\tif(sig(inp(s-t, p-t)) < 0) return 2;\t// s-t-p\n\t\treturn 0;\t\t\t\t\t\t\t\t// s-p-t\n\t}\n\t\n\t\n\tstruct L : public vector<P>{\t// line\n\t\tL(const P &p1, const P &p2){this->push_back(p1);this->push_back(p2);}\n\t\tL(){}\n\t\tP dir()const {return at(1) - at(0);}\n\t\tBOOL online(const P &p)const {return !sig(outp(p-at(0), dir()));}\n\t};\n\tstruct S : public L{\t// segment\n\t\tS(const P &p1, const P &p2):L(p1, p2){}\n\t\tS(){}\n\t\tBOOL online(const P &p)const {\n\t\t\tif(!sig(norm(p - at(0))) || !sig(norm(p - at(1)))) return BORDER;\n\t\t\treturn !sig(abs(at(0)-p) + abs(at(1) - p) - abs(at(0) - at(1)));\n\t\t}\n\t};\n\tstruct C : public P{\n\t\tR r;\n\t\tBOOL inside(const P& p)const { return less(norm(p-SELF), r*r);}\n\t};\n\tP crosspoint(const L &l, const L &m);\n\tstruct G : public vector<P>{\n\t\tG(size_type size=0):vector(size){}\n\t\tS edge(int i)const {return S(at(i), at(i+1 == size() ? 0 : i+1));}\n\t\tBOOL contains(const P &p)const {\n\t\t\tR sum = .0;\n\t\t\tREP(i, size()){\n\t\t\t\tif(S(at(i), at((i+1)%size())).online(p)) return BORDER;\t// online\n\t\t\t\tsum += arg((at(i) - p) / (at((i+1)%size()) - p));\n\t\t\t}\n\t\t\treturn !!sig(sum);\n\t\t}\n\t\tR area()const {\n\t\t\tR sum = 0;\n\t\t\tREP(i, size()) sum += outp(at(i), at((i+1)%size()));\n\t\t\treturn abs(sum / 2.);\n\t\t}\n\t\t\n\t\tG convex_hull(bool online = false) {\n\t\t\tif(size() < 2) return *this;\n\t\t\tsort(ALL(*this));\n\t\t\tG r;\n\t\t\tr.resize((int)size()*2);\n\t\t\tint k=0;\n\t\t\tfor(int i=0;i<size();r[k++]=at(i++))\n\t\t\t\twhile(k>1 && ccw(r[k-2], r[k-1], at(i)) < 1-online) k--;\n\t\t\tint t = k;\n\t\t\tfor(int i=(int)size()-1;i>=0;r[k++]=at(i--))\n\t\t\t\twhile(k>t && ccw(r[k-2], r[k-1], at(i)) < 1-online) k--;\n\t\t\tr.resize(k-1);\n\t\t\treturn r;\n\t\t}\n\t\tG cut(const L &l)const {\n\t\t\tG g;\n\t\t\tREP(i, size()){\n\t\t\t\tconst S &s = edge(i);\n\t\t\t\tif(ccw(l[0], l[1], s[0], 0) >= 0) g.push_back(s[0]);\n\t\t\t\tif(ccw(l[0], l[1], s[0], 0) * ccw(l[0], l[1], s[1], 0) < 0)\n\t\t\t\t\tg.push_back(crosspoint(s, l));\n\t\t\t}\n\t\t\treturn g;\n\t\t}\n\t\tG Voronoi(const vector<P> &p, const int t)const {\n\t\t\tG g = *this;\n\t\t\tREP(i, p.size())if(i!=t){\n\t\t\t\tconst P m = (p[t]+p[i])*0.5;\n\t\t\t\tg = g.cut(L(m, m+(p[i]-p[t])*P(0, 1)));\n\t\t\t}\n\t\t\treturn g;\n\t\t}\n\t};\n\n\tinline P proj(const P &s, const L &t){return t[0] + proj(s-t[0], t[1]-t[0]);}\n\tBOOL intersect(const S &s, const S &t){\n\t\tconst int p = ccw(t[0], t[1], s[0], 1) * ccw(t[0], t[1], s[1], 1);\n\t\tconst int q = ccw(s[0], s[1], t[0], 1) * ccw(s[0], s[1], t[1], 1);\n\t\treturn (p>0||q>0) ? FALSE : (!p||!q) ? BORDER : TRUE;\n\t}\n\tBOOL intersect(const S &s, const L &l){\n\t\tif(l.online(s[0]) || l.online(s[1])) return BORDER;\n\t\treturn (sig(outp(l.dir(), s[0]-l[0])) * sig(outp(l.dir(), s[1]-l[0])) <= 0);\n\t}\n\tR dist2(const L &l, const P &p){return norm(outp(l.dir(), p - l[0])) / norm(l.dir());}\n\tR dist2(const S &s, const P &p){\n\t\tif(inp(p-s[0],  s.dir()) < EPS) return norm(p - s[0]);\n\t\tif(inp(p-s[1], -s.dir()) < EPS) return norm(p - s[1]);\n\t\treturn dist2((const L &)s, p);\n\t}\n\tR dist2(const S &s, const L &l){\n\t\treturn intersect(s, l) ? .0 : min(dist2(l, s[0]), dist2(l, s[1]));\n\t}\n\tR dist2(const S &s, const S &t){\n\t\treturn intersect(s, t) ? .0 : min(min(dist2(s, t[0]), dist2(t, s[0])), \n\t\t\t\t\t\t\t\t\t   \t  min(dist2(s, t[1]), dist2(t, s[1])));\n\t}\n\ttemplate <class T> R dist2(const G &g, const T& t){ // todo: 内部に完全に含まれる場合\n\t\tR res = INF;\n\t\tREP(i, g.size()) res = min(res, dist2(g.edge(i), t));\n\t\treturn res;\n\t}\n\ttemplate<class S, class T> R dist(const S& s, const T& t){return sqrt(dist2(s, t));}\n\tinline BOOL intersect(const C &a, const C &b){\n\t\treturn less((a.r-b.r)*(a.r-b.r), norm(a-b)) + less(norm(a-b), (a.r+b.r)*(a.r+b.r)) - 1;\n\t}\n\tinline BOOL intersect(const C &c, const L &l){\n\t\treturn less(dist2(l, c), c.r*c.r);\n\t}\n\tinline BOOL intersect(const C &c, const S &s){\n\t\tint d = less(dist2(s, c), c.r*c.r);\n\t\tif(d != TRUE) return d;\n\t\tint p = c.inside(s[0]), q = c.inside(s[1]);\n\t\treturn (p<0 || q<0) ? BORDER : p&q;\n\t}\n\tinline S crosspoint(const C &c1, const C &c2){\n\t\tif(!intersect(c1, c2)) return S();\n\t\tR d = abs(c1 - c2);\n\t\tR x = (c1.r*c1.r - c2.r*c2.r + d*d) / (2*d);\n\t\tR h = sqrt(c1.r*c1.r - x*x);\n\t\tP u = unit(c2-c1);\n\t\treturn S(c1 + u*x + u*P(0,1)*h, c1 + u*x + u*P(0,-1)*h);\n\t}\n\tinline P crosspoint(const L &l, const L &m){\n\t\tR A = outp(l.dir(), m.dir()), B = outp(l.dir(), l[1] - m[0]);\n\t\tif(!sig(abs(A)) && !sig(abs(B))) return m[0]; // same line\n\t\tif(abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n\t\treturn m[0] + B / A * (m[1] - m[0]);\n\t}\n\tinline R commonarea(const C &a, const C &b){\n\t\tif(less(norm(a-b), (a.r-b.r)*(a.r-b.r)) == TRUE) return min(a.r*a.r, b.r*b.r)*PI;\n\t\tif(less((a.r+b.r)*(a.r+b.r), norm(a-b)) == TRUE) return .0;\n\t\tdouble d = abs(a-b);\n\t\tdouble rc = (d*d + a.r*a.r - b.r*b.r) / (2*d);\n\t\tdouble theta = acos(rc / a.r);\n\t\tdouble phi = acos((d - rc) / b.r);\n\t\treturn a.r*a.r*theta + b.r*b.r*phi - d*a.r*sin(theta);\n\t}\n\tstruct Arrangement{\n\t\tstruct AEdge{\n\t\t\tint u, v, t;\n\t\t\tR cost;\n\t\t\tAEdge(int u=0, int v=0, int t=0, R cost=0)\n\t\t\t\t:u(u), v(v), t(t), cost(cost){}\n\t\t};\n\t\ttypedef vector<vector<AEdge>> AGraph;\n\t\tvector<P> p;\n\t\tAGraph g;\n\t\tArrangement(){}\n\t\tArrangement(vector<S> seg){\n\t\t\tint m = seg.size();\n\t\t\tREP(i, m){\n\t\t\t\tp.push_back(seg[i][0]);\n\t\t\t\tp.push_back(seg[i][1]);\n\t\t\t\tREP(j, i) if(sig(outp(seg[i].dir(), seg[j].dir())) && intersect(seg[i], seg[j]) == TRUE)\n\t\t\t\t\tp.push_back(crosspoint(seg[i], seg[j]));\n\t\t\t}\n\t\t\tsort(ALL(p)); UNIQUE(p);\n\t\t\tint n=p.size();\n\t\t\tg.resize(n);\n\t\t\tREP(i, m){\n\t\t\t\tS &s = seg[i];\n\t\t\t\tvector<pair<R, int>> ps;\n\t\t\t\tREP(j, n) if(s.online(p[j])) ps.emplace_back(norm(p[j] - s[0]), j);\n\t\t\t\tsort(ALL(ps));\n\t\t\t\tREP(j, (int)ps.size()-1){\n\t\t\t\t\tconst int u=ps[j].second;\n\t\t\t\t\tconst int v=ps[j+1].second;\n\t\t\t\t\tg[u].emplace_back(u, v, 0, abs(p[u] - p[v]));\n\t\t\t\t\tg[v].emplace_back(v, u, 0, abs(p[u] - p[v]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint getIdx(P q){\n\t\t\tauto it = lower_bound(ALL(p), q);\n\t\t\tif(it == p.end() || *it != q) return -1;\n\t\t\treturn it - p.begin();\n\t\t}\n\t};\n\n\tstruct min_ball {\n\t\tP center;\n\t\tR radius2;\n\t\tmin_ball(const vector<P>& p) {\n\t\t\tFOR(it, p) ps.push_back(*it);\n\t\t}\n\t\tmin_ball& compile() {\n\t\t\tm = 0;\n\t\t\tcenter = P(0, 0);\n\t\t\tradius2 = -1;\n\t\t\tmake_ball(ps.end());\n\t\t\treturn *this;\n\t\t}\n\tprivate:\n\t\tlist<P> ps;\n\t\tlist<P>::iterator supp_end;\n\t\tint m;\n\t\tP v[3], c[3];\n\t\tR z[3], r[3];\n\t\tvoid pop() { --m; }\n\t\tvoid push(const P& p) {\n\t\t\tif (m == 0) {\n\t\t\t\tc[0] = p; r[0] = 0;\n\t\t\t} else {\n\t\t\t\tR e = norm(p-c[m-1]) - r[m-1];\n\t\t\t\tP delta = p - c[0];\n\t\t\t\tv[m] = p - c[0];\n\t\t\t\tfor (int i = 1; i < m; ++i)\n\t\t\t\t\tv[m] -= v[i] * inp(v[i], delta) / z[i];\n\t\t\t\tz[m] = inp(v[m], v[m]);\n\t\t\t\tc[m] = c[m-1] + e*v[m]/z[m]*.5;\n\t\t\t\tr[m] = r[m-1] + e*e/z[m]*.25;\n\t\t\t}\n\t\t\tcenter\t= c[m];\n\t\t\tradius2 = r[m]; ++m;\n\t\t}\n\t\tvoid make_ball(list<P>::iterator i) {\n\t\t\tsupp_end = ps.begin();\n\t\t\tif (m == 3) return;\n\t\t\tfor (list<P>::iterator k = ps.begin(); k != i; ) {\n\t\t\t\tlist<P>::iterator j = k++;\n\t\t\t\tif (norm(*j-center) > radius2) {\n\t\t\t\t\tpush(*j); make_ball(j); pop();\n\t\t\t\t\tmove_to_front(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvoid move_to_front(list<P>::iterator j) {\n\t\t\tif (supp_end == j) ++supp_end;\n\t\t\tps.splice (ps.begin(), ps, j);\n\t\t}\n\t};\n\t\n\tstruct DualGraph{\n\t\tstruct DEdge{\n\t\t\tint u, v, f, l;\n\t\t\tR a;\n\t\t\tDEdge(int u, int v, R a):u(u),v(v),f(0),l(0){\n\t\t\t\twhile(PI < a) a -= 2*PI;\n\t\t\t\twhile(a < -PI) a += 2*PI;\n\t\t\t\tthis->a = a;\n\t\t\t}\n\t\t\tbool operator<(const DEdge &opp) const{\n\t\t\t\treturn a>opp.a;\n\t\t\t}\n\t\t\tbool operator<(const R &opp) const{\n\t\t\t\treturn a>opp;\n\t\t\t}\n\t\t\tfriend ostream& operator<<(ostream &os, const DEdge &t) { return os<<\"(\"<<t.u<<\",\"<<t.v<<\",\"<<t.a*180/PI<<\")\";}\n\t\t};\n\t\t\n\t\tint n;\n\t\tvector<P> p;\n\t\tvector<vector<DEdge>> g;\n\t\tDualGraph(const vector<P> &p):p(p),g(p.size()),n(p.size()){}\n\t\tvoid add_edge(int s, int t){\n\t\t\tR a = arg(p[t]-p[s]);\n\t\t\tg[s].emplace_back(s, t, a);\n\t\t\tg[t].emplace_back(t, s, a+PI);\n\t\t}\n\t\tvector<G> poly;\n\t\t\n\t\tvoid add_polygon(int s, int t, R a){\n\t\t\tauto e = lower_bound(ALL(g[s]), a-EPS);\n\t\t\tif(e == g[s].end()) e = g[s].begin();\n\t\t\tif(e->f) return;\n\t\t\te->f = 1;\n\t\t\te->l = t;\n\t\t\tpoly[t].push_back(p[s]);\n\t\t\tadd_polygon(e->v, t, e->a > 0 ? e->a-PI : e->a+PI);\n\t\t}\n\t\t\n\t\tvector<vi> dual(){\n\t\t\tREP(i, n){\n\t\t\t\tsort(ALL(g[i]));\n\t\t\t}\n\t\t\tint s = min_element(ALL(p)) - p.begin();\n\t\t\tpoly.emplace_back();\n\t\t\tadd_polygon(s, poly.size()-1, -PI*.5);\n\t\t\tREP(i, n)REP(j, g[i].size())if(!g[i][j].f){\n\t\t\t\tpoly.emplace_back();\n\t\t\t\tadd_polygon(i, poly.size()-1, g[i][j].a+EPS);\n\t\t\t}\n\t\t\tint m = poly.size();\n\t\t\tvector<vi> dg(m, vi(m, 1<<20));\n\t\t\tREP(i, m) dg[i][i] = 0;\n\t\t\tvector<unordered_map<int, int>> rev(n);\n\t\t\tREP(i, n)REP(j, g[i].size()){\n\t\t\t\tint u = i, v = g[i][j].v, l = g[i][j].l;\n\t\t\t\tif(u>v) swap(u, v);\n\t\t\t\tif(rev[u].find(v) != rev[u].end()){\n\t\t\t\t\tdg[l][rev[u][v]] = dg[rev[u][v]][l] = 1;\n\t\t\t\t}\n\t\t\t\telse rev[u][v] = l;\n\t\t\t}\n\t\t\treturn dg;\n\t\t}\n\t};\n#undef SELF\n#undef at\n}\n\nusing namespace geom;\n\nnamespace std{\n\tbool operator<(const P &a, const P &b){return sig(a.X-b.X) ? a.X < b.X : a.Y < b.Y;}\n\tbool operator==(const P &a, const P &b){return !sig(norm(a-b));}\n\tistream& operator>>(istream &is, P &p){R x,y;is>>x>>y;p=P(x, y);return is;}\n\tistream& operator>>(istream &is, L &l){l.resize(2);return is >> l[0] >> l[1];}\n\tistream& operator>>(istream &is, C &c){return is >> (P &)c >> c.r;}\n}\n\nint n, m;\n\nint main(){\n\tios::sync_with_stdio(false);\n\twhile(cin >> n >> m, n){\n\t\tvector<P> p(n);\n\t\tREP(i, n) cin >> p[i];\n\t\tDualGraph dg(p);\n\t\tREP(i, m){\n\t\t\tint u, v;\n\t\t\tcin >> u >> v;u--;v--;\n\t\t\tdg.add_edge(u, v);\n\t\t}\n\t\tvector<vi> g = dg.dual();\n\t\tn = g.size();\n\t\tREP(k, n)REP(i, n)REP(j, n) g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n\t\tcout << *max_element(ALL(g[0])) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "int leftmost;\nint outside_color;\n\n// Library.\n#include<cassert>\n#include<map>\n#include<vector>\n#include<cmath>\n#include<queue>\n#include<algorithm>\n// Type.\ntypedef int Label;\ntypedef double Weight;\n// Class.\ntemplate<typename Vertex, typename Edge>\nclass PlaneGraph {\npublic:\n  void insert(const Vertex& v);\n  void insert(Edge e);\n  const PlaneGraph<Vertex, Edge> dualgraph() const;\n  const std::map<Label, Weight> Dijkstra(const Label& start) const;\nprivate:\n  void dualgraph_color(std::map<Label, std::map<Label, int>>& color, int c, const Edge& e, const std::map<Label, std::vector<Edge>>& edge) const;\n  std::map<Label, Vertex> V;\n  std::map<Label, std::vector<Edge>> E;\n};\n// Implement.\ntemplate<typename Vertex, typename Edge>\nvoid PlaneGraph<Vertex, Edge>::insert(const Vertex& v) {\n  V[v.label] = v;\n}\ntemplate<typename Vertex, typename Edge>\nvoid PlaneGraph<Vertex, Edge>::insert(Edge e) {\n  assert(V.find(e.from) != std::end(V));\n  assert(V.find(e.to) != std::end(V));\n  E[e.from].push_back(e);\n  std::swap(e.from, e.to);\n  E[e.from].push_back(e);\n}\ntemplate<typename Vertex, typename Edge>\nconst PlaneGraph<Vertex, Edge> PlaneGraph<Vertex, Edge>::dualgraph() const {\n  // Sort edges counterclockwise.\n  auto edge = E;\n  for(auto& list: edge) if(!list.second.empty()) {\n    std::sort(std::begin(list.second), std::end(list.second), [&](const Edge& lhs, const Edge& rhs) {\n      double l = std::atan2(V.at(lhs.to).y - V.at(lhs.from).y, V.at(lhs.to).x - V.at(lhs.from).x);\n      double r = std::atan2(V.at(rhs.to).y - V.at(rhs.from).y, V.at(rhs.to).x - V.at(rhs.from).x);\n      return l < r;\n    });\n    list.second.push_back(list.second.front());\n  }\n  // Color edges.\n  std::map<Label, std::map<Label, int>> color;\n  int c = 1;\n  for(const auto& list: edge) {\n    for(const auto& e: list.second) if(!color[e.from].count(e.to)) dualgraph_color(color, c++, e, edge);\n    if(list.first == leftmost) outside_color = color[list.second.front().from][list.second.front().to];\n  }\n  // Construct the dualgraph.\n  PlaneGraph<Vertex, Edge> result;\n  std::vector<std::vector<bool>> used(c, std::vector<bool>(c, false));\n  for(int i = 1; i < c; ++i) result.insert(Vertex({i}));\n  for(const auto& list: E) for(const auto& e: list.second) if(!used[color[e.from][e.to]][color[e.to][e.from]]) {\n    used[color[e.from][e.to]][color[e.to][e.from]] = true;\n    used[color[e.to][e.from]][color[e.from][e.to]] = true;\n    result.insert(Edge({color[e.from][e.to], color[e.to][e.from], 1}));\n  }\n  return result;\n}\ntemplate<typename Vertex, typename Edge>\nvoid PlaneGraph<Vertex, Edge>::dualgraph_color(std::map<Label, std::map<Label, int>>& color, int c, const Edge& e, const std::map<Label, std::vector<Edge>>& edge) const {\n  color[e.from][e.to] = c;\n  for(auto it = edge.at(e.to).rbegin(); it != edge.at(e.to).rend(); ++it) if(it->to == e.from) {\n    ++it;\n    if(!color[it->from].count(it->to)) dualgraph_color(color, c, *it, edge);\n    break;\n  }\n}\ntemplate<typename Vertex, typename Edge>\nconst std::map<Label, Weight> PlaneGraph<Vertex, Edge>::Dijkstra(const Label& start) const {\n  std::map<Label, Weight> result;\n  std::priority_queue<Edge, std::vector<Edge>, std::function<bool(Edge, Edge)>> q([](Edge lhs, Edge rhs) {\n    return lhs.weight >= rhs.weight;\n  });\n  q.push(Edge({start, start, 0}));\n  while(!q.empty()) {\n    auto cur = q.top();\n    q.pop();\n    result[cur.to] = cur.weight;\n    for(const auto& nex: E.at(cur.to)) if(!result.count(nex.to)) q.push(Edge({nex.from, nex.to, cur.weight + nex.weight}));\n  }\n  return result;\n}\n////////////////////////////////////////\n// Configuration.\nstruct Vertex {Label label; double x, y;};\nstruct Edge {Label from, to; Weight weight;};\n////////////////////////////////////////\n#include<bits/stdc++.h>\nusing namespace std;\nint main() {\n  int C, W;\n  while(cin >> C >> W, C | W) {\n    vector<Vertex> pillar;\n    int leftmost_x = 1000;\n    for(int i = 0; i < C; ++i) {\n      double x, y;\n      cin >> x >> y;\n      pillar.push_back({i, x, y});\n      if(leftmost_x < x) continue;\n      leftmost_x = x;\n      leftmost = i;\n    }\n    PlaneGraph<Vertex, Edge> G;\n    for(const auto& p: pillar) G.insert(p);\n    for(int i = 0; i < W; ++i) {\n      int s, t;\n      cin >> s >> t;\n      --s; --t;\n      G.insert(Edge({s, t, 1}));\n    }\n    auto D = G.dualgraph();\n    auto distance = D.Dijkstra(outside_color);\n    double answer = 0;\n    for(const auto& d: distance) answer = max(answer, d.second);\n    cout << answer << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#include <climits>\n\nusing namespace std;\n\ntypedef long long lint;\n\n//定数\nconst double EPS = 1e-10;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\nconst int INF = 1001001001;\nconst lint INFLL = 1001001001001001001ll;\n\n//初期化関連\n#define zclear(a) memset((a), 0 ,sizeof(a))\n#define mclear(a) memset((a), -1, sizeof(a))\n\n//デバッグ出力\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nbool eq(double a, double b) //a == b\n{\n    return (fabs(a - b) <= EPS);\n}\n\nbool neq(double a, double b) //a == b\n{\n    return (!eq(a, b));\n}\n  \nbool lt(double a, double b) //a < b\n{\n    return (a - b < -EPS);\n}\n  \nbool leq(double a, double b) //a <= b\n{\n    return (lt(a, b) || eq(a, b));\n}\n  \nbool gt(double a, double b) //a > b\n{\n    return (a - b > +EPS);\n}\n  \nbool geq(double a, double b) //a >= b\n{\n    return (gt(a, b) || eq(a, b));\n}\n\nclass Point{\npublic:\n\tdouble x, y;\n\tint id;\n\tPoint(double x = 0, double y = 0): x(x), y(y){}\n\tPoint operator + (Point p){return Point(x + p.x, y + p.y);}\n\tPoint operator - (Point p){return Point(x - p.x, y - p.y);}\n\tPoint operator * (double a){return Point(x * a, y * a);}\n\tPoint operator / (double a){return Point(x / a, y / a);}\n\tPoint operator * (const Point &a){\n\t\treturn Point(x * a.x - y * a.y, x * a.y + y * a.x);\n\t}\n\tbool operator < (const Point &p) const {\n\t\treturn (x != p.x ? x < p.x : y < p.y);\n\t}\n\tbool operator == (const Point &p) const {\n\t\treturn (fabs(x - p.x) < EPS && fabs(y - p.y) < EPS);\n\t}\n};\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\ndouble norm(Vector a){return (a.x * a.x + a.y * a.y);}\ndouble abs(Vector a){return (sqrt(norm(a)));}\ndouble abs(Vector a, Vector b){return (sqrt(norm(a - b)));}\ndouble dot(Vector a, Vector b){return (a.x * b.x + a.y * b.y);}\ndouble cross(Vector a, Vector b){return (a.x * b.y - a.y * b.x);}\ndouble atan(Vector a){return atan2(a.y, a.x);}\nbool sortX(Point a, Point b){return (a.x != b.x ? lt(a.x, b.x) : lt(a.y, b.y));}\nbool sortY(Point a, Point b){return (a.y != b.y ? lt(a.y, b.y) : lt(a.x, b.x));}\nPoint p;\nbool sortT(Point a, Point b){return (gt(cross(a - p, b - p), 0));}\n\nint ccw(Point p0, Point p1, Point p2)\n{\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > EPS) return (+1); //p0, p1, p2 が反時計周り\n\tif (cross(a, b) < -EPS) return (-1);//p0, p1, p2 が時計回り\n\tif (dot(a, b) < -EPS) return (+2); //p2--p0--p1 の順で一直線上\n\tif (norm(a) < norm(b)) return (-2); //p0--p1--p2 の順で一直線上\n\treturn (0); //p0--p2--p1 の順で一直線上\n}\n\nPolygon normalize(Polygon &v)\n{\n    int pt = 0;\n    for (int i = 1; i < v.size(); i++){\n        if (v[pt].y > v[i].y || (v[pt].y == v[i].y && v[pt].x > v[i].x)){\n            pt = i;\n        }\n    }\n    swap(v[pt], v[0]);\n    p = v[0];\n    sort(v.begin() + 1, v.end(), sortT);\n    return (v);\n}\n\nPolygon conhel(Polygon& ps)\n{\n    sort(ps.begin(), ps.end());\n    int k = 0, n = (int)ps.size();\n    Polygon qs(n * 2);\n      \n    for (int i = 0; i < n; i++){\n      while (k > 1 && cross(qs[k - 1] - qs[k - 2], ps[i] - qs[k - 1]) < -EPS) k--;\n      qs[k++] = ps[i];\n    }\n  \n    for (int i = n - 2, t = k; i >= 0; i--){\n      while (k > t && cross(qs[k - 1] - qs[k - 2], ps[i] - qs[k - 1]) < -EPS) k--;\n      qs[k++] = ps[i];\n    }\n  \n    qs.resize(k - 1);\n    return (qs);\n}\n\ndouble getArea(Polygon t){\n    double ans = 0.0;\n\tt = normalize(t);\n    for (unsigned int i = 0; i < t.size(); i++)\n        ans += cross(t[i] , t[(i + 1) % t.size()]);\n    return (fabs(ans) / 2);\n}\n\nbool isIntersectLL(Point p1, Point p2, Point p3, Point p4)\n{// 同一直線の場合は交差していると判定する.\n\treturn (abs(cross(p2 - p1, p4 - p3)) > EPS || // 傾きが異なる\n\t\tabs(cross(p2 - p1, p4 - p3)) < EPS); // 同じ直線である\n}\nbool isIntersectLS(Point p1, Point p2, Point p3, Point p4)\n{// 同一直線上にある場合も交差と判定\n\treturn (cross(p2 - p1, p3 - p1) * cross(p2 - p1, p4 - p1) < EPS);\n}\nbool isIntersectLP(Point p1, Point p2, Point p)\n{\n\treturn (neq(abs(ccw(p1, p2, p)), 1));\n}\nbool isIntersectSS(Point p1, Point p2, Point p3, Point p4)\n{\n    return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n             ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool isIntersectSP(Point p1, Point p2, Point p)\n{\n\treturn (eq(ccw(p1, p2, p), 0));\n}\nbool isInsideCP(Point c, double r, Point p)\n{\n\treturn (leq(abs(c - p), r));\n}\nbool isInsideCC(Point c1, double r1, Point c2, double r2)\n{\n\treturn (leq(abs(c1 - c2), r1 + r2) && geq(abs(c1 - c2), abs(r1 - r2)));\n}\nbool isInsidePolyP(Polygon gon, Point p)\n{\n    for (int i = 0; i < gon.size(); i++){\n        if (ccw(gon[i], gon[(i + 1) % gon.size()], p) == -1) return (false);\n    }\n    return (true);\n}\n\nPoint projection(Point p1, Point p2, Point p3) //直線p1p2 上への写像\n{\n\tdouble t = dot(p3 - p1, p2 - p1) / norm(p2 - p1);\n\treturn (p1 + (p2 - p1) * t);\n}\nPoint reflection(Point p1, Point p2, Point p3) //直線p1p2 上への反射\n{\n\treturn (p3 + (projection(p1, p2, p3) - p) * 2);\n}\ndouble distanceLP(Point p1, Point p2, Point p)\n{\n\treturn (abs(p - projection(p1, p2, p)));\n}\ndouble distanceLL(Point l1, Point l2, Point m1, Point m2)\n{\n\treturn (isIntersectLL(l1, l2, m1, m2) ? 0 : distanceLP(l1, l2, m1));\n}\ndouble distanceLS(Point l1, Point l2, Point s1, Point s2)\n{\n    if (isIntersectLS(l1, l2, s1, s2)) return (0);\n\treturn (min(distanceLP(l1, l2, s1), distanceLP(l1, l2, s2)));\n}\ndouble distanceSP(Point s1, Point s2, Point p)\n{\n\tPoint r = projection(s1, s2, p);\n\tif (isIntersectSP(s1, s2, r)) return (abs(r - p));\n\treturn (min(abs(s1 - p), abs(s2 - p)));\n}\ndouble distanceSS(Point s1, Point s2, Point t1, Point t2){\n\tif (isIntersectSS(s1, s2, t1, t2)) return (0);\n\treturn (min(min(distanceSP(s1, s2, t1), distanceSP(s1, s2, t2)),\n\t\t\tmin(distanceSP(t1, t2, s1), distanceSP(t1, t2, s2))));\n}\nPoint interPointLL(Point a1, Point a2, Point b1, Point b2)\n{\n\tdouble d = cross(a2 - a1, b2 - b1);\n\tif (abs(d) < EPS) throw \"Segment is Paralell!\";\n\tPoint a = a2 - a1, b = b2 - b1;\n    double t = cross(b, b1 - a1) / cross(b, a);\n    return (a1 + a * t);\n}\nvector<Point> interPointCC(Point c1, double r1, Point c2, double r2)\n{\n\tvector<Point> res;\n\tif (abs(c1 - c2) < EPS) return (vector<Point>()); // 交点が絶対にない\n\tdouble d = abs(c1 - c2);\n\tdouble rc = (d * d + r1 * r1 - r2 * r2) / (2 * d);\n\tdouble rs = sqrt(r1 * r1 - rc * rc);\n\tPoint diff = (c2 - c1) / d;\n\tres.push_back(Point(c1 + diff * Point(rc, rs)));\n\tres.push_back(Point(c1 + diff * Point(rc, -rs)));\n\treturn (res);\n}\nvector<Point> crosspointCL(Point a, double ra, Point b1, Point b2)\n{\n\tvector<Point> res;\n\tdouble dist = distanceLP(b1, b2, a);\n\tif (leq(dist, ra)){\n\t\tPoint s = projection(b1, b2, a);\n\t\tdist = sqrt(ra * ra - dist * dist);\n\t\tPoint t = (b2 - b1) / abs(b2 - b1);\n\t\tres.push_back(s + t * dist);\n\t\tres.push_back(s - t * dist);\n\t}\n\treturn (res);\n}\n\nPoint unitVector(Vector t)\n{\n    double u = abs(t);\n    return (Point(t.x / u , t.y / u));\n}\n\nPoint normalVector(Point p, Point a, Point b)\n{\n    Point v = unitVector(b - a);\n    v = cross(v, p - a) > 0 ? Point(v.y, -v.x) : Point(-v.y, v.x);\n    return v * distanceLP(p, a, b);\n}\n  \ndouble getCos(Vector a, Vector b)\n{\n    return (dot(a, b) / (abs(a) * abs(b)));\n}\n  \ndouble getSin(Vector a, Vector b)\n{\n    double t = getCos(a, b);\n    return (sqrt(1.0 - t * t));\n}\n  \ndouble getArg(Vector v)\n{\n    return (atan2(v.y, v.x));\n}\n\nPoint rotate(Point t, Point p, double r)\n{\n    double ta = cos(r) * (t.x - p.x) - sin(r) * (t.y - p.y) + p.x;\n    double tb = sin(r) * (t.x - p.x) + cos(r) * (t.y - p.y) + p.y;\n    return (Point(ta, tb));\n}\n\nint main()\n{\n\tint N, M;\n\t\n\twhile (scanf(\"%d %d\", &N, &M) && N){\n\t\tvector<Point> P(N);\n\t\tvector<int> to[128];\n\t\tbool exist[128][128] = {0};\n\t\t\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tscanf(\"%lf %lf\", &P[i].x, &P[i].y);\n\t\t\tP[i].id = i;\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < M; i++){\n\t\t\tint x, y;\n\t\t\tscanf(\"%d %d\", &x, &y);\n\t\t\tto[--x].push_back(--y);\n\t\t\tto[y].push_back(x);\n\t\t\texist[x][y] = exist[y][x] = 1;\n\t\t}\n\t\t\n\t\tPolygon Q = P;\n\t\tQ = conhel(Q);\n\t\t\n\t\tvector<int> belong[128][128];\n\t\tfor (int i = 0; i < Q.size(); i++){\n\t\t\tint u = Q[i].id, v = Q[(i + 1) % Q.size()].id;\n\t\t\tbelong[u][v].push_back(0);\n\t\t\tbelong[v][u].push_back(0);\n\t\t}\n\t\tint k = 1;\n\t\tset<vector<int> > s;\n\t\t\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tfor (int j = 0; j < N; j++){\n\t\t\t\tif (P[j] < P[i] && exist[i][j] && belong[i][j].size() < 2){\n\t\t\t\t\tvector<int> v;\n\t\t\t\t\tv.push_back(i);\n\t\t\t\t\tv.push_back(j);\n\t\t\t\t\twhile (1){\n\t\t\t\t\t\tint nextP = -1;\n\t\t\t\t\t\tint vv = v[v.size() - 1], uu = v[v.size() - 2];\n\t\t\t\t\t\tfor (int l = 0; l < to[vv].size(); l++){\n\t\t\t\t\t\t\tif (to[vv][l] == vv || to[vv][l] == uu) continue;\n\t\t\t\t\t\t\tdouble thetaT, thetaC;\n\t\t\t\t\t\t\tthetaT = acos(getCos(P[uu] - P[vv], P[to[vv][l]] - P[vv]));\n\t\t\t\t\t\t\tif (ccw(P[uu], P[vv], P[to[vv][l]]) > 0) thetaT = 2 * M_PI - thetaT;\n\t\t\t\t\t\t\tif (nextP != -1){\n\t\t\t\t\t\t\t\tthetaC = acos(getCos(P[uu] - P[vv], P[nextP] - P[vv]));\n\t\t\t\t\t\t\t\tif (ccw(P[uu], P[vv], P[nextP]) > 0) thetaC = 2 * M_PI - thetaC;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (nextP == -1 || lt(thetaT, thetaC)) nextP = to[vv][l];\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (nextP == i) break;\n\t\t\t\t\t\tv.push_back(nextP);\n\t\t\t\t\t}\n\t\t\t\t\tvector<int> ss = v;\n\t\t\t\t\tsort(ss.begin(), ss.end());\n\t\t\t\t\tif (s.find(ss) != s.end()) continue;\n\t\t\t\t\telse s.insert(ss);\n\t\t\t\t\tfor (int it = 0; it < v.size(); it++){\n\t\t\t\t\t\tint uu = v[it], vv = v[(it + 1) % v.size()];\n\t\t\t\t\t\tbelong[uu][vv].push_back(k);\n\t\t\t\t\t\tbelong[vv][uu].push_back(k);\n\t\t\t\t\t}\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int> G[1024];\n\t\t\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tfor (int j = i + 1; j < N; j++){\n\t\t\t\tif (belong[i][j].size()){\n\t\t\t\t\tint u = belong[i][j][0], v = belong[i][j][1];\n\t\t\t\t\tG[u].push_back(v);\n\t\t\t\t\tG[v].push_back(u);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tint done[1024];\n\t\tfill(done, done + 1024, -1);\n\t\tqueue<pair<int, int> > q;\n\t\t\n\t\tfor(q.push(make_pair(0, 0)); q.size(); q.pop()){\n\t\t\tpair<int, int> x = q.front();\n\t\t\tif (~done[x.first]) continue;\n\t\t\tdone[x.first] = x.second;\n\t\t\tans = max(ans, x.second);\n\t\t\t\n\t\t\tfor (int i = 0; i < G[x.first].size(); i++){\n\t\t\t\tq.push(make_pair(G[x.first][i], x.second + 1));\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <bitset>\n#include <cmath>\n#include <algorithm>\n\n#define TIMES(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef bitset<22> Spec;\nconst double EPS = 1e-9;\nconst double PI = acos(-1);\n\ndouble normalize(double angle) {\n    if(angle < 0) return angle + 2*PI;\n    return angle;\n}\n\nint cmp(double a, double b) {\n    const double diff = a-b;\n    if(fabs(diff) < EPS) return 0;\n    return diff < 0 ? -1 : 1;\n}\n\ndouble dot(const P &a, const P &b) {\n    return a.real()*b.real() + a.imag()*b.imag();\n}\n\ndouble cross(const P &a, const P &b) {\n    return a.real()*b.imag() - a.imag()*b.real();\n}\n\nint root(int n, vector<int> &roots) {\n    if(roots[n] == n) return n;\n    return roots[n] = root(roots[n], roots);\n}\n\nbool unite(int a, int b, vector<int> &roots) {\n    const int ra = root(a, roots);\n    const int rb = root(b, roots);\n    if(ra == rb) return false;\n    roots[ra] = rb;\n    return true;\n}\n\nbool solve() {\n    int C, W;\n    cin >> C >> W;\n    if(!C && !W) return false;\n\n    vector<P> poles;\n    vector<vector<int>> graph(C);\n    vector<vector<int>> wall_id(C, vector<int>(C));\n    TIMES(_, C) {\n        double x, y;\n        cin >> x >> y;\n        poles.push_back(P(x, y));\n    }\n    TIMES(i, W) {\n        int s, t;\n        cin >> s >> t;\n        --s; --t;\n        graph[s].push_back(t);\n        graph[t].push_back(s);\n        wall_id[s][t] = i*2;\n        wall_id[t][s] = i*2+1;\n    }\n\n    vector<int> roots(W*2);\n    TIMES(i, W*2) {\n        roots[i] = i;\n    }\n    TIMES(i, C) {\n        const P &pi = poles[i];\n        for(int j : graph[i]) {\n            const P &pj = poles[j];\n            const P vec = pj - pi;\n            const double len = abs(vec);\n            int candidate = -1;\n            int sin_sgn = -2;\n            double cos_val = 2;\n            for(int k : graph[j]) {\n                if(k == i) continue;\n                const P vec2 = poles[k] - pj;\n                const int sgn = cmp(cross(vec2, vec), 0);\n                const double cv = dot(vec2, vec) / len / abs(vec2) * sgn;\n                if(sgn > sin_sgn\n                    || (sgn == sin_sgn && cmp(cv, cos_val) < 0))\n                {\n                    candidate = k;\n                    sin_sgn = sgn;\n                    cos_val = cv;\n                }\n            }\n            if(candidate != -1) {\n                if(unite(wall_id[i][j], wall_id[j][candidate], roots) && false) {\n                    cout << \"unitea \" << i << \" \" << j << \" \" << candidate << endl;\n                    TIMES(a, W*2) {\n                        cout << root(a, roots) << ' ';\n                    }\n                    cout << endl;\n                }\n            }\n        }\n    }\n    // Determine outside region\n    const int rightmost = distance(poles.begin(),\n            max_element(poles.begin(), poles.end(), [](const P &a, const P &b) {\n                return a.real() < b.real();\n                }));\n    const int rm_next = *min_element(\n            graph[rightmost].begin(), \n            graph[rightmost].end(),\n            [&poles, rightmost](int a, int b) {\n            const double arga = normalize(arg(poles[a] - poles[rightmost]));\n            const double argb = normalize(arg(poles[b] - poles[rightmost]));\n            return arga < argb;\n            });\n    int out_id = root(wall_id[rightmost][rm_next], roots);\n\n    Spec init;\n    vector<Spec> areas(W*2);\n    TIMES(i, W*2) {\n        const int area = root(i, roots);\n        areas[area][i/2] = true;\n        if(area == out_id) init[i/2] = true;\n        //cout << area << ' ';\n    }\n    /*\n    for(const Spec &s : areas) {\n        if(s.any()) cout << s << endl;\n    }\n    */\n    //cout << endl;\n    Spec cur = init;\n    //cout << init << endl;\n    int turn = 0;\n    vector<bool> used(W*2, false);\n    while(true) {\n        Spec next = cur;\n        bool changed = false;\n        TIMES(i, W*2) {\n            if(!used[i] && (areas[i] & cur).any()) {\n                next |= areas[i];\n                used[i] = true;\n                changed = true;\n            }\n        }\n        if(!changed) break;\n        cur = next;\n        ++turn;\n    }\n    cout << turn << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#include <climits>\n\nusing namespace std;\n\ntypedef long long lint;\n\n//定数\nconst double EPS = 1e-10;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\nconst int INF = 1001001001;\nconst lint INFLL = 1001001001001001001ll;\n\n//初期化関連\n#define zclear(a) memset((a), 0 ,sizeof(a))\n#define mclear(a) memset((a), -1, sizeof(a))\n\n//デバッグ出力\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nbool eq(double a, double b) //a == b\n{\n    return (fabs(a - b) <= EPS);\n}\n\nbool neq(double a, double b) //a == b\n{\n    return (!eq(a, b));\n}\n  \nbool lt(double a, double b) //a < b\n{\n    return (a - b < -EPS);\n}\n  \nbool leq(double a, double b) //a <= b\n{\n    return (lt(a, b) || eq(a, b));\n}\n  \nbool gt(double a, double b) //a > b\n{\n    return (a - b > +EPS);\n}\n  \nbool geq(double a, double b) //a >= b\n{\n    return (gt(a, b) || eq(a, b));\n}\n\nclass Point{\npublic:\n\tdouble x, y;\n\tint id;\n\tPoint(double x = 0, double y = 0): x(x), y(y){}\n\tPoint operator + (Point p){return Point(x + p.x, y + p.y);}\n\tPoint operator - (Point p){return Point(x - p.x, y - p.y);}\n\tPoint operator * (double a){return Point(x * a, y * a);}\n\tPoint operator / (double a){return Point(x / a, y / a);}\n\tPoint operator * (const Point &a){\n\t\treturn Point(x * a.x - y * a.y, x * a.y + y * a.x);\n\t}\n\tbool operator < (const Point &p) const {\n\t\treturn (x != p.x ? x < p.x : y < p.y);\n\t}\n\tbool operator == (const Point &p) const {\n\t\treturn (fabs(x - p.x) < EPS && fabs(y - p.y) < EPS);\n\t}\n};\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\ndouble norm(Vector a){return (a.x * a.x + a.y * a.y);}\ndouble abs(Vector a){return (sqrt(norm(a)));}\ndouble abs(Vector a, Vector b){return (sqrt(norm(a - b)));}\ndouble dot(Vector a, Vector b){return (a.x * b.x + a.y * b.y);}\ndouble cross(Vector a, Vector b){return (a.x * b.y - a.y * b.x);}\ndouble atan(Vector a){return atan2(a.y, a.x);}\nbool sortX(Point a, Point b){return (a.x != b.x ? lt(a.x, b.x) : lt(a.y, b.y));}\nbool sortY(Point a, Point b){return (a.y != b.y ? lt(a.y, b.y) : lt(a.x, b.x));}\nPoint p;\nbool sortT(Point a, Point b){return (gt(cross(a - p, b - p), 0));}\n\nint ccw(Point p0, Point p1, Point p2)\n{\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > EPS) return (+1); //p0, p1, p2 が反時計周り\n\tif (cross(a, b) < -EPS) return (-1);//p0, p1, p2 が時計回り\n\tif (dot(a, b) < -EPS) return (+2); //p2--p0--p1 の順で一直線上\n\tif (norm(a) < norm(b)) return (-2); //p0--p1--p2 の順で一直線上\n\treturn (0); //p0--p2--p1 の順で一直線上\n}\n\nPolygon normalize(Polygon &v)\n{\n    int pt = 0;\n    for (int i = 1; i < v.size(); i++){\n        if (v[pt].y > v[i].y || (v[pt].y == v[i].y && v[pt].x > v[i].x)){\n            pt = i;\n        }\n    }\n    swap(v[pt], v[0]);\n    p = v[0];\n    sort(v.begin() + 1, v.end(), sortT);\n    return (v);\n}\n\nPolygon conhel(Polygon& ps)\n{\n    sort(ps.begin(), ps.end());\n    int k = 0, n = (int)ps.size();\n    Polygon qs(n * 2);\n      \n    for (int i = 0; i < n; i++){\n      while (k > 1 && cross(qs[k - 1] - qs[k - 2], ps[i] - qs[k - 1]) < -EPS) k--;\n      qs[k++] = ps[i];\n    }\n  \n    for (int i = n - 2, t = k; i >= 0; i--){\n      while (k > t && cross(qs[k - 1] - qs[k - 2], ps[i] - qs[k - 1]) < -EPS) k--;\n      qs[k++] = ps[i];\n    }\n  \n    qs.resize(k - 1);\n    return (qs);\n}\n\ndouble getArea(Polygon t){\n    double ans = 0.0;\n\tt = normalize(t);\n    for (unsigned int i = 0; i < t.size(); i++)\n        ans += cross(t[i] , t[(i + 1) % t.size()]);\n    return (fabs(ans) / 2);\n}\n\nbool isIntersectLL(Point p1, Point p2, Point p3, Point p4)\n{// 同一直線の場合は交差していると判定する.\n\treturn (abs(cross(p2 - p1, p4 - p3)) > EPS || // 傾きが異なる\n\t\tabs(cross(p2 - p1, p4 - p3)) < EPS); // 同じ直線である\n}\nbool isIntersectLS(Point p1, Point p2, Point p3, Point p4)\n{// 同一直線上にある場合も交差と判定\n\treturn (cross(p2 - p1, p3 - p1) * cross(p2 - p1, p4 - p1) < EPS);\n}\nbool isIntersectLP(Point p1, Point p2, Point p)\n{\n\treturn (neq(abs(ccw(p1, p2, p)), 1));\n}\nbool isIntersectSS(Point p1, Point p2, Point p3, Point p4)\n{\n    return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n             ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool isIntersectSP(Point p1, Point p2, Point p)\n{\n\treturn (eq(ccw(p1, p2, p), 0));\n}\nbool isInsideCP(Point c, double r, Point p)\n{\n\treturn (leq(abs(c - p), r));\n}\nbool isInsideCC(Point c1, double r1, Point c2, double r2)\n{\n\treturn (leq(abs(c1 - c2), r1 + r2) && geq(abs(c1 - c2), abs(r1 - r2)));\n}\nbool isInsidePolyP(Polygon gon, Point p)\n{\n    for (int i = 0; i < gon.size(); i++){\n        if (ccw(gon[i], gon[(i + 1) % gon.size()], p) == -1) return (false);\n    }\n    return (true);\n}\n\nPoint projection(Point p1, Point p2, Point p3) //直線p1p2 上への写像\n{\n\tdouble t = dot(p3 - p1, p2 - p1) / norm(p2 - p1);\n\treturn (p1 + (p2 - p1) * t);\n}\nPoint reflection(Point p1, Point p2, Point p3) //直線p1p2 上への反射\n{\n\treturn (p3 + (projection(p1, p2, p3) - p) * 2);\n}\ndouble distanceLP(Point p1, Point p2, Point p)\n{\n\treturn (abs(p - projection(p1, p2, p)));\n}\ndouble distanceLL(Point l1, Point l2, Point m1, Point m2)\n{\n\treturn (isIntersectLL(l1, l2, m1, m2) ? 0 : distanceLP(l1, l2, m1));\n}\ndouble distanceLS(Point l1, Point l2, Point s1, Point s2)\n{\n    if (isIntersectLS(l1, l2, s1, s2)) return (0);\n\treturn (min(distanceLP(l1, l2, s1), distanceLP(l1, l2, s2)));\n}\ndouble distanceSP(Point s1, Point s2, Point p)\n{\n\tPoint r = projection(s1, s2, p);\n\tif (isIntersectSP(s1, s2, r)) return (abs(r - p));\n\treturn (min(abs(s1 - p), abs(s2 - p)));\n}\ndouble distanceSS(Point s1, Point s2, Point t1, Point t2){\n\tif (isIntersectSS(s1, s2, t1, t2)) return (0);\n\treturn (min(min(distanceSP(s1, s2, t1), distanceSP(s1, s2, t2)),\n\t\t\tmin(distanceSP(t1, t2, s1), distanceSP(t1, t2, s2))));\n}\nPoint interPointLL(Point a1, Point a2, Point b1, Point b2)\n{\n\tdouble d = cross(a2 - a1, b2 - b1);\n\tif (abs(d) < EPS) throw \"Segment is Paralell!\";\n\tPoint a = a2 - a1, b = b2 - b1;\n    double t = cross(b, b1 - a1) / cross(b, a);\n    return (a1 + a * t);\n}\nvector<Point> interPointCC(Point c1, double r1, Point c2, double r2)\n{\n\tvector<Point> res;\n\tif (abs(c1 - c2) < EPS) return (vector<Point>()); // 交点が絶対にない\n\tdouble d = abs(c1 - c2);\n\tdouble rc = (d * d + r1 * r1 - r2 * r2) / (2 * d);\n\tdouble rs = sqrt(r1 * r1 - rc * rc);\n\tPoint diff = (c2 - c1) / d;\n\tres.push_back(Point(c1 + diff * Point(rc, rs)));\n\tres.push_back(Point(c1 + diff * Point(rc, -rs)));\n\treturn (res);\n}\nvector<Point> crosspointCL(Point a, double ra, Point b1, Point b2)\n{\n\tvector<Point> res;\n\tdouble dist = distanceLP(b1, b2, a);\n\tif (leq(dist, ra)){\n\t\tPoint s = projection(b1, b2, a);\n\t\tdist = sqrt(ra * ra - dist * dist);\n\t\tPoint t = (b2 - b1) / abs(b2 - b1);\n\t\tres.push_back(s + t * dist);\n\t\tres.push_back(s - t * dist);\n\t}\n\treturn (res);\n}\n\nPoint unitVector(Vector t)\n{\n    double u = abs(t);\n    return (Point(t.x / u , t.y / u));\n}\n\nPoint normalVector(Point p, Point a, Point b)\n{\n    Point v = unitVector(b - a);\n    v = cross(v, p - a) > 0 ? Point(v.y, -v.x) : Point(-v.y, v.x);\n    return v * distanceLP(p, a, b);\n}\n  \ndouble getCos(Vector a, Vector b)\n{\n    return (dot(a, b) / (abs(a) * abs(b)));\n}\n  \ndouble getSin(Vector a, Vector b)\n{\n    double t = getCos(a, b);\n    return (sqrt(1.0 - t * t));\n}\n  \ndouble getArg(Vector v)\n{\n    return (atan2(v.y, v.x));\n}\n\nPoint rotate(Point t, Point p, double r)\n{\n    double ta = cos(r) * (t.x - p.x) - sin(r) * (t.y - p.y) + p.x;\n    double tb = sin(r) * (t.x - p.x) + cos(r) * (t.y - p.y) + p.y;\n    return (Point(ta, tb));\n}\n\nint main()\n{\n\tint N, M;\n\t\n\twhile (scanf(\"%d %d\", &N, &M) && N){\n\t\tvector<Point> P(N);\n\t\tvector<int> to[128];\n\t\tbool exist[128][128] = {0};\n\t\t\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tscanf(\"%lf %lf\", &P[i].x, &P[i].y);\n\t\t\tP[i].id = i;\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < M; i++){\n\t\t\tint x, y;\n\t\t\tscanf(\"%d %d\", &x, &y);\n\t\t\tto[--x].push_back(--y);\n\t\t\tto[y].push_back(x);\n\t\t\texist[x][y] = exist[y][x] = 1;\n\t\t}\n\t\t\n\t\tPolygon Q = P;\n\t\tQ = conhel(Q);\n\t\t\n\t\tvector<int> belong[128][128];\n\t\tfor (int i = 0; i < Q.size(); i++){\n\t\t\tint u = Q[i].id, v = Q[(i + 1) % Q.size()].id;\n\t\t\tbelong[u][v].push_back(0);\n\t\t\tbelong[v][u].push_back(0);\n\t\t}\n\t\tint k = 1;\n\t\tset<vector<int> > s;\n\t\t\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tfor (int j = 0; j < N; j++){\n\t\t\t\tif (P[j] < P[i] && exist[i][j] && belong[i][j].size() < 2){\n\t\t\t\t\tvector<int> v;\n\t\t\t\t\tv.push_back(i);\n\t\t\t\t\tv.push_back(j);\n\t\t\t\t\twhile (1){\n\t\t\t\t\t\tint nextP = -1;\n\t\t\t\t\t\tint vv = v[v.size() - 1], uu = v[v.size() - 2];\n\t\t\t\t\t\tfor (int l = 0; l < to[vv].size(); l++){\n\t\t\t\t\t\t\tif (to[vv][l] == vv || to[vv][l] == uu) continue;\n\t\t\t\t\t\t\tif (ccw(P[uu], P[vv], P[to[vv][l]]) < 0){\n\t\t\t\t\t\t\t\tif (nextP == -1 || getCos(P[uu] - P[vv], P[to[vv][l]] - P[vv]) > getCos(P[uu] - P[vv], P[nextP] - P[vv])) nextP = to[vv][l];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tassert(nextP != -1);\n\t\t\t\t\t\tif (nextP == i) break;\n\t\t\t\t\t\tv.push_back(nextP);\n\t\t\t\t\t}\n\t\t\t\t\tvector<int> ss = v;\n\t\t\t\t\tsort(ss.begin(), ss.end());\n\t\t\t\t\tif (s.find(ss) != s.end()) continue;\n\t\t\t\t\telse s.insert(ss);\n\t\t\t\t\tfor (int it = 0; it < v.size(); it++){\n\t\t\t\t\t\tint uu = v[it], vv = v[(it + 1) % v.size()];\n\t\t\t\t\t\tbelong[uu][vv].push_back(k);\n\t\t\t\t\t\tbelong[vv][uu].push_back(k);\n\t\t\t\t\t}\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int> G[1024];\n\t\t\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tfor (int j = i + 1; j < N; j++){\n\t\t\t\tif (belong[i][j].size() < 2){\n\t\t\t\t\tint u = belong[i][j][0], v = belong[i][j][1];\n\t\t\t\t\tG[u].push_back(v);\n\t\t\t\t\tG[v].push_back(u);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tint done[1024];\n\t\tfill(done, done + 1024, -1);\n\t\tqueue<pair<int, int> > q;\n\t\t\n\t\tfor(q.push(make_pair(0, 0)); q.size(); q.pop()){\n\t\t\tpair<int, int> x = q.front();\n\t\t\tif (~done[x.first]) continue;\n\t\t\tdone[x.first] = x.second;\n\t\t\tans = max(ans, x.second);\n\t\t\t\n\t\t\tfor (int i = 0; i < G[x.first].size(); i++){\n\t\t\t\tq.push(make_pair(G[x.first][i], x.second + 1));\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<utility>\n#include<map>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n\nusing namespace std;\n\nstruct Point{\n\tint x,y;\n\tint id;\n\tPoint(){}\n\tPoint(int a,int b,int c):x(a),y(b),id(c){}\n};\n\nPoint points[110];\nint pid[110];\n\nbool cmp(const Point &p1,const Point &p2)\n{\n\tif(p1.x!=p2.x) return p1.x<p2.x;\n\treturn p1.y<p2.y;\n}\n\nint center;\n\nbool cmp_angle(const int &id1,const int &id2)\n{\n\tint center=pid[::center];\n\tint id1_=pid[id1],id2_=pid[id2];\n\tint dx1=points[id1_].x-points[center].x;\n\tint dy1=points[id1_].y-points[center].y;\n\tint dx2=points[id2_].x-points[center].x;\n\tint dy2=points[id2_].y-points[center].y;\n\t//(-y,x)\n\tdouble ang1=atan2(dx1,-dy1);\n\tdouble ang2=atan2(dx2,-dy2);\n\treturn ang1<ang2;\n}\n/*\nstruct cmp_angle_{\n\tbool operator()(const int &id1,const int &id2)\n\t{\n\tint center=pid[::center];\n\tint id1_=pid[id1],id2_=pid[id2];\n\tint dx1=points[id1_].x-points[center].x;\n\tint dy1=points[id1_].y-points[center].y;\n\tint dx2=points[id2_].x-points[center].x;\n\tint dy2=points[id2_].y-points[center].y;\n\t//(-y,x)\n\tdouble ang1=atan2(dx1,-dy1);\n\tdouble ang2=atan2(dx2,-dy2);\n\treturn ang1<ang2;\n\t}\n};*/\n\nvector<int> G[110];\n\nvector<vector<int> > vs;\nvector<int> dG[550];\n//bool con[550][550];\n\ntypedef pair<int,int> P;\n\nmap<P,int> cnt;\nqueue<P> que;\n\nvoid init()\n{\n\tvs.clear();\n\tfor(int i=0;i<110;i++) G[i].clear();\n\tfor(int i=0;i<550;i++) dG[i].clear();\n\tcnt.clear();\n}\n\nvector<int> res;\nvoid stroke(int u,int v,int st)\n{\n\t//u->v\n\tP p=P(min(u,v),max(u,v));\n\tif(cnt[p]==0)\n\t{\n\t\tque.push(P(v,u));\n\t}\n\tcnt[p]++;\n\tif(v==st) return;\n\tif(u==st) res.push_back(u);\n\tres.push_back(v);\n//\tprintf(\"x%dx\\n\",v);\n\tcenter=v;\n\tint id=distance(G[v].begin(),lower_bound(G[v].begin(),G[v].end(),u,cmp_angle));\n//\tprintf(\"%d::%d %d\\n\",v,G[v].size(),id);\n\tif(id==G[v].size()-1) id=0;\n\telse id++;\n\tint nxt=G[v][id];\n\tstroke(v,nxt,st);\n}\n\nvoid getGraph()\n{\n\tint V=vs.size();\n\tfor(int i=0;i<V;i++) for(int j=i+1;j<V;j++)\n\t{\n\t\tint ni=vs[i].size(),nj=vs[j].size();\n\t\tbool flg=false;\n\t\tfor(int iid=0;iid<ni;iid++) for(int jid=0;jid<nj;jid++)\n\t\t{\n\t\t\tint niid=iid==ni-1?0:iid+1;\n\t\t\tint njid=jid==nj-1?0:jid+1;\n\t\t\tif(vs[i][iid]==vs[j][njid]&&vs[i][niid]==vs[j][jid]) flg=true;\n\t\t}\n\t\tif(flg)\n\t\t{\n\t\t\tdG[i].push_back(j);\n\t\t\tdG[j].push_back(i);\n\t\t}\n\t//\tcon[i][j]=flg;\n\t//\tcon[j][i]=flg;\n\t}\n}\n\nint getMostOutSide()\n{\n\tint u=points[0].id;\n\tint v=G[u][0];\n//\tprintf(\"----------------%d %d\\n\",u,v);\n//\tprintf(\"%d %d %d %d\\n\",points[u].x,points[u].y,points[v].x,points[v].y);\n\tfor(int i=0;i<vs.size();i++)\n\t{\n\t\tfor(int j=0;j+1<vs[i].size();j++)\n\t\t{\n\t\t\tif(vs[i][j]==u&&vs[i][j+1]==v) return i;\n\t\t}\n\t\tif(vs[i][vs[i].size()-1]==u&&vs[i][0]==v) return i;\n\t}\n//\tfor(;;);\n\treturn -1;\n}\n\nvoid check(int a)\n{\n\tif(cnt.size()>a) for(;;);\n/*\tmap<P,int>::iterator it=cnt.begin();\n\tfor(;it!=cnt.end();it++)\n\t{\n\t\tint b=it->second;\n\t\tif(b!=2) for(;;);\n\t}*/\n}\n\nint dis[550];\nqueue<int> bfs_que;\nvoid bfs(int s)\n{\n//\tprintf(\"xxxxxxxxxxxxxxxxxxxxx\\n\");\n\twhile(!bfs_que.empty()) bfs_que.pop();\n\tbfs_que.push(s);\n\tfor(int i=0;i<550;i++) dis[i]=1<<29;\n\tdis[s]=0;\n\tbfs_que.push(s);\n\twhile(!bfs_que.empty())\n\t{\n\t\tint v=bfs_que.front();\n//\t\tprintf(\"bfs %d\\n\",v);\n\t\tbfs_que.pop();\n\t\tfor(int i=0;i<dG[v].size();i++)\n\t\t{\n\t\t\tint u=dG[v][i];\n\t\t\tint nd=dis[v]+1;\n\t\t\tif(nd>=dis[u]) continue;\n\t\t\tdis[u]=nd;\n\t\t\tbfs_que.push(u);\n\t\t}\n\t}\n}\n\nvoid outputdG()\n{\n\tprintf(\"-----dual\\n\");\n\tfor(int i=0;i<vs.size();i++)\n\t{\n\t\tprintf(\"%d-\",i);\n\t\tfor(int j=0;j<dG[i].size();j++)\n\t\t{\n\t\t\tprintf(\"%d \",dG[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}\n\nint main()\n{\n\twhile(true)\n\t{\n\t\tint C,W;\n\t\tscanf(\"%d%d\",&C,&W);\n\t\tif(C==0) break;\n\t\tinit();\n\t\tfor(int i=0;i<C;i++)\n\t\t{\n\t\t\tint x,y;\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\tpoints[i]=Point(x,y,i);\n\t\t}\n\t\tsort(points,points+C,cmp);\n\t\tfor(int i=0;i<C;i++) pid[points[i].id]=i;\n\t\tint su=-1,sv=-1;\n\t\tfor(int i=0;i<W;i++)\n\t\t{\n\t\t\tint u,v;\n\t\t\tscanf(\"%d%d\",&u,&v);\n\t\t\tu--;v--;\n\t\t\tG[u].push_back(v);\n\t\t\tG[v].push_back(u);\n\t\t\tsu=u,sv=v;\n\t\t}\n\t\tfor(int i=0;i<C;i++)\n\t\t{\n\t\t\tcenter=i;\n\t\t\tsort(G[i].begin(),G[i].end(),cmp_angle);\n//\t\t\tprintf(\"%d:::\",i);\n//\t\t\tfor(int j=0;j<G[i].size();j++) printf(\"%d \",G[i][j]);\n//\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tque.push(P(min(su,sv),max(su,sv)));\n\t\twhile(!que.empty())\n\t\t{\n\t\t\tP p=que.front();\n\t\t\tque.pop();\n\t\t\tint u=p.first,v=p.second;\n//\t\t\tprintf(\"pop %d %d\\n\",u,v);\n\t\t\tP pp=P(min(u,v),max(u,v));\n\t\t\tif(cnt[pp]==2) continue;\n\t\t//\tbool flg;\n\t\t//\tif(cnt[pp]==1) flg=false;\n\t\t//\telse flg=true;\n\t\t\tres.clear();\n\t\t\tstroke(u,v,u);\n\t\t\tvs.push_back(res);\n//\t\t\tfor(int i=0;i<res.size();i++) printf(\"%d \",res[i]);\n//\t\t\tprintf(\"aaa\\n\");\n\t\t//\tcnt[pp]++;\n\t\t//\tif(flg) que.push(P(v,u));\n\t\t}\n\t\tif(vs.size()>500) for(;;);\n//\t\tfor(int i=0;i<vs.size();i++)\n//\t\t{\n//\t\t\tvector<int> vec=vs[i];\n//\t\t\tprintf(\"a:\");\n//\t\t\tfor(int j=0;j<vec.size();j++) printf(\"%d \",vec[j]);\n//\t\t\tprintf(\"\\n\");\n//\t\t}\n\t\tgetGraph();\n\t\tcheck(W);\n\t\tint out=getMostOutSide();\n\t\tbfs(out);\n\t\tint ans=0;\n\t\tfor(int i=0;i<vs.size();i++) ans=max(ans,dis[i]);\n//\t\toutputdG();\n//\t\tprintf(\"---------%d--------------ans=%d\\n\",out,ans);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint bottom;\nint outside_color;\n\n// Library.\n#include<cassert>\n#include<map>\n#include<vector>\n#include<cmath>\n#include<queue>\n#include<algorithm>\n// Type.\ntypedef int Label;\ntypedef int Weight;\n// Class.\ntemplate<typename Vertex, typename Edge>\nclass PlaneGraph {\npublic:\n  void insert(const Vertex& v);\n  void insert(Edge e);\n  const PlaneGraph<Vertex, Edge> dualgraph() const;\n  const std::map<Label, Weight> Dijkstra(const Label& start) const;\n  // For debug.\n  void print() {\n    cout << \"print edges\" << endl;\n    for(const auto& list: E) {\n      for(const auto& e: list.second) cout << \" \" << e.from << \"-\" << e.to << \":\" << e.weight;\n      cout << endl;\n    }\n  }\nprivate:\n  void dualgraph_color(std::map<Label, std::map<Label, int>>& color, int c, const Edge& e, const std::map<Label, std::vector<Edge>>& edge) const;\n  std::map<Label, Vertex> V;\n  std::map<Label, std::vector<Edge>> E;\n};\n// Implement.\ntemplate<typename Vertex, typename Edge>\nvoid PlaneGraph<Vertex, Edge>::insert(const Vertex& v) {\n  V[v.label] = v;\n}\ntemplate<typename Vertex, typename Edge>\nvoid PlaneGraph<Vertex, Edge>::insert(Edge e) {\n  assert(V.find(e.from) != std::end(V));\n  assert(V.find(e.to) != std::end(V));\n  E[e.from].push_back(e);\n  std::swap(e.from, e.to);\n  E[e.from].push_back(e);\n}\ntemplate<typename Vertex, typename Edge>\nconst PlaneGraph<Vertex, Edge> PlaneGraph<Vertex, Edge>::dualgraph() const {\n  // Sort edges counterclockwise.\n  auto edge = E;\n  for(auto& list: edge) if(!list.second.empty()) {\n    std::sort(std::begin(list.second), std::end(list.second), [&](const Edge& lhs, const Edge& rhs) {\n      double l = std::atan2(V.at(lhs.to).y - V.at(lhs.from).y, V.at(lhs.to).x - V.at(lhs.from).x);\n      double r = std::atan2(V.at(rhs.to).y - V.at(rhs.from).y, V.at(rhs.to).x - V.at(rhs.from).x);\n      return l < r;\n    });\n    list.second.push_back(list.second.front());\n  }\n  // Color edges.\n  std::map<Label, std::map<Label, int>> color;\n  int c = 1;\n  for(const auto& list: edge) {\n    for(const auto& e: list.second) if(!color[e.from].count(e.to)) dualgraph_color(color, c++, e, edge);\n    if(list.first == bottom) outside_color = color[list.second[list.second.size() - 2].from][list.second[list.second.size() - 2].to];\n//     if(list.first == bottom) cout<<\",\"<<list.second[list.second.size() - 2].from<<\",\"<<list.second[list.second.size() - 2].to<<\":\"<<outside_color<<endl;\n//     if(list.first == bottom) outside_color = color[list.second.front().from][list.second.front().to];\n//     if(list.first == bottom) cout<<\",\"<<list.second.front().from<<\",\"<<list.second.front().to<<\":\"<<outside_color<<endl;\n  }\n//   cout<<\"color\"<<endl;\n//   for(auto i: color){\n//     cout<<i.first<<endl;\n//     for(auto j:i.second)cout<<\" \"<<j.first<<\":\"<<j.second;\n//     cout<<endl;\n//   }\n  // Construct the dualgraph.\n  PlaneGraph<Vertex, Edge> result;\n  std::vector<std::vector<bool>> used(c, std::vector<bool>(c, false));\n  for(int i = 1; i < c; ++i) result.insert(Vertex({i}));\n  for(const auto& list: E) for(const auto& e: list.second) if(!used[color[e.from][e.to]][color[e.to][e.from]]) {\n    used[color[e.from][e.to]][color[e.to][e.from]] = true;\n    used[color[e.to][e.from]][color[e.from][e.to]] = true;\n    result.insert(Edge({color[e.from][e.to], color[e.to][e.from], 1}));\n  }\n  return result;\n}\ntemplate<typename Vertex, typename Edge>\nvoid PlaneGraph<Vertex, Edge>::dualgraph_color(std::map<Label, std::map<Label, int>>& color, int c, const Edge& e, const std::map<Label, std::vector<Edge>>& edge) const {\n  color[e.from][e.to] = c;\n  for(auto it = edge.at(e.to).rbegin(); it != edge.at(e.to).rend(); ++it) if(it->to == e.from) {\n    ++it;\n    if(!color[it->from].count(it->to)) dualgraph_color(color, c, *it, edge);\n    break;\n  }\n}\ntemplate<typename Vertex, typename Edge>\nconst std::map<Label, Weight> PlaneGraph<Vertex, Edge>::Dijkstra(const Label& start) const {\n  std::map<Label, Weight> result;\n  std::priority_queue<Edge, std::vector<Edge>, std::function<bool(Edge, Edge)>> q([](Edge lhs, Edge rhs) {\n    return lhs.weight > rhs.weight;\n  });\n  q.push(Edge({start, start, 0}));\n  while(!q.empty()) {\n    auto cur = q.top();\n    q.pop();\n    if(result.count(cur.to)) continue;\n    result[cur.to] = cur.weight;\n    for(const auto& nex: E.at(cur.to)) if(!result.count(nex.to)) q.push(Edge({nex.from, nex.to, cur.weight + nex.weight}));\n  }\n  return result;\n}\n////////////////////////////////////////\n// Configuration.\nstruct Vertex {Label label; double x, y;};\nstruct Edge {Label from, to; Weight weight;};\n////////////////////////////////////////\n#include<bits/stdc++.h>\nusing namespace std;\nint main() {\n  int C, W;\n  while(cin >> C >> W, C | W) {\n    vector<Vertex> pillar;\n    int bottom_x = 1001, bottom_y = 1001;\n    for(int i = 0; i < C; ++i) {\n      double x, y;\n      cin >> x >> y;\n      pillar.push_back({i, x, y});\n      if(bottom_y < y) continue;\n      if(bottom_y == y && bottom_x < x) continue;\n      bottom_x = x;\n      bottom_y = y;\n      bottom = i;\n    }\n    PlaneGraph<Vertex, Edge> G;\n    for(const auto& p: pillar) G.insert(p);\n    for(int i = 0; i < W; ++i) {\n      int s, t;\n      cin >> s >> t;\n      --s; --t;\n      G.insert(Edge({s, t, 1}));\n    }\n    auto D = G.dualgraph();\n//     D.print();\n    auto distance = D.Dijkstra(outside_color);\n    Weight answer = 0;\n    for(const auto& d: distance) answer = max(answer, d.second);\n    cout << answer << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#include <climits>\n\nusing namespace std;\n\ntypedef long long lint;\n\n//定数\nconst double EPS = 1e-10;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\nconst int INF = 1001001001;\nconst lint INFLL = 1001001001001001001ll;\n\n//初期化関連\n#define zclear(a) memset((a), 0 ,sizeof(a))\n#define mclear(a) memset((a), -1, sizeof(a))\n\n//デバッグ出力\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nbool eq(double a, double b) //a == b\n{\n    return (fabs(a - b) <= EPS);\n}\n\nbool neq(double a, double b) //a == b\n{\n    return (!eq(a, b));\n}\n  \nbool lt(double a, double b) //a < b\n{\n    return (a - b < -EPS);\n}\n  \nbool leq(double a, double b) //a <= b\n{\n    return (lt(a, b) || eq(a, b));\n}\n  \nbool gt(double a, double b) //a > b\n{\n    return (a - b > +EPS);\n}\n  \nbool geq(double a, double b) //a >= b\n{\n    return (gt(a, b) || eq(a, b));\n}\n\nclass Point{\npublic:\n\tdouble x, y;\n\tint id;\n\tPoint(double x = 0, double y = 0): x(x), y(y){}\n\tPoint operator + (Point p){return Point(x + p.x, y + p.y);}\n\tPoint operator - (Point p){return Point(x - p.x, y - p.y);}\n\tPoint operator * (double a){return Point(x * a, y * a);}\n\tPoint operator / (double a){return Point(x / a, y / a);}\n\tPoint operator * (const Point &a){\n\t\treturn Point(x * a.x - y * a.y, x * a.y + y * a.x);\n\t}\n\tbool operator < (const Point &p) const {\n\t\treturn (x != p.x ? x < p.x : y < p.y);\n\t}\n\tbool operator == (const Point &p) const {\n\t\treturn (fabs(x - p.x) < EPS && fabs(y - p.y) < EPS);\n\t}\n};\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\ndouble norm(Vector a){return (a.x * a.x + a.y * a.y);}\ndouble abs(Vector a){return (sqrt(norm(a)));}\ndouble abs(Vector a, Vector b){return (sqrt(norm(a - b)));}\ndouble dot(Vector a, Vector b){return (a.x * b.x + a.y * b.y);}\ndouble cross(Vector a, Vector b){return (a.x * b.y - a.y * b.x);}\ndouble atan(Vector a){return atan2(a.y, a.x);}\nbool sortX(Point a, Point b){return (a.x != b.x ? lt(a.x, b.x) : lt(a.y, b.y));}\nbool sortY(Point a, Point b){return (a.y != b.y ? lt(a.y, b.y) : lt(a.x, b.x));}\nPoint p;\nbool sortT(Point a, Point b){return (gt(cross(a - p, b - p), 0));}\n\nint ccw(Point p0, Point p1, Point p2)\n{\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > EPS) return (+1); //p0, p1, p2 が反時計周り\n\tif (cross(a, b) < -EPS) return (-1);//p0, p1, p2 が時計回り\n\tif (dot(a, b) < -EPS) return (+2); //p2--p0--p1 の順で一直線上\n\tif (norm(a) < norm(b)) return (-2); //p0--p1--p2 の順で一直線上\n\treturn (0); //p0--p2--p1 の順で一直線上\n}\n\nPolygon normalize(Polygon &v)\n{\n    int pt = 0;\n    for (int i = 1; i < v.size(); i++){\n        if (v[pt].y > v[i].y || (v[pt].y == v[i].y && v[pt].x > v[i].x)){\n            pt = i;\n        }\n    }\n    swap(v[pt], v[0]);\n    p = v[0];\n    sort(v.begin() + 1, v.end(), sortT);\n    return (v);\n}\n\nPolygon conhel(Polygon& ps)\n{\n    sort(ps.begin(), ps.end());\n    int k = 0, n = (int)ps.size();\n    Polygon qs(n * 2);\n      \n    for (int i = 0; i < n; i++){\n      while (k > 1 && cross(qs[k - 1] - qs[k - 2], ps[i] - qs[k - 1]) < -EPS) k--;\n      qs[k++] = ps[i];\n    }\n  \n    for (int i = n - 2, t = k; i >= 0; i--){\n      while (k > t && cross(qs[k - 1] - qs[k - 2], ps[i] - qs[k - 1]) < -EPS) k--;\n      qs[k++] = ps[i];\n    }\n  \n    qs.resize(k - 1);\n    return (qs);\n}\n\ndouble getArea(Polygon t){\n    double ans = 0.0;\n\tt = normalize(t);\n    for (unsigned int i = 0; i < t.size(); i++)\n        ans += cross(t[i] , t[(i + 1) % t.size()]);\n    return (fabs(ans) / 2);\n}\n\nbool isIntersectLL(Point p1, Point p2, Point p3, Point p4)\n{// 同一直線の場合は交差していると判定する.\n\treturn (abs(cross(p2 - p1, p4 - p3)) > EPS || // 傾きが異なる\n\t\tabs(cross(p2 - p1, p4 - p3)) < EPS); // 同じ直線である\n}\nbool isIntersectLS(Point p1, Point p2, Point p3, Point p4)\n{// 同一直線上にある場合も交差と判定\n\treturn (cross(p2 - p1, p3 - p1) * cross(p2 - p1, p4 - p1) < EPS);\n}\nbool isIntersectLP(Point p1, Point p2, Point p)\n{\n\treturn (neq(abs(ccw(p1, p2, p)), 1));\n}\nbool isIntersectSS(Point p1, Point p2, Point p3, Point p4)\n{\n    return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n             ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool isIntersectSP(Point p1, Point p2, Point p)\n{\n\treturn (eq(ccw(p1, p2, p), 0));\n}\nbool isInsideCP(Point c, double r, Point p)\n{\n\treturn (leq(abs(c - p), r));\n}\nbool isInsideCC(Point c1, double r1, Point c2, double r2)\n{\n\treturn (leq(abs(c1 - c2), r1 + r2) && geq(abs(c1 - c2), abs(r1 - r2)));\n}\nbool isInsidePolyP(Polygon gon, Point p)\n{\n    for (int i = 0; i < gon.size(); i++){\n        if (ccw(gon[i], gon[(i + 1) % gon.size()], p) == -1) return (false);\n    }\n    return (true);\n}\n\nPoint projection(Point p1, Point p2, Point p3) //直線p1p2 上への写像\n{\n\tdouble t = dot(p3 - p1, p2 - p1) / norm(p2 - p1);\n\treturn (p1 + (p2 - p1) * t);\n}\nPoint reflection(Point p1, Point p2, Point p3) //直線p1p2 上への反射\n{\n\treturn (p3 + (projection(p1, p2, p3) - p) * 2);\n}\ndouble distanceLP(Point p1, Point p2, Point p)\n{\n\treturn (abs(p - projection(p1, p2, p)));\n}\ndouble distanceLL(Point l1, Point l2, Point m1, Point m2)\n{\n\treturn (isIntersectLL(l1, l2, m1, m2) ? 0 : distanceLP(l1, l2, m1));\n}\ndouble distanceLS(Point l1, Point l2, Point s1, Point s2)\n{\n    if (isIntersectLS(l1, l2, s1, s2)) return (0);\n\treturn (min(distanceLP(l1, l2, s1), distanceLP(l1, l2, s2)));\n}\ndouble distanceSP(Point s1, Point s2, Point p)\n{\n\tPoint r = projection(s1, s2, p);\n\tif (isIntersectSP(s1, s2, r)) return (abs(r - p));\n\treturn (min(abs(s1 - p), abs(s2 - p)));\n}\ndouble distanceSS(Point s1, Point s2, Point t1, Point t2){\n\tif (isIntersectSS(s1, s2, t1, t2)) return (0);\n\treturn (min(min(distanceSP(s1, s2, t1), distanceSP(s1, s2, t2)),\n\t\t\tmin(distanceSP(t1, t2, s1), distanceSP(t1, t2, s2))));\n}\nPoint interPointLL(Point a1, Point a2, Point b1, Point b2)\n{\n\tdouble d = cross(a2 - a1, b2 - b1);\n\tif (abs(d) < EPS) throw \"Segment is Paralell!\";\n\tPoint a = a2 - a1, b = b2 - b1;\n    double t = cross(b, b1 - a1) / cross(b, a);\n    return (a1 + a * t);\n}\nvector<Point> interPointCC(Point c1, double r1, Point c2, double r2)\n{\n\tvector<Point> res;\n\tif (abs(c1 - c2) < EPS) return (vector<Point>()); // 交点が絶対にない\n\tdouble d = abs(c1 - c2);\n\tdouble rc = (d * d + r1 * r1 - r2 * r2) / (2 * d);\n\tdouble rs = sqrt(r1 * r1 - rc * rc);\n\tPoint diff = (c2 - c1) / d;\n\tres.push_back(Point(c1 + diff * Point(rc, rs)));\n\tres.push_back(Point(c1 + diff * Point(rc, -rs)));\n\treturn (res);\n}\nvector<Point> crosspointCL(Point a, double ra, Point b1, Point b2)\n{\n\tvector<Point> res;\n\tdouble dist = distanceLP(b1, b2, a);\n\tif (leq(dist, ra)){\n\t\tPoint s = projection(b1, b2, a);\n\t\tdist = sqrt(ra * ra - dist * dist);\n\t\tPoint t = (b2 - b1) / abs(b2 - b1);\n\t\tres.push_back(s + t * dist);\n\t\tres.push_back(s - t * dist);\n\t}\n\treturn (res);\n}\n\nPoint unitVector(Vector t)\n{\n    double u = abs(t);\n    return (Point(t.x / u , t.y / u));\n}\n\nPoint normalVector(Point p, Point a, Point b)\n{\n    Point v = unitVector(b - a);\n    v = cross(v, p - a) > 0 ? Point(v.y, -v.x) : Point(-v.y, v.x);\n    return v * distanceLP(p, a, b);\n}\n  \ndouble getCos(Vector a, Vector b)\n{\n    return (dot(a, b) / (abs(a) * abs(b)));\n}\n  \ndouble getSin(Vector a, Vector b)\n{\n    double t = getCos(a, b);\n    return (sqrt(1.0 - t * t));\n}\n  \ndouble getArg(Vector v)\n{\n    return (atan2(v.y, v.x));\n}\n\nPoint rotate(Point t, Point p, double r)\n{\n    double ta = cos(r) * (t.x - p.x) - sin(r) * (t.y - p.y) + p.x;\n    double tb = sin(r) * (t.x - p.x) + cos(r) * (t.y - p.y) + p.y;\n    return (Point(ta, tb));\n}\n\nint main()\n{\n\tint N, M;\n\t\n\twhile (scanf(\"%d %d\", &N, &M) && N){\n\t\tvector<Point> P(N);\n\t\tvector<int> to[128];\n\t\tbool exist[128][128] = {0};\n\t\t\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tscanf(\"%lf %lf\", &P[i].x, &P[i].y);\n\t\t\tP[i].id = i;\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < M; i++){\n\t\t\tint x, y;\n\t\t\tscanf(\"%d %d\", &x, &y);\n\t\t\tto[--x].push_back(--y);\n\t\t\tto[y].push_back(x);\n\t\t\texist[x][y] = exist[y][x] = 1;\n\t\t}\n\t\t\n\t\tPolygon Q = P;\n\t\tQ = conhel(Q);\n\t\t\n\t\tvector<int> belong[128][128];\n\t\tfor (int i = 0; i < Q.size(); i++){\n\t\t\tint u = Q[i].id, v = Q[(i + 1) % Q.size()].id;\n\t\t\tbelong[u][v].push_back(0);\n\t\t\tbelong[v][u].push_back(0);\n\t\t}\n\t\tint k = 1;\n\t\tset<vector<int> > s;\n\t\t\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tfor (int j = 0; j < N; j++){\n\t\t\t\tif (P[j] < P[i] && exist[i][j] && belong[i][j].size() < 2){\n\t\t\t\t\tvector<int> v;\n\t\t\t\t\tv.push_back(i);\n\t\t\t\t\tv.push_back(j);\n\t\t\t\t\twhile (1){\n\t\t\t\t\t\tint nextP = -1;\n\t\t\t\t\t\tint vv = v[v.size() - 1], uu = v[v.size() - 2];\n\t\t\t\t\t\tfor (int l = 0; l < to[vv].size(); l++){\n\t\t\t\t\t\t\tif (to[vv][l] == vv || to[vv][l] == uu) continue;\n\t\t\t\t\t\t\tif (ccw(P[uu], P[vv], P[to[vv][l]]) < 0){\n\t\t\t\t\t\t\t\tif (nextP == -1 || getCos(P[uu] - P[vv], P[to[vv][l]] - P[vv]) > getCos(P[uu] - P[vv], P[nextP] - P[vv])) nextP = to[vv][l];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (nextP == -1) for(;;);\n\t\t\t\t\t\tif (nextP == i) break;\n\t\t\t\t\t\tv.push_back(nextP);\n\t\t\t\t\t}\n\t\t\t\t\tvector<int> ss = v;\n\t\t\t\t\tsort(ss.begin(), ss.end());\n\t\t\t\t\tif (s.find(ss) != s.end()) continue;\n\t\t\t\t\telse s.insert(ss);\n\t\t\t\t\tfor (int it = 0; it < v.size(); it++){\n\t\t\t\t\t\tint uu = v[it], vv = v[(it + 1) % v.size()];\n\t\t\t\t\t\tbelong[uu][vv].push_back(k);\n\t\t\t\t\t\tbelong[vv][uu].push_back(k);\n\t\t\t\t\t}\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int> G[1024];\n\t\t\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tfor (int j = i + 1; j < N; j++){\n\t\t\t\tif (belong[i][j].size()){\n\t\t\t\t\tint u = belong[i][j][0], v = belong[i][j][1];\n\t\t\t\t\tG[u].push_back(v);\n\t\t\t\t\tG[v].push_back(u);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tint done[1024];\n\t\tfill(done, done + 1024, -1);\n\t\tqueue<pair<int, int> > q;\n\t\t\n\t\tfor(q.push(make_pair(0, 0)); q.size(); q.pop()){\n\t\t\tpair<int, int> x = q.front();\n\t\t\tif (~done[x.first]) continue;\n\t\t\tdone[x.first] = x.second;\n\t\t\tans = max(ans, x.second);\n\t\t\t\n\t\t\tfor (int i = 0; i < G[x.first].size(); i++){\n\t\t\t\tq.push(make_pair(G[x.first][i], x.second + 1));\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<complex>\n#include<deque>\n#include<vector>\nusing namespace std;\ndouble eps=1e-6;\ndouble x[110];\ndouble y[110];\ndouble px[700];\ndouble py[700];\nint ijk[700];\nint v[700];\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ndouble PI=3.14159265358;\nstruct P{\n\tdouble x;double y;\n\tP(){}\n\tP(double X,double Y){\n\t\tx=X;y=Y;\n\t}\n\tP operator+ (const P &a)const{\n\t\treturn P(x+a.x,y+a.y);\n\t}\n\tP operator- (const P &a)const{\n\t\treturn P(x-a.x,y-a.y);\n\t}\n\tP operator* (const double &a)const{\n\t\treturn P(x*a,y*a);\n\t}\n\t/*operator+ (P a){\n\t\treturn P(x+a.x,y+a.y);\n\t}\n\toperator+ (P a){\n\t\treturn P(x+a.x,y+a.y);\n\t}*/\n\t\n};\ninline bool operator < (const P& a, const P& b) {\n    return a.x<b.x||(a.x==b.x&&a.y<b.y);\n}\ninline double cross(const P& a, const P& b) {\n\treturn a.x*b.y-a.y*b.x;\n}\ninline double dot(const P& a, const P& b) {\n\treturn a.x*b.x+a.y*b.y;\n}\n\ninline int ccw(P a, P b, P c) {\n\tb=b-a;c=c-a;\n\tif (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (b.x*b.x+b.y*b.y<c.x*c.x+c.y*c.y) return -2;       // a--b--c on line\n  return 0;\n}\n#define se second\n#define fi first\n\nbool intersectSS(const pair<P,P> &s, const pair<P,P> &t) {\n  return ccw(s.fi,s.se,t.fi)*ccw(s.fi,s.se,t.se) <= 0 &&\n         ccw(t.fi,t.se,s.fi)*ccw(t.fi,t.se,s.se) <= 0;\n}\n\nP pt[700];\nP ps[300];\nint s[400];\nint t[400];\ndouble left[400];\ndouble right[400];\nvector<pair<int,int> >g[700];\nint UF[700];\nint FIND(int a){\n\tif(UF[a]<0)return a;\n\treturn UF[a]=FIND(UF[a]);\n}\nvoid UNION(int a,int b){\n\ta=FIND(a);b=FIND(b);if(a==b)return;UF[a]+=UF[b];UF[b]=a;\n}\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<700;i++)UF[i]=-1;\n\t\tfor(int i=0;i<700;i++)g[i].clear();\n\t\tfor(int i=0;i<a;i++)scanf(\"%lf%lf\",x+i,y+i);\n\t\tfor(int i=0;i<a;i++){\n\t\t\tdouble X=cos(1)*x[i]-sin(1)*y[i];\n\t\t\tdouble Y=sin(1)*x[i]+cos(1)*y[i];\n\t\t\tx[i]=X;\n\t\t\ty[i]=Y;\n\t\t\tps[i]=P(x[i],y[i]);\n\t\t}\n\t\tfor(int i=0;i<b;i++){\n\t\t\tint p,q;scanf(\"%d%d\",&p,&q);\n\t\t\tp--;q--;\n\t\t\ts[i]=p;t[i]=q;\n\t\t\tpx[i*2]=(x[p]+x[q])/2+eps;\n\t\t\tpy[i*2]=(y[p]+y[q])/2;\n\t\t\tpx[i*2+1]=(x[p]+x[q])/2-eps;\n\t\t\tpy[i*2+1]=(y[p]+y[q])/2;\n\t\t\tpt[i*2]=P(px[i*2],py[i*2]);\n\t\t\tpt[i*2+1]=P(px[i*2+1],py[i*2+1]);\n\t\t}\n\t\tdeque<pair<int,int> >Q;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tvector<pair<double,pair<int,int> > >vec;\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tif(s[j]==i){\n\t\t\t\t\tvec.push_back(make_pair(atan2(y[t[j]]-y[i],x[t[j]]-x[i]),make_pair(j,t[j])));\n\t\t\t\t}\n\t\t\t\tif(t[j]==i){\n\t\t\t\t\tvec.push_back(make_pair(atan2(y[s[j]]-y[i],x[s[j]]-x[i]),make_pair(j,s[j])));\n\t\t\t\t}\n\t\t\t}\n\t\t\tstd::sort(vec.begin(),vec.end());\n\t\t\tint sz=vec.size();\n\t\t\tfor(int j=0;j<vec.size();j++){\n\t\t\t\tdouble th=vec[j].first;\n\t\t\t\tdouble th2=vec[(j+1)%sz].first;\n\t\t\t\tif(th>th2)th2+=2*PI;\n\t\t\t\tif(th2-th<=PI+EPS)continue;\n\t\t\t\tfor(int k=0;k<2;k++)for(int l=0;l<2;l++){\n\t\t\t\t\tif(intersectSS(make_pair(pt[vec[j].second.first*2+k],pt[vec[(j+1)%sz].second.first*2+l]),\n\t\t\t\t\tmake_pair(ps[i],ps[vec[j].second.second]))&&intersectSS(make_pair(pt[vec[j].second.first*2+k],pt[vec[(j+1)%sz].second.first*2+l]),\n\t\t\t\t\tmake_pair(ps[i],ps[vec[(j+1)%sz].second.second]))){\n\t\t\t\t\t\tg[vec[j].second.first*2+k].push_back(make_pair(vec[(j+1)%sz].second.first*2+l,0));\n\t\t\t\t\t\tg[vec[(j+1)%sz].second.first*2+l].push_back(make_pair(vec[j].second.first*2+k,0));\n\t\t\t\t\t\tUNION(vec[j].second.first*2+k,vec[(j+1)%sz].second.first*2+l);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<b*2;i++){\n\t\t\tijk[i]=999999999;\n\t\t\tv[i]=0;\n\t\t\tbool OK=true;\n\t\t\tint tt=s[i/2];\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tif(tt==s[j]||tt==t[j])continue;\n\t\t\t\tif(intersectSS(make_pair(ps[tt],ps[tt]+(pt[i]-ps[tt])*10000.0),make_pair(ps[s[j]],ps[t[j]]))){\n\t\t\t\t\tOK=false;break;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttt=t[i/2];\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tif(tt==s[j]||tt==t[j])continue;\n\t\t\t\tif(intersectSS(make_pair(ps[tt],ps[tt]+(pt[i]-ps[tt])*10000.0),make_pair(ps[s[j]],ps[t[j]]))){\n\t\t\t\t\tOK=false;break;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(OK){\n\t\t\t\tijk[i]=0;\n\t\t\t\tQ.push_back(make_pair(0,i));\n\t\t\t}\n\t\t\tfor(int j=i+1;j<b*2;j++){\n\t\t\t\tint cnt=0;\n\t\t\t\tif(FIND(i)==FIND(j))continue;\n\t\t\t\tfor(int k=0;k<b;k++){\n\t\t\t\t\tif(intersectSS(make_pair(ps[s[k]],ps[t[k]]),make_pair(pt[i],pt[j]))){\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tif(cnt>1)break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(cnt<2){\n\t\t\t\t\tif(cnt==0){\n\t\t\t\t\t\tUNION(i,j);\n\t\t\t\t\t}\n\t\t\t\t\tg[i].push_back(make_pair(j,cnt));\n\t\t\t\t\tg[j].push_back(make_pair(i,cnt));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(Q.size()){\n\t\t\tint cost=-Q.front().first;\n\t\t\tint at=Q.front().second;Q.pop_front();\n\t\t\tif(v[at])continue;\n\t\t\tv[at]=1;\n\t\t\tfor(int i=0;i<g[at].size();i++){\n\t\t\t\tif(!v[g[at][i].first]&&ijk[g[at][i].first]>cost+g[at][i].second){\n\t\t\t\t\tijk[g[at][i].first]=cost+g[at][i].second;\n\t\t\t\t\tif(g[at][i].second==1)Q.push_back(make_pair(-ijk[g[at][i].first],g[at][i].first));\n\t\t\t\t\telse Q.push_front(make_pair(-ijk[g[at][i].first],g[at][i].first));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret=0;\n\t\tfor(int i=0;i<b*2;i++)ret=max(ret,ijk[i]);\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define M_PI (3.141592653589793)\n\nusing namespace std;\n\nconst double EPS = 1e-10;\n\nclass Point{\npublic:\n    double x, y;\n    int id;\n    Point(double x = 0, double y = 0): x(x), y(y){}\n    Point operator + (Point p){return Point(x + p.x, y + p.y);}\n    Point operator - (Point p){return Point(x - p.x, y - p.y);}\n    Point operator * (double a){return Point(x * a, y * a);}\n    Point operator / (double a){return Point(x / a, y / a);}\n    Point operator * (const Point &a){\n        return Point(x * a.x - y * a.y, x * a.y + y * a.x);\n    }\n    bool operator < (const Point &p) const {\n        return (x != p.x ? x < p.x : y < p.y);\n    }\n    bool operator == (const Point &p) const {\n        return (fabs(x - p.x) < EPS && fabs(y - p.y) < EPS);\n    }\n};\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\ndouble dot(Vector a, Vector b){ return (a.x * b.x + a.y * b.y);}\ndouble norm(Vector a){ return (dot(a, a));}\ndouble abs(Vector a){ return (sqrt(norm(a)));}\ndouble cross(Vector a, Vector b){ return (a.x * b.y - a.y * b.x);}\n\nint ccw(Point p0, Point p1, Point p2)\n{\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if (cross(a, b) > EPS) return (+1); //p0, p1, p2 が反時計周り\n    if (cross(a, b) < -EPS) return (-1);//p0, p1, p2 が時計回り\n    if (dot(a, b) < -EPS) return (+2); //p2--p0--p1 の順で一直線上\n    if (norm(a) < norm(b)) return (-2); //p0--p1--p2 の順で一直線上\n    \n    return (0); //p0--p2--p1 の順で一直線上\n}\n\nPolygon conhel(Polygon& ps)\n{\n    sort(ps.begin(), ps.end());\n    int k = 0, n = (int)ps.size();\n    Polygon qs(n * 2);\n    \n    for (int i = 0; i < n; i++){\n        while (k > 1 && cross(qs[k - 1] - qs[k - 2], ps[i] - qs[k - 1]) < -EPS) k--;\n        qs[k++] = ps[i];\n    }\n    \n    for (int i = n - 2, t = k; i >= 0; i--){\n        while (k > t && cross(qs[k - 1] - qs[k - 2], ps[i] - qs[k - 1]) < -EPS) k--;\n        qs[k++] = ps[i];\n    }\n    \n    qs.resize(k - 1);\n    return (qs);\n}\n\ndouble getCos(Vector a, Vector b)\n{\n    return (dot(a, b) / (abs(a) * abs(b)));\n}\n\ndouble getArg(Vector v)\n{\n    return (atan2(v.y, v.x));\n}\n \nPoint rotate(Point t, Point p, double r)\n{\n    double ta = cos(r) * (t.x - p.x) - sin(r) * (t.y - p.y) + p.x;\n    double tb = sin(r) * (t.x - p.x) + cos(r) * (t.y - p.y) + p.y;\n    return (Point(ta, tb));\n}\n \nint main()\n{\n    int N, M;\n    \n    while (scanf(\"%d %d\", &N, &M) && N){\n        vector<Point> P(N);\n        vector<int> to[128];\n        bool exist[128][128] = {0};\n        \n        for (int i = 0; i < N; i++){\n            scanf(\"%lf %lf\", &P[i].x, &P[i].y);\n            P[i].id = i;\n        }\n        \n        for (int i = 0; i < M; i++){\n            int x, y;\n            scanf(\"%d %d\", &x, &y);\n            to[--x].push_back(--y);\n            to[y].push_back(x);\n            exist[x][y] = exist[y][x] = 1;\n        }\n        \n        Polygon Q = P;\n        Q = conhel(Q);\n        \n        vector<int> belong[128][128];\n        for (int i = 0; i < Q.size(); i++){\n            int u = Q[i].id, v = Q[(i + 1) % Q.size()].id;\n            belong[u][v].push_back(0);\n            belong[v][u].push_back(0);\n        }\n        int k = 1;\n        set<vector<int> > s;\n        \n        for (int i = 0; i < N; i++){\n            for (int j = 0; j < N; j++){\n                if (P[j] < P[i] && exist[i][j] && belong[i][j].size() < 2){\n                    vector<int> v;\n                    v.push_back(i);\n                    v.push_back(j);\n                    \n                    while (1){\n                        int nextP = -1;\n                        int vv = v[v.size() - 1], uu = v[v.size() - 2];\n                        for (int l = 0; l < to[vv].size(); l++){\n                            if (to[vv][l] == vv || to[vv][l] == uu) continue;\n                            double thetaT, thetaC;\n                            thetaT = acos(getCos(P[uu] - P[vv], P[to[vv][l]] - P[vv]));\n                            if (ccw(P[uu], P[vv], P[to[vv][l]]) > 0) thetaT = 2 * M_PI - thetaT;\n                            if (nextP != -1){\n                                thetaC = acos(getCos(P[uu] - P[vv], P[nextP] - P[vv]));\n                                if (ccw(P[uu], P[vv], P[nextP]) > 0) thetaC = 2 * M_PI - thetaC;\n                            }\n                            if (nextP == -1 || thetaT < thetaC) nextP = to[vv][l];\n                            \n                        }\n                        if (nextP == i) break;\n                        v.push_back(nextP);\n                    }\n                    vector<int> ss = v;\n                    sort(ss.begin(), ss.end());\n                    ss.erase(unique(ss.begin(), ss.end()), ss.end());\n                    if (s.find(ss) != s.end()) continue;\n                    else s.insert(ss);\n                    for (int it = 0; it < v.size(); it++){\n                        int uu = v[it], vv = v[(it + 1) % v.size()];\n                        belong[uu][vv].push_back(k);\n                        belong[vv][uu].push_back(k);\n                    }\n                    k++;\n                }\n            }\n        }\n        \n        vector<int> G[1024];\n        \n        for (int i = 0; i < N; i++){\n            for (int j = i + 1; j < N; j++){\n                if (belong[i][j].size()){\n                    assert(belong[i][j].size() == 2);\n                    int u = belong[i][j][0], v = belong[i][j][1];\n                    G[u].push_back(v);\n                    G[v].push_back(u);\n                }\n            }\n        }\n        \n        int ans = 0;\n        int done[1024];\n        fill(done, done + 1024, -1);\n        queue<pair<int, int> > q;\n        \n        for(q.push(make_pair(0, 0)); q.size(); q.pop()){\n            pair<int, int> x = q.front();\n            if (~done[x.first]) continue;\n            done[x.first] = x.second;\n            ans = max(ans, x.second);\n            \n            for (int i = 0; i < G[x.first].size(); i++){\n                q.push(make_pair(G[x.first][i], x.second + 1));\n            }\n        }\n        \n        printf(\"%d\\n\", ans);\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX_C 501\n#define MAX_W 501\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:y<p.y; }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const { return p.p1 == p1 && p.p2 == p2; }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a){ os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\nstruct Edge{\n  int from,to,rev,unique_index;\n  Edge(int from=IINF,int to=IINF):from(from),to(to){}\n};\n\nint C,W,sp;\nPoint ps[MAX_C];\nvector<Edge> G[MAX_C];\nvector<vector<int> > poly;\nbool used[MAX_C][MAX_C];\nint depth[MAX_C];\nint index_list[MAX_C][MAX_C];\nvector<int> bfs_G[MAX_C];\n\nbool cmp(const Edge& a,const Edge& b){\n  Vector vec_a = ps[a.to] - ps[a.from];\n  Vector vec_b = ps[b.to] - ps[b.from];\n  return atan2(vec_a.y,vec_a.x) <= atan2(vec_b.y,vec_b.x);\n}\n\nbool getPath(int start_node,int node,int edge,vector<int>& edge_list){\n  if( used[node][edge] ){\n    if( !edge_list.empty() && node == start_node ) return true;\n    return false;\n  }\n  used[node][edge] = true;\n\n  int next_node = G[node][edge].to;\n  int next_edge = (G[node][edge].rev+1)%((int)G[next_node].size());\n  edge_list.push_back(G[node][edge].unique_index);\n  if(getPath(start_node,next_node,next_edge,edge_list)) return true;\n  else return used[node][edge] = false;\n}\n  \nint main(){\n  while(cin>>C>>W,C|W){\n    rep(i,MAX_C)depth[i] = IINF,bfs_G[i].clear(),G[i].clear();\n    rep(i,MAX_C)rep(j,MAX_C)used[i][j] = false, index_list[i][j] = IINF;\n    depth[0] = 0;\n    poly.clear();\n    sp = 0;\n    rep(i,C) {\n      cin >> ps[i].x >> ps[i].y;\n      ps[i].x += 1000, ps[i].y += 1000;\n      if( ps[i] < ps[sp] ) sp = i;\n    }\n\n    rep(i,W) {\n      int s,t;\n      cin >> s >> t;\n      s--,t--;\n      G[s].push_back(Edge(s,t));\n      G[t].push_back(Edge(t,s));\n    }\n    rep(i,C)sort(G[i].begin(),G[i].end(),cmp);\n    int dex = 0;\n    rep(i,C){\n      rep(j,(int)G[i].size()){\n\tint to = G[i][j].to;\n\trep(k,(int)G[to].size()){\n\t  if(G[to][k].to == i){\n\t    G[i][j].rev = k;\n\t    if( index_list[i][j] == IINF ){\n\t      assert(index_list[to][k] == IINF);\n\t      index_list[i][j] = index_list[to][k] = dex++;\n\t    }\n\t    G[i][j].unique_index = index_list[i][j];\n\t    break;\n\t  }\n\t}\n      }\n    }\n    rep(i,(int)G[sp].size()){\n      if( used[sp][i] ) continue;\n      vector<int> tmp;\n      if( getPath(sp,sp,i,tmp) ) {\n\tpoly.push_back(tmp);\n      }\n    }\n\n    rep(i,C){\n      if( i == sp ) continue;\n      rep(j,G[i].size()){\n\tif( used[i][j] ) continue;\n\tvector<int> tmp;\n\tif( getPath(i,i,j,tmp) ){\n\t  poly.push_back(tmp);\n\t}\n      }\n    }\n\n    rep(i,poly.size()){\n      REP(j,i+1,poly.size()){\n\tbool connect = false;\n\trep(k,poly[i].size()){\n\t  rep(l,poly[j].size()){\n\t    if(poly[i][k] == poly[j][l]){\n\t      connect = true;\n\t      goto Skip;\n\t    }\n\t  }\n\t}\n      Skip:;\n\tif(connect){\n\t  bfs_G[i].push_back(j);\n\t  bfs_G[j].push_back(i);\n\t}\n      }\n    }\n\n    int answer = 0;\n    deque<int> deq;\n    deq.push_back(0);\n    while(!deq.empty()){\n      int cur = deq.front(); deq.pop_front();\n      rep(i,bfs_G[cur].size()){\n\tint next = bfs_G[cur][i];\n\tif( depth[next] == IINF ){\n\t  depth[next] = depth[cur] + 1;\n\t  answer = max(answer,depth[next]);\n\t  deq.push_back(next);\n\t}\n      }\n    }\n    cout << answer << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX_C 501\n#define MAX_W 501\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:y<p.y; }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const { return p.p1 == p1 && p.p2 == p2; }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a){ os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\nstruct Edge{\n  int from,to,rev,unique_index;\n  Edge(int from=IINF,int to=IINF):from(from),to(to){}\n};\n\nconst bool DEBUG = false;\nint C,W,sp;\nPoint ps[MAX_C];\nvector<Edge> G[MAX_C];\nvector<vector<int> > poly;\nbool used[MAX_C][MAX_C];\nint depth[MAX_C];\nint index_list[MAX_C][MAX_C];\nvector<int> bfs_G[MAX_C];\n\nbool cmp(const Edge& a,const Edge& b){\n  Vector vec_a = ps[a.to] - ps[a.from];\n  Vector vec_b = ps[b.to] - ps[b.from];\n  return atan2(vec_a.y,vec_a.x) <= atan2(vec_b.y,vec_b.x);\n}\n\nbool getPath(int start_node,int node,int edge,vector<int>& edge_list){\n  if(DEBUG)cout << __LINE__ << \": \" <<  node << \",\" << edge << endl;\n  if( used[node][edge] ){\n    if( !edge_list.empty() && node == start_node ) return true;\n    return false;\n  }\n  used[node][edge] = true;\n\n  int next_node = G[node][edge].to;\n  int next_edge = (G[node][edge].rev+1)%((int)G[next_node].size());\n  edge_list.push_back(G[node][edge].unique_index);\n  if(getPath(start_node,next_node,next_edge,edge_list)){\n    if(DEBUG)cout << __LINE__ << \": path::\"  << node << \",\" << edge << endl;\n    return true;\n  } else {\n    return used[node][edge] = false;\n  }\n}\n  \nint main(){\n  while(cin>>C>>W,C|W){\n    rep(i,MAX_C)depth[i] = IINF,bfs_G[i].clear(),G[i].clear();\n    rep(i,MAX_C)rep(j,MAX_C)used[i][j] = false, index_list[i][j] = IINF;\n    depth[0] = 0;\n    poly.clear();\n    sp = 0;\n    rep(i,C) {\n      cin >> ps[i].x >> ps[i].y;\n      ps[i].x += 1000, ps[i].y += 1000;\n      if( ps[i] < ps[sp] ) sp = i;\n    }\n    rep(i,W) {\n      int s,t;\n      cin >> s >> t;\n      s--,t--;\n      G[s].push_back(Edge(s,t));\n      G[t].push_back(Edge(t,s));\n    }\n    rep(i,C)sort(G[i].begin(),G[i].end(),cmp);\n    int dex = 0;\n    rep(i,C){\n      rep(j,(int)G[i].size()){\n\tint to = G[i][j].to;\n\trep(k,(int)G[to].size()){\n\t  if(G[to][k].to == i){\n\t    G[i][j].rev = k;\n\t    if( index_list[i][j] == IINF ){\n\t      assert(index_list[to][k] == IINF);\n\t      index_list[i][j] = index_list[to][k] = dex++;\n\t    }\n\t    G[i][j].unique_index = index_list[i][j];\n\t    break;\n\t  }\n\t}\n      }\n    }\n    if(DEBUG){\n      cout << __LINE__ << \":\" << endl;\n      cout << \"sp = \" << sp << endl;\n      rep(i,C){\n\tcout << \"i = \" << i << endl;\n\trep(j,G[i].size()){\n\t  cout << \"from = \" << G[i][j].from << \" to = \" << G[i][j].to << \" rev = \" << G[i][j].rev << \" unique = \" << G[i][j].unique_index << endl;\n\t}\n      }\n      cout << endl << endl;\n      rep(i,(int)G[sp].size()){\n\tif( used[sp][i] ) continue;\n\tvector<int> tmp;\n\tif( getPath(sp,sp,i,tmp) ) {\n\t  poly.push_back(tmp);\n\t  cout << \"[\" << sp << \"][\" << i << \"] : getPath!! : \" << endl;\n\t}\n      }\n    }\n    rep(i,C){\n      if( i == sp ) continue;\n      rep(j,G[i].size()){\n\tif( used[i][j] ) continue;\n\tvector<int> tmp;\n\tif( getPath(i,i,j,tmp) ){\n\t  poly.push_back(tmp);\n\t}\n      }\n    }\n\n    rep(i,poly.size()){\n      REP(j,i+1,poly.size()){\n\tbool connect = false;\n\trep(k,poly[i].size()){\n\t  rep(l,poly[j].size()){\n\t    if(poly[i][k] == poly[j][l]){\n\t      connect = true;\n\t      goto Skip;\n\t    }\n\t  }\n\t}\n      Skip:;\n\tif(connect){\n\t  bfs_G[i].push_back(j);\n\t  bfs_G[j].push_back(i);\n\t}\n      }\n    }\n\n    if(DEBUG){\n      cout << __LINE__ << \":\" << endl;\n      cout << \"poly.size() = \" << poly.size() << endl;\n      rep(i,(int)poly.size()){\n\tcout << \"poly[\" << i << \"]\" << endl;\n\trep(j,poly[i].size()){\n\t  cout << poly[i][j] << \" \";\n\t}\n\tcout << endl;\n      }\n\n      cout << \"bfs_G = \" << endl;\n      rep(i,poly.size()){\n\tcout << \"[\" << i << \"]\" << endl;\n\trep(j,bfs_G[i].size()){\n\t  cout << bfs_G[i][j] << \" \";\n\t}\n\tcout << endl;\n      }\n\n      cout << \"depth[\" << 0 << \"] = \" << depth[0] << endl;\n    }\n    int answer = 0;\n    deque<int> deq;\n    deq.push_back(0);\n    while(!deq.empty()){\n      int cur = deq.front(); deq.pop_front();\n      rep(i,bfs_G[cur].size()){\n\tint next = bfs_G[cur][i];\n\tif( depth[next] == IINF ){\n\t  depth[next] = depth[cur] + 1;\n\t  answer = max(answer,depth[next]);\n\t  deq.push_back(next);\n\t}\n      }\n    }\n    cout << answer << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//\n// [not yet accepted]\n//\n#include <iostream>\n#include <vector>\n#include <fstream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <functional>\n#include <ctime>\n#include <numeric>\n#include <unordered_set>\n#include <unordered_map>\n\nusing namespace std;\n\n#define fst first\n#define snd second\n#define all(c) ((c).begin()), ((c).end())\n#define TEST(x,a) { auto y=(x); if (sign(y-a)) { cout << \"line \" << __LINE__  << #x << \" = \" << y << \" != \" << a << endl; exit(-1); } }\n\nconst double EPS = 1e-8;\nint sign(double x) {\n  if (x < -EPS) return -1;\n  if (x > +EPS) return +1;\n  return 0;\n}\nstruct point {\n  typedef double T;\n  T x, y; \n  point &operator+=(point p) { x += p.x; y += p.y; return *this; }\n  point &operator-=(point p) { x -= p.x; y -= p.y; return *this; }\n  point &operator*=(T a)     { x *= a;   y *= a;   return *this; }\n  point &operator/=(T a)     { return *this *= (1.0/a); }\n  point operator-() const    { return {-x, -y}; }\n  bool operator<(point p) const { \n    int s = sign(x - p.x);\n    return s ? s < 0 : sign(y - p.y) < 0;\n  }\n};\nbool operator==(point p, point q) { return !(p < q) && !(q < p); }\npoint operator+(point p, point q) { return p += q; }\npoint operator-(point p, point q) { return p -= q; }\npoint operator*(point::T a, point p) { return p *= a; }\npoint operator*(point p, point::T a) { return p *= a; }\npoint operator/(point p, point::T a) { return p /= a; }\npoint::T dot(point p, point q) { return p.x*q.x+p.y*q.y; }\npoint::T cross(point p, point q) { return p.x*q.y-p.y*q.x; } // left turn > 0\npoint::T norm2(point p) { return dot(p,p); }\npoint orth(point p) { return {-p.y, p.x}; }\npoint::T norm(point p) { return sqrt(dot(p,p)); }\npoint::T arg(point p) { return atan2(p.y, p.x); }\n\nstruct line { point p, q; };\nbool operator==(line l, line m) {\n  return !sign(cross(l.p-l.q,m.p-m.q)) && !sign(cross(l.p-l.q,m.p-l.p));\n}\n\nstruct segment { point p, q; };\nbool operator==(segment l, line m) {\n  return (l.p==m.p && l.q==m.q) || (l.p==m.q && l.q==m.p); // do not consider the direction\n}\nstruct circle { point p; point::T r; };\nbool operator==(circle c, circle d) { return c.p == d.p && !sign(c.r - d.r); }\n\ntypedef vector<point> polygon;\n\nstruct polar_angle {\n  const point o;\n  const int s; // +1 for ccw, -1 for cw\n  polar_angle(point p = {0,0}, int s = +1) : o(p), s(s) { }\n  int quad(point p) const {\n    for (int i = 1; i <= 4; ++i, swap(p.x = -p.x, p.y))\n      if (p.x > 0 && p.y >= 0) return i;\n    return 0;\n  }\n  bool operator()(point p, point q) const {\n    p = p - o; q = q - o;\n    if (quad(p) != quad(q)) return s*quad(p) < s*quad(q);\n    if (cross(p, q)) return s*cross(p, q) > 0;\n    return norm2(p) < norm2(q); // closer first\n  }\n};\n\nvector<point> intersect(segment s, segment t) {\n  auto a = cross(s.q - s.p, t.q - t.p);\n  auto b = cross(t.p - s.p, t.q - t.p); \n  auto c = cross(s.q - s.p, s.p - t.p);\n  if (a < 0) { a = -a; b = -b; c = -c; }\n  if (sign(b) < 0 || sign(a-b) < 0 ||\n      sign(c) < 0 || sign(a-c) < 0) return {};      // disjoint\n  if (sign(a) != 0) return {s.p + b/a*(s.q - s.p)}; // properly crossing\n  vector<point> ps;                                 // same line\n  auto insert_if_possible = [&](point p) {\n    for (auto q: ps) if (sign(dot(p-q, p-q)) == 0) return;\n    ps.push_back(p);\n  };\n  if (sign(dot(s.p-t.p, s.q-t.p)) <= 0) insert_if_possible(t.p);\n  if (sign(dot(s.p-t.q, s.q-t.q)) <= 0) insert_if_possible(t.q);\n  if (sign(dot(t.p-s.p, t.q-s.p)) <= 0) insert_if_possible(s.p);\n  if (sign(dot(t.p-s.q, t.q-s.q)) <= 0) insert_if_possible(s.q);\n  return ps;\n}\n\nstruct arrangement {\n  struct edge {\n    int src, dst;\n    point::T weight;\n    size_t id, rev;\n  };\n  int n;\n  vector<point> ps; // ps[id[p]] = p, id[ps[k]] = k\n  map<point,int> id; \n  vector<vector<edge>> adj;\n\n  arrangement(vector<segment> ss) : n(0) {\n    vector<vector<pair<point::T, int>>> group(ss.size());\n    auto append = [&](int i, point p) {\n      if (!id.count(p)) { id[p] = n++; ps.push_back(p); }\n      group[i].push_back({norm(ss[i].p - p), id[p]});\n    };\n    for (int i = 0; i < ss.size(); ++i) {\n      append(i, ss[i].p); append(i, ss[i].q);\n      for (int j = 0; j < i; ++j) {\n        for (point p: intersect(ss[i], ss[j])) {\n          append(i, p); append(j, p);\n        }\n      }\n    }\n    adj.resize(n);\n    for (auto &vs: group) {\n      sort(all(vs));\n      for (int i = 0; i+1 < vs.size(); ++i) {\n        auto u = vs[i].snd, v = vs[i+1].snd;\n        if (u == v) continue;\n        auto len = vs[i+1].fst - vs[i].fst;\n        adj[u].push_back({u, v, len});\n        adj[v].push_back({v, u, len});\n      }\n    }\n    // remove duplicates and orient edges\n    vector<unordered_map<int, int>> idx(n);\n    for (int u = 0; u < n; ++u) {\n      auto eq = [&](edge e, edge f) { return e.dst == f.dst; };\n      auto lt = [&](edge e, edge f) { return e.dst <  f.dst; };\n      sort(all(adj[u]), lt);\n      adj[u].erase(unique(all(adj[u]), eq), adj[u].end());\n      sort(all(adj[u]), [&](edge e, edge f) {\n        return arg(ps[e.dst] - ps[e.src]) > arg(ps[f.dst] - ps[f.src]);\n      });\n      for (int i = 0; i < adj[u].size(); ++i) {\n        adj[u][i].id = i;\n        int v = adj[u][i].dst;\n        idx[u][v] = i;\n        if (idx[v].count(u)) {\n          int j = idx[v][u];\n          adj[u][i].rev = j;\n          adj[v][j].rev = i;\n        }\n      }\n    }\n  }\n  edge twin(edge e) const { return adj[e.dst][e.rev]; }\n  edge next(edge e) const {\n    int j = adj[e.dst][e.rev].id + 1;\n    if (j >= adj[e.dst].size()) j = 0;\n    return adj[e.dst][j];\n  }\n  edge outer() const {\n    int s = 0;\n    for (int i = 1; i < n; ++i) if (ps[i] < ps[s]) s = i;\n    for (int i = 0; i < adj[s].size(); ++i) {\n      edge e1 = adj[s][i], e2 = adj[s][(i+1)%adj[s].size()];\n      if (cross(ps[e1.dst]-ps[s], ps[e2.dst]-ps[s]) <= 0) return e1;\n    }\n  }\n};\nistream &operator>>(istream &is, point &p) { is>>p.x>>p.y;return is; }\nostream &operator<<(ostream &os, const point &p) { os<<\"(\"<<p.x<<\",\"<<p.y<<\")\"; return os; }\n\n\nstruct visualizer {\n  double minx, maxx, miny, maxy, scale; \n  ofstream ofs;\n  visualizer(string s = \"data.js\") : ofs(s) { \n    minx = miny =  1.0/0.0;\n    maxx = maxy = -1.0/0.0;\n  }\n  void update(point p) {\n    minx = min(minx, p.x); miny = min(miny, p.y);\n    maxx = max(maxx, p.x); maxy = max(maxy, p.y);\n    scale = 480/(max({maxx-minx, maxy-miny,1.0}));\n  }\n  double X(point p) { return scale * (p.x-minx) + 10; }\n  double Y(point p) { return 490 - scale * (p.y-miny); }\n  vector<point> ps;\n  vector<segment> ss;\n  visualizer &operator<<(point p) { ps.push_back(p); update(p); return *this; }\n  visualizer &operator<<(segment s) { ss.push_back(s); update(s.p); update(s.q); return *this; }\n  ~visualizer() {\n    for (point p: ps) \n      ofs << \"circle(\" << X(p) << \",\" << Y(p) << \",3.0)\" << endl;\n    for (segment s: ss) \n      ofs << \"line(\" << X(s.p) << \",\" << Y(s.p) << \",\" \n                     << X(s.q) << \",\" << Y(s.q) << \")\" << endl;\n  }\n};\n\n\nint main() {\n  for (int c, w; ~scanf(\"%d %d\", &c, &w) && c; ) {\n    vector<point> ps(c);\n    for (int i = 0; i < c; ++i) {\n      scanf(\"%lf %lf\", &ps[i].x, &ps[i].y);\n    }\n    vector<segment> ss;\n    for (int i = 0; i < w; ++i) {\n      int u, v; scanf(\"%d %d\", &u, &v);\n      ss.push_back({ps[u-1], ps[v-1]});\n    }\n    arrangement arr(ss);\n    /*\n    visualizer vis;\n    for (int i = 0; i < arr.n; ++i) {\n      cerr << i << \": \" << arr.ps[i] << endl;\n      vis << arr.ps[i];\n      for (auto e: arr.adj[i]) {\n        vis << segment({arr.ps[e.src], arr.ps[e.dst]});\n      }\n    }\n    */\n\n    typedef arrangement::edge edge;\n    edge e = arr.outer(); // outer-face edge\n\n    vector<unordered_map<int,int>> step(arr.n);\n    queue<edge> que;\n    auto proceed = [&](edge s, int value) {\n      if (step[s.src].count(s.dst)) return;\n      //cerr << \"proceed edge \" << arr.ps[e.src] << arr.ps[e.dst] << endl;\n      edge e = s;\n      do {\n        //cerr << \"  mark \" << arr.ps[e.src] << arr.ps[e.dst] << endl;\n        step[e.src][e.dst] = value;\n        que.push(arr.twin(e));\n        e = arr.next(e);\n      } while (e.src != s.src || e.dst != s.dst);\n    };\n    proceed(e, 0);\n    int ans = 0;\n    while (!que.empty()) {\n      edge e = que.front(); que.pop();\n      ans = step[e.dst][e.src];\n      proceed(e, ans + 1);\n    }\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<complex>\n#include<vector>\nusing namespace std;\ndouble eps=1e-7;\ndouble x[110];\ndouble y[110];\ndouble px[700];\ndouble py[700];\nint ijk[700];\nint v[700];\nint g[700][700];\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ndouble PI=3.14159265358;\ntypedef complex<double> P;\ntypedef vector<P> G;\n\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nP pt[700];\nP ps[300];\nint s[400];\nint t[400];\ndouble left[400];\ndouble right[400];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<a;i++)scanf(\"%lf%lf\",x+i,y+i);\n\t\tfor(int i=0;i<a;i++){\n\t\t\tdouble X=cos(1)*x[i]-sin(1)*y[i];\n\t\t\tdouble Y=sin(1)*x[i]+cos(1)*y[i];\n\t\t\tx[i]=X;\n\t\t\ty[i]=Y;\n\t\t\tps[i]=P(x[i],y[i]);\n\t\t\t\n\t\t}\n\t\tfor(int i=0;i<b;i++){\n\t\t\tint p,q;scanf(\"%d%d\",&p,&q);\n\t\t\tp--;q--;\n\t\t\ts[i]=p;t[i]=q;\n\t\t\tpx[i*2]=(x[p]+x[q])/2+eps;\n\t\t\tpy[i*2]=(y[p]+y[q])/2;\n\t\t\tpx[i*2+1]=(x[p]+x[q])/2-eps;\n\t\t\tpy[i*2+1]=(y[p]+y[q])/2;\n\t\t\tpt[i*2]=P(px[i*2],py[i*2]);\n\t\t\tpt[i*2+1]=P(px[i*2+1],py[i*2+1]);\n\t\t}\n\t\t\n\t\tpriority_queue<pair<int,int> >Q;\n\t\tfor(int i=0;i<b*2;i++){\n\t\t\tijk[i]=999999999;\n\t\t\tv[i]=0;\n\t\t\tbool OK=true;\n\t\t\tint tt=s[i/2];\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tif(tt==s[j]||tt==t[j])continue;\n\t\t\t\tif(intersectSS(L(ps[tt],ps[tt]+(pt[i]-ps[tt])*10000.0),L(ps[s[j]],ps[t[j]]))){\n\t\t\t\t\tOK=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(OK){\n\t\t//\t\tprintf(\" %d\\n\",i);\n\t\t\t\tijk[i]=0;\n\t\t\t\tQ.push(make_pair(0,i));\n\t\t\t}\n\t\t\tfor(int j=0;j<b*2;j++){\n\t\t\t\tif(i==j){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint cnt=0;\n\t\t\t\tfor(int k=0;k<b;k++){\n\t\t\t\t\tif(intersectSS(L(ps[s[k]],ps[t[k]]),L(pt[i],pt[j]))){\n\t\t//\t\t\t\tprintf(\"(%f,%f) (%f,%f): (%f,%f), (%f,%f)\\n\",px[i],py[i],px[j],py[j],x[s[k]],y[s[k]],x[t[k]],y[t[k]]);\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tif(cnt>1)break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(cnt<2)g[i][j]=cnt;\n\t\t\t}\n\t\t}\n\t\twhile(Q.size()){\n\t\t\tint cost=-Q.top().first;\n\t\t\tint at=Q.top().second;Q.pop();\n\t\t\tif(v[at])continue;\n\t\t\tv[at]=1;\n\t\t\tfor(int i=0;i<b*2;i++){\n\t\t\t\tif(!v[i]&&ijk[i]>cost+g[at][i]){\n\t\t\t\t\tijk[i]=cost+g[at][i];\n\t\t\t\t\tQ.push(make_pair(-ijk[i],i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret=0;\n\t\tfor(int i=0;i<b*2;i++)ret=max(ret,ijk[i]);\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<complex>\n#include<deque>\n#include<vector>\nusing namespace std;\ndouble eps=1e-6;\ndouble x[110];\ndouble y[110];\ndouble px[700];\ndouble py[700];\nint ijk[700];\nint v[700];\nint g[700][700];\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ndouble PI=3.14159265358;\nstruct P{\n\tdouble x;double y;\n\tP(){}\n\tP(double X,double Y){\n\t\tx=X;y=Y;\n\t}\n\tP operator+ (const P &a)const{\n\t\treturn P(x+a.x,y+a.y);\n\t}\n\tP operator- (const P &a)const{\n\t\treturn P(x-a.x,y-a.y);\n\t}\n\tP operator* (const double &a)const{\n\t\treturn P(x*a,y*a);\n\t}\n\t/*operator+ (P a){\n\t\treturn P(x+a.x,y+a.y);\n\t}\n\toperator+ (P a){\n\t\treturn P(x+a.x,y+a.y);\n\t}*/\n\t\n};\n  bool operator < (const P& a, const P& b) {\n    return a.x<b.x||(a.x==b.x&&a.y<b.y);\n  }\ndouble cross(const P& a, const P& b) {\n\treturn a.x*b.y-a.y*b.x;\n}\ndouble dot(const P& a, const P& b) {\n\treturn a.x*b.x+a.y*b.y;\n}\n\nint ccw(P a, P b, P c) {\n\tb=b-a;c=c-a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (b.x*b.x+b.y*b.y<c.x*c.x+c.y*c.y) return -2;       // a--b--c on line\n  return 0;\n}\n#define se second\n#define fi first\n\nbool intersectSS(const pair<P,P> &s, const pair<P,P> &t) {\n  return ccw(s.fi,s.se,t.fi)*ccw(s.fi,s.se,t.se) <= 0 &&\n         ccw(t.fi,t.se,s.fi)*ccw(t.fi,t.se,s.se) <= 0;\n}\n\nP pt[700];\nP ps[300];\nint s[400];\nint t[400];\ndouble left[400];\ndouble right[400];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<a;i++)scanf(\"%lf%lf\",x+i,y+i);\n\t\tfor(int i=0;i<a;i++){\n\t\t\tdouble X=cos(1)*x[i]-sin(1)*y[i];\n\t\t\tdouble Y=sin(1)*x[i]+cos(1)*y[i];\n\t\t\tx[i]=X;\n\t\t\ty[i]=Y;\n\t\t\tps[i]=P(x[i],y[i]);\n\t\t}\n\t\tfor(int i=0;i<b;i++){\n\t\t\tint p,q;scanf(\"%d%d\",&p,&q);\n\t\t\tp--;q--;\n\t\t\ts[i]=p;t[i]=q;\n\t\t\tpx[i*2]=(x[p]+x[q])/2+eps;\n\t\t\tpy[i*2]=(y[p]+y[q])/2;\n\t\t\tpx[i*2+1]=(x[p]+x[q])/2-eps;\n\t\t\tpy[i*2+1]=(y[p]+y[q])/2;\n\t\t\tpt[i*2]=P(px[i*2],py[i*2]);\n\t\t\tpt[i*2+1]=P(px[i*2+1],py[i*2+1]);\n\t\t}\n\t\tdeque<pair<int,int> >Q;\n\t\tfor(int i=0;i<b*2;i++)for(int j=i+1;j<b*2;j++)g[i][j]=g[j][i]=999999999;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tvector<pair<double,pair<int,int> > >vec;\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tif(s[j]==i){\n\t\t\t\t\tvec.push_back(make_pair(atan2(y[t[j]]-y[i],x[t[j]]-x[i]),make_pair(j,t[j])));\n\t\t\t\t}\n\t\t\t\tif(t[j]==i){\n\t\t\t\t\tvec.push_back(make_pair(atan2(y[s[j]]-y[i],x[s[j]]-x[i]),make_pair(j,s[j])));\n\t\t\t\t}\n\t\t\t}\n\t\t\tstd::sort(vec.begin(),vec.end());\n\t\t\tint sz=vec.size();\n\t\t\tfor(int j=0;j<vec.size();j++){\n\t\t\t\tdouble th=vec[j].first;\n\t\t\t\tdouble th2=vec[(j+1)%sz].first;\n\t\t\t\tif(th>th2)th2+=2*PI;\n\t\t\t\tif(th2-th<=PI+EPS)continue;\n\t\t\t\tfor(int k=0;k<2;k++)for(int l=0;l<2;l++){\n\t\t\t\t\tif(intersectSS(make_pair(pt[vec[j].second.first*2+k],pt[vec[(j+1)%sz].second.first*2+l]),\n\t\t\t\t\tmake_pair(ps[i],ps[vec[j].second.second]))&&intersectSS(make_pair(pt[vec[j].second.first*2+k],pt[vec[(j+1)%sz].second.first*2+l]),\n\t\t\t\t\tmake_pair(ps[i],ps[vec[(j+1)%sz].second.second]))){\n\t\t\t\t\t\tg[vec[j].second.first*2+k][vec[(j+1)%sz].second.first*2+l]=g[vec[(j+1)%sz].second.first*2+l][vec[j].second.first*2+k]=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<b*2;i++){\n\t\t\tijk[i]=999999999;\n\t\t\tv[i]=0;\n\t\t\tbool OK=true;\n\t\t\tint tt=s[i/2];\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tif(tt==s[j]||tt==t[j])continue;\n\t\t\t\tif(intersectSS(make_pair(ps[tt],ps[tt]+(pt[i]-ps[tt])*10000.0),make_pair(ps[s[j]],ps[t[j]]))){\n\t\t\t\t\tOK=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttt=t[i/2];\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tif(tt==s[j]||tt==t[j])continue;\n\t\t\t\tif(intersectSS(make_pair(ps[tt],ps[tt]+(pt[i]-ps[tt])*10000.0),make_pair(ps[s[j]],ps[t[j]]))){\n\t\t\t\t\tOK=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(OK){\n\t\t\t\tijk[i]=0;\n\t\t\t\tQ.push_back(make_pair(0,i));\n\t\t\t}\n\t\t\tfor(int j=i+1;j<b*2;j++){\n\t\t\t\tint cnt=0;\n\t\t\t\tfor(int k=0;k<b;k++){\n\t\t\t\t\tif(intersectSS(make_pair(ps[s[k]],ps[t[k]]),make_pair(pt[i],pt[j]))){\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tif(cnt>1)break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(cnt<2)g[i][j]=g[j][i]=cnt;\n\t\t\t}\n\t\t}\n\t\twhile(Q.size()){\n\t\t\tint cost=-Q.front().first;\n\t\t\tint at=Q.front().second;Q.pop_front();\n\t\t\tif(v[at])continue;\n\t\t\tv[at]=1;\n\t\t\tfor(int i=0;i<b*2;i++){\n\t\t\t\tif(!v[i]&&ijk[i]>cost+g[at][i]){\n\t\t\t\t\tijk[i]=cost+g[at][i];\n\t\t\t\t\tif(g[at][i]==1)Q.push_back(make_pair(-ijk[i],i));\n\t\t\t\t\telse Q.push_front(make_pair(-ijk[i],i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret=0;\n\t\tfor(int i=0;i<b*2;i++)ret=max(ret,ijk[i]);\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#include <climits>\n\nusing namespace std;\n\ntypedef long long lint;\n\n//定数\nconst double EPS = 1e-10;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\nconst int INF = 1001001001;\nconst lint INFLL = 1001001001001001001ll;\n\n//初期化関連\n#define zclear(a) memset((a), 0 ,sizeof(a))\n#define mclear(a) memset((a), -1, sizeof(a))\n\n//デバッグ出力\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nbool eq(double a, double b) //a == b\n{\n    return (fabs(a - b) <= EPS);\n}\n\nbool neq(double a, double b) //a == b\n{\n    return (!eq(a, b));\n}\n  \nbool lt(double a, double b) //a < b\n{\n    return (a - b < -EPS);\n}\n  \nbool leq(double a, double b) //a <= b\n{\n    return (lt(a, b) || eq(a, b));\n}\n  \nbool gt(double a, double b) //a > b\n{\n    return (a - b > +EPS);\n}\n  \nbool geq(double a, double b) //a >= b\n{\n    return (gt(a, b) || eq(a, b));\n}\n\nclass Point{\npublic:\n\tdouble x, y;\n\tint id;\n\tPoint(double x = 0, double y = 0): x(x), y(y){}\n\tPoint operator + (Point p){return Point(x + p.x, y + p.y);}\n\tPoint operator - (Point p){return Point(x - p.x, y - p.y);}\n\tPoint operator * (double a){return Point(x * a, y * a);}\n\tPoint operator / (double a){return Point(x / a, y / a);}\n\tPoint operator * (const Point &a){\n\t\treturn Point(x * a.x - y * a.y, x * a.y + y * a.x);\n\t}\n\tbool operator < (const Point &p) const {\n\t\treturn (x != p.x ? x < p.x : y < p.y);\n\t}\n\tbool operator == (const Point &p) const {\n\t\treturn (fabs(x - p.x) < EPS && fabs(y - p.y) < EPS);\n\t}\n};\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\ndouble norm(Vector a){return (a.x * a.x + a.y * a.y);}\ndouble abs(Vector a){return (sqrt(norm(a)));}\ndouble abs(Vector a, Vector b){return (sqrt(norm(a - b)));}\ndouble dot(Vector a, Vector b){return (a.x * b.x + a.y * b.y);}\ndouble cross(Vector a, Vector b){return (a.x * b.y - a.y * b.x);}\ndouble atan(Vector a){return atan2(a.y, a.x);}\nbool sortX(Point a, Point b){return (a.x != b.x ? lt(a.x, b.x) : lt(a.y, b.y));}\nbool sortY(Point a, Point b){return (a.y != b.y ? lt(a.y, b.y) : lt(a.x, b.x));}\nPoint p;\nbool sortT(Point a, Point b){return (gt(cross(a - p, b - p), 0));}\n\nint ccw(Point p0, Point p1, Point p2)\n{\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > EPS) return (+1); //p0, p1, p2 が反時計周り\n\tif (cross(a, b) < -EPS) return (-1);//p0, p1, p2 が時計回り\n\tif (dot(a, b) < -EPS) return (+2); //p2--p0--p1 の順で一直線上\n\tif (norm(a) < norm(b)) return (-2); //p0--p1--p2 の順で一直線上\n\treturn (0); //p0--p2--p1 の順で一直線上\n}\n\nPolygon normalize(Polygon &v)\n{\n    int pt = 0;\n    for (int i = 1; i < v.size(); i++){\n        if (v[pt].y > v[i].y || (v[pt].y == v[i].y && v[pt].x > v[i].x)){\n            pt = i;\n        }\n    }\n    swap(v[pt], v[0]);\n    p = v[0];\n    sort(v.begin() + 1, v.end(), sortT);\n    return (v);\n}\n\nPolygon conhel(Polygon& ps)\n{\n    sort(ps.begin(), ps.end());\n    int k = 0, n = (int)ps.size();\n    Polygon qs(n * 2);\n      \n    for (int i = 0; i < n; i++){\n      while (k > 1 && cross(qs[k - 1] - qs[k - 2], ps[i] - qs[k - 1]) < -EPS) k--;\n      qs[k++] = ps[i];\n    }\n  \n    for (int i = n - 2, t = k; i >= 0; i--){\n      while (k > t && cross(qs[k - 1] - qs[k - 2], ps[i] - qs[k - 1]) < -EPS) k--;\n      qs[k++] = ps[i];\n    }\n  \n    qs.resize(k - 1);\n    return (qs);\n}\n\ndouble getArea(Polygon t){\n    double ans = 0.0;\n\tt = normalize(t);\n    for (unsigned int i = 0; i < t.size(); i++)\n        ans += cross(t[i] , t[(i + 1) % t.size()]);\n    return (fabs(ans) / 2);\n}\n\nbool isIntersectLL(Point p1, Point p2, Point p3, Point p4)\n{// 同一直線の場合は交差していると判定する.\n\treturn (abs(cross(p2 - p1, p4 - p3)) > EPS || // 傾きが異なる\n\t\tabs(cross(p2 - p1, p4 - p3)) < EPS); // 同じ直線である\n}\nbool isIntersectLS(Point p1, Point p2, Point p3, Point p4)\n{// 同一直線上にある場合も交差と判定\n\treturn (cross(p2 - p1, p3 - p1) * cross(p2 - p1, p4 - p1) < EPS);\n}\nbool isIntersectLP(Point p1, Point p2, Point p)\n{\n\treturn (neq(abs(ccw(p1, p2, p)), 1));\n}\nbool isIntersectSS(Point p1, Point p2, Point p3, Point p4)\n{\n    return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n             ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool isIntersectSP(Point p1, Point p2, Point p)\n{\n\treturn (eq(ccw(p1, p2, p), 0));\n}\nbool isInsideCP(Point c, double r, Point p)\n{\n\treturn (leq(abs(c - p), r));\n}\nbool isInsideCC(Point c1, double r1, Point c2, double r2)\n{\n\treturn (leq(abs(c1 - c2), r1 + r2) && geq(abs(c1 - c2), abs(r1 - r2)));\n}\nbool isInsidePolyP(Polygon gon, Point p)\n{\n    for (int i = 0; i < gon.size(); i++){\n        if (ccw(gon[i], gon[(i + 1) % gon.size()], p) == -1) return (false);\n    }\n    return (true);\n}\n\nPoint projection(Point p1, Point p2, Point p3) //直線p1p2 上への写像\n{\n\tdouble t = dot(p3 - p1, p2 - p1) / norm(p2 - p1);\n\treturn (p1 + (p2 - p1) * t);\n}\nPoint reflection(Point p1, Point p2, Point p3) //直線p1p2 上への反射\n{\n\treturn (p3 + (projection(p1, p2, p3) - p) * 2);\n}\ndouble distanceLP(Point p1, Point p2, Point p)\n{\n\treturn (abs(p - projection(p1, p2, p)));\n}\ndouble distanceLL(Point l1, Point l2, Point m1, Point m2)\n{\n\treturn (isIntersectLL(l1, l2, m1, m2) ? 0 : distanceLP(l1, l2, m1));\n}\ndouble distanceLS(Point l1, Point l2, Point s1, Point s2)\n{\n    if (isIntersectLS(l1, l2, s1, s2)) return (0);\n\treturn (min(distanceLP(l1, l2, s1), distanceLP(l1, l2, s2)));\n}\ndouble distanceSP(Point s1, Point s2, Point p)\n{\n\tPoint r = projection(s1, s2, p);\n\tif (isIntersectSP(s1, s2, r)) return (abs(r - p));\n\treturn (min(abs(s1 - p), abs(s2 - p)));\n}\ndouble distanceSS(Point s1, Point s2, Point t1, Point t2){\n\tif (isIntersectSS(s1, s2, t1, t2)) return (0);\n\treturn (min(min(distanceSP(s1, s2, t1), distanceSP(s1, s2, t2)),\n\t\t\tmin(distanceSP(t1, t2, s1), distanceSP(t1, t2, s2))));\n}\nPoint interPointLL(Point a1, Point a2, Point b1, Point b2)\n{\n\tdouble d = cross(a2 - a1, b2 - b1);\n\tif (abs(d) < EPS) throw \"Segment is Paralell!\";\n\tPoint a = a2 - a1, b = b2 - b1;\n    double t = cross(b, b1 - a1) / cross(b, a);\n    return (a1 + a * t);\n}\nvector<Point> interPointCC(Point c1, double r1, Point c2, double r2)\n{\n\tvector<Point> res;\n\tif (abs(c1 - c2) < EPS) return (vector<Point>()); // 交点が絶対にない\n\tdouble d = abs(c1 - c2);\n\tdouble rc = (d * d + r1 * r1 - r2 * r2) / (2 * d);\n\tdouble rs = sqrt(r1 * r1 - rc * rc);\n\tPoint diff = (c2 - c1) / d;\n\tres.push_back(Point(c1 + diff * Point(rc, rs)));\n\tres.push_back(Point(c1 + diff * Point(rc, -rs)));\n\treturn (res);\n}\nvector<Point> crosspointCL(Point a, double ra, Point b1, Point b2)\n{\n\tvector<Point> res;\n\tdouble dist = distanceLP(b1, b2, a);\n\tif (leq(dist, ra)){\n\t\tPoint s = projection(b1, b2, a);\n\t\tdist = sqrt(ra * ra - dist * dist);\n\t\tPoint t = (b2 - b1) / abs(b2 - b1);\n\t\tres.push_back(s + t * dist);\n\t\tres.push_back(s - t * dist);\n\t}\n\treturn (res);\n}\n\nPoint unitVector(Vector t)\n{\n    double u = abs(t);\n    return (Point(t.x / u , t.y / u));\n}\n\nPoint normalVector(Point p, Point a, Point b)\n{\n    Point v = unitVector(b - a);\n    v = cross(v, p - a) > 0 ? Point(v.y, -v.x) : Point(-v.y, v.x);\n    return v * distanceLP(p, a, b);\n}\n  \ndouble getCos(Vector a, Vector b)\n{\n    return (dot(a, b) / (abs(a) * abs(b)));\n}\n  \ndouble getSin(Vector a, Vector b)\n{\n    double t = getCos(a, b);\n    return (sqrt(1.0 - t * t));\n}\n  \ndouble getArg(Vector v)\n{\n    return (atan2(v.y, v.x));\n}\n\nPoint rotate(Point t, Point p, double r)\n{\n    double ta = cos(r) * (t.x - p.x) - sin(r) * (t.y - p.y) + p.x;\n    double tb = sin(r) * (t.x - p.x) + cos(r) * (t.y - p.y) + p.y;\n    return (Point(ta, tb));\n}\n\nint main()\n{\n\tint N, M;\n\t\n\twhile (scanf(\"%d %d\", &N, &M) && N){\n\t\tvector<Point> P(N);\n\t\tvector<int> to[128];\n\t\tbool exist[128][128] = {0};\n\t\t\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tscanf(\"%lf %lf\", &P[i].x, &P[i].y);\n\t\t\tP[i].id = i;\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < M; i++){\n\t\t\tint x, y;\n\t\t\tscanf(\"%d %d\", &x, &y);\n\t\t\tto[--x].push_back(--y);\n\t\t\tto[y].push_back(x);\n\t\t\texist[x][y] = exist[y][x] = 1;\n\t\t}\n\t\t\n\t\tPolygon Q = P;\n\t\tQ = conhel(Q);\n\t\t\n\t\tvector<int> belong[128][128];\n\t\tfor (int i = 0; i < Q.size(); i++){\n\t\t\tint u = Q[i].id, v = Q[(i + 1) % Q.size()].id;\n\t\t\tbelong[u][v].push_back(0);\n\t\t\tbelong[v][u].push_back(0);\n\t\t}\n\t\tint k = 1;\n\t\tset<vector<int> > s;\n\t\t\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tfor (int j = 0; j < N; j++){\n\t\t\t\tif (P[j] < P[i] && exist[i][j] && belong[i][j].size() < 2){\n\t\t\t\t\tvector<int> v;\n\t\t\t\t\tv.push_back(i);\n\t\t\t\t\tv.push_back(j);\n\t\t\t\t\twhile (1){\n\t\t\t\t\t\tint nextP = -1;\n\t\t\t\t\t\tint vv = v[v.size() - 1], uu = v[v.size() - 2];\n\t\t\t\t\t\tfor (int l = 0; l < to[vv].size(); l++){\n\t\t\t\t\t\t\tif (to[vv][l] == vv || to[vv][l] == uu) continue;\n\t\t\t\t\t\t\tdouble thetaT, thetaC;\n\t\t\t\t\t\t\tthetaT = acos(getCos(P[uu] - P[vv], P[to[vv][l]] - P[vv]));\n\t\t\t\t\t\t\tif (ccw(P[uu], P[vv], P[to[vv][l]]) > 0) thetaT = 2 * M_PI - thetaT;\n\t\t\t\t\t\t\tif (nextP != -1){\n\t\t\t\t\t\t\t\tthetaC = acos(getCos(P[uu] - P[vv], P[nextP] - P[vv]));\n\t\t\t\t\t\t\t\tif (ccw(P[uu], P[vv], P[nextP]) > 0) thetaC = 2 * M_PI - thetaC;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (nextP == -1 || lt(thetaT, thetaC)) nextP = to[vv][l];\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (nextP == i) break;\n\t\t\t\t\t\tv.push_back(nextP);\n\t\t\t\t\t}\n\t\t\t\t\tvector<int> ss = v;\n\t\t\t\t\tsort(ss.begin(), ss.end());\n\t\t\t\t\tif (s.find(ss) != s.end()) continue;\n\t\t\t\t\telse s.insert(ss);\n\t\t\t\t\tfor (int it = 0; it < v.size(); it++){\n\t\t\t\t\t\tint uu = v[it], vv = v[(it + 1) % v.size()];\n\t\t\t\t\t\tbelong[uu][vv].push_back(k);\n\t\t\t\t\t\tbelong[vv][uu].push_back(k);\n\t\t\t\t\t}\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int> G[1024];\n\t\t\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tfor (int j = i + 1; j < N; j++){\n\t\t\t\tif (belong[i][j].size()){\n\t\t\t\t\tassert(belong[i][j].size() == 2);\n\t\t\t\t\tint u = belong[i][j][0], v = belong[i][j][1];\n\t\t\t\t\tG[u].push_back(v);\n\t\t\t\t\tG[v].push_back(u);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tint done[1024];\n\t\tfill(done, done + 1024, -1);\n\t\tqueue<pair<int, int> > q;\n\t\t\n\t\tfor(q.push(make_pair(0, 0)); q.size(); q.pop()){\n\t\t\tpair<int, int> x = q.front();\n\t\t\tif (~done[x.first]) continue;\n\t\t\tdone[x.first] = x.second;\n\t\t\tans = max(ans, x.second);\n\t\t\t\n\t\t\tfor (int i = 0; i < G[x.first].size(); i++){\n\t\t\t\tq.push(make_pair(G[x.first][i], x.second + 1));\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\n \nconst double INF = 1e12;\ntypedef complex<double> P,point;\ntypedef vector<P> G,polygon;\nnamespace std {bool operator < (const P& a, const P& b) {return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);} }\ndouble cross(const P& a, const P& b) {return imag(conj(a)*b);}\ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\n\nint main(){\n\tint C,W;\n\twhile(cin >> C >> W && C){\n\t\tvector<P> p(C);\n\t\tfor(int i = 0 ; i < C ; i++) cin >> p[i].real() >> p[i].imag();\n\t\tmap< P,vector<P> > g;\n\t\tvector< pair<P,P> > e;\n\t\tfor(int i = 0 ; i < W ; i++){\n\t\t\tint a,b;\n\t\t\tcin >> a >> b;\n\t\t\ta--,b--;\n\t\t\tg[p[a]].push_back(p[b]);\n\t\t\tg[p[b]].push_back(p[a]);\n\t\t\te.push_back(make_pair(p[a],p[b]));\n\t\t\te.push_back(make_pair(p[b],p[a]));\n\t\t}\n\t\t//e.clear();\n\t\t//e.push_back(make_pair(P(8,0),P(4,0)));\n\t\tvector< vector<P> > wall;\n\t\tset< vector<P> > already;\n\t\t\n\t\tfor(int j = 0 ; j < e.size() ; j++){\n\t\t\tP A = e[j].first;\n\t\t\tP B = e[j].second;\n\t\t\tvector<P> chain;\n\t\t\tchain.push_back(A);\n\t\t\tint fail = 0;\n\t\t\tdo{\n\t\t\t\tchain.push_back(B);\n\t\t\t\tvector< pair<double,P> > pos;\n\t\t\t\tfor(int i = 0 ; i < g[B].size() ; i++){\n\t\t\t\t\tif( g[B][i] != A && cross(B-A,g[B][i]-A) >= 0 ){\n\t\t\t\t\t\tP s = A-B;\n\t\t\t\t\t\tP t = g[B][i]-B;\n\t\t\t\t\t\tdouble tmp = acos(dot(s,t) / abs(s) / abs(t)); \n\t\t\t\t\t\t//cout << g[B][i] << \" \" << tmp << endl;\n\t\t\t\t\t\tpos.push_back(make_pair(tmp,g[B][i]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsort(pos.begin(),pos.end());\n\t\t\t\tif( pos.size() == 0 ){ fail = 1; break; }\n\t\t\t\tA = pos[0].second;\n\t\t\t\tswap(A,B);\n\t\t\t}while( B != e[j].first );\n\t\t\tif( fail ){\n\t\t\t\t//for(int i = 0 ; i < chain.size() ; i++) cout << chain[i] << \" \"; cout << endl; \n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvector<P> key = chain;\n\t\t\tsort(key.begin(),key.end());\n\t\t\tif( !already.count(key) ){\n\t\t\t\twall.push_back(chain);\n\t\t\t\talready.insert(key);\n\t\t\t\t//for(int i = 0 ; i < chain.size() ; i++) cout << chain[i] << \" \"; cout << endl;\n\t\t\t}\n\t\t}\n\t\tvector< vector<int> > wf(wall.size()+1,vector<int>(wall.size()+1));\n\t\tfor(int i = 0 ; i < wf.size() ; i++)\n\t\t\tfor(int j = 0 ; j < wf.size() ; j++)\n\t\t\t\twf[i][j] = i != j ? 1e9 : 0;\n\t\tset< pair<P,P> > usedEdge;\n\t\tfor(int i = 0 ; i < wall.size() ; i++){\n\t\t\tfor(int j = 0 ; j < wall.size() ; j++){\n\t\t\t\tif( i != j ) {\n\t\t\t\t\tset< pair<P,P> > tmp;\n\t\t\t\t\tfor(int k = 0 ; k < wall[i].size() ; k++){\n\t\t\t\t\t\tP a = wall[i][k] , b = wall[i][(k+1)%wall[i].size()];\n\t\t\t\t\t\tif( b < a ) swap(a,b);\n\t\t\t\t\t\ttmp.insert(make_pair(a,b));\n\t\t\t\t\t}\n\t\t\t\t\tint connect = 0;\n\t\t\t\t\tfor(int k = 0 ; k < wall[j].size() ; k++){\n\t\t\t\t\t\tP a = wall[j][k] , b = wall[j][(k+1)%wall[j].size()];\n\t\t\t\t\t\tif( b < a ) swap(a,b);\n\t\t\t\t\t\tif( tmp.count( make_pair(a,b) ) ){\n\t\t\t\t\t\t\tconnect = 1;\n\t\t\t\t\t\t\tusedEdge.insert(make_pair(a,b));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif( connect ) wf[i][j] = wf[j][i] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0 ; i < wall.size() ; i++){\n\t\t\tint connectOutside = 0;\n\t\t\tfor(int k = 0 ; k < wall[i].size() ; k++){\n\t\t\t\tP a = wall[i][k] , b = wall[i][(k+1)%wall[i].size()];\n\t\t\t\tif( b < a ) swap(a,b);\n\t\t\t\tif( !usedEdge.count( make_pair(a,b) ) ) connectOutside = 1;\n\t\t\t}\n\t\t\tif(connectOutside)wf[wall.size()][i] = wf[i][wall.size()] = 1;\n\t\t}\n\t\tfor(int i = 0 ; i < wf.size() ; i++)\n\t\t\tfor(int j = 0 ; j < wf.size() ; j++)\n\t\t\t\tfor(int k = 0 ; k < wf.size() ; k++)\n\t\t\t\t\twf[j][k] = min(wf[j][k],wf[j][i]+wf[i][k]);\n\t\tint res = -1e9;\n\t\tfor(int i = 0 ; i < wall.size() ; i++)\n\t\t\tres = max(res,wf[wall.size()][i]);\n\t\tcout << res << endl;\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef LOCAL\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\nusing namespace std;\n\nstruct point {\n\tint x, y;\n\texplicit point(double x_ = 0.0, double y_ = 0.0):x(x_), y(y_) {}\n\tpoint(const point &p):x(p.x), y(p.y) {}\n\n\tpoint operator+(const point &p) const {\n\t\treturn point(x + p.x, y + p.y);\n\t}\n\n\tpoint operator-(const point &p) const {\n\t\treturn point(x - p.x, y - p.y);\n\t}\n\n\tpoint operator*(double s) const {\n\t\treturn point(x * s, y * s);\n\t}\n\n\tpoint operator*(const point &p) const {\n\t\treturn point(x * p.x - y * p.y, x * p.y + y * p.x);\n\t}\n\n\tpoint operator/(double s) const {\n\t\treturn point(x / s, y / s);\n\t}\n\n\tbool operator<(const point &p) const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator==(const point &p) const {\n\t\treturn x == p.x && y == p.y;\n\t}\n};\n\ninline double angle(const point &p) {\n\treturn atan2(p.y, p.x);\n}\n\ninline int cross(const point &a, const point &b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\nstruct segment {\n\tpoint a, b;\n\tsegment(const point &a_, const point &b_):a(a_), b(b_){}\n};\n\nstruct edge {\n\tint to;\n\tdouble theta;\n\tbool used;\n\tedge(int to_, double theta_):to(to_), theta(theta_), used(false) {}\n\n\tinline bool operator<(const edge &e) const {\n\t\treturn theta < e.theta;\n\t}\n};\n\ninline istream &operator>>(istream &is, point &p){\n\treturn is >> p.x >> p.y;\n}\n\ninline ostream &operator<<(ostream &os, const point &p){\n\treturn os << make_pair(p.x, p.y);\n}\n\ninline bool outside(const vector<int> &P, const vector<point> &points) {\n\tconst int n = P.size();\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tconst point &a = points[P[i]];\n\t\tconst point &b = points[P[(i + 1) % n]];\n\t\tconst point &c = points[P[(i + 2) % n]];\n\n\t\tconst int tmp = cross(b - a, c - a);\n\t\tif(tmp != 0) return tmp > 0;\n\t}\n\tassert(false);\n}\n\ninline bool neighbor(const vector<int> &a, const vector<int> &b) {\n\tint pa = a.back();\n\tfor(const auto &ca : a) {\n\n\t\tint pb = b.back();\n\t\tfor(const auto &cb : b) {\n\t\t\tif((pa == pb && ca == cb) || (pa == cb && ca == pb)) return true;\n\t\t\tpb = cb;\n\t\t}\n\n\t\tpa = ca;\n\t}\n\treturn false;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tfor(int n, m; cin >> n >> m && n;) {\n\t\tvector<point> points(n);\n\t\tfor(auto &e : points) cin >> e;\n\n\t\tvector<vector<edge>> G(n);\n\t\tfor(int i = 0; i < m; ++i) {\n\t\t\tint s, t;\n\t\t\tcin >> s >> t;\n\t\t\t--s; --t;\n\t\t\tG[s].emplace_back(t, angle(points[t] - points[s]));\n\t\t\tG[t].emplace_back(s, angle(points[s] - points[t]));\n\t\t}\n\n\t\tfor(auto &edges : G) sort(begin(edges), end(edges));\n\n\t\tint s = -1;\n\n\t\tconst int V = 2 + m - n;\n\t\tvector<vector<int>> faces;\n\t\tfaces.reserve(V);\n\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tfor(int j = 0; j < static_cast<int>(G[i].size()); ++j) {\n\t\t\t\tint v = i;\n\t\t\t\tint e_idx = j;\n\n\t\t\t\tvector<int> P;\n\t\t\t\twhile(true) {\n\t\t\t\t\tedge &e = G[v][e_idx];\n\t\t\t\t\tif(e.used) break;\n\t\t\t\t\te.used = true;\n\n\t\t\t\t\tP.emplace_back(v);\n\n\t\t\t\t\tfor(int k = 0; k < static_cast<int>(G[e.to].size()); ++k) {\n\t\t\t\t\t\tif(G[e.to][k].to == v) {\n\t\t\t\t\t\t\tv = e.to;\n\t\t\t\t\t\t\te_idx = k + 1;\n\t\t\t\t\t\t\tif(e_idx >= static_cast<int>(G[e.to].size())) e_idx = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(P.size() >= 3) {\n\t\t\t\t\tif(s == -1 && outside(P, points)) s = faces.size();\n\t\t\t\t\tfaces.emplace_back(P);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvector<vector<int>> Gf(V);\n\n\t\tfor(int i = 0; i < V; ++i) {\n\t\t\tfor(int j = i + 1; j < V; ++j) {\n\t\t\t\tif(neighbor(faces[i], faces[j])) {\n\t\t\t\t\tGf[i].emplace_back(j);\n\t\t\t\t\tGf[j].emplace_back(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvector<int> dist(V, INT_MAX);\n\t\tqueue<int> que;\n\n\t\tdist[s] = 0;\n\t\tque.push(s);\n\n\t\twhile(!que.empty()) {\n\t\t\tconst int v = que.front();\n\t\t\tque.pop();\n\n\t\t\tfor(const auto &to : Gf[v]) {\n\t\t\t\tif(dist[to] == INT_MAX) {\n\t\t\t\t\tdist[to] = dist[v] + 1;\n\t\t\t\t\tque.push(to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << *max_element(begin(dist), end(dist)) << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<utility>\n#include<map>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n\nusing namespace std;\n\nstruct Point{\n\tint x,y;\n\tint id;\n\tPoint(){}\n\tPoint(int a,int b,int c):x(a),y(b),id(c){}\n};\n\nPoint points[110];\nint pid[110];\n\nbool cmp(const Point &p1,const Point &p2)\n{\n\tif(p1.x!=p2.x) return p1.x<p2.x;\n\treturn p1.y<p2.y;\n}\n\nint center;\n\nbool cmp_angle(const int &id1,const int &id2)\n{\n\tint center=pid[::center];\n\tint id1_=pid[id1],id2_=pid[id2];\n\tint dx1=points[id1_].x-points[center].x;\n\tint dy1=points[id1_].y-points[center].y;\n\tint dx2=points[id2_].x-points[center].x;\n\tint dy2=points[id2_].y-points[center].y;\n\t//(-y,x)\n\tdouble ang1=atan2(dx1,-dy1);\n\tdouble ang2=atan2(dx2,-dy2);\n\treturn ang1<ang2;\n}\n/*\nstruct cmp_angle_{\n\tbool operator()(const int &id1,const int &id2)\n\t{\n\tint center=pid[::center];\n\tint id1_=pid[id1],id2_=pid[id2];\n\tint dx1=points[id1_].x-points[center].x;\n\tint dy1=points[id1_].y-points[center].y;\n\tint dx2=points[id2_].x-points[center].x;\n\tint dy2=points[id2_].y-points[center].y;\n\t//(-y,x)\n\tdouble ang1=atan2(dx1,-dy1);\n\tdouble ang2=atan2(dx2,-dy2);\n\treturn ang1<ang2;\n\t}\n};*/\n\nvector<int> G[110];\n\nvector<vector<int> > vs;\nvector<int> dG[550];\n//bool con[550][550];\n\ntypedef pair<int,int> P;\n\nmap<P,int> cnt;\nqueue<P> que;\n\nvoid init()\n{\n\tvs.clear();\n\tfor(int i=0;i<110;i++) G[i].clear();\n\tfor(int i=0;i<550;i++) dG[i].clear();\n\tcnt.clear();\n}\n\nvector<int> res;\nvoid stroke(int u,int v,int st)\n{\n\t//u->v\n\tP p=P(min(u,v),max(u,v));\n\tif(cnt[p]==0)\n\t{\n\t\tque.push(P(v,u));\n\t}\n\tcnt[p]++;\n\tif(v==st) return;\n\tif(u==st) res.push_back(u);\n\tres.push_back(v);\n//\tprintf(\"x%dx\\n\",v);\n\tcenter=v;\n\tint id=distance(G[v].begin(),lower_bound(G[v].begin(),G[v].end(),u,cmp_angle));\n//\tprintf(\"%d::%d %d\\n\",v,G[v].size(),id);\n\tif(id==G[v].size()-1) id=0;\n\telse id++;\n\tint nxt=G[v][id];\n\tstroke(v,nxt,st);\n}\n\nvoid getGraph()\n{\n\tint V=vs.size();\n\tfor(int i=0;i<V;i++) for(int j=i+1;j<V;j++)\n\t{\n\t\tint ni=vs[i].size(),nj=vs[j].size();\n\t\tbool flg=false;\n\t\tfor(int iid=0;iid<ni;iid++) for(int jid=0;jid<nj;jid++)\n\t\t{\n\t\t\tint niid=iid==ni-1?0:iid+1;\n\t\t\tint njid=jid==nj-1?0:jid+1;\n\t\t\tif(vs[i][iid]==vs[j][njid]&&vs[i][niid]==vs[j][jid]) flg=true;\n\t\t}\n\t\tif(flg)\n\t\t{\n\t\t\tdG[i].push_back(j);\n\t\t\tdG[j].push_back(i);\n\t\t}\n\t//\tcon[i][j]=flg;\n\t//\tcon[j][i]=flg;\n\t}\n}\n\nint getMostOutSide()\n{\n\tint u=points[0].id;\n\tint v=G[u][0];\n//\tprintf(\"----------------%d %d\\n\",u,v);\n//\tprintf(\"%d %d %d %d\\n\",points[u].x,points[u].y,points[v].x,points[v].y);\n\tfor(int i=0;i<vs.size();i++)\n\t{\n\t\tfor(int j=0;j+1<vs[i].size();j++)\n\t\t{\n\t\t\tif(vs[i][j]==u&&vs[i][j+1]==v) return i;\n\t\t}\n\t\tif(vs[i][vs[i].size()-1]==u&&vs[i][0]==v) return i;\n\t}\n\tfor(;;);\n\treturn -1;\n}\n\nint dis[550];\nqueue<int> bfs_que;\nvoid bfs(int s)\n{\n//\tprintf(\"xxxxxxxxxxxxxxxxxxxxx\\n\");\n\twhile(!bfs_que.empty()) bfs_que.pop();\n\tbfs_que.push(s);\n\tfor(int i=0;i<550;i++) dis[i]=1<<29;\n\tdis[s]=0;\n\tbfs_que.push(s);\n\twhile(!bfs_que.empty())\n\t{\n\t\tint v=bfs_que.front();\n//\t\tprintf(\"bfs %d\\n\",v);\n\t\tbfs_que.pop();\n\t\tfor(int i=0;i<dG[v].size();i++)\n\t\t{\n\t\t\tint u=dG[v][i];\n\t\t\tint nd=dis[v]+1;\n\t\t\tif(nd>=dis[u]) continue;\n\t\t\tdis[u]=nd;\n\t\t\tbfs_que.push(u);\n\t\t}\n\t}\n}\n\nvoid outputdG()\n{\n\tprintf(\"-----dual\\n\");\n\tfor(int i=0;i<vs.size();i++)\n\t{\n\t\tprintf(\"%d-\",i);\n\t\tfor(int j=0;j<dG[i].size();j++)\n\t\t{\n\t\t\tprintf(\"%d \",dG[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}\n\nint main()\n{\n\twhile(true)\n\t{\n\t\tint C,W;\n\t\tscanf(\"%d%d\",&C,&W);\n\t\tif(C==0) break;\n\t\tinit();\n\t\tfor(int i=0;i<C;i++)\n\t\t{\n\t\t\tint x,y;\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\tpoints[i]=Point(x,y,i);\n\t\t}\n\t\tsort(points,points+C,cmp);\n\t\tfor(int i=0;i<C;i++) pid[points[i].id]=i;\n\t\tint su=-1,sv=-1;\n\t\tfor(int i=0;i<W;i++)\n\t\t{\n\t\t\tint u,v;\n\t\t\tscanf(\"%d%d\",&u,&v);\n\t\t\tu--;v--;\n\t\t\tG[u].push_back(v);\n\t\t\tG[v].push_back(u);\n\t\t\tsu=u,sv=v;\n\t\t}\n\t\tfor(int i=0;i<C;i++)\n\t\t{\n\t\t\tcenter=i;\n\t\t\tsort(G[i].begin(),G[i].end(),cmp_angle);\n//\t\t\tprintf(\"%d:::\",i);\n//\t\t\tfor(int j=0;j<G[i].size();j++) printf(\"%d \",G[i][j]);\n//\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tque.push(P(min(su,sv),max(su,sv)));\n\t\twhile(!que.empty())\n\t\t{\n\t\t\tP p=que.front();\n\t\t\tque.pop();\n\t\t\tint u=p.first,v=p.second;\n//\t\t\tprintf(\"pop %d %d\\n\",u,v);\n\t\t\tP pp=P(min(u,v),max(u,v));\n\t\t\tif(cnt[pp]==2) continue;\n\t\t//\tbool flg;\n\t\t//\tif(cnt[pp]==1) flg=false;\n\t\t//\telse flg=true;\n\t\t\tres.clear();\n\t\t\tstroke(u,v,u);\n\t\t\tvs.push_back(res);\n//\t\t\tfor(int i=0;i<res.size();i++) printf(\"%d \",res[i]);\n//\t\t\tprintf(\"aaa\\n\");\n\t\t//\tcnt[pp]++;\n\t\t//\tif(flg) que.push(P(v,u));\n\t\t}\n\t\tif(vs.size()>500) for(;;);\n//\t\tfor(int i=0;i<vs.size();i++)\n//\t\t{\n//\t\t\tvector<int> vec=vs[i];\n//\t\t\tprintf(\"a:\");\n//\t\t\tfor(int j=0;j<vec.size();j++) printf(\"%d \",vec[j]);\n//\t\t\tprintf(\"\\n\");\n//\t\t}\n\t\tgetGraph();\n\t\tint out=getMostOutSide();\n\t\tbfs(out);\n\t\tint ans=0;\n\t\tfor(int i=0;i<vs.size();i++) ans=max(ans,dis[i]);\n//\t\toutputdG();\n//\t\tprintf(\"---------%d--------------ans=%d\\n\",out,ans);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\nusing R=long double;\nusing edge=tuple<R,int>;\n\nconst int limit=310;\nint x[limit],y[limit];\n\nint main(void){\n\tint n,m;\n\twhile(cin >> n >> m,n){\n\t\trep(i,n) cin >> x[i] >> y[i];\n\n\t\tvector<edge> graph[limit];\n\t\tvector<int> used[limit];\n\n\t\trep(i,m){\n\t\t\tint s,t;\n\t\t\tcin >> s >> t;\n\t\t\ts--,t--;\n\t\t\tgraph[s].push_back(make_tuple(atan2(y[t]-y[s],x[t]-x[s]),t));\n\t\t\tused[s].push_back(-1);\n\t\t\tgraph[t].push_back(make_tuple(atan2(y[s]-y[t],x[s]-x[t]),s));\n\t\t\tused[t].push_back(-1);\n\t\t}\n\n\t\trep(v,n) sort(_all(graph[v]));\n\t\t\n\t\tint all=0;\n\t\trep(v,n){\n\t\t\trep(i,graph[v].size()){\n\t\t\t\tif(used[v][i]!=-1) continue;\n\t\t\t\t\n\t\t\t\tint cur=v,idx=i;\n\t\t\t\tdo{\n\t\t\t\t\tused[cur][idx]=all;\n\t\t\t\t\tint nxt=get<1>(graph[cur][idx]),nidx=0;\n\t\t\t\t\trep(j,graph[nxt].size()) if(get<1>(graph[nxt][j])==cur) nidx=(j+1)%int(graph[nxt].size());\n\t\t\t\t\tcur=nxt,idx=nidx;\n\t\t\t\t}while(cur!=v);\n\t\t\t\tall++;\n\t\t\t}\n\t\t}\n\t\n\t\tint dual[limit][limit];\n\t\trep(i,all)rep(j,all) dual[i][j]=(i==j)?0:(1<<20);\n\n\t\tint outer=used[min_element(x,x+n)-x][0];\n\t\t\n\t\trep(v,n){\n\t\t\trep(i,graph[v].size()){\n\t\t\t\tint v2=get<1>(graph[v][i]),j=0;\n\t\t\t\twhile(get<1>(graph[v2][j])!=v) j++;\n\n\t\t\t\tdual[used[v][i]][used[v2][j]]=1;\n\t\t\t\tdual[used[v2][j]][used[v][i]]=1;\n\t\t\t}\n\t\t}\n\n\t\trep(k,all)rep(i,all)rep(j,all) chmin(dual[i][j],dual[i][k]+dual[k][j]);\n\t\tint ans=1;\n\t\trep(v,all) chmax(ans,dual[outer][v]);\n\t\tcout << ans << endl;\n\t}\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "int bottom;\nint outside_color;\n\n// Library.\n#include<cassert>\n#include<map>\n#include<vector>\n#include<cmath>\n#include<queue>\n#include<algorithm>\n// Type.\ntypedef int Label;\ntypedef int Weight;\n// Class.\ntemplate<typename Vertex, typename Edge>\nclass PlaneGraph {\npublic:\n  void insert(const Vertex& v);\n  void insert(Edge e);\n  const PlaneGraph<Vertex, Edge> dualgraph() const;\n  const std::map<Label, Weight> Dijkstra(const Label& start) const;\nprivate:\n  void dualgraph_color(std::map<Label, std::map<Label, int>>& color, int c, const Edge& e, const std::map<Label, std::vector<Edge>>& edge) const;\n  std::map<Label, Vertex> V;\n  std::map<Label, std::vector<Edge>> E;\n};\n// Implement.\ntemplate<typename Vertex, typename Edge>\nvoid PlaneGraph<Vertex, Edge>::insert(const Vertex& v) {\n  V[v.label] = v;\n}\ntemplate<typename Vertex, typename Edge>\nvoid PlaneGraph<Vertex, Edge>::insert(Edge e) {\n  assert(V.find(e.from) != std::end(V));\n  assert(V.find(e.to) != std::end(V));\n  E[e.from].push_back(e);\n  std::swap(e.from, e.to);\n  E[e.from].push_back(e);\n}\ntemplate<typename Vertex, typename Edge>\nconst PlaneGraph<Vertex, Edge> PlaneGraph<Vertex, Edge>::dualgraph() const {\n  // Sort edges counterclockwise.\n  auto edge = E;\n  for(auto& list: edge) if(!list.second.empty()) {\n    std::sort(std::begin(list.second), std::end(list.second), [&](const Edge& lhs, const Edge& rhs) {\n      double l = std::atan2(V.at(lhs.to).y - V.at(lhs.from).y, V.at(lhs.to).x - V.at(lhs.from).x);\n      double r = std::atan2(V.at(rhs.to).y - V.at(rhs.from).y, V.at(rhs.to).x - V.at(rhs.from).x);\n      return l < r;\n    });\n    list.second.push_back(list.second.front());\n  }\n  // Color edges.\n  std::map<Label, std::map<Label, int>> color;\n  int c = 1;\n  for(const auto& list: edge) {\n    for(const auto& e: list.second) if(!color[e.from].count(e.to)) dualgraph_color(color, c++, e, edge);\n    if(list.first == bottom) outside_color = color[list.second.front().from][list.second.front().to];\n  }\n  // Construct the dualgraph.\n  PlaneGraph<Vertex, Edge> result;\n  std::vector<std::vector<bool>> used(c, std::vector<bool>(c, false));\n  for(int i = 1; i < c; ++i) result.insert(Vertex({i}));\n  for(const auto& list: E) for(const auto& e: list.second) if(!used[color[e.from][e.to]][color[e.to][e.from]]) {\n    used[color[e.from][e.to]][color[e.to][e.from]] = true;\n    used[color[e.to][e.from]][color[e.from][e.to]] = true;\n    result.insert(Edge({color[e.from][e.to], color[e.to][e.from], 1}));\n  }\n  return result;\n}\ntemplate<typename Vertex, typename Edge>\nvoid PlaneGraph<Vertex, Edge>::dualgraph_color(std::map<Label, std::map<Label, int>>& color, int c, const Edge& e, const std::map<Label, std::vector<Edge>>& edge) const {\n  color[e.from][e.to] = c;\n  for(auto it = edge.at(e.to).rbegin(); it != edge.at(e.to).rend(); ++it) if(it->to == e.from) {\n    ++it;\n    if(!color[it->from].count(it->to)) dualgraph_color(color, c, *it, edge);\n    break;\n  }\n}\ntemplate<typename Vertex, typename Edge>\nconst std::map<Label, Weight> PlaneGraph<Vertex, Edge>::Dijkstra(const Label& start) const {\n  std::map<Label, Weight> result;\n  std::priority_queue<Edge, std::vector<Edge>, std::function<bool(Edge, Edge)>> q([](Edge lhs, Edge rhs) {\n    return lhs.weight > rhs.weight;\n  });\n  q.push(Edge({start, start, 0}));\n  while(!q.empty()) {\n    auto cur = q.top();\n    q.pop();\n    if(result.count(cur.to)) continue;\n    result[cur.to] = cur.weight;\n    for(const auto& nex: E.at(cur.to)) if(!result.count(nex.to)) q.push(Edge({nex.from, nex.to, cur.weight + nex.weight}));\n  }\n  return result;\n}\n////////////////////////////////////////\n// Configuration.\nstruct Vertex {Label label; double x, y;};\nstruct Edge {Label from, to; Weight weight;};\n////////////////////////////////////////\n#include<bits/stdc++.h>\nusing namespace std;\nint main() {\n  int C, W;\n  while(cin >> C >> W, C | W) {\n    vector<Vertex> pillar;\n    int bottom_x = 1001, bottom_y = 1001;\n    for(int i = 0; i < C; ++i) {\n      double x, y;\n      cin >> x >> y;\n      pillar.push_back({i, x, y});\n      if(bottom_x < x) continue;\n      if(bottom_x == x && bottom_y < y) continue;\n      bottom_x = x;\n      bottom_y = y;\n      bottom = i;\n    }\n    PlaneGraph<Vertex, Edge> G;\n    for(const auto& p: pillar) G.insert(p);\n    for(int i = 0; i < W; ++i) {\n      int s, t;\n      cin >> s >> t;\n      --s; --t;\n      G.insert(Edge({s, t, 1}));\n    }\n    auto D = G.dualgraph();\n    auto distance = D.Dijkstra(outside_color);\n    Weight answer = 0;\n    for(const auto& d: distance) answer = max(answer, d.second);\n    cout << answer << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <unordered_map>\n#include <iterator>\n#include <assert.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nnamespace geom{\n#define X real()\n#define Y imag()\n#define at(i) ((*this)[i])\n#define SELF (*this)\n\tenum {TRUE = 1, FALSE = 0, BORDER = -1};\n\ttypedef int BOOL;\n\ttypedef double R;\n\tconst R INF = 1e8;\n\tconst R EPS = 1e-12;\n\tconst R PI = 3.1415926535897932384626;\n\tinline int sig(const R &x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n\tinline BOOL less(const R &x, const R &y) {return sig(x-y) ? x < y : BORDER;}\n\ttypedef complex<R> P;\n\tinline R norm(const P &p){return p.X*p.X+p.Y*p.Y;}\n\tinline R inp(const P& a, const P& b){return (conj(a)*b).X;}\n\tinline R outp(const P& a, const P& b){return (conj(a)*b).Y;}\n\tinline P unit(const P& p){return p/abs(p);}\n\tinline P proj(const P &s, const P &t){return t*inp(s, t)/norm(t);}\n\tinline int ccw(const P &s, const P &t, const P &p, int adv=0){\n\t\tint res = sig(outp(t-s, p-s));\n\t\tif(res || !adv) return res;\n\t\tif(sig(inp(t-s, p-s)) < 0) return -2;\t// p-s-t\n\t\tif(sig(inp(s-t, p-t)) < 0) return 2;\t// s-t-p\n\t\treturn 0;\t\t\t\t\t\t\t\t// s-p-t\n\t}\n\t\n\t\n\tstruct L : public vector<P>{\t// line\n\t\tL(const P &p1, const P &p2){this->push_back(p1);this->push_back(p2);}\n\t\tL(){}\n\t\tP dir()const {return at(1) - at(0);}\n\t\tBOOL online(const P &p)const {return !sig(outp(p-at(0), dir()));}\n\t};\n\tstruct S : public L{\t// segment\n\t\tS(const P &p1, const P &p2):L(p1, p2){}\n\t\tS(){}\n\t\tBOOL online(const P &p)const {\n\t\t\tif(!sig(norm(p - at(0))) || !sig(norm(p - at(1)))) return BORDER;\n\t\t\treturn !sig(abs(at(0)-p) + abs(at(1) - p) - abs(at(0) - at(1)));\n\t\t}\n\t};\n\tstruct C : public P{\n\t\tR r;\n\t\tBOOL inside(const P& p)const { return less(norm(p-SELF), r*r);}\n\t};\n\tP crosspoint(const L &l, const L &m);\n\tstruct G : public vector<P>{\n\t\tG(size_type size=0):vector(size){}\n\t\tS edge(int i)const {return S(at(i), at(i+1 == size() ? 0 : i+1));}\n\t\tBOOL contains(const P &p)const {\n\t\t\tR sum = .0;\n\t\t\tREP(i, size()){\n\t\t\t\tif(S(at(i), at((i+1)%size())).online(p)) return BORDER;\t// online\n\t\t\t\tsum += arg((at(i) - p) / (at((i+1)%size()) - p));\n\t\t\t}\n\t\t\treturn !!sig(sum);\n\t\t}\n\t\tR area()const {\n\t\t\tR sum = 0;\n\t\t\tREP(i, size()) sum += outp(at(i), at((i+1)%size()));\n\t\t\treturn abs(sum / 2.);\n\t\t}\n\t\t\n\t\tG convex_hull(bool online = false) {\n\t\t\tif(size() < 2) return *this;\n\t\t\tsort(ALL(*this));\n\t\t\tG r;\n\t\t\tr.resize((int)size()*2);\n\t\t\tint k=0;\n\t\t\tfor(int i=0;i<size();r[k++]=at(i++))\n\t\t\t\twhile(k>1 && ccw(r[k-2], r[k-1], at(i)) < 1-online) k--;\n\t\t\tint t = k;\n\t\t\tfor(int i=(int)size()-1;i>=0;r[k++]=at(i--))\n\t\t\t\twhile(k>t && ccw(r[k-2], r[k-1], at(i)) < 1-online) k--;\n\t\t\tr.resize(k-1);\n\t\t\treturn r;\n\t\t}\n\t\tG cut(const L &l)const {\n\t\t\tG g;\n\t\t\tREP(i, size()){\n\t\t\t\tconst S &s = edge(i);\n\t\t\t\tif(ccw(l[0], l[1], s[0], 0) >= 0) g.push_back(s[0]);\n\t\t\t\tif(ccw(l[0], l[1], s[0], 0) * ccw(l[0], l[1], s[1], 0) < 0)\n\t\t\t\t\tg.push_back(crosspoint(s, l));\n\t\t\t}\n\t\t\treturn g;\n\t\t}\n\t\tG Voronoi(const vector<P> &p, const int t)const {\n\t\t\tG g = *this;\n\t\t\tREP(i, p.size())if(i!=t){\n\t\t\t\tconst P m = (p[t]+p[i])*0.5;\n\t\t\t\tg = g.cut(L(m, m+(p[i]-p[t])*P(0, 1)));\n\t\t\t}\n\t\t\treturn g;\n\t\t}\n\t};\n\n\tinline P proj(const P &s, const L &t){return t[0] + proj(s-t[0], t[1]-t[0]);}\n\tBOOL intersect(const S &s, const S &t){\n\t\tconst int p = ccw(t[0], t[1], s[0], 1) * ccw(t[0], t[1], s[1], 1);\n\t\tconst int q = ccw(s[0], s[1], t[0], 1) * ccw(s[0], s[1], t[1], 1);\n\t\treturn (p>0||q>0) ? FALSE : (!p||!q) ? BORDER : TRUE;\n\t}\n\tBOOL intersect(const S &s, const L &l){\n\t\tif(l.online(s[0]) || l.online(s[1])) return BORDER;\n\t\treturn (sig(outp(l.dir(), s[0]-l[0])) * sig(outp(l.dir(), s[1]-l[0])) <= 0);\n\t}\n\tR dist2(const L &l, const P &p){return norm(outp(l.dir(), p - l[0])) / norm(l.dir());}\n\tR dist2(const S &s, const P &p){\n\t\tif(inp(p-s[0],  s.dir()) < EPS) return norm(p - s[0]);\n\t\tif(inp(p-s[1], -s.dir()) < EPS) return norm(p - s[1]);\n\t\treturn dist2((const L &)s, p);\n\t}\n\tR dist2(const S &s, const L &l){\n\t\treturn intersect(s, l) ? .0 : min(dist2(l, s[0]), dist2(l, s[1]));\n\t}\n\tR dist2(const S &s, const S &t){\n\t\treturn intersect(s, t) ? .0 : min(min(dist2(s, t[0]), dist2(t, s[0])), \n\t\t\t\t\t\t\t\t\t   \t  min(dist2(s, t[1]), dist2(t, s[1])));\n\t}\n\ttemplate <class T> R dist2(const G &g, const T& t){ // todo: テ・ツ??ゥツδィテ」ツ?ォテ・ツョツ古・ツ?ィテ」ツ?ォテ・ツ青ォテ」ツ?セテ」ツつ古」ツつ凝・ツ?エテ・ツ青?\n\t\tR res = INF;\n\t\tREP(i, g.size()) res = min(res, dist2(g.edge(i), t));\n\t\treturn res;\n\t}\n\ttemplate<class S, class T> R dist(const S& s, const T& t){return sqrt(dist2(s, t));}\n\tinline BOOL intersect(const C &a, const C &b){\n\t\treturn less((a.r-b.r)*(a.r-b.r), norm(a-b)) + less(norm(a-b), (a.r+b.r)*(a.r+b.r)) - 1;\n\t}\n\tinline BOOL intersect(const C &c, const L &l){\n\t\treturn less(dist2(l, c), c.r*c.r);\n\t}\n\tinline BOOL intersect(const C &c, const S &s){\n\t\tint d = less(dist2(s, c), c.r*c.r);\n\t\tif(d != TRUE) return d;\n\t\tint p = c.inside(s[0]), q = c.inside(s[1]);\n\t\treturn (p<0 || q<0) ? BORDER : p&q;\n\t}\n\tinline S crosspoint(const C &c1, const C &c2){\n\t\tif(!intersect(c1, c2)) return S();\n\t\tR d = abs(c1 - c2);\n\t\tR x = (c1.r*c1.r - c2.r*c2.r + d*d) / (2*d);\n\t\tR h = sqrt(c1.r*c1.r - x*x);\n\t\tP u = unit(c2-c1);\n\t\treturn S(c1 + u*x + u*P(0,1)*h, c1 + u*x + u*P(0,-1)*h);\n\t}\n\tinline P crosspoint(const L &l, const L &m){\n\t\tR A = outp(l.dir(), m.dir()), B = outp(l.dir(), l[1] - m[0]);\n\t\tif(!sig(abs(A)) && !sig(abs(B))) return m[0]; // same line\n\t\tif(abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n\t\treturn m[0] + B / A * (m[1] - m[0]);\n\t}\n\tinline R commonarea(const C &a, const C &b){\n\t\tif(less(norm(a-b), (a.r-b.r)*(a.r-b.r)) == TRUE) return min(a.r*a.r, b.r*b.r)*PI;\n\t\tif(less((a.r+b.r)*(a.r+b.r), norm(a-b)) == TRUE) return .0;\n\t\tdouble d = abs(a-b);\n\t\tdouble rc = (d*d + a.r*a.r - b.r*b.r) / (2*d);\n\t\tdouble theta = acos(rc / a.r);\n\t\tdouble phi = acos((d - rc) / b.r);\n\t\treturn a.r*a.r*theta + b.r*b.r*phi - d*a.r*sin(theta);\n\t}\n\tstruct Arrangement{\n\t\tstruct AEdge{\n\t\t\tint u, v, t;\n\t\t\tR cost;\n\t\t\tAEdge(int u=0, int v=0, int t=0, R cost=0)\n\t\t\t\t:u(u), v(v), t(t), cost(cost){}\n\t\t};\n\t\ttypedef vector<vector<AEdge>> AGraph;\n\t\tvector<P> p;\n\t\tAGraph g;\n\t\tArrangement(){}\n\t\tArrangement(vector<S> seg){\n\t\t\tint m = seg.size();\n\t\t\tREP(i, m){\n\t\t\t\tp.push_back(seg[i][0]);\n\t\t\t\tp.push_back(seg[i][1]);\n\t\t\t\tREP(j, i) if(sig(outp(seg[i].dir(), seg[j].dir())) && intersect(seg[i], seg[j]) == TRUE)\n\t\t\t\t\tp.push_back(crosspoint(seg[i], seg[j]));\n\t\t\t}\n\t\t\tsort(ALL(p)); UNIQUE(p);\n\t\t\tint n=p.size();\n\t\t\tg.resize(n);\n\t\t\tREP(i, m){\n\t\t\t\tS &s = seg[i];\n\t\t\t\tvector<pair<R, int>> ps;\n\t\t\t\tREP(j, n) if(s.online(p[j])) ps.emplace_back(norm(p[j] - s[0]), j);\n\t\t\t\tsort(ALL(ps));\n\t\t\t\tREP(j, (int)ps.size()-1){\n\t\t\t\t\tconst int u=ps[j].second;\n\t\t\t\t\tconst int v=ps[j+1].second;\n\t\t\t\t\tg[u].emplace_back(u, v, 0, abs(p[u] - p[v]));\n\t\t\t\t\tg[v].emplace_back(v, u, 0, abs(p[u] - p[v]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint getIdx(P q){\n\t\t\tauto it = lower_bound(ALL(p), q);\n\t\t\tif(it == p.end() || *it != q) return -1;\n\t\t\treturn it - p.begin();\n\t\t}\n\t};\n\n\tstruct min_ball {\n\t\tP center;\n\t\tR radius2;\n\t\tmin_ball(const vector<P>& p) {\n\t\t\tFOR(it, p) ps.push_back(*it);\n\t\t}\n\t\tmin_ball& compile() {\n\t\t\tm = 0;\n\t\t\tcenter = P(0, 0);\n\t\t\tradius2 = -1;\n\t\t\tmake_ball(ps.end());\n\t\t\treturn *this;\n\t\t}\n\tprivate:\n\t\tlist<P> ps;\n\t\tlist<P>::iterator supp_end;\n\t\tint m;\n\t\tP v[3], c[3];\n\t\tR z[3], r[3];\n\t\tvoid pop() { --m; }\n\t\tvoid push(const P& p) {\n\t\t\tif (m == 0) {\n\t\t\t\tc[0] = p; r[0] = 0;\n\t\t\t} else {\n\t\t\t\tR e = norm(p-c[m-1]) - r[m-1];\n\t\t\t\tP delta = p - c[0];\n\t\t\t\tv[m] = p - c[0];\n\t\t\t\tfor (int i = 1; i < m; ++i)\n\t\t\t\t\tv[m] -= v[i] * inp(v[i], delta) / z[i];\n\t\t\t\tz[m] = inp(v[m], v[m]);\n\t\t\t\tc[m] = c[m-1] + e*v[m]/z[m]*.5;\n\t\t\t\tr[m] = r[m-1] + e*e/z[m]*.25;\n\t\t\t}\n\t\t\tcenter\t= c[m];\n\t\t\tradius2 = r[m]; ++m;\n\t\t}\n\t\tvoid make_ball(list<P>::iterator i) {\n\t\t\tsupp_end = ps.begin();\n\t\t\tif (m == 3) return;\n\t\t\tfor (list<P>::iterator k = ps.begin(); k != i; ) {\n\t\t\t\tlist<P>::iterator j = k++;\n\t\t\t\tif (norm(*j-center) > radius2) {\n\t\t\t\t\tpush(*j); make_ball(j); pop();\n\t\t\t\t\tmove_to_front(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvoid move_to_front(list<P>::iterator j) {\n\t\t\tif (supp_end == j) ++supp_end;\n\t\t\tps.splice (ps.begin(), ps, j);\n\t\t}\n\t};\n\t\n\tstruct DualGraph{\n\t\tstruct DEdge{\n\t\t\tint u, v, f, l;\n\t\t\tR a;\n\t\t\tDEdge(int u, int v, R a):u(u),v(v),f(0),l(0){\n\t\t\t\twhile(PI < a) a -= 2*PI;\n\t\t\t\twhile(a < -PI) a += 2*PI;\n\t\t\t\tthis->a = a;\n\t\t\t}\n\t\t\tbool operator<(const DEdge &opp) const{\n\t\t\t\treturn a>opp.a;\n\t\t\t}\n\t\t\tbool operator<(const R &opp) const{\n\t\t\t\treturn a>opp;\n\t\t\t}\n\t\t\tfriend ostream& operator<<(ostream &os, const DEdge &t) { return os<<\"(\"<<t.u<<\",\"<<t.v<<\",\"<<t.a*180/PI<<\")\";}\n\t\t};\n\t\t\n\t\tint n;\n\t\tvector<P> p;\n\t\tvector<vector<DEdge>> g;\n\t\tDualGraph(const vector<P> &p):p(p),g(p.size()),n(p.size()){}\n\t\tvoid add_edge(int s, int t){\n\t\t\tR a = arg(p[t]-p[s]);\n\t\t\tg[s].emplace_back(s, t, a);\n\t\t\tg[t].emplace_back(t, s, a+PI);\n\t\t}\n\t\tvector<G> poly;\n\t\t\n\t\tvoid add_polygon(int s, int t, R a){\n\t\t\tauto e = lower_bound(ALL(g[s]), a-EPS);\n\t\t\tif(e == g[s].end()) e = g[s].begin();\n\t\t\tif(e->f) return;\n\t\t\te->f = 1;\n\t\t\te->l = t;\n\t\t\tpoly[t].push_back(p[s]);\n\t\t\tadd_polygon(e->v, t, e->a > 0 ? e->a-PI : e->a+PI);\n\t\t}\n\t\t\n\t\tvector<vi> dual(){\n\t\t\tREP(i, n) sort(ALL(g[i]));\n\t\t\tint s = min_element(ALL(p)) - p.begin();\n\t\t\tpoly.emplace_back();\n\t\t\tadd_polygon(s, poly.size()-1, -PI*.5);\n\t\t\tREP(i, n)REP(j, g[i].size())if(!g[i][j].f){\n\t\t\t\tpoly.emplace_back();\n\t\t\t\tadd_polygon(i, poly.size()-1, g[i][j].a+EPS);\n\t\t\t}\n\t\t\tint m = poly.size();\n\t\t\tvector<vi> dg(m);\n\t\t\tvector<unordered_map<int, int>> rev(n);\n\t\t\tREP(i, n)REP(j, g[i].size()){\n\t\t\t\tint u = i, v = g[i][j].v, l = g[i][j].l;\n\t\t\t\tif(u>v) swap(u, v);\n\t\t\t\tif(rev[u].find(v) != rev[u].end()){\n\t\t\t\t\tdg[l].push_back(rev[u][v]);\n\t\t\t\t\tdg[rev[u][v]].push_back(l);\n\t\t\t\t}\n\t\t\t\telse rev[u][v] = l;\n\t\t\t}\n\t\t\treturn dg;\n\t\t}\n\t};\n#undef SELF\n#undef at\n}\n\nusing namespace geom;\n\nnamespace std{\n\tbool operator<(const P &a, const P &b){return sig(a.X-b.X) ? a.X < b.X : a.Y < b.Y;}\n\tbool operator==(const P &a, const P &b){return !sig(norm(a-b));}\n\tistream& operator>>(istream &is, P &p){R x,y;is>>x>>y;p=P(x, y);return is;}\n\tistream& operator>>(istream &is, L &l){l.resize(2);return is >> l[0] >> l[1];}\n\tistream& operator>>(istream &is, C &c){return is >> (P &)c >> c.r;}\n\tconst double B = 0;\n\tconst double Z = 1;\n\tostream& operator<<(ostream &os, const P &p){return os << \"circle(\"<<Z*(B+p.X)<<\", \"<<Z*(B-p.Y)<<\", 2)\";}\n\tostream& operator<<(ostream &os, const C &c){return os << \"circle(\"<<Z*(B+c.X)<<\", \"<<Z*(B-c.Y)<<\", \"<<Z*(c.r)<<\")\";}\n\tostream& operator<<(ostream &os, const S &s){return os << \"line(\"<<Z*(B+s[0].X)<<\", \"<<Z*(B-s[0].Y)<<\", \"<<Z*(B+s[1].X)<<\", \"<<Z*(B-s[1].Y)<<\")\";}\n\tostream& operator<<(ostream &os, const G &g){REP(i, g.size()) cout << g.edge(i) << endl;return os;}\n}\n\n\nint n, m;\n\nvoid dijkstra(const vector<vi> &g, int s, vector<int> &ret){\n\tint n = g.size();\n\tret = vector<int>(n, INF);\n\tqueue<int> dp;\n\tdp.push(s);\n\tret[s] = 0;\n\twhile(!dp.empty()){\n\t\tint s = dp.front();\n\t\tdp.pop();\n\t\tFOR(it, g[s]){\n\t\t\tif(ret[*it] > ret[s]+1){\n\t\t\t\tret[*it] = ret[s]+1;\n\t\t\t\tdp.push(*it);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\twhile(cin >> n >> m, n){\n\t\tvector<P> p(n);\n\t\tREP(i, n) cin >> p[i];\n\t\tDualGraph dg(p);\n\t\tREP(i, m){\n\t\t\tint u, v;\n\t\t\tcin >> u >> v;u--;v--;\n\t\t\tdg.add_edge(u, v);\n\t\t}\n\t\tvector<vi> g = dg.dual();\n\t\tvi res;\n\t\tdijkstra(g, 0, res);\n\t\tcout << *max_element(ALL(res)) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cassert>\nusing namespace std;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n\treturn abs(a.real()-b.real()) > EPS ? real(a) < real(b) : imag(a) + EPS < imag(b);\n    //return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\nP readPoint(){\n\tdouble x,y;\n\tcin >> x >> y;\n\treturn P(x,y);\n}\n\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\ntypedef vector<P> G;\n\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\n\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\nP reflection(const L &l, const P &p) {\n  return p + 2. * (projection(l, p) - p);\n}\ndouble distanceLP(const L &l, const P &p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\n#define rep(i,N) for(int i = 0 ; i < N ; i++)\nP ps[110];\nvector<int> g[110];\n\nvector<int> normalize(vector<int> v){\n\tauto it = min_element(v.begin(),v.end());\n\trotate(v.begin(),it,v.end());\n\treturn v;\n}\n\nint done[110];\nvoid f(int a,int b,int s,vector<int> &v){\n\tv.push_back(b);\n\tif( b == s ) return;\n\tif( done[b]++ ) throw 0;\n\tsort(g[b].begin(),g[b].end(),[&](int x,int y){\n\t\tP A = ps[x] - ps[b];\n\t\tP B = ps[y] - ps[b];\n\t\treturn cross(A,B) > 0;\n\t});\n\trotate(g[b].begin(),find(g[b].begin(),g[b].end(),a),g[b].end());\n\tf(b,g[b][1],s,v);\n}\n\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n\ndouble area2(const G& P) {\n  double A = 0;\n  for (int i = 0; i < P.size(); ++i) \n    A += cross(curr(P, i), next(P, i));\n  return A;\n}\n\nint main(){\n\t\n\tint C,W;\n\twhile( cin >> C >> W && (C||W) ){\n\t\trep(i,C) ps[i] = readPoint();\n\t\trep(i,C) g[i].clear();\n\t\trep(i,W){\n\t\t\tint a,b;\n\t\t\tcin >> a >> b;\n\t\t\t--a,--b;\n\t\t\tg[a].push_back(b);\n\t\t\tg[b].push_back(a);\n\t\t}\n\t\tvector< vector<int> > poly;\n\t\tset< set<int> > prevs; \n\t\trep(i,C){\n\t\t\trep(j,g[i].size()){\n\t\t\t\ttry{\n\t\t\t\t\tmemset(done,0,sizeof(done));\n\t\t\t\t\tvector<int> v;\n\t\t\t\t\tf(i,g[i][j],i,v);\n\t\t\t\t\tvector<P> g;\n\t\t\t\t\trep(k,v.size())g.push_back(ps[v[k]]);\n\t\t\t\t\tif( area2(g) > 0 ){ continue; }\n\t\t\t\t\tif( prevs.count(set<int>(v.begin(),v.end())) ) continue;\n\t\t\t\t\tpoly.push_back(normalize(v));\n\t\t\t\t\tprevs.insert(set<int>(v.begin(),v.end()));\n\t\t\t\t}catch(int x){\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(poly.begin(),poly.end());\n\t\tpoly.erase(unique(poly.begin(),poly.end()),poly.end());\n\t\t\n\t\tmap< pair<int,int>, vector<int> > edgs;\n\t\tfor(int i = 0 ; i < poly.size() ; i++){\n\t\t\tfor(int j = 0 ; j < poly[i].size() ; j++){\n\t\t\t\tint A = curr(poly[i],j);\n\t\t\t\tint B = next(poly[i],j);\n\t\t\t\tif( A > B ) swap(A,B);\n\t\t\t\tedgs[pair<int,int>(A,B)].push_back(i);\n\t\t\t}\n\t\t}\n\t\tint M = poly.size() + 1;\n\t\tint wf[M][M];\n\t\trep(i,M) rep(j,M){\n\t\t\twf[i][j] = i==j?0:1e9;\n\t\t}\n\t\t\n\t\tfor( auto x : edgs ){\n\t\t\tvector<int> v = x.second;\n\t\t\tif( v.size() < 2 ) v.push_back(M-1);\n\t\t\tassert( v.size() == 2 );\n\t\t\twf[v[0]][v[1]] = wf[v[1]][v[0]] = 1;\n\t\t}\n\t\trep(i,M)rep(j,M)rep(k,M) wf[j][k] = min(wf[j][i]+wf[i][k],wf[j][k]);\n\t\tint ans = 0;\n\t\trep(i,M){\n\t\t\tans = max(ans,wf[i][M-1]);\n\t\t}\n\t\tcout << ans << endl;\n\t\t\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <ctime>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <fstream>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <numeric>\n#include <cassert>\nusing namespace std;\n\ntypedef complex<double> P;\nconst double PI = acos(-1);\n\ndouble fx(double rd){\n\twhile( rd < -1e-9 )   rd += 2*PI;\n\twhile( rd >= 2*PI - 1e-9) rd -= 2*PI;\n\treturn rd;\n}\ndouble R(P a){\n\tdouble rd = atan2(a.imag(),a.real());\n\treturn fx(rd);\n}\n\nint C,W;\n\nint wsc[300] , wtc[300];\nP c[100];\nstruct NODE{\n\tint from,to,id;\n\tdouble rad;\n\tNODE(int from,int to,int id) : from(from) , to(to) , id(id) {\n\t\trad = R(c[to]-c[from]);\n\t}\n\tNODE(){}\n};\nbool operator < (const NODE &a,const NODE &b){\n\treturn a.rad < b.rad;\n}\nvector<NODE> geo[100];\nint done[100];\n\nint start;\nint get(int x,int prev,vector<int> &ad){\n\tif( x == start ) return 1;\n\tif( done[x] ) return 0;\n\telse done[x] = true;\n\t\n\tfor(int i = 0 ; i < geo[x].size() ; i++){\n\t\tint y = (i+1)%geo[x].size();\n\t\tif( geo[x][i].to == prev ){\t\t\t\n\t\t\tif( get(geo[x][y].to,x,ad) ){\n\t\t\t\t//ad.push_back(x);\n\t\t\t\tad.push_back(geo[x][y].id);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nnamespace std {bool operator < (const P& a, const P& b) {return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);} }\ndouble cross(const P& a, const P& b) {return imag(conj(a)*b);}\ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;\n\tif (cross(b, c) < 0)   return -1;\n\tif (dot(b, c) < 0) return +2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n// Totsuhou! Andrew's Monotone Chain //\nvector<P> convex_hull(vector<P> ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<P> ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);} };\nstatic const double EPS = 1e-10;\nbool intersectSP(const L &s, const P &p) {return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;}\n\n\nint main(){\n\twhile(cin >> C >> W && C){\n\t\tfor(int i = 0 ; i < 100 ; i++) geo[i].clear();\n\t\tfor(int i = 0 ; i < C ; i++)\n\t\t\tcin >> c[i].real() >> c[i].imag();\n\t\tfor(int i = 0 ; i < W ; i++){\n\t\t\tint s,t;\n\t\t\tcin >> s >> t;\n\t\t\ts--,t--;\n\t\t\tgeo[s].push_back(NODE(s,t,i));\n\t\t\tgeo[t].push_back(NODE(t,s,i));\n\t\t\twsc[i] = s;\n\t\t\twtc[i] = t;\n\t\t}\n\t\tfor(int i = 0 ; i < 100 ; i++) sort(geo[i].begin(),geo[i].end());\n\t\t\n\t\tvector< vector<int> > wallset;\n\t\tfor(int _ = 0 ; _ < 2 ; _++){\n\t\t\tfor(int i = 0 ; i < W ; i++){\n\t\t\t\tmemset(done,0,sizeof(done));\n\t\t\t\tstart = wsc[i];\n\t\t\t\tvector<int> a;\n\t\t\t\tif( get(wtc[i],wsc[i],a) ){\n\t\t\t\t\t//a.push_back(wsc[i]);\n\t\t\t\t\ta.push_back(i);\n\t\t\t\t\tsort(a.begin(),a.end());\n\t\t\t\t\twallset.push_back(a);\n\t\t\t\t}\n\t\t\t\tswap(wsc[i],wtc[i]);\n\t\t\t}\n\t\t}\n\t\tsort(wallset.begin(),wallset.end());\n\t\twallset.erase(unique(wallset.begin(),wallset.end()),wallset.end());\n\t\t\n\t\t\n\t\tint wf[101][101]={};\n\t\tfor(int i = 0 ; i < 101 ; i++)\n\t\t\tfor(int j = 0 ; j < 101 ; j++)\n\t\t\t\twf[i][j] = i==j?0:1e9;\n\t\tint N = wallset.size();\n\t\tvector<int> wall_share[300];\n\t\t\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\tfor(int j = 0 ; j < wallset[i].size() ; j++){\n\t\t\t\twall_share[wallset[i][j]].push_back(i);\n\t\t\t\t//cout << wallset[i][j] << \" \";\n\t\t\t}\n\t\t\t//cout << endl;\n\t\t}\n\t\tfor(int i = 0 ; i < W ; i++){\n\t\t\tif( wall_share[i].size() == 1 ){\n\t\t\t\twf[wall_share[i][0]][100] = wf[100][wall_share[i][0]] = 1;\n\t\t\t}else if( wall_share[i].size() == 2 ){\n\t\t\t\tfor(int j = 0 ; j <wall_share[i].size() ; j++){\n\t\t\t\t\tfor(int k = 0 ; k < wall_share[i].size() ; k++){\n\t\t\t\t\t\tif(j!=k)wf[wall_share[i][j]][wall_share[i][k]] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<P> p;\n\t\tfor(int i = 0 ; i < C ; i++) p.push_back(c[i]);\n\t\tp = convex_hull(p);\n\t\tvector<P> np;\n\t\tfor(int i = 0 ; i < W ; i++){\n\t\t\tfor(int j = 0 ; j < p.size() ; j++){\n\t\t\t\tif( intersectSP(L(p[j],p[(j+1)%p.size()]),wsc[i]) && intersectSP(L(p[j],p[(j+1)%p.size()]),wtc[i]) ){\n\t\t\t\t\twf[wsc[i]][100] = 1;\n\t\t\t\t\twf[wtc[i]][100] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tp = np;\n\t\tfor(int i = 0 ; i < p.size() ; i++) cout << p[i] << endl;\n\t\tfor(int i = 0 ; i < 101 ; i++){\n\t\t\tfor(int j = 0 ; j < 101 ; j++){\n\t\t\t\tfor(int k = 0 ; k < 101 ; k++){\n\t\t\t\t\twf[j][k] = min(wf[j][k],wf[j][i]+wf[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\tans = max( ans , wf[i][100] );\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n==0) ? 1 : 10*TEN(n-1); }\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\nusing D = double;\nusing P = complex<D>;\n\nconst D PI = acos(D(-1)), EPS = 1e-10;\n\nint sgn(D a) {\n    if (abs(a) <= EPS) return 0;\n    return (a < 0) ? -1 : 1;\n}\nbool near(P a, P b) { return !sgn(abs(a-b)); }\nD mabs(P p) { return abs(p.real()) + abs(p.imag()); }\n\nbool lessP(P l, P r) {\n    if (sgn(r.real()-l.real())) return l.real() < r.real();\n    if (sgn(r.imag()-l.imag())) return l.imag() < r.imag();\n    return false;\n}\n\nD cross(P a, P b) { return a.real()*b.imag() - a.imag()*b.real(); }\nD dot(P a, P b) { return a.real()*b.real() + a.imag()*b.imag(); }\n\n// -2, -1, 0, 1, 2 : front, clock, on, cclock, back\nint ccw(P b, P c) {\n    int s = sgn(cross(b, c) / mabs(b));\n    if (s) return s;\n    if (!sgn(mabs(c)) || !sgn(mabs(c-b))) return 0;\n    if (dot(b, c) < 0) return 2;\n    if (dot(-b, c-b) < 0) return -2;\n}\nint ccw(P a, P b, P c) { return ccw(b-a, c-a); }\n\nstruct L {\n    P x, y;\n    L() {}\n    L(P x, P y) :x(x), y(y) {}\n    P vec() const { return y-x; }\n};\nD abs(const L &l) { return abs(l.vec()); }\nD arg(const L &l) { return arg(l.vec()); }\n\nD distLP(const L &l, const P &p) {\n    return abs(cross(l.vec(), p-l.x)/abs(l.vec()));\n}\nD distSP(const L &s, const P &p) {\n    P s2 = s.vec()*P(0, 1);\n    if (ccw(s.x, s.x+s2, p) == 1) return abs(s.x-p);\n    if (ccw(s.y, s.y+s2, p) == -1) return abs(s.y-p);\n    return min(min(abs(s.x-p), abs(s.y-p)), distLP(s, p));\n}\n\n\nint crossLL(const L &l, const L &m, P &r) {\n    L mm = L(m.x - l.x, m.y - l.x);\n    mm.x *= polar<D>(1, -arg(l));\n    mm.y *= polar<D>(1, -arg(l));\n    if (sgn(mm.vec().imag()) == 0) {\n        r = l.x;\n        if (sgn(mm.x.imag()) == 0) return -1;\n        return 0;\n    }\n    r = mm.x - mm.vec() * (mm.x.imag() / mm.vec().imag());\n    r *= polar<D>(1, arg(l));\n    r += l.x;\n    return 1;\n}\nint crossSS(const L &l, const L &m, P &r) {\n    int u = crossLL(l, m, r);\n    if (u == 0) return 0;\n    if (u == -1) {\n        int x = ccw(l.x, l.y, m.x);\n        int y = ccw(l.x, l.y, m.y);\n        if (x == 0) {\n            r = m.x;\n            return -1;\n        }\n        if (y == 0) {\n            r = m.y;\n            return -1;\n        }\n        if (x == y) return 0;\n        r = l.x;\n        return -1;\n    }\n    if (ccw(l.x, l.y, r) == 0 && ccw(m.x, m.y, r) == 0) return 1;\n    return 0;\n}\n\nusing Pol = V<P>;\n\nP cu(const Pol &p, int i) {\n    int s = p.size();\n    return p[(i%s+s)%s];\n};\n//0:P is out 1:P is on line 2:P is in\nint contains(const Pol &pol, P p) {\n    int in = -1;\n    for (int i = 0; i < int(pol.size()); i++) {\n        P a=cu(pol,i)-p, b=cu(pol,i+1)-p;\n        if (ccw(a, b, P(0, 0)) == 0) return 1;\n        if (imag(a) > imag(b)) swap(a, b);\n        if (imag(a) <= 0 && 0 < imag(b)) {\n            if (cross(a, b) < 0) in *= -1;\n        }\n    }\n    return in+1;\n}\n\nD area_naive(const Pol &p) {\n    D u = 0;\n    for (int i = 0; i < (int)p.size(); i++) {\n        u += cross(cu(p, i), cu(p, i+1));\n    }\n    return u/2;\n}\n\n/*\n -1 -> clock\n 0 -> non polygon\n 1 -> counter clock\n */\nint iscclock(const Pol &p) {\n    return sgn(area_naive(p));\n}\n\n//0:P is out 1:P is on line 2:P is in\nint contains(const Pol &pol, const L &l) {\n    vector<P> v;\n    v.push_back(l.x); v.push_back(l.y);\n    for (int i = 0; i < (int)pol.size(); i++) {\n        P a = cu(pol, i), b = cu(pol, i+1);\n        P p;\n        if (crossSS(L(a, b), l, p)) {\n            v.push_back(p);\n        }\n    }\n\n    sort(v.begin(), v.end(), [&](const P &x, const P &y){\n        return abs(l.x-x) < abs(l.x-y);\n    });\n\n    int sz = (int)v.size();\n    for (int i = 0; i < sz-1; i++) {\n        v.push_back((v[i]+v[i+1])/D(2));\n    }\n    bool f = false;\n    for (P p: v) {\n        int u = contains(pol, p); \n        if (!u) return 0;\n        if (u == 2) f = true;\n    }\n    if (f) return 2;\n    return 1;\n}\n\n\n/*\n 双対グラフを作成\n pol, rgの要素は2*n-4個確保しておくこと\n gはめちゃくちゃに破壊される\n もし連結でないグラフ、しかも内包があるグラフに行うとrgは0が複数混入する\n 0は、その連結成分だけに注目したときの外側の意味。本当に外側か判定したいなら\n contains等を使用すること\n */\nint dualGraph(P p[], vector<int> g[], int n,\n    Pol pol[], vector<int> rg[]) {\n    map<pair<int, int>, int> mp;\n    for (int i = 0; i < n; i++) {\n        sort(g[i].begin(), g[i].end());\n        assert(unique(g[i].begin(), g[i].end()) == g[i].end());\n        sort(g[i].begin(), g[i].end(), [&](int l, int r){\n            return arg(p[l]-p[i]) > arg(p[r]-p[i]);\n        });\n        for (int j = 0; j < (int)g[i].size(); j++) {\n            mp[make_pair(i, g[i][j])] = j;\n        }\n    }\n\n    vector<vector<int>> idx(n), rev(n);\n    for (int i = 0; i < n; i++) {\n        idx[i] = vector<int>(g[i].size(), -1);\n        rev[i].resize(g[i].size());\n        for (int j = 0; j < (int)g[i].size(); j++) {\n            rev[i][j] = mp[make_pair(g[i][j], i)];\n        }\n    }\n\n    int idc = 1;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < (int)g[i].size(); j++) {\n            if (idx[i][j] != -1) continue;\n            Pol po;\n            int ii = i, jj = j;\n            while (idx[ii][jj] != -2) {\n                po.push_back(p[ii]);\n                idx[ii][jj] = -2;\n                int ni = g[ii][jj];\n                int nj = (rev[ii][jj]+1) % g[ni].size();\n                ii = ni; jj = nj;\n            }\n            int id;\n            if (iscclock(po) != 1) {\n                id = 0;\n            } else {\n                id = idc;\n                pol[idc] = po;\n                idc++;\n            }\n            while (idx[ii][jj] == -2) {\n                idx[ii][jj] = id;\n                int ni = g[ii][jj];\n                int nj = (rev[ii][jj]+1) % g[ni].size();\n                ii = ni; jj = nj;\n            }\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < (int)g[i].size(); j++) {\n            if (idx[i][j] != 0) continue;\n            int id = 0;\n            for (int k = 1; k < idc; k++) {\n                if (contains(pol[k], p[i]) == 2) {\n                    id = k;\n                }\n            }\n            if (id == 0) continue;\n            int ii = i, jj = j;\n            while (idx[ii][jj] == 0) {\n                idx[ii][jj] = id;\n                int ni = g[ii][jj];\n                int nj = (rev[ii][jj]+1) % g[ni].size();\n                ii = ni; jj = nj;\n            }            \n        }\n    }\n\n    for (int i = 0; i < idc; i++) {\n        rg[i].clear();\n    }\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < (int)g[i].size(); j++) {\n            if (idx[i][j] < 0) continue;\n            rg[idx[i][j]].push_back(idx[g[i][j]][rev[i][j]]);\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        sort(rg[i].begin(), rg[i].end());\n        rg[i].erase(unique(rg[i].begin(), rg[i].end()), rg[i].end());\n    }\n\n    return idc;\n}\n\n\n\n\n\n\nconst int MN = 110;\n \n \nP p[MN];\nvector<int> g[MN];\n \nPol pol[2*MN];\nvector<int> rg[2*MN];\n \nint dist[2*MN][2*MN];\n \nbool solve() {\n    int c, w;\n    cin >> c >> w;\n    if (!c) return false;\n \n    for (int i = 0; i < c; i++) {\n        D x, y;\n        cin >> x >> y;\n        p[i] = P(x, y);\n        g[i].clear();\n    }\n \n    for (int i = 0; i < w; i++) {\n        int s, t;\n        cin >> s >> t; s--; t--;\n        g[s].push_back(t);\n        g[t].push_back(s);\n    }\n \n    dualGraph(p, g, c, pol, rg);\n    int ma = 0;\n    bool used[2*MN] = {};\n    queue<pair<int, int>> q;\n    q.push(make_pair(0, 0));\n    while (q.size()) {\n        int t, di;\n        tie(t, di) = q.front(); q.pop();\n        if (used[t]) continue;\n        used[t] = true;\n        ma = max(ma, di);\n        for (int d: rg[t]) {\n            if (used[d]) continue;\n            q.push(make_pair(d, di+1));\n        }\n    }\n    cout << ma << endl;\n    return true;\n}\n \n \nint main() {\n    while (solve()) {}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\n#define X real()\n#define Y imag()\n\ntypedef long double D;\ntypedef complex<D> P;\nstruct L{P a, b;};\ntypedef vector<P> Pol;\n\nconst D EPS = 1e-8;\nconst D PI = acos(-1);\n\nint sig(D a, D b = 0) {return a < b - EPS ? -1 : a > b + EPS ? 1 : 0;}\nbool near(P a, P b) {return !sig(norm(a - b));}\nnamespace std {\n  bool operator<(P a, P b) {return sig(a.X, b.X) ? a.X < b.X : a.Y < b.Y;}\n  bool operator<(L a, L b) {return !near(a.a, b.a) ? a.a < b.a : a.b < b.b;}\n}\n\nD det(P a, P b) {return a.X * b.Y - a.Y * b.X;}\n\nP vec(L a) {return a.b - a.a;}\n\nenum CCW{FRONT = 1, RIGHT = 2, BACK = 4, LEFT = 8, ON = 16};\nint ccw(P a, P b, P c) {\n  if (near(a, c) || near(b, c)) return ON;\n  int s = sig(det(b - a, c - a));\n  if (s) return s > 0 ? LEFT : RIGHT;\n  return (a < b) == (b < c) ? FRONT : (c < a) == (a < b) ? BACK : ON;\n}\n\nD arg(P base, P a, P b) {return arg((b - base) / (a - base));}\n\nbool iLLs(L a, L b) {return sig(det(vec(a), vec(b)));}\nbool iSS(L a, L b) {\n  int cwa = ccw(a.a, a.b, b.a) | ccw(a.a, a.b, b.b);\n  int cwb = ccw(b.a, b.b, a.a) | ccw(b.a, b.b, a.b);\n  return ((cwa | cwb) & ON) || ((cwa & cwb) == (LEFT | RIGHT));\n}\n\nP pLL(L a, L b) {return a.a + vec(a) * (det(vec(b), b.a - a.a) / det(vec(b), vec(a)));}\n\nD aPol(Pol vp) {D ret = 0; rep (i, vp.size()) ret += det(vp[i], vp[(i + 1) % vp.size()]); return ret / 2;}\n\nvector<L> merge(vector<L> s) {\n  rep (i, s.size()) if (s[i].b < s[i].a) swap(s[i].a, s[i].b);\n  sort(s.begin(), s.end());\n  rep (i, s.size()) rep (j, i) if (iSS(s[i], s[j]) && !iLLs(s[i], s[j])) {\n    s[j].b = max(s[i].b, s[j].b);\n    s.erase(s.begin() + i--);\n    break;\n  }\n  return s;\n}\n\nvector<vector<int> > sArr(vector<L> s, vector<P> &vp) {\n  s = merge(s);\n  rep (i, s.size()) {\n    vp.push_back(s[i].a);\n    vp.push_back(s[i].b);\n  }\n  rep (i, s.size()) rep (j, i) if (iSS(s[i], s[j])) vp.push_back(pLL(s[i], s[j]));\n  sort(vp.begin(), vp.end());\n  vp.erase(unique(vp.begin(), vp.end(), near), vp.end());\n  vector<vector<int> > g(vp.size());\n  rep (i, s.size()) {\n    vector<pair<D, int> > v;\n    rep (j, vp.size()) if (ccw(s[i].a, s[i].b, vp[j]) == ON) {\n      v.push_back(make_pair(norm(vp[j] - s[i].a), j));\n    }\n    sort(v.begin(), v.end());\n    rep (j, v.size() - 1) {\n      g[v[j + 1].second].push_back(v[j].second);\n      g[v[j].second].push_back(v[j + 1].second);\n    }\n  }\n  return g;\n}\n\nvector<Pol> dual(vector<L> s) {\n  vector<P> vp;\n  vector<vector<int> > edge = sArr(s, vp);\n  vector<vector<bool> > used(edge.size());\n  rep (i, edge.size()) rep (j, edge[i].size()) used[i].push_back(false);\n  vector<Pol> vpol;\n  rep (i, edge.size()) rep (j, edge[i].size()) if (!used[i][j]) {\n    Pol pol;\n    pol.push_back(vp[i]);\n    used[i][j] = true;\n    int pre = i, now = edge[i][j];\n    while (now != i) {\n      pol.push_back(vp[now]);\n      D a = -4;\n      int next = -1;\n      rep (k, edge[now].size()) {\n\tD aa = arg(vp[now], (D)2 * vp[now] - vp[pre], vp[edge[now][k]]);\n\tif (!sig(aa, PI)) aa = -PI;\n\tif (a < aa) {\n\t  a = aa;\n\t  next = k;\n\t}\n      }\n      used[now][next] = true;\n      pre = now;\n      now = edge[pre][next];\n    }\n    vpol.push_back(pol);\n  }\n  return vpol;\n}\n\nint main() {\n  while (true) {\n    int c, w;\n    cin >> c >> w;\n    if (c == 0) break;\n    vector<P> vp(c);\n    rep (i, c) cin >> vp[i].X >> vp[i].Y;\n    vector<L> vs(w);\n    rep (i, w) {\n      int s, t;\n      cin >> s >> t;\n      --s, --t;\n      vs[i].a = vp[s];\n      vs[i].b = vp[t];\n    }\n    vector<Pol> vpol = dual(vs);\n    vector<int> edge[vpol.size()];\n    rep (i, vpol.size()) rep (j, i) {\n      rep (ii, vpol[i].size()) rep (jj, vpol[j].size()) {\n\tif (!near(vpol[i][ii], vpol[j][(jj + 1) % vpol[j].size()])) continue;\n\tif (!near(vpol[i][(ii + 1) % vpol[i].size()], vpol[j][jj])) continue;\n\tedge[i].push_back(j);\n\tedge[j].push_back(i);\n      }\n    }\n    int dis[vpol.size()];\n    rep (i, vpol.size()) dis[i] = 1e9;\n    queue<pair<int, int> > que;\n    rep (i, vpol.size()) if (aPol(vpol[i]) < 0) que.push(make_pair(i, 0));\n    while (!que.empty()) {\n      pair<int, int> now = que.front();\n      que.pop();\n      if (dis[now.first] <= now.second) continue;\n      dis[now.first] = now.second;\n      rep (i, edge[now.first].size()) {\n\tque.push(make_pair(edge[now.first][i], now.second + 1));\n      }\n    }\n    int res = 0;\n    rep (i, vpol.size()) res = max(res, dis[i]);\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <set>\nusing namespace std;\n\nconst double EPS = 1e-10;\nconst double INF = 1e12;\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n#define X real()\n#define Y imag()\n\ntypedef complex<double> P;\ntypedef vector<P> VP;\nstruct L : VP{\n    L(const P& a, const P& b){ resize(2); at(0)=a; at(1)=b; }\n    L(){ resize(2); }\n};\n\nnamespace std{\n    bool operator < (const P &a, const P &b){\n        return !EQ(a.X, b.X)? a.X<b.X : a.Y<b.Y;\n    }\n    bool operator == (const P &a, const P &b){\n        return abs(a-b) < EPS;\n    }\n}\n\ndouble dot(P a, P b){\n    return (conj(a)*b).X;\n}\ndouble cross(P a, P b){\n    return (conj(a)*b).Y;\n}\nint ccw(P a, P b, P c){\n    b -= a;\n    c -= a;\n    if(cross(b,c) > EPS) return +1; //ccw\n    if(cross(b,c) <-EPS) return -1; //cw\n    if(dot(b,c) < EPS) return +2; //c-a-b\n    if(norm(b) < norm(c)) return -2; //a-b-c\n    return 0; //a-c-b\n}\n\nP projection(const L& l, const P& p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1]-l[0], m[1]-m[0]);\n  double B = cross(l[1]-l[0], l[1]-m[0]);\n  return m[0] + B /A *(m[1]-m[0]);\n}\n\ndouble getangle(const P &p, const P &a, const P &b){ //clockwise\n    P proj = projection(L(p,a), b);\n    int minus = (dot(a-p, b-p)>=0)? 1 :-1;\n    if(ccw(p,a,b)!=1){\n        return atan2(abs(b-proj), minus*abs(p-proj));\n    }else{\n        return 2*M_PI - atan2(abs(b-proj), minus*abs(p-proj));\n    }\n}\n\nvoid trace(int cidx, vector<vector<int> > &adj, map<pair<int,int>, int> &rest, VP &plist, vector<int> &poly, bool outside){\n    P curr = plist[cidx];\n    P prev = P(0, -1);\n    int pidx = -1;\n    poly = vector<int>();\n    bool first=true;\n    while(1){\n        int next = -1;\n        bool rightmost = !first && !outside;\n        double m_angle = rightmost? -INF: INF;\n        for(int i=0; i<(int)adj[cidx].size(); i++){\n            if(adj[cidx][i] == pidx) continue;\n            int imin = min(cidx, adj[cidx][i]);\n            int imax = max(cidx, adj[cidx][i]);\n            if(rest[make_pair(imin, imax)] == 0) continue;\n            double angle = getangle(curr, prev, plist[adj[cidx][i]]);\n            if((rightmost && angle > m_angle) || (!rightmost && angle < m_angle)){\n                next = adj[cidx][i];\n                m_angle = angle;\n            }\n        }\n        if(!first && next == poly[0]) break;\n        poly.push_back(next);\n        prev = curr;\n        pidx = cidx;\n        curr = plist[next];\n        cidx = next;\n        first = false;\n    }\n}\n\nvoid makeDualGraph(vector<vector<int> > &adj, vector<vector<int> > &dual, VP &plist){\n    int n = adj.size();\n    vector<int> degree(n);\n    map<pair<int,int>, int> rest;\n    for(int i=0; i<n; i++){\n        for(int j=0; j<(int)adj[i].size(); j++){\n            if(i<adj[i][j]){\n                rest[make_pair(i, adj[i][j])] = 2;\n            }\n        }\n        degree[i] = adj[i].size()*2;\n    }\n    \n    map<pair<int,int>, int> edgelist;\n    dual = vector<vector<int> >();\n    dual.reserve(200);\n    \n    int sptr=0;\n    int areaidx=-1;\n    bool first = true;\n    while(1){\n        while(sptr<n && degree[sptr]==0) sptr++;\n        if(sptr==n) break;\n        areaidx++;\n        \n        vector<int> border;\n        trace(sptr, adj, rest, plist, border, first);\n        dual.push_back(vector<int>());\n        \n        for(int i=0; i<(int)border.size(); i++){\n            int a = border[i];\n            int b = border[(i+1)%(int)border.size()];\n            if(a>b) swap(a,b);\n            degree[a]--;\n            degree[b]--;\n            rest[make_pair(a,b)]--;\n            if(edgelist.count(make_pair(a,b)) == 0){\n                edgelist[make_pair(a,b)] = areaidx;\n            }else{\n                dual[areaidx].push_back(edgelist[make_pair(a,b)]);\n                dual[edgelist[make_pair(a,b)]].push_back(areaidx);\n            }\n        }\n        first = false;\n    }\n    \n    for(int i=0; i<=areaidx; i++){\n        sort(dual[i].begin(), dual[i].end());\n        dual[i].erase(unique(dual[i].begin(), dual[i].end()), dual[i].end());\n    }\n}\n\nconst int inf = 1e9;\n\nint main(){\n\twhile(1){\n\t\tint c,w;\n\t\tcin >> c >> w;\n\t\tif(c==0) break;\n\t\t\n\t\tvector<pair<P, int> > bar(c);\n\t\tfor(int i=0; i<c; i++){\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\tbar[i] = make_pair(P(x,y), i+1);\n\t\t}\n\t\tsort(bar.begin(), bar.end());\n\t\t\n\t\tvector<int> backref(c);\n\t\tVP p(c);\n\t\tfor(int i=0; i<c; i++){\n\t\t\tbackref[bar[i].second] = i;\n\t\t\tp[i] = bar[i].first;\n\t\t}\n\t\t\n\t\tvector<vector<int> > adj(c), dual;\n\t\tfor(int i=0; i<w; i++){\n\t\t\tint s,t;\n\t\t\tcin >> s >> t;\n\t\t\tadj[backref[s]].push_back(backref[t]);\n\t\t\tadj[backref[t]].push_back(backref[s]);\n\t\t}\n\t\tmakeDualGraph(adj, dual, p);\n\t\t\n\t\tint numarea = dual.size();\n\t\tset<int> reach;\n\t\treach.insert(0);\n\t\tint ans = 0;\n\t\twhile(1){\n\t\t\tif((int)reach.size() == numarea) break;\n\t\t\tset<int> newreach;\n\t\t\tfor(set<int>::iterator itr=reach.begin(); itr!=reach.end(); itr++){\n\t\t\t\tnewreach.insert(*itr);\n\t\t\t\tfor(int i=0; i<(int)dual[*itr].size(); i++){\n\t\t\t\t\tnewreach.insert(dual[*itr][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treach = newreach;\n\t\t\tans++;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<int,pair<bool,double> > P2;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define min_3(a,b,c) min(a,min(b,c))\n#define max_3(a,b,c) max(a,max(b,c))\n#define mp1(a,b,c) P1(a,P(b,c))\n#define mp2(a,b,c) P2(a,pair<bool,double>(b,c))\n#define pque(a) priority_queue<a>\n#define rpque(a) priority_queue<a,vector<a>,greater<a>>\n\nconst int INF=1000000000;\nconst int dre_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dre_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\nconst int kaijou[10]={1,1,2,6,24,120,720,5040,40320,362880};\n\nbool com(P2 x,P2 y){\n\tif(x.sc.fr!=y.sc.fr)return x.sc.fr;\n\treturn x.sc.sc>=y.sc.sc;\n}\n\nint main(){\n\tint ppp=0;\n\twhile(1){\n\t\tppp++; if(ppp>=10)return 0;\n\t\tstatic int v,w;\n\t\tstatic int x[110],y[110];\n\t\tstatic int s,t;\n\t\t\n\t\tscanf(\"%d%d\",&v,&w); if(v==0&&w==0)break;\n\t\trep1(i,v)scanf(\"%d%d\",&x[i],&y[i]);\n\t\t\n\t\tstatic vector<P1> V_; V_.clear();\n\t\trep1(i,v){\n\t\t\tV_.pb(mp1(x[i],y[i],i));\n\t\t}\n\t\tsor(V_);\n\t\tstatic vector<P2> vec_[110];\n\t\trep1(i,v){\n\t\t\tvec_[i].clear();\n\t\t\tvec_[i].pb(mp2(0,false,-INF));\n\t\t\trep1(j,v){\n\t\t\t\tif(i==j)continue;\n\t\t\t\tif(x[i]<x[j]){\n\t\t\t\t\tvec_[i].pb(mp2(j,true,(double)(y[j]-y[i])/(x[j]-x[i])));\n\t\t\t\t}\n\t\t\t\telse if(x[i]>x[j]){\n\t\t\t\t\tvec_[i].pb(mp2(j,false,(double)(y[j]-y[i])/(x[j]-x[i])));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(y[j]>y[i])vec_[i].pb(mp2(j,true,(double)INF));\n\t\t\t\t\telse vec_[i].pb(mp2(j,true,(double)-INF));\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(vec_[i].begin(),vec_[i].end(),com);\n\t\t}\n\t\t\n\t\tstatic int e;\n\t\tstatic vector<int> V; V.clear();\n\t\tstatic bool edge[110][110];\n\t\tstatic vector<int> vec[110]; \n\t\t\n\t\te=w;\n\t\trep(i,v)V.pb(V_[i].sc.sc);\n\t\trep(i,110)rep(j,110)edge[i][j]=false;\n\t\trep(i,e){\n\t\t\tscanf(\"%d%d\",&s,&t);\n\t\t\tedge[s][t]=true;\n\t\t\tedge[t][s]=true;\n\t\t}\n\t\trep1(i,v){\n\t\t\tvec[i].clear();\n\t\t\trep(j,vec_[i].size()){\n\t\t\t\tvec[i].pb(vec_[i][j].fr);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ret=0;\n\t\twhile(e>0){\n\t\t\tret++;\n\t\t\t\n\t\t\tint a=-1;\n\t\t\trep(i,V.size()){\n\t\t\t\trep(j,105){\n\t\t\t\t\tif(edge[V[i]][j]){a=V[i]; break;}\n\t\t\t\t}\n\t\t\t\tif(a!=-1)break;\n\t\t\t}\n\t\t\t\n\t\t\tint b=0,c=a;\n\t\t\twhile(1){\n\t\t\t\tif(c==-1||vec[c].size()==0)break;\n\t\t\t\trep(i,vec[c].size()){\n\t\t\t\t\tif(vec[c][i]==b){\n\t\t\t\t\t\ti++; i%=vec[c].size();\n\t\t\t\t\t\twhile(!edge[c][vec[c][i]]){\n\t\t\t\t\t\t\ti++; i%=vec[c].size();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tedge[c][vec[c][i]]=false;\n\t\t\t\t\t\tedge[vec[c][i]][c]=false;\n\t\t\t\t\t\te--;\n\t\t\t\t\t\tb=c;\n\t\t\t\t\t\tc=vec[c][i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(c==a)break;\n\t\t\t}\n\t\t\t\n\t\t\tbool updata=true;\n\t\t\twhile(updata){\n\t\t\t\tupdata=false;\n\t\t\t\trep1(i,v){\n\t\t\t\t\tint cnt=0;\n\t\t\t\t\tint t=105;\n\t\t\t\t\trep1(j,v){\n\t\t\t\t\t\tif(edge[i][j]){cnt++; t=j;}\n\t\t\t\t\t}\n\t\t\t\t\tif(cnt==1){\n\t\t\t\t\t\tupdata=true;\n\t\t\t\t\t\tedge[i][t]=false;\n\t\t\t\t\t\tedge[t][i]=false;\n\t\t\t\t\t\te--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n==0) ? 1 : 10*TEN(n-1); }\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\nusing D = double;\nusing P = complex<D>;\n\nconst D PI = acos(D(-1)), EPS = 1e-10;\n\nint sgn(D a) {\n    if (abs(a) <= EPS) return 0;\n    return (a < 0) ? -1 : 1;\n}\nbool near(P a, P b) { return !sgn(abs(a-b)); }\nD mabs(P p) { return abs(p.real()) + abs(p.imag()); }\n\nbool lessP(P l, P r) {\n    if (sgn(r.real()-l.real())) return l.real() < r.real();\n    if (sgn(r.imag()-l.imag())) return l.imag() < r.imag();\n    return false;\n}\n\nD cross(P a, P b) { return a.real()*b.imag() - a.imag()*b.real(); }\nD dot(P a, P b) { return a.real()*b.real() + a.imag()*b.imag(); }\n\n// -2, -1, 0, 1, 2 : front, clock, on, cclock, back\nint ccw(P b, P c) {\n    int s = sgn(cross(b, c) / mabs(b));\n    if (s) return s;\n    if (!sgn(mabs(c)) || !sgn(mabs(c-b))) return 0;\n    if (dot(b, c) < 0) return 2;\n    if (dot(-b, c-b) < 0) return -2;\n}\nint ccw(P a, P b, P c) { return ccw(b-a, c-a); }\n\nstruct L {\n    P s, t;\n    L() {}\n    L(P s, P t) : s(s), t(t) {}\n    P vec() const { return t-s; }\n};\nD abs(L l) { return abs(l.vec()); }\nD arg(L l) { return arg(l.vec()); }\nint ccw(L l, P p) { return ccw(l.s, l.t, p); }\n\nbool insSS(const L &s, const L &t) {\n    int a = ccw(s, t.s), b = ccw(s, t.t);\n    int c = ccw(t, s.s), d = ccw(t, s.t);\n    if (a*b <= 0 && c*d <= 0) return true;\n    return false;\n}\n\nD distLP(const L &l, const P &p) {\n    return abs(cross(l.vec(), p-l.s))/abs(l.vec());\n}\n\nD distSP(const L &s, const P &p) {\n    P s2 = s.vec()*P(0, 1);\n    if (ccw(s.s, s.s+s2, p) == 1) return abs(s.s-p);\n    if (ccw(s.t, s.t+s2, p) == -1) return abs(s.t-p);\n    return distLP(s, p);\n}\n\nD distSS(const L &s, const L &t) {\n    if (insSS(s, t)) return 0;\n    return min({distSP(s, t.s), distSP(s, t.t),\n        distSP(t, s.s), distSP(t, s.t)});\n}\n\n\nint crossLL(const L &l, const L &m, P &r) {\n    if (sgn(cross(l.vec(), m.vec())) == 0) {\n        r = l.s;\n        if (ccw(l.s, l.t, m.s) % 2 == 0) return -1;\n        return 0;\n    }\n    D t = cross(l.vec(), l.t - m.s) / cross(l.vec(), m.vec());\n    r = m.s + t * m.vec();\n    return 1;\n/*    L mm = L(m.x - l.x, m.y - l.x);\n    mm.x *= polar<D>(1, -arg(l));\n    mm.y *= polar<D>(1, -arg(l));\n    if (sgn(mm.vec().imag()) == 0) {\n        r = l.x;\n        if (sgn(mm.x.imag()) == 0) return -1;\n        return 0;\n    }\n    r = mm.x - mm.vec() * (mm.x.imag() / mm.vec().imag());\n    r *= polar<D>(1, arg(l));\n    r += l.x;\n    return 1;*/\n}\nint crossSS(const L &l, const L &m, P &r) {\n    int u = crossLL(l, m, r);\n    if (u == 0) return 0;\n    if (u == -1) {\n        int x = ccw(l, m.s);\n        int y = ccw(l, m.t);\n        if (x == 0) {\n            r = m.s;\n            return -1;\n        }\n        if (y == 0) {\n            r = m.t;\n            return -1;\n        }\n        if (x == y) return 0;\n        r = l.s;\n        return -1;\n    }\n    if (ccw(l, r) == 0 && ccw(m, r) == 0) return 1;\n    return 0;\n}\n\nusing Pol = V<P>;\n\nP cu(const Pol &p, int i) {\n    int s = p.size();\n    return p[(i%s+s)%s];\n};\n//0:P is out 1:P is on line 2:P is in\nint contains(const Pol &pol, P p) {\n    int in = -1;\n    for (int i = 0; i < int(pol.size()); i++) {\n        P a=cu(pol,i)-p, b=cu(pol,i+1)-p;\n        if (ccw(a, b, P(0, 0)) == 0) return 1;\n        if (imag(a) > imag(b)) swap(a, b);\n        if (imag(a) <= 0 && 0 < imag(b)) {\n            if (cross(a, b) < 0) in *= -1;\n        }\n    }\n    return in+1;\n}\n\nD area_naive(const Pol &p) {\n    D u = 0;\n    for (int i = 0; i < (int)p.size(); i++) {\n        u += cross(cu(p, i), cu(p, i+1));\n    }\n    return u/2;\n}\n\n/*\n -1 -> clock\n 0 -> non polygon\n 1 -> counter clock\n */\nint iscclock(const Pol &p) {\n    return sgn(area_naive(p));\n}\n\n//0:P is out 1:P is on line 2:P is in\nint contains(const Pol &pol, const L &l) {\n    vector<P> v;\n    v.push_back(l.s); v.push_back(l.t);\n    for (int i = 0; i < (int)pol.size(); i++) {\n        P a = cu(pol, i), b = cu(pol, i+1);\n        P p;\n        if (crossSS(L(a, b), l, p)) {\n            v.push_back(p);\n        }\n    }\n\n    sort(v.begin(), v.end(), [&](const P &x, const P &y){\n        return abs(l.s-x) < abs(l.s-y);\n    });\n\n    int sz = (int)v.size();\n    for (int i = 0; i < sz-1; i++) {\n        v.push_back((v[i]+v[i+1])/D(2));\n    }\n    bool f = false;\n    for (P p: v) {\n        int u = contains(pol, p); \n        if (!u) return 0;\n        if (u == 2) f = true;\n    }\n    if (f) return 2;\n    return 1;\n}\n\n\n/*\n 双対グラフを作成\n pol, rgの要素は2*n-4個確保しておくこと\n gはめちゃくちゃに破壊される\n もし連結でないグラフ、しかも内包があるグラフに行うとrgは0が複数混入する\n 0は、その連結成分だけに注目したときの外側の意味。本当に外側か判定したいなら\n contains等を使用すること\n */\nint dualGraph(P p[], vector<int> g[], int n,\n    Pol pol[], vector<int> rg[]) {\n    map<pair<int, int>, int> mp;\n    for (int i = 0; i < n; i++) {\n        sort(g[i].begin(), g[i].end());\n        assert(unique(g[i].begin(), g[i].end()) == g[i].end());\n        sort(g[i].begin(), g[i].end(), [&](int l, int r){\n            return arg(p[l]-p[i]) > arg(p[r]-p[i]);\n        });\n        for (int j = 0; j < (int)g[i].size(); j++) {\n            mp[make_pair(i, g[i][j])] = j;\n        }\n    }\n\n    vector<vector<int>> idx(n), rev(n);\n    for (int i = 0; i < n; i++) {\n        idx[i] = vector<int>(g[i].size(), -1);\n        rev[i].resize(g[i].size());\n        for (int j = 0; j < (int)g[i].size(); j++) {\n            rev[i][j] = mp[make_pair(g[i][j], i)];\n        }\n    }\n\n    int idc = 1;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < (int)g[i].size(); j++) {\n            if (idx[i][j] != -1) continue;\n            Pol po;\n            int ii = i, jj = j;\n            while (idx[ii][jj] != -2) {\n                po.push_back(p[ii]);\n                idx[ii][jj] = -2;\n                int ni = g[ii][jj];\n                int nj = (rev[ii][jj]+1) % g[ni].size();\n                ii = ni; jj = nj;\n            }\n            int id;\n            if (iscclock(po) != 1) {\n                id = 0;\n            } else {\n                id = idc;\n                pol[idc] = po;\n                idc++;\n            }\n            while (idx[ii][jj] == -2) {\n                idx[ii][jj] = id;\n                int ni = g[ii][jj];\n                int nj = (rev[ii][jj]+1) % g[ni].size();\n                ii = ni; jj = nj;\n            }\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < (int)g[i].size(); j++) {\n            if (idx[i][j] != 0) continue;\n            int id = 0;\n            for (int k = 1; k < idc; k++) {\n                if (contains(pol[k], p[i]) == 2) {\n                    id = k;\n                }\n            }\n            if (id == 0) continue;\n            int ii = i, jj = j;\n            while (idx[ii][jj] == 0) {\n                idx[ii][jj] = id;\n                int ni = g[ii][jj];\n                int nj = (rev[ii][jj]+1) % g[ni].size();\n                ii = ni; jj = nj;\n            }            \n        }\n    }\n\n    for (int i = 0; i < idc; i++) {\n        rg[i].clear();\n    }\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < (int)g[i].size(); j++) {\n            if (idx[i][j] < 0) continue;\n            rg[idx[i][j]].push_back(idx[g[i][j]][rev[i][j]]);\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        sort(rg[i].begin(), rg[i].end());\n        rg[i].erase(unique(rg[i].begin(), rg[i].end()), rg[i].end());\n    }\n\n    return idc;\n}\n\n\n\n\n\n\nconst int MN = 110;\n \n \nP p[MN];\nvector<int> g[MN];\n \nPol pol[2*MN];\nvector<int> rg[2*MN];\n \nint dist[2*MN][2*MN];\n \nbool solve() {\n    int c, w;\n    cin >> c >> w;\n    if (!c) return false;\n \n    for (int i = 0; i < c; i++) {\n        D x, y;\n        cin >> x >> y;\n        p[i] = P(x, y);\n        g[i].clear();\n    }\n \n    for (int i = 0; i < w; i++) {\n        int s, t;\n        cin >> s >> t; s--; t--;\n        g[s].push_back(t);\n        g[t].push_back(s);\n    }\n \n    dualGraph(p, g, c, pol, rg);\n    int ma = 0;\n    bool used[2*MN] = {};\n    queue<pair<int, int>> q;\n    q.push(make_pair(0, 0));\n    while (q.size()) {\n        int t, di;\n        tie(t, di) = q.front(); q.pop();\n        if (used[t]) continue;\n        used[t] = true;\n        ma = max(ma, di);\n        for (int d: rg[t]) {\n            if (used[d]) continue;\n            q.push(make_pair(d, di+1));\n        }\n    }\n    cout << ma << endl;\n    return true;\n}\n \n \nint main() {\n    while (solve()) {}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <utility>\n#include <queue>\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<double,int> pdi;\n\nstruct column{\n\tP z;\n\tvector<pdi> adj;\n};\n\nstruct wall{\n\tint s, t;\n\tint a, b;\n\n\twall(): s(-1), t(-1), a(-1), b(-1) {}\n\n\tvoid add(int x){\n\t\tif(a == -1) a = x;\n\t\telse if(b == -1) b = x;\n\t\telse{\nthrow x;\n\t\t}\n\t}\n};\n\nvector<column> cl;\nvector<wall> wl;\nvector<vector<int> > room;\n\nint solve(){\n\tint c = cl.size(), w = wl.size();\n\tfor(int i = 0; i < w; ++i){\n\t\tint s = wl[i].s, t = wl[i].t;\n\t\tdouble a = arg(cl[t].z - cl[s].z);\n\t\tcl[s].adj.push_back(pdi(a, i));\n\n\t\ta = arg(cl[s].z - cl[t].z);\n\t\tcl[t].adj.push_back(pdi(a, i));\n\t}\n\t\n\tfor(int i = 0; i < c; ++i){\n\t\tsort(cl[i].adj.begin(), cl[i].adj.end());\n\t\tdouble a = cl[i].adj[0].first + 12.56;\n\t\tcl[i].adj.push_back(pdi(a, cl[i].adj[0].second));\n\t}\n\n\troom.clear();\n\tvector<int> visw;\n\tfor(int i = 0; i < c; ++i){\n\t\tfor(int j = 0; j + 1 < cl[i].adj.size(); ++j){\n\t\t\tvisw.clear();\n\t\t\tint prev = i;\n\t\t\tint wn0 = cl[i].adj[j].second;\n\t\t\tint wn = wn0;\n\n\t\t\tif(wl[wn0].b != -1) continue;\t//探索済み壁\n\n\t\t\tdo{\n\t\t\t\tint now = prev ^ wl[wn].s ^ wl[wn].t;\n\t\t\t\tvisw.push_back(wn);\n\t\t\t\tpdi p(arg(cl[prev].z - cl[now].z) + 1e-12, -9);\n\n\t\t\t\tconst vector<pdi> &adj = cl[now].adj;\n\t\t\t\twn = upper_bound(adj.begin(), adj.end(), p)->second;\n\t\t\t\tprev = now;\n\t\t\t} while(prev != i);\n\n\t\t\tsort(visw.begin(), visw.end());\n\n\t\t\tif(wl[wn0].a != -1 && wl[wn0].b == -1){\n\t\t\t\tif(room[wl[wn0].a] == visw){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int k = 0; k < visw.size(); ++k){\n\t\t\t\twl[visw[k]].add(room.size());\n\t\t\t}\n\t\t\troom.push_back(visw);\n\t\t}\n\t}\n\n\tvector<int> out;\n\tfor(int i = 0; i < w; ++i){\n\t\tif(wl[i].b == -1){\n\t\t\twl[i].b = room.size();\n\t\t\tout.push_back(i);\n\t\t}\n\t}\n\n\tif(!out.empty()){\n\t\troom.push_back(out);\n\t}\n\n\tint rn = room.size();\n\tvector<vector<char> > G(rn, vector<char>(rn));\n\tfor(int i = 0; i < w; ++i){\n\t\tint a = wl[i].a, b = wl[i].b;\n\t\tG[a][b] = G[b][a] = 1;\n\t}\n\n\tvector<int> visit(rn, -1);\n\tqueue<int> q;\n\tq.push(rn - 1);\n\tvisit[rn - 1] = 0;\n\twhile(!q.empty()){\n\t\tfor(int i = 0; i < rn; ++i){\n\t\t\tif(G[q.front()][i] && visit[i] == -1){\n\t\t\t\tq.push(i);\n\t\t\t\tvisit[i] = visit[q.front()] + 1;\n\t\t\t}\n\t\t}\n\t\tq.pop();\n\t}\n\n\treturn *max_element(visit.begin(), visit.end());\n}\n\nint main(){\n\tint c, w, x, y;\n\troom.reserve(321);\n\twhile(scanf(\"%d%d\", &c, &w), c){\n\t\tcl.assign(c, column());\n\t\twl.assign(w, wall());\n\t\t\n\t\tfor(int i = 0; i < c; ++i){\n\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t\tcl[i].z = P(x, y);\n\t\t}\n\t\tfor(int i = 0; i < w; ++i){\n\t\t\tscanf(\"%d%d\", &wl[i].s, &wl[i].t);\n\t\t\t--wl[i].s;\n\t\t\t--wl[i].t;\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", solve());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<int,pair<bool,double>> P2;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define min_3(a,b,c) min(a,min(b,c))\n#define max_3(a,b,c) max(a,max(b,c))\n#define mp1(a,b,c) P1(a,P(b,c))\n#define mp2(a,b,c) P2(a,pair<bool,double>(b,c))\n#define pque(a) priority_queue<a>\n#define rpque(a) priority_queue<a,vector<a>,greater<a>>\n\nconst int INF=1000000000;\nconst int dre_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dre_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\nconst int kaijou[10]={1,1,2,6,24,120,720,5040,40320,362880};\n\nbool com(P2 x,P2 y){\n\tif(x.sc.fr!=y.sc.fr)return x.sc.fr;\n\treturn x.sc.sc>=y.sc.sc;\n}\n\nint main(){\n\twhile(1){\n\t\tint c,w;\n\t\tint x[110],y[110];\n\t\tint s,t;\n\t\t\n\t\tscanf(\"%d%d\",&c,&w); if(c==0&&w==0)break;\n\t\trep1(i,c)scanf(\"%d%d\",&x[i],&y[i]);\n\t\t\n\t\tvector<P1> V_;\n\t\trep1(i,c){\n\t\t\tV_.pb(mp1(x[i],y[i],i));\n\t\t}\n\t\tsor(V_);\n\t\tvector<P2> vec_[110];\n\t\trep1(i,c){\n\t\t\tvec_[i].pb(mp2(0,false,-INF));\n\t\t\trep1(j,c){\n\t\t\t\tif(i==j)continue;\n\t\t\t\tif(x[i]<x[j]){\n\t\t\t\t\tvec_[i].pb(mp2(j,true,(double)(y[j]-y[i])/(x[j]-x[i])));\n\t\t\t\t}\n\t\t\t\telse if(x[i]>x[j]){\n\t\t\t\t\tvec_[i].pb(mp2(j,false,(double)(y[j]-y[i])/(x[j]-x[i])));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(y[j]>y[i])vec_[i].pb(mp2(j,true,(double)INF));\n\t\t\t\t\telse vec_[i].pb(mp2(j,true,(double)-INF));\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(vec_[i].begin(),vec_[i].end(),com);\n\t\t}\n\t\t\n\t\tint v,e;\n\t\tvector<int> V;\n\t\tbool edge[110][110];\n\t\tvector<int> vec[110];\n\t\t\n\t\tv=c; e=w;\n\t\trep(i,c)V.pb(V_[i].sc.sc);\n\t\trep(i,110)rep(j,110)edge[i][j]=false;\n\t\trep(i,e){\n\t\t\tscanf(\"%d%d\",&s,&t);\n\t\t\tedge[s][t]=true;\n\t\t\tedge[t][s]=true;\n\t\t}\n\t\trep1(i,c){\n\t\t\trep(j,vec_[i].size()){\n\t\t\t\tvec[i].pb(vec_[i][j].fr);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ret=0;\n\t\twhile(e>0){\n\t\t\tret++;\n\t\t\t\n\t\t\tint a=-1;\n\t\t\trep(i,V.size()){\n\t\t\t\trep(j,105){\n\t\t\t\t\tif(edge[V[i]][j]){a=V[i]; break;}\n\t\t\t\t}\n\t\t\t\tif(a!=-1)break;\n\t\t\t}\n\t\t\t\n\t\t\tint b=0,c=a;\n\t\t\twhile(1){\n\t\t\t\trep(i,vec[c].size()){\n\t\t\t\t\tif(vec[c][i]==b){\n\t\t\t\t\t\ti++; i%=vec[c].size();\n\t\t\t\t\t\twhile(!edge[c][vec[c][i]]){\n\t\t\t\t\t\t\ti++; i%=vec[c].size();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tedge[c][vec[c][i]]=false;\n\t\t\t\t\t\tedge[vec[c][i]][c]=false;\n\t\t\t\t\t\te--;\n\t\t\t\t\t\tb=c;\n\t\t\t\t\t\tc=vec[c][i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(c==a)break;\n\t\t\t}\n\t\t\t\n\t\t\tbool updata=true;\n\t\t\twhile(updata){\n\t\t\t\tupdata=false;\n\t\t\t\trep1(i,c){\n\t\t\t\t\tint cnt=0;\n\t\t\t\t\tint t=-1;\n\t\t\t\t\trep1(j,c){\n\t\t\t\t\t\tif(edge[i][j]){cnt++; t=j;}\n\t\t\t\t\t}\n\t\t\t\t\tif(cnt==1){\n\t\t\t\t\t\tupdata=true;\n\t\t\t\t\t\tedge[i][t]=false;\n\t\t\t\t\t\tedge[t][i]=false;\n\t\t\t\t\t\te--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <queue>\n#include <cstdio>\n#include <cassert>\n#include <algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst double EPS=1e-8;\nconst double PI=acos(-1);\n\nstruct point{\n\tdouble x,y;\n\tpoint():x(0),y(0){}\n\tpoint(double x,double y):x(x),y(y){}\n\tpoint &operator+=(const point &a){ x+=a.x; y+=a.y; return *this; }\n\tpoint &operator-=(const point &a){ x-=a.x; y-=a.y; return *this; }\n\tpoint &operator*=(double c){ x*=c; y*=c; return *this; }\n\tpoint &operator/=(double c){ x/=c; y/=c; return *this; }\n\tpoint operator+(const point &a)const{ return point(x+a.x,y+a.y); }\n\tpoint operator-(const point &a)const{ return point(x-a.x,y-a.y); }\n\tpoint operator/(double c)const{ return point(x/c,y/c); }\n\tpoint operator-()const{ return point(-x,-y); }\n\tbool operator< (const point &a)const{ return x+EPS<a.x || (abs(x-a.x)<EPS && y+EPS<a.y); }\n\tbool operator==(const point &a)const{ return abs(x-a.x)<EPS && abs(y-a.y)<EPS; }\n\tbool operator!=(const point &a)const{ return abs(x-a.x)>EPS || abs(y-a.y)>EPS; }\n};\n\ndouble cross(const point &a,const point &b){ return a.x*b.y-a.y*b.x; }\n\ndouble arg(const point &a){ double t=atan2(a.y,a.x); return t<0?t+2*PI:t; }\n\ntypedef vector<point> polygon;\n\nbool is_ccw(const polygon &F){\n\tint n=F.size();\n\tdouble A=0;\n\trep(i,n) A+=cross(F[i],F[(i+1)%n]);\n\treturn A>-EPS;\n}\n\n// trace the frame of a polygon\nvector<int> trace(int n,const vector<int> *G,int u0,int i0){\n\tvector<int> F;\n\tint u=u0,i=i0;\n\tdo{\n\t\tF.push_back(u);\n\t\tint v=G[u][i];\n\t\tint k=G[v].size();\n\t\trep(j,k) if(G[v][j]==u) i=(j-1+k)%k;\n\t\tu=v;\n\t}while(u!=u0);\n\treturn F;\n}\n\n// normalize the list of vertices\nvector<int> reg(vector<int> a){\n\tint k=min_element(a.begin(),a.end())-a.begin();\n\trep(i,k){\n\t\ta.push_back(a[0]);\n\t\ta.erase(a.begin());\n\t}\n\treturn a;\n}\n\nint main(){\n\tfor(int n,m;scanf(\"%d%d\",&n,&m),n;){\n\t\tpoint P[100];\n\t\trep(u,n) scanf(\"%lf%lf\",&P[u].x,&P[u].y);\n\n\t\tvector<int> G[100];\n\t\trep(i,m){\n\t\t\tint u,v; scanf(\"%d%d\",&u,&v); u--; v--;\n\t\t\tG[u].push_back(v);\n\t\t\tG[v].push_back(u);\n\t\t}\n\n\t\t// angle sort\n\t\trep(u,n){\n\t\t\tint k=G[u].size();\n\t\t\tpair<double,int> A[100];\n\t\t\trep(i,k){\n\t\t\t\tint v=G[u][i];\n\t\t\t\tA[i]=make_pair(arg(P[v]-P[u]),v);\n\t\t\t}\n\t\t\tsort(A,A+k);\n\t\t\trep(i,k) G[u][i]=A[i].second;\n\t\t}\n\n\t\t// decompose to polygons\n\t\tvector< vector<int> > F; // set of polygons\n\t\trep(u,n) rep(i,G[u].size()) F.push_back(reg(trace(n,G,u,i)));\n\t\tsort(F.begin(),F.end());\n\t\tF.erase(unique(F.begin(),F.end()),F.end());\n\n\t\t// find the outside boundary\n\t\tint n2=F.size(),u0=-1;\n\t\trep(u,n2){\n\t\t\tint k=F[u].size();\n\t\t\tpolygon H(k);\n\t\t\trep(i,k) H[i]=P[F[u][i]];\n\t\t\tif(!is_ccw(H)){\n// if(u0!=-1) for(;;);\n\t\t\t\tassert(u0==-1);\n\t\t\t\tu0=u;\n\t\t\t}\n\t\t}\nif(u0==-1) for(;;);\n\t\tassert(u0!=-1);\n\n\t\t// build the dual graph\n\t\tvector<int> G2[100];\n\t\trep(u,n2) rep(v,u) {\n\t\t\tbool ok=false;\n\t\t\tint nu=F[u].size(),nv=F[v].size();\n\t\t\trep(i,nu) rep(j,nv) if(F[u][i]==F[v][(j+1)%nv] && F[u][(i+1)%nu]==F[v][j]) ok=true;\n\t\t\tif(ok){\n\t\t\t\tG2[u].push_back(v);\n\t\t\t\tG2[v].push_back(u);\n\t\t\t}\n\t\t}\n\n\t\t// BFS\n\t\tint d[100];\n\t\trep(u,n2) d[u]=(u==u0?0:-1);\n\t\tqueue<int> Q;\n\t\tQ.push(u0);\n\t\twhile(!Q.empty()){\n\t\t\tint u=Q.front(); Q.pop();\n\t\t\trep(i,G2[u].size()){\n\t\t\t\tint v=G2[u][i];\n\t\t\t\tif(d[v]==-1) d[v]=d[u]+1, Q.push(v);\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",*max_element(d,d+n2));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n==0) ? 1 : 10*TEN(n-1); }\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\ntemplate<class T> ostream& operator<<(ostream& os, const V<T> &v) {\n    cout << \"[\";\n    for (auto p: v) cout << p << \", \";\n    cout << \"]\";\n    return os;\n}\n\ntemplate<class T>\nstruct Pt2 {\n    T x, y;\n    Pt2() {}\n    Pt2(T _x, T _y) : x(_x), y(_y) {}\n    Pt2 operator+(const Pt2 &r) const { return Pt2(x+r.x, y+r.y); }\n    Pt2 operator-(const Pt2 &r) const { return Pt2(x-r.x, y-r.y); }\n\n    Pt2 operator-() const { return Pt2(-x, -y); }\n\n    T abs() const { return sqrt(x*x + y*y); }\n    T rabs() const { return max(x, y); } // robust abs\n    T arg() const { return atan2(y, x); }\n};\ntemplate<class T> ostream& operator<<(ostream& os, const Pt2<T> &p) {\n    os << \"(\" << p.x << \", \" << p.y << \")\";\n    return os;\n}\n\nusing D = double;\nusing P = Pt2<D>;\n\nconst D PI = acos(D(-1)), EPS = 1e-10;\n\nint sgn(D a) {\n    if (abs(a) <= EPS) return 0;\n    return (a < 0) ? -1 : 1;\n}\n//relative sign\nint rsgn(D a, D f) {\n    if (abs(a) <= f*EPS) return 0;\n    return (a < 0) ? -1 : 1;\n}\nbool near(P a, P b) { return !sgn((a-b).abs()); }\n\nbool lessP(P l, P r) {\n    if (sgn(r.x-l.x)) return l.x < r.x;\n    if (sgn(r.y-l.y)) return l.y < r.y;\n    return false;\n}\n\nD cross(P a, P b) { return a.x*b.y - a.y*b.x; }\nD dot(P a, P b) { return a.x*b.x + a.y*b.y; }\n\n// -2, -1, 0, 1, 2 : front, clock, on, cclock, back\nint ccw(P b, P c) {\n    int s = rsgn(cross(b, c), b.rabs());\n    if (s) return s;\n    if (!sgn(c.rabs()) || !sgn((c-b).rabs())) return 0;\n    if (dot(b, c) < 0) return 2;\n    if (dot(-b, c-b) < 0) return -2;\n    return 0;\n}\nint ccw(P a, P b, P c) { return ccw(b-a, c-a); }\n\nstruct L {\n    P s, t;\n    L() {}\n    L(P s, P t) : s(s), t(t) {}\n    P vec() const { return t-s; }\n    D abs() const { return vec().abs(); }\n    D arg() const { return vec().arg(); }\n};\nint ccw(L l, P p) { return ccw(l.s, l.t, p); }\n\nusing Pol = V<P>;\n\n//cycle at\nconst P& c_at(const Pol &pol, int i) {\n    int n = int(pol.size());\n    assert(0 <= i && i < 2*n);\n    return pol[(i < n) ? i : i-n];\n}\n\nD area2_noabs(const Pol &p) {\n    D u = 0;\n    for (size_t i = 0; i < p.size(); i++) {\n        u += cross(p[i], c_at(p, i+1));\n    }\n    return u;\n}\n\n// -1: cw, 0: line, 1: ccw\nint is_ccw(const Pol &p) {\n    return sgn(area2_noabs(p));\n}\n\n// 0: outside, 1: on line, 2: inside\nint contains(const Pol &pol, P p) {\n    int in = -1;\n    for (int i = 0; i < int(pol.size()); i++) {\n        P a = pol[i], b = c_at(pol, i+1);\n        if (ccw(a, b, p) == 0) return 1;\n        if (a.y > b.y) swap(a, b);\n        if (a.y <= p.y && p.y < b.y && cross(a-p, b-p) < 0) in *= -1;\n    }\n    return in+1;\n}\n\n\n/*\n 双対グラフを作成\n pol, rgの要素は2*n-4個確保しておくこと\n gはめちゃくちゃに破壊される\n もし連結でないグラフ、しかも内包があるグラフに行うとrgは0が複数混入する\n 0は、その連結成分だけに注目したときの外側の意味。本当に外側か判定したいなら\n contains等を使用すること\n */\nstruct DualGraph {\n    V<Pol> pols;\n    VV<int> g;\n};\nDualGraph dualGraph(V<P> ps, VV<int> g) {\n    assert(ps.size() == g.size());\n    int n = int(ps.size());\n    using Pi = pair<int, int>;\n    map<Pi, int> mp;\n    for (int i = 0; i < n; i++) {\n        sort(g[i].begin(), g[i].end());\n        assert(unique(g[i].begin(), g[i].end()) == g[i].end());\n        sort(g[i].begin(), g[i].end(), [&](int l, int r){\n            return (ps[l]-ps[i]).arg() > (ps[r]-ps[i]).arg();\n        });\n        for (int j = 0; j < int(g[i].size()); j++) {\n            mp[Pi(i, g[i][j])] = j;\n        }\n    }\n\n    VV<int> vis(n), rev(n);\n    for (int i = 0; i < n; i++) {\n        vis[i] = V<int>(g[i].size(), -3);\n        for (int d: g[i]) {\n            rev[i].push_back(mp[Pi(d, i)]);\n        }\n    }\n\n    V<Pol> pols;\n    int idc = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < int(g[i].size()); j++) {\n            if (vis[i][j] != -3) continue;\n            Pol pol;\n            int p = i, idx = j;\n            while (vis[p][idx] != -2) {\n                pol.push_back(ps[p]);\n                vis[p][idx] = -2;\n                int np = g[p][idx];\n                int nidx = rev[p][idx]+1;\n                if (nidx == int(g[np].size())) nidx = 0;\n\n                p = np; idx = nidx;\n            }\n            int id = -1;\n            if (is_ccw(pol) == 1) {\n                id = idc;\n                pols.push_back(pol);\n                idc++;\n            }\n//            cout << \"FIND \" << id << \" \" << is_ccw(pol) << \" \" << pol << endl;\n            while (vis[p][idx] == -2) {\n                vis[p][idx] = id;\n                int np = g[p][idx];\n                int nidx = rev[p][idx]+1;\n                if (nidx == int(g[np].size())) nidx = 0;\n\n                p = np; idx = nidx;\n            }\n        }\n    }\n\n    VV<int> g2(idc+1);\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < int(g[i].size()); j++) {\n            int x = vis[i][j], y = vis[g[i][j]][rev[i][j]];\n            if (x == -1) x = idc;\n            if (y == -1) y = idc;\n            g2[x].push_back(y);\n        }\n    }\n\n    for (int i = 0; i <= idc; i++) {\n        sort(g2[i].begin(), g2[i].end());\n        g2.erase(unique(begin(g2), end(g2)), end(g2));\n    }\n\n    return DualGraph{pols, g2};\n}\n\nbool solve() {\n    int c, w;\n    cin >> c >> w;\n    if (!c) return false;\n    \n    V<P> p(c);\n    for (int i = 0; i < c; i++) {\n        D x, y;\n        cin >> x >> y;\n        p[i] = P(x, y);\n    }\n    \n    VV<int> g(c);\n    for (int i = 0; i < w; i++) {\n        int s, t;\n        cin >> s >> t; s--; t--;\n        g[s].push_back(t);\n        g[t].push_back(s);\n    }\n    \n    auto dg = dualGraph(p, g);\n    int n = int(dg.g.size());\n\n/*    cout << \"DEBUG: \" << endl;\n    cout << n << endl;\n    for (int i = 0; i < n-1; i++) {\n        for (P p: dg.pols[i]) {\n            cout << p << \", \";\n        } cout << endl;\n    }*/\n    V<int> dist(n, TEN(9));\n\n    queue<int> q;\n    dist[n-1] = 0;\n    q.push(n-1);\n    while (q.size()) {\n        int p = q.front(); q.pop();\n        for (int d: dg.g[p]) {\n            if (dist[d] <= dist[p] + 1) continue;\n            dist[d] = dist[p] + 1;\n            q.push(d);\n        }\n    }\n    int ma = -1;\n    for (int i = 0; i < n; i++) ma = max(ma, dist[i]);\n    cout << ma << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << setprecision(20);\n\n    while (solve()) {}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<utility>\n#include<map>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n\nusing namespace std;\n\nstruct Point{\n\tint x,y;\n\tint id;\n\tPoint(){}\n\tPoint(int a,int b,int c):x(a),y(b),id(c){}\n};\n\nPoint points[110];\nint pid[110];\n\nbool cmp(const Point &p1,const Point &p2)\n{\n\tif(p1.x!=p2.x) return p1.x<p2.x;\n\treturn p1.y<p2.y;\n}\n\nint center;\n\nbool cmp_angle(const int &id1,const int &id2)\n{\n\tint center=pid[::center];\n\tint id1_=pid[id1],id2_=pid[id2];\n\tint dx1=points[id1_].x-points[center].x;\n\tint dy1=points[id1_].y-points[center].y;\n\tint dx2=points[id2_].x-points[center].x;\n\tint dy2=points[id2_].y-points[center].y;\n\t//(-y,x)\n\tdouble ang1=atan2(dx1,-dy1);\n\tdouble ang2=atan2(dx2,-dy2);\n\treturn ang1<ang2;\n}\n/*\nstruct cmp_angle_{\n\tbool operator()(const int &id1,const int &id2)\n\t{\n\tint center=pid[::center];\n\tint id1_=pid[id1],id2_=pid[id2];\n\tint dx1=points[id1_].x-points[center].x;\n\tint dy1=points[id1_].y-points[center].y;\n\tint dx2=points[id2_].x-points[center].x;\n\tint dy2=points[id2_].y-points[center].y;\n\t//(-y,x)\n\tdouble ang1=atan2(dx1,-dy1);\n\tdouble ang2=atan2(dx2,-dy2);\n\treturn ang1<ang2;\n\t}\n};*/\n\nvector<int> G[110];\n\nvector<vector<int> > vs;\nvector<int> dG[550];\n//bool con[550][550];\n\ntypedef pair<int,int> P;\n\nmap<P,int> cnt;\nqueue<P> que;\n\nvoid init()\n{\n\tvs.clear();\n\tfor(int i=0;i<110;i++) G[i].clear();\n\tfor(int i=0;i<550;i++) dG[i].clear();\n\tcnt.clear();\n}\n\nvector<int> res;\nvoid stroke(int u,int v,int st)\n{\n\t//u->v\n\tP p=P(min(u,v),max(u,v));\n\tif(cnt[p]==0)\n\t{\n\t\tque.push(P(v,u));\n\t}\n\tcnt[p]++;\n\tif(v==st) return;\n\tif(u==st) res.push_back(u);\n\tres.push_back(v);\n//\tprintf(\"x%dx\\n\",v);\n\tcenter=v;\n\tint id=distance(G[v].begin(),lower_bound(G[v].begin(),G[v].end(),u,cmp_angle));\n//\tprintf(\"%d::%d %d\\n\",v,G[v].size(),id);\n\tif(G[v][id]!=u) for(;;);\n\tif(id==G[v].size()-1) id=0;\n\telse id++;\n\tint nxt=G[v][id];\n\tstroke(v,nxt,st);\n}\n\nvoid getGraph()\n{\n\tint V=vs.size();\n\tfor(int i=0;i<V;i++) for(int j=i+1;j<V;j++)\n\t{\n\t\tint ni=vs[i].size(),nj=vs[j].size();\n\t\tbool flg=false;\n\t\tfor(int iid=0;iid<ni;iid++) for(int jid=0;jid<nj;jid++)\n\t\t{\n\t\t\tint niid=iid==ni-1?0:iid+1;\n\t\t\tint njid=jid==nj-1?0:jid+1;\n\t\t\tif(vs[i][iid]==vs[j][njid]&&vs[i][niid]==vs[j][jid]) flg=true;\n\t\t}\n\t\tif(flg)\n\t\t{\n\t\t\tdG[i].push_back(j);\n\t\t\tdG[j].push_back(i);\n\t\t}\n\t//\tcon[i][j]=flg;\n\t//\tcon[j][i]=flg;\n\t}\n}\n\nint getMostOutSide()\n{\n\tint u=points[0].id;\n\tint v=G[u][0];\n//\tprintf(\"----------------%d %d\\n\",u,v);\n//\tprintf(\"%d %d %d %d\\n\",points[u].x,points[u].y,points[v].x,points[v].y);\n\tfor(int i=0;i<vs.size();i++)\n\t{\n\t\tfor(int j=0;j+1<vs[i].size();j++)\n\t\t{\n\t\t\tif(vs[i][j]==u&&vs[i][j+1]==v) return i;\n\t\t}\n\t\tif(vs[i][vs[i].size()-1]==u&&vs[i][0]==v) return i;\n\t}\n//\tfor(;;);\n\treturn -1;\n}\n\nvoid check(int a)\n{\n\tif(cnt.size()<a) for(;;);\n/*\tmap<P,int>::iterator it=cnt.begin();\n\tfor(;it!=cnt.end();it++)\n\t{\n\t\tint b=it->second;\n\t\tif(b!=2) for(;;);\n\t}*/\n}\n\nint dis[550];\nqueue<int> bfs_que;\nvoid bfs(int s)\n{\n//\tprintf(\"xxxxxxxxxxxxxxxxxxxxx\\n\");\n\twhile(!bfs_que.empty()) bfs_que.pop();\n\tbfs_que.push(s);\n\tfor(int i=0;i<550;i++) dis[i]=1<<29;\n\tdis[s]=0;\n\tbfs_que.push(s);\n\twhile(!bfs_que.empty())\n\t{\n\t\tint v=bfs_que.front();\n//\t\tprintf(\"bfs %d\\n\",v);\n\t\tbfs_que.pop();\n\t\tfor(int i=0;i<dG[v].size();i++)\n\t\t{\n\t\t\tint u=dG[v][i];\n\t\t\tint nd=dis[v]+1;\n\t\t\tif(nd>=dis[u]) continue;\n\t\t\tdis[u]=nd;\n\t\t\tbfs_que.push(u);\n\t\t}\n\t}\n}\n\nvoid outputdG()\n{\n\tprintf(\"-----dual\\n\");\n\tfor(int i=0;i<vs.size();i++)\n\t{\n\t\tprintf(\"%d-\",i);\n\t\tfor(int j=0;j<dG[i].size();j++)\n\t\t{\n\t\t\tprintf(\"%d \",dG[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}\n\nint main()\n{\n\twhile(true)\n\t{\n\t\tint C,W;\n\t\tscanf(\"%d%d\",&C,&W);\n\t\tif(C==0) break;\n\t\tinit();\n\t\tfor(int i=0;i<C;i++)\n\t\t{\n\t\t\tint x,y;\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\tpoints[i]=Point(x,y,i);\n\t\t}\n\t\tsort(points,points+C,cmp);\n\t\tfor(int i=0;i<C;i++) pid[points[i].id]=i;\n\t\tint su=-1,sv=-1;\n\t\tfor(int i=0;i<W;i++)\n\t\t{\n\t\t\tint u,v;\n\t\t\tscanf(\"%d%d\",&u,&v);\n\t\t\tu--;v--;\n\t\t\tG[u].push_back(v);\n\t\t\tG[v].push_back(u);\n\t\t\tsu=u,sv=v;\n\t\t}\n\t\tfor(int i=0;i<C;i++)\n\t\t{\n\t\t\tcenter=i;\n\t\t\tsort(G[i].begin(),G[i].end(),cmp_angle);\n//\t\t\tprintf(\"%d:::\",i);\n//\t\t\tfor(int j=0;j<G[i].size();j++) printf(\"%d \",G[i][j]);\n//\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tque.push(P(min(su,sv),max(su,sv)));\n\t\twhile(!que.empty())\n\t\t{\n\t\t\tP p=que.front();\n\t\t\tque.pop();\n\t\t\tint u=p.first,v=p.second;\n//\t\t\tprintf(\"pop %d %d\\n\",u,v);\n\t\t\tP pp=P(min(u,v),max(u,v));\n\t\t\tif(cnt[pp]==2) continue;\n\t\t//\tbool flg;\n\t\t//\tif(cnt[pp]==1) flg=false;\n\t\t//\telse flg=true;\n\t\t\tres.clear();\n\t\t\tstroke(u,v,u);\n\t\t\tvs.push_back(res);\n//\t\t\tfor(int i=0;i<res.size();i++) printf(\"%d \",res[i]);\n//\t\t\tprintf(\"aaa\\n\");\n\t\t//\tcnt[pp]++;\n\t\t//\tif(flg) que.push(P(v,u));\n\t\t}\n\t\tif(vs.size()>500) for(;;);\n//\t\tfor(int i=0;i<vs.size();i++)\n//\t\t{\n//\t\t\tvector<int> vec=vs[i];\n//\t\t\tprintf(\"a:\");\n//\t\t\tfor(int j=0;j<vec.size();j++) printf(\"%d \",vec[j]);\n//\t\t\tprintf(\"\\n\");\n//\t\t}\n\t\tgetGraph();\n\t//\tcheck(W);\n\t\tint out=getMostOutSide();\n\t\tbfs(out);\n\t\tint ans=0;\n\t\tfor(int i=0;i<vs.size();i++) ans=max(ans,dis[i]);\n//\t\toutputdG();\n//\t\tprintf(\"---------%d--------------ans=%d\\n\",out,ans);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<int,int> state;\n\nint N,M;\nP t[100];\nint f[100][100];\nint d[100][100];\n\nbool check(int from,int to){\n  P base=t[to]-t[from];\n  for(int i=0;i<N;i++){\n    P target=t[i]-t[from];\n    if(imag(target*conj(base))<0)\n      return false;\n  }\n  return true;\n}\n\nvoid init(){\n  memset(f,0,sizeof(f));\n  memset(d,1,sizeof(d));\n}\n\nint solve(){\n  int si=0,ti;\n  double mini=1e9;\n  for(int i=0;i<N;i++)\n    if(t[i].real()<t[si].real())si=i;\n  \n  for(int i=0;i<N;i++)\n    if(f[si][i] && arg(t[i]-t[si])< mini)\n      ti=i,mini=arg(t[i]-t[si]);\n\n  deque<state> Q;  \n  Q.push_back(state(si,ti));\n  d[si][ti]=0;\n\n  for(int i=0;i<N;i++){\n    for(int j=0;j<N;j++){\n      if(f[i][j]&&check(i,j)){\n        d[i][j]=0;\n        Q.push_front(state(i,j));\n      }\n    }\n  }\n   \n  int ans=0;\n  while(!Q.empty()){\n    state p=Q.front();\n    Q.pop_front();\n    int from=p.first;\n    int to=p.second;\n    ans=d[from][to];\n    \n    if(d[from][to]+1<d[to][from]){\n      d[to][from]=d[from][to]+1;\n      Q.push_back(state(to,from));\n    }\n    int id=-1;\n    double mini=1e9;\n    for(int i=0;i<N;i++){\n      if(f[to][i]&&i!=from){\n        if( arg( (t[i]-t[to])*conj(t[to]-t[from]) ) < mini){\n          id=i;\n          mini=arg( (t[i]-t[to])*conj(t[to]-t[from]) );\n        }\n      }\n    }\n    if(id!=-1&&d[to][id]>d[from][to]){\n      d[to][id]=d[from][to];\n      Q.push_front(state(to,id));\n    }\n  }\n  return ans;\n}\n\nint main(){\n  while(1){\n    cin>>N>>M;\n    if(N==0&&M==0)break;\n    init();\n    for(int i=0;i<N;i++){\n      int x,y;\n      cin>>x>>y;\n      t[i]=P(x,y);\n    }\n    for(int i=0;i<M;i++){\n      int x,y;\n      cin>>x>>y;\n      x--,y--;\n      f[x][y]=f[y][x]=true;\n    }\n    cout<<solve()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX_C 101\n#define MAX_W 301\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:y<p.y; }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const { return p.p1 == p1 && p.p2 == p2; }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a){ os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\nstruct Edge{\n  int from,to,rev,unique_index;\n  Edge(int from=IINF,int to=IINF):from(from),to(to){}\n};\n\nconst bool DEBUG = false;\nint C,W,sp;\nPoint ps[MAX_C];\nvector<Edge> G[MAX_C];\nvector<vector<int> > poly;\nbool used[MAX_C][MAX_C];\nint depth[MAX_C];\nint index_list[MAX_C][MAX_C];\nvector<int> bfs_G[MAX_C];\n\nbool cmp(const Edge& a,const Edge& b){\n  Vector vec_a = ps[a.to] - ps[a.from];\n  Vector vec_b = ps[b.to] - ps[b.from];\n  return atan2(vec_a.y,vec_a.x) <= atan2(vec_b.y,vec_b.x);\n}\n\nbool getPath(int start_node,int node,int edge,vector<int>& edge_list){\n  if(DEBUG)cout << __LINE__ << \": \" <<  node << \",\" << edge << endl;\n  if( used[node][edge] ){\n    if( !edge_list.empty() && node == start_node ) return true;\n    return false;\n  }\n  used[node][edge] = true;\n\n  int next_node = G[node][edge].to;\n  int next_edge = (G[node][edge].rev+1)%((int)G[next_node].size());\n  edge_list.push_back(G[node][edge].unique_index);\n  if(getPath(start_node,next_node,next_edge,edge_list)){\n    if(DEBUG)cout << __LINE__ << \": path::\"  << node << \",\" << edge << endl;\n    return true;\n  } else {\n    return used[node][edge] = false;\n  }\n}\n  \nint main(){\n  while(cin>>C>>W,C|W){\n    rep(i,MAX_C)depth[i] = IINF,bfs_G[i].clear(),G[i].clear();\n    rep(i,MAX_C)rep(j,MAX_C)used[i][j] = false, index_list[i][j] = IINF;\n    depth[0] = 0;\n    poly.clear();\n    sp = 0;\n    rep(i,C) {\n      cin >> ps[i].x >> ps[i].y;\n      //ps[i].x += 1000, ps[i].y += 1000;\n      if( ps[i] < ps[sp] ) sp = i;\n    }\n    rep(i,W) {\n      int s,t;\n      cin >> s >> t;\n      s--,t--;\n      G[s].push_back(Edge(s,t));\n      G[t].push_back(Edge(t,s));\n    }\n    rep(i,C)sort(G[i].begin(),G[i].end(),cmp);\n    int dex = 0;\n    rep(i,C){\n      rep(j,(int)G[i].size()){\n\tint to = G[i][j].to;\n\trep(k,(int)G[to].size()){\n\t  if(G[to][k].to == i){\n\t    G[i][j].rev = k;\n\t    if( index_list[i][j] == IINF ){\n\t      assert(index_list[to][k] == IINF);\n\t      index_list[i][j] = index_list[to][k] = dex++;\n\t    }\n\t    G[i][j].unique_index = index_list[i][j];\n\t    break;\n\t  }\n\t}\n      }\n    }\n    if(DEBUG){\n      cout << __LINE__ << \":\" << endl;\n      cout << \"sp = \" << sp << endl;\n      rep(i,C){\n\tcout << \"i = \" << i << endl;\n\trep(j,G[i].size()){\n\t  cout << \"from = \" << G[i][j].from << \" to = \" << G[i][j].to << \" rev = \" << G[i][j].rev << \" unique = \" << G[i][j].unique_index << endl;\n\t}\n      }\n      cout << endl << endl;\n      rep(i,(int)G[sp].size()){\n\tif( used[sp][i] ) continue;\n\tvector<int> tmp;\n\tif( getPath(sp,sp,i,tmp) ) {\n\t  poly.push_back(tmp);\n\t  cout << \"[\" << sp << \"][\" << i << \"] : getPath!! : \" << endl;\n\t}\n      }\n    }\n    rep(i,C){\n      if( i == sp ) continue;\n      rep(j,G[i].size()){\n\tif( used[i][j] ) continue;\n\tvector<int> tmp;\n\tif( getPath(i,i,j,tmp) ){\n\t  poly.push_back(tmp);\n\t}\n      }\n    }\n\n    rep(i,poly.size()){\n      REP(j,i+1,poly.size()){\n\tbool connect = false;\n\trep(k,poly[i].size()){\n\t  rep(l,poly[j].size()){\n\t    if(poly[i][k] == poly[j][l]){\n\t      connect = true;\n\t      goto Skip;\n\t    }\n\t  }\n\t}\n      Skip:;\n\tif(connect){\n\t  bfs_G[i].push_back(j);\n\t  bfs_G[j].push_back(i);\n\t}\n      }\n    }\n\n    if(DEBUG){\n      cout << __LINE__ << \":\" << endl;\n      cout << \"poly.size() = \" << poly.size() << endl;\n      rep(i,(int)poly.size()){\n\tcout << \"poly[\" << i << \"]\" << endl;\n\trep(j,poly[i].size()){\n\t  cout << poly[i][j] << \" \";\n\t}\n\tcout << endl;\n      }\n\n      cout << \"bfs_G = \" << endl;\n      rep(i,poly.size()){\n\tcout << \"[\" << i << \"]\" << endl;\n\trep(j,bfs_G[i].size()){\n\t  cout << bfs_G[i][j] << \" \";\n\t}\n\tcout << endl;\n      }\n\n      cout << \"depth[\" << 0 << \"] = \" << depth[0] << endl;\n    }\n    int answer = 0;\n    deque<int> deq;\n    deq.push_back(0);\n    while(!deq.empty()){\n      int cur = deq.front(); deq.pop_front();\n      rep(i,bfs_G[cur].size()){\n\tint next = bfs_G[cur][i];\n\tif( depth[next] == IINF ){\n\t  depth[next] = depth[cur] + 1;\n\t  answer = max(answer,depth[next]);\n\t  deq.push_back(next);\n\t}\n      }\n    }\n    cout << answer << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<complex>\n#include<deque>\n#include<vector>\nusing namespace std;\ndouble eps=1e-7;\ndouble x[110];\ndouble y[110];\ndouble px[700];\ndouble py[700];\nint ijk[700];\nint v[700];\nint g[700][700];\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ndouble PI=3.14159265358;\ntypedef complex<double> P;\ntypedef vector<P> G;\n\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nP pt[700];\nP ps[300];\nint s[400];\nint t[400];\ndouble left[400];\ndouble right[400];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<a;i++)scanf(\"%lf%lf\",x+i,y+i);\n\t\tfor(int i=0;i<a;i++){\n\t\t\tdouble X=cos(1)*x[i]-sin(1)*y[i];\n\t\t\tdouble Y=sin(1)*x[i]+cos(1)*y[i];\n\t\t\tx[i]=X;\n\t\t\ty[i]=Y;\n\t\t\tps[i]=P(x[i],y[i]);\n\t\t}\n\t\tfor(int i=0;i<b;i++){\n\t\t\tint p,q;scanf(\"%d%d\",&p,&q);\n\t\t\tp--;q--;\n\t\t\ts[i]=p;t[i]=q;\n\t\t\tpx[i*2]=(x[p]+x[q])/2+eps;\n\t\t\tpy[i*2]=(y[p]+y[q])/2;\n\t\t\tpx[i*2+1]=(x[p]+x[q])/2-eps;\n\t\t\tpy[i*2+1]=(y[p]+y[q])/2;\n\t\t\tpt[i*2]=P(px[i*2],py[i*2]);\n\t\t\tpt[i*2+1]=P(px[i*2+1],py[i*2+1]);\n\t\t}\n\t\t\tdeque<pair<int,int> >Q;\n\t\t\n\t\tfor(int i=0;i<b*2;i++){\n\t\t\tijk[i]=999999999;\n\t\t\tv[i]=0;\n\t\t\tbool OK=true;\n\t\t\tint tt=s[i/2];\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tif(tt==s[j]||tt==t[j])continue;\n\t\t\t\tif(intersectSS(L(ps[tt],ps[tt]+(pt[i]-ps[tt])*10000.0),L(ps[s[j]],ps[t[j]]))){\n\t\t\t\t\tOK=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(OK){\n\t\t//\t\tprintf(\" %d\\n\",i);\n\t\t\t\tijk[i]=0;\n\t\t\t\tQ.push_back(make_pair(0,i));\n\t\t\t}\n\t\t\tfor(int j=i+1;j<b*2;j++){\n\t\t\t\tint cnt=0;\n\t\t\t\tfor(int k=0;k<b;k++){\n\t\t\t\t\tif(intersectSS(L(ps[s[k]],ps[t[k]]),L(pt[i],pt[j]))){\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tif(cnt>1)break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(cnt<2)g[i][j]=g[j][i]=cnt;\n\t\t\t\telse g[i][j]=g[j][i]=999999999;\n\t\t\t}\n\t\t}\n\t\n\t\twhile(Q.size()){\n\t\t\tint cost=-Q.front().first;\n\t\t\tint at=Q.front().second;Q.pop_front();\n\t\t\tif(v[at])continue;\n\t\t\tv[at]=1;\n\t\t\tfor(int i=0;i<b*2;i++){\n\t\t\t\tif(!v[i]&&ijk[i]>cost+g[at][i]){\n\t\t\t\t\tijk[i]=cost+g[at][i];\n\t\t\t\t\tif(g[at][i]==1)Q.push_back(make_pair(-ijk[i],i));\n\t\t\t\t\telse Q.push_front(make_pair(-ijk[i],i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret=0;\n\t\tfor(int i=0;i<b*2;i++)ret=max(ret,ijk[i]);\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<int,pair<bool,double> > P2;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define min_3(a,b,c) min(a,min(b,c))\n#define max_3(a,b,c) max(a,max(b,c))\n#define mp1(a,b,c) P1(a,P(b,c))\n#define mp2(a,b,c) P2(a,pair<bool,double>(b,c))\n#define pque(a) priority_queue<a>\n#define rpque(a) priority_queue<a,vector<a>,greater<a>>\n\nconst int INF=1000000000;\nconst int dre_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dre_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\nconst int kaijou[10]={1,1,2,6,24,120,720,5040,40320,362880};\n\nbool com(P2 x,P2 y){\n\tif(x.sc.fr!=y.sc.fr)return x.sc.fr;\n\treturn x.sc.sc>=y.sc.sc;\n}\n\nint main(){\n\tint ppp=0;\n\twhile(1){\n\t\t//ppp++; if(ppp>=6)while(1){}\n\t\tstatic int v,w;\n\t\tstatic int x[310],y[310];\n\t\tstatic int s,t;\n\t\t\n\t\tscanf(\"%d%d\",&v,&w); if(v==0&&w==0)break;\n\t\trep1(i,v)scanf(\"%d%d\",&x[i],&y[i]);\n\t\t\n\t\tstatic vector<P1> V_; V_.clear();\n\t\trep1(i,v){\n\t\t\tV_.pb(mp1(x[i],y[i],i));\n\t\t}\n\t\tsor(V_);\n\t\tstatic vector<P2> vec_[310];\n\t\trep1(i,v){\n\t\t\tvec_[i].clear();\n\t\t\tvec_[i].pb(mp2(0,false,-INF));\n\t\t\trep1(j,v){\n\t\t\t\tif(i==j)continue;\n\t\t\t\tif(x[i]<x[j]){\n\t\t\t\t\tvec_[i].pb(mp2(j,true,(double)(y[j]-y[i])/(x[j]-x[i])));\n\t\t\t\t}\n\t\t\t\telse if(x[i]>x[j]){\n\t\t\t\t\tvec_[i].pb(mp2(j,false,(double)(y[j]-y[i])/(x[j]-x[i])));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(y[j]>y[i])vec_[i].pb(mp2(j,true,(double)INF));\n\t\t\t\t\telse vec_[i].pb(mp2(j,true,(double)-INF));\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(vec_[i].begin(),vec_[i].end(),com);\n\t\t}\n\t\t\n\t\tstatic int e;\n\t\tstatic vector<int> V; V.clear();\n\t\tstatic bool edge[310][310];\n\t\tstatic vector<int> vec[310]; \n\t\t\n\t\te=w;\n\t\trep(i,v)V.pb(V_[i].sc.sc);\n\t\trep(i,305)rep(j,305)edge[i][j]=false;\n\t\trep(i,e){\n\t\t\tscanf(\"%d%d\",&s,&t);\n\t\t\tedge[s][t]=true;\n\t\t\tedge[t][s]=true;\n\t\t}\n\t\trep1(i,v){\n\t\t\tvec[i].clear();\n\t\t\trep(j,vec_[i].size()){\n\t\t\t\tvec[i].pb(vec_[i][j].fr);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ret=0;\n\t\twhile(e>0){\n\t\t\tret++;\n\t\t\t\n\t\t\tint a=-1;\n\t\t\trep(i,V.size()){\n\t\t\t\trep(j,105){\n\t\t\t\t\tif(edge[V[i]][j]){a=V[i]; break;}\n\t\t\t\t}\n\t\t\t\tif(a!=-1)break;\n\t\t\t}\n\t\t\t\n\t\t\tint b=0,c=a;\n\t\t\twhile(1){\n\t\t\t\tif(c==-1||vec[c].size()==0)break;\n\t\t\t\trep(i,vec[c].size()){\n\t\t\t\t\tif(vec[c][i]==b){\n\t\t\t\t\t\ti++; i%=vec[c].size();\n\t\t\t\t\t\twhile(!edge[c][vec[c][i]]){\n\t\t\t\t\t\t\ti++; i%=vec[c].size();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tedge[c][vec[c][i]]=false;\n\t\t\t\t\t\tedge[vec[c][i]][c]=false;\n\t\t\t\t\t\te--;\n\t\t\t\t\t\tb=c;\n\t\t\t\t\t\tc=vec[c][i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(c==a)break;\n\t\t\t}\n\t\t\t\n\t\t\tbool updata=true;\n\t\t\twhile(updata){\n\t\t\t\tupdata=false;\n\t\t\t\trep1(i,v){\n\t\t\t\t\tint cnt=0;\n\t\t\t\t\tint t=105;\n\t\t\t\t\trep1(j,v){\n\t\t\t\t\t\tif(edge[i][j]){cnt++; t=j;}\n\t\t\t\t\t}\n\t\t\t\t\tif(cnt==1){\n\t\t\t\t\t\tupdata=true;\n\t\t\t\t\t\tedge[i][t]=false;\n\t\t\t\t\t\tedge[t][i]=false;\n\t\t\t\t\t\te--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\",ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <ctime>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <fstream>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <numeric>\n#include <cassert>\nusing namespace std;\n\ntypedef complex<double> P;\n\nint C,W;\n\nint wsc[300] , wtc[300];\nP c[100];\nstruct NODE{\n\tint from,to,id;\n\tNODE(int from,int to,int id) : from(from) , to(to) , id(id) {}\n\tNODE(){}\n};\nvector<NODE> geo[100];\n\nconst double PI = acos(-1);\nint start;\ndouble fx(double rd){\n\twhile( rd < -1e-9 )   rd += 2*PI;\n\twhile( rd >= 2*PI - 1e-9) rd -= 2*PI;\n\treturn rd;\n}\ndouble R(P a){\n\tdouble rd = atan2(a.imag(),a.real());\n\treturn fx(rd);\n}\nint get(int x,int prev,vector<int> &ad){\n\tif( x == start ) return 1;\n\t\n\tdouble r1 = R(c[x]-c[prev]);\n\tdouble bad = 0;\n\tint o = -1;\n\tint id;\n\tfor(int i = 0 ; i < geo[x].size() ; i++){\n\t\tif( geo[x][i].to == prev ) continue;\n\t\tdouble r2 = R(c[geo[x][i].to]-c[x]);\n\t\tdouble rr = fx(r2-r1);\n\t\tif( -1e-9 <= rr && rr <= PI + 1e-9 ){\n\t\t\tif( rr > bad ){\n\t\t\t\to = geo[x][i].to;\n\t\t\t\tbad = rr;\n\t\t\t\tid = geo[x][i].id;\n\t\t\t}\n\t\t}\n\t}\n\tif( o == -1 ) return 0;\n\t\n\tif( get(o,x,ad) ){\n\t\tad.push_back(id);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nint main(){\n\twhile(cin >> C >> W && C){\n\t\tfor(int i = 0 ; i < 100 ; i++) geo[i].clear();\n\t\tfor(int i = 0 ; i < C ; i++)\n\t\t\tcin >> c[i].real() >> c[i].imag();\n\t\tfor(int i = 0 ; i < W ; i++){\n\t\t\tint s,t;\n\t\t\tcin >> s >> t;\n\t\t\ts--,t--;\n\t\t\tgeo[s].push_back(NODE(s,t,i));\n\t\t\tgeo[t].push_back(NODE(t,s,i));\n\t\t\twsc[i] = s;\n\t\t\twtc[i] = t;\n\t\t\t\n\t\t}\n\t\t\n\t\tvector< vector<int> > wallset;\n\t\tfor(int _ = 0 ; _ < 2 ; _++){\n\t\t\tfor(int i = 0 ; i < W ; i++){\n\t\t\t\tstart = wsc[i];\n\t\t\t\tvector<int> a;\n\t\t\t\tif( get(wtc[i],wsc[i],a) ){\n\t\t\t\t\ta.push_back(i);\n\t\t\t\t\tsort(a.begin(),a.end());\n\t\t\t\t\twallset.push_back(a);\n\t\t\t\t}\n\t\t\t\tswap(wsc[i],wtc[i]);\n\t\t\t}\n\t\t}\n\t\tsort(wallset.begin(),wallset.end());\n\t\twallset.erase(unique(wallset.begin(),wallset.end()),wallset.end());\n\t\t\n\t\tint wf[101][101]={};\n\t\tfor(int i = 0 ; i < 101 ; i++)\n\t\t\tfor(int j = 0 ; j < 101 ; j++)\n\t\t\t\twf[i][j] = i==j?0:1e9;\n\t\tint N = wallset.size();\n\t\tvector<int> wall_share[300];\n\t\t\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\tfor(int j = 0 ; j < wallset[i].size() ; j++){\n\t\t\t\twall_share[wallset[i][j]].push_back(i);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0 ; i < W ; i++){\n\t\t\tif( wall_share[i].size() == 1 ){\n\t\t\t\twf[wall_share[i][0]][100] = wf[100][wall_share[i][0]] = 1;\n\t\t\t}else if( wall_share[i].size() == 2 ){\n\t\t\t\tfor(int j = 0 ; j <wall_share[i].size() ; j++){\n\t\t\t\t\tfor(int k = 0 ; k < wall_share[i].size() ; k++){\n\t\t\t\t\t\tif(j!=k)wf[wall_share[i][j]][wall_share[i][k]] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0 ; i < 101 ; i++){\n\t\t\tfor(int j = 0 ; j < 101 ; j++){\n\t\t\t\tfor(int k = 0 ; k < 101 ; k++){\n\t\t\t\t\twf[j][k] = min(wf[j][k],wf[j][i]+wf[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\tans = max( ans , wf[i][100] );\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<utility>\n#include<map>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n\nusing namespace std;\n\nstruct Point{\n\tint x,y;\n\tint id;\n\tPoint(){}\n\tPoint(int a,int b,int c):x(a),y(b),id(c){}\n};\n\nPoint points[110];\nint pid[110];\n\nbool cmp(const Point &p1,const Point &p2)\n{\n\tif(p1.x!=p2.x) return p1.x<p2.x;\n\treturn p1.y<p2.y;\n}\n\nint center;\n\nbool cmp_angle(const int &id1,const int &id2)\n{\n\tint center=pid[::center];\n\tint id1_=pid[id1],id2_=pid[id2];\n\tint dx1=points[id1_].x-points[center].x;\n\tint dy1=points[id1_].y-points[center].y;\n\tint dx2=points[id2_].x-points[center].x;\n\tint dy2=points[id2_].y-points[center].y;\n\t//(-y,x)\n\tdouble ang1=atan2(dx1,-dy1);\n\tdouble ang2=atan2(dx2,-dy2);\n\treturn ang1<ang2;\n}\n/*\nstruct cmp_angle_{\n\tbool operator()(const int &id1,const int &id2)\n\t{\n\tint center=pid[::center];\n\tint id1_=pid[id1],id2_=pid[id2];\n\tint dx1=points[id1_].x-points[center].x;\n\tint dy1=points[id1_].y-points[center].y;\n\tint dx2=points[id2_].x-points[center].x;\n\tint dy2=points[id2_].y-points[center].y;\n\t//(-y,x)\n\tdouble ang1=atan2(dx1,-dy1);\n\tdouble ang2=atan2(dx2,-dy2);\n\treturn ang1<ang2;\n\t}\n};*/\n\nvector<int> G[110];\n\nvector<vector<int> > vs;\nvector<int> dG[550];\n//bool con[550][550];\n\ntypedef pair<int,int> P;\n\nmap<P,int> cnt;\nqueue<P> que;\n\nvoid init()\n{\n\tvs.clear();\n\tfor(int i=0;i<110;i++) G[i].clear();\n\tfor(int i=0;i<550;i++) dG[i].clear();\n\tcnt.clear();\n}\n\nvector<int> res;\nvoid stroke(int u,int v,int st)\n{\n\t//u->v\n\tP p=P(min(u,v),max(u,v));\n\tif(cnt[p]==0)\n\t{\n\t\tque.push(P(v,u));\n\t}\n\tcnt[p]++;\n\tif(v==st) return;\n\tif(u==st) res.push_back(u);\n\tres.push_back(v);\n//\tprintf(\"x%dx\\n\",v);\n\tcenter=v;\n\tint id=distance(G[v].begin(),lower_bound(G[v].begin(),G[v].end(),u,cmp_angle));\n//\tprintf(\"%d::%d %d\\n\",v,G[v].size(),id);\n\tif(id==G[v].size()-1) id=0;\n\telse id++;\n\tint nxt=G[v][id];\n\tstroke(v,nxt,st);\n}\n\nvoid getGraph(int W)\n{\n\tint n=0;\n\tint V=vs.size();\n\tfor(int i=0;i<V;i++) for(int j=i+1;j<V;j++)\n\t{\n\t\tint ni=vs[i].size(),nj=vs[j].size();\n\t\tbool flg=false;\n\t\tfor(int iid=0;iid<ni;iid++) for(int jid=0;jid<nj;jid++)\n\t\t{\n\t\t\tint niid=iid==ni-1?0:iid+1;\n\t\t\tint njid=jid==nj-1?0:jid+1;\n\t\t\tif(vs[i][iid]==vs[j][njid]&&vs[i][niid]==vs[j][jid])\n\t\t\t{\n\t\t\t\tflg=true;\n\t\t\t\tn++;\n\t\t\t}\n\t\t}\n\t\tif(flg)\n\t\t{\n\t\t\tdG[i].push_back(j);\n\t\t\tdG[j].push_back(i);\n\t\t}\n\t//\tcon[i][j]=flg;\n\t//\tcon[j][i]=flg;\n\t}\n\tif(n!=W) for(;;);\n}\n\nint getMostOutSide()\n{\n\tint u=points[0].id;\n\tint v=G[u][0];\n//\tprintf(\"----------------%d %d\\n\",u,v);\n//\tprintf(\"%d %d %d %d\\n\",points[u].x,points[u].y,points[v].x,points[v].y);\n\tfor(int i=0;i<vs.size();i++)\n\t{\n\t\tfor(int j=0;j+1<vs[i].size();j++)\n\t\t{\n\t\t\tif(vs[i][j]==u&&vs[i][j+1]==v) return i;\n\t\t}\n\t\tif(vs[i][vs[i].size()-1]==u&&vs[i][0]==v) return i;\n\t}\n//\tfor(;;);\n\treturn -1;\n}\n\nvoid check(int a)\n{\n\tif(cnt.size()<a) for(;;);\n/*\tmap<P,int>::iterator it=cnt.begin();\n\tfor(;it!=cnt.end();it++)\n\t{\n\t\tint b=it->second;\n\t\tif(b!=2) for(;;);\n\t}*/\n}\n\nint dis[550];\nqueue<int> bfs_que;\nvoid bfs(int s)\n{\n//\tprintf(\"xxxxxxxxxxxxxxxxxxxxx\\n\");\n\twhile(!bfs_que.empty()) bfs_que.pop();\n\tbfs_que.push(s);\n\tfor(int i=0;i<550;i++) dis[i]=1<<29;\n\tdis[s]=0;\n\tbfs_que.push(s);\n\twhile(!bfs_que.empty())\n\t{\n\t\tint v=bfs_que.front();\n//\t\tprintf(\"bfs %d\\n\",v);\n\t\tbfs_que.pop();\n\t\tfor(int i=0;i<dG[v].size();i++)\n\t\t{\n\t\t\tint u=dG[v][i];\n\t\t\tint nd=dis[v]+1;\n\t\t\tif(nd>=dis[u]) continue;\n\t\t\tdis[u]=nd;\n\t\t\tbfs_que.push(u);\n\t\t}\n\t}\n}\n\nvoid outputdG()\n{\n\tprintf(\"-----dual\\n\");\n\tfor(int i=0;i<vs.size();i++)\n\t{\n\t\tprintf(\"%d-\",i);\n\t\tfor(int j=0;j<dG[i].size();j++)\n\t\t{\n\t\t\tprintf(\"%d \",dG[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}\n\nint main()\n{\n\twhile(true)\n\t{\n\t\tint C,W;\n\t\tscanf(\"%d%d\",&C,&W);\n\t\tif(C==0) break;\n\t\tinit();\n\t\tfor(int i=0;i<C;i++)\n\t\t{\n\t\t\tint x,y;\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\tpoints[i]=Point(x,y,i);\n\t\t}\n\t\tsort(points,points+C,cmp);\n\t\tfor(int i=0;i<C;i++) pid[points[i].id]=i;\n\t\tint su=-1,sv=-1;\n\t\tfor(int i=0;i<W;i++)\n\t\t{\n\t\t\tint u,v;\n\t\t\tscanf(\"%d%d\",&u,&v);\n\t\t\tu--;v--;\n\t\t\tG[u].push_back(v);\n\t\t\tG[v].push_back(u);\n\t\t\tsu=u,sv=v;\n\t\t}\n\t\tfor(int i=0;i<C;i++)\n\t\t{\n\t\t\tcenter=i;\n\t\t\tsort(G[i].begin(),G[i].end(),cmp_angle);\n//\t\t\tprintf(\"%d:::\",i);\n//\t\t\tfor(int j=0;j<G[i].size();j++) printf(\"%d \",G[i][j]);\n//\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tque.push(P(min(su,sv),max(su,sv)));\n\t\twhile(!que.empty())\n\t\t{\n\t\t\tP p=que.front();\n\t\t\tque.pop();\n\t\t\tint u=p.first,v=p.second;\n//\t\t\tprintf(\"pop %d %d\\n\",u,v);\n\t\t\tP pp=P(min(u,v),max(u,v));\n\t\t\tif(cnt[pp]==2) continue;\n\t\t//\tbool flg;\n\t\t//\tif(cnt[pp]==1) flg=false;\n\t\t//\telse flg=true;\n\t\t\tres.clear();\n\t\t\tstroke(u,v,u);\n\t\t\tvs.push_back(res);\n//\t\t\tfor(int i=0;i<res.size();i++) printf(\"%d \",res[i]);\n//\t\t\tprintf(\"aaa\\n\");\n\t\t//\tcnt[pp]++;\n\t\t//\tif(flg) que.push(P(v,u));\n\t\t}\n\t\tif(vs.size()>500) for(;;);\n//\t\tfor(int i=0;i<vs.size();i++)\n//\t\t{\n//\t\t\tvector<int> vec=vs[i];\n//\t\t\tprintf(\"a:\");\n//\t\t\tfor(int j=0;j<vec.size();j++) printf(\"%d \",vec[j]);\n//\t\t\tprintf(\"\\n\");\n//\t\t}\n\t\tgetGraph(W);\n\t//\tcheck(W);\n\t\tint out=getMostOutSide();\n\t\tbfs(out);\n\t\tint ans=0;\n\t\tfor(int i=0;i<vs.size();i++) ans=max(ans,dis[i]);\n//\t\toutputdG();\n//\t\tprintf(\"---------%d--------------ans=%d\\n\",out,ans);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cassert>\nusing namespace std;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n\treturn abs(a.real()-b.real()) > EPS ? real(a) < real(b) : imag(a) + EPS < imag(b);\n    //return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\nP readPoint(){\n\tdouble x,y;\n\tcin >> x >> y;\n\treturn P(x,y);\n}\n\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\ntypedef vector<P> G;\n\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\n\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\nP reflection(const L &l, const P &p) {\n  return p + 2. * (projection(l, p) - p);\n}\ndouble distanceLP(const L &l, const P &p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\n#define rep(i,N) for(int i = 0 ; i < N ; i++)\nP ps[110];\nvector<int> g[110];\n\nvector<int> normalize(vector<int> v){\n\tauto it = min_element(v.begin(),v.end());\n\trotate(v.begin(),it,v.end());\n\treturn v;\n}\n\nint done[110];\nvoid f(int a,int b,int s,vector<int> &v){\n\tv.push_back(b);\n\tif( b == s ) return;\n\tif( done[b]++ ) throw 0;\n\tsort(g[b].begin(),g[b].end(),[&](int x,int y){\n\t\tP A = ps[x] - ps[b];\n\t\tP B = ps[y] - ps[b];\n\t\treturn cross(A,B) > 0;\n\t});\n\t//cout << find(g[b].begin(),g[b].end(),a) -g[b].begin();\n\t//cout << \"[\" << a << \",\" << s << \"] \";\n\t//for(int i = 0 ; i < g[b].size() ; i++)\n\t//\tcout << g[b][i] << \" \";\n\t//cout << endl;\n\trotate(g[b].begin(),find(g[b].begin(),g[b].end(),a),g[b].end());\n\tf(b,g[b][1],s,v);\n}\n\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n\ndouble area2(const G& P) {\n  double A = 0;\n  for (int i = 0; i < P.size(); ++i) \n    A += cross(curr(P, i), next(P, i));\n  return A;\n}\n\nint main(){\n\t\n\tint C,W;\n\twhile( cin >> C >> W && (C||W) ){\n\t\trep(i,C) ps[i] = readPoint();\n\t\trep(i,C) g[i].clear();\n\t\trep(i,W){\n\t\t\tint a,b;\n\t\t\tcin >> a >> b;\n\t\t\t--a,--b;\n\t\t\tg[a].push_back(b);\n\t\t\tg[b].push_back(a);\n\t\t}\n\t\tvector< vector<int> > poly;\n\t\trep(i,C){\n\t\t\trep(j,g[i].size()){\n\t\t\t\ttry{\n\t\t\t\t\tmemset(done,0,sizeof(done));\n\t\t\t\t\tvector<int> v;\n\t\t\t\t\tf(i,g[i][j],i,v);\n\t\t\t\t\tvector<P> g;\n\t\t\t\t\trep(k,v.size())g.push_back(ps[v[k]]);\n\t\t\t\t\tif( area2(g) > 0 ) throw 0;\n\t\t\t\t\tpoly.push_back(normalize(v));\n\t\t\t\t}catch(int x){\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(poly.begin(),poly.end());\n\t\tpoly.erase(unique(poly.begin(),poly.end()),poly.end());\n\t\t\n\t\tmap< pair<int,int>, vector<int> > edgs;\n\t\tfor(int i = 0 ; i < poly.size() ; i++){\n\t\t\tfor(int j = 0 ; j < poly[i].size() ; j++){\n\t\t\t\tint A = curr(poly[i],j);\n\t\t\t\tint B = next(poly[i],j);\n\t\t\t\tif( A > B ) swap(A,B);\n\t\t\t\tedgs[pair<int,int>(A,B)].push_back(i);\n\t\t\t}\n\t\t}\n\t\tint M = poly.size() + 1;\n\t\tint wf[M][M];\n\t\trep(i,M) rep(j,M){\n\t\t\twf[i][j] = i==j?0:1e9;\n\t\t}\n\t\t\n\t\tfor( auto x : edgs ){\n\t\t\tvector<int> v = x.second;\n\t\t\tif( v.size() < 2 ) v.push_back(M-1);\n\t\t\twf[v[0]][v[1]] = wf[v[1]][v[0]] = 1;\n\t\t}\n\t\trep(i,M)rep(j,M)rep(k,M) wf[j][k] = min(wf[j][i]+wf[i][k],wf[j][k]);\n\t\tint ans = 0;\n\t\trep(i,M){\n\t\t\tans = max(ans,wf[i][M-1]);\n\t\t}\n\t\tcout << ans << endl;\n\t\t\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#include <climits>\n\nusing namespace std;\n\ntypedef long long lint;\n\n//定数\nconst double EPS = 1e-10;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\nconst int INF = 1001001001;\nconst lint INFLL = 1001001001001001001ll;\n\n//初期化関連\n#define zclear(a) memset((a), 0 ,sizeof(a))\n#define mclear(a) memset((a), -1, sizeof(a))\n\n//デバッグ出力\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nbool eq(double a, double b) //a == b\n{\n    return (fabs(a - b) <= EPS);\n}\n\nbool neq(double a, double b) //a == b\n{\n    return (!eq(a, b));\n}\n  \nbool lt(double a, double b) //a < b\n{\n    return (a - b < -EPS);\n}\n  \nbool leq(double a, double b) //a <= b\n{\n    return (lt(a, b) || eq(a, b));\n}\n  \nbool gt(double a, double b) //a > b\n{\n    return (a - b > +EPS);\n}\n  \nbool geq(double a, double b) //a >= b\n{\n    return (gt(a, b) || eq(a, b));\n}\n\nclass Point{\npublic:\n\tdouble x, y;\n\tint id;\n\tPoint(double x = 0, double y = 0): x(x), y(y){}\n\tPoint operator + (Point p){return Point(x + p.x, y + p.y);}\n\tPoint operator - (Point p){return Point(x - p.x, y - p.y);}\n\tPoint operator * (double a){return Point(x * a, y * a);}\n\tPoint operator / (double a){return Point(x / a, y / a);}\n\tPoint operator * (const Point &a){\n\t\treturn Point(x * a.x - y * a.y, x * a.y + y * a.x);\n\t}\n\tbool operator < (const Point &p) const {\n\t\treturn (x != p.x ? x < p.x : y < p.y);\n\t}\n\tbool operator == (const Point &p) const {\n\t\treturn (fabs(x - p.x) < EPS && fabs(y - p.y) < EPS);\n\t}\n};\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\ndouble norm(Vector a){return (a.x * a.x + a.y * a.y);}\ndouble abs(Vector a){return (sqrt(norm(a)));}\ndouble abs(Vector a, Vector b){return (sqrt(norm(a - b)));}\ndouble dot(Vector a, Vector b){return (a.x * b.x + a.y * b.y);}\ndouble cross(Vector a, Vector b){return (a.x * b.y - a.y * b.x);}\ndouble atan(Vector a){return atan2(a.y, a.x);}\nbool sortX(Point a, Point b){return (a.x != b.x ? lt(a.x, b.x) : lt(a.y, b.y));}\nbool sortY(Point a, Point b){return (a.y != b.y ? lt(a.y, b.y) : lt(a.x, b.x));}\nPoint p;\nbool sortT(Point a, Point b){return (gt(cross(a - p, b - p), 0));}\n\nint ccw(Point p0, Point p1, Point p2)\n{\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > EPS) return (+1); //p0, p1, p2 が反時計周り\n\tif (cross(a, b) < -EPS) return (-1);//p0, p1, p2 が時計回り\n\tif (dot(a, b) < -EPS) return (+2); //p2--p0--p1 の順で一直線上\n\tif (norm(a) < norm(b)) return (-2); //p0--p1--p2 の順で一直線上\n\treturn (0); //p0--p2--p1 の順で一直線上\n}\n\nPolygon normalize(Polygon &v)\n{\n    int pt = 0;\n    for (int i = 1; i < v.size(); i++){\n        if (v[pt].y > v[i].y || (v[pt].y == v[i].y && v[pt].x > v[i].x)){\n            pt = i;\n        }\n    }\n    swap(v[pt], v[0]);\n    p = v[0];\n    sort(v.begin() + 1, v.end(), sortT);\n    return (v);\n}\n\nPolygon conhel(Polygon& ps)\n{\n    sort(ps.begin(), ps.end());\n    int k = 0, n = (int)ps.size();\n    Polygon qs(n * 2);\n      \n    for (int i = 0; i < n; i++){\n      while (k > 1 && cross(qs[k - 1] - qs[k - 2], ps[i] - qs[k - 1]) < -EPS) k--;\n      qs[k++] = ps[i];\n    }\n  \n    for (int i = n - 2, t = k; i >= 0; i--){\n      while (k > t && cross(qs[k - 1] - qs[k - 2], ps[i] - qs[k - 1]) < -EPS) k--;\n      qs[k++] = ps[i];\n    }\n  \n    qs.resize(k - 1);\n    return (qs);\n}\n\ndouble getArea(Polygon t){\n    double ans = 0.0;\n\tt = normalize(t);\n    for (unsigned int i = 0; i < t.size(); i++)\n        ans += cross(t[i] , t[(i + 1) % t.size()]);\n    return (fabs(ans) / 2);\n}\n\nbool isIntersectLL(Point p1, Point p2, Point p3, Point p4)\n{// 同一直線の場合は交差していると判定する.\n\treturn (abs(cross(p2 - p1, p4 - p3)) > EPS || // 傾きが異なる\n\t\tabs(cross(p2 - p1, p4 - p3)) < EPS); // 同じ直線である\n}\nbool isIntersectLS(Point p1, Point p2, Point p3, Point p4)\n{// 同一直線上にある場合も交差と判定\n\treturn (cross(p2 - p1, p3 - p1) * cross(p2 - p1, p4 - p1) < EPS);\n}\nbool isIntersectLP(Point p1, Point p2, Point p)\n{\n\treturn (neq(abs(ccw(p1, p2, p)), 1));\n}\nbool isIntersectSS(Point p1, Point p2, Point p3, Point p4)\n{\n    return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n             ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool isIntersectSP(Point p1, Point p2, Point p)\n{\n\treturn (eq(ccw(p1, p2, p), 0));\n}\nbool isInsideCP(Point c, double r, Point p)\n{\n\treturn (leq(abs(c - p), r));\n}\nbool isInsideCC(Point c1, double r1, Point c2, double r2)\n{\n\treturn (leq(abs(c1 - c2), r1 + r2) && geq(abs(c1 - c2), abs(r1 - r2)));\n}\nbool isInsidePolyP(Polygon gon, Point p)\n{\n    for (int i = 0; i < gon.size(); i++){\n        if (ccw(gon[i], gon[(i + 1) % gon.size()], p) == -1) return (false);\n    }\n    return (true);\n}\n\nPoint projection(Point p1, Point p2, Point p3) //直線p1p2 上への写像\n{\n\tdouble t = dot(p3 - p1, p2 - p1) / norm(p2 - p1);\n\treturn (p1 + (p2 - p1) * t);\n}\nPoint reflection(Point p1, Point p2, Point p3) //直線p1p2 上への反射\n{\n\treturn (p3 + (projection(p1, p2, p3) - p) * 2);\n}\ndouble distanceLP(Point p1, Point p2, Point p)\n{\n\treturn (abs(p - projection(p1, p2, p)));\n}\ndouble distanceLL(Point l1, Point l2, Point m1, Point m2)\n{\n\treturn (isIntersectLL(l1, l2, m1, m2) ? 0 : distanceLP(l1, l2, m1));\n}\ndouble distanceLS(Point l1, Point l2, Point s1, Point s2)\n{\n    if (isIntersectLS(l1, l2, s1, s2)) return (0);\n\treturn (min(distanceLP(l1, l2, s1), distanceLP(l1, l2, s2)));\n}\ndouble distanceSP(Point s1, Point s2, Point p)\n{\n\tPoint r = projection(s1, s2, p);\n\tif (isIntersectSP(s1, s2, r)) return (abs(r - p));\n\treturn (min(abs(s1 - p), abs(s2 - p)));\n}\ndouble distanceSS(Point s1, Point s2, Point t1, Point t2){\n\tif (isIntersectSS(s1, s2, t1, t2)) return (0);\n\treturn (min(min(distanceSP(s1, s2, t1), distanceSP(s1, s2, t2)),\n\t\t\tmin(distanceSP(t1, t2, s1), distanceSP(t1, t2, s2))));\n}\nPoint interPointLL(Point a1, Point a2, Point b1, Point b2)\n{\n\tdouble d = cross(a2 - a1, b2 - b1);\n\tif (abs(d) < EPS) throw \"Segment is Paralell!\";\n\tPoint a = a2 - a1, b = b2 - b1;\n    double t = cross(b, b1 - a1) / cross(b, a);\n    return (a1 + a * t);\n}\nvector<Point> interPointCC(Point c1, double r1, Point c2, double r2)\n{\n\tvector<Point> res;\n\tif (abs(c1 - c2) < EPS) return (vector<Point>()); // 交点が絶対にない\n\tdouble d = abs(c1 - c2);\n\tdouble rc = (d * d + r1 * r1 - r2 * r2) / (2 * d);\n\tdouble rs = sqrt(r1 * r1 - rc * rc);\n\tPoint diff = (c2 - c1) / d;\n\tres.push_back(Point(c1 + diff * Point(rc, rs)));\n\tres.push_back(Point(c1 + diff * Point(rc, -rs)));\n\treturn (res);\n}\nvector<Point> crosspointCL(Point a, double ra, Point b1, Point b2)\n{\n\tvector<Point> res;\n\tdouble dist = distanceLP(b1, b2, a);\n\tif (leq(dist, ra)){\n\t\tPoint s = projection(b1, b2, a);\n\t\tdist = sqrt(ra * ra - dist * dist);\n\t\tPoint t = (b2 - b1) / abs(b2 - b1);\n\t\tres.push_back(s + t * dist);\n\t\tres.push_back(s - t * dist);\n\t}\n\treturn (res);\n}\n\nPoint unitVector(Vector t)\n{\n    double u = abs(t);\n    return (Point(t.x / u , t.y / u));\n}\n\nPoint normalVector(Point p, Point a, Point b)\n{\n    Point v = unitVector(b - a);\n    v = cross(v, p - a) > 0 ? Point(v.y, -v.x) : Point(-v.y, v.x);\n    return v * distanceLP(p, a, b);\n}\n  \ndouble getCos(Vector a, Vector b)\n{\n    return (dot(a, b) / (abs(a) * abs(b)));\n}\n  \ndouble getSin(Vector a, Vector b)\n{\n    double t = getCos(a, b);\n    return (sqrt(1.0 - t * t));\n}\n  \ndouble getArg(Vector v)\n{\n    return (atan2(v.y, v.x));\n}\n\nPoint rotate(Point t, Point p, double r)\n{\n    double ta = cos(r) * (t.x - p.x) - sin(r) * (t.y - p.y) + p.x;\n    double tb = sin(r) * (t.x - p.x) + cos(r) * (t.y - p.y) + p.y;\n    return (Point(ta, tb));\n}\n\nint main()\n{\n\tint N, M;\n\t\n\twhile (scanf(\"%d %d\", &N, &M) && N){\n\t\tvector<Point> P(N);\n\t\tvector<int> to[128];\n\t\tbool exist[128][128] = {0};\n\t\t\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tscanf(\"%lf %lf\", &P[i].x, &P[i].y);\n\t\t\tP[i].id = i;\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < M; i++){\n\t\t\tint x, y;\n\t\t\tscanf(\"%d %d\", &x, &y);\n\t\t\tto[--x].push_back(--y);\n\t\t\tto[y].push_back(x);\n\t\t\texist[x][y] = exist[y][x] = 1;\n\t\t}\n\t\t\n\t\tPolygon Q = P;\n\t\tQ = conhel(Q);\n\t\t\n\t\tvector<int> belong[128][128];\n\t\tfor (int i = 0; i < Q.size(); i++){\n\t\t\tint u = Q[i].id, v = Q[(i + 1) % Q.size()].id;\n\t\t\tbelong[u][v].push_back(0);\n\t\t\tbelong[v][u].push_back(0);\n\t\t}\n\t\tint k = 1;\n\t\tset<vector<int> > s;\n\t\t\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tfor (int j = 0; j < N; j++){\n\t\t\t\tif (P[j] < P[i] && exist[i][j] && belong[i][j].size() < 2){\n\t\t\t\t\tvector<int> v;\n\t\t\t\t\tv.push_back(i);\n\t\t\t\t\tv.push_back(j);\n\t\t\t\t\twhile (1){\n\t\t\t\t\t\tint nextP = -1;\n\t\t\t\t\t\tint vv = v[v.size() - 1], uu = v[v.size() - 2];\n\t\t\t\t\t\tfor (int l = 0; l < to[vv].size(); l++){\n\t\t\t\t\t\t\tif (to[vv][l] == vv || to[vv][l] == uu) continue;\n\t\t\t\t\t\t\tdouble thetaT, thetaC;\n\t\t\t\t\t\t\tthetaT = acos(getCos(P[uu] - P[vv], P[to[vv][l]] - P[vv]));\n\t\t\t\t\t\t\tif (ccw(P[uu], P[vv], P[to[vv][l]]) > 0) thetaT = 2 * M_PI - thetaT;\n\t\t\t\t\t\t\tif (nextP != -1){\n\t\t\t\t\t\t\t\tthetaC = acos(getCos(P[uu] - P[vv], P[nextP] - P[vv]));\n\t\t\t\t\t\t\t\tif (ccw(P[uu], P[vv], P[nextP]) > 0) thetaC = 2 * M_PI - thetaC;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (nextP == -1 || thetaT < thetaC) nextP = to[vv][l];\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (nextP == i) break;\n\t\t\t\t\t\tv.push_back(nextP);\n\t\t\t\t\t}\n\t\t\t\t\tvector<int> ss = v;\n\t\t\t\t\tsort(ss.begin(), ss.end());\n\t\t\t\t\tif (s.find(ss) != s.end()) continue;\n\t\t\t\t\telse s.insert(ss);\n\t\t\t\t\tfor (int it = 0; it < v.size(); it++){\n\t\t\t\t\t\tint uu = v[it], vv = v[(it + 1) % v.size()];\n\t\t\t\t\t\tbelong[uu][vv].push_back(k);\n\t\t\t\t\t\tbelong[vv][uu].push_back(k);\n\t\t\t\t\t}\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int> G[1024];\n\t\t\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tfor (int j = i + 1; j < N; j++){\n\t\t\t\tif (belong[i][j].size()){\n\t\t\t\t\tint u = belong[i][j][0], v = belong[i][j][1];\n\t\t\t\t\tG[u].push_back(v);\n\t\t\t\t\tG[v].push_back(u);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tint done[1024];\n\t\tfill(done, done + 1024, -1);\n\t\tqueue<pair<int, int> > q;\n\t\t\n\t\tfor(q.push(make_pair(0, 0)); q.size(); q.pop()){\n\t\t\tpair<int, int> x = q.front();\n\t\t\tif (~done[x.first]) continue;\n\t\t\tdone[x.first] = x.second;\n\t\t\tans = max(ans, x.second);\n\t\t\t\n\t\t\tfor (int i = 0; i < G[x.first].size(); i++){\n\t\t\t\tq.push(make_pair(G[x.first][i], x.second + 1));\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<complex>\n#include<deque>\n#include<vector>\nusing namespace std;\ndouble eps=1e-6;\ndouble x[110];\ndouble y[110];\ndouble px[700];\ndouble py[700];\nint ijk[700];\nint v[700];\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ndouble PI=3.14159265358;\nstruct P{\n\tdouble x;double y;\n\tP(){}\n\tP(double X,double Y){\n\t\tx=X;y=Y;\n\t}\n\tP operator+ (const P &a)const{\n\t\treturn P(x+a.x,y+a.y);\n\t}\n\tP operator- (const P &a)const{\n\t\treturn P(x-a.x,y-a.y);\n\t}\n\tP operator* (const double &a)const{\n\t\treturn P(x*a,y*a);\n\t}\n\t/*operator+ (P a){\n\t\treturn P(x+a.x,y+a.y);\n\t}\n\toperator+ (P a){\n\t\treturn P(x+a.x,y+a.y);\n\t}*/\n\t\n};\ninline bool operator < (const P& a, const P& b) {\n    return a.x<b.x||(a.x==b.x&&a.y<b.y);\n}\ninline double cross(const P& a, const P& b) {\n\treturn a.x*b.y-a.y*b.x;\n}\ninline double dot(const P& a, const P& b) {\n\treturn a.x*b.x+a.y*b.y;\n}\n\ninline int ccw(P a, P b, P c) {\n\tif (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (b.x*b.x+b.y*b.y<c.x*c.x+c.y*c.y) return -2;       // a--b--c on line\n  return 0;\n}\n#define se second\n#define fi first\n\nbool intersectSS(const pair<P,P> &s, const pair<P,P> &t) {\n  return ccw(s.fi,s.se,t.fi)*ccw(s.fi,s.se,t.se) <= 0 &&\n         ccw(t.fi,t.se,s.fi)*ccw(t.fi,t.se,s.se) <= 0;\n}\n\nP pt[700];\nP ps[300];\nint s[400];\nint t[400];\ndouble left[400];\ndouble right[400];\nvector<pair<int,int> >g[700];\nint UF[700];\nint FIND(int a){\n\tif(UF[a]<0)return a;\n\treturn UF[a]=FIND(UF[a]);\n}\nvoid UNION(int a,int b){\n\ta=FIND(a);b=FIND(b);if(a==b)return;UF[a]+=UF[b];UF[b]=a;\n}\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<700;i++)UF[i]=-1;\n\t\tfor(int i=0;i<700;i++)g[i].clear();\n\t\tfor(int i=0;i<a;i++)scanf(\"%lf%lf\",x+i,y+i);\n\t\tfor(int i=0;i<a;i++){\n\t\t\tdouble X=cos(1)*x[i]-sin(1)*y[i];\n\t\t\tdouble Y=sin(1)*x[i]+cos(1)*y[i];\n\t\t\tx[i]=X;\n\t\t\ty[i]=Y;\n\t\t\tps[i]=P(x[i],y[i]);\n\t\t}\n\t\tfor(int i=0;i<b;i++){\n\t\t\tint p,q;scanf(\"%d%d\",&p,&q);\n\t\t\tp--;q--;\n\t\t\ts[i]=p;t[i]=q;\n\t\t\tpx[i*2]=(x[p]+x[q])/2+eps;\n\t\t\tpy[i*2]=(y[p]+y[q])/2;\n\t\t\tpx[i*2+1]=(x[p]+x[q])/2-eps;\n\t\t\tpy[i*2+1]=(y[p]+y[q])/2;\n\t\t\tpt[i*2]=P(px[i*2],py[i*2]);\n\t\t\tpt[i*2+1]=P(px[i*2+1],py[i*2+1]);\n\t\t}\n\t\tdeque<pair<int,int> >Q;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tvector<pair<double,pair<int,int> > >vec;\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tif(s[j]==i){\n\t\t\t\t\tvec.push_back(make_pair(atan2(y[t[j]]-y[i],x[t[j]]-x[i]),make_pair(j,t[j])));\n\t\t\t\t}\n\t\t\t\tif(t[j]==i){\n\t\t\t\t\tvec.push_back(make_pair(atan2(y[s[j]]-y[i],x[s[j]]-x[i]),make_pair(j,s[j])));\n\t\t\t\t}\n\t\t\t}\n\t\t\tstd::sort(vec.begin(),vec.end());\n\t\t\tint sz=vec.size();\n\t\t\tfor(int j=0;j<vec.size();j++){\n\t\t\t\tdouble th=vec[j].first;\n\t\t\t\tdouble th2=vec[(j+1)%sz].first;\n\t\t\t\tif(th>th2)th2+=2*PI;\n\t\t\t\tif(th2-th<=PI+EPS)continue;\n\t\t\t\tfor(int k=0;k<2;k++)for(int l=0;l<2;l++){\n\t\t\t\t\tif(intersectSS(make_pair(pt[vec[j].second.first*2+k],pt[vec[(j+1)%sz].second.first*2+l]),\n\t\t\t\t\tmake_pair(ps[i],ps[vec[j].second.second]))&&intersectSS(make_pair(pt[vec[j].second.first*2+k],pt[vec[(j+1)%sz].second.first*2+l]),\n\t\t\t\t\tmake_pair(ps[i],ps[vec[(j+1)%sz].second.second]))){\n\t\t\t\t\t\tg[vec[j].second.first*2+k].push_back(make_pair(vec[(j+1)%sz].second.first*2+l,0));\n\t\t\t\t\t\tg[vec[(j+1)%sz].second.first*2+l].push_back(make_pair(vec[j].second.first*2+k,0));\n\t\t\t\t\t\tUNION(vec[j].second.first*2+k,vec[(j+1)%sz].second.first*2+l);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<b*2;i++){\n\t\t\tijk[i]=999999999;\n\t\t\tv[i]=0;\n\t\t\tbool OK=true;\n\t\t\tint tt=s[i/2];\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tif(tt==s[j]||tt==t[j])continue;\n\t\t\t\tif(intersectSS(make_pair(ps[tt],ps[tt]+(pt[i]-ps[tt])*10000.0),make_pair(ps[s[j]],ps[t[j]]))){\n\t\t\t\t\tOK=false;break;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttt=t[i/2];\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tif(tt==s[j]||tt==t[j])continue;\n\t\t\t\tif(intersectSS(make_pair(ps[tt],ps[tt]+(pt[i]-ps[tt])*10000.0),make_pair(ps[s[j]],ps[t[j]]))){\n\t\t\t\t\tOK=false;break;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(OK){\n\t\t\t\tijk[i]=0;\n\t\t\t\tQ.push_back(make_pair(0,i));\n\t\t\t}\n\t\t\tfor(int j=i+1;j<b*2;j++){\n\t\t\t\tint cnt=0;\n\t\t\t\tif(FIND(i)==FIND(j))continue;\n\t\t\t\tfor(int k=0;k<b;k++){\n\t\t\t\t\tif(intersectSS(make_pair(ps[s[k]],ps[t[k]]),make_pair(pt[i],pt[j]))){\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tif(cnt>1)break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(cnt<2){\n\t\t\t\t\tif(cnt==0){\n\t\t\t\t\t\tUNION(i,j);\n\t\t\t\t\t}\n\t\t\t\t\tg[i].push_back(make_pair(j,cnt));\n\t\t\t\t\tg[j].push_back(make_pair(i,cnt));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(Q.size()){\n\t\t\tint cost=-Q.front().first;\n\t\t\tint at=Q.front().second;Q.pop_front();\n\t\t\tif(v[at])continue;\n\t\t\tv[at]=1;\n\t\t\tfor(int i=0;i<g[at].size();i++){\n\t\t\t\tif(!v[g[at][i].first]&&ijk[g[at][i].first]>cost+g[at][i].second){\n\t\t\t\t\tijk[g[at][i].first]=cost+g[at][i].second;\n\t\t\t\t\tif(g[at][i].second==1)Q.push_back(make_pair(-ijk[g[at][i].first],g[at][i].first));\n\t\t\t\t\telse Q.push_front(make_pair(-ijk[g[at][i].first],g[at][i].first));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret=0;\n\t\tfor(int i=0;i<b*2;i++)ret=max(ret,ijk[i]);\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<int,pair<bool,double>> P2;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define min_3(a,b,c) min(a,min(b,c))\n#define max_3(a,b,c) max(a,max(b,c))\n#define mp1(a,b,c) P1(a,P(b,c))\n#define mp2(a,b,c) P2(a,pair<bool,double>(b,c))\n#define pque(a) priority_queue<a>\n#define rpque(a) priority_queue<a,vector<a>,greater<a>>\n\nconst int INF=1000000000;\nconst int dre_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dre_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\nconst int kaijou[10]={1,1,2,6,24,120,720,5040,40320,362880};\n\nbool com(P2 x,P2 y){\n\tif(x.sc.fr!=y.sc.fr)return x.sc.fr;\n\treturn x.sc.sc>=y.sc.sc;\n}\n\nint main(){\n\twhile(1){\n\t\tint c,w;\n\t\tint x[110],y[110];\n\t\tint s,t;\n\t\t\n\t\tscanf(\"%d%d\",&c,&w); if(c==0&&w==0)break;\n\t\trep1(i,c)scanf(\"%d%d\",&x[i],&y[i]);\n\t\t\n\t\tvector<P1> V_;\n\t\trep1(i,c){\n\t\t\tV_.pb(mp1(x[i],y[i],i));\n\t\t}\n\t\tsor(V_);\n\t\tvector<P2> vec_[110];\n\t\trep1(i,c){\n\t\t\tvec_[i].pb(mp2(0,false,-INF));\n\t\t\trep1(j,c){\n\t\t\t\tif(i==j)continue;\n\t\t\t\tif(x[i]<x[j]){\n\t\t\t\t\tvec_[i].pb(mp2(j,true,(double)(y[j]-y[i])/(x[j]-x[i])));\n\t\t\t\t}\n\t\t\t\telse if(x[i]>x[j]){\n\t\t\t\t\tvec_[i].pb(mp2(j,false,(double)(y[j]-y[i])/(x[j]-x[i])));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(y[j]>y[i])vec_[i].pb(mp2(j,true,(double)INF));\n\t\t\t\t\telse vec_[i].pb(mp2(j,true,(double)-INF));\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(vec_[i].begin(),vec_[i].end(),com);\n\t\t}\n\t\t\n\t\tint v,e;\n\t\tvector<int> V;\n\t\tbool edge[110][110];\n\t\tvector<int> vec[110];\n\t\t\n\t\tv=c; e=w;\n\t\trep(i,c)V.pb(V_[i].sc.sc);\n\t\trep(i,110)rep(j,110)edge[i][j]=false;\n\t\trep(i,e){\n\t\t\tscanf(\"%d%d\",&s,&t);\n\t\t\tedge[s][t]=true;\n\t\t\tedge[t][s]=true;\n\t\t}\n\t\trep1(i,c){\n\t\t\trep(j,vec_[i].size()){\n\t\t\t\tvec[i].pb(vec_[i][j].fr);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ret=0;\n\t\twhile(e>0){\n\t\t\tret++;\n\t\t\t\n\t\t\tint a=-1;\n\t\t\trep(i,V.size()){\n\t\t\t\trep(j,105){\n\t\t\t\t\tif(edge[V[i]][j]){a=V[i]; break;}\n\t\t\t\t}\n\t\t\t\tif(a!=-1)break;\n\t\t\t}\n\t\t\t\n\t\t\tint b=0,c=a;\n\t\t\twhile(1){\n\t\t\t\trep(i,vec[c].size()){\n\t\t\t\t\tif(vec[c][i]==b){\n\t\t\t\t\t\ti++; i%=vec[c].size();\n\t\t\t\t\t\twhile(!edge[c][vec[c][i]]){\n\t\t\t\t\t\t\ti++; i%=vec[c].size();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tedge[c][vec[c][i]]=false;\n\t\t\t\t\t\tedge[vec[c][i]][c]=false;\n\t\t\t\t\t\te--;\n\t\t\t\t\t\tb=c;\n\t\t\t\t\t\tc=vec[c][i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(c==a)break;\n\t\t\t}\n\t\t\t\n\t\t\tbool updata=true;\n\t\t\twhile(updata){\n\t\t\t\tupdata=false;\n\t\t\t\trep1(i,c){\n\t\t\t\t\tint cnt=0;\n\t\t\t\t\tint t=-1;\n\t\t\t\t\trep1(j,c){\n\t\t\t\t\t\tif(edge[i][j]){cnt++; t=j;}\n\t\t\t\t\t}\n\t\t\t\t\tif(cnt==1){\n\t\t\t\t\t\tupdata=true;\n\t\t\t\t\t\tedge[i][t]=false;\n\t\t\t\t\t\tedge[t][i]=false;\n\t\t\t\t\t\te--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<utility>\n#include<map>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n\nusing namespace std;\n\nstruct Point{\n\tint x,y;\n\tint id;\n\tPoint(){}\n\tPoint(int a,int b,int c):x(a),y(b),id(c){}\n};\n\nPoint points[110];\nint pid[110];\n\nbool cmp(const Point &p1,const Point &p2)\n{\n\tif(p1.x!=p2.x) return p1.x<p2.x;\n\treturn p1.y<p2.y;\n}\n\nint center;\n\nbool cmp_angle(const int &id1,const int &id2)\n{\n\tint center=pid[::center];\n\tint id1_=pid[id1],id2_=pid[id2];\n\tint dx1=points[id1_].x-points[center].x;\n\tint dy1=points[id1_].y-points[center].y;\n\tint dx2=points[id2_].x-points[center].x;\n\tint dy2=points[id2_].y-points[center].y;\n\t//(-y,x)\n\tdouble ang1=atan2(dx1,-dy1);\n\tdouble ang2=atan2(dx2,-dy2);\n\treturn ang1<ang2;\n}\n\nvector<int> G[110];\n\nvector<vector<int> > vs;\nvector<int> dG[750];\n\ntypedef pair<int,int> P;\n\nmap<P,int> cnt;\nqueue<P> que;\nint a;\nvoid init()\n{\n\tvs.clear();\n\tfor(int i=0;i<110;i++) G[i].clear();\n\tfor(int i=0;i<550;i++) dG[i].clear();\n\tcnt.clear();\n\ta=0;\n}\n\nvector<int> res;\nvoid stroke(int u,int v,int st,int st2)\n{\n\t//u->v\n\tP p=P(min(u,v),max(u,v));\n\tif(cnt[p]==0)\n\t{\n\t\tque.push(P(v,u));\n\t}\n\tcnt[p]++;\n//\tif(v==st) return;\n\tif(u==st)\n\t{\n\t\ta++;\n\t\tres.push_back(u);\n\t}\n\t//res.push_back(v);\n\ta++;\n\tcenter=v;\n\tint id=distance(G[v].begin(),lower_bound(G[v].begin(),G[v].end(),u,cmp_angle));\n\tif(id==G[v].size()-1) id=0;\n\telse id++;\n\tint nxt=G[v][id];\n\tif(v==st&&nxt==st2) return;\n\telse\n\t{\n\t\tres.push_back(v);\n\t}\n\tstroke(v,nxt,st,st2);\n}\n\nvoid getGraph(int W)\n{\n\tint n=0;\n\tint V=vs.size();\n\tfor(int i=0;i<V;i++) for(int j=i+1;j<V;j++)\n\t{\n\t\tint ni=vs[i].size(),nj=vs[j].size();\n\t\tbool flg=false;\n\t\tfor(int iid=0;iid<ni;iid++) for(int jid=0;jid<nj;jid++)\n\t\t{\n\t\t\tint niid=iid==ni-1?0:iid+1;\n\t\t\tint njid=jid==nj-1?0:jid+1;\n\t\t\tif(vs[i][iid]==vs[j][njid]&&vs[i][niid]==vs[j][jid])\n\t\t\t{\n\t\t\t\tflg=true;\n\t\t\t\tn++;\n\t\t\t}\n\t\t}\n\t\tif(flg)\n\t\t{\n\t\t\tdG[i].push_back(j);\n\t\t\tdG[j].push_back(i);\n\t\t}\n\t}\n}\n\nvector<int> outSide;\n\nint getMostOutSide()\n{\n\tint u=points[0].id;\n\tint v=G[u][0];\n\tfor(int i=0;i<vs.size();i++)\n\t{\n\t\tfor(int j=0;j+1<vs[i].size();j++)\n\t\t{\n\t\t\tif(vs[i][j]==u&&vs[i][j+1]==v) return i;\n\t\t}\n\t\tif(vs[i][vs[i].size()-1]==u&&vs[i][0]==v) return i;\n\t}\n\treturn -1;\n}\n\n\nint dis[750];\nqueue<int> bfs_que;\nvoid bfs(int s)\n{\n\twhile(!bfs_que.empty()) bfs_que.pop();\n\tbfs_que.push(s);\n\tfor(int i=0;i<750;i++) dis[i]=1<<29;\n\tdis[s]=0;\n\tbfs_que.push(s);\n\twhile(!bfs_que.empty())\n\t{\n\t\tint v=bfs_que.front();\n\t\tbfs_que.pop();\n\t\tfor(int i=0;i<dG[v].size();i++)\n\t\t{\n\t\t\tint u=dG[v][i];\n\t\t\tint nd=dis[v]+1;\n\t\t\tif(nd>=dis[u]) continue;\n\t\t\tdis[u]=nd;\n\t\t\tbfs_que.push(u);\n\t\t}\n\t}\n}\n\n\nint main()\n{\n\twhile(true)\n\t{\n\t\tint C,W;\n\t\tscanf(\"%d%d\",&C,&W);\n\t\tif(C==0) break;\n\t\tinit();\n\t\tfor(int i=0;i<C;i++)\n\t\t{\n\t\t\tint x,y;\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\tpoints[i]=Point(x,y,i);\n\t\t}\n\t\tsort(points,points+C,cmp);\n\t\tfor(int i=0;i<C;i++) pid[points[i].id]=i;\n\t\tint su=-1,sv=-1;\n\t\tfor(int i=0;i<W;i++)\n\t\t{\n\t\t\tint u,v;\n\t\t\tscanf(\"%d%d\",&u,&v);\n\t\t\tu--;v--;\n\t\t\tG[u].push_back(v);\n\t\t\tG[v].push_back(u);\n\t\t\tsu=u,sv=v;\n\t\t}\n\t\tfor(int i=0;i<C;i++)\n\t\t{\n\t\t\tcenter=i;\n\t\t\tsort(G[i].begin(),G[i].end(),cmp_angle);\n\t\t}\n\t\tque.push(P(min(su,sv),max(su,sv)));\n\t\twhile(!que.empty())\n\t\t{\n\t\t\tP p=que.front();\n\t\t\tque.pop();\n\t\t\tint u=p.first,v=p.second;\n\t\t\tP pp=P(min(u,v),max(u,v));\n\t\t\tif(cnt[pp]==2) continue;\n\t\t\tres.clear();\n\t\t\tstroke(u,v,u,v);\n\t\t\tvs.push_back(res);\n\t\t}\n\t\tif(a<2*W) for(;;);\n\t\t//if(cnt.size()<W) for(;;);\n\t\tgetGraph(W);\n\t\tint out=getMostOutSide();\n\t\tbfs(out);\n\t\tint ans=0;\n\t\tfor(int i=0;i<vs.size();i++) ans=max(ans,dis[i]);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<int,int> state;\n\nint N,M;\nP t[100];\nint f[100][100];\nint d[100][100];\n\nbool check(int from,int to){\n  P base=t[to]-t[from];\n  for(int i=0;i<N;i++){\n    P target=t[i]-t[from];\n    if(imag(target*conj(base))<0)\n      return false;\n  }\n  return true;\n}\n\nvoid init(){\n  memset(f,0,sizeof(f));\n  memset(d,1,sizeof(d));\n}\n\nint solve(){\n  /*\n  int si=0,ti;\n  double mini=1e9;\n  for(int i=0;i<N;i++)\n    if(t[i].real()<t[si].real())si=i;\n  \n  for(int i=0;i<N;i++)\n    if(f[si][i] && arg(t[i]-t[si])< mini)\n      ti=i,mini=arg(t[i]-t[si]);\n      Q.push_back(state(si,ti));\n\n  d[si][ti]=0;\n\n  */\n  \n  deque<state> Q;  \n\n  for(int i=0;i<N;i++){\n    for(int j=0;j<N;j++){\n      if(f[i][j]&&check(i,j)){\n        d[i][j]=0;\n        Q.push_front(state(i,j));\n      }\n    }\n  }\n   \n  int ans=0;\n  while(!Q.empty()){\n    state p=Q.front();\n    Q.pop_front();\n    int from=p.first;\n    int to=p.second;\n    ans=d[from][to];\n    \n    if(d[from][to]+1<d[to][from]){\n      d[to][from]=d[from][to]+1;\n      Q.push_back(state(to,from));\n    }\n    int id=-1;\n    double mini=1e9;\n    for(int i=0;i<N;i++){\n      if(f[to][i]&&i!=from){\n        if( arg( (t[i]-t[to])*conj(t[to]-t[from]) ) < mini){\n          id=i;\n          mini=arg( (t[i]-t[to])*conj(t[to]-t[from]) );\n        }\n      }\n    }\n    if(id!=-1&&d[to][id]>d[from][to]){\n      d[to][id]=d[from][to];\n      Q.push_front(state(to,id));\n    }\n  }\n  return ans;\n}\n\nint main(){\n  while(1){\n    cin>>N>>M;\n    if(N==0&&M==0)break;\n    init();\n    for(int i=0;i<N;i++){\n      int x,y;\n      cin>>x>>y;\n      t[i]=P(x,y);\n    }\n    for(int i=0;i<M;i++){\n      int x,y;\n      cin>>x>>y;\n      x--,y--;\n      f[x][y]=f[y][x]=true;\n    }\n    cout<<solve()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<int,pair<bool,double>> P2;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define min_3(a,b,c) min(a,min(b,c))\n#define max_3(a,b,c) max(a,max(b,c))\n#define mp1(a,b,c) P1(a,P(b,c))\n#define mp2(a,b,c) P2(a,pair<bool,double>(b,c))\n#define pque(a) priority_queue<a>\n#define rpque(a) priority_queue<a,vector<a>,greater<a>>\n\nconst int INF=1000000000;\nconst int dre_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dre_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\nconst int kaijou[10]={1,1,2,6,24,120,720,5040,40320,362880};\n\nbool com(P2 x,P2 y){\n\tif(x.sc.fr!=y.sc.fr)return x.sc.fr;\n\treturn x.sc.sc>=y.sc.sc;\n}\n\nint main(){\n\twhile(1){\n\t\tint c,w;\n\t\tint x[110],y[110];\n\t\tint s,t;\n\t\t\n\t\tscanf(\"%d%d\",&c,&w); if(c==0&&w==0)break;\n\t\trep1(i,c)scanf(\"%d%d\",&x[i],&y[i]);\n\t\t\n\t\tvector<P1> V_;\n\t\trep1(i,c){\n\t\t\tV_.pb(mp1(x[i],y[i],i));\n\t\t}\n\t\tsor(V_);\n\t\tvector<P2> vec_[110];\n\t\trep1(i,c){\n\t\t\tvec_[i].pb(mp2(0,false,-INF));\n\t\t\trep1(j,c){\n\t\t\t\tif(i==j)continue;\n\t\t\t\tif(x[i]<x[j]){\n\t\t\t\t\tvec_[i].pb(mp2(j,true,(double)(y[j]-y[i])/(x[j]-x[i])));\n\t\t\t\t}\n\t\t\t\telse if(x[i]>x[j]){\n\t\t\t\t\tvec_[i].pb(mp2(j,false,(double)(y[j]-y[i])/(x[j]-x[i])));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(y[j]>y[i])vec_[i].pb(mp2(j,true,(double)INF));\n\t\t\t\t\telse vec_[i].pb(mp2(j,true,(double)-INF));\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(vec_[i].begin(),vec_[i].end(),com);\n\t\t}\n\t\t\n\t\tint v,e;\n\t\tvector<int> V;\n\t\tbool edge[110][110];\n\t\tvector<int> vec[110];\n\t\t\n\t\tv=c; e=w;\n\t\trep(i,c)V.pb(V_[i].sc.sc);\n\t\trep(i,110)rep(j,110)edge[i][j]=false;\n\t\trep(i,e){\n\t\t\tscanf(\"%d%d\",&s,&t);\n\t\t\tedge[s][t]=true;\n\t\t\tedge[t][s]=true;\n\t\t}\n\t\trep1(i,c){\n\t\t\trep(j,vec_[i].size()){\n\t\t\t\tvec[i].pb(vec_[i][j].fr);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ret=0;\n\t\twhile(e>0){\n\t\t\tret++;\n\t\t\t\n\t\t\tint a=-1;\n\t\t\trep(i,V.size()){\n\t\t\t\trep(j,110){\n\t\t\t\t\tif(edge[V[i]][j]){a=V[i]; break;}\n\t\t\t\t}\n\t\t\t\tif(a!=-1)break;\n\t\t\t}\n\t\t\t\n\t\t\tint b=0,c=a;\n\t\t\twhile(1){\n\t\t\t\trep(i,vec[c].size()){\n\t\t\t\t\tif(vec[c][i]==b){\n\t\t\t\t\t\ti++; i%=vec[c].size();\n\t\t\t\t\t\twhile(!edge[c][vec[c][i]]){\n\t\t\t\t\t\t\ti++; i%=vec[c].size();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tedge[c][vec[c][i]]=false;\n\t\t\t\t\t\tedge[vec[c][i]][c]=false;\n\t\t\t\t\t\te--;\n\t\t\t\t\t\tb=c;\n\t\t\t\t\t\tc=vec[c][i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(c==a)break;\n\t\t\t}\n\t\t\t\n\t\t\tbool updata=true;\n\t\t\twhile(updata){\n\t\t\t\tupdata=false;\n\t\t\t\trep(i,110){\n\t\t\t\t\tint cnt=0;\n\t\t\t\t\tint t=-1;\n\t\t\t\t\trep(j,110){\n\t\t\t\t\t\tif(edge[i][j]){cnt++; t=j;}\n\t\t\t\t\t}\n\t\t\t\t\tif(cnt==1){\n\t\t\t\t\t\tupdata=true;\n\t\t\t\t\t\tedge[i][t]=false;\n\t\t\t\t\t\tedge[t][i]=false;\n\t\t\t\t\t\te--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <queue>\n#include <cstdio>\n#include <cassert>\n#include <algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst double EPS=1e-8;\nconst double PI=acos(-1);\n\nstruct point{\n\tdouble x,y;\n\tpoint():x(0),y(0){}\n\tpoint(double x,double y):x(x),y(y){}\n\tpoint &operator+=(const point &a){ x+=a.x; y+=a.y; return *this; }\n\tpoint &operator-=(const point &a){ x-=a.x; y-=a.y; return *this; }\n\tpoint &operator*=(double c){ x*=c; y*=c; return *this; }\n\tpoint &operator/=(double c){ x/=c; y/=c; return *this; }\n\tpoint operator+(const point &a)const{ return point(x+a.x,y+a.y); }\n\tpoint operator-(const point &a)const{ return point(x-a.x,y-a.y); }\n\tpoint operator/(double c)const{ return point(x/c,y/c); }\n\tpoint operator-()const{ return point(-x,-y); }\n\tbool operator< (const point &a)const{ return x+EPS<a.x || (abs(x-a.x)<EPS && y+EPS<a.y); }\n\tbool operator==(const point &a)const{ return abs(x-a.x)<EPS && abs(y-a.y)<EPS; }\n\tbool operator!=(const point &a)const{ return abs(x-a.x)>EPS || abs(y-a.y)>EPS; }\n};\n\ndouble cross(const point &a,const point &b){ return a.x*b.y-a.y*b.x; }\n\ndouble arg(const point &a){ double t=atan2(a.y,a.x); return t<0?t+2*PI:t; }\n\ntypedef vector<point> polygon;\n\nbool is_ccw(const polygon &F){\n\tint n=F.size();\n\tdouble A=0;\n\trep(i,n) A+=cross(F[i],F[(i+1)%n]);\n\treturn A>-EPS;\n}\n\n// trace the frame of a polygon\nvector<int> trace(const vector<int> *G,int u0,int i0){\n\tvector<int> F;\n\tint u=u0,i=i0;\n\tdo{\n\t\tF.push_back(u);\n\t\tint v=G[u][i];\n\t\tint k=G[v].size();\n\t\trep(j,k) if(G[v][j]==u) i=(j-1+k)%k;\n\t\tu=v;\n\t}while(u!=u0 || i!=i0);\n\treturn F;\n}\n\n// normalize the list of vertices\nvector<int> reg(vector<int> a){\n\tint k=min_element(a.begin(),a.end())-a.begin();\n\trep(i,k){\n\t\ta.push_back(a[0]);\n\t\ta.erase(a.begin());\n\t}\n\treturn a;\n}\n\nint main(){\n\tfor(int n,m;scanf(\"%d%d\",&n,&m),n;){\n\t\tpoint P[100];\n\t\trep(u,n) scanf(\"%lf%lf\",&P[u].x,&P[u].y);\n\n\t\tvector<int> G[100];\n\t\trep(i,m){\n\t\t\tint u,v; scanf(\"%d%d\",&u,&v); u--; v--;\n\t\t\tG[u].push_back(v);\n\t\t\tG[v].push_back(u);\n\t\t}\n\n\t\t// angle sort\n\t\trep(u,n){\n\t\t\tint k=G[u].size();\n\t\t\tpair<double,int> A[100];\n\t\t\trep(i,k){\n\t\t\t\tint v=G[u][i];\n\t\t\t\tA[i]=make_pair(arg(P[v]-P[u]),v);\n\t\t\t}\n\t\t\tsort(A,A+k);\n\t\t\trep(i,k) G[u][i]=A[i].second;\n\t\t}\n\n\t\t// decompose to polygons\n\t\tvector< vector<int> > F; // set of polygons\n\t\trep(u,n) rep(i,G[u].size()) F.push_back(reg(trace(G,u,i)));\n\t\tsort(F.begin(),F.end());\n\t\tF.erase(unique(F.begin(),F.end()),F.end());\n\n\t\t// find the outside boundary\n\t\tint n2=F.size(),u0=-1;\n\t\trep(u,n2){\n\t\t\tint k=F[u].size();\n\t\t\tpolygon H(k);\n\t\t\trep(i,k) H[i]=P[F[u][i]];\n\t\t\tif(!is_ccw(H)){\n\t\t\t\tassert(u0==-1);\n\t\t\t\tu0=u;\n\t\t\t}\n\t\t}\n\t\tassert(u0!=-1);\n\n\t\t// build the dual graph\n\t\tvector<int> G2[300];\n\t\trep(u,n2) rep(v,u) {\n\t\t\tbool ok=false;\n\t\t\tint nu=F[u].size(),nv=F[v].size();\n\t\t\trep(i,nu) rep(j,nv) if(F[u][i]==F[v][(j+1)%nv] && F[u][(i+1)%nu]==F[v][j]) ok=true;\n\t\t\tif(ok){\n\t\t\t\tG2[u].push_back(v);\n\t\t\t\tG2[v].push_back(u);\n\t\t\t}\n\t\t}\n\n\t\t// BFS\n\t\tint d[100];\n\t\trep(u,n2) d[u]=(u==u0?0:-1);\n\t\tqueue<int> Q;\n\t\tQ.push(u0);\n\t\twhile(!Q.empty()){\n\t\t\tint u=Q.front(); Q.pop();\n\t\t\trep(i,G2[u].size()){\n\t\t\t\tint v=G2[u][i];\n\t\t\t\tif(d[v]==-1) d[v]=d[u]+1, Q.push(v);\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",*max_element(d,d+n2));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n\n#define SIZE 105\n\nstruct Point{\n\tPoint(double arg_x,double arg_y){\n\t\tx = arg_x;\n\t\ty = arg_y;\n\t}\n\n\tPoint(){\n\t\tx = y = 0.0;\n\t}\n\n\tPoint operator + (Point p){ return Point(x+p.x,y+p.y); }\n\tPoint operator - (Point p){ return Point(x-p.x,y-p.y);}\n\tPoint operator * (double a){ return Point(a*x,a*y); }\n\tPoint operator / (double a){ return Point(x/a,y/a); }\n\n\tdouble abs(){ return sqrt(norm()); }\n\tdouble norm(){ return x*x + y*y; }\n\n\tbool operator<(const Point &p) const{\n\t\treturn x != p.x? x < p.x: y < p.y;\n\t}\n\n\tbool operator == (const Point &p) const{\n\t\treturn fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n\t}\n\n\tdouble x,y;\n};\n\nstruct Edge{\n\tEdge(int arg_to,double arg_theta){\n\t\tto = arg_to;\n\t\ttheta = arg_theta;\n\t}\n\tbool operator<(const struct Edge &arg) const{\n\n\t\treturn theta < arg.theta;\n\t}\n\n\tint to;\n\tdouble theta;\n};\n\nstruct Info{\n\tInfo(int arg_area_id,int arg_sum_dist){\n\t\tarea_id = arg_area_id;\n\t\tsum_dist = arg_sum_dist;\n\t}\n\tbool operator<(const struct Info &arg) const{\n\n\t\treturn sum_dist > arg.sum_dist; //総距離の降順(PQ)\n\t}\n\n\tint area_id,sum_dist;\n};\n\ntypedef Point Vector;\n\nstruct Line{\n\tLine(){\n\n\t}\n\tLine(Point a,Point b){\n\t\tp[0] = a;\n\t\tp[1] = b;\n\t}\n\tPoint p[2];\n};\n\n\nint num_pillar,num_wall;\nPoint point[SIZE];\nvector<Edge> G[SIZE];\nint min_dist[100*33*49];\n\n\nvector<int> get_area(int first_from,int first_to){\n\n\tvector<int> ret;\n\n\tint from = first_from;\n\tint to = first_to;\n\n\tdo{\n\n\t\tret.push_back(from);\n\t\tint next = to;\n\n\t\tfor(int k = 0; k < G[next].size(); k++){\n\t\t\tif(G[next][k].to == from){\n\t\t\t\tif(k != 0){\n\n\t\t\t\t\tto = G[next][k-1].to;\n\n\t\t\t\t}else{\n\n\t\t\t\t\tto = G[next][G[to].size()-1].to;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfrom = next;\n\n\t}while(from != first_from || to != first_to);\n\n\treturn ret;\n}\n\n\nvector<int> pol_sort(vector<int> polygon){\n\n\tint min_index = BIG_NUM,loc;\n\n\tfor(int i = 0; i < polygon.size(); i++){\n\n\t\tif(min_index > polygon[i]){\n\t\t\tmin_index = polygon[i];\n\t\t\tloc = i;\n\t\t}\n\t}\n\n\t//min_indexが先頭になるようにする\n\tfor(int i = 0; i < loc; i++){\n\n\t\tpolygon.push_back(polygon[0]);\n\t\tpolygon.erase(polygon.begin());\n\t}\n\n\treturn polygon;\n}\n\ndouble get_theta(Vector A){\n\n\tdouble ret = atan2(A.y,A.x);\n\n\tif(ret < 0){\n\n\t\tret += 2*M_PI;\n\t}\n\treturn ret;\n}\n\n\ndouble norm(Vector a){\n\treturn a.x*a.x+a.y*a.y;\n}\n\ndouble abs(Vector a){\n\treturn sqrt(norm(a));\n}\n\ndouble cross(Vector a,Vector b){\n    return a.x*b.y-a.y*b.x;\n}\n\ndouble dot(Vector a,Vector b){\n    return a.x*b.x + a.y*b.y;\n}\n\nvoid func(){\n\n\tfor(int i = 0; i < num_pillar; i++){\n\n\t\tG[i].clear();\n\t}\n\n\tfor(int i = 0; i < num_pillar; i++){\n\n\t\tscanf(\"%lf %lf\",&point[i].x,&point[i].y);\n\t}\n\n\tint from,to;\n\n\tfor(int i = 0; i < num_wall; i++){\n\n\t\tscanf(\"%d %d\",&from,&to);\n\n\t\tfrom--;\n\t\tto--;\n\n\t\tG[from].push_back(Edge(to,get_theta(point[from]-point[to])));\n\t\tG[to].push_back(Edge(from,get_theta(point[to]-point[from])));\n\t}\n\n\tfor(int i = 0; i < num_pillar; i++){\n\n\t\tsort(G[i].begin(),G[i].end());\n\t}\n\n\tvector<vector<int>> first_POLYGON;\n\n\tfor(int i = 0; i < num_pillar; i++){\n\n\t\tfor(int k = 0; k < G[i].size(); k++){\n\n\t\t\tvector<int> polygon = pol_sort(get_area(i,G[i][k].to));\n\n\t\t\tfirst_POLYGON.push_back(polygon);\n\t\t}\n\t}\n\n\tsort(first_POLYGON.begin(),first_POLYGON.end());\n\tfirst_POLYGON.erase(unique(first_POLYGON.begin(),first_POLYGON.end()),first_POLYGON.end());\n\n\tvector<vector<int>> POLYGON;\n\tvector<int> A,B;\n\n\tfor(int i = 0; i < first_POLYGON.size(); i++){\n\n\t\tbool FLG = true;\n\t\tA = first_POLYGON[i];\n\t\tsort(A.begin(),A.end());\n\n\t\tfor(int k = 0; k < i; k++){\n\t\t\tB = first_POLYGON[k];\n\t\t\tsort(B.begin(),B.end());\n\n\t\t\tif(A == B){\n\n\t\t\t\tFLG = false;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\t\tif(FLG){\n\t\t\tPOLYGON.push_back(first_POLYGON[i]);\n\t\t}\n\t}\n\n\tif(POLYGON.size() == 1){\n\n\t\tprintf(\"1\\n\");\n\t\treturn;\n\t}\n\n\tvector<int> dist_1;\n\n\tfor(int i = 0; i < POLYGON.size(); i++){\n\n\t\tdouble tmp = 0;\n\n\t\tfor(int k = 0; k < POLYGON[i].size(); k++){\n\n\t\t\ttmp += cross(point[POLYGON[i][k]],point[POLYGON[i][(k+1)%POLYGON[i].size()]]);\n\t\t}\n\t\tif(tmp < EPS){\n\t\t\tdist_1.push_back(i);\n\t\t}\n\t}\n\n\tint num_area = POLYGON.size();\n\tvector<int> final_G[num_area];\n\n\n\tfor(int i = 0; i < num_area-1; i++){ //領域\n\n\t\tfor(int a = 0; a < POLYGON[i].size(); a++){ //辺の走査\n\n\t\t\tLine tmp_line = Line(point[POLYGON[i][a]],point[POLYGON[i][(a+1)%POLYGON[i].size()]]);\n\n\t\t\tbool FLG = false;\n\n\t\t\tfor(int k = i+1; k < num_area; k++){ //隣接領域\n\t\t\t\tif(k == i)continue;\n\n\t\t\t\tfor(int b = 0; b < POLYGON[k].size(); b++){ //隣接領域の辺\n\t\t\t\t\tLine tmp_line2 = Line(point[POLYGON[k][b]],point[POLYGON[k][(b+1)%POLYGON[k].size()]]);\n\n\t\t\t\t\tif((tmp_line.p[0] == tmp_line2.p[0] && tmp_line.p[1] == tmp_line2.p[1]) ||\n\t\t\t\t\t\t\t(tmp_line.p[0] == tmp_line2.p[1] && tmp_line.p[1] == tmp_line2.p[0])){\n\n\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\tfinal_G[i].push_back(k);\n\t\t\t\t\t\tfinal_G[k].push_back(i);\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(FLG)break;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < num_area; i++){\n\n\t\tmin_dist[i] = BIG_NUM;\n\t}\n\n\tpriority_queue<Info> Q;\n\n\tfor(int i = 0; i < dist_1.size(); i++){\n\n\t\tmin_dist[dist_1[i]] = 1;\n\t\tQ.push(Info(dist_1[i],1));\n\t}\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().sum_dist > min_dist[Q.top().area_id]){\n\n\t\t\tQ.pop();\n\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < final_G[Q.top().area_id].size(); i++){\n\n\t\t\t\tint next_area = final_G[Q.top().area_id][i];\n\t\t\t\tint next_dist = Q.top().sum_dist+1;\n\n\t\t\t\tif(min_dist[next_area] > next_dist){\n\t\t\t\t\tmin_dist[next_area] = next_dist;\n\t\t\t\t\tQ.push(Info(next_area,next_dist));\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tint ans = 0;\n\n\tfor(int i = 0; i < num_area; i++){\n\n\t\tans = max(ans,min_dist[i]);\n\t}\n\n\tprintf(\"%d\\n\",ans-1);\n}\n\nint main(){\n\n\twhile(true){\n\n\t\tscanf(\"%d %d\",&num_pillar,&num_wall);\n\t\tif(num_pillar == 0 && num_wall == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef complex<double> Point;\nstruct Edge{\n    int from, to, id;\n    Edge() {}\n    Edge(int a, int b, int id) : from(a), to(b), id(id) {}\n};\n\ndouble angle(Point a, Point b){\n    double th = arg(conj(a) * b);\n    return (th >= 0) ? th : th + 2.0 * M_PI;\n}\n\nnamespace std{\n    bool operator < (const Point& a, const Point& b){\n        if(a.real() != b.real()) return a.real() < b.real();\n        return a.imag() < b.imag();\n    }\n}\n\nint main(){\n    int N, M;\n    while(cin >> N >> M && N){\n        vector<Point> ps(N);\n        REP(i, N){\n            double x, y;\n            cin >> x >> y;\n            ps[i] = Point(x, y);\n        }\n        vector<Edge> edges;\n        vector<vector<Edge>> G(N);\n        REP(i, M){\n            int a, b;\n            cin >> a >> b;\n            a--; b--;\n            edges.push_back(Edge(a, b, 2 * i));\n            edges.push_back(Edge(b, a, 2 * i + 1));\n            G[a].push_back(edges[2 * i]);\n            G[b].push_back(edges[2 * i + 1]);\n        }\n\n        int F = 0;\n        vector<int> face(2 * M, -1); // ティツセツコテ」ツ?ョテ・ツ渉ウテ・ツ?エテ」ツ?ョテゥツ敖「テ」ツ?ョid\n        for(int i = 0; i < 2 * M; i++){\n            if(face[i] != -1) continue;\n            int cur_e = i;\n            int prev_p = edges[i].from;\n            int cur_p = edges[i].to;\n            while(face[cur_e] == -1){\n                face[cur_e] = F;\n                int next_e = -1;\n                int next_p = -1;\n                double next_arg = 1e16;\n                for(int i = 0; i < G[cur_p].size(); i++){\n                    int to = G[cur_p][i].to;\n                    if(to == prev_p) continue;\n                    double arg = angle(ps[prev_p] - ps[cur_p], ps[to] - ps[cur_p]);\n                    if(next_arg > arg){\n                        next_arg = arg;\n                        next_e = G[cur_p][i].id;\n                        next_p = to;\n                    }\n                }\n                assert(next_e != -1);\n                cur_e = next_e;\n                prev_p = cur_p;\n                cur_p = next_p;\n            }\n            F++;\n        }\n\n        bool connected[600][600] = {};\n        for(int i = 0; i < M; i++){\n            int f1 = face[2 * i];\n            int f2 = face[2 * i + 1];\n            connected[f1][f2] = connected[f2][f1] = true;\n        }\n\n        int base = min_element(ps.begin(), ps.end()) - ps.begin();\n        int start = -1;\n        Edge tmp;\n        double min_agl = 1e8;\n        for(int i = 0; i < G[base].size(); i++){\n            Edge e = G[base][i];\n            double agl = arg(ps[e.to] - ps[e.from]);\n            if(min_agl > agl){\n                min_agl = agl;\n                start = face[e.id];\n                tmp = e;\n            }\n        }\n\n        vector<int> dist(F, -1);\n        queue<int> que;\n        que.push(start);\n        dist[start] = 0;\n        while(!que.empty()){\n            int from = que.front(); que.pop();\n            for(int to = 0; to < F; to++){\n                if(connected[from][to] && dist[to] == -1){\n                    dist[to] = dist[from] + 1;\n                    que.push(to);\n                }\n            }\n        }\n        cout << *max_element(dist.begin(), dist.end()) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<int,int> state;\n\nint N,M;\nP t[100];\nint f[100][100];\nint d[100][100];\n\nvoid init(){\n  memset(f,0,sizeof(f));\n  memset(d,1,sizeof(d));\n}\n\nint solve(){\n  int si=0,ti;\n  double mini=1e9;\n  for(int i=0;i<N;i++)\n    if(t[i].real()<t[si].real())si=i;\n  \n  for(int i=0;i<N;i++)\n    if(f[si][i] && arg(t[i]-t[si])< mini)\n      ti=i,mini=arg(t[i]-t[si]);\n\n  deque<state> Q;  \n  Q.push_back(state(si,ti));\n  d[si][ti]=0;\n  \n  int ans=0;\n  while(!Q.empty()){\n    state p=Q.front();\n    Q.pop_front();\n    int from=p.first;\n    int to=p.second;\n    ans=d[from][to];\n    \n    if(d[from][to]+1<d[to][from]){\n      d[to][from]=d[from][to]+1;\n      Q.push_back(state(to,from));\n    }\n    int id=-1;\n    double mini=1e9;\n    for(int i=0;i<N;i++){\n      if(f[to][i]&&i!=from){\n        if( arg( (t[i]-t[to])*conj(t[to]-t[from]) ) < mini){\n          id=i;\n          mini=arg( (t[i]-t[to])*conj(t[to]-t[from]) );\n        }\n      }\n    }\n    if(id!=-1&&d[to][id]>d[from][to]){\n      d[to][id]=d[from][to];\n      Q.push_front(state(to,id));\n    }\n  }\n  return ans;\n}\n\nint main(){\n  while(1){\n    cin>>N>>M;\n    if(N==0&&M==0)break;\n    init();\n    for(int i=0;i<N;i++){\n      int x,y;\n      cin>>x>>y;\n      t[i]=P(x,y);\n    }\n    for(int i=0;i<M;i++){\n      int x,y;\n      cin>>x>>y;\n      x--,y--;\n      f[x][y]=f[y][x]=true;\n    }\n    cout<<solve()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<queue>\n#include<cassert>\n#include<map>\nusing namespace std;\n#define rep(i, n) for ( int i = 0; i < n; i++ )\n#define INF (1<<21)\n#define MAX 104\n\nint n, m;\nbool V[MAX][MAX];\nint T[MAX][MAX];\nvector<int> G[MAX];\npair<int, int> P[MAX];\n\nvector<vector<pair<int, int> > > R; // room;\n\ndouble angle(int s, int t){\n  return atan2(P[t].second - P[s].second, P[t].first - P[s].first);\n}\n\nvoid parse(int s, int t, bool isouter){\n  if ( V[s][t] || s == t ) return;\n  int cur1 = s, cur2 = t;\n\n  vector<pair<int, int> > room;\n\n  while(1){\n    if ( V[cur1][cur2] ) break;\n    V[cur1][cur2] = true;\n    room.push_back(make_pair(cur1, cur2));\n    int nx;\n    rep(i, G[cur2].size() ){\n      if ( G[cur2][i] == cur1 ){ nx = i; break; } // next node after counter-clock\n    }\n    nx = (nx+1)%G[cur2].size();\n    cur1 = cur2;\n    cur2 = G[cur2][nx];\n  }\n  R.push_back(room);\n}\n\nbool isConnected(vector<pair<int, int> > &c1, vector<pair<int, int> > &c2){\n  for ( int i = 0; i < c1.size(); i++ ){\n    for ( int j = 0; j < c2.size(); j++ ){\n      pair<int, int> p1 = c1[i];\n      pair<int, int> p2 = c2[j];\n      if ( p1 == p2 ) return true;\n      swap(p2.first, p2.second);\n      if ( p1 == p2 ) return true;\n    }\n  }\n  return false;\n}\n\nvector<vector<int> > makeGraph(){\n  R.clear();\n\n  // sort by angle\n  rep(s, n) {\n    for ( int e = G[s].size()-2; e >= 0; e--)\n      for ( int j = 0; j <= e; j++ )\n\tif ( angle(s, G[s][j]) > angle(s, G[s][j+1]) ) swap(G[s][j], G[s][j+1]);\n  }\n\n  rep(i, n) rep(j, n) V[i][j] = false;\n\n  int bottom = 0;\n  rep(i, n){\n    if ( P[i].second == P[bottom].second ){\n      if ( P[i].first < P[bottom].first ) bottom = i;\n    } else {\n      if ( P[i].second < P[bottom].second ) bottom = i;\n    }\n  }\n\n  parse(bottom, G[bottom][0], true); // the outer\n\n  rep(s, n)  rep(j, G[s].size()){\n    int t =  G[s][j];\n    parse(s, t, false);\n  }\n\n  vector<vector<int> > g;\n  g.resize(R.size());\n  for ( int i = 0; i < R.size()-1; i++ ){\n    for ( int j = i+1; j < R.size(); j++ ){\n      if ( isConnected(R[i], R[j])) {\n\tg[i].push_back(j);\n\tg[j].push_back(i);\n      }\n    }\n  }\n\n\n  return g;\n}\n\nint bfs(vector<vector<int> > g){\n  vector<int> d;\n  d.resize(g.size());\n  rep(i, g.size()) d[i] = INF;\n  queue<int> Q;\n  int u, v;\n  for ( d[0] = 0, Q.push(0); !Q.empty(); ){\n    u = Q.front(); Q.pop();\n    for ( int i = 0; i < g[u].size(); i++ ){\n      int v = g[u][i];\n      if ( d[v] != INF ) continue;\n      d[v] = d[u] + 1;\n      Q.push(v);\n    }\n  }\n  int maxv = 0;\n  for ( int i = 0; i < d.size(); i++) maxv = max(maxv, d[i]);\n  return maxv;\n}\n\nmain(){\n  while(1){\n    cin >> n >> m;\n    if ( n == 0 ) break;\n    assert( 3 <= n && n <= 100 );\n    assert( n <= m && m <= 200 );\n    rep(i, n) cin >> P[i].first >> P[i].second;\n    rep(i, n) G[i].clear();\n    map<pair<int, int>, bool> vis;\n    rep(i, m){\n      int s, t;\n      cin >> s >> t;\n      s--; t--;\n      G[s].push_back(t);\n      G[t].push_back(s);\n      T[s][t] = T[t][s] = (i+1); // 0 = outer\n\n      assert( !vis[make_pair(min(s, t), max(s,t))]);\n      vis[make_pair(min(s, t), max(s,t))] = true;\n    }\n    for ( int i = 0; i < n; i++ ){\n      assert( G[i].size() >= 2 );\n    }\n    cout << bfs(makeGraph()) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<queue>\nusing namespace std;\ntypedef pair<double,int> P;\nint x[100];\nint y[100];\nvector<P> e[100];\nint a[300];\nint b[300];\nint id[300][100];\nbool used[300][100];\nvector<int> adj[300];\nint out_i,out_v;\nint out;\nvector<int> e2[600];\nint dist[600];\n\nint rev(int i,int v){\n\tif(a[i]==v)return b[i];\n\telse return a[i];\n}\n\nvoid solve(int i,int v,int k){\n\tvector<int> res;\n\tint s=i;\n\tused[s][v]=true;\n\tres.push_back(s);\n\tif(i==out_i&&v==out_v)out=k;\n\twhile(1){\n\t\ti=e[v][(id[i][v]+1)%e[v].size()].second;\n\t\tv=rev(i,v);\n\t\tif(i==s)break;\n\t\tused[i][v]=true;\n\t\tres.push_back(i);\n\t\tif(i==out_i&&v==out_v)out=k;\n\t}\n\tfor(i=0;i<res.size();i++)adj[res[i]].push_back(k);\n}\n\nint max(int a,int b){return a>b?a:b;}\n\nvoid bfs(int n,int s){\n\tint i;\n\tfor(i=0;i<n;i++)dist[i]=-1;\n\tdist[s]=0;\n\tqueue<int> que;\n\tque.push(s);\n\twhile(!que.empty()){\n\t\tint v=que.front();\n\t\tque.pop();\n\t\tfor(i=0;i<e2[v].size();i++){\n\t\t\tint u=e2[v][i];\n\t\t\tif(dist[u]==-1){\n\t\t\t\tdist[u]=dist[v]+1;\n\t\t\t\tque.push(u);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(1){\n\t\tint n,m,i,j;\n\t\tscanf(\"%d %d\",&n,&m);\n\t\tif(n==0&&m==0)break;\n\t\tfor(i=0;i<n;i++)e[i].clear();\n\t\tfor(i=0;i<m;i++)adj[i].clear();\n\t\tint lf=0;\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d %d\",&x[i],&y[i]);\n\t\t\tif(x[i]<x[lf])lf=i;\n\t\t}\n\t\tfor(i=0;i<m;i++){\n\t\t\tscanf(\"%d %d\",&a[i],&b[i]);\n\t\t\ta[i]--;b[i]--;\n\t\t\tdouble dx=(double)(x[b[i]]-x[a[i]]);\n\t\t\tdouble dy=(double)(y[b[i]]-y[a[i]]);\n\t\t\te[a[i]].push_back(P(atan2(dy,dx),i));\n\t\t\te[b[i]].push_back(P(atan2(-dy,-dx),i));\n\t\t}\n\t\tfor(i=0;i<n;i++)sort(e[i].begin(),e[i].end());\n\t\tint bt=0;\n\t\tfor(i=0;i<n;i++){\n\t\t\tfor(j=0;j<e[i].size();j++){\n\t\t\t\tid[e[i][j].second][i]=j;\n\t\t\t\tif(i==lf)if(y[rev(e[i][j].second,i)]>y[rev(e[i][bt].second,i)])bt=j;\n\t\t\t}\n\t\t}\n\t\tout_i=e[lf][bt].second;\n\t\tout_v=lf;\n\t\tfor(i=0;i<m;i++)for(j=0;j<n;j++)used[i][j]=false;\n\t\tint k=0;\n\t\tfor(i=0;i<m;i++){\n\t\t\tif(!used[i][a[i]]){\n\t\t\t\tsolve(i,a[i],k);\n\t\t\t\tk++;\n\t\t\t}\n\t\t\tif(!used[i][b[i]]){\n\t\t\t\tsolve(i,b[i],k);\n\t\t\t\tk++;\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<k;i++)e2[i].clear();\n\t\tfor(i=0;i<m;i++){\n\t\t\te2[adj[i][0]].push_back(adj[i][1]);\n\t\t\te2[adj[i][1]].push_back(adj[i][0]);\n\t\t}\n\t\tbfs(k,out);\n\t\tint ans=0;\n\t\tfor(i=0;i<k;i++)ans=max(ans,dist[i]);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <vector>\n#include <valarray>\n#include <array>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <random>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\ntypedef long double R;\ntypedef complex<R> P;\n\nconst R EPS = 1e-10;\nconst R PI = acos((R)(-1));\n\nint sgn(R a) {\n    if (a < -EPS) return -1;\n    if (a > EPS) return 1;\n    return 0;\n}\n\nR cross(P a, P b) { return a.real()*b.imag() - a.imag()*b.real(); }\n\ntypedef vector<P> Pol;\n\nP cu(const Pol &p, int i) {\n    int s = p.size();\n    return p[(i%s+s)%s];\n}\n\nR area_naive(const Pol &p) {\n    R u = 0;\n    for (int i = 0; i < (int)p.size(); i++) {\n        u += cross(cu(p, i), cu(p, i+1));\n    }\n    return u/2;\n}\n\nR area(const Pol &p) {\n    return abs(area_naive(p));\n}\n\n/*\n -1 -> clock\n 0 -> non polygon\n 1 -> counter clock\n */\nbool iscclock(const Pol &p) {\n    return sgn(area_naive(p));\n}\n\nint dualGraph(P p[], vector<int> g[], int n,\n    Pol pol[], vector<int> rg[]) {\n    map<pair<int, int>, int> mp;\n    for (int i = 0; i < n; i++) {\n        sort(g[i].begin(), g[i].end(), [&](int l, int r){\n            return arg(p[l]-p[i]) > arg(p[r]-p[i]);\n        });\n        for (int j = 0; j < (int)g[i].size(); j++) {\n            mp[make_pair(i, g[i][j])] = j;\n        }\n    }\n\n    vector<vector<int>> idx(n), rev(n);\n    for (int i = 0; i < n; i++) {\n        idx[i] = vector<int>(g[i].size(), -3);\n        rev[i].resize(g[i].size());\n        for (int j = 0; j < (int)g[i].size(); j++) {\n            rev[i][j] = mp[make_pair(g[i][j], i)];\n        }\n    }\n\n    int idc = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < (int)g[i].size(); j++) {\n            if (idx[i][j] != -3) continue;\n            Pol po;\n            int ii = i, jj = j;\n            while (idx[ii][jj] != -2) {\n                po.push_back(p[ii]);\n                idx[ii][jj] = -2;\n                int ni = g[ii][jj];\n                int nj = (rev[ii][jj]+1) % g[ni].size();\n                ii = ni; jj = nj;\n            }\n            int id;\n            if (area(po) == 0 || !iscclock(po)) {\n                id = -1;\n            } else {\n                id = idc;\n                pol[idc] = po;\n                idc++;\n            }\n            while (idx[ii][jj] == -2) {\n                idx[ii][jj] = id;\n                int ni = g[ii][jj];\n                int nj = (rev[ii][jj]+1) % g[ni].size();\n                ii = ni; jj = nj;\n            }\n        }\n    }\n\n    for (int i = 0; i < idc; i++) {\n        rg[i].clear();\n    }\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < (int)g[i].size(); j++) {\n            if (idx[i][j] < 0) continue;\n            rg[idx[i][j]].push_back(idx[g[i][j]][rev[i][j]]);\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        sort(rg[i].begin(), rg[i].end());\n        rg[i].erase(unique(rg[i].begin(), rg[i].end()), rg[i].end());\n    }\n\n    return idc;\n}\n\nconst int MN = 110;\nP p[MN];\nvector<int> g[MN];\n\nPol pol[2*MN];\nvector<int> rg[2*MN];\n\nint dist[2*MN][2*MN];\n\nbool solve() {\n    int c, w;\n    cin >> c >> w;\n    if (!c) return false;\n\n    for (int i = 0; i < c; i++) {\n        R x, y;\n        cin >> x >> y;\n        p[i] = P(x, y);\n        g[i].clear();\n    }\n\n    for (int i = 0; i < w; i++) {\n        int s, t;\n        cin >> s >> t; s--; t--;\n        g[s].push_back(t);\n        g[t].push_back(s);\n    }\n\n    int m = dualGraph(p, g, c, pol, rg);\n\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < m; j++) {\n            dist[i][j] = 10000;\n        }\n        dist[i][i] = 0;\n        for (int d: rg[i]) {\n            dist[i][d] = 1;\n        }\n    }\n\n    for (int k = 0; k < m; k++) {\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < m; j++) {\n                dist[i][j] = min(dist[i][j], dist[i][k]+dist[k][j]);\n            }\n        }\n    }\n\n    int ma = 0;\n    for (int i = 0; i < m; i++) {\n        ma = max(ma, dist[0][i]);\n    }\n    cout << ma << endl;\n    return true;\n}\n\n\nint main() {\n    while (solve()) {}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<int,int> state;\n\nint N,M,x,y;\nP t[100];\nint f[100][100];\nint d[100][100];\n\nint solve(){\n  int si=0,ti,ans=0;\n  double mini=1e9;\n  for(int i=0;i<N;i++)\n    if(t[i].real()<t[si].real())si=i;\n  deque<state> Q;    \n  for(int i=0;i<N;i++)\n    if(f[si][i] && arg(t[i]-t[si])< mini)\n      ti=i,mini=arg(t[i]-t[si]);\n  Q.push_back(state(si,ti));\n  d[si][ti]=0;\n   \n  while(!Q.empty()){\n    state p=Q.front();\n    Q.pop_front();\n    int from=p.first;\n    int to=p.second;\n    ans=max(ans,d[from][to]);\n    \n    if(d[from][to]+1<d[to][from]){\n      d[to][from]=d[from][to]+1;\n      Q.push_back(state(to,from));\n    }\n    int id=-1;\n    double mini=1e9;\n    for(int i=0;i<N;i++){\n      if(f[to][i]&&i!=from){\n        if( arg( (t[i]-t[to])*conj(t[to]-t[from]) ) < mini){\n          id=i;\n          mini=arg( (t[i]-t[to])*conj(t[to]-t[from]) );\n        }\n      }\n    }\n    if(id!=-1&&d[to][id]>d[from][to]){\n      d[to][id]=d[from][to];\n      Q.push_front(state(to,id));\n    }\n  }\n  return ans;\n}\n\nint main(){\n  while(1){\n    cin>>N>>M;\n    if(N==0&&M==0)break;\n    memset(f,0,sizeof(f));\n    memset(d,1,sizeof(d));\n    for(int i=0;i<N;i++){\n      cin>>x>>y;\n      t[i]=P(x,y);\n    }\n    for(int i=0;i<M;i++){\n      cin>>x>>y;\n      x--,y--;\n      f[x][y]=f[y][x]=true;\n    }\n    cout<<solve()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<complex>\n#include<deque>\n#include<vector>\nusing namespace std;\ndouble eps=1e-6;\ndouble x[110];\ndouble y[110];\ndouble px[700];\ndouble py[700];\nint ijk[700];\nint v[700];\nint g[700][700];\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ndouble PI=3.14159265358;\ntypedef complex<double> P;\ntypedef vector<P> G;\n\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n#define se second\n#define fi first\n\nbool intersectSS(const pair<P,P> &s, const pair<P,P> &t) {\n  return ccw(s.fi,s.se,t.fi)*ccw(s.fi,s.se,t.se) <= 0 &&\n         ccw(t.fi,t.se,s.fi)*ccw(t.fi,t.se,s.se) <= 0;\n}\n\nP pt[700];\nP ps[300];\nint s[400];\nint t[400];\ndouble left[400];\ndouble right[400];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<a;i++)scanf(\"%lf%lf\",x+i,y+i);\n\t\tfor(int i=0;i<a;i++){\n\t\t\tdouble X=cos(1)*x[i]-sin(1)*y[i];\n\t\t\tdouble Y=sin(1)*x[i]+cos(1)*y[i];\n\t\t\tx[i]=X;\n\t\t\ty[i]=Y;\n\t\t\tps[i]=P(x[i],y[i]);\n\t\t}\n\t\tfor(int i=0;i<b;i++){\n\t\t\tint p,q;scanf(\"%d%d\",&p,&q);\n\t\t\tp--;q--;\n\t\t\ts[i]=p;t[i]=q;\n\t\t\tpx[i*2]=(x[p]+x[q])/2+eps;\n\t\t\tpy[i*2]=(y[p]+y[q])/2;\n\t\t\tpx[i*2+1]=(x[p]+x[q])/2-eps;\n\t\t\tpy[i*2+1]=(y[p]+y[q])/2;\n\t\t\tpt[i*2]=P(px[i*2],py[i*2]);\n\t\t\tpt[i*2+1]=P(px[i*2+1],py[i*2+1]);\n\t\t}\n\t\tdeque<pair<int,int> >Q;\n\t\tfor(int i=0;i<b*2;i++)for(int j=i+1;j<b*2;j++)g[i][j]=g[j][i]=999999999;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tvector<pair<double,pair<int,int> > >vec;\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tif(s[j]==i){\n\t\t\t\t\tvec.push_back(make_pair(atan2(y[t[j]]-y[i],x[t[j]]-x[i]),make_pair(j,t[j])));\n\t\t\t\t}\n\t\t\t\tif(t[j]==i){\n\t\t\t\t\tvec.push_back(make_pair(atan2(y[s[j]]-y[i],x[s[j]]-x[i]),make_pair(j,t[j])));\n\t\t\t\t}\n\t\t\t}\n\t\t\tstd::sort(vec.begin(),vec.end());\n\t\t\tint sz=vec.size();\n\t\t\tfor(int j=0;j<vec.size();j++){\n\t\t\t\tdouble th=vec[j].first;\n\t\t\t\tdouble th2=vec[(j+1)%sz].first;\n\t\t\t\tif(th>th2)th2+=2*PI;\n\t\t\t\tif(th2-th<=PI+EPS)continue;\n\t\t//\t\tprintf(\"%d %d %d\\n\",i,vec[j].second,vec[(j+1)%sz].second);\n\t\t\t\tfor(int k=0;k<2;k++)for(int l=0;l<2;l++){\n\t\t\t\t\tif(intersectSS(make_pair(pt[vec[j].second.first*2+k],pt[vec[(j+1)%sz].second.first*2+l]),\n\t\t\t\t\tmake_pair(ps[i],ps[vec[j].second.second]))&&intersectSS(make_pair(pt[vec[j].second.first*2+k],pt[vec[(j+1)%sz].second.first*2+l]),\n\t\t\t\t\tmake_pair(ps[i],ps[vec[(j+1)%sz].second.second]))){\n\t\t\t//\t\t\tprintf(\"%d %d\\n\",vec[j].second*2+k,vec[(j+1)%sz].second*2+l);\n\t\t\t\t\t\tg[vec[j].second.first*2+k][vec[(j+1)%sz].second.first*2+l]=g[vec[(j+1)%sz].second.first*2+l][vec[j].second.first*2+k]=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<b*2;i++){\n\t\t\tijk[i]=999999999;\n\t\t\tv[i]=0;\n\t\t\tbool OK=true;\n\t\t\tint tt=s[i/2];\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tif(tt==s[j]||tt==t[j])continue;\n\t\t\t\tif(intersectSS(make_pair(ps[tt],ps[tt]+(pt[i]-ps[tt])*10000.0),make_pair(ps[s[j]],ps[t[j]]))){\n\t\t\t\t\tOK=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttt=t[i/2];\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tif(tt==s[j]||tt==t[j])continue;\n\t\t\t\tif(intersectSS(make_pair(ps[tt],ps[tt]+(pt[i]-ps[tt])*10000.0),make_pair(ps[s[j]],ps[t[j]]))){\n\t\t\t\t\tOK=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(OK){\n\t\t//\t\tprintf(\" %d\\n\",i);\n\t\t\t\tijk[i]=0;\n\t\t\t\tQ.push_back(make_pair(0,i));\n\t\t\t}\n\t\t\tfor(int j=i+1;j<b*2;j++){\n\t\t\t\tint cnt=0;\n\t\t\t\tfor(int k=0;k<b;k++){\n\t\t\t\t\tif(intersectSS(make_pair(ps[s[k]],ps[t[k]]),make_pair(pt[i],pt[j]))){\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tif(cnt>1)break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(cnt<2)g[i][j]=g[j][i]=cnt;\n\t\t\t//\telse g[i][j]=g[j][i]=999999999;\n\t\t\t}\n\t\t}\n\t\n\t\twhile(Q.size()){\n\t\t\tint cost=-Q.front().first;\n\t\t\tint at=Q.front().second;Q.pop_front();\n\t\t\tif(v[at])continue;\n\t\t\tv[at]=1;\n\t\t\tfor(int i=0;i<b*2;i++){\n\t\t\t\tif(!v[i]&&ijk[i]>cost+g[at][i]){\n\t\t\t\t\tijk[i]=cost+g[at][i];\n\t\t\t\t\tif(g[at][i]==1)Q.push_back(make_pair(-ijk[i],i));\n\t\t\t\t\telse Q.push_front(make_pair(-ijk[i],i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret=0;\n\t\tfor(int i=0;i<b*2;i++)ret=max(ret,ijk[i]);\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <bitset>\n#include <cmath>\n#include <set>\n\n#define TIMES(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef bitset<300> Spec;\nconst double EPS = 1e-9;\n\nstruct Polygon {\n    Spec spec;\n    int id;\n\n    bool operator <(const Polygon &p) const {\n        return spec.to_string() < p.spec.to_string();\n    }\n\n    bool operator ==(const Polygon &p) const {\n        return spec == p.spec;\n    }\n};\n\nint cmp(double a, double b) {\n    const double diff = a-b;\n    if(fabs(diff) < EPS) return 0;\n    return diff < 0 ? -1 : 1;\n}\n\ndouble dot(const P &a, const P &b) {\n    return a.real()*b.real() + a.imag()*b.imag();\n}\n\ndouble cross(const P &a, const P &b) {\n    return a.real()*b.imag() - a.imag()*b.real();\n}\n\nPolygon get_polygon(int a, int b, const vector<P> &poles, const vector<vector<int>> &graph, const vector<vector<int>> &wall_id) {\n    Polygon polygon;\n    polygon.spec[wall_id[a][b]] = true;\n\n    const int start1 = b;\n    const int start2 = a;\n    //cout << b+1 << ' ' << a+1;\n    while(true) {\n        P prev = poles[a];\n        P prev_prev = poles[b];\n        const P vec = -(prev - prev_prev);\n        const double len = abs(vec);\n        int candidate = -1;\n        int cross_sgn = -1;\n        double dot_val = -2;\n        for(int i : graph[a]) {\n            if(i == b) continue;\n            const P vec2 = poles[i] - prev;\n            const double len2 = abs(vec2);\n            int sgn = cmp(cross(vec, vec2), 0);\n            double dv = dot(vec, vec2) / len / len2;\n            //cout << \": \" << i+1 << ' ' << sgn << ' ' << dv << endl;\n            if(sgn > cross_sgn \n                || (sgn == cross_sgn && cmp(dv, dot_val) > 0))\n            {\n                candidate = i;\n                cross_sgn = sgn;\n                dot_val = dv;\n            }\n        }\n        if(candidate == -1) break;\n        const int wid = wall_id[a][candidate];\n        //cout << ',' << candidate+1;\n        if(polygon.spec[wid]) {\n            if(a != start1 || candidate != start2) polygon = Polygon();\n            break;\n        }\n        polygon.spec[wid] = true;\n        b = a; a = candidate;\n    }\n    //cout << endl;\n    return polygon;\n}\n\nint solve_inner(const set<Polygon> &polygons) {\n    Spec outer_wall;\n    outer_wall.flip();\n    for(const Polygon &p1 : polygons) {\n        for(const Polygon &p2 : polygons) {\n            if(p1.id == p2.id) continue;\n            Spec s = p1.spec & p2.spec;\n            if(s.none()) continue;\n            outer_wall &= s.flip();\n        }\n    }\n    Spec seen = outer_wall;\n    TIMES(i, 300) {\n        Spec next = seen;\n        for(const Polygon &p : polygons) {\n            if((seen & p.spec).any()) {\n                next |= p.spec;\n            }\n        }\n        if(seen == next) return i+1;\n        seen = next;\n    }\n    return -1;\n}\n\nbool solve() {\n    int C, W;\n    cin >> C >> W;\n    if(!C && !W) return false;\n\n    vector<P> poles;\n    vector<vector<int>> graph(C);\n    vector<vector<int>> wall_id(C, vector<int>(C, -1));\n    TIMES(_, C) {\n        double x, y;\n        cin >> x >> y;\n        poles.push_back(P(x, y));\n    }\n    TIMES(i, W) {\n        int s, t;\n        cin >> s >> t;\n        --s; --t;\n        graph[s].push_back(t);\n        graph[t].push_back(s);\n        wall_id[s][t] = wall_id[t][s] = i;\n    }\n\n    set<Polygon> polygons;\n    // for each wall and direction\n    TIMES(i, C) {\n        for(int j : graph[i]) {\n            Polygon poly = get_polygon(i, j, poles, graph, wall_id);\n            if(poly.spec.any()) {\n                poly.id = polygons.size();\n                polygons.insert(poly);\n            }\n        }\n    }\n    /*\n    cout << polygons.size() << endl;\n    for(const Polygon &p : polygons) {\n        cout << p.spec << endl;\n    }\n    */\n\n    cout << solve_inner(polygons) << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<int,pair<bool,double> > P2;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define min_3(a,b,c) min(a,min(b,c))\n#define max_3(a,b,c) max(a,max(b,c))\n#define mp1(a,b,c) P1(a,P(b,c))\n#define mp2(a,b,c) P2(a,pair<bool,double>(b,c))\n#define pque(a) priority_queue<a>\n#define rpque(a) priority_queue<a,vector<a>,greater<a>>\n\nconst int INF=1000000000;\nconst int dre_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dre_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\nconst int kaijou[10]={1,1,2,6,24,120,720,5040,40320,362880};\n\nbool com(P2 x,P2 y){\n\tif(x.sc.fr!=y.sc.fr)return x.sc.fr;\n\treturn x.sc.sc>=y.sc.sc;\n}\n\nint main(){\n\tint ppp=0;\n\twhile(1){\n\t\tppp++; if(ppp>=6)while(1){}\n\t\tstatic int v,w;\n\t\tstatic int x[110],y[110];\n\t\tstatic int s,t;\n\t\t\n\t\tscanf(\"%d%d\",&v,&w); if(v==0&&w==0)break;\n\t\trep1(i,v)scanf(\"%d%d\",&x[i],&y[i]);\n\t\t\n\t\tstatic vector<P1> V_; V_.clear();\n\t\trep1(i,v){\n\t\t\tV_.pb(mp1(x[i],y[i],i));\n\t\t}\n\t\tsor(V_);\n\t\tstatic vector<P2> vec_[110];\n\t\trep1(i,v){\n\t\t\tvec_[i].clear();\n\t\t\tvec_[i].pb(mp2(0,false,-INF));\n\t\t\trep1(j,v){\n\t\t\t\tif(i==j)continue;\n\t\t\t\tif(x[i]<x[j]){\n\t\t\t\t\tvec_[i].pb(mp2(j,true,(double)(y[j]-y[i])/(x[j]-x[i])));\n\t\t\t\t}\n\t\t\t\telse if(x[i]>x[j]){\n\t\t\t\t\tvec_[i].pb(mp2(j,false,(double)(y[j]-y[i])/(x[j]-x[i])));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(y[j]>y[i])vec_[i].pb(mp2(j,true,(double)INF));\n\t\t\t\t\telse vec_[i].pb(mp2(j,true,(double)-INF));\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(vec_[i].begin(),vec_[i].end(),com);\n\t\t}\n\t\t\n\t\tstatic int e;\n\t\tstatic vector<int> V; V.clear();\n\t\tstatic bool edge[110][110];\n\t\tstatic vector<int> vec[110]; \n\t\t\n\t\te=w;\n\t\trep(i,v)V.pb(V_[i].sc.sc);\n\t\trep(i,110)rep(j,110)edge[i][j]=false;\n\t\trep(i,e){\n\t\t\tscanf(\"%d%d\",&s,&t);\n\t\t\tedge[s][t]=true;\n\t\t\tedge[t][s]=true;\n\t\t}\n\t\trep1(i,v){\n\t\t\tvec[i].clear();\n\t\t\trep(j,vec_[i].size()){\n\t\t\t\tvec[i].pb(vec_[i][j].fr);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ret=0;\n\t\twhile(e>0){\n\t\t\tret++;\n\t\t\t\n\t\t\tint a=-1;\n\t\t\trep(i,V.size()){\n\t\t\t\trep(j,105){\n\t\t\t\t\tif(edge[V[i]][j]){a=V[i]; break;}\n\t\t\t\t}\n\t\t\t\tif(a!=-1)break;\n\t\t\t}\n\t\t\t\n\t\t\tint b=0,c=a;\n\t\t\twhile(1){\n\t\t\t\tif(c==-1||vec[c].size()==0)break;\n\t\t\t\trep(i,vec[c].size()){\n\t\t\t\t\tif(vec[c][i]==b){\n\t\t\t\t\t\ti++; i%=vec[c].size();\n\t\t\t\t\t\twhile(!edge[c][vec[c][i]]){\n\t\t\t\t\t\t\ti++; i%=vec[c].size();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tedge[c][vec[c][i]]=false;\n\t\t\t\t\t\tedge[vec[c][i]][c]=false;\n\t\t\t\t\t\te--;\n\t\t\t\t\t\tb=c;\n\t\t\t\t\t\tc=vec[c][i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(c==a)break;\n\t\t\t}\n\t\t\t\n\t\t\tbool updata=true;\n\t\t\twhile(updata){\n\t\t\t\tupdata=false;\n\t\t\t\trep1(i,v){\n\t\t\t\t\tint cnt=0;\n\t\t\t\t\tint t=105;\n\t\t\t\t\trep1(j,v){\n\t\t\t\t\t\tif(edge[i][j]){cnt++; t=j;}\n\t\t\t\t\t}\n\t\t\t\t\tif(cnt==1){\n\t\t\t\t\t\tupdata=true;\n\t\t\t\t\t\tedge[i][t]=false;\n\t\t\t\t\t\tedge[t][i]=false;\n\t\t\t\t\t\te--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <ctime>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <fstream>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <numeric>\n#include <cassert>\nusing namespace std;\n\ntypedef complex<double> P;\n\nint C,W;\n\nint wsc[300] , wtc[300];\nP c[100];\nstruct NODE{\n\tint from,to,id;\n\tNODE(int from,int to,int id) : from(from) , to(to) , id(id) {}\n\tNODE(){}\n};\nvector<NODE> geo[100];\n\nconst double PI = acos(-1);\nint start;\ndouble fx(double rd){\n\twhile( rd < -1e-9 )   rd += 2*PI;\n\twhile( rd >= 2*PI - 1e-9) rd -= 2*PI;\n\treturn rd;\n}\ndouble R(P a){\n\tdouble rd = atan2(a.imag(),a.real());\n\treturn fx(rd);\n}\nint get(int x,int prev,vector<int> &ad){\n\tif( x == start ) return 1;\n\t\n\tdouble r1 = R(c[x]-c[prev]);\n\tdouble bad = 0;\n\tint o = -1;\n\tint id;\n\tfor(int i = 0 ; i < geo[x].size() ; i++){\n\t\tif( geo[x][i].to == prev ) continue;\n\t\tdouble r2 = R(c[geo[x][i].to]-c[x]);\n\t\tdouble rr = fx(r2-r1);\n\t\tif( -1e-9 <= rr && rr <= PI + 1e-9 ){\n\t\t\tif( rr > bad ){\n\t\t\t\to = geo[x][i].to;\n\t\t\t\tbad = rr;\n\t\t\t\tid = geo[x][i].id;\n\t\t\t}\n\t\t}\n\t}\n\tif( o == -1 ) return 0;\n\t\n\tif( get(o,x,ad) ){\n\t\tad.push_back(id);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nint main(){\n\twhile(cin >> C >> W && C){\n\t\tfor(int i = 0 ; i < 100 ; i++) geo[i].clear();\n\t\tfor(int i = 0 ; i < C ; i++)\n\t\t\tcin >> c[i].real() >> c[i].imag();\n\t\tfor(int i = 0 ; i < W ; i++){\n\t\t\tint s,t;\n\t\t\tcin >> s >> t;\n\t\t\ts--,t--;\n\t\t\tgeo[s].push_back(NODE(s,t,i));\n\t\t\tgeo[t].push_back(NODE(t,s,i));\n\t\t\twsc[i] = s;\n\t\t\twtc[i] = t;\n\t\t\t\n\t\t}\n\t\t\n\t\tvector< vector<int> > wallset;\n\t\tfor(int _ = 0 ; _ < 2 ; _++){\n\t\t\tfor(int i = 0 ; i < W ; i++){\n\t\t\t\tstart = wsc[i];\n\t\t\t\tvector<int> a;\n\t\t\t\tif( get(wtc[i],wsc[i],a) ){\n\t\t\t\t\ta.push_back(i);\n\t\t\t\t\tsort(a.begin(),a.end());\n\t\t\t\t\twallset.push_back(a);\n\t\t\t\t}\n\t\t\t\tswap(wsc[i],wtc[i]);\n\t\t\t}\n\t\t}\n\t\tsort(wallset.begin(),wallset.end());\n\t\twallset.erase(unique(wallset.begin(),wallset.end()),wallset.end());\n\t\t\n\t\tint wf[101][101]={};\n\t\tfor(int i = 0 ; i < 101 ; i++)\n\t\t\tfor(int j = 0 ; j < 101 ; j++)\n\t\t\t\twf[i][j] = i==j?0:1e9;\n\t\tint N = wallset.size();\n\t\tvector<int> wall_share[300];\n\t\t\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\tfor(int j = 0 ; j < wallset[i].size() ; j++){\n\t\t\t\twall_share[wallset[i][j]].push_back(i);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0 ; i < W ; i++){\n\t\t\tif( wall_share[i].size() == 1 ){\n\t\t\t\twf[wall_share[i][0]][100] = wf[100][wall_share[i][0]] = 1;\n\t\t\t}else if( wall_share[i].size() == 2 ){\n\t\t\t\twf[wall_share[i][0]][wall_share[i][1]] = wf[wall_share[i][1]][wall_share[i][0]] = 1;\n\t\t\t}else{\n\t\t\t\twhile(1){cout << \"EEE\" << endl; }\n\t\t\t}\n\t\t}\n\t\twhile( wallset.size() > 100 );\n\t\tfor(int i = 0 ; i < 101 ; i++){\n\t\t\tfor(int j = 0 ; j < 101 ; j++){\n\t\t\t\tfor(int k = 0 ; k < 101 ; k++){\n\t\t\t\t\twf[j][k] = min(wf[j][k],wf[j][i]+wf[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\tans = max( ans , wf[i][100] );\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<int,pair<bool,double> > P2;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define min_3(a,b,c) min(a,min(b,c))\n#define max_3(a,b,c) max(a,max(b,c))\n#define mp1(a,b,c) P1(a,P(b,c))\n#define mp2(a,b,c) P2(a,pair<bool,double>(b,c))\n#define pque(a) priority_queue<a>\n#define rpque(a) priority_queue<a,vector<a>,greater<a>>\n\nconst int INF=1000000000;\nconst int dre_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dre_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\nconst int kaijou[10]={1,1,2,6,24,120,720,5040,40320,362880};\n\nbool com(P2 x,P2 y){\n\tif(x.sc.fr!=y.sc.fr)return x.sc.fr;\n\treturn x.sc.sc>=y.sc.sc;\n}\n\nint main(){\n\tint ppp=0;\n\twhile(1){\n\t\t//ppp++; if(ppp>=6)while(1){}\n\t\tstatic int v,w;\n\t\tstatic int x[310],y[310];\n\t\tstatic int s,t;\n\t\t\n\t\tscanf(\"%d%d\",&v,&w); if(v==0&&w==0)break;\n\t\trep1(i,v)scanf(\"%d%d\",&x[i],&y[i]);\n\t\t\n\t\tstatic vector<P1> V_; V_.clear();\n\t\trep1(i,v){\n\t\t\tV_.pb(mp1(x[i],y[i],i));\n\t\t}\n\t\tsor(V_);\n\t\tstatic vector<P2> vec_[310];\n\t\trep1(i,v){\n\t\t\tvec_[i].clear();\n\t\t\tvec_[i].pb(mp2(0,false,-INF));\n\t\t\trep1(j,v){\n\t\t\t\tif(i==j)continue;\n\t\t\t\tif(x[i]<x[j]){\n\t\t\t\t\tvec_[i].pb(mp2(j,true,(double)(y[j]-y[i])/(x[j]-x[i])));\n\t\t\t\t}\n\t\t\t\telse if(x[i]>x[j]){\n\t\t\t\t\tvec_[i].pb(mp2(j,false,(double)(y[j]-y[i])/(x[j]-x[i])));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(y[j]>y[i])vec_[i].pb(mp2(j,true,(double)INF));\n\t\t\t\t\telse vec_[i].pb(mp2(j,true,(double)-INF));\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(vec_[i].begin(),vec_[i].end(),com);\n\t\t}\n\t\t\n\t\tstatic int e;\n\t\tstatic vector<int> V; V.clear();\n\t\tstatic bool edge[310][310];\n\t\tstatic vector<int> vec[310]; \n\t\t\n\t\te=w;\n\t\trep(i,v)V.pb(V_[i].sc.sc);\n\t\trep(i,305)rep(j,305)edge[i][j]=false;\n\t\trep(i,e){\n\t\t\tscanf(\"%d%d\",&s,&t);\n\t\t\tedge[s][t]=true;\n\t\t\tedge[t][s]=true;\n\t\t}\n\t\trep1(i,v){\n\t\t\tvec[i].clear();\n\t\t\trep(j,vec_[i].size()){\n\t\t\t\tvec[i].pb(vec_[i][j].fr);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ret=0;\n\t\twhile(e>0){\n\t\t\tret++;\n\t\t\t\n\t\t\tint a=-1;\n\t\t\trep(i,V.size()){\n\t\t\t\trep(j,105){\n\t\t\t\t\tif(edge[V[i]][j]){a=V[i]; break;}\n\t\t\t\t}\n\t\t\t\tif(a!=-1)break;\n\t\t\t}\n\t\t\t\n\t\t\tint b=0,c=a;\n\t\t\twhile(1){\n\t\t\t\tif(c==-1||vec[c].size()==0)break;\n\t\t\t\trep(i,vec[c].size()){\n\t\t\t\t\tif(vec[c][i]==b){\n\t\t\t\t\t\ti++; i%=vec[c].size();\n\t\t\t\t\t\twhile(!edge[c][vec[c][i]]){\n\t\t\t\t\t\t\ti++; i%=vec[c].size();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tedge[c][vec[c][i]]=false;\n\t\t\t\t\t\tedge[vec[c][i]][c]=false;\n\t\t\t\t\t\te--;\n\t\t\t\t\t\tb=c;\n\t\t\t\t\t\tc=vec[c][i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(c==a)break;\n\t\t\t}\n\t\t\t\n\t\t\tbool updata=true;\n\t\t\twhile(updata){\n\t\t\t\tupdata=false;\n\t\t\t\trep1(i,v){\n\t\t\t\t\tint cnt=0;\n\t\t\t\t\tint t=105;\n\t\t\t\t\trep1(j,v){\n\t\t\t\t\t\tif(edge[i][j]){cnt++; t=j;}\n\t\t\t\t\t}\n\t\t\t\t\tif(cnt==1){\n\t\t\t\t\t\tupdata=true;\n\t\t\t\t\t\tedge[i][t]=false;\n\t\t\t\t\t\tedge[t][i]=false;\n\t\t\t\t\t\te--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <ctime>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <fstream>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <numeric>\n#include <cassert>\nusing namespace std;\n\ntypedef complex<double> P;\nconst double PI = acos(-1);\n\ndouble fx(double rd){\n\twhile( rd < -1e-9 )   rd += 2*PI;\n\twhile( rd >= 2*PI - 1e-9) rd -= 2*PI;\n\treturn rd;\n}\ndouble R(P a){\n\tdouble rd = atan2(a.imag(),a.real());\n\treturn fx(rd);\n}\n\nint C,W;\n\nint wsc[300] , wtc[300];\nP c[100];\nstruct NODE{\n\tint from,to,id;\n\tdouble rad;\n\tNODE(int from,int to,int id) : from(from) , to(to) , id(id) {\n\t\trad = R(c[to]-c[from]);\n\t}\n\tNODE(){}\n};\nbool operator < (const NODE &a,const NODE &b){\n\treturn a.rad < b.rad;\n}\nvector<NODE> geo[100];\nint done[100];\n\nint start;\nint get(int x,int prev,vector<int> &ad){\n\tif( x == start ) return 1;\n\tif( done[x] ) return 0;\n\telse done[x] = true;\n\t\n\tfor(int i = 0 ; i < geo[x].size() ; i++){\n\t\tint y = (i+1)%geo[x].size();\n\t\tif( geo[x][i].to == prev ){\t\t\t\n\t\t\tif( get(geo[x][y].to,x,ad) ){\n\t\t\t\t//ad.push_back(x);\n\t\t\t\tad.push_back(geo[x][y].id);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nnamespace std {bool operator < (const P& a, const P& b) {return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);} }\ndouble cross(const P& a, const P& b) {return imag(conj(a)*b);}\ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;\n\tif (cross(b, c) < 0)   return -1;\n\tif (dot(b, c) < 0) return +2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n// Totsuhou! Andrew's Monotone Chain //\nvector<P> convex_hull(vector<P> ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<P> ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);} };\nstatic const double EPS = 1e-9;\nbool intersectSP(const L &s, const P &p) {return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;}\n\ndouble intersect2SP(const L &s, const P &p) {\n\tcout << \"[\" << s[0] << \",\" << s[1] << \"]\" << \",\" << p << endl;\n\treturn abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]);\n}\n\n\nint main(){\n\twhile(cin >> C >> W && C){\n\t\tfor(int i = 0 ; i < 100 ; i++) geo[i].clear();\n\t\tfor(int i = 0 ; i < C ; i++)\n\t\t\tcin >> c[i].real() >> c[i].imag();\n\t\tfor(int i = 0 ; i < W ; i++){\n\t\t\tint s,t;\n\t\t\tcin >> s >> t;\n\t\t\ts--,t--;\n\t\t\tgeo[s].push_back(NODE(s,t,i));\n\t\t\tgeo[t].push_back(NODE(t,s,i));\n\t\t\twsc[i] = s;\n\t\t\twtc[i] = t;\n\t\t}\n\t\tfor(int i = 0 ; i < 100 ; i++) sort(geo[i].begin(),geo[i].end());\n\t\t\n\t\tvector< vector<int> > wallset;\n\t\tfor(int _ = 0 ; _ < 2 ; _++){\n\t\t\tfor(int i = 0 ; i < W ; i++){\n\t\t\t\tmemset(done,0,sizeof(done));\n\t\t\t\tstart = wsc[i];\n\t\t\t\tvector<int> a;\n\t\t\t\tif( get(wtc[i],wsc[i],a) ){\n\t\t\t\t\t//a.push_back(wsc[i]);\n\t\t\t\t\ta.push_back(i);\n\t\t\t\t\tsort(a.begin(),a.end());\n\t\t\t\t\twallset.push_back(a);\n\t\t\t\t}\n\t\t\t\tswap(wsc[i],wtc[i]);\n\t\t\t}\n\t\t}\n\t\tsort(wallset.begin(),wallset.end());\n\t\twallset.erase(unique(wallset.begin(),wallset.end()),wallset.end());\n\t\t\n\t\t\n\t\tint wf[301][301]={};\n\t\tfor(int i = 0 ; i < 301 ; i++)\n\t\t\tfor(int j = 0 ; j < 301 ; j++)\n\t\t\t\twf[i][j] = i==j?0:1e9;\n\t\tint N = wallset.size();\n\t\tvector<int> wall_share[300];\n\t\t\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\t//cout << \"[\" << i << \"]\" << endl;\n\t\t\tfor(int j = 0 ; j < wallset[i].size() ; j++){\n\t\t\t\twall_share[wallset[i][j]].push_back(i);\n\t\t\t//\tcout << c[wsc[wallset[i][j]]] << \"-\" << c[wtc[wallset[i][j]]] << \" \";\n\t\t\t}\n\t\t\t//cout << endl;\n\t\t}\n\t\tfor(int i = 0 ; i < W ; i++){\n\t\t\tfor(int j = 0 ; j <wall_share[i].size() ; j++){\n\t\t\t\tfor(int k = 0 ; k < wall_share[i].size() ; k++){\n\t\t\t\t\tif(j!=k)wf[wall_share[i][j]][wall_share[i][k]] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<P> p;\n\t\tfor(int i = 0 ; i < C ; i++) p.push_back(c[i]);\n\t\tp = convex_hull(p);\n\t\t//for(int i = 0 ; i < p.size() ; i++) cout << p[i] << \" \";\n\t\t//cout << endl;\n\t\tint soto = -1;\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\tint o = 1;\n\t\t\tfor(int j = 0 ; j < wallset[i].size() ; j++){\n\t\t\t\tint w = 0;\n\t\t\t\tfor(int k = 0 ; k < p.size() ; k++){\n\t\t\t\t\tif( intersectSP(L(p[k],p[(k+1)%p.size()]),c[wsc[wallset[i][j]]]) && intersectSP(L(p[k],p[(k+1)%p.size()]),c[wtc[wallset[i][j]]]) ){\n\t\t\t\t\t\t//cout << \"OK\" << endl;\n\t\t\t\t\t\tw = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!w){\n\t\t\t\t\to = 0;\n\t\t\t\t\t/*cout << \"----------\" << endl;\n\t\t\t\t\tcout << (intersectSP(L(P(2,0),P(8,0)),wsc[wall_share[i][j]]) ) << \" \" << (intersectSP(L(P(2,0),P(8,0)),wtc[wall_share[i][j]])) << endl;\n\t\t\t\t\tcout << (intersect2SP(L(P(2,0),P(8,0)),wsc[wall_share[i][j]]) ) << \" \" << (intersect2SP(L(P(2,0),P(8,0)),wtc[wall_share[i][j]])) << endl;\n\t\t\t\t\t\n\t\t\t\t\tcout << endl;\n\t\t\t\t\t*/\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(o) soto = i ;//, cout << soto << \"<\" << endl;\n\t\t}\n\t\twhile(soto==-1);\n\t\twhile(N>300);\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\tfor(int j = 0 ; j < N ; j++){\n\t\t\t\tfor(int k = 0 ; k < N ; k++){\n\t\t\t\t\twf[j][k] = min(wf[j][k],wf[j][i]+wf[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 1;\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\tans = max( ans , wf[i][soto] );\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <bitset>\n#include <cmath>\n#include <set>\n\n#define TIMES(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef bitset<22> Spec;\nconst double EPS = 1e-9;\n\nstruct Polygon {\n    Spec spec;\n    int id;\n\n    bool operator <(const Polygon &p) const {\n        return spec.to_string() < p.spec.to_string();\n    }\n\n    bool operator ==(const Polygon &p) const {\n        return spec == p.spec;\n    }\n};\n\nint cmp(double a, double b) {\n    const double diff = a-b;\n    if(fabs(diff) < EPS) return 0;\n    return diff < 0 ? -1 : 1;\n}\n\ndouble dot(const P &a, const P &b) {\n    return a.real()*b.real() + a.imag()*b.imag();\n}\n\ndouble cross(const P &a, const P &b) {\n    return a.real()*b.imag() - a.imag()*b.real();\n}\n\nPolygon get_polygon(int a, int b, const vector<P> &poles, const vector<vector<int>> &graph, const vector<vector<int>> &wall_id) {\n    Polygon polygon;\n    polygon.spec[wall_id[a][b]] = true;\n\n    const int start1 = b;\n    const int start2 = a;\n    //cout << b+1 << ' ' << a+1;\n    while(true) {\n        P prev = poles[a];\n        P prev_prev = poles[b];\n        const P vec = -(prev - prev_prev);\n        const double len = abs(vec);\n        int candidate = -1;\n        int cross_sgn = -1;\n        double dot_val = -2;\n        for(int i : graph[a]) {\n            if(i == b) continue;\n            const P vec2 = poles[i] - prev;\n            const double len2 = abs(vec2);\n            int sgn = cmp(cross(vec, vec2), 0);\n            double dv = dot(vec, vec2) / len / len2;\n            //cout << \": \" << i+1 << ' ' << sgn << ' ' << dv << endl;\n            if(sgn > cross_sgn \n                || (sgn == cross_sgn && cmp(dv, dot_val) > 0))\n            {\n                candidate = i;\n                cross_sgn = sgn;\n                dot_val = dv;\n            }\n        }\n        if(candidate == -1) break;\n        const int wid = wall_id[a][candidate];\n        //cout << ',' << candidate+1;\n        if(polygon.spec[wid]) {\n            if(a != start1 || candidate != start2) polygon = Polygon();\n            break;\n        }\n        polygon.spec[wid] = true;\n        b = a; a = candidate;\n    }\n    //cout << endl;\n    return polygon;\n}\n\nint solve_inner(const set<Polygon> &polygons) {\n    Spec outer_wall;\n    outer_wall.flip();\n    for(const Polygon &p1 : polygons) {\n        for(const Polygon &p2 : polygons) {\n            if(p1.id == p2.id) continue;\n            Spec s = p1.spec & p2.spec;\n            if(s.none()) continue;\n            outer_wall &= s.flip();\n        }\n    }\n    Spec seen = outer_wall;\n    TIMES(i, 300) {\n        Spec next = seen;\n        for(const Polygon &p : polygons) {\n            if((seen & p.spec).any()) {\n                next |= p.spec;\n            }\n        }\n        if(seen == next) return i+1;\n        seen = next;\n    }\n    return -1;\n}\n\nbool solve() {\n    int C, W;\n    cin >> C >> W;\n    if(!C && !W) return false;\n\n    vector<P> poles;\n    vector<vector<int>> graph(C);\n    vector<vector<int>> wall_id(C, vector<int>(C, -1));\n    TIMES(_, C) {\n        double x, y;\n        cin >> x >> y;\n        poles.push_back(P(x, y));\n    }\n    TIMES(i, W) {\n        int s, t;\n        cin >> s >> t;\n        --s; --t;\n        graph[s].push_back(t);\n        graph[t].push_back(s);\n        wall_id[s][t] = wall_id[t][s] = i;\n    }\n\n    set<Polygon> polygons;\n    // for each wall and direction\n    TIMES(i, C) {\n        for(int j : graph[i]) {\n            Polygon poly = get_polygon(i, j, poles, graph, wall_id);\n            if(poly.spec.any()) {\n                poly.id = polygons.size();\n                polygons.insert(poly);\n            }\n        }\n    }\n    /*\n    cout << polygons.size() << endl;\n    for(const Polygon &p : polygons) {\n        cout << p.spec << endl;\n    }\n    */\n\n    cout << solve_inner(polygons) << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<utility>\n#include<map>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n\nusing namespace std;\n\nstruct Point{\n\tint x,y;\n\tint id;\n\tPoint(){}\n\tPoint(int a,int b,int c):x(a),y(b),id(c){}\n};\n\nPoint points[110];\nint pid[110];\n\nbool cmp(const Point &p1,const Point &p2)\n{\n\tif(p1.x!=p2.x) return p1.x<p2.x;\n\treturn p1.y<p2.y;\n}\n\nint center;\n\nbool cmp_angle(const int &id1,const int &id2)\n{\n\tint center=pid[::center];\n\tint id1_=pid[id1],id2_=pid[id2];\n\tint dx1=points[id1_].x-points[center].x;\n\tint dy1=points[id1_].y-points[center].y;\n\tint dx2=points[id2_].x-points[center].x;\n\tint dy2=points[id2_].y-points[center].y;\n\t//(-y,x)\n\tdouble ang1=atan2(dx1,-dy1);\n\tdouble ang2=atan2(dx2,-dy2);\n\treturn ang1<ang2;\n}\n\nvector<int> G[110];\n\nvector<vector<int> > vs;\nvector<int> dG[750];\n\ntypedef pair<int,int> P;\n\nmap<P,int> cnt;\nqueue<P> que;\nint a;\nvoid init()\n{\n\tvs.clear();\n\tfor(int i=0;i<110;i++) G[i].clear();\n\tfor(int i=0;i<550;i++) dG[i].clear();\n\tcnt.clear();\n\ta=0;\n}\n\nvector<int> res;\nvoid stroke(int u,int v,int st)\n{\n\t//u->v\n\tP p=P(min(u,v),max(u,v));\n\tif(cnt[p]==0)\n\t{\n\t\tque.push(P(v,u));\n\t}\n\tcnt[p]++;\n\tif(v==st) return;\n\tif(u==st)\n\t{\n\t\ta++;\n\t\tres.push_back(u);\n\t}\n\tres.push_back(v);\n\ta++;\n\tcenter=v;\n\tint id=distance(G[v].begin(),lower_bound(G[v].begin(),G[v].end(),u,cmp_angle));\n\tif(id==G[v].size()-1) id=0;\n\telse id++;\n\tint nxt=G[v][id];\n\tstroke(v,nxt,st);\n}\n\nvoid getGraph(int W)\n{\n\tint n=0;\n\tint V=vs.size();\n\tfor(int i=0;i<V;i++) for(int j=i+1;j<V;j++)\n\t{\n\t\tint ni=vs[i].size(),nj=vs[j].size();\n\t\tbool flg=false;\n\t\tfor(int iid=0;iid<ni;iid++) for(int jid=0;jid<nj;jid++)\n\t\t{\n\t\t\tint niid=iid==ni-1?0:iid+1;\n\t\t\tint njid=jid==nj-1?0:jid+1;\n\t\t\tif(vs[i][iid]==vs[j][njid]&&vs[i][niid]==vs[j][jid])\n\t\t\t{\n\t\t\t\tflg=true;\n\t\t\t\tn++;\n\t\t\t}\n\t\t}\n\t\tif(flg)\n\t\t{\n\t\t\tdG[i].push_back(j);\n\t\t\tdG[j].push_back(i);\n\t\t}\n\t}\n}\n\nvector<int> outSide;\n\nint getMostOutSide()\n{\n\tint u=points[0].id;\n\tint v=G[u][0];\n\tfor(int i=0;i<vs.size();i++)\n\t{\n\t\tfor(int j=0;j+1<vs[i].size();j++)\n\t\t{\n\t\t\tif(vs[i][j]==u&&vs[i][j+1]==v) return i;\n\t\t}\n\t\tif(vs[i][vs[i].size()-1]==u&&vs[i][0]==v) return i;\n\t}\n\treturn -1;\n}\n\n\nint dis[750];\nqueue<int> bfs_que;\nvoid bfs(int s)\n{\n\twhile(!bfs_que.empty()) bfs_que.pop();\n\tbfs_que.push(s);\n\tfor(int i=0;i<750;i++) dis[i]=1<<29;\n\tdis[s]=0;\n\tbfs_que.push(s);\n\twhile(!bfs_que.empty())\n\t{\n\t\tint v=bfs_que.front();\n\t\tbfs_que.pop();\n\t\tfor(int i=0;i<dG[v].size();i++)\n\t\t{\n\t\t\tint u=dG[v][i];\n\t\t\tint nd=dis[v]+1;\n\t\t\tif(nd>=dis[u]) continue;\n\t\t\tdis[u]=nd;\n\t\t\tbfs_que.push(u);\n\t\t}\n\t}\n}\n\n\nint main()\n{\n\twhile(true)\n\t{\n\t\tint C,W;\n\t\tscanf(\"%d%d\",&C,&W);\n\t\tif(C==0) break;\n\t\tinit();\n\t\tfor(int i=0;i<C;i++)\n\t\t{\n\t\t\tint x,y;\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\tpoints[i]=Point(x,y,i);\n\t\t}\n\t\tsort(points,points+C,cmp);\n\t\tfor(int i=0;i<C;i++) pid[points[i].id]=i;\n\t\tint su=-1,sv=-1;\n\t\tfor(int i=0;i<W;i++)\n\t\t{\n\t\t\tint u,v;\n\t\t\tscanf(\"%d%d\",&u,&v);\n\t\t\tu--;v--;\n\t\t\tG[u].push_back(v);\n\t\t\tG[v].push_back(u);\n\t\t\tsu=u,sv=v;\n\t\t}\n\t\tfor(int i=0;i<C;i++)\n\t\t{\n\t\t\tcenter=i;\n\t\t\tsort(G[i].begin(),G[i].end(),cmp_angle);\n\t\t}\n\t\tque.push(P(min(su,sv),max(su,sv)));\n\t\twhile(!que.empty())\n\t\t{\n\t\t\tP p=que.front();\n\t\t\tque.pop();\n\t\t\tint u=p.first,v=p.second;\n\t\t\tP pp=P(min(u,v),max(u,v));\n\t\t\tif(cnt[pp]==2) continue;\n\t\t\tres.clear();\n\t\t\tstroke(u,v,u);\n\t\t\tvs.push_back(res);\n\t\t}\n\t\tif(a<2*W) for(;;);\n\t\t//if(cnt.size()<W) for(;;);\n\t\tgetGraph(W);\n\t\tint out=getMostOutSide();\n\t\tbfs(out);\n\t\tint ans=0;\n\t\tfor(int i=0;i<vs.size();i++) ans=max(ans,dis[i]);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define M_PI (3.141592653589793)\n\nusing namespace std;\n\nconst double EPS = 1e-10;\n\nclass Point{\npublic:\n    double x, y;\n    int id;\n    Point(double x = 0, double y = 0): x(x), y(y){}\n    Point operator + (Point p){return Point(x + p.x, y + p.y);}\n    Point operator - (Point p){return Point(x - p.x, y - p.y);}\n    Point operator * (double a){return Point(x * a, y * a);}\n    Point operator / (double a){return Point(x / a, y / a);}\n    Point operator * (const Point &a){\n        return Point(x * a.x - y * a.y, x * a.y + y * a.x);\n    }\n    bool operator < (const Point &p) const {\n        return (x != p.x ? x < p.x : y < p.y);\n    }\n    bool operator == (const Point &p) const {\n        return (fabs(x - p.x) < EPS && fabs(y - p.y) < EPS);\n    }\n};\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\ndouble dot(Vector a, Vector b){ return (a.x * b.x + a.y * b.y);}\ndouble norm(Vector a){ return (dot(a, a));}\ndouble abs(Vector a){ return (sqrt(norm(a)));}\ndouble cross(Vector a, Vector b){ return (a.x * b.y - a.y * b.x);}\n\nint ccw(Point p0, Point p1, Point p2)\n{\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if (cross(a, b) > EPS) return (+1); //p0, p1, p2 が反時計周り\n    if (cross(a, b) < -EPS) return (-1);//p0, p1, p2 が時計回り\n    if (dot(a, b) < -EPS) return (+2); //p2--p0--p1 の順で一直線上\n    if (norm(a) < norm(b)) return (-2); //p0--p1--p2 の順で一直線上\n    \n    return (0); //p0--p2--p1 の順で一直線上\n}\n\nPolygon conhel(Polygon& ps)\n{\n    sort(ps.begin(), ps.end());\n    int k = 0, n = (int)ps.size();\n    Polygon qs(n * 2);\n    \n    for (int i = 0; i < n; i++){\n        while (k > 1 && cross(qs[k - 1] - qs[k - 2], ps[i] - qs[k - 1]) < -EPS) k--;\n        qs[k++] = ps[i];\n    }\n    \n    for (int i = n - 2, t = k; i >= 0; i--){\n        while (k > t && cross(qs[k - 1] - qs[k - 2], ps[i] - qs[k - 1]) < -EPS) k--;\n        qs[k++] = ps[i];\n    }\n    \n    qs.resize(k - 1);\n    return (qs);\n}\n\ndouble getCos(Vector a, Vector b)\n{\n    return (dot(a, b) / (abs(a) * abs(b)));\n}\n\ndouble getArg(Vector v)\n{\n    return (atan2(v.y, v.x));\n}\n \nPoint rotate(Point t, Point p, double r)\n{\n    double ta = cos(r) * (t.x - p.x) - sin(r) * (t.y - p.y) + p.x;\n    double tb = sin(r) * (t.x - p.x) + cos(r) * (t.y - p.y) + p.y;\n    return (Point(ta, tb));\n}\n \nint main()\n{\n    int N, M;\n    \n    while (scanf(\"%d %d\", &N, &M) && N){\n        vector<Point> P(N);\n        vector<int> to[128];\n        bool exist[128][128] = {0};\n        \n        for (int i = 0; i < N; i++){\n            scanf(\"%lf %lf\", &P[i].x, &P[i].y);\n            P[i].id = i;\n        }\n        \n        for (int i = 0; i < M; i++){\n            int x, y;\n            scanf(\"%d %d\", &x, &y);\n            to[--x].push_back(--y);\n            to[y].push_back(x);\n            exist[x][y] = exist[y][x] = 1;\n        }\n        \n        Polygon Q = P;\n        Q = conhel(Q);\n        \n        vector<int> belong[128][128];\n        for (int i = 0; i < Q.size(); i++){\n            int u = Q[i].id, v = Q[(i + 1) % Q.size()].id;\n            belong[u][v].push_back(0);\n            belong[v][u].push_back(0);\n        }\n        int k = 1;\n        set<vector<int> > s;\n        \n        for (int i = 0; i < N; i++){\n            for (int j = 0; j < N; j++){\n                if (P[j] < P[i] && exist[i][j] && belong[i][j].size() < 2){\n                    vector<int> v;\n                    v.push_back(i);\n                    v.push_back(j);\n                    \n                    while (1){\n                        int nextP = -1;\n                        int vv = v[v.size() - 1], uu = v[v.size() - 2];\n                        for (int l = 0; l < to[vv].size(); l++){\n                            if (to[vv][l] == vv || to[vv][l] == uu) continue;\n                            double thetaT, thetaC;\n                            thetaT = acos(getCos(P[uu] - P[vv], P[to[vv][l]] - P[vv]));\n                            if (ccw(P[uu], P[vv], P[to[vv][l]]) > 0) thetaT = 2 * M_PI - thetaT;\n                            if (nextP != -1){\n                                thetaC = acos(getCos(P[uu] - P[vv], P[nextP] - P[vv]));\n                                if (ccw(P[uu], P[vv], P[nextP]) > 0) thetaC = 2 * M_PI - thetaC;\n                            }\n                            if (nextP == -1 || thetaT < thetaC) nextP = to[vv][l];\n                            \n                        }\n                        if (nextP == i) break;\n                        v.push_back(nextP);\n                    }\n                    vector<int> ss = v;\n                    sort(ss.begin(), ss.end());\n                    ss.erase(unique(ss.begin(), ss.end()), ss.end());\n                    if (s.find(ss) != s.end()) continue;\n                    else s.insert(ss);\n                    for (int it = 0; it < v.size(); it++){\n                        int uu = v[it], vv = v[(it + 1) % v.size()];\n                        belong[uu][vv].push_back(k);\n                        belong[vv][uu].push_back(k);\n                    }\n                    k++;\n                }\n            }\n        }\n        \n        vector<int> G[1024];\n        \n        for (int i = 0; i < N; i++){\n            for (int j = i + 1; j < N; j++){\n                if (belong[i][j].size()){\n                    assert(belong[i][j].size() == 2);\n                    int u = belong[i][j][0], v = belong[i][j][1];\n                    G[u].push_back(v);\n                    G[v].push_back(u);\n                }\n            }\n        }\n        \n        int ans = 0;\n        int done[1024];\n        fill(done, done + 1024, -1);\n        queue<pair<int, int> > q;\n        \n        for(q.push(make_pair(0, 0)); q.size(); q.pop()){\n            pair<int, int> x = q.front();\n            if (~done[x.first]) continue;\n            done[x.first] = x.second;\n            ans = max(ans, x.second);\n            \n            for (int i = 0; i < G[x.first].size(); i++){\n                q.push(make_pair(G[x.first][i], x.second + 1));\n            }\n        }\n        \n        printf(\"%d\\n\", ans);\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<int,pair<bool,double>> P2;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define min_3(a,b,c) min(a,min(b,c))\n#define max_3(a,b,c) max(a,max(b,c))\n#define mp1(a,b,c) P1(a,P(b,c))\n#define mp2(a,b,c) P2(a,pair<bool,double>(b,c))\n#define pque(a) priority_queue<a>\n#define rpque(a) priority_queue<a,vector<a>,greater<a>>\n\nconst int INF=1000000000;\nconst int dre_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dre_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\nconst int kaijou[10]={1,1,2,6,24,120,720,5040,40320,362880};\n\nbool com(P2 x,P2 y){\n\tif(x.sc.fr!=y.sc.fr)return x.sc.fr;\n\treturn x.sc.sc>=y.sc.sc;\n}\n\nint main(){\n\twhile(1){\n\t\tint c,w;\n\t\tint x[110],y[110];\n\t\tint s,t;\n\t\t\n\t\tscanf(\"%d%d\",&c,&w); if(c==0&&w==0)break;\n\t\trep1(i,c)scanf(\"%d%d\",&x[i],&y[i]);\n\t\t\n\t\tvector<P1> V_;\n\t\trep1(i,c){\n\t\t\tV_.pb(mp1(x[i],y[i],i));\n\t\t}\n\t\tsor(V_);\n\t\tvector<P2> vec_[110];\n\t\trep1(i,c){\n\t\t\tvec_[i].pb(mp2(0,false,-INF));\n\t\t\trep1(j,c){\n\t\t\t\tif(i==j)continue;\n\t\t\t\tif(x[i]<x[j]){\n\t\t\t\t\tvec_[i].pb(mp2(j,true,(double)(y[j]-y[i])/(x[j]-x[i])));\n\t\t\t\t}\n\t\t\t\telse if(x[i]>x[j]){\n\t\t\t\t\tvec_[i].pb(mp2(j,false,(double)(y[j]-y[i])/(x[j]-x[i])));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(y[j]>y[i])vec_[i].pb(mp2(j,true,(double)INF));\n\t\t\t\t\telse vec_[i].pb(mp2(j,true,(double)-INF));\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(vec_[i].begin(),vec_[i].end(),com);\n\t\t}\n\t\t\n\t\tint v,e;\n\t\tvector<int> V;\n\t\tbool edge[110][110];\n\t\tvector<int> vec[110];\n\t\t\n\t\tv=c; e=w;\n\t\trep(i,c)V.pb(V_[i].sc.sc);\n\t\trep(i,110)rep(j,110)edge[i][j]=false;\n\t\trep(i,e){\n\t\t\tscanf(\"%d%d\",&s,&t);\n\t\t\tedge[s][t]=true;\n\t\t\tedge[t][s]=true;\n\t\t}\n\t\trep1(i,c){\n\t\t\trep(j,vec_[i].size()){\n\t\t\t\tvec[i].pb(vec_[i][j].fr);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ret=0;\n\t\twhile(e>0){\n\t\t\tret++;\n\t\t\t\n\t\t\tint a=-1;\n\t\t\trep(i,V.size()){\n\t\t\t\trep(j,105){\n\t\t\t\t\tif(edge[V[i]][j]){a=V[i]; break;}\n\t\t\t\t}\n\t\t\t\tif(a!=-1)break;\n\t\t\t}\n\t\t\t\n\t\t\tint b=0,c=a;\n\t\t\twhile(1){\n\t\t\t\tif(c==-1||vec[c].size()==0)break;\n\t\t\t\trep(i,vec[c].size()){\n\t\t\t\t\tif(vec[c][i]==b){\n\t\t\t\t\t\ti++; i%=vec[c].size();\n\t\t\t\t\t\twhile(!edge[c][vec[c][i]]){\n\t\t\t\t\t\t\ti++; i%=vec[c].size();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tedge[c][vec[c][i]]=false;\n\t\t\t\t\t\tedge[vec[c][i]][c]=false;\n\t\t\t\t\t\te--;\n\t\t\t\t\t\tb=c;\n\t\t\t\t\t\tc=vec[c][i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(c==a)break;\n\t\t\t}\n\t\t\t\n\t\t\tbool updata=true;\n\t\t\twhile(updata){\n\t\t\t\tupdata=false;\n\t\t\t\trep(i,105){\n\t\t\t\t\tint cnt=0;\n\t\t\t\t\tint t=105;\n\t\t\t\t\trep(j,105){\n\t\t\t\t\t\tif(edge[i][j]){cnt++; t=j;}\n\t\t\t\t\t}\n\t\t\t\t\tif(cnt==1){\n\t\t\t\t\t\tupdata=true;\n\t\t\t\t\t\tedge[i][t]=false;\n\t\t\t\t\t\tedge[t][i]=false;\n\t\t\t\t\t\te--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<int,pair<bool,double> > P2;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define min_3(a,b,c) min(a,min(b,c))\n#define max_3(a,b,c) max(a,max(b,c))\n#define mp1(a,b,c) P1(a,P(b,c))\n#define mp2(a,b,c) P2(a,pair<bool,double>(b,c))\n#define pque(a) priority_queue<a>\n#define rpque(a) priority_queue<a,vector<a>,greater<a>>\n\nconst int INF=1000000000;\nconst int dre_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dre_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\nconst int kaijou[10]={1,1,2,6,24,120,720,5040,40320,362880};\n\nbool com(P2 x,P2 y){\n\tif(x.sc.fr!=y.sc.fr)return x.sc.fr;\n\treturn x.sc.sc>=y.sc.sc;\n}\n\nint main(){\n\twhile(1){\n\t\tstatic int v,w;\n\t\tstatic int x[110],y[110];\n\t\tstatic int s,t;\n\t\t\n\t\tscanf(\"%d%d\",&v,&w); if(v==0&&w==0)break;\n\t\trep1(i,v)scanf(\"%d%d\",&x[i],&y[i]);\n\t\t\n\t\tstatic vector<P1> V_; V_.clear();\n\t\trep1(i,v){\n\t\t\tV_.pb(mp1(x[i],y[i],i));\n\t\t}\n\t\tsor(V_);\n\t\tstatic vector<P2> vec_[110];\n\t\trep1(i,v){\n\t\t\tvec_[i].clear();\n\t\t\tvec_[i].pb(mp2(0,false,-INF));\n\t\t\trep1(j,v){\n\t\t\t\tif(i==j)continue;\n\t\t\t\tif(x[i]<x[j]){\n\t\t\t\t\tvec_[i].pb(mp2(j,true,(double)(y[j]-y[i])/(x[j]-x[i])));\n\t\t\t\t}\n\t\t\t\telse if(x[i]>x[j]){\n\t\t\t\t\tvec_[i].pb(mp2(j,false,(double)(y[j]-y[i])/(x[j]-x[i])));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(y[j]>y[i])vec_[i].pb(mp2(j,true,(double)INF));\n\t\t\t\t\telse vec_[i].pb(mp2(j,true,(double)-INF));\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(vec_[i].begin(),vec_[i].end(),com);\n\t\t}\n\t\t\n\t\tstatic int e;\n\t\tstatic vector<int> V; V.clear();\n\t\tstatic bool edge[110][110];\n\t\tstatic vector<int> vec[110]; \n\t\t\n\t\te=w;\n\t\trep(i,v)V.pb(V_[i].sc.sc);\n\t\trep(i,110)rep(j,110)edge[i][j]=false;\n\t\trep(i,e){\n\t\t\tscanf(\"%d%d\",&s,&t);\n\t\t\tedge[s][t]=true;\n\t\t\tedge[t][s]=true;\n\t\t}\n\t\trep1(i,v){\n\t\t\tvec[i].clear();\n\t\t\trep(j,vec_[i].size()){\n\t\t\t\tvec[i].pb(vec_[i][j].fr);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ret=0;\n\t\twhile(e>0){\n\t\t\tret++;\n\t\t\t\n\t\t\tint a=-1;\n\t\t\trep(i,V.size()){\n\t\t\t\trep(j,105){\n\t\t\t\t\tif(edge[V[i]][j]){a=V[i]; break;}\n\t\t\t\t}\n\t\t\t\tif(a!=-1)break;\n\t\t\t}\n\t\t\t\n\t\t\tint b=0,c=a;\n\t\t\twhile(1){\n\t\t\t\tif(c==-1||vec[c].size()==0)break;\n\t\t\t\trep(i,vec[c].size()){\n\t\t\t\t\tif(vec[c][i]==b){\n\t\t\t\t\t\ti++; i%=vec[c].size();\n\t\t\t\t\t\twhile(!edge[c][vec[c][i]]){\n\t\t\t\t\t\t\ti++; i%=vec[c].size();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tedge[c][vec[c][i]]=false;\n\t\t\t\t\t\tedge[vec[c][i]][c]=false;\n\t\t\t\t\t\te--;\n\t\t\t\t\t\tb=c;\n\t\t\t\t\t\tc=vec[c][i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(c==a)break;\n\t\t\t}\n\t\t\t\n\t\t\tbool updata=true;\n\t\t\twhile(updata){\n\t\t\t\tupdata=false;\n\t\t\t\trep1(i,v){\n\t\t\t\t\tint cnt=0;\n\t\t\t\t\tint t=105;\n\t\t\t\t\trep1(j,v){\n\t\t\t\t\t\tif(edge[i][j]){cnt++; t=j;}\n\t\t\t\t\t}\n\t\t\t\t\tif(cnt==1){\n\t\t\t\t\t\tupdata=true;\n\t\t\t\t\t\tedge[i][t]=false;\n\t\t\t\t\t\tedge[t][i]=false;\n\t\t\t\t\t\te--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<complex>\n#include<vector>\nusing namespace std;\ndouble eps=1e-7;\ndouble x[110];\ndouble y[110];\ndouble px[700];\ndouble py[700];\nint ijk[700];\nint v[700];\nint g[700][700];\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ndouble PI=3.14159265358;\ntypedef complex<double> P;\ntypedef vector<P> G;\n\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nP pt[700];\nP ps[300];\nint s[400];\nint t[400];\ndouble left[400];\ndouble right[400];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<a;i++)scanf(\"%lf%lf\",x+i,y+i);\n\t\tfor(int i=0;i<a;i++){\n\t\t\tdouble X=cos(1)*x[i]-sin(1)*y[i];\n\t\t\tdouble Y=sin(1)*x[i]+cos(1)*y[i];\n\t\t\tx[i]=X;\n\t\t\ty[i]=Y;\n\t\t\tps[i]=P(x[i],y[i]);\n\t\t\t\n\t\t}\n\t\tfor(int i=0;i<b;i++){\n\t\t\tint p,q;scanf(\"%d%d\",&p,&q);\n\t\t\tp--;q--;\n\t\t\ts[i]=p;t[i]=q;\n\t\t\tpx[i*2]=(x[p]+x[q])/2+eps;\n\t\t\tpy[i*2]=(y[p]+y[q])/2;\n\t\t\tpx[i*2+1]=(x[p]+x[q])/2-eps;\n\t\t\tpy[i*2+1]=(y[p]+y[q])/2;\n\t\t\tpt[i*2]=P(px[i*2],py[i*2]);\n\t\t\tpt[i*2+1]=P(px[i*2+1],py[i*2+1]);\n\t\t}\n\t\t\n\t\tpriority_queue<pair<int,int> >Q;\n\t\tfor(int i=0;i<b*2;i++){\n\t\t\tijk[i]=999999999;\n\t\t\tv[i]=0;\n\t\t\tbool OK=true;\n\t\t\tint tt=s[i/2];\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tif(tt==s[j]||tt==t[j])continue;\n\t\t\t\tif(intersectSS(L(ps[tt],ps[tt]+(pt[i]-ps[tt])*10000.0),L(ps[s[j]],ps[t[j]]))){\n\t\t\t\t\tOK=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(OK){\n\t\t//\t\tprintf(\" %d\\n\",i);\n\t\t\t\tijk[i]=0;\n\t\t\t\tQ.push(make_pair(0,i));\n\t\t\t}\n\t\t\tfor(int j=0;j<b*2;j++){\n\t\t\t\tif(i==j){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint cnt=0;\n\t\t\t\tfor(int k=0;k<b;k++){\n\t\t\t\t\tif(intersectSS(L(ps[s[k]],ps[t[k]]),L(pt[i],pt[j]))){\n\t\t//\t\t\t\tprintf(\"(%f,%f) (%f,%f): (%f,%f), (%f,%f)\\n\",px[i],py[i],px[j],py[j],x[s[k]],y[s[k]],x[t[k]],y[t[k]]);\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tif(cnt>1)break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(cnt<2)g[i][j]=cnt;\n\t\t\t\telse g[i][j]=999999999;\n\t\t\t}\n\t\t}\n\t\twhile(Q.size()){\n\t\t\tint cost=-Q.top().first;\n\t\t\tint at=Q.top().second;Q.pop();\n\t\t\tif(v[at])continue;\n\t\t\tv[at]=1;\n\t\t\tfor(int i=0;i<b*2;i++){\n\t\t\t\tif(!v[i]&&ijk[i]>cost+g[at][i]){\n\t\t\t\t\tijk[i]=cost+g[at][i];\n\t\t\t\t\tQ.push(make_pair(-ijk[i],i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret=0;\n\t\tfor(int i=0;i<b*2;i++)ret=max(ret,ijk[i]);\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <bitset>\n#include <cmath>\n#include <algorithm>\n\n#define TIMES(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef bitset<600> Spec;\nconst double EPS = 1e-9;\nconst double PI = acos(-1);\n\ndouble normalize(double angle) {\n    if(angle < 0) return angle + 2*PI;\n    return angle;\n}\n\nint cmp(double a, double b) {\n    const double diff = a-b;\n    if(fabs(diff) < EPS) return 0;\n    return diff < 0 ? -1 : 1;\n}\n\ndouble dot(const P &a, const P &b) {\n    return a.real()*b.real() + a.imag()*b.imag();\n}\n\ndouble cross(const P &a, const P &b) {\n    return a.real()*b.imag() - a.imag()*b.real();\n}\n\nint root(int n, vector<int> &roots) {\n    if(roots[n] == n) return n;\n    return roots[n] = root(roots[n], roots);\n}\n\nbool unite(int a, int b, vector<int> &roots) {\n    const int ra = root(a, roots);\n    const int rb = root(b, roots);\n    if(ra == rb) return false;\n    roots[ra] = rb;\n    return true;\n}\n\nbool solve() {\n    int C, W;\n    cin >> C >> W;\n    if(!C && !W) return false;\n\n    vector<P> poles;\n    vector<vector<int>> graph(C);\n    vector<vector<int>> wall_id(C, vector<int>(C));\n    TIMES(_, C) {\n        double x, y;\n        cin >> x >> y;\n        poles.push_back(P(x, y));\n    }\n    TIMES(i, W) {\n        int s, t;\n        cin >> s >> t;\n        --s; --t;\n        graph[s].push_back(t);\n        graph[t].push_back(s);\n        wall_id[s][t] = i*2;\n        wall_id[t][s] = i*2+1;\n    }\n\n    vector<int> roots(W*2);\n    TIMES(i, W*2) {\n        roots[i] = i;\n    }\n    TIMES(i, C) {\n        const P &pi = poles[i];\n        for(int j : graph[i]) {\n            const P &pj = poles[j];\n            const P vec = pj - pi;\n            const double len = abs(vec);\n            int candidate = -1;\n            int sin_sgn = -2;\n            double cos_val = 2;\n            for(int k : graph[j]) {\n                if(k == i) continue;\n                const P vec2 = poles[k] - pj;\n                const int sgn = cmp(cross(vec2, vec), 0);\n                const double cv = dot(vec2, vec) / len / abs(vec2);\n                if(sgn > sin_sgn\n                    || (sgn == sin_sgn && cv < cos_val))\n                {\n                    candidate = k;\n                    sin_sgn = sgn;\n                    cos_val = cv;\n                }\n            }\n            if(candidate != -1) {\n                if(unite(wall_id[i][j], wall_id[j][candidate], roots)) {\n                    //cout << \"unitea \" << i << \" \" << j << \" \" << candidate << endl;\n                }\n            }\n        }\n    }\n    // Determine outside region\n    const int rightmost = distance(poles.begin(),\n            max_element(poles.begin(), poles.end(), [](const P &a, const P &b) {\n                return a.real() < b.real();\n                }));\n    const int rm_next = *min_element(\n            graph[rightmost].begin(), \n            graph[rightmost].end(),\n            [&poles, rightmost](int a, int b) {\n            const double arga = normalize(arg(poles[a] - poles[rightmost]));\n            const double argb = normalize(arg(poles[b] - poles[rightmost]));\n            return arga < argb;\n            });\n    int out_id = root(wall_id[rm_next][rightmost], roots);\n\n    Spec init;\n    vector<Spec> areas(W*2);\n    TIMES(i, W*2) {\n        const int area = root(i, roots);\n        areas[area][i/2] = true;\n        if(area == out_id) init[i/2] = true;\n        //cout << area << ' ';\n    }\n    //cout << endl;\n    Spec cur = init;\n    int turn = 1;\n    while(true) {\n        Spec next = cur;\n        for(const Spec &spec : areas) {\n            if((spec & cur).any()) {\n                next |= spec;\n            }\n        }\n        if(next == cur) break;\n        cur = next;\n        ++turn;\n    }\n    cout << turn << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<int,int> state;\n\nint N,M;\nP t[100];\nint f[100][100];\nint d[100][100];\n\nbool check(int from,int to){\n  P base=t[to]-t[from];\n  for(int i=0;i<N;i++){\n    P target=t[i]-t[from];\n    if(imag(target*conj(base))<0)\n      return false;\n  }\n  return true;\n}\n\nvoid init(){\n  memset(f,0,sizeof(f));\n  memset(d,1,sizeof(d));\n}\n\nint solve(){\n  /*\n  int si=0,ti;\n  double mini=1e9;\n  for(int i=0;i<N;i++)\n    if(t[i].real()<t[si].real())si=i;\n  \n  for(int i=0;i<N;i++)\n    if(f[si][i] && arg(t[i]-t[si])< mini)\n      ti=i,mini=arg(t[i]-t[si]);\n      Q.push_back(state(si,ti));\n  */\n  \n  deque<state> Q;  \n\n  d[si][ti]=0;\n\n  for(int i=0;i<N;i++){\n    for(int j=0;j<N;j++){\n      if(f[i][j]&&check(i,j)){\n        d[i][j]=0;\n        Q.push_front(state(i,j));\n      }\n    }\n  }\n   \n  int ans=0;\n  while(!Q.empty()){\n    state p=Q.front();\n    Q.pop_front();\n    int from=p.first;\n    int to=p.second;\n    ans=d[from][to];\n    \n    if(d[from][to]+1<d[to][from]){\n      d[to][from]=d[from][to]+1;\n      Q.push_back(state(to,from));\n    }\n    int id=-1;\n    double mini=1e9;\n    for(int i=0;i<N;i++){\n      if(f[to][i]&&i!=from){\n        if( arg( (t[i]-t[to])*conj(t[to]-t[from]) ) < mini){\n          id=i;\n          mini=arg( (t[i]-t[to])*conj(t[to]-t[from]) );\n        }\n      }\n    }\n    if(id!=-1&&d[to][id]>d[from][to]){\n      d[to][id]=d[from][to];\n      Q.push_front(state(to,id));\n    }\n  }\n  return ans;\n}\n\nint main(){\n  while(1){\n    cin>>N>>M;\n    if(N==0&&M==0)break;\n    init();\n    for(int i=0;i<N;i++){\n      int x,y;\n      cin>>x>>y;\n      t[i]=P(x,y);\n    }\n    for(int i=0;i<M;i++){\n      int x,y;\n      cin>>x>>y;\n      x--,y--;\n      f[x][y]=f[y][x]=true;\n    }\n    cout<<solve()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <cmath>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\n#define x first\n#define y second\n\ntypedef pair<int,int> pii;\n\nint C, W;\nvector<pii> pole;\nvector<vector<int> > edge;\nvector<pii> edge_set;\n\nvector<vector<int> > face;\nvector<vector<int> > dual_e;\nvector<pii> dual_edge_set;\n\nvector<int> detect_f(int start, int cur, int prev) {\n\tvector<int> res;\n\tif(cur == start) {\n\t\tres.push_back(cur);\n\t\treturn res;\n\t}\n\n\tint bx, by, cx, cy;\n\tdouble mn = 10.0;\n\tint nx = -1;\n\tbx = pole[prev].x;\n\tby = pole[prev].y;\n\tcx = pole[cur].x;\n\tcy = pole[cur].y;\n\tfor(int i = 0; i < edge[cur].size(); i++) {\n\t\tif(edge[cur][i] != prev) {\n\t\t\tdouble theta, phi, ag;\n\t\t\tint ax, ay;\n\t\t\tax = pole[edge[cur][i]].x;\n\t\t\tay = pole[edge[cur][i]].y;\n\t\t\ttheta = atan2(by - cy, bx - cx);\n\t\t\tphi   = atan2(ay - cy, ax - cx);\n\t\t\tag = theta - phi + 4*M_PI;\n\t\t\twhile(ag > 2*M_PI) ag -= 2*M_PI;\n\t\t\tif(ag < mn) {\n\t\t\t\tnx = edge[cur][i];\n\t\t\t\tmn = ag;\n\t\t\t}\n\t\t}\n\t}\n\n\tres = detect_f(start, nx, cur);\n\tres.push_back(cur);\n\treturn res;\n}\n\nint face_indx(vector<int> f) {\n\tfor(int i = 0; i < face.size(); i++) {\n\t\tif(face[i].size() == f.size()) for(int j = 0; j < face[i].size(); j++) {\n\t\t\tbool flg = true;\n\t\t\tfor(int k = 0; k < face[i].size() && flg; k++) {\n\t\t\t\tflg &= face[i][(j+k)%face[i].size()] == f[k];\n\t\t\t}\n\t\t\tif(flg) return i;\n\t\t}\n\t}\n\treturn -1;\n}\n\nvoid mkdual() {\n\tfor(int i = 0; i < edge_set.size(); i++) {\n\t\tpii de, e = edge_set[i];\n\t\tfor(int i_ = 0; i_ < 2; i_++) {\n\t\t\tvector<int> f = detect_f(e.first, e.second, e.first);\n\t\t\tint indx;\n\t\t\tindx = face_indx(f);\n\t\t\tif(indx < 0) {\n\t\t\t\tindx = face.size();\n\t\t\t\tface.push_back(f);\n\t\t\t}\n\t\t\tde.first = indx;\n\t\t\tswap(e.first, e.second);\n\t\t\tswap(de.first, de.second);\n\t\t}\n\t\tdual_edge_set.push_back(de);\n\t}\n\tdual_e.resize(face.size());\n\tsort(dual_edge_set.begin(), dual_edge_set.end());\n\tdual_edge_set.erase(unique(dual_edge_set.begin(), dual_edge_set.end()), dual_edge_set.end());\n\tfor(int i = 0; i < dual_edge_set.size(); i++) {\n\t\tdual_e[dual_edge_set[i].first].push_back(dual_edge_set[i].second);\n\t\tdual_e[dual_edge_set[i].second].push_back(dual_edge_set[i].first);\n\t}\n}\n\nint solve() {\n\tint ur = 0;\n\tfor(int i = 0; i < pole.size(); i++) {\n\t\tif(pole[ur] < pole[i])\n\t\t\tur = i;\n\t}\n\tint nx = -1;\n\tdouble mn_arg = 100;\n\tfor(int i = 0; i < edge[ur].size(); i++) {\n\t\tdouble arg;\n\t\targ = atan2(pole[edge[ur][i]].y - pole[ur].y,\n\t\t\t\tpole[edge[ur][i]].x - pole[ur].x) + 4 * M_PI;\n\t\twhile(arg > 2 * M_PI) arg -= 2 * M_PI;\n\t\t\n\t\tif(arg < mn_arg) {\n\t\t\tmn_arg = arg;\n\t\t\tnx = edge[ur][i];\n\t\t}\n\t}\n\tint start;\n\tvector<int> mnpath;\n\tpriority_queue<pii> q;\n\tconst int INF = 1e9;\n\tstart = face_indx(detect_f(ur, nx, ur));\n\tmnpath.resize(face.size());\n\tfor(int i = 0; i < mnpath.size(); i++) mnpath[i] = INF;\n\tq.push(pii(0,start));\n\twhile(!q.empty()) {\n\t\tpii a = q.top(); q.pop();\n\t\tif(mnpath[a.second] > -a.first) {\n\t\t\tmnpath[a.second] = -a.first;\n\t\t}\n\t\tfor(int i = 0; i < dual_e[a.second].size(); i++) {\n\t\t\tif(mnpath[dual_e[a.second][i]] > -a.first + 1) {\n\t\t\t\tmnpath[dual_e[a.second][i]] = -a.first + 1;\n\t\t\t\tq.push(pii(a.first -1, dual_e[a.second][i]));\n\t\t\t}\n\t\t}\n\t}\n\tint res = -1;\n\tfor(int i = 0; i < mnpath.size(); i++) {\n\t\tres = max(res, mnpath[i]);\n\t}\n\treturn res;\n}\n\nint main() {\n\twhile(cin >> C >> W, C || W) {\n\t\tpole.clear();\n\t\tedge.clear();\n\t\tedge_set.clear();\n\t\tface.clear();\n\t\tdual_edge_set.clear();\n\t\tdual_e.clear();\n\t\tpole.resize(C);\n\t\tedge.resize(C);\n\t\tfor(int i = 0; i < pole.size(); i++) {\n\t\t\tcin >> pole[i].x >> pole[i].y;\n\t\t}\n\t\tfor(int i = 0; i < W; i++) {\n\t\t\tint a, b;\n\t\t\tcin >> a >> b; a--; b--;\n\t\t\tedge_set.push_back(pii(a,b));\n\t\t\tedge[a].push_back(b);\n\t\t\tedge[b].push_back(a);\n\t\t}\n\t\tmkdual();\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<queue>\n#include<algorithm>\n#include<cassert>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\ntemplate<class T> T at(vector<T> v, int i) {return v[i % v.size()];}\n\n#define X real()\n#define Y imag()\n\ntypedef long double D;\ntypedef complex<D> P;\nstruct L{P a, b;};\ntypedef vector<P> Pol;\n\n\nconst D EPS = 1e-8;\nconst D PI = acos(-1);\n\nint sig(D a, D b = 0) {return a < b - EPS ? -1 : a > b + EPS ? 1 : 0;}\nbool near(P a, P b) {return !sig(norm(a - b));}\nnamespace std {\n  bool operator<(P a, P b) {return sig(a.X, b.X) ? a.X < b.X : a.Y < b.Y;}\n  bool operator<(L a, L b) {return !near(a.a, b.a) ? a.a < b.a : a.b < b.b;}\n}\n\nP vec(L a) {return a.b - a.a;}\n\nD det(P a, P b) {return a.X * b.Y - a.Y * b.X;}\n\nenum CCW{FRONT = 1, RIGHT = 2, BACK = 4, LEFT = 8, ON = 16};\nint ccw(P a, P b, P c) {\n  if (near(a, c) || near(b, c)) return ON;\n  int s = sig(det(b - a, c - a));\n  if (s) return s > 0 ? LEFT : RIGHT;\n  return (a < b) == (b < c) ? FRONT : (c < a) == (a < b) ? BACK : ON;\n}\n\nD arg(P base, P a, P b) {return arg((b - base) / (a - base));}\n\nbool iLLs(L a, L b) {return sig(det(vec(a), vec(b)));}\nbool iSS(L a, L b) {\n  int cwa = ccw(a.a, a.b, b.a) | ccw(a.a, a.b, b.b);\n  int cwb = ccw(b.a, b.b, a.a) | ccw(b.a, b.b, a.b);\n  return ((cwa | cwb) & ON) || ((cwa & cwb) == (LEFT | RIGHT));\n}\n\nP pLL(L a, L b) {return a.a + vec(a) * (det(vec(b), b.a - a.a) / det(vec(b), vec(a)));}\n\nD aPol(Pol vp) {D ret = 0; rep (i, vp.size()) ret += det(vp[i], at(vp, i + 1)); return ret / 2;}\n\nint sGP(Pol pol, P p) {\n  int side = -1;\n  rep (i, pol.size()) {\n    P p0 = pol[i] - p, p1 = at(pol, i + 1) - p;\n    if (ccw(p0, p1, 0) == ON) return 0;\n    if (p0.Y > p1.Y) swap(p0, p1);\n    if (sig(p0.Y) <= 0 && 0 < sig(p1.Y) && sig(det(p0, p1)) > 0) side *= -1;\n  }\n  return side;\n}\n\nvector<L> merge(vector<L> s) {\n  rep (i, s.size()) if (s[i].b < s[i].a) swap(s[i].a, s[i].b);\n  sort(s.begin(), s.end());\n  rep (i, s.size()) rep (j, i) if (iSS(s[i], s[j]) && !iLLs(s[i], s[j])) {\n    s[j].b = max(s[i].b, s[j].b);\n    s.erase(s.begin() + i--);\n    break;\n  }\n  return s;\n}\n\nvector<vector<int> > sArr(vector<L> s, vector<P> &vp) {\n  s = merge(s);\n  rep (i, s.size()) {\n    vp.push_back(s[i].a);\n    vp.push_back(s[i].b);\n  }\n  rep (i, s.size()) rep (j, i) if (iSS(s[i], s[j])) vp.push_back(pLL(s[i], s[j]));\n  sort(vp.begin(), vp.end());\n  vp.erase(unique(vp.begin(), vp.end(), near), vp.end());\n  vector<vector<int> > g(vp.size());\n  rep (i, s.size()) {\n    vector<pair<D, int> > v;\n    rep (j, vp.size()) if (ccw(s[i].a, s[i].b, vp[j]) == ON) {\n      v.push_back(make_pair(norm(vp[j] - s[i].a), j));\n    }\n    sort(v.begin(), v.end());\n    rep (j, v.size() - 1) {\n      g[v[j + 1].second].push_back(v[j].second);\n      g[v[j].second].push_back(v[j + 1].second);\n    }\n  }\n  return g;\n}\n\nvector<Pol> dual(vector<L> s) {\n  vector<P> vp;\n  vector<vector<int> > edge = sArr(s, vp);\n  vector<vector<bool> > used(edge.size());\n  rep (i, edge.size()) rep (j, edge[i].size()) used[i].push_back(false);\n  vector<Pol> vpol;\n  rep (i, edge.size()) rep (j, edge[i].size()) if (!used[i][j]) {\n    Pol pol;\n    pol.push_back(vp[i]);\n    used[i][j] = true;\n    int pre = i, now = edge[i][j];\n    while (now != i) {\n      pol.push_back(vp[now]);\n      D a = -4;\n      int next = -1;\n      rep (k, edge[now].size()) {\n\tD aa = arg(vp[now], (D)2 * vp[now] - vp[pre], vp[edge[now][k]]);\n\tif (!sig(aa, PI)) aa = -PI;\n\tif (a < aa) {\n\t  a = aa;\n\t  next = k;\n\t}\n      }\n      used[now][next] = true;\n      pre = now;\n      now = edge[pre][next];\n    }\n    vpol.push_back(pol);\n  }\n  return vpol;\n}\n\nint main() {\n  while (true) {\n    int c, w;\n    cin >> c >> w;\n    if (c == 0 && w == 0) break;\n    vector<P> vp;\n    rep (i, c) {\n      D x, y;\n      cin >> x >> y;\n      vp.push_back(P(x, y));\n    }\n    vector<L> vl;\n    rep (i, w) {\n      int s, t;\n      cin >> s >> t;\n      --s, --t;\n      vl.push_back((L){vp[s], vp[t]});\n    }\n    vector<Pol> d = dual(vl);\n    vector<int> sd;\n    rep (i, d.size()) sd.push_back(sig(aPol(d[i])));\n    vector<pair<int, int> > g[d.size()];\n    rep (i, d.size()) rep (j, i) {\n      bool ok = false;\n      rep (ii, d[i].size()) rep (jj, d[j].size()) if (near(d[i][ii], at(d[j], jj + 1)) && near(at(d[i], ii + 1), d[j][jj])) ok = true;\n      if (ok) {\n\tg[i].push_back(make_pair(j, 1));\n\tg[j].push_back(make_pair(i, 1));\n      }\n    }\n    int start = -1;\n    rep (i, d.size()) if (sd[i] < 0) start = i;\n    priority_queue<pair<int, int>,vector<pair<int, int> >, greater<pair<int, int> > > que;\n    int dis[d.size()];\n    rep (i, d.size()) dis[i] = 1e9;\n    que.push(make_pair(0, start));\n    while (!que.empty()) {\n      pair<int, int> now = que.top();\n      que.pop();\n      if (dis[now.second] <= now.first) continue;\n      dis[now.second] = now.first;\n      rep (i, g[now.second].size()) que.push(make_pair(now.first + g[now.second][i].second, g[now.second][i].first));\n    }\n    int ans = 0;\n    rep (i, d.size()) ans = max(ans, dis[i]);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<int,pair<bool,double> > P2;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define min_3(a,b,c) min(a,min(b,c))\n#define max_3(a,b,c) max(a,max(b,c))\n#define mp1(a,b,c) P1(a,P(b,c))\n#define mp2(a,b,c) P2(a,pair<bool,double>(b,c))\n#define pque(a) priority_queue<a>\n#define rpque(a) priority_queue<a,vector<a>,greater<a>>\n\nconst int INF=1000000000;\nconst int dre_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dre_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\nconst int kaijou[10]={1,1,2,6,24,120,720,5040,40320,362880};\n\nbool com(P2 x,P2 y){\n\tif(x.sc.fr!=y.sc.fr)return x.sc.fr;\n\treturn x.sc.sc>=y.sc.sc;\n}\n\nint main(){\n\tstatic int v,w;\n\tstatic int x[310],y[310];\n\tstatic int s,t;\n\tstatic vector<P1> V_;\n\tstatic vector<P2> vec_[310];\n\tstatic int e;\n\tstatic vector<int> V; \n\tstatic bool edge[310][310];\n\tstatic vector<int> vec[310]; \n\tint ppp=0;\n\twhile(1){\n\t\tscanf(\"%d%d\",&v,&w); if(v==0&&w==0)break;\n\t\trep1(i,v)scanf(\"%d%d\",&x[i],&y[i]);\n\t\t\n\t\tV_.clear();\n\t\trep1(i,v){\n\t\t\tV_.pb(mp1(x[i],y[i],i));\n\t\t}\n\t\tsor(V_);\n\t\trep1(i,v){\n\t\t\tvec_[i].clear();\n\t\t\tvec_[i].pb(mp2(0,false,-INF));\n\t\t\trep1(j,v){\n\t\t\t\tif(i==j)continue;\n\t\t\t\tif(x[i]<x[j]){\n\t\t\t\t\tvec_[i].pb(mp2(j,true,(double)(y[j]-y[i])/(x[j]-x[i])));\n\t\t\t\t}\n\t\t\t\telse if(x[i]>x[j]){\n\t\t\t\t\tvec_[i].pb(mp2(j,false,(double)(y[j]-y[i])/(x[j]-x[i])));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(y[j]>y[i])vec_[i].pb(mp2(j,true,(double)INF));\n\t\t\t\t\telse vec_[i].pb(mp2(j,true,(double)-INF));\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(vec_[i].begin(),vec_[i].end(),com);\n\t\t}\n\t\t\n\t\tV.clear();\n\t\t\n\t\te=w;\n\t\trep(i,v)V.pb(V_[i].sc.sc);\n\t\trep(i,305)rep(j,305)edge[i][j]=false;\n\t\trep(i,e){\n\t\t\tscanf(\"%d%d\",&s,&t);\n\t\t\tedge[s][t]=true;\n\t\t\tedge[t][s]=true;\n\t\t}\n\t\trep1(i,v){\n\t\t\tvec[i].clear();\n\t\t\trep(j,vec_[i].size()){\n\t\t\t\tvec[i].pb(vec_[i][j].fr);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ret=0;\n\t\twhile(e>0){\n\t\t\tret++;\n\t\t\t\n\t\t\tint a=-1;\n\t\t\trep(i,V.size()){\n\t\t\t\trep(j,105){\n\t\t\t\t\tif(edge[V[i]][j]){a=V[i]; break;}\n\t\t\t\t}\n\t\t\t\tif(a!=-1)break;\n\t\t\t}\n\t\t\t\n\t\t\tint b=0,c=a;\n\t\t\twhile(1){\n\t\t\t\tif(c==-1||vec[c].size()==0)break;\n\t\t\t\trep(i,vec[c].size()){\n\t\t\t\t\tif(vec[c][i]==b){\n\t\t\t\t\t\ti++; i%=vec[c].size();\n\t\t\t\t\t\twhile(!edge[c][vec[c][i]]){\n\t\t\t\t\t\t\ti++; i%=vec[c].size();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tedge[c][vec[c][i]]=false;\n\t\t\t\t\t\tedge[vec[c][i]][c]=false;\n\t\t\t\t\t\te--;\n\t\t\t\t\t\tb=c;\n\t\t\t\t\t\tc=vec[c][i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(c==a)break;\n\t\t\t}\n\t\t\t\n\t\t\tbool updata=true;\n\t\t\twhile(updata){\n\t\t\t\tupdata=false;\n\t\t\t\trep1(i,v){\n\t\t\t\t\tint cnt=0;\n\t\t\t\t\tint t=105;\n\t\t\t\t\trep1(j,v){\n\t\t\t\t\t\tif(edge[i][j]){cnt++; t=j;}\n\t\t\t\t\t}\n\t\t\t\t\tif(cnt==1){\n\t\t\t\t\t\tupdata=true;\n\t\t\t\t\t\tedge[i][t]=false;\n\t\t\t\t\t\tedge[t][i]=false;\n\t\t\t\t\t\te--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\",ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <queue>\n#include <cstdio>\n#include <cassert>\n#include <algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst double EPS=1e-8;\nconst double PI=acos(-1);\n\nstruct point{\n\tdouble x,y;\n\tpoint():x(0),y(0){}\n\tpoint(double x,double y):x(x),y(y){}\n\tpoint &operator+=(const point &a){ x+=a.x; y+=a.y; return *this; }\n\tpoint &operator-=(const point &a){ x-=a.x; y-=a.y; return *this; }\n\tpoint &operator*=(double c){ x*=c; y*=c; return *this; }\n\tpoint &operator/=(double c){ x/=c; y/=c; return *this; }\n\tpoint operator+(const point &a)const{ return point(x+a.x,y+a.y); }\n\tpoint operator-(const point &a)const{ return point(x-a.x,y-a.y); }\n\tpoint operator/(double c)const{ return point(x/c,y/c); }\n\tpoint operator-()const{ return point(-x,-y); }\n\tbool operator< (const point &a)const{ return x+EPS<a.x || (abs(x-a.x)<EPS && y+EPS<a.y); }\n\tbool operator==(const point &a)const{ return abs(x-a.x)<EPS && abs(y-a.y)<EPS; }\n\tbool operator!=(const point &a)const{ return abs(x-a.x)>EPS || abs(y-a.y)>EPS; }\n};\n\ndouble cross(const point &a,const point &b){ return a.x*b.y-a.y*b.x; }\n\ndouble arg(const point &a){ double t=atan2(a.y,a.x); return t<0?t+2*PI:t; }\n\ntypedef vector<point> polygon;\n\nbool is_ccw(const polygon &F){\n\tint n=F.size();\n\tdouble A=0;\n\trep(i,n) A+=cross(F[i],F[(i+1)%n]);\n\treturn A>-EPS;\n}\n\n// trace the frame of a polygon\nvector<int> trace(int n,const vector<int> *G,int u0,int i0){\n\tvector<int> F;\n\tint u=u0,i=i0;\n\tdo{\n\t\tF.push_back(u);\n\t\tint v=G[u][i];\n\t\tint k=G[v].size();\n\t\trep(j,k) if(G[v][j]==u) i=(j-1+k)%k;\n\t\tu=v;\n\t}while(u!=u0);\n\treturn F;\n}\n\n// normalize the list of vertices\nvector<int> reg(vector<int> a){\n\tint k=min_element(a.begin(),a.end())-a.begin();\n\trep(i,k){\n\t\ta.push_back(a[0]);\n\t\ta.erase(a.begin());\n\t}\n\treturn a;\n}\n\nint main(){\n\tfor(int n,m;scanf(\"%d%d\",&n,&m),n;){\n\t\tpoint P[100];\n\t\trep(u,n) scanf(\"%lf%lf\",&P[u].x,&P[u].y);\n\n\t\tvector<int> G[100];\n\t\trep(i,m){\n\t\t\tint u,v; scanf(\"%d%d\",&u,&v); u--; v--;\n\t\t\tG[u].push_back(v);\n\t\t\tG[v].push_back(u);\n\t\t}\n\n\t\t// angle sort\n\t\trep(u,n){\n\t\t\tint k=G[u].size();\n\t\t\tpair<double,int> A[100];\n\t\t\trep(i,k){\n\t\t\t\tint v=G[u][i];\n\t\t\t\tA[i]=make_pair(arg(P[v]-P[u]),v);\n\t\t\t}\n\t\t\tsort(A,A+k);\n\t\t\trep(i,k) G[u][i]=A[i].second;\n\t\t}\n\n\t\t// decompose to polygons\n\t\tvector< vector<int> > F; // set of polygons\n\t\trep(u,n) rep(i,G[u].size()) F.push_back(reg(trace(n,G,u,i)));\n\t\tsort(F.begin(),F.end());\n\t\tF.erase(unique(F.begin(),F.end()),F.end());\n\n\t\t// find the outside boundary\n\t\tint n2=F.size(),u0=-1;\n\t\trep(u,n2){\n\t\t\tint k=F[u].size();\n\t\t\tpolygon H(k);\n\t\t\trep(i,k) H[i]=P[F[u][i]];\n\t\t\tif(!is_ccw(H)){\nif(u0!=-1) for(;;);\n\t\t\t\tassert(u0==-1);\n\t\t\t\tu0=u;\n\t\t\t}\n\t\t}\nif(u0==-1) for(;;);\n\t\tassert(u0!=-1);\n\n\t\t// build the dual graph\n\t\tvector<int> G2[100];\n\t\trep(u,n2) rep(v,u) {\n\t\t\tbool ok=false;\n\t\t\tint nu=F[u].size(),nv=F[v].size();\n\t\t\trep(i,nu) rep(j,nv) if(F[u][i]==F[v][(j+1)%nv] && F[u][(i+1)%nu]==F[v][j]) ok=true;\n\t\t\tif(ok){\n\t\t\t\tG2[u].push_back(v);\n\t\t\t\tG2[v].push_back(u);\n\t\t\t}\n\t\t}\n\n\t\t// BFS\n\t\tint d[100];\n\t\trep(u,n2) d[u]=(u==u0?0:-1);\n\t\tqueue<int> Q;\n\t\tQ.push(u0);\n\t\twhile(!Q.empty()){\n\t\t\tint u=Q.front(); Q.pop();\n\t\t\trep(i,G2[u].size()){\n\t\t\t\tint v=G2[u][i];\n\t\t\t\tif(d[v]==-1) d[v]=d[u]+1, Q.push(v);\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",*max_element(d,d+n2));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <unordered_map>\n#include <iterator>\n#include <assert.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nnamespace geom{\n#define X real()\n#define Y imag()\n#define at(i) ((*this)[i])\n#define SELF (*this)\n\tenum {TRUE = 1, FALSE = 0, BORDER = -1};\n\ttypedef int BOOL;\n\ttypedef double R;\n\tconst R INF = 1e8;\n\tconst R EPS = 1e-12;\n\tconst R PI = 3.1415926535897932384626;\n\tinline int sig(const R &x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n\tinline BOOL less(const R &x, const R &y) {return sig(x-y) ? x < y : BORDER;}\n\ttypedef complex<R> P;\n\tinline R norm(const P &p){return p.X*p.X+p.Y*p.Y;}\n\tinline R inp(const P& a, const P& b){return (conj(a)*b).X;}\n\tinline R outp(const P& a, const P& b){return (conj(a)*b).Y;}\n\tinline P unit(const P& p){return p/abs(p);}\n\tinline P proj(const P &s, const P &t){return t*inp(s, t)/norm(t);}\n\tinline int ccw(const P &s, const P &t, const P &p, int adv=0){\n\t\tint res = sig(outp(t-s, p-s));\n\t\tif(res || !adv) return res;\n\t\tif(sig(inp(t-s, p-s)) < 0) return -2;\t// p-s-t\n\t\tif(sig(inp(s-t, p-t)) < 0) return 2;\t// s-t-p\n\t\treturn 0;\t\t\t\t\t\t\t\t// s-p-t\n\t}\n\t\n\t\n\tstruct L : public vector<P>{\t// line\n\t\tL(const P &p1, const P &p2){this->push_back(p1);this->push_back(p2);}\n\t\tL(){}\n\t\tP dir()const {return at(1) - at(0);}\n\t\tBOOL online(const P &p)const {return !sig(outp(p-at(0), dir()));}\n\t};\n\tstruct S : public L{\t// segment\n\t\tS(const P &p1, const P &p2):L(p1, p2){}\n\t\tS(){}\n\t\tBOOL online(const P &p)const {\n\t\t\tif(!sig(norm(p - at(0))) || !sig(norm(p - at(1)))) return BORDER;\n\t\t\treturn !sig(abs(at(0)-p) + abs(at(1) - p) - abs(at(0) - at(1)));\n\t\t}\n\t};\n\tstruct C : public P{\n\t\tR r;\n\t\tBOOL inside(const P& p)const { return less(norm(p-SELF), r*r);}\n\t};\n\tP crosspoint(const L &l, const L &m);\n\tstruct G : public vector<P>{\n\t\tG(size_type size=0):vector(size){}\n\t\tS edge(int i)const {return S(at(i), at(i+1 == size() ? 0 : i+1));}\n\t\tBOOL contains(const P &p)const {\n\t\t\tR sum = .0;\n\t\t\tREP(i, size()){\n\t\t\t\tif(S(at(i), at((i+1)%size())).online(p)) return BORDER;\t// online\n\t\t\t\tsum += arg((at(i) - p) / (at((i+1)%size()) - p));\n\t\t\t}\n\t\t\treturn !!sig(sum);\n\t\t}\n\t\tR area()const {\n\t\t\tR sum = 0;\n\t\t\tREP(i, size()) sum += outp(at(i), at((i+1)%size()));\n\t\t\treturn abs(sum / 2.);\n\t\t}\n\t\t\n\t\tG convex_hull(bool online = false) {\n\t\t\tif(size() < 2) return *this;\n\t\t\tsort(ALL(*this));\n\t\t\tG r;\n\t\t\tr.resize((int)size()*2);\n\t\t\tint k=0;\n\t\t\tfor(int i=0;i<size();r[k++]=at(i++))\n\t\t\t\twhile(k>1 && ccw(r[k-2], r[k-1], at(i)) < 1-online) k--;\n\t\t\tint t = k;\n\t\t\tfor(int i=(int)size()-1;i>=0;r[k++]=at(i--))\n\t\t\t\twhile(k>t && ccw(r[k-2], r[k-1], at(i)) < 1-online) k--;\n\t\t\tr.resize(k-1);\n\t\t\treturn r;\n\t\t}\n\t\tG cut(const L &l)const {\n\t\t\tG g;\n\t\t\tREP(i, size()){\n\t\t\t\tconst S &s = edge(i);\n\t\t\t\tif(ccw(l[0], l[1], s[0], 0) >= 0) g.push_back(s[0]);\n\t\t\t\tif(ccw(l[0], l[1], s[0], 0) * ccw(l[0], l[1], s[1], 0) < 0)\n\t\t\t\t\tg.push_back(crosspoint(s, l));\n\t\t\t}\n\t\t\treturn g;\n\t\t}\n\t\tG Voronoi(const vector<P> &p, const int t)const {\n\t\t\tG g = *this;\n\t\t\tREP(i, p.size())if(i!=t){\n\t\t\t\tconst P m = (p[t]+p[i])*0.5;\n\t\t\t\tg = g.cut(L(m, m+(p[i]-p[t])*P(0, 1)));\n\t\t\t}\n\t\t\treturn g;\n\t\t}\n\t};\n\n\tinline P proj(const P &s, const L &t){return t[0] + proj(s-t[0], t[1]-t[0]);}\n\tBOOL intersect(const S &s, const S &t){\n\t\tconst int p = ccw(t[0], t[1], s[0], 1) * ccw(t[0], t[1], s[1], 1);\n\t\tconst int q = ccw(s[0], s[1], t[0], 1) * ccw(s[0], s[1], t[1], 1);\n\t\treturn (p>0||q>0) ? FALSE : (!p||!q) ? BORDER : TRUE;\n\t}\n\tBOOL intersect(const S &s, const L &l){\n\t\tif(l.online(s[0]) || l.online(s[1])) return BORDER;\n\t\treturn (sig(outp(l.dir(), s[0]-l[0])) * sig(outp(l.dir(), s[1]-l[0])) <= 0);\n\t}\n\tR dist2(const L &l, const P &p){return norm(outp(l.dir(), p - l[0])) / norm(l.dir());}\n\tR dist2(const S &s, const P &p){\n\t\tif(inp(p-s[0],  s.dir()) < EPS) return norm(p - s[0]);\n\t\tif(inp(p-s[1], -s.dir()) < EPS) return norm(p - s[1]);\n\t\treturn dist2((const L &)s, p);\n\t}\n\tR dist2(const S &s, const L &l){\n\t\treturn intersect(s, l) ? .0 : min(dist2(l, s[0]), dist2(l, s[1]));\n\t}\n\tR dist2(const S &s, const S &t){\n\t\treturn intersect(s, t) ? .0 : min(min(dist2(s, t[0]), dist2(t, s[0])), \n\t\t\t\t\t\t\t\t\t   \t  min(dist2(s, t[1]), dist2(t, s[1])));\n\t}\n\ttemplate <class T> R dist2(const G &g, const T& t){ // todo: 内部に完全に含まれる場合\n\t\tR res = INF;\n\t\tREP(i, g.size()) res = min(res, dist2(g.edge(i), t));\n\t\treturn res;\n\t}\n\ttemplate<class S, class T> R dist(const S& s, const T& t){return sqrt(dist2(s, t));}\n\tinline BOOL intersect(const C &a, const C &b){\n\t\treturn less((a.r-b.r)*(a.r-b.r), norm(a-b)) + less(norm(a-b), (a.r+b.r)*(a.r+b.r)) - 1;\n\t}\n\tinline BOOL intersect(const C &c, const L &l){\n\t\treturn less(dist2(l, c), c.r*c.r);\n\t}\n\tinline BOOL intersect(const C &c, const S &s){\n\t\tint d = less(dist2(s, c), c.r*c.r);\n\t\tif(d != TRUE) return d;\n\t\tint p = c.inside(s[0]), q = c.inside(s[1]);\n\t\treturn (p<0 || q<0) ? BORDER : p&q;\n\t}\n\tinline S crosspoint(const C &c1, const C &c2){\n\t\tif(!intersect(c1, c2)) return S();\n\t\tR d = abs(c1 - c2);\n\t\tR x = (c1.r*c1.r - c2.r*c2.r + d*d) / (2*d);\n\t\tR h = sqrt(c1.r*c1.r - x*x);\n\t\tP u = unit(c2-c1);\n\t\treturn S(c1 + u*x + u*P(0,1)*h, c1 + u*x + u*P(0,-1)*h);\n\t}\n\tinline P crosspoint(const L &l, const L &m){\n\t\tR A = outp(l.dir(), m.dir()), B = outp(l.dir(), l[1] - m[0]);\n\t\tif(!sig(abs(A)) && !sig(abs(B))) return m[0]; // same line\n\t\tif(abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n\t\treturn m[0] + B / A * (m[1] - m[0]);\n\t}\n\tinline R commonarea(const C &a, const C &b){\n\t\tif(less(norm(a-b), (a.r-b.r)*(a.r-b.r)) == TRUE) return min(a.r*a.r, b.r*b.r)*PI;\n\t\tif(less((a.r+b.r)*(a.r+b.r), norm(a-b)) == TRUE) return .0;\n\t\tdouble d = abs(a-b);\n\t\tdouble rc = (d*d + a.r*a.r - b.r*b.r) / (2*d);\n\t\tdouble theta = acos(rc / a.r);\n\t\tdouble phi = acos((d - rc) / b.r);\n\t\treturn a.r*a.r*theta + b.r*b.r*phi - d*a.r*sin(theta);\n\t}\n\tstruct Arrangement{\n\t\tstruct AEdge{\n\t\t\tint u, v, t;\n\t\t\tR cost;\n\t\t\tAEdge(int u=0, int v=0, int t=0, R cost=0)\n\t\t\t\t:u(u), v(v), t(t), cost(cost){}\n\t\t};\n\t\ttypedef vector<vector<AEdge>> AGraph;\n\t\tvector<P> p;\n\t\tAGraph g;\n\t\tArrangement(){}\n\t\tArrangement(vector<S> seg){\n\t\t\tint m = seg.size();\n\t\t\tREP(i, m){\n\t\t\t\tp.push_back(seg[i][0]);\n\t\t\t\tp.push_back(seg[i][1]);\n\t\t\t\tREP(j, i) if(sig(outp(seg[i].dir(), seg[j].dir())) && intersect(seg[i], seg[j]) == TRUE)\n\t\t\t\t\tp.push_back(crosspoint(seg[i], seg[j]));\n\t\t\t}\n\t\t\tsort(ALL(p)); UNIQUE(p);\n\t\t\tint n=p.size();\n\t\t\tg.resize(n);\n\t\t\tREP(i, m){\n\t\t\t\tS &s = seg[i];\n\t\t\t\tvector<pair<R, int>> ps;\n\t\t\t\tREP(j, n) if(s.online(p[j])) ps.emplace_back(norm(p[j] - s[0]), j);\n\t\t\t\tsort(ALL(ps));\n\t\t\t\tREP(j, (int)ps.size()-1){\n\t\t\t\t\tconst int u=ps[j].second;\n\t\t\t\t\tconst int v=ps[j+1].second;\n\t\t\t\t\tg[u].emplace_back(u, v, 0, abs(p[u] - p[v]));\n\t\t\t\t\tg[v].emplace_back(v, u, 0, abs(p[u] - p[v]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint getIdx(P q){\n\t\t\tauto it = lower_bound(ALL(p), q);\n\t\t\tif(it == p.end() || *it != q) return -1;\n\t\t\treturn it - p.begin();\n\t\t}\n\t};\n\n\tstruct min_ball {\n\t\tP center;\n\t\tR radius2;\n\t\tmin_ball(const vector<P>& p) {\n\t\t\tFOR(it, p) ps.push_back(*it);\n\t\t}\n\t\tmin_ball& compile() {\n\t\t\tm = 0;\n\t\t\tcenter = P(0, 0);\n\t\t\tradius2 = -1;\n\t\t\tmake_ball(ps.end());\n\t\t\treturn *this;\n\t\t}\n\tprivate:\n\t\tlist<P> ps;\n\t\tlist<P>::iterator supp_end;\n\t\tint m;\n\t\tP v[3], c[3];\n\t\tR z[3], r[3];\n\t\tvoid pop() { --m; }\n\t\tvoid push(const P& p) {\n\t\t\tif (m == 0) {\n\t\t\t\tc[0] = p; r[0] = 0;\n\t\t\t} else {\n\t\t\t\tR e = norm(p-c[m-1]) - r[m-1];\n\t\t\t\tP delta = p - c[0];\n\t\t\t\tv[m] = p - c[0];\n\t\t\t\tfor (int i = 1; i < m; ++i)\n\t\t\t\t\tv[m] -= v[i] * inp(v[i], delta) / z[i];\n\t\t\t\tz[m] = inp(v[m], v[m]);\n\t\t\t\tc[m] = c[m-1] + e*v[m]/z[m]*.5;\n\t\t\t\tr[m] = r[m-1] + e*e/z[m]*.25;\n\t\t\t}\n\t\t\tcenter\t= c[m];\n\t\t\tradius2 = r[m]; ++m;\n\t\t}\n\t\tvoid make_ball(list<P>::iterator i) {\n\t\t\tsupp_end = ps.begin();\n\t\t\tif (m == 3) return;\n\t\t\tfor (list<P>::iterator k = ps.begin(); k != i; ) {\n\t\t\t\tlist<P>::iterator j = k++;\n\t\t\t\tif (norm(*j-center) > radius2) {\n\t\t\t\t\tpush(*j); make_ball(j); pop();\n\t\t\t\t\tmove_to_front(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvoid move_to_front(list<P>::iterator j) {\n\t\t\tif (supp_end == j) ++supp_end;\n\t\t\tps.splice (ps.begin(), ps, j);\n\t\t}\n\t};\n\t\n\tstruct DualGraph{\n\t\tstruct DEdge{\n\t\t\tint u, v, f, l;\n\t\t\tR a;\n\t\t\tDEdge(int u, int v, R a):u(u),v(v),f(0),l(0){\n\t\t\t\twhile(PI < a) a -= 2*PI;\n\t\t\t\twhile(a < -PI) a += 2*PI;\n\t\t\t\tthis->a = a;\n\t\t\t}\n\t\t\tbool operator<(const DEdge &opp) const{\n\t\t\t\treturn a>opp.a;\n\t\t\t}\n\t\t\tbool operator<(const R &opp) const{\n\t\t\t\treturn a>opp;\n\t\t\t}\n\t\t\tfriend ostream& operator<<(ostream &os, const DEdge &t) { return os<<\"(\"<<t.u<<\",\"<<t.v<<\",\"<<t.a*180/PI<<\")\";}\n\t\t};\n\t\t\n\t\tint n;\n\t\tvector<P> p;\n\t\tvector<vector<DEdge>> g;\n\t\tDualGraph(const vector<P> &p):p(p),g(p.size()),n(p.size()){}\n\t\tvoid add_edge(int s, int t){\n\t\t\tR a = arg(p[t]-p[s]);\n\t\t\tg[s].emplace_back(s, t, a);\n\t\t\tg[t].emplace_back(t, s, a+PI);\n\t\t}\n\t\tvector<G> poly;\n\t\t\n\t\tvoid add_polygon(int s, int t, R a){\n\t\t\tauto e = lower_bound(ALL(g[s]), a-EPS);\n\t\t\tif(e == g[s].end()) e = g[s].begin();\n\t\t\tif(e->f) return;\n\t\t\te->f = 1;\n\t\t\te->l = t;\n\t\t\tpoly[t].push_back(p[s]);\n\t\t\tadd_polygon(e->v, t, e->a > 0 ? e->a-PI : e->a+PI);\n\t\t}\n\t\t\n\t\tvector<vi> dual(){\n\t\t\tREP(i, n){\n\t\t\t\tsort(ALL(g[i]));\n\t\t\t}\n\t\t\tint s = min_element(ALL(p)) - p.begin();\n\t\t\tpoly.emplace_back();\n\t\t\tadd_polygon(s, poly.size()-1, -PI*.5);\n\t\t\tREP(i, n)REP(j, g[i].size())if(!g[i][j].f){\n\t\t\t\tpoly.emplace_back();\n\t\t\t\tadd_polygon(i, poly.size()-1, g[i][j].a+EPS);\n\t\t\t}\n\t\t\tint m = poly.size();\n\t\t\tvector<vi> dg(m);\n\t\t\tvector<unordered_map<int, int>> rev(n);\n\t\t\tREP(i, n)REP(j, g[i].size()){\n\t\t\t\tint u = i, v = g[i][j].v, l = g[i][j].l;\n\t\t\t\tif(u>v) swap(u, v);\n\t\t\t\tif(rev[u].find(v) != rev[u].end()){\n\t\t\t\t\tdg[l].push_back(rev[u][v]);\n\t\t\t\t\tdg[rev[u][v]].push_back(l);\n\t\t\t\t}\n\t\t\t\telse rev[u][v] = l;\n\t\t\t}\n\t\t\treturn dg;\n\t\t}\n\t};\n#undef SELF\n#undef at\n}\n\nusing namespace geom;\n\nnamespace std{\n\tbool operator<(const P &a, const P &b){return sig(a.X-b.X) ? a.X < b.X : a.Y < b.Y;}\n\tbool operator==(const P &a, const P &b){return !sig(norm(a-b));}\n\tistream& operator>>(istream &is, P &p){R x,y;is>>x>>y;p=P(x, y);return is;}\n\tistream& operator>>(istream &is, L &l){l.resize(2);return is >> l[0] >> l[1];}\n\tistream& operator>>(istream &is, C &c){return is >> (P &)c >> c.r;}\n}\n\nint n, m;\n\nvoid dijkstra(const vector<vi> &g, int s, vector<int> &ret){\n\tint n = g.size();\n\tret = vector<int>(n, INF);\n\tqueue<int> dp;\n\tdp.push(s);\n\tret[s] = 0;\n\twhile(!dp.empty()){\n\t\tint s = dp.front();\n\t\tdp.pop();\n\t\tFOR(it, g[s]){\n\t\t\tif(ret[*it] > ret[s]+1){\n\t\t\t\tret[*it] = ret[s]+1;\n\t\t\t\tdp.push(*it);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\twhile(cin >> n >> m, n){\n\t\tvector<P> p(n);\n\t\tREP(i, n) cin >> p[i];\n\t\tDualGraph dg(p);\n\t\tREP(i, m){\n\t\t\tint u, v;\n\t\t\tcin >> u >> v;u--;v--;\n\t\t\tdg.add_edge(u, v);\n\t\t}\n\t\tvector<vi> g = dg.dual();\n\t\tvi res;\n\t\tdijkstra(g, 0, res);\n\t\tcout << *max_element(ALL(res)) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<utility>\n#include<map>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n\nusing namespace std;\n\nstruct Point{\n\tint x,y;\n\tint id;\n\tPoint(){}\n\tPoint(int a,int b,int c):x(a),y(b),id(c){}\n};\n\nPoint points[110];\nint pid[110];\n\nbool cmp(const Point &p1,const Point &p2)\n{\n\tif(p1.x!=p2.x) return p1.x<p2.x;\n\treturn p1.y<p2.y;\n}\n\nint center;\n\nbool cmp_angle(const int &id1,const int &id2)\n{\n\tint center=pid[::center];\n\tint id1_=pid[id1],id2_=pid[id2];\n\tint dx1=points[id1_].x-points[center].x;\n\tint dy1=points[id1_].y-points[center].y;\n\tint dx2=points[id2_].x-points[center].x;\n\tint dy2=points[id2_].y-points[center].y;\n\t//(-y,x)\n\tdouble ang1=atan2(dx1,-dy1);\n\tdouble ang2=atan2(dx2,-dy2);\n\treturn ang1<ang2;\n}\n\nvector<int> G[110];\n\nvector<vector<int> > vs;\nvector<int> dG[750];\n\ntypedef pair<int,int> P;\n\nmap<P,int> cnt;\nqueue<P> que;\n\nvoid init()\n{\n\tvs.clear();\n\tfor(int i=0;i<110;i++) G[i].clear();\n\tfor(int i=0;i<550;i++) dG[i].clear();\n\tcnt.clear();\n}\n\nvector<int> res;\nvoid stroke(int u,int v,int st)\n{\n\t//u->v\n\tP p=P(min(u,v),max(u,v));\n\tif(cnt[p]==0)\n\t{\n\t\tque.push(P(v,u));\n\t}\n\tcnt[p]++;\n\tif(v==st) return;\n\tif(u==st) res.push_back(u);\n\tres.push_back(v);\n\tcenter=v;\n\tint id=distance(G[v].begin(),lower_bound(G[v].begin(),G[v].end(),u,cmp_angle));\n\tif(id==G[v].size()-1) id=0;\n\telse id++;\n\tint nxt=G[v][id];\n\tstroke(v,nxt,st);\n}\n\nvoid getGraph(int W)\n{\n\tint n=0;\n\tint V=vs.size();\n\tfor(int i=0;i<V;i++) for(int j=i+1;j<V;j++)\n\t{\n\t\tint ni=vs[i].size(),nj=vs[j].size();\n\t\tbool flg=false;\n\t\tfor(int iid=0;iid<ni;iid++) for(int jid=0;jid<nj;jid++)\n\t\t{\n\t\t\tint niid=iid==ni-1?0:iid+1;\n\t\t\tint njid=jid==nj-1?0:jid+1;\n\t\t\tif(vs[i][iid]==vs[j][njid]&&vs[i][niid]==vs[j][jid])\n\t\t\t{\n\t\t\t\tflg=true;\n\t\t\t\tn++;\n\t\t\t}\n\t\t}\n\t\tif(flg)\n\t\t{\n\t\t\tdG[i].push_back(j);\n\t\t\tdG[j].push_back(i);\n\t\t}\n\t}\n}\n\nvector<int> outSide;\n\nint getMostOutSide()\n{\n\tint u=points[0].id;\n\tint v=G[u][0];\n\tfor(int i=0;i<vs.size();i++)\n\t{\n\t\tfor(int j=0;j+1<vs[i].size();j++)\n\t\t{\n\t\t\tif(vs[i][j]==u&&vs[i][j+1]==v) return i;\n\t\t}\n\t\tif(vs[i][vs[i].size()-1]==u&&vs[i][0]==v) return i;\n\t}\n\treturn -1;\n}\n\n\nint dis[750];\nqueue<int> bfs_que;\nvoid bfs(int s)\n{\n\twhile(!bfs_que.empty()) bfs_que.pop();\n\tbfs_que.push(s);\n\tfor(int i=0;i<750;i++) dis[i]=1<<29;\n\tdis[s]=0;\n\tbfs_que.push(s);\n\twhile(!bfs_que.empty())\n\t{\n\t\tint v=bfs_que.front();\n\t\tbfs_que.pop();\n\t\tfor(int i=0;i<dG[v].size();i++)\n\t\t{\n\t\t\tint u=dG[v][i];\n\t\t\tint nd=dis[v]+1;\n\t\t\tif(nd>=dis[u]) continue;\n\t\t\tdis[u]=nd;\n\t\t\tbfs_que.push(u);\n\t\t}\n\t}\n}\n\n\nint main()\n{\n\twhile(true)\n\t{\n\t\tint C,W;\n\t\tscanf(\"%d%d\",&C,&W);\n\t\tif(C==0) break;\n\t\tinit();\n\t\tfor(int i=0;i<C;i++)\n\t\t{\n\t\t\tint x,y;\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\tpoints[i]=Point(x,y,i);\n\t\t}\n\t\tsort(points,points+C,cmp);\n\t\tfor(int i=0;i<C;i++) pid[points[i].id]=i;\n\t\tint su=-1,sv=-1;\n\t\tfor(int i=0;i<W;i++)\n\t\t{\n\t\t\tint u,v;\n\t\t\tscanf(\"%d%d\",&u,&v);\n\t\t\tu--;v--;\n\t\t\tG[u].push_back(v);\n\t\t\tG[v].push_back(u);\n\t\t\tsu=u,sv=v;\n\t\t}\n\t\tfor(int i=0;i<C;i++)\n\t\t{\n\t\t\tcenter=i;\n\t\t\tsort(G[i].begin(),G[i].end(),cmp_angle);\n\t\t}\n\t\tque.push(P(min(su,sv),max(su,sv)));\n\t\twhile(!que.empty())\n\t\t{\n\t\t\tP p=que.front();\n\t\t\tque.pop();\n\t\t\tint u=p.first,v=p.second;\n\t\t\tP pp=P(min(u,v),max(u,v));\n\t\t\tres.clear();\n\t\t\tstroke(u,v,u);\n\t\t\tvs.push_back(res);\n\t\t}\n\t\tgetGraph(W);\n\t\tint out=getMostOutSide();\n\t\tbfs(out);\n\t\tgetMostOutSide();\n\t\tint ans=0;\n\t\tfor(int i=0;i<vs.size();i++) ans=max(ans,dis[i]);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<int,pair<bool,double> > P2;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define min_3(a,b,c) min(a,min(b,c))\n#define max_3(a,b,c) max(a,max(b,c))\n#define mp1(a,b,c) P1(a,P(b,c))\n#define mp2(a,b,c) P2(a,pair<bool,double>(b,c))\n#define pque(a) priority_queue<a>\n#define rpque(a) priority_queue<a,vector<a>,greater<a>>\n\nconst int INF=1000000000;\nconst int dre_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dre_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\nconst int kaijou[10]={1,1,2,6,24,120,720,5040,40320,362880};\n\nbool com(P2 x,P2 y){\n\tif(x.sc.fr!=y.sc.fr)return x.sc.fr;\n\treturn x.sc.sc>=y.sc.sc;\n}\n\nint main(){\n\twhile(1){\n\t\tstatic int c,w;\n\t\tstatic int x[110],y[110];\n\t\tstatic int s,t;\n\t\t\n\t\tscanf(\"%d%d\",&c,&w); if(c==0&&w==0)break;\n\t\trep1(i,c)scanf(\"%d%d\",&x[i],&y[i]);\n\t\t\n\t\tstatic vector<P1> V_; V_.clear();\n\t\trep1(i,c){\n\t\t\tV_.pb(mp1(x[i],y[i],i));\n\t\t}\n\t\tsor(V_);\n\t\tstatic vector<P2> vec_[110];\n\t\trep1(i,c){\n\t\t\tvec_[i].clear();\n\t\t\tvec_[i].pb(mp2(0,false,-INF));\n\t\t\trep1(j,c){\n\t\t\t\tif(i==j)continue;\n\t\t\t\tif(x[i]<x[j]){\n\t\t\t\t\tvec_[i].pb(mp2(j,true,(double)(y[j]-y[i])/(x[j]-x[i])));\n\t\t\t\t}\n\t\t\t\telse if(x[i]>x[j]){\n\t\t\t\t\tvec_[i].pb(mp2(j,false,(double)(y[j]-y[i])/(x[j]-x[i])));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(y[j]>y[i])vec_[i].pb(mp2(j,true,(double)INF));\n\t\t\t\t\telse vec_[i].pb(mp2(j,true,(double)-INF));\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(vec_[i].begin(),vec_[i].end(),com);\n\t\t}\n\t\t\n\t\tstatic int v,e;\n\t\tstatic vector<int> V; V.clear();\n\t\tstatic bool edge[110][110];\n\t\tstatic vector<int> vec[110]; \n\t\t\n\t\tv=c; e=w;\n\t\trep(i,c)V.pb(V_[i].sc.sc);\n\t\trep(i,110)rep(j,110)edge[i][j]=false;\n\t\trep(i,e){\n\t\t\tscanf(\"%d%d\",&s,&t);\n\t\t\tedge[s][t]=true;\n\t\t\tedge[t][s]=true;\n\t\t}\n\t\trep1(i,c){\n\t\t\tvec[i].clear();\n\t\t\trep(j,vec_[i].size()){\n\t\t\t\tvec[i].pb(vec_[i][j].fr);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ret=0;\n\t\twhile(e>0){\n\t\t\tret++;\n\t\t\t\n\t\t\tint a=-1;\n\t\t\trep(i,V.size()){\n\t\t\t\trep(j,105){\n\t\t\t\t\tif(edge[V[i]][j]){a=V[i]; break;}\n\t\t\t\t}\n\t\t\t\tif(a!=-1)break;\n\t\t\t}\n\t\t\t\n\t\t\tint b=0,c=a;\n\t\t\twhile(1){\n\t\t\t\tif(c==-1||vec[c].size()==0)break;\n\t\t\t\trep(i,vec[c].size()){\n\t\t\t\t\tif(vec[c][i]==b){\n\t\t\t\t\t\ti++; i%=vec[c].size();\n\t\t\t\t\t\twhile(!edge[c][vec[c][i]]){\n\t\t\t\t\t\t\ti++; i%=vec[c].size();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tedge[c][vec[c][i]]=false;\n\t\t\t\t\t\tedge[vec[c][i]][c]=false;\n\t\t\t\t\t\te--;\n\t\t\t\t\t\tb=c;\n\t\t\t\t\t\tc=vec[c][i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(c==a)break;\n\t\t\t}\n\t\t\t\n\t\t\tbool updata=true;\n\t\t\twhile(updata){\n\t\t\t\tupdata=false;\n\t\t\t\trep(i,105){\n\t\t\t\t\tint cnt=0;\n\t\t\t\t\tint t=105;\n\t\t\t\t\trep(j,105){\n\t\t\t\t\t\tif(edge[i][j]){cnt++; t=j;}\n\t\t\t\t\t}\n\t\t\t\t\tif(cnt==1){\n\t\t\t\t\t\tupdata=true;\n\t\t\t\t\t\tedge[i][t]=false;\n\t\t\t\t\t\tedge[t][i]=false;\n\t\t\t\t\t\te--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#define N 1000\n#define M 1000\n#define K 1000\nusing namespace std;\ntypedef pair<double,int> P;\nint x[N];\nint y[N];\nvector<P> e[N];\nint a[M];\nint b[M];\nint id[M][N];\nbool used[M][N];\nvector<int> adj[M];\nint out_i,out_v;\nint out;\nvector<int> e2[K];\nint dist[K];\n\nint rev(int i,int v){\n\tif(a[i]==v)return b[i];\n\telse return a[i];\n}\n\nvoid solve(int i,int v,int k){\n\tvector<int> res;\n\tint s=i;\n\tused[s][v]=true;\n\tres.push_back(s);\n\tif(i==out_i&&v==out_v)out=k;\n\twhile(1){\n\t\ti=e[v][(id[i][v]+1)%e[v].size()].second;\n\t\tv=rev(i,v);\n\t\tif(i==s)break;\n\t\tused[i][v]=true;\n\t\tres.push_back(i);\n\t\tif(i==out_i&&v==out_v)out=k;\n\t}\n\tfor(i=0;i<res.size();i++)adj[res[i]].push_back(k);\n}\n\nint max(int a,int b){return a>b?a:b;}\n\nvoid bfs(int n,int s){\n\tint i;\n\tfor(i=0;i<n;i++)dist[i]=-1;\n\tdist[s]=0;\n\tqueue<int> que;\n\tque.push(s);\n\twhile(!que.empty()){\n\t\tint v=que.front();\n\t\tque.pop();\n\t\tfor(i=0;i<e2[v].size();i++){\n\t\t\tint u=e2[v][i];\n\t\t\tif(dist[u]==-1){\n\t\t\t\tdist[u]=dist[v]+1;\n\t\t\t\tque.push(u);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(1){\n\t\tint n,m,i,j;\n\t\tscanf(\"%d %d\",&n,&m);\n\t\tif(n==0&&m==0)break;\n\t\tfor(i=0;i<n;i++)e[i].clear();\n\t\tfor(i=0;i<m;i++)adj[i].clear();\n\t\tint lf=0;\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d %d\",&x[i],&y[i]);\n\t\t\tif(x[i]<x[lf])lf=i;\n\t\t}\n\t\tfor(i=0;i<m;i++){\n\t\t\tscanf(\"%d %d\",&a[i],&b[i]);\n\t\t\ta[i]--;b[i]--;\n\t\t\tdouble dx=(double)(x[b[i]]-x[a[i]]);\n\t\t\tdouble dy=(double)(y[b[i]]-y[a[i]]);\n\t\t\te[a[i]].push_back(P(atan2(dy,dx),i));\n\t\t\te[b[i]].push_back(P(atan2(-dy,-dx),i));\n\t\t}\n\t\tfor(i=0;i<n;i++)sort(e[i].begin(),e[i].end());\n\t\tint bt=0;\n\t\tfor(i=0;i<n;i++){\n\t\t\tfor(j=0;j<e[i].size();j++){\n\t\t\t\tid[e[i][j].second][i]=j;\n\t\t\t\tif(i==lf)if(y[rev(e[i][j].second,i)]>y[rev(e[i][bt].second,i)])bt=j;\n\t\t\t}\n\t\t}\n\t\tout_i=e[lf][bt].second;\n\t\tout_v=lf;\n\t\tfor(i=0;i<m;i++)for(j=0;j<n;j++)used[i][j]=false;\n\t\tint k=0;\n\t\tfor(i=0;i<m;i++){\n\t\t\tif(!used[i][a[i]]){\n\t\t\t\tsolve(i,a[i],k);\n\t\t\t\tk++;\n\t\t\t}\n\t\t\tif(!used[i][b[i]]){\n\t\t\t\tsolve(i,b[i],k);\n\t\t\t\tk++;\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<k;i++)e2[i].clear();\n\t\tfor(i=0;i<m;i++){\n\t\t\te2[adj[i][0]].push_back(adj[i][1]);\n\t\t\te2[adj[i][1]].push_back(adj[i][0]);\n\t\t}\n\t\tbfs(k,out);\n\t\tint ans=0;\n\t\tfor(i=0;i<k;i++)ans=max(ans,dist[i]);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cassert>\nusing namespace std;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n\treturn abs(a.real()-b.real()) > EPS ? real(a) < real(b) : imag(a) + EPS < imag(b);\n    //return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\nP readPoint(){\n\tdouble x,y;\n\tcin >> x >> y;\n\treturn P(x,y);\n}\n\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\ntypedef vector<P> G;\n\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\n\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\nP reflection(const L &l, const P &p) {\n  return p + 2. * (projection(l, p) - p);\n}\ndouble distanceLP(const L &l, const P &p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\n#define rep(i,N) for(int i = 0 ; i < N ; i++)\nP ps[110];\nvector<int> g[110];\n\nvector<int> normalize(vector<int> v){\n\tauto it = min_element(v.begin(),v.end());\n\trotate(v.begin(),it,v.end());\n\treturn v;\n}\n\nint done[110];\nvoid f(int a,int b,int s,vector<int> &v){\n\tv.push_back(b);\n\tif( b == s ) return;\n\tif( done[b]++ ) throw 0;\n\tsort(g[b].begin(),g[b].end(),[&](int x,int y){\n\t\tP A = ps[x] - ps[b];\n\t\tP B = ps[y] - ps[b];\n\t\treturn cross(A,B) > 0;\n\t});\n\trotate(g[b].begin(),find(g[b].begin(),g[b].end(),a),g[b].end());\n\tf(b,g[b][1],s,v);\n}\n\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n\ndouble area2(const G& P) {\n  double A = 0;\n  for (int i = 0; i < P.size(); ++i) \n    A += cross(curr(P, i), next(P, i));\n  return A;\n}\n\nint main(){\n\t\n\tint C,W;\n\twhile( cin >> C >> W && (C||W) ){\n\t\trep(i,C) ps[i] = readPoint();\n\t\trep(i,C) g[i].clear();\n\t\trep(i,W){\n\t\t\tint a,b;\n\t\t\tcin >> a >> b;\n\t\t\t--a,--b;\n\t\t\tg[a].push_back(b);\n\t\t\tg[b].push_back(a);\n\t\t}\n\t\tvector< vector<int> > poly;\n\t\trep(i,C){\n\t\t\trep(j,g[i].size()){\n\t\t\t\ttry{\n\t\t\t\t\tmemset(done,0,sizeof(done));\n\t\t\t\t\tvector<int> v;\n\t\t\t\t\tf(i,g[i][j],i,v);\n\t\t\t\t\tvector<P> g;\n\t\t\t\t\trep(k,v.size())g.push_back(ps[v[k]]);\n\t\t\t\t\tif( area2(g) > 0 ){ continue; }\n\t\t\t\t\tpoly.push_back(normalize(v));\n\t\t\t\t}catch(int x){\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(poly.begin(),poly.end());\n\t\tpoly.erase(unique(poly.begin(),poly.end()),poly.end());\n\t\t\n\t\tmap< pair<int,int>, vector<int> > edgs;\n\t\tfor(int i = 0 ; i < poly.size() ; i++){\n\t\t\tfor(int j = 0 ; j < poly[i].size() ; j++){\n\t\t\t\tint A = curr(poly[i],j);\n\t\t\t\tint B = next(poly[i],j);\n\t\t\t\tif( A > B ) swap(A,B);\n\t\t\t\tedgs[pair<int,int>(A,B)].push_back(i);\n\t\t\t}\n\t\t}\n\t\tint M = poly.size() + 1;\n\t\tint wf[M][M];\n\t\trep(i,M) rep(j,M){\n\t\t\twf[i][j] = i==j?0:1e9;\n\t\t}\n\t\t\n\t\tfor( auto x : edgs ){\n\t\t\tvector<int> v = x.second;\n\t\t\tif( v.size() < 2 ) v.push_back(M-1);\n\t\t\twf[v[0]][v[1]] = wf[v[1]][v[0]] = 1;\n\t\t}\n\t\trep(i,M)rep(j,M)rep(k,M) wf[j][k] = min(wf[j][i]+wf[i][k],wf[j][k]);\n\t\tint ans = 1;\n\t\trep(i,M){\n\t\t\tif( wf[i][M-1] != 1e9 )\n\t\t\tans = max(ans,wf[i][M-1]);\n\t\t}\n\t\tcout << ans << endl;\n\t\t\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#define N 100\n#define M 300\n#define K 600\nusing namespace std;\ntypedef pair<double,int> P;\nint x[N];\nint y[N];\nvector<P> e[N];\nint a[M];\nint b[M];\nint id[M][N];\nbool used[M][N];\nvector<int> adj[M];\nint out_i,out_v;\nint out;\nvector<int> e2[K];\nint dist[K];\n\nint rev(int i,int v){\n\tif(a[i]==v)return b[i];\n\telse return a[i];\n}\n\nvoid solve(int i,int v,int k){\n\tvector<int> res;\n\tint s=i;\n\tused[s][v]=true;\n\tres.push_back(s);\n\tif(i==out_i&&v==out_v)out=k;\n\twhile(1){\n\t\ti=e[v][(id[i][v]+1)%e[v].size()].second;\n\t\tv=rev(i,v);\n\t\tif(i==s)break;\n\t\tused[i][v]=true;\n\t\tres.push_back(i);\n\t\tif(i==out_i&&v==out_v)out=k;\n\t}\n\tfor(i=0;i<res.size();i++)adj[res[i]].push_back(k);\n}\n\nint max(int a,int b){return a>b?a:b;}\n\nvoid bfs(int n,int s){\n\tint i;\n\tfor(i=0;i<n;i++)dist[i]=-1;\n\tdist[s]=0;\n\tqueue<int> que;\n\tque.push(s);\n\twhile(!que.empty()){\n\t\tint v=que.front();\n\t\tque.pop();\n\t\tfor(i=0;i<e2[v].size();i++){\n\t\t\tint u=e2[v][i];\n\t\t\tif(dist[u]==-1){\n\t\t\t\tdist[u]=dist[v]+1;\n\t\t\t\tque.push(u);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(1){\n\t\tint n,m,i,j;\n\t\tscanf(\"%d %d\",&n,&m);\n\t\tif(n==0&&m==0)break;\n\t\tfor(i=0;i<n;i++)e[i].clear();\n\t\tfor(i=0;i<m;i++)adj[i].clear();\n\t\tint lf=0;\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d %d\",&x[i],&y[i]);\n\t\t\tif(x[i]<x[lf])lf=i;\n\t\t}\n\t\tfor(i=0;i<m;i++){\n\t\t\tscanf(\"%d %d\",&a[i],&b[i]);\n\t\t\ta[i]--;b[i]--;\n\t\t\tdouble dx=(double)(x[b[i]]-x[a[i]]);\n\t\t\tdouble dy=(double)(y[b[i]]-y[a[i]]);\n\t\t\te[a[i]].push_back(P(atan2(dy,dx),i));\n\t\t\te[b[i]].push_back(P(atan2(-dy,-dx),i));\n\t\t}\n\t\tfor(i=0;i<n;i++)sort(e[i].begin(),e[i].end());\n\t\tint bt=0;\n\t\tfor(i=0;i<n;i++){\n\t\t\tfor(j=0;j<e[i].size();j++){\n\t\t\t\tid[e[i][j].second][i]=j;\n\t\t\t\tif(i==lf){\n\t\t\t\t\tif(y[rev(e[i][j].second,i)]>y[rev(e[i][bt].second,i)])bt=j;\n\t\t\t\t\telse if(y[rev(e[i][j].second,i)]==y[rev(e[i][bt].second,i)]&&x[rev(e[i][j].second,i)]>x[rev(e[i][bt].second,i)])bt=j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout_i=e[lf][bt].second;\n\t\tout_v=lf;\n\t\tfor(i=0;i<m;i++)for(j=0;j<n;j++)used[i][j]=false;\n\t\tint k=0;\n\t\tfor(i=0;i<m;i++){\n\t\t\tif(!used[i][a[i]]){\n\t\t\t\tsolve(i,a[i],k);\n\t\t\t\tk++;\n\t\t\t}\n\t\t\tif(!used[i][b[i]]){\n\t\t\t\tsolve(i,b[i],k);\n\t\t\t\tk++;\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<k;i++)e2[i].clear();\n\t\tfor(i=0;i<m;i++){\n\t\t\te2[adj[i][0]].push_back(adj[i][1]);\n\t\t\te2[adj[i][1]].push_back(adj[i][0]);\n\t\t}\n\t\tbfs(k,out);\n\t\tint ans=0;\n\t\tfor(i=0;i<k;i++)ans=max(ans,dist[i]);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<int,pair<bool,double> > P2;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define min_3(a,b,c) min(a,min(b,c))\n#define max_3(a,b,c) max(a,max(b,c))\n#define mp1(a,b,c) P1(a,P(b,c))\n#define mp2(a,b,c) P2(a,pair<bool,double>(b,c))\n#define pque(a) priority_queue<a>\n#define rpque(a) priority_queue<a,vector<a>,greater<a>>\n\nconst int INF=1000000000;\nconst int dre_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dre_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\nconst int kaijou[10]={1,1,2,6,24,120,720,5040,40320,362880};\n\nbool com(P2 x,P2 y){\n\tif(x.sc.fr!=y.sc.fr)return x.sc.fr;\n\treturn x.sc.sc>=y.sc.sc;\n}\n\nint main(){\n\tint ppp=0;\n\twhile(1){\n\t\tppp++; if(ppp>=6)return 0;\n\t\tstatic int v,w;\n\t\tstatic int x[110],y[110];\n\t\tstatic int s,t;\n\t\t\n\t\tscanf(\"%d%d\",&v,&w); if(v==0&&w==0)break;\n\t\trep1(i,v)scanf(\"%d%d\",&x[i],&y[i]);\n\t\t\n\t\tstatic vector<P1> V_; V_.clear();\n\t\trep1(i,v){\n\t\t\tV_.pb(mp1(x[i],y[i],i));\n\t\t}\n\t\tsor(V_);\n\t\tstatic vector<P2> vec_[110];\n\t\trep1(i,v){\n\t\t\tvec_[i].clear();\n\t\t\tvec_[i].pb(mp2(0,false,-INF));\n\t\t\trep1(j,v){\n\t\t\t\tif(i==j)continue;\n\t\t\t\tif(x[i]<x[j]){\n\t\t\t\t\tvec_[i].pb(mp2(j,true,(double)(y[j]-y[i])/(x[j]-x[i])));\n\t\t\t\t}\n\t\t\t\telse if(x[i]>x[j]){\n\t\t\t\t\tvec_[i].pb(mp2(j,false,(double)(y[j]-y[i])/(x[j]-x[i])));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(y[j]>y[i])vec_[i].pb(mp2(j,true,(double)INF));\n\t\t\t\t\telse vec_[i].pb(mp2(j,true,(double)-INF));\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(vec_[i].begin(),vec_[i].end(),com);\n\t\t}\n\t\t\n\t\tstatic int e;\n\t\tstatic vector<int> V; V.clear();\n\t\tstatic bool edge[110][110];\n\t\tstatic vector<int> vec[110]; \n\t\t\n\t\te=w;\n\t\trep(i,v)V.pb(V_[i].sc.sc);\n\t\trep(i,110)rep(j,110)edge[i][j]=false;\n\t\trep(i,e){\n\t\t\tscanf(\"%d%d\",&s,&t);\n\t\t\tedge[s][t]=true;\n\t\t\tedge[t][s]=true;\n\t\t}\n\t\trep1(i,v){\n\t\t\tvec[i].clear();\n\t\t\trep(j,vec_[i].size()){\n\t\t\t\tvec[i].pb(vec_[i][j].fr);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ret=0;\n\t\twhile(e>0){\n\t\t\tret++;\n\t\t\t\n\t\t\tint a=-1;\n\t\t\trep(i,V.size()){\n\t\t\t\trep(j,105){\n\t\t\t\t\tif(edge[V[i]][j]){a=V[i]; break;}\n\t\t\t\t}\n\t\t\t\tif(a!=-1)break;\n\t\t\t}\n\t\t\t\n\t\t\tint b=0,c=a;\n\t\t\twhile(1){\n\t\t\t\tif(c==-1||vec[c].size()==0)break;\n\t\t\t\trep(i,vec[c].size()){\n\t\t\t\t\tif(vec[c][i]==b){\n\t\t\t\t\t\ti++; i%=vec[c].size();\n\t\t\t\t\t\twhile(!edge[c][vec[c][i]]){\n\t\t\t\t\t\t\ti++; i%=vec[c].size();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tedge[c][vec[c][i]]=false;\n\t\t\t\t\t\tedge[vec[c][i]][c]=false;\n\t\t\t\t\t\te--;\n\t\t\t\t\t\tb=c;\n\t\t\t\t\t\tc=vec[c][i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(c==a)break;\n\t\t\t}\n\t\t\t\n\t\t\tbool updata=true;\n\t\t\twhile(updata){\n\t\t\t\tupdata=false;\n\t\t\t\trep1(i,v){\n\t\t\t\t\tint cnt=0;\n\t\t\t\t\tint t=105;\n\t\t\t\t\trep1(j,v){\n\t\t\t\t\t\tif(edge[i][j]){cnt++; t=j;}\n\t\t\t\t\t}\n\t\t\t\t\tif(cnt==1){\n\t\t\t\t\t\tupdata=true;\n\t\t\t\t\t\tedge[i][t]=false;\n\t\t\t\t\t\tedge[t][i]=false;\n\t\t\t\t\t\te--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <set>\n#include <cstdlib>\nusing namespace std;\n\nconst double EPS = 1e-10;\nconst double INF = 1e12;\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n#define X real()\n#define Y imag()\n\ntypedef complex<double> P;\ntypedef vector<P> VP;\nstruct L : VP{\n    L(const P& a, const P& b){ resize(2); at(0)=a; at(1)=b; }\n    L(){ resize(2); }\n};\n\nnamespace std{\n    bool operator < (const P &a, const P &b){\n        return !EQ(a.X, b.X)? a.X<b.X : a.Y<b.Y;\n    }\n    bool operator == (const P &a, const P &b){\n        return abs(a-b) < EPS;\n    }\n}\n\ndouble dot(P a, P b){\n    return (conj(a)*b).X;\n}\ndouble cross(P a, P b){\n    return (conj(a)*b).Y;\n}\nint ccw(P a, P b, P c){\n    b -= a;\n    c -= a;\n    if(cross(b,c) > EPS) return +1; //ccw\n    if(cross(b,c) <-EPS) return -1; //cw\n    if(dot(b,c) < EPS) return +2; //c-a-b\n    if(norm(b) < norm(c)) return -2; //a-b-c\n    return 0; //a-c-b\n}\n\nP projection(const L& l, const P& p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1]-l[0], m[1]-m[0]);\n  double B = cross(l[1]-l[0], l[1]-m[0]);\n  return m[0] + B /A *(m[1]-m[0]);\n}\n\ndouble getangle(const P &p, const P &a, const P &b){ //clockwise\n    P proj = projection(L(p,a), b);\n    int minus = (dot(a-p, b-p)>=0)? 1 :-1;\n    if(ccw(p,a,b)!=1){\n        return atan2(abs(b-proj), minus*abs(p-proj));\n    }else{\n        return 2*M_PI - atan2(abs(b-proj), minus*abs(p-proj));\n    }\n}\n\nvoid trace(int cidx, vector<vector<int> > &adj, map<pair<int,int>, int> &rest, VP &plist, vector<int> &poly, bool outside){\n    P curr = plist[cidx];\n    P prev = P(0, -1);\n    int pidx = -1;\n    poly = vector<int>();\n    bool first=true;\n    while(1){\n        int next = -1;\n        bool rightmost = !first && !outside;\n        double m_angle = rightmost? -INF: INF;\n        for(int i=0; i<(int)adj[cidx].size(); i++){\n            if(adj[cidx][i] == pidx) continue;\n            int imin = min(cidx, adj[cidx][i]);\n            int imax = max(cidx, adj[cidx][i]);\n            if(rest[make_pair(imin, imax)] == 0) continue;\n            double angle = getangle(curr, prev, plist[adj[cidx][i]]);\n            if((rightmost && angle > m_angle) || (!rightmost && angle < m_angle)){\n                next = adj[cidx][i];\n                m_angle = angle;\n            }\n        }\n        if(!first) rest[make_pair(min(cidx,next), max(cidx,next))]--;\n        if(!first && next == poly[0]) break;\n        if(next==-1) exit(1);\n        poly.push_back(next);\n        prev = curr;\n        pidx = cidx;\n        curr = plist[next];\n        cidx = next;\n        first = false;\n    }\n}\n\nvoid makeDualGraph(vector<vector<int> > &adj, vector<vector<int> > &dual, VP &plist){\n    int n = adj.size();\n    vector<int> degree(n);\n    map<pair<int,int>, int> rest;\n    for(int i=0; i<n; i++){\n        for(int j=0; j<(int)adj[i].size(); j++){\n            if(i<adj[i][j]){\n                rest[make_pair(i, adj[i][j])] = 2;\n            }\n        }\n        degree[i] = adj[i].size()*2;\n    }\n    \n    map<pair<int,int>, int> edgelist;\n    dual = vector<vector<int> >();\n    dual.reserve(200);\n    \n    int sptr=0;\n    int areaidx=-1;\n    bool first = true;\n    while(1){\n        while(sptr<n && degree[sptr]==0) sptr++;\n        if(sptr==n) break;\n        areaidx++;\n        \n        vector<int> border;\n        trace(sptr, adj, rest, plist, border, first);\n        dual.push_back(vector<int>());\n        \n        for(int i=0; i<(int)border.size(); i++){\n            int a = border[i];\n            int b = border[(i+1)%(int)border.size()];\n            if(a>b) swap(a,b);\n            degree[a]--;\n            degree[b]--;\n            if(edgelist.count(make_pair(a,b)) == 0){\n                edgelist[make_pair(a,b)] = areaidx;\n            }else{\n                dual[areaidx].push_back(edgelist[make_pair(a,b)]);\n                dual[edgelist[make_pair(a,b)]].push_back(areaidx);\n            }\n        }\n        first = false;\n    }\n    \n    for(int i=0; i<=areaidx; i++){\n        sort(dual[i].begin(), dual[i].end());\n        dual[i].erase(unique(dual[i].begin(), dual[i].end()), dual[i].end());\n    }\n}\n\nint main(){\n\twhile(1){\n\t\tint c,w;\n\t\tcin >> c >> w;\n\t\tif(c==0) break;\n\t\t\n\t\tvector<pair<P, int> > bar(c);\n\t\tfor(int i=0; i<c; i++){\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\tbar[i] = make_pair(P(x,y), i+1);\n\t\t}\n\t\tsort(bar.begin(), bar.end());\n\t\t\n\t\tvector<int> backref(c+1);\n\t\tVP p(c);\n\t\tfor(int i=0; i<c; i++){\n\t\t\tbackref[bar[i].second] = i;\n\t\t\tp[i] = bar[i].first;\n\t\t}\n\t\t\n\t\tvector<vector<int> > adj(c), dual;\n\t\tfor(int i=0; i<w; i++){\n\t\t\tint s,t;\n\t\t\tcin >> s >> t;\n\t\t\tadj[backref[s]].push_back(backref[t]);\n\t\t\tadj[backref[t]].push_back(backref[s]);\n\t\t}\n\t\tmakeDualGraph(adj, dual, p);\n\t\t\n\t\tint numarea = dual.size();\n\t\tset<int> reach;\n\t\treach.insert(0);\n\t\tint ans = 0;\n\t\twhile(1){\n\t\t\tif((int)reach.size() == numarea) break;\n\t\t\tset<int> newreach;\n\t\t\tfor(set<int>::iterator itr=reach.begin(); itr!=reach.end(); itr++){\n\t\t\t\tnewreach.insert(*itr);\n\t\t\t\tfor(int i=0; i<(int)dual[*itr].size(); i++){\n\t\t\t\t\tnewreach.insert(dual[*itr][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treach = newreach;\n\t\t\tans++;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;\nconst double EPS = 1e-8, INF = 1e12, PI = acos(-1.0);\ntypedef complex<double> P;\nnamespace std{\n\tbool operator<(const P& a, const P& b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ninline double cross(const P& a, const P& b){ return imag(conj(a)*b); }\ninline double dot(const P& a, const P& b){ return real(conj(a)*b); }\nstruct L : public vector<P>{\n\tL(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\ntypedef vector<P> G;\ninline int ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif(cross(b, c) >  EPS)   return +1;      // counter clockwise\n\tif(cross(b, c) < -EPS)   return -1;      // clockwise\n\tif(dot(b, c)   < -EPS)   return +2;      // c--a--b on line\n\tif(norm(b)+EPS <norm(c)) return -2;      // a--b--c on line\n\treturn 0;                                   // c is between a and b (inclusive)\n}\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\ndouble area2(const G& g) {\n\tdouble A = 0;\n\tfor (int i = 0; i < g.size(); ++i) \n\t\tA += cross(curr(g, i), next(g, i));\n\treturn A;\n}\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\tint c, w;\n\twhile(cin >> c >> w, c){\n\t\tG vs;\n\t\tvector<vi> v_to_es(c);\n\t\trep(i, c){ int x, y; cin >> x >> y; vs.emplace_back(x, y); }\n\t\trep(i, w){\n\t\t\tint s, t; cin >> s >> t; s--; t--;\n\t\t\tv_to_es[s].pb(t);\n\t\t\tv_to_es[t].pb(s);\n\t\t}\n\t\trep(i, c){\n\t\t\tsort(all(v_to_es[i]), [&](int a, int b){\n\t\t\t\treturn arg(vs[a] - vs[i]) < arg(vs[b] - vs[i]);\n\t\t\t});\n\t\t}\n\t\t\n\t\tint outer = -1;\n\t\tvector<vi> sur;\n\t\tset<pi> vis;\n\t\tmap<pi,int> e_to_sur;\n\t\t\n\t\tfunction<void(int,int,vi&)> rec = [&](int prev, int cur, vi &v){\n\t\t\tvis.emplace(prev, cur);\n\t\t\tv.pb(prev);\n\t\t\tint k = 0;\n\t\t\tfor(; v_to_es[cur][k] != prev; k++);\n\t\t\tk = (k - 1 + v_to_es[cur].size()) % v_to_es[cur].size();\n\t\t\tint next = v_to_es[cur][k];\n\t\t\tif(!vis.count(pi(cur, next))) rec(cur, next, v);\n\t\t};\n\t\trep(i, c) for(int j : v_to_es[i]) if(!vis.count(pi(i, j))){\n\t\t\tvi v;\n\t\t\trec(i, j, v);\n\t\t\tint id = sur.size();\n\t\t\tG g;\n\t\t\trep(k, v.size()){\n\t\t\t\te_to_sur[pi(v[k], v[(k+1) % v.size()])] = id;\n\t\t\t\tg.pb(vs[v[k]]);\n\t\t\t}\n\t\t\tif(area2(g) < 0) outer = id;\n\t\t\tsur.pb(v);\n\t\t\t//dbg(v, area2(g));\n\t\t}\n\t\t\n\t\t//dbg(outer);\n\t\tint n = sur.size();\n\t\tvector<vi> dist(n, vi(n, 10000));\n\t\trep(i, n) dist[i][i] = 0;\n\t\trep(i, n) rep(j, sur[i].size()){\n\t\t\tint k = e_to_sur[pi(sur[i][(j + 1) % sur[i].size()], sur[i][j])];\n\t\t\tdist[i][k] = dist[k][i] = 1;\n\t\t}\n\t\trep(k, n) rep(i, n) rep(j, n) dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\t\tcout << *max_element(all(dist[outer])) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n\n/* ??????????????¬ */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\n\nconst ld pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// ????????\\???\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// ????????????????????????\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// ??????\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// ??????\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn Point();\n\t\t}\n\t}\n};\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(nb, nc) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(nb, nc) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n\n\n/* ???????????? */\n\n// ??´?????¨??´??????????????????\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// ????????´????????????\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// ?????????????????????\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// ??????????¶?\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// ??´?????¨??´????????????\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n// ??´?????¨??´????????????\nvector<Point> is_ll2(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tif (cross(sv, tv) != 0)return vector<Point>(1, is_ll(s, t));\n\telse {\n\t\tvector<Point>ans;\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tif (isis_sp(s, t[k]) && find(ans.begin(), ans.end(), t[k]) == ans.end())ans.push_back(t[k]);\n\t\t\tif (isis_sp(t, s[k]) && find(ans.begin(), ans.end(), s[k]) == ans.end())ans.push_back(s[k]);\n\t\t}\n\t\treturn ans;\n\t}\n}\n// ????????¨???????????????\n//???????????£????????¨???????????¨assert(false)\nPoint is_ss(const Line &s, const Line& t) {\n\tif (isis_ss(s, t)) {\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\tif (s[k] == t[l])return s[k];\n\t\t\t}\n\t\t}\n\t\treturn is_ll(s, t);\n\t}\n\telse {\n\t\t//??????isis_ss?????????\n\t\tassert(false);\n\t\treturn Point(0, 0);\n\t}\n}\n// ????????¨???????????????\nvector<Point> is_ss2(const Line &s, const Line& t) {\n\tvector<Point> kouho(is_ll2(s, t));\n\tvector<Point>ans;\n\tfor (auto p : kouho) {\n\t\tif (isis_sp(s, p) && isis_sp(t, p))ans.emplace_back(p);\n\t}\n\treturn ans;\n}\n// ??´?????¨???????????¢\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// ??´?????¨??´???????????¢\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//??´?????¨??´?????????????????????????????????\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0])<eps) ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0])<eps) ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nPoint  inner_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i <static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vertics[0];\n\tLine bi1(bisection(Line(vertics[0], vertics[1]), Line(vertics[0], vertics[2])));\n\tLine bi2(bisection(Line(vertics[1], vertics[2]), Line(vertics[1], vertics[0])));\n\tif (bi1[0] == bi2[0])return bi1[0];\n\telse {\n\t\treturn is_ll(bi1, bi2);\n\t}\n}\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nvector<Point>  ex_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (abs(vertics[0] - vertics[1])<eps || abs(vertics[1] - vertics[2])<eps || (abs(vertics[2] - vertics[0])<eps))return vector<Point>();\n\tvector<Point>ecs;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tLine bi1(bisection(Line(vertics[i], vertics[i] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[i], vertics[(i + 1) % 3])));\n\t\tLine bi2(bisection(Line(vertics[(i + 1) % 3], vertics[(i + 1) % 3] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[(i + 1) % 3], vertics[i])));\n\t\tecs.push_back(is_ll(bi1, bi2));\n\t}\n\treturn ecs;\n}\n\n\n//a,b:??????\n//c:????????§??????\n//???????????´?????????????????¢?????????????±??????????\nvector<Point>  same_dis(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tvertics.push_back(is_ll(ls[0], ls[2]));\n\tvertics.push_back(is_ll(ls[1], ls[2]));\n\n\tif (abs(vertics[0] - vertics[1]) < eps)return vector<Point>{vertics[0]};\n\tLine bis(bisection(ls[0], ls[1]));\n\tvector<Point>ecs;\n\n\tLine abi(bisection(Line(vertics[0], vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, abi));\n\n\n\tLine bbi(bisection(Line(vertics[0], 2.l*vertics[0] - vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, bbi));\n\n\treturn ecs;\n}\n/* ??? */\n\n// ?????¨????????????\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n//???????????????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_circle(const Circle &cir, const  Point& p) {\n\tld dis = abs(cir.p - p);\n\tif (dis > cir.r + eps)return 0;\n\telse if (dis < cir.r - eps)return 2;\n\telse return 1;\n}\n//???lc??????rc??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint circle_in_circle(const Circle &lc, const  Circle&rc) {\n\tld dis = abs(lc.p - rc.p);\n\tif (dis < rc.r - lc.r - eps)return 2;\n\telse if (dis>rc.r - lc.r + eps)return 0;\n\telse return 1;\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n//??????????????????????????¢???\nld two_circle_area(const Circle&l, const Circle&r) {\n\tld dis = abs(l.p - r.p);\n\tif (dis > l.r + r.r)return 0;\n\telse if (dis + r.r < l.r) {\n\t\treturn r.r*r.r*pi;\n\t}\n\telse if (dis + l.r < r.r) {\n\t\treturn l.r*l.r*pi;\n\t}\n\telse {\n\t\tld ans = (l.r)*(l.r)*acos((dis*dis + l.r*l.r - r.r*r.r) / (2 * dis*l.r)) +\n\t\t\t(r.r)*(r.r)*acos((dis*dis + r.r*r.r - l.r*l.r) / (2 * dis*r.r)) -\n\t\t\tsqrt(4 * dis*dis*l.r*l.r - (dis*dis + l.r*l.r - r.r*r.r)*(dis*dis + l.r*l.r - r.r*r.r)) / 2;\n\t\treturn ans;\n\t}\n\n}\n\n/* ????§???¢ */\n\ntypedef vector<Point> Polygon;\n\n// ??¢???\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// ????§???¢????????¢??????\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// ??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//??????????????????2?????????\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// ??????\n// ???????????????????????¨????????????????????§??¨???\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n// ????????????\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ Q,R };\n\treturn polys;\n}\n\n\n/* ??¢??¬??????????????? */\nvoid add_point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, static_cast<Weight>(abs(p[from] - p[to])));\n\t\t}\n\t}\n\treturn g;\n}\nGraph sennbunn_arrangement(const vector<Line>&s) {\n\tvector<Point>crss;\n\tfor (int i = 0; i < static_cast<int>(s.size()); ++i) {\n\t\tfor (int j = i + 1; j < static_cast<int>(s.size()); ++j) {\n\t\t\tif (isis_ss(s[i], s[j])) {\n\t\t\t\tcrss.push_back(is_ll(s[i], s[j]));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i <static_cast<int>(s.size()); ++i) {\n\t\tcrss.push_back(s[i][0]);\n\t\tcrss.push_back(s[i][1]);\n\t}\n\treturn segment_arrangement(s, crss);\n}\n\n//Graph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n//\tint n = p.size(), m = c.size();\n//\tGraph g(n);\n//\tREP(i, m) {\n//\t\tvector<pair<ld, int>> vec;\n//\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n//\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n//\t\tsort(ALL(vec));\n//\t\tREP(j, vec.size() - 1) {\n//\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n//\t\t\tld angle = vec[j + 1].first - vec[j].first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t\tif (vec.size() >= 2) {\n//\t\t\tint from = vec.back().second, to = vec.front().first;\n//\t\t\tld angle = vec.front().first - vec.back().first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\n/* ????????°?????? */\n\n// ?????????????????¢?????¢??¬??????????????????????????????????????°???????????????\n// ?????´?????????????¨?????????§????????´????????????????¨?????????§???????????????\n// ?????° polygon ??????vector<int> ??§??¨?????????????§???¢???????????§?????????\n// vector<int> ??§??¨????????? ????§???¢???i???????????????????????????????????????p????????????????????§?????????\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\npair<int,Graph> dual_graph(const vector<Line> &s, const vector<Point> &p) {\n\tint N = p.size();\n\tpolygon.clear();\n\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n\tvector<vector<tuple<ld, int, bool>>> tup(N);\n\tREP(i, s.size()) {\n\t\tint a = -1, b = -1;\n\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n\t\tassert(a >= 0 && b >= 0);\n\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n\t}\n\tREP(i, N) sort(ALL(tup[i]));\n\tREP(i, N) {\n\t\tREP(j, tup[i].size()) {\n\t\t\tld angle; int pos = j, from = i, to; bool flag;\n\t\t\ttie(angle, to, flag) = tup[i][j];\n\t\t\tif (flag) continue;\n\t\t\tvector<int> ps;\n\t\t\twhile (!flag) {\n\t\t\t\tps.push_back(from);\n\t\t\t\tget<2>(tup[from][pos]) = true;\n\t\t\t\tseg2p[from][to].push_back(polygon.size());\n\t\t\t\tseg2p[to][from].push_back(polygon.size());\n\t\t\t\tangle += pi + eps;\n\t\t\t\tif (angle > pi) angle -= 2 * pi;\n\t\t\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n\t\t\t\tif (it == tup[to].end()) it = tup[to].begin();\n\t\t\t\tfrom = to; tie(angle, to, flag) = *it;\n\t\t\t\tpos = it - tup[from].begin();\n\t\t\t}\n\t\t\tpolygon.push_back(ps);\n\t\t}\n\t}\n\tint aa=0;\n\tld amax = 0;\n\tfor (int i = 0; i < int(polygon.size()); ++i) {\n\t\tvector<Point>ps;\n\t\tfor (auto id : polygon[i]) {\n\t\t\tps.push_back(p[id]);\n\t\t}\n\t\tld aarea = area(p);\n\t\tif (amax < aarea) {\n\t\t\taa = i;\n\t\t\tamax = aarea;\n\t\t}\n\t}\n\tGraph g(polygon.size());\n\tREP(i, N) REP(j, i) {\n\t\tif (seg2p[i][j].size() == 2) {\n\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n\t\t\tg[from].push_back(Edge{ from, to,1 });\n\t\t\tg[to].push_back(Edge{ to, from,1 });\n\t\t}\n\t}\n\treturn make_pair(aa,g);\n}\n\n\nint main() {\n\twhile (1) {\n\t\tint C, W; cin >> C >> W;\n\t\tif (!C)break;\n\t\tvector<Point>ps;\n\t\tfor (int i = 0; i < C; ++i) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tps.emplace_back(x, y);\n\t\t}\n\t\tvector<Line>ls;\n\t\tfor (int i = 0; i < W; ++i) {\n\t\t\tint s, t; cin >> s >> t; s--; t--;\n\t\t\tls.emplace_back(ps[s], ps[t]);\n\t\t}\n\t\tauto p=dual_graph(ls, ps);\n\t\tGraph g = p.second;\n\t\tconst int start = p.first;\n\t\tvector<int>oks(g.size());\n\t\tqueue<pair<int, int>>que;\n\t\tque.push(make_pair(start, 0));\n\t\toks[start] = true;\n\t\tint ans = 0;\n\t\twhile (!que.empty()) {\n\t\t\tauto p(que.front());\n\t\t\tque.pop();\n\t\t\tans = p.second;\n\t\t\tfor (auto e : g[p.first]) {\n\t\t\t\tif (!oks[e.dst]) {\n\t\t\t\t\toks[e.dst] = true;\n\t\t\t\t\tque.push(make_pair(e.dst, p.second + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<complex>\n#include<deque>\n#include<vector>\nusing namespace std;\ndouble eps=1e-7;\ndouble x[110];\ndouble y[110];\ndouble px[700];\ndouble py[700];\nint ijk[700];\nint v[700];\nint g[700][700];\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ndouble PI=3.14159265358;\ntypedef complex<double> P;\ntypedef vector<P> G;\n\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n#define se second\n#define fi first\n\nbool intersectSS(const pair<P,P> &s, const pair<P,P> &t) {\n  return ccw(s.fi,s.se,t.fi)*ccw(s.fi,s.se,t.se) <= 0 &&\n         ccw(t.fi,t.se,s.fi)*ccw(t.fi,t.se,s.se) <= 0;\n}\n\nP pt[700];\nP ps[300];\nint s[400];\nint t[400];\ndouble left[400];\ndouble right[400];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<a;i++)scanf(\"%lf%lf\",x+i,y+i);\n\t\tfor(int i=0;i<a;i++){\n\t\t\tdouble X=cos(1)*x[i]-sin(1)*y[i];\n\t\t\tdouble Y=sin(1)*x[i]+cos(1)*y[i];\n\t\t\tx[i]=X;\n\t\t\ty[i]=Y;\n\t\t\tps[i]=P(x[i],y[i]);\n\t\t}\n\t\tfor(int i=0;i<b;i++){\n\t\t\tint p,q;scanf(\"%d%d\",&p,&q);\n\t\t\tp--;q--;\n\t\t\ts[i]=p;t[i]=q;\n\t\t\tpx[i*2]=(x[p]+x[q])/2+eps;\n\t\t\tpy[i*2]=(y[p]+y[q])/2;\n\t\t\tpx[i*2+1]=(x[p]+x[q])/2-eps;\n\t\t\tpy[i*2+1]=(y[p]+y[q])/2;\n\t\t\tpt[i*2]=P(px[i*2],py[i*2]);\n\t\t\tpt[i*2+1]=P(px[i*2+1],py[i*2+1]);\n\t\t}\n\t\t\tdeque<pair<int,int> >Q;\n\t\t\n\t\tfor(int i=0;i<b*2;i++){\n\t\t\tijk[i]=999999999;\n\t\t\tv[i]=0;\n\t\t\tbool OK=true;\n\t\t\tint tt=s[i/2];\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tif(tt==s[j]||tt==t[j])continue;\n\t\t\t\tif(intersectSS(make_pair(ps[tt],ps[tt]+(pt[i]-ps[tt])*10000.0),make_pair(ps[s[j]],ps[t[j]]))){\n\t\t\t\t\tOK=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(OK){\n\t\t//\t\tprintf(\" %d\\n\",i);\n\t\t\t\tijk[i]=0;\n\t\t\t\tQ.push_back(make_pair(0,i));\n\t\t\t}\n\t\t\tfor(int j=i+1;j<b*2;j++){\n\t\t\t\tint cnt=0;\n\t\t\t\tfor(int k=0;k<b;k++){\n\t\t\t\t\tif(intersectSS(make_pair(ps[s[k]],ps[t[k]]),make_pair(pt[i],pt[j]))){\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tif(cnt>1)break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(cnt<2)g[i][j]=g[j][i]=cnt;\n\t\t\t\telse g[i][j]=g[j][i]=999999999;\n\t\t\t}\n\t\t}\n\t\n\t\twhile(Q.size()){\n\t\t\tint cost=-Q.front().first;\n\t\t\tint at=Q.front().second;Q.pop_front();\n\t\t\tif(v[at])continue;\n\t\t\tv[at]=1;\n\t\t\tfor(int i=0;i<b*2;i++){\n\t\t\t\tif(!v[i]&&ijk[i]>cost+g[at][i]){\n\t\t\t\t\tijk[i]=cost+g[at][i];\n\t\t\t\t\tif(g[at][i]==1)Q.push_back(make_pair(-ijk[i],i));\n\t\t\t\t\telse Q.push_front(make_pair(-ijk[i],i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret=0;\n\t\tfor(int i=0;i<b*2;i++)ret=max(ret,ijk[i]);\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<int,pair<bool,double>> P2;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define min_3(a,b,c) min(a,min(b,c))\n#define max_3(a,b,c) max(a,max(b,c))\n#define mp1(a,b,c) P1(a,P(b,c))\n#define mp2(a,b,c) P2(a,pair<bool,double>(b,c))\n#define pque(a) priority_queue<a>\n#define rpque(a) priority_queue<a,vector<a>,greater<a>>\n\nconst int INF=1000000000;\nconst int dre_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dre_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\nconst int kaijou[10]={1,1,2,6,24,120,720,5040,40320,362880};\n\nbool com(P2 x,P2 y){\n\tif(x.sc.fr!=y.sc.fr)return x.sc.fr;\n\treturn x.sc.sc>=y.sc.sc;\n}\n\nint main(){\n\twhile(1){\n\t\tint c,w;\n\t\tint x[110],y[110];\n\t\tint s,t;\n\t\t\n\t\tscanf(\"%d%d\",&c,&w); if(c==0&&w==0)break;\n\t\trep1(i,c)scanf(\"%d%d\",&x[i],&y[i]);\n\t\t\n\t\tvector<P1> V_;\n\t\trep1(i,c){\n\t\t\tV_.pb(mp1(x[i],y[i],i));\n\t\t}\n\t\tsor(V_);\n\t\tvector<P2> vec_[110];\n\t\trep1(i,c){\n\t\t\tvec_[i].pb(mp2(0,false,-INF));\n\t\t\trep1(j,c){\n\t\t\t\tif(i==j)continue;\n\t\t\t\tif(x[i]<x[j]){\n\t\t\t\t\tvec_[i].pb(mp2(j,true,(double)(y[j]-y[i])/(x[j]-x[i])));\n\t\t\t\t}\n\t\t\t\telse if(x[i]>x[j]){\n\t\t\t\t\tvec_[i].pb(mp2(j,false,(double)(y[j]-y[i])/(x[j]-x[i])));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(y[j]>y[i])vec_[i].pb(mp2(j,true,(double)INF));\n\t\t\t\t\telse vec_[i].pb(mp2(j,true,(double)-INF));\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(vec_[i].begin(),vec_[i].end(),com);\n\t\t}\n\t\t\n\t\tint v,e;\n\t\tvector<int> V;\n\t\tbool edge[110][110];\n\t\tvector<int> vec[110];\n\t\t\n\t\tv=c; e=w;\n\t\trep(i,c)V.pb(V_[i].sc.sc);\n\t\trep(i,110)rep(j,110)edge[i][j]=false;\n\t\trep(i,e){\n\t\t\tscanf(\"%d%d\",&s,&t);\n\t\t\tedge[s][t]=true;\n\t\t\tedge[t][s]=true;\n\t\t}\n\t\trep1(i,c){\n\t\t\trep(j,vec_[i].size()){\n\t\t\t\tvec[i].pb(vec_[i][j].fr);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ret=0;\n\t\twhile(e>0){\n\t\t\tret++;\n\t\t\t\n\t\t\tint a=-1;\n\t\t\trep(i,V.size()){\n\t\t\t\trep(j,110){\n\t\t\t\t\tif(edge[V[i]][j]){a=V[i]; break;}\n\t\t\t\t}\n\t\t\t\tif(a!=-1)break;\n\t\t\t}\n\t\t\t\n\t\t\tint b=0,c=a;\n\t\t\twhile(1){\n\t\t\t\trep(i,vec[c].size()){\n\t\t\t\t\tif(vec[c][i]==b){\n\t\t\t\t\t\ti++; i%=vec[c].size();\n\t\t\t\t\t\twhile(!edge[c][vec[c][i]]){\n\t\t\t\t\t\t\ti++; i%=vec[c].size();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tedge[c][vec[c][i]]=false;\n\t\t\t\t\t\tedge[vec[c][i]][c]=false;\n\t\t\t\t\t\te--;\n\t\t\t\t\t\tb=c;\n\t\t\t\t\t\tc=vec[c][i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(c==a)break;\n\t\t\t}\n\t\t\t\n\t\t\tbool updata=true;\n\t\t\twhile(updata){\n\t\t\t\tupdata=false;\n\t\t\t\trep(i,110){\n\t\t\t\t\tint cnt=0;\n\t\t\t\t\tint t=-1;\n\t\t\t\t\trep(j,110){\n\t\t\t\t\t\tif(edge[i][j]){cnt++; t=j;}\n\t\t\t\t\t}\n\t\t\t\t\tif(cnt==1){\n\t\t\t\t\t\tupdata=true;\n\t\t\t\t\t\tedge[i][t]=false;\n\t\t\t\t\t\tedge[t][i]=false;\n\t\t\t\t\t\te--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<utility>\n#include<map>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n\nusing namespace std;\n\nstruct Point{\n\tint x,y;\n\tint id;\n\tPoint(){}\n\tPoint(int a,int b,int c):x(a),y(b),id(c){}\n};\n\nPoint points[110];\nint pid[110];\n\nbool cmp(const Point &p1,const Point &p2)\n{\n\tif(p1.x!=p2.x) return p1.x<p2.x;\n\treturn p1.y<p2.y;\n}\n\nint center;\n\nbool cmp_angle(const int &id1,const int &id2)\n{\n\tint center=pid[::center];\n\tint id1_=pid[id1],id2_=pid[id2];\n\tint dx1=points[id1_].x-points[center].x;\n\tint dy1=points[id1_].y-points[center].y;\n\tint dx2=points[id2_].x-points[center].x;\n\tint dy2=points[id2_].y-points[center].y;\n\t//(-y,x)\n\tdouble ang1=atan2(dx1,-dy1);\n\tdouble ang2=atan2(dx2,-dy2);\n\treturn ang1<ang2;\n}\n\nvector<int> G[110];\n\nvector<vector<int> > vs;\nvector<int> dG[750];\n\ntypedef pair<int,int> P;\n\nmap<P,int> cnt;\nqueue<P> que;\n\nvoid init()\n{\n\tvs.clear();\n\tfor(int i=0;i<110;i++) G[i].clear();\n\tfor(int i=0;i<550;i++) dG[i].clear();\n\tcnt.clear();\n}\n\nvector<int> res;\nvoid stroke(int u,int v,int st)\n{\n\t//u->v\n\tP p=P(min(u,v),max(u,v));\n\tif(cnt[p]==0)\n\t{\n\t\tque.push(P(v,u));\n\t}\n\tcnt[p]++;\n\tif(v==st) return;\n\tif(u==st) res.push_back(u);\n\tres.push_back(v);\n\tcenter=v;\n\tint id=distance(G[v].begin(),lower_bound(G[v].begin(),G[v].end(),u,cmp_angle));\n\tif(id==G[v].size()-1) id=0;\n\telse id++;\n\tint nxt=G[v][id];\n\tstroke(v,nxt,st);\n}\n\nvoid getGraph(int W)\n{\n\tint n=0;\n\tint V=vs.size();\n\tfor(int i=0;i<V;i++) for(int j=i+1;j<V;j++)\n\t{\n\t\tint ni=vs[i].size(),nj=vs[j].size();\n\t\tbool flg=false;\n\t\tfor(int iid=0;iid<ni;iid++) for(int jid=0;jid<nj;jid++)\n\t\t{\n\t\t\tint niid=iid==ni-1?0:iid+1;\n\t\t\tint njid=jid==nj-1?0:jid+1;\n\t\t\tif(vs[i][iid]==vs[j][njid]&&vs[i][niid]==vs[j][jid])\n\t\t\t{\n\t\t\t\tflg=true;\n\t\t\t\tn++;\n\t\t\t}\n\t\t}\n\t\tif(flg)\n\t\t{\n\t\t\tdG[i].push_back(j);\n\t\t\tdG[j].push_back(i);\n\t\t}\n\t}\n}\n\nvector<int> outSide;\n\nint getMostOutSide()\n{\n\tint u=points[0].id;\n\tint v=G[u][0];\n\tfor(int i=0;i<vs.size();i++)\n\t{\n\t\tfor(int j=0;j+1<vs[i].size();j++)\n\t\t{\n\t\t\tif(vs[i][j]==u&&vs[i][j+1]==v) return i;\n\t\t}\n\t\tif(vs[i][vs[i].size()-1]==u&&vs[i][0]==v) return i;\n\t}\n\treturn -1;\n}\n\n\nint dis[750];\nqueue<int> bfs_que;\nvoid bfs(int s)\n{\n\twhile(!bfs_que.empty()) bfs_que.pop();\n\tbfs_que.push(s);\n\tfor(int i=0;i<750;i++) dis[i]=1<<29;\n\tdis[s]=0;\n\tbfs_que.push(s);\n\twhile(!bfs_que.empty())\n\t{\n\t\tint v=bfs_que.front();\n\t\tbfs_que.pop();\n\t\tfor(int i=0;i<dG[v].size();i++)\n\t\t{\n\t\t\tint u=dG[v][i];\n\t\t\tint nd=dis[v]+1;\n\t\t\tif(nd>=dis[u]) continue;\n\t\t\tdis[u]=nd;\n\t\t\tbfs_que.push(u);\n\t\t}\n\t}\n}\n\n\nint main()\n{\n\twhile(true)\n\t{\n\t\tint C,W;\n\t\tscanf(\"%d%d\",&C,&W);\n\t\tif(C==0) break;\n\t\tinit();\n\t\tfor(int i=0;i<C;i++)\n\t\t{\n\t\t\tint x,y;\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\tpoints[i]=Point(x,y,i);\n\t\t}\n\t\tsort(points,points+C,cmp);\n\t\tfor(int i=0;i<C;i++) pid[points[i].id]=i;\n\t\tint su=-1,sv=-1;\n\t\tfor(int i=0;i<W;i++)\n\t\t{\n\t\t\tint u,v;\n\t\t\tscanf(\"%d%d\",&u,&v);\n\t\t\tu--;v--;\n\t\t\tG[u].push_back(v);\n\t\t\tG[v].push_back(u);\n\t\t\tsu=u,sv=v;\n\t\t}\n\t\tfor(int i=0;i<C;i++)\n\t\t{\n\t\t\tcenter=i;\n\t\t\tsort(G[i].begin(),G[i].end(),cmp_angle);\n\t\t}\n\t\tque.push(P(min(su,sv),max(su,sv)));\n\t\twhile(!que.empty())\n\t\t{\n\t\t\tP p=que.front();\n\t\t\tque.pop();\n\t\t\tint u=p.first,v=p.second;\n\t\t\tP pp=P(min(u,v),max(u,v));\n\t\t\tif(cnt[pp]==2) continue;\n\t\t\tres.clear();\n\t\t\tstroke(u,v,u);\n\t\t\tvs.push_back(res);\n\t\t}\n\t\tif(cnt.size()<W) for(;;);\n\t\tgetGraph(W);\n\t\tint out=getMostOutSide();\n\t\tbfs(out);\n\t\tint ans=0;\n\t\tfor(int i=0;i<vs.size();i++) ans=max(ans,dis[i]);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<math.h>\n#include<complex>\n#include<queue>\n\nusing namespace std;\n#define rep(i,n) for(int i = 0 ; i < n ; ++i)\nusing ll = long long;\nusing ld = long double;\nusing Point = complex<ld>;\nconst ld eps = 1e-9;\n\nld cross(Point a,Point b){\n    return imag(conj(a)*b);\n}\n\n\nvoid solve(int n,int m){\n    vector<Point> p(n);\n    rep(i,n){\n        int x,y;\n        cin>>x>>y;\n        p[i]=Point(x,y);\n    }\n    vector<vector<int>> v(m);\n    rep(i,m){\n        int x,y;\n        cin>>x>>y;\n        --x;--y;\n        v[x].push_back(y);\n        v[y].push_back(x);\n    }\n    vector<vector<int>> used(n);\n    rep(i,n){\n        sort(v[i].begin(),v[i].end(),[&](int x,int y){\n            return arg(p[x]-p[i])<arg(p[y]-p[i]);\n        });\n        used[i].resize(v[i].size());\n    }\n    vector<vector<int>> pols;\n    rep(i,n){\n        int s = v[i].size();\n        rep(j,s){\n            if(used[i][j])continue;\n            vector<int> pol;\n            pol.push_back(i);\n            int cur = i;\n            int nxt = v[i][j];\n            used[i][j]=true;\n            while(nxt!=i){\n                pol.push_back(nxt);\n                int idx = 0;\n                while(v[nxt][idx]!=cur)++idx;\n                idx = (idx+1)%v[nxt].size();\n                used[nxt][idx]=true;\n                cur = nxt;\n                nxt = v[cur][idx];\n            }\n            ld sum = 0;\n            rep(k,pol.size()){\n                sum += cross(p[pol[k]],p[pol[(k+1)%pol.size()]]);\n            }\n            if(sum<0)pols.push_back(pol);\n        }\n    }\n    int sz = pols.size();\n    vector<vector<int>> vs(sz+1);\n    rep(i,sz){\n        int s = pols[i].size();\n        rep(j,s){\n            Point ext = (ld).5*(p[pols[i][(j+1)%s]]+p[pols[i][j]])\n                            + Point(0,1)*eps*(p[pols[i][(j+1)%s]]-p[pols[i][j]]);\n            int nxt = sz;\n            rep(k,sz){\n                ld sum = 0;\n                rep(t,pols[k].size()){\n                    sum += arg((p[pols[k][(t+1)%pols[k].size()]]-ext)/(p[pols[k][t]]-ext));\n                }\n                if(abs(sum)>3){\n                    nxt=k;\n                    break;\n                }\n            }\n            vs[nxt].push_back(i);\n            vs[i].push_back(nxt);\n        }\n    }\n    vector<int> dist(sz+1,10000);\n    dist[sz]=0;\n    queue<int> q;\n    q.push(sz);\n    int ans = 0;\n    while(q.size()){\n        int cur = q.front();q.pop();\n        ans = max(ans,dist[cur]);\n        for(auto to : vs[cur]){\n            if(dist[to]>dist[cur]+1){\n                dist[to]=dist[cur]+1;\n                q.push(to);\n            }\n        }\n    }\n    cout<<ans<<endl;\n}\n\n\n\nint main(){\n    int n,m;\n    while(cin>>n>>m,n!=0)solve(n,m);\n    \n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Point\n{\n\tfinal double X;\n\tfinal double Y;\n\n\tpublic Point( double x, double y )\n\t{\n\t\tX = x;\n\t\tY = y;\n\t\treturn;\n\t}\n\n\tpublic Point minus( final Point p )\n\t{\n\t\treturn new Point( X - p.X, Y - p.Y );\n\t}\n\n\tpublic double dot( final Point p )\n\t{\n\t\treturn X * p.X + Y * p.Y;\n\t}\n\n\tpublic double cross( final Point p )\n\t{\n\t\treturn X * p.Y - Y * p.X;\n\t}\n\n\tpublic double arg()\n\t{\n\t\treturn Math.atan2( Y, X );\n\t}\n}\n\nclass Edge\n{\n\tfinal int to;\n\tfinal int rev;\n\tfinal int id;\n\tfinal Point angle;\n\n\tpublic Edge( int t, int r, int i, Point a )\n\t{\n\t\tto = t;\n\t\trev = r;\n\t\tid = i;\n\t\tangle = a;\n\t\treturn;\n\t}\n}\n\n// public class DualGraphBuilder\nclass DualGraphBuilder\n{\n\tfinal int N;\n\tint M;\n\n\tfinal ArrayList< Point > ps_;\n\tfinal ArrayList< ArrayList< Edge > > G;\n\tfinal ArrayList< ArrayList< Integer > > edge_indices_, edge_positions_;\n\tfinal ArrayList< ArrayList< Boolean > > used_;\n\n\tint outer_ = -1;\n\tfinal ArrayList< ArrayList< Point > > areas_;\n\n\tArrayList< ArrayList< Integer > > intersects_;\n\n\n\tpublic DualGraphBuilder( final ArrayList< ArrayList< Double > > coordinates )\n\t{\n\t\tN = coordinates.size();\n\t\tM = 0;\n\t\tps_ = new ArrayList< Point >( N );\n\n\t\tG = new ArrayList< ArrayList< Edge > >( N );\n\t\tfor ( int i = 0; i < N; ++i )\n\t\t{\n\t\t\tG.add( new ArrayList< Edge >() );\n\t\t}\n\n\t\tedge_indices_ = new ArrayList< ArrayList< Integer > >( N );\n\t\tfor ( int i = 0; i < N; ++i )\n\t\t{\n\t\t\tedge_indices_.add( new ArrayList< Integer >() );\n\t\t}\n\n\t\tedge_positions_ = new ArrayList< ArrayList< Integer > >( Collections.nCopies( N, null ) );\n\t\tused_ = new ArrayList< ArrayList< Boolean > >( Collections.nCopies( N, null ) );\n\t\tareas_ = new ArrayList< ArrayList< Point > >();\n\n\t\tfor ( ArrayList< Double > p : coordinates )\n\t\t{\n\t\t\tps_.add( new Point( p.get( 0 ), p.get( 1 ) ) );\n\t\t}\n\n\t\treturn;\n\t}\n\n\tpublic void connect( final int a, final int b )\n\t{\n\t\tG.get( a ).add( new Edge( b, G.get( b ).size(), M, ps_.get( b ).minus( ps_.get( a ) ) ) );\n\t\tG.get( b ).add( new Edge( a, G.get( a ).size() - 1, M, ps_.get( a ).minus( ps_.get( b ) ) ) );\n\t\t++M;\n\n\t\treturn;\n\t}\n\n\tpublic void solve()\n\t{\n\t\tsortEdges();\n\n\t\tfor ( int v = 0; v < N; ++v )\n\t\t{\n\t\t\tfor ( int i = 0; i < G.get( v ).size(); ++i )\n\t\t\t{\n\t\t\t\tif ( used_.get( v ).get( i ) )\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tdfs( v, i );\n\t\t\t}\n\t\t}\n\n\t\treturn;\n\t}\n\n\tprivate void sortEdges()\n\t{\n\t\tfor ( int v = 0; v < N; ++v )\n\t\t{\n\t\t\tedge_indices_.get( v ).ensureCapacity( G.get( v ).size() );\n\t\t\tfor ( int i = 0; i < G.get( v ).size(); ++i )\n\t\t\t{\n\t\t\t\tedge_indices_.get( v ).add( i );\n\t\t\t}\n\n\t\t\tfinal int vv = v;\n\t\t\tCollections.sort( edge_indices_.get( v ), ( Integer i, Integer j )->\n\t\t\t\t\tDouble.compare( G.get( vv ).get( i ).angle.arg(), G.get( vv ).get( j ).angle.arg() ) );\n\n\t\t\tedge_positions_.set( v, new ArrayList< Integer >( Collections.nCopies( G.get( v ).size(), 0 ) ) );\n\t\t\tfor ( int i = 0; i < G.get( v ).size(); ++i )\n\t\t\t{\n\t\t\t\tedge_positions_.get( v ).set( edge_indices_.get( v ).get( i ), i );\n\t\t\t}\n\n\t\t\tused_.set( v, new ArrayList< Boolean >( Collections.nCopies( G.get( v ).size(), false ) ) );\n\t\t}\n\n\t\tintersects_ = new ArrayList< ArrayList< Integer > >( M );\n\t\tfor ( int i = 0; i < M; ++i )\n\t\t{\n\t\t\tintersects_.add( new ArrayList< Integer >() );\n\t\t}\n\n\t\treturn;\n\t}\n\n\tprivate void dfs( final int sv, final int se )\n\t{\n\t\tArrayList< Point > area = new ArrayList< Point >();\n\n\t\tfor ( int v = sv, e = se; area.isEmpty() || v != sv; )\n\t\t{\n\t\t\tused_.get( v ).set( e, true );\n\t\t\tarea.add( ps_.get( v ) );\n\t\t\tintersects_.get( G.get( v ).get( e ).id ).add( areas_.size() );\n\n\t\t\tfinal int r = G.get( v ).get( e ).rev;\n\t\t\tv = G.get( v ).get( e ).to;\n\t\t\te = edge_indices_.get( v ).get( ( edge_positions_.get( v ).get( r ) + G.get( v ).size() - 1 ) % G.get( v ).size() );\n\t\t}\n\n\t\t{\n\t\t\tdouble theta = 0;\n\t\t\tfor ( int i = 0; i < area.size(); ++i )\n\t\t\t{\n\t\t\t\tfinal Point p1 = area.get( ( i + 1 ) % area.size() ).minus( area.get( i ) );\n\t\t\t\tfinal Point p2 = area.get( ( i + 2 ) % area.size() ).minus( area.get( ( i + 1 ) % area.size() ) );\n\t\t\t\ttheta += Math.atan2( p1.cross( p2 ), p1.dot( p2 ) );\n\t\t\t}\n\t\t\tif ( theta < 0 )\n\t\t\t{\n\t\t\t\touter_ = areas_.size();\n\t\t\t}\n\t\t}\n\n\t\tareas_.add( area );\n\n\t\treturn;\n\t}\n\n\tpublic int areaNumber()\n\t{\n\t\treturn areas_.size();\n\t}\n\n\tpublic ArrayList< ArrayList< Point > > areas()\n\t{\n\t\treturn areas_;\n\t}\n\n\tpublic ArrayList< ArrayList< Integer > > edges()\n\t{\n\t\tArrayList< ArrayList< Integer > > res = new ArrayList< ArrayList< Integer > >( intersects_.size() );\n\t\tfor ( ArrayList< Integer > row : intersects_ )\n\t\t{\n\t\t\tArrayList< Integer > r = new ArrayList< Integer >( 2 );\n\t\t\tr.add( row.get( 0 ) );\n\t\t\tr.add( row.get( 1 ) );\n\t\t\tres.add( r );\n\t\t}\n\t\treturn res;\n\t}\n\n\tpublic int outer()\n\t{\n\t\treturn outer_;\n\t}\n\n}\n\nclass Main\n{\n\tpublic static void main( String[] args )\n\t{\n\t\tScanner scanner = new Scanner( System.in );\n\n\t\twhile ( true )\n\t\t{\n\t\t\tfinal int N = scanner.nextInt();\n\t\t\tfinal int M = scanner.nextInt();\n\t\t\t\n\t\t\tif ( N == 0 && M == 0 )\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tArrayList< ArrayList< Double > > coordinates = new ArrayList< ArrayList< Double > >( N );\n\t\t\tfor ( int i = 0; i < N; ++i )\n\t\t\t{\n\t\t\t\tfinal int X = scanner.nextInt();\n\t\t\t\tfinal int Y = scanner.nextInt();\n\t\t\t\tArrayList< Double > row = new ArrayList< Double >( 2 );\n\t\t\t\trow.add( (double)X );\n\t\t\t\trow.add( (double)Y );\n\t\t\t\tcoordinates.add( row );\n\t\t\t}\n\n\t\t\tDualGraphBuilder dualgraph = new DualGraphBuilder( coordinates );\n\t\t\tfor ( int i = 0; i < M; ++i )\n\t\t\t{\n\t\t\t\tfinal int u = scanner.nextInt() - 1;\n\t\t\t\tfinal int v = scanner.nextInt() - 1;\n\t\t\t\tdualgraph.connect( u, v );\n\t\t\t}\n\t\t\tdualgraph.solve();\n\n\t\t\tfinal int dN = dualgraph.areaNumber();\n\t\t\tArrayList< ArrayList< Integer > > dG = new ArrayList< ArrayList< Integer > >( dN );\n\t\t\tfor ( int i = 0; i < dN; ++i )\n\t\t\t{\n\t\t\t\tdG.add( new ArrayList< Integer >() );\n\t\t\t}\n\n\t\t\tfor ( ArrayList< Integer > e : dualgraph.edges() )\n\t\t\t{\n\t\t\t\tfinal int u = e.get( 0 );\n\t\t\t\tfinal int v = e.get( 1 );\n\t\t\t\tdG.get( u ).add( v );\n\t\t\t\tdG.get( v ).add( u );\n\t\t\t}\n\n\t\t\tfinal int INF = dN * 2;\n\t\t\tfinal int s = dualgraph.outer();\n\n\t\t\tArrayList< Integer > distances = new ArrayList< Integer >( dN );\n\t\t\tfor ( int i = 0; i < dN; i++ )\n\t\t\t{\n\t\t\t\tdistances.add( INF );\n\t\t\t}\n\t\t\tdistances.set( s, 0 );\n\n\t\t\tQueue< Integer > que = new ArrayDeque< Integer >();\n\t\t\tque.add( s );\n\n\t\t\twhile ( !que.isEmpty() )\n\t\t\t{\n\t\t\t\tfinal int u = que.poll();\n\n\t\t\t\tfor ( int v : dG.get( u ) )\n\t\t\t\t{\n\t\t\t\t\tif ( distances.get( v ).equals( INF ) )\n\t\t\t\t\t{\n\t\t\t\t\t\tdistances.set( v, distances.get( u ) + 1 );\n\t\t\t\t\t\tque.add( v );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfinal int res = Collections.max( distances );\n\t\t\tSystem.out.printf( \"%d\\n\", res );\n\t\t}\n\n\t\treturn;\n\t}\n}"
  },
  {
    "language": "Ruby",
    "code": "### subroutines\n\ndef make_area(an, w)\n  w[3] = an\n  area = [w]\n\n  start = w[0]\n\n  while w[1] != start\n    c1 = w[1]\n    w1 = w[4]\n    links1 = $links[c1]\n    nl1 = links1.length\n\n    wi = links1.index(w1)\n\n    w = links1[(wi + nl1 - 1) % nl1]\n    w[3] = an\n    area << w\n  end\n\n  area\nend\n\n### main\n\nwhile true\n  $cn, $wn = gets.strip.split(' ').map{|s| s.to_i}\n  break if $cn == 0 && $wn == 0\n\n  $clmns = $cn.times.map{gets.strip.split(' ').map{|s| s.to_i}}\n\n  $walls = $cn.times.map{[]}\n  $links =  $cn.times.map{[]}\n\n  $wn.times do\n    c0, c1 = gets.strip.split(' ').map{|s| s.to_i}\n    c0 -= 1\n    c1 -= 1\n\n    x0, y0 = $clmns[c0]\n    x1, y1 = $clmns[c1]\n\n    w0 = $walls[c0][c1] = [c0, c1, Math.atan2(y1 - y0, x1 - x0), nil]\n    w1 = $walls[c1][c0] = [c1, c0, Math.atan2(y0 - y1, x0 - x1), nil]\n    w0[4] = w1\n    w1[4] = w0\n\n    $links[c0] << w0\n    $links[c1] << w1\n  end\n  #p $walls\n\n  for c in (0...$cn)\n    $links[c].sort!{|wa, wb| wa[2] <=> wb[2]}\n  end\n  #p $links\n\n  an = 0\n  $areas = []\n\n  for ci in (0...$cn)\n    for wi in $links[ci].each_index\n      w = $links[ci][wi]\n      if w[3].nil?\n        $areas << make_area(an, w)\n        an += 1\n      end\n    end\n  end\n  #p an\n  #$areas.each{|ar| p ar.map{|w| $clmns[w[0]]}}\n\n  cimin = (0...$cn).min{|a, b| $clmns[a] <=> $clmns[b]}\n  s_area = $links[cimin].last[3]\n  #p cimin\n  #p s_area\n\n  dists = an.times.map{an + 1}\n  dists[s_area] = 0\n  visited = []\n  visited[s_area] = 1\n\n  q = [s_area]\n\n  while ! q.empty?\n    a0 = q.shift\n\n    for w0 in $areas[a0]\n      a1 = w0[4][3]\n      if visited[a1].nil?\n        visited[a1] = 1\n        dists[a1] = dists[a0] + 1\n        q << a1\n      end\n    end\n  end\n\n  puts dists.max\nend"
  },
  {
    "language": "Ruby",
    "code": "### subroutines\n\ndef make_area(an, w)\n  w[3] = an\n  area = [w]\n\n  start = w[0]\n\n  while w[1] != start\n    c1 = w[1]\n    w1 = w[4]\n    links1 = $links[c1]\n    nl1 = links1.length\n\n    wi = links1.index(w1)\n\n    w = links1[(wi + nl1 - 1) % nl1]\n    w[3] = an\n    area << w\n  end\n\n  area\nend\n\n### main\n\nwhile true\n  $cn, $wn = gets.strip.split(' ').map{|s| s.to_i}\n  break if $cn == 0 && $wn == 0\n\n  $clmns = $cn.times.map{gets.strip.split(' ').map{|s| s.to_i}}\n\n  $walls = $cn.times.map{[]}\n  $links =  $cn.times.map{[]}\n\n  $wn.times do\n    c0, c1 = gets.strip.split(' ').map{|s| s.to_i}\n    c0 -= 1\n    c1 -= 1\n\n    x0, y0 = $clmns[c0]\n    x1, y1 = $clmns[c1]\n\n    w0 = $walls[c0][c1] = [c0, c1, Math.atan2(y1 - y0, x1 - x0), nil]\n    w1 = $walls[c1][c0] = [c1, c0, Math.atan2(y0 - y1, x0 - x1), nil]\n    w0[4] = w1\n    w1[4] = w0\n\n    $links[c0] << w0\n    $links[c1] << w1\n  end\n  #p $walls\n\n  for c in (0...$cn)\n    $links[c].sort!{|wa, wb| wa[2] <=> wb[2]}\n  end\n  #p $links\n\n  an = 0\n  $areas = []\n\n  for ci in (0...$cn)\n    for wi in $links[c].each_index\n      w = $links[ci][wi]\n      if w[3].nil?\n        $areas << make_area(an, w)\n        an += 1\n      end\n    end\n  end\n  #p an\n  #$areas.each{|ar| p ar.map{|w| $clmns[w[0]]}}\n\n  cimin = (0...$cn).min{|a, b| $clmns[a] <=> $clmns[b]}\n  s_area = $links[cimin].last[3]\n  #p cimin\n  #p s_area\n\n  dists = an.times.map{an + 1}\n  dists[s_area] = 0\n  visited = []\n  visited[s_area] = 1\n\n  q = [s_area]\n\n  while ! q.empty?\n    a0 = q.shift\n\n    for w0 in $areas[a0]\n      a1 = w0[4][3]\n      if visited[a1].nil?\n        visited[a1] = 1\n        dists[a1] = dists[a0] + 1\n        q << a1\n      end\n    end\n  end\n\n  puts dists.max\nend"
  },
  {
    "language": "Ruby",
    "code": "### subroutines\n\ndef make_area(an, w)\n  w[3] = an\n  area = [w]\n\n  start = w[0]\n\n  while w[1] != start\n    c1 = w[1]\n    w1 = w[4]\n    links1 = $links[c1]\n    nl1 = links1.length\n\n    wi = links1.index(w1)\n\n    w = links1[(wi + nl1 - 1) % nl1]\n    w[3] = an\n    area << w\n  end\n\n  area\nend\n\n### main\n\nwhile true\n  $cn, $wn = gets.strip.split(' ').map{|s| s.to_i}\n  break if $cn == 0 && $wn == 0\n\n  $clmns = $cn.times.map{gets.strip.split(' ').map{|s| s.to_i}}\n\n  $walls = $cn.times.map{[]}\n  $links =  $cn.times.map{[]}\n\n  $wn.times do\n    c0, c1 = gets.strip.split(' ').map{|s| s.to_i}\n    c0 -= 1\n    c1 -= 1\n\n    x0, y0 = $clmns[c0]\n    x1, y1 = $clmns[c1]\n\n    w0 = $walls[c0][c1] = [c0, c1, Math.atan2(y1 - y0, x1 - x0), nil]\n    w1 = $walls[c1][c0] = [c1, c0, Math.atan2(y0 - y1, x0 - x1), nil]\n    w0[4] = w1\n    w1[4] = w0\n\n    $links[c0] << w0\n    $links[c1] << w1\n  end\n  #p $walls\n\n  for c in (0...$cn)\n    $links[c].sort!{|wa, wb| wa[2] <=> wb[2]}\n  end\n  #p $links\n\n  an = 0\n  $areas = []\n\n  for ci in (0...$cn)\n    for wi in $links[c].each_index\n      w = $links[ci][wi]\n      if w[3].nil?\n        $areas << make_area(an, w)\n        an += 1\n      end\n    end\n  end\n  #p an\n  #$areas.each{|ar| p ar.map{|w| $clmns[w[0]]}}\n\n  cimin = (0...$cn).min{|a, b| $clmns[a] <=> $clmns[b]}\n  s_area = $links[cimin].last[3]\n  #p cimin\n  #p s_area\n\n  dists = an.times.map{an + 1}\n  dists[s_area] = 0\n  visited = []\n  visited[s_area] = 1\n\n  q = [s_area]\n\n  while ! q.empty?\n    a0 = q.shift\n\n    for w0 in $areas[a0]\n      a1 = w0[4][3]\n      if visited[a1].nil?\n        visited[a1] = 1\n        dists[a1] = dists[a0] + 1\n        q << a1\n      end\n    end\n  end\n\n  puts dists.max\nend"
  },
  {
    "language": "Python",
    "code": "from math import atan2\nfrom collections import defaultdict, deque\ndef cross(a, b, c):\n    return (b[0]-a[0])*(c[1]-a[1]) - (b[1]-a[1])*(c[0]-a[0])\ndef convex_hull(ps):\n    qs = []\n    n = len(ps)\n    for p in ps:\n        while len(qs)>1 and cross(qs[-1], qs[-2], p) > 0:\n            qs.pop()\n        qs.append(p)\n    t = len(qs)\n    for i in range(n-2, -1, -1):\n        p = ps[i]\n        while len(qs)>t and cross(qs[-1], qs[-2], p) > 0:\n            qs.pop()\n        qs.append(p)\n    return qs\ndef outer_check(R, S):\n    cur = 0\n    for e in S:\n        if cur < len(R) and e == R[cur]:\n            cur += 1\n    return cur == len(R)\nwhile 1:\n    C, W = map(int, input().split())\n    if C == W == 0:\n        break\n    G0 = [[] for i in range(C)]\n    P = [list(map(int, input().split())) for i in range(C)]\n    P0 = [P[i] + [i] for i in range(C)]\n    P0.sort()\n    Q0 = convex_hull(P0)\n    R = list(map(lambda x: x[2], Q0))[:-1]\n    k = R.index(min(R))\n    R = R[k:] + R[:k]\n\n    for i in range(W):\n        s, t = map(int, input().split()); s -= 1; t -= 1\n        G0[s].append(t)\n        G0[t].append(s)\n    for i in range(C):\n        x0, y0 = P[i]\n        G0[i].sort(key = lambda p: atan2(P[p][1] - y0, P[p][0] - x0))\n    E = defaultdict(list)\n    cur = 0\n    for v in range(C):\n        for b, v0 in enumerate(G0[v]):\n            prv = v\n            st = [v]\n            while 1:\n                g = G0[v0]\n                c = (g.index(prv)+1) % len(g)\n                if v0 == v and c == b:\n                    break\n                st.append(v0)\n                prv = v0; v0 = g[c]\n\n            if min(st) == v and not outer_check(R, st):\n                for i in range(len(st)):\n                    p = st[i-1]; q = st[i]\n                    if not p < q:\n                        p, q = q, p\n                    E[p, q].append(cur)\n                cur += 1\n    G = [[] for i in range(cur+1)]\n    for es in E.values():\n        if len(es) == 2:\n            a, b = es\n        else:\n            a = es[0]; b = cur\n        G[a].append(b)\n        G[b].append(a)\n    D = [-1]*(cur+1)\n    D[cur] = 0\n    que = deque([cur])\n    while que:\n        v = que.popleft()\n        d = D[v]\n        for w in G[v]:\n            if D[w] != -1:\n                continue\n            D[w] = d+1\n            que.append(w)\n    print(max(D))\n\n"
  }
]