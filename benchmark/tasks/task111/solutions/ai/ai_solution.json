[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\ntypedef struct {\n    double x, y;\n} Point;\n\ntypedef struct {\n    Point p1, p2;\n} Wall;\n\nint cross_product(Point a, Point b, Point c) {\n    double val = (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n    if (fabs(val) < 1e-9) return 0;\n    return (val > 0) ? 1 : -1;\n}\n\nint is_point_on_segment(Point p, Point a, Point b) {\n    if (cross_product(p, a, b) != 0) return 0;\n    double min_x = fmin(a.x, b.x);\n    double max_x = fmax(a.x, b.x);\n    double min_y = fmin(a.y, b.y);\n    double max_y = fmax(a.y, b.y);\n    return (p.x >= min_x - 1e-9 && p.x <= max_x + 1e-9 && p.y >= min_y - 1e-9 && p.y <= max_y + 1e-9);\n}\n\nint do_segments_intersect(Point a1, Point a2, Point b1, Point b2) {\n    int cp1 = cross_product(a1, a2, b1);\n    int cp2 = cross_product(a1, a2, b2);\n    int cp3 = cross_product(b1, b2, a1);\n    int cp4 = cross_product(b1, b2, a2);\n\n    if (cp1 * cp2 < 0 && cp3 * cp4 < 0) return 1;\n    if (is_point_on_segment(a1, b1, b2)) return 1;\n    if (is_point_on_segment(a2, b1, b2)) return 1;\n    if (is_point_on_segment(b1, a1, a2)) return 1;\n    if (is_point_on_segment(b2, a1, a2)) return 1;\n    return 0;\n}\n\nint is_point_inside_polygon(Point p, Point* polygon, int n) {\n    if (n < 3) return 0;\n    Point extreme = {1e9, p.y};\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        int next = (i + 1) % n;\n        if (do_segments_intersect(polygon[i], polygon[next], p, extreme)) {\n            if (cross_product(polygon[i], polygon[next], p) == 0) {\n                return is_point_on_segment(p, polygon[i], polygon[next]);\n            }\n            count++;\n        }\n    }\n    return count % 2 == 1;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    Point* polygon = (Point*)malloc(N * sizeof(Point));\n    for (int i = 0; i < N; i++) {\n        scanf(\"%lf %lf\", &polygon[i].x, &polygon[i].y);\n    }\n\n    int max_holes = 0;\n    for (int i = 0; i < N; i++) {\n        int next = (i + 1) % N;\n        Point mid = {(polygon[i].x + polygon[next].x) / 2, (polygon[i].y + polygon[next].y) / 2};\n        int holes = 1;\n\n        Point* remaining_walls = (Point*)malloc((N - 2) * sizeof(Point));\n        int k = 0;\n        for (int j = 0; j < N; j++) {\n            if (j != i && j != next) {\n                remaining_walls[k++] = polygon[j];\n            }\n        }\n\n        while (is_point_inside_polygon(mid, remaining_walls, N - 2)) {\n            holes++;\n            int new_N = N - 2;\n            Point* new_polygon = (Point*)malloc(new_N * sizeof(Point));\n            int m = 0;\n            for (int j = 0; j < new_N; j++) {\n                new_polygon[m++] = remaining_walls[j];\n            }\n            free(remaining_walls);\n            remaining_walls = new_polygon;\n        }\n\n        free(remaining_walls);\n        if (holes > max_holes) {\n            max_holes = holes;\n        }\n    }\n\n    printf(\"%d\\n\", max_holes);\n    free(polygon);\n    return 0;\n}",
    "timestamp": "2025-08-05 18:39:28"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class CatEscape {\n    static class Point {\n        int x, y;\n        Point(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    static class Wall {\n        Point start, end;\n        int hole;\n        Wall(Point start, Point end, int hole) {\n            this.start = start;\n            this.end = end;\n            this.hole = hole;\n        }\n    }\n\n    public static int findMaxHolesTraversed(List<Wall> walls, List<Point> rooms) {\n        int n = rooms.size();\n        int[][] graph = new int[n][n];\n        \n        // Build graph of room connections\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                for (Wall wall : walls) {\n                    if (isRoomConnected(rooms.get(i), rooms.get(j), wall)) {\n                        graph[i][j] = graph[j][i] = wall.hole;\n                        break;\n                    }\n                }\n            }\n        }\n\n        // Floyd-Warshall to find max holes in paths\n        int[][] maxHoles = new int[n][n];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                maxHoles[i][j] = graph[i][j];\n            }\n        }\n\n        for (int k = 0; k < n; k++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    if (maxHoles[i][k] + maxHoles[k][j] > maxHoles[i][j]) {\n                        maxHoles[i][j] = maxHoles[i][k] + maxHoles[k][j];\n                    }\n                }\n            }\n        }\n\n        // Find max holes to outside\n        int maxHolesToOutside = 0;\n        for (int i = 0; i < n; i++) {\n            for (Wall wall : walls) {\n                if (isPointOutside(rooms.get(i), wall)) {\n                    maxHolesToOutside = Math.max(maxHolesToOutside, maxHoles[i][i]);\n                }\n            }\n        }\n\n        return maxHolesToOutside;\n    }\n\n    static boolean isRoomConnected(Point room1, Point room2, Wall wall) {\n        // Check if wall connects these two rooms\n        // Implement geometric intersection logic\n        return false;\n    }\n\n    static boolean isPointOutside(Point room, Wall wall) {\n        // Check if the room point is outside the mansion via this wall\n        // Implement geometric point-in-polygon logic\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        // Read input and setup rooms, walls\n        List<Wall> walls = new ArrayList<>();\n        List<Point> rooms = new ArrayList<>();\n        \n        int result = findMaxHolesTraversed(walls, rooms);\n        System.out.println(result);\n    }\n}",
    "timestamp": "2025-08-05 18:39:42"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\nstruct Point {\n    int x, y;\n    Point(int x = 0, int y = 0) : x(x), y(y) {}\n    bool operator==(const Point& other) const {\n        return x == other.x && y == other.y;\n    }\n};\n\nstruct Segment {\n    Point p1, p2;\n    Segment(Point p1, Point p2) : p1(p1), p2(p2) {}\n};\n\nint cross(const Point& a, const Point& b, const Point& c) {\n    return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n}\n\nbool isPointOnSegment(const Segment& s, const Point& p) {\n    if (cross(s.p1, s.p2, p) != 0) return false;\n    if (min(s.p1.x, s.p2.x) <= p.x && p.x <= max(s.p1.x, s.p2.x) &&\n        min(s.p1.y, s.p2.y) <= p.y && p.y <= max(s.p1.y, s.p2.y)) {\n        return true;\n    }\n    return false;\n}\n\nbool isInside(const vector<Point>& polygon, const Point& p) {\n    int n = polygon.size();\n    if (n < 3) return false;\n    bool inside = false;\n    for (int i = 0, j = n - 1; i < n; j = i++) {\n        if ((polygon[i].y > p.y) != (polygon[j].y > p.y)) {\n            int x_intersect = (polygon[j].x - polygon[i].x) * (p.y - polygon[i].y) / (polygon[j].y - polygon[i].y) + polygon[i].x;\n            if (p.x <= x_intersect) {\n                inside = !inside;\n            }\n        }\n    }\n    return inside;\n}\n\nvector<Segment> getWalls(const vector<Point>& polygon) {\n    vector<Segment> walls;\n    int n = polygon.size();\n    for (int i = 0; i < n; ++i) {\n        int j = (i + 1) % n;\n        walls.emplace_back(polygon[i], polygon[j]);\n    }\n    return walls;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    vector<Point> polygon(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> polygon[i].x >> polygon[i].y;\n    }\n\n    vector<Segment> walls = getWalls(polygon);\n    int max_holes = 0;\n\n    for (const Segment& wall : walls) {\n        Point hole((wall.p1.x + wall.p2.x) / 2, (wall.p1.y + wall.p2.y) / 2);\n\n        int holes_needed = 1;\n        vector<Segment> remaining_walls;\n        for (const Segment& w : walls) {\n            if (w.p1 == wall.p1 && w.p2 == wall.p2) continue;\n            remaining_walls.push_back(w);\n        }\n\n        vector<Point> new_polygon;\n        bool found = false;\n        for (const Segment& w : remaining_walls) {\n            if (isPointOnSegment(w, hole)) {\n                found = true;\n                new_polygon.push_back(w.p1);\n                new_polygon.push_back(w.p2);\n            }\n        }\n        if (!found) {\n            max_holes = max(max_holes, holes_needed);\n            continue;\n        }\n\n        sort(new_polygon.begin(), new_polygon.end(), [](const Point& a, const Point& b) {\n            if (a.x == b.x) return a.y < b.y;\n            return a.x < b.x;\n        });\n        new_polygon.erase(unique(new_polygon.begin(), new_polygon.end()), new_polygon.end());\n\n        while (isInside(new_polygon, hole)) {\n            holes_needed++;\n            vector<Segment> new_walls;\n            for (const Segment& w : remaining_walls) {\n                if (isPointOnSegment(w, hole)) continue;\n                new_walls.push_back(w);\n            }\n            remaining_walls = new_walls;\n\n            new_polygon.clear();\n            found = false;\n            for (const Segment& w : remaining_walls) {\n                if (isPointOnSegment(w, hole)) {\n                    found = true;\n                    new_polygon.push_back(w.p1);\n                    new_polygon.push_back(w.p2);\n                }\n            }\n            if (!found) break;\n\n            sort(new_polygon.begin(), new_polygon.end(), [](const Point& a, const Point& b) {\n                if (a.x == b.x) return a.y < b.y;\n                return a.x < b.x;\n            });\n            new_polygon.erase(unique(new_polygon.begin(), new_polygon.end()), new_polygon.end());\n        }\n\n        max_holes = max(max_holes, holes_needed);\n    }\n\n    cout << max_holes << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:40:51"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_ROOMS 100\n#define MAX_WALLS 200\n\ntypedef struct {\n    int hole;\n    int destination;\n} Passage;\n\ntypedef struct {\n    int room_id;\n    Passage passages[MAX_WALLS];\n    int passage_count;\n} Room;\n\nRoom rooms[MAX_ROOMS];\nint room_count;\nint outside_room = -1;\n\nint max_holes_to_exit(int start_room) {\n    int distances[MAX_ROOMS];\n    int visited[MAX_ROOMS];\n    \n    for (int i = 0; i < room_count; i++) {\n        distances[i] = INT_MAX;\n        visited[i] = 0;\n    }\n    \n    distances[start_room] = 0;\n    \n    for (int count = 0; count < room_count; count++) {\n        int min_dist = INT_MAX;\n        int current_room = -1;\n        \n        for (int i = 0; i < room_count; i++) {\n            if (!visited[i] && distances[i] < min_dist) {\n                min_dist = distances[i];\n                current_room = i;\n            }\n        }\n        \n        if (current_room == -1) break;\n        \n        visited[current_room] = 1;\n        \n        for (int i = 0; i < rooms[current_room].passage_count; i++) {\n            Passage p = rooms[current_room].passages[i];\n            int new_dist = distances[current_room] + 1;\n            \n            if (!visited[p.destination] && new_dist < distances[p.destination]) {\n                distances[p.destination] = new_dist;\n            }\n        }\n    }\n    \n    return distances[outside_room];\n}\n\nint main() {\n    scanf(\"%d\", &room_count);\n    \n    for (int i = 0; i < room_count; i++) {\n        rooms[i].room_id = i;\n        scanf(\"%d\", &rooms[i].passage_count);\n        \n        for (int j = 0; j < rooms[i].passage_count; j++) {\n            scanf(\"%d %d\", &rooms[i].passages[j].hole, &rooms[i].passages[j].destination);\n        }\n    }\n    \n    scanf(\"%d\", &outside_room);\n    \n    int max_traversal = 0;\n    for (int i = 0; i < room_count; i++) {\n        if (i != outside_room) {\n            int holes = max_holes_to_exit(i);\n            if (holes > max_traversal) {\n                max_traversal = holes;\n            }\n        }\n    }\n    \n    printf(\"%d\\n\", max_traversal);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 18:41:02"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <limits>\n\nusing namespace std;\n\nconst double EPS = 1e-9;\n\nstruct Point {\n    double x, y;\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n    \n    Point operator-(const Point& p) const {\n        return Point(x - p.x, y - p.y);\n    }\n    \n    double cross(const Point& p) const {\n        return x * p.y - y * p.x;\n    }\n};\n\nstruct Line {\n    Point a, b;\n    vector<int> holes;\n};\n\nbool pointInPolygon(const Point& pt, const vector<Point>& polygon) {\n    int n = polygon.size();\n    bool inside = false;\n    for (int i = 0, j = n - 1; i < n; j = i++) {\n        if (((polygon[i].y > pt.y) != (polygon[j].y > pt.y)) &&\n            (pt.x < (polygon[j].x - polygon[i].x) * (pt.y - polygon[i].y) / \n            (polygon[j].y - polygon[i].y) + polygon[i].x))\n            inside = !inside;\n    }\n    return inside;\n}\n\ndouble distancePointToLine(const Point& p, const Point& a, const Point& b) {\n    Point ab = b - a;\n    Point ap = p - a;\n    double area = abs(ap.cross(ab));\n    double base = sqrt(ab.x * ab.x + ab.y * ab.y);\n    return area / base;\n}\n\nint findMaxHolesTraversed(vector<Line>& lines, const vector<Point>& polygon, const Point& catPos) {\n    int n = lines.size();\n    int maxHoles = 0;\n    \n    for (int exit = 0; exit < n; exit++) {\n        if (!pointInPolygon(lines[exit].a, polygon) || \n            !pointInPolygon(lines[exit].b, polygon)) {\n            \n            int currHoles = 0;\n            vector<bool> visited(n, false);\n            \n            Point current = catPos;\n            int currLine = -1;\n            \n            while (currLine != exit) {\n                double minDist = numeric_limits<double>::max();\n                int nextLine = -1;\n                \n                for (int i = 0; i < n; i++) {\n                    if (i == currLine || visited[i]) continue;\n                    \n                    double dist1 = distancePointToLine(current, lines[i].a, lines[i].b);\n                    \n                    if (dist1 < minDist) {\n                        minDist = dist1;\n                        nextLine = i;\n                    }\n                }\n                \n                if (nextLine == -1) break;\n                \n                currLine = nextLine;\n                visited[currLine] = true;\n                currHoles += lines[currLine].holes.size();\n                \n                current = (lines[currLine].a + lines[currLine].b) * 0.5;\n            }\n            \n            maxHoles = max(maxHoles, currHoles);\n        }\n    }\n    \n    return maxHoles;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    \n    vector<Point> polygon(n);\n    for (int i = 0; i < n; i++) {\n        cin >> polygon[i].x >> polygon[i].y;\n    }\n    \n    vector<Line> lines(m);\n    for (int i = 0; i < m; i++) {\n        cin >> lines[i].a.x >> lines[i].a.y >> lines[i].b.x >> lines[i].b.y;\n        \n        int k;\n        cin >> k;\n        lines[i].holes.resize(k);\n        for (int j = 0; j < k; j++) {\n            cin >> lines[i].holes[j];\n        }\n    }\n    \n    Point catPos;\n    cin >> catPos.x >> catPos.y;\n    \n    int result = findMaxHolesTraversed(lines, polygon, catPos);\n    cout << result << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 18:41:17"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Point {\n    long x, y;\n    Point(long x, long y) {\n        this.x = x;\n        this.y = y;\n    }\n}\n\nclass Wall {\n    Point p1, p2;\n    Wall(Point p1, Point p2) {\n        this.p1 = p1;\n        this.p2 = p2;\n    }\n}\n\npublic class Main {\n    static boolean isPointOnSegment(Point p, Point q, Point r) {\n        if (q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) &&\n            q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y)) {\n            long val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n            return val == 0;\n        }\n        return false;\n    }\n\n    static int orientation(Point p, Point q, Point r) {\n        long val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n        if (val == 0) return 0;\n        return (val > 0) ? 1 : 2;\n    }\n\n    static boolean doIntersect(Point p1, Point q1, Point p2, Point q2) {\n        int o1 = orientation(p1, q1, p2);\n        int o2 = orientation(p1, q1, q2);\n        int o3 = orientation(p2, q2, p1);\n        int o4 = orientation(p2, q2, q1);\n\n        if (o1 != o2 && o3 != o4) return true;\n\n        if (o1 == 0 && isPointOnSegment(p1, p2, q1)) return true;\n        if (o2 == 0 && isPointOnSegment(p1, q2, q1)) return true;\n        if (o3 == 0 && isPointOnSegment(p2, p1, q2)) return true;\n        if (o4 == 0 && isPointOnSegment(p2, q1, q2)) return true;\n\n        return false;\n    }\n\n    static boolean isInside(List<Point> polygon, Point p) {\n        int n = polygon.size();\n        if (n < 3) return false;\n\n        Point extreme = new Point(Long.MAX_VALUE, p.y);\n        int count = 0, i = 0;\n        do {\n            int next = (i + 1) % n;\n            if (doIntersect(polygon.get(i), polygon.get(next), p, extreme)) {\n                if (orientation(polygon.get(i), p, polygon.get(next)) == 0) {\n                    return isPointOnSegment(polygon.get(i), p, polygon.get(next));\n                }\n                count++;\n            }\n            i = next;\n        } while (i != 0);\n\n        return (count % 2) == 1;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        List<Point> polygon = new ArrayList<>();\n        for (int i = 0; i < N; i++) {\n            long x = sc.nextLong();\n            long y = sc.nextLong();\n            polygon.add(new Point(x, y));\n        }\n\n        List<Wall> walls = new ArrayList<>();\n        for (int i = 0; i < N; i++) {\n            Point p1 = polygon.get(i);\n            Point p2 = polygon.get((i + 1) % N);\n            walls.add(new Wall(p1, p2));\n        }\n\n        int maxHoles = 0;\n        for (int i = 0; i < N; i++) {\n            Point mid = new Point((walls.get(i).p1.x + walls.get(i).p2.x) / 2, \n                                 (walls.get(i).p1.y + walls.get(i).p2.y) / 2);\n            int holes = 1;\n            List<Point> currentPolygon = new ArrayList<>(polygon);\n\n            while (true) {\n                boolean found = false;\n                for (int j = 0; j < currentPolygon.size(); j++) {\n                    Point p1 = currentPolygon.get(j);\n                    Point p2 = currentPolygon.get((j + 1) % currentPolygon.size());\n                    Point midWall = new Point((p1.x + p2.x) / 2, (p1.y + p2.y) / 2);\n                    if (!isInside(currentPolygon, midWall)) {\n                        found = true;\n                        holes++;\n                        currentPolygon.remove(j);\n                        break;\n                    }\n                }\n                if (!found) break;\n            }\n            maxHoles = Math.max(maxHoles, holes);\n        }\n\n        System.out.println(maxHoles);\n    }\n}",
    "timestamp": "2025-08-05 18:42:01"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_holes_to_exit(mansion):\n    def dfs(room, visited, depth):\n        nonlocal max_depth\n        visited.add(room)\n        max_depth = max(max_depth, depth)\n        for next_room in mansion[room]:\n            if next_room not in visited:\n                dfs(next_room, visited, depth + 1)\n        visited.remove(room)\n\n    # Build the adjacency list representing the mansion's rooms and their connections\n    # Each room represented by its index; lists show direct connections through holes\n    mansion_graph = {}\n    num_rooms = len(mansion)\n\n    for i in range(num_rooms):\n        mansion_graph[i] = mansion[i]\n\n    max_depth = 0\n\n    # Explore paths from each room to maximize the number of holes traversed\n    for start_room in range(num_rooms):\n        visited = set()\n        dfs(start_room, visited, 0)\n\n    return max_depth\n\n# Example Usage:\nmansion_layout = [\n    [1, 2],      # Room 0 connects to Room 1 and Room 2 through holes\n    [0, 2, 3],   # Room 1 connects to Room 0, Room 2, and Room 3\n    [0, 1, 3],   # Room 2 connects to Room 0, Room 1, and Room 3\n    [1, 2]       # Room 3 connects to Room 1 and Room 2\n]\nprint(max_holes_to_exit(mansion_layout))  # Output the maximum number of holes",
    "timestamp": "2025-08-13 00:27:58"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class CatEscape {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt(); // number of vertices (pillars)\n        \n        double[][] vertices = new double[n][2];\n        for (int i = 0; i < n; i++) {\n            vertices[i][0] = scanner.nextDouble(); // x-coordinate\n            vertices[i][1] = scanner.nextDouble(); // y-coordinate\n        }\n        \n        // Function to get the farthest point from a visible point\n        int maxCount = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                int count = 0;\n                for (int k = 0; k < n; k++) {\n                    if (isVisible(vertices, i, j, k)) {\n                        count++;\n                    }\n                }\n                maxCount = Math.max(maxCount, count);\n            }\n        }\n        \n        System.out.println(maxCount);\n    }\n    \n    private static boolean isVisible(double[][] vertices, int i, int j, int k) {\n        double x1 = vertices[i][0];\n        double y1 = vertices[i][1];\n        double x2 = vertices[j][0];\n        double y2 = vertices[j][1];\n        double x3 = vertices[k][0];\n        double y3 = vertices[k][1];\n        \n        double v1x = x2 - x1;\n        double v1y = y2 - y1;\n        double v2x = x3 - x1;\n        double v2y = y3 - y1;\n        \n        double cross = v1x * v2y - v1y * v2x;\n        \n        return cross < 0;\n    }\n}",
    "timestamp": "2025-08-13 00:28:06"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n\nint max(int a, int b) {\n    return a > b ? a : b;\n}\n\nint findMaxHoles(int n, int adjMatrix[n][n], int start) {\n    int dp[n];\n    for (int i = 0; i < n; i++) {\n        dp[i] = -1;\n    }\n    dp[start] = 0;\n    \n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (adjMatrix[j][i] && dp[j] != -1) {\n                dp[i] = max(dp[i], dp[j] + 1);\n            }\n        }\n    }\n    \n    int maxPath = 0;\n    for (int i = 0; i < n; i++) {\n        maxPath = max(maxPath, dp[i]);\n    }\n    return maxPath;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    int adjMatrix[n][n];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            adjMatrix[i][j] = 0;\n        }\n    }\n    \n    for (int i = 0; i < n; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        adjMatrix[u][v] = 1;\n        adjMatrix[v][u] = 1;\n    }\n    \n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        int singleResult = findMaxHoles(n, adjMatrix, i);\n        result = max(result, singleResult);\n    }\n    \n    printf(\"%d\\n\", result);\n    return 0;\n}",
    "timestamp": "2025-08-13 00:28:11"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from typing import List, Tuple\n\ndef solve_cat_escape(rooms: List[List[Tuple[int, int]]], cat_location: Tuple[int, int]) -> int:\n    def point_in_polygon(point: Tuple[int, int], polygon: List[Tuple[int, int]]) -> bool:\n        x, y = point\n        inside = False\n        j = len(polygon) - 1\n        for i in range(len(polygon)):\n            xi, yi = polygon[i]\n            xj, yj = polygon[j]\n            intersect = ((yi > y) != (yj > y)) and (x < (xj - xi) * (y - yi) / (yj - yi) + xi)\n            if intersect:\n                inside = not inside\n            j = i\n        return inside\n\n    def find_holes_to_outside(rooms: List[List[Tuple[int, int]]]) -> List[Tuple[int, int]]:\n        holes = []\n        for room in rooms:\n            for wall in range(len(room)):\n                midpoint = ((room[wall][0] + room[(wall+1)%len(room)][0]) / 2,\n                            (room[wall][1] + room[(wall+1)%len(room)][1]) / 2)\n                outside_point = (midpoint[0] * 2, midpoint[1] * 2)\n                \n                if not any(point_in_polygon(outside_point, r) for r in rooms):\n                    holes.append(midpoint)\n        return holes\n\n    def shortest_path_holes(cat_location: Tuple[int, int], holes: List[Tuple[int, int]]) -> int:\n        current_room = None\n        for room in rooms:\n            if point_in_polygon(cat_location, room):\n                current_room = room\n                break\n        \n        if current_room is None:\n            return 0\n        \n        max_holes = 0\n        for hole in holes:\n            path_holes = 0\n            current_loc = cat_location\n            current_polygon = current_room\n            \n            while not point_in_polygon(hole, current_polygon):\n                path_holes += 1\n                for r in rooms:\n                    if point_in_polygon(hole, r) and r != current_polygon:\n                        current_polygon = r\n                        break\n            \n            max_holes = max(max_holes, path_holes)\n        \n        return max_holes\n\n    holes = find_holes_to_outside(rooms)\n    return shortest_path_holes(cat_location, holes)\n\n# Example usage\nrooms = [\n    [(0,0), (0,10), (10,10), (10,0)],  # Room 1\n    [(10,0), (10,10), (20,10), (20,0)]  # Room 2\n]\ncat_location = (5, 5)\nresult = solve_cat_escape(rooms, cat_location)\nprint(result)",
    "timestamp": "2025-08-13 00:28:31"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nimport math\n\ndef readints():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef cross(o, a, b):\n    return (a[0]-o[0])*(b[1]-o[1]) - (a[1]-o[1])*(b[0]-o[0])\n\ndef point_in_polygon(poly, point):\n    wn = 0\n    n = len(poly)\n    for i in range(n):\n        j = (i + 1) % n\n        if poly[i][1] <= point[1]:\n            if poly[j][1] > point[1] and cross(poly[i], poly[j], point) > 0:\n                wn += 1\n        else:\n            if poly[j][1] <= point[1] and cross(poly[i], poly[j], point) < 0:\n                wn -= 1\n    return wn != 0\n\ndef solve():\n    N = int(sys.stdin.readline())\n    poly = []\n    for _ in range(N):\n        x, y = map(int, sys.stdin.readline().split())\n        poly.append((x, y))\n    \n    M = int(sys.stdin.readline())\n    holes = []\n    for _ in range(M):\n        x, y = map(int, sys.stdin.readline().split())\n        holes.append((x, y))\n    \n    max_holes = 0\n    for hole in holes:\n        if not point_in_polygon(poly, hole):\n            continue\n        \n        min_holes = float('inf')\n        for i in range(N):\n            j = (i + 1) % N\n            mid = ((poly[i][0] + poly[j][0]) / 2, (poly[i][1] + poly[j][1]) / 2)\n            segments = [(hole, mid)]\n            count = 1\n            for seg in segments:\n                a, b = seg\n                intersections = 0\n                for k in range(N):\n                    m = (k + 1) % N\n                    c, d = poly[k], poly[m]\n                    if (cross(a, b, c) * cross(a, b, d) < 0 and cross(c, d, a) * cross(c, d, b) < 0):\n                        intersections += 1\n                count += intersections\n            if count < min_holes:\n                min_holes = count\n        if min_holes > max_holes:\n            max_holes = min_holes\n    print(max_holes)\n\nsolve()",
    "timestamp": "2025-08-13 00:28:53"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nstruct Point {\n    double x, y;\n};\n\ndouble cross(const Point& O, const Point& A, const Point& B) {\n    return (A.x - O.x) * (B.y - O.y) - (A.y - O.y) * (B.x - O.x);\n}\n\nstruct Segment {\n    Point p1, p2;\n    int index;\n\n    bool operator<(const Segment& other) const {\n        return p1.x < other.p1.x || (p1.x == other.p1.x && p1.y < other.p1.y);\n    }\n};\n\nbool onSegment(const Point& p, const Point& q, const Point& r) {\n    return q.x <= max(p.x, r.x) && q.x >= min(p.x, r.x) &&\n           q.y <= max(p.y, r.y) && q.y >= min(p.y, r.y);\n}\n\n// Return true if line segments 'p1q1' and 'p2q2' intersect\nbool doIntersect(const Point& p1, const Point& q1, const Point& p2, const Point& q2) {\n    // Find the four orientations needed for general and special cases\n    double o1 = cross(p1, q1, p2);\n    double o2 = cross(p1, q1, q2);\n    double o3 = cross(p2, q2, p1);\n    double o4 = cross(p2, q2, q1);\n\n    // General case\n    if (o1 != 0 && o2 != 0 && ((o1 > 0) ^ (o2 > 0)) && ((o3 > 0) ^ (o4 > 0)))\n        return true;\n\n    // Special Cases\n    // p1, q1 and p2 are collinear and p2 lies on segment p1q1\n    if (o1 == 0 && onSegment(p1, p2, q1)) return true;\n\n    // p1, q1 and p2 are collinear and q2 lies on segment p1q1\n    if (o2 == 0 && onSegment(p1, q2, q1)) return true;\n\n    // p2, q2 and p1 are collinear and p1 lies on segment p2q2\n    if (o3 == 0 && onSegment(p2, p1, q2)) return true;\n\n    // p2, q2 and q1 are collinear and q1 lies on segment p2q2\n    if (o4 == 0 && onSegment(p2, q1, q2)) return true;\n\n    return false;\n}\n\nbool isHoveredOver(const vector<Segment>& segments, const Point& p) {\n    int count = 0;\n    Point extreme = {10000, p.y}; // A point outside the mansion\n\n    for (const auto& segment : segments) {\n        if (doIntersect(p, extreme, segment.p1, segment.p2)) {\n            if (cross(p, segment.p1, segment.p2) == 0 &&\n                onSegment(segment.p1, p, segment.p2)) {\n                return false; // Point is on the line\n            }\n            count++;\n        }\n    }\n    return (count % 2 == 1);\n}\n\nint main() {\n    int n;\n    cout << \"Enter the number of points in the polygon: \";\n    cin >> n;\n    vector<Point> points(n);\n\n    cout << \"Enter the coordinates of the points in the polygon:\\n\";\n    for (int i = 0; i < n; i++) {\n        cin >> points[i].x >> points[i].y;\n    }\n\n    vector<Segment> segments;\n    for (int i = 0; i < n; i++) {\n        segments.push_back({points[i], points[(i + 1) % n], i});\n    }\n\n    int maxHoles = n - 1;\n    cout << \"Maximum number of holes the cat needs to pass: \" << maxHoles << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 10:54:20"
  }
]