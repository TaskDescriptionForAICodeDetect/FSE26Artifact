[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MOD 1000000007\n#define MAX_N 100005\n#define MAX_H 10005\n\nlong long dp[2][1 << 20];\n\nint main() {\n    int N;\n    int h[MAX_N];\n    \n    scanf(\"%d\", &N);\n    for (int i = 1; i <= N; i++) {\n        scanf(\"%d\", &h[i]);\n    }\n    \n    int curr = 0, next = 1;\n    memset(dp, 0, sizeof(dp));\n    dp[curr][0] = 1;\n    \n    for (int i = 1; i <= N; i++) {\n        memset(dp[next], 0, sizeof(dp[next]));\n        int max_state = 1 << (2 * (h[i] - 1));\n        \n        for (int state = 0; state < max_state; state++) {\n            int red_count = 0, blue_count = 0;\n            int valid = 1;\n            \n            for (int j = 0; j < h[i] - 1; j++) {\n                int square = (state >> (2 * j)) & 3;\n                \n                if (square == 0) red_count++;\n                else if (square == 1) blue_count++;\n                else if (square == 2) {\n                    red_count++;\n                    blue_count++;\n                }\n                else {\n                    valid = 0;\n                    break;\n                }\n                \n                if (i > 1) {\n                    int prev_square = (state >> (2 * j)) & 3;\n                    int last_state = (prev_square << (2 * j)) | (state & ((1 << (2 * j)) - 1));\n                    \n                    if (dp[curr][last_state] == 0) {\n                        valid = 0;\n                        break;\n                    }\n                }\n            }\n            \n            if (valid && red_count == 2 && blue_count == 2) {\n                dp[next][state] = (dp[next][state] + dp[curr][0]) % MOD;\n            }\n        }\n        \n        curr = next;\n        next = 1 - curr;\n    }\n    \n    long long total_ways = 0;\n    int max_state = 1 << (2 * (h[N] - 1));\n    \n    for (int state = 0; state < max_state; state++) {\n        total_ways = (total_ways + dp[curr][state]) % MOD;\n    }\n    \n    printf(\"%lld\\n\", total_ways);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:03:43"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MOD 1000000007\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    \n    int *h = (int *)malloc((N + 1) * sizeof(int));\n    for (int i = 1; i <= N; i++) {\n        scanf(\"%d\", &h[i]);\n    }\n    \n    if (N == 1) {\n        long long ans = 1;\n        for (int i = 1; i <= h[1]; i++) {\n            ans = (ans * 2) % MOD;\n        }\n        printf(\"%lld\\n\", ans);\n        free(h);\n        return 0;\n    }\n    \n    long long ans = 1;\n    for (int i = 1; i <= N; i++) {\n        if (i == 1 || i == N) {\n            ans = (ans * 2) % MOD;\n        } else {\n            ans = (ans * 2) % MOD;\n        }\n    }\n    \n    printf(\"%lld\\n\", ans);\n    free(h);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:04:26"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n    int N;\n    cin >> N;\n    vector<int> h(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> h[i];\n    }\n\n    if (N == 1) {\n        cout << (1LL << min(2, h[0])) % MOD << endl;\n        return 0;\n    }\n\n    vector<vector<int>> dp(N, vector<int>(4, 0));\n    for (int mask = 0; mask < 4; ++mask) {\n        bool valid = true;\n        for (int i = 0; i < N - 1; ++i) {\n            int a = (mask >> (i % 2)) & 1;\n            int b = (mask >> ((i % 2) + 1)) & 1;\n            if (min(h[i], h[i + 1]) >= 2) {\n                int cnt = a + b;\n                if (cnt != 1) {\n                    valid = false;\n                    break;\n                }\n            }\n        }\n        if (valid) {\n            dp[0][mask] = 1;\n        }\n    }\n\n    for (int i = 1; i < N; ++i) {\n        for (int prev_mask = 0; prev_mask < 4; ++prev_mask) {\n            if (dp[i - 1][prev_mask] == 0) continue;\n            for (int curr_mask = 0; curr_mask < 4; ++curr_mask) {\n                bool valid = true;\n                if (i > 0) {\n                    int a = (prev_mask >> (i % 2)) & 1;\n                    int b = (curr_mask >> (i % 2)) & 1;\n                    if (min(h[i - 1], h[i]) >= 2) {\n                        int cnt = a + b;\n                        if (cnt != 1) {\n                            valid = false;\n                        }\n                    }\n                }\n                if (i < N - 1 && min(h[i], h[i + 1]) >= 2) {\n                    int a = (curr_mask >> (i % 2)) & 1;\n                    int b = (curr_mask >> ((i % 2) + 1)) & 1;\n                    int cnt = a + b;\n                    if (cnt != 1) {\n                        valid = false;\n                    }\n                }\n                if (valid) {\n                    dp[i][curr_mask] = (dp[i][curr_mask] + dp[i - 1][prev_mask]) % MOD;\n                }\n            }\n        }\n    }\n\n    long long ans = 0;\n    for (int mask = 0; mask < 4; ++mask) {\n        ans = (ans + dp[N - 1][mask]) % MOD;\n    }\n\n    for (int i = 0; i < N; ++i) {\n        if (h[i] > 2) {\n            ans = ans * (1LL << (h[i] - 2)) % MOD;\n        }\n    }\n\n    cout << ans << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 23:04:55"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    static final long MOD = 1000000007;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int[] h = new int[N];\n        for (int i = 0; i < N; i++) {\n            h[i] = sc.nextInt();\n        }\n\n        if (N == 1) {\n            System.out.println(pow(2, h[0]));\n            return;\n        }\n\n        long[][] dp = new long[N][4];\n        for (int mask = 0; mask < 4; mask++) {\n            dp[0][mask] = 1;\n        }\n\n        for (int i = 1; i < N; i++) {\n            int prevH = h[i-1];\n            int currH = h[i];\n            int minH = Math.min(prevH, currH);\n\n            for (int prevMask = 0; prevMask < 4; prevMask++) {\n                for (int currMask = 0; currMask < 4; currMask++) {\n                    boolean valid = true;\n                    for (int j = 1; j < minH; j++) {\n                        int prevBit1 = (prevMask >> (j % 2)) & 1;\n                        int prevBit2 = (prevMask >> ((j-1) % 2)) & 1;\n                        int currBit1 = (currMask >> (j % 2)) & 1;\n                        int currBit2 = (currMask >> ((j-1) % 2)) & 1;\n                        int redCount = prevBit1 + prevBit2 + currBit1 + currBit2;\n                        if (redCount != 2) {\n                            valid = false;\n                            break;\n                        }\n                    }\n                    if (valid) {\n                        dp[i][currMask] = (dp[i][currMask] + dp[i-1][prevMask]) % MOD;\n                    }\n                }\n            }\n        }\n\n        long result = 0;\n        for (int mask = 0; mask < 4; mask++) {\n            result = (result + dp[N-1][mask]) % MOD;\n        }\n\n        int maxH = Math.max(h[0], h[N-1]);\n        for (int i = 1; i < N-1; i++) {\n            maxH = Math.max(maxH, h[i]);\n        }\n        for (int i = 0; i < N; i++) {\n            if (h[i] > 2) {\n                result = result * pow(2, h[i] - 2) % MOD;\n            }\n        }\n\n        System.out.println(result);\n    }\n\n    static long pow(long a, int b) {\n        long res = 1;\n        while (b > 0) {\n            if ((b & 1) == 1) {\n                res = res * a % MOD;\n            }\n            a = a * a % MOD;\n            b >>= 1;\n        }\n        return res;\n    }\n}",
    "timestamp": "2025-08-05 23:05:25"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Solution {\n    private static final int MOD = 1_000_000_007;\n\n    public static int countPaintings(int N, int[] h) {\n        // Each column can be painted in 2 ways initially\n        long ways = 1;\n\n        // Iterate through adjacent column pairs\n        for (int i = 0; i < N - 1; i++) {\n            // Find possible square count in this 2x2 region\n            int maxSquares = Math.min(h[i], h[i + 1]);\n\n            // If no squares to consider, continue\n            if (maxSquares <= 1) continue;\n\n            // Calculate valid 2x2 subregion painting possibilities\n            long subWays = countValidPaintings(maxSquares - 1);\n            ways = (ways * subWays) % MOD;\n        }\n\n        return (int) ways;\n    }\n\n    private static long countValidPaintings(int squareCount) {\n        // Total possible 2x2 painting combinations: 2^(4 choose 2)\n        return pow(2, squareCount * (squareCount + 1) / 2);\n    }\n\n    private static long pow(long base, long exp) {\n        long result = 1;\n        base %= MOD;\n        while (exp > 0) {\n            if ((exp & 1) == 1) {\n                result = (result * base) % MOD;\n            }\n            base = (base * base) % MOD;\n            exp >>= 1;\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int[] h = new int[N];\n        for (int i = 0; i < N; i++) {\n            h[i] = scanner.nextInt();\n        }\n        System.out.println(countPaintings(N, h));\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 23:05:33"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nconst int MOD = 1e9 + 7;\n\nll modPow(ll base, ll exp) {\n    ll result = 1;\n    base %= MOD;\n    while (exp > 0) {\n        if (exp & 1) result = (result * base) % MOD;\n        base = (base * base) % MOD;\n        exp >>= 1;\n    }\n    return result;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    vector<int> h(N);\n    for (int i = 0; i < N; i++) cin >> h[i];\n\n    int minHeight = *min_element(h.begin(), h.end());\n    ll ways = modPow(2, minHeight - 1);\n\n    for (int j = 0; j < minHeight; j++) {\n        bool isPossible = true;\n        for (int i = 0; i < N - 1; i++) {\n            if (j >= h[i] || j >= h[i + 1]) {\n                isPossible = false;\n                break;\n            }\n        }\n        if (!isPossible) {\n            ways = 0;\n            break;\n        }\n    }\n\n    cout << ways << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 23:05:38"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "MOD = 10**9 + 7\n\ndef count_ways_to_paint(n, heights):\n    if n == 1:\n        # Only one way to paint all red or all blue, but they are the same\n        return 2\n\n    ways = 1\n    for i in range(n - 1):\n        h_min = min(heights[i], heights[i + 1])\n        if h_min > 1:\n            # Each of the h_min - 1 pairs can be painted in 2 ways\n            ways *= pow(2, h_min - 1, MOD)\n            ways %= MOD\n        else:\n            # If any h_min is less than or equal to 1, that pair constraints doesn't add any extra coloring options.\n            continue\n\n    return ways\n\n# Example usage:\nN = 5\nheights = [3, 2, 4, 1, 3]\nprint(count_ways_to_paint(N, heights))  # Output the result",
    "timestamp": "2025-08-13 13:30:47"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\npublic class GridPainting {\n    private static final int MOD = 1000000007;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int[] heights = new int[N];\n        \n        for (int i = 0; i < N; i++) {\n            heights[i] = scanner.nextInt();\n        }\n        \n        scanner.close();\n\n        long result = 1;\n        for (int i = 0; i < N - 1; i++) {\n            int minHeight = Math.min(heights[i], heights[i + 1]);\n            if (minHeight > 1) {\n                result = result * power(2, minHeight - 1, MOD) % MOD;\n            }\n        }\n\n        System.out.println(result);\n    }\n\n    private static long power(long base, long exp, int mod) {\n        long result = 1;\n        base = base % mod;\n        while (exp > 0) {\n            if ((exp & 1) == 1) {\n                result = (result * base) % mod;\n            }\n            exp >>= 1;\n            base = (base * base) % mod;\n        }\n        return result;\n    }\n}",
    "timestamp": "2025-08-13 13:30:51"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdint.h>\n\n#define MOD 1000000007\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    \n    int h[N];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &h[i]);\n    }\n    \n    int64_t ways = 1;\n    for (int i = 0; i < N - 1; i++) {\n        int min_height = h[i] < h[i + 1] ? h[i] : h[i + 1];\n        // Each pair has 2 ways to be painted (checkerboard pattern)\n        for (int j = 1; j < min_height; j++) {\n            ways = (ways * 2) % MOD;\n        }\n    }\n    \n    printf(\"%lld\\n\", ways);\n    return 0;\n}",
    "timestamp": "2025-08-13 13:30:56"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function countPaintingWays(N, h) {\n    const MOD = 1000000007;\n\n    function modPow(base, exp, mod) {\n        let result = 1;\n        base = base % mod;\n        while (exp > 0) {\n            if (exp % 2 === 1) {\n                result = (result * base) % mod;\n            }\n            exp = Math.floor(exp / 2);\n            base = (base * base) % mod;\n        }\n        return result;\n    }\n\n    let ways = 1;\n    for (let i = 1; i < N; i++) {\n        let count = Math.min(h[i - 1], h[i]) - 1;\n        if (count > 0) {\n            ways = (ways * modPow(2, count, MOD)) % MOD;\n        }\n    }\n\n    return ways;\n}",
    "timestamp": "2025-08-13 13:30:59"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def count_painting_ways(N, h):\n    MOD = 10**9 + 7\n    \n    # Initialize DP table\n    dp = [[[0] * 4 for _ in range(2)] for _ in range(N)]\n    \n    # Initial state for first column\n    for mask in range(4):\n        if bin(mask).count('1') == 2:\n            dp[0][0][mask] = 1\n    \n    # Dynamic programming\n    for col in range(1, N):\n        for prev_mask in range(4):\n            for curr_mask in range(4):\n                # Check if masks satisfy the coloring constraint\n                valid = True\n                for j in range(min(h[col-1], h[col])-1):\n                    # Extract 2x2 subgrid color pattern\n                    subgrid = [\n                        (prev_mask >> (1-j)) & 1,\n                        (prev_mask >> j) & 1,\n                        (curr_mask >> (1-j)) & 1,\n                        (curr_mask >> j) & 1\n                    ]\n                    \n                    # Check if exactly 2 red and 2 blue squares\n                    if sum(subgrid) != 2:\n                        valid = False\n                        break\n                \n                if valid:\n                    for state in range(2):\n                        dp[col][state][curr_mask] += dp[col-1][state][prev_mask]\n                        dp[col][state][curr_mask] %= MOD\n    \n    # Sum total ways across final column states\n    total_ways = sum(dp[N-1][state][mask] for state in range(2) for mask in range(4)) % MOD\n    \n    return total_ways\n\n# Read input\nN, h = map(int, input().split()), list(map(int, input().split()))\n\n# Output result\nprint(count_painting_ways(N, h))",
    "timestamp": "2025-08-13 13:31:08"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function countPaintings(N, heights) {\n    const MOD = 1e9 + 7;\n    \n    let dp = new Array(4).fill(0n);\n    dp[0] = 1n;\n    \n    for (let col = 0; col < N - 1; col++) {\n        let newDp = new Array(4).fill(0n);\n        \n        let minHeight = Math.min(heights[col], heights[col + 1]);\n        \n        for (let mask = 0; mask < 4; mask++) {\n            for (let nextMask = 0; nextMask < 4; nextMask++) {\n                let validConfiguration = true;\n                let redCount = 0, blueCount = 0;\n                \n                for (let j = 0; j < 2; j++) {\n                    if (mask & (1 << j)) {\n                        if (nextMask & (1 << j)) redCount++;\n                        else blueCount++;\n                    } else {\n                        if (nextMask & (1 << j)) blueCount++;\n                        else redCount++;\n                    }\n                }\n                \n                if (redCount === 2 && blueCount === 2) {\n                    newDp[nextMask] = (newDp[nextMask] + dp[mask]) % MOD;\n                }\n            }\n        }\n        \n        dp = newDp;\n    }\n    \n    let result = 0n;\n    for (let mask = 0; mask < 4; mask++) {\n        result = (result + dp[mask]) % MOD;\n    }\n    \n    return Number(result);\n}",
    "timestamp": "2025-08-13 13:31:14"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "MOD = 10**9 + 7\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    h = list(map(int, data[1:N+1]))\n    \n    if N == 1:\n        print(pow(2, h[0], MOD))\n        return\n    \n    # Check if all h_i are the same\n    all_same = True\n    for num in h[1:]:\n        if num != h[0]:\n            all_same = False\n            break\n    \n    if all_same:\n        m = h[0]\n        if m == 1:\n            print(2 * N % MOD)\n        else:\n            # The pattern is 2 * 2^(m-1) mod MOD\n            ans = 2 * pow(2, m - 1, MOD) % MOD\n            print(ans)\n    else:\n        # The answer is 2^{h1 + hN - sum min(hi, hi+1) for i=1..N-1}\n        total = h[0] + h[-1]\n        for i in range(N-1):\n            total -= min(h[i], h[i+1])\n        ans = pow(2, total, MOD)\n        print(ans)\n\nsolve()",
    "timestamp": "2025-08-13 13:31:22"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "const MOD = 1e9 + 7;\n\nfunction solve() {\n    const input = require('fs').readFileSync(0, 'utf-8').trim().split('\\n');\n    const N = parseInt(input[0], 10);\n    const h = input[1].split(' ').map(Number);\n    \n    if (N === 1) {\n        console.log((2 * h[0]) % MOD);\n        return;\n    }\n    \n    let dp = new Array(2).fill(0).map(() => new Array(2).fill(0));\n    dp[0][0] = 1;\n    dp[0][1] = 1;\n    dp[1][0] = 1;\n    dp[1][1] = 1;\n    \n    for (let i = 1; i < N; i++) {\n        const prev_h = h[i - 1];\n        const curr_h = h[i];\n        const min_h = Math.min(prev_h, curr_h);\n        \n        let new_dp = new Array(2).fill(0).map(() => new Array(2).fill(0));\n        \n        for (let a = 0; a < 2; a++) {\n            for (let b = 0; b < 2; b++) {\n                for (let c = 0; c < 2; c++) {\n                    for (let d = 0; d < 2; d++) {\n                        if (min_h === 0) {\n                            if (a === c && b === d) {\n                                new_dp[b][d] = (new_dp[b][d] + dp[a][b]) % MOD;\n                            }\n                        } else {\n                            let valid = true;\n                            for (let j = 0; j < min_h - 1; j++) {\n                                const cnt = (a + b + c + d) % 4;\n                                if (cnt !== 2) {\n                                    valid = false;\n                                    break;\n                                }\n                            }\n                            if (valid) {\n                                new_dp[b][d] = (new_dp[b][d] + dp[a][b]) % MOD;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        \n        dp = new_dp;\n    }\n    \n    let total = 0;\n    for (let a = 0; a < 2; a++) {\n        for (let b = 0; b < 2; b++) {\n            total = (total + dp[a][b]) % MOD;\n        }\n    }\n    \n    console.log(total);\n}\n\nsolve();",
    "timestamp": "2025-08-13 13:31:37"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n\nconst int MOD = 1000000007;\n\nint countWays(const std::vector<int>& heights) {\n    int N = heights.size();\n    long long result = 1;\n    \n    for (int i = 0; i < N - 1; ++i) {\n        int limit = std::min(heights[i], heights[i + 1]);\n        for (int j = 1; j < limit; ++j) {\n            result = (result * 2) % MOD;\n        }\n    }\n\n    return result;\n}\n\nint main() {\n    int N;\n    std::cin >> N;\n    \n    std::vector<int> heights(N);\n    for (int i = 0; i < N; ++i) {\n        std::cin >> heights[i];\n    }\n    \n    std::cout << countWays(heights) << std::endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 14:40:00"
  }
]