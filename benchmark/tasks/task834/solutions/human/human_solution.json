[
  {
    "language": "Fortran",
    "code": "program histogram_coloring\n  implicit none\n  type pair\n    integer(8) :: x, y\n  end type\n  integer(8), parameter :: md = 1000000007_8\n  integer :: n, h(100) = 0\n  type(pair) :: p\n  read(*,*) n\n  read(*,*) h(1:n)\n  p = solve(h(1:n))\n  write(*,'(i0)') p%y\ncontains\n  recursive function solve(h) result(ret)\n    integer, intent(in) :: h(:)\n    integer :: m, x(size(h)+1)\n    integer :: n, i, j, w\n    integer(8) :: dp1, dp2\n    type(pair) :: ret, tmp\n    n = size(h)\n    m = minval(h)\n    x(1:n) = h-m\n    x(n+1) = 0\n    w = n\n    dp1 = 1_8\n    dp2 = 1_8\n    i = 0\n    do while (i <= n)\n      j = i+1\n      do while (x(j) /= 0)\n        j = j+1\n      end do\n      if (i+1 <= j-1) then\n        tmp = solve(x(i+1:j-1))\n        dp1 = mod(dp1*tmp%x,md)\n        dp2 = mod(dp2*(tmp%x+tmp%y),md)\n        w = w-(j-i-1)\n      end if\n      i = j\n    end do\n    ret%x = mod(dp1*pow(2_8,m),md)\n    ret%y = modulo(mod(dp2*pow(2_8,w),md)+mod(dp1*(pow(2_8,m)-2_8),md),md)\n  end\n  function pow(a,b) result(r)\n    integer(8), intent(in) :: a\n    integer, intent(in) :: b\n    integer(8) :: r, p\n    integer :: k\n    r = 1_8\n    p = a\n    k = b\n    do while (k > 0)\n      if (btest(k,0)) r = mod(r*p,md)\n      p = mod(p*p,md)\n      k = rshift(k,1)\n    end do\n  end\nend program histogram_coloring"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mod 998244353\n#define MOD 1000000007\n#define inf 0x3f3f3f3f\n#define linf 0x3f3f3f3f3f3f3f3fll\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef unsigned long long ull;\nint h[110],lb[110],rb[110],in[110];\nll dp[110][110];\nint n;\nvector<int> lsh;\ninline ll quickpow(ll base,int ind)\n{\n\tll ans=1;\n\twhile(ind>0)\n\t{\n\t\tif(ind&1)ans=ans*base%MOD;\n\t\tind>>=1;\n\t\tbase=base*base%MOD;\n\t}\n\treturn ans;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tscanf(\"%d\",&h[i]);\n\t\tlsh.push_back(h[i]);\n\t}\n\tlsh.push_back(1);\n\tsort(lsh.begin(),lsh.end());\n\tlsh.erase(unique(lsh.begin(),lsh.end()),lsh.end());\n\tint m=lsh.size();\n\tfor(int i=0;i<m;i++)\n\t{\n\t\trb[i]=lsh[i];\n\t\tif(i)lb[i]=rb[i-1]+1;\n\t\telse lb[i]=1;\n\t}\n\tlb[m]=rb[m-1]+1;\n\trb[m]=inf;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tin[i]=lower_bound(lsh.begin(),lsh.end(),h[i])-lsh.begin();\n//\t\tcout<<i<<\" \"<<in[i]<<endl;\n\t}\n//\tsystem(\"pause\");\n\tfor(int i=1;i<=in[0]+1;i++)\n\t{\n\t\tint lowest=lb[i],higest=min(rb[i],h[0]);\n//\t\tcout<<\"l \"<<lowest<<\" \"<<higest<<endl;\n\t\tif(lowest<=higest)\n\t\t\tdp[0][i]=2ll*(quickpow(2,h[0]-lowest+1)-quickpow(2,h[0]-higest)+MOD)%MOD;\n\t\telse dp[0][i]=2;\n//\t\tcout<<i<<\" \"<<dp[0][i]<<endl;\n\t}\n//\tsystem(\"pause\");\n\tfor(int i=0;i+1<n;i++)\n\t{\n\t\tif(h[i]>=h[i+1])\n\t\t{\n\t\t\tfor(int j=1;j<=in[i]+1;j++)\n\t\t\t{\n\t\t\t\tif(j<=in[i+1])\n\t\t\t\t{\n\t\t\t\t\tdp[i+1][j]=(dp[i+1][j]+dp[i][j])%MOD;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdp[i+1][in[i+1]+1]=(dp[i+1][in[i+1]+1]+dp[i][j]*2ll)%MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint ind=h[i+1]-h[i];\n\t\t\tfor(int j=1;j<=in[i];j++)\n\t\t\t{\n\t\t\t\tdp[i+1][j]=(dp[i+1][j]+dp[i][j]*quickpow(2,ind)%MOD)%MOD;\n\t\t\t}\n\t\t\tfor(int j=in[i]+1;j<=in[i+1]+1;j++)\n\t\t\t{\n\t\t\t\tint lowest=lb[j],higest=min(h[i+1],rb[j]);\n\t//\t\t\tcout<<j<<\" \"<<lowest<<\" \"<<higest<<\" \"<<lb[j]<<\" \"<<rb[j]<<\" \"<<h[i+1]<<\" \"<<in[i+1]<<endl;\n\t\t\t\tif(lowest<=higest)\n\t\t\t\t{\n\t\t\t\t\tdp[i+1][j]=(dp[i+1][j]+\n\t\t\t\t\tdp[i][in[i]+1]*2ll%MOD*(quickpow(2,h[i+1]-lowest+1)-quickpow(2,h[i+1]-higest)+MOD)%MOD)%MOD;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdp[i+1][j]=(dp[i+1][j]+dp[i][in[i]+1]*2ll)%MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t//\tfor(int j=1;j<=in[i+1]+1;j++)\n\t//\t\tcout<<j<<\" \"<<dp[i+1][j]<<endl;\n\t//\tsystem(\"pause\");\n\t}\n\tll ans=0;\n\tfor(int i=1;i<=in[n-1]+1;i++)\n\t\tans=(ans+dp[n-1][i])%MOD;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n                     .:*+=%@@@@@@=-.\n                 .:=@#@@@#@@#######%==*.\n              .-=####@######%*-.....:%##%.\n            .*@###########%+:--........-%@-\n          .*@##############@+--.........-:%-\n        .+##################@==%%%%=+*:----+.\n      .-@####################%++%@@@@@=+**%@@*\n      .%###################@%%@@@###@%+:--%@@%.\n     -@###################@%%%%*::*%++:-----=@+.\n    -#####################@%=++++++*:-------.-=:\n   .+####################@%++*::-:::--::*:::***=:\n   .@#####################%=++*::::-:::++*=##@@#@-\n  ..#####################@%%=++**:::::**+%@#@%%##-..\n   .%####################@@%=+++*+****::*=@######@.\n  .=######################@%%==+==++**+=@%@##@###+:...\n  -#######################@@@%%%===++=@@@%=++===*::--...\n  -########################@@@@@@@%==%%=++==@@:::::*:--.\n..:#########################@@@@@@%%======++++::-..:-.--...\n%#############################@###@%%@@%==%=%*----.--.::---.\n#############################################*-:*:-:---*---- .\n#############################################*--*--:---*---:-.\n#############################################+--::--::-*::-::.\n###########################################+:*-.---.---.:---*-..\n###########################################**:-----------------.\n##########################################@::**:--::::::--:::::-\n###########################################:--:*:::::::::**::*+*\n###########################################=:::***::::::**:::*+*\n############################@@@@@@#########@+****::::********+++\n############################@%%%%%@@@@@@@###%+***::::::::***+==+\n############################@%%%%%%%%%%%@####=+:::-::::-::*+=%%+\n#############################@%%%%%%%%%%@#####=::--------:*=%@%+\n%###########################@%%%%==%%%%%%@##@#=:------..-:+%@@%=\n----------------------------------------------\n--------------------------------------------\n----------------------------------------------\n--------------------------------------------\n----------------------------------------------\n\n         o###########oo\n      o##\"          \"\"##o\n    o#\"                \"##\n  o#\"                    \"#o\n #\"  ##              ##   \"##\n#\"                          ##\n#  ###################       #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#o                           #\n\"#o                         ##\n \"#o                       ##\n  \"#o                    o#\"\n   \"#o                  ##\n     \"#o              o#\"\n       \"#ooo      ooo#######oo\n        ###############   \"######o\n     o###\"\"        \"###o      # ###\n   o###o     oooo    ###    oo####\"\n o###**#     #**#   ############\"\n \"\"##\"\"\"\"\"\"\"\"\"\"###########    #\n    # oooooooo#\"#**     ##    #\n    # #       # # **    ##    #\n    #o#       #o#  *****###ooo#\n                        ##\n                        ##   o###o\n                        ## o##***##\n               o########## #***#**##o\n             o##\"   \"\"###  #***##***#\n o#######o  ###   oo####   ##**####*#\no##\"  \"\"#############\"\"     ##****###\n##\"         ##              ##*##*###\n##          ###              ##### ##\n##           ###              # ##  #\n##            ##                 #\n##             ##\n##             ###\n##              ###oo\n###              \"\"###\n ###\n  ###\n*/\n\n///YEAH IM THE BEST I'VE EVER WAS\n\n///SO HAPPY\n\n#include <bits/stdc++.h>\n\n//#pragma GCC optimize(\"O3\")\n//#pragma GCC optimize(\"Ofast,no-stack-protector\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\")\n//#pragma GCC target(\"avx,tune=native\")\n//float __attribute__((aligned(32)))\n\n/*char memory[(int)1e8];\n\nchar memorypos;\n\ninline void * operator new(size_t n){\n    char * ret = memory + memorypos;\n    memorypos += n;\n    return (void *)ret;\n}\n\ninline void operator delete(void *){}\n*/\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef unsigned long long ull;\n\ntypedef long double ld;\n\ntypedef unsigned int uint;\n\nll sqr(ll x){\n    return x * x;\n}\n\nint mysqrt(ll x){\n    int l = 0, r = 1e9 + 1;\n    while (r - l > 1){\n        int m = (l + r) / 2;\n        if (m * (ll)m <= x)\n            l = m;\n        else\n            r = m;\n    }\n    return l;\n}\n\nmt19937 rnd(1227);\n\nmt19937_64 rndll(12365);\n\nll AR = 19, BR = 13, CR = 23, XR = 228, YR = 322, MODR = 1e9 + 993;\n\nll myrand(){\n    ll ZR = (XR * AR + YR * BR + CR) % MODR;\n    XR = YR;\n    YR = ZR;\n    return ZR;\n}\n\nconst int Mod = 1e9 + 7;\n\nint Bpow(int x, int y){\n    if (y == 0)\n        return 1;\n    if (y == 1)\n        return x;\n    int ret = Bpow(x, y >> 1);\n    ret = (ret * (ll)ret) % Mod;\n    if (y & 1)\n        ret = (ret * (ll)x) % Mod;\n    return ret;\n}\n\nint Bdiv(int x, int y){\n    return (x * (ll)Bpow(y, Mod - 2)) % Mod;\n}\n\nvoid setmin(int &x, int y){\n    x = min(x, y);\n}\n\nvoid setmax(int &x, int y){\n    x = max(x, y);\n}\n\nvoid setmin(ll &x, ll y){\n    x = min(x, y);\n}\n\nvoid setmax(ll &x, ll y){\n    x = max(x, y);\n}\n\nint gcd(int a, int b){\n    return a ? gcd(b % a, a) : b;\n}\n\nconst ll llinf = 2e18 + 100;\n\nconst double eps = 1e-9;\n\nconst int maxn = 1e5 + 10, maxw = 1e6 + 10, inf = 1e9 + 100, sq = 300, mod = 1e9 + 7, LG = 17;\n\nint n;\n\nint arr[100];\n\npair<int, int> srt[101];\n\nmap<int, int> mp;\n\nint ord[101];\n\nint q[101][100][100][2][2][2];\n\nvoid add(int &x, int y){\n    x += y;\n    if (x >= mod)\n        x -= mod;\n    if (x < 0)\n        x += mod;\n}\n\nint main()\n{\n    #ifdef ONPC\n    //ifstream cin(\"a.in\");\n    //ofstream cout(\"a.out\");\n    freopen(\"a.in\", \"r\", stdin);\n    freopen(\"a.out\", \"w\", stdout);\n    #else\n    //ifstream cin(\"gymnasts.in\");\n    //ofstream cout(\"gymnasts.out\");\n    //freopen(\"sort.in\", \"r\", stdin);\n    //freopen(\"sort.out\", \"w\", stdout);\n    #endif // ONPC\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n;\n    for (int i = 0; i < n; i++)\n        cin >> arr[i], srt[i] = make_pair(arr[i], i);\n    sort(srt, srt + n, [&](pair<int, int> x, pair<int, int> y){\n            return x.first > y.first || (x.first == y.first && x.second < y.second);\n         });\n    srt[n].first = 1;\n    for (int i = 0; i <= n; i++)\n    if (i == 0 || srt[i].first != srt[i - 1].first)\n        mp[srt[i].first] = mp.size() - 1, ord[mp.size() - 1] = srt[i].first;\n    for (int it = 0; it < n; it++){\n        int i = srt[it].second;\n        int l = i, r = i + 1;\n        while (l >= 0 && arr[l] >= arr[i])\n            l--;\n        while (r < n && arr[r] > arr[i])\n            r++;\n        l++;\n        r--;\n        int t = mp[srt[it].first];\n        if (l == r){\n            q[t][l][r][0][0][0] = 1;\n            q[t][l][r][1][1][0] = 1;\n            continue;\n        }\n        int t1 = 0, t2 = 0;\n        for (int j = i - 1; j >= l; j--)\n            t1 = max(t1, mp[arr[j]]);\n        for (int j = i + 1; j <= r; j++)\n            t2 = max(t2, mp[arr[j]]);\n        if (l < i && t1 < t){\n            for (int a = 0; a < 2; a++)\n                for (int b = 0; b < 2; b++)\n                    q[t][l][i - 1][a][b][0] = ((q[t1][l][i - 1][a][b][0] + q[t1][l][i - 1][!a][!b][0]) * (ll)Bpow(2, ord[t1] - ord[t] - 1)) % mod,\n                    q[t][l][i - 1][a][b][1] = q[t1][l][i - 1][a][b][1];\n        }\n        if (r > i && t2 < t){\n            for (int a = 0; a < 2; a++)\n                for (int b = 0; b < 2; b++)\n                    q[t][i + 1][r][a][b][0] = ((q[t2][i + 1][r][a][b][0] + q[t2][i + 1][r][!a][!b][0]) * (ll)Bpow(2, ord[t2] - ord[t] - 1)) % mod,\n                    q[t][i + 1][r][a][b][1] = q[t2][i + 1][r][a][b][1];\n        }\n        if (l == i){\n            for (int a = 0; a < 2; a++)\n                for (int b = 0; b < 2; b++){\n                    q[t][l][r][a][b][0] = q[t][l + 1][r][!a][b][0];\n                    for (int x = 0; x < 2; x++)\n                        add(q[t][l][r][a][b][1], q[t][l + 1][r][x][b][1]);\n                    add(q[t][l][r][a][b][1], q[t][l + 1][r][a][b][0]);\n                }\n            continue;\n        }\n        if (r == i){\n            for (int a = 0; a < 2; a++)\n                for (int b = 0; b < 2; b++){\n                    q[t][l][r][a][b][0] = q[t][l][r - 1][a][!b][0];\n                    for (int x = 0; x < 2; x++)\n                        add(q[t][l][r][a][b][1], q[t][l][r - 1][a][x][1]);\n                    add(q[t][l][r][a][b][1], q[t][l][r - 1][a][b][0]);\n                }\n            continue;\n        }\n        for (int a = 0; a < 2; a++)\n            for (int b = 0; b < 2; b++){\n                for (int c = 0; c < 2; c++)\n                    add(q[t][l][r][a][b][0], (q[t][l][i - 1][a][!c][0] * (ll)q[t][i + 1][r][!c][b][0]) % mod);\n                int w = 0, h = 0;\n                for (int x = 0; x < 2; x++)\n                    for (int o = 0; o < 2; o++)\n                        add(w, q[t][l][i - 1][a][x][o]),\n                        add(h, q[t][i + 1][r][x][b][o]);\n                q[t][l][r][a][b][1] = (w * (ll)h * (ll)2) % mod;\n                add(q[t][l][r][a][b][1], -q[t][l][r][a][b][0]);\n            }\n    }\n    if (srt[n - 1].first != 1){\n        int t = mp.size() - 1, t1 = t - 1;\n        for (int a = 0; a < 2; a++)\n            for (int b = 0; b < 2; b++)\n                q[t][0][n - 1][a][b][0] = ((q[t1][0][n - 1][a][b][0] + q[t1][0][n - 1][!a][!b][0]) * (ll)Bpow(2, ord[t1] - ord[t] - 1)) % mod,\n                q[t][0][n - 1][a][b][1] = q[t1][0][n - 1][a][b][1];\n    }\n    int t = mp.size() - 1;\n    int ans = 0;\n    for (int a = 0; a < 2; a++)\n        for (int b = 0; b < 2; b++)\n            for (int x = 0; x < 2; x++)\n                add(ans, q[t][0][n - 1][a][b][x]);\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#define mk make_pair\n#define fi first\n#define se second\nusing namespace std;\nconst int maxn=1e5+100;\nconst int mod=1e9+7;\nconst int inf=1e9+1000;\nint h[maxn],n;\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ninline ll ksm(ll num,ll t) {\n    ll res=1;num%=mod;\n    for(;t;t>>=1,num=num*num%mod) {\n        if(t&1)res=res*num%mod;\n    }\n    return res%mod;\n}\npll solve(int l,int r,int c) {\n    if(l>r)return mk(1,0);\n    vi tmp;tmp.clear();int mi=inf,w=0;\n    pll ans=mk(1,1);\n    for(int i=l;i<=r;i++)mi=min(mi,h[i]);\n    tmp.push_back(l-1);for(int i=l;i<=r;i++)if(h[i]==mi)tmp.push_back(i),w++;tmp.push_back(r+1);\n    for(int i=1;i<tmp.size();i++) {\n        int le=tmp[i-1]+1,re=tmp[i]-1;\n        pll tmp_ans=solve(le,re,mi);\n        ans.fi*=tmp_ans.fi;ans.fi%=mod;\n        ans.se*=tmp_ans.fi+tmp_ans.se;ans.se%=mod;\n    }\n    ans.se=ans.se*ksm(2,w)%mod+(ksm(2,mi-c)-2)*ans.fi%mod;ans.se%=mod;\n    ans.fi*=ksm(2,mi-c);ans.fi%=mod;\n    return ans;\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin>>n;\n    for(int i=1;i<=n;i++)cin>>h[i];\n    pll ans=solve(1,n,0);\n    cout<<ans.se;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*\nCoded by 秦惜梦\nThe most attractive girl in the world\n@@@@@@@@@@##&|;!!!!!!!!!!||||||||%%%%%$$$$$$$$$$$$%%$$$&&&&&&&&&$$&&&&&&&&&@@@&%||||||$&&&&@&%;'```'`':!||%&@@@@#@&&&&&@@@&&$$$&&@@&$$$&@@@@@@@@@@@@@#@@@@@@@@@@#@@@@@#@@@@@@@@@@##$\n@@@@@@@@@####$!;!!!!!!!!!||||||||%%%%%%%%%%%%%%%$$$$&&&&&&&&&&&&&&&&&&&&@@@@@@&%|||||!:'`'!$&&&&&&%:''!|||$&&&@@@@@@&&&&&@@@&$$$&&@&&$&&@@@@@@@@@@@@@@@@@@@@@@@@##@@@@#@@@@@@@@@@#@%\n@@@@@@@@@####@|;!!!!!!!!!|||||||%%%%%%%%%%%%%$$$$$$$$$$&&&&&&&&&&&&&&&@@@@@@@@&%|;:'''''``````'!$&&&@@&|:;%$$&&&@@@@@&&&&&@@@&$$$&&@@@@@@@@@@@@@@@@@@@@@@@#@@@@@#@@@@@#@@@@#@@@@##@%\n@@@@@@@@####@@&|;!!!!!!!!|||||||%%%%%%%%%%%%%%$$$$$$$$&&&&&&&&&&&$$$&&@@@@@@@@@@&$|;'''''````````'':!$&&&$%%%%$$&@@@@@&&&&&@@@@&&&@@#@@@@@@@@@@@@@@@@@@@@@@@@@@@#@@@@@@@@@@#@@@@#@@%\n@@@@@@@#####@@@$!;!!!!!!|||||||%%%$$$$$%%%%%%%%%$$$$$$$&&&&&&&&&$$$$&&@@@@@@@@$%$&@@&&&@&$%;:':;:''`````'|%%%%%%$$&@@@@@&&&&@@#@@@@@@#@@@@@@@@@@@@@@@@#@@@@@@@@@#@@@@@@@@@@@@@@#@@@%\n@@@@@@#####@$%%%$$$%%%||%%||||%%%%$%%$$$$$%%%%%%%$$$$&&&&&&&&&$$$$$$&&@@@@@@@&$;'''''':!%&&&&&&@@&%;'```:$&&%%%%%$$$&@@@@&&&&@@@@@@@@@#@@@@@##@@@@@@@@#@@@@@@@@@@@@@@#@@@@@@@@@#@@@%\n$&@@@@######&&&&&$%%%%|%|||||||%%%%%$$$$$$$$$$$$$&&&&&&&&&&&&&&&&$$$$&&@@@@@@&$!''''''````````:!|$&&&&&&&$&&&$%%%%$$$&&@@@&&&&&@@@@&@@@@@@@@@#@@@@@@@@#@@@@@&&&@@@@@@@@@@@@@@@#@@@@$\n$$$&@######@&&&&&&|!!!!!|||||||%%$$$$$$$$$$$$$$$&&&&&$$&&&&&&&&&&&&$$&&&@@@@@@&%;::''````````'':'``....`;|%$&&&$%%$$$$$&@@@&&&&&@@@@@@@@#@@@@@#@@@@@@@@@@@@@@&&@&&&&&&&&&@@@@@@@@@@$\n$$$&@#####@&$$&&@#&|!!!!!|||||||%%%$$$$%%%%%$$$$$$$&&&&&&&&&&&&@@@@@&&&&&&@@@@@@@@@@@&&&&&&&&@@@@&&$$%||||%%%$$&&&$$$$$$$&@@@&&&&&@@@@@@@#@@@@@@@@@@@@@@@@@@@@&&@&&&&&&&&@@@@@@@@@#$\n$$&@######@&$&@##@&$|!!!!|||||||%%%%%%%%%%%%%$$$$&&&&&&&&&&&&&&&&&&&&$$&&&&&&@@&|'`````````':::;;;;;;!|%%%%%%%%$&@@&$$$$$$$&@@&&&&&@@@@@@@@@@@@@@@@@@@@#@@@@@@@@@&&&&&&&&&@@@@@@@#@%\n$&@######@&&&@##@$$$$|!!!||||||||%%%%%%%%%%%%$$$$&&&&&&&&&&&&&&&&&&&&$&&&&&&&&@@$!:::'':::::::::::::''``.:%%$$$$$$&@@@&$$$$$&@@@&&&&@@@@@@@@@@@@#@@@@@@@@@@#@@@@#@@@@@@&&&@@@@@@@@@%\n$&@######@&&@#@&$$$$&$|!!!||||||||%%%%%%%%%$$$$$&&&&&&&&&&&&&&&&&&&$$$&&&&&&&&&&&%;::::::::::::':''':'':::%&$$$$$$$$&&@@&$$$$$&@@@&&&&@@@@@@@@@@@@@@@@@@#@@@@@@@@@@@@@@@@@@@@@@@@@@%\n&@#######@@@#@&$$$$$&&$|!!|||||||||%%%%%%$$$$$$$$$&&&&&&&&&&&&&&&$$$$$&&&&&&&&&&&$!''::::'''::;!|%%$&&@@@@&&@@$$%%$$$$&&@&&$$$$&@@@&&&&@@@@@@#@@@@@@@@@@@@@@@@@#@@@@@@@@@@@@@@@@@@@%\n############&$$$$$$$&&&$|!!||||||||%%%%%%$$$$$$$$$$$$$$&&&&&$$$$$$$$$$&&&&&&&&&&&&@@@&&&&&&&@@@@@@&&&$$%|!;%@@@@&$$$$$$$$&@@&$$$$&@@@&&&@@@@@@@@@#@@@@@@#@@#@@@@@@@@@@@@@@@@@@@@@@@$\n########@&$$$$$$$$$&&&&&$|!!||||||%%%%%%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$&&@@&&&&&&&&&&&&&&$$$$$$$$$$&&&$$%!;:::|$&@@@@&$$$$$$$&@@&$$$&@@@&&&@@@@@@@@##@@@@@@@@@@@@#@@@@@@@@@@@@@@@@@@@$\n########@$%%%$$$$$$&&&&&&&%!||||%%%$$$%%%%%%%%%%%%%%%%%%%%%%%$$$$$&&&&&&&&&&@@@&&&&&&&&&&&&$$$$$$$$$$$$$&&%!!$$$$&@@@@&$$$$$$&@@@&&&&@@@&&@@@@@@@##@@@@@#@@@@@@@@@@@@@@@@@@@@@@@@@@%\n#######@&$$$$$$$$$$$$&$|!||%%%%||%%%%%%%%%%%%%%%%%$$$$$$&$$$$$&&&&&&&&@@@@&&&&&&&&&&&&&&&&&&&$$&&$$$$$$$$$&&&$&@&$$$&@@@&$$$$$$&@@@@&&@@@@&@@@@@@###@@@@@@@@@@@@@@@@@@@@@@@@#@@@@#@%\n#######@$$$$$$%$$$$$$$&&$||||%%%%%%$$$$$$$$$$$$$$$$$$$$$$$&&&&&&&&&&@@&&&&&&&&&&&&$$$$$$&&&&$$$$$$$$$$$$$$$$$$&@@@@&$$$&@@@&$$$$&&&@@@&@@@@&&@@@@@###@@@@#@@@@@#@@@@@@@@@@@#@@@@#@@$\n#######&$$$$$$$$$$&$$$$$&&&&&$%||%%%%%%$$$$$$$$$$$$$$$$$&&&&&&&&&&&@&&&&&&&&&&&&$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$&&@@@&$$$&@@@&$$&&&@@@@@@#@@@@@@@@##@@@@#@@@@@@@@@@@@@#@@@@@@##@##$\n######@$$$$$$$$$$$$$$$$$$&&&&&&$||%%%%%%%$$$$$$$$$$$$$&&&&&&&&&@@&&&&&&&&&&&&&&$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$&@@@@@&&$&&@@@&&&&&@@@@@##@@@@@@@##@@@###@@@@@@@@@@@@@@#@@@#@#@@%\n######&$$$$$$$$$$$$$$$$$&&&&&&&&$%|%%%%%%%$$$$$$$$$$&&&&&&&&&&@&&@@&&&&&&&&&&$$$$$$$$$$$$$$$$$$$$$$$&$$$$$$$$$$$$$$$$&@@@@@@&&&&&@@@&&&&@@@@@#@@@@@###@@@##@@@@@@@@@@@@@@#@@@####@#$\n#####@$$$$$$$$$$$$$$$$$$$&&&&&&&&&%%%%%%%%%$$$$$$$$&&&&&&&&&&&&&&&&&&&&&&&&$$$$$$$$$$$$$$$$$$$$$$$$$$&$$$$$$$$$$$$$$$$$&&&@@@@@&&&&@@@@@@@@@@@@#@@@@###@@@$%%%%%%%%%%%%%$&@@#######$\n#####@&$%$$$$$$$$$$$$$$$$$$&&&&&&&&$%%%%%%%%%%$$$$&&&&&&&&&&&&&&&&$$$$$$$$$$$$$$$$$$$$$$$$$$%$$$$$$$$$%%$$$$$$$$%%$$$$$%&@&&&&@@@@@&&@@@@@&&@@@@#@@@@###@&%%%%%%%%%%%%%%%%%&@##@##@%\n####@@@@&$$$$$$$$$$$$$$$$$$&&&&&&&&&&%%%%%%%%%%$$&@&&&&$&&&$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$||$$$$$$$$%%$$$$$|%$$$$$$$%%$&@@@&&&@@@@@@@@@@@@&@@@@@@@@##@&%%%%%%%%%%%%%%%%%%%$@@@@@%\n####@@@@@@&$%$$$$$$$$$$$$$$$$$&&&&&&&&$%%%%%%%$&&&&&$$$$$$&$$$$$$$$$$$$$$$$$$$$$$$%%$$$%%%%|!|||$$$$%!|%%%$$&$$$$$$$$$$%%%$&@#@@@@&&@@@@@@@@@@@@@@##@@@@#@@@&$$%%%%%%%%|%%%%%|$@@@@$\n###@@@@@@@@$$$%$$$$$$$$$$$$$&&&&&&&&&&&&%%%%%&&&&&$%%%$$&&&$$$$$$$$$%%%$$|%$$$%%%$%%|%%!;!||!!||%$$$$$$$%%$&$$&&$$$$$$$$$$%%$@@#@@@@@@&&@@@@@@@@#@@###@@@########@@$%%%%%%%|%%$&@##$\n##@@@@@@@@@&$$$&$$$$$$$$$$$$$$$&&&&&&&&&&&%%%$&%|%%%%%$%%$$%%%%%%$$$%%%$$||%%%$$$$$%%%%%$$$$$%!!|%&&$$$$%|$$$$$$&$$$$$$$$$$$%$$&@@@@@@@@@@@@@@@##@@@@##@@####@@#######&%%%%%%%$@###$\n#@@@@@@@@@@&&$$&$$$$$$$$$$$$$$$&&&&&&$||%%%$$%!;!;!|%%%%$%!||||%%%$$$||%$%%%%%%$$$$%$$%%%%$%$$$$||$&&$$&%|%$$$$$$$&$%%$%|%$$$$%$%$@@@@@@##@@@@@@@@@@########@##@@@######&$$&@@@@@##$\n@$$&@@@@@@@&&$$$$$$$$$$$$$$$$$$&&&$&&&&$$&$$%!|%%%%%%%%%%||%%%%%%%%$$||%$$$$%%%%$$$%%$$%%%%%%%$$%|%&&$$&$%%$$$$$$$&&$%%&&&&$$$$$$$||$@@@@@@@@@@@@@@@@@@@####@@@@##@@@#@@@@@@@@@@@@@%\n&$%%$$&&&$$$$$$$$$$$$$$$$$$$$$$$$$$&&&&&&&&|!|%%%%|%%%%%%$%%%%||||%$$%|%$&&$%%%%$$$$%$$%%%%$$$$$%|$&&&$&$$$&$&$$$$&&&$%$&&&$$&&&&&$%!!|$&@@@@@@@@@@@@@@@@###@@@@@@@@@@@@@@@@@@@@@@@%\n$$%$$$$$$$$$$$$$$$$$$$$$$$$$$$$&&&$&&&&&&$|!|||%%|%%%%%%$$%%%%||||%$$%%%$&&$%%%$$&&&$$$$$$$$$$$$$%%&&&&&$$&&$&$$&&&&&&&&&&&&&&&&&&&&$|!!!!$&@@@@@@@@@@@#####@######@##@@&@@@@@@@@@@$\n$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$&&&&&&$|!|||%$%%%%%%%$$$$%%%||||%$$%%%$&&$$%%$&&&&&$$$$$$$$$$$$%%&&&&&$$&&$&$$&&&&&&&&&&&&&&&&&&&&&&%!!!!|&&&@@@@@@#########@########@@##########$\n$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$&&&&&$&$%|!||%$$%%$%%%%$$$$$%%|||||$$$&$$&$$$%$&&&&&&$$$$$%$$$$$$%$&&&&&&&&&&&$$&&&&&&&&&&&&&&@@&&&&&@@$|!$@&||||%&@#@@####@########@@@@@@@#@&&@@##$\n$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$&&&$$&$%|!||%$$%%%%%%%$$$%$$%%||||%$&&&&&&$$$$$$&&&&&$%$$$%%$$$$$%$&&&&&&&&$$$$$&&&&&&&&&&&&&&@@@&&@@@@@&@@&|||||||||%&@###############@@@@@@##@@@@%\n%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$&$&&$$$$%!!|%$$$%%%%%%$$$$%$$$%||||$&&$$&&$$$$$$$&&&$&$%%$%%%%%%$$%$$$&&&&&$$$$$$&&&&&&$&&&&&&&&&&&&&&&@@@@&||||||||||||$@#####@@@########@@@@@###@@$\n%%%%%%%%$$$$$$$$$$$$$$$$$$$$$$$$$&&%%&%!!||%$$%%$$%%$$$$%%$$%%|!|%&&$%%&&$%%%%$$$&$|%$||$%%%%%%$$$$$$&&&&$$$$$$&&&&&&$$$&&&&&&&&&&@@&&&@@@&&%|||||||||%&@@##@$$@@@@########@@@@@@##$\n;:''':;!|%%$$$$$$$$$$$$$$&&&&&&&&%%&&$!!|%%%%%%%$$$$$$$%%%$%%%|||$$&%!%&$%%%%|%%%&%!|$||%%%%%%%$$$$%%$&&$$$$$$$&&&&&&$$$$&&&&&&&&&&&&&&@@@@&&%|||||||%@@@@#@%|&#$||||%&@@@@@@@@@@@@$\n.....  .`;|%%$$$$$$$$$$$&&&&&&$%%$&&$!;|%%|||%%$$&&&&$$%%$$%%%%%%%&%!;|$$%||||%%%$|;!%||$%$$$$$%%%%||$&$%%%$$$$&&&&&&$$$$&&&&&&&&&&&&&@@@@@@&&%|||||$@@@##&%|%@@%||||||||||&@@@@@@@%\n........  `;|%$$$&&&&&&&&&&&$%$&&&&$|!|%%|!!|||$&$&&&$$%%%%%||||%$$|;;|%%|||||%$&&$|!|!!%%%%%%|!!|%!%$$%||%$&$&&&&&&&$$$$&&&&&&&&&&&&@@@@@@@@&&%|||$@@@##@$||$#&|||||||||||&#$|||||!\n...    ..  `;|%$$$$&&&&&&$%$$&&&&&&||%%$||!!||$&$$$$$$%%%%%%||||%$%!:!!!%%$$$%%%%|!;;;;;!!!!!;;;||!%&%|%%%$&&$&&&&&&&$$$$&&&&&&&&&&&@@@@@@@@@&&$||$@##@@@%||%&@$||||||||||%&@$|||||!\n       ..  .'!|%$$&&&&&&&&&&&&&&&&||$$&%||!||%&&$$$$$$%%$%||||||%|!;:;;;|%|!!!!!|!|$$&&&&$$$%!!!!;|&&$%%%$&$$$$%||&@&$$$$&&&&&&&&&@@@@@@@@@@@@&$|%@@@@#@%|||$@&%||||||||||%@@%|||||!\n       ... .';|%$$&&&&&&&&&&&&&&&%%&$&&%|||||%&&$$$$$$%%$%%%||||%!;:::::::'':;!|%%%%$&@&&$%|!|%|;!$&$%|%%$$$$&$|!|$@@&$$$&@@@@@@@@@@@@@@@@@@@@&$$@@@#@&%|||%&#$|||||||||||$@&%|||||!\n    ....   .:!|%$$&&&&&&&&&&&&&&$$&&&&$|||||%$@&$$&$$&&&$%|%%%%|;::''''''````'!!!;'`'%@&%|!::!;;!$$||%%%$&$$$$|!!|%&@@&&&&@@@@@@@@@@@@@@@@@@@@&&@@@@#@%||||$@@$|||||||||||$#&||||||!\n     ..   .';!|%$$$&&&&&&&&&&&&$$&&&&&$$%||%%&@&$$&$$$$%|!;;;;:::'`````````````````';;:;!;'::::;%$|||!!|$$$%$%||||$@@@&&&@@@@@@@@@@@@@@@@@&&@&&&&&&@@@$%%||&#&%||||||||||%&#$||||||!\n        .`:!!!|$$&&&&&&&&&&&&&&&&&&&&&&&$%$$$&@&&$&&$$|!|%$$$$%|;''``````````````':;!!!;::''':;!$%|$$%%$$$$$$%!!%&@@@@@@@@@@@@@@@@@@@@@@@@&&&&@&$$&@@@@@@@@@#&%||||||||||%@@$||||||!\n;:''`'':;!!!!|%$$&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&$&&&&&$|!%%%%$&$$|;'``````````````''''''''::::;|$&$$$%%$$%%$$$&@@@@@@@@@@@@@@@@@@@@@@@@@@@&&&@&$$$&&&@@@@@@@@@@@@@@&$%|||$@@$||||||!\n|!;;;!!!!!!|%$$$&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&%!:;|!||!!:'''``````````````''''''''':;;|$$$$$%%$%$$$&&&&&@@@@@@@@@@@@@@@@@@@@@@@@&&&@&$$$&&&&&@@@@@##@@@@@&&@@@@@@#@&%|||||!\n%|!!!!!!||%$$$&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&@@&&&&&&$$$!';;;:'```''`````````````````'''''';;:|$$$$$$$$%$$$&@&&&&@@@#@@@@@@@@@@@@@@@@@@@&&@&$$$$$$$&&&@@@@##@%;''|&@@@@@@@#@@@@@@@%\n&$%%%%%%$$$$&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&@&&&@&&&$$$%;``'''``':'``````````````````'''':::;|$$$$$$$%$$$$&&&&&&@@@##@@@@@@@@@@@@@@@@@@&@&$$$&&&$$$&&&@@@@|:''':%@@@@@@@#@@@@@@@@%\n@@&$$$$$&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&@&&@@&&&$$$$%:``````';:'```...`````````````'''':;|$$$$$$%%$$$$&&&&&&&@@##@@#######@@#@@@@@@#@&$$&&&&&$%$$&&@@%:'::'!&@@@@&@@@@@@@@@@@%\n##@&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&@@&&&&&&&$$%:``````':;:```..``````````````''':;|$$$$$$%%$$$&&&&&&&@@@####################@&$$&&$$$$$$$|;|&$!''':;$&&&&&&@@@@@@@@@@@%\n##@&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&$&@&$&&&$&&&&&%'``````.``````....```````````'`'';|$&$$$%$$$$$$&&&&&@@@@@##################@$$$&&$$$$$|:':;%&$;''''|&&&&&&&&@@@@@@@@@@%\n##@&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&$%$&@@$$$$$&&&&&@@!````````.......````````````''`'':!%$&&&$$&&&&&&&&&&@@@#@@##############@@&$$$$&$$$$$$|:''|&&|''''!$&&&&&&@@@@@@@@@@@@%\n##@&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&|;%&$&@$$$$$$&&&&&@@&;..``..........````````````''``'';%$&&&&&&&&&&&&&&@@@@@##@############@@@$$$$&$!|$$$$!:':%@%:``':%&&@@@@@@@@@@@@@@@@@%\n##@&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&$!!$&&$&&$|!|%$$$&&&@@@@$:.........``'''``':;:'`````````':!%$&&&&&&&@&&&&&@@@@@@@#@@#########@@@&$$$%!!$$$$$%;'';$&!``':%@@@@@@@@@@@@@@@@@@@&%\n##@&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&|;%&&&&$%%$%!|%%$$$$&&@@@@@$;`.....`...````````````````````';|$&&&&&&&&@@@&&&@###@@@@#@&&##@@@@@&$$$$&&$$$$$$|'```!&%;|&&&&&@@@@@@@@@@@@@@@&&&&%\n###&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&%:|&&&&&$$||$&$|%%%$$&&&@@@@@@@@$;`........``'::'`...```'``````:|$$$&@@&$&@@@@@@&@#@@####@#&&#@$|%&$$%%&&$$$$%!'`.`:!$@@&&&&@@@@@@@@@@@@@@&&&&&&&&%\n###@&&&&&&&&&&&&&&&&&&&&&&&&&&|:!&&&&&&$$%||$&&$%%%$$&&&&@@@@@@@@@@&%:`.................`'````:!;;|$$$&&@@&&&&@@@@&&@########@!':|&$$%%$|;:;;!|%%%%||$@@&&&&&&&@&&&&&&&&&&&&&&&&&&&%\n###@&&&&&&&&&&&&&&&&&&&&&&$!:|&&&&&&&&$$%|%$&&&$%%%$&&&&&@@@@@@@@@@@@&&$;`..............``'';|!;;;;|%$$$$&@@@&&&@@&&$$&&@@@@##@&%||%%%$!:|%%%%%||%!|$@@@&&&&&&&&$$$$$$&&&&&&&&&&&&&%\n###@&&&&&&&&&&&&&&&&&&&|:!$&&&&&&&&&&$%%%%$$&&&$%%$$$$&&@#@@@@@@@@@@@&&&&&&|'...........``:!!;;;;;!!;|$&$%|&@@@&&&&&$!|$$$&@@#@@&%%%%$|'':!%%%%|!|$&&@@&&&&&&&$%%%%$$$$$&&$$$$$$&&&%\n###@&&&&&&&&&&&&&&&|:;%&&&&&&&&&&&&$$%%%%$$&&&&$$$$$$$$&@#@@@@@@@@@&&&&&&&&&&&&|'.....`;%%!!!!;;;!!!!;!%$$&$|%@@@@@&&@$;:::!|%$&$%%%$%:'``';!!|||%$&@@@&&&&&&$%%%%%%%$$$$$%%%%$$$$$|\n###@&&&&&&&&&$|:;%&&&&&&&&&&&&&&&$$%%$%%$&&&&&&$$$$%$$$&@@@@@@@@@##@&&&&&&&&&&&&&&%|%&&&&&$|;;;;;;;;;;;;!$&$&$|!%&@@@@@@&%;::!$$$$$$%;:```````;||||%$&&$$$$$$%|%%%%%%%$$$%%%%%%%%$%|\n###@&&$%|||$&&&&&&&&&&&&&&&&&&$$$$%%$$%$&&&&&&&$$$%%$$&&@@@@@@@@@@@##@&&&&&&&&&&&&&&&&&&&&@%;;;;;;;::;;;;!!$&&$$%!;|$$$&&&$&&&$$$$$%!|$&%:...`.`;|!|||!;!|||||||%%%%%%$%%%||||%%%%%|\n&&@@&&&&&&&&&&&&&&&&&&&&&&&$$$$$$%%$$%$&&&&&&&&$%%%%$$&&@@@@@@@@@@@@#@&@@&&&&&&&&&&&&&@###&%;;;;;;::::;;;!!!!|$$$&&%!:;!$&&&@&$$$&@&&&$%$&|``..'%#@@&$%%||||!;:'`';|%%$%%|||||||||||\n###@&&&&&&&&&&&&&&&&&&&&$$$$$$$$%%$&&$$&&&&&&&&$%%%%$$&&&@@@@@@@@@@@@@@&&&&@@@@@&&@####$;':!!;;;::::;;;;!;!;::::;%&&&&&$$$&@&$$$@@$$$$$&@@@@$%@#@@##@@&%%||||||||%%%|!'`:!||||||||||\n###@&&&&&&&&&&&&&&&&&$$$$$$$$$$$$$$$%%$$$$&&&&@$%%%%$$&&&&&@@@@@@@@@&&&&@@&&&&&&&@@@@|:':;;!!;;:::::::;;!!;:::::::::':::';$$$$$&&$&&&@@@&&@@@@@#######@@##@&%||||||||%%%%|!''!|||||!\n###@&&&&&&&&&&&&&&$$$$$$$$$$$&&$$$$$%%$$$$$&&&&&$%%$$$&&&&&$&&&@@@@&&&&&&&&&&&&@@@%:''':;;;;;:::::::::;;;:::::::::::::;;!%$$$$$|:::|$&&$&@@@@@&$&@#####@@@@####@&$%||%%%||||||;:!||!\n###@&&&&&&&&&&&$$$$$$$$$$$&&&&&$$&&$%%$$$&&&&&&&&$%$$$$$&&&&&&&@@@#@&&&&&&&&@##$;''''':;;;;;:::::::::;!;:::::::::::::::;%&$$$$|''':;%&%!;:'''':|%$&@@@@#@@&&&@##@&&@@$|%%|||||||!:;|\n:;$@@&&&&&&&$$$$$$$$$$$&&&&&&&&&$$&&$$&&&&&&&&&&&$%%$$$&&&&&&&&&&&&@@#######@|:'''''';!!!;::::::;;!!!!;::::::::::::::::|$$$$$!'::;!!%&|;;''''''''''';$&@@#@&&$$&@&&@#@@@#####@$%||;:\n''''':|$&$$$$$$$$$$&&&&&&&&&&&&&&$$&$$&&&&&&&&&&&&&$$$$$&&$$&&&&&@@@@@&$%$%|:''''''':;:::::::::::::;;:::::::::::::::::|$$$$$!::;;;;|&%;;:''''''''''''':!$&@@@&$$$$&################$\n'''''''''';%$$&&&&&&&&&&&&&&&&&&&&$$$$&&&&&&&&&&&&&&$$$$$&@@@@@###@&&$%;''''''''':::;;:::::::::::;;:::'':::::::::::':|$$$$$!::;:::|&%;;:''''''''''''''```:%&@@&&&$$$&##############$\n'''''''''''':':|&&&&&&&&&&&&&&&&&&&&$%$&&&&&&&&&&&&&&$$$$$&@@&@@@&$$%%!:''''''::::::!;::::::::::;;::::::::::::::''':|$$$$$|;;:::;%&|::'''''''''''''`.....``;$@@&&&&$$$&@###########$\n;:'''''''''''''':::!$&&&&&&&&&&&&&&&&&%|$&&&&&&&&&&&&&&$$$$&$$$$$$|:!|;':::::::::::;!;::::::::;;:::::::::::::''''':|$$$$$|;::::|&&|::'''''''''''``........`''!&@@&&&&$$$&@#########$\n.';;;;;:'''''''''''':::;%&@&&&&&&&&&&&&%$&&$$$$&&&&&&$&@&&&$$$$%!:::!|;::::::::::::!!;::::::!;::::::::::::::''''':|&$$$$|;::::|&%;;:'``''''''''````......````'!$@@&&&&&$$$&@#######$\n;;;:`.`:;;;;::'''''''''''':;%@@@&&&&&&&&$$$&&&&&&&&&&@@&!::':'':::::||;::::::::::::!!;:::;!!;;:::::::::::::::''':%&$$$$|;:::;%&|:::'`````````'''```..`...````''!$@@&&&&&&&$$&@#####$\n;;;;;;;;;'..';;;;::''''''''''':|@@@@&&&&&&$%$&&&&&&&@@%:::::::::::::!|;:::::''''''';!;:;!!;:::::::::::::::::''':%&$$$%|;:::|&%;;:'''```````'''''``...      ```''!&@&&&&&&&&&&&&@###$\n:::;;;;;;;;!;;;'':;;;;:'''''''''':!&@@@&&&&&$$&&&&@@@$;::::::::::::';|:``````````'';!;;;:'''```````````````''''|$$$$%|;::|&$!;;:'````````''::''``....      .``'':%@&&&&&&&&&&&&&&@#$\n::::::::;;;;;;;;;;;;:'':;;:''''''''':;%@@@@&&&&$&@@@$;''''''':''`''`:|;````````````:!!:'''``.........``......`!$%%%%|;;|&$!:;'`````````'''::''.     ..    `''``''!$&&@@&&&&&&&&&&&&%\n###@%!:::::::;;;;;;;;;;;;;;;;::'''''::::|&@@@&&&&&&%'```.....````''`'||'``````````';;'''``................. .!$%%%%|!%&$!:;:'``'''````'::::''.       ....``''``'''|@&&&@&&&@&&&&&&$|\n####@&&&@&|;::::::;;;;;;;;;;;;;;;:'''''''::!&@@@@@%:````......```'```;%;`````````''''``.................   .!$%%%%%$&%;:::''```'''```'::::'`.         ...``'```''';$@&&&@@&&&&&&&&&%\n####@&&&&&&&&&$!:::::::;;;;;;;;;;;;;:''''''':|@@@$;````.......``''```'!%;``````''''``.......      ....    .;%%%%%%$%;::'''`````''''`'::::`.             ...`````'''|@&&&&@@&&&&&&&&%\n####@&&&&&&&&&&&&&&|;::::::;;;;;;;;;;;;:::'':;;%&;````.........``'````:||:```':''`......                .`:|%%%%%|;::''''``````'''''::::`.               ....```'''!$@&&&&@@&&&&&&&%\n####@&&&&&&&&&&&&&&&&&&|::::::::;;;;;;;;;:::::;;'````..........``'`````:||:':''`......                .`'!$%%%%|;:''```````````'''''::;'.                 ......``':%@@&&&&&@&&&&&&%\n####@&&&&&&&&&&&&&&&&&&&&&$!:::::::;;;;;;;;;;;;'`````..........`''``````:||:''`.  .                .``!$&$%%%%%;'''`````````````'':::;;`                   .....```'!&@&&&&&&@&&&&&%\n####@&&&&&&&&&&&&&&&&&&&&&&&&&|;:::::;;;;;;;;;:``````...........''````':':|%!'.                .``'|$&|;|%|%%%!''````...`````````':::;;`                    .....```'|@&&&&&&&@&&&&%\n####@&&&&&&&&&&&&&&&&&&&&&&&&&&&$!::::::;;;;;:``````....``......''``':'''':!|%;..         ..``:|%$|;::;|%||%%!'`````......```''`'':::;:'   .......           ....````:%@&&&&&&@@&&&%\n####@&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&%;:::::;;:```````....`.   ...`'':''`.  .':!||;````````';|%%|;::::';|%||%%;'```.........```'''''::::;'. ....````........  ......````:%@&&&&&&@@&&%\n####@&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&|:::::'```````...``.   ..'::'``.   .```':;!||!;;!||!;::::''``';|%||%|;'```..........```'''''::::;:.....``````````...........`````;&&&&&&&@@@&%\n*/\n\nint n;\nint a[105];\nconst int Mod=1'000'000'007;\n\nint ksmii(int a,int b){\n\tif(!b){\n\t\treturn 1;\n\t}\n\tint ff=ksmii(a,b>>1);\n\tff=1LL*ff*ff%Mod;\n\tif(b&1){\n\t\tff=1LL*ff*a%Mod;\n\t}\n\treturn ff;\n}\n\npair<int,int> solve(int l,int r,int lim){\n\tint minx=Mod,cnt;\n\tfor(int i=l;i<=r;i++){\n\t\tif(a[i]<minx){\n\t\t\tminx=a[i];\n\t\t\tcnt=1;\n\t\t}else if(a[i]==minx){\n\t\t\tcnt++;\n\t\t}\n\t}\n\tif(cnt==r-l+1){\n\t\treturn make_pair((ksmii(2,r-l+1)-2+Mod)%Mod,ksmii(2,minx-lim-1));\n\t}\n\tpair<int,int> ans;\n\tint L=-1,rem=r-l+1;\n\tint x1=1,x2=1;\n\tfor(int i=l;i<=r+1;i++){\n\t\tif(L==-1&&a[i]>minx){\n\t\t\tL=i;\n\t\t}else if(L!=-1&&a[i]<=minx){\n\t\t\trem-=i-L;\n\t\t\tpair<int,int> tmp=solve(L,i-1,minx);\n\t\t\tx1=1LL*x1*(tmp.first+4LL*tmp.second%Mod)%Mod;\n\t\t\tx2=2LL*x2*tmp.second%Mod;\n\t\t\tL=-1;\n\t\t}\n\t}\n\tx1=(x1-x2+Mod)%Mod;\n\tans.first=((1LL*x1*ksmii(2,rem)%Mod)+(1LL*x2*((ksmii(2,rem)-2+Mod)%Mod)%Mod))%Mod;\n\tans.second=1LL*x2*ksmii(2,minx-lim-1)%Mod;\n\treturn ans;\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d\",a+i);\n\t}\n\tint peak=0;\n\tfor(int i=1;i<=n;i++){\n\t\tif(a[i]>a[i-1]&&a[i]>a[i+1]){\n\t\t\tpeak+=a[i]-max(a[i-1],a[i+1]);\n\t\t\ta[i]=max(a[i-1],a[i+1]);\n\t\t}\n\t}\n\tpair<int,int> ans=solve(1,n,0);\n\tprintf(\"%lld\\n\",1LL*ksmii(2,peak)*((ans.first+2LL*ans.second%Mod)%Mod)%Mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int MOD = 1000 * 1000 * 1000 + 7;\nconst int INF = MOD;\nconst int N = 101;\nint mod(int n) {\n    return (n % MOD + MOD) % MOD;\n}   \nint fp(int a, int p) {\n    int ans = 1, cur = a;\n    for (int i = 0; (1ll << i) <= p; ++i) {\n        if ((p >> i) & 1) ans = mod(ans * cur);\n        cur = mod(cur * cur);\n    }\n    return ans;\n}   \nint mdiv(int a, int b) {\n    return mod(a * fp(b, MOD - 2));\n}   \nvoid add(int &a, int b) {\n    a = mod(a + b);\n}\nint h[N];\nint dp[N][N];\nsigned main() {\n    #ifdef HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    #else\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    #endif\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; ++i) cin >> h[i];\n    vector <int> c;\n    for (int i = 0; i < n; ++i) c.push_back(h[i]);\n    sort(c.begin(), c.end()); \n    c.resize(unique(c.begin(), c.end()) - c.begin());\n    int r = c.size();\n    c.push_back(INF);\n    dp[0][r] = 2;\n    int p = 2;\n    for (int i = r - 1; i >= 0; --i) {\n        if (c[i] <= h[0] && c[i] > 1) {\n            int down = 1;\n            if (i) down = c[i - 1];\n            dp[0][i] = mod(fp(2, h[0] - down + 1) - p);\n            add(p, dp[0][i]);\n        }   \n    }   \n    for (int i = 0; i + 1 < n; ++i) {\n        for (int j = 0; j <= r; ++j) {\n            if (dp[i][j]) {\n                if (h[i + 1] <= h[i]) {\n                    if (c[j] <= h[i + 1]) {\n                        add(dp[i + 1][j], dp[i][j]);\n                    }\n                    else {\n                        add(dp[i + 1][r], dp[i][j] << 1);\n                    }   \n                }\n                else {\n                    if (j == r) {\n                        dp[i + 1][r] = 2;\n                        int p = 2;\n                        for (int k = r - 1; k >= 0; --k) {\n                            if (c[k] <= h[i]) break;\n                            if (c[k] <= h[i + 1]) {\n                                int down = 1;\n                                if (k) down = c[k - 1];\n                                dp[i + 1][k] = mod(fp(2, h[i + 1] - down + 1) - p);\n                                add(p, dp[i + 1][k]);\n                            }   \n                        }   \n                        for (int k = r; k >= 0; --k) {\n                            if (c[k] <= h[i]) break;\n                            dp[i + 1][k] = mod(dp[i + 1][k] * dp[i][j]);\n                        }   \n                    }\n                    else {\n                        add(dp[i + 1][j], dp[i][j] * fp(2, h[i + 1] - h[i]));\n                    }   \n                }   \n            }   \n        }   \n    }   \n    #ifdef HOME\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j <= r; ++j) cout << dp[i][j] << ' ';\n        cout << '\\n';\n    }\n    #endif\n    int ans = 0;\n    for (int i = 0; i <= r; ++i) add(ans, dp[n - 1][i]);\n    cout << ans << '\\n';\n}   "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <algorithm>\n#define ri rd<int>\n#define rep(i, a, b) for (int i = (a), _ = (b); i <= _; ++ i)\n#define For(i, a, b) for (int i = (a), _ = (b); i < _; ++ i)\n#define per(i, a, b) for (int i = (a), _ = (b); i >= _; -- i)\nusing namespace std;\ntypedef long long LL;\nconst int O = 1e9 + 7;\nconst int INF = 1e9 + 7;\nconst int maxN = 107;\n\ntemplate<class T> T rd() {\n\tbool f = 1; char c = getchar(); for (; !isdigit(c); c = getchar()) if (c == '-') f = 0;\n\tT x = 0; for (; isdigit(c); c = getchar()) x = x * 10 + c - 48; return f ? x : -x;\n}\n\ntemplate<class T> inline void apadd(int &x, T y) { x = (x + y) % O; }\ninline void apmax(int &x, int y) { if (x < y) x = y; }\ninline void apmin(int &x, int y) { if (x > y) x = y; }\n\nint pwr(int x, int t) {\n\tint res = 1;\n\tfor (; t; t >>= 1, x = 1LL * x * x % O)\n\t\tif (t & 1) res = 1LL * res * x % O;\n\treturn res;\n}\n\nstruct Node {\n\tint f[2][2][2][2];\n\tNode() { memset(f, 0, sizeof f); }\n\n\tNode flow(int t) const {\n\t\tif (t == 0) return *this;\n\t\tNode res;\n\t\tint tmp = pwr(2, t-1);\n\t\trep (l, 0, 1) rep (r, 0, 1) rep (a, 0, 1) rep (b, 0, 1) {\n\t\t\tif (a || b) {\n\t\t\t\tif (t & 1) apadd(res.f[l^1][r^1][b][a], f[l][r][a][b]);\n\t\t\t\telse apadd(res.f[l][r][a][b], f[l][r][a][b]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tapadd(res.f[l^1][r^1][0][0], 1LL * f[l][r][0][0] * tmp);\n\t\t\t\tapadd(res.f[l][r][0][0], 1LL * f[l][r][0][0] * tmp);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tNode operator + (const Node &v) const {\n\t\tNode res;\n\t\trep (l, 0, 1) rep (r, 0, 1) rep (a, 0, 1) rep (b, 0, 1) \n\t\trep (ll, 0, 1) rep (rr, 0, 1) rep (aa, 0, 1) rep (bb, 0, 1) \n\t\t\tapadd(res.f[l][rr][a || aa || (r==0&&ll==0)][b || bb || (r==1&&ll==1)], 1LL * f[l][r][a][b] * v.f[ll][rr][aa][bb]);\n\t\treturn res;\n\t}\n}a[maxN];\n\nint n;\nint h[maxN];\n\nNode solve(int l, int r, int dw) {\n\tint m1 = INF;\n\trep (i, l, r) apmin(m1, h[i]);\n\tNode res;\n\tfor (int i = l, j = i; i <= r; i = j + 1, j = i) {\n\t\tif (h[i] == m1) {\n\t\t\tNode tmp; tmp.f[0][0][0][0] = tmp.f[1][1][0][0] = 1;\n\t\t\tif (i == l) res = tmp;\n\t\t\telse res = res + tmp;\n\t\t}\n\t\telse {\n\t\t\tfor (; j <= r && h[j] > m1; ++j); --j;\n\t\t\tNode tmp = solve(i, j, m1);\n\t\t\tif (i == l) res = tmp;\n\t\t\telse res = res + tmp;\n\t\t}\n\t}\n\treturn res.flow(m1 - dw);\n}\n\nint main() {\n\n\tn = ri();\n\trep (i, 1, n) h[i] = ri();\n\t\n\tNode res = solve(1, n, 1);\n\tLL ans = 0;\n\trep (l, 0, 1) rep (r, 0, 1) rep (a, 0, 1) rep (b, 0, 1) ans += res.f[l][r][a][b];\n\tprintf(\"%lld\\n\", (ans % O + O) % O);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\n#include<queue>\n#include<map>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cassert>\n#include<cmath>\n#include<climits>\n#include<iomanip>\n#include<stack>\n#include<unordered_map>\n#include<bitset>\n#include<limits>\n#include<complex>\n#include<array>\n#include<numeric>\n#include<functional>\n\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rrep(i,m,n) for(ll (i)=(ll)(m);(i)>=(ll)(n);(i)--)\n#define rep(i,m,n) for(ll (i)=(ll)(m);i<(ll)(n);i++)\n#define REP(i,n) rep(i,0,n)\n#define FOR(i,c) for(decltype((c).begin())i=(c).begin();i!=(c).end();++i)\n#define all(hoge) (hoge).begin(),(hoge).end()\ntypedef pair<ll, ll> P;\nconstexpr long double m_pi = 3.1415926535897932L;\nconstexpr ll MOD = 1000000007;\nconstexpr ll INF = 1LL << 61;\nconstexpr long double EPS = 1e-10;\ntemplate<typename T> using vector2 = vector<vector<T>>;\ntemplate<typename T> using vector3 = vector<vector2<T>>;\ntypedef vector<ll> Array;\ntypedef vector<Array> Matrix;\nstring operator*(const string& s, int k) {\n\tif (k == 0) return \"\";\n\tstring p = (s + s) * (k / 2);\n\tif (k % 2 == 1) p += s;\n\treturn p;\n}\n\ntemplate<class T> inline bool chmin(T& a, T b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstruct Edge {//グラフ\n\tint to, rev; ll cap;\n\tEdge(int _to, ll _cap, int _rev) {\n\t\tto = _to; cap = _cap; rev = _rev;\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nvoid add_edge(Graph& G, int from, int to, ll cap, bool revFlag, ll revCap) {//最大フロー求める Ford-fulkerson\n\tG[from].push_back(Edge(to, cap, (ll)G[to].size()));\n\tif (revFlag)G[to].push_back(Edge(from, revCap, (ll)G[from].size() - 1));//最小カットの場合逆辺は0にする\n}\n\nll max_flow_dfs(Graph& G, ll v, ll t, ll f, vector<bool>& used)\n{\n\tif (v == t)\n\t\treturn f;\n\tused[v] = true;\n\tfor (int i = 0; i < G[v].size(); ++i) {\n\t\tEdge& e = G[v][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tll d = max_flow_dfs(G, e.to, t, min(f, e.cap), used);\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n//二分グラフの最大マッチングを求めたりも出来る　また二部グラフの最大独立集合は頂点数-最大マッチングのサイズ\nll max_flow(Graph& G, ll s, ll t)//O(V(V+E))\n{\n\tll flow = 0;\n\tfor (;;) {\n\t\tvector<bool> used(G.size());\n\t\tREP(i, used.size())used[i] = false;\n\t\tll f = max_flow_dfs(G, s, t, INF, used);\n\t\tif (f == 0) {\n\t\t\treturn flow;\n\t\t}\n\t\tflow += f;\n\t}\n}\nvoid BellmanFord(Graph& G, ll s, Array& d, Array& negative) {//O(|E||V|)\n\td.resize(G.size());\n\tnegative.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\tREP(i, d.size())negative[i] = false;\n\td[s] = 0;\n\tREP(k, G.size() - 1) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[i] != INF && d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tREP(k, G.size() - 1) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[i] != INF && d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t\tnegative[G[i][j].to] = true;\n\t\t\t\t}\n\t\t\t\tif (negative[i] == true)negative[G[i][j].to] = true;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid Dijkstra(Graph& G, ll s, Array& d) {//O(|E|log|V|)\n\td.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\td[s] = 0;\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(make_pair(0, s));\n\twhile (!q.empty()) {\n\t\tP a = q.top();\n\t\tq.pop();\n\t\tif (d[a.second] < a.first)continue;\n\t\tREP(i, G[a.second].size()) {\n\t\t\tEdge e = G[a.second][i];\n\t\t\tif (d[e.to] > d[a.second] + e.cap) {\n\t\t\t\td[e.to] = d[a.second] + e.cap;\n\t\t\t\tq.push(make_pair(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nvoid WarshallFloyd(Graph& G, Matrix& d) {//O(V^3)\n\td.resize(G.size());\n\tREP(i, d.size())d[i].resize(G.size());\n\tREP(i, d.size()) {\n\t\tREP(j, d[i].size()) {\n\t\t\td[i][j] = ((i != j) ? INF : 0);\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G[i].size()) {\n\t\t\tchmin(d[i][G[i][j].to], G[i][j].cap);\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G.size()) {\n\t\t\tREP(k, G.size()) {\n\t\t\t\tchmin(d[j][k], d[j][i] + d[i][k]);\n\t\t\t}\n\t\t}\n\t}\n}\nbool tsort(Graph& graph, Array& order) {//トポロジカルソートO(E+V)\n\tint n = graph.size(), k = 0;\n\tArray in(n);\n\tfor (auto& es : graph)\n\t\tfor (auto& e : es)in[e.to]++;\n\tpriority_queue<ll, Array, greater<ll>> que;\n\tREP(i, n)\n\t\tif (in[i] == 0)que.push(i);\n\twhile (que.size()) {\n\t\tint v = que.top();\n\t\tque.pop();\n\t\torder.push_back(v);\n\t\tfor (auto& e : graph[v])\n\t\t\tif (--in[e.to] == 0)que.push(e.to);\n\t}\n\tif (order.size() != n)return false;\n\telse return true;\n}\nclass Lca {\npublic:\n\tconst int n = 0;\n\tconst int log2_n = 0;\n\tstd::vector<std::vector<int>> parent;\n\tstd::vector<int> depth;\n\n\tLca() {}\n\n\tLca(const Graph& g, int root)\n\t\t: n(g.size()), log2_n(log2(n) + 1), parent(log2_n, std::vector<int>(n)), depth(n) {\n\t\tdfs(g, root, -1, 0);\n\t\tfor (int k = 0; k + 1 < log2_n; k++) {\n\t\t\tfor (int v = 0; v < (int)g.size(); v++) {\n\t\t\t\tif (parent[k][v] < 0)\n\t\t\t\t\tparent[k + 1][v] = -1;\n\t\t\t\telse\n\t\t\t\t\tparent[k + 1][v] = parent[k][parent[k][v]];\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dfs(const Graph& g, int v, int p, int d) {\n\t\tparent[0][v] = p;\n\t\tdepth[v] = d;\n\t\tfor (auto& e : g[v]) {\n\t\t\tif (e.to != p) dfs(g, e.to, v, d + 1);\n\t\t}\n\t}\n\n\tint get(int u, int v) {\n\t\tif (depth[u] > depth[v]) std::swap(u, v);\n\t\tfor (int k = 0; k < log2_n; k++) {\n\t\t\tif ((depth[v] - depth[u]) >> k & 1) {\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\tif (u == v) return u;\n\t\tfor (int k = log2_n - 1; k >= 0; k--) {\n\t\t\tif (parent[k][u] != parent[k][v]) {\n\t\t\t\tu = parent[k][u];\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][u];\n\t}\n};\n\nclass UnionFind {\n\tvector<int> data;\n\tll num;\npublic:\n\tUnionFind(int size) : data(size, -1), num(size) { }\n\tbool unite(int x, int y) {//xとyの集合を統合する\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\tnum -= (x != y);\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {//xとyが同じ集合か返す\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {//xのルートを返す\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tll size(int x) {//xの集合のサイズを返す\n\t\treturn -data[root(x)];\n\t}\n\tll numSet() {//集合の数を返す\n\t\treturn num;\n\t}\n};\n\ntemplate<typename T, typename F>\nclass SegmentTree {\nprivate:\n\tT identity;\n\tF merge;\n\tll n;\n\tvector<T> dat;\npublic:\n\tSegmentTree(F f, T id,vector<T> v) :merge(f), identity(id) {\n\t\tint _n = v.size();\n\t\tn = 1;\n\t\twhile (n < _n)n *= 2;\n\t\tdat.resize(2 * n - 1, identity);\n\t\tREP(i, _n)dat[n + i - 1] = v[i];\n\t\tfor (int i = n - 2; i >= 0; i--)dat[i] = merge(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t}\n\tSegmentTree(F f, T id, int _n) :merge(f), identity(id) {\n\t\tn = 1;\n\t\twhile (n < _n)n *= 2;\n\t\tdat.resize(2 * n - 1, identity);\n\t}\n\tvoid set_val(int i, T x) {\n\t\ti += n - 1;\n\t\tdat[i] = x;\n\t\twhile (i > 0) {\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] = merge(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t\t}\n\t}\n\tT query(int l, int r) {\n\t\tT left = identity, right = identity;\n\t\tl += n - 1; r += n - 1;\n\t\twhile (l < r) {\n\t\t\tif ((l & 1) == 0)left = merge(left, dat[l]);\n\t\t\tif ((r & 1) == 0)right = merge(dat[r - 1], right);\n\t\t\tl = l / 2;\n\t\t\tr = (r - 1) / 2;\n\t\t}\n\t\treturn merge(left, right);\n\t}\n};\n\ntemplate< typename T >\nclass FenwickTree {\n\tvector< T > data;\n\tint n;\n\tint p;\npublic:\n\tFenwickTree(int n) :n(n) { \n\t\tdata.resize(n + 1LL, 0);\n\t\tp = 1;\n\t\twhile (p < data.size())p *= 2;\n\t}\n\tT sum(int k) {\n\t\tT ret = 0;\n\t\tfor (; k > 0; k -= k & -k) ret += data[k];\n\t\treturn (ret);\n\t}\n\t\n\tT sum(int a, int b) { return sum(b) - sum(a); }//[a,b)\n\n\tvoid add(int k, T x) {\n\t\tfor (++k; k <= n; k += k & -k) data[k] += x;\n\t}\n\n\tint lower_bound(ll w) {\n\t\tif (w <= 0)return -1;\n\t\tint x = 0;\n\t\tfor (int k = p / 2; k > 0; k /= 2) {\n\t\t\tif (x + k <= n && data[x + k] < w)w -= data[x + k], x += k;\n\t\t}\n\t\treturn x;\n\t}\n};\n\n\n\n//約数求める //約数\nvoid divisor(ll n, vector<ll>& ret) {\n\tfor (ll i = 1; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tret.push_back(i);\n\t\t\tif (i * i != n) ret.push_back(n / i);\n\t\t}\n\t}\n\tsort(ret.begin(), ret.end());\n}\n\nvoid prime_factorization(ll n, vector<P>& ret) {\n\tfor (ll i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tret.push_back({ i,0 });\n\t\t\twhile (n % i == 0) {\n\t\t\t\tn /= i;\n\t\t\t\tret[ret.size() - 1].second++;\n\t\t\t}\n\t\t}\n\t}\n\tif (n != 1)ret.push_back({ n,1 });\n}\n\n\nll mod_pow(ll x, ll n, ll mod) {\n\tll res = 1;\n\twhile (n > 0) {\n\t\tif (n & 1) res = res * x % mod;\n\t\tx = x * x % mod;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\nll mod_inv(ll x, ll mod) {\n\treturn mod_pow(x, mod - 2, mod);\n}\n\nclass Combination {\npublic:\n\tArray fact;\n\tArray inv;\n\tll mod;\n\tll mod_inv(ll x) {\n\t\tll n = mod - 2LL;\n\t\tll res = 1LL;\n\t\twhile (n > 0) {\n\t\t\tif (n & 1) res = res * x % mod;\n\t\t\tx = x * x % mod;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\t//if n >= mod use lucas \n\tll nCr(ll n, ll r) {\n\t\tif (n < r)return 0;\n\t\tif (n < mod)return ((fact[n] * inv[r] % mod) * inv[n - r]) % mod;\n\n\t\tll ret = 1;\n\t\twhile (n || r) {\n\t\t\tll _n = n % mod, _r = r % mod;\n\t\t\tn /= mod; r /= mod;\n\t\t\t(ret *= nCr(_n, _r)) %= mod;\n\t\t}\n\t\treturn ret;\n\t}\n\tll nPr(ll n, ll r) {\n\t\treturn (fact[n] * inv[n - r]) % mod;\n\t}\n\tll nHr(ll n, ll r) {\n\t\treturn nCr(r + n - 1, r);\n\t}\n\tCombination(ll _n, ll _mod) {\n\t\tmod = _mod;\n\t\tll n = min(_n + 1, mod);\n\t\tfact.resize(n);\n\t\tfact[0] = 1;\n\t\tREP(i, n - 1) {\n\t\t\tfact[i + 1] = (fact[i] * (i + 1LL)) % mod;\n\t\t}\n\t\tinv.resize(n);\n\t\tinv[n - 1] = mod_inv(fact[n - 1]);\n\t\tfor (int i = n - 1; i > 0; i--) {\n\t\t\tinv[i - 1] = inv[i] * i % mod;\n\t\t}\n\t}\n};\n\nll popcount(ll x) {\n\tx = (x & 0x5555555555555555) + (x >> 1 & 0x5555555555555555);\n\tx = (x & 0x3333333333333333) + (x >> 2 & 0x3333333333333333);\n\tx = (x & 0x0F0F0F0F0F0F0F0F) + (x >> 4 & 0x0F0F0F0F0F0F0F0F);\n\tx = (x & 0x00FF00FF00FF00FF) + (x >> 8 & 0x00FF00FF00FF00FF);\n\tx = (x & 0x0000FFFF0000FFFF) + (x >> 16 & 0x0000FFFF0000FFFF);\n\tx = (x & 0x00000000FFFFFFFF) + (x >> 32 & 0x00000000FFFFFFFF);\n\n\treturn x;\n}\n\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\n\tll n;\n\tcin >> n;\n\tvector<P> v(n);\n\tREP(i, n)cin >> v[i].first, v[i].second = i;\n\tauto f = [](P a, P b) {return min(a, b); };\n\tSegmentTree<P, decltype(f)> seg(f, P(INF, -1), v);\n\n\tauto solve = [&](auto solve,ll l, ll r, ll _h)->P {\n\t\tif (l == r)return { 1,0 };\n\t\tauto mn = seg.query(l, r);\n\t\tP tl, tr;\n\t\ttl = solve(solve, l, mn.second, mn.first);\n\t\ttr = solve(solve, mn.second + 1, r, mn.first);\n\t\tll h = mn.first - _h;\n\t\tll dp1 = mod_pow(2, h, MOD) * tl.first % MOD * tr.first % MOD;\n\t\tll dp2 = 2 * (tl.first + tl.second) % MOD * (tr.first + tr.second) % MOD;\n\t\t(dp2 += (mod_pow(2, h, MOD) + MOD - 2) % MOD * tl.first % MOD * tr.first % MOD) %= MOD;\n\t\treturn { dp1,dp2 };\n\t};\n\tcout << solve(solve, 0, n, 0).second << \"\\n\";\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\ntemplate<typename tn> void read(tn &a){\n\ttn x=0,f=1; char c=' ';\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0';\n\ta=x*f;\n}\nconst int mod = 1e9+7;\nint n,h[110],cnt,b[110];\nll f[110][110];\nll fp(ll a,ll k){\n\tll ans=1;\n\tfor(;k;k>>=1,a=a*a%mod)\n\t\tif(k&1) ans=a*ans%mod;\n\treturn ans;\n}\nint main(){\n\tread(n);\n\tfor(int i=1;i<=n;i++)\n\t\tread(h[i]),b[++cnt]=h[i];\n\tsort(b+1,b+cnt+1);\n\tcnt=unique(b+1,b+cnt+1)-b-1;\n\tfor(int i=1;i<=n;i++)\n\t\th[i]=lower_bound(b+1,b+cnt+1,h[i])-b;\n\tf[0][0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tf[i][0]=f[i-1][0]*2%mod;\n\t\tfor(int j=h[i]+1;j<=h[i-1];j++) f[i][0]=(f[i][0]+f[i-1][j]*2)%mod;\n\t\tfor(int j=1;j<=h[i];j++)\n\t\t\tif(h[i]>=h[i-1]) f[i][j]=f[i-1][j]*fp(2,b[h[i]]-b[h[i-1]])%mod;\n\t\t\telse f[i][j]=f[i-1][j];\n\t\tfor(int j=h[i-1]+1;j<=h[i];j++)\n\t\t\tif(j>1) f[i][j]=f[i-1][0]*(fp(2,b[j]-b[j-1]+1)-2)%mod*fp(2,b[h[i]]-b[j])%mod;\n\t\t\telse f[i][j]=f[i-1][0]*(fp(2,b[j])-2)%mod*fp(2,b[h[i]]-b[j])%mod;\n\t}\n\tll ans=0;\n\tfor(int i=0;i<=h[n];i++)\n\t\tans=(ans+f[n][i])%mod;\n\tcout<<(ans+mod)%mod<<'\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nint N;\nint H[105];\nll mo=1000000007;\n\nll modpow(ll a, ll n = mo-2) {\n\tll r=1;a%=mo;\n\twhile(n) r=r*((n%2)?a:1)%mo,a=a*a%mo,n>>=1;\n\treturn r;\n}\n\npair<ll,ll> hoge(int L,int R,int v) {\n\tll dp1=1,dp2=1;\n\tint i;\n\t\n\tif(L>R) return {-1,1};\n\t\n\tint mi=1<<30;\n\tfor(i=L;i<=R;i++) mi=min(mi,H[i]);\n\tint W=R-L+1;\n\tfor(i=L;i<=R;i++) if(mi!=H[i]) W--;\n\t\n\tint pre=L-1;\n\tfor(i=L;i<=R;i++) {\n\t\tif(mi==H[i]) {\n\t\t\tauto r=hoge(pre+1,i-1,mi);\n\t\t\tif(r.first>=0) {\n\t\t\t\t(dp1*=r.first)%=mo;\n\t\t\t\t(dp2*=r.first+r.second)%=mo;\n\t\t\t}\n\t\t\t\n\t\t\tpre=i;\n\t\t}\n\t}\n\tauto r=hoge(pre+1,R,mi);\n\tif(r.first>=0) {\n\t\t(dp1*=r.first)%=mo;\n\t\t(dp2*=r.first+r.second)%=mo;\n\t}\n\t\n\t(dp2=dp2*modpow(2,W)+(modpow(2,mi-v)+mo-2)*dp1)%=mo;\n\t(dp1*=modpow(2,mi-v))%=mo;\n\t\n\treturn {dp1,dp2};\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tfor(i=1;i<=N;i++) cin>>H[i];\n\tcout<<hoge(1,N,0).second<<endl;\n}\n\nint main()\n{\n        solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#define int long long\nusing namespace std;\n\nint mod = 1000000007;\n\nint powmod(int a, int n, int mod) {\n\tif (n == 0) return 1;\n\tif (n % 2 == 0) return powmod((a * a) % mod, n / 2, mod);\n\treturn (powmod(a, n - 1, mod) * a) % mod;\n}\n\nint p2(int n) {\n\treturn powmod(2, n, mod) % mod;\n}\n\nint N;\nint H[100];\n\nint aSize;\nvector<int> a[100];\n\nint n;\nint h[100];\nint dp[101][2];\t//1個, 2個\n\n//hを決めた状態で\nint solve() {\n\tint i, j;\n\t\n\tfor (i = 0; i < 101; i++) for (j = 0; j < 2; j++) dp[i][j] = 0;\n\t\n\tif (n == 1) { return p2(h[0]); }\n\t\n\tdp[2][0] = p2(max(h[0], h[1]));\n\tdp[2][1] = p2(max(h[0], h[1]) - min(h[0], h[1])) * 2;\n\t\n\tfor (i = 2; i < n; i++) {\n\t\tdp[i + 1][0] = dp[i][0] + dp[i][1]; dp[i + 1][0] %= mod;\n\t\tdp[i + 1][1] = dp[i][1]; dp[i + 1][1] %= mod;\n\t\tif (h[i] > h[i - 1]) {\n\t\t\tdp[i + 1][0] *= p2(h[i] - h[i - 1]); dp[i + 1][0] %= mod;\n\t\t\tdp[i + 1][1] *= p2(h[i] - h[i - 1]); dp[i + 1][1] %= mod;\n\t\t}\n\t}\n\t\n\treturn (dp[n][0] + dp[n][1]) % mod;\n}\n\nsigned main() {\n\tint i, j;\n\t\n\tcin >> N;\n\tfor (i = 0; i < N; i++) cin >> H[i];\n\t\n\ta[0].push_back(H[0]);\n\tfor (i = 1; i < N; i++) {\n\t\tif (H[i - 1] == 1) {\n\t\t\taSize++;\n\t\t}\n\t\ta[aSize].push_back(H[i]);\n\t}\n\t\n\tint ans = 1;\n\tfor (i = 0; i < aSize; i++) {\n\t\tn = a[i].size();\n\t\tfor (j = 0; j < a[i].size(); j++) h[j] = a[i][j];\n\t\tans *= solve();\n\t\tans %= mod;\n\t}\n\tcout << ans * p2(h[0]) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long LL;\nusing namespace std;\n\nconst int N=105;\nconst int MOD=1000000007;\nint n,f[N][N],a[N],w[N],m;\n\nint ksm(int x,int y){\n    if (y<0) return 1;\n    int ans=1;\n    while (y){\n        if (y&1) ans=(LL)ans*x%MOD;\n        x=(LL)x*x%MOD;y>>=1;\n    }\n    return ans;\n}\n\nint solution(int n){\n  for(int i=1;i<=n;i++){\n    w[++m] = a[i];\n  }\n  sort(w+1,w+m+1);\n  unique(w+1,w+m+1)-w-1;\n  for (int i=1;i<=n;i++) a[i]=lower_bound(w+1,w+m+1,a[i])-w;\n  f[0][0]=1;\n  for (int i=1;i<=n;i++)\n  {\n      for (int j=a[i]+1;j<=a[i-1];j++) (f[i][0]+=f[i-1][j]*2%MOD)%=MOD;\n      (f[i][0]+=f[i-1][0]*2%MOD)%=MOD;\n      for (int j=1;j<=a[i];j++)\n      {\n          f[i][j]=(LL)f[i-1][j]*ksm(2,w[a[i]]-w[a[i-1]])%MOD;\n          if (a[i-1]>=j) continue;\n          if (j>1) (f[i][j]+=(LL)f[i-1][0]*(ksm(2,w[j]-w[j-1])-1)%MOD*2%MOD*ksm(2,w[a[i]]-w[j])%MOD)%=MOD;\n          else (f[i][j]+=(LL)f[i-1][0]*(ksm(2,w[j])-2)%MOD*ksm(2,w[a[i]]-w[j])%MOD)%=MOD;\n      }\n  }\n  int ans=0;\n  for (int i=0;i<=m;i++) (ans+=f[n][i])%=MOD;\n  return ans;\n}\n\nint main()\n{\n    scanf(\"%d\",&n);\n    for (int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n    int res = solution(n);\n    cout<<res<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 1e9 + 7;\nconst int MN = 111;\n\nint exp(int x, int n) {\n    int ret = 1;\n    while(n) {\n        if(n & 1) ret = 1LL * ret * x % mod;\n        x = 1LL * x * x % mod;\n        n >>= 1;\n    }\n    return ret;\n}\n\nint N;\nint H[MN], mnp[MN][MN];\n\nint cc[MN][MN][MN][2];\nint dp(int l, int r, int p, int t) {\n    if(l > r) return 1;\n    int &ret = cc[l][r][p][t];\n    if(ret != -1) return ret;\n\n    ret = 0;\n    int h = p == N? 1 : H[p];\n    int x = mnp[l][r];\n    int d = H[x] - h;\n    if(t) {\n        ret += 1LL * dp(l, x - 1, x, 1) * dp(x + 1, r, x, 1) % mod * 2 % mod;\n        ret %= mod;\n        ret += 1LL * dp(l, x - 1, x, 0) * dp(x + 1, r, x, 0) % mod * (exp(2, d) + mod - 1) % mod * 2 % mod;\n        ret %= mod;\n    }\n    else {\n        ret += 1LL * dp(l, x - 1, x, 0) * dp(x + 1, r, x, 0) % mod * exp(2, d) % mod;\n        ret %= mod;\n    }\n\n    //cout << l << ' ' << r << ' ' << p << ' ' << t << ' ' << ret << endl;\n\n    return ret;\n}\n\nint main() {\n    scanf(\"%d\", &N);\n\n    for(int i = 0; i < N; i++) {\n        scanf(\"%d\", &H[i]);\n    }\n\n    for(int i = 0; i < N; i++) {\n        int mn = 2e9, p = -1;\n        for(int j = i; j < N; j++) {\n            if(mn > H[j]) mn = H[j], p = j;\n            mnp[i][j] = p;\n        }\n    }\n\n    memset(cc, -1, sizeof(cc));\n    printf(\"%d\", dp(0, N - 1, N, 1));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\n#include <stdlib.h>\n#include <vector>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <string.h>\n#include <stack>\n#define Endl endl\n#define mp make_pair\n#define ll long long \n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define over(A) {cout<<A<<endl;exit(0);}\n#define all(A) A.begin(),A.end()\n#define ceil(a,b) ((a-1)/b+1)\n#define srand() mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n#define rand(l,r) uniform_int_distribution<int>(l,r)(rng)\ntypedef unsigned long long ull;\nconst int inf=1039074182;\nusing namespace std;\nint n;\nint h[105];\nint res=1;\nvector <pair<pair<int,int>,int> >vec;\nint dp[105][105][2];\n\nnamespace combinatorics\n{\n\tint mod=1e9+7;\n\tinline int add(int a,int b)\n\t{\n\t\treturn (a+b)%mod;\n\t}\n\tinline int minus(int a,int b)\n\t{\n\t\treturn (a-b+mod)%mod;\n\t}\n\tinline int mutiply(int a,int b)\n\t{\n\t\treturn (1LL*a*b)%mod;\n\t}\n\tinline int fastpow(int basic,int x)\n\t{\n\t\tint res=1;\n\t\twhile(x)\n\t\t{\n\t\t\tif(x&1)\tres=mutiply(res,basic);\n\t\t\tbasic=mutiply(basic,basic);\n\t\t\tx>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tinline int inv(int x)\n\t{\n\t\treturn fastpow(x,mod-2);\n\t}\n};\nusing namespace combinatorics;\n\ninline void solve(int l,int r)\n{\n//\tcout<<l<<' '<<r<<endl;\n//\tSleep(1000);\n\tif(l==r) return;\n\tint mi=inf,ma=inf;\n\tfor(int i=l;i<r;i++)\n\t{\n\t\tmi=min(mi,h[i]);\n\t}\n\tvec.push_back({{l,r},mi-(l==0 && r==n)});\n\tfor(int i=l;i<r;i++)\n\t{\n\t\th[i]-=mi;\n\t}\n\tint last=l;\n\tfor(int i=l;i<=r;i++)\n\t{\n\t\tif(h[i]==0) solve(last,i),last=i+1;\n\t}\n}\n\ninline int way(int l,int r)\n{\n\tint res=0;\n\tfor(auto x:vec)\n\t{\n\t\tif(l<=x.first.first && r>=x.first.second) res=(res+x.second)%(mod-1);\n\t}\n\treturn fastpow(2,res);\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\",\"r\",stdin);\n//\tfreopen(\"1.out\",\"w\",stdout);\n\tcin>>n;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcin>>h[i];\n\t}\n\tsolve(0,n);\n//\tfor(auto x:vec)\n//\t{\n//\t\tprintf(\"From %d to %d, having %d floors.\\n\",x.first.first+1,x.first.second,x.second);\n//\t}\n\tdp[0][1][0]=1;\n\tdp[0][1][1]=1;\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tfor(int j=1;j<=i+1;j++)\n\t\t{\n\t\t\tfor(int k=0;k<2;k++)\n\t\t\t{\n\t\t\t\tdp[i+1][j+1][k]=add(dp[i+1][j+1][k],dp[i][j][k]);\n\t\t\t\tdp[i+1][1][!k]=add(dp[i+1][1][!k],mutiply(dp[i][j][k],way(i-j+1,i+1)));\n\t\t\t}\n\t\t}\n\t}\n\tint res=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tdp[n-1][i][0]=mutiply(dp[n-1][i][0],way(n-i,n));\n\t\tdp[n-1][i][1]=mutiply(dp[n-1][i][1],way(n-i,n));\n\t\tres=add(res,add(dp[n-1][i][0],dp[n-1][i][1]));\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//https://atcoder.jp/contests/agc026/tasks/agc026_d\n#include<iostream>\n#include<vector>\n#include<cassert>\n#include<algorithm>\n\nint f[100][100][101][2]; // [h,l,r,alt]\n\nint constexpr MOD=1000000007;\nint constexpr INV2=(MOD+1)/2;\n\nint pow2(int exp){\n\tassert(exp>=0);\n\tint base=2,ans=1;\n\twhile(true){\n\t\tif(exp&1)ans=ans*(int64_t)base%MOD;\n\t\texp>>=1;if(exp==0)return ans;\n\t\tbase=base*(int64_t)base%MOD;\n\t}\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(0);std::cin.tie(0);\n\tint n;std::cin>>n;\n\tstd::vector<int> a(n);for(int& x:a)std::cin>>x;\n\n\tauto vals=a;std::sort(begin(vals),end(vals));\n\tvals.erase(std::unique(begin(vals),end(vals)),end(vals));\n\tfor(int& x:vals)x-=1;\n\n\tfor(int hi=vals.size();hi--;){\n\t\tint const h=vals[hi];\n\t\tf[hi][n][n][0]=0;\n\t\tf[hi][n][n][1]=1;\n\t\tfor(int l=n;l--;){\n\t\t\tf[hi][l][l][0]=0;\n\t\t\tf[hi][l][l][1]=1;\n\n\t\t\tint min_lr=a[l];\n\t\t\tif(min_lr<=h)\n\t\t\t\tcontinue;\n\n\t\t\tint hp=-1; // any index with height == h+1, or -1\n\t\t\tif(a[l]==h+1)hp=l;\n\n\t\t\tf[hi][l][l+1][0]=0;\n\t\t\tf[hi][l][l+1][1]=pow2(a[l]-h);\n\n\t\t\tfor(int r=l+2;r<=n;++r){\n\t\t\t\tmin_lr=std::min(min_lr,a[r-1]);\n\t\t\t\tif(min_lr<=h)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif(a[r-1]==h+1)hp=r-1;\n\n\t\t\t\tif(hp>=0){\n\t\t\t\t\tassert(f[hi][hp][hp+1][1]==2);\n\t\t\t\t\tif(hp!=l&&hp!=r-1)\n\t\t\t\t\t\tf[hi][l][r][1]=f[hi][l][hp][1]*(int64_t)f[hi][hp+1][r][1]\n\t\t\t\t\t\t\t%MOD*INV2%MOD;\n\t\t\t\t\telse\n\t\t\t\t\t\tf[hi][l][r][1]=f[hi][l][hp][1]*(int64_t)f[hi][hp+1][r][1]\n\t\t\t\t\t\t\t%MOD;\n\n\t\t\t\t\tassert(f[hi][hp][hp+1][0]==0);\n\t\t\t\t\tf[hi][l][r][0]=\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\t2LL\n\t\t\t\t\t\t\t*\n\t\t\t\t\t\t\t(f[hi][l][hp][0]+f[hi][l][hp][1])\n\t\t\t\t\t\t\t*\n\t\t\t\t\t\t\t(f[hi][hp+1][r][0]+f[hi][hp+1][r][1])\n\t\t\t\t\t\t\t+MOD-f[hi][l][r][1]\n\t\t\t\t\t\t)%MOD;\n\n\t\t\t\t}else{\n\t\t\t\t\tassert(hi!=vals.size()-1);\n\t\t\t\t\tint const nexthi=hi+1;\n\t\t\t\t\tint const nexth=vals[nexthi];\n\t\t\t\t\tf[hi][l][r][0]=f[nexthi][l][r][0];\n\t\t\t\t\tf[hi][l][r][1]=f[nexthi][l][r][1]*(int64_t)pow2(nexth-h)%MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint h0=vals[0];\n\tstd::cout<<(f[0][0][n][0]+f[0][0][n][1]*(int64_t)pow2(h0))%MOD<<'\\n';\n}\n\n\n/*\n\ngiven config A:\n| ........... |\nn of way to fill the row below (assume rect.)\n1 (just flip the last col) if any 2 cons. id\n2 (flip or keep) if alternate\n\nconsider top down\n\nf[l,r,h,0|1] = num of way to fill [l..r[ with h first lay cut of (alternative?)\n(assume all are > h)\n1: must alternate\n0: must not alternate\n\nans = sum f[0,n,0,all]\n\nBASE CASE\n\nlet f[x,x,_,1] = 1 // len <= 1 : alternative\nlet f[x,x,_,0] = 0\nlet f[x,x+1,_,0] = 0\nlet f[x,x+1,h,1] = 2^(h[x]-h) (h[x]-h>0)\n\n\nf[l,r,h,0] = f[l,r,h+1,0] if valid\nf[l,r,h,1] = 2*f[l,r,h+1,1] if valid\n\nif f[l,r,h+1,_] is not valid\nthen there is i in [l..r[ such that h[i]==h\nconsider f[l,i], f[i,i+1] and f[i+1,r]\nf[l,r,h,1] = f[l,i,h,1] * f[i,r,h,1] / 2\nf[l,r,h,0] = \nf[l,i,h,sum] * f[i,i+1,h,sum] * f[i+1,r,h,sum] - f[l,r,h,1]\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=int64_t;\n#define int ll\n\n#define FOR(i,a,b) for(int i=int(a);i<int(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define MP make_pair\n#define PB push_back\n#define ALL(x) x.begin(),x.end()\n#ifdef MAROON_LOCAL\n#define cerr (cerr<<\"-- line \"<<__LINE__<<\" -- \")\n#else\nclass CerrDummy{}cerrDummy;\ntemplate<class T>\nCerrDummy& operator<<(CerrDummy&cd,const T&){\n\treturn cd;\n}\nusing charTDummy=char;\nusing traitsDummy=char_traits<charTDummy>;\nCerrDummy& operator<<(CerrDummy&cd,basic_ostream<charTDummy,traitsDummy>&(basic_ostream<charTDummy,traitsDummy>&)){\n\treturn cd;\n}\n#define cerr cerrDummy\n#endif\n#define REACH cerr<<\"reached\"<<endl\n#define DMP(x) cerr<<#x<<\":\"<<x<<endl\n#define ZERO(x) memset(x,0,sizeof(x))\n#define ONE(x) memset(x,-1,sizeof(x))\n\nusing pi=pair<int,int>;\nusing vi=vector<int>;\nusing ld=long double;\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"{\";\n\tREP(i,(int)v.size()){\n\t\tif(i)os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\nll read(){\n\tll i;\n\tscanf(\"%\" SCNd64,&i);\n\treturn i;\n}\n\nvoid printSpace(){\n\tprintf(\" \");\n}\n\nvoid printEoln(){\n\tprintf(\"\\n\");\n}\n\nvoid print(ll x,int suc=1){\n\tprintf(\"%\" PRId64,x);\n\tif(suc==1)\n\t\tprintEoln();\n\tif(suc==2)\n\t\tprintSpace();\n}\n\nstring readString(){\n\tstatic char buf[3341000];\n\tscanf(\"%s\",buf);\n\treturn string(buf);\n}\n\nchar* readCharArray(){\n\tstatic char buf[3341000];\n\tstatic int bufUsed=0;\n\tchar* ret=buf+bufUsed;\n\tscanf(\"%s\",ret);\n\tbufUsed+=strlen(ret)+1;\n\treturn ret;\n}\n\ntemplate<class T,class U>\nvoid chmax(T& a,U b){\n\tif(a<b)\n\t\ta=b;\n}\n\ntemplate<class T,class U>\nvoid chmin(T& a,U b){\n\tif(b<a)\n\t\ta=b;\n}\n\ntemplate<class T>\nT Sq(const T& t){\n\treturn t*t;\n}\n\n#define CAPITAL\nvoid Yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid No(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nconst int mod=1000000007;\ntemplate<class T,class U>\nvoid add(T& a,U b){\n\t//a=((ll)a+b)%mod;\n\ta+=b;\n\tif(a>=mod)a-=mod;\n}\n\ntemplate<class T,class U>\nvoid sub(T& a,U b){\n\t//a=((ll)a-b%mod+mod)%mod;\n\ta-=b;\n\tif(a<0)a+=mod;\n}\n\ntemplate<class T,class U>\nvoid mult(T& a,U b){\n\ta=((ll)a*b)%mod;\n}\n\nll modPow(ll a,ll p){\n\tll s=1;\n\twhile(p){\n\t\tif(p&1)mult(s,a);\n\t\tmult(a,a);\n\t\tp>>=1;\n\t}\n\treturn s;\n}\n\nll modInv(ll a){\n\treturn modPow(a,mod-2);\n}\n\nconst int Vmax=1000010;\nint fact[Vmax],factInv[Vmax];\nvoid InitFact(){\n\tfact[0]=1;\n\tFOR(i,1,Vmax){\n\t\tfact[i]=fact[i-1];\n\t\tmult(fact[i],i);\n\t}\n\tfactInv[Vmax-1]=modInv(fact[Vmax-1]);\n\tfor(int i=Vmax-2;i>=0;i--){\n\t\tfactInv[i]=factInv[i+1];\n\t\tmult(factInv[i],i+1);\n\t}\n}\nint Choose(int n,int k){\n\treturn ll(fact[n])*factInv[n-k]%mod*factInv[k]%mod;\n}\nint Binom(int a,int b){\n\treturn ll(fact[a+b])*factInv[a]%mod*factInv[b]%mod;\n}\n\nint cf=1;\n\npi rec(vi h){\n\tcerr<<h<<endl;\n\tint n=h.size();\n\tassert(n>=2);\n\tint mn=*min_element(ALL(h));\n\tvi cur;\n\tvector<pi> w;\n\tREP(i,n+1)\n\t\tif(i<n&&h[i]>mn)\n\t\t\tcur.PB(h[i]-mn);\n\t\telse if(!cur.empty()){\n\t\t\tif(int(cur.size())==1){\n\t\t\t\tmult(cf,modPow(2,cur[0]));\n\t\t\t\th[i-1]=mn;\n\t\t\t\tcur.clear();\n\t\t\t}else{\n\t\t\t\tcerr<<i<<\" \"<<cur<<endl;\n\t\t\t\tw.PB(rec(cur));\n\t\t\t\tcur.clear();\n\t\t\t}\n\t\t}\n\tint us=0;\n\tREP(i,n)if(h[i]==mn)\n\t\tus++;\n\tint iti=1;\n\tfor(auto x:w){\n\t\tmult(iti,x.first);\n\t}\n\tmult(iti,2);\n\tint waf=1;\n\tfor(auto x:w){\n\t\tint y=x.first;\n\t\tmult(y,2);\n\t\tadd(y,x.second);\n\t\tmult(waf,y);\n\t}\n\tmult(waf,modPow(2,us));\n\tsub(waf,iti);\n\t\n\tcerr<<waf<<\" \"<<iti<<endl;\n\t\n\tmult(iti,modPow(2,mn-1));\n\t\n\treturn pi(iti,waf);\n}\n\nsigned main(){\n\tint n=read();\n\tvi h(n);REP(i,n)h[i]=read();\n\tint ans;\n\tif(n==1)\n\t\tans=modPow(2,h[0]);\n\telse{\n\t\tpi r=rec(h);\n\t\tans=r.first;\n\t\tadd(ans,r.second);\n\t\tmult(ans,cf);\n\t}\n\tprint(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#define int long long\nusing namespace std;\n\nint mod = 1000000007;\n\nint powmod(int a, int n, int mod) {\n\tif (n == 0) return 1;\n\tif (n % 2 == 0) return powmod((a * a) % mod, n / 2, mod);\n\treturn (powmod(a, n - 1, mod) * a) % mod;\n}\n\nint p2(int n) {\n\treturn powmod(2, n, mod) % mod;\n}\n\nint N;\nint H[100];\n\nint aSize;\nvector<int> a[100];\n\nint n;\nint h[100];\nint dp[101][2];\t//1個, 2個\n\n//hを決めた状態で\nint solve() {\n\tint i, j;\n\t\n\tfor (i = 0; i < 101; i++) for (j = 0; j < 2; j++) dp[i][j] = 0;\n\t\n\tif (n == 1) { return p2(h[0]); }\n\t\n\tdp[2][0] = p2(max(h[0], h[1]));\n\tdp[2][1] = p2(max(h[0], h[1]) - min(h[0], h[1])) * 2;\n\t\n\tfor (i = 2; i < n; i++) {\n\t\tdp[i + 1][0] = dp[i][0] + dp[i][1]; dp[i + 1][0] %= mod;\n\t\tdp[i + 1][1] = dp[i][1]; dp[i + 1][1] %= mod;\n\t\tif (h[i] > h[i - 1]) {\n\t\t\tdp[i + 1][0] *= p2(h[i] - h[i - 1]); dp[i + 1][0] %= mod;\n\t\t\tdp[i + 1][1] *= p2(h[i] - h[i - 1]); dp[i + 1][1] %= mod;\n\t\t}\n\t}\n\t\n\treturn (dp[n][0] + dp[n][1]) % mod;\n}\n\nsigned main() {\n\tint i, j;\n\t\n\tcin >> N;\n\tfor (i = 0; i < N; i++) cin >> H[i];\n\t\n\ta[0].push_back(H[0]);\n\tfor (i = 1; i < N; i++) {\n\t\tif (H[i - 1] == 1 || H[i] == 1) {\n\t\t\taSize++;\n\t\t}\n\t\ta[aSize].push_back(H[i]);\n\t}\n\taSize++;\n\t\n\tint ans = 1;\n\tfor (i = 0; i < aSize; i++) {\n\t\tn = a[i].size();\n\t\tfor (j = 0; j < a[i].size(); j++) h[j] = a[i][j];\n\t\t//for (j = 0; j < n; j++) cout << h[j] << \" \"; cout << endl;\n\t\tans *= solve();\n\t\tans %= mod;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<iostream>\n#define fi first\n#define se second\n#define pi pair<LL,LL>\n#define LL long long\nusing namespace std;\nconst LL inf=2e9;\nconst LL mod=1e9+7;\nLL n,h[110];\nLL pow(LL a,LL b)\n{\n\tLL ans=1;\n\twhile(b)\n\t{\n\t\tif(b&1) ans=ans*a%mod;\n\t\ta=a*a%mod;b>>=1;\n\t}\n\treturn ans;\n}\npi solve(LL l,LL r,LL k)//l r区间大于k的部分\n{\n\tLL Min=inf,cnt=0;pi ans;\n\tfor(LL i=l;i<=r;i++)\n\t{\n\t\tif(h[i]<Min) Min=h[i],cnt=1;\n\t\telse if(h[i]==Min) cnt++;\n\t}\n\tif(cnt==(r-l+1))//矩形随便算 \n\t{\n\t\tans.fi=(pow(2,r-l+1)+mod-2)%mod;\n\t\tans.se=pow(2,Min-k-1);\n\t\treturn ans;\n\t}\n\tLL re=r-l+1,s0=1,s1=1,last=0;//s0 s1是first second \n\tfor(LL i=l;i<=r+1;i++) if(!last&&h[i]>Min) last=i;\n\telse if(last&&(h[i]<=Min||i>r))\n\t{\n\t\tre-=i-last;\n\t\tpi tmp=solve(last,i-1,Min);\n\t\ts0=s0*(tmp.fi+4*tmp.se%mod)%mod;//*4是因为上一行可以取反，当前行亦然，2*2\n\t\ts1=s1*(2*tmp.se%mod)%mod;\n\t\tlast=0;\n\t}\n\ts0=(s0+mod-s1)%mod;\n\tans.fi=s0*pow(2,re)%mod;\n\t(ans.fi+=(s1*(pow(2,re)-2+mod)%mod)%mod)%=mod; \n\tans.se=s1*pow(2,Min-k-1)%mod;\n\t//因为fi可以从两种情况转移过来，se只能从s1转移过来 \n\treturn ans;\n} \nint main()\n{\n\tscanf(\"%lld\",&n);\n\tfor(LL i=1;i<=n;i++) scanf(\"%lld\",&h[i]);\n\tif(n==1)\n\t{\n\t\tprintf(\"%lld\",pow(2,h[1]));\n\t\treturn 0;\n\t}\n\tLL tot=1;\n\tfor(LL i=1;i<=n;i++) if(h[i]>h[i-1]&&h[i]>h[i+1])\n\t{\n\t\t(tot*=pow(2,h[i]-max(h[i-1],h[i+1])))%=mod;\n\t\th[i]=max(h[i-1],h[i+1]);\n\t}\n\tpi ans=solve(1,n,0);\n\tprintf(\"%lld\",tot*((ans.fi+ans.se*2)%mod)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#define maxn 105\n#define R register\n#define INF 0x3f3f3f3f\nusing namespace std;\ntypedef long long lxl;\nconst lxl mod = 1e9+7;\n\ninline lxl read()\n{\n\tlxl x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9') {if(ch=='-') f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9') {x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\ninline lxl fmi(lxl a,lxl b)\n{\n\tlxl ans=1;\n\twhile(b>0)\n\t{\n\t\tif(b&1) ans=(ans*a)%mod;\n\t\ta=(a*a)%mod;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\n\nlxl n,h[maxn],H[maxn],W[maxn],X[maxn],Rm[maxn],tot;\nint d[maxn][20],lg[maxn];\nstd::vector<int> ch[maxn];\n\ninline void init()\n{\n\tlg[0]=-1;\n\tfor(R int i=1;i<=n;++i)\n\t\tlg[i]=lg[i>>1]+1;\n\tfor(R int i=1;i<=n;++i)\n\t\td[i][0]=h[i];\n\tfor(R int j=1;j<=15;++j)\n\t\tfor(R int i=1;i+(1<<(j-1))<=n;++i)\n\t\t\td[i][j]=min(d[i][j-1],d[i+(1<<(j-1))][j-1]);\n}\n\ninline int query(int l,int r)\n{\n\tint k=lg[r-l+1];\n\treturn min(d[l][k],d[r-(1<<k)+1][k]);\n}\n\ninline int build(int l,int r,int fa)\n{\n\tif(l>r) return 0;\n\tint p=++tot;\n\tint x=X[p]=query(l,r);\n\tH[p]=X[p]-X[fa];\n\tW[p]=r-l+1;\n\tint tl=l-1,tr=l-1;\n\tfor(R int i=l;i<=r;++i)\n\t{\n\t\tif(h[i]==x&&tl<tr)\n\t\t\tch[p].push_back(build(tl+1,tr,p));\n\t\tif(h[i]==x) tl=i,++Rm[p];\n\t\telse tr=i;\n\t}\n\tif(tl<tr) ch[p].push_back(build(tl+1,tr,p));\n\treturn p;\n}\n\nlxl f[maxn][2];\n\ninline void dp(int u)\n{\n\tlxl res1=1,res2=1;\n\tfor (std::vector<int>::iterator it = ch[u].begin(); it != ch[u].end(); ++it)\n\t{\n\t\tdp(*it);\n\t\tres1=(res1*f[*it][0])%mod;\n\t\tres2=(res2*((f[*it][0]*2%mod+f[*it][1])%mod))%mod;\n\t}\n\tf[u][0]=(fmi(2,H[u])*res1)%mod;\n\tf[u][1]=(fmi(2,Rm[u])*res2+(mod-2*res1)%mod)%mod;\n}\n\nint main()\n{\n\tn=read();\n\tfor(R int i=1;i<=n;++i)\n\t\th[i]=read();\n\tinit();\n\tint rt=build(1,n,0);\n\tdp(rt);\n\tprintf(\"%lld\",(f[rt][1]+f[rt][0])%mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nconst int MOD = (int)1e9 + 7;\n\nint n,m,h[101],hnum[101],dh[101];///h记录每一列高度 dh记录离散化后的各不相同的高度 hnum记录h对应dh中的位置，即第几高的高度\nlong long dp[101][101];///记录第i列第n块高度往上的方案数\n\nint pow_(long long x,int y) {///快速幂求 x的y次方\n    long long ans = 1;\n    if(y > 0) {\n        while(y) {\n            if(y % 2)ans = ans * x % MOD;\n            x = x * x % MOD;\n            y /= 2;\n        }\n    }\n    return ans;\n}\n\nint main() {\n    scanf(\"%d\",&n);\n    for(int i = 1;i <= n;i ++) {\n        scanf(\"%d\",&h[i]);\n        dh[++ m] = h[i];///先把高度存到dh数组 下标从1开始，方便后面dp\n    }\n    sort(dh + 1,dh + m + 1);///dh数组排序\n    m = unique(dh + 1,dh + m + 1) - dh - 1;///dh数组离散化去掉重复的高度 m是不相同的高度数\n    for(int i = 1;i <= n;i ++) {\n        hnum[i] = lower_bound(dh + 1,dh + m + 1,h[i]) - dh;///每一列高度在dh数组中对应的位置\n    }\n    dp[0][0]=1;///初始化 当第0列有1个无连续相同的方案\n    for(int i = 1;i <= n;i ++) {///对每一列每个高度段进行更新 更新过程为从下往上\n        (dp[i][0] += dp[i - 1][0] * 2 % MOD) %= MOD;///无连续相同方案  加上前i - 1列无连续相同方案数*2 因为可以是与前一列对应位置同色或者异色一共两种方案\n        for(int j = hnum[i] + 1;j <= hnum[i - 1];j ++)///如果前一列比这一列高，高出的部分也存着接触部分无连续相同的方案 但是可能会重复加上上一步的方案数所以下面更新高出的部分时会避免\n            (dp[i][0] += dp[i - 1][j] * 2 % MOD) %= MOD;\n        int d = pow_(2,h[i] - h[i - 1]);///比前一列高出部分的涂色方案数，如果比前一列低 d就等于1\n        for(int j = 1;j <= min(hnum[i - 1],hnum[i]);j ++) {\n            dp[i][j] = dp[i - 1][j] * d % MOD;///有连续相同颜色的方案数 已经分析过接触部分的颜色一定是定下的 所以这一列接触部分有连续相同部分的方案数由高出部分的变化决定 即 乘上d\n        }\n        for(int j = hnum[i - 1] + 1;j <= hnum[i];j ++) {///更新比前一列高出的部分 j从上一列的高度加1的下标开始\n            if(j > 1)(dp[i][j] = dp[i - 1][0] * (pow_(2,dh[j] - dh[j - 1]) - 1) % MOD * 2 % MOD * pow_(2,h[i] - dh[j]) % MOD) %= MOD;\n            ///一般情况 前i - 1列无连续方案 * （第j块高度变化方案 -1表示去掉无连续相同方案) * 2 * 剩下几块高度的变化方案数\n            else (dp[1][1] = dp[0][0] * (pow_(2,dh[1]) - 2) % MOD * pow_(2,h[i] - dh[1]) % MOD) %= MOD;\n            ///第一列的第一块高度 记录随意变化方案数 -2表示除去dp[i][0]已经记录过的无连续相同方案 勿重复记录\n        }\n    }\n    long long ans = 0;\n    for(int i = 0;i <= hnum[n];i++)\n        (ans += dp[n][i]) %= MOD;\n    printf(\"%lld\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define fi first\n#define se second\n\nconst int N = 105, mod = 1e9 + 7;\nint n, h[N];\n\nvoid add (int &_a, int _b) {\n    assert(_b >= 0 && _b < mod);\n    _a += _b;\n    if (_a >= mod) _a -= mod;\n}\n\nint binPow (int _a, int _n) {\n    int ret = 1;\n    for (; _n; _n >>= 1, _a = 1LL * _a * _a % mod) if (_n & 1) ret = 1LL * ret * _a % mod;\n    return ret;\n}\n\npair<int, int> solve (int l, int r) {\n    int minH = mod;\n\n    bool rect = 1;\n    for (int i = l; i + 1 <= r; ++i) if (h[i] != h[i + 1]) rect = 0;\n\n    if (rect) return { (binPow(2, r - l + 1) + binPow(2, min(h[l] - h[l - 1], h[r] - h[r + 1]) ) - 2 + mod) % mod,\n                      binPow(2, min(h[l] - h[l - 1], h[r] - h[r + 1]) ) };\n\n    for (int i = l; i <= r; ++i) minH = min(minH, h[i]);\n    vector< pair<int, int> > dp;\n    vector< pair<int, int> > range;\n    for (int i = l, lst = -1; i <= r; ++i) {\n        if (h[i] == minH) lst = -1;\n        else {\n            if (lst == -1) lst = i;\n            if (i == r || h[i + 1] == minH) dp.pb( { solve(lst, i) } );\n        }\n    }\n    for (int i = l, lst = -1; i <= r; ++i) {\n        if (h[i] > minH) lst = -1;\n        else {\n            if (lst == -1) lst = i;\n            if (i == r || h[i + 1] > minH) range.pb( { lst, i } );\n        }\n    }\n\n//    cout << \"l = \" << l << \"  r = \" << r << '\\n';\n//    for (auto _ : dp) cout << _.fi << ' '; cout << '\\n';\n\n    pair<int, int> ret = { 0, 0 };\n\n    int tmp = 1;\n    for (auto _ : dp) tmp = 1LL * tmp * ( (_.fi + _.se) % mod) % mod;\n    for (auto _ : range) tmp = 1LL * tmp * binPow(2, _.se - _.fi + 1) % mod;\n\n//    cout << \"tmp = \" << tmp << '\\n';\n\n    add(ret.fi, tmp);\n\n    tmp = 1;\n    for (auto _ : dp) tmp = 1LL * tmp * _.se % mod;\n    add(tmp, tmp);\n\n//    cout << \"tmp = \" << tmp << '\\n';\n\n    add(ret.fi, 1LL * tmp * ( (binPow(2, minH - max(h[l - 1], h[r + 1]) - 1) - 1 + mod) % mod) % mod);\n\n    add(ret.se, 1LL * tmp * binPow(2, minH - max(h[l - 1], h[r + 1]) - 1) % mod);\n\n//    cout << ret.fi << \"  \" << ret.se << '\\n';\n\n    return ret;\n}\n\nint main () {\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\n    cin >> n;\n    for (int i = 1; i <= n; ++i) cin >> h[i];\n\n    cout << solve(1, n).fi;\n\n    return 0;\n}\n/*\n3\n4 2 5\n\n320\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<map>\n#include<vector>\n#include<queue>\n#include<deque>\n#define ll long long\n#define mp make_pair\n#define rep(i,x,y) for(int i=(x);i<=(y);++i)\n#define r0p(i,n) for(int i=0;i<n;++i)\n#pragma GCC optimize(1)\n#pragma G++ optimize(1)\n#pragma GCC optimize(2)\n#pragma G++ optimize(2)\n#pragma GCC optimize(3)\n#pragma G++ optimize(3)\n#pragma GCC optimize(\"-funsafe-loop-optimizations\")\n#pragma GCC optimize(\"-funroll-loops\")\n#pragma GCC optimize(\"-fwhole-program\")\n#pragma GCC optimize(\"-fthread-jumps\")\n#pragma GCC optimize(\"-falign-functions\")\n#pragma GCC optimize(\"-falign-jumps\")\n#pragma GCC optimize(\"-falign-loops\")\n#pragma GCC optimize(\"-falign-labels\")\n#pragma GCC optimize(\"-fcaller-saves\")\n#pragma GCC optimize(\"-fcrossjumping\")\n#pragma GCC optimize(\"-fcse-follow-jumps\")\n#pragma GCC optimize(\"-fcse-skip-blocks\")\n#pragma GCC optimize(\"-fdelete-null-pointer-checks\")\n#pragma GCC optimize(\"-fexpensive-optimizations\")\n#pragma GCC optimize(\"-fgcse\")\n#pragma GCC optimize(\"-fgcse-lm\")\n#pragma GCC optimize(\"-finline-small-functions\")\n#pragma GCC optimize(\"-findirect-inlining\")\n#pragma GCC optimize(\"-foptimize-sibling-calls\")\n#pragma GCC optimize(\"-fpeephole2\")\n#pragma GCC optimize(\"-freorder-blocks\")\n#pragma GCC optimize(\"-freorder-functions\")\n#pragma GCC optimize(\"-frerun-cse-after-loop\")\n#pragma GCC optimize(\"-fsched-interblock\")\n#pragma GCC optimize(\"-fsched-spec\")\n#pragma GCC optimize(\"-fschedule-insns\")\n#pragma GCC optimize(\"-fschedule-insns2\")\n#pragma GCC optimize(\"-fstrict-aliasing\")\n#pragma GCC optimize(\"-fstrict-overflow\")\n#pragma GCC optimize(\"-ftree-switch-conversion\")\n#pragma GCC optimize(\"-ftree-pre\")\n#pragma GCC optimize(\"-ftree-vrp\")\n#define pii pair<int,int>\n#pragma GCC diagnostic error \"-std=c++11\"\nusing namespace std;\ninline void rdl(long long &val){\n    long long x=0;\n    int f=1;\n    char ch=getchar();\n    while((ch<'0' or ch>'9') and ch!='-') ch=getchar();\n    if(ch=='-'){\n        f=-1;\n        ch=getchar();\n\t}\n\twhile(ch>='0' and ch<='9'){\n\t    x=(x<<3)+(x<<1)+ch-'0';\n\t\tch=getchar();\n\t}\n    val=x*f;\n}\ninline void rdi(int &val){\n    int x=0;\n    int f=1;\n    char ch=getchar();\n    while((ch<'0' or ch>'9') and ch!='-') ch=getchar();\n    if(ch=='-'){\n        f=-1;\n        ch=getchar();\n    }\n    while(ch>='0' and ch<='9'){\n        x=(x<<3)+(x<<1)+ch-'0';\n        ch=getchar();\n    }\n    val=x*f;\n}\ninline long long rdl(){\n    long long x=0;\n    int f=1;\n    char ch=getchar();\n    while((ch<'0' or ch>'9') and ch!='-') ch=getchar();\n    if(ch=='-'){\n        f=-1;\n        ch=getchar();\n    }\n    while(ch>='0' and ch<='9'){\n        x=(x<<3)+(x<<1)+ch-'0';\n        ch=getchar();\n    }\n    return x*f;\n}\ninline int rdi(){\n    int x=0;\n    int f=1;\n\tchar ch=getchar();\n\twhile((ch<'0' or ch>'9') and ch!='-') ch=getchar();\n\tif(ch=='-'){\n        f=-1;\n        ch=getchar();\n    }\n    while(ch>='0' and ch<='9'){\n        x=(x<<3)+(x<<1)+ch-'0';\n        ch=getchar();\n    }\n    return x*f;\n}\ninline void write(int x){\n    if(x<0) putchar('-'),x=-x;\n    if(x>9) write(x/10);\n    putchar(x%10+'0');\n}\ninline void _write(int x){\n\twrite(x);\n\tputchar(' ');\n}\ninline void print(int x){\n\twrite(x);\n\tputchar('\\n');\n}\ninline void write(ll x){\n    if(x<0) putchar('-'),x=-x;\n    if(x>9) write(x/10);\n    putchar(x%10+'0');\n}\ninline void _write(ll x){\n\twrite(x);\n\tputchar(' ');\n}\ninline void print(ll x){\n\twrite(x);\n\tputchar('\\n');\n}\nconst int md=1000000007;\ninline int qp(int a,ll b){\n\tint rt=1;\n\twhile(b){\n\t\tif(b&1) rt=(rt*a)%md;\n\t\ta=(a*a)%md;\n\t\tb>>=1; \n\t}\n\treturn rt;\n}\nint w[111],n,dp[111];\nint main(){\n\tint i,j,k;\n\trdi(n);\n\tfor(i=1;i<=n;++i) rdi(w[i]);\n\tdp[0]=1;\n\tw[n+1]=1;\n\tfor(i=1;i<n+2;++i){\n\t\tdp[i]=dp[i-1]*2%md;\n\t\tfor(j=1;j<i;++j){\n\t\t\tint t=max(w[i],w[j-1]),mn=w[j]-1;\n\t\t\tll sum=0;\n\t\t\tfor(k=j;k<i;++k) mn=min(mn,w[k]-1),sum+=max(w[k+1]-w[k],0);\n\t\t\tif(t<=mn){\n\t\t\t\tint t1=qp(2,w[j]-1-mn);\n\t\t\t\tint t2=qp(2,mn-t+1)-1;\n\t\t\t\tint t3=qp(2,sum);\n\t\t\t\tdp[i]=(dp[i]+4ll*dp[j-1]*t1%md*t2%md*t3)%md;\n\t\t\t}\n\t\t}\n\t}\n\tprint(dp[n+1]*500000004ll%md);\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author majk\n */\n\n#ifndef MAJK_LIB\n#define MAJK_LIB\n\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <fstream>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <algorithm>\n#include <numeric>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <array>\n#include <bitset>\nusing namespace std;\n\n#define x first\n#define y second\ntypedef std::pair<int,int> pii; typedef long long ll; typedef unsigned long long ull; typedef unsigned int ui; typedef pair<ui,ui> puu;\n\ntemplate <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate <typename T, typename U> std::ostream&operator<<(std::ostream&o, const pair<T,U>&p) {o << p.x << ' ' << p.y; return o;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {if(t.empty())o<<'\\n';for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\nui logceil(ll x) { return x?8*sizeof(ll)-__builtin_clzll(x):0; }\n\nnamespace std { template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}}; }\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename F> double bshd(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){l=m;}else{h=m;}}return (l+h)/2;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename F> double bsld(double l,double h,const F&f){ui r=200;while(r--){double m=(l+h)/2;if(f(m)){h=m;}else{l=m;}}return (l+h)/2;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector2<T>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector2<T>>(a,vector2<T>(b,c,t)){}};\ntemplate<typename T>class vector4:public vector<vector3<T>>{public:vector4(){} vector4(size_t a,size_t b,size_t c,size_t d,T t=T()):vector<vector3<T>>(a,vector3<T>(b,c,d,t)){}};\ntemplate<typename T>class vector5:public vector<vector4<T>>{public:vector5(){} vector5(size_t a,size_t b,size_t c,size_t d,size_t e,T t=T()):vector<vector4<T>>(a,vector4<T>(b,c,d,e,t)){}};\n\n\n#endif\n#ifndef MOD_H\n#define MOD_H\n\n\n\ntemplate <unsigned int N> class Field {\n    typedef unsigned int ui;\n    typedef unsigned long long ull;\n\tinline ui pow(ui a, ui p){ui r=1,e=a;while(p){if(p&1){r=((ull)r*e)%N;}e=((ull)e*e)%N;p>>=1;}return r;}\n\t/*extended GCD(slow):ll t=0,nt=1,r=N,nr=a;while(nr){ll q=r/nr;t-=q*nt;swap(t,nt);r-=q*nr;swap(r,nr);}assert(r<=1);return(t<0)?t+N:t;*/\n\tinline ui inv(ui a){return pow(a,N-2);}\npublic:\n    inline Field(int x = 0) : v(x<0?N+x:x) {}\n\tinline Field<N> pow(int p){return (*this)^p; }\n\tinline Field<N> operator^(int p){return {(int)pow(v,(ui)p)};}\n    inline Field<N>&operator+=(const Field<N>&o) {if (v+o.v >= N) v += o.v - N; else v += o.v; return *this; }\n    inline Field<N>&operator-=(const Field<N>&o) {if (v<o.v) v -= o.v-N; else v-=o.v; return *this; }\n    inline Field<N>&operator*=(const Field<N>&o) {v=(ull)v*o.v % N; return *this; }\n    inline Field<N>&operator/=(const Field<N>&o) { return *this*=inv(o.v); }\n    inline Field<N> operator+(const Field<N>&o) const {Field<N>r{*this};return r+=o;}\n    inline Field<N> operator-(const Field<N>&o) const {Field<N>r{*this};return r-=o;}\n    inline Field<N> operator*(const Field<N>&o) const {Field<N>r{*this};return r*=o;}\n    inline Field<N> operator/(const Field<N>&o) const {Field<N>r{*this};return r/=o;}\n    inline Field<N> operator-() {if(v) return {(int)(N-v)}; else return {0};};\n    inline Field<N>& operator++() { ++v; if (v==N) v=0; return *this; }\n    inline Field<N> operator++(int) { Field<N>r{*this}; ++*this; return r; }\n    inline Field<N>& operator--() { --v; if (v==-1) v=N-1; return *this; }\n    inline Field<N> operator--(int) { Field<N>r{*this}; --*this; return r; }\n    inline bool operator==(const Field<N>&o) const { return o.v==v; }\n\tinline bool operator!=(const Field<N>&o) const { return o.v!=v; }\n\tinline explicit operator ui() const { return v; }\n\tinline static vector<Field<N>>fact(int t){vector<Field<N>>F(t+1,1);for(int i=2;i<=t;++i){F[i]=F[i-1]*i;}return F;}\n\tinline static vector<Field<N>>invfact(int t){vector<Field<N>>F(t+1,1);Field<N> X{1};for(int i=2;i<=t;++i){X=X*i;}F[t]=1/X;for(int i=t-1;i>=2;--i){F[i]=F[i+1]*(i+1);}return F;}\nprivate: ui v;\n};\ntemplate<unsigned int N>istream &operator>>(std::istream&is,Field<N>&f){unsigned int v;is>>v;f=v;return is;}\ntemplate<unsigned int N>ostream &operator<<(std::ostream&os,const Field<N>&f){return os<<(unsigned int)f;}\ntemplate<unsigned int N>Field<N> operator+(int i,const Field<N>&f){return Field<N>(i)+f;}\ntemplate<unsigned int N>Field<N> operator-(int i,const Field<N>&f){return Field<N>(i)-f;}\ntemplate<unsigned int N>Field<N> operator*(int i,const Field<N>&f){return Field<N>(i)*f;}\ntemplate<unsigned int N>Field<N> operator/(int i,const Field<N>&f){return Field<N>(i)/f;}\n\n\ntypedef Field<1000000007> FieldMod;\n\nstruct Ring {\n\ttemplate <typename T>\n\tstatic T div(T p, T q, T N) {\n\t\tT t=0,nt=1,r=N,nr=q;\n\t\twhile(nr!=0){ T q=r/nr;t-=q*nt;r-=q*nr;swap(t,nt);swap(r,nr); }\n\t\tt=(t<0)?t+N:t;\n\t\tr=(r<0)?r+N:r;\n\t\tif (gcd(p,N)%r!=0) { return 0; }\n\t\treturn (t*p/r)%N;\n\t}\n};\n#endif\n\n\nclass DHistogramColoring {\npublic:\n    void solve(istream& cin, ostream& cout) {\n        int N; cin >> N;\n        vector<int> A(N); cin >> A;\n        vector<FieldMod> D(N+1, 0);\n        D[0] = 1;\n        for (int i = 0; i <= N; ++i) {\n            int lo = A[i];\n            for (int j = i+1; j <= N; ++j) {\n                ll choices = A[i];\n\n                if (j != N) lo = min(lo, A[j]);\n                for (int k = i+1; k < j; ++k) {\n                    choices += max(0, A[k] - A[k-1]);\n//                    lo = min(lo, A[k]);\n                }\n\n                if (i != 0) choices -= min(A[i-1], A[i]);\n                if (j != N) {\n                    choices -= min(A[j-1], A[j]);\n                    if (i != 0) choices += min(lo, min(A[i-1],A[j]));\n                    else choices++;\n                }\n\n                D[j] += D[i] * FieldMod{2}.pow(choices % 1000000006);\n\n            }\n        }\n        cout << D[N] << '\\n';\n    }\n};\n\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tDHistogramColoring solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 105;\nconst int P = 1e9 + 7;\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\ntemplate <typename T> void write(T x) {\n\tif (x < 0) x = -x, putchar('-');\n\tif (x > 9) write(x / 10);\n\tputchar(x % 10 + '0');\n}\ntemplate <typename T> void writeln(T x) {\n\twrite(x);\n\tputs(\"\");\n}\nint power(int x, ll y) {\n\tif (y == 0) return 1;\n\tint tmp = power(x, y / 2);\n\tif (y % 2 == 0) return 1ll * tmp * tmp % P;\n\telse return 1ll * tmp * tmp % P * x % P;\n}\nvoid update(int &x, int y) {\n\tx += y;\n\tif (x >= P) x -= P;\n}\nll cnt; int dp[MAXN];\nint n, ans, a[MAXN], b[MAXN];\nint main() {\n\tread(n), ans = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tread(a[i]);\n\t\tif (a[i] == 1) {\n\t\t\tcnt += 1;\n\t\t\ta[i] = 0;\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tint Max = max(a[i - 1], a[i + 1]);\n\t\tif (a[i] > Max) {\n\t\t\tcnt += a[i] - Max;\n\t\t\ta[i] = Max;\n\t\t}\n\t}\n\tans = power(2, cnt);\n\tfor (int i = 1; i <= n - 1; i++) {\n\t\tb[i] = min(a[i], a[i + 1]);\n\t\tif (b[i]) b[i]--;\n\t}\n\tdp[0] = 1;\n\tfor (int i = 0; i <= n - 1; i++) {\n\t\tfor (int j = i + 1; j <= n; j++) {\n\t\t\tstatic int c[MAXN];\n\t\t\tmemset(c, 0, sizeof(c));\n\t\t\tfor (int k = i + 1, Min = min(b[k], b[i]); k <= j - 1; k++, chkmin(Min, b[k]))\n\t\t\t\tchkmax(c[k], Min);\n\t\t\tfor (int k = j - 1, Min = min(b[k], b[j]); k >= i + 1; k--, chkmin(Min, b[k]))\n\t\t\t\tchkmax(c[k], Min);\n\t\t\tll cnt = 0;\n\t\t\tfor (int k = i + 1; k <= j - 1; k++) {\n\t\t\t\tc[k] = b[k] - c[k];\n\t\t\t\tif (c[k] - c[k - 1] > 0) cnt += c[k] - c[k - 1];\n\t\t\t}\n\t\t\tif (b[i] == 0 && (b[j] != 0 || i != j - 1)) cnt++;\n\t\t\tupdate(dp[j], 1ll * dp[i] * power(2, cnt) % P);\n\t\t\tif (b[j] == 0) break;\n\t\t}\n\t}\n\twriteln(1ll * ans * dp[n] % P);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll MOD = 1e9+7;\n\nint n;\nll h[110];\n\nll power(ll a, ll n) {\n    if (n<0) return 0;\n    if (!n) return 1;\n    ll t = power(a,n/2);\n    return t*t%MOD*((n&1)?a:1)%MOD;\n}\n\nll D[110][110];\nll ch[110];\nvector<ll> comp;\nint main() {\n    int i, j;\n\n    scanf(\"%d\",&n);\n    for (i=0;i<n;i++) scanf(\"%lld\",&h[i]);\n    for (i=0;i<n;i++) comp.push_back(h[i]);\n    comp.push_back(0);\n    sort(comp.begin(),comp.end());\n    comp.erase(unique(comp.begin(),comp.end()),comp.end());\n    for (i=0;i<n;i++) ch[i] = lower_bound(comp.begin(),comp.end(),h[i])-comp.begin();\n    for (j=0;j<comp.size();j++) {\n        if (j==0) D[0][j] = power(2,h[0]);\n        else if (j<=ch[0]) D[0][j] = power(2,h[0]-comp[j]+1);\n        else D[0][j] = 0;\n    }\n    for (i=1;i<n;i++) {\n        ll p = min(ch[i-1],ch[i]);\n        for (j=0;j<comp.size();j++) {\n            if (j<=p) D[i][j] = (D[i-1][j]+D[i-1][p])*power(2,h[i]-comp[p])%MOD;\n            else D[i][j] = D[i-1][p]*2*power(2,h[i]-comp[j])%MOD;\n        }\n    }\n    printf(\"%lld\\n\",D[n-1][0]);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\ntemplate<typename S, typename T>\nvoid xmin(S&a, T const&b){if(b<a) a=b;}\ntemplate<typename S, typename T>\nvoid xmax(S&a, T const&b){if(b>a) a=b;}\n\ntemplate<ll mod>\nstruct NT{\n    static int add(int const&a, int const&b){\n        ll ret = a+b;\n        if(ret>=mod) ret-=mod;\n        return ret;\n    }\n    static int& xadd(int& a, int const&b){\n        a+=b;\n        if(a>=mod) a-=mod;\n        return a;\n    }\n    static int sub(int const&a, int const&b){\n        return add(a, mod-b);\n    }\n    static int& xsub(int& a, int const&b){\n        return xadd(a, mod-b);\n    }\n    static int mul(int const&a, int const&b){\n        return a*(ll)b%mod;\n    }\n    static int& xmul(int &a, int const&b){\n        return a=mul(a, b);\n    }\n    static int inv_rec(int const&a, int const&m){\n        assert(a!=0);\n        if(a==1) return 1;\n        int ret = m+(1-inv_rec(m%a, a)*(ll)m)/a;\n        return ret;\n    }\n\t// this is soooo great, can even be used for a sieve\n    static int inv_rec_2(int const&a, int const&m){\n        assert(a!=0);\n        if(a==1) return 1;\n        int ret = m-NT<mod>::mul((m/a), inv_rec_2(m%a, m));\n        return ret;\n    }\n    static int inv(int const&a){\n        return inv_rec_2(a, mod);\n    }\n};\nconstexpr int mod = 1e9+7;\nusing nt = NT<mod>;\nconst int tt = nt::inv(2);\n\nint ipow(int a, int exp){\n    int ret = 1;\n    for(;exp;exp>>=1){\n        if(exp&1){\n            nt::xmul(ret, a);\n        }\n        nt::xmul(a, a);\n    }\n    return ret;\n}\n\nstruct Inter{\n    int l, r;\n    int dp, alt;\n    bool operator<(Inter const&o)const{\n        return make_pair(l, r) < make_pair(o.l, o.r);\n    }\n};\n\nsigned main()\n{\n    #ifdef LOCAL_RUN\n    freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n    cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(false);\n    int TTT; cin >> TTT; while(TTT--){\n    #else\n    cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(false);\n    #endif // LOCAL_RUN\n\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for(auto &e:a){\n        cin >> e;\n    }\n    vector<Inter> inters;\n\n    int old_h = 1e9;\n    auto down = [&](int h){\n        assert(old_h >= h);\n        if(old_h > h){\n            int dh = old_h - h;\n            int fact = ipow(2, dh);\n            for(auto &e:inters){\n                nt::xmul(e.alt, fact);\n            }\n        }\n        old_h = h;\n    };\n\n    for(int it=0;it<n;++it){\n        int j = max_element(a.begin(), a.end()) - a.begin();\n        int h = a[j];\n        down(h);\n        a[j] = -1;\n        inters.emplace_back(Inter{j, j, 0, 2});\n\n        for(int _:{0, 1}){ (void)_;\n            sort(inters.begin(), inters.end());\n            for(int i=1;i<(int)inters.size();++i){\n                if(inters[i-1].r+1 == inters[i].l){\n                    //merge\n                    Inter const a = inters[i-1], b = inters[i];\n                    Inter res{a.l, b.r, 0, 0};\n\n                    nt::xadd(res.dp, nt::mul(a.dp, b.dp));\n                    nt::xadd(res.dp, nt::mul(a.dp, b.alt));\n                    nt::xadd(res.dp, nt::mul(a.alt, b.dp));\n                    nt::xadd(res.dp, nt::mul(nt::mul(a.alt, b.alt), tt));\n                    nt::xadd(res.alt, nt::mul(nt::mul(a.alt, b.alt), tt));\n\n                    inters[i-1] = res;\n                    inters.erase(inters.begin()+i);\n                    --i;\n                }\n            }\n        }\n    }\n    down(1);\n\n    assert(inters.size() == 1);\n    int ans = nt::add(inters[0].dp, inters[0].alt);\n    cout << ans << \"\\n\";\n\n\n\n\n    #ifdef LOCAL_RUN\n    }\n    #endif // LOCAL_RUN\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <functional>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cstdlib>\n\nusing namespace std;\ntypedef long long llong;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<llong, llong> pll;\n\nint n, k;\nint hs[105];\nint cp[105];\nint dp[105][105];\n\nconst int mod = 1e9 + 7;\n\nvoid add(int &x, llong y) {\n    x += y % mod;\n    x %= mod;\n}\n\nint mul(int x, int y) {\n    return (llong)x * y % mod;\n}\n\nint pw(int x, int p) {\n    if (p == 0) return 1;\n    int ret = pw(x, p >> 1);\n    ret = mul(ret, ret);\n    if (p & 1) ret = mul(ret, x);\n    return ret;\n}\n\nint solve(int s, int e) {\n    dp[s - 1][0] = 1;\n    for (int i = s; i <= e; ++i) {\n        if (hs[i - 1] < hs[i]) {\n            dp[i][0] = dp[i - 1][0];\n            add(dp[i][0], dp[i][0]);\n            \n            for (int j = 1; j <= hs[i - 1]; ++j) {\n                dp[i][j] = mul(dp[i - 1][j], pw(2, cp[hs[i]] - cp[hs[i - 1]]));\n            }\n            for (int j = hs[i - 1] + 1; j <= hs[i]; ++j) {\n                dp[i][j] = mul(dp[i - 1][0], mul((pw(2, cp[j] - cp[j - 1]) + mod - 1 - (j == 1 ? pw(2, cp[j] - 1) : 0)) % mod, pw(2, cp[hs[i]] - cp[j] + 1)));\n            }\n        }\n        else {\n            dp[i][0] = dp[i - 1][0];\n            for (int j = hs[i] + 1; j < k; ++j) {\n                add(dp[i][0], dp[i - 1][j]);\n            }\n            add(dp[i][0], dp[i][0]);\n            for (int j = 1; j <= hs[i]; ++j) {\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n    int ret = 0;\n    for (int i = 0; i < k; ++i) {\n        add(ret, dp[e][i]);\n    }\n    return ret;\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    vector<int> one;\n    one.push_back(0);\n    for (int i = 1; i <= n; ++i) {\n        scanf(\"%d\", hs + i);\n        if (hs[i] == 1) hs[i] = 0, one.push_back(i);\n        cp[i] = hs[i];\n    }\n    one.push_back(n + 1);\n    sort(cp, cp + (n + 1));\n    k = unique(cp, cp + (n + 1)) - cp;\n    for (int i = 1; i <= n; ++i) {\n        hs[i] = lower_bound(cp, cp + k, hs[i]) - cp;\n    }\n    int ret = pw(2, one.size() - 2);\n    for (int i = 1; i < one.size(); ++i) {\n        ret = mul(ret, solve(one[i - 1] + 1, one[i] - 1));\n    }\n    printf(\"%d\\n\", ret);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\n\nconst ll mod = 1e9 + 7;\n\nll A[111];\nll n;\n\nll lpow(ll a, ll b)\n{\n\tif(b == 0) return 1;\n\tll rt = lpow(a, b>>1);\n\trt = rt * rt % mod;\n\tif(b & 1) rt = rt * a % mod;\n\treturn rt;\n}\n\npll run(ll l, ll r, ll h)\n{\t\n\tif(l == r){\n\t\treturn pll(lpow(2, A[l] - h), lpow(2, A[l] - h - 1));\n\t}\n\t\n\tll i, a, b, s, m, f;\n\tpll p;\n\t\n\ta = b = f = 1;\n\tm = 1e9;\n\t\n\tfor(i=l;i<=r;i++){\n\t\tm = min(m, A[i]);\n\t}\n\t\n\tfor(i=s=l;i<=r;i++){\n\t\tif(A[i] == m){\n\t\t\tif(s <= i-1){\n\t\t\t\tp = run(s, i-1, m);\n\t\t\t\ta = a * (p.first + p.second * 2) % mod;\n\t\t\t\tb = b * p.second % mod;\n\t\t\t}\n\t\t\ta = a * 2 % mod;\n\t\t\ts = i + 1;\n\t\t}\n\t\telse f = 2;\n\t}\n\tif(s <= r){\n\t\tp = run(s, r, m);\n\t\ta = a * (p.first + p.second * 2) % mod;\n\t\tb = b * p.second % mod;\n\t}\n\tb = b * f % mod;\n\t\n//\tprintf(\"%lld - %lld : %lld %lld\\n\", l, r, a, b);\n\t\n\ta = (a - b * 2 + b * lpow(2, m - h) + mod + mod) % mod;\n\tb = b * lpow(2, m - h - 1) % mod;\n\t\n//\tprintf(\"%lld - %lld : %lld %lld\\n\", l, r, a, b);\n\t\n\treturn pll(a, b);\n}\n\nint main()\n{\n\tll i;\n\tpll p;\n\t\n\tscanf(\"%lld\", &n);\n\t\n\tfor(i=1;i<=n;i++){\n\t\tscanf(\"%lld\", A+i);\n\t}\n\t\n\tp = run(1, n, 0);\n\t\n\tprintf(\"%lld\\n\", p.first);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nD棰橈細\n缁欏畾n鍒楃殑鏂瑰潡\n绗琲鍒楅珮搴i\n鐜板湪瑕佹妸瀹冩煋鎴愮孩钃濅袱鑹?\n瑕佹眰婊¤冻锛?\n瀵逛簬浠绘剰涓€涓?*2鐨勫尯鍩燂紝鎭版湁2涓摑鑹诧紝2涓孩鑹?\n闂柟妗堟暟\nn<=100,h<=10^9\n*/\n#include<bits/stdc++.h>\n#define rep(i,a,b) for (int i=(a); i<=(b); i++)\n#define per(i,a,b) for (int i=(a); i>=(b); i--)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> pii;\n\nconst int maxn = 105;\nconst int MOD = 1000000007;\nint bin[maxn], h[maxn], f[maxn][3];\nint n, mx, res, base = 1;\n\ninline int power(int x, int p) {\n\tint res = 1;\n\twhile (p) {\n\t\tif (p & 1) res = 1LL * res * x % MOD;\n\t\tx = 1LL * x * x % MOD; p >>= 1;\n\t}\n\treturn res;\n}\n\npii solve(int l, int r, int base) {\n\t// printf(\"%d %d %d\\n\", l, r, base);\n\tint mn = MOD, cnt = 0;\n\tpii res = make_pair(0, 0), sub;\n\trep (i, l, r)\n\t\tif (h[i] < mn) mn = h[i], cnt = 1;\n\t\telse if (h[i] == mn) cnt++;\n\tif (cnt == r - l + 1) {\n\t\tres.first = (power(2, r - l + 1) + MOD - 2) % MOD;\n\t\tres.second = power(2, mn - base - 1);\n\t\t//printf(\"%d %d %d  %d %d\\n\", l, r, base, res.fi, res.se);\n\t\treturn res;\n\t}\n\tint remain = r - l + 1, last = 0, tmp = 1;\n\tint res0 = 1, res1 = 1;\n\trep (i, l, r + 1)\n\t\tif (!last && h[i] > mn) last = i;\n\t\telse if (last && (i > r || h[i] == mn)) {\n\t\t\tremain -= i - last;\n\t\t\tsub = solve(last, i - 1, mn);\n\t\t\tres0 = 1LL * res0 * (sub.fi + 4LL * sub.se) % MOD;\n\t\t\tres1 = 2LL * res1 * sub.se % MOD;\n\t\t\tlast = 0;\n\t\t}\n\tres0 = (res0 + MOD - res1) % MOD;\n\tres.fi = 1LL * res0 * power(2, remain) % MOD;\n\tres.fi = (res.fi + 1LL * res1 * (power(2, remain) + MOD - 2)) % MOD;\n\tres.se = 1LL * res1 * power(2, mn - base - 1) % MOD;\n\t//printf(\"%d %d %d  %d %d\\n\", l, r, base, res.fi, res.se);\n\treturn res;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\trep (i, 1, n) scanf(\"%d\", &h[i]);\n\tif (n == 1) {\n\t\tprintf(\"%d\\n\", power(2, h[1]));\n\t\treturn 0;\n\t}\n\trep (i, 1, n)\n\t\tif (h[i] > h[i-1] && h[i] > h[i+1]) {\n\t\t\tbase = 1LL * base * power(2, h[i] - max(h[i-1], h[i+1])) % MOD;\n\t\t\th[i] = max(h[i-1], h[i+1]);\n\t\t}\n\tpii tmp = solve(1, n, 0);\n\tres = 1LL * base * (tmp.fi + 2LL * tmp.se) % MOD;\n\tprintf(\"%d\\n\", res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mod 1000000007\nusing namespace std;\nint n,dp[105][105],ans;\nint h[105],H[105],hi[105],cnt,r[105];\n\nint ksm(int x,int y){\n\tint res=1;\n\twhile(y){\n\t\tif(y&1) res=1ll*res*x%mod;\n\t\tx=1ll*x*x%mod,y/=2;\n\t}\n\treturn res;\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&h[i]),hi[i]=h[i];\n\tsort(hi+1,hi+n+1);\n\tfor(int i=1;i<=n;i++) if(hi[i]!=hi[i-1]) H[++cnt]=hi[i];\n\tfor(int i=1;i<=n;i++) r[i]=lower_bound(H+1,H+cnt+1,h[i])-H;\n\tfor(int j=0;j<r[1];j++){\n\t\tint i=1;\n\t\tif(j) dp[i][j]=2ll*(ksm(2,H[j+1]-H[j])-1)*ksm(2,h[1]-H[j+1])%mod;\n\t\telse dp[i][j]=1ll*(ksm(2,H[j+1]-H[j])-2)*ksm(2,h[1]-H[j+1])%mod;\n\t}\n\tdp[1][r[1]]=2;\n\tfor(int i=2;i<=n;i++){\n\t\tif(h[i]<=h[i-1]){\n\t\t\tfor(int j=0;j<r[i];j++) dp[i][j]=dp[i-1][j];\n\t\t\tfor(int j=r[i];j<=r[i-1];j++) (dp[i][r[i]]+=2ll*dp[i-1][j]%mod)%=mod;\n\t\t}\n\t\telse{\n\t\t\tfor(int j=0;j<r[i-1];j++) dp[i][j]=1ll*dp[i-1][j]*ksm(2,h[i]-h[i-1])%mod;\n\t\t\tint S=2ll*dp[i-1][r[i-1]]%mod;\n\t\t\tfor(int j=r[i-1];j<r[i];j++) dp[i][j]=1ll*S*(ksm(2,H[j+1]-H[j])-1)%mod*ksm(2,h[i]-H[j+1])%mod;\n\t\t\tdp[i][r[i]]=S;\n\t\t}\n\t}\n\tfor(int i=0;i<=r[n];i++) (ans+=dp[n][i])%=mod;\n\tprintf(\"%d\\n\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O2\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"avx,avx2,sse,sse2,ssse3,popcnt,sse4.1,sse4.2,tune=native\")\n#include<bits/stdc++.h>\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define pb push_back\nusing namespace std;\nusing ll = long long;\n//using arr = array;\nusing pi = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vpi = vector<pi>;\nusing ld = double;\nconst int maxn = 105, mod = 1e9 + 7;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint n, a[maxn], gp[maxn][maxn][maxn], fp[maxn][maxn][maxn];\n\n//g - flipping pattern\n//f - everything else\n\nint g(int l, int r, int w) {\n\tif(gp[l][r][w] != -1) return gp[l][r][w];\n\tint ans = 1, len = 0;\n\tfor(int i = l; i <= r; i++) {\n\t\tif(a[i] == w) {\n\t\t\tif(len) ans = ans * 1ll * g(i - len, i - 1, w + 1) % mod;\n\t\t\tlen = 0;\n\t\t} else ++len;\n\t}\n\tif(len) ans = ans * 1ll * g(r + 1 - len, r, w + 1) % mod;\n\tgp[l][r][w] = ans * 2ll % mod;\n\treturn gp[l][r][w];\n}\n\nint f(int l, int r, int w) {\n\tif(fp[l][r][w] != -1) return fp[l][r][w];\n\tint ans = 1, len = 0;\n\tfor(int i = l; i <= r; i++) {\n\t\tif(a[i] == w) {\n\t\t\tif(len) ans = ans * 1ll * (2ll * g(i - len, i - 1, w + 1) + f(i - len, i - 1, w + 1)) % mod;\n\t\t\tans = ans * 2ll % mod;\n\t\t\tlen = 0;\n\t\t} else ++len;\n\t}\n\tif(len) ans = ans * 1ll * (2ll * g(r + 1 - len, r, w + 1) + f(r + 1 - len, r, w + 1)) % mod;\n\tfp[l][r][w] = (mod + ans - g(l, r, w)) % mod;\n\treturn fp[l][r][w];\n}\n\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tmemset(gp, -1, sizeof gp);\n\tmemset(fp, -1, sizeof fp);\n\tcin >> n;\n\tfor(int i = 0; i < n; i++) cin >> a[i];\n\tcout << (g(0, n-1, 1)+f(0, n-1, 1))%mod;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\ntemplate<typename tn> void read(tn &a){\n\ttn x=0,f=1; char c=' ';\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0';\n\ta=x*f;\n}\nconst int mod = 1e9+7;\nint n,h[110],cnt,b[110];\nll f[110][110];\nll fp(ll a,ll k){\n\tll ans=1;\n\tfor(;k;k>>=1,a=a*a%mod)\n\t\tif(k&1) ans=a*ans%mod;\n\treturn ans;\n}\nint main(){\n\tread(n);\n\tfor(int i=1;i<=n;i++)\n\t\tread(h[i]),b[++cnt]=h[i];\n\tsort(b+1,b+cnt+1);\n\tcnt=unique(b+1,b+cnt+1)-b-1;\n\tfor(int i=1;i<=n;i++)\n\t\th[i]=lower_bound(b+1,b+cnt+1,h[i])-b;\n\tf[0][0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tf[i][0]=f[i-1][0]*2%mod;\n\t\tfor(int j=h[i]+1;j<=h[i-1];j++) (f[i][0]=f[i][0]+f[i-1][j]*2)%mod;\n\t\tfor(int j=1;j<=h[i];j++)\n\t\t\tif(h[i]>=h[i-1]) f[i][j]=f[i-1][j]*fp(2,b[h[i]]-b[h[i-1]])%mod;\n\t\t\telse f[i][j]=f[i-1][j];\n\t\tfor(int j=h[i-1]+1;j<=h[i];j++)\n\t\t\tif(j>1) f[i][j]=f[i-1][0]*(fp(2,b[j]-b[j-1]+1)-2)%mod*fp(2,b[h[i]]-b[j])%mod;\n\t\t\telse f[i][j]=f[i-1][0]*(fp(2,b[j])-2)%mod*fp(2,b[h[i]]-b[j])%mod;\n\t}\n\tll ans=0;\n\tfor(int i=0;i<=h[n];i++)\n\t\tans=(ans+f[n][i])%mod;\n\tcout<<(ans+mod)%mod<<'\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n\nusing namespace std;\n\nconst int maxn = 110;\nconst int base = 1e9+7;\n\nint n,a[maxn];\nll f[maxn][maxn];\nmap<int,int> cnt;\nvector<int> h;\n\nll pw(int a,int n) {\n    if (n==0) return 1ll;\n    if (n==1) return a;\n    ll tmp = pw(a,n/2);\n    tmp = (tmp*tmp)%base;\n    if (n%2==0) return tmp;\n    return (tmp*a)%base;\n}\n\nint main() {\n  //  freopen(\"in.txt\",\"r\",stdin);\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin>>n;\n    for (int i=1;i<=n;i++) {\n        cin>>a[i];\n        if (cnt[a[i]]!=0) continue;\n        h.push_back(a[i]);\n        cnt[a[i]]=1;\n    }\n    cnt.clear();\n    h.push_back(0);\n    sort(h.begin(),h.end());\n    h.erase(unique(h.begin(),h.end()),h.end());\n    for (int j=0;j<h.size();j++) cnt[h[j]]=j;\n    for (int j=0;j<h.size();j++)\n        if (h[j] == 0) f[1][j] = pw(2,a[1]);\n        else if (h[j] <= a[1]) f[1][j] = pw(2,a[1] - h[j]+1);\n    for (int i=2;i<=n;i++) {\n        if (a[i] < a[i-1]) {\n            int mi = cnt[a[i]];\n            for (int j=0;j<h.size();j++)\n                if (h[j] <= a[i])\n                    f[i][j] = (f[i-1][j] + f[i-1][mi])%base;\n        } else {\n            int mi = cnt[a[i-1]];\n            for (int j=0;j<h.size();j++) {\n                if (h[j] <= a[i-1]) f[i][j] = ((f[i-1][j] + f[i-1][mi])%base * pw(2,a[i] - a[i-1])) % base;\n                else if (h[j] <= a[i]) f[i][j] = (pw(2,a[i] - h[j]+1) * f[i-1][mi]) % base;\n            }\n        }\n    }\n    cout<<f[n][0]<<endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nЗАПУСКАЕМ \n░ГУСЯ░▄▀▀▀▄░РАБОТЯГУ░░\n▄███▀░◐░░░▌░░░░░░░\n░░░░▌░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▌░░░░░▐▄▄░░░░░\n░░░░▌░░░░▄▀▒▒▀▀▀▀▄\n░░░▐░░░░▐▒▒▒▒▒▒▒▒▀▀▄\n░░░▐░░░░▐▄▒▒▒▒▒▒▒▒▒▒▀▄\n░░░░▀▄░░░░▀▄▒▒▒▒▒▒▒▒▒▒▀▄\n░░░░░░▀▄▄▄▄▄█▄▄▄▄▄▄▄▄▄▄▄▀▄\n░░░░░░░░░░░▌▌░▌▌░░░░░\n░░░░░░░░░░░▌▌░▌▌░░░░░\n░░░░░░░░░▄▄▌▌▄▌▌░░░░░ \n */\n#include <iostream>\n#include <complex>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <cmath>\n#include <bitset>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <deque>\n    \n     \nusing namespace std;\ntemplate<typename T1, typename T2>inline void chkmin(T1 &x, T2 y) { if (x > y) x = y; }\ntemplate<typename T1, typename T2>inline void chkmax(T1 &x, T2 y) { if (x < y) x = y; } \ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const pair<T, U> &_p) { _out << _p.first << ' ' << _p.second; return _out; }\ntemplate<typename T, typename U> inline istream &operator>> (istream &_in, pair<T, U> &_p) { _in >> _p.first >> _p.second; return _in; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const vector<T> &_v) { if (_v.empty()) { return _out; } _out << _v.front(); for (auto _it = ++_v.begin(); _it != _v.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline istream &operator>> (istream &_in, vector<T> &_v) { for (auto &_i : _v) { _in >> _i; } return _in; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const set<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const multiset<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const unordered_set<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const unordered_multiset<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const map<T, U> &_m) { if (_m.empty()) { return _out; } _out << '(' << _m.begin()->first << \": \" << _m.begin()->second << ')'; for (auto _it = ++_m.begin(); _it != _m.end(); ++_it) { _out << \", (\" << _it->first << \": \" << _it->second << ')'; } return _out; }\ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const unordered_map<T, U> &_m) { if (_m.empty()) { return _out; } _out << '(' << _m.begin()->first << \": \" << _m.begin()->second << ')'; for (auto _it = ++_m.begin(); _it != _m.end(); ++_it) { _out << \", (\" << _it->first << \": \" << _it->second << ')'; } return _out; }\n#define sz(c) (int)(c).size()\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define left left228\n#define right right228\n#define next next228\n#define rank rank228\n#define prev prev228\n#define y1 y1228                                                         \n#define read(FILENAME) freopen((FILENAME + \".in\").c_str(), \"r\", stdin)\n#define write(FILENAME) freopen((FILENAME + \".out\").c_str(), \"w\", stdout)\n#define files(FILENAME) read(FILENAME), write(FILENAME)\n#define pb push_back\nconst string FILENAME = \"input\";\nconst int MAXN = 101;\nconst int Mod = 1000000007;\n\n\nint mul(int a, int b) {\n\treturn (1LL * a * b) % Mod;\n}\n\nint sum(int a, int b) {\n\treturn (a + b) % Mod;\n}\n\n\nint powm(int a, int b) {\n\tif (b == 0) {\n\t\treturn 1;\n\t}\n\tif (b & 1) {\n\t\treturn mul(a, powm(a, b - 1));\n\t} else {\n\t\tint g = powm(a, b >> 1);\n\t\treturn mul(g, g);\n\t}\n} \n\n\nint n;\nint h[MAXN];\n\n\nint solve1(int l, int r, int depth) {\n\tif (l == r) {\n\t\treturn 1;\n\t}\n\tint curh = Mod;\t\n\tfor (int i = l; i < r; i++) {\n\t\tchkmin(curh, h[i]);\n\t}\n\tvector<int> st;\n\tst.pb(l - 1);\n\tfor (int i = l; i < r; i++) {\n\t\tif (h[i] == curh) {\n\t\t\tst.pb(i);\n\t\t}\n\t}\n\tst.pb(r);\n\tint res = powm(2, curh - depth + 1);\n\tfor (int i = 0; i < sz(st) - 1; i++) {\n\t\tint nl = st[i] + 1;\n\t\tint nr = st[i + 1];\n\t\tif (nl != nr) {\n\t\t\tres = mul(res, solve1(nl, nr, curh + 1));\n\t\t} \n\t}\n\treturn res;\n}\n\n\nint solve(int l, int r, int depth) {\n\tif (l + 1 >= r) {\n\t\treturn 0;\n\t}\n\tint curh = Mod;\t\n\tfor (int i = l; i < r; i++) {\n\t\tchkmin(curh, h[i]);\n\t}\n\tif (depth > curh) {\n\t\treturn 1;\n\t}\n\tvector<int> st;\n\tst.pb(l - 1);\n\tint res = 1;\n\tfor (int i = l; i < r; i++) {\n\t\tif (h[i] == curh) {\n\t\t\tst.pb(i);\n\t\t\tres = mul(res, 2);\n\t\t}\n\t}\n\tst.pb(r);\n\tfor (int i = 0; i < sz(st) - 1; i++) {\n\t\tint nl = st[i] + 1;\n\t\tint nr = st[i + 1];\n\t\tif (nl != nr) {\n\t\t\tres = mul(res, sum(solve(nl, nr, curh + 1), mul(solve1(nl, nr, curh + 1), 2)));\n\t\t}\n\t}\n\treturn sum(res, Mod - solve1(l, r, curh));\n}\n\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\t//read(FILENAME);\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> h[i];\n\t}\n\tif (n == 1) {\n\t\tcout << powm(2, h[0]) << '\\n';\n\t\treturn 0;\n\t}\n\tcout << sum(solve(0, n, 1), solve1(0, n, 1)) << '\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"algorithm\"\n#include \"cstring\"\n#include \"cstdio\"\n#include \"vector\"\nusing namespace std;\n#define MAXN 116\n#define P 1000000007\nint n;\nint A[MAXN];\nint Pow( int x , int a ) {\n    int cur = x % P , ans = 1;\n    while( a ) {\n        if( a & 1 ) ans = 1ll * ans * cur % P;\n        cur = 1ll * cur * cur % P , a >>= 1;\n    }\n    return ans;\n}\npair<int,int> solve( int l , int r , int c ) {\n//    cout << l << ' ' << r << endl;\n    if( l > r ) return make_pair( 1 , 0 );\n    int h = 0x3f3f3f3f;\n    for( int i = l ; i <= r ; ++ i ) h = min( h , A[i] );\n    vector<int> pos;\n    pos.push_back( l - 1 );\n    for( int i = l ; i <= r ; ++ i ) if( A[i] == h ) pos.push_back( i );\n    pos.push_back( r + 1 );\n    int nm = pos.size() - 2;\n    int re = 1 , tot = 1;\n    for( int i = 0 ; i < pos.size() - 1 ; ++ i ) {\n        pair<int,int> ret = solve( pos[i] + 1, pos[i + 1] - 1, h );\n        re = 1ll * re * ret.first % P , tot = 1ll * tot * ( ret.first + ret.second ) % P;\n//        cout << l << ' ' << r << ' ' << pos[i] + 1 << ' ' << pos[i + 1] << ' ' << re << ' ' << tot << endl;\n    }\n    return make_pair( 1ll * re * Pow( 2 , h - c ) % P , ( 1ll * re * ( Pow( 2 , h - c ) - 2 ) % P + 1ll * Pow( 2 , nm ) * tot % P ) % P );\n}\nint main() {\n    cin >> n;\n    for( int i = 1 ; i <= n ; ++ i ) scanf(\"%d\",&A[i]);\n    cout << solve( 1 , n , 0 ).second << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long LL;\nusing namespace std;\n\nconst int N=105;\nconst int MOD=1000000007;\nint n,f[N][N],a[N],w[N],m;\n\nint ksm(int x,int y){\n    if (y<0) return 1;\n    int ans=1;\n    while (y){\n        if (y&1) ans=(LL)ans*x%MOD;\n        x=(LL)x*x%MOD;y>>=1;\n    }\n    return ans;\n}\n\nint solution(int n,vector<int>& nums){\n  for(int i=1;i<=n;i++){\n    w[++m] = nums[i];\n  }\n  sort(w+1,w+m+1);\n  unique(w+1,w+m+1)-w-1;\n  for (int i=1;i<=n;i++) nums[i]=std::lower_bound(w+1,w+m+1,nums[i])-w;\n  f[0][0]=1;\n  for (int i=1;i<=n;i++)\n  {\n      for (int j=nums[i]+1;j<=nums[i-1];j++) (f[i][0]+=f[i-1][j]*2%MOD)%=MOD;\n      (f[i][0]+=f[i-1][0]*2%MOD)%=MOD;\n      for (int j=1;j<=nums[i];j++)\n      {\n          f[i][j]=(LL)f[i-1][j]*ksm(2,w[nums[i]]-w[nums[i-1]])%MOD;\n          if (nums[i-1]>=j) continue;\n          if (j>1) (f[i][j]+=(LL)f[i-1][0]*(ksm(2,w[j]-w[j-1])-1)%MOD*2%MOD*ksm(2,w[nums[i]]-w[j])%MOD)%=MOD;\n          else (f[i][j]+=(LL)f[i-1][0]*(ksm(2,w[j])-2)%MOD*ksm(2,w[nums[i]]-w[j])%MOD)%=MOD;\n      }\n  }\n  int ans=0;\n  for (int i=0;i<=m;i++) (ans+=f[n][i])%=MOD;\n  return ans;\n}\n\nint main()\n{\n    scanf(\"%d\",&n);\n    for (int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n    vector<int> nums(a,a+n+1);\n    int res = solution(n, nums);\n    cout<<res<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<cstring>\n#include<stdlib.h>\n#include<time.h>\n#include<math.h>\n#include<algorithm>\n#include<vector>\n#define ll long long\n#define maxn 105\n#define p 1000000007\n#define inf 0x3f3f3f3f\nusing namespace std;\nint n,h[maxn],root,tot=1;\nint si[maxn],a[maxn];\nll f[maxn][2];// f[maxn][0]表示非黑白相间的方案数\nvector<int> c[maxn];\n\ninline int read()\n{\n\tint num,sign=1;\n\tchar c;\n\twhile((c=getchar())<'0'||c>'9')\n\t\tif(c=='-')sign=-1;\n\tnum=c-'0';\n\twhile((c=getchar())>='0'&&c<='9')\n\t\tnum=(num<<1)+(num<<3)+c-'0';\n\treturn num*sign;\n}\n\nvoid build(int l,int r,int id)\n{\n\tint minheight=inf,top=0;\n\tint st[maxn];\n\tsi[id]=r-l+1;\n\tfor(register int i=l;i<=r;++i)\n\t{\n\t\tif(h[i]<=minheight)\n\t\t{\n\t\t\tif(h[i]<minheight)\n\t\t\t{\n\t\t\t\ttop=0;\n\t\t\t\tminheight=h[i];\n\t\t\t\tst[++top]=i;\n\t\t\t}\n\t\t\telse\n\t\t\t\tst[++top]=i;\n\t\t}\n\t}\n\tst[++top]=r+1,a[id]=minheight;\n\tint lastgo=l;\n\tfor(register int i=1;i<=top;++i)\n\t{\n\t\tif(st[i]==lastgo)\n\t\t{\n\t\t\t++lastgo;\n\t\t\tcontinue;\n\t\t}\n\t\t++tot;\n\t\tc[id].push_back(tot);\n\t\tbuild(lastgo,st[i]-1,tot);\n\t\tlastgo=st[i]+1;\n\t}\n}\n\ninline ll ksm(ll a,ll b)\n{\n\tll res=1;\n\twhile(b)\n\t{\n\t\tif(b&1)res=(res*a)%p;\n\t\tb>>=1;\n\t\ta=(a*a)%p;\n\t}\n\treturn res;\n}\n\nvoid dfs(int u,int lasth)\n{\n\tint sum=si[u];\n\tint H=a[u]-lasth;\n\tf[u][1]=1,f[u][0]=1;\n\tfor(register int i=0;i<c[u].size();++i)\n\t{\n\t\tint v=c[u][i];\n\t\tdfs(v,a[u]);\n\t\tf[u][0]=(f[u][0]*((f[v][1]+f[v][0])%p)%p+(f[u][0]*f[v][1])%p)%p;\n\t\tf[u][1]=(f[v][1]*f[u][1])%p;\n\t\tsum-=si[v];\n\t}\n\tf[u][0]=((f[u][0]*ksm(2,sum))%p+(p-2*f[u][1])%p)%p;\n\tf[u][1]=(f[u][1]*ksm(2,H))%p;\n}\n\nint main()\n{\n\tn=read();\n\tfor(register int i=1;i<=n;++i)h[i]=read();\n\tbuild(1,n,1);\n\tdfs(1,0);\n\tprintf(\"%lld\\n\",(f[1][0]+f[1][1])%p);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": " #include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n\ntypedef long long LL;\n\nconst int N=105;\nconst int MOD=1000000007;\n\nint n,f[N][N],h[N],w[N],m;\n\nint ksm(int x,int y)\n{\n    if (y<0) return 1;\n    int ans=1;\n    while (y)\n    {\n        if (y&1) ans=(LL)ans*x%MOD;\n        x=(LL)x*x%MOD;y>>=1;\n    }\n    return ans;\n}\n\nint main()\n{\n    scanf(\"%d\",&n);\n    for (int i=1;i<=n;i++) scanf(\"%d\",&h[i]),w[++m]=h[i];\n    std::sort(w+1,w+m+1);\n    m=std::unique(w+1,w+m+1)-w-1;\n    for (int i=1;i<=n;i++) h[i]=std::lower_bound(w+1,w+m+1,h[i])-w;\n    f[0][0]=1;\n    for (int i=1;i<=n;i++)\n    {\n        for (int j=h[i]+1;j<=h[i-1];j++) (f[i][0]+=f[i-1][j]*2%MOD)%=MOD;\n        (f[i][0]+=f[i-1][0]*2%MOD)%=MOD;\n        for (int j=1;j<=h[i];j++)\n        {\n            f[i][j]=(LL)f[i-1][j]*ksm(2,w[h[i]]-w[h[i-1]])%MOD;\n            if (h[i-1]>=j) continue;\n            if (j>1) (f[i][j]+=(LL)f[i-1][0]*ksm(2,w[h[i]]-w[j-1])%MOD)%=MOD;\n            else (f[i][j]+=(LL)f[i-1][0]*(ksm(2,w[j])-2)%MOD*ksm(2,w[h[i]]-w[j])%MOD)%=MOD;\n        }\n    }\n    \n    printf(\"%d\\n\", h[1]);\n    for(int i = 0; i <= h[1]; ++i) printf(\"%d \", f[1][i]); printf(\"\\n\");\n    \n    int ans=0;\n    for (int i=0;i<=m;i++) (ans+=f[n][i])%=MOD;\n    printf(\"%d\",ans);\n    return 0;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pii pair<int, int>\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst int N = 110, mod = 1e9 + 7;\n\nll h[N], dp[N][N], f[N][N], y[N], t[N];\n\nint power(int a, int b)\n{\n\tif(b == 0) return 1;\n\tll res = power(a, b/2); \n\tres *= res, res %= mod;\n\tif(b & 1) res *= a, res %= mod;\n\treturn res;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tvector <int> vc; vc.pb(0);\n\n\tint n; cin >> n;\n\tfor (int i=0; i<n; i++) {\n\t\tcin >> h[i];\n\t\tvc.pb(h[i]);\n\t}\n\n\tsort(vc.begin(), vc.end());\n\tvc.resize(unique(vc.begin(), vc.end()) - vc.begin());\n\t\n\tint cnt = 0;\n\tfor (auto Y : vc)\n\t\ty[cnt ++] = Y;\n\n\tfor (int i=0; i<n; i++)\n\t\tt[i] = lower_bound(vc.begin(), vc.end(), h[i]) - vc.begin();\n\n\n\tfor (int j=0; j<t[0]; j++)\n\t{\n\t\tint y1 = y[j], y2 = y[j + 1];\n\t\tif(y2 >= y1 + 2)\n\t\t{\n\t\t\tint R = h[0] - y[j] - 2, L = h[0] - y[j + 1];\n\t\t\tdp[0][j] = power(2, R + 1) + mod - power(2, L); dp[0][j] %= mod;\n\t\t}\n\t\tint pw = max(0LL, h[0] - y[j + 1] - 1);\n\t\tf[0][j] = power(2, pw);\n\t}\n\n\tfor (int i=1; i<n; i++)\n\t\tfor (int j=0; j<t[i]; j++)\n\t\t{\n\t\t\tif (j < t[i] - 1)\n\t\t\t{\n\t\t\t\tif(j + 1 <= t[i - 1])\n\t\t\t\t{\n\t\t\t\t\tll way = dp[i - 1][j];\n\t\t\t\t\tif(h[i] > h[i - 1]) way *= power(2, h[i] - h[i - 1]);\n\t\t\t\t\tdp[i][j] = way % mod;\n\n\t\t\t\t\tbool done = 0;\n\n\t\t\t\t\tway = f[i - 1][j];\n\t\t\t\t\tif(j == t[i - 1] - 1) way *= 2, way %= mod, done = 1;\n\n\t\t\t\t\tif(h[i] > h[i - 1]) way *= power(2, h[i] - h[i - 1] - done), way %= mod;\n\t\t\t\t\tf[i][j] = way;\n\n\t\t\t\t}else\n\t\t\t\t{\n\t\t\t\t\tll way = 2LL * f[i - 1][t[i - 1] - 1] % mod;\n\t\t\t\t\tint R = h[i] - y[j] - 2, L = h[i] - y[j + 1];\n\t\t\t\t\tway *= (power(2, R + 1) + mod - power(2, L)) % mod;\n\t\t\t\t\tdp[i][j] = way % mod;\n\n\t\t\t\t\tf[i][j] = 2LL * f[i - 1][t[i - 1] - 1] % mod;\n\t\t\t\t\tf[i][j] *= power(2, h[i] - y[j + 1] - 1); f[i][j] %= mod;\n\t\t\t\t}\n\t\t\t}else\n\t\t\t{\n\t\t\t\tif(t[i - 1] >= j + 1){\n\t\t\t\t\tdp[i][j] = dp[i - 1][j];\n\t\t\t\t\tll ps = 0;\n\t\t\t\t\tfor (int k=j; k<t[i - 1]; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tps += 2LL * f[i - 1][k]; ps %= mod;\n\t\t\t\t\t\tif(k + 1 < t[i - 1]) ps += 2LL * dp[i - 1][k + 1], ps %= mod;\n\t\t\t\t\t}\n\t\t\t\t\tf[i][j] = ps;\n\t\t\t\t}else\n\t\t\t\t{\n\t\t\t\t\tll way = 2LL * f[i - 1][t[i - 1] - 1];\n\t\t\t\t\tway *= power(2, h[i] - y[j] - 1) + mod - 1; way %= mod;\n\t\t\t\t\tdp[i][j] = way;\n\n\t\t\t\t\tf[i][j] = 2LL * f[i - 1][t[i - 1] - 1] % mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\tll ans = 0;\n\tfor(int j=0; j<t[n - 1]; j++) {\n\t\tans += (2LL * dp[n - 1][j]) % mod;\n\t\tans += (2LL * f[n - 1][j]) % mod;\n\t\tans %= mod;\n\t}\n\n\tans %= mod;\n\tcout << ans << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#define N 102\n#define pi pair<int,int>\n#define mkp make_pair\n#define fi first\n#define se second\n\nusing namespace std;\n\nconst int mod = 1e9 + 7;\n\nint n;\nint a[N];\n\nint quick_pow(int ,int);\npi solve(int ,int ,int);\n\nint main(){\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i <= n; ++i)\n\t\tscanf(\"%d\", a + i);\n\tpi ans = solve(1, n, 0);\n\tprintf(\"%d\\n\", (1ll * ans.fi + ans.se * 2 % mod) % mod);\n\treturn 0;\n}\n\nint quick_pow(int x, int y){\n\tint res = 1;\n\tfor(; y; y >>= 1, x = 1ll * x * x % mod)\n\t\tif(y & 1) res = 1ll * res * x % mod;\n\treturn res;\n}\n\npi solve(int l, int r, int h){\n\tif(l > r) return mkp(0, 0);\n\tif(l == r) return mkp(0, quick_pow(2, a[l] - h - 1));\n\tint mn = 999999999;\n\tfor(int i = l; i <= r; ++i) mn = min(mn, a[i]);\n\tint f[2] = {1, 1};\n\tfor(int i = l; i <= r; ++i)\n\t\tif(a[i] - mn){\n\t\t\tint pos = i;\n\t\t\twhile(pos + 1 <= r && a[pos + 1] - mn) ++pos;\n\t\t\tpi res = solve(i, pos, mn);\n\t\t\tf[0] = 1ll * f[0] * ((1ll * res.fi + 1ll * res.se * 4 % mod) % mod) % mod;\n\t\t\tf[1] = 1ll * f[1] * res.se % mod * 2 % mod; i = pos;\n\t\t}\n\t\telse f[0] = 1ll * f[0] * 2 % mod;\n\tf[0] = (f[0] + (1ll * mod - 1ll * f[1] * 2 % mod) % mod) % mod;\n\tf[1] = 1ll * f[1] * quick_pow(2, mn - h - 1) % mod;\n\treturn mkp(f[0], f[1]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst long long MOD = 1e9+7;\ntypedef pair<int, int> ii;\n\nint h[105];\n\nlong long memo[5][105][105];\n\nlong long pow2(long long b){\n    if(b <= 29){\n        return 1<<b;\n    }else{\n        long long temp = pow2(b>>1);\n        if(b&1){\n            return ((temp*temp)<<1)%MOD;\n        }else{\n            return temp*temp%MOD;\n        }\n    }\n}\n\nlong long dp(int mode, int i, int j, int offset = 0){\n    //if(i != 0 || j != 8){return 1;}\n    if(memo[mode][i][j] != -1){\n        return memo[mode][i][j];\n    }\n\n    int x = MOD;\n    for(int k = i; k <= j; k ++){\n        x = min(x, h[k]);\n    }\n\n    int w = 0;\n    for(int k = i; k <= j; k ++){\n        w += (h[k] == x);\n    }\n\n    vector<ii> startEnd;\n    int s = i;\n    for(int k = i; k <= j+1; k ++){\n        if(k == j+1 || h[k] == x){\n            // stop here\n            int e = k;\n            if(s == e){\n                s = k+1;\n                continue;\n            }\n            startEnd.push_back(ii(s, e-1));\n            s = k+1;\n        }\n    }\n\n    if(w == 0){w = j-i+1;} // edge case when all the heights are the same\n\n    /*printf(\"dp(%d, %d, %d) offset=%d x=%d w=%d\\n\", mode, i, j, offset, x, w);\n    for(ii se: startEnd){\n        printf(\"ii(%d, %d)\\n\", se.first, se.second);\n    }*/\n\n    if(mode == 1){\n        long long ans1 = pow2(x-offset);\n\n        for(ii se: startEnd){\n            int s, e;\n            tie(s, e) = se;\n            ans1 = ans1*dp(1, s, e, x)%MOD;\n        }\n\n        return memo[mode][i][j] = ans1%MOD;\n    }else if(mode == 3){\n        long long ans1 = (pow2(x-offset)+MOD-2)%MOD;\n        long long ans3 = pow2(w);\n\n        for(ii se: startEnd){\n            int s, e;\n            tie(s, e) = se;\n            ans1 = ans1*dp(1, s, e, x)%MOD;\n            ans3 = ans3*(dp(1, s, e, x)+dp(3, s, e, x))%MOD;\n        }\n\n        return memo[mode][i][j] = (ans1+ans3)%MOD;\n    }\n}\n\nint main(){\n    int N;\n    scanf(\"%d\", &N);\n\n    for(int i = 0; i < N; i ++){\n        scanf(\"%d\", &h[i]);\n    }\n\n    memset(memo, -1, sizeof(memo));\n    printf(\"%lld\", dp(3, 0, N-1));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author majk\n */\n\n#ifndef MAJK_LIB\n#define MAJK_LIB\n\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <fstream>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <algorithm>\n#include <numeric>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <array>\n#include <bitset>\nusing namespace std;\n\n#define x first\n#define y second\ntypedef std::pair<int,int> pii; typedef long long ll; typedef unsigned long long ull; typedef unsigned int ui; typedef pair<ui,ui> puu;\n\ntemplate <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate <typename T, typename U> std::ostream&operator<<(std::ostream&o, const pair<T,U>&p) {o << p.x << ' ' << p.y; return o;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {if(t.empty())o<<'\\n';for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\nui logceil(ll x) { return x?8*sizeof(ll)-__builtin_clzll(x):0; }\n\nnamespace std { template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}}; }\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename F> double bshd(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){l=m;}else{h=m;}}return (l+h)/2;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename F> double bsld(double l,double h,const F&f){ui r=200;while(r--){double m=(l+h)/2;if(f(m)){h=m;}else{l=m;}}return (l+h)/2;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector2<T>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector2<T>>(a,vector2<T>(b,c,t)){}};\ntemplate<typename T>class vector4:public vector<vector3<T>>{public:vector4(){} vector4(size_t a,size_t b,size_t c,size_t d,T t=T()):vector<vector3<T>>(a,vector3<T>(b,c,d,t)){}};\ntemplate<typename T>class vector5:public vector<vector4<T>>{public:vector5(){} vector5(size_t a,size_t b,size_t c,size_t d,size_t e,T t=T()):vector<vector4<T>>(a,vector4<T>(b,c,d,e,t)){}};\n\n\n#endif\n#ifndef MOD_H\n#define MOD_H\n\n\n\ntemplate <unsigned int N> class Field {\n    typedef unsigned int ui;\n    typedef unsigned long long ull;\n\tinline ui pow(ui a, ui p){ui r=1,e=a;while(p){if(p&1){r=((ull)r*e)%N;}e=((ull)e*e)%N;p>>=1;}return r;}\n\t/*extended GCD(slow):ll t=0,nt=1,r=N,nr=a;while(nr){ll q=r/nr;t-=q*nt;swap(t,nt);r-=q*nr;swap(r,nr);}assert(r<=1);return(t<0)?t+N:t;*/\n\tinline ui inv(ui a){return pow(a,N-2);}\npublic:\n    inline Field(int x = 0) : v(x<0?N+x:x) {}\n\tinline Field<N> pow(int p){return (*this)^p; }\n\tinline Field<N> operator^(int p){return {(int)pow(v,(ui)p)};}\n    inline Field<N>&operator+=(const Field<N>&o) {if (v+o.v >= N) v += o.v - N; else v += o.v; return *this; }\n    inline Field<N>&operator-=(const Field<N>&o) {if (v<o.v) v -= o.v-N; else v-=o.v; return *this; }\n    inline Field<N>&operator*=(const Field<N>&o) {v=(ull)v*o.v % N; return *this; }\n    inline Field<N>&operator/=(const Field<N>&o) { return *this*=inv(o.v); }\n    inline Field<N> operator+(const Field<N>&o) const {Field<N>r{*this};return r+=o;}\n    inline Field<N> operator-(const Field<N>&o) const {Field<N>r{*this};return r-=o;}\n    inline Field<N> operator*(const Field<N>&o) const {Field<N>r{*this};return r*=o;}\n    inline Field<N> operator/(const Field<N>&o) const {Field<N>r{*this};return r/=o;}\n    inline Field<N> operator-() {if(v) return {(int)(N-v)}; else return {0};};\n    inline Field<N>& operator++() { ++v; if (v==N) v=0; return *this; }\n    inline Field<N> operator++(int) { Field<N>r{*this}; ++*this; return r; }\n    inline Field<N>& operator--() { --v; if (v==-1) v=N-1; return *this; }\n    inline Field<N> operator--(int) { Field<N>r{*this}; --*this; return r; }\n    inline bool operator==(const Field<N>&o) const { return o.v==v; }\n\tinline bool operator!=(const Field<N>&o) const { return o.v!=v; }\n\tinline explicit operator ui() const { return v; }\n\tinline static vector<Field<N>>fact(int t){vector<Field<N>>F(t+1,1);for(int i=2;i<=t;++i){F[i]=F[i-1]*i;}return F;}\n\tinline static vector<Field<N>>invfact(int t){vector<Field<N>>F(t+1,1);Field<N> X{1};for(int i=2;i<=t;++i){X=X*i;}F[t]=1/X;for(int i=t-1;i>=2;--i){F[i]=F[i+1]*(i+1);}return F;}\nprivate: ui v;\n};\ntemplate<unsigned int N>istream &operator>>(std::istream&is,Field<N>&f){unsigned int v;is>>v;f=v;return is;}\ntemplate<unsigned int N>ostream &operator<<(std::ostream&os,const Field<N>&f){return os<<(unsigned int)f;}\ntemplate<unsigned int N>Field<N> operator+(int i,const Field<N>&f){return Field<N>(i)+f;}\ntemplate<unsigned int N>Field<N> operator-(int i,const Field<N>&f){return Field<N>(i)-f;}\ntemplate<unsigned int N>Field<N> operator*(int i,const Field<N>&f){return Field<N>(i)*f;}\ntemplate<unsigned int N>Field<N> operator/(int i,const Field<N>&f){return Field<N>(i)/f;}\n\n\ntypedef Field<1000000007> FieldMod;\n\nstruct Ring {\n\ttemplate <typename T>\n\tstatic T div(T p, T q, T N) {\n\t\tT t=0,nt=1,r=N,nr=q;\n\t\twhile(nr!=0){ T q=r/nr;t-=q*nt;r-=q*nr;swap(t,nt);swap(r,nr); }\n\t\tt=(t<0)?t+N:t;\n\t\tr=(r<0)?r+N:r;\n\t\tif (gcd(p,N)%r!=0) { return 0; }\n\t\treturn (t*p/r)%N;\n\t}\n};\n#endif\n\n\nclass DHistogramColoring {\npublic:\n    void solve(istream& cin, ostream& cout) {\n        int N; cin >> N;\n        vector<int> A(N); cin >> A;\n//        if (N == 1) {\n//            cout << FieldMod{2}.pow(A[0]) << endl;\n//            return;\n//        }\n\n        vector<FieldMod> D(N+1, 0);\n        D[0] = 1;\n        for (int i = 0; i <= N; ++i) {\n            for (int j = i+1; j <= N; ++j) {\n                ll choices = 0;\n                int lo = A[i];\n                for (int k = i; k < j; ++k) {\n                    choices += max(0, A[k] - (k==i?0:A[k-1]));\n                    lo = min(lo, A[k]);\n                }\n\n                if (i != 0 && j != N) {\n                    choices -= min(A[i-1], A[i]);\n                    choices -= min(A[j-1], A[j]);\n                    choices += min(lo, min(A[i-1],A[j]));\n                } else if (i == 0 && j != N) {\n                    choices -= min(A[j-1], A[j]);\n                    choices++;\n                } else if (i == 0 && j == N) {\n                    // ok\n                } else {\n                    choices -= min(A[i-1], A[i]);\n                }\n\n                D[j] += D[i] * FieldMod{2}.pow(choices % 1000000006);\n            }\n        }\n        cout << D[N] << '\\n';\n    }\n};\n\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tDHistogramColoring solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst ll p = 1e9+7;\n\nll n, h[105], dp[105][105], k;\nmap<int, int> m;\nvector<int> v;\n\nll exp(ll x, ll k) {\n\tif (k < 0)\n\t\treturn 0;\n\tif (k == 0)\n\t\treturn 1;\n\tif (k%2 == 1)\n\t\treturn x*exp(x, k-1)%p;\n\tll y = exp(x, k/2);\n\treturn y*y%p;\n}\n\n//alternate in first h1 squares\n//does not alternate in first h2 squares\n//total length x\nll ctalt(ll h1, ll h2, ll x) {\n\tif (h1 >= h2)\n\t\treturn 0;\n\tll ct1 = 0, ct2 = 0;\n\tif (h1 == 0)\n\t\tct1 = exp(2, x);\n\telse\n\t\tct1 = 2*exp(2, x-h1);\n\tif (h2 == 0)\n\t\tct2 = exp(2, x);\n\telse\n\t\tct2 = 2*exp(2, x-h2);\n\treturn (p+ct1%p-ct2%p)%p;\n}\n\nint main() {\n\tcin >> n;\n\tv.push_back(0);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> h[i];\n\t\tif (m.count(h[i]) > 0)\n\t\t\tcontinue;\n\t\tm[h[i]] = 1;\n\t\tv.push_back(h[i]);\n\t}\n\tsort(v.begin(), v.end());\n\tk = v.size();\n\tv.push_back(1000000005);\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (i == 0) {\n\t\t\tfor (int j = 0; j < k; ++j) {\n\t\t\t\tdp[i][j] = ctalt(v[j], v[j+1], h[i]);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tint t = 0, t1 = 0;\n\t\tfor (int j = 0; j < k; ++j) {\n\t\t\tif (h[i] == v[j])\n\t\t\t\tt = j;\n\t\t\tif (h[i-1] == v[j])\n\t\t\t\tt1 = j;\n\t\t}\n\n\t\tfor (int j = 0; j <= t1; ++j) {\n\t\t\tif (h[i] <= h[i-1]) {\n\t\t\t\tif (v[j] >= h[i])\n\t\t\t\t\tdp[i][t] = (dp[i][t] + 2*dp[i-1][j])%p;\n\t\t\t\telse\n\t\t\t\t\tdp[i][j] = (dp[i][j] + dp[i-1][j])%p;\n\t\t\t} else {\n\t\t\t\tif (j < t1) {\n\t\t\t\t\tdp[i][j] = (dp[i][j] + dp[i-1][j]*exp(2, h[i]-h[i-1]))%p;\n\t\t\t\t} else {\n\t\t\t\t\tll x = dp[i-1][j];\n\t\t\t\t\tfor (int jj = t1; jj < k; ++jj)\n\t\t\t\t\t\tdp[i][jj] = (dp[i][jj] + x*ctalt(v[jj], v[jj+1], h[i]))%p;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tll ans = 0;\n\tfor (int j = 0; j < k; ++j)\n\t\tans = (ans + dp[n-1][j])%p;\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\ntemplate <typename TYPE> inline void chkmax(TYPE &x,TYPE y){x<y?x=y:0;}\ntemplate <typename TYPE> inline void chkmin(TYPE &x,TYPE y){y<x?x=y:0;}\ntemplate <typename TYPE> void readint(TYPE &x)\n{\n    x=0;int f=1;char c;\n    for(c=getchar();!isdigit(c);c=getchar())if(c=='-')f=-1;\n    for(;isdigit(c);c=getchar())x=x*10+c-'0';\n    x*=f;\n}\nconst int MAXN=105,MOD=1000000007;\nint qmi(int x,int y)\n{\n\tint ans=1;\n\tfor(;y;y>>=1,x=1ll*x*x%MOD)\n\t\tif(y&1)ans=1ll*ans*x%MOD;\n\treturn ans;\n}\n\nint n,a[MAXN],f[MAXN][MAXN],g[MAXN][MAXN];\nvoid solve(int l,int r,int x)\n{\n\tint y=1<<30,las=l-1,w=0;\n\tfor(int i=l;i<=r;++i)chkmin(y,a[i]);\n\tfor(int i=l;i<=r;++i)if(a[i]==y)++w;\n\tif(w==r-l+1)\n\t{\n\t\tf[l][r]=(1ll*qmi(2,y-x)+qmi(2,r-l+1)-2+MOD)%MOD;\n\t\tg[l][r]=qmi(2,y-x);\n\t\treturn;\n\t}\n\tf[l][r]=qmi(2,w);\n\tg[l][r]=1;\n\tfor(int i=l;i<=r+1;++i)\n\t\tif(i>r || a[i]==y)\n\t\t{\n\t\t\tif(i-las>=2)\n\t\t\t{\n\t\t\t\tsolve(las+1,i-1,y);\n\t\t\t\tg[l][r]=1ll*g[l][r]*g[las+1][i-1]%MOD;\n\t\t\t\tf[l][r]=1ll*f[l][r]*(g[las+1][i-1]+f[las+1][i-1])%MOD;\n\t\t\t}\n\t\t\tlas=i;\n\t\t}\n\tf[l][r]=(f[l][r]+1ll*g[l][r]*(qmi(2,y-x)-2+MOD))%MOD;\n\tg[l][r]=1ll*g[l][r]*qmi(2,y-x)%MOD;\n//cerr<<l<<\" \"<<r<<\":\"<<f[l][r]<<\" \"<<g[l][r]<<endl;\n}\n\nint main()\n{\n\t#ifndef ONLINE_JUDGE\n\tfreopen(\"code.in\",\"r\",stdin);\n//\tfreopen(\"code.out\",\"w\",stdout);\n\t#endif\n\treadint(n);\n\tfor(int i=1;i<=n;++i)readint(a[i]);\n\tsolve(1,n,0);\n\tprintf(\"%d\\n\",f[1][n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <limits>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <iterator>\n#include <bitset>\n#include <unordered_map>\n#include <unordered_set>\n\nusing namespace std;\n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)c.size())\n#define ten(n) ((int)1e##n)\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing Pll = pair<ll, ll>;\n\ntemplate<typename ...> static inline int getchar_unlocked(void) { return getchar(); }\ntemplate<typename ...> static inline void putchar_unlocked(int c) { putchar(c); }\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\nvoid reader(int& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k && k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k < '0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nvoid reader(ll& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k && k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k < '0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nint reader(char c[]) { int i, s = 0; for (;;) { mygc(i); if (i != ' ' && i != '\\n' && i != '\\r' && i != '\\t' && i != EOF) break; }c[s++] = i; for (;;) { mygc(i); if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break; c[s++] = i; }c[s] = '\\0'; return s; }\nint reader(string& c) { int i; for (;;) { mygc(i); if (i != ' ' && i != '\\n' && i != '\\r' && i != '\\t' && i != EOF) break; }c.push_back(i); for (;;) { mygc(i); if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break; c.push_back(i); }; return sz(c); }\ntemplate <class T, class S> void reader(T& x, S& y) { reader(x); reader(y); }\ntemplate <class T, class S, class U> void reader(T& x, S& y, U& z) { reader(x); reader(y); reader(z); }\ntemplate <class T, class S, class U, class V> void reader(T& x, S& y, U& z, V& w) { reader(x); reader(y); reader(z); reader(w); }\nvoid writer(int x, char c) { int s = 0, m = 0; char f[10]; if (x < 0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(ll x, char c) { int s = 0, m = 0; char f[20]; if (x < 0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(const char c[]) { int i; for (i = 0; c[i] != '\\0'; i++)mypc(c[i]); }\nvoid writer(const string& x, char c) { int i; for (i = 0; x[i] != '\\0'; i++)mypc(x[i]); mypc(c); }\nvoid writer(const char x[], char c) { int i; for (i = 0; x[i] != '\\0'; i++)mypc(x[i]); mypc(c); }\ntemplate<class T> void writerLn(T x) { writer(x, '\\n'); }\ntemplate<class T, class S> void writerLn(T x, S y) { writer(x, ' '); writer(y, '\\n'); }\ntemplate<class T, class S, class U> void writerLn(T x, S y, U z) { writer(x, ' '); writer(y, ' '); writer(z, '\\n'); }\ntemplate<class T, class S, class U, class V> void writerLn(T x, S y, U z, V v) { writer(x, ' '); writer(y, ' '); writer(z, ' '); writer(v, '\\n'); }\ntemplate<class T> void writerArr(T x[], int n) { if (!n) { mypc('\\n'); return; }FOR(i, n - 1)writer(x[i], ' '); writer(x[n - 1], '\\n'); }\ntemplate<class T> void writerArr(vector<T>& x) { writerArr(x.data(), (int)x.size()); }\n\ntemplate<class T> void chmin(T& a, const T& b) { if (a > b) a = b; }\ntemplate<class T> void chmax(T& a, const T& b) { if (a < b) a = b; }\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\ntemplate<class T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\nll mod_pow(ll a, ll n, ll mod) {\n\tll ret = 1;\n\tll p = a % mod;\n\twhile (n) {\n\t\tif (n & 1) ret = ret * p % mod;\n\t\tp = p * p % mod;\n\t\tn >>= 1;\n\t}\n\treturn ret;\n}\ntemplate<class T> T extgcd(T a, T b, T& x, T& y) { for (T u = y = 1, v = x = 0; a;) { T q = b / a; swap(x -= q * u, u); swap(y -= q * v, v); swap(b -= q * a, a); } return b; }\nll mod_inv(ll a, ll m) { ll x, y; extgcd<ll>(a, m, x, y); return (m + x % m) % m; }\n\n#ifdef _MSC_VER\n// #ifdef _DEBUG\ntemplate <typename ... Args>\nvoid debugPrintf(const char* format, Args const& ... args) {\n\tfprintf(stderr, format, args ...);\n\tfflush(stderr);\n}\n#else\n#define debugPrintf(...)\n#endif\n\nusing ull = unsigned long long;\n\nvoid reader(ull& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k && k <= '9') { x = ull(k - '0'); break; } }for (;;) { mygc(k); if (k < '0' || k>'9')break; x = x * 10 + k - '0'; } }\nvoid writer(ull x, char c) { int s = 0, m = 0; char f[20]; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\n\nclass UnionFind {\nprivate:\n    int n;\n    vector<int> a;\npublic:\n    UnionFind(int n) : n(n), a(n, -1) {}\n    int find(int x) { return a[x] < 0 ? x : (a[x] = find(a[x])); }\n    bool same(int x, int y) { return find(x) == find(y); }\n    bool same(Pii& p) { return same(p.first, p.second); }\n    bool unite(int x, int y) {\n        x = find(x), y = find(y);\n        if (x == y) return false;\n        if (a[x] > a[y]) swap(x, y);\n        a[x] += a[y];\n        a[y] = x;\n        n--;\n        return true;\n    }\n    bool unite(Pii& p) { return unite(p.first, p.second); }\n    int size() const { return n; }\n    int size(int x) { return -a[find(x)]; }\n};\n\nstruct P {\n    ll lastH;\n    ll a, b;\n};\n\nconst int MOD = ten(9) + 7;\n\nll h[100];\nP vals[100];\n\nint main() {\n    int n; reader(n);\n    UnionFind uf(n);\n    vector<Pii> vp;\n    FOR(i, n) {\n        reader(h[i]);\n        vp.emplace_back(h[i], i);\n    }\n    sort(vp.rbegin(), vp.rend());\n\n    auto concat = [&](int _l, int _r) {\n        _l = uf.find(_l);\n        _r = uf.find(_r);\n        auto& l = vals[_l];\n        auto& r = vals[_r];\n        ll curH = min(l.lastH, r.lastH);\n        l.a = l.a * mod_pow(2, l.lastH - curH, MOD) % MOD;\n        r.a = r.a * mod_pow(2, r.lastH - curH, MOD) % MOD;\n        l.lastH = r.lastH = curH;\n\n       P dest;\n       dest.lastH = curH;\n       dest.a = l.a * r.a % MOD * mod_inv(2, MOD) % MOD;\n       dest.b = ((l.a + l.b) * (r.a + r.b) - dest.a) % MOD;\n       uf.unite(_l, _r);\n       int _o = uf.find(_l);\n       vals[_o] = dest;\n    };\n\n    vector<bool> used(n);\n    for (auto& kv : vp) {\n        used[kv.second] = true;\n        vals[kv.second] = { kv.first, 2, 0 };\n\n        if (kv.second > 0 && used[kv.second - 1]) {\n            concat(kv.second - 1, kv.second);\n        }\n        if (kv.second < n-1 && used[kv.second + 1]) {\n            concat(kv.second, kv.second + 1);\n        }\n    }\n\n    int p = uf.find(0);\n    auto& x = vals[p];\n    ll ans = (x.a * mod_pow(2, x.lastH - 1, MOD) + x.b) % MOD;\n    ans = (ans % MOD + MOD) % MOD;\n    writerLn(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconstexpr int P = 1E9 + 7;\nint power(int base, int exp) {\n    int result = 1;\n    while (exp > 0) {\n        if (exp & 1)\n            result = 1LL * result * base % P;\n        base = 1LL * base * base % P;\n        exp >>= 1;\n    }\n    return result;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin >> n;\n    vector<int> h(n);\n    for (int i = 0; i < n; ++i)\n        cin >> h[i];\n    function<array<int, 2>(int, int, int)> calc = [&](int l, int r, int low) {\n        if (l == r)\n            return array<int, 2>{1, 0};\n        int mn = 1E9;\n        array<int, 2> dp {1, 1};\n        for (int i = l; i < r; ++i)\n            mn = min(mn, h[i]);\n        int x = l, cnt = 0;\n        for (int i = l; i < r; ++i) {\n            if (h[i] == mn) {\n                auto f = calc(x, i, mn);\n                x = i + 1;\n                ++cnt;\n                dp[0] = 1LL * dp[0] * f[0] % P;\n                dp[1] = 1LL * dp[1] * (f[0] + f[1]) % P;\n            }\n        }\n        auto f = calc(x, r, mn);\n        dp[0] = 1LL * dp[0] * f[0] % P;\n        dp[1] = 1LL * dp[1] * (f[0] + f[1]) % P;\n        int tmp = power(2, mn - low);\n        dp[1] = (1LL * power(2, cnt) * dp[1] + 1LL * (tmp - 2 + P) * dp[0]) % P;\n        dp[0] = 1LL * tmp * dp[0] % P;\n        return dp;\n    };\n    cout << calc(0, n, 0)[1] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#define ll long long\nusing namespace std;\ntemplate <class T>\ninline void rd(T &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile(!isdigit(c)) { if(c=='-') f=-1; c=getchar(); }\n\twhile(isdigit(c)) x=x*10-'0'+c,c=getchar(); x*=f;\n}\nconst int N=110,mod=1e9+7;\ninline int Pow(int x,int y) { int res=1; for(;y;y>>=1,x=x*(ll)x%mod) if(y&1) res=res*(ll)x%mod; return res; }\nint f[N][N][2],vis[N][N],h[N],minv[N][N],n;\nvoid sol(int l,int r) {\n\tif(vis[l][r]) return;\n\tvis[l][r]=1;\n\tminv[l][r]=1e9;\n\tfor(int i=l;i<=r;++i) minv[l][r]=min(minv[l][r],h[i]);\n\tint lst=l-1,tot=0;\n\tf[l][r][0]=f[l][r][1]=1;\n\tfor(int i=l;i<=r+1;++i) if(h[i]==minv[l][r]||i==r+1) {\n\t\tint L=lst+1,R=i-1; lst=i;\n\t\tif(L<=R) {\n\t\t\tsol(L,R);\n\t\t\tf[l][r][0]=f[l][r][0]*(ll)f[L][R][0]%mod*Pow(2,minv[L][R]-minv[l][r]-1)%mod;\n\t\t\tf[l][r][1]=f[l][r][1]*(ll)(f[L][R][0]*(ll)Pow(2,minv[L][R]-minv[l][r])%mod+f[L][R][1])%mod;\n\t\t\ttot+=R-L+1;\n\t\t}\n\t}\n\tf[l][r][0]=f[l][r][0]*2ll%mod;\n\tf[l][r][1]=(f[l][r][1]*(ll)Pow(2,r-l+1-tot)%mod-f[l][r][0])%mod;\n}\t\t\n\t\nint main() {\n\trd(n);\n\tfor(int i=1;i<=n;++i) rd(h[i]);\n\tsol(1,n);\n\tint ans=(f[1][n][0]*(ll)Pow(2,minv[1][n]-1)%mod+f[1][n][1])%mod;\n\tprintf(\"%d\",(ans+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//problem:\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mk make_pair\n#define lob lower_bound\n#define upb upper_bound\n#define fst first\n#define scd second\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ninline int read(){\n\tint f=1,x=0;char ch=getchar();\n\twhile(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}\n\twhile(isdigit(ch)){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\ninline ll readll(){\n\tll f=1,x=0;char ch=getchar();\n\twhile(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}\n\twhile(isdigit(ch)){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nconst int MAXN=105,MOD=1e9+7;\ninline int pow_mod(int x,int i){int y=1;while(i){if(i&1)y=(ll)y*x%MOD;x=(ll)x*x%MOD;i>>=1;}return y;}\nint n,h[MAXN];\nvector<int>vec,w[MAXN];\nint solve1(int l,int r,int k,int low){\n\t//cout<<\"dp1 \"<<l<<\" \"<<r<<\" \"<<k<<endl;\n\tint mx=0,mn=2e9;\n\tfor(int i=l;i<=r;++i)mx=max(mx,h[i]),mn=min(mn,h[i]);\n\tif(mn>k)return solve1(l,r,mn,low);\n\tif(mx==k&&mx==mn)return pow_mod(2,vec[k]-low);\n\t\n\tint ans=1,st=lob(w[k].begin(),w[k].end(),l)-w[k].begin(),ed=lob(w[k].begin(),w[k].end(),r)-w[k].begin();\n\ted=min(ed,(int)w[k].size()-1);\n\tif(w[k][ed]>r)ed--;\n\tint lst=l;\n\tfor(int i=st;i<=ed;++i){\n\t\tassert(w[k][i]>=l&&w[k][i]<=r);\n\t\tif(lst<=w[k][i]-1)ans=(ll)ans*solve1(lst,w[k][i]-1,k+1,vec[k])%MOD;\n\t\tlst=w[k][i]+1;\n\t}\n\tif(lst<=r)ans=(ll)ans*solve1(lst,r,k+1,vec[k])%MOD;\n\tans=(ll)ans*pow_mod(2,vec[k]-low)%MOD;\n\treturn ans;\n}\nint solve2(int l,int r,int k,int low){\n\t//cout<<l<<\" \"<<r<<\" \"<<k<<endl;\n\tint mx=0,mn=2e9;\n\tfor(int i=l;i<=r;++i)mx=max(mx,h[i]),mn=min(mn,h[i]);\n\tif(mn>k)return solve2(l,r,mn,low);\n\tif(mx==k&&mx==mn)return (pow_mod(2,r-l+1)-2+pow_mod(2,vec[k]-low))%MOD;\n\t\n\tint st=lob(w[k].begin(),w[k].end(),l)-w[k].begin(),ed=lob(w[k].begin(),w[k].end(),r)-w[k].begin();\n\ted=min(ed,(int)w[k].size()-1);\n\tif(w[k][ed]>r)ed--;\n\tvector<int>dp1,dp2;\n\tint lst=l,t=0;\n\tfor(int i=st;i<=ed;++i){\n\t\tassert(w[k][i]>=l&&w[k][i]<=r);\n\t\tt++;\n\t\tif(lst<=w[k][i]-1)dp1.pb(solve1(lst,w[k][i]-1,k+1,vec[k])),dp2.pb(solve2(lst,w[k][i]-1,k+1,vec[k]));\n\t\tlst=w[k][i]+1;\n\t}\n\tif(lst<=r)dp1.pb(solve1(lst,r,k+1,vec[k])),dp2.pb(solve2(lst,r,k+1,vec[k]));\n\tint ans1=1,ans2=1;\n\tfor(int i=0;i<(int)dp1.size();++i)ans1=(ll)ans1*(dp1[i]+dp2[i])%MOD,ans2=(ll)ans2*dp1[i]%MOD;\n\tans1=(ll)ans1*pow_mod(2,t)%MOD;\n\tans2=(ll)ans2*(pow_mod(2,vec[k]-low)-2)%MOD;\n\treturn (ans1+ans2)%MOD;\n}\nint main() {\n\tn=read();\n\tfor(int i=1;i<=n;++i)h[i]=read(),vec.pb(h[i]);\n\tvec.pb(0);\n\tsort(vec.begin(),vec.end());\n\tvec.erase(unique(vec.begin(),vec.end()),vec.end());\n\tfor(int i=1;i<=n;++i)h[i]=lob(vec.begin(),vec.end(),h[i])-vec.begin(),w[h[i]].pb(i);\n\tcout<<solve2(1,n,1,0)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define int long long\nusing namespace std;\nconst int N=102;\nconst int mod=1e9+7;\nint ar[N];\nint binpow(int x,int y){\n\tint tich=1;\n\twhile(y){\n\t\tif(y&1){\n\t\t\ttich*=x;\n\t\t\ttich%=mod;\n\t\t}\n\t\tx*=x;\n\t\tx%=mod;\n\t\ty>>=1;\n\t}\n\treturn tich;\n}\npair<int,int> solve(int l,int r){\n//\tcout<<l<<' '<<r<<endl;\n\tint i,dem=0,num1=1,num2=1,min1=mod,lst=l;\n\tpair<int,int> tmp;\n\tfor(i=l;i<=r;i++){\n\t\tmin1=min(min1,ar[i]);\n\t}\n\tfor(i=l;i<=r;i++){\n\t\tar[i]-=min1;\n\t}\n\tfor(i=l;i<=r;i++){\n\t\tif(!ar[i]){\n\t\t\tdem++;\n\t\t\tif(lst!=i){\n\t\t\t\ttmp=solve(lst,i-1);\n\t\t\t\tnum1*=tmp.first;\n\t\t\t\tnum1%=mod;\n\t\t\t\tnum2*=(tmp.first+tmp.second);\n\t\t\t\tnum2%=mod;\n\t\t\t}\n\t\t\tlst=i+1;\n\t\t}\n//\t\tdem++;\n\t}\n\tif(lst!=r+1&&lst!=l){\n\t\ttmp=solve(lst,r);\n\t\tnum1*=tmp.first;\n\t\tnum1%=mod;\n\t\tnum2*=(tmp.first+tmp.second);\n\t\tnum2%=mod;\n\t}\n\tnum2=(binpow(2,dem)*num2+(binpow(2,min1)-2)*num1)%mod;\n\tif(num2<0){\n\t\tnum2+=mod;\n\t}\n\tnum1*=binpow(2,min1);\n\tnum1%=mod;\n\treturn {num1,num2};\n}\nsigned main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n,i,j,k,l;\n\tcin>>n;\n\tfor(i=1;i<=n;i++){\n\t\tcin>>ar[i];\n\t}\n\tcout<<solve(1,n).second;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Author:xht37\n#include <bits/stdc++.h>\n\n#define ui unsigned int\n#define ll long long\n#define ul unsigned ll\n#define ld long double\n\n#define pi pair <int, int>\n#define fi first\n#define se second\n#define mp make_pair\n\n#define ls (p << 1)\n#define rs (ls | 1)\n#define md ((t[p].l + t[p].r) >> 1)\n\n#define vi vector <int>\n#define pb push_back\n#define pq priority_queue\n\n#define dbg(x) cerr << #x\" = \" << x << endl\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#define fl(x) freopen(x\".in\", \"r\", stdin), freopen(x\".out\", \"w\", stdout)\n\nusing namespace std;\n\nnamespace io {\n\tconst int SI = 1 << 21 | 1;\n\tchar IB[SI], *IS, *IT, OB[SI], *OS = OB, *OT = OS + SI - 1, c, ch[100];\n\tint f, t;\n\t#define gc() (IS == IT ? (IT = (IS = IB) + fread(IB, 1, SI, stdin), IS == IT ? EOF : *IS++) : *IS++)\n\tinline void flush() {\n\t\tfwrite(OB, 1, OS - OB, stdout), OS = OB;\n\t}\n\tinline void pc(char x) {\n\t\t*OS++ = x;\n\t\tif (OS == OT) flush();\n\t}\n\n\ttemplate <class I>\n\tinline void rd(I &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + (c & 15), c = gc());\n\t\tx *= f;\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y) {\n\t\trd(x), rd(y);\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y, I &z) {\n\t\trd(x), rd(y), rd(z);\n\t}\n\ttemplate <class I>\n\tinline void rda(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) rd(a[i]);\n\t}\n\tinline void rdc(char &c) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t}\n\tinline void rds(char *s, int &n) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (n = 0; c >= 33 && c <= 126; s[++n] = c, c = gc());\n\t\ts[n+1] = '\\0';\n\t}\n\tinline void rds(string &s) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (s.clear(); c >= 33 && c <= 126; s.pb(c), c = gc());\n\t}\n\n\ttemplate <class I>\n\tinline void print(I x, char k = '\\n') {\n\t\tif (!x) pc('0');\n\t\tif (x < 0) pc('-'), x = -x;\n\t\twhile (x) ch[++t] = x % 10 + '0', x /= 10;\n\t\twhile (t) pc(ch[t--]);\n\t\tpc(k);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y) {\n\t\tprint(x, ' '), print(y);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y, I z) {\n\t\tprint(x, ' '), print(y, ' '), print(z);\n\t}\n\ttemplate <class I>\n\tinline void printa(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) print(a[i], \" \\n\"[i==n]);\n\t}\n\tinline void printc(char c) {\n\t\tpc(c);\n\t}\n\tinline void prints(char *s, int n) {\n\t\tfor (int i = 1; i <= n; i++) pc(s[i]);\n\t\tpc('\\n');\n\t}\n\tinline void prints(string s) {\n\t\tint n = s.length();\n\t\twhile (t < n) pc(s[t++]);\n\t\tpc('\\n'), t = 0;\n\t}\n\tstruct Flush {\n\t\t~Flush() {\n\t\t\tflush();\n\t\t}\n\t} flusher;\n}\nusing io::rd;\nusing io::rda;\nusing io::rdc;\nusing io::rds;\nusing io::print;\nusing io::printa;\nusing io::printc;\nusing io::prints;\n\nconst int P = 1e9 + 7;\n\nstruct modint {\n\tint x;\n\tinline modint(int x = 0) : x(x) {}\n\tinline modint &operator = (int o) { return x = o, *this; }\n\tinline modint &operator += (modint o) { return (x += o.x) >= P && (x -= P), *this; }\n\tinline modint &operator -= (modint o) { return (x -= o.x) < 0 && (x += P), *this; }\n\tinline modint &operator *= (modint o) { return x = 1ll * x * o.x % P, *this; }\n\ttemplate <class I>\n\tinline modint &operator ^= (I b) {\n\t\tmodint a = *this, c;\n\t\tif (!~b) b = P - 2;\n\t\tc.x = 1 % P;\n\t\twhile (b) {\n\t\t\tif (b & 1) c *= a;\n\t\t\ta *= a, b >>= 1;\n\t\t}\n\t\treturn x = c.x, *this;\n\t}\n\tinline modint &operator /= (modint o) { return *this *= o ^ -1; }\n\tinline modint &operator += (int o) { return (x += o) >= P && (x -= P), *this; }\n\tinline modint &operator -= (int o) { return (x -= o) < 0 && (x += P), *this; }\n\tinline modint &operator *= (int o) { return x = 1ll * x * o % P, *this; }\n\tinline modint &operator /= (int o) { return *this *= (modint)o ^ -1; }\n\ttemplate <class I>\n\tinline friend modint operator + (modint a, I b) { return a += b; }\n\ttemplate <class I>\n\tinline friend modint operator - (modint a, I b) { return a -= b; }\n\ttemplate <class I>\n\tinline friend modint operator * (modint a, I b) { return a *= b; }\n\ttemplate <class I>\n\tinline friend modint operator ^ (modint a, I b) { return a ^= b; }\n\ttemplate <class I>\n\tinline friend modint operator / (modint a, I b) { return a /= b; }\n\tinline friend bool operator == (modint a, int b) { return a.x == b; }\n\tinline friend bool operator != (modint a, int b) { return a.x != b; }\n\tinline friend bool operator < (modint a, int b) { return a.x < b; }\n\tinline friend bool operator <= (modint a, int b) { return a.x <= b; }\n\tinline friend bool operator > (modint a, int b) { return a.x > b; }\n\tinline friend bool operator >= (modint a, int b) { return a.x >= b; }\n\tinline friend bool operator == (modint a, modint b) { return a.x == b.x; }\n\tinline friend bool operator != (modint a, modint b) { return a.x != b.x; }\n\tinline friend bool operator < (modint a, modint b) { return a.x < b.x; }\n\tinline friend bool operator <= (modint a, modint b) { return a.x <= b.x; }\n\tinline friend bool operator > (modint a, modint b) { return a.x > b.x; }\n\tinline friend bool operator >= (modint a, modint b) { return a.x >= b.x; }\n\tinline bool operator ! () { return !x; }\n\tinline modint operator - () { return x ? P - x : 0; }\n};\ninline void rd(modint &x) { rd(x.x); }\ninline void print(modint x, char k = '\\n') { print(x.x, k); }\n\n//const int NP = 1e6 + 7;\n//modint p[NP], v[NP], vp[NP];\n//inline void init(int n) {\n//  p[0] = v[0] = 1;\n//  for (int i = 1; i <= n; i++) p[i] = p[i-1] * i;\n//  vp[n] = 1 / p[n];\n//  for (int i = n; i; i--) v[i] = vp[i] * p[i-1], vp[i-1] = vp[i] * i;\n//}\n//inline modint binom(int n, int m) {\n//  return (m < 0 || n < m) ? 0 : p[n] * vp[m] * vp[n-m];\n//}\n\nconst int N = 1e5 + 7;\nint n, h[N], p[N], pl[N], pr[N], w[N];\n\nstruct DP {\n\tmodint a[2][2][2];\n\tinline DP() {\n\t\tfor (int i = 0; i < 2; i++)\n\t\t\tfor (int j = 0; j < 2; j++)\n\t\t\t\tfor (int k = 0; k < 2; k++)\n\t\t\t\t\ta[i][j][k] = 0;\n\t}\n\tinline friend DP operator + (DP a, DP b) {\n\t\tDP c;\n\t\tfor (int li = 0; li < 2; ++li)\n\t\t\tfor (int ri = 0; ri < 2; ++ri)\n\t\t\t\tfor (int lj = 0; lj < 2; ++lj)\n\t\t\t\t\tfor (int rj = 0; rj < 2; ++rj)\n\t\t\t\t\t\tfor (int lk = 0; lk < 2; ++lk)\n\t\t\t\t\t\t\tfor (int rk = 0; rk < 2; ++rk)\n\t\t\t\t\t\t\t\tc.a[li][rj][lk|rk|(lj==ri)] += a.a[li][lj][lk] * b.a[ri][rj][rk];\n\t\treturn c;\n\t}\n} f[N];\n\nvoid work(int o, int x) {\n\tif (w[o] == x) return;\n\tDP now;\n\tint t = (w[o] ^ x) & 1;\n\tmodint k = (modint)2 ^ (w[o] - x - 1);\n\tfor (int i = 0; i < 2; i++)\n\t\tfor (int j = 0; j < 2; j++)\n\t\t\tnow.a[i][j][1] = f[o].a[i^t][j^t][1],\n\t\t\tnow.a[i][j][0] = (f[o].a[i][j][0] + f[o].a[i^1][j^1][0]) * k;\n\tf[o] = now;\n}\n\nint main() {\n\trd(n), rda(h, n), iota(p + 1, p + n + 1, 1);\n\tsort(p + 1, p + n + 1, [&](int i, int j) { return h[i] > h[j]; });\n\tfor (int o = 1; o <= n; o++) {\n\t\tint i = p[o], L = i, R = i;\n\t\tDP now;\n\t\tnow.a[0][0][0] = now.a[1][1][0] = 1;\n\t\tif (pl[i-1]) L = pl[i-1], pr[L] = pl[i-1] = 0, work(L, h[i]), now = f[L] + now;\n\t\tif (pr[i+1]) R = pr[i+1], pr[i+1] = pl[R] = 0, work(i + 1, h[i]), now = f[i+1] + now;\n\t\tf[L] = now, pr[L] = R, pl[R] = L, w[L] = h[i];\n\t}\n\twork(1, 1);\n\tmodint ans;\n\tfor (int i = 0; i < 2; i++)\n\t\tfor (int j = 0; j < 2; j++)\n\t\t\tfor (int k = 0; k < 2; k++)\n\t\t\t\tans += f[1].a[i][j][k];\n\tprint(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <fstream>\n#include <iostream>\n#include <algorithm>\n#include <bitset>\n#include <array>\n#include <vector>\n#include <queue>\n#include <set>\n#include <cmath> // 変数名にy1が使えなくなるかも…。\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <string>\n\ntypedef __int128_t int128_t;\nstd::istream &operator>>(std::istream& input, int128_t& value) { // int128_tの入力。入力が64bitに収まる前提。\n    long long tmp; input >> tmp; value = tmp;\n    return input;\n}\nstd::ostream &operator<<(std::ostream& output, const int128_t value) { // int128_tの出力。出力が64bitに収まる前提。\n    output << (long long)value;\n    return output;\n}\n\nint128_t cal_mod(const int128_t n, const int128_t mod) {\n    // n % modを計算する。ただしmod <= 0 ならば何もしない。nが負の場合、正にして補正する。\n    if (mod <= 0) {\n        return n;\n    } else if (0 <= n) {\n        return n % mod;\n    } else {\n        int128_t tmp = (-n) / mod + 1;\n        return (n + tmp * mod) % mod;\n    }\n}\n\nint128_t pow_mod(int128_t x, int128_t n, const int128_t mod) {\n    // 累乗の計算。mod <= 0ならば余りの計算は行わない。\n    int128_t ret = 1;\n    while (n > 0) {\n        if (n & 1) { ret = cal_mod(ret * x, mod); }\n        x = cal_mod(x * x, mod);\n        n = (n >> 1);\n    }\n    return ret;\n}\n\nconst int MOD = 1e9 + 7;\nconst int MAX_H = 1e9 + 7;\nconst int MAX_N = 110;\nint N;\nint128_t h[MAX_N];\n\nint128_t s[MAX_N]; // s[i]:i番目に低い山（高さ2以上）の高さ。\nstd::map<int128_t, int> mp; // 2以上の高さに対して、何番目に低いか。\n\nint128_t dp[MAX_N][MAX_N] = {};\n// dp[i][j] : i番目の列まで塗終わり、その列で最初に現れる連続同色がs[j]の高さに収まる(s[j-1]には収まらない)塗り方の数。\n// dp[i][0] は、連続同色が現れない塗り方。\n\nint128_t calc_sub(int128_t h1, int128_t h2) {\n    // h1まで交互に塗った1つの塗り方に対して、h2までに連続塗りを含む塗り方がいくつあるか。\n    return pow_mod(2, h2 - h1, MOD) - 1;\n}\n\nint main(int argc, char **argv) {\n    std::cin >> N;\n    \n    for (int i = 1; i <= N; i++) {\n        std::cin >> h[i];\n    }\n\n    for (int i = 1; i <= N; i++) {\n        if (1 < h[i]) {\n            mp[h[i]] = 1;\n        }\n    }\n    int cnt = 1;\n    for (auto itr = mp.begin(); itr != mp.end(); ++itr) {\n        mp[itr->first] = cnt;\n        s[cnt] = itr->first;\n        cnt++;\n    }\n    s[0] = 1;\n    s[cnt] = MAX_H;\n    dp[0][0] = 1;\n\n    //std::cout << \"check:\" << s[0] << \" \" << s[1] << \" \" << s[2] << \" \" << s[3] << std::endl;\n\n    for (int i = 1; i <= N; i++) {\n        if (h[i] == 1) {\n            for (int j = 0; j < cnt; j++) {\n                dp[i][0] = (dp[i][0] + dp[i-1][j] * 2) % MOD;\n            }\n        } else if (i == 1 || h[i-1] == 1) {\n            dp[i][0] = dp[i-1][0] * 2;\n            for (int j = 1; s[j] <= h[i]; j++) {\n                dp[i][j] = (dp[i-1][0] * 2 * calc_sub(s[j-1], s[j]) * pow_mod(2, h[i] - s[j], MOD)) % MOD;\n            }\n        } else {\n            dp[i][0] = dp[i-1][0] * 2;\n            if (h[i] <= h[i-1]) {\n                for (int j = 1; s[j] <= h[i-1]; j++) {\n                    if (s[j] <= h[i]) {\n                        dp[i][j] = dp[i-1][j];\n                    } else {\n                        dp[i][0] = (dp[i][0] + dp[i-1][j] * 2) % MOD;\n                    }\n                }\n            } else {\n                for (int j = 1; s[j] <= h[i]; j++) {\n                    if (s[j] <= h[i-1]) {\n                        dp[i][j] = (dp[i-1][j] * pow_mod(2, h[i] - h[i-1], MOD)) % MOD;\n                    } else {\n                        dp[i][j] = (dp[i-1][0] * 2 * calc_sub(s[j-1], s[j]) * pow_mod(2, h[i] - s[j], MOD)) % MOD;\n                    }\n                }\n            }\n        }\n        //std::cout << \"dp:\" << dp[i][0] << \" \" << dp[i][1] << \" \" << dp[i][2] << std::endl;\n    }\n\n    int128_t ret = 0;\n    for (int j = 0; s[j] <= h[N]; j++) {\n        ret = (ret + dp[N][j]) % MOD;\n    }\n    std::cout << ret << std::endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll; \nconst ll MOD=1e9+7;\nll mypow(int x){\n\tll res=1,ans=2;\n\twhile (x>0){\n\t\tif (x%2==1){\n\t\t\tx--;\n\t\t\tres*=ans;\n\t\t\tres%=MOD; \n\t\t\tcontinue;\n\t\t}\n\t\tans*=ans;\n\t\tans%=MOD;\n\t\tx/=2;\n\t}\n\treturn res;\n}\nint n,a[103];\nll dp[103][103],ans=0;\nvector<int>v;\nmap <int,int> vis;\nmap <int,int> mp;\nint main(){\n\tcin>>n;\n\tfor (int i=1;i<=n;i++){\n\t\tcin>>a[i];\n\t\tif (vis[a[i]]) continue;\n\t\tv.push_back(a[i]);\n\t\tvis[a[i]]=1;\n\t}\n\tv.push_back(0);\n\tsort (v.begin(),v.end());\n\tfor (int i=0;i<v.size();i++)\n\t\tmp[v[i]]=i;\n\tdp[1][0]=(mypow(v[1]-v[0])-2)%MOD*mypow(a[1]-v[1]);\n\tfor (int i=1;i<mp[a[1]];i++) dp[1][i]=2*(mypow(v[i+1]-v[i])-1)%MOD*mypow(a[1]-v[i+1]);\n\tdp[1][mp[a[1]]]=2;\n\tfor (int i=2;i<=n;i++){\n\t\tif (a[i-1]>=a[i]){\n\t\t\tfor (int j=0;j<=mp[a[i]];j++) dp[i][j]=dp[i-1][j];\n\t\t\tfor (int j=mp[a[i]]+1;j<=mp[a[i-1]];j++) dp[i][mp[a[i]]]+=dp[i-1][j];\n\t\t\tdp[i][mp[a[i]]]=dp[i][mp[a[i]]]*2%MOD;\n\t\t}else{\n\t\t\tfor (int j=0;j<mp[a[i-1]];j++) dp[i][j]=dp[i-1][j]*mypow(a[i]-a[i-1])%MOD;\n\t\t\tdp[i][mp[a[i-1]]]=2*dp[i-1][mp[a[i-1]]]*(mypow(v[mp[a[i-1]]+1]-a[i-1])-1)%MOD*mypow(a[i]-v[mp[a[i-1]]+1])%MOD;\n\t\t\tfor (int j=mp[a[i-1]]+1;j<mp[a[i]];j++) dp[i][j]=dp[i-1][mp[a[i-1]]]*2%MOD*(mypow(v[j+1]-v[j])-1)%MOD*mypow(a[i]-v[j+1])%MOD;\n\t\t\tdp[i][mp[a[i]]]=dp[i-1][mp[a[i-1]]]*2%MOD;\n\t\t}\n\t}\n\tfor (int i=0;i<=mp[a[n]];i++) ans+=dp[n][i];\n\tcout<<ans%MOD;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\n#define fi first\n#define se second\nconst int maxn=105;\nconst int mod=1e9+7;\nconst int inf=0x3f3f3f3f;\nint n,h[maxn];\ninline ll fpow(ll a,ll b)\n{\n\tll ret=1;\n\tfor(;b;b>>=1,a=a*a%mod)\n\t\tif(b&1) ret=ret*a%mod;\n\treturn ret;\n}\ninline pll solve(int l,int r,int k)\n{\n\tint mn=inf,cnt=0;\n\tfor(int i=l;i<=r;i++)\n\t\tif(h[i]<mn) mn=h[i],cnt=1;\n\t\telse if(h[i]==mn) cnt++;\n\tif(cnt==r-l+1) return pll(fpow(2,r-l+1)-2,fpow(2,mn-k));\n\tint last=0; ll s0=1,s1=1; pll ret=pll(0,0);\n\tfor(int i=l;i<=r+1;i++)\n\t\tif(!last && h[i]>mn) last=i;\n\t\telse if((i>r || h[i]==mn) && last)\n\t\t{\n\t\t\tpll tmp=solve(last,i-1,mn);\n\t\t\t(s0*=(tmp.fi+2*tmp.se))%=mod;\n\t\t\t(s1*=tmp.se)%=mod;\n\t\t\tlast=0;\n\t\t}\n\t(s0-=s1)%=mod;\n\tret.fi=(s0*fpow(2,cnt)+s1*(fpow(2,cnt)-2))%mod;\n\tret.se=s1*fpow(2,mn-k)%mod;\n\treturn ret;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&h[i]);\n\tll ans=1;\n\tfor(int i=1;i<=n;i++)\n\t\tif(h[i]>h[i-1] && h[i]>h[i+1])\n\t\t\t(ans*=fpow(2,h[i]-max(h[i-1],h[i+1])))%=mod,h[i]=max(h[i-1],h[i+1]);\n\tpll ret=solve(1,n,0);\n\tprintf(\"%lld\\n\",(ans*(ret.fi+ret.se)%mod+mod)%mod);\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pw(x) (1LL << (x))\n#define db(x) cerr << #x << \" = \" << x << endl\n#define db2(x, y) cerr << \"(\" << #x << \", \" << #y << \") = (\" << x << \", \" << y << \")\" << endl\n\nusing namespace std;\ntypedef long long ll;\ntypedef double dbl;\nconst int INF = 1.01e9;\nconst int MOD = (int)1e9 + 7;\n\nvoid add(int &x, ll y) {\n    x = (x + y) % MOD;\n}\n\nint bin(int a, ll n) {\n    int res = 1;\n    while (n) {\n        if (n & 1) res = 1LL * res * a % MOD;\n        a = 1LL * a * a % MOD;\n        n >>= 1;\n    }\n    return res;\n}\n\nint inv(int x) {\n    return bin(x, MOD - 2);\n}\n\nint main() {\n#ifdef HOME\n    assert(freopen(\"in\", \"r\", stdin));\n#endif\n\n    int n;\n    while (cin >> n) {\n        vector<int> a(n);\n        for (int i = 0; i < n; i++) cin >> a[i];\n\n        a.insert(a.begin(), 1);\n        a.push_back(0);\n        n += 2;\n\n        vector<int> dp(n);\n        dp[0] = 1;\n        for (int i = 0; i < n - 1; i++) {\n            add(dp[i + 1], dp[i]);\n            if (i + 1 < n - 1) add(dp[i + 1], dp[i]);\n            if (a[i + 1] > a[i]) {\n                int mn = a[i + 1];\n                for (int j = i + 2; j < n; j++) {\n                    if (a[j] < mn) {\n                        int y = max(a[i], a[j]);\n\n                        ll sum = 0;\n                        //sum += a[i + 1] - y;\n                        for (int k = i + 1; k < j; k++) {\n                            sum += max(0, a[k] - max(a[k - 1], mn - 1));\n                        }\n\n                        //int N = mn - y;\n                        //int K = j - i - 1;\n                        //cout << N << \" \" << K << endl;\n                        //int cur = 2LL * bin(2, sum) * (bin(2, 1LL * K * N) - 1 + MOD) % MOD * inv(bin(2, K) - 1 + MOD) % MOD;\n                        int N = mn - y;\n                        int K = 1;\n                        int cur = 1LL * bin(2, sum) * (bin(2, N) - 1 + MOD) % MOD;\n                        cur = 1LL * cur * dp[i] % MOD;\n                        add(dp[j], cur);\n                        if (j < n - 1) add(dp[j], cur);\n\n                        mn = a[j];\n                        if (mn <= a[i]) break;\n                    }\n                }\n            }\n        }\n        cout << dp[n - 1] << endl;\n    }\n\n\n#ifdef HOME\n    cerr << \"time = \" << (clock() * 1. / CLOCKS_PER_SEC) << \"\\n\";\n#endif\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#define maxn 105\n#define R register\n#define INF 0x3f3f3f3f\nusing namespace std;\ntypedef long long lxl;\nconst lxl mod = 1e9+7;\n\ninline lxl read()\n{\n\tlxl x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9') {if(ch=='-') f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9') {x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\ninline lxl fmi(lxl a,lxl b)\n{\n\tlxl ans=1;\n\twhile(b>0)\n\t{\n\t\tif(b&1) ans=(ans*a)%mod;\n\t\ta=(a*a)%mod;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\n\nlxl n,h[maxn],H[maxn],W[maxn],X[maxn],Rm[maxn],tot;\nint d[maxn][20],lg[maxn];\nstd::vector<int> ch[maxn];\n\ninline void init()\n{\n\tlg[0]=-1;\n\tfor(R int i=1;i<=n;++i)\n\t\tlg[i]=lg[i>>1]+1;\n\tfor(R int i=1;i<=n;++i)\n\t\td[i][0]=h[i];\n\tfor(R int j=1;j<=15;++j)\n\t\tfor(R int i=1;i+(1<<(j-1))<=n;++i)\n\t\t\td[i][j]=min(d[i][j-1],d[i+(1<<(j-1))][j-1]);\n}\n\ninline int query(int l,int r)\n{\n\tint k=lg[r-l+1];\n\treturn min(d[l][k],d[r-(1<<k)+1][k]);\n}\n\ninline int build(int l,int r,int fa)\n{\n\tif(l>r) return 0;\n\tint p=++tot;\n\tint x=X[p]=query(l,r);\n\tH[p]=X[p]-X[fa];\n\tW[p]=r-l+1;\n\tint tl=l-1,tr=l-1;\n\tfor(R int i=l;i<=r;++i)\n\t{\n\t\tif(h[i]==x&&tl<tr)\n\t\t\tch[p].push_back(build(tl+1,tr,p));\n\t\tif(h[i]==x) tl=i,++Rm[p];\n\t\telse tr=i;\n\t}\n\tif(tl<tr) ch[p].push_back(build(tl+1,tr,p));\n\treturn p;\n}\n\nlxl f[maxn][2];\n\ninline void dp(int u)\n{\n\tlxl res1=1,res2=1;\n\tfor (std::vector<int>::iterator it = ch[u].begin(); it != ch[u].end(); ++it)\n\t{\n\t\tdp(*it);\n\t\tres1=(res1*f[*it][0])%mod;\n\t\tres2=(res2*(f[*it][0]*2+f[*it][1]))%mod;\n\t}\n\tf[u][0]=(fmi(2,H[u])*res1)%mod;\n\tf[u][1]=(fmi(2,Rm[u])*res2+(mod-2*res1)%mod)%mod;\n}\n\nint main()\n{\n\tn=read();\n\tfor(R int i=1;i<=n;++i)\n\t\th[i]=read();\n\tinit();\n\tint rt=build(1,n,0);\n\tdp(rt);\n\tprintf(\"%lld\",f[rt][1]+f[rt][0]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\ntemplate<typename T> using gpp_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T, typename L> using gpp_map = tree<T, L, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T> using gpp_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;*/\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl;\n#define mdebug(m) cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;}\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\nconst int mod = 1000000007;\n//const int mod = 998244353;\n//#define Add(x, y) x = (x + (y)) % mod\n//#define Mult(x, y) x = (x * (y)) % mod\n\ntemplate<long long MOD>\nstruct ModInt{\n\n    using ll = long long;\n    ll val;\n\n    void setval(ll v) { val = v % MOD; };\n    ModInt(): val(0) {}\n    ModInt(ll v) { setval(v); };\n\n    ModInt operator+(const ModInt &x) const { return ModInt(val + x.val); }\n    ModInt operator-(const ModInt &x) const { return ModInt(val - x.val + MOD); }\n    ModInt operator*(const ModInt &x) const { return ModInt(val * x.val); }\n    ModInt operator/(const ModInt &x) const { return *this * x.inv(); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt operator+=(const ModInt &x) { return *this = *this + x; }\n    ModInt operator-=(const ModInt &x) { return *this = *this - x; }\n    ModInt operator*=(const ModInt &x) { return *this = *this * x; }\n    ModInt operator/=(const ModInt &x) { return *this = *this / x; }\n\n    friend ostream& operator<<(ostream &os, const ModInt &x) { os << x.val; return os; }\n    friend istream& operator>>(istream &is, ModInt &x) { is >> x.val; x.val = (x.val % MOD + MOD) % MOD; return is; }\n\n    ModInt pow(ll n) const {\n        ModInt a = 1;\n        if(n == 0) return a;\n        int i0 = 64 - __builtin_clzll(n);\n        for(int i = i0 - 1; i >= 0; i--){\n            a = a * a;\n            if((n >> i) & 1) a *= (*this); \n        }\n        return a;\n    }\n    ModInt inv() const { return this->pow(MOD - 2); }\n};\n\nusing mint = ModInt<mod>; mint pow(mint x, long long n) { return x.pow(n); }\n//using mint = double; //for debug\nusing mvec = vector<mint>;\nusing mmat = vector<mvec>;\n\nstruct Combination{\n\n    vector<mint> fact, invfact;\n\n    Combination(int N){\n        fact = vector<mint>({mint(1)});\n        invfact = vector<mint>({mint(1)});\n        fact_initialize(N);\n    }\n\n    void fact_initialize(int N){\n        int i0 = fact.size();\n        if(i0 >= N + 1) return;\n        fact.resize(N + 1);\n        invfact.resize(N + 1);\n        for(int i = i0; i <= N; i++) fact[i] = fact[i - 1] * i;\n        invfact[N] = (mint)1 / fact[N];\n        for(int i = N - 1; i >= i0; i--) invfact[i] = invfact[i + 1] * (i + 1); \n    }\n\n    mint nCr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[r] * invfact[n - r];\n    }\n\n    mint nPr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[n - r];\n    }\n\n};\n\nstruct edge{int to, cost, id;};\n\nclass Graph\n{\npublic:\n    int N;\n    vector<vector<edge>> G;\n    pairs sz;\n    mmat dp;\n\n    Graph(int N): N(N){\n        G = vector<vector<edge>>(N, vector<edge>(0));\n        dp = mmat(N, mvec(2, 0));\n    }\n\n    void add_Directed_edge(int from, int to, int cost = 1, int id = 0){\n        G[from].push_back(edge({to, cost, id}));\n    }\n\n    void add_Undirected_edge(int v1, int v2, int cost = 1, int id = 0){\n        add_Directed_edge(v1, v2, cost, id);\n        add_Directed_edge(v2, v1, cost, id);\n    }\n\n    void dfs(int v){\n        if(SZ(G[v]) == 0){\n            dp[v][0] = pow((mint)2, sz[v].s);\n            dp[v][1] = pow((mint)2, sz[v].f) - 2;\n        }else{\n            mint x0 = 1, x1 = 1;\n            int w = sz[v].f;\n            for(auto e: G[v]){\n                dfs(e.to);\n                x0 *= dp[e.to][0];\n                x1 *= dp[e.to][0] * 2 + dp[e.to][1];\n                w -= sz[e.to].f;\n            }\n            x0 *= 2;\n            dp[v][0] = x0 * pow((mint)2, sz[v].s - 1);\n            dp[v][1] = x1 * pow((mint)2, w) - x0;\n        }\n    }\n\n};\n\nvoid maketree(vec &h, int l, int r, int t, int p, pairs &sz, pairs &es){\n    int M = INF;\n    FOR(i, l, r){\n        Min(M, h[i]);\n    }\n    int v = SZ(sz);\n    sz.pb(Pii(r - l, M - t));\n    if(p != -1) es.pb(Pii(p, v));\n    \n    int l0 = -1;\n    FOR(i, l, r + 1){\n        if(i == r || h[i] == M){\n            if(l0 >= 0){\n                maketree(h, l0, i, M, v, sz, es);\n                l0 = -1;\n            }\n        }else{\n            if(l0 == -1) l0 = i;\n        }\n    }\n}\n\nsigned main(){\n\n    int N; cin >> N;\n    vec h(N); cin >> h;\n\n    pairs sz, es;\n    maketree(h, 0, N, 0, -1, sz, es);\n    /*\n    REP(i, SZ(sz)){\n        debug(i);\n        cout << sz[i].f << \",\" << sz[i].s << endl;\n    }\n    debug(SZ(es));\n    for(Pii q: es) cout << q.f << \",\" << q.s << endl;\n    */\n    Graph G(SZ(sz));\n    for(Pii q: es) G.add_Directed_edge(q.f, q.s);\n    G.sz = sz;\n    G.dfs(0);\n    mint ans = G.dp[0][0] + G.dp[0][1];\n    Out(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\nint dp[103][103] , h[103] , lsh[103] , N , cl;\n\nint poww(long long a , int b){\n\tint times = 1;\n\twhile(b){\n\t\tif(b & 1) times = times * a % MOD;\n\t\ta = a * a % MOD; b >>= 1;\n\t}\n\treturn times;\n}\n\nint main(){\n\tlsh[++cl] = 1; cin >> N;\n\tfor(int i = 1 ; i <= N ; ++i){cin >> h[i]; lsh[++cl] = h[i];}\n\tsort(lsh + 1 , lsh + cl + 1); cl = unique(lsh + 1 , lsh + cl + 1) - lsh - 1;\n\tfor(int i = 1 ; i <= N ; ++i) h[i] = lower_bound(lsh + 1 , lsh + cl + 1 , h[i]) - lsh;\n\tfor(int i = 1 ; i <= h[1] ; ++i) dp[1][i] = poww(2 , 1 + lsh[h[1]] - lsh[i]);\n\tfor(int i = 1 ; i <= h[1] ; ++i) dp[1][i] = (dp[1][i] - dp[1][i + 1]) % MOD;\n\tfor(int i = 1 ; i < N ; ++i)\n\t\tif(h[i] >= h[i + 1])\n\t\t\tfor(int j = 1 ; j <= h[i] ; ++j)\n\t\t\t\tdp[i + 1][min(h[i + 1] , j)] = (dp[i + 1][min(h[i + 1] , j)] + 1ll * dp[i][j] * (1 + (j >= h[i + 1]))) % MOD;\n\t\telse{\n\t\t\tint pw = poww(2 , lsh[h[i + 1]] - lsh[h[i]]);\n\t\t\tfor(int j = 1 ; j < h[i] ; ++j)\n\t\t\t\tdp[i + 1][j] = 1ll * pw * dp[i][j] % MOD;\n\t\t\tfor(int j = h[i] ; j <= h[i + 1] ; ++j)\n\t\t\t\tdp[i + 1][j] = 2ll * dp[i][h[i]] * poww(2 , lsh[h[i + 1]] - lsh[j]) % MOD;\n\t\t\tfor(int j = h[i] ; j <= h[i + 1] ; ++j)\n\t\t\t\tdp[i + 1][j] = (dp[i + 1][j] - dp[i + 1][j + 1] + MOD) % MOD;\n\t\t}\n\tint sum = 0;\n\tfor(int i = 1 ; i <= cl ; ++i) sum = (sum + dp[N][i]) % MOD;\n\tcout << sum; return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst long long MOD=1e9+7;\n\ntemplate<uint_fast64_t Modulus> class modint{\n    using u64=uint_fast64_t;\n    public:\n    u64 a;\n    constexpr modint(const u64 x=0) noexcept:a(((x%Modulus)+Modulus)%Modulus){}\n    constexpr u64 &value() noexcept{return a;}\n    constexpr const u64 &value() const noexcept{return a;}\n    constexpr modint &operator+=(const modint &rhs) noexcept{\n        a+=rhs.a;\n        if (a>=Modulus) a-=Modulus;\n        return *this;\n    }\n    constexpr modint operator+(const modint &rhs) const noexcept{\n        return modint(*this)+=rhs;\n    }\n    constexpr modint &operator++() noexcept{\n        return ++a,*this;\n    }\n    constexpr modint operator++(int) noexcept{\n        modint t=*this; return ++a,t;\n    }\n    constexpr modint &operator-=(const modint &rhs) noexcept{\n        if (a<rhs.a) a+=Modulus;\n        a-=rhs.a;\n        return *this;\n    }\n    constexpr modint operator-(const modint &rhs) const noexcept{\n        return modint(*this)-=rhs;\n    }\n    constexpr modint &operator--() noexcept{\n        return --a,*this;\n    }\n    constexpr modint operator--(int) noexcept{\n        modint t=*this; return --a,t;\n    }\n    constexpr modint &operator*=(const modint &rhs) noexcept{\n        a=a*rhs.a%Modulus;\n        return *this;\n    }\n    constexpr modint operator*(const modint &rhs) const noexcept{\n        return modint(*this)*=rhs;\n    }\n    constexpr modint &operator/=(modint rhs) noexcept{\n        u64 exp=Modulus-2;\n        while(exp){\n            if (exp&1) *this*=rhs;\n            rhs*=rhs; exp>>=1;\n        }\n        return *this;\n    }\n    constexpr modint operator/(const modint &rhs) const noexcept{\n        return modint(*this)/=rhs;\n    }\n    constexpr modint operator-() const noexcept{\n        return modint(Modulus-a);\n    }\n    constexpr bool operator==(const modint &rhs) const noexcept{\n        return a==rhs.a;\n    }\n    constexpr bool operator!=(const modint &rhs) const noexcept{\n        return a!=rhs.a;\n    }\n    constexpr bool operator!() const noexcept{return !a;}\n    friend constexpr modint pow(modint rhs,long long exp) noexcept{\n        modint res{1};\n        while(exp){\n            if (exp&1) res*=rhs;\n            rhs*=rhs; exp>>=1;\n        }\n        return res;\n    }\n    template<class T> friend constexpr modint operator+(T x,modint y) noexcept{\n        return modint(x)+y;\n    }\n    template<class T> friend constexpr modint operator-(T x,modint y) noexcept{\n        return modint(x)-y;\n    }\n    template<class T> friend constexpr modint operator*(T x,modint y) noexcept{\n        return modint(x)*y;\n    }\n    template<class T> friend constexpr modint operator/(T x,modint y) noexcept{\n        return modint(x)/y;\n    }\n    friend ostream &operator<<(ostream &s,const modint &rhs) noexcept{\n        return s << rhs.a;\n    }\n    friend istream &operator>>(istream &s,modint &rhs) noexcept{\n        u64 a; rhs=modint{(s >> a,a)}; return s;\n    }\n};\n\nusing mint=modint<MOD>;\n\ntemplate<class K>\nstruct Matrix{\n    vector<vector<K>> dat;\n    Matrix(size_t r,size_t c):dat(r,vector<K>(c,K())){}\n    Matrix(size_t n):dat(n,vector<K>(n,K())){}\n    Matrix(vector<vector<K>> dat):dat(dat){}\n    size_t size() const{return dat.size();}\n    vector<K> &operator[](int i){return dat[i];}\n    const vector<K> &operator[](int i) const{return dat[i];}\n    static Matrix I(size_t n){\n        Matrix res(n);\n        for (int i=0;i<n;++i) res[i][i]=K(1);\n        return res;\n    }\n    Matrix &operator+=(const Matrix &B){\n        for (int i=0;i<dat.size();++i)\n            for (int j=0;j<dat[0].size();++j)\n                (*this)[i][j]+=B[i][j];\n        return (*this);\n    }\n    Matrix operator+(const Matrix &B) const{\n        return Matrix(*this)+=B;\n    }\n    Matrix &operator-=(const Matrix &B){\n        for (int i=0;i<dat.size();++i)\n            for (int j=0;j<dat[0].size();++j)\n                (*this)[i][j]-=B[i][j];\n        return (*this);\n    }\n    Matrix operator-(const Matrix &B) const{\n        return Matrix(*this)-=B;\n    }\n    Matrix &operator*=(const Matrix &B){\n        vector<vector<K>> res(dat.size(),vector<K>(B[0].size(),K()));\n        for (int i=0;i<dat.size();++i)\n            for (int j=0;j<B[0].size();++j)\n                for (int k=0;k<B.size();++k)\n                    res[i][j]+=(*this)[i][k]*B[k][j];\n        dat.swap(res);\n        return (*this);\n    }\n    Matrix operator*(const Matrix &B) const{\n        return Matrix(*this)*=B;\n    }\n    Matrix &operator^=(long long k){\n        Matrix res=Matrix::I(size());\n        while(k){\n            if (k&1LL) res*=*this;\n            *this*=*this; k>>=1LL;\n        }\n        dat.swap(res.dat);\n        return (*this);\n    }\n    Matrix operator^(long long k) const{\n        return Matrix(*this)^=k;\n    }\n    static Matrix Gauss_Jordan(const Matrix &A,const Matrix &B){\n        int n=A.size(),l=B[0].size();\n        Matrix C(n,n+l);\n        for (int i=0;i<n;++i){\n            for (int j=0;j<n;++j)\n                C[i][j]=A[i][j];\n            for (int j=0;j<l;++j)\n                C[i][j+n]=B[i][j];\n        }\n        for (int i=0;i<n;++i){\n            int p=i;\n            for (int j=i;j<n;++j){\n                if (abs(C[p][i])<abs(C[j][i])) p=j;\n            }\n            swap(C[i],C[p]);\n            if (abs(C[i][i])<1e-9) return Matrix(0,0);\n            for (int j=i+1;j<n+l;++j) C[i][j]/=C[i][i];\n            for (int j=0;j<n;++j){\n                if (i!=j) for (int k=i+1;k<n+l;++k){\n                    C[j][k]-=C[j][i]*C[i][k];\n                }\n            }\n        }\n        Matrix res(n,l);\n        for (int i=0;i<n;++i)\n            for (int j=0;j<n;++j)\n                res[i][j]=C[i][j+n];\n        return res;\n    }\n    Matrix inv() const{\n        Matrix res=I(size());\n        return Gauss_Jordan(*this,res);\n    }\n    K determinant() const{\n        Matrix A(dat);\n        K res(1);\n        int n=size();\n        for (int i=0;i<n;++i){\n            int p=i;\n            for (int j=i;j<n;++j){\n                if (abs(A[p][i])<abs(A[j][i])) p=j;\n            }\n            if (i!=p) swap(A[i],A[p]),res=-res;\n            if (abs(A[i][i])<1e-9) return K(0);\n            res*=A[i][i];\n            for (int j=i+1;j<n;++j) A[i][j]/=A[i][i];\n            for (int j=i+1;j<n;++j)\n                for (int k=i+1;k<n;++k)\n                    A[j][k]-=A[j][i]*A[i][k];\n        }\n        return res;\n    }\n    //sum_{k=0}^{n-1} x^k\n    static K geometric_sum(K x,long long n){\n        Matrix A(2);\n        A[0][0]=x; A[0][1]=0;\n        A[1][0]=1; A[1][1]=1;\n        return (A^n)[1][0];\n    }\n    //sum_{k=0}^{n-1} A^k\n    Matrix powsum(long long k) const{\n        int n=size();\n        Matrix B(n<<1),res(n);\n        for (int i=0;i<n;++i){\n            for (int j=0;j<n;++j)\n                B[i][j]=dat[i][j];\n            B[i+n][i]=B[i+n][i+n]=K(1);\n        }\n        B^=k;\n        for (int i=0;i<n;++i)\n            for (int j=0;j<n;++j)\n                res[i][j]=B[i+n][j];\n        return res;\n    }\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N; cin >> N;\n    vector<ll> h(N+2);\n    h[0]=h[N+1]=0;\n    for (int i=1;i<=N;++i) cin >> h[i];\n    vector<mint> dp(N+2,0);\n    dp[0]=1;\n    for (int i=1;i<=N;++i){\n        dp[i]+=dp[i-1]*2;\n        if (h[i]<=h[i-1]) continue;\n        ll Min=h[i],sum=0; mint pre=0;\n        for (int j=i+1;j<=N+1;++j){\n            sum+=max(0LL,h[j]-h[j-1]);\n            if (h[j]>=Min) continue;\n            ll other=max(h[j],h[i-1]);\n            mint rui=Matrix<mint>::geometric_sum((mint)2,h[i]-other-(other==0?1:0));\n            dp[j]+=dp[i]*(rui-pre)*pow((mint)2,sum)*(h[j]>0?2:1);\n            Min=h[j]; pre=rui;\n            if (h[j]<=h[i-1]||h[j]<=1) break;\n        }\n    }\n    cout << dp[N]+dp[N+1] << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cstring>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define TRACE(x) cout << #x << \" = \" << x << endl\n#define _ << \" _ \" <<\n\ntypedef long long llint;\n\nconst int mod = 1e9 + 7;\n\ninline int add(int a, int b) {\n  return a+b >= mod ? a+b-mod : a+b;\n}\n\ninline int sub(int a, int b) {\n  return a >= b ? a-b : a-b+mod;\n}\n\ninline int mul(int a, int b) {\n  return llint(a)*b % mod;\n}\n\nint powmod(int a, llint b) {\n  if (b == 0) return 1;\n  if (b&1) return mul(a, powmod(a, b-1));\n  return powmod(mul(a, a), b/2);\n}\n\nconst int MAX = 110;\n\nint h[MAX], pw[MAX];\n\npair<int, int> solve(int a, int b, int s) {\n  if (b - a == 1) {\n    return {powmod(2, h[a] - s - 1), 0};\n  }\n\n  assert(b - a > 1);\n  int m = *min_element(h + a, h + b);\n\n  vector<pair<int, int>> v;\n  int i = a;\n  while (i < b) {\n    int j = i;\n    while (j < b && (h[i] == m) == (h[j] == m)) j++;\n    v.push_back({i, j});\n    i = j;\n  }\n\n  int f0 = 0, f1 = 1;\n  bool first = true;\n  for (auto& p: v) {\n    int x = p.first, y = p.second;\n    if (h[x] != m) {\n      if (y - x > 1) {\n        auto g = solve(x, y, m);\n        if (first) {\n          f1 = mul(2, g.first);\n          f0 = g.second;\n        } else {\n          f0 = mul(f0, add(mul(4, g.first), g.second));\n          f0 = add(f0, mul(mul(2, f1), mul(2, g.first)));\n          f0 = add(f0, mul(mul(2, f1), g.second));\n          f1 = mul(f1, mul(2, g.first));\n        }\n      } else {\n        if (first) {\n          f0 = 0;\n          f1 = powmod(2, h[x] - m);\n        } else {\n          f0 = mul(f0, 2);\n          f0 = add(f0, mul(2, f1));\n          f0 = mul(f0, powmod(2, h[x] - m));\n          f1 = mul(f1, powmod(2, h[x] - m));\n        }\n      }\n    } else {\n      if (first) {\n        f0 = sub(pw[y - x], 2);\n        f1 = 1;\n      } else {\n        f0 = mul(f0, pw[y - x]);\n        f0 = add(f0, mul(mul(2, f1), sub(pw[y - x], 1)));\n      }\n    }\n    first = false;\n  }\n\n  int good_ways = powmod(2, m - s - 1);\n\n  f1 = mul(f1, good_ways);\n\n  return {f1, f0};\n}\n\nint main(void) {\n  int N;\n  scanf(\"%d\", &N);\n  REP(i, N) scanf(\"%d\", &h[i]);\n\n  pw[0] = 1;\n  REP(i, N) pw[i + 1] = mul(pw[i], 2);\n\n  auto g = solve(0, N, 0);\n\n  int ret = add(mul(2, g.first), g.second);\n  printf(\"%d\\n\", ret);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N = 105;\nconst int MOD = 1000000007;\n\nint n,dp[N][N],h[N],w[N],m;\n\nint pow_(int x,int y) {///快速幂求 x的y次方\n    int ans = 1;\n    if(y > 0) {\n        while(y) {\n            if(y % 2)ans = (LL)ans * x % MOD;\n            x = (LL)x * x % MOD;\n            y /= 2;\n        }\n    }\n    return ans;\n}\n\nint main() {\n    scanf(\"%d\",&n);\n    for(int i = 1;i <= n;i ++) {\n        scanf(\"%d\",&h[i]);\n        w[++ m] = h[i];\n    }\n    sort(w + 1,w + m + 1);///高度排序\n    m = unique(w + 1,w + m + 1) - w - 1;///离散化 m是离散化后的长度\n    for(int i = 1;i <= n;i ++) {\n        h[i] = lower_bound(w + 1,w + m + 1,h[i]) - w;\n    }\n    dp[0][0]=1;\n    for(int i = 1;i <= n;i ++) {\n        for(int j = h[i] + 1;j <= h[i - 1];j ++)\n            (dp[i][0] += dp[i - 1][j] * 2 % MOD) %= MOD;\n        (dp[i][0] += dp[i - 1][0] * 2 % MOD) %= MOD;///交叉或者不交叉\n        for(int j = 1;j <= h[i];j ++) {\n            dp[i][j]=(LL)dp[i - 1][j] * pow_(2,w[h[i]] - w[h[i-1]]) % MOD;\n            if(h[i - 1] >= j)continue;///如果是高度不超过前一列的位置 量已经确定了\n            if(j > 1)(dp[i][j] += (LL)dp[i - 1][0] * (pow_(2,w[j] - w[j - 1]) - 1) % MOD * 2 % MOD * pow_(2,w[h[i]] - w[j]) % MOD) %= MOD;\n            else (dp[i][1] += (LL)dp[i - 1][0] * (pow_(2,w[1]) - 2) % MOD * pow_(2,w[h[i]] - w[1]) % MOD) %= MOD;///上一列中无重复的乘上化不超过上一列高度中有重复的\n        }\n    }\n    int ans = 0;\n    for(int i = 0;i <= m;i++)\n        (ans += dp[n][i]) %= MOD;\n    printf(\"%d\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\nconst int N=1010,M=1000010,P=1e9+7;\nconst int inf=0x3f3f3f3f;\nconst int INF=0xcfcfcfcf;\nconst db eps=1e-9,pi=asin(1)*2;\ninline ll read();\n#define cmax(a,b) a=max(a,b)\n#define cmin(a,b) a=min(a,b)\ninline int ADD(int a,int b) { return a+b>=P?a+b-P:a+b; }\ninline int MINUS(int a,int b) { return a-b<0?a-b+P:a-b; }\n#define plus(a,b) a=ADD(a,b)\n#define minus(a,b) a=MINUS(a,b)\n#define mul(a,b) a=(1ll*a*(b))%P\n#define mem(a,b) memset(a,b,sizeof(a))\n#define pii pair<int,int>\n#define pil pair<int,ll>\n#define pli pair<ll,int>\n#define pll pair<ll,ll>\n#define mp(x,y) make_pair(x,y)\n\ninline int quickmi(int x,int n)\n{\n\tint res=1;\n\tfor(;n;n>>=1)\n\t{\n\t\tif(n&1) mul(res,x);\n\t\tmul(x,x);\n\t}\n\treturn res;\n}\n\nint n,cnt=0;\nint h[N],f[N];\nint dp1[N],dp2[N],dp3[N];\ninline int solve(int l,int r,int hfa)\n{\n\tif(l>r) return 0;\n\tint id=++cnt,minn=inf,num=0,lst=l;\n//\tcerr<<id<<\" \"<<l<<\" \"<<r<<\"\\n\";\n\tfor(int i=l;i<=r;i++)\n\t{\n\t\tif(h[i]==minn) num++;\n\t\tif(h[i]<minn) minn=h[i],num=1;\n\t}\n\tdp1[id]=quickmi(2,minn-hfa);\n\tdp2[id]=quickmi(2,num);\n\tdp3[id]=MINUS(dp1[id],2);\n\tfor(int i=l;i<=r+1;i++)\n\t{\n\t\tif(h[i]==minn||i>r)\n\t\t{\n\t\t\tint son=solve(lst,i-1,minn);\n\t\t\tlst=i+1;\n\t\t\tif(!son) continue;\n\t\t\tmul(dp1[id],dp1[son]);\n\t\t\tmul(dp2[id],ADD(dp1[son],dp2[son]));\n\t\t\tmul(dp3[id],dp1[son]);\n\t\t}\n\t}\n\tplus(dp2[id],dp3[id]);\n\treturn id;\n}\n\n#ifdef FILE\nconst int RS=1<<20;\nchar buf[RS],*p1=buf,*p2=buf;\n#define getchar() p1==p2&&(p2=(p1=buf)+fread(buf,1,RS,stdin),p1==p2)?EOF:*p1++\n#endif\ninline ll read()\n{\n\tll s=0;\n\tbool flag=false;\n\tchar ch=getchar();\n\tfor(;ch<'0'||ch>'9';ch=getchar()) if(ch=='-') flag=true;\n\tfor(;'0'<=ch&&ch<='9';ch=getchar()) s=(s<<3)+(s<<1)+(ch^'0');\n\tif(flag) return -s;\n\treturn s;\n}\n\nint main()\n{\n#ifdef FILE\n\tfreopen(FILE \".in\",\"r\",stdin);\n\tfreopen(FILE \".out\",\"w\",stdout);\n#endif\n\tn=read();\n\tfor(int i=1;i<=n;i++) h[i]=read();\n\tdp1[0]=1;\n\tprintf(\"%d\\n\",dp2[solve(1,n,0)]);\n/*\n\tcerr<<\"dp1: \\n\";\n\tfor(int i=1;i<=cnt;i++) cerr<<dp1[i]<<\" \";\n\tcerr<<\"\\n\";\n\tcerr<<\"dp2: \\n\";\n\tfor(int i=1;i<=cnt;i++) cerr<<dp2[i]<<\" \";\n\tcerr<<\"\\n\";\n\tcerr<<\"dp3: \\n\";\n\tfor(int i=1;i<=cnt;i++) cerr<<dp3[i]<<\" \";\n\tcerr<<\"\\n\";\n//*/\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define all(x) (x).begin (),(x).end()\n#define sqrt(x) sqrt(abs(x))\n#define re return\n#define sz(x) ((int)(x).size ())\n#define prev PREV\n#define next NEXT\n\nusing ll = long long;\nusing ii = pair<int, int>;\nusing ld = long double;\nusing D = double;\nusing vi = vector<int>;\nusing vii = vector<ii>;\nusing vvi = vector<vi>;\nusing vs = vector<string>;\n\ntemplate<typename T> T abs (T x) { re x < 0 ? -x : x; }\ntemplate<typename T> T sgn (T x) { re x < 0 ? -1 : (x > 0 ? 1 : 0); }\ntemplate<typename T> T sqr (T x) { re x * x; }\ntemplate<typename T> T gcd (T a, T b) { re a ? gcd (b % a, a) : b; }\n\nconst int mod = 1000*1000*1000+7;\n\nint n;\nint m;\nint res[110][110];\nint h[110];\nvi w;\n\nint power (int a, int b) {\n\tint c = 1;\n\twhile (b) {\n\t\tif (b & 1) c = ((ll)c * a) % mod;\n\t\ta = ((ll)a * a) % mod;\n\t\tb /= 2;\n\t}\n\tre c;\n}\n\nint main () {\n\tscanf (\"%d\", &n);\n\th[0] = 1;\n\tw.pb (1);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf (\"%d\", &h[i]);\n\t\tw.pb (h[i]);\n\t}\n\tsort (all (w));\n\tw.resize (unique (all (w)) - w.begin ());\n\tres[0][0] = 1;\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = 0; j < sz (w); j++) {\n\t\t\tif (j == 0) {\n\t\t\t\tres[i + 1][0] = (res[i + 1][0] + (ll)res[i][j] * 2) % mod;\n\t\t\t\tfor (int k = 1; k < sz (w); k++) {\n\t\t\t\t\tint a = max (h[i], w[k - 1]);\n\t\t\t\t\tint b = min (h[i + 1], w[k]);\n//\t\t\t\t\tprintf (\"%d %d\\n\", a, b);\n\t\t\t\t\tif (a <= b) {\n\t\t\t\t\t\tll tmp = power (2, h[i + 1] - a) - power (2, h[i + 1] - b);\n\t\t\t\t\t\tif (tmp < 0) tmp += mod;\n\t\t\t\t\t\tres[i + 1][k] = (res[i + 1][k] + (ll)res[i][j] * 2 * tmp) % mod;\n\t\t\t\t\t}\n\t\t\t\t}\t\n\t\t\t} else {\n\t\t\t\tif (w[j] <= h[i + 1]) {\n\t\t\t\t\tres[i + 1][j] = (res[i + 1][j] + (ll)res[i][j] * power (2, max (0, h[i + 1] - h[i]))) % mod;\n\t\t\t\t} else {\n\t\t\t\t\tres[i + 1][0] = (res[i + 1][0] + (ll)res[i][j] * 2) % mod;\n\t\t\t\t}\n\t\t\t}\n//\t\t\tprintf (\"%d,%d : %d = %d\\n\", i, h[i], w[j], res[i][j]);\n\t\t}\n\tint ans = 0;\n\tfor (int i = 0; i < sz (w); i++) {\n//\t\tprintf (\"%d = %d\\n\", i, res[n][i]);\n\t\tans = (ans + res[n][i]) % mod;\n\t}\t\n\tprintf (\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n\ntypedef long long LL;\n\nconst int N=105;\nconst int MOD=1000000007;\n\nint n,f[N][N],h[N],w[N],m;\n\nint ksm(int x,int y)\n{\n    if (y<0) return 1;\n    int ans=1;\n    while (y)\n    {\n        if (y&1) ans=(LL)ans*x%MOD;\n        x=(LL)x*x%MOD;y>>=1;\n    }\n    return ans;\n}\n\nint main()\n{\n    scanf(\"%d\",&n);\n    for (int i=1;i<=n;i++) scanf(\"%d\",&h[i]),w[++m]=h[i];\n    std::sort(w+1,w+m+1);\n    m=std::unique(w+1,w+m+1)-w-1;\n    for (int i=1;i<=n;i++) h[i]=std::lower_bound(w+1,w+m+1,h[i])-w;\n    f[0][0]=1;\n    for (int i=1;i<=n;i++)\n    {\n        for (int j=h[i]+1;j<=h[i-1];j++) (f[i][0]+=f[i-1][j]*2%MOD)%=MOD;\n        (f[i][0]+=f[i-1][0]*2%MOD)%=MOD;\n        for (int j=1;j<=h[i];j++)\n        {\n            f[i][j]=(LL)f[i-1][j]*ksm(2,w[h[i]]-w[h[i-1]])%MOD;\n            if (h[i-1]>=j) continue;\n            if (j>1) (f[i][j]+=(LL)f[i-1][0]*(ksm(2,w[j]-w[j-1])-1)%MOD*2%MOD*ksm(2,w[h[i]]-w[j])%MOD)%=MOD;\n            else (f[i][j]+=(LL)f[i-1][0]*(ksm(2,w[j])-2)%MOD*ksm(2,w[h[i]]-w[j])%MOD)%=MOD;\n        }\n    }\n    int ans=0;\n    for (int i=0;i<=m;i++) (ans+=f[n][i])%=MOD;\n    printf(\"%d\",ans);\n    return 0;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast,no-stack-protector\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\")\n//#pragma GCC target(\"avx,tune=native\")\n#include<bits/stdc++.h>\n#define int long long\n//#include<ext/pb_ds/assoc_container.hpp>\nusing namespace std;\n//using namespace __gnu_pbds;\nconst int inf=0x3f3f3f3f;\nconst double eps=1e-6;\nconst int mod=1000000007;\ntypedef long long ll;\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\ninline string getstr(string &s,int l,int r){string ret=\"\";for(int i=l;i<=r;i++)ret.push_back(s[i]);return ret;}\nint modpow(int x,int y,int md=mod){if(y<=0)return 1;int ret=modpow(x,y>>1,md);ret=(ll)ret*ret%md;if(y&1)ret=(ll)ret*x%md;return ret;}\nint n;\nint h[105],g[105];\ninline int add(int x,int y){\n\treturn (x+y)%mod;\n}\ninline int mul(int x,int y){\n\treturn x*y%mod;\n}\ninline int sub(int x,int y){\n\treturn (x-y+mod)%mod; \n}\npair<int,int>operator*(pair<int,int>a,pair<int,int>b){\n\ta.first=mul(a.first,add(b.first,b.second));\n\ta.second=mul(a.second,b.second);\n\treturn a;\n}\npair<int,int>solve(int l,int r){\n\tint low=*min_element(h+l,h+r+1);\n\tint cnt=0;\n\tfor(int i=l;i<=r;i++)h[i]-=low;\n\tfor(int i=l;i<=r;i++)if(!h[i])cnt++;\n\tint L=l,R=l;h[r+1]=0;\n\tpair<int,int>ret(modpow(2,cnt),2);\n\tfor(int i=l;i<=r+1;i++){\n\t\tR=i-1;\n\t\tif(h[i]==0){\n\t\t\tif(L<=R)ret=ret*solve(L,R);\n\t\t\tL=i+1;\n\t\t}\n\t}\n\tret.first=sub(ret.first,ret.second);\n\tret.second=mul(ret.second,modpow(2,low-1));\n\tret.first=add(ret.first,ret.second);\n\treturn ret;\n}\nsigned main(){\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)cin>>h[i];\n\tcout<<solve(1,n).first<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdlib>\n#include<cstdio>\n#include<algorithm>\n#define ll long long\nusing namespace std;\nconst int maxn=1010, inf=1e9, mod=1e9+7;\nint n, N;\nint h[maxn], b[maxn], f[maxn][maxn];\n\ntemplate<typename T>\ninline void read(T &k)\n{\n\tint f=1; k=0; char c=getchar();\n\twhile(c<'0' || c>'9') c=='-'&&(f=-1), c=getchar();\n\twhile(c<='9' && c>='0') k=k*10+c-'0', c=getchar();\n\tk*=f;\t\n}\n\ninline int power(int a, int b)\n{\n\tif(b<0) return 1;\n\tint ans=1;\n\tfor(;b;b>>=1, a=1ll*a*a%mod)\n\tif(b&1) ans=1ll*a*ans%mod;\n\treturn ans;\n}\n \nint main()\n{\n\tread(n);\n\tfor(int i=1;i<=n;i++) read(h[i]), b[++N]=h[i];\n\tsort(b+1, b+1+N); N=unique(b+1, b+1+N)-b-1;\n\tfor(int i=1;i<=n;i++) h[i]=lower_bound(b+1, b+1+N, h[i])-b;\n\tf[0][0]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tf[i][0]=2ll*f[i-1][0]%mod;\n\t\tfor(int j=h[i]+1;j<=h[i-1];j++) f[i][0]=(f[i][0]+2ll*f[i-1][j])%mod;\n\t\tfor(int j=1;j<=h[i];j++)\n\t\t{\n\t\t\tf[i][j]=1ll*f[i-1][j]*power(2, b[h[i]]-b[h[i-1]])%mod;\n\t\t\tif(j>h[i-1])\n\t\t\t{\n\t\t\t\tif(j>1) f[i][j]=(f[i][j]+1ll*f[i-1][0]*(power(2, b[j]-b[j-1])-1+mod)*2%mod*power(2, b[h[i]]-b[j]))%mod;\n\t\t\t\telse f[i][j]=(f[i][j]+1ll*f[i-1][0]*(power(2, b[j]-1)-1)*2%mod*power(2, b[h[i]]-b[j]))%mod;\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=0;i<=N;i++) ans=(ans+f[n][i])%mod;\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) (x = max(x,y))\n#define mins(x,y) (x = min(x,y))\n#define limit(x,l,r) max(l,min(x,r))\n#define lims(x,l,r) (x = max(l,min(x,r)))\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcountll\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,v(T),greater<T> >\n#define bn(x) ((1<<x)-1)\n#define dup(x,y) (((x)+(y)-1)/(y))\n#define newline puts(\"\")\n#define v(T) vector<T>\n#define vv(T) v(v(T))\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ntemplate<typename T>inline istream& operator>>(istream&i,v(T)&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(const v(T)&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>inline ostream& operator<<(ostream&o,const v(T)&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>inline istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>inline ostream& operator<<(ostream&o,const pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\ntemplate<typename T>inline ll suma(const v(T)& a) { ll res(0); for (auto&& x : a) res += x; return res;}\nconst double eps = 1e-10;\nconst ll LINF = 1e18;\nconst int INF = 1001001001;\n#define dame { puts(\"-1\"); return 0;}\n#define yn {puts(\"YES\");}else{puts(\"NO\");}\nconst int MX = 200005;\n\n// Mod int\nconst int mod = 1000000007;\nstruct mint {\n  ll x;\n  mint():x(0){}\n  mint(ll x):x((x%mod+mod)%mod){}\n  // mint(ll x):x(x){}\n  mint& fix() { x = (x%mod+mod)%mod; return *this;}\n  mint& operator+=(const mint& a){ if((x+=a.x)>=mod) x-=mod; return *this;}\n  mint& operator-=(const mint& a){ if((x+=mod-a.x)>=mod) x-=mod; return *this;}\n  mint& operator*=(const mint& a){ (x*=a.x)%=mod; return *this;}\n  mint& operator/=(const mint& a){ (x*=a.ex(mod-2).x)%=mod; return *this;}\n  mint operator+(const mint& a)const{ return mint(*this) += a;}\n  mint operator-(const mint& a)const{ return mint(*this) -= a;}\n  mint operator*(const mint& a)const{ return mint(*this) *= a;}\n  mint operator/(const mint& a)const{ return mint(*this) /= a;}\n  mint ex(ll t) const {\n    if(!t) return 1;\n    mint res = ex(t/2);\n    res *= res;\n    return (t&1)?res*x:res;\n  }\n  bool operator<(const mint& a)const{ return x < a.x;}\n  bool operator==(const mint& a)const{ return x == a.x;}\n};\nmint ex(mint x, ll t) { return x.ex(t);}\nistream& operator>>(istream&i,mint&a){i>>a.x;return i;}\nostream& operator<<(ostream&o,const mint&a){o<<a.x;return o;}\ntypedef vector<mint> vm;\nstruct comb {\n  vm f, g;\n  comb(){}\n  comb(int mx):f(mx+1),g(mx+1) {\n    f[0] = 1;\n    rrep(i,mx) f[i] = f[i-1]*i;\n    g[mx] = f[mx].ex(mod-2);\n    for(int i=mx;i>0;i--) g[i-1] = g[i]*i;\n  }\n  mint c(int a, int b) {\n    if (a < b) return 0;\n    return f[a]*g[b]*g[a-b];\n  }\n};\n//\n\nvi conv(vi a) {\n  vi res;\n  rep(i,sz(a)-1) {\n    res.pb(min(a[i],a[i+1])-1);\n  }\n  return res;\n}\ntypedef pair<mint,mint> MP;\nMP dfs(vi a) {\n  int n = sz(a);\n  int l = INF;\n  rep(i,n) mins(l,a[i]);\n  rep(i,n) a[i] -= l;\n  MP res(1,1);\n  vi x;\n  auto f = [&]() {\n    if (!sz(x)) return;\n    MP d = dfs(x);\n    res.fi *= d.fi;\n    res.se *= d.se;\n    x = vi();\n  };\n  rep(i,n) {\n    if (a[i]) {\n      x.pb(a[i]);\n    } else {\n      res.se *= 2;\n      f();\n    }\n  }\n  f();\n  // cerr<<l<<\": \"<<a<<endl;\n  // cerr<<res<<endl;\n  res.se += res.fi*(ex(2,l)-1);\n  res.fi *= ex(2,l);\n  // cerr<<res<<endl;\n  return res;\n}\nmint solve(vi a) {\n  int n = sz(a);\n  if (!n) return 1;\n  a = conv(a);\n  return dfs(a).se*2;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\",&n);\n  vi a(n);\n  cin>>a;\n  mint ans = 1;\n  rep(i,n) {\n    int x = 1;\n    if (i) maxs(x,a[i-1]);\n    if (i+1 < n) maxs(x,a[i+1]);\n    if (a[i] > x) {\n      ans *= ex(2,a[i]-x);\n      a[i] = x;\n    }\n  }\n\n  vi x;\n  rep(i,n) {\n    if (a[i] == 1) {\n      ans *= 2;\n      a[i] = 0;\n      ans *= solve(x);\n      x = vi();\n    } else x.pb(a[i]);\n  }\n  ans *= solve(x);\n  cout<<ans<<endl;\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int Mod=1e9+7;\nint n,h[110];\nll qpow(ll x,ll a){\n\tll res=1;\n\twhile (a){\n\t\tif (a&1) res=res*x%Mod;\n\t\tx=x*x%Mod; a>>=1;\n\t}\n\treturn res;\n}\ninline ll calc(int l){\n\treturn (qpow(2,l)+Mod-2)%Mod;\n}\npii solve(int l,int r,int k){\n\tint mn=h[l],cnt=0;\n\tfor (int i=l+1;i<=r;i++) mn=min(mn,h[i]);\n\tfor (int i=l;i<=r;i++)\n\t\tif (h[i]==mn) cnt++;\n\tif (cnt==r-l+1) return pii(calc(r-l+1),qpow(2,mn-k-1));\n\tint tot=r-l+1,s0=1,s1=1,last=0;\n\tfor (int i=l;i<=r+1;i++)\n\t\tif (!last&&h[i]>mn) last=i;\n\t\telse\n\t\t\tif (last&&(h[i]<=mn||i>r)){\n\t\t\t\ttot-=i-last;\n\t\t\t\tpii tmp=solve(last,i-1,mn);\n\t\t\t\ts0=(ll)s0*(tmp.first+4ll*tmp.second%Mod)%Mod;\n\t\t\t\ts1=(ll)s1*(2ll*tmp.second%Mod)%Mod;\n\t\t\t\tlast=0;\n\t\t\t}\n\ts0=(s0+Mod-s1)%Mod; pii res;\n\tres.first=(ll)s0*qpow(2,tot)%Mod;\n\tres.first=(res.first+(ll)s1*calc(tot)%Mod)%Mod;\n\tres.second=(ll)s1*qpow(2,mn-k-1)%Mod;\n\treturn res;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&h[i]);\n\tif (n==1){\n\t\tprintf(\"%lld\\n\",qpow(2,h[1]));\n\t\treturn 0;\n\t}\n\tll mul=1;\n\tfor (int i=1;i<=n;i++)\n\t\tif (h[i]>max(h[i-1],h[i+1])){\n\t\t\tmul=mul*qpow(2,h[i]-max(h[i-1],h[i+1]))%Mod;\n\t\t\th[i]=max(h[i-1],h[i+1]);\n\t\t}\n\tpii ans=solve(1,n,0);\n\tprintf(\"%lld\\n\",1ll*mul*(ans.first+2ll*ans.second)%Mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,x,y) for (int i=(x);i<=(y);i++)\n#define ll long long\n#define inf 1000000001\n#define y1 y1___\n#define pii pair<int,int>\n#define fi first\n#define se second\nusing namespace std;\nchar gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\nll read(){\n    char ch=gc();ll x=0;int op=1;\n    for (;!isdigit(ch);ch=gc()) if (ch=='-') op=-1;\n    for (;isdigit(ch);ch=gc()) x=(x<<1)+(x<<3)+ch-'0';\n    return x*op;\n}\n#define N 105\n#define mod 1000000007\nint ksm(int x,int p){\n    int ret=1;\n    for (;p;p>>=1,x=(ll)x*x%mod) if (p&1) ret=(ll)ret*x%mod;\n    return ret;\n}\nint n,h[N];\npii solve(int l,int r,int lim){//区间[l,r]比lim高的部分的方案数\n    int mi=inf,cnt=0;pii ret;//first：存在相邻格子颜色相同情况的方案数；second：不存在的方案数（固定第一个格子的颜色）\n    rep (i,l,r) if (h[i]<mi) mi=h[i],cnt=1;else if (h[i]==mi) cnt++;\n    if (cnt==r-l+1){//矩形\n        ret.fi=(ksm(2,r-l+1)+mod-2)%mod;\n        ret.se=ksm(2,mi-lim-1);\n        return ret;\n    }\n    int rest=r-l+1,s0=1,s1=1,last=0;//rest：上方没有方格的列数；s0,s1：维护上方有方格的列，当前行存在/不存在的方案数\n    rep (i,l,r+1)\n        if (!last&&h[i]>mi) last=i;\n        else if (last&&(h[i]<=mi||i>r)){\n            rest-=i-last;\n            pii tmp=solve(last,i-1,mi);//子问题，递归求解\n            s0=(ll)s0*(tmp.fi+4ll*tmp.se%mod)%mod;//*4是因为上一行可以取反，当前行亦然，2*2\n            s1=(ll)s1*(2ll*tmp.se%mod)%mod;\n            last=0;\n        }\n    s0=(s0+mod-s1)%mod;\n    ret.fi=(ll)s0*ksm(2,rest)%mod;//如果上方方格已经存在，剩下的列随意\n    ret.fi=(ret.fi+(ll)s1*(ksm(2,rest)+mod-2)%mod)%mod;//否则需要去掉两种不合法的情况\n    ret.se=(ll)s1*ksm(2,mi-lim-1)%mod;//固定第一个格子（第一行）颜色\n    return ret;\n}\nint main(){\n    n=read();rep (i,1,n) h[i]=read();\n    if (n==1){//注意特判\n        printf(\"%d\\n\",ksm(2,h[1]));\n        exit(0);\n    }\n    int ex=1;\n    rep (i,1,n) if (h[i]>h[i-1]&&h[i]>h[i+1]){\n        ex=(ll)ex*ksm(2,h[i]-max(h[i-1],h[i+1]))%mod;\n        h[i]=max(h[i-1],h[i+1]);\n    }\n    pii ans=solve(1,n,0);\n    printf(\"%d\",(ll)ex*(ans.fi+2ll*ans.se%mod)%mod);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N = 105;\nconst int MOD = 1000000007;\n\nint n,m,h[N],w[N];\nLL dp[N][N];\n\nint pow_(int x,int y) {///快速幂求 x的y次方\n    int ans = 1;\n    if(y > 0) {\n        while(y) {\n            if(y % 2)ans = (LL)ans * x % MOD;\n            x = (LL)x * x % MOD;\n            y /= 2;\n        }\n    }\n    return ans;\n}\n\nint main() {\n    scanf(\"%d\",&n);\n    for(int i = 1;i <= n;i ++) {\n        scanf(\"%d\",&h[i]);\n        w[++ m] = h[i];\n    }\n    sort(w + 1,w + m + 1);///高度排序\n    m = unique(w + 1,w + m + 1) - w - 1;///离散化 m是离散化后的长度\n    for(int i = 1;i <= n;i ++) {\n        h[i] = lower_bound(w + 1,w + m + 1,h[i]) - w;\n    }\n    dp[0][0]=1;\n    for(int i = 1;i <= n;i ++) {\n        for(int j = h[i] + 1;j <= h[i - 1];j ++)\n            (dp[i][0] += dp[i - 1][j] * 2 % MOD) %= MOD;\n        (dp[i][0] += dp[i - 1][0] * 2 % MOD) %= MOD;///交叉或者不交叉\n        for(int j = 1;j <= h[i];j ++) {\n            dp[i][j]=(LL)dp[i - 1][j] * pow_(2,w[h[i]] - w[h[i-1]]) % MOD;\n            if(h[i - 1] >= j)continue;///如果是高度不超过前一列的位置 量已经确定了\n            if(j > 1)(dp[i][j] += dp[i - 1][0] * (pow_(2,w[j] - w[j - 1]) - 1) % MOD * 2 % MOD * pow_(2,w[h[i]] - w[j]) % MOD) %= MOD;\n            else (dp[i][1] += dp[i - 1][0] * (pow_(2,w[1]) - 2) % MOD * pow_(2,w[h[i]] - w[1]) % MOD) %= MOD;///上一列中无重复的乘上化不超过上一列高度中有重复的\n        }\n    }\n    LL ans = 0;\n    for(int i = 0;i <= m;i++)\n        (ans += dp[n][i]) %= MOD;\n    printf(\"%lld\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define fi first\n#define se second\n\nconst int N = 105, mod = 1e9 + 7;\nint n, h[N];\n\nvoid add (int &_a, int _b) {\n    _a += _b;\n    if (_a >= mod) _a -= mod;\n}\n\nint binPow (int _a, int _n) {\n    int ret = 1;\n    for (; _n; _n >>= 1, _a = 1LL * _a * _a % mod) if (_n & 1) ret = 1LL * ret * _a % mod;\n    return ret;\n}\n\npair<int, int> solve (int l, int r) {\n    int minH = mod;\n\n    bool rect = 1;\n    for (int i = l; i + 1 <= r; ++i) if (h[i] != h[i + 1]) rect = 0;\n\n    if (rect) return { (binPow(2, r - l + 1) + binPow(2, min(h[l] - h[l - 1], h[r] - h[r + 1]) ) - 2 + mod) % mod,\n                      binPow(2, min(h[l] - h[l - 1], h[r] - h[r + 1]) ) };\n\n    for (int i = l; i <= r; ++i) minH = min(minH, h[i]);\n    vector< pair<int, int> > dp;\n    vector< pair<int, int> > range;\n    for (int i = l, lst = -1; i <= r; ++i) {\n        if (h[i] == minH) lst = -1;\n        else {\n            if (lst == -1) lst = i;\n            if (i == r || h[i + 1] == minH) dp.pb( { solve(lst, i) } );\n        }\n    }\n    for (int i = l, lst = -1; i <= r; ++i) {\n        if (h[i] > minH) lst = -1;\n        else {\n            if (lst == -1) lst = i;\n            if (i == r || h[i + 1] > minH) range.pb( { lst, i } );\n        }\n    }\n\n//    cout << \"l = \" << l << \"  r = \" << r << '\\n';\n//    for (auto _ : dp) cout << _.fi << ' '; cout << '\\n';\n\n    pair<int, int> ret = { 0, 0 };\n\n    int tmp = 1;\n    for (auto _ : dp) tmp = 1LL * tmp * ( (_.fi + _.se) % mod) % mod;\n    for (auto _ : range) tmp = 1LL * tmp * binPow(2, _.se - _.fi + 1) % mod;\n\n//    cout << \"tmp = \" << tmp << '\\n';\n\n    add(ret.fi, tmp);\n\n    tmp = 1;\n    for (auto _ : dp) tmp = 1LL * tmp * _.se % mod;\n    add(tmp, tmp);\n\n//    cout << \"tmp = \" << tmp << '\\n';\n\n    add(ret.fi, 1LL * tmp * ( (binPow(2, minH - max(h[l - 1], h[r + 1]) - 1) - 1 + mod) % mod) % mod);\n\n    add(ret.se, 1LL * tmp * binPow(2, minH - max(h[l - 1], h[r + 1]) - 1) % mod);\n\n//    cout << ret.fi << \"  \" << ret.se << '\\n';\n\n    return ret;\n}\n\nint main () {\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\n    cin >> n;\n    for (int i = 1; i <= n; ++i) cin >> h[i];\n\n    int ans = solve(1, n).fi;\n    assert(ans >= 0 && ans < mod);\n    cout << ans;\n\n    return 0;\n}\n/*\n3\n4 2 5\n\n320\n*/\n"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-03-09 16:15:41\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\nint read()\n{\n\tint r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\n#define i64 long long\nconst int N=100010,L=20,mod=1000000007,i2=(mod+1)/2;\ni64 power(i64 a,i64 b,i64 p)\n{\n\ti64 r=1;\n\tfor(;b;b>>=1,a=a*a%p) if(b&1) r=r*a%p;\n\treturn r;\n}\nint n,h[N],m[N][L+2],b[N];\nint Min(int a,int b){ return h[a]<h[b]?a:b; }\nint cmin(int l,int r)\n{\n\tint B=b[r-l+1];\n\treturn Min(m[l][B],m[r-(1<<B)+1][B]);\n}\n#define info std::pair<i64,i64>\ninfo operator+(info a,i64 b){ a.first-=a.second; a.second=a.second*power(2,b,mod)%mod; return info((a.first+a.second+mod)%mod,a.second); }\ninfo operator+(info a,info b){ return info(a.first*b.first%mod,a.second*b.second%mod*i2%mod); }\ninfo calc(int l,int r,int H)\n{\n\tif(l>r) return info(1,2);\n\tif(l==r) return info(2,2)+(h[l]-H-1);\n\tint m=cmin(l,r);\n\treturn (calc(l,m-1,h[m]-1)+info(2,2)+calc(m+1,r,h[m]-1))+(h[m]-H-1);\n}\nint main()\n{\n\tn=read();\n\tfr(i,1,n) h[i]=read();\n\tfr(i,2,n) b[i]=b[i>>1]+1;\n\tfr(i,1,n) m[i][0]=i;\n\tfr(j,1,L) fr(i,1,n-(1<<j)+1) m[i][j]=Min(m[i][j-1],m[i+(1<<(j-1))][j-1]);\n\tprintf(\"%d\\n\",int(calc(1,n,0).first));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define int long long \n#define mod 1000000007\nint a[110],n;\nstruct node{\n\tint x,y;\n};\nint quickpow(int x,int y){\n\tif(y==0)return 1;\n\tif(y==1)return x;\n\tif(y%2==0)return quickpow(x*x%mod,y/2);\n\tif(y%2==1)return quickpow(x*x%mod,y/2)*x%mod;\n}\nnode calc(int l,int r,int lim){\n\tint minn=0x3f3f3f3f3f3f3f3f,cnt=0;\n\tnode ans;\n\tfor(int i=l;i<=r;i++)\n\t\tif(a[i]<minn)minn=a[i],cnt=1;\n\t\telse if(a[i]==minn)cnt++;\n\tif(cnt==r-l+1){\n\t\tans.x=(quickpow(2,r-l+1)-2+mod)%mod;\n\t\tans.y=quickpow(2,minn-lim-1);\n\t\treturn ans;\n\t}\n\tint s0=1,s1=1,last=0;\n\tfor(int i=l;i<=r+1;i++){\n\t\tif(!last&&a[i]>minn)last=i;\n\t\telse if(last&&(i==r+1||a[i]==minn)){\n\t\t\tnode Ans=calc(last,i-1,minn);\n\t\t\t(s0*=(Ans.x+4*Ans.y%mod)%mod)%=mod;\n\t\t\t(s1*=Ans.y*2%mod)%=mod;\n\t\t\tlast=0;\n\t\t}\n\t}\n\ts0=(s0+mod-s1)%mod;\n\tans.x=(s0*quickpow(2,cnt)%mod+s1*(quickpow(2,cnt)-2+mod)%mod)%mod;\n\tans.y=s1*quickpow(2,minn-lim-1)%mod;\n\treturn ans;\n}\nsigned main(){\n\tscanf(\"%lld\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%lld\",&a[i]);\n\tif(n==1){\n\t\tprintf(\"%lld\",quickpow(2,a[1]));\n\t\treturn 0;\n\t}\n\tint ans=1;\n\tfor(int i=1;i<=n;i++)\n\t\tif(a[i]>a[i-1]&&a[i]>a[i+1]){\n\t\t\t(ans*=quickpow(2,a[i]-std::max(a[i+1],a[i-1])))%=mod;\n\t\t\ta[i]=std::max(a[i+1],a[i-1]);\n\t\t}\n\tnode Ans=calc(1,n,0);\n\tprintf(\"%lld\\n\",ans*(Ans.x+2*Ans.y%mod)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <utility>\n\nusing namespace std;\n\n#define fi first\n#define se second\n#define long long long\ntypedef pair<int,int> ii;\ntypedef pair<long,ii> lii;\n\nconst long MOD = 1e9+7;\nlong p2(long b)\n{\n\tif(b == 0) return 1;\n\telse if(b == 2) return 4;\n\telse if(b&1) return (p2(b-1)*2)%MOD;\n\telse\n\t{\n\t\tlong temp = p2(b/2);\n\t\treturn (temp*temp)%MOD;\n\t}\n}\nlong geo(long a, long n)\n{\n\treturn (a*(p2(n)-1))%MOD;\n}\n\nvector<lii> vec;\nlong arr[100003];\n\nint main()\n{\n\t//ios_base::sync_with_stdio(); cin.tie(0); cout.tie(0);\n\t// freopen(\"input.in\", \"r\", stdin);\n\t\n\tint n; scanf(\"%d\", &n);\t\n\tfor(int i = 1; i <= n; i++)\n\t\tscanf(\"%lld\", &arr[i]);\n\tlong res = 1;\n\tlong bed = 0;\n\tfor(int i = 1; i <= n+1; i++)\n\t{\n\t\tif(arr[i] == 1 || i == n+1)\n\t\t{\n\t\t\t// printf(\"i : %d\\n\" , i);\n\t\t\tlong cnt = 0;\n\t\t\tcnt += bed;\n\t\t\t// printf(\"\tBED : %lld\\n\", bed);\n\t\t\tfor(auto j : vec)\n\t\t\t{\n\t\t\t\t// printf(\"\t%lld %d %d\\n\", j.fi, j.se.fi, j.se.se);\n\t\t\t\tcnt += geo(j.fi,j.se.fi-j.se.se+1);\n\t\t\t\tcnt %= MOD;\n\t\t\t}\n\t\t\t// printf(\"\tCNT : %lld\\n\", cnt);\n\t\t\tvec.clear(); bed = 1;\n\t\t\tres *= cnt*2;\n\t\t\tres %= MOD;\n\n\t\t}\n\t\telse if(vec.size() == 0)\n\t\t{\n\t\t\tvec.push_back({2,{arr[i],2}});\n\t\t\tbed = 2;\n\t\t}\n\t\telse if(arr[i] > arr[i-1])\n\t\t{\n\t\t\tfor(int j = 0; j < vec.size(); j++)\n\t\t\t{\n\t\t\t\tvec[j].fi *= p2(arr[i]-arr[i-1]);\n\t\t\t\tvec[j].fi %= MOD;\n\t\t\t}\n\t\t\tbed *= 2; bed %= MOD;\n\t\t\tvec.push_back({bed,{arr[i], arr[i-1]+1}});\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvector<lii> temp;\n\t\t\tbed *= 2; bed %= MOD;\n\t\t\tfor(int j = 0; j < vec.size(); j++)\n\t\t\t{\n\t\t\t\tif(vec[j].se.fi > arr[i])\n\t\t\t\t{\n\t\t\t\t\tif(vec[j].se.se > arr[i])\n\t\t\t\t\t{\n\t\t\t\t\t\tbed += 2*geo(vec[j].fi,vec[j].se.fi-vec[j].se.se+1);\n\t\t\t\t\t\tbed %= MOD;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tbed += 2*geo(vec[j].fi, vec[j].se.fi-arr[i]);\n\t\t\t\t\t\tbed %= MOD;\n\t\t\t\t\t\ttemp.push_back({vec[j].fi*p2(vec[j].se.fi-arr[i]),{arr[i],vec[j].se.se}});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\ttemp.push_back(vec[j]);\n\t\t\t}\n\t\t\tvec = temp;\n\t\t}\n\t}\n\tres *= p2(MOD-2);\n\tres %= MOD;\n\tprintf(\"%lld\\n\", res);\n}\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) (x = max(x,y))\n#define mins(x,y) (x = min(x,y))\n#define limit(x,l,r) max(l,min(x,r))\n#define lims(x,l,r) (x = max(l,min(x,r)))\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcountll\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,v(T),greater<T> >\n#define bn(x) ((1<<x)-1)\n#define dup(x,y) (((x)+(y)-1)/(y))\n#define newline puts(\"\")\n#define v(T) vector<T>\n#define vv(T) v(v(T))\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ntemplate<typename T>inline istream& operator>>(istream&i,v(T)&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(const v(T)&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>inline ostream& operator<<(ostream&o,const v(T)&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>inline istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>inline ostream& operator<<(ostream&o,const pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\ntemplate<typename T>inline ll suma(const v(T)& a) { ll res(0); for (auto&& x : a) res += x; return res;}\nconst double eps = 1e-10;\nconst ll LINF = 1e18;\nconst int INF = 1001001001;\n#define dame { puts(\"-1\"); return 0;}\n#define yn {puts(\"YES\");}else{puts(\"NO\");}\nconst int MX = 200005;\n\n// Mod int\nconst int mod = 1000000007;\nstruct mint {\n  ll x;\n  mint():x(0){}\n  mint(ll x):x((x%mod+mod)%mod){}\n  // mint(ll x):x(x){}\n  mint& fix() { x = (x%mod+mod)%mod; return *this;}\n  mint& operator+=(const mint& a){ if((x+=a.x)>=mod) x-=mod; return *this;}\n  mint& operator-=(const mint& a){ if((x+=mod-a.x)>=mod) x-=mod; return *this;}\n  mint& operator*=(const mint& a){ (x*=a.x)%=mod; return *this;}\n  mint& operator/=(const mint& a){ (x*=a.ex(mod-2).x)%=mod; return *this;}\n  mint operator+(const mint& a)const{ return mint(*this) += a;}\n  mint operator-(const mint& a)const{ return mint(*this) -= a;}\n  mint operator*(const mint& a)const{ return mint(*this) *= a;}\n  mint operator/(const mint& a)const{ return mint(*this) /= a;}\n  mint ex(ll t) const {\n    if(!t) return 1;\n    mint res = ex(t/2);\n    res *= res;\n    return (t&1)?res*x:res;\n  }\n  bool operator<(const mint& a)const{ return x < a.x;}\n  bool operator==(const mint& a)const{ return x == a.x;}\n};\nmint ex(mint x, ll t) { return x.ex(t);}\nistream& operator>>(istream&i,mint&a){i>>a.x;return i;}\nostream& operator<<(ostream&o,const mint&a){o<<a.x;return o;}\ntypedef vector<mint> vm;\nstruct comb {\n  vm f, g;\n  comb(){}\n  comb(int mx):f(mx+1),g(mx+1) {\n    f[0] = 1;\n    rrep(i,mx) f[i] = f[i-1]*i;\n    g[mx] = f[mx].ex(mod-2);\n    for(int i=mx;i>0;i--) g[i-1] = g[i]*i;\n  }\n  mint c(int a, int b) {\n    if (a < b) return 0;\n    return f[a]*g[b]*g[a-b];\n  }\n};\n//\n\nvi conv(vi a) {\n  vi res;\n  rep(i,sz(a)-1) {\n    res.pb(min(a[i],a[i+1])-1);\n  }\n  return res;\n}\ntypedef pair<mint,mint> MP;\nMP dfs(vi a) {\n  int n = sz(a);\n  int l = INF;\n  rep(i,n) mins(l,a[i]);\n  rep(i,n) a[i] -= l;\n  MP res(1,1);\n  vi x;\n  auto f = [&]() {\n    if (!sz(x)) return;\n    MP d = dfs(x);\n    res.fi *= d.fi;\n    res.se *= d.se;\n    x = vi();\n  };\n  rep(i,n) {\n    if (a[i]) {\n      x.pb(a[i]);\n    } else {\n      res.se *= 2;\n      f();\n    }\n  }\n  f();\n  cerr<<l<<\": \"<<a<<endl;\n  // cerr<<res<<endl;\n  res.se += res.fi*(ex(2,l)-1);\n  res.fi *= ex(2,l);\n  // cerr<<res<<endl;\n  return res;\n}\nmint solve(vi a) {\n  int n = sz(a);\n  if (!n) return 1;\n  a = conv(a);\n  return dfs(a).se*2;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\",&n);\n  vi a(n);\n  cin>>a;\n  mint ans = 1;\n  rep(i,n) {\n    int x = 0;\n    if (i) maxs(x,a[i-1]);\n    if (i+1 < n) maxs(x,a[i+1]);\n    if (a[i] > x) {\n      ans *= ex(2,a[i]-x);\n      a[i] = x;\n    }\n  }\n\n  vi x;\n  rep(i,n) {\n    if (a[i] == 1) {\n      ans *= 2;\n      a[i] = 0;\n      ans *= solve(x);\n      x = vi();\n    } else x.pb(a[i]);\n  }\n  ans *= solve(x);\n  cout<<ans<<endl;\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mod 1000000007\n#define fir first\n#define sec second\n#define mp make_pair\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\ninline int add(int x,int y){\n\tx += y;if (x >= mod) x -= mod;\n\treturn x;\n}\n\ninline int sub(int x,int y){\n\tx -= y;if (x < 0) x += mod;\n\treturn x;\n}\ninline int qpow(int x,int y){\n\tint res = 1;\n\twhile (y){\n\t\tif (y & 1) res = 1ll * res * x % mod;\n\t\tx = 1ll * x * x % mod;\n\t\ty >>= 1;\n\t}\n\treturn res;\n}\nconst int N = 1e5 + 10;\n\nint n , h[N];\npii solve(int l,int r,int lim){//first not ababab second ababa\n\tint minm = 0x3f3f3f3f , cntminm = 0 , block = 0;\n\tfor (int i = l;i <= r;i++){\n\t\tif (h[i] < minm){\n\t\t\tminm = h[i];\n\t\t\tcntminm = 0;\n\t\t}\n\t\tif (h[i] == minm) cntminm++;\n\t}\n\t\n\tif (cntminm == r - l + 1){\n//\t\tprintf(\"%d %d %d [%d %d]\\n\",l,r,lim,qpow(2,r-l+1)-2,qpow(2,h[l]-lim));\n\t\treturn mp(qpow(2 , r - l + 1) - 2 , qpow(2 , h[l] - lim));\n\t}\n\t\n\tpii res = mp(1 , 1);\n\tfor (int i = l;i <= r;i++){\n\t\tif (h[i] == minm) continue;\n\t\tint j = i;while (j + 1 <= r && h[j + 1] != minm)j++;\n\t\t\n\t\tpii tmp = solve(i , j , minm);\n\t\tres.first = 1ll * res.first * add(tmp.first , 2ll * tmp.second % mod) % mod;\n\t\tres.second = 1ll * res.second * tmp.second % mod;\n\t\tblock++;\n\t\ti = j;\n\t}\n\t\n\tres.first = 1ll * qpow(2 , cntminm) * res.first % mod;\n\tres.first = sub(res.first , 2ll * res.second % mod);\n\tres.second = 1ll * qpow(2 , minm - lim) * res.second % mod;\n\t\n//\tprintf(\"%d %d %d %d %d\\n\",l,r,lim,res.fir,res.sec);\n\treturn res;\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 1;i <= n;i++) cin >> h[i];\n\tpii res = solve(1 , n , 0);\n\t\n\tcout<<add(res.first,res.second);\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\nconst int N=1010,M=1000010,P=1e9+7;\nconst int inf=0x3f3f3f3f;\nconst int INF=0xcfcfcfcf;\nconst db eps=1e-9,pi=asin(1)*2;\ninline ll read();\n#define cmax(a,b) a=max(a,b)\n#define cmin(a,b) a=min(a,b)\ninline int ADD(int a,int b) { return a+b>=P?a+b-P:a+b; }\ninline int MINUS(int a,int b) { return a-b<0?a-b+P:a-b; }\n#define plus(a,b) a=ADD(a,b)\n#define minus(a,b) a=MINUS(a,b)\n#define mul(a,b) a=(1ll*a*(b))%P\n#define mem(a,b) memset(a,b,sizeof(a))\n#define pii pair<int,int>\n#define pil pair<int,ll>\n#define pli pair<ll,int>\n#define pll pair<ll,ll>\n#define mp(x,y) make_pair(x,y)\n\ninline int quickmi(int x,int n)\n{\n\tint res=1;\n\tfor(;n;n>>=1)\n\t{\n\t\tif(n&1) mul(res,x);\n\t\tmul(x,x);\n\t}\n\treturn res;\n}\n\nint n,cnt=0;\nint h[N],f[N];\nint dp1[N],dp2[N],dp3[N];\ninline int solve(int l,int r,int hfa)\n{\n\tif(l>r) return 0;\n\tint id=++cnt,minn=inf,num=0,lst=l;\n//\tcerr<<id<<\" \"<<l<<\" \"<<r<<\"\\n\";\n\tfor(int i=l;i<=r;i++)\n\t{\n\t\tif(h[i]==minn) num++;\n\t\tif(h[i]<minn) minn=h[i],num=1;\n\t}\n\tdp1[id]=quickmi(2,minn-hfa);\n\tdp2[id]=quickmi(2,num);\n\tdp3[id]=MINUS(dp1[id],2);\n\tfor(int i=l;i<=r+1;i++)\n\t{\n\t\tif(h[i]==minn||i>r)\n\t\t{\n\t\t\tint son=solve(lst,i-1,minn);\n\t\t\tlst=i+1;\n\t\t\tif(!son) continue;\n\t\t\tmul(dp1[id],dp1[son]);\n\t\t\tmul(dp2[id],ADD(dp1[son],dp2[son]));\n\t\t\tmul(dp3[id],dp1[son]);\n\t\t}\n\t}\n\tplus(dp2[id],dp3[id]);\n\treturn id;\n}\n\n#ifdef FILE\nconst int RS=1<<20;\nchar buf[RS],*p1=buf,*p2=buf;\n#define getchar() p1==p2&&(p2=(p1=buf)+fread(buf,1,RS,stdin),p1==p2)?EOF:*p1++\n#endif\ninline ll read()\n{\n\tll s=0;\n\tbool flag=false;\n\tchar ch=getchar();\n\tfor(;ch<'0'||ch>'9';ch=getchar()) if(ch=='-') flag=true;\n\tfor(;'0'<=ch&&ch<='9';ch=getchar()) s=(s<<3)+(s<<1)+(ch^'0');\n\tif(flag) return -s;\n\treturn s;\n}\n\nint main()\n{\n#ifdef FILE\n\tfreopen(FILE \".in\",\"r\",stdin);\n\tfreopen(FILE \".out\",\"w\",stdout);\n#endif\n\tn=read();\n\tfor(int i=1;i<=n;i++) h[i]=read();\n\tdp1[0]=1;\n\tprintf(\"%d\\n\",dp2[solve(1,n,0)]);\n/*\n\tcerr<<\"dp1: \\n\";\n\tfor(int i=1;i<=cnt;i++) cerr<<dp1[i]<<\" \";\n\tcerr<<\"\\n\";\n\tcerr<<\"dp2: \\n\";\n\tfor(int i=1;i<=cnt;i++) cerr<<dp2[i]<<\" \";\n\tcerr<<\"\\n\";\n\tcerr<<\"dp3: \\n\";\n\tfor(int i=1;i<=cnt;i++) cerr<<dp3[i]<<\" \";\n\tcerr<<\"\\n\";\n//*/\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<int, P> Pint;\nconst ll MOD=1e9+7;\nll powmod(ll a, ll k){\n    ll ap=a, ans=1;\n    while(k>0){\n        if(k%2==1){\n            ans*=ap;\n            ans%=MOD;\n        }\n        ap=ap*ap;\n        ap%=MOD;\n        k/=2;\n    }\n    return ans;\n}\nint main()\n{\n\t\n\tint n;\n  ll h[101];\n  vector<ll> hs;\n  cin>>n;\n  for(int i=1; i<=n; i++){\n    cin>>h[i]; hs.push_back(h[i]);\n  }\n  sort(hs.begin(), hs.end());\n  hs.erase(unique(hs.begin(), hs.end()), hs.end());\n  ll dp[2][100][100]={};\n  vector<Pint> v;\n  for(int i=hs.size()-1; i>=0; i--){\n    bool nuo[102]={}, nuo2[102]={};\n    for(int j=1; j<=n; j++){\n      if(hs[i]<=h[j]) nuo[j]=1;\n    }\n    int l;\n    for(int j=0; j<=n; j++){\n      if(!nuo[j] && nuo[j+1]) l=j;\n      if(nuo[j] && !nuo[j+1]){\n        bool ok=0;\n        for(int k=l+1; k<=j; k++){\n          if(hs[i]==h[k]){\n            ok=1;\n            break;\n          }\n        }\n        if(ok) v.push_back(Pint(hs[i], P(l+1, j)));\n      }\n    }\n  }\n  bool used[100]={};\n  for(int i=0; i<v.size(); i++){\n    int l=v[i].second.first, r=v[i].second.second, d0=v[i].first;\n    //cout<<l<<\" \"<<r<<\" \"<<d0<<endl;\n    bool no=1;\n    dp[1][l][r]=2;\n    ll prod=1, prod1=1;\n    int ct=0;\n    bool nuo=0;\n    int ct2=0;\n    for(int j=0; j<i; j++){\n      int l1=v[j].second.first, r1=v[j].second.second;\n      if(l>l1 || r1>r) continue;\n      if(used[j]) continue;\n      used[j]=1;\n      no=0;\n      if(r1!=l1) nuo=1;\n      int d1=v[j].first;\n      dp[1][l][r]*=(dp[1][l1][r1]*powmod(2ll, d1-d0-1)%MOD);\n      dp[1][l][r]%=MOD;\n      prod*=(dp[0][l1][r1]+dp[1][l1][r1]*powmod(2ll, d1-d0)%MOD);\n      prod%=MOD;\n      prod1*=(dp[1][l1][r1]*powmod(2ll, d1-d0)%MOD);\n      prod1%=MOD;\n      ct+=(r1-l1+1);\n      ct2++;\n    }\n    if(no){\n      dp[0][l][r]=(powmod(2ll, r-l+1)-2+MOD)%MOD;\n    }else{\n      if(nuo) dp[0][l][r]=((prod-prod1+MOD)*powmod(2ll, r-l+1-ct)%MOD+dp[1][l][r]*500000004%MOD*(powmod(2ll, r-l+1-ct+ct2)+MOD-2)%MOD)%MOD;\n      else dp[0][l][r]=dp[1][l][r]*500000004%MOD*(powmod(2ll, r-l+1)+MOD-2)%MOD;\n    }\n    if(r-l+1==n){\n      ll ans=dp[0][l][r]+dp[1][l][r]*powmod(2ll, d0-1)%MOD;\n      ans%=MOD;\n      cout<<ans<<endl;\n    }\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define index(xs, x) (int)(lower_bound(all(xs), x) - xs.begin())\n#define _1 first\n#define _2 second\n#define pb push_back\n//#define INF 1145141919\n#define MOD 1000000007\ninline void add(int &x, int v) { x += v; if (x >= MOD) x -= MOD; }\ninline int mul(int x, int y) { return (1LL*x*y)%MOD; }\n\nint N;\nint A[100];\nint dp[101][102];\nint modpow(int x, int k) {\n  int a = 1;\n  while (k) {\n    if (k&1) a = mul(a, x);\n    x = mul(x, x);\n    k>>=1;\n  }\n  return a;\n}\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N;\n  rep(i, N) cin >> A[i];\n  vector<int> xs;\n  rep(i, N) xs.pb(A[i]);\n  sort(all(xs)); uniq(xs);\n  int inf = xs.size();\n\n  //dp[0][inf] = 1;\n  add(dp[1][inf], 2);\n  int e = 2;\n  for (int k=index(xs, A[0]); k>0; k--) {\n    int w = xs[k]-(k>0?xs[k-1]:0);\n    add(dp[1][k], mul(e, (modpow(2, w)+MOD-1)%MOD));\n    e = mul(e, modpow(2, w));\n  }\n  // k=0\n  int w = xs[0];\n  add(dp[1][0], mul(e, (modpow(2, w-1)+MOD-1)%MOD));\n\n  int prev = A[0];\n  for (int i=1; i<N; i++) {\n    int vpos = index(xs, A[i]);\n    if (prev >= A[i]) {\n      rep(j, xs.size()) {\n        // j->inf\n        if (xs[j] > A[i]) add(dp[i+1][inf], mul(2, dp[i][j]));\n        // j->j\n        else add(dp[i+1][j], dp[i][j]);\n      }\n      // inf->inf\n      add(dp[i+1][inf], mul(2, dp[i][inf]));\n    }\n    else {\n      // j->j\n      int e = modpow(2, A[i]-prev);\n      rep(j, xs.size()) add(dp[i+1][j], mul(e, dp[i][j]));\n      // inf->inf\n      add(dp[i+1][inf], mul(2, dp[i][inf]));\n      // inf->k\n      e = 2;\n      for (int k=index(xs, A[i]); k>=0 && xs[k]>prev; k--) {\n        int w = xs[k]-(k>0?xs[k-1]:0);\n        add(dp[i+1][k], mul(mul(e, (modpow(2, w)+MOD-1)%MOD), dp[i][inf]));\n        e = mul(e, modpow(2, w));\n      }\n    }\n    prev = A[i];\n  }\n\n  int s = 0;\n  rep(i, xs.size()+1) add(s, dp[N][i]);\n  cout << s << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a))\nusing namespace std;\n\nconst int mo=1000000007;\nint power(int x,ll y){\n\tint s=1;\n\tfor (;y;y/=2,x=1ll*x*x%mo)\n\t\tif (y&1) s=1ll*s*x%mo;\n\treturn s;\n}\nconst int N=105;\nint a[N],mn[N][N];\nint fxor[N][N];\nint pre[N][N];\nint suf[N][N];\nint mx[N],g[N],n;\nint main(){\n\tscanf(\"%d\",&n); n++;\n\tFor(i,2,n) scanf(\"%d\",&a[i]);\n\ta[0]=a[1]=a[n+1]=a[n+2]=1;\n\tFor(i,0,n+2) mn[i][i]=i;\n\tFor(l,0,n+2) For(r,l+1,n+2)\n\t\tmn[l][r]=(a[r]<a[mn[l][r-1]]?r:mn[l][r-1]);\n\tFor(i,1,n+2) fxor[i][i-1]=1;\n\tRep(l,n+1,1) For(r,l,n+1){\n\t\tint dn=max(a[l-1],a[r+1]),md=mn[l][r];\n\t\tif (a[md]>=dn) fxor[l][r]=1ll*power(2,a[md]-dn)*fxor[l][md-1]%mo*fxor[md+1][r]%mo;\n\t}\n\tFor(l,0,n+2){\n\t\tCLR(mx,0); mx[l]=a[l];\n\t\tFor(i,l+1,n+2) mx[i]=min(a[i],mx[i-1]);\n\t\tint tmp=pre[l][l]=1,las=l;\n\t\tFor(r,l+1,n+2){\n\t\t\tpre[l][r]=1ll*tmp*fxor[las+1][r-1]%mo;\n\t\t\tif (mx[r]>=a[r]) tmp=1ll*tmp*fxor[las+1][r-1]%mo,las=r;\n\t\t}\n\t}\n\tFor(r,0,n+2){\n\t\tCLR(mx,0); mx[r]=a[r];\n\t\tRep(i,r-1,0) mx[i]=min(a[i],mx[i+1]);\n\t\tint tmp=suf[r][r]=1,las=r;\n\t\tRep(l,r-1,0){\n\t\t\tsuf[l][r]=1ll*tmp*fxor[l+1][las-1]%mo;\n\t\t\tif (mx[l]>=a[l]) tmp=1ll*tmp*fxor[l+1][las-1]%mo,las=l;\n\t\t}\n\t}\n\tg[1]=1;\n\tFor(i,2,n+2) For(j,1,i-1){\n\t\tint md=mn[j-1][i];\n\t\tUPD(g[i],1ll*g[j]*pre[j-1][md]%mo*suf[md][i]%mo);\n\t}\n\tprintf(\"%d\\n\",1ll*g[n+2]*500000004ll%mo);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ALL(v) std::begin(v), std::end(v)\n#define ALLR(v) std::rbegin(v), std::rend(v)\nusing ll = std::int64_t;\nusing ull = std::uint64_t;\nusing pii = std::pair<int, int>;\nusing tii = std::tuple<int, int, int>;\nusing pll = std::pair<ll, ll>;\nusing tll = std::tuple<ll, ll, ll>;\ntemplate <typename T> using vec = std::vector<T>;\ntemplate <typename T> using vvec = vec<vec<T>>;\ntemplate <typename T> const T& var_min(const T &t) { return t; }\ntemplate <typename T> const T& var_max(const T &t) { return t; }\ntemplate <typename T, typename... Tail> const T& var_min(const T &t, const Tail&... tail) { return std::min(t, var_min(tail...)); }\ntemplate <typename T, typename... Tail> const T& var_max(const T &t, const Tail&... tail) { return std::max(t, var_max(tail...)); }\ntemplate <typename T, typename... Tail> void chmin(T &t, const Tail&... tail) { t = var_min(t, tail...); }\ntemplate <typename T, typename... Tail> void chmax(T &t, const Tail&... tail) { t = var_max(t, tail...); }\ntemplate <typename T> const T& clamp(const T &t, const T &low, const T &high) { return std::max(low, std::min(high, t)); }\ntemplate <typename T> void chclamp(T &t, const T &low, const T &high) { return t = clamp(t, low, high); }\ntemplate <typename T> T make_v(T init) { return init; }\ntemplate <typename T, typename... Tail> auto make_v(T init, std::size_t s, Tail... tail) { auto v = std::move(make_v(init, tail...)); return vec<decltype(v)>(s, v); }\ntemplate <typename T, std::size_t Head, std::size_t ...Tail> struct multi_dem_array { using type = std::array<typename multi_dem_array<T, Tail...>::type, Head>; };\ntemplate <typename T, std::size_t Head> struct multi_dem_array<T, Head> { using type = std::array<T, Head>; };\ntemplate <typename T, std::size_t ...Args> using mdarray = typename multi_dem_array<T, Args...>::type;\nnamespace init__ { struct InitIO { InitIO() { std::cin.tie(nullptr); std::ios_base::sync_with_stdio(false); std::cout << std::fixed << std::setprecision(30); } } init_io; }\n\nnamespace math {\n\ntemplate <typename T>\nconstexpr T pow(const T &n, ll k) {\n    T ret = n.mul_id_ele();\n    T cur = n;\n    while (k) {\n        if (k & 1) ret *= cur;\n        cur *= cur;\n        k /= 2;\n    }\n    return ret;\n}\n\n}\n\nnamespace math {\n\ntemplate <ll Mod>\nstruct Modint {\n\n    constexpr Modint(ll x) : x((Mod + x % Mod) % Mod) { }\n    \n    constexpr Modint() : Modint(0) { }\n    \n    constexpr Modint<Mod> add_id_ele() const { \n        return Modint<Mod>(0); \n    }\n    \n    constexpr Modint<Mod> mul_id_ele() const {\n        return Modint<Mod>(1); \n    }\n    \n    constexpr ll& value() { \n        return x; \n    }\n    \n    constexpr ll value() const {\n        return x; \n    }\n\n    constexpr Modint& operator +=(const Modint &oth) {\n        x += oth.value();\n        if (Mod <= x) x -= Mod;\n        return *this;\n    }\n\n    constexpr Modint& operator -=(const Modint &oth) {\n        x += Mod - oth.value();\n        if (Mod <= x) x -= Mod;\n        return *this;\n    }\n\n    constexpr Modint& operator *=(const Modint &oth) {\n        x *= oth.value();\n        x %= Mod;\n        return *this;\n    }\n\n    constexpr Modint& operator /=(const Modint &oth) {\n        x *= oth.inv();\n        x %= Mod;\n        return *this;\n    }\n\n    constexpr Modint operator +(const Modint &oth) const {\n        return Modint(x) += oth;\n    }\n\n    constexpr Modint operator -(const Modint &oth) const {\n        return Modint(x) -= oth;\n    }\n\n    constexpr Modint operator *(const Modint &oth) const {\n        return Modint(x) *= oth;\n    }\n\n    constexpr Modint operator /(const Modint &oth) const {\n        return Modint(x) /= oth;\n    }\n\n    constexpr Modint operator -() const {\n        return Modint((x != 0) * (Mod - x)); \n    }\n\n    template <typename T>\n    constexpr typename std::enable_if<std::is_integral<T>::value, const Modint&>::type\n    operator =(T t) {\n        (*this) = Modint(std::forward<T>(t)); \n        return *this;\n    }\n\n    constexpr Modint inv() const {\n        return ::math::pow(*this, Mod - 2);\n    }\n\n    constexpr ll mod() const {\n        return Mod;\n    }\n\nprivate:\n    ll x;\n};\n\n}\n\nconst ll mod = 1e9 + 7;\nusing mint = math::Modint<mod>;\nconst std::size_t SIZE = 110;\nmint dp[SIZE][SIZE];\n\nstruct Compress {\n    vec<ll> v;\n\n    Compress(const vec<ll> &v_) : v(v_) {\n        v.push_back(0);\n        std::sort(ALL(v));\n        auto ite = std::unique(ALL(v));\n        v.erase(ite, v.end());\n    }\n\n    ll get_id(ll n) {\n        return std::distance(v.begin(),\n                             std::lower_bound(ALL(v), n));\n    }\n};\n\nint main() {\n    ll n;\n    std::cin >> n;\n    vec<ll> h(n);\n    for (ll &e : h) std::cin >> e;\n\n    Compress cmp(h);\n    \n    ll phid = cmp.get_id(h[0]);\n    dp[1][0] = (math::pow(mint(2), cmp.v[1]) - 2) * math::pow(mint(2), h[0] - cmp.v[1]);\n    for (ll i = 1; i < phid; i++) dp[1][i] = (math::pow(mint(2), cmp.v[i + 1] - cmp.v[i]) - 1) * 2 * math::pow(mint(2), cmp.v[phid] - cmp.v[i + 1]);\n    dp[1][phid] = 2;\n    for (ll i = 1; i < n; i++) {\n        ll hid = cmp.get_id(h[i]);\n        if (hid <= phid) {\n            for (ll h = 0; h < hid; h++) dp[i + 1][h] = dp[i][h];\n            for (ll h = hid; h <= phid; h++) dp[i + 1][hid] += dp[i][h];\n            dp[i + 1][hid] *= 2;\n        } else {\n            ll diff = h[i] - h[i - 1];\n            mint pow2 = math::pow(mint(2), diff);\n            for (ll h = 0; h < phid; h++) dp[i + 1][h] = dp[i][h] * pow2; \n            for (ll h = phid; h < hid; h++) {\n                ll diff1 = cmp.v[hid] - cmp.v[h + 1];\n                ll diff2 = cmp.v[h + 1] - cmp.v[h];\n                dp[i + 1][h] = (math::pow(mint(2), diff2) - 1) * math::pow(mint(2), diff1) * dp[i][phid] * 2;\n            }\n            dp[i + 1][hid] = dp[i][phid] * 2;\n        }\n        phid = hid;\n    }\n\n    mint ans = 0;\n    for (ll i = 0; i < SIZE; i++) ans += dp[n][i];\n    std::cout << ans.value() << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nconst int N = 105;\nconst int INF = 0x3f3f3f3f;\ntypedef long long ll;\n#define lson l, m, rt<<1\n#define rson m+1, r, rt<<1|1\nconst int MOD = 1e9+7;\n\n\nint h[N];\nint Has[N]; int tot;\nll dp[N][N];\n\nll Pow(ll x, ll y) {\n\tif(y <= 0) return 1;\n\tll result = 1;\n\twhile(y) {\n\t\tif(y & 1)\n\t\t\tresult = result * x % MOD;\n\t\ty >>= 1;\n\t\tx = x*x % MOD;\n\t}\n\treturn result;\n}\n\nint main() {\n\tint n;\n\twhile(~scanf(\"%d\", &n)) {\n\t\ttot = 0;\n\t\tmemset(dp, 0, sizeof(dp));\n\t\th[0] = 0;\n\t\tdp[0][0] = 1;\n\n\t\tfor(int i = 1; i <= n; ++i) {\n\t\t\tscanf(\"%d\", &h[i]);\n\t\t\tHas[++tot] = h[i];\n\t\t}\n\t\tsort(Has + 1, Has + tot + 1);\n\t\ttot = unique(Has+1, Has + tot + 1) - Has - 1;\n\t\t\n\t\tfor(int i = 1; i <= n; ++i) {\n\t\t\th[i] = lower_bound(Has + 1, Has + tot + 1, h[i]) - Has;\n\t\t}\n\t\t\n\t\t\n\t\tfor(int i = 1; i <= n; ++i) {\n\t\t\tdp[i][0] = dp[i-1][0] * 2 % MOD;\n\t\t\tfor(int j = h[i] + 1; j <= h[i-1]; ++j) dp[i][0] = (dp[i][0] + dp[i-1][j] * 2 % MOD) % MOD;\n\n\t\t\tll tmpPow = Pow(2, Has[h[i]] - Has[h[i-1]]);\n\t\t\tfor(int j = 1; j <= min(h[i-1], h[i]) ; ++j) {\n\t\t\t\tdp[i][j] = dp[i-1][j] * tmpPow % MOD;\n\t\t\t}\n\n\t\t\tfor(int j = h[i-1] + 1; j <= h[i]; ++j) {\n\t\t\t\tdp[i][j] = (dp[i][j] + j==1? ( dp[i-1][0] * ( Pow(2, Has[j]) - 2) % MOD * Pow(2, Has[h[i]] - Has[j]) % MOD ) :\n\t\t\t\t\t\t\t\t\t\t\t ( dp[i-1][0] * 2 * (Pow(2, Has[j]-Has[j-1]) - 1) % MOD * Pow(2, Has[h[i]]-Has[j]) % MOD ) \n\t\t\t\t\t\t\t\t\t\t\t ) %MOD;\n\t\t\t}\n\t\t}\n\n\n\t\tll result = 0;\n\t\tfor(int i = 0; i <= tot; ++i) {\n\t\t\tresult = (result + dp[n][i]) % MOD;\n\t\t}\n\t\tprintf(\"%lld\\n\", result);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nconst int MOD = (int)1e9 + 7;\n\nint n,m,h[101],hnum[101],dh[101];///h记录每一列高度 dh记录离散化后的各不相同的高度 hnum记录h对应dh中的位置，即第几高的高度\nlong long dp[101][101];\n\nint pow_(long long x,int y) {///快速幂求 x的y次方\n    long long ans = 1;\n    if(y > 0) {\n        while(y) {\n            if(y % 2)ans = ans * x % MOD;\n            x = x * x % MOD;\n            y /= 2;\n        }\n    }\n    return ans;\n}\n\nint main() {\n    scanf(\"%d\",&n);\n    for(int i = 1;i <= n;i ++) {\n        scanf(\"%d\",&h[i]);\n        dh[++ m] = h[i];///先把高度存到dh数组 下标从1开始，方便后面dp\n    }\n    sort(dh + 1,dh + m + 1);///dh数组排序\n    m = unique(dh + 1,dh + m + 1) - dh - 1;///dh数组离散化去掉重复的高度 m是不相同的高度数\n    for(int i = 1;i <= n;i ++) {\n        hnum[i] = lower_bound(dh + 1,dh + m + 1,h[i]) - dh;///每一列高度在dh数组中对应的位置\n    }\n    dp[0][0]=1;///初始化 当第0列有1个无连续相同的方案\n    for(int i = 1;i <= n;i ++) {///对每一列每个高度段进行更新 更新过程为从下往上\n        (dp[i][0] += dp[i - 1][0] * 2 % MOD) %= MOD;///无连续相同方案  加上前i - 1列无连续相同方案数*2 因为可以是与前一列对应位置同色或者异色一共两种方案\n        for(int j = hnum[i] + 1;j <= hnum[i - 1];j ++)///如果前一列比这一列高，高出的部分也存着接触部分无连续相同的方案 但是可能会重复加上上一步的方案数所以下面更新高出的部分时会避免\n            (dp[i][0] += dp[i - 1][j] * 2 % MOD) %= MOD;\n        int d = pow_(2,h[i] - h[i - 1]);///比前一列高出部分的涂色方案数，如果比前一列低 d就等于1\n        for(int j = 1;j <= min(hnum[i - 1],hnum[i]);j ++) {\n            dp[i][j] = dp[i - 1][j] * d % MOD;///有连续相同颜色的方案数 已经分析过接触部分的颜色一定是定下的 所以这一列接触部分有连续相同部分的方案数由高出部分的变化决定 即 乘上d\n        }\n        for(int j = hnum[i - 1] + 1;j <= hnum[i];j ++) {///更新比前一列高出的部分 j从上一列的高度加1的下标开始\n            if(j > 1)(dp[i][j] += dp[i - 1][0] * (pow_(2,dh[j] - dh[j - 1]) - 1) % MOD * 2 % MOD * pow_(2,h[i] - dh[j]) % MOD) %= MOD;\n            ///一般情况 前i - 1列无连续方案 * （第j块高度变化方案 -1表示去掉重复的 这里会包括一种前面计算过的方案 容易想到) * 剩下几块高度的变化方案数\n            else (dp[1][1] += dp[0][0] * (pow_(2,dh[1]) - 2) % MOD * pow_(2,h[i] - dh[1]) % MOD) %= MOD;\n            ///第一列的第一块高度 记录随意变化方案数 -2表示除去dp[i][0]已经记录过的 勿重复记录\n        }\n    }\n    long long ans = 0;\n    for(int i = 0;i <= hnum[n];i++)\n        (ans += dp[n][i]) %= MOD;\n    printf(\"%lld\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n\ntypedef long long LL;\n\nint main(){\n  int n;\n  cin >> n;\n  LL h;\n  LL pre=0;\n  LL renzoku=0;\n  LL count=0;\n  bool one=true;\n  LL ans=1;\n  vector<LL> a(n);\n  int now=0;\n  for(int i=0;i<n;i++){\n    cin >> h;\n    if(h>1){\n      if(h>pre) count+=h-pre;\n      pre=h;\n      renzoku++;\n      if(one) count--;\n      one=false;\n    }else{\n      a[now]=renzoku;\n      now++;\n      count++;\n      pre=0;\n      renzoku=0;\n      one=true;\n    }\n  }\n  if(h>1){\n    a[now]=renzoku;\n    now++;\n  }\n  count%=1000000006;\n  vector<LL> doub(31);\n  doub[0]=2;\n  for(int i=1;i<31;i++){\n    doub[i]=doub[i-1]*doub[i-1]%1000000007;\n  }\n  LL tmp;\n  for(int i=0;i<now;i++){\n    tmp=1;\n    // cout << a[i] << endl;\n    for(int j=0;j<31;j++){\n      if((a[i]-1)&(1<<j)){\n        tmp=tmp*doub[j]%1000000007;\n      }\n    }\n    // cout << tmp << endl;\n    ans=ans*(tmp+1)%1000000007;\n  }\n  // LL t=1;\n  // cout << \"c\" << count << endl;\n  for(int i=0;i<31;i++){\n    if(count&(1<<i)){\n      // t*=doub[i];\n      ans=ans*doub[i]%1000000007;\n    }\n  }\n  // cout << t << endl;\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define mod 1000000007\n#define N 105\nint n,f[N][N],h[N],w[N],m;\nint ksm(int x,int y)\n{\n\tint s = 1;\n    for(int i = y; i > 0; i >>= 1){\n    \tif(i & 1) s = 1ll * s * x % mod;\n    \tx = 1ll * x * x % mod;\n\t}\n    return s;\n}\n \nint main()\n{\n    scanf(\"%d\",&n);\n    for (int i=1;i<=n;i++) scanf(\"%d\",&h[i]),w[++m]=h[i];\n    std::sort(w+1,w+m+1);\n    m=std::unique(w+1,w+m+1)-w-1;\n    for (int i=1;i<=n;i++) h[i]=std::lower_bound(w+1,w+m+1,h[i])-w;\n    f[0][0]=1;\n    for (int i=1;i<=n;i++)\n    {\n        for (int j=h[i]+1;j<=h[i-1];j++) (f[i][0]+=f[i-1][j]*2%mod)%=mod;\n        (f[i][0]+=f[i-1][0]*2%mod)%=mod;\n        for (int j=1;j<=h[i];j++)\n        {\n            f[i][j]=(ll)f[i-1][j]*ksm(2,w[h[i]]-w[h[i-1]])%mod;\n            if (h[i-1]>=j) continue;\n            if (j>1) (f[i][j]+=(ll)f[i-1][0]*(ksm(2,w[j]-w[j-1])-1)%mod*2%mod*ksm(2,w[h[i]]-w[j])%mod)%=mod;\n            else (f[i][j]+=(ll)f[i-1][0]*(ksm(2,w[j])-2)%mod*ksm(2,w[h[i]]-w[j])%mod)%=mod;\n        }\n    }\n    int ans=0;\n    for (int i=0;i<=m;i++) (ans+=f[n][i])%=mod;\n    printf(\"%d\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 105, mod = 1e9+7, inv2 = (mod+1)/2, phi = mod-1;\n\nint n, a[MAXN], dp[MAXN][MAXN][2];\n\ninline int power(int a, int n)\n{\n\tint ans = 1;\n\tfor (; n; n >>= 1) {\n\t\tif (n&1) ans = (long long)ans*a%mod;\n\t\ta = (long long)a*a%mod;\n\t}\n\treturn ans;\n}\n\nvoid dfs(int L, int R)\n{\n\tif (L == R) {\n\t\tthrow;\n\t} else if (L > R) {\n\t\tdp[L][R][0] = 1;\n\t\treturn;\n\t}\n\tint pos = L, tmp;\n\tvector<int> v, d;\n\tfor (int i = L; i <= R; i++)\n\t\tif (a[i] < a[pos])\n\t\t\tpos = i;\n\ttmp = a[pos];\n        for (int i = L; i <= R; i++)\n\t\ta[i] -= tmp;\n\tint cnt_len = 0, cnt_cnt = 0;\n\tfor (int i = L; i <= R; i++)\n\t\tif (a[i] == 0)\n\t\t\tcnt_cnt++;\n\tif (cnt_cnt == R-L+1) {\n\t\tdp[L][R][0] = power(2, tmp);\n\t\tdp[L][R][1] = ((power(2, R-L+1)-2)%mod+mod)%mod;\n\t\t// cerr << L << \" \" << R << \" \" << dp[L][R][0] << \" \" << dp[L][R][1] << endl;\n\t\treturn;\n\t}\n\tint cnt_sub = 0;\n\tdp[L][R][0] = dp[L][R][1] = 1;\n\tfor (int i = L; i <= R; ) {\n\t\tif (a[i] == 0) {\n\t\t\tint j = i;\n\t\t\twhile (j+1 <= R && a[j+1] == 0) j++;\n\t\t\tcnt_len++;\n\t\t\ti = j+1;\n\t\t} else {\n\t\t\tint j = i;\n\t\t\twhile (j+1 <= R && a[j+1] != 0) j++;\n\t\t\tcnt_sub++;\n\t\t\tdfs(i, j);\n\t\t\tdp[L][R][0] = (long long)dp[L][R][0]*dp[i][j][0]%mod;\n\t\t\tdp[L][R][1] = (long long)dp[L][R][1]*((dp[i][j][0]*2ll+dp[i][j][1])%mod)%mod;\n\t\t}\n\t}\n\tdp[L][R][0] = (long long)dp[L][R][0]*2%mod;\n\tdp[L][R][1] = (long long)dp[L][R][1]*power(2, cnt_cnt)%mod;\n\tdp[L][R][1] = ((dp[L][R][1]-dp[L][R][0])%mod+mod)%mod;\n\tdp[L][R][0] = (long long)dp[L][R][0]*power(2, tmp-1)%mod;\n\t// cerr << L << \" \" << R << \" \" << dp[L][R][0] << \" \" << dp[L][R][1] << endl;\n}\n\nint main()\n{\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++) cin >> a[i];\n\ta[0] = a[n+1] = 0;\n\tint cnt = 0;\n\tfor (int i = 1; i <= n; i++)\n\t\tif (a[i] > a[i-1] && a[i] > a[i+1]) {\n\t\t\tint tar = max(a[i-1], a[i+1]);\n\t\t\tcnt = (cnt+a[i]-tar)%phi;\n\t\t\ta[i] = tar;\n\t\t}\n\tdfs(1, n);\n\tcout << (long long)(dp[1][n][0]+dp[1][n][1])%mod*power(2, cnt)%mod << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<ctime>\n#include<map>\n#include<bitset>\n#include<set>\n#include<assert.h>\n#define LL long long\n#define mp(x,y) make_pair(x,y)\n#define pll pair<long long,long long>\n#define pii pair<int,int>\n#define SZ(x) ((int)x.size())\nusing namespace std;\ninline LL read()\n{\n\tLL f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint stack[20];\ntemplate<typename T>inline void write(T x)\n{\n\tif(x<0){putchar('-');x=-x;}\n    if(!x){putchar('0');return;}\n    int top=0;\n    while(x)stack[++top]=x%10,x/=10;\n    while(top)putchar(stack[top--]+'0');\n}\ntemplate<typename T>inline void pr1(T x){write(x);putchar(' ');}\ntemplate<typename T>inline void pr2(T x){write(x);putchar('\\n');}\ntemplate<typename T>inline void chkmin(T &x,T y){x=x<y?x:y;}\ntemplate<typename T>inline void chkmax(T &x,T y){x=x>y?x:y;}\nconst int MAXN=105;\nconst int mod=1e9+7;\nint pow_mod(int a,int b)\n{\n\tint ret=1;\n\tfor(;b;b>>=1,a=1LL*a*a%mod)if(b&1)ret=1LL*ret*a%mod;\n\treturn ret;\n}\nint f[MAXN][MAXN],g[MAXN][MAXN],h[MAXN],a[MAXN],n;\nvoid ad(int &x,int y){x+=y;if(x>=mod)x-=mod;}\nvoid dl(int &x,int y){x-=y;if(x<0)x+=mod;}\n//f same \n//g not same\nvoid dp(int l,int r,int down)\n{\n\tif(l>r)return ;\n\tif(l==r){g[l][r]=pow_mod(2,h[l]-down);return ;}\n\tint mn=0;for(int i=l;i<=r;i++)if(!mn||h[i]<h[mn])mn=i;\n\tint s1=0,s2=0;\n\tfor(int i=l,nxt;i<=r;i=nxt+1)\n\t{\n\t\tnxt=i;\n\t\tif(h[i]==h[mn])\n\t\t{\n\t\t\ts1=2LL*s1%mod;ad(s1,2LL*s2%mod);\n\t\t\tif(!s2)s2=1;continue;\n\t\t}while(h[nxt+1]>h[mn]&&nxt+1<=r)++nxt;\n\t\tdp(i,nxt,h[mn]+1);\n\t\tint u1=f[i][nxt],u2=g[i][nxt];\n\t\tif(i!=l)\n\t\t{\n\t\t\tif(!s1)\n\t\t\t{\n\t\t\t\tad(s1,2LL*s2*u1%mod);\n\t\t\t\tad(s1,4LL*u2*s2%mod);\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\ts1=(4LL*s1*u2%mod+1LL*s1*u1%mod)%mod;ad(s1,2LL*s2*u1%mod);\n\t\t\t\tad(s1,4LL*u2*s2%mod);\n\t\t\t}\n\t\t\tif(!s2)s2=2LL*u2%mod;\n\t\t\telse s2=2LL*s2*u2%mod;\n\t\t}\n\t\telse s1=u1,s2=2LL*u2%mod;\n\t}\n\tif(h[mn]>down)s2=1LL*s2*pow_mod(2,h[mn]-down)%mod;\n\tf[l][r]=s1;g[l][r]=s2;\n}\nint main()\n{\n\tn=read();for(int i=1;i<=n;i++)h[i]=a[i]=read();\n\tif(n==1)return pr2(pow_mod(2,h[1])),0;\n\tsort(a+1,a+1+n);int ln=unique(a+1,a+1+n)-(a+1);\n\ta[0]=1;\n\tdp(1,n,1);\n\tpr2((f[1][n]+2LL*g[1][n])%mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC target(\"avx\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"inline\")\n#pragma GCC optimize(\"-fgcse\")\n#pragma GCC optimize(\"-fgcse-lm\")\n#pragma GCC optimize(\"-fipa-sra\")\n#pragma GCC optimize(\"-ftree-pre\")\n#pragma GCC optimize(\"-ftree-vrp\")\n#pragma GCC optimize(\"-fpeephole2\")\n#pragma GCC optimize(\"-ffast-math\")\n#pragma GCC optimize(\"-fsched-spec\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC optimize(\"-falign-jumps\")\n#pragma GCC optimize(\"-falign-loops\")\n#pragma GCC optimize(\"-falign-labels\")\n#pragma GCC optimize(\"-fdevirtualize\")\n#pragma GCC optimize(\"-fcaller-saves\")\n#pragma GCC optimize(\"-fcrossjumping\")\n#pragma GCC optimize(\"-fthread-jumps\")\n#pragma GCC optimize(\"-funroll-loops\")\n#pragma GCC optimize(\"-fwhole-program\")\n#pragma GCC optimize(\"-freorder-blocks\")\n#pragma GCC optimize(\"-fschedule-insns\")\n#pragma GCC optimize(\"inline-functions\")\n#pragma GCC optimize(\"-ftree-tail-merge\")\n#pragma GCC optimize(\"-fschedule-insns2\")\n#pragma GCC optimize(\"-fstrict-aliasing\")\n#pragma GCC optimize(\"-fstrict-overflow\")\n#pragma GCC optimize(\"-falign-functions\")\n#pragma GCC optimize(\"-fcse-skip-blocks\")\n#pragma GCC optimize(\"-fcse-follow-jumps\")\n#pragma GCC optimize(\"-fsched-interblock\")\n#pragma GCC optimize(\"-fpartial-inlining\")\n#pragma GCC optimize(\"no-stack-protector\")\n#pragma GCC optimize(\"-freorder-functions\")\n#pragma GCC optimize(\"-findirect-inlining\")\n#pragma GCC optimize(\"-fhoist-adjacent-loads\")\n#pragma GCC optimize(\"-frerun-cse-after-loop\")\n#pragma GCC optimize(\"inline-small-functions\")\n#pragma GCC optimize(\"-finline-small-functions\")\n#pragma GCC optimize(\"-ftree-switch-conversion\")\n#pragma GCC optimize(\"-foptimize-sibling-calls\")\n#pragma GCC optimize(\"-fexpensive-optimizations\")\n#pragma GCC optimize(\"-funsafe-loop-optimizations\")\n#pragma GCC optimize(\"inline-functions-called-once\")\n#pragma GCC optimize(\"-fdelete-null-pointer-checks\")\n#include<bits/stdc++.h>\n#define rep(i,a,b) for (int i=(a); i<=(b); i++)\n#define per(i,a,b) for (int i=(a); i>=(b); i--)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> pii;\n\nconst int maxn = 105;\nconst int MOD = 1000000007;\nint h[maxn], f[maxn][3];\nint n, mx, res, base = 1;\n\ninline int power(int x, int p) {\n\tint res = 1;\n\twhile (p) {\n\t\tif (p & 1) res = 1LL * res * x % MOD;\n\t\tx = 1LL * x * x % MOD; p >>= 1;\n\t}\n\treturn res;\n}\n\npii solve(int l, int r, int base) {\n\t// printf(\"%d %d %d\\n\", l, r, base);\n\tint mn = MOD, cnt = 0;\n\tpii res = make_pair(0, 0), sub;\n\trep (i, l, r)\n\t\tif (h[i] < mn) mn = h[i], cnt = 1;\n\t\telse if (h[i] == mn) cnt++;\n\tif (cnt == r - l + 1) {\n\t\tres.first = (power(2, r - l + 1) + MOD - 2) % MOD;\n\t\tres.second = power(2, mn - base - 1);\n\t\t//printf(\"%d %d %d  %d %d\\n\", l, r, base, res.fi, res.se);\n\t\treturn res;\n\t}\n\tint remain = r - l + 1, last = 0, tmp = 1;\n\tint res0 = 1, res1 = 1;\n\trep (i, l, r + 1)\n\t\tif (!last && h[i] > mn) last = i;\n\t\telse if (last && (i > r || h[i] == mn)) {\n\t\t\tremain -= i - last;\n\t\t\tsub = solve(last, i - 1, mn);\n\t\t\tres0 = 1LL * res0 * (sub.fi + 4LL * sub.se) % MOD;\n\t\t\tres1 = 2LL * res1 * sub.se % MOD;\n\t\t\tlast = 0;\n\t\t}\n\tres0 = (res0 + MOD - res1) % MOD;\n\tres.fi = 1LL * res0 * power(2, remain) % MOD;\n\tres.fi = (res.fi + 1LL * res1 * (power(2, remain) + MOD - 2)) % MOD;\n\tres.se = 1LL * res1 * power(2, mn - base - 1) % MOD;\n\t//printf(\"%d %d %d  %d %d\\n\", l, r, base, res.fi, res.se);\n\treturn res;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\trep (i, 1, n) scanf(\"%d\", &h[i]);\n\trep (i, 1, n)\n\t\tif (h[i] > h[i-1] && h[i] > h[i+1]) {\n\t\t\tbase = 1LL * base * power(2, h[i] - max(h[i-1], h[i+1])) % MOD;\n\t\t\th[i] = max(h[i-1], h[i+1]);\n\t\t}\n\tpii tmp = solve(1, n, 0);\n\tres = 1LL * base * (tmp.fi + 2LL * tmp.se) % MOD;\n\tprintf(\"%d\\n\", res);\n\treturn 0;\n}\n\n/*\n#include<bits/stdc++.h>\n#define rep(i,a,b) for (int i=(a); i<=(b); i++)\n#define per(i,a,b) for (int i=(a); i>=(b); i--)\n#define add(a,b) (a+b>=MOD?a+=b-MOD:a+=b)\nusing namespace std;\ntypedef long long LL;\n\nconst int maxn = 105;\nconst int MOD = 1000000007;\nint h[maxn], f[maxn][3];\nint n, mx, res, base = 1;\n\ninline int power(int x, int p) {\n\tint res = 1;\n\twhile (p) {\n\t\tif (p & 1) res = 1LL * res * x % MOD;\n\t\tx = 1LL * x * x % MOD; p >>= 1;\n\t}\n\treturn res;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\trep (i, 1, n) scanf(\"%d\", &h[i]);\n\trep (i, 1, n)\n\t\tif (h[i] > h[i-1] && h[i] > h[i+1]) {\n\t\t\tbase = 1LL * base * power(2, h[i] - max(h[i-1], h[i+1]));\n\t\t\th[i] = max(h[i-1], h[i+1]);\n\t\t}\n\trep (i, 1, n) mx = max(mx, h[i]);\n\tres = power(2, mx + 1);\t\t//娌℃湁鐩搁偦鐨勭浉鍚岀殑case\n\tint t = 0;\n\trep (i, 1, n) {\t\t\t\t//鏋氫妇鐩稿悓鐨勬渶澶у€?\n\t\tmemset(f, 0, sizeof f);\n\t\tf[0][0] = 1;\n\t\trep (j, 1, n)\t\t\t//鍒嗕笁绉嶆儏鍐佃璁?\n\t\t\tif (j < i) {\n\t\t\t\tadd(f[j][0], f[j-1][0]);\n\t\t\t\tif (h[j] <= h[i]) \n\t\t\t\t\tadd(f[j][1], f[j-1][0]);\n\t\t\t\t\n\t\t\t\tif (h[j] <= h[i])\n\t\t\t\t\tadd(f[j][2], f[j-1][1]);\n\t\t\t\t\n\t\t\t\tadd(f[j][0], f[j-1][2]);\n\t\t\t\tif (h[j] <= h[i]) {\n\t\t\t\t\tadd(f[j][1], f[j-1][2]);\n\t\t\t\t\tadd(f[j][2], f[j-1][2]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (j > i) {\n\t\t\t\tadd(f[j][0], f[j-1][0]);\n\t\t\t\tif (h[j] < h[i]) \n\t\t\t\t\tadd(f[j][1], f[j-1][0]);\n\t\t\t\t\n\t\t\t\tif (h[j] < h[i])\n\t\t\t\t\tadd(f[j][2], f[j-1][1]);\n\t\t\t\t\n\t\t\t\tadd(f[j][0], f[j-1][2]);\n\t\t\t\tif (h[j] < h[i]) {\n\t\t\t\t\tadd(f[j][1], f[j-1][2]);\n\t\t\t\t\tadd(f[j][2], f[j-1][2]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tadd(f[j][1], f[j-1][0]);\n\t\t\t\tadd(f[j][2], f[j-1][1]);\n\t\t\t\tadd(f[j][1], f[j-1][2]);\n\t\t\t\tadd(f[j][2], f[j-1][2]);\n\t\t\t}\n\t\tint tmp = (f[n][0] + f[n][2]) % MOD;\n\t\tt = (t + tmp) % MOD;\n\t\tprintf(\"%d %d\\n\", i, tmp);\n\t\tres = (res + 1LL * tmp * power(2, mx - h[i] + 1)) % MOD;\n\t}\n\tprintf(\"%d\\n\", t);\n\tres = 1LL * res * base % MOD;\n\tprintf(\"%d\\n\", res);\n\treturn 0;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "//Wrong answer on test inf.\n#include<bits/stdc++.h>\n#define rep(i,x,y) for (int i=(x);i<=(y);i++)\n#define ll long long\n#define inf 1000000001\n#define y1 y1___\n#define pii pair<int,int>\n#define fi first\n#define se second\nusing namespace std;\nchar gc(){\n\tstatic char buf[100000],*p1=buf,*p2=buf;\n\treturn p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\nll read(){\n\tchar ch=gc();ll x=0;int op=1;\n\tfor (;!isdigit(ch);ch=gc()) if (ch=='-') op=-1;\n\tfor (;isdigit(ch);ch=gc()) x=(x<<1)+(x<<3)+ch-'0';\n\treturn x*op;\n}\n#define N 105\n#define mod 1000000007\nint ksm(int x,int p){\n\tint ret=1;\n\tfor (;p;p>>=1,x=(ll)x*x%mod) if (p&1) ret=(ll)ret*x%mod;\n\treturn ret;\n}\nint n,h[N];\npii solve(int l,int r,int lim){//区间[l,r]比lim高的部分的方案数\n\tint mi=inf,cnt=0;pii ret;//first：存在相邻格子颜色相同情况的方案数；second：不存在的方案数（固定第一个格子的颜色）\n\trep (i,l,r) if (h[i]<mi) mi=h[i],cnt=1;else if (h[i]==mi) cnt++;\n\tif (cnt==r-l+1){//矩形\n\t\tret.fi=(ksm(2,r-l+1)+mod-2)%mod;\n\t\tret.se=ksm(2,mi-lim-1);\n\t\treturn ret;\n\t}\n\tint rest=r-l+1,s0=1,s1=1,last=0;//rest：上方没有方格的列数；s0,s1：维护上方有方格的列，当前行存在/不存在的方案数\n\trep (i,l,r+1)\n\t\tif (!last&&h[i]>mi) last=i;\n\t\telse if (last&&(h[i]<=mi||i>r)){\n\t\t\trest-=i-last;\n\t\t\tpii tmp=solve(last,i-1,mi);//子问题，递归求解\n\t\t\ts0=(ll)s0*(tmp.fi+4ll*tmp.se%mod)%mod;//*4是因为上一行可以取反，当前行亦然，2*2\n\t\t\ts1=(ll)s1*(2ll*tmp.se%mod)%mod;\n\t\t\tlast=0;\n\t\t}\n\ts0=(s0+mod-s1)%mod;\n\tret.fi=(ll)s0*ksm(2,rest)%mod;//如果上方方格已经存在，剩下的列随意\n\tret.fi=(ret.fi+(ll)s1*(ksm(2,rest)+mod-2)%mod)%mod;//否则需要去掉两种不合法的情况\n\tret.se=(ll)s1*ksm(2,mi-lim-1)%mod;//固定第一个格子（第一行）颜色\n\treturn ret;\n}\nint main(){\n\tn=read();rep (i,1,n) h[i]=read();\n\tint ex=1;\n\trep (i,1,n) if (h[i]>h[i-1]&&h[i]>h[i+1]){\n\t\tex=(ll)ex*ksm(2,h[i]-max(h[i-1],h[i+1]))%mod;\n\t\th[i]=max(h[i-1],h[i+1]);\n\t}\n\tpii ans=solve(1,n,0);\n\tprintf(\"%d\",(ll)ex*(ans.fi+2ll*ans.se%mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\nusing namespace std;\nconst int mo=1000000007;\nint n,a[105];\nint power(int x,int y){\n\tint s=1;\n\tfor (;y;y/=2,x=1ll*x*x%mo)\n\t\tif (y&1) s=1ll*s*x%mo;\n\treturn s;\n}\npii operator *(const pii &a,const pii &b){\n\tint sum=2ll*(a.fi+a.se)*(b.fi+b.se)%mo;\n\treturn pii(2ll*a.fi*b.fi%mo,sum);\n}\npii F(int l,int r,int v){\n\tif (l==r)\n\t\treturn pii(power(2,a[l]-v-1),0);\n\tint mnv=1<<30,las=l;\n\tpii vf;\n\tFor(i,l,r) mnv=min(mnv,a[i]);\n\tFor(i,l,r+1)\n\t\tif (a[i]==mnv||i==r+1){\n\t\t\tif (las!=i){\n\t\t\t\tpii vson=F(las,i-1,mnv);\n\t\t\t\tint v1=vf.fi,v2=vf.se;\n\t\t\t\tint v3=2ll*vson.fi%mo,v4=vson.se;\n\t\t\t\tif (las==l) vf=pii(v3,v4);\n\t\t\t\telse{\n\t\t\t\t\tvf.fi=1ll*v1*v3%mo;\n\t\t\t\t\tvf.se=(2ll*(v1+v2)*(v3+v4)+mo-vf.fi)%mo;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i!=r+1){\n\t\t\t\tif (i==l) vf=pii(1,0);\n\t\t\t\telse{\n\t\t\t\t\tint v1=vf.fi,v2=vf.se;\n\t\t\t\t\tvf=pii(v1,(v1+2ll*v2)%mo);\n\t\t\t\t}\n\t\t\t}\n\t\t\tlas=i+1;\n\t\t}\n\tvf.fi=1ll*vf.fi*power(2,mnv-v-1)%mo;\n\treturn vf;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tFor(i,1,n) scanf(\"%d\",&a[i]);\n\tpii ans=F(1,n,0);\n\tprintf(\"%d\",2ll*(ans.fi+ans.se)%mo);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long h[200009];\nlong long dp[109];\n\nlong long mod = 1e9+7;\nvector< pair<long long,long long> > v[109];\nlong long exp(long long b){\n    if(!b) return 1;\n    if(b&1) return 2*exp(b-1)%mod;\n    long long k = exp(b/2);\n    return k*k%mod;\n}\nmain(){\n    long long n;\n    cin >> n;\n    for(long long i = 1; i <= n; i++){\n        cin >> h[i];\n    }\n    for(long long i = 1; i <= n; i++){\n        if(h[i-1] > h[i]) continue;\n        long long lo = max((long long)2,h[i-1]+1), hi = h[i];\n        for(long long j = i; j <= n; j++){\n            if(max((long long)0,hi - max(lo,h[j]+1)+1)) v[i].push_back({j-1,max((long long)0,hi - max(lo,h[j]+1)+1)});\n            hi = min(hi,h[j]);\n        }\n        if(max((long long)0,hi-lo+1)) v[i].push_back({n,max((long long)0,hi-lo+1)});\n    }\n    for(long long i = n; i >= 1; i--){\n        for(long long j = i; j <= n; j++){\n        long long A = 0;\n            for(long long k = i; k <= j; k++){\n                for(long long t= 0; t < v[k]. size(); t++){\n                    long long r = v[k][t].first, N =  v[k][t].second;\n                    if(r <= j) A+= N;\n                }\n            }\n        if(j == n) dp[i] = (dp[i] + exp(A)) % mod;\n        else dp[i] = (dp[i] + dp[j+1] * exp(A))% mod;\n        }\n    }\n    cout<<  dp[1] * 2 % mod << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h> \n#define ll long long\n#define N 105\n#define mod 1000000007\nusing namespace std;\nint n,f[N][N],h[N],w[N],tot;\ninline int ksm(int x,int p){\n\tif(p<0)return 1;\n\tint ret=1;\n\twhile(p){\n\t\tif(p&1)ret=ret*x%mod;\n\t\tx=x*x%mod;\n\t\tp>>=1;\n\t}\n\treturn ret;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i)scanf(\"%d\",&h[i]),w[++tot]=h[i];\n\tsort(w+1,w+tot+1);\n\ttot=unique(w+1,w+tot+1)-w-1;\n\tfor(int i=1;i<=n;++i)h[i]=lower_bound(w+1,w+tot+1,h[i])-w;\n\tf[0][0]=1;\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=h[i]+1;j<=h[i-1];++j)(f[i][0]+=f[i-1][j]*2%mod)%=mod;\n\t\t(f[i][0]+=f[i-1][0]*2%mod)%=mod;\n\t\tfor(int j=1;j<=h[i];++j){\n\t\t\tf[i][j]=(ll)f[i-1][j]*ksm(2,w[h[i]]-w[h[i-1]])%mod;\n\t\t\tif(h[i-1]>=j)continue;\n\t\t\tif(j>1)(f[i][j]+=(ll)f[i-1][0]*(ksm(2,w[j]-w[j-1])-1)%mod*2%mod*ksm(2,w[h[i]]-w[j])%mod)%=mod;\n\t\t\telse (f[i][j]+=(ll)f[i-1][0]*(ksm(2,w[j])-2)%mod*ksm(2,w[h[i]]-w[j])%mod)%=mod;\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=0;i<=tot;++i)(ans+=f[n][i])%=mod;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*----------------by syr----------------*/\n/*\n\n         iii                  ii\n     rBQBBBBBBE       BBR iBBBBQBBL     XBBBBBBQBBBBB\n   iBBQJ    7BBB      BBsSBBr   BBQ      i      cBBB\n  rBBU       iBBw     BBBQi     HBBi           KBBi\n  BBH         BB5    iBBB       isL          wBB5\n GBB         iBBi    6BB                   iBBB\n BBQ         BQB     BBD                  QBBi\n BBB        BQB     iQBi                1BBv\n sBBg     wBBB      QBB               iBBB\n  7BBBBBBBBBi       BBR              wBBBBBBBBBBBBB\n     irvi           ii               ii    i i iii\n                i5U\n               BBB\n               BB7\n              1BB\n      iPBBBBBKBBR    JBR1       rQBO   BR  UBQP  iBBQi\n    7BBBGs7sXBBBi     QBBr     gBBE   rBB BB2BB7HBZQBB\n   QBBi      sBQ       BBB   iBBB     SQBBR  BBBB  cBQ\n  gBQ        BBg        BBB KBBi      MBBH   BBB   BBs\n iBBv       iBBi         QBBBL        BBR   pBB   iBB\n pBB        BBB         iBBBB        iBB    BBL   KBB\n MBB       BBBR        BBB JBBi      DBR   iBQ    BBL\n GBB     7BBBB2      PBBH   BBBi     BQr   DBB   iBB\n  BQBXwgBBP BB7    1BBB      BBQ7   1BB    BBc   BBB\n   2BBBBw   BB    EBBS        QBBi  HBa   iBB    BB7\n*/\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define PH push\n#define MP make_pair\n#define PB push_back\n#define fst first\n#define snd second\n#define FOR(i, x, y) for(int i = (x); i < (y); ++i)\n#define REP(i, x, y) for(int i = (x); i <= (y); ++i)\n#define x0 x0123456789\n#define y0 y0123456789\n#define x1 x1234567890\n#define y1 y1234567890\n#define x2 x2345678901\n#define y2 y2345678901\ntypedef double db;\ntypedef long long ll;\ntypedef long double ldb;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int INF = 1e9 + 7;\nconst int maxn = 105;\n\nint n;\nint a[maxn];\nint f[maxn][maxn], g[maxn][maxn];\n\ninline int mul(int x, int y){return (1ll * x * y) % INF;}\ninline int add(int x, int y){return (x + y) % INF;}\ninline int sub(int x, int y){return (x - y + INF) % INF;}\n\ninline int qpow(int x, int y){\n\tint ret = 1;\n\tfor(; y; y >>= 1){\n\t\tif(y & 1)\n\t\t\tret = mul(ret, x);\n\t\tx = mul(x, x);\n\t}\n\treturn ret;\n}\n\nvoid solve(int l, int r){\n\tint mn = INF, ept = 0;\n\tf[l][r] = g[l][r] = 1;\n\tREP(i, l, r){\n\t\tmn = min(mn, a[i]);\n\t}\n\tREP(i, l, r){\n\t\ta[i] -= mn;\n\t\tif(!a[i]) ++ept;\n\t}\n\tfor(int i = l; i <= r; ){\n\t\tif(a[i]){\n\t\t\tint j;\n\t\t\tfor(j = i; a[j]; ++j);\n\t\t\tsolve(i, j - 1);\n\t\t\tf[l][r] = mul(f[l][r], add(f[i][j - 1], g[i][j - 1]));\n\t\t\tg[l][r] = mul(g[l][r], g[i][j - 1]);\n\t\t\ti = j + 1;\n\t\t}\n\t\telse ++i;\n\t}\n\tg[l][r] = mul(g[l][r], 2);\n\tf[l][r] = mul(f[l][r], qpow(2, ept));\n\tf[l][r] = sub(f[l][r], g[l][r]);\n\tg[l][r] = mul(g[l][r], qpow(2, mn - 1));\n\tf[l][r] = add(f[l][r], g[l][r]);\n\t//printf(\"l = %d r = %d f = %d g = %d\\n\", l, r, f[l][r], g[l][r]);\n\treturn;\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tFOR(i, 0, n){\n\t\tscanf(\"%d\", a + i);\n\t}\n\tsolve(0, n - 1);\n\tprintf(\"%d\\n\", f[0][n - 1]);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC target(\"avx\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"inline\")\n#pragma GCC optimize(\"-fgcse\")\n#pragma GCC optimize(\"-fgcse-lm\")\n#pragma GCC optimize(\"-fipa-sra\")\n#pragma GCC optimize(\"-ftree-pre\")\n#pragma GCC optimize(\"-ftree-vrp\")\n#pragma GCC optimize(\"-fpeephole2\")\n#pragma GCC optimize(\"-ffast-math\")\n#pragma GCC optimize(\"-fsched-spec\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC optimize(\"-falign-jumps\")\n#pragma GCC optimize(\"-falign-loops\")\n#pragma GCC optimize(\"-falign-labels\")\n#pragma GCC optimize(\"-fdevirtualize\")\n#pragma GCC optimize(\"-fcaller-saves\")\n#pragma GCC optimize(\"-fcrossjumping\")\n#pragma GCC optimize(\"-fthread-jumps\")\n#pragma GCC optimize(\"-funroll-loops\")\n#pragma GCC optimize(\"-fwhole-program\")\n#pragma GCC optimize(\"-freorder-blocks\")\n#pragma GCC optimize(\"-fschedule-insns\")\n#pragma GCC optimize(\"inline-functions\")\n#pragma GCC optimize(\"-ftree-tail-merge\")\n#pragma GCC optimize(\"-fschedule-insns2\")\n#pragma GCC optimize(\"-fstrict-aliasing\")\n#pragma GCC optimize(\"-fstrict-overflow\")\n#pragma GCC optimize(\"-falign-functions\")\n#pragma GCC optimize(\"-fcse-skip-blocks\")\n#pragma GCC optimize(\"-fcse-follow-jumps\")\n#pragma GCC optimize(\"-fsched-interblock\")\n#pragma GCC optimize(\"-fpartial-inlining\")\n#pragma GCC optimize(\"no-stack-protector\")\n#pragma GCC optimize(\"-freorder-functions\")\n#pragma GCC optimize(\"-findirect-inlining\")\n#pragma GCC optimize(\"-fhoist-adjacent-loads\")\n#pragma GCC optimize(\"-frerun-cse-after-loop\")\n#pragma GCC optimize(\"inline-small-functions\")\n#pragma GCC optimize(\"-finline-small-functions\")\n#pragma GCC optimize(\"-ftree-switch-conversion\")\n#pragma GCC optimize(\"-foptimize-sibling-calls\")\n#pragma GCC optimize(\"-fexpensive-optimizations\")\n#pragma GCC optimize(\"-funsafe-loop-optimizations\")\n#pragma GCC optimize(\"inline-functions-called-once\")\n#pragma GCC optimize(\"-fdelete-null-pointer-checks\")\n// by piano\n#include<bits/stdc++.h>\n#define rep(i,a,b) for (int i=(a); i<=(b); i++)\n#define per(i,a,b) for (int i=(a); i>=(b); i--)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> pii;\n \nconst int maxn = 105;\nconst int MOD = 1000000007;\nint bin[maxn], h[maxn], f[maxn][3];\nint n, mx, res, base = 1;\n \ninline int power(int x, int p) {\n\tint res = 1;\n\twhile (p) {\n\t\tif (p & 1) res = 1LL * res * x % MOD;\n\t\tx = 1LL * x * x % MOD; p >>= 1;\n\t}\n\treturn res;\n}\n \npii solve(int l, int r, int base) {\n\t// printf(\"%d %d %d\\n\", l, r, base);\n\tint mn = MOD, cnt = 0;\n\tpii res = make_pair(0, 0), sub;\n\trep (i, l, r)\n\t\tif (h[i] < mn) mn = h[i], cnt = 1;\n\t\telse if (h[i] == mn) cnt++;\n\tif (cnt == r - l + 1) {\n\t\tres.first = (power(2, r - l + 1) + MOD - 2) % MOD;\n\t\tres.second = power(2, mn - base - 1);\n\t\t//printf(\"%d %d %d  %d %d\\n\", l, r, base, res.fi, res.se);\n\t\treturn res;\n\t}\n\tint remain = r - l + 1, last = 0, tmp = 1;\n\tint res0 = 1, res1 = 1;\n\trep (i, l, r + 1)\n\t\tif (!last && h[i] > mn) last = i;\n\t\telse if (last && (i > r || h[i] == mn)) {\n\t\t\tremain -= i - last;\n\t\t\tsub = solve(last, i - 1, mn);\n\t\t\tres0 = 1LL * res0 * (sub.fi + 4LL * sub.se) % MOD;\n\t\t\tres1 = 2LL * res1 * sub.se % MOD;\n\t\t\tlast = 0;\n\t\t}\n\tres0 = (res0 + MOD - res1) % MOD;\n\tres.fi = 1LL * res0 * power(2, remain) % MOD;\n\tres.fi = (res.fi + 1LL * res1 * (power(2, remain) + MOD - 2)) % MOD;\n\tres.se = 1LL * res1 * power(2, mn - base - 1) % MOD;\n\t//printf(\"%d %d %d  %d %d\\n\", l, r, base, res.fi, res.se);\n\treturn res;\n}\n \nint main() {\n\tscanf(\"%d\", &n);\n\trep (i, 1, n) scanf(\"%d\", &h[i]);\n\tif (n == 1) {\n\t\tprintf(\"%d\\n\", power(2, h[1]));\n\t\treturn 0;\n\t}\n\trep (i, 1, n)\n\t\tif (h[i] > h[i-1] && h[i] > h[i+1]) {\n\t\t\tbase = 1LL * base * power(2, h[i] - max(h[i-1], h[i+1])) % MOD;\n\t\t\th[i] = max(h[i-1], h[i+1]);\n\t\t}\n\tpii tmp = solve(1, n, 0);\n\tres = 1LL * base * (tmp.fi + 2LL * tmp.se) % MOD;\n\tprintf(\"%d\\n\", res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 105;\nconst int MOD = 1e9 + 7;\nint n, h[N];\nint qpow(int x, int k) {\n    int r = 1;\n    while(k) {\n        if(k & 1) r = (ll)r * x % MOD;\n        x = (ll)x * x % MOD;\n        k >>= 1;\n    }\n    return r;\n}\ntypedef pair<int, int> pii;\npii dfs(int l, int r) {\n    int mn = 2e9, mc = 0;\n    for(int i = l; i <= r; i++) {\n        if(h[i]) {\n            if(mn == h[i]) mc++;\n            else if(mn > h[i]) mc = 1;\n            mn = min(mn, h[i]);\n        }\n    }\n    // printf(\"mc:%d mn:%d\\n\", mc, mn);\n    vector<pii> res;\n    int st = -1, t = 0;\n    for(int i = l; i <= r; i++) {\n        h[i] -= mn;\n        if(h[i]) {\n            if(st == -1) st = i, t = 1;\n            else {\n                t++;\n            }\n        } else {\n            if(t) {\n                res.push_back(dfs(st, st + t - 1));\n                t = 0;\n                st = -1;\n            }\n        }\n    }\n    if(t) {\n        res.push_back(dfs(st, st + t - 1));\n    }\n    ll o1 = qpow(2, mc), o2 = qpow(2, mn);\n    ll r1 = o1, r11 = o2 - 2, ret2 = o2;\n    for(pii p : res) {\n        ret2 = ret2 * p.second % MOD;\n        r1 = r1 * (p.first + p.second) % MOD;\n        r11 = r11 * p.second % MOD;\n    }\n    // printf(\"%d  %d  mn:%d  mc:%d  ret1:%d  ret2:%d\\n\", l, r, mn, mc, ret1, ret2);\n    return pii((r1 + r11) % MOD, ret2);\n}\nint main() {\n    int n;\n    cin >> n;\n    for(int i = 0; i < n; i++) {\n        cin >> h[i];\n    }\n    pii res = dfs(0, n - 1);\n    cout << res.first % MOD << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define N 100005\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> Pair;\n\ntemplate <class T> inline void read(T &x) {\n\tchar ch; bool flag = false;\n\twhile (!isdigit(ch = getchar())) flag |= ch == '-';\n\tfor (x = ch ^ 48; isdigit(ch = getchar()); x = x * 10 + (ch ^ 48));\n\tif (flag) x = -x;\n}\n\ninline int input() {\n\tint x; char ch; bool flag = false;\n\twhile (!isdigit(ch = getchar())) flag |= ch == '-';\n\tfor (x = ch ^ 48; isdigit(ch = getchar()); x = x * 10 + (ch ^ 48));\n\treturn flag ? -x : x;\n}\n\nconst int mod = 1e9 + 7;\ninline int add(int x, int y) { x += y; return x >= mod ? x - mod : x; }\ninline void inc(int &x, int y) { x += y; x -= x >= mod ? mod : 0; }\n\ninline int Power(int x, int y) {\n\tint res = 1;\n\twhile (y) {\n\t\tif (y & 1) res = (ll) res * x % mod;\n\t\tx = (ll) x * x % mod, y >>= 1;\n\t} return res;\n}\n\ntemplate <class T> void chkmax(T &x, T y) { x = x > y ? x : y; }\ntemplate <class T> void chkmin(T &x, T y) { x = x < y ? x : y; }\ntemplate <class T> T gcd(T x, T y) { return !y ? x : gcd(x % y, y); }\n\nint n;\nint h[N];\n\nPair solve(int l, int r, int lim) {\n\tbool flag = false; int upp = h[l]; Pair res;\n\tfor (int i = l + 1; i <= r; ++i) {\n\t\tflag |= h[i] != h[i - 1];\n\t\tchkmin(upp, h[i]);\n\t}\n\tif (!flag) {\n\t\tres.fi = add(Power(2, r - l + 1), mod - 2);\n\t\tres.se = Power(2, upp - lim - 1);\n\t\treturn res;\n\t}\n\t\n\tint cnt = 0, last = 0, s0 = 1, s1 = 1;\n\tfor (int i = l; i <= r + 1; ++i) {\n\t\tif (h[i] == upp) ++cnt;\n\t\tif (!last && h[i] > upp) last = i;\n\t\telse if (last && (h[i] == upp || i > r)) {\n\t\t\tPair tmp = solve(last, i - 1, upp);\n\t\t\ts0 = (ll) s0 * (tmp.fi + 4ll * tmp.se % mod) % mod;\n\t\t\ts1 = (ll) s1 * tmp.se * 2 % mod;\n\t\t\tlast = 0;\n\t\t}\n\t}\n\t\n\tinc(s0, mod - s1);\n\tres.fi = (ll) s0 * Power(2, cnt) % mod;\n\tinc(res.fi, (ll) s1 * add(Power(2, cnt), mod - 2) % mod);\n\tres.se = (ll) s1 * Power(2, upp - lim - 1) % mod;\n\treturn res;\n}\n\nint main() {\n\tn = input();\n\tfor (int i = 1; i <= n; ++i) h[i] = input();\n\tif (n == 1) return printf(\"%d\\n\", Power(2, h[1])), 0;\n\tll Ex = 1;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (h[i] <= h[i - 1] || h[i] <= h[i + 1]) continue;\n\t\tEx = Ex * Power(2, h[i] - max(h[i - 1], h[i + 1])) % mod;\n\t\th[i] = max(h[i - 1], h[i + 1]);\n\t}\n\tPair ans = solve(1, n, 0);\n\tprintf(\"%lld\\n\", Ex * add(ans.fi, add(ans.se, ans.se)) % mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\n\nusing namespace std;\n\ntypedef long long ll;\n\nll pow_mod(ll x,int k) {\n  ll ans=1;\n  while (k) {\n  \tif (k&1) ans=ans*x%MOD;\n  \tx=x*x%MOD;\n  \tk>>=1;\n  }\n  return ans;\n} \n\nvector <int> son[105];\nint len[105],size[105];\n\nint f[105],g[105];\n\nvoid dfs(int x) {\n  int ans=1,s=size[x];\n  f[x]=1;g[x]=0;\n  for(int i=0;i<son[x].size();i++) {\n  \tint u=son[x][i];\n  \tdfs(u);\n  \tg[x]=((ll)g[x]*(f[u]+g[u])+(ll)f[x]*g[u])%MOD;\n  \tf[x]=(ll)f[x]*f[u]%MOD;\n  \ts-=size[u];\n  }\n  g[x]=((ll)g[x]*pow_mod(2LL,s)%MOD+(ll)f[x]*(pow_mod(2LL,s)-1+MOD))%MOD;\n  f[x]=(ll)f[x]*pow_mod(2LL,len[x])%MOD;\n} \n\nint num[105];\n\nint st[105],id[105];\n\nint solve(int l,int r) {\n  int cnt=0,top=0;\n  st[0]=l-1;\n  for(int i=l;i<=r;i++) {\n  \twhile (top&&num[st[top]]>=num[i])\n  \t  if (num[i]==num[st[top]]) {\n  \t  \t  st[top]=i;\n  \t  \t  break;\n\t\t}\n\t  else if (num[i]>num[st[top-1]]) {\n\t  \tint v=++cnt;\n\t  \tson[v].clear();\n\t  \tson[v].push_back(id[top]);\n\t  \tlen[id[top]]=num[st[top]]-num[i];\n\t  \tsize[id[top]]=i-st[top-1]-2;\n\t  \tst[top]=i;id[top]=v;\n\t  \tbreak;\n\t  }\n\t  else {\n\t  \tlen[id[top]]=num[st[top]]-num[st[top-1]];\n\t  \tsize[id[top]]=i-st[top-1]-2;\n\t  \tson[id[top-1]].push_back(id[top]);\n\t  \ttop--;\n\t  }\n\tif (st[top]!=i) {\n\t\tint v=++cnt;\n\t\tst[++top]=i;id[top]=v;\n\t\tson[v].clear();\n\t}\n  }\n  while (top) {\n  \tlen[id[top]]=num[st[top]]-num[st[top-1]];\n  \tsize[id[top]]=r-st[top-1]-1;\n  \tif (top>1) son[id[top-1]].push_back(id[top]);\n  \ttop--;\n  }\n  dfs(id[1]);\n  return (f[id[1]]+g[id[1]])%MOD;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\",&n);\n  for(int i=1;i<=n;i++) {\n  \tscanf(\"%d\",&num[i]);\n  \tnum[i]--;\n  }\n  int ans=1;\n  for(int i=1;i<=n;i++) {\n    if (!num[i]||!num[i-1]) ans=ans*2LL%MOD;\n    if (num[i]&&!num[i+1]) {\n    \tint l=i;\n    \twhile (num[l-1]) l--;\n\t\tans=ans*solve(l,i)%MOD; \n\t}\n  }\n  printf(\"%d\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nconst int MOD = (int)1e9 + 7;\n\nint n,m,h[101],hnum[101],dh[101];///h记录每一列高度 dh记录离散化后的各不相同的高度 hnum记录h对应dh中的位置，即第几高的高度\nlong long dp[101][101];///记录第i列第n块高度往上的方案数\n\nint pow_(long long x,int y) {///快速幂求 x的y次方\n    long long ans = 1;\n    if(y > 0) {\n        while(y) {\n            if(y % 2)ans = ans * x % MOD;\n            x = x * x % MOD;\n            y /= 2;\n        }\n    }\n    return ans;\n}\n\nint main() {\n    scanf(\"%d\",&n);\n    for(int i = 1;i <= n;i ++) {\n        scanf(\"%d\",&h[i]);\n        dh[++ m] = h[i];///先把高度存到dh数组 下标从1开始，方便后面dp\n    }\n    sort(dh + 1,dh + m + 1);///dh数组排序\n    m = unique(dh + 1,dh + m + 1) - dh - 1;///dh数组离散化去掉重复的高度 m是不相同的高度数\n    for(int i = 1;i <= n;i ++) {\n        hnum[i] = lower_bound(dh + 1,dh + m + 1,h[i]) - dh;///每一列高度在dh数组中对应的位置\n    }\n    dp[0][0]=1;///初始化 当第0列有1个无连续相同的方案\n    for(int i = 1;i <= n;i ++) {///对每一列每个高度段进行更新 更新过程为从下往上\n        (dp[i][0] += dp[i - 1][0] * 2 % MOD) %= MOD;///无连续相同方案  加上前i - 1列无连续相同方案数*2 因为可以是与前一列对应位置同色或者异色一共两种方案\n        for(int j = hnum[i] + 1;j <= hnum[i - 1];j ++)///如果前一列比这一列高，高出的部分也存着接触部分无连续相同的方案 但是可能会重复加上上一步的方案数所以下面更新高出的部分时会避免\n            (dp[i][0] += dp[i - 1][j] * 2 % MOD) %= MOD;\n        int d = pow_(2,h[i] - h[i - 1]);///比前一列高出部分的涂色方案数，如果比前一列低 d就等于1\n        for(int j = 1;j <= min(hnum[i - 1],hnum[i]);j ++) {\n            dp[i][j] = dp[i - 1][j] * d % MOD;///有连续相同颜色的方案数 已经分析过接触部分的颜色一定是定下的 所以这一列接触部分有连续相同部分的方案数由高出部分的变化决定 即 乘上d\n        }\n        for(int j = hnum[i - 1] + 1;j <= hnum[i];j ++) {///更新比前一列高出的部分 j从上一列的高度加1的下标开始\n            if(j > 1)(dp[i][j] = dp[i - 1][0] * (pow_(2,dh[j] - dh[j - 1]) - 1) % MOD * 2 % MOD * pow_(2,h[i] - dh[j]) % MOD) %= MOD;\n            ///一般情况 前i - 1列无连续方案 * （第j块高度变化方案 -1表示去掉无连续相同方案) * 2 * 剩下几块高度的变化方案数\n            //else (dp[1][1] = dp[0][0] * (pow_(2,dh[1]) - 2) % MOD * pow_(2,h[i] - dh[1]) % MOD) %= MOD;\n            ///第一列的第一块高度 记录随意变化方案数 -2表示除去dp[i][0]已经记录过的无连续相同方案 勿重复记录\n        }\n    }\n    long long ans = 0;\n    for(int i = 0;i <= hnum[n];i++)\n        (ans += dp[n][i]) %= MOD;\n    printf(\"%lld\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define mp make_pair\n#define PI pair<int,int>\n#define poly vector<ll>\n#define For(i,l,r) for(int i=(int)(l);i<=(int)(r);i++)\n#define Rep(i,r,l) for(int i=(int)(r);i>=(int)(l);i--)\n#define pb push_back\n#define fi first\n#define se second\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define getchar gc\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\ninline ull rnd(){\n\treturn ((ull)rand()<<30^rand())<<4|rand()%4;\n}\nconst int B=32000,N=10000005,mod=998244353;\nint qq,q[N];\nll F[B+1],G[B+1];\nPI f[N];\nPI operator +(PI a,PI b){\n\treturn mp((ll)a.fi*b.fi%mod,((ll)a.fi*b.se*2+(ll)a.se*b.fi*2+(ll)a.se*b.se+(ll)a.fi*b.fi*2)%mod);\n}\nll pw(int h){\n\treturn F[h%B]*G[h/B]%mod;\n}\nvoid del(PI &x,int h){\n\tx.fi=x.fi*pw(h)%mod;\n}\nint main(){\n\tFor(i,F[0]=1,B)F[i]=F[i-1]*2%mod;\n\tFor(i,G[0]=1,B)G[i]=G[i-1]*F[B]%mod;\n\tint n=read();\n\tFor(i,1,n){\n\t\tint h=read();\n\t\tPI zs=mp(1,0);\n\t\tif(qq&&q[qq]>=h){\n\t\t\twhile(q[qq-1]>=h){\n\t\t\t\tdel(f[qq],q[qq]-q[qq-1]); \n\t\t\t\tf[qq-1]=f[qq-1]+f[qq]; qq--;\n\t\t\t}\n\t\t\tdel(f[qq],q[qq]-h);\n\t\t\tq[qq]=h; f[qq]=f[qq]+zs;\n\t\t}else{\n\t\t\tq[++qq]=h;\n\t\t\tf[qq]=zs;\n\t\t\t\n\t\t}\n\t}\n\tq[0]=1;\n\t//For(i,1,qq)cout<<f[i].fi<<\" \"<<f[i].se<<endl;\n\twhile(qq){\n\t\tdel(f[qq],q[qq]-q[qq-1]); qq--;\n\t\tif(qq)f[qq]=f[qq]+f[qq+1];\n\t}\n\tcout<<((ll)f[1].fi*2+f[1].se)%mod<<endl;\n}\n/*\n3\n1 2 2\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nconst ll MAX=105;\nconst ll INF=0x3f3f3f3f;\nconst ll MOD=1e9+7;\nll N,ans,h[MAX],dp[MAX][MAX],order[MAX],hg[MAX],hg_cnt;\npll g[MAX];\nll power(ll x,ll y){\n    if(y==0) return 1;\n    ll t=power(x,y/2);\n    if(y%2) return t*t%MOD*x%MOD;\n    return t*t%MOD;\n}\nint main(){\n    scanf(\"%lld\",&N);\n    for(ll i=0;i<N;i++) {\n        scanf(\"%lld\",&h[i]);\n        g[i].first=h[i],g[i].second=i;\n    }\n    sort(g,g+N);\n    hg[hg_cnt++]=1;\n    for(ll i=0;i<N;i++) {\n        if(hg[hg_cnt-1]!=g[i].first) hg[hg_cnt++]=g[i].first;\n        order[g[i].second]=hg_cnt-1;\n    }\n    dp[0][order[0]]=2;\n    for(ll i=0;i<order[0];i++) dp[0][i]=(power(2,hg[order[0]]-hg[i]+1)-power(2,hg[order[0]]-hg[i+1]+1)+MOD)%MOD;\n    for(ll i=1;i<N;i++){\n        for(ll j=0;j<=min(order[i],order[i-1])-1;j++) dp[i][j]=dp[i-1][j];\n        for(ll j=min(order[i],order[i-1]);j<=order[i-1];j++) dp[i][min(order[i],order[i-1])]+=2*dp[i-1][j],dp[i][min(order[i],order[i-1])]%=MOD;\n        if(order[i]>order[i-1]){\n            ll t=power(2,hg[order[i]]-hg[order[i-1]]);\n            for(ll j=0;j<order[i-1];j++) dp[i][j]=(dp[i][j]*t)%MOD;\n            dp[i][order[i]]=dp[i][order[i-1]];\n            for(ll j=order[i]-1;j>=order[i-1];j--) dp[i][j]=(power(2,hg[order[i]]-hg[j])-power(2,hg[order[i]]-hg[j+1])+MOD)*dp[i][order[i-1]]%MOD;\n        }\n    }\n    for(ll i=0;i<=order[N-1];i++) ans+=dp[N-1][i],ans%=MOD;\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": " # include <bits/stdc++.h>\n    # define \tll \t\tlong long\n    using namespace std;\n    const int inf = 0x3f3f3f3f, INF = 0x7fffffff;\n    const ll  infll = 0x3f3f3f3f3f3f3f3fll, INFll = 0x7fffffffffffffffll;\n    int read(){\n    \tint tmp = 0, fh = 1; char ch = getchar();\n    \twhile (ch < '0' || ch > '9'){ if (ch == '-') fh = -1; ch = getchar(); }\n    \twhile (ch >= '0' && ch <= '9'){ tmp = tmp * 10 + ch - '0'; ch = getchar(); }\n    \treturn tmp * fh;\n    }\n    const int P = 1e9 + 7, N = 210;\n    int n, h[N];\n    ll f[N][2][2][2], g0[2][2][2], g1[2][2][2], use[N];\n    ll power(ll x, int y){\n    \tll i = x; x = 1;\n    \twhile (y > 0){\n    \t\tif (y % 2 == 1) x = x * i % P;\n    \t\ti = i * i % P;\n    \t\ty /= 2;\n    \t}\n    \treturn x;\n    }\n    int main(){\n    //\tfreopen(\".in\", \"r\", stdin);\n    //\tfreopen(\".out\", \"w\", stdout);\n    \tn = read();\n    \tfor (int i = 1; i <= n; i++) h[i] = read(); \n    \th[++n] = 1;\n    \tint las = inf, lim, tmp, cnt = 0;\n    \twhile (cnt < n){\n    \t\tlim = -1;\n    \t\tfor (int j = 1; j <= n; j++)\n    \t\t\tif (use[j] == 0) \n    \t\t\t\tlim = max(h[j], lim);\n    \t\ttmp = las - lim;\n    \t\tfor (int j = 1; j <= n; j++){\n    \t\t\tif (use[j] == 2) continue;\n    \t\t\tif (use[j] == 0){\n    \t\t\t\tif (h[j] < lim) continue;\n    \t\t\t\tuse[j] = 1;\n    \t\t\t\tf[j][0][0][0] = f[j][0][1][1] = 1;\n    \t\t\t\tcnt++;\n    \t\t\t}\n    \t\t\telse if (use[j] == 1){\n    \t\t\t\tf[j][0][0][0] = f[j][0][1][1] = (f[j][0][1][1] + f[j][0][0][0]) * power(2, tmp - 1) % P;\n    \t\t\t\tf[j][0][0][1] = f[j][0][1][0] = (f[j][0][0][1] + f[j][0][1][0]) * power(2, tmp - 1) % P;\n    \t\t\t\tif (tmp % 2 == 1){\n    \t\t\t\t\tswap(f[j][1][0][0], f[j][1][1][1]);\n    \t\t\t\t\tswap(f[j][1][0][1], f[j][1][1][0]);\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\tif (j != 1 && use[j - 1] != 0){\n    \t\t\t\tuse[j] = 2;\n    \t\t\t\tint k = j - 1;\n    \t\t\t\twhile (use[k] == 2) k--;\n    \t\t\t\tfor (int t0 = 0; t0 <= 1; t0++)\n    \t\t\t\t\tfor (int t1 = 0; t1 <= 1; t1++)\n    \t\t\t\t\t\tfor (int t2 = 0; t2 <= 1; t2++)\n    \t\t\t\t\t\t\tg0[t0][t1][t2] = f[k][t0][t1][t2], g1[t0][t1][t2] = f[j][t0][t1][t2];\n    \t\t\t\tfor (int t0 = 0; t0 <= 1; t0++)\n    \t\t\t\t\tfor (int t1 = 0; t1 <= 1; t1++){\n    \t\t\t\t\t\tf[k][0][t0][t1] = (g0[0][t0][1] * g1[0][0][t1] + g0[0][t0][0] * g1[0][1][t1]) % P;\n    \t\t\t\t\t\tf[k][1][t0][t1] = ((g0[1][t0][1] + g0[1][t0][0]) * (g1[1][0][t1] + g1[1][1][t1] + g1[0][0][t1] + g1[0][1][t1])) % P;\n    \t\t\t\t\t\tf[k][1][t0][t1] = (f[k][1][t0][t1] + (g0[0][t0][1] + g0[0][t0][0]) * (g1[1][0][t1] + g1[1][1][t1])) % P;\n    \t\t\t\t\t\tf[k][1][t0][t1] = (f[k][1][t0][t1] + g0[0][t0][1] * g1[0][1][t1] + g0[0][t0][0] * g1[0][0][t1]) % P;\n    \t\t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t\tlas = lim; \n    \t}\n    \tll ans = 0;\n    \tfor (int t0 = 0; t0 <= 1; t0++)\n    \t\tfor (int t1 = 0; t1 <= 1; t1++)\n    \t\t\tans = (ans + f[1][0][t0][t1] + f[1][1][t0][t1]) % P;\n    \tprintf(\"%lld\\n\", 1ll * ans * power(2, P - 2) % P);\n    \treturn 0;\n    }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) (x = max(x,y))\n#define mins(x,y) (x = min(x,y))\n#define limit(x,l,r) max(l,min(x,r))\n#define lims(x,l,r) (x = max(l,min(x,r)))\n#define isin(x,l,r) ((l) <= (x) && (x) < (r))\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcountll\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,v(T),greater<T> >\n#define bn(x) ((1<<x)-1)\n#define dup(x,y) (((x)+(y)-1)/(y))\n#define newline puts(\"\")\n#define v(T) vector<T>\n#define vv(T) v(v(T))\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ntemplate<typename T>inline istream& operator>>(istream&i,v(T)&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(const v(T)&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>inline ostream& operator<<(ostream&o,const v(T)&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>inline istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>inline ostream& operator<<(ostream&o,const pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\ntemplate<typename T>inline ll suma(const v(T)& a) { ll res(0); for (auto&& x : a) res += x; return res;}\nconst double eps = 1e-10;\nconst ll LINF = 1001002003004005006ll;\nconst int INF = 1001001001;\n#define dame { puts(\"-1\"); return 0;}\n#define yn {puts(\"YES\");}else{puts(\"NO\");}\nconst int MX = 200005;\n\n// Union find\nstruct uf {\n  vi d;\n  uf(){}\n  uf(int mx):d(mx,-1){}\n  int root(int x) {\n    if(d[x] < 0) return x;\n    return d[x] = root(d[x]);\n  }\n  bool unite(int x, int y) {\n    x = root(x); y = root(y);\n    if(x == y) return false;\n    if(d[x] > d[y]) swap(x,y);\n    d[x] += d[y]; d[y] = x;\n    return true;\n  }\n  int size(int x) { return -d[root(x)];}\n};\n//\n\n// Mod int\nconst int mod = 1000000007;\nstruct mint {\n  ll x;\n  mint():x(0){}\n  mint(ll x):x((x%mod+mod)%mod){}\n  // mint(ll x):x(x){}\n  mint& fix() { x = (x%mod+mod)%mod; return *this;}\n  mint operator-() const { return mint(0) - *this;}\n  mint& operator+=(const mint& a){ if((x+=a.x)>=mod) x-=mod; return *this;}\n  mint& operator-=(const mint& a){ if((x+=mod-a.x)>=mod) x-=mod; return *this;}\n  mint& operator*=(const mint& a){ (x*=a.x)%=mod; return *this;}\n  mint& operator/=(const mint& a){ (x*=a.ex(mod-2).x)%=mod; return *this;}\n  mint operator+(const mint& a)const{ return mint(*this) += a;}\n  mint operator-(const mint& a)const{ return mint(*this) -= a;}\n  mint operator*(const mint& a)const{ return mint(*this) *= a;}\n  mint operator/(const mint& a)const{ return mint(*this) /= a;}\n  mint ex(ll t) const {\n    if(!t) return 1;\n    mint res = ex(t/2);\n    res *= res;\n    return (t&1)?res*x:res;\n  }\n  bool operator<(const mint& a)const{ return x < a.x;}\n  bool operator==(const mint& a)const{ return x == a.x;}\n};\nmint ex(mint x, ll t) { return x.ex(t);}\nistream& operator>>(istream&i,mint&a){i>>a.x;return i;}\nostream& operator<<(ostream&o,const mint&a){o<<a.x;return o;}\ntypedef vector<mint> vm;\nstruct comb {\n  vm f, g;\n  comb(){}\n  comb(int mx):f(mx+1),g(mx+1) {\n    f[0] = 1;\n    rrep(i,mx) f[i] = f[i-1]*i;\n    g[mx] = f[mx].ex(mod-2);\n    for(int i=mx;i>0;i--) g[i-1] = g[i]*i;\n  }\n  mint c(int a, int b) {\n    if (a < b) return 0;\n    return f[a]*g[b]*g[a-b];\n  }\n};\n//\n\nvi conv(vi a) {\n  int n = sz(a);\n  rep(i,n) a[i]--;\n  vi res;\n  rep(i,n-1) {\n    res.pb(min(a[i],a[i+1]));\n  }\n  return res;\n}\nmint f(vi a) {\n  int n = sz(a);\n  // cerr<<a<<endl;\n  vp p(n);\n  rep(i,n) p[i] = P(a[i],i);\n  sort(rng(p)); reverse(rng(p));\n  vi gid(n,-1);\n  uf t(n);\n  vi used;\n  vp g;\n  vvi to;\n  for (int i = 0; i < n;) {\n    int si = i;\n    int now = p[si].fi;\n    vvi chi;\n    while (i < n && p[i].fi == now) {\n      chi.pb(vi());\n      int j = p[i].se;\n      if (j && gid[t.root(j-1)] != -1) {\n        int gi = gid[t.root(j-1)];\n        t.unite(j,j-1);\n        if (!used[gi]) {\n          chi.back().pb(gi);\n          used[gi] = 1;\n          g[gi].se -= now;\n        }\n      }\n      if (j+1 < n && gid[t.root(j+1)] != -1) {\n        int gi = gid[t.root(j+1)];\n        t.unite(j,j+1);\n        if (!used[gi]) {\n          chi.back().pb(gi);\n          used[gi] = 1;\n          g[gi].se -= now;\n        }\n      }\n      if (j && (a[j-1] == now || t.root(j-1) != j-1)) {\n        t.unite(j,j-1);\n      }\n      if (j+1 < n && (a[j+1] == now || t.root(j+1) != j+1)) {\n        t.unite(j,j+1);\n      }\n      ++i;\n    }\n    vi js;\n    srep(pi,si,i) {\n      int j = p[pi].se;\n      js.pb(t.root(j));\n    }\n    sort(rng(js)); uni(js);\n    for (int j : js) {\n      gid[j] = sz(used);\n      used.pb(0);\n      g.pb(P(t.size(j),now));\n      to.pb(vi());\n    }\n    srep(pi,si,i) {\n      int j = p[pi].se;\n      int gi = gid[t.root(j)];\n      for (int u : chi[pi-si]) to[gi].pb(u);\n    }\n  }\n  mint res;\n  int m = sz(g);\n  // cerr<<\"G \"<<g<<endl;\n  // rep(i,m) cerr<<to[i]<<endl;\n  vm d1(m), d2(m);\n  rep(i,m) {\n    mint two = ex(2,g[i].se);\n    d1[i] = two;\n    int r = g[i].fi;\n    mint x = 1, y = two-1;\n    for (int j : to[i]) {\n      r -= g[j].fi;\n      d1[i] *= d1[j];\n      x *= d2[j];\n      y *= d1[j];\n    }\n    x *= ex(2,r);\n    d2[i] = x+y;\n  }\n  // cerr<<d1<<endl;\n  // cerr<<d2<<endl;\n  res = d2.back();\n  return res*2;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\",&n);\n  vi a(n);\n  cin>>a;\n  a.insert(a.begin(),0);\n  a.pb(0);\n  ll cnt = 0;\n  rrep(i,n) {\n    int mx = max(a[i-1],a[i+1]);\n    if (mx < a[i]) {\n      cnt += a[i]-mx;\n      a[i] = mx;\n    }\n  }\n  rrep(i,n) {\n    if (a[i] == 1) {\n      ++cnt;\n      a[i] = 0;\n    }\n  }\n  // cerr<<a<<endl;\n  mint ans = ex(2,cnt);\n  vi x;\n  rrep(i,n+1) {\n    if (a[i]) {\n      x.pb(a[i]);\n    } else {\n      if (sz(x)) {\n        ans *= f(conv(x));\n      }\n      x = vi();\n    }\n  }\n\n  cout<<ans<<endl;\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"vector\"\n#include \"string\"\n#include \"map\"\n#include \"algorithm\"\n#include \"functional\"\n#include \"set\"\n#include \"numeric\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007; \n\nlong long int N, M, K, H, W, L, R;\n\nlong long int power(long long int x, long long int n, long long int M) {\n\tlong long int tmp = 1;\n\n\tif (n > 0) {\n\t\ttmp = power(x, n / 2, M);\n\t\tif (n % 2 == 0) tmp = (tmp*tmp) % M;\n\t\telse tmp = (((tmp*tmp) % M)*x) % M;\n\t}\n\treturn tmp;\n}\n\nstruct Node {\n\tint l;\n\tint r;\n\tint bottom = 0;\n\tint up;\n};\n\nvoid Search(vector<long long int>&dp1, vector<long long int>& dp2, vector<vector<int>>&edge, vector<Node> &node, int n = M - 1) {\n\tif (edge[n].empty()) {\n\t\tdp1[n] = power(2, node[n].up - node[n].bottom, MOD);\n\t\tdp2[n] = dp1[n];\n\t\tdp2[n] += power(2, node[n].r - node[n].l + 1, MOD) + MOD - 2;\n\t\tdp2[n] %= MOD;\n\t\treturn;\n\t}\n\tdp1[n] = 1;\n\tdp2[n] = 1;\n\tint w = node[n].r - node[n].l + 1;\n\tfor (auto i : edge[n]) {\n\t\tif (dp1[i] == -1)Search(dp1, dp2, edge, node, i);\n\t\tdp1[n] *= dp1[i];\n\t\tdp1[n] %= MOD;\n\t\tdp2[n] *= (dp1[i] + dp2[i]) % MOD;\n\t\tdp2[n] %= MOD;\n\t\t/*if(node[i].r!=node[i].l)*/w -= node[i].r - node[i].l + 1;\n\t}\n\tdp2[n] *= power(2, w, MOD);\n\tdp2[n] %= MOD;\n\tdp2[n] += dp1[n] * (power(2, node[n].up - node[n].bottom, MOD) - 2);\n\tdp2[n] %= MOD;\n\tdp1[n] *= power(2, node[n].up - node[n].bottom, MOD);\n\tdp1[n] %= MOD;\n\treturn;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tvector<int>v(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> v[i];\n\t}\n\tset<int>s;\n\tfor (auto i : v)s.insert(i);\n\tvector<Node>node;\n\tfor (auto i : s) {\n\t\tL = -1;\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (v[j] >= i) {\n\t\t\t\tif (L == -1)L = j;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (L != -1) {\n\t\t\t\t\tNode n;\n\t\t\t\t\tn.l = L;\n\t\t\t\t\tn.r = j - 1;\n\t\t\t\t\tL = -1;\n\t\t\t\t\tn.up = MOD;\n\t\t\t\t\tfor (int k = n.l; k <= n.r; k++) {\n\t\t\t\t\t\tn.up = min(n.up, v[k]);\n\t\t\t\t\t}\n\t\t\t\t\tif (n.up == i)\tnode.push_back(n);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (L != -1) {\n\t\t\tNode n;\n\t\t\tn.l = L;\n\t\t\tn.r = N - 1;\n\t\t\tn.up = MOD;\n\t\t\tfor (int k = n.l; k <= n.r; k++) {\n\t\t\t\tn.up = min(n.up, v[k]);\n\t\t\t}\n\t\t\tif (n.up == i)\tnode.push_back(n);\n\t\t}\n\t}\n\tM = node.size();\n\t//cout << M << endl;\n\tvector<vector<int>>edge(M);\n\treverse(node.begin(), node.end());\n\tfor (int i = 0; i < M; i++) {\n\t\tfor (int j = i + 1; j < M; j++) {\n\t\t\tif (node[i].l >= node[j].l&&node[i].r <= node[j].r) {\n\t\t\t\tedge[j].push_back(i);\n\t\t\t\tnode[i].bottom = node[j].up;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvector<long long int>dp1(M, -1);\n\tvector<long long int>dp2(M, -1);\n\tSearch(dp1, dp2, edge, node);\n\tcout << dp2.back() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//ΔAGC026D\n#include<iostream>\n#include<cstdio>\n#include<fstream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<bitset>\n#include<cmath>\n#include<cstring>\n#include<cstdlib>\nusing namespace std;\ntypedef long long LL;\ntypedef double DB;\nconst int N = 111;\nconst int MO = 1e9+7;\nconst int inf = 2e9;\nint mul(int x,int y){\n\treturn (LL)x*y%MO;\n}\nint fpow(int x,int y=MO-2){\n\tif(!y)\n\t\treturn 1;\n\tLL z=fpow(x,y>>1);\n\tz=mul(z,z);\n\tif(y&1)\n\t\treturn mul(z,x);\n\treturn z;\n}\nint n,h[N],f[N][N],g[N][N];\nvoid solve(int w,int l,int r){\n\tint i,j,x=inf,y=0;\n\tfor(i=l;i<=r;i=i+1)\n\t\tx=min(x,h[i]),y=max(y,h[i]);\n\tif(x==y){\n\t\tf[l][r]=fpow(2,x-w-1);\n\t\tg[l][r]=(fpow(2,r-l+1)-2+f[l][r]*2%MO)%MO;\n\t\treturn;\n\t}\n\tf[l][r]=1;\n\tg[l][r]=1;\n\tfor(i=l;i<=r;i=i+1){\n\t\tif(h[i]==x){\n\t\t\tg[l][r]=mul(g[l][r],2);\n\t\t\tcontinue;\n\t\t}\n\t\tfor(j=i;j<=r&&h[j+1]>x;j=j+1);\n\t\tsolve(x,i,j);\n\t\tf[l][r]=mul(f[l][r],f[i][j]*2);\n\t\tif(i==j)\n\t\t\tg[l][r]=mul(g[l][r],g[i][j]*2);\n\t\telse\n\t\t\tg[l][r]=mul(g[l][r],g[i][j]+f[i][j]*2%MO);\n\t\ti=j;\n\t}\n\tg[l][r]=(g[l][r]-f[l][r]*2%MO+MO)%MO;\n\tf[l][r]=mul(f[l][r],fpow(2,x-w-1));\n\tg[l][r]=(g[l][r]+f[l][r]*2%MO)%MO;\n\t//cout<<l<<' '<<r<<' '<<f[l][r]<<' '<<g[l][r]<<endl;\n}\nint main()\n{\n\tint i;\n\tcin>>n;\n\tfor(i=1;i<=n;i=i+1)\n\t\tcin>>h[i];\n\tsolve(0,1,n);\n\tcout<<g[1][n];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nint H[105];\nll mo=1000000007;\n\nll modpow(ll a, ll n = mo-2) {\n\tll r=1;a%=mo;\n\twhile(n) r=r*((n%2)?a:1)%mo,a=a*a%mo,n>>=1;\n\treturn r;\n}\n\npair<ll,ll> hoge(int L,int R,int v) {\n\tll dp1=1,dp2=1;\n\tint i;\n\t\n\tif(L>R) return {-1,1};\n\t\n\tint mi=1<<30;\n\tfor(i=L;i<=R;i++) mi=min(mi,H[i]);\n\tint W=R-L+1;\n\tfor(i=L;i<=R;i++) if(mi!=H[i]) W--;\n\t\n\tint pre=L-1;\n\tfor(i=L;i<=R;i++) {\n\t\tif(mi==H[i]) {\n\t\t\tauto r=hoge(pre+1,i-1,mi);\n\t\t\tif(r.first>=0) {\n\t\t\t\t(dp1*=r.first)%=mo;\n\t\t\t\t(dp2*=r.second)%=mo;\n\t\t\t}\n\t\t\t\n\t\t\tpre=i;\n\t\t}\n\t}\n\tauto r=hoge(pre+1,R,mi);\n\tif(r.first>=0) {\n\t\t(dp1*=r.first)%=mo;\n\t\t(dp2*=r.second)%=mo;\n\t}\n\t\n\tif(W==R-L+1) {\n\t\t(dp2=dp2*modpow(2,W)+2*(modpow(2,mi-v-1)+mo-1)*dp1)%=mo;\n\t}\n\telse {\n\t\t(dp2=dp2*modpow(2,W)+(modpow(2,mi-v)+mo-1)*dp1)%=mo;\n\t}\n\t(dp1*=modpow(2,mi-v))%=mo;\n\t\n\treturn {dp1,dp2};\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tfor(i=1;i<=N;i++) cin>>H[i];\n\t\n\tll ret=1;\n\tFOR(j,1001) {\n\t\tFOR(i,N+1) if(H[i]==1) (ret*=2)%=mo, H[i]=0;\n\t\tfor(i=1;i<N+1;i++) {\n\t\t\tif(H[i]>max(H[i-1],H[i+1])) {\n\t\t\t\t(ret*=modpow(2,H[i]-max(H[i-1],H[i+1])))%=mo;\n\t\t\t\tH[i]=max(H[i-1],H[i+1]);\n\t\t\t}\n\t\t}\n\t}\t\n\t\n\tfor(i=1;i<=N;i++) if(H[i]) {\n\t\tj=i;\n\t\twhile(H[j]) j++;\n\t\t(ret*=hoge(i,j-1,0).second)%=mo;\n\t\ti=j;\n\t}\n\tcout<<ret<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define Endl endl\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class T,size_t n> ostream& operator<<(ostream &os, const array<T,n> &t) {\n\tos<<\"{\"; rep(i,n) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T,class U> ostream& operator<<(ostream &os, const tuple<S,T,U> &t) { return os<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\ntemplate<class S, class T,class U,class V> ostream& operator<<(ostream &os, const tuple<S,T,U,V> &t) { return os<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\",\"<<get<3>(t)<<\")\";}\ntemplate<class S, class T,class U,class V,class W> ostream& operator<<(ostream &os, const tuple<S,T,U,V,W> &t) { return os<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\",\"<<get<3>(t)<<\",\"<<get<4>(t)<<\")\";}\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n//#undef NUIP\n#ifdef NUIP\n#define out(args...){vector<string> a_r_g_s=s_p_l_i_t(#args, ','); e_r_r(a_r_g_s.begin(), args); }\nvector<string> s_p_l_i_t(const string &s, char c){vector<string> v;int d=0,f=0;string t;for(char c:s){if(!d&&c==',')v.pb(t),t=\"\";else t+=c;if(c=='\\\"'||c=='\\'')f^=1;if(!f&&c=='(')++d;if(!f&&c==')')--d;}v.pb(t);return move(v);}\nvoid e_r_r(vector<string>::iterator it) {}\ntemplate<typename T, typename... Args> void e_r_r(vector<string>::iterator it, T a, Args... args){ if(*it==\" 1\"||*it==\"1\") cerr<<endl; else cerr << it -> substr((*it)[0] == ' ', it -> length()) << \" = \" << a << \", \"; e_r_r(++it, args...);}\n#else\n#define out\n#endif\n#ifdef __cpp_init_captures\ntemplate<typename T>vector<T> table(int n, T v){ return vector<T>(n, v);}\ntemplate <class... Args> auto table(int n, Args... args){auto val = table(args...); return vector<decltype(val)>(n, move(val));}\n#endif\nconst ll MOD=1e9+7;\n\nll modpow(ll r,ll n,ll m=MOD){\n  ll re=1,d=r%m;\n  if(n<0)(n%=m-1)+=m-1;\n  for(;n;n/=2){\n    if(n&1)(re*=d)%=m;\n    (d*=d)%=m;\n  }\n  return re;\n}\ntemplate <int mod=MOD> struct modInt{\n  int v;\n  modInt(int v=0):v(v){}\n  modInt operator+(const modInt &n)const{return v+n.v<mod ? v+n.v : v+n.v-mod;}\n  modInt operator-(const modInt &n)const{return v-n.v<0 ? v-n.v+mod : v-n.v;}\n  modInt operator*(const modInt &n)const{return ll(v)*n.v%mod;}\n  modInt operator/(const modInt &n)const{return ll(v)*modpow(n.v%mod,-1,mod)%mod;}\n  modInt operator+(const ll &n)const{return v+n<mod ? v+n : v+n-mod;}\n  modInt operator-(const ll &n)const{return v-n<0 ? v-n+mod : v-n;}\n  modInt operator*(const ll &n)const{return ll(v)*(n%mod)%mod;}\n  modInt operator/(const ll &n)const{return ll(v)*modpow(n%mod,-1,mod)%mod;}\n  modInt& operator+=(const modInt &n){v+=n.v; if(v>=mod) v-=mod; return *this;}\n  modInt& operator-=(const modInt &n){v-=n.v; if(v<0) v+=mod; return *this;}\n  modInt& operator*=(const modInt &n){v=ll(v)*n.v%mod; return *this;}\n  modInt& operator/=(const modInt &n){v=ll(v)*modpow(n.v,-1,mod)%mod; return *this;}\n  modInt& operator+=(const ll &n){v+=n; if(v>=mod) v-=mod; return *this;}\n  modInt& operator-=(const ll &n){v-=n; if(v<0) v+=mod; return *this;}\n  modInt& operator*=(const ll &n){v=ll(v)*n%mod; return *this;}\n  modInt& operator/=(const ll &n){v=ll(v)*modpow(n,-1,mod)%mod; return *this;}\n};\ntemplate<int mod> ostream& operator<<(ostream &os,const modInt<mod> &n){return os<<n.v;};\ntemplate<int mod> modInt<mod> operator+(const ll &n,const modInt<mod> &m){return m.v+n<mod ? m.v+n : m.v+n-mod;}\ntemplate<int mod> modInt<mod> operator-(const ll &n,const modInt<mod> &m){return n-m.v<0 ? n-m.v+mod : n-m.v;}\ntemplate<int mod> modInt<mod> operator*(const ll &n,const modInt<mod> &m){return ll(m.v)*(n%mod)%mod;}\ntemplate<int mod> modInt<mod> operator/(const ll &n,const modInt<mod> &m){return ll(m.v)*modpow(n%mod,-1,mod)%mod;}\ntypedef modInt<MOD> mint;\ntemplate <int mod> modInt<mod> modpow(modInt<mod> r,ll n){ modInt<mod> re(1); if(n<0)(n%=mod-1)+=mod-1; for(;n;n/=2){if(n&1) re*=r; r*=r;} return re;}\nvector<mint> fact,finv,inv;\nmint comb(ll n,ll r){ if(n<r||r<0)return 0; return fact[n]*finv[n-r]*finv[r];}\nclass Doralion{\n  void Modinvs(vector<mint> &re,int n){ re.resize(n+1); re[1]=1; for(int i=2;i<=n;++i)re[i]=re[MOD%i]*(MOD-MOD/i);}\n  void Facts(vector<mint> &re,int n){ re.resize(n+1); re[0]=1; rep(i,n)re[i+1]=re[i]*(i+1);}\n  void Factinvs(vector<mint> &re,const vector<mint> &inv,int n){ re.resize(n+1); re[0]=1; rep(i,n)re[i+1]=re[i]*inv[i+1];}\npublic:\n  Doralion(int n){ Modinvs(inv,n); Facts(fact,n); Factinvs(finv,inv,n);}\n} doralion(212345);\n\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n\tint n;\n\tcin>>n;\n\tvector<int> a(n);\n\trep(i,n) cin>>a[i];\n\tauto hs=a;\n\tsort(rall(hs)); UNIQUE(hs);\n\ta.pb(-1); ++n;\n\t//hs.pb(0);\n\tusing pmm=pair<mint,mint>;\n\tmap<pii,pmm> dp; //(R,not R)\n\tint pre=hs[0]+1;\n\tfor(int h:hs){\n\t\tmap<pii,pmm> nxt;\n\t\tint last=-1;\n\t\trep(i,n){\n\t\t\tif(a[i]<h){\n\t\t\t\tvector<pmm> ps;\n\t\t\t\tint len=i-last-1;\n\t\t\t\tint l2=0;\n\t\t\t\tint lb=last+1;\n\t\t\t\tlast=i;\n\t\t\t\tif(!len) continue;\n\t\t\t\twhile(dp.size() && dp.begin()->X.X<i){\n\t\t\t\t\tlen-=dp.begin()->X.Y-dp.begin()->X.X;\n\t\t\t\t\tl2+=dp.begin()->X.Y-dp.begin()->X.X;\n\t\t\t\t\tps.pb(dp.begin()->Y);\n\t\t\t\t\tdp.erase(dp.begin());\n\t\t\t\t}\n\t\t\t\tout(h,ps,len,i,1);\n\t\t\t\tauto &re=nxt[pii(lb,i)];\n\t\t\t\tif(l2){\n\t\t\t\t\tre=pmm(1,1);\n\t\t\t\t\tout(i,re,pre,h,1);\n\t\t\t\t\tmint hoge=modpow(mint(2),pre-h);\n\t\t\t\t\tfor(auto p:ps){\n\t\t\t\t\t\tmint tmp=p.Y*hoge;\n\t\t\t\t\t\tre.X*=p.X+tmp;\n\t\t\t\t\t\tre.Y*=tmp;\n\t\t\t\t\t}\n\t\t\t\t\tout(ps,hoge,re,1);\n\t\t\t\t\tre.X*=modpow(mint(2),len); //new\n\t\t\t\t\tre.Y*=modpow(mint((MOD+1)/2),(ll)ps.size()-1);\n\t\t\t\t\tre.X-=re.Y;\n\t\t\t\t}else{\n\t\t\t\t\tre=pmm(modpow(mint(2),len),2);\n\t\t\t\t\tre.X-=re.Y;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\t// nothing\n\t\t\t}\n\t\t}\n\t\tpre=h;\n\t\tdp=nxt;\n\t\t// for(auto p:dp) cout<<p;cout<<endl;\n\t}\n\tauto re=dp.begin()->Y;\n\tif(hs.back()>1){\n\t\tre.Y*=modpow(mint(2),hs.back()-1);\n\t}\n\tcout<<re.X+re.Y<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "    /* - - - - - - - - - - - - - - -\n    \tUser : \t\tVanishD\n    \tproblem :\n    \tPoints : \t\n    - - - - - - - - - - - - - - - */\n    # include <bits/stdc++.h>\n    # define \tll \t\tlong long\n    using namespace std;\n    const int inf = 0x3f3f3f3f, INF = 0x7fffffff;\n    const ll  infll = 0x3f3f3f3f3f3f3f3fll, INFll = 0x7fffffffffffffffll;\n    int read(){\n    \tint tmp = 0, fh = 1; char ch = getchar();\n    \twhile (ch < '0' || ch > '9'){ if (ch == '-') fh = -1; ch = getchar(); }\n    \twhile (ch >= '0' && ch <= '9'){ tmp = tmp * 10 + ch - '0'; ch = getchar(); }\n    \treturn tmp * fh;\n    }\n    const int P = 1e9 + 7, N = 210;\n    int n, h[N];\n    ll f[N][2][2][2], g0[2][2][2], g1[2][2][2], use[N];\n    ll power(ll x, int y){\n    \tll i = x; x = 1;\n    \twhile (y > 0){\n    \t\tif (y % 2 == 1) x = x * i % P;\n    \t\ti = i * i % P;\n    \t\ty /= 2;\n    \t}\n    \treturn x;\n    }\n    int main(){\n    //\tfreopen(\".in\", \"r\", stdin);\n    //\tfreopen(\".out\", \"w\", stdout);\n    \tn = read();\n    \tfor (int i = 1; i <= n; i++) h[i] = read(); \n    \th[++n] = 1;\n    \tint las = inf, lim, tmp, cnt = 0;\n    \twhile (cnt < n){\n    \t\tlim = -1;\n    \t\tfor (int j = 1; j <= n; j++)\n    \t\t\tif (use[j] == 0) \n    \t\t\t\tlim = max(h[j], lim);\n    \t\ttmp = las - lim;\n    \t\tfor (int j = 1; j <= n; j++){\n    \t\t\tif (use[j] == 2) continue;\n    \t\t\tif (use[j] == 0){\n    \t\t\t\tif (h[j] < lim) continue;\n    \t\t\t\tuse[j] = 1;\n    \t\t\t\tf[j][0][0][0] = f[j][0][1][1] = 1;\n    \t\t\t\tcnt++;\n    \t\t\t}\n    \t\t\telse if (use[j] == 1){\n    \t\t\t\tf[j][0][0][0] = f[j][0][1][1] = (f[j][0][1][1] + f[j][0][0][0]) * power(2, tmp - 1) % P;\n    \t\t\t\tf[j][0][0][1] = f[j][0][1][0] = (f[j][0][0][1] + f[j][0][1][0]) * power(2, tmp - 1) % P;\n    \t\t\t\tif (tmp % 2 == 1){\n    \t\t\t\t\tswap(f[j][1][0][0], f[j][1][1][1]);\n    \t\t\t\t\tswap(f[j][1][0][1], f[j][1][1][0]);\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\tif (j != 1 && use[j - 1] != 0){\n    \t\t\t\tuse[j] = 2;\n    \t\t\t\tint k = j - 1;\n    \t\t\t\twhile (use[k] == 2) k--;\n    \t\t\t\tfor (int t0 = 0; t0 <= 1; t0++)\n    \t\t\t\t\tfor (int t1 = 0; t1 <= 1; t1++)\n    \t\t\t\t\t\tfor (int t2 = 0; t2 <= 1; t2++)\n    \t\t\t\t\t\t\tg0[t0][t1][t2] = f[k][t0][t1][t2], g1[t0][t1][t2] = f[j][t0][t1][t2];\n    \t\t\t\tfor (int t0 = 0; t0 <= 1; t0++)\n    \t\t\t\t\tfor (int t1 = 0; t1 <= 1; t1++){\n    \t\t\t\t\t\tf[k][0][t0][t1] = (g0[0][t0][1] * g1[0][0][t1] + g0[0][t0][0] * g1[0][1][t1]) % P;\n    \t\t\t\t\t\tf[k][1][t0][t1] = ((g0[1][t0][1] + g0[1][t0][0]) * (g1[1][0][t1] + g1[1][1][t1] + g1[0][0][t1] + g1[0][1][t1])) % P;\n    \t\t\t\t\t\tf[k][1][t0][t1] = (f[k][1][t0][t1] + (g0[0][t0][1] + g0[0][t0][0]) * (g1[1][0][t1] + g1[1][1][t1])) % P;\n    \t\t\t\t\t\tf[k][1][t0][t1] = (f[k][1][t0][t1] + g0[0][t0][1] * g1[0][1][t1] + g0[0][t0][0] * g1[0][0][t1]) % P;\n    \t\t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t\tlas = lim; \n    \t}\n    \tll ans = 0;\n    \tfor (int t0 = 0; t0 <= 1; t0++)\n    \t\tfor (int t1 = 0; t1 <= 1; t1++)\n    \t\t\tans = (ans + f[1][0][t0][t1] + f[1][1][t0][t1]) % P;\n    \tprintf(\"%lld\\n\", 1ll * ans * power(2, P - 2) % P);\n    \treturn 0;\n    }"
  },
  {
    "language": "C++",
    "code": "\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <utility>\n\nusing namespace std;\n\n#define fi first\n#define se second\n#define long long long\ntypedef pair<int,int> ii;\ntypedef pair<long,ii> lii;\n\nconst long MOD = 1e9+7;\nlong p2(long b)\n{\n\tif(b == 0) return 1;\n\telse if(b == 2) return 4;\n\telse if(b&1) return (p2(b-1)*2)%MOD;\n\telse\n\t{\n\t\tlong temp = p2(b/2);\n\t\treturn (temp*temp)%MOD;\n\t}\n}\nlong geo(long a, long n)\n{\n\treturn (a*(p2(n)-1))%MOD;\n}\n\nvector<lii> vec;\nlong arr[100003];\n\nint main()\n{\n\t//ios_base::sync_with_stdio(); cin.tie(0); cout.tie(0);\n\t// freopen(\"input.in\", \"r\", stdin);\n\t\n\tint n; scanf(\"%d\", &n);\t\n\tfor(int i = 1; i <= n; i++)\n\t\tscanf(\"%lld\", &arr[i]);\n\tlong res = 1;\n\tlong bed = 0;\n\tfor(int i = 1; i <= n+1; i++)\n\t{\n\t\tif(arr[i] == 1 || i == n+1)\n\t\t{\n\t\t\t// printf(\"i : %d\\n\" , i);\n\t\t\tlong cnt = 0;\n\t\t\tcnt += bed;\n\t\t\t// printf(\"\tBED : %lld\\n\", bed);\n\t\t\tfor(auto j : vec)\n\t\t\t{\n\t\t\t\t// printf(\"\t%lld %d %d\\n\", j.fi, j.se.fi, j.se.se);\n\t\t\t\tcnt += geo(j.fi,j.se.fi-j.se.se+1);\n\t\t\t\tcnt %= MOD;\n\t\t\t}\n\t\t\t// printf(\"\tCNT : %lld\\n\", cnt);\n\t\t\tvec.clear();\n\t\t\tres *= cnt*2;\n\t\t\tres %= MOD;\n\n\t\t}\n\t\telse if(vec.size() == 0)\n\t\t{\n\t\t\tvec.push_back({2,{arr[i],2}});\n\t\t\tbed = 2;\n\t\t}\n\t\telse if(arr[i] > arr[i-1])\n\t\t{\n\t\t\tfor(int j = 0; j < vec.size(); j++)\n\t\t\t{\n\t\t\t\tvec[j].fi *= p2(arr[i]-arr[i-1]);\n\t\t\t\tvec[j].fi %= MOD;\n\t\t\t}\n\t\t\tbed *= 2; bed %= MOD;\n\t\t\tvec.push_back({bed,{arr[i], arr[i-1]+1}});\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvector<lii> temp;\n\t\t\tbed *= 2; bed %= MOD;\n\t\t\tfor(int j = 0; j < vec.size(); j++)\n\t\t\t{\n\t\t\t\tif(vec[j].se.fi > arr[i])\n\t\t\t\t{\n\t\t\t\t\tif(vec[j].se.se > arr[i])\n\t\t\t\t\t{\n\t\t\t\t\t\tbed += 2*geo(vec[j].fi,vec[j].se.fi-vec[j].se.se+1);\n\t\t\t\t\t\tbed %= MOD;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tbed += 2*geo(vec[j].fi, vec[j].se.fi-arr[i]);\n\t\t\t\t\t\tbed %= MOD;\n\t\t\t\t\t\ttemp.push_back({vec[j].fi*p2(vec[j].se.fi-arr[i]),{arr[i],vec[j].se.se}});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\ttemp.push_back(vec[j]);\n\t\t\t}\n\t\t\tvec = temp;\n\t\t}\n\t}\n\tres *= p2(MOD-2);\n\tres %= MOD;\n\tprintf(\"%lld\\n\", res);\n}\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "/*\ncat <<EOF >mistaken-paste\n*/\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 2000000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1000000\n#define M_MAX 200000\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <set>\n#include <map>\n#include <string>\n\n// using namespace std; // HELL\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\nusing std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\n\n#endif\n\ntypedef struct {\n\tint32_t a;\n\tint32_t b;\n} hw;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\null n, m;\null h, w;\null k;\null q;\null vua, vub, vuc, vud, vue, vuf;\nsll vsa, vsb, vsc, vsd, vse, vsf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (x < y) {\n\t\treturn gcd(y, x);\n\t} else if (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n// double distance (sll x1, sll y1, sll x2, sll y2) {\n// \tdouble xdist2, ydist2, origindist, dist;\n\n// \txdist2 = (x1 - x2) * (x1 - x2);\n// \tydist2 = (y1 - y2) * (y1 - y2);\n// \treturn sqrt(xdist2 + ydist2);\n// }\n\nint32_t pullcomp (const void *left, const void *right) {\n\tull l = *(ull*)left;\n\tull r = *(ull*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t psllcomp (const void *left, const void *right) {\n\tsll l = *(sll*)left;\n\tsll r = *(sll*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pcharcomp (const void *left, const void *right) {\n\tchar l = *(char*)left;\n\tchar r = *(char*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nint32_t phwllABcomp (const void *left, const void *right) {\n\thwll l = *(hwll*)left;\n\thwll r = *(hwll*)right;\n\tif (l.a < r.a) {\n\t\treturn -1;\n\t}\n\tif (l.a > r.a) {\n\t\treturn +1;\n\t}\n\tif (l.b < r.b) {\n\t\treturn -1;\n\t}\n\tif (l.b > r.b) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t phwllREVcomp (const void *left, const void *right) {\n\thwll l = *(hwll*)left;\n\thwll r = *(hwll*)right;\n\tif (l.b < r.b) {\n\t\treturn -1;\n\t}\n\tif (l.b > r.b) {\n\t\treturn +1;\n\t}\n\tif (l.a < r.a) {\n\t\treturn -1;\n\t}\n\tif (l.a > r.a) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t ptriplecomp (const void *left, const void *right) {\n\thwllc l = *(hwllc*)left;\n\thwllc r = *(hwllc*)right;\n\n\tif (l.a < r.a) {\n\t\treturn -1;\n\t}\n\tif (l.a > r.a) {\n\t\treturn +1;\n\t}\n\tif (l.b < r.b) {\n\t\treturn -1;\n\t}\n\tif (l.b > r.b) {\n\t\treturn +1;\n\t}\n\tif (l.c < r.c) {\n\t\treturn -1;\n\t}\n\tif (l.c > r.c) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\null parent[N_MAX];\null rank[N_MAX];\nvoid uf_init (ull n) {\n\tfor (sll i = 0; i < n; i++) {\n\t\tparent[i] = i;\n\t\trank[i] = 0;\n\t}\n}\null uf_find (ull x) {\n\tif (parent[x] == x) return x;\n\treturn parent[x] = uf_find(parent[x]);\n}\nsll uf_union (ull a, ull b) {\n\ta = uf_find(a);\n\tb = uf_find(b);\n\tif (a == b) return -1;\n\n\tif (rank[a] > rank[b]) {\n\t\ta ^= (b ^= (a ^= b));\n\t}\n\n\tparent[a] = b;\n\tif (rank[a] == rank[b]) {\n\t\trank[b]++;\n\t}\n\n\treturn b;\n}\n\n\null a[N_MAX];\n// sll a[3001][3001];\nsll b[N_MAX];\n// sll b[3001][3001];\nsll c[N_MAX];\nchar s[N_MAX + 1];\n// char s[3010][3010];\n// char t[N_MAX + 1];\n// char t[3010][3010];\n// hwll xy[N_MAX];\n\ntypedef pair<ull, ull> P;\n\null ignores = 0;\n\nP dfs (ull begin, ull end, ull cut) {\n\tsll i, j;\n\n\tull vmin = BIG;\n\tfor (i = begin; i < end; i++) vmin = umin(vmin, a[i]);\n\n\tvector<P> query;\n\tvector<P> v;\n\n\tull wrem = end - begin;\n\n\ti = begin;\n\twhile (i < end && a[i] == vmin) i++;\n\twhile (i < end) {\n\t\tj = i;\n\t\twhile (i < end && a[i] != vmin) i++;\n\t\tif (i - j == 1) {\n\t\t\tignores += (a[j] - vmin);\n\t\t} else {\n\t\t\tquery.push_back(P(j, i));\n\t\t\twrem -= (i - j);\n\t\t}\n\n\t\twhile (i < end && a[i] == vmin) i++;\n\t}\n\n\tfor (P x : query) {\n\t\tP reted = dfs(x.first, x.second, vmin);\n\t\tv.push_back(reted);\n\t}\n\n\tP ret;\n\tif (vmin == 1) {\n\t\tignores += wrem;\n\n\t\tull reted = 1;\n\t\tfor (P x : v) {\n\t\t\treted *= (x.first * 2 + x.second) % MOD;\n\t\t\treted %= MOD;\n\t\t}\n\t\tret.first = reted;\n\t\tret.second = 0;\n\t} else if (query.empty()) {\n\t\tull h = vmin - cut;\n\n\t\tret.first = bitpow(2, h, MOD);\n\t\tret.second = (MOD + bitpow(2, end - begin, MOD) - 2) % MOD;\n\t} else {\n\t\tull unfix = 1;\n\t\tull whole = 1;\n\t\tfor (P x : v) {\n\t\t\tunfix *= x.first;\n\t\t\tunfix %= MOD;\n\n\t\t\twhole *= (x.first + x.second) % MOD;\n\t\t\twhole %= MOD;\n\t\t}\n\n\t\t// printf(\"%llu*%llu/%llu\\n\", unfix, bitpow(2, vmin - cut, MOD), bitpow(2, v.size() - 1, MOD));\n\t\tret.first = divide(unfix * bitpow(2, vmin - cut, MOD) % MOD, bitpow(2, v.size() - 1, MOD), MOD);\n\t\tret.second = \n\t\t( ((MOD + whole - unfix) % MOD) * bitpow(2, wrem, MOD) % MOD )\n\t\t+ (MOD - divide(unfix, bitpow(2, v.size() - 1, MOD), MOD) + (unfix * bitpow(2, wrem, MOD) % MOD)) % MOD;\n\t\t// printf(\"%llu + %llu\\n\", ( ((MOD + whole - unfix) % MOD) * bitpow(2, wrem, MOD) % MOD ), (MOD - divide(unfix, bitpow(2, v.size() - 1, MOD), MOD) + (unfix * bitpow(2, wrem, MOD) % MOD)) % MOD\n\t\t\t// );\n\t}\n\n\t// printf(\"%lld~%lld: %llu/%llu ignores: %llu wrem: %llu : %llu-%llu=%llu v%d\\n\", begin, end, ret.first, ret.second, ignores, wrem, vmin, cut, vmin - cut, v.size());\n\n\treturn ret;\n\n}\n\null solve () {\n\tsll i, j, ki, li;\n\tull result = 0;\n\t// sll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tull *dpcell;\n\n\tP ret = dfs(0, n, 0);\n\n\tresult = (ret.first + ret.second) % MOD;\n\tresult = (result * bitpow(2, ignores, MOD)) % MOD;\n\n\tprintf(\"%llu\\n\", result);\n\t// printf(\"%.15lf\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\t// puts(\"YES\");\n\t// puts(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\tputs(\"Takahashi\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\t// puts(\"No\");\n\t// puts(\"0\");\n\t// puts(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\tputs(\"Aoki\");\n\treturn 1;\n}\n\nint32_t main (void) {\n\tint32_t i, j;\n\tint32_t x, y;\n\n\t// scanf(\"%lf%lf\", &vda, &vdb, &vdc);\n\t// scanf(\"%lld%lld\", &vsa, &vsb, &vsc, &vsd);\n\t// scanf(\"%llu%llu\", &vua, &vub, &vuc, &vud);\n\t// scanf(\"%*llu%*llu\");\n\t// scanf(\"%llu%llu\", &h, &w);\n\tscanf(\"%llu\", &n, &m);\n\t// scanf(\"%llu\", &k, &n, &m);\n\t// scanf(\"%s\", s);\n\t// scanf(\"%s\", t);\n\t// scanf(\"%llu\", &q);\n\tfor (i = 0; i < n; i++) {\n\t\t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t\tscanf(\"%lld\", &a[i]);\n\t\t// scanf(\"%lld\", &b[i]);\n\t\t// scanf(\"%lld\", &c[i]);\n\t\t// scanf(\"%lld\", &t[i]);\n\t\t// a[i]--;\n\t\t// b[i]--;\n\t\t// c[i]--;\n\t}\n\t// scanf(\"%llu%llu\", &m, &k);\n\t// for (i = 0; i < w; i++) {\n\t// \tscanf(\"%llu\", &b[i]);\n\t// \t// b[i]--;\n\t// }\n\t// scanf(\"%llu\", &q);\n\n\t// for (i = 0; i < h; i++) {\n\t// \tfor (j = 0; j < w; j++) {\n\t// \t\tscanf(\"%llu\", &a[i][j]);\n\t// \t}\n\t// }\n\t// for (i = 0; i < h; i++) {\n\t// \tscanf(\"%s\", &s[i]);\n\t// }\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 123456\n#define F first\n#define S second\n#define M 1000000007\n\nusing namespace std;\ntypedef long long ll;\nll a[maxn],s[maxn],dp[105][105],n,b[maxn],ans,m;\nset <ll> f;\n\nll pow_(ll x,ll y){\n    ll rt=1;\n    while (y){\n        if (y&1) rt=rt*x%M;\n        x=x*x%M; y>>=1;\n    }\n    return rt;\n}\n\nint main(){\n    cin >> n;\n    for (int i=1;i<=n;i++) cin >> a[i];\n    for (int i=1;i<=n;i++) {\n        if (f.find(a[i])==f.end()) f.insert(a[i]),b[++m]=a[i];\n    }\n    sort(b+1,b+m+1);\n    for (int i=1;i<=n;i++) for (int j=1;j<=m;j++) if (a[i]==b[j]) s[i]=j;\n    dp[0][0]=1;\n    for (int i=0;i<n;i++){\n        for (int j=1;j<=s[i];j++){\n            if (j<=s[i+1]) (dp[i+1][j]+=dp[i][j]*pow_(2ll,max(b[s[i+1]]-b[s[i]],0ll)))%=M;\n            else (dp[i+1][0]+=dp[i][j]*2)%=M;\n        }\n        (dp[i+1][0]+=dp[i][0]*2)%=M;\n        if (s[i+1]>s[i]){\n            for (int j=s[i]+1;j<=s[i+1];j++) (dp[i+1][j]+=dp[i][0]*(pow_(2ll,b[j]-b[j-1]-(j==1))-1)*2%M*pow_(2ll,b[s[i+1]]-b[j]))%=M;\n        }\n    }\n    for (int i=0;i<=s[n];i++) (ans+=dp[n][i])%=M;\n    cout << (ans+M)%M << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n\n#define mkpr make_pair\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nconst int MAXN = 100, MOD = 1e9 + 7;\nint n, h[MAXN + 5];\n\ninline int qkpow ( int a, int b, const int p = MOD ) {\n\tint ret = 1;\n\tfor ( ; b; a = 1ll * a * a % p, b >>= 1 ) ret = 1ll * ret * ( b & 1 ? a : 1 ) % p;\n\treturn ret;\n}\n\ninline pii solve ( const int l, const int r, const int cut ) {\n\tif ( l > r ) return mkpr ( 1, 0 );\n\tint height = 0x3f3f3f3f;\n\tfor ( int i = l; i <= r; ++ i ) height = height < h[i] ? height : h[i];\n\tvector<int> lowpos; lowpos.push_back ( l - 1 );\n\tfor ( int i = l; i <= r; ++ i ) if ( height == h[i] ) lowpos.push_back ( i );\n\tlowpos.push_back ( r + 1 );\n\tint lowcnt = ( int ) lowpos.size () - 2, prdfirst = 1, prdboth = 1;\n\tfor ( int i = 0; i < ( int ) lowpos.size () - 1; ++ i ) {\n\t\tpii tmp ( solve ( lowpos[i] + 1, lowpos[i + 1] - 1, height ) );\n\t\tprdfirst = 1ll * prdfirst * tmp.first % MOD;\n\t\tprdboth = 1ll * prdboth * ( tmp.first + tmp.second ) % MOD;\n\t}\n\tint pwr = qkpow ( 2, height -= cut );\n\treturn lowpos.clear (),\n\t\t   mkpr ( 1ll * pwr * prdfirst % MOD, ( 1ll * qkpow ( 2, lowcnt ) * prdboth % MOD + ( pwr - 2ll ) * prdfirst % MOD ) % MOD );\n}\n\nint main () {\n\tios :: sync_with_stdio ( false );\n\tcin >> n;\n\tfor ( int i = 1; i <= n; ++ i ) cin >> h[i];\n\tcout << ( solve ( 1, n, 0 ).second + MOD ) % MOD << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Why I am so dumb? :c\n#include <bits/stdc++.h>\n\n#define pb push_back\n#define mp make_pair\n\n#define all(x) (x).begin(), (x).end()\n\n#define fi first\n#define se second\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int mod = (int)1e9 + 7;\n\nint dp[105][105];\n\nint rl[105];\n\nint h[105];\n\nint ans;\n\nint n;\n\nvoid addMod(int &a, int b, int m = mod) {\n    a += b;\n\n    if (m <= a) {\n        a -= m;\n    }\n}\n\nint binPow(int a, int b, int m = mod) {\n    int ret = 1;\n\n    for (; b; b >>= 1) {\n        if (b & 1) {\n            ret = (ret * 1ll * a) % mod;\n        }\n\n        a = (a * 1ll * a) % mod;\n    }\n\n    return ret;\n}\n\nvoid compress() {\n    vector<int> vv;\n    vv.pb(1);\n\n    for (int i = 1; i <= n; ++i) {\n        vv.pb(h[i]);\n    }\n\n    sort(all(vv));\n    vv.resize(unique(all(vv)) - vv.begin());\n\n    for (int i = 0; i < vv.size(); ++i) {\n        rl[i + 1] = vv[i];\n    }\n\n    for (int i = 1; i <= n; ++i) {\n        h[i] = upper_bound(all(vv), h[i]) - vv.begin();\n    }\n}\n\nint f(int l, int r) {\n    int ret = 0;\n\n    addMod(ret, binPow(2, r + 1));\n    addMod(ret, mod - binPow(2, l));\n\n    return ret;\n}\n             \nvoid solve() {                   \n    scanf(\"%d\", &n);\n\n    for (int i = 1; i <= n; ++i) {\n        scanf(\"%d\", &h[i]);\n    }        \n\n    compress();\n\n    dp[1][0] = 2;\n\n    for (int i = 1; i < h[1]; ++i) {\n        int l = rl[h[1]] - rl[i + 1] + 1;\n        int r = rl[h[1]] - rl[i];\n        dp[1][i] = f(l, r);                                             \n    }\n    \n    for (int i = 2; i <= n; ++i) {\n        for (int j = h[i - 1]; j < h[i]; ++j) {\n            int cur = dp[i - 1][0];\n\n            int l = rl[h[i]] - rl[j + 1] + 1;\n            int r = rl[h[i]] - rl[j];\n\n            addMod(dp[i][j], cur * 1ll * f(l, r) % mod);\n        }\n\n        addMod(dp[i][0], dp[i - 1][0] * 2ll % mod);\n\n        for (int j = 1; j < h[i - 1]; ++j) {\n            if (j < h[i]) {\n                int cur = dp[i - 1][j];\n\n                if (h[i] > h[i - 1]) {\n                    cur = (cur * 1ll * binPow(2, rl[h[i]] - rl[h[i - 1]])) % mod;\n                }\n\n                addMod(dp[i][j], cur);\n            }\n            else {\n                addMod(dp[i][0], dp[i - 1][j] * 2ll % mod);\n            }\n        }\n    }\n    \n    for (int i = 0; i < h[n]; ++i) {\n        addMod(ans, dp[n][i]);    \n    }\n\n    printf(\"%d\\n\", ans);\n}\n\nint main() {    \n    int tt = 1;\n\n    while (tt--) {\n        solve();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nmap<pair<VI,int>,ll> hs;\nint n,h[110];\nll solve(VI x,int ty) {\n\tif (x.empty()) return 1;\n\tif (hs.count(mp(x,ty))) return hs[mp(x,ty)];\n\tint v=*min_element(all(x));\n\tif (ty==0) {\n\t\tll ans=1;\n\t\tif (v==1) {\n\t\t\tVI c;\n\t\t\tfor (auto p:x) {\n\t\t\t\tif (p==1) {\n\t\t\t\t\tans=ans*2%mod;\n\t\t\t\t\tans=ans*solve(c,0)%mod;\n\t\t\t\t\tc.clear();\n\t\t\t\t} else {\n\t\t\t\t\tc.pb(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\tans=ans*solve(c,0)%mod;\n\t\t\treturn hs[mp(x,ty)]=ans;\n\t\t} else {\n\t\t\tVI y=x;\n\t\t\trep(i,0,SZ(y)) y[i]-=v-1;\n\t\t\tll all=solve(y,0);\n\t\t\tll dif=solve(y,1)*2%mod;\n\t\t\tall=(all-dif+mod)%mod;\n\t\t\treturn hs[mp(x,ty)]=(all+dif*powmod(2,v-1))%mod;\n\t\t}\n\t} else {\n\t\t// RBRB\n\t\tll ans=1;\n\t\tif (v==1) {\n\t\t\tVI c;\n\t\t\tfor (auto p:x) {\n\t\t\t\tif (p==1) {\n\t\t\t\t\tans=ans*solve(c,1)%mod;\n\t\t\t\t\tc.clear();\n\t\t\t\t} else {\n\t\t\t\t\tc.pb(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\tans=ans*solve(c,1)%mod;\n\t\t\treturn hs[mp(x,ty)]=ans;\n\t\t} else {\n\t\t\tVI y=x;\n\t\t\trep(i,0,SZ(y)) y[i]-=v-1;\n\t\t\tll dif=solve(y,1);\n\t\t\treturn hs[mp(x,ty)]=dif*powmod(2,v-1)%mod;\t\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d\",&n);\n\trep(i,0,n) scanf(\"%d\",h+i);\n\tprintf(\"%lld\\n\",solve(VI(h,h+n),0));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n// #define int ll\nusing PII = pair<ll, ll>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n\ntemplate<typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value==0>::type\nfill_v(T &t, const V &v) { t=v; }\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t, const V &v ) { for(auto &e:t) fill_v(e,v); }\n\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.first<<','<<a.second<<')'; return out;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& vec){\n    for(T& x: vec) {is >> x;} return is;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n    out<<'['; for(T i: a) {out<<i<<',';} out<<']'; return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0}; // DRUL\nconst int INF = 1<<30;\nconst ll LLINF = 1LL<<60;\nconst ll MOD = 1000000007;\n\nll binpow(ll x, ll e) {\n  ll ret = 1, p = x;\n  while(e > 0) {\n    if(e&1) {(ret *= p) %= MOD; e--;}\n    else {(p *= p) %= MOD; e /= 2;} \n  }\n  return ret;\n}\n\nPII dfs(vector<ll> a) {\n    ll n = a.size();\n    // 最小の要素の分引く\n    ll mi = *min_element(ALL(a)), cnt = 0;\n    REP(i, n) {\n        a[i] -= mi;\n        cnt += a[i]==0;\n    }\n    // 子が存在しない\n    if(cnt == n) {\n        ll ans = binpow(2, n);\n        (ans += MOD-2) %= MOD;\n        (ans += binpow(2, mi)) %= MOD;\n        // cout << a << \" \" << mi << \" \" << PII{binpow(2, mi), ans} << endl;\n        return {binpow(2, mi), ans};\n    }\n    // a[i]=0のところで分割して子を求める\n    ll l = 0;\n    vector<vector<ll>> child;\n    while(l < n) {\n        if(a[l] == 0) {l++; continue;}\n        ll r = l;\n        while(r+1<n && a[r+1] > 0) ++r;\n        vector<ll> c;\n        FOR(i, l, r+1) c.push_back(a[i]);\n        child.push_back(c);\n        l = r+1;\n    }\n    // 子の答えを求める\n    vector<PII> ret;\n    for(auto c: child) ret.push_back(dfs(c));\n    ll ans1 = 1, ans2 = 1;\n    for(auto p: ret) {\n        (ans1 *= p.first) %= MOD;\n        (ans2 *= (p.first + p.second)) %= MOD; \n    }\n    PII ans;\n    ans.first = binpow(2, mi) * ans1 % MOD;\n    ans.second = binpow(2, cnt) * ans2 % MOD;\n    (ans.second += (binpow(2, mi) + MOD - 2) % MOD * ans1 % MOD) %= MOD;\n    // cout << a << \" \" << mi << \" \" << ans << endl;\n    return ans;\n}\n\nsigned main(void)\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    ll n;\n    cin >> n;\n    vector<ll> h(n);\n    REP(i, n) cin >> h[i];\n\n    cout << dfs(h).second << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define f first\n#define s second\n#define mod 1000000007\nusing namespace std;\nint n, i;\nint v[105];\npair<int, int> sol;\nint mult(int x, int e){\n    if(e == 0){\n        return 1;\n    }\n    else{\n        int a = mult(x, e / 2);\n        if(e % 2 == 0){\n            return a * 1LL * a % mod;\n        }\n        else{\n            return a * 1LL * a % mod * x % mod;\n        }\n    }\n}\npair<int, int> solve(int st, int dr){\n    pair<int, int> sol;\n    if(st == dr){\n        sol.s = 0;\n        sol.f = mult(2, v[st]);\n        return sol;\n    }\n    int minim = 1000000000, nr = 0, num = 0, p, aux = 2, i;\n    for(i = st; i <= dr; i++){\n        minim = min(minim, v[i]);\n    }\n    for(i = st; i <= dr; i++){\n        v[i] -= minim;\n    }\n    pair<int, int> d[105];\n    p = st - 1;\n    for(i = st; i <= dr; i++){\n        if(v[i] == 0){\n            num++;\n            if(p != i - 1){\n                d[++nr] = solve(p + 1, i - 1);\n            }\n            p = i;\n        }\n    }\n    if(p != dr){\n        d[++nr] = solve(p + 1, dr);\n    }\n    sol.f = mult(2, minim);\n    sol.s = mult(2, num);\n    for(i = 1; i <= nr; i++){\n        sol.f = sol.f * 1LL * d[i].f % mod;\n        sol.s = (2LL * d[i].f + d[i].s) * sol.s % mod;\n        aux = aux * 1LL * d[i].f % mod;\n    }\n    sol.s -= aux;\n    if(sol.s < 0){\n        sol.s += mod;\n    }\n    return sol;\n}\nint main(){\n    cin>> n;\n    for(i = 1; i <= n; i++){\n        cin>> v[i];\n    }\n    sol = solve(1, n);\n    sol.f = (sol.f + sol.s) % mod;\n    cout<< sol.f;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\nconst int MAXN = 100 + 5;\n\nconst int MOD = (int)1e9 + 7;\n\nint n, h[MAXN], sorted[MAXN];\n\nint qpow(int a, int x) {\n    int res = 1;\n    for (; x > 0; x >>= 1) {\n        if (x & 1)\n            res = 1LL * res * a % MOD;\n        a = 1LL * a * a % MOD;\n    }\n    return res;\n}\n\nbool added[MAXN];\nint R_L[MAXN], L_R[MAXN];\n\nint dp[MAXN][MAXN][2][2][2];\n\nvoid merge(int dp_l[2][2][2], int dp_r[2][2][2], int res[2][2][2]) {\n    int tmp[2][2][2];\n    \n    memset(tmp, 0, sizeof tmp);\n    \n    for (int l = 0; l < 2; ++l)\n    for (int r = 0; r < 2; ++r) {\n        for (int ll = 0; ll < 2; ++ll)\n        for (int rr = 0; rr < 2; ++rr)\n        for (int sl = 0; sl < 2; ++sl)\n        for (int sr = 0; sr < 2; ++sr) {\n            int t = sl | sr | (ll == rr);\n            tmp[l][r][t] = (tmp[l][r][t] + 1LL * dp_l[l][ll][sl] * dp_r[rr][r][sr]) % MOD;\n        }\n    }\n    \n    memcpy(res, tmp, sizeof tmp);\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; ++i) {\n        scanf(\"%d\", h + i);\n        sorted[i] = i;\n    }\n\n    for (int i = 1; i <= n; ++i)\n        for (int j = n; j > i; --j)\n            if (h[sorted[j - 1]] < h[sorted[j]]) {\n                int t = sorted[j - 1];\n                sorted[j - 1] = sorted[j];\n                sorted[j] = t;\n            }\n\n    for (int i = 1; i <= n; ++i) {\n        int j = sorted[i], k = sorted[i - 1], t = (h[k] - h[j]) & 1;\n\n        if (h[k] > h[j]) {\n            for (int L = 1; L <= n; ) {\n                if (!added[L]) {\n                    ++L;\n                } else {\n                    int R = L;\n                    while (R + 1 <= n && added[R + 1]) ++R;\n\n                    int tmp[2][2][2];\n\n                    for (int l = 0; l < 2; ++l)\n                    for (int r = 0; r < 2; ++r) {\n                        tmp[l][r][1] = dp[L][R][l ^ t][r ^ t][1];\n                        tmp[l][r][0] = 1LL * (dp[L][R][l][r][0] + dp[L][R][l ^ 1][r ^ 1][0]) * qpow(2, h[k] - h[j] - 1) % MOD;\n                    }\n\n                    memcpy(dp[L][R], tmp, sizeof tmp);\n\n                    L = R + 1;\n                }\n            }\n        }\n\n        int tmp[2][2][2];\n        int L = j, R = j;\n\n        memset(tmp, 0, sizeof tmp);\n        tmp[0][0][0] = tmp[1][1][0] = 1;\n\n        if (R_L[j - 1]) {\n            int l = R_L[j - 1], r = j - 1;\n            L_R[l] = R_L[r] = 0;\n            merge(dp[l][r], tmp, tmp);\n            L = l;\n        }\n\n        if (L_R[j + 1]) {\n            int l = j + 1, r = L_R[j + 1];\n            L_R[l] = R_L[r] = 0;\n            merge(tmp, dp[l][r], tmp);\n            R = r;\n        }\n\n        added[j] = true;\n        memcpy(dp[L][R], tmp, sizeof tmp);\n        L_R[L] = R;\n        R_L[R] = L;\n    }\n\n    if (h[sorted[n]] > 1) {\n        int t = (h[sorted[n]] - 1) & 1;\n        int tmp[2][2][2];\n\n        for (int l = 0; l < 2; ++l)\n        for (int r = 0; r < 2; ++r) {\n            tmp[l][r][1] = dp[1][n][l ^ t][r ^ t][1];\n            tmp[l][r][0] = 1LL * (dp[1][n][l][r][0] + dp[1][n][l ^ 1][r ^ 1][0]) * qpow(2, h[sorted[n]] - 1 - 1) % MOD;\n        }\n        \n        memcpy(dp[1][n], tmp, sizeof tmp);\n    }\n\n    int ans = 0;\n    for (int i = 0; i < 2; ++i)\n    for (int j = 0; j < 2; ++j)\n    for (int k = 0; k < 2; ++k) {\n        ans = (ans + dp[1][n][i][j][k]) % MOD;\n    }\n\n    printf(\"%d\\n\", ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n* @Author: wxyww\n* @Date: 2020-03-23 07:30:09\n* @Last Modified time: 2020-03-23 08:24:37\n*/\n#include<cstdio>\n#include<iostream>\n#include<cstdlib>\n#include<cmath>\n#include<ctime>\n#include<bitset>\n#include<cstring>\n#include<algorithm>\n#include<string>\n#include<queue>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\n#define int ll\nconst int N = 1010,mod = 1e9 + 7;\nll read() {\n\tll x=0,f=1;char c=getchar();\n\twhile(c<'0'||c>'9') {\n\t\tif(c=='-') f=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9') {\n\t\tx=x*10+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*f;\n}\nint n,h[N];\nint qm(int x,int y) {\n\tint ret = 1;\n\tfor(;y;y >>= 1,x = 1ll * x * x % mod)\n\t\tif(y & 1) ret = 1ll * ret * x % mod;\n\treturn ret;\n}\n#define pi pair<ll,ll>\n\npi solve(int l,int r,int lim) {\n\tint mn = 1e9,cnt = 0;pi ret;\n\tfor(int i = l;i <= r;++i) {\n\t\tif(h[i] < mn) {\n\t\t\tmn = h[i];cnt = 1;\n\t\t}\n\t\telse if(h[i] == mn) cnt++;\n\t}\n\tif(cnt == r - l + 1) {\n\t\tret.first = (qm(2,r - l + 1) - 2 + mod) % mod;\n\t\tret.second = qm(2,mn - lim - 1);\n\t\treturn ret;\n\t}\n\tint len = r - l + 1,s0 = 1,s1 = 1,lst = 0;\n\tfor(int i = l;i <= r + 1;++i) {\n\t\tif(!lst && h[i] > mn) lst = i;\n\t\telse if(lst && (h[i] <= mn || i > r)) {\n\t\t\tlen -= i - lst;\n\t\t\tpi tmp = solve(lst,i - 1,mn);\n\t\t\ts0 = 1ll * s0 * (tmp.first + 4ll * tmp.second % mod) % mod;\n\t\t\ts1 = 1ll * s1 * (2ll * tmp.second % mod) % mod;\n\t\t\tlst = 0;\n\t\t}\n\t}\n\ts0 = (s0 - s1 + mod) % mod;\n\tret.first = 1ll * s0 * qm(2,len) % mod;\n\tret.first += 1ll * s1 * (qm(2,len) - 2 + mod) % mod;\n\tret.second = s1 * qm(2,mn - lim - 1) % mod;\n\treturn ret;\n}\n\n main() {\n\tn = read();\n\tfor(int i = 1;i <= n;++i) h[i] = read();\n\tfor(int i = 1;i <= 100000;++i) \n\tif(n == 1) {\n\t\tprintf(\"%d\\n\",qm(2,h[1]));\n\t\treturn 0;\n\t}\n\tint ans = 1;\n\tfor(int i = 1;i <= n;++i) {\n\t\tif(h[i] > h[i - 1] && h[i] > h[i + 1]) {\n\t\t\tans = 1ll * ans * qm(2,h[i] - max(h[i - 1],h[i + 1])) % mod;\n\t\t\th[i] = max(h[i - 1],h[i + 1]);\n\t\t}\n\t}\n\n\tpi ret = solve(1,n,0);\n\tprintf(\"%lld\",1ll * ans * (ret.first + ret.second + ret.second) % mod);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define Mp make_pair\n#define pb push_back\n#define rep(i, j, k) for (int i = (j); i <= (k); i++)\n#define per(i, j, k) for (int i = (j); i >= (k); i--)\nusing namespace std;\n\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\n\nconst int N = 103,mod = 1e9+7,inf=0x3f3f3f3f;\nint n,a[N];\n\nint qpow(int a,int b){\n    int ret=1;\n    while(b){\n        if(b&1) ret=(ll)ret*a%mod;\n        a=(ll)a*a%mod; b>>=1;\n    }\n    return ret;\n}\nPII solve(int l,int r,int h){\n    if(l==r) {\n        int x=qpow(2,a[l]-h);\n        //printf(\"%d %d %d %d\\n\",l,a[l],h,x);\n        return Mp(x,x);\n    }\n    int mnh=inf;\n    rep(i,l,r) mnh=min(mnh,a[i]);\n    int c=1,t=qpow(2,mnh-h);\n    rep(i,l,r) if(a[i]==mnh) c=(ll)c*2%mod;\n    int x=1,y=1;\n    for(int i = l,j=l; i<=r; i=j+1,j=i){\n        if(a[i]==mnh) continue;\n        while(j<r&&a[j+1]!=mnh) j++;\n        PII ret=solve(i,j,mnh);\n        x=(ll)x*ret.fi%mod;\n        y=(ll)y*(ret.fi+ret.se)%mod;\n    }\n    int f=(ll)x*t%mod;\n    int s=((ll)c*y+(ll)(t-2+mod)*x)%mod;\n    //printf(\"%d %d %d %d\\n\",x,y,f,s);\n    return Mp(f,s);\n}\n\nint main(){\n    scanf(\"%d\",&n);\n    rep(i,1,n) scanf(\"%d\",&a[i]);\n    printf(\"%d\\n\",solve(1,n,0).se);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int mod = 1e9 + 7;\n\nint add(int x, int y) {\n  x += y;\n  if (x >= mod) {\n    x -= mod;\n  }\n  return x;\n}\n\nint sub(int x, int y) {\n  x -= y;\n  if (x < 0) {\n    x += mod;\n  }\n  return x;\n}\n\nint mul(int x, int y) {\n  return (ll)x * y % mod;\n}\n\nint power(int x, int y) {\n  int result = 1;\n  for (; y; y >>= 1, x = mul(x, x)) {\n    if (y & 1) {\n      result = mul(result, x);\n    }\n  }\n  return result;\n}\n\npair<int, int> solve(int l, int r, int base, vector<int> &a) {\n  int x = *min_element(a.begin() + l, a.begin() + r), coef = 1, all = 1, number = 0;\n  for (int i = l; i < r; ++i) {\n    if (a[i] != x) {\n      int j = i;\n      while (j + 1 < r && a[j + 1] != x) {\n        ++j;\n      }\n      pair<int, int> value = solve(i, j + 1, x, a);\n      i = j;\n      coef = mul(coef, value.first);\n      all = mul(all, add(value.first, value.second));\n    } else {\n      ++number;\n    }\n  }\n  return make_pair(mul(coef, power(2, x - base)), add(mul(all, power(2, number)), mul(coef, sub(power(2, x - base), 2))));\n}\n\nint main() {\n#ifdef wxh010910\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  int n;\n  scanf(\"%d\", &n);\n  vector<int> a(n);\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d\", &a[i]);\n  }\n  printf(\"%d\\n\", solve(0, n, 0, a).second);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <set>\n// #include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long li;\n\nconst li mod = 1e9 + 7;\n\nli pow(li x, li n) {\n    if (n == 0) {\n        return 1;\n    }\n    li sq = pow(x, n / 2);\n    li ans = sq * sq % mod;\n    if (n & 1) {\n        ans = ans * x % mod;\n    }\n    return ans;\n}\n\n\nli inv(li x) {\n    return pow(x, mod - 2);\n}\n\nstruct result {\n    li stripe;\n    li nonstripe;\n\n    result(li str, li nonstr) {\n        stripe = str;\n        nonstripe = nonstr;\n    }\n\n    li total() {\n        return (stripe + nonstripe) % mod;\n    }\n};\n\nresult recur(vector<li> hs) {\n    set<li> elements(hs.begin(), hs.end());\n    li width = hs.size();\n\n    if (elements.size() == 1) {\n        li height = hs.front();\n        return result(pow(2, height), (pow(2, width) - 2 + mod) % mod);\n    } else {\n        li height = *min_element(hs.begin(), hs.end());\n        vector<vector<li>> subs;\n        vector<li> sub;\n        li free = 0;\n        for (auto &&h : hs) {\n            li newh = h - height;\n            if (newh == 0) {\n                free += 1;\n                if (sub.size() > 0) {\n                    subs.push_back(sub);\n                    sub = vector<li>();\n                }\n            } else {\n                sub.push_back(newh);\n            }\n        }\n        if (sub.size() > 0) {\n            subs.push_back(sub);\n        }\n        li stripe = pow(2, height);\n        li nonstripe = pow(2, free);\n\n        li negnonstripe = 2;\n\n        for (auto &&sub : subs) {\n            auto res = recur(sub);\n            stripe *= res.stripe;\n            stripe %= mod;\n\n            nonstripe *= (res.nonstripe + res.stripe * 2 % mod) % mod;\n            nonstripe %= mod;\n\n            negnonstripe *= res.stripe % mod;\n            negnonstripe %= mod;\n        }\n\n        nonstripe = (nonstripe + mod - negnonstripe) % mod;\n        return result(stripe, nonstripe);\n    }\n}\n\nint main() {\n    li n;\n    cin >> n;\n\n    vector<li> hs(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> hs[i];\n    }\n\n    cout << recur(hs).total() << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#if defined(LOCAL)\nconst double _max_double_error = 1e-9;\n#include \"testutils.h\"\n#define L(x...) (debug(x, #x))\n#define I(x, ...) (x)\n#define C(x...) CHECK(x)\n#else\n#define L(x, ...) (x)\n#define I(x, ...) (x)\n#define C(x, ...) ;\n#endif\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <math.h>\n#include <limits>\n#include <numeric>\n\nusing namespace std;\nusing vi = vector<int>; using vvi = vector<vi>; using vvvi = vector<vvi>;\nusing ii = pair<int,int>; using lu = unsigned long long; using l = long long;\nusing vs = vector<string>; using vii = vector<ii>;\nusing vl = vector<l>; using vvl = vector<vl>; using vvvl = vector<vvl>;\nusing ll = pair<l,l>; using vll = vector<ll>; using vvll = vector<vll>;\nusing vb = vector<bool>; using vvb = vector<vb>;\nusing vd = vector<double>; using vvd = vector<vd>;\nusing mll = unordered_map<l, l>;\nconst l INF = numeric_limits<l>::max();\nconst double EPS = 1e-10; static constexpr auto PI = 3.1415926;\nconst l e0=1, e3=1000, e5=100000, e6=10*e5, e7=10*e6, e8=10*e7, e9=10*e8;\nconst char lf = '\\n';\n#define all(x) begin(x), end(x)\n#define F(a,b,c) for (l a = l(b); a < l(c); a++)\n#define B(a,b,c) for (l a = l(c) - 1; a >= l(b); a--)\n#define VVL(x, a, b, i) vvl x(a, vl(b, l(i)));\n#define VVVL(x, a, b, c, i) vvvl x(a, vvl(b, vl(c, l(i))));\n\nconst l MOD = e9 + 7; // end of template\n\nl sign(l n) {\n  if (n < 0) return -1;\n  if (n == 0) return 0;\n  return 1;\n}\n\n// conruent modulo, works for negative\nl cong(l x, l mod) {\n  return (x % mod + mod) % mod;\n}\n\n// (a * b) % mod, safe for l near max\nl mult_mod(l a, l b, l mod) {\n  l x = 0;\n  while (b) {\n    if (b % 2) x = (x + a) % mod;\n    a = (a * 2) % mod;\n    b /= 2;\n  }\n  return x;\n}\n\n// (base^power) % mod, safe for l near max\nl pow_mod(l base, l power, l mod) {\n  l r = 1;\n  while (power) {\n    if (power % 2) r = mult_mod(r, base, mod);\n    base = mult_mod(base, base, mod);\n    power /= 2;\n  }\n  return r;\n}\n\nl divup(l a, l b) { // ceil div\n  return (a + b - 1) / b;\n}\n\n// return gcd(a, b) and set x, y: a * x + b * y = gcd(a, b)\nl extended_euclid(l a, l b, l& x, l& y) {\n  if (b == 0) { x = 1; y = 0; return a; }\n  l d = extended_euclid(b, a % b, x, y);\n  l t = y;\n  y = x - (a / b) * y;\n  x = t;\n  return d;\n}\n\n// return b: a * b = 1 (mod n)\nl inverse_mod(l a, l n) {\n  l x, y;\n  l d = extended_euclid(a, n, x, y);\n  if (d != 1) return 0;\n  return cong(x, n);\n}\n\n// single combintions k from n\nl nCr(l n, l k, l mod) {\n  l a = 1;\n  for (l i = n; i > n - k; i--) a = mult_mod(a, i, mod);\n  l b = 1;\n  F(i, 1, k + 1) b = mult_mod(b, i, mod);\n  b = inverse_mod(b, mod);\n  return mult_mod(a, b, mod);\n}\n\n// precompute all combinations up to (n n)\nvvl combinations(l n, l mod) {\n  vvl c(n + 1, vl(n + 1));\n  F(i, 0, n + 1) {\n    c[i][0] = 1;\n    F(j, 1, i + 1) {\n      c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;\n    }\n  }\n  return c;\n}\n\n// l on the ring of MOD, put l arg to the right: lm = lm + l\nstruct lm {\n  l raw;\n  lm(): raw(0) {}\n  lm(l x): raw(x) {}\n  lm(lm const& x): raw(x.raw) {}\n  lm(lm&& x) { swap(*this, x); }\n  friend void swap(lm& a, lm& b) { swap(a.raw, b.raw); }\n  lm& operator = (l x) { raw = x; return *this; }\n  lm& operator = (lm x) { swap(*this, x); return *this; }\n  void operator += (const lm x) { raw = cong(raw + x.raw, MOD); }\n  lm operator + (const lm x) { lm z(*this); z += x; return z; }\n  void operator -= (const lm x) { raw = cong(raw - x.raw, MOD); }\n  lm operator - (const lm x) { lm z(*this); z -= x; return z; }\n  void operator *= (const lm x) { raw = cong(raw * x.raw, MOD); }\n  lm operator * (const lm x) { lm z(*this); z *= x; return z; }\n  void operator /= (const lm x) { raw = cong(raw * inverse_mod(x.raw, MOD), MOD); }\n  lm operator / (const lm x) { lm z(*this); z /= x; return z; }\n};\nusing vlm = vector<lm>;\n\nostream& operator << (ostream& o, const lm& v) {\n  o << v.raw;\n  return o;\n}\n\nvoid solve(istream& in, ostream& out) {\n  l n; in >> n;\n  vl h(n); F(i, 0, n) in >> h[i];\n  auto u = h; sort(all(u)); u.erase(unique(all(u)), end(u));\n  I(h, u);\n  l m = u.size();\n  vlm d(m + 1);\n  d[m] = 1;\n  l k = -1;\n  F(i, 0, n) {\n    vlm next(m + 1);\n    l p = lower_bound(all(u), h[i]) - begin(u);\n    C(p < m);\n    l over = i ? max(l(0), h[i] - h[i - 1]) : 0;\n    F(j, 0, min(k, p) + 1) next[j] = d[j] * pow_mod(2, over, MOD);\n    if (p > k) {\n      F(j, k + 1, p + 1) {\n        l e = u[j];\n        if (j) {\n          e = e - u[j - 1] + 1;\n          C(e > 1);\n        }\n        l top = h[i] - u[j];\n        C(top >= 0);\n        next[j] = d[m] * (pow_mod(2, e, MOD) - 2) * pow_mod(2, top, MOD);\n      }\n    }\n    F(j, p + 1, m + 1) next[m] += d[j] * 2;\n    swap(I(next), d);\n    swap(p, k);\n  }\n  lm z = 0;\n  F(i, 0, m + 1) z += d[i];\n  out << z << lf;\n}\n\nint main(int argc, char **argv) {\n  ios_base::sync_with_stdio(false); cin.tie(0);\n  cout << fixed << setprecision(15);\n#if defined(LOCAL)\n  tst::test_init(argc, argv);\n  // _generate_random_test = generate_random;\n  // _solve_brute = solve_brute;\n  // _player_b = player_b;\n  // _custom_solution_checker = solution_checker;\n  tst::maybe_run_tests(cin, cout);\n#else\n  solve(cin, cout);\n#endif\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nconst int N = 100005, P = 1000000007;\nint n, a[N], lg2[N], mn[N][17];\n\nint power(int a, int x) {\n  int ans = 1;\n  for (; x; x >>= 1, a = 1LL * a * a % P)\n    if (x & 1) ans = 1LL * ans * a % P;\n  return ans;\n}\n\nint better(int i, int j) {\n  return (a[i] < a[j] || (a[i] == a[j] && i < j)) ? i : j;\n}\nint query(int l, int r) {\n  int x = lg2[r - l + 1];\n  return better(mn[l][x], mn[r - (1 << x) + 1][x]);\n}\n\nstruct node {\n  int c0, c1, c2;\n  node(int d0 = 0, int d1 = 0, int d2 = 0) {\n    c0 = d0, c1 = d1, c2 = d2;\n  }\n};\n\nnode solve(int l, int r, int h) {\n  int pos = query(l, r), mnv = a[pos];\n  vector<int> v;\n  for (;;) {\n    v.push_back(pos);\n    if (pos == r) break;\n    int nxt_pos = query(pos + 1, r);\n    if (a[nxt_pos] == a[pos])\n      pos = nxt_pos;\n    else\n      break;\n  }\n  node res;\n  if (v[0] != l) {\n    res = solve(l, v[0] - 1, mnv);\n    res.c1 = (res.c0 + res.c1) % P;\n    res.c0 = res.c1;\n    res.c2 = (2LL * res.c2 + res.c0 + res.c1) % P;\n  } else\n    res = node(1, 1, 0);\n  for (int i = 1; i < (int)v.size(); ++i) {\n    if (v[i - 1] + 1 < v[i]) {\n      node tmp = solve(v[i - 1] + 1, v[i] - 1, mnv);\n      tmp.c1 = (tmp.c0 + tmp.c1) % P;\n      tmp.c0 = tmp.c1;\n      if (v[i - 1] - l & 1)\n        res = node(1LL * res.c0 * tmp.c0 % P, 1LL * res.c1 * tmp.c1 % P,\n          (1LL * res.c0 * tmp.c1 + 1LL * res.c1 * tmp.c0 + (0LL + tmp.c0 + tmp.c1 + tmp.c2) * res.c2 + (0LL + res.c0 + res.c1) * tmp.c2) % P);\n      else\n        res = node(1LL * res.c0 * tmp.c1 % P, 1LL * res.c1 * tmp.c0 % P,\n          (1LL * res.c0 * tmp.c0 + 1LL * res.c1 * tmp.c1 + (0LL + tmp.c0 + tmp.c1 + tmp.c2) * res.c2 + (0LL + res.c0 + res.c1) * tmp.c2) % P);\n    }\n    res.c2 = (2LL * res.c2 + res.c0 + res.c1) % P;\n  }\n  if (v.back() != r) {\n    node tmp = solve(v.back() + 1, r, mnv);\n    tmp.c1 = (tmp.c0 + tmp.c1) % P;\n    tmp.c0 = tmp.c1;\n    if (v.back() - l & 1)\n      res = node(1LL * res.c0 * tmp.c0 % P, 1LL * res.c1 * tmp.c1 % P,\n        (1LL * res.c0 * tmp.c1 + 1LL * res.c1 * tmp.c0 + (0LL + tmp.c0 + tmp.c1 + tmp.c2) * res.c2 + (0LL + res.c0 + res.c1) * tmp.c2) % P);\n    else\n      res = node(1LL * res.c0 * tmp.c1 % P, 1LL * res.c1 * tmp.c0 % P,\n        (1LL * res.c0 * tmp.c0 + 1LL * res.c1 * tmp.c1 + (0LL + tmp.c0 + tmp.c1 + tmp.c2) * res.c2 + (0LL + res.c0 + res.c1) * tmp.c2) % P);\n  }\n  res = node(mnv == h + 1 ? res.c0 : 1LL * (res.c0 + res.c1) * power(2, mnv - h - 2) % P,\n    mnv == h + 1 ? res.c1 : 1LL * (res.c0 + res.c1) * power(2, mnv - h - 2) % P, res.c2);\n  return res;\n}\n\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; ++i) {\n    scanf(\"%d\", a + i);\n    mn[i][0] = i;\n  }\n  for (int i = 2; i <= n; ++i)\n    lg2[i] = lg2[i >> 1] + 1;\n  for (int j = 1; 1 << j <= n; ++j)\n    for (int i = 1; i + (1 << j) - 1 <= n; ++i)\n      mn[i][j] = better(mn[i][j - 1], mn[i + (1 << j - 1)][j - 1]);\n  node res = solve(1, n, 0);\n  int ans = (0LL + res.c0 + res.c1 + res.c2) % P;\n  printf(\"%d\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntemplate <int MOD_>\nstruct modnum {\n\tstatic constexpr int MOD = MOD_;\n\tstatic_assert(MOD_ > 0, \"MOD must be positive\");\n\nprivate:\n\tusing ll = long long;\n\n\tint v;\n\n\tstatic int minv(int a, int m) {\n\t\ta %= m;\n\t\tassert(a);\n\t\treturn a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);\n\t}\n\npublic:\n\n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int() const { return v; }\n\tfriend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n\tfriend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }\n\n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n\tmodnum inv() const {\n\t\tmodnum res;\n\t\tres.v = minv(v, MOD);\n\t\treturn res;\n\t}\n\tmodnum neg() const {\n\t\tmodnum res;\n\t\tres.v = v ? MOD-v : 0;\n\t\treturn res;\n\t}\n\n\tmodnum operator- () const {\n\t\treturn neg();\n\t}\n\tmodnum operator+ () const {\n\t\treturn modnum(*this);\n\t}\n\n\tmodnum& operator ++ () {\n\t\tv ++;\n\t\tif (v == MOD) v = 0;\n\t\treturn *this;\n\t}\n\tmodnum& operator -- () {\n\t\tif (v == 0) v = MOD;\n\t\tv --;\n\t\treturn *this;\n\t}\n\tmodnum& operator += (const modnum& o) {\n\t\tv += o.v;\n\t\tif (v >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tif (v < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= o.inv();\n\t}\n\n\tfriend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\n\tfriend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\nusing num = modnum<int(1e9) + 7>;\n\nusing ll = long long;\n\nnum powmod(num a, ll b) {\n\tnum r = 1;\n\twhile (b) {\n\t\tif (b & 1) {\n\t\t\tr *= a;\n\t\t}\n\t\ta *= a;\n\t\tb /= 2;\n\t}\n\treturn r;\n}\n\nconst int MAXV = 110;\n\npair<num, num> go(vector<int> H) {\n\tint Hmin = *min_element(H.begin(), H.end());\n\tint num0 = 0;\n\tfor (int i = 0; i < int(H.size()); i++) {\n\t\tH[i] -= Hmin;\n\t\tif (H[i] == 0) num0++;\n\t}\n\n\tassert(num0 >= 1);\n\tnum p0 = 1;\n\tnum p1 = 1;\n\tint prv = 0;\n\tfor (int i = 0; i <= int(H.size()); i++) {\n\t\tif (i == int(H.size()) || H[i] == 0) {\n\t\t\tif (prv < i) {\n\t\t\t\tauto p = go(vector<int>(H.begin() + prv, H.begin() + i));\n\t\t\t\tp0 *= (p.first + p.second);\n\t\t\t\tp1 *= p.second;\n\t\t\t}\n\t\t\tprv = i+1;\n\t\t}\n\t}\n\tnum tot = powmod(2, num0) * p0 + (powmod(2, Hmin) - 2) * p1;\n\tnum alt = powmod(2, Hmin) * p1;\n\treturn {tot, alt};\n}\n\nint main() {\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tint N; cin >> N;\n\tvector<int> H(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> H[i];\n\t}\n\tauto ans = go(H);\n\tcout << ans.first << '\\n';\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nint N;\nint H[105];\nll mo=1000000007;\n\nll modpow(ll a, ll n = mo-2) {\n\tll r=1;a%=mo;\n\twhile(n) r=r*((n%2)?a:1)%mo,a=a*a%mo,n>>=1;\n\treturn r;\n}\n\npair<ll,ll> hoge(int L,int R,int v) {\n\tll dp1=1,dp2=1;\n\tint i;\n\t\n\tif(L>R) return {0,0};\n\t\n\tint mi=1<<30;\n\tfor(i=L;i<=R;i++) mi=min(mi,H[i]);\n\tint W=R-L+1;\n\tfor(i=L;i<=R;i++) if(mi!=H[i]) W--;\n\t\n\tint pre=L-1;\n\tfor(i=L;i<=R;i++) {\n\t\tif(mi==H[i]) {\n\t\t\tauto r=hoge(pre+1,i-1,mi);\n\t\t\tif(r.first>0) {\n\t\t\t\t(dp1*=r.first)%=mo;\n\t\t\t\t(dp2*=r.first+r.second)%=mo;\n\t\t\t}\n\t\t\t\n\t\t\tpre=i;\n\t\t}\n\t}\n\tauto r=hoge(pre+1,R,mi);\n\tif(r.first > 0) {\n\t\t(dp1*=r.first)%=mo;\n\t\t(dp2*=r.first+r.second)%=mo;\n\t}\n\t(dp2=dp2*modpow(2,W)+(modpow(2,mi-v)+mo-2)*dp1)%=mo;\n\t(dp1*=modpow(2,mi-v))%=mo;\n\t\n\treturn {dp1,dp2};\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tfor(i=1;i<=N;i++) cin>>H[i];\n\tcout<<hoge(1,N,0).second<<endl;\n}\n\nint main()\n{\n        solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define P 1000000007\n\nusing namespace std;\n\ntypedef long long ll;\n\nll h[111], Mn[111][111], Sm[111][111], SS[111][111], n, F[111];\n\nll powmod(ll x, ll y = P - 2, ll p = P) {\n    ll ans = 1;\n    while(y) {\n        if(y & 1) ans = ans * x % p;\n        x = x * x % p;\n        y >>= 1;\n    }\n    return ans;\n}\n\nint main() {\n    scanf(\"%lld\", &n);\n    for(int i = 1; i <= n; i++) scanf(\"%lld\", &h[i]);\n    h[0] = (h[n + 1] = 1);\n    for(int i = 1; i <= n; i++) {\n        Mn[i][i] = h[i], Sm[i][i] = h[i], SS[i][i] = h[i];\n        for(int j = i + 1; j <= n; j++) Mn[i][j] = min(Mn[i][j - 1], h[j]), Sm[i][j] = Sm[i][j - 1] + h[j], SS[i][j] = SS[i][j - 1] + max(h[j] - h[j - 1], 0ll);\n    }\n    F[0] = 1;\n    for(int i = 1; i <= n; i++) {\n        F[i] = F[i - 1] * 2 % P;\n        for(int j = 1; j <= i; j++) {\n            int r = Mn[j][i], l = max(h[i + 1], h[j - 1]) + 1;\n            if(l <= r) F[i] = (F[i] + 2 * F[j - 1] * (powmod(2, SS[j][i] - l + 1) - powmod(2, SS[j][i] - r))) % P;\n        }\n    }\n    printf(\"%lld\\n\", (F[n] % P + P) % P);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef BZ\n#pragma GCC optimize \"-O3\"\n#endif\n#include <bits/stdc++.h>\n\n#define FASTIO\n\n#ifdef FASTIO\n#define scanf abacaba\n#define printf abacaba\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\nconst ll MOD = 1e9 + 7;\n\n\nll pw(ll a, ll b) {\n\tll ans = 1; while (b) {\n\t\twhile (!(b & 1)) b >>= 1, a = (a * a) % MOD;\n\t\tans = (ans * a) % MOD, --b;\n\t} return ans;\n}\n\nint n;\n\nll h[1200];\n\nvector<ll> vv;\npair<ll, ll> ans[1200];\nint en[1200];\n\nint main() {\n#ifdef FASTIO\n\tios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n#endif\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i)\n\t\tcin >> h[i], vv.push_back(h[i]);\n\tsort(vv.begin(), vv.end());\n\tvv.resize(unique(vv.begin(), vv.end()) - vv.begin());\n\treverse(vv.begin(), vv.end());\n\tvv.push_back(0);\n\tfor (int i = 0; i < n; ++i)\n\t\ten[i] = 0;\n\th[n] = 0;\n\tfor (int it = 0; it < vv.size() - 1; ++it) {\n\t\tll hh = vv[it];\n\t\tint st = -1;\n\t\tint cnt = 0;\n\t\tvector<pair<ll, ll>> cur;\n\t\tll len = vv[it] - vv[it + 1];\n\t\tll gd = 1;\n\t\tll all = 1;\n\t\tfor (int i = 0; i <= n; ++i) {\n\t\t\tif (en[i] == 1) {\n\t\t\t\tif (st == -1)\n\t\t\t\t\tst = i;\n\t\t\t\tgd = (gd * ans[i].first) % MOD;\n\t\t\t\tall = (all * (ans[i].first * 2 + ans[i].second)) % MOD;\n\t\t\t}\n\t\t\telse if (h[i] == hh) {\n\t\t\t\tif (st == -1)\n\t\t\t\t\tst = i;\n\t\t\t\t++cnt;\n\t\t\t}\n\t\t\telse if (en[i] == 0) {\n\t\t\t\tif (st != -1) {\n\t\t\t\t\tfor (int j = st; j < i; ++j)\n\t\t\t\t\t\ten[j] = 2;\n\t\t\t\t\ten[st] = 1;\n\t\t\t\t\tans[st].first = gd * pw(2, len) % MOD;\n\t\t\t\t\tans[st].second = (all * pw(2, cnt) % MOD - gd * 2 % MOD + MOD) % MOD;\n\t\t\t\t}\n\t\t\t\tgd = all = 1;\n\t\t\t\tst = -1;\n\t\t\t\tcnt = 0;\n\t\t\t}\n\t\t}\n\t}\n\tcout << (ans[0].first + ans[0].second) % MOD;\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\nconst int MAXN = 100 + 5;\n\nconst int MOD = (int)1e9 + 7;\n\nint n, h[MAXN], sorted[MAXN];\n\nint qpow(int a, int x) {\n    int res = 1;\n    for (; x > 0; x >>= 1) {\n        if (x & 1)\n            res = 1LL * res * a % MOD;\n        a = 1LL * a * a % MOD;\n    }\n    return res;\n}\n\nbool added[MAXN];\nint R_L[MAXN], L_R[MAXN];\n\nint dp[MAXN][MAXN][2][2][2];\n\nvoid merge(int dp_l[2][2][2], int dp_r[2][2][2], int res[2][2][2]) {\n    int tmp[2][2][2];\n    \n    memset(tmp, 0, sizeof tmp);\n    \n    for (int l = 0; l < 2; ++l)\n    for (int r = 0; r < 2; ++r) {\n        for (int ll = 0; ll < 2; ++ll)\n        for (int rr = 0; rr < 2; ++rr)\n        for (int sl = 0; sl < 2; ++sl)\n        for (int sr = 0; sr < 2; ++sr) {\n            int t = sl | sr | (ll == rr);\n            tmp[l][r][t] = (tmp[l][r][t] + 1LL * dp_l[l][ll][sl] * dp_r[rr][r][sr]) % MOD;\n        }\n    }\n    \n    memcpy(res, tmp, sizeof tmp);\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; ++i) {\n        scanf(\"%d\", h + i);\n        sorted[i] = i;\n    }\n\n    for (int i = 1; i <= n; ++i)\n        for (int j = n; j > i; --j)\n            if (h[sorted[j - 1]] < h[sorted[j]]) {\n                int t = sorted[j - 1];\n                sorted[j - 1] = sorted[j];\n                sorted[j] = t;\n            }\n\n    for (int i = 1; i <= n; ++i) {\n        int j = sorted[i], k = sorted[i - 1], t = (h[k] - h[j]) & 1;\n\n        if (h[k] > h[j]) {\n            for (int L = 1; L <= n; ) {\n                if (!added[L]) {\n                    ++L;\n                } else {\n                    int R = L;\n                    while (R + 1 <= n && added[R + 1]) ++R;\n\n                    int tmp[2][2][2];\n\n                    for (int l = 0; l < 2; ++l)\n                    for (int r = 0; r < 2; ++r) {\n                        tmp[l][r][1] = dp[L][R][l ^ t][r ^ t][1];\n                        tmp[l][r][0] = 1LL * (dp[L][R][l][r][0] + dp[L][R][l ^ 1][r ^ 1][0]) * qpow(2, h[k] - h[j] - 1) % MOD;\n                    }\n\n                    memcpy(dp[L][R], tmp, sizeof tmp);\n                }\n            }\n        }\n\n        int tmp[2][2][2];\n        int L = j, R = j;\n\n        memset(tmp, 0, sizeof tmp);\n        tmp[0][0][0] = tmp[1][1][0] = 1;\n\n        if (R_L[j - 1]) {\n            int l = R_L[j - 1], r = j - 1;\n            L_R[l] = R_L[r] = 0;\n            merge(dp[l][r], tmp, tmp);\n            L = l;\n        }\n\n        if (L_R[j + 1]) {\n            int l = j + 1, r = L_R[j + 1];\n            L_R[l] = R_L[r] = 0;\n            merge(tmp, dp[l][r], tmp);\n            R = r;\n        }\n\n        added[j] = true;\n        memcpy(dp[L][R], tmp, sizeof tmp);\n        L_R[L] = R;\n        R_L[R] = L;\n    }\n\n    if (h[sorted[n]] > 1) {\n        int t = (h[sorted[n]] - 1) & 1;\n        int tmp[2][2][2];\n\n        for (int l = 0; l < 2; ++l)\n        for (int r = 0; r < 2; ++r) {\n            tmp[l][r][1] = dp[1][n][l ^ t][r ^ t][1];\n            tmp[l][r][0] = 1LL * (dp[1][n][l][r][0] + dp[1][n][l ^ 1][r ^ 1][0]) * qpow(2, h[sorted[n]] - 1 - 1) % MOD;\n        }\n        \n        memcpy(dp[1][n], tmp, sizeof tmp);\n    }\n\n    int ans = 0;\n    for (int i = 0; i < 2; ++i)\n    for (int j = 0; j < 2; ++j)\n    for (int k = 0; k < 2; ++k) {\n        ans = (ans + dp[1][n][i][j][k]) % MOD;\n    }\n\n    printf(\"%d\\n\", ans);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <algorithm>\n#define enter putchar('\\n')\n#define space putchar(' ')\n#define fi first\n#define se second\n#define mp make_pair\n#define ba 47\n#define mo 999999137\n#define mod 974711\n//#define ivorysi\n#define pii pair<int,int>\nusing namespace std;\ntypedef long long int64;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;char c = getchar();T f = 1;\n    while(c < '0' || c > '9') {\n\tif(c == '-') f = -1;\n\tc = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n\tres = res * 10 + c - '0';\n\tc = getchar();\n    }\n    res *= f;\n}\n\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {putchar('-');x = -x;}\n    if(x >= 10) out(x / 10);\n    putchar('0' + x % 10);\n}\nconst int MOD = 1000000007;\nint N;\nint h[105];\nbool vis[105];\nint inc(int a,int b) {\n    return a + b >= MOD ? a + b - MOD : a + b;\n}\nint mul(int a,int b) {\n    return 1LL * a * b % MOD;\n}\nint fpow(int x,int c) {\n    int res = 1,t = x;\n    while(c) {\n\tif(c & 1) res = mul(res,t);\n\tt = mul(t,t);\n\tc >>= 1;\n    }\n    return res;\n}\nvoid update(int &x,int y) {\n    x = inc(x,y);\n}\npii Solve(int l,int r,int v) {\n    int minv = 1e9;\n    for(int i = l ; i <= r ; ++i) minv = min(minv,h[i]);\n    int p,cnt = 0;\n    pii res = mp(1,1);\n    for(int i = l ; i <= r ; ++i) {\n\tif(h[i] > minv) ++cnt;  \n    }\n    for(int i = l ; i <= r ; ++i) {\n\tif(h[i] > minv) {\n\t    p = i;\n\t    while(p < r && h[p + 1] > minv) ++p;\n\t    pii f = Solve(i,p,minv);\n\t    res.fi = mul(res.fi,f.fi);\n\t    res.se = mul(res.se,inc(f.se,f.fi));\n\t    i = p;\n\t}\n    }\n    int t = mul(res.fi,2);\n    res.se = mul(res.se,fpow(2,r - l + 1 - cnt));\n    res.fi = mul(res.fi,fpow(2,minv - v));\n    res.se = inc(res.se,inc(res.fi,MOD - t));\n    return res; \n}\nvoid Solve() {\n    read(N);\n    for(int i = 1 ; i <= N ; ++i) {read(h[i]);}\n    pii ans = Solve(1,N,0);\n    out(ans.se);enter;\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << (x) << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){o<<\"sz = \"<<vc.size()<<endl<<\"[\";for(const T& v:vc) o<<v<<\",\";o<<\"]\";return o;}\ntemplate<unsigned int mod_>\nstruct ModInt{\n\tusing uint = unsigned int;\n\tusing ll = long long;\n\tusing ull = unsigned long long;\n\n\tconstexpr static uint mod = mod_;\n\n\tuint v;\n\tModInt():v(0){}\n\tModInt(ll v):v(normS(v%mod+mod)){}\n\texplicit operator bool() const {return v!=0;}\n\tstatic uint normS(const uint &x){return (x<mod)?x:x-mod;}\t\t// [0 , 2*mod-1] -> [0 , mod-1]\n\tstatic ModInt make(const uint &x){ModInt m; m.v=x; return m;}\n\tModInt operator+(const ModInt& b) const { return make(normS(v+b.v));}\n\tModInt operator-(const ModInt& b) const { return make(normS(v+mod-b.v));}\n\tModInt operator-() const { return make(normS(mod-v)); }\n\tModInt operator*(const ModInt& b) const { return make((ull)v*b.v%mod);}\n\tModInt operator/(const ModInt& b) const { return *this*b.inv();}\n\tModInt& operator+=(const ModInt& b){ return *this=*this+b;}\n\tModInt& operator-=(const ModInt& b){ return *this=*this-b;}\n\tModInt& operator*=(const ModInt& b){ return *this=*this*b;}\n\tModInt& operator/=(const ModInt& b){ return *this=*this/b;}\n\tll extgcd(ll a,ll b,ll &x,ll &y) const{\n\t\tll u[]={a,1,0},v[]={b,0,1};\n\t\twhile(*v){\n\t\t\tll t=*u/ *v;\n\t\t\trep(i,3) swap(u[i]-=t*v[i],v[i]);\n\t\t}\n\t\tif(u[0]<0) rep(i,3) u[i]=-u[i];\n\t\tx=u[1],y=u[2];\n\t\treturn u[0];\n\t}\n\tModInt inv() const{\n\t\tll x,y;\n\t\textgcd(v,mod,x,y);\n\t\treturn make(normS(x+mod));\n\t}\n\tbool operator==(const ModInt& b) const { return v==b.v;}\n\tbool operator!=(const ModInt& b) const { return v!=b.v;}\n\tfriend istream& operator>>(istream &o,ModInt& x){\n\t\tll tmp;\n\t\to>>tmp;\n\t\tx=ModInt(tmp);\n\t\treturn o;\n\t}\n\tfriend ostream& operator<<(ostream &o,const ModInt& x){ return o<<x.v;}\n};\nusing mint = ModInt<1000000007>;\nmint ex(mint x,int p){\n\tmint a = 1;\n\twhile(p){\n\t\tif(p&1) a*=x;\n\t\tx*=x;\n\t\tp/=2;\n\t}\n\treturn a;\n}\n\nint N;\nusing P = pair<int,int>;\nvector<int> h;\nusing State = array<int,3>;\t//l,r,hastwo?\nvector<P> pranges;\nmap<State,mint> dp,ndp;\nusing P = pair<int,int>;\nint prevx;\nvoid calc(P ran,int X){\n\tint L = ran.fs, R = ran.sc;\n\tint K = pranges.size();\n\tint i = L;\n\tmint f[2] = {}, nf[2] = {};\n\tf[0] = 1;\n\twhile(i!=R+1){\n\t\tint id = lower_bound(all(pranges),P(i,-1))-pranges.begin();\n\t\tint j = -1;\n\t\tbool isempty = 0;\n\t\tif(id==K || pranges[id].fs!=i){\t//empty\n\t\t\tif(id==K) j = R;\n\t\t\telse j = min(R,pranges[id].fs-1);\n\t\t\tisempty = 1;\n\t\t}else{\n\t\t\tj = pranges[id].sc;\n\t\t}\n\t\tassert(j!=-1);\n\t\tint len = j-i+1;\n\t\tmint x,y;\n//\t\tprintf(\"(i,j) = %d,%d\\n\",i,j);\n\n\t\tif(isempty){\n\t\t\tx = 2, y = ex(2,len)-2;\n\t\t}else{\n\t\t\tint dh = prevx-X;\n\t\t\tmint a = dp[{i,j,0}];\n\t\t\tmint b = dp[{i,j,1}];\n\t\t\tx = a*ex(2,dh);\n\t\t\ty = b;\n\t\t}\n\t\tif(i==L){\n\t\t\tnf[0] += f[0]*x;\n\t\t\tnf[1] += f[0]*y+f[1]*(x+y);\n\t\t}else{\n\t\t\tnf[0] += f[0]*x/2;\n\t\t\tnf[1] += f[0]*(x/2+y)+f[1]*(x+y);\n\t\t}\n\n\t\trep(d,2) f[d] = nf[d], nf[d] = 0;\n\t\ti = j+1;\n\t}\n\tndp[{L,R,0}] = f[0];\n\tndp[{L,R,1}] = f[1];\n//\tprintf(\"[%d,%d]   val = %d,%d\\n\",L,R,f[0].v,f[1].v);\n}\nint main(){\n\tcin>>N;\n\th.resize(N);\n\trep(i,N) cin>>h[i];\n\tvector<int> xs;\n\trep(i,N){\n\t\txs.pb(h[i]-1);\n\t}\n\txs.pb(0);\n\tsort(all(xs));\n\txs.erase(unique(xs.begin(),xs.end()),xs.end());\n\treverse(all(xs));\n\tprevx = -1;\n\tfor(int x:xs){\n//\t\tprintf(\"-------x = %d---------\\n\",x);\n\t\tvector<P> ps;\n\t\tint l = -1;\n\t\trep(i,N){\n\t\t\tif(h[i]>x){\n\t\t\t\tif(l==-1) l = i;\n\t\t\t}else{\n\t\t\t\tif(l!=-1) ps.pb(P(l,i-1));\n\t\t\t\tl = -1;\n\t\t\t}\n\t\t}\n\t\tif(l!=-1) ps.pb(P(l,N-1));\n//\t\tshow(ps);\n\t\tfor(P p:ps){\n\t\t\tcalc(p,x);\n\t\t}\n\t\tdp = ndp;\n\t\tndp.clear();\n\t\tprevx = x;\n\t\tpranges = ps;\n\t}\n\tmint ans = 0;\n\tfor(auto it:dp){\n\t\tState s = it.fs;\n\t\tmint v = it.sc;\n\t\tassert(s[0]==0 && s[1]==N-1);\n\t\tans += v;\n\t}\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int mod=1e9+7;\ninline int addmod(int x)\n{\n\treturn x>=mod?x-mod:x;\n}\ninline int submod(int x)\n{\n\treturn x<0?x+mod:x;\n}\nint fpow(int x,int y)\n{\n\tint ans=1;\n\twhile(y)\n\t{\n\t\tif(y&1) ans=1ll*ans*x%mod;\n\t\tx=1ll*x*x%mod;\n\t\ty/=2;\n\t}\n\treturn ans;\n}\nint n,a[1005],f[1005][2],st[100005],tp,ls[100005],rs[100005],inv2;\nvoid dfs(int u,int fa)\n{\n\tif(!u) return;\n\tdfs(ls[u],u),dfs(rs[u],u);\n\tint v=a[u]-a[fa];\n\tif(!ls[u]&&!rs[u])\n\t{\n\t\tf[u][1]=fpow(2,v);\n\t//\tprintf(\"u=%d,f=%d,%d\\n\",u,f[u][0],f[u][1]);\n\t\treturn;\n\t} \n\tif(!ls[u]||!rs[u])\n\t{\n\t\tint s=ls[u]+rs[u];\n\t\tf[u][0]=2ll*addmod(f[s][0]+f[s][1])%mod;\n\t//\tf[u][0]=submod(f[u][0]-f[s][1]);\n\t\tf[u][1]=1ll*fpow(2,v)*f[s][1]%mod;\n\t//\tprintf(\"u=%d,f=%d,%d\\n\",u,f[u][0],f[u][1]);\n\t\treturn;\n\t}\n\tf[u][0]=2ll*addmod(f[ls[u]][0]+2*f[ls[u]][1]%mod)*addmod(f[rs[u]][0]+2*f[rs[u]][1]%mod)%mod;\n\tf[u][0]=submod(f[u][0]-2ll*f[ls[u]][1]*f[rs[u]][1]%mod);\n\tf[u][1]=1ll*fpow(2,v)*f[ls[u]][1]%mod*f[rs[u]][1]%mod;\n\t//printf(\"u=%d,f=%d,%d\\n\",u,f[u][0],f[u][1]);\n}\nint main()\n{\n\tinv2=fpow(2,mod-2);\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\twhile(tp>1&&a[st[tp-1]]>a[i])\n\t\t{\n\t\t\trs[st[tp-1]]=st[tp];\n\t\t\ttp--;\n\t\t}\n\t\tif(tp&&a[st[tp]]>a[i]) ls[i]=st[tp],tp--;\n\t\tst[++tp]=i;\n\t}\n\t//for(int i=1;i<=n;i++)\n\t//\tprintf(\"i=%d,ls=%d,rs=%d\\n\",i,ls[i],rs[i]);\n\twhile(tp>1)\n\t{\n\t\trs[st[tp-1]]=st[tp];\n\t\ttp--;\n\t}\n\tdfs(st[tp],0);\n\tprintf(\"%d\",addmod(f[st[tp]][0]+f[st[tp]][1]));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio> \n#include <iostream> \n#include <algorithm> \nusing namespace std;\nconst int MOD=1e9+7;\ninline int mul(int a,int b)\n{return 1LL*a*b%MOD;}\ninline int add(int a,int b)\n{a+=b;return a>=MOD?a-MOD:a;}\ninline int sub(int a,int b)\n{a-=b;return a<0?a+MOD:a;}\nint p2(int b)\n{\n\tint a=2,ans=1;\n\tfor(;b;b>>=1,a=mul(a,a))\n\t\tif(b&1)ans=mul(ans,a);\n\treturn ans;\n}\nconst int Q=1<<8;\nint cmp[Q],a[Q];\nstruct dt{\n\tint f,g;\n\tdt(){}\n\tdt(int mus,int no)\n\t{f=mus,g=no;}\n};\ndt Gans(int l,int r,int lim)\n{\n\tint mn=MOD,ct=0;\n\tfor(int i=l;i<=r;i++)\n\t\tif(a[i]==mn)++ct;\n\t\telse if(a[i]<mn)ct=1,mn=a[i];\n\tif(ct==r-l+1)return dt(sub(p2(ct),2),p2(mn-lim));\n\tint p0=1,p1=1;\n\tfor(int lst=0,i=l;i<=r+1;i++)\n\t\tif(lst&&(a[i]==mn||i>r)){\n\t\t\tdt now=Gans(lst,i-1,mn);\n\t\t\tlst=0;\n\t\t\tp0=mul(p0,add(now.f,mul(now.g,2)));\n\t\t\tp1=mul(p1,now.g);\n\t\t}\n\t\telse if((!lst)&&a[i]>mn)lst=i;\n\tp0=sub(p0,p1);\n\treturn dt(add(mul(p0,p2(ct)),mul(p1,sub(p2(ct),2))),mul(p1,p2(mn-lim)));\n}\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tdt als=Gans(1,n,0);\n\tprintf(\"%d\",add(als.f,als.g));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SIZE 205\n#define INF 1000000005\n#define MOD 1000000007\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\nvector <int> vx;\nint H[SIZE];\nll dp[2][SIZE];\nll all[SIZE];\nll mpow(ll m,ll t){\n\tif(t==0) return 1LL;\n\tll ret=mpow(m,t/2);\n\tret=ret*ret%MOD;\n\tif(t%2==1) ret=ret*m%MOD;\n\treturn ret;\n}\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tvx.push_back(INF);\n\tvx.push_back(1);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&H[i]);\n\t\tvx.push_back(H[i]);\n\t}\n\tsort(vx.begin(),vx.end());\n\tvx.erase(unique(vx.begin(),vx.end()),vx.end());\n\tint pos=0;\n\tfor(int i=0;i+1<vx.size();i++){\n\t\tint low=vx[i]+1,up=vx[i+1];\n\t\tup=min(up,H[0]);\n\t\tif(low>up) dp[pos][i]=0;\n\t\telse{\n\t\t\tdp[pos][i]=2LL*(mpow(2,up-low+1)-1LL)%MOD*mpow(2,H[0]-up)%MOD;\n\t\t}\n\t}\n\tall[0]=2LL;\n\tfor(int i=1;i<n;i++){\n\t\tpos^=1;\n\t\tmemset(dp[pos],0,sizeof(dp[pos]));\n\t\tint t=lower_bound(vx.begin(),vx.end(),H[i])-vx.begin();\n\t\tfor(int j=0;j+1<vx.size();j++){\n\t\t\tif(dp[pos^1][j]==0) continue;\n\t\t\tif(j+1<=t){\n\t\t\t\tll vl=dp[pos^1][j];\n\t\t\t\tif(H[i-1]<H[i]) vl=vl*mpow(2,H[i]-H[i-1])%MOD;\n\t\t\t\tdp[pos][j]+=vl;\n\t\t\t\tif(dp[pos][j]>=MOD) dp[pos][j]-=MOD;\n\t\t\t}else{\n\t\t\t\tall[i]+=dp[pos^1][j]*2LL%MOD;\n\t\t\t\tif(all[i]>=MOD) all[i]-=MOD;\n\t\t\t}\n\t\t}\n\t\tif(all[i-1]!=0){\n\t\t\tfor(int j=0;j+1<vx.size();j++){\n\t\t\t\tint low=vx[j]+1,up=vx[j+1];\n\t\t\t\tlow=max(low,H[i-1]+1);\n\t\t\t\tup=min(up,H[i]);\n\t\t\t\tif(low<=up){\n\t\t\t\t\tdp[pos][j]+=all[i-1]*2LL%MOD*(mpow(2,up-low+1)-1LL)%MOD*mpow(2,H[i]-up)%MOD;\n\t\t\t\t\tif(dp[pos][j]>=MOD) dp[pos][j]-=MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\tall[i]+=all[i-1]*2LL%MOD;\n\t\t\tif(all[i]>=MOD) all[i]-=MOD;\n\t\t}\n\t}\n\tll ret=all[n-1];\n\tfor(int i=0;i+1<vx.size();i++){\n\t\tret+=dp[pos][i];\n\t\tif(ret>=MOD) ret-=MOD;\n\t}\n\tprintf(\"%lld\\n\",ret);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define pb push_back\n#define mp make_pair\n#define F first\n#define S second\n#define ld long double\n#define pii pair<int,int>\nint const M=200+10,M2=300+10,inf=1e9+10,mod=1e9+7;\nint a[M];\nint dp[M][M][2],mark[M][M][2];\nint pw(int x,int y)\n{\n\tif(y==0)return 1;\n\tint tmp=pw(x,y/2);\n\tif(y%2==0)return (tmp*tmp)%mod;\n\treturn ((tmp*tmp)%mod*x)%mod;\n}\nvoid fdp(int l,int r,bool ch)\n{\n\tif(mark[l][r][ch])return;\n\tmark[l][r][ch]=1;\n\tint now=max(a[l-1],a[r+1]);\n\tnow++;\n\tint mn=inf;\n\tfor(int i=l;i<=r;i++)\n\t{\n\t\tmn=min(mn,a[i]);\n\t}\n\tint last=l;\n\tdp[l][r][ch]=1;\n\tif(ch)dp[l][r][ch]=pw(2,mn-now);\n\t//if(ch)cout<<now<<\" \"<<mn<<\" \"<<dp[l][r][ch]<<endl;\n\tint bad=2;\n\t//if(ch==0)cout<<l<<\" \"<<\n\tfor(int i=l;i<=r;i++)\n\t{\n\t\tif(a[i]==mn)\n\t\t{\n\t\t\tif(last==i)\n\t\t\t{\n\t\t\t\tlast=i+1;\n\t\t\t\tif(!ch)dp[l][r][ch]*=2,dp[l][r][ch]%=mod;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(ch)\n\t\t\t{\n\t\t\t\tfdp(last,i-1,1);\n\t\t\t\tdp[l][r][ch]*=dp[last][i-1][1];\n\t\t\t\tdp[l][r][ch]%=mod;\n\t\t\t\tdp[l][r][ch]*=2;\n\t\t\t\tdp[l][r][ch]%=mod;\n\t\t\t\tlast=i+1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfdp(last,i-1,1);\n\t\t\tfdp(last,i-1,0);\n\t\t\tint tmp=dp[last][i-1][0]+(dp[last][i-1][1]*4);\n\t\t\ttmp*=2;\n\t\t\ttmp%=mod;\n\t\t\tdp[l][r][ch]*=tmp;\n\t\t\tdp[l][r][ch]%=mod;\n\t\t\tdp[l][r][ch]%=mod;\n\t\t\tbad*=dp[last][i-1][1]*2;\n\t\t\tlast=i+1;\n\t\t\t//cout<<last<<endl;\n\t\t//\tcout<<dp[last][i-1][1]<<endl;\n\t\t\tbad%=mod;\n\t\t}\n\t}\n\tif(last!=r+1)\n\t{\n\t\tif(ch)\n\t\t{\n\t\t\tfdp(last,r,1);\n\t\t\tdp[l][r][ch]*=(dp[last][r][1]);\n\t\t\tdp[l][r][ch]%=mod;\n\t\t\tdp[l][r][ch]*=2;\n\t\t\tdp[l][r][ch]%=mod;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfdp(last,r,0);\n\t\t\tfdp(last,r,1);\n\t\t\tbad*=dp[last][r][1]*2;\n\t\t\tbad%=mod;\n\t\t\tint tmp=dp[last][r][0]+dp[last][r][1]*4;\n\t\t\ttmp%=mod;\n\t\t\tdp[l][r][ch]*=tmp;\n\t\t\tdp[l][r][ch]%=mod;\n\t\t}\n\t}\n//\tif(!ch)cout<<l<<\" \"<<r<<\" \"<<dp[l][r][ch]<<\" \"<<bad<<endl;\n\tif(ch==0)\n\t{\n\t\tdp[l][r][ch]-=bad;\n\t\tdp[l][r][ch]+=mod;\n\t\tdp[l][r][ch]%=mod;\n\t}\n}\nint32_t main()\n{\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\tint n;\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)cin>>a[i];\n\tfdp(1,n,0);\n\tfdp(1,n,1);\n\t//cout<<dp[1][n][1]<<endl;\n\tcout<<(dp[1][n][1]*2+dp[1][n][0])%mod;\n}\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n)  for(int i = (k);i < (n);++i)\n#define REP(i,n)    FOR(i,0,n)\n#define ALL(x)      begin(x),end(x)\n\nusing namespace std;\nusing vecint = vector<int>;\nusing ll = int64_t;\nconst ll mod = 1000000007;\nconstexpr ll INF = 1000000000000000ll;\n\nstruct Mod {\n  ll n;\n  Mod () : n(0) {;}\n  Mod (ll m) : n(m) {\n    if (n >= mod) n %= mod;\n    else if (n < 0) n = (n % mod + mod) % mod;\n  }\n  operator ll() { return n; }\n};\n\nbool operator==(Mod a, Mod b) { return a.n == b.n; }\nMod operator+=(Mod &a, Mod b) { a.n += b.n; if (a.n >= mod) a.n -= mod; return a; }\nMod operator-=(Mod &a, Mod b) { a.n -= b.n; if (a.n < 0) a.n += mod; return a; }\nMod operator*=(Mod &a, Mod b) { a.n = (a.n * b.n) % mod; return a; }\nMod operator+(Mod a, Mod b) { return a += b; }\nMod operator-(Mod a, Mod b) { return a -= b; }\nMod operator*(Mod a, Mod b) { return a *= b; }\nMod operator^(Mod a, ll n) {\n  if (n == 0) return Mod(1);\n  Mod res = (a * a) ^ (n / 2);\n  if (n % 2) res = res * a;\n  return res;\n}\n\nMod pow2(ll n) {\n  return Mod(2) ^ n;\n}\n\nint main()\n{\n  ll n;\n  cin>>n;\n  vector<ll> h(n+2);\n  REP(i,n) cin>>h[i+1];\n  vector<Mod> dpa(n, 2), dpb(n, 0);\n  set<ll> sh;\n  REP(i,n) {\n    sh.insert(h[i+1]);\n    if (h[i] == h[i+1]) {\n      dpb[i] = Mod(2)*dpb[i-1] + Mod(2);\n    }\n  }\n  for_each(rbegin(sh), rend(sh), [&](ll hi) {\n    set<int> pos;\n    REP(i,n) {\n      if (h[i+1] == hi) {\n        pos.insert(i);\n      }\n    }\n    for (int p : pos) {\n      int l, r;\n      for (l = p-1; l >= 0; --l) {\n        if (h[l+1] < hi) break;\n      }\n      for (r = p+1; r < n; ++r) {\n        if (h[r+1] < hi) break;\n      }\n      bool old = false, old2 = true;\n      vector<ll> minh(1, INF);\n      int cnt = 0;\n      vector<Mod> vdpa, vdpb;\n      FOR(i,l+1,r) {\n        if (h[i+1] == hi) {\n          if (!old2) {\n            minh.push_back(INF);\n          }\n          old = false;\n          old2 = true;\n          ++cnt;\n          continue;\n        }\n        if (h[i+1] <= minh.back()) {\n          minh.back() = h[i+1];\n          if (old) {\n            vdpa.back() = dpa[i];\n            vdpb.back() = dpb[i];\n          } else {\n            vdpa.emplace_back(dpa[i]);\n            vdpb.emplace_back(dpb[i]);\n          }\n          old = true;\n          old2 = false;\n        }\n      }\n      if (vdpa.empty()) continue;\n      Mod a = 1;\n      REP(i, vdpa.size()) {\n        a *= vdpa[i] * pow2(minh[i] - hi - 1);\n      }\n      Mod b = 1;\n      REP(i, vdpa.size()) {\n        b *= Mod(2)*(vdpa[i] * pow2(minh[i] - hi - 1)) + vdpb[i];\n      }\n      Mod mb = 1;\n      REP(i, vdpa.size()) {\n        mb *= Mod(2)*(vdpa[i] * pow2(minh[i] - hi - 1));\n      }\n      cerr << p << ' ' << a << ' ' << b << ' ' << mb << ' ' << cnt << endl;\n      b -= mb;\n      dpa[p] = a*Mod(2);\n      dpb[p] = a * (pow2(cnt+vdpa.size()) - Mod(2)) + b * pow2(cnt);\n    }\n  });\n  int mn = 0;\n  ll mnh = INF;\n  REP(i,n) {\n    cerr << dpa[i] << ' ' << dpb[i] << endl;\n    if (h[i+1] <= mnh) {\n      mnh = h[i+1];\n      mn = i;\n    }\n  }\n  cout << dpa[mn] * pow2(mnh-1) + dpb[mn] << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define sz(a) int(a.size())\n#define clr(a) memset(a,0,sizeof(a))\n#define all(a) a.begin(),a.end()\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int inf=1e9;\nconst ll Inf=1e18;\nconst int N=110;\nconst int mod=1e9+7;\nint gi() {\n    int x=0,o=1;char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();\n    if(ch=='-') o=-1,ch=getchar();\n    while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n    return x*o;\n}\ntemplate<typename T> bool chkmax(T &a,T b) { return a<b?a=b,1:0; };\ntemplate<typename T> bool chkmin(T &a,T b) { return a>b?a=b,1:0; };\nint add(int a,int b) { return a+b>=mod?a+b-mod:a+b; }\nint sub(int a,int b) { return a-b<0?a-b+mod:a-b; }\nvoid inc(int &a,int b) { a=(a+b>=mod?a+b-mod:a+b); }\nvoid dec(int &a,int b) { a=(a-b<0?a-b+mod:a-b); }\nint n,a[N],f[N][N][2];\nvector<pii> line[N];\nint qpow(int a,int b) {\n    int ret=1;\n    while(b) {\n        if(b&1) ret=1ll*ret*a%mod;\n        a=1ll*a*a%mod,b>>=1;\n    }\n    return ret;\n}\nvoid solve(int l,int r,int h) {\n    if(l>r) return;\n    int mn=inf+1,k=0;\n    for(int i=l;i<=r;i++) if(chkmin(mn,a[i])) k=i;\n    //cerr<<l<<\" \"<<r<<\" \"<<qpow(2,mn-h)<<endl;\n    line[r].pb(mp(l,qpow(2,mn-h)));\n    solve(l,k-1,mn),solve(k+1,r,mn);\n}\nint main() {\n    n=gi();\n    for(int i=1;i<=n;i++) a[i]=gi();\n    solve(1,n,1);\n    if(line[1].empty()) f[1][1][0]=f[1][1][1]=1;\n    else f[1][1][0]=f[1][1][1]=line[1][0].se;\n    for(int i=1;i<n;i++)\n        for(int j=1;j<=n;j++)\n            for(int k=0;k<2;k++) {\n                if(!f[i][j][k]) continue;\n                int nxt=f[i][j][k];\n                for(pii x:line[i+1]) if(x.fi>=j) nxt=1ll*nxt*x.se%mod;\n                inc(f[i+1][j][k^1],nxt);\n                nxt=f[i][j][k];\n                for(pii x:line[i+1]) if(x.fi>=i+1) nxt=1ll*nxt*x.se%mod;\n                inc(f[i+1][i+1][k],nxt);\n            }\n    int ans=0;\n    for(int j=1;j<=n;j++)\n        for(int k=0;k<2;k++) inc(ans,f[n][j][k]);\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\nusing namespace std;\nconst int N=110,Mo=1000000007;\nint f[N][N],a[N],v[N];\ninline int gi() {\n    int x=0,o=1;\n    char ch=getchar();\n    while(ch!='-'&&(ch<'0'||ch>'9')) ch=getchar();\n    if(ch=='-') o=-1,ch=getchar();\n    while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n    return x*o;\n}\ninline int Pow(int x,int y) {\n    int ret=1;\n    while(y) {\n\tif(y&1) ret=1LL*ret*x%Mo;\n\tx=1LL*x*x%Mo,y>>=1;\n    }\n    return ret;\n}\nint main() {\n    int n,k,ans=0;\n    cin>>n;\n    for(int i=1;i<=n;i++) a[i]=v[i]=gi();\n    sort(v+1,v+1+n);\n    k=unique(v+1,v+1+n)-v-1;\n    for(int i=1;i<=n;i++) a[i]=lower_bound(v+1,v+1+k,a[i])-v;\n    f[0][0]=1;\n    for(int i=1;i<=n;i++) {\n\tf[i][0]=2LL*f[i-1][0]%Mo;\n\tfor(int j=a[i]+1;j<=a[i-1];j++)\n\t    f[i][0]=(f[i][0]+2LL*f[i-1][j])%Mo;\n\tint t=(a[i]<=a[i-1]?1:Pow(2,v[a[i]]-v[a[i-1]]));\n\tfor(int j=min(a[i],a[i-1]);j;j--)\n\t    f[i][j]=1LL*t*f[i-1][j]%Mo;\n\tfor(int j=a[i-1]+1;j<=a[i];j++) {\n\t    int t=(j==1?Pow(2,v[j])-2:Pow(2,v[j]-v[j-1]+1)-2);\n\t    f[i][j]=(f[i][j]+1LL*f[i-1][0]*t%Mo*Pow(2,v[a[i]]-v[j]))%Mo;\n\t}\n    }\n    for(int i=0;i<=k;i++) ans=(ans+f[n][i])%Mo;\n    cout<<ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = (int)1e9 + 7;\nconst int inv2 = (mod + 1) / 2;\ntypedef long long ll;\nint sum(int a, int b) {\n    int s = a + b;\n    if (s >= mod) s -= mod;\n    return s;\n}\nint sub(int a, int b) {\n    int s = a - b;\n    if (s < 0) s += mod;\n    return s;\n}\nint mult(int a, int b) {\n    return (1LL * a * b) % mod;\n}\nint pw(int a, int b) {\n    if (b == 0) return 1;\n    if (b & 1) return mult(a, pw(a, b - 1));\n    int res = pw(a, b / 2);\n    return mult(res, res);\n}\npair < int, int > solve(vector < int > h) {\n\n    if (h.empty()) return make_pair(1, 2);     //// ???\n    if (h.size() == 1) return make_pair(pw(2, h[0]), pw(2, h[0]));\n    int mn = h[0];\n    for (int i = 0; i < h.size(); i++) {\n        if (h[i] == 1) {\n            vector < int > nh1, nh2;\n            for (int j = 0; j < i; j++) nh1.push_back(h[j]);\n            for (int j = i + 1; j < h.size(); j++) nh2.push_back(h[j]);\n            pair < int, int > f1 = solve(nh1);\n            pair < int, int > f2 = solve(nh2);\n            return make_pair(mult(2, mult(f1.first, f2.first)), mult(mult(f1.second, f2.second), inv2));\n        }\n        mn = min(h[i], mn);\n    }\n    vector < int > small;\n    small.push_back(-1);\n    for (int i = 0; i < h.size(); i++) {\n        if (h[i] == mn) small.push_back(i);\n    }\n    small.push_back(h.size());\n    vector < pair < int, int > > all;\n    for (int j = 0; j + 1 < small.size(); j++) {\n        vector < int > nh;\n        if (small[j] + 1 == small[j + 1]) continue;\n        for (int i = small[j] + 1; i < small[j + 1]; i++) {\n            nh.push_back(h[i] - mn + 1);\n        }\n        all.push_back(solve(nh));\n    }\n    if (small.size() == h.size() + 2) {\n        return make_pair(sub(sum(pw(2, mn), pw(2, h.size())), 2) ,pw(2, mn));\n    }\n    int num = small.size() - 2;\n    int f2 = 1;\n    for (int i = 0; i < all.size(); i++) {\n        f2 = mult(f2, mult(all[i].second, inv2));\n    }\n    int final2 = mult(f2, pw(2, mn));\n    int f1 = 1;\n    for (int i = 0; i < all.size(); i++){\n        f1 = mult(f1, all[i].first);\n    }\n    f1 = mult(f1, pw(2, num));\n    f1 = sub(f1, mult(2, f2));\n    f1 = sum(f1, final2);\n    return make_pair(f1, final2);\n}\nint main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    ios_base::sync_with_stdio(false);\n    //freopen(\"input.txt\", \"r\", stdin);\n    srand(time(0));\n    int n;\n    vector < int > h;\n    cin >> n;\n    h.resize(n);\n    for (int i = 0; i < n; i++) cin >> h[i];\n    cout << solve(h).first;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*\nCoded by 秦惜梦\nThe most attractive girl in the world\n@@@@@@@@@@##&|;!!!!!!!!!!||||||||%%%%%$$$$$$$$$$$$%%$$$&&&&&&&&&$$&&&&&&&&&@@@&%||||||$&&&&@&%;'```'`':!||%&@@@@#@&&&&&@@@&&$$$&&@@&$$$&@@@@@@@@@@@@@#@@@@@@@@@@#@@@@@#@@@@@@@@@@##$\n@@@@@@@@@####$!;!!!!!!!!!||||||||%%%%%%%%%%%%%%%$$$$&&&&&&&&&&&&&&&&&&&&@@@@@@&%|||||!:'`'!$&&&&&&%:''!|||$&&&@@@@@@&&&&&@@@&$$$&&@&&$&&@@@@@@@@@@@@@@@@@@@@@@@@##@@@@#@@@@@@@@@@#@%\n@@@@@@@@@####@|;!!!!!!!!!|||||||%%%%%%%%%%%%%$$$$$$$$$$&&&&&&&&&&&&&&&@@@@@@@@&%|;:'''''``````'!$&&&@@&|:;%$$&&&@@@@@&&&&&@@@&$$$&&@@@@@@@@@@@@@@@@@@@@@@@#@@@@@#@@@@@#@@@@#@@@@##@%\n@@@@@@@@####@@&|;!!!!!!!!|||||||%%%%%%%%%%%%%%$$$$$$$$&&&&&&&&&&&$$$&&@@@@@@@@@@&$|;'''''````````'':!$&&&$%%%%$$&@@@@@&&&&&@@@@&&&@@#@@@@@@@@@@@@@@@@@@@@@@@@@@@#@@@@@@@@@@#@@@@#@@%\n@@@@@@@#####@@@$!;!!!!!!|||||||%%%$$$$$%%%%%%%%%$$$$$$$&&&&&&&&&$$$$&&@@@@@@@@$%$&@@&&&@&$%;:':;:''`````'|%%%%%%$$&@@@@@&&&&@@#@@@@@@#@@@@@@@@@@@@@@@@#@@@@@@@@@#@@@@@@@@@@@@@@#@@@%\n@@@@@@#####@$%%%$$$%%%||%%||||%%%%$%%$$$$$%%%%%%%$$$$&&&&&&&&&$$$$$$&&@@@@@@@&$;'''''':!%&&&&&&@@&%;'```:$&&%%%%%$$$&@@@@&&&&@@@@@@@@@#@@@@@##@@@@@@@@#@@@@@@@@@@@@@@#@@@@@@@@@#@@@%\n$&@@@@######&&&&&$%%%%|%|||||||%%%%%$$$$$$$$$$$$$&&&&&&&&&&&&&&&&$$$$&&@@@@@@&$!''''''````````:!|$&&&&&&&$&&&$%%%%$$$&&@@@&&&&&@@@@&@@@@@@@@@#@@@@@@@@#@@@@@&&&@@@@@@@@@@@@@@@#@@@@$\n$$$&@######@&&&&&&|!!!!!|||||||%%$$$$$$$$$$$$$$$&&&&&$$&&&&&&&&&&&&$$&&&@@@@@@&%;::''````````'':'``....`;|%$&&&$%%$$$$$&@@@&&&&&@@@@@@@@#@@@@@#@@@@@@@@@@@@@@&&@&&&&&&&&&@@@@@@@@@@$\n$$$&@#####@&$$&&@#&|!!!!!|||||||%%%$$$$%%%%%$$$$$$$&&&&&&&&&&&&@@@@@&&&&&&@@@@@@@@@@@&&&&&&&&@@@@&&$$%||||%%%$$&&&$$$$$$$&@@@&&&&&@@@@@@@#@@@@@@@@@@@@@@@@@@@@&&@&&&&&&&&@@@@@@@@@#$\n$$&@######@&$&@##@&$|!!!!|||||||%%%%%%%%%%%%%$$$$&&&&&&&&&&&&&&&&&&&&$$&&&&&&@@&|'`````````':::;;;;;;!|%%%%%%%%$&@@&$$$$$$$&@@&&&&&@@@@@@@@@@@@@@@@@@@@#@@@@@@@@@&&&&&&&&&@@@@@@@#@%\n$&@######@&&&@##@$$$$|!!!||||||||%%%%%%%%%%%%$$$$&&&&&&&&&&&&&&&&&&&&$&&&&&&&&@@$!:::'':::::::::::::''``.:%%$$$$$$&@@@&$$$$$&@@@&&&&@@@@@@@@@@@@#@@@@@@@@@@#@@@@#@@@@@@&&&@@@@@@@@@%\n$&@######@&&@#@&$$$$&$|!!!||||||||%%%%%%%%%$$$$$&&&&&&&&&&&&&&&&&&&$$$&&&&&&&&&&&%;::::::::::::':''':'':::%&$$$$$$$$&&@@&$$$$$&@@@&&&&@@@@@@@@@@@@@@@@@@#@@@@@@@@@@@@@@@@@@@@@@@@@@%\n&@#######@@@#@&$$$$$&&$|!!|||||||||%%%%%%$$$$$$$$$&&&&&&&&&&&&&&&$$$$$&&&&&&&&&&&$!''::::'''::;!|%%$&&@@@@&&@@$$%%$$$$&&@&&$$$$&@@@&&&&@@@@@@#@@@@@@@@@@@@@@@@@#@@@@@@@@@@@@@@@@@@@%\n############&$$$$$$$&&&$|!!||||||||%%%%%%$$$$$$$$$$$$$$&&&&&$$$$$$$$$$&&&&&&&&&&&&@@@&&&&&&&@@@@@@&&&$$%|!;%@@@@&$$$$$$$$&@@&$$$$&@@@&&&@@@@@@@@@#@@@@@@#@@#@@@@@@@@@@@@@@@@@@@@@@@$\n########@&$$$$$$$$$&&&&&$|!!||||||%%%%%%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$&&@@&&&&&&&&&&&&&&$$$$$$$$$$&&&$$%!;:::|$&@@@@&$$$$$$$&@@&$$$&@@@&&&@@@@@@@@##@@@@@@@@@@@@#@@@@@@@@@@@@@@@@@@@$\n########@$%%%$$$$$$&&&&&&&%!||||%%%$$$%%%%%%%%%%%%%%%%%%%%%%%$$$$$&&&&&&&&&&@@@&&&&&&&&&&&&$$$$$$$$$$$$$&&%!!$$$$&@@@@&$$$$$$&@@@&&&&@@@&&@@@@@@@##@@@@@#@@@@@@@@@@@@@@@@@@@@@@@@@@%\n#######@&$$$$$$$$$$$$&$|!||%%%%||%%%%%%%%%%%%%%%%%$$$$$$&$$$$$&&&&&&&&@@@@&&&&&&&&&&&&&&&&&&&$$&&$$$$$$$$$&&&$&@&$$$&@@@&$$$$$$&@@@@&&@@@@&@@@@@@###@@@@@@@@@@@@@@@@@@@@@@@@#@@@@#@%\n#######@$$$$$$%$$$$$$$&&$||||%%%%%%$$$$$$$$$$$$$$$$$$$$$$$&&&&&&&&&&@@&&&&&&&&&&&&$$$$$$&&&&$$$$$$$$$$$$$$$$$$&@@@@&$$$&@@@&$$$$&&&@@@&@@@@&&@@@@@###@@@@#@@@@@#@@@@@@@@@@@#@@@@#@@$\n#######&$$$$$$$$$$&$$$$$&&&&&$%||%%%%%%$$$$$$$$$$$$$$$$$&&&&&&&&&&&@&&&&&&&&&&&&$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$&&@@@&$$$&@@@&$$&&&@@@@@@#@@@@@@@@##@@@@#@@@@@@@@@@@@@#@@@@@@##@##$\n######@$$$$$$$$$$$$$$$$$$&&&&&&$||%%%%%%%$$$$$$$$$$$$$&&&&&&&&&@@&&&&&&&&&&&&&&$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$&@@@@@&&$&&@@@&&&&&@@@@@##@@@@@@@##@@@###@@@@@@@@@@@@@@#@@@#@#@@%\n######&$$$$$$$$$$$$$$$$$&&&&&&&&$%|%%%%%%%$$$$$$$$$$&&&&&&&&&&@&&@@&&&&&&&&&&$$$$$$$$$$$$$$$$$$$$$$$&$$$$$$$$$$$$$$$$&@@@@@@&&&&&@@@&&&&@@@@@#@@@@@###@@@##@@@@@@@@@@@@@@#@@@####@#$\n#####@$$$$$$$$$$$$$$$$$$$&&&&&&&&&%%%%%%%%%$$$$$$$$&&&&&&&&&&&&&&&&&&&&&&&&$$$$$$$$$$$$$$$$$$$$$$$$$$&$$$$$$$$$$$$$$$$$&&&@@@@@&&&&@@@@@@@@@@@@#@@@@###@@@$%%%%%%%%%%%%%$&@@#######$\n#####@&$%$$$$$$$$$$$$$$$$$$&&&&&&&&$%%%%%%%%%%$$$$&&&&&&&&&&&&&&&&$$$$$$$$$$$$$$$$$$$$$$$$$$%$$$$$$$$$%%$$$$$$$$%%$$$$$%&@&&&&@@@@@&&@@@@@&&@@@@#@@@@###@&%%%%%%%%%%%%%%%%%&@##@##@%\n####@@@@&$$$$$$$$$$$$$$$$$$&&&&&&&&&&%%%%%%%%%%$$&@&&&&$&&&$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$||$$$$$$$$%%$$$$$|%$$$$$$$%%$&@@@&&&@@@@@@@@@@@@&@@@@@@@@##@&%%%%%%%%%%%%%%%%%%%$@@@@@%\n####@@@@@@&$%$$$$$$$$$$$$$$$$$&&&&&&&&$%%%%%%%$&&&&&$$$$$$&$$$$$$$$$$$$$$$$$$$$$$$%%$$$%%%%|!|||$$$$%!|%%%$$&$$$$$$$$$$%%%$&@#@@@@&&@@@@@@@@@@@@@@##@@@@#@@@&$$%%%%%%%%|%%%%%|$@@@@$\n###@@@@@@@@$$$%$$$$$$$$$$$$$&&&&&&&&&&&&%%%%%&&&&&$%%%$$&&&$$$$$$$$$%%%$$|%$$$%%%$%%|%%!;!||!!||%$$$$$$$%%$&$$&&$$$$$$$$$$%%$@@#@@@@@@&&@@@@@@@@#@@###@@@########@@$%%%%%%%|%%$&@##$\n##@@@@@@@@@&$$$&$$$$$$$$$$$$$$$&&&&&&&&&&&%%%$&%|%%%%%$%%$$%%%%%%$$$%%%$$||%%%$$$$$%%%%%$$$$$%!!|%&&$$$$%|$$$$$$&$$$$$$$$$$$%$$&@@@@@@@@@@@@@@@##@@@@##@@####@@#######&%%%%%%%$@###$\n#@@@@@@@@@@&&$$&$$$$$$$$$$$$$$$&&&&&&$||%%%$$%!;!;!|%%%%$%!||||%%%$$$||%$%%%%%%$$$$%$$%%%%$%$$$$||$&&$$&%|%$$$$$$$&$%%$%|%$$$$%$%$@@@@@@##@@@@@@@@@@########@##@@@######&$$&@@@@@##$\n@$$&@@@@@@@&&$$$$$$$$$$$$$$$$$$&&&$&&&&$$&$$%!|%%%%%%%%%%||%%%%%%%%$$||%$$$$%%%%$$$%%$$%%%%%%%$$%|%&&$$&$%%$$$$$$$&&$%%&&&&$$$$$$$||$@@@@@@@@@@@@@@@@@@@####@@@@##@@@#@@@@@@@@@@@@@%\n&$%%$$&&&$$$$$$$$$$$$$$$$$$$$$$$$$$&&&&&&&&|!|%%%%|%%%%%%$%%%%||||%$$%|%$&&$%%%%$$$$%$$%%%%$$$$$%|$&&&$&$$$&$&$$$$&&&$%$&&&$$&&&&&$%!!|$&@@@@@@@@@@@@@@@@###@@@@@@@@@@@@@@@@@@@@@@@%\n$$%$$$$$$$$$$$$$$$$$$$$$$$$$$$$&&&$&&&&&&$|!|||%%|%%%%%%$$%%%%||||%$$%%%$&&$%%%$$&&&$$$$$$$$$$$$$%%&&&&&$$&&$&$$&&&&&&&&&&&&&&&&&&&&$|!!!!$&@@@@@@@@@@@#####@######@##@@&@@@@@@@@@@$\n$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$&&&&&&$|!|||%$%%%%%%%$$$$%%%||||%$$%%%$&&$$%%$&&&&&$$$$$$$$$$$$%%&&&&&$$&&$&$$&&&&&&&&&&&&&&&&&&&&&&%!!!!|&&&@@@@@@#########@########@@##########$\n$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$&&&&&$&$%|!||%$$%%$%%%%$$$$$%%|||||$$$&$$&$$$%$&&&&&&$$$$$%$$$$$$%$&&&&&&&&&&&$$&&&&&&&&&&&&&&@@&&&&&@@$|!$@&||||%&@#@@####@########@@@@@@@#@&&@@##$\n$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$&&&$$&$%|!||%$$%%%%%%%$$$%$$%%||||%$&&&&&&$$$$$$&&&&&$%$$$%%$$$$$%$&&&&&&&&$$$$$&&&&&&&&&&&&&&@@@&&@@@@@&@@&|||||||||%&@###############@@@@@@##@@@@%\n%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$&$&&$$$$%!!|%$$$%%%%%%$$$$%$$$%||||$&&$$&&$$$$$$$&&&$&$%%$%%%%%%$$%$$$&&&&&$$$$$$&&&&&&$&&&&&&&&&&&&&&&@@@@&||||||||||||$@#####@@@########@@@@@###@@$\n%%%%%%%%$$$$$$$$$$$$$$$$$$$$$$$$$&&%%&%!!||%$$%%$$%%$$$$%%$$%%|!|%&&$%%&&$%%%%$$$&$|%$||$%%%%%%$$$$$$&&&&$$$$$$&&&&&&$$$&&&&&&&&&&@@&&&@@@&&%|||||||||%&@@##@$$@@@@########@@@@@@##$\n;:''':;!|%%$$$$$$$$$$$$$$&&&&&&&&%%&&$!!|%%%%%%%$$$$$$$%%%$%%%|||$$&%!%&$%%%%|%%%&%!|$||%%%%%%%$$$$%%$&&$$$$$$$&&&&&&$$$$&&&&&&&&&&&&&&@@@@&&%|||||||%@@@@#@%|&#$||||%&@@@@@@@@@@@@$\n.....  .`;|%%$$$$$$$$$$$&&&&&&$%%$&&$!;|%%|||%%$$&&&&$$%%$$%%%%%%%&%!;|$$%||||%%%$|;!%||$%$$$$$%%%%||$&$%%%$$$$&&&&&&$$$$&&&&&&&&&&&&&@@@@@@&&%|||||$@@@##&%|%@@%||||||||||&@@@@@@@%\n........  `;|%$$$&&&&&&&&&&&$%$&&&&$|!|%%|!!|||$&$&&&$$%%%%%||||%$$|;;|%%|||||%$&&$|!|!!%%%%%%|!!|%!%$$%||%$&$&&&&&&&$$$$&&&&&&&&&&&&@@@@@@@@&&%|||$@@@##@$||$#&|||||||||||&#$|||||!\n...    ..  `;|%$$$$&&&&&&$%$$&&&&&&||%%$||!!||$&$$$$$$%%%%%%||||%$%!:!!!%%$$$%%%%|!;;;;;!!!!!;;;||!%&%|%%%$&&$&&&&&&&$$$$&&&&&&&&&&&@@@@@@@@@&&$||$@##@@@%||%&@$||||||||||%&@$|||||!\n       ..  .'!|%$$&&&&&&&&&&&&&&&&||$$&%||!||%&&$$$$$$%%$%||||||%|!;:;;;|%|!!!!!|!|$$&&&&$$$%!!!!;|&&$%%%$&$$$$%||&@&$$$$&&&&&&&&&@@@@@@@@@@@@&$|%@@@@#@%|||$@&%||||||||||%@@%|||||!\n       ... .';|%$$&&&&&&&&&&&&&&&%%&$&&%|||||%&&$$$$$$%%$%%%||||%!;:::::::'':;!|%%%%$&@&&$%|!|%|;!$&$%|%%$$$$&$|!|$@@&$$$&@@@@@@@@@@@@@@@@@@@@&$$@@@#@&%|||%&#$|||||||||||$@&%|||||!\n    ....   .:!|%$$&&&&&&&&&&&&&&$$&&&&$|||||%$@&$$&$$&&&$%|%%%%|;::''''''````'!!!;'`'%@&%|!::!;;!$$||%%%$&$$$$|!!|%&@@&&&&@@@@@@@@@@@@@@@@@@@@&&@@@@#@%||||$@@$|||||||||||$#&||||||!\n     ..   .';!|%$$$&&&&&&&&&&&&$$&&&&&$$%||%%&@&$$&$$$$%|!;;;;:::'`````````````````';;:;!;'::::;%$|||!!|$$$%$%||||$@@@&&&@@@@@@@@@@@@@@@@@&&@&&&&&&@@@$%%||&#&%||||||||||%&#$||||||!\n        .`:!!!|$$&&&&&&&&&&&&&&&&&&&&&&&$%$$$&@&&$&&$$|!|%$$$$%|;''``````````````':;!!!;::''':;!$%|$$%%$$$$$$%!!%&@@@@@@@@@@@@@@@@@@@@@@@@&&&&@&$$&@@@@@@@@@#&%||||||||||%@@$||||||!\n;:''`'':;!!!!|%$$&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&$&&&&&$|!%%%%$&$$|;'``````````````''''''''::::;|$&$$$%%$$%%$$$&@@@@@@@@@@@@@@@@@@@@@@@@@@@&&&@&$$$&&&@@@@@@@@@@@@@@&$%|||$@@$||||||!\n|!;;;!!!!!!|%$$$&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&%!:;|!||!!:'''``````````````''''''''':;;|$$$$$%%$%$$$&&&&&@@@@@@@@@@@@@@@@@@@@@@@@&&&@&$$$&&&&&@@@@@##@@@@@&&@@@@@@#@&%|||||!\n%|!!!!!!||%$$$&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&@@&&&&&&$$$!';;;:'```''`````````````````'''''';;:|$$$$$$$$%$$$&@&&&&@@@#@@@@@@@@@@@@@@@@@@@&&@&$$$$$$$&&&@@@@##@%;''|&@@@@@@@#@@@@@@@%\n&$%%%%%%$$$$&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&@&&&@&&&$$$%;``'''``':'``````````````````'''':::;|$$$$$$$%$$$$&&&&&&@@@##@@@@@@@@@@@@@@@@@@&@&$$$&&&$$$&&&@@@@|:''':%@@@@@@@#@@@@@@@@%\n@@&$$$$$&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&@&&@@&&&$$$$%:``````';:'```...`````````````'''':;|$$$$$$%%$$$$&&&&&&&@@##@@#######@@#@@@@@@#@&$$&&&&&$%$$&&@@%:'::'!&@@@@&@@@@@@@@@@@%\n##@&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&@@&&&&&&&$$%:``````':;:```..``````````````''':;|$$$$$$%%$$$&&&&&&&@@@####################@&$$&&$$$$$$$|;|&$!''':;$&&&&&&@@@@@@@@@@@%\n##@&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&$&@&$&&&$&&&&&%'``````.``````....```````````'`'';|$&$$$%$$$$$$&&&&&@@@@@##################@$$$&&$$$$$|:':;%&$;''''|&&&&&&&&@@@@@@@@@@%\n##@&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&$%$&@@$$$$$&&&&&@@!````````.......````````````''`'':!%$&&&$$&&&&&&&&&&@@@#@@##############@@&$$$$&$$$$$$|:''|&&|''''!$&&&&&&@@@@@@@@@@@@%\n##@&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&|;%&$&@$$$$$$&&&&&@@&;..``..........````````````''``'';%$&&&&&&&&&&&&&&@@@@@##@############@@@$$$$&$!|$$$$!:':%@%:``':%&&@@@@@@@@@@@@@@@@@%\n##@&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&$!!$&&$&&$|!|%$$$&&&@@@@$:.........``'''``':;:'`````````':!%$&&&&&&&@&&&&&@@@@@@@#@@#########@@@&$$$%!!$$$$$%;'';$&!``':%@@@@@@@@@@@@@@@@@@@&%\n##@&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&|;%&&&&$%%$%!|%%$$$$&&@@@@@$;`.....`...````````````````````';|$&&&&&&&&@@@&&&@###@@@@#@&&##@@@@@&$$$$&&$$$$$$|'```!&%;|&&&&&@@@@@@@@@@@@@@@&&&&%\n###&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&%:|&&&&&$$||$&$|%%%$$&&&@@@@@@@@$;`........``'::'`...```'``````:|$$$&@@&$&@@@@@@&@#@@####@#&&#@$|%&$$%%&&$$$$%!'`.`:!$@@&&&&@@@@@@@@@@@@@@&&&&&&&&%\n###@&&&&&&&&&&&&&&&&&&&&&&&&&&|:!&&&&&&$$%||$&&$%%%$$&&&&@@@@@@@@@@&%:`.................`'````:!;;|$$$&&@@&&&&@@@@&&@########@!':|&$$%%$|;:;;!|%%%%||$@@&&&&&&&@&&&&&&&&&&&&&&&&&&&%\n###@&&&&&&&&&&&&&&&&&&&&&&$!:|&&&&&&&&$$%|%$&&&$%%%$&&&&&@@@@@@@@@@@@&&$;`..............``'';|!;;;;|%$$$$&@@@&&&@@&&$$&&@@@@##@&%||%%%$!:|%%%%%||%!|$@@@&&&&&&&&$$$$$$&&&&&&&&&&&&&%\n###@&&&&&&&&&&&&&&&&&&&|:!$&&&&&&&&&&$%%%%$$&&&$%%$$$$&&@#@@@@@@@@@@@&&&&&&|'...........``:!!;;;;;!!;|$&$%|&@@@&&&&&$!|$$$&@@#@@&%%%%$|'':!%%%%|!|$&&@@&&&&&&&$%%%%$$$$$&&$$$$$$&&&%\n###@&&&&&&&&&&&&&&&|:;%&&&&&&&&&&&&$$%%%%$$&&&&$$$$$$$$&@#@@@@@@@@@&&&&&&&&&&&&|'.....`;%%!!!!;;;!!!!;!%$$&$|%@@@@@&&@$;:::!|%$&$%%%$%:'``';!!|||%$&@@@&&&&&&$%%%%%%%$$$$$%%%%$$$$$|\n###@&&&&&&&&&$|:;%&&&&&&&&&&&&&&&$$%%$%%$&&&&&&$$$$%$$$&@@@@@@@@@##@&&&&&&&&&&&&&&%|%&&&&&$|;;;;;;;;;;;;!$&$&$|!%&@@@@@@&%;::!$$$$$$%;:```````;||||%$&&$$$$$$%|%%%%%%%$$$%%%%%%%%$%|\n###@&&$%|||$&&&&&&&&&&&&&&&&&&$$$$%%$$%$&&&&&&&$$$%%$$&&@@@@@@@@@@@##@&&&&&&&&&&&&&&&&&&&&@%;;;;;;;::;;;;!!$&&$$%!;|$$$&&&$&&&$$$$$%!|$&%:...`.`;|!|||!;!|||||||%%%%%%$%%%||||%%%%%|\n&&@@&&&&&&&&&&&&&&&&&&&&&&&$$$$$$%%$$%$&&&&&&&&$%%%%$$&&@@@@@@@@@@@@#@&@@&&&&&&&&&&&&&@###&%;;;;;;::::;;;!!!!|$$$&&%!:;!$&&&@&$$$&@&&&$%$&|``..'%#@@&$%%||||!;:'`';|%%$%%|||||||||||\n###@&&&&&&&&&&&&&&&&&&&&$$$$$$$$%%$&&$$&&&&&&&&$%%%%$$&&&@@@@@@@@@@@@@@&&&&@@@@@&&@####$;':!!;;;::::;;;;!;!;::::;%&&&&&$$$&@&$$$@@$$$$$&@@@@$%@#@@##@@&%%||||||||%%%|!'`:!||||||||||\n###@&&&&&&&&&&&&&&&&&$$$$$$$$$$$$$$$%%$$$$&&&&@$%%%%$$&&&&&@@@@@@@@@&&&&@@&&&&&&&@@@@|:':;;!!;;:::::::;;!!;:::::::::':::';$$$$$&&$&&&@@@&&@@@@@#######@@##@&%||||||||%%%%|!''!|||||!\n###@&&&&&&&&&&&&&&$$$$$$$$$$$&&$$$$$%%$$$$$&&&&&$%%$$$&&&&&$&&&@@@@&&&&&&&&&&&&@@@%:''':;;;;;:::::::::;;;:::::::::::::;;!%$$$$$|:::|$&&$&@@@@@&$&@#####@@@@####@&$%||%%%||||||;:!||!\n###@&&&&&&&&&&&$$$$$$$$$$$&&&&&$$&&$%%$$$&&&&&&&&$%$$$$$&&&&&&&@@@#@&&&&&&&&@##$;''''':;;;;;:::::::::;!;:::::::::::::::;%&$$$$|''':;%&%!;:'''':|%$&@@@@#@@&&&@##@&&@@$|%%|||||||!:;|\n:;$@@&&&&&&&$$$$$$$$$$$&&&&&&&&&$$&&$$&&&&&&&&&&&$%%$$$&&&&&&&&&&&&@@#######@|:'''''';!!!;::::::;;!!!!;::::::::::::::::|$$$$$!'::;!!%&|;;''''''''''';$&@@#@&&$$&@&&@#@@@#####@$%||;:\n''''':|$&$$$$$$$$$$&&&&&&&&&&&&&&$$&$$&&&&&&&&&&&&&$$$$$&&$$&&&&&@@@@@&$%$%|:''''''':;:::::::::::::;;:::::::::::::::::|$$$$$!::;;;;|&%;;:''''''''''''':!$&@@@&$$$$&################$\n'''''''''';%$$&&&&&&&&&&&&&&&&&&&&$$$$&&&&&&&&&&&&&&$$$$$&@@@@@###@&&$%;''''''''':::;;:::::::::::;;:::'':::::::::::':|$$$$$!::;:::|&%;;:''''''''''''''```:%&@@&&&$$$&##############$\n'''''''''''':':|&&&&&&&&&&&&&&&&&&&&$%$&&&&&&&&&&&&&&$$$$$&@@&@@@&$$%%!:''''''::::::!;::::::::::;;::::::::::::::''':|$$$$$|;;:::;%&|::'''''''''''''`.....``;$@@&&&&$$$&@###########$\n;:'''''''''''''':::!$&&&&&&&&&&&&&&&&&%|$&&&&&&&&&&&&&&$$$$&$$$$$$|:!|;':::::::::::;!;::::::::;;:::::::::::::''''':|$$$$$|;::::|&&|::'''''''''''``........`''!&@@&&&&$$$&@#########$\n.';;;;;:'''''''''''':::;%&@&&&&&&&&&&&&%$&&$$$$&&&&&&$&@&&&$$$$%!:::!|;::::::::::::!!;::::::!;::::::::::::::''''':|&$$$$|;::::|&%;;:'``''''''''````......````'!$@@&&&&&$$$&@#######$\n;;;:`.`:;;;;::'''''''''''':;%@@@&&&&&&&&$$$&&&&&&&&&&@@&!::':'':::::||;::::::::::::!!;:::;!!;;:::::::::::::::''':%&$$$$|;:::;%&|:::'`````````'''```..`...````''!$@@&&&&&&&$$&@#####$\n;;;;;;;;;'..';;;;::''''''''''':|@@@@&&&&&&$%$&&&&&&&@@%:::::::::::::!|;:::::''''''';!;:;!!;:::::::::::::::::''':%&$$$%|;:::|&%;;:'''```````'''''``...      ```''!&@&&&&&&&&&&&&@###$\n:::;;;;;;;;!;;;'':;;;;:'''''''''':!&@@@&&&&&$$&&&&@@@$;::::::::::::';|:``````````'';!;;;:'''```````````````''''|$$$$%|;::|&$!;;:'````````''::''``....      .``'':%@&&&&&&&&&&&&&&@#$\n::::::::;;;;;;;;;;;;:'':;;:''''''''':;%@@@@&&&&$&@@@$;''''''':''`''`:|;````````````:!!:'''``.........``......`!$%%%%|;;|&$!:;'`````````'''::''.     ..    `''``''!$&&@@&&&&&&&&&&&&%\n###@%!:::::::;;;;;;;;;;;;;;;;::'''''::::|&@@@&&&&&&%'```.....````''`'||'``````````';;'''``................. .!$%%%%|!%&$!:;:'``'''````'::::''.       ....``''``'''|@&&&@&&&@&&&&&&$|\n####@&&&@&|;::::::;;;;;;;;;;;;;;;:'''''''::!&@@@@@%:````......```'```;%;`````````''''``.................   .!$%%%%%$&%;:::''```'''```'::::'`.         ...``'```''';$@&&&@@&&&&&&&&&%\n####@&&&&&&&&&$!:::::::;;;;;;;;;;;;;:''''''':|@@@$;````.......``''```'!%;``````''''``.......      ....    .;%%%%%%$%;::'''`````''''`'::::`.             ...`````'''|@&&&&@@&&&&&&&&%\n####@&&&&&&&&&&&&&&|;::::::;;;;;;;;;;;;:::'':;;%&;````.........``'````:||:```':''`......                .`:|%%%%%|;::''''``````'''''::::`.               ....```'''!$@&&&&@@&&&&&&&%\n####@&&&&&&&&&&&&&&&&&&|::::::::;;;;;;;;;:::::;;'````..........``'`````:||:':''`......                .`'!$%%%%|;:''```````````'''''::;'.                 ......``':%@@&&&&&@&&&&&&%\n####@&&&&&&&&&&&&&&&&&&&&&$!:::::::;;;;;;;;;;;;'`````..........`''``````:||:''`.  .                .``!$&$%%%%%;'''`````````````'':::;;`                   .....```'!&@&&&&&&@&&&&&%\n####@&&&&&&&&&&&&&&&&&&&&&&&&&|;:::::;;;;;;;;;:``````...........''````':':|%!'.                .``'|$&|;|%|%%%!''````...`````````':::;;`                    .....```'|@&&&&&&&@&&&&%\n####@&&&&&&&&&&&&&&&&&&&&&&&&&&&$!::::::;;;;;:``````....``......''``':'''':!|%;..         ..``:|%$|;::;|%||%%!'`````......```''`'':::;:'   .......           ....````:%@&&&&&&@@&&&%\n####@&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&%;:::::;;:```````....`.   ...`'':''`.  .':!||;````````';|%%|;::::';|%||%%;'```.........```'''''::::;'. ....````........  ......````:%@&&&&&&@@&&%\n####@&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&|:::::'```````...``.   ..'::'``.   .```':;!||!;;!||!;::::''``';|%||%|;'```..........```'''''::::;:.....``````````...........`````;&&&&&&&@@@&%\n*/\n\nint n;\nint a[105];\nconst int Mod=1'000'000'007;\n\nint ksmii(int a,int b){\n\tif(!b){\n\t\treturn 1;\n\t}\n\tint ff=ksmii(a,b>>1);\n\tff=1LL*ff*ff%Mod;\n\tif(b&1){\n\t\tff=1LL*ff*a%Mod;\n\t}\n\treturn ff;\n}\n\npair<int,int> solve(int l,int r,int lim){\n\tint minx=Mod,cnt;\n\tfor(int i=l;i<=r;i++){\n\t\tif(a[i]<minx){\n\t\t\tminx=a[i];\n\t\t\tcnt=1;\n\t\t}else if(a[i]==minx){\n\t\t\tcnt++;\n\t\t}\n\t}\n\tif(cnt==r-l+1){\n\t\treturn make_pair((ksmii(2,r-l+1)-2+Mod)%Mod,ksmii(2,minx-lim-1));\n\t}\n\tpair<int,int> ans;\n\tint L=-1,rem=r-l+1;\n\tint x1=1,x2=1;\n\tfor(int i=l;i<=r+1;i++){\n\t\tif(L==-1&&a[i]>minx){\n\t\t\tL=i;\n\t\t}else if(L!=-1&&a[i]<=minx){\n\t\t\trem-=i-L;\n\t\t\tpair<int,int> tmp=solve(L,i-1,minx);\n\t\t\tx1=1LL*x1*(tmp.first+4LL*tmp.second%Mod)%Mod;\n\t\t\tx2=2LL*x2*tmp.second%Mod;\n\t\t\tL=-1;\n\t\t}\n\t}\n\tx1=(x1-x2+Mod)%Mod;\n\tans.first=((1LL*x1*ksmii(2,rem)%Mod)+(1LL*x2*((ksmii(2,rem)-2+Mod)%Mod)%Mod))%Mod;\n\tans.second=1LL*x2*ksmii(2,minx-lim-1)%Mod;\n\treturn ans;\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d\",a+i);\n\t}\n\tint peak=0;\n\tfor(int i=1;i<=n;i++){\n\t\tif(a[i]>a[i-1]&&a[i]>a[i+1]){\n\t\t\tpeak=((long long)peak+a[i]-max(a[i-1],a[i+1])+Mod)%Mod;\n\t\t\ta[i]=max(a[i-1],a[i+1]);\n\t\t}\n\t}\n\tpair<int,int> ans=solve(1,n,0);\n\tprintf(\"%lld\\n\",1LL*ksmii(2,peak)*((ans.first+2LL*ans.second%Mod)%Mod)%Mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nD题：\n给定n列的方块\n第i列高度hi\n现在要把它染成红蓝两色\n要求满足：\n对于任意一个2*2的区域，恰有2个蓝色，2个红色\n问方案数\nn<=100,h<=10^9\n*/\n#include<bits/stdc++.h>\n#define rep(i,a,b) for (int i=(a); i<=(b); i++)\n#define per(i,a,b) for (int i=(a); i>=(b); i--)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> pii;\n\nconst int maxn = 105;\nconst int MOD = 1000000007;\nint bin[maxn], h[maxn], f[maxn][3];\nint n, mx, res, base = 1;\n\ninline int power(int x, int p) {\n\tint res = 1;\n\twhile (p) {\n\t\tif (p & 1) res = 1LL * res * x % MOD;\n\t\tx = 1LL * x * x % MOD; p >>= 1;\n\t}\n\treturn res;\n}\n\npii solve(int l, int r, int base) {\n\t// printf(\"%d %d %d\\n\", l, r, base);\n\tint mn = MOD, cnt = 0;\n\tpii res = make_pair(0, 0), sub;\n\trep (i, l, r)\n\t\tif (h[i] < mn) mn = h[i], cnt = 1;\n\t\telse if (h[i] == mn) cnt++;\n\tif (cnt == r - l + 1) {\n\t\tres.first = (power(2, r - l + 1) + MOD - 2) % MOD;\n\t\tres.second = power(2, mn - base - 1);\n\t\t//printf(\"%d %d %d  %d %d\\n\", l, r, base, res.fi, res.se);\n\t\treturn res;\n\t}\n\tint remain = r - l + 1, last = 0, tmp = 1;\n\tint res0 = 1, res1 = 1;\n\trep (i, l, r + 1)\n\t\tif (!last && h[i] > mn) last = i;\n\t\telse if (last && (i > r || h[i] == mn)) {\n\t\t\tremain -= i - last;\n\t\t\tsub = solve(last, i - 1, mn);\n\t\t\tres0 = 1LL * res0 * (sub.fi + 4LL * sub.se) % MOD;\n\t\t\tres1 = 2LL * res1 * sub.se % MOD;\n\t\t\tlast = 0;\n\t\t}\n\tres0 = (res0 + MOD - res1) % MOD;\n\tres.fi = 1LL * res0 * power(2, remain) % MOD;\n\tres.fi = (res.fi + 1LL * res1 * (power(2, remain) + MOD - 2)) % MOD;\n\tres.se = 1LL * res1 * power(2, mn - base - 1) % MOD;\n\t//printf(\"%d %d %d  %d %d\\n\", l, r, base, res.fi, res.se);\n\treturn res;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\trep (i, 1, n) scanf(\"%d\", &h[i]);\n\tif (n == 1) {\n\t\tprintf(\"%d\\n\", power(2, h[1]));\n\t\treturn 0;\n\t}\n\trep (i, 1, n)\n\t\tif (h[i] > h[i-1] && h[i] > h[i+1]) {\n\t\t\tbase = 1LL * base * power(2, h[i] - max(h[i-1], h[i+1])) % MOD;\n\t\t\th[i] = max(h[i-1], h[i+1]);\n\t\t}\n\tpii tmp = solve(1, n, 0);\n\tres = 1LL * base * (tmp.fi + 2LL * tmp.se) % MOD;\n\tprintf(\"%d\\n\", res);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long double ld;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst long long infll = (long long) 1.01e18;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1);\n\nmt19937 mrand(random_device{} ()); \n\nint rnd(int x) {\n  return mrand() % x;\n}\n\nvoid precalc() {\n}\n\nconst int mod = (int) 1e9 + 7;\n\nint mul(int a, int b) {\n  return (long long) a * b % mod;\n}\n\nvoid add(int &a, int b) {\n  a += b;\n  if (a >= mod) {\n    a -= mod;\n  }\n}\n\nint powMod(int x, int p) {\n  int res = 1;\n  while (p) {\n    if (p & 1) {\n      res = mul(res, x);\n    }\n    p >>= 1;\n    x = mul(x, x);\n  }\n  return res;\n}\n\nconst int maxn = 105;\nint n;\nint a[maxn];\n\nint read() {\n  if (scanf(\"%d\", &n) < 1) {\n    return false;\n  }\n  a[0] = 1;\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &a[i]);\n  }\n  a[n + 1] = 1;\n  n += 2;\n  return true;\n}\n\nint cnt[maxn][maxn];\nint dp[maxn];\n\nvoid solve() {\n  for (int i = 0; i + 1 < n; i++) {\n    cnt[i][i] = 1;\n  }\n  for (int len = 1; len < n - 1; len++) {\n    for (int i = 0; i + len + 1 < n; i++) {\n      int j = i + len;\n      int k = i + 1;\n      for (int l = i + 2; l <= j; l++) {\n        if (a[l] < a[k]) {\n          k = l;\n        }\n      }\n      if (a[k] <= min(a[i], a[i + 1]) || a[k] <= min(a[j], a[j + 1])) {\n        cnt[i][j] = mul(cnt[i][k - 1], cnt[k][j]);\n      } else {\n        cnt[i][j] = mul(powMod(2, a[k] - max(min(a[i], a[i + 1]), min(a[j], a[j + 1]))), mul(cnt[i][k - 1], cnt[k][j]));\n      }\n    }\n  }\n  memset(dp, 0, sizeof(dp));\n  dp[0] = 2;\n  for (int i = 0; i + 1 < n; i++) {\n    auto cur = dp[i];\n    for (int j = i + 1; j + 1 < n; j++) {\n      add(dp[j], mul(cur, cnt[i][j]));\n    }\n  }\n  printf(\"%d\\n\", dp[n - 2]);\n}\n\nint main() {\n  precalc();\n#ifdef DEBUG\n  assert(freopen(TASK \".in\", \"r\", stdin));\n  assert(freopen(TASK \".out\", \"w\", stdout));\n#endif\n  while (read()) {\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N = 105;\nconst int MOD = 1000000007;\n\nint n,m,h[N],w[N];\nLL dp[N][N];\n\nint pow_(int x,int y) {///快速幂求 x的y次方\n    int ans = 1;\n    if(y > 0) {\n        while(y) {\n            if(y % 2)ans = (LL)ans * x % MOD;\n            x = (LL)x * x % MOD;\n            y /= 2;\n        }\n    }\n    return ans;\n}\n\nint main() {\n    scanf(\"%d\",&n);\n    for(int i = 1;i <= n;i ++) {\n        scanf(\"%d\",&h[i]);\n        w[++ m] = h[i];\n    }\n    sort(w + 1,w + m + 1);///高度排序\n    m = unique(w + 1,w + m + 1) - w - 1;///离散化 m是离散化后的长度\n    for(int i = 1;i <= n;i ++) {\n        h[i] = lower_bound(w + 1,w + m + 1,h[i]) - w;\n    }\n    dp[0][0]=1;\n    for(int i = 1;i <= n;i ++) {\n        for(int j = h[i] + 1;j <= h[i - 1];j ++)\n            (dp[i][0] += dp[i - 1][j] * 2 % MOD) %= MOD;\n            \n        (dp[i][0] += dp[i - 1][0] * 2 % MOD) %= MOD;///交叉或者不交叉\n        \n        int d = pow_(2,w[h[i]] - w[h[i-1]]);\n        for(int j = 1;j <= h[i];j ++) {\n            dp[i][j] = dp[i - 1][j] * d % MOD;\n        }\n        \n        for(int j = h[i - 1] + 1;j <= h[i];j ++) {///比前一列高出的部分\n            if(j > 1)(dp[i][j] += dp[i - 1][0] * (pow_(2,w[j] - w[j - 1]) - 1) % MOD * 2 % MOD * pow_(2,w[h[i]] - w[j]) % MOD) %= MOD;\n            else (dp[i][1] += dp[i - 1][0] * (pow_(2,w[1]) - 2) % MOD) %= MOD;///上一列中无重复的乘上化不超过上一列高度中有重复的\n        }\n    }\n    LL ans = 0;\n    for(int i = 0;i <= m;i++)\n        (ans += dp[n][i]) %= MOD;\n    printf(\"%lld\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<map>\n#include<bitset>\n#include<set>\n#define N (110)\n#define P (1000000007)\n#define M ()\n#define inf (0x7f7f7f7f)\n#define rg register int\n#define Label puts(\"NAIVE\")\n#define spa print(' ')\n#define ent print('\\n')\n#define rand() (((rand())<<(15))^(rand()))\n#define file(s) freopen(s\".in\",\"r\",stdin),freopen(s\".out\",\"w\",stdout)\ntypedef long double ld;\ntypedef long long LL;\ntypedef unsigned long long ull;\nusing namespace std;\nnamespace fastIO1{\n\tinline char read(){\n\t\tstatic const int IN_LEN=1000000;\n\t\tstatic char buf[IN_LEN],*s,*t;\n\t\treturn (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);\n\t}\n\ttemplate<class T>\n\tinline void read(T &x){\n\t\tstatic bool iosig;\n\t\tstatic char c;\n\t\tfor(iosig=false,c=read();!isdigit(c);c=read()){\n\t\t\tif(c=='-')iosig=true;\n\t\t\tif(c==-1)return;\n\t\t}\n\t\tfor(x=0;isdigit(c);c=read())x=((x+(x<<2))<<1)+(c^'0');\n\t\tif(iosig)x=-x;\n\t}\n\tinline char readc(char &c){\n\t\tfor(c=read();!isalpha(c)&&!isdigit(c);c=read())\n\t\tif(c==-1)return 0;\n\t}\n\tconst int OUT_LEN = 10000000;\n\tchar obuf[OUT_LEN],*ooh=obuf;\n\tinline void print(char c){\n\t\tif(ooh==obuf+OUT_LEN)fwrite(obuf,1,OUT_LEN,stdout),ooh=obuf;\n\t\t*ooh++=c;\n\t}\n\ttemplate<class T>\n\tinline void print(T x){\n\t\tstatic int buf[30],cnt;\n\t\tif(x==0)print('0');\n\t\telse{\n\t\t\tif(x<0)print('-'),x=-x;\n\t\t\tfor(cnt=0;x;x/=10)buf[++cnt]=x%10+48;\n\t\t\twhile(cnt)print((char)buf[cnt--]);\n\t\t}\n\t}\n\tinline void flush(){fwrite(obuf,1,ooh-obuf,stdout);}\n}\nnamespace fastIO2{\n\ttemplate<class T>\n\tinline void read(T &x){\n\t\tstatic bool iosig;\n\t\tstatic char c;\n\t\tfor(iosig=false,c=getchar();!isdigit(c);c=getchar()){\n\t\t\tif(c=='-')iosig=true;\n\t\t\tif(c==-1)return;\n\t\t}\n\t\tfor(x=0;isdigit(c);c=getchar())x=((x+(x<<2))<<1)+(c^'0');\n\t\tif(iosig)x=-x;\n\t}\n}\nusing namespace fastIO1;\nint n,m,h[N],oth=1;\ntypedef pair<int,int> PII;\nint ksm(int a,int p){\n\tint res=1;\n\twhile(p){\n\t\tif(p&1)res=1ll*res*a%P;\n\t\ta=1ll*a*a%P,p>>=1; \n\t}\n\treturn res;\n}\nPII solve(int L,int R,int lim){\n\t//if(L>R)return;\n\t//cout<<L<<\" \"<<R<<endl;\n\tint mn=inf,cnt=0; PII cur;\n\tfor(int i=L;i<=R;i++)if(h[i]<mn)mn=h[i],cnt=1;else if(h[i]==mn)cnt++;\n\tif(cnt==R-L+1){\n\t\tcur.first=(1ll*ksm(2,R-L+1)+P-2)%P;\n\t\tcur.second=ksm(2,mn-lim-1);\n\t\treturn cur;\n\t}\n\tint l=R-L+1,s0=1,s1=1,lst=0;\n\tfor(int i=L;i<=R+1;i++)\n\tif(!lst&&h[i]>mn)lst=i;\n\telse if(lst&&(h[i]<=mn||i>R)){\n\t\tl-=i-lst;\n\t\tPII ans=solve(lst,i-1,mn);\n\t\ts0=1ll*s0*(ans.first+4ll*ans.second%P)%P;\n\t\ts1=2ll*s1*ans.second%P; lst=0;\n\t}\n\tcur.first=1ll*(s0-s1+P)*ksm(2,l)%P;\n\tcur.first=(cur.first+1ll*s1*(ksm(2,l)+P-2)%P)%P;\n\tcur.second=1ll*s1*ksm(2,mn-lim-1)%P;\n\treturn cur;\n}\nint main(){\n\tread(n);\n\tfor(int i=1;i<=n;i++)read(h[i]);\n\tif(n==1)printf(\"%d\\n\",ksm(2,h[1])),exit(0);\n\tfor(int i=1;i<=n;i++)\n\tif(h[i]>h[i+1]&&h[i]>h[i-1]){\n\t\toth=1ll*oth*ksm(2,h[i]-max(h[i+1],h[i-1]))%P;\n\t\th[i]=max(h[i-1],h[i+1]);\n\t}\n\tPII ans=solve(1,n,0);\n\tprintf(\"%lld\\n\",1ll*oth*(0ll+ans.first+ans.second+ans.second)%P);\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <bits/stdc++.h>\n\n#define FOR(i, n)     for(lli i = 0; i < (lli)(n); ++i)\n#define FORU(i, j, k) for(lli i = (j); i <= (lli)(k); ++i)\n#define FORD(i, j, k) for(lli i = (j); i >= (lli)(k); --i)\n\n#define SQ(x) ((x)*(x))\n\n#define all(x) begin(x), end(x)\n#define rall(x) rbegin(x), rend(x)\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\n\ntemplate<typename... As>\nstruct tpl : public std::tuple<As...> {\n  using std::tuple<As...>::tuple;\n  tpl(){}\n  tpl(std::tuple<As...> const& b) { std::tuple<As...>::operator=(b); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type const&\n  x() const { return get<0>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type&\n  x() { return get<0>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type const&\n  y() const { return get<1>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type&\n  y() { return get<1>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type const&\n  z() const { return get<2>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type&\n  z() { return get<2>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type const&\n  w() const { return get<3>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type&\n  w() { return get<3>(*this); }\n};\n\nusing lli   = long long int;\nusing llu   = long long unsigned;\n\nusing pii   = tpl<lli, lli>;\nusing piii  = tpl<lli, lli, lli>;\nusing piiii = tpl<lli, lli, lli, lli>;\nusing vi    = vector<lli>;\nusing vii   = vector<pii>;\nusing viii  = vector<piii>;\nusing vvi   = vector<vi>;\nusing vvii  = vector<vii>;\nusing vviii = vector<viii>;\n\ntemplate<class T>\nusing min_queue = priority_queue<T, vector<T>, greater<T> >;\ntemplate<class T>\nusing max_queue = priority_queue<T>;\n\ntemplate<size_t... I>\nstruct my_index_sequence {\n  using type = my_index_sequence;\n  static constexpr array<size_t, sizeof...(I)> value = { {I...} };\n};\n\nnamespace my_index_sequence_detail {\n  template<typename I, typename J> struct concat;\n  template<size_t... I, size_t... J>\n  struct concat<my_index_sequence<I...>, my_index_sequence<J...> > :\n    my_index_sequence<I..., (sizeof...(I)+J)...> { };\n  template<size_t N> struct make_index_sequence :\n    concat<typename make_index_sequence<N/2>::type, typename make_index_sequence<N-N/2>::type>::type { };\n  template <> struct make_index_sequence<0> : my_index_sequence<>{};\n  template <> struct make_index_sequence<1> : my_index_sequence<0>{};\n}\n\ntemplate<class... A>\nusing my_index_sequence_for = typename my_index_sequence_detail::make_index_sequence<sizeof...(A)>::type;\n\ntemplate<class T, size_t... I>\nvoid print_tuple(ostream& s, T const& a, my_index_sequence<I...>){\n  using swallow = int[];\n  (void)swallow{0, (void(s << (I == 0? \"\" : \", \") << get<I>(a)), 0)...};\n}\n\ntemplate<class T>\nostream& print_collection(ostream& s, T const& a);\ntemplate<class... A>\nostream& operator<<(ostream& s, tpl<A...> const& a);\ntemplate<class... A>\nostream& operator<<(ostream& s, tuple<A...> const& a);\ntemplate<class A, class B>\nostream& operator<<(ostream& s, pair<A, B> const& a);\n\ntemplate<class T, size_t I>\nostream& operator<<(ostream& s, array<T, I> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, vector<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, multimap<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, multiset<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, map<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, set<T> const& a) { return print_collection(s, a); }\n\ntemplate<class T>\nostream& print_collection(ostream& s, T const& a){\n  s << '[';\n  for(auto it = begin(a); it != end(a); ++it){\n    s << *it;\n    if(it != prev(end(a))) s << \" \";\n  }\n  return s << ']';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tpl<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tuple<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class A, class B>\nostream& operator<<(ostream& s, pair<A, B> const& a){\n  return s << \"(\" << get<0>(a) << \", \" << get<1>(a) << \")\";\n}\n\n//------------------------------------------------------------------------------\n\n// --- BEGIN SNIPPET MODULAR ---\n\nconst lli MOD = 1e9+7;\n\ninline lli fexp(lli a, lli b, lli m=MOD) {\n  lli r = 1;\n  while(b){\n    if(b&1) r = (r*a)%m;\n    a = (a*a)%m;\n    b /= 2;\n  }\n  return r;\n}\n\ninline lli invmod(lli a, lli m=MOD) {\n  return fexp(a, m-2, m);\n}\n\nlli nmod(lli x) { return (x%MOD+MOD)%MOD; }\n\nstruct Zn {\n  lli x;\n  Zn(lli x_) : x(x_) {\n    x %= MOD;\n    if(x<0) x = (x+MOD)%MOD;\n  }\n\n  Zn operator+(Zn const& o) const { return Zn(x+o.x); }\n  Zn operator-(Zn const& o) const { return Zn(x-o.x); }\n  Zn operator*(Zn const& o) const { return Zn(x*o.x); }\n\n  Zn& operator+=(Zn const& o) { return *this = *this+o; }\n  Zn& operator-=(Zn const& o) { return *this = *this-o; }\n  Zn& operator*=(Zn const& o) { return *this = *this*o; }\n};\n\npii egcd(lli a, lli b) {\n  if(a%b==0) {\n    return mt(0,1);\n  }else{\n    pii p = egcd(b,a%b);\n    int u=p.x(), v=p.y();\n    return mt(v, u-(a/b)*v);\n  }\n}\n\n// solve x*a = b [mod m]\nint solveInv(lli a, lli b, lli m) {\n  if(b==0) return 0;\n  pii p = egcd(a,m);\n  lli g=__gcd(m,a);\n  return (((b/g)*p.x())%m+m)%m;\n}\n\n// --- END SNIPPET MODULAR ---\n\nconst int N = 200;\nlli H[N];\n// lli dp[N+1][N+1];\n\nint main(){\n  ios::sync_with_stdio(0); cin.tie(0);\n  lli n; cin>>n;\n  FOR(i,n) cin>>H[i];\n  function<pii(lli,lli,lli)> f = [&](lli from, lli i, lli j) -> pii { // (val with only hor, full val)\n    if(i>j) return pii(1,1);\n    lli a = i;\n    FORU(b,i,j) if(H[b]<H[a]) a = b;\n    lli x1,y1,x2,y2;\n    tie(x1,y1) = f(H[a],i,a-1);\n    tie(x2,y2) = f(H[a],a+1,j);\n\n    lli x30 = (fexp(2, H[a]-from)) * x1 % MOD * x2 % MOD;\n    lli x3 = (fexp(2, H[a]-from) - 1 + MOD) * x1 % MOD * x2 % MOD;\n    lli y3 = ((a!=i?2:1)*(a!=j?2:1)%MOD*y1%MOD*y2%MOD + x3) % MOD;\n    return mt(x30,y3);\n  };\n  lli x,y; tie(x,y) = f(1,0,n-1);\n  cout << (2*y)%MOD << endl;\n  // set<lli> allH(H,H+n);\n  // allH.insert(0);\n  // vi HS(all(allH));\n  // int m = HS.size();\n  // HS.eb((lli)1e10);\n  // memset(dp,0,sizeof(dp));\n  // dp[0][m] = 1;\n  // lli last = 0;\n  // FOR(i,n) {\n  //   lli h = H[i];\n  //   FOR(j,m+1) if(dp[i][j]) {\n  //     cerr << mt(i,j) << \" \" << dp[i][j] << \" \" << HS[j] << \" \" << h << endl;\n  //     if(HS[j] <= h) {\n  //       (dp[i+1][j] += fexp(2, max(0ll,h-max(1ll,last))) * dp[i+1][j] % MOD) %= MOD;\n  //     }else{\n  //       (dp[i+1][m] += (last==0?1:2)*dp[i][j]) %= MOD;\n  //       FOR(k,m) if(HS[k] > max(1ll,last) && HS[k] <= h) {\n  //         (dp[i+1][k] += (last==0?1:2)*dp[i][j]%MOD*(fexp(2,HS[k]-(k==1?1:HS[k-1]))-1+MOD)%MOD*fexp(2,h-HS[k])%MOD) %= MOD;\n  //       }\n  //     }\n  //   }\n  //   last = h;\n\n  //   FOR(j,m+1) cerr << dp[i+1][j] << \" \";\n  //   cerr << endl;\n  // }\n  // lli ans = 0;\n  // FOR(i,m+1) (ans += dp[n][i]) %= MOD;\n  // cout << (2*ans)%MOD << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\n\nconst ll mod = 1e9 + 7;\n\nll A[111];\nll n;\n\nll lpow(ll a, ll b)\n{\n\tif(b == 0) return 1;\n\tll rt = lpow(a, b>>1);\n\trt = rt * rt % mod;\n\tif(b & 1) rt = rt * a % mod;\n\treturn rt;\n}\n\npll run(ll l, ll r, ll h)\n{\t\n\tif(l == r){\n\t\treturn pll(lpow(2, A[l] - h), lpow(2, A[l] - h - 1));\n\t}\n\t\n\tll i, a, b, s, m, f;\n\tpll p;\n\t\n\ta = b = f = 1;\n\tm = 2e9;\n\t\n\tfor(i=l;i<=r;i++){\n\t\tm = min(m, A[i]);\n\t}\n\t\n\tfor(i=s=l;i<=r;i++){\n\t\tif(A[i] == m){\n\t\t\tif(s <= i-1){\n\t\t\t\tp = run(s, i-1, m);\n\t\t\t\ta = a * (p.first + p.second * 2) % mod;\n\t\t\t\tb = b * p.second % mod;\n\t\t\t}\n\t\t\ta = a * 2 % mod;\n\t\t\ts = i + 1;\n\t\t}\n\t\telse f = 2;\n\t}\n\tif(s <= r){\n\t\tp = run(s, r, m);\n\t\ta = a * (p.first + p.second * 2) % mod;\n\t\tb = b * p.second % mod;\n\t}\n\tb = b * f % mod;\n\t\n\ta = (a - b * 2 + b * lpow(2, m - h) + mod + mod) % mod;\n\tb = b * lpow(2, m - h - 1) % mod;\n\t\n\treturn pll(a, b);\n}\n\nint main()\n{\n\tll i;\n\tpll p;\n\t\n\tscanf(\"%lld\", &n);\n\t\n\tfor(i=1;i<=n;i++){\n\t\tscanf(\"%lld\", A+i);\n\t}\n\t\n\tp = run(1, n, 0);\n\t\n\tprintf(\"%lld\\n\", p.first);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#define mod 1000000007\n#define maxn 1003\nusing namespace std;\nint h[maxn], a[maxn], b[maxn], _h[maxn], _a[maxn], f[maxn][maxn];\nint fpw(int x, int y){\n\tif (y < 0)\n\t\treturn 1;\n\tint ans = 1;\n\tfor (int i = 1; i <= y; i <<= 1, x = 1LL * x * x % mod)\n\t\tif (y & i)\n\t\t\tans = 1LL * ans * x % mod;\n\treturn ans;\n}\nint main(){\n\tint n;\n\tcin >> n;\n\tfor (int i = 1; i <= n; ++ i){\n\t\tcin >> h[i];\n\t\ta[i] = h[i];\n\t}\n\tsort(a + 1, a + 1 + n);\n\tint _n = 0;\n\tfor (int i = 1; i <= n; ++ i)\n\t\tif (a[i] != a[i - 1])\n\t\t\t_a[++ _n] = a[i];\n\tfor (int i = 1; i <= n; ++ i)\n\t\t_h[i] = lower_bound(_a + 1, _a + 1 + _n, h[i]) - _a;\n\tf[0][0] = 1;\n\tfor (int i = 1; i <= n; ++ i){\n\t\tf[i][0] = f[i - 1][0] * 2 % mod;\n\t\tfor (int j = _h[i] + 1; j <= _h[i - 1]; ++ j)\n\t\t\tf[i][0] = (f[i][0] + f[i - 1][j] * 2 % mod) % mod;\n\t\tint x = fpw(2, h[i] - h[i - 1]);\n\t\tfor (int j = 1; j <= min(_h[i], _h[i - 1]); ++ j)\n\t\t\tf[i][j] = 1LL * f[i - 1][j] * x % mod;\n\t\tfor (int j = _h[i - 1] + 1; j <= _h[i]; ++ j){\n\t\t\tif (j > 1)\n\t\t\t\tf[i][j] = 1LL * f[i - 1][0] * (fpw(2, _a[j] - _a[j - 1]) - 1) % mod * 2 % mod * fpw(2, h[i] - _a[j]) % mod;\n\t\t\telse\n\t\t\t\tf[1][1] = 1LL * f[0][0] * (fpw(2, _a[1]) - 2) % mod * fpw(2, h[i] - _a[1]) % mod;\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i <= _h[n]; ++ i)\n\t\tans = (ans + f[n][i]) % mod;\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct state {\n\tint h;\n\tint w;\n\tlong long ans1 = 2;\n\tlong long ans2 = 0;\n\t\n\tstate() {}\n\tstate(int h, int w) : h(h), w(w) {}\n};\n\nint m = 1000000007;\nint h[100];\n\nlong long powmod(long long x, long long y) {\n\tlong long ans = 1;\n\t\n\twhile (y > 0) {\n\t\tif (y & 1) ans = ans * x % m;\n\t\tx = x * x % m;\n\t\ty >>= 1;\n\t}\n\t\n\treturn ans;\n}\n\nlong long mod_inverse(long long a, long long m) {\n    long long b = m, x = 1, y = 0;\n    \n    while (b) {\n        long long t = a / b;\n        \n        a -= t * b;\n        x -= t * y;\n        \n        swap(a, b);\n        swap(x, y);\n    }\n    \n    return (m + x % m) % m;\n}\n\nlong long solve(int l, int r) {\n\tint i, j;\n\tlong long ans = 1;\n\tvector <state> v;\n\t\n\tif (l == r) return 1;\n\t\n\tv.push_back(state(0, 1));\n\t\n\tfor (i = l; i < r; i++) {\n\t\tv.push_back(state(h[i], 1));\n\t}\n\t\n\tv.push_back(state(0, 1));\n\t\n\twhile (v.size() > 3) {\n\t\tint x = 0;\n\t\t\n\t\tfor (i = 0; i < v.size(); i++) {\n\t\t\tif (v[i].h > v[x].h) x = i;\n\t\t}\n\t\t\n\t\tif (v[x].h == v[x + 1].h) {\n\t\t\tlong long tmp1, tmp2;\n\t\t\t\n\t\t\ttmp1 = v[x].ans1 * v[x + 1].ans1 % m * mod_inverse(2, m) % m;\n\t\t\ttmp2 = ((v[x].ans1 + v[x].ans2) * (v[x + 1].ans1 + v[x + 1].ans2) - tmp1 + m) % m;\n\t\t\t\n\t\t\tv[x].ans1 = tmp1;\n\t\t\tv[x].ans2 = tmp2;\n\t\t\tv[x].w += v[x + 1].w;\n\t\t\tv.erase(v.begin() + x + 1);\n\t\t} else {\n\t\t\tint h = v[x].h - max(v[x - 1].h, v[x + 1].h);\n\t\t\t\n\t\t\tif (v[x].w == 1) {\n\t\t\t\tans = ans * powmod(2, h) % m;\n\t\t\t} else {\n\t\t\t\tv[x].ans1 = v[x].ans1 * powmod(2, h) % m;\n\t\t\t}\n\t\t\t\n\t\t\tv[x].h -= h;\n\t\t}\n\t}\n\t\n\treturn ans * (v[1].ans1 * powmod(2, v[1].h - 1) % m + v[1].ans2) % m;\n}\n\nint main() {\n\tint n, x = 0, i;\n\tlong long ans = 1;\n\t\n\tscanf(\"%d\", &n);\n\t\n\tfor (i = 0; i < n; i++) scanf(\"%d\", &h[i]);\n\t\n\tfor (i = 0; i < n; i++) {\n\t\tif (h[i] == 1) {\n\t\t\tans = ans * solve(x, i) * 2 % m;\n\t\t\tx = i + 1;\n\t\t}\n\t}\n\t\n\tans = ans * solve(x, n) % m;\n\t\n\tprintf(\"%lld\\n\", ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#define SF scanf\n#define PF printf\n#define MAXN 100010\n#define MOD 1000000007\nusing namespace std;\nint n,h[MAXN];\ntypedef long long ll;\nll dp[MAXN];\nll fsp(ll x,int y){\n\tll res=1;\n\twhile(y){\n\t\tif(y&1)\n\t\t\tres=res*x%MOD;\n\t\tx=x*x%MOD;\n\t\ty>>=1;\n\t}\n\treturn res;\n}\nint main(){\n\tSF(\"%d\",&n);\n\tdp[n+1]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tSF(\"%d\",&h[i]);\n\t\tif(h[i]==1){\n\t\t\th[i]--;\n\t\t\tdp[n+1]=dp[n+1]*2ll%MOD;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tif(h[i]>h[i-1]&&h[i]>h[i+1]){\n\t\t\tint h1=max(h[i-1],h[i+1]);\n\t\t\tdp[n+1]=dp[n+1]*fsp(2,h[i]-h1)%MOD;\n\t\t\th[i]=h1;\t\n\t\t}\n\tfor(int i=n;i>0;i--){\n\t\tif(h[i])\n\t\t\tdp[i]=dp[i+1]*2ll%MOD;\n\t\telse{\n\t\t\tdp[i]=dp[i+1];\n\t\t\tcontinue;\n\t\t}\n\t\tint minh=h[i],q=i;\n\t\tfor(int j=i;h[j]==h[i];j++)\n\t\t\tif(h[j+1]>h[i]){\n\t\t\t\tq=j;\n\t\t\t\tminh++;\n\t\t\t}\n\t\tll res1=0;\n\t\tint end,sumh=0;\n\t\tif(h[i]<h[i-1])\n\t\t\tend=h[i];\n\t\telse\n\t\t\tend=h[i-1]+1;\n\t\t//PF(\"{%d %d}\\n\",minh,end);\n\t\tfor(int j=q+1;minh>end;j++){\n\t\t\tif(h[j]>h[j-1])\n\t\t\t\tsumh+=h[j]-h[j-1];\n\t\t\tif(h[j]<minh){\n\t\t\t\tint minh1=max(end,h[j]);\n\t\t\t\t//PF(\"{%d %d %d}\\n\",sumh+h[i]-minh,minh-minh1,-(minh==(h[i]+1)?0:1));\n\t\t\t\tif(minh==h[i]+1)\n\t\t\t\t\tres1+=dp[j]*(fsp(2,sumh+h[i]-minh+q-i+2)+fsp(2,sumh+h[i]-minh+2)*(fsp(2,minh-minh1-1)-1)%MOD)%MOD;\n\t\t\t\telse\n\t\t\t\t\tres1+=dp[j]*(fsp(2,sumh+h[i]-minh+1)*(fsp(2,minh-minh1)-1)%MOD)%MOD;\n\t\t\t\tres1%=MOD;\n\t\t\t\tminh=minh1;\n\t\t\t}\n\t\t}\n\t\tdp[i]+=res1;\n\t\tdp[i]%=MOD;\n\t\t//PF(\"{%lld}\\n\",dp[i]);\n\t}\n\tPF(\"%lld\",dp[1]);\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define EB emplace_back\n\ntypedef long long ll;\ntypedef std::pair <int, int> pr;\ntypedef std::vector <int> vector;\nconst int mod = 1000000007, pmod = mod - 1;\n\ninline void add(int &x, const int y) {x += y - mod, x += x >> 31 & mod;}\ninline void sub(int &x, const int y) {x -= y, x += x >> 31 & mod;}\nll PowerMod(ll a, int n, ll c = 1) {for (n += n >> 31 & pmod; n; n >>= 1, a = a * a % mod) if (n & 1) c = c * a % mod; return c;}\n\npr solve(const vector &h) {\n\tint i, j = -1, n = h.size(), x, y = 0, P1 = 1, P2 = 1, C1, C2, W = n, best;\n\tvector S; x = *std::min_element(h.begin(), h.end());\n\tfor (i = 0; i <= n; ++i)\n\t\tif (i == n || h[i] == x) {\n\t\t\tif (j + 1 == i) ++j;\n\t\t\telse if (j + 2 == i) ++j, P1 = PowerMod(2, h[j] - x, P1), P2 = PowerMod(2, h[j] - x, P2), ++j;\n\t\t\telse {\n\t\t\t\tW -= i - j - 1, S.clear(), S.reserve(i - j - 1);\n\t\t\t\tfor (++y; ++j < i; S.EB(h[j] - x));\n\t\t\t\tstd::tie(C1, C2) = solve(S), P1 = (ll)P1 * (C1 + C2) % mod, P2 = (ll)P2 * C2 % mod;\n\t\t\t}\n\t\t}\n\tif (y)\n\t\tbest = PowerMod(2, 1 - y, P2), C2 = PowerMod(2, x, best),\n\t\tC1 = PowerMod(2, W, P1), sub(C1, best), sub(C1, best);\n\telse\n\t\tC2 = PowerMod(2, x, P2), sub(C1 = PowerMod(2, n, P2), P2), sub(C1, P2);\n\treturn add(C1, C2), pr(C1, C2);\n}\n\nint main() {\n\tint i, n, x; vector h;\n\tscanf(\"%d\", &n), h.reserve(n);\n\tfor (i = 0; i < n; ++i) scanf(\"%d\", &x), h.EB(x);\n\tprintf(\"%d\\n\", solve(h).first);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n//#include <deque>\n#include <valarray>\n#include <array>\n#include <unordered_map>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include <fstream>\n\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n\n// output\n#define OUT(d) std::cout<<(d);\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<(d);\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<(d);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(i, n) std::cout<<(i + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << (d) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=int(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n// test\ntemplate<class T> std::vector<std::vector<T>> VV(int n, int m, T init = T()) {\n\treturn std::vector<std::vector<T>>(n, std::vector<T>(m, init));\n}\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-9;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n\n// ------------>8------------------------------------->8------------\n\nll powMod(ll n, ll p, ll mod) {\n\tll res = 1;\n\twhile (p) {\n\t\tif (p & 1) (res *= n) %= mod;\n\t\t(n *= n) %= mod;\n\t\tp >>= 1;\n\t}\n\treturn res;\n}\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, n);\n\tVEC(int, h, n);\n\n\t// (任意通り, 下の段をRBRB...で塗る通り)\n\tstd::function<PAIR(int, int, int)> dfs = [&](int L, int R, int hh) {\n\t\tPAIR res;\n\n\t\tif (R - L == 1) {\n\t\t\tres.second = powMod(2, h[L] - hh - 1, MOD);\n\t\t\tres.first = 2 * res.second;\n\t\t}\n\t\telse {\n\t\t\tint mi = INFINT;\n\t\t\tFOR(i, L, R) {\n\t\t\t\tif (h[i] - hh > 0) {\n\t\t\t\t\tif (mi > h[i] - hh) {\n\t\t\t\t\t\tCHMIN(mi, h[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (mi == INFINT) {\n\t\t\t\tres.first = 1;\n\t\t\t\tres.second = 1;\n\t\t\t}\n\t\t\telse if (mi > hh + 1) {\n\t\t\t\tauto p = dfs(L, R, mi - 1);\n\t\t\t\tres.second = powMod(2, mi - hh - 1, MOD) * p.second % MOD;\n\t\t\t\tres.first = p.first - 2 * p.second + 2 * res.second;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstd::vector<PAIR> ch;\n\n\t\t\t\tint l = -1;\n\t\t\t\tint rest = R - L;\n\t\t\t\tFOR(r, L, R + 1) {\n\t\t\t\t\tif (r == R || h[r] - mi <= 0) {\n\t\t\t\t\t\tif (l != -1) {\n\t\t\t\t\t\t\tch.emplace_back(dfs(l, r, hh));\n\t\t\t\t\t\t\trest -= r - l;\n\t\t\t\t\t\t\tl = -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (l == -1) l = r;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tres.first = powMod(2, rest, MOD);\n\t\t\t\tREP(i, ch.size()) {\n\t\t\t\t\t(res.first *= ch[i].first) %= MOD;\n\t\t\t\t}\n\n\t\t\t\tres.second = 1;\n\t\t\t\tREP(i, ch.size()) {\n\t\t\t\t\t(res.second *= ch[i].second) %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tres.first %= MOD;\n\t\tres.second %= MOD;\n\t\tif (res.first < 0) res.first += MOD;\n\t\tif (res.second < 0) res.second += MOD;\n\t\treturn res;\n\t};\n\tOUT(dfs(0, n, 0).first)BR;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\n\ntemplate<unsigned P> struct ModInt {\n  using M = ModInt;\n  unsigned v;\n  ModInt() : v(0) {}\n  template<class Int> ModInt(Int x) : v(x >= 0 ? x % P : -x % P ? P - -x % P : 0) {}\n  constexpr ModInt(unsigned v, int) : v(v) {}\n  static constexpr unsigned p() { return P; }\n  M operator+() const { return *this; }\n  M operator-() const { return {v ? P - v : 0, 0}; }\n  explicit operator bool() const noexcept { return v; }\n  bool operator!() const noexcept { return !(bool) *this; }\n  M operator*(M rhs) const { return M(*this) *= rhs; }\n  M operator/(M rhs) const { return M(*this) /= rhs; }\n  M operator+(M rhs) const { return M(*this) += rhs; }\n  M operator-(M rhs) const { return M(*this) -= rhs; }\n  bool operator==(M rhs) const { return v == rhs.v; }\n  bool operator!=(M rhs) const { return !(*this == rhs); }\n  M& operator*=(M rhs) { v = (unsigned long long) v * rhs.v % P; return *this; }\n  M& operator/=(M rhs) { return *this *= rhs.inv(); }\n  M& operator+=(M rhs) { v = rhs.v < P - v ? v + rhs.v : v - (P - rhs.v); return *this; }\n  M& operator-=(M rhs) { v = rhs.v <= v ? v - rhs.v : v + (P - rhs.v); return *this; }\n  M inv() const {\n    int a = v, b = P, x = 1, u = 0;\n    while (b) {\n      int q = a / b;\n      swap(a -= q * b, b);\n      swap(x -= q * u, u);\n    }\n    assert(a == 1);\n    return x;\n  }\n  template<class Int> M pow(Int n) const {\n    n = n >= 0 ? n % (P - 1) : P - 1 - -n % (P - 1);\n    M res = 1;\n    for (M a = *this; n; a *= a, n >>= 1) if (n & 1) res *= a;\n    return res;\n  }\n  template<class Int> friend M operator*(Int lhs, M rhs) { return M(lhs) *= rhs; }\n  template<class Int> friend M operator/(Int lhs, M rhs) { return M(lhs) /= rhs; }\n  template<class Int> friend M operator+(Int lhs, M rhs) { return M(lhs) += rhs; }\n  template<class Int> friend M operator-(Int lhs, M rhs) { return M(lhs) -= rhs; }\n  friend ostream& operator<<(ostream& os, M rhs) { return os << rhs.v; }\n  friend istream& operator>>(istream& is, M& rhs) { lint x; is >> x; rhs = x; return is; }\n  template<class Int> friend bool operator==(Int lhs, M rhs) { return M(lhs) == rhs; }\n  template<class Int> friend bool operator!=(Int lhs, M rhs) { return !(lhs == rhs); }\n};\nusing Mint = ModInt<(unsigned) 1e9 + 7>;\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int n; cin >> n;\n  V<> h(n + 1, 1), hs;\n  for (int i = 0; i <= n; ++i) {\n    if (i) cin >> h[i];\n    hs.push_back(h[i]);\n    hs.push_back(h[i] + 1);\n  }\n  sort(begin(hs), end(hs));\n  hs.erase(unique(begin(hs), end(hs)), end(hs));\n  auto h2j = [&](int h) -> int {\n    return lower_bound(begin(hs), end(hs), h) - begin(hs);\n  };\n  int m = hs.size();\n  V<Mint> dp(m - 1);\n  dp[0] = 1;\n  for (int i = 0; i < n; ++i) {\n    V<Mint> ndp(m - 1);\n    if (h[i] <= h[i + 1]) {\n      for (int j = 0; hs[j] < h[i]; ++j) {\n        ndp[j] += Mint(2).pow(h[i + 1] - h[i]) * dp[j];\n      }\n      for (int j = h2j(h[i]); hs[j] < h[i + 1]; ++j) {\n        ndp[j] += (Mint(2).pow(h[i + 1] - hs[j] + 1) - Mint(2).pow(h[i + 1] - hs[j + 1] + 1)) * dp[h2j(h[i])];\n      }\n      ndp[h2j(h[i + 1])] += 2 * dp[h2j(h[i])];\n    } else {\n      for (int j = 0; hs[j] < h[i + 1]; ++j) {\n        ndp[j] += dp[j];\n      }\n      for (int j = h2j(h[i + 1]); hs[j] <= h[i]; ++j) {\n        ndp[h2j(h[i + 1])] += 2 * dp[j];\n      }\n    }\n    swap(dp, ndp);\n  }\n  cout << accumulate(begin(dp), end(dp), Mint(0)) << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "\t#include <iostream>\n    #include <string>\n    #include <set>  \n    #include <stack>\n    #include <algorithm>\n    #include <vector>\n    #include <cmath>\n    #include <queue>\n    #include <deque>\n    #include <cstring>\n    #include <cstdio>\n    #include <map>\n    #include <numeric>\n    #include <cassert>\n    #include <iomanip>\n    #include <sstream>\n    #include <ctime>\n    #include <bitset> \nusing namespace std;\n#define for1(i,a,b) for(int i=(a);i<(int)(b);++i)\n#define rep(i,maxn) for1(i,0,maxn)\n#define ford(i,b,a) for(int i=(int)(b)-1;i>=a;--i)\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<int,pii > piii;\n#define inf 0x3f3f3f3f\n#define mod 1000000007\n#define st first\n#define nd second\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define dprintf(...) printf(__VA_ARGS__)\nconst int maxn=110;\nll h[maxn];\nll ncnt;\nint n;\nvector<pii> dive;\nll qp(ll base,ll ind)\n{\n\tll ans=1;\n\twhile(ind>0)\n\t{\n\t\tif(ind&1)ans=ans*base%mod;\n\t\tind>>=1;\n\t\tbase=base*base%mod;\n\t}\n\treturn ans%mod;\n}\nll f[maxn],g[maxn];\nll cal(int bg,int ed)\n{\n\tf[bg]=qp(2,h[bg]-1);\n\tg[bg]=1;\n\tfor1(i,bg,ed)\n\t{\n\t//\tcout<<i<<\" \"<<f[i]<<\" \"<<g[i]<<endl;\n\t//\tsystem(\"pause\");\n\t\tif(h[i+1]>=h[i])\n\t\t{\n\t\t\tll buf=qp(2,h[i+1]-h[i]);\n\t\t\tf[i+1]=(f[i]+g[i])%mod*buf%mod;\n\t\t\tg[i+1]=g[i]*2%mod;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tll buf=qp(2,h[i]-h[i+1])-1;\n\t\t//\tcout<<buf<<endl;\n\t\t\tll res=0;\n\t\t\tf[i+1]=(f[i]+g[i])%mod;\n\t\t\tint cur=i;ll mx=h[i];\n\t\t\twhile(buf>0&&cur>bg)\n\t\t\t{\n\t\t\t\tcur--;\n\t\t\t\tif(h[cur]>=mx)continue;\n\t\t\t\tll ok=qp(2,h[i]-h[cur])-qp(2,h[i]-mx);\n\t\t\t\tif(h[cur]<=h[i+1])ok=qp(2,h[i]-h[i+1])-qp(2,h[i]-mx);\n\t\t\t\tres+=g[cur]*2*ok%mod;\n\t\t\t\tbuf-=ok;\n\t\t\t//\tcout<<ok<<\" \"<<buf<<endl;\n\t\t\t//\tsystem(\"pause\");\n\t\t\t\tmx=h[cur];\n\t\t\t}\n\t\t\tif(buf<0)cout<<\"Error\"<<endl;\n\t\t\telse res+=buf;\n\t\t\tf[i+1]+=res;\n\t\t\tf[i+1]%=mod;\n\t\t\tg[i+1]=(res+g[i])*2%mod;\n\t\t//\tcout<<res<<\" \"<<buf<<\" \"<<f[i+1]<<\" \"<<g[i+1]<<endl;\n\t\t}\n\t}\n\treturn f[ed]%mod;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\trep(i,n)scanf(\"%lld\",h+i);\n\tint stp=0,edp=-1;\n\trep(i,n)\n\t{\n\t\tll pre=(i?h[i-1]:1);\n\t\tll nxt=(i==n-1?1:h[i+1]);\n\t\tll cur;\n\t\tcur=min(h[i],pre);\n\t\tcur=max(cur,min(h[i],nxt));\n\t\tncnt+=h[i]-cur;\n\t\th[i]=cur;\n\t//\tcout<<i<<\" \"<<cur<<\" \"<<pre<<\" \"<<nxt<<\" \"<<h[i]<<endl;\n\t\tif(h[i]==1)\n\t\t{\n\t//\t\tcout<<i<<endl;\n\t\t\tif(stp<edp)\n\t\t\t\tdive.pb(mp(stp,edp));\n\t\t\tstp=i+1,edp=i;\n\t\t\tncnt++;\n\t\t}\n\t\telse edp++;\n\t}\n\tif(stp<edp)dive.pb(mp(stp,edp));\n\tll ans=1;\n\tans%=mod;\n\trep(i,dive.size())\n\t{\n\t\tans*=2*cal(dive[i].st,dive[i].nd);\n\t\tans%=mod;\n\t}\n//\tcout<<ans<<endl;\n//\tcout<<ans<<endl;\n\tif(!dive.size())ans=1;\n\tif(ncnt)ans*=qp(2,ncnt);\n\tans%=mod;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 1000000007;\n\nlong long modPow(long long a, long long p){\n\tif(p == 0) return 1;\n\tlong long res = modPow(a, p/2);\n\tres = (res * res) % MOD;\n\tif(p%2 == 1) res = (res * a) % MOD;\n\treturn res;\n}\n\npair<long long, long long> solve(const vector<int>& h){\n\tif(h.empty()) return make_pair(1, 1);\n\tint minH = h[0];\n\tfor(auto& t : h) minH = min(t, minH);\n\tif(minH > 1){\n\t\tvector<int> nh = h;\n\t\tfor(auto& t : nh) t -= minH - 1;\n\t\tauto res = solve(nh);\n\t\tlong long p2 = modPow(2, minH - 1);\n\t\tres.first = (res.first + (2 * p2 + MOD - 2) % MOD * res.second) % MOD;\n\t\tres.second = (res.second * p2) % MOD;\n\t\treturn res;\n\t} else {\n\t\tfor(int i=0;i<h.size();i++){\n\t\t\tif(h[i] == 1){\n\t\t\t\tvector<int> h1, h2;\n\t\t\t\tfor(int j=0;j<i;j++) h1.push_back(h[j]);\n\t\t\t\tfor(int j=i+1;j<h.size();j++) h2.push_back(h[j]);\n\t\t\t\tauto res1 = solve(h1);\n\t\t\t\tauto res2 = solve(h2);\n\t\t\t\tpair<long long, long long> res;\n\t\t\t\tres.first = 2 * res1.first * res2.first % MOD;\n\t\t\t\tres.second = res1.second * res2.second % MOD;\n\t\t\t\treturn res;\n\t\t\t}\n\t\t}\n\t}\n\treturn make_pair(0, 0);\n}\n\nint main(){\n\tint N;\n\twhile(cin >> N){\n\t\tvector<int> h(N);\n\t\tfor(auto& t : h) cin >> t;\n\t\tcout << solve(h).first << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <vector>\n#include <cassert>\n#include <fstream>\n#include <algorithm>\n#include <list>\n#include <random>\n#include <ctime>\n#include <cmath>\n#include <random>\n#include <bitset>\n#include <complex>\n#pragma unroll\n#pragma loop count N\n#pragma ivdep\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n#define int ll\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef pair<ld, ld> pld;\ntypedef complex<double> base;\n\n#define mmin(a, b) a = min(a, (b))\n#define mmax(a, b) a = max(a, (b))\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define ALL(a) a.begin(),a.end()\n#define sqr(x) (x) * (x)\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define cint const int &\n#define SZ(a) ((int)(a.size()))\n#define f(cnt) (((cnt) + 1) * (cnt) / 2)\n#define watch(x) cout << (#x) << \" = \" << x << endl;\n\nconst double PI = 2 * acos(0.0);\n\ntemplate<class T>\nvoid show(const set<T> &a) {\n    for (T x : a)\n        cout << x << \" \";\n    cout << endl;\n}\n\ntemplate<class T>\nvoid show(const vector<T> &a) {\n    for (T x : a)\n        cout << x << \" \";\n    cout << endl;\n}\n\nconst ll M = 1e9 + 7;\n\nll MOD(ll a) {\n    if (a >= 0) return a >= M ? a % M : a;\n    if (a <= -M) a %= M;\n    return a ? a + M : a;\n}\n\nconst int N = 109;\nconst int L = 1e6 + 7;\n\nstruct edge {\n    int u, v;\n    ll height;\n    edge(int u, int v, ll height): u(u), v(v), height(height) {\n\n    }\n\n};\nvector<edge> e;\n\nll pw(ll a, ll p) {\n    if (p < 0LL) return pw(pw(a, -p), M - 2);\n    if (!p) return 1;\n    ll ret = pw(a, p >> 1LL);\n    ret = MOD(ret * ret);\n    if (p & 1LL) ret = MOD(ret * a);\n    return ret;\n}\n\nint counter = 1;\nvi g[L];\nll len[L];\nint vert[L];\nint start[L];\nll h[N];\nll dp[2][L];\n\ninline ll get_ways(int v) {\n    vvvl dp(N, vvl(2, vl(2, 0)));\n    vector<char> must(N, 0);\n    for (int id : g[v]) {\n        int to = e[id].v;\n        for (int i = 1; i < len[to]; ++i)\n            must[i + start[to]] = 1;\n    }\n    dp[start[v]][0][0] = dp[start[v]][0][1] = 1;\n    for (int i = 1; i < len[v]; ++i) {\n        int ind = i + start[v];\n        if (must[ind]) {\n            for (int z1 : {0, 1}) for (int z2 : {0, 1})\n                dp[ind][z1][z2] = dp[ind - 1][z1][!z2];\n        } else {\n            for (int z1 : {0, 1}) for (int z2 : {0, 1}) for (int z3 : {0, 1}) {\n                int nx = z1;\n                if (z2 != z3) nx = 1;\n                dp[ind][nx][z3] = MOD(dp[ind][nx][z3] + dp[ind - 1][z1][z2]);\n            }\n        }\n    }\n    if (len[v] < 2) {\n        while (1) {\n            int a = 1;\n            int b = a + 1;\n            a = a + b;\n        }\n    }\n    ll ret = MOD(dp[start[v] + len[v] - 1][1][0] + dp[start[v] + len[v] - 1][1][1]);\n    return ret;\n}\n\nll dfs(int v) {\n    ll dp0 = 1;\n    ll dp1 = 1;\n    ll dp2 = 0;\n    ll restlen = len[v];\n    for (int id : g[v]) {\n        int to = e[id].v;\n        dfs(to);\n        restlen -= len[to];\n        ll curgood = MOD(pw(2, e[id].height - 1) * dp[0][to]);\n        ll curbad = dp[1][to];\n        dp2 = MOD(dp2 * (curgood * 2 + curbad) + dp1 * curbad);\n        dp1 = MOD(dp1 * curgood * 2);\n        dp0 = MOD(dp0 * curgood);\n    }\n    dp[1][v] = MOD(dp2 * pw(2, restlen) + dp0 * get_ways(v));\n    dp[0][v] = MOD(2 * dp0);\n}\n\nsigned main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n\n    int n;\n    cin >> n;\n    set<ll> hs;\n    fori (i, n) {\n        cin >> h[i];\n        hs.insert(h[i]);\n    }\n    ll prev = 0;\n    len[counter++] = n;\n    fori (i , n)\n        vert[i] = 1;\n    int curv = 0;\n    int par = 0;\n    for (auto hi : hs) {\n        int cnt = 0;\n        fori (i, n) {\n            if (h[i] >= hi) {\n                if (!cnt) {\n                    curv = counter++;\n                    start[curv] = i;\n                    par = vert[i];\n                }\n                vert[i] = curv;\n                cnt++;\n            } else {\n                if (cnt >= 2) {\n                    len[curv] = cnt;\n                    g[par].pb(SZ(e));\n                    e.pb(edge(par, curv, hi - prev));\n                }\n                cnt = 0;\n            }\n        }\n        if (cnt >= 2) {\n            len[curv] = cnt;\n            g[par].pb(SZ(e));\n            e.pb(edge(par, curv, hi - prev));\n        }\n        prev = hi;\n    }\n    ll fre = 0;\n    fori (i, n) {\n        ll neib = 0;\n        if (i) mmax(neib, h[i - 1]);\n        if (i != n - 1) mmax(neib, h[i + 1]);\n        fre += max(0LL, h[i] - neib);\n    }\n    dfs(2);\n    ll ans = MOD(dp[0][2] * pw(2, e[g[1][0]].height - 1) + dp[1][2]);\n    ans = MOD(ans * pw(2, fre));\n    cout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define endl '\\n'\n#define fi first\n#define se second\n#define MOD(n,k) ( ( ((n) % (k)) + (k) ) % (k))\n#define FOR(i,n) for (int i = 0; i < n; i++)\n#define FORR(i,a,b) for (int i = a; i <= b; i++)\n#define ALL(v) v.begin(), v.end()\n#define pb(x) push_back(x)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> ii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<ii> vii;\n\nconst int MX = 105, mod = 1e9+7;\nint n, h[MX];\nll dp[MX][MX][2];\n\nll pot (ll b, ll p, int mod) {\n\tll res = 1;\n\tb %= mod;\n\n\twhile (p) {\n\t\tif (p & 1) res = res * b % mod;\n\t\tb = b * b % mod;\n\t\tp /= 2;\n\t}\n\n\treturn res;\n}\n\nll obtRes (int i, int j, int f, int off) {\n\tll &res = dp[i][j][f];\n\tif (res != -1) return res;\n\n\tint mn = 2e9, cn;\n\tfor (int k = i; k <= j; k++)\n\t\tif (h[k] < mn) {\n\t\t\tmn = h[k];\n\t\t\tcn = 1;\n\t\t} else if (h[k] == mn)\n\t\t\tcn++;\n\n\tif (f) {\n\t\tll x = pot(2, cn, mod);\n\t\tll y = pot(2, mn - off, mod) - 2;\n\t\tint ant = -1;\n\n\t\tfor (int k = i; k <= j; k++) {\n\t\t\tif (h[k] > mn) {\n\t\t\t\tif (ant == -1) ant = k;\n\t\t\t} else {\n\t\t\t\tif (ant != -1) {\n\t\t\t\t\tx = x * (obtRes(ant, k-1, 1, mn) + obtRes(ant, k-1, 0, mn)) % mod;\n\t\t\t\t\ty = y * obtRes(ant, k-1, 0, mn) % mod;\n\t\t\t\t}\n\t\t\t\tant = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (ant != -1) {\n\t\t\tx = x * (obtRes(ant, j, 1, mn) + obtRes(ant, j, 0, mn)) % mod;\n\t\t\ty = y * obtRes(ant, j, 0, mn) % mod;\n\t\t}\n\n\t\treturn res = (x + y) % mod;\n\t}\n\n\tres = pot(2, mn - off, mod);\n\n\tint ant = -1;\n\tfor (int k = i; k <= j; k++) {\n\t\tif (h[k] > mn) {\n\t\t\tif (ant == -1) ant = k;\n\t\t} else {\n\t\t\tif (ant != -1)\n\t\t\t\tres = res * obtRes(ant, k-1, 0, mn) % mod;\n\t\t\tant = -1; \n\t\t}\n\t}\n\n\tif (ant != -1)\n\t\tres = res * obtRes(ant, j, 0, mn) % mod;\n\n\treturn res;\n}\n\nint main () {\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tFOR(i,MX) FOR(j,MX) FOR (k,2) dp[i][j][k] = -1;\n\n\tcin >> n;\n\tFOR(i,n) cin >> h[i];\n\n\tcout << MOD(obtRes(0, n-1, 1, 0), mod) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define XX first\n#define YY second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define REP rep\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\nconst ll MOD=1e9+7;\n\n#define rall(X) (X).rbegin(),(X).rend()\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n\ntemplate<ll mod>\nstruct ModInt{\n  using M=ModInt;\n  ll a;\n  M& put(ll v){\n    a=(v<mod)?v:v-mod;\n    return *this;\n  }\n  ModInt(ll v=0){put(v%mod+mod);}\n  M operator+(M x){return M().put(a+x.a);}\n  M operator-(M x){return M().put(a+mod-x.a);}\n  M operator*(M x){return M().put(a*x.a%mod);}\n  M operator/(M x){return *this*x.inv();}\n  M& operator+=(M x){return *this=*this+x;};\n  M& operator-=(M x){return *this=*this-x;};\n  M& operator*=(M x){return *this=*this*x;};\n  M& operator/=(M x){return *this=*this/x;};\n  bool operator==(M x){return a==x.a;}\n\n  M pow(ll m){\n    M x=*this,res=1;\n    while(m){\n      if(m&1)res*=x;\n      x*=x;\n      m>>=1;\n    }\n    return res;\n  }\n  M inv(){return pow(mod-2);}\n};\n\nusing Int = ModInt<MOD>;\n\nint N;\nvector<LL> hs;\nInt fact = 1;\n\nstruct Val {\n  Int dp1;\n  Int dp2;\n};\n\nstruct Val Calc(vector<LL> &hs) {\n  LL mh = 1LL << 40;\n  for (LL h : hs) {\n    MN(mh, h);\n  }\n\n  struct Val ret = {1, 1};\n  vector<LL> vec;\n  int w = 0;\n  for (LL h : hs) {\n    h -= mh;\n    if (h > 0) {\n      vec.eb(h);\n    } else {\n      ++w;\n      assert(h == 0);\n      if (vec.size()) {\n        auto res = Calc(vec);\n        ret.dp2 *= res.dp2 + res.dp1;\n        ret.dp1 *= res.dp1;\n      }\n      vec.clear();\n    }\n  }\n\n  if (vec.size()) {\n    auto res = Calc(vec);\n    ret.dp2 *= res.dp2 + res.dp1;\n    ret.dp1 *= res.dp1;\n  }\n\n  Int g = Int(2).pow(w);\n  ret.dp2 *= g;\n  //cout << ret.dp1.a << \", \" << ret.dp2.a << endl;\n  Int t = Int(2).pow(mh);\n  ret.dp2 += ret.dp1 * (t-2);\n  ret.dp1 *= t;\n  //cout << ret.dp1.a << \", \" << ret.dp2.a << endl;\n  return ret;\n}\n\nsigned main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n  cin >> N;\n  rep(i, N) {\n    LL h;\n    cin >> h;\n    hs.eb(h);\n  }\n  cout << (fact*Calc(hs).dp2).a << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n\nconst int N = 1e6 + 10;\nconst int mod = 1e9 + 7;\nint h[N], st[N], top, n, ls[N], rs[N], root, f[N][2], num[N], single[N], mulsingle[N], rev[N], coe[N];\nbool bsin[N];\n\ninline void build()\n{\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tint k = top;\n\t\twhile (k > 0 && h[st[k]] > h[i]) k--;\n\t\tif (k) rs[st[k]] = i;\n\t\tif (k < top) ls[i] = st[k + 1];\n\t\tst[++k] = i;\n\t\ttop = k;\n\t}\n\troot = st[1];\n}\n\nvoid dfs(int x)\n{\n\tif (!x) return;\n\tcout << \"x \" << x << endl;\n\tdfs(ls[x]), dfs(rs[x]);\n}\n\ninline int fp(int a, int n)\n{\n\tint res = 1;\n\twhile (n)\n\t{\n\t\tif (n & 1) res = (res * a) % mod;\n\t\ta = (a * a) % mod;\n\t\tn >>= 1;\n\t}\n\treturn res % mod;\n}\n\ninline void fill(int *a, int siz, int val)\n{\n\tfor (int i = 1; i <= siz; i++)\ta[i] = val;\n}\n\ninline void dp(int x, int fa)\n{\n\tif (!x) return;\n\tnum[x] = 1;\n\trev[x] = 1;\n\tcoe[x] = 1;\n\tint height = h[x] - h[fa];\n\t// if (!rs[x] && !ls[x] && h[x] != h[fa])\n\t// {\n\t// \tsingle[x] = 1;\n\t// \tmulsingle[x] *= fp(2, height);\n\t// \treturn;\n\t// }\n\tif (!rs[x] && !ls[x] && h[x] == h[fa])\n\t\treturn;\n\tdp(ls[x], x);\n\tdp(rs[x], x);\n\t// if (ls[x] && x - ls[x] == 1) rev[x] += single[ls[x]];\n\t// if (rs[x] && rs[x] - x == 1) rev[x] += single[rs[x]];\n\t// if (ls[x]) mulsingle[x] *= mulsingle[ls[x]];\n\t// if (rs[x]) mulsingle[x] *= mulsingle[rs[x]]; \n\tif (ls[x] && h[ls[x]] == h[x]) rev[x] += rev[ls[x]], coe[x] = (coe[ls[x]] * coe[x]) % mod;\n\tif (rs[x] && h[rs[x]] == h[x]) rev[x] += rev[rs[x]], coe[x] = (coe[rs[x]] * coe[x]) % mod;\n\tif (f[ls[x]][1] == 0) ls[x] = 0;\n\tif (f[rs[x]][1] == 0) rs[x] = 0;\n\tif (h[x] != h[fa]) coe[x] = 2;\n\tif (height > 0)\n\t{\n\t\tif (rs[x] && ls[x])\n\t\t{\n\t\t\tf[x][1] = f[rs[x]][1] * f[ls[x]][1] % mod * fp(2, height) % mod;\n\t\t\t// cout << \"fk1 \" << f[rs[x]][1] << ' ' << f[ls[x]][1] << endl;\n\t\t\t// cout << \"fk0 \" << f[rs[x]][0] << ' ' << f[ls[x]][0] << endl;\n\t\t\tf[x][0] = (((f[rs[x]][1] * f[ls[x]][0] % mod * coe[rs[x]] * (fp(2, rev[x])) % mod + f[rs[x]][0] * f[ls[x]][1] % mod * coe[ls[x]] * (fp(2, rev[x])) % mod) % mod + f[rs[x]][0] * f[ls[x]][0] % mod * fp(2, rev[x]) % mod) % mod + f[rs[x]][1] * f[ls[x]][1] % mod * (coe[rs[x]] * coe[ls[x]] * (fp(2, rev[x])) - 2) % mod) % mod;\n\t\t}\n\t\telse if (rs[x])\n\t\t{\n\t\t\tf[x][1] = f[rs[x]][1] * fp(2, height) % mod;\n\t\t\tf[x][0] = (f[rs[x]][0] * fp(2, rev[x]) % mod + f[rs[x]][1] * ( coe[rs[x]] * fp(2, rev[x]) - 2) % mod) % mod;\n\t\t\t// cout << \"f[rs[x]][0] \" << f[rs[x]][0] << endl;\n\t\t\t// cout << \"f[rs[x]][1] \" << f[rs[x]][1] << endl;\n\t\t\t// cout << \"coe[rs[x]] \" << coe[rs[x]] << endl;\n\t\t\t// cout << \"rev[x] \" << rev[x] << endl;\n\t\t\t// cout << \"fk \" << f[x][0] << endl;\n\t\t}\n\t\telse if (ls[x])\n\t\t{\n\t\t\tf[x][1] = f[ls[x]][1] * fp(2, height) % mod;\n\t\t\tf[x][0] = (f[ls[x]][0] * fp(2, rev[x]) % mod + f[ls[x]][1] * ( coe[ls[x]] * fp(2, rev[x]) - 2) % mod) % mod;\n\t\t}\n\t\telse \n\t\t{\n\t\t\tf[x][1] = fp(2, height);\n\t\t\tf[x][0] = (fp(2, rev[x]) - 2) % mod;\n\t\t}\n\t}\t\n\telse \n\t{\n\t\tif (rs[x] && ls[x])\n\t\t{\n\t\t\tif (h[rs[x]] != h[x])\n\t\t\t\tcoe[x] *= 2;\n\t\t\tif (h[ls[x]] != h[x])\n\t\t\t\tcoe[x] *= 2;\n\t\t\tf[x][1] = f[rs[x]][1] * f[ls[x]][1] % mod;\n\t\t\tf[x][0] = ((f[rs[x]][0] * f[ls[x]][0] % mod + f[rs[x]][1] * f[ls[x]][0] * coe[rs[x]] % mod) % mod + f[rs[x]][0] * f[ls[x]][1] * coe[ls[x]] % mod) % mod;\n\t\t}\n\t\telse if (rs[x])\n\t\t{\n\t\t\tf[x][1] = f[rs[x]][1];\n\t\t\tf[x][0] = f[rs[x]][0];\n\t\t\tif (h[rs[x]] != h[x])\n\t\t\tcoe[x] *= 2;\n\t\t}\n\t\telse if (ls[x])\n\t\t{\n\t\t\tf[x][1] = f[ls[x]][1];\n\t\t\tf[x][0] = f[ls[x]][0];\n\t\t\tif (h[ls[x]] != h[x])\n\t\t\tcoe[x] *= 2;\n\t\t}\n\t}\n\t// cout << \"x \" << x << endl;\n\t// cout << \"f[x][1] \" << f[x][1] << endl;\n\t// cout << \"f[x][0] \" << f[x][0] << endl;\n\t// cout << \"rev[x] \" << rev[x] << endl;\n\t// cout << \"coe[x] \" << coe[x] << endl;\n\tcoe[x] %= mod;\n}\n\nsigned main()\n{\n\tint ml = 0;\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++)\tcin >> h[i];\n\tif (n == 1)\n\t{\n\t\tcout << fp(2, h[1]) << endl;\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tif (h[i] > h[i - 1] && h[i] > h[i + 1]) ml += h[i] - max(h[i - 1], h[i + 1]), h[i] = max(h[i - 1], h[i + 1]);\n\tbuild();\n\tfill(mulsingle, n, 1);\n\tf[0][1] = f[0][0] = 1;\n\tdp(root, 0);\n\t// cout << \"mul \" << fp(2, ml) << endl;\n\tcout << (f[root][1] + f[root][0]) % mod * fp(2, ml) % mod << endl;\n\t// cout << \"1 \" << f[root][1] << endl;\n\t// cout << \"0 \" << f[root][0] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nconst int mod = 1e9 + 7;\nint n;\nint h[200];\nint mypow(int x, int n) {\n    if (n == 0) return 1;\n    int g = mypow(x, n / 2);\n    g = 1ll * g * g % mod;\n    if (n & 1) g = 1ll * g * x % mod;\n    return g;\n}\nint f[200][200];\nint good[5][5];\nlong long geomprog(int b, int k) {\n    return mypow(b, k + 1) - 1;\n}\nint solve(int l, int r) {\n    for (int j = l; j <= r; j++) b[j] = a[j];\n    sort(b + l, b + r + 1);\n    int c = 1, k = 0;\n    for (int i = l; i <= r; i++) {\n        if (b[i] != b[i - 1]) {\n            k++;\n            l[k] = c;\n            r[k] = b[i] - 1;\n            c = b[i];\n        }\n    }\n    f[l][0] = 2;\n    for (int j = 1; j <= k; j++) {\n        if (r[j] < a[l]) f[l][j] = (geomprog(2, a[j] - l[j]) - geomprog(2, a[j] - r[j]) + mod) % mod;\n    for (int i = l; i < r; i++)\n    for (int j = 0; j <= k; j++)\n        if (f[i][j] != 0) {\n            if (j == 0) {\n                if (a[i] >= a[i + 1]) {\n                    f[i + 1][0] += f[i][j];\n                    if (f[i + 1][0] >= mod) f[i + 1][0] -= mod;\n                }\n            }\n            else {\n                if (r[j] < a[i + 1]) {\n                    int c = 1;\n                    if (a[i + 1] > a[i]) c = mypow(2, a[i + 1] - a[i]);\n                    f[i + 1][j] += 1ll * f[i][j] * c % mod;\n                    if (f[i + 1][j] >= mod) f[i + 1][j] -= mod;\n                }\n                else {\n                    f[i + 1][0] += f[i][j];\n                    if (f[i + 1][0] >= mod) f[i + 1][0] -= mod;\n                }\n            }\n        }\n}\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin >> n;\n    good[0][3] = good[3][0] = 1;\n    good[1][2] = good[2][1] = 1;\n    good[1][1] = good[2][2] = 1;\n    for (int i = 1; i <= n; i++) cin >> h[i];\n    long long c = 1; int prv = 0;\n    h[n + 1] = 1;\n    for (int i = 1; i <= n + 1; i++) {\n        if (h[i] == 1) {\n            if (i != n + 1) c = c * 2 % mod;\n            if (prv + 1 <= i - 1) c = c * solve(prv + 1, i - 1) % mod;\n            prv = i;\n        }\n    }\n    cout << c << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N = 105;\nconst int MOD = 1000000007;\n\nint n,m,h[N],w[N];\nLL dp[N][N];\n\nint pow_(int x,int y) {///快速幂求 x的y次方\n    int ans = 1;\n    if(y > 0) {\n        while(y) {\n            if(y % 2)ans = (LL)ans * x % MOD;\n            x = (LL)x * x % MOD;\n            y /= 2;\n        }\n    }\n    return ans;\n}\n\nint main() {\n    scanf(\"%d\",&n);\n    for(int i = 1;i <= n;i ++) {\n        scanf(\"%d\",&h[i]);\n        w[++ m] = h[i];\n    }\n    sort(w + 1,w + m + 1);///高度排序\n    m = unique(w + 1,w + m + 1) - w - 1;///离散化 m是离散化后的长度\n    for(int i = 1;i <= n;i ++) {\n        h[i] = lower_bound(w + 1,w + m + 1,h[i]) - w;\n    }\n    dp[0][0]=1;\n    for(int i = 1;i <= n;i ++) {\n        for(int j = h[i] + 1;j <= h[i - 1];j ++)\n            (dp[i][0] += dp[i - 1][j] * 2 % MOD) %= MOD;\n            \n        (dp[i][0] += dp[i - 1][0] * 2 % MOD) %= MOD;///交叉或者不交叉\n        \n        int d = pow_(2,w[h[i]] - w[h[i-1]]);\n        for(int j = 1;j <= h[i];j ++) {\n            dp[i][j] = dp[i - 1][j] * d % MOD;\n        }\n        \n        for(int j = h[i - 1] + 1;j <= h[i];j ++) {///比前一列高出的部分\n            if(j > 1)(dp[i][j] += dp[i - 1][0] * (pow_(2,w[j] - w[j - 1]) - 1) % MOD * 2 % MOD * pow_(2,w[h[i]] - w[j]) % MOD) %= MOD;\n            else (dp[i][1] += dp[i - 1][0] * (pow_(2,w[1]) - 2) % MOD) %= MOD;///上一列中无重复的乘上化不超过上一列高度中有重复的\n        }\n    }\n    LL ans = 0;\n    for(int i = 0;i <= m;i++)\n        (ans += dp[n][i]) %= MOD;\n    printf(\"%lld\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#define SF scanf\n#define PF printf\n#define MAXN 100010\n#define MOD 1000000007\nusing namespace std;\nint n,h[MAXN];\ntypedef long long ll;\nll dp[MAXN];\nll fsp(ll x,int y){\n\tll res=1;\n\twhile(y){\n\t\tif(y&1)\n\t\t\tres=res*x%MOD;\n\t\tx=x*x%MOD;\n\t\ty>>=1;\n\t}\n\treturn res;\n}\nint main(){\n\tSF(\"%d\",&n);\n\tdp[n+1]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tSF(\"%d\",&h[i]);\n\t\tif(h[i]==1){\n\t\t\th[i]--;\n\t\t\tdp[n+1]=dp[n+1]*2ll%MOD;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tif(h[i]>h[i-1]&&h[i]>h[i+1]){\n\t\t\tint h1=max(h[i-1],h[i+1]);\n\t\t\tdp[n+1]=dp[n+1]*fsp(2,h[i]-h1)%MOD;\n\t\t\th[i]=h1;\t\n\t\t}\n\tfor(int i=n;i>0;i--){\n\t\tif(h[i])\n\t\t\tdp[i]=dp[i+1]*2ll%MOD;\n\t\telse\n\t\t\tdp[i]=dp[i+1];\n\t\tint minh=h[i],q=i;\n\t\tfor(int j=i;h[j]==h[i];j++)\n\t\t\tif(h[j+1]>h[i]){\n\t\t\t\tq=j;\n\t\t\t\tminh++;\n\t\t\t}\n\t\tll res1=0;\n\t\tint end,sumh=0;\n\t\tif(h[i]<h[i-1])\n\t\t\tend=h[i];\n\t\telse\n\t\t\tend=h[i-1]+1;\n\t\t//PF(\"{%d %d}\\n\",minh,end);\n\t\tfor(int j=q+1;minh>end;j++){\n\t\t\tif(h[j]>h[j-1])\n\t\t\t\tsumh+=h[j]-h[j-1];\n\t\t\tif(h[j]<minh){\n\t\t\t\tint minh1=max(end,h[j]);\n\t\t\t\t//PF(\"{%d %d %d}\\n\",sumh+h[i]-minh,minh-minh1,-(minh==(h[i]+1)?0:1));\n\t\t\t\tif(minh==h[i]+1)\n\t\t\t\t\tres1+=dp[j]*(fsp(2,sumh+h[i]-minh+q-i+2)+fsp(2,sumh+h[i]-minh+2)*(fsp(2,minh-minh1-1)-1)%MOD)%MOD;\n\t\t\t\telse\n\t\t\t\t\tres1+=dp[j]*(fsp(2,sumh+h[i]-minh+1)*(fsp(2,minh-minh1)-1)%MOD)%MOD;\n\t\t\t\tres1%=MOD;\n\t\t\t\tminh=minh1;\n\t\t\t}\n\t\t}\n\t\tdp[i]+=res1;\n\t\tdp[i]%=MOD;\n\t\t//PF(\"{%lld}\\n\",dp[i]);\n\t}\n\tPF(\"%lld\",dp[1]);\n} \n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\nusing namespace std;\n#define MOD 1000000007\n#define f(i,n) for(int i=0;i<int(n);i++)\n#define N (50000)\nlong long p2[30];\n\nvoid prpo2(void){\n\tp2[0] = 2;\n\tf(i, 29)p2[i + 1] = (p2[i] * p2[i]) % MOD;\n\treturn;\n}\n\nlong long po2(int x){\n\tlong long re = 1;\n\tf(i,30){\n\t\tif (x % 2 == 1)re = (re*p2[i]) % MOD;\n\t\tx = x / 2;\n\t}\n\treturn re;\n}\n\nint main(void){\n\tint n;\n\tset<int>se;\n\tvector<int>v;\n\tint x, y;\n\tlong long cc, dd, aa, bb;\n\tlong long c[110];\n\tlong long d[110];\n\tint a[110];\n\tbool u[110];\n\tf(i, 110){\n\t\tu[i] = false;\n\t\tc[i] = -1;\n\t}\n\tprpo2();\n\tscanf(\"%d\", &n);\n\tf(i, n){\n\t\tscanf(\"%d\", &a[i]);\n\t\tif (se.count(a[i]) == 0){\n\t\t\tv.push_back(a[i]);\n\t\t\tse.insert(a[i]);\n\t\t}\n\t}\n\tv.push_back(0);\n\tsort(v.begin(), v.end(), greater<int>());\n\tf(i, v.size()-1){\n\t\tf(j, n){\n\t\t\tif (a[j] >= v[i])u[j] = true;\n\t\t\telse u[j] = false;\n\t\t}\n\t\tf(j, n){\n\t\t\tif (u[j]){\n\t\t\t\tcc = 2;\n\t\t\t\tdd = 1;\n\t\t\t\tx = j;\n\t\t\t\ty = j;\n\t\t\t\twhile (u[y]){\n\t\t\t\t\tif (c[y] >= 0){\n\t\t\t\t\t\tcc *= c[y];\n\t\t\t\t\t\tcc = cc%MOD;\n\t\t\t\t\t\taa = ((2 * c[y]) + d[y]) % MOD;\n\t\t\t\t\t\tdd *= aa;\n\t\t\t\t\t\tdd = dd%MOD;\n\t\t\t\t\t}\n\t\t\t\t\telse if (c[y] == -1){\n\t\t\t\t\t\tdd *= 2;\n\t\t\t\t\t\tdd = dd%MOD;\n\t\t\t\t\t}\n\t\t\t\t\ty++;\n\t\t\t\t}\n\t\t\t\tfor (int ii = x; ii < y; ii++)c[ii] = -2;\n\t\t\t\tdd = (dd - cc + MOD) % MOD;\n\t\t\t\tc[x] = cc;\n\t\t\t\td[x] = dd;\n\t\t\t\tj = y;\n\t\t\t}\n\t\t}\n\t\taa = po2(v[i] - v[i + 1] - 1);\n\t\tf(i, n){\n\t\t\tif (c[i] >= 0)c[i] = (c[i] * aa) % MOD;\n\t\t}\n\t}\n\taa = (c[0] + d[0]) % MOD;\n\tprintf(\"%lld\\n\", aa);\n\n\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Author:xht37\n#include <bits/stdc++.h>\n\n#define ui unsigned int\n#define ll long long\n#define ul unsigned ll\n#define ld long double\n\n#define pi pair <int, int>\n#define fi first\n#define se second\n#define mp make_pair\n\n#define ls (p << 1)\n#define rs (ls | 1)\n#define md ((t[p].l + t[p].r) >> 1)\n\n#define vi vector <int>\n#define pb push_back\n#define pq priority_queue\n\n#define dbg(x) cerr << #x\" = \" << x << endl\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#define fl(x) freopen(x\".in\", \"r\", stdin), freopen(x\".out\", \"w\", stdout)\n\nusing namespace std;\n\nnamespace io {\n\tconst int SI = 1 << 21 | 1;\n\tchar IB[SI], *IS, *IT, OB[SI], *OS = OB, *OT = OS + SI - 1, c, ch[100];\n\tint f, t;\n\t#define gc() (IS == IT ? (IT = (IS = IB) + fread(IB, 1, SI, stdin), IS == IT ? EOF : *IS++) : *IS++)\n\tinline void flush() {\n\t\tfwrite(OB, 1, OS - OB, stdout), OS = OB;\n\t}\n\tinline void pc(char x) {\n\t\t*OS++ = x;\n\t\tif (OS == OT) flush();\n\t}\n\n\ttemplate <class I>\n\tinline void rd(I &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + (c & 15), c = gc());\n\t\tx *= f;\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y) {\n\t\trd(x), rd(y);\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y, I &z) {\n\t\trd(x), rd(y), rd(z);\n\t}\n\ttemplate <class I>\n\tinline void rda(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) rd(a[i]);\n\t}\n\tinline void rdc(char &c) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t}\n\tinline void rds(char *s, int &n) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (n = 0; c >= 33 && c <= 126; s[++n] = c, c = gc());\n\t\ts[n+1] = '\\0';\n\t}\n\tinline void rds(string &s) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (s.clear(); c >= 33 && c <= 126; s.pb(c), c = gc());\n\t}\n\n\ttemplate <class I>\n\tinline void print(I x, char k = '\\n') {\n\t\tif (!x) pc('0');\n\t\tif (x < 0) pc('-'), x = -x;\n\t\twhile (x) ch[++t] = x % 10 + '0', x /= 10;\n\t\twhile (t) pc(ch[t--]);\n\t\tpc(k);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y) {\n\t\tprint(x, ' '), print(y);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y, I z) {\n\t\tprint(x, ' '), print(y, ' '), print(z);\n\t}\n\ttemplate <class I>\n\tinline void printa(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) print(a[i], \" \\n\"[i==n]);\n\t}\n\tinline void printc(char c) {\n\t\tpc(c);\n\t}\n\tinline void prints(char *s, int n) {\n\t\tfor (int i = 1; i <= n; i++) pc(s[i]);\n\t\tpc('\\n');\n\t}\n\tinline void prints(string s) {\n\t\tint n = s.length();\n\t\twhile (t < n) pc(s[t++]);\n\t\tpc('\\n'), t = 0;\n\t}\n\tstruct Flush {\n\t\t~Flush() {\n\t\t\tflush();\n\t\t}\n\t} flusher;\n}\nusing io::rd;\nusing io::rda;\nusing io::rdc;\nusing io::rds;\nusing io::print;\nusing io::printa;\nusing io::printc;\nusing io::prints;\n\nconst int P = 1e9 + 7;\n\nstruct modint {\n\tint x;\n\tinline modint(int x = 0) : x(x) {}\n\tinline modint &operator = (int o) { return x = o, *this; }\n\tinline modint &operator += (modint o) { return (x += o.x) >= P && (x -= P), *this; }\n\tinline modint &operator -= (modint o) { return (x -= o.x) < 0 && (x += P), *this; }\n\tinline modint &operator *= (modint o) { return x = 1ll * x * o.x % P, *this; }\n\ttemplate <class I>\n\tinline modint &operator ^= (I b) {\n\t\tmodint a = *this, c;\n\t\tif (!~b) b = P - 2;\n\t\tc.x = 1 % P;\n\t\twhile (b) {\n\t\t\tif (b & 1) c *= a;\n\t\t\ta *= a, b >>= 1;\n\t\t}\n\t\treturn x = c.x, *this;\n\t}\n\tinline modint &operator /= (modint o) { return *this *= o ^ -1; }\n\tinline modint &operator += (int o) { return (x += o) >= P && (x -= P), *this; }\n\tinline modint &operator -= (int o) { return (x -= o) < 0 && (x += P), *this; }\n\tinline modint &operator *= (int o) { return x = 1ll * x * o % P, *this; }\n\tinline modint &operator /= (int o) { return *this *= (modint)o ^ -1; }\n\ttemplate <class I>\n\tinline friend modint operator + (modint a, I b) { return a += b; }\n\ttemplate <class I>\n\tinline friend modint operator - (modint a, I b) { return a -= b; }\n\ttemplate <class I>\n\tinline friend modint operator * (modint a, I b) { return a *= b; }\n\ttemplate <class I>\n\tinline friend modint operator ^ (modint a, I b) { return a ^= b; }\n\ttemplate <class I>\n\tinline friend modint operator / (modint a, I b) { return a /= b; }\n\tinline friend bool operator == (modint a, int b) { return a.x == b; }\n\tinline friend bool operator != (modint a, int b) { return a.x != b; }\n\tinline friend bool operator < (modint a, int b) { return a.x < b; }\n\tinline friend bool operator <= (modint a, int b) { return a.x <= b; }\n\tinline friend bool operator > (modint a, int b) { return a.x > b; }\n\tinline friend bool operator >= (modint a, int b) { return a.x >= b; }\n\tinline friend bool operator == (modint a, modint b) { return a.x == b.x; }\n\tinline friend bool operator != (modint a, modint b) { return a.x != b.x; }\n\tinline friend bool operator < (modint a, modint b) { return a.x < b.x; }\n\tinline friend bool operator <= (modint a, modint b) { return a.x <= b.x; }\n\tinline friend bool operator > (modint a, modint b) { return a.x > b.x; }\n\tinline friend bool operator >= (modint a, modint b) { return a.x >= b.x; }\n\tinline bool operator ! () { return !x; }\n\tinline modint operator - () { return x ? P - x : 0; }\n};\ninline void rd(modint &x) { rd(x.x); }\ninline void print(modint x, char k = '\\n') { print(x.x, k); }\n\n//const int NP = 1e6 + 7;\n//modint p[NP], v[NP], vp[NP];\n//inline void init(int n) {\n//  p[0] = v[0] = 1;\n//  for (int i = 1; i <= n; i++) p[i] = p[i-1] * i;\n//  vp[n] = 1 / p[n];\n//  for (int i = n; i; i--) v[i] = vp[i] * p[i-1], vp[i-1] = vp[i] * i;\n//}\n//inline modint binom(int n, int m) {\n//  return (m < 0 || n < m) ? 0 : p[n] * vp[m] * vp[n-m];\n//}\n\nconst int N = 1e5 + 7;\nint n, h[N], p[N], pl[N], pr[N], w[N];\n\nstruct DP {\n\tmodint a[2][2][2];\n\tinline DP() {\n\t\tfor (int i = 0; i < 2; i++)\n\t\t\tfor (int j = 0; j < 2; j++)\n\t\t\t\tfor (int k = 0; k < 2; k++)\n\t\t\t\t\ta[i][j][k] = 0;\n\t}\n\tinline friend DP operator + (DP a, DP b) {\n\t\tDP c;\n\t\tfor (int li = 0; li < 2; ++li)\n\t\t\tfor (int ri = 0; ri < 2; ++ri)\n\t\t\t\tfor (int lj = 0; lj < 2; ++lj)\n\t\t\t\t\tfor (int rj = 0; rj < 2; ++rj)\n\t\t\t\t\t\tfor (int lk = 0; lk < 2; ++lk)\n\t\t\t\t\t\t\tfor (int rk = 0; rk < 2; ++rk)\n\t\t\t\t\t\t\t\tc.a[li][ri][lk|rk|(lj==rj)] += a.a[li][lj][lk] * b.a[rj][ri][rk];\n\t\treturn c;\n\t}\n} f[N];\n\nvoid work(int o, int x) {\n\tif (w[o] == x) return;\n\tDP now;\n\tint t = (w[o] ^ x) & 1;\n\tmodint k = (modint)2 ^ (w[o] - x - 1);\n\tfor (int i = 0; i < 2; i++)\n\t\tfor (int j = 0; j < 2; j++)\n\t\t\tnow.a[i][j][1] = f[o].a[i^t][j^t][1],\n\t\t\tnow.a[i][j][0] = (f[o].a[i][j][0] + f[o].a[i^1][j^1][0]) * k;\n\tf[o] = now;\n}\n\nint main() {\n\trd(n), rda(h, n), iota(p + 1, p + n + 1, 1);\n\tsort(p + 1, p + n + 1, [&](int i, int j) { return h[i] > h[j]; });\n\tfor (int o = 1; o <= n; o++) {\n\t\tint i = p[o], L = i, R = i;\n\t\tDP now;\n\t\tnow.a[0][0][0] = now.a[1][1][0] = 1;\n\t\tif (pl[i-1]) L = pl[i-1], pr[L] = pl[i-1] = 0, work(L, h[i]), now = f[L] + now;\n\t\tif (pr[i+1]) R = pr[i+1], pr[i+1] = pl[R] = 0, work(i + 1, h[i]), now = f[i+1] + now;\n\t\tf[L] = now, pr[L] = R, pl[R] = L, w[L] = h[i];\n\t}\n\twork(1, 1);\n\tmodint ans;\n\tfor (int i = 0; i < 2; i++)\n\t\tfor (int j = 0; j < 2; j++)\n\t\t\tfor (int k = 0; k < 2; k++)\n\t\t\t\tans += f[1].a[i][j][k];\n\tprint(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// #pragma GCC optimize (\"O3\")\n// #pragma GCC target (\"sse4\")\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<int,int> PII;\n\n#define REP(i,n) for(int i=0;i<(n);++i)\n#define FOR(i,a,b) for (int i=(a); i<(b); ++i)\n#define FORD(i,a,b) for (int i=(a)-1; i>=(b); --i)\n\n#define pb push_back\n#define mp make_pair\n#define st first\n#define nd second\n\nconst int MOD = 1000000007;\n\nLL powe(LL a, LL b) {\n  LL r = 1;\n  while (b) {\n    if (b&1) {\n      (r *= a) %= MOD;\n    }\n    a = a * a % MOD;\n    b >>= 1;\n  }\n  return r;\n}\n\nint H[105];\n// ababababab..., any\npair<LL, LL> go(int a, int b, int offset) {\n  // printf(\"%d %d %d\\n\", a, b, offset);\n\n  if (a == b) return { 1, 1 };\n\n  int mini = 1e9;\n  FOR(i,a,b) mini = min(mini, H[i] - offset);\n  // assert(mini > 0);\n\n  if (a + 1 == b) return { powe(2, mini-1), powe(2, mini) };\n\n  int S = a;\n\n  LL aba = 1, any = 1, aba_counted = 1;\n  int minis = 0;\n  FOR(i,a,b+1) {\n    if (i == b || H[i]-offset == mini) {\n      if (i > S) {\n        auto rec = go(S, i, offset+mini);\n\n        (aba *= 2 * rec.st) %= MOD;\n        (any *= (rec.nd + 2 * rec.st)) %= MOD;\n      }\n\n      S = i + 1;\n\n      if (i < b) {\n        (any *= 2) %= MOD;\n        ++minis;\n      }\n    }\n  }\n\n  // printf(\"%d %d %d %lld %lld(%d %lld)\\n\", a, b, offset, aba, any, mini, powe(2, mini)-2);\n  (any += 2 * aba * (powe(2, mini-1)-1)) %= MOD;\n  (aba *= powe(2, mini-1)) %= MOD;\n  // printf(\"%d %d %d %lld %lld\\n\", a, b, offset, aba, any);\n\n  return {aba, any};\n}\n\nint main() {\n  // ios_base::sync_with_stdio(0);\n\n  int N;\n  scanf(\"%d\", &N);\n  REP(i,N) {\n    scanf(\"%d\", &H[i]);\n  }\n\n  LL any = 0;\n  REP(i,N) {\n    int h = 0;\n    if (i > 0) h = max(h, H[i-1]);\n    if (i < N-1) h = max(h, H[i+1]);\n    h = min(h, H[i]);\n    any += H[i] - h;\n    H[i] = h;\n  }\n\n  LL result = powe(2, any);\n  auto r = go(0, N, 0);\n  (result *= r.nd) %= MOD;\n\n  /*\n  REP(i,N) {\n    if (H[i] == 1) {\n      ++any;\n      (result *= go(S,i)) %= MOD;\n      S = i + 1;\n    }\n  }\n\n  (result *= powe(2, any)) %= MOD;\n  */\n\n  printf(\"%lld\\n\", result);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint mt(int a,int b)\n{\n\tif(b==0)\n\t{\n\t\treturn 1;\n\t}\n\tint c=mt(a,b>>1);\n\tc=(long long)c*c%1000000007;\n\tif(b&1)\n\t{\n\t\tc=(long long)c*a%1000000007;\n\t}\n\treturn c;\n}\nint h[128];\nvoid sol(int l,int r,int& dp1,int& dp2)\n{\n\tint mn=1000000007;\n\tfor(int i=l;i<=r;i++)\n\t{\n\t\tif(h[i]<mn)\n\t\t{\n\t\t\tmn=h[i];\n\t\t}\n\t}\n\tfor(int i=l;i<=r;i++)\n\t{\n\t\th[i]-=mn;\n\t}\n\tdp1=2;\n\tdp2=1;\n\tint pre=0;\n\tfor(int i=l;i<=r;i++)\n\t{\n\t\tif(h[i])\n\t\t{\n\t\t\tif(!pre)\n\t\t\t{\n\t\t\t\tpre=i;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(pre)\n\t\t\t{\n\t\t\t\tint tmp1,tmp2;\n\t\t\t\tsol(pre,i-1,tmp1,tmp2);\n\t\t\t\tdp1=(long long)dp1*tmp1%1000000007;\n\t\t\t\tdp2=(long long)dp2*(tmp1+tmp2)%1000000007;\n\t\t\t\tpre=0;\n\t\t\t}\n\t\t\tdp2<<=1;\n\t\t\tif(dp2>=1000000007)\n\t\t\t{\n\t\t\t\tdp2-=1000000007;\n\t\t\t}\n\t\t}\n\t}\n\tif(pre)\n\t{\n\t\tint tmp1,tmp2;\n\t\tsol(pre,r,tmp1,tmp2);\n\t\tdp1=(long long)dp1*tmp1%1000000007;\n\t\tdp2=(long long)dp2*(tmp1+tmp2)%1000000007;\n\t\tpre=0;\n\t}\n\tdp2-=dp1;\n\tif(dp2<0)\n\t{\n\t\tdp2+=1000000007;\n\t}\n\tdp1=(long long)dp1*mt(2,mn-1)%1000000007;\n\tdp2+=dp1;\n\tif(dp2>=1000000007)\n\t{\n\t\tdp2-=1000000007;\n\t}\n}\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&h[i]);\n\t}\n\tint dp1,dp2;\n\tsol(1,n,dp1,dp2);\n\tprintf(\"%d\\n\",dp2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll mod = 1'000'000'007;\n\nll p2(ll e) {\n    if (e == 0) return 1;\n    if (e == 1) return 2;\n    if (e & 1) return 2 * p2(e - 1) % mod;\n    ll r = p2(e >> 1);\n    return r * r % mod;\n}\n\nll solve(vector<ll>& hs) {\n    if (hs.empty()) return 1;\n    set<ll> vset(hs.begin(), hs.end());\n    vector<ll> vs(vset.begin(), vset.end());\n    map<ll,int> vi;\n    for (int i = 0; i < vs.size(); i++) vi[vs[i]] = i;\n    vector<ll> ans(vs.size(), 1LL);\n    ll total = 1;\n    ll ph = 0;\n    for (ll h: hs) {\n        if (ph == 0) {\n            for (int i = 0; i <= vi[h]; i++) {\n                ans[i] = p2(h - vs[i]);\n            }\n            total = p2(h);\n        } else if (ph <= h) {\n            vector<ll> pans(ans.begin(), ans.end());\n            for (int i = 0; i <= vi[h]; i++) {\n                ans[i] = (pans[min(i, vi[ph])] + pans[vi[ph]]) * p2(h - max(vs[i], ph));\n                ans[i] %= mod;\n            }\n            total = (total + 2 * pans[vi[ph]]) * p2(h - ph);\n            total %= mod;\n        } else {\n            vector<ll> pans(ans.begin(), ans.end());\n            for (int i = 0; i <= vi[h]; i++) {\n                ans[i] = pans[i] + pans[vi[h]];\n                ans[i] %= mod;\n            }\n            total = (total + 2 * pans[vi[h]]);\n            total %= mod;\n        }\n        ph = h;\n        // printf(\"after h = %lld: total = %lld\\n\", h, total);\n        // for (int i = 0; i < vs.size(); i++) {\n        //     printf(\"%lld: %lld\\n\", vs[i], ans[i]);\n        // }\n        // printf(\"\\n\");\n    }\n    return total;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    vector<ll> h;\n    ll ans = 1;\n    for (int i = 0; i < n; i++) {\n        ll v;\n        scanf(\"%lld\", &v);\n        if (v == 1) {\n            ans *= 2;\n            ans %= mod;\n            ans *= solve(h);\n            ans %= mod;\n            h.clear();\n        } else {\n            h.push_back(v);\n        }\n    }\n    ans *= solve(h);\n    ans %= mod;\n    printf(\"%lld\\n\", (ans % mod + mod) % mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<bitset>\n#include<stack>\nusing namespace std;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n/*\ncout<<setprecision(20)\ncin.tie(0);\nios::sync_with_stdio(false);\n*/\nconst llint mod=1e9+7;\nconst llint big=2.19e15+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-15;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\nllint rui(llint in,int zyo){//inのzyo乗を計算します\n\tllint ans=1,gen=in;\n\tfor(int h=0;h<30;h++){\n\t\tif(zyo&(1<<h)){ans*=gen;ans%=mod;}\n\t\tgen*=gen;gen%=mod;\n\t}\n\treturn ans;\n}\nint main(void){\n\tint n,i,j;cin>>n;\n\t//1～n,晩兵のn+1,さらに晩兵\n\tvector<int>h(n+3);\n\tfor(i=1;i<=n;i++){cin>>h[i];}h[n+1]=1;\n\tvector<pair<int,int>>taka(n+1);\n\tfor(i=1;i<=n+1;i++){taka[i-1]=mp(h[i],i);}\n\tSO(taka);REV(taka);\n\tvector<bool>mite(n+3);\n\tvector<int>hi(n+3);//左端を示します\n\tvector<int>mg(n+3);//左端を示します\n\tfor(i=0;i<n+3;i++){hi[i]=i;mg[i]=i;}\n\tvector<llint>free(n+3);\n\tvector<llint>same(n+3);\n\tvector<llint>when(n+3);//前にいつ見たか\n\tfor(i=0;i<=n;i++){\n\t\tint naga=taka[i].fir;\n\t\tint ter=taka[i].sec;\n\t\tmite[ter]=1;\n\t\t\n\t\tfree[ter]=1;\n\t\tsame[ter]=0;\n\t\twhen[ter]=naga;\n\t\tif(mite[ter+1]){\n\t\t\tint net=ter+1;\n\t\t\tmg[ter]=mg[net];\n\t\t\thi[mg[net]]=ter;\n\t\t\tfree[net]*=rui(2,when[net]-naga);\n\t\t\tfree[net]%=mod;\n\t\t\tllint f=free[ter]*free[net];\n\t\t\tllint s=2*(free[ter]+same[ter])*(free[net]+same[net])-f;\n\t\t\tfree[ter]=f%mod;same[ter]=s%mod;when[ter]=naga;\n\t\t}\n\t\tif(mite[ter-1]){\n\t\t\t//マージします\n\t\t\tint net=hi[ter-1];\n\t\t\thi[mg[ter]]=net;\n\t\t\tmg[hi[net]]=mg[ter];\n\t\t\tfree[net]*=rui(2,when[net]-naga);\n\t\t\tfree[net]%=mod;\n\t\t\tllint f=free[ter]*free[net];\n\t\t\tllint s=2*(free[ter]+same[ter])*(free[net]+same[net])-f;\n\t\t\tfree[net]=f%mod;same[net]=s%mod;when[net]=naga;\n\t\t}\n\t\t//cerr<<\"free\";for(j=1;j<=n+1;j++){cerr<<free[j]<<\" \";}cerr<<endl;\n\t\t//cerr<<\"same\";for(j=1;j<=n+1;j++){cerr<<same[j]<<\" \";}cerr<<endl;\n\t}\n\tcout<<(free[1]+same[1])%mod<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<stdio.h>\n#include<string.h>\n#include<algorithm>\n#include<map>\nusing namespace std;\n\nint n;\nlong long h[111];\nlong long dp[111][111];\nlong long MOD=1000000007;\n\nlong long hn2h[111];\n\nint hn[111];\nmap<long long,int>rk;\nmap<long long,int>::iterator it;\nint l;\nint m;\n\nlong long mul(long long x,long long n)\n{\n    if(n==0)return 1;\n    if(n==1)return x%MOD;\n    long long r=mul(x,n/2);\n    if(n%2==0)\n    {\n        return r*r%MOD;\n    }\n    else\n    {\n        return r*r%MOD*x%MOD;\n    }\n}\n\nint main()\n{\n    int i,j,k;\n    int xx;\n    long long g,g2;\n\n    scanf(\"%d\",&n);\n\n    for(i=1;i<=n;i++)\n    {\n        scanf(\"%lld\",&h[i]);\n\n        if(rk.find(h[i])==rk.end())\n        {\n            rk[h[i]]=1;\n        }\n    }\n\n    m=0;\n    hn2h[0]=0;\n    for(it=rk.begin();it!=rk.end();it++)\n    {\n        m++;\n        rk[it->first]=m;\n\n        hn2h[m]=it->first;\n    }\n    for(i=1;i<=n;i++)\n    {\n        hn[i]=rk[h[i]];\n\n        //cout<<hn[i]<<' ';\n    }\n    //cout<<\"   hn\"<<endl;\n    hn[0]=0;\n\n\n    dp[0][0]=1;\n    for(i=0;i<=n-1;i++)\n    {\n        for(j=0;j<=hn[i];j++)\n        {\n            int nowh=hn[i];\n            int nxth=hn[i+1];\n            if(j==0)\n            {\n                dp[i+1][0]=(dp[i+1][0]+dp[i][j]*2ll)%MOD;\n                for(k=nowh+1;k<=nxth;k++)\n                {\n                    g=hn2h[k]-hn2h[k-1];\n                    if(k>1)g++;\n\n                    g2=hn2h[nxth]-hn2h[k];\n\n                    dp[i+1][k]=(dp[i+1][k]+dp[i][j]*(mul(2ll,g)-2ll)%MOD*mul(2ll,g2)%MOD)%MOD;\n                }\n            }\n            else\n            {\n                if(j>nxth)\n                {\n                    dp[i+1][0]=(dp[i+1][0]+dp[i][j]*2ll)%MOD;\n                }\n                else\n                {\n                    if(nxth<=nowh)\n                    {\n                        dp[i+1][j]=(dp[i+1][j]+dp[i][j])%MOD;\n                    }\n                    else\n                    {\n                        g=hn2h[nxth]-hn2h[nowh];\n                        dp[i+1][j]=(dp[i+1][j]+dp[i][j]*mul(2ll,g)%MOD)%MOD;\n                    }\n                }\n            }\n        }\n    }\n\n    long long ans=0;\n    for(i=0;i<=m;i++)\n    {\n        ans=(ans+dp[n][i])%MOD;\n    }\n    ans=(ans+MOD)%MOD;\n\n    cout<<ans<<endl;\n\n/*\n    for(i=0;i<=n;i++)\n    {\n        for(j=0;j<=hn[i];j++)\n        {\n            cout<<dp[i][j]<<' ';\n        }\n        cout<<endl;\n    }\n*/\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define fi first\n#define se second\n\nconst int N = 105, mod = 1e9 + 7;\nint n, h[N];\n\nvoid add (int &_a, int _b) {\n    _a += _b;\n    if (_a >= mod) _a -= mod;\n}\n\nint binPow (int _a, int _n) {\n    int ret = 1;\n    for (; _n; _n >>= 1, _a = 1LL * _a * _a % mod) if (_n & 1) ret = 1LL * ret * _a % mod;\n    return ret;\n}\n\npair<int, int> solve (int l, int r) {\n    int minH = mod;\n\n    bool rect = 1;\n    for (int i = l; i + 1 <= r; ++i) if (h[i] != h[i + 1]) rect = 0;\n\n    if (rect) return { (binPow(2, r - l + 1) + binPow(2, min(h[l] - h[l - 1], h[r] - h[r + 1]) ) - 2 + mod) % mod,\n                      binPow(2, min(h[l] - h[l - 1], h[r] - h[r + 1]) ) };\n\n    for (int i = l; i <= r; ++i) minH = min(minH, h[i]);\n    vector< pair<int, int> > dp;\n    vector< pair<int, int> > range;\n    for (int i = l, lst = -1; i <= r; ++i) {\n        if (h[i] == minH) lst = -1;\n        else {\n            if (lst == -1) lst = i;\n            if (i == r || h[i + 1] == minH) dp.pb( { solve(lst, i) } );\n        }\n    }\n    for (int i = l, lst = -1; i <= r; ++i) {\n        if (h[i] > minH) lst = -1;\n        else {\n            if (lst == -1) lst = i;\n            if (i == r || h[i + 1] > minH) range.pb( { lst, i } );\n        }\n    }\n\n//    cout << \"l = \" << l << \"  r = \" << r << '\\n';\n//    for (auto _ : dp) cout << _.fi << ' '; cout << '\\n';\n\n    pair<int, int> ret = { 0, 0 };\n\n    int tmp = 1;\n    for (auto _ : dp) tmp = 1LL * tmp * (_.fi + _.se) % mod;\n    for (auto _ : range) tmp = 1LL * tmp * binPow(2, _.se - _.fi + 1) % mod;\n\n//    cout << \"tmp = \" << tmp << '\\n';\n\n    add(ret.fi, tmp);\n\n    tmp = 1;\n    for (auto _ : dp) tmp = 1LL * tmp * _.se % mod;\n    tmp = 2LL * tmp % mod;\n\n//    cout << \"tmp = \" << tmp << '\\n';\n\n    add(ret.fi, 1LL * tmp * (binPow(2, minH - max(h[l - 1], h[r + 1]) - 1) - 1 + mod) % mod);\n\n    add(ret.se, 1LL * tmp * binPow(2, minH - max(h[l - 1], h[r + 1]) - 1) % mod);\n\n//    cout << ret.fi << \"  \" << ret.se << '\\n';\n\n    return ret;\n}\n\nint main () {\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\n    cin >> n;\n    for (int i = 1; i <= n; ++i) cin >> h[i];\n\n    cout << solve(1, n).fi;\n\n    return 0;\n}\n/*\n3\n4 2 5\n\n320\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 105\n\nusing namespace std;\n\nconst int mod = 1e9 + 7;\n\nint n, tot;\nint h[N], H[N], f[N][2];\n\ninline int fpm(int x, int y) {\n\tint res = 1;\n\twhile(y) {\n\t\tif(y & 1) res = 1LL * x * res % mod;\n\t\tx = 1LL * x * x % mod, y >>= 1;\n\t}\n\treturn res;\n}\n\nvoid solve(int u, int l, int r) {\n\tbool flag = false;\n\tH[u] = h[r];\n\tfor(int i = l; i < r; ++i)\n\t\tif(h[i] != h[i + 1]) {\n\t\t\tH[u] = min(H[u], h[i]);\n\t\t\tflag = true;\n\t\t}\n\t\n\tif(!flag) {\n\t\tf[u][0] = fpm(2, r - l + 1) - 2;\n\t\tf[u][1] = fpm(2, H[u]);\n\t\treturn;\n\t}\n\t\n\tf[u][0] = 1, f[u][1] = 2;\n\tfor(int i = l; i <= r; ++i) {\n\t\th[i] -= H[u];\n\t\tif(!h[i])\n\t\t\tf[u][0] = (f[u][0] + f[u][0]) % mod;\n\t}\n\t\n\tint las = 1;\n\tfor(int i = l; i <= r; ++i) {\n\t\tif(h[i - 1] == 0 && h[i] != 0) las = i;\n\t\tif(h[i] != 0 && h[i + 1] == 0) {\n\t\t\tint v = ++tot;\n\t\t\tsolve(v, las, i);\n\t\t\tf[u][0] = f[u][0] * (f[v][0] + 2LL * f[v][1]) % mod;\n\t\t\tf[u][1] = 1LL * f[u][1] * f[v][1] % mod;\n\t\t}\n\t}\n\t\n\tf[u][0] = (f[u][0] - f[u][1] + mod) % mod;\n\tf[u][1] = 1LL * f[u][1] * fpm(2, H[u] - 1) % mod;\n\t\n//\tcerr << l << ' ' << r << ' ' << H[u] << ' ' << f[u][0] << ' ' << f[u][1] << endl;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i <= n; ++i)\n\t\tscanf(\"%d\", &h[i]);\n\t\n\tsolve(0, 1, n);\n\t\n\tint ans = (f[0][0] + f[0][1]) % mod;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int mod = 1e9 + 7;\nconst int N = 105;\n\nint n, h[N];\nint p[N], l[N], r[N];\nint f[N][2], sz[N], H[N], visit[N][N];\nvector<int> G[N];\n\nint binPow(int x, int y) {\n\tif (!y) return 1;\n\tint ret = binPow(x, y >> 1); \n\tret = 1LL * ret * ret % mod;\n\tif (y & 1) ret = 1LL * ret * x % mod; \n\treturn ret;\n}\n\nvoid dfs(int u) {\n\tint tmp = sz[u];\n\tf[u][0] = f[u][1] = 1;\n\tfor (auto v : G[u]) {\n\t\tdfs(v), tmp -= sz[v];\n\t\tf[u][0] = 1LL * f[u][0] * f[v][0] % mod;\n\t\tf[u][1] = 1LL * f[u][1] * (2 * f[v][0] + f[v][1]) % mod;\n\t}\n\tf[u][0] = 2 * f[u][0] % mod;\n\tf[u][1] = 1LL * f[u][1] * binPow(2, tmp) % mod;\n\tf[u][1] = (f[u][1] + mod - f[u][0]) % mod;\n\tf[u][0] = 1LL * f[u][0] * binPow(2, H[u] - 1) % mod;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> n;\n\tfor (int i = 1; i <= n; ++i) cin >> h[i];\n\tfor (int i = 1; i <= n; ++i) {\n\t\tl[i] = i;\n\t\twhile (l[i] > 1 && h[l[i] - 1] >= h[i]) l[i] = l[l[i] - 1];\n\t}\n\tfor (int i = n; i >= 1; --i) {\n\t\tr[i] = i;\n\t\twhile (r[i] < n && h[r[i] + 1] >= h[i]) r[i] = r[r[i] + 1];\n\t}\n\tfor (int i = 1; i <= n; ++i) p[i] = i;\n\tsort(p + 1, p + 1 + n, [&] (int x, int y) {\n\t\treturn h[x] < h[y];\n\t});\n\tint cnt = 0;\n\tvisit[1][n] = ++cnt, sz[1] = n, H[1] = h[p[1]];\n\tfor (int i = 1; i <= n; ++i) {\n\t\tint L = l[p[i]], R = r[p[i]];\n\t\tif (visit[L][R]) continue;\t\t\n\t\tvisit[L][R] = ++cnt, sz[cnt] = R - L + 1;\n\t\tH[cnt] = h[p[i]] - max(h[L - 1], h[R + 1]);\n\t\tint par = 0;\n\t\tif (L > 1 && R < n) {\n\t\t\tif (h[L - 1] > h[R + 1]) par = visit[l[L - 1]][r[L - 1]];\n\t\t\telse par = visit[l[R + 1]][r[R + 1]];\n\t\t}\n\t\telse if (L > 1) par = visit[l[L - 1]][r[L - 1]];\n\t\telse par = visit[l[R + 1]][r[R + 1]];\n\t\tG[par].push_back(cnt);\n\t\t// cout << cnt << ' ' << par << ' ' << H[cnt] << ' ' << sz[cnt] << ' ' << L << ' ' << R << '\\n';\n\t}\n\tdfs(1);\n\tcout << (f[1][0] + f[1][1]) % mod;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\n#define sqr(a) ((a) * (a))\n#define sz(a) int(a.size())\n#define all(a) a.begin(), a.end()\n#define forn(i, n) for(int i = 0; i < int(n); i++) \n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n\ntypedef long long li;\ntypedef long double ld;\ntypedef pair<int, int> pt;\n\ntemplate <class A, class B> ostream& operator << (ostream& out, const pair<A, B> &a) {\n\treturn out << \"(\" << a.x << \", \" << a.y << \")\";\n}\n\ntemplate <class A> ostream& operator << (ostream& out, const vector<A> &v) {\n\tout << \"[\";\n\tforn(i, sz(v)) {\n\t\tif(i) out << \", \";\n\t\tout << v[i];\n\t}\n\treturn out << \"]\";\n}\n\nmt19937 rnd(time(NULL));\n\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\nconst int MOD = INF + 7;\nconst ld EPS = 1e-9;\nconst ld PI = acos(-1.0);\n\nconst int N = 100 + 7;\n\nint n;\nint a[N];\n\nbool read () {\n\tif (scanf(\"%d\", &n) != 1)\n\t\treturn false;\n\tforn(i, n)\n\t\tscanf(\"%d\", &a[i]);\n\treturn true;\n}\n\nint binpow(int a, int b){\n\tint res = 1;\n\twhile (b){\n\t\tif (b & 1)\n\t\t\tres = (res * li(a)) % MOD;\n\t\ta = (a * li(a)) % MOD;\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\n\npt get(int l, int r){\n\tif (l == r)\n\t\treturn mp(1, 0);\n\t\n\tint mn = *min_element(a + l, a + r);\n\t\n\tvector<pt> dp;\n\tint lst = l;\n\tint cnt = 0;\n\tfore(i, l, r){\n\t\ta[i] -= mn;\n\t\tif (a[i] == 0){\n\t\t\tdp.pb(get(lst, i));\n\t\t\tlst = i + 1;\n\t\t\t++cnt;\n\t\t}\n\t}\n\tdp.pb(get(lst, r));\n\t\n\tfore(i, l, r)\n\t\ta[i] += mn;\n\t\n\tint dp1 = binpow(2, mn), dp2 = 0;\n\tfor (auto it : dp)\n\t\tdp1 = (dp1 * li(it.x)) % MOD;\n\t\n\tint tmp;\n\t\n\ttmp = binpow(2, cnt);\n\tfor (auto it : dp)\n\t\ttmp = (tmp * li(it.x + it.y)) % MOD;\n\tdp2 = (dp2 + tmp) % MOD;\n\t\n\ttmp = (binpow(2, mn) - 2 + MOD) % MOD;\n\tfor (auto it : dp)\n\t\ttmp = (tmp * li(it.x)) % MOD;\n\tdp2 = (dp2 + tmp) % MOD;\n\t\n\treturn mp(dp1, dp2);\n}\n\nvoid solve() {\n\tprintf(\"%d\\n\", get(0, n).y);\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\t\n\tint tt = clock();\n\t\n#endif\n\t\n\tcerr.precision(15);\n\tcout.precision(15);\n\tcerr << fixed;\n\tcout << fixed;\n\n#ifdef _DEBUG\n\twhile(read()) {\t\n#else\n\tif(read()) {\n#endif\n\t\tsolve();\n\t\t\n#ifdef _DEBUG\n\tcerr << \"TIME = \" << clock() - tt << endl;\n\ttt = clock();\n#endif\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\nconst LL MOD = 1000000007;\nLL powmod(LL a, LL n){\n    if(n == 0) return 1;\n    if(n % 2) return (a*powmod(a,n-1)) % MOD;\n    LL c = powmod(a, n/2);\n    return (c*c) % MOD;\n}\nLL inv(LL a){\n    return powmod(a, MOD-2);\n}\nLL fact[110000];\nLL invfact[110000];\n\nLL ncr(LL n, LL r){\n    if(r < 0 || n < 0) return 0;\n    if(n < r) return 0;\n    LL a = fact[n];\n    a = (a * invfact[r]) % MOD;\n    a = (a * invfact[n-r]) % MOD;\n    return a;\n}\nvoid init(){\n    fact[0] = 1;\n    invfact[0] = 1;\n    LL inv2 = inv(2);\n    for(LL i = 1; i < 110000; i++){\n        fact[i] = (i*fact[i-1]) % MOD;\n        invfact[i] = inv(fact[i]);\n    }\n}\n\npair<LL,LL> solve(vector<LL> a){\n\tLL r = a[0];\n\tfor(int j = 0; j < a.size(); j++){\n\t\tr = min(r, a[j]);\n\t}\n\tLL num0 = 0;\n\tfor(int j = 0; j < a.size(); j++){\n\t\ta[j] -= r;\n\t\tif(a[j] == 0) num0++;\n\t}\n\tvector<LL> cur;\n\tLL total = powmod(2, num0);\n\tLL alternating = 2;\n\ta.push_back(0);\n\n\tfor(int j = 0; j < a.size(); j++){\n\t\tif(a[j] == 0 && cur.size() > 0){\n\t\t\tpair<LL,LL> d = solve(cur);\n\t\t\tcur.clear();\n\t\t\ttotal = (total * (d.first + d.second) ) % MOD;\n\t\t\talternating = (alternating * d.second) % MOD;\n\t\t}\n\t\tif(a[j] != 0){\n\t\t\tcur.push_back(a[j]);\n\t\t}\n\t\tif(a[j] == 0){\n\t\t\tnum0 ++;\n\t\t}\n\t}\n\ttotal -= alternating;\n\talternating = (alternating * powmod(2, r-1)) % MOD;\n\ttotal += alternating;\n\ttotal %= MOD;\n\tif(total < 0) total += MOD;\n\tif(alternating < 0) alternating += MOD;\n\treturn {total, alternating};\n}\nint main(){\n\tLL N;\n\tcin >> N;\n\tvector<LL> h;\n\tfor(int i = 0; i < N; i++){\n\t\tLL a;\n\t\tcin >> a;\n\t\th.push_back(a);\n\t}\n\tpair<LL,LL> ans = solve(h);\n\tcout << ans.first << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Copyright by libra9z\n#ifndef ONLINE_JUDGE\n#define __DEBUG\n#endif\n\n#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n#pragma GCC optimize(\"Ofast,no-stack-protector\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\")\n\n#define _CRT_SECURE_NO_WARNINGS\n#include <immintrin.h>\n#include <emmintrin.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <algorithm>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cstdint>\n#include <cstring>\n#include <cstdlib>\n#include <vector>\n#include <bitset>\n#include <cstdio>\n#include <queue>\n#include <deque>\n#include <cmath>\n#include <ctime>\n#include <set>\n#include <map>\nusing namespace std;\n#include <ext/rope>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/hash_policy.hpp>\n#include <ext/pb_ds/priority_queue.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\ntemplate <typename T, typename Comp = less <T>, typename Heap_tag = __gnu_pbds :: pairing_heap_tag>\nusing Priority_queue = __gnu_pbds :: priority_queue <T, Comp, Heap_tag>;\ntemplate <typename Key, typename Value>\nusing hashmap = __gnu_pbds :: gp_hash_table <Key, Value>;\ntemplate <typename T, typename Comp = less <T> >\nusing ordered_set = __gnu_pbds :: tree <T, __gnu_pbds :: null_type,\n\t\t\tComp, __gnu_pbds :: rb_tree_tag, __gnu_pbds :: tree_order_statistics_node_update>;\nstruct custom_hash {\n\tstatic uint64_t splitmix64(uint64_t x) {\n\t\tx += 0x9e3779b97f4a7c15;\n\t\tx = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n\t\tx = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n\t\treturn x ^ (x >> 31);\n\t}\n\tsize_t operator()(uint64_t x) const {\n\t\tstatic const uint64_t FIXED_RANDOM = chrono :: steady_clock :: now().time_since_epoch().count();\n\t\treturn splitmix64(x + FIXED_RANDOM);\n\t}\n};\ntemplate <typename T>\nusing hash_set = unordered_set <T, custom_hash>;\ntemplate <typename T, typename K>\nusing hash_map = unordered_map <T, K, custom_hash>;\n\n#define rep(i, n) for (int i = 0; i < (n); ++ i)\n#define rep1(i, n) for (int i = 1; i <= (n); ++ i)\n#define Rep(i, a, b) for (int i = (a); i <= (b); ++ i)\n#define repit(it, a) for (__typeof(a.begin()) it = a.begin(); it != a.end(); it ++)\n#define FILEOPEN(f)                              \\\n        freopen(f\".in\", \"r\", stdin);             \\\n        freopen(f\".out\", \"w\", stdout)\n#define All(a) a.begin(), a.end()\n#define SZ(a) ((int)a.size())\n#define sqr(s) ((s) * (s))\n#define fillset(a, val) memset(a, val, sizeof(a))\n#define fi first\n#define se second\n#define y0 y19260817\n#define y1 y19268107\n#define j0 j19260817\n#define j1 j19268107\n#define x0 x19260817\n#define x1 x19268107\n#ifndef __DEBUG\n#define Debug(...)\n#else\ntemplate <typename T> inline void _debug(const char *names, T &&t) {\n\t(cerr << names << \" = \" << t << endl).flush();\n}\ntemplate <typename T1, typename ...T>\ninline void _debug(const char *names, T1 &&t1, T &&... t) {\n\tconst char *comma = strchr(names, ',');\n\t(cerr.write(names, comma - names) << \" = \" << t1 << \", \").flush();\n\t_debug(comma + 1, t ...);\n}\n#define Debug(...) _debug(#__VA_ARGS__, __VA_ARGS__)\n#endif\ntemplate <typename T>\ninline T chmax(T &x, T y) { return x = max(x, y); }\ntemplate <typename T>\ninline T chmin(T &x, T y) { return x = min(x, y); }\ntemplate <typename T>\ninline void reinit(T &t) { t.~T(); new (&t) T(); }\ntemplate <typename T>\ninline void readval(T &t) { cin >> t; }\ntemplate <typename T>\ninline T readin() { T t; cin >> t; return t; }\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long long llong;\ntypedef unsigned long long ullong;\ntypedef long double ld;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef ullong hash_type;\n\nconst int inf = 0x3f3f3f3f;\nconst ll lnf = 0x3f3f3f3f3f3f3f3f;\nconst double EPS = 1e-9, PI = acos(-1.0);\nconst int mod1 = 1000'000'007, mod2 = 998'244'353;\nmt19937 __random_gen(time(NULL));\n\ntemplate <unsigned MOD>\nclass modular_int {\n\tpublic:\n\t\ttypedef unsigned value_type;\n\tprotected:\n\t\tunsigned x;\n\tpublic:\n\t\tmodular_int inv() const {\n\t\t\tunsigned a = MOD, b = x;\n\t\t\tint u = 0, v = 1;\n\t\t\twhile (b) {\n\t\t\t\tint t = a / b;\n\t\t\t\ta -= t * b, swap(a, b);\n\t\t\t\tu -= t * v, swap(u, v);\n\t\t\t} if (u < 0) u += MOD;\n\t\t\treturn modular_int(u);\n\t\t}\n\t\tinline modular_int pow(long long y) const {\n\t\t\tmodular_int b = *this, r = 1;\n\t\t\tif (y < 0) b = b.inv(), y = -y;\n\t\t\tfor (; y; y >>= 1, b *= b) if (y & 1) r *= b;\n\t\t\treturn r;\n\t\t}\n\tpublic:\n\t\tmodular_int() { x = 0; }\n\t\tmodular_int(const modular_int &y) { x = y.x; }\n\t\tmodular_int(modular_int &&y) { x = y.x; }\n\t\tinline void clear() { *this = modular_int(); }\n\t\tinline int to_int() const { return (int)x; }\n\t\tinline unsigned value() const { return x; }\n\t\tinline void invalid_copyright() {\n\t\t\tstd :: cerr << \"\\\"modular_int\\\" copyrights by libra9z, \";\n\t\t\tstd :: cerr << \"don't use it unless getting the agreement of libra9z! \";\n\t\t\tstd :: cerr << \"(You can ask libra9z on \\\"https://codeforces.com/profile/libra9z\\\")\\n\";\n\t\t\t__builtin_abort();\n\t\t}\n\tpublic:\n\t\tmodular_int(int y) { if (y < 0 || (int)MOD <= y) y %= (int)MOD; if (y < 0) y += MOD; x = y; }\n\t\tmodular_int(unsigned y) { if (MOD <= y) x = y % MOD; else x = y; }\n\t\tmodular_int(long long y) { if (y < 0 || MOD <= y) y %= MOD; if (y < 0) y += MOD; x = y; }\n\t\tmodular_int(unsigned long long y) { if (MOD <= y) x = y % MOD; else x = y; }\n\t\tmodular_int &operator = (const modular_int &y) { x = y.x; }\n\t\tmodular_int &operator = (const int &y) { x = y; }\n\t\tmodular_int &operator = (const long long &y) { x = y; }\n\t\tmodular_int &operator = (const unsigned int &y) { x = y; }\n\t\tmodular_int &operator = (const unsigned long long &y) { x = y; }\n\t\tmodular_int &operator += (const modular_int &y) { if ((x += y.x) >= MOD) x -= MOD; return *this; }\n\t\tmodular_int &operator -= (const modular_int &y) { if ((x -= y.x) & (1u << 31)) x += MOD; return *this; }\n\t\tmodular_int &operator *= (const modular_int &y) { x = (unsigned long long)x * y.x % MOD; return *this; }\n\t\tmodular_int &operator /= (const modular_int &y) { x = (unsigned long long)x * y.inv().x % MOD; return *this; }\n\t\tmodular_int &operator += (const int &y) { return *this += modular_int(y); }\n\t\tmodular_int &operator -= (const int &y) { return *this -= modular_int(y); }\n\t\tmodular_int &operator *= (const int &y) { return *this *= modular_int(y); }\n\t\tmodular_int &operator /= (const int &y) { return *this /= modular_int(y); }\n\t\tmodular_int &operator += (const long long &y) { return *this += modular_int(y); }\n\t\tmodular_int &operator -= (const long long &y) { return *this -= modular_int(y); }\n\t\tmodular_int &operator *= (const long long &y) { return *this *= modular_int(y); }\n\t\tmodular_int &operator /= (const long long &y) { return *this /= modular_int(y); }\n\t\tmodular_int &operator += (const unsigned int &y) { return *this += modular_int(y); }\n\t\tmodular_int &operator -= (const unsigned int &y) { return *this -= modular_int(y); }\n\t\tmodular_int &operator *= (const unsigned int &y) { return *this *= modular_int(y); }\n\t\tmodular_int &operator /= (const unsigned int &y) { return *this /= modular_int(y); }\n\t\tmodular_int &operator += (const unsigned long long &y) { return *this += modular_int(y); }\n\t\tmodular_int &operator -= (const unsigned long long &y) { return *this -= modular_int(y); }\n\t\tmodular_int &operator *= (const unsigned long long &y) { return *this *= modular_int(y); }\n\t\tmodular_int &operator /= (const unsigned long long &y) { return *this /= modular_int(y); }\n\t\tfriend modular_int operator + (modular_int x, const modular_int &y) { return x += y; }\n\t\tfriend modular_int operator - (modular_int x, const modular_int &y) { return x -= y; }\n\t\tfriend modular_int operator * (modular_int x, const modular_int &y) { return x *= y; }\n\t\tfriend modular_int operator / (modular_int x, const modular_int &y) { return x *= y.inv(); }\n\t\tfriend modular_int operator + (modular_int x, const int &y) { return x += y; }\n\t\tfriend modular_int operator - (modular_int x, const int &y) { return x -= y; }\n\t\tfriend modular_int operator * (modular_int x, const int &y) { return x *= y; }\n\t\tfriend modular_int operator / (modular_int x, const int &y) { return x /= y; }\n\t\tfriend modular_int operator + (modular_int x, const long long &y) { return x += y; }\n\t\tfriend modular_int operator - (modular_int x, const long long &y) { return x -= y; }\n\t\tfriend modular_int operator * (modular_int x, const long long &y) { return x *= y; }\n\t\tfriend modular_int operator / (modular_int x, const long long &y) { return x /= y; }\n\t\tfriend modular_int operator + (modular_int x, const unsigned &y) { return x += y; }\n\t\tfriend modular_int operator - (modular_int x, const unsigned &y) { return x -= y; }\n\t\tfriend modular_int operator * (modular_int x, const unsigned &y) { return x *= y; }\n\t\tfriend modular_int operator / (modular_int x, const unsigned &y) { return x /= y; }\n\t\tfriend modular_int operator + (modular_int x, const unsigned long long &y) { return x += y; }\n\t\tfriend modular_int operator - (modular_int x, const unsigned long long &y) { return x -= y; }\n\t\tfriend modular_int operator * (modular_int x, const unsigned long long &y) { return x *= y; }\n\t\tfriend modular_int operator / (modular_int x, const unsigned long long &y) { return x /= y; }\n\t\tmodular_int operator - () const { return (x ? MOD - x : 0); }\n\t\tmodular_int operator ++ () const { return *this += 1; }\n\t\tmodular_int operator -- () const { return *this -= 1; }\n\t\tmodular_int operator ++ (int) const { modular_int ret = *this; *this += 1; return ret; }\n\t\tmodular_int operator -- (int) const { modular_int ret = *this; *this -= 1; return ret; }\n\t\tfriend bool operator < (const modular_int &x, const modular_int &y) { return x.x < y.x; }\n\t\tfriend bool operator == (const modular_int &x, const modular_int &y) { return x.x == y.x; }\n\t\tfriend bool operator != (const modular_int &x, const modular_int &y) { return x.x != y.x; }\n\t\tfriend ostream &operator << (ostream &os, modular_int x) { return os << x.x; }\n\t\tfriend istream &operator >> (istream &is, modular_int &x) { is >> x.x; x.x %= MOD; return is; }\n};\ntypedef modular_int <mod1> mod_int;\n\npair <mod_int, mod_int> solve(const vector <int> &v) {\n\tint mn = *min_element(All(v));\n\tmod_int pv = 1, ph = 1;\n\tvector <int> p;\n\tfor (int now: v)\n\t\tif (now == mn) {\n\t\t\tpv *= 2;\n\t\t\tif (p.empty()) continue;\n\t\t\tauto npr = solve(p);\n\t\t\tp.clear();\n\t\t\tph *= npr.se, pv *= (npr.fi + npr.se);\n\t\t}\n\t\telse\n\t\t\tp.push_back(now - mn);\n\tif (!p.empty()) {\n\t\tauto npr = solve(p);\n\t\tph *= npr.se, pv *= (npr.fi + npr.se);\n\t}\n\tmod_int k = 2 * ph;\n\tph *= mod_int(2).pow(mn);\n\treturn {pv + ph - k, ph};\n}\n\nint main(int argc, const char *argv[]) {\n\tios_base :: sync_with_stdio(false);\n\tcin.tie(nullptr); cout.tie(nullptr);\n\tcout << fixed << setprecision(12);\n\tvector <int> a(*istream_iterator<int>(cin));\n\tfor_each(All(a), readval <int>);\n\tcout << solve(a).fi << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\n#define ll long long\n#define ld long double\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define SZ(x) (int)(x).size()\ntemplate <typename T> using ord_set = tree <T, null_type, less <T>, rb_tree_tag, tree_order_statistics_node_update>;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int N = 105, MOD = 1e9 + 7;\nint n, h[N], mn[N][N], dp[2][N][N], same[N][N], g[N][N], p[N];\n\nint bp(int x, int y) {\n\tint res = 1;\n\twhile (y) {\n\t\tif (y & 1)\n\t\t\tres = (ll)res * x % MOD;\n\t\tx = (ll)x * x % MOD;\n\t\ty /= 2;\n\t}\n\treturn res;\n}\n\nvoid add(int & x, int y) {\n\tx += y;\n\tif (x >= MOD) x -= MOD;\n}\n\nint get(int l, int r) {\n\tif (l > r) return 1;\n\tint & res = g[l][r];\n\tif (res != -1) return res;\n\treturn res = (ll)bp(2, max(0, h[l] - max(h[l - 1], mn[l + 1][r + 1]))) * get(l + 1, r) % MOD;\n}\n\nint solve(int f, int l, int r) {\n\tif (l > r) return 1;\n\tint & res = dp[f][l][r];\n\tif (res != -1) return res;\n\tres = 0;\n\tif (f == 0) {\n\t\tfor (int i = l; i <= r; i++)\n\t\t\tadd(res, (ll)get(l, i) * solve(1, i + 1, r) % MOD);\n\t}\telse {\n\t\tfor (int i = l + 1; i <= r; i++)\n\t\t\tadd(res, (ll)same[l][i] * solve(0, i + 1, r) % MOD);\n\t}\n\treturn res;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false), cin.tie(NULL);\n\t#ifdef LOCAL\n\t\tfreopen(\"input.txt\", \"r\", stdin);\n\t#endif\n\t\n\tmemset(& g, -1, sizeof(g));\n\tmemset(& dp, -1, sizeof(dp));\n\tcin >> n;\n\tint mul = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> h[i];\n\t\tif (h[i] == 1) mul++, h[i] = 0;\n\t}\n\tfor (int r = n + 1; r >= 1; r--) {\n\t\tmn[r][r] = h[r];\n\t\tfor (int l = r - 1; l >= 1; l--) {\n\t\t\tmn[l][r] = min(h[l], mn[l + 1][r]);\n\t\t}\n\t}\n\tp[0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 0; j <= i - 2; j++) {\n\t\t\tadd(p[i], p[j]);\n\t\t}\n\t}\n\tfor (int l = 1; l <= n; l++) {\n\t\tfor (int r = l; r <= n; r++) {\n\t\t\tsame[l][r] = 1;\n\t\t\tfor (int k = l; k <= r; k++) {\n\t\t\t\tint hl = (k == l) ? 0 : h[k - 1];\n\t\t\t\tint hr = (k == r) ? 0 : h[k + 1];\n\t\t\t\tsame[l][r] = (ll)same[l][r] * bp(2, max(0, h[k] - max(hl, hr))) % MOD;\n\t\t\t}\n\t\t\tsame[l][r] = (ll)same[l][r] * p[r - l + 1] % MOD;\n\t\t}\n\t}\n\tint last = 0, res = 1;\n\tfor (int i = 1; i <= n + 1; i++) {\n\t\tif (h[i] == 0) {\n\t\t\tif (last + 1 <= i - 1) {\n\t\t\t\tint cur = (solve(0, last + 1, i - 1) + solve(1, last + 1, i - 1)) % MOD;\n\t\t\t\tcur = cur * 2 % MOD;\n\t\t\t\tcur = (cur - get(last + 1, i - 1) + MOD) % MOD;\n\t\t\t\tres = (ll)res * cur % MOD;\n\t\t\t}\n\t\t\tlast = i;\n\t\t}\n\t}\n\tcout << (ll)res * bp(2, mul) % MOD;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <vector>\n#include <cassert>\n#include <fstream>\n#include <algorithm>\n#include <list>\n#include <random>\n#include <ctime>\n#include <cmath>\n#include <random>\n#include <bitset>\n#include <complex>\n#pragma unroll\n#pragma loop count N\n#pragma ivdep\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n//#define int ll\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef pair<ld, ld> pld;\ntypedef complex<double> base;\n\n#define mmin(a, b) a = min(a, (b))\n#define mmax(a, b) a = max(a, (b))\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define ALL(a) a.begin(),a.end()\n#define sqr(x) (x) * (x)\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define cint const int &\n#define SZ(a) ((int)(a.size()))\n#define f(cnt) (((cnt) + 1) * (cnt) / 2)\n#define watch(x) cout << (#x) << \" = \" << x << endl;\n\nconst double PI = 2 * acos(0.0);\n\ntemplate<class T>\nvoid show(const set<T> &a) {\n    for (T x : a)\n        cout << x << \" \";\n    cout << endl;\n}\n\ntemplate<class T>\nvoid show(const vector<T> &a) {\n    for (T x : a)\n        cout << x << \" \";\n    cout << endl;\n}\n\nconst ll M = 1e9 + 7;\n\nll MOD(ll a) {\n    if (a >= 0) return a >= M ? a % M : a;\n    if (a <= -M) a %= M;\n    return a ? a + M : a;\n}\n\nconst int N = 109;\nconst int L = 1e6 + 7;\n\nstruct edge {\n    int u, v;\n    ll height;\n    edge(int u, int v, ll height): u(u), v(v), height(height) {\n\n    }\n\n};\nvector<edge> e;\n\nll pw(ll a, ll p) {\n    if (!p) return 1;\n    ll ret = pw(a, p >> 1);\n    ret = MOD(ret * ret);\n    if (p & 1) ret = MOD(ret * a);\n    return ret;\n}\n\nint counter = 1;\nvi g[L];\nll len[L];\nint vert[L];\nint start[L];\nll h[N];\nll dp[2][L];\n\ninline ll get_ways(int v) {\n    vvvl dp(N, vvl(2, vl(2, 0)));\n    vector<char> must(N, 0);\n    for (int id : g[v]) {\n        int to = e[id].v;\n        for (int i = 1; i < len[to]; ++i)\n            must[i + start[to]] = 1;\n    }\n    dp[start[v]][0][0] = dp[start[v]][0][1] = 1;\n    for (int i = 1; i < len[v]; ++i) {\n        int ind = i + start[v];\n        if (must[ind]) {\n            for (int z1 : {0, 1}) for (int z2 : {0, 1})\n                dp[ind][z1][z2] = dp[ind - 1][z1][!z2];\n        } else {\n            for (int z1 : {0, 1}) for (int z2 : {0, 1}) for (int z3 : {0, 1}) {\n                int nx = z1;\n                if (z2 != z3) nx = 1;\n                dp[ind][nx][z3] = MOD(dp[ind][nx][z3] + dp[ind - 1][z1][z2]);\n            }\n        }\n    }\n    ll ret = MOD(dp[start[v] + len[v] - 1][1][0] + dp[start[v] + len[v] - 1][1][1]);\n    return ret;\n}\n\nll dfs(int v) {\n    ll dp1 = 1; // wasn't any bad\n    ll dp2 = 0; /* was bad */;\n    ll restlen = len[v];\n    dp[0][v] = 1;\n    for (int id : g[v]) {\n        int to = e[id].v;\n        restlen -= len[to];\n        dfs(to);\n        ll curgood = MOD(pw(2, e[id].height - 1) * dp[0][to]);\n        dp[0][v] = MOD(dp[0][v] * curgood);\n        ll curbad = dp[1][to];\n        ll odp1 = dp1;\n        ll odp2 = dp2;\n        dp1 = MOD(odp1 * curgood * 2);\n        dp2 = MOD(odp2 * (curgood * 2 + curbad) + odp1 * curbad);\n    }\n    ll ways = get_ways(v);\n    dp[1][v] = MOD(dp2 * pw(2, restlen) + dp[0][v] * ways);\n    dp[0][v] = MOD(2 * dp[0][v]);\n}\n\nsigned main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n\n\n    int n;\n    cin >> n;\n    set<ll> hs;\n    fori (i, n) {\n        cin >> h[i];\n        hs.insert(h[i]);\n    }\n    ll prev = 0;\n    len[counter++] = n;\n    fori (i , n)\n        vert[i] = 1;\n    int curv = 0;\n    int par = 0;\n    for (auto hi : hs) {\n        int cnt = 0;\n        fori (i, n) {\n            if (h[i] >= hi) {\n                if (!cnt) {\n                    curv = counter++;\n                    start[curv] = i;\n                }\n                par = vert[i];\n                vert[i] = curv;\n                cnt++;\n            } else {\n                if (cnt >= 2) {\n                    len[curv] = cnt;\n                    g[par].pb(e.size());\n                    e.pb(edge(par, curv, hi - prev));\n                }\n                cnt = 0;\n            }\n        }\n        if (cnt >= 2) {\n            len[curv] = cnt;\n            g[par].pb(e.size());\n            e.pb(edge(par, curv, hi - prev));\n        }\n        prev = hi;\n    }\n    while (counter > N) ++counter;\n    ll fre = 0;\n    fori (i, n) {\n        ll lf = 0, rf = 0;\n        if (i) lf = h[i - 1];\n        if (i != n - 1) rf = h[i + 1];\n        fre += max(0LL, h[i] - max(lf, rf));\n    }\n    dfs(2);\n    ll ans = MOD(dp[0][2] * pw(2, e[g[1][0]].height - 1) + dp[1][2]);\n    ans = MOD(ans * pw(2, fre));\n    cout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cassert>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <ctime>\n#include <map>\n#include <set>\n#include <queue>\n#include <string>\n#include <cassert>\n#include <stack> \n\n#define INFLL 2000000000000000000\n#define INF 2000000000\n#define MOD 1000000007\n#define BASE 77747\n#define PI acos(-1.0)\n#define MAXLEN 29\n\ntypedef std::pair <int, int> pii;\ntypedef long long ll;\ntypedef std::vector <ll> vll;\n\nusing namespace std;\n\nll add(ll a, ll b) {\n\treturn (a + b) % MOD;\n}\nll mul(ll a, ll b) {\n\treturn (a * b) % MOD;\n}\nll modPow(ll a, ll b) {\n\tif (b < 0) return 1;\n\tll ans = 1;\n\twhile (b) {\n\t\tif (b & 1) ans = mul(ans, a);\n\t\ta = mul(a, a);\n\t\tb >>= 1;\n\t}\n\treturn ans;\n}\nll dp2[100][100];\nll dp1[100];\nll arr[100];\nint n;\n\nll solve(int s, int e) {\n\tif (s > e) return 1;\n\tif (s == e) return modPow(2, arr[s]);\n\tint len = e - s + 1;\n\tll tmp[100];\n\tfor (int i = s; i <= e; i++) tmp[i - s] = arr[i];\n\tfor (int i = 0; i < len; i++) for (int j = 0; j < len; j++) dp1[i] = dp2[i][j] = 0;\n\tdp1[0] = modPow(2, tmp[0]);\n\tfor (int i = 0; i < len; i++) {\n\t\tif (tmp[i] <= tmp[0]) dp2[0][i] = mul(modPow(2, tmp[0] - tmp[i]), 2);\n\t\telse dp2[0][i] = 2;\n\t}\n\tfor (int i = 1; i < len; i++) {\n\t\tif (tmp[i] >= tmp[i - 1]) {\n\t\t\tdp1[i] = mul(dp2[i - 1][i - 1], modPow(2, tmp[i] - tmp[i - 1]));\n\t\t\tdp1[i] = add(dp1[i], mul(dp1[i - 1], modPow(2, tmp[i] - tmp[i - 1])));\n\t\t} else \n\t\t\tdp1[i] = add(dp1[i - 1], dp2[i - 1][i]);\n\t\tfor (int j = i; j < len; j++) {\n\t\t\tif (tmp[i] >= tmp[j]) {\n\t\t\t\tif (tmp[i - 1] <= tmp[i]) {\n\t\t\t\t\tdp2[i][j] = mul(add(dp2[i - 1][i - 1], dp2[i - 1][j]), \n\t\t\t\t\t\tmodPow(2, tmp[i] - max(tmp[i - 1], tmp[j])));\n\t\t\t\t} else {\n\t\t\t\t\tdp2[i][j] = add(dp2[i - 1][j], dp2[i - 1][i]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdp2[i][j] = mul(2, dp2[i - 1][i]);\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfor (int i = 0; i < len; i++) {\n\t\tcout << dp1[i] << endl;\n\t\tfor (int j = i; j < len; j++) cout << dp2[i][j] << \" \";\n\t\tcout << endl << \"------------\" << endl;\n\t}*/\n\treturn dp1[len - 1];\n}\n\nint main() {\n\tint t;\n\tt = 1;\n\twhile (t--) {\n\t\tfor (int i = 0; i < 100; i++) {\n\t\t\tdp1[i] = 0;\n\t\t\tarr[i] = 0;\n\t\t\tfor (int j = 0; j < 100; j++) dp2[i][j] = 0;\n\t\t}\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) cin >> arr[i];\n\tll ans = 1;\n\tint prev = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (arr[i] == 1) {\n\t\t\tans = mul(ans, solve(prev, i - 1));\n\t\t\tans = mul(ans, 2);\n\t\t\tprev = i + 1;\n\t\t}\n\t}\n\tans = mul(ans, solve(prev, n - 1));\n\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Love and Freedom.\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#define ll long long\n#define inf 20021225\n#define N 110\n#define pa pair<int,int>\n#define mdn 1000000007\nusing namespace std;\nint read()\n{\n\tint s=0,t=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')\tt=-1; ch=getchar();}\n\twhile(ch>='0' && ch<='9')\ts=s*10+ch-'0',ch=getchar();\n\treturn s*t;\n}\nint a[N],n;\nint ksm(int bs,int mi)\n{\n\tint ans=1;\n\twhile(mi)\n\t{\n\t\tif(mi&1)\tans=1ll*ans*bs%mdn;\n\t\tbs=1ll*bs*bs%mdn; mi>>=1;\n\t}\n\treturn ans;\n}\npa solve(int l,int r,int lim)\n{\n\tint mn=a[min_element(a+l,a+r+1)-a],w1=1,w2=1,num=0;\n\tfor(int i=l,j;i<=r;i++)\n\t{\n\t\tif(a[i]!=mn)\n\t\t{\n\t\t\tj=i; while(j+1<=r&&a[j+1]!=mn)\tj++;\n\t\t\tpa cur=solve(i,j,mn); i=j;\n\t\t\tw1=1ll*cur.first*w1%mdn;\n\t\t\tw2=1ll*(cur.first+cur.second)%mdn*w2%mdn;\n\t\t}\n\t\telse\tnum++;\n\t}\n\treturn make_pair(1ll*w1*ksm(2,mn-lim)%mdn,(1ll*w2*ksm(2,num)%mdn+1ll*w1*(ksm(2,mn-lim)-2)%mdn));\n}\nint main()\n{\n\tn=read();\n\tfor(int i=1;i<=n;i++)\ta[i]=read();\n\tprintf(\"%d\\n\",solve(1,n,0).second);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define SORT(a) sort(a.begin(), a.end())\n#define REVERSE(a) reverse(a.begin(), a.end())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define int long long\n#define INF 1000000000000000000\nusing namespace std;\n\n#define ANS(f) if(f) cout << \"YES\" << endl; else cout << \"NO\" << endl;\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\ntypedef pair<int, int> Pii;\n\ntemplate<typename T>\nvoid readv(vector<T> &a){ REP(i, a.size()) cin >> a[i]; }\nvoid readi(vector<int> &a){ REP(i, a.size()){cin >> a[i]; a[i]--;} }\nvoid debug(mat m){REP(i, m.size()){ REP(j, m[0].size()){ cout << m[i][j] << \",\"; } cout << endl; }}\n\nint modpow(int x, int n, int m){\n    int a = 1;\n    IREP(i, 64){\n        a = (a * a) % m;\n        if(((n >> i) & 1) == 1) a = (a * x) % m;\n    }\n    return a;\n}\n\nsigned main(){\n\n    int N; cin >> N;\n    vec h(N + 1, 1); REP(i, N) cin >> h[i + 1];\n    int mod = 1000000007;\n\n    set<int> s;\n    s.insert(1);\n    REP(i, N) s.insert(h[i]);\n    map<int, int> m;\n    vec v(0);\n    for(int i: s) v.push_back(i);\n    int n = v.size();\n\n    mat dp(N + 1, vec(n + 1, 0));\n    dp[0][n] = 1;\n    REP(i, N){\n        int j0 = Lower_bound(v, h[i]);\n        int j1 = Lower_bound(v, h[i + 1]);\n        if(j1 <= j0){\n            REP(j, j1 + 1){\n                dp[i + 1][j] = dp[i][j];\n            }\n            FOR(j, j1 + 1, n + 1){\n                dp[i + 1][n] += 2 * dp[i][j];\n                dp[i + 1][n] %= mod;\n            }\n        }else{\n            REP(j, j0 + 1){\n                dp[i + 1][j] = (dp[i][j] * modpow(2, h[i + 1] - h[i], mod)) % mod;\n            }\n            FOR(j, j0 + 1, j1 + 1){\n                dp[i + 1][j] = (2 * dp[i][n] * (modpow(2, v[j] - v[j - 1], mod) + mod - 1)) % mod;\n            }\n            dp[i + 1][n] = (2 * dp[i][n]) % mod;\n        }\n    }\n\n    //debug(dp);\n\n    int ans = 0;\n    REP(i, n + 1) ans = (ans + dp[N][i]) % mod;\n    cout << ans;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//************************\n//** author  :  Alex Hu **\n//************************\n\n//  _______        __________         ________        __\n//  \\      \\   ____\\______   \\ ____  /  _____/  _____/  |_\n//  /   |   \\ /  _ \\|       _// __ \\/   \\  ____/ __ \\   __\\\n// /    |    (  <_> )    |   \\  ___/\\    \\_\\  \\  ___/|  |\n// \\____|__  /\\____/|____|_  /\\___  >\\______  /\\___  >__|\n//         \\/              \\/     \\/        \\/     \\/\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define CLEAN(a,b) memset(a,b,sizeof(a))\n#define mkp make_pair\n#define pb push_back\n#define rept(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define fi first\n#define se second\n#define sqr(a) ((a)*(a))\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst ll mod=1e9+7;\nconst int INF=0x3f3f3f3f;\nconst int MAX=1e5+5;\n\nint n;\nint a[105];\nconst int Mod=1'000'000'007;\n\nint ksmii(int a,int b){\n\tif(!b){\n\t\treturn 1;\n\t}\n\tint ff=ksmii(a,b>>1);\n\tff=1LL*ff*ff%Mod;\n\tif(b&1){\n\t\tff=1LL*ff*a%Mod;\n\t}\n\treturn ff;\n}\n\npair<int,int> solve(int l,int r,int lim){\n\tint minx=Mod,cnt;\n\tfor(int i=l;i<=r;i++){\n\t\tif(a[i]<minx){\n\t\t\tminx=a[i];\n\t\t\tcnt=1;\n\t\t}else if(a[i]==minx){\n\t\t\tcnt++;\n\t\t}\n\t}\n\tif(cnt==r-l+1){\n\t\treturn make_pair((ksmii(2,r-l+1)-2+Mod)%Mod,ksmii(2,minx-lim-1));\n\t}\n\tpair<int,int> ans;\n\tint L=-1,rem=r-l+1;\n\tint x1=1,x2=1;\n\tfor(int i=l;i<=r+1;i++){\n\t\tif(L==-1&&a[i]>minx){\n\t\t\tL=i;\n\t\t}else if(L!=-1&&a[i]<=minx){\n\t\t\trem-=i-L;\n\t\t\tpair<int,int> tmp=solve(L,i-1,minx);\n\t\t\tx1=1LL*x1*(tmp.first+4LL*tmp.second%Mod)%Mod;\n\t\t\tx2=2LL*x2*tmp.second%Mod;\n\t\t\tL=-1;\n\t\t}\n\t}\n\tx1=(x1-x2+Mod)%Mod;\n\tans.first=((1LL*x1*ksmii(2,rem)%Mod)+(1LL*x2*((ksmii(2,rem)-2+Mod)%Mod)%Mod))%Mod;\n\tans.second=1LL*x2*ksmii(2,minx-lim-1)%Mod;\n\treturn ans;\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d\",a+i);\n\t}\n\tif(n==1){\n\t\tprintf(\"%d\\n\",ksmii(2,a[1]));\n\t\treturn 0;\n\t}\n\tint peak=1;\n\tfor(int i=1;i<=n;i++){\n\t\tif(a[i]>a[i-1]&&a[i]>a[i+1]){\n\t\t\tpeak=1LL*peak*ksmii(2,a[i]-max(a[i-1],a[i+1]))%Mod;\n\t\t\ta[i]=max(a[i-1],a[i+1]);\n\t\t}\n\t}\n\tpair<int,int> ans=solve(1,n,0);\n\tprintf(\"%lld\\n\",1LL*peak*((ans.first+2LL*ans.second%Mod)%Mod)%Mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nlong long N, K;\nlong long H[100];\nvector<long long> L;\nlong long P[30];\nlong long D[101][101];\n#define MOD 1000000007LL\nlong long R;\n\nlong long pow(long long x) {\n  long long r = 1;\n  for(long long b = 0; b < 30; ++b) {\n    if((1 << b) & x) (r *= P[b]) %= MOD;\n  }\n  return r;\n}\nint main() {\n  P[0] = 2LL;\n  for(long long i = 1; i < 30; ++i) {\n    P[i] = P[i - 1] * P[i - 1] % MOD;\n  }\n  cin >> N;\n  L.push_back(0);\n  for(long long i = 0; i < N; ++i) {\n    cin >> H[i]; L.push_back(H[i]);\n  }\n  sort(L.begin(), L.end());\n  L.erase(unique(L.begin(), L.end()), L.end());\n  K = L.size();\n  /*for(long long k = 0; k < K; ++k) {\n    cout << \"L[\" << k << \"] : \" << L[k] << endl;\n  }*/\n  long long prev_l = 0; D[0][0] = 1;\n  for(long long i = 0; i < N; ++i) {\n    long long l = lower_bound(L.begin(), L.end(), H[i]) - L.begin();\n    /*cout << \"i=\" << i\n      << \" l=\" << l << \" prev_l=\" << prev_l << endl;*/\n    if(prev_l >= l) {\n      (D[i + 1][0] += 2 * D[i][0]) %= MOD;\n      for(long long k = 1; k <= l; ++k) {\n        (D[i + 1][k] += D[i][k]) %= MOD;\n      }\n      for(long long k = l + 1; k <= prev_l; ++k) {\n        (D[i + 1][0] += 2 * D[i][k]) %= MOD;\n      }\n    } else {\n      D[i + 1][0] += 2 * D[i][0];\n      for(long long k = prev_l + 1; k <= l; ++k) {\n        (D[i + 1][k] +=\n          2 * (pow(L[k] - L[k - 1] - (k - 1 == 0 ? 1 : 0)) - 1)\n          * pow(L[l] - L[k]) % MOD\n          * D[i][0]) %= MOD;\n      }\n      long long C = pow(L[l] - L[prev_l]);\n      for(long long k = 1; k <= prev_l; ++k) {\n        (D[i + 1][k] += C * D[i][k]) %= MOD;\n      }\n    }\n    /*for(long long k = 0; k <= l; ++k) {\n      cout << \"  \" << \"D[][\" << k << \"]=\"\n        << D[i + 1][k] << endl;\n    }*/\n    prev_l = l;\n  }\n  for(long long k = 0; k < K; ++k) {\n    (R += D[N][k]) %= MOD;\n  }\n  cout << R << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <set>\n#include <vector>\n#include <map>\n#include <cstdio>\n#include <utility>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cassert>\n#include <climits>\n#include <numeric>\n#include <sstream>\nusing namespace std;\ntypedef long long ll;\n#define DEBUG\n#ifdef DEBUG\n\t#define debug printf\n#else\n\t#define debug(...)\n#endif\nconst int maxn = 103;\nconst int mod = 1e9 + 7;\nint n,m,a[maxn],b[maxn],f[maxn][maxn],tp;\nint i,j;\nll mypow(ll a,ll b)\n{\n\tif(b <= 0)\n\t{\n\t\treturn 1;\n\t}\n\tll res = 1;\n\tfor(;b;b >>= 1,a = a * a % mod)\n\t{\n\t\tif(b & 1)\n\t\t{\n\t\t\tres = res * a % mod;\n\t\t}\n\t}\n\treturn res;\n}\nvoid trans(int d)\n{\n\td = min(d,a[i + 1]);\n\tf[i + 1][d] = (f[i + 1][d] + mypow(2,b[a[i]] - b[max(j,a[i + 1])]) * tp) % mod;\n}\nint main(int argc, char const *argv[])\n{\n\tscanf(\"%d\",&n);\n\tfor(int i = 0;i < n; ++i)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t\tb[i] = --a[i];\n\t}\n\tsort(b,b + n + 1);\n\tm = unique(b,b + n + 1) - b;\n\tfor(int i = 0;i < n; ++i)\n\t{\n\t\ta[i] = lower_bound(b,b + m,a[i]) - b;\n\t}\t\n\tf[0][0] = 1;\n\tfor(i = 0;i < n; ++i)\n\t{\n\t\tfor(j = 0;j <= a[i]; ++j)\n\t\t{\n\t\t\tif((tp = f[i][j]))\n\t\t\t{\n\t\t\t\ttrans(j),trans(a[i]);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",f[n][0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#define int long long\nusing namespace std;\n\nint mod = 1000000007;\n\nint powmod(int a, int n, int mod) {\n\tif (n == 0) return 1;\n\tif (n % 2 == 0) return powmod((a * a) % mod, n / 2, mod);\n\treturn (powmod(a, n - 1, mod) * a) % mod;\n}\n\nint p2(int n) {\n\treturn powmod(2, n, mod) % mod;\n}\n\nint N;\nint H[100];\n\nint aSize;\nvector<int> a[100];\n\nint n;\nint h[100];\nint dp[101][2];\t//1個, 2個\n\n//hを決めた状態で\nint solve() {\n\tint i, j;\n\t\n\tfor (i = 0; i < 101; i++) for (j = 0; j < 2; j++) dp[i][j] = 0;\n\t\n\tif (n == 1) { return p2(h[0]); }\n\t\n\tdp[2][0] = p2(max(h[0], h[1]));\n\tdp[2][1] = p2(max(h[0], h[1]) - min(h[0], h[1])) * 2;\n\t\n\tfor (i = 2; i < n; i++) {\n\t\tdp[i + 1][0] = dp[i][0] + dp[i][1]; dp[i + 1][0] %= mod;\n\t\tdp[i + 1][1] = dp[i][1]; dp[i + 1][1] %= mod;\n\t\tif (h[i] > h[i - 1]) {\n\t\t\tdp[i + 1][0] *= p2(h[i] - h[i - 1]); dp[i + 1][0] %= mod;\n\t\t\tdp[i + 1][1] *= p2(h[i] - h[i - 1]); dp[i + 1][1] %= mod;\n\t\t}\n\t}\n\t\n\treturn (dp[n][0] + dp[n][1]) % mod;\n}\n\nsigned main() {\n\tint i, j;\n\t\n\tcin >> N;\n\tfor (i = 0; i < N; i++) cin >> H[i];\n\t\n\ta[0].push_back(H[0]);\n\tfor (i = 1; i < N; i++) {\n\t\tif (H[i - 1] == 1) {\n\t\t\taSize++;\n\t\t}\n\t\ta[aSize].push_back(H[i]);\n\t}\n\t\n\tint ans = 1;\n\tfor (i = 0; i < aSize; i++) {\n\t\tn = a[i].size();\n\t\tfor (j = 0; j < a[i].size(); j++) h[j] = a[i][j];\n\t\tans *= solve();\n\t\tans %= mod;\n\t}\n\tcout << (ans * p2(h[0])) % mod << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<map>\n#include<vector>\n#include<queue>\n#include<deque>\n#define ll long long\n#define mp make_pair\n#define rep(i,x,y) for(int i=(x);i<=(y);++i)\n#define r0p(i,n) for(int i=0;i<n;++i)\n#pragma GCC optimize(1)\n#pragma G++ optimize(1)\n#pragma GCC optimize(2)\n#pragma G++ optimize(2)\n#pragma GCC optimize(3)\n#pragma G++ optimize(3)\n#pragma GCC optimize(\"-funsafe-loop-optimizations\")\n#pragma GCC optimize(\"-funroll-loops\")\n#pragma GCC optimize(\"-fwhole-program\")\n#pragma GCC optimize(\"-fthread-jumps\")\n#pragma GCC optimize(\"-falign-functions\")\n#pragma GCC optimize(\"-falign-jumps\")\n#pragma GCC optimize(\"-falign-loops\")\n#pragma GCC optimize(\"-falign-labels\")\n#pragma GCC optimize(\"-fcaller-saves\")\n#pragma GCC optimize(\"-fcrossjumping\")\n#pragma GCC optimize(\"-fcse-follow-jumps\")\n#pragma GCC optimize(\"-fcse-skip-blocks\")\n#pragma GCC optimize(\"-fdelete-null-pointer-checks\")\n#pragma GCC optimize(\"-fexpensive-optimizations\")\n#pragma GCC optimize(\"-fgcse\")\n#pragma GCC optimize(\"-fgcse-lm\")\n#pragma GCC optimize(\"-finline-small-functions\")\n#pragma GCC optimize(\"-findirect-inlining\")\n#pragma GCC optimize(\"-foptimize-sibling-calls\")\n#pragma GCC optimize(\"-fpeephole2\")\n#pragma GCC optimize(\"-freorder-blocks\")\n#pragma GCC optimize(\"-freorder-functions\")\n#pragma GCC optimize(\"-frerun-cse-after-loop\")\n#pragma GCC optimize(\"-fsched-interblock\")\n#pragma GCC optimize(\"-fsched-spec\")\n#pragma GCC optimize(\"-fschedule-insns\")\n#pragma GCC optimize(\"-fschedule-insns2\")\n#pragma GCC optimize(\"-fstrict-aliasing\")\n#pragma GCC optimize(\"-fstrict-overflow\")\n#pragma GCC optimize(\"-ftree-switch-conversion\")\n#pragma GCC optimize(\"-ftree-pre\")\n#pragma GCC optimize(\"-ftree-vrp\")\n#define pii pair<int,int>\n#pragma GCC diagnostic error \"-std=c++11\"\nusing namespace std;\ninline void rdl(long long &val){\n    long long x=0;\n    int f=1;\n    char ch=getchar();\n    while((ch<'0' or ch>'9') and ch!='-') ch=getchar();\n    if(ch=='-'){\n        f=-1;\n        ch=getchar();\n\t}\n\twhile(ch>='0' and ch<='9'){\n\t    x=(x<<3)+(x<<1)+ch-'0';\n\t\tch=getchar();\n\t}\n    val=x*f;\n}\ninline void rdi(int &val){\n    int x=0;\n    int f=1;\n    char ch=getchar();\n    while((ch<'0' or ch>'9') and ch!='-') ch=getchar();\n    if(ch=='-'){\n        f=-1;\n        ch=getchar();\n    }\n    while(ch>='0' and ch<='9'){\n        x=(x<<3)+(x<<1)+ch-'0';\n        ch=getchar();\n    }\n    val=x*f;\n}\ninline long long rdl(){\n    long long x=0;\n    int f=1;\n    char ch=getchar();\n    while((ch<'0' or ch>'9') and ch!='-') ch=getchar();\n    if(ch=='-'){\n        f=-1;\n        ch=getchar();\n    }\n    while(ch>='0' and ch<='9'){\n        x=(x<<3)+(x<<1)+ch-'0';\n        ch=getchar();\n    }\n    return x*f;\n}\ninline int rdi(){\n    int x=0;\n    int f=1;\n\tchar ch=getchar();\n\twhile((ch<'0' or ch>'9') and ch!='-') ch=getchar();\n\tif(ch=='-'){\n        f=-1;\n        ch=getchar();\n    }\n    while(ch>='0' and ch<='9'){\n        x=(x<<3)+(x<<1)+ch-'0';\n        ch=getchar();\n    }\n    return x*f;\n}\ninline void write(int x){\n    if(x<0) putchar('-'),x=-x;\n    if(x>9) write(x/10);\n    putchar(x%10+'0');\n}\ninline void _write(int x){\n\twrite(x);\n\tputchar(' ');\n}\ninline void print(int x){\n\twrite(x);\n\tputchar('\\n');\n}\ninline void write(ll x){\n    if(x<0) putchar('-'),x=-x;\n    if(x>9) write(x/10);\n    putchar(x%10+'0');\n}\ninline void _write(ll x){\n\twrite(x);\n\tputchar(' ');\n}\ninline void print(ll x){\n\twrite(x);\n\tputchar('\\n');\n}\nconst int md=1000000007;\ninline int qp(int a,ll b){\n\tint rt=1;\n\twhile(b){\n\t\tif(b&1) rt=(rt*a)%md;\n\t\ta=(a*a)%md;\n\t\tb>>=1; \n\t}\n\treturn rt;\n}\nint w[111],n,dp[111];\nint main(){\n\tint i,j,k;\n\trdi(n);\n\tfor(i=1;i<=n;++i) rdi(w[i]);\n\tdp[0]=1;\n\tw[n+1]=1;\n\tfor(i=1;i<n+2;++i){\n\t\tdp[i]=dp[i-1]*2%md;\n\t\tfor(j=1;j<i;++j){\n\t\t\tint t=max(w[i],w[j-1]),mn=w[j]-1;\n\t\t\tll sum=0;\n\t\t\tfor(k=j;k<i;++k) mn=min(mn,w[k]-1),sum+=max(w[k+1]-w[k],0);\n\t\t\tif(t<=mn){\n\t\t\t\tint t1=qp(2,w[j]-1-mn);\n\t\t\t\tint t2=qp(2,mn-t+1)-1;\n\t\t\t\tint t3=qp(2,sum);\n\t\t\t\tdp[i]=(dp[i]+4ll*dp[j-1]*t1%md*t2%md*t3)%md;\n\t\t\t}\n\t\t}\n\t}\n\tprint(dp[n+1]*500000004ll%md);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define P 1000000007\n\nusing namespace std;\n\ntypedef long long ll;\n\nll h[111], Mn[111][111], Sm[111][111], SS[111][111], n;\n\nll F[111];\n\nll powmod(ll x, ll y = P - 2, ll p = P) {\n    ll ans = 1;\n    while(y) {\n        if(y & 1) ans = ans * x % p;\n        x = x * x % p;\n        y >>= 1;\n    }\n    return ans;\n}\n\nll calc(ll a, ll q, ll n) {\n    return (powmod(2, a + q * n) - powmod(2, a)) * powmod(powmod(2, q) - 1) % P;\n}\n\nint main() {\n    scanf(\"%lld\", &n);\n    for(int i = 1; i <= n; i++) scanf(\"%lld\", &h[i]);\n    h[0] = (h[n + 1] = 1);\n    for(int i = 1; i <= n; i++) {\n        Mn[i][i] = h[i], Sm[i][i] = h[i], SS[i][i] = h[i];\n        for(int j = i + 1; j <= n; j++) Mn[i][j] = min(Mn[i][j - 1], h[j]), Sm[i][j] = Sm[i][j - 1] + h[j], SS[i][j] = SS[i][j - 1] + max(h[j] - h[j - 1], 0ll);\n    }\n    F[0] = 1;\n    for(int i = 1; i <= n; i++) {\n        F[i] = F[i - 1] * 2 % P;\n        for(int j = 1; j <= i; j++) {\n            int r = Mn[j][i], l = max(h[i + 1], h[j - 1]) + 1;\n            if(l <= r) F[i] = (F[i] + 2 * F[j - 1] * calc(SS[j][i] - r, 1, r - l + 1)) % P;\n        }\n    }\n    printf(\"%lld\\n\", (F[n] % P + P) % P);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define cs const\n#define re register\n#define pb push_back\n#define pii pair<int,int>\n#define ll long long\n#define y1 shinkle\n#define fi first\n#define se second\n#define bg begin\nnamespace IO{\n\ncs int RLEN=1<<20|1;\ninline char gc(){\n    static char ibuf[RLEN],*ib,*ob;\n    (ib==ob)&&(ob=(ib=ibuf)+fread(ibuf,1,RLEN,stdin));\n    return (ib==ob)?EOF:*ib++;\n}\ninline int read(){\n    char ch=gc();\n    int res=0;bool f=1;\n    while(!isdigit(ch))f^=ch=='-',ch=gc();\n    while(isdigit(ch))res=(res*10)+(ch^48),ch=gc();\n    return f?res:-res;\n}\ninline ll readll(){\n    char ch=gc();\n    ll res=0;bool f=1;\n    while(!isdigit(ch))f^=ch=='-',ch=gc();\n    while(isdigit(ch))res=(res*10)+(ch^48),ch=gc();\n    return f?res:-res;\n}\ninline char readchar(){\n\tchar ch=gc();\n\twhile(isspace(ch))ch=gc();\n\treturn ch;\n}\ninline int readstring(char *s){\n\tint top=0;char ch=gc();\n\twhile(isspace(ch))ch=gc();\n\twhile(!isspace(ch)&&ch!=EOF)s[++top]=ch,ch=gc();\n\ts[top+1]='\\0';return top;\n}\n\n}\nusing IO::read;\nusing IO::readll;\nusing IO::readstring;\nusing IO::readchar; \ntemplate<typename tp>inline void chemx(tp &a,tp b){(a<b)?(a=b):0;}\ntemplate<typename tp>inline void chemn(tp &a,tp b){(a>b)?(a=b):0;}\ncs int mod=1e9+7;\ninline int add(int a,int b){return (a+b)>=mod?(a+b-mod):(a+b);}\ninline int dec(int a,int b){return (a<b)?(a-b+mod):(a-b);}\ninline int mul(int a,int b){static ll r;r=(ll)a*b;return (r>=mod)?(r%mod):r;}\ninline void Add(int &a,int b){a=(a+b)>=mod?(a+b-mod):(a+b);}\ninline void Dec(int &a,int b){a=(a<b)?(a-b+mod):(a-b);}\ninline void Mul(int &a,int b){static ll r;r=(ll)a*b;a=(r>=mod)?(r%mod):r;}\ninline int ksm(int a,int b,int res=1){for(;b;b>>=1,Mul(a,a))(b&1)&&(Mul(res,a),1);return res;}\ninline int Inv(int x){return ksm(x,mod-2);}\ncs int N=105;\nint n,cnt,f[N][N],a[N],h[N],c[N];\nint main(){\n\t#ifdef Stargazer\n\tfreopen(\"lx.in\",\"r\",stdin);\n\t#endif\n\tn=read();\n\tfor(int i=1;i<=n;i++)h[i]=c[i]=read();\n\tsort(c+1,c+n+1),cnt=unique(c+1,c+n+1)-c-1;\n\tfor(int i=1;i<=n;i++)a[i]=lower_bound(c+1,c+cnt+1,h[i])-c;\n\tf[0][0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tAdd(f[i][0],mul(f[i-1][0],2));\n\t\tfor(int j=a[i]+1;j<=a[i-1];j++)Add(f[i][0],mul(f[i-1][j],2));\n\t\tint d=ksm(2,max(0,h[i]-h[i-1]));\n\t\tfor(int j=1;j<=min(a[i],a[i-1]);j++)Add(f[i][j],mul(f[i-1][j],d));\n\t\tif(i==1)Add(f[1][1],mul(f[0][0],mul(ksm(2,c[1])-2,ksm(2,h[i]-c[1]))));\n\t\tfor(int j=max(2,a[i-1]+1);j<=a[i];j++)\n\t\tAdd(f[i][j],mul(f[i-1][0],mul(ksm(2,c[j]-c[j-1])-1,mul(2,ksm(2,h[i]-c[j])))));\n\t}int res=0;\n\tfor(int i=0;i<=a[n];i++)Add(res,f[n][i]);\n\tcout<<res<<'\\n';return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <functional>\nusing namespace std;\n\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define repn(i,x) for(ll i=1;i<=x;i++)\n\ntypedef long long ll;\nconst ll INF = 1e17;\nconst ll MOD = 1000000007;\nconst ll MAX = 4000001;\n\nll max(ll a, ll b) {\n\tif (a > b) { return a; }\n\treturn b;\n}\n\nll min(ll a, ll b) {\n\tif (a > b) { return b; }\n\treturn a;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) { return a; }\n\tif (a < b) { return gcd(b, a); }\n\treturn gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\n\nstruct edge {\n\tll ind;\n\tll fr;\n\tll to;\n\tll d;\n};\n\nclass mint {\n    long long x;\npublic:\n    mint(long long x = 0) : x((x% MOD + MOD) % MOD) {}\n    mint operator-() const {\n        return mint(-x);\n    }\n    mint& operator+=(const mint& a) {\n        if ((x += a.x) >= MOD) x -= MOD;\n        return *this;\n    }\n    mint& operator-=(const mint& a) {\n        if ((x += MOD - a.x) >= MOD) x -= MOD;\n        return *this;\n    }\n    mint& operator*=(const  mint& a) {\n        (x *= a.x) %= MOD;\n        return *this;\n    }\n    mint operator+(const mint& a) const {\n        mint res(*this);\n        return res += a;\n    }\n    mint operator-(const mint& a) const {\n        mint res(*this);\n        return res -= a;\n    }\n    mint operator*(const mint& a) const {\n        mint res(*this);\n        return res *= a;\n    }\n\n    mint operator^(const ll& t)const {\n        if (!t) return 1;\n        mint a = pow(t >> 1);\n        a *= a;\n        if (t & 1) a *= *this;\n        return a;\n    }\n\n    mint pow(ll t) const {\n        if (!t) return 1;\n        mint a = pow(t >> 1);\n        a *= a;\n        if (t & 1) a *= *this;\n        return a;\n    }\n    // for prime MOD\n    mint inv() const {\n        return pow(MOD - 2);\n    }\n    mint& operator/=(const mint& a) {\n        return (*this) *= a.inv();\n    }\n    mint operator/(const mint& a) const {\n        mint res(*this);\n        return res /= a;\n    }\n\n    friend ostream& operator<<(ostream& os, const mint& m) {\n        os << m.x;\n        return os;\n    }\n};\n\n//////////////////////////\n\n\n\nint main() {\n    \n    ll N;\n    cin >> N;\n\n    vector<ll> H(N + 1, 0);\n    repn(i, N) cin >> H[i];\n    H[0] = 1;\n\n    vector<vector<mint>> dp(N + 1, vector<mint>(N + 1, 0));\n    mint x;\n\n    rep(j, N + 1) {\n        if (H[j] == 1) { dp[0][j] = 1; }\n    }\n\n    repn(i, N)rep(j, N+1) {\n\n        //if (H[i] == 1) {\n            //if(H[j]<=H[i]){dp[i][j]== }\n        //}\n        if (H[i] <= H[i - 1]) {\n            if (H[j] <= H[i]) { dp[i][j] = dp[i - 1][j] + dp[i - 1][i]; }\n            else { dp[i][j] = 0; }\n        }\n\n        else {\n            if (H[j] <= H[i - 1]) { dp[i][j] = ((mint)2^(H[i] - H[i - 1])) * (dp[i - 1][j] + dp[i - 1][i - 1]);}\n            else if (H[j] <= H[i]) { dp[i][j] = ((mint)2^(H[i] - H[j])) * 2 * dp[i - 1][i - 1]; }\n            else { dp[i][j]=0; }\n        }\n        //cout << i << j << \" \"<<dp[i][j] << endl;\n    }\n\n    cout << dp[N][0];\n\n\tsystem(\"PAUSE\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <functional>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <memory>\n#include <thread>\n#include <tuple>\n\nusing namespace std;\n\nconst int mod = 1'000'000'007;\nvector<int> h;\n\nstruct dp_t {\n  long long alternating;\n  long long other;\n};\n\nlong long power(long long n, long long k, long long m) {\n  if (m < 0) m = -m;\n  n %= m;\n  long long ret = 1;\n  while (k) {\n    if (k & 1) ret = (ret * n % m);\n    n = (n * n % m);\n    k >>= 1;\n  }\n  return ret;\n}\n\n\ndp_t solve(int L, int R, int base) {\n  dp_t res = { 0, 0 };\n  if (L == R) {\n    int count = h[L] - base;\n    res.alternating = power(2, count - 1, mod);\n    return res;\n  }\n  int splitbase = *min_element(h.begin() + L, h.begin() + R + 1);\n  int last = L;\n  long long alternate = 1;\n  long long all = 1;\n  for (int i = L; i <= R; i++) {\n    if (h[i] == splitbase) {\n      last = i + 1;\n      all *= 2;\n      all %= mod;\n    }\n    else if (i + 1 > R || h[i + 1] == splitbase) {\n      if (last == i) {\n        all *= power(2, h[i] - splitbase, mod);\n        all *= 2;\n        all %= mod;\n        alternate *= power(2, h[i] - splitbase, mod);\n        alternate %= mod;\n      }\n      else {\n        dp_t sub = solve(last, i, splitbase);\n        alternate *= sub.alternating * 2;\n        alternate %= mod;\n        all *= (sub.alternating * 4 + sub.other) % mod;\n        all %= mod;\n      }\n    }\n  }\n\n  res.other = (all - alternate * 2) % mod;\n  alternate *= power(2, splitbase - base - 1, mod);\n  alternate %= mod;\n  res.alternating = alternate;\n  return res;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  h.resize(n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &h[i]);\n  }\n  dp_t ans = solve(0, n-1, 0);\n  long long val = (ans.alternating * 2 + ans.other) % mod;\n  val += mod;\n  val %= mod;\n  printf(\"%lld\\n\", val);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma warning (disable:4996)\n#include\"bits/stdc++.h\"\n#include<cassert>\n#define int long long\n#define MRE assert(0);\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nconst long long mod = 1000000007;\nconst long long inf = 1e17;\ntypedef pair<int, int> P;\nstruct rect {\n\tint L, R, H;\n};\nint n; \nint h[105];\nint dp1[105][105], dp2[105][105];\nint modpow(int a, int x) {\n\tint res = 1;\n\twhile (x) {\n\t\tif (x & 1)res = res*a%mod;\n\t\ta = a*a%mod;\n\t\tx >>= 1;\n\t}\n\treturn res;\n}\n\nvoid memo(int l, int r) {\n\tif (dp1[l][r] != -1)return;\n\tvector<P>V;\n//\tcout << l << ' ' << r << endl;\n\n\tint idx = l, mn = inf;\n\tfor (int i = l; i <= r; i++)mn = min(mn, h[i]);\n\tint idx2 = l;\n\n\twhile (1) {\n\t\twhile (idx2<=r&&h[idx2] == mn)idx2++;\n\t\tif (idx2 > r)break;\n\t\tint idx3 = idx2;\n\t\twhile (idx3<=r&&h[idx3] != mn)idx3++;\n\t\tV.push_back(P(idx2, idx3-1));\n\t\tidx2 = idx3 + 1;\n\t}\n\n\tif (V.size()) {//適切なマージ\n\t\tvector<P>V2;\n\t\trep(j, V.size()) {\n\t\t\tmemo(V[j].first, V[j].second);\n\t\t\tV2.push_back(P(dp1[V[j].first][V[j].second], dp2[V[j].first][V[j].second]));\n\t\t}\n\t\tint m = 0;\n\t\tfor(int i=l;i<=r;i++)if (h[i] == mn)m++;\n\t\tint sum = 1, sum2 = 2;\n\t\tint H = h[r + 1];\n\t\tif (l)H = max(H, h[l - 1]);\n\t\tH = mn - H;\n\t\trep(i, V2.size()) {\n\t\t\tsum *= V2[i].first + 2 * V2[i].second;\n\t\t\tsum %= mod;\n\t\t\tsum2 *= V2[i].second;\n\t\t\tsum2 %= mod;\n\t\t}\n\t\tsum = sum*modpow(2, m) % mod;\n\t\tint T = (sum + mod - sum2) % mod;\n\t\tsum2 = sum2*modpow(2, H-1) % mod;\n\t\tdp1[l][r] = T;\n\t\tdp2[l][r] = sum2;\n//\t\tcout << l << ' ' << r << ' ' << T << ' ' << sum2 << ' ' << H << endl;\n\t}\n\telse {\n\t\tint H = h[r + 1];\n\t\tif (l)H = max(H, h[l - 1]);\n\t\tint t = (modpow(2, r - l + 1) + mod - 2) % mod;\n\t\tint u = modpow(2, h[l]-H);\n\t\tdp1[l][r] = t;\n\t\tdp2[l][r] = u;\n\t}\n}\n\n\nsigned main() {\n\tcin >> n;\n\trep(i, n)cin >> h[i];\n\t\n\t/*\n\tint cnt = 0;\n\trep(i, n - 1) {\n\t\tif (h[i]<h[i + 1] && h[i + 1]>h[i + 2]) {\n\t\t\tcnt += h[i + 1] - max(h[i], h[i + 2]);\n\t\t\th[i + 1] = max(h[i], h[i + 2]);\n\t\t}\n\t}\n\tif (h[0] > h[1]) {\n\t\tcnt += h[0] - h[1];\n\t\th[0] = h[1];\n\t}\n\tcnt %= mod;\n\trep(i, n) {\n\t\tif (i)cout << ' '; cout << h[i];\n\t}cout << endl;\n\t*/\n\n\trep(i, n)rep(j, n)dp1[i][j] = dp2[i][j]= -1;\n\tmemo(0, n - 1);\n\tcout << (dp1[0][n - 1] + dp2[0][n - 1])%mod << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\nusing namespace std;\nconst int N=105,P=1e9+7;\nint n,h[N];\nint fpow(int k1,int k2){\n\tint k3=1;\n\tfor(;k2;k2>>=1,k1=1LL*k1*k1%P)if(k2&1)k3=1LL*k3*k1%P;\n\treturn k3;\n}\npair<int,int>sol(int l,int r,int bs){\n\tint mn=*min_element(h+l,h+r+1),coef=1,all=1,num=0;\n\tfor(int i=l;i<=r;){\n\t\tif(h[i]!=mn){\n\t\t\tint j=i+1;\n\t\t\twhile(j<=r&&h[j]!=mn)++j;\n\t\t\tpair<int,int>val(sol(i,j-1,mn));\n\t\t\tcoef=1LL*coef*val.fi%P;\n\t\t\tall=1LL*all*(val.fi+val.se)%P;\n\t\t\ti=j;\n\t\t}else{\n\t\t\t++num,++i;\n\t\t}\n\t}\n\treturn make_pair(1LL*coef*fpow(2,mn-bs)%P,(1LL*all*fpow(2,num)%P+1LL*coef*(fpow(2,mn-bs)+P-2)%P)%P);\n}\nint main(){\n\tscanf(\"%d\",&n);\n\trep(i,1,n)scanf(\"%d\",h+i);\n\tprintf(\"%d\\n\",sol(1,n,0).se);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize (\"O2,unroll-loops\")\n//#pragma GCC optimize(\"no-stack-protector,fast-math\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> piii;\ntypedef pair<pair<ll, ll>, bool> DP;\n#define debug(x) cerr<<#x<<'='<<(x)<<endl;\n#define debugp(x) cerr<<#x<<\"= {\"<<(x.first)<<\", \"<<(x.second)<<\"}\"<<endl;\n#define debug2(x, y) cerr<<\"{\"<<#x<<\", \"<<#y<<\"} = {\"<<(x)<<\", \"<<(y)<<\"}\"<<endl;\n#define debugv(v) {cerr<<#v<<\" : \";for (auto x:v) cerr<<x<<' ';cerr<<endl;}\n#define all(x) x.begin(), x.end()\n#define pb push_back\n#define kill(x) return cout<<x<<'\\n', 0;\n\nconst int inf=1000000010;\nconst ll INF=10000000000000010LL;\nconst int mod=1000000007, inv2=(mod+1)/2;\nconst int MAXN=300010, LOG=20;\n\nll n, m, k, u, v, x, y, t, a, b, ans;\nll A[MAXN];\n\nll powmod(ll a, ll b){\n\tll res=1;\n\tfor (; b; b>>=1, a=a*a%mod) if (b&1) res=res*a%mod;\n\treturn res;\n}\n\nDP Get(DP p, int ted){\n\tp.first.first=p.first.first*powmod(2, ted)%mod;\n\treturn p;\n}\n\nDP Merge(DP p, DP q){\n\tif (!p.second) return q;\n\tif (!q.second) return p;\n\tll dp=(p.first.first*q.first.first)%mod*inv2%mod;\n\treturn {{dp, ((p.first.first+p.first.second)*(q.first.first+q.first.second)-dp)%mod}, 1};\n}\n\nDP Solve(int tl, int tr, int h){\n//\tcerr<<\"Solve \"<<tl<<\" \"<<tr<<\" \"<<h<<\"\\n\";\n\tif (tl>tr) return {{0, 0}, 0};\n\tif (tl==tr) return Get({{2, 0}, 1}, A[tl]-1-h);\n\tll mn=inf, pos;\n\tfor (int i=tl; i<=tr; i++) if (A[i]<mn) mn=A[i], pos=i;\n\tint last=tl;\n\tDP res={{0, 0}, 0};\n\tfor (int i=tl; i<=tr; i++) if (A[i]==mn){\n\t\tres=Merge(res, Solve(last, i-1, mn-1));\n\t\tres=Merge(res, {{2, 0}, 1});\n\t\tlast=i+1;\n\t}\n\tif (last<=tr) res=Merge(res, Solve(last, tr, mn-1));\n\tres=Get(res, mn-1-h);\n\t\n//\tcerr<<\"Solve \"<<tl<<\" \"<<tr<<\" \"<<h<<\":  \"<<res.first.first<<\" \"<<res.first.second<<\"\\n\";\n\t\n\treturn res;\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tcin>>n;\n\tfor (int i=1; i<=n; i++) cin>>A[i];\n\tDP res=Solve(1, n, 0);\n\tans=(res.first.first+res.first.second+2ll*mod)%mod;\n\tcout<<ans<<\"\\n\";\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\n#define Mod 1000000007\nusing namespace std;\nint fpow(int a,int b)\n{\n\tint ans=1,t=a;\n\twhile(b)\n\t{\n\t\tif(b&1)ans=(long long)ans*t%Mod;\n\t\tt=(long long)t*t%Mod;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\n//2^a+...+2^{b-1}\nint solve(int a,int b)\n{\n\treturn (fpow(2,b)-fpow(2,a)+Mod)%Mod;\n}\nint h[110],H[110];\nint f[110][110];\nvoid add(int& x,int y)\n{\n\tx+=y;\n\tif(x>=Mod)x-=Mod;\n\treturn ;\n}\nint main()\n{\n\tint n;scanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&h[i]);\n\t\tH[i]=h[i];\n\t}\n\tH[0]=1;\n\tsort(H,H+n+1);int N=unique(H,H+n+1)-H;\n\tfor(int i=1;i<=n;i++)\n\t\th[i]=lower_bound(H,H+N,h[i])-H;\n\tf[0][1]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(h[i]<=h[i-1]){\n\t\t\tfor(int j=1;j<=h[i-1]+1;j++)\n\t\t\t\tif(j>h[i])add(f[i][h[i]+1],f[i-1][j]*2%Mod);\n\t\t\t\telse add(f[i][j],f[i-1][j]);\n\t\t}\n\t\telse{\n\t\t\tfor(int j=1;j<=h[i-1];j++)\n\t\t\t\tadd(f[i][j],(long long)f[i-1][j]*fpow(2,H[h[i]]-H[h[i-1]])%Mod);\n\t\t\tfor(int j=h[i-1]+1;j<=h[i];j++)\n\t\t\t\tadd(f[i][j],(long long)f[i-1][h[i-1]+1]*solve(H[h[i]]-H[j],H[h[i]]-H[j-1])*2%Mod);\n\t\t\tadd(f[i][h[i]+1],f[i-1][h[i-1]+1]*2%Mod);\n\t\t}\n//\t\tprintf(\"%d:\",i);\n//\t\tfor(int j=1;j<=h[i]+1;j++)\n//\t\t\tprintf(\"%d \",f[i][j]);\n//\t\tprintf(\"\\n\");\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=h[n]+1;i++)\n\t\tadd(ans,f[n][i]);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author majk\n */\n\n#ifndef MAJK_LIB\n#define MAJK_LIB\n\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <fstream>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <algorithm>\n#include <numeric>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <array>\n#include <bitset>\nusing namespace std;\n\n#define x first\n#define y second\ntypedef std::pair<int,int> pii; typedef long long ll; typedef unsigned long long ull; typedef unsigned int ui; typedef pair<ui,ui> puu;\n\ntemplate <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate <typename T, typename U> std::ostream&operator<<(std::ostream&o, const pair<T,U>&p) {o << p.x << ' ' << p.y; return o;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {if(t.empty())o<<'\\n';for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\nui logceil(ll x) { return x?8*sizeof(ll)-__builtin_clzll(x):0; }\n\nnamespace std { template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}}; }\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename F> double bshd(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){l=m;}else{h=m;}}return (l+h)/2;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename F> double bsld(double l,double h,const F&f){ui r=200;while(r--){double m=(l+h)/2;if(f(m)){h=m;}else{l=m;}}return (l+h)/2;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector2<T>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector2<T>>(a,vector2<T>(b,c,t)){}};\ntemplate<typename T>class vector4:public vector<vector3<T>>{public:vector4(){} vector4(size_t a,size_t b,size_t c,size_t d,T t=T()):vector<vector3<T>>(a,vector3<T>(b,c,d,t)){}};\ntemplate<typename T>class vector5:public vector<vector4<T>>{public:vector5(){} vector5(size_t a,size_t b,size_t c,size_t d,size_t e,T t=T()):vector<vector4<T>>(a,vector4<T>(b,c,d,e,t)){}};\n\n\n#endif\n#ifndef MOD_H\n#define MOD_H\n\n\n\ntemplate <unsigned int N> class Field {\n    typedef unsigned int ui;\n    typedef unsigned long long ull;\n\tinline ui pow(ui a, ui p){ui r=1,e=a;while(p){if(p&1){r=((ull)r*e)%N;}e=((ull)e*e)%N;p>>=1;}return r;}\n\t/*extended GCD(slow):ll t=0,nt=1,r=N,nr=a;while(nr){ll q=r/nr;t-=q*nt;swap(t,nt);r-=q*nr;swap(r,nr);}assert(r<=1);return(t<0)?t+N:t;*/\n\tinline ui inv(ui a){return pow(a,N-2);}\npublic:\n    inline Field(int x = 0) : v(x<0?N+x:x) {}\n\tinline Field<N> pow(int p){return (*this)^p; }\n\tinline Field<N> operator^(int p){return {(int)pow(v,(ui)p)};}\n    inline Field<N>&operator+=(const Field<N>&o) {if (v+o.v >= N) v += o.v - N; else v += o.v; return *this; }\n    inline Field<N>&operator-=(const Field<N>&o) {if (v<o.v) v -= o.v-N; else v-=o.v; return *this; }\n    inline Field<N>&operator*=(const Field<N>&o) {v=(ull)v*o.v % N; return *this; }\n    inline Field<N>&operator/=(const Field<N>&o) { return *this*=inv(o.v); }\n    inline Field<N> operator+(const Field<N>&o) const {Field<N>r{*this};return r+=o;}\n    inline Field<N> operator-(const Field<N>&o) const {Field<N>r{*this};return r-=o;}\n    inline Field<N> operator*(const Field<N>&o) const {Field<N>r{*this};return r*=o;}\n    inline Field<N> operator/(const Field<N>&o) const {Field<N>r{*this};return r/=o;}\n    inline Field<N> operator-() {if(v) return {(int)(N-v)}; else return {0};};\n    inline Field<N>& operator++() { ++v; if (v==N) v=0; return *this; }\n    inline Field<N> operator++(int) { Field<N>r{*this}; ++*this; return r; }\n    inline Field<N>& operator--() { --v; if (v==-1) v=N-1; return *this; }\n    inline Field<N> operator--(int) { Field<N>r{*this}; --*this; return r; }\n    inline bool operator==(const Field<N>&o) const { return o.v==v; }\n\tinline bool operator!=(const Field<N>&o) const { return o.v!=v; }\n\tinline explicit operator ui() const { return v; }\n\tinline static vector<Field<N>>fact(int t){vector<Field<N>>F(t+1,1);for(int i=2;i<=t;++i){F[i]=F[i-1]*i;}return F;}\n\tinline static vector<Field<N>>invfact(int t){vector<Field<N>>F(t+1,1);Field<N> X{1};for(int i=2;i<=t;++i){X=X*i;}F[t]=1/X;for(int i=t-1;i>=2;--i){F[i]=F[i+1]*(i+1);}return F;}\nprivate: ui v;\n};\ntemplate<unsigned int N>istream &operator>>(std::istream&is,Field<N>&f){unsigned int v;is>>v;f=v;return is;}\ntemplate<unsigned int N>ostream &operator<<(std::ostream&os,const Field<N>&f){return os<<(unsigned int)f;}\ntemplate<unsigned int N>Field<N> operator+(int i,const Field<N>&f){return Field<N>(i)+f;}\ntemplate<unsigned int N>Field<N> operator-(int i,const Field<N>&f){return Field<N>(i)-f;}\ntemplate<unsigned int N>Field<N> operator*(int i,const Field<N>&f){return Field<N>(i)*f;}\ntemplate<unsigned int N>Field<N> operator/(int i,const Field<N>&f){return Field<N>(i)/f;}\n\n\ntypedef Field<1000000007> FieldMod;\n\nstruct Ring {\n\ttemplate <typename T>\n\tstatic T div(T p, T q, T N) {\n\t\tT t=0,nt=1,r=N,nr=q;\n\t\twhile(nr!=0){ T q=r/nr;t-=q*nt;r-=q*nr;swap(t,nt);swap(r,nr); }\n\t\tt=(t<0)?t+N:t;\n\t\tr=(r<0)?r+N:r;\n\t\tif (gcd(p,N)%r!=0) { return 0; }\n\t\treturn (t*p/r)%N;\n\t}\n};\n#endif\n\n\nclass DHistogramColoring {\npublic:\n    FieldMod solve(vector<int> A) {\n        int N = A.size();\n        if (N == 1) return FieldMod{2}.pow(A[0]);\n        vector<FieldMod> D(N+1, 0);\n        D[0] = 1;\n        for (int i = 0; i <= N; ++i) {\n            for (int j = i+1; j <= N; ++j) {\n                ll choices = 0;\n                int lo = A[i];\n                for (int k = i; k < j; ++k) {\n                    choices += max(0, A[k] - (k==i?0:A[k-1]));\n                    lo = min(lo, A[k]);\n                }\n\n                if (i != 0 && j != N) {\n                    choices -= min(A[i-1], A[i]);\n                    choices -= min(A[j-1], A[j]);\n                    choices += min(lo, min(A[i-1],A[j]));\n                } else if (i == 0 && j != N) {\n                    choices -= min(A[j-1], A[j]);\n                    choices++;\n                } else if (i == 0 && j == N) {\n                    // ok\n                } else {\n                    choices -= min(A[i-1], A[i]);\n                }\n\n                D[j] += D[i] * FieldMod{2}.pow(choices % 1000000006);\n            }\n        }\n        return D[N];\n    }\n\n    void solve(istream& cin, ostream& cout) {\n        int N; cin >> N;\n        vector<int> A(N); cin >> A;\n        if (N == 1) {\n            cout << FieldMod{2}.pow(A[0]) << endl;\n            return;\n        }\n\n        FieldMod mul = 1;\n//        if (A[0] > A[1]) {\n//            mul *= FieldMod{2}.pow(A[0]-A[1]);\n//            A[0] = A[1];\n//        }\n\n//        if (A[N-1] > A[N-2]) {\n//            mul *= FieldMod{2}.pow(A[N-1]-A[N-2]);\n//            A[N-1] = A[N-2];\n//        }\n\n//        for (int i = 1; i < N-1; ++i) {\n//            if (A[i] > max(A[i-1], A[i+1])) {\n//                mul *= FieldMod{2}.pow(A[i]-max(A[i-1], A[i+1]));\n//                A[i] = max(A[i-1], A[i+1]);\n//            }\n//        }\n\n        for (int i = 0; i < N; ++i) {\n            if (A[i] == 1) {\n                A[i] = 0;\n                mul *= 2;\n            }\n        }\n\n        vector<int> B;\n        FieldMod ans = 1;\n        for (int i = 0; i < N; ++i) {\n            if (A[i] == 0) {\n                if (!B.empty()) {\n                    ans *= solve(B);\n                    B.clear();\n                }\n            } else {\n                B.push_back(A[i]);\n            }\n        }\n\n        if (!B.empty()) ans *= solve(B);\n        cout << ans * mul << '\\n';\n    }\n};\n\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tDHistogramColoring solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <vector>\nusing namespace std;\n#define ll long long\nconst int N = 10;\nconst int mod = 1e9 + 7;\ninline int add(int a, int b){a += b; if(a >= mod) a -= mod; return a;}\ninline int sub(int a, int b){ a -= b; if(a < 0) a += mod; return a;}\ninline int mul(int a, int b){return (a * (ll) b) % mod;}\n\ninline int powr(int a, int b){\n\tint ret = 1;\n\tfor(; b; b >>= 1, a = mul(a, a)) if(b & 1) ret = mul(ret, a);\n\treturn ret;\n}\n\ninline int f(int i, int j){\n\treturn sub(add(powr(2, i), powr(2, j)), 2);\n}\n\nint get2(vector<int> v){\n\tif(v.empty()) return 1;\n\tint mn = *min_element(v.begin(), v.end());\n\tint ret = powr(2, mn);\n\tvector<int> curr = {};\n\tfor(auto it : v){\n\t\tif(it == mn){\n\t\t\tret = mul(ret, get2(curr));\n\t\t\tcurr = {};\n\t\t} else{\n\t\t\tcurr.push_back(it - mn);\n\t\t}\n\t}\n\treturn ret;\n}\n\nint get(vector<int> v){\n\tif(v.empty()) return 1;\n\tint mn = *min_element(v.begin(), v.end());\n\tint ret = 1;\n\tint ans = 0;\n\tint total = -1;\n\tint F = mul(2, sub(powr(2, mn - 1), 1));\n\tvector<int> curr = {};\n\tvector<int> curr2 = {};\n\tfor(auto it : v){\n\t\tif(it == mn){\n\t\t\tret = mul(ret, get(curr));\n\t\t\tif(F) F = mul(F, get2(curr2));\n\t\t\tcurr = {};\n\t\t\tcurr2 = {};\n\t\t\tret = mul(ret, 2);\n\n\t\t} else{\n\t\t\tcurr.push_back(it - mn + 1);\n\t\t\tcurr2.push_back(it - mn);\n\t\t}\n\t}\n\tret = mul(ret, get(curr));\n\tret = add(ret, F);\n\treturn ret;\n}\n\nint main(){\n\tint n; cin >> n;\n\tvector<int> h(n);\n\tfor(int i = 0; i < n; i++) cin >> h[i];\n\tcout << get(h) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n\ntypedef long long LL;\n\nint main(){\n  int n;\n  cin >> n;\n  LL h;\n  LL pre=0;\n  LL renzoku=0;\n  LL count=0;\n  bool one=true;\n  LL ans=1;\n  vector<LL> a(n);\n  int now=0;\n  for(int i=0;i<n;i++){\n    cin >> h;\n    if(h>1){\n      if(h>pre) count+=h-pre;\n      pre=h;\n      renzoku++;\n      if(one) count--;\n      one=false;\n    }else{\n      a[now]=renzoku;\n      now++;\n      count++;\n      pre=0;\n      renzoku=0;\n      one=true;\n    }\n  }\n  if(h>1){\n    a[now]=renzoku;\n    now++;\n  }\n  count%=1000000006;\n  vector<LL> doub(31);\n  doub[0]=2;\n  for(int i=1;i<n;i++){\n    doub[i]=doub[i-1]*doub[i-1]%1000000007;\n  }\n  LL tmp;\n  for(int i=0;i<now;i++){\n    tmp=1;\n    // cout << a[i] << endl;\n    for(int j=0;j<31;j++){\n      if((a[i]-1)&(1<<j)){\n        tmp=tmp*doub[j]%1000000007;\n      }\n    }\n    // cout << tmp << endl;\n    ans=ans*(tmp+1)%1000000007;\n  }\n  // LL t=1;\n  // cout << \"c\" << count << endl;\n  for(int i=0;i<31;i++){\n    if(count&(1<<i)){\n      // t*=doub[i];\n      ans=ans*doub[i]%1000000007;\n    }\n  }\n  // cout << t << endl;\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing ll = long long;\n#define MIN(a, b) (((a) < (b)) ? (a) : (b))\n#define MAX(a, b) (((a) < (b)) ? (b) : (a))\n\nint const nmax = 100;\nint const inf =    1000000000;\nint const modulo = 1000000007;\nint v[1 + nmax];\n\nint lgpow(int a, int b) {\n  if(b == 0)\n    return 1;\n  else if(b == 1)\n    return a;\n  else {\n    int result = lgpow(a, b/ 2);\n    if(b % 2 == 0)\n      return 1LL * result * result % modulo;\n    else\n      return 1LL * result * result % modulo * a % modulo;\n  }\n}\n\nstd::pair<int,int> solve(int from, int to, int start) {\n  int smin = inf;\n  for(int i = from; i <= to; i++)\n    smin = std::min(smin, v[i]);\n  int last = from - 1;\n  \n  std::pair<int,int> sol;\n\n  for(int i = from; i <= to; i++) {\n    if(v[i] == smin) {\n      if(last + 1 < i) {\n        if(last == from - 1) { \n          sol = solve(last + 1, i - 1, smin);\n          sol.first = sol.first * 2 % modulo;\n        } else {\n          std::pair<int,int> aux = solve(last + 1, i - 1, smin);\n          sol.second = (1LL * sol.second * (2LL * aux.first + aux.second) + 1LL * sol.first * aux.second + 1LL * sol.first * aux.first) % modulo;\n          sol.first = 1LL * sol.first * aux.first % modulo;\n        }\n      }\n      if(i == from)\n        sol = {2, 0};\n      else {\n        sol = {sol.first, (sol.first + 2LL * sol.second) % modulo};\n      }\n      last = i;\n    }\n  }\n\n  if(last + 1 <= to) {\n    if(last == from - 1) { \n      sol = solve(last + 1, to, smin);\n      sol.first = sol.first * 2 % modulo;\n    } else {\n      std::pair<int,int> aux = solve(last + 1, to, smin);\n      sol.second = (1LL * sol.second * (2LL * aux.first + aux.second) + 1LL * sol.first * aux.second + 1LL * sol.first * aux.first) % modulo;\n      sol.first = 1LL * sol.first * aux.first % modulo;\n    }\n  }\n\n  sol.first = 1LL * sol.first * lgpow(2, smin - start - 1)% modulo;\n\n  return {sol.first, sol.second};\n}\n\nint main() {\n  int n;\n  std::cin >> n;\n  for(int i = 1;i <= n; i++)\n    std::cin >> v[i];\n  std::pair<int,int> sol = solve(1, n, 0);\n  std::cout << (sol.first + sol.second) % modulo;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <vector>\n#include <cassert>\n#include <fstream>\n#include <algorithm>\n#include <list>\n#include <random>\n#include <ctime>\n#include <cmath>\n#include <random>\n#include <bitset>\n#include <complex>\n#pragma unroll\n#pragma loop count N\n#pragma ivdep\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n//#define int ll\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef pair<ld, ld> pld;\ntypedef complex<double> base;\n\n#define mmin(a, b) a = min(a, (b))\n#define mmax(a, b) a = max(a, (b))\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define ALL(a) a.begin(),a.end()\n#define sqr(x) (x) * (x)\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define cint const int &\n#define SZ(a) ((int)(a.size()))\n#define f(cnt) (((cnt) + 1) * (cnt) / 2)\n#define watch(x) cout << (#x) << \" = \" << x << endl;\n\nconst double PI = 2 * acos(0.0);\n\ntemplate<class T>\nvoid show(const set<T> &a) {\n    for (T x : a)\n        cout << x << \" \";\n    cout << endl;\n}\n\ntemplate<class T>\nvoid show(const vector<T> &a) {\n    for (T x : a)\n        cout << x << \" \";\n    cout << endl;\n}\n\nconst ll M = 1e9 + 7;\n\nll MOD(ll a) {\n    if (a >= 0) return a >= M ? a % M : a;\n    if (a <= -M) a %= M;\n    return a ? a + M : a;\n}\n\nconst int N = 109;\nconst int L = 1e6 + 7;\n\nstruct edge {\n    int u, v;\n    ll height;\n    edge(int u, int v, ll height): u(u), v(v), height(height) {\n\n    }\n\n};\nvector<edge> e;\n\nll pw(ll a, ll p) {\n    if (p < 0) return pw(pw(a, -p), M - 2);\n    if (!p) return 1;\n    ll ret = pw(a, p >> 1);\n    ret = MOD(ret * ret);\n    if (p & 1) ret = MOD(ret * a);\n    return ret;\n}\n\nint counter = 1;\nvi g[L];\nll len[L];\nint vert[L];\nint start[L];\nll h[N];\nll dp[2][L];\n\ninline ll get_ways(int v) {\n    vvvl dp(N, vvl(2, vl(2, 0)));\n    vector<char> must(N, 0);\n    for (int id : g[v]) {\n        int to = e[id].v;\n        for (int i = 1; i < len[to]; ++i)\n            must[i + start[to]] = 1;\n    }\n    dp[start[v]][0][0] = dp[start[v]][0][1] = 1;\n    for (int i = 1; i < len[v]; ++i) {\n        int ind = i + start[v];\n        if (must[ind]) {\n            for (int z1 : {0, 1}) for (int z2 : {0, 1})\n                dp[ind][z1][z2] = dp[ind - 1][z1][!z2];\n        } else {\n            for (int z1 : {0, 1}) for (int z2 : {0, 1}) for (int z3 : {0, 1}) {\n                int nx = z1;\n                if (z2 != z3) nx = 1;\n                dp[ind][nx][z3] = MOD(dp[ind][nx][z3] + dp[ind - 1][z1][z2]);\n            }\n        }\n    }\n    ll ret = MOD(dp[start[v] + len[v] - 1][1][0] + dp[start[v] + len[v] - 1][1][1]);\n    return ret;\n}\n\nll dfs(int v) {\n    ll dp1 = 1; // wasn't any bad\n    ll dp2 = 0; /* was bad */;\n    ll restlen = len[v];\n    dp[0][v] = 1;\n    for (int id : g[v]) {\n        int to = e[id].v;\n        restlen -= len[to];\n        dfs(to);\n        ll curgood = MOD(pw(2, e[id].height - 1) * dp[0][to]);\n        dp[0][v] = MOD(dp[0][v] * curgood);\n        ll curbad = dp[1][to];\n        ll odp1 = dp1;\n        ll odp2 = dp2;\n        dp1 = MOD(odp1 * curgood * 2);\n        dp2 = MOD(odp2 * (curgood * 2 + curbad) + odp1 * curbad);\n    }\n    ll ways = get_ways(v);\n    dp[1][v] = MOD(dp2 * pw(2, restlen) + dp[0][v] * ways);\n    dp[0][v] = MOD(2 * dp[0][v]);\n}\n\nsigned main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n\n\n    int n;\n    cin >> n;\n    set<ll> hs;\n    fori (i, n) {\n        cin >> h[i];\n        hs.insert(h[i]);\n    }\n    ll prev = 0;\n    len[counter++] = n;\n    fori (i , n)\n        vert[i] = 1;\n    int curv = 0;\n    int par = 0;\n    for (auto hi : hs) {\n        int cnt = 0;\n        fori (i, n) {\n            if (h[i] >= hi) {\n                if (!cnt) {\n                    curv = counter++;\n                    start[curv] = i;\n                }\n                par = vert[i];\n                vert[i] = curv;\n                cnt++;\n            } else {\n                if (cnt >= 2) {\n                    len[curv] = cnt;\n                    g[par].pb(e.size());\n                    e.pb(edge(par, curv, hi - prev));\n                }\n                cnt = 0;\n            }\n        }\n        if (cnt >= 2) {\n            len[curv] = cnt;\n            g[par].pb(e.size());\n            e.pb(edge(par, curv, hi - prev));\n        }\n        prev = hi;\n    }\n    ll fre = 0;\n    fori (i, n) {\n        ll lf = 0, rf = 0;\n        if (i) lf = h[i - 1];\n        if (i != n - 1) rf = h[i + 1];\n        fre += max(0LL, h[i] - max(lf, rf));\n    }\n    dfs(2);\n    ll ans = MOD(dp[0][2] * pw(2, e[g[1][0]].height - 1) + dp[1][2]);\n    ans = MOD(ans * pw(2, fre));\n    cout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int Maxn=105,mod=1e9+7;\nint h[Maxn];\nint ksm(int x,int k){\n\tint ret=1,tmp=x;\n\twhile(k){\n\t\tif(k&1)ret=1ll*ret*tmp%mod;\n\t\ttmp=1ll*tmp*tmp%mod;k>>=1;\n\t}\n\treturn ret;\n}\npair<int,int>solve(int l,int r,int lim){\n\tint Min=*min_element(h+l,h+r+1);\n\tint cnt=count(h+l,h+r+1,Min);\n\tpair<int,int>ans=make_pair(1,1);\n\tif(cnt==r-l+1){\n\t\tans.first=ksm(2,Min-lim);\n\t\tans.second=(ans.first+ksm(2,cnt)-2)%mod;\n\t\treturn ans;\n\t}\n\tvector<pair<int,int>>vec;\n\tfor(int i=l;i<=r;i++){\n\t\tif(h[i]==Min)continue;\n\t\tint L=i;\n\t\twhile(i<=r&&h[i]>Min)i++;\n\t\tvec.emplace_back(solve(L,i-1,Min));\n\t}\n\tint f=1,g=1;\n\tfor(auto&i:vec){\n\t\tf=1ll*f*i.first%mod;\n\t\tg=1ll*g*(i.first+i.second)%mod;\n\t}\n\tans.second=(1ll*(g-1ll*ksm(2,vec.size())*f)%mod*ksm(2,cnt)+1ll*f*(ksm(2,vec.size()+cnt)-2))%mod;\n\tans.first=1ll*f*ksm(2,Min-lim)%mod;\n\tans.second=(ans.second+ans.first)%mod;\n\treturn ans;\n}\nint main(){\n\tint n;scanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&h[i]);\n\tcout<<solve(1,n,0).second<<\"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define For(i, j, k) for (int i = j; i <= k; i++)\n\nusing namespace std;\n\nconst int N = 110;\nconst int Mod = 1e9 + 7;\n\nint h[N], fa[N], n;\nint dp[N][2];\n\nint find(int x) {\n\treturn x == fa[x] ? x : fa[x] = find(fa[x]);\n}\n\nint Pow(int x, int e) {\n\tint ret = 1;\n\twhile (e) {\n\t\tif (e & 1) ret = 1ll * ret * x % Mod;\n\t\tx = 1ll * x * x % Mod;\n\t\te >>= 1;\n\t}\n\treturn ret;\n}\n\nint rk[N];\n\nbool cmp(int x, int y) {\n\treturn h[x] > h[y];\n}\n\nbool vis[N];\n\nint main() {\n\n\tscanf(\"%d\", &n);\n\tFor(i, 1, n) scanf(\"%d\", &h[i]), fa[i] = i, rk[i] = i;\n\tsort(rk + 1, rk + n + 1, cmp);\n\n\tFor(i, 1, n) {\n\t\tint x = rk[i], u = 0, v = 0;\n\t\tvis[x] = true;\n\t\tif (vis[x - 1]) u = find(x - 1), dp[u][0] = 1ll * dp[u][0] * Pow(2, h[u] - h[x]) % Mod, fa[u] = x;\n\t\tif (vis[x + 1]) v = find(x + 1), dp[v][0] = 1ll * dp[v][0] * Pow(2, h[v] - h[x]) % Mod, fa[v] = x;\n\t\tif (!u) u = v, v = 0;\n\n\t\tif (!u) {\n\t\t\tdp[x][0] = 1, dp[x][1] = 0;\n\t\t} else if (!v) {\n\t\t\tdp[x][0] = dp[u][0];\n\t\t\tdp[x][1] = (dp[u][1] * 2ll + dp[u][0] * 2ll) % Mod;\n\t\t} else {\n\t\t\tdp[x][0] = 1ll * dp[u][0] * dp[v][0] % Mod;\n\t\t\tdp[x][1] = 2ll * dp[u][1] * dp[v][1] % Mod;\n\t\t\tdp[x][1] = (dp[x][1] + 4ll * dp[u][0] * dp[v][1] + 4ll * dp[v][0] * dp[u][1]) % Mod;\n\t\t\tdp[x][1] = (dp[x][1] + 6ll * dp[u][0] * dp[v][0]) % Mod;\n\t\t}\n\t}\n\n\tint x = find(1);\n\tint ans = (dp[x][1] + 1ll * dp[x][0] * Pow(2, h[x])) % Mod;\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//problem:\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mk make_pair\n#define lob lower_bound\n#define upb upper_bound\n#define fst first\n#define scd second\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ninline int read(){\n\tint f=1,x=0;char ch=getchar();\n\twhile(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}\n\twhile(isdigit(ch)){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\ninline ll readll(){\n\tll f=1,x=0;char ch=getchar();\n\twhile(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}\n\twhile(isdigit(ch)){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nconst int MAXN=105,MOD=1e9+7;\ninline int pow_mod(int x,int i){int y=1;while(i){if(i&1)y=(ll)y*x%MOD;x=(ll)x*x%MOD;i>>=1;}return y;}\nint n,h[MAXN];\nvector<int>vec,w[MAXN];\nint solve1(int l,int r,int k,int low){\n\t//cout<<\"dp1 \"<<l<<\" \"<<r<<\" \"<<k<<endl;\n\tint mx=0,mn=2e9;\n\tfor(int i=l;i<=r;++i)mx=max(mx,h[i]),mn=min(mn,h[i]);\n\tif(mn>k)return solve1(l,r,mn,low);\n\tif(mx==k&&mx==mn)return pow_mod(2,vec[k]-low);\n\t\n\tint ans=1,st=lob(w[k].begin(),w[k].end(),l)-w[k].begin(),ed=lob(w[k].begin(),w[k].end(),r)-w[k].begin();\n\ted=min(ed,(int)w[k].size()-1);\n\tif(w[k][ed]>r)ed--;\n\tint lst=l,t=0;\n\t\n\tfor(int i=st;i<=ed;++i){\n\t\tassert(w[k][i]>=l&&w[k][i]<=r);\n\t\tt=1;\n\t\tif(lst<=w[k][i]-1)ans=(ll)ans*solve1(lst,w[k][i]-1,k+1,vec[k])%MOD;\n\t\tlst=w[k][i]+1;\n\t}\n\tif(lst<=r)ans=(ll)ans*solve1(lst,r,k+1,(!t)?low:vec[k])%MOD;\n\tif(t)ans=(ll)ans*pow_mod(2,vec[k]-low)%MOD;\n\treturn ans;\n}\nint solve2(int l,int r,int k,int low){\n\t//cout<<l<<\" \"<<r<<\" \"<<k<<endl;\n\tint mx=0,mn=2e9;\n\tfor(int i=l;i<=r;++i)mx=max(mx,h[i]),mn=min(mn,h[i]);\n\tif(mn>k)return solve2(l,r,mn,low);\n\tif(mx==k&&mx==mn)return (pow_mod(2,r-l+1)-2+pow_mod(2,vec[k]-low))%MOD;\n\t\n\tint st=lob(w[k].begin(),w[k].end(),l)-w[k].begin(),ed=lob(w[k].begin(),w[k].end(),r)-w[k].begin();\n\ted=min(ed,(int)w[k].size()-1);\n\tif(w[k][ed]>r)ed--;\n\tvector<int>dp1,dp2;\n\tint lst=l,t=0;\n\tfor(int i=st;i<=ed;++i){\n\t\tassert(w[k][i]>=l&&w[k][i]<=r);\n\t\tt++;\n\t\tif(lst<=w[k][i]-1)dp1.pb(solve1(lst,w[k][i]-1,k+1,vec[k])),dp2.pb(solve2(lst,w[k][i]-1,k+1,vec[k]));\n\t\tlst=w[k][i]+1;\n\t}\n\tif(lst<=r)dp1.pb(solve1(lst,r,k+1,(!t)?low:vec[k])),dp2.pb(solve2(lst,r,k+1,(!t)?low:vec[k]));\n\tint ans1=1,ans2=1;\n\tfor(int i=0;i<(int)dp1.size();++i)ans1=(ll)ans1*(dp1[i]+dp2[i])%MOD,ans2=(ll)ans2*dp1[i]%MOD;\n\tans1=(ll)ans1*pow_mod(2,t)%MOD;\n\tif(t)ans2=(ll)ans2*(pow_mod(2,vec[k]-low)-2)%MOD;\n\treturn (ans1+ans2)%MOD;\n}\nint main() {\n\tn=read();\n\tfor(int i=1;i<=n;++i)h[i]=read(),vec.pb(h[i]);\n\tvec.pb(0);\n\tsort(vec.begin(),vec.end());\n\tvec.erase(unique(vec.begin(),vec.end()),vec.end());\n\tfor(int i=1;i<=n;++i)h[i]=lob(vec.begin(),vec.end(),h[i])-vec.begin(),w[h[i]].pb(i);\n\tcout<<solve2(1,n,1,0)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\nusing namespace std;\nconst int N=110,Mo=1000000007;\nint f[N][N],a[N],v[N];\ninline int gi() {\n    int x=0,o=1;\n    char ch=getchar();\n    while(ch!='-'&&(ch<'0'||ch>'9')) ch=getchar();\n    if(ch=='-') o=-1,ch=getchar();\n    while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n    return x*o;\n}\ninline int Pow(int x,int y) {\n    int ret=1;\n    while(y) {\n\tif(y&1) ret=1LL*ret*x%Mo;\n\tx=1LL*x*x%Mo,y>>=1;\n    }\n    return ret;\n}\nint main() {\n    int n,k,ans=0;\n    cin>>n;\n    for(int i=1;i<=n;i++) a[i]=v[i]=gi();\n    sort(v+1,v+1+n);\n    k=unique(v+1,v+1+n)-v-1;\n    for(int i=1;i<=n;i++) a[i]=lower_bound(v+1,v+1+k,a[i])-v;\n    f[0][0]=1;\n    for(int i=1;i<=n;i++) {\n\tf[i][0]=2LL*f[i-1][0]%Mo;\n\tfor(int j=a[i]+1;j<=a[i-1];j++)\n\t    f[i][0]=(f[i][0]+2*f[i-1][j])%Mo;\n\tint t=(a[i]<=a[i-1]?1:Pow(2,v[a[i]]-v[a[i-1]]));\n\tfor(int j=min(a[i],a[i-1]);j;j--)\n\t    f[i][j]=1LL*t*f[i-1][j]%Mo;\n\tfor(int j=a[i-1]+1;j<=a[i];j++) {\n\t    int t=(j==1?Pow(2,v[j])-2:Pow(2,v[j]-v[j-1]+1)-2);\n\t    f[i][j]=(f[i][j]+1LL*f[i-1][0]*t%Mo*Pow(2,v[a[i]]-v[j]))%Mo;\n\t}\n    }\n    for(int i=0;i<=k;i++) ans=(ans+f[n][i])%Mo;\n    cout<<ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#define SF scanf\n#define PF printf\n#define MAXN 100010\n#define MOD 1000000007\nusing namespace std;\nint n,h[MAXN];\ntypedef long long ll;\nll dp[MAXN];\nll fsp(ll x,int y){\n\tll res=1;\n\twhile(y){\n\t\tif(y&1)\n\t\t\tres=res*x%MOD;\n\t\tx=x*x%MOD;\n\t\ty>>=1;\n\t}\n\treturn res;\n}\nint main(){\n\tSF(\"%d\",&n);\n\tdp[n+1]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tSF(\"%d\",&h[i]);\n\t\tif(h[i]==1){\n\t\t\th[i]--;\n\t\t\tdp[n+1]=dp[n+1]*2ll%MOD;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tif(h[i]>h[i-1]&&h[i]>h[i+1]){\n\t\t\tint h1=max(h[i-1],h[i+1]);\n\t\t\tdp[n+1]=dp[n+1]*fsp(2,h[i]-h1)%MOD;\n\t\t\th[i]=h1;\t\n\t\t}\n\tfor(int i=n;i>0;i--){\n\t\tif(h[i])\n\t\t\tdp[i]=dp[i+1]*2ll%MOD;\n\t\telse\n\t\t\tdp[i]=dp[i+1];\n\t\tint minh=h[i],q=i;\n\t\tfor(int j=i;h[j]==h[i];j++)\n\t\t\tif(h[j+1]>h[i]){\n\t\t\t\tq=j;\n\t\t\t\tminh++;\n\t\t\t}\n\t\tll res1=0;\n\t\tint end=h[i-1]+1,sumh=0;\n\t\t//PF(\"{%d %d}\\n\",minh,end);\n\t\tfor(int j=q+1;minh>end;j++){\n\t\t\tif(h[j]>h[j-1])\n\t\t\t\tsumh+=h[j]-h[j-1];\n\t\t\tif(h[j]<minh){\n\t\t\t\tint minh1=max(end,h[j]);\n\t\t\t\t//PF(\"{%d %d %d}\\n\",sumh+h[i]-minh,minh-minh1,-(minh==(h[i]+1)?0:1));\n\t\t\t\tif(minh==h[i]+1)\n\t\t\t\t\tres1+=dp[j]*(fsp(2,sumh+h[i]-minh+q-i+2)+fsp(2,sumh+h[i]-minh+2)*(fsp(2,minh-minh1-1)-1)%MOD)%MOD;\n\t\t\t\telse\n\t\t\t\t\tres1+=dp[j]*(fsp(2,sumh+h[i]-minh+1)*(fsp(2,minh-minh1)-1)%MOD)%MOD;\n\t\t\t\tres1%=MOD;\n\t\t\t\tminh=minh1;\n\t\t\t}\n\t\t}\n\t\tdp[i]+=res1;\n\t\tdp[i]%=MOD;\n\t\t//PF(\"{%lld}\\n\",dp[i]);\n\t}\n\tPF(\"%lld\",dp[1]);\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nint N;\nint H[105];\nll mo=1000000007;\n\nll modpow(ll a, ll n = mo-2) {\n\tll r=1;a%=mo;\n\twhile(n) r=r*((n%2)?a:1)%mo,a=a*a%mo,n>>=1;\n\treturn r;\n}\n\npair<ll,ll> hoge(int L,int R,int v) {\n\tll dp1=1,dp2=1;\n\tint i,j;\n\t\n\tif(L>R) return {0,0};\n\t\n\tint mi=1<<30;\n\tfor(i=L;i<=R;i++) mi=min(mi,H[i]);\n\tint W=R-L+1;\n\tfor(i=L;i<=R;i++) if(mi!=H[i]) W--;\n\t\n\tint pre=L-1;\n\tfor(i=L;i<=R;i++) {\n\t\tif(mi==H[i]) {\n\t\t\tauto r=hoge(pre+1,i-1,mi);\n\t\t\tif(r.first>0) {\n\t\t\t\t(dp1*=r.first)%=mo;\n\t\t\t\t(dp2*=r.first+r.second)%=mo;\n\t\t\t}\n\t\t\t\n\t\t\tpre=i;\n\t\t}\n\t}\n\tauto r=hoge(pre+1,R,mi);\n\tif(r.first > 0) {\n\t\t(dp1*=r.first)%=mo;\n\t\t(dp2*=r.first+r.second)%=mo;\n\t}\nj\n\t(dp2=dp2*modpow(2,W)+(modpow(2,mi-v)+mo-2)*dp1)%=mo;\n\t(dp1*=modpow(2,mi-v))%=mo;\n\t\n\treturn {dp1,dp2};\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tfor(i=1;i<=N;i++) cin>>H[i];\n\tcout<<hoge(1,N,0).second<<endl;\n}\n\nint main()\n{\n        solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\n#define ms(s, n) memset(s, n, sizeof(s))\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define FORd(i, a, b) for (int i = (a) - 1; i >= (b); --i)\n#define FORall(it, a) for (__typeof((a).begin()) it = (a).begin(); it != (a).end(); it++)\n#define sz(a) int((a).size())\n#define present(t, x) (t.find(x) != t.end())\n#define all(a) (a).begin(), (a).end()\n#define uni(a) (a).erase(unique(all(a)), (a).end())\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define fi first\n#define se second\n#define prec(n) fixed<<setprecision(n)\n#define bit(n, i) (((n) >> (i)) & 1)\n#define bitcount(n) __builtin_popcountll(n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pi;\ntypedef vector<int> vi;\ntypedef vector<pi> vii;\nconst int MOD = (int) 1e9 + 7;\nconst int FFTMOD = 1007681537;\nconst int INF = (int) 1e9;\nconst ll LINF = (ll) 1e18;\nconst ld PI = acos((ld) -1);\nconst ld EPS = 1e-9;\ninline ll gcd(ll a, ll b) {ll r; while (b) {r = a % b; a = b; b = r;} return a;}\ninline ll lcm(ll a, ll b) {return a / gcd(a, b) * b;}\ninline ll fpow(ll n, ll k, int p = MOD) {ll r = 1; for (; k; k >>= 1) {if (k & 1) r = r * n % p; n = n * n % p;} return r;}\ntemplate<class T> inline int chkmin(T& a, const T& val) {return val < a ? a = val, 1 : 0;}\ntemplate<class T> inline int chkmax(T& a, const T& val) {return a < val ? a = val, 1 : 0;}\ninline ll isqrt(ll k) {ll r = sqrt(k) + 1; while (r * r > k) r--; return r;}\ninline ll icbrt(ll k) {ll r = cbrt(k) + 1; while (r * r * r > k) r--; return r;}\ninline void addmod(int& a, int val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;}\ninline void submod(int& a, int val, int p = MOD) {if ((a = (a - val)) < 0) a += p;}\ninline int mult(int a, int b, int p = MOD) {return (ll) a * b % p;}\ninline int inv(int a, int p = MOD) {return fpow(a, p - 2, p);}\ninline int sign(ld x) {return x < -EPS ? -1 : x > +EPS;}\ninline int sign(ld x, ld y) {return sign(x - y);}\n#define db(x) cerr << #x << \" = \" << (x) << \" \";\n#define endln cerr << \"\\n\";\n\nconst int maxn = 100 + 5;\nint n;\nint a[maxn];\nvi dc;\nint dp[maxn][maxn];\n\nint calc(int pos, int k) {\n    if (pos == n) return 1;\n    int& res = dp[pos][k];\n    if (~res) return res;\n    res = 0;\n    if (a[pos + 1] <= a[pos]) {\n        int nk = k;\n        if (dc[k] > a[pos + 1]) {\n            nk = maxn - 1;\n        }\n        int coef = nk == maxn - 1 ? 2 : 1;\n        addmod(res, mult(coef, calc(pos + 1, nk)));\n    }\n    else {\n        if (k == maxn - 1) {\n            for (int i = 1; i < sz(dc); i++) {\n                int lo = max(!i ? 2 : dc[i - 1] + 1, a[pos] + 1);\n                int hi = min(dc[i], a[pos + 1]);\n                int nk = min(k, i);\n                if (lo <= hi) {\n                    int coef = fpow(2, hi - lo + 1);\n                    submod(coef, 1);\n                    coef = mult(coef, 2);\n                    if (a[pos + 1] >= hi) {\n                        coef = mult(coef, fpow(2, a[pos + 1] - hi));\n                    }\n                    addmod(res, mult(coef, calc(pos + 1, nk)));\n                }\n            }\n        }\n        int nk = k;\n        int coef = nk == maxn - 1 ? 2 : 1;\n        if (k < maxn - 1) {\n            coef = mult(coef, fpow(2, a[pos + 1] - a[pos]));\n        }\n        addmod(res, mult(coef, calc(pos + 1, nk)));\n    }\n    return res;\n}\n\nvoid chemthan() {\n    cin >> n;\n    a[0] = 1;\n    dc.pb(1);\n    FOR(i, 1, n + 1) cin >> a[i], dc.pb(a[i]);\n    sort(all(dc)), uni(dc);\n    ms(dp, -1);\n    cout << calc(0, maxn - 1) << \"\\n\";\n}\n\nint main(int argc, char* argv[]) {\n    ios_base::sync_with_stdio(0), cin.tie(0);\n    if (argc > 1) {\n        assert(freopen(argv[1], \"r\", stdin));\n    }\n    if (argc > 2) {\n        assert(freopen(argv[2], \"wb\", stdout));\n    }\n    chemthan();\n    cerr << \"\\nTime elapsed: \" << 1000 * clock() / CLOCKS_PER_SEC << \"ms\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <windows.h>\nusing namespace std;\ntypedef long long LL;\nconst int mod = 1e9 + 7, MAX = 110;\nint n, h[MAX], pw[MAX];\ninline int add(int a, int b) {\n\treturn a + b >= mod ? a + b - mod : a + b;\n}\ninline int sub(int a, int b) {\n\treturn a >= b ? a - b : a - b + mod;\n}\ninline int mul(int a, int b) {\n\treturn LL(a) * b % mod;\n}\nint pm(int a, LL b) {\n\tif (b == 0) return 1;\n\tif (b & 1) return mul(a, pm(a, b - 1));\n\treturn pm(mul(a, a), b / 2);\n}\npair<int, int> solve(int a, int b, int s) {\n\tif (b - a == 1) {\n\t\tint w = pm(2, h[a] - s);\n\t\treturn make_pair(w, w);\n\t}\n\tint m = *min_element(h + a, h + b);\n\tvector <pair<int, int> > v;\n\tint i = a;\n\twhile (i < b) {\n\t\tint j = i;\n    \twhile (j < b && (h[i] == m) == (h[j] == m))\n\t\t\tj ++;\n    \tv.push_back(make_pair(i, j));\n    \ti = j;\n\t} \n\tint fT = 1, fA = 2;\n  \tfor (int i = 0; i < v.size(); i ++) {\n\t\tpair<int, int> p = v[i];\n\t    int x = p.first, y = p.second;\n\t    if (h[x] != m) {\n\t    \tpair <int,int> g = solve(x, y, m);\n\t    \tfT = mul(fT, add(g.first, g.second));\n\t    \tfA = mul(fA, g.first);\n\t    } else {\n\t    \tfT = mul(fT, pw[y - x]);\n\t    }\n\t}\n\tfT = sub(fT, fA);\n\tfA = mul(fA, pm(2, m - s - 1));\n\tfT = add(fT, fA);\n\treturn make_pair(fA, fT);\n}\nint main(void) {\n\tcin >> n;\n\t//DWORD start_time = GetTickCount();\n\tfor (int i = 0; i < n; i ++)\n\t\tcin >> h[i];\n\tpw[0] = 1;\n\tfor (int i = 0; i < n; i ++)\n\t\tpw[i + 1] = mul(pw[i], 2);\n\tpair <int, int> g = solve(0, n, 0);\n\tcout << g.second << endl;\n\t//DWORD end_time = GetTickCount();\n\t//cout << \"Time costed : \" << (end_time - start_time)  << \".ms\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int mod=1e9+7;\ninline int add(int x,int y){\n\treturn (x+y)%mod;\n}\ninline int mul(int x,int y){\n\treturn (ll)x*y%mod;\n}\ninline int qpow(int base,int pw){\n\tif(pw<0) return 1;\n\tint res=1;\n\twhile(pw>0){\n\t\tif(pw&1) res=mul(res,base);\n\t\tbase=mul(base,base);\n\t\tpw>>=1;\n\t}\n\treturn res;\n}\nint h[110],dp[110][110];\nvector<int> hs;\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d\",h+i);\n\t\ths.push_back(h[i]);\n\t}\n\ths.push_back(0);\n\tsort(hs.begin(),hs.end());\n\ths.erase(unique(hs.begin(),hs.end()),hs.end());\n\tfor(int i=1;i<=n;i++)\n\t\th[i]=lower_bound(hs.begin(),hs.end(),h[i])-hs.begin();\n\tdp[0][0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=h[i]+1;j<=h[i-1];j++)\n\t\t\tdp[i][0]=add(dp[i][0],add(dp[i-1][j],dp[i-1][j]));\n\t\tdp[i][0]=add(dp[i][0],add(dp[i-1][0],dp[i-1][0]));\n\t\tfor(int j=1;j<=h[i];j++){\n\t\t\tdp[i][j]=mul(dp[i-1][j],qpow(2,hs[h[i]]-hs[h[i-1]]));\n\t\t\tif(h[i-1]>=j) continue;\n\t\t\tif(j>1) dp[i][j]=add(dp[i][j],mul(add(dp[i-1][0],dp[i-1][0]),mul(add(qpow(2,hs[j]-hs[j-1])-1,mod),qpow(2,hs[h[i]]-hs[j]))));\n\t\t\telse dp[i][j]=add(dp[i][j],mul(dp[i-1][0],mul(add(qpow(2,hs[j])-2,mod),qpow(2,hs[h[i]]-hs[j]))));\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=0;i<(int)hs.size();i++)\n\t\tans=add(ans,dp[n][i]);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nint MOD = 1000000007;\nint pw(int a, int b){\n    if (b == 0) return 1;\n    if (b == 1) return a;\n    if (b%2) return ((a * pw(a, b-1)) % MOD);\n    int rs = pw(a, b/2);\n    return (rs*rs) % MOD;\n}\npair<int, int> solve(vector<int> &v){\n    int n = v.size();\n    int mn = 1e12;\n    for (int i=0; i < n; i++) mn = min(mn, v[i]);\n    int holes = 0;\n    vector<pair<int, int> > ress;\n    vector<int> a, b;\n    for (int i=0; i < n; i++){\n        if (v[i] > mn) a.push_back(v[i] - mn);\n        else{\n            if (a.size() > 0){\n                ress.push_back(solve(a));\n                b.push_back(a.size());\n            }\n            a.clear();\n            holes++;\n        }\n    }\n    if (a.size() > 0){\n        ress.push_back(solve(a));\n        b.push_back(a.size());\n    }\n    int N = 2;\n    for (int i=0; i < ress.size(); i++) {\n        //cout << ress[i].first << \" \" << ress[i].second << endl;\n        N *= ress[i].second;\n        N %= MOD;\n    }\n    N %= MOD;\n    int on = N;\n    N *= pw(2, mn-1);\n    N %= MOD;\n    int R = pw(2, holes);\n    for (int i=0; i < ress.size(); i++){\n        int H = (ress[i].first + 2 * ress[i].second) % MOD;\n        R *= H;\n        R %= MOD;\n    }\n    R -= on;\n    R %= MOD;\n    if (R < 0) R += MOD;\n    return {R, N};\n}\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    int n;\n    cin >> n;\n    vector<int> v(n);\n    for (int i=0; i < n; i++){\n        cin >> v[i];\n    }\n    pair<int, int> p = solve(v);\n    //cout << p.first << \" \" << p.second << endl;\n    cout << (p.first + p.second) % MOD << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\n\nconst ll big = 1000000007;\nconst ll mod = 998244353;\n\nll n,m,k,T;\n\nvl A;\n\nll getv(ll i){\n    if(i == -1)return 0;\n    if(i == n)return 0;\n    assert(i >= 0 && i < n);\n    return A[i];\n}\n\nll upp(ll i, ll j){\n    if(j == 0)return 1;\n    ll h = upp(i,j/2);\n    if(j%2 == 0)return (h*h)%big;\n    return (((h*h)%big)*i)%big;\n}\n\nvl heights;\nset<ll> S;\n\nll upto(ll i, ll j){\n    if(j == 0){\n        return (upp(2,A[i])-2+big)%big;\n    }\n    return (upp(2,A[i]-heights[j]+1)-2+big)%big;\n}\n\nll horisontal(ll i, ll j){\n    if(heights[j] >= A[i])return 0;\n    ll d1 = A[i]-heights[j];\n    ll d2 = A[i]-heights[j+1];\n    return (upto(i,j)-upto(i,j+1)+big)%big;\n}\n\n\nunordered_map<ll,ll> M;\n\nll dp(ll i, ll horisont, bool vertical){\n    if(i == n)return 1;\n    ll h = 2ll*(i*ll(12345678911)+horisont) + vertical;\n    if(M.find(h) != M.end())return M[h];\n\n    ll ans = 0;\n    if(A[i] == 0){\n        return dp(i+1,0,1);\n    }\n    if(vertical){\n        ans += 2*dp(i+1,A[i],1);\n        if(A[i] > horisont){\n            for(int c1 = 0; c1 < sz(heights); c1++){\n                if(heights[c1] < horisont)continue;\n                ans += horisontal(i,c1)*dp(i+1,heights[c1],0);\n                ans %= big;\n            }\n        }\n    }\n    if(!vertical){\n        if(horisont >= A[i]){\n            ans = 2*dp(i+1,A[i],1);\n        }\n        else{\n            ll d = max(A[i]-getv(i-1),0ll);\n            ans = upp(2,d)*dp(i+1,horisont,0);\n        }\n    }\n\n    ans %= big;\n    M[h] = ans;\n    return ans;\n}\n\nint main(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    //freopen(\"input.txt\",\"r\",stdin);\n    //freopen(\"autput.txt\",\"w\",stdout);\n    ll a,b,c,d;\n    cin >> n;\n    ll ans = 1;\n    for(int c1 = 0; c1 < n; c1++){\n        cin >> a;\n        if(a == 1){\n            a = 0;\n            ans *= 2;\n            ans %= big;\n        }\n        A.push_back(a);\n    }\n\n    for(int c1 = 0; c1 < n; c1++){\n        d = max(A[c1] - max(getv(c1-1),getv(c1+1)),0ll);\n        ans *= upp(2,d);\n        ans %= big;\n        A[c1] -= d;\n    }\n    heights.push_back(0);\n    S.insert(0);\n    for(int c1 = 0; c1 < n; c1++){\n        if(S.find(A[c1]) == S.end()){\n            S.insert(A[c1]);\n            heights.push_back(A[c1]);\n        }\n    }\n    sort(all(heights));\n/*\n    cerr << \"h: \" << horisontal(1,0) << \" \" << horisontal(1,1) << \"\\n\";\n\n    cout << ans << \"\\n\";\n    for(int c1 = 0; c1 < n; c1++){\n        cout << A[c1] << \" \";\n    }cout << \"\\n\";\n    cerr << dp(5,0,1) << \"  jk\\n\";\n    */\n    ans *= dp(0,0,1);\n    cout << ans%big << \"\\n\";\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntemplate <int MOD_>\nstruct modnum {\n\tstatic constexpr int MOD = MOD_;\n\tstatic_assert(MOD_ > 0, \"MOD must be positive\");\n\nprivate:\n\tusing ll = long long;\n\n\tint v;\n\n\tstatic int minv(int a, int m) {\n\t\ta %= m;\n\t\tassert(a);\n\t\treturn a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);\n\t}\n\npublic:\n\n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int() const { return v; }\n\tfriend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n\tfriend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }\n\n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n\tmodnum inv() const {\n\t\tmodnum res;\n\t\tres.v = minv(v, MOD);\n\t\treturn res;\n\t}\n\tmodnum neg() const {\n\t\tmodnum res;\n\t\tres.v = v ? MOD-v : 0;\n\t\treturn res;\n\t}\n\n\tmodnum operator- () const {\n\t\treturn neg();\n\t}\n\tmodnum operator+ () const {\n\t\treturn modnum(*this);\n\t}\n\n\tmodnum& operator ++ () {\n\t\tv ++;\n\t\tif (v == MOD) v = 0;\n\t\treturn *this;\n\t}\n\tmodnum& operator -- () {\n\t\tif (v == 0) v = MOD;\n\t\tv --;\n\t\treturn *this;\n\t}\n\tmodnum& operator += (const modnum& o) {\n\t\tv += o.v;\n\t\tif (v >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tif (v < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= o.inv();\n\t}\n\n\tfriend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\n\tfriend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\nusing num = modnum<int(1e9) + 7>;\n\nconst int MAXV = 110;\nnum pow2[MAXV];\n\npair<num, num> go(vector<int> H) {\n\tint Hmin = *min_element(H.begin(), H.end());\n\tint num0 = 0;\n\tfor (int i = 0; i < int(H.size()); i++) {\n\t\tH[i] -= Hmin;\n\t\tif (H[i] == 0) num0++;\n\t}\n\n\tassert(num0 >= 1);\n\tnum p0 = 1;\n\tnum p1 = 1;\n\tint prv = 0;\n\tfor (int i = 0; i <= int(H.size()); i++) {\n\t\tif (i == int(H.size()) || H[i] == 0) {\n\t\t\tif (prv < i) {\n\t\t\t\tauto p = go(vector<int>(H.begin() + prv, H.begin() + i));\n\t\t\t\tp0 *= (p.first + p.second);\n\t\t\t\tp1 *= p.second;\n\t\t\t}\n\t\t\tprv = i+1;\n\t\t}\n\t}\n\tnum tot = pow2[num0] * p0 + (pow2[Hmin] - 2) * p1;\n\tnum alt = pow2[Hmin] * p1;\n\treturn {tot, alt};\n}\n\nint main() {\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tpow2[0] = 1;\n\tfor (int i = 1; i < MAXV; i++) {\n\t\tpow2[i] = pow2[i-1] * 2;\n\t}\n\n\tint N; cin >> N;\n\tvector<int> H(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> H[i];\n\t}\n\tauto ans = go(H);\n\tcout << ans.first << '\\n';\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <functional>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cstdlib>\n\nusing namespace std;\ntypedef long long llong;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<llong, llong> pll;\n\nint n, k;\nint hs[101];\nint cp[101];\nint dp[101][101];\n\nconst int mod = 1e9 + 7;\n\nvoid add(int &x, llong y) {\n    x += y % mod;\n    x %= mod;\n}\n\nint mul(int x, int y) {\n    return (llong)x * y % mod;\n}\n\nint pw(int x, int p) {\n    if (p == 0) return 1;\n    int ret = pw(x, p >> 1);\n    ret = mul(ret, ret);\n    if (p & 1) ret = mul(ret, x);\n    return ret;\n}\n\nint solve(int s, int e) {\n    dp[s - 1][0] = 1;\n    for (int i = s; i <= e; ++i) {\n        if (hs[i - 1] < hs[i]) {\n            dp[i][0] = dp[i - 1][0];\n            add(dp[i][0], dp[i][0]);\n            \n            for (int j = 1; j <= hs[i - 1]; ++j) {\n                dp[i][j] = mul(dp[i - 1][j], pw(2, cp[hs[i]] - cp[hs[i - 1]]));\n            }\n            for (int j = hs[i - 1] + 1; j <= hs[i]; ++j) {\n                dp[i][j] = mul(dp[i - 1][0], mul(pw(2, cp[j] - cp[j - 1]) - 1 - (j == 1 ? pw(2, cp[j] - 1) : 0), pw(2, cp[hs[i]] - cp[j] + 1)));\n            }\n        }\n        else {\n            dp[i][0] = dp[i - 1][0];\n            for (int j = hs[i] + 1; j < k; ++j) {\n                add(dp[i][0], dp[i - 1][j]);\n            }\n            add(dp[i][0], dp[i][0]);\n            for (int j = 1; j <= hs[i]; ++j) {\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n    int ret = 0;\n    for (int i = 0; i < k; ++i) {\n        add(ret, dp[e][i]);\n    }\n    return ret;\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    vector<int> one;\n    one.push_back(0);\n    for (int i = 1; i <= n; ++i) {\n        scanf(\"%d\", hs + i);\n        if (hs[i] == 1) hs[i] = 0, one.push_back(i);\n        cp[i] = hs[i];\n    }\n    one.push_back(n + 1);\n    sort(cp, cp + (n + 1));\n    k = unique(cp, cp + (n + 1)) - cp;\n    for (int i = 1; i <= n; ++i) {\n        hs[i] = lower_bound(cp, cp + k, hs[i]) - cp;\n    }\n    int ret = pw(2, one.size() - 2);\n    for (int i = 1; i < one.size(); ++i) {\n        ret = mul(ret, solve(one[i - 1] + 1, one[i] - 1));\n    }\n    printf(\"%d\\n\", ret);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fo(i, x, y) for(int i = x, B = y; i <= B; i ++)\n#define ff(i, x, y) for(int i = x, B = y; i <  B; i ++)\n#define fd(i, x, y) for(int i = x, B = y; i >= B; i --)\n#define ll long long\n#define pp printf\n#define hh pp(\"\\n\")\nusing namespace std;\n\nconst int N = 105;\n\nint n, a[N], b[N], m, na[N];\nmap<int, int> ba;\n\nconst int mo = 1e9 + 7;\n\nll ksm(ll x, ll y) {\n\tll s = 1;\n\tfor(; y; y /= 2, x = x * x % mo)\n\t\tif(y & 1) s = s * x % mo;\n\treturn s;\n}\n\nll qu(int x, int y) {\n\treturn (ksm(2, y + 1) - ksm(2, x) + mo) % mo;\n}\n\nll a2[N];\nll f[N][N];\n\nvoid add(ll &x, ll y) {\n\t(x += y) %= mo;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfo(i, 1, n) scanf(\"%d\", &a[i]), b[i] = a[i];\n\tsort(b + 1, b + n + 1);\n\tm = unique(b + 1, b + n + 1) - (b + 1);\n\tfo(i, 1, m) ba[b[i]] = i;\n\tfo(i, 1, n) na[i] = ba[a[i]];\n\tb[m + 1] = 2e9; f[0][m + 1] = 1;\n\tfo(i, 1, n) {\n\t\tfo(j, 1, m + 1) if(f[i - 1][j]) {\n\t\t\tif(a[i - 1] <= a[i]) {\n\t\t\t\tif(b[j] <= a[i]) {\n\t\t\t\t\tadd(f[i][j], f[i - 1][j] * ksm(2, a[i] - a[i - 1]));\n\t\t\t\t} else {\n\t\t\t\t\tfo(k, na[i - 1] + 1, na[i]) {\n\t\t\t\t\t\tint x = b[k - 1] + 1, y = b[k];\n\t\t\t\t\t\tif(x == 1) x ++;\n\t\t\t\t\t\tif(x <= y)\n\t\t\t\t\t\tadd(f[i][k], f[i - 1][j] * qu(a[i] - y + 1, a[i] - x + 1)) ;\n\t\t\t\t\t}\n\t\t\t\t\tadd(f[i][m + 1], f[i - 1][j] * 2);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif(b[j] <= a[i]) {\n\t\t\t\t\tadd(f[i][j], f[i - 1][j]);\n\t\t\t\t} else {\n\t\t\t\t\tadd(f[i][m + 1], f[i - 1][j] * 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll ans = 0;\n\tfo(j, 1, m + 1) ans = (ans + f[n][j]) % mo;\n\tpp(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef double D;\ntypedef long long int LL;\n\n#define st first\n#define nd second\n#define pb push_back\n#define PLL pair <LL, LL>\n#define PII pair <int, int>\n\nconst int N = 1e6 + 7;\nconst int MX = 1e9 + 7;\nconst LL INF = 1e18 + 9LL;\n\nint fast(int a, int b){\n\tint ret = 1;\n\twhile(b){\n\t\tif(b & 1)\n\t\t\tret = (1LL * ret * a)%MX;\n\t\t\n\t\ta = (1LL * a * a)%MX;\n\t\tb >>= 1;\n\t}\n\t\n\treturn ret;\n}\n\nPII solve(vector <int> h){\n\tif(h.size() == 0)\n\t\treturn {0, 0};\n\tif(h.size() == 1)\n\t\treturn {0, fast(2, h[0])};\n\n\tif(h.size() == 2)\n\t\treturn {2, fast(2, h[0])};\n\t\n\tint mn = 0;\n\tfor(int i = 1; i < (int)h.size(); ++i)\n\t\tif(h[i] < h[mn])\n\t\t\tmn = i;\n\t\n\tPII ret = {0, 0};\n\th.push_back(h[mn]);\n\tvector <int> cur; int cnt = 0;\n\tfor(int i = 0; i < (int)h.size(); ++i){\n\t\tif(h[i] == h[mn]){\n\t\t\tPII t = solve(cur);\n\t\t\tif((ret.st + ret.nd) == 0)\n\t\t\t\tret = t;\n\t\t\telse\n\t\t\t\tret = {(1LL * (ret.st + ret.nd) * (t.st + t.nd))%MX, (((1LL * ret.nd * t.nd)%MX) * fast(2, MX - 2))%MX};\n\n\t\t\tcur.clear();\n\t\t\t++cnt;\n\t\t}\n\t\telse\n\t\t\tcur.push_back(h[i] - h[mn]);\n\t}\n\t\n\t--cnt;\n\treturn {(1LL * (ret.st + 2LL * ret.nd) * fast(2, cnt) - 2LL * ret.nd)%MX, (1LL * fast(2, h[mn]) * ret.nd)%MX};\n}\n\nint main(){\n\tint n; scanf(\"%d\", &n);\n\tvector <int> v(n, 0);\n\t\n\tfor(int i = 0; i < n; ++i)\n\t\tscanf(\"%d\", &v[i]);\n\t\n\tLL res = 1LL;\n\tfor(int i = 0; i < n; ++i){\n\t\tint Left = i == 0 ? 0 : v[i - 1];\n\t\tint Right = i == n - 1 ? 0 : v[i + 1];\n\t\t\n\t\tif(Left < v[i] && Right < v[i]){\n\t\t\tres = (1LL * res * fast(2, v[i] - max(Left, Right)))%MX;\n\t\t\tv[i] = max(Left, Right);\n\t\t}\n\t}\n\n\tPII ret = solve(v);\n\tprintf(\"%d\\n\", (1LL * res * (ret.st + ret.nd))%MX);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#define ll long long\n#define inf 0x3f3f3f3f\n#define mod 1000000007\n#define maxn 200010\ninline ll read()\n{\n\tll x=0; char c=getchar(),f=1;\n\tfor(;c<'0'||'9'<c;c=getchar())if(c=='-')f=-1;\n\tfor(;'0'<=c&&c<='9';c=getchar())x=x*10+c-'0';\n\treturn x*f;\n}\ninline void write(ll x)\n{\n\tstatic char buf[20];\n\tint len=0;\n\tif(x<0)putchar('-'),x=-x;\n\tfor(;x;x/=10)buf[len++]=x%10+'0';\n\tif(!len)putchar('0');\n\telse while(len)putchar(buf[--len]);\n}\ninline void writesp(ll x){write(x); putchar(' ');}\ninline void writeln(ll x){write(x); putchar('\\n');}\nint a[maxn];\nint n;\nll power(ll a,ll b)\n{\n\tll ans=1;\n\tfor(;b;b>>=1,a=a*a%mod)\n\t\tif(b&1)ans=ans*a%mod;\n\treturn ans;\n}\nvoid solve(int l,int r,ll& f,ll& g)\n{\n\tint mn=a[l],mx=a[l];\n\tfor(int i=l+1;i<=r;i++){\n\t\tmx=std::max(mx,a[i]);\n\t\tmn=std::min(mn,a[i]);\n\t}\n\tfor(int i=l;i<=r;i++)\n\t\ta[i]-=mn;\n\tif(mx==mn){\n\t\tf=(power(2,r-l+1)+mod-2)%mod;\n\t\tg=power(2,mn);\n\t\treturn;\n\t}\n\tll mul1=1,mul2=1;\n\tint last=l,cnt=0;\n\tfor(int i=l;i<=r;i++)\n\t\tif(a[i]&&(!a[i+1]||i==r)){\n\t\t\tll tf=0,tg=0;\n\t\t\tsolve(last,i,tf,tg);\n\t\t\tmul1=mul1*(tf+2*tg)%mod;\n\t\t\tmul2=mul2*tg%mod;\n\t\t}\n\t\telse if(!a[i]){\n\t\t\tlast=i+1;\n\t\t\t++cnt;\n\t\t}\n\tf=(power(2,cnt)*mul1-2*mul2+2*mod)%mod;\n\tg=power(2,mn)*mul2%mod;\n}\nint main()\n{\n\tn=read();\n\tfor(int i=1;i<=n;i++)\n\t\ta[i]=read();\n\tll f=0,g=0;\n\tsolve(1,n,f,g);\n\twriteln((f+g)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <utility>\n\nusing namespace std;\n\n#define fi first\n#define se second\n#define long long long\ntypedef pair<int,int> ii;\ntypedef pair<long,ii> lii;\n\nconst long MOD = 1e9+7;\nlong p2(long b)\n{\n\tif(b == 0) return 1;\n\telse if(b == 2) return 4;\n\telse if(b&1) return (p2(b-1)*2)%MOD;\n\telse\n\t{\n\t\tlong temp = p2(b/2);\n\t\treturn (temp*temp)%MOD;\n\t}\n}\nlong geo(long a, long n)\n{\n\treturn (a*(p2(n)-1))%MOD;\n}\n\nvector<lii> vec;\nlong arr[100003];\n\nint main()\n{\n\t//ios_base::sync_with_stdio(); cin.tie(0); cout.tie(0);\n\t// freopen(\"input.in\", \"r\", stdin);\n\t\n\tint n; scanf(\"%d\", &n);\t\n\tfor(int i = 1; i <= n; i++)\n\t\tscanf(\"%lld\", &arr[i]);\n\tlong hit = 0;\n\tlong res = 1;\n\tlong bed = 1;\n\tfor(int i = 1; i <= n+1; i++)\n\t{\n\t\tif(arr[i] == 1 || i == n+1)\n\t\t{\n\t\t\tlong cnt = 0;\n\t\t\tcnt += bed;\n\t\t\tfor(auto j : vec)\n\t\t\t{\n\t\t\t\tcnt += geo(j.fi,j.se.fi-j.se.se+1);\n\t\t\t\tcnt %= MOD;\n\t\t\t}\n\t\t\t// printf(\"i : %d\\n\" , i);\n\t\t\t// printf(\"\tBED : %lld\\n\", bed);\n\t\t\t// printf(\"\tCNT : %lld\\n\", cnt);\n\t\t\tif(arr[i] == 1) hit++;\n\t\t\tvec.clear();\n\t\t\tbed = 1;\n\t\t\tres *= cnt;\n\t\t\tres %= MOD;\n\n\t\t}\n\t\telse if(vec.size() == 0)\n\t\t{\n\t\t\tvec.push_back({2,{arr[i],2}});\n\t\t\tbed *= 2;\n\t\t}\n\t\telse if(arr[i] > arr[i-1])\n\t\t{\n\t\t\tfor(int j = 0; j < vec.size(); j++)\n\t\t\t{\n\t\t\t\tvec[j].fi *= p2(arr[i]-arr[i-1]);\n\t\t\t\tvec[j].fi %= MOD;\n\t\t\t}\n\t\t\tbed *= 2; bed %= MOD;\n\t\t\tvec.push_back({bed,{arr[i], arr[i-1]+1}});\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvector<lii> temp;\n\t\t\tbed *= 2; bed %= MOD;\n\t\t\tfor(int j = 0; j < vec.size(); j++)\n\t\t\t{\n\t\t\t\tif(vec[j].se.fi > arr[i])\n\t\t\t\t{\n\t\t\t\t\tif(vec[j].se.se > arr[i])\n\t\t\t\t\t{\n\t\t\t\t\t\tbed += 2*geo(vec[j].fi,vec[j].se.fi-vec[j].se.se+1);\n\t\t\t\t\t\tbed %= MOD;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tbed += 2*geo(vec[j].fi, vec[j].se.fi-arr[i]);\n\t\t\t\t\t\tbed %= MOD;\n\t\t\t\t\t\ttemp.push_back({(vec[j].fi*p2(vec[j].se.fi-arr[i]))%MOD,{arr[i],vec[j].se.se}});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\ttemp.push_back(vec[j]);\n\t\t\t}\n\t\t\tvec = temp;\n\t\t}\n\t}\n\tres *= p2(hit);\n\tres %= MOD;\n\t// printf(\"%lld\\n\", p2(1000000000));\n\tprintf(\"%lld\\n\", res);\n}\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i, j, k) for(int i=(j); i<=(k); i++)\n#define FFOR(i, j, k) for(int i=(j); i<(k); i++)\n#define DFOR(i, j, k) for(int i=(j); i>=(k); i--)\n#define bug(x) cerr<<#x<<\" = \"<<(x)<<'\\n'\n#define pb push_back\n#define mp make_pair\n#define bit(s, i) (((s)>>(i))&1LL)\n#define mask(i) ((1LL<<(i)))\n#define builtin_popcount __builtin_popcountll\n#define __builtin_popcount __builtin_popcountll\nusing ll=long long; using ld=long double;\nmt19937_64 rng(chrono::high_resolution_clock::now().time_since_epoch().count()); const ld pi=acos(0)*2;\ntemplate <typename T> inline void read(T &x){char c; bool nega=0; while((!isdigit(c=getchar()))&&(c!='-')); if(c=='-'){nega=1; c=getchar();} x=c-48; while(isdigit(c=getchar())) x=x*10+c-48; if(nega) x=-x;}\ntemplate <typename T> inline void writep(T x){if(x>9) writep(x/10); putchar(x%10+48);}\ntemplate <typename T> inline void write(T x){if(x<0){ putchar('-'); x=-x;} writep(x);}\ntemplate <typename T> inline void writeln(T x){write(x); putchar('\\n');}\ntemplate <typename CT, typename T> inline void reset_container(CT &c, int sz, T v){c.resize(sz); for(auto &x: c) x=v;}\n#define taskname \"agc026_d\"\nint n;\nint h[101];\nconst ll base=1000000007;\nll power(ll a, ll b){\n    if(b==0) return 1;\n    ll t=power(a, b/2);\n    t=(t*t)%base;\n    if(b%2) t=(t*a)%base;\n    return t;\n}\nint minpos[101][101];\nbool doneg[101][101][101];\nll g[101][101][101];\nll G(int l, int r, int low){\n    if(l>r) return 1;\n    ///calculate from l to r, above low\n    if(doneg[l][r][low]) return g[l][r][low];\n    doneg[l][r][low]=1;\n    int x=minpos[l][r];\n    return g[l][r][low]=((G(l, x-1, (h[x]>h[low])?x:low)*G(x+1, r, (h[x]>h[low])?x:low))%base*power(2, max(0, h[x]-h[low])))%base;\n}\nbool done[101][101];\nll f[101][101];\nll F(int l, int low){\n    if(done[l][low]) return f[l][low];\n    done[l][low]=1;\n    int aff[101];\n    aff[l]=low;\n    FOR(i, l+1, n) aff[i]=(h[i]<h[aff[i-1]])?i:aff[i-1];\n    FOR(i, l+1, n){\n        int aff2[101];\n        ll cnt=1;\n        FOR(x, l, i) aff2[x]=aff[x];\n        int now=i;\n        DFOR(j, i, l){\n            if(h[j]<h[now]) now=j;\n            if(h[aff2[j]]<h[now]) aff2[j]=now;\n        }\n        FOR(j, l, i){\n            int k=j;\n            while((k<i-1)&&(aff2[k+1]==aff2[j])) k++;\n            cnt=(cnt*G(j, k, aff2[j]))%base;\n            j=k;\n        }\n        if(h[i]>h[i-1]){\n            f[l][low]+=(cnt*F(i, i-1))%base;\n        }\n        else{\n            f[l][low]+=(cnt*F(i, i))%base;\n        }\n    }\n    ll cnt=1;\n    FOR(j, l, n){\n        int k=j;\n        while((k<n)&&(aff[k+1]==aff[j])) k++;\n        cnt=(cnt*G(j, k, aff[j]))%base;\n        j=k;\n    }\n    f[l][low]+=cnt;\n    f[l][low]%=base;\n    return f[l][low];\n}\nint main(){\n    #ifdef Aria\n        if(fopen(taskname\".in\", \"r\"))\n            freopen(taskname\".in\", \"r\", stdin);\n    #endif // Aria\n    read(n);\n    FOR(i, 1, n) read(h[i]);\n    FOR(l, 1, n) FOR(r, l, n) minpos[l][r]=min_element(h+l, h+r+1)-h;\n    h[0]=1;\n    writeln((F(1, 0)*2)%base);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n// #define int long long\n// #define double long double\n#define rep(i,n) for (int i=0; i<(int)(n); ++i)\n#define rep1(i,n) for (int i=1; i<(int)(n); ++i)\n#define repeq(i,n) for (int i=0; i<=(int)(n); ++i)\n#define rep1eq(i,n) for (int i=1; i<=(int)(n); ++i)\n#define rrep(i,n) for (int i=(int)(n)-1; i>=0; --i)\n#define rrep1(i,n) for (int i=(int)(n)-1; i>0; --i)\n#define rrepeq(i,n) for (int i=(int)(n); i>=0; --i)\n#define rrep1eq(i,n) for (int i=(int)(n); i>0; --i)\n#define REP(i,a,b) for (int i=(int)(a); i<=(int)(b); ++i)\n#define RREP(i,a,b) for (int i=(int)(a); i>=(int)(b); --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vb = vector<bool>;\ntemplate<typename T> using Graph = vector<vector<T>>;\ntemplate<typename T> using Spacial = vector<vector<vector<T>>>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nconst int MOD = 1e9+7;\nconst int MOD2 = 998244353;\n// const double EPS = 1e-9;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nstring interval[2] = {\" \", \"\\n\"}; // {\" \", \"\\n\"}\n\ntemplate<typename T> struct is_plural : false_type{};\ntemplate<typename T1, typename T2> struct is_plural<pair<T1, T2>> : true_type{};\ntemplate<typename T> struct is_plural<vector<T>> : true_type{};\ntemplate<typename T> struct is_plural<complex<T>> : true_type{};\n \ntemplate<typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { return is >> p.first >> p.second; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) { return os << p.first << \" \" << p.second; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec) { for (auto itr = vec.begin(); itr != vec.end(); ++itr) is >> *itr; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec) { if (vec.empty()) return os; bool pl = is_plural<T>(); os << vec.front(); for (auto itr = ++vec.begin(); itr != vec.end(); ++itr) os << interval[pl] << *itr; return os; }\n \nbool CoutYN(bool a, string y = \"Yes\", string n = \"No\") { cout << (a ? y : n) << \"\\n\"; return a; }\n\ntemplate<typename T1, typename T2> inline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\ntemplate<typename T1, typename T2> inline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\nlong long modpow(int a, long long n, int mod = MOD) { long long ret = 1; do { if (n & 1) ret = ret * a % mod; a = 1LL * a * a % mod; } while (n >>= 1); return ret; }\n\ntemplate<typename T> T GCD(T a, T b) { return b ? GCD(b, a%b) : a; }\ntemplate<typename T> T LCM(T a, T b) { return a / GCD(a, b) * b; }\n\ntemplate<typename T1, typename T2> bool CompareBySecond(pair<T1, T2> a, pair<T1, T2> b) { return a.second != b.second ? a.second < b.second : a.first < b.first; }\ntemplate<typename T1, typename T2> bool CompareByInverse(pair<T1, T2> a, pair<T1, T2> b) { return a.first != b.first ? a.first < b.first : a.second > b.second; }\n\n\n/* -------- <templates end> -------- */\n\n\ntemplate<uint_fast64_t Modulus = MOD>\nstruct Modint {\n  using u64 = uint_fast64_t;\n  u64 a;\n\n  constexpr Modint(const u64 x = 0) noexcept : a(x % Modulus) {}\n\n  constexpr Modint operator+(const Modint rhs) const noexcept {\n    return Modint(*this) += rhs;\n  }\n  constexpr Modint operator-(const Modint rhs) const noexcept {\n    return Modint(*this) -= rhs;\n  }\n  constexpr Modint operator*(const Modint rhs) const noexcept {\n    return Modint(*this) *= rhs;\n  }\n  constexpr Modint operator/(const Modint rhs) const noexcept {\n    return Modint(*this) /= rhs;\n  }\n\n  constexpr Modint &operator+=(const Modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) a -= Modulus;\n    return *this;\n  }\n  constexpr Modint &operator-=(const Modint rhs) noexcept {\n    if (a < rhs.a) a += Modulus;\n    a -= rhs.a;\n    return *this;\n  }\n  constexpr Modint &operator*=(const Modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  constexpr Modint &operator/=(Modint rhs) noexcept {\n    u64 exp = Modulus - 2;\n    while (exp) {\n      if (exp & 1) *this *= rhs;\n      rhs *= rhs;\n      exp >>= 1;\n    }\n    return *this;\n  }\n\n  Modint pow(u64 t) const {\n    if (!t) return 1;\n    Modint x = pow(t>>1);\n    x *= x;\n    if (t&1) x *= *this;\n    return x;\n  }\n\n  explicit operator bool() const {\n    return a;\n  }\n\n  friend ostream &operator<<(ostream &os, const Modint &m) {\n    return os << m.a;\n  }\n};\n\nusing mint = Modint<>;\n\nstruct rect {\n  int l, r, h, dec;\n\n  rect(int l, int r, int h) : l(l), r(r), h(h), dec(0) {}\n};\n\nvoid solve() {\n  int n; cin >> n;\n  vi h(n); cin >> h;\n\n  Graph<int> tree(n);\n\n  vector<rect> vec;\n  vec.emplace_back(0, n-1, 0);\n  queue<int> q;\n  q.emplace(0);\n\n  while (!q.empty()) {\n    int v = q.front(); q.pop();\n    int MIN = 1<<30;\n    vi pos;\n\n    REP(i,vec[v].l,vec[v].r) {\n      if (chmin(MIN, h[i])) pos.clear();\n      if (h[i] == MIN) pos.emplace_back(i);\n    }\n\n    vec[v].h = MIN - vec[v].h;\n    vec[v].dec = pos.size();\n\n    pos.emplace_back(vec[v].r + 1);\n    int prev = vec[v].l - 1;\n    for (auto &k : pos) {\n      if (k - prev > 1) {\n        tree[v].emplace_back(vec.size());\n        q.emplace(vec.size());\n        vec.emplace_back(prev + 1, k - 1, MIN);\n      }\n      prev = k;\n    }\n  }\n\n  const mint two = 2;\n\n  function<pair<mint, mint>(int)> dfs = [&](int v) {\n    mint flip = 1, all = 1;\n    for (auto &nv : tree[v]) {\n      mint f, c;\n      tie(f, c) = dfs(nv);\n      flip *= f;\n      all *= f * 2 + c;\n    }\n    return make_pair(flip * two.pow(vec[v].h), all * two.pow(vec[v].dec) - flip * 2);\n  };\n\n  auto ans = dfs(0);\n  cout << ans.first + ans.second << endl;\n}\n\n\n/* -------- <programs end> -------- */\n\n\nsigned main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "asf"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <vector>\n#include <cassert>\n#include <fstream>\n#include <algorithm>\n#include <list>\n#include <random>\n#include <ctime>\n#include <cmath>\n#include <random>\n#include <bitset>\n#include <complex>\n#pragma unroll\n#pragma loop count N\n#pragma ivdep\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n#define int ll\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef pair<ld, ld> pld;\ntypedef complex<double> base;\n\n#define mmin(a, b) a = min(a, (b))\n#define mmax(a, b) a = max(a, (b))\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define ALL(a) a.begin(),a.end()\n#define sqr(x) (x) * (x)\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define cint const int &\n#define SZ(a) ((int)(a.size()))\n#define f(cnt) (((cnt) + 1) * (cnt) / 2)\n#define watch(x) cout << (#x) << \" = \" << x << endl;\n\nconst double PI = 2 * acos(0.0);\n\ntemplate<class T>\nvoid show(const set<T> &a) {\n    for (T x : a)\n        cout << x << \" \";\n    cout << endl;\n}\n\ntemplate<class T>\nvoid show(const vector<T> &a) {\n    for (T x : a)\n        cout << x << \" \";\n    cout << endl;\n}\n\nconst ll M = 1e9 + 7;\n\nll MOD(ll a) {\n    if (a >= 0) return a >= M ? a % M : a;\n    if (a <= -M) a %= M;\n    return a ? a + M : a;\n}\n\nconst int N = 109;\nconst int L = 1e6 + 7;\n\nstruct edge {\n    int u, v;\n    ll height;\n    edge(int u, int v, ll height): u(u), v(v), height(height) {\n\n    }\n\n};\nvector<edge> e;\n\nll pw(ll a, ll p) {\n    if (p < 0LL) return pw(pw(a, -p), M - 2);\n    if (!p) return 1;\n    ll ret = pw(a, p >> 1LL);\n    ret = MOD(ret * ret);\n    if (p & 1LL) ret = MOD(ret * a);\n    return ret;\n}\n\nint counter = 1;\nvi g[L];\nll len[L];\nint vert[L];\nint start[L];\nll h[N];\nll dp[2][L];\n\ninline ll get_ways(int v) {\n    vvvl dp(N, vvl(2, vl(2, 0)));\n    vector<char> must(N, 0);\n    for (int id : g[v]) {\n        int to = e[id].v;\n        for (int i = 1; i < len[to]; ++i)\n            must[i + start[to]] = 1;\n    }\n    dp[start[v]][0][0] = dp[start[v]][0][1] = 1;\n    for (int i = 1; i < len[v]; ++i) {\n        int ind = i + start[v];\n        if (must[ind]) {\n            for (int z1 : {0, 1}) for (int z2 : {0, 1})\n                dp[ind][z1][z2] = dp[ind - 1][z1][!z2];\n        } else {\n            for (int z1 : {0, 1}) for (int z2 : {0, 1}) for (int z3 : {0, 1}) {\n                int nx = z1;\n                if (z2 != z3) nx = 1;\n                dp[ind][nx][z3] = MOD(dp[ind][nx][z3] + dp[ind - 1][z1][z2]);\n            }\n        }\n    }\n    ll ret = MOD(dp[start[v] + len[v] - 1][1][0] + dp[start[v] + len[v] - 1][1][1]);\n    return ret;\n}\n\nll dfs(int v) {\n    ll dp0 = 1;\n    ll dp1 = 1;\n    ll dp2 = 0;\n    ll restlen = len[v];\n    for (int id : g[v]) {\n        int to = e[id].v;\n        dfs(to);\n        restlen -= len[to];\n        ll curgood = MOD(pw(2, e[id].height - 1) * dp[0][to]);\n        ll curbad = dp[1][to];\n        dp2 = MOD(dp2 * (curgood * 2 + curbad) + dp1 * curbad);\n        dp1 = MOD(dp1 * curgood * 2);\n        dp0 = MOD(dp0 * curgood);\n    }\n    dp[1][v] = MOD(dp2 * pw(2, restlen) + dp0 * get_ways(v));\n    dp[0][v] = MOD(2 * dp0);\n}\n\nsigned main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n\n    int n;\n    cin >> n;\n    set<ll> hs;\n    fori (i, n) {\n        cin >> h[i];\n        hs.insert(h[i]);\n    }\n    ll prev = 0;\n    len[counter++] = n;\n    fori (i , n)\n        vert[i] = 1;\n    int curv = 0;\n    int par = 0;\n    for (auto hi : hs) {\n        int cnt = 0;\n        fori (i, n) {\n            if (h[i] >= hi) {\n                if (!cnt) {\n                    curv = counter++;\n                    start[curv] = i;\n                    par = vert[i];\n                }\n                vert[i] = curv;\n                cnt++;\n            } else {\n                if (cnt >= 2) {\n                    len[curv] = cnt;\n                    g[par].pb(SZ(e));\n                    e.pb(edge(par, curv, hi - prev));\n                }\n                cnt = 0;\n            }\n        }\n        if (cnt >= 2) {\n            len[curv] = cnt;\n            g[par].pb(SZ(e));\n            e.pb(edge(par, curv, hi - prev));\n        }\n        prev = hi;\n    }\n    if (counter < 3) {\n        while (1) {\n            int a= 1;\n        }\n    }\n    ll fre = 0;\n    fori (i, n) {\n        ll neib = 0;\n        if (i) mmax(neib, h[i - 1]);\n        if (i != n - 1) mmax(neib, h[i + 1]);\n        fre += max(0LL, h[i] - neib);\n    }\n    dfs(2);\n    ll ans = MOD(dp[0][2] * pw(2, e[g[1][0]].height - 1) + dp[1][2]);\n    ans = MOD(ans * pw(2, fre));\n    cout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define db double\n#define pint pair<int,int>\n#define mk(x,y) make_pair(x,y)\n#define fir first\n#define sec second\n#define Rep(x,y,z) for(int x=y;x<=z;x++)\n#define Red(x,y,z) for(int x=y;x>=z;x--)\nusing namespace std;\nconst int MAXN=105,Mod=1e9+7;\nchar buf[1<<12],*p1=buf,*p2=buf,nc;int ny;\ninline char gc() {return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<12,stdin),p1==p2)?EOF:*p1++;}\n//inline char gc(){return getchar();}\ninline int read(){\n\tint x=0;for(ny=1;nc=gc(),(nc<48||nc>57)&&nc!=EOF;)if(nc==45)ny=-1;if(nc<0)return nc;\n\tfor(x=nc-48;nc=gc(),47<nc&&nc<58&&nc!=EOF;x=(x<<3)+(x<<1)+(nc^48));return x*ny;\n}inline int Fp(int x,int k){int ans=1;for(;k;k>>=1,x=1ll*x*x%Mod)if(k&1)ans=1ll*ans*x%Mod;return ans;}\nint sz[MAXN],len[MAXN],f[MAXN],g[MAXN],num[MAXN],stk[MAXN],id[MAXN],n,ans=1;\nvector<int>G[MAXN];\nvoid dfs(int x){\n\tint ans=1,s=sz[x];f[x]=1,g[x]=0;\n\tfor(int i=0,len=G[x].size(),y;i<len;i++){\n\t\tdfs(y=G[x][i]),g[x]=(1ll*g[x]*(f[y]+g[y])+1ll*f[x]*g[y])%Mod,f[x]=1ll*f[x]*f[y]%Mod,s-=sz[y];\n\t}g[x]=(1ll*g[x]*Fp(2,s)%Mod+1ll*f[x]*(Fp(2,s)-1))%Mod,f[x]=1ll*f[x]*Fp(2,len[x])%Mod;\n}\ninline int Solve(int l,int r){\n\tint cnt=0,top=0;stk[0]=l-1;\n\tRep(i,l,r){\n\t\twhile(top&&num[stk[top]]>=num[i])\n\t\t\tif(num[stk[top]]==num[i]){stk[top]=i;break;}\n\t\t\telse if(num[i]>num[stk[top-1]]){\n\t\t\t\tint v=++cnt;G[v].clear(),G[v].push_back(id[top]),len[id[top]]=num[stk[top]]-num[i];\n\t\t\t\tsz[id[top]]=i-stk[top-1]-2,stk[top]=i,id[top]=v;break;\n\t\t\t}else len[id[top]]=num[stk[top]]-num[stk[top-1]],sz[id[top]]=i-stk[top-1]-2,G[id[top-1]].push_back(id[top]),top--;\n\t\tif(stk[top]!=i){int v=++cnt;stk[++top]=i,id[top]=v,G[v].clear();}\n\t}while(top){\n\t\tlen[id[top]]=num[stk[top]]-num[stk[top-1]],sz[id[top]]=r-stk[top-1]-1;\n\t\tif(top>1)G[id[top-1]].push_back(id[top]);top--;\n\t}dfs(id[1]);return (f[id[1]]+g[id[1]])%Mod;\n}\nint main(){\n\tn=read();\n\tRep(i,1,n)num[i]=read()-1;\n\tRep(i,1,n){\n\t\tif(!num[i]||!num[i-1])ans=ans*2%Mod;\n\t\tif(num[i]&&!num[i+1]){\n\t\t\tint l=i;for(;num[l-1];l--);\n\t\t\tans=1ll*ans*Solve(l,i)%Mod;\n\t\t}\n\t}cout<<ans<<'\\n';\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\nconst int N=100,mod=1e9+7;\nint n,h[N+1];\nint f[N+1][N+1];\nint pow(int x,int times)\n{\n\tint ret=1;\n\twhile(times) {\n\t\tif(times&1) {\n\t\t\tret=1ll*ret*x%mod;\n\t\t}\n\t\ttimes>>=1,x=1ll*x*x%mod;\n\t}\n\treturn ret;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i) {\n\t\tscanf(\"%d\",&h[i]);\n\t}\n\th[0]=1,f[0][0]=1;\n\tfor(int i=1;i<=n;++i) {\n\t\tfor(int j=0;j<=n;++j) {\n\t\t\tif(h[j]>h[i]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(h[j]<h[i-1]) {\n\t\t\t\tif(h[i]<h[i-1]) {\n\t\t\t\t\tf[i][j]=(f[i-1][j]+f[i-1][i])%mod;\n\t\t\t\t} else {\n\t\t\t\t\tf[i][j]=1ll*(f[i-1][j]+f[i-1][i-1])*pow(2,h[i]-h[i-1])%mod;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tf[i][j]=2ll*f[i-1][i-1]*pow(2,h[i]-h[j])%mod;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",f[n][0]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int mod=1e9+7;\ninline int addmod(int x)\n{\n\treturn x>=mod?x-mod:x;\n}\ninline int submod(int x)\n{\n\treturn x<0?x+mod:x;\n}\nint fpow(int x,int y)\n{\n\tint ans=1;\n\twhile(y)\n\t{\n\t\tif(y&1) ans=1ll*ans*x%mod;\n\t\tx=1ll*x*x%mod;\n\t\ty/=2;\n\t}\n\treturn ans;\n}\nint n,a[1005],f[1005][2],st[100005],tp,ls[100005],rs[100005],inv2;\nvoid dfs(int u,int fa)\n{\n\tif(!u) return;\n\tdfs(ls[u],u),dfs(rs[u],u);\n\tint v=a[u]-a[fa];\n\tif(!ls[u]&&!rs[u])\n\t{\n\t\tf[u][1]=fpow(2,v);\n\t//\tprintf(\"u=%d,f=%d,%d\\n\",u,f[u][0],f[u][1]);\n\t\treturn;\n\t} \n\tif(!ls[u]||!rs[u])\n\t{\n\t\tint s=ls[u]+rs[u];\n\t\tf[u][0]=2ll*addmod(f[s][0]+f[s][1]);\n\t//\tf[u][0]=submod(f[u][0]-f[s][1]);\n\t\tf[u][1]=1ll*fpow(2,v)*f[s][1]%mod;\n\t//\tprintf(\"u=%d,f=%d,%d\\n\",u,f[u][0],f[u][1]);\n\t\treturn;\n\t}\n\tf[u][0]=2ll*addmod(f[ls[u]][0]+2*f[ls[u]][1]%mod)*addmod(f[rs[u]][0]+2*f[rs[u]][1]%mod)%mod;\n\tf[u][0]=submod(f[u][0]-2ll*f[ls[u]][1]*f[rs[u]][1]%mod%mod);\n\tf[u][1]=1ll*fpow(2,v)*f[ls[u]][1]*f[rs[u]][1]%mod;\n\t//printf(\"u=%d,f=%d,%d\\n\",u,f[u][0],f[u][1]);\n}\nint main()\n{\n\tinv2=fpow(2,mod-2);\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\twhile(tp>1&&a[st[tp-1]]>a[i])\n\t\t{\n\t\t\trs[st[tp-1]]=st[tp];\n\t\t\ttp--;\n\t\t}\n\t\tif(tp&&a[st[tp]]>a[i]) ls[i]=st[tp],tp--;\n\t\tst[++tp]=i;\n\t}\n\t//for(int i=1;i<=n;i++)\n\t//\tprintf(\"i=%d,ls=%d,rs=%d\\n\",i,ls[i],rs[i]);\n\twhile(tp>1)\n\t{\n\t\trs[st[tp-1]]=st[tp];\n\t\ttp--;\n\t}\n\tdfs(st[tp],0);\n\tprintf(\"%d\",addmod(f[st[tp]][0]+f[st[tp]][1]));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fi first\n#define se second\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\nconst int P=1e9+7,inv2=(P+1)>>1;\ninline void upd(R int &x,R int y){(x+=y)>=P?x-=P:0;}\ninline int inc(R int x,R int y){return x+y>=P?x+y-P:x+y;}\ninline int dec(R int x,R int y){return x-y<0?x-y+P:x-y;}\ninline int mul(R int x,R int y){return 1ll*x*y-1ll*x*y/P*P;}\nint ksm(R int x,R int y){\n\tR int res=1;\n\tfor(;y;y>>=1,x=mul(x,x))(y&1)?res=mul(res,x):0;\n\treturn res;\n}\ntypedef pair<int,int> pi;\nconst int N=105;\nint a[N],n,res;pi p;\npi calc(int l,int r,int x){\n\tR int mn=1e9,mx=0;\n\tfp(i,l,r)cmin(mn,a[i]),cmax(mx,a[i]);\n\tif(mn==mx)return pi(ksm(2,mn-x),ksm(2,r-l+1)-2);\n\tint f=1,s=1,w=0,np=1,coef=1;\n\tfor(int i=l-1,j=l;i<=r;i=j++){\n\t\twhile(j<=r&&a[j]!=mn)++j;\n\t\tif(i+1<=j-1){\n\t\t\tif(i+1==j-1)coef=mul(coef,ksm(2,a[i+1]-mn)),++w;\n\t\t\telse{\n\t\t\t\tp=calc(i+1,j-1,mn);\n\t\t\t\tf=mul(f,p.fi);\n//\t\t\t\tif(mn-x>1)s=mul(s,inc(p.fi,p.se));\n//\t\t\t\telse \n\t\t\t\ts=mul(s,inc(p.fi,inc(p.fi,p.se)));\n//\t\t\t\tprintf(\"Calc %d %d %d %d\\n\",i+1,j-1,p.fi,p.se);\n\t\t\t\tnp=mul(np,p.fi);\n\t\t\t}\n\t\t}\n\t\tw+=j<=r;\n\t}\n//\tprintf(\"%d %d %d %d %d %d %d\\n\",l,r,f,s,w,np,coef);\n\tif(w==r-l+1)return pi(mul(ksm(2,mn-x),coef),mul(ksm(2,r-l+1)-2,coef));\n\tf=mul(f,ksm(2,mn-x)),s=mul(s,ksm(2,w)),np=mul(np,2);\n//\tif(mn-x==1)\n//\tnp=mul(np,2);\n\tf=mul(f,coef),s=mul(s,coef),np=mul(np,coef);\n//\tprintf(\"%d %d %d\\n\",f,s,np);\n\treturn pi(f,inc(s,P-np));\n}\nint main(){\n//\tfreopen(\"testdata.in\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tfp(i,1,n)scanf(\"%d\",&a[i]);\n\tpi p=calc(1,n,0);\n\tprintf(\"%d\\n\",inc(p.fi,p.se));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<bitset>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; i++ )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef pair<ll,int> pli;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\nint dx[4]={1,0,-1,0} , dy[4]={0,1,0,-1} ;\n\nll dp[111][111][2];\nint a[111];\n\nll powmod(ll n,ll k){\n    ll ret=1;\n    while(k>0){\n        if(k&1)ret=ret*n%mod;\n        n=n*n%mod;\n        k>>=1;\n    }\n    return ret;\n}\n\nll rec(int l,int r,int h,int flag){\n    if(dp[l][r][flag]!=-1)return dp[l][r][flag];\n    int mi=inf,ma=0;\n    REP(i,l,r){\n        mi=min(mi,a[i]);\n        ma=max(ma,a[i]);\n    }\n    ll ret1,ret2;\n    ret1=ret2=1;\n    ll pos=l-1;\n    REP(i,l,r){\n        if(a[i]==mi){\n            ret2=2*ret2%mod;;\n            if(i-pos>1){\n                ret1*=rec(pos+1,i,mi,1);\n                ret2*=(2*rec(pos+1,i,mi,1)+rec(pos+1,i,mi,0));\n                ret1%=mod;\n                ret2%=mod;\n            }\n            pos=i;\n        }\n    }\n    if(r-pos>1){\n        ret1=ret1*rec(pos+1,r,mi,1)%mod;\n        ret2=ret2*(2*rec(pos+1,r,mi,1)+rec(pos+1,r,mi,0))%mod;\n    }\n    ret2=(ret2-ret1*2+2*mod)%mod;\n    return dp[l][r][flag]=flag?ret1*powmod(2,mi-h)%mod:ret2;\n}\nint main(){\n   int n;\n   cin>>n;\n   rep(i,n)cin>>a[i];\n   rep(i,n+1)rep(j,n+1)rep(k,2)dp[i][j][k]=-1;\n   ll ans=rec(0,n,0,0)+rec(0,n,0,1);\n   cout<<ans%mod<<endl;\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define UPD(x,y) (((x)+=(y))>=mo?(x)-=mo:233)\n#define CLR(a,v) memset(a,v,sizeof(a))\nusing namespace std;\nconst int mo=1000000007;\nint power(int x,int y){\n\tint s=1;\n\tfor (;y;y/=2,x=1ll*x*x%mo)\n\t\tif (y&1) s=1ll*s*x%mo;\n\treturn s;\n}\nconst int N=105;\nint a[N],mn[N][N];\nint fxor[N][N];\nint pre[N][N];\nint suf[N][N];\nint mx[N],g[N],n;\nint main(){\n\tscanf(\"%d\",&n); n++;\n\tFor(i,2,n) scanf(\"%d\",&a[i]);\n\ta[0]=a[1]=a[n+1]=a[n+2]=1;\n\tFor(i,0,n+2) mn[i][i]=i;\n\tFor(l,0,n+2) For(r,l+1,n+2)\n\t\tmn[l][r]=(a[r]<a[mn[l][r-1]]?r:mn[l][r-1]);\n\tFor(i,1,n+2) fxor[i][i-1]=1;\n\tRep(l,n+1,1) For(r,l,n+1){\n\t\tint dn=max(a[l-1],a[r+1]),md=mn[l][r];\n\t\tif (a[md]>=dn) fxor[l][r]=1ll*power(2,a[md]-dn)*fxor[l][md-1]%mo*fxor[md+1][r]%mo;\n\t}\n\tFor(l,0,n+2){\n\t\tCLR(mx,0); mx[l]=a[l];\n\t\tFor(i,l+1,n+2) mx[i]=min(a[i],mx[i-1]);\n\t\tint tmp=pre[l][l]=1,las=l;\n\t\tFor(r,l+1,n+2){\n\t\t\tpre[l][r]=1ll*tmp*fxor[las+1][r-1]%mo;\n\t\t\tif (mx[r]>=a[r]) tmp=1ll*tmp*fxor[las+1][r-1]%mo,las=r;\n\t\t}\n\t}\n\tFor(r,0,n+2){\n\t\tCLR(mx,0); mx[r]=a[r];\n\t\tRep(i,r-1,0) mx[i]=min(a[i],mx[i+1]);\n\t\tint tmp=suf[r][r]=1,las=r;\n\t\tRep(l,r-1,0){\n\t\t\tsuf[l][r]=1ll*tmp*fxor[l+1][las-1]%mo;\n\t\t\tif (mx[l]>=a[l]) tmp=1ll*tmp*fxor[l+1][las-1]%mo,las=l;\n\t\t}\n\t}\n\tg[1]=1;\n\tFor(i,2,n+2) For(j,1,i-1){\n\t\tint md=mn[j-1][i];\n\t\tUPD(g[i],1ll*g[j]*pre[j-1][md]%mo*suf[md][i]%mo);\n\t}\n\tprintf(\"%d\\n\",1ll*g[n+2]*500000004ll%mo);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_set>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\nll n;\nvector<ll> a;\nconst ll inv=(MOD+1)/2;\n\nll mod_pow(ll a,ll x){\n    ll ret=1;\n    while(x>0){\n        if(x&1){(ret*=a)%=MOD;}\n        (a*=a)%=MOD;\n        x>>=1;\n    }\n    return ret;\n}\n\npll search(ll l,ll r,ll h){\n    pll ret={1,1}; //tate,yoko\n    ll mx=0;\n    ll mi=E;\n    for(ll i=l;i<r;i++){\n        mx=max(mx,a[i]-h);\n        mi=min(mi,a[i]-h);\n    }\n    if(r-l==1){return {0,mod_pow(2,mx)};}\n    if(mi==mx){return {mod_pow(2,r-l-1),mod_pow(2,mx)};}\n    ll L=l;\n    ll cnt=0;\n    for(ll i=l;i<=r;i++){\n        if(i==r || a[i]==mi+h){\n            if(L<i){\n                pll A=search(L,i,mi+h);\n                (ret.S*=A.S)%=MOD;\n                (ret.S*=inv)%=MOD;\n                (ret.F*=(A.F+A.S*2)%MOD)%=MOD;\n            }\n            L=i+1;\n            if(i!=r){cnt++;}\n        }\n    }\n    (ret.F*=mod_pow(2,cnt))%=MOD;\n    (ret.F-=ret.S*4)%=MOD;\n    (ret.S*=mod_pow(2,mi))%=MOD;\n    (ret.S*=2)%=MOD;\n    cout<<l<<\" \"<<r<<\" \"<<h<<\" \"<<ret.F<<\" \"<<ret.S<<endl;\n    return ret;\n}\n\npll search2(ll l,ll r,ll h){\n    pll ret={1,1}; //tate,yoko\n    ll mx=0;\n    ll mi=E;\n    for(ll i=l;i<r;i++){\n        mx=max(mx,a[i]-h);\n        mi=min(mi,a[i]-h);\n    }\n    if(r-l==1){return {0,mod_pow(2,mx)};}\n    if(mi==mx){return {mod_pow(2,r-l-1),mod_pow(2,mx)};}\n    ll L=l;\n    ll cnt=0;\n    ll k2=1;\n    for(ll i=l;i<=r;i++){\n        if(i==r || a[i]==mi+h){\n            if(L<i){\n                pll A=search2(L,i,mi+h);\n                (ret.S*=A.S)%=MOD;\n                (ret.F*=(A.F+A.S*2)%MOD)%=MOD;\n                (k2*=A.S)%=MOD;\n            }\n            L=i+1;\n            if(i!=r){cnt++;}\n        }\n    }\n    (ret.S*=mod_pow(2,mi))%=MOD;\n    (ret.F*=mod_pow(2,cnt))%=MOD;\n    (ret.F-=k2*2)%=MOD;\n    //cout<<l<<\" \"<<r<<\" \"<<h<<\" \"<<ret.F<<\" \"<<ret.S<<endl;\n    return ret;\n}\n\n\n\nint main(){\n    cin>>n;\n    a.resize(n);\n    for(auto &I:a){cin>>I;}\n    pll ans=search2(0,n,0);\n    ll A=ans.F+ans.S;\n    A%=MOD;\n    if(A<0){A+=MOD;}\n    cout<<A<<endl;\n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N, K, H[100];\nvector<int> L;\nlong long P[30];\nlong long D[101][101];\n#define MOD 1000000007LL\nlong long R;\n\nlong long pow(int x) {\n  long long r = 1;\n  for(int b = 0; b < 30; ++b) {\n    if((1 << b) & x) (r *= P[b]) %= MOD;\n  }\n  return r;\n}\nint main() {\n  P[0] = 2LL;\n  for(int i = 1; i < 30; ++i) {\n    P[i] = P[i - 1] * P[i - 1] % MOD;\n  }\n  cin >> N;\n  L.push_back(0);\n  for(int i = 0; i < N; ++i) {\n    cin >> H[i]; L.push_back(H[i]);\n  }\n  sort(L.begin(), L.end());\n  L.erase(unique(L.begin(), L.end()), L.end());\n  K = L.size();\n  long long prev_l = 0; D[0][0] = 1;\n  for(int i = 0; i < N; ++i) {\n    long long l = lower_bound(L.begin(), L.end(), H[i]) - L.begin();\n    if(prev_l >= l) {\n      (D[i + 1][0] += 2 * D[i][0] % MOD) %= MOD;\n      for(int k = 1; k <= l; ++k) {\n        (D[i + 1][k] += D[i][k]) %= MOD;\n      }\n      for(int k = l + 1; k <= prev_l; ++k) {\n        (D[i + 1][0] += 2 * D[i][k] % MOD) %= MOD;\n      }\n    } else {\n      (D[i + 1][0] += 2 * D[i][0] % MOD) %= MOD;\n      for(int k = prev_l + 1; k <= l; ++k) {\n        (D[i + 1][k] +=\n          2\n          * (pow(L[k] - L[k - 1] - (k - 1 == 0 ? 1 : 0)) + MOD - 1) % MOD\n          * pow(L[l] - L[k]) % MOD\n          * D[i][0]) %= MOD;\n      }\n      long long C = pow(L[l] - L[prev_l]);\n      for(int k = 1; k <= prev_l; ++k) {\n        (D[i + 1][k] += C * D[i][k] % MOD) %= MOD;\n      }\n    }\n    prev_l = l;\n  }\n  for(int k = 0; k < K; ++k) {\n    (R += D[N][k]) %= MOD;\n  }\n  cout << R << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nconst int mod=1000000007;\nint N,h[110];\nint pw(int a,int n){\n\tint b=1;\n\tfor(;n;n>>=1)n&1?b=1ll*b*a%mod:1,a=1ll*a*a%mod;\n\treturn b;\n}\nstd::pair<int,int>dfs(int l,int r,int mn){\n\tint m=l;\n\tfor(int i=l;i<r;i++)if(h[i]<h[m])m=i;\n\tint s=pw(2,h[m]-mn);\n\tif(r-l==1)return std::make_pair(s,s);\n\tif(m==l){\n\t\tstd::pair<int,int>sr=dfs(m+1,r,h[m]);\n\t\treturn std::make_pair((2ll*sr.first+(s-1ll)*sr.second)%mod,1ll*s*sr.second%mod);\n\t}\n\tif(m==r-1){\n\t\tstd::pair<int,int>sl=dfs(l,m,h[m]);\n\t\treturn std::make_pair((2ll*sl.first+(s-1ll)*sl.second)%mod,1ll*s*sl.second%mod);\n\t}\n\tstd::pair<int,int>sl=dfs(l,m,h[m]),sr=dfs(m+1,r,h[m]);\n\treturn std::make_pair(\n\t\t(4ll*sl.first%mod*sr.first+(s-1ll)*sl.second%mod*sr.second)%mod,\n\t\t1ll*s*sl.second%mod*sr.second%mod\n\t);\n}\nint main(){\n\tscanf(\"%d\",&N);\n\tfor(int i=0;i<N;i++)scanf(\"%d\",h+i),--h[i];\n\tprintf(\"%d\\n\",dfs(0,N,0).first*2%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nconst int N = 111;\nconst int mod = 1e9 + 7;\n\nnamespace {\n  int add(int x) {return (x >= mod) ? x - mod : x;}\n  int sub(int x) {return (x < 0) ? x + mod : x;}\n  void Add(int &x, int y) {x = add(x + y);}\n  void Sub(int &x, int y) {x = sub(x - y);}\n}\n\nint Pow(int x, int y) {\n  int res = 1;\n  for(; y; y >>= 1, x = x * x % mod) {\n    if(y & 1) {\n      res = res * x % mod;\n    }\n  }\n  return res;\n}\n\nint n, H[N], dp[N][N][2][2][2];\nint Min[N][N];\n\nint ans = 1;\n\nbool vis[N][N];\n\nint get(int l, int r) {\n  int h = 2e9;\n  for(int i = l; i <= r; ++ i) h = min(h, H[i]);\n  return h;\n}\n\nvoid solve(int l, int r) {\n  //cerr << l <<' ' << r << endl;\n  if(vis[l][r]) return;\n  vis[l][r] = 1;\n  if(l == r) {\n    dp[l][r][1][1][0] = dp[l][r][0][0][0] = 1;\n    return;\n  }\n  if(l > r) {\n    return;\n  }\n  int h = 2e9;\n  for(int i = l; i <= r; ++ i) {\n    h = min(h, H[i]);\n  }\n  int who = 0;\n  for(int i = l; i <= r; ++ i) if(H[i] == h) who = i;\n  //cerr << l <<\" \" << r << \" \" << who << endl;\n  solve(l, who - 1);\n  solve(who + 1, r);\n  if(l > who - 1) {\n    //cerr << l <<\" \" << r <<\" \" << \"in\" << endl;\n    for(int a = 0; a < 2; ++ a) {\n      for(int b = 0; b < 2; ++ b) {\n        for(int c = 0; c < 2; ++ c) {\n          for(int d = 0; d < 2; ++ d) {\n            Add(dp[l][r][d][b][(d == a) || c],\n                dp[who + 1][r][a][b][c] * Pow(2 - c, get(who + 1, r) - h) % mod);\n          }\n        } \n      }\n    }\n    //cerr << l <<\" \" << r << \" \" << \"out\" << endl;\n    return;\n  }\n  if(who == r) {\n    //cerr << l <<\" \" << r << \" in\" << endl;\n    for(int a = 0; a < 2; ++ a) {\n      for(int b = 0; b < 2; ++ b) {\n        for(int c = 0; c < 2; ++ c) {\n          for(int d = 0; d < 2; ++ d) {\n            Add(dp[l][r][a][d][(d == b) || c],\n                dp[l][who - 1][a][b][c] * Pow(2 - c, get(l, who - 1) - h) % mod);\n          }\n        }\n      }\n    }\n      //cerr << l <<\" \" << r <<\" out\" << endl;\n    return;\n  }\n  //cerr << l << \" \" << r <<\" in\" << endl;\n  for(int a = 0; a < 2; ++ a) {\n    for(int b = 0; b < 2; ++ b) {\n      for(int c = 0; c < 2; ++ c) {\n        for(int d = 0; d < 2; ++ d) {\n          for(int e = 0; e < 2; ++ e) {\n            for(int f = 0; f < 2; ++ f) {\n              for(int g = 0; g < 2; ++ g) {\n                Add(dp[l][r][a][f][(d == b) || (d == e) || c || g],\n                    dp[l][who - 1][a][b][c] * dp[who + 1][r][e][f][g] % mod * Pow(2 - c, get(l, who - 1) - h) % mod * Pow(2 - g, get(who + 1, r) - h) % mod);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  //cerr << l << \" \" << r <<\" out\" << endl;\n  return;\n}\n\nmain() {\n  cin >> n;\n  int h = 2e9;\n  for(int i = 1; i <= n; ++ i) cin >> H[i], h = min(h, H[i]);\n  solve(1, n);\n  //cerr << \"HERE\" << endl;\n  int ans = 0;\n  for(int a = 0; a < 2; ++ a)\n    for(int b = 0; b < 2; ++ b)\n      for(int c = 0; c < 2;++ c)\n        Add(ans, dp[1][n][a][b][c] * Pow(2 - c, h - 1) % mod);\n  \n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 100 + 5;\n\nconst int MOD = (int)1e9 + 7;\n\nint n, h[MAXN], sorted[MAXN];\n\nint qpow(int a, int x) {\n    int res = 1;\n    for (; x > 0; x >>= 1) {\n        if (x & 1)\n            res = 1LL * res * a % MOD;\n        a = 1LL * a * a % MOD;\n    }\n    return res;\n}\n\nbool added[MAXN];\nint R_L[MAXN], L_R[MAXN];\n\nint dp[MAXN][MAXN][2][2][2];\nint last_h[MAXN][MAXN];\n\nvoid merge(int dp_l[2][2][2], int dp_r[2][2][2], int res[2][2][2]) {\n    int tmp[2][2][2];\n    \n    memset(tmp, 0, sizeof tmp);\n    \n    for (int l = 0; l < 2; ++l)\n    for (int r = 0; r < 2; ++r) {\n        for (int ll = 0; ll < 2; ++ll)\n        for (int rr = 0; rr < 2; ++rr)\n        for (int sl = 0; sl < 2; ++sl)\n        for (int sr = 0; sr < 2; ++sr) {\n            int t = sl | sr | (ll == rr);\n            tmp[l][r][t] = (tmp[l][r][t] + 1LL * dp_l[l][ll][sl] * dp_r[rr][r][sr]) % MOD;\n        }\n    }\n    \n    memcpy(res, tmp, sizeof tmp);\n}\n\nvoid calc(int L, int R, int h_now) {\n    if (last_h[L][R] == h_now) {\n        return;\n    }\n    \n    int tmp[2][2][2];\n    int t = (last_h[L][R] - h_now) & 1;\n\n    for (int l = 0; l < 2; ++l)\n    for (int r = 0; r < 2; ++r) {\n        tmp[l][r][1] = dp[L][R][l ^ t][r ^ t][1];\n        tmp[l][r][0] = 1LL * (dp[L][R][l][r][0] + dp[L][R][l ^ 1][r ^ 1][0]) * qpow(2, last_h[L][R] - h_now - 1) % MOD;\n    }\n\n    memcpy(dp[L][R], tmp, sizeof tmp);\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; ++i) {\n        scanf(\"%d\", h + i);\n        sorted[i] = i;\n    }\n    \n    std::sort(sorted + 1, sorted + n + 1, [&] (int a, int b) {\n        return h[a] > h[b];\n    });\n\n    for (int i = 1; i <= n; ++i) {\n        int j = sorted[i];\n\n        int tmp[2][2][2];\n        int L = j, R = j;\n\n        memset(tmp, 0, sizeof tmp);\n        tmp[0][0][0] = tmp[1][1][0] = 1;\n\n        if (R_L[j - 1]) {\n            int l = R_L[j - 1], r = j - 1;\n            L_R[l] = R_L[r] = 0;\n            calc(l, r, h[j]);\n            merge(dp[l][r], tmp, tmp);\n            L = l;\n        }\n\n        if (L_R[j + 1]) {\n            int l = j + 1, r = L_R[j + 1];\n            L_R[l] = R_L[r] = 0;\n            calc(l, r, h[j]);\n            merge(tmp, dp[l][r], tmp);\n            R = r;\n        }\n\n        added[j] = true;\n        memcpy(dp[L][R], tmp, sizeof tmp);\n        L_R[L] = R;\n        R_L[R] = L;\n        last_h[L][R] = h[j];\n    }\n\n    if (h[sorted[n]] > 1) {\n        int t = (h[sorted[n]] - 1) & 1;\n        int tmp[2][2][2];\n\n        for (int l = 0; l < 2; ++l)\n        for (int r = 0; r < 2; ++r) {\n            tmp[l][r][1] = dp[1][n][l ^ t][r ^ t][1];\n            tmp[l][r][0] = 1LL * (dp[1][n][l][r][0] + dp[1][n][l ^ 1][r ^ 1][0]) * qpow(2, h[sorted[n]] - 1 - 1) % MOD;\n        }\n        \n        memcpy(dp[1][n], tmp, sizeof tmp);\n    }\n\n    int ans = 0;\n    for (int i = 0; i < 2; ++i)\n    for (int j = 0; j < 2; ++j)\n    for (int k = 0; k < 2; ++k) {\n        ans = (ans + dp[1][n][i][j][k]) % MOD;\n    }\n\n    printf(\"%d\\n\", ans);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\ncat <<EOF >mistaken-paste\n*/\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 2000000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1000000\n#define M_MAX 200000\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <set>\n#include <map>\n#include <string>\n\n// using namespace std; // HELL\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\nusing std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\n\n#endif\n\ntypedef struct {\n\tint32_t a;\n\tint32_t b;\n} hw;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\null n, m;\null h, w;\null k;\null q;\null vua, vub, vuc, vud, vue, vuf;\nsll vsa, vsb, vsc, vsd, vse, vsf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (x < y) {\n\t\treturn gcd(y, x);\n\t} else if (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n// double distance (sll x1, sll y1, sll x2, sll y2) {\n// \tdouble xdist2, ydist2, origindist, dist;\n\n// \txdist2 = (x1 - x2) * (x1 - x2);\n// \tydist2 = (y1 - y2) * (y1 - y2);\n// \treturn sqrt(xdist2 + ydist2);\n// }\n\nint32_t pullcomp (const void *left, const void *right) {\n\tull l = *(ull*)left;\n\tull r = *(ull*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t psllcomp (const void *left, const void *right) {\n\tsll l = *(sll*)left;\n\tsll r = *(sll*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pcharcomp (const void *left, const void *right) {\n\tchar l = *(char*)left;\n\tchar r = *(char*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nint32_t phwllABcomp (const void *left, const void *right) {\n\thwll l = *(hwll*)left;\n\thwll r = *(hwll*)right;\n\tif (l.a < r.a) {\n\t\treturn -1;\n\t}\n\tif (l.a > r.a) {\n\t\treturn +1;\n\t}\n\tif (l.b < r.b) {\n\t\treturn -1;\n\t}\n\tif (l.b > r.b) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t phwllREVcomp (const void *left, const void *right) {\n\thwll l = *(hwll*)left;\n\thwll r = *(hwll*)right;\n\tif (l.b < r.b) {\n\t\treturn -1;\n\t}\n\tif (l.b > r.b) {\n\t\treturn +1;\n\t}\n\tif (l.a < r.a) {\n\t\treturn -1;\n\t}\n\tif (l.a > r.a) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t ptriplecomp (const void *left, const void *right) {\n\thwllc l = *(hwllc*)left;\n\thwllc r = *(hwllc*)right;\n\n\tif (l.a < r.a) {\n\t\treturn -1;\n\t}\n\tif (l.a > r.a) {\n\t\treturn +1;\n\t}\n\tif (l.b < r.b) {\n\t\treturn -1;\n\t}\n\tif (l.b > r.b) {\n\t\treturn +1;\n\t}\n\tif (l.c < r.c) {\n\t\treturn -1;\n\t}\n\tif (l.c > r.c) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\null parent[N_MAX];\null rank[N_MAX];\nvoid uf_init (ull n) {\n\tfor (sll i = 0; i < n; i++) {\n\t\tparent[i] = i;\n\t\trank[i] = 0;\n\t}\n}\null uf_find (ull x) {\n\tif (parent[x] == x) return x;\n\treturn parent[x] = uf_find(parent[x]);\n}\nsll uf_union (ull a, ull b) {\n\ta = uf_find(a);\n\tb = uf_find(b);\n\tif (a == b) return -1;\n\n\tif (rank[a] > rank[b]) {\n\t\ta ^= (b ^= (a ^= b));\n\t}\n\n\tparent[a] = b;\n\tif (rank[a] == rank[b]) {\n\t\trank[b]++;\n\t}\n\n\treturn b;\n}\n\n\null a[N_MAX];\n// sll a[3001][3001];\nsll b[N_MAX];\n// sll b[3001][3001];\nsll c[N_MAX];\nchar s[N_MAX + 1];\n// char s[3010][3010];\n// char t[N_MAX + 1];\n// char t[3010][3010];\n// hwll xy[N_MAX];\n\ntypedef pair<ull, ull> P;\n\null ignores = 0;\n\nP dfs (ull begin, ull end, ull cut) {\n\tsll i, j;\n\n\tull vmin = BIG;\n\tfor (i = begin; i < end; i++) vmin = umin(vmin, a[i]);\n\n\tvector<P> query;\n\tvector<P> v;\n\n\tull wrem = end - begin;\n\n\ti = begin;\n\twhile (i < end && a[i] == vmin) i++;\n\twhile (i < end) {\n\t\tj = i;\n\t\twhile (i < end && a[i] != vmin) i++;\n\t\tif (i - j == 1) {\n\t\t\tignores += (a[j] - vmin);\n\t\t} else {\n\t\t\tquery.push_back(P(j, i));\n\t\t\twrem -= (i - j);\n\t\t}\n\n\t\twhile (i < end && a[i] == vmin) i++;\n\t}\n\n\tfor (P x : query) {\n\t\tP reted = dfs(x.first, x.second, vmin);\n\t\tv.push_back(reted);\n\t}\n\n\tP ret;\n\tif (vmin == 1) {\n\t\tignores += wrem;\n\n\t\tull reted = 1;\n\t\tfor (P x : v) {\n\t\t\treted *= (x.first * 2 + x.second) % MOD;\n\t\t\treted %= MOD;\n\t\t}\n\t\tret.first = reted;\n\t\tret.second = 0;\n\t} else if (query.empty()) {\n\t\tull h = vmin - cut;\n\n\t\tret.first = bitpow(2, h, MOD);\n\t\tret.second = (MOD + bitpow(2, end - begin, MOD) - 2) % MOD;\n\t} else {\n\t\tull unfix = 1;\n\t\tull whole = 1;\n\t\tfor (P x : v) {\n\t\t\tunfix *= x.first;\n\t\t\tunfix %= MOD;\n\n\t\t\twhole *= (x.first * 2 + x.second) % MOD;\n\t\t\twhole %= MOD;\n\t\t}\n\n\t\t// printf(\"%llu*%llu/%llu\\n\", unfix, bitpow(2, vmin - cut, MOD), bitpow(2, v.size() - 1, MOD));\n\t\t// ret.first = divide(unfix * bitpow(2, vmin - cut, MOD) % MOD, bitpow(2, v.size() - 1, MOD), MOD);\n\t\t// ret.second = \n\t\t// ( ((MOD + whole - unfix) % MOD) * bitpow(2, wrem, MOD) % MOD )\n\t\t// + (MOD - divide(unfix, bitpow(2, v.size() - 1, MOD), MOD) + (unfix * bitpow(2, wrem, MOD) % MOD)) % MOD;\n\t\t// printf(\"%llu + %llu\\n\", ( ((MOD + whole - unfix) % MOD) * bitpow(2, wrem, MOD) % MOD ), (MOD - divide(unfix, bitpow(2, v.size() - 1, MOD), MOD) + (unfix * bitpow(2, wrem, MOD) % MOD)) % MOD\n\t\t// \t);\n\n\t\tret.first = unfix * bitpow(2, vmin - cut, MOD) % MOD;\n\t\tret.second = (MOD + (whole * bitpow(2, wrem, MOD) % MOD) - (unfix * 2 % MOD)) % MOD;\n\t}\n\n\t// printf(\"%lld~%lld: %llu/%llu ignores: %llu wrem: %llu : %llu-%llu=%llu v%d\\n\", begin, end, ret.first, ret.second, ignores, wrem, vmin, cut, vmin - cut, v.size());\n\n\treturn ret;\n\n}\n\null solve () {\n\tsll i, j, ki, li;\n\tull result = 0;\n\t// sll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tull *dpcell;\n\n\tP ret = dfs(0, n, 0);\n\n\tresult = (ret.first + ret.second) % MOD;\n\tresult = (result * bitpow(2, ignores, MOD)) % MOD;\n\n\tprintf(\"%llu\\n\", result);\n\t// printf(\"%.15lf\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\t// puts(\"YES\");\n\t// puts(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\tputs(\"Takahashi\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\t// puts(\"No\");\n\t// puts(\"0\");\n\t// puts(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\tputs(\"Aoki\");\n\treturn 1;\n}\n\nint32_t main (void) {\n\tint32_t i, j;\n\tint32_t x, y;\n\n\t// scanf(\"%lf%lf\", &vda, &vdb, &vdc);\n\t// scanf(\"%lld%lld\", &vsa, &vsb, &vsc, &vsd);\n\t// scanf(\"%llu%llu\", &vua, &vub, &vuc, &vud);\n\t// scanf(\"%*llu%*llu\");\n\t// scanf(\"%llu%llu\", &h, &w);\n\tscanf(\"%llu\", &n, &m);\n\t// scanf(\"%llu\", &k, &n, &m);\n\t// scanf(\"%s\", s);\n\t// scanf(\"%s\", t);\n\t// scanf(\"%llu\", &q);\n\tfor (i = 0; i < n; i++) {\n\t\t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t\tscanf(\"%lld\", &a[i]);\n\t\t// scanf(\"%lld\", &b[i]);\n\t\t// scanf(\"%lld\", &c[i]);\n\t\t// scanf(\"%lld\", &t[i]);\n\t\t// a[i]--;\n\t\t// b[i]--;\n\t\t// c[i]--;\n\t}\n\t// scanf(\"%llu%llu\", &m, &k);\n\t// for (i = 0; i < w; i++) {\n\t// \tscanf(\"%llu\", &b[i]);\n\t// \t// b[i]--;\n\t// }\n\t// scanf(\"%llu\", &q);\n\n\t// for (i = 0; i < h; i++) {\n\t// \tfor (j = 0; j < w; j++) {\n\t// \t\tscanf(\"%llu\", &a[i][j]);\n\t// \t}\n\t// }\n\t// for (i = 0; i < h; i++) {\n\t// \tscanf(\"%s\", &s[i]);\n\t// }\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<string>\n#include<math.h>\n#include<vector>\n#include<queue>\n#include<map>\n#include<stack>\n#include<fstream>\n#include<stdlib.h>\n#include<set>\n#include<climits>\n#include<cmath>  \n#include<memory.h> \n#include<sstream>\n#include<time.h>\n#include<iomanip>\nusing namespace std;\nconst unsigned long long BIGEST=1000000000000000000+1000000000000000000;\nconst long long BIGER=1000000000000000000;\nconst int BIG=1000000000;\nconst int MOD=1000000007;\nconst long long LMOD=1000000007;\n//const long long LMOD=1000000007;\n#define Fi first\n#define Se second\n#define P2 pair\n#define Pii pair<int,int>\n#define Cb make_pair\n#define ll long long\n#define Ull unsigned long long\n#define Sf scanf\n#define Pf printf\n#define Pb push_back\n#define Psh push\n#define Stc stack\n#define Vct vector\n#define Ret return\n#define Sz size\n#define Ins insert\n#define Que queue\n#define Emp empty\n#define Fro front\n#define Rv reverse\n#define Er erase\nll f[105][105][2];\nll h[105];\nll pw(ll a,ll b)\n{\n\tif(b==1)return a;\n\tif(b==0)return 1;\n\tll t=pw(a,b/2);\n\tif(b&1)return t*t*a%LMOD;\n\treturn t*t%LMOD;\n}\nll K(ll l,ll r,ll bt)\n{\n\t//cout<<l<<\" \"<<r<<\" \"<<bt<<endl;\n\tll mn=BIGER;\n\tfor(ll i=l;i<r;i++)\n\t{\n\t\t//mn=min(mn,h[i]);\n\t\tif(h[i]!=h[i+1])\n\t\t{\n\t\t\tfor(ll i=l;i<=r;i++)mn=min(mn,h[i]);\n\t\t\tll g=0;\n\t\t\tfor(ll i=l;i<=r;i++)if(h[i]==mn)g++;\n\t\t\tll lq=l,rq=l,res[2];\n\t\t\tres[0]=2;\n\t\t\tres[1]=1;\n\t\t\twhile(lq<=r)\n\t\t\t{\n\t\t\t\t//cout<<\">\"<<lq<<\" \"<<rq<<\" \"<<l<<\" \"<<r<<\" \"<<mn<<endl;\n\t\t\t\twhile(lq<=r&&h[lq]==mn)lq++,rq++;\n\t\t\t\twhile(rq<=r&&h[rq]>mn)rq++;rq--;\n\t\t\t\tif(lq<=r)\n\t\t\t\t{\n\t\t\t\t\tK(lq,rq,mn+1);\n\t\t\t\t\tres[0]=res[0]*f[lq][rq][0]%MOD;\n\t\t\t\t\tres[1]=res[1]*(f[lq][rq][0]*2+f[lq][rq][1])%MOD;\n\t\t\t\t}\n\t\t\t\trq++;\n\t\t\t\tlq=rq;\n\t\t\t}\n\t\t\t//cout<<\"!\"<<res[1]<<\" \"<<res[0]<<\"!\"<<endl;\n\t\t\tres[1]=res[1]*pw(2,g)%MOD;\n\t\t\tres[1]=(res[1]+MOD-res[0])%MOD;\n\t\t\tres[0]=res[0]*pw(2,mn-bt)%MOD;\n\t\t\tf[l][r][0]=res[0];\n\t\t\tf[l][r][1]=res[1];\n\t\t\treturn 0;\n\t\t}\n\t}\n\t//cout<<\"!\";\n\tf[l][r][1]=(pw(2,r-l+1)+MOD-2)%MOD;\n\tf[l][r][0]=pw(2,h[l]-bt+1)%MOD;\n\t//cout<<\"!\";\n\treturn 0;\n}\nint main()\n{\n\tll n;\n\tSf(\"%lld\",&n);\n\tfor(ll i=1;i<=n;i++)\n\t{\n\t\tSf(\"%lld\",&h[i]);\n\t}\n\tK(1,n,1);\n\tcout<<(f[1][n][0]+f[1][n][1])%MOD<<endl;\n\t/*\n\tfor(ll i=1;i<=n;i++)\n\t{\n\t\tfor(ll j=1;j<=n;j++)\n\t\t{\n\t\t\tcout<<f[i][j][0]<<\",\"<<f[i][j][1]<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t}\n\t*/\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#define vll vector<ll>\n#define vvvl vector<vvl>\n#define vvl vector<vector<ll>>\n#define VV(a, b, c, d) vector<vector<d>>(a, vector<d>(b, c))\n#define VVV(a, b, c, d) vector<vvl>(a, vvl(b, vll (c, d)));\n#define re(c, b) for(ll c=0;c<b;c++)\n#define all(obj) (obj).begin(), (obj).end()\ntypedef long long int ll;\ntypedef long double ld;\nusing namespace std;\n\nll num = 0;\nvvl dat;//l, r, h\nvvl G = VV(101, 0, 0, ll);\nvll h;\nll INF = 10000000000;\nvoid f(ll par, ll l, ll r){\n  ll minnum = INF;\n  ll L = l;\n  for(int i=l;i<r;i++){\n    if(h[i]==0){\n      if(minnum!=INF){\n        if(par!=-1) G[par].push_back(num);\n        dat.push_back(vll{L, i, minnum});\n        num++;\n        for(int j=L;j<i;j++) h[j] -= minnum;\n        f(num-1, L, i);\n      }\n      L = i+1;\n      minnum = INF;\n      continue;\n    }else{\n      minnum = min(minnum, h[i]);\n    }\n\n    if(h[i]!=0&&i==r-1){\n      if(minnum!=INF){\n        if(par!=-1) G[par].push_back(num);\n        dat.push_back(vll{L, i+1, minnum});\n        num++;\n        for(int j=L;j<=i;j++) h[j] -= minnum;\n        f(num-1, L, i+1);\n      }\n    }\n  }\n}\nll P = 1000000007;\nll mpow(ll a, ll b, ll p = -1){\n  ll ret = 1, num = a;\n  if(p==-1){\n    while(b>0){\n      if(b%2) ret *= num;\n      num = num * num;\n      b /= 2;\n    }\n  }else{\n    while(b>0){\n      if(b%2) ret = (ret*num)%p;\n      num = (num*num)%p;\n      b /= 2;\n    }\n  }\n  return ret;\n}\nvll dp1(101, 0);\nvll dp2(101, 0);\n\nvoid dfs(ll now, ll from){\n  ll cnt = 0;\n  for(auto to:G[now]){\n    if(to==from) continue;\n    cnt++;\n  }\n  if(!cnt){\n    dp1[now] = mpow(2, dat[now][2], P);\n    dp2[now] =\n    (mpow(2, dat[now][1]-dat[now][0], P) + (dp1[now] - 2) + P)%P;\n    return;\n  }\n\n  ll W = dat[now][1] - dat[now][0];\n  dp1[now] = 1, dp2[now] = 1;\n\n  ll s = 1, t = 1;\n  for(auto to:G[now]){\n    if(to==from) continue;\n    dfs(to, now);\n    //子全てが1のとき1になれる\n    W -= dat[to][1] - dat[to][0];\n    dp1[now] = (dp1[now] * dp1[to])%P;\n    s = (s * (dp1[to] + dp2[to])%P)%P;\n    t = (t * dp1[to])%P;\n  }\n\n  dp1[now] = (dp1[now] * mpow(2, dat[now][2], P))%P;\n  ll a = ((mpow(2, dat[now][2], P)-2+P)%P *t)%P;\n  ll b =(mpow(2, W, P)*s)%P;\n  dp2[now] = (a + b)%P;\n}\n\nint main(int argc, char const *argv[]) {\n  ll n;std::cin >> n;\n  h = vll(n);\n  re(i, n) std::cin >> h[i];\n  f(-1, 0, n);\n  dfs(0, -1);\n  std::cout << dp2[0] << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define maxn 120\n#define rep(i,l,r) for(register int i = l ; i <= r ; i++)\n#define repd(i,r,l) for(register int i = r ; i >= l ; i--)\n#define rvc(i,S) for(register int i = 0 ; i < (int)S.size() ; i++)\n#define rvcd(i,S) for(register int i = ((int)S.size()) - 1 ; i >= 0 ; i--)\n#define fore(i,x)for (register int i = head[x] ; i ; i = e[i].next)\n#define pb push_back\n#define prev prev_\n#define stack stack_\n#define mp make_pair\n#define fi first\n#define se second\n#define inf 0x3f3f3f3f\ntypedef long long ll;\ntypedef pair<int,int> pr;\n\nconst ll mod = 1e9 + 7;\nint h[maxn],a[maxn],tag[maxn],r[maxn * maxn],tot,n;\nll f[maxn][2][2][2],rec[maxn * maxn][2][2][2];\n\ninline void up(ll &x,ll y){ x = (x + y) % mod; }\ninline ll power(ll x,ll y){\n\tll res = 1;\n\tif ( y < 0 ) return 1;\n\twhile ( y ){\n\t\tif ( y & 1 ) res = res * x % mod;\n\t\tx = x * x % mod;\n\t\ty >>= 1;\n\t}\n\treturn res;\n}\nint main(){\n\t\n\tscanf(\"%d\",&n);\n\trep(i,1,n) scanf(\"%d\",&h[i]) , a[i] = h[i];\n\ta[n + 1] = 1;\n\tsort(a + 1,a + n + 2);\n\trepd(l,n + 1,1){\n\t\tif ( a[l] == a[l + 1] ) continue;\n\t\tint curh = a[l],last = 0,t = (a[l + 1] - a[l]) & 1; ll curp = power(2,a[l + 1] - a[l] - 1);\n\t\tmemset(f,0,sizeof(f));\n\t\tfor (register int i = 1 ; i <= n ; ){\n\t\t\tif ( h[i] >= curh && h[i - 1] >= curh ){\n\t\t\t\tint nxt;\n\t\t\t\tif ( tag[i] ){\n\t\t\t\t\tnxt = r[tag[i]];\n\t\t\t\t\trep(x,0,1) rep(y,0,1) rep(cx,0,1) rep(cy,0,1){\n\t\t\t\t\t\tif ( y != cx ){\n\t\t\t\t\t\t\tup(f[nxt][x][cy][1],f[i - 1][x][y][1] * (rec[tag[i]][cx][cy][1] + rec[tag[i]][cy][cx][1]) % mod * curp);\n\t\t\t\t\t\t\tup(f[nxt][x][cy][0],f[i - 1][x][y][0] * (rec[tag[i]][cx][cy][1] + rec[tag[i]][cy][cx][1]) % mod * curp);\n\t\t\t\t\t\t\tup(f[nxt][x][cy][0],(f[i - 1][x][y][0] + f[i - 1][x][y][1]) * rec[tag[i]][cx ^ t][cy ^ t][0]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tup(f[nxt][x][cy][0],(f[i - 1][x][y][0] + f[i - 1][x][y][1]) * rec[tag[i]][cx ^ t][cy ^ t][0]);\n\t\t\t\t\t\t\tup(f[nxt][x][cy][0],(f[i - 1][x][y][0] + f[i - 1][x][y][1]) * (rec[tag[i]][cx][cy][1] + rec[tag[i]][cy][cx][1]) % mod * curp);\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tnxt = i;\n\t\t\t\t\trep(x,0,1) rep(y,0,1) rep(z,0,1) rep(c,0,1){\n\t\t\t\t\t\tup(f[nxt][x][c][z && (c != y)],f[i - 1][x][y][z]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ti = nxt + 1;\n\t\t\t}\n\t\t\telse if ( h[i] < curh && h[i - 1] >= curh ){\n\t\t\t\ttag[last] = ++tot , r[tot] = i - 1;\n\t\t\t\trep(x,0,1) rep(y,0,1) rep(z,0,1) rec[tot][x][y][z] = f[i - 1][x][y][z];\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if ( h[i] >= curh && h[i - 1] < curh ){\n\t\t\t\tlast = i;\n\t\t\t\tint nxt;\n\t\t\t\tif ( tag[i] ){\n\t\t\t\t\tnxt = r[tag[i]];\n\t\t\t\t\trep(x,0,1) rep(y,0,1){\n\t\t\t\t\t\tf[nxt][x][y][0] = rec[tag[i]][x ^ t][y ^ t][0];\n\t\t\t\t\t\tf[nxt][x][y][1] = (rec[tag[i]][y][x][1] + rec[tag[i]][x][y][1]) * curp % mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tnxt = i;\n\t\t\t\t\trep(c,0,1) f[i][c][c][1] = 1;\n\t\t\t\t}\n\t\t\t\ti = nxt + 1;\n\t\t\t}\n\t\t\telse i++;\n\t\t}\n\t\tif ( h[n] >= curh ){\n\t\t\ttag[last] = ++tot , r[tot] = n;\n\t\t\trep(x,0,1) rep(y,0,1) rep(z,0,1) rec[tot][x][y][z] = f[n][x][y][z];\n\t\t}\n\t}\n\tll ans = 0;\n\trep(x,0,1) rep(y,0,1) rep(z,0,1) up(ans,f[n][x][y][z]);\n\tprintf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define llu unsigned long long\n#define ld double\n#define llu unsigned long long\n#define rep(i,x,y)  for(ll i=x;i<y;++i)\n#define For(i,x,y)  for(ll i=x;i<=y;++i)\n#define FOr(i,x,y)  for(ll i=x;i>=y;--i)\n#define pi acos(-1)\n#define mk make_pair<ll,ll>\n#define pa pair<ll,ll>\n#define lf else if\n#define min(x,y)    ((x)<(y)?(x):(y))\n#define sqr(x)      ((x)*(x))\n#define abs(x)      ((x)>0?(x):-(x))\n#define Mul(x,y)    (x=(x)*(y)%mod)\n#define Mul1(x,y)   (x=(x)*(y)%mod1)\n#define Add(x,y)    (x=(x+(y))%mod)\n#define Add1(x,y)\t(x=(x+(y))%mod1)\n#define E(x)        return writeln(x),0\n#define p(x)        printf(\"~%d~\\n\",x)\n#define pp(x,y)     printf(\"~~%lld %lld~~\\n\",x,y)\n#define ppp(x,y,z)  printf(\"~~~%d %d %d~~~\\n\",x,y,z)\n#define pppp(x,y,z,a)  printf(\"~~~%lld %lld %lld %lld~~~\\n\",x,y,z,a)\n#define f_in(x)     freopen(x\".in\",\"r\",stdin)\n#define f_out(x)    freopen(x\".out\",\"w\",stdout)\n#define open(x)     f_in(x),f_out(x)\n#define fi first\n#define se second\ntypedef complex<double> E;\nnamespace SHENZHEBEI{\n#ifdef LOCAL\n    struct _{_(){freopen(\"cf.in\",\"r\",stdin);}}_;\n#endif\n#define NEG 1\n    inline char gc(){   return getchar();   }\n#if NEG\n    inline ll read(){    ll x=0,f=1; char ch=gc();   for (;!isdigit(ch);ch=gc()) if (ch=='-') f=-1;  for (;isdigit(ch);ch=gc())  x=x*10-48+ch;   return x*f; }\n    inline void write(ll x){    if (x<0) putchar('-'),x=-x;  if (x>=10)   write(x/10);    putchar(x%10+'0');  }\n#else\n    inline ll read(){    ll x=0; char ch=gc();   for (;!isdigit(ch);ch=gc());    for (;isdigit(ch);ch=gc())  x=x*10-48+ch;   return x;   }\n    inline void write(ll x){    if (x>=10)   write(x/10);    putchar(x%10+'0');  }\n#endif\n    inline char readchar(){ char ch=gc();   for(;isspace(ch);ch=gc());  return ch;  }\n    inline ll readstr(char *s){ char ch=gc();   int cur=0;  for(;isspace(ch);ch=gc());      for(;!isspace(ch);ch=gc())  s[cur++]=ch;    s[cur]='\\0';    return cur; }\n    inline void writeln(ll x){  write(x);   puts(\"\");   }\n    inline ld getreal(){    static ld lbc;  scanf(\"%lf\",&lbc);  return lbc; }\n}using namespace SHENZHEBEI;\nconst ll N=110,mod=1e9+7;\nll n,a[N],h[N],f[N][N][2];\nnamespace GuYue{\n\tll b[N],h[N],n;\n\tll ppow(ll x,ll k){\n\t\tif (k<0)return 1;\n\t\tll ans=1;\n\t\tfor(;k;k>>=1,Mul(x,x))if (k&1)Mul(ans,x);\n\t\treturn ans;\n\t}\n\tll work(){\n\t\tmemset(f,0,sizeof f);\n\t\tn=*a;\n//\t\tif (n==1)return ppow(2,a[1]);\n\t\tFor(i,1,n)b[i]=a[i];b[n+1]=1;\n\t\tsort(b+1,b+n+2);\n\t\tll tot=unique(b+1,b+n+2)-b-1;b[tot+1]=b[tot];\n\t\tFor(i,1,n)h[i]=lower_bound(b+1,b+tot+1,a[i])-b;\n\t\tf[0][0][0]=f[0][0][1]=1;\n//\t\tFor(i,1,n)write(a[i]),putchar(' ');puts(\"\");\n\t\tFor(i,1,n){\n\t\t\tFor(cur1,0,h[i-1])For(cur2,0,h[i])For(num1,0,1)For(num2,0,1)\n\t\t\tif (f[i-1][cur1][num1]){\n\t\t\t\tll res1,res2,res3=0;\n\t\t\t\tif (cur2==h[i])res1=res2=1;\n\t\t\t\telse\tres1=(cur2==0)?0:(ppow(2,b[cur2+1]-b[cur2])-1),res2=ppow(2,a[i]-b[cur2+1]);\n\t\t\t\tif ((num1!=num2)&&(min(cur1,cur2)>=min(h[i-1],h[i]))){\n\t\t\t\t\tres3=1;\n\t\t\t\t\tif (i==1)res3=0;\n\t\t\t\t}\n//\t\t\t\tif (res3==1&&i==3)pppp(cur1,cur2,f[i-1][cur1][num1]*res1%mod*res2%mod*res3,res2);\n\t\t\t\tAdd(f[i][cur2][num2],f[i-1][cur1][num1]*res1%mod*res2%mod*res3);\n//\t\t\t\tif (res3)pppp(a[i],b[cur2+1],cur2,res1);\n//\t\t\t\tif(i==2)\t\t\twriteln(f[i-1][cur1][num1]*res1%mod*res2%mod*res3);\n\t\t\t\tif (num1==num2){\n\t\t\t\t\tif (h[i]>=h[i-1]){\n\t\t\t\t\t\tif (cur2>=cur1&&cur1==h[i-1])\n\t\t\t\t\t\t\tAdd(f[i][cur2][num2],f[i-1][cur1][num1]*res1%mod*res2);//writeln(f[i-1][cur1][num1]*res1*res2);\n\t\t\t\t\t\tlf (cur1==cur2)\n\t\t\t\t\t\t\tAdd(f[i][cur2][num2],f[i-1][cur1][num1]*ppow(2,a[i]-a[i-1]));\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif (cur2<=cur1&&cur2==h[i])\n\t\t\t\t\t\t\tAdd(f[i][cur2][num2],f[i-1][cur1][num1]);\n\t\t\t\t\t\tlf (cur1==cur2)\n\t\t\t\t\t\t\tAdd(f[i][cur2][num2],f[i-1][cur1][num1]);\n\t\t\t\t\t}\n\t\t\t\t}\n//\t\t\t\twriteln(f[i-1][cur1][num1]*res1%mod*res2%mod*res3);\n\t\t\t}\n\t\t}ll ans=0;\n\t\tFor(i,0,n+1)For(j,0,1)Add(ans,f[n][i][j]);//writeln(f[n][i][j]);\n\t\treturn ans;\n\t}\n}\nint main(){\n\tn=read();\n\tFor(i,1,n)h[i]=read();\n\tll ans=1;h[n+1]=1;\n\tfor(ll i=1;i<=n;)if (h[i]!=1){\n\t\t*a=0;\n\t\tfor(;h[i]!=1;)a[++*a]=h[i++];\n\t\tMul(ans,GuYue::work());\n\t}else\tMul(ans,2),++i;\n\tAdd(ans,mod);\n\twriteln(ans);\n}\n/*\n对于2\n取反,相同。。。 \n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdlib>\n#include<cstdio>\n#include<algorithm>\n#define ll long long\nusing namespace std;\nconst int maxn=1010, inf=1e9, mod=1e9+7;\nint n, N;\nint h[maxn], b[maxn], f[maxn][maxn];\n\ntemplate<typename T>\ninline void read(T &k)\n{\n\tint f=1; k=0; char c=getchar();\n\twhile(c<'0' || c>'9') c=='-'&&(f=-1), c=getchar();\n\twhile(c<='9' && c>='0') k=k*10+c-'0', c=getchar();\n\tk*=f;\t\n}\n\ninline int power(int a, int b)\n{\n\tif(b<0) return 1;\n\tint ans=1;\n\tfor(;b;b>>=1, a=1ll*a*a%mod)\n\tif(b&1) ans=1ll*a*ans%mod;\n\treturn ans;\n}\n \nint main()\n{\n\tread(n);\n\tfor(int i=1;i<=n;i++) read(h[i]), b[++N]=h[i];\n\tsort(b+1, b+1+N); N=unique(b+1, b+1+N)-b-1;\n\tfor(int i=1;i<=n;i++) h[i]=lower_bound(b+1, b+1+N, h[i])-b;\n\tf[0][0]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tf[i][0]=2ll*f[i-1][0]%mod;\n\t\tfor(int j=h[i]+1;j<=h[i-1];j++) f[i][0]=(f[i][0]+2ll*f[i-1][j])%mod;\n\t\tint sj=min(h[i], h[i-1]);\n\t\tfor(int j=1;j<=sj;j++)\n\t\tf[i][j]=1ll*f[i-1][j]*power(2, b[h[i]]-b[h[i-1]])%mod;\n\t\tfor(int j=h[i-1]+1;j<=h[i];j++)\n\t\tif(j>1) f[i][j]=(f[i][j]+1ll*f[i-1][0]*(power(2, b[j]-b[j-1])-1+mod)*2%mod*power(2, b[h[i]]-b[j]))%mod;\n\t\telse f[i][j]=(f[i][j]+1ll*f[i-1][0]*(power(2, b[j]-1)-1)*2%mod*power(2, b[h[i]]-b[j]))%mod;\n\t}\n\tint ans=0;\n\tfor(int i=0;i<=N;i++) ans=(ans+f[n][i])%mod;\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\nconst int N=1e5+5;\nconst int mod=1e9+7;\n\nint n,a[N],foo[N],bar[N];\n\nint fp(int x){\n\treturn 1ll*foo[x%N]*bar[x/N]%mod;\n}\n\npair<int,int>solve(int l,int r,int h){\n\tint mn=1<<30,cnt=0,x=1,y=1;\n\tfor(int i=l;i<=r;++i)\n\t\tif(a[i]<mn)mn=a[i],cnt=1;\n\t\telse if(a[i]==mn)++cnt;\n\tif(cnt==r-l+1)\n\t\tx=fp(r-l+1)-2,y=fp(mn-h);\n\telse{\n\t\tint z=r-l+1;\n\t\tfor(int i=l,j=0;i<=r;++i){\n\t\t\tif(!j&&a[i]>mn)j=i;\n\t\t\tif(j&&(i==r||a[i+1]==mn)){\n\t\t\t\tauto res=solve(j,i,mn);\n\t\t\t\tx=(res.first+2ll*res.second)*x%mod;\n\t\t\t\ty=1ll*res.second*y%mod;\n\t\t\t\tz-=i-j+1;j=0;\n\t\t\t}\n\t\t}\n\t\tx=(x+mod-y)%mod;\n\t\tx=(1ll*x*fp(z)+1ll*y*(fp(z)-2))%mod;\n\t\ty=1ll*y*fp(mn-h)%mod;\n\t}\n\treturn make_pair(x,y);\n}\n\nint main(){\n\tfoo[0]=1;foo[1]=2;\n\tfor(int i=2;i<N;++i)foo[i]=1ll*foo[i-1]*foo[1]%mod;\n\tbar[0]=1;bar[1]=(foo[N-1]<<1)%mod;\n\tfor(int i=2;i<N;++i)bar[i]=1ll*bar[i-1]*bar[1]%mod;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i)scanf(\"%d\",&a[i]);\n\tauto ans=solve(1,n,0);\n\tprintf(\"%d\\n\",(ans.first+ans.second)%mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\nconst ll MOD = 1000000007;\n\ninline void add(ll &x, ll y) { x += y; if (x >= MOD) x -= MOD; }\n\nll mod_pow(ll x, ll k) {\n\tll res = 1;\n\tfor (; k; x = x * x % MOD, k /= 2) {\n\t\tif (k & 1) {\n\t\t\tres = res * x % MOD;\n\t\t}\n\t}\n\treturn res;\n}\n\nint N;\nint h[110];\nint mh[110][110];\nll dp[110][110][2][2][2]; //left, right, same\nll sub[110][2][2][2]; //left, right, same\nll tb[110][110][2][2][2];\n\nvoid calc(int l, int r, int lo) {\n\tcerr << l << \" \" << r << \" \" << lo << endl;\n\tint la = -1;\n\tbool fd = 0;\n\n\tfor (int m = l; m <= r; ++m) {\n\t\tif (h[m] == mh[l][r]) {\n\t\t\tif (la != -1) {\n\t\t\t\tcalc(la, m-1, mh[l][r]);\n\t\t\t\tfd = 1;\n\t\t\t\tif (la == l) {\n\t\t\t\t\trep(j, 2) {\n\t\t\t\t\t\trep(k, 2) {\n\t\t\t\t\t\t\trep(t, 2) {\n\t\t\t\t\t\t\t\tif (t == 1) {\n\t\t\t\t\t\t\t\t\tadd(tb[l][m-1][j^1][k^1][t], dp[la][m-1][j^1][k^1][t]);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tadd(tb[l][m-1][j^1][k^1][t], dp[la][m-1][j][k][t]);\n\t\t\t\t\t\t\t\t\tadd(tb[l][m-1][j][k][t], dp[la][m-1][j][k][t]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\trep(j, 2) {\n\t\t\t\t\t\trep(k, 2) {\n\t\t\t\t\t\t\trep(t, 2) {\n\t\t\t\t\t\t\t\trep(jj, 2) {\n\t\t\t\t\t\t\t\t\trep(kk, 2) {\n\t\t\t\t\t\t\t\t\t\trep(tt, 2) {\n\t\t\t\t\t\t\t\t\t\t\tint nj, nk, nt;\n\t\t\t\t\t\t\t\t\t\t\tif (tt == 1) {\n\t\t\t\t\t\t\t\t\t\t\t\tnj = j, nk = kk ^ 1, nt = (t | tt) | (k == (jj ^ 1));\n\t\t\t\t\t\t\t\t\t\t\t\tadd(tb[l][m-1][nj][nk][nt], tb[l][la-1][j][k][t] * dp[la][m-1][jj][kk][tt] % MOD);\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\tnj = j, nk = kk ^ 1, nt = (t | tt) | (k == (jj ^ 1));\n\t\t\t\t\t\t\t\t\t\t\t\tadd(tb[l][m-1][nj][nk][nt], tb[l][la-1][j][k][t] * dp[la][m-1][jj][kk][tt] % MOD);\n\n\t\t\t\t\t\t\t\t\t\t\t\tnj = j, nk = kk, nt = (t | tt) | (k == jj);\n\t\t\t\t\t\t\t\t\t\t\t\tadd(tb[l][m-1][nj][nk][nt], tb[l][la-1][j][k][t] * dp[la][m-1][jj][kk][tt] % MOD);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (m == l) {\n\t\t\t\ttb[l][l][0][0][0] = tb[l][l][1][1][0] = 1;\n\t\t\t} else {\n\t\t\t\trep(j, 2) {\n\t\t\t\t\trep(k, 2) {\n\t\t\t\t\t\trep(t, 2) {\n\t\t\t\t\t\t\tif (tb[l][m-1][j][k][t] == 0) continue; \n\t\t\t\t\t\t\trep(nx, 2) {\n\t\t\t\t\t\t\t\tadd(tb[l][m][j][nx][t | (nx == k)], tb[l][m-1][j][k][t]); \n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tla = -1;\n\t\t} else if (h[m] > mh[l][r]) {\n\t\t\tif (la == -1) {\n\t\t\t\tla = m;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (la != -1) {\n\t\tfd = 1;\n\t\tcalc(la, r, mh[l][r]);\n\t\trep(j, 2) {\n\t\t\trep(k, 2) {\n\t\t\t\trep(t, 2) {\n\t\t\t\t\trep(jj, 2) {\n\t\t\t\t\t\trep(kk, 2) {\n\t\t\t\t\t\t\trep(tt, 2) {\n\t\t\t\t\t\t\t\tint nj, nk, nt;\n\t\t\t\t\t\t\t\tif (tt == 1) {\n\t\t\t\t\t\t\t\t\tnj = j, nk = kk ^ 1, nt = (t | tt) | (k == (jj ^ 1));\n\t\t\t\t\t\t\t\t\tadd(tb[l][r][nj][nk][nt], tb[l][la-1][j][k][t] * dp[la][r][jj][kk][tt] % MOD);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tnj = j, nk = kk ^ 1, nt = (t | tt) | (k == (jj ^ 1));\n\t\t\t\t\t\t\t\t\tadd(tb[l][r][nj][nk][nt], tb[l][la-1][j][k][t] * dp[la][r][jj][kk][tt] % MOD);\n\n\t\t\t\t\t\t\t\t\tnj = j, nk = kk, nt = (t | tt) | (k == jj);\n\t\t\t\t\t\t\t\t\tadd(tb[l][r][nj][nk][nt], tb[l][la-1][j][k][t] * dp[la][r][jj][kk][tt] % MOD);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\t\t\t\n\t}\n\n\tif (!fd) {\n\t\trep(j, 2) {\n\t\t\trep(k, 2) {\n\t\t\t\trep(t, 2) {\n\t\t\t\t\ttb[l][r][j][k][t] = sub[r-l+1][j][k][t];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint num = mh[l][r] - lo - 1;\n\tll p[2];\n\n\tif (num == 0) {\n\t\tp[0] = 1;\n\t\tp[1] = 0;\n\t} else {\n\t\tp[0] = p[1] = mod_pow(2, num - 1);\n\t}\n\n\trep(j, 2) {\n\t\trep(k, 2) {\n\t\t\trep(t, 2) {\n\t\t\t\tif (t == 1) {\n\t\t\t\t\tbool b = (num & 1);\n\t\t\t\t\tadd(dp[l][r][j^b][k^b][t], tb[l][r][j][k][t]);\n\t\t\t\t} else {\n\t\t\t\t\trep(b, 2) {\n\t\t\t\t\t\tadd(dp[l][r][j^b][k^b][t], tb[l][r][j][k][t] * p[b] % MOD);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\trep(j, 2) {\n\t\trep(k, 2) {\n\t\t\trep(t, 2) {\n\t\t\t\tprintf(\"%d %d %d %d %d : %d\\n\", l, r, j, k, t, dp[l][r][j][k][t]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> N;\n\trep(i, N) cin >> h[i];\n\tll pp = 1;\n\n\tif (N >= 2) {\n\t\tif (h[0] > h[1]) {\n\t\t\tpp = pp * mod_pow(2, h[0] - h[1]) % MOD;\n\t\t\th[0] = h[1];\n\t\t}\n\t\tif (h[N-2] < h[N-1]) {\n\t\t\tpp = pp * mod_pow(2, h[N-1] - h[N-2]) % MOD;\n\t\t\th[N-1] = h[N-2];\n\t\t}\n\t}\n\n\twhile (true) {\n\t\tbool fd = 0;\n\t\trep(i, N) {\n\t\t\tif (i > 0 && i + 1 < N && h[i] > h[i+1] && h[i] > h[i-1]) {\n\t\t\t\tpp = pp * mod_pow(2, h[i] - max(h[i-1], h[i+1])) % MOD;\n\t\t\t\th[i] = max(h[i-1], h[i+1]);\n\t\t\t\tfd = 1;\n\t\t\t}\n\t\t}\n\t\tif (!fd) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trep(i, N) {\n\t\tint d = 2e9;\n\t\tfor (int j = i; j < N; ++j) {\n\t\t\td = min(d, h[j]);\n\t\t\tmh[i][j] = d;\n\t\t}\n\t}\n\n\tsub[1][0][0][0] = sub[1][1][1][0] = 1;\n\n\tfor (int i = 1; i < N; ++i) {\n\t\trep(j, 2) {\n\t\t\trep(k, 2) {\n\t\t\t\trep(l, 2) {\n\t\t\t\t\tif (sub[i][j][k][l] == 0) continue;\n\t\t\t\t\trep(nx, 2) {\n\t\t\t\t\t\tadd(sub[i+1][j][nx][l | (k == nx)], sub[i][j][k][l]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcalc(0, N-1, 0);\n\tll ret = 0;\n\trep(j, 2) {\n\t\trep(k, 2) {\n\t\t\trep(t, 2) {\n\t\t\t\tadd(ret, dp[0][N-1][j][k][t]);\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << pp << endl;\n\n\tcout << ret * pp % MOD << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\n#include <stdlib.h>\n#include <vector>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <string.h>\n#include <stack>\n#define Endl endl\n#define mp make_pair\n#define ll long long \n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define over(A) {cout<<A<<endl;exit(0);}\n#define all(A) A.begin(),A.end()\n#define ceil(a,b) ((a-1)/b+1)\n#define srand() mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n#define rand(l,r) uniform_int_distribution<int>(l,r)(rng)\ntypedef unsigned long long ull;\nconst int inf=1039074182;\nusing namespace std;\nint n;\nint h[105];\nint res=1;\nvector <pair<pair<int,int>,int> >vec;\nint dp[105][105][2];\n\nnamespace combinatorics\n{\n\tint mod=1e9+7;\n\tinline int add(int a,int b)\n\t{\n\t\treturn (a+b)%mod;\n\t}\n\tinline int minus(int a,int b)\n\t{\n\t\treturn (a-b+mod)%mod;\n\t}\n\tinline int mutiply(int a,int b)\n\t{\n\t\treturn (1LL*a*b)%mod;\n\t}\n\tinline int fastpow(int basic,int x)\n\t{\n\t\tint res=1;\n\t\twhile(x)\n\t\t{\n\t\t\tif(x&1)\tres=mutiply(res,basic);\n\t\t\tbasic=mutiply(basic,basic);\n\t\t\tx>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tinline int inv(int x)\n\t{\n\t\treturn fastpow(x,mod-2);\n\t}\n};\nusing namespace combinatorics;\n\ninline void solve(int l,int r)\n{\n//\tcout<<l<<' '<<r<<endl;\n//\tSleep(1000);\n\tif(l==r) return;\n\tint mi=inf,ma=inf;\n\tfor(int i=l;i<r;i++)\n\t{\n\t\tmi=min(mi,h[i]);\n\t}\n\tvec.push_back({{l,r},mi-(l==0 && r==n)});\n\tfor(int i=l;i<r;i++)\n\t{\n\t\th[i]-=mi;\n\t}\n\tint last=l;\n\tfor(int i=l;i<=r;i++)\n\t{\n\t\tif(h[i]==0) solve(last,i),last=i+1;\n\t}\n}\n\ninline int way(int l,int r)\n{\n\tint res=0;\n\tfor(auto x:vec)\n\t{\n\t\tif(l<=x.first.first && r>=x.first.second) res=add(res,x.second);\n\t}\n\treturn fastpow(2,res);\n}\n\nint main()\n{\n\tcin>>n;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcin>>h[i];\n\t}\n\tsolve(0,n);\n//\tfor(auto x:vec)\n//\t{\n//\t\tprintf(\"From %d to %d, having %d floors.\\n\",x.first.first+1,x.first.second,x.second);\n//\t}\n\tdp[0][1][0]=1;\n\tdp[0][1][1]=1;\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tfor(int j=1;j<=i+1;j++)\n\t\t{\n\t\t\tfor(int k=0;k<2;k++)\n\t\t\t{\n\t\t\t\tdp[i+1][j+1][k]=add(dp[i+1][j+1][k],dp[i][j][k]);\n\t\t\t\tdp[i+1][1][!k]=add(dp[i+1][1][!k],mutiply(dp[i][j][k],way(i-j+1,i+1)));\n\t\t\t}\n\t\t}\n\t}\n\tint res=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tdp[n-1][i][0]=mutiply(dp[n-1][i][0],way(n-i,n));\n\t\tdp[n-1][i][1]=mutiply(dp[n-1][i][1],way(n-i,n));\n\t\tres=add(res,add(dp[n-1][i][0],dp[n-1][i][1]));\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int MAXN = 100 + 5;\n\nconst int Mod = 1e9 + 7;\n\nint n, h[MAXN];\n\nint sorted[MAXN];\n\nint qpow(int a, int x) {\n    int res = 1;\n    for (; x > 0; x >>= 1) {\n        if (x & 1) res = 1LL * res * a % Mod;\n        a = 1LL * a * a % Mod;\n    }\n    return res;\n}\n\nstd::set<std::pair<int, int>> intervals;\n\nstd::map<int, int> L_R, R_L;\n\nint dp[MAXN][MAXN][2][2][2];\n\nvoid Merge(int dp_l[2][2][2], int dp_r[2][2][2], int res[2][2][2]) {\n    static int tmp[2][2][2];\n    \n    memset(tmp, 0, sizeof tmp);\n    \n    for (int l = 0; l < 2; ++l)\n    for (int r = 0; r < 2; ++r) {\n        for (int ll = 0; ll < 2; ++ll)\n        for (int rr = 0; rr < 2; ++rr)\n        for (int sl = 0; sl < 2; ++sl)\n        for (int sr = 0; sr < 2; ++sr) {\n            int t = sl | sr | (ll == rr);\n            tmp[l][r][t] = (tmp[l][r][t] + 1LL * dp_l[l][ll][sl] * dp_r[rr][r][sr]) % Mod;\n        }\n    }\n    \n    memcpy(res, tmp, sizeof tmp);\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; ++i) {\n        scanf(\"%d\", h + i);\n        sorted[i] = i;\n    }\n    \n    std::sort(sorted + 1, sorted + n + 1, [] (int a, int b) { return h[a] > h[b]; });\n    \n    for (int i = 1; i <= n; ++i) {\n        int j = sorted[i], k = sorted[i - 1], t = (h[k] - h[j]) & 1;\n        \n        if (h[k] > h[j]) {\n            for (auto e: intervals) {\n                int L = e.first, R = e.second;\n                \n                static int tmp[2][2][2];\n                for (int l = 0; l < 2; ++l)\n                for (int r = 0; r < 2; ++r) {\n                    tmp[l][r][1] = dp[L][R][l ^ t][r ^ t][1];\n                    tmp[l][r][0] = 1LL * (dp[L][R][l][r][0] + dp[L][R][l ^ 1][r ^ 1][0]) * qpow(2, h[k] - h[j] - 1) % Mod;\n                }\n                \n                memcpy(dp[L][R], tmp, sizeof tmp);\n            }\n        }\n        \n        static int tmp[2][2][2];\n        int L = j, R = j;\n        \n        memset(tmp, 0, sizeof tmp);\n        tmp[0][0][0] = tmp[1][1][0] = 1;\n        \n        if (R_L.count(j - 1)) {\n            int l = R_L[j - 1], r = j - 1;\n            intervals.erase(intervals.find(std::make_pair(l, r)));\n            L_R.erase(L_R.find(l));\n            R_L.erase(R_L.find(r));\n            Merge(dp[l][r], tmp, tmp);\n            L = l;\n        }\n        \n        if (L_R.count(j + 1)) {\n            int l = j + 1, r = L_R[j + 1];\n            intervals.erase(intervals.find(std::make_pair(l, r)));\n            L_R.erase(L_R.find(l));\n            R_L.erase(R_L.find(r));\n            Merge(tmp, dp[l][r], tmp);\n            R = r;\n        }\n        \n        memcpy(dp[L][R], tmp, sizeof tmp);\n        intervals.insert({L, R});\n        L_R.insert({L, R});\n        R_L.insert({R, L});\n    }\n    \n    if (h[sorted[n]] > 1) {\n        int t = (h[sorted[n]] - 1) & 1;\n        int tmp[2][2][2];\n        for (int l = 0; l < 2; ++l)\n        for (int r = 0; r < 2; ++r) {\n            tmp[l][r][1] = dp[1][n][l ^ t][r ^ t][1];\n            tmp[l][r][0] = 1LL * (dp[1][n][l][r][0] + dp[1][n][l ^ 1][r ^ 1][0]) * qpow(2, h[sorted[n]] - 1 - 1) % Mod;\n        }\n        \n        memcpy(dp[1][n], tmp, sizeof tmp);\n    }\n    \n    int ans = 0;\n    for (int i = 0; i < 2; ++i)\n    for (int j = 0; j < 2; ++j)\n    for (int k = 0; k < 2; ++k) {\n        ans = (ans + dp[1][n][i][j][k]) % Mod;\n    }\n    printf(\"%d\\n\", ans);\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (lli i = 0; i < (n); i++)\n#define rrep(i, n) for (lli i = (n)-1; i >= 0; i--)\nusing namespace std;\nusing lli = long long int;\n\nbool calc2(lli a, lli b, lli c, lli d)\n{\n    if (a < b) {\n        return false;\n    }\n    lli tmp = (a - c) / b;\n    a -= tmp * b;\n}\nbool calc(lli a, lli b, lli c, lli d)\n{\n\n    if (b > d)\n        return false;\n    lli aa = a, bb = b, cc = c, dd = d;\n    lli tmp = a;\n    // cerr << \"init a \" << endl;\n    map<lli, bool> m;\n    map<lli, bool> m2;\n    m2[a] = true;\n    rep(I, 100)\n    {\n        // cout << a << endl;\n        if (a < b) {\n            // cerr << \"end\" << endl;\n            return false;\n        }\n        a -= b;\n\n        if (a <= c) {\n            a += d;\n            if (m2[a])\n                return true;\n\n            m2[a] = true;\n        } else {\n            if (m2[a])\n                return true;\n            m2[a] = true;\n        }\n    }\n    a = aa, b = bb, c = cc, d = dd;\n    m[a] = true;\n    rep(I, 100000)\n    {\n        //     cout << a << \" \" << b << \" \" << c << \" \" << d << endl;\n        if (a < b) {\n            // cerr << \"end\" << endl;\n            return false;\n        }\n        if (a > c) {\n            lli cand1 = a - ((a - c) / b) * b;\n            lli cand2 = a - ((a - c) / b + 1) * b;\n            if (cand1 <= c) {\n                a = cand1;\n            } else {\n                a = cand2;\n            }\n            if (a < 0)\n                return false;\n            // a -= (((a - c) % b == 0) ? (a - c) / b : ((a - c) / b + 1)) * b;\n        } else {\n            a -= b;\n        }\n        //cout << a << endl;\n        if (a <= c) {\n            a += d;\n            if (m[a])\n                return true;\n            m[a] = true;\n        } else {\n            if (m[a])\n                return true;\n            m[a] = true;\n        }\n    }\n    return true;\n}\nint main()\n{\n    int t;\n    cin >> t;\n    lli a, b, c, d;\n    rep(i, t)\n    {\n        cin >> a >> b >> c >> d;\n        auto s = calc(a, b, c, d);\n        cout << (s ? \"Yes\" : \"No\") << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <queue>\n#include <set>\n#include <map>\n#include <functional>\n#include <string>\n#include <cmath>\n#define SIZE 205\n#define INF 1000000005\n#define MOD 1000000007\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\n\nvector <int> vx;\nint H[SIZE];\nll dp[2][SIZE];\nll all[SIZE];\n\nll mpow(ll m,ll t)\n{\n\tif(t==0) return 1LL;\n\tll ret=mpow(m,t/2);\n\tret=ret*ret%MOD;\n\tif(t%2==1) ret=ret*m%MOD;\n\treturn ret;\n}\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tvx.push_back(INF);\n\tvx.push_back(1);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tscanf(\"%d\",&H[i]);\n\t\tvx.push_back(H[i]);\n\t}\n\tsort(vx.begin(),vx.end());\n\tvx.erase(unique(vx.begin(),vx.end()),vx.end());\n\tint pos=0;\n\tfor(int i=0;i+1<vx.size();i++)\n\t{\n\t\tint low=vx[i]+1,up=vx[i+1];\n\t\tup=min(up,H[0]);\n\t\tif(low>up) dp[pos][i]=0;\n\t\telse\n\t\t{\n\t\t\tdp[pos][i]=2LL*(mpow(2,up-low+1)-1LL)%MOD*mpow(2,H[0]-up)%MOD;\n\t\t}\n\t}\n\tall[0]=2LL;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tpos^=1;\n\t\tmemset(dp[pos],0,sizeof(dp[pos]));\n\t\tint t=lower_bound(vx.begin(),vx.end(),H[i])-vx.begin();\n\t\tfor(int j=0;j+1<vx.size();j++)\n\t\t{\n\t\t\tif(dp[pos^1][j]==0) continue;\n\t\t\tif(j+1<=t)\n\t\t\t{\n\t\t\t\tll vl=dp[pos^1][j];\n\t\t\t\tif(H[i-1]<H[i]) vl=vl*mpow(2,H[i]-H[i-1])%MOD;\n\t\t\t\tdp[pos][j]+=vl;\n\t\t\t\tif(dp[pos][j]>=MOD) dp[pos][j]-=MOD;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tall[i]+=dp[pos^1][j]*2LL%MOD;\n\t\t\t\tif(all[i]>=MOD) all[i]-=MOD;\n\t\t\t}\n\t\t}\n\t\tif(all[i-1]!=0)\n\t\t{\n\t\t\tfor(int j=0;j+1<vx.size();j++)\n\t\t\t{\n\t\t\t\tint low=vx[j]+1,up=vx[j+1];\n\t\t\t\tlow=max(low,H[i-1]+1);\n\t\t\t\tup=min(up,H[i]);\n\t\t\t\tif(low<=up)\n\t\t\t\t{\n\t\t\t\t\tdp[pos][j]+=all[i-1]*2LL%MOD*(mpow(2,up-low+1)-1LL)%MOD*mpow(2,H[i]-up)%MOD;\n\t\t\t\t\tif(dp[pos][j]>=MOD) dp[pos][j]-=MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\tall[i]+=all[i-1]*2LL%MOD;\n\t\t\tif(all[i]>=MOD) all[i]-=MOD;\n\t\t}\n\t}\n\tll ret=all[n-1];\n\tfor(int i=0;i+1<vx.size();i++)\n\t{\n\t\tret+=dp[pos][i];\n\t\tif(ret>=MOD) ret-=MOD;\n\t}\n\tprintf(\"%lld\\n\",ret);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 105;\nconst int MOD = 1e9 + 7;\nint n, h[N];\nint qpow(int x, int k) {\n    int r = 1;\n    while(k) {\n        if(k & 1) r = (ll)r * x % MOD;\n        x = (ll)x * x % MOD;\n        k >>= 1;\n    }\n    return r;\n}\ntypedef pair<int, int> pii;\npii dfs(int l, int r) {\n    int mn = 2e9, mc = 0;\n    for(int i = l; i <= r; i++) {\n        if(h[i]) {\n            if(mn == h[i]) mc++;\n            else if(mn > h[i]) mc = 1;\n            mn = min(mn, h[i]);\n        }\n    }\n    // printf(\"mc:%d mn:%d\\n\", mc, mn);\n    vector<pii> res;\n    int st = -1, t = 0;\n    for(int i = l; i <= r; i++) {\n        h[i] -= mn;\n        if(h[i]) {\n            if(st == -1) st = i, t = 1;\n            else {\n                t++;\n            }\n        } else {\n            if(t) {\n                res.push_back(dfs(st, st + t - 1));\n                t = 0;\n                st = -1;\n            }\n        }\n    }\n    if(t) {\n        res.push_back(dfs(st, st + t - 1));\n    }\n    ll o1 = qpow(2, mc), o2 = qpow(2, mn);\n    ll r1 = o1, r11 = o2 - 2, ret2 = o2;\n    for(pii p : res) {\n        ret2 = ret2 * p.second % MOD;\n        r1 = r1 * (p.first + p.second) % MOD;\n        r11 = r11 * p.second % MOD;\n    }\n    // printf(\"%d  %d  mn:%d  mc:%d  ret1:%d  ret2:%d\\n\", l, r, mn, mc, ret1, ret2);\n    return pii(r1 + r11, ret2);\n}\nint main() {\n    int n;\n    cin >> n;\n    for(int i = 0; i < n; i++) {\n        cin >> h[i];\n    }\n    pii res = dfs(0, n - 1);\n    cout << res.first % MOD << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\nconst int INF = 1e9+1;\nconst int MOD = 1e9+7;\n\nint mod_pow(int x, int n){\n  int res = 1;\n  while ( n ) {\n    if ( n & 1 ) (res *= x) %= MOD;\n    (x *= x) %= MOD;\n    n >>= 1;\n  }\n  return res;\n}\n\nint N;\nvector<int> h;\nvector<vector<int> > dp1, dp2;\n\nvoid dfs(int l, int r) {\n  int mi = INF;\n  for ( int i = l; i < r; i++ ) mi = min(mi, h[i]);\n  for ( int i = l; i < r; i++ ) h[i] -= mi;  \n  int cnt_mi = 0;\n  vector<int> p{l-1};  \n  for ( int i = l; i < r; i++ ) {\n    if ( h[i] == 0 ) {\n      cnt_mi++;\n      p.emplace_back(i);      \n    }\n  }\n  p.emplace_back(r);  \n\n  //cnt_mi = max(1LL, cnt_mi);  \n  int mpow1 = mod_pow(2, cnt_mi);\n  int mpow2 = mod_pow(2, mi);  \n  dp1[l][r] = dp2[l][r] = 1;  \n  for ( int i = 0; i < (int)p.size()-1; i++ ) {    \n    if ( p[i]+1 >= p[i+1] ) continue;    \n    dfs(p[i]+1, p[i+1]);\n    (dp1[l][r] *= (dp1[p[i]+1][p[i+1]]+dp2[p[i]+1][p[i+1]])) %= MOD;    \n    (dp2[l][r] *= dp2[p[i]+1][p[i+1]]) %= MOD;\n  }\n  (dp1[l][r] = mpow1*dp1[l][r]%MOD + (mpow2+MOD-2)*dp2[l][r]%MOD) %= MOD;\n  (dp2[l][r] *= mpow2) %= MOD;\n\n  for ( int i = l; i < r; i++ ) h[i] += mi;\n}\n\nsigned main() {\n  cin >> N;\n\n  h = vector<int>(N);\n  for ( int i = 0; i < N; i++ ) cin >> h[i];\n  \n  dp1 = dp2 = vector<vector<int> >(N+1, vector<int>(N+1, 0));\n\n  dfs(0, N);\n\n  cout << dp1[0][N] << endl;  \n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cctype>\n#include<iostream>\n#include<string>\n#include<sstream>\n#include<set>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<utility>\nusing namespace std;\n#define i64 long long int\n\nstruct mod_arith {\n\tint mod;\n\tmod_arith() {\n\t\tmod = 1000000007;\n\t}\n\tvoid set_mod(int _mod) { mod = _mod; }\n\tint add(int x, int y) { return (x + y) % mod; }\n\tint sub(int x, int y) { return (x - y + mod) % mod; }\n\tint mul(int x, int y) { return (int)((long long int)x*y%mod); }\n\tint pw(int x, i64 y) {\n\t\tint r = 1;\n\t\twhile (1) {\n\t\t\tif (y & 1)r = mul(r, x);\n\t\t\tif (y >>= 1)x = mul(x, x);else\n\t\t\t\tbreak;\n\t\t}\n\t\treturn r;\n\t}\n};\n\nmod_arith ma;\n\nint dp[111],h[111];\nint h2[111], m, n;\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &h[i]);\n\t\th2[i] = h[i];\n\t}\n\tm = n + 1;\n\th2[n] = 1;\n\tsort(h2, h2 + m);\n\tm = unique(h2, h2 + m) - h2;\n\tfor (int i = 0; i < n; i++) {\n\t\th[i] = lower_bound(h2, h2 + m, h[i])-h2;\n\t}\n\tdp[0] = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 1; i + j <= n; j++) {\n\t\t\ti64 cur = 0;\n\t\t\tfor (int H = 0; H < m - 1; H++) {\n\t\t\t\tint S = i, E = i + j;\n\t\t\t\twhile (1) {\n\t\t\t\t\tfor (; S < E && h[S] <= H; S++);\n\t\t\t\t\tif (S == E)break;\n\t\t\t\t\tint T = S;\n\t\t\t\t\tfor (;T < E && h[T] > H; T++);\n\t\t\t\t\tbool flag = true;\n\t\t\t\t\tif (S == i && (i > 0 && h[i - 1] > H))flag = false;\n\t\t\t\t\tif (T == E && (E < n && h[E] > H))flag = false;\n\t\t\t\t\tif (flag) {\n\t\t\t\t\t\tcur += h2[H + 1] - h2[H];\n\t\t\t\t\t}\n\t\t\t\t\tS = T;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[i + j] = ma.add(dp[i + j], ma.mul(dp[i], ma.pw(2, cur)));\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ma.mul(dp[n], 2));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int maxn=1e2+10,mod=1e9+7;\nint n,h[maxn],cnt;\nint dp[maxn][2],l[maxn],r[maxn],a[maxn],b[maxn];\nvector<int> ch[maxn];\n\nvoid dfs(int pos){\n\tb[pos]=*min_element(h+l[pos],h+r[pos]+1);\n\tfor(int i=l[pos],j;i<=r[pos];++i){\n\t\tif(h[i]==b[pos])\n\t\t\tcontinue;\n\t\tj=i;\n\t\twhile(j<r[pos]&&h[j+1]>b[pos])\n\t\t\t++j;\n\t\t++cnt;\n\t\tl[cnt]=i,r[cnt]=j,a[cnt]=b[pos];\n\t\tch[pos].push_back(cnt);\n\t\tdfs(cnt);\n\t\ti=j;\n\t}\n}\ninline ll fpow(ll a,ll n){\n\tll res=1;\n\tfor(;n;n>>=1,a=a*a%mod)\n\t\tif(n&1ll)\n\t\t\tres=res*a%mod;\n\treturn res;\n}\nvoid solve(int pos){\n\tif(ch[pos].empty()){\n\t\tdp[pos][1]=fpow(2,b[pos]-a[pos]);\n\t\tdp[pos][0]=(fpow(2,r[pos]-l[pos]+1)+mod-2)%mod;\n\t\treturn;\n\t}\n\tll tmp[2],temp[2];\n\tfor(int i=l[pos],j=0;i<=r[pos];)\n\t\tif(j<ch[pos].size()&&i==l[ch[pos][j]]){\n\t\t\tsolve(ch[pos][j]);\n\t\t\tif(i==l[pos]){\n\t\t\t\ttmp[0]=dp[ch[pos][j]][0];\n\t\t\t\ttmp[1]=dp[ch[pos][j]][1]*2%mod;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttemp[0]=(tmp[0]*dp[ch[pos][j]][0]+tmp[0]*dp[ch[pos][j]][1]*2+tmp[1]*dp[ch[pos][j]][0]+tmp[1]*dp[ch[pos][j]][1])%mod;\n\t\t\t\ttemp[1]=tmp[1]*dp[ch[pos][j]][1]%mod;\n\t\t\t\ttmp[0]=temp[0];\n\t\t\t\ttmp[1]=temp[1];\n\t\t\t}\n\t\t\ti=r[ch[pos][j]]+1;\n\t\t\t++j;\n\t\t}\n\t\telse{\n\t\t\tif(i==l[pos]){\n\t\t\t\ttmp[0]=0;\n\t\t\t\ttmp[1]=2;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttemp[0]=(tmp[0]*2+tmp[1])%mod;\n\t\t\t\ttemp[1]=tmp[1];\n\t\t\t\ttmp[0]=temp[0];\n\t\t\t\ttmp[1]=temp[1];\n\t\t\t}\n\t\t\t++i;\n\t\t}\n\tdp[pos][0]=tmp[0];\n\tdp[pos][1]=tmp[1]*fpow(2,b[pos]-a[pos]-1)%mod;\n}\n\nint main(){\n\tcin>>n;\n\tfor(int i=1;i<=n;++i)\n\t\tcin>>h[i];\n\t++cnt;\n\tl[1]=1,r[1]=n,a[1]=0;\n\tdfs(1);\n\tsolve(1);\n\tcout<<(dp[1][0]+dp[1][1])%mod<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fs first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define ALL(A) A.begin(),A.end()\n#define RALL(A) A.rbegin(),A.rend()\ntypedef long long LL;\ntypedef pair<LL,LL> P;\nconst LL mod=1e9+7;\nconst LL LINF=1e18;\n\n\nbool check(LL a,LL b,LL c,LL d,LL t){\n    if(t==100000) return true;\n    if(t%2==0){\n        LL m=0;\n        m=(c-a)/(d-b)+1;\n        if(check(a+m*(d-b),b,c,d,t+1)) return true;\n        else return false;\n    }\n    else{\n        LL m=0;\n        if((a-c)%b==0) m=(a-c)/b;\n        else m=(a-c)/b+1;\n        if(0>a-m*b||m<=0) return false;\n        if(check(a-m*b,b,c,d,t+1)) return true;\n    }\n    return false;\n}\n\n\nint main(){\n    int T;\n    cin >> T;\n    while(T--){\n        LL a,b,c,d;\n        cin >> a >> b >> c >> d;\n        LL m=0;\n        LL nx=0;\n        if(a<=c){\n            if(a<b){\n                puts(\"No\");\n                continue;\n            }\n            nx=a-b;\n        }\n        else{\n            if((a-c)%b==0) m=(a-c)/b;\n            else m=(a-c)/b+1;\n            if(a-m*b<0){\n                puts(\"No\");\n                continue;\n            }\n            nx=a-m*b;\n        }\n        if(b>d) puts(\"No\");\n        else if(b==d) puts(\"Yes\");\n        else{\n            if(check(nx,b,c,d,0)) puts(\"Yes\");\n            else puts(\"No\");\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*\nCoded by 秦惜梦\nThe most attractive girl in the world\n@@@@@@@@@@##&|;!!!!!!!!!!||||||||%%%%%$$$$$$$$$$$$%%$$$&&&&&&&&&$$&&&&&&&&&@@@&%||||||$&&&&@&%;'```'`':!||%&@@@@#@&&&&&@@@&&$$$&&@@&$$$&@@@@@@@@@@@@@#@@@@@@@@@@#@@@@@#@@@@@@@@@@##$\n@@@@@@@@@####$!;!!!!!!!!!||||||||%%%%%%%%%%%%%%%$$$$&&&&&&&&&&&&&&&&&&&&@@@@@@&%|||||!:'`'!$&&&&&&%:''!|||$&&&@@@@@@&&&&&@@@&$$$&&@&&$&&@@@@@@@@@@@@@@@@@@@@@@@@##@@@@#@@@@@@@@@@#@%\n@@@@@@@@@####@|;!!!!!!!!!|||||||%%%%%%%%%%%%%$$$$$$$$$$&&&&&&&&&&&&&&&@@@@@@@@&%|;:'''''``````'!$&&&@@&|:;%$$&&&@@@@@&&&&&@@@&$$$&&@@@@@@@@@@@@@@@@@@@@@@@#@@@@@#@@@@@#@@@@#@@@@##@%\n@@@@@@@@####@@&|;!!!!!!!!|||||||%%%%%%%%%%%%%%$$$$$$$$&&&&&&&&&&&$$$&&@@@@@@@@@@&$|;'''''````````'':!$&&&$%%%%$$&@@@@@&&&&&@@@@&&&@@#@@@@@@@@@@@@@@@@@@@@@@@@@@@#@@@@@@@@@@#@@@@#@@%\n@@@@@@@#####@@@$!;!!!!!!|||||||%%%$$$$$%%%%%%%%%$$$$$$$&&&&&&&&&$$$$&&@@@@@@@@$%$&@@&&&@&$%;:':;:''`````'|%%%%%%$$&@@@@@&&&&@@#@@@@@@#@@@@@@@@@@@@@@@@#@@@@@@@@@#@@@@@@@@@@@@@@#@@@%\n@@@@@@#####@$%%%$$$%%%||%%||||%%%%$%%$$$$$%%%%%%%$$$$&&&&&&&&&$$$$$$&&@@@@@@@&$;'''''':!%&&&&&&@@&%;'```:$&&%%%%%$$$&@@@@&&&&@@@@@@@@@#@@@@@##@@@@@@@@#@@@@@@@@@@@@@@#@@@@@@@@@#@@@%\n$&@@@@######&&&&&$%%%%|%|||||||%%%%%$$$$$$$$$$$$$&&&&&&&&&&&&&&&&$$$$&&@@@@@@&$!''''''````````:!|$&&&&&&&$&&&$%%%%$$$&&@@@&&&&&@@@@&@@@@@@@@@#@@@@@@@@#@@@@@&&&@@@@@@@@@@@@@@@#@@@@$\n$$$&@######@&&&&&&|!!!!!|||||||%%$$$$$$$$$$$$$$$&&&&&$$&&&&&&&&&&&&$$&&&@@@@@@&%;::''````````'':'``....`;|%$&&&$%%$$$$$&@@@&&&&&@@@@@@@@#@@@@@#@@@@@@@@@@@@@@&&@&&&&&&&&&@@@@@@@@@@$\n$$$&@#####@&$$&&@#&|!!!!!|||||||%%%$$$$%%%%%$$$$$$$&&&&&&&&&&&&@@@@@&&&&&&@@@@@@@@@@@&&&&&&&&@@@@&&$$%||||%%%$$&&&$$$$$$$&@@@&&&&&@@@@@@@#@@@@@@@@@@@@@@@@@@@@&&@&&&&&&&&@@@@@@@@@#$\n$$&@######@&$&@##@&$|!!!!|||||||%%%%%%%%%%%%%$$$$&&&&&&&&&&&&&&&&&&&&$$&&&&&&@@&|'`````````':::;;;;;;!|%%%%%%%%$&@@&$$$$$$$&@@&&&&&@@@@@@@@@@@@@@@@@@@@#@@@@@@@@@&&&&&&&&&@@@@@@@#@%\n$&@######@&&&@##@$$$$|!!!||||||||%%%%%%%%%%%%$$$$&&&&&&&&&&&&&&&&&&&&$&&&&&&&&@@$!:::'':::::::::::::''``.:%%$$$$$$&@@@&$$$$$&@@@&&&&@@@@@@@@@@@@#@@@@@@@@@@#@@@@#@@@@@@&&&@@@@@@@@@%\n$&@######@&&@#@&$$$$&$|!!!||||||||%%%%%%%%%$$$$$&&&&&&&&&&&&&&&&&&&$$$&&&&&&&&&&&%;::::::::::::':''':'':::%&$$$$$$$$&&@@&$$$$$&@@@&&&&@@@@@@@@@@@@@@@@@@#@@@@@@@@@@@@@@@@@@@@@@@@@@%\n&@#######@@@#@&$$$$$&&$|!!|||||||||%%%%%%$$$$$$$$$&&&&&&&&&&&&&&&$$$$$&&&&&&&&&&&$!''::::'''::;!|%%$&&@@@@&&@@$$%%$$$$&&@&&$$$$&@@@&&&&@@@@@@#@@@@@@@@@@@@@@@@@#@@@@@@@@@@@@@@@@@@@%\n############&$$$$$$$&&&$|!!||||||||%%%%%%$$$$$$$$$$$$$$&&&&&$$$$$$$$$$&&&&&&&&&&&&@@@&&&&&&&@@@@@@&&&$$%|!;%@@@@&$$$$$$$$&@@&$$$$&@@@&&&@@@@@@@@@#@@@@@@#@@#@@@@@@@@@@@@@@@@@@@@@@@$\n########@&$$$$$$$$$&&&&&$|!!||||||%%%%%%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$&&@@&&&&&&&&&&&&&&$$$$$$$$$$&&&$$%!;:::|$&@@@@&$$$$$$$&@@&$$$&@@@&&&@@@@@@@@##@@@@@@@@@@@@#@@@@@@@@@@@@@@@@@@@$\n########@$%%%$$$$$$&&&&&&&%!||||%%%$$$%%%%%%%%%%%%%%%%%%%%%%%$$$$$&&&&&&&&&&@@@&&&&&&&&&&&&$$$$$$$$$$$$$&&%!!$$$$&@@@@&$$$$$$&@@@&&&&@@@&&@@@@@@@##@@@@@#@@@@@@@@@@@@@@@@@@@@@@@@@@%\n#######@&$$$$$$$$$$$$&$|!||%%%%||%%%%%%%%%%%%%%%%%$$$$$$&$$$$$&&&&&&&&@@@@&&&&&&&&&&&&&&&&&&&$$&&$$$$$$$$$&&&$&@&$$$&@@@&$$$$$$&@@@@&&@@@@&@@@@@@###@@@@@@@@@@@@@@@@@@@@@@@@#@@@@#@%\n#######@$$$$$$%$$$$$$$&&$||||%%%%%%$$$$$$$$$$$$$$$$$$$$$$$&&&&&&&&&&@@&&&&&&&&&&&&$$$$$$&&&&$$$$$$$$$$$$$$$$$$&@@@@&$$$&@@@&$$$$&&&@@@&@@@@&&@@@@@###@@@@#@@@@@#@@@@@@@@@@@#@@@@#@@$\n#######&$$$$$$$$$$&$$$$$&&&&&$%||%%%%%%$$$$$$$$$$$$$$$$$&&&&&&&&&&&@&&&&&&&&&&&&$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$&&@@@&$$$&@@@&$$&&&@@@@@@#@@@@@@@@##@@@@#@@@@@@@@@@@@@#@@@@@@##@##$\n######@$$$$$$$$$$$$$$$$$$&&&&&&$||%%%%%%%$$$$$$$$$$$$$&&&&&&&&&@@&&&&&&&&&&&&&&$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$&@@@@@&&$&&@@@&&&&&@@@@@##@@@@@@@##@@@###@@@@@@@@@@@@@@#@@@#@#@@%\n######&$$$$$$$$$$$$$$$$$&&&&&&&&$%|%%%%%%%$$$$$$$$$$&&&&&&&&&&@&&@@&&&&&&&&&&$$$$$$$$$$$$$$$$$$$$$$$&$$$$$$$$$$$$$$$$&@@@@@@&&&&&@@@&&&&@@@@@#@@@@@###@@@##@@@@@@@@@@@@@@#@@@####@#$\n#####@$$$$$$$$$$$$$$$$$$$&&&&&&&&&%%%%%%%%%$$$$$$$$&&&&&&&&&&&&&&&&&&&&&&&&$$$$$$$$$$$$$$$$$$$$$$$$$$&$$$$$$$$$$$$$$$$$&&&@@@@@&&&&@@@@@@@@@@@@#@@@@###@@@$%%%%%%%%%%%%%$&@@#######$\n#####@&$%$$$$$$$$$$$$$$$$$$&&&&&&&&$%%%%%%%%%%$$$$&&&&&&&&&&&&&&&&$$$$$$$$$$$$$$$$$$$$$$$$$$%$$$$$$$$$%%$$$$$$$$%%$$$$$%&@&&&&@@@@@&&@@@@@&&@@@@#@@@@###@&%%%%%%%%%%%%%%%%%&@##@##@%\n####@@@@&$$$$$$$$$$$$$$$$$$&&&&&&&&&&%%%%%%%%%%$$&@&&&&$&&&$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$||$$$$$$$$%%$$$$$|%$$$$$$$%%$&@@@&&&@@@@@@@@@@@@&@@@@@@@@##@&%%%%%%%%%%%%%%%%%%%$@@@@@%\n####@@@@@@&$%$$$$$$$$$$$$$$$$$&&&&&&&&$%%%%%%%$&&&&&$$$$$$&$$$$$$$$$$$$$$$$$$$$$$$%%$$$%%%%|!|||$$$$%!|%%%$$&$$$$$$$$$$%%%$&@#@@@@&&@@@@@@@@@@@@@@##@@@@#@@@&$$%%%%%%%%|%%%%%|$@@@@$\n###@@@@@@@@$$$%$$$$$$$$$$$$$&&&&&&&&&&&&%%%%%&&&&&$%%%$$&&&$$$$$$$$$%%%$$|%$$$%%%$%%|%%!;!||!!||%$$$$$$$%%$&$$&&$$$$$$$$$$%%$@@#@@@@@@&&@@@@@@@@#@@###@@@########@@$%%%%%%%|%%$&@##$\n##@@@@@@@@@&$$$&$$$$$$$$$$$$$$$&&&&&&&&&&&%%%$&%|%%%%%$%%$$%%%%%%$$$%%%$$||%%%$$$$$%%%%%$$$$$%!!|%&&$$$$%|$$$$$$&$$$$$$$$$$$%$$&@@@@@@@@@@@@@@@##@@@@##@@####@@#######&%%%%%%%$@###$\n#@@@@@@@@@@&&$$&$$$$$$$$$$$$$$$&&&&&&$||%%%$$%!;!;!|%%%%$%!||||%%%$$$||%$%%%%%%$$$$%$$%%%%$%$$$$||$&&$$&%|%$$$$$$$&$%%$%|%$$$$%$%$@@@@@@##@@@@@@@@@@########@##@@@######&$$&@@@@@##$\n@$$&@@@@@@@&&$$$$$$$$$$$$$$$$$$&&&$&&&&$$&$$%!|%%%%%%%%%%||%%%%%%%%$$||%$$$$%%%%$$$%%$$%%%%%%%$$%|%&&$$&$%%$$$$$$$&&$%%&&&&$$$$$$$||$@@@@@@@@@@@@@@@@@@@####@@@@##@@@#@@@@@@@@@@@@@%\n&$%%$$&&&$$$$$$$$$$$$$$$$$$$$$$$$$$&&&&&&&&|!|%%%%|%%%%%%$%%%%||||%$$%|%$&&$%%%%$$$$%$$%%%%$$$$$%|$&&&$&$$$&$&$$$$&&&$%$&&&$$&&&&&$%!!|$&@@@@@@@@@@@@@@@@###@@@@@@@@@@@@@@@@@@@@@@@%\n$$%$$$$$$$$$$$$$$$$$$$$$$$$$$$$&&&$&&&&&&$|!|||%%|%%%%%%$$%%%%||||%$$%%%$&&$%%%$$&&&$$$$$$$$$$$$$%%&&&&&$$&&$&$$&&&&&&&&&&&&&&&&&&&&$|!!!!$&@@@@@@@@@@@#####@######@##@@&@@@@@@@@@@$\n$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$&&&&&&$|!|||%$%%%%%%%$$$$%%%||||%$$%%%$&&$$%%$&&&&&$$$$$$$$$$$$%%&&&&&$$&&$&$$&&&&&&&&&&&&&&&&&&&&&&%!!!!|&&&@@@@@@#########@########@@##########$\n$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$&&&&&$&$%|!||%$$%%$%%%%$$$$$%%|||||$$$&$$&$$$%$&&&&&&$$$$$%$$$$$$%$&&&&&&&&&&&$$&&&&&&&&&&&&&&@@&&&&&@@$|!$@&||||%&@#@@####@########@@@@@@@#@&&@@##$\n$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$&&&$$&$%|!||%$$%%%%%%%$$$%$$%%||||%$&&&&&&$$$$$$&&&&&$%$$$%%$$$$$%$&&&&&&&&$$$$$&&&&&&&&&&&&&&@@@&&@@@@@&@@&|||||||||%&@###############@@@@@@##@@@@%\n%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$&$&&$$$$%!!|%$$$%%%%%%$$$$%$$$%||||$&&$$&&$$$$$$$&&&$&$%%$%%%%%%$$%$$$&&&&&$$$$$$&&&&&&$&&&&&&&&&&&&&&&@@@@&||||||||||||$@#####@@@########@@@@@###@@$\n%%%%%%%%$$$$$$$$$$$$$$$$$$$$$$$$$&&%%&%!!||%$$%%$$%%$$$$%%$$%%|!|%&&$%%&&$%%%%$$$&$|%$||$%%%%%%$$$$$$&&&&$$$$$$&&&&&&$$$&&&&&&&&&&@@&&&@@@&&%|||||||||%&@@##@$$@@@@########@@@@@@##$\n;:''':;!|%%$$$$$$$$$$$$$$&&&&&&&&%%&&$!!|%%%%%%%$$$$$$$%%%$%%%|||$$&%!%&$%%%%|%%%&%!|$||%%%%%%%$$$$%%$&&$$$$$$$&&&&&&$$$$&&&&&&&&&&&&&&@@@@&&%|||||||%@@@@#@%|&#$||||%&@@@@@@@@@@@@$\n.....  .`;|%%$$$$$$$$$$$&&&&&&$%%$&&$!;|%%|||%%$$&&&&$$%%$$%%%%%%%&%!;|$$%||||%%%$|;!%||$%$$$$$%%%%||$&$%%%$$$$&&&&&&$$$$&&&&&&&&&&&&&@@@@@@&&%|||||$@@@##&%|%@@%||||||||||&@@@@@@@%\n........  `;|%$$$&&&&&&&&&&&$%$&&&&$|!|%%|!!|||$&$&&&$$%%%%%||||%$$|;;|%%|||||%$&&$|!|!!%%%%%%|!!|%!%$$%||%$&$&&&&&&&$$$$&&&&&&&&&&&&@@@@@@@@&&%|||$@@@##@$||$#&|||||||||||&#$|||||!\n...    ..  `;|%$$$$&&&&&&$%$$&&&&&&||%%$||!!||$&$$$$$$%%%%%%||||%$%!:!!!%%$$$%%%%|!;;;;;!!!!!;;;||!%&%|%%%$&&$&&&&&&&$$$$&&&&&&&&&&&@@@@@@@@@&&$||$@##@@@%||%&@$||||||||||%&@$|||||!\n       ..  .'!|%$$&&&&&&&&&&&&&&&&||$$&%||!||%&&$$$$$$%%$%||||||%|!;:;;;|%|!!!!!|!|$$&&&&$$$%!!!!;|&&$%%%$&$$$$%||&@&$$$$&&&&&&&&&@@@@@@@@@@@@&$|%@@@@#@%|||$@&%||||||||||%@@%|||||!\n       ... .';|%$$&&&&&&&&&&&&&&&%%&$&&%|||||%&&$$$$$$%%$%%%||||%!;:::::::'':;!|%%%%$&@&&$%|!|%|;!$&$%|%%$$$$&$|!|$@@&$$$&@@@@@@@@@@@@@@@@@@@@&$$@@@#@&%|||%&#$|||||||||||$@&%|||||!\n    ....   .:!|%$$&&&&&&&&&&&&&&$$&&&&$|||||%$@&$$&$$&&&$%|%%%%|;::''''''````'!!!;'`'%@&%|!::!;;!$$||%%%$&$$$$|!!|%&@@&&&&@@@@@@@@@@@@@@@@@@@@&&@@@@#@%||||$@@$|||||||||||$#&||||||!\n     ..   .';!|%$$$&&&&&&&&&&&&$$&&&&&$$%||%%&@&$$&$$$$%|!;;;;:::'`````````````````';;:;!;'::::;%$|||!!|$$$%$%||||$@@@&&&@@@@@@@@@@@@@@@@@&&@&&&&&&@@@$%%||&#&%||||||||||%&#$||||||!\n        .`:!!!|$$&&&&&&&&&&&&&&&&&&&&&&&$%$$$&@&&$&&$$|!|%$$$$%|;''``````````````':;!!!;::''':;!$%|$$%%$$$$$$%!!%&@@@@@@@@@@@@@@@@@@@@@@@@&&&&@&$$&@@@@@@@@@#&%||||||||||%@@$||||||!\n;:''`'':;!!!!|%$$&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&$&&&&&$|!%%%%$&$$|;'``````````````''''''''::::;|$&$$$%%$$%%$$$&@@@@@@@@@@@@@@@@@@@@@@@@@@@&&&@&$$$&&&@@@@@@@@@@@@@@&$%|||$@@$||||||!\n|!;;;!!!!!!|%$$$&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&%!:;|!||!!:'''``````````````''''''''':;;|$$$$$%%$%$$$&&&&&@@@@@@@@@@@@@@@@@@@@@@@@&&&@&$$$&&&&&@@@@@##@@@@@&&@@@@@@#@&%|||||!\n%|!!!!!!||%$$$&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&@@&&&&&&$$$!';;;:'```''`````````````````'''''';;:|$$$$$$$$%$$$&@&&&&@@@#@@@@@@@@@@@@@@@@@@@&&@&$$$$$$$&&&@@@@##@%;''|&@@@@@@@#@@@@@@@%\n&$%%%%%%$$$$&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&@&&&@&&&$$$%;``'''``':'``````````````````'''':::;|$$$$$$$%$$$$&&&&&&@@@##@@@@@@@@@@@@@@@@@@&@&$$$&&&$$$&&&@@@@|:''':%@@@@@@@#@@@@@@@@%\n@@&$$$$$&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&@&&@@&&&$$$$%:``````';:'```...`````````````'''':;|$$$$$$%%$$$$&&&&&&&@@##@@#######@@#@@@@@@#@&$$&&&&&$%$$&&@@%:'::'!&@@@@&@@@@@@@@@@@%\n##@&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&@@&&&&&&&$$%:``````':;:```..``````````````''':;|$$$$$$%%$$$&&&&&&&@@@####################@&$$&&$$$$$$$|;|&$!''':;$&&&&&&@@@@@@@@@@@%\n##@&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&$&@&$&&&$&&&&&%'``````.``````....```````````'`'';|$&$$$%$$$$$$&&&&&@@@@@##################@$$$&&$$$$$|:':;%&$;''''|&&&&&&&&@@@@@@@@@@%\n##@&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&$%$&@@$$$$$&&&&&@@!````````.......````````````''`'':!%$&&&$$&&&&&&&&&&@@@#@@##############@@&$$$$&$$$$$$|:''|&&|''''!$&&&&&&@@@@@@@@@@@@%\n##@&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&|;%&$&@$$$$$$&&&&&@@&;..``..........````````````''``'';%$&&&&&&&&&&&&&&@@@@@##@############@@@$$$$&$!|$$$$!:':%@%:``':%&&@@@@@@@@@@@@@@@@@%\n##@&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&$!!$&&$&&$|!|%$$$&&&@@@@$:.........``'''``':;:'`````````':!%$&&&&&&&@&&&&&@@@@@@@#@@#########@@@&$$$%!!$$$$$%;'';$&!``':%@@@@@@@@@@@@@@@@@@@&%\n##@&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&|;%&&&&$%%$%!|%%$$$$&&@@@@@$;`.....`...````````````````````';|$&&&&&&&&@@@&&&@###@@@@#@&&##@@@@@&$$$$&&$$$$$$|'```!&%;|&&&&&@@@@@@@@@@@@@@@&&&&%\n###&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&%:|&&&&&$$||$&$|%%%$$&&&@@@@@@@@$;`........``'::'`...```'``````:|$$$&@@&$&@@@@@@&@#@@####@#&&#@$|%&$$%%&&$$$$%!'`.`:!$@@&&&&@@@@@@@@@@@@@@&&&&&&&&%\n###@&&&&&&&&&&&&&&&&&&&&&&&&&&|:!&&&&&&$$%||$&&$%%%$$&&&&@@@@@@@@@@&%:`.................`'````:!;;|$$$&&@@&&&&@@@@&&@########@!':|&$$%%$|;:;;!|%%%%||$@@&&&&&&&@&&&&&&&&&&&&&&&&&&&%\n###@&&&&&&&&&&&&&&&&&&&&&&$!:|&&&&&&&&$$%|%$&&&$%%%$&&&&&@@@@@@@@@@@@&&$;`..............``'';|!;;;;|%$$$$&@@@&&&@@&&$$&&@@@@##@&%||%%%$!:|%%%%%||%!|$@@@&&&&&&&&$$$$$$&&&&&&&&&&&&&%\n###@&&&&&&&&&&&&&&&&&&&|:!$&&&&&&&&&&$%%%%$$&&&$%%$$$$&&@#@@@@@@@@@@@&&&&&&|'...........``:!!;;;;;!!;|$&$%|&@@@&&&&&$!|$$$&@@#@@&%%%%$|'':!%%%%|!|$&&@@&&&&&&&$%%%%$$$$$&&$$$$$$&&&%\n###@&&&&&&&&&&&&&&&|:;%&&&&&&&&&&&&$$%%%%$$&&&&$$$$$$$$&@#@@@@@@@@@&&&&&&&&&&&&|'.....`;%%!!!!;;;!!!!;!%$$&$|%@@@@@&&@$;:::!|%$&$%%%$%:'``';!!|||%$&@@@&&&&&&$%%%%%%%$$$$$%%%%$$$$$|\n###@&&&&&&&&&$|:;%&&&&&&&&&&&&&&&$$%%$%%$&&&&&&$$$$%$$$&@@@@@@@@@##@&&&&&&&&&&&&&&%|%&&&&&$|;;;;;;;;;;;;!$&$&$|!%&@@@@@@&%;::!$$$$$$%;:```````;||||%$&&$$$$$$%|%%%%%%%$$$%%%%%%%%$%|\n###@&&$%|||$&&&&&&&&&&&&&&&&&&$$$$%%$$%$&&&&&&&$$$%%$$&&@@@@@@@@@@@##@&&&&&&&&&&&&&&&&&&&&@%;;;;;;;::;;;;!!$&&$$%!;|$$$&&&$&&&$$$$$%!|$&%:...`.`;|!|||!;!|||||||%%%%%%$%%%||||%%%%%|\n&&@@&&&&&&&&&&&&&&&&&&&&&&&$$$$$$%%$$%$&&&&&&&&$%%%%$$&&@@@@@@@@@@@@#@&@@&&&&&&&&&&&&&@###&%;;;;;;::::;;;!!!!|$$$&&%!:;!$&&&@&$$$&@&&&$%$&|``..'%#@@&$%%||||!;:'`';|%%$%%|||||||||||\n###@&&&&&&&&&&&&&&&&&&&&$$$$$$$$%%$&&$$&&&&&&&&$%%%%$$&&&@@@@@@@@@@@@@@&&&&@@@@@&&@####$;':!!;;;::::;;;;!;!;::::;%&&&&&$$$&@&$$$@@$$$$$&@@@@$%@#@@##@@&%%||||||||%%%|!'`:!||||||||||\n###@&&&&&&&&&&&&&&&&&$$$$$$$$$$$$$$$%%$$$$&&&&@$%%%%$$&&&&&@@@@@@@@@&&&&@@&&&&&&&@@@@|:':;;!!;;:::::::;;!!;:::::::::':::';$$$$$&&$&&&@@@&&@@@@@#######@@##@&%||||||||%%%%|!''!|||||!\n###@&&&&&&&&&&&&&&$$$$$$$$$$$&&$$$$$%%$$$$$&&&&&$%%$$$&&&&&$&&&@@@@&&&&&&&&&&&&@@@%:''':;;;;;:::::::::;;;:::::::::::::;;!%$$$$$|:::|$&&$&@@@@@&$&@#####@@@@####@&$%||%%%||||||;:!||!\n###@&&&&&&&&&&&$$$$$$$$$$$&&&&&$$&&$%%$$$&&&&&&&&$%$$$$$&&&&&&&@@@#@&&&&&&&&@##$;''''':;;;;;:::::::::;!;:::::::::::::::;%&$$$$|''':;%&%!;:'''':|%$&@@@@#@@&&&@##@&&@@$|%%|||||||!:;|\n:;$@@&&&&&&&$$$$$$$$$$$&&&&&&&&&$$&&$$&&&&&&&&&&&$%%$$$&&&&&&&&&&&&@@#######@|:'''''';!!!;::::::;;!!!!;::::::::::::::::|$$$$$!'::;!!%&|;;''''''''''';$&@@#@&&$$&@&&@#@@@#####@$%||;:\n''''':|$&$$$$$$$$$$&&&&&&&&&&&&&&$$&$$&&&&&&&&&&&&&$$$$$&&$$&&&&&@@@@@&$%$%|:''''''':;:::::::::::::;;:::::::::::::::::|$$$$$!::;;;;|&%;;:''''''''''''':!$&@@@&$$$$&################$\n'''''''''';%$$&&&&&&&&&&&&&&&&&&&&$$$$&&&&&&&&&&&&&&$$$$$&@@@@@###@&&$%;''''''''':::;;:::::::::::;;:::'':::::::::::':|$$$$$!::;:::|&%;;:''''''''''''''```:%&@@&&&$$$&##############$\n'''''''''''':':|&&&&&&&&&&&&&&&&&&&&$%$&&&&&&&&&&&&&&$$$$$&@@&@@@&$$%%!:''''''::::::!;::::::::::;;::::::::::::::''':|$$$$$|;;:::;%&|::'''''''''''''`.....``;$@@&&&&$$$&@###########$\n;:'''''''''''''':::!$&&&&&&&&&&&&&&&&&%|$&&&&&&&&&&&&&&$$$$&$$$$$$|:!|;':::::::::::;!;::::::::;;:::::::::::::''''':|$$$$$|;::::|&&|::'''''''''''``........`''!&@@&&&&$$$&@#########$\n.';;;;;:'''''''''''':::;%&@&&&&&&&&&&&&%$&&$$$$&&&&&&$&@&&&$$$$%!:::!|;::::::::::::!!;::::::!;::::::::::::::''''':|&$$$$|;::::|&%;;:'``''''''''````......````'!$@@&&&&&$$$&@#######$\n;;;:`.`:;;;;::'''''''''''':;%@@@&&&&&&&&$$$&&&&&&&&&&@@&!::':'':::::||;::::::::::::!!;:::;!!;;:::::::::::::::''':%&$$$$|;:::;%&|:::'`````````'''```..`...````''!$@@&&&&&&&$$&@#####$\n;;;;;;;;;'..';;;;::''''''''''':|@@@@&&&&&&$%$&&&&&&&@@%:::::::::::::!|;:::::''''''';!;:;!!;:::::::::::::::::''':%&$$$%|;:::|&%;;:'''```````'''''``...      ```''!&@&&&&&&&&&&&&@###$\n:::;;;;;;;;!;;;'':;;;;:'''''''''':!&@@@&&&&&$$&&&&@@@$;::::::::::::';|:``````````'';!;;;:'''```````````````''''|$$$$%|;::|&$!;;:'````````''::''``....      .``'':%@&&&&&&&&&&&&&&@#$\n::::::::;;;;;;;;;;;;:'':;;:''''''''':;%@@@@&&&&$&@@@$;''''''':''`''`:|;````````````:!!:'''``.........``......`!$%%%%|;;|&$!:;'`````````'''::''.     ..    `''``''!$&&@@&&&&&&&&&&&&%\n###@%!:::::::;;;;;;;;;;;;;;;;::'''''::::|&@@@&&&&&&%'```.....````''`'||'``````````';;'''``................. .!$%%%%|!%&$!:;:'``'''````'::::''.       ....``''``'''|@&&&@&&&@&&&&&&$|\n####@&&&@&|;::::::;;;;;;;;;;;;;;;:'''''''::!&@@@@@%:````......```'```;%;`````````''''``.................   .!$%%%%%$&%;:::''```'''```'::::'`.         ...``'```''';$@&&&@@&&&&&&&&&%\n####@&&&&&&&&&$!:::::::;;;;;;;;;;;;;:''''''':|@@@$;````.......``''```'!%;``````''''``.......      ....    .;%%%%%%$%;::'''`````''''`'::::`.             ...`````'''|@&&&&@@&&&&&&&&%\n####@&&&&&&&&&&&&&&|;::::::;;;;;;;;;;;;:::'':;;%&;````.........``'````:||:```':''`......                .`:|%%%%%|;::''''``````'''''::::`.               ....```'''!$@&&&&@@&&&&&&&%\n####@&&&&&&&&&&&&&&&&&&|::::::::;;;;;;;;;:::::;;'````..........``'`````:||:':''`......                .`'!$%%%%|;:''```````````'''''::;'.                 ......``':%@@&&&&&@&&&&&&%\n####@&&&&&&&&&&&&&&&&&&&&&$!:::::::;;;;;;;;;;;;'`````..........`''``````:||:''`.  .                .``!$&$%%%%%;'''`````````````'':::;;`                   .....```'!&@&&&&&&@&&&&&%\n####@&&&&&&&&&&&&&&&&&&&&&&&&&|;:::::;;;;;;;;;:``````...........''````':':|%!'.                .``'|$&|;|%|%%%!''````...`````````':::;;`                    .....```'|@&&&&&&&@&&&&%\n####@&&&&&&&&&&&&&&&&&&&&&&&&&&&$!::::::;;;;;:``````....``......''``':'''':!|%;..         ..``:|%$|;::;|%||%%!'`````......```''`'':::;:'   .......           ....````:%@&&&&&&@@&&&%\n####@&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&%;:::::;;:```````....`.   ...`'':''`.  .':!||;````````';|%%|;::::';|%||%%;'```.........```'''''::::;'. ....````........  ......````:%@&&&&&&@@&&%\n####@&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&|:::::'```````...``.   ..'::'``.   .```':;!||!;;!||!;::::''``';|%||%|;'```..........```'''''::::;:.....``````````...........`````;&&&&&&&@@@&%\n*/\n\nint n;\nint a[105];\nconst int Mod=1'000'000'007;\n\nint ksmii(int a,int b){\n\tif(!b){\n\t\treturn 1;\n\t}\n\tint ff=ksmii(a,b>>1);\n\tff=1LL*ff*ff%Mod;\n\tif(b&1){\n\t\tff=1LL*ff*a%Mod;\n\t}\n\treturn ff;\n}\n\npair<int,int> solve(int l,int r,int lim){\n\tint minx=Mod,cnt;\n\tfor(int i=l;i<=r;i++){\n\t\tif(a[i]<minx){\n\t\t\tminx=a[i];\n\t\t\tcnt=1;\n\t\t}else if(a[i]==minx){\n\t\t\tcnt++;\n\t\t}\n\t}\n\tif(cnt==r-l+1){\n\t\treturn make_pair((ksmii(2,r-l+1)-2+Mod)%Mod,ksmii(2,minx-lim-1));\n\t}\n\tpair<int,int> ans;\n\tint L=-1,rem=r-l+1;\n\tint x1=1,x2=1;\n\tfor(int i=l;i<=r+1;i++){\n\t\tif(L==-1&&a[i]>minx){\n\t\t\tL=i;\n\t\t}else if(L!=-1&&a[i]<=minx){\n\t\t\trem-=i-L;\n\t\t\tpair<int,int> tmp=solve(L,i-1,minx);\n\t\t\tx1=1LL*x1*(tmp.first+4LL*tmp.second%Mod)%Mod;\n\t\t\tx2=2LL*x2*tmp.second%Mod;\n\t\t\tL=-1;\n\t\t}\n\t}\n\tx1=(x1-x2+Mod)%Mod;\n\tans.first=((1LL*x1*ksmii(2,rem)%Mod)+(1LL*x2*((ksmii(2,rem)-2+Mod)%Mod)%Mod))%Mod;\n\tans.second=1LL*x2*ksmii(2,minx-lim-1)%Mod;\n\treturn ans;\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d\",a+i);\n\t}\n\tif(n==1){\n\t\tprintf(\"%d\\n\",ksmii(2,a[1]));\n\t\treturn 0;\n\t}\n\tint peak=1;\n\tfor(int i=1;i<=n;i++){\n\t\tif(a[i]>a[i-1]&&a[i]>a[i+1]){\n\t\t\tpeak=1LL*peak*ksmii(2,a[i]-max(a[i-1],a[i+1]))%Mod;\n\t\t\ta[i]=max(a[i-1],a[i+1]);\n\t\t}\n\t}\n\tpair<int,int> ans=solve(1,n,0);\n\tprintf(\"%lld\\n\",1LL*peak*((ans.first+2LL*ans.second%Mod)%Mod)%Mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n\n#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n#include <bitset>\n#include <list>\n\nauto& in = std::cin;\nauto& out = std::cout;\n#define all_range(C) std::begin(C), std::end(C)\nconst double PI = 3.141592653589793238462643383279502884197169399375105820974944;\n\ntemplate<typename Arithmetic, typename Integral>\nstd::enable_if_t< std::is_unsigned<Integral>::value, Arithmetic>\nipow(Arithmetic bace, Integral n)\n{\n\t//繰り返し二条法\n\tauto res = (Arithmetic)(1);\n\twhile (n > 0) {\n\t\tif (n & 1) res *= bace;\n\t\tbace *= bace;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\nconstexpr bool is_prime(uint32_t N)\n{\n\tif (N <= 1) {\n\t\treturn false;\n\t}\n\tfor (size_t i = 2; i*i <= N; ++i)\n\t{\n\t\tif (N%i == 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate <uint64_t MOD> class mint_base;\n//mint_base_base型用の累乗関数\ntemplate <uint64_t MOD> constexpr mint_base<MOD> m_pow(mint_base<MOD> x, uint64_t n)noexcept;\n//mod計算を自動で行う整数テンプレートクラス\ntemplate <uint64_t MOD_ = 1000000007>\nclass mint_base\n{\npublic:\n\tstatic constexpr auto MOD = MOD_;\n\tstatic_assert(!(MOD <= 2), \"MOD cannot be below 2.\");\n\tstatic_assert(MOD <= (0xFFFFFFFFFFFFFFFF / 2), \"MOD is too big\");//加算してオーバーフローしない\n\tstatic_assert(MOD <= 0xFFFFFFFF, \"MOD is too big\");//乗算してオーバーフローしない\n\tconstexpr mint_base<MOD> operator+(const mint_base<MOD> &other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v += other;\n\t}\n\tconstexpr mint_base<MOD> operator-(const mint_base<MOD> &other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v -= other;\n\t}\n\tconstexpr mint_base<MOD> operator*(const mint_base<MOD> &other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v *= other;\n\t}\n\tconstexpr auto operator/(const mint_base<MOD> &other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v /= other;\n\t}\n\tconstexpr mint_base<MOD>& operator+=(const mint_base<MOD> &other) noexcept\n\t{\n\t\ta += other.a;\n\t\tif (MOD <= a) { a -= MOD; };\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator-=(const mint_base<MOD> &other) noexcept\n\t{\n\t\tif (a >= other.a) {\n\t\t\ta -= other.a;\n\t\t}\n\t\telse {\n\t\t\ta = (a + MOD) - other.a;\n\t\t}\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator*=(const mint_base<MOD> &other) noexcept\n\t{\n#if 1\n\t\ta *= other.a;\n\t\ta %= MOD;\n#else\n\t\t//MOD <= (MAXUINT64 / 2)条件下\n\t\tuint64_t b = other.a, v = 0;\n\t\twhile (b > 0) {\n\t\t\tif (b & 1) {\n\t\t\t\tv += a;\n\t\t\t\tif (v >= MOD)v -= MOD;\n\t\t\t}\n\t\t\ta += a;\n\t\t\tif (MOD <= a)a -= MOD;\n\t\t\tb >>= 1;\n\t\t}\n\t\ta = v;\n#endif\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator/=(const mint_base<MOD> &other) noexcept\n\t{\n\t\treturn *this *= ~other;\n\t}\n\tconstexpr mint_base<MOD> operator+()const noexcept { return *this; }\n\tconstexpr mint_base<MOD> operator-()const noexcept\n\t{\n\t\treturn{ MOD - a, mod_value_tag{} };\n\t}\n\tconstexpr mint_base<MOD>& operator++() noexcept\n\t{\n\t\tif (MOD <= ++a) { a = 0; };\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator--() noexcept\n\t{\n\t\tif (a <= 0) { a = MOD; };\n\t\t--a;\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD> operator++(int) noexcept\n\t{\n\t\tauto tmp = *this;\n\t\t++*this;\n\t\treturn tmp;\n\t}\n\tconstexpr mint_base<MOD> operator--(int) noexcept\n\t{\n\t\tauto tmp = *this;\n\t\t--*this;\n\t\treturn tmp;\n\t}\n\tconstexpr mint_base<MOD> operator~()const noexcept\n\t{\n\t\treturn ipow(*this, e_phi - 1);\n\t}\n\tconstexpr mint_base<MOD>& operator=(const mint_base<MOD> &other) noexcept\n\t{\n\t\ta = other.a;\n\t\treturn *this;\n\t}\n\tconstexpr explicit operator uint64_t()const noexcept\n\t{\n\t\treturn a;\n\t}\n\tconstexpr explicit operator unsigned()const noexcept\n\t{\n\t\treturn (unsigned)a;\n\t}\n\tstatic constexpr uint64_t getmod() noexcept\n\t{\n\t\treturn MOD;\n\t}\n\tconstexpr mint_base(uint64_t a_) noexcept :a(a_ % MOD) {}\n\tconstexpr mint_base()noexcept : a(0) {}\n\tstruct mod_value_tag {};\n\tconstexpr mint_base(uint64_t a_, mod_value_tag) :a(a_) {}\nprivate:\n\tstatic constexpr uint64_t get_e_phi()noexcept {\n\t\t//オイラー値の導出\n\t\tuint64_t temp = MOD;\n\t\tuint64_t m_ = MOD;\n\t\tfor (uint64_t i = 2; i * i <= m_; ++i)\n\t\t{\n\t\t\tif (m_ % i == 0)\n\t\t\t{\n\t\t\t\ttemp = temp / i * (i - 1);\n\t\t\t\tfor (; m_ % i == 0; m_ /= i);\n\t\t\t}\n\t\t}\n\t\tif (m_ != 1)temp = temp / m_ * (m_ - 1);\n\t\treturn temp;\n\t}\n\tstatic constexpr uint64_t e_phi = get_e_phi();//オイラー値\n\tuint64_t a;\n};\n//mint_base型用の累乗関数\ntemplate<uint64_t MOD>constexpr mint_base<MOD> m_pow(mint_base<MOD> x, uint64_t n)noexcept\n{\n\tmint_base<MOD> res = 1;\n\twhile (n > 0)\n\t{\n\t\tif (n & 1)res *= x;\n\t\tx *= x;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n//mint_baseの階乗計算\n//O(x)時間が必要のため、fact_set関数を推奨する。\ntemplate<uint64_t MOD>constexpr mint_base<MOD> fact(mint_base<MOD> x)noexcept\n{\n\tmint_base<MOD> res(1);\n\tfor (uint64_t i = 1; i <= (uint64_t)x; ++i)\n\t{\n\t\tres *= i;\n\t}\n\treturn res;\n}\n//mint_baseの階乗計算\n//0からxまでの階乗を返す\n//O(x)時間が必要\ntemplate<uint64_t MOD>std::vector<mint_base<MOD>> fact_set(mint_base<MOD> x = mint_base<MOD>(-1))\n{\n\tmint_base<MOD> res(1);\n\tstd::vector<mint_base<MOD>> set((uint64_t)(x)+1);\n\tset[0] = 1;\n\tfor (uint64_t i = 1; i <= (uint64_t)x; ++i)\n\t{\n\t\tres *= i;\n\t\tset[i] = res;\n\t}\n\treturn res;\n}\n//mint_base型のstreamへの出力\ntemplate<uint64_t MOD> std::ostream& operator<<(std::ostream& os, mint_base<MOD> i)\n{\n\tos << (uint64_t)i;\n\treturn os;\n}\n//mint_base型のstreamからの入力\ntemplate<uint64_t MOD> std::istream& operator >> (std::istream& is, mint_base<MOD>& i)\n{\n\tuint64_t tmp;\n\tis >> tmp;\n\ti = tmp;\n\treturn is;\n}\ntypedef mint_base<1000000007> mint;\nnamespace mint_literal {\n\tconstexpr mint operator\"\"_mi(unsigned long long x)noexcept {\n\t\treturn mint(x);\n\t}\n}\nusing namespace mint_literal;\n//mint_baseの階乗計算\n//0からxまでの階乗を返す\n//O(N)\ntemplate<int32_t X, uint64_t MOD = mint::MOD>\n/*constexpr*/ std::array<mint_base<MOD>, X + 1> fact_set_c()\n{\n\tmint_base<MOD> res(1);\n\tstd::array<mint_base<MOD>, X + 1> set;\n\tset[0] = 1;\n\tfor (int32_t i = 1; i <= X; ++i)\n\t{\n\t\tres *= i;\n\t\tset[i] = res;\n\t}\n\treturn set;\n}\ntemplate<typename RET = mint, typename Integral>\nRET combination(Integral all, Integral get)\n{\n\tassert(all >= get);\n\tget = std::min(all - get, get);\n#if 1\n\t//時間計算量O(1)+初期化O(NlogMOD)\n\tstatic_assert(false, \"\");\n\tstatic const auto fact_v = fact_set_c<要素数 + 1>();\n\tstatic const auto fact_div_v = [&]() {\n\t\tauto tmp = fact_v;\n\t\tfor (auto& i : tmp) { i = ~i; }\n\t\treturn tmp;\n\t}();\n\t//return fact_v[all] / (fact_v[get] * fact_v[all - get]);\n\treturn fact_v[all] * fact_div_v[get] * fact_div_v[all - get];\n#elif 0\n\t//時間計算量O(1)\n\t//空間計算量、初期化時間計算量O(N^2)\n\tconstexpr int32_t ALL_MAX = 要素数;// 10'000;\n\tstatic std::vector<RET> DP_comb[ALL_MAX + 1];\n\tif (!DP_comb[all].empty())\n\t{\n\t\treturn DP_comb[all][get];\n\t}\n\n\tif (DP_comb[0].empty())\n\t{\n\t\tDP_comb[0].resize(1);\n\t\tDP_comb[0][0] = (RET)1;\n\t\tDP_comb[1].resize(1);\n\t\tDP_comb[1][0] = (RET)1;\n\t}\n\tfor (int32_t i = 2; i <= all; i++)\n\t{\n\t\tif (DP_comb[i].empty())\n\t\t{\n\t\t\tint32_t size = i / 2 + 1;\n\t\t\tDP_comb[i].resize(size);\n\t\t\tDP_comb[i][0] = (RET)1;\n\t\t\tfor (int32_t j = 1; j < size - 1; j++)\n\t\t\t{\n\t\t\t\tDP_comb[i][j] = DP_comb[i - 1][j - 1] + DP_comb[i - 1][j];\n\t\t\t}\n\t\t\tDP_comb[i][size - 1] = DP_comb[i - 1][size - 2] + DP_comb[i - 1][(i & 1) ? (size - 1) : (size - 2)];\n\t\t}\n\t}\n\treturn DP_comb[all][get];\n#else\n\t//時間計算量O(get * logMOD)\n\tRET ret = (RET)1;\n\tfor (Integral i = 1; i <= get; ++i)\n\t{\n\t\tret *= all + 1 - i;\n\t\tret /= i;\n\t}\n\treturn ret;\n#endif\n}\n\nint32_t N;\nint32_t h[110];\nstd::map<int32_t, int32_t> sorted_h;\n\nmint dp[100][110];\nbool used[100][110];\nmint func(int32_t i, int32_t h_max)//r==3で呼び出されたら、funcは3を作れるh[i]が[0,h_max]なら\n{\n\tif (i == N+1) {\n\t\treturn 1_mi;\n\t}\n\tauto& memo = dp[i][sorted_h[h_max]];\n\tif (used[i][sorted_h[h_max]]) {\n\t\treturn memo;\n\t}\n\tused[i][sorted_h[h_max]] = true;\n\tmemo = 0;\n\n\tif (h[i] < 2) {\n\t\tmemo += 2_mi*func(i + 1, h[i]);\n\t\treturn memo;\n\t}\n\n\tif (h[i-1]<= h_max && h[i-1] <= h[i]) {\n\t\th_max = h[i];\n\t}\n\tif (h[i] < h_max) {\n\t\th_max=h[i];\n\t}\n\n\tfor(auto iter = sorted_h.begin(),iter_next = std::next(iter);iter_next!= sorted_h.end();++iter,++iter_next)\n\t{\n\t\tauto& nexth = *iter;\n\t\tif (nexth.first < h[i - 1]) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (nexth.first >= h_max) {\n\t\t\tbreak;\n\t\t}\n\n\t\tmemo += 2_mi*(ipow(2_mi, (unsigned)(iter_next->first - nexth.first)) - 1)*ipow(2_mi, (unsigned)(h[i] - iter_next->first))*func(i+1, nexth.first);\n\n\t}\n\tif (h[i] == h_max) {\n\t\tmemo += 2_mi * func(i + 1, h[i]);\n\t}\n\tmemo += func(i + 1, h_max)*ipow(2_mi, (unsigned)(std::max(0,h[i]-h[i-1])));\n\treturn memo;\n\n\t/*\n\tif (h[i] < 2) {\n\t\tmemo += func(i + 1, 0);\n\t\tmemo += func(i + 1, 1);\n\t\treturn memo;\n\t}\n\n\n\tauto diff = h[i] - h[i - 1];\n\tif (h[i - 1] < 2) {\n\t\tうわあ;\n\t\tdiff = h[i]-2;\n\n\t\tmemo += func(i+1,0);\n\t\tmemo += 2_mi*func(i + 1, 1);\n\t\tmemo += func(i + 1, 2);\n\n\t\tmemo *= ipow(2_mi, (unsigned)(diff));\n\t\treturn memo;\n\t}\n\n\n\tmint mul = 1_mi;\n\n\tif (diff <= 0) {\n\t}\n\telse {\n\t\tmul = ipow(2_mi, (unsigned)(diff));\n\t}\n\n\tif (r == 3) {\n\t\tauto target = h[i + 1];\n\t\tif (target <= h[i - 1]) {\n\t\t\tmemo = 2_mi*func(i + 1, 3)*mul;\n\t\t}\n\t\telse {\n\t\t\tauto free = std::max(0, h[i] - h[i + 1]);\n\t\t\tauto FREE_mul = ipow(2_mi, (unsigned)(free));\n\t\t\tmemo += 2_mi*func(i + 1, 3)*FREE_mul;\n\t\t\tif (diff > 0) {\n\t\t\t\tmemo += 2_mi*func(i + 1, 1)*(mul-1);\n\t\t\t}\n\t\t}\n\t}\n\telse if (r == 1) {\n\t\tmemo = func(i + 1, 1)＊mul; うわあ;\n\t}\n\telse if (r == 2) {\n\t\tmemo = func(i + 1, 0)*mul;\n\t}\n\telse if(r==0){\n\t\tmemo = func(i + 1, 2)*mul;\n\t}\n\t*/\n\treturn memo;\n}\n\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\tin.tie(nullptr);\n\tout.tie(nullptr);\n\n\tin >> N;\n\tsorted_h.emplace(1, 1); h[0] = 1;\n\tfor (size_t i = 1; i <= N; i++)\n\t{\n\t\tin >> h[i];\n\t\tsorted_h.emplace(h[i],i);\n\t}\n\tout << func(1, 1) << endl;\n\n\n\treturn 0;\n}\n#endif\n\n\n#if 0\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n#include <bitset>\n#include <list>\n\nauto& in = std::cin;\nauto& out = std::cout;\n#define all_range(C) std::begin(C), std::end(C)\nconst double PI = 3.141592653589793238462643383279502884197169399375105820974944;\n\nint32_t N;\nstd::string s;\nchar count[256];\n\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\tin.tie(nullptr);\n\tout.tie(nullptr);\n\n\tin >> N>>s;\n\tfor (auto& c : s) {\n\t\tcount[c]++;\n\t}\n\tfor (size_t i = 0; i < 256; i++)\n\t{\n\t\tif (count[i] % 2) {\n\t\t\tout << 0 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\n\n\treturn 0;\n}\n#endif\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\nconst double PI = 3.14159265358979323846;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\n//繰り返し二乗法\nint mod_pow(int x, int n, int m) {\n    if (n == 0)\n        return 1;\n    int res = mod_pow(x * x % m, n / 2, m);\n    if (n & 1)\n        res = res * x % m;\n    return res;\n}\n\nint N;\nint h[110];\nint dp[110][220];\nunordered_map<int, int> mp;\nint mp_inv[220];\nint mod = 1e9 + 7;\nsigned main() {\n    cin >> N;\n    for (int i = 1; i <= N; i++)cin >> h[i];\n\n    set<int> st;\n    st.insert(0), st.insert(1);\n    for (int i = 1; i <= N; i++)st.insert(h[i]), st.insert(h[i] - 1);\n    vint mp_inv(st.begin(), st.end());\n    for (int i = 0; i < mp_inv.size(); i++)mp[mp_inv[i]] = i;\n\n    dp[0][1] = 1;\n    h[0] = 1;\n    for (int i = 0; i < N; i++) {\n        if (h[i] < h[i + 1]) {\n            for (int j = 1; j < mp[h[i]]; j++)dp[i + 1][j] = dp[i][j] * mod_pow(2, h[i + 1] - h[i], mod) % mod;\n            for (int j = mp[h[i]]; j < mp[h[i + 1]]; j++) {\n                int a = h[i + 1] - mp_inv[j];\n                int b = mp_inv[j] - mp_inv[j - 1];\n                dp[i + 1][j] = dp[i][mp[h[i]]] * mod_pow(2, a, mod) % mod * (mod_pow(2, b, mod) - 1 + mod) % mod;\n            }\n            dp[i + 1][mp[h[i + 1]]] = dp[i][mp[h[i]]] * 2 % mod;\n\n        } else {\n            for (int j = 1; j < mp[h[i + 1]]; j++)dp[i + 1][j] = dp[i][j];\n            for (int jp = mp[h[i + 1]]; jp <= mp[h[i]]; jp++)(dp[i + 1][mp[h[i + 1]]] += 2 * dp[i][jp]) %= mod;\n        }\n    }\n    int ans = 0;\n    for (int i = 0; i < 220; i++)(ans += dp[N][i]) %= mod;\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nlong long N, H[100009], dp[109][109], mod = 1000000007; vector<pair<int, int>>vec[100009];\n\nlong long modpow(long long a, long long b, long long m) {\n\tlong long p = 1, q = a;\n\tfor (int i = 0; i < 63; i++) {\n\t\tif ((b / (1LL << i)) % 2 == 1) { p *= q; p %= m; }\n\t\tq *= q; q %= m;\n\t}\n\treturn p;\n}\n\nint main() {\n\tcin >> N;\n\tfor (int i = 1; i <= N; i++) cin >> H[i];\n\tH[0] = 1; H[N + 1] = 1;\n\tfor (int i = 1; i <= N; i++) {\n\t\tlong long minx = (1LL << 60);\n\t\tfor (int j = i; j <= N; j++) {\n\t\t\tminx = min(minx, H[j]);\n\t\t\tif (H[i - 1] < minx && minx > H[j + 1]) vec[j].push_back(make_pair(i, minx - max(H[i - 1], H[j + 1])));\n\t\t}\n\t}\n\tdp[0][1] = 1;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 1; j <= N; j++) {\n\t\t\tlong long K = 0; for (int k = 0; k < vec[i + 1].size(); k++) { if (vec[i + 1][k].first >= j) K += vec[i + 1][k].second; }\n\t\t\tlong long L = modpow(2, K, mod);\n\t\t\tdp[i + 1][j] += dp[i][j] * L; dp[i + 1][j] %= mod;\n\t\t\tlong long K1 = 0; for (int k = 0; k < vec[i + 1].size(); k++) { if (vec[i + 1][k].first >= i + 1) { K1 += vec[i + 1][k].second; } }\n\t\t\tlong long L1 = modpow(2, K1, mod);\n\t\t\tdp[i + 1][i + 1] += dp[i][j] * L1; dp[i + 1][i + 1] %= mod;\n\t\t}\n\t}\n\tlong long sum = 0;\n\tfor (int i = 1; i <= N; i++) sum += dp[N][i];\n\tcout << sum%mod << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long LL;\nusing namespace std;\n\nconst int N=105;\nconst int MOD=1000000007;\nint n,f[N][N],a[N],w[N],m;\n\nint ksm(int x,int y){\n    if (y<0) return 1;\n    int ans=1;\n    while (y){\n        if (y&1) ans=(LL)ans*x%MOD;\n        x=(LL)x*x%MOD;y>>=1;\n    }\n    return ans;\n}\n\nint solution(){\n  for(int i=1;i<=n;i++){\n    w[++m] = a[i];\n  }\n  sort(w+1,w+m+1);\n  m = unique(w+1,w+m+1)-w-1;\n  for (int i=1;i<=n;i++) a[i]=lower_bound(w+1,w+m+1,a[i])-w;\n  f[0][0]=1;\n  for (int i=1;i<=n;i++)\n  {\n      for (int j=a[i]+1;j<=a[i-1];j++) (f[i][0]+=f[i-1][j]*2%MOD)%=MOD;\n      (f[i][0]+=f[i-1][0]*2%MOD)%=MOD;\n      for (int j=1;j<=a[i];j++)\n      {\n          f[i][j]=(LL)f[i-1][j]*ksm(2,w[a[i]]-w[a[i-1]])%MOD;\n          if (a[i-1]>=j) continue;\n          if (j>1) (f[i][j]+=(LL)f[i-1][0]*(ksm(2,w[j]-w[j-1])-1)%MOD*2%MOD*ksm(2,w[a[i]]-w[j])%MOD)%=MOD;\n          else (f[i][j]+=(LL)f[i-1][0]*(ksm(2,w[j])-2)%MOD*ksm(2,w[a[i]]-w[j])%MOD)%=MOD;\n      }\n  }\n  int ans=0;\n  for (int i=0;i<=m;i++) (ans+=f[n][i])%=MOD;\n  return ans;\n}\n\nint main()\n{\n    scanf(\"%d\",&n);\n    for (int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n    int res = solution();\n    cout<<res<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> ii;\nconst int MN = 110;\nconst ll M = 1e9+7;\ninline ll mul(ll a, ll b) {return (a*b)%M;}\nll bp(ll b, ll p) {\n\tll ac = 1;\n\twhile(p) {\n\t\tif(p&1) {\n\t\t\tac = mul(b,ac);\n\t\t}\n\t\tb = mul(b,b);\n\t\tp >>= 1;\n\t}\n\treturn ac;\n}\ninline ll norm(ll val) {\n\treturn (val<0)?val%M+M:val%M;\n}\nll dp[MN][MN];\nll hc[MN][MN];\nll va[MN];\nll w[MN],wa[MN];\nll lim[MN],rs[MN][MN];\nll n;\nll ds(ll r, ll h) {\n\tif(r >= n-1) {return 1;}\n\tif(dp[r][h] != -1) {\n\t\treturn dp[r][h];\n\t}\n\tif(h > wa[r]) {\n\t\treturn dp[r][h] = ds(r,wa[r]);\n\t}\n\tif(wa[r] == 0) {\n\t\treturn dp[r][h] = ds(r+1,0);\n\t}\n\tll hv = 0;\n\tif(h == wa[r]) {\n\t\thv = 0;\n\t} else {\n\t\thv = 0;\n\t\tfor(int i=h;i<wa[r];i++) {\n\t\t\tll sz = va[i+1];\n\t\t\tll ot = hc[r][i+1]-sz;\n\t\t\thv += mul(mul(norm(bp(2,sz)-1),bp(2,ot)),ds(rs[r][i+1],wa[r]));\n\t\t}\n\t}\n\tll vv = ds(r+1,max(wa[r],h));\n\tll ev = ds(r+1,wa[r]);\n\treturn dp[r][h] = norm(hv+vv+ev);\n}\nint main() {\n\tcin >> n;\n\tmemset(lim,-1,sizeof(lim));\n\tmemset(dp,-1,sizeof(dp));\n\tmemset(hc,0,sizeof(hc));\n\tfor(int i=0;i<n;i++) {\n\t\tcin >> w[i];\n\t}\n\tif(n == 1) {\n\t\tcout << bp(2,w[0]) << '\\n';\n\t\treturn 0;\n\t}\n\tll los = 0;\n\tfor(int i=0;i<n-1;i++) {\n\t\twa[i] = min(w[i],w[i+1]);\n\t\tlim[i] = max(lim[i],wa[i]);\n\t\tlim[i+1] = max(lim[i+1],wa[i]);\n\t\twa[i]--;\n\t}\n\tfor(int i=0;i<n;i++) {\n\t\tif(lim[i] == 1) {lim[i] = 0;}\n\t\tlos += w[i]-lim[i];\n\t}\n\tset<ll> bs;\n\tfor(int i=0;i<n-1;i++) {\n\t\tbs.insert(wa[i]);\n\t}\n\tbs.insert(0);\n\tll lst = 0;\n\tll ctr = 0;\n\tmap<ll,ll> mo;\n\tfor(auto& it: bs) {\n\t\tmo[it] = ctr;\n\t\tva[ctr] = it-lst;\n\t\tctr++;\n\t\tlst = it;\n\t}\n\tfor(int i=0;i<n-1;i++) {\n\t\twa[i] = mo[wa[i]];\n\t}\n\tfor(int i=0;i<n;i++) {\n\t\tfor(int j=0;j<n-1;j++) {\n\t\t\tint r = j;\n\t\t\twhile(r < n-1 && wa[r] >= i) {\n\t\t\t\tr++;\n\t\t\t}\n\t\t\trs[j][i] = r;\n\t\t}\n\t}\n\tfor(int i=1;i<n;i++) {\n\t\tfor(int j=0;j<n-1;j++) {\n\t\t\tfor(int k=i;k<n;k++) {\n\t\t\t\tfor(int l=j;l<rs[j][i];l++) {\n\t\t\t\t\tif((l <= j || wa[l-1] < k) && wa[l] >= k) {\n\t\t\t\t\t\thc[j][i] += va[k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll res = ds(0,0);\n\tint x = 0;\n\twhile(x < n-1) {\n\t\tif(rs[x][1] == x) {\n\t\t\tx++;\n\t\t} else {\n\t\t\tres = mul(res,2);\n\t\t\tx = rs[x][1];\n\t\t}\n\t}\n\tres = mul(res,bp(2,los));\n\tcout << res << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N=150,mo=1e9+7;\nint fap(int a,int b){\n    if (b<=0) return 1;\n    int s=1;\n    for (; b; b>>=1,a=1ll*a*a%mo)\n\tif (b&1) s=1ll*s*a%mo;\n    return s;\n}\nvoid cal(int &x,int y){\n    (x+=y)%=mo; return;\n}\nint n,h[N],a[N],f[N][N];\nint main(){\n    cin>>n;\n    for (int i=1; i<=n; ++i)\n\tcin>>h[i],a[i]=h[i];\n    int tmp=n;\n    sort(a+1,a+n+1);\n    tmp=unique(a+1,a+n+1)-a-1;\n    for (int i=1; i<=n; ++i)\n\th[i]=lower_bound(a+1,a+tmp+1,h[i])-a;\n    f[0][0]=1;\n    for (int i=1; i<=n; ++i){\n\tf[i][0]=f[i-1][0]*2%mo;\n\tfor (int j=h[i]+1; j<=h[i-1]; ++j)\n\t    cal(f[i][0],f[i-1][j]*2%mo);\n\ttmp=fap(2,a[h[i]]-a[h[i-1]]);\n\tfor (int j=min(h[i],h[i-1]); j; --j)\n\t    cal(f[i][j],1ll*tmp*f[i-1][j]%mo);\n\tfor (int j=h[i-1]+1; j<=h[i]; ++j){\n\t    if (j==1)\n\t\tcal(f[i][j],1ll*f[i-1][0]*(fap(2,a[1])-2)%mo*fap(2,a[h[i]]-a[j])%mo);\n\t    else\n\t\tcal(f[i][j],2ll*f[i-1][0]*(fap(2,a[j]-a[j-1])-1)%mo*fap(2,a[h[i]]-a[j])%mo);\n\t}\n    }\n    int ans=0;\n    for (int i=0; i<=h[n]; ++i)\n\tcal(ans,f[n][i]);\n    cout<<ans;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#define ll long long\nusing namespace std;\nconst ll MOD=1e9+7;\nint n,sa[105],rnk[105];\nll k,h[105],s[105],f0;\nll quick_pow(ll x,ll a)\n{\n\tll ans=1;\n\twhile(a)\n\t{\n\t\tif(a&1)ans=ans*x%MOD;\n\t\tx=x*x%MOD;\n\t\ta>>=1;\n\t}\n\treturn ans;\n}\nbool cmp(int a,int b)\n{\n\treturn h[a]<h[b];\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%lld\",&h[i]);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tsa[i]=i;\n\t\tif(n!=1&&h[i]>max(h[i-1],h[i+1]))\n\t\t{\n\t\t\tk+=h[i]-max(h[i-1],h[i+1]);\n\t\t\th[i]=max(h[i-1],h[i+1]);\n\t\t}\n\t}\n\tsort(sa+1,sa+n+1,cmp);\n\tfor(int i=1;i<=n;i++)rnk[sa[i]]=i;\n\tf0=1;\n\th[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(rnk[i]<rnk[i-1])f0=(f0*2+(s[rnk[i-1]]-s[rnk[i]]+MOD)*2)%MOD;\n\t\telse\n\t\t{\n\t\t\tfor(int j=1;j<=rnk[i-1];j++)\n\t\t\t  s[j]=s[j]*quick_pow(2,h[i]-h[i-1])%MOD;\n\t\t\tfor(int j=rnk[i-1]+1;j<=rnk[i];j++)\n\t\t\t  s[j]=(s[j-1]+f0*2*(quick_pow(2,h[i]-h[sa[j-1]])-quick_pow(2,h[i]-h[sa[j]])+MOD))%MOD;\n\t\t\tf0=f0*2%MOD;\n\t\t}\n\t}\n\tll ans=s[rnk[n]]+f0;\n\tans=ans%MOD*quick_pow(2,k)%MOD;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int LL;\ntypedef pair <LL, LL> pii;\nconst LL MOD = 1000000007LL;\nconst int MAXN = 105, INF = 1000000001;\n\nint n, h[MAXN];\n\ninline LL mul(LL a, LL b){return a * b % MOD;}\ninline LL quickPow(LL base, int times){\n\tLL ret = 1LL;\n\twhile(times){\n\t\tif(times & 1) ret = ret * base % MOD;\n\t\tbase = base * base % MOD;\n\t\ttimes >>= 1;\n\t} return ret;\n}\npii solve(int l, int r, int b){\n\tint i, j, mn = INF; pii f, tmp;\n\tfor(i = l; i <= r; ++ i)\n\t\tif(h[i] < mn) mn = h[i];\n\tfor(i = l; i <= r; i = j + 1)\n\t\tif(h[i] > mn){\n\t\t\tfor(j = i; j < r && h[j + 1] > mn; ++ j) ;\n\t\t\ttmp = solve(i, j, mn);\n\t\t\tif(i == l) f = pii(mul(tmp.first, 2), tmp.second);\n\t\t\telse f = pii(mul(mul(tmp.first, f.first), 2), (mul(mul(f.first, tmp.first), 4) + mul(mul(f.first, tmp.second), 2) + mul(mul(f.second, tmp.first), 4) + mul(f.second, tmp.second)) % MOD);\n\t\t}else{\n\t\t\tj = i;\n\t\t\tif(i == l) f = pii(1, 0);\n\t\t\telse f = pii(f.first, (f.first * 2 + f.second * 2) % MOD);\n\t\t}\n\treturn pii(f.first * quickPow(2, mn - b - 1) % MOD, f.second);\n}\nint main(){\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i <= n; ++ i)\n\t\tscanf(\"%d\", &h[i]);\n\tauto ret = solve(1, n, 0);\n\tprintf(\"%d\\n\", int((ret.first * 2 + ret.second) % MOD));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#define ll long long\nusing namespace std;\ntemplate <class T>\ninline void rd(T &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile(!isdigit(c)) { if(c=='-') f=-1; c=getchar(); }\n\twhile(isdigit(c)) x=x*10-'0'+c,c=getchar(); x*=f;\n}\nconst int N=110,mod=1e9+7;\ninline int Pow(int x,int y) { int res=1; for(;y;y>>=1,x=x*(ll)x%mod) if(y&1) res=res*(ll)x%mod; return res; }\nint f[N][N][2],vis[N][N],h[N],minv[N][N],n;\nvoid sol(int l,int r) {\n\tif(vis[l][r]||l>r) return;\n\tvis[l][r]=1;\n\tminv[l][r]=1e9;\n\tfor(int i=l;i<=r;++i) minv[l][r]=min(minv[l][r],h[i]);\n\tint lst=l-1,tot=0;\n\tf[l][r][0]=f[l][r][1]=1;\n\tfor(int i=l;i<=r+1;++i) if(h[i]==minv[l][r]||i==r+1) {\n\t\tint L=lst+1,R=i-1; sol(L,R),lst=i;\n\t\tif(L<=R) {\n\t\t\tf[l][r][0]=f[l][r][0]*(ll)f[L][R][0]%mod*Pow(2,minv[L][R]-minv[l][r]-1)%mod;\n\t\t\tf[l][r][1]=f[l][r][1]*(ll)(f[L][R][0]*(ll)Pow(2,minv[L][R]-minv[l][r])%mod+f[L][R][1])%mod;\n\t\t\ttot+=R-L+1;\n\t\t}\n\t}\n\tf[l][r][0]=f[l][r][0]*2ll%mod;\n\tf[l][r][1]=(f[l][r][1]*(ll)Pow(2,r-l+1-tot)%mod-f[l][r][0])%mod;\n}\t\t\n\t\nint main() {\n\trd(n);\n\tfor(int i=1;i<=n;++i) rd(h[i]);\n\tsol(1,n);\n\tint ans=(f[1][n][0]*(ll)Pow(2,minv[1][n]-1)%mod+f[1][n][1])%mod;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//c++ -std=gnu++14 a.cpp\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n#include <tuple>\n#include <iomanip>\n#include <climits>\n#include <fstream>\n#include <random>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n//typedef pair<ll, ll> P;\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define revrep(i, n) for(int i = (n)-1; i >= 0; i--)\n#define pb push_back\n#define f first\n#define s second\n#define chmin(x, y) x = min(x, y);\n#define chmax(x, y) x = max(x, y);\n#define sz(x) ((int)(x).size())\n\n//const ll INFL = LLONG_MAX;//10^18 = 2^60\nconst ll INFL = 1LL<<60;\n//const int INF = INT_MAX;\nconst int INF = 1 << 30;//10^9\nconst int MOD = 1000000007;\n//const int MOD = 998244353;\n//int MOD = 1000000007;\ndouble EPS = 1e-10;\n\nvector<ll> dy = {0, 1, 0, -1, 1, 1, -1, -1, 0};\nvector<ll> dx = {1, 0, -1, 0, 1, -1, 1, -1, 0};\n\nvoid pres(double A){printf(\"%.12lf\\n\", A);}\nvoid BinarySay(ll x, ll y = 60){rep(i, y) cout << (x>>(y-1-i) & 1); cout << endl;}\nll cnt_bit(ll x){return __builtin_popcountll(x);}\n\nll pow_long(ll x, ll k){\n  ll res = 1;\n  while(k > 0){\n    if(k % 2) res *= x;\n    x *= x; k /= 2;\n  }\n  return res;\n}\n\nll pow_mod(ll x, ll k){\n  x %= MOD;\n  ll res = 1;\n  while(k > 0){\n    if(k % 2){\n      res *= x; res %= MOD;\n    }\n    x *= x; x %= MOD;\n    k /= 2;\n  }\n  return res;\n}\n\nll inverse(ll x){return pow_mod(x, MOD - 2);};\n\nll gcd(ll a, ll b){\n    if(b == 0) return a;\n    return gcd(b, a % b);\n}\n\nll lcm(ll x, ll y){\n  ll res = x / gcd(x, y);\n  res *= y;\n  return res;\n};\n\n\n//コンビネーション\nconst int MAXcomb = 200010;\nll fac[MAXcomb], finv[MAXcomb], inv[MAXcomb];\n//facはn!,finvは1/n!\n//invは逆元\nvoid COMinit(){\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for(int i = 2; i < MAXcomb; i++){\n        fac[i] = fac[i-1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD/i) % MOD;\n        finv[i] = finv[i-1] * inv[i] % MOD;\n    }\n}\nll comb(int n, int k){\n    if(n < k) return 0;\n    if(n < 0 || k < 0) return 0;\n    return fac[n] * finv[k] % MOD * finv[n-k] % MOD;\n}\n\nconst int MAXkai = 200010;\nll kai_memo[MAXkai];\nll kai(ll N){\n  if(kai_memo[N] != 0) return kai_memo[N];\n  if(N <= 1) return 1;\n  return kai_memo[N] = N * kai(N-1) % MOD;\n}\n\nll disit(ll s, ll base = 10){\n  ll res = 0;\n  while(s){\n    res++;\n    s /= base;\n  }\n  return res;\n}\n\n//約数の列挙O(√n)\nvector<ll> divisor(ll n){\n    vector<ll> res(0);\n    for(ll i = 1; i * i <= n; i++){\n        if(n % i == 0){\n            res.push_back(i);\n            if(i != n/i) res.push_back(n/i);\n        }\n    }\n    sort(res.begin(), res.end());\n    return res;\n}\n\nvoid mul(int &a, int b){\n  a = a * 1LL * b % MOD;\n}\n\nstruct vertex{\n  int num;\n  int len;\n};\n\nint N;\nvector<int> h;\nvertex vs[10010];\nvector<int> E[10010];\nint id;\n\nvoid make_E(int par, int f, int s){\n  int m = INF;\n  for(int i = f; i < s; i++) m = min(m, h[i]);\n  for(int i = f; i < s; i++) h[i] -= m;\n  vs[par].num = m;\n\n  int last = f;\n  for(int i = f; i <= s; i++){\n    if(i != s && h[i]){\n      continue;\n    }else{\n      if(last != i){\n        vs[id] = {-1, i - last};\n        E[par].pb(id);\n        id++;\n        make_E(id-1, last, i);\n      }\n      last = i + 1;\n    }\n  }\n}\n\npair<int, int> tree_dp(int v){\n  int x = vs[v].num, w = vs[v].len;\n  for(int to: E[v]) w -= vs[to].len;\n\n  int res1 = pow_mod(2, x);\n  int all1 = pow_mod(2, w);\n  int all2 = (pow_mod(2, x) + MOD - 2) % MOD;\n  for(int to: E[v]){\n    pair<int, int> get = tree_dp(to);\n    mul(res1, get.f);\n    mul(all1, (get.f + get.s) % MOD);\n    mul(all2, get.f);\n  }\n  return {res1, (all1 + all2) % MOD};\n}\n\n\nvoid solve(){\n  cin >> N;\n  h.resize(N);\n  rep(i, N){\n    cin >> h[i];\n  }\n\n  vs[id] = {-1, N};\n  id++;\n  make_E(0, 0, N);\n  pair<int, int> ans = tree_dp(0);\n  cout << ans.s << endl;\n}\n\nint main(){\n  ios_base::sync_with_stdio(0);\n  cin.tie(0), cout.tie(0);\n  solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nMain AC Solution(Zobiest Hash)\n*/\n\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n==0) ? 1 : 10*TEN(n-1); }\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\nconst int MN = 100;\nconst int MH = TEN(9);\n\nmt19937 gen;\nvoid reseed(ll seed) {\n    gen = mt19937(seed);\n    for (int i = 0; i < 10000; i++) {\n        gen(); // skip\n    }\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n    using D = uniform_int_distribution<ll>;\n    assert(l <= r);\n    return D(l, r)(gen);\n}\n\nstring rand_lower_string(int n, int up = 26) {\n    string s = \"\";\n    for (int i = 0; i < n; i++) {\n        s += 'a' + rand_int(0, up-1);\n    }\n    return s;\n}\n\ntemplate<class T> void myshuffle(T &v) {\n    shuffle(begin(v), end(v), gen);\n}\n\ntemplate<uint MD>\nstruct ModInt {\n    using M = ModInt;\n    uint v;\n    ModInt() : v{0} {}\n    ModInt(ll _v) : v{normS(_v % MD + MD)} {}\n    explicit operator bool() const { return v != 0; }\n    static uint normS(uint x) { return (x < MD) ? x : x - MD; };\n    static M make(uint x) { M m; m.v = x; return m; }\n    static M inv(const M& x) { return x.pow(MD - 2); }\n    M operator+(const M& r) const { return make(normS(v + r.v)); }\n    M operator-(const M& r) const { return make(normS(v + MD - r.v)); }\n    M operator*(const M& r) const { return make(ull(v) * r.v % MD); }\n    M operator/(const M& r) const { return *this * inv(r); }\n    M& operator+=(const M& r) { return *this = *this + r; }\n    M& operator-=(const M& r) { return *this = *this - r; }\n    M& operator*=(const M& r) { return *this = *this * r; }\n    M& operator/=(const M& r) { return *this = *this / r; }\n    M pow(ll n) const {\n        M x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n};\nusing Mint = ModInt<TEN(9)+7>;\n\nusing P = pair<Mint, Mint>; // 0101, all\n\nP make(int l, int r, V<int> &v) {\n    int mi = TEN(9) + TEN(4);\n    for (int i = l; i < r; i++) {\n        mi = min(mi, v[i]);\n    }\n    for (int i = l; i < r; i++) {\n        v[i] -= mi;\n    }\n    int other = 0;\n    Mint c01 = Mint(1), c01self = Mint(1);\n    int p = l;\n    while (p < r) {\n        if (v[p] == 0) {\n            other++;\n            p++;\n            continue;\n        }\n        int q = p;\n        while (q < r && v[q]) q++;\n        P ch = make(p, q, v);\n        c01 *= ch.first;\n        c01self *= (ch.first + ch.second);\n        p = q;\n    }\n    Mint self01 = Mint(2).pow(mi) * c01;\n    Mint selfall = Mint(2).pow(other) * c01self + self01 - Mint(2) * c01;\n    return P(self01, selfall);\n}\n\nint main() {\n    int n;\n    cin >> n;\n    V<int> a(n);\n    for (int i = 0; i < n; i++) cin >> a[i];\n    P p = make(0, n, a);\n    cout << p.second.v << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define Endl endl\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class T,size_t n> ostream& operator<<(ostream &os, const array<T,n> &t) {\n\tos<<\"{\"; rep(i,n) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T,class U> ostream& operator<<(ostream &os, const tuple<S,T,U> &t) { return os<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\ntemplate<class S, class T,class U,class V> ostream& operator<<(ostream &os, const tuple<S,T,U,V> &t) { return os<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\",\"<<get<3>(t)<<\")\";}\ntemplate<class S, class T,class U,class V,class W> ostream& operator<<(ostream &os, const tuple<S,T,U,V,W> &t) { return os<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\",\"<<get<3>(t)<<\",\"<<get<4>(t)<<\")\";}\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n//#undef NUIP\n#ifdef NUIP\n#define out(args...){vector<string> a_r_g_s=s_p_l_i_t(#args, ','); e_r_r(a_r_g_s.begin(), args); }\nvector<string> s_p_l_i_t(const string &s, char c){vector<string> v;int d=0,f=0;string t;for(char c:s){if(!d&&c==',')v.pb(t),t=\"\";else t+=c;if(c=='\\\"'||c=='\\'')f^=1;if(!f&&c=='(')++d;if(!f&&c==')')--d;}v.pb(t);return move(v);}\nvoid e_r_r(vector<string>::iterator it) {}\ntemplate<typename T, typename... Args> void e_r_r(vector<string>::iterator it, T a, Args... args){ if(*it==\" 1\"||*it==\"1\") cerr<<endl; else cerr << it -> substr((*it)[0] == ' ', it -> length()) << \" = \" << a << \", \"; e_r_r(++it, args...);}\n#else\n#define out\n#endif\n#ifdef __cpp_init_captures\ntemplate<typename T>vector<T> table(int n, T v){ return vector<T>(n, v);}\ntemplate <class... Args> auto table(int n, Args... args){auto val = table(args...); return vector<decltype(val)>(n, move(val));}\n#endif\nconst ll MOD=1e9+7;\n\nll modpow(ll r,ll n,ll m=MOD){\n  ll re=1,d=r%m;\n  if(n<0)(n%=m-1)+=m-1;\n  for(;n;n/=2){\n    if(n&1)(re*=d)%=m;\n    (d*=d)%=m;\n  }\n  return re;\n}\ntemplate <int mod=MOD> struct modInt{\n  int v;\n  modInt(int v=0):v(v){}\n  modInt operator+(const modInt &n)const{return v+n.v<mod ? v+n.v : v+n.v-mod;}\n  modInt operator-(const modInt &n)const{return v-n.v<0 ? v-n.v+mod : v-n.v;}\n  modInt operator*(const modInt &n)const{return ll(v)*n.v%mod;}\n  modInt operator/(const modInt &n)const{return ll(v)*modpow(n.v%mod,-1,mod)%mod;}\n  modInt operator+(const ll &n)const{return v+n<mod ? v+n : v+n-mod;}\n  modInt operator-(const ll &n)const{return v-n<0 ? v-n+mod : v-n;}\n  modInt operator*(const ll &n)const{return ll(v)*(n%mod)%mod;}\n  modInt operator/(const ll &n)const{return ll(v)*modpow(n%mod,-1,mod)%mod;}\n  modInt& operator+=(const modInt &n){v+=n.v; if(v>=mod) v-=mod; return *this;}\n  modInt& operator-=(const modInt &n){v-=n.v; if(v<0) v+=mod; return *this;}\n  modInt& operator*=(const modInt &n){v=ll(v)*n.v%mod; return *this;}\n  modInt& operator/=(const modInt &n){v=ll(v)*modpow(n.v,-1,mod)%mod; return *this;}\n  modInt& operator+=(const ll &n){v+=n; if(v>=mod) v-=mod; return *this;}\n  modInt& operator-=(const ll &n){v-=n; if(v<0) v+=mod; return *this;}\n  modInt& operator*=(const ll &n){v=ll(v)*n%mod; return *this;}\n  modInt& operator/=(const ll &n){v=ll(v)*modpow(n,-1,mod)%mod; return *this;}\n};\ntemplate<int mod> ostream& operator<<(ostream &os,const modInt<mod> &n){return os<<n.v;};\ntemplate<int mod> modInt<mod> operator+(const ll &n,const modInt<mod> &m){return m.v+n<mod ? m.v+n : m.v+n-mod;}\ntemplate<int mod> modInt<mod> operator-(const ll &n,const modInt<mod> &m){return n-m.v<0 ? n-m.v+mod : n-m.v;}\ntemplate<int mod> modInt<mod> operator*(const ll &n,const modInt<mod> &m){return ll(m.v)*(n%mod)%mod;}\ntemplate<int mod> modInt<mod> operator/(const ll &n,const modInt<mod> &m){return ll(m.v)*modpow(n%mod,-1,mod)%mod;}\ntypedef modInt<MOD> mint;\ntemplate <int mod> modInt<mod> modpow(modInt<mod> r,ll n){ modInt<mod> re(1); if(n<0)(n%=mod-1)+=mod-1; for(;n;n/=2){if(n&1) re*=r; r*=r;} return re;}\nvector<mint> fact,finv,inv;\nmint comb(ll n,ll r){ if(n<r||r<0)return 0; return fact[n]*finv[n-r]*finv[r];}\nclass Doralion{\n  void Modinvs(vector<mint> &re,int n){ re.resize(n+1); re[1]=1; for(int i=2;i<=n;++i)re[i]=re[MOD%i]*(MOD-MOD/i);}\n  void Facts(vector<mint> &re,int n){ re.resize(n+1); re[0]=1; rep(i,n)re[i+1]=re[i]*(i+1);}\n  void Factinvs(vector<mint> &re,const vector<mint> &inv,int n){ re.resize(n+1); re[0]=1; rep(i,n)re[i+1]=re[i]*inv[i+1];}\npublic:\n  Doralion(int n){ Modinvs(inv,n); Facts(fact,n); Factinvs(finv,inv,n);}\n} doralion(212345);\n\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n\tint n;\n\tcin>>n;\n\tvector<int> a(n);\n\trep(i,n) cin>>a[i];\n\tauto hs=a;\n\tsort(rall(hs)); UNIQUE(hs);\n\ta.pb(-1); ++n;\n\t//hs.pb(0);\n\tusing pmm=pair<mint,mint>;\n\tmap<pii,pmm> dp; //(R,not R)\n\tint pre=hs[0]+1;\n\tfor(int h:hs){\n\t\tmap<pii,pmm> nxt;\n\t\tint last=-1;\n\t\trep(i,n){\n\t\t\tif(a[i]<h){\n\t\t\t\tvector<pmm> ps;\n\t\t\t\tint len=i-last-1;\n\t\t\t\tint l2=0;\n\t\t\t\tint lb=last+1;\n\t\t\t\tlast=i;\n\t\t\t\tif(!len) continue;\n\t\t\t\twhile(dp.size() && dp.begin()->X.X<i){\n\t\t\t\t\tlen-=dp.begin()->X.Y-dp.begin()->X.X;\n\t\t\t\t\tl2+=dp.begin()->X.Y-dp.begin()->X.X;\n\t\t\t\t\tps.pb(dp.begin()->Y);\n\t\t\t\t\tdp.erase(dp.begin());\n\t\t\t\t}\n\t\t\t\tout(h,ps,len,i,1);\n\t\t\t\tauto &re=nxt[pii(lb,i)];\n\t\t\t\tif(l2){\n\t\t\t\t\tre=pmm(1,1);\n\t\t\t\t\tout(i,re,pre,h,1);\n\t\t\t\t\tmint hoge=modpow(mint(2),pre-h);\n\t\t\t\t\tfor(auto p:ps){\n\t\t\t\t\t\tmint tmp=p.Y*hoge;\n\t\t\t\t\t\tre.X*=p.X+tmp;\n\t\t\t\t\t\tre.Y*=tmp;\n\t\t\t\t\t}\n\t\t\t\t\tout(ps,hoge,re,1);\n\t\t\t\t\tre.X*=modpow(mint(2),len); //new\n\t\t\t\t\tre.Y*=modpow(mint((MOD+1)/2),(ll)ps.size()-1);\n\t\t\t\t\tre.X-=re.Y;\n\t\t\t\t}else{\n\t\t\t\t\tre=pmm(modpow(mint(2),len),2);\n\t\t\t\t\tre.X-=re.Y;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\t// nothing\n\t\t\t}\n\t\t}\n\t\tpre=h;\n\t\tdp=nxt;\n\t\tfor(auto p:dp) cout<<p;cout<<endl;\n\t}\n\tauto re=dp.begin()->Y;\n\tif(hs.back()>1){\n\t\tre.Y*=modpow(mint(2),hs.back()-1);\n\t}\n\tcout<<re.X+re.Y<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                     \n                                             `-:://:::-                                             \n                                           `//:-------:/:`                                          \n                                          .+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .o:--...```..---+/`                                        \n                                       `/y+o/---....---:+o.                                         \n                                   `...````-os+/:---:/+o/--.`                                       \n              `-/+++++/:.      `...`       :h+d+oooo+/+-`   ...                                     \n            `/++//:::://++-`....`         -.`//````````:`     `..`                                  \n           `o+/::------://o/`           `-` -.          -`       `..`                               \n `---.-o/:./o/::-..``..-ЗАПУСКАЕМ      ..  ..            -`        `...       ``..``                \n  `....o+:-++/:--.```..-://s.        `-`  .-              -`          `-o: .-//::::/:-`             \n          `:s+/:--....-::/+s-`      .-   `-                -`           -///:--------:/:`           \n           ./s+//:::::://oo-``..НЕЙРОННУЮ: СЕТЬ:::::::-`РАБОТЯГИ        `+:--........--:/`          \n            .:ooo+++++osso-`    `.:-...`/` ./::-------:/:`   -`         :+--..``````.--:+:...-+:-`  \n             `.-/+++++/+-.-`    -.   ``:so:/:--.......--:+`  `-```````o+/+--..`````..--:o/-..:s+:.  \n                 ```````:``.. `-`     -` `+:--..`````..--/+-.../.`````..-o:--.......---/o.    `     \n                        `:  `:-      -.  .o:--..`` ``..--:o`   `-`      `:o+:--------:+o-`          \n                         `-`-...    ..   .o/--...```..--:+/`    `-`     `oy/so/////++o/.`           \n                          -/`  `-` `- ``+s/o/:---...---:++.      `-`   .-../d://///:-.`             \n                `.---..``-..-    .-/..`````-oo+/:::::/+o+-        `-``-`  `-.  ````                 \n             `:++++/+++++-  ..``.-/:`      /y-:/++o++/:.`..`       ./.   `-                         \n            -++/::::::://+/..:-``:` ..   `-.`  ```.```    `..`   `..`-` `-                          \n       ``  -o//:--....-::/++` -.-`   `-`.-`                 `..`..`  `-.-                           \n  -----ss+:++/:--.```..-://s.  /.     `::                    `-:.     ./`                           \n  `````/:..+o/::-..``.--:/+s. ..-`   `-``-`                 ..` `-`  `-`-`                          \n          `-s+/::-----::/+oo---``-` ..    .:-    ```      .-`     .-.-  `-`                         \n           `:oo+//::://+os/..:`..-/:`      :y.-:::::::.`.-`        ./-`  `-`                        \n            `./+oooooooo+/.`-    .-:...`.. .//:-------://`        `- `..` `:.                       \n              ``.-::::-.``-/`  `-` `-  `oo:+:--.......--:/`      `-    `.:--h.``..```               \n                          -.-`.-    .-   `+:--..`````..--//`    `-       /s-//::::::::.             \n                         -` `/-      ..  .o:--..`` ``..--:o.```.-        `//:--------://`           \n                        -` .-`.-`     -.`-o/--...```..--:+/.``-:....``:-.+:--....`...--:+`          \n                       ..`-.   `-.   ``:os:o/:---...---:++.  `-     ``///+:-..``````.--:+-````-.`   \n              `.:///////.-`      .:-..` -``-+o+/:::::/+o/.  `-         `:+:-..`````..--:o/:--/ys+-  \n            `-++///////+o/. ``....`-.    :` `.:++++++/:.`  .-           -o/---......---/o.   `.`    \n           `++//:-----::/+o:..`     .-`   :    ```````    .-           `+so+:--------:++-`          \n  `````:-``:o/::-..`..--:/+o`         -.  `-             .-          `../../+o+////+o+:.`           \n  -----syo/o+/:--.```..-://s.          .-` `-           .-        `...     ``-:////:-``             \n       .` `/s//:--....-::/+s.            -. `-`        .-       `..`                                \n           .+o+/:::--:://+s/-..`          .::+y  ```  .-     `..`                                   \n            ./oo++////+oso-`   `....       :y-+:::::::/`   ...                                      \n             `.:+oooooo/-`         `....-. .//:-------:/:-.`                                        \n                ``...``                 /+:+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .+/--...```..--:+/`                                        \n                                         `-o/:---...---:++.                                         \n                                          `-+o+/:---:/+o/.                                          \n                                            `.:+oooo+/-.`                                           \n                                               ``````                                               \n*/\n\n#ifdef aimbot\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#endif\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <set>\n#include <queue>\n#include <ostream>\n#include <istream>\n#include <typeinfo>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <limits>\n#include <fstream>\n#include <array>\n#include <list>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <cstring>\n\n#define mt make_tuple\n#define x first\n#define y second\n#define pb push_back\n#define ppb pop_back\n#define mp make_pair\n#define umap unordered_map\n#define uset unordered_set\n#define elif else if\n#define len(v) ((int)v.size())\n#define f(i, n) for (int i = 0; i < (n); i++)\n#define rof(i, n) for (int i = ((n) - 1); i >= 0; i--) \n#define apply(v, act) for (auto &x : v) { act; }\n#define log(args...) {string s = #args;deque<string> deq;\\\nstring buf = \"\";int bal = 0;for (char c : s) {\\\nif (c == '(' || c == '[' || c == '{') {bal++;\\\n} else if (c == ')' || c == ']' || c == '}') {\\\nbal--;} else {if (bal == 0) {if (c == ',') {\\\ndeq.pb(buf);buf = \"\";} else {if (c != ' ') {\\\nbuf += c;}}}}}if (!buf.empty()) {deq.pb(buf);}\\\nsmart_io::precall_print();smart_io::_print(deq, args);}\n\n#define print    \\\nsmart_io::precall_print(); \\\ncout,\n\n#define scan cin,\n\n#ifdef fast_allocator\nconst int MAXMEM = 50000000;\nchar _memory[MAXMEM];\nsize_t _ptr = 0;\nvoid* operator new(size_t _x) { _ptr += _x; assert(_ptr < MAXMEM); return _memory + _ptr - _x; }\nvoid operator delete (void*) noexcept {}\n#endif\n\nusing namespace std;\n\nchar string_in_buffer[(int)260];\n\n\nvoid fast_scan(int &x) { scanf(\"%d\", &x); }\nvoid fast_scan(long long &x) { scanf(\"%lld\", &x); }\nvoid fast_scan(unsigned long long &x) { scanf(\"%llu\", &x); }\nvoid fast_scan(double &x) { scanf(\"%lf\", &x); }\nvoid fast_scan(long double &x) { scanf(\"%Lf\", &x); }\nvoid fast_scan(char &x) { \n\tscanf(\"%c\", &x); \n\tif (x == '\\n') {\n\t\tfast_scan(x);\n\t}\n}\nvoid fast_scan(string &x) {\n\tscanf(\"%s\", string_in_buffer);\n\tx = string(string_in_buffer);\n}\n\ntemplate<class TFirst, class TSecond>\nvoid fast_scan(pair<TFirst, TSecond> &p) {\n\tfast_scan(p.first);\n\tfast_scan(p.second);\n}\n\ntemplate <class T>\nvoid fast_scan(vector<T> &v) {\n\tfor (auto &x : v) fast_scan(x);\n}\n\nvoid fast_print(const int &x) { printf(\"%d\", x); }\nvoid fast_print(const long long &x) { printf(\"%lld\", x); }\nvoid fast_print(const unsigned long long &x) { printf(\"%llu\", x); }\nvoid fast_print(const double &x) { printf(\"%.15lf\", x); }\nvoid fast_print(const long double &x) { printf(\"%.15Lf\", x); }\nvoid fast_print(const char &x) { printf(\"%c\", x); };\nvoid fast_print(const string &x) { printf(\"%s\", x.c_str());}\nvoid fast_print(const char v[]) { fast_print((string)v); }\n\ntemplate<class TFirst, class TSecond>\nvoid fast_print(const pair<TFirst, TSecond> &p) {\n\tfast_print(p.first);\n\tfast_print(' ');\n\tfast_print(p.second);\n}\n\ntemplate <class T>\nvoid fast_print(const vector<T> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print(' ');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const vector<vector<T>> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print('\\n');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const T &v) {\n\tfor (const auto &x : v) {\n\t\tfast_print(x);\n\t\tfast_print(' ');\n\t}\n}\n\n\nusing namespace std;\n\n\nnamespace smart_io {\n\tstring print_start = \"\";\n\tstring sep = \" \";\n\tbool first_print = false;\n\n\tvoid precall_print() {\n\t\tfast_print(print_start);\n\t\tprint_start = \"\\n\";\n\t\tfirst_print = true;\n\t}\n\n\tvoid _print(deque<string>) {}\n\ttemplate<class T, class... Args>\n\tvoid _print(deque<string> names, T kek, Args... args) {\n\t\tif (!first_print) {\n\t\t\tfast_print(\"\\n\");\n\t\t} else {\n\t\t\tfirst_print = false;\n\t\t}\n\t\tfast_print(names.front());\n\t\tfast_print(\" = \");\n\t\tfast_print(kek);\n\t\tnames.pop_front();\n\t\t_print(names, args...);\n\t}\n} //namespace smart_io\n\n\ntemplate <class T>\nostream &operator,(ostream &os, const T &object) {\n\tif (!smart_io::first_print) {\n\t\tfast_print(smart_io::sep);\n\t} else {\n\t\tsmart_io::first_print = false;\n\t}\n\tfast_print(object);\n\treturn os;\n}\n\ntemplate <class T>\nistream &operator,(istream &is, T &object) {\n\tfast_scan(object);\n\treturn is;\n}\n\n#define int long long\n\nnamespace typedefs {\n\ttypedef long long ll;\n\ttypedef unsigned long long ull;\n\ttypedef pair<int, int> pii;\n\ttypedef long double ld;\n}\n\nnamespace numbers_operation {\n\ttemplate<class T>\n\tT floor_mod(T a, T b) {\n\t\tif (a % b == 0) return 0;\n\t\tif (a >= 0 && b >= 0) return a % b;\n\t\tif (a <= 0 && b <= 0) return a % b;\n\t\treturn abs(b) - (abs(a) % abs(b));\n\t}\n}\n\nusing namespace numbers_operation;\nusing namespace typedefs;\n\nconst ll MOD = 1e9 + 7;\n\nint fast_pow(int x, int p) {\n\tif (p == 0) return 1;\n\tif (p & 1) {\n\t\treturn (fast_pow(x, p - 1) * x) % MOD;\n\t} else {\n\t\tll sub = fast_pow(x, p / 2);\n\t\treturn (sub * sub) % MOD;\t\n\t}\n}\n\nint n;\nvector<int> v;\n\nint solve__par(int l, int r, int depth) {\n\tif (l == r) return 1;\n\tint _min = 1e9 + 1;\t\n\tfor (int i = l; i < r; i++) {\n\t\t_min = min(_min, v[i]);\n\t}\n\tint h = _min - depth;\n\tvector<int> stops;\n\tstops.pb(l - 1);\n\tfor (int i = l; i < r; i++) {\n\t\tif (v[i] == _min) {\n\t\t\tstops.pb(i);\n\t\t}\n\t}\n\tstops.pb(r);\n\tll rez = fast_pow(2, h + 1);\n\tf(i, len(stops) - 1) {\n\t\tint sub_l = stops[i] + 1;\n\t\tint sub_r = stops[i + 1];\n\t\tif (sub_l == sub_r) {\n\t\t} else {\n\t\t\trez *= solve__par(sub_l, sub_r, _min + 1);\n\t\t}\n\t\trez %= MOD;\n\t}\n\treturn rez;\n}\n\nint solve(int l, int r, int depth) {\n\tif (l + 1 >= r) return 0;\n\tint _min = 1e9 + 1;\t\n\tfor (int i = l; i < r; i++) {\n\t\t_min = min(_min, v[i]);\n\t}\n\tif (depth > _min) return 1;\n\tint h = _min - depth;\n\tvector<int> stops;\n\tstops.pb(l - 1);\n\tll rez = 1;\n\tfor (int i = l; i < r; i++) {\n\t\tif (v[i] == _min) {\n\t\t\tstops.pb(i);\n\n\t\t\trez *= 2;\n\t\t\trez %= MOD;\n\t\t}\n\t}\n\tstops.pb(r);\n\tf(i, len(stops) - 1) {\n\t\tint sub_l = stops[i] + 1;\n\t\tint sub_r = stops[i + 1];\n\t\tif (sub_l == sub_r) {\n\t\t\t// rez *= 2;\n\t\t\t// print \"MUL?\", sub_l, sub_r;\n\t\t} else {\n\t\t\t// print \"invoke?\", sub_l, sub_r;\n\t\t\trez *= (solve(sub_l, sub_r, _min + 1) + 2 * solve__par(sub_l, sub_r, _min + 1));\n\t\t}\n\t\trez %= MOD;\n\t}\n\n\treturn floor_mod(rez - solve__par(l, r, _min), MOD);\n}\n\nsigned main(signed argc, char *argv[]) {\n\tscan n;\t\n\tv.resize(n);\n\tscan v;\n\tprint (solve(0, n, 1) + solve__par(0, n, 1)) % MOD;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mod 998244353\n#define MOD 1000000007\n#define inf 0x3f3f3f3f\n#define linf 0x3f3f3f3f3f3f3f3fll\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef unsigned long long ull;\nint h[110];\nint n;\ninline ll quickpow(ll base,int ind)\n{\n\tll ans=1;\n\twhile(ind>0)\n\t{\n\t\tif(ind&1)ans=ans*base%MOD;\n\t\tind>>=1;\n\t\tbase=base*base%MOD;\n\t}\n\treturn ans;\n}\npair<ll,ll> solve(int l,int r)\n{\n\tint minval=inf;\n\tfor(int i=l;i<=r;i++)\n\t\tminval=min(minval,h[i]);\n//\tcout<<l<<\" \"<<r<<\" \"<<minval<<endl;\n\tint st=l;\n\tll cross=2,all=1;\n\tfor(int i=l;i<=r+1;i++)\n\t\tif(i>r||h[i]==minval)\n\t\t{\n\t\t\tif(i>st)\n\t\t\t{\n\t\t\t\tfor(int j=st;j<i;j++)\n\t\t\t\t\th[j]-=minval;\n\t\t\t\tpair<ll,ll> tmp=solve(st,i-1);\n\t\t\t\tcross=cross*tmp.first%MOD;\n\t\t\t\tall=all*(tmp.first+tmp.second)%MOD;\n\t\t\t}\n\t\t\tst=i+1;\n\t\t\tif(i<=r)all=all*2%MOD;\n\t\t}\n\tall=(all-cross+MOD)%MOD;\n\tcross=cross*quickpow(2,minval-1)%MOD;\n\tall=(all+cross)%MOD;\n//\tcout<<cross<<\" \"<<all<<endl;\n\treturn make_pair(cross,all);\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tscanf(\"%d\",&h[i]);\n\t}\n\tprintf(\"%lld\\n\",solve(0,n-1).second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<set>\n#include<unordered_map>\n#define lol(i,n) for(ll i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\n\nusing namespace std;\nll po(ll x){\n    ll res=1;\n    for(ll y=2;x;x>>=1,y=y*y%mod){\n\tif(x&1)res=res*y%mod;\n    }\n    return res;\n}\nll mo(ll x){\n    x%=mod;\n    if(x<0)x+=mod;\n    return x;\n}\ntypedef pair<ll,ll> P;\n#define N 110\nvector<ll> v[N];\nll n,f[N],g[N],l[N],r[N],w[N],u[N],h[N],m;\nll ans;\nvoid func(ll x){\n    ll len=r[x]-l[x]-1;\n    if(len==1){\n\tmul(ans,po(w[x]));\n\tf[x]=g[x]=0;\n\treturn;\n    }\n    ll fm=1,gm=1,sum=0;\n    for(auto c:v[x]){\n\tfunc(c);\n\tif(r[c]-l[c]-1==1)continue;\n\tsum+=r[c]-l[c]-1;\n\tfm=mo(fm*f[c]);\n\tgm=mo(gm*(2*f[c]+g[c]));\n    }\n    if(sum==0){\n\tf[x]=mo(po(w[x]));\n\tg[x]=mo(po(len)-2);\n\treturn;\n    }\n    f[x]=mo(fm*po(w[x]));\n    g[x]=mo(gm*po(len-sum));\n    g[x]=mo(g[x]-2*fm);\n}\nint main(){\n    cin>>n;\n    if(n==1){\n\tcin>>n;\n\tcout<<po(n)<<endl;\n\treturn 0;\n    }\n    lol(i,n)cin>>h[i];\n    unordered_map<ll,vector<ll> >mas;\n    lol(i,n){\n\tmas[h[i]].push_back(i);\n    }\n    sort(h,h+n);\n    set<ll> st; st.insert(-1); st.insert(n);\n    m=1,l[0]=-1,r[0]=n,w[0]=u[0]=h[0];\n    lol(i,n){\n\tif(i&&h[i-1]==h[i])continue;\n\tfor(auto x:mas[h[i]]){\n\t    auto il=st.lower_bound(x); il--;\n\t    ll L=*il;\n\t    auto ir=st.upper_bound(x);\n\t    ll R=*ir;\n\t    if(l[m-1]==L&&r[m-1]==R)continue;\n\t    l[m]=L,r[m]=R,u[m]=w[m]=h[i],m++;\n\t}\n\tfor(auto x:mas[h[i]])st.insert(x);\n    }\n    lol(i,m){\n\tfor(ll j=i-1;~j;j--){\n\t    if(l[j]<=l[i]&&r[i]<=r[j]){\n\t\tv[j].push_back(i);\n\t\tw[i]=u[i]-u[j];\n\t\tbreak;\n\t    }\n\t}\n    }\n    ans=1;\n    func(0);\n    cout<<mo(ans*(f[0]+g[0]))<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Love and Freedom.\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#define ll long long\n#define inf 20021225\n#define N 110\n#define pa pair<int,int>\n#define mdn 1000000007\nusing namespace std;\nint read()\n{\n\tint s=0,t=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')\tt=-1; ch=getchar();}\n\twhile(ch>='0' && ch<='9')\ts=s*10+ch-'0',ch=getchar();\n\treturn s*t;\n}\nint a[N],n;\nint ksm(int bs,int mi)\n{\n\tint ans=1;\n\twhile(mi)\n\t{\n\t\tif(mi&1)\tans=1ll*ans*bs%mdn;\n\t\tbs=1ll*bs*bs%mdn; mi>>=1;\n\t}\n\treturn ans;\n}\npa solve(int l,int r,int lim)\n{\n\tint mn=a[min_element(a+l,a+r+1)-a],w1=1,w2=1,num=0;\n\tfor(int i=l,j;i<=r;i++)\n\t{\n\t\tif(a[i]!=mn)\n\t\t{\n\t\t\tj=i; while(j+1<=r&&a[j+1]!=mn)\tj++;\n\t\t\tpa cur=solve(i,j,mn); i=j;\n\t\t\tw1=1ll*cur.first*w1%mdn;\n\t\t\tw2=1ll*(cur.first+cur.second)%mdn*w2%mdn;\n\t\t}\n\t\telse\tnum++;\n\t}\n\treturn make_pair(1ll*w1*ksm(2,mn-lim)%mdn,(1ll*w2*ksm(2,num)%mdn+1ll*w1*(ksm(2,mn-lim)-2)%mdn)%mdn);\n}\nint main()\n{\n\tn=read();\n\tfor(int i=1;i<=n;i++)\ta[i]=read();\n\tprintf(\"%d\\n\",solve(1,n,0).second);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <numeric>\n\ntemplate <class T, class U>\ninline bool chmin(T &lhs, const U &rhs) {\n  if (lhs > rhs) {\n    lhs = rhs;\n    return true;\n  }\n  return false;\n}\n\ntemplate <class T, class U>\ninline bool chmax(T &lhs, const U &rhs) {\n  if (lhs < rhs) {\n    lhs = rhs;\n    return true;\n  }\n  return false;\n}\n\n// [l, r) from l to r\nstruct range {\n  struct itr {\n    int i;\n    constexpr itr(int i_): i(i_) { }\n    constexpr void operator ++ () { ++i; }\n    constexpr int operator * () const { return i; }\n    constexpr bool operator != (itr x) const { return i != x.i; }\n  };\n  const itr l, r;\n  constexpr range(int l_, int r_): l(l_), r(std::max(l_, r_)) { }\n  constexpr itr begin() const { return l; }\n  constexpr itr end() const { return r; }\n};\n\n// [l, r) from r to l\nstruct revrange {\n  struct itr {\n    int i;\n    constexpr itr(int i_): i(i_) { }\n    constexpr void operator ++ () { --i; }\n    constexpr int operator * () const { return i; }\n    constexpr bool operator != (itr x) const { return i != x.i; }\n  };\n  const itr l, r;\n  constexpr revrange(int l_, int r_): l(l_ - 1), r(std::max(l_, r_) - 1) { }\n  constexpr itr begin() const { return r; }\n  constexpr itr end() const { return l; }\n};\n\ntemplate <uint32_t Modulus>\nclass modular {\npublic:\n  using value_type = uint32_t;\n  using max_type = uint64_t;\n\n  static constexpr value_type mod = Modulus;\n  static constexpr value_type mod_min = 1;\n  static constexpr value_type mod_max = 2147483647;\n  static_assert(mod >= mod_min, \"invalid mod :: too small\");\n  static_assert(mod <= mod_max, \"invalid mod :: too big\");\n\n  template <class T>\n  static constexpr value_type normalize(T value_) {\n    if (value_ < 0) {\n      value_ = -value_;\n      value_ %= mod;\n      if (value_ == 0) return 0;\n      return mod - value_;\n    }\n    return value_ % mod;\n  }\n\nprivate:\n  value_type value;\n\npublic:\n  constexpr modular(): value(0) { }\n  template <class T>\n  explicit constexpr modular(T value_): value(normalize(value_)) { }\n  template <class T>\n  explicit constexpr operator T() { return static_cast<T>(value); }\n\n  constexpr value_type operator () () const { return value; }\n  constexpr modular operator - () const { return modular(mod - value); }\n  constexpr modular operator ~ () const { return inverse(); }\n\n  constexpr value_type &extract() { return value; }\n  constexpr modular inverse() const { return power(mod - 2); }\n  constexpr modular power(max_type exp) const {\n    modular res(1), mult(*this);\n    while (exp > 0) {\n      if (exp & 1) res *= mult;\n      mult *= mult;\n      exp >>= 1;\n    }\n    return res;\n  }\n\n  constexpr modular operator + (const modular &rhs) const { return modular(*this) += rhs; }\n  constexpr modular& operator += (const modular &rhs) { \n    if ((value += rhs.value) >= mod) value -= mod; \n    return *this; \n  }\n\n  constexpr modular operator - (const modular &rhs) const { return modular(*this) -= rhs; }\n  constexpr modular& operator -= (const modular &rhs) { \n    if ((value += mod - rhs.value) >= mod) value -= mod; \n    return *this; \n  }\n\n  constexpr modular operator * (const modular &rhs) const { return modular(*this) *= rhs; }\n  constexpr modular& operator *= (const modular &rhs) { \n    value = (max_type) value * rhs.value % mod;\n    return *this;\n  }\n\n  constexpr modular operator / (const modular &rhs) const { return modular(*this) /= rhs; }\n  constexpr modular& operator /= (const modular &rhs) { return (*this) *= rhs.inverse(); }\n\n  constexpr bool zero() const { return value == 0; }\n  constexpr bool operator == (const modular &rhs) const { return value == rhs.value; }\n  constexpr bool operator != (const modular &rhs) const { return value != rhs.value; }\n  friend std::ostream& operator << (std::ostream &stream, const modular &rhs) {\n    return stream << rhs.value;\n  }\n\n};\n\ntemplate <class T>\nstruct fix_point: private T {\n  explicit constexpr fix_point(T &&func): T(std::forward<T>(func)) { }\n  template <class... Args>\n  constexpr decltype(auto) operator () (Args &&... args) const {\n    return T::operator()(*this, std::forward<Args>(args)...);\n  }\n};\n\ntemplate <class T>\nconstexpr decltype(auto) make_fix_point(T &&func) {\n  return fix_point<T>{std::forward<T>(func)};\n}\n\nusing modint = modular<1000000007>;\n\nint main() {\n  int N;\n  std::cin >> N;\n  std::vector<int> H(N);\n  for (int &x: H) {\n    std::cin >> x;\n  }\n  auto ans = make_fix_point([&](auto dfs, int l, int r, int d) -> std::pair<modint, modint> {\n    int min_height = *std::min_element(H.cbegin() + l, H.cbegin() + r);\n    int height = min_height - d;\n    int free = r - l;\n    std::vector<std::pair<modint, modint>> up;\n    {\n      int right = r;\n      while (right > l && H[right - 1] == min_height) {\n        --right;\n      }\n      int left = l;\n      for (int i: range(l, right)) {\n        if (H[i] == min_height) {\n          if (left < i) {\n            up.emplace_back(dfs(left, i, min_height));\n            free -= i - left;\n          }\n          left = i + 1;\n        }\n      }\n      if (left < right) {\n        up.emplace_back(dfs(left, right, min_height));\n        free -= right - left;\n      }\n    }\n    if (up.empty()) {\n      return { modint(2).power(height), modint(2).power(r - l) - modint(2) };\n    }\n    modint alternate(1);\n    for (auto p: up) {\n      alternate *= p.first;\n    }\n    modint continuous = modint(2).power(free);\n    for (auto p: up) {\n      continuous *= p.first * modint(2) + p.second;\n    }\n    modint remove;\n\n    return { modint(2).power(height) * alternate, continuous - modint(2) * alternate };\n  })(0, N, 0);\n  std::cout << ans.first + ans.second << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 1e-5\n#define LONG_INF 1000000000000000000LL\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n#define MOD 998244353LL\n#define seg_size 262144*4\n#define REP(a,b) for(long long a = 0;a < b;++a)\nvector<long long> inputs;\nlong long powing(long long a, long long b) {\n\tlong long ans = 1;\n\twhile (b != 0) {\n\t\tif (b % 2) {\n\t\t\tans *= a;\n\t\t\tans %= MAX_MOD;\n\t\t}\n\t\ta *= a;\n\t\ta %= MAX_MOD;\n\t\tb /= 2;\n\t}\n\treturn ans;\n}\npair<long long, long long> dfs(long long left, long long right) {\n\tpair<long long, long long> ans = make_pair(0, 1);\n\tif (left == right) return ans;\n\tlong long height = 1e9;\n\tfor (int i = left; i < right; ++i) {\n\t\theight = min(height, inputs[i]);\n\t}\n\tfor (int i = left; i < right; ++i) {\n\t\tinputs[i] -= height;\n\t}\n\tvector<pair<long long, long long>> kouho;\n\tint back_itr = left;\n\tint cnt = 0;\n\tfor (int i = left; i < right; ++i) {\n\t\tif (inputs[i] == 0) {\n\t\t\tkouho.push_back(dfs(back_itr, i));\n\t\t\tback_itr = i + 1;\n\t\t\tcnt++;\n\t\t}\n\t}\n\tkouho.push_back(dfs(back_itr, right));\n\tfor (int i = 0; i < kouho.size(); ++i) {\n\t\tans.second *= kouho[i].second;\n\t\tans.second %= MAX_MOD;\n\t}\n\tans.first = 1;\n\tfor (int q = 0; q < kouho.size(); ++q) {\n\t\tans.first *= (kouho[q].first + kouho[q].second);\n\t\tans.first %= MAX_MOD;\n\t}\n\tans.first *= powing(2LL, cnt);\n\tans.first %= MAX_MOD;\n\tans.first += MAX_MOD - ((ans.second * 2LL) % MAX_MOD);\n\tans.first %= MAX_MOD;\n\tans.second *= powing(2LL, height);\n\tans.second %= MAX_MOD;\n\tans.first += ans.second;\n\tans.first %= MAX_MOD;\n\treturn ans;\n}\nint main() {\n\tint n;\n\tcin >> n;\n\tREP(i, n) {\n\t\tlong long a;\n\t\tcin >> a;\n\t\tinputs.push_back(a);\n\t}\n\tcout << dfs(0, inputs.size()).first << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int mod=1000000007;\ninline void add(int &x,int y){(x+=y)>=mod?x-=mod:0;}\ninline int pl(int x,int y){return (x+=y)>=mod?x-mod:x;}\ninline int kpow(int a,int b)\n{\n\tint s=1;\n\tfor(;b;b>>=1,a=1ll*a*a%mod)\n\t\tif(b&1)s=1ll*s*a%mod;\n\treturn s;\n}\nint n,h[110],dp[110][110],d[110],m,ans;\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i)scanf(\"%d\",&h[i]),d[i]=h[i];\n\tsort(d+1,d+1+n);\n\tm=unique(d+1,d+1+n)-d-1;\n\tfor(int i=1;i<=n;++i)h[i]=lower_bound(d+1,d+1+m,h[i])-d;\n\tdp[1][0]=kpow(2,d[h[1]]);\n\tfor(int i=1;i<=h[1];++i)dp[1][i]=2*kpow(2,d[h[1]]-d[i])%mod;\n\tfor(int i=0;i<h[1];++i)add(dp[1][i],mod-dp[1][i+1]);\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tif(h[i]>=h[i+1])\n\t\t{\n\t\t\tfor(int j=0;j<h[i+1];++j)dp[i+1][j]=dp[i][j];\n\t\t\tfor(int j=h[i+1];j<=h[i];++j)add(dp[i+1][h[i+1]],dp[i][j]);\n\t\t\t(dp[i+1][h[i+1]]<<=1)%=mod;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint res=kpow(2,d[h[i+1]]-d[h[i]]);\n\t\t\tfor(int j=0;j<h[i];++j)dp[i+1][j]=1ll*dp[i][j]*res%mod;\n\t\t\tfor(int j=h[i];j<=h[i+1];++j)dp[i+1][j]=2ll*dp[i][h[i]]*kpow(2,d[h[i+1]]-d[j])%mod;\n\t\t\tfor(int j=h[i];j<h[i+1];++j)add(dp[i+1][j],mod-dp[i+1][j+1]);\n\t\t}\n\t}\n\tfor(int j=0;j<=h[n];++j)add(ans,dp[n][j]);\n\tprintf(\"%d\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n//clock_t start=clock();clock_t end=clock();cout<<(double)(end-start)/CLOCKS_PER_SEC<<endl;\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int ui;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppii;\ntypedef pair<int,pii> pipi;\ntypedef pair<ll,ll> pll;\ntypedef pair<pll,ll> ppll;\ntypedef pair<ll,pll> plpl;\ntypedef pair<pii,pii> P;\ntypedef tuple<ll,ll,ll> tl;\ntypedef pair<double,double> pdd;\ntypedef vector<vector<ll>> mat;\nll mod=1000000007;\nll mod2=998244353;\nll mod3=1000003;\nll mod4=998244853;\nll mod5=1000000009;\nll inf=1LL<<62;\ndouble pi=3.141592653589793238462643383279L;\ndouble eps=1e-14;\n#define rep(i,m,n) for(ll i=m;i<n;i++)\n#define rrep(i,n,m) for(ll i=n;i>=m;i--)\n#define srep(itr,st) for(auto itr=st.begin();itr!=st.end();itr++)\n#define mrep(itr,mp) for(auto& itr:mp)\n#define Max(a,b) a=max(a,b)\n#define Min(a,b) a=min(a,b)\nint dh[4]={1,-1,0,0};\nint dw[4]={0,0,1,-1};\nint ddh[8]={-1,-1,-1,0,0,1,1,1};\nint ddw[8]={-1,0,1,-1,1,-1,0,1};\nstruct custom_hash {\n    static uint64_t splitmix64(uint64_t x) {\n        // http://xorshift.di.unimi.it/splitmix64.c\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n        return x ^ (x >> 31);\n    }\n\n    size_t operator()(uint64_t x) const {\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(x + FIXED_RANDOM);\n    }\n};\n#define umh unordered_map<ll,ll,custom_hash>\nll gcd(ll a,ll b){\n    if(a<b)swap(a,b);\n    if(b==0)return a;\n    if(a%b==0)return b;\n    return gcd(b,a%b);\n}\nll lcm(ll a,ll b){\n    ll c=gcd(a,b);\n    return a*b/c;\n}\nll Pow(ll n,ll k){\n    ll ret=1;\n    ll now=n;\n    while(k>0){\n        if(k&1)ret*=now;\n        now*=now;\n        k/=2;\n    }\n    return ret;\n}\nll beki(ll n,ll k,ll md){\n  ll ret=1;\n  ll now=n;\n    now%=md;\n  while(k>0){\n    if(k%2==1){\n      ret*=now;\n      ret%=md;\n    }\n    now*=now;\n    now%=md;\n    k/=2;\n  }\n  return ret;\n}\nll gyaku(ll n,ll md){\n  return beki(n,md-2,md);\n}\nll popcount(ll n){\n    ll ret=0;\n    ll u=n;\n    while(u>0){\n        ret+=u%2;\n        u/=2;\n        \n    }\n    return ret;\n}\nll h[110];\nll dfs(ll l,ll r,ll hl,ll hr,ll nh){\n    if(l==r)return 1;\n    ll mi=inf,num=-1;\n    ll ret=1;\n    rep(i,l,r){\n        if(mi>h[i]){\n            mi=h[i];\n            num=i;\n        }\n    }\n    if(l>hl&&r<hr){\n        (ret*=beki(2,mi-nh,mod))%=mod;\n    }\n    (ret*=dfs(l,num,hl,hr,mi))%=mod;\n    (ret*=dfs(num+1,r,hl,hr,mi))%=mod;\n    return ret;\n}\nint main(){\n    ios::sync_with_stdio(false);cin.tie(0);\n    ll n;cin>>n;\n    rep(i,1,n+1)cin>>h[i];\n   // cout<<dfs(0,3,0,3,0)<<endl;\n    h[0]=1;\n    h[n+1]=1;\n    ll dp[n+2];\n    fill(dp,dp+n+1,0);\n    dp[0]=1;\n    rep(i,1,n+1){\n        rep(j,i,n+1){\n            (dp[j]+=dp[i-1]*dfs(i-1,j+2,i-1,j+2,1))%=mod;\n        }\n    }\n    ll ans=dp[n]*2;\n    cout<<ans%mod<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//21\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\nconst int maxn = 101;\nconst int lbt = 1e9 + 7;\nconst int inf = 1e9;\n\nint n;\nint h[maxn];\n\nint fast_pow(int a, int t);\npair<int, int> cal(int l, int r, int bot);\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &h[i]);\n\t}\n\tpair<int, int> ans = cal(1, n, 0);\n\tprintf(\"%d\", (ans.first + ans.second) % lbt);\n\treturn 0;\n}\n\nint fast_pow(int a, int t) {\n\tint ans = 1;\n\tfor (int i = 31; i >= 0; i--) {\n\t\tans = (long long)ans * ans % lbt;\n\t\tif (t >> i & 1) ans = (long long)a * ans % lbt;\n\t}\n\treturn ans;\n}\n\npair<int, int> cal(int l, int r, int bot) {\n\tint minh = inf;\n\tfor (int i = l; i <= r; i++) {\n\t\tminh = min(minh, h[i]);\n\t}\n\tint g = 0;\n\tint prod = 1;\n\tint prod0 = 1;\n\tint last = l;\n\tfor (int i = l; i <= r; i++) {\n\t\tif (h[i] == minh) {\n\t\t\tg++;\n\t\t\tif (last < i) {\n\t\t\t\tpair<int, int> cur = cal(last, i - 1, minh);\n\t\t\t\tprod = (long long)prod * ((long long)2 * cur.first + cur.second) % lbt;\n\t\t\t\tprod0 = (long long)prod0 * cur.first % lbt;\n\t\t\t}\n\t\t\tlast = i + 1;\n\t\t}\n\t}\n\tif (last <= r) {\n\t\tpair<int, int> cur = cal(last, r, minh);\n\t\tprod = (long long)prod * ((long long)2 * cur.first + cur.second) % lbt;\n\t\tprod0 = (long long)prod0 * cur.first % lbt;\n\t}\n\tint dp0 = (long long)fast_pow(2, minh - bot) * prod0 % lbt;\n\tint dp1 = ((long long)fast_pow(2, g) * prod + (long long)(lbt - 2) * prod0) % lbt;\n\treturn make_pair(dp0, dp1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nvoid add(int &a, int b) {\n    a += b;\n    while(a >= MOD)\n        a -= MOD;\n    while(a < 0)\n        a += MOD;\n}\n\nvoid mult(int &a, int b) {\n    a = 1LL * a * b % MOD;\n};\n\nint len(pair<int, int> a) {\n    return a.second - a.first + 1;\n}\n\nint isInside(pair<int, int> a, pair<int, int> b) {\n    return a.first >= b.first and a.second <= b.second;\n}\n\nint two(int n) {\n    int ans = 1, temp = 2;\n    for(int i = 0; (1 << i) <= n; i += 1) {\n        if((1 << i) & n)\n            mult(ans, temp);\n        mult(temp, temp);\n    }\n    return ans;\n}\n\nint main() {\n    int n; cin >> n;\n    vector<int> v(n, 0);\n\n    for(int i = 0; i < n; i += 1) {\n        cin >> v[i];\n    }\n    \n    auto nxt = [&] (int i) {\n        if(i + 1 < n)\n            return v[i + 1];\n        return 0;\n    };\n\n    auto prv = [&] (int i) {\n        if(i - 1 >= 0)\n            return v[i - 1];\n        return 0;\n    };\n\n    vector<pair<int, int>> plateaus;\n    vector<vector<int>> minim(n, vector<int> (n, numeric_limits<int>::max()));\n\n    for(int i = 0; i < n; i += 1) {\n        for(int j = i; j < n; j += 1) {\n            minim[i][j] = min(minim[i][j], v[j]);\n            if(j - 1 >= i)\n                minim[i][j] = min(minim[i][j], minim[i][j - 1]);\n            if(prv(i) < minim[i][j] and nxt(j) < minim[i][j]) {\n                plateaus.push_back({i, j});\n            }\n        }\n    }\n\n    sort(plateaus.begin(), plateaus.end(), [&] (pair<int, int> a, pair<int, int> b) {\n        return len(a) > len(b);\n    });\n\n    int p = plateaus.size();\n    vector<bool> seen(p, 0);\n    vector<int> dp_alt(p, 0), dp_whatever(p, 0);\n    \n    auto all = [&] (int index) {\n        return (dp_whatever[index] + 2LL * dp_alt[index]) % MOD;\n    };\n\n    function<void(int, int)> rec = [&] (int index, int ground) {\n\n        seen[index] = 1;\n        vector<int> sons;\n        int min_h = minim[plateaus[index].first][plateaus[index].second];\n\n        for(int i = 0; i < p; i += 1) {\n            if(i != index and isInside(plateaus[i], plateaus[index]) and not seen[i]) {\n                rec(i, min_h);\n                sons.push_back(i);\n            }\n        }       \n\n        dp_alt[index] = 1;\n        int rem = len(plateaus[index]);\n\n        for(auto son : sons) {\n            mult(dp_alt[index], 2 * dp_alt[son] % MOD);\n            rem -= len(plateaus[son]);\n        }\n\n        dp_whatever[index] = two(rem);\n        \n        for(auto son : sons) {\n            int coef = (4LL * dp_alt[son] + dp_whatever[son]) % MOD;\n            mult(dp_whatever[index], coef);\n        }\n\n        add(dp_whatever[index], -(2 * dp_alt[index] % MOD));\n        mult(dp_alt[index], two(min_h - ground - 1));\n    };\n    \n    rec(0, 0);\n    int ans = all(0);\n    cout << ans << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(3)\n#include<bits/stdc++.h>\n#define MAXN 100005\n#define INF 1000000000\n#define MOD 1000000007\n#define F first\n#define S second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nint n,h[MAXN];\nvoid add(int &a,int b) {a+=b; if(a>=MOD) a-=MOD;}\nvoid dec(int &a,int b) {a-=b; if(a<0) a+=MOD;}\nint pow_mod(int a,int i)\n{\n    int s=1;\n    while(i)\n    {\n        if(i&1) s=1LL*s*a%MOD;\n        a=1LL*a*a%MOD;\n        i>>=1;\n    }\n    return s;\n}\nP solve(int l,int r)\n{ \n    int minh=INF;\n    for(int i=l;i<=r;i++) minh=min(minh,h[i]);\n    int cnt=0;\n    for(int i=l;i<=r;i++)\n    {\n        h[i]-=minh;\n        if(!h[i]) cnt++;\n    }\n    int ans1=1,ans2=1;\n    int lb=INF,rb=-INF;\n    for(int i=l;i<=r;i++)\n    {\n        if(h[i]==0)\n        {\n            if(rb!=-INF)\n            {\n                P p=solve(lb,rb);\n                ans1=1LL*ans1*p.F%MOD;\n                ans2=1LL*ans2*(p.F+p.S)%MOD;\n            }\n            lb=INF;rb=-INF;\n        }\n        else\n        {\n            lb=min(lb,i);\n            rb=max(rb,i);\n        }\n    }\n    if(rb!=-INF)\n    {\n        P p=solve(lb,rb);\n        ans1=1LL*ans1*p.F%MOD;\n        ans2=1LL*ans2*(p.F+p.S)%MOD;\n    }\n    ans2=1LL*ans2*pow_mod(2,cnt)%MOD;\n    int mult=pow_mod(2,minh);\n    dec(ans2,2LL*ans1%MOD); ans1=1LL*ans1*mult%MOD; add(ans2,ans1);\n    return P(ans1,ans2);\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++) scanf(\"%d\",&h[i]);\n    printf(\"%d\\n\",solve(1,n).S);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n#define fi first\n#define sc second\nconst ll mod = 1000000007;\n#define repn(i,n) for(int i=1;i<=n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mp make_pair\n#define pb push_back\n\nint n,a[105];\nll modpow(ll a,ll n){\n    ll ret = 1;\n    while(n){\n        if(n&1) ret = ret*a%mod;\n        a = a*a%mod;\n        n >>= 1;\n    }\n    return ret;\n}\nP rec(int l,int r,int dep){\n\tint mn = mod;\n\tfor(int i=l;i<=r;i++) mn = min(mn,a[i]);\n\tint cnt = 0;\n\tvector<P>ret;\n\tint sum = 0;\n\tfor(int i=l;i<=r;i++){\n\t\tif(a[i] == mn){\n\t\t\tif(cnt) ret.pb(rec(i-cnt,i-1,mn));\n\t\t\tcnt = 0;\n\t\t\tsum++;\n\t\t}\n\t\telse cnt++;\n\t}\n\tif(cnt) ret.pb(rec(r-cnt+1,r,mn));\n\t\n\t//01010101....\n\tll val = 1;\n\trep(i,ret.size()) val = val * ret[i].fi % mod * 2LL % mod;\n\t\n\t//all\n\tll val2 = modpow(2LL,sum);\n\trep(i,ret.size()) val2 = val2 * (ret[i].fi*4LL%mod+ret[i].sc) % mod;\n\tval2 = (val2-2LL*val)%mod;\n\tif(val2 < 0) val2 += mod;\n\t\n\tval = val * modpow(2LL,mn-dep-1) % mod;\n\treturn mp(val,val2);\n}\nint main(){\n\tcin >> n;\n\trepn(i,n) cin >> a[i];\n\t\n\tP ret = rec(1,n,0);\n\tll ans = ret.fi*2LL+ret.sc;\n\tcout << (ans%mod+mod)%mod << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <queue>\nusing namespace std;\ntypedef long long ll;\nconst int mod=(int)1e9+7,N=105;\nint a[N],p[N],f[N][N];\nvoid upd(int &x,int y){x=(x+y)%mod;}\nint ksm(int x,int y){\n    int tmp=x,ans=1;\n    while(y){\n        if(y&1) ans=(ll)ans*tmp%mod;\n        tmp=(ll)tmp*tmp%mod;\n        y>>=1;\n    }\n    return ans;\n}\nint main(){\n    int n,i,len,j,k,ans=0;\n    scanf(\"%d\",&n);\n    for(i=1;i<=n;i++)\n        scanf(\"%d\",&a[i]),p[i]=a[i];\n    p[n+1]=1;\n    sort(p+1,p+n+2);\n    len=unique(p+1,p+n+2)-p-1;\n    for(i=1;i<=n;i++) a[i]=lower_bound(p+1,p+len+1,a[i])-p;\n    j=1;\n    for(j=1;j<a[1];j++)\n        f[1][j]=(ll)(ksm(2,p[j+1]-p[j])-1)*ksm(2,p[a[1]]-p[j+1])%mod*2%mod;\n    f[1][a[1]]=2;\n    for(i=1;i<n;i++)\n        for(j=1;j<=a[i];j++){\n            if(a[i+1]<=a[i]){\n                if(j>=a[i+1]) upd(f[i+1][a[i+1]],f[i][j]*2%mod);\n                else upd(f[i+1][j],f[i][j]);\n            }\n            else{\n                if(j==a[i]){\n                    for(k=a[i];k<a[i+1];k++)\n                        upd(f[i+1][k],(ll)f[i][j]*2*(ksm(2,p[k+1]-p[k])-1)%mod*ksm(2,p[a[i+1]]-p[k+1])%mod);\n                    upd(f[i+1][a[i+1]],f[i][j]*2%mod);\n                }\n                else upd(f[i+1][j],(ll)f[i][j]*ksm(2,p[a[i+1]]-p[a[i]])%mod);\n            }\n        }\n    for(j=1;j<=a[n];j++) upd(ans,f[n][j]);\n    printf(\"%d\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<string>\n#include<cstring> \n#include<cassert>\n#include<cmath>\n#include<sstream>\n#include<fstream>\n#include<map>\n#include<set>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<bitset>\nusing namespace std;\nconst long long MOD=1e9+7;\nlong long quipow(int i,long long x){\n\tlong long res=1;\n\twhile(i>0){\n\t\tif(i&1) res=res*x%MOD;\n\t\tx=x*x%MOD;\n\t\ti>>=1;\n\t}\n\treturn res;\n}\nlong long dp1[105],dp2[105],ndp1[105],ndp2[105];      //dp2[i]:到第i行为止依然有序的情况 \nint h[105];\nvector<int> v;\nmap<int,int> mp;\nint main(){\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>h[i];\n\t\tv.push_back(h[i]);\n\t}\n\tsort(v.begin(),v.end());\n\tv.erase(unique(v.begin(),v.end()),v.end());\n\tfor(int i=0;i<v.size();i++) mp[v[i]]=i;\n\tfor(int i=0;v[i]<=h[0]&&i<v.size();i++){\n\t\tdp2[i]=2*quipow(h[0]-v[i],2)%MOD;\n\t\tdp1[i]=(quipow(h[0],2)-dp2[i]+MOD)%MOD;\n\t}\n\tfor(int i=1;i<n;i++){\n\t\tfor(int j=0;v[j]<=min(h[i],h[i-1])&&j<v.size();j++) {\n\t\t\tndp1[j]=dp1[j]%MOD;\n\t\t\tndp2[j]=(dp2[j]+dp2[min(mp[h[i-1]],mp[h[i]])])%MOD;\n\t\t\tdp1[j]=ndp1[j]*quipow(h[i]-h[i-1],2)%MOD;\n\t\t\tdp2[j]=ndp2[j]*quipow(h[i]-h[i-1],2)%MOD;\n\t\t}\n\t\tint idx=mp[h[i-1]];\n\t\tif(h[i]>h[i-1]){\n\t\t\tfor(int j=idx+1;v[j]<=h[i]&&j<v.size();j++){\n\t\t\t\tndp1[j]=((ndp1[j-1]+ndp2[j-1])%MOD*quipow(v[j]-v[j-1],2)%MOD-ndp2[j-1]+MOD)%MOD;\n\t\t\t\tndp2[j]=ndp2[j-1]%MOD;\n\t\t\t\tdp1[j]=ndp1[j]*quipow(h[i]-v[j],2)%MOD;\n\t\t\t\tdp2[j]=ndp2[j]*quipow(h[i]-v[j],2)%MOD;\n\t\t\t}\n\t\t}\n\t}\n\tlong long res=0;\n\tres=(dp1[mp[h[n-1]]]+dp2[mp[h[n-1]]])%MOD;\n\tcout<<res;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define TRACE(x) x\n#define WATCH(x) TRACE(cout << #x\" = \" << x << endl)\n#define WATCHR(a, b) TRACE(for (auto it=a; it!=b;) cout << *(it++) << \" \"; cout << endl)\n#define WATCHC(V) TRACE({cout << #V\" = \"; WATCHR(V.begin(), V.end());})\n\n#define all(x) (x).begin(), (x).end()\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate<int MOD> struct modnum {\n    int v;\n    modnum() : v(0) {}\n    modnum(ll _v) : v(_v % MOD) { if (v < 0) v += MOD; }\n    explicit operator int() const { return v; }\n    friend ostream& operator << (ostream& o, const modnum& n) { return o << n.v; }\n    friend istream& operator << (istream& i, modnum& n) { ll v; i >> v; n = modnum(v); return i; }\n\n    friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n    friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n    modnum& operator += (const modnum& o) { v += o.v; if (v >= MOD) v -= MOD; return *this; }\n    modnum& operator -= (const modnum& o) { v -= o.v; if (v < 0) v += MOD; return *this; }\n    modnum& operator *= (const modnum& o) { v = int(ll(v) * ll(o.v) % MOD); return *this; }\n    modnum operator - () { modnum res; if (v) res.v = MOD - v; return res; }\n    friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n    friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n    friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\n    modnum pow(int e) const {\n        if (e == 0) return 1;\n        if (e & 1) return *this * this->pow(e-1);\n        return (*this * *this).pow(e/2);\n    }\n\n    modnum inv() const {\n        int g = MOD, x = 0, y = 1;\n        for (int r = v; r != 0; ) {\n            int q = g / r;\n            g %= r; swap(g, r);\n            x -= q * y; swap(x, y);\n        }\n\n        assert(g == 1);\n        assert(y == MOD || y == -MOD);\n        return x < 0 ? x + MOD : x;\n    }\n    modnum& operator /= (const modnum& o) { return (*this) *= o.inv(); }\n    friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= modnum(b); }\n};\nusing mn = modnum<1'000'000'007>;\n\npair<mn, mn> ways(const vi &h) {\n    int mv = INT_MAX;\n    for (int v : h) {\n        mv = min(mv, v);\n    }\n\n    mn vert = 1, horiz = 1;\n\n    auto proc = [&](vi &grp) {\n        if (!grp.size()) return;\n        auto p = ways(grp);\n        grp.clear();\n\n        horiz *= p.second;\n        vert *= (p.first + p.second);\n    };\n\n    vi grp;\n    for (int v : h) {\n        if (v == mv) {\n            vert *= 2;\n            proc(grp);\n        } else {\n            grp.push_back(v - mv);\n        }\n    }\n    proc(grp);\n\n    mn checker = 2 * horiz;\n    horiz *= mn(2).pow(mv);\n    mn total = vert + horiz - checker;\n\n    return { total, horiz };\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n\n    int N;\n    cin >> N;\n\n    vi h(N);\n    for (int i = 0; i < N; i++) {\n        cin >> h[i];\n    }\n\n    cout << ways(h).first << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <numeric>\n#include <set>\n#include <vector>\nusing namespace std;\n\ntemplate<uint32_t mod> class modulo_int {\n  class dummy_type { };\n\n  modulo_int &normalize2() {\n    if (value >= mod) value -= mod;\n    return *this;\n  }\n\n  modulo_int(const uint32_t value, const dummy_type &) : value(value) {}\n\npublic:\n  explicit modulo_int(const int64_t value = 0) : value(value % mod + mod) { normalize2(); }\n\n  uint32_t get() const { return value; }\n\n  modulo_int operator+() const {\n    return *this;\n  }\n  modulo_int operator-() const {\n    return modulo_int(mod - this->value, {}).normalize2();\n  }\n  modulo_int operator+(const modulo_int &that) const {\n    return modulo_int(this->value + that.value, {}).normalize2();\n  }\n  modulo_int operator-(const modulo_int &that) const {\n    return modulo_int(this->value + (mod - that.value), {}).normalize2();\n  }\n  modulo_int operator*(const modulo_int &that) const {\n    return modulo_int(((uint64_t)(this->value) * that.value) % mod, {});\n  }\n  // mod should be prime\n  modulo_int operator/(const modulo_int &that) const {\n    return *this * that.inv();\n  }\n  friend modulo_int pow(const modulo_int base, uint64_t e) {\n    if (e == 0) return modulo_int(1, {});\n    if (e == 1) return base;\n    auto tmp = pow(base * base, e / 2);\n    return (e&1) ? tmp * base : tmp;\n  }\n\n  modulo_int &operator+=(const modulo_int &that) { return *this = *this + that; }\n  modulo_int &operator-=(const modulo_int &that) { return *this = *this - that; }\n  modulo_int &operator*=(const modulo_int &that) { return *this = *this * that; }\n  modulo_int &operator/=(const modulo_int &that) { return *this = *this / that; }\n\n  modulo_int inv() const {\n    pow(*this, mod - 2);\n  }\n\nprivate:\n  uint32_t value;\n};\n\nusing mod_t = modulo_int<1000000007>;\n\n// pair(stripe case, non-stripe case)\npair<mod_t, mod_t> solve_rec(\n    const vector<int> &h,\n    const int l,\n    const int r,\n    const int current_h\n)\n{\n  assert(r > l);\n  const int new_h = *min_element(begin(h) + l, begin(h) + r);\n  assert(new_h > current_h);\n  if (new_h == *max_element(begin(h) + l, begin(h) + r)) {\n    mod_t stripe_res = pow(mod_t(2), h[l] - current_h);\n    mod_t nonstripe_res = pow(mod_t(2), r - l) - mod_t(2);    // -2 for stripe\n    return make_pair(stripe_res, nonstripe_res);\n  }\n  vector<int> ls, rs;\n  for (int i = l; i < r; ++i) {\n    if (new_h == h[i]) continue;\n    if (rs.empty() || rs.back() != i) {\n      ls.push_back(i);\n      rs.push_back(i+1);\n    } else {\n      ++rs.back();\n    }\n  }\n  assert(ls.size() == rs.size());\n  assert(!ls.empty());\n\n  mod_t nonstripe_res(1);\n  mod_t stripe_res(1);\n  const int t = ls.size();\n  vector<mod_t> stripe, nonstripe;\n  for (int i = 0; i < t; ++i) {\n    mod_t stripe, nonstripe;\n    tie(stripe, nonstripe) = solve_rec(h, ls[i], rs[i], new_h);\n    nonstripe_res *= nonstripe + (stripe * mod_t(2));\n    stripe_res *= stripe;\n  }\n  for (int i = l; i < r; ++i) if (h[i] == new_h) nonstripe_res *= mod_t(2);\n  nonstripe_res -= stripe_res * mod_t(2);\n  stripe_res *= pow(mod_t(2), new_h - current_h);\n  return make_pair(stripe_res, nonstripe_res);\n}\n\n\nint main() {\n  int n;\n  cin >> n;\n  vector<int> h(n);\n  for (auto &x : h) cin >> x;\n  if (n == 1) {\n    cout << pow(mod_t(2), h[0]).get() << endl;\n    return 0;\n  }\n  mod_t precompute(1);\n  for (int i = 0; i < n; ++i) {\n    const int adj = max(i == 0 ? 0 : h[i-1], i == n-1 ? 0 : h[i+1]);\n    if (adj < h[i]) {\n      precompute *= pow(mod_t(2), h[i] - adj);\n      h[i] = adj;\n    }\n  }\n  mod_t stripe, nonstripe;\n  tie(stripe, nonstripe) = solve_rec(h, 0, n, 0);\n\n  cout << (precompute * (stripe + nonstripe)).get() << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N, K;\nint H[100];\nvector<int> L;\nlong long P[30];\nlong long D[101][101];\n#define MOD 1000000007LL\nlong long R;\n\nlong long pow(int x) {\n  long long r = 1;\n  for(int b = 0; b < 30; ++b) {\n    if((1 << b) & x) (r *= P[b]) %= MOD;\n  }\n  return r;\n}\nint main() {\n  P[0] = 2LL;\n  for(int i = 1; i < 30; ++i) {\n    P[i] = P[i - 1] * P[i - 1] % MOD;\n  }\n  cin >> N;\n  L.push_back(0);\n  for(int i = 0; i < N; ++i) {\n    cin >> H[i]; L.push_back(H[i]);\n  }\n  sort(L.begin(), L.end());\n  L.erase(unique(L.begin(), L.end()), L.end());\n  K = L.size();\n  /*for(int k = 0; k < K; ++k) {\n    cout << \"L[\" << k << \"] : \" << L[k] << endl;\n  }*/\n  int prev_l = 0; D[0][0] = 1;\n  for(int i = 0; i < N; ++i) {\n    int l = lower_bound(L.begin(), L.end(), H[i]) - L.begin();\n    /*cout << \"i=\" << i\n      << \" l=\" << l << \" prev_l=\" << prev_l << endl;*/\n    if(prev_l >= l) {\n      (D[i + 1][0] += 2 * D[i][0]) %= MOD;\n      for(int k = 1; k <= l; ++k) {\n        (D[i + 1][k] += D[i][k]) %= MOD;\n      }\n      for(int k = l + 1; k <= prev_l; ++k) {\n        (D[i + 1][0] += 2 * D[i][k]) %= MOD;\n      }\n    } else {\n      D[i + 1][0] += 2 * D[i][0];\n      for(int k = prev_l + 1; k <= l; ++k) {\n        (D[i + 1][k] +=\n          2 * (pow(L[k] - L[k - 1] - (k - 1 == 0 ? 1 : 0)) - 1)\n          * pow(L[l] - L[k]) % MOD\n          * D[i][0]) %= MOD;\n      }\n      long long C = pow(L[l] - L[prev_l]);\n      for(int k = 1; k <= prev_l; ++k) {\n        (D[i + 1][k] += C * D[i][k]) %= MOD;\n      }\n    }\n    /*for(int k = 0; k <= l; ++k) {\n      cout << \"  \" << \"D[][\" << k << \"]=\"\n        << D[i + 1][k] << endl;\n    }*/\n    prev_l = l;\n  }\n  for(int k = 0; k < K; ++k) {\n    (R += D[N][k]) %= MOD;\n  }\n  cout << R << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int mod=1000000007;\ninline void add(int &a,int b){\n    a+=b;\n    if(a>=mod)a-=mod;\n}\nint mpow(int a,int b){\n    int ret=1;\n    while(b){\n        if(b&1)ret=ret*a%mod;\n        a=a*a%mod;\n        b>>=1;\n    }\n    return ret;\n}\n\nint N;\nint H[111];\n\nint dp[111][111],dp2[111][111];\n\nvoid solve(int l,int r,int b){\n    int &ret=dp[l][r];\n    int &ret2=dp2[l][r];\n\n    if(ret!=-1)return;\n\n    int bb=*min_element(H+l,H+r);\n    if(*max_element(H+l,H+r)==bb){\n        ret=(mpow(2,r-l)-2+mod)%mod;\n        ret2=mpow(2,bb-b);\n        return;\n    }\n\n    vpint lis;\n    int cur=l;\n    while(cur<r){\n        if(H[cur]==bb){\n            cur++;\n            continue;\n        }\n        int nex=cur;\n        while(nex<r&&H[nex]>bb)nex++;\n        lis.pb({cur,nex});\n        solve(cur,nex,bb);\n        cur=nex;\n    }\n\n    int num=count(H+l,H+r,bb);\n\n    int x=mpow(2,num);\n    ret2=2;\n    for(auto &p:lis){\n        x=x*(dp[p.fi][p.se]+dp2[p.fi][p.se]*2)%mod;\n        ret2=ret2*dp2[p.fi][p.se]%mod;\n    }\n    ret=(x-ret2+mod)%mod;\n}\n\nsigned main(){\n    cin>>N;\n    rep(i,N)cin>>H[i];\n\n    memset(dp,-1,sizeof(dp));\n    solve(0,N,0);\n    cout<<(dp[0][N]+dp2[0][N])%mod<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N;\nint H[105];\nll mo=1000000007;\n\nll modpow(ll a, ll n = mo-2) {\n\tll r=1;a%=mo;\n\twhile(n) r=r*((n%2)?a:1)%mo,a=a*a%mo,n>>=1;\n\treturn r;\n}\n\npair<ll,ll> hoge(int L,int R,int v) {\n\tll dp1=1,dp2=1;\n\tint i;\n\t\n\tif(L>R) return {-1,1};\n\t\n\tint mi=1<<30;\n\tfor(i=L;i<=R;i++) mi=min(mi,H[i]);\n\tint W=R-L+1;\n\tfor(i=L;i<=R;i++) if(mi!=H[i]) W--;\n\t\n\tint pre=L-1;\n\tfor(i=L;i<=R;i++) {\n\t\tif(mi==H[i]) {\n\t\t\tauto r=hoge(pre+1,i-1,mi);\n\t\t\tif(r.first>=0) {\n\t\t\t\t(dp1*=r.first)%=mo;\n\t\t\t\t(dp2*=r.first+r.second)%=mo;\n\t\t\t}\n\t\t\t\n\t\t\tpre=i;\n\t\t}\n\t}\n\tauto r=hoge(pre+1,R,mi);\n\tif(r.first>=0) {\n\t\t(dp1*=r.first)%=mo;\n\t\t(dp2*=r.first+r.second)%=mo;\n\t}\n\t\n\t(dp2=dp2*modpow(2,W)+(modpow(2,mi-v)+mo-2)*dp1)%=mo;\n\t(dp1*=modpow(2,mi-v))%=mo;\n\t\n\treturn {dp1,dp2};\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tfor(i=1;i<=N;i++) cin>>H[i];\n\tcout<<hoge(1,N,0).second<<endl;\n}\n\nint main()\n{\n        solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn=111,mod=1000000007,inv2=500000004;\n#define FOR(i,a,b) for(int i=(a);i<=(b);i++)\n#define ROF(i,a,b) for(int i=(a);i>=(b);i--)\n#define MEM(x,v) memset(x,v,sizeof(x))\ntemplate<typename T>\ninline void read(T &x){\n\tx=0;\n\tchar ch=getchar();bool f=false;\n\twhile(ch<'0' || ch>'9') f|=ch=='-',ch=getchar();\n\twhile(ch>='0' && ch<='9') x=x*10+ch-'0',ch=getchar();\n\tif(f) x=-x;\n}\nint n,h[maxn],dp[maxn][maxn][2][2][2],mn[maxn][maxn],tmp[2][2][2],ans;\ninline int qpow(int a,int b){\n\tint ans=1;\n\tfor(;b;b>>=1,a=1ll*a*a%mod) if(b&1) ans=1ll*ans*a%mod;\n\treturn ans;\n}\nvoid go_lower(int f[][2][2],int cnt){\n\tif(!cnt) return;\n\tint g[2][2][2];\n\tMEM(g,0);\n\tFOR(a,0,1) FOR(b,0,1) FOR(c,0,1) if(c){\n\t\tif(cnt%2==0) g[a][b][c]=f[a][b][c];\n\t\telse g[a^1][b^1][c]=f[a][b][c];\n\t}\n\telse{\n\t\tg[a][b][c]=(g[a][b][c]+1ll*f[a][b][c]*qpow(2,cnt-1))%mod;\n\t\tg[a^1][b^1][c]=(g[a^1][b^1][c]+1ll*f[a][b][c]*qpow(2,cnt-1))%mod;\n\t}\n\tFOR(a,0,1) FOR(b,0,1) FOR(c,0,1) f[a][b][c]=g[a][b][c];\n}\nvoid merge(int f[][2][2],int g[][2][2]){\n\tint h[2][2][2];\n\tMEM(h,0);\n\tFOR(a,0,1) FOR(b,0,1) FOR(c,0,1) FOR(d,0,1) FOR(e,0,1) FOR(f_,0,1){\n\t\tint to=c|f_|(b==d);\n\t\th[a][e][to]=(h[a][e][to]+1ll*f[a][b][c]*g[d][e][f_])%mod;\n\t}\n\tFOR(a,0,1) FOR(b,0,1) FOR(c,0,1) f[a][b][c]=h[a][b][c];\n}\nvoid dfs(int l,int r){\n\tif(l>r) return;\n\tif(l==r){\n\t\tdp[l][r][0][0][0]=dp[l][r][1][1][0]=1;\n\t\treturn;\n\t}\n\tint last=l-1;\n\tFOR(i,l,r) if(h[i]==mn[l][r]){\n\t\tif(last+1<=i-1){\n\t\t\tdfs(last+1,i-1);\n\t\t\tgo_lower(dp[last+1][i-1],mn[last+1][i-1]-mn[l][r]);\n\t\t\tif(last==l-1){\n\t\t\t\tFOR(a,0,1) FOR(b,0,1) FOR(c,0,1) dp[l][r][a][b][c]=dp[last+1][i-1][a][b][c];\n\t\t\t}\n\t\t\telse merge(dp[l][r],dp[last+1][i-1]);\n\t\t}\n\t\tif(i==l) FOR(a,0,1) FOR(b,0,1) FOR(c,0,1) dp[l][r][a][b][c]=tmp[a][b][c]; \n\t\telse merge(dp[l][r],tmp);\n\t\tlast=i;\n\t}\n\tif(last!=r){\n\t\tdfs(last+1,r);\n\t\tgo_lower(dp[last+1][r],mn[last+1][r]-mn[l][r]);\n\t\tif(last==l-1){\n\t\t\tFOR(a,0,1) FOR(b,0,1) FOR(c,0,1) dp[l][r][a][b][c]=dp[last+1][r][a][b][c];\n\t\t}\n\t\telse merge(dp[l][r],dp[last+1][r]);\n\t}\n}\nint main(){\n\tread(n);\n\tFOR(i,1,n) read(h[i]);\n\tFOR(i,1,n){\n\t\tmn[i][i]=h[i];\n\t\tFOR(j,i+1,n) mn[i][j]=min(mn[i][j-1],h[j]);\n\t}\n\ttmp[0][0][0]=tmp[1][1][0]=1;\n\tdfs(1,n);\n\tgo_lower(dp[1][n],mn[1][n]-1);\n\tFOR(a,0,1) FOR(b,0,1) FOR(c,0,1) ans=(ans+dp[1][n][a][b][c])%mod;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<iostream>\n#define LL long long\nusing namespace std;\nconst LL mod=1e9+7;\nLL f[110][110][2],n,h[110];\nbool vis[110][110];\nLL Pow(LL a,LL b)\n{\n\tLL ans=1;\n\twhile(b)\n\t{\n\t\tif(b&1) ans=ans*a%mod;\n\t\ta=a*a%mod;b>>=1;\n\t}\n\treturn ans;\n}\nvoid solve(LL l,LL r,LL s)\n{\n\t//printf(\"solve:%lld %lld %lld\\n\",l,r,s);\n\tbool flag=true;\n\tfor(LL i=l;i<r;i++) if(h[i]!=h[i+1]) flag=false;\n\tif(flag)\n\t{\n\t\tLL c=Pow(2,r-l+1);\n\t\tf[l][r][1]=(c-2+mod)%mod;\n\t\tf[l][r][0]=Pow(2,h[l]-s+1);\n\t\t//printf(\"f:%lld %lld\\n\",f[l][r][0],f[l][r][1]);\n\t\treturn;\n\t}\n\tLL t=1e9+10,cnt=0;\n\tfor(LL i=l;i<=r;i++)\n\t{\n\t\tif(h[i]<t) t=h[i],cnt=0;\n\t\tif(t==h[i]) cnt++;\n\t}\n\tLL p=l,g0=2,g1=1;\n\t//printf(\"t:%lld\\n\",t);\n\twhile(p<=r)\n\t{\n\t\twhile(p<=r&&h[p]==t) p++;\n\t\tLL q=p;\n\t\twhile(q<=r&&h[q]!=t) q++;\n\t\tif(p<=r)\n\t\t{\n\t\t\tsolve(p,q-1,t+1);\n\t\t\t(g0*=f[p][q-1][0])%=mod;\n\t\t\t(g1*=(f[p][q-1][0]*2+f[p][q-1][1])%mod)%=mod;\n\t\t}\n\t\t//printf(\"g0 g1:%lld %lld\\n\",g0,g1);\n\t\tp=q;\n\t}\n\t//printf(\"g1:%lld\\n\",g1);\n\t(g1*=Pow(2,cnt))%=mod;g1-=g0;(g1+=mod)%=mod;\n\t(g0*=Pow(2,t-s))%=mod;\n\t//printf(\"now:%lld %lld %lld %lld %lld\\n\",l,r,s,g0,g1);\n\tf[l][r][0]=g0;f[l][r][1]=g1;\n}\nint main()\n{\n\tscanf(\"%lld\",&n);\n\tfor(LL i=1;i<=n;i++) scanf(\"%lld\",&h[i]);\n\tmemset(vis,false,sizeof(vis));\n\tLL tot=1;\n\tfor(LL i=1;i<=n;i++) if(h[i]>h[i-1]&&h[i]>h[i+1])\n\t{\n\t\tLL t=max(h[i-1],h[i+1]);\n\t\t(tot*=Pow(2,h[i]-t))%=mod;h[i]=t;\n\t}\n\tsolve(1,n,1);\n\tprintf(\"%lld\",tot*(f[1][n][0]+f[1][n][1])%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int MOD = (int)1e9 + 7;\n\nint n,m,h[101],hnum[101],dh[101];\nLL dp[101][101];\n\nint pow_(int x,int y) {///快速幂求 x的y次方\n    int ans = 1;\n    if(y > 0) {\n        while(y) {\n            if(y % 2)ans = (LL)ans * x % MOD;\n            x = (LL)x * x % MOD;\n            y /= 2;\n        }\n    }\n    return ans;\n}\n\nint main() {\n    scanf(\"%d\",&n);\n    for(int i = 1;i <= n;i ++) {\n        scanf(\"%d\",&h[i]);\n        dh[++ m] = h[i];\n    }\n    sort(dh + 1,dh + m + 1);///高度排序\n    m = unique(dh + 1,dh + m + 1) - dh - 1;///离散化 m是离散化后的长度\n    for(int i = 1;i <= n;i ++) {\n        hnum[i] = lower_bound(dh + 1,dh + m + 1,h[i]) - dh;\n    }\n    dp[0][0]=1;\n    for(int i = 1;i <= n;i ++) {\n        for(int j = hnum[i] + 1;j <= hnum[i - 1];j ++)\n            (dp[i][0] += dp[i - 1][j] * 2 % MOD) %= MOD;\n\n        (dp[i][0] += dp[i - 1][0] * 2 % MOD) %= MOD;///交叉或者不交叉\n\n        int d = pow_(2,h[i] - h[i - 1]);\n        for(int j = 1;j <= min(hnum[i - 1],hnum[i]);j ++) {\n            dp[i][j] = dp[i - 1][j] * d % MOD;\n        }\n        for(int j = hnum[i - 1] + 1;j <= hnum[i];j ++) {///比前一列高出的部分\n            if(j > 1)(dp[i][j] += dp[i - 1][0] * (pow_(2,dh[j] - dh[j - 1]) - 1) % MOD * 2 % MOD * pow_(2,h[i] - dh[j]) % MOD) %= MOD;\n            else (dp[i][1] += dp[i - 1][0] * (pow_(2,dh[1]) - 2) % MOD * pow_(2,h[i] - dh[1]) % MOD) %= MOD;///上一列中无重复相同的乘上化不超过上一列高度中有重复的\n        }\n    }\n    LL ans = 0;\n    for(int i = 0;i <= hnum[n];i++)\n        (ans += dp[n][i]) %= MOD;\n    printf(\"%lld\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define INF 2e9\n#define mo 1000000007\nusing namespace std;\nstruct Info{ll p1,p2;};\nint a[1010],n;\nll po(ll x,ll y){ll z=1;while (y){if (y%2==1)z=(x*z)%mo;x=(x*x)%mo;y/=2;}return z;}\nInfo work(int l,int r,int x){\n\tint mi=INF;\n\tInfo z,y;\n\tll c1=1,c2=1,c3=0;\n\tfor(int i=l;i<=r;i++)mi=min(mi,a[i]);\n\tfor(int i=l;i<=r;i++)if(a[i]==mi)c3++;\n\tfor(int i=l,j;i<=r;i=j+1){\n\t\tj=i;\n\t\tif (a[i]>mi){while (a[j+1]>mi)j++;y=work(i,j,mi);c1=c1*y.p1%mo,c2=c2*(y.p1+y.p2)%mo;}\n\t}\n\tz.p1=c1*po(2,mi-x)%mo;\n\tz.p2=(c2*po(2,c3)+c1*(po(2,mi-x)-2+mo))%mo;\n\treturn z;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tcout<<work(1,n,0).p2<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\n#define LL long long\n#define fgx cerr<<\"--------------\"<<endl;\n#define dgx cerr<<\"==============\"<<endl;\n\ninline int read(){\n\tint x=0,f=1;char c=getchar();\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0';\n\treturn x*f;\n}\nconst int MAXN = 10010;\nconst int INF = 2147483600;\nconst LL Mod = 1000000007LL;\n\nint N; int a[MAXN+1]; \n\nint f[19][MAXN+1],g[19][MAXN+1],Log2[MAXN+1],mn;\ninline LL Pow(LL a,LL b){\n\tLL ret=1; for(;b;b>>=1,a=a*a%Mod) if(b&1) ret=ret*a%Mod; return ret;\n}\ninline int qry(int l,int r){\n\tint x=Log2[r-l+1]; mn=min(f[x][l],f[x][r-(1<<x)+1]);\n\tif(f[x][l]<=f[x][r-(1<<x)+1]) return g[x][l];\n\telse return g[x][r-(1<<x)+1];\n}\ninline void Init(){\n\tfor(int i=1;i<N;i++) f[0][i]=a[i],g[0][i]=i;\n\tfor(int i=2;i<N;i++) Log2[i]=Log2[i>>1]+1;\n\tfor(int j=1;j<=19;j++){\n\t\tfor(int i=1;i+(1<<j)-1<N;i++){\n\t\t\tf[j][i]=min(f[j-1][i],f[j-1][i+(1<<(j-1))]); g[j][i]=INF;\n\t\t\tif(f[j-1][i]==f[j][i]) g[j][i]=min(g[j][i],g[j-1][i]);\n\t\t\tif(f[j-1][i+(1<<(j-1))]==f[j][i]) g[j][i]=min(g[j][i],g[j-1][i+(1<<(j-1))]); \n\t\t}\n\t}\n} int cnt; int Len[MAXN+1],ln[MAXN+1],rn[MAXN+1],To[MAXN+1],Sum[MAXN+1];\nint nxt[MAXN+1];\ninline int div(int base,int l,int r){\n\tint x=qry(l,r); int bs=mn,id=cnt+1,nx; ln[++cnt]=l; rn[cnt]=r; Sum[cnt]=bs-base; Len[cnt]=Sum[cnt];\n\tint last=l-1; while(x<=r&&x){ if(last+1<x) {nx=div(bs,last+1,x-1); Sum[id]+=Sum[nx];} last=x; x=nxt[x]; } \n\tif(last<r) nx=div(bs,last+1,r),Sum[id]+=Sum[nx];\n\tTo[id]=cnt+1;\n\treturn id;\n}\nint b[MAXN+1],pos[MAXN+1]; LL h[MAXN+1]; LL Pw2[MAXN+1];\n\nint main(){\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tN=read(); int anspw=0;\n\tfor(int i=1;i<=N;i++) a[i]=read();\n\tfor(int i=1;i<=N;i++){\n\t\tif(a[i]>a[i-1]&&a[i]>a[i+1]){\n\t\t\tint d=a[i];\n\t\t\ta[i]=max(a[i-1],a[i+1]); anspw+=d-a[i];\n\t\t}\n\t} for(int i=1;i<=N;i++) a[i]--;\n\tfor(int i=1;i<N;i++) a[i]=min(a[i],a[i+1]),b[i]=a[i];\n\tsort(b+1,b+N); int n=unique(b+1,b+N)-b-1;\n\tfor(int i=1;i<N;i++){\n\t\tint c=lower_bound(b+1,b+n+1,a[i])-b;\n\t\tnxt[pos[c]]=i; pos[c]=i;\n\t} Init(); div(0,1,N-1);\n\th[1]=1; Pw2[0]=1;\n\tfor(int i=1;i<=N;i++) Pw2[i]=Pw2[i-1]*2%Mod;\n\tln[cnt+1]=rn[cnt+1]=N;\n\tfor(int i=1;i<=cnt;i++){\n\t\tif(!To[i]) To[i]=cnt+1;\n\t\t(h[To[i]]+=h[i]*((Pow(2,Sum[i])-Pow(2,Sum[i]-Len[i])+Mod)%Mod)%Mod*Pw2[ln[To[i]]-rn[i]-1]%Mod)%=Mod;\n\t\t(h[i+1]+=h[i]*((Pw2[ln[i+1]-ln[i]]+Mod)%Mod)%Mod)%=Mod;\n\t} \n\tprintf(\"%lld\\n\",h[cnt+1]*Pow(2,anspw)%Mod*2%Mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#define mp make_pair\n#define pb push_back\nusing namespace std;\ntypedef long long li;\n\nconst int Mod = 1e9 + 7;\n\ninline int Add(int x, int y) {\n  x += y;\n  if (x >= Mod) x -= Mod;\n  else if (x < 0) x += Mod;\n  return x;\n}\ninline int Mul(int x, int y) {\n  return 1LL * x * y % Mod;\n}\nint Pow(int a, int b) {\n  int res = (a == 0) ? 0 : 1;\n  while (b) {\n    if (b & 1) res = Mul(res, a);\n    a = Mul(a, a);\n    b >>= 1;\n  }\n  return res;\n}\n\nconst int N = 110;\nint n, h[N];\nint f[N][N][2][2][2], g[2][2][2];\n\nint Getmin(int l, int r) {\n  int res = Mod;\n  for (int i = l; i <= r; ++i)\n    res = min(res, h[i]);\n  return res;\n}\nvoid Calc(int l, int r, int delta_h) {\n  memset(g, 0, sizeof g);\n  for (int i = 0; i < 2; ++i)\n    for (int j = 0; j < 2; ++j) {\n      if (delta_h) {\n\tg[i][j][0] = Add(g[i][j][0], Mul(f[l][r][i][j][0], Pow(2, delta_h - 1)));\n\tg[j][i][0] = Add(g[j][i][0], Mul(f[l][r][i][j][0], Pow(2, delta_h - 1)));\n      } else {\n\tg[i][j][0] = Add(g[i][j][0], f[l][r][i][j][0]);\n      }\n      if (delta_h & 1) {\n\tg[i ^ 1][j ^ 1][1] = Add(g[i ^ 1][j ^ 1][1], f[l][r][i][j][1]);\n      } else {\n\tg[i][j][1] = Add(g[i][j][1], f[l][r][i][j][1]);\n      }\n    }\n  memcpy(f[l][r], g, sizeof g);\n}\nvoid Merge(int l, int r, int nowl, int nowr) {\n  memset(g, 0, sizeof g);\n  for (int i = 0; i < 2; ++i)\n    for (int j = 0; j < 2; ++j)\n      for (int k = 0; k < 2; ++k)\n\tfor (int xi = 0; xi < 2; ++xi)\n\t  for (int xj = 0; xj < 2; ++xj)\n\t    for (int xk = 0; xk < 2; ++xk) {\n\t      int p = i, q = xj;\n\t      int s = k || xk || (j == xi);\n\t      int now = Mul(f[l][r][i][j][k], f[nowl][nowr][xi][xj][xk]);\n\t      g[p][q][s] = Add(g[p][q][s], now);\n\t    }\n  memcpy(f[l][r], g, sizeof g);\n}\nvoid Solve(int l, int r) {\n  if (l == r) {\n    f[l][r][0][0][0] = f[l][r][1][1][0] = 1;\n    return;\n  }\n  vector<pair<int, int> >now;\n  int hmin = Getmin(l, r);\n  int pre = l;\n  for (int i = l; i <= r; ++i)\n    if (h[i] == hmin) {\n      if (pre < i) now.pb(mp(pre, i - 1));\n      now.pb(mp(i, i));\n      pre = i + 1;\n    }\n  if (pre <= r) now.pb(mp(pre, r));\n  for (int i = 0; i < (int)now.size(); ++i) {\n    int nowl = now[i].first, nowr = now[i].second;\n    Solve(nowl, nowr);\n    Calc(nowl, nowr, Getmin(nowl, nowr) - hmin);\n    if (i) Merge(l, r, nowl, nowr);\n    else memcpy(f[l][r], f[nowl][nowr], sizeof g);\n  }\n}\n\nint main(void) {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; ++i)\n    scanf(\"%d\", &h[i]);\n  Solve(1, n);\n  Calc(1, n, Getmin(1, n) - 1);\n  int ans = 0;\n  for (int i = 0; i < 2; ++i)\n    for (int j = 0; j < 2; ++j)\n      for (int k = 0; k < 2; ++k)\n\tans = Add(ans, f[1][n][i][j][k]);\n  printf(\"%d\\n\", ans);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 110, P = 1000000007;\nint n, a[maxn];\n\nint qp(int x, int y) {\n    int z = 1;\n    for (; y; y >>= 1, x = 1LL * x * x % P) {\n        if (y & 1) z = 1LL * z * x % P;\n    }\n    return z;\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n    function<pair<int, int>(int, int, int)> solve = [&](int l, int r, int lst) {\n        int x = *min_element(a + l, a + r + 1);\n        int coef = 1, sum = 1, num = r - l + 1;\n        for (int i = l, j; i <= r; i++) if (a[i] ^ x) {\n            for (j = i; a[j] ^ x && j <= r; j++) num--;\n            auto p = solve(i, j - 1, x); i = j;\n            coef = 1LL * coef * p.first % P;\n            sum = 1LL * sum * (p.first + p.second) % P;\n        }\n        return pair<int, int>(1LL * coef * qp(2, x - lst) % P,\n            (1LL * sum * qp(2, num) + 1LL * coef * (qp(2, x - lst) - 2) % P) % P);\n    };\n    auto p = solve(1, n, 0);\n    printf(\"%d\\n\", (p.second + P) % P);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n\ntypedef long long LL;\n\nconst int N=105;\nconst int MOD=1000000007;\n\nint n,f[N][N],h[N],w[N],m;\n\nint ksm(int x,int y)\n{\n    if (y<0) return 1;\n    int ans=1;\n    while (y)\n    {\n        if (y&1) ans=(LL)ans*x%MOD;\n        x=(LL)x*x%MOD;y>>=1;\n    }\n    return ans;\n}\n\nint main()\n{\n    scanf(\"%d\",&n);\n    for (int i=1;i<=n;i++) scanf(\"%d\",&h[i]),w[++m]=h[i];\n    std::sort(w+1,w+m+1);\n    m=std::unique(w+1,w+m+1)-w-1;\n    for (int i=1;i<=n;i++) h[i]=std::lower_bound(w+1,w+m+1,h[i])-w;\n    f[0][0]=1;\n    for (int i=1;i<=n;i++)\n    {\n        for (int j=h[i]+1;j<=h[i-1];j++) (f[i][0]+=f[i-1][j]*2%MOD)%=MOD;\n        (f[i][0]+=f[i-1][0]*2%MOD)%=MOD;\n        for (int j=1;j<=h[i];j++)\n        {\n            f[i][j]=(LL)f[i-1][j]*ksm(2,w[h[i]]-w[h[i-1]])%MOD;\n            if (h[i-1]>=j) continue;\n            if (j>1) (f[i][j]+=(LL)f[i-1][0]*(ksm(2,w[j]-w[j-1])-1)%MOD*2%MOD*ksm(2,w[h[i]]-w[j])%MOD)%=MOD;\n            else (f[i][j]+=(LL)f[i-1][0]*(ksm(2,w[j])-2)%MOD*ksm(2,w[h[i]]-w[j])%MOD)%=MOD;\n        }\n    }\n    int ans=0;\n    for (int i=0;i<=m;i++) (ans+=f[n][i])%=MOD;\n    printf(\"%d\",ans);\n    return 0;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\ntemplate <typename TYPE> inline void chkmax(TYPE &x,TYPE y){x<y?x=y:0;}\ntemplate <typename TYPE> inline void chkmin(TYPE &x,TYPE y){y<x?x=y:0;}\ntemplate <typename TYPE> void readint(TYPE &x)\n{\n    x=0;int f=1;char c;\n    for(c=getchar();!isdigit(c);c=getchar())if(c=='-')f=-1;\n    for(;isdigit(c);c=getchar())x=x*10+c-'0';\n    x*=f;\n}\nconst int MAXN=105,MOD=1000000007;\nint qmi(int x,int y)\n{\n\tint ans=1;\n\tfor(;y;y>>=1,x=1ll*x*x%MOD)\n\t\tif(y&1)ans=1ll*ans*x%MOD;\n\treturn ans;\n}\n\nint n,a[MAXN],f[MAXN][MAXN],g[MAXN][MAXN];\nvoid solve(int l,int r,int x)\n{\n\tint y=1<<30,las=l-1,w=0;\n\tfor(int i=l;i<=r;++i)chkmin(y,a[i]);\n\tfor(int i=l;i<=r;++i)if(a[i]==y)++w;\n\tif(w==r-l+1)\n\t{\n\t\tf[l][r]=(1ll*qmi(2,y-x)+qmi(2,r-l+1)-2+MOD)%MOD;\n\t\tg[l][r]=qmi(2,y-x);\n\t\treturn;\n\t}\n\tf[l][r]=qmi(2,w);\n\tg[l][r]=1;\n\tfor(int i=l;i<=r+1;++i)\n\t\tif(i>r || a[i]==y)\n\t\t{\n\t\t\tif(i-las>=2)\n\t\t\t{\n\t\t\t\tsolve(las+1,i-1,y);\n\t\t\t\tg[l][r]=1ll*g[l][r]*g[las+1][i-1]%MOD;\n\t\t\t\tf[l][r]=1ll*f[l][r]*(g[las+1][i-1]+f[las+1][i-1])%MOD;\n\t\t\t}\n\t\t\tlas=i;\n\t\t}\n\tf[l][r]=(f[l][r]+1ll*g[l][r]*(qmi(2,y-x)-2+MOD))%MOD;\n\tg[l][r]=1ll*g[l][r]*qmi(2,y-x)%MOD;\n//cerr<<l<<\" \"<<r<<\":\"<<f[l][r]<<\" \"<<g[l][r]<<endl;\n}\n\nint main()\n{\n\t#ifndef ONLINE_JUDGE\n//\tfreopen(\"code.in\",\"r\",stdin);\n//\tfreopen(\"code.out\",\"w\",stdout);\n\t#endif\n\treadint(n);\n\tfor(int i=1;i<=n;++i)readint(a[i]);\n\tsolve(1,n,0);\n\tprintf(\"%d\\n\",f[1][n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nconst ll mod=1e9+7;\nusing namespace std;\nbool __DBG=1;\nll N;\nll f[110][110],g[110];\nll a[110],H[110],lisan[110],lcnt;\nll &ml=lcnt;\nll ans;\nll qpow(ll a,ll b) {\n    ll ans=1;\n    for(;b;b>>=1,a=(a*a)%mod) if(b&1) ans=(ans*a)%mod;\n    return ans;\n}\nvoid tt(int i,int j) {\n    if(!__DBG) return;\n    printf(\"f[%d][%d]=%lld\\n\",i,j,f[i][j]);\n}\nint main() {\n    //cerr<<qpow(2,0)<<endl;\n    scanf(\"%lld\",&N);\n    for(int i=1;i<=N;++i) scanf(\"%lld\",a+i),lisan[i]=a[i];\n    sort(lisan+1,lisan+N+1);\n    lcnt=unique(lisan+1,lisan+N+1)-lisan-1;\n    for(int i=1;i<=N;++i) H[i]=lower_bound(lisan+1,lisan+lcnt+1,a[i])-lisan;\n    //for(int i=1;i<=N;++i) printf(\"H[%d]=%lld\\n\",i,H[i]);\n    g[1]=2;\n    for(int i=1;i<=H[1];++i) f[1][i]=qpow(2,a[1]-lisan[i])*(qpow(2,lisan[i])-2);//,tt(1,i);\n    for(int i=H[1]+1;i<=ml;++i) f[1][i]=f[1][i-1];//,tt(1,i);\n    for(int i=2;i<=N;++i) {\n        for(int j=1;j<=H[i];++j) {\n            f[i][j]+=f[i-1][j]*qpow(2,max(0ll,a[i]-a[i-1]))%mod;\n            f[i][j]%=mod;\n            if(j>H[i-1]) {\n                f[i][j]+=2*g[i-1]*qpow(2,a[i]-lisan[j])%mod*(qpow(2,lisan[j]-a[i-1])-1)%mod;\n                f[i][j]%=mod;\n            }\n           // tt(i,j);\n        }\n        for(int j=H[i]+1;j<=ml;++j) f[i][j]=f[i][j-1];\n        if(H[i-1]<=H[i]) g[i]=g[i-1]*2%mod;\n        else g[i]=g[i-1]*2%mod+(f[i-1][H[i-1]]-f[i-1][H[i]]+mod)*2%mod;\n        g[i]=(g[i]%mod+mod)%mod;\n        //printf(\"g[%d]=%lld\\n\",i,g[i]);\n    }\n    ans=g[N]+f[N][ml];\n    //printf(\"ans=%lld\\n\",ans);\n    printf(\"%lld\\n\",ans%mod);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ri register int\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\t// input a signed integer\n\ttemplate <class I>\n\tinline void gi (I &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = (x << 1) + (x << 3) + (c & 15); x *= f;\n\t}\n\t// input a letter\n\ttemplate <class I>\n\tinline void get (I &x) {\n\t\tfor (c = gc(); c < 'A' || c > 'Z'; c = gc()) ;\n\t\tx = c;\n\t}\n\t// input a string\n\tinline void read (char *s){\n\t\tfor(c = gc(); c < 'A' || c > 'Z'; c = gc()) ;\n\t\tfor(; c >= 'A' && c <= 'Z'; c = gc()) *++s = c;\n\t\t*++s = '\\0';\n\t}\n\t// print a signed integer\n\ttemplate <class I>\n\tinline void print (I x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t}\n\t//no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io :: gi;\nusing io :: get;\nusing io :: read;\nusing io :: putc;\nusing io :: print;\nconst int N=105,mod=1e9+7;\nint h[N];\nstruct segtree{\n\t#define pii pair<int,int>\n\t#define fi first\n\t#define se second\n\t#define mp make_pair\n\tpii res[N<<2];\n\t#define lc x<<1\n\t#define rc x<<1|1\n\tinline void build(ri x,ri l,ri r){\n\t\tif(l==r){\n\t\t\tres[x]=mp(h[l],l);\n\t\t\treturn;\n\t\t}\n\t\tri mid=l+r>>1;\n\t\tbuild(lc,l,mid);\n\t\tbuild(rc,mid+1,r);\n\t\tres[x]=min(res[lc],res[rc]); \n\t}\n\tinline pii query(ri x,ri l,ri r,ri ql,ri qr){\n\t\tif(ql<=l&&r<=qr)\n\t\t\treturn res[x];\n\t\tpii ans=mp(2e9,2e9);\n\t\tri mid=l+r>>1;\n\t\tif(ql<=mid) ans=query(lc,l,mid,ql,qr);\n\t\tif(qr> mid) ans=min(ans,query(rc,mid+1,r,ql,qr));\n\t\treturn ans;\n\t}\n\t#undef lc\n\t#undef rc\n}seg;\nint n,size,tl[N],tr[N],t[N];\nvector<int> e[N];\ninline int build(ri l,ri r){\n\tri x=++size,lst,i;\n\ttl[x]=l;tr[x]=r;\n\tt[x]=seg.query(1,1,n,l,r).fi;\n\tvector<int> v;\n\tpii now;\n\tfor(i=l;i<=r;i=now.se+1){\n\t\tnow=seg.query(1,1,n,i,r);\n\t\tif(now.fi>t[x]) break;\n\t\tv.push_back(now.se);\n\t}\n\tv.push_back(r+1);\n\tlst=l-1;\n\tfor(int p:v){\n\t\tif(lst+1<=p-1)\n\t\t\te[x].push_back(build(lst+1,p-1)),\n\t\t\tt[e[x].back()]-=t[x];\n\t\tlst=p;\n\t}\n\treturn x;\n}\ninline int mu(ri x,ri y){\n\treturn (long long)x*y%mod;\n}\ninline int add(ri x,ri y){\n\treturn (x+=y)>=mod?x-mod:x;\n}\ninline int sub(ri x,ri y){\n\treturn (x-=y)<0?x+mod:x;\n}\ninline int fpow(ri a,ri b){\n\tri ans=1;\n\tfor(;b;b>>=1,a=mu(a,a))\n\t\tif(b&1)\n\t\t\tans=mu(ans,a);\n\treturn ans;\n}\nint f[N][2];\ninline void dfs(ri x){\n\tri len=tr[x]-tl[x]+1;\n\tfor(int y:e[x])\n\t\tdfs(y),\n\t\tlen-=tr[y]-tl[y]+1;\n\tf[x][0]=fpow(2,len);\n\tf[x][1]=2;\n\tfor(int y:e[x])\n\t\tf[x][0]=mu(f[x][0],add(f[y][0],mu(2,f[y][1]))),\n\t\tf[x][1]=mu(f[x][1],f[y][1]);\n\tf[x][0]=sub(f[x][0],f[x][1]);\n\tf[x][1]=mu(f[x][1],fpow(2,t[x]-1));\n\t// f[x][0] 非01相间的方案数\n\t// f[x][1]   01相间的方案数 \n}\nint main(){\n\tri i;\n\tgi(n);\n\tfor(i=1;i<=n;++i)\n\t\tgi(h[i]);\n\tseg.build(1,1,n);\n\tbuild(1,n);\n\tdfs(1);\n\tprintf(\"%d\\n\",add(f[1][0],f[1][1])); \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long int int64;\nstatic const int64 mod = 1000000007LL;\n\nint64 pow2(int x)\n{\t\n\tint64 val = 1;\n\tfor(int i = 30;i >= 0;--i) {\n\t\tval = val * val % mod;\n\t\tif(((x >> i) & 1) == 1) {\n\t\t\tval = val * 2 % mod;\n\t\t}\n\t}\n\treturn val;\n}\n\nstd::pair<int64,int64> solve(std::vector<int> h)\n{\n\tif(h.empty()) return std::make_pair(1,1);\n\tint min = h[0];\n\tfor(int i = 1;i < h.size();++i) if(h[i] < min) min = h[i];\n\tstd::vector<int> cur;\n\tint64 v1 = 1, v2 = 1;\n\tint w = 0;\n\tfor(int i = 0;i <= h.size();++i) {\n\t\tif(i == h.size() || h[i] == min) {\n\t\t\tif(!cur.empty()) {\n\t\t\t\tstd::pair<int64,int64> res = solve(cur);\n\t\t\t\tv1 = v1 * res.first % mod;\n\t\t\t\tv2 = v2 * (res.first + res.second) % mod;\n\t\t\t\tcur.clear();\n\t\t\t}\n\t\t\t++w;\n\t\t} else {\t\n\t\t\tcur.push_back(h[i] - min);\n\t\t}\n\t}\n\t--w;\n\treturn std::make_pair(v1*pow2(min)%mod, (v2*pow2(w)+(pow2(min)-2)*v1)%mod);\n}\n\nint main()\n{\n\tint n;\n\tstd::vector<int> h;\n\tscanf(\"%d\",&n);\n\tfor(int i = 0;i < n;++i) {\n\t\tint k;\n\t\tscanf(\"%d\",&k);\n\t\th.push_back(k);\n\t}\n\tstd::pair<int64,int64> ans = solve(h);\n\tprintf(\"%lld\\n\", ans.second);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\nconst int mod = 1000000007;\nint a[110];\nint pow(int x, int p) {\n\tif (p == 0) return 1;\n\tif (p == 1) return x;\n\tlong long res = pow(x, p / 2);\n\tres = res * res % mod;\n\tif (p & 1) {\n\t\tres = res * x % mod;\n\t}\n\treturn res;\n}\nint dp[110][110][2][2][2];\nvoid add(int &x, long long v) {\n\tx += v;\n\tif (x >= mod) x -= mod;\n}\nvoid go(int l, int r, int b) {\n\tint h = *min_element(a + l, a + r);\n\tfor (int i = l; i < r; i++) {\n\t\tif (a[i] == h) {\n\t\t\tif (i == l) {\n\t\t\t\tdp[l][i+1][0][0][0] = 1;\n\t\t\t\tdp[l][i+1][1][1][0] = 1;\n\t\t\t} else {\n\t\t\t\tfor (int x = 0; x < 2; x++) {\n\t\t\t\t\tfor (int y = 0; y < 2; y++) {\n\t\t\t\t\t\tfor (int z = 0; z < 2; z++) {\n\t\t\t\t\t\t\tfor (int u = 0; u < 2; u++) {\n\t\t\t\t\t\t\t\tadd(dp[l][i+1][x][u][z|(y==u)], dp[l][i][x][y][z]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tint j = i;\n\t\twhile (a[j] > h) ++j;\n\t\tgo(i, j, h);\n\t\tif (i > l) {\n\t\t\tfor (int x = 0; x < 2; x++) {\n\t\t\t\tfor (int y = 0; y < 2; y++) {\n\t\t\t\t\tfor (int z = 0; z < 2; z++) {\n\t\t\t\t\t\tlong long d = dp[i][j][x][y][z];\n\t\t\t\t\t\tfor (int u = 0; u < 2; u++) {\n\t\t\t\t\t\t\tfor (int v = 0; v < 2; v++) {\n\t\t\t\t\t\t\t\tfor (int w = 0; w < 2; w++) {\n\t\t\t\t\t\t\t\t\tadd(dp[l][j][u][y][z|w|(v==x)], ((long long)dp[l][i][u][v][w] * d) % mod);\n\t\t\t\t\t\t\t\t\tif (!z) {\n\t\t\t\t\t\t\t\t\t\tadd(dp[l][j][u][y^1][z|w|(v==(x^1))], ((long long)dp[l][i][u][v][w] * d) % mod);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (int x = 0; x < 2; x++) {\n\t\t\t\tint s = dp[l][j][x][0][0];\n\t\t\t\tadd(s, dp[l][j][x^1][1][0]);\n\t\t\t\tdp[l][j][x][0][0] = dp[l][j][x^1][1][0] = s % mod;\n\t\t\t\tswap(dp[l][j][x][0][1], dp[l][j][x^1][1][1]);\n\t\t\t}\n\t\t}\n\t\ti = j - 1;\n\t}\n\tif (h - b == 1) return;\n\tint pa = (h - b - 1) & 1;\n\tlong long m = pow(2, h - b - 2);\n\tfor (int i = 0; i < 2; i++) {\n\t\tint s = dp[l][r][i][0][0];\n\t\tadd(s, dp[l][r][i^1][1][0]);\n\t\tdp[l][r][i][0][0] = dp[l][r][i^1][1][0] = m * s % mod;\n\t\tswap(dp[l][r][i][0][1], dp[l][r][i^1][1][1]);\n\t}\n}\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\tgo(0, n, 0);\n\tint ans = 0;\n\tfor (int x = 0; x < 2; x++) {\n\t\tfor (int y = 0; y < 2; y++) {\n\t\t\tfor (int z = 0; z < 2; z++) {\n\t\t\t\tadd(ans, dp[0][n][x][y][z]);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\n#include <stdlib.h>\n#include <vector>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <string.h>\n#include <stack>\n#define Endl endl\n#define mp make_pair\n#define ll long long \n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define over(A) {cout<<A<<endl;exit(0);}\n#define all(A) A.begin(),A.end()\n#define ceil(a,b) ((a-1)/b+1)\n#define srand() mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n#define rand(l,r) uniform_int_distribution<int>(l,r)(rng)\ntypedef unsigned long long ull;\nconst int inf=1039074182;\nusing namespace std;\nint n;\nint h[105];\nint res=1;\nvector <pair<pair<int,int>,int> >vec;\nint dp[105][105][2];\n\nnamespace combinatorics\n{\n\tint mod=1e9+7;\n\tinline int add(int a,int b)\n\t{\n\t\treturn (a+b)%mod;\n\t}\n\tinline int minus(int a,int b)\n\t{\n\t\treturn (a-b+mod)%mod;\n\t}\n\tinline int mutiply(int a,int b)\n\t{\n\t\treturn (1LL*a*b)%mod;\n\t}\n\tinline int fastpow(int basic,int x)\n\t{\n\t\tint res=1;\n\t\twhile(x)\n\t\t{\n\t\t\tif(x&1)\tres=mutiply(res,basic);\n\t\t\tbasic=mutiply(basic,basic);\n\t\t\tx>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tinline int inv(int x)\n\t{\n\t\treturn fastpow(x,mod-2);\n\t}\n};\nusing namespace combinatorics;\n\ninline void solve(int l,int r)\n{\n//\tcout<<l<<' '<<r<<endl;\n//\tSleep(1000);\n\tif(l==r) return;\n\tint mi=inf,ma=inf;\n\tfor(int i=l;i<r;i++)\n\t{\n\t\tmi=min(mi,h[i]);\n\t}\n\tvec.push_back({{l,r},mi-(l==0 && r==n)});\n\tfor(int i=l;i<r;i++)\n\t{\n\t\th[i]-=mi;\n\t}\n\tint last=l;\n\tfor(int i=l;i<=r;i++)\n\t{\n\t\tif(h[i]==0) solve(last,i),last=i+1;\n\t}\n}\n\ninline int way(int l,int r)\n{\n\tint res=0;\n\tfor(auto x:vec)\n\t{\n\t\tif(l<=x.first.first && r>=x.first.second) res=add(res,x.second);\n\t}\n\treturn fastpow(2,res);\n}\n\nint main()\n{\n\tcin>>n;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcin>>h[i];\n\t}\n\tsolve(0,n);\n//\tfor(auto x:vec)\n//\t{\n//\t\tprintf(\"From %d to %d, having %d floors.\\n\",x.first.first+1,x.first.second,x.second);\n//\t}\n\tdp[0][1][0]=1;\n\tdp[0][1][1]=1;\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tfor(int j=1;j<=i+1;j++)\n\t\t{\n\t\t\tfor(int k=0;k<2;k++)\n\t\t\t{\n\t\t\t\tdp[i+1][j+1][k]=add(dp[i+1][j+1][k],dp[i][j][k]);\n\t\t\t\tdp[i+1][1][!k]=add(dp[i+1][1][!k],mutiply(dp[i][j][k],way(i-j+1,i+1)));\n\t\t\t}\n\t\t}\n\t}\n\tint res=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tdp[n-1][i][0]=mutiply(dp[n-1][i][0],way(n-i,n));\n\t\tdp[n-1][i][1]=mutiply(dp[n-1][i][1],way(n-i,n));\n\t\tres=add(res,add(dp[n-1][i][0],dp[n-1][i][1]));\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <fstream>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <complex>\n#include <iomanip>\n#include <stdio.h>\n#include <string.h>\n#include <random>\n#include <functional>\n\nusing std::cin;\nusing std::cout;\nusing std::cerr;\nusing std::endl;\n\nusing std::map;\nusing std::set;\nusing std::bitset;\nusing std::vector;\nusing std::string;\nusing std::multimap;\nusing std::multiset;\nusing std::deque;\nusing std::queue;\nusing std::stack;\nusing std::pair;\nusing std::iterator;\n\nusing std::sort;\nusing std::stable_sort;\nusing std::reverse;\nusing std::max_element;\nusing std::min_element;\nusing std::unique;\nusing std::ios_base;\nusing std::swap;\nusing std::fill;\n\nusing std::setprecision;\nusing std::fixed;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<long long> vl;\ntypedef string S;\n\nll min(ll a, ll b) {return a < b ? a : b;}\nll min(int a, ll b) {return a < b ? a : b;}\nll min(ll a, int b) {return a < b ? a : b;}\nll min(int a, int b) {return a < b ? a : b;}\n\nll max(ll a, ll b) {return a > b ? a : b;}\nll max(int a, ll b) {return a > b ? a : b;}\nll max(ll a, int b) {return a > b ? a : b;}\nll max(int a, int b) {return a > b ? a : b;}\n\nnamespace MySpace{\n\n};\n\n#define F(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define fi first\n#define se second\n#define re return\n#define all(x) (x).begin(), (x).end()\n#define int long long\n\nconst int N = 111;\nconst int MOD = 1e9 + 7;\n\nint n;\nint h[500];\nint dp[N][N][N];\nint kek[N][N];\n\nlong long inq(long long x, long long y)\n{\n    if (y == 0) return 1;\n    long long l = inq(x, y / 2);\n    if (y % 2) return l * l % MOD * x % MOD;\n    return l * l % MOD;\n}\n\nvoid calc(int l, int r)\n{\n    if (l == r)\n    {\n        int x = max(h[l - 1], h[r + 1]);\n        dp[l][r][0] = inq(2, h[l] - x);\n        return;\n    }\n    int pos = l;\n    for (int i = l; i <= r; i++)\n    {\n        if (h[i] < h[pos]) pos = i;\n    }\n    if (h[pos] < h[l - 1] || h[pos] < h[r + 1]) return;\n    //if (pos != l) calc(l, pos - 1);\n    //if (pos != r) calc(pos + 1, r);\n    int a = h[pos];\n    int b = max(h[l - 1], h[r + 1]);\n    dp[l][r][0] = (inq(2, a - b - (b == 0)) - 1) * inq(2, kek[l][r] - a + 1) % MOD;\n    //cout << l << \" \" << r << \" \" << pos << \" \" << a << \" \" << b << \" \" << kek[l][r] << endl;\n    if (pos == l)\n    {\n    \tfor (int k = 1; k <= r - l; k++) dp[l][r][k] = dp[l + 1][r][k - 1];\n    \treturn;\n    }\n    if (pos == r)\n    {\n    \tfor (int k = 1; k <= r - l; k++) dp[l][r][k] = dp[l][r - 1][k - 1];\n    \treturn;\n    }\n    for (int a = 0; a < pos - l; a++)\n    for (int b = 0; b < r - pos; b++)\n    dp[l][r][a + b + 2] = (dp[l][r][a + b + 2] + dp[l][pos - 1][a] * dp[pos + 1][r][b]) % MOD;\n}\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n;\n    for (int i = 1; i <= n; i++) cin >> h[i];\n    for (int l = 1; l <= n; l++)\n    {\n    \tint lh = 1;\n    \tfor (int r = l; r <= n; r++)\n    \t{\n    \t\tkek[l][r] = kek[l][r - 1];\n    \t\tif (h[r] > lh) kek[l][r] += h[r] - lh, lh = h[r];\n    \t}\n    }\n    /*for (int l = 1; l <= n; l++)\n    {\n    \tfor (int r = 1; r <= n; r++)\n    \t{\n    \t\tcout << kek[l][r] << \" \";\n    \t}\n    \tcout << \"\\n\";\n    }\n    cout << \"\\n\";*/\n    for (int len = 1; len <= n; len++)\n    {\n        for (int i = 1; i + len - 1 <= n; i++)\n        {\n        \tint j = i + len - 1;\n            int k = 1e9;\n            for (int x = i; x <= j; x++) if (h[x] < k) k = h[x];\n            if (h[i - 1] <= k && h[j + 1] <= k) calc(i, j);\n        }\n    }\n    int ans = 0;\n    for (int c = 0; c <= n - 1; c++)\n    {\n        ans = (ans + inq(2, c) * dp[1][n][c]) % MOD;\n    }\n    cout << 2 * ans % MOD;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nint w[110], n, D[110], Mod = 1000000007;\nint Pow(int a, long long b) {\n\tint r = 1;\n\twhile (b) {\n\t\tif (b & 1)r = 1ll * r*a%Mod;\n\t\ta = 1ll * a*a%Mod; b >>= 1;\n\t}\n\treturn r;\n}\nint main() {\n\tint i, j, k;\n\tscanf(\"%d\", &n);\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &w[i]);\n\t}\n\tD[0] = 1;\n\tw[n + 1] = 1;\n\tfor (i = 1; i <= n + 1; i++) {\n\t\tD[i] = D[i - 1] * 2;\n\t\tfor (j = 1; j < i; j++) {\n\t\t\tint b = max(w[i], w[j - 1]), e = w[j] - 1;\n\t\t\tlong long s = 0;\n\t\t\tfor (k = j; k < i; k++) {\n\t\t\t\te = min(e, w[k] - 1);\n\t\t\t\ts += max(w[k + 1] - w[k], 0);\n\t\t\t}\n\t\t\tif (b <= e) {\n\t\t\t\tint t1 = Pow(2, w[j] - 1 - e);\n\t\t\t\tint t2 = Pow(2, e - b + 1) - 1;\n\t\t\t\tint t3 = Pow(2, s);\n\t\t\t\tD[i] = (D[i] + 4ll * D[j - 1] * t1 % Mod* t2%Mod * t3)%Mod;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", 1ll*D[n + 1]*((Mod+1)/2)%Mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nconst int N = 105;\nconst int INF = 0x3f3f3f3f;\ntypedef long long ll;\n#define lson l, m, rt<<1\n#define rson m+1, r, rt<<1|1\nconst int MOD = 1e9+7;\n\n\nint h[N];\nint Has[N]; int tot;\nll dp[N][N];\n\nll Pow(ll x, ll y) {\n\tif(y <= 0) return 1;\n\tll result = 1;\n\twhile(y) {\n\t\tif(y & 1)\n\t\t\tresult = result * x % MOD;\n\t\ty >>= 1;\n\t\tx = x*x % MOD;\n\t}\n\treturn result;\n}\n\nint main() {\n\tint n;\n\twhile(~scanf(\"%d\", &n)) {\n\t\ttot = 0;\n\t\tmemset(dp, 0, sizeof(dp));\n\t\th[0] = 0;\n\t\tdp[0][0] = 1;\n\n\t\tfor(int i = 1; i <= n; ++i) {\n\t\t\tscanf(\"%d\", &h[i]);\n\t\t\tHas[++tot] = h[i];\n\t\t}\n\t\tsort(Has + 1, Has + tot + 1);\n\t\ttot = unique(Has+1, Has + tot + 1) - Has - 1;\n\t\t\n\t\tfor(int i = 1; i <= n; ++i) {\n\t\t\th[i] = lower_bound(Has + 1, Has + tot + 1, h[i]) - Has;\n\t\t}\n\t\t\n\t\t\n\t\tfor(int i = 1; i <= n; ++i) {\n\t\t\tdp[i][0] = dp[i-1][0] * 2 % MOD;\n\t\t\tfor(int j = h[i] + 1; j <= h[i-1]; ++j) dp[i][0] = (dp[i][0] + dp[i-1][j] * 2 % MOD) % MOD;\n\n\t\t\tll tmpPow = Pow(2, Has[h[i]] - Has[h[i-1]]);\n\t\t\tfor(int j = 1; j <= h[i-1]; ++j) {\n\t\t\t\tdp[i][j] = dp[i-1][j] * tmpPow % MOD;\n\t\t\t}\n\n\t\t\tfor(int j = h[i-1] + 1; j <= h[i]; ++j) {\n\t\t\t\tdp[i][j] = j==1? ( dp[i-1][0] * ( Pow(2, Has[j]) - 2) % MOD * Pow(2, Has[h[i]] - Has[j]) % MOD ) :\n\t\t\t\t\t\t\t\t\t\t\t ( dp[i-1][0] * 2 * (Pow(2, Has[j]-Has[j-1]) - 1) % MOD * Pow(2, Has[h[i]]-Has[j]) % MOD );\n\t\t\t}\n\t\t}\n\n\n\t\tll result = 0;\n\t\tfor(int i = 0; i <= tot; ++i) {\n\t\t\tresult = (result + dp[n][i]) % MOD;\n\t\t}\n\t\tprintf(\"%lld\\n\", result);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;const int mod=1000000007;typedef pair<long long,long long> pii;int h[105];\ninline int qpow(int a,int b) {int rtv=1;for (;b;b>>=1,a=1LL*a*a%mod) if (b&1) rtv=1LL*rtv*a%mod;return rtv;}\ninline pii dac(int l,int r,int bnd) {long long mn=1e18,cnt=0,rem=r-l+1,ans0=1,ans1=1;pii _;\n\tfor (int i=l;i<=r;++i) if (h[i]<mn) mn=h[i],cnt=1;else if (h[i]==mn) ++cnt;\n\tif (cnt==r-l+1) return make_pair((qpow(2,r-l+1)+mod-2)%mod,qpow(2,mn-bnd-1));\n\tfor (int i=l,j=0;i<=r+1;++i) if (!j&&h[i]>mn) j=i;\n\t\telse if (j&&(h[i]==mn||i>r)) {rem-=i-j,_=dac(j,i-1,mn),j=0;\n\t\t\tans0=1LL*ans0*(_.first+(4LL*_.second%mod)%mod)%mod,ans1=1LL*ans1*(_.second<<1)%mod;\n\t\t}ans0=(ans0-ans1+mod)%mod;\n\treturn make_pair((1LL*ans0*qpow(2,rem)%mod+1LL*ans1*(qpow(2,rem)+mod-2)%mod)%mod,1LL*ans1*qpow(2,mn-bnd-1)%mod);\n}int main() {int n,prod=1;pii _;scanf(\"%d\",&n);for (int i=1;i<=n;++i) scanf(\"%d\",h+i);\n\tif (n<2) return 0*printf(\"%d\",qpow(2,h[1]));\n\tfor (register int i=1;i<=n;++i) if (h[i]>h[i-1]&&h[i]>h[i+1])\n\t\tprod=1LL*prod*qpow(2,h[i]-max(h[i-1],h[i+1]))%mod,h[i]=max(h[i-1],h[i+1]);\n\t_=dac(1,n,0);printf(\"%lld\",1LL*prod*((_.first+_.second+_.second)%mod)%mod);return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int mod = 1e9 + 7;\nint n, m, l[105], r[105];\nll h[105], a[105], dp[105][2];\nll Pow(ll a, int x) {\n\tll res = 1;\n\twhile (x) {\n\t\tif (x & 1) (res *= a) %= mod;\n\t\t(a *= a) %= mod;\n\t\tx >>= 1; \n\t}\n\treturn res;\n}\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> h[i];\n\t\ta[i] = h[i];\n\t}\n\tsort(a + 1, a + 1 + n);\n\tm = unique(a + 1, a + 1 + n) - a - 1;\n\tfor (int i = m; i >= 1; i--) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tif (h[j] > a[i]) {\n\t\t\t\tif (h[j - 1] > a[i]) {\n\t\t\t\t\tdp[j][0] = dp[j - 1][0];\n\t\t\t\t\tdp[j][1] = dp[j - 1][1];\n\t\t\t\t}\n\t\t\t\tif (h[j - 1] == a[i]) {\n\t\t\t\t\tdp[j][0] = (dp[j][0] + dp[j][1]) % mod;\n\t\t\t\t\tdp[j][1] = (2 * dp[j][1]) % mod;\n\t\t\t\t\tdp[j][0] = dp[j - 1][0] * dp[j][0] % mod;\n\t\t\t\t\tdp[j][1] = dp[j - 1][1] * dp[j][1] % mod * Pow(2, mod - 2) % mod;\n\t\t\t\t}\n\t\t\t\tif (h[j - 1] < a[i]) {\n\t\t\t\t\tdp[j][0] = (dp[j][0] + dp[j][1]) % mod;\n\t\t\t\t\tdp[j][1] = (2 * dp[j][1]) % mod;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (h[j] == a[i]) {\n\t\t\t\tif (h[j - 1] >= h[j]) {\n\t\t\t\t\tdp[j][0] = dp[j - 1][0] * 2 % mod;\n\t\t\t\t\tdp[j][1] = dp[j - 1][1];\n\t\t\t\t} \n\t\t\t\telse {\n\t\t\t\t\tdp[j][0] = 2;\n\t\t\t\t\tdp[j][1] = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int j = n; j >= 1; j--) {\n\t\t\tif (h[j] >= a[i] && h[j + 1] >= a[i]) {\n\t\t\t\tdp[j][0] = dp[j + 1][0];\n\t\t\t\tdp[j][1] = dp[j + 1][1];\n\t\t\t}\n\t\t}\n\t\tfor (int j = n; j >= 1; j--) {\n\t\t\tint k = a[i] - a[i - 1] - 1;\n\t\t\tdp[j][0] = (dp[j][0] + dp[j][1] * (Pow(2, k) - 1) % mod) % mod,\n\t\t\tdp[j][1] = dp[j][1] * Pow(2, k) % mod;\n\t\t}\n\t}\n\tcout << dp[1][0];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nconst int N=1010,mod=1e9+7;\nint n,ans=1,x,y,high[N];\nint power(int p)\n{\n\tint ans=1,v=2;\n\tfor(;p;p>>=1,v=1ll*v*v%mod)\n\t if(p&1)ans=1ll*ans*v%mod;\n\treturn ans;\n}\nvoid slove(int l,int r,int h,int &a,int &b)\n{\n\tint minf=0x7fffffff,cnt=0;\n\tfor(int i=l;i<=r;i++)\n\t if(high[i]<minf)minf=high[i],cnt=1;\n\t else if(high[i]==minf)cnt++;\n\tif(cnt==r-l+1)\n\t{\n\t\ta=power(r-l+1)-2;if(a<0)a+=mod;\n\t\tb=power(minf-h);\n\t\treturn;\n\t}\n\tint x,y,last=0,v1=1,v2=1;\n\tfor(int i=l;i<=r+1;i++)\n\t{\n\t\tif(!last&&high[i]>minf)last=i;\n\t\telse if(last&&(high[i]<=minf||i==r+1))\n\t\t{\n\t\t\tslove(last,i-1,minf,x,y);\n\t\t\tv1=1ll*v1*((x+y*2)%mod)%mod;\n\t\t\tv2=1ll*v2*y%mod;last=0;\n\t\t}\n\t}\n\ta=1ll*v1*power(cnt)%mod;\n\ta=(a-v2*2)%mod;if(a<0)a+=mod;\n\tb=v2*power(minf-h)%mod;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t scanf(\"%d\",&high[i]);\n\tfor(int i=1;i<=n;i++)\n\t if(high[i]>high[i-1]&&high[i]>high[i+1])\n\t {\n\t    ans=1ll*ans*power(high[i]-max(high[i-1],high[i+1]))%mod;\n\t    high[i]=max(high[i-1],high[i+1]);\n\t }\n\tslove(1,n,0,x,y);\n\tans=1ll*ans*(x+y)%mod;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<string>\n#include<cstring> \n#include<cassert>\n#include<cmath>\n#include<sstream>\n#include<fstream>\n#include<map>\n#include<set>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<bitset>\nusing namespace std;\nconst long long MOD=1e9+7;\nlong long quipow(int i,unsigned long long x){\n\tlong long res=1;\n\twhile(i>0){\n\t\tif(i&1) res=res*x%MOD;\n\t\tx=x*x%MOD;\n\t\ti>>=1;\n\t}\n\treturn res;\n}\nlong long dp1[105],dp2[105],ndp1[105],ndp2[105];      //dp2[i]:到第i行为止依然有序的情况 \nint h[105];\nvector<int> v;\nmap<int,int> mp;\nint main(){\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>h[i];\n\t\tv.push_back(h[i]);\n\t}\n\tsort(v.begin(),v.end());\n\tv.erase(unique(v.begin(),v.end()),v.end());\n//\tcout<<v.size()<<endl;\n\tfor(int i=0;i<v.size();i++) mp[v[i]]=i;\n\tfor(int i=0;v[i]<=h[0]&&i<v.size();i++){\n\t\tdp2[i]=2*quipow(h[0]-v[i],2);\n\t\tdp1[i]=(quipow(h[0],2)-dp2[i]+MOD)%MOD;\n\t//\tcout<<i<<\" \"<<dp1[i]<<\" \"<<dp2[i]<<endl;\n\t}\n\tfor(int i=1;i<n;i++){\n\t//\tcout<<i<<\" \"<<h[i]<<\":\\n\";\n\t\tfor(int j=0;v[j]<=min(h[i],h[i-1])&&j<v.size();j++) {\n\t\t\tndp1[j]=dp1[j];\n\t\t\tndp2[j]=(dp2[j]+dp2[min(mp[h[i-1]],mp[h[i]])])%MOD;\n\t\t\tdp1[j]=ndp1[j]*quipow(h[i]-h[i-1],2)%MOD;\n\t\t\tdp2[j]=ndp2[j]*quipow(h[i]-h[i-1],2)%MOD;\n\t//\t\tcout<<dp1[j]<<\" \"<<dp2[j]<<endl;\n\t\t}\n\t\tint idx=mp[h[i-1]];\n\t\tif(h[i]>h[i-1]){\n\t\t\tfor(int j=idx+1;v[j]<=h[i]&&j<v.size();j++){\n\t\t\t\tndp1[j]=((ndp1[j-1]+ndp2[j-1])%MOD*quipow(v[j]-v[j-1],2)%MOD-ndp2[j-1]+MOD)%MOD;\n\t\t\t\tndp2[j]=ndp2[j-1];\n\t\t\t\tdp1[j]=ndp1[j]*quipow(h[i]-v[j],2)%MOD;\n\t\t\t\tdp2[j]=ndp2[j]*quipow(h[i]-v[j],2)%MOD;\n\t\t\t}\n\t\t}\n\t}\n\tlong long res=0;\n\tres=(dp1[mp[h[n-1]]]+dp2[mp[h[n-1]]])%MOD;\n\tcout<<res;\n}"
  },
  {
    "language": "C++",
    "code": "// ███▓▓▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓╬╬╬╬╬╬▓█\n// ███▓███████▓▓╬╬╬╬╬╬╬╬╬╬╬╬▓███▓▓▓▓█▓╬╬╬▓█\n// ███████▓█████▓▓╬╬╬╬╬╬╬╬▓███▓╬╬╬╬╬╬╬▓╬╬▓█\n// ████▓▓▓▓╬╬▓█████╬╬╬╬╬╬███▓╬╬╬╬╬╬╬╬╬╬╬╬╬█\n// ███▓▓▓▓╬╬╬╬╬╬▓██╬╬╬╬╬╬▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓█\n// ████▓▓▓╬╬╬╬╬╬╬▓█▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓█\n// ███▓█▓███████▓▓███▓╬╬╬╬╬╬▓███████▓╬╬╬╬▓█\n// ████████████████▓█▓╬╬╬╬╬▓▓▓▓▓▓▓▓╬╬╬╬╬╬╬█\n// ███▓▓▓▓▓▓▓╬╬▓▓▓▓▓█▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓█\n// ████▓▓▓╬╬╬╬▓▓▓▓▓▓█▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓█\n// ███▓█▓▓▓▓▓▓▓▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓█\n// █████▓▓▓▓▓▓▓▓█▓▓▓█▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓█\n// █████▓▓▓▓▓▓▓██▓▓▓█▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n// █████▓▓▓▓▓████▓▓▓█▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n// ████▓█▓▓▓▓██▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n// ████▓▓███▓▓▓▓▓▓▓██▓╬╬╬╬╬╬╬╬╬╬╬╬█▓╬▓╬╬▓██\n// █████▓███▓▓▓▓▓▓▓▓████▓▓╬╬╬╬╬╬╬█▓╬╬╬╬╬▓██\n// █████▓▓█▓███▓▓▓████╬▓█▓▓╬╬╬▓▓█▓╬╬╬╬╬╬███\n// ██████▓██▓███████▓╬╬╬▓▓╬▓▓██▓╬╬╬╬╬╬╬▓███\n// ███████▓██▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬████\n// ███████▓▓██▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓████\n// ████████▓▓▓█████▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓█████\n// █████████▓▓▓█▓▓▓▓▓███▓╬╬╬╬╬╬╬╬╬╬╬▓██████\n// ██████████▓▓▓█▓▓▓╬▓██╬╬╬╬╬╬╬╬╬╬╬▓███████\n// ███████████▓▓█▓▓▓▓███▓╬╬╬╬╬╬╬╬╬▓████████\n// ██████████████▓▓▓███▓▓╬╬╬╬╬╬╬╬██████████\n// ███████████████▓▓▓██▓▓╬╬╬╬╬╬▓███████████\n// #pragma GCC optimize(\"Ofast\")\n// #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,tune=native\")\n// #pragma GCC optimize(\"unroll-loops\")    \n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <cmath>\n#include <bitset>\n#include <cassert>\n#include <queue>\n#include <deque>\n#include <cassert>\n#include <iomanip> \n#include <chrono>\n#define pb push_back\n#define x first\n#define y second\n#define mp make_pair\n#define files(FILENAME) read(FILENAME); write(FILENAME)\n#define read(FILENAME) freopen((string(FILENAME) + \".in\").c_str(), \"r\", stdin)\n#define write(FILENAME) freopen((string(FILENAME) + \".out\").c_str(), \"w\", stdout)\nusing namespace std;\n        \ntemplate<typename T1, typename T2>inline void chkmin(T1 &x, T2 y) { if (x > y) x = y; }\ntemplate<typename T1, typename T2>inline void chkmax(T1 &x, T2 y) { if (x < y) x = y; } \ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const pair<T, U> &_p) { _out << _p.first << ' ' << _p.second; return _out; }\ntemplate<typename T, typename U> inline istream &operator>> (istream &_in, pair<T, U> &_p) { _in >> _p.first >> _p.second; return _in; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const vector<T> &_v) { if (_v.empty()) { return _out; } _out << _v.front(); for (auto _it = ++_v.begin(); _it != _v.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline istream &operator>> (istream &_in, vector<T> &_v) { for (auto &_i : _v) { _in >> _i; } return _in; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const set<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const multiset<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const unordered_set<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const unordered_multiset<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const map<T, U> &_m) { if (_m.empty()) { return _out; } _out << '(' << _m.begin()->first << \": \" << _m.begin()->second << ')'; for (auto _it = ++_m.begin(); _it != _m.end(); ++_it) { _out << \", (\" << _it->first << \": \" << _it->second << ')'; } return _out; }\ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const unordered_map<T, U> &_m) { if (_m.empty()) { return _out; } _out << '(' << _m.begin()->first << \": \" << _m.begin()->second << ')'; for (auto _it = ++_m.begin(); _it != _m.end(); ++_it) { _out << \", (\" << _it->first << \": \" << _it->second << ')'; } return _out; }\n \ntypedef long double base;        \ntypedef pair<int, int> point;\n\nconst int p = 1e9 + 7;\n\nint a[101];\n\nint sum(int a, int b) {\n\ta += b;\n\treturn a < p ? a : a - p;\n}\n\nint mul(long long a, int b) {\n\treturn a * b % p;\n}\n\nint powx(int a, int b) {\n\tint ans = 1;\n\twhile (b) {\n\t\tif (b & 1) ans = mul(ans, a);\n\t\ta = mul(a, a);\n\t\tb >>= 1;\n\t}\n\treturn ans;\n}\n\nconst int rev2 = powx(2, p - 2);\n\nint n;\nint h[101];\n\npair<int, int> res(int Ln, int Rn, int cur_h) {\n\tint min_h = 1e9;\n\tfor (int i = Ln; i < Rn; ++i) {\n\t\tchkmin(min_h, h[i]);\n\t}\n\tint L = Ln;\n\tint ans1 = 1, ans2 = 1, cnt0 = 0, cnt1 = 0;\n\twhile (L < Rn) {\n\t\tif (h[L] == min_h) {\n\t\t\t++cnt0;\n\t\t\t++L;\n\t\t\tcontinue;\n\t\t}\n\t\t++cnt1;\n\t\tint R = L;\n\t\twhile (R < Rn && h[R] != min_h) {\n\t\t\t++R;\n\t\t}\n\t\tauto rep = res(L, R, min_h);\n\t\trep.x = sum(rep.x, rep.x);\n\t\tans1 = mul(ans1, rep.x);\n\t\tans2 = mul(ans2, mul(2, sum(rep.x, rep.y)));\n\t\tL = R; \n\t}\n\tcnt0 = powx(2, cnt0);\n\tcnt1 = powx(2, cnt1);\n\t// cout << ans1 << ' ' << ans2 << ' ' << cnt0 << ' ' << cnt1 << endl;\n\tpair<int, int> ans = {0, 0};\n\tans.x = mul(ans1, 2);\n\tans.y = sum(mul(ans2, cnt0), p - ans.x);\n\t// cout << ans.x << ' ' << ans.y << endl;\n\tans.x = mul(ans.x, powx(2, min_h - cur_h - 1));\n\tans.x = mul(ans.x, rev2);\n\tans.y = mul(ans.y, rev2);\n\treturn ans;\n}\n\nint main() {\n\tios::sync_with_stdio(0);\n\tsrand(time(0));\n\t//read(\"input\");\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> h[i];\n\t}\n\tauto rep = res(0, n, 0);\n\tcout << mul(2, sum(rep.x, rep.y)) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <fstream>\n#include <iostream>\n#include <algorithm>\n#include <bitset>\n#include <array>\n#include <vector>\n#include <queue>\n#include <set>\n#include <cmath> // 変数名にy1が使えなくなるかも…。\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <string>\n\ntypedef __int128_t int128_t;\nstd::istream &operator>>(std::istream& input, int128_t& value) { // int128_tの入力。入力が64bitに収まる前提。\n    long long tmp; input >> tmp; value = tmp;\n    return input;\n}\nstd::ostream &operator<<(std::ostream& output, const int128_t value) { // int128_tの出力。出力が64bitに収まる前提。\n    output << (long long)value;\n    return output;\n}\n\nint128_t cal_mod(const int128_t n, const int128_t mod) {\n    // n % modを計算する。ただしmod <= 0 ならば何もしない。nが負の場合、正にして補正する。\n    if (mod <= 0) {\n        return n;\n    } else if (0 <= n) {\n        return n % mod;\n    } else {\n        int128_t tmp = (-n) / mod + 1;\n        return (n + tmp * mod) % mod;\n    }\n}\n\nint128_t pow_mod(int128_t x, int128_t n, const int128_t mod) {\n    // 累乗の計算。mod <= 0ならば余りの計算は行わない。\n    int128_t ret = 1;\n    while (n > 0) {\n        if (n & 1) { ret = cal_mod(ret * x, mod); }\n        x = cal_mod(x * x, mod);\n        n = (n >> 1);\n    }\n    return ret;\n}\n\nconst int MOD = 1e9 + 7;\nconst int MAX_H = 1e9 + 7;\nconst int MAX_N = 110;\nint N;\nint128_t h[MAX_N];\n\nint128_t s[MAX_N]; // s[i]:i番目に低い山（高さ2以上）の高さ。\nstd::map<int128_t, int> mp; // 2以上の高さに対して、何番目に低いか。\n\nint128_t dp[MAX_N][MAX_N] = {};\n// dp[i][j] : i番目の列まで塗終わり、その列で最初に現れる連続同色がs[j]の高さに収まる(s[j-1]には収まらない)塗り方の数。\n// dp[i][0] は、連続同色が現れない塗り方。\n\nint128_t calc_sub(int128_t h1, int128_t h2) {\n    // h1まで交互に塗った1つの塗り方に対して、h2までに連続塗りを含む塗り方がいくつあるか。\n    return cal_mod(pow_mod(2, h2 - h1, MOD) - 1, MOD);\n}\n\nint main(int argc, char **argv) {\n    std::cin >> N;\n    \n    for (int i = 1; i <= N; i++) {\n        std::cin >> h[i];\n    }\n\n    for (int i = 1; i <= N; i++) {\n        if (1 < h[i]) {\n            mp[h[i]] = 1;\n        }\n    }\n    int cnt = 1;\n    for (auto itr = mp.begin(); itr != mp.end(); ++itr) {\n        mp[itr->first] = cnt;\n        s[cnt] = itr->first;\n        cnt++;\n    }\n    s[0] = 1;\n    s[cnt] = MAX_H;\n    dp[0][0] = 1;\n\n    //std::cout << \"check:\" << s[0] << \" \" << s[1] << \" \" << s[2] << \" \" << s[3] << std::endl;\n\n    for (int i = 1; i <= N; i++) {\n        if (h[i] == 1) {\n            for (int j = 0; j < cnt; j++) {\n                dp[i][0] = (dp[i][0] + dp[i-1][j] * 2) % MOD;\n            }\n        } else if (i == 1 || h[i-1] == 1) {\n            dp[i][0] = dp[i-1][0] * 2;\n            for (int j = 1; s[j] <= h[i]; j++) {\n                dp[i][j] = (dp[i-1][0] * (int128_t)2 * calc_sub(s[j-1], s[j]) * pow_mod(2, h[i] - s[j], MOD)) % MOD;\n                //dp[i][j] = ((dp[i-1][0] * 2) % MOD) * ((calc_sub(s[j-1], s[j]) * pow_mod(2, h[i] - s[j], MOD)) % MOD) % MOD;\n            }\n        } else {\n            dp[i][0] = dp[i-1][0] * 2;\n            if (h[i] <= h[i-1]) {\n                for (int j = 1; s[j] <= h[i-1]; j++) {\n                    if (s[j] <= h[i]) {\n                        dp[i][j] = dp[i-1][j];\n                    } else {\n                        dp[i][0] = (dp[i][0] + dp[i-1][j] * 2) % MOD;\n                    }\n                }\n            } else {\n                for (int j = 1; s[j] <= h[i]; j++) {\n                    if (s[j] <= h[i-1]) {\n                        dp[i][j] = (dp[i-1][j] * pow_mod(2, h[i] - h[i-1], MOD)) % MOD;\n                    } else {\n                        dp[i][j] = (dp[i-1][0] * (int128_t)2 * calc_sub(s[j-1], s[j]) * pow_mod(2, h[i] - s[j], MOD)) % MOD;\n                        //dp[i][j] = ((dp[i-1][0] * 2) % MOD) * ((calc_sub(s[j-1], s[j]) * pow_mod(2, h[i] - s[j], MOD)) % MOD) % MOD;\n                    }\n                }\n            }\n        }\n        //std::cout << \"dp:\" << dp[i][0] << \" \" << dp[i][1] << \" \" << dp[i][2] << std::endl;\n    }\n\n    int128_t ret = 0;\n    for (int j = 0; s[j] <= h[N]; j++) {\n        ret = (ret + dp[N][j]) % MOD;\n    }\n    std::cout << ret << std::endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef LOCAL\n#pragma GCC optimize (\"O3\")\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\nenable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return {i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (c it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(x...) \" [\" #x \": \" << (x) << \"] \"\n\nusing ld = long double;\nusing ll = long long;\n\nconstexpr int mod = 1000 * 1000 * 1000 + 7;\nconstexpr int odw2 = (mod + 1) / 2;\n\nvoid OdejmijOd(int& a, int b) { a -= b; if (a < 0) a += mod; }\nint Odejmij(int a, int b) { OdejmijOd(a, b); return a; }\nvoid DodajDo(int& a, int b) { a += b; if (a >= mod) a -= mod; }\nint Dodaj(int a, int b) { DodajDo(a, b); return a; }\nint Mnoz(int a, int b) { return (ll) a * b % mod; }\nvoid MnozDo(int& a, int b) { a = Mnoz(a, b); }\nint Pot(int a, int b) { int res = 1; while (b) { if (b % 2 == 1) MnozDo(res, a); a = Mnoz(a, a); b /= 2; } return res; }\nint Odw(int a) { return Pot(a, mod - 2); }\nvoid PodzielDo(int& a, int b) { MnozDo(a, Odw(b)); }\nint Podziel(int a, int b) { return Mnoz(a, Odw(b)); }\nint Moduluj(ll x) { x %= mod; if (x < 0) x += mod; return x; }\n\ntemplate <typename T> T Maxi(T& a, T b) { return a = max(a, b); }\ntemplate <typename T> T Mini(T& a, T b) { return a = min(a, b); }\n\nconstexpr int nax = 105;\n\nvector<int> hs;\n\nint n, m;\nint pot2[nax];\nint h[nax];\nint myj[nax];\nint dp[nax][nax];\n\nint Popsuj(int hx) {\n  return Odejmij(Pot(2, hx), 1);\n}\n\nint Algos() {\n  debug() << imie(hs) imie(n) imie(m) imie(range(h + 1, h + n + 1));\n  for (int j = 1; j <= m; j++) {\n    for (int i = 1; i <= n; i++) {\n      if (h[i] == hs[j]) {\n        myj[i] = j;\n      }\n    }\n  }\n  for (int j = 1; j <= m; j++) {\n    if (hs[j] < h[1]) {\n      dp[1][j] = Mnoz(Mnoz(2, Pot(2, max(0, h[1] - hs[j + 1]))), Popsuj(hs[j + 1] - hs[j]));\n    } else if (hs[j] == h[1]) {\n      dp[1][j] = 2;\n    } else {\n      dp[1][j] = 0;\n    }\n  }\n  for (int i = 2; i <= n; i++) {\n    for (int j = 1; j <= m; j++) {\n      const int val = dp[i - 1][j];\n      if (!val) continue;\n      debug() << \"dp[\" << i - 1 << \"][\" << j << \"] = \" << val;\n\n      if (h[i] <= hs[j]) {\n        DodajDo(dp[i][myj[i]], Mnoz(val, 2));\n      } else if (h[i] <= h[i - 1]) {\n        DodajDo(dp[i][j], val);\n      } else if (hs[j] < h[i - 1]) {\n        DodajDo(dp[i][j], Mnoz(val, Pot(2, h[i] - h[i - 1])));\n      } else {\n        for (int j2 = j; j2 <= m and hs[j2] <= h[i]; j2++) {\n          debug() << imie(j2);\n          if (hs[j2] < h[i]) {\n            //debug() << imie(Mnoz(Mnoz(2, val), Odejmij(Pot(2, h[i] - hs[j2]), 1)));\n            //DodajDo(dp[i][j2], Mnoz(Mnoz(2, val), Odejmij(Pot(2, h[i] - hs[j2]), 1)));\n            DodajDo(dp[i][j2], Mnoz(Mnoz(Mnoz(2, val), Pot(2, max(0, h[i] - hs[j2 + 1]))), Popsuj(hs[j2 + 1] - hs[j2])));\n          } else {\n            //debug() << imie(Mnoz(val, 2));\n            DodajDo(dp[i][j2], Mnoz(val, 2));\n          }\n        }\n      }\n    }\n  }\n  int wyn = 0;\n  for (int j = 1; j <= m; j++) {\n    const int val = dp[n][j];\n    if (!val) continue;\n    debug() << \"hdp[\" << n << \"][\" << j << \"] = \" << val;\n    DodajDo(wyn, val);\n  }\n  return wyn;\n}\n\nint main() {\n  pot2[0] = 1;\n  for (int i = 1; i < nax; i++) pot2[i] = Mnoz(pot2[i - 1], 2);\n\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cin >> n;\n  for (int i = 1; i <= n; i++) {\n    cin >> h[i];\n    hs.push_back(h[i]);\n  }\n  hs.push_back(0);\n  hs.push_back(1);\n  sort(hs.begin(), hs.end());\n  hs.resize(unique(hs.begin(), hs.end()) - hs.begin());\n  m = (int) hs.size() - 1;\n  cout << Algos() << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define mp make_pair\n#define PI pair<int,int>\n#define poly vector<ll>\n#define For(i,l,r) for(int i=(int)(l);i<=(int)(r);i++)\n#define Rep(i,r,l) for(int i=(int)(r);i>=(int)(l);i--)\n#define pb push_back\n#define fi first\n#define se second\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define getchar gc\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\ninline ull rnd(){\n\treturn ((ull)rand()<<30^rand())<<4|rand()%4;\n}\nconst int B=32000,N=10000005,mod=1e9+7;\nint qq,q[N];\nll F[B+1],G[B+1];\nPI f[N];\nPI operator +(PI a,PI b){\n\treturn mp((ll)a.fi*b.fi%mod,((ll)a.fi*b.se*2+(ll)a.se*b.fi*2+(ll)a.se*b.se+(ll)a.fi*b.fi*2)%mod);\n}\nll pw(int h){\n\treturn F[h%B]*G[h/B]%mod;\n}\nvoid del(PI &x,int h){\n\tx.fi=x.fi*pw(h)%mod;\n}\nint main(){\n\tFor(i,F[0]=1,B)F[i]=F[i-1]*2%mod;\n\tFor(i,G[0]=1,B)G[i]=G[i-1]*F[B]%mod;\n\tint n=read();\n\tFor(i,1,n){\n\t\tint h=read();\n\t\tPI zs=mp(1,0);\n\t\tif(qq&&q[qq]>=h){\n\t\t\twhile(q[qq-1]>=h){\n\t\t\t\tdel(f[qq],q[qq]-q[qq-1]); \n\t\t\t\tf[qq-1]=f[qq-1]+f[qq]; qq--;\n\t\t\t}\n\t\t\tdel(f[qq],q[qq]-h);\n\t\t\tq[qq]=h; f[qq]=f[qq]+zs;\n\t\t}else{\n\t\t\tq[++qq]=h;\n\t\t\tf[qq]=zs;\n\t\t\t\n\t\t}\n\t}\n\tq[0]=1;\n\t//For(i,1,qq)cout<<f[i].fi<<\" \"<<f[i].se<<endl;\n\twhile(qq){\n\t\tdel(f[qq],q[qq]-q[qq-1]); qq--;\n\t\tif(qq)f[qq]=f[qq]+f[qq+1];\n\t}\n\tcout<<((ll)f[1].fi*2+f[1].se)%mod<<endl;\n}\n/*\n3\n1 2 2\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/detail/standard_policies.hpp>\nusing ll = int64_t;\nusing ld = double;\nusing ull = uint64_t;\nusing namespace std;\nusing namespace __gnu_pbds;     \n\nconst int MAXN = 228;\n\nconst ll MOD = 1e9 + 7;\nconst ll REV2 = (MOD + 1) / 2;\n\nusing Vec = vector<ll>;\n\nll p2(ll a) {\n    if (!a) {\n        return 1;\n    }\n\n    ll v = p2(a / 2);\n    v = (v * v) % MOD;\n\n    if (a & 1) {\n        v = (v * 2) % MOD;\n    }\n\n    return v;\n}\n\n\nconst ll INF = (1ll << 60);\n\nll eval(const Vec& a) {\n    assert(a.size());\n\n    ll mn = INF;\n    for (ll x : a) {\n        mn = min(mn, x);\n    }\n\n    ll cn = p2(mn) - 1;\n    Vec na(a);\n    for (ll& x : na) {\n        x -= mn;\n    }\n\n    ll pv = 0;\n    ll p = 0;\n\n    na.push_back(0);\n\n    for (ll x : na) {\n        p += max<ll>(x - pv, 0ll);\n        pv = x;\n    }\n\n    ll ans = p2(p) * cn % MOD;\n    Vec cur;\n    \n    ll ansgood = REV2 * REV2 % MOD;\n\n    for (ll x : na) {\n        if (!x) {\n            ansgood = (ansgood * 2) % MOD;\n            if (!cur.empty()) {\n                ansgood = ansgood * eval(cur) * 2 % MOD;\n                cur.clear();\n            }\n        } else {\n            cur.push_back(x);\n        }\n    }\n    \n    return (ans + ansgood) % MOD;\n}\n\nint main() {\n#ifdef BZ\n    freopen(\"input.txt\", \"r\", stdin); freopen(\"output.txt\", \"w\", stdout);\n#endif\n    ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); cout.setf(ios::fixed); cout.precision(20);\n    int n;\n    cin >> n;\n    Vec a(n);\n    for (ll& x : a) {\n        cin >> x;\n        --x;\n    }\n\n    ll ans = eval(a);\n    cout << (ans * 2) % MOD << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "//Wrong answer on test inf.\n#include<bits/stdc++.h>\n#define rep(i,x,y) for (int i=(x);i<=(y);i++)\n#define ll long long\n#define inf 1000000001\n#define y1 y1___\n#define pii pair<int,int>\n#define fi first\n#define se second\nusing namespace std;\nchar gc(){\n\tstatic char buf[100000],*p1=buf,*p2=buf;\n\treturn p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\nll read(){\n\tchar ch=gc();ll x=0;int op=1;\n\tfor (;!isdigit(ch);ch=gc()) if (ch=='-') op=-1;\n\tfor (;isdigit(ch);ch=gc()) x=(x<<1)+(x<<3)+ch-'0';\n\treturn x*op;\n}\n#define N 105\n#define mod 1000000007\nint ksm(int x,int p){\n\tint ret=1;\n\tfor (;p;p>>=1,x=(ll)x*x%mod) if (p&1) ret=(ll)ret*x%mod;\n\treturn ret;\n}\nint n,h[N];\npii solve(int l,int r,int lim){//区间[l,r]比lim高的部分的方案数\n\tint mi=inf,cnt=0;pii ret;//first：存在相邻格子颜色相同情况的方案数；second：不存在的方案数（固定第一个格子的颜色）\n\trep (i,l,r) if (h[i]<mi) mi=h[i],cnt=1;else if (h[i]==mi) cnt++;\n\tif (cnt==r-l+1){//矩形\n\t\tret.fi=(ksm(2,r-l+1)+mod-2)%mod;\n\t\tret.se=ksm(2,mi-lim-1);\n\t\treturn ret;\n\t}\n\tint rest=r-l+1,s0=1,s1=1,last=0;//rest：上方没有方格的列数；s0,s1：维护上方有方格的列，当前行存在/不存在的方案数\n\trep (i,l,r+1)\n\t\tif (!last&&h[i]>mi) last=i;\n\t\telse if (last&&(h[i]<=mi||i>r)){\n\t\t\trest-=i-last;\n\t\t\tpii tmp=solve(last,i-1,mi);//子问题，递归求解\n\t\t\ts0=(ll)s0*(tmp.fi+4ll*tmp.se%mod)%mod;//*4是因为上一行可以取反，当前行亦然，2*2\n\t\t\ts1=(ll)s1*(2ll*tmp.se%mod)%mod;\n\t\t\tlast=0;\n\t\t}\n\ts0=(s0+mod-s1)%mod;\n\tret.fi=(ll)s0*ksm(2,rest)%mod;//如果上方方格已经存在，剩下的列随意\n\tret.fi=(ret.fi+(ll)s1*(ksm(2,rest)+mod-2)%mod)%mod;//否则需要去掉两种不合法的情况\n\tret.se=(ll)s1*ksm(2,mi-lim-1)%mod;//固定第一个格子（第一行）颜色\n\treturn ret;\n}\nint main(){\n\tn=read();rep (i,1,n) h[i]=read();\n\tif (n==1){//注意特判\n\t\tprintf(\"%d\\n\",ksm(2,h[1]));\n\t\texit(0);\n\t}\n\tint ex=1;\n\trep (i,1,n) if (h[i]>h[i-1]&&h[i]>h[i+1]){\n\t\tex=(ll)ex*ksm(2,h[i]-max(h[i-1],h[i+1]))%mod;\n\t\th[i]=max(h[i-1],h[i+1]);\n\t}\n\tpii ans=solve(1,n,0);\n\tprintf(\"%d\",(ll)ex*(ans.fi+2ll*ans.se%mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int MOD = 1e9 + 7;\n\nint n,m,h[101],hnum[101],dh[101];\nLL dp[101][101];\n\nint pow_(int x,int y) {///快速幂求 x的y次方\n    int ans = 1;\n    if(y > 0) {\n        while(y) {\n            if(y % 2)ans = (LL)ans * x % MOD;\n            x = (LL)x * x % MOD;\n            y /= 2;\n        }\n    }\n    return ans;\n}\n\nint main() {\n    scanf(\"%d\",&n);\n    for(int i = 1;i <= n;i ++) {\n        scanf(\"%d\",&h[i]);\n        dh[++ m] = h[i];\n    }\n    sort(dh + 1,dh + m + 1);///高度排序\n    m = unique(dh + 1,dh + m + 1) - dh - 1;///离散化 m是离散化后的长度\n    for(int i = 1;i <= n;i ++) {\n        hnum[i] = lower_bound(dh + 1,dh + m + 1,hnum[i]) - dh;\n    }\n    dp[0][0]=1;\n    for(int i = 1;i <= n;i ++) {\n        for(int j = hnum[i] + 1;j <= hnum[i - 1];j ++)\n            (dp[i][0] += dp[i - 1][j] * 2 % MOD) %= MOD;\n\n        (dp[i][0] += dp[i - 1][0] * 2 % MOD) %= MOD;///交叉或者不交叉\n\n        int d = pow_(2,dh[hnum[i]] - dh[hnum[i-1]]);\n        for(int j = 1;j <= min(hnum[i - 1],hnum[i]);j ++) {\n            dp[i][j] = dp[i - 1][j] * d % MOD;\n        }\n        for(int j = hnum[i - 1] + 1;j <= hnum[i];j ++) {///比前一列高出的部分\n            if(j > 1)(dp[i][j] += dp[i - 1][0] * (pow_(2,dh[j] - dh[j - 1]) - 1) % MOD * 2 % MOD * pow_(2,dh[hnum[i]] - dh[j]) % MOD) %= MOD;\n            else (dp[i][1] += dp[i - 1][0] * (pow_(2,dh[1]) - 2) % MOD * pow_(2,dh[hnum[i]] - dh[1]) % MOD) %= MOD;///上一列中无重复相同的乘上化不超过上一列高度中有重复的\n        }\n        printf(\"%d\\n\",dp[i][0]);\n    }\n    LL ans = 0;\n    for(int i = 0;i <= hnum[n];i++)\n        (ans += dp[n][i]) %= MOD;\n    printf(\"%lld\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nlong long N, H[100009], dp[109][109], mod = 1000000007; vector<pair<int, int>>vec[100009];\n\nlong long modpow(long long a, long long b, long long m) {\n\tlong long p = 1, q = a;\n\tfor (int i = 0; i < 63; i++) {\n\t\tif ((b / (1LL << i)) % 2 == 1) { p *= q; p %= m; }\n\t\tq *= q; q %= m;\n\t}\n\treturn p;\n}\n\nint main() {\n\tcin >> N;\n\tfor (int i = 1; i <= N; i++) cin >> H[i];\n\tH[0] = 1; H[N + 1] = 1;\n\tfor (int i = 1; i <= N; i++) {\n\t\tlong long minx = (1LL << 60);\n\t\tfor (int j = i; j <= N; j++) {\n\t\t\tminx = min(minx, H[j]);\n\t\t\tif (H[i - 1] < minx && minx > H[j + 1]) vec[j].push_back(make_pair(i, minx - max(H[i - 1], H[j + 1])));\n\t\t}\n\t}\n\tdp[0][1] = 1;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 1; j <= N; j++) {\n\t\t\tlong long K = 0; for (int k = 0; k < vec[i + 1].size(); k++) { if (vec[i + 1][k].first >= j) K += vec[i + 1][k].second; }\n\t\t\tlong long L = modpow(2, K, mod);\n\t\t\tdp[i + 1][j] += dp[i][j] * L; dp[i + 1][j] %= mod;\n\t\t\tlong long K1 = 0; for (int k = 0; k < vec[i + 1].size(); k++) { if (vec[i + 1][k].first >= i + 1) { K1 += vec[i + 1][k].second; } }\n\t\t\tlong long L1 = modpow(2, K1, mod);\n\t\t\tdp[i + 1][i + 1] += dp[i][j] * L1; dp[i + 1][j + 1] %= mod;\n\t\t}\n\t}\n\tlong long sum = 0;\n\tfor (int i = 1; i <= N; i++) sum += dp[N][i];\n\tcout << sum%mod << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "        #include <bits/stdc++.h>\n        using namespace std;\n   #define int long long\n   #define PP pair<int,pair<int,int>>\nconst int MAX = 510000;\nconst int MOD =  1000000007;\nint modpow(int a, int n, int mod) {\n    int res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\n     signed main(){\n     int n;\n     cin>>n;\n     int h[n+1]={};\n     for(int i=0;i<n;i++)cin>>h[i];\n     int dp[n][n+1];\n     dp[0][n]=modpow(2,h[0],MOD);\n     for(int i=0;i<n;i++){\n       if(h[i]<=h[0]){\n         dp[0][i]=modpow(2,h[0]-h[i]+1,MOD);\n       }else dp[0][i]=0;\n     }\n     for(int i=1;i<n;i++){\n       if(h[i]>h[i-1]){\n         for(int j=0;j<=n;j++){\n           if(h[i]>=h[j]){\n             if(h[j]>h[i-1]){\n               dp[i][j]=(dp[i-1][i-1]*modpow(2,h[i]-h[j],MOD)%MOD)*2%MOD;\n             }else dp[i][j]=(dp[i-1][j]*modpow(2,h[i]-h[i-1],MOD)%MOD+dp[i-1][i-1]*modpow(2,h[i]-h[i-1],MOD)%MOD)%MOD;\n           }else dp[i][j]=0;\n         }\n       }else{\n         for(int j=0;j<=n;j++){\n           if(h[i]>=h[j]){\n             dp[i][j]=(dp[i-1][j]+dp[i-1][i])%MOD;\n           }else dp[i][j]=0;\n         }\n       }\n     }\n     cout<<dp[n-1][n]<<endl;\n                  \n}\n\n\n        \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define all(x) (x).begin(), (x).end()\n#define itn int\n#define make_unique(x) sort((x).begin(), (x).end()); (x).erase(unique((x).begin(), (x).end()), (x).end())\n\nusing namespace std;\n\ninline int nxt() {\n\tint x;\n\tscanf(\"%d\", &x);\n\treturn x;\n}\n\nconst int mod = 1000000007;\nlong long pw(long long a, long long b) {\n\tlong long res = 1;\n\twhile (b) {\n\t\tif (b & 1ll) {\n\t\t\tres = res * a % mod;\n\t\t}\n\t\tb >>= 1;\n\t\ta = a * a % mod;\n\t}\n\treturn res;\n}\n\nconst int N = 111;\nlong long dp[N][N];\n\nlong long paintPidorski(int x) {\n\treturn (pw(2, x) - 1 + mod) % mod;\n}\n\nlong long getAnswer(vector<int> a) {\n\tint n = a.size();\n\n\tif (n == 1) {\n\t\treturn pw(2, a[0]);\n\t}\n\tauto b = a;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint x = 0;\n\t\tif (i < n - 1) {\n\t\t\tx = max(x, a[i + 1]);\n\t\t}\n\t\tif (i) {\n\t\t\tx = max(x, a[i - 1]);\n\t\t}\n\t\tb[i] = min(a[i], x);\n\t}\n\tlong long ans = 1;\n\tfor (int i = 0; i < n; ++i) {\n\t\tans = ans * pw(2, a[i] - b[i]) % mod;\n\t\ta[i] = b[i];\n\t}\n\n\tmake_unique(b);\n\tb.insert(b.begin(), 0);\n\tfor (int& x : a) {\n\t\tx = lower_bound(all(b), x) - b.begin();\n\t}\n\n\t// for (int x : b) {\n\t// \tcerr << x << \" \";\n\t// }\n\t// cerr << \"\\n\";\n\n\tmemset(dp, 0, sizeof(dp));\n\n\tfor (int i = 0; i < a[0]; ++i) {\n\t\tdp[0][i] = pw(2, b[a[0]] - b[i]);\n\t}\n\tdp[0][a[0]] = 1;\n\tfor (int i = 0; i < a[0]; ++i) {\n\t\tdp[0][i] -= dp[0][i + 1];\n\t}\n\t// for (int i = a[0]; i > 0; --i) {\n\t// \tdp[0][i] -= dp[0][i - 1];\n\t// }\n\tfor (int i = 0; i <= n; ++i) {\n\t\tdp[0][i] = (dp[0][i] % mod + mod) % mod;\n\t}\n\n\tfor (int i = 1; i < n; ++i) {\n\t\tfor (int j = 0; j <= a[i - 1]; ++j) {\n\t\t\tif (j < a[i - 1] && j < a[i]) {\n\t\t\t\tdp[i][j] += dp[i - 1][j] * pw(2, b[a[i]] - b[min(a[i], a[i - 1])]) % mod;\n\t\t\t\t// cerr << i << \" \" << j << \" \" << dp[i][j] << \" --\\n\";\n\t\t\t} else if (j < a[i - 1]) {\n\t\t\t\tdp[i][a[i]] += 2 * dp[i - 1][j];\n\t\t\t} else if (j < a[i]) {\n\t\t\t\t// dp[i][a[i]] += 2 * dp[i - 1][j];\n\t\t\t\t// for (int t = j; t < a[i]; ++t) {\n\t\t\t\t// \tdp[i][t] += 2 * dp[i - 1][j] * paintPidorski(b[a[i]] - b[t]) % mod;\n\t\t\t\t// }\n\t\t\t\tvector<long long> qw(a[i] + 1);\n\t\t\t\tfor (int t = j; t <= a[i]; ++t) {\n\t\t\t\t\tqw[t] = pw(2, b[a[i]] - b[t]);\n\t\t\t\t}\n\t\t\t\t// qw[a[i]] = 2;\n\t\t\t\t// for (auto x : qw) {\n\t\t\t\t// \tcerr << x << \" \";\n\t\t\t\t// }\n\t\t\t\t// cerr << \"--\\n\";\n\t\t\t\tfor (int t = j; t < a[i]; ++t) {\n\t\t\t\t\tqw[t] -= qw[t + 1];\n\t\t\t\t\tqw[t] = (qw[t] % mod + mod) % mod;\n\t\t\t\t}\n\t\t\t\tfor (int t = j; t <= a[i]; ++t) {\n\t\t\t\t\tdp[i][t] += qw[t] * 2 * dp[i - 1][j] % mod;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdp[i][a[i]] += 2 * dp[i - 1][j];\n\t\t\t}\n\t\t}\n\n\t\tfor (int j = 0; j <= a[i]; ++j) {\n\t\t\tdp[i][j] %= mod;\n\t\t}\n\t}\n\n\t// for (int i = 0; i < n; ++i) {\n\t// \tcerr << a[i] << \" \";\n\t// }\n\t// cerr << \"\\n\";\n\t// for (int i = 0; i < n; ++i) {\n\t// \tcerr << b[a[i]] << \" \";\n\t// }\n\t// cerr << \"\\n\\n\";\n\t// for (int i = 0; i < n; ++i) {\n\t// \tfor (int j = 0; j <= a[i]; ++j) {\n\t// \t\tcerr << dp[i][j] << \" \";\n\t// \t}\n\t// \tcerr << \"\\n\";\n\t// }\n\t// cerr << \"\\n\";\n\n\tlong long tmp = 0;\n\tfor (int i = 0; i <= a[n - 1]; ++i) {\n\t\ttmp += dp[n - 1][i];\n\t}\n\ttmp %= mod;\n\treturn ans * tmp % mod;\n}\n\nint main() {\n\tint n = nxt();\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\ta[i] = nxt();\n\t}\n\n\tlong long ans = 1;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (a[i] == 1) {\n\t\t\tans = ans * 2 % mod;\n\t\t} else {\n\t\t\tint j = i;\n\t\t\twhile (j < n && a[j] > 1) {\n\t\t\t\t++j;\n\t\t\t}\n\t\t\tans = ans * getAnswer(vector<int>(a.begin() + i, a.begin() + j)) % mod;\n\t\t\ti = j - 1;\n\t\t}\n\t}\n\n\tcout << ans << \"\\n\";\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\nconst int64 mod = 1e9+7;\n\nint64 mpow(int64 a, int64 b){\n\tif(b == 0) return 1;\n\tif(b%2) return a*mpow(a, b-1)%mod;\n\tint64 ret = mpow(a, b/2);\n\treturn ret*ret%mod;\n}\n\nvector<int64> h;\nint32 N;\n\nint64 solve(int32 l, int32 r){\n\tint64 dp[110][110] = {};\n\tdp[l][l-1] = 2;\n\tdp[l][l] = (mpow(2, h[l])+mod-2)%mod;\n\n\tFOR(i, l, r-1){\n\t\tFOR(j, l-1, i+1){\n\t\t\tif(h[i] > h[i+1]){\n\t\t\t\tif(h[j] == 0){\n\t\t\t\t\tdp[i+1][j] = (dp[i+1][j]+dp[i][j]*2)%mod;\n\t\t\t\t}else if(h[j] > h[i+1]){\n\t\t\t\t\tint64 rest = dp[i][j]*mpow(2, h[j]-h[i+1]+1)*mpow((mpow(2, h[j]-h[j-1])+mod-1)%mod, mod-2);\n\t\t\t\t\tint64 out = dp[i][j]*(mpow(2, h[j])-mpow(2,h[j]-h[i+1]+1)+mod)%mod*mpow((mpow(2, h[j]-h[j-1])+mod-1)%mod, mod-2);\n\t\t\t\t\tdp[i+1][i+1] = (dp[i+1][j]+rest)%mod;\n\t\t\t\t\tdp[i+1][l-1] = (dp[i+1][j]+out*2)%mod;\n\t\t\t\t}else{\n\t\t\t\t\tdp[i+1][j] = (dp[i+1][j]+dp[i][j])%mod;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(h[j] == 0){\n\t\t\t\t\tdp[i+1][i+1] = (dp[i+1][i+1]+dp[i][j]*(mpow(2, h[i+1]-h[i]+1)+mod-2)%mod)%mod;\n\t\t\t\t\tdp[i+1][j] = (dp[i+1][j]+dp[i][j]*2)%mod;\n\t\t\t\t}else{\n\t\t\t\t\tdp[i+1][j] = (dp[i+1][j]+dp[i][j]*mpow(2, h[i+1]-h[i])%mod)%mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint64 res = 0;\n\tFOR(j, l-1, r+1)\n\t\tres += dp[r-1][j];\n\treturn res;\n}\n\nint main(void){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcin >> N;\n\th = vector<int64>(N+2, 0);\n\tREP(i, N) cin >> h[i+1];\n\n\tint64 free_ = 0;\n\tint64 l = 1;\n\tint64 res = 1;\n\tREP(i, N){\n\t\tif(h[i+1] > h[i] && h[i+1] > h[i+2]){\n\t\t\tfree_ += h[i+1]-max(h[i], h[i+2]);\n\t\t\th[i+1] = max(h[i], h[i+2]);\n\t\t}\n\t\tif(h[i+1] == 1){\n\t\t\tfree_++;\n\t\t\th[i+1] = 0;\n\t\t\tif(h[l] != 0)\n\t\t\t\tres = res*solve(l, i+1)%mod;\n\t\t\tl = i+2;\n\t\t}\n\t}\n\tif(h[l] != 0)\n\t\tres = res*solve(l, N+1)%mod;\n\tres = res*mpow(2, free_)%mod;\n\t\n\tcout << res << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#define maxn 105\n#define R register\n#define INF 0x3f3f3f3f\nusing namespace std;\ntypedef long long lxl;\nconst lxl mod = 1e9+7;\n\ninline lxl read()\n{\n\tlxl x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9') {if(ch=='-') f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9') {x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\ninline lxl fmi(lxl a,lxl b)\n{\n\tlxl ans=1;\n\twhile(b>0)\n\t{\n\t\tif(b&1) ans=(ans*a)%mod;\n\t\ta=(a*a)%mod;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\n\nlxl n,h[maxn],H[maxn],W[maxn],X[maxn],Rm[maxn],tot;\nint d[maxn][20],lg[maxn];\nstd::vector<int> ch[maxn];\n\ninline void init()\n{\n\tlg[0]=-1;\n\tfor(R int i=1;i<=n;++i)\n\t\tlg[i]=lg[i>>1]+1;\n\tfor(R int i=1;i<=n;++i)\n\t\td[i][0]=h[i];\n\tfor(R int j=1;j<=15;++j)\n\t\tfor(R int i=1;i+(1<<(j-1))<=n;++i)\n\t\t\td[i][j]=min(d[i][j-1],d[i+(1<<(j-1))][j-1]);\n}\n\ninline int query(int l,int r)\n{\n\tint k=lg[r-l+1];\n\treturn min(d[l][k],d[r-(1<<k)+1][k]);\n}\n\ninline int build(int l,int r,int fa)\n{\n\tif(l>r) return 0;\n\tint p=++tot;\n\tint x=X[p]=query(l,r);\n\tH[p]=X[p]-X[fa];\n\tW[p]=r-l+1;\n\tint tl=l-1,tr=l-1;\n\tfor(R int i=l;i<=r;++i)\n\t{\n\t\tif(h[i]==x&&tl<tr)\n\t\t\tch[p].push_back(build(tl+1,tr,p));\n\t\tif(h[i]==x) tl=i,++Rm[p];\n\t\telse tr=i;\n\t}\n\tif(tl<tr) ch[p].push_back(build(tl+1,tr,p));\n\treturn p;\n}\n\nlxl f[maxn][2];\n\ninline void dp(int u)\n{\n\t//f[u][0] stands for u 10101010 \n\t// f[u][1] u \\out S\n\tlxl res1=1,res2=1;\n\tfor (std::vector<int>::iterator it = ch[u].begin(); it != ch[u].end(); ++it)\n\t{\n\t\tdp(*it);\n\t\tres1=(res1*f[*it][0])%mod;\n\t\tres2=(res2*((f[*it][0]*2%mod+f[*it][1])%mod))%mod;\n\t}\n\tf[u][0]=(fmi(2,H[u])*res1)%mod;\n\tf[u][1]=(fmi(2,Rm[u])*res2+(mod-2*res1%mod)%mod)%mod;\n}\n\nint main()\n{\n\tn=read();\n\tfor(R int i=1;i<=n;++i)\n\t\th[i]=read();\n\tinit();\n\tint rt=build(1,n,0);\n\tdp(rt);\n\tprintf(\"%lld\",(f[rt][1]+2ll * f[rt][0] % mod)%mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N = 105;\nconst int MOD = 1000000007;\n\nint n,dp[N][N],h[N],w[N],m;\n\nint pow_(int x,int y) {///快速幂求 x的y次方\n    int ans = 1;\n    if(y > 0) {\n        while(y) {\n            if(y % 2)ans = (LL)ans * x % MOD;\n            x = (LL)x * x % MOD;\n            y /= 2;\n        }\n    }\n    return ans;\n}\n\nint main() {\n    scanf(\"%d\",&n);\n    for(int i = 1;i <= n;i ++) {\n        scanf(\"%d\",&h[i]);\n        w[++ m] = h[i];\n    }\n    sort(w + 1,w + m + 1);///高度排序\n    m = unique(w + 1,w + m + 1) - w - 1;///离散化 m是离散化后的长度\n    for(int i = 1;i <= n;i ++) {\n        h[i] = lower_bound(w + 1,w + m + 1,h[i]) - w;\n    }\n    dp[0][0]=1;\n    for(int i = 1;i <= n;i ++) {\n        for(int j = h[i] + 1;j <= h[i - 1];j ++)\n            (dp[i][0] += dp[i - 1][j] * 2 % MOD) %= MOD;\n        (dp[i][0] += dp[i - 1][0] * 2 % MOD) %= MOD;///交叉或者不交叉\n        for(int j = 1;j <= h[i];j ++) {\n            dp[i][j]=(LL)dp[i - 1][j] * pow_(2,w[h[i]] - w[h[i-1]]) % MOD;\n            if(h[i - 1] >= j)continue;///如果是高度不超过前一列的位置 量已经确定了\n            if(j > 1)(dp[i][j] += (LL)dp[i - 1][0] * (pow_(2,w[j] - w[j - 1])) % MOD % MOD * pow_(2,w[h[i]] - w[j]) % MOD) %= MOD;\n            else (dp[i][1] += (LL)dp[i - 1][0] * (pow_(2,w[1]) - 2) % MOD * pow_(2,w[h[i]] - w[1]) % MOD) %= MOD;///上一列中无重复的乘上化不超过上一列高度中有重复的\n        }\n    }\n    int ans = 0;\n    for(int i = 0;i <= m;i++)\n        (ans += dp[n][i]) %= MOD;\n    printf(\"%d\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int mod = 1000000007;\ntypedef long long LL;\nvoid reduce(int & x) { x += x >> 31 & mod; }\nint mul(int a, int b) { return (LL) a * b % mod; }\nint pow(int a, int b, int res = 1) {\n\tfor (; b; b >>= 1, a = mul(a, a)) if (b & 1) res = mul(res, a);\n\treturn res;\n}\nconst int MAXN = 110;\nint A[MAXN], n, li[MAXN], bak;\nint dp[MAXN][MAXN];\nint main() {\n\tstd::ios_base::sync_with_stdio(false), std::cin.tie(0);\n\tstd::cin >> n;\n\tfor (int i = 1; i <= n; ++i) std::cin >> A[i], li[++bak] = A[i];\n\tli[++bak] = 1; std::sort(li + 1, li + 1 + bak);\n\tbak = std::unique(li + 1, li + 1 + bak) - li - 1;\n\tli[bak + 1] = 0x3f3f3f3f;\n\tfor (int i = 1; i <= n; ++i)\n\t\tA[i] = std::lower_bound(li + 1, li + 1 + bak, A[i]) - li;\n\tdp[0][0] = 1;\n\tconst int inv2 = mod + 1 >> 1;\n\tauto calc = [] (int l, int r, int H) {\n\t\tr = std::min(r, H - 1);\n\t\treturn pow(2, H, (pow(inv2, l) - pow(inv2, r + 1) + mod) % mod);\n\t} ;\n\tfor (int i = 1; i < A[1]; ++i) {\n\t\tdp[1][i] = pow(2, li[A[1]] - li[i]) - pow(2, li[A[1]] - li[i + 1]);\n\t\treduce(dp[1][i]);\n\t\tdp[1][i] = mul(dp[1][i], 2);\n\t}\n\tdp[1][A[1]] = 2;\n\tfor (int i = 2; i <= n; ++i) {\n\t\tif (A[i] >= A[i - 1]) {\n\t\t\tint delta = li[A[i]] - li[A[i - 1]];\n\t\t\tfor (int j = 1; j < A[i - 1]; ++j) {\n\t\t\t\treduce(dp[i][j] += pow(2, delta, dp[i - 1][j]) - mod);\n\t\t\t}\n\t\t\tfor (int j = A[i - 1]; j <= A[i]; ++j) {\n\t\t\t\tint t = calc(li[j], li[j + 1] - 1, li[A[i]]) + (j == A[i]);\n\t\t\t\tt = mul(t, 2);\n\t\t\t\treduce(dp[i][j] += mul(t, dp[i - 1][A[i - 1]]) - mod);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (int j = 1; j <= A[i - 1]; ++j)\n\t\t\t\treduce(dp[i][std::min(j, A[i])] += mul(dp[i - 1][j], 1 + (j >= A[i])) - mod);\n\t\t}\n\t}\n\tstd::cout << std::accumulate(dp[n], dp[n + 1], 0ll) % mod << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <limits>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <iterator>\n#include <bitset>\n#include <unordered_map>\n#include <unordered_set>\n\nusing namespace std;\n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)c.size())\n#define ten(n) ((int)1e##n)\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing Pll = pair<ll, ll>;\n\ntemplate<typename ...> static inline int getchar_unlocked(void) { return getchar(); }\ntemplate<typename ...> static inline void putchar_unlocked(int c) { putchar(c); }\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\nvoid reader(int& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nvoid reader(ll& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nint reader(char c[]) { int i, s = 0; for (;;) { mygc(i); if (i != ' '&&i != '\\n'&&i != '\\r'&&i != '\\t'&&i != EOF) break; }c[s++] = i; for (;;) { mygc(i); if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break; c[s++] = i; }c[s] = '\\0'; return s; }\nint reader(string& c) { int i; for (;;) { mygc(i); if (i != ' '&&i != '\\n'&&i != '\\r'&&i != '\\t'&&i != EOF) break; }c.push_back(i); for (;;) { mygc(i); if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break; c.push_back(i); }; return sz(c); }\ntemplate <class T, class S> void reader(T& x, S& y) { reader(x); reader(y); }\ntemplate <class T, class S, class U> void reader(T& x, S& y, U& z) { reader(x); reader(y); reader(z); }\ntemplate <class T, class S, class U, class V> void reader(T& x, S& y, U& z, V & w) { reader(x); reader(y); reader(z); reader(w); }\nvoid writer(int x, char c) { int s = 0, m = 0; char f[10]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(ll x, char c) { int s = 0, m = 0; char f[20]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(const char c[]) { int i; for (i = 0; c[i] != '\\0'; i++)mypc(c[i]); }\nvoid writer(const string& x, char c) { int i; for (i = 0; x[i] != '\\0'; i++)mypc(x[i]); mypc(c); }\nvoid writer(const char x[], char c) { int i; for (i = 0; x[i] != '\\0'; i++)mypc(x[i]); mypc(c); }\ntemplate<class T> void writerLn(T x) { writer(x, '\\n'); }\ntemplate<class T, class S> void writerLn(T x, S y) { writer(x, ' '); writer(y, '\\n'); }\ntemplate<class T, class S, class U> void writerLn(T x, S y, U z) { writer(x, ' '); writer(y, ' '); writer(z, '\\n'); }\ntemplate<class T, class S, class U, class V> void writerLn(T x, S y, U z, V v) { writer(x, ' '); writer(y, ' '); writer(z, ' '); writer(v, '\\n'); }\ntemplate<class T> void writerArr(T x[], int n) { if (!n) { mypc('\\n'); return; }FOR(i, n - 1)writer(x[i], ' '); writer(x[n - 1], '\\n'); }\ntemplate<class T> void writerArr(vector<T>& x) { writerArr(x.data(), (int)x.size()); }\n\ntemplate<class T> void chmin(T& a, const T& b) { if (a > b) a = b; }\ntemplate<class T> void chmax(T& a, const T& b) { if (a < b) a = b; }\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\ntemplate<class T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\nll mod_pow(ll a, ll n, ll mod) {\n\tll ret = 1;\n\tll p = a % mod;\n\twhile (n) {\n\t\tif (n & 1) ret = ret * p % mod;\n\t\tp = p * p % mod;\n\t\tn >>= 1;\n\t}\n\treturn ret;\n}\ntemplate<class T> T extgcd(T a, T b, T& x, T& y) { for (T u = y = 1, v = x = 0; a;) { T q = b / a; swap(x -= q * u, u); swap(y -= q * v, v); swap(b -= q * a, a); } return b; }\nll mod_inv(ll a, ll m) { ll x, y; extgcd<ll>(a, m, x, y); return (m + x % m) % m; }\n\nconst int MOD = ten(9) + 7;\n\nint hs[100];\n\nclass UnionFind {\nprivate:\n\tint n;\n\tvector<int> a;\npublic:\n\tUnionFind(int n) : n(n), a(n, -1) {}\n\tint find(int x) { return a[x] < 0 ? x : (a[x] = find(a[x])); }\n\tbool same(int x, int y) { return find(x) == find(y); }\n\tbool same(Pii& p) { return same(p.first, p.second); }\n\tbool unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y) return false;\n\t\tif (a[x] > a[y]) swap(x, y);\n\t\ta[x] += a[y];\n\t\ta[y] = x;\n\t\tn--;\n\t\treturn true;\n\t}\n\tbool unite(Pii& p) { return unite(p.first, p.second); }\n\tint size() const { return n; }\n\tint size(int x) { return -a[find(x)]; }\n};\n\nstruct P {\n\tll normal, color;\n\tint lastModified;\n\tP() {\n\t\tnormal = color = 0;\n\t\tlastModified = 0;\n\t}\n\n\tP(int h) {\n\t\tnormal = 0;\n\t\tcolor = 2;\n\t\tlastModified = h;\n\t}\n\n\tvoid update(int nh) {\n\t\tint hDiff = lastModified - nh;\n\t\t(color *= mod_pow(2, hDiff, MOD)) %= MOD;\n\t\tlastModified = nh;\n\t}\n};\n\nP combine(P& l, P& r, int nh) {\n\tl.update(nh);\n\tr.update(nh);\n\n\tP ret(nh);\n\tret.normal = l.normal * r.normal + l.color * r.normal + l.normal * r.color;\n\tret.normal %= MOD;\n\tret.color = l.color * r.color % MOD * (MOD + 1) / 2 % MOD;\n\tret.normal += ret.color;\n\tret.normal %= MOD;\n\n\treturn ret;\n}\n\nint main() {\n\tint n; reader(n);\n\tvector<Pii> vp;\n\tFOR(i, n) {\n\t\tint h; reader(h);\n\t\tvp.emplace_back(h, i);\n\t}\n\tsort(vp.rbegin(), vp.rend());\n\n\tvector<int> used(n);\n\tmap<Pii, P> mp;\n\tfor (auto& kv : vp) {\n\t\tP nw(kv.first);\n\t\tint id = kv.second;\n\t\tPii range(id, id + 1);\n\t\tif (sz(mp) != 0) {\n\t\t\tauto it = mp.lower_bound(range);\n\t\t\tif (it != mp.end()) {\n\t\t\t\tif (it->first.first == id + 1) {\n\t\t\t\t\tauto pp = it->second;\n\t\t\t\t\trange.second = it->first.second;\n\t\t\t\t\tP nnw = combine(nw, pp, kv.first);\n\t\t\t\t\tnw = nnw;\n\t\t\t\t\tmp.erase(it);\n\t\t\t\t}\n\t\t\t}\n\t\t\tauto it2 = mp.lower_bound(range);\n\t\t\tif (it2 != mp.begin()) {\n\t\t\t\t--it2;\n\t\t\t\tif (it2->first.second == id) {\n\t\t\t\t\tauto pp = it2->second;\n\t\t\t\t\trange.first = it2->first.first;\n\t\t\t\t\tP nnw = combine(nw, pp, kv.first);\n\t\t\t\t\tnw = nnw;\n\t\t\t\t\tmp.erase(it2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmp[range] = nw;\n\t}\n\n\tP ap = mp.begin()->second;\n\tap.update(1);\n\tll ans = ap.normal + ap.color;\n\tans %= MOD;\n\twriterLn(ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct state {\n\tint h;\n\tint w;\n\tlong long ans1 = 2;\n\tlong long ans2 = 0;\n\t\n\tstate() {}\n\tstate(int h, int w) : h(h), w(w) {}\n};\n\nint n, m = 1000000007;\nint h[100];\n\nlong long powmod(long long x, long long y) {\n\tlong long ans = 1;\n\t\n\twhile (y > 0) {\n\t\tif (y & 1) ans = ans * x % m;\n\t\tx = x * x % m;\n\t\ty >>= 1;\n\t}\n\t\n\treturn ans;\n}\n\nlong long mod_inverse(long long a, long long m) {\n    long long b = m, x = 1, y = 0;\n    \n    while (b) {\n        long long t = a / b;\n        \n        a -= t * b;\n        x -= t * y;\n        \n        swap(a, b);\n        swap(x, y);\n    }\n    \n    return (m + x % m) % m;\n}\n\nlong long solve() {\n\tint i, j;\n\tlong long ans = 1;\n\tvector <state> v;\n\t\n\tv.push_back(state(0, 1));\n\t\n\tfor (i = 0; i < n; i++) {\n\t\tv.push_back(state(h[i], 1));\n\t}\n\t\n\tv.push_back(state(0, 1));\n\t\n\twhile (v.size() > 3) {\n\t\tint x = 0;\n\t\t\n\t\tfor (i = 0; i < v.size(); i++) {\n\t\t\tif (v[i].h > v[x].h) x = i;\n\t\t}\n\t\t\n\t\tif (v[x].h == v[x + 1].h) {\n\t\t\tlong long tmp1, tmp2;\n\t\t\t\n\t\t\ttmp1 = v[x].ans1 * v[x + 1].ans1 % m * mod_inverse(2, m) % m;\n\t\t\ttmp2 = ((v[x].ans1 + v[x].ans2) * (v[x + 1].ans1 + v[x + 1].ans2) - tmp1 + m) % m;\n\t\t\t\n\t\t\tv[x].ans1 = tmp1;\n\t\t\tv[x].ans2 = tmp2;\n\t\t\tv[x].w += v[x + 1].w;\n\t\t\tv.erase(v.begin() + x + 1);\n\t\t} else {\n\t\t\tint h = v[x].h - max(v[x - 1].h, v[x + 1].h);\n\t\t\t\n\t\t\tif (v[x].w == 1) {\n\t\t\t\tans = ans * powmod(2, h) % m;\n\t\t\t} else {\n\t\t\t\tv[x].ans1 = v[x].ans1 * powmod(2, h) % m;\n\t\t\t}\n\t\t\t\n\t\t\tv[x].h -= h;\n\t\t}\n\t}\n\t\n\treturn ans * (v[1].ans1 * powmod(2, v[1].h - 1) % m + v[1].ans2) % m;\n}\n\nint main() {\n\tint i;\n\t\n\tscanf(\"%d\", &n);\n\t\n\tfor (i = 0; i < n; i++) scanf(\"%d\", &h[i]);\n\t\n\tprintf(\"%lld\\n\", solve());\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef LOCAL\n#pragma GCC optimize(\"O3\")\n#endif\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\ntypedef long long ll;\n\nconst int mod = 1e9 + 7;\n\nint mul(int a, int b) {\n\treturn (ll) a * b % mod;\n}\nint my_pow(int a, int b) {\n\tint r = 1;\n\twhile(b) {\n\t\tif(b % 2) r = mul(r, a);\n\t\ta = mul(a, a);\n\t\tb /= 2;\n\t}\n\treturn r;\n}\nint my_inv(int a) { return my_pow(a, mod - 2); }\n\nint f(vector<int> h) {\n\th.push_back(1);\n\tint n = h.size();\n\tvector<int> dp(n);\n\tdp[n-1] = 1;\n\tfor(int i = n - 2; i >= 0; --i) {\n\t\tdp[i] = mul(dp[i+1], 2); // not destroying\n\t\tif(i > 0 && h[i] <= h[i-1]) continue;\n\t\tconst int prv = i ? h[i-1] : 1;\n\t\tint min_so_far = h[i];\n\t\tint multiplier = 2;\n\t\tfor(int j = i + 1; j <= n - 1; ++j) {\n\t\t\tif(h[j] < min_so_far) {\n\t\t\t\t//~ int diff = max(0, min_so_far - max(h[j], prv));\n\t\t\t\tint low = max(h[j], prv) + 1;\n\t\t\t\tint high = min_so_far;\n\t\t\t\tswap(low, high);\n\t\t\t\tlow = h[i] - low;\n\t\t\t\thigh = h[i] - high;\n\t\t\t\tint a = low;\n\t\t\t\tint b = high;\n\t\t\t\tif(low <= high) {\n\t\t\t\t\tdp[i] = (dp[i] + mul(dp[j], mul(multiplier, mul(my_pow(2, a), my_pow(2, b - a + 1) - 1)))) % mod;\n\t\t\t\t}\n\t\t\t\t//~ for(int k = low; k <= high; ++k)\n\t\t\t\t\t//~ dp[i] = (dp[i] + mul(dp[j], mul(multiplier, my_pow(2, k)))) % mod;\n\t\t\t\t//~ dp[i] = (dp[i] + mul(dp[j], mul(2, diff)));\n\t\t\t\tmin_so_far = h[j];\n\t\t\t}\n\t\t\t//~ if(h[j] > h[j-1]) multiplier = mul(2, multiplier);\n\t\t\tmultiplier = mul(multiplier, my_pow(2, max(0, h[j] - h[j-1])));\n\t\t}\n\t}\n\tdebug() << imie(dp);\n\treturn dp[0];\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tvector<int> h(n);\n\tfor(int & x : h) scanf(\"%d\", &x);\n\tint answer = 1;\n\tfor(int i = 0; i < n; ++i) {\n\t\tif(h[i] > 1) {\n\t\t\tvector<int> gather;\n\t\t\tgather.push_back(h[i]);\n\t\t\twhile(i + 1 < n && h[i+1] > 1) {\n\t\t\t\t++i;\n\t\t\t\tgather.push_back(h[i]);\n\t\t\t}\n\t\t\tanswer = mul(answer, f(gather));\n\t\t}\n\t\telse answer = mul(answer, 2);\n\t}\n\tanswer %= mod;\n\tif(answer < 0) answer += mod;\n\tprintf(\"%d\\n\", answer);\n\t//~ int answer = 1 << (n - 1);\n\t//~ for(int i = 0; i < n; ++i) {\n\t\t//~ int prv = i ? h[i-1] : 0;\n\t\t//~ answer <<= max(0, h[i] - prv);\n\t//~ }\n\t//~ cout << answer << endl;\n\t/*vector<int> dp(2);\n\t// dp[0] = takie same, nie mozna wybierac :(\n\tdp[1] = 1;\n\tfor(int ii = 0; ii < n; ++ii) {\n\t\tint here = h[ii];\n\t\tint prv = ii ? h[ii-1] : 0;\n\t\tint sure = 0;\n\t\tif(ii == 0) sure = here;\n\t\telse sure = max(0, here - prv);\n\t\t\n\t}\n\tint answer = (dp[0] + dp[1]) % mod;\n\tprintf(\"%d\\n\", answer);*/\n}\n"
  },
  {
    "language": "C++",
    "code": "//\n// Created by Ильдар Ялалов on 14.01.2020.\n//\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst int inf_int = 1e9 + 100;\nconst ll inf_ll = 1e18;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef long double dbl;\ntypedef unsigned int uint;\n#define pb push_back\n#define eb emplace_back\nconst double pi = 3.1415926535898;\n#define dout if(debug) cout\n#define fi first\n#define se second\n#define sp setprecision\n#define sz(a) (int(a.size()))\n#define mp make_pair\n#define all(a) a.begin(),a.end()\n\n\ntemplate<class T1, class T2>\nstd::ostream &operator<<(std::ostream &out, const std::pair<T1, T2> &rhs) {\n    out << \"( \" << rhs.first << \" , \" << rhs.second << \" )\";\n    return out;\n}\n\ntemplate<typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate<typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate<typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string &s) {\n    return '\"' + s + '\"';\n}\n\nstring to_string(const char *s) {\n    return to_string((string) s);\n}\n\nstring to_string(bool b) {\n    return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n    bool first = true;\n    string res = \"{\";\n    for (int i = 0; i < static_cast<int>(v.size()); i++) {\n        if (!first) {\n            res += \", \";\n        }\n        first = false;\n        res += to_string(v[i]);\n    }\n    res += \"}\";\n    return res;\n}\n\ntemplate<size_t N>\nstring to_string(bitset<N> v) {\n    string res = \"\";\n    for (size_t i = 0; i < N; i++) {\n        res += static_cast<char>('0' + v[i]);\n    }\n    return res;\n}\n\ntemplate<typename A>\nstring to_string(A v) {\n    bool first = true;\n    string res = \"{\";\n    for (const auto &x : v) {\n        if (!first) {\n            res += \", \";\n        }\n        first = false;\n        res += to_string(x);\n    }\n    res += \"}\";\n    return res;\n}\n\ntemplate<typename A, typename B>\nstring to_string(pair<A, B> p) {\n    return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate<typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n    return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate<typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n    return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" +\n           to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate<typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n    cerr << \" \" << to_string(H);\n    debug_out(T...);\n}\n\n#ifdef zxc\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nbool debug = 0;\nconst int MAXN = 1000 + 100;\nconst int LOG = 21;\nconst int mod = 1e9 + 7;\nconst int MX = (1e7 + 100) * 1.5;\ntypedef long long li;\n\n\ntemplate<uint MD>\nstruct ModInt {\n    using M = ModInt;\n    uint v;\n\n    ModInt() : v{0} {}\n\n    ModInt(ll _v) : v{normS(_v % MD + MD)} {}\n\n    explicit operator bool() const { return v != 0; }\n\n    static uint normS(uint x) { return (x < MD) ? x : x - MD; };\n\n    static M make(uint x) {\n        M m;\n        m.v = x;\n        return m;\n    }\n\n    static M inv(const M &x) { return x.pow(MD - 2); }\n\n    M operator+(const M &r) const { return make(normS(v + r.v)); }\n\n    M operator-(const M &r) const { return make(normS(v + MD - r.v)); }\n\n    M operator*(const M &r) const { return make(ull(v) * r.v % MD); }\n\n    M operator/(const M &r) const { return *this * inv(r); }\n\n    M &operator+=(const M &r) { return *this = *this + r; }\n\n    M &operator-=(const M &r) { return *this = *this - r; }\n\n    M &operator*=(const M &r) { return *this = *this * r; }\n\n    M &operator/=(const M &r) { return *this = *this / r; }\n\n    M pow(ll n) const {\n        M x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n};\n\nusing Mint = ModInt<mod>;\n\nusing P = pair<Mint, Mint>; // 0101, all\n\nP solve(vector<int> &a) {\n    int n = sz(a);\n    int mn = *min_element(all(a));\n\n    int cnt = 0;\n    vector<int> nxt;\n\n    Mint total = 1;\n    Mint spec = 1;\n    for (int &v:a) {\n        v -= mn;\n    }\n    for (int i = 0; i < n; ++i) {\n        if (a[i] == 0) {\n            if (!nxt.empty()) {\n                auto res = solve(nxt);\n                total *= res.first + res.second;\n                spec *= res.first;\n            }\n            nxt.clear();\n            cnt++;\n        } else {\n            nxt.pb(a[i]);\n        }\n    }\n    if (!nxt.empty()) {\n        auto res = solve(nxt);\n        total *= (res.first + res.second);\n        spec *= res.first;\n    }\n\n    total = total * (Mint(2).pow(cnt));\n\n    total = total + spec * (Mint(2).pow(mn) - 2);\n    spec = spec * (Mint(2).pow(mn));\n    return {spec, total};\n}\n\nvoid solve() {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i];\n    }\n    cout << solve(a).second.v << \"\\n\";\n}\n\nsigned main() {\n#ifdef zxc\n    freopen(\"../input.txt\", \"r\", stdin);\n    // freopen(\"../output.txt\", \"w\", stdout);\n#else\n#endif //zxc\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cout.setf(ios::fixed);\n    cout.precision(15);\n\n    int t = 1;\n    while (t--)\n        solve();\n    debug(1.0 * clock() / CLOCKS_PER_SEC);\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<stdio.h>\nusing namespace std;\ntypedef long long ll;\nconst int P=1e9+7,N=105;\ninline int fpow(int a,int t){\n\tstatic int r;\n\tfor(r=1;t;t>>=1,a=(ll)a*a%P)if(t&1)r=(ll)r*a%P;\n\treturn r;\n}\nint n,m,res,h[N],v[N],f[N][N];\ninline void inc(int&x,int y){x+=y;x<P?:x-=P;}\nint main(){\n\tint i,j,k,t;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;i++)scanf(\"%d\",h+i),v[i]=h[i];\n\tsort(v+1,v+n+1),m=unique(v+1,v+n+1)-v-1;\n\tfor(i=1;i<=n;i++)h[i]=lower_bound(v+1,v+m+1,h[i])-v;\n\tfor(i=j=1;j<=h[i];j++)f[i][j]=(ll)2*(fpow(2,v[j]-v[j-1]-(j==1))-1)*fpow(2,v[h[i]]-v[j])%P;\n\tf[i][h[i]+1]=2;\n\tfor(i=2;i<=n;i++){\n\t\tfor(j=1;j<=h[i-1];j++)inc(f[i][min(j,h[i]+1)],f[i-1][j]);\n\t\tif(h[i]>h[i-1]){\n\t\t\tt=fpow(2,v[h[i]]-v[h[i-1]]);\n\t\t\tfor(j=1;j<=h[i-1];j++)f[i][j]=(ll)f[i][j]*t%P;\n\t\t\tfor(j=h[i-1]+1;j<=h[i];j++)f[i][j]=(ll)f[i-1][h[i-1]+1]*2*(fpow(2,v[j]-v[j-1])-1)%P*fpow(2,v[h[i]]-v[j])%P;\n\t\t}else (f[i][h[i]+1]<<=1)%=P;\n\t\tinc(f[i][h[i]+1],f[i-1][h[i-1]+1]*2%P);\n\t}\n\tfor(i=1;i<=m+1;i++)inc(res,f[n][i]);\n\tprintf(\"%d\\n\",res);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N = 105;\nconst int MOD = 1000000007;\n\nint n,f[N][N],h[N],w[N],m;\n\nint ksm(int x,int y) {\n    if(y < 0)return 1;\n    int ans = 1;\n    while(y) {\n        if(y & 1)ans = (LL)ans * x % MOD;\n        x = (LL)x * x % MOD;\n        y /= 2;\n    }\n    return ans;\n}\n\nint main() {\n    scanf(\"%d\",&n);\n    for(int i = 1;i <= n;i ++) {\n        scanf(\"%d\",&h[i]);\n        w[++ m] = h[i];\n    }\n    sort(w + 1,w + m + 1);\n    m = unique(w + 1,w + m + 1) - w - 1;\n    for(int i = 1;i <= n;i ++) {\n        h[i] = lower_bound(w + 1,w + m + 1,h[i]) - w;\n    }\n    f[0][0]=1;\n    for(int i = 1;i <= n;i ++) {\n        for(int j = h[i] + 1;j <= h[i-1];j ++)\n            (f[i][0] += f[i - 1][j] * 2 % MOD) %= MOD;\n        (f[i][0] += f[i - 1][0] * 2 % MOD) %= MOD;\n        for(int j = 1;j <= h[i];j ++) {\n            f[i][j]=(LL)f[i - 1][j] * ksm(2,w[h[i]] - w[h[i-1]]) % MOD;\n            if(h[i - 1] >= j)continue;\n            if(j > 1)(f[i][j] += (LL)f[i - 1][0] * (ksm(2,w[j] - w[j - 1]) - 1) % MOD * 2 % MOD * ksm(2,w[h[i]] - w[j]) % MOD) %= MOD;\n            else (f[i][j] += (LL)f[i - 1][0] * (ksm(2,w[j]) - 2) % MOD * ksm(2,w[h[i]] - w[j]) % MOD) %= MOD;\n        }\n    }\n    int ans = 0;\n    for(int i = 0;i <= m;i++)\n        (ans += f[n][i]) %= MOD;\n    printf(\"%d\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\nconst int mod = 1000000007;\nint n;\nint a[105];\nll exp(ll a, ll x){\n    if (x == 0) return 1ll;\n    ll p = exp(a,x/2);\n    p = (p*p)%mod;\n    if (x & 1){\n        p = (p*a)%mod;\n    }\n    return p;\n}\nii solve(int l, int r, int s){\n    if (l > r) return ii(1ll,0ll);\n    int pos = l;\n    for (int i = l; i <= r; i++){\n        if (a[i] < a[pos]) pos = i;\n    }\n    ii L = solve(l,pos-1,a[pos]);\n    ii R = solve(pos+1,r,a[pos]);\n    ll prod1 = (ll)(L.first)*(R.first)%mod;\n    ll prod2 = (ll)(L.first+L.second)*(R.first+R.second)%mod;\n    ll ex = exp(2,a[pos]-s);\n    ll dp1 = (ex*prod1)%mod;\n    ll dp2 = (2*prod2 + (ex-2)*prod1)%mod;\n    //printf(\"%d %d %lld %lld\\n\",l,r,dp1,dp2);\n    return ii(dp1,dp2);\n}\nint main(){\n    scanf(\"%d\",&n);\n    for (int i = 0; i < n; i++) scanf(\"%d\",&a[i]);\n    printf(\"%lld\",solve(0,n-1,0).second);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#define ll long long\nusing namespace std;\nconst ll MOD=1e9+7;\nint n,sa[105],rnk[105];\nll k,h[105],s[105],f0;\nll quick_pow(ll x,ll a)\n{\n\tll ans=1;\n\twhile(a)\n\t{\n\t\tif(a&1)ans=ans*x%MOD;\n\t\tx=x*x%MOD;\n\t\ta>>=1;\n\t}\n\treturn ans;\n}\nbool cmp(int a,int b)\n{\n\treturn h[a]<h[b];\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%lld\",&h[i]);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tsa[i]=i;\n\t\tif(h[i]>max(h[i-1],h[i+1]))\n\t\t{\n\t\t\tk+=h[i]-max(h[i-1],h[i+1]);\n\t\t\th[i]=max(h[i-1],h[i+1]);\n\t\t}\n\t}\n\tsort(sa+1,sa+n+1,cmp);\n\tfor(int i=1;i<=n;i++)rnk[sa[i]]=i;\n\tf0=1;\n\th[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(rnk[i]<rnk[i-1])f0=(f0*2+(s[rnk[i-1]]-s[rnk[i]]+MOD)*2)%MOD;\n\t\telse\n\t\t{\n\t\t\tfor(int j=1;j<=rnk[i-1];j++)\n\t\t\t  s[j]=s[j]*quick_pow(2,h[i]-h[i-1])%MOD;\n\t\t\tfor(int j=rnk[i-1]+1;j<=rnk[i];j++)\n\t\t\t  s[j]=(s[j-1]+f0*2*(quick_pow(2,h[i]-h[sa[j-1]])-quick_pow(2,h[i]-h[sa[j]])+MOD))%MOD;\n\t\t\tf0=f0*2%MOD;\n\t\t}\n\t}\n\tll ans=s[rnk[n]]+f0;\n\tans=ans%MOD*quick_pow(2,k)%MOD;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nconst int N = 105;\nconst int INF = 0x3f3f3f3f;\ntypedef long long ll;\n#define lson l, m, rt<<1\n#define rson m+1, r, rt<<1|1\nconst int MOD = 1e9+7;\nint h[N];\nint Has[N]; int tot;\nll dp[N][N];\nll Pow(ll x, ll y) {\n    if(y <= 0) return 1;\n    ll result = 1;\n    while(y) {\n        if(y & 1)\n            result = result * x % MOD;\n        y >>= 1;\n        x = x*x % MOD;\n    }\n    return result;\n}\nint main() {\n    int n;\n    while(~scanf(\"%d\", &n)) {\n        tot = 0;\n        memset(dp, 0, sizeof(dp));\n        h[0] = 0;\n        dp[0][0] = 1;\n\n        for(int i = 1; i <= n; ++i) {\n            scanf(\"%d\", &h[i]);\n            Has[++tot] = h[i];\n        }\n        sort(Has + 1, Has + tot + 1);\n        tot = unique(Has+1, Has + tot + 1) - Has - 1;\n\n        for(int i = 1; i <= n; ++i) {\n            h[i] = lower_bound(Has + 1, Has + tot + 1, h[i]) - Has;\n        }\n        for(int i = 1; i <= n; ++i) {\n            dp[i][0] = dp[i-1][0] * 2 % MOD;\n            for(int j = h[i] + 1; j <= h[i-1]; ++j) dp[i][0] = (dp[i][0] + dp[i-1][j] * 2 % MOD) % MOD;\n            ll tmpPow = Pow(2, Has[h[i]] - Has[h[i-1]]);\n            for(int j = 1; j <= min(h[i-1], h[i]) ; ++j)\n                dp[i][j] = dp[i-1][j] * tmpPow % MOD;\n            for(int j = h[i-1] + 1; j <= h[i]; ++j) {\n                dp[i][j] = (dp[i][j] + j==1? ( dp[i-1][0] * ( Pow(2, Has[j]) - 2) % MOD * Pow(2, Has[h[i]] - Has[j]) % MOD ) :\n                                             ( dp[i-1][0] * 2 * (Pow(2, Has[j]-Has[j-1]) - 1) % MOD * Pow(2, Has[h[i]]-Has[j]) % MOD )\n                                             ) %MOD;\n            }\n        }\n        ll result = 0;\n        for(int i = 0; i <= tot; ++i)\n            result = (result + dp[n][i]) % MOD;\n        printf(\"%lld\\n\", result);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define F first\n#define S second\n#define ALL(v) v.begin(),v.end()\n#define fast_cin() ios_base::sync_with_stdio(0);\n#define smid ((i + j) >> 1)\n#define lc (sidx * 2)\n#define rc (lc + 1)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <ll,ll> pll;\ntypedef pair <int,int> pii;\n\n#define TRACE\n#ifndef ONLINE_JUDGE\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n    cerr << name << \" : \" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n    const char* comma = strchr(names + 1, ',');cerr.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n}\n#else\n#define trace(...)\n#endif\n\nbool bit(int n, int i) { return (n >> i) & 1; }\nint ceil(int a, int b) { return ceil(((ld)a) / b); }\n\nint faltu;\n\nconst int mod = 1e9+7;\nconst ll inf = 4e18;\nconst ll ninf = -inf;\nconst int imax = 2e9 + 100;\n\nll power(ll m) {\n\tll res = 1, a = 2;\n\twhile(m > 0) {\n\t\tif(m & 1) {\n\t\t\tres = (res * a) % mod;\n\t\t}\n\t\tm /= 2;\n\t\ta = (a * a) % mod;\n\t}\n\treturn res;\n}\n\nll solve(ll h[], int n) {\n\tif(n <= 0) {\n\t\treturn 1;\n\t}\n\tll ans = power(h[1]);\n\tll tmp[n + 1], alt[n + 1];\n\talt[0] = 1;\n\tif(h[2] < h[1]) {\n\t\talt[1] = (2ll * power(h[1] - h[2])) % mod;\n\t} else {\n\t\talt[1] = (2) % mod;\n\t}\n\ttmp[0] = 1;\n\ttmp[1] = ans;\n\tfor(int i = 2; i <= n; i++) {\n\t\tif(h[i] > h[i - 1]) {\n\t\t\tans = (((ans + alt[i - 1]) % mod) * (power(h[i] - h[i - 1]))) % mod;\n\t\t} else {\n\t\t\tans = (ans + alt[i - 1]) % mod;\n\t\t}\n\t\ttmp[i] = ans;\n\t\tif(i < n and h[i + 1] < h[i]) {\n\t\t\talt[i] = (((alt[i - 1] * 2ll) % mod) * power(h[i] - h[i + 1])) % mod;\n\t\t} else {\n\t\t\talt[i] = (alt[i - 1] * 2) % mod;\n\t\t}\n\t\ttrace(ans);\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\ttime_t t1, t2;\n\tt1 = clock();\n\tsrand(time(0));\n\t\n\tll n;\n\tcin >> n;\n\n\tll h[n + 1];\n\tvector <int> breakDowns;\n\tfor(int i = 1; i <= n; i++) {\n\t\tcin >> h[i];\n\t\tif(h[i] == 1) {\n\t\t\tbreakDowns.pb(i);\n\t\t}\n\t}\n\tbreakDowns.pb(n + 1);\n\tvector <ll> ans;\n\tint last = 0;\n\tfor(int i: breakDowns) {\n\t\ttrace(i - last - 1);\n\t\tans.pb(solve(h + last, i - last - 1));\n\t\tlast = i;\n\t}\n\tll fAns = power(breakDowns.size() - 1);\n\ttrace(fAns);\n\tfor(ll i: ans) {\n\t\ttrace(i);\n\t\tfAns = (fAns * i) % mod;\n\t}\n\tfAns = (fAns + mod) % mod;\n\tcout << fAns << endl;\n\n\tt2 = clock();\n\tcerr << \"time taken: \" << t2 - t1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\nconst ll MOD=1e9+7;\n\n\nll powm(ll x,ll k){\n    ll res=1;\n    while(k){\n        if(k&1) res*=x;\n        k>>=1;\n        x*=x;\n        res%=MOD;\n        x%=MOD;\n    }\n    return res;\n}\n\nvector<vector<ll>> patp;\nvector<vector<ll>> pati;\n\nll query_p(int hei,int l,int r,vector<ll>& h){\n    if(patp[l][r]!=-1){\n        return patp[l][r];\n    }\n    if(l==r) return 1;\n    ll mi=1e9;\n    for(int i=l;i<r;i++){\n        mi=min(mi,h[i]);\n    }\n    int tail=l;\n    ll res=powm(2,mi-hei); //todo\n    for(int i=l;i<=r;i++){\n        if(i==r || h[i]==mi){\n            res*=query_p(mi,tail,i,h);\n            res%=MOD;\n            tail=i+1;\n        }\n    }\n    return patp[l][r]=res;\n}\n\nll query_i(int hei,int l,int r,vector<ll>& h){\n    if(pati[l][r]!=-1){\n        return pati[l][r];\n    }\n    if(l==r) return 0;\n    ll mi=1e9;\n    ll cnt=1;\n    for(int i=l;i<r;i++){\n        if(h[i]<mi){\n            mi=h[i];\n            cnt=1;\n        }\n        else if(h[i]==mi){\n            cnt++;\n        }\n    }\n    int tail=l;\n    ll res=powm(2,cnt);\n    for(int i=l;i<=r;i++){\n        if(i==r || h[i]==mi){\n            ll v=query_p(mi,tail,i,h);\n            if(v!=1){\n                res*=(query_i(mi,tail,i,h)%MOD+2*v)%MOD;\n            }\n            else{\n                res*=(query_i(mi,tail,i,h)%MOD+v)%MOD;\n            }\n            res%=MOD;\n            tail=i+1;\n        }\n    }\n    \n    res=((res-(2*query_p(hei,l,r,h))*powm(powm(2,mi-hei),MOD-2))%MOD%MOD+MOD)%MOD;\n    \n    return pati[l][r]=res;\n}\nint main(){\n    int n;\n    cin>>n;\n    patp.assign(n+1,vector<ll>(n+1,-1));\n    pati.assign(n+1,vector<ll>(n+1,-1));\n    vector<ll> h(n);\n    for(int i=0;i<n;i++) cin>>h[i];\n    ll num=(2*query_p(1,0,n,h)+query_i(1,0,n,h))%MOD;\n    cout<<num<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n\nconst int N = 1e6 + 10;\nconst int mod = 1e9 + 7;\nint h[N], st[N], top, n, ls[N], rs[N], root, f[N][2], num[N], single[N], mulsingle[N], rev[N], coe[N];\nbool bsin[N];\n\ninline void build()\n{\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tint k = top;\n\t\twhile (k > 0 && h[st[k]] > h[i]) k--;\n\t\tif (k) rs[st[k]] = i;\n\t\tif (k < top) ls[i] = st[k + 1];\n\t\tst[++k] = i;\n\t\ttop = k;\n\t}\n\troot = st[1];\n}\n\nvoid dfs(int x)\n{\n\tif (!x) return;\n\tcout << \"x \" << x << endl;\n\tdfs(ls[x]), dfs(rs[x]);\n}\n\ninline int fp(int a, int n)\n{\n\tint res = 1;\n\twhile (n)\n\t{\n\t\tif (n & 1) res = (res * a) % mod;\n\t\ta = (a * a) % mod;\n\t\tn >>= 1;\n\t}\n\treturn res % mod;\n}\n\ninline void fill(int *a, int siz, int val)\n{\n\tfor (int i = 1; i <= siz; i++)\ta[i] = val;\n}\n\ninline void dp(int x, int fa)\n{\n\tif (!x) return;\n\tnum[x] = 1;\n\trev[x] = 1;\n\tcoe[x] = 1;\n\tint height = h[x] - h[fa];\n\t// if (!rs[x] && !ls[x] && h[x] != h[fa])\n\t// {\n\t// \tsingle[x] = 1;\n\t// \tmulsingle[x] *= fp(2, height);\n\t// \treturn;\n\t// }\n\tif (!rs[x] && !ls[x] && h[x] == h[fa])\n\t\treturn;\n\tdp(ls[x], x);\n\tdp(rs[x], x);\n\t// if (ls[x] && x - ls[x] == 1) rev[x] += single[ls[x]];\n\t// if (rs[x] && rs[x] - x == 1) rev[x] += single[rs[x]];\n\t// if (ls[x]) mulsingle[x] *= mulsingle[ls[x]];\n\t// if (rs[x]) mulsingle[x] *= mulsingle[rs[x]]; \n\tif (ls[x] && h[ls[x]] == h[x]) rev[x] += rev[ls[x]], coe[x] = (coe[ls[x]] * coe[x]) % mod;\n\tif (rs[x] && h[rs[x]] == h[x]) rev[x] += rev[rs[x]], coe[x] = (coe[rs[x]] * coe[x]) % mod;\n\tif (f[ls[x]][1] == 0) ls[x] = 0;\n\tif (f[rs[x]][1] == 0) rs[x] = 0;\n\tif (h[x] != h[fa]) coe[x] = 2;\n\tif (height > 0)\n\t{\n\t\tif (rs[x] && ls[x])\n\t\t{\n\t\t\tf[x][1] = f[rs[x]][1] * f[ls[x]][1] % mod * fp(2, height) % mod;\n\t\t\t// cout << \"fk1 \" << f[rs[x]][1] << ' ' << f[ls[x]][1] << endl;\n\t\t\t// cout << \"fk0 \" << f[rs[x]][0] << ' ' << f[ls[x]][0] << endl;\n\t\t\t// f[x][0] = (((f[rs[x]][1] * f[ls[x]][0] % mod * coe[rs[x]] % mod * fp(2, rev[x]) % mod + \n\t\t\t// \tf[rs[x]][0] * f[ls[x]][1] % mod * coe[ls[x]] % mod * fp(2, rev[x]) % mod) % mod + \n\t\t\t// f[rs[x]][0] * f[ls[x]][0] % mod * fp(2, rev[x]) % mod) % mod + \n\t\t\t// f[rs[x]][1] * f[ls[x]][1] % mod * (coe[rs[x]] % mod * coe[ls[x]] % mod * fp(2, rev[x]) - 2 + mod) % mod) % mod;\n\t\t\tf[x][0] = f[rs[x]][1] * f[ls[x]][0] % mod * coe[rs[x]] % mod * fp(2, rev[x]) % mod;\n\t\t\tf[x][0] = (f[x][0] + f[rs[x]][0] * f[ls[x]][1] % mod * coe[ls[x]] % mod * fp(2, rev[x]) % mod) % mod;\n\t\t\tf[x][0] = (f[x][0] + f[rs[x]][0] * f[ls[x]][0] % mod * fp(2, rev[x]) % mod) % mod;\n\t\t\tf[x][0] = (f[x][0] + f[rs[x]][1] * f[ls[x]][1] % mod * (coe[rs[x]] % mod * coe[ls[x]] % mod * fp(2, rev[x]) % mod - 2 + mod) % mod) % mod;\n\n\t\t}\n\t\telse if (rs[x])\n\t\t{\n\t\t\tf[x][1] = f[rs[x]][1] * fp(2, height) % mod;\n\t\t\tf[x][0] = (f[rs[x]][0] * fp(2, rev[x]) % mod + f[rs[x]][1] * ((coe[rs[x]] * fp(2, rev[x]) % mod - 2 + mod) % mod)) % mod;\n\t\t\t// cout << \"f[rs[x]][0] \" << f[rs[x]][0] << endl;\n\t\t\t// cout << \"f[rs[x]][1] \" << f[rs[x]][1] << endl;\n\t\t\t// cout << \"coe[rs[x]] \" << coe[rs[x]] << endl;\n\t\t\t// cout << \"rev[x] \" << rev[x] << endl;\n\t\t\t// cout << \"fk \" << f[x][0] << endl;\n\t\t}\n\t\telse if (ls[x])\n\t\t{\n\t\t\tf[x][1] = f[ls[x]][1] * fp(2, height) % mod;\n\t\t\tf[x][0] = (f[ls[x]][0] * fp(2, rev[x]) % mod + f[ls[x]][1] * ((coe[ls[x]] * fp(2, rev[x]) % mod - 2 + mod) % mod)) % mod;\n\t\t}\n\t\telse \n\t\t{\n\t\t\tf[x][1] = fp(2, height);\n\t\t\tf[x][0] = (fp(2, rev[x]) - 2 + mod) % mod;\n\t\t}\n\t}\t\n\telse \n\t{\n\t\tif (rs[x] && ls[x])\n\t\t{\n\t\t\tif (h[rs[x]] != h[x])\n\t\t\t\tcoe[x] = (coe[x] * 2) % mod;\n\t\t\tif (h[ls[x]] != h[x])\n\t\t\t\tcoe[x] = (coe[x] * 2) % mod;\n\t\t\tf[x][1] = f[rs[x]][1] * f[ls[x]][1] % mod;\n\t\t\tf[x][0] = ((f[rs[x]][0] * f[ls[x]][0] % mod + f[rs[x]][1] * f[ls[x]][0] % mod * coe[rs[x]] % mod) % mod + f[rs[x]][0] * f[ls[x]][1] % mod * coe[ls[x]] % mod) % mod;\n\t\t}\n\t\telse if (rs[x])\n\t\t{\n\t\t\tf[x][1] = f[rs[x]][1];\n\t\t\tf[x][0] = f[rs[x]][0];\n\t\t\tif (h[rs[x]] != h[x])\n\t\t\tcoe[x] = (2 * coe[x]) % mod;\n\t\t}\n\t\telse if (ls[x])\n\t\t{\n\t\t\tf[x][1] = f[ls[x]][1];\n\t\t\tf[x][0] = f[ls[x]][0];\n\t\t\tif (h[ls[x]] != h[x])\n\t\t\tcoe[x] = (2 * coe[x]) % mod;\n\t\t}\n\t}\n\t// cout << \"x \" << x << endl;\n\t// cout << \"f[x][1] \" << f[x][1] << endl;\n\t// cout << \"f[x][0] \" << f[x][0] << endl;\n\t// cout << \"rev[x] \" << rev[x] << endl;\n\t// cout << \"coe[x] \" << coe[x] << endl;\n\tcoe[x] %= mod;\n\tf[x][1] %= mod;\n\tf[x][0] %= mod;\n}\n\nsigned main()\n{\n\tint ml = 0;\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++)\tcin >> h[i];\n\tif (n == 1)\n\t{\n\t\tcout << fp(2, h[1]) << endl;\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tif (h[i] > h[i - 1] && h[i] > h[i + 1]) ml += h[i] - max(h[i - 1], h[i + 1]), h[i] = max(h[i - 1], h[i + 1]);\n\tbuild();\n\tfill(mulsingle, n, 1);\n\tf[0][1] = f[0][0] = 1;\n\tdp(root, 0);\n\t// cout << \"mul \" << fp(2, ml) << endl;\n\tcout << (f[root][1] + f[root][0]) % mod * fp(2, ml) % mod << endl;\n\t// cout << \"1 \" << f[root][1] << endl;\n\t// cout << \"0 \" << f[root][0] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>/*{{{*/\n#include<cctype>\n#include<cassert>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<ctime>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<set>\n#include<vector>\nusing namespace std;\ntypedef long long lld;\ntypedef long double lf;\ntypedef unsigned long long uld;\ntypedef pair<int,int> pii;\n#define fi first\n#define se second\n#define pb push_back\n#define mk make_pair\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define ROF(i,a,b) for(int i=(a);i>=(b);--i)\nnamespace RA{\n    int r(int p){return 1ll*rand()*rand()%p;}\n    int r(int L,int R){return r(R-L+1)+L;}\n}/*}}}*/\n/******************heading******************/\nconst int N=105,P=1e9+7;\ntypedef long long LL;\n\nint n;\nint a[N];\nLL c[N][N];//区间[l,r]，以r结尾的段的个数\nLL f[N][N];//f[i,j]:前i个数，末尾j个是极长的交错段的方案数\nLL pw(LL a,LL m){\n    LL res=1;\n    while(m)m&1?res=res*a%P:0,a=a*a%P,m>>=1;\n    return res;\n}\n\n\nint main(){\n    scanf(\"%d\",&n);\n    FOR(i,1,n)scanf(\"%d\",&a[i]);\n    a[0]=1;\n    FOR(r,1,n){\n        if(a[r]<=a[r+1])continue;\n        int lim=a[r+1];\n        int cur=a[r];\n        ROF(i,r-1,0){\n            if(a[i]<cur){\n                c[i+1][r]+=cur-max(a[i],lim);\n                cur=max(a[i],lim);\n            }\n            c[i][r]=c[i+1][r];\n        }\n    }\n    //FOR(i,1,n)FOR(j,1,i)if(c[j][i])printf(\"c[%d,%d]=%lld\\n\",j,i,c[j][i]);\n    f[1][1]=pw(2,c[1][1])*2%P;\n    FOR(i,1,n){\n        FOR(j,2,i){\n            f[i][j]=f[i-1][j-1]*1ll*pw(2,c[i-j+1][i])%P;\n            //printf(\"f[%d,%d]=%lld\\n\",i,j,f[i][j]);\n        }\n        FOR(j,1,i-1){\n            f[i][1]=(f[i][1]+f[i-1][j]*pw(2,c[i][i]))%P;\n        }\n        //printf(\"f[%d,%d]=%lld\\n\",i,1,f[i][1]);\n    }\n    LL ans=0;\n    FOR(i,1,n)ans=(ans+f[n][i])%P;\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\ntypedef long long LL;\nconst LL mo=1e9+7;\nconst int N=1000;\nint n,ok[N+10];\nLL h[N+10],h2[N+1],f[N+10][N+10];\nLL mul(LL x,LL y) {\n    LL z=1;\n    while (y) {\n        if (y&1) z=z*x%mo;\n        y>>=1;\n        x=x*x%mo;\n    }\n    return z;\n}\nint main() {\n    scanf(\"%d\",&n);\n    for (int i=1;i<=n;i++) {\n        scanf(\"%lld\",&h[i]);\n        h2[i]=h[i];\n    }\n    sort(h2+1,h2+n+1);\n    h2[0]=1;\n    for (int i=n;i>=0;i--)\n        if (i==n||h2[i]!=h2[i+1]) ok[i]=1;\n    h2[n+1]=1e9;\n    for (int i=0;i<=n;i++) {\n        if (h2[i]>h[1]) break;\n        if (!ok[i]) continue;\n        if (h2[i+1]<=h[1]) f[1][i]=(mul(2,h[1]-h2[i])-mul(2,h[1]-h2[i+1]))*2%mo;\n        else f[1][i]=mul(2,h[1]-h2[i])*2%mo;\n    }\n    for (int i=1;i<n;i++)\n        for (int j=0;j<=n;j++) {\n            if (f[i][j]==0) continue;\n            if (h[i]<h[i+1]) {\n                if (h2[j]==h[i])\n                    for (int j2=j;j2<=n;j2++) {\n                        if (!ok[j2]||h2[j2]>h[i+1]) continue;\n                        LL now;\n                        if (h2[j2+1]<=h[i+1])\n                            now=f[i][j]*(mul(2,h[i+1]-h2[j2])-mul(2,h[i+1]-h2[j2+1]))%mo;\n                        else now=f[i][j]*mul(2,h[i+1]-h2[j2])%mo;\n                        f[i+1][j2]=(f[i+1][j2]+now*2)%mo;\n                    }\n                else f[i+1][j]=(f[i+1][j]+f[i][j]*mul(2,h[i+1]-h[i]))%mo;\n                continue;\n            }\n            if (h2[j]>=h[i+1]) {\n                int num=0;\n                for (int j=n;j>=0;j--)\n                    if (h2[j]==h[i+1]) {\n                        num=j;\n                        break;\n                    }\n                f[i+1][num]=(f[i+1][num]+f[i][j]*2)%mo;\n            }\n            else f[i+1][j]=(f[i+1][j]+f[i][j])%mo;\n        }\n    LL ans=0;\n    for (int i=0;i<=n;i++)\n        ans=(ans+f[n][i])%mo;\n    ans=(ans%mo+mo)%mo;\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint ungigned\n#define db double\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pli pair<ll,int>\n#define vi vector<int>\n#define vpi vector<pii >\n#define IT iterator\n \n#define PB push_back\n#define MK make_pair\n#define LB lower_bound\n#define UB upper_bound\n#define y1 wzpakking \n#define fi first\n#define se second\n#define BG begin\n#define ED end\n \n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define UPD(x,y) (((x)+=(y))>=mo?(x)-=mo:233)\n#define CLR(a,v) memset(a,v,sizeof(a))\n#define CPY(a,b) memcpy(a,b,sizeof(a))\n#define sqr(x) (1ll*x*x)\n \n#define LS3 k*2,l,mid\n#define RS3 k*2+1,mid+1,r\n#define LS5 k*2,l,mid,x,y\n#define RS5 k*2+1,mid+1,r,x,y\n#define GET pushdown(k);int mid=(l+r)/2\n#define INF (1ll<<60)\nusing namespace std;\n\nconst int mo=1000000007;\nint power(int x,ll y){\n\tint s=1;\n\tfor (;y;y/=2,x=1ll*x*x%mo)\n\t\tif (y&1) s=1ll*s*x%mo;\n\treturn s;\n}\nconst int N=105;\nint a[N],mn[N][N];\nint fxor[N][N];\nint pre[N][N];\nint suf[N][N];\nint mx[N],g[N],n;\nint main(){\n\tscanf(\"%d\",&n); n++;\n\tFor(i,2,n) scanf(\"%d\",&a[i]);\n\ta[0]=a[1]=a[n+1]=a[n+2]=1;\n\tFor(i,0,n+2) mn[i][i]=i;\n\tFor(l,0,n+2) For(r,l+1,n+2)\n\t\tmn[l][r]=(a[r]<a[mn[l][r-1]]?r:mn[l][r-1]);\n\tFor(i,1,n+2) fxor[i][i-1]=1;\n\tRep(l,n+2,1) For(r,l,n+2){\n\t\tint dn=max(a[l-1],a[r+1]),md=mn[l][r];\n\t\tif (a[md]>=dn) fxor[l][r]=1ll*power(2,a[md]-dn)*fxor[l][md-1]%mo*fxor[md+1][r]%mo;\n\t}\n\tFor(l,0,n+2){\n\t\tCLR(mx,0); mx[l]=a[l];\n\t\tFor(i,l+1,n+2) mx[i]=min(a[i],mx[i-1]);\n\t\tint tmp=pre[l][l]=1,las=l;\n\t\tFor(r,l+1,n+2){\n\t\t\tpre[l][r]=1ll*tmp*fxor[las+1][r-1];\n\t\t\tif (mx[r]>=a[r]) tmp=1ll*tmp*fxor[las+1][r-1],las=r;\n\t\t}\n\t}\n\tFor(r,0,n+2){\n\t\tCLR(mx,0); mx[r]=a[r];\n\t\tRep(i,r-1,0) mx[i]=min(a[i],mx[i+1]);\n\t\tint tmp=suf[r][r]=1,las=r;\n\t\tRep(l,r-1,0){\n\t\t\tsuf[l][r]=1ll*tmp*fxor[l+1][las-1];\n\t\t\tif (mx[l]>=a[l]) tmp=1ll*tmp*fxor[l+1][las-1],las=l;\n\t\t}\n\t}\n\tg[1]=1;\n\tFor(i,2,n+2) For(j,1,i-1){\n\t\tint md=mn[j-1][i];\n\t\tUPD(g[i],1ll*g[j]*pre[j-1][md]%mo*suf[md][i]%mo);\n\t}\n\tprintf(\"%d\\n\",1ll*g[n+2]*500000004ll%mo);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<iostream>\n#define fi first\n#define se second\n#define pi pair<LL,LL>\n#define LL long long\nusing namespace std;\nconst LL inf=2e9;\nconst LL mod=1e9+7;\nLL n,h[110];\nLL pow(LL a,LL b)\n{\n\tLL ans=1;\n\twhile(b)\n\t{\n\t\tif(b&1) ans=ans*a%mod;\n\t\ta=a*a%mod;b>>=1;\n\t}\n\treturn ans;\n}\npi solve(LL l,LL r,LL k)//l r区间大于k的部分\n{\n\tLL Min=inf,cnt=0;pi ans;\n\tfor(LL i=l;i<=r;i++)\n\t{\n\t\tif(h[i]<Min) Min=h[i],cnt=1;\n\t\telse if(h[i]==Min) cnt++;\n\t}\n\tif(cnt==(r-l+1))\n\t{\n\t\tans.fi=(pow(2,r-l+1)+mod-2)%mod;\n\t\tans.se=pow(2,Min-k-1);\n\t\t//printf(\"1:%lld %lld %lld %lld\\n\",l,r,ans.fi,ans.se);\n\t\treturn ans;\n\t}\n\tLL re=r-l+1,s0=1,s1=1,last=0;\n\tfor(LL i=l;i<=r+1;i++) if(!last&&h[i]>Min) last=i;\n\telse if(last&&(h[i]<=Min||i>r))\n\t{\n\t\tre-=i-last;\n\t\tpi tmp=solve(last,i-1,Min);\n\t\ts0=s0*(tmp.fi+4*tmp.se%mod)%mod;\n\t\ts1=s1*(2*tmp.se%mod)%mod;\n\t\tlast=0;\n\t}\n\ts0=(s0+mod-s1)%mod;\n\t//printf(\"s:%lld %lld\\n\",s0,s1);\n\tans.fi=s0*pow(2,re)%mod;\n\t(ans.fi+=(s1*(pow(2,re)-2+mod)%mod)%mod)%=mod;\n\tans.se=s1*pow(2,Min-k-1)%mod;\n\t//printf(\"2:%lld %lld %lld %lld\\n\",l,r,ans.fi,ans.se);\n\treturn ans;\n} \nint main()\n{\n\tscanf(\"%lld\",&n);\n\tfor(LL i=1;i<=n;i++) scanf(\"%lld\",&h[i]);\n\tif(n==1)\n\t{\n\t\tprintf(\"%lld\",pow(2,h[1]));\n\t\treturn 0;\n\t}\n\tLL tot=1;\n\tfor(LL i=1;i<=n;i++) if(h[i]>h[i-1]&&h[i]>h[i+1])\n\t{\n\t\t(tot*=pow(2,h[i]-max(h[i-1],h[i+1])))%=mod;\n\t\th[i]=max(h[i-1],h[i+1]);\n\t}\n\tpi ans=solve(1,n,0);\n\tprintf(\"%lld\",tot*((ans.fi+ans.se*2)%mod)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint N;\nint H[105];\nconst int MOD = 1000000007;\nint DP[2][105];\nvoid Read()\n{\n    cin >> N;\n    for(int i = 1; i <= N; i++)\n        cin >> H[i];\n}\nint power(int n, int p)\n{\n    int sol = 1;\n    while(p)\n    {\n        if(p % 2 == 1)\n            sol = (1LL * sol * n) % MOD;\n        n = (1LL * n * n) % MOD;\n        p /= 2;\n    }\n    return sol;\n}\ninline void Add(int& x, int y)\n{\n    x += y;\n    if(x >= MOD)\n        x -= MOD;\n}\nvoid Solve()\n{\n    int ans = 1;\n    for(int i = 1; i <= N; i++)\n    {\n        int m = max(H[i + 1], H[i - 1]);\n        if(m >= H[i])\n            continue;\n            ans = (1LL * ans * power(2, H[i] - m)) % MOD;\n        H[i] = min(m, H[i]);\n    }\n    int i = 1, next = 1;\n    while(i <= N)\n    {\n        next = i;\n        while(next <= N && H[next] > 1)\n        {\n            ++next;\n        }\n        if(i == next)\n        {\n            ans = (2LL * ans) % MOD;\n            i++;\n            continue;\n        }\n        DP[0][i] = power(2, H[i]) - 2;\n        DP[1][i] = 2;\n        for(int j = i + 1; j <= next - 1; j++)\n        {\n            if(H[j] <= H[j - 1])\n                DP[0][j] = DP[0][j - 1];\n            else\n            {\n                DP[0][j] = (1LL * DP[0][j - 1] * power(2, H[j] - H[j - 1])) % MOD;\n                Add(DP[0][j], (DP[1][j - 1] * 2LL * (power(2, H[j] - H[j - 1]) - 1)) % MOD);\n            }\n\n            DP[1][j] = (2LL * DP[1][j - 1]) % MOD;\n        }\n        int aux = DP[0][next - 1];\n        Add(aux, DP[1][next - 1]);\n        ans = (1LL * ans * aux) % MOD;\n        if(next <= N)\n            ans = (2LL * ans) % MOD;\n        i = next + 1;\n    }\n    cout << ans << \"\\n\";\n}\nint main()\n{\n    Read();\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <stdio.h>\n#include <complex>\n#include <cstdint>\n#include <tuple>\n#define M_PI       3.14159265358979323846\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define MT make_tuple\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,s,n) for(int i=s;i<(int)n;++i)\n#define REP(i,n) FOR(i,0,n)\n\n#define MOD 1000000007\n\nLL mod_pow(LL a, LL p) {\n\tLL tmp = a;\n\tLL ret = 1LL;\n\twhile (p) {\n\t\tif (p & 1) ret = (ret*tmp)%MOD;\n\t\tp >>= 1;\n\t\ttmp = (tmp*tmp) % MOD;\n\t}\n\treturn ret;\n}\n\nstruct node {\npublic:\n\tint h, w, parent;\n\tnode(int _h, int _w, int _p) :h(_h), w(_w), parent(_p) {};\n\tvector<int> childs;\n\tvoid add_child(int idx) {\n\t\tchilds.PB(idx);\n\t}\n};\n\nusing graph = vector<node>;\nint h[100];\ngraph g;\nint n;\nLL dp1[100], dp2[100];\n\nint build_tree(int s, int e, int parent=-1, int offset=0) {\n\tif (s == e)return -1;\n\tint x = 1e9 + 5;\n\tFOR(i, s, e)x = min(x, h[i]-offset);\n\tg.PB(node(x, e - s, parent));\n\tint myIdx = g.size() - 1;\n\tif(parent!=-1)g[parent].w -= g[myIdx].w;\n\tint start = s;\n\tFOR(i, s, e) {\n\t\tif (h[i] == x + offset) {\n\t\t\tauto childIdx = build_tree(start, i, myIdx, x+offset);\n\t\t\tif (childIdx != -1) g[myIdx].add_child(childIdx);\n\t\t\tstart = i + 1;\n\t\t}\n\t}\n\tauto childIdx = build_tree(start, e, myIdx, x + offset);\n\tif (childIdx != -1) g[myIdx].add_child(childIdx);\n\treturn myIdx;\n}\n\npair<LL, LL> calc(int idx = 0) {\n\tLL p1 = 1, p2 = 1;\n\tfor (auto child : g[idx].childs) {\n\t\tauto tmp = calc(child);\n\t\tp1 = (p1*tmp.first) % MOD;\n\t\tp2 = (p2*(tmp.first+tmp.second)) % MOD;\n\t}\n\treturn MP((p1*mod_pow(2, g[idx].h)) % MOD, (((p2*mod_pow(2, g[idx].w)) % MOD + (p1*mod_pow(2, g[idx].h)) % MOD) % MOD - p1 * 2 + 2 * MOD) % MOD);\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tREP(i, n)scanf(\"%d\", &h[i]);\n\tbuild_tree(0, n);\n\tauto ans = calc();\n\tcout << ans.second << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author aajisaka\n */\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n#define SPEED ios_base::sync_with_stdio(false);cin.tie(nullptr)\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define all(v) v.begin(), v.end()\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing P = pair<ll, ll>;\n\nconstexpr long double PI = 3.14159265358979323846264338327950288L;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nconstexpr ll mod17 = 1e9+7;\nconstexpr ll mod19 = 1e9+9;\nconstexpr ll mod9 = 998244353;\nll mod = mod17;\n\n// Mod int libraries\ntemplate<typename T>\nT mod_pow(T a, ll x) {\n  T res = 1;\n  while(x > 0) {\n    if (x & 1) res *= a;\n    a *= a; x >>= 1;\n  }\n  return res;\n}\n\n// Mint32\nunordered_map<ll, ll> minvmap;\nll minv(ll a, ll m) {\n  auto k = a; auto p = minvmap[a]; if (p != 0) return p;\n  ll b = m, u = 1, v = 0;\n  while (b) { ll t = a/b; swap(a -= t*b, b); swap(u -= t*v, v); }\n  p = (u%m+m)%m; minvmap[k] = p; return p;\n}\n\nstruct mint {\n  ll x;\n  mint():x(0){}\n  mint(ll x):x((x%mod+mod)%mod){}\n  mint& fix() { x = (x%mod+mod)%mod; return *this;}\n  mint operator-() const { return mint(0) - *this;}\n  mint& operator+=(const mint& a){ if((x+=a.x)>=mod) x-=mod; return *this;}\n  mint& operator-=(const mint& a){ if((x+=mod-a.x)>=mod) x-=mod; return *this;}\n  mint& operator*=(const mint& a){ (x*=a.x)%=mod; return *this;}\n  mint& operator/=(const mint& a){ (x*=minv(a.x, mod))%=mod; return *this; }\n  mint operator+(const mint& a)const{ return mint(*this) += a;}\n  mint operator-(const mint& a)const{ return mint(*this) -= a;}\n  mint operator*(const mint& a)const{ return mint(*this) *= a;}\n  mint operator/(const mint& a)const{ return mint(*this) /= a;}\n  bool operator<(const mint& a)const{ return x < a.x;}\n  bool operator==(const mint& a)const{ return x == a.x;}\n};\n\n// Mint64\nstruct mint64 {\n    ull x;\n    static ull mod, inv, r2;\n    mint64(): x(0){}\n    mint64(ull x): x(init(x)) {}\n    static ull init(ull x) { return reduce(__uint128_t(x)*r2);}\n    static void set_mod(ull m) {\n      mod = inv = m;\n      for(int i=0; i<5; i++) inv *= 2 - inv*m;\n      r2 = -__uint128_t(m)%m;\n    }\n    static ull reduce(__uint128_t x) {\n      ull y = ull(x >> 64) - ull((__uint128_t(ull(x)*inv)*mod)>>64);\n      return ll(y) < 0 ? y+mod : y;\n    }\n    mint64& operator+=(mint64& a) { x+=a.x-mod; if(ll(x)<0) x+=mod; return *this; }\n    mint64 operator+(mint64& a) const{ return mint64(*this)+=a; }\n    mint64& operator*=(mint64& a) { x=reduce(__uint128_t(x)*a.x); return *this; }\n    mint64 operator*(mint64& a) const { return mint64(*this)*=a; }\n};\n\null mint64::mod, mint64::inv, mint64::r2;\n\n// Verify: https://yukicoder.me/submissions/472580\nstruct Miller {\n    const vector<ull> v = {2, 325, 9375, 28178, 450775, 9780504, 1795265022};\n    bool suspect(ull a, ull s, ull d, ull n) {\n      if (mint64::mod != n) mint64::set_mod(n);\n      mint64 one = 1, minusone = n-1, ma = a;\n      auto x = mod_pow(ma, d);\n      if (x.x == one.x) return true;\n      for(ull r = 0; r < s; r++) {\n        if (x.x == minusone.x) return true;\n        x = x * x;\n      }\n      return false;\n    }\n\n    // check if n is prime\n    bool check(ull n) {\n      if (n < 2 || (n > 2 && n % 2 == 0)) return false;\n      ull d = n - 1;\n      ull s = 0;\n      while (!(d & 1)) {\n        d >>= 1;\n        s++;\n      }\n      for (auto a: v) {\n        if (a >= n) break;\n        if (!suspect(a, s, d, n)) return false;\n      }\n      return true;\n    }\n};\n\nclass combination {\n    // factorial\n    public: std::vector<mint> fact;\n    public: std::vector<mint> inv;\n\n    combination(int n) {\n      fact.resize(n + 1);\n      inv.resize(n + 1);\n      fact[0] = 1;\n      for (int i = 1; i <= n; i++) {\n        fact[i] = fact[i - 1] * i;\n      }\n      inv[n] = mint(1) / fact[n];\n      for (int i = n - 1; i >= 0; i--) {\n        inv[i] = inv[i + 1] * (i + 1);\n      }\n    }\n\n    // nCr\n    public: mint get(int n, int r) {\n      if (n < r || n < 0 || r < 0) return 0;\n      return fact[n]*inv[r]*inv[n-r];\n    }\n    // nPr\n    public: mint p(int n, int r) {\n      if (n < r || n < 0) return 0;\n      return fact[n]*inv[n-r];\n    }\n};\n\n\nconst int MAX_NODE = 10005;\n\nclass DHistogramColoring {\npublic:\n\n    // to\n    vector<mint> dp1, dp2;\n    vector<int> tree[MAX_NODE];\n    vector<P> node; // width, height\n\n    void dfs(int p, int height) {\n      int width = node[p].first;\n      height = node[p].second - height;\n\n      if (tree[p].empty()) {\n        dp1[p] = mod_pow(mint(2), height);\n        dp2[p] = dp1[p] + mod_pow(mint(2), width) - 2;\n        debug(p, width, height);\n        debug(dp1[p].x, dp2[p].x);\n        return;\n      }\n\n      int rest = width;\n      mint d1 = 1;\n      mint d2 = 1;\n      int cnt = 0;\n      for(auto e: tree[p]) {\n        dfs(e, node[p].second);\n        d1 *= dp1[e];\n        d2 *= (dp1[e] + dp2[e]);\n        rest -= node[e].first;\n        cnt++;\n      }\n\n      dp1[p] = d1 * mod_pow(mint(2), height);\n      dp2[p] = d2 * mod_pow(mint(2), rest);\n      dp2[p] -= d1*2;\n      dp2[p] += dp1[p];\n\n      //dp2[p] = (d2 - d1) * mod_pow(mint(2), rest);\n      //dp2[p] += d1 * (mod_pow(mint(2), rest+cnt)-2);\n      //dp2[p] += dp1[p];\n    }\n\n    void solve(istream& cin, ostream& cout) {\n      SPEED;\n      int n; cin >> n;\n      dp1.resize(MAX_NODE);\n      dp2.resize(MAX_NODE);\n      vector<int> h(n);\n      rep(i, n) {\n        cin >> h[i];\n      }\n\n      stack<P> st; // pos, height\n      vector<int> child(n, -1);\n      for(int i=0; i<n; i++) {\n        if (st.empty()) {\n          st.emplace(i, h[i]);\n          continue;\n        }\n\n        int left = i;\n        while(!st.empty() && st.top().second > h[i]) {\n          left = st.top().first;\n          int right = i;\n          int height = st.top().second;\n          // rectangle\n          set<int> ch;\n          for(int j=left; j<right; j++) {\n            if (child[j] != -1) {\n              ch.insert(child[j]);\n            }\n          }\n          for(auto e: ch) {\n            tree[node.size()].push_back(e);\n          }\n          for(int j=left; j<right; j++) {\n            child[j] = node.size();\n          }\n          node.emplace_back(right-left, height);\n          st.pop();\n        }\n\n        if (st.empty() || st.top().second < h[i]) {\n          st.emplace(left, h[i]);\n        }\n      }\n      while(!st.empty()) {\n        int left = st.top().first;\n        int right = n;\n        int height = st.top().second;\n        // rectangle\n        set<int> ch;\n        for(int j=left; j<right; j++) {\n          if (child[j] != -1) ch.insert(child[j]);\n        }\n        for(auto e: ch) {\n          tree[node.size()].push_back(e);\n        }\n        for(int j=left; j<right; j++) {\n          child[j] = node.size();\n        }\n        node.emplace_back(right-left, height);\n        st.pop();\n      }\n\n      int root = node.size()-1;\n      dfs(root, 0);\n      cout << dp2[root].x << endl;\n    }\n};\n\nsigned main() {\n  DHistogramColoring solver;\n  std::istream& in(std::cin);\n  std::ostream& out(std::cout);\n  solver.solve(in, out);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n\ntypedef long long LL;\n\nconst int N=105;\nconst int MOD=1000000007;\n\nint n,f[N][N],h[N],w[N],m;\n\nint ksm(int x,int y)\n{\n    if (y<0) return 1;\n    int ans=1;\n    while (y)\n    {\n        if (y&1) ans=(LL)ans*x%MOD;\n        x=(LL)x*x%MOD;y>>=1;\n    }\n    return ans;\n}\n\nint main()\n{\n    scanf(\"%d\",&n);\n    for (int i=1;i<=n;i++) scanf(\"%d\",&h[i]),w[++m]=h[i];\n    std::sort(w+1,w+m+1);\n    m=std::unique(w+1,w+m+1)-w-1;\n    for (int i=1;i<=n;i++) h[i]=std::lower_bound(w+1,w+m+1,h[i])-w;\n    f[0][0]=1;\n    for (int i=1;i<=n;i++)\n    {\n        for (int j=h[i]+1;j<=h[i-1];j++) (f[i][0]+=f[i-1][j]*2%MOD)%=MOD;\n        (f[i][0]+=f[i-1][0]*2%MOD)%=MOD;\n        for (int j=1;j<=h[i];j++)\n        {\n            f[i][j]=(LL)f[i-1][j]*ksm(2,w[h[i]]-w[h[i-1]])%MOD;\n            if (h[i-1]>=j) continue;\n            if (j>1) (f[i][j]+=(LL)f[i-1][0]*(ksm(2,w[j]-w[j-1])-1)%MOD*2%MOD*ksm(2,w[h[i]]-w[j])%MOD)%=MOD;\n            else (f[i][j]+=(LL)f[i-1][0]*(ksm(2,w[j])-2)%MOD*ksm(2,w[h[i]]-w[j])%MOD)%=MOD;\n        }\n    }\n    int ans=0;\n    for (int i=0;i<=m;i++) (ans+=f[n][i])%=MOD;\n    printf(\"%d\",ans);\n    return 0;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>  \n#include <algorithm>  \n#include <assert.h>\n#include <bitset>\n#include <cmath>  \n#include <complex>  \n#include <deque>  \n#include <functional>  \n#include <iostream>  \n#include <limits.h>  \n#include <map>  \n#include <math.h>  \n#include <queue>  \n#include <set>  \n#include <stdlib.h>  \n#include <string.h>  \n#include <string>  \n#include <time.h>  \n#include <unordered_map>  \n#include <unordered_set>  \n#include <vector>  \n#include <chrono>\n#include <random>\n#include <time.h>\n#include <fstream>\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue<int>\n#define pqg priority_queue<int,vector<int>,greater<int>>\n#define pb push_back\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define endl \"\\n\"\n#define all(c) begin(c),end(c)\nusing namespace std;\nint in() {int x;scanf(\"%d\",&x);return x;}\nll lin() {ll x;scanf(\"%lld\",&x);return x;}\nvoid print(vec v){for(auto e:v)cout<<e<<\" \";cout<<endl;}\nvoid print(vecll v){for(auto e:v)cout<<e<<\" \";cout<<endl;}\nvoid print(map<int,int> mp){for(auto e:mp)cout<<e.first<<\" \"<<e.second<<endl;cout<<endl;}\n\n\n#define INF 1e9+7\n#define LLINF 1e18+7\n#define N 2500000\nll MOD=1e9+7;\n\nll modpow(ll a,ll n){\n    if(n%2) return a*modpow(a*a%MOD,n/2)%MOD;\n    else if(n==0) return 1ll;\n    else modpow(a*a%MOD,n/2);\n}\n\nmain(){\n    ll n=in();\n    vecll v;\n    v.pb(1);\n    rep(i,n)v.pb(in());\n    vecll w=v;\n    sort(all(w));\n    vecll dp2;\n    dp2.pb(0);dp2.pb(0);\n    ll dp1=1;\n    map<int,int> mp;\n    vecll rev(n+2);\n    int now=1;\n    rep(i,n+1){\n        if(mp[w[i]]==0) {\n            mp[w[i]]=now;\n            rev[now]=w[i];\n            now++;\n        }\n    }\n    rep(i,n){\n        vecll newdp2(n+2);\n        int a=mp[v[i]],b=mp[v[i+1]];\n        if(v[i]<=v[i+1]){\n            rep2(j,1,a){\n                dp2[j]=(dp2[j]*modpow(2,v[i+1]-v[i]))%MOD;\n            }\n            rep2(j,a+1,b){\n                dp2.pb(dp1*2%MOD*(modpow(2,v[i+1]-rev[j-1])-modpow(2,v[i+1]-rev[j])+MOD)%MOD);\n            }\n            dp1=dp1*2%MOD;\n        }\n        else{\n            dp1=dp1*2%MOD;\n            rep2(j,b+1,a){\n                dp1=(dp1+2*dp2[j])%MOD;\n            }\n            dp2.erase(dp2.begin()+b+1,dp2.end());\n        }\n        // cout<<dp1<<\" \"; print(dp2);\n        // cout<<endl;\n        \n    }\n    ll ans=0;\n    rep(i,dp2.size())ans=(ans+dp2[i])%MOD;\n    cout<<(ans+dp1)%MOD<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author majk\n */\n\n#ifndef MAJK_LIB\n#define MAJK_LIB\n\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <fstream>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <algorithm>\n#include <numeric>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <array>\n#include <bitset>\nusing namespace std;\n\n#define x first\n#define y second\ntypedef std::pair<int,int> pii; typedef long long ll; typedef unsigned long long ull; typedef unsigned int ui; typedef pair<ui,ui> puu;\n\ntemplate <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate <typename T, typename U> std::ostream&operator<<(std::ostream&o, const pair<T,U>&p) {o << p.x << ' ' << p.y; return o;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {if(t.empty())o<<'\\n';for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\nui logceil(ll x) { return x?8*sizeof(ll)-__builtin_clzll(x):0; }\n\nnamespace std { template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}}; }\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename F> double bshd(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){l=m;}else{h=m;}}return (l+h)/2;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename F> double bsld(double l,double h,const F&f){ui r=200;while(r--){double m=(l+h)/2;if(f(m)){h=m;}else{l=m;}}return (l+h)/2;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector2<T>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector2<T>>(a,vector2<T>(b,c,t)){}};\ntemplate<typename T>class vector4:public vector<vector3<T>>{public:vector4(){} vector4(size_t a,size_t b,size_t c,size_t d,T t=T()):vector<vector3<T>>(a,vector3<T>(b,c,d,t)){}};\ntemplate<typename T>class vector5:public vector<vector4<T>>{public:vector5(){} vector5(size_t a,size_t b,size_t c,size_t d,size_t e,T t=T()):vector<vector4<T>>(a,vector4<T>(b,c,d,e,t)){}};\n\n\n#endif\n#ifndef MOD_H\n#define MOD_H\n\n\n\ntemplate <unsigned int N> class Field {\n    typedef unsigned int ui;\n    typedef unsigned long long ull;\n\tinline ui pow(ui a, ui p){ui r=1,e=a;while(p){if(p&1){r=((ull)r*e)%N;}e=((ull)e*e)%N;p>>=1;}return r;}\n\t/*extended GCD(slow):ll t=0,nt=1,r=N,nr=a;while(nr){ll q=r/nr;t-=q*nt;swap(t,nt);r-=q*nr;swap(r,nr);}assert(r<=1);return(t<0)?t+N:t;*/\n\tinline ui inv(ui a){return pow(a,N-2);}\npublic:\n    inline Field(int x = 0) : v(x<0?N+x:x) {}\n\tinline Field<N> pow(int p){return (*this)^p; }\n\tinline Field<N> operator^(int p){return {(int)pow(v,(ui)p)};}\n    inline Field<N>&operator+=(const Field<N>&o) {if (v+o.v >= N) v += o.v - N; else v += o.v; return *this; }\n    inline Field<N>&operator-=(const Field<N>&o) {if (v<o.v) v -= o.v-N; else v-=o.v; return *this; }\n    inline Field<N>&operator*=(const Field<N>&o) {v=(ull)v*o.v % N; return *this; }\n    inline Field<N>&operator/=(const Field<N>&o) { return *this*=inv(o.v); }\n    inline Field<N> operator+(const Field<N>&o) const {Field<N>r{*this};return r+=o;}\n    inline Field<N> operator-(const Field<N>&o) const {Field<N>r{*this};return r-=o;}\n    inline Field<N> operator*(const Field<N>&o) const {Field<N>r{*this};return r*=o;}\n    inline Field<N> operator/(const Field<N>&o) const {Field<N>r{*this};return r/=o;}\n    inline Field<N> operator-() {if(v) return {(int)(N-v)}; else return {0};};\n    inline Field<N>& operator++() { ++v; if (v==N) v=0; return *this; }\n    inline Field<N> operator++(int) { Field<N>r{*this}; ++*this; return r; }\n    inline Field<N>& operator--() { --v; if (v==-1) v=N-1; return *this; }\n    inline Field<N> operator--(int) { Field<N>r{*this}; --*this; return r; }\n    inline bool operator==(const Field<N>&o) const { return o.v==v; }\n\tinline bool operator!=(const Field<N>&o) const { return o.v!=v; }\n\tinline explicit operator ui() const { return v; }\n\tinline static vector<Field<N>>fact(int t){vector<Field<N>>F(t+1,1);for(int i=2;i<=t;++i){F[i]=F[i-1]*i;}return F;}\n\tinline static vector<Field<N>>invfact(int t){vector<Field<N>>F(t+1,1);Field<N> X{1};for(int i=2;i<=t;++i){X=X*i;}F[t]=1/X;for(int i=t-1;i>=2;--i){F[i]=F[i+1]*(i+1);}return F;}\nprivate: ui v;\n};\ntemplate<unsigned int N>istream &operator>>(std::istream&is,Field<N>&f){unsigned int v;is>>v;f=v;return is;}\ntemplate<unsigned int N>ostream &operator<<(std::ostream&os,const Field<N>&f){return os<<(unsigned int)f;}\ntemplate<unsigned int N>Field<N> operator+(int i,const Field<N>&f){return Field<N>(i)+f;}\ntemplate<unsigned int N>Field<N> operator-(int i,const Field<N>&f){return Field<N>(i)-f;}\ntemplate<unsigned int N>Field<N> operator*(int i,const Field<N>&f){return Field<N>(i)*f;}\ntemplate<unsigned int N>Field<N> operator/(int i,const Field<N>&f){return Field<N>(i)/f;}\n\n\ntypedef Field<1000000007> FieldMod;\n\nstruct Ring {\n\ttemplate <typename T>\n\tstatic T div(T p, T q, T N) {\n\t\tT t=0,nt=1,r=N,nr=q;\n\t\twhile(nr!=0){ T q=r/nr;t-=q*nt;r-=q*nr;swap(t,nt);swap(r,nr); }\n\t\tt=(t<0)?t+N:t;\n\t\tr=(r<0)?r+N:r;\n\t\tif (gcd(p,N)%r!=0) { return 0; }\n\t\treturn (t*p/r)%N;\n\t}\n};\n#endif\n\n\nclass DHistogramColoring {\npublic:\n    void solve(istream& cin, ostream& cout) {\n        int N; cin >> N;\n        vector<int> A(N); cin >> A;\n        vector<FieldMod> D(N+1, 0);\n        D[0] = 1;\n        for (int i = 0; i <= N; ++i) {\n            int lo = A[i];\n\n            ll choices = A[i];\n            for (int j = i+1; j <= N; ++j) {\n                if (j != N) lo = min(lo, A[j]);\n\n\n                ll myChoices = choices;\n                if (i != 0) myChoices -= min(A[i-1], A[i]);\n                if (j != N) {\n                    myChoices -= min(A[j-1], A[j]);\n                    if (i != 0) myChoices += min(lo, min(A[i-1],A[j]));\n                    else myChoices++;\n                }\n\n                D[j] += D[i] * FieldMod{2}.pow(myChoices % 1000000006);\n\n                if (j != N) {\n                    choices += max(0, A[j] - A[j-1]);\n//                    lo = min(lo, A[k]);\n                }\n            }\n        }\n        cout << D[N] << '\\n';\n    }\n};\n\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tDHistogramColoring solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int MOD = 1000 * 1000 * 1000 + 7;\nconst int INF = MOD;\nconst int N = 101;\nint mod(int n) {\n    return (n % MOD + MOD) % MOD;\n}   \nint fp(int a, int p) {\n    int ans = 1, cur = a;\n    for (int i = 0; (1ll << i) <= p; ++i) {\n        if ((p >> i) & 1) ans = mod(ans * cur);\n        cur = mod(cur * cur);\n    }\n    return ans;\n}   \nvoid add(int &a, int b) {\n    a = mod(a + b);\n}\nint h[N];\nint dp[N][N];\nsigned main() {\n    #ifdef HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    #else\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    #endif\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; ++i) cin >> h[i];\n    vector <int> c;\n    for (int i = 0; i < n; ++i) c.push_back(h[i]);\n    sort(c.begin(), c.end()); \n    c.resize(unique(c.begin(), c.end()) - c.begin());\n    int r = c.size();\n    c.push_back(INF);\n    dp[0][r] = 2;\n    int p = 2;\n    for (int i = r - 1; i >= 0; --i) {\n        if (c[i] <= h[0] && c[i] > 1) {\n            int down = 1;\n            if (i) down = c[i - 1];\n            dp[0][i] = mod(fp(2, h[0] - down + 1) - p);\n            add(p, dp[0][i]);\n        }   \n    }   \n    for (int i = 0; i + 1 < n; ++i) {\n        for (int j = 0; j <= r; ++j) {\n            if (dp[i][j]) {\n                if (h[i + 1] <= h[i]) {\n                    if (c[j] <= h[i + 1]) {\n                        add(dp[i + 1][j], dp[i][j]);\n                    }\n                    else {\n                        add(dp[i + 1][r], dp[i][j] << 1);\n                    }   \n                }\n                else {\n                    if (j == r) {\n                        dp[i + 1][r] = 2;\n                        int p = 2;\n                        for (int k = r - 1; k >= 0; --k) {\n                            if (c[k] <= h[i]) break;\n                            if (c[k] <= h[i + 1]) {\n                                int down = 1;\n                                if (k) down = c[k - 1];\n                                dp[i + 1][k] = mod(fp(2, h[i + 1] - down + 1) - p);\n                                add(p, dp[i + 1][k]);\n                            }   \n                        }   \n                        for (int k = r; k >= 0; --k) {\n                            if (c[k] <= h[i]) break;\n                            dp[i + 1][k] = mod(dp[i + 1][k] * dp[i][j]);\n                        }   \n                    }\n                    else {\n                        add(dp[i + 1][j], dp[i][j] * fp(2, h[i + 1] - h[i]));\n                    }   \n                }   \n            }   \n        }   \n    }   \n    int ans = 0;\n    for (int i = 0; i <= r; ++i) add(ans, dp[n - 1][i]);\n    cout << ans << '\\n';\n}   "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define pb push_back\n#define eb emplace_back\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n#define __builtin_popcount __builtin_popcountll\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\n    os<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\n    os<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const map<S, T> &t) {\n    os<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nconst int INV_2 = (1 + MOD) / 2;\n\nll modpow(ll x, ll y){\n    if (y < 0) return 0;\n    ll r = 1, a = x % MOD;\n    while(y > 0){\n        if((y&1) == 1) r = (r*a) % MOD;\n        a = (a*a) % MOD;\n        y /= 2;\n    }\n    return r;\n}\ntemplate <typename T=int>\nstruct Zipper{\n    vector<T> dec;\n    unordered_map<T, int> enc;\n    Zipper(){}\n    void add(T t){dec.pb(t);}\n    size_t size(){return dec.size();}\n    void compile(){\n        sort(ALL(dec)); UNIQUE(dec);\n        REP(i, dec.size()) enc[dec[i]] = i;\n    }\n    T operator[](int i){return dec[i];}\n    int operator()(T t){return enc[t];}\n    int lb(T t){return lower_bound(ALL(dec), t) - dec.begin();}\n    int ub(T t){return upper_bound(ALL(dec), t) - dec.begin();}\n};\n\nint T, n, m;\n\nint main(int argc, char *argv[]){\n    ios::sync_with_stdio(false);\n    while(cin >> n){\n        vi d(n);\n        Zipper<int> zip;\n        REP(i, n) {\n            cin >> d[i];\n            zip.add(d[i]);\n        }\n        zip.add(1);\n        zip.compile();\n        REP(i, n) d[i] = zip(d[i]);\n        int m = zip.size();\n        vector<ll> dp(1);\n        dp[zip(1)] = 1;\n        int prv = zip(1);\n        for (int cur : d) {\n            vector<ll> nxt(cur + 1);\n            if (prv >= cur) {\n                REP(j, prv + 1) {\n                    if (cur <= j) {\n                        nxt[cur] = (nxt[cur] + dp[j] * 2) % MOD;\n                    } else {\n                        nxt[j] = (nxt[j] + dp[j]) % MOD;\n                    }\n                }\n            } else {\n                REP(j, prv) {\n                    nxt[j] = (nxt[j] + dp[j] * modpow(2, zip[cur] - zip[prv])) % MOD;\n                }\n                for(int j = prv; j <= cur; j ++) {\n                    nxt[j] = (nxt[j] + dp[prv] * 2 * (modpow(2, zip[cur] - zip[j]) +\n                            (cur == j ? 0 : MOD - modpow(2, zip[cur] - zip[j + 1]))\n                                                                 )) % MOD;\n                }\n            }\n            prv = cur;\n            swap(dp, nxt);\n        }\n        cout << accumulate(ALL(dp), 0ll) % MOD << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define CO const\n#define IN inline\ntypedef long long int64;\n\ntemplate<class T> IN T read(){\n\tT x=0,w=1;char c=getchar();\n\tfor(;!isdigit(c);c=getchar())if(c=='-') w=-w;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0';\n\treturn x*w;\n}\ntemplate<class T> IN T read(T&x){\n\treturn x=read<T>();\n}\n\nCO int mod=1e9+7,i2=(mod+1)/2;\nIN int add(int a,int b){\n\treturn (a+=b)>=mod?a-mod:a;\n}\nIN int mul(int a,int b){\n\treturn (int64)a*b%mod;\n}\nIN int fpow(int a,int b){\n\tint ans=1;\n\tfor(;b;b>>=1,a=mul(a,a))\n\t\tif(b&1) ans=mul(ans,a);\n\treturn ans;\n}\n\nCO int N=110;\nint n;\nnamespace seg{\n\tpair<int,int> val[4*N];\n\t\n\t#define lc (x<<1)\n\t#define rc (x<<1|1)\n\t#define mid ((l+r)>>1)\n\tvoid build(int x,int l,int r){\n\t\tif(l==r) {val[x]={read<int>(),l}; return;}\n\t\tbuild(lc,l,mid),build(rc,mid+1,r);\n\t\tval[x]=min(val[lc],val[rc]);\n\t}\n\tpair<int,int> query(int x,int l,int r,int ql,int qr){\n\t\tif(ql<=l and r<=qr) return val[x];\n\t\tif(qr<=mid) return query(lc,l,mid,ql,qr);\n\t\tif(ql>mid) return query(rc,mid+1,r,ql,qr);\n\t\treturn min(query(lc,l,mid,ql,qr),query(rc,mid+1,r,ql,qr));\n\t}\n\t#undef lc\n\t#undef rc\n\t#undef mid\n}\n\nint num,L[N],R[N],H[N];\nvector<int> to[N];\n\nint build(int l,int r){\n\tint x=++num;\n\tL[x]=l,R[x]=r,H[x]=seg::query(1,1,n,l,r).first;\n\tvector<int> pos;\n\tfor(int i=l;i<=r;){\n\t\tpair<int,int> v=seg::query(1,1,n,i,r);\n\t\tif(v.first>H[x]) break;\n\t\tpos.push_back(v.second);\n\t\ti=v.second+1;\n\t}\n\tpos.push_back(r+1);\n\tint last=l-1;\n\tfor(int now:pos){\n\t\tif(last+1<=now-1){\n\t\t\tto[x].push_back(build(last+1,now-1));\n\t\t\tH[to[x].back()]-=H[x];\n\t\t}\n\t\tlast=now;\n\t}\n\treturn x;\n}\n\nint F[N][2],coef=1;\n\nvoid dfs(int x){\n//\tcerr<<x<<\" \"<<L[x]<<\" \"<<R[x]<<\" H=\"<<H[x]<<endl;\n\tint len=R[x]-L[x]+1;\n\tfor(int y:to[x]) dfs(y),len-=R[y]-L[y]+1;\n\tF[x][0]=fpow(2,len),F[x][1]=2;\n\tfor(int y:to[x]){\n\t\tF[x][0]=mul(F[x][0],add(F[y][0],mul(2,F[y][1])));\n\t\tF[x][1]=mul(F[x][1],F[y][1]);\n\t}\n\tF[x][0]=add(F[x][0],mod-F[x][1]);\n\tF[x][1]=mul(F[x][1],fpow(2,H[x]-1));\n//\tcerr<<x<<\" F=\"<<F[x][0]<<\" \"<<F[x][1]<<endl;\n}\n\nint main(){\n\tread(n);\n\tseg::build(1,1,n);\n\tint root=build(1,n);\n\tdfs(root);\n\tint ans=add(F[root][0],F[root][1]);\n\tans=mul(ans,coef);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <algorithm>\n#define enter putchar('\\n')\n#define space putchar(' ')\n#define fi first\n#define se second\n#define ba 47\n#define mo 999999137\n#define mod 974711\n//#define ivorysi\n#define pii pair<int,int>\nusing namespace std;\ntypedef long long int64;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;char c = getchar();T f = 1;\n    while(c < '0' || c > '9') {\n\tif(c == '-') f = -1;\n\tc = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n\tres = res * 10 + c - '0';\n\tc = getchar();\n    }\n    res *= f;\n}\n\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {putchar('-');x = -x;}\n    if(x >= 10) out(x / 10);\n    putchar('0' + x % 10);\n}\nstruct Hash {\n    char t[20];\n    int64 val;\n    int len;\n    friend bool operator < (const Hash &a,const Hash &b) {\n\treturn a.val < b.val;\n    }\n    friend bool operator == (const Hash &a,const Hash &b) {\n\tif(a.val != b.val) return false;\n\tif(a.len != b.len) return false;\n\tfor(int i = 1 ; i <= a.len ; ++i) {\n\t    if(a.t[i] != b.t[i]) return false;\n\t}\n\treturn true;\n    }\n}B[1000005];\nint cnt;\nint64 e[55];\nstruct Mmp {\n    struct node {\n\tint next,v;\n\tint64 x;\n    }E[1000005];\n    int head[mod + 5],sumE;\n    void clear() {\n\tmemset(head,0,sizeof(head));\n\tsumE = 0;\n    }\n    void add(int64 x,int v) {\n\tint u = x % mod;\n\tE[++sumE].x = x;\n\tE[sumE].v = v;\n\tE[sumE].next = head[u];\n\thead[u] = sumE;\n    }\n    void Insert(int64 x) {\n\tint u = x % mod;\n\tfor(int i = head[u] ; i ; i = E[i].next) {\n\t    if(E[i].x == x) {E[i].v++;return;}\n\t}\n\tadd(x,1);\n    }\n    int Query(int64 x) {\n\tint u = x % mod;\n\tfor(int i = head[u]; i ; i = E[i].next) {\n\t    if(E[i].x == x) return E[i].v;\n\t}\n\treturn 0;\n    }\n}M1,M2;\nint64 Calc(char *s,int l) {\n    int64 res = 0;\n    for(int i = 1 ; i <= l ; ++i) {\n\tres += (s[i] - 'a' + 1) * e[i] % mo;\n\tres %= mo;\n    }\n    return res;\n}\nvoid Insert(char *s,int l) {\n    ++cnt;\n    for(int i = 1 ; i <= l ; ++i) B[cnt].t[i] = s[i]; \n    B[cnt].len = l;B[cnt].val = Calc(s,l);\n}\nint N;\nchar s[55];\nvoid Solve() {\n    read(N);\n    e[0] = 1;\n    for(int i = 1 ; i <= N ; ++i) e[i] = e[i - 1] * ba % mo;\n    scanf(\"%s\",s + 1);\n    char t1[25],t2[25];\n    int c1,c2;\n    for(int S = 0 ; S < (1 << N) ; ++S) {\n\tc1 = c2 = 0;\n\tint T = 0;\n\tfor(int i = 1 ; i <= N ; ++i) {\n\t    if(S >> (i - 1) & 1) t1[++c1] = s[i];\n\t    else {t2[++c2] = s[i];T |= (1 << i - 1);}\n\t}\n\tif(S > T) continue;\n\tif(c1) Insert(t1,c1);\n\tif(c2) Insert(t2,c2);\n    }\n    sort(B + 1,B + cnt + 1);\n    cnt = unique(B + 1,B + cnt + 1) - B - 1;\n    M1.clear();M2.clear();\n    for(int i = 1 ; i <= cnt ; ++i) {\n\tM1.add(B[i].val,i);\n    }\n    for(int S = 0 ; S < (1 << N) ; ++S) {\n\tc1 = c2 = 0;\n\tint T = 0;\n\tfor(int i = 1 ; i <= N ; ++i) {\n\t    if(S >> (i - 1) & 1)  t1[++c1] = s[i];\n\t    else {t2[++c2] = s[i];T |= (1 << i - 1);}\n\t}\n\tif(S > T) continue;\n\tint d1 = 0,d2 = 0;\n\tif(c1) d1 = M1.Query(Calc(t1,c1));\n\tif(c2) d2 = M1.Query(Calc(t2,c2));\n\tM2.Insert(1LL * d1 * cnt + d2);\n    }\n    int ans = 0;\n    for(int S = 0 ; S < (1 << N) ; ++S) {\n\tc1 = c2 = 0;\n\tint T = 0;\n\tfor(int i = N + 1 ; i <= 2 * N ; ++i) {\n\t    if(S >> (i - N - 1) & 1) t1[++c1] = s[i];\n\t    else {t2[++c2] = s[i];T |= (1 << i - N - 1);}\n\t}\n\tif(S > T) continue;\n\treverse(t1 + 1,t1 + c1 + 1);\n\treverse(t2 + 1,t2 + c2 + 1);\n\tint d1 = 0,d2 = 0;\n\tif(c1) d1 = M1.Query(Calc(t1,c1));\n\tif(c2) d2 = M1.Query(Calc(t2,c2));\n\tif(d1 > d2) swap(d1,d2);\n\tans += M2.Query(1LL * d1 * cnt + d2);\n    }\n    out(ans);enter;\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#else\n    freopen(\"string.in\",\"r\",stdin);\n    freopen(\"string.out\",\"w\",stdout);\n#endif\n    Solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "/*input\n10\n15 12\n13 10\n9 6\n11 8\n9 6\n11 8\n14 12\n7 6\n15 14\n9 8\n*/\n#include <bits/stdc++.h>\n#define pb push_back\n#define all(a) a.begin(), a.end()\n#define sz(a) (int)a.size()\n#define x first\n#define y second\n#define debug(...) cout << \"[\" << #__VA_ARGS__ << \": \" << __VA_ARGS__ << \"]\\n\"\n#define rd() abs((int)rng())\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int>pii;\nconst int maxn = 105;\nconst int mod = 1e9 + 7;\nmt19937 rng(chrono::high_resolution_clock::now().time_since_epoch().count());\nint n, nxt_id;\nint arr[maxn], L[maxn], R[maxn], H[maxn], C[maxn];\nvector<int>adj[maxn];\nvoid build(int lo, int hi, int p)\n{\n\tint id = ++nxt_id;\n\tif(p != 0)\n\t\tadj[p].pb(id);\n\tL[id] = lo, R[id] = hi;\n\tint mn = mod;\n\tfor(int i = lo; i <= hi; i++)\n\t\tmn = min(mn, arr[i]);\n\tH[id] = mn;\n\tfor(int i = lo; i <= hi; i++)\n\t{\n\t\tif(arr[i] > mn)\n\t\t{\n\t\t\tint j = i;\n\t\t\twhile(j + 1 <= hi && arr[j + 1] > mn)\n\t\t\t\t++j;\n\t\t\tbuild(i, j, id);\n\t\t\ti = j;\n\t\t}\n\t\telse\n\t\t\t++C[id];\n\t}\n}\nll pwr(ll a, ll pw)\n{\n\tll ret = 1;\n\twhile(pw > 0)\n\t{\n\t\tif(pw & 1)\n\t\t\tret = ret * a % mod;\n\t\ta = a * a % mod;\n\t\tpw >>= 1;\n\t}\n\treturn ret;\n}\nll dp1[maxn], dp2[maxn]; // dp1 - bottom row alternates, dp2 - total number of ways to color the histogram\nvoid dfs(int v, int p)\n{\n\tll h = H[v] - H[p];\n\tll p1 = 1, p12 = 1;\n\tfor(int to : adj[v])\n\t{\n\t\tdfs(to, v);\n\t\tp1 = p1 * dp1[to] % mod;\n\t\tp12 = p12 * (dp1[to] + dp2[to]) % mod;\n\t}\n\tdp1[v] = pwr(2, h) * p1 % mod;\n\tdp2[v] = (pwr(2, C[v]) * p12 + (pwr(2, h) - 2) * p1) % mod;\n}\nint main()\n{\n\tios_base::sync_with_stdio(false), cin.tie(0);\n\tcin >> n;\n\tfor(int i = 1; i <= n; i++)\n\t\tcin >> arr[i];\n\tbuild(1, n, 0);\n\tdfs(1, 0);\n\tcout << dp2[1] << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<vector>\n#include<cmath>\n#include<queue>\n#include<string.h>\n#include<map>\n#include<algorithm>\n#define ll long long\n#define rep(i,a,b) for(int i = a;i < b;i++)\n#define N 1000004\n#define INF 1e9+7\n\nusing namespace std;\n\nll n,h[N],mod = 1e9+7;\nll dp1[N],dp2[N]; // dp1[i] = solution for which row i is either RBRBR... or BRBRB.... dp2[i] = full solution\nvector < vector < ll > > graph(N);\npair < ll,ll > seg[4*N];\nll w[N];\n\nll expo(ll vasi,ll ek)\n{\n    if(ek == 1)\n        return vasi;\n\n    if(ek == 0)\n        return 1;\n\n    ll x = expo(vasi,ek/2);\n\n    x =  (x*x)%mod;\n\n    if(ek%2==1)\n        x = (x*vasi)%mod;\n\n    return x;\n}\n\nvoid build(ll low,ll high,ll pos)\n{\n    if(low == high)\n    {\n        seg[pos].first = h[low];\n        seg[pos].second = low;\n\n        return;\n    }\n\n    ll mid = (low + high)/2;\n\n    build(low,mid,pos*2+1);\n    build(mid+1,high,pos*2+2);\n\n    if(seg[pos*2+1].first <= seg[pos*2+2].first)\n    {\n        seg[pos] = seg[pos*2+1];\n    }\n    else\n    {\n        seg[pos] = seg[pos*2+2];\n    }\n\n    return;\n}\n\npair < ll,ll > query(ll low,ll high,ll pos,ll slow,ll shigh)\n{\n    if(low >= slow && high <= shigh)\n    {\n        return seg[pos];\n    }\n    if(low > shigh || high < slow)\n    {\n        return make_pair(INF,-1);\n    }\n\n    ll mid = (low + high) / 2;\n\n    pair < ll,ll > q1 = query(low,mid,pos*2+1,slow,shigh);\n    pair < ll,ll > q2 = query(mid+1,high,pos*2+2,slow,shigh);\n\n    if(q1.first <= q2.first)\n    {\n        return q1;\n    }\n\n    return q2;\n}\n\nvoid decompose(ll low,ll high,ll parent,ll prevval)\n{\n    if(low == high)\n    {\n        w[low] = 1;\n        graph[parent].push_back(low);\n        return;\n    }\n\n//    cout << low << \" \" << high << \" \"<< parent << \" \"<<prevval<<endl;\n\n    pair < ll,ll > cur = query(0,n-1,0,low,high);\n\n    if(cur.first == prevval)\n    {\n        w[parent]++;\n\n        if(low != cur.second)\n            decompose(low,cur.second-1,parent,cur.first);\n\n        if(high != cur.second)\n            decompose(cur.second+1,high,parent,cur.first);\n\n        return;\n    }\n\n    w[cur.second] = 1;\n    graph[parent].push_back(cur.second);\n\n    if(low != cur.second)\n        decompose(low,cur.second-1,cur.second,cur.first);\n\n    if(high != cur.second)\n        decompose(cur.second+1,high,cur.second,cur.first);\n\n    return;\n}\n\nvoid dfs(ll cur)\n{\n    cout << cur << \": \" << \"in\\n\";\n\n    rep(i,0,graph[cur].size())\n    {\n        dfs(graph[cur][i]);\n    }\n    cout << cur << \": \" << \"out\\n\";\n\n    return;\n}\n\nll calc1(ll cur,ll removed)\n{\n    if(dp1[cur])\n    {\n        return dp1[cur];\n    }\n\n    ll res = expo(2,h[cur] - removed);\n\n    rep(i,0,graph[cur].size())\n    {\n        res = (res*calc1(graph[cur][i],h[cur]))%mod;\n    }\n\n    return dp1[cur] = res;\n}\n\nll calc2(ll cur,ll removed)\n{\n    if(dp2[cur])\n    {\n        return dp2[cur];\n    }\n\n   // cout << cur << \" \" << w[cur] << endl;\n\n    ll res = expo(2,w[cur]);\n\n    rep(i,0,graph[cur].size())\n    {\n        res = (res*(calc1(graph[cur][i],h[cur]) + calc2(graph[cur][i],h[cur])))%mod;\n    }\n\n    ll res1 = (expo(2,h[cur] - removed) - 2 + mod)%mod;\n\n    rep(i,0,graph[cur].size())\n    {\n        res1 = (res1*calc1(graph[cur][i],h[cur]))%mod;\n    }\n\n    return dp2[cur] = (res+res1)%mod;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n\n    cin >> n;\n\n    rep(i,0,n)\n    {\n        cin >> h[i];\n    }\n\n    build(0,n-1,0);\n\n    decompose(0,n-1,n,-1);\n\n    cout << calc2(n,0) << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#define maxn 105\n#define R register\n#define INF 0x3f3f3f3f\nusing namespace std;\ntypedef long long lxl;\nconst lxl mod = 1e9+7;\n\ninline lxl read()\n{\n\tlxl x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9') {if(ch=='-') f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9') {x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\ninline lxl fmi(lxl a,lxl b)\n{\n\tlxl ans=1;\n\twhile(b>0)\n\t{\n\t\tif(b&1) ans=(ans*a)%mod;\n\t\ta=(a*a)%mod;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\n\nlxl n,h[maxn],H[maxn],W[maxn],X[maxn],Rm[maxn],tot;\nint d[maxn][20],lg[maxn];\nstd::vector<int> ch[maxn];\n\ninline void init()\n{\n\tlg[0]=-1;\n\tfor(R int i=1;i<=n;++i)\n\t\tlg[i]=lg[i>>1]+1;\n\tfor(R int i=1;i<=n;++i)\n\t\td[i][0]=h[i];\n\tfor(R int j=1;j<=15;++j)\n\t\tfor(R int i=1;i+(1<<(j-1))<=n;++i)\n\t\t\td[i][j]=min(d[i][j-1],d[i+(1<<(j-1))][j-1]);\n}\n\ninline int query(int l,int r)\n{\n\tint k=lg[r-l+1];\n\treturn min(d[l][k],d[r-(1<<k)+1][k]);\n}\n\ninline int build(int l,int r,int fa)\n{\n\tif(l>r) return 0;\n\tint p=++tot;\n\tint x=X[p]=query(l,r);\n\tH[p]=X[p]-X[fa];\n\tW[p]=r-l+1;\n\tint tl=l-1,tr=l-1;\n\tfor(R int i=l;i<=r;++i)\n\t{\n\t\tif(h[i]==x&&tl<tr)\n\t\t\tch[p].push_back(build(tl+1,tr,p));\n\t\tif(h[i]==x) tl=i,++Rm[p];\n\t\telse tr=i;\n\t}\n\tif(tl<tr) ch[p].push_back(build(tl+1,tr,p));\n\treturn p;\n}\n\nlxl f[maxn][2];\n\ninline void dp(int u)\n{\n\tlxl res1=1,res2=1;\n\tfor (std::vector<int>::iterator it = ch[u].begin(); it != ch[u].end(); ++it)\n\t{\n\t\tdp(*it);\n\t\tres1=(res1*f[*it][0])%mod;\n\t\tres2=(res2*(f[*it][0]*2%mod+f[*it][1]))%mod;\n\t}\n\tf[u][0]=(fmi(2,H[u])*res1)%mod;\n\tf[u][1]=(fmi(2,Rm[u])*res2%mod+(mod-2*res1)%mod)%mod;\n}\n\nint main()\n{\n\tn=read();\n\tfor(R int i=1;i<=n;++i)\n\t\th[i]=read();\n\tinit();\n\tint rt=build(1,n,0);\n\tdp(rt);\n\tprintf(\"%lld\",f[rt][1]+f[rt][0]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 1000000007;\n\nlong long modPow(long long a, long long p){\n\tif(p == 0) return 1;\n\tlong long res = modPow(a, p/2);\n\tres = (res * res) % MOD;\n\tif(p%2 == 1) res = (res * a) % MOD;\n\treturn res;\n}\n\npair<long long, long long> solve(const vector<int>& h){\n\tif(h.size() == 1){\n\t\tpair<long long, long long> res;\n\t\tres.first = modPow(2, h[0]);\n\t\tres.second = 0;\n\t\treturn res;\n\t}\n\tint minH = h[0];\n\tfor(const auto& t : h) minH = min(minH, t);\n\tlong long alt = 2;\n\tlong long any = 0;\n\tfor(int i=0;i<h.size();i++){\n\t\tif(h[i] == minH){\n\t\t\tif(i > 0) any = (2 * any + alt) % MOD;\n\t\t} else {\n\t\t\tint end = i;\n\t\t\twhile(end < h.size() && h[end] != minH) ++end;\n\t\t\tvector<int> nh(end - i);\n\t\t\tfor(int j=i;j<end;j++) nh[j-i] = h[j] - minH;\n\t\t\tif(end - i == 1){\n\t\t\t\tauto next = solve(nh);\n\t\t\t\tif(i > 0) any = ((2 * any + alt) * next.first) % MOD;\n\t\t\t\talt = (alt * next.first) % MOD;\n\t\t\t} else {\n\t\t\t\tauto next = solve(nh);\n\t\t\t\tlong long addAny = 0;\n\t\t\t\taddAny += (2 * next.first) % MOD;\n\t\t\t\taddAny += next.second % MOD;\n\t\t\t\tany = (any * addAny) % MOD;\n\t\t\t\tif(i > 0){\n\t\t\t\t\tany = (any + alt * next.first) % MOD;\n\t\t\t\t\tany = (any + alt * next.second) % MOD;\n\t\t\t\t} else {\n\t\t\t\t\tany = (any + next.second) % MOD;\n\t\t\t\t}\n\t\t\t\talt = (alt * next.first) % MOD;\n\t\t\t}\n\t\t\ti = end - 1;\n\t\t}\n\t}\n\talt = (alt * modPow(2, minH-1)) % MOD;\n\treturn make_pair(alt, any);\n}\n\nint main(){\n\tint N;\n\twhile(cin >> N){\n\t\tvector<int> h(N);\n\t\tfor(auto& t : h) cin >> t;\n\t\tauto res = solve(h);\n\t\tcout << (res.first + res.second) % MOD << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\n#include <stdlib.h>\n#include <vector>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <string.h>\n#include <stack>\n#define Endl endl\n#define mp make_pair\n#define ll long long \n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define over(A) {cout<<A<<endl;exit(0);}\n#define all(A) A.begin(),A.end()\n#define ceil(a,b) ((a-1)/b+1)\n#define srand() mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n#define rand(l,r) uniform_int_distribution<int>(l,r)(rng)\ntypedef unsigned long long ull;\nconst int inf=1039074182;\nusing namespace std;\nint n;\nint h[105];\nint res=1;\nvector <pair<pair<int,int>,int> >vec;\nint dp[105][105][2];\n\nnamespace combinatorics\n{\n\tint mod=1e9+7;\n\tinline int add(int a,int b)\n\t{\n\t\treturn (a+b)%mod;\n\t}\n\tinline int minus(int a,int b)\n\t{\n\t\treturn (a-b+mod)%mod;\n\t}\n\tinline int mutiply(int a,int b)\n\t{\n\t\treturn (1LL*a*b)%mod;\n\t}\n\tinline int fastpow(int basic,int x)\n\t{\n\t\tint res=1;\n\t\twhile(x)\n\t\t{\n\t\t\tif(x&1)\tres=mutiply(res,basic);\n\t\t\tbasic=mutiply(basic,basic);\n\t\t\tx>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tinline int inv(int x)\n\t{\n\t\treturn fastpow(x,mod-2);\n\t}\n};\nusing namespace combinatorics;\n\ninline void solve(int l,int r)\n{\n\tif(l==r) return;\n\tint mi,ma;\n\tfor(int i=l;i<r;i++)\n\t{\n\t\tmi=min(mi,h[i]);\n\t}\n\tvec.push_back({{l,r},mi-(l==0 && r==n)});\n\tfor(int i=l;i<r;i++)\n\t{\n\t\th[i]-=mi;\n\t}\n\tint last=l;\n\tfor(int i=l;i<=r;i++)\n\t{\n\t\tif(h[i]==0) solve(last,i),last=i+1;\n\t}\n}\n\ninline int way(int l,int r)\n{\n\tint res=0;\n\tfor(auto x:vec)\n\t{\n\t\tif(l<=x.first.first && r>=x.first.second) res+=x.second;\n\t}\n\treturn fastpow(2,res);\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\",\"r\",stdin);\n\tcin>>n;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcin>>h[i];\n\t}\n\tsolve(0,n);\n//\tfor(auto x:vec)\n//\t{\n//\t\tprintf(\"From %d to %d, having %d floors.\\n\",x.first.first+1,x.first.second,x.second);\n//\t}\n\tdp[0][1][0]=1;\n\tdp[0][1][1]=1;\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tfor(int j=1;j<=i+1;j++)\n\t\t{\n\t\t\tfor(int k=0;k<2;k++)\n\t\t\t{\n\t\t\t\tdp[i+1][j+1][k]=add(dp[i+1][j+1][k],dp[i][j][k]);\n\t\t\t\tdp[i+1][1][!k]=add(dp[i+1][1][!k],mutiply(dp[i][j][k],way(i-j+1,i+1)));\n\t\t\t}\n\t\t}\n\t}\n\tint res=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tdp[n-1][i][0]=mutiply(dp[n-1][i][0],way(n-i,n));\n\t\tdp[n-1][i][1]=mutiply(dp[n-1][i][1],way(n-i,n));\n\t\tres=add(res,add(dp[n-1][i][0],dp[n-1][i][1]));\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nlong long N, K;\nlong long H[100];\nvector<long long> L;\nlong long P[60];\nlong long D[101][101];\n#define MOD 1000000007LL\nlong long R;\n\nlong long pow(long long x) {\n  long long r = 1;\n  for(long long b = 0; b < 60; ++b) {\n    if((1LL << b) & x) (r *= P[b]) %= MOD;\n  }\n  return r;\n}\nint main() {\n  P[0] = 2LL;\n  for(long long i = 1; i < 60; ++i) {\n    P[i] = P[i - 1] * P[i - 1] % MOD;\n  }\n  cin >> N;\n  L.push_back(0);\n  for(long long i = 0; i < N; ++i) {\n    cin >> H[i]; L.push_back(H[i]);\n  }\n  sort(L.begin(), L.end());\n  L.erase(unique(L.begin(), L.end()), L.end());\n  K = L.size();\n  /*for(long long k = 0; k < K; ++k) {\n    cout << \"L[\" << k << \"] : \" << L[k] << endl;\n  }*/\n  long long prev_l = 0; D[0][0] = 1;\n  for(long long i = 0; i < N; ++i) {\n    long long l = lower_bound(L.begin(), L.end(), H[i]) - L.begin();\n    /*cout << \"i=\" << i\n      << \" l=\" << l << \" prev_l=\" << prev_l << endl;*/\n    if(prev_l >= l) {\n      (D[i + 1][0] += 2 * D[i][0] % MOD) %= MOD;\n      for(long long k = 1; k <= l; ++k) {\n        (D[i + 1][k] += D[i][k]) %= MOD;\n      }\n      for(long long k = l + 1; k <= prev_l; ++k) {\n        (D[i + 1][0] += 2 * D[i][k] % MOD) %= MOD;\n      }\n    } else {\n      (D[i + 1][0] += 2 * D[i][0] % MOD) %= MOD;\n      for(long long k = prev_l + 1; k <= l; ++k) {\n        (D[i + 1][k] +=\n          2\n          * (pow(L[k] - L[k - 1] - (k - 1 == 0 ? 1 : 0)) + MOD - 1) % MOD\n          * pow(L[l] - L[k]) % MOD\n          * D[i][0]) %= MOD;\n      }\n      long long C = pow(L[l] - L[prev_l]);\n      for(long long k = 1; k <= prev_l; ++k) {\n        (D[i + 1][k] += C * D[i][k] % MOD) %= MOD;\n      }\n    }\n    /*for(long long k = 0; k <= l; ++k) {\n      cout << \"  \" << \"D[][\" << k << \"]=\"\n        << D[i + 1][k] << endl;\n    }*/\n    prev_l = l;\n  }\n  for(long long k = 0; k < K; ++k) {\n    (R += D[N][k]) %= MOD;\n  }\n  cout << R << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 110\n#define ll long long\nusing namespace std;\nconst int mod=1e9+7;\nint h[maxn],a[maxn],b[maxn],sz,n;\n\nll qpow(ll a,ll x)\n{\n    ll ret=1;\n    while(x>0)\n    {\n        if(x&1) ret=ret*a%mod;\n        a=a*a%mod;\n        x>>=1;\n    }\n    return ret;\n}\nll cal(int lb,int ub)\n{\n    ll ret=qpow(2,ub+1)+mod-qpow(2,lb);\n    if(ret>=0)ret-=mod;\n    return ret;\n}\nll dp[maxn][maxn];\nvoid upd(int &x,int y)\n{\n    x=(x+y>=mod?x+y-mod:x+y);\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    h[sz++]=1;\n    for(int i=0;i<n;++i)\n    {\n        scanf(\"%d\",&a[i]);\n        h[sz++]=a[i];\n    }\n    sort(h,h+sz); sz=unique(h,h+sz)-h;\n    dp[0][0]=2;\n    for(int i=0;i<n;++i) b[i]=lower_bound(h,h+sz,a[i])-h;\n    for(int i=1;i<=b[0];++i)\n    {\n        int ub=a[0]-(h[i-1]+1)+1;\n        int lb=a[0]-(h[i])+1;\n        //printf(\"h[%d]=%d,lb=%d,ub=%d\\n\",i,h[i],lb,ub);\n        dp[0][i]=cal(lb,ub);\n    }\n\n    for(int i=1;i<n;++i)\n    {\n        dp[i][0]=dp[i-1][0]*2%mod;\n        ll t=qpow(2,max(0,a[i]-a[i-1]));\n        for(int j=1;j<=b[i];++j)\n            if(dp[i-1][j])\n                dp[i][j]=(dp[i][j]+dp[i-1][j]*t)%mod;\n        for(int j=b[i]+1;j<sz;++j)\n            if(dp[i-1][j])\n            dp[i][0]=(dp[i][0]+dp[i-1][j]*2)%mod;\n        if(b[i]>b[i-1])\n        {\n            for(int j=b[i-1]+1;j<=b[i];++j)\n            {\n                int ub=a[i]-(h[j-1]+1)+1;\n                int lb=a[i]-(h[j])+1;\n                ll ret=cal(lb,ub);\n                dp[i][j]=(dp[i][j]+dp[i-1][0]*ret)%mod;\n            }\n        }\n    }\n    int ans=0;\n    for(int i=0;i<sz;++i)\n    {\n        ans+=dp[n-1][i];\n        if(ans>=mod) ans-=mod;\n    }\n    printf(\"%d\\n\",ans);\n        //for(int j=len+1;j<sz;++j)\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nint w[110], n, D[110], Mod = 1000000007;\nint Pow(int a, long long b) {\n\tint r = 1;\n\twhile (b) {\n\t\tif (b & 1)r = 1ll * r*a%Mod;\n\t\ta = 1ll * a*a%Mod; b >>= 1;\n\t}\n\treturn r;\n}\nint main() {\n\tint i, j, k;\n\tscanf(\"%d\", &n);\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &w[i]);\n\t}\n\tD[0] = 1;\n\tw[n + 1] = 1;\n\tfor (i = 1; i <= n + 1; i++) {\n\t\tD[i] = D[i - 1] * 2 % Mod;\n\t\tfor (j = 1; j < i; j++) {\n\t\t\tint b = max(w[i], w[j - 1]), e = w[j] - 1;\n\t\t\tlong long s = 0;\n\t\t\tfor (k = j; k < i; k++) {\n\t\t\t\te = min(e, w[k] - 1);\n\t\t\t\ts += max(w[k + 1] - w[k], 0);\n\t\t\t}\n\t\t\tif (b <= e) {\n\t\t\t\tint t1 = Pow(2, w[j] - 1 - e);\n\t\t\t\tint t2 = Pow(2, e - b + 1) - 1;\n\t\t\t\tint t3 = Pow(2, s);\n\t\t\t\tD[i] = (D[i] + 4ll * D[j - 1] * t1 % Mod* t2%Mod * t3)%Mod;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", 1ll*D[n + 1]*((Mod+1)/2)%Mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// created [2019/11/18] 22:39:34\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n\nusing i32 = int32_t;\nusing i64 = int64_t;\nusing u32 = uint32_t;\nusing u64 = uint64_t;\nusing uint = unsigned int;\nusing usize = std::size_t;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\ntemplate<typename T> constexpr T popcount(const T u) { return u ? static_cast<T>(__builtin_popcountll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T log2p1(const T u) { return u ? static_cast<T>(64 - __builtin_clzll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T msbp1(const T u) { return log2p1(u); }\ntemplate<typename T> constexpr T lsbp1(const T u) { return __builtin_ffsll(u); }\ntemplate<typename T> constexpr T clog(const T u) { return u ? log2p1(u - 1) : static_cast<T>(u); }\ntemplate<typename T> constexpr bool ispow2(const T u) { return u and (static_cast<u64>(u) & static_cast<u64>(u - 1)) == 0; }\ntemplate<typename T> constexpr T ceil2(const T u) { return static_cast<T>(1) << clog(u); }\ntemplate<typename T> constexpr T floor2(const T u) { return u == 0 ? static_cast<T>(0) : static_cast<T>(1) << (log2p1(u) - 1); }\ntemplate<typename T> constexpr bool btest(const T mask, const usize ind) { return static_cast<bool>((static_cast<u64>(mask) >> ind) & static_cast<u64>(1)); }\ntemplate<typename T> void bset(T& mask, const usize ind) { mask |= (static_cast<T>(1) << ind); }\ntemplate<typename T> void breset(T& mask, const usize ind) { mask &= ~(static_cast<T>(1) << ind); }\ntemplate<typename T> void bflip(T& mask, const usize ind) { mask ^= (static_cast<T>(1) << ind); }\ntemplate<typename T> void bset(T& mask, const usize ind, const bool b) { (b ? bset(mask, ind) : breset(mask, ind)); }\ntemplate<typename T> constexpr T bcut(const T mask, const usize ind) { return ind == 0 ? static_cast<T>(0) : static_cast<T>((static_cast<u64>(mask) << (64 - ind)) >> (64 - ind)); }\ntemplate<typename T> bool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate<typename T> bool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\nconstexpr unsigned int mod                  = 1000000007;\ntemplate<typename T> constexpr T inf_v      = std::numeric_limits<T>::max() / 4;\ntemplate<typename Real> constexpr Real pi_v = Real{3.141592653589793238462643383279502884};\n\ntemplate<typename T>\nT read()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate<typename T, typename... Args>\nauto read(const usize size, Args... args)\n{\n    std::vector<decltype(read<T>(args...))> ans(size);\n    for (usize i = 0; i < size; i++) { ans[i] = read<T>(args...); }\n    return ans;\n}\ntemplate<typename... Types>\nauto reads() { return std::tuple<std::decay_t<Types>...>{read<Types>()...}; }\n#    define SHOW(...) static_cast<void>(0)\n\ntemplate<typename T>\nstd::vector<T> make_v(const usize size, const T v) { return std::vector<T>(size, v); }\ntemplate<typename... Args>\nauto make_v(const usize size, Args... args) { return std::vector<decltype(make_v(args...))>(size, make_v(args...)); }\n\n\ntemplate<typename T> T gcd(const T& a, const T& b) { return a < 0 ? gcd(-a, b) : b < 0 ? gcd(a, -b) : (a > b ? gcd(b, a) : a == 0 ? b : gcd(b % a, a)); }\ntemplate<typename T> T lcm(const T& a, const T& b) { return a / gcd(a, b) * b; }\ntemplate<typename T>\nconstexpr std::pair<T, T> extgcd(const T a, const T b)\n{\n    if (b == 0) { return std::pair<T, T>{1, 0}; }\n    const auto g = gcd(a, b), da = std::abs(b) / g;\n    const auto p = extgcd(b, a % b);\n    const auto x = (da + p.second % da) % da, y = (g - a * x) / b;\n    return {x, y};\n}\ntemplate<typename T>\nconstexpr T inverse(const T a, const T mod) { return extgcd(a, mod).first; }\ntemplate<uint mod_value, bool dynamic = false>\nclass modint_base\n{\npublic:\n    template<typename UInt = uint>\n    static std::enable_if_t<dynamic, const UInt> mod() { return mod_ref(); }\n    template<typename UInt = uint>\n    static constexpr std::enable_if_t<not dynamic, const UInt> mod() { return mod_value; }\n    template<typename UInt = uint>\n    static void set_mod(const std::enable_if_t<dynamic, const UInt> mod) { mod_ref() = mod, inv_ref() = {1, 1}; }\n    modint_base() : v{0} {}\n    modint_base(const ll val) : v{norm(static_cast<uint>(val % static_cast<ll>(mod()) + static_cast<ll>(mod())))} {}\n    modint_base(const modint_base& n) : v{n()} {}\n    explicit operator bool() const { return v != 0; }\n    bool operator!() const { return not static_cast<bool>(*this); }\n    modint_base& operator=(const modint_base& m) { return v = m(), (*this); }\n    modint_base& operator=(const ll val) { return v = norm(uint(val % static_cast<ll>(mod()) + static_cast<ll>(mod()))), (*this); }\n    friend modint_base operator+(const modint_base& m) { return m; }\n    friend modint_base operator-(const modint_base& m) { return make(norm(mod() - m.v)); }\n    friend modint_base operator+(const modint_base& m1, const modint_base& m2) { return make(norm(m1.v + m2.v)); }\n    friend modint_base operator-(const modint_base& m1, const modint_base& m2) { return make(norm(m1.v + mod() - m2.v)); }\n    friend modint_base operator*(const modint_base& m1, const modint_base& m2) { return make(static_cast<uint>(static_cast<ll>(m1.v) * static_cast<ll>(m2.v) % static_cast<ll>(mod()))); }\n    friend modint_base operator/(const modint_base& m1, const modint_base& m2) { return m1 * inv(m2.v); }\n    friend modint_base operator+(const modint_base& m, const ll val) { return modint_base{static_cast<ll>(m.v) + val}; }\n    friend modint_base operator-(const modint_base& m, const ll val) { return modint_base{static_cast<ll>(m.v) - val}; }\n    friend modint_base operator*(const modint_base& m, const ll val) { return modint_base{static_cast<ll>(m.v) * (val % static_cast<ll>(mod()))}; }\n    friend modint_base operator/(const modint_base& m, const ll val) { return modint_base{static_cast<ll>(m.v) * inv(val)}; }\n    friend modint_base operator+(const ll val, const modint_base& m) { return modint_base{static_cast<ll>(m.v) + val}; }\n    friend modint_base operator-(const ll val, const modint_base& m) { return modint_base{-static_cast<ll>(m.v) + val}; }\n    friend modint_base operator*(const ll val, const modint_base& m) { return modint_base{static_cast<ll>(m.v) * (val % static_cast<ll>(mod()))}; }\n    friend modint_base operator/(const ll val, const modint_base& m) { return modint_base{val * inv(static_cast<ll>(m.v))}; }\n    friend modint_base& operator+=(modint_base& m1, const modint_base& m2) { return m1 = m1 + m2; }\n    friend modint_base& operator-=(modint_base& m1, const modint_base& m2) { return m1 = m1 - m2; }\n    friend modint_base& operator*=(modint_base& m1, const modint_base& m2) { return m1 = m1 * m2; }\n    friend modint_base& operator/=(modint_base& m1, const modint_base& m2) { return m1 = m1 / m2; }\n    friend modint_base& operator+=(modint_base& m, const ll val) { return m = m + val; }\n    friend modint_base& operator-=(modint_base& m, const ll val) { return m = m - val; }\n    friend modint_base& operator*=(modint_base& m, const ll val) { return m = m * val; }\n    friend modint_base& operator/=(modint_base& m, const ll val) { return m = m / val; }\n    friend modint_base operator^(const modint_base& m, const ll n) { return power(m.v, n); }\n    friend modint_base& operator^=(modint_base& m, const ll n) { return m = m ^ n; }\n    friend bool operator==(const modint_base& m1, const modint_base& m2) { return m1.v == m2.v; }\n    friend bool operator!=(const modint_base& m1, const modint_base& m2) { return not(m1 == m2); }\n    friend bool operator==(const modint_base& m, const ll val) { return m.v == norm(static_cast<uint>(static_cast<ll>(mod()) + val % static_cast<ll>(mod()))); }\n    friend bool operator!=(const modint_base& m, const ll val) { return not(m == val); }\n    friend bool operator==(const ll val, const modint_base& m) { return m.v == norm(static_cast<uint>(static_cast<ll>(mod()) + val % static_cast<ll>(mod()))); }\n    friend bool operator!=(const ll val, const modint_base& m) { return not(m == val); }\n    friend std::istream& operator>>(std::istream& is, modint_base& m)\n    {\n        ll v;\n        return is >> v, m = v, is;\n    }\n    friend std::ostream& operator<<(std::ostream& os, const modint_base& m) { return os << m(); }\n    uint operator()() const { return v; }\n    static modint_base small_inv(const usize n)\n    {\n        auto& in = inv_ref();\n        if (n < in.size()) { return in[n]; }\n        for (usize i = in.size(); i <= n; i++) { in.push_back(-in[modint_base::mod() % i] * (modint_base::mod() / i)); }\n        return in.back();\n    }\n\nprivate:\n    template<typename UInt = uint>\n    static std::enable_if_t<dynamic, UInt&> mod_ref()\n    {\n        static UInt mod = 0;\n        return mod;\n    }\n    static uint norm(const uint x) { return x < mod() ? x : x - mod(); }\n    static modint_base make(const uint x)\n    {\n        modint_base m;\n        return m.v = x, m;\n    }\n    static modint_base power(modint_base x, ull n)\n    {\n        modint_base ans = 1;\n        for (; n; n >>= 1, x *= x) {\n            if (n & 1) { ans *= x; }\n        }\n        return ans;\n    }\n    static modint_base inv(const ll v) { return v < 1000000 ? small_inv(static_cast<usize>(v)) : modint_base{inverse(v, static_cast<ll>(mod()))}; }\n    static std::vector<modint_base>& inv_ref()\n    {\n        static std::vector<modint_base> in{1, 1};\n        return in;\n    }\n    uint v;\n};\ntemplate<uint mod>\nusing modint = modint_base<mod, false>;\ntemplate<uint id>\nusing dynamic_modint = modint_base<id, true>;\nint main()\n{\n    using mint   = modint<mod>;\n    const auto n = read<int>();\n    auto h       = read<ll>(n);\n    auto H       = h;\n    H.push_back(0);\n    std::sort(H.begin(), H.end());\n    H.erase(std::unique(H.begin(), H.end()), H.end());\n    const int hn = H.size();\n    std::map<ll, int> zip;\n    for (int i = 0; i < hn; i++) { zip[H[i]] = i; }\n    for (int i = 0; i < n; i++) { h[i] = zip[h[i]]; }\n    SHOW(H);\n    SHOW(h);\n    auto dp = make_v(n, hn + 1, mint(0));  // i行目まで塗って始めての連がj-1段目〜j段目に存在する\n    for (int i = 1; i <= h[0]; i++) {\n        dp[0][i] = (mint(2) ^ (H[h[0]] - (H[i - 1]))) - (mint(2) ^ (H[h[0]] - H[i])) - (i == 1 ? 1 : 0);\n    }\n    dp[0][hn] = 2;\n    SHOW(dp[0]);\n    for (int i = 1; i < n; i++) {\n        for (int j = 0; j <= hn; j++) {\n            if (j <= h[i]) {  // 模様そのまま\n                dp[i][j] += dp[i - 1][j] * (mint(2) ^ std::max(0LL, H[h[i]] - H[h[i - 1]]));\n            } else {\n                dp[i][hn] += 2 * dp[i - 1][j];\n            }\n        }\n    }\n    mint ans = 0;\n    for (int i = 0; i <= hn; i++) { ans += dp[n - 1][i]; }\n    std::cout << ans << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int LL;\ntypedef pair <LL, LL> pii;\nconst LL MOD = 1000000007LL;\nconst int MAXN = 105, INF = 1000000001;\n\nint n, h[MAXN];\n\ninline LL quickPow(LL base, int times){\n\tLL ret = 1LL;\n\twhile(times){\n\t\tif(times & 1) ret = ret * base % MOD;\n\t\tbase = base * base % MOD;\n\t\ttimes >>= 1;\n\t} return ret;\n}\npii solve(int l, int r, int b){\n\tint i, j, mn = INF; pii f, tmp;\n\tfor(i = l; i <= r; ++ i)\n\t\tif(h[i] < mn) mn = h[i];\n\tfor(i = l; i <= r; i = j + 1)\n\t\tif(h[i] > mn){\n\t\t\tfor(j = i; j < r && h[j + 1] > mn; ++ j) ;\n\t\t\ttmp = solve(i, j, mn);\n\t\t\tif(i == l) f = pii(tmp.first * 2 % MOD, tmp.second);\n\t\t\telse f = pii(tmp.first * f.first * 2 % MOD, (f.first * tmp.first * 4 + f.first * tmp.second * 2 + f.second * tmp.first * 4 + f.second * tmp.second) % MOD);\n\t\t}else{\n\t\t\tj = i;\n\t\t\tif(i == l) f = pii(1, 0);\n\t\t\telse f = pii(f.first, (f.first * 2 + f.second * 2) % MOD);\n\t\t}\n\treturn pii(f.first * quickPow(2, mn - b - 1) % MOD, f.second);\n}\nint main(){\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i <= n; ++ i)\n\t\tscanf(\"%d\", &h[i]);\n\tauto ret = solve(1, n, 0);\n\tprintf(\"%d\\n\", int((ret.first * 2 + ret.second) % MOD));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define REP(i,a,b) for(int i=(a),_end_=(b);i<=_end_;i++)\n#define DREP(i,a,b) for(int i=(a),_end_=(b);i>=_end_;i--)\n#define EREP(i,u) for(int i=start[u];i;i=e[i].next)\n#define fi first\n#define se second\n#define mkr(a,b) make_pair(a,b)\n#define SZ(A) ((int)A.size())\ntemplate<class T>inline void chkmin(T &a,T b){ if(a>b)a=b;}\ntemplate<class T>inline void chkmax(T &a,T b){ if(a<b)a=b;}\ninline void myassert(bool a,string s){ if(!a)cerr<<s<<endl,exit(0);}\ninline int read()\n{\n\tint s=0,f=1;char ch=getchar();\n\twhile(!isdigit(ch) && ch!='-')ch=getchar();\n\tif(ch=='-')ch=getchar(),f=-1;\n\twhile(isdigit(ch))s=s*10+ch-'0',ch=getchar();\n\treturn ~f?s:-s;\n}\n\nconst int maxn=120;\nconst int mod=1e9+7;\n\ninline int power(int a,int b)\n{\n\tint ans=1;\n\twhile(b)\n\t{\n\t\tif(b&1)ans=(ll)ans*a%mod;\n\t\tb>>=1;\n\t\ta=(ll)a*a%mod;\n\t}\n\treturn ans;\n}\n\nint n,h[maxn];\nint sx[maxn],tx;\n\ninline void init()\n{\n\tn=read();\n\tREP(i,1,n)h[i]=read(),sx[i]=h[i]; tx=n;\n\tsort(sx+1,sx+tx+1); tx=unique(sx+1,sx+tx+1)-sx-1;\n}\n\nint g[maxn][2];\n\ninline void doing()\n{\n\tDREP(i,tx,1)\n\t{\n\t\tint f[2]={0},empty=1;\n\t\tint mult=power(2,sx[i]-sx[i-1]-1);\n\t\tREP(j,1,n)if(h[j]>=sx[i])\n\t\t{\n\t\t\tif(h[j]>sx[i])while(j<n && h[j+1]>sx[i])++j;\n\t\t\telse g[j][0]=0,g[j][1]=1;\n\t\t\tif(empty)f[0]=g[j][0],f[1]=g[j][1]*2%mod;\n\t\t\telse {\n\t\t\t\tint tmp[2]; ;\n\t\t\t\ttmp[0]=((ll)f[0]*g[j][0]+(ll)f[1]*g[j][0]+(ll)f[0]*g[j][1]*2+(ll)f[1]*g[j][1])%mod;\n\t\t\t\ttmp[1]=((ll)f[1]*g[j][1])%mod;\n\t\t\t\tf[0]=tmp[0]; f[1]=tmp[1];\n\t\t\t}\n\t\t\tempty=0;\n\t\t\tif(j==n || h[j+1]<sx[i])\n\t\t\t{\n\t\t\t\tg[j][0]=f[0],g[j][1]=(ll)f[1]*mult%mod;\n\t\t\t}\n\t\t}else f[0]=f[1]=0,empty=1;\n\t}\n\tint ans=(g[n][0]+g[n][1])%mod;\n\tprintf(\"%d\\n\",ans);\n}\n\nint main()\n{\n\tinit();\n\tdoing();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,x,y) for (int i=(x);i<=(y);i++)\n#define ll long long\n#define inf 1000000001\n#define y1 y1___\n#define pii pair<int,int>\n#define fi first\n#define se second\nusing namespace std;\nchar gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\nll read(){\n    char ch=gc();ll x=0;int op=1;\n    for (;!isdigit(ch);ch=gc()) if (ch=='-') op=-1;\n    for (;isdigit(ch);ch=gc()) x=(x<<1)+(x<<3)+ch-'0';\n    return x*op;\n}\n#define N 105\n#define mod 1000000007\nint ksm(int x,int p){\n    int ret=1;\n    for (;p;p>>=1,x=(ll)x*x%mod) if (p&1) ret=(ll)ret*x%mod;\n    return ret;\n}\nint n,h[N];\npii solve(int l,int r,int lim){\n    int mi=inf,cnt=0;pii ret;\n    rep (i,l,r) if (h[i]<mi) mi=h[i],cnt=1;else if (h[i]==mi) cnt++;\n    if (cnt==r-l+1){\n        ret.fi=(ksm(2,r-l+1)+mod-2)%mod;\n        ret.se=ksm(2,mi-lim);\n        return ret;\n    }\n    int rest=r-l+1,s0=1,s1=1,last=0;\n    rep (i,l,r+1)\n        if (!last&&h[i]>mi) last=i;\n        else if (last&&(h[i]<=mi||i>r)){\n            rest-=i-last;\n            pii tmp=solve(last,i-1,mi);\n            s0=(ll)s0*(tmp.fi+2ll*tmp.se%mod)%mod;\n            s1=(ll)s1*(tmp.se%mod)%mod;\n            last=0;\n        }\n    s0=(s0+mod-s1)%mod;\n    ret.fi=(ll)s0*ksm(2,rest)%mod;\n    ret.fi=(ret.fi+(ll)s1*(ksm(2,rest)+mod-2)%mod)%mod;\n    ret.se=(ll)s1*ksm(2,mi-lim)%mod;\n    return ret;\n}\nint main(){\n    n=read();rep (i,1,n) h[i]=read();\n    if (n==1){\n        printf(\"%d\\n\",ksm(2,h[1]));\n        exit(0);\n    }\n    int ex=1;\n    rep (i,1,n) if (h[i]>h[i-1]&&h[i]>h[i+1]){\n        ex=(ll)ex*ksm(2,h[i]-max(h[i-1],h[i+1]))%mod;\n        h[i]=max(h[i-1],h[i+1]);\n    }\n    pii ans=solve(1,n,0);\n    printf(\"%d\",(ll)ex*(ans.fi+ans.se%mod)%mod);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <vector>\n#include <cassert>\n#include <fstream>\n#include <algorithm>\n#include <list>\n#include <random>\n#include <ctime>\n#include <cmath>\n#include <random>\n#include <bitset>\n#include <complex>\n#pragma unroll\n#pragma loop count N\n#pragma ivdep\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n#define int ll\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef pair<ld, ld> pld;\ntypedef complex<double> base;\n\n#define mmin(a, b) a = min(a, (b))\n#define mmax(a, b) a = max(a, (b))\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define ALL(a) a.begin(),a.end()\n#define sqr(x) (x) * (x)\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define cint const int &\n#define SZ(a) ((int)(a.size()))\n#define f(cnt) (((cnt) + 1) * (cnt) / 2)\n#define watch(x) cout << (#x) << \" = \" << x << endl;\n\nconst double PI = 2 * acos(0.0);\n\ntemplate<class T>\nvoid show(const set<T> &a) {\n    for (T x : a)\n        cout << x << \" \";\n    cout << endl;\n}\n\ntemplate<class T>\nvoid show(const vector<T> &a) {\n    for (T x : a)\n        cout << x << \" \";\n    cout << endl;\n}\n\nconst ll M = 1e9 + 7;\n\nll MOD(ll a) {\n    if (a >= 0) return a >= M ? a % M : a;\n    if (a <= -M) a %= M;\n    return a ? a + M : a;\n}\n\nconst int N = 109;\nconst int L = 1e6 + 7;\n\nstruct edge {\n    int u, v;\n    ll height;\n    edge(int u, int v, ll height): u(u), v(v), height(height) {\n\n    }\n\n};\nvector<edge> e;\n\nll pw(ll a, ll p) {\n    if (p < 0LL) return pw(pw(a, -p), M - 2);\n    if (!p) return 1;\n    ll ret = pw(a, p >> 1LL);\n    ret = MOD(ret * ret);\n    if (p & 1LL) ret = MOD(ret * a);\n    return ret;\n}\n\nint counter = 1;\nvi g[L];\nll len[L];\nint vert[L];\nint start[L];\nll h[N];\nll dp[2][L];\n\ninline ll get_ways(int v) {\n    vvvl dp(N, vvl(2, vl(2, 0)));\n    vector<char> must(N, 0);\n    for (int id : g[v]) {\n        int to = e[id].v;\n        for (int i = 1; i < len[to]; ++i)\n            must[i + start[to]] = 1;\n    }\n    dp[start[v]][0][0] = dp[start[v]][0][1] = 1;\n    for (int i = 1; i < len[v]; ++i) {\n        int ind = i + start[v];\n        if (must[ind]) {\n            for (int z1 : {0, 1}) for (int z2 : {0, 1})\n                dp[ind][z1][z2] = dp[ind - 1][z1][!z2];\n        } else {\n            for (int z1 : {0, 1}) for (int z2 : {0, 1}) for (int z3 : {0, 1}) {\n                int nx = z1;\n                if (z2 != z3) nx = 1;\n                dp[ind][nx][z3] = MOD(dp[ind][nx][z3] + dp[ind - 1][z1][z2]);\n            }\n        }\n    }\n    ll ret = MOD(dp[start[v] + len[v] - 1][1][0] + dp[start[v] + len[v] - 1][1][1]);\n    return ret;\n}\n\nll dfs(int v) {\n    ll dp0 = 1;\n    ll dp1 = 1;\n    ll dp2 = 0;\n    ll restlen = len[v];\n    for (int id : g[v]) {\n        int to = e[id].v;\n        dfs(to);\n        restlen -= len[to];\n        ll curgood = MOD(pw(2, e[id].height - 1) * dp[0][to]);\n        ll curbad = dp[1][to];\n        dp2 = MOD(dp2 * (curgood * 2 + curbad) + dp1 * curbad);\n        dp1 = MOD(dp1 * curgood * 2);\n        dp0 = MOD(dp0 * curgood);\n    }\n    dp[1][v] = MOD(dp2 * pw(2, restlen) + dp0 * get_ways(v));\n    dp[0][v] = MOD(2 * dp0);\n}\n\nsigned main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n\n    int n;\n    cin >> n;\n    set<ll> hs;\n    fori (i, n) {\n        cin >> h[i];\n        hs.insert(h[i]);\n    }\n    if (n == 1) {\n        cout << pw(2, h[0]);\n        return 0;\n    }\n    ll prev = 0;\n    len[counter++] = n;\n    fori (i , n)\n        vert[i] = 1;\n    int curv = 0;\n    int par = 0;\n    for (auto hi : hs) {\n        int cnt = 0;\n        fori (i, n) {\n            if (h[i] >= hi) {\n                if (!cnt) {\n                    curv = counter++;\n                    start[curv] = i;\n                    par = vert[i];\n                }\n                vert[i] = curv;\n                cnt++;\n            } else {\n                if (cnt >= 2) {\n                    len[curv] = cnt;\n                    g[par].pb(SZ(e));\n                    e.pb(edge(par, curv, hi - prev));\n                }\n                cnt = 0;\n            }\n        }\n        if (cnt >= 2) {\n            len[curv] = cnt;\n            g[par].pb(SZ(e));\n            e.pb(edge(par, curv, hi - prev));\n        }\n        prev = hi;\n    }\n    ll fre = 0;\n    fori (i, n) {\n        ll neib = 0;\n        if (i) mmax(neib, h[i - 1]);\n        if (i != n - 1) mmax(neib, h[i + 1]);\n        fre += max(0LL, h[i] - neib);\n    }\n    int id = g[1][0];\n    int vertex = e[id].v;\n    dfs(vertex);\n    ll ans = MOD(dp[0][vertex] * pw(2, e[id].height - 1) + dp[1][vertex]);\n    ans = MOD(ans * pw(2, fre));\n    cout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "/*Lower_Rating*/\n/*Ex*/\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<stack>\n#include<vector>\n#include<queue>\n#include<bitset>\n#include<set>\nusing namespace std;\n\n#define LL long long\n#define DB double\n#define MOD 1000000007\n#define Pr pair<int,int>\n#define X first\n#define Y second\n#define MAXN 200\n#define eps 1e-10\n#define INF 1000000000\n#define mem(x,p) memset(x,p,sizeof(x))\n\nLL read(){\n  LL x=0,F=1;char c=getchar();\n  while(c<'0'||c>'9'){if(c=='-')F=-1;c=getchar();}\n  while(c>='0'&&c<='9'){x=(x<<3)+(x<<1)+c-'0';c=getchar();}\n  return x*F;\n}\nint add(int a,int b){return (a+b>=MOD)?a+b-MOD:a+b;}\nint dec(int a,int b){return (a-b<0)?a-b+MOD:a-b;}\nint mul(LL a,int b){return a*b%MOD;}\nint fst_pow(int a,int b){\n    int res=1;\n    while(b){\n        if(b&1)res=mul(res,a);\n        a=mul(a,a);\n        b>>=1;\n    }return res;\n}\n\nint n,a[MAXN+5];\n\nPr solve(int l,int r,int c){\n    if(l>r)return Pr(1,0);\n    int mh=INF;\n    for(int i=l;i<=r;i++)mh=min(mh,a[i]);\n    vector<int> pos;\n    pos.push_back(l-1);\n    for(int i=l;i<=r;i++)\n    if(a[i]==mh)pos.push_back(i);\n    pos.push_back(r+1);\n    int w=pos.size()-2;\n    Pr tmp,v;tmp=Pr(1,1);\n    for(int i=0;i<pos.size()-1;i++){\n        v=solve(pos[i]+1,pos[i+1]-1,mh);\n        tmp.X=mul(tmp.X,v.X);\n        tmp.Y=mul(tmp.Y,add(v.X,v.Y));\n    }\n    return Pr(mul(tmp.X,fst_pow(2,mh-c)),add(mul(tmp.X,dec(fst_pow(2,mh-c),2)),mul(tmp.Y,fst_pow(2,w))));\n}\n\nint main(){\n    n=read();\n    for(int i=1;i<=n;i++)a[i]=read();\n    printf(\"%d\",solve(1,n,0).Y);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <utility>\n#include <tuple>\nusing namespace std;\n\nconstexpr int mod = 1000000007;\n\nint pow2(int n) {\n    // fprintf(stderr, \"pow2(%d) = \", n);\n    long ans = 1, x = 2;\n    for (; n; n >>= 1, x = x * x % mod)\n        if (n & 1)\n            ans = ans * x % mod;\n    // fprintf(stderr, \"%d\\n\", (int) ans);\n    return ans;\n}\n\npair<int, int> solve(int *bg, int *ed) {\n    int m = *min_element(bg, ed);\n    for_each(bg, ed, [m](int &x) { x -= m; });\n\n    long f = 1, s = 2;\n    int n = 0;\n    for (int *p = bg; p != ed;) {\n        if (*p) {\n            int *q = find(p, ed, 0);\n            auto pa = solve(p, q);\n            f = f * (pa.first + pa.second) % mod;\n            s = s * pa.second % mod;\n            p = q;\n        } else {\n            n++;\n            p++;\n        }\n    }\n    f = f * pow2(n) % mod;\n\n    f = (f - s + mod) % mod;\n    s = s * pow2(m - 1) % mod;\n    f = (f + s) % mod;\n\n    return make_pair(f, s);\n}\n\nint h[100];\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++)\n        scanf(\"%d\", h + i);\n    \n    printf(\"%d\\n\", solve(h, h + n).first);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\nusing namespace std;\nconst long long mod=1000000007;\n\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst long double EPS=1e-13;\nconst long double PI=acos(-1.0);\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\nlong double ABS(long double a){return max(a,-a);}\nlong long pw(long long a,long long b){\n\tlong long ret=1;\n\twhile(b){\n\t\tif(b%2)ret=ret*a%mod;\n\t\ta=a*a%mod;\n\t\tb/=2;\n\t}\n\treturn ret;\n}\nlong long dp[110][110];\nlong long dp2[110][110];\n\nint p[110];\nvoid solve(int a,int b,int c){\n\tif(dp[a][b]!=-1)return;\n\tif(a==b){\n\t\tint has=p[a]-c;\n\t\tdp[a][b]=0;\n\t\tdp2[a][b]=pw(2,has);\n\t\treturn;\n\t}\n\tint mn=mod;\n\tfor(int i=a;i<=b;i++){\n\t\tmn=min(mn,p[i]);\n\t}\n\tint left=a;\n\tvector<long long>d1;\n\tvector<long long>d2;\n\tint mc=0;\n\tfor(int i=a;i<=b;i++){\n\t\tif(mn==p[i]){\n\t\t\tmc++;\n\t\t\tif(left<i){\n\t\t\t\tsolve(left,i-1,mn);\n\t\t\t\td1.push_back(dp[left][i-1]);\n\t\t\t\td2.push_back(dp2[left][i-1]);\n\t\t\t}\n\t\t\tleft=i+1;\n\t\t}\n\t}\n\tif(left<=b){\n\t\tsolve(left,b,mn);\n\t\td1.push_back(dp[left][b]);\n\t\td2.push_back(dp2[left][b]);\n\t}\n\tlong long ks2=1;\n\tfor(int i=0;i<d2.size();i++)ks2=ks2*d2[i]%mod;\n\tdp2[a][b]=ks2*pw(2,mn-c)%mod;\n\tlong long ks1=pw(2,mc);\n\tfor(int i=0;i<d1.size();i++)ks1=ks1*(d1[i]+d2[i]*2)%mod;\n\tks1=(ks1+mod*2-ks2*2)%mod;\n\tdp[a][b]=ks1;\n}\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tfor(int i=0;i<a;i++)scanf(\"%d\",p+i);\n\tfor(int i=0;i<110;i++)for(int j=0;j<110;j++)dp[i][j]=-1;\n\tsolve(0,a-1,0);\n\tprintf(\"%lld\\n\",(dp[0][a-1]+dp2[0][a-1])%mod);\n}"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#define foreach(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\n#ifndef LOCAL\n#define cerr if(0)cout\n#endif\ntypedef long long ll;\nconst int mod=1e9+7;\n//My i/o stream\nstruct fastio\n{\n\tchar s[100000];\n\tint it,len;\n\tfastio(){it=len=0;}\n\tinline char get()\n\t{\n\t\tif(it<len)return s[it++];it=0;\n\t\tlen=fread(s,1,100000,stdin);\n\t\tif(len==0)return EOF;else return s[it++];\n\t}\n\tbool notend()\n\t{\n\t\tchar c=get();\n\t\twhile(c==' '||c=='\\n')c=get();\n\t\tif(it>0)it--;\n\t\treturn c!=EOF;\n\t}\n}_buff;\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putchar(' ')\n#define putii(x,y) puti(x),puti(y)\n#define putiii(x,y,z) putii(x,y),puti(z)\n#define putsi(x) putnum(x),putchar('\\n')\n#define putsii(x,y) puti(x),putsi(y)\n#define putsiii(x,y,z) putii(x,y),putsi(z)\ninline ll getnum()\n{\n\tll r=0;bool ng=0;char c;c=_buff.get();\n\twhile(c!='-'&&(c<'0'||c>'9'))c=_buff.get();\n\tif(c=='-')ng=1,c=_buff.get();\n\twhile(c>='0'&&c<='9')r=r*10+c-'0',c=_buff.get();\n\treturn ng?-r:r;\n}\ntemplate<class T> inline void putnum(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tregister short a[20]={},sz=0;\n\twhile(x)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1;i>=0;i--)putchar('0'+a[i]);\n}\ninline char getreal(){char c=_buff.get();while(c<=32)c=_buff.get();return c;}\nll qpow(ll x,ll k){return k==0?1:1ll*qpow(1ll*x*x%mod,k>>1)*(k&1?x:1)%mod;}\nint n,a[111];\nll w[111][111],dp[111];\nvector<pair<pair<int,int>,int> >V;\nint pw2[211];\nvoid solve(int pre,int l,int r)\n{\n\tint mn=a[l];\n\tfor(int i=l;i<=r;i++)mn=min(mn,a[i]);\n\tV.PB(MP(MP(l,r),mn-pre));\n\tfor(int i=l;i<=r;i)\n\t{\n\t\tif(a[i]==mn)i++;\n\t\telse\n\t\t{\n\t\t\tint r=i;\n\t\t\twhile(a[r]>mn)r++;\n\t\t\tsolve(mn,i,r-1);\n\t\t\ti=r;\n\t\t}\n\t}\n}\nint main()\n{\n\tgeti(n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tgeti(a[i]);\n\t}\n\tsolve(0,1,n);\n\tfor(int i=0;i<V.size();i++)pw2[i]=qpow(2,V[i].SS);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=i;j<=n;j++)\n\t\t{\n\t\t\tw[i][j]=1;\n\t\t\tfor(int k=0;k<V.size();k++)\n\t\t\t{\n\t\t\t\tif(i<=V[k].FF.FF&&V[k].FF.SS<=j)\n\t\t\t\t{\n\t\t\t\t\tw[i][j]=1ll*w[i][j]*pw2[k]%mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tw[1][n]=1ll*w[1][n]*qpow(2,mod-2)%mod;\n\tdp[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tdp[i]=0;\n\t\tfor(int j=1;j<=i;j++)\n\t\t{\n\t\t\tdp[i]=(dp[i]+1ll*w[j][i]*dp[j-1])%mod;\n\t\t}\n\t}\n\tcout<<(2ll*dp[n]%mod+mod)%mod;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define mp make_pair\nusing namespace std;\n\ntypedef pair <long long, long long> pii;\ntypedef pair <pii, long long> piii;\n\nconst int mod = 1000000007;\n\nint a[110], vis[110][110];\nvector <int> all;\n\nlong long power(int a, int b){\n\tif (b <= 0) return 1;\n\tlong long tmp = power(a, b >> 1);\n\treturn b & 1 ? tmp * tmp % mod * a % mod : tmp * tmp % mod;\n}\n\nvoid add(long long &a, long long b){\n\ta = (a + b % mod + mod) % mod;\n}\n\npiii dfs(int l, int r, int now){\n\tint last = l;\n\tint left = r - l + 1;\n\tpiii ans = mp(mp(1ll, 1ll), 1ll);\n\tvector <int> dp(r - l + 2, 0);\n\tdp[0] = 1;\n\tfor (int i = l; i <= r + 1; i++){\n\t\tif (i > r || vis[now + 1][i]){\n\t\t\tif (last > i - 1){\n\t\t\t\tlast = i + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tpiii tmp = dfs(last, i - 1, now + 1);\n\t\t\tans.fi.fi = ans.fi.fi * (tmp.fi.fi + tmp.fi.se) % mod;\n\t\t\tans.fi.se = ans.fi.se * (tmp.fi.se + tmp.fi.fi) % mod;\n\t\t\tans.se = ans.se * ((tmp.fi.fi + tmp.fi.se) * 2 + tmp.se) % mod;\n\t\t\tleft -= i - last;\n\t\t\tlast = i + 1;\n\t\t}\n\t}\n\tans.se = ans.se * power(2, left) % mod, add(ans.se, -ans.fi.fi - ans.fi.se);\n\tint cnt = all[now] - (now ? all[now - 1] : 0);\n\tif (cnt > 1){\n\t\tlong long xx = ans.fi.fi, yy = ans.fi.se;\n\t\tans.fi.fi = (xx * power(2, cnt - 2) + yy * power(2, cnt - 2)) % mod;\n\t\tans.fi.se = (xx * power(2, cnt - 2) + yy * power(2, cnt - 2)) % mod;\n\t}\n\treturn ans;\n}\n\nint main(){\n\tint n; scanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++){\n\t\tscanf(\"%d\", &a[i]);\n\t\tall.push_back(a[i]);\n\t}\n\tsort(all.begin(), all.end());\n\tall.resize(unique(all.begin(), all.end()) - all.begin());\n\tfor (int i = 0; i < all.size(); i++){ \n\t\tfor (int j = 0; j < n; j++){\n\t\t\tvis[i + 1][j] = (a[j] == all[i]);\n\t\t}\n\t}\n\tpiii ans = dfs(0, n - 1, 0);\n\tprintf(\"%lld\\n\", (ans.fi.fi + ans.fi.se + ans.se) % mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author majk\n */\n\n#ifndef MAJK_LIB\n#define MAJK_LIB\n\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <fstream>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <algorithm>\n#include <numeric>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <array>\n#include <bitset>\nusing namespace std;\n\n#define x first\n#define y second\ntypedef std::pair<int,int> pii; typedef long long ll; typedef unsigned long long ull; typedef unsigned int ui; typedef pair<ui,ui> puu;\n\ntemplate <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate <typename T, typename U> std::ostream&operator<<(std::ostream&o, const pair<T,U>&p) {o << p.x << ' ' << p.y; return o;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {if(t.empty())o<<'\\n';for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\nui logceil(ll x) { return x?8*sizeof(ll)-__builtin_clzll(x):0; }\n\nnamespace std { template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}}; }\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename F> double bshd(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){l=m;}else{h=m;}}return (l+h)/2;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename F> double bsld(double l,double h,const F&f){ui r=200;while(r--){double m=(l+h)/2;if(f(m)){h=m;}else{l=m;}}return (l+h)/2;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector2<T>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector2<T>>(a,vector2<T>(b,c,t)){}};\ntemplate<typename T>class vector4:public vector<vector3<T>>{public:vector4(){} vector4(size_t a,size_t b,size_t c,size_t d,T t=T()):vector<vector3<T>>(a,vector3<T>(b,c,d,t)){}};\ntemplate<typename T>class vector5:public vector<vector4<T>>{public:vector5(){} vector5(size_t a,size_t b,size_t c,size_t d,size_t e,T t=T()):vector<vector4<T>>(a,vector4<T>(b,c,d,e,t)){}};\n\n\n#endif\n#ifndef MOD_H\n#define MOD_H\n\n\n\ntemplate <unsigned int N> class Field {\n    typedef unsigned int ui;\n    typedef unsigned long long ull;\n\tinline ui pow(ui a, ui p){ui r=1,e=a;while(p){if(p&1){r=((ull)r*e)%N;}e=((ull)e*e)%N;p>>=1;}return r;}\n\t/*extended GCD(slow):ll t=0,nt=1,r=N,nr=a;while(nr){ll q=r/nr;t-=q*nt;swap(t,nt);r-=q*nr;swap(r,nr);}assert(r<=1);return(t<0)?t+N:t;*/\n\tinline ui inv(ui a){return pow(a,N-2);}\npublic:\n    inline Field(int x = 0) : v(x<0?N+x:x) {}\n\tinline Field<N> pow(int p){return (*this)^p; }\n\tinline Field<N> operator^(int p){return {(int)pow(v,(ui)p)};}\n    inline Field<N>&operator+=(const Field<N>&o) {if (v+o.v >= N) v += o.v - N; else v += o.v; return *this; }\n    inline Field<N>&operator-=(const Field<N>&o) {if (v<o.v) v -= o.v-N; else v-=o.v; return *this; }\n    inline Field<N>&operator*=(const Field<N>&o) {v=(ull)v*o.v % N; return *this; }\n    inline Field<N>&operator/=(const Field<N>&o) { return *this*=inv(o.v); }\n    inline Field<N> operator+(const Field<N>&o) const {Field<N>r{*this};return r+=o;}\n    inline Field<N> operator-(const Field<N>&o) const {Field<N>r{*this};return r-=o;}\n    inline Field<N> operator*(const Field<N>&o) const {Field<N>r{*this};return r*=o;}\n    inline Field<N> operator/(const Field<N>&o) const {Field<N>r{*this};return r/=o;}\n    inline Field<N> operator-() {if(v) return {(int)(N-v)}; else return {0};};\n    inline Field<N>& operator++() { ++v; if (v==N) v=0; return *this; }\n    inline Field<N> operator++(int) { Field<N>r{*this}; ++*this; return r; }\n    inline Field<N>& operator--() { --v; if (v==-1) v=N-1; return *this; }\n    inline Field<N> operator--(int) { Field<N>r{*this}; --*this; return r; }\n    inline bool operator==(const Field<N>&o) const { return o.v==v; }\n\tinline bool operator!=(const Field<N>&o) const { return o.v!=v; }\n\tinline explicit operator ui() const { return v; }\n\tinline static vector<Field<N>>fact(int t){vector<Field<N>>F(t+1,1);for(int i=2;i<=t;++i){F[i]=F[i-1]*i;}return F;}\n\tinline static vector<Field<N>>invfact(int t){vector<Field<N>>F(t+1,1);Field<N> X{1};for(int i=2;i<=t;++i){X=X*i;}F[t]=1/X;for(int i=t-1;i>=2;--i){F[i]=F[i+1]*(i+1);}return F;}\nprivate: ui v;\n};\ntemplate<unsigned int N>istream &operator>>(std::istream&is,Field<N>&f){unsigned int v;is>>v;f=v;return is;}\ntemplate<unsigned int N>ostream &operator<<(std::ostream&os,const Field<N>&f){return os<<(unsigned int)f;}\ntemplate<unsigned int N>Field<N> operator+(int i,const Field<N>&f){return Field<N>(i)+f;}\ntemplate<unsigned int N>Field<N> operator-(int i,const Field<N>&f){return Field<N>(i)-f;}\ntemplate<unsigned int N>Field<N> operator*(int i,const Field<N>&f){return Field<N>(i)*f;}\ntemplate<unsigned int N>Field<N> operator/(int i,const Field<N>&f){return Field<N>(i)/f;}\n\n\ntypedef Field<1000000007> FieldMod;\n\nstruct Ring {\n\ttemplate <typename T>\n\tstatic T div(T p, T q, T N) {\n\t\tT t=0,nt=1,r=N,nr=q;\n\t\twhile(nr!=0){ T q=r/nr;t-=q*nt;r-=q*nr;swap(t,nt);swap(r,nr); }\n\t\tt=(t<0)?t+N:t;\n\t\tr=(r<0)?r+N:r;\n\t\tif (gcd(p,N)%r!=0) { return 0; }\n\t\treturn (t*p/r)%N;\n\t}\n};\n#endif\n\n\nclass DHistogramColoring {\npublic:\n    void solve(istream& cin, ostream& cout) {\n        int N; cin >> N;\n        vector<int> A(N); cin >> A;\n        vector<FieldMod> D(N+1, 0);\n        D[0] = 1;\n        for (int i = 0; i < N; ++i) {\n            int lo = A[i];\n            if (i != 0) lo = min(lo, A[i-1]); else lo = 1;\n\n            ll choices = A[i];\n            if (i != 0) choices -= min(A[i-1], A[i]);\n\n            for (int j = i+1; j < N; ++j) {\n                lo = min(lo, A[j]);\n\n                ll myChoices = choices;\n                if (j != N) {\n                    myChoices -= min(A[j-1], A[j]);\n                    if (i != 0) myChoices += lo;\n                    else myChoices += lo;\n                }\n\n                D[j] += D[i] * FieldMod{2}.pow(myChoices % 1000000006);\n\n                choices += max(0, A[j] - A[j-1]);\n            }\n\n            D[N] += D[i] * FieldMod{2}.pow(choices % 1000000006);\n        }\n        cout << D[N] << '\\n';\n    }\n};\n\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tDHistogramColoring solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\nconst int mod=1e9+7;\n\nvoid U(auto &x,auto y){\n    x=(x+y)%mod;\n}\nll K(ll x,ll y=mod-2){\n    ll t=1;\n    for (;y;y>>=1,x=x*x%mod)\n        if (y&1) t=t*x%mod;\n    return t;\n}\n\nstruct VAL{\n    int v[2][2][2];\n}nil, one;\n\nVAL operator + (VAL a,VAL b){\n    VAL c=nil;\n    for (int la=0;la<=1;++la)\n        for (int ra=0;ra<=1;++ra)\n            for (int fa=0;fa<=1;++fa)\n                for (int lb=0;lb<=1;++lb)\n                    for (int rb=0;rb<=1;++rb)\n                        for (int fb=0;fb<=1;++fb){\n                            U(c.v[la][rb][fa|fb|ra==lb],(ll)a.v[la][ra][fa]*b.v[lb][rb][fb]);\n                        }\n    return c;\n}\n\nint n;\n\nVAL calc(vector<int>vec){\n    int mn=*min_element(vec.begin(),vec.end()), sz=vec.size();\n    VAL res=nil; int fir=1;\n    for (int i=0;i<sz;++i){\n        VAL tmp;\n        if (vec[i]==mn) tmp=one;\n        else {\n            vector<int>nex;\n            while (i<sz&&vec[i]>mn) nex.push_back(vec[i]-mn+1), ++i;\n            --i;\n            tmp=calc(nex);\n        }\n        if (fir) res=tmp, fir=0;\n        else res=res+tmp;\n    }\n    int t=mn-1;\n    if (!t) return res;\n    VAL re2=nil;\n    for (int lb=0;lb<=1;++lb)\n        for (int rb=0;rb<=1;++rb)\n            for (int fl=0;fl<=1;++fl){\n                if (!fl){\n                    for (int dif=0;dif<=1;++dif)\n                        U(re2.v[lb^dif][rb^dif][fl],res.v[lb][rb][fl]*K(2,t-1));\n                }else{\n                    int dif=t&1;\n                    U(re2.v[lb^dif][rb^dif][fl],res.v[lb][rb][fl]);\n                }\n            }\n    return re2;\n}\n\nint main(){\n    cin>>n;\n    vector<int>vec;\n    for (int i=1;i<=n;++i){\n        int x; cin>>x;\n        vec.push_back(x);\n    }\n    one.v[1][1][0]=one.v[0][0][0]=1;\n    VAL res=calc(vec);\n    int ans=0;\n    for (int lb=0;lb<=1;++lb)\n        for (int rb=0;rb<=1;++rb)\n            for (int fl=0;fl<=1;++fl)\n                U(ans,res.v[lb][rb][fl]);\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\n// mod\nconst ll MOD = 1000000007ll;\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n// floating\ntypedef double Real;\nconst Real EPS = 1e-11;\n#define EQ0(x) (abs(x)<EPS)\n#define EQ(a,b) (abs(a-b)<EPS)\ntypedef complex<Real> P;\n\nint n;\nll h[125];\n\nll modpow(ll a, ll b){\n  ll r = 1;\n  while(b){\n    if(b&1)r=r*a%MOD;\n    a=a*a%MOD;\n    b>>=1;\n  }\n  return r;\n}\n\nconst ll INV2 = (MOD+1)/2ll;\n\nll memo[125][125][125][2];\n// -> base = h[k], range = [l,r), nurikata\nll dfs(int l, int r, int k, int typ){\n  if(l>=r)return 0ll;\n  if(memo[l][r][k][typ]!=-1)return memo[l][r][k][typ];\n  int base = k==n ? 0 : h[k];\n  int top = 1<<30;\n  int topi = -1;\n  FOR(i,l,r){\n    if(h[i]<top){\n      top = h[i];\n      topi = i;\n    }\n  }\n  int topr = topi;\n  while(topr<r){\n    if(h[topr] == h[topi])topr++;\n    else break;\n  }\n  // int topl = r;\n  // while(topl>0){\n  //   if(h[topl-1] == h[topi])topl--;\n  //   else break;\n  // }\n  if(l+1==r){\n    if(typ==1){\n      // printf(\"(%d,%d,%d,%d) -> %lld\\n\", l,r,k,typ,modpow(2,top-base));\n      return memo[l][r][k][typ] = modpow(2,top-base);\n    }else{\n      // printf(\"(%d,%d,%d,%d) -> %lld\\n\", l,r,k,typ,0ll);\n      return memo[l][r][k][typ] = 0;\n    }\n  }\n  if(typ==1){\n    // kougo\n    ll ret = 0;\n    if(topi==l && topr==r){\n      ret = 1;\n    }else if(topi==l){\n      ret = dfs(topr,r,topi,1);\n    }else if(topr==r){\n      ret = dfs(l,topi,topi,1);\n    }else{\n      ret = dfs(l,topi,topi,1) * dfs(topr,r,topi,1) % MOD;\n    }\n    ret = ret * modpow(2,top-base) % MOD;\n    // printf(\"(%d,%d,%d,%d) -> %lld\\n\", l,r,k,typ,ret);\n    return memo[l][r][k][typ] = ret;\n  }else{\n    // contains conseq\n    ll ret = 0;\n    ll l0 = dfs(l,topi,topi,0);\n    ll l1 = dfs(l,topi,topi,1)*2%MOD;\n    ll r0 = dfs(topr,r,topi,0);\n    ll r1 = dfs(topr,r,topi,1)*2%MOD;\n    ll bip = modpow(2,topr-topi);\n    // printf(\"  %lld %lld %lld %lld\\n\",l0,l1,r0,r1);\n    if(topi==l && topr==r){\n      ret = (modpow(2,r-l)-2+MOD)%MOD;\n    }else if(topi == l){\n      ret = r0 * bip % MOD + r1 * (bip-1+MOD) % MOD;\n      ret %= MOD;\n    }else if(topr == r){\n      ret = l0 * bip % MOD + l1 * (bip-1+MOD) % MOD;\n      ret %= MOD;\n    }else{\n      ret += l0 * r0 % MOD * bip % MOD;\n      ret += l0 * r1 % MOD * bip % MOD;\n      ret += l1 * r0 % MOD * bip % MOD;\n      ret += l1 * r1 % MOD * (2*bip-1+MOD) % MOD * INV2 % MOD;\n      ret %= MOD;\n    }\n    // printf(\"(%d,%d,%d,%d) -> %lld\\n\", l,r,k,typ,ret);\n    return memo[l][r][k][typ] = ret;\n  }\n}\n\nint main(){\n  scanf(\"%d\",&n);\n  REP(i,n)scanf(\"%lld\",h+i);\n  REP(i,125)REP(j,125)REP(k,125)REP(l,2)memo[i][j][k][l] = -1;\n  ll ans = (dfs(0,n,n,0) + dfs(0,n,n,1)) % MOD;\n  printf(\"%lld\\n\",ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\nusing namespace std;\n\nconst int N = 105;\n\nint n, h[N];\nLL ans = 1, mod = 1e9 + 7;\nstruct node {\n\tLL x, y;\n};\n\nLL fsp(LL a, LL b) {\n\tLL rst = 1;\n\twhile(b > 0) {\n\t\tif(b&1) rst = rst*a%mod;\n\t\tb = b>>1;\n\t\ta = a*a%mod;\n\t}\n\treturn rst;\n}\n\nnode solve(int l, int r, LL up) {\n\tint cnt = 0, mi = 1e9 + 5, last = 0;\n\tnode rst;\n\tfor(int i = l; i <= r; i++)\n\t\tif(h[i] == mi) cnt++;\n\t    else if(h[i] < mi) mi = h[i], cnt = 1;\n\tif(cnt == r - l + 1) {\n\t\trst.x = (fsp(2, mi - up) + fsp(2, r - l + 1) - 2 + mod)%mod;\n\t\trst.y = fsp(2, mi - up);\n\t\treturn rst;\n\t}\n\tLL c1 = 1, c2 = 1;\n\tfor(int i = l; i <= r + 1; i++) {\n\t\tif(h[i] > mi && !last) last = i;\n\t\telse if(h[i] == mi || i > r) {\n\t\t\tif(!last) continue;\n\t\t\tnode tmp = solve(last, i - 1, mi);\n\t\t\tc1 = c1*(tmp.x + tmp.y)%mod;\n\t\t\tc2 = c2*tmp.y%mod;\n\t\t\tlast = 0;\n\t\t} \n\t}\n\tc1 = (c1*fsp(2, cnt)%mod + c2*(fsp(2, mi - up) - 2 + mod)%mod)%mod;\n\tc2 = c2*fsp(2, mi - up)%mod;\n\trst = (node) {c1, c2};\n\treturn rst;\n}\n\nint main() {\n    cin>>n;\n    for(int i = 1; i <= n; i++) \n    \tcin>>h[i];\n    for(int i = 1; i <= n; i++)\n    \tif(h[i] > max(h[i - 1], h[i + 1])) {\n    \t\tans = ans*fsp(2, h[i] - max(h[i - 1], h[i + 1]))%mod;\n            h[i] = max(h[i - 1], h[i + 1]);\n    \t}\n    node tmp = solve(1, n, 0);\n    cout<<tmp.x*ans%mod<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define lor(a,b,c) for(register int a=b;a<=c;++a)\n#define ror(a,b,c) for(register int a=c;a>=b;--a)\ntypedef long long ll;\n\nconst int MAXN=105,MAXT=MAXN<<1,INF=0x3f3f3f3f;\nconst ll MOD=1e9+7;\n\nint n,h[MAXN];\nint tot,bor[MAXT][2],son[MAXT][MAXT],top[MAXT],bot[MAXT];\nll dp1[MAXN],dp2[MAXN];\n\ntemplate <typename T> inline T read(){\n\tchar tmp=getchar(); T sum=0; bool flag=false;\n\twhile(tmp<'0'||tmp>'9'){\n\t\tif(tmp=='-') flag=true; tmp=getchar();\n\t}\n\twhile(tmp>='0'&&tmp<='9'){\n\t\tsum=(sum<<1)+(sum<<3)+tmp-'0'; tmp=getchar();\n\t}\n\treturn flag?-sum:sum;\n}\n\ntemplate <typename T> inline void inc(T &a,T b){\n\t(a+=b)>=MOD?a-=MOD:a;\n}\n\ninline ll qsm(ll a,ll b){\n\tll ans=1ll;\n\twhile(b){\n\t\tif(b&1) (ans*=a)%=MOD; (a*=a)%=MOD; b>>=1;\n\t}\n\treturn ans;\n}\n\nint main(){\n\t#ifndef ONLINE_JUDGE\n\tfreopen(\"test.in\",\"r\",stdin);\n\t#endif\n\n\tn=read<int>(); lor(i,1,n) h[i]=read<int>();\n\n\ttot=1; bor[tot][0]=1; bor[tot][1]=n;\n\tint it=tot;\n\twhile(it<=tot){\n\t\tbool same=true; int minn=h[bor[it][0]];\n\t\tlor(i,bor[it][0]+1,bor[it][1]){\n\t\t\tif(h[i]!=h[i-1]) same=false; minn=min(minn,h[i]);\n\t\t}\n\t\ttop[it]=minn;\n\t\tif(!same){\n\t\t\tint pre=-1;\n\t\t\tlor(i,bor[it][0],bor[it][1]){\n\t\t\t\tif(h[i]==minn){\n\t\t\t\t\tif(pre!=-1) ++tot,son[it][++son[it][0]]=tot,bor[tot][0]=pre,bor[tot][1]=i-1,bot[tot]=minn;\n\t\t\t\t\tpre=-1;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(pre==-1) pre=i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(pre!=-1) ++tot,son[it][++son[it][0]]=tot,bor[tot][0]=pre,bor[tot][1]=bor[it][1],bot[tot]=minn;;\n\t\t}\n\t\t++it;\n\t}\n\n\tror(k,1,tot){\n\t\tll st1=1ll,st2=1ll;\n\t\tll uncover=bor[k][1]-bor[k][0]+1,h=top[k]-bot[k];\n\t\tlor(i,1,son[k][0]){\n\t\t\tint v=son[k][i];\n\t\t\tuncover-=bor[v][1]-bor[v][0]+1;\n\t\t\t(st1*=dp1[v]+dp2[v])%=MOD;\n\t\t\t(st2*=dp1[v])%=MOD;\n\t\t}\n\t\tdp1[k]=st2*qsm(2,h)%MOD;\n\t\t(dp2[k]=qsm(2,uncover)*st1%MOD+(qsm(2,h)+MOD-2)%MOD*st2%MOD)%=MOD;\n\t}\n\n\tprintf(\"%lld\\n\",dp2[1]);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O2\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"avx,avx2,sse,sse2,ssse3,popcnt,sse4.1,sse4.2,tune=native\")\n#include<bits/stdc++.h>\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define pb push_back\nusing namespace std;\nusing ll = long long;\n//using arr = array;\nusing pi = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vpi = vector<pi>;\nusing ld = double;\nconst int maxn = 105, mod = 1e9 + 7;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint n, a[maxn];\nmap<int, int> gp[maxn][maxn], fp[maxn][maxn];\n\n//g - flipping pattern\n//f - everything else\n#define mul(x, y) ( (x) * 1ll * (y) % mod )\n\nint bp(int a, int p) {\n\tint r = 1;\n\twhile(p) {\n\t\tif(p&1) r = mul(r, a);\n\t\tp >>= 1, a = mul(a, a);\n\t}\n\treturn r;\n}\nint g(int l, int r, int w) {\n\tif(gp[l][r].count(w)) return gp[l][r][w];\n\tint mn = 1<<30;\n\tfor(int i = l; i <= r; i++) mn = min(mn, a[i]);\n\tif(mn != w) {\n\t\treturn gp[l][r][w] = mul(bp(2, mn-w), g(l, r, mn));\n\t}\n\t\n\tint ans = 1, len = 0;\n\tfor(int i = l; i <= r; i++) {\n\t\tif(a[i] == w) {\n\t\t\tif(len) ans = ans * 1ll * g(i - len, i - 1, w + 1) % mod;\n\t\t\tlen = 0;\n\t\t} else ++len;\n\t}\n\tif(len) ans = ans * 1ll * g(r + 1 - len, r, w + 1) % mod;\n\tgp[l][r][w] = ans * 2ll % mod;\n\treturn gp[l][r][w];\n}\n\nint f(int l, int r, int w) {\n\tif(fp[l][r].count(w)) return fp[l][r][w];\n\tint mn = 1<<30;\n\tfor(int i = l; i <= r; i++) mn = min(mn, a[i]);\n\tif(mn != w) {\n\t\treturn gp[l][r][w] = f(l, r, mn);\n\t}\n\t\n\tint ans = 1, len = 0;\n\tfor(int i = l; i <= r; i++) {\n\t\tif(a[i] == w) {\n\t\t\tif(len) ans = ans * 1ll * (2ll * g(i - len, i - 1, w + 1) + f(i - len, i - 1, w + 1)) % mod;\n\t\t\tans = ans * 2ll % mod;\n\t\t\tlen = 0;\n\t\t} else ++len;\n\t}\n\tif(len) ans = ans * 1ll * (2ll * g(r + 1 - len, r, w + 1) + f(r + 1 - len, r, w + 1)) % mod;\n\tfp[l][r][w] = (mod + ans - g(l, r, w)) % mod;\n\treturn fp[l][r][w];\n}\n\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin >> n;\n\tfor(int i = 0; i < n; i++) cin >> a[i];\n\tcout << (g(0, n-1, 1)+f(0, n-1, 1))%mod;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n#define fi first\n#define se second\n#define mp make_pair\n\nconst int MOD = (int)1e9 + 7;\n\nint pow(int x, int k){\n  if(k==0) return 1;\n  int p = pow(x,k/2);\n  p = (p * 1ll * p) % MOD;\n  if(k % 2) p = (p * 1ll * x) % MOD;\n  return p;\n}\n\npii solve(vector<int> hh){\n  int low = (int)1e9;\n  for(auto x : hh)\n    low = min(low, x);\n  vector<int> cur;\n  vector<pii> sols;\n  int emp = 0;\n  for(int i = 0 ; i < hh.size(); i ++ ){\n    hh[i] -= low;\n    emp += (hh[i] == 0);\n    if(hh[i] != 0) cur.push_back(hh[i]);\n    if(hh[i] == 0 || i + 1 == hh.size()){\n      if(!cur.empty()) sols.push_back(solve(cur));\n      cur.clear();\n    }\n  }\n  ll a1 = 1;\n  for(auto x : sols)\n    a1 = (a1 * 1ll * x.fi) % MOD;\n  a1 = (a1 * 1ll * pow(2,low)) % MOD;\n  ll a2 = pow(2,emp);\n  ll a3 = (pow(2,low) - 2);\n  for(auto x : sols){\n    a2 = (a2 * 1ll * (x.fi + x.se)) % MOD;\n    a3 = (a3 * 1ll * x.fi) % MOD;\n  }\n  return mp(a1, (a2+a3)%MOD);\n}\n\nint main(){\n  int n;\n  cin >> n;\n  vector<int> sol;\n  int a;\n  for(int i = 1; i <= n; i ++ ){\n    cin >> a;\n    sol.push_back(a);\n  }\n  pii res = solve(sol);\n  cout << res.se << \"\\n\";\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n    color(i,j) != color(i+1,j)\n    RBRBRB.../BRBRBR.. :  color(i,j) = color(i+1,j)\n    f[i][j] = so cach to cot 1->i, dong h[j] -> max\n    f[i][h[i]] = 2*.... (+ them x2 truong hop noi tren)\n*/\n\n\n#include <bits/stdc++.h>\n#define ll long long\n\nusing namespace std;\n\nconst int maxn = 110;\nconst int base = 1e9+7;\n\nint n,a[maxn];\nll f[maxn][maxn];\nmap<int,int> cnt;\nvector<int> h;\n\nll pw(int a,int n) {\n    if (n==0) return 1ll;\n    if (n==1) return a;\n    ll tmp = pw(a,n/2);\n    tmp = (tmp*tmp)%base;\n    if (n%2==0) return tmp;\n    return (tmp*a)%base;\n}\n\nint main() {\n   // freopen(\"in.txt\",\"r\",stdin);\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin>>n;\n    for (int i=1;i<=n;i++) {\n        cin>>a[i];\n        if (cnt[a[i]]!=0) continue;\n        h.push_back(a[i]);\n        cnt[a[i]]=1;\n    }\n    cnt.clear();\n    h.push_back(0);\n    sort(h.begin(),h.end());\n    h.erase(unique(h.begin(),h.end()),h.end());\n    for (int j=0;j<h.size();j++) cnt[h[j]]=j;\n    for (int j=0;j<h.size();j++)\n        if (h[j] == 0) f[1][j] = pw(2,a[1]);\n        else if (h[j] <= a[1]) f[1][j] = pw(2,a[1] - h[j]+1);\n    for (int i=2;i<=n;i++) {\n        if (a[i] < a[i-1]) {\n            int mi = cnt[a[i]];\n            for (int j=0;j<h.size();j++)\n                if (h[j] <= a[i])\n                    f[i][j] = (f[i-1][j] + f[i-1][mi])%base;\n        } else {\n            int mi = cnt[a[i-1]];\n            for (int j=0;j<h.size();j++) {\n                if (h[j] <= a[i-1]) f[i][j] = ((f[i-1][j] + f[i-1][mi])%base * pw(2,a[i] - a[i-1])) % base;\n                else if (h[j] <= a[i]) f[i][j] = (pw(2,a[i] - h[j]+1) * f[i-1][mi]) % base;\n            }\n        }\n    }\n    cout<<f[n][0]<<endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "//Author:xht37\n#include <bits/stdc++.h>\n\n#define ui unsigned int\n#define ll long long\n#define ul unsigned ll\n#define ld long double\n\n#define pi pair <int, int>\n#define fi first\n#define se second\n#define mp make_pair\n\n#define ls (p << 1)\n#define rs (ls | 1)\n#define md ((t[p].l + t[p].r) >> 1)\n\n#define vi vector <int>\n#define pb push_back\n#define pq priority_queue\n\n#define dbg(x) cerr << #x\" = \" << x << endl\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#define fl(x) freopen(x\".in\", \"r\", stdin), freopen(x\".out\", \"w\", stdout)\n\nusing namespace std;\n\nnamespace io {\n\tconst int SI = 1 << 21 | 1;\n\tchar IB[SI], *IS, *IT, OB[SI], *OS = OB, *OT = OS + SI - 1, c, ch[100];\n\tint f, t;\n\t#define gc() (IS == IT ? (IT = (IS = IB) + fread(IB, 1, SI, stdin), IS == IT ? EOF : *IS++) : *IS++)\n\tinline void flush() {\n\t\tfwrite(OB, 1, OS - OB, stdout), OS = OB;\n\t}\n\tinline void pc(char x) {\n\t\t*OS++ = x;\n\t\tif (OS == OT) flush();\n\t}\n\n\ttemplate <class I>\n\tinline void rd(I &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + (c & 15), c = gc());\n\t\tx *= f;\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y) {\n\t\trd(x), rd(y);\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y, I &z) {\n\t\trd(x), rd(y), rd(z);\n\t}\n\ttemplate <class I>\n\tinline void rda(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) rd(a[i]);\n\t}\n\tinline void rdc(char &c) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t}\n\tinline void rds(char *s, int &n) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (n = 0; c >= 33 && c <= 126; s[++n] = c, c = gc());\n\t\ts[n+1] = '\\0';\n\t}\n\tinline void rds(string &s) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (s.clear(); c >= 33 && c <= 126; s.pb(c), c = gc());\n\t}\n\n\ttemplate <class I>\n\tinline void print(I x, char k = '\\n') {\n\t\tif (!x) pc('0');\n\t\tif (x < 0) pc('-'), x = -x;\n\t\twhile (x) ch[++t] = x % 10 + '0', x /= 10;\n\t\twhile (t) pc(ch[t--]);\n\t\tpc(k);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y) {\n\t\tprint(x, ' '), print(y);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y, I z) {\n\t\tprint(x, ' '), print(y, ' '), print(z);\n\t}\n\ttemplate <class I>\n\tinline void printa(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) print(a[i], \" \\n\"[i==n]);\n\t}\n\tinline void printc(char c) {\n\t\tpc(c);\n\t}\n\tinline void prints(char *s, int n) {\n\t\tfor (int i = 1; i <= n; i++) pc(s[i]);\n\t\tpc('\\n');\n\t}\n\tinline void prints(string s) {\n\t\tint n = s.length();\n\t\twhile (t < n) pc(s[t++]);\n\t\tpc('\\n'), t = 0;\n\t}\n\tstruct Flush {\n\t\t~Flush() {\n\t\t\tflush();\n\t\t}\n\t} flusher;\n}\nusing io::rd;\nusing io::rda;\nusing io::rdc;\nusing io::rds;\nusing io::print;\nusing io::printa;\nusing io::printc;\nusing io::prints;\n\nconst int P = 1e9 + 7;\n\nstruct modint {\n\tint x;\n\tinline modint(int x = 0) : x(x) {}\n\tinline modint &operator = (int o) { return x = o, *this; }\n\tinline modint &operator += (modint o) { return (x += o.x) >= P && (x -= P), *this; }\n\tinline modint &operator -= (modint o) { return (x -= o.x) < 0 && (x += P), *this; }\n\tinline modint &operator *= (modint o) { return x = 1ll * x * o.x % P, *this; }\n\ttemplate <class I>\n\tinline modint &operator ^= (I b) {\n\t\tmodint a = *this, c;\n\t\tif (!~b) b = P - 2;\n\t\tc.x = 1 % P;\n\t\twhile (b) {\n\t\t\tif (b & 1) c *= a;\n\t\t\ta *= a, b >>= 1;\n\t\t}\n\t\treturn x = c.x, *this;\n\t}\n\tinline modint &operator /= (modint o) { return *this *= o ^ -1; }\n\tinline modint &operator += (int o) { return (x += o) >= P && (x -= P), *this; }\n\tinline modint &operator -= (int o) { return (x -= o) < 0 && (x += P), *this; }\n\tinline modint &operator *= (int o) { return x = 1ll * x * o % P, *this; }\n\tinline modint &operator /= (int o) { return *this *= (modint)o ^ -1; }\n\ttemplate <class I>\n\tinline friend modint operator + (modint a, I b) { return a += b; }\n\ttemplate <class I>\n\tinline friend modint operator - (modint a, I b) { return a -= b; }\n\ttemplate <class I>\n\tinline friend modint operator * (modint a, I b) { return a *= b; }\n\ttemplate <class I>\n\tinline friend modint operator ^ (modint a, I b) { return a ^= b; }\n\ttemplate <class I>\n\tinline friend modint operator / (modint a, I b) { return a /= b; }\n\tinline friend bool operator == (modint a, int b) { return a.x == b; }\n\tinline friend bool operator != (modint a, int b) { return a.x != b; }\n\tinline friend bool operator < (modint a, int b) { return a.x < b; }\n\tinline friend bool operator <= (modint a, int b) { return a.x <= b; }\n\tinline friend bool operator > (modint a, int b) { return a.x > b; }\n\tinline friend bool operator >= (modint a, int b) { return a.x >= b; }\n\tinline friend bool operator == (modint a, modint b) { return a.x == b.x; }\n\tinline friend bool operator != (modint a, modint b) { return a.x != b.x; }\n\tinline friend bool operator < (modint a, modint b) { return a.x < b.x; }\n\tinline friend bool operator <= (modint a, modint b) { return a.x <= b.x; }\n\tinline friend bool operator > (modint a, modint b) { return a.x > b.x; }\n\tinline friend bool operator >= (modint a, modint b) { return a.x >= b.x; }\n\tinline bool operator ! () { return !x; }\n\tinline modint operator - () { return x ? P - x : 0; }\n};\ninline void rd(modint &x) { rd(x.x); }\ninline void print(modint x, char k = '\\n') { print(x.x, k); }\n\n//const int NP = 1e6 + 7;\n//modint p[NP], v[NP], vp[NP];\n//inline void init(int n) {\n//  p[0] = v[0] = 1;\n//  for (int i = 1; i <= n; i++) p[i] = p[i-1] * i;\n//  vp[n] = 1 / p[n];\n//  for (int i = n; i; i--) v[i] = vp[i] * p[i-1], vp[i-1] = vp[i] * i;\n//}\n//inline modint binom(int n, int m) {\n//  return (m < 0 || n < m) ? 0 : p[n] * vp[m] * vp[n-m];\n//}\n\nconst int N = 1e5 + 7;\nint n, h[N], p[N], pl[N], pr[N], w[N];\n\nstruct DP {\n\tmodint a[2][2][2];\n\tinline DP() {\n\t\tfor (int i = 0; i < 2; i++)\n\t\t\tfor (int j = 0; j < 2; j++)\n\t\t\t\tfor (int k = 0; k < 2; k++)\n\t\t\t\t\ta[i][j][k] = 0;\n\t}\n\tinline modint (* operator [] (int i)) [2] {\n\t\treturn a[i];\n\t}\n\tinline friend DP operator + (DP a, DP b) {\n\t\tDP c;\n\t\tfor (int li = 0; li < 2; ++li)\n\t\t\tfor (int ri = 0; ri < 2; ++ri)\n\t\t\t\tfor (int lj = 0; lj < 2; ++lj)\n\t\t\t\t\tfor (int rj = 0; rj < 2; ++rj)\n\t\t\t\t\t\tfor (int lk = 0; lk < 2; ++lk)\n\t\t\t\t\t\t\tfor (int rk = 0; rk < 2; ++rk)\n\t\t\t\t\t\t\t\tc[li][rj][lk|rk|(lj==ri)] += a[li][lj][lk] * b[ri][rj][rk];\n\t\treturn c;\n\t}\n} f[N];\n\nvoid work(int o, int x) {\n\tif (w[o] == x) return;\n\tDP now;\n\tint t = (w[o] ^ x) & 1;\n\tmodint k = (modint)2 ^ (w[o] - x - 1);\n\tfor (int i = 0; i < 2; i++)\n\t\tfor (int j = 0; j < 2; j++)\n\t\t\tnow[i][j][0] = (f[o][i][j][0] + f[o][i^1][j^1][0]) * k,\n\t\t\tnow[i][j][1] = f[o][i^t][j^t][1];\n\tf[o] = now;\n}\n\nint main() {\n\trd(n), rda(h, n), iota(p + 1, p + n + 1, 1);\n\tsort(p + 1, p + n + 1, [&](int i, int j) { return h[i] > h[j]; });\n\tfor (int o = 1; o <= n; o++) {\n\t\tint i = p[o], L = i, R = i;\n\t\tDP now;\n\t\tnow[0][0][0] = now[1][1][0] = 1;\n\t\tif (pl[i-1]) L = pl[i-1], pr[L] = pl[i-1] = 0, work(L, h[i]), now = f[L] + now;\n\t\tif (pr[i+1]) R = pr[i+1], pr[i+1] = pl[R] = 0, work(i + 1, h[i]), now = f[i+1] + now;\n\t\tf[L] = now, pr[L] = R, pl[R] = L, w[L] = h[i];\n\t}\n\twork(1, 1);\n\tmodint ans;\n\tfor (int i = 0; i < 2; i++)\n\t\tfor (int j = 0; j < 2; j++)\n\t\t\tfor (int k = 0; k < 2; k++)\n\t\t\t\tans += f[1][i][j][k];\n\tprint(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <utility>\n#include <tuple>\n#include <functional>\n#include <bitset>\n#include <cassert>\n#include <complex>\n#include <stdio.h>\n#include <time.h>\n#include <numeric>\n#include <random>\n#include <unordered_map>\n#include <unordered_set>\n#define all(a) a.begin(),a.end()\n#define rep(i, n) for (ll i = 0; i < (n); i++)\n#define pb push_back\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\ntypedef complex<ld> com;\nconstexpr int inf = 1000000000;\nconstexpr ll INF = 1000000000000000010;\nconstexpr ld EPS = 1e-12;\nconstexpr ld PI = 3.141592653589793238;\ntemplate<class T, class U> inline bool chmax(T &a, const U &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T, class U> inline bool chmin(T &a, const U &b) { if (a > b) { a = b; return true; } return false; }\n\nconstexpr ll mod = 1000000007;\nconstexpr ll modsize = 0;\nvector<ll> fac(modsize);\nvector<ll> inv(modsize);\nvector<ll> facinv(modsize);\n\nvoid modcalc() {\n\tif (modsize == 0) abort();\n\tfac[0] = 1; fac[1] = 1; inv[1] = 1;\n\tfacinv[0] = 1; facinv[1] = 1;\n\tfor (ll i = 2; i < modsize; i++) {\n\t\tfac[i] = fac[i - 1] * i % mod;\n\t\tinv[i] = mod - inv[mod % i] * (mod / i) % mod;\n\t\tfacinv[i] = facinv[i - 1] * inv[i] % mod;\n\t}\n}\n\nll modinv(ll a) {\n\tif (a == 0) abort();\n\tll b = mod, u = 1, v = 0;\n\twhile (b) {\n\t\tll t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= mod;\n\tif (u < 0) u += mod;\n\treturn u;\n}\n\nll modpow(ll a, ll b) {\n\tll ans = 1;\n\ta %= mod;\n\twhile (b) {\n\t\tif (b & 1) ans = ans * a % mod;\n\t\ta = a * a % mod;\n\t\tb >>= 1;\n\t}\n\treturn ans;\n}\n\nll modcomb(ll n, ll k) {\n\tif (n < 0 || k < 0 || n < k) return 0;\n\treturn fac[n] * facinv[k] % mod * facinv[n - k] % mod;\n}\n\nll modperm(ll n, ll k) {\n\tif (n < 0 || k < 0 || n < k) return 0;\n\treturn fac[n] * facinv[n - k] % mod;\n}\n\nll modhom(ll n, ll k) {\n\tif (n < 0 || k < 0 || n == 0 && k > 0) return 0;\n\tif (n == 0 && k == 0) return 1;\n\treturn fac[n + k - 1] * facinv[k] % mod * facinv[n - 1] % mod;\n}\n\nvector<ll> a(100);\n\nP solve(ll l, ll r, ll d) {\n\tll s = inf;\n\tfor (int i = l; i < r; i++) chmin(s, a[i]);\n\tll dp1 = 1, dp2 = 2;\n\tfor (int i = l; i < r; i++) {\n\t\tif (a[i] == s) {\n\t\t\tif (i != l && a[i - 1] != s) {\n\t\t\t\tP p = solve(l, i, s);\n\t\t\t\tll pf = p.first; ll ps = p.second;\n\t\t\t\tdp1 *= (pf + ps); dp1 %= mod;\n\t\t\t\tdp2 *= ps; dp2 %= mod;\n\t\t\t}\n\t\t\tl = i + 1;\n\t\t\tdp1 *= 2; dp1 %= mod;\n\t\t}\n\t}\n\tif (l < r) {\n\t\tP p = solve(l, r, s);\n\t\tll pf = p.first; ll ps = p.second;\n\t\tdp1 *= (pf + ps); dp1 %= mod;\n\t\tdp2 *= ps; dp2 %= mod;\n\t}\n\tdp1 += dp2 * modpow(2, s - d - 1) - dp2 + mod; dp1 %= mod;\n\tdp2 *= modpow(2, s - d - 1); dp2 %= mod;\n\treturn P(dp1, dp2);\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n\n\tint n;\n\tcin >> n;\n\trep(i, n) cin >> a[i];\n\tcout << solve(0, n, 0).first << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvoid read(int &x) {\n    x=0;int f=1;char ch=getchar();\n    for(;!isdigit(ch);ch=getchar()) if(ch=='-') f=-f;\n    for(;isdigit(ch);ch=getchar()) x=x*10+ch-'0';x*=f;\n}\n\nvoid print(int x) {\n    if(x<0) putchar('-'),x=-x;\n    if(!x) return ;print(x/10),putchar(x%10+48);\n}\nvoid write(int x) {if(!x) putchar('0');else print(x);putchar('\\n');}\n\n#define lf double\n#define ll long long \n\n#define pii pair<int,int >\n#define vec vector<int >\n\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\n\n#define data asd09123jdf02i3h\n\n#define FOR(i,l,r) for(int i=l,i##_r=r;i<=i##_r;i++)\n\nconst int maxn = 1e6+10;\nconst int inf = 1e9;\nconst lf eps = 1e-8;\nconst int mod = 1e9+7;\n\nint a[maxn],n;\n\nint qpow(int a,int x) {\n    int res=1;\n    for(;x;x>>=1,a=1ll*a*a%mod) if(x&1) res=1ll*res*a%mod;\n    return res;\n}\n\npii solve(int l,int r) {\n    int mn=1e9,pre=l-1,cnt=0;\n    for(int i=l;i<=r;i++) mn=min(mn,a[i]);\n    pii ans;ans.fr=ans.sc=1;\n    for(int i=l;i<=r+1;i++) {\n        if(i!=r+1&&a[i]!=mn) continue;cnt++;\n        if(pre==i-1) {pre=i;continue;}\n        int t=1e9;\n        for(int j=pre+1;j<i;j++) t=min(t,a[j]);\n        t--;\n        pii res=solve(pre+1,i-1);\n        res.sc=1ll*res.sc*qpow(2,t-mn)%mod;\n        ans.sc=1ll*ans.sc*res.sc%mod;\n        ans.fr=1ll*ans.fr*(2ll*res.sc+res.fr)%mod;\n        pre=i;\n    }\n    cnt--;\n    ans.sc=2ll*ans.sc%mod;\n    ans.fr=1ll*ans.fr*qpow(2,cnt)%mod;\n    ans.fr=(ans.fr-ans.sc+mod)%mod;\n    // printf(\"solve :: %d %d ( %d %d ) \\n\",l,r,ans.fr,ans.sc);\n    return ans;\n}\n\nint main() {\n    read(n);for(int i=1;i<=n;i++) read(a[i]);\n    pii ans=solve(1,n);\n    int mn=1e9;\n    for(int i=1;i<=n;i++) mn=min(mn,a[i]);\n    ans.sc=1ll*ans.sc*qpow(2,mn-1)%mod;\n    write((ans.fr+ans.sc)%mod);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <string>\n#include <random>\n#include <cassert>\n#include <cstring>\n#include <chrono>\n#include <set>\n#include <map>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll MODULO = 1e9 + 7;\n\nll Pow(ll x, ll n) {\n  ll result = 1;\n  while (n > 0) {\n    if (n % 2 == 1) {\n      n--;\n      result = result * x % MODULO;\n    }\n    n /= 2;\n    x = x * x % MODULO;\n  }\n  return result;\n}\n\nint n;\nll h[102];\nll mi[102][102];\n\nmap<vector<int>, ll> memCost;\nll GetCost(int l, int r, int d) {\n  vector<int> key = {l, r, d};\n  if (memCost.count(key)) return memCost[key];\n  ll& result = memCost[key];\n  //cerr << \"l, r, d = \" << l << \" \" << r << \" \" << d << endl;\n  ll nextD = mi[l][r];\n  ll border = max(h[l - 1], h[r + 1]);\n  //cerr << \"nextD, border = \" << nextD << \" \" << border << endl;\n\n  if (d < min(border, nextD)) return result = GetCost(l, r, min(border, nextD));\n  if (border <= d && d < nextD) return result = GetCost(l, r, nextD) * Pow(2, nextD - d) % MODULO;\n\n  result = 1;\n  int left = l;\n  while (left <= r) {\n    while (left <= r && h[left] == nextD) left++;\n    if (left > r) break;\n    int right = left;\n    while (right + 1 <= r && h[right + 1] != nextD) right++;\n    result = result * GetCost(left, right, d + 1) % MODULO;\n    //cerr << \"result = \" << result << endl;\n    //cerr << \"(border < d + 1) = \" << (border < d + 1) << endl;\n    if (max(h[left - 1], h[right + 1]) < d + 1) result = result * 2 % MODULO;\n    //cerr << \"result = \" << result << endl;\n    left = right + 1;\n  }\n  return result;\n}\n\nll GetSingleCost(int l, int r) {\n  vector<int> key = {l, r};\n  if (memCost.count(key)) return memCost[key];\n  ll& result = memCost[key];\n  result = 1;\n  for (int i = l; i <= r; ++i) {\n    ll diff = h[i] - max(h[i - 1], h[i + 1]);\n    if (diff < 0) continue;\n    result = result * Pow(2, diff) % MODULO;\n  }\n  return result;\n}\n\nll ans[102][2];\nll Solve(int at, int type) {\n  if (at == n + 1) return 1;\n  ll& result = ans[at][type];\n  if (result != -1) return result;\n  result = 0;\n  if (type == 0) {\n    result = Solve(at, type ^ 1);\n    for (int r = at; r <= n; ++r) {\n      result = (result + GetSingleCost(at, r) * Solve(r + 1, type ^ 1)) % MODULO;\n    }\n    return result;\n  }\n  // type == 1\n  for (int r = at + 1; r <= n; ++r) {\n    //cerr << \" r = \" << r << endl;\n    result = (result + GetCost(at, r, 1) * Solve(r + 1, type ^ 1)) % MODULO;\n  }\n  return result;\n}\n\nint main()\n{\n  cin >> n;\n  for (int i = 0; i < n; ++i) cin >> h[i + 1];\n  for (int i = 0; i < n + 2; ++i) mi[i][i] = h[i];\n  for (int l = 0; l < n + 2; ++l) for (int r = l + 1; r < n + 2; ++r) mi[l][r] = min(mi[l][r - 1], h[r]);\n\n  //cerr << GetCost(1, 4, 1) << endl;\n//  return 0;\n//  cerr << GetCost(1, 3, 1) << endl;\n//  cerr << GetCost(2, 3, 1) << endl;\n//  cerr << endl;\n//  cerr << GetSingleCost(1, 3) << endl;\n//  cerr << GetSingleCost(1, 2) << endl;\n//  cerr << GetSingleCost(2, 3) << endl;\n//  cerr << GetSingleCost(3, 3) << endl;\n//  return 0;\n\n  memset(ans, -1, sizeof(ans));\n  ll result = Solve(1, 0) * 2 % MODULO;\n  cout << result << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#pragma comment(linker, \"/STACK:256000000\")\n#define _USE_MATH_DEFINES\n#include<iostream>\n#include<vector>\n#include<string>\n#include<stack>\n#include<algorithm>\n#include<cmath>\n#include<set>\n#include<queue>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<ctime>\n#include<cstdio>\n#include<cassert>\n#include<functional>\n\n\n\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, int> pii;\ntypedef pair<char, char> pcc;\ntypedef pair<double, double> pdd;\n\n#define show(x) cerr << x\n#define debug(x) show(#x << \": \" << (x) << endl)\n\nconst long double PI = 3.14159265358979323846;\nconst long double eps = 1e-5;\nconst int INF = numeric_limits<int>::max();\nconst ll LINF = numeric_limits<ll>::max();\nconst ll mod = 1000 * 1000 * 1000 + 7;\n\n\nll power(ll x, ll n) {\n    ll res = 1;\n    while (n) {\n        if (n & 1)\n            res = (res * x) % mod;\n        x = (x * x) % mod;\n        n /= 2;\n    }\n    return res;\n}\n\nstruct seg {\n    int l, r;\n    ll res0, res1, res2;\n\n};\n\nbool operator<(const seg& s1, const seg& s2) {\n    return s1.l < s2.l;\n}\n\nvoid solve() {\n    int n;\n    cin >> n;\n    vector<int> h(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> h[i];\n    }\n    vector<pii> p(n);\n    for (int i = 0; i < n; ++i) {\n        p[i] = make_pair(h[i], i);\n    }\n    sort(p.rbegin(), p.rend());\n    vector<seg> a;\n    vector<int> act(n, 0);\n\n    ll lh = p[0].first;\n    for (int i = 0; i < n; ++i) {\n        ll ch = p[i].first;\n        for (int j = 0; j < a.size(); ++j) {\n            a[j].res0 = (a[j].res0 * power(2, lh - ch)) % mod;\n            a[j].res1 = (a[j].res1 * power(2, lh - ch)) % mod;\n        }\n        int id = p[i].second;\n        seg s;\n        s.l = s.r = id;\n        s.res0 = s.res1 = 1;\n        s.res2 = 0;\n        act[id] = 1;\n        a.push_back(s);\n        sort(a.begin(), a.end());\n        lh = ch;\n        bool ok = 1;\n        while (ok) {\n            ok = 0;\n            for (int j = 0; j + 1 < a.size(); ++j) {\n                if (a[j].r + 1 == a[j + 1].l) {\n                    ll res0 = 0, res1 = 0, res2 = 0;\n                    if (((a[j].r - a[j].l) % 2) == 0) {\n                        res0 = (res0 + (a[j].res0 * a[j + 1].res1) % mod) % mod;\n                        res1 = (res1 + (a[j].res1 * a[j + 1].res0) % mod) % mod;\n                    }\n                    else {\n                        res0 = (res0 + (a[j].res0 * a[j + 1].res0) % mod) % mod;\n                        res1 = (res1 + (a[j].res1 * a[j + 1].res1) % mod) % mod;\n                    }\n                    res2 = (((a[j].res0 + a[j].res1 + a[j].res2) % mod) * ((a[j + 1].res0 + a[j + 1].res1 + a[j + 1].res2) % mod)) % mod;\n                    res2 = (res2 - res1 - res0 + 2 * mod) % mod;\n                    a[j].res0 = res0;\n                    a[j].res1 = res1;\n                    a[j].res2 = res2;\n                    a[j].r = a[j + 1].r;\n                    a.erase(a.begin() + j + 1);\n                    ok = 1;\n                    break;\n                }\n            }\n        }\n    }\n    cout << (((a[0].res0 + a[0].res1) * power(2, lh - 1)) % mod + a[0].res2) % mod << endl;\n    \n}\n\n//#define LOCAL\n\nint main() {\n    ios_base::sync_with_stdio(0);\n#ifdef LOCAL\n    freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n#endif\n    solve();\n\n\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\t\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <fstream>\n#include <iostream>\n#include <algorithm>\n#include <bitset>\n#include <array>\n#include <vector>\n#include <queue>\n#include <set>\n#include <cmath> // 変数名にy1が使えなくなるかも…。\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <string>\n\ntypedef __int128_t int128_t;\nstd::istream &operator>>(std::istream& input, int128_t& value) { // int128_tの入力。入力が64bitに収まる前提。\n    long long tmp; input >> tmp; value = tmp;\n    return input;\n}\nstd::ostream &operator<<(std::ostream& output, const int128_t value) { // int128_tの出力。出力が64bitに収まる前提。\n    output << (long long)value;\n    return output;\n}\n\nint128_t cal_mod(const int128_t n, const int128_t mod) {\n    // n % modを計算する。ただしmod <= 0 ならば何もしない。nが負の場合、正にして補正する。\n    if (mod <= 0) {\n        return n;\n    } else if (0 <= n) {\n        return n % mod;\n    } else {\n        int128_t tmp = (-n) / mod + 1;\n        return (n + tmp * mod) % mod;\n    }\n}\n\nint128_t pow_mod(int128_t x, int128_t n, const int128_t mod) {\n    // 累乗の計算。mod <= 0ならば余りの計算は行わない。\n    int128_t ret = 1;\n    while (n > 0) {\n        if (n & 1) { ret = cal_mod(ret * x, mod); }\n        x = cal_mod(x * x, mod);\n        n = (n >> 1);\n    }\n    return ret;\n}\n\nconst int MOD = 1e9 + 7;\nconst int MAX_H = 1e9 + 7;\nconst int MAX_N = 110;\nint N;\nint128_t h[MAX_N];\n\nint128_t s[MAX_N]; // s[i]:i番目に低い山（高さ2以上）の高さ。\nstd::map<int128_t, int> mp; // 2以上の高さに対して、何番目に低いか。\n\nint128_t dp[MAX_N][MAX_N] = {};\n// dp[i][j] : i番目の列まで塗終わり、その列で最初に現れる連続同色がs[j]の高さに収まる(s[j-1]には収まらない)塗り方の数。\n// dp[i][0] は、連続同色が現れない塗り方。\n\nint128_t calc_sub(int128_t h1, int128_t h2) {\n    // h1まで交互に塗った1つの塗り方に対して、h2までに連続塗りを含む塗り方がいくつあるか。\n    return cal_mod(pow_mod(2, h2 - h1, MOD) - 1, MOD);\n}\n\nint main(int argc, char **argv) {\n    std::cin >> N;\n    \n    for (int i = 1; i <= N; i++) {\n        std::cin >> h[i];\n    }\n\n    for (int i = 1; i <= N; i++) {\n        if (1 < h[i]) {\n            mp[h[i]] = 1;\n        }\n    }\n    int cnt = 1;\n    for (auto itr = mp.begin(); itr != mp.end(); ++itr) {\n        mp[itr->first] = cnt;\n        s[cnt] = itr->first;\n        cnt++;\n    }\n    s[0] = 1;\n    s[cnt] = MAX_H;\n    dp[0][0] = 1;\n\n    //std::cout << \"check:\" << s[0] << \" \" << s[1] << \" \" << s[2] << \" \" << s[3] << std::endl;\n\n    for (int i = 1; i <= N; i++) {\n        if (h[i] == 1) {\n            for (int j = 0; j < cnt; j++) {\n                dp[i][0] = (dp[i][0] + dp[i-1][j] * 2) % MOD;\n            }\n        } else if (i == 1 || h[i-1] == 1) {\n            dp[i][0] = dp[i-1][0] * 2;\n            for (int j = 1; s[j] <= h[i]; j++) {\n                //dp[i][j] = (dp[i-1][0] * 2 * calc_sub(s[j-1], s[j]) * pow_mod(2, h[i] - s[j], MOD)) % MOD;\n                dp[i][j] = ((dp[i-1][0] * 2) % MOD) * ((calc_sub(s[j-1], s[j]) * pow_mod(2, h[i] - s[j], MOD)) % MOD) % MOD;\n            }\n        } else {\n            dp[i][0] = dp[i-1][0] * 2;\n            if (h[i] <= h[i-1]) {\n                for (int j = 1; s[j] <= h[i-1]; j++) {\n                    if (s[j] <= h[i]) {\n                        dp[i][j] = dp[i-1][j];\n                    } else {\n                        dp[i][0] = (dp[i][0] + dp[i-1][j] * 2) % MOD;\n                    }\n                }\n            } else {\n                for (int j = 1; s[j] <= h[i]; j++) {\n                    if (s[j] <= h[i-1]) {\n                        dp[i][j] = (dp[i-1][j] * pow_mod(2, h[i] - h[i-1], MOD)) % MOD;\n                    } else {\n                        dp[i][j] = ((dp[i-1][0] * 2) % MOD) * ((calc_sub(s[j-1], s[j]) * pow_mod(2, h[i] - s[j], MOD)) % MOD) % MOD;\n                    }\n                }\n            }\n        }\n        //std::cout << \"dp:\" << dp[i][0] << \" \" << dp[i][1] << \" \" << dp[i][2] << std::endl;\n    }\n\n    int128_t ret = 0;\n    for (int j = 0; s[j] <= h[N]; j++) {\n        ret = (ret + dp[N][j]) % MOD;\n    }\n    std::cout << ret << std::endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fo(i,a,b)for(int i=a,_e=b;i<=_e;++i)\n#define add(x,y)(x=((ll)y+x)%mo)\n#define ll long long\nusing namespace std;\nconst int N=105,mo=1e9+7;\nint n,nn,v,ans;\nint h[N],w[N],h2[N],f[N][N];\nint ksm(int x,int y){\n\tint t=1;\n\tfor(;y;y>>=1,x=(ll)x*x%mo)if(y&1)t=(ll)t*x%mo;\n\treturn t;\n}\nint main(){\n\tios::sync_with_stdio(0);\n\tcin>>n;\n\tfo(i,1,n)cin>>h[i],h2[i]=h[i];\n\tsort(h2+1,h2+n+1);\n\tnn=unique(h2+1,h2+n+1)-h2-1;\n\tf[0][0]=1;\n\tfo(i,1,n){\n\t\tw[i]=lower_bound(h2+1,h2+nn+1,h[i])-h2;\n\t\tif(v=f[i-1][0]){\n\t\t\tf[i][0]=(ll)v*2%mo;\n\t\t\tif(h[i-1]<h[i]){\n\t\t\t\tfo(j,w[i-1]+1,w[i]){\n\t\t\t\t\tif(j==1)f[i][j]=(ll)2*ksm(2,h[i]-h2[1])%mo*(ksm(2,h2[1]-1)-1)%mo;\n\t\t\t\t\telse f[i][j]=(ll)v*2*ksm(2,h[i]-h2[j])%mo*(ksm(2,h2[j]-h2[j-1])-1)%mo;\n\t\t\t\t}\n\t\t\t}\t\n\t\t}\n\t\tint p;\n\t\tif(h[i-1]<h[i])p=ksm(2,h[i]-h[i-1]);\n\t\tfo(j,1,nn)if(v=f[i-1][j]){\n\t\t\tif(h[i-1]>=h[i]){\n\t\t\t\tif(j<=w[i])add(f[i][j],v);\n\t\t\t\telse add(f[i][0],v*2);\n\t\t\t}else{\n\t\t\t\tadd(f[i][j],v*p);\n\t\t\t}\n\t\t}\n\t}\n\tfo(i,0,nn)add(ans,f[n][i]);\n\tcout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N = 105;\nconst int MOD = 1000000007;\n\nint n,m,h[N],w[N];\nLL dp[N][N];\n\nint pow_(int x,int y) {///快速幂求 x的y次方\n    int ans = 1;\n    if(y > 0) {\n        while(y) {\n            if(y % 2)ans = (LL)ans * x % MOD;\n            x = (LL)x * x % MOD;\n            y /= 2;\n        }\n    }\n    return ans;\n}\n\nint main() {\n    scanf(\"%d\",&n);\n    for(int i = 1;i <= n;i ++) {\n        scanf(\"%d\",&h[i]);\n        w[++ m] = h[i];\n    }\n    sort(w + 1,w + m + 1);///高度排序\n    m = unique(w + 1,w + m + 1) - w - 1;///离散化 m是离散化后的长度\n    for(int i = 1;i <= n;i ++) {\n        h[i] = lower_bound(w + 1,w + m + 1,h[i]) - w;\n    }\n    dp[0][0]=1;\n    for(int i = 1;i <= n;i ++) {\n        for(int j = h[i] + 1;j <= h[i - 1];j ++)\n            (dp[i][0] += dp[i - 1][j] * 2 % MOD) %= MOD;\n            \n        (dp[i][0] += dp[i - 1][0] * 2 % MOD) %= MOD;///交叉或者不交叉\n        \n        int d = pow_(2,w[h[i]] - w[h[i-1]]);\n        for(int j = 1;j <= h[i];j ++) {\n            dp[i][j] = dp[i - 1][j] * d % MOD;\n        }\n        \n        for(int j = h[i - 1] + 1;j <= h[i];j ++) {///比前一列高出的部分\n            if(j > 1)(dp[i][j] += dp[i - 1][0] * (pow_(2,w[j] - w[j - 1]) - 1) % MOD * 2 % MOD * pow_(2,w[h[i]] - w[j]) % MOD) %= MOD;\n            else (dp[i][1] += dp[i - 1][0] * (pow_(2,w[1]) - 2) % MOD * pow_(2,w[h[i]] - w[1]) % MOD) %= MOD;///上一列中无重复的乘上化不超过上一列高度中有重复的\n        }\n    }\n    LL ans = 0;\n    for(int i = 0;i <= m;i++)\n        (ans += dp[n][i]) %= MOD;\n    printf(\"%lld\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pii pair<int, int>\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst int N = 110, mod = 1e9 + 7;\n\nll h[N], dp[N][N], f[N][N], y[N], t[N];\n\nint power(int a, int b)\n{\n\tif(b == 0) return 1;\n\tll res = power(a, b/2); \n\tres *= res, res %= mod;\n\tif(b & 1) res *= a, res %= mod;\n\treturn res;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tvector <int> vc; vc.pb(0);\n\n\tint n; cin >> n;\n\tfor (int i=0; i<n; i++) {\n\t\tcin >> h[i];\n\t\tvc.pb(h[i]);\n\t}\n\n\tsort(vc.begin(), vc.end());\n\tvc.resize(unique(vc.begin(), vc.end()) - vc.begin());\n\t\n\tint cnt = 0;\n\tfor (auto Y : vc)\n\t\ty[cnt ++] = Y;\n\n\tfor (int i=0; i<n; i++)\n\t\tt[i] = lower_bound(vc.begin(), vc.end(), h[i]) - vc.begin();\n\n\n\tfor (int j=0; j<t[0]; j++)\n\t{\n\t\tint y1 = y[j], y2 = y[j + 1];\n\t\tif(y2 >= y1 + 2)\n\t\t{\n\t\t\tint R = h[0] - y[j] - 2, L = h[0] - y[j + 1];\n\t\t\tdp[0][j] = power(2, R + 1) + mod - power(2, L); dp[0][j] %= mod;\n\t\t}\n\t\tint pw = max(0LL, h[0] - y[j + 1] - 1);\n\t\tf[0][j] = power(2, pw);\n\t}\n\n\tfor (int i=1; i<n; i++)\n\t\tfor (int j=0; j<t[i]; j++)\n\t\t{\n\t\t\tif (j < t[i] - 1)\n\t\t\t{\n\t\t\t\tif(j + 1 <= t[i - 1])\n\t\t\t\t{\n\t\t\t\t\tll way = dp[i - 1][j];\n\t\t\t\t\tif(h[i] > h[i - 1]) way *= power(2, h[i] - h[i - 1]);\n\t\t\t\t\tdp[i][j] = way % mod;\n\n\t\t\t\t\tbool done = 0;\n\n\t\t\t\t\tway = f[i - 1][j];\n\t\t\t\t\tif(j == t[i - 1] - 1) way *= 2, way %= mod, done = 1;\n\n\t\t\t\t\tif(h[i] > h[i - 1]) way *= power(2, h[i] - h[i - 1] - done), way %= mod;\n\t\t\t\t\tf[i][j] = way;\n\n\t\t\t\t}else\n\t\t\t\t{\n\t\t\t\t\tll way = 2LL * f[i - 1][t[i - 1] - 1] % mod;\n\t\t\t\t\tint R = h[i] - y[j] - 2, L = h[i] - y[j + 1];\n\t\t\t\t\tway *= (power(2, R + 1) + mod - power(2, L)) % mod;\n\t\t\t\t\tdp[i][j] = way % mod;\n\n\t\t\t\t\tf[i][j] = 2LL * f[i - 1][t[i - 1] - 1] % mod;\n\t\t\t\t\tf[i][j] *= power(2, h[i] - y[j + 1] - 1); f[i][j] %= mod;\n\t\t\t\t}\n\t\t\t}else\n\t\t\t{\n\t\t\t\tif(t[i - 1] >= j + 1){\n\t\t\t\t\tdp[i][j] = dp[i - 1][j];\n\t\t\t\t\tll ps = 0;\n\t\t\t\t\tfor (int k=j; k<t[i - 1]; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tps += 2LL * f[i - 1][k]; ps %= mod;\n\t\t\t\t\t\tif(k + 1 < t[i - 1]) ps += 2LL * dp[i - 1][k + 1], ps %= mod;\n\t\t\t\t\t}\n\t\t\t\t\tf[i][j] = ps;\n\t\t\t\t}else\n\t\t\t\t{\n\t\t\t\t\tll way = 2LL * f[i - 1][t[i - 1] - 1];\n\t\t\t\t\tway *= power(2, h[i] - y[j] - 1) + mod - 1; way %= mod;\n\t\t\t\t\tdp[i][j] = way;\n\n\t\t\t\t\tf[i][j] = 2LL * f[i - 1][t[i - 1] - 1] % mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\tll ans = 0;\n\tfor(int j=0; j<t[n - 1]; j++) {\n\t\tans += (2LL * dp[n - 1][j]) % mod;\n\t\tans += (2LL * f[n - 1][j]) % mod;\n\t\tans %= mod;\n\t}\n\n\tans %= mod;\n\tcout << ans << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define modulo 1000000007\n#define mod(mod_x) ((((long long)mod_x+modulo))%modulo)\n#define Inf 10000000000000000\n\nint beki(long long a,long long b,int M = modulo){\n\tint x = 1;\n\twhile(b!=0){\n\t\tif(b&1){\n\t\t\tx=((long long)x*a)%M;\n\t\t}\n\t\ta=((long long)a*a)%M;\n\t\tb>>=1;\n\t}\n\treturn x;\n}\n\npair<int,int> dfs(vector<int> h){\n\tint width = h.size();\n\tint m = 1000000004;\n\tfor(int i=0;i<h.size();i++){\n\t\tm = min(m,h[i]);\n\t}\n\tint height = m;\n\t\n\tfor(int i=0;i<h.size();i++){\n\t\th[i] -= m;\n\t}\n\t\n\tint check = 1,notcheck = 1;\n\tbool f = false;\n\tint cnt0 = 0;\n\twhile(h.size()!=0){\n\t\twhile(h.size()!=0&&h.back()==0){\n\t\t\th.pop_back();\n\t\t\tcnt0 ++;\n\t\t}\n\t\tif(h.size()==0)break;\n\t\tvector<int> t;\n\t\twhile(h.size()!=0&&h.back()!=0){\n\t\t\tt.push_back(h.back());\n\t\t\th.pop_back();\n\t\t}\n\t\t\n\t\tpair<int,int> p = dfs(t);\n\t\tif(!f){\n\t\t\tf=true;\n\t\t}\n\t\tcheck = mod(check * p.first);\n\t\tnotcheck = mod(notcheck * mod(p.first*2 + p.second));\n\t}\n\t\n\tif(f){\n\t\tnotcheck = mod(notcheck * beki(2,cnt0));\n\t\tcheck = mod(check * 2);\n\t\tnotcheck = mod(notcheck - check);\n\t\tcheck = mod(check * beki(2,height-1));\n\t}\n\telse{\n\t\tcheck = beki(2,height);\n\t\tnotcheck = mod(beki(2,width)-2);\n\t}\n\t//cout<<height<<','<<width<<','<<check<<','<<notcheck<<endl;\n\treturn make_pair(check,notcheck);\n}\n\t\n\nint main(){\n\t\n\tint N;\n\tcin>>N;\n\t\n\tvector<int> h(N);\n\tfor(int i=0;i<N;i++){\n\t\tcin>>h[i];\n\t}\n\t\n\tpair<int,int> p = dfs(h);\n\t\n\tcout<<mod(p.first+p.second)<<endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\nconst ll MOD = 1000000007;\n\ninline void add(ll &x, ll y) { x += y; if (x >= MOD) x -= MOD; }\n\nll mod_pow(ll x, ll k) {\n\tll res = 1;\n\tfor (; k; x = x * x % MOD, k /= 2) {\n\t\tif (k & 1) {\n\t\t\tres = res * x % MOD;\n\t\t}\n\t}\n\treturn res;\n}\n\nint N;\nint h[110];\nint mh[110][110];\nll dp[110][110][2][2][2]; //left, right, same\nll tb[110][110][2][2][2];\n\nvoid calc(int l, int r, int lo, int &pt) {\n\t//cerr << l << \" \" << r << \" \" << lo << endl;\n\n\tint now = pt++;\n\tint la = -1;\n\n\tfor (int m = l; m <= r; ++m) {\n\t\tif (h[m] == mh[l][r]) {\n\t\t\tif (la != -1) {\n\t\t\t\tcalc(la, m-1, mh[l][r], pt);\n\t\t\t\tif (la == l) {\n\t\t\t\t\trep(j, 2) {\n\t\t\t\t\t\trep(k, 2) {\n\t\t\t\t\t\t\trep(t, 2) {\n\t\t\t\t\t\t\t\tif (t == 1) {\n\t\t\t\t\t\t\t\t\tadd(tb[now][m-1][j^1][k^1][t], dp[la][m-1][j][k][t]);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tadd(tb[now][m-1][j^1][k^1][t], dp[la][m-1][j][k][t]);\n\t\t\t\t\t\t\t\t\tadd(tb[now][m-1][j][k][t], dp[la][m-1][j][k][t]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\trep(j, 2) {\n\t\t\t\t\t\trep(k, 2) {\n\t\t\t\t\t\t\trep(t, 2) {\n\t\t\t\t\t\t\t\trep(jj, 2) {\n\t\t\t\t\t\t\t\t\trep(kk, 2) {\n\t\t\t\t\t\t\t\t\t\trep(tt, 2) {\n\t\t\t\t\t\t\t\t\t\t\tint nj, nk, nt;\n\t\t\t\t\t\t\t\t\t\t\tif (tt == 1) {\n\t\t\t\t\t\t\t\t\t\t\t\tnj = j, nk = kk ^ 1, nt = (t | tt) | (k == (jj ^ 1));\n\t\t\t\t\t\t\t\t\t\t\t\tadd(tb[now][m-1][nj][nk][nt], tb[now][la-1][j][k][t] * dp[la][m-1][jj][kk][tt] % MOD);\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\tnj = j, nk = kk ^ 1, nt = (t | tt) | (k == (jj ^ 1));\n\t\t\t\t\t\t\t\t\t\t\t\tadd(tb[now][m-1][nj][nk][nt], tb[now][la-1][j][k][t] * dp[la][m-1][jj][kk][tt] % MOD);\n\n\t\t\t\t\t\t\t\t\t\t\t\tnj = j, nk = kk, nt = (t | tt) | (k == jj);\n\t\t\t\t\t\t\t\t\t\t\t\tadd(tb[now][m-1][nj][nk][nt], tb[now][la-1][j][k][t] * dp[la][m-1][jj][kk][tt] % MOD);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (m == l) {\n\t\t\t\ttb[now][l][0][0][0] = tb[now][l][1][1][0] = 1;\n\t\t\t} else {\n\t\t\t\trep(j, 2) {\n\t\t\t\t\trep(k, 2) {\n\t\t\t\t\t\trep(t, 2) {\n\t\t\t\t\t\t\tif (tb[now][m-1][j][k][t] == 0) continue; \n\t\t\t\t\t\t\trep(nx, 2) {\n\t\t\t\t\t\t\t\tadd(tb[now][m][j][nx][t | (nx == k)], tb[now][m-1][j][k][t]); \n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tla = -1;\n\t\t} else if (h[m] > mh[l][r]) {\n\t\t\tif (la == -1) {\n\t\t\t\tla = m;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (la != -1) {\n\t\tcalc(la, r, mh[l][r], pt);\n\n\t\trep(j, 2) {\n\t\t\trep(k, 2) {\n\t\t\t\trep(t, 2) {\n\t\t\t\t\tif (tb[la-1][j][k][t] == 0) continue;\n\t\t\t\t\trep(jj, 2) {\n\t\t\t\t\t\trep(kk, 2) {\n\t\t\t\t\t\t\trep(tt, 2) {\n\t\t\t\t\t\t\t\tif (dp[la][r][jj][kk][tt] == 0) continue;\n\t\t\t\t\t\t\t\tint nj, nk, nt;\n\t\t\t\t\t\t\t\tif (tt == 1) {\n\t\t\t\t\t\t\t\t\tnj = j, nk = kk ^ 1, nt = ((t | tt) | (k == (jj ^ 1)));\n\t\t\t\t\t\t\t\t\tadd(tb[now][r][nj][nk][nt], tb[now][la-1][j][k][t] * dp[la][r][jj][kk][tt] % MOD);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tnj = j, nk = kk ^ 1, nt = ((t | tt) | (k == (jj ^ 1)));\n\t\t\t\t\t\t\t\t\tadd(tb[now][r][nj][nk][nt], tb[now][la-1][j][k][t] * dp[la][r][jj][kk][tt] % MOD);\n\n\t\t\t\t\t\t\t\t\tnj = j, nk = kk, nt = ((t | tt) | (k == jj));\n\t\t\t\t\t\t\t\t\tadd(tb[now][r][nj][nk][nt], tb[now][la-1][j][k][t] * dp[la][r][jj][kk][tt] % MOD);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint num = mh[l][r] - lo - 1;\n\tll p[2];\n\n\tif (num == 0) {\n\t\tp[0] = 1;\n\t\tp[1] = 0;\n\t} else {\n\t\tp[0] = p[1] = mod_pow(2, num - 1);\n\t}\n\n\trep(j, 2) {\n\t\trep(k, 2) {\n\t\t\trep(t, 2) {\n\t\t\t\tif (t == 1) {\n\t\t\t\t\tbool b = (num & 1);\n\t\t\t\t\tadd(dp[l][r][j^b][k^b][t], tb[now][r][j][k][t]);\n\t\t\t\t} else {\n\t\t\t\t\trep(b, 2) {\n\t\t\t\t\t\tadd(dp[l][r][j^b][k^b][t], tb[now][r][j][k][t] * p[b] % MOD);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> N;\n\trep(i, N) cin >> h[i];\n\n\trep(i, N) {\n\t\tint d = 2e9;\n\t\tfor (int j = i; j < N; ++j) {\n\t\t\td = min(d, h[j]);\n\t\t\tmh[i][j] = d;\n\t\t}\n\t}\n\n\tint k = 0;\n\tcalc(0, N-1, 0, k);\n\tll ret = 0;\n\trep(j, 2) {\n\t\trep(k, 2) {\n\t\t\trep(t, 2) {\n\t\t\t\tadd(ret, dp[0][N-1][j][k][t]);\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ret % MOD << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\ntypedef pair<lint,lint> pll;\ntypedef long double louble;\n\n#define lf ('\\n')\n\ntemplate<typename T1,typename T2> inline T1 max(T1 a,T2 b){return a<b?b:a;}\ntemplate<typename T1,typename T2> inline T1 min(T1 a,T2 b){return a<b?a:b;}\n\nnamespace ae86\n{\n\tconst int bufl = 1<<15;\n\t\n\tchar buf[bufl],*s=buf,*t=buf;\n\t\n\tinline int fetch()\n\t{\n\t\tif(s==t){t=(s=buf)+fread(buf,1,bufl,stdin);if(s==t)return EOF;}\n\t\treturn *s++;\n\t}\n\t\n\tinline int ty()\n\t{\n\t\tint a=0,b=1,c=fetch();\n\t\twhile(!isdigit(c))b^=c=='-',c=fetch();\n\t\twhile(isdigit(c))a=a*10+c-48,c=fetch();\n\t\treturn b?a:-a;\n\t}\n}\nusing ae86::ty;\n\nconst int _ = 103 , mo = 1000000007;\n\ninline lint powa(lint a,lint t)\n{\n\tlint b=1;\n\twhile(t){if(t&1)b=b*a%mo;a=a*a%mo,t>>=1;}\n\treturn b;\n}\n\nint n,hig[_];\n\n// pll = (not have adjacent same color, have adjacent same color)\n\npll dfs(int l,int r,int h)\n{\n\tint mih=2e9;\n\tfor(int i=l;i<=r;i++)mih=min(mih,hig[i]);\n\n\tpll ans=pll(2,1);\n\tfor(int i=l;i<=r;i++)\n\t{\n\t\tif(hig[i]==mih)ans.second=ans.second*2%mo;\n\t\telse\n\t\t{\n\t\t\tint j=i;\n\t\t\twhile(j<r && hig[j+1]>mih)j++;\n\t\t\tpll ret=dfs(i,j,mih);\n\t\t\tans.first=ans.first*ret.first%mo;\n\t\t\tans.second=(ret.first+ret.first+ret.second)%mo*ans.second%mo;\n\t\t\ti=j;\n\t\t}\n\t}\n\n\tans.second=(ans.second-ans.first+mo)%mo;\n\tans.first=ans.first*powa(2,mih-h-1)%mo;\n\n\treturn ans;\n}\n\nint main()\n{\n\tn=ty();\n\tfor(int i=1;i<=n;i++)hig[i]=ty();\n\tpll ret=dfs(1,n,0);\n\tprintf(\"%lld\\n\",(ret.first+ret.second)%mo);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <map>\n#include <list>\n#include <iterator>\n#include <set>\n#include <queue>\n#include <iostream>\n#include <sstream>\n#include <stack>\n#include <deque>\n#include <cmath>\n#include <memory.h>\n#include <ctime>\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <algorithm>\n#include <utility>\n#include <fstream>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i, a, b) for(int i = a; i < b; ++i)\n#define RFOR(i, b, a) for(int i = b - 1; i >= a; --i)\n#define REP(i, N) FOR(i, 0, N)\n#define RREP(i, N) RFOR(i, N, 0)\n\n#define ALL(V) V.begin(), V.end()\n#define SIZE(V) (int)V.size()\n#define pb push_back\n#define mp make_pair\n#define EPS 1e-7\n#define Pi 3.14159265358979\n#define FILL(a,v) memset(a,v,sizeof(a))\n\nusing namespace std;\n\n\ntypedef long long Long;\ntypedef unsigned long long ULong;\ntypedef unsigned int Uint;\ntypedef unsigned char Uchar;\ntypedef vector <int> VI;\ntypedef pair <int, int> PII;\n\n\nconst int M = 1000000007;\nconst int MAXN = 107;\n\nLong binpow(Long b, int p) {\n    Long res = 1;\n    while (p > 0) {\n        if (p&1)\n            res *= b;\n        b*=b;\n        b%=M;\n        res %= M;\n        p >>= 1;\n    }\n    return res;\n}\n\n\nLong col(int h) {\n    return binpow(2,h);\n}\nint n;\n\nLong dps[MAXN];\nLong dpd[MAXN];\nLong dpc[MAXN][MAXN];\n\n\nLong solve(VI h) {\n    int n = h.size();\n    if (n == 0)\n        return 1;\n\n    dps[0] = dpd[0] = (2*col(h[0]-2))%M;\n    REP(i,n) {\n        if (h[i] <= h[0])\n            dpc[0][i] = (2*col(h[0]-h[i]))%M;\n    }\n\n    FOR(i,1,n) {\n        dps[i] = dps[i-1]*col(h[i]-h[i-1])%M;\n        dpd[i] = dpd[i-1]*col(h[i]-h[i-1])%M;\n        if (h[i] <= h[i-1])\n            dpd[i] += dpc[i-1][i];\n        else\n            dpd[i] += dpc[i-1][i-1]*col(h[i]-h[i-1])%M;\n        dps[i] %= M;\n        dpd[i] %= M;\n\n\n        FOR(j, i, n) {\n            if (h[j] > h[i])\n                continue;\n\n            if (h[j] >= h[i-1]) {\n                dpc[i][j] = 2*dpc[i-1][i-1]*col(h[i]-h[j]);\n                continue;\n            }\n\n            if (h[i] >= h[i-1])\n                dpc[i][j] = (dpc[i-1][j] + dpc[i-1][i-1])*col(h[i] - h[i-1]);\n            else {\n                dpc[i][j] = dpc[i-1][j] + dpc[i-1][i];\n            }\n        }\n        REP(j,n)\n            dpc[i][j] %= M;\n\n    }\n//\n//    REP(i,n) {\n//        cout << dps[i] << \"\\t\" << dpd[i] << \"\\t\";\n//        REP(j,n)\n//            cout << dpc[i][j] << \"\\t\";\n//        cout << endl;\n//    }\n\n//    cout << dps[n-1] + dpd[n-1] << endl;\n\n    return (dps[n-1] + dpd[n-1])%M;\n}\n\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin >> n;\n\n    Long res = 1;\n\n    int t;\n    VI h;\n\n\n    REP(i,n) {\n        cin >> t;\n        if (t == 1) {\n            res *= solve(h);\n            res %= M;\n            res *= 2;\n            res %= M;\n            h.clear();\n        } else {\n            h.pb(t);\n        }\n    }\n\n    res *= solve(h);\n\n    cout << res%M << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nconst int MOD = (int)1e9 + 7;\n\nint n,m,h[101],hnum[101],dh[101];\nlong long dp[101][101];\n\nint pow_(int x,int y) {///快速幂求 x的y次方\n    long long ans = 1;\n    if(y > 0) {\n        while(y) {\n            if(y % 2)ans = ans * x % MOD;\n            x = (long long)x * x % MOD;\n            y /= 2;\n        }\n    }\n    return ans;\n}\n\nint main() {\n    scanf(\"%d\",&n);\n    for(int i = 1;i <= n;i ++) {\n        scanf(\"%d\",&h[i]);\n        dh[++ m] = h[i];\n    }\n    sort(dh + 1,dh + m + 1);///高度排序\n    m = unique(dh + 1,dh + m + 1) - dh - 1;///离散化 m是离散化后的长度\n    for(int i = 1;i <= n;i ++) {\n        hnum[i] = lower_bound(dh + 1,dh + m + 1,h[i]) - dh;\n    }\n    dp[0][0]=1;\n    for(int i = 1;i <= n;i ++) {\n        for(int j = hnum[i] + 1;j <= hnum[i - 1];j ++)\n            (dp[i][0] += dp[i - 1][j] * 2 % MOD) %= MOD;\n\n        (dp[i][0] += dp[i - 1][0] * 2 % MOD) %= MOD;///交叉或者不交叉\n\n        int d = pow_(2,h[i] - h[i - 1]);\n        for(int j = 1;j <= min(hnum[i - 1],hnum[i]);j ++) {\n            dp[i][j] = dp[i - 1][j] * d % MOD;\n        }\n        for(int j = hnum[i - 1] + 1;j <= hnum[i];j ++) {///比前一列高出的部分\n            if(j > 1)(dp[i][j] += dp[i - 1][0] * (pow_(2,dh[j] - dh[j - 1]) - 1) % MOD * 2 % MOD * pow_(2,h[i] - dh[j]) % MOD) %= MOD;\n            else (dp[i][1] += dp[i - 1][0] * (pow_(2,dh[1]) - 2) % MOD * pow_(2,h[i] - dh[1]) % MOD) %= MOD;///上一列中无重复相同的乘上化不超过上一列高度中有重复的\n        }\n    }\n    long long ans = 0;\n    for(int i = 0;i <= hnum[n];i++)\n        (ans += dp[n][i]) %= MOD;\n    printf(\"%lld\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int>pii;\nconst int N=105,mo=1e9+7;\ninline int poww(int x,int y){\n\tint ans=1;\n\tfor(;y;y>>=1,x=1ll*x*x%mo)if(y&1)ans=1ll*ans*x%mo;\n\treturn ans;\n}\ninline int SS(int x){return poww(2,x+1)-1;}\ninline int S(int l,int r){return (SS(r)+mo-SS(l))%mo;}\nint n,h[N],hh[N],h2[N],i,j,k,f[N][N],nn,ans;\ninline void work(int i,int z,int x){\n\tfor(;i<=h2[z];++i)\n\t\tf[z][i]=(f[z][i]+1ll*x*(hh[i]>1?S(h[z]-hh[i]-1,h[z]-max(1,hh[i-1])-1):0))%mo;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;++i)scanf(\"%d\",h+i),hh[i]=h[i];\n\tsort(hh+1,hh+n+1);nn=unique(hh+1,hh+n+1)-hh-1;\n\tfor(i=1;i<=n;++i)h2[i]=lower_bound(hh+1,hh+nn+1,h[i])-hh;\n\tf[1][0]=2;work(1,1,2);\n\tfor(i=1;i<n;++i){\n\t\tfor(j=1;j<=h2[i] && j<=h2[i+1];++j)f[i+1][j]=1ll*(h2[i]<h2[i+1]?poww(2,h[i+1]-h[i]):1)*f[i][j]%mo;\n\t\twork(h2[i]+1,i+1,(h2[i]==1?2ll:2ll)*f[i][0]%mo);\n\t\tfor(j=0;j<=h2[i];++j)if(!j || j>h2[i+1])f[i+1][0]=(f[i+1][0]+2ll*f[i][j])%mo;\n\t}\n\tfor(i=0;i<=h2[n];++i)ans=(ans+f[n][i])%mo;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int N = 105, mod = 1000000007;\nint n, h[N];\n\ninline int qpow(int b, int p) {\n  int r = 1;\n  for (; p; p >>= 1) {\n    if (p & 1) r = (ll) r * b % mod;\n    b = (ll) b * b % mod;\n  }\n  return r;\n}\n\npair<int, int> solve(int l, int r, int x) {\n  int mn = mod;\n  for (int i = l; i <= r; i++) {\n    mn = min(mn, h[i]);\n  }\n  pair<int, int> p = make_pair(2, 1);\n  for (int i = l; i <= r; i++) {\n    if (h[i] == mn) {\n      p.second = p.second * 2 % mod;\n    } else {\n      int j = i;\n      for (; j < r && h[j + 1] > mn; j++);\n      auto q = solve(i, j, mn);\n      p.first = (ll) p.first * q.first % mod;\n      p.second = (ll) p.second * (q.first * 2 % mod + q.second) % mod;\n      i = j;\n    }\n  }\n  p.second = (p.second + mod - p.first) % mod;\n  p.first = (ll) p.first * qpow(2, mn - x - 1) % mod;\n  return p;\n}\n\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &h[i]);\n  }\n  auto p = solve(1, n, 0);\n  printf(\"%d\\n\", (p.first + p.second) % mod);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ri register int\ntypedef long long ll;\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\t// input a signed integer\n\ttemplate <class I>\n\tinline void gi (I &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = (x << 1) + (x << 3) + (c & 15); x *= f;\n\t}\n\t// print a signed integer\n\ttemplate <class I>\n\tinline void print (I x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t}\n\t// no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n} \nusing io :: gi;\nusing io :: putc;\nusing io :: print;\nconst int N=105,mod=1e9+7;\nint h[N],f[N][N],a[N],pos[N];\n// f[i][j] 表示第i列前a[i]个格子没有出现 xx/oo ，前a[i+1]个格子出现了 xx/oo \ninline int fpow(ri a,ri b){\n\tri ans=1;\n\tfor(;b;b>>=1,a=(ll)a*a%mod)\n\t\tif(b&1) ans=(ll)ans*a%mod;\n\treturn ans;\n}\ninline void add(int &x,ri y){\n\tx=(x+=y)>=mod?x-mod:x;\n}\ninline int calc(ri x){  \n\treturn (fpow(2,x)-1+mod)%mod; \n}\ninline int solve(ri l,ri r){\n\tri i,j,k,m,res;\n\tm=0;\n\tfor(i=l;i<=r;++i) a[++m]=h[i];\n\tsort(a+1,a+1+m);\n\tm=unique(a+1,a+1+m)-a-1;\n\tfor(i=l;i<=r;++i) pos[i]=lower_bound(a+1,a+1+m,h[i])-a;\n\tf[l][0]=2ll*calc(a[1]-1)*fpow(2,h[l]-a[1])%mod; \n\tfor(i=1;i<pos[l];++i)\n\t\tf[l][i]=2ll*calc(a[i+1]-a[i])*fpow(2,h[l]-a[i+1])%mod;\n\tf[l][pos[l]]=2; \n\tfor(i=l+1;i<=r;++i){ \n\t\tif(h[i]<=h[i-1]){\n\t\t\tfor(j=0;j<pos[i];++j)\n\t\t\t\tf[i][j]=f[i-1][j];\n\t\t\tfor(k=pos[i];k<=pos[i-1];++k)\n\t\t\t\tadd(f[i][j],f[i-1][k]*2ll%mod);\n\t\t}\n\t\telse{\n\t\t\tfor(j=0;j<pos[i-1];++j)\n\t\t\t\tf[i][j]=(ll)f[i-1][j]*fpow(2,h[i]-h[i-1])%mod;\n\t\t\tfor(;j<pos[i];++j)\n\t\t\t\tf[i][j]=(ll)f[i-1][pos[i-1]]*2*calc(a[j+1]-a[j])%mod*fpow(2,h[i]-a[j+1])%mod;\n\t\t\tf[i][pos[i]]=f[i-1][pos[i-1]]*2ll%mod;\n\t\t}\n\t//\tfor(j=0;j<=pos[i];++j)\n\t//\t\tprintf(\"dp %d %d %d\\n\",i,j,f[i][j]);\n\t} \n\tres=0;\n\tfor(i=0;i<=m;++i)\n\t\tadd(res,f[r][i]);\n\treturn res;\n}\nint main(){\n\tri n,i,last,ans;\n\tgi(n);\n\tfor(i=1;i<=n;++i) gi(h[i]);\n\tlast=0;ans=1;\n\tfor(i=1;i<=n;++i)\n\t\tif(h[i]==1){\n\t\t\tans=(ans<<1)%mod;\n\t\t\tif(last+1<=i-1) ans=(ll)ans*solve(last+1,i-1)%mod;\n\t\t\tlast=i; \n\t\t}\n\tif(last+1<=n) ans=(ll)ans*solve(last+1,n)%mod;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define P pair<int,int>\n#define fir first\n#define sec second\nusing namespace std;\ntypedef long long ll;\nconst int mod=1e9+7;\nconst int inf=0x3f3f3f3f;\nconst int N=105;\nint a[N],n;\nint ksm(int x,int y)\n{\n\tint res=1;\n\twhile (y){if (y&1) res=(ll)res*x%mod;x=(ll)x*x%mod;y>>=1;}\n\treturn res;\n}\nvoid up(int &x,int y){x=x-mod+y;x=(x<0)?x+mod:x;}\nP dfs(int l,int r,int h)//笛卡尔树,s1表示存在相同相邻，s2表示010101相邻不同 \n{\n\tint Min=inf,cnt=0;\n\tfor (int i=l;i<=r;i++) Min=min(Min,a[i]);\n\tfor (int i=l;i<=r;i++) if (Min==a[i]) cnt++;\n\tif (cnt==r-l+1)//边界，矩形 \n\t  return P(((ll)ksm(2,r-l+1)-2+mod)%mod,ksm(2,Min-h));\n\tint s1=1,s2=1,blo=0;cnt=0;\n    for (int i=l,L=l,R=l-1;i<=r;i++)\n    {\n    \tif (a[i]!=Min) R=i;else cnt++;\n    \tif (a[i]==Min||i==r)\n    \t{\n    \t\tif (L<=R)\n    \t\t{\n    \t\t  blo++; \n    \t\t  P now=dfs(L,R,Min);\n\t\t\t  s1=(ll)s1*(now.fir+(ll)now.sec*2%mod)%mod;//全集 \n\t\t\t  s2=(ll)s2*now.sec%mod;//01交替 \n\t\t\t}\n    \t\tL=i+1,R=i;\n\t\t}\n\t}\n\ts1=((ll)s1-(ll)s2*ksm(2,blo)%mod+mod)%mod;//存在相同相邻 \n\tP ans;\n\tans.fir=(ll)s1*ksm(2,cnt)%mod;\n\tans.fir=((ll)ans.fir+((ll)ksm(2,cnt)*ksm(2,blo)%mod-2+mod)%mod*s2%mod)%mod; \n\tans.sec=(ll)s2*ksm(2,Min-h)%mod;\n\treturn ans;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tP now=dfs(1,n,0);//[1,n]当前底层高度 \n\tprintf(\"%d\\n\",((ll)now.fir+now.sec)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <vector>\n#include <cassert>\n#include <fstream>\n#include <algorithm>\n#include <list>\n#include <random>\n#include <ctime>\n#include <cmath>\n#include <random>\n#include <bitset>\n#include <complex>\n#pragma unroll\n#pragma loop count N\n#pragma ivdep\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n//#define int ll\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef pair<ld, ld> pld;\ntypedef complex<double> base;\n\n#define mmin(a, b) a = min(a, (b))\n#define mmax(a, b) a = max(a, (b))\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define ALL(a) a.begin(),a.end()\n#define sqr(x) (x) * (x)\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define cint const int &\n#define SZ(a) ((int)(a.size()))\n#define f(cnt) (((cnt) + 1) * (cnt) / 2)\n#define watch(x) cout << (#x) << \" = \" << x << endl;\n\nconst double PI = 2 * acos(0.0);\n\ntemplate<class T>\nvoid show(const set<T> &a) {\n    for (T x : a)\n        cout << x << \" \";\n    cout << endl;\n}\n\ntemplate<class T>\nvoid show(const vector<T> &a) {\n    for (T x : a)\n        cout << x << \" \";\n    cout << endl;\n}\n\nconst ll M = 1e9 + 7;\n\nll MOD(ll a) {\n    if (a >= 0) return a >= M ? a % M : a;\n    if (a <= -M) a %= M;\n    return a ? a + M : a;\n}\n\nconst int N = 109;\nconst int L = 1e6 + 7;\n\nstruct edge {\n    int u, v;\n    ll height;\n    edge(int u, int v, ll height): u(u), v(v), height(height) {\n\n    }\n\n};\nvector<edge> e;\n\nll pw(ll a, ll p) {\n    if (!p) return 1;\n    ll ret = pw(a, p >> 1);\n    ret = MOD(ret * ret);\n    if (p & 1) ret = MOD(ret * a);\n    return ret;\n}\n\nint counter = 1;\nvi g[L];\nll len[L];\nint vert[L];\nint start[L];\nll h[N];\nll dp[2][L];\n\ninline ll get_ways(int v) {\n    vvvl dp(N, vvl(2, vl(2, 0)));\n    vector<char> must(N, 0);\n    for (int id : g[v]) {\n        int to = e[id].v;\n        for (int i = 1; i < len[to]; ++i)\n            must[i + start[to]] = 1;\n    }\n    dp[start[v]][0][0] = dp[start[v]][0][1] = 1;\n    for (int i = 1; i < len[v]; ++i) {\n        int ind = i + start[v];\n        if (must[ind]) {\n            for (int z1 : {0, 1}) for (int z2 : {0, 1})\n                dp[ind][z1][z2] = dp[ind - 1][z1][!z2];\n        } else {\n            for (int z1 : {0, 1}) for (int z2 : {0, 1}) for (int z3 : {0, 1}) {\n                int nx = z1;\n                if (z2 != z3) nx = 1;\n                dp[ind][nx][z3] = MOD(dp[ind][nx][z3] + dp[ind - 1][z1][z2]);\n            }\n        }\n    }\n    ll ret = MOD(dp[start[v] + len[v] - 1][1][0] + dp[start[v] + len[v] - 1][1][1]);\n    return ret;\n}\n\nll dfs(int v) {\n    ll dp1 = 1; // wasn't any bad\n    ll dp2 = 0; /* was bad */;\n    ll restlen = len[v];\n    dp[0][v] = 1;\n    for (int id : g[v]) {\n        int to = e[id].v;\n        restlen -= len[to];\n        dfs(to);\n        ll curgood = MOD(pw(2, e[id].height - 1) * dp[0][to]);\n        dp[0][v] = MOD(dp[0][v] * curgood);\n        ll curbad = dp[1][to];\n        ll odp1 = dp1;\n        ll odp2 = dp2;\n        dp1 = MOD(odp1 * curgood * 2);\n        dp2 = MOD(odp2 * (curgood * 2 + curbad) + odp1 * curbad);\n    }\n    ll ways = get_ways(v);\n    dp[1][v] = MOD(dp2 * pw(2, restlen) + dp[0][v] * ways);\n    dp[0][v] = MOD(2 * dp[0][v]);\n}\n\nsigned main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n\n\n    int n;\n    cin >> n;\n    set<ll> hs;\n    fori (i, n) {\n        cin >> h[i];\n        hs.insert(h[i]);\n    }\n    ll prev = 0;\n    len[counter++] = n;\n    fori (i , n)\n        vert[i] = 1;\n    int curv = 0;\n    int par = 0;\n    for (auto hi : hs) {\n        int cnt = 0;\n        fori (i, n) {\n            if (h[i] >= hi) {\n                if (!cnt) {\n                    curv = counter++;\n                    start[curv] = i;\n                }\n                par = vert[i];\n                vert[i] = curv;\n                cnt++;\n            } else {\n                if (cnt >= 2) {\n                    len[curv] = cnt;\n                    g[par].pb(e.size());\n                    e.pb(edge(par, curv, hi - prev));\n                }\n                cnt = 0;\n            }\n        }\n        if (cnt >= 2) {\n            len[curv] = cnt;\n            g[par].pb(e.size());\n            e.pb(edge(par, curv, hi - prev));\n        }\n        prev = hi;\n    }\n    while (counter > L) ++counter;\n    ll fre = 0;\n    fori (i, n) {\n        ll lf = 0, rf = 0;\n        if (i) lf = h[i - 1];\n        if (i != n - 1) rf = h[i + 1];\n        fre += max(0LL, h[i] - max(lf, rf));\n    }\n    dfs(2);\n    ll ans = MOD(dp[0][2] * pw(2, e[g[1][0]].height - 1) + dp[1][2]);\n    ans = MOD(ans * pw(2, fre));\n    cout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 105;\nconst int mod = 1000000007;\ninline int qp(int a, int b) {\n\tint res = 1;\n\twhile (b) {\n\t\tif (b & 1) res = 1ll * res * a % mod;\n\t\ta = 1ll * a * a % mod;\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\nint n, h[N];\npair<int, int> solve(int l, int r, int lim) {\n\tint mn = 0x3f3f3f3f, cntmn = 0;\n\tfor (int i = l; i <= r; i++) {\n\t\tif (h[i] < mn) {\n\t\t\tmn = h[i];\n\t\t\tcntmn = 1;\n\t\t} else if (h[i] == mn) cntmn++;\n\t}\n\tpair<int, int> ret;\n\tif (cntmn == r - l + 1) {\n\t\tret.first = (qp(2, r - l + 1) - 2 + mod) % mod;\n\t\tret.second = qp(2, mn - lim - 1);\n\t\treturn ret;\n\t}\n\tint t0 = 1, t1 = 1;\n\tfor (int i = l, lst = l - 1; i <= r + 1; i++) {\n\t\tif (i > r || h[i] == mn) {\n\t\t\tif (lst < i - 1) {\n\t\t\t\tpair<int, int> cur = solve(lst + 1, i - 1, mn);\n\t\t\t\tt0 = 1ll * t0 * (cur.first + 4ll * cur.second % mod) % mod;\n\t\t\t\tt1 = 1ll * t1 * (2ll * cur.second % mod) % mod;\n\t\t\t}\n\t\t\tlst = i;\n\t\t}\n\t}\n\tt0 = (t0 - 2 * t1 % mod + mod) % mod;\n\tret.first = 1ll * t0 * qp(2, cntmn) % mod;\n\tret.first = (ret.first + 2ll * t1 * (qp(2, cntmn) - 1) % mod) % mod;\n\tret.second = 1ll * t1 * qp(2, mn - lim - 1) % mod;\n\treturn ret;\n}\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &h[i]);\n\tpair<int, int> ret = solve(1, n, 0);\n\tint ans = (ret.first + 2ll * ret.second) % mod;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\ntemplate<typename T> using gpp_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T, typename L> using gpp_map = tree<T, L, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T> using gpp_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;*/\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl;\n#define mdebug(m) cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;}\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\nconst int mod = 1000000007;\n//const int mod = 998244353;\n//#define Add(x, y) x = (x + (y)) % mod\n//#define Mult(x, y) x = (x * (y)) % mod\n\ntemplate<long long MOD>\nstruct ModInt{\n\n    using ll = long long;\n    ll val;\n\n    void setval(ll v) { val = v % MOD; };\n    ModInt(): val(0) {}\n    ModInt(ll v) { setval(v); };\n\n    ModInt operator+(const ModInt &x) const { return ModInt(val + x.val); }\n    ModInt operator-(const ModInt &x) const { return ModInt(val - x.val + MOD); }\n    ModInt operator*(const ModInt &x) const { return ModInt(val * x.val); }\n    ModInt operator/(const ModInt &x) const { return *this * x.inv(); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt operator+=(const ModInt &x) { return *this = *this + x; }\n    ModInt operator-=(const ModInt &x) { return *this = *this - x; }\n    ModInt operator*=(const ModInt &x) { return *this = *this * x; }\n    ModInt operator/=(const ModInt &x) { return *this = *this / x; }\n\n    friend ostream& operator<<(ostream &os, const ModInt &x) { os << x.val; return os; }\n    friend istream& operator>>(istream &is, ModInt &x) { is >> x.val; x.val = (x.val % MOD + MOD) % MOD; return is; }\n\n    ModInt pow(ll n) const {\n        ModInt a = 1;\n        if(n == 0) return a;\n        int i0 = 64 - __builtin_clzll(n);\n        for(int i = i0 - 1; i >= 0; i--){\n            a = a * a;\n            if((n >> i) & 1) a *= (*this); \n        }\n        return a;\n    }\n    ModInt inv() const { return this->pow(MOD - 2); }\n};\n\nusing mint = ModInt<mod>; mint pow(mint x, long long n) { return x.pow(n); }\n//using mint = double; //for debug\nusing mvec = vector<mint>;\nusing mmat = vector<mvec>;\n\nstruct Combination{\n\n    vector<mint> fact, invfact;\n\n    Combination(int N){\n        fact = vector<mint>({mint(1)});\n        invfact = vector<mint>({mint(1)});\n        fact_initialize(N);\n    }\n\n    void fact_initialize(int N){\n        int i0 = fact.size();\n        if(i0 >= N + 1) return;\n        fact.resize(N + 1);\n        invfact.resize(N + 1);\n        for(int i = i0; i <= N; i++) fact[i] = fact[i - 1] * i;\n        invfact[N] = (mint)1 / fact[N];\n        for(int i = N - 1; i >= i0; i--) invfact[i] = invfact[i + 1] * (i + 1); \n    }\n\n    mint nCr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[r] * invfact[n - r];\n    }\n\n    mint nPr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[n - r];\n    }\n\n};\n\nsigned main(){\n\n    int N; cin >> N;\n    vec h(N); cin >> h;\n\n    set<int> s(all(h));\n    s.insert(INF);\n    s.insert(1);\n    vec v(all(s));\n    int n = SZ(v);\n\n    mmat dp(N + 1, mvec(n, 0));\n    int prev = Lower_bound(v, 1);\n    dp[0][n - 1] = 1;\n    REP(i, N){\n        int j0 = Lower_bound(v, h[i]);\n        mint c0 = pow((mint)2, max(0LL, h[i] - v[prev]));\n        REP(j, j0 + 1){\n            dp[i + 1][j] += dp[i][j] * c0;\n        }\n        mint u = 0;\n        FOR(j, j0 + 1, n) u += dp[i][j];\n        FOR(j, prev + 1, j0 + 1){\n            int c = v[j] - v[j - 1];\n            int k = h[i] - v[j - 1];\n            dp[i + 1][j] += u * pow((mint)2, k - c + 1) * (pow((mint)2, c) - 1);\n        }\n        dp[i + 1][n - 1] += u * 2;\n        prev = j0;\n    }\n    mint ans = 0;\n    REP(j, n) ans += dp[N][j];\n    Out(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <vector>\n#include <cassert>\n#include <fstream>\n#include <algorithm>\n#include <list>\n#include <random>\n#include <ctime>\n#include <cmath>\n#include <random>\n#include <bitset>\n#include <complex>\n#pragma unroll\n#pragma loop count N\n#pragma ivdep\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n#define int ll\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef pair<ld, ld> pld;\ntypedef complex<double> base;\n\n#define mmin(a, b) a = min(a, (b))\n#define mmax(a, b) a = max(a, (b))\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define ALL(a) a.begin(),a.end()\n#define sqr(x) (x) * (x)\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define cint const int &\n#define SZ(a) ((int)(a.size()))\n#define f(cnt) (((cnt) + 1) * (cnt) / 2)\n#define watch(x) cout << (#x) << \" = \" << x << endl;\n\nconst double PI = 2 * acos(0.0);\n\ntemplate<class T>\nvoid show(const set<T> &a) {\n    for (T x : a)\n        cout << x << \" \";\n    cout << endl;\n}\n\ntemplate<class T>\nvoid show(const vector<T> &a) {\n    for (T x : a)\n        cout << x << \" \";\n    cout << endl;\n}\n\nconst ll M = 1e9 + 7;\n\nll MOD(ll a) {\n    if (a >= 0) return a >= M ? a % M : a;\n    if (a <= -M) a %= M;\n    return a ? a + M : a;\n}\n\nconst int N = 109;\nconst int L = 1e6 + 7;\n\nstruct edge {\n    int u, v;\n    ll height;\n    edge(int u, int v, ll height): u(u), v(v), height(height) {\n\n    }\n\n};\nvector<edge> e;\n\nll pw(ll a, ll p) {\n    if (p < 0LL) return pw(pw(a, -p), M - 2);\n    if (!p) return 1;\n    ll ret = pw(a, p >> 1LL);\n    ret = MOD(ret * ret);\n    if (p & 1LL) ret = MOD(ret * a);\n    return ret;\n}\n\nint counter = 1;\nvi g[L];\nll len[L];\nint vert[L];\nint start[L];\nll h[N];\nll dp[2][L];\n\ninline ll get_ways(int v) {\n    vvvl dp(N, vvl(2, vl(2, 0)));\n    vector<char> must(N, 0);\n    for (int id : g[v]) {\n        int to = e[id].v;\n        for (int i = 1; i < len[to]; ++i)\n            must[i + start[to]] = 1;\n    }\n    dp[start[v]][0][0] = dp[start[v]][0][1] = 1;\n    for (int i = 1; i < len[v]; ++i) {\n        int ind = i + start[v];\n        if (must[ind]) {\n            for (int z1 : {0, 1}) for (int z2 : {0, 1})\n                dp[ind][z1][z2] = dp[ind - 1][z1][!z2];\n        } else {\n            for (int z1 : {0, 1}) for (int z2 : {0, 1}) for (int z3 : {0, 1}) {\n                int nx = z1;\n                if (z2 != z3) nx = 1;\n                dp[ind][nx][z3] = MOD(dp[ind][nx][z3] + dp[ind - 1][z1][z2]);\n            }\n        }\n    }\n    ll ret = MOD(dp[start[v] + len[v] - 1][1][0] + dp[start[v] + len[v] - 1][1][1]);\n    return ret;\n}\n\nll dfs(int v) {\n    ll dp0 = 1;\n    ll dp1 = 1;\n    ll dp2 = 0;\n    ll restlen = len[v];\n    for (int id : g[v]) {\n        int to = e[id].v;\n        dfs(to);\n        restlen -= len[to];\n        ll curgood = MOD(pw(2, e[id].height - 1) * dp[0][to]);\n        ll curbad = dp[1][to];\n        dp2 = MOD(dp2 * (curgood * 2 + curbad) + dp1 * curbad);\n        dp1 = MOD(dp1 * curgood * 2);\n        dp0 = MOD(dp0 * curgood);\n    }\n    dp[1][v] = MOD(dp2 * pw(2, restlen) + dp0 * get_ways(v));\n    dp[0][v] = MOD(2 * dp0);\n}\n\nsigned main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n\n    int n;\n    cin >> n;\n    set<ll> hs;\n    fori (i, n) {\n        cin >> h[i];\n        hs.insert(h[i]);\n    }\n    ll prev = 0;\n    len[counter++] = n;\n    fori (i , n)\n        vert[i] = 1;\n    int curv = 0;\n    int par = 0;\n    for (auto hi : hs) {\n        int cnt = 0;\n        fori (i, n) {\n            if (h[i] >= hi) {\n                if (!cnt) {\n                    curv = counter++;\n                    start[curv] = i;\n                    par = vert[i];\n                }\n                vert[i] = curv;\n                cnt++;\n            } else {\n                if (cnt >= 2) {\n                    len[curv] = cnt;\n                    g[par].pb(SZ(e));\n                    e.pb(edge(par, curv, hi - prev));\n                }\n                cnt = 0;\n            }\n        }\n        if (cnt >= 2) {\n            len[curv] = cnt;\n            g[par].pb(SZ(e));\n            e.pb(edge(par, curv, hi - prev));\n        }\n        prev = hi;\n    }\n    ll fre = 0;\n    fori (i, n) {\n        ll neib = 0;\n        if (i) mmax(neib, h[i - 1]);\n        if (i != n - 1) mmax(neib, h[i + 1]);\n        fre += max(0LL, h[i] - neib);\n    }\n    int vertex = e[g[1][0]].v;\n    dfs(vertex);\n    ll ans = MOD(dp[0][vertex] * pw(2, e[g[1][0]].height - 1) + dp[1][vertex]);\n    ans = MOD(ans * pw(2, fre));\n    cout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <set>\n\n#define MIN_INT -2147483648\n#define MAX_INT 2147483647\n#define MIN_LONG -9223372036854775808L\n#define MAX_LONG 9223372036854775807L\n#define PI 3.141592653589793238462643383279502884L\n\n#define long long long int\n\nusing std::vector;\nusing std::map;\nusing std::set;\nusing std::string;\nusing std::pair;\nusing std::cin;\nusing std::cout;\nusing std::cerr;\n\n// @author: pashka\n\ntypedef pair<long, int> item;\nitem zeroSum = {MAX_LONG, -1};\n\nitem sum(item a, item b) {\n    if (a.first < b.first || a.first == b.first && a.second < b.second) {\n        return a;\n    } else {\n        return b;\n    }\n}\n\nvector<item> sums;\n\nint size;\n\nitem sum(int l, int r, int n, int L, int R) {\n    if (l >= R || L >= r) return zeroSum;\n    if (L >= l && R <= r) {\n        return sums[n];\n    }\n    int M = (L + R) >> 1;\n    return sum(sum(l, r, 2 * n + 1, L, M), sum(l, r, 2 * n + 2, M, R));\n}\n\nvoid init(int n) {\n    size = 1;\n    while (size < n) size *= 2;\n    sums.assign(2 * size, zeroSum);\n}\n\nvoid init(vector<item> a) {\n    int n = a.size();\n    init(n);\n    size = 1;\n    while (size < n) size *= 2;\n    sums.assign(2 * size, zeroSum);\n    for (int i = 0; i < n; i++) {\n        sums[size - 1 + i] = a[i];\n    }\n    for (int i = size - 2; i >= 0; i--) {\n        sums[i] = sum(sums[2 * i + 1], sums[2 * i + 2]);\n    }\n}\n\nitem sum(int l, int r) {\n    return sum(l, r, 0, 0, size);\n}\n\n// -----\n\n\n#define MOD 1000000007\n\nlong sum(long a, long b) { return (a + b) % MOD; }\n\nlong minus(long a, long b) { return (a - b + MOD) % MOD; }\n\nlong mult(long a, long b) { return (a * b) % MOD; }\n\nlong pow(long a, long b) {\n    long res = 1;\n    while (b > 0) {\n        if (b & 1) {\n            res = mult(res, a);\n        }\n        a = mult(a, a);\n        b >>= 1;\n    }\n    return res;\n}\n\n// ---\n\n\nint N = 0;\nvector<vector<int>> g(110);\nvector<long> h(110);\nvector<long> w(110);\n\nint build_tree(int l, int r) {\n//    cout << l << \" \" << r << \"\\n\";\n    int X = N++;\n    auto m = sum(l, r);\n    h[X] = m.first;\n    w[X] = r - l;\n    if (m.second > l) {\n//        cout << \" \" << l << \" \" << r << \"->\" << l << \" \" << m.second << \"\\n\";\n        g[X].push_back(build_tree(l, m.second));\n    }\n    while (m.second < r - 1) {\n        auto mm = sum(m.second + 1, r);\n//        cout << mm.second << \"\\n\";\n        if (mm.first == m.first) {\n            if (mm.second > m.second + 1) {\n//                cout << \" \" << l << \" \" << r << \"->\" << m.second + 1 << \" \" << mm.second << \"\\n\";\n                g[X].push_back(build_tree(m.second + 1, mm.second));\n            }\n            m = mm;\n        } else {\n//            cout << \" \" << l << \" \" << r << \"->\" << m.second + 1 << \" \" << r << \"\\n\";\n            g[X].push_back(build_tree(m.second + 1, r));\n//            cout << \" 333\\n\";\n            break;\n        }\n    }\n//    cout << l << \" \" << r << \"\\n\";\n    return X;\n}\n\nvector<long> da;\nvector<long> db;\n\nvoid calc(int x, long hh) {\n    int k = w[x];\n    long pa = 1;\n    long pb = 1;\n    for (auto y: g[x]) {\n        calc(y, h[x]);\n        pa = mult(pa, mult(2, da[y]));\n        pb = mult(pb, sum(db[y], mult(2, da[y])));\n        k -= w[y];\n    }\n    da[x] = mult(pow(2, (h[x] - hh - 1)), pa);\n    db[x] = mult(da[x], 2);\n    db[x] = sum(db[x], mult(pb, pow(2, k)));\n    db[x] = minus(db[x], mult(2, pa));\n//    cout << w[x] << \" \" << (h[x] - hh) << \" \" << da[x] << \" \" << db[x] << \"\\n\";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n\n    int n;\n    cin >> n;\n    vector<pair<long, int>> a(n);\n    for (int i = 0; i < n; i++) {\n        cin >> a[i].first;\n        a[i].second = i;\n    }\n\n    init(a);\n\n    int root = build_tree(0, n);\n//    cout << root << \"\\n\";\n\n    da.resize(N);\n    db.resize(N);\n    calc(root, 0);\n    cout << db[root] << \"\\n\";\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define fi first\n#define se second\n\nconst int N = 105, mod = 1e9 + 7;\nint n, h[N];\n\nvoid add (int &_a, int _b) {\n    _a += _b;\n    if (_a >= mod) _a -= mod;\n}\n\nint binPow (int _a, int _n) {\n    int ret = 1;\n    for (; _n; _n >>= 1, _a = 1LL * _a * _a % mod) if (_n & 1) ret = 1LL * ret * _a % mod;\n    return ret;\n}\n\npair<int, int> solve (int l, int r) {\n    int minH = mod;\n\n    bool rect = 1;\n    for (int i = l; i + 1 <= r; ++i) if (h[i] != h[i + 1]) rect = 0;\n\n    if (rect) return { (binPow(2, r - l + 1) + binPow(2, min(h[l] - h[l - 1], h[r] - h[r + 1]) ) - 2 + mod) % mod,\n                      binPow(2, min(h[l] - h[l - 1], h[r] - h[r + 1]) ) };\n\n    for (int i = l; i <= r; ++i) minH = min(minH, h[i]);\n    vector< pair<int, int> > dp;\n    vector< pair<int, int> > range;\n    for (int i = l, lst = -1; i <= r; ++i) {\n        if (h[i] == minH) lst = -1;\n        else {\n            if (lst == -1) lst = i;\n            if (i == r || h[i + 1] == minH) dp.pb( { solve(lst, i) } );\n        }\n    }\n    for (int i = l, lst = -1; i <= r; ++i) {\n        if (h[i] > minH) lst = -1;\n        else {\n            if (lst == -1) lst = i;\n            if (i == r || h[i + 1] > minH) range.pb( { lst, i } );\n        }\n    }\n\n//    cout << \"l = \" << l << \"  r = \" << r << '\\n';\n//    for (auto _ : dp) cout << _.fi << ' '; cout << '\\n';\n\n    pair<int, int> ret = { 0, 0 };\n\n    int tmp = 1;\n    for (auto _ : dp) tmp = 1LL * tmp * ( (_.fi + _.se) % mod) % mod;\n    for (auto _ : range) tmp = 1LL * tmp * binPow(2, _.se - _.fi + 1) % mod;\n\n//    cout << \"tmp = \" << tmp << '\\n';\n\n    add(ret.fi, tmp);\n\n    tmp = 1;\n    for (auto _ : dp) tmp = 1LL * tmp * _.se % mod;\n    add(tmp, tmp);\n\n//    cout << \"tmp = \" << tmp << '\\n';\n\n    add(ret.fi, 1LL * tmp * ( (binPow(2, minH - max(h[l - 1], h[r + 1]) - 1) - 1 + mod) % mod) % mod);\n\n    add(ret.se, 1LL * tmp * binPow(2, minH - max(h[l - 1], h[r + 1]) - 1) % mod);\n\n//    cout << ret.fi << \"  \" << ret.se << '\\n';\n\n    return ret;\n}\n\nint main () {\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\n    cin >> n;\n    for (int i = 1; i <= n; ++i) cin >> h[i];\n\n    cout << solve(1, n).fi;\n\n    return 0;\n}\n/*\n3\n4 2 5\n\n320\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\nconst ll mod = 1000000007;\nll beki(ll a, ll b) {\n    if(b == 0) return 1;\n    ll ret = beki(a, b / 2);\n    ret = ret * ret % mod;\n    if(b & 1) ret = ret * a % mod;\n    return ret;\n}\nll N;\nvector<ll> h;\nll ans = 1;\n\nvoid print(l_l tmp) {\n    cerr << \"{\" << tmp.first << \", \" << tmp.second << \"}\" << endl;\n}\n\nl_l f(ll l, ll r, ll d) {\n    l_l ret;\n    /*\n    if(r == l + 1) {\n        ret.second = beki(2, h[l] - d);\n        cerr << \"f: \" << l << \" \" << r << \" \" << d << endl;\n        print(ret);\n        return ret;\n    }\n    */\n    ll mini = 1e10;\n    ll maxi = 0;\n    for(int i = l; i < r; i++) {\n        chmin(mini, h[i]);\n        chmax(maxi, h[i]);\n    }\n    if(mini == maxi) {\n        ret.first = beki(2, r - l) - 2 + mod;\n        ret.first %= mod;\n        ret.second = 2 * beki(2, maxi - d - 1);\n        ret.second %= mod;\n        //cerr << \"f: \" << l << \" \" << r << \" \" << d << endl;\n        //print(ret);\n        return ret;\n    }\n    ll Left = l;\n    ll mininum = 0;\n    vector<l_l> v;\n    for(int i = l; i < r; i++) {\n        if(h[i] == mini) {\n            mininum++;\n            if(Left != i) {\n                v.push_back(f(Left, i, mini));\n            }\n            Left = i + 1;\n        }\n    }\n    if(Left != r) {\n        v.push_back(f(Left, r, mini));\n    }\n    ll total = beki(2, mininum);\n    ll Second = 2;\n    for(auto tmp : v) {\n        total *= tmp.first + tmp.second * 2;\n        total %= mod;\n        Second *= tmp.second;\n        Second %= mod;\n    }\n    ret.second = Second;\n    ret.first = total - Second + mod;\n    ret.first %= mod;\n    ret.second *= beki(2, mini - d - 1);\n    ret.second %= mod;\n    //cerr << \"f: \" << l << \" \" << r << \" \" << d << endl;\n    //print(ret);\n    return ret;\n}\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> N;\n    h.resize(N);\n    for(int i = 0; i < N; i++) {\n        cin >> h[i];\n    }\n    ll l = 0;\n    for(int r = 0; r < N; r++) {\n        if(h[r] == 1) {\n            ans *= 2;\n            if(l != r) {\n                auto tmp = f(l, r, 0);\n                ans *= tmp.first + tmp.second;\n                ans %= mod;\n            }\n            l = r + 1;\n        }\n    }\n    if(l != N) {\n        auto tmp = f(l, N, 0);\n        ans *= tmp.first + tmp.second;\n        ans %= mod;\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int64 INF = 1LL << 60;\nconst int mod = 1e9 + 7;\n\nint64_t mod_pow(int64_t x, int64_t n, int64_t mod) {\n  int64_t ret = 1;\n  while(n > 0) {\n    if(n & 1) (ret *= x) %= mod;\n    (x *= x) %= mod;\n    n >>= 1;\n  }\n  return ret;\n}\n\nint64 N, A[100];\nint64 dp1[100][101], dp2[100][101];\n\nvoid dfs(int l, int r) {\n  int64 ret = INF;\n  int w = r - l;\n  for(int i = l; i < r; i++) ret = min(ret, A[i]);\n  for(int i = l; i < r; i++) A[i] -= ret;\n  vector< pair< int, int > > child;\n  for(int i = l; i < r; i++) {\n    if(A[i] == 0) continue;\n    int left = i;\n    while(left < r && A[left] > 0) ++left;\n    child.emplace_back(i, left);\n    w -= left - i;\n    i = left - 1;\n  }\n  dp1[l][r] = dp2[l][r] = 1;\n  for(auto &p : child) {\n    dfs(p.first, p.second);\n    (dp1[l][r] *= dp1[p.first][p.second]) %= mod;\n    (dp2[l][r] *= dp1[p.first][p.second] + dp2[p.first][p.second]) %= mod;\n  }\n  dp2[l][r] = dp2[l][r] * mod_pow(2, w, mod) % mod + ((mod_pow(2, ret, mod) + mod - 2) % mod) * dp1[l][r] % mod;\n  (dp1[l][r] *= mod_pow(2, ret, mod)) %= mod;\n  for(int i = l; i < r; i++) A[i] += ret;\n}\n\nint main() {\n  cin >> N;\n  for(int i = 0; i < N; i++) {\n    cin >> A[i];\n  }\n  dfs(0, N);\n  cout << dp2[0][N] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n#define N 106\n#define mod 1000000007\nint dp[N][N],n,s[N],st[N],v[N],v2[N],ct,as=1;\nint pw(int a,int p){int as=1;while(p){if(p&1)as=1ll*as*a%mod;a=1ll*a*a%mod;p>>=1;}return as;}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&s[i]),v[i]=s[i];\n\tsort(v+1,v+n+1);\n\tv[0]=1;for(int i=1;i<=n;i++)if(v[i]!=v[i-1])v2[++ct]=v[i];\n\tfor(int i=1;i<=n;i++)for(int j=1;j<=ct;j++)if(s[i]==v2[j])st[i]=j;\n\tdp[0][0]=1;\n\tfor(int i=1;i<=n;i++)\n\tif(s[i]==1)\n\t{\n\t\tint su=0;\n\t\tfor(int j=0;j<=ct+1;j++)su=(su+dp[i-1][j])%mod;\n\t\tas=2ll*as*su%mod;\n\t\tdp[i][0]=1;\n\t}\n\telse if(s[i-1]<=1)\n\t{\n\t\tfor(int j=1;j<=st[i];j++)\n\t\tdp[i][j]=pw(2,s[i]-v2[j-1]+(j>1));\n\t\tdp[i][st[i]+1]=2;\n\t\tfor(int j=1;j<=st[i];j++)dp[i][j]=(dp[i][j]-dp[i][j+1]+mod)%mod;\n\t}\n\telse if(s[i]<=s[i-1])\n\t{\n\t\tfor(int j=1;j<=st[i-1]+1;j++)\n\t\tif(j>st[i])dp[i][st[i]+1]=(dp[i][st[i]+1]+2ll*dp[i-1][j])%mod;\n\t\telse dp[i][j]=dp[i-1][j];\n\t}\n\telse\n\t{\n\t\tfor(int j=1;j<=st[i-1];j++)dp[i][j]=1ll*dp[i-1][j]*pw(2,s[i]-s[i-1])%mod;\n\t\tfor(int j=st[i-1]+1;j<=st[i];j++)dp[i][j]=2ll*dp[i-1][st[i-1]+1]*pw(2,s[i]-v2[j-1])%mod;\n\t\tdp[i][st[i]+1]=2ll*dp[i-1][st[i-1]+1]%mod;\n\t\tfor(int j=st[i-1]+1;j<=st[i];j++)dp[i][j]=(dp[i][j]-dp[i][j+1]+mod)%mod;\n\t}\n\tint su=0;\n\tfor(int j=0;j<=ct+1;j++)su=(su+dp[n][j])%mod;\n\tas=1ll*as*su%mod;\n\tprintf(\"%d\\n\",as);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\n#include <stdlib.h>\n#include <vector>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <string.h>\n#include <stack>\n#define Endl endl\n#define mp make_pair\n#define ll long long \n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define over(A) {cout<<A<<endl;exit(0);}\n#define all(A) A.begin(),A.end()\n#define ceil(a,b) ((a-1)/b+1)\n#define srand() mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n#define rand(l,r) uniform_int_distribution<int>(l,r)(rng)\ntypedef unsigned long long ull;\nconst int inf=1039074182;\nusing namespace std;\nint n;\nint h[105];\nint res=1;\nvector <pair<pair<int,int>,int> >vec;\nint dp[105][105][2];\n\nnamespace combinatorics\n{\n\tint mod=1e9+7;\n\tinline int add(int a,int b)\n\t{\n\t\treturn (a+b)%mod;\n\t}\n\tinline int minus(int a,int b)\n\t{\n\t\treturn (a-b+mod)%mod;\n\t}\n\tinline int mutiply(int a,int b)\n\t{\n\t\treturn (1LL*a*b)%mod;\n\t}\n\tinline int fastpow(int basic,int x)\n\t{\n\t\tint res=1;\n\t\twhile(x)\n\t\t{\n\t\t\tif(x&1)\tres=mutiply(res,basic);\n\t\t\tbasic=mutiply(basic,basic);\n\t\t\tx>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tinline int inv(int x)\n\t{\n\t\treturn fastpow(x,mod-2);\n\t}\n};\nusing namespace combinatorics;\n\ninline void solve(int l,int r)\n{\n//\tcout<<l<<' '<<r<<endl;\n//\tSleep(1000);\n\tif(l==r) return;\n\tint mi=inf,ma=inf;\n\tfor(int i=l;i<r;i++)\n\t{\n\t\tmi=min(mi,h[i]);\n\t}\n\tvec.push_back({{l,r},mi-(l==0 && r==n)});\n\tfor(int i=l;i<r;i++)\n\t{\n\t\th[i]-=mi;\n\t}\n\tint last=l;\n\tfor(int i=l;i<=r;i++)\n\t{\n\t\tif(h[i]==0) solve(last,i),last=i+1;\n\t}\n}\n\ninline int way(int l,int r)\n{\n\tint res=0;\n\tfor(auto x:vec)\n\t{\n\t\tif(l<=x.first.first && r>=x.first.second) res=(res+x.second)%(mod-1);\n\t}\n\treturn fastpow(2,res);\n}\n\nint main()\n{\n\tfreopen(\"input.txt\",\"r\",stdin);\n//\tfreopen(\"1.out\",\"w\",stdout);\n\tcin>>n;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcin>>h[i];\n\t}\n\tsolve(0,n);\n//\tfor(auto x:vec)\n//\t{\n//\t\tprintf(\"From %d to %d, having %d floors.\\n\",x.first.first+1,x.first.second,x.second);\n//\t}\n\tdp[0][1][0]=1;\n\tdp[0][1][1]=1;\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tfor(int j=1;j<=i+1;j++)\n\t\t{\n\t\t\tfor(int k=0;k<2;k++)\n\t\t\t{\n\t\t\t\tdp[i+1][j+1][k]=add(dp[i+1][j+1][k],dp[i][j][k]);\n\t\t\t\tdp[i+1][1][!k]=add(dp[i+1][1][!k],mutiply(dp[i][j][k],way(i-j+1,i+1)));\n\t\t\t}\n\t\t}\n\t}\n\tint res=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tdp[n-1][i][0]=mutiply(dp[n-1][i][0],way(n-i,n));\n\t\tdp[n-1][i][1]=mutiply(dp[n-1][i][1],way(n-i,n));\n\t\tres=add(res,add(dp[n-1][i][0],dp[n-1][i][1]));\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<math.h>\n#include<ctype.h>\n#include<algorithm>\n#include<bitset>\n#include<cassert>\n#include<cctype>\n#include<cerrno>\n#include<cfloat>\n#include<ciso646>\n#include<climits>\n#include<clocale>\n#include<complex>\n#include<csetjmp>\n#include<csignal>\n#include<cstdarg>\n#include<cstddef>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<ctime>\n#include<cwchar>\n#include<cwctype>\n#include<deque>\n#include<exception>\n#include<fstream>\n#include<functional>\n#include<iomanip>\n#include<ios>\n#include<iosfwd>\n#include<iostream>\n#include<istream>\n#include<iterator>\n#include<limits>\n#include<list>\n#include<locale>\n#include<map>\n#include<memory>\n#include<new>\n#include<numeric>\n#include<ostream>\n#include<queue>\n#include<set>\n#include<sstream>\n#include<stack>\n#include<stdexcept>\n#include<streambuf>\n#include<string>\n#include<typeinfo>\n#include<utility>\n#include<valarray>\n#include<vector>\n#include<string.h>\n#include<stdlib.h>\n#include<stdio.h>\nusing namespace std;\nconst long long Mod=1e9+7;\nstruct node\n{\n\tlong long x,y;\n};\nint n,h[110];\nlong long pw(long long x,long long y)\n{\n\tlong long res=1;\n\twhile (y)\n\t{\n\t\tif (y&1)\n\t\t{\n\t\t\tres=res*x%Mod;\n\t\t}\n\t\ty>>=1;\n\t\tx=x*x%Mod;\n\t}\n\treturn res;\n}\nnode work(int l,int r,int lim)\n{\n\tnode res;\n\tif (l==r)\n\t{\n\t\tres.x=0;\n\t\tres.y=pw(2,h[l]-lim);\n\t\treturn res;\n\t}\n\tint mn=l;\n\tfor (int i=l+1;i<=r;i++)\n\t{\n\t\tif (h[i]<h[mn])\n\t\t{\n\t\t\tmn=i;\n\t\t}\n\t}\n\tnode x,y;\n\tif (mn==l)\n\t{\n\t\ty=work(mn+1,r,h[mn]);\n\t\tres.x=(y.x+y.y)*2%Mod;\n\t\tres.y=y.y*pw(2,h[mn]-lim)%Mod;\n\t}\n\telse if (mn==r)\n\t{\n\t\tx=work(l,mn-1,h[mn]);\n\t\tres.x=(x.x+x.y)*2%Mod;\n\t\tres.y=x.y*pw(2,h[mn]-lim)%Mod;\n\t}\n\telse\n\t{\n\t\tx=work(l,mn-1,h[mn]);\n\t\ty=work(mn+1,r,h[mn]);\n\t\tres.x=(x.x*y.x%Mod*2%Mod+x.x*y.y%Mod*4%Mod+x.y*y.x%Mod*4%Mod+x.y*y.y%Mod*6%Mod)%Mod;\n\t\tres.y=x.y*y.y%Mod*pw(2,h[mn]-lim)%Mod;\n\t}\n\treturn res;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&h[i]);\n\t}\n\tlong long ans;\n\tnode res=work(1,n,0);\n\tans=(res.x+res.y)%Mod;\n\tprintf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nconstexpr lint MOD = 1000000007;\n\nint N;\nvector<int> h;\n\nlint power(lint x, lint n)\n{\n    lint ans = 1;\n    while (n > 0)\n    {\n        if (n & 1)\n            ans = ans * x % MOD;\n        x = x * x % MOD;\n        n >>= 1;\n    }\n    return ans;\n}\n\nint main()\n{\n    cin >> N;\n    h.resize(N);\n    for (auto &val : h) cin >> val;\n\n    vector<lint> dp(N);\n    vector<vector<lint>> dpa(N, vector<lint>(N));\n    dp[0] = power(2, h[0]);\n    for (int i=0; i<N; i++)\n    {\n        dpa[0][i] = 2LL * power(2, h[0] - h[i]) % MOD;\n    }\n\n    for (int i = 1; i < N; i++)\n    {\n        dp[i] = dp[i - 1] * power(2, h[i] - h[i - 1]);\n        dp[i] += dpa[i - 1][i] * power(2, h[i] - h[i - 1]);\n        dp[i] %= MOD;\n        for (int j = 0; j < N; j++)\n        {\n            // 前の列の逆\n            if (h[i] <= h[i-1])\n            {\n                if (h[j] < h[i]) dpa[i][j] = dpa[i-1][j];\n                else dpa[i][j] = dpa[i-1][i];\n            }\n            else \n            {\n                if (h[i] > h[j])\n                {\n                    if (h[j] > h[i-1]) dpa[i][j] = dpa[i-1][j] * power(2, h[i] - h[j]);\n                    else dpa[i][j] = dpa[i-1][j] * power(2, h[i] - h[i-1]);\n                }\n                else dpa[i][j] = dpa[i - 1][j];\n            }\n\n            // 前の列と同じ\n            dpa[i][j] += dpa[i - 1][i] * power(2, h[i] - max(h[i - 1], h[j]));\n            dpa[i][j] %= MOD;\n        }\n    }\n    // cout << endl;\n    // for (auto vec : dpa)\n    // {\n    //     for (auto val : vec) cout << val << \" \";\n    //     cout << endl;\n    // }\n    // cout << endl;\n    // for (auto v : dp) cout << v << endl;\n    cout << dp[N - 1] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#include <windows.h>\nusing namespace std;\ntypedef long long LL;\nconst int mod = 1e9 + 7, MAX = 110;\nint n, h[MAX], pw[MAX];\ninline int add(int a, int b) {\n\treturn a + b >= mod ? a + b - mod : a + b;\n}\ninline int sub(int a, int b) {\n\treturn a >= b ? a - b : a - b + mod;\n}\ninline int mul(int a, int b) {\n\treturn LL(a) * b % mod;\n}\nint pm(int a, LL b) {\n\tif (b == 0) return 1;\n\tif (b & 1) return mul(a, pm(a, b - 1));\n\treturn pm(mul(a, a), b / 2);\n}\npair<int, int> solve(int a, int b, int s) {\n\tif (b - a == 1) {\n\t\tint w = pm(2, h[a] - s);\n\t\treturn make_pair(w, w);\n\t}\n\tint m = *min_element(h + a, h + b);\n\tvector <pair<int, int> > v;\n\tint i = a;\n\twhile (i < b) {\n\t\tint j = i;\n    \twhile (j < b && (h[i] == m) == (h[j] == m))\n\t\t\tj ++;\n    \tv.push_back(make_pair(i, j));\n    \ti = j;\n\t} \n\tint fT = 1, fA = 2;\n  \tfor (int i = 0; i < v.size(); i ++) {\n\t\tpair<int, int> p = v[i];\n\t    int x = p.first, y = p.second;\n\t    if (h[x] != m) {\n\t    \tpair <int,int> g = solve(x, y, m);\n\t    \tfT = mul(fT, add(g.first, g.second));\n\t    \tfA = mul(fA, g.first);\n\t    } else {\n\t    \tfT = mul(fT, pw[y - x]);\n\t    }\n\t}\n\tfT = sub(fT, fA);\n\tfA = mul(fA, pm(2, m - s - 1));\n\tfT = add(fT, fA);\n\treturn make_pair(fA, fT);\n}\nint main(void) {\n\tcin >> n;\n\t//DWORD start_time = GetTickCount();\n\tfor (int i = 0; i < n; i ++)\n\t\tcin >> h[i];\n\tpw[0] = 1;\n\tfor (int i = 0; i < n; i ++)\n\t\tpw[i + 1] = mul(pw[i], 2);\n\tpair <int, int> g = solve(0, n, 0);\n\tcout << g.second << endl;\n\t//DWORD end_time = GetTickCount();\n\t//cout << \"Time costed : \" << (end_time - start_time)  << \".ms\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <fstream>\n#include <iostream>\n#include <algorithm>\n#include <bitset>\n#include <array>\n#include <vector>\n#include <queue>\n#include <set>\n#include <cmath> // 変数名にy1が使えなくなるかも…。\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <string>\n\ntypedef __int128_t int128_t;\nstd::istream &operator>>(std::istream& input, int128_t& value) { // int128_tの入力。入力が64bitに収まる前提。\n    long long tmp; input >> tmp; value = tmp;\n    return input;\n}\nstd::ostream &operator<<(std::ostream& output, const int128_t value) { // int128_tの出力。出力が64bitに収まる前提。\n    output << (long long)value;\n    return output;\n}\n\nint128_t cal_mod(const int128_t n, const int128_t mod) {\n    // n % modを計算する。ただしmod <= 0 ならば何もしない。nが負の場合、正にして補正する。\n    if (mod <= 0) {\n        return n;\n    } else if (0 <= n) {\n        return n % mod;\n    } else {\n        int128_t tmp = (-n) / mod + 1;\n        return (n + tmp * mod) % mod;\n    }\n}\n\nint128_t pow_mod(int128_t x, int128_t n, const int128_t mod) {\n    // 累乗の計算。mod <= 0ならば余りの計算は行わない。\n    int128_t ret = 1;\n    while (n > 0) {\n        if (n & 1) { ret = cal_mod(ret * x, mod); }\n        x = cal_mod(x * x, mod);\n        n = (n >> 1);\n    }\n    return ret;\n}\n\nconst int MOD = 1e9 + 7;\nconst int MAX_H = 1e9 + 7;\nconst int MAX_N = 110;\nint N;\nint128_t h[MAX_N];\n\nint128_t s[MAX_N]; // s[i]:i番目に低い山（高さ2以上）の高さ。\nstd::map<int128_t, int> mp; // 2以上の高さに対して、何番目に低いか。\n\nint128_t dp[MAX_N][MAX_N] = {};\n// dp[i][j] : i番目の列まで塗終わり、その列で最初に現れる連続同色がs[j]の高さに収まる(s[j-1]には収まらない)塗り方の数。\n// dp[i][0] は、連続同色が現れない塗り方。\n\nint128_t calc_sub(int128_t h1, int128_t h2) {\n    // h1まで交互に塗った1つの塗り方に対して、h2までに連続塗りを含む塗り方がいくつあるか。\n    return cal_mod(pow_mod(2, h2 - h1, MOD) - 1, MOD);\n}\n\nint main(int argc, char **argv) {\n    std::cin >> N;\n    \n    for (int i = 1; i <= N; i++) {\n        std::cin >> h[i];\n    }\n\n    for (int i = 1; i <= N; i++) {\n        if (1 < h[i]) {\n            mp[h[i]] = 1;\n        }\n    }\n    int cnt = 1;\n    for (auto itr = mp.begin(); itr != mp.end(); ++itr) {\n        mp[itr->first] = cnt;\n        s[cnt] = itr->first;\n        cnt++;\n    }\n    s[0] = 1;\n    s[cnt] = MAX_H;\n    dp[0][0] = 1;\n\n    //std::cout << \"check:\" << s[0] << \" \" << s[1] << \" \" << s[2] << \" \" << s[3] << std::endl;\n\n    for (int i = 1; i <= N; i++) {\n        if (h[i] == 1) {\n            for (int j = 0; j < cnt; j++) {\n                dp[i][0] = (dp[i][0] + dp[i-1][j] * 2) % MOD;\n            }\n        } else if (i == 1 || h[i-1] == 1) {\n            dp[i][0] = dp[i-1][0] * 2;\n            for (int j = 1; s[j] <= h[i]; j++) {\n                dp[i][j] = (dp[i-1][0] * 2 * calc_sub(s[j-1], s[j]) * pow_mod(2, h[i] - s[j], MOD)) % MOD;\n            }\n        } else {\n            dp[i][0] = dp[i-1][0] * 2;\n            if (h[i] <= h[i-1]) {\n                for (int j = 1; s[j] <= h[i-1]; j++) {\n                    if (s[j] <= h[i]) {\n                        dp[i][j] = dp[i-1][j];\n                    } else {\n                        dp[i][0] = (dp[i][0] + dp[i-1][j] * 2) % MOD;\n                    }\n                }\n            } else {\n                for (int j = 1; s[j] <= h[i]; j++) {\n                    if (s[j] <= h[i-1]) {\n                        dp[i][j] = (dp[i-1][j] * pow_mod(2, h[i] - h[i-1], MOD)) % MOD;\n                    } else {\n                        dp[i][j] = (dp[i-1][0] * 2 * calc_sub(s[j-1], s[j]) * pow_mod(2, h[i] - s[j], MOD)) % MOD;\n                    }\n                }\n            }\n        }\n        //std::cout << \"dp:\" << dp[i][0] << \" \" << dp[i][1] << \" \" << dp[i][2] << std::endl;\n    }\n\n    int128_t ret = 0;\n    for (int j = 0; s[j] <= h[N]; j++) {\n        ret = (ret + dp[N][j]) % MOD;\n    }\n    std::cout << ret << std::endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n\ntypedef long long LL;\n\nconst int N=105;\nconst int MOD=1000000007;\n\nint n,f[N][N],h[N],w[N],m;\n\nint ksm(int x,int y)\n{\n    if (y<0) return 1;\n    int ans=1;\n    while (y)\n    {\n        if (y&1) ans=(LL)ans*x%MOD;\n        x=(LL)x*x%MOD;y>>=1;\n    }\n    return ans;\n}\n\nint main()\n{\n    scanf(\"%d\",&n);\n    for (int i=1;i<=n;i++) scanf(\"%d\",&h[i]),w[++m]=h[i];\n    std::sort(w+1,w+m+1);\n    m=std::unique(w+1,w+m+1)-w-1;\n    for (int i=1;i<=n;i++) h[i]=std::lower_bound(w+1,w+m+1,h[i])-w;\n    f[0][0]=1;\n    for (int i=1;i<=n;i++)\n    {\n        for (int j=h[i]+1;j<=h[i-1];j++) (f[i][0]+=f[i-1][j]*2%MOD)%=MOD;\n        (f[i][0]+=f[i-1][0]*2%MOD)%=MOD;\n        for (int j=1;j<=h[i];j++)\n        {\n            f[i][j]=(LL)f[i-1][j]*ksm(2,w[h[i]]-w[h[i-1]])%MOD;\n            if (h[i-1]>=j) continue;\n            if (j>1) (f[i][j]+=(LL)f[i-1][0]*(ksm(2,w[j]-w[j-1])-1)%MOD*2%MOD*ksm(2,w[h[i]]-w[j])%MOD)%=MOD;\n            else (f[i][j]+=(LL)f[i-1][0]*(ksm(2,w[j])-2)%MOD*ksm(2,w[h[i]]-w[j])%MOD)%=MOD;\n        }\n    }\n    \n    \n    int ans=0;\n    for (int i=0;i<=m;i++) (ans+=f[n][i])%=MOD;\n    printf(\"%d\",ans);\n    return 0;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing std::pair;\nusing std::vector;\nusing std::string;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n#define fst first\n#define snd second\n#define pb(a) push_back(a)\n#define mp(a, b) std::make_pair(a, b)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\ntemplate <typename T> bool chkmax(T& a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> bool chkmin(T& a, T b) { return a > b ? a = b, 1 : 0; }\n\nconst int oo = 0x3f3f3f3f;\n\nstring procStatus() {\n    std::ifstream t(\"/proc/self/status\");\n    return string(std::istreambuf_iterator<char>(t), std::istreambuf_iterator<char>());\n}\n\ntemplate <typename T> T read(T& x) {\n    int f = 1; x = 0;\n    char ch = getchar();\n    for(;!isdigit(ch); ch = getchar()) if(ch == '-') f = -1;\n    for(; isdigit(ch); ch = getchar()) x = x * 10 + ch - 48;\n    return x *= f;\n}\n\nconst int N = 100;\nconst int mo = 1e9 + 7;\n\ninline int fpm(int x, int y) {\n    int res = 1;\n    for(; y > 0; y >>= 1) {\n        if(y & 1)\n            res = (ll) res * x % mo;\n        x = (ll) x * x % mo;\n    }\n    return res;\n}\n\nint n;\nint a[N + 5], cnt;\nint dp[N + 5][2];\n\ninline void add(int &x, int y) {\n    (x += y) >= mo ? x -= mo : 0;\n}\n\npii solve(int l, int r, int base = 0) {\n    if(l == r) {\n        return mp(fpm(2, a[l] - base), 0);\n    }\n\n    int mn = oo;\n    int u = ++ cnt;\n\n    dp[u][0] = 1;\n    for(int i = l; i <= r; ++i) { chkmin(mn, a[i]); }\n    for(int i = l; i <= r; ++i) {\n        if(a[i] > mn) {\n            int j = i;\n            while(j + 1 <= r && a[j + 1] > mn) { ++ j; }\n            pii temp = solve(i, j, mn);\n\n            if(i != l) {\n                dp[u][1] = ((ll) dp[u][1] * (temp.snd + 2ll * temp.fst) % mo + \n                           (ll) dp[u][0] * (temp.snd + temp.fst) % mo) % mo;\n                dp[u][0] = (ll) dp[u][0] * temp.fst % mo;\n            } else {\n                dp[u][1] = temp.snd;\n                dp[u][0] = (ll) dp[u][0] * (2ll * temp.fst) % mo;\n            }\n\n            i = j;\n        } else {\n            if(i != l) {\n                dp[u][1] = ((ll) dp[u][1] * 2 + dp[u][0]) % mo;\n            } else {\n                dp[u][0] = 2;\n            }\n        }\n    }\n\n    return mp((ll) dp[u][0] * fpm(2, mn - base - 1) % mo, dp[u][1]);\n}\n\nint main() {\n#ifdef Wearry\n    freopen(\"in\", \"r\", stdin);\n    freopen(\"out\", \"w\", stdout);\n#endif\n\n    read(n);\n    for(int i = 1; i <= n; ++i) read(a[i]);\n\n    pii ans = solve(1, n);\n    printf(\"%d\\n\", (ans.fst + ans.snd) % mo);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// sto boshi\n#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n\nnamespace IO {\n    template <typename _T>\n    inline bool read (_T& x) {\n        x = 0;\n        _T y = 1;\n        char c = getchar();\n        while ((c < '0' || '9' < c) && c != EOF) {\n            if (c == '-') y = -1;\n            c = getchar();\n        }\n        if (c == EOF) return false;\n        while ('0' <= c && c <= '9') x = x * 10 + c - '0', c = getchar();\n        x *= y;\n        return true;\n    }\n\n    template <typename _T>\n    inline _T input () {\n        _T x = 0, y = 1;\n        char c = getchar();\n        while ((c < '0' || '9' < c) && c != EOF) {\n            if (c == '-') y = -1;\n            c = getchar();\n        }\n        if (c == EOF) return 0;\n        while ('0' <= c && c <= '9') x = x * 10 + c - '0', c = getchar();\n        x *= y;\n        return x;\n    }\n};\nusing namespace IO;\n\n#define reg register\n#define MAX_N 200007\n#define MOD 1000000007\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define rep(i, l, r) for(int i = l; i <= r; ++i)\n#define lep(i, l, r) for(int i = l; i < r; ++i)\n#define irep(i, r, l) for(int i = r; i >= l; --i)\n#define ilep(i, r, l) for(int i = r; i > l; --i)\ntypedef long long ll;\n\nint N;\nint a[MAX_N], h[MAX_N], mn[MAX_N];\nint L[MAX_N], R[MAX_N];\nint f[MAX_N][2][2][2];\n\ninline int add (int x, int y) { return (x += y) >= MOD ? x - MOD : x; }\n\ninline void inc (int &x, int y) { (x += y) >= MOD ? x -= MOD : 0; }\n\ninline int mul (int x, int y) { return 1LL * x * y % MOD; }\n\ninline int qpow (int x, int y) {\n    int ans = 1;\n    for (; y; y >>= 1, x = mul(x, x)) if (y & 1) ans = mul(ans ,x);\n    return ans;\n}\n\nbool cmp (int a, int b) { return h[a] > h[b]; }\n\ninline void update (int a[2][2][2], int g[2][2][2], int delt) {\n    int f[2][2][2];\n    memset(f, 0, sizeof(f));\n    lep (i, 0, 2) {\n        lep (j, 0, 2) {\n            if (delt) {\n                inc(f[i][j][0], mul(a[i][j][0], qpow(2, delt - 1)));\n                inc(f[i ^ 1][j ^ 1][0], mul(a[i][j][0], qpow(2, delt - 1)));\n            } else inc(f[i][j][0], a[i][j][0]);\n            inc(f[i ^ (delt & 1)][j ^ (delt & 1)][1], a[i][j][1]);\n        }\n    }\n    memmove(g, f, sizeof(f));\n}\n\ninline void merge (int a[2][2][2], int b[2][2][2], int g[2][2][2]) {\n    int f[2][2][2];\n    memset(f, 0, sizeof(f));\n    lep (ai, 0, 2) {\n        lep (aj, 0, 2) {\n            lep (sa, 0, 2) if (a[ai][aj][sa]) {\n                lep (bi, 0, 2) {\n                    lep (bj, 0, 2) {\n                        lep (sb, 0, 2) if (b[bi][bj][sb]) {\n                            inc(f[ai][bj][sa | sb | (aj == bi)],\n                                mul(a[ai][aj][sa], b[bi][bj][sb]));\n                        }\n                    }\n                }\n            }\n        }\n    }\n    memmove(g, f, sizeof(f));\n}\n\ninline void solve () {\n    rep (i, 1, N) {\n        int x = a[i];\n        if (!L[x - 1] && !R[x + 1]) {\n            f[x][0][0][0] = f[x][1][1][0] = 1;\n            L[x] = R[x] = x;\n            mn[x] = h[x];\n        } else if (!L[x - 1] && R[x + 1]) {\n            update(f[x + 1], f[x + 1], mn[x + 1] - h[x]);\n            f[x][0][0][0] = f[x][1][1][0] = 1;\n            R[x] = R[x + 1];\n            L[R[x]] = x;\n            merge(f[x], f[x + 1], f[x]);\n            memmove(f[R[x]], f[x], sizeof(f[x]));\n            mn[x] = mn[R[x]] = h[x];\n        } else if (L[x - 1] && !R[x + 1]) {\n            update(f[x - 1], f[x - 1], mn[x - 1] - h[x]);\n            f[x][0][0][0] = f[x][1][1][0] = 1;\n            L[x] = L[x - 1];\n            R[L[x]] = x;\n            merge(f[x - 1], f[x], f[x]);\n            memmove(f[L[x]], f[x], sizeof(f[x]));\n            mn[x] = mn[L[x]] = h[x];\n        } else {\n            update(f[x + 1], f[x + 1], mn[x + 1] - h[x]);\n            update(f[x - 1], f[x - 1], mn[x - 1] - h[x]);\n            f[x][0][0][0] = f[x][1][1][0] = 1;\n            merge(f[x], f[x + 1], f[x]);\n            merge(f[x - 1], f[x], f[x - 1]);\n            L[x] = L[x - 1], R[x] = R[x + 1];\n            R[L[x]] = R[x], L[R[x]] = L[x];\n            memmove(f[L[x]], f[x - 1], sizeof(f[x - 1]));\n            memmove(f[R[x]], f[x - 1], sizeof(f[x - 1]));\n            mn[L[x]] = mn[R[x]] = h[x];\n        }\n    }\n    // 这里之前忘记了\n    update(f[1], f[1], mn[1] - 1);\n    \n    int res = 0;\n    lep (i, 0, 2) lep (j, 0, 2) lep (k, 0, 2) inc(res, f[1][i][j][k]);\n    printf(\"%d\\n\", res);\n}\n\nint main() {\n#ifdef LOCAL\n    freopen(\"1.in\", \"r\", stdin);\n#endif\n    read(N);\n    rep(i, 1, N) read(h[i]), a[i] = i;\n    std::sort(a + 1, a + N + 1, cmp);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100, mod = 1000000007, inf = 0x3f3f3f3f;\nint n, h[maxn + 10], ans;\nint f[maxn + 10][maxn + 10][2][2][2], tmp[2][2][2];\nint add(int x, int y) {\n\tx += y; return x < mod ? x : x - mod;\n}\nint dec(int x, int y) {\n\tx -= y; return x < 0 ? x + mod : x;\n}\nint mul(int x, int y) {\n\treturn 1ll * x * y % mod;\n}\nint fpow(int x, int y) {\n\tint ans = 1;\n\twhile (y) {\n\t\tif (y & 1) ans = mul(ans, x);\n\t\ty >>= 1; x = mul(x, x);\n\t}\n\treturn ans;\n}\n\nint calcmin(int l, int r) {\n\tint ans = inf;\n\tfor (int i = l; i <= r; ++i) ans = min(ans, h[i]);\n\treturn ans;\n}\n\nvoid upd(int l, int r, int h) {\n\tfor (int i = 0; i < 2; ++i)\n\t\tfor (int j = 0; j < 2; ++j)\n\t\t\tfor (int k = 0; k < 2; ++k)\n\t\t\t\ttmp[i][j][k] = 0;\n\tfor (int i = 0; i < 2; ++i)\n\t\tfor (int j = 0; j < 2; ++j) {\n\t\t\tif (h) {\n\t\t\t\ttmp[i][j][0] = add(tmp[i][j][0], mul(f[l][r][i][j][0], fpow(2, h - 1)));\n\t\t\t\ttmp[j][i][0] = add(tmp[j][i][0], mul(f[l][r][i][j][0], fpow(2, h - 1)));\n\t\t\t} else tmp[i][j][0] = add(tmp[i][j][0], f[l][r][i][j][0]);\n\t\t\tif (h & 1) tmp[i ^ 1][j ^ 1][1] = add(tmp[i ^ 1][j ^ 1][1], f[l][r][i][j][1]);\n\t\t\telse tmp[i][j][1] = add(tmp[i][j][1], f[l][r][i][j][1]);\n\t\t}\n\tfor (int i = 0; i < 2; ++i)\n\t\tfor (int j = 0; j < 2; ++j)\n\t\t\tfor (int k = 0; k < 2; ++k)\n\t\t\t\tf[l][r][i][j][k] = tmp[i][j][k];\n}\n\nvoid merge(int l, int r, int ll, int rr) {\n\tfor (int i = 0; i < 2; ++i)\n\t\tfor (int j = 0; j < 2; ++j)\n\t\t\tfor (int k = 0; k < 2; ++k)\n\t\t\t\ttmp[i][j][k] = 0;\n\tfor (int i = 0; i < 2; ++i)\n\t\tfor (int j = 0; j < 2; ++j)\n\t\t\tfor (int k = 0; k < 2; ++k)\n\t\t\t\tfor (int s = 0; s < 2; ++s)\n\t\t\t\t\tfor (int p = 0; p < 2; ++p)\n\t\t\t\t\t\tfor (int q = 0; q < 2; ++q) {\n\t\t\t\t\t\t\tint st = i, ed = p, t = k || q || (j == s);\n\t\t\t\t\t\t\ttmp[st][ed][t] = add(tmp[st][ed][t], mul(f[l][r][i][j][k], f[ll][rr][s][p][q]));\n\t\t\t\t\t\t}\n\tfor (int i = 0; i < 2; ++i)\n\t\tfor (int j = 0; j < 2; ++j)\n\t\t\tfor (int k = 0; k < 2; ++k)\n\t\t\t\tf[l][r][i][j][k] = tmp[i][j][k];\n}\n\nvoid dp(int l, int r) {\n\tif (l == r) {\n\t\tf[l][r][0][0][0] = f[l][r][1][1][0] = 1;\n\t} else {\n\t\tint minv = calcmin(l, r);\n\t\tint lst = l - 1;\n\t\tvector<pair<int, int> > vec;\n\t\tfor (int i = l; i <= r; ++i)\n\t\t\tif (h[i] == minv) {\n\t\t\t\tif (lst + 1 <= i - 1) vec.push_back(make_pair(lst + 1, i - 1));\n\t\t\t\tvec.push_back(make_pair(i, i)); lst = i;\n\t\t\t}\n\t\tif (lst < r) vec.push_back(make_pair(lst + 1, r));\n\t\tfor (int i = 0; i < vec.size(); ++i) {\n\t\t\tpair<int, int> e = vec[i];\n\t\t\tdp(e.first, e.second);\n\t\t\tupd(e.first, e.second, calcmin(e.first, e.second) - minv);\n\t\t\tif (i) merge(l, r, e.first, e.second);\n\t\t\telse {\n\t\t\t\tfor (int j = 0; j < 2; ++j)\n\t\t\t\t\tfor (int k = 0; k < 2; ++k)\n\t\t\t\t\t\tfor (int s = 0; s < 2; ++s)\n\t\t\t\t\t\t\tf[l][r][j][k][s] = f[e.first][e.second][j][k][s];\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i) scanf(\"%d\", &h[i]);\n\tdp(1, n);\n\tupd(1, n, calcmin(1, n) - 1);\n\tfor (int i = 0; i < 2; ++i)\n\t\tfor (int j = 0; j < 2; ++j)\n\t\t\tfor (int k = 0; k < 2; ++k)\n\t\t\t\tans = add(ans, f[1][n][i][j][k]);\n\tprintf(\"%d\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nint N;\nint H[105];\nll mo=1000000007;\n\nll modpow(ll a, ll n = mo-2) {\n\tll r=1;a%=mo;\n\twhile(n) r=r*((n%2)?a:1)%mo,a=a*a%mo,n>>=1;\n\treturn r;\n}\n\npair<ll,ll> hoge(int L,int R,int v) {\n\tll dp1=1,dp2=1;\n\tint i;\n\t\n\tif(L>R) return {0,0};\n\t\n\tint mi=1<<30;\n\tfor(i=L;i<=R;i++) mi=min(mi,H[i]);\n\tint W=R-L+1;\n\tfor(i=L;i<=R;i++) if(mi!=H[i]) W--;\n\t\n\tint pre=L-1;\n\tfor(i=L;i<=R;i++) {\n\t\tif(mi==H[i]) {\n\t\t\tauto r=hoge(pre+1,i-1,mi);\n\t\t\tif(r.first>0) {\n\t\t\t\t(dp1*=r.first)%=mo;\n\t\t\t\t(dp2*=r.first+r.second)%=mo;\n\t\t\t}\n\t\t\t\n\t\t\tpre=i;\n\t\t}\n\t}\n\tauto r=hoge(pre+1,R,mi);\n\tif(r.first > 0) {\n\t\t(dp1*=r.first)%=mo;\n\t\t(dp2*=r.first+r.second)%=mo;\n\t}\nj\n\t(dp2=dp2*modpow(2,W)+(modpow(2,mi-v)+mo-2)*dp1)%=mo;\n\t(dp1*=modpow(2,mi-v))%=mo;\n\t\n\treturn {dp1,dp2};\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tfor(i=1;i<=N;i++) cin>>H[i];\n\tcout<<hoge(1,N,0).second<<endl;\n}\n\nint main()\n{\n        solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int md = (int) 1e9 + 7;\n\ninline int add(int x, int y) {\n  x += y;\n  if (x >= md) x -= md;\n  if (x < 0) x += md;\n  return x;\n}\n\ninline int mul(int x, int y) {\n  return 1ll * x * y % md;\n}\n\ninline int power(int x, int y) {\n  int r = 1;\n  while (y > 0) {\n    if (y & 1) r = mul(r, x);\n    x = mul(x, x);\n    y >>= 1;\n  }\n  return r;\n}\n\nconst int N = 105;\n\nint dp[N][N];\n\nint main() {\n  int n;\n  cin >> n;\n  vector<int> a(n + 1, 1);\n  for (int i = 1; i <= n; i++) {\n    cin >> a[i];\n  }\n  dp[0][0] = 1;\n  for (int i = 1; i <= n; i++) {\n    for (int j = 0; j <= n; j++) {\n      if (a[j] > a[i]) continue;\n      if (a[j] < a[i - 1]) {\n        int bef = (a[i] < a[i - 1] ? i : i - 1);\n        dp[i][j] = mul(add(dp[i - 1][j], dp[i - 1][bef]), power(2, a[i] - a[i - 1]));\n      } else {\n        dp[i][j] = mul(2 * dp[i - 1][i - 1], power(2, a[i] - a[j]));\n      }\n    }\n  }\n  cout << dp[n][0] << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 1'000'000'007;\nint mul(long long a, long long b){\n\treturn a * b % mod;\n}\nint xp(long long a, long long b){\n\ta %= mod;\n\tint r = 1;\n\tfor(; b; b >>= 1, a = mul(a, a)) if(b&1) r = mul(r, a);\n\treturn r;\n}\nusing pii = pair<int,int>;\npii solve(vector<int> f){\n\tint h = *min_element(f.begin(), f.end());\n\tvector<pii> sub;\n\tvector<int> smp;\n\tint miss = 0;\n\tfor(int v : f){\n\t\tif(v > h){\n\t\t\tsmp.push_back(v - h);\n\t\t} else {\n\t\t\tmiss++;\n\t\t\tif(!smp.empty()){\n\t\t\t\tsub.push_back(solve(smp));\n\t\t\t}\n\t\t\tsmp.clear();\n\t\t}\n\t}\n\tif(!smp.empty()) sub.push_back(solve(smp));\n\tpii now = {1, 1};\n\tfor(pii p : sub) now.first = mul(now.first, p.first);\n\tfor(pii p : sub) now.second = mul(now.second, p.first + p.second);\n\tnow.second = mul(now.second, xp(2, miss));\n\tnow.second += mod - mul(2, now.first); if(now.second >= mod) now.second -= mod;\n\tnow.first = mul(now.first, xp(2, h));\n\tnow.second += now.first; if(now.second >= mod) now.second -= mod;\n\treturn now;\n}\nint main(){\n\tint n; cin >> n;\n\tvector<int> a(n);\n\tfor(int i = 0; i < n; i++) cin >> a[i];\n\tcout << solve(a).second << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#define Starseven main\n#define ll long long\nnamespace lyt {\n\tvoid read(int &x){\n\tchar ch=getchar();int re=0,op=1;\n\twhile(ch<'0'||ch>'9'){if(ch=='-') op=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){re=(re<<3)+(re<<1)+ch-'0';ch=getchar();}\n\tx = re * op;\n\treturn ;\n\t}\n\tvoid read(long long &x){\n\tchar ch=getchar();long long re=0,op=1;\n\twhile(ch<'0'||ch>'9'){if(ch=='-') op=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){re=(re<<3ll)+(re<<1ll)+ch-'0';ch=getchar();}\n\tx = re * op;\n\treturn ;\n\t}\n\tvoid write(int x){\n\t\tif(x<0){putchar('-');x=-x;}\n\t\tif(x>9) write(x/10);\n\t\tputchar(x%10+'0');\n\t\treturn ;\n\t}//¼ÇµÃ×Ô¼º¼Ó¿Õ¸ñºÍ»»ÐÐ \n\tvoid write(long long x){\n\t\tif(x<0){putchar('-');x=-x;}\n\t\tif(x>9) write(x/10);\n\t\tputchar(x%10+'0');\n\t\treturn ;\n\t}//¼ÇµÃ×Ô¼º¼Ó¿Õ¸ñºÍ»»ÐÐ\n\tint max(int x,int y){return x<y?y:x;}\n\tint min(int x,int y){return x<y?x:y;}\n\tint abs(int x){return x<0?-x:x;}\n\tlong long max(long long x,long long y){return x<y?y:x;}\n\tlong long min(long long x,long long y){return x<y?x:y;}\n\tlong long abs(long long x){return x<0?-x:x;}\n\tdouble max(double x,double y){return x<y?y:x;}\n\tdouble min(double x,double y){return x<y?x:y;}\n\tdouble abs(double x){return x<0?-x:x;}\n\tvoid swap(int &a,int &b) {a ^= b ^= a ^= b;}\n\tvoid swap(long long &a,long long &b) {a ^= b ^= a ^= b;}\n\tll Power(ll a, ll b, ll p) {\n\t\tll re = 1;\n\t\twhile(b) {\n\t\t\tif(b & 1ll) re = (re * a) % p;\n\t\t\tb >>= 1ll;\n\t\t\ta = (a * a) % p; \n\t\t}\n\t\treturn re;\n\t}\n\tint Power(int a, int b, int p) {\n\t\tint re = 1;\n\t\twhile(b) {\n\t\t\tif(b & 1) re = 1ll * re * a % p;\n\t\t\tb >>= 1;\n\t\t\ta = 1ll * a * a % p; \n\t\t}\n\t\treturn re;\n\t}\n}using namespace lyt;\nconst int mod = 1e9 + 7;\nconst int N = 1e2 + 20;\nint va[N], minn[N][N];\n\nstruct xyx {\n\tint res1, res2;\n};\n\nxyx Dfs(int l, int r, int pre_dep) {\n\tint judge = minn[l][r], num = 0;\n\txyx re;\n\tstd::vector<int> v;\n\tv.push_back(l - 1);\n\tfor (int i = l; i <= r; i++) {\n\t\tif(va[i] == judge) {\n\t\t\tv.push_back(i);\n\t\t\tnum++;\n\t\t}\n\t}\n\tv.push_back(r + 1);\n\tif(num == r - l + 1) {\n\t\tre.res1 = Power(2, minn[l][r] - pre_dep, mod);\n\t\tre.res2 = (Power(2, r - l + 1, mod) - 2) % mod;\n\t\tre.res2 = (re.res2 + mod) % mod;\n\t\treturn re;\n\t}// if it's a rectangle\n\tre.res1 = re.res2 = 1;\n\tfor (int i = 0; i < num + 1; i++) {\n\t\tif(v[i] + 1 >= v[i + 1]) continue;\n\t\txyx hack = Dfs(v[i] + 1, v[i + 1] - 1, judge);\n\t\tre.res1 = 1ll * re.res1 * hack.res1 % mod;\n\t\tre.res2 = re.res2 * (hack.res2 + hack.res1 * 2 % mod) % mod;\n\t}\n\txyx ans;\n\tans.res1 = Power(2, judge - pre_dep, mod) * re.res1;\n\tans.res2 = (Power(2, num, mod) * re.res2 % mod + (mod - 2ll * re.res1) % mod) % mod;\n\treturn ans;\n}\n\nint Starseven(void) {\n\tint n;\n\tread(n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tread(va[i]);\n\t}\n\tif(n == 1) {\n\t\tint ans = Power(2, va[1], mod);\n\t\twrite(ans);\n\t\tputs(\"\");\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tminn[i][i] = va[i];\n\t\tfor (int j = i + 1; j <= n; j++) {\n\t\t\tminn[i][j] = min(minn[i][j - 1], va[j]);\n\t\t}\n\t}\n\txyx ans = Dfs(1, n, 0);\n\tans.res1 = 1ll * (ans.res1 + ans.res2) % mod;\n\twrite(ans.res1);\n\tputs(\"\");\n\treturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h> \n#define ll long long\n#define N 105\n#define mod 1000000007\nusing namespace std;\nint n,f[N][N],h[N],w[N],tot;\ninline int ksm(int x,int p){\n\tif(p<0)return 1;\n\tint ret=1;\n\twhile(p){\n\t\tif(p&1)ret=ret*x%mod;\n\t\tx=x*x%mod;\n\t\tp>>=1;\n\t}\n\treturn ret;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i)scanf(\"%d\",&h[i]),w[++tot]=h[i];\n\tsort(w+1,w+tot+1);\n\ttot=unique(w+1,w+tot+1)-w-1;\n\tfor(int i=1;i<=n;++i)h[i]=lower_bound(w+1,w+tot+1,h[i])-w;\n\tf[0][0]=1;\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=h[i]+1;j<=h[i-1];++j)(f[i][0]+=f[i-1][j]*2%mod)%=mod;\n\t\t(f[i][0]+=f[i-1][0]*2%mod)%=mod;\n\t\tfor(int j=1;j<=h[i];++j){\n\t\t\tf[i][j]=(ll)f[i-1][j]*ksm(2,w[h[i]]-w[h[i-1]])%mod;\n\t\t\tif(h[i-1]>=j)continue;\n\t\t\tif(j>1)(f[i][j]+=(ll)f[i-1][0]*(ksm(2,w[j]-w[j-1])-1)%mod*2%mod)%=mod;\n\t\t\telse (f[i][j]+=(ll)f[i-1][0]*(ksm(2,w[j])-2)%mod*ksm(2,w[h[i]]-w[j])%mod)%=mod;\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=0;i<=tot;++i)(ans+=f[n][i])%=mod;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Ala be zekrellah tatmaenolgholoob ...\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define F first\n#define S second\n#define MP make_pair\nconst int maxn = 100+9;\nconst ll mod = 1e9+7;\n\nset <int> st;\nmap <int,int> mp;\nll dp[maxn][maxn];\nint h[maxn], val[maxn], len[maxn];\n\nll cal (ll x, ll p) {\n\tif (p == 0)\n\t\treturn 1;\n\tll res = cal(x, p / 2);\n\tres = (res * res) % mod;\n\tif (p % 2)\n\t\tres = res * x % mod;\n\treturn res;\n}\n\nint main () {\n\tios::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\tint n, num = 1;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> h[i];\n\t\tst.insert(h[i]);\n\t}\n\tint last = 0;\n\tfor (auto x : st) {\n\t\tval[num] = x;\n\t\tlen[num] = x - last;\n\t\tmp[x] = num;\n\t\tnum++;\n\t\tlast = x;\n\t}\n\t// base\n\tdp[0][0] = 2;\n\tfor (int i = 1; i <= mp[h[0]]; i++) {\n\t\tif (val[i] == 1)\n\t\t\tcontinue;\n\t\tll cur = cal(2, h[0] - val[i] + 1) * (cal(2, len[i]) - 1) % mod;\n\t\tif (i == 1)\n\t\t\tcur = cal(2, h[0] - val[i]) * (cal(2, len[i]) - 2) % mod;\n\t\tcur = (cur + mod) % mod;\n\t\tdp[0][i] = cur;\n\t}\n\tfor (int i = 1; i < n; i++) {\n\t\t// dp[i][0]\n\t\tdp[i][0] = dp[i - 1][0] * 2 % mod;\n\t\tfor (int t = mp[h[i]] + 1; t < maxn; t++)\n\t\t\tdp[i][0] = (dp[i][0] + dp[i - 1][t] * 2 % mod) % mod;\n\t\t// dp[i][a]\n\t\tfor (int t = 1; t <= mp[h[i]]; t++)\n\t\t\tdp[i][t] = dp[i - 1][t] * cal(2, max(h[i] - h[i - 1], 0)) % mod;\n\t\tif (h[i] <= h[i - 1])\n\t\t\tcontinue;\n\t\tll f = dp[i - 1][0];\n\t\tfor (int t = mp[h[i - 1]] + 1; t <= mp[h[i]]; t++)\n\t\t\tdp[i][t] = f * cal(2, h[i] - val[t] + 1) % mod * (cal(2, len[t]) - 1) % mod;\n\t}\n\t// ans\n\tll res = 0;\n\tfor (int i = 0; i < maxn; i++)\n\t\tres = (res + dp[n - 1][i]) % mod;\n\tcout << res << \"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll; \nconst ll MOD=1e9+7;\nll mypow(int x){\n\tll res=1,ans=2;\n\twhile (x>0){\n\t\tif (x%2==1){\n\t\t\tx--;\n\t\t\tres*=ans;\n\t\t\tres%=MOD; \n\t\t\tcontinue;\n\t\t}\n\t\tans*=ans;\n\t\tans%=MOD;\n\t\tx/=2;\n\t}\n\treturn res;\n}\nint n,a[103];\nll dp[103][103],ans=0;\nvector<int>v;\nmap <int,int> vis;\nmap <int,int> mp;\nint main(){\n\tcin>>n;\n\tfor (int i=1;i<=n;i++){\n\t\tcin>>a[i];\n\t\tif (vis[a[i]]) continue;\n\t\tv.push_back(a[i]);\n\t\tvis[a[i]]=1;\n\t}\n\tv.push_back(0);\n\tsort (v.begin(),v.end());\n\tfor (int i=0;i<v.size();i++)\n\t\tmp[v[i]]=i;\n\tdp[1][0]=(mypow(v[1]-v[0])-2)%MOD*mypow(a[1]-v[1])%MOD;\n\tfor (int i=1;i<mp[a[1]];i++) dp[1][i]=2*(mypow(v[i+1]-v[i])-1)%MOD*mypow(a[1]-v[i+1])%MOD;\n\tdp[1][mp[a[1]]]=2;\n\tfor (int i=2;i<=n;i++){\n\t\tif (a[i-1]>=a[i]){\n\t\t\tfor (int j=0;j<=mp[a[i]];j++) dp[i][j]=dp[i-1][j];\n\t\t\tfor (int j=mp[a[i]]+1;j<=mp[a[i-1]];j++) dp[i][mp[a[i]]]+=dp[i-1][j];\n\t\t\tdp[i][mp[a[i]]]=dp[i][mp[a[i]]]*2%MOD;\n\t\t}else{\n\t\t\tfor (int j=0;j<mp[a[i-1]];j++) dp[i][j]=dp[i-1][j]*mypow(a[i]-a[i-1])%MOD;\n\t\t\tdp[i][mp[a[i-1]]]=2*dp[i-1][mp[a[i-1]]]*(mypow(v[mp[a[i-1]]+1]-a[i-1])-1)%MOD*mypow(a[i]-v[mp[a[i-1]]+1])%MOD;\n\t\t\tfor (int j=mp[a[i-1]]+1;j<mp[a[i]];j++) dp[i][j]=dp[i-1][mp[a[i-1]]]*2%MOD*(mypow(v[j+1]-v[j])-1)%MOD*mypow(a[i]-v[j+1])%MOD;\n\t\t\tdp[i][mp[a[i]]]=dp[i-1][mp[a[i-1]]]*2%MOD;\n\t\t}\n\t}\n\tfor (int i=0;i<=mp[a[n]];i++) ans+=dp[n][i];\n\tcout<<ans%MOD;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nint H[105];\n\nint dp[105][105];\nint all[105];\n\nint mod = 1000000007;\nlong long qexp(long long b, long long p){\n    long long res = 1;\n    while(p){\n        if(p&1) res = (res * b) % mod;\n        b = (b * b) % mod;\n        p >>= 1;\n    }\n    return res;\n}\n\nvector<int> dis = {1};\nint get(int x){ return lower_bound(dis.begin(),dis.end(),x) - dis.begin(); }\nvoid c(int &x){\n\tx %= mod;\n\tif(x < 0) x += mod;\n}\n\nsigned main(){\n\tios_base::sync_with_stdio(false); cin.tie(0);\n\t\n\tint n; cin >> n;\n\tfor(int i = 1;i <= n;i++){\n\t\tcin >> H[i];\n\t\tdis.push_back(H[i]);\n\t}\n\n\tsort(dis.begin(),dis.end());\n\tdis.erase(unique(dis.begin(), dis.end()), dis.end());\n\tint m = dis.size();\n\t\n\tall[0] = 1;\n\t\n\tfor(int i = 1;i <= n;i++){\n\t\tif(H[i] > H[i-1]){\t\t\t\n\t\t\tfor(int j = m-1;j >= 0;j--){\n\t\t\t\tif(dis[j] >= H[i]) dp[i][j] = 0;\n\t\t\t\telse if(dis[j] >= H[i-1]){\n\t\t\t\t\tdp[i][j] = all[i-1] * (qexp(2, H[i] - dis[j]) - 1) * 2;\n\t\t\t\t\tc(dp[i][j]);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdp[i][j] = dp[i-1][j] * qexp(2,H[i] - H[i-1]);\n\t\t\t\t\tc(dp[i][j]);\n\t\t\t\t\tdp[i][j] += all[i-1] * (qexp(2, H[i] - H[i-1]) - 1) * 2;\n\t\t\t\t\tc(dp[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tall[i] = all[i-1] * 2;\n\t\t\tc(all[i]);\n\t\t}\n\t\telse{\n\t\t\tfor(int j = 0;j < m;j++){\n\t\t\t\tif(dis[j] >= H[i]) dp[i][j] = 0;\n\t\t\t\telse{\n\t\t\t\t\tdp[i][j] = dp[i-1][j] - dp[i-1][get(H[i])];\n\t\t\t\t\tc(dp[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tall[i] = (all[i-1] + dp[i-1][get(H[i])]) * 2;\n\t\t\tc(all[i]);\n\t\t}\n\t\t\n\t}\n\t\n\tint ans = all[n];\n\tfor(int j = 0;j < m;j++){\n\t\tans += dp[n][j];\n\t\tc(ans);\n\t}\n\t\n\tcout << ans;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int mod=1000000007;\ninline void add(int &x,int y){(x+=y)>=mod?x-=mod:0;}\ninline int pl(int x,int y){return (x+=y)>=mod?x-mod:x;}\ninline int kpow(int a,int b)\n{\n\tint s=1;\n\tfor(;b;b>>=1,a=1ll*a*a%mod)\n\t\tif(b&1)s=1ll*s*a%mod;\n\treturn s;\n}\nint n,h[110],dp[110][110],d[110],m,ans;\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i)scanf(\"%d\",&h[i]),d[i]=h[i];\n\tsort(d+1,d+1+n);\n\tm=unique(d+1,d+1+n)-d-1;\n\tfor(int i=1;i<=n;++i)h[i]=lower_bound(d+1,d+1+m,h[i])-d;\n\tfor(int i=0;i<=h[1];++i)dp[1][i]=kpow(2,d[h[1]]-d[i])*(1+(i>0))%mod;\n\tfor(int i=0;i<=h[1];++i)add(dp[1][i],mod-dp[1][i+1]);\n\tfor(int i=2;i<=n;++i)\n\t{\n\t\tfor(int j=0;j<=h[i-1]&&j<=h[i];++j)dp[i][j]=dp[i-1][j];\n\t\tif(h[i-1]>=h[i])\n\t\t{\n\t\t\tfor(int j=h[i]+1;j<=h[i-1];++j)add(dp[i][h[i]],dp[i-1][j]);\n\t\t\tfor(int j=h[i];j<=h[i-1];++j)add(dp[i][h[i]],dp[i-1][j]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint res=pl(dp[i][h[i-1]],dp[i-1][h[i-1]]);\n\t\t\tfor(int j=h[i-1];j<=h[i];++j)dp[i][j]=1ll*res*kpow(2,d[h[i]]-d[j])%mod;\n\t\t\tfor(int j=h[i-1];j<=h[i];++j)add(dp[i][j],mod-dp[i][j+1]);\n\t\t\tres=kpow(2,d[h[i]]-d[h[i-1]]);\n\t\t\tfor(int j=0;j<h[i-1];++j)dp[i][j]=1ll*dp[i][j]*res%mod;\n\t\t}\n\t}\n//\tfor(int i=1;i<=n;++i)\n//\t{\n//\t\tfor(int j=0;j<=h[i];++j)printf(\"%d \",dp[i][j]);\n//\t\tprintf(\"\\n\");\n//\t}\n\tfor(int j=0;j<=h[n];++j)add(ans,dp[n][j]);\n\tprintf(\"%d\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#define SF scanf\n#define PF printf\n#define MAXN 100010\n#define MOD 1000000007\nusing namespace std;\nint n;\ntypedef long long ll;\nll dp[MAXN],h[MAXN];\nll fsp(ll x,ll y){\n\tll res=1;\n\twhile(y){\n\t\tif(y&1)\n\t\t\tres=res*x%MOD;\n\t\tx=x*x%MOD;\n\t\ty>>=1;\n\t}\n\treturn res;\n}\nint main(){\n\tSF(\"%d\",&n);\n\tdp[n+1]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tSF(\"%lld\",&h[i]);\n\t\tif(h[i]==1){\n\t\t\th[i]--;\n\t\t\tdp[n+1]=dp[n+1]*2ll%MOD;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tif(h[i]>h[i-1]&&h[i]>h[i+1]){\n\t\t\tint h1=max(h[i-1],h[i+1]);\n\t\t\tdp[n+1]=dp[n+1]*fsp(2,h[i]-h1)%MOD;\n\t\t\th[i]=h1;\t\n\t\t}\n\tfor(int i=n;i>0;i--){\n\t\t//PF(\"{%d}\",i);\n\t\tif(h[i])\n\t\t\tdp[i]=dp[i+1]*2ll%MOD;\n\t\telse{\n\t\t\tdp[i]=dp[i+1];\n\t\t\tcontinue;\n\t\t} \n\t \tll minh=h[i],q=i;\n\t\tfor(int j=i;h[j]==h[i];j++)\n\t\t\tif(h[j+1]>h[i]){\n\t\t\t\tq=j;\n\t\t\t\tminh++;\n\t\t\t}\n\t\tll res1=0;\n\t\tll end,sumh=0;\n\t\tif(h[i]<h[i-1])\n\t\t\tend=h[i];\n\t\telse\n\t\t\tend=h[i-1]+1;\n\t\t//PF(\"{%d %d}\\n\",minh,end);\n\t\tfor(int j=q+1;minh>end;j++){\n\t\t\tif(h[j]>h[j-1])\n\t\t\t\tsumh+=h[j]-h[j-1];\n\t\t\tif(h[j]<minh){\n\t\t\t\tint minh1=max(end,h[j]);\n\t\t\t\t//PF(\"{%d %d %d}\\n\",sumh+h[i]-minh,minh-minh1,-(minh==(h[i]+1)?0:1));\n\t\t\t\tif(minh==h[i]+1)\n\t\t\t\t\tres1+=dp[j]*(fsp(2,sumh+h[i]-minh+q-i+2)+fsp(2,sumh+h[i]-minh+2)*(fsp(2,minh-minh1-1)-1)%MOD)%MOD;\n\t\t\t\telse\n\t\t\t\t\tres1+=dp[j]*(fsp(2,sumh+h[i]-minh+1)*(fsp(2,minh-minh1)-1)%MOD)%MOD;\n\t\t\t\tres1%=MOD;\n\t\t\t\tminh=minh1;\n\t\t\t}\n\t\t}\n\t\tdp[i]+=res1;\n\t\tdp[i]%=MOD;\n\t\t//PF(\"{%lld}\\n\",dp[i]);\n\t}\n\tPF(\"%lld\",dp[1]);\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <map>\nusing namespace std;\n\nconst long long MOD = 1000000007;\n\nlong long ModPow(long long x, long long n) {\n        long long res = 1;\n        while (n > 0) {\n                if (n & 1) res = res * x % MOD;\n                x = x * x % MOD;\n                n >>= 1;\n        }\n        return res;\n}\n\nint main() {\n        //input\n        int n;\n        scanf(\"%d\", &n);\n        vector<long long> h(n);\n        for (int i = 0; i < n; i ++) {\n                scanf(\"%lld\", &h[i]);\n        }\n        // create a tree\n        vector<vector<int>> g(n);\n        map<int, pair<long long, int>> hw;\n        int k = 0;\n        function<void (int, int, long long, int)> dfs = [&](int l, int r, long long bottom, int prev) {\n                int node = k ++;\n                if (prev != -1) { \n                        g[prev].push_back(node);\n                }\n                long long mi = 10000000000;\n                for (int i = l; i <= r; i ++) {\n                        mi = min(mi, h[i]);\n                }\n                int ww = 0;\n                int cnt = 0;\n                for (int i = l; i <= r; i ++) {\n                        ww += mi == h[i];\n                        cnt ++;\n                }\n                long long hh = mi - bottom;\n                hw[node] = make_pair(hh, ww);\n                if (ww == cnt) {\n                        return;\n                }\n                bool in = false;\n                int tl, tr;\n                vector<pair<int, int>> seg;\n                for (int i = l; i <= r; i ++) {\n                        if (h[i] > mi) {\n                                if (!in) {\n                                        in = true;\n                                        tl = i;\n                                }\n                        } else {\n                                if (in) {\n                                        in = false;\n                                        tr = i - 1;\n                                        seg.emplace_back(tl, tr);\n                                }\n                        }\n                }\n                if (in) {\n                        seg.emplace_back(tl, r);\n                }\n                for (auto s : seg) {\n                        dfs(s.first, s.second, mi, node);\n                }\n        };\n        dfs(0, n - 1, 0, -1);\n        // solve\n        vector<long long> dp(n), dp2(n);\n        function<void (int)> solve = [&](int u) {\n                long long mul1 = 1, mul2 = 1;\n                for (auto v : g[u]) {\n                        solve(v);\n                        (mul1 *= dp[v]) %= MOD;\n                        (mul2 *= (dp[v] + dp2[v])) %= MOD;\n                }\n                (dp[u] = ModPow(2LL, hw[u].first) * mul1) %= MOD;\n                (dp2[u] = ModPow(2LL, hw[u].second) * mul2 % MOD + ((ModPow(2LL, hw[u].first) - 2) + MOD % MOD) * mul1 % MOD) %= MOD;\n        };\n        solve(0);\n        //output\n        printf(\"%lld\\n\", dp2[0]);\n        return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h> \n#define ll long long\n#define N 105\n#define mod 1000000007\nusing namespace std;\nll n,f[N][N],h[N],w[N],tot;\ninline ll ksm(ll x,ll p){\n\tif(p<0)return 1;\n\tll ret=1;\n\twhile(p){\n\t\t\n\t\tif(p&1)ret=ret*x%mod;\n\t\tx=x*x%mod;\n\t\tp>>=1;\n\t}\n\treturn ret;\n}\nint main(){\n\tscanf(\"%lld\",&n);\n\tfor(ll i=1;i<=n;++i)scanf(\"%lld\",&h[i]),w[++tot]=h[i];\n\tsort(w+1,w+tot+1);\n\ttot=unique(w+1,w+tot+1)-w-1;\n\tfor(ll i=1;i<=n;++i)h[i]=lower_bound(w+1,w+tot+1,h[i])-w;\n\tf[0][0]=1;\n\tfor(ll i=1;i<=n;++i){\n\t\tfor(ll j=h[i]+1;j<=h[i-1];++j)(f[i][0]+=f[i-1][j]*2%mod)%=mod;\n\t\t(f[i][0]+=f[i-1][0]*2%mod)%=mod;\n\t\tfor(ll j=1;j<=h[i];++j){\n\t\t\tf[i][j]=(ll)f[i-1][j]*ksm(2,w[h[i]]-w[h[i-1]])%mod;\n\t\t\tif(h[i-1]>=j)continue;\n\t\t\tif(j>1)(f[i][j]+=(ll)f[i-1][0]*(ksm(2,w[j]-w[j-1])-1)%mod*2%mod*ksm(2,w[h[i]]-w[j])%mod)%=mod;\n\t\t\telse (f[i][j]+=(ll)f[i-1][0]*(ksm(2,w[j])-2)%mod*ksm(2,w[h[i]]-w[j])%mod)%=mod;\n\t\t}\n\t}\n\tll ans=0;\n\tfor(ll i=0;i<=tot;++i)(ans+=f[n][i])%=mod;\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod=1000000007ll;\nvoid ad(long long &a,long long b){a+=b;a%=mod;}\nvoid mn(long long &a,long long b){a+=mod-b;a%=mod;}\nvoid ml(long long &a,long long b){a*=b;a%=mod;}\nlong long sq(long long a){return a*a%mod;}\nlong long pw(long long a,long long n)\n{\n  return n==0?1ll:sq(pw(a,n/2))*(n%2==1?a:1ll)%mod;\n}\nlong long iv(long long a){return pw(a,mod-2);}\n\nint main()\n{\n  int n;\n  scanf(\"%d\",&n);\n  long long h[110],X[110];\n  X[0]=0;\n  for(int i=0;i<n;i++){\n    scanf(\"%lld\",h+i);\n    X[i+1]=h[i];\n  }\n  sort(X,X+n+1);\n  int r[110];\n  for(int i=0;i<n;i++){\n    r[i]=lower_bound(X,X+n+1,h[i])-X;\n  }\n  long long dp[110][110];\n  for(int j=0;j<=r[0];j++){\n    dp[0][j]=(j==0?1ll:2ll)*pw(2ll,X[r[0]]-X[j])%mod;\n  }\n  for(int i=1;i<n;i++){\n    if(r[i-1]<=r[i]){\n      for(int j=0;j<=r[i-1];j++){\n\tdp[i][j]=(dp[i-1][j]+dp[i-1][r[i-1]])%mod*pw(2ll,X[r[i]]-X[r[i-1]])%mod;\n      }\n      for(int j=r[i-1]+1;j<=r[i];j++){\n\tdp[i][j]=2ll*dp[i-1][r[i-1]]%mod*pw(2ll,X[r[i]]-X[j])%mod;\n      }\n    }\n    else{\n      for(int j=0;j<=r[i];j++){\n\tdp[i][j]=(dp[i-1][j]+dp[i-1][r[i]])%mod;\n      }\n    }\n  }\n  printf(\"%lld\\n\",dp[n-1][0]);\n  return 0;\n}\n\n      \n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int mod=1000000007;\ninline void add(int &a,int b){\n    a+=b;\n    if(a>=mod)a-=mod;\n}\nint mpow(int a,int b){\n    int ret=1;\n    while(b){\n        if(b&1)ret=ret*a%mod;\n        a=a*a%mod;\n        b>>=1;\n    }\n    return ret;\n}\n\nint N;\nint H[111];\n\nint dp[111][111],dp2[111][111];\n\nvoid solve(int l,int r,int b){\n    int &ret=dp[l][r];\n    int &ret2=dp2[l][r];\n\n    if(ret!=-1)return;\n\n    int bb=*min_element(H+l,H+r);\n    if(*max_element(H+l,H+r)==bb){\n        ret=(mpow(2,r-l)-2+mod)%mod;\n        ret2=mpow(2,bb-b);\n        return;\n    }\n\n    vpint lis;\n    int cur=l;\n    while(cur<r){\n        if(H[cur]==bb){\n            cur++;\n            continue;\n        }\n        int nex=cur;\n        while(nex<r&&H[nex]>bb)nex++;\n        lis.pb({cur,nex});\n        solve(cur,nex,bb);\n        cur=nex;\n    }\n\n    int num=count(H+l,H+r,bb);\n\n    int x=mpow(2,num);\n    ret2=2;\n    for(auto &p:lis){\n        x=x*(dp[p.fi][p.se]+dp2[p.fi][p.se]*2)%mod;\n        ret2=ret2*dp2[p.fi][p.se]%mod;\n    }\n    ret=(x-ret2+mod)%mod;\n    ret2=ret2*mpow(2,bb-b-1)%mod;\n}\n\nsigned main(){\n    cin>>N;\n    rep(i,N)cin>>H[i];\n\n    memset(dp,-1,sizeof(dp));\n    solve(0,N,0);\n    cout<<(dp[0][N]+dp2[0][N])%mod<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 100 + 7;\nconst int mod = 1e9 + 7;\n\nint h[maxn];\n\nlong long power(int x, int times) { \n    long long rt = 1, base = x;\n    while (times) {\n        if (times & 1) rt = rt * base % mod;\n        base = base * base % mod;\n        times >>= 1;\n    }\n    return rt;\n}\n\nint dp1(int x, int y, int level) {\n    static bool vis[maxn][maxn];\n    static int f[maxn][maxn];\n    if (vis[x][y]) return f[x][y];\n    vis[x][y] = true;\n\n    int MIN = h[x];\n\n    long long cnt1 = 1;\n    for (int i = x; i <= y; i++) {\n        MIN = min(MIN, h[i]);\n    }\n\n    for (int i = x; i <= y; i++) \n        if (h[i] != MIN) {\n            int j = i;\n            while (j <= y && h[j] != MIN) j++;\n            j--;\n            cnt1 = cnt1 * dp1(i, j, MIN) % mod;\n            i = j;\n        }\n    cnt1 = cnt1 * power(2, MIN - level) % mod;\n    //cout << x << ' ' << y << ' ' << level << ' ' << cnt1 << endl;\n    return f[x][y] = cnt1;\n}\n\nint dp2(int x, int y, int level) {\n    static bool vis[maxn][maxn];\n    static int f[maxn][maxn];\n    if (vis[x][y]) return f[x][y];\n    vis[x][y] = true;\n\n    int MIN = h[x], k = 0;\n\n    long long cnt1 = 1, cnt2 = 1;\n    for (int i = x; i <= y; i++) {\n        MIN = min(MIN, h[i]);\n    }\n\n    for (int i = x; i <= y; i++) \n        if (h[i] != MIN) {\n            int j = i;\n            while (j <= y && h[j] != MIN) j++;\n            j--;\n            cnt1 = cnt1 * dp1(i, j, MIN) % mod;\n            cnt2 = cnt2 * (dp1(i, j, MIN) + dp2(i, j, MIN)) % mod;\n            i = j;\n        }\n        else {\n            k++;\n        }\n    // cout << cnt1 << ' ' << cnt2 << endl;\n    int &rt = f[x][y];\n    rt = ((cnt2 * power(2, k) % mod + cnt1 * (power(2, MIN - level) - 2) % mod) % mod + mod) % mod;\n    // cout << cnt1 * (power(2, MIN - level) - 2) % mod << endl;\n    // cout << cnt2 * power(2, k) % mod << endl;\n    // cout << endl;\n    \n    // cout << x << ' ' << y << ' ' << level << ' ' << rt << endl;\n    // cout << cnt1 << ' ' << cnt2 << ' ' << k << ' ' << MIN << endl;   \n    return rt;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n\n    for (int i = 1; i <= n; i++) {\n        scanf(\"%d\", &h[i]);\n    }\n\n    cout << dp2(1, n, 0) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n\ntypedef long long LL;\n\nconst int N=105;\nconst int MOD=1000000007;\n\nint n,f[N][N],h[N],w[N],m;\n\nint ksm(int x,int y)\n{\n    if (y<0) return 1;\n    int ans=1;\n    while (y)\n    {\n        if (y&1) ans=(LL)ans*x%MOD;\n        x=(LL)x*x%MOD;y>>=1;\n    }\n    return ans;\n}\n\nint main()\n{\n    scanf(\"%d\",&n);\n    for (int i=1;i<=n;i++) scanf(\"%d\",&h[i]),w[++m]=h[i];\n    std::sort(w+1,w+m+1);\n    m=std::unique(w+1,w+m+1)-w-1;\n    for (int i=1;i<=n;i++) h[i]=std::lower_bound(w+1,w+m+1,h[i])-w;\n    f[0][0]=1;\n    for (int i=1;i<=n;i++)\n    {\n        for (int j=h[i]+1;j<=h[i-1];j++) (f[i][0]+=f[i-1][j]*2%MOD)%=MOD;\n        (f[i][0]+=f[i-1][0]*2%MOD)%=MOD;\n        for (int j=1;j<=h[i];j++)\n        {\n            f[i][j]=(LL)f[i-1][j]*ksm(2,w[h[i]]-w[h[i-1]])%MOD;\n            if (h[i-1]>=j) continue;\n            if (j>1) (f[i][j]+=(LL)f[i-1][0]*(ksm(2,w[j]-w[j-1])-1)%MOD*2%MOD*ksm(2,w[h[i]]-w[j])%MOD)%=MOD;\n            else (f[i][j]+=(LL)f[i-1][0]*(ksm(2,w[j])-2)%MOD*ksm(2,w[h[i]]-w[j])%MOD)%=MOD;\n        }\n    }\n    int ans=0;\n    for (int i=0;i<=m;i++) (ans+=f[n][i])%=MOD;\n    printf(\"%d\",ans);\n    return 0;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author aajisaka\n */\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n#define SPEED ios_base::sync_with_stdio(false);cin.tie(nullptr)\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define all(v) v.begin(), v.end()\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing P = pair<ll, ll>;\n\nconstexpr long double PI = 3.14159265358979323846264338327950288L;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nconstexpr ll mod17 = 1e9+7;\nconstexpr ll mod19 = 1e9+9;\nconstexpr ll mod9 = 998244353;\nll mod = mod17;\n\n// Mod int libraries\ntemplate<typename T>\nT mod_pow(T a, ll x) {\n  T res = 1;\n  while(x > 0) {\n    if (x & 1) res *= a;\n    a *= a; x >>= 1;\n  }\n  return res;\n}\n\n// Mint32\nunordered_map<ll, ll> minvmap;\nll minv(ll a, ll m) {\n  auto k = a; auto p = minvmap[a]; if (p != 0) return p;\n  ll b = m, u = 1, v = 0;\n  while (b) { ll t = a/b; swap(a -= t*b, b); swap(u -= t*v, v); }\n  p = (u%m+m)%m; minvmap[k] = p; return p;\n}\n\nstruct mint {\n  ll x;\n  mint():x(0){}\n  mint(ll x):x((x%mod+mod)%mod){}\n  mint& fix() { x = (x%mod+mod)%mod; return *this;}\n  mint operator-() const { return mint(0) - *this;}\n  mint& operator+=(const mint& a){ if((x+=a.x)>=mod) x-=mod; return *this;}\n  mint& operator-=(const mint& a){ if((x+=mod-a.x)>=mod) x-=mod; return *this;}\n  mint& operator*=(const mint& a){ (x*=a.x)%=mod; return *this;}\n  mint& operator/=(const mint& a){ (x*=minv(a.x, mod))%=mod; return *this; }\n  mint operator+(const mint& a)const{ return mint(*this) += a;}\n  mint operator-(const mint& a)const{ return mint(*this) -= a;}\n  mint operator*(const mint& a)const{ return mint(*this) *= a;}\n  mint operator/(const mint& a)const{ return mint(*this) /= a;}\n  bool operator<(const mint& a)const{ return x < a.x;}\n  bool operator==(const mint& a)const{ return x == a.x;}\n};\n\n// Mint64\nstruct mint64 {\n    ull x;\n    static ull mod, inv, r2;\n    mint64(): x(0){}\n    mint64(ull x): x(init(x)) {}\n    static ull init(ull x) { return reduce(__uint128_t(x)*r2);}\n    static void set_mod(ull m) {\n      mod = inv = m;\n      for(int i=0; i<5; i++) inv *= 2 - inv*m;\n      r2 = -__uint128_t(m)%m;\n    }\n    static ull reduce(__uint128_t x) {\n      ull y = ull(x >> 64) - ull((__uint128_t(ull(x)*inv)*mod)>>64);\n      return ll(y) < 0 ? y+mod : y;\n    }\n    mint64& operator+=(mint64& a) { x+=a.x-mod; if(ll(x)<0) x+=mod; return *this; }\n    mint64 operator+(mint64& a) const{ return mint64(*this)+=a; }\n    mint64& operator*=(mint64& a) { x=reduce(__uint128_t(x)*a.x); return *this; }\n    mint64 operator*(mint64& a) const { return mint64(*this)*=a; }\n};\n\null mint64::mod, mint64::inv, mint64::r2;\n\n// Verify: https://yukicoder.me/submissions/472580\nstruct Miller {\n    const vector<ull> v = {2, 325, 9375, 28178, 450775, 9780504, 1795265022};\n    bool suspect(ull a, ull s, ull d, ull n) {\n      if (mint64::mod != n) mint64::set_mod(n);\n      mint64 one = 1, minusone = n-1, ma = a;\n      auto x = mod_pow(ma, d);\n      if (x.x == one.x) return true;\n      for(ull r = 0; r < s; r++) {\n        if (x.x == minusone.x) return true;\n        x = x * x;\n      }\n      return false;\n    }\n\n    // check if n is prime\n    bool check(ull n) {\n      if (n < 2 || (n > 2 && n % 2 == 0)) return false;\n      ull d = n - 1;\n      ull s = 0;\n      while (!(d & 1)) {\n        d >>= 1;\n        s++;\n      }\n      for (auto a: v) {\n        if (a >= n) break;\n        if (!suspect(a, s, d, n)) return false;\n      }\n      return true;\n    }\n};\n\nclass combination {\n    // factorial\n    public: std::vector<mint> fact;\n    public: std::vector<mint> inv;\n\n    combination(int n) {\n      fact.resize(n + 1);\n      inv.resize(n + 1);\n      fact[0] = 1;\n      for (int i = 1; i <= n; i++) {\n        fact[i] = fact[i - 1] * i;\n      }\n      inv[n] = mint(1) / fact[n];\n      for (int i = n - 1; i >= 0; i--) {\n        inv[i] = inv[i + 1] * (i + 1);\n      }\n    }\n\n    // nCr\n    public: mint get(int n, int r) {\n      if (n < r || n < 0 || r < 0) return 0;\n      return fact[n]*inv[r]*inv[n-r];\n    }\n    // nPr\n    public: mint p(int n, int r) {\n      if (n < r || n < 0) return 0;\n      return fact[n]*inv[n-r];\n    }\n};\n\n\nclass DHistogramColoring {\npublic:\n    void solve(istream& cin, ostream& cout) {\n      SPEED;\n      int n; cin >> n;\n      vector<int> h(n);\n      ll cnt = 0;\n      set<int> st;\n      rep(i, n) {\n        cin >> h[i];\n        if (h[i] == 1) {\n          h[i]--;\n          cnt++;\n        }\n      }\n\n      for(int i=1; i<n-1; i++) {\n        int m = max(h[i-1], h[i+1]);\n        if (h[i] > m) {\n          cnt += h[i]-m;\n          h[i] = m;\n        }\n      }\n\n      if (n > 1) {\n        if (h[0] > h[1]) {\n          cnt += h[0] - h[1];\n          h[0] = h[1];\n        }\n        if (h[n-2] < h[n-1]) {\n          cnt += h[n-1] - h[n-2];\n          h[n-1] = h[n-2];\n        }\n      }\n\n      st.insert(0);\n      rep(i, n) {\n        debug(i, h[i]);\n        st.insert(h[i]);\n      }\n\n      map<int, int> mp;\n      int idx = 0;\n      for(auto e: st) {\n        mp[e] = idx;\n        idx++;\n      }\n      vector<int> rev;\n      for(auto e: st) {\n        rev.push_back(e);\n      }\n\n      // dp[0]: rest\n      vector<mint> dp(idx);\n      mint two = 2;\n      bool first = true;\n\n      mint ret = mod_pow(two, cnt);\n\n      rep(i, n) {\n        if (h[i] == 0) {\n          if (first) continue;\n          mint sum = 0;\n          for(auto& e: dp) {\n            sum += e;\n            e = 0;\n          }\n          //debug(sum.x);\n          ret *= sum;\n          first = true;\n          continue;\n        }\n\n        int p = mp[h[i]];\n        if (first) {\n          dp[p] = 2;\n          mint sum = dp[p];\n          for(int j=p-1; j>=0; j--) {\n            mint tmp2 = mod_pow(two, rev[p] - rev[j]);\n            dp[j] = tmp2 - sum;\n            sum += tmp2;\n          }\n          first = false;\n          continue;\n        }\n\n        // complex part\n        // decrease\n        int b = -1;\n        for(int j=idx-1; j>=0; j--) {\n          if (j > p) {\n            dp[j-1] += dp[j];\n            dp[j] = 0;\n          }\n          if (dp[j].x > 0) {\n            b = j;\n            break;\n          }\n        }\n\n        int hb = rev[b];\n        int hp = rev[p];\n        mint tmp = 0;\n        mint dpb = dp[b];\n        for(int j=p; j>=0; j--) {\n          if (j >= b) {\n            dp[j] = dpb * 2 * mod_pow(two, (hp - rev[j])) - tmp;\n            tmp += dp[j];\n          } else {\n            dp[j] *= mod_pow(two, hp - hb);\n          }\n        }\n      }\n\n      if (!first) {\n        mint sum = 0;\n        for(int i=0; i<idx; i++) {\n          sum += dp[i];\n          //debug(i, rev[i], dp[i].x);\n        }\n        //debug(sum.x);\n        ret *= sum;\n        first = true;\n      }\n\n      cout << ret.x << endl;\n\n\n\n\n    }\n};\n\nsigned main() {\n  DHistogramColoring solver;\n  std::istream& in(std::cin);\n  std::ostream& out(std::cout);\n  solver.solve(in, out);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define R(i,n) for(int i = 0; i < (n); i++)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, set<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\n\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> PP) {\n  return os << \"(\" << PP.FI << \",\" << PP.SE << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst int MAX = 101;\nconst int P = 1e9 + 7;\nint t[MAX];\nint pot(int a,int w){\n  int r = 1;\n  while(w){\n    if(w & 1){\n      r = r * a % P;\n    }\n    w/=2;\n    a = a * a % P;\n  }\n  return r;\n}\nint mul(int a,int b){\n  return a * b % P;\n}\nvoid sub(int &a,int b){\n  a -= b;\n  if(a < 0)\n    a+=P;\n}\nvoid add(int &a,int b){\n  a += b;\n  if(a >= P)\n    a -= P;\n}\nPII licz(int po,int ko,int flo){\n  int poo = po;\n  int ma = 2e9;\n  for(int i = po; i < ko; i++){\n    mini(ma,t[i]);\n  }\n  PII res = {2,1};\n  int ilema = -1;\n  for(int i = po; i <= ko; i++){\n    if(i == ko || t[i] == ma){\n      ilema++;\n      if(i > po){\n        PII pom = licz(po, i, ma);\n        res.FI = mul(res.FI, pom.FI);\n        res.SE = mul(res.SE, (pom.SE + pom.FI)%P);\n      }\n      po = i + 1;\n    }\n  }\n  debug(res);\n  res.SE = mul(res.SE, pot(2, ilema));\n  debug(res);\n  sub(res.SE, res.FI);\n  \n  res.FI = mul(res.FI, pot(2, ma - flo - 1));\n  add(res.SE,res.FI);\n  debug(poo,ko,res);\n  return res;\n}\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n  int n;\n  cin >> n;\n  R(i,n){\n    cin >> t[i];\n  }\n  PII res = licz(0,n,0);\n  cout << res.SE << \"\\n\";\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN=100;\nconst int MAXZ=MAXN;\nconst int MOD=1000000007;\nint pw(int x,int n) { int ret=1; while(true) { if(n&1) ret=(ll)ret*x%MOD; if((n>>=1)==0) return ret; x=(ll)x*x%MOD; } }\nvoid inc(int &a,int b) { if((a+=b)>=MOD) a-=MOD; }\n\nint n;\nint h[MAXN];\n\nint z[MAXN],nz;\n\nint dpalt[MAXN];\nint dpdup[MAXN][MAXZ];\n\nvoid run() {\n\tscanf(\"%d\",&n); REP(i,n) scanf(\"%d\",&h[i]);\n\n\tnz=0; REP(i,n) z[nz++]=h[i]; sort(z,z+nz); nz=unique(z,z+nz)-z;\n\n\tmemset(dpalt,0,sizeof(dpalt)); memset(dpdup,0,sizeof(dpdup));\n\tREP(i,n) {\n\t\tint cz=lower_bound(z,z+nz,h[i])-z;\n\t\tif(i==0) {\n\t\t\tinc(dpalt[i],2);\n\t\t\tREPE(nj,cz) {\n\t\t\t\tint here=z[nj]-(nj==0?0:z[nj-1]),below=nj==0?0:z[nj-1],above=h[i]-z[nj];\n\t\t\t\tint ways=below==0?(ll)(pw(2,here)+MOD-2)*pw(2,above)%MOD:(ll)2*(pw(2,here)+MOD-1)*pw(2,above)%MOD;\n\t\t\t\tinc(dpdup[i][nj],ways);\n\t\t\t}\n\t\t} else {\n\t\t\tint pz=lower_bound(z,z+nz,h[i-1])-z;\n\t\t\tif(dpalt[i-1]!=0) {\n\t\t\t\tinc(dpalt[i],(ll)2*dpalt[i-1]%MOD);\n\t\t\t\tFORE(nj,pz+1,cz) {\n\t\t\t\t\tint here=z[nj]-z[nj-1],below=z[nj-1]-h[i-1],above=h[i]-z[nj];\n\t\t\t\t\tint ways=(ll)2*(pw(2,here)+MOD-1)*pw(2,above)%MOD;\n\t\t\t\t\tinc(dpdup[i][nj],(ll)dpalt[i-1]*ways%MOD);\n\t\t\t\t}\n\t\t\t}\n\t\t\tREP(j,nz) if(dpdup[i-1][j]!=0) {\n\t\t\t\tif(cz<j) {\n\t\t\t\t\tinc(dpalt[i],(ll)2*dpdup[i-1][j]%MOD);\n\t\t\t\t} else {\n\t\t\t\t\tint above=cz<=pz?0:h[i]-h[i-1];\n\t\t\t\t\tint ways=pw(2,above);\n\t\t\t\t\tinc(dpdup[i][j],(ll)dpdup[i-1][j]*ways%MOD);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ret=0;\n\tinc(ret,dpalt[n-1]);\n\tREP(j,nz) inc(ret,dpdup[n-1][j]);\n\tprintf(\"%d\\n\",ret);\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// created [2019/11/18] 22:39:34\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n\nusing i32 = int32_t;\nusing i64 = int64_t;\nusing u32 = uint32_t;\nusing u64 = uint64_t;\nusing uint = unsigned int;\nusing usize = std::size_t;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\ntemplate<typename T> constexpr T popcount(const T u) { return u ? static_cast<T>(__builtin_popcountll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T log2p1(const T u) { return u ? static_cast<T>(64 - __builtin_clzll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T msbp1(const T u) { return log2p1(u); }\ntemplate<typename T> constexpr T lsbp1(const T u) { return __builtin_ffsll(u); }\ntemplate<typename T> constexpr T clog(const T u) { return u ? log2p1(u - 1) : static_cast<T>(u); }\ntemplate<typename T> constexpr bool ispow2(const T u) { return u and (static_cast<u64>(u) & static_cast<u64>(u - 1)) == 0; }\ntemplate<typename T> constexpr T ceil2(const T u) { return static_cast<T>(1) << clog(u); }\ntemplate<typename T> constexpr T floor2(const T u) { return u == 0 ? static_cast<T>(0) : static_cast<T>(1) << (log2p1(u) - 1); }\ntemplate<typename T> constexpr bool btest(const T mask, const usize ind) { return static_cast<bool>((static_cast<u64>(mask) >> ind) & static_cast<u64>(1)); }\ntemplate<typename T> void bset(T& mask, const usize ind) { mask |= (static_cast<T>(1) << ind); }\ntemplate<typename T> void breset(T& mask, const usize ind) { mask &= ~(static_cast<T>(1) << ind); }\ntemplate<typename T> void bflip(T& mask, const usize ind) { mask ^= (static_cast<T>(1) << ind); }\ntemplate<typename T> void bset(T& mask, const usize ind, const bool b) { (b ? bset(mask, ind) : breset(mask, ind)); }\ntemplate<typename T> constexpr T bcut(const T mask, const usize ind) { return ind == 0 ? static_cast<T>(0) : static_cast<T>((static_cast<u64>(mask) << (64 - ind)) >> (64 - ind)); }\ntemplate<typename T> bool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate<typename T> bool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\nconstexpr unsigned int mod                  = 1000000007;\ntemplate<typename T> constexpr T inf_v      = std::numeric_limits<T>::max() / 4;\ntemplate<typename Real> constexpr Real pi_v = Real{3.141592653589793238462643383279502884};\n\ntemplate<typename T>\nT read()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate<typename T, typename... Args>\nauto read(const usize size, Args... args)\n{\n    std::vector<decltype(read<T>(args...))> ans(size);\n    for (usize i = 0; i < size; i++) { ans[i] = read<T>(args...); }\n    return ans;\n}\ntemplate<typename... Types>\nauto reads() { return std::tuple<std::decay_t<Types>...>{read<Types>()...}; }\n#    define SHOW(...) static_cast<void>(0)\n\ntemplate<typename T>\nstd::vector<T> make_v(const usize size, const T v) { return std::vector<T>(size, v); }\ntemplate<typename... Args>\nauto make_v(const usize size, Args... args) { return std::vector<decltype(make_v(args...))>(size, make_v(args...)); }\n\n\ntemplate<typename T> T gcd(const T& a, const T& b) { return a < 0 ? gcd(-a, b) : b < 0 ? gcd(a, -b) : (a > b ? gcd(b, a) : a == 0 ? b : gcd(b % a, a)); }\ntemplate<typename T> T lcm(const T& a, const T& b) { return a / gcd(a, b) * b; }\ntemplate<typename T>\nconstexpr std::pair<T, T> extgcd(const T a, const T b)\n{\n    if (b == 0) { return std::pair<T, T>{1, 0}; }\n    const auto g = gcd(a, b), da = std::abs(b) / g;\n    const auto p = extgcd(b, a % b);\n    const auto x = (da + p.second % da) % da, y = (g - a * x) / b;\n    return {x, y};\n}\ntemplate<typename T>\nconstexpr T inverse(const T a, const T mod) { return extgcd(a, mod).first; }\ntemplate<uint mod_value, bool dynamic = false>\nclass modint_base\n{\npublic:\n    template<typename UInt = uint>\n    static std::enable_if_t<dynamic, const UInt> mod() { return mod_ref(); }\n    template<typename UInt = uint>\n    static constexpr std::enable_if_t<not dynamic, const UInt> mod() { return mod_value; }\n    template<typename UInt = uint>\n    static void set_mod(const std::enable_if_t<dynamic, const UInt> mod) { mod_ref() = mod, inv_ref() = {1, 1}; }\n    modint_base() : v{0} {}\n    modint_base(const ll val) : v{norm(static_cast<uint>(val % static_cast<ll>(mod()) + static_cast<ll>(mod())))} {}\n    modint_base(const modint_base& n) : v{n()} {}\n    explicit operator bool() const { return v != 0; }\n    bool operator!() const { return not static_cast<bool>(*this); }\n    modint_base& operator=(const modint_base& m) { return v = m(), (*this); }\n    modint_base& operator=(const ll val) { return v = norm(uint(val % static_cast<ll>(mod()) + static_cast<ll>(mod()))), (*this); }\n    friend modint_base operator+(const modint_base& m) { return m; }\n    friend modint_base operator-(const modint_base& m) { return make(norm(mod() - m.v)); }\n    friend modint_base operator+(const modint_base& m1, const modint_base& m2) { return make(norm(m1.v + m2.v)); }\n    friend modint_base operator-(const modint_base& m1, const modint_base& m2) { return make(norm(m1.v + mod() - m2.v)); }\n    friend modint_base operator*(const modint_base& m1, const modint_base& m2) { return make(static_cast<uint>(static_cast<ll>(m1.v) * static_cast<ll>(m2.v) % static_cast<ll>(mod()))); }\n    friend modint_base operator/(const modint_base& m1, const modint_base& m2) { return m1 * inv(m2.v); }\n    friend modint_base operator+(const modint_base& m, const ll val) { return modint_base{static_cast<ll>(m.v) + val}; }\n    friend modint_base operator-(const modint_base& m, const ll val) { return modint_base{static_cast<ll>(m.v) - val}; }\n    friend modint_base operator*(const modint_base& m, const ll val) { return modint_base{static_cast<ll>(m.v) * (val % static_cast<ll>(mod()))}; }\n    friend modint_base operator/(const modint_base& m, const ll val) { return modint_base{static_cast<ll>(m.v) * inv(val)}; }\n    friend modint_base operator+(const ll val, const modint_base& m) { return modint_base{static_cast<ll>(m.v) + val}; }\n    friend modint_base operator-(const ll val, const modint_base& m) { return modint_base{-static_cast<ll>(m.v) + val}; }\n    friend modint_base operator*(const ll val, const modint_base& m) { return modint_base{static_cast<ll>(m.v) * (val % static_cast<ll>(mod()))}; }\n    friend modint_base operator/(const ll val, const modint_base& m) { return modint_base{val * inv(static_cast<ll>(m.v))}; }\n    friend modint_base& operator+=(modint_base& m1, const modint_base& m2) { return m1 = m1 + m2; }\n    friend modint_base& operator-=(modint_base& m1, const modint_base& m2) { return m1 = m1 - m2; }\n    friend modint_base& operator*=(modint_base& m1, const modint_base& m2) { return m1 = m1 * m2; }\n    friend modint_base& operator/=(modint_base& m1, const modint_base& m2) { return m1 = m1 / m2; }\n    friend modint_base& operator+=(modint_base& m, const ll val) { return m = m + val; }\n    friend modint_base& operator-=(modint_base& m, const ll val) { return m = m - val; }\n    friend modint_base& operator*=(modint_base& m, const ll val) { return m = m * val; }\n    friend modint_base& operator/=(modint_base& m, const ll val) { return m = m / val; }\n    friend modint_base operator^(const modint_base& m, const ll n) { return power(m.v, n); }\n    friend modint_base& operator^=(modint_base& m, const ll n) { return m = m ^ n; }\n    friend bool operator==(const modint_base& m1, const modint_base& m2) { return m1.v == m2.v; }\n    friend bool operator!=(const modint_base& m1, const modint_base& m2) { return not(m1 == m2); }\n    friend bool operator==(const modint_base& m, const ll val) { return m.v == norm(static_cast<uint>(static_cast<ll>(mod()) + val % static_cast<ll>(mod()))); }\n    friend bool operator!=(const modint_base& m, const ll val) { return not(m == val); }\n    friend bool operator==(const ll val, const modint_base& m) { return m.v == norm(static_cast<uint>(static_cast<ll>(mod()) + val % static_cast<ll>(mod()))); }\n    friend bool operator!=(const ll val, const modint_base& m) { return not(m == val); }\n    friend std::istream& operator>>(std::istream& is, modint_base& m)\n    {\n        ll v;\n        return is >> v, m = v, is;\n    }\n    friend std::ostream& operator<<(std::ostream& os, const modint_base& m) { return os << m(); }\n    uint operator()() const { return v; }\n    static modint_base small_inv(const usize n)\n    {\n        auto& in = inv_ref();\n        if (n < in.size()) { return in[n]; }\n        for (usize i = in.size(); i <= n; i++) { in.push_back(-in[modint_base::mod() % i] * (modint_base::mod() / i)); }\n        return in.back();\n    }\n\nprivate:\n    template<typename UInt = uint>\n    static std::enable_if_t<dynamic, UInt&> mod_ref()\n    {\n        static UInt mod = 0;\n        return mod;\n    }\n    static uint norm(const uint x) { return x < mod() ? x : x - mod(); }\n    static modint_base make(const uint x)\n    {\n        modint_base m;\n        return m.v = x, m;\n    }\n    static modint_base power(modint_base x, ull n)\n    {\n        modint_base ans = 1;\n        for (; n; n >>= 1, x *= x) {\n            if (n & 1) { ans *= x; }\n        }\n        return ans;\n    }\n    static modint_base inv(const ll v) { return v < 1000000 ? small_inv(static_cast<usize>(v)) : modint_base{inverse(v, static_cast<ll>(mod()))}; }\n    static std::vector<modint_base>& inv_ref()\n    {\n        static std::vector<modint_base> in{1, 1};\n        return in;\n    }\n    uint v;\n};\ntemplate<uint mod>\nusing modint = modint_base<mod, false>;\ntemplate<uint id>\nusing dynamic_modint = modint_base<id, true>;\nint main()\n{\n    using mint   = modint<mod>;\n    const auto n = read<int>();\n    auto h       = read<ll>(n);\n    auto H       = h;\n    H.push_back(0);\n    std::sort(H.begin(), H.end());\n    H.erase(std::unique(H.begin(), H.end()), H.end());\n    const int hn = H.size();\n    std::map<ll, int> zip;\n    for (int i = 0; i < hn; i++) { zip[H[i]] = i; }\n    for (int i = 0; i < n; i++) { h[i] = zip[h[i]]; }\n    // min_i s.t. x_{i-1}とx_{i}が同じ色な場所をS(x)とする\n    auto dp = make_v(n, hn + 1, mint(0));  // S(x) \\in [H_j,H_{j+1})\n    for (int j = 0; j < h[0]; j++) {\n        if (j == 0) {\n            if (H[j + 1] < 2) {\n                continue;\n            } else {\n                dp[0][j] = (mint(2) ^ H[h[0]]) - (mint(2) ^ (H[h[0]] - H[j + 1] + 1));\n            }\n        } else {\n            dp[0][j] = (mint(2) ^ (H[h[0]] - H[j] + 1)) - (mint(2) ^ (H[h[0]] - H[j + 1] + 1));\n        }\n    }\n    dp[0][hn] = 2;\n    for (int i = 1; i < n; i++) {\n        for (int j = 0; j < hn; j++) {\n            if (j < h[i]) {  // 模様そのまま\n                dp[i][j] += dp[i - 1][j] * (mint(2) ^ std::max(0LL, H[h[i]] - H[h[i - 1]]));\n            } else {\n                dp[i][hn] += 2 * dp[i - 1][j];\n            }\n        }\n        for (int j = h[i - 1]; j < h[i]; j++) {\n            if (j == 0) {\n                if (H[j + 1] < 2) {\n                    continue;\n                } else {\n                    dp[i][j] += ((mint(2) ^ H[h[i]]) - (mint(2) ^ (H[h[i]] - H[j + 1] + 1))) * dp[i - 1][hn];\n                }\n            } else {\n                dp[i][j] += ((mint(2) ^ (H[h[i]] - H[j] + 1)) - (mint(2) ^ (H[h[i]] - H[j + 1] + 1))) * dp[i - 1][hn];\n            }\n        }\n        dp[i][hn] += dp[i - 1][hn] * 2;\n    }\n    mint ans = 0;\n    for (int i = 0; i <= hn; i++) { ans += dp[n - 1][i]; }\n    SHOW(dp);\n    std::cout << ans << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define N 110\n#define mod 1000000007\ntypedef long long ll;\nll h[N],a[N],dp[N][N];\ninline ll Pow(ll a,ll b,int p=mod) {\n    if (b<=0) return 1; ll res=1;\n    for (;b;b>>=1,a=1LL*a*a%p)\n        if (b&1) res=1LL*res*a%p;\n    return res;\n}\ninline int read() {\n    int x=0;\n    char ch=getchar();\n    while (!isdigit(ch)) ch=getchar();\n    while (isdigit(ch)) x=x*10+ch-'0',ch=getchar();\n    return x;\n}\nint main() {\n    int n=read(),tot=0; dp[0][0]=1;\n    for (int i=1;i<=n;i++) a[++tot]=h[i]=read();\n    sort(a+1,a+tot+1),tot=unique(a+1,a+tot+1)-a-1;\n    for (int i=1;i<=n;i++) h[i]=lower_bound(a+1,a+tot+1,h[i])-a;\n    for (int i=1;i<=n;i++) {\n        dp[i][0]=dp[i-1][0]*2%mod;\n        for (int j=h[i]+1;j<=h[i-1];j++) dp[i][0]=(dp[i][0]+dp[i-1][j]*2%mod)%mod;\n        ll tmp=Pow(2,a[h[i]]-a[h[i-1]]);\n        for (int j=1;j<=min(h[i-1],h[i]);j++) dp[i][j]=dp[i-1][j]*tmp%mod;\n        for (int j=h[i-1]+1;j<=h[i];j++) \n            if (dp[i][j]+j==1) dp[i][j]=dp[i-1][0]*(Pow(2,a[j])-2)%mod*Pow(2,a[h[i]]-a[j])%mod;\n            else dp[i][j]=dp[i-1][0]*2*(Pow(2,a[j]-a[j-1])-1)%mod*Pow(2,a[h[i]]-a[j])%mod;\n    }\n    ll res=0;\n    for (int i=0;i<=tot;i++) res=(res+dp[n][i])%mod;\n    printf(\"%lld\\n\",res);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nconst int mod = 1e9 + 7;\nmap<vi, int> dp, dp2;\n\nint pw2(int x){\n\tint res = 1;\n\tfor(ll m = 2; x; x /= 2){\n\t\tif(x & 1) res = res * m % mod;\n\t\tm = m * m % mod;\n\t}\n\treturn res;\n}\nvector<vi> children(const vi &h){\n\tint mn = *min_element(all(h)), n = h.size();\n\tvector<vi> cs;\n\tvi tmp;\n\trep(i, n){\n\t\tif(h[i] > mn) tmp.pb(h[i] - mn);\n\t\tif(h[i] == mn || i == n-1){\n\t\t\tif(tmp.size()) cs.pb(tmp);\n\t\t\ttmp.clear();\n\t\t}\n\t}\n\treturn cs;\n}\nint rec2(const vi &h){\n\tif(dp2.count(h)) return dp2[h];\n\tint &res2 = dp2[h], mn = *min_element(all(h));\n\tres2 = pw2(mn);\n\tfor(vi &c : children(h)) res2 = (ll)res2 * rec2(c) % mod;\n\treturn res2;\n}\nint rec(const vi &h){\n\tif(dp.count(h)) return dp[h];\n\tint &res = dp[h];\n\tint mn = *min_element(all(h)), rem = count(all(h), mn);\n\t\n\t//パターン1 i列目とi+1列目が反転でも同じでもいい\n\t//パターン2 i列目とi+1列目が反転\n\tint res1 = pw2(rem);\n\tint res2 = (pw2(mn) + mod - 2) % mod;\n\tfor(vi &c : children(h)){\n\t\tres1 = res1 * (ll)(rec(c) + rec2(c)) % mod;\n\t\tres2 = res2 * (ll)rec2(c) % mod;\n\t}\n\treturn res = (res1 + res2) % mod;\n}\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\t\n\tint n; cin >> n;\n\tvi h(n); rep(i, n) cin >> h[i];\n\tcout << rec(h) << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n \n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n \n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \ntemplate <class T>\nistream& operator>>(istream& is, vector<T>& v) {\n  for (T& x : v)\n    is >> x;\n  return is;\n}\n \ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n  if (!v.empty()) {\n    os << v.front();\n    for (int i = 1; i < v.size(); ++i)\n      os << ' ' << v[i];\n  }\n  return os;\n}\n\nconst int N = 110, P = 1000000007;\n\nint n;\nint h[N], stk[N], ch[N][2];\nint dp[N][2];\n\nint mpow(int x, int k) {\n  int ret = 1;\n  while (k) {\n    if (k & 1)\n      ret = ret * (ll)x % P;\n    x = x * (ll)x % P;\n    k >>= 1;\n  }\n  return ret;\n}\n\nvoid dfs(int x, int v) {\n  dp[x][0] = 1;\n  for (int k = 0; k < 2; ++k)\n    if (ch[x][k]) {\n      int c = ch[x][k];\n      dfs(c, h[x]);\n      dp[x][1] = (dp[x][1] * (ll)(dp[c][0] + dp[c][1]) * 2 + dp[x][0] * ((ll)dp[c][0] + dp[c][1] * 2)) % P;\n      dp[x][0] = dp[x][0] * (ll)dp[c][0] % P;\n    }\n  dp[x][0] = dp[x][0] * (ll)mpow(2, h[x] - v) % P;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  cin >> n;\n  for (int i = 1; i <= n; ++i)\n    cin >> h[i];\n  int cnt = 0;\n  for (int i = 1; i <= n; ++i) {\n    int cur = 0;\n    while (cnt && h[stk[cnt]] > h[i]) {\n      ch[stk[cnt]][1] = cur;\n      cur = stk[cnt--];\n    }\n    ch[i][0] = cur;\n    stk[++cnt] = i;\n  }\n  int cur = 0;\n  while (cnt > 1) {\n    ch[stk[cnt]][1] = cur;\n    cur = stk[cnt--];\n  }\n  int rt = stk[1];\n  ch[rt][1] = cur;\n  dfs(rt, 1);\n  int ans = (dp[rt][0] + dp[rt][1]) % P * 2 % P;\n  cout << ans << '\\n';\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<set>\n#include<unordered_map>\n#define lol(i,n) for(ll i=0;i<n;i++)\n#define mod 1000000007\n#define mul(a,b) a=(a*b)%mod;\ntypedef long long ll;\n\nusing namespace std;\nll po(ll x){\n    ll res=1;\n    for(ll y=2;x;x>>=1,y=y*y%mod){\n\tif(x&1)res=res*y%mod;\n    }\n    return res;\n}\nll mo(ll x){\n    x%=mod;\n    if(x<0)x+=mod;\n    return x;\n}\ntypedef pair<ll,ll> P;\n#define N 110\nvector<ll> v[N];\nll n,f[N],g[N],l[N],r[N],w[N],u[N],h[N],m;\nll ans;\nvoid func(ll x){\n    ll len=r[x]-l[x]-1;\n    if(len==1){\n\tmul(ans,po(w[x]));\n\tf[x]=g[x]=0;\n\treturn;\n    }\n    ll fm=1,gm=1,sum=0;\n    for(auto c:v[x]){\n\tfunc(c);\n\tif(r[c]-l[c]-1==1)continue;\n\tsum+=r[c]-l[c]-1;\n\tfm=mo(fm*f[c]);\n\tgm=mo(gm*(2*f[c]+g[c]));\n    }\n    if(sum==0){\n\tf[x]=mo(po(w[x]));\n\tg[x]=mo(po(len)-2);\n\treturn;\n    }\n    f[x]=mo(fm*po(w[x]));\n    g[x]=mo(gm*po(len-sum));\n    g[x]=mo(g[x]-2*fm);\n}\nint main(){\n    cin>>n;\n    if(n==1){\n\tcin>>n;\n\tcout<<po(n)<<endl;\n\treturn 0;\n    }\n    lol(i,n)cin>>h[i];\n    unordered_map<ll,vector<ll> >mas;\n    lol(i,n){\n\tmas[h[i]].push_back(i);\n    }\n    sort(h,h+n);\n    set<ll> st; st.insert(-1); st.insert(n);\n    m=1,l[0]=-1,r[0]=n,w[0]=u[0]=h[0];\n    lol(i,n){\n\tif(i&&h[i-1]==h[i])continue;\n\tfor(auto x:mas[h[i]]){\n\t    auto il=st.lower_bound(x); il--;\n\t    ll L=*il;\n\t    auto ir=st.upper_bound(x);\n\t    ll R=*ir;\n\t    if(l[m-1]==L&&r[m-1]==R)continue;\n\t    l[m]=L,r[m]=R,u[m]=w[m]=h[i],m++;\n\t}\n\tfor(auto x:mas[h[i]])st.insert(x);\n    }\n    lol(i,m){\n\tfor(ll j=i-1;~j;j--){\n\t    if(l[j]<=l[i]&&r[i]<=r[j]){\n\t\tv[j].push_back(i);\n\t\tw[i]=u[i]-u[j];\n\t\tbreak;\n\t    }\n\t}\n    }\n    ans=1;\n    func(0);\n    cout<<mo(ans*(f[0]+g[0]))<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <complex>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nconst ll mod = 1000000007;\n\nll add(ll x, ll y){\n    return (x+y)%mod;\n}\n\nll mul(ll x, ll y){\n    return (x%mod)*(y%mod)%mod;\n}\n\nll powll(ll x, ll y){\n    ll res = 1LL;\n    while(y){\n        if (y & 1LL)\n            res *= x;\n        res %= mod;\n        x = (x*x) % mod;\n        y >>= 1LL;\n    }\n    return res;\n}\n\nll divll(ll x, ll y){\n    return (x * powll(y,mod-2)) % mod;\n}\n\nmap<int, int> zip;\nVI unzip;\nvoid compress_coordinate(VI x){\n    x.push_back(0);\n    int n = x.size();\n    REP(i,n) unzip.push_back(x[i]);\n    sort(ALL(unzip));\n    unzip.erase(unique(ALL(unzip)), unzip.end());\n    REP(i,unzip.size()) zip[unzip[i]] = i;\n}\n\nconst int N = 105;\nll dp[N][N];\n\nint main() {\n    int n;\n    cin >> n;\n    VI h(n);\n    REP(i,n) h[i] = in();\n    compress_coordinate(h);\n    int m = unzip.size();\n\n    REP(j,m){\n        if (j == 0) dp[0][0] = powll(2, h[0]);\n        else if (h[0] >= unzip[j]) dp[0][j] = powll(2, h[0] - unzip[j] + 1);\n    }\n    REP(j,m-1){\n        dp[0][j] = (dp[0][j] - dp[0][j+1] + mod) % mod;\n    }\n\n    REP(i,n-1) REP(j,m){\n        if (h[i] >= h[i+1]){\n            if (unzip[j] < h[i+1]){\n                dp[i+1][j] = (dp[i+1][j] + dp[i][j]) % mod;\n            }else{\n                int x = zip[h[i+1]];\n                dp[i+1][x] = (dp[i+1][x] + 2 * dp[i][j]) % mod;\n            }\n        }else{\n            if (j < zip[h[i]]){\n                dp[i+1][j] = (dp[i+1][j] + dp[i][j] * powll(2, h[i+1] - h[i])) % mod;\n            }else{\n                FOR(k,zip[h[i]],zip[h[i+1]]){\n                    ll tmp = powll(2, h[i+1] - unzip[k]);\n                    if (k < zip[h[i+1]]) tmp = (tmp + mod - powll(2, h[i+1] - unzip[k+1])) % mod;\n                    dp[i+1][k] = (dp[i+1][k] + 2 * dp[i][j] * tmp) % mod;\n                }\n            }\n        }\n    }\n\n    // REP(i,n-1){\n    //     REP(j,m) cout << dp[i][j] << \" \";\n    //     cout << endl;\n    // }\n\n    ll ans = 0;\n    REP(j,m) ans = (ans + dp[n-1][j]) % mod;\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma warning (disable:4996)\n#include\"bits/stdc++.h\"\n#include<cassert>\n#define int long long\n#define MRE assert(0);\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nconst long long mod = 1000000007;\nconst long long inf = 1e17;\ntypedef pair<int, int> P;\nint n; \nint h[105];\nint dp1[105][105], dp2[105][105];\nint modpow(int a, int x) {\n\tint res = 1;\n\twhile (x) {\n\t\tif (x & 1)res = res*a%mod;\n\t\ta = a*a%mod;\n\t\tx >>= 1;\n\t}\n\treturn res;\n}\n\nvoid memo(int l, int r) {\n\tif (dp1[l][r] != -1)return;\n\tvector<P>V;\n\n\tint idx = l, mn = inf;\n\tfor (int i = l; i <= r; i++)mn = min(mn, h[i]);\n\tint idx2 = l;\n\n\twhile (1) {\n\t\twhile (idx2<=r&&h[idx2] == mn)idx2++;\n\t\tif (idx2 > r)break;\n\t\tint idx3 = idx2;\n\t\twhile (idx3<=r&&h[idx3] != mn)idx3++;\n\t\tV.push_back(P(idx2, idx3-1));\n\t\tidx2 = idx3 + 1;\n\t}\n\n\tif (V.size()) {//適切なマージ\n\t\tvector<P>V2;\n\t\trep(j, V.size()) {\n\t\t\tmemo(V[j].first, V[j].second);\n\t\t\tV2.push_back(P(dp1[V[j].first][V[j].second], dp2[V[j].first][V[j].second]));\n\t\t}\n\t\tint m = 0;\n\t\tfor(int i=l;i<=r;i++)if (h[i] == mn)m++;\n\t\tint sum = 1, sum2 = 2;\n\t\tint H = h[r + 1];\n\t\tif (l)H = max(H, h[l - 1]);\n\t\tH = mn - H;\n\t\trep(i, V2.size()) {\n\t\t\tsum *= V2[i].first + 2 * V2[i].second;\n\t\t\tsum %= mod;\n\t\t\tsum2 *= V2[i].second;\n\t\t\tsum2 %= mod;\n\t\t}\n\t\tsum = sum*modpow(2, m) % mod;\n\t\tint T = (sum + mod - sum2) % mod;\n\t\tsum2 = sum2*modpow(2, H-1) % mod;\n\t\tdp1[l][r] = T;\n\t\tdp2[l][r] = sum2;\n\t}\n\telse {\n\t\tint H = h[r + 1];\n\t\tif (l)H = max(H, h[l - 1]);\n\t\tint t = (modpow(2, r - l + 1) + mod - 2) % mod;\n\t\tint u = modpow(2, h[l]-H);\n\t\tdp1[l][r] = t;\n\t\tdp2[l][r] = u;\n\t}\n}\n\n\nsigned main() {\n\tcin >> n;\n\trep(i, n)cin >> h[i];\n\trep(i, n)rep(j, n)dp1[i][j] = dp2[i][j]= -1;\n\tmemo(0, n - 1);\n\tcout << (dp1[0][n - 1] + dp2[0][n - 1])%mod << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define pb push_back\n#define all(v) v.begin(), v.end()\n#define sz(v) int(v.size())\n#define pii pair<int, int>\n#define mp make_pair\n#define f first\n#define ll long long\n#define ld long double\n#define s second\n#define vec vector<int>\n\nusing namespace std;\n\nconst int N = (int) 1e3 + 10;\nconst int M = (int) 2e6 + 10;\nconst int K = (int) 20;\nconst int INF = (int) 1e9 + 7;\nconst int mod = (int) 998244353;\nconst ld EPS = (ld) 1e-9;\nconst ll LINF = (ll) 1e18;\nint n;\nvec all;\nint h[N];\n\nint mult(int x, int y) {\n\treturn 1ll * x * y % INF;\n}\n\nvoid add(int &x, int y) {\n\tx += y;\n\tif (x >= INF)\n\t\tx -= INF;\n\tif (x < 0) \n\t\tx += INF;\n}\n\nint sum(int x, int y) {\n\tadd(x, y);\n\treturn x;\n}\n\nint bp(int x, int y) {\n\tint ans = 1;\n\twhile (y) {\n\t\tif (y % 2) \n\t\t\tans = mult(ans, x);\n\t\tx = mult(x, x);\n\t\ty /= 2;\n\t}\n\treturn ans;\n}\n\nint f(int l, int r) {\n\t// 2^l + 2^(l+1) + ... + 2^r\n\tint pref = sum(bp(2, r + 1), -1);\n\tadd(pref, -sum(bp(2, l), -1));\n\treturn pref;\n}\n\nint dp[N][N];\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\t#ifdef sony\n\t\tfreopen(\"input.txt\", \"r\", stdin);\n\t\tfreopen(\"output.txt\", \"w\", stdout);\n\t#endif\n\tsrand(time(0));\n\tcin >> n;\n\tbool try_it = true;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> h[i];\n\t\tif (try_it) {\n\t\t\tall.pb(h[i]);\n\t\t\tif (h[i] > 1)\n\t\t\t\tall.pb(h[i] - 1);\n\t\t}\n\t}\n\tall.pb(1);\n\tif (!try_it) {\n\t\tfor (int i = 1; i <= 100; i++) {\n\t\t\tall.pb(i);\n\t\t}\n\t}\n\tsort(all.begin(), all.end());\n\tall.resize(unique(all.begin(), all.end()) - all.begin());\n\tfor (int i = 0; i < sz(all); i++) {\n\t\tif (all[i] < h[1]) { \n\t\t\tadd(dp[1][i], f(h[1] - all[i + 1] + 1, h[1] - all[i]));\n\n\t\t\t/*\n\t\t\tfor (int pos = all[i]; pos < all[i + 1]; pos++) {\n\t\t\t\tadd(dp[1][i], bp(2, h[1] - pos)); \n\t\t\t}\n\t\t\t*/\n\t\t}\n\t}\n\tdp[1][sz(all)] = 2; // no same\n\tfor (int i = 2; i <= n; i++) {\n\t\tfor (int j = 0; j < sz(all); j++) {\n\t\t\tif (all[j] >= h[i]) { \n\t\t\t\t// 010100\n\t\t\t\t// 10101\n\t\t\t\tadd(dp[i][sz(all)], mult(2, dp[i - 1][j]));\n\t\t\t} else {\n\t\t\t\t// all[j] < h[i]\n\n\t\t\t\t// 011000\n\t\t\t\t// abcde \n\t\t\t\tif (h[i] <= h[i - 1]) {\n\t\t\t\t\tadd(dp[i][j], dp[i - 1][j]);\n\t\t\t\t}\n\t\t\t\t// 011000\n\t\t\t\t// 100111abc\n\t\t\t\tif (h[i] > h[i - 1]) {\n\t\t\t\t\tadd(dp[i][j], mult(bp(2, h[i] - h[i - 1]), dp[i - 1][j]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (h[i] <= h[i - 1]) {\n\t\t\t// 01010101\n\t\t\t// abcde\n\t\t\tadd(dp[i][sz(all)], mult(2, dp[i - 1][sz(all)]));\n\t\t}\n\t\tif (h[i] > h[i - 1]) {\t\n\t\t\t// 01010101\n\t\t\t// abcdefghijk\n\t\t\t// no same \n\t\t\tadd(dp[i][sz(all)], mult(2, dp[i - 1][sz(all)]));\n\n\t\t\t// same but >= h[i - 1]\n\t\t\t// 010101\n\t\t\t// 1010100\n\n\t\t\tfor (int j = 0; j < sz(all); j++) {\n\t\t\t\tif (all[j] < h[i] && all[j] >= h[i - 1]) {\n\t\t\t\t\tadd(dp[i][j], mult(f(h[i] - all[j + 1] + 1, h[i] - all[j]), dp[i - 1][sz(all)]));\n\t\t\t\t\t/*\n\t\t\t\t\tfor (int pos = all[j]; pos < all[j + 1]; pos++) {\n\t\t\t\t\t\tadd(dp[i][j], mult(bp(2, h[i] - pos), dp[i - 1][sz(all)]));\n\t\t\t\t\t}\n\t\t\t\t\t*/\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int j = 0; j <= sz(all); j++) {\n\t\tadd(ans, dp[n][j]);\n\t}\n\tcout << ans;\n\treturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <iostream>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <unordered_map>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<int, P> Pint;\nconst ll MOD=1e9+7;\nll powmod(ll a, ll k){\n    ll ap=a, ans=1;\n    while(k>0){\n        if(k%2==1){\n            ans*=ap;\n            ans%=MOD;\n        }\n        ap=ap*ap;\n        ap%=MOD;\n        k/=2;\n    }\n    return ans;\n}\nint main()\n{\n\t\n\tint n;\n  ll h[101];\n  vector<ll> hs;\n  cin>>n;\n  for(int i=1; i<=n; i++){\n    cin>>h[i]; hs.push_back(h[i]);\n  }\n  sort(hs.begin(), hs.end());\n  hs.erase(unique(hs.begin(), hs.end()), hs.end());\n  ll dp[2][100][100]={};\n  vector<Pint> v;\n  for(int i=hs.size()-1; i>=0; i--){\n    bool nuo[102]={}, nuo2[102]={};\n    for(int j=1; j<=n; j++){\n      if(hs[i]<=h[j]) nuo[j]=1;\n    }\n    int l;\n    for(int j=0; j<=n; j++){\n      if(!nuo[j] && nuo[j+1]) l=j;\n      if(nuo[j] && !nuo[j+1]){\n        bool ok=0;\n        for(int k=l+1; k<=j; k++){\n          if(hs[i]==h[k]){\n            ok=1;\n            break;\n          }\n        }\n        if(ok) v.push_back(Pint(hs[i], P(l+1, j)));\n      }\n    }\n  }\n  bool used[100]={};\n  for(int i=0; i<v.size(); i++){\n    int l=v[i].second.first, r=v[i].second.second, d0=v[i].first;\n    //cout<<l<<\" \"<<r<<\" \"<<d0<<endl;\n    bool no=1;\n    dp[1][l][r]=2;\n    ll prod=1, prod1=1;\n    int ct=0;\n    bool nuo=0;\n    int ct2=0;\n    for(int j=0; j<i; j++){\n      int l1=v[j].second.first, r1=v[j].second.second;\n      if(l>l1 || r1>r) continue;\n      if(used[j]) continue;\n      used[j]=1;\n      no=0;\n      if(r1!=l1) nuo=1;\n      int d1=v[j].first;\n      dp[1][l][r]*=(dp[1][l1][r1]*powmod(2ll, d1-d0-1)%MOD);\n      dp[1][l][r]%=MOD;\n      prod*=(dp[0][l1][r1]+dp[1][l1][r1]*powmod(2ll, d1-d0)%MOD);\n      prod%=MOD;\n      prod1*=(dp[1][l1][r1]*powmod(2ll, d1-d0)%MOD);\n      prod1%=MOD;\n      ct+=(r1-l1+1);\n      ct2++;\n    }\n    if(no){\n      dp[0][l][r]=(powmod(2ll, r-l+1)-2+MOD)%MOD;\n    }else{\n      if(nuo) dp[0][l][r]=((prod-prod1+MOD)*powmod(2ll, r-l+1-ct)%MOD+dp[1][l][r]*500000004%MOD*(powmod(2ll, r-l+1-ct+ct2)+MOD-2)%MOD)%MOD;\n      else dp[0][l][r]=dp[1][l][r]*500000004%MOD*(powmod(2ll, r-l+1)+MOD-2)%MOD;\n    }\n    if(r-l+1==n){\n      ll ans=dp[0][l][r]+dp[1][l][r]*powmod(2ll, d0-1)%MOD;\n      ans%=MOD;\n      cout<<ans<<endl;\n    }\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-9;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nll Pow(ll n,ll p){\n\tll r=1;\n\tfor(;p>0;p>>=1){\n\t\tif(p&1) r=(r*n)%mod;\n\t\tn=(n*n)%mod;\n\t}\n\treturn r;\n}\n\nll n;\nvl a;\nvvl dp,DP;\n\nint main(){\n\tcin>>n;\n\ta=vl(n+2);\n\tdp=DP=vvl(n+2,vl(n+2));\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\tfor(int k=0;k<n;k++) for(int i=1;i<=n;i++) if(i+k<=n&&a[i-1]<a[i]||a[i+k]>a[i+k+1]){\n\t\tll L=i,R=i+k,m=inf,M=max(a[i-1],a[i+k+1]);\n\t\tfor(int j=L;j<=R;j++) m=min(m,a[j]);\n\t\tif(m<=M) continue;\n\t\tvi b,c;\n\t\tll I=L,t=0;\n\t\tfor(int j=L;j<=R;j++) if(a[j]==m){\n\t\t\tt++;\n\t\t\tif(I!=j){\n\t\t\t\tb.push_back(I);\n\t\t\t\tc.push_back(j-1);\n\t\t\t}\n\t\t\tI=j+1;\n\t\t}\n\t\tif(I!=R+1){\n\t\t\tb.push_back(I);\n\t\t\tc.push_back(R);\n\t\t}\n\t\tif(t==R-L+1){\n\t\t\tdp[L][R]=Pow(2,m-M-1);\n\t\t\tDP[L][R]=(Pow(2,t)+mod-2)%mod;\n\t\t\tcontinue;\n\t\t}\n\t\tll S=b.size(),res=1,sum=Pow(2,t);\n\t\tfor(int j=0;j<S;j++){\n\t\t\tint l=b[j],r=c[j];\n\t\t\t(res*=2*dp[l][r])%=mod;\n\t\t\t(sum*=4*dp[l][r]+DP[l][r])%=mod;\n\t\t}\n\t\t(sum+=2*mod-2*res)%=mod;\n\t\t(res*=Pow(2,m-M-1))%=mod;\n\t\tdp[L][R]=res,DP[L][R]=sum;\n\t}\n\tcout<<(2*dp[1][n]+DP[1][n])%mod<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define iinf 2000000000\n#define linf 1000000000000000000LL\n#define ulinf 10000000000000000000ull\n#define MOD1 1000000007LL\n#define mpr make_pair\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef unsigned long UL;\ntypedef unsigned short US;\ntypedef pair < int , int > pii;\nclock_t __stt;\ninline void TStart(){__stt=clock();}\ninline void TReport(){printf(\"\\nTaken Time : %.3lf sec\\n\",(double)(clock()-__stt)/CLOCKS_PER_SEC);}\ntemplate < typename T > T MIN(T a,T b){return a<b?a:b;}\ntemplate < typename T > T MAX(T a,T b){return a>b?a:b;}\ntemplate < typename T > T ABS(T a){return a>0?a:(-a);}\ntemplate < typename T > void UMIN(T &a,T b){if(b<a) a=b;}\ntemplate < typename T > void UMAX(T &a,T b){if(b>a) a=b;}\nint n,h[105],t[105],dp[105][105];\nint powM(int val,int pw,LL moD=MOD1){\n\tif(pw<0) return 0;\n    int ret=1;\n    while(pw){\n        if(pw&1) ret=((LL)ret*(LL)val)%moD;\n        val=((LL)val*(LL)val)%moD;\n        pw>>=1;\n    }\n    return ret%moD;\n}\nint calsum(int r,int l){\n\treturn (powM(2,r)+MOD1-powM(2,l))%MOD1;\n}\nbool cmp(int A,int B){\n\treturn h[A]<h[B];\n}\nint main(){\n    // inputting start\n    // 数据结构记得初始化！ n，m别写反！\n    int i,j,k,res=0;\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;++i){\n\t\tscanf(\"%d\",h+i);\n\t\tt[i]=i;\n\t}\n    #ifdef LOCAL\n        TStart();\n    #endif\n    // calculation start\n    // 数据结构记得初始化！ n，m别写反！\n\tt[n]=n;\n\th[n]=1;\n\tsort(t,t+n+1,cmp);\n\tfor(i=0;i<=n;++i){\n\t\tj=t[i];\n\t\tk=t[i+1];\n\t\tif(i==n) k=-1;\n\t\tif(h[j]<=h[0]){\n\t\t\tdp[0][j]=(2*calsum(h[0]-h[j],(k==-1?-1:(h[0]-h[k]))))%MOD1;\n\t\t}\n\t}\n\tfor(i=0;i<n;++i){\n\t\tfor(j=0;j<=n;++j){\n\t\t\tif(!dp[i][j]) continue;\n\t\t\tif(i==n-1) res=(res+dp[i][j])%MOD1;\n\t\t\tif(h[j]==h[i]) dp[i][j]=(dp[i][j]*2)%MOD1;\n\t\t\tif(h[i+1]<=h[i]){\n\t\t\t\tif(h[j]>=h[i+1] && h[j]!=h[i]){\n\t\t\t\t\tdp[i][j]=(dp[i][j]*2)%MOD1;\n\t\t\t\t}\n\t\t\t\tdp[i+1][(h[j]>=h[i+1])?(i+1):j]+=dp[i][j];\n\t\t\t\tdp[i+1][(h[j]>=h[i+1])?(i+1):j]%=MOD1;\n\t\t\t}\n\t\t\telse if(h[j]==h[i]){\n\t\t\t\tfor(k=0;k<=n;++k){\n\t\t\t\t\tint c=t[k],nx=t[k+1];\n\t\t\t\t\tif(k==n) nx=-1;\n\t\t\t\t\tif(h[c]>=h[j] && h[c]<=h[i+1]){\n\t\t\t\t\t\tint val=((LL)dp[i][j]*(LL)calsum(h[i+1]-h[c],(nx==-1?-1:h[i+1]-h[nx])))%MOD1;\n\t\t\t\t\t\tdp[i+1][c]+=val;\n\t\t\t\t\t\tdp[i+1][c]%=MOD1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdp[i+1][j]+=((LL)dp[i][j]*(LL)powM(2,h[i+1]-h[i]))%MOD1;\n\t\t\t\tdp[i+1][j]%=MOD1;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",res);\n    #ifdef LOCAL\n        TReport();\n    #endif\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, a, b) for(int i = a; i <= b; i++)\n#define per(i, a, b) for(int i = a; i >= b; i--)\ntypedef long long LL;\nconst int maxn = 105;\nconst LL mod = 1e9 + 7;\n\nint n, h[maxn];\nstruct Node {\n\tLL x, y;\n};\nLL ans;\n\nLL Ksm(LL a, LL b) {\n\tLL ans = 1;\n\twhile(b) {\n\t\tif(b&1) ans = ans*a%mod;\n\t\tb /= 2;\n\t\ta = a*a%mod;\n\t}\n\treturn ans;\n}\n\nNode Solve(int l, int r, int bot) {\n\tint cnt = 0, low = 1e9;\n\tNode ans;\n\trep(i, l, r) \n\t    low = min(low, h[i]);\n\trep(i, l, r)\n\t    if(h[i] == low) cnt++;\n\tif(cnt == r - l + 1) {\n\t\tif(!low) return (Node) {1, 1};\n\t\tans.y = Ksm(2, low - bot);\n\t\tans.x = (Ksm(2, r - l + 1) + Ksm(2, low - bot) - 2)%mod;\n\t\treturn ans; \n\t}\n\tLL c1 = 1, c2 = 1;\n\trep(i, l, r) {\n\t\tif(h[i] == low) continue;\n\t\tint cur = i;\n\t\twhile(h[cur + 1] > low && cur < r) cur++;\n\t\tNode res = Solve(i, cur, low);\n\t\ti = cur;\n\t\tc2 = c2*res.y%mod;\n\t\tc1 = c1*(res.x + res.y)%mod;\n\t}\n\tc1 = (c1*Ksm(2, cnt)%mod + c2*(Ksm(2, low - bot) - 2 + mod)%mod)%mod;\n\tc2 = c2*Ksm(2, low - bot)%mod;\n\treturn (Node) {c1, c2};\n}\n\nint main() {\n\tcin>>n;\n\trep(i, 1, n) \n\t    cin>>h[i];\n\tans = 1;\n\tfor(int i = 1; i <= n; i++)\n    \tif(h[i] > max(h[i - 1], h[i + 1])) {\n    \t\tans = ans*Ksm(2, h[i] - max(h[i - 1], h[i + 1]))%mod;\n            h[i] = max(h[i - 1], h[i + 1]);\n    \t}\n\tNode tmp = Solve(1, n, 0);\n\tcout<<(ans*tmp.x%mod + mod)%mod<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst long long inv2=500000004;\nconst int N=105,mu=1000000007;\nint h[N],b[N],dp[N],dp2[N],f[N],n;\nbool cmp(int x,int y){\n\treturn h[x]==h[y]?x<y:h[x]>h[y];\n}\nint find(int x){\n\tif (f[x]==x) return f[x];\n\tf[x]=find(f[x]);\n\treturn f[x];\n}\nint ksm(int x,int y){\n\tint ans=1;\n\tfor (;y;y>>=1,x=1ll*x*x%mu)\n\t\tif (y&1) ans=ans*1ll*x%mu;\n\treturn ans;\n}\nvoid merge(int x,int y){\n\tint fx=find(x),fy=find(y);\n\tif (fx==fy) return;\n\tint t2=ksm(2,h[fy]-h[fx])*1ll*dp2[fy]%mu;\n\tdp[fx]=(1ll*dp[fx]*(t2+dp[fy])%mu+1ll*dp2[fx]*dp[fy]%mu)%mu; \n\tdp2[fx]=inv2*t2%mu*dp2[fx]%mu;\n\tdp[fx]=(dp[fx]+dp2[fx])%mu;\n\tf[fy]=fx;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&h[i]);\n\tfor (int i=1;i<=n;i++) b[i]=i;\n\tstd::sort(b+1,b+n+1,cmp);\n\tfor (int i=1;i<=n;i++) dp2[i]=2,dp[i]=0,f[i]=i;\n\tfor (int j=1;j<=n;j++){\n\t\tint i=b[j];\n\t\tif (h[i-1]>=h[i]) merge(i,i-1);\n\t\tif (h[i+1]>=h[i]) merge(i,i+1); \n\t}\n\tint ff=find(1);\n\tprintf(\"%d\",(dp[ff]+1ll*dp2[ff]*ksm(2,h[ff]-1))%mu);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <vector>\n#include <cassert>\n#include <fstream>\n#include <algorithm>\n#include <list>\n#include <random>\n#include <ctime>\n#include <cmath>\n#include <random>\n#include <bitset>\n#include <complex>\n#pragma unroll\n#pragma loop count N\n#pragma ivdep\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n//#define int ll\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef pair<ld, ld> pld;\ntypedef complex<double> base;\n\n#define mmin(a, b) a = min(a, (b))\n#define mmax(a, b) a = max(a, (b))\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define ALL(a) a.begin(),a.end()\n#define sqr(x) (x) * (x)\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define cint const int &\n#define SZ(a) ((int)(a.size()))\n#define f(cnt) (((cnt) + 1) * (cnt) / 2)\n#define watch(x) cout << (#x) << \" = \" << x << endl;\n\nconst double PI = 2 * acos(0.0);\n\ntemplate<class T>\nvoid show(const set<T> &a) {\n    for (T x : a)\n        cout << x << \" \";\n    cout << endl;\n}\n\ntemplate<class T>\nvoid show(const vector<T> &a) {\n    for (T x : a)\n        cout << x << \" \";\n    cout << endl;\n}\n\nconst ll M = 1e9 + 7;\n\nll MOD(ll a) {\n    if (a >= 0) return a >= M ? a % M : a;\n    if (a <= -M) a %= M;\n    return a ? a + M : a;\n}\n\nconst int N = 109;\nconst int L = 1e6;\n\nstruct edge {\n    int u, v;\n    ll height;\n    edge(int u, int v, ll height): u(u), v(v), height(height) {\n\n    }\n\n};\nvector<edge> e;\n\nll pw(ll a, ll p) {\n    if (!p) return 1;\n    ll ret = pw(a, p >> 1);\n    ret = MOD(ret * ret);\n    if (p & 1) ret = MOD(ret * a);\n    return ret;\n}\n\nint counter = 1;\nvi g[L];\nll len[L];\nint vert[L];\nint start[L];\nll h[N];\nll dp[2][L];\n\ninline ll get_ways(int v) {\n    vvvl dp(N, vvl(2, vl(2, 0)));\n    vector<char> must(N, 0);\n    for (int id : g[v]) {\n        int to = e[id].v;\n        for (int i = 1; i < len[to]; ++i)\n            must[i + start[to]] = 1;\n    }\n    dp[start[v]][0][0] = dp[start[v]][0][1] = 1;\n    for (int i = 1; i < len[v]; ++i) {\n        int ind = i + start[v];\n        if (must[ind]) {\n            for (int z1 : {0, 1}) for (int z2 : {0, 1})\n                dp[ind][z1][z2] = dp[ind - 1][z1][!z2];\n        } else {\n            for (int z1 : {0, 1}) for (int z2 : {0, 1}) for (int z3 : {0, 1}) {\n                int nx = z1;\n                if (z2 != z3) nx = 1;\n                dp[ind][nx][z3] = MOD(dp[ind][nx][z3] + dp[ind - 1][z1][z2]);\n            }\n        }\n    }\n    ll ret = MOD(dp[start[v] + len[v] - 1][1][0] + dp[start[v] + len[v] - 1][1][1]);\n    return ret;\n}\n\nll dfs(int v) {\n    ll dp1 = 1; // wasn't any bad\n    ll dp2 = 0; /* was bad */;\n    ll restlen = len[v];\n    dp[0][v] = 1;\n    for (int id : g[v]) {\n        int to = e[id].v;\n        restlen -= len[to];\n        dfs(to);\n        ll curgood = MOD(pw(2, e[id].height - 1) * dp[0][to]);\n        dp[0][v] = MOD(dp[0][v] * curgood);\n        ll curbad = dp[1][to];\n        ll odp1 = dp1;\n        ll odp2 = dp2;\n        dp1 = MOD(odp1 * curgood * 2);\n        dp2 = MOD(odp2 * (curgood * 2 + curbad) + odp1 * curbad);\n    }\n    ll ways = get_ways(v);\n    dp[1][v] = MOD(dp2 * pw(2, restlen) + dp[0][v] * ways);\n    dp[0][v] = MOD(2 * dp[0][v]);\n}\n\nsigned main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n\n\n    int n;\n    cin >> n;\n    set<ll> hs;\n    fori (i, n) {\n        cin >> h[i];\n        hs.insert(h[i]);\n    }\n    ll prev = 0;\n    len[counter++] = n;\n    fori (i , n)\n        vert[i] = 1;\n    int curv = 0;\n    int par = 0;\n    for (auto hi : hs) {\n        int cnt = 0;\n        fori (i, n) {\n            if (h[i] >= hi) {\n                if (!cnt) {\n                    curv = counter++;\n                    start[curv] = i;\n                }\n                par = vert[i];\n                vert[i] = curv;\n                cnt++;\n            } else {\n                if (cnt >= 2) {\n                    len[curv] = cnt;\n                    g[par].pb(e.size());\n                    e.pb(edge(par, curv, hi - prev));\n                }\n                cnt = 0;\n            }\n        }\n        if (cnt >= 2) {\n            len[curv] = cnt;\n            g[par].pb(e.size());\n            e.pb(edge(par, curv, hi - prev));\n        }\n        prev = hi;\n    }\n    ll fre = 0;\n    fori (i, n) {\n        ll lf = 0, rf = 0;\n        if (i) lf = h[i - 1];\n        if (i != n - 1) rf = h[i + 1];\n        fre += max(0LL, h[i] - max(lf, rf));\n    }\n    dfs(2);\n    ll ans = MOD(dp[0][2] * pw(2, e[g[1][0]].height - 1) + dp[1][2]);\n    ans = MOD(ans * pw(2, fre));\n    cout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define XX first\n#define YY second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define REP rep\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\nconst ll MOD=1e9+7;\n\n#define rall(X) (X).rbegin(),(X).rend()\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n\ntemplate<ll mod>\nstruct ModInt{\n  using M=ModInt;\n  ll a;\n  M& put(ll v){\n    a=(v<mod)?v:v-mod;\n    return *this;\n  }\n  ModInt(ll v=0){put(v%mod+mod);}\n  M operator+(M x){return M().put(a+x.a);}\n  M operator-(M x){return M().put(a+mod-x.a);}\n  M operator*(M x){return M().put(a*x.a%mod);}\n  M operator/(M x){return *this*x.inv();}\n  M& operator+=(M x){return *this=*this+x;};\n  M& operator-=(M x){return *this=*this-x;};\n  M& operator*=(M x){return *this=*this*x;};\n  M& operator/=(M x){return *this=*this/x;};\n  bool operator==(M x){return a==x.a;}\n\n  M pow(ll m){\n    M x=*this,res=1;\n    while(m){\n      if(m&1)res*=x;\n      x*=x;\n      m>>=1;\n    }\n    return res;\n  }\n  M inv(){return pow(mod-2);}\n};\n\nusing Int = ModInt<MOD>;\n\nint N;\nvector<LL> hs;\nInt fact = 1;\n\nstruct Val {\n  Int dp1;\n  Int dp2;\n};\n\nstruct Val Calc(vector<LL> &hs) {\n  if (hs.size() == 1) {\n    fact *= Int(2).pow(hs[0]);\n    return Val{1, 1};\n  }\n\n  LL mh = 1LL << 40;\n  for (LL h : hs) {\n    MN(mh, h);\n  }\n\n  struct Val ret = {1, 1};\n  vector<LL> vec;\n  if (mh == 1) {\n    for (LL h : hs) {\n      if (h == 1) {\n        if (vec.size() > 1) {\n          auto res = Calc(vec);\n          ret.dp1 *= res.dp1;\n          ret.dp2 *= res.dp2;\n        } else if (vec.size() == 1) {\n          auto res = Calc(vec);\n          fact /= 2;\n          ret.dp2 *= 2;\n        }\n        vec.clear();\n        ret.dp2 *= 2;\n      } else {\n        vec.eb(h);\n      }\n    }\n\n    if (vec.size()) {\n      auto res = Calc(vec);\n      ret.dp1 *= res.dp1;\n      ret.dp2 *= res.dp2;\n    }\n    return ret;\n  }\n  \n  int w = 0;\n  for (LL h : hs) {\n    h -= mh;\n    if (h > 0) {\n      vec.eb(h);\n    } else {\n      ++w;\n      assert(h == 0);\n      if (vec.size()) {\n        auto res = Calc(vec);\n        ret.dp1 *= res.dp1;\n        ret.dp2 *= res.dp2;\n        if (vec.size() == 1) ++w;\n      }\n      vec.clear();\n    }\n  }\n\n  if (vec.size()) {\n    auto res = Calc(vec);\n    ret.dp1 *= res.dp1;\n    ret.dp2 *= res.dp2;\n    if (vec.size() == 1) ++w;\n  }\n\n  if (w == hs.size()) {\n    return {Int(2).pow(mh-1), Int(2).pow(mh) + Int(2).pow(w) - 2};\n  }\n\n  Int g = Int(2).pow(w);\n  ret.dp2 *= g;\n  Int t = Int(2).pow(mh);\n  ret.dp2 += ret.dp1 * (t*2+g*2-4);\n  ret.dp1 *= t;\n  return ret;\n}\n\nsigned main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n  cin >> N;\n  rep(i, N) {\n    LL h;\n    cin >> h;\n    hs.eb(h);\n  }\n  cout << (fact*Calc(hs).dp2).a << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n\nconst int N = 1e6 + 10;\nconst int mod = 1e9 + 7;\nint h[N], st[N], top, n, ls[N], rs[N], root, f[N][2], num[N], single[N], mulsingle[N], rev[N];\nbool bsin[N];\n\ninline void build()\n{\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tint k = top;\n\t\twhile (k > 0 && h[st[k]] > h[i]) k--;\n\t\tif (k) rs[st[k]] = i;\n\t\tif (k < top) ls[i] = st[k + 1];\n\t\tst[++k] = i;\n\t\ttop = k;\n\t}\n\troot = st[1];\n}\n\nvoid dfs(int x)\n{\n\tif (!x) return;\n\tcout << \"x \" << x << endl;\n\tdfs(ls[x]), dfs(rs[x]);\n}\n\ninline int fp(int a, int n)\n{\n\tint res = 1;\n\twhile (n)\n\t{\n\t\tif (n & 1) res = (res * a) % mod;\n\t\ta = (a * a) % mod;\n\t\tn >>= 1;\n\t}\n\treturn res % mod;\n}\n\ninline void fill(int *a, int siz, int val)\n{\n\tfor (int i = 1; i <= siz; i++)\ta[i] = val;\n}\n\ninline void dp(int x, int fa)\n{\n\tif (!x) return;\n\tnum[x] = 1;\n\trev[x] = 1;\n\tint height = h[x] - h[fa];\n\t// if (!rs[x] && !ls[x] && h[x] != h[fa])\n\t// {\n\t// \tsingle[x] = 1;\n\t// \tmulsingle[x] *= fp(2, height);\n\t// \treturn;\n\t// }\n\tif (!rs[x] && !ls[x] && h[x] == h[fa])\n\t\treturn;\n\tdp(ls[x], x);\n\tdp(rs[x], x);\n\t// if (ls[x] && x - ls[x] == 1) rev[x] += single[ls[x]];\n\t// if (rs[x] && rs[x] - x == 1) rev[x] += single[rs[x]];\n\t// if (ls[x]) mulsingle[x] *= mulsingle[ls[x]];\n\t// if (rs[x]) mulsingle[x] *= mulsingle[rs[x]]; \n\tif (ls[x] && h[ls[x]] == h[x]) rev[x] += rev[ls[x]];\n\tif (rs[x] && h[rs[x]] == h[x]) rev[x] += rev[rs[x]];\n\tif (f[ls[x]][1] == 0) ls[x] = 0;\n\tif (f[rs[x]][1] == 0) rs[x] = 0;\n\n\tif (height > 0)\n\t{\n\t\tif (rs[x] && ls[x])\n\t\t{\n\t\t\tf[x][1] = f[rs[x]][1] * f[ls[x]][1] % mod  * fp(2, height) % mod;\n\t\t\t// cout << \"fk1 \" << f[rs[x]][1] << ' ' << f[ls[x]][1] << endl;\n\t\t\t// cout << \"fk0 \" << f[rs[x]][0] << ' ' << f[ls[x]][0] << endl;\n\t\t\tf[x][0] = (((f[rs[x]][1] * f[ls[x]][0] % mod * 2 * (fp(2, rev[x])) % mod + f[rs[x]][0] * f[ls[x]][1] % mod * 2 * (fp(2, rev[x])) % mod) % mod + f[rs[x]][0] * f[ls[x]][0] % mod * fp(2, rev[x]) % mod) % mod + f[rs[x]][1] * f[ls[x]][1] % mod * (2 * 2 * (fp(2, rev[x])) - 2) % mod) % mod;\n\t\t}\n\t\telse if (rs[x])\n\t\t{\n\t\t\tf[x][1] = f[rs[x]][1] * fp(2, height) % mod;\n\t\t\tf[x][0] = (f[rs[x]][0] * fp(2, rev[x]) % mod + f[rs[x]][1] * (2 * fp(2, rev[x]) - 2) % mod) % mod;\n\t\t}\n\t\telse if (ls[x])\n\t\t{\n\t\t\tf[x][1] = f[ls[x]][1] * fp(2, height) % mod;\n\t\t\tf[x][0] = (f[ls[x]][0] * fp(2, rev[x]) % mod + f[ls[x]][1] * (2 * fp(2, rev[x]) - 2) % mod) % mod;\n\t\t}\n\t\telse \n\t\t{\n\t\t\tf[x][1] = fp(2, height);\n\t\t\tf[x][0] = (fp(2, rev[x]) - 2) % mod;\n\t\t}\n\t}\t\n\telse \n\t{\n\t\tif (rs[x] && ls[x])\n\t\t{\n\t\t\tf[x][1] = f[rs[x]][1] * f[ls[x]][1] % mod;\n\t\t\tf[x][0] = ((f[rs[x]][0] * f[ls[x]][0] % mod + f[rs[x]][1] * f[ls[x]][0] % mod) % mod + f[rs[x]][0] * f[ls[x]][1] % mod) % mod;\n\t\t}\n\t\telse if (rs[x])\n\t\t{\n\t\t\tf[x][1] = f[rs[x]][1];\n\t\t\tf[x][0] = f[rs[x]][0];\n\t\t}\n\t\telse if (ls[x])\n\t\t{\n\t\t\tf[x][1] = f[ls[x]][1];\n\t\t\tf[x][0] = f[ls[x]][0];\n\t\t}\n\t}\n\t// cout << \"x \" << x << endl;\n\t// cout << \"f[x][1] \" << f[x][1] << endl;\n\t// cout << \"f[x][0] \" << f[x][0] << endl;\n\t// cout << \"rev[x] \" << rev[x] << endl;\n}\n\nsigned main()\n{\n\tint ml = 0;\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++)\tcin >> h[i];\n\tif (n == 1)\n\t{\n\t\tcout << fp(2, h[1]) << endl;\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tif (h[i] > h[i - 1] && h[i] > h[i + 1]) ml += h[i] - max(h[i - 1], h[i + 1]), h[i] = max(h[i - 1], h[i + 1]);\n\tbuild();\n\tfill(mulsingle, n, 1);\n\tf[0][1] = f[0][0] = 1;\n\tdp(root, 0);\n\t// cout << \"mul \" << mulsingle[root] << endl;\n\tcout << (f[root][1] + f[root][0]) % mod * fp(2, ml) % mod << endl;\n\t// cout << \"1 \" << f[root][1] << endl;\n\t// cout << \"0 \" << f[root][0] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<list>\n#include<set>\n#include<string>\n#include <iomanip>\nusing namespace std;\nint gcd(int a, int b) {\n\tint c = a % b;\n\twhile (c != 0) {\n\t\ta = b;\n\t\tb = c;\n\t\tc = a % b;\n\t}\n\treturn b;\n}\nstruct UnionFind {\n\tvector<int> par; // par[i]:iの親の番号　(例) par[3] = 2 : 3の親が2\n\n\tUnionFind(int N) : par(N) { //最初は全てが根であるとして初期化\n\t\tfor (int i = 0; i < N; i++) par[i] = i;\n\t}\n\n\tint root(int x) { // データxが属する木の根を再帰で得る：root(x) = {xの木の根}\n\t\tif (par[x] == x) return x;\n\t\treturn par[x] = root(par[x]);\n\t}\n\n\tvoid unite(int x, int y) { // xとyの木を併合\n\t\tint rx = root(x); //xの根をrx\n\t\tint ry = root(y); //yの根をry\n\t\tif (rx == ry) return; //xとyの根が同じ(=同じ木にある)時はそのまま\n\t\tpar[rx] = ry; //xとyの根が同じでない(=同じ木にない)時：xの根rxをyの根ryにつける\n\t}\n\n\tbool same(int x, int y) { // 2つのデータx, yが属する木が同じならtrueを返す\n\t\tint rx = root(x);\n\t\tint ry = root(y);\n\t\treturn rx == ry;\n\t}\n};\ntypedef long long ll;\n\nll M = 1000000007;\n\nvector<ll> fac(1000001); //n!(mod M)\nvector<ll> ifac(1000001); //k!^{M-2} (mod M)\n\nll mpow(ll x, ll n) {\n\tll ans = 1;\n\twhile (n != 0) {\n\t\tif (n & 1) ans = ans * x % M;\n\t\tx = x * x % M;\n\t\tn = n >> 1;\n\t}\n\treturn ans;\n}\nvoid setcomb() {\n\tfac[0] = 1;\n\tifac[0] = 1;\n\tfor (ll i = 0; i < 1000000; i++) {\n\t\tfac[i + 1] = fac[i] * (i + 1) % M; // n!(mod M)\n\t}\n\tifac[1000000] = mpow(fac[1000000], M - 2);\n\tfor (ll i = 1000000; i > 0; i--) {\n\t\tifac[i - 1] = ifac[i] * i%M;\n\t}\n}\nll comb(ll a, ll b) {\n\tif (a == 0 && b == 0)return 1;\n\tif (a < b || a < 0)return 0;\n\tll tmp = ifac[a - b] * ifac[b] % M;\n\treturn tmp * fac[a] % M;\n}\nll perm(ll a, ll b) {\n\tif (a == 0 && b == 0)return 1;\n\tif (a < b || a < 0)return 0;\n\treturn fac[a] * ifac[a - b] % M;\n}\n// mod. m での a の逆元 a^{-1} を計算する\nlong long modinv(long long a) {\n\tlong long b = M, u = 1, v = 0;\n\twhile (b) {\n\t\tlong long t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= M;\n\tif (u < 0) u += M;\n\treturn u;\n}\nvector<vector<ll>> mul(vector<vector<ll>> a, vector<vector<ll>> b, int n) {\n\tint i, j, k, t;\n\tvector<vector<ll>> c(n);\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = 0; j < n; j++) {\n\t\t\tt = 0;\n\t\t\tfor (k = 0; k < n; k++)\n\t\t\t\tt = (t + a[i][k] * b[k][j] % M) % M;\n\t\t\tc[i].push_back(t);\n\t\t}\n\t}\n\treturn c;\n}\n\ntemplate< typename Monoid >\nstruct SegmentTree {\n\n\tint sz;\n\tvector< Monoid > seg;\n\n\tconst Monoid M1;\n\n\tSegmentTree(int n, const Monoid &M1) : M1(M1) {\n\t\tsz = 1;\n\t\twhile (sz < n) sz <<= 1;\n\t\tseg.assign(2 * sz, M1);\n\t}\n\n\tvoid set(int k, const Monoid &x) {\n\t\tseg[k + sz] = x;\n\t}\n\n\tvoid build() {\n\t\tfor (int k = sz - 1; k > 0; k--) {\n\t\t\tseg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n\t\t}\n\t}\n\n\tvoid update(int k, const Monoid &x) {\n\t\tk += sz;\n\t\tseg[k] = x;\n\t\twhile (k >>= 1) {\n\t\t\tseg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n\t\t}\n\t}\n\n\tMonoid query(int a, int b) {\n\t\tMonoid L = M1, R = M1;\n\t\tfor (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n\t\t\tif (a & 1) L = f(L, seg[a++]);\n\t\t\tif (b & 1) R = f(seg[--b], R);\n\t\t}\n\t\treturn f(L, R);\n\t}\n\n\tMonoid value(const int &k) const {\n\t\treturn seg[k + sz];\n\t}\n\n\tMonoid f(Monoid a, Monoid b) {\n\t\treturn a + b;\n\t}\n};\n\nll n, h[111], ans = 1;\nll calc(ll l,ll r,ll nowh,ll dish,ll info) {\n\tif (r - l == 1)\n\t\treturn 1;\n\telse {\n\t\tll p,count=0;\n\t\tif (!info) {\n\t\t\tll nl = -1, mh = 1e12, t = 1;\n\t\t\tfor (ll nr = 0; nr < r; nr++) {\n\t\t\t\tif (h[nr] == nowh) {\n\t\t\t\t\tcount++;\n\t\t\t\t\tt *= calc(nl, nr, mh, mh - nowh, 0);\n\t\t\t\t\tt %= M;\n\t\t\t\t\tnl = nr;\n\t\t\t\t\tmh = 1e12;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tmh = min(mh, h[nr]);\n\t\t\t}\n\t\t\tt *= calc(nl, r, mh, mh - nowh, 0);\n\t\t\tt %= M;\n\t\t\tp = t;\n\t\t\tnl = -1;\n\t\t\tmh = 1e12;\n\t\t\tt = 1;\n\t\t\tfor (ll nr = 0; nr < r; nr++) {\n\t\t\t\tif (h[nr] == nowh) {\n\t\t\t\t\tt *= calc(nl, nr, mh, mh - nowh, 1);\n\t\t\t\t\tt %= M;\n\t\t\t\t\tnl = nr;\n\t\t\t\t\tmh = 1e12;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tmh = min(mh, h[nr]);\n\t\t\t}\n\t\t\tt *= calc(nl, r, mh, mh - nowh, 1);\n\t\t\tt %= M;\n\t\t\tt *= mpow(2, dish) - 1;\n\t\t\tt %= M;\n\t\t\tt *= modinv(mpow(2, count));\n\t\t\tt %= M;\n\t\t\tp += t;\n\t\t\tp %= M;\n\t\t}\n\t\telse {\n\t\t\tll nl = -1, mh = 1e12, t = 1;\n\t\t\tfor (ll nr = 0; nr < r; nr++) {\n\t\t\t\tif (h[nr] == nowh) {\n\t\t\t\t\tcount++;\n\t\t\t\t\tt *= calc(nl, nr, mh, mh - nowh, 1);\n\t\t\t\t\tt %= M;\n\t\t\t\t\tnl = nr;\n\t\t\t\t\tmh = 1e12;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tmh = min(mh, h[nr]);\n\t\t\t}\n\t\t\tt *= calc(nl, r, mh, mh - nowh, 0);\n\t\t\tt %= M;\n\t\t\tt *= mpow(2, dish);\n\t\t\tt %= M;\n\t\t\tt *= modinv(mpow(2, count));\n\t\t\tt %= M;\n\t\t\tp = t;\n\t\t}\n\t\treturn p;\n\t}\n}\n\nint main() {\n\tcin >> n;\n\tfor (ll i = 0; i < n; i++)\n\t\tcin >> h[i];\n\tll l = -1,mh=1e12;\n\tfor (ll r = 0; r < n; r++) {\n\t\tif (h[r] == 1) {\n\t\t\tans *= calc(l, r, mh, mh - 1, 0);\n\t\t\tans %= M;\n\t\t\tans *= mpow(2, r - l - 1);\n\t\t\tans %= M;\n\t\t\tans *= 2;\n\t\t\tans %= M;\n\t\t\tl = r;\n\t\t\tmh = 1e12;\n\t\t}\n\t\telse\n\t\t\tmh = min(mh, h[r]);\n\t}\n\tans *= calc(l, n, mh, mh - 1, 0);\n\tans %= M;\n\tans *= mpow(2, n - l - 1);\n\tans %= M;\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nconst int N = 105;\nconst int INF = 0x3f3f3f3f;\ntypedef long long ll;\n#define lson l, m, rt<<1\n#define rson m+1, r, rt<<1|1\nconst int MOD = 1e9+7;\n\n\nint h[N];\nint Has[N]; int tot;\nll dp[N][N];\n\nll Pow(ll x, ll y) {\n\tif(y <= 0) return 1;\n\tll result = 1;\n\twhile(y) {\n\t\tif(y & 1)\n\t\t\tresult = result * x % MOD;\n\t\ty >>= 1;\n\t\tx = x*x % MOD;\n\t}\n\treturn result;\n}\n\nint main() {\n\tint n;\n\twhile(~scanf(\"%d\", &n)) {\n\t\ttot = 0;\n\t\tmemset(dp, 0, sizeof(dp));\n\t\th[0] = 0;\n\t\tdp[0][0] = 1;\n\n\t\tfor(int i = 1; i <= n; ++i) {\n\t\t\tscanf(\"%d\", &h[i]);\n\t\t\tHas[++tot] = h[i];\n\t\t}\n\t\tsort(Has + 1, Has + tot + 1);\n\t\ttot = unique(Has+1, Has + tot + 1) - Has - 1;\n\t\t\n\t\tfor(int i = 1; i <= n; ++i) {\n\t\t\th[i] = lower_bound(Has + 1, Has + tot + 1, h[i]) - Has;\n\t\t}\n\t\t\n\t\t\n\t\tfor(int i = 1; i <= n; ++i) {\n\t\t\tdp[i][0] = dp[i-1][0] * 2 % MOD;\n\t\t\tfor(int j = h[i] + 1; j <= h[i-1]; ++j) dp[i][0] = (dp[i][0] + dp[i-1][j] * 2 % MOD) % MOD;\n\n\t\t\tll tmpPow = Pow(2, Has[h[i]] - Has[h[i-1]]);\n\t\t\tfor(int j = 1; j <= h[i]; ++j) {\n\t\t\t\tdp[i][j] = dp[i-1][j] * tmpPow % MOD;\n\t\t\t}\n\n\t\t\tfor(int j = h[i-1] + 1; j <= h[i]; ++j) {\n\t\t\t\tdp[i][j] = (dp[i][j] + j==1? ( dp[i-1][0] * ( Pow(2, Has[j]) - 2) % MOD * Pow(2, Has[h[i]] - Has[j]) % MOD ) :\n\t\t\t\t\t\t\t\t\t\t\t ( dp[i-1][0] * 2 * (Pow(2, Has[j]-Has[j-1]) - 1) % MOD * Pow(2, Has[h[i]]-Has[j]) % MOD ) \n\t\t\t\t\t\t\t\t\t\t\t ) %MOD;\n\t\t\t}\n\t\t}\n\n\n\t\tll result = 0;\n\t\tfor(int i = 0; i <= tot; ++i) {\n\t\t\tresult = (result + dp[n][i]) % MOD;\n\t\t}\n\t\tprintf(\"%lld\\n\", result);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\ntypedef long long ll;\n\ninline int Max(const int a,const int b){return a>b?a:b;}\n\n#define pii pair<int,int>\n#define fi first\n#define se second\n\nint n,h[105];\nconst int Mod=1000000007,Inf=0x3f3f3f3f;\n\nll Pow(ll a,ll b)\n{\n    ll s=1;\n    for(;b;b>>=1,a=a*a%Mod)\n        if(b&1)s=s*a%Mod;\n    return s%Mod;\n}\n\nstd::pair<int,int> Solve(int l,int r,int Lim)\n{\n    int Minh=Inf,Cnt=0;\n    for(int i=l;i<=r;++i)\n        if(h[i]<Minh)Minh=h[i],Cnt=1;\n        else if(h[i]==Minh)++Cnt;\n    if(Cnt==r-l+1)return std::make_pair(int((Pow(2,r-l+1)+Mod-2)%Mod),(int)Pow(2,Minh-Lim-1));\n    int Rem=r-l+1,s0=1,s1=1,Las=0;\n    for(int i=l;i<=r+1;++i)\n        if(!Las&&h[i]!=Minh)Las=i;\n        else if(Las&&(h[i]==Minh||i>r))\n        {\n            std::pair<int,int> Tmp=Solve(Las,i-1,Minh);\n            s0=(ll)s0*(Tmp.first+4ll*Tmp.second%Mod)%Mod;\n            s1=(ll)s1*2ll*Tmp.second%Mod,Rem-=i-Las,Las=0;\n        }\n    s0=(s0+Mod-s1)%Mod;\n    return std::make_pair(int((s0*Pow(2,Rem)%Mod+s1*(Pow(2,Rem)+Mod-2))%Mod),int(s1*Pow(2,Minh-Lim-1)%Mod));\n}\n\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;++i)scanf(\"%d\",&h[i]);\n    if(n==1)return printf(\"%d\\n\",int(Pow(2,h[1]))),0;\n    int Ex=1;\n    for(int i=1;i<=n;++i)\n        if(h[i]>h[i-1]&&h[i]>h[i+1])\n        {\n            Ex=(Ex*Pow(2,h[i]-Max(h[i-1],h[i+1])))%Mod;\n            h[i]=Max(h[i-1],h[i+1]);\n        }\n    std::pair<int,int> Ans=Solve(1,n,0);\n    printf(\"%d\\n\",int(Ex*(Ans.first+2ll*Ans.second)%Mod));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\n#include <stdlib.h>\n#include <vector>\n#include <map>\n#include <queue>\n#include <windows.h>\n#include <set>\n#include <string>\n#include <string.h>\n#include <stack>\n#define Endl endl\n#define mp make_pair\n#define ll long long \n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define over(A) {cout<<A<<endl;exit(0);}\n#define all(A) A.begin(),A.end()\n#define ceil(a,b) ((a-1)/b+1)\n#define srand() mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n#define rand(l,r) uniform_int_distribution<int>(l,r)(rng)\ntypedef unsigned long long ull;\nconst int inf=1039074182;\nusing namespace std;\nint n;\nint h[105];\nint res=1;\nvector <pair<pair<int,int>,int> >vec;\nint dp[105][105][2];\n\nnamespace combinatorics\n{\n\tint mod=1e9+7;\n\tinline int add(int a,int b)\n\t{\n\t\treturn (a+b)%mod;\n\t}\n\tinline int minus(int a,int b)\n\t{\n\t\treturn (a-b+mod)%mod;\n\t}\n\tinline int mutiply(int a,int b)\n\t{\n\t\treturn (1LL*a*b)%mod;\n\t}\n\tinline int fastpow(int basic,int x)\n\t{\n\t\tint res=1;\n\t\twhile(x)\n\t\t{\n\t\t\tif(x&1)\tres=mutiply(res,basic);\n\t\t\tbasic=mutiply(basic,basic);\n\t\t\tx>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tinline int inv(int x)\n\t{\n\t\treturn fastpow(x,mod-2);\n\t}\n};\nusing namespace combinatorics;\n\ninline void solve(int l,int r)\n{\n//\tcout<<l<<' '<<r<<endl;\n//\tSleep(1000);\n\tif(l==r) return;\n\tint mi=inf,ma=inf;\n\tfor(int i=l;i<r;i++)\n\t{\n\t\tmi=min(mi,h[i]);\n\t}\n\tvec.push_back({{l,r},mi-(l==0 && r==n)});\n\tfor(int i=l;i<r;i++)\n\t{\n\t\th[i]-=mi;\n\t}\n\tint last=l;\n\tfor(int i=l;i<=r;i++)\n\t{\n\t\tif(h[i]==0) solve(last,i),last=i+1;\n\t}\n}\n\ninline int way(int l,int r)\n{\n\tint res=0;\n\tfor(auto x:vec)\n\t{\n\t\tif(l<=x.first.first && r>=x.first.second) res=add(res,x.second);\n\t}\n\treturn fastpow(2,res);\n}\n\nint main()\n{\n\tcin>>n;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcin>>h[i];\n\t}\n\tsolve(0,n);\n//\tfor(auto x:vec)\n//\t{\n//\t\tprintf(\"From %d to %d, having %d floors.\\n\",x.first.first+1,x.first.second,x.second);\n//\t}\n\tdp[0][1][0]=1;\n\tdp[0][1][1]=1;\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tfor(int j=1;j<=i+1;j++)\n\t\t{\n\t\t\tfor(int k=0;k<2;k++)\n\t\t\t{\n\t\t\t\tdp[i+1][j+1][k]=add(dp[i+1][j+1][k],dp[i][j][k]);\n\t\t\t\tdp[i+1][1][!k]=add(dp[i+1][1][!k],mutiply(dp[i][j][k],way(i-j+1,i+1)));\n\t\t\t}\n\t\t}\n\t}\n\tint res=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tdp[n-1][i][0]=mutiply(dp[n-1][i][0],way(n-i,n));\n\t\tdp[n-1][i][1]=mutiply(dp[n-1][i][1],way(n-i,n));\n\t\tres=add(res,add(dp[n-1][i][0],dp[n-1][i][1]));\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<set>\n#include<unordered_map>\n#define lol(i,n) for(ll i=0;i<n;i++)\n#define mod 1000000007\n#define mul(a,b) a=(a*b)%mod;\ntypedef long long ll;\n\nusing namespace std;\nll po(ll x){\n    ll res=1;\n    for(ll y=2;x;x>>=1,y=y*y%mod){\n\tif(x&1)res=res*y%mod;\n    }\n    return res;\n}\nll mo(ll x){\n    x%=mod;\n    if(x<0)x+=mod;\n    return x;\n}\ntypedef pair<ll,ll> P;\n#define N 110\nvector<ll> v[N];\nll n,f[N],g[N],l[N],r[N],w[N],u[N],h[N],m;\nll ans;\nvoid func(ll x){\n    ll len=r[x]-l[x]-1;\n    if(len==1){\n\tmul(ans,po(w[x]));\n\tf[x]=g[x]=0;\n\treturn;\n    }\n    ll fm=1,gm=1,sum=0;\n    for(auto c:v[x]){\n\tfunc(c);\n\tif(r[c]-l[c]-1==1)continue;\n\tsum+=r[c]-l[c]-1;\n\tfm=mo(fm*f[c]);\n\tgm=mo(gm*(2*f[c]+g[c]));\n\t//cout<<2*f[c]+g[c]<<\":\"<<gm<<\" \";\n    }\n    if(sum==0){\n\tf[x]=mo(po(w[x]));\n\tg[x]=mo(po(len)-2);\n\treturn;\n    }\n    //cout<<\"#\"<<x<<\" \"<<fm<<\" \"<<gm<<endl;\n    f[x]=mo(fm*po(w[x]));\n    g[x]=mo(gm*po(len-sum));\n    g[x]=mo(g[x]-2*fm);\n}\nint main(){\n    cin>>n;\n    if(n==1){\n\tcin>>n;\n\tcout<<po(n)<<endl;\n\treturn 0;\n    }\n    lol(i,n)cin>>h[i];\n    unordered_map<ll,vector<ll> >mas;\n    lol(i,n){\n\tmas[h[i]].push_back(i);\n    }\n    sort(h,h+n);\n    set<ll> st; st.insert(-1); st.insert(n);\n    m=1,l[0]=-1,r[0]=n,w[0]=u[0]=h[0];\n    lol(i,n){\n\tif(i&&h[i-1]==h[i])continue;\n\tfor(auto x:mas[h[i]]){\n\t    auto il=st.lower_bound(x); il--;\n\t    ll L=*il;\n\t    auto ir=st.upper_bound(x);\n\t    ll R=*ir;\n\t    if(l[m-1]==L&&r[m-1]==R)continue;\n\t    l[m]=L,r[m]=R,u[m]=w[m]=h[i],m++;\n\t}\n\tfor(auto x:mas[h[i]])st.insert(x);\n    }\n    lol(i,m){\n\tfor(ll j=i-1;~j;j--){\n\t    if(l[j]<=l[i]&&r[i]<=r[j]){\n\t\tv[j].push_back(i);\n\t\tw[i]=u[i]-u[j];\n\t\tbreak;\n\t    }\n\t}\n    }\n    ans=1;\n    func(0);\n    cout<<mo(ans*(f[0]+g[0]))<<endl;\n    /*\n    lol(i,m){\n\tcout<<i<<\":\"<<l[i]+1<<\" \"<<r[i]-1<<\" \"<<w[i]<<endl;\n\tcout<<\"f=\"<<f[i]<<\" g=\"<<g[i]<<endl;\n\tfor(auto x:v[i])cout<<x<<\" \";cout<<endl;\n    }*/\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <map>\n#include <list>\n#include <iterator>\n#include <set>\n#include <queue>\n#include <iostream>\n#include <sstream>\n#include <stack>\n#include <deque>\n#include <cmath>\n#include <memory.h>\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <algorithm>\n#include <utility>\n#include <time.h>\n#include <bitset>\n#include <assert.h>\n#include <complex.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(int i=(a)-1;i>=(b);--i)\n#define FILL(A,val) memset(A,val,sizeof(A))\n\n#define ALL(V) V.begin(),V.end()\n#define SZ(V) (int)V.size()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long Int;\ntypedef unsigned long long UInt;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double Pi = acos(-1.0);\nconst int INF = 1000000000;\nconst Int INF2 = Int(INF) * 5000;\nconst Int INF3 = Int(INF) * INF;\nconst int MAX = 100007;\nconst int MAXE = 2007000;\nconst int MAXV = 5000;\nconst int BASE = 1000000000;\nconst int ST = 1000000007;\n\nconst int MOD = 1000000007;\n\nint A[MAX];\nInt bpow(Int a, Int k)\n{\n    Int res = 1;\n    while (k)\n    {\n        if (k & 1)\n        {\n            res *= a;\n            res %= MOD;\n        }\n        a *= a;\n        a %= MOD;\n        k /= 2;\n    }\n    return res;\n}\n\nInt solve(int L, int R)\n{\n    if (L > R) return 1;\n\n    if (L == R)\n    {\n        return bpow(2 , A[L]);\n    }\n\n    Int val1 = (bpow(2 , R - L + 1) - 2 + MOD) % MOD;\n    FOR(i,L, R + 1)\n    {\n        int cnt = INF;\n        if (i - 1 >= L) cnt = min(cnt , A[i] - A[i - 1]);\n        if (i + 1 <= R) cnt = min(cnt , A[i] - A[i + 1]);\n        if (cnt < 0) cnt = 0;\n        val1 *= bpow(2 , cnt);\n        val1 %= MOD;\n    }\n\n    Int val2 = 1;\n\n    VI H;\n    FOR(i,L,R + 1)\n    {\n        H.push_back(A[i]);\n    }\n    H.push_back(0);\n    sort(ALL(H));\n    H.resize(unique(ALL(H)) - H.begin());\n\n    FOR(i,0,SZ(H) - 1)\n    {\n        int cnt = 0;\n\n        bool st = false;\n\n        FOR(j,L, R + 1)\n        {\n            if (A[j] > H[i])\n            {\n                st = true;\n            } else\n            {\n                cnt += st;\n                st = false;\n            }\n        }\n        cnt += st;\n        val2 *= bpow(2 , (Int)(H[i + 1] - H[i]) * cnt);\n        val2 %= MOD;\n    }\n\n    cout << val1 << ' ' << val2 << endl;\n\n    return val1 + val2;\n}\n\nInt dp[107];\n\nint main()\n{\n//    freopen(\"in.txt\", \"r\", stdin);\n//    freopen(\"out.txt\" , \"w\", stdout);\n\n    int n;\n    cin >> n;\n    FOR(i,0,n)\n    {\n        cin >> A[i];\n    }\n\n    VI H;\n    FOR(i,0,n)\n    {\n        H.push_back(A[i]);\n    }\n    H.push_back(0);\n    sort(ALL(H));\n    H.resize(unique(ALL(H)) - H.begin());\n\n    vector<pair<PII, int> > C;\n\n    FOR(i,0,SZ(H) - 1)\n    {\n        int cnt = 0;\n\n        bool st = false;\n        int L;\n        FOR(j,0, n)\n        {\n            if (A[j] > H[i])\n            {\n                if (!st) {\n                    st = true;\n                    L = j;\n                }\n            } else\n            {\n                if (st)\n                {\n                    C.push_back(MP(MP(L , j - 1) , H[i + 1] - H[i] - (i == 0)));\n                }\n                st = false;\n            }\n        }\n        if (st)\n        {\n            C.push_back(MP(MP(L , n - 1) , H[i + 1] - H[i] - (i == 0)));\n        }\n    }\n\n//    FOR(i,0,SZ(C))\n//    {\n//        cout << C[i].first.first << ' ' << C[i].first.second << ' ' << C[i].second << endl;\n//    }\n\n    dp[0] = 1;\n\n    FOR(i,0,n)\n    {\n        FOR(j,i,n)\n        {\n            Int v = 0;\n            FOR(k,0,SZ(C))\n            {\n                if (C[k].first.first >= i && C[k].first.second <= j)\n                    v += C[k].second;\n            }\n\n            dp[j + 1] = (dp[j + 1] + (1 + (i == 0)) * bpow(2 , v) * dp[i]) % MOD;\n\n\n        }\n    }\n\n    cout << dp[n] << endl;\n\n\n//    Int res = 1;\n//\n//    int last = 0;\n//\n//    FOR(i,0,n)\n//    {\n//        if (A[i] == 1)\n//        {\n//            res *= 2;\n//            res %= MOD;\n//            res *= solve(last , i - 1);\n//            res %= MOD;\n//            last = i + 1;\n//        }\n//    }\n//    res *= solve(last , n - 1);\n//    res %= MOD;\n//\n//    cout << res << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\nvector<P> child[100][100];\nInt height[100][100];\nInt h[100];\nInt dp[100][100][2];\n\nInt n;\n\n\nInt mod_pow(Int x, Int a, Int m = MOD){\n  if(a == 0)return 1;\n  Int res = mod_pow(x, a / 2, m);\n  res = res * res % m;\n  if(a % 2)res *= x;\n  return res % m;\n}\n\nInt inv(Int x, Int m = MOD){\n  return mod_pow(x, m-2, m);\n}\n\nvoid dfs(int l, int r, int base = 0){\n  height[l][r] = INF;\n  for(int i = l;i <= r;i++){\n    height[l][r] = min(height[l][r], h[i]);\n  }\n  int nl = l;\n  int nc = 0;\n  for(int i = l;i <= r;i++)nc += height[l][r] == h[i];\n  while(true){\n    while(nl <= r && h[nl] <= height[l][r])nl++;\n    if(nl > r)break;\n    Int nr = nl;\n    while(nr+1 <= r && h[nr+1] > height[l][r])nr++;\n    child[l][r].push_back(P(nl, nr));\n    dfs(nl, nr, height[l][r]);\n    nl = nr+1;\n  }\n  \n  height[l][r] -= base;\n  dp[l][r][0] = mod_pow(2, height[l][r]);\n  dp[l][r][1] = mod_pow(2, nc);\n  Int pk = 1;\n  for(auto c:child[l][r]){\n    dp[l][r][0];pk *= dp[c.first][c.second][0];pk %= MOD;\n    dp[l][r][1] *= (dp[c.first][c.second][0]*2 + dp[c.first][c.second][1]) % MOD;dp[l][r][1] %= MOD;\n  }\n  dp[l][r][0] *= pk;dp[l][r][0] %= MOD;\n  dp[l][r][1] -= 2*pk;dp[l][r][1] %= MOD;\n  //  cout << l<< \" \" << r << \" \" <<  dp[l][r][0] << \" \" << dp[l][r][1] << endl;\n}\n\nint main(){\n  cin >> n;\n  for(int i = 0;i < n;i++){\n    cin >> h[i];\n  }\n\n  dfs(0, n-1);\n  Int res = dp[0][n-1][0] + dp[0][n-1][1];res %= MOD;\n  if(res < 0)res += MOD;\n  cout << res << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int N=103,M=1e9+7;\nusing namespace std;\nint n,m,a[N],b[N],f[N][N],i,j,tp;\ninline int ksm(int t){\n\tif(t<0)return 1;\n\tint y=1;long long x=2;\n\tfor(;t;t>>=1)\n\tt&1?y=y*x%M:0,x=x*x%M;\n\treturn y;\n}\ninline void trans(int d){\n\td=min(d,a[i+1]);\n\tf[i+1][d]=(f[i+1][d]+\n\t1ll*ksm(b[a[i]]-b[max(j,a[i+1])])*tp)%M;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;i++)\n\tscanf(\"%d\",a+i),b[i]=--a[i];\n\tsort(b,b+n+1),m=unique(b,b+n+1)-b;\n\tfor(i=0;i<n;i++)\n\ta[i]=lower_bound(b,b+m,a[i])-b;\n\tf[0][0]=1;\n\tfor(i=0;i<n;i++)\n\tfor(j=0;j<=a[i];j++)\n\tif(tp=f[i][j])\n\ttrans(j),trans(a[i]);\n\tprintf(\"%d\",f[n][0]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nint N;\nint H[105];\nll mo=1000000007;\n\nll modpow(ll a, ll n = mo-2) {\n\tll r=1;a%=mo;\n\twhile(n) r=r*((n%2)?a:1)%mo,a=a*a%mo,n>>=1;\n\treturn r;\n}\n\npair<ll,ll> hoge(int L,int R,int v) {\n\tll dp1=1,dp2=1;\n\tint i;\n\t\n\tif(L>R) return {0, 0};\n\t\n\tint mi=1<<30;\n\tfor(i=L;i<=R;i++) mi=min(mi,H[i]);\n\tint W=R-L+1;\n\tfor(i=L;i<=R;i++) if(mi!=H[i]) W--;\n\t\n\tint pre=L-1;\n\tfor(i=L;i<=R;i++) {\n\t\tif(mi==H[i]) {\n\t\t\tauto r=hoge(pre+1,i-1,mi);\n\t\t\tif(r.first>=0) {\n\t\t\t\t(dp1*=r.first)%=mo;\n\t\t\t\t(dp2*=r.first+r.second)%=mo;\n\t\t\t}\n\t\t\t\n\t\t\tpre=i;\n\t\t}\n\t}\n\tauto r=hoge(pre+1,R,mi);\n\tif(r.first > 0) {\n\t\t(dp1*=r.first)%=mo;\n\t\t(dp2*=r.first+r.second)%=mo;\n\t}\n\t\n\t(dp2=dp2*modpow(2,W)+(modpow(2,mi-v)+mo-2)*dp1)%=mo;\n\t(dp1*=modpow(2,mi-v))%=mo;\n\t\n\treturn {dp1,dp2};\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tfor(i=1;i<=N;i++) cin>>H[i];\n\tcout<<hoge(1,N,0).second<<endl;\n}\n\nint main()\n{\n        solve();\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author majk\n */\n\n#ifndef MAJK_LIB\n#define MAJK_LIB\n\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <fstream>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <algorithm>\n#include <numeric>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <array>\n#include <bitset>\nusing namespace std;\n\n#define x first\n#define y second\ntypedef std::pair<int,int> pii; typedef long long ll; typedef unsigned long long ull; typedef unsigned int ui; typedef pair<ui,ui> puu;\n\ntemplate <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate <typename T, typename U> std::ostream&operator<<(std::ostream&o, const pair<T,U>&p) {o << p.x << ' ' << p.y; return o;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {if(t.empty())o<<'\\n';for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\nui logceil(ll x) { return x?8*sizeof(ll)-__builtin_clzll(x):0; }\n\nnamespace std { template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}}; }\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename F> double bshd(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){l=m;}else{h=m;}}return (l+h)/2;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename F> double bsld(double l,double h,const F&f){ui r=200;while(r--){double m=(l+h)/2;if(f(m)){h=m;}else{l=m;}}return (l+h)/2;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector2<T>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector2<T>>(a,vector2<T>(b,c,t)){}};\ntemplate<typename T>class vector4:public vector<vector3<T>>{public:vector4(){} vector4(size_t a,size_t b,size_t c,size_t d,T t=T()):vector<vector3<T>>(a,vector3<T>(b,c,d,t)){}};\ntemplate<typename T>class vector5:public vector<vector4<T>>{public:vector5(){} vector5(size_t a,size_t b,size_t c,size_t d,size_t e,T t=T()):vector<vector4<T>>(a,vector4<T>(b,c,d,e,t)){}};\n\n\n#endif\n#ifndef MOD_H\n#define MOD_H\n\n\n\ntemplate <unsigned int N> class Field {\n    typedef unsigned int ui;\n    typedef unsigned long long ull;\n\tinline ui pow(ui a, ui p){ui r=1,e=a;while(p){if(p&1){r=((ull)r*e)%N;}e=((ull)e*e)%N;p>>=1;}return r;}\n\t/*extended GCD(slow):ll t=0,nt=1,r=N,nr=a;while(nr){ll q=r/nr;t-=q*nt;swap(t,nt);r-=q*nr;swap(r,nr);}assert(r<=1);return(t<0)?t+N:t;*/\n\tinline ui inv(ui a){return pow(a,N-2);}\npublic:\n    inline Field(int x = 0) : v(x<0?N+x:x) {}\n\tinline Field<N> pow(int p){return (*this)^p; }\n\tinline Field<N> operator^(int p){return {(int)pow(v,(ui)p)};}\n    inline Field<N>&operator+=(const Field<N>&o) {if (v+o.v >= N) v += o.v - N; else v += o.v; return *this; }\n    inline Field<N>&operator-=(const Field<N>&o) {if (v<o.v) v -= o.v-N; else v-=o.v; return *this; }\n    inline Field<N>&operator*=(const Field<N>&o) {v=(ull)v*o.v % N; return *this; }\n    inline Field<N>&operator/=(const Field<N>&o) { return *this*=inv(o.v); }\n    inline Field<N> operator+(const Field<N>&o) const {Field<N>r{*this};return r+=o;}\n    inline Field<N> operator-(const Field<N>&o) const {Field<N>r{*this};return r-=o;}\n    inline Field<N> operator*(const Field<N>&o) const {Field<N>r{*this};return r*=o;}\n    inline Field<N> operator/(const Field<N>&o) const {Field<N>r{*this};return r/=o;}\n    inline Field<N> operator-() {if(v) return {(int)(N-v)}; else return {0};};\n    inline Field<N>& operator++() { ++v; if (v==N) v=0; return *this; }\n    inline Field<N> operator++(int) { Field<N>r{*this}; ++*this; return r; }\n    inline Field<N>& operator--() { --v; if (v==-1) v=N-1; return *this; }\n    inline Field<N> operator--(int) { Field<N>r{*this}; --*this; return r; }\n    inline bool operator==(const Field<N>&o) const { return o.v==v; }\n\tinline bool operator!=(const Field<N>&o) const { return o.v!=v; }\n\tinline explicit operator ui() const { return v; }\n\tinline static vector<Field<N>>fact(int t){vector<Field<N>>F(t+1,1);for(int i=2;i<=t;++i){F[i]=F[i-1]*i;}return F;}\n\tinline static vector<Field<N>>invfact(int t){vector<Field<N>>F(t+1,1);Field<N> X{1};for(int i=2;i<=t;++i){X=X*i;}F[t]=1/X;for(int i=t-1;i>=2;--i){F[i]=F[i+1]*(i+1);}return F;}\nprivate: ui v;\n};\ntemplate<unsigned int N>istream &operator>>(std::istream&is,Field<N>&f){unsigned int v;is>>v;f=v;return is;}\ntemplate<unsigned int N>ostream &operator<<(std::ostream&os,const Field<N>&f){return os<<(unsigned int)f;}\ntemplate<unsigned int N>Field<N> operator+(int i,const Field<N>&f){return Field<N>(i)+f;}\ntemplate<unsigned int N>Field<N> operator-(int i,const Field<N>&f){return Field<N>(i)-f;}\ntemplate<unsigned int N>Field<N> operator*(int i,const Field<N>&f){return Field<N>(i)*f;}\ntemplate<unsigned int N>Field<N> operator/(int i,const Field<N>&f){return Field<N>(i)/f;}\n\n\ntypedef Field<1000000007> FieldMod;\n\nstruct Ring {\n\ttemplate <typename T>\n\tstatic T div(T p, T q, T N) {\n\t\tT t=0,nt=1,r=N,nr=q;\n\t\twhile(nr!=0){ T q=r/nr;t-=q*nt;r-=q*nr;swap(t,nt);swap(r,nr); }\n\t\tt=(t<0)?t+N:t;\n\t\tr=(r<0)?r+N:r;\n\t\tif (gcd(p,N)%r!=0) { return 0; }\n\t\treturn (t*p/r)%N;\n\t}\n};\n#endif\n\n\nclass DHistogramColoring {\npublic:\n    FieldMod solve(vector<int> A) {\n        int N = A.size();\n        if (N == 1) return FieldMod{2}.pow(A[0]);\n        vector<FieldMod> D(N+1, 0);\n        D[0] = 1;\n        for (int i = 0; i <= N; ++i) {\n            for (int j = i+1; j <= N; ++j) {\n                ll choices = 0;\n                int lo = A[i];\n                for (int k = i; k < j; ++k) {\n                    choices += max(0, A[k] - (k==i?0:A[k-1]));\n                    lo = min(lo, A[k]);\n                }\n\n                if (i != 0 && j != N) {\n                    choices -= min(A[i-1], A[i]);\n                    choices -= min(A[j-1], A[j]);\n                    choices += min(lo, min(A[i-1],A[j]));\n                } else if (i == 0 && j != N) {\n                    choices -= min(A[j-1], A[j]);\n                    choices++;\n                } else if (i == 0 && j == N) {\n                    // ok\n                } else {\n                    choices -= min(A[i-1], A[i]);\n                }\n\n                D[j] += D[i] * FieldMod{2}.pow(choices % 1000000006);\n            }\n        }\n        return D[N];\n    }\n\n    void solve(istream& cin, ostream& cout) {\n        int N; cin >> N;\n        vector<int> A(N); cin >> A;\n        if (N == 1) {\n            cout << FieldMod{2}.pow(A[0]) << endl;\n            return;\n        }\n\n//        for (int i = 0; i < N; ++i) {\n//            if (A[i] == 1) {\n//                A[i] = 0;\n//                mul *= 2;\n//            }\n//        }\n\n        vector<int> B;\n        FieldMod ans = 1;\n        for (int i = 0; i < N; ++i) {\n            if (A[i] == 0) {\n                if (!B.empty()) {\n                    ans *= solve(B);\n                    B.clear();\n                }\n            } else {\n                B.push_back(A[i]);\n            }\n        }\n\n        if (!B.empty()) ans *= solve(B);\n        cout << ans * 1 << '\\n';\n    }\n};\n\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tDHistogramColoring solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <vector>\n#include <cassert>\n#include <fstream>\n#include <algorithm>\n#include <list>\n#include <random>\n#include <ctime>\n#include <cmath>\n#include <random>\n#include <bitset>\n#include <complex>\n#pragma unroll\n#pragma loop count N\n#pragma ivdep\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n#define int ll\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef pair<ld, ld> pld;\ntypedef complex<double> base;\n\n#define mmin(a, b) a = min(a, (b))\n#define mmax(a, b) a = max(a, (b))\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define ALL(a) a.begin(),a.end()\n#define sqr(x) (x) * (x)\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define cint const int &\n#define SZ(a) ((int)(a.size()))\n#define f(cnt) (((cnt) + 1) * (cnt) / 2)\n#define watch(x) cout << (#x) << \" = \" << x << endl;\n\nconst double PI = 2 * acos(0.0);\n\ntemplate<class T>\nvoid show(const set<T> &a) {\n    for (T x : a)\n        cout << x << \" \";\n    cout << endl;\n}\n\ntemplate<class T>\nvoid show(const vector<T> &a) {\n    for (T x : a)\n        cout << x << \" \";\n    cout << endl;\n}\n\nconst ll M = 1e9 + 7;\n\nll MOD(ll a) {\n    if (a >= 0) return a >= M ? a % M : a;\n    if (a <= -M) a %= M;\n    return a ? a + M : a;\n}\n\nconst int N = 109;\nconst int L = 1e6 + 7;\n\nstruct edge {\n    int u, v;\n    ll height;\n    edge(int u, int v, ll height): u(u), v(v), height(height) {\n\n    }\n\n};\nvector<edge> e;\n\nll pw(ll a, ll p) {\n    if (p < 0LL) return pw(pw(a, -p), M - 2);\n    if (!p) return 1;\n    ll ret = pw(a, p >> 1LL);\n    ret = MOD(ret * ret);\n    if (p & 1LL) ret = MOD(ret * a);\n    return ret;\n}\n\nint counter = 1;\nvi g[L];\nll len[L];\nint vert[L];\nint start[L];\nll h[N];\nll dp[2][L];\n\ninline ll get_ways(int v) {\n    vvvl dp(N, vvl(2, vl(2, 0)));\n    vector<char> must(N, 0);\n    for (int id : g[v]) {\n        int to = e[id].v;\n        for (int i = 1; i < len[to]; ++i)\n            must[i + start[to]] = 1;\n    }\n    dp[start[v]][0][0] = dp[start[v]][0][1] = 1;\n    for (int i = 1; i < len[v]; ++i) {\n        int ind = i + start[v];\n        if (must[ind]) {\n            for (int z1 : {0, 1}) for (int z2 : {0, 1})\n                dp[ind][z1][z2] = dp[ind - 1][z1][!z2];\n        } else {\n            for (int z1 : {0, 1}) for (int z2 : {0, 1}) for (int z3 : {0, 1}) {\n                int nx = z1;\n                if (z2 != z3) nx = 1;\n                dp[ind][nx][z3] = MOD(dp[ind][nx][z3] + dp[ind - 1][z1][z2]);\n            }\n        }\n    }\n    ll ret = MOD(dp[start[v] + len[v] - 1][1][0] + dp[start[v] + len[v] - 1][1][1]);\n    return ret;\n}\n\nll dfs(int v) {\n    ll dp0 = 1;\n    ll dp1 = 1;\n    ll dp2 = 0;\n    ll restlen = len[v];\n    for (int id : g[v]) {\n        int to = e[id].v;\n        dfs(to);\n        restlen -= len[to];\n        ll curgood = MOD(pw(2, e[id].height - 1) * dp[0][to]);\n        ll curbad = dp[1][to];\n        dp2 = MOD(dp2 * (curgood * 2 + curbad) + dp1 * curbad);\n        dp1 = MOD(dp1 * curgood * 2);\n        dp0 = MOD(dp0 * curgood);\n    }\n    dp[1][v] = MOD(dp2 * pw(2, restlen) + dp0 * get_ways(v));\n    dp[0][v] = MOD(2 * dp0);\n}\n\nsigned main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n\n    int n;\n    cin >> n;\n    set<ll> hs;\n    fori (i, n) {\n        cin >> h[i];\n        hs.insert(h[i]);\n    }\n    ll prev = 0;\n    len[counter++] = n;\n    fori (i , n)\n        vert[i] = 1;\n    int curv = 0;\n    int par = 0;\n    for (auto hi : hs) {\n        int cnt = 0;\n        fori (i, n) {\n            if (h[i] >= hi) {\n                if (!cnt) {\n                    curv = counter++;\n                    start[curv] = i;\n                    par = vert[i];\n                }\n                vert[i] = curv;\n                cnt++;\n            } else {\n                if (cnt >= 2) {\n                    len[curv] = cnt;\n                    g[par].pb(SZ(e));\n                    e.pb(edge(par, curv, hi - prev));\n                }\n                cnt = 0;\n            }\n        }\n        if (cnt >= 2) {\n            len[curv] = cnt;\n            g[par].pb(SZ(e));\n            e.pb(edge(par, curv, hi - prev));\n        }\n        prev = hi;\n    }\n    ll fre = 0;\n    fori (i, n) {\n        ll neib = 0;\n        if (i) mmax(neib, h[i - 1]);\n        if (i != n - 1) mmax(neib, h[i + 1]);\n        fre += max(0LL, h[i] - neib);\n    }\n    dfs(2);\n    ll ans = MOD(dp[0][2] * pw(2, e[g[1][0]].height - 1) + dp[1][2]);\n    ans = MOD(ans * pw(2, fre));\n    cout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define mod 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define MOD 1000000007\n    \nlong long mod_pow(long long a,long long b)\n{\n    a %= MOD;\n    long long res = 1;\n    while(b){\n        if(b & 1){\n            res = res * a % MOD;\n        }\n        a = a * a % MOD;\n        b >>= 1;\n    }\n    return res;\n}\n    \nll dp[110][110];\n\nint main(){\n    int n;\n    cin >> n;\n    vector<int> a(n+1);\n    a[0] = 0;\n    rep(i,n) cin >> a[i+1];\n    n++;\n    vector<int> b = a;\n    b.push_back(1);\n    sort(b.begin(),b.end());\n    b.erase(unique(b.begin(),b.end()),b.end());\n    int m = b.size();\n    map<ll,int>mp;        \n    rep(i,b.size()){\n        mp[b[i]] = i;\n    }\n    \n    dp[0][0] = 1;\n    for(int i=1;i<n;i++){\n        int K = mp[a[i]];\n        if(a[i]<=a[i-1]){\n            for(int j=K+1;j<m;j++){\n                dp[i-1][0] += dp[i-1][j];\n                dp[i-1][0] %= mod;\n            }\n            dp[i][0] = dp[i-1][0]*2%mod;\n            for(int j=1;j<=K;j++){\n                dp[i][j] = dp[i-1][j];\n            }\n        }else{\n            int L = mp[a[i-1]];\n            dp[i][0] = dp[i-1][0]*2%mod;\n            //cerr <<\"L: \"<<  L << \" K: \" << K << endl;\n            for(int j=1;j<=L;j++){\n                dp[i][j] = dp[i-1][j]*mod_pow(2,a[i]-a[i-1])%mod;    \n            }\n            for(int j=L+1;j<=K;j++){\n                if(a[i-1]==0){\n                    if(b[j]!=1)dp[i][j] = 2*((mod + mod_pow(2,a[i]-b[j-1]) - mod_pow(2,a[i]-b[j]) )%mod)%mod;\n                }else if(b[j]!=1)dp[i][j] = 2*dp[i-1][0]*((mod + mod_pow(2,a[i]-b[j-1]) - mod_pow(2,a[i]-b[j]) )%mod)%mod;        \n                //cerr <<a[i-1] << \" \" << a[i] << \" \" << b[j] << endl;\n                //cerr << dp[i-1][0] << \" \" << (mod + mod_pow(2,a[i]-a[i-1]) -2*mod_pow(2,a[i]-b[j]) )%mod << endl;\n            }\n        }\n        // rep(j,m){\n        //     cerr << dp[i][j] << \" \";\n        // }\n        // cerr << endl;\n    }\n    ll sm = 0;\n    for(int i=0;i<m;i++){\n        sm += dp[n-1][i];\n        sm %= mod;\n    }\n    cout << sm << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\nvector<P> child[101][101];\nInt height[101][101];\nInt h[101];\nInt dp[101][101][2];\n\nInt n;\n\n\nInt mod_pow(Int x, Int a, Int m = MOD){\n  if(a == 0)return 1;\n  Int res = mod_pow(x, a / 2, m);\n  res = res * res % m;\n  if(a % 2)res *= x;\n  return res % m;\n}\n\nInt inv(Int x, Int m = MOD){\n  return mod_pow(x, m-2, m);\n}\n\nvoid dfs(int l, int r, int base = 0){\n  height[l][r] = INF * 2;\n  for(int i = l;i <= r;i++){\n    height[l][r] = min(height[l][r], h[i]);\n  }\n  int nl = l;\n  int nc = 0;\n  for(int i = l;i <= r;i++)nc += height[l][r] == h[i];\n  while(true){\n    while(nl <= r && h[nl] <= height[l][r])nl++;\n    if(nl > r)break;\n    Int nr = nl;\n    while(nr+1 <= r && h[nr+1] > height[l][r])nr++;\n    child[l][r].push_back(P(nl, nr));\n    dfs(nl, nr, height[l][r]);\n    nl = nr+1;\n  }\n  \n  height[l][r] -= base;\n  dp[l][r][0] = mod_pow(2, height[l][r]);\n  dp[l][r][1] = mod_pow(2, nc);\n  Int pk = 1;\n  for(auto c:child[l][r]){\n    pk *= dp[c.first][c.second][0];pk %= MOD;\n    dp[l][r][1] *= (dp[c.first][c.second][0]*2 + dp[c.first][c.second][1]) % MOD;dp[l][r][1] %= MOD;\n  }\n  dp[l][r][0] *= pk;dp[l][r][0] %= MOD;\n  dp[l][r][1] -= 2*pk;dp[l][r][1] %= MOD;\n  //  cout << l<< \" \" << r << \" \" <<  dp[l][r][0] << \" \" << dp[l][r][1] << endl;\n}\n\nint main(){\n  cin >> n;\n  for(int i = 0;i < n;i++){\n    cin >> h[i];\n  }\n\n  dfs(0, n-1);\n  Int res = dp[0][n-1][0] + dp[0][n-1][1];res %= MOD;\n  if(res < 0)res += MOD;\n  cout << res << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nPROG: agc26d\nLANG: C++11\n    _____\n  .'     '.\n /  0   0  \\\n|     ^     |\n|  \\     /  |\n \\  '---'  /\n  '._____.'\n */\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate<class T>\nvoid readi(T &x)\n{\n\tT input = 0;\n\tbool negative = false;\n\tchar c = ' ';\n\twhile (c < '-')\n\t{\n\t\tc = getchar();\n\t}\n\tif (c == '-')\n\t{\n\t\tnegative = true;\n\t\tc = getchar();\n\t}\n\twhile (c >= '0')\n\t{\n\t\tinput = input * 10 + (c - '0');\n\t\tc = getchar();\n\t}\n\tif (negative)\n\t{\n\t\tinput = -input;\n\t}\n\tx = input;\n}\ntemplate<class T>\nvoid printi(T output)\n{\n\tif (output == 0)\n\t{\n\t\tputchar('0');\n\t\treturn;\n\t}\n\tif (output < 0)\n\t{\n\t\tputchar('-');\n\t\toutput = -output;\n\t}\n\tint aout[20];\n\tint ilen = 0;\n\twhile(output)\n\t{\n\t\taout[ilen] = ((output % 10));\n\t\toutput /= 10;\n\t\tilen++;\n\t}\n\tfor (int i = ilen - 1; i >= 0; i--)\n\t{\n\t\tputchar(aout[i] + '0');\n\t}\n\treturn;\n}\ntemplate<class T>\nvoid ckmin(T &a, T b)\n{\n\ta = min(a, b);\n}\ntemplate<class T>\nvoid ckmax(T &a, T b)\n{\n\ta = max(a, b);\n}\nlong long randomize(long long mod)\n{\n\treturn ((1ll << 30) * rand() + (1ll << 15) * rand() + rand()) % mod;\n}\n\n#define MP make_pair\n#define PB push_back\n#define PF push_front\n#define fi first\n#define se second\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\nconst long double PI = 4.0 * atan(1.0);\nconst long double EPS = 1e-10;\n\n#define MAGIC 347\n#define SINF 10007\n#define CO 1000007\n#define INF 1000000007\n#define BIG 1000000931\n#define LARGE 1696969696967ll\n#define GIANT 2564008813937411ll\n#define LLINF 2696969696969696969ll\n#define MAXN 113\n\nlong long normalize(long long x, long long mod = INF)\n{\n\treturn (((x % mod) + mod) % mod);\n}\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nint N;\nint arr[MAXN];\nint up[MAXN][MAXN];\nbool vis[MAXN][MAXN][MAXN][2];\nll dp[MAXN][MAXN][MAXN][2];\nll ans;\n\nll getpow(ll a, ll e)\n{\n\tif (e == 0)\n\t{\n\t\treturn 1;\n\t}\n\tll was = getpow(a, e / 2);\n\tif (e % 2)\n\t{\n\t\treturn (was * was % INF * a % INF);\n\t}\n\telse\n\t{\n\t\treturn (was * was % INF);\n\t}\n}\nll solve(int L, int R, int idx, bool flag)\n{\n\t//dp[L][R] given that we're at height arr[idx]\n\tif (L < 0 || R < 0 || L > R)\n\t{\n\t\treturn 1;\n\t}\n\tif (vis[L][R][idx][flag])\n\t{\n\t\treturn dp[L][R][idx][flag];\n\t}\n\tvis[L][R][idx][flag] = true;\n\tll res = 0;\n\t//0 means you don't care, 1 means you insist that it's sideways\n\tint d = arr[up[L][R]] - arr[idx];\n\t//either ok\n\tif (flag)\n\t{\n\t\tres += solve(L, up[L][R] - 1, up[L][R], 1) * solve(up[L][R] + 1, R, up[L][R], 1) % INF * getpow(2, d) % INF;\n\t}\n\telse\n\t{\n\t\tres += solve(L, up[L][R] - 1, up[L][R], 1) * solve(up[L][R] + 1, R, up[L][R], 1) % INF * (getpow(2, d + 1) - 2) % INF;\n\t\tres += solve(L, up[L][R] - 1, up[L][R], 0) * solve(up[L][R] + 1, R, up[L][R], 0) * 2 % INF;\n\t}\n\tres %= INF;\n\tdp[L][R][idx][flag] = res;\n//\tcerr << \"solve \" << L << \" \" << R << \" height \" << arr[idx] << \" flag \" << flag << \" ans \"<< res << endl;\n\treturn res;\n}\n\nint32_t main()\n{\n\tios_base::sync_with_stdio(0); \n\tsrand(time(0));\n\t//\tcout << fixed << setprecision(10);\t\n\t//\tcerr << fixed << setprecision(10);\n\tif (fopen(\"agc26d.in\", \"r\"))\n\t{\t\n\t\tfreopen (\"agc26d.in\", \"r\", stdin);\n\t\t//\tfreopen (\"agc26d.out\", \"w\", stdout);\n\t}\n\tcin >> N;\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tcin >> arr[i];\n\t}\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tint mn = INF, idx = -1;\n\t\tfor (int j = i; j < N; j++)\n\t\t{\n\t\t\tif (arr[j] < mn)\n\t\t\t{\n\t\t\t\tmn = arr[j]; idx = j;\n\t\t\t}\n\t\t\tup[i][j] = idx;\n\t\t\t//\t\t\tcerr << up[i][j] << ' ';\n\t\t}\n\t\t//\t\tcerr << endl;\n\t}\n\tarr[N] = 1;\n\tans = solve(0, N - 1, N, 0);\n\tcout << ans << '\\n';\n\t//\tcerr << \"time elapsed = \" << (clock() / (CLOCKS_PER_SEC / 1000)) << \" ms\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MOD 1000000007\n#define TWO 500000004\n\nint n, x[105], par[105], ta, tc;\nset<int> m;\nset<int>::iterator it;\nlong long ya[105], yb[105], tb;\n\nint find(int a) {\n\treturn par[a] == a ? a : par[a] = find(par[a]);\n}\n\nlong long po(long long b, int p) {\n\tlong long re = 1;\n\twhile (p) {\n\t\tif (p & 1)\n\t\t\tre = re * b % MOD;\n\t\tb = b * b % MOD;\n\t\tp >>= 1;\n\t}\n\treturn re;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", x + i);\n\t\tm.insert(x[i]);\n\t}\n\tm.insert(1);\n\tit = m.end();\n\twhile (it != m.begin()) {\n\t\tit--;\n\t\tta = *it;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tif (par[i]) {\n\t\t\t\tif (par[i] == i) {\n\t\t\t\t\tyb[i] = yb[i] * po(2, x[i] - ta) % MOD;\n\t\t\t\t\tx[i] = ta;\n\t\t\t\t\tif (par[i - 1]) {\n\t\t\t\t\t\ttc = find(i - 1);\n\t\t\t\t\t\ttb = yb[tc] * yb[i] % MOD * TWO % MOD;\n\t\t\t\t\t\tya[tc] = ((ya[tc] + yb[tc]) * (ya[i] + yb[i]) % MOD + MOD - tb) % MOD;\n\t\t\t\t\t\tyb[tc] = tb;\n\t\t\t\t\t\tpar[i] = tc;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (x[i] == ta) {\n\t\t\t\tif (par[i - 1]) {\n\t\t\t\t\ttc = find(i - 1);\n\t\t\t\t\tya[tc] = (ya[tc] * 2 + yb[tc]) % MOD;\n\t\t\t\t\tpar[i] = tc;\n\t\t\t\t} else {\n\t\t\t\t\tpar[i] = i;\n\t\t\t\t\tyb[i] = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t// printf(\"[%d]\\n\", ta);\n\t\t// for (int i = 1; i <= n; i++) if (par[i] == i) printf(\"%d  %lld %lld\\n\", i, ya[i], yb[i]);\n\t}\n\tprintf(\"%lld\\n\", (ya[1] + yb[1]) % MOD);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\ntemplate<unsigned MOD> struct ModInt {\n    static const unsigned static_MOD = MOD;\n    unsigned x;\n    void undef() { x = (unsigned)-1; }\n    bool isnan() const { return x == (unsigned)-1; }\n    inline int geti() const { return (int)x; }\n    ModInt() { x = 0; }\n    ModInt(const ModInt &y) { x = y.x; }\n    ModInt(int y) { if (y<0 || (int)MOD<=y) y %= (int)MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt(long long y) { if (y<0 || MOD<=y) y %= MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned long long y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt &operator+=(const ModInt y) { if ((x += y.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(const ModInt y) { if ((x -= y.x) & (1u<<31)) x += MOD; return *this; }\n    ModInt &operator*=(const ModInt y) { x = (unsigned long long)x * y.x % MOD; return *this; }\n    ModInt &operator/=(const ModInt y) { x = (unsigned long long)x * y.inv().x % MOD; return *this; }\n    ModInt operator-() const { return (x ? MOD-x: 0); }\n\n    ModInt inv() const {\n\tunsigned a = MOD, b = x; int u = 0, v = 1;\n\twhile (b) {\n\t    int t = a / b;\n\t    a -= t * b; swap(a, b);\n\t    u -= t * v; swap(u, v);\n\t}\n\tif (u < 0) u += MOD;\n\treturn ModInt(u);\n    }\n    ModInt pow(long long y) const {\n\tModInt b = *this, r = 1;\n\tif (y < 0) { b = b.inv(); y = -y; }\n\tfor (; y; y>>=1) {\n\t    if (y&1) r *= b;\n\t    b *= b;\n\t}\n\treturn r;\n    }\n    friend ModInt operator+(ModInt x, const ModInt y) { return x += y; }\n    friend ModInt operator-(ModInt x, const ModInt y) { return x -= y; }\n    friend ModInt operator*(ModInt x, const ModInt y) { return x *= y; }\n    friend ModInt operator/(ModInt x, const ModInt y) { return x *= y.inv(); }\n    friend bool operator<(const ModInt x, const ModInt y) { return x.x < y.x; }\n    friend bool operator==(const ModInt x, const ModInt y) { return x.x == y.x; }\n    friend bool operator!=(const ModInt x, const ModInt y) { return x.x != y.x; }\n};\n\nconst LL MOD = 1000000007;\ntypedef ModInt<MOD> Mint;\n\nint N;\nint H[111];\n\npair<Mint, Mint> rec(int L, int R, int LV) {\n//    if (L+1 == R) {\n//\treturn make_pair(Mint(2).pow(H[L]-LV), 0);\n//    }\n\n    int B = *min_element(H+L, H+R);\n    if (B == *max_element(H+L, H+R)) {\n\tMint a = Mint(2).pow(H[L]-LV);\n\tMint b = Mint(2).pow(R-L)-2;\n\treturn make_pair(a, a+b);\n    }\n\n\n    Mint F = 1, S = 1;\n    for (int i=L; i<R; ) {\n\tint j = i;\n\twhile (j < R && H[j] > B) j++;\n\n\tif (i < j) {\n\t    pair<Mint, Mint> g = rec(i, j, B);\n\t    F *= g.first;\n\t    S *= g.first + g.second;\n\t    i = j;\n\t} else {\n\t    S *= 2;\n\t    i++;\n\t}\n    }\n\n    Mint p = Mint(2).pow(B-LV);\n    pair<Mint, Mint> ret = make_pair(\n\t    F * p,\n\t    S + F * (p-2));\n\n    return ret;\n}\n\nvoid MAIN() {\n    scanf(\"%d\", &N);\n    REP (i, N) scanf(\"%d\", H+i);\n\n    pair<Mint, Mint> ans = rec(0, N, 0);\n    printf(\"%d\\n\", ans.second.geti());\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define int long long\nusing namespace std;\ntypedef pair<int, int> P;\nconst int INF = 1e15;\nconst int mod = 1e9 + 7;\n\nint n;\nint h[105];\n\nlong long mod_pow(long long x, long long n){\n    if(n == 0) return 1;\n    long long res = mod_pow(x*x % mod, n / 2);\n    if(n & 1) res = res*x % mod;\n    return res;\n}\n\nP calc(int L, int R, int v){\n    int dp1 = 1, dp2 = 1;\n    if(L > R) return {-1, -1};\n    int MIN = INF;\n    rep(i, L, R + 1) MIN = min(MIN, h[i]);\n    int w = R - L + 1;\n    rep(i, L, R + 1) if(MIN != h[i]) w--;\n    int pre = L - 1;\n    rep(i, L, R + 1){\n        if(MIN == h[i]){\n            P p = calc(pre + 1, i - 1, MIN);\n            if(p.first >= 0){\n                (dp1 *= p.first) %= mod;\n                (dp2 *= p.first + p.second) %= mod;\n            }\n            pre = i;\n        }\n    }\n    P p = calc(pre + 1, R, MIN);\n    if(p.first >= 0){\n        (dp1 *= p.first) %= mod;\n        (dp2 *= p.first + p.second) %= mod;\n    }\n    (dp2 = dp2 * mod_pow(2, w) + (mod_pow(2, MIN - v) + mod - 2) * dp1) %= mod;\n    (dp1 *= mod_pow(2, MIN - v)) %= mod;\n    return {dp1, dp2};\n}\n\nsigned main(){\n    cin >> n;\n    rep(i, 1, n + 1) cin >> h[i];\n    cout << calc(1, n, 0).second << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#define Starseven main\n#define ll long long\nnamespace lyt {\n\tvoid read(int &x){\n\tchar ch=getchar();int re=0,op=1;\n\twhile(ch<'0'||ch>'9'){if(ch=='-') op=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){re=(re<<3)+(re<<1)+ch-'0';ch=getchar();}\n\tx = re * op;\n\treturn ;\n\t}\n\tvoid read(long long &x){\n\tchar ch=getchar();long long re=0,op=1;\n\twhile(ch<'0'||ch>'9'){if(ch=='-') op=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){re=(re<<3ll)+(re<<1ll)+ch-'0';ch=getchar();}\n\tx = re * op;\n\treturn ;\n\t}\n\tvoid write(int x){\n\t\tif(x<0){putchar('-');x=-x;}\n\t\tif(x>9) write(x/10);\n\t\tputchar(x%10+'0');\n\t\treturn ;\n\t}//¼ÇµÃ×Ô¼º¼Ó¿Õ¸ñºÍ»»ÐÐ \n\tvoid write(long long x){\n\t\tif(x<0){putchar('-');x=-x;}\n\t\tif(x>9) write(x/10);\n\t\tputchar(x%10+'0');\n\t\treturn ;\n\t}//¼ÇµÃ×Ô¼º¼Ó¿Õ¸ñºÍ»»ÐÐ\n\tint max(int x,int y){return x<y?y:x;}\n\tint min(int x,int y){return x<y?x:y;}\n\tint abs(int x){return x<0?-x:x;}\n\tlong long max(long long x,long long y){return x<y?y:x;}\n\tlong long min(long long x,long long y){return x<y?x:y;}\n\tlong long abs(long long x){return x<0?-x:x;}\n\tdouble max(double x,double y){return x<y?y:x;}\n\tdouble min(double x,double y){return x<y?x:y;}\n\tdouble abs(double x){return x<0?-x:x;}\n\tvoid swap(int &a,int &b) {a ^= b ^= a ^= b;}\n\tvoid swap(long long &a,long long &b) {a ^= b ^= a ^= b;}\n\tll Power(ll a, ll b, ll p) {\n\t\tll re = 1;\n\t\twhile(b) {\n\t\t\tif(b & 1ll) re = (re * a) % p;\n\t\t\tb >>= 1ll;\n\t\t\ta = (a * a) % p; \n\t\t}\n\t\treturn re;\n\t}\n\tint Power(int a, int b, int p) {\n\t\tint re = 1;\n\t\twhile(b) {\n\t\t\tif(b & 1) re = 1ll * re * a % p;\n\t\t\tb >>= 1;\n\t\t\ta = 1ll * a * a % p; \n\t\t}\n\t\treturn re;\n\t}\n}using namespace lyt;\nconst int mod = 1e9 + 7;\nconst int N = 1e2 + 20;\nint va[N], minn[N][N];\n\nstruct xyx {\n\tint res1, res2;\n};\n\nxyx Dfs(int l, int r, int pre_dep) {\n\tint judge = minn[l][r], num = 0;\n\txyx re;\n\tstd::vector<int> v;\n\tv.push_back(l - 1);\n\tfor (int i = l; i <= r; i++) {\n\t\tif(va[i] == judge) {\n\t\t\tv.push_back(i);\n\t\t\tnum++;\n\t\t}\n\t}\n\tv.push_back(r + 1);\n\tre.res1 = re.res2 = 1;\n\tfor (int i = 0; i < num + 1; i++) {\n\t\tif(v[i] + 1 >= v[i + 1]) continue;\n\t\txyx hack = Dfs(v[i] + 1, v[i + 1] - 1, judge);\n\t\tre.res1 = 1ll * re.res1 * hack.res1 % mod;\n\t\tre.res2 = 1ll * re.res2 * 1ll * ( (hack.res2 + 1ll * hack.res1 * 2 % mod) % mod) % mod;\n\t}\n\txyx ans;\n\tans.res1 = 1ll * Power(2, judge - pre_dep, mod) * re.res1 % mod;\n\tans.res2 = (1ll * Power(2, num, mod) * re.res2 % mod + ( (mod - 2ll * re.res1) % mod + mod) % mod) % mod;\n\treturn ans;\n}\n\nint Starseven(void) {\n\tint n;\n\tread(n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tread(va[i]);\n\t}\n\tif(n == 1) {\n\t\tint ans = Power(2, va[1], mod);\n\t\twrite(ans);\n\t\tputs(\"\");\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tminn[i][i] = va[i];\n\t\tfor (int j = i + 1; j <= n; j++) {\n\t\t\tminn[i][j] = min(minn[i][j - 1], va[j]);\n\t\t}\n\t}\n\txyx ans = Dfs(1, n, 0);\n\tans.res1 = 1ll * (ans.res1 + ans.res2) % mod;\n\twrite(ans.res1);\n\tputs(\"\");\n\treturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define pb push_back\n#define eb emplace_back\n#define all(x) x.begin(), x.end()\n#define debug(x) cerr << #x <<\": \" << (x) << endl\n//Ã¥ï¿½Â¨Ã¦Â¯ï¿½Ã¤Â¸ÂªÃ¥ï¿½Â½Ã¦ï¿½Â°Ã§ï¿½ï¿½Ã¥ï¿½Â¥Ã¥ï¿½Â£Ã¥Â¤ï¿½Ã¦ï¿½Â§Ã¨Â¡ï¿½Ã¤Â¸ï¿½Ã¦Â¬Â¡Ã¯Â¼ï¿½Ã¥ï¿½ÂºÃ¥ï¿½Â£Ã¥Â¤ï¿½Ã¦ï¿½Â§Ã¨Â¡ï¿½Ã¤Â¸ï¿½Ã¦Â¬Â¡Ã£ï¿½ï¿½Ã§ï¿½Â¶Ã¥ï¿½ï¿½Ã¥Â°Â±Ã¥ï¿½Â¯Ã¤Â»Â¥Ã¥Â¿Â«Ã©ï¿½ï¿½Ã¥Â¾ï¿½Ã§ï¿½Â¥Ã¦ï¿½Â¯Ã¥ï¿½ÂªÃ¤Â¸ÂªÃ¥ï¿½Â°Ã¦ï¿½Â¹Ã¦Â®ÂµÃ©ï¿½ï¿½Ã¨Â¯Â¯Ã¤Âºï¿½\n#define DEBUG printf(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#ifdef LOCAL\n#define see(x) cout  << #x << \": \" << (x) << endl\n#endif\n#ifndef LOCAL\n#define see(x)\n#endif\n\n\n#define rep(n) for(int _ = 0; _ != (n); ++_)\n//#define rep(i, a, b) for(int i = (a); i <= (b); ++i)\n#define Rng(i, n) for(int i = 0; i != (n); ++i)\n#define rng(i, a, b) for(int i = (a); i < (b); ++i)\n#define RNG(i, a) for(auto &i: (a))\n#define dwn(i, r, l) for(int i = (r); i>=(l); i--)\n\nnamespace std {\n    template<class T>\n    T begin(std::pair<T, T> p)\n    {\n        return p.first;\n    }\n    template<class T>\n    T end(std::pair<T, T> p)\n    {\n        return p.second;\n    }\n}\n\n\n#if __cplusplus < 201402L\ntemplate<class Iterator>\n    std::reverse_iterator<Iterator> make_reverse_iterator(Iterator it)\n    {\n        return std::reverse_iterator<Iterator>(it);\n    }\n#endif\n\ntemplate<class Range>\nstd::pair<std::reverse_iterator<decltype(begin(std::declval<Range>()))>, std::reverse_iterator<decltype(begin(std::declval<Range>()))>> make_reverse_range(Range &&r)\n{\n    return std::make_pair(make_reverse_iterator(::begin(r)), make_reverse_iterator(::end(r)));\n}\n\n#define RRNG(x, cont) for (auto &x: make_reverse_range(cont))\n\n\n\ntemplate<class T> int sign(const T &a) { return a == 0 ? 0 : a > 0 ? 1 : -1; }\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> void Min(T &a, const T &b){ a = min(a, b); }\ntemplate<class T> void Max(T &a, const T &b){ a = max(a, b); }\n\ntemplate<typename T> void println(const T &t) { cout << t << '\\n'; }\ntemplate<typename T, typename ...Args> void println(const T &t, const Args &...rest) { cout << t << ' '; println(rest...); }\n\ntemplate<typename T> void print(const T &t) { cout << t << ' '; }\n\ntemplate<typename T, typename ...Args> void print(const T &t, const Args &...rest) { cout << t; print(rest...); }\n\n// this overload is chosen when there's only one argument\ntemplate<class T> void scan(T &t) { cin >> t; }\ntemplate<class T, class ...Args> void scan(T &a, Args &...rest) { cin >> a; scan(rest...); }\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing vec = vector<ll>;\nusing mat = vector<vec>;\nusing pii = pair<int, int>;\nusing pdd = pair<double, double>;\nusing pip = pair<int, pii>;\nusing szt = size_t;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vb = vector<bool>;\nusing vpii = vector<pii>;\nusing vvi = vector<vi>;\nusing pli = pair<ll,int>;\nusing wg = vector<vpii>; //weighted graph\n\nint cas;\nconst double pi = acos(-1);\nll mod = 1e9 + 7;\n\ntemplate<class T>\ninline void add_mod(T &a, const T &b) {\n    a += b;\n    if (a >= mod) a -= mod;\n}\ntemplate<class T>\nvoid sub_mod(T &a, const T &b){\n    a -= b;\n    if (a < 0) a += mod;\n}\nauto bo=[](int x){ //Ã¤Âºï¿½Ã¨Â¿ï¿½Ã¥ï¿½Â¶Ã¨Â¾ï¿½Ã¥ï¿½Âº\n    bitset<5> a(x);\n    cout << a << endl;\n};\n\n\n\nmat operator*(const mat &a, const mat &b) {\n    mat c(a.size(), vec(b[0].size()));\n    for (int i = 0; i < a.size(); i++) {\n        for (int j = 0; j < a[0].size(); j++) {\n            if (a[i][j]) { // optimization for sparse matrix\n                for (int k = 0; k < b[0].size(); k++) {\n                    add_mod(c[i][k], a[i][j] * b[j][k] % mod);\n                }\n            }\n        }\n    }\n    return c;\n}\n\nvec operator*(const mat &a, const vec &b) {\n    vec c(a.size());\n    for (int i = 0; i < a.size(); i++) {\n        for (int j = 0; j < a[0].size(); j++) {\n            add_mod(c[i], a[i][j] * b[j] % mod);\n        }\n    }\n    return c;\n}\n\nmat pow(mat a, ull n) {\n    mat res(a.size(), vec(a[0].size()));\n    for (int i = 0; i < a.size(); i++) {\n        res[i][i] = 1;\n    }\n    while (n) {\n        if (n & 1) {\n            res = res * a;\n        }\n        a = a * a;\n        n >>= 1;\n    }\n    return res;\n}\n\nstd::ostream& operator<<(std::ostream& os, __int128 T) {\n    if (T<0) os<<\"-\";\n    if (T>=10 ) os<<T/10;\n    if (T<=-10) os<<(-(T/10));\n    return os<<( (int) (T%10) >0 ? (int) (T%10) : -(int) (T%10) ) ;\n}\n\n__int128 LPOW(__int128 x, ll n) {\n    __int128 res = 1;\n    for (; n; n /= 2, x *= x, x %= mod) {\n        if (n & 1) {\n            res *= x;\n            res %= mod;\n        }\n    }\n    return res;\n}\n\nll POW(ll x, ll n){\n    ll res = 1;\n    for (; n; n /= 2, x *= x, x %= mod) {\n        if (n & 1) {\n            res *= x;\n            res %= mod;\n        }\n    }\n    return res;\n}\n\n\nll INV(ll x) {\n    return POW(x, mod - 2);\n}\n\nll inv(ll x){\n    //    see(x);\n    return x == 1? 1: (mod - mod/x * inv(mod%x) % mod);\n}\n\n\n\n// 2D rotation\nvoid rotate(double &x, double &y, double theta) {\n    double tx = cos(theta) * x - sin(theta) * y;\n    double ty = sin(theta) * x + cos(theta) * y;\n    x = tx, y = ty;\n}\nnamespace bit {\n    const int BIT_N = 1e5 + 5;\n\n    int bit[BIT_N];\n\n    int sum(int x) {\n        int res = 0;\n        while (x) {\n            res += bit[x];\n            x -= x & -x;\n        }\n        return res;\n    }\n\n    int sum(int l, int r) {\n        if (l > r) return 0;\n        return sum(r) - sum(l - 1);\n    }\n\n    void add(int x, int v, int n) {\n        while (x <= n) {\n            bit[x] += v;\n            x += x & -x;\n        }\n    }\n}\n\nnamespace util{\n    int len(ll x){return snprintf(nullptr, 0, \"%lld\", x);}\n    vi get_d(ll x){\n        vi res;\n        while(x) {\n            res.pb(x%10);\n            x /= 10;\n        }\n        reverse(all(res));\n        return res;\n    }\n    template <class T> T parity(const T &a){\n        return a & 1;\n    }\n    template <class T>\n    void out (const vector<T> &a){\n        std::copy(a.begin(), a.end(), std::ostream_iterator<T>(std::cout, \", \"));\n        cout << endl;\n    };\n    template<class T>\n    void lisan(T &a){\n        sort(all(a));\n        a.erase(unique(all(a)), a.end());\n    }\n}\n\nusing namespace util;\n\n// #include <ext/pb_ds/priority_queue.hpp>\n\n// typedef __gnu_pbds :: priority_queue<pip, less<pip>, __gnu_pbds::thin_heap_tag > Heap;\n\n// Heap h;\n\n// Heap::point_iterator pos[N][N];\nconst ll LINF = LLONG_MAX/10;\nconst int INF = INT_MAX/10;\nconst int M = 3000 + 5;\n\nll dp[105][105];\n\nint main() {\n    // Single Cut of Failure taught me\n    cout << std::fixed; //\n    cout << setprecision(10);\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n#ifdef LOCAL\n    freopen(\"main.in\", \"r\", stdin);\n    //    freopen(\"main.out\", \"w\", stdout);\n#endif\n    int n;\n    scan(n);\n    map<int,int> ls; //离散化\n    vi h(n);\n\n    RNG(x, h){\n        scan(x);\n        ls[x];\n    }\n    int tmp = 0;\n    vi H;\n    RNG(x, ls){\n        x.second = tmp++;\n        H.pb(x.first);\n    }\n\n    vi g(n);\n\n    rng(i, 0, n) g[i] = ls[h[i]];\n\n    auto c=[&](int i){\n        return i == 0 ? H[0] : H[i] - H[i-1];\n    };\n\n    // 不要害怕边界条件！\n    rng(j, 0, g[0]+1){\n        if(j == 0)\n            dp[0][j] = (POW(2, c(j))-2 + mod) % mod * POW(2, h[0] - H[j]) % mod;\n        else\n            dp[0][j] = 2 * (POW(2, c(j)) -1) % mod * POW(2, h[0] - H[j]) % mod;\n    }\n    dp[0][g[0]+1] = 2;\n\n    rng(i, 1, n){\n        rng(j, 0, g[i]+1){\n            if(ls[h[i-1]] >= j){\n                dp[i][j] = dp[i-1][j] * POW(2, max(0, h[i]-h[i-1])) % mod;\n            }\n            else{\n                dp[i][j] = dp[i-1][g[i-1]+1] * 2 % mod * (POW(2, c(j)) -1)  % mod * POW(2, h[i]-H[j]) % mod;\n            }\n        }\n        if(g[i-1] <= g[i]){\n            dp[i][g[i]+1] = 2 * dp[i-1][g[i-1]+1] % mod;\n        }\n        else{\n            ll sum = 0;\n            rng(j, g[i]+1, g[i-1]+2) add_mod(sum, dp[i-1][j]);\n            dp[i][g[i]+1] = 2 * sum % mod;\n        }\n    }\n//\n//    rng(j, 0, g[1]+2){\n//        see(dp[1][j]);\n//    }\n\n    ll ans = 0;\n    rng(i, 0, g[n-1]+2){\n        add_mod(ans, dp[n-1][i]);\n    }\n\n    println(ans);\n\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n\n#define ln                '\\n'\n#define all(dat)           dat.begin(), dat.end()\n#define loop(i, to)        for (int i = 0; i < to; ++i)\n#define cont(i, to)        for (int i = 1; i <= to; ++i)\n#define circ(i, fr, to)    for (int i = fr; i <= to; ++i)\n#define foreach(i, dat)    for (__typeof(dat.begin()) i = dat.begin(); i != dat.end(); ++i)\n\ntypedef long long          num;\n\nusing namespace std;\n\nconst int nsz = 1e2, mod = 1e9 + 7;\nint n, h[nsz + 5], dp[nsz + 5], f[nsz + 5][nsz + 5];\n\nnum inline qpow(num a, int p) {\n    num res = 1;\n    for (; p > 0; p >>= 1) {\n        if (p & 1) {\n            res *= a;\n            res %= mod;\n        }\n        a *= a;\n        a %= mod;\n    }\n    return res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin >> n;\n    cont (i, n) {\n        cin >> h[i];\n    }\n    dp[1] = qpow(2, h[1]);\n    cont (i, n) {\n        f[1][i] = 2 * qpow(2, h[1] - h[i]);\n    }\n    circ (i, 2, n) {\n        dp[i] = (dp[i - 1] + f[i - 1][i]) * qpow(2, h[i] - h[i - 1]) % mod;\n        cont (j, n) {\n            if (h[i] <= h[i - 1]) {\n                f[i][j] = h[i] > h[j] ? f[i - 1][j] : f[i - 1][i];\n            } else {\n                if (h[i] > h[j]) {\n                    f[i][j] = f[i - 1][j] * qpow(2, h[i] - (h[j] > h[i - 1] ? h[j] : h[i - 1])) % mod;\n                } else {\n                    f[i][j] = f[i - 1][j];\n                }\n            }\n            f[i][j] += f[i - 1][i] * qpow(2, h[i] - max(h[i - 1], h[j])) % mod;\n            f[i][j] %= mod;\n        }\n    }\n    cout << dp[n] << ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n\nconst int N = 1e6 + 10;\nconst int mod = 1e9 + 7;\nint h[N], st[N], top, n, ls[N], rs[N], root, f[N][2], num[N], single[N], mulsingle[N], rev[N];\nbool bsin[N];\n\ninline void build()\n{\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tint k = top;\n\t\twhile (k > 0 && h[st[k]] > h[i]) k--;\n\t\tif (k) rs[st[k]] = i;\n\t\tif (k < top) ls[i] = st[k + 1];\n\t\tst[++k] = i;\n\t\ttop = k;\n\t}\n\troot = st[1];\n}\n\nvoid dfs(int x)\n{\n\tif (!x) return;\n\tcout << \"x \" << x << endl;\n\tdfs(ls[x]), dfs(rs[x]);\n}\n\ninline int fp(int a, int n)\n{\n\tint res = 1;\n\twhile (n)\n\t{\n\t\tif (n & 1) res = (res * a) % mod;\n\t\ta = (a * a) % mod;\n\t\tn >>= 1;\n\t}\n\treturn res % mod;\n}\n\ninline void fill(int *a, int siz, int val)\n{\n\tfor (int i = 1; i <= siz; i++)\ta[i] = val;\n}\n\ninline void dp(int x, int fa)\n{\n\tif (!x) return;\n\tnum[x] = 1;\n\trev[x] = 1;\n\tint height = h[x] - h[fa];\n\t// if (!rs[x] && !ls[x] && h[x] != h[fa])\n\t// {\n\t// \tsingle[x] = 1;\n\t// \tmulsingle[x] *= fp(2, height);\n\t// \treturn;\n\t// }\n\tif (!rs[x] && !ls[x] && h[x] == h[fa])\n\t\treturn;\n\tdp(ls[x], x);\n\tdp(rs[x], x);\n\t// if (ls[x] && x - ls[x] == 1) rev[x] += single[ls[x]];\n\t// if (rs[x] && rs[x] - x == 1) rev[x] += single[rs[x]];\n\t// if (ls[x]) mulsingle[x] *= mulsingle[ls[x]];\n\t// if (rs[x]) mulsingle[x] *= mulsingle[rs[x]]; \n\tif (ls[x] && h[ls[x]] == h[x]) rev[x] += rev[ls[x]];\n\tif (rs[x] && h[rs[x]] == h[x]) rev[x] += rev[rs[x]];\n\tif (f[ls[x]][1] == 0) ls[x] = 0;\n\tif (f[rs[x]][1] == 0) rs[x] = 0;\n\n\tif (height > 0)\n\t{\n\t\tif (rs[x] && ls[x])\n\t\t{\n\t\t\tf[x][1] = f[rs[x]][1] * f[ls[x]][1] % mod  * fp(2, height) % mod;\n\t\t\t// cout << \"fk1 \" << f[rs[x]][1] << ' ' << f[ls[x]][1] << endl;\n\t\t\t// cout << \"fk0 \" << f[rs[x]][0] << ' ' << f[ls[x]][0] << endl;\n\t\t\tf[x][0] = ((f[rs[x]][1] * f[ls[x]][0] % mod * 2 * (fp(2, rev[x])) % mod + f[rs[x]][0] * f[ls[x]][1] % mod * 2 * (fp(2, rev[x])) % mod) % mod + f[rs[x]][0] * f[ls[x]][0] % mod * fp(2, rev[x]) % mod + f[rs[x]][1] * f[ls[x]][1] % mod * (2 * 2 * (fp(2, rev[x])) % mod - 2)) % mod;\n\t\t}\n\t\telse if (rs[x])\n\t\t{\n\t\t\tf[x][1] = f[rs[x]][1] * fp(2, height) % mod;\n\t\t\tf[x][0] = (f[rs[x]][0] * fp(2, rev[x]) % mod + f[rs[x]][1] * (2 * fp(2, rev[x]) - 2 + mod) % mod) % mod;\n\t\t}\n\t\telse if (ls[x])\n\t\t{\n\t\t\tf[x][1] = f[ls[x]][1] * fp(2, height) % mod;\n\t\t\tf[x][0] = (f[ls[x]][0] * fp(2, rev[x]) % mod + f[ls[x]][1] * (2 * fp(2, rev[x]) - 2 + mod) % mod) % mod;\n\t\t}\n\t\telse \n\t\t{\n\t\t\tf[x][1] = fp(2, height);\n\t\t\tf[x][0] = (fp(2, rev[x]) - 2 + mod) % mod;\n\t\t}\n\t}\t\n\telse \n\t{\n\t\tif (rs[x] && ls[x])\n\t\t{\n\t\t\tf[x][1] = f[rs[x]][1] * f[ls[x]][1] % mod;\n\t\t\tf[x][0] = ((f[rs[x]][0] * f[ls[x]][0] % mod + f[rs[x]][1] * f[ls[x]][0] % mod) % mod + f[rs[x]][0] * f[ls[x]][1] % mod) % mod;\n\t\t}\n\t\telse if (rs[x])\n\t\t{\n\t\t\tf[x][1] = f[rs[x]][1];\n\t\t\tf[x][0] = f[rs[x]][0];\n\t\t}\n\t\telse if (ls[x])\n\t\t{\n\t\t\tf[x][1] = f[ls[x]][1];\n\t\t\tf[x][0] = f[ls[x]][0];\n\t\t}\n\t}\n\t// cout << \"x \" << x << endl;\n\t// cout << \"f[x][1] \" << f[x][1] << endl;\n\t// cout << \"f[x][0] \" << f[x][0] << endl;\n\t// cout << \"rev[x] \" << rev[x] << endl;\n}\n\nsigned main()\n{\n\tint ml = 0;\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++)\tcin >> h[i];\n\tfor (int i = 1; i <= n; i++)\n\t\tif (h[i] > h[i - 1] && h[i] > h[i + 1]) ml += h[i] - max(h[i - 1], h[i + 1]), h[i] = max(h[i - 1], h[i + 1]);\n\tbuild();\n\tfill(mulsingle, n, 1);\n\tf[0][1] = f[0][0] = 1;\n\tdp(root, 0);\n\t// cout << \"mul \" << mulsingle[root] << endl;\n\tcout << (f[root][1] + f[root][0]) % mod * fp(2, ml) % mod << endl;\n\t// cout << \"1 \" << f[root][1] << endl;\n\t// cout << \"0 \" << f[root][0] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing i64 = long long;\n\nconst i64 MOD = 1000000007;\ni64 pow(i64 a, i64 k) {\n\ti64 t = 1;\n\tfor (; k; a = a * a % MOD, k >>= 1) if (k & 1) t = t * a % MOD;\n\treturn t;\n}\n\nconst int INF = int(MOD);\nconst int N = 100000 + 7;\n\nint n;\nint a[N];\n\nstruct seg {\n\tint low[N << 2];\n\tvoid build(int p, int l, int r) {\n\t\tif (l == r)\n\t\t\tlow[p] = a[l];\n\t\telse\n\t\t\tbuild(p << 1, l, l + r >> 1), build(p << 1 | 1, (l + r >> 1) + 1, r),\n\t\t\tlow[p] = std::min(low[p << 1], low[p << 1 | 1]);\n\t}\n\tint getmin(int p, int l, int r, int x, int y) {\n\t\tif (x <= l && r <= y) return low[p];\n\t\tint m = l + r >> 1, u = INF, v = INF;\n\t\tif (x <= m) u = getmin(p << 1, l, m, x, y);\n\t\tif (y > m) v = getmin(p << 1 | 1, m + 1, r, x, y);\n\t\treturn std::min(u, v);\n\t}\n\tvoid arr(int p, int l, int r, int x, int y, int k, std::vector<int>& z) {\n\t\tif (low[p] > k) return;\n\t\tif (l == r) return void(z.push_back(l));\n\t\tint m = l + r >> 1;\n\t\tif (x <= m) arr(p << 1, l, m, x, y, k, z);\n\t\tif (y > m) arr(p << 1 | 1, m + 1, r, x, y, k, z);\n\t}\n} seg;\n\nint ct;\nint l[N], r[N], h[N];\nstd::vector<int> kid[N];\nint build(int u, int v, int q) {\n\tint p = ++ct;\n\tl[p] = u, r[p] = v, h[p] = q;\n\tif (u == v) return p;\n\tstd::vector<int> z;\n\tint w = seg.getmin(1, 1, n, u, v);\n\tz.push_back(u - 1), seg.arr(1, 1, n, u, v, w, z), z.push_back(v + 1);\n\tfor (int i = 1, j; i < z.size(); ++i)\n\t\tif (z[i - 1] + 1 <= z[i] - 1)\n\t\t\tkid[p].push_back(build(z[i - 1] + 1, z[i] - 1, w));\n  return p;\n}\n\ni64 dp[N][2];\nvoid solve(int p) {\n\tint w = r[p] - l[p] + 1;\n\tfor (auto t : kid[p]) solve(t), w -= r[t] - l[t] + 1;\n\tdp[p][0] = pow(2, w), dp[p][1] = 1;\n\tw = a[l[p]];\n\tfor (auto t : kid[p])\n\t\t( dp[p][0] *= dp[t][0] + 2 * dp[t][1] ) %= MOD,\n\t\t( dp[p][1] *= dp[t][1] ) %= MOD,\n\t\tw = std::min(w, h[t]);\n\t( dp[p][0] -= dp[p][1] * 2 ) %= MOD;\n\t( dp[p][1] *= pow(2, w - h[p]) ) %= MOD;\n}\n\nint main() {\n//\tfreopen(\"code.in\", \"r\", stdin);\n//\tfreopen(\"code.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\tif (n == 1) return printf(\"0\"), 0;\n\tfor (int i = 1; i <= n; ++i)\n\t\tscanf(\"%lld\", a + i);\n\tseg.build(1, 1, n);\n\tint rt = build(1, n, 0);\n\tsolve(rt);\n\tprintf(\"%lld\", (dp[rt][0] + dp[rt][1] + MOD * 3) % MOD);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* - - - - - - - - - - - - - - -\n\tUser : \t\tVanishD\n\tproblem :\n\tPoints : \t\n- - - - - - - - - - - - - - - */\n# include <bits/stdc++.h>\n# define \tll \t\tlong long\nusing namespace std;\nconst int inf = 0x3f3f3f3f, INF = 0x7fffffff;\nconst ll  infll = 0x3f3f3f3f3f3f3f3fll, INFll = 0x7fffffffffffffffll;\nint read(){\n\tint tmp = 0, fh = 1; char ch = getchar();\n\twhile (ch < '0' || ch > '9'){ if (ch == '-') fh = -1; ch = getchar(); }\n\twhile (ch >= '0' && ch <= '9'){ tmp = tmp * 10 + ch - '0'; ch = getchar(); }\n\treturn tmp * fh;\n}\nconst int P = 1e9 + 7, N = 210;\nint n, h[N];\nll f[N][2][2][2], g0[2][2][2], g1[2][2][2], use[N];\nll power(ll x, int y){\n\tll i = x; x = 1;\n\twhile (y > 0){\n\t\tif (y % 2 == 1) x = x * i % P;\n\t\ti = i * i % P;\n\t\ty /= 2;\n\t}\n\treturn x;\n}\nint main(){\n//\tfreopen(\".in\", \"r\", stdin);\n//\tfreopen(\".out\", \"w\", stdout);\n\tn = read();\n\tfor (int i = 1; i <= n; i++) h[i] = read(); \n\th[++n] = 1;\n\tint las = inf, lim, tmp, cnt = 0;\n\twhile (cnt < n){\n\t\tlim = -1;\n\t\tfor (int j = 1; j <= n; j++)\n\t\t\tif (use[j] == 0) \n\t\t\t\tlim = max(h[j], lim);\n\t\ttmp = las - lim;\n\t\tfor (int j = 1; j <= n; j++){\n\t\t\tif (use[j] == 2) continue;\n\t\t\tif (use[j] == 0){\n\t\t\t\tif (h[j] < lim) continue;\n\t\t\t\tuse[j] = 1;\n\t\t\t\tf[j][0][0][0] = f[j][0][1][1] = 1;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\telse if (use[j] == 1){\n\t\t\t\tf[j][0][0][0] = f[j][0][1][1] = (f[j][0][1][1] + f[j][0][0][0]) * power(2, tmp - 1) % P;\n\t\t\t\tf[j][0][0][1] = f[j][0][1][0] = (f[j][0][0][1] + f[j][0][1][0]) * power(2, tmp - 1) % P;\n\t\t\t\tif (tmp % 2 == 1){\n\t\t\t\t\tswap(f[j][1][0][0], f[j][1][1][1]);\n\t\t\t\t\tswap(f[j][1][0][1], f[j][1][1][0]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (j != 1 && use[j - 1] != 0){\n\t\t\t\tuse[j] = 2;\n\t\t\t\tint k = j - 1;\n\t\t\t\twhile (use[k] == 2) k--;\n\t\t\t\tfor (int t0 = 0; t0 <= 1; t0++)\n\t\t\t\t\tfor (int t1 = 0; t1 <= 1; t1++)\n\t\t\t\t\t\tfor (int t2 = 0; t2 <= 1; t2++)\n\t\t\t\t\t\t\tg0[t0][t1][t2] = f[k][t0][t1][t2], g1[t0][t1][t2] = f[j][t0][t1][t2];\n\t\t\t\tfor (int t0 = 0; t0 <= 1; t0++)\n\t\t\t\t\tfor (int t1 = 0; t1 <= 1; t1++){\n\t\t\t\t\t\tf[k][0][t0][t1] = (g0[0][t0][1] * g1[0][0][t1] + g0[0][t0][0] * g1[0][1][t1]) % P;\n\t\t\t\t\t\tf[k][1][t0][t1] = ((g0[1][t0][1] + g0[1][t0][0]) * (g1[1][0][t1] + g1[1][1][t1] + g1[0][0][t1] + g1[0][1][t1])) % P;\n\t\t\t\t\t\tf[k][1][t0][t1] = (f[k][1][t0][t1] + (g0[0][t0][1] + g0[0][t0][0]) * (g1[1][0][t1] + g1[1][1][t1])) % P;\n\t\t\t\t\t\tf[k][1][t0][t1] = (f[k][1][t0][t1] + g0[0][t0][1] * g1[0][1][t1] + g0[0][t0][0] * g1[0][0][t1]) % P;\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlas = lim; \n\t}\n\tll ans = 0;\n\tfor (int t0 = 0; t0 <= 1; t0++)\n\t\tfor (int t1 = 0; t1 <= 1; t1++)\n\t\t\tans = (ans + f[1][0][t0][t1] + f[1][1][t0][t1]) % P;\n\tprintf(\"%lld\\n\", 1ll * ans * power(2, P - 2) % P);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long L;\nconst int maxn = 233 , mod = 1e9 + 7 , inv2 = 500000004;\nint n;\nint h[maxn];\nint fpw(int x , int t){\n\tif(!t) return 1;\n\tint c = fpw(x , t >> 1);\n\tc = (L)c * c % mod;\n\tif(t & 1) c = (L)c * x % mod;\n\treturn c;\n}\n\nint ans[maxn][maxn][3];\nbool vis[maxn][maxn];\nint c[2];\n\nvoid solve(int l , int r , int d){\n\tif(vis[l][r])\n\t\treturn ;\n\tvis[l][r] = 1;\n\tif(l == r){\n\t\tans[l][r][1] = fpw(2 , h[l] - d + 1);\n//\t\tcerr << l << \" \" << r << \" \" << d << \" \" << ans[l][r][0] << \" \" << ans[l][r][1] << endl;\n\t\treturn ;\n\t}\n\tint minn = (int)1e9 + 10;\n\tfor(int k = l ; k <= r ; ++ k)\n\t\tminn = min(minn , h[k]);\n\tint ll = l , rr = -1;\n\tfor(int k = l ; k <= r ; ++ k)\n\t\tif(h[k] == minn){\n\t\t\trr = k - 1;\n\t\t\tif(ll <= rr)\n\t\t\t\tsolve(ll , rr , minn + 1);\n\t\t\tll = k + 1;\n\t\t}\n\trr = r;\n\tif(ll <= rr)\n\t\tsolve(ll , rr , minn + 1);\n\tmemset(c , 0 , sizeof c);\n\tll = l , rr = r;\n\tbool first = 1;\n\tfor(int k = l ; k <= r ; ++ k)\n\t\tif(h[k] == minn){\n\t\t\trr = k - 1;\n\t\t\tif(ll <= rr){\n\t\t\t\tif(first){\n\t\t\t\t\tc[0] = ans[ll][rr][0];\n\t\t\t\t\tc[1] = (ans[ll][rr][1] << 1) % mod;\n\t\t\t\t\tfirst = 0;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tc[0] = ((L)c[0] * ((L)2 * ans[ll][rr][1] + ans[ll][rr][0]) + (L)c[1] * (ans[ll][rr][0] + ans[ll][rr][1])) % mod;\n\t\t\t\t\tc[1] = (L)c[1] * ans[ll][rr][1] % mod;\n\t\t\t\t}\n\t\t\t}\n//\t\t\tcerr << k << \" \" << c[0] << \" \" << c[1] << endl;\n\t\t\tif(first){\n\t\t\t\tc[0] = 0;\n\t\t\t\tc[1] = 2;\n\t\t\t\tfirst = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t\tc[0] = ((L)c[0] * 2 + c[1]) % mod;\n\t\t\tll = k + 1;\n//\t\t\tcerr << k << \" \" << c[0] << \" \" << c[1] << endl;\n\t\t}\n\trr = r;\n\tif(ll <= rr){\n\t\tif(first){\n\t\t\tc[0] = ans[ll][rr][0];\n\t\t\tc[1] = (ans[ll][rr][1] << 1) % mod;\n\t\t\tfirst = 0;\n\t\t}\n\t\telse{\n\t\t\tc[0] = ((L)c[0] * ((L)2 * ans[ll][rr][1] + ans[ll][rr][0]) + (L)c[1] * (ans[ll][rr][0] + ans[ll][rr][1])) % mod;\n\t\t\tc[1] = (L)c[1] * ans[ll][rr][1] % mod;\n\t\t}\n\t}\n\tans[l][r][0] = c[0];\n\tans[l][r][1] = (L)c[1] * fpw(2 , minn - d) % mod;\n//\tcerr << l << \" \" << r << \" \" << d << \" \" << ans[l][r][0] << \" \" << ans[l][r][1] << endl;\n}\nint main(){\n\tcin >> n;\n\tfor(int i = 1 ; i <= n ; ++ i)\n\t\tcin >> h[i];\n\tsolve(1 , n , 1);\n\tcout << (ans[1][n][0] + ans[1][n][1]) % mod << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define fst first\n#define snd second\n#define SZ(u) ((int) (u).size())\n#define ALL(u) (u).begin(), (u).end()\n\ninline void proc_status()\n{\n    ifstream t(\"/proc/self/status\");\n    cerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate<typename T> inline T read()\n{\n\tregister T sum = 0, fg = 1;\n\tregister char ch(getchar());\n\tfor(; !isdigit(ch); ch = getchar()) if(ch == '-') fg = -1;\n\tfor(;  isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) - '0' + ch;\n\treturn sum * fg;\n}\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\nconst int MOD = (int) 1e9 + 7;\nconst int MAXN = 100;\n\nint n;\n\nint a[MAXN + 5];\n\ninline void input()\n{\n\tn = read<int>();\n\tfor(int i = 1; i <= n; ++i) a[i] = read<int>();\n}\n\nint m;\n\nint val[MAXN + 5];\n\ninline void discrete()\n{\n\tm = 0;\n\tfor(int i = 1; i <= n; ++i) val[++m] = a[i];\n\tsort(val + 1, val + m + 1), m = unique(val + 1, val + n + 1) - (val + 1);\n\tfor(int i = 1; i <= n; ++i) a[i] = lower_bound(val + 1, val + m + 1, a[i]) - val;\n}\n\ninline int fpm(int base, int exp)\n{\n\tint res = 1;\n\tfor(; exp; exp >>= 1, base = (LL) base * base % MOD) if(exp & 1) res = (LL) res * base % MOD;\n\treturn res;\n}\n\ninline void solve()\n{\n\tdiscrete();\n\n\tstatic int f[MAXN + 5][MAXN + 5] = {0};\n\n\tf[0][0] = 1;\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\tf[i][0] = f[i - 1][0] * 2 % MOD;\n\t\tfor(int j = a[i] + 1; j <= a[i - 1]; ++j) (f[i][0] += f[i - 1][j] * 2 % MOD) %= MOD;\n\n\t\tint coef = a[i] <= a[i - 1] ? 1 : fpm(2, val[a[i]] - val[a[i - 1]]);\n\t\tfor(int j = min(a[i], a[i - 1]); j; --j) f[i][j] = (LL) f[i - 1][j] * coef % MOD;\n\n\t\tfor(int j = a[i - 1] + 1; j <= a[i]; ++j)\n\t\t{\n\t\t\tcoef = (j == 1 ? fpm(2, val[j]) - 2 : fpm(2, val[j] - val[j - 1] + 1) - 2) % MOD;\n\t\t\t(f[i][j] += (LL) f[i - 1][0] * coef % MOD * fpm(2, val[a[i]] - val[j]) % MOD) %= MOD;\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor(int i = 0; i <= a[n]; ++i) (ans += f[n][i]) %= MOD;\n\tprintf(\"%d\\n\", (ans + MOD) % MOD);\n}\n\nint main()\n{\n\tfreopen(\"D.in\", \"r\", stdin);\n\tfreopen(\"D.out\", \"w\", stdout);\n\n\tinput();\n\tsolve();\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ff first\n#define ss second\n#define pb push_back\n#define mp make_pair\ntypedef long long LL;\ntypedef unsigned long long uLL;\ntypedef pair<int,int> pii;\n\nconst int maxn=111;\nconst int mod=1e9+7;\nint qpow(int x,int y)\n{\n\tint ret=1;\n\twhile(y)\n\t{\n\t\tif(y&1)ret=(LL)ret*x%mod;\n\t\tx=(LL)x*x%mod;\n\t\ty>>=1;\n\t}\n\treturn ret;\n}\n\nint n,h[maxn];\n\npii solve(int l,int r,int v)\n{\n\tif(l==r)return mp(qpow(2,h[l]-v),0);\n\t\n\tint mn=*min_element(h+l,h+r+1);\n\tvector<int> pos;pos.pb(l-1);for(int i=l;i<=r;i++)if(h[i]==mn)pos.pb(i);pos.pb(r+1);\n\tvector<pii> ansv;\n\tfor(int i=1;i<(int)pos.size();i++)if(pos[i]>pos[i-1]+1)ansv.pb(solve(pos[i-1]+1,pos[i]-1,mn));\n\t\n\tint v1=2,v2=qpow(2,(int)pos.size()-2);\n\tfor(int i=0;i<(int)ansv.size();i++)\n\t{\n\t\tv1=(LL)v1*ansv[i].ff%mod;\n\t\tv2=(LL)v2*(ansv[i].ff*2ll+ansv[i].ss)%mod;\n\t}\n\tv2-=v1;if(v2<0)v2+=mod;\n\tv1=(LL)v1*qpow(2,mn-v-1)%mod;\n\treturn mp(v1,v2);\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",h+i);\n\t\n\tpii ans=solve(1,n,0);\n\tprintf(\"%d\\n\",(ans.ff+ans.ss)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define XX first\n#define YY second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define REP rep\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\nconst ll MOD=1e9+7;\n\n#define rall(X) (X).rbegin(),(X).rend()\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n\ntemplate<ll mod>\nstruct ModInt{\n  using M=ModInt;\n  ll a;\n  M& put(ll v){\n    a=(v<mod)?v:v-mod;\n    return *this;\n  }\n  ModInt(ll v=0){put(v%mod+mod);}\n  M operator+(M x){return M().put(a+x.a);}\n  M operator-(M x){return M().put(a+mod-x.a);}\n  M operator*(M x){return M().put(a*x.a%mod);}\n  M operator/(M x){return *this*x.inv();}\n  M& operator+=(M x){return *this=*this+x;};\n  M& operator-=(M x){return *this=*this-x;};\n  M& operator*=(M x){return *this=*this*x;};\n  M& operator/=(M x){return *this=*this/x;};\n  bool operator==(M x){return a==x.a;}\n\n  M pow(ll m){\n    M x=*this,res=1;\n    while(m){\n      if(m&1)res*=x;\n      x*=x;\n      m>>=1;\n    }\n    return res;\n  }\n  M inv(){return pow(mod-2);}\n};\n\nusing Int = ModInt<MOD>;\n\nint N;\nvector<LL> hs;\nInt fact = 1;\n\nstruct Val {\n  Int dp1;\n  Int dp2;\n};\n\nstruct Val Calc(vector<LL> &hs) {\n  if (hs.size() == 1) {\n    fact *= Int(2).pow(hs[0]);\n    return Val{1, 1};\n  }\n\n  LL mh = 1LL << 40;\n  for (LL h : hs) {\n    MN(mh, h);\n  }\n\n  struct Val ret = {1, 1};\n  vector<LL> vec;\n  if (mh == 1) {\n    for (LL h : hs) {\n      if (h == 1) {\n        if (vec.size()) {\n          auto res = Calc(vec);\n          ret.dp1 *= res.dp1;\n          ret.dp2 *= res.dp2;\n          if (vec.size() == 1) {\n            ret.dp2 *= 2;\n            fact /= 2;\n          }\n        }\n        vec.clear();\n        ret.dp2 *= 2;\n      } else {\n        assert(h >= 2);\n        vec.eb(h);\n      }\n    }\n\n    if (vec.size()) {\n      auto res = Calc(vec);\n      ret.dp1 *= res.dp1;\n      ret.dp2 *= res.dp2;\n      if (vec.size() == 1) {\n        ret.dp2 *= 2;\n        fact /= 2;\n      }\n    }\n    //cout << ret.dp1.a << \", \" << ret.dp2.a << endl;\n    return ret;\n  }\n  \n  int w = 0;\n  int e = 0;\n  for (LL h : hs) {\n    h -= mh;\n    if (h > 0) {\n      vec.eb(h);\n    } else {\n      ++w;\n      assert(h == 0);\n      if (vec.size()) {\n        auto res = Calc(vec);\n        ret.dp1 *= res.dp1;\n        ret.dp2 *= res.dp2;\n        if (vec.size() == 1) ++w;\n        else e++;\n      }\n      vec.clear();\n    }\n  }\n\n  if (vec.size()) {\n    auto res = Calc(vec);\n    ret.dp1 *= res.dp1;\n    ret.dp2 *= res.dp2;\n    if (vec.size() == 1) ++w;\n    else e++;\n  }\n\n  if (w == hs.size()) {\n    ret = Val{Int(2).pow(mh-1)*ret.dp2, (Int(2).pow(mh) + Int(2).pow(w) - 2)*ret.dp2};\n    //cout << ret.dp1.a << \", \" << ret.dp2.a << endl;\n    return ret;\n  }\n\n  Int kazu = Int(2).pow(e);\n  //cout << \"w: \" << w << endl;\n  Int g = Int(2).pow(w);\n  ret.dp2 *= g;\n  //cout << ret.dp1.a << \", \" << ret.dp2.a << endl;\n  Int t = Int(2).pow(mh);\n  ret.dp2 += ret.dp1 * ((kazu*kazu - kazu)*g + kazu*(t-2));\n  ret.dp1 *= Int(2).pow(e+mh-1);\n  //cout << ret.dp1.a << \", \" << ret.dp2.a << endl;\n  return ret;\n}\n\nsigned main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n  cin >> N;\n  rep(i, N) {\n    LL h;\n    cin >> h;\n    hs.eb(h);\n  }\n  cout << (fact*Calc(hs).dp2).a << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\n\n#define FOR(i,a,b) for(ll i=(a);i<(b);i++)\n#define REP(i,a) FOR(i,0,a)\nusing namespace std;\t\n\nconst ll MOD=1e9+7,MAX_N=100;\n\nll N,h[MAX_N];\n\nll memo[MAX_N][MAX_N*2];\nvector<ll> hei;\n\nll mpw(ll n,ll m){\n\tif (m==0){\n\t\treturn 1;\n\t}\n\tll ret=mpw(n,m/2);\n\tret*=ret;\n\tret%=MOD;\n\tif (m&1){\n\t\tret*=n;\n\t\tret%=MOD;\n\t}\n\treturn ret;\n}\n\nll dfs(ll n,ll m){\n\tif (memo[n][m+1]!=-1){\n\t\treturn memo[n][m+1];\n\t}\n\tll ret=0;\n\tif (m%2==0 && hei[m/2+1]-hei[m/2]<=1){\n\t\tret=0;\n\t}else if (n==N-1){\n\t\tif (m==-1){\n\t\t\tret=2;\n\t\t}else{\n\t\t\tif (m&1){\n\t\t\t\tret=mpw(2,h[n]-hei[m/2+1]);\n\t\t\t}else{\n\t\t\t\tret=mpw(2,h[n]-hei[m/2+1])*((mpw(2,hei[m/2+1]-hei[m/2]-1)+MOD-1)%MOD)%MOD*2%MOD;\n\t\t\t}\n\t\t}\n\t}else if (m==-1){\n\t\tif (h[n+1]<=h[n]){\n\t\t\tret=dfs(n+1,-1)*2%MOD;\n\t\t}else{\n\t\t\tret=dfs(n+1,-1)*2%MOD;\n\t\t\tll x=lower_bound(hei.begin(),hei.end(),h[n])-hei.begin(),y=lower_bound(hei.begin(),hei.end(),h[n+1])-hei.begin();\n\t\t\tREP(i,(y-x)*2){\n\t\t\t\tret+=dfs(n+1,x*2+i-1)*2%MOD;\n\t\t\t\tret%=MOD;\n\t\t\t}\n\t\t}\n\t}else{\n\t\tif (m%2){\n\t\t\tif (h[n+1]>hei[m/2+1]){\n\t\t\t\tret=dfs(n+1,m)*mpw(2,max(h[n]-h[n+1],0ll))%MOD;\n\t\t\t}else{\n\t\t\t\tret=mpw(2,h[n]-hei[m/2+1])*dfs(n+1,-1)%MOD;\n\t\t\t}\n\t\t}else{\n\t\t\tif (h[n+1]>=hei[m/2+1]){\n\t\t\t\tret=dfs(n+1,m)*mpw(2,max(h[n]-h[n+1],0ll))%MOD;\n\t\t\t}else{\n\t\t\t\tret=mpw(2,h[n]-hei[m/2+1])*((mpw(2,hei[m/2+1]-hei[m/2]-1)+MOD-1)%MOD)%MOD*2%MOD*dfs(n+1,-1)%MOD;\n\t\t\t}\n\t\t}\n\t}\n\treturn memo[n][m+1]=ret;\n}\n\n\t\t\nint main(){\n\tcin>>N;\n\tREP(i,N){\n\t\tcin>>h[i];\n\t\thei.push_back(h[i]);\n\t}\n\thei.push_back(0);\n\tsort(hei.begin(),hei.end());\n\thei.erase(unique(hei.begin(),hei.end()),hei.end());\n\tmemset(memo,-1,sizeof(memo));\n\tll ans=dfs(0,-1);\n\tll x=lower_bound(hei.begin(),hei.end(),h[0])-hei.begin();\n\tREP(i,x*2-1){\n\t\tans+=dfs(0,i);\n\t\tans%=MOD;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nconst int N = 105;\nconst int INF = 0x3f3f3f3f;\ntypedef long long ll;\n#define lson l, m, rt<<1\n#define rson m+1, r, rt<<1|1\nconst int MOD = 1e9+7;\n\n\nint h[N];\nint Has[N]; int tot;\nll dp[N][N];\n\nll Pow(ll x, ll y) {\n\tif(y <= 0) return 1;\n\tll result = 1;\n\twhile(y) {\n\t\tif(y & 1)\n\t\t\tresult = result * x % MOD;\n\t\ty >>= 1;\n\t\tx = x*x % MOD;\n\t}\n\treturn result;\n}\n\nint main() {\n\tint n;\n\twhile(~scanf(\"%d\", &n)) {\n\t\ttot = 0;\n\t\tmemset(dp, 0, sizeof(dp));\n\t\th[0] = 0;\n\t\tdp[0][0] = 1;\n\n\t\tfor(int i = 1; i <= n; ++i) {\n\t\t\tscanf(\"%d\", &h[i]);\n\t\t\tHas[++tot] = h[i];\n\t\t}\n\t\tsort(Has + 1, Has + tot + 1);\n\t\ttot = unique(Has+1, Has + tot + 1) - Has - 1;\n\t\t\n\t\tfor(int i = 1; i <= n; ++i) {\n\t\t\th[i] = lower_bound(Has + 1, Has + tot + 1, h[i]) - Has;\n\t\t}\n\t\t\n\t\t\n\t\tfor(int i = 1; i <= n; ++i) {\n\t\t\tdp[i][0] = dp[i-1][0] * 2 % MOD;\n\t\t\tfor(int j = h[i] + 1; j <= h[i-1]; ++j) dp[i][0] = (dp[i][0] + dp[i-1][j] * 2 % MOD) % MOD;\n\n\t\t\tll tmpPow = Pow(2, Has[h[i]] - Has[h[i-1]]);\n\t\t\tfor(int j = 1; j <= min(h[i-1], h[i]) ; ++j) {\n\t\t\t\tdp[i][j] = dp[i-1][j] * tmpPow % MOD;\n\t\t\t}\n\n\t\t\tfor(int j = h[i-1] + 1; j <= h[i]; ++j) {\n\t\t\t\tdp[i][j] = (dp[i][j] + j==1? ( dp[i-1][0] * ( Pow(2, Has[j]) - 2) % MOD * Pow(2, Has[h[i]] - Has[j]) % MOD ) :\n\t\t\t\t\t\t\t\t\t\t\t ( dp[i-1][0] * 2 * (Pow(2, Has[j]-Has[j-1]) - 1) % MOD * Pow(2, Has[h[i]]-Has[j]) % MOD ) \n\t\t\t\t\t\t\t\t\t\t\t ) %MOD;\n\t\t\t}\n\t\t}\n\n\n\t\tll result = 0;\n\t\tfor(int i = 0; i <= tot; ++i) {\n\t\t\tresult = (result + dp[n][i]) % MOD;\n\t\t}\n\t\tprintf(\"%lld\\n\", result);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nconst int MOD = (int)1e9 + 7;\n\nint n,m,h[101],hnum[101],dh[101];///h记录每一列高度 dh记录离散化后的各不相同的高度 hnum记录h对应dh中的位置，即第几高的高度\nlong long dp[101][101];///记录第i列第n块高度往上的方案数\n\nint pow_(long long x,int y) {///快速幂求 x的y次方\n    long long ans = 1;\n    if(y > 0) {\n        while(y) {\n            if(y % 2)ans = ans * x % MOD;\n            x = x * x % MOD;\n            y /= 2;\n        }\n    }\n    return ans;\n}\n\nint main() {\n    scanf(\"%d\",&n);\n    for(int i = 1;i <= n;i ++) {\n        scanf(\"%d\",&h[i]);\n        dh[++ m] = h[i];///先把高度存到dh数组 下标从1开始，方便后面dp\n    }\n    sort(dh + 1,dh + m + 1);///dh数组排序\n    m = unique(dh + 1,dh + m + 1) - dh - 1;///dh数组离散化去掉重复的高度 m是不相同的高度数\n    for(int i = 1;i <= n;i ++) {\n        hnum[i] = lower_bound(dh + 1,dh + m + 1,h[i]) - dh;///每一列高度在dh数组中对应的位置\n    }\n    dp[0][0]=1;///初始化 当第0列有1个无连续相同的方案\n    for(int i = 1;i <= n;i ++) {///对每一列每个高度段进行更新 更新过程为从下往上\n        (dp[i][0] += dp[i - 1][0] * 2 % MOD) %= MOD;///无连续相同方案  加上前i - 1列无连续相同方案数*2 因为可以是与前一列对应位置同色或者异色一共两种方案\n        for(int j = hnum[i] + 1;j <= hnum[i - 1];j ++)///如果前一列比这一列高，高出的部分也存着接触部分无连续相同的方案 但是可能会重复加上上一步的方案数所以下面更新高出的部分时会避免\n            (dp[i][0] += dp[i - 1][j] * 2 % MOD) %= MOD;\n        int d = pow_(2,h[i] - h[i - 1]);///比前一列高出部分的涂色方案数，如果比前一列低 d就等于1\n        for(int j = 1;j <= min(hnum[i - 1],hnum[i]);j ++) {\n            dp[i][j] = dp[i - 1][j] * d % MOD;///有连续相同颜色的方案数 已经分析过接触部分的颜色一定是定下的 所以这一列接触部分有连续相同部分的方案数由高出部分的变化决定 即 乘上d\n        }\n        for(int j = hnum[i - 1] + 1;j <= hnum[i];j ++) {///更新比前一列高出的部分 j从上一列的高度加1的下标开始\n            if(j > 1)(dp[i][j] += dp[i - 1][0] * (pow_(2,dh[j] - dh[j - 1]) - 1) % MOD * 2 % MOD * pow_(2,h[i] - dh[j]) % MOD) %= MOD;\n            ///一般情况 前i - 1列无连续方案 * （第j块高度变化方案 -1表示去掉无连续相同方案) * 2 * 剩下几块高度的变化方案数\n            else (dp[1][1] += dp[0][0] * (pow_(2,dh[1]) - 2) % MOD * pow_(2,h[i] - dh[1]) % MOD) %= MOD;\n            ///第一列的第一块高度 记录随意变化方案数 -2表示除去dp[i][0]已经记录过的无连续相同方案 勿重复记录\n        }\n    }\n    long long ans = 0;\n    for(int i = 0;i <= hnum[n];i++)\n        (ans += dp[n][i]) %= MOD;\n    printf(\"%lld\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*\nCoded by 秦惜梦\nThe most attractive girl in the world\n@@@@@@@@@@##&|;!!!!!!!!!!||||||||%%%%%$$$$$$$$$$$$%%$$$&&&&&&&&&$$&&&&&&&&&@@@&%||||||$&&&&@&%;'```'`':!||%&@@@@#@&&&&&@@@&&$$$&&@@&$$$&@@@@@@@@@@@@@#@@@@@@@@@@#@@@@@#@@@@@@@@@@##$\n@@@@@@@@@####$!;!!!!!!!!!||||||||%%%%%%%%%%%%%%%$$$$&&&&&&&&&&&&&&&&&&&&@@@@@@&%|||||!:'`'!$&&&&&&%:''!|||$&&&@@@@@@&&&&&@@@&$$$&&@&&$&&@@@@@@@@@@@@@@@@@@@@@@@@##@@@@#@@@@@@@@@@#@%\n@@@@@@@@@####@|;!!!!!!!!!|||||||%%%%%%%%%%%%%$$$$$$$$$$&&&&&&&&&&&&&&&@@@@@@@@&%|;:'''''``````'!$&&&@@&|:;%$$&&&@@@@@&&&&&@@@&$$$&&@@@@@@@@@@@@@@@@@@@@@@@#@@@@@#@@@@@#@@@@#@@@@##@%\n@@@@@@@@####@@&|;!!!!!!!!|||||||%%%%%%%%%%%%%%$$$$$$$$&&&&&&&&&&&$$$&&@@@@@@@@@@&$|;'''''````````'':!$&&&$%%%%$$&@@@@@&&&&&@@@@&&&@@#@@@@@@@@@@@@@@@@@@@@@@@@@@@#@@@@@@@@@@#@@@@#@@%\n@@@@@@@#####@@@$!;!!!!!!|||||||%%%$$$$$%%%%%%%%%$$$$$$$&&&&&&&&&$$$$&&@@@@@@@@$%$&@@&&&@&$%;:':;:''`````'|%%%%%%$$&@@@@@&&&&@@#@@@@@@#@@@@@@@@@@@@@@@@#@@@@@@@@@#@@@@@@@@@@@@@@#@@@%\n@@@@@@#####@$%%%$$$%%%||%%||||%%%%$%%$$$$$%%%%%%%$$$$&&&&&&&&&$$$$$$&&@@@@@@@&$;'''''':!%&&&&&&@@&%;'```:$&&%%%%%$$$&@@@@&&&&@@@@@@@@@#@@@@@##@@@@@@@@#@@@@@@@@@@@@@@#@@@@@@@@@#@@@%\n$&@@@@######&&&&&$%%%%|%|||||||%%%%%$$$$$$$$$$$$$&&&&&&&&&&&&&&&&$$$$&&@@@@@@&$!''''''````````:!|$&&&&&&&$&&&$%%%%$$$&&@@@&&&&&@@@@&@@@@@@@@@#@@@@@@@@#@@@@@&&&@@@@@@@@@@@@@@@#@@@@$\n$$$&@######@&&&&&&|!!!!!|||||||%%$$$$$$$$$$$$$$$&&&&&$$&&&&&&&&&&&&$$&&&@@@@@@&%;::''````````'':'``....`;|%$&&&$%%$$$$$&@@@&&&&&@@@@@@@@#@@@@@#@@@@@@@@@@@@@@&&@&&&&&&&&&@@@@@@@@@@$\n$$$&@#####@&$$&&@#&|!!!!!|||||||%%%$$$$%%%%%$$$$$$$&&&&&&&&&&&&@@@@@&&&&&&@@@@@@@@@@@&&&&&&&&@@@@&&$$%||||%%%$$&&&$$$$$$$&@@@&&&&&@@@@@@@#@@@@@@@@@@@@@@@@@@@@&&@&&&&&&&&@@@@@@@@@#$\n$$&@######@&$&@##@&$|!!!!|||||||%%%%%%%%%%%%%$$$$&&&&&&&&&&&&&&&&&&&&$$&&&&&&@@&|'`````````':::;;;;;;!|%%%%%%%%$&@@&$$$$$$$&@@&&&&&@@@@@@@@@@@@@@@@@@@@#@@@@@@@@@&&&&&&&&&@@@@@@@#@%\n$&@######@&&&@##@$$$$|!!!||||||||%%%%%%%%%%%%$$$$&&&&&&&&&&&&&&&&&&&&$&&&&&&&&@@$!:::'':::::::::::::''``.:%%$$$$$$&@@@&$$$$$&@@@&&&&@@@@@@@@@@@@#@@@@@@@@@@#@@@@#@@@@@@&&&@@@@@@@@@%\n$&@######@&&@#@&$$$$&$|!!!||||||||%%%%%%%%%$$$$$&&&&&&&&&&&&&&&&&&&$$$&&&&&&&&&&&%;::::::::::::':''':'':::%&$$$$$$$$&&@@&$$$$$&@@@&&&&@@@@@@@@@@@@@@@@@@#@@@@@@@@@@@@@@@@@@@@@@@@@@%\n&@#######@@@#@&$$$$$&&$|!!|||||||||%%%%%%$$$$$$$$$&&&&&&&&&&&&&&&$$$$$&&&&&&&&&&&$!''::::'''::;!|%%$&&@@@@&&@@$$%%$$$$&&@&&$$$$&@@@&&&&@@@@@@#@@@@@@@@@@@@@@@@@#@@@@@@@@@@@@@@@@@@@%\n############&$$$$$$$&&&$|!!||||||||%%%%%%$$$$$$$$$$$$$$&&&&&$$$$$$$$$$&&&&&&&&&&&&@@@&&&&&&&@@@@@@&&&$$%|!;%@@@@&$$$$$$$$&@@&$$$$&@@@&&&@@@@@@@@@#@@@@@@#@@#@@@@@@@@@@@@@@@@@@@@@@@$\n########@&$$$$$$$$$&&&&&$|!!||||||%%%%%%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$&&@@&&&&&&&&&&&&&&$$$$$$$$$$&&&$$%!;:::|$&@@@@&$$$$$$$&@@&$$$&@@@&&&@@@@@@@@##@@@@@@@@@@@@#@@@@@@@@@@@@@@@@@@@$\n########@$%%%$$$$$$&&&&&&&%!||||%%%$$$%%%%%%%%%%%%%%%%%%%%%%%$$$$$&&&&&&&&&&@@@&&&&&&&&&&&&$$$$$$$$$$$$$&&%!!$$$$&@@@@&$$$$$$&@@@&&&&@@@&&@@@@@@@##@@@@@#@@@@@@@@@@@@@@@@@@@@@@@@@@%\n#######@&$$$$$$$$$$$$&$|!||%%%%||%%%%%%%%%%%%%%%%%$$$$$$&$$$$$&&&&&&&&@@@@&&&&&&&&&&&&&&&&&&&$$&&$$$$$$$$$&&&$&@&$$$&@@@&$$$$$$&@@@@&&@@@@&@@@@@@###@@@@@@@@@@@@@@@@@@@@@@@@#@@@@#@%\n#######@$$$$$$%$$$$$$$&&$||||%%%%%%$$$$$$$$$$$$$$$$$$$$$$$&&&&&&&&&&@@&&&&&&&&&&&&$$$$$$&&&&$$$$$$$$$$$$$$$$$$&@@@@&$$$&@@@&$$$$&&&@@@&@@@@&&@@@@@###@@@@#@@@@@#@@@@@@@@@@@#@@@@#@@$\n#######&$$$$$$$$$$&$$$$$&&&&&$%||%%%%%%$$$$$$$$$$$$$$$$$&&&&&&&&&&&@&&&&&&&&&&&&$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$&&@@@&$$$&@@@&$$&&&@@@@@@#@@@@@@@@##@@@@#@@@@@@@@@@@@@#@@@@@@##@##$\n######@$$$$$$$$$$$$$$$$$$&&&&&&$||%%%%%%%$$$$$$$$$$$$$&&&&&&&&&@@&&&&&&&&&&&&&&$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$&@@@@@&&$&&@@@&&&&&@@@@@##@@@@@@@##@@@###@@@@@@@@@@@@@@#@@@#@#@@%\n######&$$$$$$$$$$$$$$$$$&&&&&&&&$%|%%%%%%%$$$$$$$$$$&&&&&&&&&&@&&@@&&&&&&&&&&$$$$$$$$$$$$$$$$$$$$$$$&$$$$$$$$$$$$$$$$&@@@@@@&&&&&@@@&&&&@@@@@#@@@@@###@@@##@@@@@@@@@@@@@@#@@@####@#$\n#####@$$$$$$$$$$$$$$$$$$$&&&&&&&&&%%%%%%%%%$$$$$$$$&&&&&&&&&&&&&&&&&&&&&&&&$$$$$$$$$$$$$$$$$$$$$$$$$$&$$$$$$$$$$$$$$$$$&&&@@@@@&&&&@@@@@@@@@@@@#@@@@###@@@$%%%%%%%%%%%%%$&@@#######$\n#####@&$%$$$$$$$$$$$$$$$$$$&&&&&&&&$%%%%%%%%%%$$$$&&&&&&&&&&&&&&&&$$$$$$$$$$$$$$$$$$$$$$$$$$%$$$$$$$$$%%$$$$$$$$%%$$$$$%&@&&&&@@@@@&&@@@@@&&@@@@#@@@@###@&%%%%%%%%%%%%%%%%%&@##@##@%\n####@@@@&$$$$$$$$$$$$$$$$$$&&&&&&&&&&%%%%%%%%%%$$&@&&&&$&&&$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$||$$$$$$$$%%$$$$$|%$$$$$$$%%$&@@@&&&@@@@@@@@@@@@&@@@@@@@@##@&%%%%%%%%%%%%%%%%%%%$@@@@@%\n####@@@@@@&$%$$$$$$$$$$$$$$$$$&&&&&&&&$%%%%%%%$&&&&&$$$$$$&$$$$$$$$$$$$$$$$$$$$$$$%%$$$%%%%|!|||$$$$%!|%%%$$&$$$$$$$$$$%%%$&@#@@@@&&@@@@@@@@@@@@@@##@@@@#@@@&$$%%%%%%%%|%%%%%|$@@@@$\n###@@@@@@@@$$$%$$$$$$$$$$$$$&&&&&&&&&&&&%%%%%&&&&&$%%%$$&&&$$$$$$$$$%%%$$|%$$$%%%$%%|%%!;!||!!||%$$$$$$$%%$&$$&&$$$$$$$$$$%%$@@#@@@@@@&&@@@@@@@@#@@###@@@########@@$%%%%%%%|%%$&@##$\n##@@@@@@@@@&$$$&$$$$$$$$$$$$$$$&&&&&&&&&&&%%%$&%|%%%%%$%%$$%%%%%%$$$%%%$$||%%%$$$$$%%%%%$$$$$%!!|%&&$$$$%|$$$$$$&$$$$$$$$$$$%$$&@@@@@@@@@@@@@@@##@@@@##@@####@@#######&%%%%%%%$@###$\n#@@@@@@@@@@&&$$&$$$$$$$$$$$$$$$&&&&&&$||%%%$$%!;!;!|%%%%$%!||||%%%$$$||%$%%%%%%$$$$%$$%%%%$%$$$$||$&&$$&%|%$$$$$$$&$%%$%|%$$$$%$%$@@@@@@##@@@@@@@@@@########@##@@@######&$$&@@@@@##$\n@$$&@@@@@@@&&$$$$$$$$$$$$$$$$$$&&&$&&&&$$&$$%!|%%%%%%%%%%||%%%%%%%%$$||%$$$$%%%%$$$%%$$%%%%%%%$$%|%&&$$&$%%$$$$$$$&&$%%&&&&$$$$$$$||$@@@@@@@@@@@@@@@@@@@####@@@@##@@@#@@@@@@@@@@@@@%\n&$%%$$&&&$$$$$$$$$$$$$$$$$$$$$$$$$$&&&&&&&&|!|%%%%|%%%%%%$%%%%||||%$$%|%$&&$%%%%$$$$%$$%%%%$$$$$%|$&&&$&$$$&$&$$$$&&&$%$&&&$$&&&&&$%!!|$&@@@@@@@@@@@@@@@@###@@@@@@@@@@@@@@@@@@@@@@@%\n$$%$$$$$$$$$$$$$$$$$$$$$$$$$$$$&&&$&&&&&&$|!|||%%|%%%%%%$$%%%%||||%$$%%%$&&$%%%$$&&&$$$$$$$$$$$$$%%&&&&&$$&&$&$$&&&&&&&&&&&&&&&&&&&&$|!!!!$&@@@@@@@@@@@#####@######@##@@&@@@@@@@@@@$\n$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$&&&&&&$|!|||%$%%%%%%%$$$$%%%||||%$$%%%$&&$$%%$&&&&&$$$$$$$$$$$$%%&&&&&$$&&$&$$&&&&&&&&&&&&&&&&&&&&&&%!!!!|&&&@@@@@@#########@########@@##########$\n$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$&&&&&$&$%|!||%$$%%$%%%%$$$$$%%|||||$$$&$$&$$$%$&&&&&&$$$$$%$$$$$$%$&&&&&&&&&&&$$&&&&&&&&&&&&&&@@&&&&&@@$|!$@&||||%&@#@@####@########@@@@@@@#@&&@@##$\n$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$&&&$$&$%|!||%$$%%%%%%%$$$%$$%%||||%$&&&&&&$$$$$$&&&&&$%$$$%%$$$$$%$&&&&&&&&$$$$$&&&&&&&&&&&&&&@@@&&@@@@@&@@&|||||||||%&@###############@@@@@@##@@@@%\n%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$&$&&$$$$%!!|%$$$%%%%%%$$$$%$$$%||||$&&$$&&$$$$$$$&&&$&$%%$%%%%%%$$%$$$&&&&&$$$$$$&&&&&&$&&&&&&&&&&&&&&&@@@@&||||||||||||$@#####@@@########@@@@@###@@$\n%%%%%%%%$$$$$$$$$$$$$$$$$$$$$$$$$&&%%&%!!||%$$%%$$%%$$$$%%$$%%|!|%&&$%%&&$%%%%$$$&$|%$||$%%%%%%$$$$$$&&&&$$$$$$&&&&&&$$$&&&&&&&&&&@@&&&@@@&&%|||||||||%&@@##@$$@@@@########@@@@@@##$\n;:''':;!|%%$$$$$$$$$$$$$$&&&&&&&&%%&&$!!|%%%%%%%$$$$$$$%%%$%%%|||$$&%!%&$%%%%|%%%&%!|$||%%%%%%%$$$$%%$&&$$$$$$$&&&&&&$$$$&&&&&&&&&&&&&&@@@@&&%|||||||%@@@@#@%|&#$||||%&@@@@@@@@@@@@$\n.....  .`;|%%$$$$$$$$$$$&&&&&&$%%$&&$!;|%%|||%%$$&&&&$$%%$$%%%%%%%&%!;|$$%||||%%%$|;!%||$%$$$$$%%%%||$&$%%%$$$$&&&&&&$$$$&&&&&&&&&&&&&@@@@@@&&%|||||$@@@##&%|%@@%||||||||||&@@@@@@@%\n........  `;|%$$$&&&&&&&&&&&$%$&&&&$|!|%%|!!|||$&$&&&$$%%%%%||||%$$|;;|%%|||||%$&&$|!|!!%%%%%%|!!|%!%$$%||%$&$&&&&&&&$$$$&&&&&&&&&&&&@@@@@@@@&&%|||$@@@##@$||$#&|||||||||||&#$|||||!\n...    ..  `;|%$$$$&&&&&&$%$$&&&&&&||%%$||!!||$&$$$$$$%%%%%%||||%$%!:!!!%%$$$%%%%|!;;;;;!!!!!;;;||!%&%|%%%$&&$&&&&&&&$$$$&&&&&&&&&&&@@@@@@@@@&&$||$@##@@@%||%&@$||||||||||%&@$|||||!\n       ..  .'!|%$$&&&&&&&&&&&&&&&&||$$&%||!||%&&$$$$$$%%$%||||||%|!;:;;;|%|!!!!!|!|$$&&&&$$$%!!!!;|&&$%%%$&$$$$%||&@&$$$$&&&&&&&&&@@@@@@@@@@@@&$|%@@@@#@%|||$@&%||||||||||%@@%|||||!\n       ... .';|%$$&&&&&&&&&&&&&&&%%&$&&%|||||%&&$$$$$$%%$%%%||||%!;:::::::'':;!|%%%%$&@&&$%|!|%|;!$&$%|%%$$$$&$|!|$@@&$$$&@@@@@@@@@@@@@@@@@@@@&$$@@@#@&%|||%&#$|||||||||||$@&%|||||!\n    ....   .:!|%$$&&&&&&&&&&&&&&$$&&&&$|||||%$@&$$&$$&&&$%|%%%%|;::''''''````'!!!;'`'%@&%|!::!;;!$$||%%%$&$$$$|!!|%&@@&&&&@@@@@@@@@@@@@@@@@@@@&&@@@@#@%||||$@@$|||||||||||$#&||||||!\n     ..   .';!|%$$$&&&&&&&&&&&&$$&&&&&$$%||%%&@&$$&$$$$%|!;;;;:::'`````````````````';;:;!;'::::;%$|||!!|$$$%$%||||$@@@&&&@@@@@@@@@@@@@@@@@&&@&&&&&&@@@$%%||&#&%||||||||||%&#$||||||!\n        .`:!!!|$$&&&&&&&&&&&&&&&&&&&&&&&$%$$$&@&&$&&$$|!|%$$$$%|;''``````````````':;!!!;::''':;!$%|$$%%$$$$$$%!!%&@@@@@@@@@@@@@@@@@@@@@@@@&&&&@&$$&@@@@@@@@@#&%||||||||||%@@$||||||!\n;:''`'':;!!!!|%$$&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&$&&&&&$|!%%%%$&$$|;'``````````````''''''''::::;|$&$$$%%$$%%$$$&@@@@@@@@@@@@@@@@@@@@@@@@@@@&&&@&$$$&&&@@@@@@@@@@@@@@&$%|||$@@$||||||!\n|!;;;!!!!!!|%$$$&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&%!:;|!||!!:'''``````````````''''''''':;;|$$$$$%%$%$$$&&&&&@@@@@@@@@@@@@@@@@@@@@@@@&&&@&$$$&&&&&@@@@@##@@@@@&&@@@@@@#@&%|||||!\n%|!!!!!!||%$$$&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&@@&&&&&&$$$!';;;:'```''`````````````````'''''';;:|$$$$$$$$%$$$&@&&&&@@@#@@@@@@@@@@@@@@@@@@@&&@&$$$$$$$&&&@@@@##@%;''|&@@@@@@@#@@@@@@@%\n&$%%%%%%$$$$&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&@&&&@&&&$$$%;``'''``':'``````````````````'''':::;|$$$$$$$%$$$$&&&&&&@@@##@@@@@@@@@@@@@@@@@@&@&$$$&&&$$$&&&@@@@|:''':%@@@@@@@#@@@@@@@@%\n@@&$$$$$&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&@&&@@&&&$$$$%:``````';:'```...`````````````'''':;|$$$$$$%%$$$$&&&&&&&@@##@@#######@@#@@@@@@#@&$$&&&&&$%$$&&@@%:'::'!&@@@@&@@@@@@@@@@@%\n##@&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&@@&&&&&&&$$%:``````':;:```..``````````````''':;|$$$$$$%%$$$&&&&&&&@@@####################@&$$&&$$$$$$$|;|&$!''':;$&&&&&&@@@@@@@@@@@%\n##@&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&$&@&$&&&$&&&&&%'``````.``````....```````````'`'';|$&$$$%$$$$$$&&&&&@@@@@##################@$$$&&$$$$$|:':;%&$;''''|&&&&&&&&@@@@@@@@@@%\n##@&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&$%$&@@$$$$$&&&&&@@!````````.......````````````''`'':!%$&&&$$&&&&&&&&&&@@@#@@##############@@&$$$$&$$$$$$|:''|&&|''''!$&&&&&&@@@@@@@@@@@@%\n##@&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&|;%&$&@$$$$$$&&&&&@@&;..``..........````````````''``'';%$&&&&&&&&&&&&&&@@@@@##@############@@@$$$$&$!|$$$$!:':%@%:``':%&&@@@@@@@@@@@@@@@@@%\n##@&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&$!!$&&$&&$|!|%$$$&&&@@@@$:.........``'''``':;:'`````````':!%$&&&&&&&@&&&&&@@@@@@@#@@#########@@@&$$$%!!$$$$$%;'';$&!``':%@@@@@@@@@@@@@@@@@@@&%\n##@&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&|;%&&&&$%%$%!|%%$$$$&&@@@@@$;`.....`...````````````````````';|$&&&&&&&&@@@&&&@###@@@@#@&&##@@@@@&$$$$&&$$$$$$|'```!&%;|&&&&&@@@@@@@@@@@@@@@&&&&%\n###&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&%:|&&&&&$$||$&$|%%%$$&&&@@@@@@@@$;`........``'::'`...```'``````:|$$$&@@&$&@@@@@@&@#@@####@#&&#@$|%&$$%%&&$$$$%!'`.`:!$@@&&&&@@@@@@@@@@@@@@&&&&&&&&%\n###@&&&&&&&&&&&&&&&&&&&&&&&&&&|:!&&&&&&$$%||$&&$%%%$$&&&&@@@@@@@@@@&%:`.................`'````:!;;|$$$&&@@&&&&@@@@&&@########@!':|&$$%%$|;:;;!|%%%%||$@@&&&&&&&@&&&&&&&&&&&&&&&&&&&%\n###@&&&&&&&&&&&&&&&&&&&&&&$!:|&&&&&&&&$$%|%$&&&$%%%$&&&&&@@@@@@@@@@@@&&$;`..............``'';|!;;;;|%$$$$&@@@&&&@@&&$$&&@@@@##@&%||%%%$!:|%%%%%||%!|$@@@&&&&&&&&$$$$$$&&&&&&&&&&&&&%\n###@&&&&&&&&&&&&&&&&&&&|:!$&&&&&&&&&&$%%%%$$&&&$%%$$$$&&@#@@@@@@@@@@@&&&&&&|'...........``:!!;;;;;!!;|$&$%|&@@@&&&&&$!|$$$&@@#@@&%%%%$|'':!%%%%|!|$&&@@&&&&&&&$%%%%$$$$$&&$$$$$$&&&%\n###@&&&&&&&&&&&&&&&|:;%&&&&&&&&&&&&$$%%%%$$&&&&$$$$$$$$&@#@@@@@@@@@&&&&&&&&&&&&|'.....`;%%!!!!;;;!!!!;!%$$&$|%@@@@@&&@$;:::!|%$&$%%%$%:'``';!!|||%$&@@@&&&&&&$%%%%%%%$$$$$%%%%$$$$$|\n###@&&&&&&&&&$|:;%&&&&&&&&&&&&&&&$$%%$%%$&&&&&&$$$$%$$$&@@@@@@@@@##@&&&&&&&&&&&&&&%|%&&&&&$|;;;;;;;;;;;;!$&$&$|!%&@@@@@@&%;::!$$$$$$%;:```````;||||%$&&$$$$$$%|%%%%%%%$$$%%%%%%%%$%|\n###@&&$%|||$&&&&&&&&&&&&&&&&&&$$$$%%$$%$&&&&&&&$$$%%$$&&@@@@@@@@@@@##@&&&&&&&&&&&&&&&&&&&&@%;;;;;;;::;;;;!!$&&$$%!;|$$$&&&$&&&$$$$$%!|$&%:...`.`;|!|||!;!|||||||%%%%%%$%%%||||%%%%%|\n&&@@&&&&&&&&&&&&&&&&&&&&&&&$$$$$$%%$$%$&&&&&&&&$%%%%$$&&@@@@@@@@@@@@#@&@@&&&&&&&&&&&&&@###&%;;;;;;::::;;;!!!!|$$$&&%!:;!$&&&@&$$$&@&&&$%$&|``..'%#@@&$%%||||!;:'`';|%%$%%|||||||||||\n###@&&&&&&&&&&&&&&&&&&&&$$$$$$$$%%$&&$$&&&&&&&&$%%%%$$&&&@@@@@@@@@@@@@@&&&&@@@@@&&@####$;':!!;;;::::;;;;!;!;::::;%&&&&&$$$&@&$$$@@$$$$$&@@@@$%@#@@##@@&%%||||||||%%%|!'`:!||||||||||\n###@&&&&&&&&&&&&&&&&&$$$$$$$$$$$$$$$%%$$$$&&&&@$%%%%$$&&&&&@@@@@@@@@&&&&@@&&&&&&&@@@@|:':;;!!;;:::::::;;!!;:::::::::':::';$$$$$&&$&&&@@@&&@@@@@#######@@##@&%||||||||%%%%|!''!|||||!\n###@&&&&&&&&&&&&&&$$$$$$$$$$$&&$$$$$%%$$$$$&&&&&$%%$$$&&&&&$&&&@@@@&&&&&&&&&&&&@@@%:''':;;;;;:::::::::;;;:::::::::::::;;!%$$$$$|:::|$&&$&@@@@@&$&@#####@@@@####@&$%||%%%||||||;:!||!\n###@&&&&&&&&&&&$$$$$$$$$$$&&&&&$$&&$%%$$$&&&&&&&&$%$$$$$&&&&&&&@@@#@&&&&&&&&@##$;''''':;;;;;:::::::::;!;:::::::::::::::;%&$$$$|''':;%&%!;:'''':|%$&@@@@#@@&&&@##@&&@@$|%%|||||||!:;|\n:;$@@&&&&&&&$$$$$$$$$$$&&&&&&&&&$$&&$$&&&&&&&&&&&$%%$$$&&&&&&&&&&&&@@#######@|:'''''';!!!;::::::;;!!!!;::::::::::::::::|$$$$$!'::;!!%&|;;''''''''''';$&@@#@&&$$&@&&@#@@@#####@$%||;:\n''''':|$&$$$$$$$$$$&&&&&&&&&&&&&&$$&$$&&&&&&&&&&&&&$$$$$&&$$&&&&&@@@@@&$%$%|:''''''':;:::::::::::::;;:::::::::::::::::|$$$$$!::;;;;|&%;;:''''''''''''':!$&@@@&$$$$&################$\n'''''''''';%$$&&&&&&&&&&&&&&&&&&&&$$$$&&&&&&&&&&&&&&$$$$$&@@@@@###@&&$%;''''''''':::;;:::::::::::;;:::'':::::::::::':|$$$$$!::;:::|&%;;:''''''''''''''```:%&@@&&&$$$&##############$\n'''''''''''':':|&&&&&&&&&&&&&&&&&&&&$%$&&&&&&&&&&&&&&$$$$$&@@&@@@&$$%%!:''''''::::::!;::::::::::;;::::::::::::::''':|$$$$$|;;:::;%&|::'''''''''''''`.....``;$@@&&&&$$$&@###########$\n;:'''''''''''''':::!$&&&&&&&&&&&&&&&&&%|$&&&&&&&&&&&&&&$$$$&$$$$$$|:!|;':::::::::::;!;::::::::;;:::::::::::::''''':|$$$$$|;::::|&&|::'''''''''''``........`''!&@@&&&&$$$&@#########$\n.';;;;;:'''''''''''':::;%&@&&&&&&&&&&&&%$&&$$$$&&&&&&$&@&&&$$$$%!:::!|;::::::::::::!!;::::::!;::::::::::::::''''':|&$$$$|;::::|&%;;:'``''''''''````......````'!$@@&&&&&$$$&@#######$\n;;;:`.`:;;;;::'''''''''''':;%@@@&&&&&&&&$$$&&&&&&&&&&@@&!::':'':::::||;::::::::::::!!;:::;!!;;:::::::::::::::''':%&$$$$|;:::;%&|:::'`````````'''```..`...````''!$@@&&&&&&&$$&@#####$\n;;;;;;;;;'..';;;;::''''''''''':|@@@@&&&&&&$%$&&&&&&&@@%:::::::::::::!|;:::::''''''';!;:;!!;:::::::::::::::::''':%&$$$%|;:::|&%;;:'''```````'''''``...      ```''!&@&&&&&&&&&&&&@###$\n:::;;;;;;;;!;;;'':;;;;:'''''''''':!&@@@&&&&&$$&&&&@@@$;::::::::::::';|:``````````'';!;;;:'''```````````````''''|$$$$%|;::|&$!;;:'````````''::''``....      .``'':%@&&&&&&&&&&&&&&@#$\n::::::::;;;;;;;;;;;;:'':;;:''''''''':;%@@@@&&&&$&@@@$;''''''':''`''`:|;````````````:!!:'''``.........``......`!$%%%%|;;|&$!:;'`````````'''::''.     ..    `''``''!$&&@@&&&&&&&&&&&&%\n###@%!:::::::;;;;;;;;;;;;;;;;::'''''::::|&@@@&&&&&&%'```.....````''`'||'``````````';;'''``................. .!$%%%%|!%&$!:;:'``'''````'::::''.       ....``''``'''|@&&&@&&&@&&&&&&$|\n####@&&&@&|;::::::;;;;;;;;;;;;;;;:'''''''::!&@@@@@%:````......```'```;%;`````````''''``.................   .!$%%%%%$&%;:::''```'''```'::::'`.         ...``'```''';$@&&&@@&&&&&&&&&%\n####@&&&&&&&&&$!:::::::;;;;;;;;;;;;;:''''''':|@@@$;````.......``''```'!%;``````''''``.......      ....    .;%%%%%%$%;::'''`````''''`'::::`.             ...`````'''|@&&&&@@&&&&&&&&%\n####@&&&&&&&&&&&&&&|;::::::;;;;;;;;;;;;:::'':;;%&;````.........``'````:||:```':''`......                .`:|%%%%%|;::''''``````'''''::::`.               ....```'''!$@&&&&@@&&&&&&&%\n####@&&&&&&&&&&&&&&&&&&|::::::::;;;;;;;;;:::::;;'````..........``'`````:||:':''`......                .`'!$%%%%|;:''```````````'''''::;'.                 ......``':%@@&&&&&@&&&&&&%\n####@&&&&&&&&&&&&&&&&&&&&&$!:::::::;;;;;;;;;;;;'`````..........`''``````:||:''`.  .                .``!$&$%%%%%;'''`````````````'':::;;`                   .....```'!&@&&&&&&@&&&&&%\n####@&&&&&&&&&&&&&&&&&&&&&&&&&|;:::::;;;;;;;;;:``````...........''````':':|%!'.                .``'|$&|;|%|%%%!''````...`````````':::;;`                    .....```'|@&&&&&&&@&&&&%\n####@&&&&&&&&&&&&&&&&&&&&&&&&&&&$!::::::;;;;;:``````....``......''``':'''':!|%;..         ..``:|%$|;::;|%||%%!'`````......```''`'':::;:'   .......           ....````:%@&&&&&&@@&&&%\n####@&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&%;:::::;;:```````....`.   ...`'':''`.  .':!||;````````';|%%|;::::';|%||%%;'```.........```'''''::::;'. ....````........  ......````:%@&&&&&&@@&&%\n####@&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&|:::::'```````...``.   ..'::'``.   .```':;!||!;;!||!;::::''``';|%||%|;'```..........```'''''::::;:.....``````````...........`````;&&&&&&&@@@&%\n*/\n\nint n;\nint a[105];\nconst int Mod=1'000'000'007;\n\nint ksmii(int a,int b){\n\tif(!b){\n\t\treturn 1;\n\t}\n\tint ff=ksmii(a,b>>1);\n\tff=1LL*ff*ff%Mod;\n\tif(b&1){\n\t\tff=1LL*ff*a%Mod;\n\t}\n\treturn ff;\n}\n\npair<int,int> solve(int l,int r,int lim){\n\tint minx=Mod,cnt;\n\tfor(int i=l;i<=r;i++){\n\t\tif(a[i]<minx){\n\t\t\tminx=a[i];\n\t\t\tcnt=1;\n\t\t}else if(a[i]==minx){\n\t\t\tcnt++;\n\t\t}\n\t}\n\tif(cnt==r-l+1){\n\t\treturn make_pair((ksmii(2,r-l+1)-2+Mod)%Mod,ksmii(2,minx-lim-1));\n\t}\n\tpair<int,int> ans;\n\tint L=-1,rem=r-l+1;\n\tint x1=1,x2=1;\n\tfor(int i=l;i<=r+1;i++){\n\t\tif(L==-1&&a[i]>minx){\n\t\t\tL=i;\n\t\t}else if(L!=-1&&a[i]<=minx){\n\t\t\trem-=i-L;\n\t\t\tpair<int,int> tmp=solve(L,i-1,minx);\n\t\t\tx1=1LL*x1*(tmp.first+4LL*tmp.second%Mod)%Mod;\n\t\t\tx2=2LL*x2*tmp.second%Mod;\n\t\t\tL=-1;\n\t\t}\n\t}\n\tx1=(x1-x2+Mod)%Mod;\n\tans.first=((1LL*x1*ksmii(2,rem)%Mod)+(1LL*x2*((ksmii(2,rem)-2+Mod)%Mod)%Mod))%Mod;\n\tans.second=1LL*x2*ksmii(2,minx-lim-1)%Mod;\n\treturn ans;\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d\",a+i);\n\t}\n\tif(n==1){\n\t\tprintf(\"%d\\n\",ksmii(2,a[1]));\n\t\treturn 0;\n\t}\n\tint peak=1;\n\tfor(int i=1;i<=n;i++){\n\t\tif(a[i]>a[i-1]&&a[i]>a[i+1]){\n\t\t\tpeak=1LL*peak*ksmii(2,a[i]-max(a[i-1],a[i+1]))%Mod;\n\t\t\ta[i]=max(a[i-1],a[i+1]);\n\t\t}\n\t}\n\tpair<int,int> ans=solve(1,n,0);\n\tprintf(\"%lld\\n\",1LL*peak*((ans.first+2LL*ans.second%Mod)%Mod)%Mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <utility>\n#include <cstdio>\n#define MOD 1000000007\ntypedef long long ll;\ninline ll quick_pow(ll a, int n)\n{\n\tll res = 1;\n\twhile (n)\n\t{\n\t\tif (n & 1)\n\t\t\tres = res * a % MOD;\n\t\ta = a * a % MOD;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\nint arr[105];\nstd::pair<int, int> work(int l, int r, int d)\n{\n\tint pos = l;\n\tfor (int i = l; i <= r; i++)\n\t{\n\t\tif (arr[i] < arr[pos])\n\t\t\tpos = i;\n\t}\n\tll val = quick_pow(2, arr[pos] - d);\n\tif (l == r)\n\t\treturn {val, val};\n\tif (pos == l)\n\t{\n\t\tauto res = work(l + 1, r, arr[pos]);\n\t\treturn {(2 * res.first + (val - 1) * res.second) % MOD, val * res.second % MOD};\n\t}\n\tif (pos == r)\n\t{\n\t\tauto res = work(l, r - 1, arr[pos]);\n\t\treturn {(2 * res.first + (val - 1) * res.second) % MOD, val * res.second % MOD};\n\t}\n\tauto x = work(l, pos - 1, arr[pos]), y = work(pos + 1, r, arr[pos]);\n\treturn {4ll * x.first % MOD * y.first % MOD + (val - 1) * x.second % MOD * y.second % MOD\n\t\t, val * x.second % MOD * y.second % MOD};\n}\nint main()\n{\n\t// freopen(\"AGC026-D.in\", \"r\", stdin);\n\tint n; \n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", arr + i);\n\t\tarr[i]--;\n\t}\n\tprintf(\"%d\\n\", work(0, n - 1, 0).first * 2 % MOD);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nDé¢˜ï¼š\nç»™å®šnåˆ—çš„æ–¹å—\nç¬¬iåˆ—é«˜åº¦hi\nçŽ°åœ¨è¦æŠŠå®ƒæŸ“æˆçº¢è“ä¸¤è‰²\nè¦æ±‚æ»¡è¶³ï¼š\nå¯¹äºŽä»»æ„ä¸€ä¸ª2*2çš„åŒºåŸŸï¼Œæ°æœ‰2ä¸ªè“è‰²ï¼Œ2ä¸ªçº¢è‰²\né—®æ–¹æ¡ˆæ•°\nn<=100,h<=10^9\n*/\n#include<bits/stdc++.h>\n#define rep(i,a,b) for (int i=(a); i<=(b); i++)\n#define per(i,a,b) for (int i=(a); i>=(b); i--)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> pii;\n\nconst int maxn = 105;\nconst int MOD = 1000000007;\nint h[maxn], f[maxn][3];\nint n, mx, res, base = 1;\n\ninline int power(int x, int p) {\n\tint res = 1;\n\twhile (p) {\n\t\tif (p & 1) res = 1LL * res * x % MOD;\n\t\tx = 1LL * x * x % MOD; p >>= 1;\n\t}\n\treturn res;\n}\n\npii solve(int l, int r, int base) {\n\t// printf(\"%d %d %d\\n\", l, r, base);\n\tint mn = MOD, cnt = 0;\n\tpii res = make_pair(0, 0), sub;\n\trep (i, l, r)\n\t\tif (h[i] < mn) mn = h[i], cnt = 1;\n\t\telse if (h[i] == mn) cnt++;\n\tif (cnt == r - l + 1) {\n\t\tres.first = (power(2, r - l + 1) + MOD - 2) % MOD;\n\t\tres.second = power(2, mn - base - 1);\n\t\t//printf(\"%d %d %d  %d %d\\n\", l, r, base, res.fi, res.se);\n\t\treturn res;\n\t}\n\tint remain = r - l + 1, last = 0, tmp = 1;\n\tint res0 = 1, res1 = 1;\n\trep (i, l, r + 1)\n\t\tif (!last && h[i] > mn) last = i;\n\t\telse if (last && (i > r || h[i] == mn)) {\n\t\t\tremain -= i - last;\n\t\t\tsub = solve(last, i - 1, mn);\n\t\t\tres0 = 1LL * res0 * (sub.fi + 4LL * sub.se) % MOD;\n\t\t\tres1 = 2LL * res1 * sub.se % MOD;\n\t\t\tlast = 0;\n\t\t}\n\tres0 = (res0 + MOD - res1) % MOD;\n\tres.fi = 1LL * res0 * power(2, remain) % MOD;\n\tres.fi = (res.fi + 1LL * res1 * (power(2, remain) + MOD - 2)) % MOD;\n\tres.se = 1LL * res1 * power(2, mn - base - 1) % MOD;\n\t//printf(\"%d %d %d  %d %d\\n\", l, r, base, res.fi, res.se);\n\treturn res;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\trep (i, 1, n) scanf(\"%d\", &h[i]);\n\tif (n==1){\n\t\tprintf(\"%d\\n\",power(2,h[1]));\n\t\treturn 0;\n\t}\n\trep (i, 1, n)\n\t\tif (h[i] > h[i-1] && h[i] > h[i+1]) {\n\t\t\tbase = 1LL * base * power(2, h[i] - max(h[i-1], h[i+1])) % MOD;\n\t\t\th[i] = max(h[i-1], h[i+1]);\n\t\t}\n\tpii tmp = solve(1, n, 0);\n\tres = 1LL * base * (tmp.fi + 2LL * tmp.se) % MOD;\n\tprintf(\"%d\\n\", res);\n\treturn 0;\n}\n\n/*\n#include<bits/stdc++.h>\n#define rep(i,a,b) for (int i=(a); i<=(b); i++)\n#define per(i,a,b) for (int i=(a); i>=(b); i--)\n#define add(a,b) (a+b>=MOD?a+=b-MOD:a+=b)\nusing namespace std;\ntypedef long long LL;\n\nconst int maxn = 105;\nconst int MOD = 1000000007;\nint h[maxn], f[maxn][3];\nint n, mx, res, base = 1;\n\ninline int power(int x, int p) {\n\tint res = 1;\n\twhile (p) {\n\t\tif (p & 1) res = 1LL * res * x % MOD;\n\t\tx = 1LL * x * x % MOD; p >>= 1;\n\t}\n\treturn res;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\trep (i, 1, n) scanf(\"%d\", &h[i]);\n\trep (i, 1, n)\n\t\tif (h[i] > h[i-1] && h[i] > h[i+1]) {\n\t\t\tbase = 1LL * base * power(2, h[i] - max(h[i-1], h[i+1]));\n\t\t\th[i] = max(h[i-1], h[i+1]);\n\t\t}\n\trep (i, 1, n) mx = max(mx, h[i]);\n\tres = power(2, mx + 1);\t\t//æ²¡æœ‰ç›¸é‚»çš„ç›¸åŒçš„case\n\tint t = 0;\n\trep (i, 1, n) {\t\t\t\t//æžšä¸¾ç›¸åŒçš„æœ€å¤§å€¼\n\t\tmemset(f, 0, sizeof f);\n\t\tf[0][0] = 1;\n\t\trep (j, 1, n)\t\t\t//åˆ†ä¸‰ç§æƒ…å†µè®¨è®º\n\t\t\tif (j < i) {\n\t\t\t\tadd(f[j][0], f[j-1][0]);\n\t\t\t\tif (h[j] <= h[i]) \n\t\t\t\t\tadd(f[j][1], f[j-1][0]);\n\t\t\t\t\n\t\t\t\tif (h[j] <= h[i])\n\t\t\t\t\tadd(f[j][2], f[j-1][1]);\n\t\t\t\t\n\t\t\t\tadd(f[j][0], f[j-1][2]);\n\t\t\t\tif (h[j] <= h[i]) {\n\t\t\t\t\tadd(f[j][1], f[j-1][2]);\n\t\t\t\t\tadd(f[j][2], f[j-1][2]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (j > i) {\n\t\t\t\tadd(f[j][0], f[j-1][0]);\n\t\t\t\tif (h[j] < h[i]) \n\t\t\t\t\tadd(f[j][1], f[j-1][0]);\n\t\t\t\t\n\t\t\t\tif (h[j] < h[i])\n\t\t\t\t\tadd(f[j][2], f[j-1][1]);\n\t\t\t\t\n\t\t\t\tadd(f[j][0], f[j-1][2]);\n\t\t\t\tif (h[j] < h[i]) {\n\t\t\t\t\tadd(f[j][1], f[j-1][2]);\n\t\t\t\t\tadd(f[j][2], f[j-1][2]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tadd(f[j][1], f[j-1][0]);\n\t\t\t\tadd(f[j][2], f[j-1][1]);\n\t\t\t\tadd(f[j][1], f[j-1][2]);\n\t\t\t\tadd(f[j][2], f[j-1][2]);\n\t\t\t}\n\t\tint tmp = (f[n][0] + f[n][2]) % MOD;\n\t\tt = (t + tmp) % MOD;\n\t\tprintf(\"%d %d\\n\", i, tmp);\n\t\tres = (res + 1LL * tmp * power(2, mx - h[i] + 1)) % MOD;\n\t}\n\tprintf(\"%d\\n\", t);\n\tres = 1LL * res * base % MOD;\n\tprintf(\"%d\\n\", res);\n\treturn 0;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cstring>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define TRACE(x) cout << #x << \" = \" << x << endl\n#define _ << \" _ \" <<\n\ntypedef long long llint;\n\nconst int mod = 1e9 + 7;\n\ninline int add(int a, int b) {\n  return a+b >= mod ? a+b-mod : a+b;\n}\n\ninline int sub(int a, int b) {\n  return a >= b ? a-b : a-b+mod;\n}\n\ninline int mul(int a, int b) {\n  return llint(a)*b % mod;\n}\n\nint powmod(int a, llint b) {\n  if (b == 0) return 1;\n  if (b&1) return mul(a, powmod(a, b-1));\n  return powmod(mul(a, a), b/2);\n}\n\nconst int MAX = 110;\n\nint h[MAX], pw[MAX];\n\npair<int, int> solve(int a, int b, int s) {\n\n  assert(b - a > 1);\n  int m = *min_element(h + a, h + b);\n\n  vector<pair<int, int>> v;\n  int i = a;\n  while (i < b) {\n    int j = i;\n    while (j < b && (h[i] == m) == (h[j] == m)) j++;\n    v.push_back({i, j});\n    i = j;\n  }\n\n  int f0 = 0, f1 = 1;\n  bool first = true;\n  for (auto& p: v) {\n    int x = p.first, y = p.second;\n    if (h[x] != m) {\n      if (y - x > 1) {\n        auto g = solve(x, y, m);\n        if (first) {\n          f1 = mul(2, g.first);\n          f0 = g.second;\n        } else {\n          f0 = mul(f0, add(mul(4, g.first), g.second));\n          f0 = add(f0, mul(mul(2, f1), mul(2, g.first)));\n          f0 = add(f0, mul(mul(2, f1), g.second));\n          f1 = mul(f1, mul(2, g.first));\n        }\n      } else {\n        if (first) {\n          f0 = 0;\n          f1 = powmod(2, h[x] - m);\n        } else {\n          f0 = mul(f0, 2);\n          f0 = add(f0, mul(2, f1));\n          f0 = mul(f0, powmod(2, h[x] - m));\n          f1 = mul(f1, powmod(2, h[x] - m));\n        }\n      }\n    } else {\n      if (first) {\n        f0 = sub(pw[y - x], 2);\n        f1 = 1;\n      } else {\n        f0 = mul(f0, pw[y - x]);\n        f0 = add(f0, mul(mul(2, f1), sub(pw[y - x], 1)));\n      }\n    }\n    first = false;\n  }\n\n  int good_ways = powmod(2, m - s - 1);\n\n  f1 = mul(f1, good_ways);\n\n  return {f1, f0};\n}\n\nint main(void) {\n  int N;\n  scanf(\"%d\", &N);\n  REP(i, N) scanf(\"%d\", &h[i]);\n\n  pw[0] = 1;\n  REP(i, N) pw[i + 1] = mul(pw[i], 2);\n\n  auto g = solve(0, N, 0);\n\n  int ret = add(mul(2, g.first), g.second);\n  printf(\"%d\\n\", ret);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<bitset>\nusing namespace std;\nint p = 1000000007;\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(long long i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp make_pair\n#define pin pair<int,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define sq(a) (a)*(a)\n#define rev(s) reverse(s.begin(),s.end())\n#define end_program(s) cout << s <<endl;return 0\n#define itn int\nint kai_size = 1000001;\nvel kai(kai_size, 1);\nvel ink(kai_size, 1);\nvel dist;\nint RE() {\n\tvel v(3, 2);\n\treturn v.at(4); \n}\nint ru(int a, int r) {\n\tif (r == 0) { return 1; }\n\tint ans = ru(a, r / 2);\n\tans *= ans; ans %= p;\n\tif (r % 2 == 1) { ans *= a; }\n\treturn ans % p;\n}\nint inv(int a) {\n\treturn ru(a, p - 2);\n}\nvoid make_kai() {\n\trep(i, kai_size-1) { kai[i + 1] = (kai[i] * (i + 1)) % p; }\n\trep(i, kai_size) { ink[i] = inv(kai[i]); }\n}\nint com(int n, int r) {\n\tif (r < 0 || n < r) { return 0; }\n\tint ans = kai[n] * ink[r];\n\tans %= p; ans *= ink[n - r]; ans %= p;\n\treturn ans;\n}\nvel dis(int mid1, vvel &way) {\n\tint n = way.size();\n\tvel dist(n, -1); dist[mid1] = 0;\n\tqueue<int> q;\n\tq.push(mid1);\n\twhile (!q.empty()) {\n\t\tint st = q.front(); q.pop();\n\t\trep(i, way[st].size()) {\n\t\t\tint to = way[st][i];\n\t\t\tif (dist[to] == -1) {\n\t\t\t\tdist[to] = dist[st] + 1;\n\t\t\t\tq.push(to);\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\npin most_far(int now, int n, vvel &way) {\n\tvel dist1 = dis(now, way);\n\tpin ans = mkp(-1, 0);\n\trep(i, n) {\n\t\tif (dist1[i] > ans.first) { ans = mkp(dist1[i], i); }\n\t}\n\treturn ans;\n}\n\nint per(int a, int b) {\n\tint ans = a % b;\n\tif (ans < 0) { ans += b; }\n\treturn ans;\n}\nvel uni(vel &v) {\n\tsor(v);\n\tvel ans(1, v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tif (v[i] != v[i-1]) { ans.push_back(v[i]); }\n\t}\n\tv = ans;\n\treturn v;\n}\nint s_gcd(int a, int b) {\n\tif (b == 0) { return a; }\n\treturn s_gcd(b, a%b);\n}\nint gcd(int a, int b) {\n\tif (a < b) { swap(a, b); }\n\treturn s_gcd(a, b);\n}\nbool is_prime(int i) {\n\tfor (int j = 2; j*j <= i; j++) {\n\t\tif (i%j == 0) { return false; }\n\t}\n\treturn true;\n}\nint get(int i, int j, vvel &ans) {\n\tint n = ans.size();\n\tif (i < 0 || n <= i || j < 0 || n <= j) { return 1; }\n\treturn ans[i][j];\n}\nint lcm(int a, int b) {\n\treturn a * b / gcd(a, b);\n}\nvvel make_sep(vel h, int min1) {\n\tvel is_zero(1, -1);\n\trep(i,h.size()) { \n\t\th[i] -= min1; \n\t\tif (h[i] == 0) { is_zero.push_back(i); }\n\t}\n\tis_zero.push_back(h.size());\n\tint sz = is_zero.size() - 1;\n\tvvel ans(sz);\n\trep(i, sz) {\n\t\tint st = is_zero[i];\n\t\tint to = is_zero[i + 1];\n\t\tfor (int j = st + 1; j < to; j++) {\n\t\t\tans[i].push_back(h[j]);\n\t\t}\n\t}\n\treturn ans;\n}\nint solve2(vel h) {//一個交互が有った時の値\n\tint n = h.size();\n\tif (n == 0) { return 1; }\n\tint min1 = h[0];\n\trep(i, n) {\n\t\tmmin(min1, h[i]);\n\t}\n\tvvel x = make_sep(h, min1);\n\tint ans2 = ru(2, min1);\n\trep(i, x.size()) {\n\t\tans2 *= solve2(x[i]);\n\t\tans2 %= p;\n\t}\n\treturn ans2;\n}\nint solve1(vel h) {//全部の下の組み合わせに対して足す。\n\tint n = h.size();\n\tif (n == 0) { return 1; }\n\tint min1 = h[0];\n\trep(i, n) {\n\t\tmmin(min1, h[i]);\n\t}\n\tvvel x = make_sep(h, min1);\n\tint ans1 = 1;\n\tint ex = n;\n\tint ans2 = ru(2, min1+1) + p - 2; ans2 %= p;\n\trep(i, x.size()) {\n\t\tans1 *= solve1(x[i]);\n\t\tans1 %= p;\n\t\tans2 *= solve2(x[i]);\n\t\tans2 %= p;\n\t\tex -= x[i].size();\n\t}\n\tans1 *= ru(2, ex);\n\treturn (ans1 + ans2) % p;\n}\nint solve(vel h) {\n\tint n = h.size();\n\tint min1 = h[0];\n\trep(i, n) {\n\t\tmmin(min1, h[i]);\n\t}\n\tvvel x = make_sep(h, min1);\n\tint ans1 = 1;\n\tint ex = n;\n\tint ans2 = ru(2, min1) + p - 2; ans2 %= p;\n\trep(i, x.size()) {\n\t\tans1 *= solve1(x[i]);\n\t\tans1 %= p;\n\t\tans2 *= solve2(x[i]);\n\t\tans2 %= p;\n\t\tex -= x[i].size();\n\t}\n\tans1 *= ru(2, ex);\n\treturn (ans1 + ans2) % p;\n}\nsigned main() {\n\tint n; cin >> n;\n\tvel h(n); rep(i, n) { cin >> h[i]; }\n\tcout << solve(h) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;const int mod=1000000007;typedef pair<long long,long long> pii;int h[105];\ninline int qpow(int a,int b) {int rtv=1;for (;b;b>>=1,a=1LL*a*a%mod) if (b&1) rtv=1LL*rtv*a%mod;return rtv;}\ninline pii dac(int l,int r,int bnd) {long long mn=1e18,cnt=0,rem=r-l+1,ans0=1,ans1=1;pii _;\n\tfor (int i=l;i<=r;++i) if (h[i]<mn) mn=h[i],cnt=1;else if (h[i]==mn) ++cnt;\n\tif (cnt==r-l+1) return make_pair((qpow(2,r-l+1)+mod-2)%mod,qpow(2,mn-bnd-1));\n\tfor (int i=l,j=0;i<=r+1;++i) if (!j&&h[i]>mn) j=i;\n\t\telse if (j&&(h[i]==mn||i>r)) {rem-=i-j,_=dac(j,i-1,mn),j=0;\n\t\t\tans0=1LL*ans0*(_.first+(4LL*_.second%mod)%mod)%mod,ans1=1LL*ans1*(_.second<<1)%mod;\n\t\t}ans0=(ans0-ans1+mod)%mod;\n\treturn make_pair((1LL*ans0*qpow(2,rem)%mod+1LL*ans1*(qpow(2,rem)+mod-2)%mod)%mod,1LL*ans1*qpow(2,mn-bnd-1)%mod);\n}int main() {int n,prod=1;pii _;scanf(\"%d\",&n);for (int i=1;i<=n;++i) scanf(\"%d\",h+i);\n\tif (n<2) return 0*printf(\"%d\",qpow(2,h[1]));\n\tfor (int i=1;i<=n;++i) if (h[i]>h[i-1]&&h[i]>h[i+1])\n\t\tprod=1LL*prod*qpow(2,h[i]-max(h[i-1],h[i+1]))%mod,h[i]=max(h[i-1],h[i+1]);\n\t_=dac(1,n,0);printf(\"%lld\",1LL*prod*((_.first+_.second+_.second)%mod)%mod);return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Hacheylight\n#include <map>\n#include <set>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <vector>\n#include <bitset>\n#include <cstdio>\n#include <cctype>\n#include <string>\n#include <numeric>\n#include <cstring>\n#include <cassert>\n#include <climits>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\n#include <functional>\nusing namespace std ;\n//#define int long long\n#define rep(i, a, b) for (int i = (a); i <= (b); i++)\n#define per(i, a, b) for (int i = (a); i >= (b); i--)\n#define loop(it, v) for (auto it = v.begin(); it != v.end(); it++)\n#define cont(i, x) for (int i = head[x]; i; i = e[i].nxt)\n#define clr(a) memset(a, 0, sizeof(a))\n#define ass(a, sum) memset(a, sum, sizeof(a))\n#define lowbit(x) (x & -x)\n#define all(x) x.begin(), x.end()\n#define SC(t, x) static_cast <t> (x)\n#define ub upper_bound\n#define lb lower_bound\n#define pqueue priority_queue\n#define mp make_pair\n#define pb push_back\n#define pof pop_front\n#define pob pop_back\n#define fi first\n#define se second\n#define y1 y1_\n#define Pi acos(-1.0)\n#define iv inline void\n#define enter cout << endl\n#define siz(x) ((int)x.size())\n#define file(x) freopen(x\".in\", \"r\", stdin),freopen(x\".out\", \"w\", stdout)\ntypedef double db ;\ntypedef long long ll ;\ntypedef unsigned long long ull ;\ntypedef pair <int, int> pii ;\ntypedef vector <int> vi ;\ntypedef vector <pii> vii ;\ntypedef queue <int> qi ;\ntypedef queue <pii> qii ;\ntypedef set <int> si ;\ntypedef map <int, int> mii ;\ntypedef map <string, int> msi ;\nconst int N = 110 ;\nconst int INF = 0x3f3f3f3f ;\nconst int iinf = 1 << 30 ;\nconst ll linf = 2e18 ;\nconst int MOD = 1000000007 ;\nconst double eps = 1e-7 ;\nvoid douout(double x){ printf(\"%lf\\n\", x + 0.0000000001) ; }\ntemplate <class T> void print(T a) { cout << a << endl ; exit(0) ; }\ntemplate <class T> void chmin(T &a, T b) { if (a > b) a = b ; }\ntemplate <class T> void chmax(T &a, T b) { if (a < b) a = b ; }\ntemplate <class T> void add(T &a, T b) { a = (1ll * a + b) % MOD ; }\ntemplate <class T> void sub(T &a, T b) { a = (a - b + MOD) % MOD ; }\ntemplate <class T> void mul(T &a, T b) { a = (ll) a * b % MOD ; }\ntemplate <class T> T read() {\n    int f = 1 ; T x = 0 ;\n    char ch = getchar() ;\n    while (!isdigit(ch)) { if (ch == '-') f = -1 ; ch = getchar() ; }\n    while (isdigit(ch)) { x = x * 10 + ch -'0' ; ch = getchar() ; }\n    return x * f ;\n}\n\n\nint pw(int a, int b) {\n\tint s = 1 ;\n\tfor (; b; b >>= 1, a = (ll) a * a % MOD)\n\tif (b & 1) s = (ll) s * a % MOD ;\n\treturn s ;\n}\n\nint n ;\nint h[N] ;\n\npii solve(int l, int r, int lim) {\n\tint mi = iinf, cnt = 0 ; pii ans ;\n\trep(i, l, r) if (h[i] < mi) mi = h[i], cnt = 1 ;\n\telse if (h[i] == mi) cnt++ ;\n\tif (cnt == r - l + 1) {\n\t\tans.fi = (pw(2, r - l + 1) - 2 + MOD) % MOD ;\n\t\tans.se = pw(2, mi - lim - 1) ;\n\t\treturn ans ;\n\t}\n\tint rst = r - l + 1, s0 = 1, s1 = 1, lst = 0 ;\n\trep(i, l, r + 1)\n\tif (!lst && h[i] > mi) lst = i ;\n\telse if (lst && (h[i] <= mi || i > r)) {\n\t\trst -= i - lst ;\n\t\tpii tmp = solve(lst, i - 1, mi) ;\n\t\tmul(s0, (int) (tmp.first + 4ll * tmp.se % MOD) % MOD) ;\n\t\tmul(s1, (int) (2ll * tmp.se % MOD) % MOD) ;\n\t\tlst = 0 ;\n\t}\n\tsub(s0, s1) ;\n\tans.fi = (ll) s0 * pw(2, rst) % MOD ;\n\tadd(ans.fi, (int) ((ll) s1 * (pw(2, rst) % MOD - 2 + MOD) % MOD) % MOD) ;\n\tans.se = (ll) s1 * pw(2, mi - lim - 1) % MOD ;\n\treturn ans ;\n}\n\n\nsigned main() {\n\tscanf(\"%d\", &n) ;\n\trep(i, 1, n) scanf(\"%d\", &h[i]) ;\n\tif (n == 1) print(pw(2, h[1])) ;\n\tint peak = 1 ;\n\trep(i, 1, n)\n\tif (h[i] > h[i - 1] && h[i] > h[i + 1]) {\n\t\tmul(peak, pw(2, h[i] - max(h[i - 1], h[i + 1]))) ;\n\t\th[i] = max(h[i - 1], h[i + 1]) ;\n\t}\n\tpii ans = solve(1, n, 0) ;\n\tprintf(\"%lld\\n\", (ll) peak * (ans.fi + 2ll * ans.se % MOD) % MOD) ;\n\n\treturn 0 ;\n}\n\n/*\n写代码时请注意：\n\t1.ll？数组大小，边界？数据范围？\n\t2.精度？\n\t3.特判？\n\t4.至少做一些\n思考提醒：\n\t1.最大值最小->二分？\n\t2.可以贪心么？不行dp可以么\n\t3.可以优化么\n\t4.维护区间用什么数据结构？\n\t5.统计方案是用dp？模了么？\n\t6.逆向思维？\n*/\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\n\nconst ll big = 1000000007;\nconst ll mod = 998244353;\n\nll n,m,k,T;\n\nvl A;\n\nll getv(ll i){\n    if(i == -1)return 0;\n    if(i == n)return 0;\n    assert(i >= 0 && i < n);\n    return A[i];\n}\n\nll upp(ll i, ll j){\n    if(j == 0)return 1;\n    ll h = upp(i,j/2);\n    if(j%2 == 0)return (h*h)%big;\n    return (((h*h)%big)*i)%big;\n}\n\nvl heights;\nset<ll> S;\n\nll upto(ll i, ll j){\n    if(j == 0){\n        return (upp(2,A[i])-2+big)%big;\n    }\n    return (upp(2,A[i]-heights[j]+1)-2+big)%big;\n}\n\nll horisontal(ll i, ll j){\n    if(heights[j] >= A[i])return 0;\n    ll d1 = A[i]-heights[j];\n    ll d2 = A[i]-heights[j+1];\n    return (upto(i,j)-upto(i,j+1)+big)%big;\n}\n\n\nunordered_map<ll,ll> M;\n\nll dp(ll i, ll horisont, bool vertical){\n    if(i == n)return 1;\n    ll h = 2*(i*1234567891+horisont) + vertical;\n    if(M.find(h) != M.end())return M[h];\n\n    ll ans = 0;\n    if(A[i] == 0){\n        return dp(i+1,0,1);\n    }\n    if(vertical){\n        ans += 2*dp(i+1,A[i],1);\n        if(A[i] > horisont){\n            for(int c1 = 0; c1 < sz(heights); c1++){\n                if(heights[c1] < horisont)continue;\n                ans += horisontal(i,c1)*dp(i+1,heights[c1],0);\n\n            }\n        }\n    }\n    if(!vertical){\n        if(horisont >= A[i]){\n            ans = 2*dp(i+1,A[i],1);\n        }\n        else{\n            ll d = max(A[i]-getv(i-1),0ll);\n            ans = upp(2,d)*dp(i+1,horisont,0);\n        }\n    }\n\n    ans %= big;\n    M[h] = ans;\n    return ans;\n}\n\nint main(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    //freopen(\"input.txt\",\"r\",stdin);\n    //freopen(\"autput.txt\",\"w\",stdout);\n    ll a,b,c,d;\n    cin >> n;\n    ll ans = 1;\n    for(int c1 = 0; c1 < n; c1++){\n        cin >> a;\n        if(a == 1){\n            a = 0;\n            ans *= 2;\n            ans %= big;\n        }\n        A.push_back(a);\n    }\n\n    for(int c1 = 0; c1 < n; c1++){\n        d = max(A[c1] - max(getv(c1-1),getv(c1+1)),0ll);\n        ans *= upp(2,d);\n        ans %= big;\n        A[c1] -= d;\n    }\n    heights.push_back(0);\n    S.insert(0);\n    for(int c1 = 0; c1 < n; c1++){\n        if(S.find(A[c1]) == S.end()){\n            S.insert(A[c1]);\n            heights.push_back(A[c1]);\n        }\n    }\n    sort(all(heights));\n/*\n    cerr << \"h: \" << horisontal(1,0) << \" \" << horisontal(1,1) << \"\\n\";\n\n    cout << ans << \"\\n\";\n    for(int c1 = 0; c1 < n; c1++){\n        cout << A[c1] << \" \";\n    }cout << \"\\n\";\n    cerr << dp(5,0,1) << \"  jk\\n\";\n    */\n    ans *= dp(0,0,1);\n    cout << ans%big << \"\\n\";\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100, mod = 1000000007, inf = 0x3f3f3f3f;\nint n, h[maxn + 10], ans;\nint f[maxn + 10][maxn + 10][2][2][2], tmp[2][2][2];\nint add(int x, int y) {\n\tx += y; return x < mod ? x : x - mod;\n}\nint dec(int x, int y) {\n\tx -= y; return x < 0 ? x + mod : x;\n}\nint mul(int x, int y) {\n\treturn 1ll * x * y % mod;\n}\nint fpow(int x, int y) {\n\tint ans = 1;\n\twhile (y) {\n\t\tif (y & 1) ans = mul(ans, x);\n\t\ty >>= 1; x = mul(x, x);\n\t}\n\treturn ans;\n}\n\nint calcmin(int l, int r) {\n\tint ans = inf;\n\tfor (int i = l; i <= r; ++i) ans = min(ans, h[i]);\n\treturn ans;\n}\n\nvoid upd(int l, int r, int h) {\n\tfor (int i = 0; i < 2; ++i)\n\t\tfor (int j = 0; j < 2; ++j)\n\t\t\tfor (int k = 0; k < 2; ++k)\n\t\t\t\ttmp[i][j][k] = 0;\n\tfor (int i = 0; i < 2; ++i)\n\t\tfor (int j = 0; j < 2; ++j) {\n\t\t\tif (h) {\n\t\t\t\ttmp[i][j][0] = add(tmp[i][j][0], mul(f[l][r][i][j][0], fpow(2, h - 1)));\n\t\t\t\ttmp[j][i][0] = add(tmp[j][i][0], mul(f[l][r][i][j][0], fpow(2, h - 1)));\n\t\t\t} else tmp[i][j][0] = add(tmp[i][j][0], f[l][r][i][j][0]);\n\t\t\tif (h & 1) tmp[j][i][1] = add(tmp[j][i][1], f[l][r][i][j][1]);\n\t\t\telse tmp[i][j][1] = add(tmp[i][j][1], f[l][r][i][j][1]);\n\t\t}\n\tfor (int i = 0; i < 2; ++i)\n\t\tfor (int j = 0; j < 2; ++j)\n\t\t\tfor (int k = 0; k < 2; ++k)\n\t\t\t\tf[l][r][i][j][k] = tmp[i][j][k];\n}\n\nvoid merge(int l, int r, int ll, int rr) {\n\tfor (int i = 0; i < 2; ++i)\n\t\tfor (int j = 0; j < 2; ++j)\n\t\t\tfor (int k = 0; k < 2; ++k)\n\t\t\t\ttmp[i][j][k] = 0;\n\tfor (int i = 0; i < 2; ++i)\n\t\tfor (int j = 0; j < 2; ++j)\n\t\t\tfor (int k = 0; k < 2; ++k)\n\t\t\t\tfor (int s = 0; s < 2; ++s)\n\t\t\t\t\tfor (int p = 0; p < 2; ++p)\n\t\t\t\t\t\tfor (int q = 0; q < 2; ++q) {\n\t\t\t\t\t\t\tint st = i, ed = p, t = k || q || (j == s);\n\t\t\t\t\t\t\ttmp[st][ed][t] = add(tmp[st][ed][t], mul(f[l][r][i][j][k], f[ll][rr][s][p][q]));\n\t\t\t\t\t\t}\n\tfor (int i = 0; i < 2; ++i)\n\t\tfor (int j = 0; j < 2; ++j)\n\t\t\tfor (int k = 0; k < 2; ++k)\n\t\t\t\tf[l][r][i][j][k] = tmp[i][j][k];\n}\n\nvoid dp(int l, int r) {\n\tif (l == r) {\n\t\tf[l][r][0][0][0] = f[l][r][1][1][0] = 1;\n\t} else {\n\t\tint minv = calcmin(l, r);\n\t\tint lst = l - 1;\n\t\tvector<pair<int, int> > vec;\n\t\tfor (int i = l; i <= r; ++i)\n\t\t\tif (h[i] == minv) {\n\t\t\t\tif (lst + 1 <= i - 1) vec.push_back(make_pair(lst + 1, i - 1));\n\t\t\t\tvec.push_back(make_pair(i, i)); lst = i;\n\t\t\t}\n\t\tif (lst < r) vec.push_back(make_pair(lst + 1, r));\n\t\tfor (int i = 0; i < vec.size(); ++i) {\n\t\t\tpair<int, int> e = vec[i];\n\t\t\tdp(e.first, e.second);\n\t\t\tupd(e.first, e.second, calcmin(e.first, e.second) - minv);\n\t\t\tif (i) merge(l, r, e.first, e.second);\n\t\t\telse {\n\t\t\t\tfor (int j = 0; j < 2; ++j)\n\t\t\t\t\tfor (int k = 0; k < 2; ++k)\n\t\t\t\t\t\tfor (int s = 0; s < 2; ++s)\n\t\t\t\t\t\t\tf[l][r][j][k][s] = f[e.first][e.second][j][k][s];\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i) scanf(\"%d\", &h[i]);\n\tdp(1, n);\n\tupd(1, n, calcmin(1, n) - 1);\n\tfor (int i = 0; i < 2; ++i)\n\t\tfor (int j = 0; j < 2; ++j)\n\t\t\tfor (int k = 0; k < 2; ++k)\n\t\t\t\tans = add(ans, f[1][n][i][j][k]);\n\tprintf(\"%d\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=105,INF=1<<30;\nll dp[MAX][MAX];\n\nll rui(ll a,ll b){\n    ll ans=1;\n    while(b>0){\n        if(b&1) ans=ans*a%mod;\n        a=a*a%mod;\n        b/=2;\n    }\n    return ans;\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int N;cin>>N;\n    vector<ll> h(N+2,1),num(N+2,1),hi(N+2,1);\n    vector<ll> SE;\n    SE.push_back(1);\n    for(int i=0;i<N;i++){\n        cin>>h[i+1];\n        SE.push_back(h[i+1]);\n    }\n    if(N==1){\n        cout<<rui(2,h[1])<<endl;\n        return 0;\n    }\n    \n    sort(all(SE));\n    SE.erase(unique(all(SE)),SE.end());\n    \n    ll M=SE.size();\n    \n    for(int i=0;i<N+2;i++){\n        for(int j=0;j<M;j++){\n            if(SE[j]==h[i]){\n                num[i]=j;\n                break;\n            }\n        }\n    }\n    \n    for(int i=0;i<M;i++){\n        hi[i]=SE[i];\n    }\n    \n    dp[0][0]=1;\n    \n    for(int i=1;i<=N;i++){\n        if(h[i-1]>=h[i]){\n            for(ll from=M-1;from>=num[i];from--){\n                dp[i][num[i]]+=dp[i-1][from]*2;\n                dp[i][num[i]]%=mod;\n            }\n            for(ll j=num[i]-1;j>=0;j--){\n                dp[i][j]+=dp[i-1][j];\n            }\n        }else{\n            dp[i][num[i]]+=dp[i-1][num[i-1]]*2%mod;\n            \n            for(ll j=num[i]-1;j>=num[i-1];j--){\n                dp[i][j]+=dp[i-1][num[i-1]]*2%mod*rui(2,h[i]-hi[j+1])%mod*(rui(2,hi[j+1]-hi[j])-1)%mod;\n            }\n            \n            for(ll j=num[i-1]-1;j>=0;j--){\n                dp[i][j]+=dp[i-1][j]*rui(2,h[i]-h[i-1])%mod;\n            }\n        }\n    }\n    \n    ll ans=0;\n    \n    for(int j=0;j<M;j++){\n        ans+=dp[N][j];\n        ans%=mod;\n    }\n    \n    cout<<ans<<endl;\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 110\n#define ll long long\nusing namespace std;\nconst int mod=1e9+7;\nint h[maxn],a[maxn],b[maxn],sz,n;\n\nll qpow(ll a,ll x)\n{\n    ll ret=1;\n    while(x>0)\n    {\n        if(x&1) ret=ret*a%mod;\n        a=a*a%mod;\n        x>>=1;\n    }\n    return ret;\n}\nll cal(int lb,int ub)\n{\n    ll ret=qpow(2,ub+1)+mod-qpow(2,lb);\n    if(ret>=mod)ret-=mod;\n    return ret;\n}\nll dp[maxn][maxn];\nvoid upd(int &x,int y)\n{\n    x=(x+y>=mod?x+y-mod:x+y);\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    h[sz++]=1;\n    for(int i=0;i<n;++i)\n    {\n        scanf(\"%d\",&a[i]);\n        h[sz++]=a[i];\n    }\n    sort(h,h+sz); sz=unique(h,h+sz)-h;\n    dp[0][0]=2;\n    for(int i=0;i<n;++i) b[i]=lower_bound(h,h+sz,a[i])-h;\n    for(int i=1;i<=b[0];++i)\n    {\n        int ub=a[0]-(h[i-1]+1)+1;\n        int lb=a[0]-(h[i])+1;\n        //printf(\"h[%d]=%d,lb=%d,ub=%d\\n\",i,h[i],lb,ub);\n        dp[0][i]=cal(lb,ub);\n    }\n\n    for(int i=1;i<n;++i)\n    {\n        dp[i][0]=dp[i-1][0]*2%mod;\n        ll t=qpow(2,max(0,a[i]-a[i-1]));\n        for(int j=1;j<=b[i];++j)\n            if(dp[i-1][j])\n                dp[i][j]=(dp[i][j]+dp[i-1][j]*t)%mod;\n        for(int j=b[i]+1;j<sz;++j)\n            if(dp[i-1][j])\n            dp[i][0]=(dp[i][0]+dp[i-1][j]*2)%mod;\n        if(b[i]>b[i-1])\n        {\n            for(int j=b[i-1]+1;j<=b[i];++j)\n            {\n                int ub=a[i]-(h[j-1]+1)+1;\n                int lb=a[i]-(h[j])+1;\n                ll ret=cal(lb,ub);\n                dp[i][j]=(dp[i][j]+dp[i-1][0]*ret)%mod;\n            }\n        }\n    }\n    int ans=0;\n    for(int i=0;i<sz;++i)\n    {\n        ans+=dp[n-1][i];\n        if(ans>=mod) ans-=mod;\n    }\n    printf(\"%d\\n\",ans);\n        //for(int j=len+1;j<sz;++j)\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int mod = 1000000007;\nint binpow(int a, int b) {\n\tint ret = 1;\n\twhile (b) {\n\t\tif (b & 1) ret = 1LL * ret * a % mod;\n\t\ta = 1LL * a * a % mod;\n\t\tb >>= 1;\n\t}\n\treturn ret;\n}\nint main() {\n\tint n;\n\tcin >> n;\n\tvector<int> h(n);\n\tfor (int i = 0; i < n; ++i) cin >> h[i];\n\tvector<int> dp = { 2 };\n\tint firstlow = (n == 1 ? 1 : h[1]);\n\tdp[0] = 1LL * dp[0] * binpow(2, max(h[0] - firstlow, 0)) % mod;\n\tfor (int i = 1; i < n; ++i) {\n\t\tvector<int> ndp(i + 1);\n\t\tint low = (i == n - 1 ? 1 : h[i + 1]);\n\t\tif (h[i] <= low) {\n\t\t\tfor (int j = 0; j < i; ++j) {\n\t\t\t\tndp[j] = dp[j];\n\t\t\t\tndp[i] = (ndp[i] + dp[j]) % mod;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tint mx = min(h[i - 1], h[i]);\n\t\t\tint s = 0;\n\t\t\tfor (int j = i - 1; j >= 0; --j) {\n\t\t\t\tmx = min(mx, (j == 0 ? 1 : h[j - 1]));\n\t\t\t\tndp[j] = 1LL * dp[j] * binpow(2, h[i] - max(low, mx)) % mod;\n\t\t\t\ts = (s + dp[j]) % mod;\n\t\t\t}\n\t\t\tndp[i] = 1LL * s * binpow(2, h[i] - max(min(h[i - 1], h[i]), low)) % mod;\n\t\t}\n\t\tdp = ndp;\n\t}\n\tint sum = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tsum = (sum + dp[i]) % mod;\n\t}\n\tcout << sum << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing pii = pair<int, int>;\n\nconst int N = 110;\nconst int MOD = 1e9+7;\n\ninline int add(int a, int b) { return (a+b)%MOD; }\ninline int mul(int a, int b) { return (a*1ll*b)%MOD; }\ninline int subt(int a, int b) { a = (a-b)%MOD; return a < 0 ? a+MOD : a; }\n\nint n, H[N];\n\nint pw(int b)\n{\n    int a = 2, ans = 1;\n    while (b) {\n        if (b&1) ans = mul(ans, a);\n        a = mul(a, a);\n        b >>= 1;\n    }\n    return ans;\n}\n\npii solve(int l, int r, int dh)\n{\n    int mn = MOD;\n    for (int i = l; i <= r; ++i)\n        mn = min(mn, H[i]);\n    int all = 1, sw = 2;\n    for (int i = l; i <= r; ) {\n        if (H[i] == mn) {\n            all = mul(all, 2);\n            ++i;\n        } else {\n            int j = i;\n            while (j <= r && H[j] > mn) ++j;\n            pii ret = solve(i, j-1, mn);\n            all = mul(all, add( mul(2, ret.second), ret.first ));\n            sw = mul(sw, ret.second);\n            i = j;\n        }\n    }\n    int nsw = subt(all, sw);\n    sw = mul(sw, pw(mn-dh-1));\n    return pii(nsw, sw);\n}\n\nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; ++i)\n        scanf(\"%d\", &H[i]);\n    pii ans = solve(0, n-1, 0);\n    printf(\"%d\\n\", add(ans.first, ans.second));\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\nconst int Max_N(105);\nconst int MOD(1000000000 + 7);\n\nconstexpr int Mult(int a, int b)\n{\n\treturn a * 1LL * b % MOD;\n}\n\nconstexpr int Add(int a, int b)\n{\n\treturn a + b >= MOD ? a + b - MOD : a + b;\n}\n\ninline void upd(int &a, int b)\n{\n\ta = Add(a, b);\n}\n\nint power(int a, int n)\n{\n\tint Ret(1);\n\twhile (n)\n\t{\n\t\tif (n & 1)\n\t\t\tRet = Mult(Ret, a);\n\t\ta = Mult(a, a), n >>= 1;\n\t}\n\treturn Ret;\n}\n\nint N, H[Max_N], V, F[Max_N][3], power2[Max_N];\n\nint solve(int l, int r)\n{\n\tint u = ++V, Min = H[l];\n\tfor (int i = l;i <= r;++i)\n\t\tMin = min(Min, H[i]);\n\tfor (int i = l;i <= r;++i)\n\t\tH[i] -= Min;\n\tint start, v, G[Max_N][3] = {};\n\tif (!H[l])\n\t\tG[l][0] = G[l][1] = 1, G[l][2] = 0, start = l + 1;\n\telse\n\t\tfor (int x = l;x <= r;++x)\n\t\t\tif (!H[x])\n\t\t\t{\n\t\t\t\tstart = x, v = solve(l, --x);\n\t\t\t\tG[x][2] = F[v][2];\n\t\t\t\tG[x][0] = G[x][1] = Add(F[v][0], F[v][1]);\n\t\t\t\tbreak;\n\t\t\t}\n\tfor (int i = start, x;i <= r;++i)\n\t\tif (!H[i])\n\t\t{\n\t\t\tupd(G[i][2], Mult(G[i - 1][2], 2));\n\t\t\tupd(G[i][2], Add(G[i - 1][0], G[i - 1][1]));\n\t\t\tupd(G[i][0], G[i - 1][1]), upd(G[i][1], G[i - 1][0]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (x = i;x <= r;++x)\n\t\t\t\tif (x == r || !H[x + 1])\n\t\t\t\t\tbreak;\n\t\t\tv = solve(i, x);\n\t\t\tupd(G[x][2], Mult(G[i - 1][2], Add(F[v][2], Mult(2, Add(F[v][0], F[v][1])))));\n\t\t\tfor (int c = 0;c <= 1;++c)\n\t\t\t{\n\t\t\t\tupd(G[x][2], Mult(G[i - 1][c], Add(F[v][2], Add(F[v][0], F[v][1]))));\n\t\t\t\tupd(G[x][c ^ ((x - i + 1) & 1)], Mult(G[i - 1][c], Add(F[v][0], F[v][1])));\n\t\t\t}\n\t\t\ti = x;\n\t\t}\n\tF[u][2] = G[r][2];\n\tif (Min == 1)\n\t\tF[u][0] = G[r][(r - l) & 1], F[u][1] = G[r][((r - l) & 1) ^ 1];\n\telse\n\t\tF[u][0] = F[u][1] = Mult(Add(G[r][0], G[r][1]), power(2, Min - 2));\n\treturn u;\n}\n\nint main()\n{\n\tscanf(\"%d\", &N);\n\tfor (int i = 1;i <= N;++i)\n\t\tscanf(\"%d\", H + i);\n\tpower2[0] = 1;\n\tfor (int i = 1;i <= N;++i)\n\t\tpower2[i] = Add(power2[i - 1], power2[i - 1]);\n\tsolve(1, N);\n\tprintf(\"%d\", Add(Add(F[1][0], F[1][1]), F[1][2]));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll MOD = (1e+9)+7;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-11;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\ntypedef pair<ld, ld> LDP;\nll mod_pow(ll x, ll n, ll mod) {\n\tll res = 1;\n\twhile (n > 0) {\n\t\tif (n & 1) res = res * x%mod;\n\t\tx = x * x%mod;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\nstruct seg { int le, ri,num; ll hei; };\nint main() {\n\tint n; cin >> n; ll h[100];\n\trep(i, n) {\n\t\tcin >> h[i];\n\t}\n\tll res = 1;\n\tif (n == 1) {\n\t\tcout << mod_pow(2, h[0], MOD) << endl; return 0;\n\t}\n\trep(i, n) {\n\t\tif (i == 0) {\n\t\t\tif (h[0] > h[1]) {\n\t\t\t\t(res *= mod_pow(2, h[0] - h[1],MOD)) %= MOD;\n\t\t\t\th[0] = h[1];\n\t\t\t}\n\t\t}\n\t\telse if (i == n - 1) {\n\t\t\tif (h[n - 2] < h[n - 1]) {\n\t\t\t\t(res *= mod_pow(2, h[n - 1] - h[n - 2],MOD)) %= MOD;\n\t\t\t\th[n - 1] = h[n - 2];\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tll mh = max(h[i - 1], h[i + 1]);\n\t\t\tif (h[i] > mh) {\n\t\t\t\t(res *= mod_pow(2, h[i] - mh, MOD)) %= MOD;\n\t\t\t\th[i] = mh;\n\t\t\t}\n\t\t}\n\t}\n\tseg a[1000];\n\tvector<int> G[1000];\n\tqueue<seg> q; int sum = 0;\n\tq.push({ 0, n ,0,0 });\n\twhile (!q.empty()) {\n\t\tseg nex = q.front(); q.pop();\n\t\tint le = nex.le; int ri = nex.ri; ll hei = nex.hei;\n\t\tint num = nex.num;\n\t\tll mi = INF;\n\t\tRep(i, le, ri) {\n\t\t\tmi = min(mi, h[i]);\n\t\t}\n\t\ta[num] = { le,ri,0,mi - hei };\n\t\tint now = le;\n\t\tRep(i, le, ri) {\n\t\t\tif (mi == h[i]) {\n\t\t\t\tif (i - now > 0) {\n\t\t\t\t\tsum++;\n\t\t\t\t\tG[num].push_back(sum);\n\t\t\t\t\tq.push({ now, i, sum, mi });\n\t\t\t\t}\n\t\t\t\tnow = i + 1;\n\t\t\t}\n\t\t}\n\t\tif (ri-now>0) {\n\t\t\tsum++;\n\t\t\tG[num].push_back(sum);\n\t\t\tq.push({ now,ri,sum,mi });\n\t\t}\n\t}\n\tLP dp[1000];\n\tper(i, sum+1) {\n\t\tint len = G[i].size();\n\t\tll he = a[i].hei;\n\t\tint le = a[i].le; int ri = a[i].ri;\n\t\tif (len == 0) {\n\t\t\tdp[i].first = mod_pow(2, he, MOD);\n\t\t\tdp[i].second = mod_pow(2, ri - le, MOD);\n\t\t\t(dp[i].second += dp[i].first) %= MOD;\n\t\t\t(dp[i].second += MOD - (ll)2) %= MOD;\n\t\t}\n\t\telse {\n\t\t\tll nex1 = mod_pow(2, he, MOD);\n\t\t\tint wei = ri - le;\n\t\t\trep(j, len) {\n\t\t\t\tseg nod = a[G[i][j]];\n\t\t\t\twei -= (nod.ri - nod.le);\n\t\t\t}\n\t\t\tll nex2 = mod_pow(2, wei, MOD);\n\t\t\trep(j, len) {\n\t\t\t\tint v = G[i][j];\n\t\t\t\t(nex1 *= dp[v].first) %= MOD;\n\t\t\t\t(nex2 *= (dp[v].first + dp[v].second) % MOD) %= MOD;\n\t\t\t}\n\t\t\tll cnex = mod_pow(2, he, MOD);\n\t\t\t(cnex += MOD - (ll)2) %= MOD;\n\t\t\trep(j, len) {\n\t\t\t\tint v = G[i][j];\n\t\t\t\t(cnex *= dp[v].first) %= MOD;\n\t\t\t}\n\t\t\t(nex2 += cnex) %= MOD;\n\t\t\tdp[i] = { nex1,nex2 };\n\t\t}\n\t}\n\tcout << res * dp[0].second % MOD << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define meow(args...) fprintf(stderr, args)\ntypedef unsigned u32;\ntypedef long long s64;\ntypedef unsigned long long u64;\ntemplate<class T1, class T2> inline bool cmin(T1 &a, const T2 &b) {return b<a?(a=b, true):false;}\ntemplate<class T1, class T2> inline bool cmax(T1 &a, const T2 &b) {return a<b?(a=b, true):false;}\ntemplate<class Type> Type read() {\n\tType a;\n\tbool b;\n\tunsigned char c;\n\twhile(c=getchar()-48, (c>9)&(c!=253));\n\tfor(a=(b=c==253)?0:c; (c=getchar()-48)<=9; a=a*10+c);\n\treturn b?-a:a;\n}\nint (*rd)()=read<int>;\nconst u32 P=1e9+7;\ninline u32 &inc(u32 &a, u32 b) {return (a+=b)<P?a:(a-=P);}\ninline u32 &dec(u32 &a, u32 b) {return (a-=b)&0x80000000?(a+=P):a;}\ninline u32 sum(u32 a, u32 b) {return (a+=b)<P?a:a-P;}\ninline u32 dif(u32 a, u32 b) {return (a-=b)&0x80000000?a+P:a;}\nu64 power(u64 a, int b) {\n\tu64 ans=1;\n\tfor(; b; a=a*a%P, b/=2) if(b&1) ans=ans*a%P;\n\treturn ans;\n}\n\nconst int N=101;\nint n, m, h[N], real[N];\nu32 f[N];\nint main() {\n\tn=rd();\n\tfor(int i=0; i<n; ++i) h[i]=real[i]=rd();\n\tstd::sort(real, real+n);\n\tm=std::unique(real, real+n)-real;\n\tfor(int i=0; i<n; ++i) h[i]=std::lower_bound(real, real+m, h[i])-real;\n\tf[0]=power(2, real[h[0]]);\n\tfor(int i=0; i<=h[0]; ++i) f[i+1]=power(2, real[h[0]]-real[i]+1);\n\tfor(int i=0; i<=h[0]; ++i) dec(f[i], f[i+1]);\n\tfor(int i=1; i<n; ++i) {\n\t\tif(h[i]<=h[i-1]) {\n\t\t\tu32 s=0;\n\t\t\tfor(int j=h[i]; j<=h[i-1]; ++j) inc(s, f[j+1]), f[j+1]=0;\n\t\t\tf[h[i]+1]=2*s%P;\n\t\t} else {\n\t\t\tu32 g=f[h[i-1]+1];\n\t\t\tfor(int j=h[i-1]; j<=h[i]; ++j) f[j+1]=g*power(2, real[h[i]]-real[j]+1)%P;\n\t\t\tfor(int j=h[i-1]; ++j<=h[i]; ) dec(f[j], f[j+1]);\n\t\t\tu64 p=power(2, real[h[i]]-real[h[i-1]]);\n\t\t\tfor(int j=0; j<=h[i-1]; ++j) f[j]=f[j]*p%P;\n\t\t}\n\t}\n\tu32 ans=0;\n\tfor(int i=0; i<=h[n-1]+1; ++i) inc(ans, f[i]);\n\tprintf(\"%u\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define st first\n#define nd second\n#define pb push_back\n#define pf push_front\n#define ppb pop_back\n#define ppf pop_front\n#define umax(x,y) x=max(x,y)\n#define umin(x,y) x=min(x,y)\n#define ll long long \n#define ii pair<int,int>\n#define iii pair<int,ii>\n#define iiii pair<ii,ii>\n#define sz(x) ((int) x.size())\n#define orta ((bas+son)/2)\n#define all(x) x.begin(),x.end()\n#define pw(x) (1<<(x))\n#define inf 1000000005\n#define MOD 1000000007 \n#define N 105\n#define M 1000003\n#define LOG 20\n#define KOK 250\n#define EPS 0.0000001\nusing namespace std;\n\nint n,cnt;\nint tut[N],h[N],dp[N][N],vis[N][N];\n\nint mul(int x,int y) {\n\t\n\treturn (ll)x*y%MOD;\n\n}\n\nint add(int x,int y) {\n\n\tx+=y;\n\n\tif(x>=MOD) x-=MOD;\n\tif(x<0) x+=MOD;\n\n\treturn x;\n\n}\n\nint fe(int x,int y) {\n\n\tif(y==0) return 1;\n\tif(y&1) return mul(x,fe(x,y-1));\n\n\tint res=fe(x,y>>1);\n\n\treturn mul(res,res);\n\n}\n\nint f(int pos,int bef) {\n\n\tif(pos>n) return 1;\n\n\tif(vis[pos][bef]) return dp[pos][bef];\n\n\tvis[pos][bef]=1;\n\n\tint& r=dp[pos][bef];\n\n\tif(h[pos-1]>=h[pos]) {\n\n\t\tif(bef>h[pos]) {\n\n\t\t\tr=add(r,mul(2,f(pos+1,cnt+1)));\n\n\t\t}\n\t\telse {\n\n\t\t\tr=add(r,f(pos+1,bef));\n\n\t\t}\n\n\t}\n\telse {\n\n\t\tif(bef>h[pos]) {\n\n\t\t\tfor(int i=h[pos-1]+1;i<=h[pos];i++) {\n\n\t\t\t\tr=add(r,mul(f(pos+1,i),mul(add(fe(2,tut[i]-tut[i-1]-(i-1==0)),MOD-1),fe(2,tut[h[pos]]-tut[i]))));\n\n\t\t\t}\n\n\t\t\tr=add(r,f(pos+1,cnt+1));\n\n\t\t\tr=mul(r,2);\n\n\t\t}\n\t\telse {\n\n\t\t\tr=add(r,mul(f(pos+1,bef),fe(2,tut[h[pos]]-tut[h[pos-1]])));\n\n\t\t}\n\n\t}\n\n\treturn r;\n\n}\n\nvoid compress() {\n\n\tmap<int,int> has;\n\n\tfor(int i=1;i<=n;i++) has[h[i]]=1;\n\n\tfor(auto& x:has) {\n\n\t\t++cnt;\n\n\t\ttut[cnt]=x.st;\n\t\tx.nd=cnt;\n\n\t}\n\n\tfor(int i=1;i<=n;i++) h[i]=has[h[i]];\n\n}\n\nint main() {\n\n\tscanf(\"%d\",&n);\n\n\tfor(int i=1;i<=n;i++) {\n\t\n\t\tscanf(\"%d\",h+i);\n\t\n\t}\n\n\tcompress();\n\n\tprintf(\"%d\",f(1,cnt+1));\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nconst int N=1010,mod=1e9+7;\nint n,ans=1,x,y,high[N];\nint power(int p)\n{\n\tint ans=1,v=2;\n\tfor(;p;p>>=1,v=1ll*v*v%mod)\n\t if(p&1)ans=1ll*ans*v%mod;\n\treturn ans;\n}\nvoid slove(int l,int r,int h,int &a,int &b)\n{\n\tint minf=0x7fffffff,cnt=0;\n\tfor(int i=l;i<=r;i++)\n\t if(high[i]<minf)minf=high[i],cnt=1;\n\t else if(high[i]==minf)cnt++;\n\tif(cnt==r-l+1)\n\t{\n\t\ta=power(r-l+1)-2;if(a<0)a+=mod;\n\t\tb=power(minf-h);\n\t\treturn;\n\t}\n\tint x,y,last=0,v1=1,v2=1;\n\tfor(int i=l;i<=r+1;i++)\n\t{\n\t\tif(!last&&high[i]>minf)last=i;\n\t\telse if(last&&(high[i]<=minf||i==r+1))\n\t\t{\n\t\t\tslove(last,i-1,minf,x,y);\n\t\t\tv1=1ll*v1*(x+y*2%mod)%mod;\n\t\t\tv2=1ll*v2*y%mod;last=0;\n\t\t}\n\t}\n\ta=1ll*v1*power(cnt)%mod;\n\ta=(a-v2*2)%mod;if(a<0)a+=mod;\n\tb=1ll*v2*power(minf-h)%mod;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t scanf(\"%d\",&high[i]);\n\tfor(int i=1;i<=n;i++)\n\t if(high[i]>high[i-1]&&high[i]>high[i+1])\n\t {\n\t    ans=1ll*ans*power(high[i]-max(high[i-1],high[i+1]))%mod;\n\t    high[i]=max(high[i-1],high[i+1]);\n\t }\n\tslove(1,n,0,x,y);\n\tans=1ll*ans*(x+y)%mod;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\nusing namespace std;\nconst int N=220,P=1e9+7;\nint n,m,ans,a[N],b[N],f[N][N];\nvoid chk(int&x){x-=P;x+=(x>>31)&P;}\nint qpw(int x,int y){int z=1;for(;y;y>>=1,x=1ll*x*x%P)if(y&1) z=1ll*z*x%P;return z;}\nint main(){\n\t//freopen(\"1.in\",\"r\",stdin);\n\tscanf(\"%d\",&n);a[0]=1;b[n+1]=1;\n\tFOR(i,1,n) scanf(\"%d\",&a[i]),b[i]=a[i];\n\tsort(b+1,b+n+2);m=unique(b+1,b+n+2)-b;\n\tFOR(i,0,n) a[i]=lower_bound(b+1,b+m,a[i])-b;\n\tf[0][1]=1;\n\tFOR(i,1,n)FOR(j,1,a[i-1])if(f[i-1][j]){\n\t\tint x=a[i-1],y=a[i];\n\t\tif(x>y){\n\t\t\tchk(f[i][min(j,y)]+=f[i-1][j]);\n\t\t\tif(j>=y) chk(f[i][y]+=f[i-1][j]);\n\t\t}\n\t\telse{\n\t\t\tif(j<x) chk(f[i][j]+=1ll*qpw(2,b[y]-b[x])*f[i-1][j]%P);\n\t\t\telse FOR(k,x,y)\n\t\t\tchk(f[i][k]+=2ll*(qpw(2,b[y]-b[k])-(k==y?0:qpw(2,b[y]-b[k+1]))+P)%P*f[i-1][j]%P);\n\t\t}\n\t}\n\tFOR(j,1,m) chk(ans+=f[n][j]);\n\tcout<<ans<<'\\n'; \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\nint dp[103][103] , h[103] , lsh[103] , N , cl;\n\nint poww(long long a , int b){\n\tint times = 1;\n\twhile(b){\n\t\tif(b & 1) times = times * a % MOD;\n\t\ta = a * a % MOD; b >>= 1;\n\t}\n\treturn times;\n}\n\nint main(){\n\tlsh[++cl] = 1; cin >> N;\n\tfor(int i = 1 ; i <= N ; ++i){cin >> h[i]; lsh[++cl] = h[i];}\n\tsort(lsh + 1 , lsh + cl + 1); cl = unique(lsh + 1 , lsh + cl + 1) - lsh - 1;\n\tfor(int i = 1 ; i <= N ; ++i) h[i] = lower_bound(lsh + 1 , lsh + cl + 1 , h[i]) - lsh;\n\tfor(int i = 1 ; i <= h[1] ; ++i) dp[1][i] = poww(2 , 1 + lsh[h[1]] - lsh[i]);\n\tfor(int i = 1 ; i <= h[1] ; ++i) dp[1][i] = (dp[1][i] - dp[1][i + 1] + MOD) % MOD;\n\tfor(int i = 1 ; i < N ; ++i)\n\t\tif(h[i] >= h[i + 1])\n\t\t\tfor(int j = 1 ; j <= h[i] ; ++j)\n\t\t\t\tdp[i + 1][min(h[i + 1] , j)] = (dp[i + 1][min(h[i + 1] , j)] + 1ll * dp[i][j] * (1 + (j >= h[i + 1]))) % MOD;\n\t\telse{\n\t\t\tint pw = poww(2 , lsh[h[i + 1]] - lsh[h[i]]);\n\t\t\tfor(int j = 1 ; j < h[i] ; ++j)\n\t\t\t\tdp[i + 1][j] = 1ll * pw * dp[i][j] % MOD;\n\t\t\tfor(int j = h[i] ; j <= h[i + 1] ; ++j)\n\t\t\t\tdp[i + 1][j] = 2ll * dp[i][h[i]] * poww(2 , lsh[h[i + 1]] - lsh[j]) % MOD;\n\t\t\tfor(int j = h[i] ; j <= h[i + 1] ; ++j)\n\t\t\t\tdp[i + 1][j] = (dp[i + 1][j] - dp[i + 1][j + 1] + MOD) % MOD;\n\t\t}\n\tint sum = 0;\n\tfor(int i = 1 ; i <= cl ; ++i) sum = (sum + dp[N][i]) % MOD;\n\tcout << sum; return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <utility>\n#include <cstdio>\n#define MOD 1000000007\ntypedef long long ll;\ninline ll quick_pow(ll a, int n)\n{\n\tll res = 1;\n\twhile (n)\n\t{\n\t\tif (n & 1)\n\t\t\tres = res * a % MOD;\n\t\ta = a * a % MOD;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\nint arr[105];\nstd::pair<ll, ll> work(int l, int r, int h)\n{\n\tif (l > r)\n\t\treturn {1, (MOD + 1) / 2};\n\tint pos = std::min_element(arr + l, arr + r + 1) - arr;\n\tll val = quick_pow(2, arr[pos] - h);\n\tif (l == r)\n\t\treturn {val, val};\n\tauto x = work(l, pos - 1, arr[pos]), y = work(pos + 1, r, arr[pos]);\n\treturn {val * x.first % MOD * y.first % MOD,\n\t\t\t4 * x.second % MOD * y.second % MOD + (val - 1) * x.first % MOD * y.first % MOD};\n}\nint main()\n{\n\t// freopen(\"AGC026-D.in\", \"r\", stdin);\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(\"%d\", arr + i);\n\tprintf(\"%lld\\n\", work(0, n - 1, 1).second * 2 % MOD);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 100 + 7;\nconst int mod = 1e9 + 7;\n\nint h[maxn];\n\nlong long power(int x, int times) { \n    long long rt = 1, base = x;\n    while (times) {\n        if (times & 1) rt = rt * base % mod;\n        base = base * base % mod;\n        times >>= 1;\n    }\n    return rt;\n}\n\nint dp1(int x, int y, int level) {\n    static bool vis[maxn][maxn];\n    static int f[maxn][maxn];\n    if (vis[x][y]) return f[x][y];\n    vis[x][y] = true;\n\n    int MIN = h[x];\n\n    long long cnt1 = 1;\n    for (int i = x; i <= y; i++) {\n        MIN = min(MIN, h[i]);\n    }\n\n    for (int i = x; i <= y; i++) \n        if (h[i] != MIN) {\n            int j = i;\n            while (j <= y && h[j] != MIN) j++;\n            j--;\n            cnt1 = cnt1 * dp1(i, j, MIN) % mod;\n            i = j;\n        }\n    cnt1 = cnt1 * power(2, MIN - level) % mod;\n    //cout << x << ' ' << y << ' ' << level << ' ' << cnt1 << endl;\n    return f[x][y] = cnt1;\n}\n\nint dp2(int x, int y, int level) {\n    static bool vis[maxn][maxn];\n    static int f[maxn][maxn];\n    if (vis[x][y]) return f[x][y];\n    vis[x][y] = true;\n\n    int MIN = h[x], k = 0;\n\n    long long cnt1 = 1, cnt2 = 1;\n    for (int i = x; i <= y; i++) {\n        MIN = min(MIN, h[i]);\n    }\n\n    for (int i = x; i <= y; i++) \n        if (h[i] != MIN) {\n            int j = i;\n            while (j <= y && h[j] != MIN) j++;\n            j--;\n            cnt1 = cnt1 * (dp1(i, j, MIN) + dp2(i, j, MIN));\n            cnt2 = cnt2 * dp2(i, j, MIN);\n            i = j;\n        }\n        else {\n            k++;\n        }\n    \n    int &rt = f[x][y];\n    rt = ((cnt1 * power(2, k) % mod + cnt1 * (power(2, MIN - level) - 2) % mod) % mod + mod) % mod;\n    \n    // cout << x << ' ' << y << ' ' << level << ' ' << rt << endl;\n    // cout << cnt1 << ' ' << cnt2 << ' ' << k << ' ' << MIN << endl;   \n    return rt;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n\n    for (int i = 1; i <= n; i++) {\n        scanf(\"%d\", &h[i]);\n    }\n\n    cout << dp2(1, n, 0) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Author:xht37\n#include <bits/stdc++.h>\n\n#define ui unsigned int\n#define ll long long\n#define ul unsigned ll\n#define ld long double\n\n#define pi pair <int, int>\n#define fi first\n#define se second\n#define mp make_pair\n\n#define ls (p << 1)\n#define rs (ls | 1)\n#define md ((t[p].l + t[p].r) >> 1)\n\n#define vi vector <int>\n#define pb push_back\n#define pq priority_queue\n\n#define dbg(x) cerr << #x\" = \" << x << endl\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#define fl(x) freopen(x\".in\", \"r\", stdin), freopen(x\".out\", \"w\", stdout)\n\nusing namespace std;\n\nnamespace io {\n\tconst int SI = 1 << 21 | 1;\n\tchar IB[SI], *IS, *IT, OB[SI], *OS = OB, *OT = OS + SI - 1, c, ch[100];\n\tint f, t;\n\t#define gc() (IS == IT ? (IT = (IS = IB) + fread(IB, 1, SI, stdin), IS == IT ? EOF : *IS++) : *IS++)\n\tinline void flush() {\n\t\tfwrite(OB, 1, OS - OB, stdout), OS = OB;\n\t}\n\tinline void pc(char x) {\n\t\t*OS++ = x;\n\t\tif (OS == OT) flush();\n\t}\n\n\ttemplate <class I>\n\tinline void rd(I &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + (c & 15), c = gc());\n\t\tx *= f;\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y) {\n\t\trd(x), rd(y);\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y, I &z) {\n\t\trd(x), rd(y), rd(z);\n\t}\n\ttemplate <class I>\n\tinline void rda(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) rd(a[i]);\n\t}\n\tinline void rdc(char &c) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t}\n\tinline void rds(char *s, int &n) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (n = 0; c >= 33 && c <= 126; s[++n] = c, c = gc());\n\t\ts[n+1] = '\\0';\n\t}\n\tinline void rds(string &s) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (s.clear(); c >= 33 && c <= 126; s.pb(c), c = gc());\n\t}\n\n\ttemplate <class I>\n\tinline void print(I x, char k = '\\n') {\n\t\tif (!x) pc('0');\n\t\tif (x < 0) pc('-'), x = -x;\n\t\twhile (x) ch[++t] = x % 10 + '0', x /= 10;\n\t\twhile (t) pc(ch[t--]);\n\t\tpc(k);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y) {\n\t\tprint(x, ' '), print(y);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y, I z) {\n\t\tprint(x, ' '), print(y, ' '), print(z);\n\t}\n\ttemplate <class I>\n\tinline void printa(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) print(a[i], \" \\n\"[i==n]);\n\t}\n\tinline void printc(char c) {\n\t\tpc(c);\n\t}\n\tinline void prints(char *s, int n) {\n\t\tfor (int i = 1; i <= n; i++) pc(s[i]);\n\t\tpc('\\n');\n\t}\n\tinline void prints(string s) {\n\t\tint n = s.length();\n\t\twhile (t < n) pc(s[t++]);\n\t\tpc('\\n'), t = 0;\n\t}\n\tstruct Flush {\n\t\t~Flush() {\n\t\t\tflush();\n\t\t}\n\t} flusher;\n}\nusing io::rd;\nusing io::rda;\nusing io::rdc;\nusing io::rds;\nusing io::print;\nusing io::printa;\nusing io::printc;\nusing io::prints;\n\nconst int P = 1e9 + 7;\n\nstruct modint {\n\tint x;\n\tinline modint(int x = 0) : x(x) {}\n\tinline modint &operator = (int o) { return x = o, *this; }\n\tinline modint &operator += (modint o) { return (x += o.x) >= P && (x -= P), *this; }\n\tinline modint &operator -= (modint o) { return (x -= o.x) < 0 && (x += P), *this; }\n\tinline modint &operator *= (modint o) { return x = 1ll * x * o.x % P, *this; }\n\ttemplate <class I>\n\tinline modint &operator ^= (I b) {\n\t\tmodint a = *this, c;\n\t\tif (!~b) b = P - 2;\n\t\tc.x = 1 % P;\n\t\twhile (b) {\n\t\t\tif (b & 1) c *= a;\n\t\t\ta *= a, b >>= 1;\n\t\t}\n\t\treturn x = c.x, *this;\n\t}\n\tinline modint &operator /= (modint o) { return *this *= o ^ -1; }\n\tinline modint &operator += (int o) { return (x += o) >= P && (x -= P), *this; }\n\tinline modint &operator -= (int o) { return (x -= o) < 0 && (x += P), *this; }\n\tinline modint &operator *= (int o) { return x = 1ll * x * o % P, *this; }\n\tinline modint &operator /= (int o) { return *this *= (modint)o ^ -1; }\n\ttemplate <class I>\n\tinline friend modint operator + (modint a, I b) { return a += b; }\n\ttemplate <class I>\n\tinline friend modint operator - (modint a, I b) { return a -= b; }\n\ttemplate <class I>\n\tinline friend modint operator * (modint a, I b) { return a *= b; }\n\ttemplate <class I>\n\tinline friend modint operator ^ (modint a, I b) { return a ^= b; }\n\ttemplate <class I>\n\tinline friend modint operator / (modint a, I b) { return a /= b; }\n\tinline friend bool operator == (modint a, int b) { return a.x == b; }\n\tinline friend bool operator != (modint a, int b) { return a.x != b; }\n\tinline friend bool operator < (modint a, int b) { return a.x < b; }\n\tinline friend bool operator <= (modint a, int b) { return a.x <= b; }\n\tinline friend bool operator > (modint a, int b) { return a.x > b; }\n\tinline friend bool operator >= (modint a, int b) { return a.x >= b; }\n\tinline friend bool operator == (modint a, modint b) { return a.x == b.x; }\n\tinline friend bool operator != (modint a, modint b) { return a.x != b.x; }\n\tinline friend bool operator < (modint a, modint b) { return a.x < b.x; }\n\tinline friend bool operator <= (modint a, modint b) { return a.x <= b.x; }\n\tinline friend bool operator > (modint a, modint b) { return a.x > b.x; }\n\tinline friend bool operator >= (modint a, modint b) { return a.x >= b.x; }\n\tinline bool operator ! () { return !x; }\n\tinline modint operator - () { return x ? P - x : 0; }\n};\ninline void rd(modint &x) { rd(x.x); }\ninline void print(modint x, char k = '\\n') { print(x.x, k); }\n\n//const int NP = 1e6 + 7;\n//modint p[NP], v[NP], vp[NP];\n//inline void init(int n) {\n//  p[0] = v[0] = 1;\n//  for (int i = 1; i <= n; i++) p[i] = p[i-1] * i;\n//  vp[n] = 1 / p[n];\n//  for (int i = n; i; i--) v[i] = vp[i] * p[i-1], vp[i-1] = vp[i] * i;\n//}\n//inline modint binom(int n, int m) {\n//  return (m < 0 || n < m) ? 0 : p[n] * vp[m] * vp[n-m];\n//}\n\nconst int N = 1e5 + 7;\nint n, h[N], p[N], pl[N], pr[N], w[N];\n\nstruct DP {\n\tmodint a[2][2][2];\n\tinline DP() {\n\t\tfor (int i = 0; i < 2; i++)\n\t\t\tfor (int j = 0; j < 2; j++)\n\t\t\t\tfor (int k = 0; k < 2; k++)\n\t\t\t\t\ta[i][j][k] = 0;\n\t}\n\tinline friend DP operator + (DP a, DP b) {\n\t\tDP c;\n\t\tfor (int li = 0; li < 2; ++li)\n\t\t\tfor (int ri = 0; ri < 2; ++ri)\n\t\t\t\tfor (int lj = 0; lj < 2; ++lj)\n\t\t\t\t\tfor (int rj = 0; rj < 2; ++rj)\n\t\t\t\t\t\tfor (int lk = 0; lk < 2; ++lk)\n\t\t\t\t\t\t\tfor (int rk = 0; rk < 2; ++rk)\n\t\t\t\t\t\t\t\tc.a[li][rj][lk|rk|(lj==ri)] += a.a[li][lj][lk] * b.a[ri][rj][rk];\n\t\treturn c;\n\t}\n} f[N];\n\nvoid work(int o, int x) {\n\tif (w[o] == x) return;\n\tDP now;\n\tint t = (w[o] ^ x) & 1;\n\tmodint k = (modint)2 ^ (w[o] - x - 1);\n\tfor (int i = 0; i < 2; i++)\n\t\tfor (int j = 0; j < 2; j++)\n\t\t\tnow.a[i][j][0] = (f[o].a[i][j][0] + f[o].a[i^1][j^1][0]) * k,\n\t\t\tnow.a[i][j][1] = f[o].a[i^t][j^t][1];\n\tf[o] = now;\n}\n\nint main() {\n\trd(n), rda(h, n), iota(p + 1, p + n + 1, 1);\n\tsort(p + 1, p + n + 1, [&](int i, int j) { return h[i] > h[j]; });\n\tfor (int o = 1; o <= n; o++) {\n\t\tint i = p[o], L = i, R = i;\n\t\tDP now;\n\t\tnow.a[0][0][0] = now.a[1][1][0] = 1;\n\t\tif (pl[i-1]) L = pl[i-1], pr[L] = pl[i-1] = 0, work(L, h[i]), now = f[L] + now;\n\t\tif (pr[i+1]) R = pr[i+1], pr[i+1] = pl[R] = 0, work(i + 1, h[i]), now = f[i+1] + now;\n\t\tf[L] = now, pr[L] = R, pl[R] = L, w[L] = h[i];\n\t}\n\twork(1, 1);\n\tmodint ans;\n\tfor (int i = 0; i < 2; i++)\n\t\tfor (int j = 0; j < 2; j++)\n\t\t\tfor (int k = 0; k < 2; k++)\n\t\t\t\tans += f[1].a[i][j][k];\n\tprint(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) (x = max(x,y))\n#define mins(x,y) (x = min(x,y))\n#define limit(x,l,r) max(l,min(x,r))\n#define lims(x,l,r) (x = max(l,min(x,r)))\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcountll\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,v(T),greater<T> >\n#define bn(x) ((1<<x)-1)\n#define dup(x,y) (((x)+(y)-1)/(y))\n#define newline puts(\"\")\n#define v(T) vector<T>\n#define vv(T) v(v(T))\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ntemplate<typename T>inline istream& operator>>(istream&i,v(T)&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(const v(T)&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>inline ostream& operator<<(ostream&o,const v(T)&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>inline istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>inline ostream& operator<<(ostream&o,const pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\ntemplate<typename T>inline ll suma(const v(T)& a) { ll res(0); for (auto&& x : a) res += x; return res;}\nconst double eps = 1e-10;\nconst ll LINF = 1e18;\nconst int INF = 1001001001;\n#define dame { puts(\"-1\"); return 0;}\n#define yn {puts(\"YES\");}else{puts(\"NO\");}\nconst int MX = 200005;\n\n// Mod int\nconst int mod = 1000000007;\nstruct mint {\n  ll x;\n  mint():x(0){}\n  mint(ll x):x((x%mod+mod)%mod){}\n  // mint(ll x):x(x){}\n  mint& fix() { x = (x%mod+mod)%mod; return *this;}\n  mint& operator+=(const mint& a){ if((x+=a.x)>=mod) x-=mod; return *this;}\n  mint& operator-=(const mint& a){ if((x+=mod-a.x)>=mod) x-=mod; return *this;}\n  mint& operator*=(const mint& a){ (x*=a.x)%=mod; return *this;}\n  mint& operator/=(const mint& a){ (x*=a.ex(mod-2).x)%=mod; return *this;}\n  mint operator+(const mint& a)const{ return mint(*this) += a;}\n  mint operator-(const mint& a)const{ return mint(*this) -= a;}\n  mint operator*(const mint& a)const{ return mint(*this) *= a;}\n  mint operator/(const mint& a)const{ return mint(*this) /= a;}\n  mint ex(ll t) const {\n    if(!t) return 1;\n    mint res = ex(t/2);\n    res *= res;\n    return (t&1)?res*x:res;\n  }\n  bool operator<(const mint& a)const{ return x < a.x;}\n  bool operator==(const mint& a)const{ return x == a.x;}\n};\nmint ex(mint x, ll t) { return x.ex(t);}\nistream& operator>>(istream&i,mint&a){i>>a.x;return i;}\nostream& operator<<(ostream&o,const mint&a){o<<a.x;return o;}\ntypedef vector<mint> vm;\nstruct comb {\n  vm f, g;\n  comb(){}\n  comb(int mx):f(mx+1),g(mx+1) {\n    f[0] = 1;\n    rrep(i,mx) f[i] = f[i-1]*i;\n    g[mx] = f[mx].ex(mod-2);\n    for(int i=mx;i>0;i--) g[i-1] = g[i]*i;\n  }\n  mint c(int a, int b) {\n    if (a < b) return 0;\n    return f[a]*g[b]*g[a-b];\n  }\n};\n//\n\nvi conv(vi a) {\n  vi res;\n  rep(i,sz(a)-1) {\n    res.pb(min(a[i],a[i+1])-1);\n  }\n  return res;\n}\ntypedef pair<mint,mint> MP;\nMP dfs(vi a) {\n  int n = sz(a);\n  int l = INF;\n  rep(i,n) mins(l,a[i]);\n  rep(i,n) a[i] -= l;\n  MP res(1,1);\n  vi x;\n  auto f = [&]() {\n    if (!sz(x)) return;\n    MP d = dfs(x);\n    res.fi *= d.fi;\n    res.se *= d.se;\n    x = vi();\n  };\n  rep(i,n) {\n    if (a[i]) {\n      x.pb(a[i]);\n    } else {\n      res.se *= 2;\n      f();\n    }\n  }\n  f();\n  // cerr<<l<<\": \"<<a<<endl;\n  // cerr<<res<<endl;\n  res.se += res.fi*(ex(2,l)-1);\n  res.fi *= ex(2,l);\n  // cerr<<res<<endl;\n  return res;\n}\nmint solve(vi a) {\n  int n = sz(a);\n  if (!n) return 1;\n  a = conv(a);\n  return dfs(a).se*2;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\",&n);\n  vi a(n);\n  cin>>a;\n  mint ans = 1;\n  rep(i,n) {\n    int x = 0;\n    if (i) maxs(x,a[i-1]);\n    if (i+1 < n) maxs(x,a[i+1]);\n    if (a[i] > x) {\n      ans *= ex(2,a[i]-x);\n      a[i] = x;\n    }\n  }\n\n  vi x;\n  rep(i,n) {\n    if (a[i] == 1) {\n      ans *= 2;\n      a[i] = 0;\n      ans *= solve(x);\n    } else x.pb(a[i]);\n  }\n  ans *= solve(x);\n  cout<<ans<<endl;\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define db double\n#define pint pair<int,int>\n#define mk(x,y) make_pair(x,y)\n#define fir first\n#define sec second\n#define Rep(x,y,z) for(int x=y;x<=z;x++)\n#define Red(x,y,z) for(int x=y;x>=z;x--)\nusing namespace std;\nconst int MAXN=6e3+5;\nchar buf[1<<12],*p1=buf,*p2=buf,nc;int ny;\n//inline char gc() {return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<12,stdin),p1==p2)?EOF:*p1++;}\ninline char gc(){return getchar();}\ninline int read(){\n\tint x=0;for(ny=1;nc=gc(),(nc<48||nc>57)&&nc!=EOF;)if(nc==45)ny=-1;if(nc<0)return nc;\n\tfor(x=nc-48;nc=gc(),47<nc&&nc<58&&nc!=EOF;x=(x<<3)+(x<<1)+(nc^48));return x*ny;\n}int n,tmp,p[MAXN],kind[MAXN],cnt,bel[MAXN];string s,F[MAXN];\nint main(){\n\tn=read(),cin>>s,p[0]=-1;\n\tRep(i,0,2*n-1){\n\t\ttmp+=s[i]=='a'?1:-1;\n\t\tif(!tmp)p[++cnt]=i,kind[cnt]=s[i]=='a';\n\t}bool flg=1;\n\tRed(i,cnt,1){\n\t\tif(kind[i]){\n\t\t\tint s1=0,s2=0;\n\t\t\tRep(j,p[i-1]+1,p[i])if(s[j]=='a')bel[j]=++s1;else bel[j]=++s2;\n\t\t\tF[i]=F[i+1],flg=0;\n\t\t\tRep(j,1,s1){\n\t\t\t\tstring cur;\n\t\t\t\tRep(k,p[i-1]+1,p[i])if(bel[k]>=j)cur+=s[k];\n\t\t\t\tF[i]=max(F[i],cur+F[i+1]);\n\t\t\t}\n\t\t}else if(flg){\n\t\t\tint s1=0,s2=0;\n\t\t\tRep(j,p[i-1]+1,p[i])if(s[j]=='a')bel[j]=++s1;else bel[j]=++s2;\n\t\t\tfor(int r=p[i-1]+1;;){\n\t\t\t\tfor(;r<=p[i]&&s[r]=='b';r++);\n\t\t\t\tif(r>p[i])break;int t=bel[r];\n\t\t\t\tfor(r++,F[i]+=\"ab\";bel[r]!=t;r++);r++;\n\t\t\t}F[i]+=F[i+1];\n\t\t}else F[i]=F[i+1];\n\t}cout<<F[1]<<'\\n';\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n\ntypedef long long ll;\ntypedef pair<int, int> pi;\n\nint n;\nconst int maxn = 105;\n\nint h[maxn];\nint a[maxn], tot;\nint id[maxn];\nconst int mod = 1e9 + 7;\n\nvoid add(int &a, int b){\n    a += b;\n    if(a >= mod)\n        a -= mod;\n}\n\nint dp[maxn][maxn];\n\nint qpow(int a, int n){\n    int ret = 1;\n    while(n > 0){\n        if(n & 1){\n            ret = 1LL * ret * a % mod;\n        }\n        a = 1LL * a * a % mod;\n        n >>= 1;\n    }\n    return ret;\n}\n\nint power2(int l, int r){\n    int ret = (qpow(2, r + 1) - qpow(2, l) + mod) % mod;\n    return ret;\n}\n\nint solve(vector<int> heights){\n    if(heights.size() == 0){\n        return 1;\n    }\n    memset(dp, 0, sizeof(dp));\n    int h1 = a[heights[0]];\n    dp[1][0] = 2;\n    dp[1][1] = power2(h1 - a[1] + 1, h1 - 1);\n    for(int i = 2;i <= heights[0];i++){\n        dp[1][i] = power2(h1 - a[i] + 1, h1 - a[i - 1]);\n    }\n    int sz = heights.size();\n    for(int i = 1;i < sz;i++){\n        for(int j = 1;j <= heights[i - 1];j++){\n            if(heights[i] >= j){\n                int sum = max(0, a[heights[i]] - a[heights[i - 1]]);\n                sum = qpow(2, sum);\n                add(dp[i + 1][j], 1LL * dp[i][j] * sum % mod);\n            }else{\n                add(dp[i + 1][0], dp[i][j] * 2 % mod); \n            }\n        }\n        if(heights[i] <= heights[i - 1]){\n            add(dp[i + 1][0], dp[i][0] * 2 % mod);\n        }else{\n            h1 = a[heights[i]];\n            for(int j = heights[i - 1] + 1;j <= heights[i];j++){\n                int sum = power2(h1 - a[j] + 1, h1 - a[j - 1]);\n                add(dp[i + 1][j], 1LL * dp[i][0] * sum % mod);\n            }\n            add(dp[i + 1][0], dp[i][0] * 2 % mod);\n        }\n    }\n    //for(int i = 1;i <= sz;i++){\n    //    for(int j = 0;j <= heights[i - 1];j++){\n    //        cout << dp[i][j] << \" \";\n    //    }\n    //    cout << endl;\n    //}\n    int ans = 0;\n    for(int j = 0;j <= heights[sz - 1];j++){\n        add(ans, dp[sz][j]);\n    }\n    return ans;\n}\n\nint main(){\n    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n    cin >> n;\n    tot = 0;\n    for(int i = 1;i <= n;i++){\n        cin >> h[i];\n        if(h[i] > 1)\n            a[++tot] = h[i];\n    }\n    sort(a + 1, a + 1 + tot);\n    tot = unique(a + 1, a + 1 + tot) - a - 1;\n    for(int i = 1;i <= n;i++){\n        if(h[i] == 1)\n            continue;\n        id[i] = lower_bound(a + 1, a + 1 + tot, h[i]) - a;\n    }\n    vector<int> his;\n    int ans = 1;\n    for(int i = 1;i <= n;i++){\n        if(h[i] == 1){\n            ans = ans * 2 % mod;\n            ans = 1LL * ans * solve(his) % mod;\n            his.clear();\n        }else{\n            his.push_back(id[i]);\n        }\n    }\n    if(!his.empty()){\n        ans = 1LL * ans * solve(his) % mod;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int mod=1000000007;\nint n,h[110],f[110],mi[110][110];\nlong long cnt[110][110];\n\nint quickmi(int a,long long b)\n{\n\tint t=1;\n\tfor (; b; b>>=1,a=1ll*a*a%mod)\n\t\tif (b&1) t=1ll*t*a%mod;\n\treturn t;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1; i<=n; i++) scanf(\"%d\",&h[i]);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tmi[i][i]=h[i];\n\t\tfor (int j=i+1; j<=n; j++) mi[i][j]=min(mi[i][j-1],h[j]);\n\t}\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tcnt[i][i]=h[i];\n\t\tfor (int j=i+1; j<=n; j++) cnt[i][j]=cnt[i][j-1]+max(h[j]-h[j-1],0);\n\t}\n\tfor (int i=1; i<n; i++)\n\t{\n\t\tint H=min(h[i],h[i+1]);\n\t\tf[i]=quickmi(2,cnt[1][i]-H);\n\t\tfor (int j=1; j<i; j++)\n\t\t\tif (h[j]<h[j+1]) f[i]=(f[i]+1ll*f[j]*quickmi(2,cnt[j][i]-h[j]-H+mi[j][i+1]))%mod;\n\t\t\telse f[i]=(f[i]+1ll*f[j]*quickmi(2,cnt[j+1][i]-h[j+1]-H+mi[j+1][i+1]))%mod;\n\t}\n\tf[n]=quickmi(2,cnt[1][n]);\n\tfor (int j=1; j<n; j++)\n\t\tif (h[j]<h[j+1]) f[n]=(f[n]+1ll*f[j]*quickmi(2,cnt[j][n]-h[j]+1))%mod;\n\t\telse f[n]=(f[n]+1ll*f[j]*quickmi(2,cnt[j+1][n]-h[j+1]+1))%mod;\n\treturn printf(\"%d\\n\",f[n]),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <math.h>\n#include <time.h>\n#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <fstream>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAXN = 105;\nconst ll MOD = 1000000007;\n\nint n;\nint h[MAXN];\n\nll f[MAXN][MAXN][2];\n\nbool vis[MAXN][MAXN][2];\n\nll power(ll a,ll b)\n{\n\tll res = 1;\n\twhile (b)\n\t{\n\t\tif (b & 1)\n\t\t\t(res *= a) %= MOD;\n\t\t(a *= a) %= MOD;\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\n\nll dfs(int l,int r,bool fl)\n{\n\tif (l > r)\n\t\treturn fl;\n\tif (vis[l][r][fl])\n\t\treturn f[l][r][fl];\n\tvis[l][r][fl] = 1;\n\tint H = max(h[l - 1],h[r + 1]),MN = 1e9;\n\tll res = 1;\n\tfor (int i = l;i <= r;i++)\n\t\tMN = min(MN,h[i]);\n\tint lst = l;\n\tfor (int i = l;i <= r;i++)\n\t\tif (h[i] == MN)\n\t\t{\n\t\t\t(res *= dfs(lst,i - 1,1)) %= MOD;\n\t\t\tlst = i + 1;\n\t\t}\n\tf[l][r][1] = res * dfs(lst,r,1) * 2 % MOD;\n\tlst = l;\n\tres = 1;\n\tfor (int i = l;i <= r;i++)\n\t\tif (h[i] == MN)\n\t\t{\n\t\t\t(res *= (dfs(lst,i - 1,0) + dfs(lst,i - 1,1) * ((i - 1 >= lst) + 1)) * 2) %= MOD;\n\t\t\tlst = i + 1;\n\t\t}\n\tf[l][r][0] = (res * (dfs(lst,r,0) + dfs(lst,r,1) * ((r >= lst) + 1)) - f[l][r][1]) % MOD;\n\t(f[l][r][1] *= power(2,MN - H - 1)) %= MOD;\n\treturn f[l][r][fl];\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i = 1;i <= n;i++)\n\t\tscanf(\"%d\",&h[i]);\n\tprintf(\"%lld\\n\",(dfs(1,n,0) + dfs(1,n,1) + MOD + MOD) % MOD);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define mod 1000000007LL\n\nll f[110][2],bin[110];\nint h[110],n,tt;\n\ninline int rd()\n{\n\tint x=0;char ch=getchar();\n\tfor (;ch<'0'||ch>'9';ch=getchar());\n\tfor (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n\treturn x;\n}\n\ninline ll pls(const ll &x,const ll &y) { return (x+y<mod)?x+y:x+y-mod; }\ninline ll mns(const ll &x,const ll &y) { return (x-y<0)?x-y+mod:x-y; }\ninline ll ksm(ll x,ll y) { ll res=1;for (;y;y>>=1,x=x*x%mod) if (y&1) res=res*x%mod;return res; }\n\ninline void pre_gao()\n{\n\tbin[0]=1;\n\tfor (int i=1;i<=n;i++) bin[i]=bin[i-1]*2%mod;\n}\n\ninline void solve(int l,int r)\n{\n\tint id=++tt,mn=h[l];\n\tfor (int i=l;i<=r;i++) mn=min(mn,h[i]);\n\tll g[110][2];\n\tmemset(g,0,sizeof(g));\n\tg[l-1][0]=0;g[l-1][1]=2;\n\tfor (int i=l;i<=r;i++)\n\t{\n\t\tif (h[i]==mn)\n\t\t{\n\t\t\tg[i][0]=pls(g[i-1][0]*2%mod,(i==l)?0:g[i-1][1]);\n\t\t\tg[i][1]=g[i-1][1];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint j=i;\n\t\t\tfor (;j<=r&&h[j]>mn;j++);j--;\n\t\t\tfor (int k=i;k<=j;k++) h[k]-=mn;\n\t\t\tint now=tt+1;solve(i,j);\n\t\t\tg[j][0]=pls(g[i-1][0]*pls(f[now][0],f[now][1]*2%mod)%mod,(i==l)?f[now][0]:g[i-1][1]*pls(f[now][0],f[now][1])%mod);\n\t\t\tg[j][1]=g[i-1][1]*f[now][1]%mod;\n\t\t\ti=j;\n\t\t}\n\t}\n\tf[id][0]=g[r][0];f[id][1]=g[r][1]*ksm(2,mn-1)%mod;\n}\n\nint main()\n{\n\tn=rd();pre_gao();\n\tfor (int i=1;i<=n;i++) h[i]=rd();\n\tsolve(1,n);\n\tprintf(\"%lld\\n\",pls(f[1][0],f[1][1]));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\nvector<P> child[100][100];\nInt height[100][100];\nInt h[100];\nInt dp[101][101][2];\n\nInt n;\n\n\nInt mod_pow(Int x, Int a, Int m = MOD){\n  if(a == 0)return 1;\n  Int res = mod_pow(x, a / 2, m);\n  res = res * res % m;\n  if(a % 2)res *= x;\n  return res % m;\n}\n\nInt inv(Int x, Int m = MOD){\n  return mod_pow(x, m-2, m);\n}\n\nvoid dfs(int l, int r, int base = 0){\n  height[l][r] = INF;\n  for(int i = l;i <= r;i++){\n    height[l][r] = min(height[l][r], h[i]);\n  }\n  int nl = l;\n  int nc = 0;\n  for(int i = l;i <= r;i++)nc += height[l][r] == h[i];\n  while(true){\n    while(nl <= r && h[nl] <= height[l][r])nl++;\n    if(nl > r)break;\n    Int nr = nl;\n    while(nr+1 <= r && h[nr+1] > height[l][r])nr++;\n    child[l][r].push_back(P(nl, nr));\n    dfs(nl, nr, height[l][r]);\n    nl = nr+1;\n  }\n  \n  height[l][r] -= base;\n  dp[l][r][0] = mod_pow(2, height[l][r]);\n  dp[l][r][1] = mod_pow(2, nc);\n  Int pk = 1;\n  for(auto c:child[l][r]){\n    dp[l][r][0];pk *= dp[c.first][c.second][0];pk %= MOD;\n    dp[l][r][1] *= (dp[c.first][c.second][0]*2 + dp[c.first][c.second][1]) % MOD;dp[l][r][1] %= MOD;\n  }\n  dp[l][r][0] *= pk;dp[l][r][0] %= MOD;\n  dp[l][r][1] -= 2*pk;dp[l][r][1] %= MOD;\n  //  cout << l<< \" \" << r << \" \" <<  dp[l][r][0] << \" \" << dp[l][r][1] << endl;\n}\n\nint main(){\n  cin >> n;\n  for(int i = 0;i < n;i++){\n    cin >> h[i];\n  }\n\n  dfs(0, n-1);\n  Int res = dp[0][n-1][0] + dp[0][n-1][1];res %= MOD;\n  if(res < 0)res += MOD;\n  cout << res << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\nconst ll MOD = 1000000007;\n\ninline void add(ll &x, ll y) { x += y; if (x >= MOD) x -= MOD; }\n\nll mod_pow(ll x, ll k) {\n\tll res = 1;\n\tfor (; k; x = x * x % MOD, k /= 2) {\n\t\tif (k & 1) {\n\t\t\tres = res * x % MOD;\n\t\t}\n\t}\n\treturn res;\n}\n\nint N;\nint h[110];\nint mh[110][110];\nll dp[110][110][2][2][2]; //left, right, same\nll sub[110][2][2][2]; //left, right, same\nll tb[110][110][2][2][2];\n\nvoid calc(int l, int r, int lo, int &pt) {\n\t//cerr << l << \" \" << r << \" \" << lo << endl;\n\n\tbool sm = 1;\n\tfor (int i = l; i <= r; ++i) if (mh[l][r] != h[i]) {\n\t\tsm = 0;\n\t}\n\n\tint now = pt++;\n\tif (sm) {\n\t\trep(j, 2) {\n\t\t\trep(k, 2) {\n\t\t\t\trep(t, 2) {\n\t\t\t\t\ttb[now][r][j][k][t] = sub[r-l+1][j][k][t];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tint la = -1;\n\n\t\tfor (int m = l; m <= r; ++m) {\n\t\t\tif (h[m] == mh[l][r]) {\n\t\t\t\tif (la != -1) {\n\t\t\t\t\tcalc(la, m-1, mh[l][r], pt);\n\t\t\t\t\tif (la == l) {\n\t\t\t\t\t\trep(j, 2) {\n\t\t\t\t\t\t\trep(k, 2) {\n\t\t\t\t\t\t\t\trep(t, 2) {\n\t\t\t\t\t\t\t\t\tif (t == 1) {\n\t\t\t\t\t\t\t\t\t\tadd(tb[now][m-1][j^1][k^1][t], dp[la][m-1][j][k][t]);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tadd(tb[now][m-1][j^1][k^1][t], dp[la][m-1][j][k][t]);\n\t\t\t\t\t\t\t\t\t\tadd(tb[now][m-1][j][k][t], dp[la][m-1][j][k][t]);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\trep(j, 2) {\n\t\t\t\t\t\t\trep(k, 2) {\n\t\t\t\t\t\t\t\trep(t, 2) {\n\t\t\t\t\t\t\t\t\trep(jj, 2) {\n\t\t\t\t\t\t\t\t\t\trep(kk, 2) {\n\t\t\t\t\t\t\t\t\t\t\trep(tt, 2) {\n\t\t\t\t\t\t\t\t\t\t\t\tint nj, nk, nt;\n\t\t\t\t\t\t\t\t\t\t\t\tif (tt == 1) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tnj = j, nk = kk ^ 1, nt = (t | tt) | (k == (jj ^ 1));\n\t\t\t\t\t\t\t\t\t\t\t\t\tadd(tb[now][m-1][nj][nk][nt], tb[now][la-1][j][k][t] * dp[la][m-1][jj][kk][tt] % MOD);\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\tnj = j, nk = kk ^ 1, nt = (t | tt) | (k == (jj ^ 1));\n\t\t\t\t\t\t\t\t\t\t\t\t\tadd(tb[now][m-1][nj][nk][nt], tb[now][la-1][j][k][t] * dp[la][m-1][jj][kk][tt] % MOD);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\tnj = j, nk = kk, nt = (t | tt) | (k == jj);\n\t\t\t\t\t\t\t\t\t\t\t\t\tadd(tb[now][m-1][nj][nk][nt], tb[now][la-1][j][k][t] * dp[la][m-1][jj][kk][tt] % MOD);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (m == l) {\n\t\t\t\t\ttb[now][l][0][0][0] = tb[now][l][1][1][0] = 1;\n\t\t\t\t} else {\n\t\t\t\t\trep(j, 2) {\n\t\t\t\t\t\trep(k, 2) {\n\t\t\t\t\t\t\trep(t, 2) {\n\t\t\t\t\t\t\t\tif (tb[now][m-1][j][k][t] == 0) continue; \n\t\t\t\t\t\t\t\trep(nx, 2) {\n\t\t\t\t\t\t\t\t\tadd(tb[now][m][j][nx][t | (nx == k)], tb[now][m-1][j][k][t]); \n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tla = -1;\n\t\t\t} else if (h[m] > mh[l][r]) {\n\t\t\t\tif (la == -1) {\n\t\t\t\t\tla = m;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (la != -1) {\n\t\t\tcalc(la, r, mh[l][r], pt);\n\n\t\t\trep(j, 2) {\n\t\t\t\trep(k, 2) {\n\t\t\t\t\trep(t, 2) {\n\t\t\t\t\t\tif (tb[la-1][j][k][t] == 0) continue;\n\t\t\t\t\t\trep(jj, 2) {\n\t\t\t\t\t\t\trep(kk, 2) {\n\t\t\t\t\t\t\t\trep(tt, 2) {\n\t\t\t\t\t\t\t\t\tif (dp[la][r][jj][kk][tt] == 0) continue;\n\t\t\t\t\t\t\t\t\tint nj, nk, nt;\n\t\t\t\t\t\t\t\t\tif (tt == 1) {\n\t\t\t\t\t\t\t\t\t\tnj = j, nk = kk ^ 1, nt = ((t | tt) | (k == (jj ^ 1)));\n\t\t\t\t\t\t\t\t\t\tadd(tb[now][r][nj][nk][nt], tb[now][la-1][j][k][t] * dp[la][r][jj][kk][tt] % MOD);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tnj = j, nk = kk ^ 1, nt = ((t | tt) | (k == (jj ^ 1)));\n\t\t\t\t\t\t\t\t\t\tadd(tb[now][r][nj][nk][nt], tb[now][la-1][j][k][t] * dp[la][r][jj][kk][tt] % MOD);\n\n\t\t\t\t\t\t\t\t\t\tnj = j, nk = kk, nt = ((t | tt) | (k == jj));\n\t\t\t\t\t\t\t\t\t\tadd(tb[now][r][nj][nk][nt], tb[now][la-1][j][k][t] * dp[la][r][jj][kk][tt] % MOD);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint num = mh[l][r] - lo - 1;\n\tll p[2];\n\n\tif (num == 0) {\n\t\tp[0] = 1;\n\t\tp[1] = 0;\n\t} else {\n\t\tp[0] = p[1] = mod_pow(2, num - 1);\n\t}\n\n\trep(j, 2) {\n\t\trep(k, 2) {\n\t\t\trep(t, 2) {\n\t\t\t\tif (t == 1) {\n\t\t\t\t\tbool b = (num & 1);\n\t\t\t\t\tadd(dp[l][r][j^b][k^b][t], tb[now][r][j][k][t]);\n\t\t\t\t} else {\n\t\t\t\t\trep(b, 2) {\n\t\t\t\t\t\tadd(dp[l][r][j^b][k^b][t], tb[now][r][j][k][t] * p[b] % MOD);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> N;\n\trep(i, N) cin >> h[i];\n\n\trep(i, N) {\n\t\tint d = 2e9;\n\t\tfor (int j = i; j < N; ++j) {\n\t\t\td = min(d, h[j]);\n\t\t\tmh[i][j] = d;\n\t\t}\n\t}\n\n\tsub[1][0][0][0] = sub[1][1][1][0] = 1;\n\n\tfor (int i = 1; i < N; ++i) {\n\t\trep(j, 2) {\n\t\t\trep(k, 2) {\n\t\t\t\trep(l, 2) {\n\t\t\t\t\tif (sub[i][j][k][l] == 0) continue;\n\t\t\t\t\trep(nx, 2) {\n\t\t\t\t\t\tadd(sub[i+1][j][nx][l | (k == nx)], sub[i][j][k][l]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint k = 0;\n\tcalc(0, N-1, 0, k);\n\tll ret = 0;\n\trep(j, 2) {\n\t\trep(k, 2) {\n\t\t\trep(t, 2) {\n\t\t\t\tadd(ret, dp[0][N-1][j][k][t]);\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ret % MOD << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nlong long N, K;\nlong long H[100];\nvector<long long> L;\nlong long P[60];\nlong long D[101][101];\n#define MOD 1000000007LL\nlong long R;\n\nlong long pow(long long x) {\n  long long r = 1;\n  for(long long b = 0; b < 60; ++b) {\n    if((1LL << b) & x) (r *= P[b]) %= MOD;\n  }\n  return r;\n}\nint main() {\n  P[0] = 2LL;\n  for(long long i = 1; i < 60; ++i) {\n    P[i] = P[i - 1] * P[i - 1] % MOD;\n  }\n  cin >> N;\n  L.push_back(0);\n  for(long long i = 0; i < N; ++i) {\n    cin >> H[i]; L.push_back(H[i]);\n  }\n  sort(L.begin(), L.end());\n  L.erase(unique(L.begin(), L.end()), L.end());\n  K = L.size();\n  /*for(long long k = 0; k < K; ++k) {\n    cout << \"L[\" << k << \"] : \" << L[k] << endl;\n  }*/\n  long long prev_l = 0; D[0][0] = 1;\n  for(long long i = 0; i < N; ++i) {\n    long long l = lower_bound(L.begin(), L.end(), H[i]) - L.begin();\n    /*cout << \"i=\" << i\n      << \" l=\" << l << \" prev_l=\" << prev_l << endl;*/\n    if(prev_l >= l) {\n      (D[i + 1][0] += 2 * D[i][0]) %= MOD;\n      for(long long k = 1; k <= l; ++k) {\n        (D[i + 1][k] += D[i][k]) %= MOD;\n      }\n      for(long long k = l + 1; k <= prev_l; ++k) {\n        (D[i + 1][0] += 2 * D[i][k]) %= MOD;\n      }\n    } else {\n      D[i + 1][0] += 2 * D[i][0];\n      for(long long k = prev_l + 1; k <= l; ++k) {\n        (D[i + 1][k] +=\n          2 * (pow(L[k] - L[k - 1] - (k - 1 == 0 ? 1 : 0)) - 1)\n          * pow(L[l] - L[k]) % MOD\n          * D[i][0]) %= MOD;\n      }\n      long long C = pow(L[l] - L[prev_l]);\n      for(long long k = 1; k <= prev_l; ++k) {\n        (D[i + 1][k] += C * D[i][k]) %= MOD;\n      }\n    }\n    /*for(long long k = 0; k <= l; ++k) {\n      cout << \"  \" << \"D[][\" << k << \"]=\"\n        << D[i + 1][k] << endl;\n    }*/\n    prev_l = l;\n  }\n  for(long long k = 0; k < K; ++k) {\n    (R += D[N][k]) %= MOD;\n  }\n  cout << R << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n\nconst int mod = 1e9 + 7;\ntemplate<typename T>\nT add(T x) {\n  return x;\n}\ntemplate<typename T, typename... Ts>\nT add(T x, Ts... y) {\n  T res = x + add(y...);\n  if (res >= mod)\n    res -= mod;\n  return res;\n}\ntemplate<typename T, typename... Ts>\nT sub(T x, Ts... y) {\n  return add(x, mod - add(y...));\n}\ntemplate<typename T, typename... Ts>\nvoid udd(T& x, Ts... y) {\n  x = add(x, y...);\n}\ntemplate<typename T, typename... Ts>\nvoid uub(T& x, Ts... y) {\n  x = sub(x, y...);\n}\ntemplate<typename T>\nT mul(T x) {\n  return x;\n}\ntemplate<typename T, typename... Ts>\nT mul(T x, Ts... y) {\n  return (x * 1ll * mul(y...)) % mod;\n}\ntemplate<typename T, typename... Ts>\nvoid uul(T& x, Ts... y) {\n  x = mul(x, y...);\n}\nint bin(int a, ll deg) {\n  int r = 1;\n  while (deg) {\n    if (deg & 1)\n      uul(r, a);\n    deg >>= 1;\n    uul(a, a);\n  }\n  return r;\n}\nint inv(int x) {\n  assert(x);\n  return bin(x, mod - 2);\n}\n\nconst int maxn = 105;\nint h[maxn];\nint d[maxn][maxn];\nvector<int> hs;\n\nsigned main() {\n#ifdef LOCAL\n  assert(freopen(\"d.in\", \"r\", stdin));\n#endif\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; ++i) {\n    cin >> h[i];\n    hs.push_back(h[i]);\n  }\n  hs.push_back(0);\n  hs.push_back(1e9 + 7);\n  sort(hs.begin(), hs.end());\n  hs.erase(unique(hs.begin(), hs.end()), hs.end());\n  int last = hs.size() - 2;\n  d[0][last] = 1;\n  for (int i = 0; i < n; ++i) {\n    //for (int j = 0; j <= last; ++j) {\n      //cerr << d[i][j] << ' ';\n    //}\n    //cerr << '\\n';\n    for (int j = 0; j <= last; ++j) {\n      if (i && h[i] <= h[i - 1]) {\n        int nj = hs[j] < h[i] ? j : last;\n        udd(d[i + 1][nj], d[i][j]); //inv\n        if (nj == last) {\n          udd(d[i + 1][nj], d[i][j]); //copy\n        }\n      } else {\n        int ph = i ? h[i - 1] : 0;\n        if (j != last) {\n          udd(d[i + 1][j], mul(d[i][j], bin(2, h[i] - ph)));\n        } else {\n          udd(d[i + 1][last], mul(2, d[i][j]));\n          int from = lower_bound(hs.begin(), hs.end(), ph) - hs.begin();\n          for (int nj = from; hs[nj] < h[i]; ++nj) {\n            int ways = bin(2, h[i] - hs[nj]);\n            int bad = bin(2, h[i] - hs[nj + 1] + 1);\n            if (i || nj > 0) {\n              uul(ways, 2);\n            }\n            //if (d[i][j]) {\n              //cerr << \"wb \" << ways << ' ' << bad << '\\n';\n            //}\n            uub(ways, bad);\n            udd(d[i + 1][nj], mul(d[i][j], ways));\n          }\n        }\n      }\n    }\n  }\n    //for (int j = 0; j <= last; ++j) {\n      //cerr << d[n][j] << ' ';\n    //}\n    //cerr << '\\n';\n  int res = 0;\n  for (int j = 0; j <= last; ++j) {\n    udd(res, d[n][j]);\n  }\n  cout << res << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define il inline\n#define ll long long\nconst int N=105,P=1e9+7;\n\nint n,h[N],A=1;\nstruct node{int a,b;}B;\n\nil int ksm(int a,int b)\n{\n    int res=1;\n    for ( ; b; b>>=1,a=(ll)a*a%P) if (b&1) res=(ll)res*a%P;\n    return res;\n}\n\nil node sol(int l,int r,int x)\n{\n    node t; int i,cnt,mn=1e9+1,a=1,b=1,L=0,R=r-l+1;\n    for (i=l; i<=r; i++)\n        if (h[i]<mn) mn=h[i],cnt=1;\n        else if (h[i]==mn) cnt++;\n    if (cnt==R) return (node){(ksm(2,R)-2+P)%P,ksm(2,mn-x-1)};\n    for (i=l; i<r+2; i++)\n         if (!L&&h[i]>mn) L=i;\n         else if (L&&(h[i]<=mn||i>r))\n         {\n             R-=i-L,t=sol(L,i-1,mn),L=0;\n             a=(ll)a*(t.a+4ll*t.b)%P,b=2ll*b*t.b%P;\n         }\n    a=(a-b+P)%P;\n    return (node){((ll)a*ksm(2,R)+(ll)b*(ksm(2,R)-2+P))%P,(ll)b*ksm(2,mn-x-1)%P};\n}\n\nint main()\n{\n    scanf(\"%d\",&n); int i;\n    for (i=1; i<=n; i++) scanf(\"%d\",h+i);\n    if (n==1) return printf(\"%d\",ksm(2,h[1])),0;\n\n    for (i=1; i<=n; i++) if (h[i]>h[i-1]&&h[i]>h[i+1])\n        A=(ll)A*ksm(2,h[i]-std::max(h[i-1],h[i+1]))%P,h[i]=std::max(h[i-1],h[i+1]);\n    B=sol(1,n,0),printf(\"%d\",(ll)A*(B.a+2ll*B.b)%P);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author majk\n */\n\n#ifndef MAJK_LIB\n#define MAJK_LIB\n\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <fstream>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <algorithm>\n#include <numeric>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <array>\n#include <bitset>\nusing namespace std;\n\n#define x first\n#define y second\ntypedef std::pair<int,int> pii; typedef long long ll; typedef unsigned long long ull; typedef unsigned int ui; typedef pair<ui,ui> puu;\n\ntemplate <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate <typename T, typename U> std::ostream&operator<<(std::ostream&o, const pair<T,U>&p) {o << p.x << ' ' << p.y; return o;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {if(t.empty())o<<'\\n';for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\nui logceil(ll x) { return x?8*sizeof(ll)-__builtin_clzll(x):0; }\n\nnamespace std { template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}}; }\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename F> double bshd(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){l=m;}else{h=m;}}return (l+h)/2;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename F> double bsld(double l,double h,const F&f){ui r=200;while(r--){double m=(l+h)/2;if(f(m)){h=m;}else{l=m;}}return (l+h)/2;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector2<T>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector2<T>>(a,vector2<T>(b,c,t)){}};\ntemplate<typename T>class vector4:public vector<vector3<T>>{public:vector4(){} vector4(size_t a,size_t b,size_t c,size_t d,T t=T()):vector<vector3<T>>(a,vector3<T>(b,c,d,t)){}};\ntemplate<typename T>class vector5:public vector<vector4<T>>{public:vector5(){} vector5(size_t a,size_t b,size_t c,size_t d,size_t e,T t=T()):vector<vector4<T>>(a,vector4<T>(b,c,d,e,t)){}};\n\n\n#endif\n#ifndef MOD_H\n#define MOD_H\n\n\n\ntemplate <unsigned int N> class Field {\n    typedef unsigned int ui;\n    typedef unsigned long long ull;\n\tinline ui pow(ui a, ui p){ui r=1,e=a;while(p){if(p&1){r=((ull)r*e)%N;}e=((ull)e*e)%N;p>>=1;}return r;}\n\t/*extended GCD(slow):ll t=0,nt=1,r=N,nr=a;while(nr){ll q=r/nr;t-=q*nt;swap(t,nt);r-=q*nr;swap(r,nr);}assert(r<=1);return(t<0)?t+N:t;*/\n\tinline ui inv(ui a){return pow(a,N-2);}\npublic:\n    inline Field(int x = 0) : v(x<0?N+x:x) {}\n\tinline Field<N> pow(int p){return (*this)^p; }\n\tinline Field<N> operator^(int p){return {(int)pow(v,(ui)p)};}\n    inline Field<N>&operator+=(const Field<N>&o) {if (v+o.v >= N) v += o.v - N; else v += o.v; return *this; }\n    inline Field<N>&operator-=(const Field<N>&o) {if (v<o.v) v -= o.v-N; else v-=o.v; return *this; }\n    inline Field<N>&operator*=(const Field<N>&o) {v=(ull)v*o.v % N; return *this; }\n    inline Field<N>&operator/=(const Field<N>&o) { return *this*=inv(o.v); }\n    inline Field<N> operator+(const Field<N>&o) const {Field<N>r{*this};return r+=o;}\n    inline Field<N> operator-(const Field<N>&o) const {Field<N>r{*this};return r-=o;}\n    inline Field<N> operator*(const Field<N>&o) const {Field<N>r{*this};return r*=o;}\n    inline Field<N> operator/(const Field<N>&o) const {Field<N>r{*this};return r/=o;}\n    inline Field<N> operator-() {if(v) return {(int)(N-v)}; else return {0};};\n    inline Field<N>& operator++() { ++v; if (v==N) v=0; return *this; }\n    inline Field<N> operator++(int) { Field<N>r{*this}; ++*this; return r; }\n    inline Field<N>& operator--() { --v; if (v==-1) v=N-1; return *this; }\n    inline Field<N> operator--(int) { Field<N>r{*this}; --*this; return r; }\n    inline bool operator==(const Field<N>&o) const { return o.v==v; }\n\tinline bool operator!=(const Field<N>&o) const { return o.v!=v; }\n\tinline explicit operator ui() const { return v; }\n\tinline static vector<Field<N>>fact(int t){vector<Field<N>>F(t+1,1);for(int i=2;i<=t;++i){F[i]=F[i-1]*i;}return F;}\n\tinline static vector<Field<N>>invfact(int t){vector<Field<N>>F(t+1,1);Field<N> X{1};for(int i=2;i<=t;++i){X=X*i;}F[t]=1/X;for(int i=t-1;i>=2;--i){F[i]=F[i+1]*(i+1);}return F;}\nprivate: ui v;\n};\ntemplate<unsigned int N>istream &operator>>(std::istream&is,Field<N>&f){unsigned int v;is>>v;f=v;return is;}\ntemplate<unsigned int N>ostream &operator<<(std::ostream&os,const Field<N>&f){return os<<(unsigned int)f;}\ntemplate<unsigned int N>Field<N> operator+(int i,const Field<N>&f){return Field<N>(i)+f;}\ntemplate<unsigned int N>Field<N> operator-(int i,const Field<N>&f){return Field<N>(i)-f;}\ntemplate<unsigned int N>Field<N> operator*(int i,const Field<N>&f){return Field<N>(i)*f;}\ntemplate<unsigned int N>Field<N> operator/(int i,const Field<N>&f){return Field<N>(i)/f;}\n\n\ntypedef Field<1000000007> FieldMod;\n\nstruct Ring {\n\ttemplate <typename T>\n\tstatic T div(T p, T q, T N) {\n\t\tT t=0,nt=1,r=N,nr=q;\n\t\twhile(nr!=0){ T q=r/nr;t-=q*nt;r-=q*nr;swap(t,nt);swap(r,nr); }\n\t\tt=(t<0)?t+N:t;\n\t\tr=(r<0)?r+N:r;\n\t\tif (gcd(p,N)%r!=0) { return 0; }\n\t\treturn (t*p/r)%N;\n\t}\n};\n#endif\n\n\nclass DHistogramColoring {\npublic:\n    int brr(vector<vector<int>> &Z, const vector<int> &A, int I, int J) {\n        while (I < A.size() && A[I] == J) { I++; J = 0; }\n        if (I == A.size()) return 1;\n        int ans = 0;\n        if (I != 0 && A[I-1] > J && J > 0) {\n            Z[I][J] = 0;\n            if (Z[I-1][J-1] + Z[I-1][J] + Z[I][J-1] + Z[I][J] == 2) ans += brr(Z, A, I, J+1);\n            Z[I][J] = 1;\n            if (Z[I-1][J-1] + Z[I-1][J] + Z[I][J-1] + Z[I][J] == 2) ans += brr(Z, A, I, J+1);\n        } else {\n\n            Z[I][J] = 0;\n            ans += brr(Z, A, I, J+1);\n            Z[I][J] = 1;\n            ans += brr(Z, A, I, J+1);\n        }\n        return ans;\n    }\n\n    int brute(vector<int> A) {\n        int N = A.size();\n        vector<vector<int>> Z(N);\n        for (int i = 0; i < N; ++i) {\n            Z[i].resize(A[i]);\n        }\n        return brr(Z, A, 0, 0);\n    }\n\n    FieldMod solve(vector<int> A) {\n        int N = A.size();\n        if (N == 1) return FieldMod{2}.pow(A[0]);\n        vector<FieldMod> D(N+1, 0);\n        D[0] = 1;\n        for (int i = 0; i <= N; ++i) {\n            for (int j = i+1; j <= N; ++j) {\n                ll choices = 0;\n                int lo = A[i];\n                for (int k = i; k < j; ++k) {\n                    choices += max(0, A[k] - (k==i?0:A[k-1]));\n                    lo = min(lo, A[k]);\n                }\n\n                if (i != 0 && j != N) {\n                    choices -= min(A[i-1], A[i]);\n                    choices -= min(A[j-1], A[j]);\n                    choices += min(lo, min(A[i-1],A[j]));\n                } else if (i == 0 && j != N) {\n                    choices -= min(A[j-1], A[j]);\n                    choices++;\n                } else if (i == 0 && j == N) {\n                    // ok\n                } else {\n                    choices -= min(A[i-1], A[i]);\n                }\n\n                D[j] += D[i] * FieldMod{2}.pow(choices % 1000000006);\n            }\n        }\n        return D[N];\n    }\n\n    void solve(istream& cin, ostream& cout) {\n        int N; cin >> N;\n        vector<int> A(N); cin >> A;\n        if (N == 1) {\n            cout << FieldMod{2}.pow(A[0]) << endl;\n            return;\n        }\n\n        FieldMod mul = 1;\n        if (A[0] > A[1]) {\n            mul *= FieldMod{2}.pow(A[0]-A[1]);\n            A[0] = A[1];\n        }\n\n        if (A[N-1] > A[N-2]) {\n            mul *= FieldMod{2}.pow(A[N-1]-A[N-2]);\n            A[N-1] = A[N-2];\n        }\n\n        for (int i = 1; i < N-1; ++i) {\n            if (A[i] > max(A[i-1], A[i+1])) {\n                mul *= FieldMod{2}.pow(A[i]-max(A[i-1], A[i+1]));\n                A[i] = max(A[i-1], A[i+1]);\n            }\n        }\n\n        for (int i = 0; i < N; ++i) {\n            if (A[i] == 1) {\n                A[i] = 0;\n                mul *= 2;\n            }\n        }\n\n        vector<int> B;\n        FieldMod ans = 1;\n        for (int i = 0; i < N; ++i) {\n            if (A[i] == 0) {\n                if (!B.empty()) {\n                    ans *= solve(B);\n                    B.clear();\n                }\n            } else {\n                B.push_back(A[i]);\n            }\n        }\n\n        if (!B.empty()) ans *= solve(B);\n        cout << ans * mul << '\\n';\n    }\n};\n\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tDHistogramColoring solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\n#define MOD 1000000007\n#define MAX_P 200005\nInt fact[MAX_P],inv[MAX_P],finv[MAX_P];;\nInt extgcd(Int a,Int b,Int& x,Int& y){\n  Int d=a;\n  if(b!=0){\n    d=extgcd(b,a%b,y,x);\n    y-=(a/b)*x;\n  }else{\n    x=1;y=0;\n  }\n  return d;\n}\nInt mod_inverse(Int a,Int mod){\n  Int x,y;\n  extgcd(a,mod,x,y);\n  return (mod+x%mod)%mod;\n}\n\nInt mod_pow(Int x,Int n,Int mod){\n  Int res=1;\n  while(n){\n    if(n&1) (res*=x)%=mod;\n    (x*=x)%=mod;\n    n>>=1;\n  }\n  return res;\n}\n\nInt mod_inverse2(Int a,Int mod){\n  return mod_pow(a,mod-2,mod);\n}\n\nvoid init(Int mod){\n  fact[0]=1;\n  for(Int i=1;i<MAX_P;i++)\n    fact[i]=(fact[i-1]*i)%mod;\n\n  inv[1]=1;\n  for(Int i=2;i<MAX_P;i++)\n    inv[i]=inv[mod%i]*(mod-mod/i)%mod;\n  \n  finv[0]=1;\n  for(Int i=1;i<MAX_P;i++)\n    finv[i]=finv[i-1]*inv[i]%mod;\n}\n\nInt mod_fact(Int n,Int mod,Int& e){\n  e=0;\n  if(n==0) return 1;\n  Int res=mod_fact(n/mod,mod,e);\n  e+=n/mod;\n  if(n/mod%2!=0)return res*(mod-fact[n%mod]) %mod;\n  return res*fact[n%mod]%mod;\n}\n\nInt mod_comb(Int n,Int k,Int mod){\n  if(n==k||k==0) return 1;\n  Int e1,e2,e3;\n  Int a1=mod_fact(n,mod,e1),a2=mod_fact(k,mod,e2),a3=mod_fact(n-k,mod,e3);\n  if(e1>e2+e3) return 0;\n  return a1*mod_inverse(a2*a3%mod,mod)%mod;\n}\n\nInt mod_comb2(Int n,Int k,Int mod){\n  Int res=1;\n  for(Int i=0;i<k;i++){\n    res*=(n-i)%mod;\n    res%=mod;\n    res*=mod_inverse(i+1,mod);\n    res%=mod;\n  }\n  return res;\n}\n\n//only for prime mod\nInt mod_comb3(Int n,Int k,Int mod){\n  if(k<0||k>n) return 0;\n  return fact[n]*finv[k]%mod*finv[n-k]%mod;\n}\n\nInt montmort(Int n,Int mod){\n  Int res=0,inv=1;\n  for(Int k=2;k<=n;k++){\n    (inv*=mod_inverse(k,mod))%=mod;\n    if(k%2) (res+=mod-inv)%=mod;\n    else (res+=inv)%=mod;\n  }\n  for(Int i=1;i<=n;i++)\n    (res*=i)%=mod;\n  return res;\n}\n\n// calculate P(t) from given points in [0,N]\nInt LagrangePolynomial(vector<Int> &y,Int t,const Int mod){\n  init(mod);\n  Int n=y.size()-1;\n  Int num=1;\n  for(Int i=0;i<=n;i++)\n    num=num*((t-i)%mod)%mod;\n  Int res=0;\n  for(Int i=0;i<=n;i++){\n    Int tmp=(y[i]*num%mod)*mod_inverse((t-i)%mod,mod)%mod;\n    tmp=tmp*finv[i]%mod;\n    tmp=tmp*finv[n-i]%mod;\n    if((n-i)&1) tmp=mod-tmp;\n    res=(res+tmp)%mod;\n  }\n  return res;\n}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<Int> h(n);\n  for(Int i=0;i<n;i++) cin>>h[i];\n  \n  using P = pair<Int, Int>;\n  function<P(Int, Int, Int)> dfs=\n    [&](Int l,Int r,Int d)->P{\n      Int flg=1;\n      for(Int i=l;i<r;i++)\n\tflg&=h[i]==h[l];\n      if(flg){\n\tInt x=2;\n\tInt y=mod_pow(2,r-l,MOD)+MOD-2;\n\tx*=mod_pow(2,h[l]-d-1,MOD);\n\tx%=MOD;\n\ty%=MOD;\n\t//cout<<l<<\" \"<<r<<\":\"<<x<<\" \"<<y<<endl;\n\treturn P(x,y);\n      }\n      Int t=h[l],u=0;\n      for(Int i=l;i<r;i++) chmin(t,h[i]);\n      vector<P> v;\n      for(Int i=l;i<r;i++){\n\tif(h[i]==t) continue;\n\tInt j=i;\n\twhile(j<r&&h[j]!=t) j++;\n\tv.emplace_back(dfs(i,j,t));\n\tu+=j-i;\n\ti=j-1;\n      }\n      Int w=(r-l)-u;\n      Int x=2,y=1;\n      for(auto p:v){\n\tx*=p.first;\n\ty*=(p.first*2+p.second)%MOD;\n\tx%=MOD;\n\ty%=MOD;\n      }\n      y*=mod_pow(2,w,MOD);\n      y%=MOD;\n      y+=MOD-x;\n      y%=MOD;\n      x*=mod_pow(2,t-d-1,MOD);\n      x%=MOD;\n      \n      //cout<<l<<\" \"<<r<<\" \"<<w<<\"*\"<<x<<\" \"<<y<<endl;\n      return P(x,y);\n    };\n  \n  auto p=dfs(0,n,0);\n  Int ans=(p.first+p.second)%MOD;\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<bitset>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; i++ )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef pair<ll,int> pli;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\nint dx[4]={1,0,-1,0} , dy[4]={0,1,0,-1} ;\n\nll dp[111][111][2];\nint a[111];\n\nll powmod(ll n,ll k){\n    ll ret=1;\n    while(k>0){\n        if(k&1)ret=ret*n%mod;\n        n=n*n%mod;\n        k>>=1;\n    }\n    return ret;\n}\n\nll rec(int l,int r,int h,int flag){\n    if(dp[l][r][flag]!=-1)return dp[l][r][flag];\n    if(l+1==r){\n        if(flag)return dp[l][r][flag]=powmod(2,a[l]-h);\n        else return dp[l][r][flag]=0;\n    }\n    int mi=inf,ma=0;\n    REP(i,l,r){\n        mi=min(mi,a[i]);\n        ma=max(ma,a[i]);\n    }\n    ll ret1=1;\n    ll pos=l-1;\n    REP(i,l,r){\n        if(a[i]==mi){\n            if(i-pos>1)ret1*=rec(pos+1,i,mi,1);\n            ret1%=mod;\n            pos=i;\n        }\n    }\n    if(r-pos>1)ret1=ret1*rec(pos+1,r,mi,1)%mod;\n    ret1=ret1;\n    if(flag) return dp[l][r][flag]=ret1*powmod(2,mi-h)%mod;\n    ll ret2=1;\n    pos=l-1;\n    REP(i,l,r){\n        if(a[i]==mi){\n            ret2=2*ret2%mod;\n            if(i-pos>1)ret2*=(2*rec(pos+1,i,mi,1)+rec(pos+1,i,mi,0));\n            ret2%=mod;\n            pos=i;\n        }\n    }\n    if(r-pos>1)ret2=ret2*(2*rec(pos+1,r,mi,1)+rec(pos+1,r,mi,0))%mod;\n    ret2=(ret2-ret1*2+2*mod)%mod;\n    return dp[l][r][flag]=ret2;\n}\nint main(){\n   int n;\n   cin>>n;\n   rep(i,n)cin>>a[i];\n   rep(i,n+1)rep(j,n+1)rep(k,2)dp[i][j][k]=-1;\n   ll ans=rec(0,n,0,0)+rec(0,n,0,1);\n   cout<<ans%mod<<endl;\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define SZ 666666\nint n,h[SZ];\nconst int MOD=1e9+7;\nll qp(ll a,ll b)\n{\n\tll x=1; a%=MOD;\n\twhile(b)\n\t{\n\t\tif(b&1) x=x*a%MOD;\n\t\ta=a*a%MOD; b>>=1;\n\t}\n\treturn x;\n}\nstruct arr\n{\nll g[2][2],e; bool m;\nvoid mu(ll x)\n{\n\t(g[0][0]*=x)%=MOD;\n\t(g[0][1]*=x)%=MOD;\n\t(g[1][0]*=x)%=MOD;\n\t(g[1][1]*=x)%=MOD;\n}\nvoid clr() {memset(&g,0,sizeof g);e=m=0;}\nll all() {return (g[0][0]+g[0][1]+g[1][0]+g[1][1]+e)%MOD;}\n};\narr tf(arr a)\n{\n\tif(a.m) return a;\n\tarr s=a;\n\tfor(int i=0;i<2;++i)\n\t\tfor(int j=0;j<2;++j)\n\t\t\t(s.g[j][i]+=a.g[i][j])%=MOD;\n\treturn s;\n}\narr operator * (arr a,arr b)\n{\n\tif(a.m) return b;\n\tif(b.m) return a;\n\tarr t; t.clr();\n\tt.e=a.e*b.e%MOD;\n\tfor(int i=0;i<2;++i)\n\t\tfor(int j=0;j<2;++j)\n\t\t\t(t.e+=a.g[i][j]*b.e)%=MOD,\n\t\t\t(t.e+=a.e*b.g[i][j])%=MOD;\n\tfor(int i=0;i<2;++i)\n\t\tfor(int j=0;j<2;++j) if(a.g[i][j])\n\t\t\tfor(int k=0;k<2;++k)\n\t\t\t\tfor(int l=0;l<2;++l)\n\t\t\t\t{\n\t\t\t\t\tif(j==k) (t.e+=a.g[i][j]*b.g[k][l])%=MOD;\n\t\t\t\t\telse (t.g[i][l]+=a.g[i][j]*b.g[k][l])%=MOD;\n\t\t\t\t}\n\treturn t;\n}\narr go(int x,int y,int b)\n{\n//\tcerr<<\"REAL\"<<x<<\"~\"<<y<<\"\\n\";\n\tif(x>y)\n\t{\n\t\tarr xx;\n\t\txx.clr(); xx.m=1;\n\t\treturn xx;\n\t}\n\tif(x==y)\n\t{\n\t\tarr xx; xx.clr();\n\t\txx.g[0][0]=xx.g[1][1]=qp(2,h[x]-b-1);\n//\t\tcout<<x<<\":\"<<y<<\" \"<<xx.g[0][0]<<\"!!\\n\";\n\t\treturn xx;\n\t}\n//\tcout<<x<<\"~\"<<y<<\"  \"<<b<<\"\\n\";\n\tint mi=1e9;\n\tfor(int i=x;i<=y;++i)\n\t\tmi=min(mi,h[i]);\n\tarr ans; ans.clr(); ans.m=1; int cl=x;\n\tfor(int i=x;i<=y;++i)\n\t{\n\t\tif(h[i]==mi)\n\t\t{\n\t\t\tarr s=go(cl,i-1,mi); s=tf(s);\n\t\t\tans=ans*s; cl=i+1;\n\t\t\ts.clr(); s.g[0][0]=s.g[1][1]=1;\n\t\t\tans=ans*s;\n\t\t}\n\t}\n\tans=ans*tf(go(cl,y,mi));\n//\tcout<<x<<\"~\"<<y<<\"  \"<<b<<\" \"<<ans.all()<<\" extra\"<<mi-b-1<<\"\\n\";\n//\tcout<<ans.g[0][0]<<\",\"<<ans.g[0][1]<<\",\"<<ans.g[1][0]<<\",\"<<ans.g[1][1]<<\" \"<<ans.e<<\"||\\n\";\n\tif(mi-b-1)\n\t{\n\t\tans=tf(ans);\n\t\tans.mu(qp(2,mi-b-2));\n\t}\n\treturn ans;\n}\nint main()\n{\n\tcin>>n;\n\tfor(int i=1;i<=n;++i)\n\t\tcin>>h[i];\n\tarr t=go(1,n,0);\n\tll ans=t.all();\n\tans=(ans%MOD+MOD)%MOD;\n\tcout<<ans<<\"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define fi first\n#define se second\n\nconst int N = 105, mod = 1e9 + 7;\nint n, h[N];\n\nvoid add (int &_a, int _b) {\n    _a += _b;\n    if (_a >= mod) _a -= mod;\n}\n\nint binPow (int _a, int _n) {\n    int ret = 1;\n    for (; _n; _n >>= 1, _a = 1LL * _a * _a % mod) if (_n & 1) ret = 1LL * ret * _a % mod;\n    return ret;\n}\n\npair<int, int> solve (int l, int r) {\n    int minH = mod;\n\n    bool rect = 1;\n    for (int i = l; i + 1 <= r; ++i) if (h[i] != h[i + 1]) rect = 0;\n\n    if (rect) return { (binPow(2, r - l + 1) + binPow(2, min(h[l] - h[l - 1], h[r] - h[r + 1]) ) - 2 + mod) % mod,\n                      binPow(2, min(h[l] - h[l - 1], h[r] - h[r + 1]) ) };\n\n    for (int i = l; i <= r; ++i) minH = min(minH, h[i]);\n    vector< pair<int, int> > dp;\n    vector< pair<int, int> > range;\n    for (int i = l, lst = -1; i <= r; ++i) {\n        if (h[i] == minH) lst = -1;\n        else {\n            if (lst == -1) lst = i;\n            if (i == r || h[i + 1] == minH) dp.pb( { solve(lst, i) } );\n        }\n    }\n    for (int i = l, lst = -1; i <= r; ++i) {\n        if (h[i] > minH) lst = -1;\n        else {\n            if (lst == -1) lst = i;\n            if (i == r || h[i + 1] > minH) range.pb( { lst, i } );\n        }\n    }\n\n//    cout << \"l = \" << l << \"  r = \" << r << '\\n';\n//    for (auto _ : dp) cout << _.fi << ' '; cout << '\\n';\n\n    pair<int, int> ret = { 0, 0 };\n\n    int tmp = 1;\n    for (auto _ : dp) tmp = 1LL * tmp * ( (_.fi + _.se) % mod) % mod;\n    for (auto _ : range) tmp = 1LL * tmp * binPow(2, _.se - _.fi + 1) % mod;\n\n//    cout << \"tmp = \" << tmp << '\\n';\n\n    add(ret.fi, tmp);\n\n    tmp = 1;\n    for (auto _ : dp) tmp = 1LL * tmp * _.se % mod;\n    add(tmp, tmp);\n\n//    cout << \"tmp = \" << tmp << '\\n';\n\n    add(ret.fi, 1LL * tmp * ( (binPow(2, minH - max(h[l - 1], h[r + 1]) - 1) - 1 + mod) % mod) % mod);\n\n    add(ret.se, 1LL * tmp * binPow(2, minH - max(h[l - 1], h[r + 1]) - 1) % mod);\n\n//    cout << ret.fi << \"  \" << ret.se << '\\n';\n\n    return ret;\n}\n\nint main () {\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\n    cin >> n;\n    for (int i = 1; i <= n; ++i) cin >> h[i];\n\n    int ans = solve(1, n).fi;\n    assert(ans >= 0 && ans < mod);\n    cout << (ans % mod + mod) % mod;\n\n    return 0;\n}\n/*\n3\n4 2 5\n\n320\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cstring>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define TRACE(x) cout << #x << \" = \" << x << endl\n#define _ << \" _ \" <<\n\ntypedef long long llint;\n\nconst int mod = 1e9 + 7;\n\ninline int add(int a, int b) { return a + b >= mod ? a + b - mod : a + b; }\n\ninline int sub(int a, int b) { return a >= b ? a - b : a - b + mod; }\n\ninline int mul(int a, int b) { return llint(a) * b % mod; }\n\nint powmod(int a, llint b) {\n  if (b == 0) return 1;\n  if (b & 1) return mul(a, powmod(a, b - 1));\n  return powmod(mul(a, a), b / 2);\n}\n\nconst int MAX = 110;\n\nint h[MAX], pw[MAX];\n\npair<int, int> solve(int a, int b, int s) {\n  if (b - a == 1) {\n    int w = powmod(2, h[a] - s);\n    return {w, w};\n  }\n\n  int m = *min_element(h + a, h + b);\n\n  vector<pair<int, int>> v;\n  int i = a;\n  while (i < b) {\n    int j = i;\n    while (j < b && (h[i] == m) == (h[j] == m)) j++;\n    v.push_back({i, j});\n    i = j;\n  }\n\n  int fTotal = 1;\n  int fAlternate = 2;\n\n  for (auto& p : v) {\n    int x = p.first, y = p.second;\n    if (h[x] != m) {\n      auto g = solve(x, y, m);\n      fTotal = mul(fTotal, add(g.first, g.second));\n      fAlternate = mul(fAlternate, g.first);\n    } else {\n      fTotal = mul(fTotal, pw[y - x]);\n    }\n  }\n\n  fTotal = sub(fTotal, fAlternate);\n  fAlternate = mul(fAlternate, powmod(2, m - s - 1));\n  fTotal = add(fTotal, fAlternate);\n  return {fAlternate, fTotal};\n}\n\nint main(void) {\n  int N;\n  scanf(\"%d\", &N);\n  REP(i, N) scanf(\"%d\", &h[i]);\n\n  pw[0] = 1;\n  REP(i, N) pw[i + 1] = mul(pw[i], 2);\n\n  auto g = solve(0, N, 0);\n  printf(\"%d\\n\", g.second);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * File    : D2.cpp\n * Author  : Kazune Takahashi\n * Created : 2018-7-15 16:51:34\n * Powered by Visual Studio Code\n */\n\n#include <iostream>\n#include <iomanip>   // << fixed << setprecision(xxx)\n#include <algorithm> // do { } while ( next_permutation(A, A+xxx) ) ;\n#include <vector>\n#include <string> // to_string(nnn) // substr(m, n) // stoi(nnn)\n#include <complex>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <map> // if (M.find(key) != M.end()) { }\n#include <set>\n#include <functional>\n#include <random> // auto rd = bind(uniform_int_distribution<int>(0, 9), mt19937(19920725));\n#include <chrono> // std::chrono::system_clock::time_point start_time, end_time;\n// start = std::chrono::system_clock::now();\n// double elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(end_time-start_time).count();\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\n#define DEBUG 0 // change 0 -> 1 if we need debug.\n\ntypedef long long ll;\n\n// const int dx[4] = {1, 0, -1, 0};\n// const int dy[4] = {0, 1, 0, -1};\n\n// const int C = 1e6+10;\nconst ll infty = 1000000007;\nconst ll MOD = 1000000007;\n\ntypedef tuple<ll, ll> P;\n\nint N;\nll H[110];\n\nlong long power(long long x, long long n)\n{\n  if (n == 0)\n  {\n    return 1;\n  }\n  else if (n % 2 == 1)\n  {\n    return (x * power(x, n - 1)) % MOD;\n  }\n  else\n  {\n    long long half = power(x, n / 2);\n    return (half * half) % MOD;\n  }\n}\n\nint h_ind(int l, int r)\n{\n  int ind = -1;\n  ll mini = infty;\n  for (auto i = l; i < r; i++)\n  {\n    if (H[i] < mini)\n    {\n      ind = i;\n      mini = H[i];\n    }\n  }\n  return ind;\n}\n\nP func(int l, int r, ll h)\n{\n  if (l == r)\n  {\n    // cerr << \"func(\" << l << \", \" << r << \", \" << h << \") = \";\n    // cerr << \"1, 1\" << endl;\n    return P(1, 1);\n  }\n  int ind = h_ind(l, r);\n  ll height = H[ind] - h;\n  if (l + 1 == r && height == 1)\n  {\n    // cerr << \"func(\" << l << \", \" << r << \", \" << h << \") = \";\n    // cerr << \"2, 1\" << endl;\n    return P(2, 1);\n  }\n  if (height == 1)\n  {\n    auto it1 = func(l, ind, h);\n    auto it2 = func(ind + 1, r, h);\n    ll f1 = get<0>(it1);\n    ll g1 = get<1>(it1);\n    ll f2 = get<0>(it2);\n    ll g2 = get<1>(it2);\n    ll f = (((2 * f1) % MOD) * f2) % MOD;\n    ll g = (g1 * g2) % MOD;\n    // cerr << \"func(\" << l << \", \" << r << \", \" << h << \") = \";\n    // cerr << f << \", \" << g << endl;\n    return P(f, g);\n  }\n  auto it1 = func(l, r, h + height - 1);\n  ll f1 = get<0>(it1);\n  ll g1 = get<1>(it1);\n  ll f = f1;\n  f += 2 * (MOD - g1);\n  f %= MOD;\n  f += (power(2, height) * g1) % MOD;\n  f %= MOD;\n  ll g = (power(2, height - 1) * g1) % MOD;\n  // cerr << \"func(\" << l << \", \" << r << \", \" << h << \") = \";\n  // cerr << f << \", \" << g << endl;\n  return P(f, g);\n}\n\nint main()\n{\n  cin >> N;\n  for (auto i = 0; i < N; i++)\n  {\n    cin >> H[i];\n  }\n  cout << get<0>(func(0, N, 0)) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int mod = 1000000007;\nconst int Maxn = 105;\n\nint n;\nint H[Maxn];\nvector <int> un;\nint dp[Maxn][Maxn];\nint res;\n\nint toPower(int a, int p)\n{\n\tint res = 1;\n\twhile (p) {\n\t\tif (p & 1) res = ll(res) * a % mod;\n\t\tp >>= 1; a = ll(a) * a % mod;\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tun.push_back(0);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &H[i]);\n\t\tun.push_back(H[i]);\n\t}\n\tsort(un.begin(), un.end());\n\tun.erase(unique(un.begin(), un.end()), un.end());\n\tfor (int j = 0; j < un.size() && un[j] <= H[0]; j++) {\n\t\tint ways = j == 0? 1: 2;\n\t\tif (j + 1 < un.size() && un[j + 1] <= H[0]) {\n\t\t\tways = ll(ways) * (ll(toPower(2, un[j + 1] - un[j]) - (j == 0? 2: 1) + mod)) % mod;\n\t\t\tways = ll(ways) * ll(toPower(2, H[0] - un[j + 1])) % mod;\n\t\t}\n\t\tdp[0][j] = ways;\n\t}\n\tfor (int i = 0; i + 1 < n; i++)\n\t\tfor (int j = 0; j < un.size() && un[j] <= H[i]; j++) {\n\t\t\tif (un[j] < H[i + 1])\n\t\t\t\tif (un[j] < H[i]) {\n\t\t\t\t\tint ways = dp[i][j];\n\t\t\t\t\tif (H[i + 1] > H[i]) ways = ll(ways) * toPower(2, H[i + 1] - H[i]) % mod;\n\t\t\t\t\tdp[i + 1][j] = (dp[i + 1][j] + ways) % mod;\n\t\t\t\t} else {\n\t\t\t\t\tfor (int k = j; k < un.size() && un[k] <= H[i + 1]; k++) {\n\t\t\t\t\t\tint ways = 2 * dp[i][j] % mod;\n\t\t\t\t\t\tif (k + 1 < un.size() && un[k + 1] <= H[i + 1]) {\n\t\t\t\t\t\t\tways = ll(ways) * (ll(toPower(2, un[k + 1] - un[k]) - 1 + mod)) % mod;\n\t\t\t\t\t\t\tways = ll(ways) * ll(toPower(2, H[i + 1] - un[k + 1])) % mod;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdp[i + 1][k] = (dp[i + 1][k] + ways) % mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\tint ind = lower_bound(un.begin(), un.end(), H[i + 1]) - un.begin();\n\t\t\t\tdp[i + 1][ind] = (dp[i + 1][ind] + 2ll * ll(dp[i][j])) % mod;\n\t\t\t}\n\t\t}\n\tfor (int j = 0; j < un.size(); j++)\n\t\tres = (res + dp[n - 1][j]) % mod;\n\tprintf(\"%d\\n\", res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <ctime>\n#include <cassert>\n#include <unordered_map>\n#include <fstream>\n#include <random>\n#include <cstring>\n#include <bitset>\n#include <functional>\n#include <tuple>\n#include <complex>\n\n#define all(a) (a).begin(), (a).end()\n#define sz(a) (int)(a).size()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef long double ld;\n\nconst int MAXN = 111;\nconst int P = 1e9 + 7;\n\nint dp[MAXN][MAXN];\n\nvoid add(int &a, int b) {\n    a += b;\n    if (a >= P) {\n        a -= P;\n    }\n}\n\nvoid sub(int &a, int b) {\n    a -= b;\n    if (a < 0) {\n        a += P;\n    }\n}\n\n\nvoid mul(int &a, int b) {\n    ll c = (ll)a * b;\n    c %= P;\n    a = c;\n}\n\nint binPow(int a, int b) {\n    if (b == 0) {\n        return 1;\n    }\n    int res = binPow(a, b / 2);\n    mul(res, res);\n    if (b & 1) {\n        mul(res, a);\n    }\n    return res;\n}\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    // freopen(\"input.txt\", \"r\", stdin);\n    // freopen(\"output.txt\", \"w\", stdout);\n    \n    int n;\n    cin >> n;\n    ++n;\n\n    vector<int> h(n);\n\n    set<int> setik;\n\n    h[0] = 1;\n    for (int i = 1; i < n; ++i) {   \n        cin >> h[i];\n    }\n\n    for (int i = 0; i < n; ++i) {\n        setik.insert(h[i]);\n    }\n\n    vector<int> u;\n\n    for (int s : setik) {\n        u.push_back(s);\n    }\n\n    int m = sz(u);\n\n    dp[0][0] = 2;\n\n    for (int i = 1; i < n; ++i) {\n\n        int pos = -1;\n\n        if (h[i] == 1) {\n            for (int j = 0; j < m; ++j) {\n                add(dp[i][0], dp[i - 1][j]);\n            }\n            mul(dp[i][0], 2);\n            continue;\n        }\n\n        for (int j = 0; j < m; ++j) {\n            if (u[j] == h[i - 1]) {\n                pos = j;\n            }\n\n            if (h[i - 1] >= h[i]) {\n                if (u[j] < h[i]) {\n                    add(dp[i][j], dp[i - 1][j]);\n                } else if (u[j] == h[i]) {\n                    for (int k = j; k < m; ++k) {\n                        add(dp[i][j], dp[i - 1][k]);\n                    }\n                    mul(dp[i][j], 2);\n                }\n            } else {\n                if (u[j] < h[i - 1]) {\n                    int cur = dp[i - 1][j];\n                    mul(cur, binPow(2, h[i] - h[i - 1]));\n                    add(dp[i][j], cur);\n                } else if (u[j] < h[i]) {\n                    int cur = dp[i - 1][pos];\n                    mul(cur, 2);\n                    mul(cur, binPow(2, u[j + 1] - u[j]) - 1);\n                    mul(cur, binPow(2, h[i] - u[j + 1]));\n                    add(dp[i][j], cur);\n                    // cout << pos << endl;\n                    // cout << i << \" \" << dp[i][j] << endl;\n                } else if (u[j] == h[i]) {\n                    int cur = dp[i - 1][pos];\n                    mul(cur, 2);\n                    add(dp[i][j], cur);\n                }\n            }\n        }\n    }\n\n    int res = 0;\n\n    for (int j = 0; j < m; ++j) {\n        add(res, dp[n - 1][j]);\n    }\n\n    mul(res, (P + 1) / 2);\n\n    cout << res << endl;\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\nusing namespace std;\n#define LL long long\nconst int N=105;\nconst LL mod=1000000007;\nint a[N];\nLL sqrr(LL x){return x*x%mod;}\nLL mi2(int x){\n    if (!x) return 1;if (x==1) return 2;\n    LL ans=sqrr(mi2(x>>1));\n    if (x&1) ans=ans*2%mod;\n    return ans;\n}\nLL dp(int l,int r,int h,int ff){\n    if (l>r) return 1ll;\n    if (l==r) return mi2(a[l]-h);\n    int i,mini=0;\n    for (i=l;i<=r;i++) if (a[i]<a[mini]) mini=i;\n    if (ff) return dp(l,mini-1,a[mini],ff)*dp(mini+1,r,a[mini],ff)%mod*mi2(a[mini]-h)%mod;\n    else{\n        LL ans1=dp(l,mini-1,a[mini]-1,0)*dp(mini+1,r,a[mini]-1,0)%mod*2ll%mod;\n        LL ans2=dp(l,mini-1,a[mini],1)*dp(mini+1,r,a[mini],1)%mod*(mi2(a[mini]-h)+mod-2)%mod;\n        return (ans1+ans2)%mod;\n    }\n}\nint main(){\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    int i,n;\n    scanf(\"%d\",&n);\n    for (i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n    a[0]=0x7fffffff;\n    printf(\"%lld\\n\",dp(1,n,0,0));\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,x,y) for (int i=(x);i<=(y);i++)\n#define ll long long\n#define inf 1000000001\n#define y1 y1___\n#define pii pair<int,int>\n#define fi first\n#define se second\nusing namespace std;\nchar gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\nll read(){\n    char ch=gc();ll x=0;int op=1;\n    for (;!isdigit(ch);ch=gc()) if (ch=='-') op=-1;\n    for (;isdigit(ch);ch=gc()) x=(x<<1)+(x<<3)+ch-'0';\n    return x*op;\n}\n#define N 105\n#define mod 1000000007\nint ksm(int x,int p){\n    int ret=1;\n    for (;p;p>>=1,x=(ll)x*x%mod) if (p&1) ret=(ll)ret*x%mod;\n    return ret;\n}\nint n,h[N];\npii solve(int l,int r,int lim){//区间[l,r]比lim高的部分的方案数\n    int mi=inf,cnt=0;pii ret;//first：存在相邻格子颜色相同情况的方案数；second：不存在的方案数（固定第一个格子的颜色）\n    rep (i,l,r) if (h[i]<mi) mi=h[i],cnt=1;else if (h[i]==mi) cnt++;\n    if (cnt==r-l+1){//矩形\n        ret.fi=(ksm(2,r-l+1)+mod-2)%mod;\n        ret.se=ksm(2,mi-lim);\n        return ret;\n    }\n    int rest=r-l+1,s0=1,s1=1,last=0;//rest：上方没有方格的列数；s0,s1：维护上方有方格的列，当前行存在/不存在的方案数\n    rep (i,l,r+1)\n        if (!last&&h[i]>mi) last=i;\n        else if (last&&(h[i]<=mi||i>r)){\n            rest-=i-last;\n            pii tmp=solve(last,i-1,mi);//子问题，递归求解\n            s0=(ll)s0*(tmp.fi+2ll*tmp.se%mod)%mod;//*4是因为上一行可以取反，当前行亦然，2*2\n            s1=(ll)s1*(1ll*tmp.se%mod)%mod;\n            last=0;\n        }\n    s0=(s0+mod-s1)%mod;\n    ret.fi=(ll)s0*ksm(2,rest)%mod;//如果上方方格已经存在，剩下的列随意\n    ret.fi=(ret.fi+(ll)s1*(ksm(2,rest)+mod-2)%mod)%mod;//否则需要去掉两种不合法的情况\n    ret.se=(ll)2ll*s1*ksm(2,mi-lim-1)%mod;//固定第一个格子（第一行）颜色\n    return ret;\n}\nint main(){\n    n=read();rep (i,1,n) h[i]=read();\n    if (n==1){//注意特判\n        printf(\"%d\\n\",ksm(2,h[1]));\n        exit(0);\n    }\n    pii ans=solve(1,n,0);\n    printf(\"%d\",(ans.fi+ans.se%mod)%mod);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\n#define fr first\n#define sc second\n\nconst ll M = 1000000007;\n\nll modpow(ll x,ll k){\n\tif(k == 0)return 1;\n\tll ret = modpow(x,k/2);\n\tret *= ret; ret %= M;\n\tif(k%2 == 1){\n\t\tret *= x; ret %= M;\n\t}\n\treturn ret;\n}\n\nint N;\nll h[102];\n\nll dp1[102][102];\nll dp2[102][102];\nvoid solve(int l,int r,int d){\n\tif(l == r){\n\t\tdp1[l][r] = 0;\n\t\tdp2[l][r] = modpow(2,h[l]-d);\n\t\treturn;\n\t}\n\tint d_ = M;\n\tfor(int i = l ; i <= r ; i ++)d_ = min( (ll)d_ , h[i] );\n\tvector<P> vec;\n\tint l_=l,r_=l-1;\n\tint cnt = 0;\n\tfor(int i = l ; i <= r ; i ++){\n\t\tif(h[i] <= d_){\n\t\t\tcnt ++;\n\t\t\tif(l_ <= r_){\n\t\t\t\tvec.push_back(P(l_,r_));\n\t\t\t\tsolve(l_,r_,d_);\n\t\t\t}\n\t\t\tl_ = i+1;\n\t\t\tr_ = i;\n\t\t}\n\t\telse {\n\t\t\tr_ = i;\n\t\t}\n\t}\n\tif(l_ <= r_){\n\t\tvec.push_back(P(l_,r_));\n\t\tsolve(l_,r_,d_);\n\t}\n\tdp1[l][r] = 1;\n\tdp2[l][r] = 1;\n\tfor(int i = 0 ; i < vec.size() ; i ++){\n\t\tP p = vec[i];\n\t\tdp1[l][r] *= (dp1[p.fr][p.sc]+dp2[p.fr][p.sc]*2);\n\t\tdp1[l][r] %= M;\n\t\tdp2[l][r] *= dp2[p.fr][p.sc];\n\t\tdp2[l][r] %= M;\n\t}\n\tdp1[l][r] *= modpow(2,cnt);\n\tdp1[l][r] %= M;\n\tdp2[l][r] *= 2;\n\tdp2[l][r] %= M;\n\tdp1[l][r] += M-dp2[l][r];\n\tdp1[l][r] %= M;\n\tdp2[l][r] *= modpow(2,d_-d-1);\n\tdp2[l][r] %= M;\n}\n\nint main(){\n\tscanf(\"%d\",&N);\n\tfor(int i = 1 ; i <= N ; i ++){\n\t\tscanf(\"%lld\",&h[i]);\n\t}\n\tsolve(1,N,0);\n\t//cout << dp1[1][N] << \" \" << dp2[1][N] << endl;\n\tcout << (dp1[1][N]+dp2[1][N])%M << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nconst int MX = 100005;\nconst ll MOD = 1000000007;\n\ntemplate <typename T> void read(T &x)\n{\n\tx = 0;\n\tchar c = getchar();\n\twhile(!isdigit(c)) c = getchar();\n\twhile(isdigit(c)) x = x*10+c-'0', c = getchar();\n}\n\ntemplate <typename T> void add(T &x, const T &y)\n{\n\tx += y;\n\tx %= MOD;\n}\n\nll qpow(ll x, ll t)\n{\n\tll ans = 1;\n\twhile(t)\n\t{\n\t\tif(t & 1) ans = ans * x % MOD;\n\t\tx = x * x % MOD;\n\t\tt >>= 1;\n\t}\n\treturn ans;\n}\n\nll inv(ll x)\n{\n\treturn qpow(x, MOD-2);\n}\n\nint n, h[MX], rak[MX];\nint lmost[MX], rmost[MX];\nll f[MX][2][2][2];\nint hmn[MX];\n\nvoid input()\n{\n\tread(n);\n\tfor(int i=1; i<=n; i++) read(h[i]), rak[i] = i;\n\tsort(rak+1, rak+n+1, [=](int a, int b){return h[a] > h[b];});\n}\n\nvoid trans(ll a[2][2][2], ll b[2][2][2], ll tar[2][2][2])\n{\n\tll f[2][2][2];\n\tmemset(f, 0, sizeof(f));\n\tfor(int l=0; l<2; l++)\n\t\tfor(int ma=0; ma<2; ma++)\n\t\t\tfor(int mb=0; mb<2; mb++)\n\t\t\t\tfor(int r=0; r<2; r++)\n\t\t\t\t\tfor(int ca=0; ca<2; ca++)\n\t\t\t\t\t\tfor(int cb=0; cb<2; cb++)\n\t\t\t\t\t\t\tadd(f[l][r][ca|cb|(ma==mb)], a[l][ma][ca]*b[mb][r][cb]);\n\tmemmove(tar, f, sizeof(f));\n}\n\nvoid moveh(ll a[2][2][2], ll tar[2][2][2], int dh)\n{\n\tll f[2][2][2];\n\tmemset(f, 0, sizeof(f));\n\tfor(int l=0; l<2; l++)\n\t\tfor(int r=0; r<2; r++)\n\t\t{\n\t\t\tif(dh)\n\t\t\t{\n\t\t\t\tadd(f[l][r][0], a[l][r][0]*qpow(2, dh-1));\n\t\t\t\tadd(f[l^1][r^1][0], a[l][r][0]*qpow(2, dh-1));\n\t\t\t}\n\t\t\telse add(f[l][r][0], a[l][r][0]);\n\t\t\tadd(f[l^(dh&1)][r^(dh&1)][1], a[l][r][1]);\n\t\t}\n\tmemmove(tar, f, sizeof(f));\n}\n\nvoid work()\n{\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tint p = rak[i];\n\t\tif(!lmost[p-1] && !rmost[p+1])\n\t\t{\n\t\t\tf[p][0][0][0] = 1;\n\t\t\tf[p][1][1][0] = 1;\n\t\t\tlmost[p] = rmost[p] = p;\n\t\t\thmn[p] = h[p];\n\t\t}\n\t\telse if(!lmost[p-1] && rmost[p+1])\n\t\t{\n\t\t\tmoveh(f[p+1], f[p+1], hmn[p+1]-h[p]);\n\t\t\tlmost[rmost[p+1]] = p;\n\t\t\trmost[p] = rmost[p+1];\n\t\t\thmn[p] = hmn[rmost[p+1]] = h[p];\n\t\t\tf[p][0][0][0] = 1;\n\t\t\tf[p][1][1][0] = 1;\n\t\t\ttrans(f[p], f[p+1], f[p]);\n\t\t\tmemmove(f[rmost[p+1]], f[p], sizeof(f[p]));\n\t\t}\n\t\telse if(lmost[p-1] && !rmost[p+1])\n\t\t{\n\t\t\tmoveh(f[p-1], f[p-1], hmn[p-1]-h[p]);\n\t\t\trmost[lmost[p-1]] = p;\n\t\t\tlmost[p] = lmost[p-1];\n\t\t\thmn[p] = hmn[lmost[p-1]] = h[p];\n\t\t\tf[p][0][0][0] = 1;\n\t\t\tf[p][1][1][0] = 1;\n\t\t\ttrans(f[p-1], f[p], f[p]);\n\t\t\tmemmove(f[lmost[p-1]], f[p], sizeof(f[p]));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmoveh(f[p-1], f[p-1], hmn[p-1]-h[p]);\n\t\t\tmoveh(f[p+1], f[p+1], hmn[p+1]-h[p]);\n\t\t\trmost[lmost[p-1]] = rmost[p+1];\n\t\t\tlmost[rmost[p+1]] = lmost[p-1];\n\t\t\thmn[p] = hmn[lmost[p-1]] = hmn[rmost[p+1]] = h[p];\n\t\t\tf[p][0][0][0] = 1;\n\t\t\tf[p][1][1][0] = 1;\n\t\t\ttrans(f[p-1], f[p], f[p]);\n\t\t\ttrans(f[p], f[p+1], f[p+1]);\n\t\t\tmemmove(f[lmost[p-1]], f[p+1], sizeof(f[p+1]));\n\t\t\tmemmove(f[rmost[p+1]], f[p+1], sizeof(f[p+1]));\n\t\t}\n\t}\n\tmoveh(f[1], f[1], hmn[1]-1);\n\tll ans = 0;\n\tfor(int i=0; i<2; i++)\n\t\tfor(int j=0; j<2; j++)\n\t\t\tfor(int k=0; k<2; k++)\n\t\t\t\tadd(ans, f[1][i][j][k]);\n\tprintf(\"%lld\\n\", ans);\n}\n\nint main()\n{\n\tinput();\n\twork();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nAuthor: QAQAutomaton\nLang: C++\nCode: D.cpp\nMail: lk@qaq-am.com\nBlog: https://www.qaq-am.com/\n*/\n#include<bits/stdc++.h>\n#define int long long\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define DEBUG printf(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define Debug debug(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define all(x) x.begin(),x.end()\n#define x first\n#define y second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nint inf;\nconst double eps=1e-8;\nconst double pi=acos(-1.0);\ntemplate<class T>int chkmin(T &a,T b){return a>b?a=b,1:0;}\ntemplate<class T>int chkmax(T &a,T b){return a<b?a=b,1:0;}\ntemplate<class T>T sqr(T a){return a*a;}\ntemplate<class T>T mmin(T a,T b){return a<b?a:b;}\ntemplate<class T>T mmax(T a,T b){return a>b?a:b;}\ntemplate<class T>T aabs(T a){return a<0?-a:a;}\ntemplate<class T>int dcmp(T a,T b){return a>b;}\ntemplate<int *a>int cmp_a(int x,int y){return a[x]<a[y];}\n#define min mmin\n#define max mmax\n#define abs aabs\nstruct __INIT__{\n\t__INIT__(){\n\t\tmemset(&inf,0x3f,sizeof(inf));\n\t}\n}__INIT___;\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\ttemplate<typename A>\n\tinline bool read (A &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;else if(c==EOF)return 0;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;\n\t\treturn 1;\n\t}\n\tinline bool read (char &x) {\n\t\twhile((x=gc())==' '||x=='\\n' || x=='\\r');\n\t\treturn x!=EOF;\n\t}\n\tinline bool read(char *x){\n\t\twhile((*x=gc())=='\\n' || *x==' '||*x=='\\r');\n\t\tif(*x==EOF)return 0;\n\t\twhile(!(*x=='\\n'||*x==' '||*x=='\\r'))*(++x)=gc();\n\t\t*x=0;\n\t\treturn 1;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool read(A &x,B &...y){\n\t\treturn read(x)&&read(y...);\n\t}\n\ttemplate<typename A>\n\tinline bool write (A x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t\treturn 0;\n\t}\n\tinline bool write (char x) {\n\t\tputc(x);\n\t\treturn 0;\n\t}\n\tinline bool write(const char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\tinline bool write(char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool write(A x,B ...y){\n\t\treturn write(x)||write(y...);\n\t}\n\t//no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io :: read;\nusing io :: putc;\nusing io :: write;\nint n,a[105],f[105][2],is[105],ir[105];\npii b[105];\nconst int p=1000000007;\nint fpm(int a,int b){\n\tint c=1;for(;b;b>>=1,a=a*a%p)if(b&1)c=c*a%p;\n\treturn c;\n}\nsigned main(){\n#ifdef QAQAutoMaton \n\tfreopen(\"D.in\",\"r\",stdin);\n\tfreopen(\"D.out\",\"w\",stdout);\n#endif\n\tread(n);\n\ta[0]=1;\n\tfor(int i=1;i<=n;++i){\n\t\tread(a[i]);\n\t\tb[i]=make_pair(a[i],i);\n\t}\n\tsort(b+1,b+n+1,dcmp<pii>);\n\tfor(int i=1,j=1,las=1e9+1;i<=n;i=j){\n\t\tfor(int k=1;k<=n;++k)f[k][0]=f[k][0]*fpm(2,las-b[i].x-1)%p;\n\t\twhile(j<=n && b[j].x==b[i].x){\n\t\t\tis[b[j].y]=1;\n\t\t\t++j;\n\t\t}\n\t\tfor(int k=1;k<=n;++k)if(is[k]){\n\t\t\tint l=k;\n\t\t\tint w0=1,w1=1,w2=0;\n\t\t\twhile(is[l]){\n\t\t\t\tif(ir[l]){\n\t\t\t\t\tw0=w0*f[l][0]%p;\n\t\t\t\t\tw1=w1*(f[l][0]*2+f[l][1])%p;\n\t\t\t\t\tir[l]=0;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tw2+=a[l]==b[i].x;\n\t\t\t\t}\n\t\t\t\t++l;\n\t\t\t}\n\t\t\t--l;\n\t\t\tk=l;\n\t\t\tf[k][0]=w0*2%p;\n\t\t\tf[k][1]=(w1*fpm(2,w2)+p-f[k][0])%p;\n\t\t\tir[k]=1;\n\t\t}\n\t\tlas=b[i].x;\n\t}\n\n\twrite((f[n][0]*fpm(2,b[n].x-1)+f[n][1])%p,'\\n');\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<utility>\n#include<map>\n#include<algorithm>\n\nusing namespace std;\n\nconst long long mod = 1000000007;\n\ntypedef pair<int, int> P;\n\nmap<P, long long> mp;\n\nint a[110];\nint N;\n\nint vals[110];\n\nlong long mul(long long a, long long b){\n\treturn (a * b) % mod;\n}\n\nlong long ex(long long a, long long e){\n\tif(e == 0) return 1;\n\tlong long tmp = ex(a, e / 2);\n\ttmp = mul(tmp, tmp);\n\tif(e % 2 == 1) tmp = mul(tmp, a);\n\treturn tmp;\n}\n\nlong long dp[110];\n\nlong long solve(){\n\tfor(int i = 1; i <= N; ++i){\n\t\tint ub = a[i];\n\t\tfor(int j = i; j <= N; ++j){\n\t\t\tub = min(ub, a[j]);\n\t\t\tint lb = max(a[i - 1], a[j + 1]);\n\t\t\tif(lb == 0) lb = 1;\n\t\t\tif(ub > lb){\n\t\t\t\tmp[P(i, j)] = ub - lb;\n\t\t\t}\n\t\t}\n\t}\n\tdp[0] = 1;\n\tfor(int i = 1; i <= N; ++i){\n\t\tlong long e = 0;\n\t\tfor(int j = i - 1; j >= 0; --j){\n\t\t\tfor(int k = j + 1; k <= i; ++k){\n\t\t\t\te += mp[P(j + 1, k)];\n\t\t\t}\n\t\t\tdp[i] += mul(dp[j], ex(2, e));\n\t\t\tdp[i] %= mod;\n\t\t}\n\t}\n\tlong long ans = mul(dp[N], 2);\n\tans += mod;\n\tans %= mod;\n\treturn ans;\n}\n\nvoid input(){\n\tscanf(\"%d\", &N);\n\tfor(int i = 1; i <= N; ++i){\n\t\tscanf(\"%d\", a + i);\n\t}\n}\n\nint main(){\n\tinput();\n\tlong long ans = solve();\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<cstring>\n#include<stdlib.h>\n#include<time.h>\n#include<math.h>\n#include<algorithm>\n#include<vector>\n#define ll long long\n#define maxn 105\n#define p 1000000007\n#define inf 0x3f3f3f3f\nusing namespace std;\nint n,h[maxn],root,tot=1;\nint si[maxn],a[maxn];\nll f[maxn][2];// f[maxn][0]è¡¨ç¤ºéžé»‘ç™½ç›¸é—´\nvector<int> c[maxn];\n\ninline int read()\n{\n\tint num,sign=1;\n\tchar c;\n\twhile((c=getchar())<'0'||c>'9')\n\t\tif(c=='-')sign=-1;\n\tnum=c-'0';\n\twhile((c=getchar())>='0'&&c<='9')\n\t\tnum=(num<<1)+(num<<3)+c-'0';\n\treturn num*sign;\n}\n\nvoid build(int l,int r,int id)\n{\n\tint minheight=inf,top=0;\n\tint st[maxn];\n\tsi[id]=r-l+1;\n\tfor(register int i=l;i<=r;++i)\n\t{\n\t\tif(h[i]<=minheight)\n\t\t{\n\t\t\tif(h[i]<minheight)\n\t\t\t{\n\t\t\t\ttop=0;\n\t\t\t\tminheight=h[i];\n\t\t\t\tst[++top]=i;\n\t\t\t}\n\t\t\telse\n\t\t\t\tst[++top]=i;\n\t\t}\n\t}\n\tst[++top]=r+1,a[id]=minheight;\n\tint lastgo=l;\n\tfor(register int i=1;i<=top;++i)\n\t{\n\t\tif(st[i]==lastgo)\n\t\t{\n\t\t\t++lastgo;\n\t\t\tcontinue;\n\t\t}\n\t\t++tot;\n\t\tc[id].push_back(tot);\n\t\tbuild(lastgo,st[i]-1,tot);\n\t\tlastgo=st[i]+1;\n\t}\n}\n\ninline ll ksm(ll a,ll b)\n{\n\tll res=1;\n\twhile(b)\n\t{\n\t\tif(b&1)res=(res*a)%p;\n\t\tb>>=1;\n\t\ta=(a*a)%p;\n\t}\n\treturn res;\n}\n\nvoid dfs(int u,int lasth)\n{\n\tint sum=si[u];\n\tint H=a[u]-lasth;\n\tf[u][1]=2,f[u][0]=1;\n\tfor(register int i=0;i<c[u].size();++i)\n\t{\n\t\tint v=c[u][i];\n\t\tdfs(v,a[u]);\n\t\tf[u][0]=(f[u][0]*((f[v][1]+f[v][0])%p)%p+(f[u][0]*f[v][1])%p)%p;\n\t\tf[u][1]=(f[v][1]*f[u][1])%p;\n\t\tsum-=si[v];\n\t}\n\tf[u][0]=((f[u][0]*ksm(2,sum))%p+(p-f[u][1])%p)%p;\n\tf[u][1]=(f[u][1]*ksm(2,H-1))%p;\n}\n\nint main()\n{\n\tn=read();\n\tfor(register int i=1;i<=n;++i)h[i]=read();\n\tbuild(1,n,1);\n\tdfs(1,0);\n\tprintf(\"%lld\\n\",(f[1][0]+f[1][1])%p);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int _INT_MAX_ = 0x3fffffff;\n\nconst int MOD = int(1e9) + 7;\n\nint fpow(int base, int exp) {\n\tint result = 1;\n\tfor (; exp; exp >>= 1) {\n\t\tif (exp & 1)\n\t\t\tresult = (long long)result * base % MOD;\n\t\tbase = (long long)base * base % MOD;\n\t}\n\treturn result;\n}\n\nint n, h[110];\n\npair<int, int> solve(int l, int r, int limit) {\n\tint min_height = _INT_MAX_;\n\tfor (int i = l; i < r; ++i) {\n\t\tmin_height = min(min_height, h[i]);\n\t}\n\t\n\tpair<int, int> result = {2, 1};\n\tint tot = -1;\n\tfor (int i = l; i <= r; ++i) {\n\t\tif (i == r || min_height == h[i]) {\n\t\t\t++tot;\n\t\t\tif (i > l) {\n\t\t\t\tpair<int, int> tmp = solve(l, i, min_height);\n\t\t\t\tresult.first = (long long)result.first * tmp.first % MOD;\n\t\t\t\tresult.second =\n\t\t\t\t\t(long long)result.second * (tmp.first + tmp.second) % MOD;\n\t\t\t}\n\t\t\tl = i + 1;\n\t\t}\n\t}\n\t\n\tresult.second = (long long)result.second * fpow(2, tot) % MOD;\n\tresult.second = (result.second - result.first + MOD) % MOD;\n\tresult.first = (long long)result.first * fpow(2, min_height - limit - 1) % MOD;\n\tresult.second = (result.first + result.second) % MOD;\n\treturn result;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tscanf(\"%d\", &h[i]);\n\t}\n\tpair<int, int> ans = solve(0, n, 0);\n\tprintf(\"%d\\n\", ans.second);\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author majk\n */\n\n#ifndef MAJK_LIB\n#define MAJK_LIB\n\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <fstream>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <algorithm>\n#include <numeric>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <array>\n#include <bitset>\nusing namespace std;\n\n#define x first\n#define y second\ntypedef std::pair<int,int> pii; typedef long long ll; typedef unsigned long long ull; typedef unsigned int ui; typedef pair<ui,ui> puu;\n\ntemplate <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate <typename T, typename U> std::ostream&operator<<(std::ostream&o, const pair<T,U>&p) {o << p.x << ' ' << p.y; return o;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {if(t.empty())o<<'\\n';for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\nui logceil(ll x) { return x?8*sizeof(ll)-__builtin_clzll(x):0; }\n\nnamespace std { template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}}; }\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename F> double bshd(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){l=m;}else{h=m;}}return (l+h)/2;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename F> double bsld(double l,double h,const F&f){ui r=200;while(r--){double m=(l+h)/2;if(f(m)){h=m;}else{l=m;}}return (l+h)/2;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector2<T>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector2<T>>(a,vector2<T>(b,c,t)){}};\ntemplate<typename T>class vector4:public vector<vector3<T>>{public:vector4(){} vector4(size_t a,size_t b,size_t c,size_t d,T t=T()):vector<vector3<T>>(a,vector3<T>(b,c,d,t)){}};\ntemplate<typename T>class vector5:public vector<vector4<T>>{public:vector5(){} vector5(size_t a,size_t b,size_t c,size_t d,size_t e,T t=T()):vector<vector4<T>>(a,vector4<T>(b,c,d,e,t)){}};\n\n\n#endif\n#ifndef MOD_H\n#define MOD_H\n\n\n\ntemplate <unsigned int N> class Field {\n    typedef unsigned int ui;\n    typedef unsigned long long ull;\n\tinline ui pow(ui a, ui p){ui r=1,e=a;while(p){if(p&1){r=((ull)r*e)%N;}e=((ull)e*e)%N;p>>=1;}return r;}\n\t/*extended GCD(slow):ll t=0,nt=1,r=N,nr=a;while(nr){ll q=r/nr;t-=q*nt;swap(t,nt);r-=q*nr;swap(r,nr);}assert(r<=1);return(t<0)?t+N:t;*/\n\tinline ui inv(ui a){return pow(a,N-2);}\npublic:\n    inline Field(int x = 0) : v(x<0?N+x:x) {}\n\tinline Field<N> pow(int p){return (*this)^p; }\n\tinline Field<N> operator^(int p){return {(int)pow(v,(ui)p)};}\n    inline Field<N>&operator+=(const Field<N>&o) {if (v+o.v >= N) v += o.v - N; else v += o.v; return *this; }\n    inline Field<N>&operator-=(const Field<N>&o) {if (v<o.v) v -= o.v-N; else v-=o.v; return *this; }\n    inline Field<N>&operator*=(const Field<N>&o) {v=(ull)v*o.v % N; return *this; }\n    inline Field<N>&operator/=(const Field<N>&o) { return *this*=inv(o.v); }\n    inline Field<N> operator+(const Field<N>&o) const {Field<N>r{*this};return r+=o;}\n    inline Field<N> operator-(const Field<N>&o) const {Field<N>r{*this};return r-=o;}\n    inline Field<N> operator*(const Field<N>&o) const {Field<N>r{*this};return r*=o;}\n    inline Field<N> operator/(const Field<N>&o) const {Field<N>r{*this};return r/=o;}\n    inline Field<N> operator-() {if(v) return {(int)(N-v)}; else return {0};};\n    inline Field<N>& operator++() { ++v; if (v==N) v=0; return *this; }\n    inline Field<N> operator++(int) { Field<N>r{*this}; ++*this; return r; }\n    inline Field<N>& operator--() { --v; if (v==-1) v=N-1; return *this; }\n    inline Field<N> operator--(int) { Field<N>r{*this}; --*this; return r; }\n    inline bool operator==(const Field<N>&o) const { return o.v==v; }\n\tinline bool operator!=(const Field<N>&o) const { return o.v!=v; }\n\tinline explicit operator ui() const { return v; }\n\tinline static vector<Field<N>>fact(int t){vector<Field<N>>F(t+1,1);for(int i=2;i<=t;++i){F[i]=F[i-1]*i;}return F;}\n\tinline static vector<Field<N>>invfact(int t){vector<Field<N>>F(t+1,1);Field<N> X{1};for(int i=2;i<=t;++i){X=X*i;}F[t]=1/X;for(int i=t-1;i>=2;--i){F[i]=F[i+1]*(i+1);}return F;}\nprivate: ui v;\n};\ntemplate<unsigned int N>istream &operator>>(std::istream&is,Field<N>&f){unsigned int v;is>>v;f=v;return is;}\ntemplate<unsigned int N>ostream &operator<<(std::ostream&os,const Field<N>&f){return os<<(unsigned int)f;}\ntemplate<unsigned int N>Field<N> operator+(int i,const Field<N>&f){return Field<N>(i)+f;}\ntemplate<unsigned int N>Field<N> operator-(int i,const Field<N>&f){return Field<N>(i)-f;}\ntemplate<unsigned int N>Field<N> operator*(int i,const Field<N>&f){return Field<N>(i)*f;}\ntemplate<unsigned int N>Field<N> operator/(int i,const Field<N>&f){return Field<N>(i)/f;}\n\n\ntypedef Field<1000000007> FieldMod;\n\nstruct Ring {\n\ttemplate <typename T>\n\tstatic T div(T p, T q, T N) {\n\t\tT t=0,nt=1,r=N,nr=q;\n\t\twhile(nr!=0){ T q=r/nr;t-=q*nt;r-=q*nr;swap(t,nt);swap(r,nr); }\n\t\tt=(t<0)?t+N:t;\n\t\tr=(r<0)?r+N:r;\n\t\tif (gcd(p,N)%r!=0) { return 0; }\n\t\treturn (t*p/r)%N;\n\t}\n};\n#endif\n\n\nclass DHistogramColoring {\npublic:\n    void solve(istream& cin, ostream& cout) {\n        int N; cin >> N;\n        vector<int> A(N); cin >> A;\n        vector<FieldMod> D(N+1, 0);\n        D[0] = 1;\n        for (int i = 0; i < N; ++i) {\n            int lo = min(A[i], i==0?1:A[i-1]);\n            ll choices = (i==0?A[i]:max(A[i]-A[i-1], 0));\n\n            for (int j = i+1; j < N; ++j) {\n                lo = min(lo, A[j]);\n                D[j] += D[i] * FieldMod{2}.pow((choices + lo - min(A[j-1], A[j])) % 1000000006);\n                choices += max(0, A[j] - A[j-1]);\n            }\n\n            D[N] += D[i] * FieldMod{2}.pow(choices % 1000000006);\n        }\n        cout << D[N] << '\\n';\n    }\n};\n\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tDHistogramColoring solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int N=105,mod=1e9+7;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(!isdigit(ch))\n\t{\n\t\tif(ch=='-') f=-1;\n\t\tch=getchar();\n\t}\n\twhile(isdigit(ch))\n\t{\n\t\tx=(x<<1)+(x<<3)+ch-'0';\n\t\tch=getchar();\n\t}\n\treturn x*f;\n}\ninline int ksm(int x,int y)\n{\n\tif(y<=0) return 1;//为什么要加这一句？ \n\tint res=1;\n\tfor(;y;y>>=1,x=(x*x)%mod)if(y&1)res=(res*x)%mod;\n\treturn res;\n}\nint a[N],Has[N],tot,f[N][N],n,ans;\nsigned main(void)\n{\n\tn=read();\n\tf[0][0]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\ta[i]=read();\n\t\tHas[++tot]=a[i];\n\t}\n\tsort(Has+1,Has+tot+1);\n\ttot=unique(Has+1,Has+tot+1)-Has-1;\n\tfor(int i=1;i<=n;i++)a[i]=lower_bound(Has+1,Has+tot+1,a[i])-Has;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint now=ksm(2,Has[a[i]]-Has[a[i-1]]);\n\t\tf[i][0]=(f[i-1][0]<<1)%mod;\n\t\tfor(int j=a[i]+1;j<=a[i-1];j++)f[i][0]=(f[i][0]+((f[i-1][j])<<1)%mod)%mod;\n\t\tfor(int j=1;j<=min(a[i-1],a[i]);j++)f[i][j]=f[i-1][j]*now%mod;\n\t\tfor(int j=a[i-1]+1;j<=a[i];j++)\n\t\tif(j==1)f[i][j]=f[i-1][0]*(ksm(2,Has[j])-2)%mod*ksm(2,Has[a[i]]-Has[j])%mod;\n\t\telse f[i][j]=(f[i-1][0]<<1)*(ksm(2,Has[j]-Has[j-1])-1)%mod*ksm(2,Has[a[i]]-Has[j])%mod;\n\t}\n\tfor(int i=0;i<=tot;i++)ans=(ans+f[n][i])%mod;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n\nconst int N = 1e6 + 10;\nconst int mod = 1e9 + 7;\nint h[N], st[N], top, n, ls[N], rs[N], root, f[N][2], num[N], single[N], mulsingle[N], rev[N];\nbool bsin[N];\n\ninline void build()\n{\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tint k = top;\n\t\twhile (k > 0 && h[st[k]] > h[i]) k--;\n\t\tif (k) rs[st[k]] = i;\n\t\tif (k < top) ls[i] = st[k + 1];\n\t\tst[++k] = i;\n\t\ttop = k;\n\t}\n\troot = st[1];\n}\n\nvoid dfs(int x)\n{\n\tif (!x) return;\n\tcout << \"x \" << x << endl;\n\tdfs(ls[x]), dfs(rs[x]);\n}\n\ninline int fp(int a, int n)\n{\n\tint res = 1;\n\twhile (n)\n\t{\n\t\tif (n & 1) res = (res * a) % mod;\n\t\ta = (a * a) % mod;\n\t\tn >>= 1;\n\t}\n\treturn res % mod;\n}\n\ninline void fill(int *a, int siz, int val)\n{\n\tfor (int i = 1; i <= siz; i++)\ta[i] = val;\n}\n\ninline void dp(int x, int fa)\n{\n\tif (!x) return;\n\tnum[x] = 1;\n\trev[x] = 1;\n\tint height = h[x] - h[fa];\n\t// if (!rs[x] && !ls[x] && h[x] != h[fa])\n\t// {\n\t// \tsingle[x] = 1;\n\t// \tmulsingle[x] *= fp(2, height);\n\t// \treturn;\n\t// }\n\tif (!rs[x] && !ls[x] && h[x] == h[fa])\n\t\treturn;\n\tdp(ls[x], x);\n\tdp(rs[x], x);\n\t// if (ls[x] && x - ls[x] == 1) rev[x] += single[ls[x]];\n\t// if (rs[x] && rs[x] - x == 1) rev[x] += single[rs[x]];\n\t// if (ls[x]) mulsingle[x] *= mulsingle[ls[x]];\n\t// if (rs[x]) mulsingle[x] *= mulsingle[rs[x]]; \n\tif (ls[x] && h[ls[x]] == h[x]) rev[x] += rev[ls[x]];\n\tif (rs[x] && h[rs[x]] == h[x]) rev[x] += rev[rs[x]];\n\tif (f[ls[x]][1] == 0) ls[x] = 0;\n\tif (f[rs[x]][1] == 0) rs[x] = 0;\n\n\tif (height > 0)\n\t{\n\t\tif (rs[x] && ls[x])\n\t\t{\n\t\t\tf[x][1] = (f[rs[x]][1] * f[ls[x]][1] % mod  * fp(2, height) % mod) % mod;\n\t\t\t// cout << \"fk1 \" << f[rs[x]][1] << ' ' << f[ls[x]][1] << endl;\n\t\t\t// cout << \"fk0 \" << f[rs[x]][0] << ' ' << f[ls[x]][0] << endl;\n\t\t\tf[x][0] = (((f[rs[x]][1] * f[ls[x]][0] % mod * 2 * (fp(2, rev[x])) % mod + f[rs[x]][0] * f[ls[x]][1] % mod * 2 * (fp(2, rev[x])) % mod) % mod + f[rs[x]][0] * f[ls[x]][0] % mod) % mod * fp(2, rev[x]) % mod + f[rs[x]][1] * f[ls[x]][1] % mod * (2 * 2 * (fp(2, rev[x])) % mod - 2)) % mod;\n\t\t}\n\t\telse if (rs[x])\n\t\t{\n\t\t\tf[x][1] = f[rs[x]][1] * fp(2, height) % mod;\n\t\t\tf[x][0] = (f[rs[x]][0] * fp(2, rev[x]) % mod + f[rs[x]][1] * (2 * fp(2, rev[x]) - 2 + mod) % mod) % mod;\n\t\t}\n\t\telse if (ls[x])\n\t\t{\n\t\t\tf[x][1] = f[ls[x]][1] * fp(2, height) % mod;\n\t\t\tf[x][0] = (f[ls[x]][0] * fp(2, rev[x]) % mod + f[ls[x]][1] * (2 * fp(2, rev[x]) - 2 + mod) % mod) % mod;\n\t\t}\n\t\telse \n\t\t{\n\t\t\tf[x][1] = fp(2, height);\n\t\t\tf[x][0] = (fp(2, rev[x]) - 2 + mod) % mod;\n\t\t}\n\t}\t\n\telse \n\t{\n\t\tif (rs[x] && ls[x])\n\t\t{\n\t\t\tf[x][1] = f[rs[x]][1] * f[ls[x]][1] % mod;\n\t\t\tf[x][0] = ((f[rs[x]][0] * f[ls[x]][0] % mod + f[rs[x]][1] * f[ls[x]][0] % mod) % mod + f[rs[x]][0] * f[ls[x]][1] % mod) % mod;\n\t\t}\n\t\telse if (rs[x])\n\t\t{\n\t\t\tf[x][1] = f[rs[x]][1];\n\t\t\tf[x][0] = f[rs[x]][0];\n\t\t}\n\t\telse if (ls[x])\n\t\t{\n\t\t\tf[x][1] = f[ls[x]][1];\n\t\t\tf[x][0] = f[ls[x]][0];\n\t\t}\n\t}\n\t// cout << \"x \" << x << endl;\n\t// cout << \"f[x][1] \" << f[x][1] << endl;\n\t// cout << \"f[x][0] \" << f[x][0] << endl;\n\t// cout << \"rev[x] \" << rev[x] << endl;\n}\n\nsigned main()\n{\n\tint ml = 0;\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++)\tcin >> h[i];\n\tfor (int i = 1; i <= n; i++)\n\t\tif (h[i] > h[i - 1] && h[i] > h[i + 1]) ml += h[i] - max(h[i - 1], h[i + 1]), h[i] = max(h[i - 1], h[i + 1]);\n\tbuild();\n\tfill(mulsingle, n, 1);\n\tf[0][1] = f[0][0] = 1;\n\tdp(root, 0);\n\t// cout << \"mul \" << mulsingle[root] << endl;\n\tcout << ((f[root][1] + f[root][0]) % mod * fp(2, ml) % mod) % mod << endl;\n\t// cout << \"1 \" << f[root][1] << endl;\n\t// cout << \"0 \" << f[root][0] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n      \n#define FOR(i,a,b) for(ll i = (a); i < (ll)(b); i++)\n#define REP(i,n) FOR(i,0,n)\n#define YYS(x,arr) for(auto& x:arr)\n#define PW(x) (1LL<<(x))\n#define SZ(x) ((ll)(x).size())\n\n#define pb emplace_back\n#define fi first\n#define se second\n\nusing namespace std;\n\nusing ld = long double;\nusing ll = long long int;\n\nconst ll INF = (ll)1e9 + 10;\nconst ll INFLL = (ll)1e18 + 10;\nconst ll MOD = 1e9+7;\n     \ntemplate<class T> T &chmin( T &a , const T &b ){ return a = min(a,b); }\ntemplate<class T> T &chmax( T &a , const T &b ){ return a = max(a,b); }\ntemplate<class T> void UNIQUE(vector<T> &a){ a.erase(unique(a.begin(), a.end()), a.end()); }\n\ntemplate<class S, class T> ostream& operator << (ostream& os, const pair<S, T> v){\n  os << \"(\" << v.first << \", \" << v.second << \")\"; return os;\n}\ntemplate<class T> ostream& operator << (ostream& os, const vector<T> v){\n  for(int i = 0; i < v.size(); i++){if(i > 0){os << \" \";} os << v[i];} return os;\n}\ntemplate<class T> ostream& operator << (ostream& os, const vector<vector<T>> v){\n  for(int i = 0; i < v.size(); i++){if(i > 0){os << endl;} os << v[i];} return os;\n}\n\nll in(){long long int x; scanf(\"%lld\", &x); return x;}\nld fin(){double x; scanf(\"%lf\", &x); return x;}\nchar yuyushiki[1000010]; string stin(){scanf( \"%s\", yuyushiki ); return yuyushiki;}\n\n// head\n\n\nstruct Mod{\n  unsigned n;\n  Mod() : n(0){}\n  Mod( ll x ){\n    if( x < 0 ) n = x%MOD+MOD;\n    else n = x%MOD;\n  }\n};\nMod operator + ( Mod a  , Mod b ){ return Mod( a.n + b.n ); }\nMod operator +=( Mod &a , Mod b ){ return a = a + b; }\nMod operator - ( Mod a ){ return Mod( MOD - a.n ); }\nMod operator - ( Mod a  , Mod b ){ return Mod( a.n + MOD - b.n ); }\nMod operator -=( Mod &a , Mod b ){ return a = a - b; }\nMod operator * ( Mod a  , Mod b ){ return Mod( (ll)a.n * b.n ); }\nMod operator *=( Mod &a , Mod b ){ return a = a * b; }\nMod modpow( Mod x , ll k ){\n  Mod res = 1;\n  while( k ){\n    if( k & 1 ) res *= x;\n    k /= 2;\n    x *= x;\n  }\n  return res;\n}\nll extgcd( ll a , ll b , ll &x , ll &y ){\n  ll d = a;\n  if( b != 0 ){\n    d = extgcd( b , a % b , y , x );\n    y -= a / b * x;\n  } else {\n    x = 1, y = 0;\n  }\n  return d;\n}\nMod inv( Mod a ){ ll x, y; assert( extgcd( a.n , MOD , x , y ) == 1 ); return Mod( x ); }\nMod operator / ( Mod a  , Mod b ){ return Mod( (ll)a.n * inv(b).n ); }\nMod operator /=( Mod &a , Mod b ){ return a = a / b; }\n\nusing T = tuple<Mod, Mod, Mod>;\n\nll n;\nll a[110];\n\nT dfs(ll l, ll r, ll h){\n  ll m = *min_element(a+l, a+r);\n  vector<ll> v(0);\n  v.pb(l-1);\n  FOR(i, l, r){\n    if(a[i] == m){\n      v.pb(i);\n    }\n  }\n  v.pb(r);\n  Mod tatejima = modpow(2, SZ(v) - 2);\n  Mod yokojima = modpow(2, m-h);\n  Mod both = 2;\n  REP(i, SZ(v) - 1){\n    if(v[i+1] - v[i] > 1){\n      auto w = dfs(v[i]+1, v[i+1], m);\n      tatejima *= get<0>(w) - get<2>(w) + get<1>(w) * 2;\n      yokojima *= get<1>(w);\n      both *= get<1>(w);\n    }\n  }\n  // cout << l << \" \" << r << \" \" << h << \" \" << tatejima.n << \" \" << yokojima.n << \" \" << both.n << endl;\n  return T(tatejima, yokojima, both);\n}\n\nint main(){\n\n  n = in();\n  REP(i, n){\n    a[i] = in();\n  }\n\n  auto res = dfs(0, n, 0);\n  Mod ans = get<0>(res) + get<1>(res) - get<2>(res);\n\n  printf(\"%d\\n\", (int)ans.n);\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T>\nbool chmin(T &a,T b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T>\nbool chmax(T &a,T b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>\nvoid ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>\nvoid debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>\nvoid debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];\nfor(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>\nvector<vector<T>>vec(ll x, ll y, T w){\n  vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,0,-1,0,1,1,-1,-1};\nvector<ll>dy={0,1,0,-1,1,-1,1,-1};\ntemplate<typename T>\nvector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v(ts...))>(a,make_v(ts...));\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, pair<T1, T2>&p){\n  return os << p.first << \" \" << p.second;\n}  \ntemplate< int mod >\nstruct ModInt {\n  ll x;\n\n  ModInt() : x(0) {}\n\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n  ModInt &operator+=(const ModInt &p) {\n    if((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator-=(const ModInt &p) {\n    if((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator*=(const ModInt &p) {\n    x = (int) (1LL * x * p.x % mod);\n    return *this;\n  }\n\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n\n  ModInt operator-() const { return ModInt(-x); }\n\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n  bool operator==(const ModInt &p) const { return x == p.x; }\n\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return ModInt(u);\n  }\n\n  ModInt pow(int64_t n) const {\n    ModInt ret(1), mul(x);\n    while(n > 0) {\n      if(n & 1) ret *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return ret;\n  }\n\n  friend ostream &operator<<(ostream &os, const ModInt &p) {\n    return os << p.x;\n  }\n\n  friend istream &operator>>(istream &is, ModInt &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt< mod >(t);\n    return (is);\n  }\n\n  static int get_mod() { return mod; }\n};\nusing modint = ModInt< MOD1 >;modint pow(ll n, ll x){return modint(n).pow(x);}\n//using modint=ld;\n//0-indexedで各値が何番目に小さいかを返す\n\ntemplate<typename T>\nmap<T,ll> compress(vector<T> &t){\n  sort(ALL(t));\n  t.erase(unique(ALL(t)),t.end());\n  map<T, ll> ret;\n  for(ll i=0;i<(ll)t.size();i++)\n    ret[t[i]]=i;\n  return ret;\n}\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll n;cin>>n;\n  vector<ll>h(n+1);\n  h[0]=1;\n  rep(i,0,n)cin>>h[i+1];\n  vector<ll>val=h;\n  auto mp=compress(val);\n  ll sz=mp.size();\n  auto dp=vec(n+1,sz,modint(0));\n  dp[0][0]=1;\n  rep(i,0,n){\n    ll pre=mp[h[i]],next=mp[h[i+1]];\n    ll mi=min(pre,next);\n    if(pre>=next){\n      rep(j,0,sz){\n        if(j>=next)dp[i+1][next]+=dp[i][j];\n        dp[i+1][min(j,next)]+=dp[i][j];\n      }\n    }\n    else{\n      rep(j,0,pre){\n        dp[i+1][j]+=dp[i][j]*pow(2LL,h[i+1]-h[i]);\n      }\n      modint k=dp[i][pre]*2;\n      rep(j,pre,next+1){\n        dp[i+1][j]+=k*pow(2LL,h[i+1]-val[j]);\n        if(j!=next)dp[i+1][j]-=k*pow(2LL,h[i+1]-val[j+1]);\n      }\n    }\n  }\n  //debug(dp,n+1,sz);\n  modint ret=0;\n  rep(i,0,sz)ret+=dp[n][i];\n  cout<<ret<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for (int i = (a); i <= (b); ++ i)\n#define rrp(i,a,b) for (int i = (a); i >= (b); -- i)\n#define gc() getchar()\n#define fir first\n#define sec second\ntypedef pair<int,int> pii;\ntypedef long double db;\ntypedef long long ll;\ntemplate <typename tp>\ninline void read(tp& x) {\n  x = 0; char tmp; bool key = 0;\n  for (tmp = gc(); !isdigit(tmp); tmp = gc())\n    key = (tmp == '-');\n  for (; isdigit(tmp); tmp = gc())\n    x = (x << 3) + (x << 1) + (tmp ^ '0');\n  if (key) x = -x;\n}\ntemplate <typename tp>\ninline void ckmn(tp& x,tp y) {\n  x = x < y ? x : y;\n}\ntemplate <typename tp>\ninline void ckmx(tp& x,tp y) {\n  x = x < y ? y : x;\n}\n\nconst int MOD = (int)(1e9 + 7);\ninline void Add(int& x,int y) {\n  x = x + y >= MOD ? x + y - MOD : x + y;\n}\ninline void Sub(int& x,int y) {\n  x = x - y < 0 ? x - y + MOD : x - y;\n}\nint power(int a,int b) {\n  int ret = 1;\n  while (b) {\n    if (b&1) ret = 1ll * ret * a % MOD;\n    a = 1ll * a * a % MOD;\n    b >>= 1;\n  }\n  return ret;\n}\n\nconst int N = 110;\nint dp[N][N], hei[N], n;\nvector<int> tmp;\nint main() {\n  read(n);\n  rep (i, 1, n)\n    read(hei[i]), tmp.push_back(hei[i]);\n  hei[0] = 1, tmp.push_back(1);\n  sort(tmp.begin(), tmp.end());\n  tmp.erase(unique(tmp.begin(), tmp.end()), tmp.end());\n  rep (i, 0, n)\n    hei[i] = lower_bound(tmp.begin(), tmp.end(), hei[i]) - tmp.begin();\n  dp[0][n] = 1;\n  rep (i, 1, n) {\n    rep (j, 0, min(hei[i-1], hei[i]))\n      Add(dp[i][j], 1ll * dp[i-1][j] * power(2, max(0, tmp[hei[i]] - tmp[hei[i-1]])) % MOD);\n    int sum = 0;\n    rep (j, min(hei[i-1], hei[i])+1, n)\n      Add(sum, dp[i-1][j]);\n    sum = (sum * 2) % MOD;\n    rep (j, min(hei[i-1], hei[i])+1, hei[i]) {\n      int v = power(2, tmp[j] - tmp[j-1]) - 1;\n      v = 1ll * v * power(2, tmp[hei[i]] - tmp[j]) % MOD;\n      Add(dp[i][j], 1ll * v * sum % MOD);\n    }\n    Add(dp[i][n], sum);\n  }\n  int ans = 0;\n  rep (i, 0, n) Add(ans, dp[n][i]);\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "     #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n/*\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n */                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \n                                \n                int pr[1000010];\n                int inv[1000010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n    \n       \n       \n                               //----------------kokomade tenpure------------\n\n\n\nint a[110];\n\npa dfs(int l,int r,int h){\n\tint mi=inf*100000ll;\n\tint mk=0;\n\tfor(int  i=l;i<r;i++){\n\t\tif(a[i]<mi){\n\t\t\tmi=a[i];\n\t\t\tmk=1;\n\t\t}\n\t\telse if(a[i]==mi)mk++;\n\t}\n\tassert(mk>0);\n\tif(mk==r-l){\n\t\tint ta=mi-h;\n\t//\tcout<<ta<<endl;\n\t\tassert(ta>0);\n\t\t\treturn {beki(2,ta-1,inf),(beki(2,r-l,inf)+inf-2)%inf};\n\t}\n\t\n\tvector<pa> kukan,tugi;\n\t\n\tint f=0,s=0;\n\tfor(int i=l;i<r;i++)if(a[i]!=mi){\n\t\tif(kukan.size()==0){\n\t\t\t\tkukan.pb({i,i});\n\t\t}\n\t\telse if(kukan.back().second==i-1){\n\t\t\tkukan.back().second++;\n\t\t}\n\t\telse{\n\t\t\t\tkukan.pb({i,i});\n\t\t}\n\t}\n\tf=beki(2,mi-h-1,inf);\n\tfor(auto &e:kukan){\n\t\te.second++;\n\t\ttugi.pb(dfs(e.first,e.second,mi));\n\t}\n\t\n\tfor(auto e:tugi){\n\t//\tcout<<e.first<<\" \"<<e.second<<endl;\n\t\tf*=e.first*2%inf;\n\t\tf%=inf;\n\t}\n\ts=1;\n\tint y=kukan.size();\n\tfor(int i=0;i<y;i++){\n\t\tint kirei=2*(beki(2,r-l-(kukan[i].second-kukan[i].first),inf)+inf)%inf;\n\t\tint dame=(beki(2,kukan[i].second-kukan[i].first,inf)-2+inf)%inf*beki(2,r-l-(kukan[i].second-kukan[i].first),inf)%inf;\n\t//\tcout<<\"ki \"<<kirei<<\" dame \"<<dame<<endl;\n\t\tassert((kirei+dame)%inf==(beki(2,r-l,inf)+inf)%inf);\n\t\t\n\t\tint kake1=kirei*tugi[i].first*2%inf;\n\t\tint kake2=beki(2,r-l-(kukan[i].second-kukan[i].first),inf)%inf*tugi[i].second%inf;\n\t//\tcout<<kake1<<\" \"<<kake2<<endl;\n\t\ts*=(kake1+kake2)%inf*beki((beki(2,r-l,inf)+inf),inf-2,inf)%inf;\n\t\ts%=inf;\n\t}\n\ts*=(beki(2,r-l,inf)+inf)%inf;\n\t\n\tint hiku=2;\n\tfor(auto e:tugi){\n\t//\tcout<<e.first<<\" \"<<e.second<<endl;\n\t\thiku*=e.first*2%inf;\n\t\thiku%=inf;\n\t}\n\ts%=inf;\n\ts+=inf-hiku;\n\treturn {f,s%inf};\n}\n\n signed main(){\n \t\n\n    \t       cin.tie(0);\n   \t\t\tios::sync_with_stdio(false);\n\n \tint n;\ncin>>n;\n \t\n \tfor(int i=0;i<n;i++)cin>>a[i];\n \t\n \tpa z=dfs(0,n,0);\n \t\n //\tcout<<z.first<<\" \"<<z.second<<endl;\n \t\n \tint ans=2*z.first%inf;\n //\tz.second*=(beki(2,n,inf)+inf-2)%inf;\n \tz.second%=inf;\n \tcout<<(ans+z.second)%inf<<endl;\n \treturn 0;\n \t\n  }\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n\ntypedef long long LL;\n\nconst int N=105;\nconst int MOD=1000000007;\n\nint n,f[N][N],h[N],w[N],m;\n\nint ksm(int x,int y)\n{\n\tif (y<0) return 1;\n\tint ans=1;\n\twhile (y)\n\t{\n\t\tif (y&1) ans=(LL)ans*x%MOD;\n\t\tx=(LL)x*x%MOD;y>>=1;\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&h[i]),w[++m]=h[i];\n\tstd::sort(w+1,w+m+1);\n\tm=std::unique(w+1,w+m+1)-w-1;\n\tfor (int i=1;i<=n;i++) h[i]=std::lower_bound(w+1,w+m+1,h[i])-w;\n\tf[0][0]=1;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=h[i]+1;j<=h[i-1];j++) (f[i][0]+=f[i-1][j]*2%MOD)%=MOD;\n\t\t(f[i][0]+=f[i-1][0]*2%MOD)%=MOD;\n\t\tfor (int j=1;j<=h[i];j++)\n\t\t{\n\t\t\tf[i][j]=(LL)f[i-1][j]*ksm(2,w[h[i]]-w[h[i-1]])%MOD;\n\t\t\tif (h[i-1]>=j) continue;\n\t\t\tif (j>1) (f[i][j]+=(LL)f[i-1][0]*(ksm(2,w[j]-w[j-1])-1)%MOD*2%MOD*ksm(2,w[h[i]]-w[j])%MOD)%=MOD;\n\t\t\telse (f[i][j]+=(LL)f[i-1][0]*(ksm(2,w[j])-2)%MOD*ksm(2,w[h[i]]-w[j])%MOD)%=MOD;\n\t\t}\n\t}\n\tint ans=0;\n\tfor (int i=0;i<=m;i++) (ans+=f[n][i])%=MOD;\n\tprintf(\"%d\",ans);\n\treturn 0;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<bits/stdc++.h>\n\ntypedef long long LL;\n\nusing namespace std;\nLL M = 1000000007;\nLL pow(LL a,LL b,LL m){\n    if(b==0){\n        return 1;\n    }\n    else if (b%2 ==0 ){\n        LL y = pow(a,b/2,m);\n        return (y*y)%m;\n    }\n    else{\n        return (a*pow(a,b-1,m))%m;\n    }\n\n}\n\n\nint main()\n{\n    LL N;\n    cin>>N;\n    LL arr[N], check[N], sorted[N];\n    for(int i=0; i<N; i++){\n        cin>>arr[i];\n        sorted[i] = arr[i];\n    }\n    sort(sorted, sorted +N);\n    for(int i=0; i<N; i++){\n        LL counter = 0;\n        for(int j=0; j<N; j++){\n            if(j<i && arr[j] <= arr[i])\n                counter++;\n            if(j>i && arr[j] < arr[i])\n                counter++;\n        }\n        check[i] = counter;\n    }\n\n    LL dp[N][N + 1];\n    for(int i=0; i<N; i++){\n        for(int j=0; j<N + 1; j++){\n            dp[i][j] = 0;\n        }\n    }\n\n\n    for(int i=1; i<=check[0] + 1; i++){\n        dp[0][i] = (pow(2, sorted[check[0]] - sorted[i - 1], M)*2)%M;\n    }\n    dp[0][0] = (pow(2, sorted[check[0]], M)%M);\n\n\n    for(int i=1; i<N; i++){\n       if( check[i] > check[i-1]){\n            for(int j=0; j <= check[i -1] + 1; j++){\n                dp[i][j] += (dp[i-1][j]* pow(2, sorted[check[i]] - sorted[check[i-1]], M))%M;\n                dp[i][j] += (dp[i-1][check[i-1] + 1] * pow(2, sorted[check[i]] - sorted[check[i-1]], M))%M;\n                dp[i][j] = dp[i][j]%M;\n            }\n            for(int j = check[i-1] + 2; j <= check[i] + 1; j++){\n                dp[i][j] += (dp[i-1][check[i-1] + 1] * 2 * pow(2, sorted[check[i]] - sorted[j-1], M))%M;\n                dp[i][j] = dp[i][j]%M;\n            }\n\n       }\n       else{\n            for(int j=0; j<=check[i] + 1; j++){\n                dp[i][j] += dp[i-1][j];\n                dp[i][j] += dp[i-1][check[i] + 1];\n                dp[i][j] = dp[i][j]%M;\n            }\n       }\n    }\n    cout<<dp[N-1][0]<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint ungigned\n#define db double\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pli pair<ll,int>\n#define vi vector<int>\n#define vpi vector<pii >\n#define IT iterator\n \n#define PB push_back\n#define MK make_pair\n#define LB lower_bound\n#define UB upper_bound\n#define y1 wzpakking \n#define fi first\n#define se second\n#define BG begin\n#define ED end\n \n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define UPD(x,y) (((x)+=(y))>=mo?(x)-=mo:233)\n#define CLR(a,v) memset(a,v,sizeof(a))\n#define CPY(a,b) memcpy(a,b,sizeof(a))\n#define sqr(x) (1ll*x*x)\n \n#define LS3 k*2,l,mid\n#define RS3 k*2+1,mid+1,r\n#define LS5 k*2,l,mid,x,y\n#define RS5 k*2+1,mid+1,r,x,y\n#define GET pushdown(k);int mid=(l+r)/2\n#define INF (1ll<<60)\nusing namespace std;\n\nconst int mo=1000000007;\nint power(int x,ll y){\n\tint s=1;\n\tfor (;y;y/=2,x=1ll*x*x%mo)\n\t\tif (y&1) s=1ll*s*x%mo;\n\treturn s;\n}\nconst int N=105;\nint a[N],mn[N][N];\nint fxor[N][N];\nint tr[N][N];\nint mx[N],g[N],n;\nint main(){\n\tscanf(\"%d\",&n); n++;\n\tFor(i,2,n) scanf(\"%d\",&a[i]);\n\ta[0]=a[1]=a[n+1]=a[n+2]=1;\n\tFor(i,0,n+2) mn[i][i]=i;\n\tFor(l,0,n+2) For(r,l+1,n+2)\n\t\tmn[l][r]=(a[r]<a[mn[l][r-1]]?r:mn[l][r-1]);\n\tFor(i,1,n+2) fxor[i][i-1]=1;\n\tRep(l,n+2,1) For(r,l,n+2){\n\t\tif (a[l]<a[l-1]||a[r]<a[r+1]) continue;\n\t\tint dn=max(a[l-1],a[r+1]),md=mn[l][r];\n\t\tif (a[md]>=dn) fxor[l][r]=1ll*power(2,a[md]-dn)*fxor[l][md-1]%mo*fxor[md+1][r]%mo;\n\t}\n\tfor (int l=n+1;l>=1;l--)\n\t\tfor (int r=l;r<=n+1;r++){\n\t\t\tfor (int k=l-1;k<=r+1;k++) mx[k]=0;\n\t\t\tint tmp=a[l-1];\n\t\t\tfor (int k=l;k<=r;k++)\n\t\t\t\tmx[k]=tmp=min(tmp,a[k]);\n\t\t\ttmp=a[r+1];\n\t\t\tfor (int k=r;k>=l;k--)\n\t\t\t\tmx[k]=max(mx[k],tmp=min(tmp,a[k]));\n\t\t\tint las=l-1; tr[l][r]=1;\n\t\t\tfor (int k=l;k<=r+1;k++)\n\t\t\t\tif (mx[k]>=a[k]||k==r+1) tr[l][r]=1ll*tr[l][r]*fxor[las+1][k-1]%mo,las=k;\n\t\t}\n\tg[1]=1;\n\tFor(i,2,n+2) For(j,1,i-1)\n\t\tUPD(g[i],1ll*g[j]*tr[j][i-1]%mo);\n\tprintf(\"%d\\n\",1ll*g[n+2]*500000004ll%mo);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<bitset>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; i++ )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef pair<ll,int> pli;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\nint dx[4]={1,0,-1,0} , dy[4]={0,1,0,-1} ;\n\nll dp[111][111][2];\nint a[111];\n\nll powmod(ll n,ll k){\n    ll ret=1;\n    while(k>0){\n        if(k&1)ret=ret*n%mod;\n        n=n*n%mod;\n        k>>=1;\n    }\n    return ret;\n}\n\nll rec(int l,int r,int h,int flag){\n    if(dp[l][r][flag]!=-1)return dp[l][r][flag];\n    if(l+1==r){\n        if(flag)return dp[l][r][flag]=powmod(2,a[l]-h);\n        else return dp[l][r][flag]=0;\n    }\n    int mi=inf,ma=0;\n    REP(i,l,r){\n        mi=min(mi,a[i]);\n        ma=max(ma,a[i]);\n    }\n    ll ret1,ret2;\n    ret1=ret2=1;\n    ll pos=l-1;\n    REP(i,l,r){\n        if(a[i]==mi){\n            ret2*=2;\n            if(i-pos>1){\n                ret1*=rec(pos+1,i,mi,1);\n                ret2*=(2*rec(pos+1,i,mi,1)+rec(pos+1,i,mi,0));\n            ret1%=mod;\n            ret2%=mod;\n            }\n            pos=i;\n        }\n    }\n    if(r-pos>1){\n        ret1=ret1*rec(pos+1,r,mi,1)%mod;\n        ret2=ret2*(2*rec(pos+1,r,mi,1)+rec(pos+1,r,mi,0))%mod;\n    }\n    ret2=(ret2-ret1*2+2*mod)%mod;\n    return dp[l][r][flag]=flag?ret1*powmod(2,mi-h)%mod:ret2;\n}\nint main(){\n   int n;\n   cin>>n;\n   rep(i,n)cin>>a[i];\n   rep(i,n+1)rep(j,n+1)rep(k,2)dp[i][j][k]=-1;\n   ll ans=rec(0,n,0,0)+rec(0,n,0,1);\n   cout<<ans%mod<<endl;\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*{{{*/\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<set>\n#include<map>\n#include<queue>\n#include<bitset>\n#include<vector>\n#include<limits.h>\n#include<assert.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define FOR(I, A, B) for (int I = (A); I <= (B); ++I)\n#define FORS(I, S) for (int I = 0; S[I]; ++I)\n#define RS(X) scanf(\"%s\", (X))\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())\n#define CASET int ___T; scanf(\"%d\", &___T); for(int cs=1;cs<=___T;cs++)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define F first\n#define S second\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<LL> VL;\ntypedef vector<PII> VPII;\ntypedef pair<LL,LL> PLL;\ntypedef vector<PLL> VPLL;\ntemplate<class T> void _R(T &x) { cin >> x; }\nvoid _R(int &x) { scanf(\"%d\", &x); }\nvoid _R(LL &x) { scanf(\"%lld\", &x); }\nvoid _R(double &x) { scanf(\"%lf\", &x); }\nvoid _R(char &x) { scanf(\" %c\", &x); }\nvoid _R(char *x) { scanf(\"%s\", x); }\nvoid R() {}\ntemplate<class T, class... U> void R(T &head, U &... tail) { _R(head); R(tail...); }\ntemplate<class T> void _W(const T &x) { cout << x; }\nvoid _W(const int &x) { printf(\"%d\", x); }\nvoid _W(const LL &x) { printf(\"%lld\", x); }\nvoid _W(const double &x) { printf(\"%.16f\", x); }\nvoid _W(const char &x) { putchar(x); }\nvoid _W(const char *x) { printf(\"%s\", x); }\ntemplate<class T,class U> void _W(const pair<T,U> &x) {_W(x.F); putchar(' '); _W(x.S);}\ntemplate<class T> void _W(const vector<T> &x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(' '); }\nvoid W() {}\ntemplate<class T, class... U> void W(const T &head, const U &... tail) { _W(head); putchar(sizeof...(tail) ? ' ' : '\\n'); W(tail...); }\n#ifdef HOME\n #define DEBUG(...) {printf(\"# \");printf(__VA_ARGS__);puts(\"\");}\n#else\n #define DEBUG(...)\n#endif\nint MOD = 1e9+7;\nvoid ADD(LL& x,LL v){x=(x+v)%MOD;if(x<0)x+=MOD;}\n/*}}}*/\nconst int SIZE = 1e6+10;\nLL fac[SIZE],inv[SIZE];\nLL mypow(LL x,LL y){\n    LL res=1;\n    while(y){\n        if(y&1)res=res*x%MOD;\n        y>>=1;\n        x=x*x%MOD;\n    }\n    return res;\n}\nLL C(int x,int y){\n    if(y<0||y>x)return 0;\n    return fac[x]*inv[y]%MOD*inv[x-y]%MOD;\n}\nvoid build(){\n    assert(MOD>=SIZE);\n    fac[0]=1;\n    REPP(i,1,SIZE)fac[i]=fac[i-1]*i%MOD;\n    inv[SIZE-1]=mypow(fac[SIZE-1],MOD-2);\n    for(int i=SIZE-2;i>=0;i--)inv[i]=inv[i+1]*(i+1)%MOD;\n}\nPLL solve(int AA[],int N){\n    int BB[100];\n    int mi=1e9,ma=0;\n    REP(i,N){\n        mi=min(mi,AA[i]);\n        ma=max(ma,AA[i]);\n    }\n    if(mi==ma){\n        return MP(mypow(2,ma-1),mypow(2,N-1)-1);\n    }\n    REP(i,N){\n        BB[i]=AA[i]-mi;\n    }\n    PLL res={1LL,1LL};\n    LL minus=1;\n    for(int i=0,j;i<N;i=j){\n        if(i)res.S=res.S*2%MOD;\n        if(BB[i]==0){\n            j=i+1;\n            continue;\n        }\n        for(j=i+1;j<N&&BB[j];j++);\n        PLL ret=solve(BB+i,j-i);\n        res.S=res.S*(2*ret.F+ret.S)%MOD;\n        minus=minus*ret.F*2%MOD;\n        res.F=res.F*ret.F*2%MOD;\n    }\n    ADD(res.S,-minus);\n    res.F=res.F*mypow(2,mi-1)%MOD;\n    return res;\n}\nint AA[SIZE];\nint main(){\n    build();\n    int N; R(N);\n    FOR(i,1,N)R(AA[i]);\n    LL uni=0;\n    FOR(i,1,N){\n        if(AA[i]==1){\n            AA[i]=0;\n            uni++;\n        }\n    }\n    FOR(i,1,N){\n        if(AA[i]>max(AA[i-1],AA[i+1])){\n            uni+=AA[i]-max(AA[i-1],AA[i+1]);\n            AA[i]=max(AA[i-1],AA[i+1]);\n        }\n    }\n    LL an=mypow(2,uni);\n    for(int i=1,j;i<=N;i=j){\n        if(AA[i]==0){\n            j=i+1;\n            continue;\n        }\n        for(j=i+1;j<=N&&AA[j];j++);\n        PLL res=solve(AA+i,j-i);\n        an=an*2LL*(res.F+res.S)%MOD;\n    }\n    W(an);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define fi first\n#define se second\n\nconst int N = 105, mod = 1e9 + 7;\nint n, h[N];\n\nvoid add (int &_a, int _b) {\n    assert(_b >= 0 && _b < mod);\n    _a += _b;\n    if (_a >= mod) _a -= mod;\n}\n\nint binPow (int _a, int _n) {\n    int ret = 1;\n    for (; _n; _n >>= 1, _a = 1LL * _a * _a % mod) if (_n & 1) ret = 1LL * ret * _a % mod;\n    return ret;\n}\n\npair<int, int> solve (int l, int r) {\n    int minH = mod;\n\n    bool rect = 1;\n    for (int i = l; i + 1 <= r; ++i) if (h[i] != h[i + 1]) rect = 0;\n\n    if (rect) return { ( (binPow(2, r - l + 1) + binPow(2, min(h[l] - h[l - 1], h[r] - h[r + 1]) ) ) % mod - 2 + mod) % mod,\n                      binPow(2, min(h[l] - h[l - 1], h[r] - h[r + 1]) ) };\n\n    for (int i = l; i <= r; ++i) minH = min(minH, h[i]);\n    vector< pair<int, int> > dp;\n    vector< pair<int, int> > range;\n    for (int i = l, lst = -1; i <= r; ++i) {\n        if (h[i] == minH) lst = -1;\n        else {\n            if (lst == -1) lst = i;\n            if (i == r || h[i + 1] == minH) dp.pb( { solve(lst, i) } );\n        }\n    }\n    for (int i = l, lst = -1; i <= r; ++i) {\n        if (h[i] > minH) lst = -1;\n        else {\n            if (lst == -1) lst = i;\n            if (i == r || h[i + 1] > minH) range.pb( { lst, i } );\n        }\n    }\n\n//    cout << \"l = \" << l << \"  r = \" << r << '\\n';\n//    for (auto _ : dp) cout << _.fi << ' '; cout << '\\n';\n\n    pair<int, int> ret = { 0, 0 };\n\n    int tmp = 1;\n    for (auto _ : dp) tmp = 1LL * tmp * ( (_.fi + _.se) % mod) % mod;\n    for (auto _ : range) tmp = 1LL * tmp * binPow(2, _.se - _.fi + 1) % mod;\n\n//    cout << \"tmp = \" << tmp << '\\n';\n\n    add(ret.fi, tmp);\n\n    tmp = 1;\n    for (auto _ : dp) tmp = 1LL * tmp * _.se % mod;\n    add(tmp, tmp);\n\n//    cout << \"tmp = \" << tmp << '\\n';\n\n    add(ret.fi, 1LL * tmp * ( (binPow(2, minH - max(h[l - 1], h[r + 1]) - 1) - 1 + mod) % mod) % mod);\n\n    add(ret.se, 1LL * tmp * binPow(2, minH - max(h[l - 1], h[r + 1]) - 1) % mod);\n\n//    cout << ret.fi << \"  \" << ret.se << '\\n';\n\n    return ret;\n}\n\nint main () {\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\n    cin >> n;\n    for (int i = 1; i <= n; ++i) cin >> h[i];\n\n    cout << solve(1, n).fi;\n\n    return 0;\n}\n/*\n3\n4 2 5\n\n320\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// #pragma GCC optimize (\"O3\")\n// #pragma GCC target (\"sse4\")\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<int,int> PII;\n\n#define REP(i,n) for(int i=0;i<(n);++i)\n#define FOR(i,a,b) for (int i=(a); i<(b); ++i)\n#define FORD(i,a,b) for (int i=(a)-1; i>=(b); --i)\n\n#define pb push_back\n#define mp make_pair\n#define st first\n#define nd second\n\nconst int MOD = 1000000007;\n\nLL powe(LL a, LL b) {\n  LL r = 1;\n  while (b) {\n    if (b&1) {\n      (r *= a) %= MOD;\n    }\n    a = a * a % MOD;\n    b >>= 1;\n  }\n  return r;\n}\n\nint H[105];\n// ababababab..., any\npair<LL, LL> go(int a, int b, int offset) {\n  // printf(\"%d %d %d\\n\", a, b, offset);\n\n  if (a == b) return { 1, 1 };\n\n  int mini = 1e9;\n  FOR(i,a,b) mini = min(mini, H[i] - offset);\n  if (mini == 0) return {1, 1};\n  // assert(mini > 0);\n\n  if (a + 1 == b) return { powe(2, mini-1), powe(2, mini) };\n\n  int S = a;\n\n  LL aba = 1, any = 1, aba_counted = 1;\n  int minis = 0;\n  FOR(i,a,b+1) {\n    if (i == b || H[i]-offset == mini) {\n      if (i > S) {\n        auto rec = go(S, i, offset+mini);\n\n        (aba *= 2 * rec.st) %= MOD;\n        (any *= (rec.nd + 2 * rec.st)) %= MOD;\n      }\n\n      S = i + 1;\n\n      if (i < b) {\n        (any *= 2) %= MOD;\n        ++minis;\n      }\n    }\n  }\n\n  // printf(\"%d %d %d %lld %lld(%d %lld)\\n\", a, b, offset, aba, any, mini, powe(2, mini)-2);\n  (any += 2 * aba * (powe(2, mini-1)-1)) %= MOD;\n  (aba *= powe(2, mini-1)) %= MOD;\n  // printf(\"%d %d %d %lld %lld\\n\", a, b, offset, aba, any);\n\n  return {aba, any};\n}\n\nint main() {\n  // ios_base::sync_with_stdio(0);\n\n  int N;\n  scanf(\"%d\", &N);\n  REP(i,N) {\n    scanf(\"%d\", &H[i]);\n  }\n\n  LL any = 0;\n  REP(i,N) {\n    int h = 0;\n    if (i > 0) h = max(h, H[i-1]);\n    if (i < N-1) h = max(h, H[i+1]);\n    h = min(h, H[i]);\n    any += H[i] - h;\n    H[i] = h;\n  }\n\n  LL result = powe(2, any);\n  auto r = go(0, N, 0);\n  (result *= r.nd) %= MOD;\n\n  /*\n  REP(i,N) {\n    if (H[i] == 1) {\n      ++any;\n      (result *= go(S,i)) %= MOD;\n      S = i + 1;\n    }\n  }\n\n  (result *= powe(2, any)) %= MOD;\n  */\n\n  printf(\"%lld\\n\", result);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int Mod=1e9+7;\nint n,h[110];\nll qpow(ll x,ll a){\n\tll res=1;\n\twhile (a){\n\t\tif (a&1) res=res*x%Mod;\n\t\tx=x*x%Mod; a>>=1;\n\t}\n\treturn res;\n}\ninline ll calc(int l){\n\treturn (qpow(2,l)+Mod-2)%Mod;\n}\npii solve(int l,int r,int k){\n\tint mn=h[l],cnt=0;\n\tfor (int i=l+1;i<=r;i++) mn=min(mn,h[i]);\n\tfor (int i=l;i<=r;i++)\n\t\tif (h[i]==mn) cnt++;\n\tif (cnt==r-l+1) return pii(calc(r-l+1),qpow(2,mn-k-1));\n\tint tot=r-l+1,s0=1,s1=1,last=0;\n\tfor (int i=l;i<=r+1;i++)\n\t\tif (!last&&h[i]>mn) last=i;\n\t\telse\n\t\t\tif (last&&(h[i]<=mn||i>r)){\n\t\t\t\ttot-=i-last;\n\t\t\t\tpii tmp=solve(last,i-1,mn);\n\t\t\t\ts0=(ll)s0*(tmp.first+4ll*tmp.second%Mod)%Mod;\n\t\t\t\ts1=(ll)s1*(2ll*tmp.second%Mod)%Mod;\n\t\t\t\tlast=0;\n\t\t\t}\n\ts0=(s0+Mod-s1)%Mod; pii res;\n\tres.first=(ll)s0*qpow(2,tot)%Mod;\n\tres.first=(res.first+(ll)s1*calc(tot)%Mod)%Mod;\n\tres.second=(ll)s1*qpow(2,mn-k-1)%Mod;\n\treturn res;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&h[i]);\n\tif (n==1){\n\t\tprintf(\"%lld\\n\",qpow(2,h[1]));\n\t\treturn 0;\n\t}\n\tll mul=1;\n\tfor (int i=1;i<=n;i++)\n\t\tif (h[i]>max(h[i-1],h[i+1])){\n\t\t\tmul=mul*qpow(2,h[i]-max(h[i-1],h[i+1]));\n\t\t\th[i]=max(h[i-1],h[i+1]);\n\t\t}\n\tpii ans=solve(1,n,0);\n\tprintf(\"%lld\\n\",1ll*mul*(ans.first+2ll*ans.second)%Mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mset(a, b) memset(a, b, sizeof(a))\n#define mpcy(a, b) memcpy(a, b, sizeof(a))\nusing namespace std;\ntypedef long long LL;\nconst int N = 105;\n\ntemplate <typename T> inline void read(T &AKNOI) {\n\tT x = 0, flag = 1;\n\tchar ch = getchar();\n\twhile (!isdigit(ch)) {\n\t\tif (ch == '-') flag = - 1;\n\t\tch = getchar();\n\t}\n\twhile (isdigit(ch)) {\n\t\tx = x * 10 + ch - '0';\n\t\tch = getchar();\n\t}\n\tAKNOI = flag * x;\n}\n\nnamespace ModCalculator {\n\tconst int MOD = 1e9 + 7;\n\tinline void Inc(int &x, int y) {\n\t\tx += y; if (x >= MOD) x -= MOD;\n\t}\n\tinline void Dec(int &x, int y) {\n\t\tx -= y; if (x < 0) x += MOD;\n\t}\n\tinline int Add(int x, int y) {\n\t\tInc(x, y); return x;\n\t}\n\tinline int Sub(int x, int y) {\n\t\tDec(x, y); return x;\n\t}\n\tinline int Mul(int x, int y) {\n\t\treturn 1LL * x * y % MOD;\n\t}\n\tinline int Ksm(int x, int y) {\n\t\tint ret = 1;\n\t\tfor (; y; y >>= 1) {\n\t\t\tif (y & 1) ret = Mul(ret, x);\n\t\t\tx = Mul(x, x);\n\t\t}\n\t\treturn ret;\n\t}\n\tinline int Inv(int x) {\n\t\treturn Ksm(x, MOD - 2);\n\t}\n}\nusing namespace ModCalculator;\n\nint n, h[N], dp[N][2], tot;\n\nint DP(int l, int r, int lim) {\n\tint u = ++tot;\n\tint mn = MOD, cnt = 0;\n\tfor (int i = l; i <= r; ++i) {\n\t\tmn = min(mn, h[i]);\n\t}\n\tfor (int i = l; i <= r; ++i) {\n\t\tcnt += (mn == h[i]);\n\t}\n\tif (cnt == r - l + 1) {\n\t\tif (mn == 0) {\n\t\t\tdp[u][0] = dp[u][1] = 1;\n\t\t} else {\n\t\t\tdp[u][0] = Ksm(2, mn - lim);\n\t\t\tdp[u][1] = Sub(Ksm(2, r - l + 1), 2);\n\t\t}\n\t\treturn u;\n\t}\n\tdp[u][0] = dp[u][1] = 1;\n\tfor (int i = l; i <= r; ++i) {\n\t\tif (h[i] == mn) continue;\n\t\tint j = i;\n\t\twhile (j < r && h[j + 1] > mn) ++j;\n\t\tint v = DP(i, j, mn);\n\t\ti = j;\n\t\tdp[u][0] = Mul(dp[u][0], dp[v][0]);\n\t\tdp[u][1] = Mul(dp[u][1], Add(Mul(dp[v][0], 2), dp[v][1]));\n\t}\n\tdp[u][1] = Sub(Mul(dp[u][1], Ksm(2, cnt)), Mul(dp[u][0], 2));\n\tdp[u][0] = Mul(dp[u][0], Ksm(2, mn - lim));\n\treturn u;\n}\n\nvoid init() {\n\tread(n);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tread(h[i]);\n\t}\n}\n\nvoid solve() {\n\tint ans = 1;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (h[i] > max(h[i - 1], h[i + 1])) {\n\t\t\tans = Mul(ans, Ksm(2, h[i] - max(h[i - 1], h[i + 1])));\n\t\t\th[i] = max(h[i - 1], h[i + 1]);\n\t\t}\n\t}\n\tint u = DP(1, n, 0);\n\tprintf(\"%d\\n\", Mul(ans, Add(dp[u][0], dp[u][1])));\n}\n\nint main() {\n\tinit();\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#define mod 1000000007\n#define MN 110\n\nint f[MN][MN], g[MN];\nint h[MN], b[MN];\nint c[MN];\n\nint qpow(int x, int p)\n{\n\tint ans = 1;\n\twhile(p)\n\t{\n\t\tif(p & 1) ans = 1ll * ans * x % mod; \n\t\tx = 1ll * x * x % mod; p >>= 1;\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tint n; scanf(\"%d\", &n);\n\tfor(int i = 1; i <= n; i++) scanf(\"%d\", &h[i]), b[i] = h[i];\n\tstd::sort(b + 1, b + n + 1); int N = std::unique(b + 1, b + n + 1) - b - 1;\n\tfor(int i = 1; i <= n; i++) h[i] = std::lower_bound(b + 1, b + N + 1, h[i]) - b;\n\tb[0] = 1; for(int i = 1; i <= N; i++) c[i] = qpow(2, b[i] - b[i - 1]) - 1;\n\tg[0] = 1;\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tif(h[i - 1] < h[i])\n\t\t{\n\t\t\tfor(int j = 1; j <= h[i - 1]; j++) \n\t\t\t\tf[i][j] = f[i - 1][j];\n\t\t\tfor(int j = h[i - 1] + 1; j <= h[i]; j++)\n\t\t\t\tf[i][j] = 2 * g[i - 1] % mod;\n\t\t\tg[i] = 2 * g[i - 1] % mod;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(int j = 1; j <= h[i]; j++)\n\t\t\t\tf[i][j] = 1ll * f[i - 1][j] * qpow(2, b[h[i - 1]] - b[h[i]]) % mod;\n\t\t\tg[i] = 2 * g[i - 1] % mod;\n\t\t\tfor(int j = h[i] + 1; j <= h[i - 1]; j++)\n\t\t\t\tg[i] = (g[i] + 2ll * c[j] * f[i - 1][j] % mod * qpow(2, b[h[i - 1]] - b[j])) % mod;\n\t\t}\n\t}\n\tint ans = g[n]; \n\tfor(int i = 1; i <= h[n]; i++) ans = (ans + 1ll * c[i] * f[n][i] % mod * qpow(2, b[h[n]] - b[i])) % mod;\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "\t#include <iostream>\n    #include <string>\n    #include <set>  \n    #include <stack>\n    #include <algorithm>\n    #include <vector>\n    #include <cmath>\n    #include <queue>\n    #include <deque>\n    #include <cstring>\n    #include <cstdio>\n    #include <map>\n    #include <numeric>\n    #include <cassert>\n    #include <iomanip>\n    #include <sstream>\n    #include <ctime>\n    #include <bitset> \nusing namespace std;\n#define for1(i,a,b) for(int i=(a);i<(int)(b);++i)\n#define rep(i,maxn) for1(i,0,maxn)\n#define ford(i,b,a) for(int i=(int)(b)-1;i>=a;--i)\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<int,pii > piii;\n#define inf 0x3f3f3f3f\n#define mod 1000000007\n#define st first\n#define nd second\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define dprintf(...) printf(__VA_ARGS__)\nconst int maxn=110;\nll h[maxn];\nll ncnt;\nint n;\nvector<pii> dive;\nll qp(ll base,ll ind)\n{\n\tll ans=1;\n\tif(ind<0)cout<<\"Wrong\"<<endl;\n\twhile(ind>0)\n\t{\n\t\tif(ind&1)ans=ans*base%mod;\n\t\tind>>=1;\n\t\tbase=base*base%mod;\n\t}\n\treturn ans%mod;\n}\nll f[maxn],g[maxn];\nll cal(int bg,int ed)\n{\n\tf[bg]=qp(2,h[bg]-1);\n\tg[bg]=1;\n\tfor1(i,bg,ed)\n\t{\n\t//\tcout<<i<<\" \"<<f[i]<<\" \"<<g[i]<<endl;\n\t//\tsystem(\"pause\");\n\t\tif(h[i+1]>=h[i])\n\t\t{\n\t\t\tll buf=qp(2,h[i+1]-h[i]);\n\t\t\tf[i+1]=(f[i]+g[i])%mod*buf%mod;\n\t\t\tg[i+1]=g[i]*2%mod;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tll rst=qp(2,h[i]-h[i+1])-1;\n\t\t//\tcout<<rst<<endl;\n\t\t\tll res=0;\n\t\t\tll buf=1;\n\t\t\tf[i+1]=(f[i]+g[i])%mod;\n\t\t\tint cur=i;ll mx=h[i];ll pre=h[i];\n\t\t\twhile(rst>0&&cur>bg)\n\t\t\t{\n\t\t\t\tcur--;\n\t\t\t\tif(h[cur]==pre)continue;\n\t\t\t\tif(h[cur]>pre)\n\t\t\t\t{\n\t\t\t\t\tbuf=buf*qp(2,h[cur]-pre)%mod;\n\t\t\t\t\tpre=h[cur];\n\t\t\t\t//\tcout<<cur<<\" \"<<buf<<endl;\n\t\t\t\t//\tsystem(\"pause\");\n\t\t\t\t\tcontinue;\n\t\t\t\t} \n\t\t\t\tif(h[cur]<=h[i+1])\n\t\t\t\t{\n\t\t\t\t\tres+=rst*2%mod*g[cur]%mod*buf%mod;\n\t\t\t\t\tres%=mod;\n\t\t\t//\t\tcout<<res<<endl;\n\t\t\t\t\tbuf=0;rst=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpre=h[cur];\n\t\t\t\tif(h[cur]>=mx)continue;\n\t\t\t//\tcout<<h[i]<<\" \"<<mx<<\" \"<<h[cur]<<endl;\n\t\t\t\tll ok=qp(2,h[i]-h[cur])-qp(2,h[i]-mx);\n\t\t\t\tif(ok<0)ok=(ok+mod)%mod;\n\t\t\t\tres+=g[cur]*2*ok%mod*buf%mod;\n\t\t\t\trst=((rst+mod)-ok)%mod;\n\t\t\t//\tcout<<ok<<\" \"<<rst<<\" \"<<res<<endl;\n\t\t\t//\tsystem(\"pause\");\n\t\t\t\tmx=h[cur];\n\t\t\t}\n\t\t//\tif(buf<0)cout<<\"Error\"<<endl;\n\t\t\tres=(res+rst*buf%mod)%mod;\n\t\t\tf[i+1]+=res;\n\t\t\tf[i+1]%=mod;\n\t\t\tg[i+1]=(res+g[i])*2%mod;\n\t\t//\tcout<<res<<\" \"<<buf<<\" \"<<f[i+1]<<\" \"<<g[i+1]<<endl;\n\t\t}\n\t}\n\treturn f[ed]%mod;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\trep(i,n)scanf(\"%lld\",h+i);\n\tint stp=0,edp=-1;\n\trep(i,n)\n\t{\n\t\tll pre=(i?h[i-1]:1);\n\t\tll nxt=(i==n-1?1:h[i+1]);\n\t\tll cur;\n\t\tcur=min(h[i],pre);\n\t\tcur=max(cur,min(h[i],nxt));\n\t\tncnt+=h[i]-cur;\n\t\th[i]=cur;\n\t//\tcout<<i<<\" \"<<cur<<\" \"<<pre<<\" \"<<nxt<<\" \"<<h[i]<<endl;\n\t\tif(h[i]==1)\n\t\t{\n\t//\t\tcout<<i<<endl;\n\t\t\tif(stp<edp)\n\t\t\t\tdive.pb(mp(stp,edp));\n\t\t\tstp=i+1,edp=i;\n\t\t\tncnt++;\n\t\t}\n\t\telse edp++;\n\t}\n\tif(stp<edp)dive.pb(mp(stp,edp));\n\tll ans=1;\n\tans%=mod;\n\trep(i,dive.size())\n\t{\n\t\tans*=2*cal(dive[i].st,dive[i].nd);\n\t\tans%=mod;\n\t}\n//\tcout<<ans<<endl;\n//\tcout<<ans<<endl;\n\tif(!dive.size())ans=1;\n\tif(ncnt)ans*=qp(2,ncnt);\n\tans%=mod;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n\n#define ln                '\\n'\n#define all(dat)           dat.begin(), dat.end()\n#define loop(i, to)        for (int i = 0; i < to; ++i)\n#define cont(i, to)        for (int i = 1; i <= to; ++i)\n#define circ(i, fr, to)    for (int i = fr; i <= to; ++i)\n#define foreach(i, dat)    for (__typeof(dat.begin()) i = dat.begin(); i != dat.end(); ++i)\n\ntypedef long long          num;\n\nusing namespace std;\n\nconst int nsz = 1e2, mod = 1e9 + 7;\nint n, h[nsz + 5], dp[nsz + 5], f[nsz + 5][nsz + 5];\n\nnum inline qpow(num a, int p) {\n    num res = 1;\n    for (; p > 0; p >>= 1) {\n        if (p & 1) {\n            res *= a;\n            res %= mod;\n        }\n        a *= a;\n        a %= mod;\n    }\n    return res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin >> n;\n    cont (i, n) {\n        cin >> h[i];\n    }\n    dp[1] = qpow(2, h[1]);\n    cont (i, n) {\n        f[1][i] = 2 * qpow(2, h[1] - h[i]) % mod;\n    }\n    circ (i, 2, n) {\n        dp[i] = (dp[i - 1] + f[i - 1][i]) * qpow(2, h[i] - h[i - 1]) % mod;\n        cont (j, n) {\n            if (h[i] <= h[i - 1]) {\n                f[i][j] = h[i] > h[j] ? f[i - 1][j] : f[i - 1][i];\n            } else {\n                if (h[i] > h[j]) {\n                    f[i][j] = f[i - 1][j] * qpow(2, h[i] - (h[j] > h[i - 1] ? h[j] : h[i - 1])) % mod;\n                } else {\n                    f[i][j] = f[i - 1][j];\n                }\n            }\n            f[i][j] += f[i - 1][i] * qpow(2, h[i] - max(h[i - 1], h[j])) % mod;\n            f[i][j] %= mod;\n        }\n    }\n    cout << dp[n] << ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <numeric>\n\ntemplate <class T, class U>\ninline bool chmin(T &lhs, const U &rhs) {\n  if (lhs > rhs) {\n    lhs = rhs;\n    return true;\n  }\n  return false;\n}\n\ntemplate <class T, class U>\ninline bool chmax(T &lhs, const U &rhs) {\n  if (lhs < rhs) {\n    lhs = rhs;\n    return true;\n  }\n  return false;\n}\n\n// [l, r) from l to r\nstruct range {\n  struct itr {\n    int i;\n    constexpr itr(int i_): i(i_) { }\n    constexpr void operator ++ () { ++i; }\n    constexpr int operator * () const { return i; }\n    constexpr bool operator != (itr x) const { return i != x.i; }\n  };\n  const itr l, r;\n  constexpr range(int l_, int r_): l(l_), r(std::max(l_, r_)) { }\n  constexpr itr begin() const { return l; }\n  constexpr itr end() const { return r; }\n};\n\n// [l, r) from r to l\nstruct revrange {\n  struct itr {\n    int i;\n    constexpr itr(int i_): i(i_) { }\n    constexpr void operator ++ () { --i; }\n    constexpr int operator * () const { return i; }\n    constexpr bool operator != (itr x) const { return i != x.i; }\n  };\n  const itr l, r;\n  constexpr revrange(int l_, int r_): l(l_ - 1), r(std::max(l_, r_) - 1) { }\n  constexpr itr begin() const { return r; }\n  constexpr itr end() const { return l; }\n};\n\ntemplate <uint32_t Modulus>\nclass modular {\npublic:\n  using value_type = uint32_t;\n  using max_type = uint64_t;\n\n  static constexpr value_type mod = Modulus;\n  static constexpr value_type mod_min = 1;\n  static constexpr value_type mod_max = 2147483647;\n  static_assert(mod >= mod_min, \"invalid mod :: too small\");\n  static_assert(mod <= mod_max, \"invalid mod :: too big\");\n\n  template <class T>\n  static constexpr value_type normalize(T value_) {\n    if (value_ < 0) {\n      value_ = -value_;\n      value_ %= mod;\n      if (value_ == 0) return 0;\n      return mod - value_;\n    }\n    return value_ % mod;\n  }\n\nprivate:\n  value_type value;\n\npublic:\n  constexpr modular(): value(0) { }\n  template <class T>\n  explicit constexpr modular(T value_): value(normalize(value_)) { }\n  template <class T>\n  explicit constexpr operator T() { return static_cast<T>(value); }\n\n  constexpr value_type operator () () const { return value; }\n  constexpr modular operator - () const { return modular(mod - value); }\n  constexpr modular operator ~ () const { return inverse(); }\n\n  constexpr value_type &extract() { return value; }\n  constexpr modular inverse() const { return power(mod - 2); }\n  constexpr modular power(max_type exp) const {\n    modular res(1), mult(*this);\n    while (exp > 0) {\n      if (exp & 1) res *= mult;\n      mult *= mult;\n      exp >>= 1;\n    }\n    return res;\n  }\n\n  constexpr modular operator + (const modular &rhs) const { return modular(*this) += rhs; }\n  constexpr modular& operator += (const modular &rhs) { \n    if ((value += rhs.value) >= mod) value -= mod; \n    return *this; \n  }\n\n  constexpr modular operator - (const modular &rhs) const { return modular(*this) -= rhs; }\n  constexpr modular& operator -= (const modular &rhs) { \n    if ((value += mod - rhs.value) >= mod) value -= mod; \n    return *this; \n  }\n\n  constexpr modular operator * (const modular &rhs) const { return modular(*this) *= rhs; }\n  constexpr modular& operator *= (const modular &rhs) { \n    value = (max_type) value * rhs.value % mod;\n    return *this;\n  }\n\n  constexpr modular operator / (const modular &rhs) const { return modular(*this) /= rhs; }\n  constexpr modular& operator /= (const modular &rhs) { return (*this) *= rhs.inverse(); }\n\n  constexpr bool zero() const { return value == 0; }\n  constexpr bool operator == (const modular &rhs) const { return value == rhs.value; }\n  constexpr bool operator != (const modular &rhs) const { return value != rhs.value; }\n  friend std::ostream& operator << (std::ostream &stream, const modular &rhs) {\n    return stream << rhs.value;\n  }\n\n};\n\ntemplate <class T>\nstruct fix_point: private T {\n  explicit constexpr fix_point(T &&func): T(std::forward<T>(func)) { }\n  template <class... Args>\n  constexpr decltype(auto) operator () (Args &&... args) const {\n    return T::operator()(*this, std::forward<Args>(args)...);\n  }\n};\n\ntemplate <class T>\nconstexpr decltype(auto) make_fix_point(T &&func) {\n  return fix_point<T>{std::forward<T>(func)};\n}\n\nusing modint = modular<1000000007>;\n\nint main() {\n  int N;\n  std::cin >> N;\n  std::vector<int> H(N);\n  for (int &x: H) {\n    std::cin >> x;\n  }\n  auto ans = make_fix_point([&](auto dfs, int l, int r, int d) -> std::pair<modint, modint> {\n    int min_height = *std::min_element(H.cbegin() + l, H.cbegin() + r);\n    int height = min_height - d;\n    int free = r - l;\n    std::vector<std::pair<modint, modint>> up;\n    {\n      int right = r;\n      while (right > l && H[right - 1] == min_height) {\n        --right;\n      }\n      int left = l;\n      for (int i: range(l, right)) {\n        if (H[i] == min_height) {\n          if (left < i) {\n            up.emplace_back(dfs(left, i, min_height));\n            free -= i - left;\n          }\n          left = i + 1;\n        }\n      }\n      if (left < right) {\n        up.emplace_back(dfs(left, right, min_height));\n        free -= right - left;\n      }\n    }\n    if (up.empty()) {\n      return { modint(2).power(height), modint(2).power(r - l) - modint(2) };\n    }\n    modint alternate(1);\n    for (auto p: up) {\n      alternate *= p.first;\n    }\n    modint continuous = modint(2).power(free);\n    for (auto p: up) {\n      continuous *= p.first * modint(2) + p.second;\n    }\n    return { modint(2).power(height) * alternate, continuous - modint(2) * alternate };\n  })(0, N, 0);\n  std::cout << ans.first + ans.second << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct state {\n\tint h;\n\tlong long ans1 = 2;\n\tlong long ans2 = 0;\n\t\n\tstate(int h) : h(h) {}\n};\n\nint n, m = 1000000007;\nint h[100];\n\nlong long powmod(long long x, long long y) {\n\tlong long ans = 1;\n\t\n\twhile (y > 0) {\n\t\tif (y & 1) ans = ans * x % m;\n\t\tx = x * x % m;\n\t\ty >>= 1;\n\t}\n\t\n\treturn ans;\n}\n\nlong long mod_inverse(long long a, long long m) {\n    long long b = m, x = 1, y = 0;\n    \n    while (b) {\n        long long t = a / b;\n        \n        a -= t * b;\n        x -= t * y;\n        \n        swap(a, b);\n        swap(x, y);\n    }\n    \n    return (m + x % m) % m;\n}\n\nlong long solve() {\n\tint i, j;\n\tvector <state> v;\n\t\n\tv.push_back(state(0));\n\t\n\tfor (i = 0; i < n; i++) {\n\t\tv.push_back(state(h[i]));\n\t}\n\t\n\tv.push_back(state(0));\n\t\n\twhile (v.size() > 3) {\n\t\tint x = 0;\n\t\t\n\t\tfor (i = 0; i < v.size(); i++) {\n\t\t\tif (v[i].h > v[x].h) x = i;\n\t\t}\n\t\t\n\t\tif (v[x].h == v[x + 1].h) {\n\t\t\tlong long tmp1, tmp2;\n\t\t\t\n\t\t\ttmp1 = v[x].ans1 * v[x + 1].ans1 % m * mod_inverse(2, m) % m;\n\t\t\ttmp2 = ((v[x].ans1 + v[x].ans2) * (v[x + 1].ans1 + v[x + 1].ans2) - tmp1 + m) % m;\n\t\t\t\n\t\t\tv[x].ans1 = tmp1;\n\t\t\tv[x].ans2 = tmp2;\n\t\t\tv.erase(v.begin() + x + 1);\n\t\t} else {\n\t\t\tint h = v[x].h - max(v[x - 1].h, v[x + 1].h);\n\t\t\t\n            v[x].ans1 = v[x].ans1 * powmod(2, h) % m;\n\t\t\tv[x].h -= h;\n\t\t}\n\t}\n\t\n\treturn (v[1].ans1 * powmod(2, v[1].h - 1) % m + v[1].ans2) % m;\n}\n\nint main() {\n\tint i;\n\t\n\tscanf(\"%d\", &n);\n\t\n\tfor (i = 0; i < n; i++) scanf(\"%d\", &h[i]);\n\t\n\tprintf(\"%lld\\n\", solve());\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nconst int N = 105;\nconst int INF = 0x3f3f3f3f;\ntypedef long long ll;\n#define lson l, m, rt<<1\n#define rson m+1, r, rt<<1|1\nconst int MOD = 1e9+7;\n\n\nint h[N];\nint Has[N]; int tot;\nll dp[N][N];\n\nll Pow(ll x, ll y) {\n\tif(y <= 0) return 1;\n\tll result = 1;\n\twhile(y) {\n\t\tif(y & 1)\n\t\t\tresult = result * x % MOD;\n\t\ty >>= 1;\n\t\tx = x*x % MOD;\n\t}\n\treturn result;\n}\n\nint main() {\n\tint n;\n\twhile(~scanf(\"%d\", &n)) {\n\t\ttot = 0;\n\t\tmemset(dp, 0, sizeof(dp));\n\t\th[0] = 0;\n\t\tdp[0][0] = 1;\n\n\t\tfor(int i = 1; i <= n; ++i) {\n\t\t\tscanf(\"%d\", &h[i]);\n\t\t\tHas[++tot] = h[i];\n\t\t}\n\t\tsort(Has + 1, Has + tot + 1);\n\t\ttot = unique(Has+1, Has + tot + 1) - Has - 1;\n\t\t\n\t\tfor(int i = 1; i <= n; ++i) {\n\t\t\th[i] = lower_bound(Has + 1, Has + tot + 1, h[i]) - Has;\n\t\t}\n\t\t\n\t\t\n\t\tfor(int i = 1; i <= n; ++i) {\n\t\t\tdp[i][0] = dp[i-1][0] * 2 % MOD;\n\t\t\tfor(int j = h[i] + 1; j <= h[i-1]; ++j) dp[i][0] = (dp[i][0] + dp[i-1][j] * 2 % MOD) % MOD;\n\n\t\t\tll tmpPow = Pow(2, Has[h[i]] - Has[h[i-1]]);\n\t\t\tfor(int j = 1; j <= h[i]; ++j) {\n\t\t\t\tdp[i][j] = dp[i-1][j] * tmpPow % MOD;\n\t\t\t}\n\n\t\t\tfor(int j = h[i-1] + 1; j <= h[i]; ++j) {\n\t\t\t\tdp[i][j] = (dp[i][j] + j==1? ( dp[i-1][0] * ( Pow(2, Has[j]) - 2) % MOD * Pow(2, Has[h[i]] - Has[j]) % MOD ) :\n\t\t\t\t\t\t\t\t\t\t\t ( dp[i-1][0] * ( Pow(2, Has[j]-Has[j-1]) - 1) % MOD * 2 % MOD * Pow(2, Has[h[i]]-Has[j]) % MOD ) \n\t\t\t\t\t\t\t\t\t\t\t ) %MOD;\n\t\t\t}\n\t\t}\n\n\n\t\tll result = 0;\n\t\tfor(int i = 0; i <= tot; ++i) {\n\t\t\tresult = (result + dp[n][i]) % MOD;\n\t\t}\n\t\tprintf(\"%lld\\n\", result);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<cstring>\n#include<stdlib.h>\n#include<time.h>\n#include<math.h>\n#include<algorithm>\n#include<vector>\n#define ll long long\n#define maxn 105\n#define p 1000000007\n#define inf 0x3f3f3f3f\nusing namespace std;\nint n,h[maxn],root,tot=1;\nint si[maxn],a[maxn];\nll f[maxn][2];// f[maxn][0]表示非黑白相间的方案数\nvector<int> c[maxn];\n\ninline int read()\n{\n\tint num,sign=1;\n\tchar c;\n\twhile((c=getchar())<'0'||c>'9')\n\t\tif(c=='-')sign=-1;\n\tnum=c-'0';\n\twhile((c=getchar())>='0'&&c<='9')\n\t\tnum=(num<<1)+(num<<3)+c-'0';\n\treturn num*sign;\n}\n\nvoid build(int l,int r,int id)\n{\n\tint minheight=inf,top=0;\n\tint st[maxn];\n\tsi[id]=r-l+1;\n\tfor(register int i=l;i<=r;++i)\n\t{\n\t\tif(h[i]<=minheight)\n\t\t{\n\t\t\tif(h[i]<minheight)\n\t\t\t{\n\t\t\t\ttop=0;\n\t\t\t\tminheight=h[i];\n\t\t\t\tst[++top]=i;\n\t\t\t}\n\t\t\telse\n\t\t\t\tst[++top]=i;\n\t\t}\n\t}\n\tst[++top]=r+1,a[id]=minheight;\n\tint lastgo=l;\n\tfor(register int i=1;i<=top;++i)\n\t{\n\t\tif(st[i]==lastgo)\n\t\t{\n\t\t\t++lastgo;\n\t\t\tcontinue;\n\t\t}\n\t\t++tot;\n\t\tc[id].push_back(tot);\n\t\tbuild(lastgo,st[i]-1,tot);\n\t\tlastgo=st[i]+1;\n\t}\n}\n\ninline ll ksm(ll a,ll b)\n{\n\tll res=1;\n\twhile(b)\n\t{\n\t\tif(b&1)res=(res*a)%p;\n\t\tb>>=1;\n\t\ta=(a*a)%p;\n\t}\n\treturn res;\n}\n\nvoid dfs(int u,int lasth)\n{\n\tint sum=si[u];\n\tint H=a[u]-lasth;\n\tf[u][1]=1,f[u][0]=1;\n\tfor(register int i=0;i<c[u].size();++i)\n\t{\n\t\tint v=c[u][i];\n\t\tdfs(v,a[u]);\n\t\tf[u][0]=(f[u][0]*((f[v][1]+f[v][0])%p)%p+(f[u][0]*f[v][1])%p)%p;\n\t\tf[u][1]=(f[v][1]*f[u][1])%p;\n\t\tsum-=si[v];\n\t}\n\tf[u][0]=((f[u][0]*ksm(2,sum))%p+(p-2*f[u][1]%p)%p)%p;\n\tf[u][1]=(f[u][1]*ksm(2,H))%p;\n}\n\nint main()\n{\n\tn=read();\n\tfor(register int i=1;i<=n;++i)h[i]=read();\n\tbuild(1,n,1);\n\tdfs(1,0);\n\tprintf(\"%lld\\n\",(f[1][0]+f[1][1])%p);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nconst int MOD = (int)1e9 + 7;\n\nint n,m,h[101],hnum[101],dh[101];\nlong long dp[101][101];\n\nint pow_(long long x,int y) {///快速幂求 x的y次方\n    long long ans = 1;\n    if(y > 0) {\n        while(y) {\n            if(y % 2)ans = ans * x % MOD;\n            x = x * x % MOD;\n            y /= 2;\n        }\n    }\n    return ans;\n}\n\nint main() {\n    scanf(\"%d\",&n);\n    for(int i = 1;i <= n;i ++) {\n        scanf(\"%d\",&h[i]);\n        dh[++ m] = h[i];\n    }\n    sort(dh + 1,dh + m + 1);///高度排序\n    m = unique(dh + 1,dh + m + 1) - dh - 1;///离散化 m是离散化后的长度\n    for(int i = 1;i <= n;i ++) {\n        hnum[i] = lower_bound(dh + 1,dh + m + 1,h[i]) - dh;\n    }\n    dp[0][0]=1;\n    for(int i = 1;i <= n;i ++) {\n        for(int j = hnum[i] + 1;j <= hnum[i - 1];j ++)\n            (dp[i][0] += dp[i - 1][j] * 2 % MOD) %= MOD;\n\n        (dp[i][0] += dp[i - 1][0] * 2 % MOD) %= MOD;///交叉或者不交叉\n\n        int d = pow_(2,h[i] - h[i - 1]);\n        for(int j = 1;j <= min(hnum[i - 1],hnum[i]);j ++) {\n            dp[i][j] = dp[i - 1][j] * d % MOD;\n        }\n        for(int j = hnum[i - 1] + 1;j <= hnum[i];j ++) {///比前一列高出的部分\n            if(j > 1)(dp[i][j] += dp[i - 1][0] * (pow_(2,dh[j] - dh[j - 1]) - 1) % MOD * 2 % MOD * pow_(2,h[i] - dh[j]) % MOD) %= MOD;\n            else (dp[i][1] += dp[i - 1][0] * (pow_(2,dh[1]) - 2) % MOD * pow_(2,h[i] - dh[1]) % MOD) %= MOD;///上一列中无重复相同的乘上化不超过上一列高度中有重复的\n        }\n    }\n    long long ans = 0;\n    for(int i = 0;i <= hnum[n];i++)\n        (ans += dp[n][i]) %= MOD;\n    printf(\"%lld\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <memory.h>\n#include <math.h>\n#include <assert.h>\n#include <queue>\n#include <map>\n#include <set>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <functional>\n#include <unordered_map>\n\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define Fi first\n#define Se second\n#define pb(x) push_back(x)\n#define szz(x) (int)x.size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define all(x) x.begin(), x.end()\ntypedef tuple<int, int, int> t3;\n\nint N, h[110];\nll d[110][210];\nconst ll MOD = 1e9 + 7;\nll pw(int x, int y) {\n\tll res = 1;\n\twhile(y) {\n\t\tif(y & 1) res = res * x % MOD;\n\t\tx = (ll)x * x % MOD;\n\t\ty >>= 1;\n\t}\n\treturn res;\n}\n\nll get_pw2(int l, int r) {\n\tll val = pw(2, r + 1);\n\tval = (val + MOD - pw(2, l)) % MOD;\n\treturn val;\n}\n\nvector <int> hv;\npii get_seg(int v) {\n\tif(v == 1) return pii(1, hv[0] - 1);\n\tif(v % 2 == 0) return pii(hv[v/2-1], hv[v/2-1]);\n\telse return pii(hv[v/2-1] + 1, hv[v/2] - 1);\n}\n\nvoid solve(){\n\tscanf(\"%d\", &N);\n\tfor(int i=1;i<=N;i++) scanf(\"%d\", h+i);\n\tfor(int i=1;i<=N;i++) hv.pb(h[i]);\n\tsort(all(hv)); hv.resize(unique(all(hv)) - hv.begin());\n\tfor(int i=1;i<=N;i++) h[i] = (int)(lower_bound(all(hv), h[i]) - hv.begin());\n\tfor(int i=1;i<=2*h[1]+2;i++) {\n\t\tpii s = get_seg(i);\n\t\tif(s.Fi <= s.Se) {\n\t\t\tint lv = hv[h[1]] - s.Se;\n\t\t\tint rv = hv[h[1]] - s.Fi;\n\t\t\td[1][i] = get_pw2(lv, rv);\n\t\t}\n\t\tif(i == 2*h[1]+2) d[1][i] = (d[1][i] + 1) % MOD;\n\t}\n\tfor(int i=1;i<N;i++) {\n\t\tif(h[i] >= h[i+1]) {\n\t\t\tfor(int j=1;j<=2*h[i+1]+1;j++) {\n\t\t\t\td[i+1][j] = (d[i+1][j] + d[i][j]) % MOD;\n\t\t\t}\n\t\t\tll sum = 0;\n\t\t\tfor(int j=2*h[i+1]+2;j<=2*h[i]+2;j++) {\n\t\t\t\tsum = (sum + d[i][j]) % MOD;\n\t\t\t}\n\t\t\td[i+1][2*h[i+1]+2] = (d[i+1][2*h[i+1]+2] + sum * 2) % MOD;\n\t\t}\n\t\telse {\n\t\t\tfor(int j=1;j<=2*h[i]+1;j++) {\n\t\t\t\td[i+1][j] = (d[i+1][j] + (ll)pw(2, hv[h[i+1]] - hv[h[i]]) * d[i][j]) % MOD;\n\t\t\t}\n\t\t\tfor(int j=2*h[i]+2;j<=2*h[i+1]+2;j++) {\n\t\t\t\tpii s = get_seg(j);\n\t\t\t\tint lv = hv[h[i+1]] - s.Se;\n\t\t\t\tint rv = hv[h[i+1]] - s.Fi;\n\t\t\t\tll val = get_pw2(lv, rv);\n\t\t\t\tif(j == 2*h[i+1]+2) val = 2;\n\t\t\t\td[i+1][j] = (d[i+1][j] + val * d[i][2*h[i]+2]) % MOD;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tll sum = 0;\n\trep(i, 210) sum = (sum + d[N][i]) % MOD;\n\tprintf(\"%lld\\n\", sum);\n}\n\nint main(){\n\tint Tc = 1; //scanf(\"%d\", &Tc);\n\tfor(int tc=1;tc<=Tc;tc++){\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <string>\n#include <utility>\n#include <vector>\n\nconst int DEBUG = 0;\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define DEBUGP(val) cerr << #val << \"=\" << val << \"\\n\"\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\nconst ll mod = 1e9 + 7;\n\n/*\n * Dependencies: typedef long long ll\n * Headers: iostream\n * Verified by: ARC099-F\n *              https://beta.atcoder.jp/contests/arc099/submissions/2743855\n */\n\ntemplate<ll mod = (ll)1e9 + 7>\nstruct ModInt {\n  ll x;\n  ModInt(void): x(0) {}\n  ModInt(ll x): x(x % mod){}\n  ModInt(const ModInt &x): x(x.x) {}\n  ModInt operator+(ModInt o) const {\n    ll y = x + o.x;\n    if (y >= mod) y -= mod;\n    return ModInt(y);\n  }\n  ModInt operator-(ModInt o) const {\n    ll y = x - o.x + mod;\n    if (y >= mod) y -= mod;\n    return ModInt(y);\n  }\n  ModInt operator*(ModInt o) const {\n    return ModInt((x * o.x) % mod);\n  }\n  ll to_ll() const {\n    return x;\n  }\n  bool operator<(ModInt o) const {\n    return x < o.x;\n  }\n  ModInt pow(ll e) {\n    assert (e >= 0);\n    ModInt sum = 1;\n    ModInt cur = *this;\n    while (e > 0) {\n      if (e % 2) {\n        sum = sum * cur;\n      }\n      cur = cur * cur;\n      e /= 2;\n    }\n    return sum;\n  }\n  ModInt inv(void) {\n    return pow(mod - 2);\n  }\n};\n\ntemplate<ll mod>\nostream &operator<<(ostream &os, ModInt<mod> mi) {\n  return os << mi.x;\n}\n\n\nconst int N = 110;\nModInt<> dp[N][N];\n\nint main(void) {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  VL h(n);\n  REP(i, 0, n) cin >> h[i];\n  VL coord;\n  REP(i, 0, n) {\n    if (h[i] >= 2) {\n      coord.push_back(h[i]);\n    }\n  }\n  coord.push_back(0);\n  sort(coord.begin(), coord.end());\n  coord.erase(unique(coord.begin(), coord.end()), coord.end());\n  map<ll, int> c_inv;\n  REP(i, 0, coord.size()) c_inv[coord[i]] = i;\n  VI hc(n);\n  REP(i, 0, n) hc[i] = c_inv[h[i]];\n  dp[0][0] = 1;\n  REP(i, 0, n) {\n    // collapse\n    if (h[i] == 1) {\n      ModInt<> tot;\n      REP(j, 0, N) {\n\ttot = tot + dp[i][j];\n      }\n      tot = tot * 2;\n      dp[i + 1][0] = tot;\n      continue;\n    }\n    // don't care\n    if (i == 0 || h[i - 1] == 1) {\n      int len = hc[i];\n      ModInt<> fac = dp[i][0];\n      REP(j, 0, len + 1) {\n\tdp[i + 1][j] = dp[i + 1][j] + ModInt<>(2).pow(coord[j] == 0 ? h[i] : h[i] - coord[j] + 1);\n\tif (j < len) {\n\t  dp[i + 1][j] = dp[i + 1][j] - ModInt<>(2).pow(coord[j + 1] == 0 ? h[i] : h[i] - coord[j + 1] + 1);\n\t}\n\tdp[i + 1][j] = dp[i + 1][j] * fac;\n      }\n      continue;\n    }\n    int u = hc[i - 1];\n    int v = hc[i];\n    int m = min(u, v);\n    ModInt<> fac = ModInt<>(2).pow(v >= u ? coord[v] - coord[u] : 0);\n    assert (u >= 1);\n    assert (v >= 1);\n    if (DEBUG) {\n      DEBUGP(u);\n      DEBUGP(v);\n      DEBUGP(m);\n      DEBUGP(fac);\n    }\n    REP(j, 0, m) {\n      dp[i + 1][j] = dp[i + 1][j] + dp[i][j] * fac;\n    }\n    if (u >= v) {\n      REP(j, v, u + 1) {\n\tdp[i + 1][v] = dp[i + 1][v] + dp[i][j] * 2;\n      }\n    } else {\n      REP(j, u, v + 1) {\n\tModInt<> tmp = ModInt<>(2).pow(h[i] - coord[j]);\n\tif (j < v) {\n\t  tmp = tmp - ModInt<>(2).pow(h[i] - coord[j + 1]);\n\t}\n\tdp[i + 1][j] = dp[i + 1][j] + tmp * dp[i][u] * 2;\n      }\n    }\n  }\n  if (DEBUG) {\n    cerr << \"dp:\" << endl;\n    REP(i, 0, n + 1) {\n      REP(j, 0, n + 1) {\n\tcerr << \" \" << dp[i][j];\n      }\n      cerr << endl;\n    }\n  }\n  ModInt<> tot;\n  REP(i, 0, N) tot = tot + dp[n][i];\n  cout << tot << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define N 100005\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> Pair;\n\ntemplate <class T> inline void read(T &x) {\n\tchar ch; bool flag = false;\n\twhile (!isdigit(ch = getchar())) flag |= ch == '-';\n\tfor (x = ch ^ 48; isdigit(ch = getchar()); x = x * 10 + (ch ^ 48));\n\tif (flag) x = -x;\n}\n\ninline int input() {\n\tint x; char ch; bool flag = false;\n\twhile (!isdigit(ch = getchar())) flag |= ch == '-';\n\tfor (x = ch ^ 48; isdigit(ch = getchar()); x = x * 10 + (ch ^ 48));\n\treturn flag ? -x : x;\n}\n\nconst int mod = 1e9 + 7;\ninline int add(int x, int y) { x += y; return x >= mod ? x - mod : x; }\ninline void inc(int &x, int y) { x += y; x -= x >= mod ? mod : 0; }\n\ninline int Power(int x, int y) {\n\tint res = 1;\n\twhile (y) {\n\t\tif (y & 1) res = (ll) res * x % mod;\n\t\tx = (ll) x * x % mod, y >>= 1;\n\t} return res;\n}\n\ntemplate <class T> void chkmax(T &x, T y) { x = x > y ? x : y; }\ntemplate <class T> void chkmin(T &x, T y) { x = x < y ? x : y; }\ntemplate <class T> T gcd(T x, T y) { return !y ? x : gcd(x % y, y); }\n\nint n;\nint h[N];\n\nPair solve(int l, int r, int lim) {\n\tbool flag = false; int upp = h[l]; Pair res;\n\tfor (int i = l + 1; i <= r; ++i) {\n\t\tflag |= h[i] != h[i - 1];\n\t\tchkmin(upp, h[i]);\n\t}\n\tif (!flag) {\n\t\tres.fi = add(Power(2, r - l + 1), mod - 2);\n\t\tres.se = Power(2, upp - lim - 1);\n\t\treturn res;\n\t}\n\t\n\tint cnt = 0, last = 0, s0 = 1, s1 = 1;\n\tfor (int i = l; i <= r + 1; ++i) {\n\t\tif (h[i] == upp) ++cnt;\n\t\tif (!last && h[i] > upp) last = i;\n\t\telse if (last && (h[i] == upp || i > r)) {\n\t\t\tPair tmp = solve(last, i - 1, upp);\n\t\t\ts0 = (ll) s0 * (tmp.fi + 4ll * tmp.se % mod) % mod;\n\t\t\ts1 = (ll) s1 * tmp.se * 2 % mod;\n\t\t\tlast = 0;\n\t\t}\n\t}\n\t\n\tinc(s0, mod - s1);\n\tres.fi = (ll) s0 * Power(2, cnt) % mod;\n\tinc(res.fi, (ll) s1 * add(Power(2, cnt), mod - 2) % mod);\n\tres.se = (ll) s1 * Power(2, upp - lim - 1) % mod;\n\treturn res;\n}\n\nint main() {\n\tn = input();\n\tfor (int i = 1; i <= n; ++i) h[i] = input();\n\tll Ex = 1;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (h[i] <= h[i - 1] || h[i] <= h[i + 1]) continue;\n\t\tEx = Ex * Power(2, h[i] - max(h[i - 1], h[i + 1])) % mod;\n\t\th[i] = max(h[i - 1], h[i + 1]);\n\t}\n\tPair ans = solve(1, n, 0);\n\tprintf(\"%lld\\n\", Ex * add(ans.fi, add(ans.se, ans.se)) % mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) (x = max(x,y))\n#define mins(x,y) (x = min(x,y))\n#define limit(x,l,r) max(l,min(x,r))\n#define lims(x,l,r) (x = max(l,min(x,r)))\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcountll\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,v(T),greater<T> >\n#define bn(x) ((1<<x)-1)\n#define dup(x,y) (((x)+(y)-1)/(y))\n#define newline puts(\"\")\n#define v(T) vector<T>\n#define vv(T) v(v(T))\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ntemplate<typename T>inline istream& operator>>(istream&i,v(T)&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(const v(T)&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>inline ostream& operator<<(ostream&o,const v(T)&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>inline istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>inline ostream& operator<<(ostream&o,const pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\ntemplate<typename T>inline ll suma(const v(T)& a) { ll res(0); for (auto&& x : a) res += x; return res;}\nconst double eps = 1e-10;\nconst ll LINF = 1e18;\nconst int INF = 1001001001;\n#define dame { puts(\"-1\"); return 0;}\n#define yn {puts(\"YES\");}else{puts(\"NO\");}\nconst int MX = 200005;\n\n// Mod int\nconst int mod = 1000000007;\nstruct mint {\n  ll x;\n  mint():x(0){}\n  mint(ll x):x((x%mod+mod)%mod){}\n  // mint(ll x):x(x){}\n  mint& fix() { x = (x%mod+mod)%mod; return *this;}\n  mint& operator+=(const mint& a){ if((x+=a.x)>=mod) x-=mod; return *this;}\n  mint& operator-=(const mint& a){ if((x+=mod-a.x)>=mod) x-=mod; return *this;}\n  mint& operator*=(const mint& a){ (x*=a.x)%=mod; return *this;}\n  mint& operator/=(const mint& a){ (x*=a.ex(mod-2).x)%=mod; return *this;}\n  mint operator+(const mint& a)const{ return mint(*this) += a;}\n  mint operator-(const mint& a)const{ return mint(*this) -= a;}\n  mint operator*(const mint& a)const{ return mint(*this) *= a;}\n  mint operator/(const mint& a)const{ return mint(*this) /= a;}\n  mint ex(ll t) const {\n    if(!t) return 1;\n    mint res = ex(t/2);\n    res *= res;\n    return (t&1)?res*x:res;\n  }\n  bool operator<(const mint& a)const{ return x < a.x;}\n  bool operator==(const mint& a)const{ return x == a.x;}\n};\nmint ex(mint x, ll t) { return x.ex(t);}\nistream& operator>>(istream&i,mint&a){i>>a.x;return i;}\nostream& operator<<(ostream&o,const mint&a){o<<a.x;return o;}\ntypedef vector<mint> vm;\nstruct comb {\n  vm f, g;\n  comb(){}\n  comb(int mx):f(mx+1),g(mx+1) {\n    f[0] = 1;\n    rrep(i,mx) f[i] = f[i-1]*i;\n    g[mx] = f[mx].ex(mod-2);\n    for(int i=mx;i>0;i--) g[i-1] = g[i]*i;\n  }\n  mint c(int a, int b) {\n    if (a < b) return 0;\n    return f[a]*g[b]*g[a-b];\n  }\n};\n//\n\nvi conv(vi a) {\n  vi res;\n  rep(i,sz(a)-1) {\n    res.pb(min(a[i],a[i+1])-1);\n  }\n  return res;\n}\ntypedef pair<mint,mint> MP;\nMP dfs(vi a) {\n  int n = sz(a);\n  int l = INF;\n  rep(i,n) mins(l,a[i]);\n  rep(i,n) a[i] -= l;\n  MP res(1,1);\n  vi x;\n  auto f = [&]() {\n    if (!sz(x)) return;\n    MP d = dfs(x);\n    res.fi *= d.fi;\n    res.se *= d.se;\n    x = vi();\n  };\n  rep(i,n) {\n    if (a[i]) {\n      x.pb(a[i]);\n    } else {\n      res.se *= 2;\n      f();\n    }\n  }\n  f();\n  // cerr<<l<<\": \"<<a<<endl;\n  // cerr<<res<<endl;\n  res.se += res.fi*(ex(2,l)-1);\n  res.fi *= ex(2,l);\n  // cerr<<res<<endl;\n  return res;\n}\nmint solve(vi a) {\n  int n = sz(a);\n  if (!n) return 1;\n  a = conv(a);\n  return dfs(a).se*2;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\",&n);\n  vi a(n);\n  cin>>a;\n  mint ans = 1;\n  rep(i,n) {\n    int x = 1;\n    if (i) maxs(x,a[i-1]);\n    if (i+1 < n) maxs(x,a[i+1]);\n    if (a[i] > x) {\n      ans *= ex(2,a[i]-x);\n      a[i] = x;\n    }\n  }\n\n  vi x;\n  rep(i,n) {\n    if (a[i] == 1) {\n      ans *= 2;\n      a[i] = 0;\n      ans *= solve(x);\n      x = vi();\n    } else x.pb(a[i]);\n  }\n  ans *= solve(x);\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nPROG: agc26d\nLANG: C++11\n    _____\n  .'     '.\n /  0   0  \\\n|     ^     |\n|  \\     /  |\n \\  '---'  /\n  '._____.'\n */\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate<class T>\nvoid readi(T &x)\n{\n\tT input = 0;\n\tbool negative = false;\n\tchar c = ' ';\n\twhile (c < '-')\n\t{\n\t\tc = getchar();\n\t}\n\tif (c == '-')\n\t{\n\t\tnegative = true;\n\t\tc = getchar();\n\t}\n\twhile (c >= '0')\n\t{\n\t\tinput = input * 10 + (c - '0');\n\t\tc = getchar();\n\t}\n\tif (negative)\n\t{\n\t\tinput = -input;\n\t}\n\tx = input;\n}\ntemplate<class T>\nvoid printi(T output)\n{\n\tif (output == 0)\n\t{\n\t\tputchar('0');\n\t\treturn;\n\t}\n\tif (output < 0)\n\t{\n\t\tputchar('-');\n\t\toutput = -output;\n\t}\n\tint aout[20];\n\tint ilen = 0;\n\twhile(output)\n\t{\n\t\taout[ilen] = ((output % 10));\n\t\toutput /= 10;\n\t\tilen++;\n\t}\n\tfor (int i = ilen - 1; i >= 0; i--)\n\t{\n\t\tputchar(aout[i] + '0');\n\t}\n\treturn;\n}\ntemplate<class T>\nvoid ckmin(T &a, T b)\n{\n\ta = min(a, b);\n}\ntemplate<class T>\nvoid ckmax(T &a, T b)\n{\n\ta = max(a, b);\n}\nlong long randomize(long long mod)\n{\n\treturn ((1ll << 30) * rand() + (1ll << 15) * rand() + rand()) % mod;\n}\n\n#define MP make_pair\n#define PB push_back\n#define PF push_front\n#define fi first\n#define se second\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\nconst long double PI = 4.0 * atan(1.0);\nconst long double EPS = 1e-10;\n\n#define MAGIC 347\n#define SINF 10007\n#define CO 1000007\n#define INF 1000000007\n#define BIG 1000000931\n#define LARGE 1696969696967ll\n#define GIANT 2564008813937411ll\n#define LLINF 2696969696969696969ll\n#define MAXN 113\n\nlong long normalize(long long x, long long mod = INF)\n{\n\treturn (((x % mod) + mod) % mod);\n}\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nint N;\nint arr[MAXN];\nint up[MAXN][MAXN];\nbool vis[MAXN][MAXN][MAXN][2];\nll dp[MAXN][MAXN][MAXN][2];\nll ans;\n\nll getpow(ll a, ll e)\n{\n\tif (e == 0)\n\t{\n\t\treturn 1;\n\t}\n\tll was = getpow(a, e / 2);\n\tif (e % 2)\n\t{\n\t\treturn (was * was % INF * a % INF);\n\t}\n\telse\n\t{\n\t\treturn (was * was % INF);\n\t}\n}\nll solve(int L, int R, int idx, bool flag)\n{\n\t//dp[L][R] given that we're at height arr[idx]\n\tif (L < 0 || R < 0 || L > R)\n\t{\n\t\treturn 1;\n\t}\n\tif (vis[L][R][idx][flag])\n\t{\n\t\treturn dp[L][R][idx][flag];\n\t}\n\tvis[L][R][idx][flag] = true;\n\tll res = 0;\n\t//0 means no, 1 means yes\n\tint d = arr[up[L][R]] - arr[idx];\n\tif (flag)\n\t{\n\t\t//must alternate\n\t\tres += solve(L, up[L][R] - 1, up[L][R], 1) * solve(up[L][R] + 1, R, up[L][R], 1) % INF * getpow(2, d) % INF;\n\t}\n\t//MUST ALTERNATE!\n\telse\n\t{\n\t\t//must alternate\n\t\tres += solve(L, up[L][R] - 1, up[L][R], 1) * solve(up[L][R] + 1, R, up[L][R], 1) % INF * (getpow(2, d + 1) - 2) % INF;\n\t\t//mustnt alternate\n\t\tres += solve(L, up[L][R] - 1, up[L][R], 0) * solve(up[L][R] + 1, R, up[L][R], 0) * 2 % INF;\n\t}\n\tres %= INF;\n\tdp[L][R][idx][flag] = res;\n//\tcerr << \"solve \" << L << \" \" << R << \" height \" << arr[idx] << \" flag \" << flag << \" ans \"<< res << endl;\n\treturn res;\n}\n\nint32_t main()\n{\n\tios_base::sync_with_stdio(0); \n\tsrand(time(0));\n\t//\tcout << fixed << setprecision(10);\t\n\t//\tcerr << fixed << setprecision(10);\n\tif (fopen(\"agc26d.in\", \"r\"))\n\t{\t\n\t\tfreopen (\"agc26d.in\", \"r\", stdin);\n\t\t//\tfreopen (\"agc26d.out\", \"w\", stdout);\n\t}\n\tcin >> N;\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tcin >> arr[i];\n\t\tarr[i]--;\n\t}\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tint mn = INF, idx = -1;\n\t\tfor (int j = i; j < N; j++)\n\t\t{\n\t\t\tif (arr[j] < mn)\n\t\t\t{\n\t\t\t\tmn = arr[j]; idx = j;\n\t\t\t}\n\t\t\tup[i][j] = idx;\n\t\t\t//\t\t\tcerr << up[i][j] << ' ';\n\t\t}\n\t\t//\t\tcerr << endl;\n\t}\n\tarr[N] = 0;\n\tans = solve(0, N - 1, N, 0);\n\tcout << ans << '\\n';\n\t//\tcerr << \"time elapsed = \" << (clock() / (CLOCKS_PER_SEC / 1000)) << \" ms\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int Maxn=105,mod=1e9+7;\nint h[Maxn];\nint ksm(int x,int k){\n\tint ret=1,tmp=x;\n\twhile(k){\n\t\tif(k&1)ret=1ll*ret*tmp%mod;\n\t\ttmp=1ll*tmp*tmp%mod;k>>=1;\n\t}\n\treturn ret;\n}\npair<int,int>solve(int l,int r,int lim){\n\tint Min=*min_element(h+l,h+r+1);\n\tint cnt=count(h+l,h+r+1,Min);\n\tpair<int,int>ans=make_pair(1,1);\n\tif(cnt==r-l+1){\n\t\tans.first=ksm(2,Min-lim);\n\t\tans.second=(ans.first+ksm(2,cnt)-2)%mod;\n\t\treturn ans;\n\t}\n\tvector<pair<int,int>>vec;\n\tfor(int i=l;i<=r;i++){\n\t\tif(h[i]==Min)continue;\n\t\tint L=i;\n\t\twhile(i<=r&&h[i]>Min)i++;\n\t\tvec.emplace_back(solve(L,i-1,Min));\n\t}\n\tint f=1,g=1;\n\tfor(auto&i:vec){\n\t\tf=1ll*f*i.first%mod;\n\t\tg=1ll*g*(i.first+i.second)%mod;\n\t}\n\tans.second=(1ll*(g-1ll*ksm(2,vec.size())*f)%mod*ksm(2,cnt)+1ll*f*(ksm(2,vec.size()+cnt)-2))%mod;\n\tans.first=1ll*f*ksm(2,Min-lim)%mod;\n\tans.second=(ans.second+ans.first)%mod;\n\treturn ans;\n}\nint main(){\n\tint n;scanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&h[i]);\n\tcout<<(solve(1,n,0).second+mod)%mod<<\"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAX_N = 123;\nconst ll MOD = 1e9 + 7;\n\nll sq(ll x) { return x * x % MOD; }\nll qpow(ll a, ll b) { return b ? sq(qpow(a, b / 2)) * (b & 1 ? a : 1) % MOD : 1; }\nll inv(ll x) { return qpow(x, MOD - 2); }\n\nint N, H[MAX_N];\nll F[MAX_N];\n\nint main() {\n    scanf(\"%d\", &N);\n    for (int i = 1; i <= N; i++) scanf(\"%d\", &H[i]);\n    H[0] = H[N + 1] = 1;\n    F[0] = 2;\n    for (int i = 1; i <= N; i++) {\n        ll sum = 0; int prev = H[i + 1];\n        for (int j = i; j; j--) {\n            int l = max(H[j - 1], prev), r = H[j];\n            if (r > l) {\n                sum += r - l;\n            }\n            prev = min(prev, H[j]);\n            (F[i] += F[j - 1] * qpow(2, sum)) %= MOD;\n        }\n    }\n    printf(\"%lld\\n\", F[N]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cmath>\n#include<cstdlib>\n#define LL long long\n#define LD long double\nusing namespace std;\nconst int NN=100 +117;\nconst int MM=100 +117;\nint read(){\n\tint fl=1,x;char c;\n\tfor(c=getchar();(c<'0'||c>'9')&&c!='-';c=getchar());\n\tif(c=='-'){fl=-1;c=getchar();}\n\tfor(x=0;c>='0'&&c<='9';c=getchar())\n\t\tx=(x<<3)+(x<<1)+c-'0';\n\treturn x*fl;\n}\nvoid open(){\n\tfreopen(\"a.in\",\"r\",stdin);\n\t//freopen(\"a.out\",\"w\",stdout);\n}\nvoid close(){\n\tfclose(stdin);\n\tfclose(stdout);\n}\n\n\nint m,n;\nLL a[NN]={};\nLL dp[NN][NN]={};\nbool conti[NN]={};\nint li[NN]={};\nconst int mod=1e9+7;\nLL ksm(LL a,LL b){\n\tLL ret=1;\n\tfor(;b;b>>=1,a=a*a%mod)\n\t\tif(b&1)ret=ret*a%mod;\n\treturn ret;\n}\nint main(){\n\t//open();\n\tn=read();\n\tLL ans=1;\n\tfor(int i=1;i<=n;++i){\n\t\ta[i]=read();\n\t\tif(a[i]==1){\n\t\t\tans=ans*2%mod;\n\t\t\ta[i]=0;\n\t\t}\n\t}\n\tint lcnt=0;\n\tfor(int i=1;i<=n;++i){\n\t\tint nb=max(a[i-1],a[i+1]);\n\t\tif(a[i]>nb){\n\t\t\tans=ans*ksm(2,a[i]-nb)%mod;\n\t\t\ta[i]=nb;\n\t\t}\n\t\tif(a[i])li[++lcnt]=a[i];\n\t}\n\tsort(li+1,li+1+lcnt);\n\tlcnt=unique(li+1,li+1+lcnt)-li-1;\n\tfor(int i=1;i<=n+1;++i){\n\t\tif(!a[i]){\n\t\t\tconti[i]=0;\n\t\t\tif(conti[i-1]==1){\n\t\t\t\tans=ans*dp[i-1][0]%mod;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tint h=lower_bound(li+1,li+1+lcnt,a[i])-li;\n\t\t\tif(conti[i-1]){\n\t\t\t\tint pre=lower_bound(li+1,li+1+lcnt,a[i-1])-li;\n\t\t\t\tif(pre<=h){\n\t\t\t\t\tfor(int j=0;j<=pre;++j){\n\t\t\t\t\t\tdp[i][j]=(dp[i-1][j]+dp[i-1][pre])*ksm(2,a[i]-a[i-1])%mod;\n\t\t\t\t\t}\n\t\t\t\t\tfor(int j=pre+1;j<=h;++j){\n\t\t\t\t\t\tdp[i][j]=(dp[i-1][pre]+dp[i-1][pre])*ksm(2,a[i]-li[j])%mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tfor(int j=0;j<=h;++j){\n\t\t\t\t\t\tdp[i][j]=(dp[i-1][j]+dp[i-1][h])%mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdp[i][0]=ksm(2,a[i]);\n\t\t\t\tfor(int j=1;j<=h;++j){\n\t\t\t\t\tdp[i][j]=2*ksm(2,a[i]-li[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tconti[i]=1;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\tclose();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nconst int mod = 1e9 + 7;\nint n;\nint a[200];\nint mypow(int x, int n) {\n    if (n == 0) return 1;\n    int g = mypow(x, n / 2);\n    g = 1ll * g * g % mod;\n    if (n & 1) g = 1ll * g * x % mod;\n    return g;\n}\nint f[200][200];\nint good[5][5];\nint b[200];\nint ll[200], rr[200];\nlong long geomprog(int b, int k) {\n    if (k <= 0) return 1;\n    return mypow(b, k + 1) - 1;\n}\nint solve(int l, int r) {\n    for (int j = l; j <= r; j++) b[j] = a[j];\n    sort(b + l, b + r + 1);\n    int c = 1, k = 0;\n    for (int i = l; i <= r; i++) {\n        if (b[i] != b[i - 1]) {\n            k++;\n            ll[k] = c;\n            rr[k] = b[i] - 1;\n            c = b[i];\n        }\n    }\n    f[l][0] = 2;\n    for (int j = 1; j <= k; j++)\n        if (rr[j] < a[l]) f[l][j] = (geomprog(2, a[l] - ll[j]) - geomprog(2, a[l] - rr[j] - 1) + mod) % mod;\n    for (int i = l; i < r; i++)\n    for (int j = 0; j <= k; j++)\n        if (f[i][j] != 0) {\n            if (j == 0) {\n                if (a[i] >= a[i + 1]) {\n                    f[i + 1][0] += 2ll * f[i][j] % mod;\n                    if (f[i + 1][0] >= mod) f[i + 1][0] -= mod;\n                }\n                else {\n                    f[i + 1][0] += 2ll * f[i][j] % mod;\n                    if (f[i + 1][0] >= mod) f[i + 1][0] -= mod;\n                    for (int t = 1; t <= k; t++)\n                        if (ll[t] >= a[i] && rr[t] < a[i + 1]) {\n                            int c = (geomprog(2, a[i + 1] - ll[t]) - geomprog(2, a[i + 1] - rr[t] - 1) + mod) % mod;\n                            f[i + 1][t] += 1ll * c * f[i][j] % mod;\n                            if (f[i + 1][t] >= mod) f[i + 1][t] -= mod;\n                        }\n                }\n            }\n            else {\n                if (rr[j] < a[i + 1]) {\n                    int c = 1;\n                    if (a[i + 1] > a[i]) c = mypow(2, a[i + 1] - a[i]);\n                    f[i + 1][j] += 1ll * f[i][j] * c % mod;\n                    if (f[i + 1][j] >= mod) f[i + 1][j] -= mod;\n                }\n                else {\n                    f[i + 1][0] += 2ll * f[i][j] % mod;\n                    if (f[i + 1][0] >= mod) f[i + 1][0] -= mod;\n                }\n            }\n        }\n    int s = 0;\n    for (int j = 0; j <= k; j++) {\n        s += f[r][j];\n        if (s >= mod) s -= mod;\n    }\n    return s;\n}\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin >> n;\n    good[0][3] = good[3][0] = 1;\n    good[1][2] = good[2][1] = 1;\n    good[1][1] = good[2][2] = 1;\n    for (int i = 1; i <= n; i++) cin >> a[i];\n    long long c = 1; int prv = 0;\n    a[n + 1] = 1;\n    for (int i = 1; i <= n + 1; i++) {\n        if (a[i] == 1) {\n            if (i != n + 1) c = c * 2 % mod;\n            if (prv + 1 <= i - 1) c = c * solve(prv + 1, i - 1) % mod;\n            prv = i;\n        }\n    }\n    cout << c << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <sstream>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <cstdlib>\n#include <cstdio>\n#include <iterator>\n#include <functional>\n#include <bitset>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\nclock_t __my_start_clock = clock();\n#else\n#define eprintf(...)\n#endif\n\n#define TIMESTAMP(x) eprintf(\"[\"#x\"] Time : %.3lf s.\\n\", (clock() - __my_start_clock)*1.0/CLOCKS_PER_SEC)\n#define TIMESTAMPf(x,...) eprintf(\"[\" x \"] Time : %.3lf s.\\n\", __VA_ARGS__, (clock() - __my_start_clock)*1.0/CLOCKS_PER_SEC)\n\nusing namespace std;\n\n#ifdef LOCAL\nstatic struct __timestamper {\n  string what;\n  __timestamper(const char* what) : what(what){};\n  __timestamper(const string& what) : what(what){};\n  ~__timestamper(){\n    TIMESTAMPf(\"%s\", what.data());\n\t}\n} __TIMESTAMPER(\"end\");\n#else \nstruct __timestamper {};\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst int MOD = 1000000007;\n\nvoid add(int &a, int b) {\n  if ((a += b) >= MOD) a -= MOD;\n}\n\nvoid sub(int &a, int b) {\n  if ((a -= b) < 0) a += MOD;\n}\n\nint mul(int a, int b) {\n  return (int) ((a * 1LL * b) % MOD);\n}\n\nint mpow(int a, int b) {\n  int res = 1;\n  while (b) {\n    if (b & 1) res = mul(res, a);\n    a = mul(a, a);\n    b >>= 1;\n  }\n  return res;\n}\n\nint minv(int x) {\n  return mpow(x, MOD - 2);\n}\n\n// (altering lowest row, non-altering)\npair<int, int> solve(vector<int> v) {\n  if (v.size() == 0) {\n    return {1, 0};\n  }\n  if (v.size() == 1) {\n    return {mpow(2, v[0]), 0};\n  }\n  int m = *min_element(v.begin(), v.end());\n\n  int res1 = 1;\n  int res2 = 1;\n  vector<int> st;\n  for (int i = 0; i <= (int)v.size(); i++) {\n    if (i != (int)v.size() && v[i] > m) {\n      st.push_back(v[i] - m + 1);\n    } else {\n      auto r = solve(st);\n      res1 = mul(res1, mul(r.first, minv(st.empty() ? 1 : 2)));\n      res2 = mul(res2, r.first + r.second);\n      if (i != (int)v.size()) {\n        res2 = mul(res2, 2);\n      }\n      st.clear();\n    }\n  }\n\n  sub(res2, mul(res1, 2));\n  res1 = mul(res1, mpow(2, m));\n\n  return {res1, res2};\n}\n\nint main() {\n#ifdef LOCAL\n  freopen(\"d.in\", \"r\", stdin);\n  freopen(\"d.out\", \"w\", stdout);\n#endif\n\n  int n;\n  while (scanf(\"%d\", &n) == 1) {\n    vector<int> v(n);\n    for (int &x : v) {\n      scanf(\"%d\", &x);\n    }\n    auto res = solve(v);\n    printf(\"%d\\n\", (res.first + res.second) % MOD);\n//    break;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#define maxn 105\n#define R register\n#define INF 0x3f3f3f3f\nusing namespace std;\ntypedef long long lxl;\nconst lxl mod = 1e9+7;\n\ninline lxl read()\n{\n\tlxl x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9') {if(ch=='-') f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9') {x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\ninline lxl fmi(lxl a,lxl b)\n{\n\tlxl ans=1;\n\twhile(b>0)\n\t{\n\t\tif(b&1) ans=(ans*a)%mod;\n\t\ta=(a*a)%mod;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\n\nlxl n,h[maxn],H[maxn],W[maxn],X[maxn],Rm[maxn],tot;\nint d[maxn][20],lg[maxn];\nstd::vector<int> ch[maxn];\n\ninline void init()\n{\n\tlg[0]=-1;\n\tfor(R int i=1;i<=n;++i)\n\t\tlg[i]=lg[i>>1]+1;\n\tfor(R int i=1;i<=n;++i)\n\t\td[i][0]=h[i];\n\tfor(R int j=1;j<=15;++j)\n\t\tfor(R int i=1;i+(1<<(j-1))<=n;++i)\n\t\t\td[i][j]=min(d[i][j-1],d[i+(1<<(j-1))][j-1]);\n}\n\ninline int query(int l,int r)\n{\n\tint k=lg[r-l+1];\n\treturn min(d[l][k],d[r-(1<<k)+1][k]);\n}\n\ninline int build(int l,int r,int fa)\n{\n\tif(l>r) return 0;\n\tint p=++tot;\n\tint x=X[p]=query(l,r);\n\tH[p]=X[p]-X[fa];\n\tW[p]=r-l+1;\n\tint tl=l-1,tr=l-1;\n\tfor(R int i=l;i<=r;++i)\n\t{\n\t\tif(h[i]==x&&tl<tr)\n\t\t\tch[p].push_back(build(tl+1,tr,p));\n\t\tif(h[i]==x) tl=i,++Rm[p];\n\t\telse tr=i;\n\t}\n\tif(tl<tr) ch[p].push_back(build(tl+1,tr,p));\n\treturn p;\n}\n\nlxl f[maxn][2];\n\ninline void dp(int u)\n{\n\tlxl res1=1,res2=1;\n\tfor (std::vector<int>::iterator it = ch[u].begin(); it != ch[u].end(); ++it)\n\t{\n\t\tdp(*it);\n\t\tres1=(res1*f[*it][0])%mod;\n\t\tres2=(res2*((f[*it][0]*2%mod+f[*it][1])%mod))%mod;\n\t}\n\tf[u][0]=(fmi(2,H[u])*res1)%mod;\n\tf[u][1]=(fmi(2,Rm[u])*res2+(mod-2*res1%mod)%mod)%mod;\n}\n\nint main()\n{\n\tn=read();\n\tfor(R int i=1;i<=n;++i)\n\t\th[i]=read();\n\tinit();\n\tint rt=build(1,n,0);\n\tdp(rt);\n\tprintf(\"%lld\",(f[rt][1]+f[rt][0])%mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int mod=1000000007;\nint h[111];\nint n;\nint fpow2(int y)\n{\n\tif(y==0)\n\t\treturn 1;\n\tint ret=fpow2(y>>1);\n\tret=(long long)ret*ret%mod;\n\tif(y&1)\n\t\t(ret<<=1)%=mod;\n\treturn ret;\n}\npair<int,int> solve(int l,int r,int nh)\n{\n\tint mi=1010101010,cnt=0;\n\tfor(int i=l;i<=r;i++)\n\t\tmi=min(mi,h[i]);\n\tfor(int i=l;i<=r;i++)\n\t\tcnt+=(mi==h[i]);\n\tint h1=1,h2=1,st=0;\n\tpair<int,int> dp;\n\tfor(int i=l;i<=r+1;i++)\n\t\tif(h[i]>mi)\n\t\t{\n\t\t\tif(st==0)\n\t\t\t\tst=i;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(st)\n\t\t\t{\n\t\t\t\tdp=solve(st,i-1,mi);\n\t\t\t\th1=(long long)dp.first*h1%mod;\n\t\t\t\th2=((long long)dp.first*2+dp.second)*h2%mod;\n\t\t\t\tst=0;\n\t\t\t}\n\t\t}\n\treturn make_pair((long long)h1*fpow2(mi-nh)%mod,((long long)h2*fpow2(cnt)+mod+mod-h1-h1)%mod);\n}\nint main()\n{\n\tpair<int,int> dp;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&h[i]);\n\tdp=solve(1,n,0);\n\tprintf(\"%d\",(dp.first+dp.second)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=105,p=1000000007;\nint read(){\n\tint f=1,g=0;\n\tchar ch=getchar();\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-') f=-1;\n\tfor (;isdigit(ch);ch=getchar()) g=g*10+ch-'0';\n\treturn f*g;\n}\nint qpow(int x,int k){\n\tint t=1;\n\tfor (;k;k>>=1){\n\t\tif (k&1) t=(ll)t*x%p;\n\t\tx=(ll)x*x%p;\n\t}\n\treturn t;\n}\nint n,m,K,a[N];\nvoid check(int &x,int y){if ((x+=y)>=p) x-=p;}\ntypedef pair<int,int> pr;\npr work(int dep,int l,int r){\n\tint d=0x3f3f3f3f,las=l;\n\tpr ans=make_pair(2,1);\n\tfor (int i=l;i<=r;i++) d=min(d,a[i]);\n\tfor (int i=l;i<=r;i++)\n\tif (a[i]==d) {\n\t\tcheck(ans.second,ans.second);\n\t\tif (las<i){\n\t\t\tpr t=work(d+1,las,i-1);\n\t\t\tans.first=(ll)ans.first*t.first%p;\n\t\t\tans.second=(ll)ans.second*(t.second+t.first)%p;\n\t\t}\n\t\tlas=i+1;\n\t}\n\tif (las<=r){\n\t\tpr t=work(d+1,las,r);\n\t\tans.first=(ll)ans.first*t.first%p;\n\t\tans.second=(ll)ans.second*(t.second+t.first)%p;\n\t}\n\tcheck(ans.second,p-ans.first);\n\tans.first=(ll)ans.first*qpow(2,d-dep)%p;\n\tcheck(ans.second,ans.first);\n\treturn ans;\n}\nint main(){\n\tn=read();\n\tfor (int i=1;i<=n;i++) a[i]=read();\n\tprintf(\"%d\\n\",work(1,1,n).second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <algorithm>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <tuple>\n#include <typeinfo>\n#include <unordered_set>\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REPD(i, n) for(int i = (int)(n) - 1; i >= 0; i--)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(auto i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define BIT(n, m) (((n) >> (m)) & 1)\n\ntypedef long long ll;\n\ntemplate <typename S, typename T> ostream &operator<<(ostream &out, const pair<S, T> &p) {\n  out << \"(\" << p.first << \", \" << p.second << \")\";\n  return out;\n}\n\ntemplate <typename T> ostream &operator<<(ostream &out, const vector<T> &v) {\n  out << \"[\";\n  REP(i, v.size()){\n    if (i > 0) out << \", \";\n    out << v[i];\n  }\n  out << \"]\";\n  return out;\n}\n\nconst int MAX = 110;\nconst ll mod = 1000 * 1000 * 1000 + 7;\nint N;\nvector<ll> H;\nll memo1[MAX];\nll memo2[MAX][MAX];\nll memo3[MAX][MAX];\nll memo4[MAX][MAX];\n\nll modpow(ll n, ll p) {\n  ll res = 1;\n  while (p > 0) {\n    if (p & 1) {\n      res *= n;\n      res %= mod;\n    }\n    p >>= 1;\n    n = n * n % mod;\n  }\n  return res;\n}\n\npair<ll, ll> rec(int l, int r, int h) {\n  assert(r - l > 0);\n  if (r - l == 1) {\n    const ll c = modpow(2, H[l] - h);\n    return {c, c};\n  }\n\n  int min_h = *min_element(H.begin() + l, H.begin() + r);\n  assert(min_h > h);\n\n  vector<pair<int, int>> v;\n  int i = l;\n  while (i < r) {\n    int j = i;\n    while (j < r && (H[i] == min_h) == (H[j] == min_h)) j++;\n    v.push_back({i, j});\n    i = j;\n  }\n  \n  int w = count(H.begin() + l, H.begin() + r, min_h);\n  int x = min_h;\n\n  ll prod1 = 1;\n  ll prod2 = 1;\n  for (auto& p : v) {\n    int x = p.first, y = p.second;\n    if (H[x] != min_h) {\n      auto g = rec(x, y, min_h);\n      prod1 *= g.first;\n      prod1 %= mod;\n      prod2 *= g.second + g.first;\n      prod2 %= mod;\n    }\n  }\n  ll res1 = modpow(2, min_h - h) * prod1 % mod;\n  ll res2 = (modpow(2, w) * prod2 + (modpow(2, min_h - h) - 2) * prod1) % mod;\n  return {res1, res2 % mod};\n}\n\nint main(int argc, char *argv[])\n{\n  cin >> N;\n  H.resize(N);\n  REP(i, N) cin >> H[i];\n  cout << rec(0, N, 0).second << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 105, mod = 1e9+7, inv2 = (mod+1)/2, phi = mod-1;\n\nint n, a[MAXN], dp[MAXN][MAXN][2];\n\ninline int power(int a, int n)\n{\n\tint ans = 1;\n\tfor (; n; n >>= 1) {\n\t\tif (n&1) ans = (long long)ans*a%mod;\n\t\ta = (long long)a*a%mod;\n\t}\n\treturn ans;\n}\n\nvoid dfs(int L, int R)\n{\n\tint pos = L, tmp;\n\tfor (int i = L; i <= R; i++)\n\t\tif (a[i] < a[pos])\n\t\t\tpos = i;\n\ttmp = a[pos];\n        for (int i = L; i <= R; i++)\n\t\ta[i] -= tmp;\n\tint cnt_len = 0, cnt_cnt = 0;\n\tfor (int i = L; i <= R; i++)\n\t\tif (a[i] == 0)\n\t\t\tcnt_cnt++;\n\tif (cnt_cnt == R-L+1) {\n\t\tdp[L][R][0] = power(2, tmp);\n\t\tdp[L][R][1] = ((power(2, R-L+1)-2)%mod+mod)%mod;\n\t\t// cerr << L << \" \" << R << \" \" << dp[L][R][0] << \" \" << dp[L][R][1] << endl;\n\t\treturn;\n\t}\n\tint cnt_sub = 0;\n\tdp[L][R][0] = dp[L][R][1] = 1;\n\tfor (int i = L; i <= R; ) {\n\t\tif (a[i] == 0) {\n\t\t\tint j = i;\n\t\t\twhile (j+1 <= R && a[j+1] == 0) j++;\n\t\t\tcnt_len++;\n\t\t\ti = j+1;\n\t\t} else {\n\t\t\tint j = i;\n\t\t\twhile (j+1 <= R && a[j+1] != 0) j++;\n\t\t\tcnt_sub++;\n\t\t\tdfs(i, j);\n\t\t\tdp[L][R][0] = (long long)dp[L][R][0]*dp[i][j][0]%mod;\n\t\t\tdp[L][R][1] = (long long)dp[L][R][1]*((dp[i][j][0]*2ll+dp[i][j][1])%mod)%mod;\n\t\t}\n\t}\n\tdp[L][R][0] = (long long)dp[L][R][0]*2%mod;\n\tdp[L][R][1] = (long long)dp[L][R][1]*power(2, cnt_cnt)%mod;\n\tdp[L][R][1] = ((dp[L][R][1]-dp[L][R][0])%mod+mod)%mod;\n\tdp[L][R][0] = (long long)dp[L][R][0]*power(2, tmp-1)%mod;\n\t// cerr << L << \" \" << R << \" \" << dp[L][R][0] << \" \" << dp[L][R][1] << endl;\n}\n\nint main()\n{\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++) cin >> a[i];\n\tif (n == 1) {\n\t\tcout << power(2, a[1]) << endl;\n\t\treturn 0;\n\t}\n\ta[0] = a[n+1] = 0;\n\tint cnt = 0;\n\tfor (int i = 1; i <= n; i++)\n\t\tif (a[i] > a[i-1] && a[i] > a[i+1]) {\n\t\t\tint tar = max(a[i-1], a[i+1]);\n\t\t\tcnt = (cnt+a[i]-tar)%phi;\n\t\t\ta[i] = tar;\n\t\t}\n\tdfs(1, n);\n\tcout << (long long)(dp[1][n][0]+dp[1][n][1])%mod*power(2, cnt)%mod << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <fstream>\n#include <iostream>\n#include <algorithm>\n#include <bitset>\n#include <array>\n#include <vector>\n#include <queue>\n#include <set>\n#include <cmath> // 変数名にy1が使えなくなるかも…。\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <string>\n\ntypedef __int128_t int128_t;\nstd::istream &operator>>(std::istream& input, int128_t& value) { // int128_tの入力。入力が64bitに収まる前提。\n    long long tmp; input >> tmp; value = tmp;\n    return input;\n}\nstd::ostream &operator<<(std::ostream& output, const int128_t value) { // int128_tの出力。出力が64bitに収まる前提。\n    output << (long long)value;\n    return output;\n}\n\nint128_t cal_mod(const int128_t n, const int128_t mod) {\n    // n % modを計算する。ただしmod <= 0 ならば何もしない。nが負の場合、正にして補正する。\n    if (mod <= 0) {\n        return n;\n    } else if (0 <= n) {\n        return n % mod;\n    } else {\n        int128_t tmp = (-n) / mod + 1;\n        return (n + tmp * mod) % mod;\n    }\n}\n\nint128_t pow_mod(int128_t x, int128_t n, const int128_t mod) {\n    // 累乗の計算。mod <= 0ならば余りの計算は行わない。\n    int128_t ret = 1;\n    while (n > 0) {\n        if (n & 1) { ret = cal_mod(ret * x, mod); }\n        x = cal_mod(x * x, mod);\n        n = (n >> 1);\n    }\n    return ret;\n}\n\nconst int128_t MOD = 1e9 + 7;\nconst int MAX_H = 1e9 + 7;\nconst int MAX_N = 110;\nint N;\nint128_t h[MAX_N];\n\nint128_t s[MAX_N]; // s[i]:i番目に低い山（高さ2以上）の高さ。\nstd::map<int128_t, int> mp; // 2以上の高さに対して、何番目に低いか。\n\nint128_t dp[MAX_N][MAX_N] = {};\n// dp[i][j] : i番目の列まで塗終わり、その列で最初に現れる連続同色がs[j]の高さに収まる(s[j-1]には収まらない)塗り方の数。\n// dp[i][0] は、連続同色が現れない塗り方。\n\nint128_t calc_sub(int128_t h1, int128_t h2) {\n    // h1まで交互に塗った1つの塗り方に対して、h2までに連続塗りを含む塗り方がいくつあるか。\n    return cal_mod(pow_mod(2, h2 - h1, MOD) - 1, MOD);\n}\n\nint main(int argc, char **argv) {\n    std::cin >> N;\n    \n    for (int i = 1; i <= N; i++) {\n        std::cin >> h[i];\n    }\n\n    for (int i = 1; i <= N; i++) {\n        if (1 < h[i]) {\n            mp[h[i]] = 1;\n        }\n    }\n    int cnt = 1;\n    for (auto itr = mp.begin(); itr != mp.end(); ++itr) {\n        mp[itr->first] = cnt;\n        s[cnt] = itr->first;\n        cnt++;\n    }\n    s[0] = 1;\n    s[cnt] = MAX_H;\n    dp[0][0] = 1;\n\n    //std::cout << \"check:\" << s[0] << \" \" << s[1] << \" \" << s[2] << \" \" << s[3] << std::endl;\n\n    for (int i = 1; i <= N; i++) {\n        if (h[i] == 1) {\n            for (int j = 0; j < cnt; j++) {\n                dp[i][0] = (dp[i][0] + dp[i-1][j] * 2) % MOD;\n            }\n        } else if (i == 1 || h[i-1] == 1) {\n            dp[i][0] = (dp[i-1][0] * 2) % MOD;\n            for (int j = 1; s[j] <= h[i]; j++) {\n                dp[i][j] = (dp[i-1][0] * 2 * calc_sub(s[j-1], s[j]) * pow_mod(2, h[i] - s[j], MOD)) % MOD;\n            }\n        } else {\n            dp[i][0] = (dp[i-1][0] * 2) % MOD;\n            if (h[i] <= h[i-1]) {\n                for (int j = 1; s[j] <= h[i-1]; j++) {\n                    if (s[j] <= h[i]) {\n                        dp[i][j] = dp[i-1][j];\n                    } else {\n                        dp[i][0] = (dp[i][0] + dp[i-1][j] * 2) % MOD;\n                    }\n                }\n            } else {\n                for (int j = 1; s[j] <= h[i]; j++) {\n                    if (s[j] <= h[i-1]) {\n                        dp[i][j] = (dp[i-1][j] * pow_mod(2, h[i] - h[i-1], MOD)) % MOD;\n                    } else {\n                        dp[i][j] = (dp[i-1][0] * 2 * calc_sub(s[j-1], s[j]) * pow_mod(2, h[i] - s[j], MOD)) % MOD;\n                    }\n                }\n            }\n        }\n        //std::cout << \"dp:\" << dp[i][0] << \" \" << dp[i][1] << \" \" << dp[i][2] << std::endl;\n    }\n\n    int128_t ret = 0;\n    for (int j = 0; s[j] <= h[N]; j++) {\n        ret = (ret + dp[N][j]) % MOD;\n    }\n    std::cout << ret << std::endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n#define N 106\n#define mod 998244353\nint dp[N][N],n,s[N],st[N],v[N],v2[N],ct,as=1;\nint pw(int a,int p){int as=1;while(p){if(p&1)as=1ll*as*a%mod;a=1ll*a*a%mod;p>>=1;}return as;}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&s[i]),v[i]=s[i];\n\tsort(v+1,v+n+1);\n\tv[0]=1;for(int i=1;i<=n;i++)if(v[i]!=v[i-1])v2[++ct]=v[i];\n\tfor(int i=1;i<=n;i++)for(int j=1;j<=ct;j++)if(s[i]==v2[j])st[i]=j;\n\tdp[0][0]=1;\n\tfor(int i=1;i<=n;i++)\n\tif(s[i]==1)\n\t{\n\t\tint su=0;\n\t\tfor(int j=0;j<=ct+1;j++)su=(su+dp[i-1][j])%mod;\n\t\tas=2ll*as*su%mod;\n\t\tdp[i][0]=1;\n\t}\n\telse if(s[i-1]<=1)\n\t{\n\t\tfor(int j=1;j<=st[i];j++)\n\t\tdp[i][j]=pw(2,s[i]-v2[j-1]+(j>1));\n\t\tdp[i][st[i]+1]=2;\n\t\tfor(int j=1;j<=st[i];j++)dp[i][j]=(dp[i][j]-dp[i][j+1]+mod)%mod;\n\t}\n\telse if(s[i]<=s[i-1])\n\t{\n\t\tfor(int j=1;j<=st[i-1]+1;j++)\n\t\tif(j>st[i])dp[i][st[i]+1]=(dp[i][st[i]+1]+2ll*dp[i-1][j])%mod;\n\t\telse dp[i][j]=dp[i-1][j];\n\t}\n\telse\n\t{\n\t\tfor(int j=1;j<=st[i-1];j++)dp[i][j]=1ll*dp[i-1][j]*pw(2,s[i]-s[i-1])%mod;\n\t\tfor(int j=st[i-1]+1;j<=st[i];j++)dp[i][j]=2ll*dp[i-1][st[i-1]+1]*pw(2,s[i]-v2[j-1])%mod;\n\t\tdp[i][st[i]+1]=2ll*dp[i-1][st[i-1]+1]%mod;\n\t\tfor(int j=st[i-1]+1;j<=st[i];j++)dp[i][j]=(dp[i][j]-dp[i][j+1]+mod)%mod;\n\t}\n\tint su=0;\n\tfor(int j=0;j<=ct+1;j++)su=(su+dp[n][j])%mod;\n\tas=1ll*as*su%mod;\n\tprintf(\"%d\\n\",as);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define llu unsigned long long\n#define ld double\n#define llu unsigned long long\n#define rep(i,x,y)  for(ll i=x;i<y;++i)\n#define For(i,x,y)  for(ll i=x;i<=y;++i)\n#define FOr(i,x,y)  for(ll i=x;i>=y;--i)\n#define pi acos(-1)\n#define mk make_pair<ll,ll>\n#define pa pair<ll,ll>\n#define lf else if\n#define min(x,y)    ((x)<(y)?(x):(y))\n#define sqr(x)      ((x)*(x))\n#define abs(x)      ((x)>0?(x):-(x))\n#define Mul(x,y)    (x=(x)*(y)%mod)\n#define Mul1(x,y)   (x=(x)*(y)%mod1)\n#define Add(x,y)    (x=(x+(y))%mod)\n#define Add1(x,y)\t(x=(x+(y))%mod1)\n#define E(x)        return writeln(x),0\n#define p(x)        printf(\"~%d~\\n\",x)\n#define pp(x,y)     printf(\"~~%d %d~~\\n\",x,y)\n#define ppp(x,y,z)  printf(\"~~~%d %d %d~~~\\n\",x,y,z)\n#define pppp(x,y,z,a)  printf(\"~~~%d %d %d %d~~~\\n\",x,y,z,a)\n#define f_in(x)     freopen(x\".in\",\"r\",stdin)\n#define f_out(x)    freopen(x\".out\",\"w\",stdout)\n#define open(x)     f_in(x),f_out(x)\n#define fi first\n#define se second\ntypedef complex<double> E;\nnamespace SHENZHEBEI{\n#ifdef LOCAL\n    struct _{_(){freopen(\"cf.in\",\"r\",stdin);}}_;\n#endif\n#define NEG 1\n    inline char gc(){   return getchar();   }\n#if NEG\n    inline ll read(){    ll x=0,f=1; char ch=gc();   for (;!isdigit(ch);ch=gc()) if (ch=='-') f=-1;  for (;isdigit(ch);ch=gc())  x=x*10-48+ch;   return x*f; }\n    inline void write(ll x){    if (x<0) putchar('-'),x=-x;  if (x>=10)   write(x/10);    putchar(x%10+'0');  }\n#else\n    inline ll read(){    ll x=0; char ch=gc();   for (;!isdigit(ch);ch=gc());    for (;isdigit(ch);ch=gc())  x=x*10-48+ch;   return x;   }\n    inline void write(ll x){    if (x>=10)   write(x/10);    putchar(x%10+'0');  }\n#endif\n    inline char readchar(){ char ch=gc();   for(;isspace(ch);ch=gc());  return ch;  }\n    inline ll readstr(char *s){ char ch=gc();   int cur=0;  for(;isspace(ch);ch=gc());      for(;!isspace(ch);ch=gc())  s[cur++]=ch;    s[cur]='\\0';    return cur; }\n    inline void writeln(ll x){  write(x);   puts(\"\");   }\n    inline ld getreal(){    static ld lbc;  scanf(\"%lf\",&lbc);  return lbc; }\n}using namespace SHENZHEBEI;\nconst ll N=110,mod=1e9+7;\nll n,a[N],h[N],f[N][N][2];\nnamespace GuYue{\n\tll b[N],h[N],n;\n\tll ppow(ll x,ll k){\n\t\tll ans=1;\n\t\tfor(;k;k>>=1,Mul(x,x))if (k&1)Mul(ans,x);\n\t\treturn ans;\n\t}\n\tll work(){\n\t\tmemset(f,0,sizeof f);\n\t\tn=*a;\n//\t\tif (n==1)return ppow(2,a[1]);\n\t\tFor(i,1,n)b[i]=a[i];\n\t\tsort(b+1,b+n+1);\n\t\tll tot=unique(b+1,b+n+1)-b-1;b[tot+1]=b[tot];\n\t\tFor(i,1,n)h[i]=lower_bound(b+1,b+tot+1,a[i])-b;\n\t\tf[0][0][0]=f[0][0][1]=1;\n//\t\tFor(i,1,n)write(a[i]),putchar(' ');puts(\"\");\n\t\tFor(i,1,n){\n\t\t\tFor(cur1,0,h[i-1])For(cur2,0,h[i])For(num1,0,1)For(num2,0,1)\n\t\t\tif (f[i-1][cur1][num1]){\n\t\t\t\tll res1,res2,res3=0;\n\t\t\t\tif (cur2==h[i])res1=res2=1;\n\t\t\t\telse\tres1=ppow(2,b[cur2+1]-b[cur2]-(cur2==0))-1,res2=ppow(2,a[i]-b[cur2+1]);\n\t\t\t\tif ((num1!=num2)&&(min(cur1,cur2)>=min(h[i-1],h[i]))){\n\t\t\t\t\tres3=1;\n\t\t\t\t\tif (i==1)res3=0;\n\t\t\t\t}\n\t\t\t\tAdd(f[i][cur2][num2],f[i-1][cur1][num1]*res1%mod*res2%mod*res3);\n\t\t\t\tif ((num1==num2)&&((min(cur1,cur2)>=min(h[i-1],h[i]))||(cur1==cur2))){\n\t\t\t\t\tAdd(f[i][cur2][num2],f[i-1][cur1][num1]*res1%mod*res2%mod);\n\t\t\t\t}\n//\t\t\t\twriteln(f[i-1][cur1][num1]*res1%mod*res2%mod*res3);\n\t\t\t}\n\t\t}ll ans=0;\n\t\tFor(i,0,n)For(j,0,1)Add(ans,f[n][i][j]);\n//\t\twriteln(ans);\n\t\treturn ans;\n\t}\n}\nint main(){\n\tn=read();\n\tFor(i,1,n)h[i]=read();\n\tll ans=1;h[n+1]=1;\n\tfor(ll i=1;i<=n;)if (h[i]!=1){\n\t\t*a=0;\n\t\tfor(;h[i]!=1;)a[++*a]=h[i++];\n\t\tMul(ans,GuYue::work());\n\t}else\tMul(ans,2),++i;\n\tAdd(ans,mod);\n\twriteln(ans);\n}\n/*\n对于2\n取反,相同。。。 \n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define fi first\n#define se second\n\nconst int N = 105, mod = 1e9 + 7;\nint n, h[N];\n\nvoid add (int &_a, int _b) {\n    _a += _b;\n    if (_a >= mod) _a -= mod;\n}\n\nint binPow (int _a, int _n) {\n    int ret = 1;\n    for (; _n; _n >>= 1, _a = 1LL * _a * _a % mod) if (_n & 1) ret = 1LL * ret * _a % mod;\n    return ret;\n}\n\npair<int, int> solve (int l, int r) {\n    int minH = mod;\n\n    bool rect = 1;\n    for (int i = l; i + 1 <= r; ++i) if (h[i] != h[i + 1]) rect = 0;\n\n    if (rect) return { (binPow(2, r - l + 1) + binPow(2, min(h[l] - h[l - 1], h[r] - h[r + 1]) ) - 2 + mod) % mod,\n                      binPow(2, min(h[l] - h[l - 1], h[r] - h[r + 1]) ) };\n\n    for (int i = l; i <= r; ++i) minH = min(minH, h[i]);\n    vector< pair<int, int> > dp;\n    vector< pair<int, int> > range;\n    for (int i = l, lst = -1; i <= r; ++i) {\n        if (h[i] == minH) lst = -1;\n        else {\n            if (lst == -1) lst = i;\n            if (i == r || h[i + 1] == minH) dp.pb( { solve(lst, i) } );\n        }\n    }\n    for (int i = l, lst = -1; i <= r; ++i) {\n        if (h[i] > minH) lst = -1;\n        else {\n            if (lst == -1) lst = i;\n            if (i == r || h[i + 1] > minH) range.pb( { lst, i } );\n        }\n    }\n\n//    cout << \"l = \" << l << \"  r = \" << r << '\\n';\n//    for (auto _ : dp) cout << _.fi << ' '; cout << '\\n';\n\n    pair<int, int> ret = { 0, 0 };\n\n    int tmp = 1;\n    for (auto _ : dp) tmp = 1LL * tmp * ( (_.fi + _.se) % mod) % mod;\n    for (auto _ : range) tmp = 1LL * tmp * binPow(2, _.se - _.fi + 1) % mod;\n\n//    cout << \"tmp = \" << tmp << '\\n';\n\n    add(ret.fi, tmp);\n\n    tmp = 1;\n    for (auto _ : dp) tmp = 1LL * tmp * _.se % mod;\n    add(tmp, tmp);\n\n//    cout << \"tmp = \" << tmp << '\\n';\n\n    add(ret.fi, 1LL * tmp * ( (binPow(2, minH - max(h[l - 1], h[r + 1]) - 1) - 1 + mod) % mod) % mod);\n\n    add(ret.se, 1LL * tmp * binPow(2, minH - max(h[l - 1], h[r + 1]) - 1) % mod);\n\n//    cout << ret.fi << \"  \" << ret.se << '\\n';\n\n    return ret;\n}\n\nint main () {\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\n    cin >> n;\n    for (int i = 1; i <= n; ++i) cin >> h[i];\n\n    int ans = solve(1, n).fi;\n    cout << (ans % mod + mod) % mod;\n\n    return 0;\n}\n/*\n3\n4 2 5\n\n320\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define pb push_back\n//#define mp make_pair\n#define fr first\n#define sc second\n#define MAX ((ll)(1e17+100))\n#define MX ((ll)(1e5+100))\n#define ARRS ((ll)(1e6+100))\n#define ARS ((ll)(1e3+100))\n#define HS ((ll)(233))\n#define MOD ((ll)(1e9+7))\n#define EP ((double)(1e-9))\n#define LG 21\n#define mul(a,b) a=((a)*(b))%MOD\nusing namespace std;\n\nll dp[200][200][3];\nll a[ARRS];\n\nll pw(ll a,ll b){\n\tll p=1;\n\twhile(b){\n\t\tif(b&1)p=(p*a)%MOD;\n\t\ta=(a*a)%MOD;\n\t\tb>>=1;\n\t}\n\treturn p;\n}\n\nvoid go(ll l,ll r,ll d){\n\tif(l==r){\n\t\tdp[l][r][0]=1;\n\t\tdp[l][r][1]=1;\n\t\tdp[l][r][2]=0;\n\t\treturn;\n\t}\n\tvector<ll> v;\n\tll mn=MAX;\n\tfor(int i=l; i<r; i++)\n\t\tmn=min(mn,a[i]);\n\tv.pb(l-1);\n\tfor(int i=l; i<r; i++)\n\t\tif(a[i]==mn)v.pb(i);\n\tv.pb(r);\n\tfor(int i=0; i<v.size()-1; i++)\n\t\tgo(v[i]+1,v[i+1],mn);\n\tdp[l][r][0]=1;\n\tll t=0;\n\tfor(int i=0; i<v.size()-1; i++){\n\t\tmul(dp[l][r][0],dp[v[i]+1][v[i+1]][t]);\n\t\tt^=(v[i+1]-(v[i]+1));\n\t\tt^=1;\n\t\tt&=1;\n\t}\n\tdp[l][r][1]=1;\n\tt=1;\n\tfor(int i=0; i<v.size()-1; i++){\n\t\tmul(dp[l][r][1],dp[v[i]+1][v[i+1]][t]);\n\t\tt^=(v[i+1]-(v[i]+1));\n\t\tt^=1;\n\t\tt&=1;\n\t}\n\tdp[l][r][2]=1;\n\tfor(int i=0; i<v.size()-1; i++){\n\t\tif(v[i]+1!=v[i+1]){\n\t\t\tmul(dp[l][r][2],\n\t\t\t\tdp[v[i]+1][v[i+1]][0]+\n\t\t\t\tdp[v[i]+1][v[i+1]][1]+\n\t\t\t\tdp[v[i]+1][v[i+1]][2]);\n\t\t\t//cout<<v[i]+1<<\" - \"<<v[i+1]<<endl;\n\t\t\t\n\t\t\t//cout<<\n\t\t\t\t//dp[v[i]+1][v[i+1]][0]+\n\t\t\t\t//dp[v[i]+1][v[i+1]][1]+\n\t\t\t\t//dp[v[i]+1][v[i+1]][2]<<endl;\n\t\t}\n\t\tif(r!=v[i+1])\n\t\tmul(dp[l][r][2],2);\n\t}\n\t//cout<<dp[l][r][2]<<endl;\n\tdp[l][r][2]-=dp[l][r][0]+dp[l][r][1];\n\tdp[l][r][2]%=MOD;\n\tdp[l][r][2]+=MOD;\n\tdp[l][r][2]%=MOD;\n\tmul(dp[l][r][0],pw(2,mn-d));\n\tmul(dp[l][r][1],pw(2,mn-d));\n\t//cout<<l<<\" \"<<r-1<<\" \"<<dp[l][r][0]<<\" = \"<<dp[l][r][1]<<\" \"<<dp[l][r][2]<<endl;\n}\n\nint main(){\n\tll n;\n\tcin>>n;\n\tfor(int i=0; i<n; i++)\n\t\tcin>>a[i];\n\tgo(0,n,1);\n\tcout<<(dp[0][n][0]+dp[0][n][1]+dp[0][n][2])%MOD;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define pll pair <ll , ll>\n\n#define pb push_back\n#define pf push_front\n#define pob pop_back\n#define pof pop_front\n#define mp make_pair\n\n#define X first\n#define Y second\n\n#define LB(x) ((x) & -(x))\n#define BIT(a , b) (((a)>>(b)) & 1)\n\nconst ll MAXN=1e2+10;\nconst ll Mod=1e9+7;\nconst ll INF=1e9+10;\n\nll a[MAXN];\n\nll pw(ll x , ll n)\n{\n    if (n==0)\n    {\n        return 1;\n    }\n\n    ll w=pw(x , n/2);\n    w*=w;\n    w%=Mod;\n\n    if (n&1)\n    {\n        w*=x;\n        w%=Mod;\n    }\n\n    return w;\n}\n\npll solve(ll l , ll r)\n{\n    if (l>r)\n    {\n        return mp(1 , 1);\n    }\n\n    ll res=0 , t=1 , w=1 , d=0 , e=INF;\n\n    for(ll i=l;i<=r;i++)\n    {\n        e=min(e , a[i]);\n    }\n\n    ll z=l;\n\n    for(ll i=l;i<=r;i++)\n    {\n        a[i]-=e;\n\n        if (a[i]==0)\n        {\n            pll f=solve(z , i-1);\n\n            t*=f.Y;\n            t%=Mod;\n\n            w*=f.X;\n            w%=Mod;\n\n            d++;\n            z=i+1;\n        }\n    }\n\n    pll f=solve(z , r);\n\n    t*=f.Y;\n    t%=Mod;\n\n    w*=f.X;\n    w%=Mod;\n\n    res+=(pw(2 , d)*w)%Mod;\n    res%=Mod;\n\n    res+=(pw(2 , e)*t)%Mod;\n    res%=Mod;\n\n    res+=(t*((pw(2 , e)-2+Mod)%Mod))%Mod;\n    res%=Mod;\n\n    return mp(res , (pw(2 , e)*t)%Mod);\n}\n\nint main()\n{\n\tios_base :: sync_with_stdio(false);\n\tcin.tie(0);\n\n\tll n;\n\tcin>>n;\n\n\tfor(ll i=1;i<=n;i++)\n    {\n        cin>>a[i];\n    }\n\n    pll res=solve(1 , n);\n\n    cout<<(res.X-res.Y+Mod)%Mod;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <functional>\n#include <map>\n#include <set>\n#include <sys/timeb.h>\n#include <fstream>\n#include <random>\n#include <regex>\n#include <chrono>\n#include <bitset>\n#include <cassert>\n#include <iomanip>\n#include <limits>\n\nusing namespace std;\n\n//#define DEBUG_\n\n#define repr(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repr(i,0,n)\n#define reprrev(i,a,b) for(int i=(int)(b)-1;i>=(int)(a);i--)\n#define reprev(i,n) reprrev(i,0,n)\n#define repi(itr,ds) for(auto itr=ds.begin();itr!=ds.end();itr++)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define mp make_pair\n#define mt make_tuple\n#define INF 1050000000\n#define INFR INT_MAX\n#define INFL (long long)(4e18)\n#define INFLR LLONG_MAX\n#define EPS (1e-10)\n#define MOD 1000000007\n#define PI 3.141592653589793238\n#define RMAX 4294967295\n\n\n#ifdef DEBUG_\n#define DEB\n#else\n#define DEB if(false)\n#endif\n\n#ifdef DEBUG_\n#define dump(...) DUMPOUT<<\"  \"; \\\ndump_func(string(#__VA_ARGS__) + \":\", \"[\" + to_string(__LINE__) + \":\" + __FUNCTION__ + \"]\"); \\\nDUMPOUT<<\"    \"; \\\ndump_func(__VA_ARGS__)\n#else\n#define dump(...)\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> Pi;\ntypedef pair<ll, ll> Pll;\ntypedef pair<double, double> Pd;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<Pi> vPi;\ntypedef vector<Pll> vPll;\ntypedef vector<Pd>vPd;\ntypedef vector<vector<int> > vvi;\ntypedef vector<vector<bool> > vvb;\ntypedef vector<vector<ll> > vvll;\ntypedef vector<vector<char> > vvc;\ntypedef vector<vector<string> > vvs;\ntypedef vector<vector<double> > vvd;\ntypedef vector<vector<Pi> > vvPi;\ntypedef vector<vector<vector<int> > > vvvi;\ntypedef vector<vector<vector<ll> > > vvvll;\ntypedef vector<vector<vector<Pi> > > vvvPi;\ntypedef vector<vector<vector<vector<Pi> > > > vvvvPi;\ntypedef priority_queue<int, vector<int>, greater<int> > pqli;\ntypedef priority_queue<ll, vector<ll>, greater<ll> > pqlll;\ntypedef priority_queue<Pi, vector<Pi>, greater<Pi> > pqlP;\ntemplate <class T>\nusing vec = vector<T>;\ntemplate<class T>\nusing pql = priority_queue<T, vector<T>, greater<T>>;\nstring debug_show(Pi a) {\n\treturn \"(\" + to_string(a.first) + \",\" + to_string(a.second) + \")\";\n}\n\n#define DUMPOUT cerr\n\nvoid dump_func() {\n\tDUMPOUT << endl;\n}\ntemplate <class Head, class... Tail>\nvoid dump_func(Head&& head, Tail&&... tail) {\n\tDUMPOUT << head;\n\tif (sizeof...(Tail) <= 1) {\n\t\tDUMPOUT << \" \";\n\t}\n\telse {\n\t\tDUMPOUT << \", \";\n\t}\n\tdump_func(std::move(tail)...);\n}\n\n// vector\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& vec) {\n\tfor (T& x : vec) is >> x;\n\treturn is;\n}\n// pair\ntemplate<typename T, typename U>\nostream& operator << (ostream& os, pair<T, U>& pair_var) {\n\tos << \"(\" << pair_var.first << \",\" << pair_var.second << \")\";\n\treturn os;\n}\n// pair\ntemplate<typename T, typename U>\nostream& operator << (ostream& os, const pair<T, U>& pair_var) {\n\tos << \"(\" << pair_var.first << \",\" << pair_var.second << \")\";\n\treturn os;\n}\n// vector\ntemplate<typename T>\nostream& operator << (ostream& os, const vector<T>& vec) {\n\tos << \"{\";\n\tfor (int i = 0; i < vec.size(); i++) {\n\t\tos << vec[i] << (i + 1 == vec.size() ? \"\" : \", \");\n\t}\n\tos << \"}\";\n\treturn os;\n}\n// map\ntemplate<typename T, typename U>\nostream& operator << (ostream& os, map<T, U>& map_var) {\n\tos << \"{\";\n\trepi(itr, map_var) {\n\t\tos << \"(\" << itr->first << \",\" << itr->second << \")\";\n\t\titr++;\n\t\tif (itr == map_var.end()) os << \", \";\n\t\titr--;\n\t}\n\tos << \"}\";\n\treturn os;\n}\n// set\ntemplate<typename T>\nostream& operator << (ostream& os, set<T>& set_var) {\n\tos << \"{\";\n\trepi(itr, set_var) {\n\t\tos << \"  \" << *itr << endl;\n\t\titr++;\n\t\tif (itr == set_var.end()) os << \", \";\n\t\titr--;\n\t}\n\tos << \"}\";\n\treturn os;\n}\nstring YN(bool y, int id = 0) { if (id)cout << id; return (y ? \"YES\" : \"NO\"); }\nstring yn(bool y, int id = 0) { if (id)cout << id; return (y ? \"Yes\" : \"No\"); }\nstring ON(bool y, int id = 0) { if (id)cout << id; return (y ? \"OK\" : \"NG\"); }\n\nint dir4[4][2] = { { 0,-1 },{ -1,0 },{ 1,0 },{ 0,1 } };\nint dir8[8][2] = { { -1,-1 },{ 0,-1 },{ 1,-1 },{ -1,0 },{ 1,0 },{ -1,1 },{ 0,1 },{ 1,1 } };\nchar dirchar[4] = { '<','^','>','v' };\n\n// [a,b)\nint irand(int a, int b) {\n\tstatic mt19937 Rand(static_cast<unsigned int>(time(nullptr)));\n\tuniform_int_distribution<int> dist(a, b - 1);\n\treturn dist(Rand);\n}\n\n// [a,b)\ndouble drand(int a, int b) {\n\tstatic mt19937 Rand(static_cast<unsigned int>(time(nullptr)));\n\tuniform_real_distribution<double> dist(a, b);\n\treturn dist(Rand);\n}\nstruct Edge {\n\tint from, to, cost;\n\tbool operator<(Edge e) {\n\t\treturn cost < e.cost;\n\t}\n};\nusing Graph = vec<vec<Edge>>;\n\nostream& operator << (ostream& os, Edge &edge) {\n\tos << \"(\" << edge.from << \"->\" << edge.to << \":\" << edge.cost << \")\";\n\treturn os;\n}\n//======================================================\n\nll powMod(ll x, ll n, ll mod) {\n\tll res = 1;\n\twhile (n > 0) {\n\t\tif (n & 1) res = res * x % mod;\n\t\tx = x * x % mod;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\nvll h;\nGraph G;\nvector<Pll> node;\nvector<Pll> dp;\n\nint addChild(int par, Pll val) {\n\tstatic int next = 0;\n\n\tif(par != -1) G[par].push_back(Edge{ par,next,1 });\n\tnode[next] = val;\n\tnext++;\n\treturn next - 1;\n}\n\n// [left, right)で部分木作成\nvoid makeTree(int par, int height, int left, int right) {\n\tif (right <= left)return;\n\tcerr << left << \"-\" << right << endl;\n\n\tbool same = true;\n\tll minheight = h[left];\n\trepr(i, left + 1, right) {\n\t\tif (h[i] != h[i - 1]) {\n\t\t\tsame = false;\n\t\t}\n\t\tminheight = min(minheight, h[i]);\n\t}\n\tint pos = addChild(par, mp(right - left, minheight - height));\n\tif (same) {\n\t\treturn;\n\t}\n\n\tint l = left;\n\trepr(i, left, right) {\n\t\tif (h[i] == minheight) {\n\t\t\tmakeTree(pos, minheight, l, i);\n\t\t\tl = i + 1;\n\t\t}\n\t}\n\tmakeTree(pos, minheight, l, right);\n}\n\nvoid solve(int pos) {\n\tll x = node[pos].second;\n\tll w = node[pos].first;\n\tfor (auto e : G[pos]) {\n\t\tw -= node[e.to].first;\n\t}\n\n\tll dp1 = powMod(2, x, MOD);\n\tll dp21 = powMod(2, w, MOD);\n\tll dp22 = (powMod(2, x, MOD) - 2 + MOD) % MOD;\n\n\tfor (auto e : G[pos]) {\n\t\tsolve(e.to);\n\t\tdp1 *= dp[e.to].first;\n\t\tdp1 %= MOD;\n\t\tdp21 *= dp[e.to].first + dp[e.to].second;\n\t\tdp21 %= MOD;\n\t\tdp22 *= dp[e.to].first;\n\t\tdp22 %= MOD;\n\t}\n\tdp[pos].first = dp1;\n\tdp[pos].second = (dp21 + dp22) % MOD;\n}\n\nint main() {\n\tint N;\n\tcin >> N;\n\th.resize(N);\n\tcin >> h;\n\n\tG.resize(N);\n\tnode.resize(N, mp(-1,-1));\n\tdp.resize(N, mp(-1,-1));\n\n\tmakeTree(-1, 0, 0, N);\n\n\tsolve(0);\n\n\tcout << dp[0].second << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\nusing ll = long long;\nusing u64 = uint_fast64_t;\nusing pii = pair<int, int>;\nusing pll = pair<long long, long long>;\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define all(x) (x).begin(),(x).end()\nconstexpr char ln =  '\\n';\nconstexpr long long MOD = 1000000007;\n//constexpr long long MOD = 998244353;\ntemplate<class T1, class T2> inline bool chmax(T1 &a, T2 b) { if (a < b) { a = b; return true;} return false; }\ntemplate<class T1, class T2> inline bool chmin(T1 &a, T2 b) { if (a > b) { a = b; return true;} return false; }\ninline int popcount(int x) {return __builtin_popcount(x);}\ninline int popcount(long long x) {return __builtin_popcountll(x);}\nvoid print() { cout << \"\\n\"; }\ntemplate<class T, class... Args>\nvoid print(const T &x, const Args &... args) {\n    cout << x << \" \";\n    print(args...);\n}\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\ntemplate <uint_fast64_t Modulus> \nstruct ModInt {\n    using u64 = uint_fast64_t;\n\n    u64 a;\n\n    constexpr ModInt(const long long x = 0) noexcept : a(x >= 0 ? x % Modulus : (Modulus - (-x) % Modulus) % Modulus) {}\n    constexpr u64 &value() noexcept {return a;}\n    constexpr const u64 &value() const noexcept {return a;}\n    constexpr ModInt operator+(const ModInt rhs) const noexcept {return ModInt(*this) += rhs;}\n    constexpr ModInt operator-(const ModInt rhs) const noexcept {return ModInt(*this) -= rhs;}\n    constexpr ModInt operator*(const ModInt rhs) const noexcept {return ModInt(*this) *= rhs;}\n    constexpr ModInt operator/(const ModInt rhs) const noexcept {return ModInt(*this) /= rhs;}\n    constexpr ModInt operator^(const long long rhs) const noexcept {return ModInt(*this) ^= rhs;}\n    constexpr bool operator==(const ModInt &rhs) const noexcept {return a == rhs.a;}\n    constexpr bool operator!=(const ModInt &rhs) const noexcept {return a != rhs.a;}\n    constexpr ModInt &operator+=(const ModInt rhs) noexcept {\n        a += rhs.a;\n        if (a >= Modulus) {\n            a -= Modulus;\n        }\n        return *this;\n    }\n    constexpr ModInt &operator-=(const ModInt rhs) noexcept {\n        if (a < rhs.a) {\n            a += Modulus;\n        }\n        a -= rhs.a;\n        return *this;\n    }\n    constexpr ModInt &operator*=(const ModInt rhs) noexcept {\n        a = a * rhs.a % Modulus;\n        return *this;\n    }\n    constexpr ModInt &operator/=(ModInt rhs) noexcept {\n        u64 exp = Modulus - 2;\n        while (exp) {\n            if (exp&1) *this *= rhs;\n            exp >>= 1;\n            rhs *= rhs;\n        }\n        return *this;\n    }\n    constexpr ModInt &operator^=(long long exp) noexcept {\n        ModInt rhs = a;\n        a = 1;\n        while (exp) {\n            if (exp&1) *this *= rhs;\n            exp >>= 1;\n            rhs *= rhs;\n        }\n        return *this;\n    }\n\n    friend ostream &operator<<(ostream& os, const ModInt& rhs) noexcept {return os << rhs.a;}\n    friend istream &operator>>(istream& is, ModInt& rhs) noexcept {long long a; is >> a; rhs = a; return is;}\n};\n\nusing mint = ModInt<MOD>;\n\n\ntemplate<typename T>\nstruct Compress {\n    vector<T> xs;\n\n    Compress(){};\n    Compress(const vector<T> &vs) {add(vs);}\n    Compress(const initializer_list<vector<T>> &vs) {for(auto &p : vs) add(p);}\n\n    void add(const vector<T> &vs) {copy(begin(vs), end(vs), back_inserter(xs));}\n    void add(const T &x) {xs.emplace_back(x);}\n\n    int build() {\n        sort(begin(xs), end(xs));\n        xs.erase(unique(begin(xs), end(xs)), end(xs));\n        return (int)xs.size();\n    }\n\n    vector<int> get(const vector<T> &vs) const {\n        vector<int> ret;\n        transform(begin(vs), end(vs), back_inserter(ret), [&](const T &x) {\n            return lower_bound(begin(xs), end(xs), x) - begin(xs);\n        });\n        return ret;\n    }\n\n    int get(const T &x) const {return lower_bound(begin(xs), end(xs), x) - begin(xs);}\n\n    const T &operator[](int k) const {return xs[k];}\n};\n\nint main() {\n    ios::sync_with_stdio(false); cin.tie(nullptr);\n    int N; cin >> N;\n    vector<int> h(N+1);\n    rep(i,N) cin >> h[i+1];\n\n    Compress<int> Com(h);\n    Com.add((int)1e9+1);\n    int M = Com.build();\n    vector<vector<mint>> dp(N+1, vector<mint>(M));\n    dp[0][1] = 1;\n    for (int i = 1; i <= N; i++) {\n        if (h[i] > h[i-1]) {\n            int H = Com.get(h[i-1]) + 1;\n            mint C = 2;\n            C ^= h[i] - h[i-1];\n            rep(j,M) {\n                if (Com[j] <= h[i-1]) {\n                    dp[i][j] += dp[i-1][j]*C;\n                } else if (Com[j] <= h[i]) {\n                    mint two = 2;\n                    two ^= Com[j] - Com[j-1];\n                    if (j==1) two /= 2;\n                    dp[i][j] += dp[i-1][H]*(two-1)*(mint(2)^(h[i]-Com[j]))*2;\n                } else {\n                    dp[i][j] += dp[i-1][H]*2;\n                    break;\n                }\n            }\n        } else {\n            int H = Com.get(h[i]) + 1;\n            rep(j,M) {\n                if (Com[j] <= h[i]) {\n                    dp[i][j] += dp[i-1][j];\n                } else if (Com[j] <= h[i-1]) {\n                    dp[i][H] += dp[i-1][j]*2;\n                } else {\n                    dp[i][H] += dp[i-1][j]*2;\n                    break;\n                }\n            }\n        }\n    }\n\n    mint ans = 0;\n    rep(j,M) ans += dp[N][j];\n    cout << ans << ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "//              +-- -- --++-- +-In the name of ALLAH-+ --++-- -- --+              \\\\\n\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define _sz(x) (int)x.size()\n\nusing namespace std ;\nusing ll = long long ;\nusing ld = long double ;\nusing pii = pair <int , int> ;\n\nint const N = 100 + 10 , mod = 1e9 + 7 ;\nint n , h[N] ;\n\nint inv2 = (mod + 1) >> 1 ;\n\nint z = 1 ;\nset <pii> dp ;\n\ninline void add (int &a , int b) {\n\ta += b ;\n\tif (a >= mod) a -= mod ;\n}\n\ninline int pw (int a , int b) {\n\tint res = 1 ;\n\tfor (; b ; b >>= 1 , a = 1ll * a * a % mod) \n\t\tif (b & 1) res = 1ll * res * a % mod ;\n\treturn res ;\n}\n\ninline int get (int start , int len) {\n\treturn (2 * start - (2ll * start * pw(inv2 , len)) % mod + mod) % mod ;\n}\n\nint main(){\n\tios::sync_with_stdio(false) , cin.tie(0) , cout.tie(0) ;\n\t\n\tcin >> n ;\n\tfor (int i = 0 ; i < n ; i ++) cin >> h[i] ;\n\n\tif (h[0] > 1) dp.insert({1 , pw(2 , h[0] - 1)}) ; \n\tdp.insert({h[0] , 2}) ;\n\n\tfor (int i = 1 ; i < n ; i ++) {\n\t\tif (h[i - 1] >= h[i]) {\n\t\t\tint sum = 0 , last = h[i - 1] + 1 ;\n\t\t\twhile (dp.size() && dp.rbegin() -> F > h[i]) {\n\t\t\t\tpii p = *dp.rbegin() ;\n\t\n\t\t\t\tadd(sum , get(p.S , last - p.F)) ;\n\n\t\t\t\tlast = p.F ;\n\n\t\t\t\tdp.erase(p) ;\n\t\t\t}\n\n\t\t\tif (dp.size()) {\n\t\t\t\tpii p = *dp.rbegin() ;\n\t\t\t\tadd(sum , get(1ll * p.S * pw(inv2 , h[i] - p.F) % mod , last - h[i])) ;\n\t\t\t\tif (p.F == h[i]) dp.erase(p) ;\n\t\t\t}\n\n\t\t\tadd(sum , sum) ;\n\n\t\t\tdp.insert({h[i] , sum}) ; \n\t\t}\n\t\telse {\n\t\t\tz = 1ll * z * pw(2 , h[i] - h[i - 1]) % mod ;\n\n\t\t\tpii p = *dp.rbegin() ;\n\n\t\t\tassert(p.F == h[i - 1]) ;\n\n\t\t\tdp.insert({h[i] , 2ll * p.S * pw(inv2 , h[i] - h[i - 1]) % mod}) ;\n\t\t}\n\t}\n\n\tint last = h[n - 1] + 1 , ans = 0 ;\n\twhile (_sz(dp)) {\n\t\tpii p = *dp.rbegin() ;\n\t\n\t\tadd(ans , get(p.S , last - p.F)) ;\n\n\t\tlast = p.F ;\n\n\t\tdp.erase(p) ;\n\t}\n\n\tans = 1ll * ans * z % mod ;\n\n\tcout << ans << '\\n' ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int mod = 1e9 + 7;\nconst int N = 105;\n\nint n, h[N];\nint p[N], l[N], r[N];\nint f[N][2], sz[N], H[N], visit[N][N];\nvector<int> G[N];\n\nint binPow(int x, int y) {\n\tif (!y) return 1;\n\tint ret = binPow(x, y >> 1); \n\tret = 1LL * ret * ret % mod;\n\tif (y & 1) ret = 1LL * ret * x % mod; \n\treturn ret;\n}\n\nvoid dfs(int u) {\n\tint tmp = sz[u];\n\tf[u][0] = f[u][1] = 1;\n\tfor (auto v : G[u]) {\n\t\tdfs(v), tmp -= sz[v];\n\t\tf[u][0] = 1LL * f[u][0] * f[v][0] % mod;\n\t\tf[u][1] = 1LL * f[u][1] * (2LL * f[v][0] + f[v][1]) % mod;\n\t}\n\tf[u][0] = 2 * f[u][0] % mod;\n\tf[u][1] = 1LL * f[u][1] * binPow(2, tmp) % mod;\n\tf[u][1] = (f[u][1] + mod - f[u][0]) % mod;\n\tf[u][0] = 1LL * f[u][0] * binPow(2, H[u] - 1) % mod;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> n;\n\tfor (int i = 1; i <= n; ++i) cin >> h[i];\n\tfor (int i = 1; i <= n; ++i) {\n\t\tl[i] = i;\n\t\twhile (l[i] > 1 && h[l[i] - 1] >= h[i]) l[i] = l[l[i] - 1];\n\t}\n\tfor (int i = n; i >= 1; --i) {\n\t\tr[i] = i;\n\t\twhile (r[i] < n && h[r[i] + 1] >= h[i]) r[i] = r[r[i] + 1];\n\t}\n\tfor (int i = 1; i <= n; ++i) p[i] = i;\n\tsort(p + 1, p + 1 + n, [&] (int x, int y) {\n\t\treturn h[x] < h[y];\n\t});\n\tint cnt = 0;\n\tvisit[1][n] = ++cnt, sz[1] = n, H[1] = h[p[1]];\n\tfor (int i = 1; i <= n; ++i) {\n\t\tint L = l[p[i]], R = r[p[i]];\n\t\tif (visit[L][R]) continue;\t\t\n\t\tvisit[L][R] = ++cnt, sz[cnt] = R - L + 1;\n\t\tH[cnt] = h[p[i]] - max(h[L - 1], h[R + 1]);\n\t\tint par = 0;\n\t\tif (L > 1 && R < n) {\n\t\t\tif (h[L - 1] > h[R + 1]) par = visit[l[L - 1]][r[L - 1]];\n\t\t\telse par = visit[l[R + 1]][r[R + 1]];\n\t\t}\n\t\telse if (L > 1) par = visit[l[L - 1]][r[L - 1]];\n\t\telse par = visit[l[R + 1]][r[R + 1]];\n\t\tG[par].push_back(cnt);\n\t\t// cout << cnt << ' ' << par << ' ' << H[cnt] << ' ' << sz[cnt] << ' ' << L << ' ' << R << '\\n';\n\t}\n\tdfs(1);\n\t// for (int i = 1; i <= cnt; ++i) cout << f[i][0] << ' ' << f[i][1] << '\\n';\n\tcout << (f[1][0] + f[1][1]) % mod;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nThough leaves are many , the root is one.\nThrough all the lying days of my youth\nI swayed my leaves and flowers in the sun.\nNow I may wither into the truth.\n\t  \t  \t- William Butler Yeats\n*/\n//#pragma GCC optimize(\"Ofast,no-stack-protector\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\")\n//#pragma GCC target(\"avx,tune=native\")\n#include<bits/stdc++.h>\n#define int long long\n#pragma comment(\"-Wl,--stack=1024000000\")\n//#include<ext/pb_ds/assoc_container.hpp>\nusing namespace std;\n//using namespace __gnu_pbds;\nconst int inf=0x3f3f3f3f;\nconst double eps=1e-6;\nconst int mod=1000000007;\ntypedef long long ll;\n#ifndef LOCAL\n#define cerr if(0)cout\n#define eprintf(...) 0\n#else\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#endif\ninline string getstr(string &s,int l,int r){string ret=\"\";for(int i=l;i<=r;i++)ret.push_back(s[i]);return ret;}\nint modpow(int x,int y,int md=mod){int ret=1;do{if(y&1)ret=(ll)ret*x%md;x=(ll)x*x%md;}while(y>>=1);return ret;}\ninline int Rand(){return rand()*32768+rand();}\npair<int,int>solve(vector<int>h){\n\tif(!h.size())return make_pair(0,1);\n\tint low=*min_element(h.begin(),h.end());\n\tvector<int>split;\n\tfor(int i=0;i<h.size();i++){\n\t\th[i]-=low;if(!h[i])split.push_back(i);\n\t}\n\tpair<int,int>ret(modpow(2,split.size(),mod),2);\n\tsplit.insert(split.begin(),-1);split.push_back(h.size());\n\tfor(int i=0;i+1<split.size();i++){\n\t\tvector<int>tmp(h.begin()+split[i]+1,h.begin()+split[i+1]);\n\t\tauto got=solve(tmp);\n\t\tret.first=ret.first*(got.first+got.second)%mod;\n\t\tret.second=ret.second*got.second%mod;\n\t}\n\tret.first+=ret.second*(modpow(2,low-1,mod)-1)%mod;ret.first%=mod;\n\tret.second=ret.second*modpow(2,low-1,mod)%mod;\n\treturn ret;\n}\nvector<int>h;\nsigned main(){\n\tint n;cin>>n;h.resize(n);\n\tfor(int i=0;i<h.size();i++)cin>>h[i];\n\tcout<<solve(h).first<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nll mod_pow(ll x,ll n){\n\tll res=1;\n\twhile(n>0){\n\t\tif(n&1LL)res=res*x%MOD;\n\t\tx=x*x%MOD;\n\t\tn>>=1;\n\t}\n\treturn res;\n}\nll h[105];\nll h_min[205];\nll h_dif[205];\nint l[205],r[205];\nint w[205];\nint siz;\nvector<int> G[205];\nll dp1[205],dp2[205];\n\nvoid build(int lx,int rx){\n\tl[siz]=lx;\n\tr[siz]=rx;\n\th_min[siz]=h[lx];\n\tw[siz]=rx-lx;\n\tfor(int i=lx;i<rx;i++){\n\t\th_min[siz]=min(h_min[siz],h[i]);\n\t}\n\th_dif[siz]+=h_min[siz];\n\tint par=siz;\n\tint prv=lx;\n\tfor(int i=lx;i<rx;i++){\n\t\tif(h[i]==h_min[par]){\n\t\t\tif(i==prv){\n\t\t\t\tprv++;\n\t\t\t}else{\n\t\t\t\tsiz++;\n\t\t\t\tG[par].push_back(siz);\n\t\t\t\th_dif[siz]-=h_min[par];\n\t\t\t\tw[par]-=i-prv;\n\t\t\t\tbuild(prv,i);\n\t\t\t\tprv=i+1;\n\t\t\t}\n\t\t}\n\t}\n\tif(prv!=rx){\n\t\tsiz++;\n\t\tG[par].push_back(siz);\n\t\th_dif[siz]-=h_min[par];\n\t\tw[par]-=rx-prv;\n\t\tbuild(prv,rx);\n\t}\n}\n\nvoid solve(int v){\n\tif(h_dif[v]==0)w[v]=0;\n\tdp1[v]=1;\n\tdp2[v]=1;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tsolve(G[v][i]);\n\t\tdp1[v]*=dp1[G[v][i]];\n\t\tdp1[v]%=MOD;\n\t\tdp2[v]*=(dp1[G[v][i]]+dp2[G[v][i]])%MOD;\n\t\tdp2[v]%=MOD;\n\t}\n\tdp2[v]=dp2[v]*mod_pow(2,w[v])%MOD;\n\tif(h_dif[v]>0)dp2[v]+=dp1[v]*(mod_pow(2,h_dif[v])-2)%MOD;\n\tdp2[v]%=MOD;\n\tif(dp2[v]<0)dp2[v]+=MOD;\n\tdp1[v]*=mod_pow(2,h_dif[v]);\n\tdp1[v]%=MOD;\n}\n\nint main(void){\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%lld\",&h[i]);\n\t}\n\tbuild(0,n);\n\tsolve(0);\n\tprintf(\"%lld\\n\",dp2[0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nll H[105];\nll mo=1000000007;\nll ret=1;\n\nll memo[105][105];\n\nll dp[101010];\n\nll modpow(ll a, ll n = mo-2) {\n\tll r=1;a%=mo;\n\twhile(n) r=r*((n%2)?a:1)%mo,a=a*a%mo,n>>=1;\n\treturn r;\n}\n\n\nll hoge(int L,int R) {\n\tif(L>R) return 1;\n\tif(memo[L][R]>=0) return memo[L][R];\n\t\n\tll HH[105]={};\n\tint i;\n\tHH[L-1]=H[L-1];\n\tHH[R+1]=H[R+1];\n\tfor(i=L;i<=R;i++) HH[i]=max(HH[i],min(HH[i-1],H[i]));\n\tfor(i=R;i>=L;i--) HH[i]=max(HH[i],min(HH[i+1],H[i]));\n\t\n\tint x=L;\n\tfor(int i=L+1;i<=R;i++) if(H[i]>H[x]) x=i;\n\tmemo[L][R]=modpow(2,H[x]-HH[x])*hoge(L,x-1)%mo*hoge(x+1,R)%mo;\n\treturn memo[L][R];\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tfor(i=1;i<=N;i++) cin>>H[i];\n\tMINUS(memo);\n\t\n\tFOR(j,1001) {\n\t\tFOR(i,N+1) {\n\t\t\tif(H[i]==1) {\n\t\t\t\t(ret*=2)%=mo;\n\t\t\t\tH[i]=0;\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<N+1;i++) {\n\t\t\tif(H[i]>max(H[i-1],H[i+1])) {\n\t\t\t\t(ret*=modpow(2,H[i]-max(H[i-1],H[i+1])))%=mo;\n\t\t\t\tH[i]=max(H[i-1],H[i+1]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint L,R;\n\tfor(L=1;L<=N;L++) if(H[L]) {\n\t\tR=L;\n\t\twhile(R<=N && H[R]) R++;\n\t\t\n\t\tdp[L-1]=2;\n\t\tfor(int x=L;x<R;x++) {\n\t\t\tfor(y=L-1;y<x;y++) {\n\t\t\t\tfor(i=y+1;i<x;i++) {\n\t\t\t\t\tdp[x]+=dp[y]*hoge(y+1,i-1)%mo;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[x]%=mo;\n\t\t\t\n\t\t}\n\t\tll tot=0;\n\t\tfor(x=L-1;x<R;x++) {\n\t\t\tif(x==L-1) tot+=dp[x]*hoge(x+1,R-1)%mo*((mo+1)/2)%mo;\n\t\t\telse tot+=dp[x]*hoge(x+1,R-1)%mo;\n\t\t}\n\t\t\n\t\t(ret*=tot%mo)%=mo;\n\t\tL=R;\n\t}\n\t\n\tcout<<ret<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <vector>\n#include <bitset>\n#include <cstdio>\n#include <cctype>\n#include <string>\n#include <numeric>\n#include <cstring>\n#include <cassert>\n#include <climits>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\n#include <functional>\nusing namespace std ;\n#define rep(i, a, b) for (register ll i = (a); i <= (b); ++i)\n#define per(i, a, b) for (register ll i = (a); i >= (b); --i)\n#define loop(it, v) for (auto it = v.begin(); it != v.end(); it++)\n#define cont(i, x) for (register int i = head[x]; i; i = edge[i].nex)\n#define clr(a) memset(a, 0, sizeof(a))\n#define ass(a, cnt) memset(a, cnt, sizeof(a))\n#define cop(a, b) memcpy(a, b, sizeof(a))\n#define lowbit(x) (x & -x)\n#define all(x) x.begin(), x.end()\n#define SC(t, x) static_cast <t> (x)\n#define ub upper_bound\n#define lb lower_bound\n#define pqueue priority_queue\n#define mp make_pair\n#define pb push_back\n#define pof pop_front\n#define pob pop_back\n#define fi first\n#define se second\n#define y1 y1_\n#define Pi acos(-1.0)\n#define iv inline void\n#define enter putchar('\\n')\n#define siz(x) ((int)x.size())\n#define file(x) freopen(x\".in\", \"r\", stdin),freopen(x\".out\", \"w\", stdout)\ntypedef double db ;\ntypedef long long ll ;\ntypedef unsigned long long ull ;\ntypedef pair <int, int> pii ;\ntypedef vector <int> vi ;\ntypedef vector <pii> vii ;\ntypedef queue <int> qi ;\ntypedef queue <pii> qii ;\ntypedef set <int> si ;\ntypedef map <int, int> mii ;\ntypedef map <string, int> msi ;\nconst int maxn = 1e2 + 5 ;\nconst int inf = 0x3f3f3f3f ;\nconst int iinf = 1 << 30 ;\nconst ll linf = 2e18 ;\nconst ll mod = 1e9 + 7 ;\nconst double eps = 1e-7 ;\ntemplate <class T = int> T read()\n{\n\tT f = 1, a = 0;\n\tchar ch = getchar() ;\n\twhile (!isdigit(ch)) { if (ch == '-') f = -1 ; ch = getchar() ; }\n\twhile (isdigit(ch)) { a =  (a << 3) + (a << 1) + ch - '0' ; ch = getchar() ; }\n\treturn a * f ;\n}\n\nll power(ll a, ll b)\n{\n\tll ret = 1;\n\tfor(; b; b >>= 1, (a *= a) %= mod) if(b & 1) (ret *= a) %= mod;\n\treturn ret;\n}\n\nll n, ans;\n\nll h[maxn];\n\nll f[maxn][maxn], g[maxn][maxn];\n\nvoid solve(ll l, ll r, ll d)\n{\n\t// printf(\"%lld %lld\\n\", l, r);\n\tif(l > r) return ;\n\tll pos, maxx = linf;\n\trep(i, l, r) if(h[i] < maxx) maxx = h[i], pos = i;\n\tg[l][r] += h[pos] - d;\n\tsolve(l, pos - 1, h[pos]), solve(pos + 1, r, h[pos]);\n}\n\nsigned main()\n{\n\tscanf(\"%lld\", &n);\n\trep(i, 1, n) scanf(\"%lld\", &h[i]);\n\tsolve(1, n, 1);\n\t// rep(i, 1, n) rep(j, i, n) printf(\"%lld %lld : %lld\\n\", i, j, g[i][j]);\n\trep(i, 1, n) per(j, i - 1, 1) (g[j][i] += g[j + 1][i]) %= (mod - 1);\n\t// rep(i, 1, n) rep(j, i, n) printf(\"%lld %lld : %lld\\n\", i, j, g[i][j]);\n\tf[1][1] = (2 * power(2, g[1][1])) % mod;\n\trep(i, 1, n - 1) rep(j, 1, i)\n\t{\n\t\t(f[i + 1][j + 1] += f[i][j] * power(2, g[i - j + 1][i + 1]) % mod) %= mod;\n\t\t(f[i + 1][1] += f[i][j] * power(2, g[i + 1][i + 1]) % mod) %= mod;\n\t}\n\trep(i, 1, n) (ans += f[n][i]) %= mod;\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\nconst ll MOD = 1000000007;\n\nll modpow(ll x, ll n){\n    ll res = 1, r = x;\n    while(n){\n        if(n % 2) res = res * r % MOD;\n        r = r * r % MOD;\n        n /= 2;\n    }\n    return res;\n}\n\nll p[102];\nll h[102];\n\nP dfs(ll left, ll right, ll height){\n    ll lowest = MOD;\n    for(int i = left; i < right; i++) lowest = min(lowest, h[i]);\n    P d[102];\n    ll c = 0;\n    ll k = 0;\n    ll last = left;\n    for(int i = left; i < right; i++){\n        if(h[i] == lowest){\n            c++;\n            if(i != last){\n                d[k] = dfs(last, i, lowest);\n                k++;\n            }\n            last = i + 1;\n        }\n    }\n    if(last != right){\n        d[k] = dfs(last, right, lowest);\n        k++;\n    }\n    ll dp[102][102];\n    for(int i = 0; i <= k; i++){\n        for(int j = 0; j <= k; j++) dp[i][j] = 0;\n    }\n    dp[0][0] = 1;\n    for(int i = 1; i <= k; i++){\n        for(int j = 0; j <= i; j++){\n            dp[i][j] = dp[i - 1][j] * d[i - 1].second % MOD;\n            if(j) dp[i][j] = (dp[i][j] + dp[i - 1][j - 1] * d[i - 1].first % MOD) % MOD;\n        }\n    }\n    P res = P(0, 0);\n    for(int j = 0; j <= k; j++){\n        res.second = (res.second + dp[k][j] * p[c + j] % MOD) % MOD;\n    }\n    res.first = dp[k][k] * 2 % MOD;\n    res.second = (res.second + MOD - res.first) % MOD;\n    res.first = res.first * modpow(2, lowest - height - 1) % MOD;\n    return res;\n}\n\nint main()\n{\n    int n;\n    cin >> n;\n    for(int i = 0; i < n; i++) cin >> h[i];\n    p[0] = 1;\n    for(int i = 1; i <= n; i++) p[i] = p[i - 1] * 2 % MOD;\n    P ans = dfs(0, n, 0);\n    cout << (ans.first + ans.second) % MOD << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <vector>\n#include <cassert>\n#include <fstream>\n#include <algorithm>\n#include <list>\n#include <random>\n#include <ctime>\n#include <cmath>\n#include <random>\n#include <bitset>\n#include <complex>\n#pragma unroll\n#pragma loop count N\n#pragma ivdep\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n//#define int ll\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef pair<ld, ld> pld;\ntypedef complex<double> base;\n\n#define mmin(a, b) a = min(a, (b))\n#define mmax(a, b) a = max(a, (b))\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define ALL(a) a.begin(),a.end()\n#define sqr(x) (x) * (x)\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define cint const int &\n#define SZ(a) ((int)(a.size()))\n#define f(cnt) (((cnt) + 1) * (cnt) / 2)\n#define watch(x) cout << (#x) << \" = \" << x << endl;\n\nconst double PI = 2 * acos(0.0);\n\ntemplate<class T>\nvoid show(const set<T> &a) {\n    for (T x : a)\n        cout << x << \" \";\n    cout << endl;\n}\n\ntemplate<class T>\nvoid show(const vector<T> &a) {\n    for (T x : a)\n        cout << x << \" \";\n    cout << endl;\n}\n\nconst ll M = 1e9 + 7;\n\nll MOD(ll a) {\n    if (a >= 0) return a >= M ? a % M : a;\n    if (a <= -M) a %= M;\n    return a ? a + M : a;\n}\n\nconst int N = 1000;\n\nstruct edge {\n    int u, v;\n    ll height;\n    edge(int u, int v, ll height): u(u), v(v), height(height) {\n\n    }\n\n};\nvector<edge> e;\n\nll pw(ll a, ll p) {\n    if (!p) return 1;\n    ll ret = pw(a, p >> 1);\n    ret = MOD(ret * ret);\n    if (p & 1) ret = MOD(ret * a);\n    return ret;\n}\n\nint counter = 1;\nvi g[N];\nll len[N];\nint vert[N];\nint start[N];\nll h[N];\nll dp[2][N];\n\nll get_ways(int v) {\n    vvvl dp(N, vvl(2, vl(2, 0)));\n    vector<char> must(N, 0);\n    for (int id : g[v]) {\n        int to = e[id].v;\n        for (int i = 1; i < len[to]; ++i)\n            must[i + start[to]] = 1;\n    }\n    dp[start[v]][0][0] = dp[start[v]][0][1] = 1;\n    for (int i = 1; i < len[v]; ++i) {\n        int ind = i + start[v];\n        if (must[ind]) {\n            for (int z1 : {0, 1}) for (int z2 : {0, 1})\n                dp[ind][z1][z2] = dp[ind - 1][z1][!z2];\n        } else {\n            for (int z1 : {0, 1}) for (int z2 : {0, 1}) for (int z3 : {0, 1}) {\n                int nx = z1;\n                if (z2 != z3) nx = 1;\n                dp[ind][nx][z3] = MOD(dp[ind][nx][z3] + dp[ind - 1][z1][z2]);\n            }\n        }\n    }\n    ll ret = MOD(dp[start[v] + len[v] - 1][1][0] + dp[start[v] + len[v] - 1][1][1]);\n    return ret;\n}\n\nll dfs(int v) {\n    ll dp1 = 1; // wasn't any bad\n    ll dp2 = 0; /* was bad */;\n    ll restlen = len[v];\n    dp[0][v] = 1;\n    for (int id : g[v]) {\n        int to = e[id].v;\n        restlen -= len[to];\n        dfs(to);\n        ll curgood = MOD(pw(2, e[id].height - 1) * dp[0][to]);\n        dp[0][v] = MOD(dp[0][v] * curgood);\n        ll curbad = dp[1][to];\n        ll odp1 = dp1;\n        ll odp2 = dp2;\n        dp1 = MOD(odp1 * curgood * 2);\n        dp2 = MOD(odp2 * (curgood * 2 + curbad) + odp1 * curbad);\n    }\n    ll ways = get_ways(v);\n    dp[1][v] = MOD(dp2 * pw(2, restlen) + dp[0][v] * ways);\n    dp[0][v] = MOD(2 * dp[0][v]);\n}\n\nsigned main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n\n\n    int n;\n    cin >> n;\n    set<ll> hs;\n    fori (i, n) {\n        cin >> h[i];\n        hs.insert(h[i]);\n    }\n    ll prev = 0;\n    len[counter++] = n;\n    fori (i , n)\n        vert[i] = 1;\n    int curv = 0;\n    int par = 0;\n    for (auto hi : hs) {\n        int cnt = 0;\n        fori (i, n) {\n            if (h[i] >= hi) {\n                if (!cnt) {\n                    curv = counter++;\n                    start[curv] = i;\n                }\n                par = vert[i];\n                vert[i] = curv;\n                cnt++;\n            } else {\n                if (cnt >= 2) {\n                    len[curv] = cnt;\n                    g[par].pb(e.size());\n                    e.pb(edge(par, curv, hi - prev));\n                }\n                cnt = 0;\n            }\n        }\n        if (cnt >= 2) {\n            len[curv] = cnt;\n            g[par].pb(e.size());\n            e.pb(edge(par, curv, hi - prev));\n        }\n        prev = hi;\n    }\n    int fre = 0;\n    fori (i, n) {\n        int lf = 0, rf = 0;\n        if (i) lf = h[i - 1];\n        if (i != n - 1) rf = h[i + 1];\n        fre += max(0LL, h[i] - max(lf, rf));\n    }\n    dfs(2);\n    ll ans = MOD(dp[0][2] * pw(2, e[g[1][0]].height - 1) + dp[1][2]);\n    ans = MOD(ans * pw(2, fre));\n    cout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nconst int moder = 1e9 + 7;\nconst int N = 110;\n\nint powermod(int a, int exp){\n    int ret = 1;\n    for ( ; exp > 0; exp >>= 1){\n        if (exp & 1){\n            ret = 1ll * a * ret % moder;\n        }\n        a = 1ll * a * a % moder;\n    }\n    return ret;\n}\n\nint h[N], c[N];\nint dp[N][N];\n\nint main(){\n    int n;\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; ++ i){\n        scanf(\"%d\", &h[i]);\n        c[i + 1] = h[i];\n    }\n    std::sort(c, c + n + 1);\n    int cnt = std::unique(c, c + n) - c;\n    for (int i = cnt - 1; i >= 0; -- i){\n        if (c[i] > h[0]){\n            continue;\n        }\n        dp[0][i] = powermod(2, std::min(h[0] - c[i] + 1, h[0]));\n    }\n    for (int i = 0; i < cnt; ++ i){\n        dp[0][i] -= dp[0][i + 1];\n        dp[0][i] += dp[0][i] < 0 ? moder : 0;\n    }\n    for (int i = 1; i < n; ++ i){\n        dp[i][0] = 1ll * powermod(2, h[i] - h[i - 1]) * dp[i - 1][0] % moder;\n        int sit = std::lower_bound(c, c + cnt, h[i]) - c;\n        for (int j = 1; j < N; ++ j){\n            if (c[j] > h[i - 1]) break;\n            if (c[j] == h[i - 1] && h[i - 1] < h[i]){\n                for (int k = cnt - 1; k >= j; -- k){\n                    if (c[k] > h[i]) continue;\n                    dp[i][k] = (dp[i][k] + 1ll * powermod(2, h[i] - c[k] + 1) * dp[i - 1][j]) % moder;\n                    dp[i][k] += dp[i][k] < 0 ? moder : 0;\n                }\n                for (int k = j; k < cnt; ++ k){\n                    dp[i][k] -= dp[i][k + 1];\n                    dp[i][k] += dp[i][k] < 0 ? moder : 0;\n                }\n                continue;\n            }\n            if (c[j] < h[i]){\n                dp[i][j] = (dp[i][j] + 1ll * powermod(2, h[i] - h[i - 1]) * dp[i - 1][j]) % moder;\n            }\n            else{\n                auto &u = dp[i][std::min(j, sit)];\n                u = (u + 2ll * powermod(2, h[i] - h[i - 1]) * dp[i - 1][j]) % moder;\n            }\n        }\n    }\n    int ans = 0;\n    for (int i = 0; i < N; ++ i){\n        ans += dp[n - 1][i];\n        ans -= ans >= moder ? moder : 0;\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof x)\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define fi first\n#define se second\n#define outval(x) cerr<<#x\" = \"<<x<<endl\n#define outtag(x) cerr<<\"-----------------\"#x\"-----------------\\n\"\n#define outarr(a,L,R) cerr<<#a\"[\"<<L<<\"..\"<<R<<\"] = \";\\\n                    For(_x,L,R) cerr<<a[_x]<<\" \";cerr<<endl;\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair <int,int> pii;\nLL read(){\n    LL x=0,f=0;\n    char ch=getchar();\n    while (!isdigit(ch))\n        f=ch=='-',ch=getchar();\n    while (isdigit(ch))\n        x=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n    return f?-x:x;\n}\nconst int N=105,mod=1e9+7,INF=mod+233;\nint Pow(int x,int y){\n\tint ans=1;\n\tfor (;y;y>>=1,x=(LL)x*x%mod)\n\t\tif (y&1)\n\t\t\tans=(LL)ans*x%mod;\n\treturn ans;\n}\nvoid Add(int &x,int y){\n\tif ((x+=y)>=mod)\n\t\tx-=mod;\n}\nvoid Del(int &x,int y){\n\tif ((x-=y)<0)\n\t\tx+=mod;\n}\nint Add(int x){\n\treturn x>=mod?x-mod:x;\n}\nint Del(int x){\n\treturn x<0?x+mod:x;\n}\nint n;\nint a[N];\nint g[N][N],f[N][N];\nvoid dfs(int L,int R,int h){\n\tif (L==R){\n\t\tg[L][R]=Pow(2,a[L]-h);\n\t\tf[L][R]=0;\n//\t\tprintf(\"dfs(%d,%d,%d): \",L,R,h);\n//\t\tprintf(\"g = %d, f = %d\\n\",g[L][R],f[L][R]);\n\t\treturn;\n\t}\n\tint mi=INF;\n\tFor(i,L,R)\n\t\tmi=min(mi,a[i]);\n\tint las=L;\n\tFor(i,L,R){\n\t\tif (a[i]==mi){\n\t\t\tif (las<i){\n\t\t\t\tdfs(las,i-1,mi);\n\t\t\t\tif (las==L){\n\t\t\t\t\tg[L][R]=g[las][i-1];\n\t\t\t\t\tf[L][R]=f[las][i-1];\n\t\t\t\t\tlas=i;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint g0=g[L][R],g1=g[las][i-1];\n\t\t\t\t\tint f0=f[L][R],f1=f[las][i-1];\n\t\t\t\t\tg[L][R]=(LL)g0*g1%mod;\n\t\t\t\t\tf[L][R]=0;\n\t\t\t\t\tAdd(f[L][R],(LL)g0*g1%mod);\n\t\t\t\t\tAdd(f[L][R],(LL)f0*g1*2%mod);\n\t\t\t\t\tAdd(f[L][R],(LL)g0*f1*2%mod);\n\t\t\t\t\tAdd(f[L][R],(LL)f0*f1*2%mod);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdfs(i,i,mi);\n\t\t\tif (las==L){\n\t\t\t\tg[L][R]=g[i][i];\n\t\t\t\tf[L][R]=f[i][i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint g0=g[L][R],g1=g[i][i];\n\t\t\t\tint f0=f[L][R],f1=f[i][i];\n\t\t\t\tg[L][R]=(LL)g0*g1%mod;\n\t\t\t\tf[L][R]=0;\n\t\t\t\tAdd(f[L][R],(LL)g0*g1%mod);\n\t\t\t\tAdd(f[L][R],(LL)f0*g1*2%mod);\n\t\t\t\tAdd(f[L][R],(LL)g0*f1*2%mod);\n\t\t\t\tAdd(f[L][R],(LL)f0*f1*2%mod);\n\t\t\t}\n\t\t\tlas=i+1;\n\t\t}\n\t}\n\tif (las<=R){\n\t\tdfs(las,R,mi);\n\t\tint g0=g[L][R],g1=g[las][R];\n\t\tint f0=f[L][R],f1=f[las][R];\n\t\tg[L][R]=(LL)g0*g1%mod;\n\t\tf[L][R]=0;\n\t\tAdd(f[L][R],(LL)g0*g1%mod);\n\t\tAdd(f[L][R],(LL)f0*g1*2%mod);\n\t\tAdd(f[L][R],(LL)g0*f1*2%mod);\n\t\tAdd(f[L][R],(LL)f0*f1*2%mod);\n\t}\n\tg[L][R]=(LL)g[L][R]*Pow(2,mi-h)%mod;\n//\tprintf(\"dfs(%d,%d,%d): \",L,R,h);\n//\tprintf(\"g = %d, f = %d\\n\",g[L][R],f[L][R]);\n}\nint main(){\n\tn=read();\n\tFor(i,1,n)\n\t\ta[i]=read();\n\tdfs(1,n,1);\n\tint ans=Add(g[1][n]+f[1][n]);\n\tAdd(ans,ans);\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing int64 = long long;\nusing uint64 = unsigned long long;\n\nconst int64 MOD = 1e9 + 7;\n\nconstexpr int MAX_N = 100;\nint64 h[MAX_N];\n\nint64 powMod(int64 a, int64 n)\n{\n    int64 res = 1;\n    a = a % MOD;\n    while (n > 0)\n    {\n        if (n % 2 == 1)\n        {\n            res = (res * a) % MOD;\n        }\n        a = (a * a) % MOD;\n        n >>= 1;\n    }\n    return res;\n}\n\nint times = 0;\n\npair<int64, int64> counting(int l, int r, int offset)\n{\n    if (l == r)\n    {\n        return {1, 0};\n    }\n\n    int64 cnt1 = 1, cnt2 = 1,\n          minHeight = *min_element(h + l, h + r);\n    \n    int rectL = l, x = 0;\n    for (int i = l; i < r; i++)\n    {\n        if (h[i] == minHeight)\n        {\n            auto cres = counting(rectL, i, minHeight);\n\n            cnt1 = (cnt1 * cres.first) % MOD;\n            cnt2 = (cnt2 * (cres.first + cres.second)) % MOD;\n\n            rectL = i + 1;\n            x++;    // 上に乗っかっていない\n        }\n    }\n    auto cres = counting(rectL, r, minHeight);\n\n    cnt1 = (cnt1 * cres.first) % MOD;\n    cnt2 = (cnt2 * (cres.first + cres.second)) % MOD;\n\n    int height = minHeight - offset;\n    cnt2 = (powMod(2, x) * cnt2 % MOD + cnt1 * ((powMod(2, height) + MOD - 2) % MOD)) % MOD;\n    cnt1 = powMod(2, height) * cnt1 % MOD;\n\n    return {cnt1, cnt2};\n}\n\nint main()\n{\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n\n    int N;\n    cin >> N;\n\n    for (int i = 0; i < N; i++)\n    {\n        cin >> h[i];\n    }\n\n    cout << counting(0, N, 0).second << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//https://atcoder.jp/contests/agc026/tasks/agc026_d\n#include<iostream>\n#include<vector>\n#include<cassert>\n#include<algorithm>\n\nint f[100][101][101][2]; // [h,l,r,alt]\n\nint constexpr MOD=1000000007;\nint constexpr INV2=(MOD+1)/2;\n\nint pow2(int exp){\n\tassert(exp>=0);\n\tint base=2,ans=1;\n\twhile(true){\n\t\tif(exp&1)ans=ans*(int64_t)base%MOD;\n\t\texp>>=1;if(exp==0)return ans;\n\t\tbase=base*(int64_t)base%MOD;\n\t}\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(0);std::cin.tie(0);\n\tint n;std::cin>>n;\n\tstd::vector<int> a(n);for(int& x:a)std::cin>>x;\n\n\tauto vals=a;std::sort(begin(vals),end(vals));\n\tvals.erase(std::unique(begin(vals),end(vals)),end(vals));\n\tfor(int& x:vals)x-=1;\n\n\tfor(int hi=vals.size();hi--;){\n\t\tint const h=vals[hi];\n\t\tf[hi][n][n][0]=0;\n\t\tf[hi][n][n][1]=1;\n\t\tfor(int l=n;l--;){\n\t\t\tf[hi][l][l][0]=0;\n\t\t\tf[hi][l][l][1]=1;\n\n\t\t\tint min_lr=a[l];\n\t\t\tif(min_lr<=h)\n\t\t\t\tcontinue;\n\n\t\t\tint hp=-1; // any index with height == h+1, or -1\n\t\t\tif(a[l]==h+1)hp=l;\n\n\t\t\tf[hi][l][l+1][0]=0;\n\t\t\tf[hi][l][l+1][1]=pow2(a[l]-h);\n\n\t\t\tfor(int r=l+2;r<=n;++r){\n\t\t\t\tmin_lr=std::min(min_lr,a[r-1]);\n\t\t\t\tif(min_lr<=h)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif(a[r-1]==h+1)hp=r-1;\n\n\t\t\t\tif(hp>=0){\n\t\t\t\t\tassert(f[hi][hp][hp+1][1]==2);\n\t\t\t\t\tif(hp!=l&&hp!=r-1)\n\t\t\t\t\t\tf[hi][l][r][1]=f[hi][l][hp][1]*(int64_t)f[hi][hp+1][r][1]\n\t\t\t\t\t\t\t%MOD*INV2%MOD;\n\t\t\t\t\telse\n\t\t\t\t\t\tf[hi][l][r][1]=f[hi][l][hp][1]*(int64_t)f[hi][hp+1][r][1]\n\t\t\t\t\t\t\t%MOD;\n\n\t\t\t\t\tassert(f[hi][hp][hp+1][0]==0);\n\t\t\t\t\tf[hi][l][r][0]=\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\t2LL\n\t\t\t\t\t\t\t*\n\t\t\t\t\t\t\t(f[hi][l][hp][0]+f[hi][l][hp][1])\n\t\t\t\t\t\t\t*\n\t\t\t\t\t\t\t(f[hi][hp+1][r][0]+f[hi][hp+1][r][1])\n\t\t\t\t\t\t\t+MOD-f[hi][l][r][1]\n\t\t\t\t\t\t)%MOD;\n\n\t\t\t\t}else{\n\t\t\t\t\tassert(hi!=vals.size()-1);\n\t\t\t\t\tint const nexthi=hi+1;\n\t\t\t\t\tint const nexth=vals[nexthi];\n\t\t\t\t\tf[hi][l][r][0]=f[nexthi][l][r][0];\n\t\t\t\t\tf[hi][l][r][1]=f[nexthi][l][r][1]*(int64_t)pow2(nexth-h)%MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint h0=vals[0];\n\tstd::cout<<(f[0][0][n][0]+f[0][0][n][1]*(int64_t)pow2(h0))%MOD<<'\\n';\n}\n\n\n/*\n\ngiven config A:\n| ........... |\nn of way to fill the row below (assume rect.)\n1 (just flip the last col) if any 2 cons. id\n2 (flip or keep) if alternate\n\nconsider top down\n\nf[l,r,h,0|1] = num of way to fill [l..r[ with h first lay cut of (alternative?)\n(assume all are > h)\n1: must alternate\n0: must not alternate\n\nans = sum f[0,n,0,all]\n\nBASE CASE\n\nlet f[x,x,_,1] = 1 // len <= 1 : alternative\nlet f[x,x,_,0] = 0\nlet f[x,x+1,_,0] = 0\nlet f[x,x+1,h,1] = 2^(h[x]-h) (h[x]-h>0)\n\n\nf[l,r,h,0] = f[l,r,h+1,0] if valid\nf[l,r,h,1] = 2*f[l,r,h+1,1] if valid\n\nif f[l,r,h+1,_] is not valid\nthen there is i in [l..r[ such that h[i]==h\nconsider f[l,i], f[i,i+1] and f[i+1,r]\nf[l,r,h,1] = f[l,i,h,1] * f[i,r,h,1] / 2\nf[l,r,h,0] = \nf[l,i,h,sum] * f[i,i+1,h,sum] * f[i+1,r,h,sum] - f[l,r,h,1]\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nconst ll mod=1e9+7;\nusing namespace std;\nll N;\nll f[1100][1100],g[1100];\nll a[1100],H[1100],lisan[1100],lcnt;\nll &ml=lcnt;\nll ans;\nll qpow(ll a,ll b) {\n    ll ans=1;\n    for(;b;b>>=1,a=(a*a)%mod) if(b&1) ans=(ans*a)%mod;\n    return ans;\n}\n\nint main() {\n    //cerr<<qpow(2,0)<<endl;\n    scanf(\"%lld\",&N);\n    for(int i=1;i<=N;++i) scanf(\"%lld\",a+i),lisan[i]=a[i];\n    sort(lisan+1,lisan+N+1);\n    lcnt=unique(lisan+1,lisan+N+1)-lisan-1;\n    for(int i=1;i<=N;++i) H[i]=lower_bound(lisan+1,lisan+lcnt+1,a[i])-lisan;\n    //for(int i=1;i<=N;++i) printf(\"H[%d]=%lld\\n\",i,H[i]);\n    g[1]=2;\n    for(int i=1;i<=H[1];++i) f[1][i]=qpow(2,a[1]-lisan[i])*(qpow(2,lisan[i])-2);//,tt(1,i);\n    for(int i=H[1]+1;i<=ml;++i) f[1][i]=f[1][i-1];//,tt(1,i);\n    for(int i=2;i<=N;++i) {\n        for(int j=1;j<=H[i];++j) {\n            f[i][j]+=f[i-1][j]%mod*qpow(2,max(0ll,a[i]-a[i-1]))%mod;\n            f[i][j]%=mod;\n            if(j>H[i-1]) {\n                f[i][j]+=2*g[i-1]%mod*qpow(2,a[i]-lisan[j])%mod*(qpow(2,lisan[j]-a[i-1])-1)%mod;\n                f[i][j]%=mod;\n            }\n            //tt(i,j);\n        }\n        for(int j=H[i]+1;j<=ml;++j) f[i][j]=f[i][j-1];\n        if(H[i-1]<=H[i]) g[i]=g[i-1]*2%mod;\n        else g[i]=(g[i-1]*2%mod+(f[i-1][H[i-1]]-f[i-1][H[i]]+mod)*2%mod)%mod;\n        g[i]=(g[i]%mod+mod)%mod;\n        //printf(\"g[%d]=%lld\\n\",i,g[i]);\n    }\n    ans=(g[N]+f[N][ml])%mod;\n    //printf(\"ans=%lld\\n\",ans);\n    printf(\"%lld\\n\",ans%mod);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 1000000007;\nconst int inv2 = MOD - MOD/2;\n\nlong long modPow(long long a, long long p){\n    if(p == 0) return 1;\n    auto res = modPow(a, p/2);\n    res = (res * res) % MOD;\n    if(p%2 == 1) res = (res * a) % MOD;\n    return res;\n}\n\npair<long long, long long> solve(const vector<int>& h, int begin, int end, int curH){\n    int lowest = 1 << 30, highest = curH;\n    for(int i=begin;i<end;i++){\n        lowest = min(lowest, h[i]);\n        highest = max(highest, h[i]);\n    }\n    if(lowest == highest){\n        return make_pair(modPow(2, lowest - curH), (modPow(2, end - begin) + MOD - 2) % MOD);\n    }\n    long long all = 1;\n    long long one = 1;\n    int last = -1;\n    int cnt = 0;\n    for(int i=begin;i<=end;i++){\n        if(i == end || h[i] == lowest){\n            if(i < end) ++cnt;\n            if(last != -1){\n                auto p = solve(h, last, i, lowest);\n                all = (all * (2 * p.first + p.second)) % MOD;\n                one = (one * p.first) % MOD;\n                last = -1;\n            }\n        } else {\n            if(last == -1) last = i;\n        }\n    }\n    one = (2 * one) % MOD;\n    all = (all * modPow(2, cnt)) % MOD;\n    all = (all + MOD - one) % MOD;\n    one = (one * modPow(2, lowest - curH - 1)) % MOD;\n    return make_pair(one, all);\n}\n\nint main(){\n    int N; cin >> N;\n    vector<int> h(N);\n    for(auto& t : h) cin >> t;\n    auto res = solve(h, 0, N, 0);\n    cout << (res.first + res.second) % MOD << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma G++ optimize(2)\n#pragma GCC optimize(2)\n#include<bits/stdc++.h>\n#define LL long long\n#define O4 __inline__ __attribute__((always_inline))\n#define inf 0x7fffffff\n#define UL unsigned LL\n#define LD long double\n#ifdef ONLINE_JUDGE\n#define getchar nc\n#endif\n//#define int LL\nnamespace FastIO{\n\tO4 char nc(){\n\t\tstatic char buf[100000],*p1=buf,*p2=buf;\n\t\treturn p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n\t}\n\tO4 int read(){\n\t\tchar t;int u=0,k=1;t=getchar();\n\t\twhile(t<'0'||t>'9'){if(t=='-')k=-1;t=getchar();}\n\t\twhile(t>='0'&&t<='9'){u=u*10+t-'0';t=getchar();}\n\t\treturn u*k;\n\t}\n\ttemplate <typename T>\n\tO4 void read(T &u){\n\t\tchar t;T k=1;u=0;t=getchar();\n\t\twhile(t<'0'||t>'9'){if(t=='-')k=-1;t=getchar();}\n\t\twhile(t>='0'&&t<='9'){u=u*10+t-'0';t=getchar();}\n\t\tif(t=='.'){\n\t\t\tT mass=0.1;t=getchar();\n\t\t\twhile(t>='0'&&t<='9'){u+=mass*(t-'0');mass/=10;t=getchar();}\n\t\t}u*=k;\n\t}\n\tO4 int read(char asd[]){\n\t\tchar t=getchar();int u=0;\n\t\twhile(t==' '||t=='\\n'||t=='\\r')t=getchar();\n\t\twhile(t!=' '&&t!='\\n'&&t!=EOF&&t!='\\r')asd[u++]=t,t=getchar();\n\t\tasd[u]='\\0';return u;\n\t}\n\tchar sr[1<<23],z[23];int C=-1,Z;\n\tO4 void wer(int x,char T){\n\t\tint y=0;if(x<0)y=1,x=-x;\n\t\twhile(z[++Z]=x%10+'0',x/=10);if(y)z[++Z]='-';\n\t\twhile(sr[++C]=z[Z],--Z);sr[++C]=T;\n\t}\n\tO4 void wer(char T[],char QWQ){\n\t\tfor(int i=0;T[i]!='\\0';i++)sr[++C]=T[i];\n\t\tsr[++C]=QWQ;\n\t}\n\tO4 void out(){fwrite(sr,1,C+1,stdout);C=-1;}\n}\nusing namespace std;\nusing namespace FastIO;\nconst int N=1e5+5,MOD=1e9+7;\nint n,m,a,b,c,d,e,limit,k;\nint val[N];struct oath{int F,G;};\n//F 黑白相間\tG 普通 \nO4 int KSM(int a,int b=MOD){\n\tint res=1;\n\twhile(b){\n\t\tif(b&1)res=1ll*res*a%MOD;\n\t\ta=1ll*a*a%MOD;b>>=1;\n\t}return res;\n}\noath DFS(int L,int R,int las,int dp){\n\tint mi=1e9+5,sum=0;\n\toath now={1,1},TP;\n\tfor(int i=L;i<=R;i++){\n\t\tif(mi==val[i])sum++;\n\t\tif(val[i]<mi)sum=1,mi=val[i];\n\t}\n\tif(sum==R-L+1){\n\t\tnow.F=KSM(2,mi-las);\n\t\tnow.G=KSM(2,sum)-2;\n\t\treturn now;\n\t}\n\tfor(int ql=L,qr;ql<=R;ql=qr+1){\n\t\twhile(ql<=R&&val[ql]==mi)ql++;\n\t\tif(ql==R+1)break;\n\t\tqr=ql;while(qr<R&&val[qr+1]>mi)qr++;\n\t\tif(ql==L&&qr==R){\n\t\t\tfor(int i=L;i<=R;i++)if(val[i]==mi)while(1);\n\t\t\texit(233);\n\t\t}\n\t\tTP=DFS(ql,qr,mi,dp+1);\n\t\tnow.F=1ll*TP.F*now.F%MOD;\n\t\tnow.G=1ll*(TP.F*2%MOD+TP.G)%MOD*now.G%MOD;\n\t}\n\tnow.G=1ll*now.G*KSM(2,sum)%MOD;\n\t(now.G-=now.F*2%MOD)%=MOD;\n\tnow.F=1ll*now.F*KSM(2,mi-las)%MOD;\n\treturn now;\n}\nsigned main(){\n\tn=read();\n\tfor(int i=1;i<=n;i++)val[i]=read();\n\toath Ans=DFS(1,n,0,1);\n\tcout<<((Ans.F+Ans.G)%MOD+MOD)%MOD;\n\treturn out(),0;\n}\n/*\n6\n1 1 4 5 1 4\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<set>\n#include<unordered_map>\n#define lol(i,n) for(ll i=0;i<n;i++)\n#define mod 1000000007\n#define mul(a,b) a=(a*b)%mod;\ntypedef long long ll;\n\nusing namespace std;\nll po(ll x){\n    ll res=1;\n    for(ll y=2;x;x>>=1,y=y*y%mod){\n\tif(x&1)res=res*y%mod;\n    }\n    return res;\n}\nll mo(ll x){\n    x%=mod;\n    if(x<0)x+=mod;\n    return x;\n}\ntypedef pair<ll,ll> P;\n#define N 110\nvector<ll> v[N];\nll n,f[N],g[N],l[N],r[N],w[N],u[N],h[N],m;\nll ans;\nvoid func(ll x){\n    ll len=r[x]-l[x]-1;\n    if(len==1){\n\tmul(ans,po(w[x]));\n\tf[x]=g[x]=0;\n\treturn;\n    }\n    ll fm=1,gm=1,sum=0;\n    for(auto c:v[x]){\n\tfunc(c);\n\tif(r[c]-l[c]-1==1)continue;\n\tsum+=r[c]-l[c]-1;\n\tfm=mo(fm*f[c]);\n\tgm=mo(gm*(2*f[c]+g[c]));\n\t//cout<<2*f[c]+g[c]<<\":\"<<gm<<\" \";\n    }\n    if(sum==0){\n\tf[x]=mo(po(w[x]));\n\tg[x]=mo(po(len)-2);\n\treturn;\n    }\n    //cout<<\"#\"<<x<<\" \"<<fm<<\" \"<<gm<<endl;\n    f[x]=mo(fm*po(w[x]));\n    g[x]=mo(gm*po(len-sum));\n    g[x]=mo(g[x]-2*fm);\n}\nint main(){\n    cin>>n;\n    lol(i,n)cin>>h[i];\n    unordered_map<ll,vector<ll> >mas;\n    lol(i,n){\n\tmas[h[i]].push_back(i);\n    }\n    sort(h,h+n);\n    set<ll> st; st.insert(-1); st.insert(n);\n    m=1,l[0]=-1,r[0]=n,w[0]=u[0]=h[0];\n    lol(i,n){\n\tif(i&&h[i-1]==h[i])continue;\n\tfor(auto x:mas[h[i]]){\n\t    auto il=st.lower_bound(x); il--;\n\t    ll L=*il;\n\t    auto ir=st.upper_bound(x);\n\t    ll R=*ir;\n\t    if(l[m-1]==L&&r[m-1]==R)continue;\n\t    l[m]=L,r[m]=R,u[m]=w[m]=h[i],m++;\n\t}\n\tfor(auto x:mas[h[i]])st.insert(x);\n    }\n    lol(i,m){\n\tfor(ll j=i-1;~j;j--){\n\t    if(l[j]<=l[i]&&r[i]<=r[j]){\n\t\tv[j].push_back(i);\n\t\tw[i]=u[i]-u[j];\n\t\tbreak;\n\t    }\n\t}\n    }\n    ans=1;\n    func(0);\n    cout<<mo(ans*(f[0]+g[0]))<<endl;\n    /*\n    lol(i,m){\n\tcout<<i<<\":\"<<l[i]+1<<\" \"<<r[i]-1<<\" \"<<w[i]<<endl;\n\tcout<<\"f=\"<<f[i]<<\" g=\"<<g[i]<<endl;\n\tfor(auto x:v[i])cout<<x<<\" \";cout<<endl;\n    }*/\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define XX first\n#define YY second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define REP rep\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\nconst ll MOD=1e9+7;\n\n#define rall(X) (X).rbegin(),(X).rend()\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n\ntemplate<ll mod>\nstruct ModInt{\n  using M=ModInt;\n  ll a;\n  M& put(ll v){\n    a=(v<mod)?v:v-mod;\n    return *this;\n  }\n  ModInt(ll v=0){put(v%mod+mod);}\n  M operator+(M x){return M().put(a+x.a);}\n  M operator-(M x){return M().put(a+mod-x.a);}\n  M operator*(M x){return M().put(a*x.a%mod);}\n  M operator/(M x){return *this*x.inv();}\n  M& operator+=(M x){return *this=*this+x;};\n  M& operator-=(M x){return *this=*this-x;};\n  M& operator*=(M x){return *this=*this*x;};\n  M& operator/=(M x){return *this=*this/x;};\n  bool operator==(M x){return a==x.a;}\n\n  M pow(ll m){\n    M x=*this,res=1;\n    while(m){\n      if(m&1)res*=x;\n      x*=x;\n      m>>=1;\n    }\n    return res;\n  }\n  M inv(){return pow(mod-2);}\n};\n\nusing Int = ModInt<MOD>;\n\nint N;\nvector<LL> hs;\nInt fact = 1;\n\nstruct Val {\n  Int dp1;\n  Int dp2;\n};\n\nstruct Val Calc(vector<LL> &hs) {\n  if (hs.size() == 1) {\n    fact *= Int(2).pow(hs[0]);\n    return Val{1, 1};\n  }\n\n  LL mh = 1LL << 40;\n  for (LL h : hs) {\n    MN(mh, h);\n  }\n\n  struct Val ret = {1, 1};\n  vector<LL> vec;\n  if (mh == 1) {\n    for (LL h : hs) {\n      if (h == 1) {\n        if (vec.size()) {\n          auto res = Calc(vec);\n          ret.dp1 *= res.dp1;\n          ret.dp2 *= res.dp2;\n          if (vec.size() == 1) {\n            ret.dp2 *= 2;\n            fact /= 2;\n          }\n        }\n        vec.clear();\n        ret.dp2 *= 2;\n      } else {\n        assert(h >= 2);\n        vec.eb(h);\n      }\n    }\n\n    if (vec.size()) {\n      auto res = Calc(vec);\n      ret.dp1 *= res.dp1;\n      ret.dp2 *= res.dp2;\n      if (vec.size() == 1) {\n        ret.dp2 *= 2;\n        fact /= 2;\n      }\n    }\n    //cout << ret.dp1.a << \", \" << ret.dp2.a << endl;\n    return ret;\n  }\n  \n  int w = 0;\n  for (LL h : hs) {\n    h -= mh;\n    if (h > 0) {\n      vec.eb(h);\n    } else {\n      ++w;\n      assert(h == 0);\n      if (vec.size()) {\n        auto res = Calc(vec);\n        ret.dp1 *= res.dp1;\n        ret.dp2 *= res.dp2;\n        if (vec.size() == 1) ++w;\n      }\n      vec.clear();\n    }\n  }\n\n  if (vec.size()) {\n    auto res = Calc(vec);\n    ret.dp1 *= res.dp1;\n    ret.dp2 *= res.dp2;\n    if (vec.size() == 1) ++w;\n  }\n\n  if (w == hs.size()) {\n    ret = Val{Int(2).pow(mh-1)*ret.dp2, (Int(2).pow(mh) + Int(2).pow(w) - 2)*ret.dp2};\n    //cout << ret.dp1.a << \", \" << ret.dp2.a << endl;\n    return ret;\n  }\n\n  //cout << \"w: \" << w << endl;\n  Int g = Int(2).pow(w);\n  ret.dp2 *= g;\n  //cout << ret.dp1.a << \", \" << ret.dp2.a << endl;\n  Int t = Int(2).pow(mh);\n  ret.dp2 += ret.dp1 * (t+g-2) * 2;\n  ret.dp1 *= t;\n  //cout << ret.dp1.a << \", \" << ret.dp2.a << endl;\n  return ret;\n}\n\nsigned main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n  cin >> N;\n  rep(i, N) {\n    LL h;\n    cin >> h;\n    hs.eb(h);\n  }\n  cout << (fact*Calc(hs).dp2).a << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing pll = pair<ll,ll>;\n#define f(i,a,b) for (int i = a; i < b; i++)\n#define pb push_back\n#define Min(a,b) a=min(a,b)\n\nconst int mod = 1e9+7;\n\nll modpow(ll a, ll b) {\n\treturn b?modpow(a*a%mod,b/2)*(b&1?a:1)%mod:1;\n}\n\npll solve(vi ds) {\n\tint x = mod;\n\tf(i,0,ds.size()) Min(x,ds[i]);\n\tint w = 0;\n\tll a = 1, b = 1;\n\tvi nxt;\n\tf(i,0,ds.size()) if (x == ds[i]) {\n\t\tif (nxt.size()) {\n\t\t\tpll sol = solve(nxt);\n\t\t\ta = a*sol.first%mod;\n\t\t\tb = b*((sol.first+sol.second)%mod)%mod;\n\t\t\tnxt = vi();\n\t\t}\n\t\tw++;\t\n\t} else nxt.pb(ds[i]-x);\n\tif (nxt.size()) {\n\t\tpll sol = solve(nxt);\n\t\ta = a*sol.first%mod;\n\t\tb = b*((sol.first+sol.second)%mod)%mod;\n\t}\n\treturn pll(a*modpow(2,x)%mod,\n\t\t(b*modpow(2,w)%mod+(modpow(2,x)+mod-2)*a%mod)%mod);\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n#ifdef LOCAL\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n\tclock_t start = clock();\n#endif\n\n\tint n;\n\tcin>>n;\n\tvi ds(n);\n\tf(i,0,n) cin>>ds[i];\n\tcout << solve(ds).second << endl;\n\n#ifdef LOCAL\n\tcout << setprecision(12) << (long double)(clock()-start) / CLOCKS_PER_SEC << endl;\n#endif\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n\nconst int N = 1e6 + 10;\nconst int mod = 1e9 + 7;\nint h[N], st[N], top, n, ls[N], rs[N], root, f[N][2], num[N], single[N], mulsingle[N], rev[N], coe[N];\nbool bsin[N];\n\ninline void build()\n{\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tint k = top;\n\t\twhile (k > 0 && h[st[k]] > h[i]) k--;\n\t\tif (k) rs[st[k]] = i;\n\t\tif (k < top) ls[i] = st[k + 1];\n\t\tst[++k] = i;\n\t\ttop = k;\n\t}\n\troot = st[1];\n}\n\nvoid dfs(int x)\n{\n\tif (!x) return;\n\tcout << \"x \" << x << endl;\n\tdfs(ls[x]), dfs(rs[x]);\n}\n\ninline int fp(int a, int n)\n{\n\tint res = 1;\n\twhile (n)\n\t{\n\t\tif (n & 1) res = (res * a) % mod;\n\t\ta = (a * a) % mod;\n\t\tn >>= 1;\n\t}\n\treturn res % mod;\n}\n\ninline void fill(int *a, int siz, int val)\n{\n\tfor (int i = 1; i <= siz; i++)\ta[i] = val;\n}\n\ninline void dp(int x, int fa)\n{\n\tif (!x) return;\n\tnum[x] = 1;\n\trev[x] = 1;\n\tcoe[x] = 1;\n\tint height = h[x] - h[fa];\n\t// if (!rs[x] && !ls[x] && h[x] != h[fa])\n\t// {\n\t// \tsingle[x] = 1;\n\t// \tmulsingle[x] *= fp(2, height);\n\t// \treturn;\n\t// }\n\tif (!rs[x] && !ls[x] && h[x] == h[fa])\n\t\treturn;\n\tdp(ls[x], x);\n\tdp(rs[x], x);\n\t// if (ls[x] && x - ls[x] == 1) rev[x] += single[ls[x]];\n\t// if (rs[x] && rs[x] - x == 1) rev[x] += single[rs[x]];\n\t// if (ls[x]) mulsingle[x] *= mulsingle[ls[x]];\n\t// if (rs[x]) mulsingle[x] *= mulsingle[rs[x]]; \n\tif (ls[x] && h[ls[x]] == h[x]) rev[x] += rev[ls[x]], coe[x] = (coe[ls[x]] * coe[x]) % mod;\n\tif (rs[x] && h[rs[x]] == h[x]) rev[x] += rev[rs[x]], coe[x] = (coe[rs[x]] * coe[x]) % mod;\n\tif (f[ls[x]][1] == 0) ls[x] = 0;\n\tif (f[rs[x]][1] == 0) rs[x] = 0;\n\tif (h[x] != h[fa]) coe[x] = 2;\n\tif (height > 0)\n\t{\n\t\tif (rs[x] && ls[x])\n\t\t{\n\t\t\tf[x][1] = f[rs[x]][1] * f[ls[x]][1] % mod * fp(2, height) % mod;\n\t\t\t// cout << \"fk1 \" << f[rs[x]][1] << ' ' << f[ls[x]][1] << endl;\n\t\t\t// cout << \"fk0 \" << f[rs[x]][0] << ' ' << f[ls[x]][0] << endl;\n\t\t\tf[x][0] = (((f[rs[x]][1] * f[ls[x]][0] % mod * coe[rs[x]] * (fp(2, rev[x])) % mod + f[rs[x]][0] * f[ls[x]][1] % mod * coe[ls[x]] * (fp(2, rev[x])) % mod) % mod + f[rs[x]][0] * f[ls[x]][0] % mod * fp(2, rev[x]) % mod) % mod + f[rs[x]][1] * f[ls[x]][1] % mod * (coe[rs[x]] * coe[ls[x]] * (fp(2, rev[x])) - 2) % mod) % mod;\n\t\t}\n\t\telse if (rs[x])\n\t\t{\n\t\t\tf[x][1] = f[rs[x]][1] * fp(2, height) % mod;\n\t\t\tf[x][0] = (f[rs[x]][0] * fp(2, rev[x]) % mod + f[rs[x]][1] * ( coe[rs[x]] * fp(2, rev[x]) - 2) % mod) % mod;\n\t\t}\n\t\telse if (ls[x])\n\t\t{\n\t\t\tf[x][1] = f[ls[x]][1] * fp(2, height) % mod;\n\t\t\tf[x][0] = (f[ls[x]][0] * fp(2, rev[x]) % mod + f[ls[x]][1] * ( coe[ls[x]] * fp(2, rev[x]) - 2) % mod) % mod;\n\t\t}\n\t\telse \n\t\t{\n\t\t\tf[x][1] = fp(2, height);\n\t\t\tf[x][0] = (fp(2, rev[x]) - 2) % mod;\n\t\t}\n\t}\t\n\telse \n\t{\n\t\tif (rs[x] && ls[x])\n\t\t{\n\t\t\tcoe[x] *= 4;\n\t\t\tf[x][1] = f[rs[x]][1] * f[ls[x]][1] % mod;\n\t\t\tf[x][0] = ((f[rs[x]][0] * f[ls[x]][0] % mod + f[rs[x]][1] * f[ls[x]][0] * coe[rs[x]] % mod) % mod + f[rs[x]][0] * f[ls[x]][1] * coe[ls[x]] % mod) % mod;\n\t\t}\n\t\telse if (rs[x])\n\t\t{\n\t\t\tf[x][1] = f[rs[x]][1];\n\t\t\tf[x][0] = f[rs[x]][0];\n\t\t\tcoe[x] *= 2;\n\t\t}\n\t\telse if (ls[x])\n\t\t{\n\t\t\tf[x][1] = f[ls[x]][1];\n\t\t\tf[x][0] = f[ls[x]][0];\n\t\t\tcoe[x] *= 2;\n\t\t}\n\t}\n\t// cout << \"x \" << x << endl;\n\t// cout << \"f[x][1] \" << f[x][1] << endl;\n\t// cout << \"f[x][0] \" << f[x][0] << endl;\n\t// cout << \"rev[x] \" << rev[x] << endl;\n\tcoe[x] %= mod;\n}\n\nsigned main()\n{\n\tint ml = 0;\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++)\tcin >> h[i];\n\tif (n == 1)\n\t{\n\t\tcout << fp(2, h[1]) << endl;\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tif (h[i] > h[i - 1] && h[i] > h[i + 1]) ml += h[i] - max(h[i - 1], h[i + 1]), h[i] = max(h[i - 1], h[i + 1]);\n\tbuild();\n\tfill(mulsingle, n, 1);\n\tf[0][1] = f[0][0] = 1;\n\tdp(root, 0);\n\t// cout << \"mul \" << fp(2, ml) << endl;\n\tcout << (f[root][1] + f[root][0]) % mod * fp(2, ml) % mod << endl;\n\t// cout << \"1 \" << f[root][1] << endl;\n\t// cout << \"0 \" << f[root][0] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 100, mod = 1e9 + 7;\nint n, a[maxn + 3];\n\nint qpow(int a, int b) {\n\tint c = 1;\n\tfor (; b; b >>= 1, a = 1ll * a * a % mod) {\n\t\tif (b & 1) c = 1ll * a * c % mod;\n\t}\n\treturn c;\n}\n\npair<int, int> solve(int l, int r, int h) {\n\tif (l == r) {\n\t\tint x = qpow(2, a[l] - h);\n\t\treturn make_pair(x, x);\n\t}\n\tint mn = a[l];\n\tfor (int i = l; i <= r; i++) {\n\t\tmn = min(mn, a[i]);\n\t}\n\tint c = 1, t = qpow(2, mn - h);\n\tfor (int i = l; i <= r; i++) {\n\t\tif (a[i] == mn) c = 2ll * c % mod;\n\t}\n\tint x = 1, y = 1;\n\tfor (int i = l, j = l; i <= r; i = j + 1, j = i) {\n\t\tif (a[i] == mn) continue;\n\t\twhile (j < r && a[j + 1] != mn) j++;\n\t\tpair<int, int> t = solve(i, j, mn);\n\t\tx = 1ll * x * (t.first + t.second) % mod;\n\t\ty = 1ll * y * t.first % mod;\n\t}\n\tint p = 1ll * t * y % mod;\n\tint q = (1ll * c * x + 1ll * (t + mod - 2) * y) % mod;\n\treturn make_pair(p, q);\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\tprintf(\"%d\\n\", solve(1, n, 0).second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int, int> pii;\n#define fi first\n#define se second\n#define mp make_pair\n\nconst int MAXN = 100;\nconst int MOD = int(1E9) + 7;\n\ninline int add(int x, int y) {x += y; return x >= MOD ? x - MOD : x;}\ninline int sub(int x, int y) {x -= y; return x < 0 ? x + MOD : x;}\ninline int mul(int x, int y) {return 1LL * x * y % MOD;}\n\nint pow_mod(int b, int p) {\n\tint ret = 1;\n\tfor(int i=p;i;i>>=1,b=mul(b,b))\n\t\tif( i & 1 ) ret = mul(ret, b);\n\treturn ret;\n}\n\nint h[MAXN + 5], N;\npii get(int l, int r, int lh) {\n\tint mn = h[l];\n\tfor(int i=l;i<=r;i++)\n\t\tmn = min(mn, h[i]);\n\t\n\tint lst = l; pii ret = mp(1, 1);\n\tfor(int i=l;i<=r;i++) {\n\t\tif( h[i] == mn ) {\n\t\t\tif( i > lst ) {\n\t\t\t\tpii tmp = get(lst, i - 1, mn);\n\t\t\t\tret.fi = mul(ret.fi, tmp.fi);\n\t\t\t\tret.se = mul(ret.se, add(mul(2, tmp.fi), tmp.se));\n\t\t\t}\n\t\t\tret.se = mul(ret.se, 2);\n\t\t\t\n\t\t\tlst = i + 1;\n\t\t}\n\t}\n\tif( r >= lst ) {\n\t\tpii tmp = get(lst, r, mn);\n\t\tret.fi = mul(ret.fi, tmp.fi);\n\t\tret.se = mul(ret.se, add(mul(2, tmp.fi), tmp.se));\n\t}\n\t\n\treturn mp(mul(ret.fi, pow_mod(2, mn - lh)), sub(ret.se, mul(2, ret.fi)));\n}\n\nint main() {\n\tscanf(\"%d\", &N);\n\tfor(int i=1;i<=N;i++) scanf(\"%d\", &h[i]);\n\t\n\tpii k = get(1, N, 0);\n\tprintf(\"%d\\n\", add(k.fi, k.se));\n}"
  },
  {
    "language": "C++",
    "code": "//teja349\n#include <bits/stdc++.h>\n#include <vector>\n#include <set>\n#include <map>\n#include <string>\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <utility>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <iomanip> \n//setbase - cout << setbase (16); cout << 100 << endl; Prints 64\n//setfill -   cout << setfill ('x') << setw (5); cout << 77 << endl; prints xxx77\n//setprecision - cout << setprecision (14) << f << endl; Prints x.xxxx\n//cout.precision(x)  cout<<fixed<<val;  // prints x digits after decimal in val\n\nusing namespace std;\n#define f(i,a,b) for(i=a;i<b;i++)\n#define rep(i,n) f(i,0,n)\n#define fd(i,a,b) for(i=a;i>=b;i--)\n#define pb push_back\n#define mp make_pair\n#define vi vector< int >\n#define vl vector< ll >\n#define ss second\n#define ff first\n#define ll long long\n#define pii pair< int,int >\n#define pll pair< ll,ll >\n#define sz(a) a.size()\n#define inf (1000*1000*1000+5)\n#define all(a) a.begin(),a.end()\n#define tri pair<int,pii>\n#define vii vector<pii>\n#define vll vector<pll>\n#define viii vector<tri>\n#define mod (1000*1000*1000+7)\n#define pqueue priority_queue< int >\n#define pdqueue priority_queue< int,vi ,greater< int > >\nll perfect[123],dp[123][123],h1[123],h[123],last[123],cur[123];\n//std::ios::sync_with_stdio(false);   \nll powe(ll val){\n\tll ans=1;\n\tll a=2;\n\twhile(val>0){\n\t\tif(val%2){\n\t\t\tans*=a;\n\t\t\tans%=mod;\n\t\t}\n\t\ta*=a;\n\t\ta%=mod;\n\t\tval/=2;\n\t}\n\treturn ans;\n}\nll func(ll n){\n\t // cout<<n<<endl;\n    ll i,j;\n    map<ll,ll> mapi;\n    map<ll,ll>::iterator it;\n    mapi.clear();\n    rep(i,n){\n    \t//cin>>>h[i];\n    \tmapi[h[i]]=0;\n    }\n    ll counter=0;\n    ll previ=0;\n    for(it=mapi.begin();it!=mapi.end();it++){\n    \tlast[counter]=previ;\n    \tcur[counter]=it->ff;\n    \tprevi=it->ff;\n    \tit->ss=counter++;\n    }\n    rep(i,mapi[h[0]]+1){\n    \tif(i==0){\n    \t\tdp[0][i]=(powe(cur[i]-last[i])-2)*powe(h[0]-cur[i]);\n    \t\t\n    \t}\n    \telse{\n    \t\tdp[0][i]=(powe(cur[i]-last[i])-1)*powe(h[0]-cur[i]);\n    \t\tdp[0][i]%=mod;\n    \t\tdp[0][i]*=2;\n\n    \t}\n    \t//cout<<dp[0][i]<<endl;\n    \tdp[0][i]%=mod;\n    \tdp[0][i]+=mod;\n    \tdp[0][i]%=mod;\n\n    }\n    perfect[0]=2;\n    f(i,1,n){\n\n    \trep(j,min(mapi[h[i]],mapi[h[i-1]])+1){\n    \t\tdp[i][j]=dp[i-1][j];\n    \t\tif(h[i-1]<h[i]){\n    \t\t\tdp[i][j]*=powe(h[i]-h[i-1]);\n    \t\t\tdp[i][j]%=mod;\n    \t\t}\n\n    \t}\n    \tperfect[i]=perfect[i-1]*2;\n    \tperfect[i]%=mod;\n    \tf(j,mapi[h[i]]+1,mapi[h[i-1]]+1){\n    \t\tperfect[i]+=dp[i-1][j]*2;\n    \t\tperfect[i]%=mod;\n    \t}\n    \tf(j,mapi[h[i-1]]+1,mapi[h[i]]+1){\n    \t\t//cout<<last[j]<<endl;\n    \t\tdp[i][j] = (powe(cur[j]-last[j])-1)*powe(h[i]-cur[j]);\n    \t\tdp[i][j]%=mod;\n    \t\tdp[i][j]*=perfect[i];\n    \t\tdp[i][j]%=mod;\n    \t}\n\n\n\n    }\n    ll ans=0;\n    rep(j,mapi[h[n-1]]+1){\n    \t//cout<<dp[n-1][j]<<endl;\n    \tans+=dp[n-1][j];\n    \tans%=mod;\n    }\n    //cout<<perfect[n-1]<<endl;\n    ans+=perfect[n-1];\n    ans%=mod;\n    return ans;\n\n\n\n\n    return 0;  \n    \n}\nint main(){\n\tll n;\n\tcin>>n;\n\tll i,j;\n\trep(i,n){\n\t\tcin>>h1[i];\n\t}\n\t//return 0;\n\tll ans=1;\n\tj=0;\n\trep(i,n){\n\t\tif(h1[i]==1){\n\t\t\tans*=2;\n\t\t\tans%=mod;\n\t\t\tif(j!=0){\n\t\t\t\tans*=func(j);\n\t\t\t\tans%=mod;\n\t\t\t}\n\t\t\tj=0;\n\n\t\t}\n\t\telse{\n\t\t\th[j++]=h1[i];\n\t\t}\n\t}\n\tif(j!=0){\n\t\tans*=func(j);\n\t\tans%=mod;\n\t}\n\tans+=mod;\n\tans%=mod;\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\n#include<cassert>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\ntypedef pair<lint,lint> pl;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n//問題文および制約はちゃんと確認しよう！\n//サイズは10^5じゃなくて2×10^5とかかもしれないし、重要な制約・条件を見落としているかも\n//とりあえずサンプルを読んでから解法を考えよう？\nint h[110];\nlint dp[110][110][110][2];\nlint mo=1000000007,m2=(mo+1)/2;\nvector<int> de;\nlint zyo(lint x,lint y){\n    lint ret=1,a=x;\n    while(y>0){\n    \tif(y%2==1) ret=(ret*a)%mo;\n    \ta=(a*a)%mo;y/=2;\n    }\n    return ret;\n}\npl cal(int l,int r,int d){\n\tint mi=114;\n\tREP(i,l,r) mi=min(mi,h[i]);\n\tvector<int> v;v.pb(l-1);\n\tREP(i,l,r){\n\t\tif(h[i]==mi) v.pb(i);\n\t}\n\tv.pb(r);\n\tlint r0=1,r1=1;\n\tif(v.size()==r-l+2){\n\t\tr0*=2;r1*=zyo(2,r-l);r1%=mo;\n\t\tr1-=r0;r1%=mo;r1+=mo;r1%=mo;\n\t}\n\telse{\n\t\tvector<pl> p;\n\t\trep(i,(int)v.size()-1){\n\t\t\tif(v[i+1]>v[i]+1) p.pb(cal(v[i]+1,v[i+1],mi));\n\t\t}\n\t\trep(i,p.size()){\n\t\t\tr0*=p[i].fi;r0%=mo;\n\t\t\tr1*=(p[i].fi*2+p[i].se);r1%=mo;\n\t\t}\n\t\tr0*=2;r0%=mo;\n\t\tr1*=zyo(2,v.size()-2);r1%=mo;\n\t\tr1-=r0;r1%=mo;r1+=mo;r1%=mo;\n\t}\n\t//cout<<l<<' '<<r<<' '<<d<<' '<<r0<<' '<<r1<<endl;\n\tdp[l][r][d][0]=r0*zyo(2,de[mi]-de[d]-1);dp[l][r][d][0]%=mo;\n\tdp[l][r][d][1]=r1;\n\treturn mp(dp[l][r][d][0],dp[l][r][d][1]);\n}\nint main()\n{\n\tint n;lint ba=1,out=0;\n\tcin>>n;\n\trep(i,n){\n\t\tcin>>h[i];//de.pb(h[i]);\n\t}\n\tif(n==1){\n\t\tcout<<zyo(2,h[0])<<endl;return 0;\n\t}\n\tif(h[0]>h[1]){\n\t\tba*=zyo(2,h[0]-h[1]);h[0]=h[1];ba%=mo;\n\t}\n\tif(h[n-1]>h[n-2]){\n\t\tba*=zyo(2,h[n-1]-h[n-2]);h[n-1]=h[n-2];ba%=mo;\n\t}\n\tREP(i,1,n-1){\n\t\tint t=max(h[i-1],h[i+1]);\n\t\tif(h[i]>t){\n\t\t\tba*=zyo(2,h[i]-t);h[i]=t;ba%=mo;\n\t\t}\n\t}\n\t//cout<<ba<<endl;\n\t//rep(i,n) cout<<h[i]<<' ';cout<<endl;\n\trep(i,n) de.pb(h[i]);\n\tde.pb(0);sort(All(de));de.erase(unique(All(de)));\n\trep(i,n) h[i]=lower_bound(All(de),h[i])-de.begin();\n\tmemset(dp,-1,sizeof(dp));\n\tcal(0,n,0);\n\tout=(dp[0][n][0][0]+dp[0][n][0][1])*ba;\n\tcout<<out%mo<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) (x = max(x,y))\n#define mins(x,y) (x = min(x,y))\n#define limit(x,l,r) max(l,min(x,r))\n#define lims(x,l,r) (x = max(l,min(x,r)))\n#define isin(x,l,r) ((l) <= (x) && (x) < (r))\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcountll\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,v(T),greater<T> >\n#define bn(x) ((1<<x)-1)\n#define dup(x,y) (((x)+(y)-1)/(y))\n#define newline puts(\"\")\n#define v(T) vector<T>\n#define vv(T) v(v(T))\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ntemplate<typename T>inline istream& operator>>(istream&i,v(T)&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(const v(T)&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>inline ostream& operator<<(ostream&o,const v(T)&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>inline istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>inline ostream& operator<<(ostream&o,const pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\ntemplate<typename T>inline ll suma(const v(T)& a) { ll res(0); for (auto&& x : a) res += x; return res;}\nconst double eps = 1e-10;\nconst ll LINF = 1001002003004005006ll;\nconst int INF = 1001001001;\n#define dame { puts(\"-1\"); return 0;}\n#define yn {puts(\"YES\");}else{puts(\"NO\");}\nconst int MX = 200005;\n\n// Union find\nstruct uf {\n  vi d;\n  uf(){}\n  uf(int mx):d(mx,-1){}\n  int root(int x) {\n    if(d[x] < 0) return x;\n    return d[x] = root(d[x]);\n  }\n  bool unite(int x, int y) {\n    x = root(x); y = root(y);\n    if(x == y) return false;\n    if(d[x] > d[y]) swap(x,y);\n    d[x] += d[y]; d[y] = x;\n    return true;\n  }\n  int size(int x) { return -d[root(x)];}\n};\n//\n\n// Mod int\nconst int mod = 1000000007;\nstruct mint {\n  ll x;\n  mint():x(0){}\n  mint(ll x):x((x%mod+mod)%mod){}\n  // mint(ll x):x(x){}\n  mint& fix() { x = (x%mod+mod)%mod; return *this;}\n  mint operator-() const { return mint(0) - *this;}\n  mint& operator+=(const mint& a){ if((x+=a.x)>=mod) x-=mod; return *this;}\n  mint& operator-=(const mint& a){ if((x+=mod-a.x)>=mod) x-=mod; return *this;}\n  mint& operator*=(const mint& a){ (x*=a.x)%=mod; return *this;}\n  mint& operator/=(const mint& a){ (x*=a.ex(mod-2).x)%=mod; return *this;}\n  mint operator+(const mint& a)const{ return mint(*this) += a;}\n  mint operator-(const mint& a)const{ return mint(*this) -= a;}\n  mint operator*(const mint& a)const{ return mint(*this) *= a;}\n  mint operator/(const mint& a)const{ return mint(*this) /= a;}\n  mint ex(ll t) const {\n    if(!t) return 1;\n    mint res = ex(t/2);\n    res *= res;\n    return (t&1)?res*x:res;\n  }\n  bool operator<(const mint& a)const{ return x < a.x;}\n  bool operator==(const mint& a)const{ return x == a.x;}\n};\nmint ex(mint x, ll t) { return x.ex(t);}\nistream& operator>>(istream&i,mint&a){i>>a.x;return i;}\nostream& operator<<(ostream&o,const mint&a){o<<a.x;return o;}\ntypedef vector<mint> vm;\nstruct comb {\n  vm f, g;\n  comb(){}\n  comb(int mx):f(mx+1),g(mx+1) {\n    f[0] = 1;\n    rrep(i,mx) f[i] = f[i-1]*i;\n    g[mx] = f[mx].ex(mod-2);\n    for(int i=mx;i>0;i--) g[i-1] = g[i]*i;\n  }\n  mint c(int a, int b) {\n    if (a < b) return 0;\n    return f[a]*g[b]*g[a-b];\n  }\n};\n//\n\nvi conv(vi a) {\n  int n = sz(a);\n  rep(i,n) a[i]--;\n  vi res;\n  rep(i,n-1) {\n    res.pb(min(a[i],a[i+1]));\n  }\n  return res;\n}\nmint f(vi a) {\n  int n = sz(a);\n  // cerr<<a<<endl;\n  vp p(n);\n  rep(i,n) p[i] = P(a[i],i);\n  sort(rng(p)); reverse(rng(p));\n  vi gid(n,-1);\n  uf t(n);\n  vi used;\n  vp g;\n  vvi to;\n  for (int i = 0; i < n;) {\n    int si = i;\n    int now = p[si].fi;\n    vvi chi;\n    while (i < n && p[i].fi == now) {\n      chi.pb(vi());\n      int j = p[i].se;\n      if (j && gid[t.root(j-1)] != -1) {\n        int gi = gid[t.root(j-1)];\n        t.unite(j,j-1);\n        if (!used[gi]) {\n          chi.back().pb(gi);\n          used[gi] = 1;\n          g[gi].se -= now;\n        }\n      }\n      if (j+1 < n && gid[t.root(j+1)] != -1) {\n        int gi = gid[t.root(j+1)];\n        t.unite(j,j+1);\n        if (!used[gi]) {\n          chi.back().pb(gi);\n          used[gi] = 1;\n          g[gi].se -= now;\n        }\n      }\n      if (j && a[j-1] == now) {\n        t.unite(j,j-1);\n      }\n      if (j+1 < n && a[j+1] == now) {\n        t.unite(j,j+1);\n      }\n      ++i;\n    }\n    vi js;\n    srep(pi,si,i) {\n      int j = p[pi].se;\n      js.pb(t.root(j));\n    }\n    sort(rng(js)); uni(js);\n    for (int j : js) {\n      gid[j] = sz(used);\n      used.pb(0);\n      g.pb(P(t.size(j),now));\n      to.pb(vi());\n    }\n    srep(pi,si,i) {\n      int j = p[pi].se;\n      int gi = gid[t.root(j)];\n      for (int u : chi[pi-si]) to[gi].pb(u);\n    }\n  }\n  mint res;\n  int m = sz(g);\n  // cerr<<\"G \"<<g<<endl;\n  // rep(i,m) cerr<<to[i]<<endl;\n  vm d1(m), d2(m);\n  rep(i,m) {\n    mint two = ex(2,g[i].se);\n    d1[i] = two;\n    int r = g[i].fi;\n    mint x = 1, y = two-1;\n    for (int j : to[i]) {\n      r -= g[j].fi;\n      d1[i] *= d1[j];\n      x *= d2[j];\n      y *= d1[j];\n    }\n    x *= ex(2,r);\n    d2[i] = x+y;\n  }\n  // cerr<<d1<<endl;\n  // cerr<<d2<<endl;\n  res = d2.back();\n  return res*2;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\",&n);\n  vi a(n);\n  cin>>a;\n  a.insert(a.begin(),0);\n  a.pb(0);\n  ll cnt = 0;\n  rrep(i,n) {\n    int mx = max(a[i-1],a[i+1]);\n    if (mx < a[i]) {\n      cnt += a[i]-mx;\n      a[i] = mx;\n    }\n  }\n  rrep(i,n) {\n    if (a[i] == 1) {\n      ++cnt;\n      a[i] = 0;\n    }\n  }\n  mint ans = ex(2,cnt);\n  vi x;\n  rrep(i,n+1) {\n    if (a[i]) {\n      x.pb(a[i]);\n    } else {\n      if (sz(x)) {\n        ans *= f(conv(x));\n      }\n      x = vi();\n    }\n  }\n\n  cout<<ans<<endl;\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) (x = max(x,y))\n#define mins(x,y) (x = min(x,y))\n#define limit(x,l,r) max(l,min(x,r))\n#define lims(x,l,r) (x = max(l,min(x,r)))\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcountll\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,v(T),greater<T> >\n#define bn(x) ((1<<x)-1)\n#define dup(x,y) (((x)+(y)-1)/(y))\n#define newline puts(\"\")\n#define v(T) vector<T>\n#define vv(T) v(v(T))\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ntemplate<typename T>inline istream& operator>>(istream&i,v(T)&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(const v(T)&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>inline ostream& operator<<(ostream&o,const v(T)&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>inline istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>inline ostream& operator<<(ostream&o,const pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\ntemplate<typename T>inline ll suma(const v(T)& a) { ll res(0); for (auto&& x : a) res += x; return res;}\nconst double eps = 1e-10;\nconst ll LINF = 1e18;\nconst int INF = 1001001001;\n#define dame { puts(\"-1\"); return 0;}\n#define yn {puts(\"YES\");}else{puts(\"NO\");}\nconst int MX = 200005;\n\n// Mod int\nconst int mod = 1000000007;\nstruct mint {\n  ll x;\n  mint():x(0){}\n  mint(ll x):x((x%mod+mod)%mod){}\n  // mint(ll x):x(x){}\n  mint& fix() { x = (x%mod+mod)%mod; return *this;}\n  mint& operator+=(const mint& a){ if((x+=a.x)>=mod) x-=mod; return *this;}\n  mint& operator-=(const mint& a){ if((x+=mod-a.x)>=mod) x-=mod; return *this;}\n  mint& operator*=(const mint& a){ (x*=a.x)%=mod; return *this;}\n  mint& operator/=(const mint& a){ (x*=a.ex(mod-2).x)%=mod; return *this;}\n  mint operator+(const mint& a)const{ return mint(*this) += a;}\n  mint operator-(const mint& a)const{ return mint(*this) -= a;}\n  mint operator*(const mint& a)const{ return mint(*this) *= a;}\n  mint operator/(const mint& a)const{ return mint(*this) /= a;}\n  mint ex(ll t) const {\n    if(!t) return 1;\n    mint res = ex(t/2);\n    res *= res;\n    return (t&1)?res*x:res;\n  }\n  bool operator<(const mint& a)const{ return x < a.x;}\n  bool operator==(const mint& a)const{ return x == a.x;}\n};\nmint ex(mint x, ll t) { return x.ex(t);}\nistream& operator>>(istream&i,mint&a){i>>a.x;return i;}\nostream& operator<<(ostream&o,const mint&a){o<<a.x;return o;}\ntypedef vector<mint> vm;\nstruct comb {\n  vm f, g;\n  comb(){}\n  comb(int mx):f(mx+1),g(mx+1) {\n    f[0] = 1;\n    rrep(i,mx) f[i] = f[i-1]*i;\n    g[mx] = f[mx].ex(mod-2);\n    for(int i=mx;i>0;i--) g[i-1] = g[i]*i;\n  }\n  mint c(int a, int b) {\n    if (a < b) return 0;\n    return f[a]*g[b]*g[a-b];\n  }\n};\n//\n\nvi conv(vi a) {\n  vi res;\n  rep(i,sz(a)-1) {\n    res.pb(min(a[i],a[i+1])-1);\n  }\n  return res;\n}\ntypedef pair<mint,mint> MP;\nMP dfs(vi a) {\n  int n = sz(a);\n  int l = INF;\n  rep(i,n) mins(l,a[i]);\n  rep(i,n) a[i] -= l;\n  MP res(1,1);\n  vi x;\n  auto f = [&]() {\n    if (!sz(x)) return;\n    MP d = dfs(x);\n    res.fi *= d.fi;\n    res.se *= d.se;\n    x = vi();\n  };\n  rep(i,n) {\n    if (a[i]) {\n      x.pb(a[i]);\n    } else {\n      res.se *= 2;\n      f();\n    }\n  }\n  f();\n  // cerr<<l<<\": \"<<a<<endl;\n  // cerr<<res<<endl;\n  res.se += res.fi*(ex(2,l)-1);\n  res.fi *= ex(2,l);\n  // cerr<<res<<endl;\n  return res;\n}\nmint solve(vi a) {\n  int n = sz(a);\n  if (!n) return 1;\n  a = conv(a);\n  return dfs(a).se*2;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\",&n);\n  vi a(n);\n  cin>>a;\n  mint ans = 1;\n  rep(i,n) {\n    int x = 0;\n    if (i) maxs(x,a[i-1]);\n    if (i+1 < n) maxs(x,a[i+1]);\n    if (a[i] > x) {\n      ans *= ex(2,a[i]-x);\n      a[i] = x;\n    }\n  }\n\n  vi x;\n  rep(i,n) {\n    if (a[i] == 1) {\n      ans *= 2;\n      a[i] = 0;\n      ans *= solve(x);\n      x = vi();\n    } else x.pb(a[i]);\n  }\n  ans *= solve(x);\n  cout<<ans<<endl;\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nint H[105];\nll mo=1000000007;\n\nll modpow(ll a, ll n = mo-2) {\n\tll r=1;a%=mo;\n\twhile(n) r=r*((n%2)?a:1)%mo,a=a*a%mo,n>>=1;\n\treturn r;\n}\n\npair<ll,ll> hoge(int L,int R,int v) {\n\tll dp1=1,dp2=1;\n\tint i;\n\t\n\tif(L>R) return {-1,1};\n\t\n\tint mi=1<<30;\n\tfor(i=L;i<=R;i++) mi=min(mi,H[i]);\n\tint W=R-L+1;\n\tfor(i=L;i<=R;i++) if(mi!=H[i]) W--;\n\t\n\tint pre=L-1;\n\tfor(i=L;i<=R;i++) {\n\t\tif(mi==H[i]) {\n\t\t\tauto r=hoge(pre+1,i-1,mi);\n\t\t\tif(r.first>=0) {\n\t\t\t\t(dp1*=r.first)%=mo;\n\t\t\t\t(dp2*=r.first+r.second)%=mo;\n\t\t\t}\n\t\t\t\n\t\t\tpre=i;\n\t\t}\n\t}\n\tauto r=hoge(pre+1,R,mi);\n\tif(r.first>=0) {\n\t\t(dp1*=r.first)%=mo;\n\t\t(dp2*=r.first+r.second)%=mo;\n\t}\n\t\n\t(dp2=dp2*modpow(2,W)+(modpow(2,mi-v)+mo-2)*dp1)%=mo;\n\t(dp1*=modpow(2,mi-v))%=mo;\n\t\n\treturn {dp1,dp2};\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tfor(i=1;i<=N;i++) cin>>H[i];\n\tcout<<hoge(1,N,0).second<<endl;\n\treturn;\n\t\n\tll ret=1;\n\tFOR(j,1001) {\n\t\tFOR(i,N+1) if(H[i]==1) (ret*=2)%=mo, H[i]=0;\n\t\tfor(i=1;i<N+1;i++) {\n\t\t\tif(H[i]>max(H[i-1],H[i+1])) {\n\t\t\t\t(ret*=modpow(2,H[i]-max(H[i-1],H[i+1])))%=mo;\n\t\t\t\tH[i]=max(H[i-1],H[i+1]);\n\t\t\t}\n\t\t}\n\t}\t\n\t\n\tfor(i=1;i<=N;i++) if(H[i]) {\n\t\tj=i;\n\t\twhile(H[j]) j++;\n\t\t(ret*=hoge(i,j-1,0).second)%=mo;\n\t\ti=j;\n\t}\n\tcout<<ret<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N=105;\nconst int MOD=1000000007;\n\nint n,f[N][N],h[N],w[N],m;\n\nint ksm(int x,int y)\n{\n    if (y<0) return 1;\n    int ans=1;\n    while (y)\n    {\n        if (y&1) ans=(LL)ans*x%MOD;\n        x=(LL)x*x%MOD;y>>=1;\n    }\n    return ans;\n}\n\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i = 1;i <= n;i ++) {\n        scanf(\"%d\",&h[i]);\n        w[++ m] = h[i];\n    }\n    sort(w + 1,w + m + 1);\n    m = unique(w + 1,w + m + 1) - w - 1;\n    for(int i = 1;i <= n;i ++) {\n        h[i] = lower_bound(w + 1,w + m + 1,h[i]) - w;\n    }\n    f[0][0]=1;\n    for(int i = 1;i <= n;i ++) {\n        for(int j = h[i] + 1;j <= h[i-1];j ++) {\n            (f[i][0] += f[i - 1][j] * 2 % MOD) %= MOD;\n            (f[i][0] += f[i - 1][0] * 2 % MOD) %= MOD;\n        }\n        for(int j = 1;j <= h[i];j ++) {\n            f[i][j]=(LL)f[i - 1][j] * ksm(2,w[h[i]] - w[h[i-1]]) % MOD;\n            if(h[i - 1] >= j)continue;\n            if(j > 1)(f[i][j] += (LL)f[i - 1][0] * (ksm(2,w[j] - w[j - 1]) - 1) % MOD * 2 % MOD * ksm(2,w[h[i]] - w[j]) % MOD) %= MOD;\n            else (f[i][j] += (LL)f[i - 1][0] * (ksm(2,w[j]) - 2) % MOD * ksm(2,w[h[i]] - w[j]) % MOD) %= MOD;\n        }\n    }\n    int ans = 0;\n    for(int i = 0;i <= m;i++)\n        (ans += f[n][i]) %= MOD;\n    printf(\"%d\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int M=1e9+7;\nint a[110],n;\nstruct node{\n\tint x,y;\n};\nint ksm(int x,int y){\n\tint ans=1;\n\tfor (;y;y>>=1,x=x*x%M)\n\t\tif (y&1)(ans*=x)%=M;\n\treturn ans;\t\n}\nnode calc(int l,int r,int lim){\n\tint minn=1e18,cnt=0;\n\tnode ans;\n\tfor (int i=l;i<=r;i++)\n\t\tif (a[i]<minn)minn=a[i],cnt=1;\n\t\telse if (a[i]==minn)cnt++;\n\tif (cnt==r-l+1){\n\t\tans.x=(ksm(2,r-l+1)-2+M)%M;\n\t\tans.y=ksm(2,minn-lim-1);\n\t\treturn ans;\n\t}\n\tint s0=1,s1=1,last=0;\n\tfor (int i=l;i<=r+1;i++){\n\t\tif (!last&&a[i]>minn)last=i;\n\t\telse if (last&&(i==r+1||a[i]==minn)){\n\t\t\tnode Ans=calc(last,i-1,minn);\n\t\t\t(s0*=(Ans.x+4*Ans.y%M)%M)%=M;\n\t\t\t(s1*=Ans.y*2%M)%=M;\n\t\t\tlast=0;\n\t\t}\n\t}\n\ts0=(s0+M-s1)%M;\n\tans.x=(s0*ksm(2,cnt)%M+s1*(ksm(2,cnt)-2+M)%M)%M;\n\tans.y=s1*ksm(2,minn-lim-1)%M;\n\treturn ans;\n}\nsigned main(){\n\tscanf(\"%lld\",&n);\n\tfor (int i=1;i<=n;i++)scanf(\"%lld\",&a[i]);\n\tif (n==1){\n\t\tprintf(\"%lld\",ksm(2,a[1]));\n\t\treturn 0;\n\t}\n\tint ans=1;\n\tfor (int i=1;i<=n;i++)\n\t\tif (a[i]>a[i-1]&&a[i]>a[i+1]){\n\t\t\t(ans*=ksm(2,a[i]-max(a[i+1],a[i-1])))%=M;\n\t\t\ta[i]=max(a[i+1],a[i-1]);\n\t\t}\n\tnode Ans=calc(1,n,0);\n\tprintf(\"%lld\\n\",ans*(Ans.x+2*Ans.y%M)%M);\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <numeric>\n#include <set>\n#include <tuple>\n#include <vector>\nusing namespace std;\n\ntemplate<uint32_t mod> class modulo_int {\n  class dummy_type { };\n\n  modulo_int &normalize2() {\n    if (value >= mod) value -= mod;\n    return *this;\n  }\n\n  modulo_int(const uint32_t value, const dummy_type &) : value(value) {}\n\npublic:\n  explicit modulo_int(const int64_t value = 0) : value(value % mod + mod) { normalize2(); }\n\n  uint32_t get() const { return value; }\n\n  modulo_int operator+() const {\n    return *this;\n  }\n  modulo_int operator-() const {\n    return modulo_int(mod - this->value, {}).normalize2();\n  }\n  modulo_int operator+(const modulo_int &that) const {\n    return modulo_int(this->value + that.value, {}).normalize2();\n  }\n  modulo_int operator-(const modulo_int &that) const {\n    return modulo_int(this->value + (mod - that.value), {}).normalize2();\n  }\n  modulo_int operator*(const modulo_int &that) const {\n    return modulo_int(((uint64_t)(this->value) * that.value) % mod, {});\n  }\n  // mod should be prime\n  modulo_int operator/(const modulo_int &that) const {\n    return *this * that.inv();\n  }\n  friend modulo_int pow(const modulo_int base, uint64_t e) {\n    if (e == 0) return modulo_int(1, {});\n    if (e == 1) return base;\n    auto tmp = pow(base * base, e / 2);\n    return (e&1) ? tmp * base : tmp;\n  }\n\n  modulo_int &operator+=(const modulo_int &that) { return *this = *this + that; }\n  modulo_int &operator-=(const modulo_int &that) { return *this = *this - that; }\n  modulo_int &operator*=(const modulo_int &that) { return *this = *this * that; }\n  modulo_int &operator/=(const modulo_int &that) { return *this = *this / that; }\n\n  modulo_int inv() const {\n    pow(*this, mod - 2);\n  }\n\nprivate:\n  uint32_t value;\n};\n\nusing mod_t = modulo_int<1000000007>;\n\n// pair(stripe case, non-stripe case)\npair<mod_t, mod_t> solve_rec(\n    const vector<int> &h,\n    const int l,\n    const int r,\n    const int current_h\n)\n{\n  assert(r > l);\n  const int new_h = *min_element(begin(h) + l, begin(h) + r);\n  assert(new_h > current_h);\n  if (new_h == *max_element(begin(h) + l, begin(h) + r)) {\n    mod_t stripe_res = pow(mod_t(2), h[l] - current_h);\n    mod_t nonstripe_res = pow(mod_t(2), r - l) - mod_t(2);    // -2 for stripe\n    return make_pair(stripe_res, nonstripe_res);\n  }\n  vector<int> ls, rs;\n  for (int i = l; i < r; ++i) {\n    if (new_h == h[i]) continue;\n    if (rs.empty() || rs.back() != i) {\n      ls.push_back(i);\n      rs.push_back(i+1);\n    } else {\n      ++rs.back();\n    }\n  }\n  assert(ls.size() == rs.size());\n  assert(!ls.empty());\n\n  mod_t nonstripe_res(1);\n  mod_t stripe_res(1);\n  const int t = ls.size();\n  vector<mod_t> stripe, nonstripe;\n  for (int i = 0; i < t; ++i) {\n    mod_t stripe, nonstripe;\n    tie(stripe, nonstripe) = solve_rec(h, ls[i], rs[i], new_h);\n    nonstripe_res *= nonstripe + (stripe * mod_t(2));\n    stripe_res *= stripe;\n  }\n  for (int i = l; i < r; ++i) if (h[i] == new_h) nonstripe_res *= mod_t(2);\n  nonstripe_res -= stripe_res * mod_t(2);\n  stripe_res *= pow(mod_t(2), new_h - current_h);\n  return make_pair(stripe_res, nonstripe_res);\n}\n\n\nint main() {\n  int n;\n  cin >> n;\n  vector<int> h(n);\n  for (auto &x : h) cin >> x;\n  if (n == 1) {\n    cout << pow(mod_t(2), h[0]).get() << endl;\n    return 0;\n  }\n  mod_t precompute(1);\n  for (int i = 0; i < n; ++i) {\n    const int adj = max(i == 0 ? 0 : h[i-1], i == n-1 ? 0 : h[i+1]);\n    if (adj < h[i]) {\n      precompute *= pow(mod_t(2), h[i] - adj);\n      h[i] = adj;\n    }\n  }\n  mod_t stripe, nonstripe;\n  tie(stripe, nonstripe) = solve_rec(h, 0, n, 0);\n\n  cout << (precompute * (stripe + nonstripe)).get() << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX = 210000;\nconst int MOD = 1000000007;\n\ntypedef pair<long long, long long> pll;\nlong long modpow(long long a, long long n, long long mod) {\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\nint N;\nvector<long long> H;\n\n// first: all, second: oxoxoxoxox\npll rec(int left, int right) {\n    long long resall = 0, resalt = 0;\n\n    // height\n    long long height = 1LL<<60;\n    for (int i = left; i < right; ++i) if (H[i] < height) height = H[i];\n    for (int i = left; i < right; ++i) H[i] -= height;\n    vector<pll> subs;\n    int nleft = left;\n    int width = 0;\n    for (int i = left; i < right; ++i) {\n        if (H[i] == 0) {\n            if (i > nleft) subs.push_back(rec(nleft, i));\n            nleft = i+1;\n            ++width;\n        }\n    }\n    if (right > nleft) subs.push_back(rec(nleft, right));\n    \n    // second -> second\n    long long facalt = 1;\n    for (auto p : subs) facalt *= p.second, facalt %= MOD;\n    resalt += facalt * modpow(2LL, height, MOD) % MOD;\n    resall += resalt;\n\n    // first (not second)\n    long long fac = 1;\n    for (auto p : subs) {\n        fac *= (p.first + p.second); fac %= MOD;\n    }\n    resall += fac * modpow(2LL, width, MOD) % MOD;\n    resall += MOD - facalt * 2 % MOD;\n\n    // result\n    return pll(resall % MOD, resalt % MOD);;\n}\n\nint main() {\n    cin >> N;\n    H.resize(N); for (int i = 0; i < N; ++i) cin >> H[i];\n    pll res = rec(0, N);\n    cout << res.first << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#define maxn 105\n#define R register\n#define INF 0x3f3f3f3f\nusing namespace std;\ntypedef long long lxl;\nconst lxl mod = 1e9+7;\n\ninline lxl read()\n{\n\tlxl x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9') {if(ch=='-') f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9') {x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\ninline lxl fmi(lxl a,lxl b)\n{\n\tlxl ans=1;\n\twhile(b>0)\n\t{\n\t\tif(b&1) ans=(ans*a)%mod;\n\t\ta=(a*a)%mod;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\n\nlxl n,h[maxn],H[maxn],W[maxn],X[maxn],Rm[maxn],tot;\nint d[maxn][20],lg[maxn];\nstd::vector<int> ch[maxn];\n\ninline void init()\n{\n\tlg[0]=-1;\n\tfor(R int i=1;i<=n;++i)\n\t\tlg[i]=lg[i>>1]+1;\n\tfor(R int i=1;i<=n;++i)\n\t\td[i][0]=h[i];\n\tfor(R int j=1;j<=15;++j)\n\t\tfor(R int i=1;i+(1<<(j-1))<=n;++i)\n\t\t\td[i][j]=min(d[i][j-1],d[i+(1<<(j-1))][j-1]);\n}\n\ninline int query(int l,int r)\n{\n\tint k=lg[r-l+1];\n\treturn min(d[l][k],d[r-(1<<k)+1][k]);\n}\n\ninline int build(int l,int r,int fa)\n{\n\tif(l>r) return 0;\n\tint p=++tot;\n\tint x=X[p]=query(l,r);\n\tH[p]=X[p]-X[fa];\n\tW[p]=r-l+1;\n\tint tl=l-1,tr=l-1;\n\tfor(R int i=l;i<=r;++i)\n\t{\n\t\tif(h[i]==x&&tl<tr)\n\t\t\tch[p].push_back(build(tl+1,tr,p));\n\t\tif(h[i]==x) tl=i,++Rm[p];\n\t\telse tr=i;\n\t}\n\tif(tl<tr) ch[p].push_back(build(tl+1,tr,p));\n\treturn p;\n}\n\nlxl f[maxn][2];\n\ninline void dp(int u)\n{\n\t//f[u][0] stands for u 10101010 \n\t// f[u][1] u \\out S\n\tlxl res1=1,res2=1;\n\tfor (std::vector<int>::iterator it = ch[u].begin(); it != ch[u].end(); ++it)\n\t{\n\t\tdp(*it);\n\t\tres1=(res1*f[*it][0])%mod;\n\t\tres2=(res2*((f[*it][0]*2%mod+f[*it][1])%mod))%mod;\n\t}\n\tf[u][0]=(fmi(2,H[u])*res1)%mod;\n\tf[u][1]=(fmi(2,Rm[u])*res2+(mod-2*res1%mod)%mod)%mod;\n}\n\nint main()\n{\n\tn=read();\n\tfor(R int i=1;i<=n;++i)\n\t\th[i]=read();\n\tinit();\n\tint rt=build(1,n,0);\n\tdp(rt);\n\tprintf(\"%lld\",(f[rt][1]+2ll * f[rt][0] % mod)%mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// #pragma GCC optimize (\"O3\")\n// #pragma GCC target (\"sse4\")\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<int,int> PII;\n\n#define REP(i,n) for(int i=0;i<(n);++i)\n#define FOR(i,a,b) for (int i=(a); i<(b); ++i)\n#define FORD(i,a,b) for (int i=(a)-1; i>=(b); --i)\n\n#define pb push_back\n#define mp make_pair\n#define st first\n#define nd second\n\nconst int MOD = 1000000007;\n\nLL powe(LL a, LL b) {\n  LL r = 1;\n  while (b) {\n    if (b&1) {\n      (r *= a) %= MOD;\n    }\n    a = a * a % MOD;\n    b >>= 1;\n  }\n  return r;\n}\n\nint H[105];\n// ababababab..., any\npair<LL, LL> go(int a, int b, int offset) {\n  // printf(\"%d %d %d\\n\", a, b, offset);\n\n  if (a == b) return { 1, 1 };\n\n  int mini = 1e9;\n  FOR(i,a,b) mini = min(mini, H[i] - offset);\n  assert(mini > 0);\n\n  if (a + 1 == b) return { powe(2, mini-1), powe(2, mini) };\n\n  int S = a;\n\n  LL aba = 1, any = 1, aba_counted = 1;\n  int minis = 0;\n  FOR(i,a,b+1) {\n    if (i == b || H[i]-offset == mini) {\n      if (i > S) {\n        auto rec = go(S, i, offset+mini);\n\n        (aba *= 2 * rec.st) %= MOD;\n        (any *= (rec.nd + 2 * rec.st)) %= MOD;\n      }\n\n      S = i + 1;\n\n      if (i < b) {\n        (any *= 2) %= MOD;\n        ++minis;\n      }\n    }\n  }\n\n  // printf(\"%d %d %d %lld %lld(%d %lld)\\n\", a, b, offset, aba, any, mini, powe(2, mini)-2);\n  (any += 2 * aba * (powe(2, mini-1)-1)) %= MOD;\n  (aba *= powe(2, mini-1)) %= MOD;\n  // printf(\"%d %d %d %lld %lld\\n\", a, b, offset, aba, any);\n\n  return {aba, any};\n}\n\nint main() {\n  // ios_base::sync_with_stdio(0);\n\n  int N;\n  scanf(\"%d\", &N);\n  REP(i,N) {\n    scanf(\"%d\", &H[i]);\n  }\n\n  LL any = 0;\n  REP(i,N) {\n    int h = 0;\n    if (i > 0) h = max(h, H[i-1]);\n    if (i < N-1) h = max(h, H[i+1]);\n    h = min(h, H[i]);\n    any += H[i] - h;\n    H[i] = h;\n  }\n\n  LL result = powe(2, any);\n  auto r = go(0, N, 0);\n  (result *= r.nd) %= MOD;\n\n  /*\n  REP(i,N) {\n    if (H[i] == 1) {\n      ++any;\n      (result *= go(S,i)) %= MOD;\n      S = i + 1;\n    }\n  }\n\n  (result *= powe(2, any)) %= MOD;\n  */\n\n  printf(\"%lld\\n\", result);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n#define pb(a) push_back(a)\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N=1e4+5,Mo=1e9+7;\n\nint pwr(int x,int y) {\n\tint z=1;\n\tfor(;y;y>>=1,x=(ll)x*x%Mo)\n\t\tif (y&1) z=(ll)z*x%Mo;\n\treturn z;\n}\n\nint n,h[N],row[N],column[N],tot;\nvector<int> son[N];\n\nint build(int l,int r,int d) {\n\tint mn=1e9,cnt=0,v=++tot;\n\tfo(i,l,r) mn=min(mn,h[i]);\n\tcolumn[v]=r-l+1;row[v]=mn-d;\n\tfo(i,l,r) cnt+=h[i]==mn;\n\tif (cnt==r-l+1) return v;\n\tint la=l-1;\n\tfo(i,l,r) \n\t\tif (h[i]==mn) {\n\t\t\tif (la!=i-1) son[v].pb(build(la+1,i-1,mn));\n\t\t\tla=i;\n\t\t}\n\tif (la!=r) son[v].pb(build(la+1,r,mn));\n\treturn v;\n}\n\nll f[N],g[N];\n\nvoid dfs(int x) {\n\tf[x]=1;g[x]=0;int c=column[x]-1;\n\tfor(int y:son[x]) {\n\t\tdfs(y);\n\t\tg[x]=(g[x]*(f[y]+g[y])+f[x]*g[y])%Mo;\n\t\tf[x]=f[x]*f[y]%Mo;\n\t\tc-=column[y]-1;\n\t}\n\tg[x]=(g[x]*pwr(2,c)+f[x]*(pwr(2,c)-1))%Mo;\n\tf[x]=f[x]*pwr(2,row[x]-(x==1))%Mo;\n}\n\nint main() {\n\tscanf(\"%d\",&n);\n\tfo(i,1,n) scanf(\"%d\",&h[i]);\n\tint ans=1;\n\tfo(i,2,n-1) \n\t\tif (h[i]>h[i-1]&&h[i]>h[i+1]) {\n\t\t\tans=(ll)ans*pwr(2,h[i]-max(h[i-1],h[i+1]))%Mo;\n\t\t\th[i]=max(h[i-1],h[i+1]);\n\t\t}\n\tbuild(1,n,0);dfs(1);\n\tans=(ll)ans*(f[1]+g[1])%Mo;\n\tprintf(\"%d\\n\",ans*2%Mo);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\ntypedef long long LL;\nconst int Mod = 1000000007;\nconst int MN = 100005;\n\ninline int qPow(int b, LL e) {\n\te = (e % (Mod - 1) + Mod - 1) % (Mod - 1);\n\tint a = 1;\n\tfor (; e; e >>= 1, b = (LL)b * b % Mod)\n\t\tif (e & 1) a = (LL)a * b % Mod;\n\treturn a;\n}\n\nint N, A[MN];\nLL B[MN];\nint stk[MN], val[MN], top;\ninline bool cmp(int i, int j) { return A[i] < A[j]; }\nint f[MN];\n\nint main() {\n\tscanf(\"%d\", &N);\n\tfor (int i = 1; i <= N; ++i) scanf(\"%d\", &A[i]);\n\tA[0] = A[N + 1] = 1;\n\tfor (int i = 1; i <= N; ++i) B[i] = A[i - 1] < A[i] ? A[i] - A[i - 1] : 0;\n\tfor (int i = 1; i <= N; ++i) B[i] += B[i - 1];\n\tf[0] = 1;\n\tstk[top = 1] = 0;\n\tfor (int i = 1; i <= N + 1; ++i) {\n\t\tf[i] = f[i - 1] * 2 % Mod;\n\t\tif (A[i - 1] > A[i]) {\n\t\t\tint p = std::lower_bound(stk + 1, stk + top + 1, i, cmp) - stk;\n\t\t\tf[i] = (f[i] + (LL)qPow(2, B[i - 1] + 1) * (val[top] - val[p] + Mod)) % Mod;\n\t\t\tif (p > 1 && A[i] < A[stk[p]]) f[i] = (f[i] + (LL)qPow(2, B[i - 1] - B[stk[p - 1] + 1] + A[stk[p - 1] + 1] + 1) * (qPow(2, -A[i] + 1) - qPow(2, -A[stk[p]] + 1) + Mod) % Mod * f[stk[p - 1]]) % Mod;\n\t\t}\n\t\twhile (top && A[stk[top]] >= A[i]) --top;\n\t\tstk[++top] = i;\n\t\tif (top > 1) val[top] = (val[top - 1] + (LL)qPow(2, A[stk[top - 1] + 1] - B[stk[top - 1] + 1] + 1) * (qPow(2, -A[stk[top - 1]]) - qPow(2, -A[stk[top]]) + Mod) % Mod * f[stk[top - 1]]) % Mod;\n\t}\n\tprintf(\"%lld\\n\", (LL)qPow(2, -1) * f[N + 1] % Mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define llu unsigned long long\n#define ld double\n#define llu unsigned long long\n#define rep(i,x,y)  for(ll i=x;i<y;++i)\n#define For(i,x,y)  for(ll i=x;i<=y;++i)\n#define FOr(i,x,y)  for(ll i=x;i>=y;--i)\n#define pi acos(-1)\n#define mk make_pair<ll,ll>\n#define pa pair<ll,ll>\n#define lf else if\n#define min(x,y)    ((x)<(y)?(x):(y))\n#define sqr(x)      ((x)*(x))\n#define abs(x)      ((x)>0?(x):-(x))\n#define Mul(x,y)    (x=(x)*(y)%mod)\n#define Mul1(x,y)   (x=(x)*(y)%mod1)\n#define Add(x,y)    (x=(x+(y))%mod)\n#define Add1(x,y)\t(x=(x+(y))%mod1)\n#define E(x)        return writeln(x),0\n#define p(x)        printf(\"~%d~\\n\",x)\n#define pp(x,y)     printf(\"~~%d %d~~\\n\",x,y)\n#define ppp(x,y,z)  printf(\"~~~%d %d %d~~~\\n\",x,y,z)\n#define pppp(x,y,z,a)  printf(\"~~~%d %d %d %d~~~\\n\",x,y,z,a)\n#define f_in(x)     freopen(x\".in\",\"r\",stdin)\n#define f_out(x)    freopen(x\".out\",\"w\",stdout)\n#define open(x)     f_in(x),f_out(x)\n#define fi first\n#define se second\ntypedef complex<double> E;\nnamespace SHENZHEBEI{\n#ifdef LOCAL\n    struct _{_(){freopen(\"cf.in\",\"r\",stdin);}}_;\n#endif\n#define NEG 1\n    inline char gc(){   return getchar();   }\n#if NEG\n    inline ll read(){    ll x=0,f=1; char ch=gc();   for (;!isdigit(ch);ch=gc()) if (ch=='-') f=-1;  for (;isdigit(ch);ch=gc())  x=x*10-48+ch;   return x*f; }\n    inline void write(ll x){    if (x<0) putchar('-'),x=-x;  if (x>=10)   write(x/10);    putchar(x%10+'0');  }\n#else\n    inline ll read(){    ll x=0; char ch=gc();   for (;!isdigit(ch);ch=gc());    for (;isdigit(ch);ch=gc())  x=x*10-48+ch;   return x;   }\n    inline void write(ll x){    if (x>=10)   write(x/10);    putchar(x%10+'0');  }\n#endif\n    inline char readchar(){ char ch=gc();   for(;isspace(ch);ch=gc());  return ch;  }\n    inline ll readstr(char *s){ char ch=gc();   int cur=0;  for(;isspace(ch);ch=gc());      for(;!isspace(ch);ch=gc())  s[cur++]=ch;    s[cur]='\\0';    return cur; }\n    inline void writeln(ll x){  write(x);   puts(\"\");   }\n    inline ld getreal(){    static ld lbc;  scanf(\"%lf\",&lbc);  return lbc; }\n}using namespace SHENZHEBEI;\nconst ll N=110,mod=1e9+7;\nll n,a[N],h[N],f[N][N][2];\nnamespace GuYue{\n\tll b[N],h[N],n;\n\tll ppow(ll x,ll k){\n\t\tll ans=1;\n\t\tfor(;k;k>>=1,Mul(x,x))if (k&1)Mul(ans,x);\n\t\treturn ans;\n\t}\n\tll work(){\n\t\tmemset(f,0,sizeof f);\n\t\tn=*a;\n//\t\tif (n==1)return ppow(2,a[1]);\n\t\tFor(i,1,n)b[i]=a[i];\n\t\tsort(b+1,b+n+1);\n\t\tll tot=unique(b+1,b+n+1)-b-1;b[tot+1]=b[tot];\n\t\tFor(i,1,n)h[i]=lower_bound(b+1,b+tot+1,a[i])-b;\n\t\tf[0][0][0]=f[0][0][1]=1;\n//\t\tFor(i,1,n)write(a[i]),putchar(' ');puts(\"\");\n\t\tFor(i,1,n){\n\t\t\tFor(cur1,0,h[i-1])For(cur2,0,h[i])For(num1,0,1)For(num2,0,1)\n\t\t\tif (f[i-1][cur1][num1]){\n\t\t\t\tll res1,res2,res3=0;\n\t\t\t\tif (cur2==h[i])res1=res2=1;\n\t\t\t\telse\tres1=ppow(2,b[cur2+1]-b[cur2]-(cur2==0))-1,res2=ppow(2,a[i]-b[cur2+1]);\n\t\t\t\tif ((num1!=num2)&&(min(cur1,cur2)>=min(h[i-1],h[i]))){\n\t\t\t\t\tres3=1;\n\t\t\t\t\tif (i==1)res3=0;\n\t\t\t\t}\n\t\t\t\tAdd(f[i][cur2][num2],f[i-1][cur1][num1]*res1%mod*res2%mod*res3);\n\t\t\t\tif (num1==num2){\n\n\t\t\t\t\tif (h[i]>=h[i-1]){\n\t\t\t\t\t\tif (cur2>=cur1&&cur1==h[i-1])\n\t\t\t\t\t\t\tAdd(f[i][cur2][num2],f[i-1][cur1][num1]*res1%mod*res2);//writeln(f[i-1][cur1][num1]*res1*res2);\n\t\t\t\t\t\tlf (cur1==cur2)\n\t\t\t\t\t\t\tAdd(f[i][cur2][num2],f[i-1][cur1][num1]*ppow(2,a[i]-a[i-1]));\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif (cur2<=cur1&&cur2==h[i])\n\t\t\t\t\t\t\tAdd(f[i][cur2][num2],f[i-1][cur1][num1]);\n\t\t\t\t\t\tlf (cur1==cur2)\n\t\t\t\t\t\t\tAdd(f[i][cur2][num2],f[i-1][cur1][num1]);\n\t\t\t\t\t}\t\t\t\t}\n//\t\t\t\twriteln(f[i-1][cur1][num1]*res1%mod*res2%mod*res3);\n\t\t\t}\n\t\t}ll ans=0;\n\t\tFor(i,0,n)For(j,0,1)Add(ans,f[n][i][j]);\n//\t\twriteln(ans);\n\t\treturn ans;\n\t}\n}\nint main(){\n\tn=read();\n\tFor(i,1,n)h[i]=read();\n\tll ans=1;h[n+1]=1;\n\tfor(ll i=1;i<=n;)if (h[i]!=1){\n\t\t*a=0;\n\t\tfor(;h[i]!=1;)a[++*a]=h[i++];\n\t\tMul(ans,GuYue::work());\n\t}else\tMul(ans,2),++i;\n\tAdd(ans,mod);\n\twriteln(ans);\n}\n/*\n对于2\n取反,相同。。。 \n*/\n"
  },
  {
    "language": "C++",
    "code": "/*\n                     .:*+=%@@@@@@=-.\n                 .:=@#@@@#@@#######%==*.\n              .-=####@######%*-.....:%##%.\n            .*@###########%+:--........-%@-\n          .*@##############@+--.........-:%-\n        .+##################@==%%%%=+*:----+.\n      .-@####################%++%@@@@@=+**%@@*\n      .%###################@%%@@@###@%+:--%@@%.\n     -@###################@%%%%*::*%++:-----=@+.\n    -#####################@%=++++++*:-------.-=:\n   .+####################@%++*::-:::--::*:::***=:\n   .@#####################%=++*::::-:::++*=##@@#@-\n  ..#####################@%%=++**:::::**+%@#@%%##-..\n   .%####################@@%=+++*+****::*=@######@.\n  .=######################@%%==+==++**+=@%@##@###+:...\n  -#######################@@@%%%===++=@@@%=++===*::--...\n  -########################@@@@@@@%==%%=++==@@:::::*:--.\n..:#########################@@@@@@%%======++++::-..:-.--...\n%#############################@###@%%@@%==%=%*----.--.::---.\n#############################################*-:*:-:---*---- .\n#############################################*--*--:---*---:-.\n#############################################+--::--::-*::-::.\n###########################################+:*-.---.---.:---*-..\n###########################################**:-----------------.\n##########################################@::**:--::::::--:::::-\n###########################################:--:*:::::::::**::*+*\n###########################################=:::***::::::**:::*+*\n############################@@@@@@#########@+****::::********+++\n############################@%%%%%@@@@@@@###%+***::::::::***+==+\n############################@%%%%%%%%%%%@####=+:::-::::-::*+=%%+\n#############################@%%%%%%%%%%@#####=::--------:*=%@%+\n%###########################@%%%%==%%%%%%@##@#=:------..-:+%@@%=\n----------------------------------------------\n--------------------------------------------\n----------------------------------------------\n--------------------------------------------\n----------------------------------------------\n\n         o###########oo\n      o##\"          \"\"##o\n    o#\"                \"##\n  o#\"                    \"#o\n #\"  ##              ##   \"##\n#\"                          ##\n#  ###################       #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#o                           #\n\"#o                         ##\n \"#o                       ##\n  \"#o                    o#\"\n   \"#o                  ##\n     \"#o              o#\"\n       \"#ooo      ooo#######oo\n        ###############   \"######o\n     o###\"\"        \"###o      # ###\n   o###o     oooo    ###    oo####\"\n o###**#     #**#   ############\"\n \"\"##\"\"\"\"\"\"\"\"\"\"###########    #\n    # oooooooo#\"#**     ##    #\n    # #       # # **    ##    #\n    #o#       #o#  *****###ooo#\n                        ##\n                        ##   o###o\n                        ## o##***##\n               o########## #***#**##o\n             o##\"   \"\"###  #***##***#\n o#######o  ###   oo####   ##**####*#\no##\"  \"\"#############\"\"     ##****###\n##\"         ##              ##*##*###\n##          ###              ##### ##\n##           ###              # ##  #\n##            ##                 #\n##             ##\n##             ###\n##              ###oo\n###              \"\"###\n ###\n  ###\n*/\n\n///YEAH IM THE BEST I'VE EVER WAS\n\n///SO HAPPY\n\n#include <bits/stdc++.h>\n\n//#pragma GCC optimize(\"O3\")\n//#pragma GCC optimize(\"Ofast,no-stack-protector\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\")\n//#pragma GCC target(\"avx,tune=native\")\n//float __attribute__((aligned(32)))\n\n/*char memory[(int)1e8];\n\nchar memorypos;\n\ninline void * operator new(size_t n){\n    char * ret = memory + memorypos;\n    memorypos += n;\n    return (void *)ret;\n}\n\ninline void operator delete(void *){}\n*/\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef unsigned long long ull;\n\ntypedef long double ld;\n\ntypedef unsigned int uint;\n\nll sqr(ll x){\n    return x * x;\n}\n\nint mysqrt(ll x){\n    int l = 0, r = 1e9 + 1;\n    while (r - l > 1){\n        int m = (l + r) / 2;\n        if (m * (ll)m <= x)\n            l = m;\n        else\n            r = m;\n    }\n    return l;\n}\n\nmt19937 rnd(1227);\n\nmt19937_64 rndll(12365);\n\nll AR = 19, BR = 13, CR = 23, XR = 228, YR = 322, MODR = 1e9 + 993;\n\nll myrand(){\n    ll ZR = (XR * AR + YR * BR + CR) % MODR;\n    XR = YR;\n    YR = ZR;\n    return ZR;\n}\n\nconst int Mod = 1e9 + 7;\n\nint Bpow(int x, int y){\n    if (y == 0)\n        return 1;\n    if (y == 1)\n        return x;\n    int ret = Bpow(x, y >> 1);\n    ret = (ret * (ll)ret) % Mod;\n    if (y & 1)\n        ret = (ret * (ll)x) % Mod;\n    return ret;\n}\n\nint Bdiv(int x, int y){\n    return (x * (ll)Bpow(y, Mod - 2)) % Mod;\n}\n\nvoid setmin(int &x, int y){\n    x = min(x, y);\n}\n\nvoid setmax(int &x, int y){\n    x = max(x, y);\n}\n\nvoid setmin(ll &x, ll y){\n    x = min(x, y);\n}\n\nvoid setmax(ll &x, ll y){\n    x = max(x, y);\n}\n\nint gcd(int a, int b){\n    return a ? gcd(b % a, a) : b;\n}\n\nconst ll llinf = 2e18 + 100;\n\nconst double eps = 1e-9;\n\nconst int maxn = 1e5 + 10, maxw = 1e6 + 10, inf = 1e9 + 100, sq = 300, mod = 1e9 + 7, LG = 17;\n\nint n;\n\nint arr[100];\n\npair<int, int> srt[100];\n\nmap<int, int> mp;\n\nint ord[101];\n\nint q[101][100][100][2][2][2];\n\nvoid add(int &x, int y){\n    x += y;\n    if (x >= mod)\n        x -= mod;\n    if (x < 0)\n        x += mod;\n}\n\nint main()\n{\n    #ifdef ONPC\n    //ifstream cin(\"a.in\");\n    //ofstream cout(\"a.out\");\n    freopen(\"a.in\", \"r\", stdin);\n    freopen(\"a.out\", \"w\", stdout);\n    #else\n    //ifstream cin(\"gymnasts.in\");\n    //ofstream cout(\"gymnasts.out\");\n    //freopen(\"sort.in\", \"r\", stdin);\n    //freopen(\"sort.out\", \"w\", stdout);\n    #endif // ONPC\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n;\n    for (int i = 0; i < n; i++)\n        cin >> arr[i], srt[i] = make_pair(arr[i], i);\n    sort(srt, srt + n, [&](pair<int, int> x, pair<int, int> y){\n            return x.first > y.first || (x.first == y.first && x.second < y.second);\n         });\n    srt[n].first = 1;\n    for (int i = 0; i <= n; i++)\n    if (i == 0 || srt[i].first != srt[i - 1].first)\n        mp[srt[i].first] = mp.size() - 1, ord[mp.size() - 1] = srt[i].first;\n    for (int it = 0; it < n; it++){\n        int i = srt[it].second;\n        int l = i, r = i + 1;\n        while (l >= 0 && arr[l] >= arr[i])\n            l--;\n        while (r < n && arr[r] > arr[i])\n            r++;\n        l++;\n        r--;\n        int t = mp[srt[it].first];\n        if (l == r){\n            q[t][l][r][0][0][0] = 1;\n            q[t][l][r][1][1][0] = 1;\n            continue;\n        }\n        int t1 = 0, t2 = 0;\n        for (int j = i - 1; j >= l; j--)\n            t1 = max(t1, mp[arr[j]]);\n        for (int j = i + 1; j <= r; j++)\n            t2 = max(t2, mp[arr[j]]);\n        if (l < i && t1 < t){\n            for (int a = 0; a < 2; a++)\n                for (int b = 0; b < 2; b++)\n                    q[t][l][i - 1][a][b][0] = ((q[t1][l][i - 1][a][b][0] + q[t1][l][i - 1][!a][!b][0]) * (ll)Bpow(2, ord[t1] - ord[t] - 1)) % mod,\n                    q[t][l][i - 1][a][b][1] = q[t1][l][i - 1][a][b][1];\n        }\n        if (r > i && t2 < t){\n            for (int a = 0; a < 2; a++)\n                for (int b = 0; b < 2; b++)\n                    q[t][i + 1][r][a][b][0] = ((q[t2][i + 1][r][a][b][0] + q[t2][i + 1][r][!a][!b][0]) * (ll)Bpow(2, ord[t2] - ord[t] - 1)) % mod,\n                    q[t][i + 1][r][a][b][1] = q[t2][i + 1][r][a][b][1];\n        }\n        if (l == i){\n            for (int a = 0; a < 2; a++)\n                for (int b = 0; b < 2; b++){\n                    q[t][l][r][a][b][0] = q[t][l + 1][r][!a][b][0];\n                    for (int x = 0; x < 2; x++)\n                        add(q[t][l][r][a][b][1], q[t][l + 1][r][x][b][1]);\n                    add(q[t][l][r][a][b][1], q[t][l + 1][r][a][b][0]);\n                }\n            continue;\n        }\n        if (r == i){\n            for (int a = 0; a < 2; a++)\n                for (int b = 0; b < 2; b++){\n                    q[t][l][r][a][b][0] = q[t][l][r - 1][a][!b][0];\n                    for (int x = 0; x < 2; x++)\n                        add(q[t][l][r][a][b][1], q[t][l][r - 1][a][x][1]);\n                    add(q[t][l][r][a][b][1], q[t][l][r - 1][a][b][0]);\n                }\n            continue;\n        }\n        for (int a = 0; a < 2; a++)\n            for (int b = 0; b < 2; b++){\n                for (int c = 0; c < 2; c++)\n                    add(q[t][l][r][a][b][0], (q[t][l][i - 1][a][!c][0] * (ll)q[t][i + 1][r][!c][b][0]) % mod);\n                int w = 0, h = 0;\n                for (int x = 0; x < 2; x++)\n                    for (int o = 0; o < 2; o++)\n                        add(w, q[t][l][i - 1][a][x][o]),\n                        add(h, q[t][i + 1][r][x][b][o]);\n                q[t][l][r][a][b][1] = (w * (ll)h * (ll)2) % mod;\n                add(q[t][l][r][a][b][1], -q[t][l][r][a][b][0]);\n            }\n    }\n    if (srt[n - 1].first != 1){\n        int t = mp.size() - 1, t1 = t - 1;\n        for (int a = 0; a < 2; a++)\n            for (int b = 0; b < 2; b++)\n                q[t][0][n - 1][a][b][0] = ((q[t1][0][n - 1][a][b][0] + q[t1][0][n - 1][!a][!b][0]) * (ll)Bpow(2, ord[t1] - ord[t] - 1)) % mod,\n                q[t][0][n - 1][a][b][1] = q[t1][0][n - 1][a][b][1];\n    }\n    int t = mp.size() - 1;\n    int ans = 0;\n    for (int a = 0; a < 2; a++)\n        for (int b = 0; b < 2; b++)\n            for (int x = 0; x < 2; x++)\n                add(ans, q[t][0][n - 1][a][b][x]);\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nconst int MOD = (int)1e9 + 7;\n\nint n,m,h[101],hnum[101],dh[101];///h记录每一列高度 dh记录离散化后的各不相同的高度 hnum记录h对应dh中的位置，即第几高的高度\nlong long dp[101][101];///记录第i列第n块高度往上的方案数\n\nint pow_(long long x,int y) {///快速幂求 x的y次方\n    long long ans = 1;\n    if(y > 0) {\n        while(y) {\n            if(y % 2)ans = ans * x % MOD;\n            x = x * x % MOD;\n            y /= 2;\n        }\n    }\n    return ans;\n}\n\nint main() {\n    scanf(\"%d\",&n);\n    for(int i = 1;i <= n;i ++) {\n        scanf(\"%d\",&h[i]);\n        dh[++ m] = h[i];///先把高度存到dh数组 下标从1开始，方便后面dp\n    }\n    sort(dh + 1,dh + m + 1);///dh数组排序\n    m = unique(dh + 1,dh + m + 1) - dh - 1;///dh数组离散化去掉重复的高度 m是不相同的高度数\n    for(int i = 1;i <= n;i ++) {\n        hnum[i] = lower_bound(dh + 1,dh + m + 1,h[i]) - dh;///每一列高度在dh数组中对应的位置\n    }\n    dp[0][0]=1;///初始化 当第0列有1个无连续相同的方案\n    for(int i = 1;i <= n;i ++) {///对每一列每个高度段进行更新 更新过程为从下往上\n        (dp[i][0] += dp[i - 1][0] * 2 % MOD) %= MOD;///无连续相同方案  加上前i - 1列无连续相同方案数*2 因为可以是与前一列对应位置同色或者异色一共两种方案\n        for(int j = hnum[i] + 1;j <= hnum[i - 1];j ++)///如果前一列比这一列高，高出的部分也存着接触部分无连续相同的方案 但是可能会重复加上上一步的方案数所以下面更新高出的部分时会避免\n            (dp[i][0] += dp[i - 1][j] * 2 % MOD) %= MOD;\n        int d = pow_(2,h[i] - h[i - 1]);///比前一列高出部分的涂色方案数，如果比前一列低 d就等于1\n        for(int j = 1;j <= min(hnum[i - 1],hnum[i]);j ++) {\n            dp[i][j] = dp[i - 1][j] * d % MOD;///有连续相同颜色的方案数 已经分析过接触部分的颜色一定是定下的 所以这一列接触部分有连续相同部分的方案数由高出部分的变化决定 即 乘上d\n        }\n        for(int j = hnum[i - 1] + 1;j <= hnum[i];j ++) {///更新比前一列高出的部分 j从上一列的高度加1的下标开始\n            if(j > 1)(dp[i][j] = dp[i - 1][0] * (pow_(2,dh[j] - dh[j - 1]) - 1) % MOD * 2 % MOD * pow_(2,h[i] - dh[j]) % MOD) %= MOD;\n            ///一般情况 前i - 1列无连续方案 * （第j块高度变化方案 -1表示去掉无连续相同方案) * 2 * 剩下几块高度的变化方案数\n            else (dp[1][1] = dp[0][0] * (pow_(2,dh[1]) - 2) % MOD * pow_(2,h[i] - dh[1]) % MOD) %= MOD;\n            ///第一列的第一块高度 记录随意变化方案数 -2表示除去dp[i][0]已经记录过的无连续相同方案 勿重复记录\n        }\n    }\n    long long ans = 0;\n    for(int i = 0;i <= hnum[n];i++)\n        (ans += dp[n][i]) %= MOD;\n    printf(\"%lld\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define ll long long\n\nconst ll mod = 1000000007;\nconst ll maxN = 111;\n\nll n, i, j, h[maxN], act, bef;\nvector<ll> ord;\nll dp[maxN][maxN];\n\nll poww(ll a, ll b) {\n    ll ans = 1;\n    while (b > 0) {\n        if (b & 1) ans = (ans * a) % mod;\n        b >>= 1;\n        a = (a * a) % mod;\n    }\n    return ans;\n}\n\nint get_id(int x) {\n    return lower_bound(ord.begin(), ord.end(), x) - ord.begin();\n}\n\nint main()\n{\n  //  freopen(\"test.in\",\"r\",stdin);\n\n    scanf(\"%lld\", &n);\n    for (i = 1; i <= n; i++) scanf(\"%lld\", &h[i]), ord.pb(h[i]);\n\n    ord.pb(0);\n    sort(ord.begin(), ord.end());\n    ord.resize(unique(ord.begin(), ord.end()) - ord.begin());\n\n    dp[1][0] = 2; //! doua colorari variabile\n\n    //! initializeaza\n    act = get_id(h[1]);\n    dp[1][1] = ((poww(2, ord[1]) + mod - 2) * poww(2, h[1] - ord[1])) % mod;\n\n    for (i = 2; i <= act; i++) {\n        dp[1][i] = ((poww(2, ord[i] - ord[i - 1]) + mod - 1) * 2LL) % mod;\n        dp[1][i] = (dp[1][i] * poww(2, h[1] - ord[i]));\n    }\n\n    //! rezolva\n    for (i = 2; i <= n; i++) {\n        bef = get_id(h[i - 1]);\n        act = get_id(h[i]);\n\n        if (h[i] == 1) {\n            for (j = 0; j <= bef; j++)\n                dp[i][0] = (dp[i][0] + dp[i - 1][j]) % mod;\n            dp[i][0] = (dp[i][0] * 2) % mod;\n            continue;\n        }\n\n        if (h[i - 1] <= h[i]) {\n            //! creste nebunia\n            for (j = 1; j <= bef; j++) {\n                dp[i][j] = (dp[i - 1][j] * poww(2, h[i] - ord[bef])) % mod;\n            }\n\n            dp[i][0] = (dp[i - 1][0] * 2) % mod;\n            for (j = bef + 1; j <= act; j++) {\n                dp[i][j] = (dp[i - 1][0] * ( poww(2, ord[j] - ord[j - 1]) + mod - 1 )) % mod;\n                dp[i][j] = (dp[i][j] * poww(2, h[i] - ord[j])) % mod;\n                dp[i][j] = (dp[i][j] * 2) % mod;\n            }\n        } else {\n            dp[i][0] = (dp[i - 1][0] * 2) % mod;\n\n            for (j = 1; j <= act; j++)\n                dp[i][j] = dp[i - 1][j];\n            for (j = act + 1; j <= bef; j++)\n                dp[i][0] = (dp[i][0] + dp[i - 1][j] * 2LL) % mod;\n        }\n    }\n\n    ll ans = 0;\n    act = get_id(h[n]);\n    for (i = 0; i <= act; i++) ans = (ans + dp[n][i]) % mod;\n\n    printf(\"%lld\", ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstdio>\n#define N 101\n#define p 1000000007\n#define ll long long\nusing namespace std;\ninline int mod(int x){return x<p?x:x-p;}\ninline int calc(int x,int y)\n{\n    int z=1;\n    for(;y;x=(ll)x*x%p,y>>=1)if(y&1)z=(ll)x*z%p;\n    return z;\n}\nint a[N],b[N],d[N],e[N],f[2][N],g[N],h,i,j,n;\ninline bool cmp(int u,int v){return a[u]<a[v];}\ninline int mul(int u,int v){return(ll)d[v]*e[u]%p;}\nint main()\n{\n    scanf(\"%d\",&n);\n    for(i=1;i<=n;i++)scanf(\"%d\",a+i),b[i]=i;\n    sort(b+1,b+n+1,cmp);\n    for(i=1;i<=n;a[b[i++]]=h)if(a[b[i]]!=g[h])g[++h]=a[b[i]];\n    for(i=0;i<=n;i++)e[i]=calc(d[i]=calc(2,g[i]),p-2);\n    for(i=1,*f[0]=mod(p+d[a[1]]-mod(mul(1,a[1])<<1)),f[0][a[1]]=2;i<a[1];i++)f[0][i]=mod(mod(p+mul(i,a[1])-mul(i+1,a[1]))<<1);\n    for(i=2;i<=n;i++)\n    if(a[i-1]<a[i])\n    {\n        for(j=0;j<a[i-1];f[i&1][j++]=0)f[i&1^1][j]=(ll)f[i&1][j]*mul(a[i-1],a[i])%p;\n        for(f[i&1^1][a[i]]=h=mod(f[i&1][j=a[i-1]]<<1),f[i&1][j]=0;j<a[i];j++)f[i&1^1][j]=(ll)h*(p+mul(j,a[i])-mul(j+1,a[i]))%p;\n    }\n    else\n    {\n        for(j=0;j<a[i];f[i&1][j++]=0)f[i&1^1][j]=f[i&1][j];\n        for(j=a[i];j<=a[i-1];f[i&1][j++]=0)f[i&1^1][a[i]]=mod(f[i&1^1][a[i]]+mod(f[i&1][j]<<1));\n    }\n    for(i=j=0;i<=a[n];i++)j=mod(j+f[n&1^1][i]);\n    return 0&printf(\"%d\\n\",j);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N = 105;\nconst int MOD = 1000000007;\n\nint n,dp[N][N],h[N],w[N],m;\n\nint pow_(int x,int y) {///快速幂求 x的y次方\n    int ans = 1;\n    if(y > 0) {\n        while(y) {\n            if(y % 2)ans = (LL)ans * x % MOD;\n            x = (LL)x * x % MOD;\n            y /= 2;\n        }\n    }\n    return ans;\n}\n\nint main() {\n    scanf(\"%d\",&n);\n    for(int i = 1;i <= n;i ++) {\n        scanf(\"%d\",&h[i]);\n        w[++ m] = h[i];\n    }\n    sort(w + 1,w + m + 1);///高度排序\n    m = unique(w + 1,w + m + 1) - w - 1;///离散化 m是离散化后的长度\n    for(int i = 1;i <= n;i ++) {\n        h[i] = lower_bound(w + 1,w + m + 1,h[i]) - w;\n        printf(\"%d\\n\",h[i]);\n    }\n    dp[0][0]=1;\n    for(int i = 1;i <= n;i ++) {\n        for(int j = h[i] + 1;j <= h[i-1];j ++)\n            (dp[i][0] += dp[i - 1][j] * 2 % MOD) %= MOD;\n        (dp[i][0] += dp[i - 1][0] * 2 % MOD) %= MOD;///交叉或者不交叉\n        for(int j = 1;j <= h[i];j ++) {\n            dp[i][j]=(LL)dp[i - 1][j] * pow_(2,w[h[i]] - w[h[i-1]]) % MOD;\n            if(h[i - 1] >= j)continue;\n            if(j > 1)(dp[i][j] += (LL)dp[i - 1][0] * (pow_(2,w[j] - w[j - 1]) - 1) % MOD * 2 % MOD * pow_(2,w[h[i]] - w[j]) % MOD) %= MOD;\n            //else (dp[i][j] += (LL)dp[i - 1][0] * (pow_(2,w[j]) - 2) % MOD * pow_(2,w[h[i]] - w[j]) % MOD) %= MOD;\n        }\n    }\n    int ans = 0;\n    for(int i = 0;i <= m;i++)\n        (ans += dp[n][i]) %= MOD;\n    printf(\"%d\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nint H[105];\n\nint dp[105][105];\nint all[105];\n\nint mod = 1000000007;\nlong long qexp(long long b, long long p){\n    long long res = 1;\n    while(p){\n        if(p&1) res = (res * b) % mod;\n        b = (b * b) % mod;\n        p >>= 1;\n    }\n    return res;\n}\n\nvector<int> dis = {1};\nint get(int x){ return lower_bound(dis.begin(),dis.end(),x) - dis.begin(); }\nvoid c(int &x){\n\tx %= mod;\n\tif(x < 0) x += mod;\n}\n\nsigned main(){\n\tios_base::sync_with_stdio(false); cin.tie(0);\n\t\n\tint n; cin >> n;\n\tfor(int i = 1;i <= n;i++){\n\t\tcin >> H[i];\n\t\tdis.push_back(H[i]);\n\t}\n\n\tsort(dis.begin(),dis.end());\n\tdis.erase(unique(dis.begin(), dis.end()), dis.end());\n\tint m = dis.size();\n\t\n\tall[0] = 1;\n\t\n\tfor(int i = 1;i <= n;i++){\n\t\tif(H[i] > H[i-1]){\t\t\t\n\t\t\tfor(int j = m-1;j >= 0;j--){\n\t\t\t\tif(dis[j] >= H[i]) dp[i][j] = 0;\n\t\t\t\telse if(dis[j] >= H[i-1]){\n\t\t\t\t\tdp[i][j] = all[i-1] * (qexp(2, H[i] - dis[j]) - 1) * 2;\n\t\t\t\t\tc(dp[i][j]);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdp[i][j] = dp[i-1][j] * qexp(2,H[i] - H[i-1]);\n\t\t\t\t\tc(dp[i][j]);\n\t\t\t\t\tdp[i][j] += all[i-1] * (qexp(2, H[i] - H[i-1]) - 1) * 2;\n\t\t\t\t\tc(dp[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tall[i] = all[i-1] * 2;\n\t\t\tc(all[i]);\n\t\t}\n\t\telse{\n\t\t\tfor(int j = 0;j < m;j++){\n\t\t\t\tif(dis[j] >= H[i]) dp[i][j] = 0;\n\t\t\t\telse{\n\t\t\t\t\tdp[i][j] = dp[i-1][j] - dp[i-1][get(H[i])];\n\t\t\t\t\tc(dp[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tall[i] = (all[i-1] + dp[i-1][get(H[i])]) * 2;\n\t\t\tc(all[i]);\n\t\t}\n\t\t\n\t}\n\t\n\tint ans = all[n] + dp[n][0];\n\tc(ans);\n\t\n\tcout << ans;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cout<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl\n\n\ntypedef long long ll;\n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define rrep(i,n) for(int i=n-1;i>=0;i--)\n#define rrep1(i,n) for(int i=n;i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(v) v.begin(),v.end()\n#define UNIQUE(v) v.erase(unique(all(v)), v.end())\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\nconst ll inf = 1000000001;\nconst ll INF = 2e18;\nconst ll MOD = 1000000007;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx[4] = { 1,0, -1,0 }, dy[4] = { 0,1,0,-1 };\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n//#define mp make_pair\n\n\nvii G(10000);\nvl dp1(10000), dp2(10000);\nvector<pll> rect(10000);\nvl h(110);\nint cnt = 0;\nint n;\nset<ll> st;\n\nll mod_pow(ll x, ll p, ll M = MOD) {\n\tll a = 1;\n\twhile (p) {\n\t\tif (p % 2)\n\t\t\ta = a * x%M;\n\t\tx = x * x%M;\n\t\tp /= 2;\n\t}\n\treturn a;\n}\n\n\nvoid dfs(ll now_h, int left, int right, int parent) {\n\tif (left == right) {\n\t\treturn;\n\t}\n\tint idx = cnt++;\n\tif (parent != -1) {\n\t\tG[parent].push_back(idx);\n\t}\n\tll nex_h = *st.lower_bound(now_h + 1);\n\trect[idx] = pll(nex_h - now_h, right - left);\n\tREP (i, left, right) {\n\t\tif (h[i] == nex_h) {\n\t\t\tdfs(nex_h, left, i, idx);\n\t\t\tleft = i + 1;\n\t\t}\n\t}\n\tdfs(nex_h, left, right, idx);\n}\n\nvoid dp(int now) {\n\tll res1 = 1, res2 = 1;\n\tll x = rect[now].first, w = rect[now].second;\n\trep(i, G[now].size()) {\n\t\tdp(G[now][i]);\n\t\tres1 = res1 * dp1[G[now][i]] % MOD;\n\t\tres2 = res2 * ((dp1[G[now][i]] + dp2[G[now][i]]) % MOD) % MOD;\n\t\tw -= rect[G[now][i]].second;\n\t}\n\tdp1[now] = res1 * mod_pow(2, x) % MOD;\n\tdp2[now] = (mod_pow(2, w) * res2 % MOD + (mod_pow(2, x) - 2) % MOD * res1 % MOD) % MOD;\n}\n\nint main() {\n\tcin >> n;\n\trep(i, n) {\n\t\tcin >> h[i];\n\t\tst.insert(h[i]);\n\t}\n\tdfs(0, 0, n, -1);\n\tdp(0);\n\tcout << dp2[0] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N = 105;\nconst int MOD = 1000000007;\n\nint n,m,h[N],w[N];\nLL dp[N][N];\n\nint pow_(int x,int y) {///快速幂求 x的y次方\n    int ans = 1;\n    if(y > 0) {\n        while(y) {\n            if(y % 2)ans = (LL)ans * x % MOD;\n            x = (LL)x * x % MOD;\n            y /= 2;\n        }\n    }\n    return ans;\n}\n\nint main() {\n    scanf(\"%d\",&n);\n    for(int i = 1;i <= n;i ++) {\n        scanf(\"%d\",&h[i]);\n        w[++ m] = h[i];\n    }\n    sort(w + 1,w + m + 1);///高度排序\n    m = unique(w + 1,w + m + 1) - w - 1;///离散化 m是离散化后的长度\n    for(int i = 1;i <= n;i ++) {\n        h[i] = lower_bound(w + 1,w + m + 1,h[i]) - w;\n    }\n    dp[0][0]=1;\n    for(int i = 1;i <= n;i ++) {\n        for(int j = h[i] + 1;j <= h[i - 1];j ++)\n            (dp[i][0] += dp[i - 1][j] * 2 % MOD) %= MOD;\n\n        (dp[i][0] += dp[i - 1][0] * 2 % MOD) %= MOD;///交叉或者不交叉\n\n        int d = pow_(2,w[h[i]] - w[h[i-1]]);\n        for(int j = 1;j <= min(h[i - 1],h[i]);j ++) {\n            dp[i][j] = dp[i - 1][j] * d % MOD;\n        }\n\n        for(int j = h[i - 1] + 1;j <= h[i];j ++) {///比前一列高出的部分\n            if(j > 1)(dp[i][j] += dp[i - 1][0] * (pow_(2,w[j] - w[j - 1]) - 1) % MOD * 2 % MOD * pow_(2,w[h[i]] - w[j]) % MOD) %= MOD;\n            else (dp[i][1] += dp[i - 1][0] * (pow_(2,w[1]) - 2) % MOD * pow_(2,w[h[i]] - w[1]) % MOD) %= MOD;///上一列中无重复的乘上化不超过上一列高度中有重复的\n        }\n    }\n    LL ans = 0;\n    for(int i = 0;i <= m;i++)\n        (ans += dp[n][i]) %= MOD;\n    printf(\"%lld\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef int sign;\ntypedef long long ll;\n#define For(i,a,b) for(register sign i=(sign)(a);i<=(sign)(b);++i)\n#define Fordown(i,a,b) for(register sign i=(sign)(a);i>=(sign)(b);--i)\nconst int N=100+5;\ntemplate<typename T>bool cmax(T &a,T b){return (a<b)?a=b,1:0;}\ntemplate<typename T>bool cmin(T &a,T b){return (a>b)?a=b,1:0;}\ntemplate<typename T>T read()\n{\n\tT ans=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch)&&ch!='-')ch=getchar();\n\tif(ch=='-')f=-1,ch=getchar();\n\twhile(isdigit(ch))ans=(ans<<3)+(ans<<1)+(ch-'0'),ch=getchar();\n\treturn ans*f;\n}\ntemplate<typename T>void write(T x,char y)\n{\n\tif(x==0)\n\t{\n\t\tputchar('0'),putchar(y);\n\t\treturn;\n\t}\n\tif(x<0)\n\t{\n\t\tputchar('-');\n\t\tx=-x;\n\t}\n\tstatic char wr[20];\n\tint top=0;\n\tfor(;x;x/=10)wr[++top]=x%10+'0';\n\twhile(top)putchar(wr[top--]);\n\tputchar(y);\n}\nvoid file()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"in\",\"r\",stdin);\n\tfreopen(\"out\",\"w\",stdout);\n#endif\n}\nint n,h[N];\nvoid input()\n{\n\tn=read<int>();\n\tFor(i,1,n)h[i]=read<int>();\n}\nint q[N],top;\nvoid init()\n{\n\tFor(i,1,n)q[++top]=h[i];\n\tsort(q+1,q+top+1);\n\ttop=unique(q+1,q+top+1)-q-1;\n\tFor(i,1,n)h[i]=lower_bound(q+1,q+top+1,h[i])-q;\n}\nconst int mo=1e9+7;\nint dp[N][N];\nll power(ll x,int y)\n{\n\tll res=1;\n\tfor(;y;x=x*x%mo,y>>=1)if(y&1)res=res*x%mo;\n\treturn res;\n}\nvoid add(int &x,int y)\n{\n\tx+=y;x-=(x>=mo?mo:0);\n}\nvoid work()\n{\n\tdp[0][0]=1;\t\n\tFor(i,1,n)\n\t{\n\t\tadd(dp[i][0],dp[i-1][0]*2%mo);\n\t\tFor(j,h[i]+1,h[i-1])add(dp[i][0],dp[i-1][j]*2%mo);\n\t\tint d=(h[i]>h[i-1]?power(2,q[h[i]]-q[h[i-1]]):1);\n\t\tFor(j,1,min(h[i-1],h[i]))dp[i][j]=1ll*dp[i-1][j]*d%mo;\n\t\tFor(j,h[i-1]+1,h[i])\n\t\t{\n\t\t\tif(j>1)dp[i][j]=1ll*dp[i-1][0]*power(2,q[h[i]]-q[j])%mo*(power(2,q[j]-q[j-1])-1)%mo*2%mo;\n\t\t\telse dp[1][1]=1ll*(power(2,q[1])-2)*power(2,q[h[1]]-q[1])%mo;\n\t\t}\n\t}\n\tint ans=0;\n\tFor(i,0,h[n])add(ans,dp[n][i]);\n\twrite(ans,'\\n');\n}\nint main()\n{\n//\tfile();\n\tinput();\n\tinit();\n\twork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\n#define LL long long\n#define fgx cerr<<\"--------------\"<<endl;\n#define dgx cerr<<\"==============\"<<endl;\n\ninline int read(){\n\tint x=0,f=1;char c=getchar();\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0';\n\treturn x*f;\n}\nconst int MAXN = 10010;\nconst int INF = 2147483600;\nconst LL Mod = 1000000007LL;\n\nint N; int a[MAXN+1]; \n\nint f[19][MAXN+1],g[19][MAXN+1],Log2[MAXN+1],mn;\ninline LL Pow(LL a,LL b){\n\tLL ret=1; for(;b;b>>=1,a=a*a%Mod) if(b&1) ret=ret*a%Mod; return ret;\n}\ninline int qry(int l,int r){\n\tint x=Log2[r-l+1]; mn=min(f[x][l],f[x][r-(1<<x)+1]);\n\tif(f[x][l]<=f[x][r-(1<<x)+1]) return g[x][l];\n\telse return g[x][r-(1<<x)+1];\n}\ninline void Init(){\n\tfor(int i=1;i<N;i++) f[0][i]=a[i],g[0][i]=i;\n\tfor(int i=2;i<N;i++) Log2[i]=Log2[i>>1]+1;\n\tfor(int j=1;j<=15;j++){\n\t\tfor(int i=1;i+(1<<j)-1<N;i++){\n\t\t\tf[j][i]=min(f[j-1][i],f[j-1][i+(1<<(j-1))]); g[j][i]=INF;\n\t\t\tif(f[j-1][i]==f[j][i]) g[j][i]=min(g[j][i],g[j-1][i]);\n\t\t\tif(f[j-1][i+(1<<(j-1))]==f[j][i]) g[j][i]=min(g[j][i],g[j-1][i+(1<<(j-1))]); \n\t\t}\n\t}\n} int cnt; int Len[MAXN+1],ln[MAXN+1],rn[MAXN+1],To[MAXN+1],Sum[MAXN+1];\nint nxt[MAXN+1];\ninline int div(int base,int l,int r){\n\tint x=qry(l,r); int bs=mn,id=cnt+1,nx; ln[++cnt]=l; rn[cnt]=r; Sum[cnt]=bs-base; Len[cnt]=Sum[cnt];\n\tint last=l-1; while(x<=r&&x){ if(last+1<x) {nx=div(bs,last+1,x-1); Sum[id]+=Sum[nx];} last=x; x=nxt[x]; } \n\tif(last<r) nx=div(bs,last+1,r),Sum[id]+=Sum[nx];\n\tTo[id]=cnt+1;\n\treturn id;\n}\nint b[MAXN+1],pos[MAXN+1]; LL h[MAXN+1]; LL Pw2[MAXN+1];\n\nint main(){\n\t//freopen(\"a.in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tN=read(); int anspw=0;\n\tfor(int i=1;i<=N;i++) a[i]=read();\n\tif(N==1){\n\t\tprintf(\"%lld\\n\",Pow(2,a[1])); return 0;\n\t}\n\tfor(int i=1;i<=N;i++){\n\t\tif(a[i]>a[i-1]&&a[i]>a[i+1]){\n\t\t\tint d=a[i];\n\t\t\ta[i]=max(a[i-1],a[i+1]); anspw+=d-a[i];\n\t\t}\n\t} for(int i=1;i<=N;i++) a[i]--;\n\tfor(int i=1;i<N;i++) a[i]=min(a[i],a[i+1]),b[i]=a[i];\n\tsort(b+1,b+N); int n=unique(b+1,b+N)-b-1;\n\tfor(int i=1;i<N;i++){\n\t\tint c=lower_bound(b+1,b+n+1,a[i])-b;\n\t\tnxt[pos[c]]=i; pos[c]=i;\n\t} Init(); div(0,1,N-1);\n\th[1]=1; Pw2[0]=1;\n\tfor(int i=1;i<=N;i++) Pw2[i]=Pw2[i-1]*2%Mod;\n\tln[cnt+1]=rn[cnt+1]=N;\n\tfor(int i=1;i<=cnt;i++){\n\t\tif(!To[i]) To[i]=cnt+1;\n\t\t(h[To[i]]+=h[i]*((Pow(2,Sum[i])-Pow(2,Sum[i]-Len[i])+Mod)%Mod)%Mod*Pw2[ln[To[i]]-rn[i]-1]%Mod)%=Mod;\n\t\t(h[i+1]+=h[i]*((Pw2[ln[i+1]-ln[i]]+Mod)%Mod)%Mod)%=Mod;\n\t} \n\tprintf(\"%lld\\n\",h[cnt+1]*Pow(2,anspw)%Mod*2%Mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <fstream>\n#include <iostream>\n#include <algorithm>\n#include <bitset>\n#include <array>\n#include <vector>\n#include <queue>\n#include <set>\n#include <cmath> // 変数名にy1が使えなくなるかも…。\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <string>\n\ntypedef __int128_t int128_t;\nstd::istream &operator>>(std::istream& input, int128_t& value) { // int128_tの入力。入力が64bitに収まる前提。\n    long long tmp; input >> tmp; value = tmp;\n    return input;\n}\nstd::ostream &operator<<(std::ostream& output, const int128_t value) { // int128_tの出力。出力が64bitに収まる前提。\n    output << (long long)value;\n    return output;\n}\n\nint128_t cal_mod(const int128_t n, const int128_t mod) {\n    // n % modを計算する。ただしmod <= 0 ならば何もしない。nが負の場合、正にして補正する。\n    if (mod <= 0) {\n        return n;\n    } else if (0 <= n) {\n        return n % mod;\n    } else {\n        int128_t tmp = (-n) / mod + 1;\n        return (n + tmp * mod) % mod;\n    }\n}\n\nint128_t pow_mod(int128_t x, int128_t n, const int128_t mod) {\n    // 累乗の計算。mod <= 0ならば余りの計算は行わない。\n    int128_t ret = 1;\n    while (n > 0) {\n        if (n & 1) { ret = cal_mod(ret * x, mod); }\n        x = cal_mod(x * x, mod);\n        n = (n >> 1);\n    }\n    return ret;\n}\n\nconst int128_t MOD = 1e9 + 7;\nconst int MAX_H = 1e9 + 7;\nconst int MAX_N = 110;\nint N;\nint128_t h[MAX_N];\n\nint128_t s[MAX_N]; // s[i]:i番目に低い山（高さ2以上）の高さ。\nstd::map<int128_t, int> mp; // 2以上の高さに対して、何番目に低いか。\n\nint128_t dp[MAX_N][MAX_N] = {};\n// dp[i][j] : i番目の列まで塗終わり、その列で最初に現れる連続同色がs[j]の高さに収まる(s[j-1]には収まらない)塗り方の数。\n// dp[i][0] は、連続同色が現れない塗り方。\n\nint128_t calc_sub(int128_t h1, int128_t h2) {\n    // h1まで交互に塗った1つの塗り方に対して、h2までに連続塗りを含む塗り方がいくつあるか。\n    return cal_mod(pow_mod(2, h2 - h1, MOD) - 1, MOD);\n}\n\nint main(int argc, char **argv) {\n    std::cin >> N;\n    \n    for (int i = 1; i <= N; i++) {\n        std::cin >> h[i];\n    }\n\n    for (int i = 1; i <= N; i++) {\n        if (1 < h[i]) {\n            mp[h[i]] = 1;\n        }\n    }\n    int cnt = 1;\n    for (auto itr = mp.begin(); itr != mp.end(); ++itr) {\n        mp[itr->first] = cnt;\n        s[cnt] = itr->first;\n        cnt++;\n    }\n    s[0] = 1;\n    s[cnt] = MAX_H;\n    dp[0][0] = 1;\n\n    //std::cout << \"check:\" << s[0] << \" \" << s[1] << \" \" << s[2] << \" \" << s[3] << std::endl;\n\n    for (int i = 1; i <= N; i++) {\n        if (h[i] == 1) {\n            for (int j = 0; j < cnt; j++) {\n                dp[i][0] = (dp[i][0] + dp[i-1][j] * 2) % MOD;\n            }\n        } else if (i == 1 || h[i-1] == 1) {\n            dp[i][0] = dp[i-1][0] * 2;\n            for (int j = 1; s[j] <= h[i]; j++) {\n                dp[i][j] = (dp[i-1][0] * (int128_t)2 * calc_sub(s[j-1], s[j]) * pow_mod(2, h[i] - s[j], MOD)) % MOD;\n                //dp[i][j] = ((dp[i-1][0] * 2) % MOD) * ((calc_sub(s[j-1], s[j]) * pow_mod(2, h[i] - s[j], MOD)) % MOD) % MOD;\n            }\n        } else {\n            dp[i][0] = dp[i-1][0] * 2;\n            if (h[i] <= h[i-1]) {\n                for (int j = 1; s[j] <= h[i-1]; j++) {\n                    if (s[j] <= h[i]) {\n                        dp[i][j] = dp[i-1][j];\n                    } else {\n                        dp[i][0] = (dp[i][0] + dp[i-1][j] * 2) % MOD;\n                    }\n                }\n            } else {\n                for (int j = 1; s[j] <= h[i]; j++) {\n                    if (s[j] <= h[i-1]) {\n                        dp[i][j] = (dp[i-1][j] * pow_mod(2, h[i] - h[i-1], MOD)) % MOD;\n                    } else {\n                        dp[i][j] = (dp[i-1][0] * (int128_t)2 * calc_sub(s[j-1], s[j]) * pow_mod(2, h[i] - s[j], MOD)) % MOD;\n                        //dp[i][j] = ((dp[i-1][0] * 2) % MOD) * ((calc_sub(s[j-1], s[j]) * pow_mod(2, h[i] - s[j], MOD)) % MOD) % MOD;\n                    }\n                }\n            }\n        }\n        //std::cout << \"dp:\" << dp[i][0] << \" \" << dp[i][1] << \" \" << dp[i][2] << std::endl;\n    }\n\n    int128_t ret = 0;\n    for (int j = 0; s[j] <= h[N]; j++) {\n        ret = (ret + dp[N][j]) % MOD;\n    }\n    std::cout << ret << std::endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 14.07.2018 16:07:03       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring to_string(string s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nconst int md = (int) 1e9 + 7;\n\ninline void add(int &a, int b) {\n  a += b;\n  if (a >= md) a -= md;\n}\n\ninline void sub(int &a, int b) {\n  a -= b;\n  if (a < 0) a += md;\n}\n\ninline int mul(int a, int b) {\n#if !defined(_WIN32) || defined(_WIN64)\n  return (int) ((long long) a * b % md);\n#endif\n  unsigned long long x = (long long) a * b;\n  unsigned xh = (unsigned) (x >> 32), xl = (unsigned) x, d, m;\n  asm(\n    \"divl %4; \\n\\t\"\n    : \"=a\" (d), \"=d\" (m)\n    : \"d\" (xh), \"a\" (xl), \"r\" (md)\n  );\n  return m;\n}\n\ninline int power(int a, long long b) {\n  int res = 1;\n  while (b > 0) {\n    if (b & 1) {\n      res = mul(res, a);\n    }\n    a = mul(a, a);\n    b >>= 1;\n  }\n  return res;\n}\n\ninline int inv(int a) {\n  a %= md;\n  if (a < 0) a += md;\n  int b = md, u = 0, v = 1;\n  while (a) {\n    int t = b / a;\n    b -= t * a; swap(a, b);\n    u -= t * v; swap(u, v);\n  }\n  assert(b == 1);\n  if (u < 0) u += md;\n  return u;\n}\n\n// (chess, not)\n\npair<int,int> solve(vector<int> a) {\n  int n = (int) a.size();\n  int mn = *min_element(a.begin(), a.end());\n  vector<int> b(n);\n  int zeros = 0;\n  for (int i = 0; i < n; i++) {\n    b[i] = a[i] - mn;\n    zeros += (b[i] == 0);\n  }\n  if (zeros == n) {\n    int ans = md - 2;\n    add(ans, power(2, n));\n    auto res = make_pair(power(2, mn), ans);\n    debug(a, res.first, res.second);\n    return res;\n  }\n  vector<vector<int>> children;\n  int beg = 0;\n  while (beg < n) {\n    if (b[beg] == 0) {\n      beg++;\n      continue;\n    }\n    int end = beg;\n    while (end + 1 < n && b[end + 1] > 0) {\n      end++;\n    }\n    vector<int> c;\n    for (int i = beg; i <= end; i++) {\n      c.push_back(b[i]);\n    }\n    children.push_back(c);\n    beg = end + 1;\n  }\n  vector<pair<int,int>> aux;\n  for (auto &v : children) {\n    aux.push_back(solve(v));\n  }\n  int chess = 1;\n  for (auto &p : aux) {\n    chess = mul(chess, p.first);\n  }\n  chess = mul(chess, 2);\n  int nott = 1;\n  for (auto &p : aux) {\n    int cur = mul(p.first, 2);\n    add(cur, p.second);\n    nott = mul(nott, cur);\n  }\n  nott = mul(nott, power(2, zeros));\n  sub(nott, chess);\n  chess = mul(chess, power(2, mn - 1));\n  debug(a, chess, nott);\n  return make_pair(chess, nott);\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  pair<int,int> p = solve(a);\n  cout << (p.first + p.second) % md << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\nconst ll MOD = 1000000007;\n\ninline void add(ll &x, ll y) { x += y; if (x >= MOD) x -= MOD; }\n\nll mod_pow(ll x, ll k) {\n\tll res = 1;\n\tfor (; k; x = x * x % MOD, k /= 2) {\n\t\tif (k & 1) {\n\t\t\tres = res * x % MOD;\n\t\t}\n\t}\n\treturn res;\n}\n\nint N;\nint h[110];\nint mh[110][110];\nll dp[110][110][2][2][2]; //left, right, same\nll sub[110][2][2][2]; //left, right, same\nll tb[110][110][2][2][2];\n\nvoid calc(int l, int r, int lo, int &pt) {\n\t//cerr << l << \" \" << r << \" \" << lo << endl;\n\n\tbool sm = 1;\n\tfor (int i = l; i <= r; ++i) if (mh[l][r] != h[i]) {\n\t\tsm = 0;\n\t}\n\n\tint now = pt++;\n\tif (sm) {\n\t\trep(j, 2) {\n\t\t\trep(k, 2) {\n\t\t\t\trep(t, 2) {\n\t\t\t\t\ttb[now][r][j][k][t] = sub[r-l+1][j][k][t];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tint la = -1;\n\n\t\tfor (int m = l; m <= r; ++m) {\n\t\t\tif (h[m] == mh[l][r]) {\n\t\t\t\tif (la != -1) {\n\t\t\t\t\tcalc(la, m-1, mh[l][r], pt);\n\t\t\t\t\tif (la == l) {\n\t\t\t\t\t\trep(j, 2) {\n\t\t\t\t\t\t\trep(k, 2) {\n\t\t\t\t\t\t\t\trep(t, 2) {\n\t\t\t\t\t\t\t\t\tif (t == 1) {\n\t\t\t\t\t\t\t\t\t\tadd(tb[now][m-1][j^1][k^1][t], dp[la][m-1][j][k][t]);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tadd(tb[now][m-1][j^1][k^1][t], dp[la][m-1][j][k][t]);\n\t\t\t\t\t\t\t\t\t\tadd(tb[now][m-1][j][k][t], dp[la][m-1][j][k][t]);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\trep(j, 2) {\n\t\t\t\t\t\t\trep(k, 2) {\n\t\t\t\t\t\t\t\trep(t, 2) {\n\t\t\t\t\t\t\t\t\trep(jj, 2) {\n\t\t\t\t\t\t\t\t\t\trep(kk, 2) {\n\t\t\t\t\t\t\t\t\t\t\trep(tt, 2) {\n\t\t\t\t\t\t\t\t\t\t\t\tint nj, nk, nt;\n\t\t\t\t\t\t\t\t\t\t\t\tif (tt == 1) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tnj = j, nk = kk ^ 1, nt = (t | tt) | (k == (jj ^ 1));\n\t\t\t\t\t\t\t\t\t\t\t\t\tadd(tb[now][m-1][nj][nk][nt], tb[now][la-1][j][k][t] * dp[la][m-1][jj][kk][tt] % MOD);\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\tnj = j, nk = kk ^ 1, nt = (t | tt) | (k == (jj ^ 1));\n\t\t\t\t\t\t\t\t\t\t\t\t\tadd(tb[now][m-1][nj][nk][nt], tb[now][la-1][j][k][t] * dp[la][m-1][jj][kk][tt] % MOD);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\tnj = j, nk = kk, nt = (t | tt) | (k == jj);\n\t\t\t\t\t\t\t\t\t\t\t\t\tadd(tb[now][m-1][nj][nk][nt], tb[now][la-1][j][k][t] * dp[la][m-1][jj][kk][tt] % MOD);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (m == l) {\n\t\t\t\t\ttb[now][l][0][0][0] = tb[now][l][1][1][0] = 1;\n\t\t\t\t} else {\n\t\t\t\t\trep(j, 2) {\n\t\t\t\t\t\trep(k, 2) {\n\t\t\t\t\t\t\trep(t, 2) {\n\t\t\t\t\t\t\t\tif (tb[now][m-1][j][k][t] == 0) continue; \n\t\t\t\t\t\t\t\trep(nx, 2) {\n\t\t\t\t\t\t\t\t\tadd(tb[now][m][j][nx][t | (nx == k)], tb[now][m-1][j][k][t]); \n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tla = -1;\n\t\t\t} else if (h[m] > mh[l][r]) {\n\t\t\t\tif (la == -1) {\n\t\t\t\t\tla = m;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (la != -1) {\n\t\t\tcalc(la, r, mh[l][r], pt);\n\n\t\t\trep(j, 2) {\n\t\t\t\trep(k, 2) {\n\t\t\t\t\trep(t, 2) {\n\t\t\t\t\t\tif (tb[la-1][j][k][t] == 0) continue;\n\t\t\t\t\t\trep(jj, 2) {\n\t\t\t\t\t\t\trep(kk, 2) {\n\t\t\t\t\t\t\t\trep(tt, 2) {\n\t\t\t\t\t\t\t\t\tif (dp[la][r][jj][kk][tt] == 0) continue;\n\t\t\t\t\t\t\t\t\tint nj, nk, nt;\n\t\t\t\t\t\t\t\t\tif (tt == 1) {\n\t\t\t\t\t\t\t\t\t\tnj = j, nk = kk ^ 1, nt = ((t | tt) | (k == (jj ^ 1)));\n\t\t\t\t\t\t\t\t\t\tadd(tb[now][r][nj][nk][nt], tb[now][la-1][j][k][t] * dp[la][r][jj][kk][tt] % MOD);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tnj = j, nk = kk ^ 1, nt = ((t | tt) | (k == (jj ^ 1)));\n\t\t\t\t\t\t\t\t\t\tadd(tb[now][r][nj][nk][nt], tb[now][la-1][j][k][t] * dp[la][r][jj][kk][tt] % MOD);\n\n\t\t\t\t\t\t\t\t\t\tnj = j, nk = kk, nt = ((t | tt) | (k == jj));\n\t\t\t\t\t\t\t\t\t\tadd(tb[now][r][nj][nk][nt], tb[now][la-1][j][k][t] * dp[la][r][jj][kk][tt] % MOD);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint num = mh[l][r] - lo - 1;\n\tll p[2];\n\n\tif (num == 0) {\n\t\tp[0] = 1;\n\t\tp[1] = 0;\n\t} else {\n\t\tp[0] = p[1] = mod_pow(2, num - 1);\n\t}\n\n\trep(j, 2) {\n\t\trep(k, 2) {\n\t\t\trep(t, 2) {\n\t\t\t\tif (t == 1) {\n\t\t\t\t\tbool b = (num & 1);\n\t\t\t\t\tadd(dp[l][r][j^b][k^b][t], tb[now][r][j][k][t]);\n\t\t\t\t} else {\n\t\t\t\t\trep(b, 2) {\n\t\t\t\t\t\tadd(dp[l][r][j^b][k^b][t], tb[now][r][j][k][t] * p[b] % MOD);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> N;\n\trep(i, N) cin >> h[i];\n\tll pp = 1;\n\n\tif (N >= 2) {\n\t\tif (h[0] > h[1]) {\n\t\t\tpp = pp * mod_pow(2, h[0] - h[1]) % MOD;\n\t\t\th[0] = h[1];\n\t\t}\n\t\tif (h[N-2] < h[N-1]) {\n\t\t\tpp = pp * mod_pow(2, h[N-1] - h[N-2]) % MOD;\n\t\t\th[N-1] = h[N-2];\n\t\t}\n\t}\n\n\twhile (true) {\n\t\tbool fd = 0;\n\t\trep(i, N) {\n\t\t\tif (i > 0 && i + 1 < N && h[i] > h[i+1] && h[i] > h[i-1]) {\n\t\t\t\tpp = pp * mod_pow(2, h[i] - max(h[i-1], h[i+1])) % MOD;\n\t\t\t\th[i] = max(h[i-1], h[i+1]);\n\t\t\t\tfd = 1;\n\t\t\t}\n\t\t}\n\t\tif (!fd) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trep(i, N) {\n\t\tint d = 2e9;\n\t\tfor (int j = i; j < N; ++j) {\n\t\t\td = min(d, h[j]);\n\t\t\tmh[i][j] = d;\n\t\t}\n\t}\n\n\tsub[1][0][0][0] = sub[1][1][1][0] = 1;\n\n\tfor (int i = 1; i < N; ++i) {\n\t\trep(j, 2) {\n\t\t\trep(k, 2) {\n\t\t\t\trep(l, 2) {\n\t\t\t\t\tif (sub[i][j][k][l] == 0) continue;\n\t\t\t\t\trep(nx, 2) {\n\t\t\t\t\t\tadd(sub[i+1][j][nx][l | (k == nx)], sub[i][j][k][l]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint k = 0;\n\tcalc(0, N-1, 0, k);\n\tll ret = 0;\n\trep(j, 2) {\n\t\trep(k, 2) {\n\t\t\trep(t, 2) {\n\t\t\t\tadd(ret, dp[0][N-1][j][k][t]);\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ret * pp % MOD << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\nconst int N=100,mod=1e9+7;\nint n,h[N+1];\nint f[N+1][N+1];\nint pow(int x,int times)\n{\n\tint ret=1;\n\twhile(times) {\n\t\tif(times&1) {\n\t\t\tret=1ll*ret*x%mod;\n\t\t}\n\t\ttimes>>=1,x=1ll*x*x%mod;\n\t}\n\treturn ret;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i) {\n\t\tscanf(\"%d\",&h[i]);\n\t}\n\th[0]=1,f[0][0]=1;\n\tfor(int i=1;i<=n;++i) {\n\t\tfor(int j=0;j<=n;++j) {\n\t\t\tif(h[j]>h[i]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(h[j]<h[i-1]) {\n\t\t\t\tif(h[i]<h[i-1]) {\n\t\t\t\t\tf[i][j]=(f[i-1][j]+f[i-1][i])%mod;\n\t\t\t\t} else {\n\t\t\t\t\tf[i][j]=1ll*(f[i-1][j]+f[i-1][i-1])*pow(2,h[i]-h[i-1])%mod;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tf[i][j]=2ll*f[i-1][i-1]*pow(2,h[i]-h[j])%mod;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",f[n][0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define SORT(a) sort(a.begin(), a.end())\n#define REVERSE(a) reverse(a.begin(), a.end())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define int long long\n#define INF 1000000000000000000\nusing namespace std;\n\n#define ANS(f) if(f) cout << \"YES\" << endl; else cout << \"NO\" << endl;\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\ntypedef pair<int, int> Pii;\n\ntemplate<typename T>\nvoid readv(vector<T> &a){ REP(i, a.size()) cin >> a[i]; }\nvoid readi(vector<int> &a){ REP(i, a.size()){cin >> a[i]; a[i]--;} }\nvoid debug(mat m){REP(i, m.size()){ REP(j, m[0].size()){ cout << m[i][j] << \",\"; } cout << endl; }}\n\nint modpow(int x, int n, int m){\n    int a = 1;\n    IREP(i, 64){\n        a = (a * a) % m;\n        if(((n >> i) & 1) == 1) a = (a * x) % m;\n    }\n    return a;\n}\n\nsigned main(){\n\n    int N; cin >> N;\n    vec h(N + 1, 1); REP(i, N) cin >> h[i + 1];\n    int mod = 1000000007;\n\n    set<int> s;\n    REP(i, N + 1) s.insert(h[i]);\n    map<int, int> m;\n    vec v(0);\n    for(int i: s) v.push_back(i);\n    int n = v.size();\n    //REP(i, n) cout << v[i] << endl;\n\n    mat dp(N + 1, vec(n + 1, 0));\n    dp[0][n] = 1;\n    REP(i, N){\n        int j0 = Lower_bound(v, h[i]);\n        int j1 = Lower_bound(v, h[i + 1]);\n        if(j1 <= j0){\n            REP(j, j1 + 1){\n                dp[i + 1][j] = dp[i][j];\n            }\n            FOR(j, j1 + 1, n + 1){\n                dp[i + 1][n] += 2 * dp[i][j];\n                dp[i + 1][n] %= mod;\n            }\n        }else{\n            REP(j, j0 + 1){\n                dp[i + 1][j] = (dp[i][j] * modpow(2, h[i + 1] - h[i], mod)) % mod;\n            }\n            FOR(j, j0 + 1, j1 + 1){\n                int tmp = ((modpow(2, v[j] - v[j - 1], mod) + mod - 1) * modpow(2, h[i + 1] - v[j], mod)) % mod;\n                dp[i + 1][j] = (2 * dp[i][n] * tmp) % mod;\n            }\n            dp[i + 1][n] = (2 * dp[i][n]) % mod;\n        }\n    }\n\n    //debug(dp);\n\n    int ans = 0;\n    REP(i, n + 1) ans = (ans + dp[N][i]) % mod;\n    cout << ans;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int P=1e9+7;\nconst int N=205;\nconst int Gi=(P+1)/2;\n#define ll long long\nll fsp(ll x,int y){\n\tll ans=1;\n\twhile(y){\n\t\tif(y&1)\tans=ans*x%P;\n\t\tx=x*x%P,y>>=1;\n\t}\n\treturn ans;\n}\nll f[N][2];\nvector<int>ch[N];\nint n,top,a[N],st[N],len[N];\nvoid dp(int x,int fl){\n\tint si=ch[x].size();\n\tfor(int i=0;i<si;i++)\tdp(ch[x][i],a[x]);\n\tif(!si){\n\t\tf[x][0]=fsp(2,len[x])-2;\n\t\tf[x][1]=fsp(2,a[x]-fl);\n\t}\n\telse{\n\t\tll r1=1,r2=1;\n\t\tfor(int i=0;i<si;i++){\n\t\t\tr1=r1*(f[ch[x][i]][0]+f[ch[x][i]][1]*2)%P;\n\t\t\tr2=r2*f[ch[x][i]][1]%P;\n\t\t}\n\t\tf[x][0]=((r1-r2+P)*fsp(2,len[x])+r2*(fsp(2,len[x])-2))%P;\n\t\tf[x][1]=r2*fsp(2,a[x]-fl)%P;\n\t}\n}\nint main(){\n\t\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\tscanf(\"%d\",&a[i]),len[i]=1;\n\tfor(int i=1;i<=n;i++){\n\t\twhile(top&&a[st[top]]>=a[i]){\n\t\t\tif(a[st[top]]==a[i])\tlen[i]+=len[st[top]],swap(ch[st[top]],ch[i]);\n\t\t\telse{\n\t\t\t\tif(a[st[top-1]]>=a[i])\tch[st[top-1]].push_back(st[top]);\n\t\t\t\telse\tch[i].push_back(st[top]);\n\t\t\t}\n\t\t\ttop--;\n\t\t}\n\t\tst[++top]=i;\n\t}\n\twhile(top>1)\tch[st[top-1]].push_back(st[top]),top--;\n\n\tdp(st[top],0);\n\tprintf(\"%lld\\n\",(f[st[1]][0]+f[st[1]][1])%P);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*\nCoded by 秦惜梦\nThe most attractive girl in the world\n@@@@@@@@@@##&|;!!!!!!!!!!||||||||%%%%%$$$$$$$$$$$$%%$$$&&&&&&&&&$$&&&&&&&&&@@@&%||||||$&&&&@&%;'```'`':!||%&@@@@#@&&&&&@@@&&$$$&&@@&$$$&@@@@@@@@@@@@@#@@@@@@@@@@#@@@@@#@@@@@@@@@@##$\n@@@@@@@@@####$!;!!!!!!!!!||||||||%%%%%%%%%%%%%%%$$$$&&&&&&&&&&&&&&&&&&&&@@@@@@&%|||||!:'`'!$&&&&&&%:''!|||$&&&@@@@@@&&&&&@@@&$$$&&@&&$&&@@@@@@@@@@@@@@@@@@@@@@@@##@@@@#@@@@@@@@@@#@%\n@@@@@@@@@####@|;!!!!!!!!!|||||||%%%%%%%%%%%%%$$$$$$$$$$&&&&&&&&&&&&&&&@@@@@@@@&%|;:'''''``````'!$&&&@@&|:;%$$&&&@@@@@&&&&&@@@&$$$&&@@@@@@@@@@@@@@@@@@@@@@@#@@@@@#@@@@@#@@@@#@@@@##@%\n@@@@@@@@####@@&|;!!!!!!!!|||||||%%%%%%%%%%%%%%$$$$$$$$&&&&&&&&&&&$$$&&@@@@@@@@@@&$|;'''''````````'':!$&&&$%%%%$$&@@@@@&&&&&@@@@&&&@@#@@@@@@@@@@@@@@@@@@@@@@@@@@@#@@@@@@@@@@#@@@@#@@%\n@@@@@@@#####@@@$!;!!!!!!|||||||%%%$$$$$%%%%%%%%%$$$$$$$&&&&&&&&&$$$$&&@@@@@@@@$%$&@@&&&@&$%;:':;:''`````'|%%%%%%$$&@@@@@&&&&@@#@@@@@@#@@@@@@@@@@@@@@@@#@@@@@@@@@#@@@@@@@@@@@@@@#@@@%\n@@@@@@#####@$%%%$$$%%%||%%||||%%%%$%%$$$$$%%%%%%%$$$$&&&&&&&&&$$$$$$&&@@@@@@@&$;'''''':!%&&&&&&@@&%;'```:$&&%%%%%$$$&@@@@&&&&@@@@@@@@@#@@@@@##@@@@@@@@#@@@@@@@@@@@@@@#@@@@@@@@@#@@@%\n$&@@@@######&&&&&$%%%%|%|||||||%%%%%$$$$$$$$$$$$$&&&&&&&&&&&&&&&&$$$$&&@@@@@@&$!''''''````````:!|$&&&&&&&$&&&$%%%%$$$&&@@@&&&&&@@@@&@@@@@@@@@#@@@@@@@@#@@@@@&&&@@@@@@@@@@@@@@@#@@@@$\n$$$&@######@&&&&&&|!!!!!|||||||%%$$$$$$$$$$$$$$$&&&&&$$&&&&&&&&&&&&$$&&&@@@@@@&%;::''````````'':'``....`;|%$&&&$%%$$$$$&@@@&&&&&@@@@@@@@#@@@@@#@@@@@@@@@@@@@@&&@&&&&&&&&&@@@@@@@@@@$\n$$$&@#####@&$$&&@#&|!!!!!|||||||%%%$$$$%%%%%$$$$$$$&&&&&&&&&&&&@@@@@&&&&&&@@@@@@@@@@@&&&&&&&&@@@@&&$$%||||%%%$$&&&$$$$$$$&@@@&&&&&@@@@@@@#@@@@@@@@@@@@@@@@@@@@&&@&&&&&&&&@@@@@@@@@#$\n$$&@######@&$&@##@&$|!!!!|||||||%%%%%%%%%%%%%$$$$&&&&&&&&&&&&&&&&&&&&$$&&&&&&@@&|'`````````':::;;;;;;!|%%%%%%%%$&@@&$$$$$$$&@@&&&&&@@@@@@@@@@@@@@@@@@@@#@@@@@@@@@&&&&&&&&&@@@@@@@#@%\n$&@######@&&&@##@$$$$|!!!||||||||%%%%%%%%%%%%$$$$&&&&&&&&&&&&&&&&&&&&$&&&&&&&&@@$!:::'':::::::::::::''``.:%%$$$$$$&@@@&$$$$$&@@@&&&&@@@@@@@@@@@@#@@@@@@@@@@#@@@@#@@@@@@&&&@@@@@@@@@%\n$&@######@&&@#@&$$$$&$|!!!||||||||%%%%%%%%%$$$$$&&&&&&&&&&&&&&&&&&&$$$&&&&&&&&&&&%;::::::::::::':''':'':::%&$$$$$$$$&&@@&$$$$$&@@@&&&&@@@@@@@@@@@@@@@@@@#@@@@@@@@@@@@@@@@@@@@@@@@@@%\n&@#######@@@#@&$$$$$&&$|!!|||||||||%%%%%%$$$$$$$$$&&&&&&&&&&&&&&&$$$$$&&&&&&&&&&&$!''::::'''::;!|%%$&&@@@@&&@@$$%%$$$$&&@&&$$$$&@@@&&&&@@@@@@#@@@@@@@@@@@@@@@@@#@@@@@@@@@@@@@@@@@@@%\n############&$$$$$$$&&&$|!!||||||||%%%%%%$$$$$$$$$$$$$$&&&&&$$$$$$$$$$&&&&&&&&&&&&@@@&&&&&&&@@@@@@&&&$$%|!;%@@@@&$$$$$$$$&@@&$$$$&@@@&&&@@@@@@@@@#@@@@@@#@@#@@@@@@@@@@@@@@@@@@@@@@@$\n########@&$$$$$$$$$&&&&&$|!!||||||%%%%%%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$&&@@&&&&&&&&&&&&&&$$$$$$$$$$&&&$$%!;:::|$&@@@@&$$$$$$$&@@&$$$&@@@&&&@@@@@@@@##@@@@@@@@@@@@#@@@@@@@@@@@@@@@@@@@$\n########@$%%%$$$$$$&&&&&&&%!||||%%%$$$%%%%%%%%%%%%%%%%%%%%%%%$$$$$&&&&&&&&&&@@@&&&&&&&&&&&&$$$$$$$$$$$$$&&%!!$$$$&@@@@&$$$$$$&@@@&&&&@@@&&@@@@@@@##@@@@@#@@@@@@@@@@@@@@@@@@@@@@@@@@%\n#######@&$$$$$$$$$$$$&$|!||%%%%||%%%%%%%%%%%%%%%%%$$$$$$&$$$$$&&&&&&&&@@@@&&&&&&&&&&&&&&&&&&&$$&&$$$$$$$$$&&&$&@&$$$&@@@&$$$$$$&@@@@&&@@@@&@@@@@@###@@@@@@@@@@@@@@@@@@@@@@@@#@@@@#@%\n#######@$$$$$$%$$$$$$$&&$||||%%%%%%$$$$$$$$$$$$$$$$$$$$$$$&&&&&&&&&&@@&&&&&&&&&&&&$$$$$$&&&&$$$$$$$$$$$$$$$$$$&@@@@&$$$&@@@&$$$$&&&@@@&@@@@&&@@@@@###@@@@#@@@@@#@@@@@@@@@@@#@@@@#@@$\n#######&$$$$$$$$$$&$$$$$&&&&&$%||%%%%%%$$$$$$$$$$$$$$$$$&&&&&&&&&&&@&&&&&&&&&&&&$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$&&@@@&$$$&@@@&$$&&&@@@@@@#@@@@@@@@##@@@@#@@@@@@@@@@@@@#@@@@@@##@##$\n######@$$$$$$$$$$$$$$$$$$&&&&&&$||%%%%%%%$$$$$$$$$$$$$&&&&&&&&&@@&&&&&&&&&&&&&&$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$&@@@@@&&$&&@@@&&&&&@@@@@##@@@@@@@##@@@###@@@@@@@@@@@@@@#@@@#@#@@%\n######&$$$$$$$$$$$$$$$$$&&&&&&&&$%|%%%%%%%$$$$$$$$$$&&&&&&&&&&@&&@@&&&&&&&&&&$$$$$$$$$$$$$$$$$$$$$$$&$$$$$$$$$$$$$$$$&@@@@@@&&&&&@@@&&&&@@@@@#@@@@@###@@@##@@@@@@@@@@@@@@#@@@####@#$\n#####@$$$$$$$$$$$$$$$$$$$&&&&&&&&&%%%%%%%%%$$$$$$$$&&&&&&&&&&&&&&&&&&&&&&&&$$$$$$$$$$$$$$$$$$$$$$$$$$&$$$$$$$$$$$$$$$$$&&&@@@@@&&&&@@@@@@@@@@@@#@@@@###@@@$%%%%%%%%%%%%%$&@@#######$\n#####@&$%$$$$$$$$$$$$$$$$$$&&&&&&&&$%%%%%%%%%%$$$$&&&&&&&&&&&&&&&&$$$$$$$$$$$$$$$$$$$$$$$$$$%$$$$$$$$$%%$$$$$$$$%%$$$$$%&@&&&&@@@@@&&@@@@@&&@@@@#@@@@###@&%%%%%%%%%%%%%%%%%&@##@##@%\n####@@@@&$$$$$$$$$$$$$$$$$$&&&&&&&&&&%%%%%%%%%%$$&@&&&&$&&&$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$||$$$$$$$$%%$$$$$|%$$$$$$$%%$&@@@&&&@@@@@@@@@@@@&@@@@@@@@##@&%%%%%%%%%%%%%%%%%%%$@@@@@%\n####@@@@@@&$%$$$$$$$$$$$$$$$$$&&&&&&&&$%%%%%%%$&&&&&$$$$$$&$$$$$$$$$$$$$$$$$$$$$$$%%$$$%%%%|!|||$$$$%!|%%%$$&$$$$$$$$$$%%%$&@#@@@@&&@@@@@@@@@@@@@@##@@@@#@@@&$$%%%%%%%%|%%%%%|$@@@@$\n###@@@@@@@@$$$%$$$$$$$$$$$$$&&&&&&&&&&&&%%%%%&&&&&$%%%$$&&&$$$$$$$$$%%%$$|%$$$%%%$%%|%%!;!||!!||%$$$$$$$%%$&$$&&$$$$$$$$$$%%$@@#@@@@@@&&@@@@@@@@#@@###@@@########@@$%%%%%%%|%%$&@##$\n##@@@@@@@@@&$$$&$$$$$$$$$$$$$$$&&&&&&&&&&&%%%$&%|%%%%%$%%$$%%%%%%$$$%%%$$||%%%$$$$$%%%%%$$$$$%!!|%&&$$$$%|$$$$$$&$$$$$$$$$$$%$$&@@@@@@@@@@@@@@@##@@@@##@@####@@#######&%%%%%%%$@###$\n#@@@@@@@@@@&&$$&$$$$$$$$$$$$$$$&&&&&&$||%%%$$%!;!;!|%%%%$%!||||%%%$$$||%$%%%%%%$$$$%$$%%%%$%$$$$||$&&$$&%|%$$$$$$$&$%%$%|%$$$$%$%$@@@@@@##@@@@@@@@@@########@##@@@######&$$&@@@@@##$\n@$$&@@@@@@@&&$$$$$$$$$$$$$$$$$$&&&$&&&&$$&$$%!|%%%%%%%%%%||%%%%%%%%$$||%$$$$%%%%$$$%%$$%%%%%%%$$%|%&&$$&$%%$$$$$$$&&$%%&&&&$$$$$$$||$@@@@@@@@@@@@@@@@@@@####@@@@##@@@#@@@@@@@@@@@@@%\n&$%%$$&&&$$$$$$$$$$$$$$$$$$$$$$$$$$&&&&&&&&|!|%%%%|%%%%%%$%%%%||||%$$%|%$&&$%%%%$$$$%$$%%%%$$$$$%|$&&&$&$$$&$&$$$$&&&$%$&&&$$&&&&&$%!!|$&@@@@@@@@@@@@@@@@###@@@@@@@@@@@@@@@@@@@@@@@%\n$$%$$$$$$$$$$$$$$$$$$$$$$$$$$$$&&&$&&&&&&$|!|||%%|%%%%%%$$%%%%||||%$$%%%$&&$%%%$$&&&$$$$$$$$$$$$$%%&&&&&$$&&$&$$&&&&&&&&&&&&&&&&&&&&$|!!!!$&@@@@@@@@@@@#####@######@##@@&@@@@@@@@@@$\n$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$&&&&&&$|!|||%$%%%%%%%$$$$%%%||||%$$%%%$&&$$%%$&&&&&$$$$$$$$$$$$%%&&&&&$$&&$&$$&&&&&&&&&&&&&&&&&&&&&&%!!!!|&&&@@@@@@#########@########@@##########$\n$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$&&&&&$&$%|!||%$$%%$%%%%$$$$$%%|||||$$$&$$&$$$%$&&&&&&$$$$$%$$$$$$%$&&&&&&&&&&&$$&&&&&&&&&&&&&&@@&&&&&@@$|!$@&||||%&@#@@####@########@@@@@@@#@&&@@##$\n$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$&&&$$&$%|!||%$$%%%%%%%$$$%$$%%||||%$&&&&&&$$$$$$&&&&&$%$$$%%$$$$$%$&&&&&&&&$$$$$&&&&&&&&&&&&&&@@@&&@@@@@&@@&|||||||||%&@###############@@@@@@##@@@@%\n%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$&$&&$$$$%!!|%$$$%%%%%%$$$$%$$$%||||$&&$$&&$$$$$$$&&&$&$%%$%%%%%%$$%$$$&&&&&$$$$$$&&&&&&$&&&&&&&&&&&&&&&@@@@&||||||||||||$@#####@@@########@@@@@###@@$\n%%%%%%%%$$$$$$$$$$$$$$$$$$$$$$$$$&&%%&%!!||%$$%%$$%%$$$$%%$$%%|!|%&&$%%&&$%%%%$$$&$|%$||$%%%%%%$$$$$$&&&&$$$$$$&&&&&&$$$&&&&&&&&&&@@&&&@@@&&%|||||||||%&@@##@$$@@@@########@@@@@@##$\n;:''':;!|%%$$$$$$$$$$$$$$&&&&&&&&%%&&$!!|%%%%%%%$$$$$$$%%%$%%%|||$$&%!%&$%%%%|%%%&%!|$||%%%%%%%$$$$%%$&&$$$$$$$&&&&&&$$$$&&&&&&&&&&&&&&@@@@&&%|||||||%@@@@#@%|&#$||||%&@@@@@@@@@@@@$\n.....  .`;|%%$$$$$$$$$$$&&&&&&$%%$&&$!;|%%|||%%$$&&&&$$%%$$%%%%%%%&%!;|$$%||||%%%$|;!%||$%$$$$$%%%%||$&$%%%$$$$&&&&&&$$$$&&&&&&&&&&&&&@@@@@@&&%|||||$@@@##&%|%@@%||||||||||&@@@@@@@%\n........  `;|%$$$&&&&&&&&&&&$%$&&&&$|!|%%|!!|||$&$&&&$$%%%%%||||%$$|;;|%%|||||%$&&$|!|!!%%%%%%|!!|%!%$$%||%$&$&&&&&&&$$$$&&&&&&&&&&&&@@@@@@@@&&%|||$@@@##@$||$#&|||||||||||&#$|||||!\n...    ..  `;|%$$$$&&&&&&$%$$&&&&&&||%%$||!!||$&$$$$$$%%%%%%||||%$%!:!!!%%$$$%%%%|!;;;;;!!!!!;;;||!%&%|%%%$&&$&&&&&&&$$$$&&&&&&&&&&&@@@@@@@@@&&$||$@##@@@%||%&@$||||||||||%&@$|||||!\n       ..  .'!|%$$&&&&&&&&&&&&&&&&||$$&%||!||%&&$$$$$$%%$%||||||%|!;:;;;|%|!!!!!|!|$$&&&&$$$%!!!!;|&&$%%%$&$$$$%||&@&$$$$&&&&&&&&&@@@@@@@@@@@@&$|%@@@@#@%|||$@&%||||||||||%@@%|||||!\n       ... .';|%$$&&&&&&&&&&&&&&&%%&$&&%|||||%&&$$$$$$%%$%%%||||%!;:::::::'':;!|%%%%$&@&&$%|!|%|;!$&$%|%%$$$$&$|!|$@@&$$$&@@@@@@@@@@@@@@@@@@@@&$$@@@#@&%|||%&#$|||||||||||$@&%|||||!\n    ....   .:!|%$$&&&&&&&&&&&&&&$$&&&&$|||||%$@&$$&$$&&&$%|%%%%|;::''''''````'!!!;'`'%@&%|!::!;;!$$||%%%$&$$$$|!!|%&@@&&&&@@@@@@@@@@@@@@@@@@@@&&@@@@#@%||||$@@$|||||||||||$#&||||||!\n     ..   .';!|%$$$&&&&&&&&&&&&$$&&&&&$$%||%%&@&$$&$$$$%|!;;;;:::'`````````````````';;:;!;'::::;%$|||!!|$$$%$%||||$@@@&&&@@@@@@@@@@@@@@@@@&&@&&&&&&@@@$%%||&#&%||||||||||%&#$||||||!\n        .`:!!!|$$&&&&&&&&&&&&&&&&&&&&&&&$%$$$&@&&$&&$$|!|%$$$$%|;''``````````````':;!!!;::''':;!$%|$$%%$$$$$$%!!%&@@@@@@@@@@@@@@@@@@@@@@@@&&&&@&$$&@@@@@@@@@#&%||||||||||%@@$||||||!\n;:''`'':;!!!!|%$$&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&$&&&&&$|!%%%%$&$$|;'``````````````''''''''::::;|$&$$$%%$$%%$$$&@@@@@@@@@@@@@@@@@@@@@@@@@@@&&&@&$$$&&&@@@@@@@@@@@@@@&$%|||$@@$||||||!\n|!;;;!!!!!!|%$$$&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&%!:;|!||!!:'''``````````````''''''''':;;|$$$$$%%$%$$$&&&&&@@@@@@@@@@@@@@@@@@@@@@@@&&&@&$$$&&&&&@@@@@##@@@@@&&@@@@@@#@&%|||||!\n%|!!!!!!||%$$$&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&@@&&&&&&$$$!';;;:'```''`````````````````'''''';;:|$$$$$$$$%$$$&@&&&&@@@#@@@@@@@@@@@@@@@@@@@&&@&$$$$$$$&&&@@@@##@%;''|&@@@@@@@#@@@@@@@%\n&$%%%%%%$$$$&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&@&&&@&&&$$$%;``'''``':'``````````````````'''':::;|$$$$$$$%$$$$&&&&&&@@@##@@@@@@@@@@@@@@@@@@&@&$$$&&&$$$&&&@@@@|:''':%@@@@@@@#@@@@@@@@%\n@@&$$$$$&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&@&&@@&&&$$$$%:``````';:'```...`````````````'''':;|$$$$$$%%$$$$&&&&&&&@@##@@#######@@#@@@@@@#@&$$&&&&&$%$$&&@@%:'::'!&@@@@&@@@@@@@@@@@%\n##@&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&@@&&&&&&&$$%:``````':;:```..``````````````''':;|$$$$$$%%$$$&&&&&&&@@@####################@&$$&&$$$$$$$|;|&$!''':;$&&&&&&@@@@@@@@@@@%\n##@&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&$&@&$&&&$&&&&&%'``````.``````....```````````'`'';|$&$$$%$$$$$$&&&&&@@@@@##################@$$$&&$$$$$|:':;%&$;''''|&&&&&&&&@@@@@@@@@@%\n##@&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&$%$&@@$$$$$&&&&&@@!````````.......````````````''`'':!%$&&&$$&&&&&&&&&&@@@#@@##############@@&$$$$&$$$$$$|:''|&&|''''!$&&&&&&@@@@@@@@@@@@%\n##@&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&|;%&$&@$$$$$$&&&&&@@&;..``..........````````````''``'';%$&&&&&&&&&&&&&&@@@@@##@############@@@$$$$&$!|$$$$!:':%@%:``':%&&@@@@@@@@@@@@@@@@@%\n##@&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&$!!$&&$&&$|!|%$$$&&&@@@@$:.........``'''``':;:'`````````':!%$&&&&&&&@&&&&&@@@@@@@#@@#########@@@&$$$%!!$$$$$%;'';$&!``':%@@@@@@@@@@@@@@@@@@@&%\n##@&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&|;%&&&&$%%$%!|%%$$$$&&@@@@@$;`.....`...````````````````````';|$&&&&&&&&@@@&&&@###@@@@#@&&##@@@@@&$$$$&&$$$$$$|'```!&%;|&&&&&@@@@@@@@@@@@@@@&&&&%\n###&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&%:|&&&&&$$||$&$|%%%$$&&&@@@@@@@@$;`........``'::'`...```'``````:|$$$&@@&$&@@@@@@&@#@@####@#&&#@$|%&$$%%&&$$$$%!'`.`:!$@@&&&&@@@@@@@@@@@@@@&&&&&&&&%\n###@&&&&&&&&&&&&&&&&&&&&&&&&&&|:!&&&&&&$$%||$&&$%%%$$&&&&@@@@@@@@@@&%:`.................`'````:!;;|$$$&&@@&&&&@@@@&&@########@!':|&$$%%$|;:;;!|%%%%||$@@&&&&&&&@&&&&&&&&&&&&&&&&&&&%\n###@&&&&&&&&&&&&&&&&&&&&&&$!:|&&&&&&&&$$%|%$&&&$%%%$&&&&&@@@@@@@@@@@@&&$;`..............``'';|!;;;;|%$$$$&@@@&&&@@&&$$&&@@@@##@&%||%%%$!:|%%%%%||%!|$@@@&&&&&&&&$$$$$$&&&&&&&&&&&&&%\n###@&&&&&&&&&&&&&&&&&&&|:!$&&&&&&&&&&$%%%%$$&&&$%%$$$$&&@#@@@@@@@@@@@&&&&&&|'...........``:!!;;;;;!!;|$&$%|&@@@&&&&&$!|$$$&@@#@@&%%%%$|'':!%%%%|!|$&&@@&&&&&&&$%%%%$$$$$&&$$$$$$&&&%\n###@&&&&&&&&&&&&&&&|:;%&&&&&&&&&&&&$$%%%%$$&&&&$$$$$$$$&@#@@@@@@@@@&&&&&&&&&&&&|'.....`;%%!!!!;;;!!!!;!%$$&$|%@@@@@&&@$;:::!|%$&$%%%$%:'``';!!|||%$&@@@&&&&&&$%%%%%%%$$$$$%%%%$$$$$|\n###@&&&&&&&&&$|:;%&&&&&&&&&&&&&&&$$%%$%%$&&&&&&$$$$%$$$&@@@@@@@@@##@&&&&&&&&&&&&&&%|%&&&&&$|;;;;;;;;;;;;!$&$&$|!%&@@@@@@&%;::!$$$$$$%;:```````;||||%$&&$$$$$$%|%%%%%%%$$$%%%%%%%%$%|\n###@&&$%|||$&&&&&&&&&&&&&&&&&&$$$$%%$$%$&&&&&&&$$$%%$$&&@@@@@@@@@@@##@&&&&&&&&&&&&&&&&&&&&@%;;;;;;;::;;;;!!$&&$$%!;|$$$&&&$&&&$$$$$%!|$&%:...`.`;|!|||!;!|||||||%%%%%%$%%%||||%%%%%|\n&&@@&&&&&&&&&&&&&&&&&&&&&&&$$$$$$%%$$%$&&&&&&&&$%%%%$$&&@@@@@@@@@@@@#@&@@&&&&&&&&&&&&&@###&%;;;;;;::::;;;!!!!|$$$&&%!:;!$&&&@&$$$&@&&&$%$&|``..'%#@@&$%%||||!;:'`';|%%$%%|||||||||||\n###@&&&&&&&&&&&&&&&&&&&&$$$$$$$$%%$&&$$&&&&&&&&$%%%%$$&&&@@@@@@@@@@@@@@&&&&@@@@@&&@####$;':!!;;;::::;;;;!;!;::::;%&&&&&$$$&@&$$$@@$$$$$&@@@@$%@#@@##@@&%%||||||||%%%|!'`:!||||||||||\n###@&&&&&&&&&&&&&&&&&$$$$$$$$$$$$$$$%%$$$$&&&&@$%%%%$$&&&&&@@@@@@@@@&&&&@@&&&&&&&@@@@|:':;;!!;;:::::::;;!!;:::::::::':::';$$$$$&&$&&&@@@&&@@@@@#######@@##@&%||||||||%%%%|!''!|||||!\n###@&&&&&&&&&&&&&&$$$$$$$$$$$&&$$$$$%%$$$$$&&&&&$%%$$$&&&&&$&&&@@@@&&&&&&&&&&&&@@@%:''':;;;;;:::::::::;;;:::::::::::::;;!%$$$$$|:::|$&&$&@@@@@&$&@#####@@@@####@&$%||%%%||||||;:!||!\n###@&&&&&&&&&&&$$$$$$$$$$$&&&&&$$&&$%%$$$&&&&&&&&$%$$$$$&&&&&&&@@@#@&&&&&&&&@##$;''''':;;;;;:::::::::;!;:::::::::::::::;%&$$$$|''':;%&%!;:'''':|%$&@@@@#@@&&&@##@&&@@$|%%|||||||!:;|\n:;$@@&&&&&&&$$$$$$$$$$$&&&&&&&&&$$&&$$&&&&&&&&&&&$%%$$$&&&&&&&&&&&&@@#######@|:'''''';!!!;::::::;;!!!!;::::::::::::::::|$$$$$!'::;!!%&|;;''''''''''';$&@@#@&&$$&@&&@#@@@#####@$%||;:\n''''':|$&$$$$$$$$$$&&&&&&&&&&&&&&$$&$$&&&&&&&&&&&&&$$$$$&&$$&&&&&@@@@@&$%$%|:''''''':;:::::::::::::;;:::::::::::::::::|$$$$$!::;;;;|&%;;:''''''''''''':!$&@@@&$$$$&################$\n'''''''''';%$$&&&&&&&&&&&&&&&&&&&&$$$$&&&&&&&&&&&&&&$$$$$&@@@@@###@&&$%;''''''''':::;;:::::::::::;;:::'':::::::::::':|$$$$$!::;:::|&%;;:''''''''''''''```:%&@@&&&$$$&##############$\n'''''''''''':':|&&&&&&&&&&&&&&&&&&&&$%$&&&&&&&&&&&&&&$$$$$&@@&@@@&$$%%!:''''''::::::!;::::::::::;;::::::::::::::''':|$$$$$|;;:::;%&|::'''''''''''''`.....``;$@@&&&&$$$&@###########$\n;:'''''''''''''':::!$&&&&&&&&&&&&&&&&&%|$&&&&&&&&&&&&&&$$$$&$$$$$$|:!|;':::::::::::;!;::::::::;;:::::::::::::''''':|$$$$$|;::::|&&|::'''''''''''``........`''!&@@&&&&$$$&@#########$\n.';;;;;:'''''''''''':::;%&@&&&&&&&&&&&&%$&&$$$$&&&&&&$&@&&&$$$$%!:::!|;::::::::::::!!;::::::!;::::::::::::::''''':|&$$$$|;::::|&%;;:'``''''''''````......````'!$@@&&&&&$$$&@#######$\n;;;:`.`:;;;;::'''''''''''':;%@@@&&&&&&&&$$$&&&&&&&&&&@@&!::':'':::::||;::::::::::::!!;:::;!!;;:::::::::::::::''':%&$$$$|;:::;%&|:::'`````````'''```..`...````''!$@@&&&&&&&$$&@#####$\n;;;;;;;;;'..';;;;::''''''''''':|@@@@&&&&&&$%$&&&&&&&@@%:::::::::::::!|;:::::''''''';!;:;!!;:::::::::::::::::''':%&$$$%|;:::|&%;;:'''```````'''''``...      ```''!&@&&&&&&&&&&&&@###$\n:::;;;;;;;;!;;;'':;;;;:'''''''''':!&@@@&&&&&$$&&&&@@@$;::::::::::::';|:``````````'';!;;;:'''```````````````''''|$$$$%|;::|&$!;;:'````````''::''``....      .``'':%@&&&&&&&&&&&&&&@#$\n::::::::;;;;;;;;;;;;:'':;;:''''''''':;%@@@@&&&&$&@@@$;''''''':''`''`:|;````````````:!!:'''``.........``......`!$%%%%|;;|&$!:;'`````````'''::''.     ..    `''``''!$&&@@&&&&&&&&&&&&%\n###@%!:::::::;;;;;;;;;;;;;;;;::'''''::::|&@@@&&&&&&%'```.....````''`'||'``````````';;'''``................. .!$%%%%|!%&$!:;:'``'''````'::::''.       ....``''``'''|@&&&@&&&@&&&&&&$|\n####@&&&@&|;::::::;;;;;;;;;;;;;;;:'''''''::!&@@@@@%:````......```'```;%;`````````''''``.................   .!$%%%%%$&%;:::''```'''```'::::'`.         ...``'```''';$@&&&@@&&&&&&&&&%\n####@&&&&&&&&&$!:::::::;;;;;;;;;;;;;:''''''':|@@@$;````.......``''```'!%;``````''''``.......      ....    .;%%%%%%$%;::'''`````''''`'::::`.             ...`````'''|@&&&&@@&&&&&&&&%\n####@&&&&&&&&&&&&&&|;::::::;;;;;;;;;;;;:::'':;;%&;````.........``'````:||:```':''`......                .`:|%%%%%|;::''''``````'''''::::`.               ....```'''!$@&&&&@@&&&&&&&%\n####@&&&&&&&&&&&&&&&&&&|::::::::;;;;;;;;;:::::;;'````..........``'`````:||:':''`......                .`'!$%%%%|;:''```````````'''''::;'.                 ......``':%@@&&&&&@&&&&&&%\n####@&&&&&&&&&&&&&&&&&&&&&$!:::::::;;;;;;;;;;;;'`````..........`''``````:||:''`.  .                .``!$&$%%%%%;'''`````````````'':::;;`                   .....```'!&@&&&&&&@&&&&&%\n####@&&&&&&&&&&&&&&&&&&&&&&&&&|;:::::;;;;;;;;;:``````...........''````':':|%!'.                .``'|$&|;|%|%%%!''````...`````````':::;;`                    .....```'|@&&&&&&&@&&&&%\n####@&&&&&&&&&&&&&&&&&&&&&&&&&&&$!::::::;;;;;:``````....``......''``':'''':!|%;..         ..``:|%$|;::;|%||%%!'`````......```''`'':::;:'   .......           ....````:%@&&&&&&@@&&&%\n####@&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&%;:::::;;:```````....`.   ...`'':''`.  .':!||;````````';|%%|;::::';|%||%%;'```.........```'''''::::;'. ....````........  ......````:%@&&&&&&@@&&%\n####@&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&|:::::'```````...``.   ..'::'``.   .```':;!||!;;!||!;::::''``';|%||%|;'```..........```'''''::::;:.....``````````...........`````;&&&&&&&@@@&%\n*/\n\nint n;\nint a[105];\nconst int Mod=1'000'000'007;\n\nint ksmii(int a,int b){\n\tif(!b){\n\t\treturn 1;\n\t}\n\tint ff=ksmii(a,b>>1);\n\tff=1LL*ff*ff%Mod;\n\tif(b&1){\n\t\tff=1LL*ff*a%Mod;\n\t}\n\treturn ff;\n}\n\npair<int,int> solve(int l,int r,int lim){\n\tint minx=Mod,cnt;\n\tfor(int i=l;i<=r;i++){\n\t\tif(a[i]<minx){\n\t\t\tminx=a[i];\n\t\t\tcnt=1;\n\t\t}else if(a[i]==minx){\n\t\t\tcnt++;\n\t\t}\n\t}\n\tif(cnt==r-l+1){\n\t\treturn make_pair((ksmii(2,r-l+1)-2+Mod)%Mod,ksmii(2,minx-lim-1));\n\t}\n\tpair<int,int> ans;\n\tint L=-1,rem=r-l+1;\n\tint x1=1,x2=1;\n\tfor(int i=l;i<=r+1;i++){\n\t\tif(L==-1&&a[i]>minx){\n\t\t\tL=i;\n\t\t}else if(L!=-1&&a[i]<=minx){\n\t\t\trem-=i-L;\n\t\t\tpair<int,int> tmp=solve(L,i-1,minx);\n\t\t\tx1=1LL*x1*(tmp.first+4LL*tmp.second%Mod)%Mod;\n\t\t\tx2=2LL*x2*tmp.second%Mod;\n\t\t\tL=-1;\n\t\t}\n\t}\n\tx1=(x1-x2+Mod)%Mod;\n\tans.first=((1LL*x1*ksmii(2,rem)%Mod)+(1LL*x2*((ksmii(2,rem)-2+Mod)%Mod)%Mod))%Mod;\n\tans.second=1LL*x2*ksmii(2,minx-lim-1)%Mod;\n\treturn ans;\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d\",a+i);\n\t}\n\tint peak=1;\n\tfor(int i=1;i<=n;i++){\n\t\tif(a[i]>a[i-1]&&a[i]>a[i+1]){\n\t\t\tpeak=1LL*peak*ksmii(2,a[i]-max(a[i-1],a[i+1]))%Mod;\n\t\t\ta[i]=max(a[i-1],a[i+1]);\n\t\t}\n\t}\n\tpair<int,int> ans=solve(1,n,0);\n\tprintf(\"%lld\\n\",1LL*peak*((ans.first+2LL*ans.second%Mod)%Mod)%Mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nlong long n,h[105],dp[105],tmp,mod=1000*1000*1000+7,pre[105],l,r,omega,dest,prog;\ndeque<pair<long long,int> > v;\n\nlong long fastp(long long base,int exp){\n    if(exp==0)return 1;\n    \n    long long val=fastp(base,exp/2);\n    val=(val*val)%mod;\n    if(exp%2)val*=base;\n    return val%mod;\n}\n\n\nint main(){\n\n\tcin>>n;\n    for(int i=1;i<=n;i++)cin>>h[i];\n\n    dp[n+1]=1;\n    pre[0]=1;\n    for(int i=1;i<=n;i++){\n        pre[i]=pre[i-1]*fastp(2,max(0ll,h[i]-h[i-1]));\n        pre[i]%=mod;\n    }\n    \n    for(int i=n;i>0;i--){\n        tmp=2*dp[i+1];\n        \n        v.clear();\n        v.push_back({2,n+1});\n        for(int j=n;j>=i;j--){\n            while(v.size()>0 && v.back().first>=h[j]+1)v.pop_back();\n            v.push_back({h[j]+1,j});\n        }\n        \n        while(v.size()>1 && v[1].first<=h[i-1])v.pop_front();\n        \n        v[0].first=max(v[0].first,h[i-1]+1);\n        \n        for(int j=0;j<v.size()-1;j++){\n            l=v[j].first;\n            r=v[j+1].first-1;\n            if(l>r)continue;\n            dest=v[j].second;\n            omega=(pre[dest-1]*fastp(pre[i],mod-2))%mod;\n            prog=(fastp(2,h[i]-l)*(2-fastp(fastp(2,r-l),mod-2)))%mod;\n            prog+=mod;\n            prog%=mod;\n            tmp+=((2ll*omega*prog)%mod*dp[dest])%mod;\n            tmp%=mod;\n        }\n        \n        dp[i]=tmp;\n    }\n    \n    cout<<dp[1]<<endl;\n\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 111;\nconst int mod = 1e9 + 7;\nint f[N][N];\nint h[N], d[N], n, tot;\nint ksm(int base, int x){\n\tint ans = 1;\n\twhile(x){\n\t\tif(x & 1)ans = 1LL * ans * base % mod;\n\t\tx >>= 1;\n\t\tbase = 1LL * base * base % mod;\n\t}\n\treturn ans;\n}\nint main(){\n\tcin>>n;\n\tfor(int i = 1;i <= n; i++){\n\t\tscanf(\"%d\", &h[i]);\n\t\td[++tot] = h[i];\n\t}\n\tsort(d + 1, d + 1 + tot);\n\ttot = unique(d + 1, d + 1 + tot) - (d + 1);\n\tf[1][0] = (ksm(2, h[1]) - 2 * ksm(2, h[1] - d[1]) % mod + mod) % mod;\n\tfor(int i = 1;i <= tot && d[i] <= h[1]; i++){\n\t\tif(d[i] < h[1])f[1][i] = 2ll * (ksm(2, h[1] - d[i]) - ksm(2, h[1] - d[i+1]) + mod) % mod;\n\t\telse f[1][i] = 2;\n\t}\n\tfor(int i = 1;i < n; i++){\n//\t\tprintf(\"i=%d\\n\", i);\n\t\tint x = lower_bound(d + 1, d + 1 + tot, h[i+1]) - d;\n\t\tfor(int j = 0;d[j] <= h[i] && j <= tot; j++){\n\t\t\tif(h[i] >= h[i+1]){\n\t\t\t\tif(d[j] < h[i+1])f[i+1][j] = f[i][j];\n\t\t\t\telse{\n\t\t\t\t\tf[i+1][x] = (f[i+1][x] + 2 * f[i][j] % mod) % mod;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(d[j] < h[i]){\n\t\t\t\t\tf[i+1][j] = (f[i+1][j] + 1LL * f[i][j] * ksm(2, h[i+1] - h[i]) % mod) % mod;\n\t\t\t\t}\n\t\t\t\tif(d[j] == h[i]){\n\t\t\t\t\tfor(int k = j;k < x; k++){\n\t\t\t\t\t\tf[i+1][k] = (f[i+1][k] + 2LL * f[i][j] * (ksm(2, h[i+1] - d[k]) - ksm(2, h[i+1] - d[k+1]) + mod) % mod);\n\t\t\t\t\t}\n\t\t\t\t\tf[i+1][x] = 2 * f[i][j] % mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(int i = 0;i <= tot; i++){\n\t\tans = (ans + f[n][i]) % mod;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\ntemplate <typename TYPE> inline void chkmax(TYPE &x,TYPE y){x<y?x=y:0;}\ntemplate <typename TYPE> inline void chkmin(TYPE &x,TYPE y){y<x?x=y:0;}\ntemplate <typename TYPE> void readint(TYPE &x)\n{\n    x=0;int f=1;char c;\n    for(c=getchar();!isdigit(c);c=getchar())if(c=='-')f=-1;\n    for(;isdigit(c);c=getchar())x=x*10+c-'0';\n    x*=f;\n}\nconst int MAXN=105,MOD=1000000007;\nint qmi(int x,int y)\n{\n\tint ans=1;\n\tfor(;y;y>>=1,x=1ll*x*x%MOD)\n\t\tif(y&1)ans=1ll*ans*x%MOD;\n\treturn ans;\n}\n\nint n,a[MAXN],f[MAXN][MAXN],g[MAXN][MAXN];\nvoid solve(int l,int r,int x)\n{\n\tint y=1<<30,las=l-1,w=0;\n\tfor(int i=l;i<=r;++i)chkmin(y,a[i]);\n\tfor(int i=l;i<=r;++i)if(a[i]==y)++w;\n\tif(w==r-l+1)\n\t{\n\t\tf[l][r]=qmi(2,y-x)+qmi(2,r-l+1)-2;\n\t\tg[l][r]=qmi(2,y-x);\n\t\treturn;\n\t}\n\tf[l][r]=qmi(2,w);\n\tg[l][r]=1;\n\tfor(int i=l;i<=r+1;++i)\n\t\tif(i>r || a[i]==y)\n\t\t{\n\t\t\tif(i-las>=2)\n\t\t\t{\n\t\t\t\tsolve(las+1,i-1,y);\n\t\t\t\tg[l][r]=1ll*g[l][r]*g[las+1][i-1]%MOD;\n\t\t\t\tf[l][r]=1ll*f[l][r]*(g[las+1][i-1]+f[las+1][i-1])%MOD;\n\t\t\t}\n\t\t\tlas=i;\n\t\t}\n\tf[l][r]=(f[l][r]+1ll*g[l][r]*(qmi(2,y-x)-2+MOD))%MOD;\n\tg[l][r]=1ll*g[l][r]*qmi(2,y-x)%MOD;\n//cerr<<l<<\" \"<<r<<\":\"<<f[l][r]<<\" \"<<g[l][r]<<endl;\n}\n\nint main()\n{\n\t#ifndef ONLINE_JUDGE\n//\tfreopen(\"code.in\",\"r\",stdin);\n//\tfreopen(\"code.out\",\"w\",stdout);\n\t#endif\n\treadint(n);\n\tfor(int i=1;i<=n;++i)readint(a[i]);\n\tsolve(1,n,0);\n\tprintf(\"%d\\n\",f[1][n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <iostream>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n\nusing namespace std;\n\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\n#define REP(i, a, b) for(int i = int(a); i <= int(b); i++)\n#define LOOP(i, v) for(int i = 0; i < v.size(); i++)\n#define EPS 1e-9\n#define INF 1e12\n#define debug(x) cerr << \"DEBUG : \" << (#x) << \" => \" << (x) << endl\n\nlong long int MOD = 1000000007;\n\nlong long int pow2(long long int k)\n{\n  if(k == 0) return 1;\n  long long int x = pow2(k/2);\n  if(k & 1) return (((x*x)%MOD)*2)%MOD;\n  else return (x*x)%MOD;\n}\n\nint main()\n{\n  int N;\n  long long int h[100];\n  long long int val[100];\n  set<long long int> ss;\n  set<long long int>::iterator it;\n  map<long long int, int> mm;\n  \n  scanf(\"%d\", &N);\n  REP(i, 0, N-1)\n  {\n    scanf(\"%lld\", &h[i]);\n    ss.insert(h[i]);\n  }\n  \n  int M = 0;\n  for(it = ss.begin(); it != ss.end(); it++)\n  {\n    mm[*it] = M;\n    val[M] = *it;\n    M++;\n  }\n  // M = number of different heights\n  \n  long long int dp[100][101];\n  \n  long long int prevh = 1;\n  REP(i, 0, M)\n  {\n    if(i == M) dp[0][i] = 2;\n    else if(val[i] <= h[0]) dp[0][i] = ((pow2(val[i]-prevh+1)-2) * pow2(h[0]-val[i]))%MOD;\n    else dp[0][i] = 0;\n    prevh = val[i];\n  }\n  \n  REP(j, 1, N-1)\n  {\n    REP(i, 0, M) dp[j][i] = 0;\n    if(h[j] <= h[j-1])\n    {\n      REP(i, 0, M)\n      {\n        if(i < M && val[i] <= h[j]) dp[j][i] = (dp[j][i] + dp[j-1][i])%MOD;\n        else dp[j][M] = (dp[j][M] + 2*dp[j-1][i])%MOD;\n      }\n    }\n    else\n    {\n      long long int tot = 0;\n      REP(i, 0, M)\n      {\n        if(i < M && val[i] <= h[j-1]) dp[j][i] = (dp[j][i] + dp[j-1][i]*pow2(h[j]-h[j-1]))%MOD;\n        else tot = (tot+dp[j-1][i])%MOD;\n      }\n      REP(i, 0, M)\n      {\n        if(i < M && val[i] > h[j-1] && val[i] <= h[j]) dp[j][i] = (dp[j][i] + ((tot*(pow2(val[i]-val[i-1]+1)-2))%MOD) * pow2(h[j]-val[i]))%MOD;\n        else if(i == M) dp[j][i] = (dp[j][i] + tot*2)%MOD;\n      }\n    }\n  }\n  \n  long long int ans = 0;\n  \n  REP(i, 0, M) ans = (ans + dp[N-1][i])%MOD;\n  \n  cout << ans << endl;\n  \n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define y1 dmytxdy\n#define fi first\n#define se second\n#define mp make_pair\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef long double ld;\n\ntemplate <typename T> bool chkmin(T &x,T y){return x>y?x=y,1:0;}\ntemplate <typename T> bool chkmax(T &x,T y){return x<y?x=y,1:0;}\n\nint readint(){\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nconst int cys=1000000007;\nint n,ncnt;\nll d[105],f[105],a[105];\n\nll mod(ll x){return x>=cys?x-cys:x;}\n\nll qpow(ll x,ll p){\n\tll ret=1;\n\tfor(;p;p>>=1,x=x*x%cys) if(p&1) ret=ret*x%cys;\n\treturn ret;\n}\n\nint solve(int l,int r,int x){\n\tint rt=++ncnt;\n\tif(l==r){\n\t\td[rt]=0,f[rt]=qpow(2,a[l]-x);\n\t\treturn rt;\n\t}\n\tll mina=1<<30;\n\tfor(int i=l;i<=r;i++) chkmin(mina,a[i]);\n\tint lst=l-1;\n\tf[rt]=qpow(2,mina-x),d[rt]=1;\n\tfor(int i=l;i<=r;i++){\n\t\tif(a[i]==mina){\n\t\t\td[rt]=mod(d[rt]<<1);\n\t\t\tif(lst+1==i){\n\t\t\t\tlst=i;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint tmp=solve(lst+1,i-1,mina);\n\t\t\tf[rt]=f[rt]*f[tmp]%cys;\n\t\t\td[rt]=d[rt]*(d[tmp]+(f[tmp]<<1))%cys;\n\t\t\tlst=i;\n\t\t}\n\t}\n\tif(lst!=r){\n\t\tint tmp=solve(lst+1,r,mina);\n\t\tf[rt]=f[rt]*f[tmp]%cys;\n\t\td[rt]=d[rt]*(d[tmp]+(f[tmp]<<1))%cys;\n\t}\n\td[rt]=mod(d[rt]+cys-f[rt]*qpow((cys+1)/2,mina-x-1)%cys);\n\treturn rt;\n}\n\nint main(){\n\tn=readint();\n\tfor(int i=1;i<=n;i++) a[i]=readint();\n\tint tmp=solve(1,n,0);\n\tprintf(\"%lld\\n\",mod(d[tmp]+f[tmp]));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,x,y) for (int i=(x);i<=(y);i++)\n#define ll long long\n#define inf 1000000001\n#define y1 y1___\n#define pii pair<int,int>\n#define fi first\n#define se second\nusing namespace std;\nchar gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\nll read(){\n    char ch=gc();ll x=0;int op=1;\n    for (;!isdigit(ch);ch=gc()) if (ch=='-') op=-1;\n    for (;isdigit(ch);ch=gc()) x=(x<<1)+(x<<3)+ch-'0';\n    return x*op;\n}\n#define N 105\n#define mod 1000000007\nint ksm(int x,int p){\n    int ret=1;\n    for (;p;p>>=1,x=(ll)x*x%mod) if (p&1) ret=(ll)ret*x%mod;\n    return ret;\n}\nint n,h[N];\npii solve(int l,int r,int lim){//区间[l,r]比lim高的部分的方案数\n    int mi=inf,cnt=0;pii ret;//first：存在相邻格子颜色相同情况的方案数；second：不存在的方案数（固定第一个格子的颜色）\n    rep (i,l,r) if (h[i]<mi) mi=h[i],cnt=1;else if (h[i]==mi) cnt++;\n    if (cnt==r-l+1){//矩形\n        ret.fi=(ksm(2,r-l+1)+mod-2)%mod;\n        ret.se=ksm(2,mi-lim);\n        return ret;\n    }\n    int rest=r-l+1,s0=1,s1=1,last=0;//rest：上方没有方格的列数；s0,s1：维护上方有方格的列，当前行存在/不存在的方案数\n    rep (i,l,r+1)\n        if (!last&&h[i]>mi) last=i;\n        else if (last&&(h[i]<=mi||i>r)){\n            rest-=i-last;\n            pii tmp=solve(last,i-1,mi);//子问题，递归求解\n            s0=(ll)s0*(tmp.fi+2ll*tmp.se%mod)%mod;//*4是因为上一行可以取反，当前行亦然，2*2\n            s1=(ll)s1*(1ll*tmp.se%mod)%mod;\n            last=0;\n        }\n    s0=(s0+mod-s1)%mod;\n    ret.fi=(ll)s0*ksm(2,rest)%mod;//如果上方方格已经存在，剩下的列随意\n    ret.fi=(ret.fi+(ll)s1*(ksm(2,rest)+mod-2)%mod)%mod;//否则需要去掉两种不合法的情况\n    ret.se=(ll)2ll*s1*ksm(2,mi-lim-1)%mod;//固定第一个格子（第一行）颜色\n    return ret;\n}\nint main(){\n    n=read();rep (i,1,n) h[i]=read();\n    if (n==1){//注意特判\n        printf(\"%d\\n\",ksm(2,h[1]));\n        exit(0);\n    }\n    int ex=1;\n    rep (i,1,n) if (h[i]>h[i-1]&&h[i]>h[i+1]){\n        ex=(ll)ex*ksm(2,h[i]-max(h[i-1],h[i+1]))%mod;\n        h[i]=max(h[i-1],h[i+1]);\n    }\n    pii ans=solve(1,n,0);\n    printf(\"%d\",(ll)ex*(ans.fi+ans.se%mod)%mod);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(i,v.size())cout<<\" \"<<v[i];cout<<endl<<endl;\n#define show2d(v) rep(i,v.size()){rep(j,v[i].size())cout<<\" \"<<v[i][j];cout<<endl;}cout<<endl;\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<int,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n//nCr mod m\n#define MOD 1000000007\n#define M 1000000\nvector<ll> fact;\nbool h=false;\nvoid init(){\n\th=true;\n\tfact=vector<ll>(M);\n\tfact[0]=fact[1]=1;\n\tloop(i,2,M)fact[i]=fact[i-1]*i%MOD;\n}\n// a^b mod MOD\nll powmod(ll a,ll b,ll m=MOD){\n\tll out=1;\n\tll p=a%m;\n\twhile(b){\n\t\tif(b&1)out=out*p%m;\n\t\tp=p*p%m;\n\t\tb>>=1;\n\t}\n\treturn out;\n}\n//nCr\nll nCr(ll n,ll r,ll m=MOD){\n\tif(!h)init();\n\tif(n<0||r<0||n<r)return 1;//??????\n\tll out=fact[n]*powmod(fact[r]*fact[n-r]%m,m-2,m)%m;\n\treturn out;\n}\nint n;\nvi in;\npii f(int l,int r,int a){\n\tint mi=inf;\n\tloop(i,l,r)mi=min(mi,in[i]);\n\t\n\tvi t={l-1};\n\tloop(i,l,r)if(in[i]==mi)t.pb(i);\n\tt.pb(r);\n\tvp in;\n\t\n\tint w=r-l;\n\trep(i,t.size()-1)if(t[i]+1-t[i+1])in.pb(f(t[i]+1,t[i+1],mi)),w-=t[i+1]-t[i]-1;\n\t\n\tint b=powmod(2,mi-a,MOD),c=powmod(2,w,MOD),d=(MOD+powmod(2,mi-a,MOD)-2)%MOD;\n\trep(i,in.size()){\n\t\t(b*=in[i].first)%=MOD;\n\t\t(c*=in[i].first+in[i].second)%=MOD;\n\t\t(d*=in[i].first)%=MOD;\n\t}\n\treturn {b,(c+d)%MOD};\n}\nsigned main(){\n\tinit();\n\tcin>>n;\n\tin=vi(n);\n\trep(i,n)cin>>in[i];\n\tpii a=f(0,n,0);\n\tcout<<a.second<<endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint N, a[109], dp[109][109][3];\nconst int mod = 1e9 + 7;\nlong long e2 = 0;\n\nint add (int x, int y) {int ans = x + y; if (ans >= mod) ans -= mod; return ans;}\nint subtract (int x, int y) {if (x >= y) return x - y; return x - y + mod;}\nint mul (int x, int y) {return 1LL * x * y % mod;}\nvoid adto (int &x, int y) {x += y; if (x >= mod) x -= mod;}\n\nint power (int a, int b)\n{\n    int p = 1;\n    for (int i=0; (1<<i) <= b; i++)\n    {\n        if (b & (1 << i)) p = mul (p, a);\n        a = mul (a, a);\n    }\n    return p;\n}\n\nint p2 (long long e) {return power (2, e % (mod - 1));}\n\nvoid solve (int i, int j, int lastH)\n{\n    int minH = a[i], maxH = a[i];\n    for (int k=i; k<=j; k++)\n        minH = min (minH, a[k]),\n        maxH = max (maxH, a[k]);\n    if (minH == maxH)\n    {\n        int h = minH - lastH + 1;\n        dp[i][j][0] = dp[i][j][1] = p2 (h - 1);\n        if (j - i + 1 > 1) dp[i][j][2] = subtract (p2 (j - i + 1), 2);\n        else dp[i][j][2] = 0;\n        return ;\n    }\n    vector < pair < int, int > > v;\n    int dp2[4];\n    dp2[1] = dp2[2] = dp2[3] = 0;\n    dp2[0] = 1;\n    for (int l=i; l<=j; l++)\n        if (a[l] > minH)\n        {\n            int r = l;\n            while (r < j && a[r + 1] > minH)\n                r ++;\n            v.push_back ({l, r});\n            solve (l, r, minH);\n            int oldDp[4];\n            memcpy (oldDp, dp2, sizeof (dp2));\n            memset (dp2, 0, sizeof (dp2));\n            for (int k1=0; k1<4; k1++)\n            {\n                int dp3[4];\n                dp3[0] = 0;\n                dp3[3] = dp[l][r][2];\n                dp3[1] = dp[l][r][1];\n                dp3[2] = dp[l][r][0];\n                for (int k2=1; k2<4; k2++)\n                {\n                    int realK = 0;\n                    if (l % 2 == i % 2) realK = k2;\n                    else\n                    {\n                        if (k2 & 1) realK |= 2;\n                        if (k2 & 2) realK |= 1;\n                    }\n                    adto (dp2[k1 | realK], mul (oldDp[k1], dp3[k2]));\n                }\n            }\n            l = r;\n        }\n        else\n        {\n            int oldDp[4];\n            memcpy (oldDp, dp2, sizeof (dp2));\n            memset (dp2, 0, sizeof (dp2));\n            for (int p=0; p<2; p++)\n            {\n                int o = 0;\n                if (p != (l - i) % 2) o |= 1;\n                else o |= 2;\n                for (int k=0; k<4; k++)\n                    adto (dp2[k | o], oldDp[k]);\n            }\n        }\n    dp[i][j][0] = dp[i][j][1] = 1;\n    dp[i][j][2] = dp2[3];\n    for (auto s : v)\n        for (int k=0; k<2; k++)\n            dp[i][j][k] = mul (dp[i][j][k], dp[s.first][s.second][k ^ (s.first % 2) ^ (i % 2)]);\n    if (lastH < minH)\n    {\n        int steps = minH - lastH, s = add (dp[i][j][0], dp[i][j][1]);\n        s = mul (s, p2 (steps - 1));\n        dp[i][j][0] = dp[i][j][1] = s;\n    }\n}\n\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nscanf (\"%d\", &N);\nfor (int i=1; i<=N; i++)\n    scanf (\"%d\", &a[i]);\nsolve (1, N, 1);\nprintf (\"%d\\n\", add (add (dp[1][N][0], dp[1][N][1]), dp[1][N][2]));\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nconst int MOD = (int)1e9 + 7;\n\nint n,m,h[101],hnum[101],dh[101];///h记录每一列高度 dh记录离散化后的各不相同的高度 hnum记录h对应dh中的位置，即第几高的高度\nlong long dp[101][101];///记录第i列第n块高度往上的方案数\n\nint pow_(long long x,int y) {///快速幂求 x的y次方\n    long long ans = 1;\n    if(y > 0) {\n        while(y) {\n            if(y % 2)ans = ans * x % MOD;\n            x = x * x % MOD;\n            y /= 2;\n        }\n    }\n    return ans;\n}\n\nint main() {\n    scanf(\"%d\",&n);\n    for(int i = 1;i <= n;i ++) {\n        scanf(\"%d\",&h[i]);\n        dh[++ m] = h[i];///先把高度存到dh数组 下标从1开始，方便后面dp\n    }\n    sort(dh + 1,dh + m + 1);///dh数组排序\n    m = unique(dh + 1,dh + m + 1) - dh - 1;///dh数组离散化去掉重复的高度 m是不相同的高度数\n    for(int i = 1;i <= n;i ++) {\n        hnum[i] = lower_bound(dh + 1,dh + m + 1,h[i]) - dh;///每一列高度在dh数组中对应的位置\n    }\n    dp[0][0]=1;///初始化 当第0列有1个无连续相同的方案\n    for(int i = 1;i <= n;i ++) {///对每一列每个高度段进行更新 更新过程为从下往上\n        (dp[i][0] += dp[i - 1][0] * 2 % MOD) %= MOD;///无连续相同方案  加上前i - 1列无连续相同方案数*2 因为可以是与前一列对应位置同色或者异色一共两种方案\n        for(int j = hnum[i] + 1;j <= hnum[i - 1];j ++)///如果前一列比这一列高，高出的部分也存着接触部分无连续相同的方案 但是可能会重复加上上一步的方案数所以下面更新高出的部分时会避免\n            (dp[i][0] += dp[i - 1][j] * 2 % MOD) %= MOD;\n        int d = pow_(2,h[i] - h[i - 1]);///比前一列高出部分的涂色方案数，如果比前一列低 d就等于1\n        for(int j = 1;j <= min(hnum[i - 1],hnum[i]);j ++) {\n            dp[i][j] = dp[i - 1][j] * d % MOD;///有连续相同颜色的方案数 已经分析过接触部分的颜色一定是定下的 所以这一列接触部分有连续相同部分的方案数由高出部分的变化决定 即 乘上d\n        }\n        for(int j = hnum[i - 1] + 1;j <= hnum[i];j ++) {///更新比前一列高出的部分 j从上一列的高度加1的下标开始\n            if(j > 1)(dp[i][j] = dp[i - 1][0] * (pow_(2,dh[j] - dh[j - 1]) - 1) % MOD * 2 % MOD * pow_(2,h[i] - dh[j]) % MOD) %= MOD;\n            ///一般情况 前i - 1列无连续方案 * （第j块高度变化方案 -1表示去掉无连续相同方案) * 2 * 剩下几块高度的变化方案数\n            else (dp[1][1] = dp[0][0] * (pow_(2,dh[1]) - 2) % MOD * pow_(2,h[i] - dh[1]) % MOD) %= MOD;\n            ///第一列的第一块高度 记录随意变化方案数 -2表示除去dp[i][0]已经记录过的无连续相同方案 勿重复记录\n        }\n    }\n    long long ans = 0;\n    for(int i = 0;i <= hnum[n];i++)\n        (ans += dp[n][i]) %= MOD;\n    printf(\"%lld\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define FAST ios_base::sync_with_stdio(false); cin.tie(0);\n#define pb push_back\n#define eb emplace_back\n#define ins insert\n#define f first\n#define s second\n#define cbr cerr << \"hi\\n\"\n#define mmst(x, v) memset((x), v, sizeof ((x)))\n#define siz(x) ll(x.size())\n#define all(x) (x).begin(), (x).end()\n#define lbd(x,y) (lower_bound(all(x),y)-x.begin())\n#define ubd(x,y) (upper_bound(all(x),y)-x.begin())\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());    //can be used by calling rng() or shuffle(A, A+n, rng)\ninline long long rand(long long x, long long y) { return (rng() % (y+1-x)) + x; } //inclusivesss\nstring inline to_string(char c) {string s(1,c);return s;} template<typename T> inline T gcd(T a,T b){ return a==0?llabs(b):gcd(b%a,a); }\n\ntypedef long long ll; \ntypedef long double ld;\n#define FOR(i,s,e) for(ll i=s;i<=ll(e);++i)\n#define DEC(i,s,e) for(ll i=s;i>=ll(e);--i)\ntypedef pair<ll,ll>pi; typedef pair<ll,pi>spi; typedef pair<pi,pi>dpi;\n\n#define LLINF ((long long)1e18)\n#define INF int(1e9+1e6)\n#define MAXN (206)\nll n,A[MAXN],dp[MAXN][MAXN],mod=1e9+7,ans=1,no[MAXN];\nvector<ll> d;\nvector<pi> range;\nint main(){\n\tFAST\n\tcin>>n;\n\tFOR(i,1,n)cin>>A[i];\n\tauto qexp=[&](ll x,ll e){\n\t\tll sum = 1;\n\t\twhile(e){\n\t\t\tif(e&1) sum*=x, sum%=mod;\n\t\t\tx*=x,x%=mod;\n\t\t\te>>=1;\n\t\t}\n\t\treturn sum;\n\t};\n\tauto calc2=[&](ll x){\n\t\treturn qexp(2,x+1) - 1;\n\t};\n\tauto calc=[&](ll x,ll y){\n\t\treturn (calc2(y) + mod - calc2(x-1))%mod;\n\t};\n\tFOR(i,1,n){\n\t\tif(A[i]==1) A[i]=0, ans *= 2, ans %= mod;\n\t}\n\tFOR(i,1,n)if(A[i]>A[i-1]&&A[i]>A[i+1]){\n\t\tans*=qexp(2,A[i]-max(A[i-1],A[i+1])),ans%=mod;\n\t\tA[i]=max(A[i-1],A[i+1]);\n\t}\n\tFOR(i,1,n)if(A[i]) d.eb(A[i]),d.eb(A[i]+1);\n\td.eb(ll(1e9) + 1);\n\td.eb(1);\n\td.eb(2);\n\tsort(all(d)), d.resize(unique(all(d))-d.begin());\n\tassert(d[0]==1);\n\tFOR(i,1,siz(d)-1) range.eb(d[i-1]+1,d[i]);\n\tFOR(j,0,siz(range)-1)if(range[j].s<=A[1]){\n\t\tdp[1][j] = calc(A[1]-range[j].s, A[1]-range[j].f) * 2 % mod;\n\t}\n\tno[1]=A[1]>0 ? 2 : 1;\n\tFOR(i,2,n){\n\t\tFOR(j,0,siz(range)-1)if(range[j].s<=A[i]){\n\t\t\tdp[i][j] += dp[i-1][j] * qexp(2, max(0ll, A[i]-A[i-1])) % mod, dp[i][j] %= mod;\n\t\t\tif(range[j].f > A[i-1]) dp[i][j] += no[i-1] * 2 % mod * calc(A[i]-range[j].s, A[i]-range[j].f) % mod, dp[i][j] %= mod;\n\t\t}\n\t\tFOR(k,0,siz(range)-1)if(range[k].f>A[i]){\n\t\t\tno[i] += dp[i-1][k] * (A[i] > 0 ? 2 : 1) % mod, no[i] %= mod;\n\t\t}\n\t\tno[i] += no[i-1] * (A[i]>0 ? 2 : 1) % mod, no[i] %= mod;\n\t}\n\tll sum = 0;\n\tFOR(j,0,siz(range)-1) sum += dp[n][j], sum%=mod;\n\tsum += no[n], sum %= mod;\n\tsum *= ans, sum %= mod;\n\tcout<<sum<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int MAXN = 100 + 5;\n\nconst int Mod = 1e9 + 7;\n\nint n, h[MAXN];\n\nint sorted[MAXN];\n\nint qpow(int a, int x) {\n    int res = 1;\n    for (; x > 0; x >>= 1) {\n        if (x & 1) res = 1LL * x * a % Mod;\n        a = 1LL * a * a % Mod;\n    }\n    return res;\n}\n\nstd::set<std::pair<int, int>> intervals;\n\nstd::map<int, int> L_R, R_L;\n\nint dp[MAXN][MAXN][2][2][2];\n\nvoid Merge(int dp_l[2][2][2], int dp_r[2][2][2], int res[2][2][2]) {\n    static int tmp[2][2][2];\n    \n    memset(tmp, 0, sizeof tmp);\n    \n    for (int l = 0; l < 2; ++l)\n    for (int r = 0; r < 2; ++r) {\n        for (int ll = 0; ll < 2; ++ll)\n        for (int rr = 0; rr < 2; ++rr)\n        for (int sl = 0; sl < 2; ++sl)\n        for (int sr = 0; sr < 2; ++sr) {\n            int t = sl | sr | (ll == rr);\n            tmp[l][r][t] = (tmp[l][r][t] + 1LL * dp_l[l][ll][sl] * dp_r[rr][r][sr]) % Mod;\n        }\n    }\n    \n    memcpy(res, tmp, sizeof tmp);\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; ++i) {\n        scanf(\"%d\", h + i);\n        sorted[i] = i;\n    }\n    \n    std::sort(sorted + 1, sorted + n + 1, [] (int a, int b) { return h[a] > h[b]; });\n    \n    for (int i = 1; i <= n; ++i) {\n        int j = sorted[i], k = sorted[i - 1], t = (h[k] - h[j]) & 1;\n        \n        if (h[k] > h[j]) {\n            for (auto e: intervals) {\n                int L = e.first, R = e.second;\n                \n                static int tmp[2][2][2];\n                for (int l = 0; l < 2; ++l)\n                for (int r = 0; r < 2; ++r) {\n                    tmp[l][r][1] = dp[L][R][l ^ t][r ^ t][1];\n                    tmp[l][r][0] = 1LL * (dp[L][R][l][r][0] + dp[L][R][l ^ 1][r ^ 1][0]) * qpow(2, h[k] - h[j] - 1) % Mod;\n                }\n                \n                memcpy(dp[L][R], tmp, sizeof tmp);\n            }\n        }\n        \n        static int tmp[2][2][2];\n        int L = j, R = j;\n        \n        memset(tmp, 0, sizeof tmp);\n        tmp[0][0][0] = tmp[1][1][0] = 1;\n        \n        if (R_L.count(j - 1)) {\n            int l = R_L[j - 1], r = j - 1;\n            intervals.erase(intervals.find(std::make_pair(l, r)));\n            L_R.erase(L_R.find(l));\n            R_L.erase(R_L.find(r));\n            Merge(dp[l][r], tmp, tmp);\n            L = l;\n        }\n        \n        if (L_R.count(j + 1)) {\n            int l = j + 1, r = L_R[j + 1];\n            intervals.erase(intervals.find(std::make_pair(l, r)));\n            L_R.erase(L_R.find(l));\n            R_L.erase(R_L.find(r));\n            Merge(tmp, dp[l][r], tmp);\n            R = r;\n        }\n        \n        memcpy(dp[L][R], tmp, sizeof tmp);\n        intervals.insert({L, R});\n        L_R.insert({L, R});\n        R_L.insert({R, L});\n    }\n    \n    if (h[sorted[n]] > 1) {\n        int t = (h[sorted[n]] - 1) & 1;\n        int tmp[2][2][2];\n        for (int l = 0; l < 2; ++l)\n        for (int r = 0; r < 2; ++r) {\n            tmp[l][r][1] = dp[1][n][l ^ t][r ^ t][1];\n            tmp[l][r][0] = 1LL * (dp[1][n][l][r][0] + dp[1][n][l ^ 1][r ^ 1][0]) * qpow(2, h[sorted[n]] - 1 - 1) % Mod;\n        }\n        \n        memcpy(dp[1][n], tmp, sizeof tmp);\n    }\n    \n    int ans = 0;\n    for (int i = 0; i < 2; ++i)\n    for (int j = 0; j < 2; ++j)\n    for (int k = 0; k < 2; ++k) {\n        ans = (ans + dp[1][n][i][j][k]) % Mod;\n    }\n    printf(\"%d\\n\", ans);\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = (int) 1e5 + 5;\n\nconst int MOD = (int)1e9 + 7;\n\nint n, h[MAXN], sorted[MAXN];\n\nint qpow(int a, int x) {\n    int res = 1;\n    for (; x > 0; x >>= 1) {\n        if (x & 1)\n            res = 1LL * res * a % MOD;\n        a = 1LL * a * a % MOD;\n    }\n    return res;\n}\n\nbool added[MAXN];\nint R_L[MAXN], L_R[MAXN];\n\nint dp[MAXN][2][2][2];\nint last_h[MAXN];\n\nvoid merge(int dp_l[2][2][2], int dp_r[2][2][2], int res[2][2][2]) {\n    int tmp[2][2][2];\n    \n    memset(tmp, 0, sizeof tmp);\n    \n    for (int l = 0; l < 2; ++l)\n    for (int r = 0; r < 2; ++r) {\n        for (int ll = 0; ll < 2; ++ll)\n        for (int rr = 0; rr < 2; ++rr)\n        for (int sl = 0; sl < 2; ++sl)\n        for (int sr = 0; sr < 2; ++sr) {\n            int t = sl | sr | (ll == rr);\n            tmp[l][r][t] = (tmp[l][r][t] + 1LL * dp_l[l][ll][sl] * dp_r[rr][r][sr]) % MOD;\n        }\n    }\n    \n    memcpy(res, tmp, sizeof tmp);\n}\n\nvoid calc(int L, int h_now) {\n    if (last_h[L] == h_now) {\n        return;\n    }\n    \n    int tmp[2][2][2];\n    int t = (last_h[L] - h_now) & 1;\n\n    for (int l = 0; l < 2; ++l)\n    for (int r = 0; r < 2; ++r) {\n        tmp[l][r][1] = dp[L][l ^ t][r ^ t][1];\n        tmp[l][r][0] = 1LL * (dp[L][l][r][0] + dp[L][l ^ 1][r ^ 1][0]) * qpow(2, last_h[L] - h_now - 1) % MOD;\n    }\n\n    memcpy(dp[L], tmp, sizeof tmp);\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; ++i) {\n        scanf(\"%d\", h + i);\n        sorted[i] = i;\n    }\n    \n    std::sort(sorted + 1, sorted + n + 1, [&] (int a, int b) {\n        return h[a] > h[b];\n    });\n\n    for (int i = 1; i <= n; ++i) {\n        int j = sorted[i];\n\n        int tmp[2][2][2];\n        int L = j, R = j;\n\n        memset(tmp, 0, sizeof tmp);\n        tmp[0][0][0] = tmp[1][1][0] = 1;\n\n        if (R_L[j - 1]) {\n            int l = R_L[j - 1], r = j - 1;\n            L_R[l] = R_L[r] = 0;\n            calc(l, h[j]);\n            merge(dp[l], tmp, tmp);\n            L = l;\n        }\n\n        if (L_R[j + 1]) {\n            int l = j + 1, r = L_R[j + 1];\n            L_R[l] = R_L[r] = 0;\n            calc(l, h[j]);\n            merge(tmp, dp[l], tmp);\n            R = r;\n        }\n\n        added[j] = true;\n        memcpy(dp[L], tmp, sizeof tmp);\n        L_R[L] = R;\n        R_L[R] = L;\n        last_h[L] = h[j];\n    }\n\n    if (h[sorted[n]] > 1) {\n        int t = (h[sorted[n]] - 1) & 1;\n        int tmp[2][2][2];\n\n        for (int l = 0; l < 2; ++l)\n        for (int r = 0; r < 2; ++r) {\n            tmp[l][r][1] = dp[1][l ^ t][r ^ t][1];\n            tmp[l][r][0] = 1LL * (dp[1][l][r][0] + dp[1][l ^ 1][r ^ 1][0]) * qpow(2, h[sorted[n]] - 1 - 1) % MOD;\n        }\n        \n        memcpy(dp[1], tmp, sizeof tmp);\n    }\n\n    int ans = 0;\n    for (int i = 0; i < 2; ++i)\n    for (int j = 0; j < 2; ++j)\n    for (int k = 0; k < 2; ++k) {\n        ans = (ans + dp[1][i][j][k]) % MOD;\n    }\n\n    printf(\"%d\\n\", ans);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int64 INF = 1LL << 60;\nconst int mod = 1e9 + 7;\n\nint64_t mod_pow(int64_t x, int64_t n, int64_t mod) {\n  int64_t ret = 1;\n  while(n > 0) {\n    if(n & 1) (ret *= x) %= mod;\n    (x *= x) %= mod;\n    n >>= 1;\n  }\n  return ret;\n}\n\nint64 N, A[100];\nint64 dp1[100][101], dp2[100][101];\n\nvoid dfs(int l, int r) {\n  int64 ret = INF;\n  int w = r - l;\n  for(int i = l; i < r; i++) ret = min(ret, A[i]);\n  for(int i = l; i < r; i++) A[i] -= ret;\n  vector< pair< int, int > > child;\n  for(int i = l; i < r; i++) {\n    if(A[i] == 0) continue;\n    int left = i;\n    while(left < r && A[left] > 0) ++left;\n    child.emplace_back(i, left);\n    w -= left - i;\n    i = left - 1;\n  }\n  dp1[l][r] = dp2[l][r] = 1;\n  for(auto &p : child) {\n    dfs(p.first, p.second);\n    (dp1[l][r] *= dp1[p.first][p.second]) %= mod;\n    (dp2[l][r] *= dp1[p.first][p.second] + dp2[p.first][p.second]) %= mod;\n  }\n  (dp2[l][r] = dp2[l][r] * mod_pow(2, w, mod) % mod + ((mod_pow(2, ret, mod) + mod - 2) % mod) * dp1[l][r] % mod) %= mod;\n  (dp1[l][r] *= mod_pow(2, ret, mod)) %= mod;\n  for(int i = l; i < r; i++) A[i] += ret;\n}\n\nint main() {\n  cin >> N;\n  for(int i = 0; i < N; i++) {\n    cin >> A[i];\n  }\n  dfs(0, N);\n  cout << dp2[0][N] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/*     !ya khoda!     */\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\n#define ll long long\n#define ld long double\n\n#define pp push\n#define po pop()\n#define pb push_back\n#define pf push_front\n#define pob pop_back()\n#define pof pop_front()\n#define I insert\n#define E erase\n\n#define F first\n#define S second\n\n#define mkp make_pair\n#define pll pair<ll,ll>\n#define smax(a,b) a=max(a,b)\n#define smin(a,b) a=min(a,b)\n#define all(a) a.begin(),a.end()\n\n#define coutghat(x)      cout<<tolower(x);\n#define coutashar(x,d)   cout<<fixed<<setprecision(x)<<(ld)d\n#define IOS ios_base::sync_with_stdio(false) , cin.tie(0) , cout.tie(0);\n\n#define LB(x) ((x) & -(x))\n#define BIT(a , b) (((a)>>(b)) & 1)\n//#define poow(a,b,M)   b?(poow((a*a)%M,b/2)%M * (b&1?a))%M:1 ;\n/*==========================================================================*/\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate <typename T> using ordered_set =  tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate <typename T> using ordered_multiset =  tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;\nll poow(ll x,ll n,ll Mod=1e9+7) { return (n==0?1:poow(x*x%Mod,n/2)*(n&1?x:1)%Mod); }\n//#pragma optimize O3\n// 107,109, 211,223, 307, 401,409, 503,509, 601,607, 701,709, 809, 907, 1009\n/*==========================================================================*/\nconst int N=1e2+100 , M=1e6+10  , SQ=550 , LG=21 , base=2;\nconst int mod=1e9+7 , MOD=1e9+9;\nconst ll  INF=1e9   , inf=1e18 , super_inf=~0ull/4;\nll n,a[N];\n/*==========================================================================*/\npll solve(ll l , ll r)\n{   ll res=0,t=1,w=1,d=0,e=INF,z=l;\n    if(l>r)   return mkp(1,1);\n    for(int i=l;i<=r;i++)   e=min(e,a[i]);\n\n    for(int i=l;i<=r;i++)\n    {   a[i]-=e;\n        if(a[i]==0)\n        {   pll f=solve(z,i-1);\n            t*=f.S  ,  t%=mod;\n            w*=f.F  ,  w%=mod;\n            d++     ,  z=i+1;\n        }\n    }\n\n    pll f=solve(z , r);\n\n    t*=f.S  ,  t%=mod;\n    w*=f.F  ,  w%=mod;\n    res+=(poow(2,d)*w)%mod   ,   res%=mod;\n    res+=(poow(2,e)*t)%mod   ,   res%=mod;\n    res+=(t*((poow(2,e)-2+mod)%mod))%mod;\n    res%=mod;\n\n    return mkp(res,(poow(2,e)*t)%mod);\n}\n/*==========================================================================*/\nint main()\n{\n\tIOS;\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)   cin>>a[i];\n\n    pll res=solve(1,n);\n\n    cout<<(res.F-res.S+mod)%mod;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <vector>\n#include <cassert>\n#include <fstream>\n#include <algorithm>\n#include <list>\n#include <random>\n#include <ctime>\n#include <cmath>\n#include <random>\n#include <bitset>\n#include <complex>\n#pragma unroll\n#pragma loop count N\n#pragma ivdep\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n//#define int ll\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef pair<ld, ld> pld;\ntypedef complex<double> base;\n\n#define mmin(a, b) a = min(a, (b))\n#define mmax(a, b) a = max(a, (b))\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define ALL(a) a.begin(),a.end()\n#define sqr(x) (x) * (x)\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define cint const int &\n#define SZ(a) ((int)(a.size()))\n#define f(cnt) (((cnt) + 1) * (cnt) / 2)\n#define watch(x) cout << (#x) << \" = \" << x << endl;\n\nconst double PI = 2 * acos(0.0);\n\ntemplate<class T>\nvoid show(const set<T> &a) {\n    for (T x : a)\n        cout << x << \" \";\n    cout << endl;\n}\n\ntemplate<class T>\nvoid show(const vector<T> &a) {\n    for (T x : a)\n        cout << x << \" \";\n    cout << endl;\n}\n\nconst ll M = 1e9 + 7;\n\nll MOD(ll a) {\n    if (a >= 0) return a >= M ? a % M : a;\n    if (a <= -M) a %= M;\n    return a ? a + M : a;\n}\n\nconst int N = 109;\nconst int L = 1e5;\n\nstruct edge {\n    int u, v;\n    ll height;\n    edge(int u, int v, ll height): u(u), v(v), height(height) {\n\n    }\n\n};\nvector<edge> e;\n\nll pw(ll a, ll p) {\n    if (!p) return 1;\n    ll ret = pw(a, p >> 1);\n    ret = MOD(ret * ret);\n    if (p & 1) ret = MOD(ret * a);\n    return ret;\n}\n\nint counter = 1;\nvi g[L];\nll len[L];\nint vert[L];\nint start[L];\nll h[N];\nll dp[2][L];\n\ninline ll get_ways(int v) {\n    vvvl dp(N, vvl(2, vl(2, 0)));\n    vector<char> must(N, 0);\n    for (int id : g[v]) {\n        int to = e[id].v;\n        for (int i = 1; i < len[to]; ++i)\n            must[i + start[to]] = 1;\n    }\n    dp[start[v]][0][0] = dp[start[v]][0][1] = 1;\n    for (int i = 1; i < len[v]; ++i) {\n        int ind = i + start[v];\n        if (must[ind]) {\n            for (int z1 : {0, 1}) for (int z2 : {0, 1})\n                dp[ind][z1][z2] = dp[ind - 1][z1][!z2];\n        } else {\n            for (int z1 : {0, 1}) for (int z2 : {0, 1}) for (int z3 : {0, 1}) {\n                int nx = z1;\n                if (z2 != z3) nx = 1;\n                dp[ind][nx][z3] = MOD(dp[ind][nx][z3] + dp[ind - 1][z1][z2]);\n            }\n        }\n    }\n    ll ret = MOD(dp[start[v] + len[v] - 1][1][0] + dp[start[v] + len[v] - 1][1][1]);\n    return ret;\n}\n\nll dfs(int v) {\n    ll dp1 = 1; // wasn't any bad\n    ll dp2 = 0; /* was bad */;\n    ll restlen = len[v];\n    dp[0][v] = 1;\n    for (int id : g[v]) {\n        int to = e[id].v;\n        restlen -= len[to];\n        dfs(to);\n        ll curgood = MOD(pw(2, e[id].height - 1) * dp[0][to]);\n        dp[0][v] = MOD(dp[0][v] * curgood);\n        ll curbad = dp[1][to];\n        ll odp1 = dp1;\n        ll odp2 = dp2;\n        dp1 = MOD(odp1 * curgood * 2);\n        dp2 = MOD(odp2 * (curgood * 2 + curbad) + odp1 * curbad);\n    }\n    ll ways = get_ways(v);\n    dp[1][v] = MOD(dp2 * pw(2, restlen) + dp[0][v] * ways);\n    dp[0][v] = MOD(2 * dp[0][v]);\n}\n\nsigned main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n\n\n    int n;\n    cin >> n;\n    set<ll> hs;\n    fori (i, n) {\n        cin >> h[i];\n        hs.insert(h[i]);\n    }\n    ll prev = 0;\n    len[counter++] = n;\n    fori (i , n)\n        vert[i] = 1;\n    int curv = 0;\n    int par = 0;\n    for (auto hi : hs) {\n        int cnt = 0;\n        fori (i, n) {\n            if (h[i] >= hi) {\n                if (!cnt) {\n                    curv = counter++;\n                    start[curv] = i;\n                }\n                par = vert[i];\n                vert[i] = curv;\n                cnt++;\n            } else {\n                if (cnt >= 2) {\n                    len[curv] = cnt;\n                    g[par].pb(e.size());\n                    e.pb(edge(par, curv, hi - prev));\n                }\n                cnt = 0;\n            }\n        }\n        if (cnt >= 2) {\n            len[curv] = cnt;\n            g[par].pb(e.size());\n            e.pb(edge(par, curv, hi - prev));\n        }\n        prev = hi;\n    }\n    ll fre = 0;\n    fori (i, n) {\n        ll lf = 0, rf = 0;\n        if (i) lf = h[i - 1];\n        if (i != n - 1) rf = h[i + 1];\n        fre += max(0LL, h[i] - max(lf, rf));\n    }\n    dfs(2);\n    ll ans = MOD(dp[0][2] * pw(2, e[g[1][0]].height - 1) + dp[1][2]);\n    ans = MOD(ans * pw(2, fre));\n    cout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i, j, k) for(int i=(j); i<=(k); i++)\n#define FFOR(i, j, k) for(int i=(j); i<(k); i++)\n#define DFOR(i, j, k) for(int i=(j); i>=(k); i--)\n#define bug(x) cerr<<#x<<\" = \"<<(x)<<'\\n'\n#define pb push_back\n#define mp make_pair\n#define bit(s, i) (((s)>>(i))&1LL)\n#define mask(i) ((1LL<<(i)))\n#define builtin_popcount __builtin_popcountll\n#define __builtin_popcount __builtin_popcountll\nusing ll=long long; using ld=long double;\nmt19937_64 rng(chrono::high_resolution_clock::now().time_since_epoch().count()); const ld pi=acos(0)*2;\ntemplate <typename T> inline void read(T &x){char c; bool nega=0; while((!isdigit(c=getchar()))&&(c!='-')); if(c=='-'){nega=1; c=getchar();} x=c-48; while(isdigit(c=getchar())) x=x*10+c-48; if(nega) x=-x;}\ntemplate <typename T> inline void writep(T x){if(x>9) writep(x/10); putchar(x%10+48);}\ntemplate <typename T> inline void write(T x){if(x<0){ putchar('-'); x=-x;} writep(x);}\ntemplate <typename T> inline void writeln(T x){write(x); putchar('\\n');}\ntemplate <typename CT, typename T> inline void reset_container(CT &c, int sz, T v){c.resize(sz); for(auto &x: c) x=v;}\n#define taskname \"agc026_d\"\nint n;\nint h[101];\nconst ll base=1000000007;\nll power(ll a, ll b){\n    if(b==0) return 1;\n    ll t=power(a, b/2);\n    t=(t*t)%base;\n    if(b%2) t=(t*a)%base;\n    return t;\n}\nint minpos[101][101];\nbool doneg[101][101][101];\nll g[101][101][101];\nll G(int l, int r, int low){\n    if(l>r) return 1;\n    ///calculate from l to r, above low\n    if(doneg[l][r][low]) return g[l][r][low];\n    doneg[l][r][low]=1;\n    int x=minpos[l][r];\n    return g[l][r][low]=((G(l, x-1, (h[x]>h[low])?x:low)*G(x+1, r, (h[x]>h[low])?x:low))%base*power(2, max(0, h[x]-h[low])))%base;\n}\nbool done[101][101];\nll f[101][101];\nll F(int l, int low){\n    if(done[l][low]) return f[l][low];\n    done[l][low]=1;\n    int aff[101];\n    aff[l]=low;\n    FOR(i, l+1, n) aff[i]=(h[i]<h[aff[i-1]])?i:aff[i-1];\n    FOR(i, l+1, n){\n        int aff2[101];\n        ll cnt=1;\n        FOR(x, l, i) aff2[x]=aff[x];\n        int now=i;\n        DFOR(j, i, l){\n            if(h[j]<h[now]) now=j;\n            if(h[aff2[j]]<h[now]) aff2[j]=now;\n        }\n        FOR(j, l, i){\n            int k=j;\n            while((k<i-1)&&(aff2[k+1]==aff2[j])) k++;\n            cnt=(cnt*G(j, k, aff2[j]))%base;\n            j=k;\n        }\n        if(h[i]>h[i-1]){\n            f[l][low]+=(cnt*F(i, i-1))%base;\n        }\n        else{\n            f[l][low]+=(cnt*F(i, i))%base;\n        }\n    }\n    ll cnt=1;\n    FOR(j, l, n){\n        int k=j;\n        while((k<n)&&(aff[k+1]==aff[j])) k++;\n        cnt=(cnt*G(j, k, aff[j]))%base;\n        j=k;\n    }\n    f[l][low]+=cnt;\n    f[l][low]%=base;\n    return f[l][low];\n}\nint main(){\n    #ifdef Aria\n        if(fopen(taskname\".in\", \"r\"))\n            freopen(taskname\".in\", \"r\", stdin);\n    #endif // Aria\n    read(n);\n    FOR(i, 1, n) read(h[i]);\n    FOR(l, 1, n) FOR(r, l, n) minpos[l][r]=min_element(h+l, h+r+1)-h;\n    h[0]=1;\n    writeln((F(1, 0)*2)%base);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MN 100\n#define mod 1000000007\n#define MK 32768\nusing namespace std;\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();\n    return x*f;\n}\nint n,a[MN+5],L[MN+5],num,f[MN+5][MN+5],pw[MK+5],PW[MK+5],ans;\ninline void R(int&x,int y){(x+=y)>=mod?x-=mod:0;}\ninline int pw2(int x){return 1LL*PW[x>>15]*pw[x&32767]%mod;}\ninline int Sum(int l,int r){return (pw2(r+1)-pw2(l)+mod)%mod;}\nint main()\n{   \n    n=read();pw[0]=PW[0]=1;\n    for(int i=1;i<=MK;++i) pw[i]=2*pw[i-1]%mod;\n    for(int i=1;i<=MK;++i) PW[i]=1LL*PW[i-1]*pw[MK]%mod;\n    for(int i=1;i<=n;++i) a[i]=L[i]=read();\n    sort(L+1,L+n+1);num=unique(L+1,L+n+1)-L-1;L[++num]=2e9;\n    f[0][num]=1;\n    for(int i=1;i<=n;++i)\n    {\n        a[i]=lower_bound(L+1,L+num+1,a[i])-L;\n        for(int j=1;j<=a[i];++j) R(f[i][j],1LL*f[i-1][j]*pw2(max(0,L[a[i]]-L[a[i-1]]))%mod);\n        int res=0;\n        for(int j=a[i]+1;j<=num;++j) R(res,f[i-1][j]);\n        res=2*res%mod;\n        for(int j=a[i-1]+1;j<=a[i];++j) \n        {\n            int l=max(2,L[j-1]+1),r=L[j];if(l>r) continue;\n            R(f[i][j],1LL*res*Sum(L[a[i]]-r,L[a[i]]-l)%mod);  \n        }\n        R(f[i][num],res);\n    }\n    for(int j=1;j<=num;++j) R(ans,f[n][j]);\n    cout<<ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define llint long long\n#define mod 1000000007\n\nusing namespace std;\n\nllint n;\nllint a[105], b[105];\nllint num[105][105];\nllint dp[105];\n\nllint modpow(llint a, llint n)\n{\n\tif(n == 0) return 1;\n\tif(n % 2){\n\t\treturn ((a%mod) * (modpow(a, n-1)%mod)) % mod;\n\t}\n\telse{\n\t\treturn modpow((a*a)%mod, n/2) % mod;\n\t}\n}\n\nint main(void)\n{\n\tcin >> n;\n\tfor(int i = 1; i <= n; i++) cin >> a[i], a[i]--;\n\t\n\tllint mul = 1;\n\tfor(int i = 1; i <= n; i++){\n\t\tmul *= modpow(2, max(0LL, a[i] - max(a[i-1], a[i+1]))), mul %= mod;\n\t\ta[i] = min(a[i], max(a[i-1], a[i+1]));\n\t}\n\t\n\tfor(int i = 1; i <= n-1; i++) b[i] = min(a[i], a[i+1]);\n\t\n\tfor(int l = 1; l <= n-1; l++){\n\t\tfor(int r = 1; r <= n-1; r++){\n\t\t\tif(l > r) continue;\n\t\t\tllint sum = 0;\n\t\t\tfor(int i = l-1; i <= r; i++){\n\t\t\t\tif(b[i+1] >= b[i]) sum += b[i+1]-b[i];\n\t\t\t\telse{\n\t\t\t\t\tllint d = b[i]-b[i+1], x = min(sum, d);\n\t\t\t\t\tnum[l][r] += x, num[l][r] %= mod-1, sum -= x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tdp[0] = 1;\n\tfor(int i = 1; i <= n; i++){\n\t\tfor(int j = 0; j < i; j++){\n\t\t\tdp[i] += dp[j] * modpow(2, num[j+1][i-1]) % mod;\n\t\t\tdp[i] %= mod;\n\t\t}\n\t}\n\t\n\tllint ans = dp[n];\n\tans *= mul, ans %= mod;\n\tans *= 2, ans %= mod;\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n#define MOD 1000000007\n#define ADD(X,Y) ((X) = ((X) + (Y)%MOD) % MOD)\ntypedef long long i64; typedef vector<int> ivec; typedef vector<string> svec;\n\nint N;\ni64 H[100];\n\ni64 modpow(i64 a, int pw)\n{\n\tif (pw == 0) return 1;\n\ti64 ret = modpow(a, pw / 2);\n\tret = ret * ret % MOD;\n\tif (pw % 2 == 1) ret = ret * a % MOD;\n\treturn ret;\n}\n\npair<i64, i64> solve(int l, int r, i64 base)\n{\n\ti64 lowest = 1001001001;\n\tfor (int i = l; i < r; ++i) lowest = min(lowest, H[i]);\n\n\ti64 alt = 2, nalt = 1;\n\tint start = -1; bool flg = false; int nl = 0;\n\tfor (int i = l; i < r; ++i) {\n\t\tif (H[i] != lowest) {\n\t\t\tif (start == -1) start = i;\n\n\t\t\tif (i == r - 1 || H[i + 1] == lowest) {\n\t\t\t\tauto tmp = solve(start, i + 1, lowest);\n\t\t\t\tstart = -1;\n\n\t\t\t\talt = alt * tmp.first % MOD * 2 % MOD;\n\t\t\t\tnalt = nalt * (tmp.first * 2 + tmp.second) % MOD;\n\n\t\t\t\talt = alt * (MOD + 1) / 2 % MOD;\n\t\t\t\tflg = true;\n\t\t\t}\n\t\t} else {\n\t\t\tnalt = nalt * 2 % MOD;\n\t\t\t++nl;\n\t\t}\n\t}\n\tADD(nalt, MOD - alt);\n\n\talt = alt * modpow(2, (lowest - base - 1)) % MOD;\n\n\treturn {alt, nalt};\n}\n\nint main()\n{\n\tscanf(\"%d\", &N);\n\tfor (int i = 0; i < N; ++i) scanf(\"%lld\", H + i);\n\n\tauto sol = solve(0, N, 0);\n\ti64 ret = (sol.first + sol.second) % MOD;\n\tprintf(\"%lld\\n\", ret);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <iomanip>\n\n#include <vector>\n#include <set>\n#include <bitset>\n#include <map>\n#include <deque>\n#include <string>\n\n#include <algorithm>\n#include <numeric>\n#include <random>\n\n#include <cstdio>\n#include <cassert>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <cmath>\n\nusing namespace std;\n\n#define forn(i, n) for (ll i = 0; i < (ll) (n); ++i)\n#define sz(a) static_cast<int>((a).size())\n#define endl '\\n'\n\nusing ll = long long;\n\nconst ll INF = static_cast<ll>(1e9) + 7;\nconst int MAXN = static_cast<int>(2e5) + 17;\n\nint n;\nint h[MAXN];\n\nbool read() {\n    if (!(cin >> n))\n        return false;\n\n    forn (i, n)\n        cin >> h[i];\n\n    return true;\n}\n\nll binpow(ll x, ll n) {\n    ll res = 1ll;\n\n    for (; n > 0; n >>= 1, x = x * x % INF)\n        if (n & 1)\n            res = res * x % INF;\n\n    return res;\n}\n\npair<ll, ll> dfs(int lx, int rx, int ly, int ry) {\n    if (rx == lx)\n        return make_pair(binpow(2ll, ry - ly + 1), 0);\n\n    if (*max_element(h + lx, h + rx + 1) == ry) {\n        return make_pair(binpow(2ll, ry - ly + 1), (INF + binpow(2ll, rx - lx + 1) - 2) % INF);\n    }\n\n    pair<ll, ll> res = {1, 1};\n\n    for (int i = lx; i <= rx; ++i)\n        if (h[i] > ry) {\n            int l = i, r = i, hh = h[i];\n\n            for (; r <= rx && h[r] > ry; ++r)\n                hh = min(hh, h[r]);\n\n            --r;\n            auto p = dfs(l, r, ry + 1, hh);\n            res.first *= p.first;\n            res.first %= INF;\n            res.second *= (2ll * p.first + p.second);\n            res.second %= INF;\n            i = r;\n        } else {\n            res.second += res.second;\n\n            if (res.second >= INF)\n                res.second -= INF;\n        }\n\n    res.second -= 2ll * res.first % INF;\n\n    if (res.second < 0)\n        res.second += INF;\n\n    res.first *= binpow(2ll, ry - ly + 1);\n    res.first %= INF;\n\n    return res;\n}\n\nvoid solve() {\n    auto p = dfs(0, n - 1, 1, *min_element(h, h + n));\n    ll ans = (p.first + p.second) % INF;\n    cout << ans << endl;\n}\n\nint main() {\n    cin.tie(nullptr);\n    std::ios_base::sync_with_stdio(false);\n    std::mt19937 rand('S' + 'E' + 'R' + 'E' + 'Z' + 'H' + 'K' + 'A');\n\n#ifdef SEREZHKA\n    freopen(\"file.in\", \"r\", stdin);\n#endif\n\n    while (read())\n        solve();\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nconst int N = 105;\nconst int INF = 0x3f3f3f3f;\ntypedef long long ll;\n#define lson l, m, rt<<1\n#define rson m+1, r, rt<<1|1\nconst int MOD = 1e9+7;\n\n\nint h[N];\nint Has[N]; int tot;\nll dp[N][N];\n\nll Pow(ll x, ll y) {\n\tif(y <= 0) return 1;\n\tll result = 1;\n\twhile(y) {\n\t\tif(y & 1)\n\t\t\tresult = result * x % MOD;\n\t\ty >>= 1;\n\t\tx = x*x % MOD;\n\t}\n\treturn result;\n}\n\nint main() {\n\tint n;\n\twhile(~scanf(\"%d\", &n)) {\n\t\ttot = 0;\n\t\tmemset(dp, 0, sizeof(dp));\n\t\th[0] = 0;\n\t\tdp[0][0] = 1;\n\n\t\tfor(int i = 1; i <= n; ++i) {\n\t\t\tscanf(\"%d\", &h[i]);\n\t\t\tHas[++tot] = h[i];\n\t\t}\n\t\tsort(Has + 1, Has + tot + 1);\n\t\ttot = unique(Has+1, Has + tot + 1) - Has - 1;\n\t\t\n\t\tfor(int i = 1; i <= n; ++i) {\n\t\t\th[i] = lower_bound(Has + 1, Has + tot + 1, h[i]) - Has;\n\t\t}\n\t\t\n\t\t\n\t\tfor(int i = 1; i <= n; ++i) {\n\t\t\tdp[i][0] = dp[i-1][0] * 2 % MOD;\n\t\t\tfor(int j = h[i] + 1; j <= h[i-1]; ++j) dp[i][0] = (dp[i][0] + dp[i-1][j] * 2 % MOD) % MOD;\n\n\t\t\tll tmpPow = Pow(2, Has[h[i]] - Has[h[i-1]]);\n\t\t\tfor(int j = 1; j <= h[i]; ++j) {\n\t\t\t\tdp[i][j] = dp[i-1][j] * tmpPow % MOD;\n\t\t\t}\n\n\t\t\tfor(int j = h[i-1] + 1; j <= h[i]; ++j) {\n\t\t\t\tdp[i][j] = (dp[i][j] + j==1? ( dp[i-1][0] * ( Pow(2, Has[j]) - 2) % MOD * Pow(2, Has[h[i]] - Has[j]) % MOD ) :\n\t\t\t\t\t\t\t\t\t\t\t ( dp[i-1][0] * ( 2 * Pow(2, Has[j]-Has[j-1]) - 1) % MOD * Pow(2, Has[h[i]]-Has[j]) % MOD ) \n\t\t\t\t\t\t\t\t\t\t\t ) %MOD;\n\t\t\t}\n\t\t}\n\n\n\t\tll result = 0;\n\t\tfor(int i = 0; i <= tot; ++i) {\n\t\t\tresult = (result + dp[n][i]) % MOD;\n\t\t}\n\t\tprintf(\"%lld\\n\", result);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define min(a,b) ((a)<(b)?(a):(b))\n#define max(a,b) ((a)>(b)?(a):(b))\n#define for1(a,b,i) for(int i=a;i<=b;++i)\n#define FOR2(a,b,i) for(int i=a;i>=b;--i)\nusing namespace std;\ntypedef long long ll;\ninline int read() {\n\tint f=1,sum=0;\n\tchar x=getchar();\n\tfor(;(x<'0'||x>'9');x=getchar()) if(x=='-') f=-1;\n\tfor(;x>='0'&&x<='9';x=getchar()) sum=sum*10+x-'0';\n\treturn f*sum;\n}\n\n#define M 105\n#define mod 1000000007\nint n;\nint a[M];\nint tot,st[M],dui[M],f[M][M];\n\ninline int qpow(int x,int ci) {\n\tint sum=1;\n\tfor(;ci;ci>>=1,x=1ll*x*x%mod)\n\t\tif(ci&1) sum=1ll*x*sum%mod;\n\treturn sum;\n}\n\ninline void inc(int &x,int y){x+=y,x-=x>=mod?mod:0;}\n\nint main() {\n\t//freopen(\"a.in\",\"r\",stdin);\n\tn=read();\n\tfor1(1,n,i) {\n\t\ta[i]=read();\n\t\tdui[i]=a[i]-1;\n\t}\n\tsort(dui+1,dui+n+1);\n\tfor1(1,n,i) {\n\t\tif(dui[i]!=dui[i-1]) ++tot;\n\t\tst[tot]=dui[i];\n\t}\n\tfor1(1,n,i) {\n\t\tif(a[i]==1) a[i]=0;\n\t\telse for1(1,tot,j) if(a[i]==st[j]+1) a[i]=j;\n\t}\n\tf[1][0]=2;\n\tfor1(1,a[1],i) f[1][i]=1ll*(qpow(2,st[i]-st[i-1])-1)*qpow(2,st[a[1]]-st[i]+1)%mod;\n\t//for1(0,a[1],i) cout<<f[1][i]<<\" \"; cout<<endl;\n\tfor1(2,n,i) {\n\t\tfor1(1,tot,j) {\n\t\t\tif(!f[i-1][j]) continue;\n\t\t\tif(j<=a[i]) {\n\t\t\t\tint k=1;\n\t\t\t\tif(a[i]>a[i-1]) k=qpow(2,st[a[i]]-st[a[i-1]]);\n\t\t\t\tinc(f[i][j],1ll*k*f[i-1][j]%mod);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tinc(f[i][0],2ll*f[i-1][j]%mod);\n\t\t\t}\n\t\t}\n\t\tinc(f[i][0],2ll*f[i-1][0]%mod);\n\t\tif(a[i]>a[i-1]) {\n\t\t\tfor1(a[i-1]+1,a[i],j) {\n\t\t\t\tinc(f[i][j],1ll*f[i-1][0]*(qpow(2,st[j]-st[j-1])-1)%mod*qpow(2,st[a[i]]-st[j]+1)%mod);\n\t\t\t}\n\t\t}\n\t}\n\t//for1(0,a[n],i) cout<<f[n][i]<<\" \"; cout<<endl;\n\tint ans=0;\n\tfor1(0,tot,i) inc(ans,f[n][i]);\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef __INTMOD_H__0001__\n#define __INTMOD_H__0001__\n\n#include <vector>\n#include <iostream>\n#include <cassert>\n#include <iostream>\n\n/* Modulus must be less than 0x80000000, and must not be 0. */\ntemplate <uint32_t Modulus>\nclass IntMod {\n\ttypedef int Int;\n\ttypedef unsigned int UInt;\n\ttypedef long long Long;\n\ttypedef unsigned long long ULong;\n\npublic:\n\ttemplate <uint32_t Modulus_>\n\tfriend bool operator==(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <uint32_t Modulus_>\n\tfriend bool operator!=(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <uint32_t Modulus_>\n\tfriend bool operator<(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <uint32_t Modulus_>\n\tfriend bool operator<=(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <uint32_t Modulus_>\n\tfriend bool operator>(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <uint32_t Modulus_>\n\tfriend bool operator>=(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\nprivate:\n\tUInt value_m;\n\npublic:\n\tIntMod() { value_m = 0; }\n\tIntMod(UInt value) { value_m = value % Modulus; }\n\tIntMod(ULong value) { value_m = value % Modulus; }\n\tIntMod(Int value) {\n\t\tInt tmp = value % (Int)Modulus;\n\t\tvalue_m = tmp >= 0 ? tmp : Modulus - (unsigned int)(-tmp);\n\t}\n\tIntMod(Long value) {\n\t\tInt tmp = value % (Long)Modulus;\n\t\tvalue_m = tmp >= 0 ? tmp : Modulus - (unsigned int)(-tmp);\n\t}\n\tIntMod(const IntMod& other) : value_m(other.value_m) {}\n\tIntMod& operator=(const IntMod& other) { value_m = other.value_m; return *this; }\n\t\n\tconst IntMod& operator+() const { return *this; }\n\tIntMod operator-() const { return IntMod(Modulus - value_m); }\n\tIntMod& operator++() {\n\t\t++value_m;\n\t\tif (value_m == Modulus) value_m = 0;\n\t\treturn *this;\n\t}\n\tIntMod& operator--() {\n\t\tif (value_m == 0) value_m = Modulus;\n\t\t--value_m;\n\t\treturn *this;\n\t}\n\tIntMod operator++(int dummy) {\n\t\tIntMod tmp(*this);\n\t\t++(*this);\n\t\treturn tmp;\n\t}\n\tIntMod operator--(int dummy) {\n\t\tIntMod tmp(*this);\n\t\t--(*this);\n\t\treturn tmp;\n\t}\n\tIntMod& operator+=(const IntMod& right) {\n\t\tvalue_m += right.value_m;\t\t// value_m < 0x80000000\n\t\tif (value_m >= Modulus) value_m -= Modulus;\n\t\treturn *this;\n\t}\n\tIntMod& operator-=(const IntMod& right) {\n\t\tif (value_m < right.value_m) value_m += Modulus;\n\t\tvalue_m -= right.value_m;\n\t\treturn *this;\n\t}\n\tIntMod& operator*=(const IntMod& right) {\n\t\tvalue_m = ((ULong)value_m * right.value_m) % Modulus;\n\t\treturn *this;\n\t}\t\n\tIntMod& operator/=(const IntMod& right) {\n\t\t(*this) *= (right.Inverse());\n\t\treturn *this;\n\t}\n\t// for power\n\tIntMod operator[](ULong exp) const {\n\t\treturn Pow(exp);\n\t}\n\n\t/* Modulus must be a prime. */\n\tIntMod Inverse() const { return (*this).Pow(Modulus - 2); }\n\tIntMod Pow(ULong exp) const {\n\t\tIntMod product = 1;\n\t\tIntMod factor(*this);\n\t\twhile (exp > 0) {\n\t\t\tif (exp & 1) product *= factor;\n\t\t\tfactor *= factor;\n\t\t\texp >>= 1;\n\t\t}\n\t\treturn product;\n\t}\n\tUInt Get_value() const {\n\t\treturn value_m;\n\t}\n\n\tstatic IntMod Fact(UInt num) {\n\t\tstatic std::vector<IntMod> table(1, 1);\n\t\tif (table.size() > num) return table[num];\n\n\t\tint old_size = table.size();\n\t\ttable.resize(num + 1);\n\t\tfor (int i = old_size; i <= num; i++) {\n\t\t\ttable[i] = table[i - 1] * i;\n\t\t}\n\t\treturn table[num];\n\t}\n\n\tstatic IntMod Combi(UInt n, UInt r) {\n\t\tif (n < r) throw \"okashii\";\n\t\treturn IntMod::Fact(n) / (IntMod::Fact(n - r) * IntMod::Fact(r));\n\t}\n\n\tstatic std::vector<IntMod> Inverse_list(int size) {\n\t\tassert(size < Modulus);\n\t\tstd::vector<IntMod> ret_arr(size + 1);\n\t\tret_arr[1] = 1;\n\t\tfor (int i = 2; i <= size; ++i) {\n\t\t\tret_arr[i] = ((ULong)(Modulus - Modulus / i) * ret_arr[Modulus % i].Get_value()) % Modulus;\n\t\t}\n\t\treturn ret_arr;\n\t}\n};\n\ntemplate <uint32_t Modulus>\nIntMod<Modulus> operator+(const IntMod<Modulus>& left, const IntMod<Modulus>& right) {\n\tIntMod<Modulus> ret(left);\n\tret += right;\n\treturn ret;\n}\n\ntemplate <uint32_t Modulus>\nIntMod<Modulus> operator-(const IntMod<Modulus>& left, const IntMod<Modulus>& right) {\n\tIntMod<Modulus> ret(left);\n\tret -= right;\n\treturn ret;\n}\n\ntemplate <uint32_t Modulus>\nIntMod<Modulus> operator*(const IntMod<Modulus>& left, const IntMod<Modulus>& right) {\n\tIntMod<Modulus> ret(left);\n\tret *= right;\n\treturn ret;\n}\n\ntemplate <uint32_t Modulus>\nIntMod<Modulus> operator/(const IntMod<Modulus>& left, const IntMod<Modulus>& right) {\n\tIntMod<Modulus> ret(left);\n\tret /= right;\n\treturn ret;\n}\n\n\ntemplate <uint32_t Modulus>\nbool operator==(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m == right.value_m; }\ntemplate <uint32_t Modulus>\nbool operator!=(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m != right.value_m; }\n/* for set/map */\ntemplate <uint32_t Modulus>\nbool operator<(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m < right.value_m; }\ntemplate <uint32_t Modulus>\nbool operator<=(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m <= right.value_m; }\ntemplate <uint32_t Modulus>\nbool operator>(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m > right.value_m; }\ntemplate <uint32_t Modulus>\nbool operator>=(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m >= right.value_m; }\n\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator+(const IntMod<Modulus>& left, Integer right) { return left + IntMod<Modulus>(right); }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator+(Integer left, const IntMod<Modulus>& right) { return IntMod<Modulus>(left) + right; }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator-(const IntMod<Modulus>& left, Integer right) { return left - IntMod<Modulus>(right); }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator-(Integer left, const IntMod<Modulus>& right) { return IntMod<Modulus>(left) - right; }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator*(const IntMod<Modulus>& left, Integer right) { return left * IntMod<Modulus>(right); }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator*(Integer left, const IntMod<Modulus>& right) { return IntMod<Modulus>(left) * right; }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator/(const IntMod<Modulus>& left, Integer right) { return left / IntMod<Modulus>(right); }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator/(Integer left, const IntMod<Modulus>& right) { return IntMod<Modulus>(left) / right; }\n\ntemplate <uint32_t Modulus>\nstd::istream& operator<<(std::istream& ist, const IntMod<Modulus>& val) {\n\tuint64_t tmp;\n\tist >> tmp;\n\tval = tmp;\n\treturn ist;\n}\n\ntemplate <uint32_t Modulus>\nstd::ostream& operator<<(std::ostream& ost, const IntMod<Modulus>& val) {\n\tost << val.Get_value();\n\treturn ost;\n}\n\ntypedef IntMod<1000000007> MInt;\n\n#if 1\nMInt operator\"\" _m(unsigned long long num) { return MInt(num); }\n#endif\n\n#endif\n\n#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n#define REP(i, a, n) for(LL i = (a), i##_max = (n); i < i##_max; ++i)\n#define REM(i, a, n) for(LL i = (LL)(n) - 1, i##min = (a); i >= i##min; --i)\n#define ALL(arr) (arr).begin(), (arr).end()\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP {cin.tie(NULL); ios::sync_with_stdio(false);}\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst string INFSTR = \"\\x7f\";\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate<class T>\nT Compare(T left, T right) { return left > right ? 1 : (left < right ? -1 : 0); }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\ntemplate <class T>\nT Next() { T buf; cin >> buf; return buf; }\n\n#ifdef ONLY_MY_ENVIR\n#include \"IntMod.h\"\n#include \"Union_Find.h\"\n#include \"Graph.h\"\n#include \"Range.h\"\n#include \"Global.h\"\n#include \"Flow_Solver.h\"\n#include \"Tree.h\"\n#include \"Suffix_Array.h\"\n#include \"Geometry.h\"\n#include \"Matrix.h\"\n#include \"Segment_Tree.h\"\n#include \"Rational.h\"\n#include \"Position.h\"\n#include \"Factorization.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>> (istream& ist, __int128& val) { LL tmp;  ist >> tmp; val = tmp; return ist; }\nostream& operator<< (ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\n#if 1234567891\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\t// コスト小を優先\ntemplate <class T>\nauto Is(const T& value) { return [value](const auto& comparand) -> bool { return comparand == value; }; }\n#endif\n\nusing PM = pair<MInt, MInt>;\nint N;\nvector<int> A;\n\nPM sub(vector<int> vec) {\n\tconst int M = vec.size();\n\tif (M == 1) return PM(MInt(2).Pow(vec[0]), 0);\n\t\n\tint mn = *min_element(vec.begin(), vec.end());\n\tfor (int& v : vec) {\n\t\tv -= mn;\n\t}\n\n\tMInt tate = 1;\n\tMInt yoko = 1;\n\tREP(i, 0, M) {\n\t\tif (vec[i] == 0) {\n\t\t\tif (i == 0) {\n\t\t\t\ttate *= 2;\n\t\t\t}\n\t\t\tyoko *= 2;\n\t\t} else {\n\t\t\tbool leftmost = i == 0;\n\t\t\tvector<int> nxt;\n\t\t\twhile (i < M && vec[i]) {\n\t\t\t\tnxt.push_back(vec[i]);\n\t\t\t\t++i;\n\t\t\t}\n\t\t\tPM ret = sub(nxt);\n\t\t\tif (leftmost) {\n\t\t\t\ttate *= ret.first * 2;\n\t\t\t} else {\n\t\t\t\ttate *= ret.first;\n\t\t\t}\n\t\t\tyoko *= ret.first * 2 + ret.second;\n\t\t\t--i;\n\t\t}\n\t}\n\tyoko -= tate;\n\n\ttate *= MInt(2).Pow(mn - 1);\n\treturn PM(tate, yoko);\n}\n\nint main() {\n\tcin >> N;\n\tREP(i, 0, N) {\n\t\tint a;\n\t\tcin >> a;\n\t\tA.push_back(a);\n\t}\n\t\n\tPM ret = sub(A);\n\tcout << ret.first + ret.second << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 110\n#define ll long long\nusing namespace std;\nconst int mod=1e9+7;\nint h[maxn],a[maxn],b[maxn],sz,n;\n\nll qpow(ll a,ll x)\n{\n    ll ret=1;\n    while(x>0)\n    {\n        if(x&1) ret=ret*a%mod;\n        a=a*a%mod;\n        x>>=1;\n    }\n    return ret;\n}\nll cal(int lb,int ub)\n{\n    ll ret=qpow(2,ub+1)+mod-qpow(2,lb);\n    if(ret>=0)ret-=mod;\n    return ret;\n}\nll dp[maxn][maxn];\nvoid upd(int &x,int y)\n{\n    x=(x+y>=mod?x+y-mod:x+y);\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    h[sz++]=1;\n    for(int i=0;i<n;++i)\n    {\n        scanf(\"%d\",&a[i]);\n        h[sz++]=a[i];\n    }\n    sort(h,h+sz); sz=unique(h,h+sz)-h;\n    dp[0][0]=2;\n    for(int i=0;i<n;++i) b[i]=lower_bound(h,h+sz,a[i])-h;\n    for(int i=1;i<=b[0];++i)\n    {\n        int ub=a[0]-(h[i-1]+1)+1;\n        int lb=a[0]-(h[i])+1;\n        //printf(\"h[%d]=%d,lb=%d,ub=%d\\n\",i,h[i],lb,ub);\n        dp[0][i]=cal(lb,ub);\n    }\n\n    for(int i=1;i<n;++i)\n    {\n        dp[i][0]=dp[i-1][0]*2%mod;\n        ll t=qpow(2,max(0,a[i]-a[i-1]));\n        for(int j=1;j<=b[i];++j)\n            if(dp[i-1][j])\n                dp[i][j]=(dp[i][j]+dp[i-1][j]*t)%mod;\n        for(int j=b[i]+1;j<sz;++j)\n            dp[i][0]=(dp[i][0]+dp[i-1][j]*2)%mod;\n        if(b[i]>b[i-1])\n        {\n            for(int j=b[i-1]+1;j<=b[i];++j)\n            {\n                int ub=a[i]-(h[j-1]+1)+1;\n                int lb=a[i]-(h[j])+1;\n                ll ret=cal(lb,ub);\n                dp[i][j]=(dp[i][j]+dp[i-1][0]*ret)%mod;\n            }\n        }\n    }\n    int ans=0;\n    for(int i=0;i<sz;++i)\n    {\n        ans+=dp[n-1][i];\n        if(ans>=mod) ans-=mod;\n    }\n    printf(\"%d\\n\",ans);\n        //for(int j=len+1;j<sz;++j)\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define F first\n#define S second\n#define SZ(x) ((int)(x).size())\n#define ALL(x) (x).begin(),(x).end()\n#ifdef _DEBUG_\n  #define debug(...) printf(__VA_ARGS__)\n#else\n  #define debug(...) (void)0\n#endif\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\n\nconst int MOD = 1e9 + 7;\n\nint add(int x, int y) { x += y; if (x >= MOD) x -= MOD; return x; }\nint sub(int x, int y) { x -= y; if (x < 0) x += MOD; return x; }\nint mul(int x, int y) { return 1ll * x * y % MOD; }\n\nint pw(int a, int k) {\n  int res = 1;\n  while (k) {\n    if (k % 2 == 1)\n      res = mul(res, a);\n    a = mul(a, a);\n    k /= 2;\n  }\n  return res;\n}\n\nconst int MAXN = 100 + 10;\nint N;\nint h[MAXN];\nVI nums;\n\nint dp[MAXN][MAXN];\nint f(int x, int y) {\n  if (dp[x][y] >= 0)\n    return dp[x][y];\n  assert(x >= 1 && y >= 0 && y <= h[x]);\n  if (x == 1) {\n    dp[x][y] = pw(2, nums[h[x]] - nums[y]);\n    if (y > 0)\n      dp[x][y] = mul(2, dp[x][y]);\n    debug(\"dp[%d][%d(%d)] = %d\\n\", x, y, nums[y], dp[x][y]);\n    return dp[x][y];\n  }\n  int t1 =  mul(f(x - 1, min(y, h[x - 1])), pw(2, max(0, min(nums[h[x]] - nums[y], nums[h[x]] - nums[h[x - 1]]))));\n  int t2 =  mul(f(x - 1, min(h[x], h[x - 1])), pw(2, max(0, min(nums[h[x]] - nums[y], nums[h[x]] - nums[h[x - 1]]))));\n  dp[x][y] = add(t1, t2);\n  debug(\"dp[%d][%d(%d)] = %d\\n\", x, y, nums[y], dp[x][y]);\n  return dp[x][y];\n}\n\nint main() {\n  memset(dp, -1, sizeof(dp));\n  cin >> N;\n  nums.PB(0);\n  for (int i = 1; i <= N; i++) {\n    cin >> h[i];\n    nums.PB(h[i]);\n  }\n  sort(ALL(nums));\n  nums.resize(unique(ALL(nums)) - begin(nums));\n  for (int i = 1; i <= N; i++)\n    h[i] = lower_bound(ALL(nums), h[i]) - begin(nums);\n  cout << f(N, 0) << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n#define N 106\n#define mod 1000000007\nint dp[N][N],n,s[N],st[N],v[N],v2[N],ct,as=1;\nint pw(int a,int p){int as=1;while(p){if(p&1)as=1ll*as*a%mod;a=1ll*a*a%mod;p>>=1;}return as;}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&s[i]),v[i]=s[i];\n\tsort(v+1,v+n+1);\n\tv[0]=1;for(int i=1;i<=n;i++)if(v[i]!=v[i-1])v2[++ct]=v[i];\n\tfor(int i=1;i<=n;i++)for(int j=1;j<=ct;j++)if(s[i]==v2[j])st[i]=j;\n\tdp[0][0]=1;\n\tfor(int i=1;i<=n;i++)\n\tif(s[i]==1)\n\t{\n\t\tint su=0;\n\t\tfor(int j=0;j<=ct+1;j++)su=(su+dp[i-1][j])%mod;\n\t\tas=2ll*as*su%mod;\n\t\tdp[i][0]=1;\n\t}\n\telse if(s[i-1]<=1)\n\t{\n\t\tfor(int j=1;j<=st[i];j++)\n\t\tdp[i][j]=pw(2,s[i]-v2[j-1]+(j>1));\n\t\tdp[i][st[i]+1]=2;\n\t\tfor(int j=1;j<=st[i];j++)dp[i][j]=(dp[i][j]-dp[i][j+1]+mod)%mod;\n\t}\n\telse if(s[i]<=s[i-1])\n\t{\n\t\tfor(int j=1;j<=st[i-1]+1;j++)\n\t\tif(j>st[i])dp[i][st[i]+1]=(dp[i][st[i]+1]+2ll*dp[i-1][j])%mod;\n\t\telse dp[i][j]=dp[i-1][j];\n\t}\n\telse\n\t{\n\t\tfor(int j=1;j<=st[i-1];j++)dp[i][j]=1ll*dp[i-1][j]*pw(2,s[i]-s[i-1])%mod;\n\t\tfor(int j=st[i-1]+1;j<=st[i];j++)dp[i][j]=2ll*dp[i-1][st[i-1]+1]*pw(2,s[i]-v2[j-1])%mod;\n\t\tdp[i][st[i]+1]=2ll*dp[i-1][st[i-1]+1]%mod;\n\t\tfor(int j=st[i-1]+1;j<=st[i];j++)dp[i][j]=(dp[i][j]-dp[i][j+1]+mod)%mod;\n\t}\n\tint su=0;\n\tfor(int j=0;j<=ct+1;j++)su=(su+dp[n][j])%mod;\n\tas=1ll*as*su%mod;\n\tprintf(\"%d\\n\",as);\n}//"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N = 105;\nconst int MOD = 1000000007;\n\nint n,m,h[N],w[N];\nLL dp[N][N];\n\nint pow_(int x,int y) {///快速幂求 x的y次方\n    int ans = 1;\n    if(y > 0) {\n        while(y) {\n            if(y % 2)ans = (LL)ans * x % MOD;\n            x = (LL)x * x % MOD;\n            y /= 2;\n        }\n    }\n    return ans;\n}\n\nint main() {\n    scanf(\"%d\",&n);\n    for(int i = 1;i <= n;i ++) {\n        scanf(\"%d\",&h[i]);\n        w[++ m] = h[i];\n    }\n    sort(w + 1,w + m + 1);///高度排序\n    m = unique(w + 1,w + m + 1) - w - 1;///离散化 m是离散化后的长度\n    for(int i = 1;i <= n;i ++) {\n        h[i] = lower_bound(w + 1,w + m + 1,h[i]) - w;\n    }\n    dp[0][0]=1;\n    for(int i = 1;i <= n;i ++) {\n        for(int j = h[i] + 1;j <= h[i - 1];j ++)\n            (dp[i][0] += dp[i - 1][j] * 2 % MOD) %= MOD;\n\n        (dp[i][0] += dp[i - 1][0] * 2 % MOD) %= MOD;///交叉或者不交叉\n\n        int d = pow_(2,w[h[i]] - w[h[i-1]]);\n        for(int j = 1;j <= min(h[i - 1],h[i]);j ++) {\n            dp[i][j] = dp[i - 1][j] * d % MOD;\n        }\n\n        for(int j = h[i - 1] + 1;j <= h[i];j ++) {///比前一列高出的部分\n            if(j > 1)(dp[i][j] += dp[i - 1][0] * (pow_(2,w[j] - w[j - 1]) - 1) % MOD * 2 % MOD * pow_(2,w[h[i]] - w[j]) % MOD) %= MOD;\n            else (dp[i][1] += dp[i - 1][0] * (pow_(2,w[1]) - 2) % MOD * pow_(2,w[h[i]] - w[1]) % MOD) %= MOD;///上一列中无重复的乘上化不超过上一列高度中有重复的\n        }\n    }\n    LL ans = 0;\n    for(int i = 0;i <= h[n];i++)\n        (ans += dp[n][i]) %= MOD;\n    printf(\"%lld\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\nusing namespace std;\nconst int mo=1000000007;\nint n,a[105];\nint power(int x,int y){\n\tint s=1;\n\tfor (;y;y/=2,x=1ll*x*x%mo)\n\t\tif (y&1) s=1ll*s*x%mo;\n\treturn s;\n}\npii F(int l,int r,int v){\n\tif (l==r)\n\t\treturn pii(power(2,a[l]-v-1),0);\n\tint mnv=1<<30,las=l;\n\tpii vf;\n\tFor(i,l,r) mnv=min(mnv,a[i]);\n\tFor(i,l,r+1)\n\t\tif (a[i]==mnv||i==r+1){\n\t\t\tif (las!=i){\n\t\t\t\tpii vson=F(las,i-1,mnv);\n\t\t\t\tint v1=vf.fi,v2=vf.se;\n\t\t\t\tint v3=2ll*vson.fi%mo,v4=vson.se;\n\t\t\t\tif (las==l) vf=pii(v3,v4);\n\t\t\t\telse{\n\t\t\t\t\tvf.fi=1ll*v1*v3%mo;\n\t\t\t\t\tvf.se=(2ll*(v1+v2)*(v3+v4)+mo-vf.fi)%mo;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i!=r+1){\n\t\t\t\tif (i==l) vf=pii(1,0);\n\t\t\t\telse vf.se=(2ll*vf.se+vf.fi)%mo;\n\t\t\t}\n\t\t\tlas=i+1;\n\t\t}\n\tvf.fi=1ll*vf.fi*power(2,mnv-v-1)%mo;\n\treturn vf;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tFor(i,1,n) scanf(\"%d\",&a[i]);\n\tpii ans=F(1,n,0);\n\tprintf(\"%d\",2ll*(ans.fi+ans.se)%mo);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint ungigned\n#define db double\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pli pair<ll,int>\n#define vi vector<int>\n#define vpi vector<pii >\n#define IT iterator\n \n#define PB push_back\n#define MK make_pair\n#define LB lower_bound\n#define UB upper_bound\n#define y1 wzpakking \n#define fi first\n#define se second\n#define BG begin\n#define ED end\n \n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define UPD(x,y) (((x)+=(y))>=mo?(x)-=mo:233)\n#define CLR(a,v) memset(a,v,sizeof(a))\n#define CPY(a,b) memcpy(a,b,sizeof(a))\n#define sqr(x) (1ll*x*x)\n \n#define LS3 k*2,l,mid\n#define RS3 k*2+1,mid+1,r\n#define LS5 k*2,l,mid,x,y\n#define RS5 k*2+1,mid+1,r,x,y\n#define GET pushdown(k);int mid=(l+r)/2\n#define INF (1ll<<60)\nusing namespace std;\n\nconst int mo=1000000007;\nint power(int x,ll y){\n\tint s=1;\n\tfor (;y;y/=2,x=1ll*x*x%mo)\n\t\tif (y&1) s=1ll*s*x%mo;\n\treturn s;\n}\nconst int N=105;\nint a[N],mn[N][N];\nint fxor[N][N];\nint trans[N][N];\nint mx[N],g[N],n;\nint main(){\n\tscanf(\"%d\",&n); n++;\n\tfor (int i=2;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\ta[0]=a[1]=a[n+1]=a[n+2]=1;\n\tfor (int i=1;i<=n;i++){\n\t\tmn[i][i]=i;\n\t\tfor (int j=i+1;j<=n;j++)\n\t\t\tmn[i][j]=(a[j]<a[mn[i][j-1]]?j:mn[i][j-1]);\n\t}\n\tfor (int i=1;i<=n+2;i++)\n\t\tfxor[i][i-1]=1;\n\tfor (int l=n+2;l>=1;l--)\n\t\tfor (int r=l;r<=n+2;r++){\n\t\t\tif (a[l]<a[l-1]||a[r]<a[r+1]) continue;\n\t\t\tint dn=max(a[l-1],a[r+1]),md=mn[l][r];\n\t\t\tif (a[md]<dn) continue;\n\t\t\tfxor[l][r]=1ll*power(2,a[md]-dn)*fxor[l][md-1]%mo*fxor[md+1][r]%mo;\n\t\t}\n\tfor (int l=n+1;l>=1;l--)\n\t\tfor (int r=l;r<=n+1;r++){\n\t\t\tfor (int k=l-1;k<=r+1;k++) mx[k]=0;\n\t\t\tint tmp=a[l-1];\n\t\t\tfor (int k=l;k<=r;k++)\n\t\t\t\tmx[k]=tmp=min(tmp,a[k]);\n\t\t\ttmp=a[r+1];\n\t\t\tfor (int k=r;k>=l;k--)\n\t\t\t\tmx[k]=max(mx[k],tmp=min(tmp,a[k]));\n\t\t\tint las=l-1; trans[l][r]=1;\n\t\t\tfor (int k=l;k<=r+1;k++)\n\t\t\t\tif (mx[k]>=a[k]||k==r+1) trans[l][r]=1ll*trans[l][r]*fxor[las+1][k-1]%mo,las=k;\n\t\t}\n\tg[1]=1;\n\tfor (int i=2;i<=n+2;i++)\n\t\tfor (int j=1;j<i;j++)\n\t\t\tUPD(g[i],1ll*g[j]*trans[j][i-1]%mo);\n\tprintf(\"%d\\n\",1ll*g[n+2]*500000004ll%mo);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n\nusing namespace std;\nconst int mod = 1e9+7;\nint ad(int x,int y) { x+=y; return x>=mod?x-mod:x; }\nint mu(int x,int y) { return 1ll*x*y%mod; }\nint sb(int x,int y) { x-=y; return x<0?x+mod:x; }\nint ksm(int a,int b) {\n\tint ans = 1;\n\tfor(;b;b>>=1,a=mu(a,a))\n\t\tif(b&1) ans = mu(ans,a);\n\treturn ans;\n}\nint n,h[1005];\n\nstruct node{\n\tint s0,s1;\n}; //s0 no xiangling s1 suiyi\n\nnode DC(int l,int r,int lm) {\n\tint x0 = 1 , x1 = 1 , cc = 0;\n\tint mimi = 0x3f3f3f3f;\n\tfor(int i=l;i<=r;i++) {\n\t\tmimi = min(mimi,h[i]);\n\t}\n\tfor(int i=l;i<=r;i++) cc += (h[i]==mimi);\n\tfor(int i=l,j;i<=r;i=j+1) {\n\t\tj = i;\n\t\tif(h[i]>mimi) {\n\t\t\twhile(j+1<=r&&h[j+1]!=mimi) j++;\n\t\t\tnode yoo = DC(i,j,mimi);\n\t\t\tx0 = mu(x0,yoo.s0); x1 = mu(x1,ad(yoo.s0,yoo.s1));\n\t\t}\n\t}\n\treturn (node){mu(x0,ksm(2,mimi-lm)),ad(mu(x0,sb(ksm(2,mimi-lm),2) ),mu(x1,ksm(2,cc))) };\n}\n\nint main() {\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) {\n\t\tscanf(\"%d\",&h[i]);\n\t}\n\tnode ans = DC(1,n,0);\n\tprintf(\"%d\",ans.s1);\n}\n//"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nll H[105];\nll mo=1000000007;\nll ret=1;\n\nll memo[105][105];\n\nll dp[101010];\n\nll modpow(ll a, ll n = mo-2) {\n\tll r=1;a%=mo;\n\twhile(n) r=r*((n%2)?a:1)%mo,a=a*a%mo,n>>=1;\n\treturn r;\n}\n\n\nll hoge(int L,int R) {\n\tif(L>R) return 1;\n\tif(memo[L][R]>=0) return memo[L][R];\n\t\n\tll HH[105]={};\n\tint i;\n\tHH[L-1]=H[L-1];\n\tHH[R+1]=H[R+1];\n\tfor(i=L;i<=R;i++) HH[i]=max(HH[i],min(HH[i-1],H[i]));\n\tfor(i=R;i>=L;i--) HH[i]=max(HH[i],min(HH[i+1],H[i]));\n\t\n\tint x=L;\n\tfor(int i=L+1;i<=R;i++) if(H[i]>H[x]) x=i;\n\tmemo[L][R]=modpow(2,H[x]-HH[x])*hoge(L,x-1)%mo*hoge(x+1,R)%mo;\n\treturn memo[L][R];\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tfor(i=1;i<=N;i++) cin>>H[i];\n\tMINUS(memo);\n\t\n\tFOR(j,1001) {\n\t\tFOR(i,N+1) {\n\t\t\tif(H[i]==1) {\n\t\t\t\t(ret*=2)%=mo;\n\t\t\t\tH[i]=0;\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<N+1;i++) {\n\t\t\tif(H[i]>max(H[i-1],H[i+1])) {\n\t\t\t\t(ret*=modpow(2,H[i]-max(H[i-1],H[i+1])))%=mo;\n\t\t\t\tH[i]=max(H[i-1],H[i+1]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint L,R;\n\tfor(L=1;L<=N;L++) if(H[L]) {\n\t\tR=L;\n\t\twhile(R<=N && H[R]) R++;\n\t\t\n\t\tdp[L-1]=2;\n\t\tfor(int x=L;x<R;x++) {\n\t\t\tfor(y=L-1;y<x;y++) {\n\t\t\t\tfor(i=y+1;i<x;i++) {\n\t\t\t\t\tdp[x]+=dp[y]*hoge(y+1,i-1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[x]%=mo;\n\t\t\t\n\t\t}\n\t\tll tot=0;\n\t\tfor(x=L-1;x<R;x++) {\n\t\t\tif(x==L-1) tot+=dp[x]*hoge(x+1,R-1)%mo*((mo+1)/2)%mo;\n\t\t\telse tot+=dp[x]*hoge(x+1,R-1)%mo;\n\t\t}\n\t\t\n\t\t(ret*=tot%mo)%=mo;\n\t\tL=R;\n\t}\n\t\n\tcout<<ret<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\n#include <stdlib.h>\n#include <vector>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <string.h>\n#include <stack>\n#define Endl endl\n#define mp make_pair\n#define ll long long \n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define over(A) {cout<<A<<endl;exit(0);}\n#define all(A) A.begin(),A.end()\n#define ceil(a,b) ((a-1)/b+1)\n#define srand() mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n#define rand(l,r) uniform_int_distribution<int>(l,r)(rng)\ntypedef unsigned long long ull;\nconst int inf=1039074182;\nusing namespace std;\nint n;\nint h[105];\nint res=1;\nvector <pair<pair<int,int>,int> >vec;\nint dp[105][105][2];\n\nnamespace combinatorics\n{\n\tint mod=1e9+7;\n\tinline int add(int a,int b)\n\t{\n\t\treturn (a+b)%mod;\n\t}\n\tinline int minus(int a,int b)\n\t{\n\t\treturn (a-b+mod)%mod;\n\t}\n\tinline int mutiply(int a,int b)\n\t{\n\t\treturn (1LL*a*b)%mod;\n\t}\n\tinline int fastpow(int basic,int x)\n\t{\n\t\tint res=1;\n\t\twhile(x)\n\t\t{\n\t\t\tif(x&1)\tres=mutiply(res,basic);\n\t\t\tbasic=mutiply(basic,basic);\n\t\t\tx>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tinline int inv(int x)\n\t{\n\t\treturn fastpow(x,mod-2);\n\t}\n};\nusing namespace combinatorics;\n\ninline void solve(int l,int r)\n{\n//\tcout<<l<<' '<<r<<endl;\n//\tSleep(1000);\n\tif(l==r) return;\n\tint mi=inf,ma=inf;\n\tfor(int i=l;i<r;i++)\n\t{\n\t\tmi=min(mi,h[i]);\n\t}\n\tvec.push_back({{l,r},mi-(l==0 && r==n)});\n\tfor(int i=l;i<r;i++)\n\t{\n\t\th[i]-=mi;\n\t}\n\tint last=l;\n\tfor(int i=l;i<=r;i++)\n\t{\n\t\tif(h[i]==0) solve(last,i),last=i+1;\n\t}\n}\n\ninline int way(int l,int r)\n{\n\tint res=0;\n\tfor(auto x:vec)\n\t{\n\t\tif(l<=x.first.first && r>=x.first.second) res=(res+x.second)%(mod-1);\n\t}\n\treturn fastpow(2,res);\n}\n\nint main()\n{\n\tfreopen(\"input.txt\",\"r\",stdin);\n//\tfreopen(\"1.out\",\"w\",stdout);\n\tcin>>n;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcin>>h[i];\n\t}\n\tsolve(0,n);\n//\tfor(auto x:vec)\n//\t{\n//\t\tprintf(\"From %d to %d, having %d floors.\\n\",x.first.first+1,x.first.second,x.second);\n//\t}\n\tdp[0][1][0]=1;\n\tdp[0][1][1]=1;\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tfor(int j=1;j<=i+1;j++)\n\t\t{\n\t\t\tfor(int k=0;k<2;k++)\n\t\t\t{\n\t\t\t\tdp[i+1][j+1][k]=add(dp[i+1][j+1][k],dp[i][j][k]);\n\t\t\t\tdp[i+1][1][!k]=add(dp[i+1][1][!k],mutiply(dp[i][j][k],way(i-j+1,i+1)));\n\t\t\t}\n\t\t}\n\t}\n\tint res=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tdp[n-1][i][0]=mutiply(dp[n-1][i][0],way(n-i,n));\n\t\tdp[n-1][i][1]=mutiply(dp[n-1][i][1],way(n-i,n));\n\t\tres=add(res,add(dp[n-1][i][0],dp[n-1][i][1]));\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <deque>\n#include <stack>\n#include <bitset>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,ll> pil;\ntypedef pair<ll,int> pli;\n#define rep(i,n) for (int i=0;i<n;++i)\n#define REP(i,n) for (int i=1;i<=n;++i)\n#define all(x) x.begin(),x.end()\n#define mp make_pair\n#define pb push_back\n#define pf push_front\n#define F first\n#define S second\n#define read(x) scanf(\"%d\",&x)\nconst ll MOD=1e9+7;\nint n;\nint H[105];\ninline ll pow2(int exp){\n\tll ret=1,tmp=2;\n\twhile(exp){\n\t\tif (exp&1) ret=ret*tmp%MOD;\n\t\ttmp=tmp*tmp%MOD;\n\t\texp>>=1;\n\t}\n\treturn ret;\n}\ninline pair<ll,ll> dp(int l,int r,int h){\n\tint low=2e9,cnt=0;\n\tfor (int i=l;i<=r;++i){\n\t\tif (low==H[i]) ++cnt;\n\t\telse if (H[i]<low) low=H[i],cnt=1;\n\t}\n\tif (cnt==r-l+1){\n\t\treturn mp(pow2(low-h)%MOD,(pow2(cnt)+pow2(low-h)-2)%MOD);\n\t}\n\telse{\n\t\tpair<ll,ll> data[105];int cntseg=0;\n\t\tfor (int i=l;i<=r;){\n\t\t\twhile(i<=r&&H[i]==low) ++i;\n\t\t\tint nl=i;\n\t\t\twhile(i<=r&&H[i]>low) ++i;\n\t\t\tint nr=i-1;\n\t\t\tif (nr<nl) continue;\n\t\t\tdata[++cntseg]=dp(nl,nr,low);\n\t\t}\n\t\tpair<ll,ll> ret=mp(1,1);\n\t\tfor (int i=1;i<=cntseg;++i) ret.F=ret.F*data[i].F%MOD;\n\t\tret.F=ret.F*pow2(low-h)%MOD;\n\t\tll part1=1,part2=1;\n\t\tfor (int i=1;i<=cntseg;++i) part1=part1*(data[i].F+data[i].S)%MOD;\n\t\tpart1=part1*pow2(cnt)%MOD;\n\t\tfor (int i=1;i<=cntseg;++i) part2=part2*data[i].F%MOD;\n\t\tpart2=part2*(pow2(low-h)-2)%MOD;\n\t\tret.S=(part1+part2)%MOD;\n\t\treturn ret;\n\t}\n}\nint main(){\n\tios::sync_with_stdio(false);\n\tcin>>n;\n\tfor (int i=1;i<=n;++i) cin>>H[i];\n\tpair<ll,ll> ret=dp(1,n,0);\n\tcout<<ret.S<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\nusing ll = long long int;\nusing int64 = long long int;\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst int INF = 1LL << 29;\nconst ll LONGINF = 1LL << 60;\nconst ll MOD = 1000000007LL;\n\n// ModInt begin\n\nusing ll = long long;\ntemplate<ll mod>\nstruct ModInt {\n    ll v;\n    ll mod_pow(ll x, ll n) const {\n        return (!n) ? 1 : (mod_pow((x*x)%mod,n/2) * ((n&1)?x:1)) % mod;\n    }\n    ModInt(ll a = 0) : v((a %= mod) < 0 ? a + mod : a) {}\n    ModInt operator+ ( const ModInt& b ) const {\n        return (v + b.v >= mod ? ModInt(v + b.v - mod) : ModInt(v + b.v));\n    }\n    ModInt operator- () const {\n        return ModInt(-v);\n    }\n    ModInt operator- ( const ModInt& b ) const {\n        return (v - b.v < 0 ? ModInt(v - b.v + mod) : ModInt(v - b.v));\n    }\n    ModInt operator* ( const ModInt& b ) const {return (v * b.v) % mod;}\n    ModInt operator/ ( const ModInt& b ) const {return (v * mod_pow(b.v, mod-2)) % mod;}\n    \n    bool operator== ( const ModInt &b ) const {return v == b.v;}\n    bool operator!= ( const ModInt &b ) const {return !(*this == b); }\n    ModInt& operator+= ( const ModInt &b ) {\n        v += b.v;\n        if(v >= mod) v -= mod;\n        return *this;\n    }\n    ModInt& operator-= ( const ModInt &b ) {\n        v -= b.v;\n        if(v < 0) v += mod;\n        return *this;\n    }\n    ModInt& operator*= ( const ModInt &b ) {\n        (v *= b.v) %= mod;\n        return *this;\n    }\n    ModInt& operator/= ( const ModInt &b ) {\n        (v *= mod_pow(b.v, mod-2)) %= mod;\n        return *this;\n    }\n    ModInt pow(ll x) { return ModInt(mod_pow(v, x)); }\n    // operator int() const { return int(v); }\n    // operator long long int() const { return v; }\n};\n\ntemplate<ll mod>\nModInt<mod> pow(ModInt<mod> n, ll k) {\n    return ModInt<mod>(n.mod_pow(n.v, k));\n}\n\ntemplate<ll mod>\nostream& operator<< (ostream& out, ModInt<mod> a) {return out << a.v;}\ntemplate<ll mod>\nistream& operator>> (istream& in, ModInt<mod>& a) {\n    in >> a.v;\n    return in;\n}\n\n// ModInt end\n\nusing mint = ModInt<MOD>;\nusing PairTp = pair<mint, mint>;\n\nPairTp solve(int l, int r, vector<ll> &h) {\n    ll mi = LONGINF;\n    for(int i=l; i<r; i++) chmin(mi, h[i]);\n    for(int i=l; i<r; i++) h[i] -= mi;\n\n    mint cnt_01(1), cnt_all(1);\n    int blank = 0, lb = l;\n    for(; lb<r; ) {\n        if(h[lb] == 0) blank++, lb++;\n        else {\n            int ub = lb;\n            while(ub < r and h[ub] > 0) ub++;\n            auto val = solve(lb, ub, h);\n            cnt_01 *= val.first;\n            cnt_all *= (val.first + val.second);\n            lb = ub;\n        }\n    }\n    mint res_01 = pow(mint(2), mi) * cnt_01;\n    mint res_all = pow(mint(2), blank) * cnt_all + (pow(mint(2), mi) - mint(2)) * cnt_01;\n    return make_pair(res_01, res_all);\n}\n\nint main() {\n    int N; scanf(\"%d\", &N);\n    vector<ll> H(N);\n    for(int i=0; i<N; i++) scanf(\"%lld\", &H[i]);\n\n    auto ans = solve(0, N, H);\n    cout << ans.second << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define Mp make_pair\n#define pb push_back\n#define rep(i, j, k) for (int i = (j); i <= (k); i++)\n#define per(i, j, k) for (int i = (j); i >= (k); i--)\nusing namespace std;\n\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\n\nconst int N = 103,mod = 1e9+7,inf=0x3f3f3f3f;\nint n,a[N];\n\nint qpow(int a,int b){\n    int ret=1;\n    while(b){\n        if(b&1) ret=(ll)ret*a;\n        a=(ll)a*a; b>>=1;\n    }\n    return ret;\n}\nPII solve(int l,int r,int h){\n    if(l==r) return Mp(qpow(2,a[l]-h),qpow(2,a[l]-h));\n    int mnh=inf;\n    rep(i,l,r) mnh=min(mnh,a[i]);\n    int c=1,t=qpow(2,mnh-h);\n    rep(i,l,r) if(a[i]==mnh) c=(ll)c*2%mod;\n    int x=1,y=1;\n    for(int i = l,j=l; i<=r; i=j+1,j=i){\n        if(a[i]==mnh) continue;\n        while(j<r&&a[j+1]!=mnh) j++;\n        PII ret=solve(i,j,mnh);\n        x=(ll)x*ret.fi%mod;\n        y=(ll)y*(ret.fi+ret.se)%mod;\n    }\n    int f=(ll)x*t%mod;\n    int s=((ll)c*y+(ll)(t-2+mod)*x)%mod;\n    return Mp(f,s);\n}\n\nint main(){\n    scanf(\"%d\",&n);\n    rep(i,1,n) scanf(\"%d\",&a[i]);\n    printf(\"%d\\n\",solve(1,n,0).se);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#define SF scanf\n#define PF printf\n#define MAXN 100010\n#define MOD 1000000007\nusing namespace std;\nint n;\ntypedef long long ll;\nll dp[MAXN],h[MAXN];\nll fsp(ll x,ll y){\n\tll res=1;\n\twhile(y){\n\t\tif(y&1)\n\t\t\tres=res*x%MOD;\n\t\tx=x*x%MOD;\n\t\ty>>=1;\n\t}\n\treturn res;\n}\nint main(){\n\tSF(\"%d\",&n);\n\tdp[n+1]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tSF(\"%lld\",&h[i]);\n\t\tif(h[i]==1){\n\t\t\th[i]--;\n\t\t\tdp[n+1]=dp[n+1]*2ll%MOD;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tif(h[i]>h[i-1]&&h[i]>h[i+1]){\n\t\t\tint h1=max(h[i-1],h[i+1]);\n\t\t\tdp[n+1]=dp[n+1]*fsp(2,h[i]-h1)%MOD;\n\t\t\th[i]=h1;\t\n\t\t}\n\tfor(int i=n;i>0;i--){\n\t\t//PF(\"{%d}\",i);\n\t\tif(h[i])\n\t\t\tdp[i]=dp[i+1]*2ll%MOD;\n\t\telse{\n\t\t\tdp[i]=dp[i+1];\n\t\t\tcontinue;\n\t\t} \n\t \tll minh=h[i],q=i;\n\t\tfor(int j=i;h[j]==h[i];j++)\n\t\t\tif(h[j+1]>h[i]){\n\t\t\t\tq=j;\n\t\t\t\tminh++;\n\t\t\t}\n\t\tll res1=0;\n\t\tll end,sumh=0;\n\t\tif(h[i]<h[i-1])\n\t\t\tend=h[i];\n\t\telse\n\t\t\tend=h[i-1]+1;\n\t\t//PF(\"{%d %d}\\n\",minh,end);\n\t\tfor(int j=q+1;minh>end;j++){\n\t\t\tif(h[j]>h[j-1])\n\t\t\t\tsumh+=h[j]-h[j-1];\n\t\t\tif(h[j]<minh){\n\t\t\t\tint minh1=max(end,h[j]);\n\t\t\t\t//PF(\"{%d %d %d}\\n\",sumh+h[i]-minh,minh-minh1,-(minh==(h[i]+1)?0:1));\n\t\t\t\tif(minh==h[i]+1)\n\t\t\t\t\tres1+=dp[j]*(fsp(2,sumh+h[i]-minh+q-i+2)+fsp(2,sumh+h[i]-minh+2)*(fsp(2,minh-minh1-1)-1)%MOD)%MOD;\n\t\t\t\telse\n\t\t\t\t\tres1+=dp[j]*(fsp(2,sumh+h[i]-minh+1)*(fsp(2,minh-minh1)-1)%MOD)%MOD;\n\t\t\t\tres1%=MOD;\n\t\t\t\tminh=minh1;\n\t\t\t}\n\t\t}\n\t\tdp[i]+=res1;\n\t\tdp[i]%=MOD;\n\t\t//PF(\"{%lld}\\n\",dp[i]);\n\t}\n\tPF(\"%lld\",dp[1]);\n} \n"
  },
  {
    "language": "C++",
    "code": "// Copyright by libra9z\n#ifndef ONLINE_JUDGE\n#define __DEBUG\n#endif\n\n#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n#pragma GCC optimize(\"Ofast,no-stack-protector\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\")\n\n#define _CRT_SECURE_NO_WARNINGS\n#include <immintrin.h>\n#include <emmintrin.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <algorithm>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cstdint>\n#include <cstring>\n#include <cstdlib>\n#include <vector>\n#include <bitset>\n#include <cstdio>\n#include <queue>\n#include <deque>\n#include <cmath>\n#include <ctime>\n#include <set>\n#include <map>\nusing namespace std;\n#include <ext/rope>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/hash_policy.hpp>\n#include <ext/pb_ds/priority_queue.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\ntemplate <typename T, typename Comp = less <T>, typename Heap_tag = __gnu_pbds :: pairing_heap_tag>\nusing Priority_queue = __gnu_pbds :: priority_queue <T, Comp, Heap_tag>;\ntemplate <typename Key, typename Value>\nusing hashmap = __gnu_pbds :: gp_hash_table <Key, Value>;\ntemplate <typename T, typename Comp = less <T> >\nusing ordered_set = __gnu_pbds :: tree <T, __gnu_pbds :: null_type,\n\t\t\tComp, __gnu_pbds :: rb_tree_tag, __gnu_pbds :: tree_order_statistics_node_update>;\nstruct custom_hash {\n\tstatic uint64_t splitmix64(uint64_t x) {\n\t\tx += 0x9e3779b97f4a7c15;\n\t\tx = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n\t\tx = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n\t\treturn x ^ (x >> 31);\n\t}\n\tsize_t operator()(uint64_t x) const {\n\t\tstatic const uint64_t FIXED_RANDOM = chrono :: steady_clock :: now().time_since_epoch().count();\n\t\treturn splitmix64(x + FIXED_RANDOM);\n\t}\n};\ntemplate <typename T>\nusing hash_set = unordered_set <T, custom_hash>;\ntemplate <typename T, typename K>\nusing hash_map = unordered_map <T, K, custom_hash>;\n\n#define rep(i, n) for (int i = 0; i < (n); ++ i)\n#define rep1(i, n) for (int i = 1; i <= (n); ++ i)\n#define Rep(i, a, b) for (int i = (a); i <= (b); ++ i)\n#define repit(it, a) for (__typeof(a.begin()) it = a.begin(); it != a.end(); it ++)\n#define FILEOPEN(f)                              \\\n        freopen(f\".in\", \"r\", stdin);             \\\n        freopen(f\".out\", \"w\", stdout)\n#define All(a) a.begin(), a.end()\n#define SZ(a) ((int)a.size())\n#define sqr(s) ((s) * (s))\n#define fillset(a, val) memset(a, val, sizeof(a))\n#define fi first\n#define se second\n#define y0 y19260817\n#define y1 y19268107\n#define j0 j19260817\n#define j1 j19268107\n#define x0 x19260817\n#define x1 x19268107\n#ifndef __DEBUG\n#define Debug(...)\n#else\ntemplate <typename T> inline void _debug(const char *names, T &&t) {\n\t(cerr << names << \" = \" << t << endl).flush();\n}\ntemplate <typename T1, typename ...T>\ninline void _debug(const char *names, T1 &&t1, T &&... t) {\n\tconst char *comma = strchr(names, ',');\n\t(cerr.write(names, comma - names) << \" = \" << t1 << \", \").flush();\n\t_debug(comma + 1, t ...);\n}\n#define Debug(...) _debug(#__VA_ARGS__, __VA_ARGS__)\n#endif\ntemplate <typename T>\ninline T chmax(T &x, T y) { return x = max(x, y); }\ntemplate <typename T>\ninline T chmin(T &x, T y) { return x = min(x, y); }\ntemplate <typename T>\ninline void reinit(T &t) { t.~T(); new (&t) T(); }\ntemplate <typename T>\ninline void readval(T &t) { cin >> t; }\ntemplate <typename T>\ninline T readin() { T t; cin >> t; return t; }\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long long llong;\ntypedef unsigned long long ullong;\ntypedef long double ld;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef ullong hash_type;\n\nconst int inf = 0x3f3f3f3f;\nconst ll lnf = 0x3f3f3f3f3f3f3f3f;\nconst double EPS = 1e-9, PI = acos(-1.0);\nconst int mod1 = 1000'000'007, mod2 = 998'244'353;\nmt19937 __random_gen(time(NULL));\n\ntemplate <unsigned MOD>\nclass modular_int {\n\tpublic:\n\t\ttypedef unsigned value_type;\n\tprotected:\n\t\tunsigned x;\n\tpublic:\n\t\tmodular_int inv() const {\n\t\t\tunsigned a = MOD, b = x;\n\t\t\tint u = 0, v = 1;\n\t\t\twhile (b) {\n\t\t\t\tint t = a / b;\n\t\t\t\ta -= t * b, swap(a, b);\n\t\t\t\tu -= t * v, swap(u, v);\n\t\t\t} if (u < 0) u += MOD;\n\t\t\treturn modular_int(u);\n\t\t}\n\t\tinline modular_int pow(long long y) const {\n\t\t\tmodular_int b = *this, r = 1;\n\t\t\tif (y < 0) b = b.inv(), y = -y;\n\t\t\tfor (; y; y >>= 1, b *= b) if (y & 1) r *= b;\n\t\t\treturn r;\n\t\t}\n\tpublic:\n\t\tmodular_int() { x = 0; }\n\t\tmodular_int(const modular_int &y) { x = y.x; }\n\t\tmodular_int(modular_int &&y) { x = y.x; }\n\t\tinline void clear() { *this = modular_int(); }\n\t\tinline int to_int() const { return (int)x; }\n\t\tinline unsigned value() const { return x; }\n\t\tinline void invalid_copyright() {\n\t\t\tstd :: cerr << \"\\\"modular_int\\\" copyrights by libra9z, \";\n\t\t\tstd :: cerr << \"don't use it unless getting the agreement of libra9z! \";\n\t\t\tstd :: cerr << \"(You can ask libra9z on \\\"https://codeforces.com/profile/libra9z\\\")\\n\";\n\t\t\t__builtin_abort();\n\t\t}\n\tpublic:\n\t\tmodular_int(int y) { if (y < 0 || (int)MOD <= y) y %= (int)MOD; if (y < 0) y += MOD; x = y; }\n\t\tmodular_int(unsigned y) { if (MOD <= y) x = y % MOD; else x = y; }\n\t\tmodular_int(long long y) { if (y < 0 || MOD <= y) y %= MOD; if (y < 0) y += MOD; x = y; }\n\t\tmodular_int(unsigned long long y) { if (MOD <= y) x = y % MOD; else x = y; }\n\t\tmodular_int &operator = (const modular_int &y) { x = y.x; }\n\t\tmodular_int &operator = (const int &y) { x = y; }\n\t\tmodular_int &operator = (const long long &y) { x = y; }\n\t\tmodular_int &operator = (const unsigned int &y) { x = y; }\n\t\tmodular_int &operator = (const unsigned long long &y) { x = y; }\n\t\tmodular_int &operator += (const modular_int &y) { if ((x += y.x) >= MOD) x -= MOD; return *this; }\n\t\tmodular_int &operator -= (const modular_int &y) { if ((x -= y.x) & (1u << 31)) x += MOD; return *this; }\n\t\tmodular_int &operator *= (const modular_int &y) { x = (unsigned long long)x * y.x % MOD; return *this; }\n\t\tmodular_int &operator /= (const modular_int &y) { x = (unsigned long long)x * y.inv().x % MOD; return *this; }\n\t\tmodular_int &operator += (const int &y) { return *this += modular_int(y); }\n\t\tmodular_int &operator -= (const int &y) { return *this -= modular_int(y); }\n\t\tmodular_int &operator *= (const int &y) { return *this *= modular_int(y); }\n\t\tmodular_int &operator /= (const int &y) { return *this /= modular_int(y); }\n\t\tmodular_int &operator += (const long long &y) { return *this += modular_int(y); }\n\t\tmodular_int &operator -= (const long long &y) { return *this -= modular_int(y); }\n\t\tmodular_int &operator *= (const long long &y) { return *this *= modular_int(y); }\n\t\tmodular_int &operator /= (const long long &y) { return *this /= modular_int(y); }\n\t\tmodular_int &operator += (const unsigned int &y) { return *this += modular_int(y); }\n\t\tmodular_int &operator -= (const unsigned int &y) { return *this -= modular_int(y); }\n\t\tmodular_int &operator *= (const unsigned int &y) { return *this *= modular_int(y); }\n\t\tmodular_int &operator /= (const unsigned int &y) { return *this /= modular_int(y); }\n\t\tmodular_int &operator += (const unsigned long long &y) { return *this += modular_int(y); }\n\t\tmodular_int &operator -= (const unsigned long long &y) { return *this -= modular_int(y); }\n\t\tmodular_int &operator *= (const unsigned long long &y) { return *this *= modular_int(y); }\n\t\tmodular_int &operator /= (const unsigned long long &y) { return *this /= modular_int(y); }\n\t\tfriend modular_int operator + (modular_int x, const modular_int &y) { return x += y; }\n\t\tfriend modular_int operator - (modular_int x, const modular_int &y) { return x -= y; }\n\t\tfriend modular_int operator * (modular_int x, const modular_int &y) { return x *= y; }\n\t\tfriend modular_int operator / (modular_int x, const modular_int &y) { return x *= y.inv(); }\n\t\tfriend modular_int operator + (modular_int x, const int &y) { return x += y; }\n\t\tfriend modular_int operator - (modular_int x, const int &y) { return x -= y; }\n\t\tfriend modular_int operator * (modular_int x, const int &y) { return x *= y; }\n\t\tfriend modular_int operator / (modular_int x, const int &y) { return x /= y; }\n\t\tfriend modular_int operator + (modular_int x, const long long &y) { return x += y; }\n\t\tfriend modular_int operator - (modular_int x, const long long &y) { return x -= y; }\n\t\tfriend modular_int operator * (modular_int x, const long long &y) { return x *= y; }\n\t\tfriend modular_int operator / (modular_int x, const long long &y) { return x /= y; }\n\t\tfriend modular_int operator + (modular_int x, const unsigned &y) { return x += y; }\n\t\tfriend modular_int operator - (modular_int x, const unsigned &y) { return x -= y; }\n\t\tfriend modular_int operator * (modular_int x, const unsigned &y) { return x *= y; }\n\t\tfriend modular_int operator / (modular_int x, const unsigned &y) { return x /= y; }\n\t\tfriend modular_int operator + (modular_int x, const unsigned long long &y) { return x += y; }\n\t\tfriend modular_int operator - (modular_int x, const unsigned long long &y) { return x -= y; }\n\t\tfriend modular_int operator * (modular_int x, const unsigned long long &y) { return x *= y; }\n\t\tfriend modular_int operator / (modular_int x, const unsigned long long &y) { return x /= y; }\n\t\tmodular_int operator - () const { return (x ? MOD - x : 0); }\n\t\tmodular_int operator ++ () const { return *this += 1; }\n\t\tmodular_int operator -- () const { return *this -= 1; }\n\t\tmodular_int operator ++ (int) const { modular_int ret = *this; *this += 1; return ret; }\n\t\tmodular_int operator -- (int) const { modular_int ret = *this; *this -= 1; return ret; }\n\t\tfriend bool operator < (const modular_int &x, const modular_int &y) { return x.x < y.x; }\n\t\tfriend bool operator == (const modular_int &x, const modular_int &y) { return x.x == y.x; }\n\t\tfriend bool operator != (const modular_int &x, const modular_int &y) { return x.x != y.x; }\n\t\tfriend ostream &operator << (ostream &os, modular_int x) { return os << x.x; }\n\t\tfriend istream &operator >> (istream &is, modular_int &x) { is >> x.x; x.x %= MOD; return is; }\n};\ntypedef modular_int <mod1> mod_int;\n\npair <mod_int, mod_int> solve(const vector <int> &v) {\n\tint mn = *min_element(All(v));\n\tmod_int pv = 1, ph = 1;\n\tvector <int> p;\n\tfor (int now: v)\n\t\tif (now == mn) {\n\t\t\tpv *= 2;\n\t\t\tif (p.empty()) continue;\n\t\t\tauto [nt, nh] = solve(p);\n\t\t\tp.clear();\n\t\t\tph *= nh, pv *= (nt + nh);\n\t\t}\n\t\telse\n\t\t\tp.push_back(now - mn);\n\tif (!p.empty()) {\n\t\tauto [nt, nh] = solve(p);\n\t\tph *= nh, pv *= (nt + nh);\n\t}\n\tmod_int k = 2 * ph;\n\tph *= mod_int(2).pow(mn);\n\treturn {pv + ph - k, ph};\n}\n\nint main(int argc, const char *argv[]) {\n\tios_base :: sync_with_stdio(false);\n\tcin.tie(nullptr); cout.tie(nullptr);\n\tcout << fixed << setprecision(12);\n\tvector <int> a(*istream_iterator<int>(cin));\n\tfor_each(All(a), readval <int>);\n\tcout << solve(a).fi << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/detail/standard_policies.hpp>\nusing ll = int64_t;\nusing ld = double;\nusing ull = uint64_t;\nusing namespace std;\nusing namespace __gnu_pbds;     \n\nconst int MAXN = 228;\n\nconst ll MOD = 1e9 + 7;\nconst ll REV2 = (MOD + 1) / 2;\n\nusing Vec = vector<ll>;\n\nll p2(ll a) {\n    if (!a) {\n        return 1;\n    }\n\n    ll v = p2(a / 2);\n    v = (v * v) % MOD;\n\n    if (a & 1) {\n        v = (v * 2) % MOD;\n    }\n\n    return v;\n}\n\n\nconst ll INF = (1ll << 60);\n\nll eval(const Vec& a) {\n    assert(a.size());\n\n    ll mn = INF;\n    for (ll x : a) {\n        mn = min(mn, x);\n    }\n\n    ll cn = p2(mn) - 1;\n    Vec na(a);\n    for (ll& x : na) {\n        x -= mn;\n    }\n\n    ll pv = 0;\n    ll p = 0;\n\n    na.push_back(0);\n\n    for (ll x : na) {\n        p += max(x - pv, 0ll);\n        pv = x;\n    }\n\n    ll ans = p2(p) * cn % MOD;\n    Vec cur;\n    \n    ll ansgood = REV2 * REV2 % MOD;\n\n    for (ll x : na) {\n        if (!x) {\n            ansgood = (ansgood * 2) % MOD;\n            if (!cur.empty()) {\n                ansgood = ansgood * eval(cur) * 2 % MOD;\n                cur.clear();\n            }\n        } else {\n            cur.push_back(x);\n        }\n    }\n    \n    return (ans + ansgood) % MOD;\n}\n\nint main() {\n#ifdef BZ\n    freopen(\"input.txt\", \"r\", stdin); freopen(\"output.txt\", \"w\", stdout);\n#endif\n    ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); cout.setf(ios::fixed); cout.precision(20);\n    int n;\n    cin >> n;\n    Vec a(n);\n    for (ll& x : a) {\n        cin >> x;\n        --x;\n    }\n\n    ll ans = eval(a);\n    cout << (ans * 2) % MOD << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nlong long n,h[105],dp[105],tmp,mod=1000*1000*1000+7,pre[105],l,r,omega,dest,prog;\ndeque<pair<long long,int> > v;\n\nlong long fastp(long long base,int exp){\n    if(exp==0)return 1;\n    \n    long long val=fastp(base,exp/2);\n    val=(val*val)%mod;\n    if(exp%2)val*=base;\n    return val%mod;\n}\n\n\nint main(){\n\n\tcin>>n;\n    for(int i=1;i<=n;i++)cin>>h[i];\n\n    dp[n+1]=1;\n    pre[0]=1;\n    for(int i=1;i<=n;i++){\n        pre[i]=pre[i-1]*fastp(2,max(0ll,h[i]-h[i-1]));\n        pre[i]%=mod;\n    }\n    \n    for(int i=n;i>0;i--){\n        tmp=2*dp[i+1];\n        \n        v.clear();\n        v.push_back({2,n+1});\n        for(int j=n;j>=i;j--){\n            while(v.size()>0 && v.back().first>=h[j]+1)v.pop_back();\n            v.push_back({h[j]+1,j});\n        }\n        \n        while(v.size()>1 && v[1].first<=h[i-1])v.pop_front();\n        \n        v[0].first=max(v[0].first,h[i-1]+1);\n        \n        for(int j=0;j<v.size()-1;j++){\n            l=v[j].first;\n            r=v[j+1].first-1;\n            if(l>r)continue;\n            dest=v[j].second;\n            omega=(pre[dest-1]*fastp(pre[i],mod-2))%mod;\n            prog=(fastp(2,h[i]-l)*(2-fastp(fastp(2,r-l),mod-2)))%mod;\n            prog+=mod;\n            prog%=mod;\n            tmp+=((2ll*omega*prog)%mod*dp[dest])%mod;\n            tmp%=mod;\n        }\n        \n        dp[i]=tmp%mod;\n    }\n    \n    cout<<(dp[1]%mod+mod)%mod<<endl;\n\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\n#define each(i,a) for (auto&& i : a)\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define eb emplace_back\n#define all(a) (a).begin(),(a).end()\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\n\nconst ll linf = 1e18;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n  each(x,vec) is >> x;\n  return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n  rep(i,vec.size()) {\n    if (i) os << \" \";\n    os << vec[i];\n  }\n  return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector< vector<T> >& vec) {\n  rep(i,vec.size()) {\n    if (i) os << endl;\n    os << vec[i];\n  }\n  return os;\n}\nconst ll mod = 1e9+7;\nll mul(ll a, ll b) {\n  return a * b % mod;\n}\nll mul(initializer_list<ll> t) {\n  ll res = 1;\n  each(v, t) res = mul(res, v);\n  return res;\n}\nll add(ll a, ll b) {\n  return (a + b) % mod;\n}\nll add(initializer_list<ll> t) {\n  ll res = 0;\n  each(v, t) res = add(res, v);\n  return res;\n}\nll sub(ll a, ll b) {\n  return (a - b + mod) % mod;\n}\nll sub(initializer_list<ll> t) {\n  auto it = t.begin();\n  ll res = *(it++);\n  while (it != t.end()) {\n    res = sub(res, *(it++));\n  }\n  return res;\n}\nll inv(ll n);\nll power(ll x, ll n) {\n  if (n < 0) return inv(power(x, -n));\n  ll res = 1;\n  for (ll i = 1; i <= n; i <<= 1) {\n    if (i & n) res = mul(res, x);\n    x = mul(x, x);\n  }\n  return res;\n}\nll inv(ll n) {\n  return power(n, mod-2);\n}\nll divi(ll a, ll b) {\n  return mul(a, inv(b));\n}\nll divi(initializer_list<ll> t) {\n  auto it = t.begin();\n  ll res = *(it++);\n  while (it != t.end()) {\n    res = divi(res, *(it++));\n  }\n  return res;\n}\nvector<ll> fact;\nvoid init_fact(ll n) {\n  fact.assign(n+1, 1);\n  FOR(i, 1, fact.size()) {\n    fact[i] = mul(fact[i-1], i);\n  }\n}\n\nll comb(ll n, ll r) {\n  if (r < 0) return 0;\n  if (r > n) return 0;\n  return divi(fact[n], mul(fact[r], fact[n-r]));\n}\n\nusing Row = vector<ll>;\nusing Matrix = vector<Row>;\nMatrix E(ll n) {\n  Matrix res(n, Row(n, 0));\n  rep(i, n) res[i][i] = 1;\n  return res;\n}\nMatrix mul(const Matrix& A, const Matrix& B) {\n  const ll n = A.size(), m = A[0].size(), l = B[0].size();\n  assert(m == B.size());\n  Matrix res(n, Row(l, 0));\n  rep(i, n) rep(j, m) rep(k, l) {\n    res[i][k] = add(res[i][k], mul(A[i][j], B[j][k]));\n  }\n  return res;\n}\nMatrix power(Matrix A, ll n) {\n  assert(A.size() == A[0].size());\n  Matrix res = E(A.size());\n  for (ll i = 1; i <= n; i <<= 1) {\n    if (i & n) res = mul(res, A);\n    A = mul(A, A);\n  }\n  return res;\n}\n\nll solve(const vector<ll>& h) {\n  const ll n = h.size();\n  if (n == 0) return 1;\n  vector<vector<bool>> m1(n, vector<bool>(n+1, false));\n  vector<vector<ll>> m2(n, vector<ll>(n+1));\n  function<ll(ll,ll)> f = [&](ll l, ll r) {\n    // cout << \"f(\" << l << \", \" << r << \")\" << endl;\n    // assert(0 <= l && l <= r && r < n);\n    if (l > r) return 0LL;\n    if (l == r) return 1LL;\n    if (m1[l][r]) return m2[l][r];\n    ll d = r-l;\n    vector<ll> fill(d, 0);\n    if (l > 0) {\n      chmax(fill[0], min(h[l-1], h[l]));\n      rep(i, 1, d) {\n        chmax(fill[i], min(fill[i-1], h[l+i]));\n      }\n    }\n    if (r < n) {\n      chmax(fill[d-1], min(h[r], h[r-1]));\n      rrep(i, d-1) {\n        chmax(fill[i], min(fill[i+1], h[l+i]));\n      }\n    }\n    vector<P> v;\n    ll x = 0;\n    rep(i, d) {\n      if (fill[i] == h[l+i]) {\n        v.eb(x, i);\n        x = i+1;\n      }\n    }\n    v.eb(x, d);\n    ll res = 1;\n    if (v.size() == 1 && v[0].first == 0 && v[0].second == d) {\n      ll dh = linf;\n      rep(i, d) chmin(dh, h[l+i] - fill[i]);\n      res = power(2, dh);\n      v.clear();\n      x = 0;\n      rep(i, d) {\n        if (fill[i] + dh == h[l+i]) {\n          // cout << i << \" \" << fill[i] << \" \" << dh << \" \" << h[l+i] << endl;\n          v.eb(x, i);\n          x = i+1;\n        }\n      }\n      v.eb(x, d);\n    }\n    each(p, v) {\n      res = mul(res, f(l+p.first, l+p.second));\n    }\n    // cout << \"f(\" << l << \", \" << r << \") = \" << res << endl;\n    m1[l][r] = true, m2[l][r] = res;\n    return res;\n  };\n  // cout << h << endl;\n  // cout << f(2, 4) << endl;\n  // return 0;\n  // return 0;\n  // rep(i, n) rep(j, i+1, n) {\n  //   f(i, j);\n  // }\n  // dp[今][前]\n  vector<vector<ll>> dp(n+1, vector<ll>(n+1, 0));\n  dp[0][0] = 1;\n  rep(i, n) rep(j, i+1) {\n    if (dp[i][j] == 0) continue;\n    if (i < n-1) {\n      ll c = j == 0 ? 2 : 1;\n      ll r = h[i] > h[i+1] ? i+1 : i;\n      ll nj = h[i] < h[i+1] ? i+1 : i+2;\n      // cout << i << \" \" << j << \" \" << c << \" \" << r << \" \" << nj << \" \" << f(j, r) << endl;\n      // cout << j << \" \" << r << \" \" << f(j, r) << endl;\n      dp[i+2][nj] = add(dp[i+2][nj], mul(dp[i][j], mul(c, f(j, r))));\n    }\n    dp[i+1][j] = add(dp[i+1][j], dp[i][j]);\n  }\n  ll ans = 0;\n  // cout << dp << endl;\n  rep(i, n+1) {\n    ans = add(ans, mul(dp[n][i], f(i, n)));\n  }\n  // cout << h << \" : \" << ans << endl;\n  return ans;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  ll n; cin >> n;\n  vector<ll> h(n); cin >> h;\n  ll coe = 1;\n  rep(i, n) {\n    if (h[i] == 1) {\n      h[i] = 0;\n      coe = mul(coe, 2);\n    }\n  }\n  rep(i, n) {\n    ll b = 0;\n    if (i > 0) chmax(b, h[i-1]);\n    if (i < n-1) chmax(b, h[i+1]);\n    if (h[i] > b) {\n      coe = mul(coe, power(2, h[i] - b));\n      h[i] = b;\n    }\n  }\n  ll ans = 1;\n  vector<ll> v;\n  rep(i, n) {\n    if (h[i] == 0) {\n      ans = mul(ans, solve(v));\n      v.clear();\n    }\n    else {\n      v.pb(h[i]);\n    }\n  }\n  ans = mul(ans, solve(v));\n  ans = mul(ans, coe);\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define index(xs, x) (int)(lower_bound(all(xs), x) - xs.begin())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\ninline void add(int &x, int v) { x += v; if (x >= MOD) x -= MOD; }\ninline int mul(int x, int y) { return (1LL*x*y)%MOD; }\nint modpow(int x, int k) {\n  int a = 1;\n  while (k) {\n    if (k&1) a = mul(a, x);\n    x = mul(x, x);\n    k>>=1;\n  }\n  return a;\n}\n\nint N;\nint A[100];\n\nint V;\nint dp1[100], dp2[100];\nint W[100], H[100];\nvector<int> G[100];\n\nint f(int l, int r, int base) {\n  int m = INF;\n  for (int i=l; i<=r; i++) m = min(m, A[i]);\n\n  int id = V++;\n  W[id] = r-l+1;\n  H[id] = m-base;\n  assert(H[id]>0);\n\n  int lp = -1;\n  for (int i=l; i<=r; i++) {\n    if (A[i] > m) {\n      if (lp == -1) lp = i;\n    }\n    else {\n      if (lp != -1) G[id].pb(f(lp, i-1, m)), lp = -1;\n    }\n  }\n  if (lp != -1) G[id].pb(f(lp, r, m));\n  return id;\n}\nvoid dfs(int x) {\n  int rest = W[x];\n  for (int t : G[x]) dfs(t), rest -= W[t];\n  // g = 2*Πdp1[t]\n  // dp1[x] = 2^(h-1) * g\n  // dp2[x] = (2^rest * Π(2*dp1[t]+dp2[t])) - g\n  int g = 2;\n  for (int t : G[x]) g = mul(g, dp1[t]);\n  dp1[x] = mul(modpow(2, H[x]-1), g);\n  dp2[x] = modpow(2, rest);\n  for (int t : G[x]) dp2[x] = mul(dp2[x], (mul(2, dp1[t])+dp2[t])%MOD);\n  add(dp2[x], MOD-g);\n  //cout<<\"w=\"<<W[x]<<\", h=\"<<H[x]<<\", dp1=\"<<dp1[x]<<\", dp2=\"<<dp2[x]<<\"\\n\";\n}\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N;\n  rep(i, N) cin >> A[i];\n  vector<int> xs;\n  rep(i, N) xs.pb(A[i]);\n  sort(all(xs)); uniq(xs);\n\n  int root = f(0, N-1, 0);\n  dfs(root);\n  cout << (dp1[root]+dp2[root])%MOD << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int mod = 1e9 + 7;\n\nint fast_pow(int x, int y, int z = mod) {\n  long long ret = 1;\n  for (; y; y >>= 1, x = (long long)x * x % z) {\n    if (y & 1)\n      ret = ret * x % z;\n  }\n  return ret;\n}\n\nint main(int argc, char *argv[]) {\n  std::ios_base::sync_with_stdio(false);\n  map<int, map<int, long long>> f;\n  set<int> se;\n  int n;\n  cin >> n;\n  vector<int> a(n, 0);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n    se.insert(a[i]);\n  }\n  for (auto x : se) {\n    if (x <= a[0]) {\n      f[0][x] = fast_pow(2, a[0] - x + 1);\n    }\n  }\n  f[0][0] = fast_pow(2, a[0]);\n  se.insert(0);\n  for (int i = 1; i < n; i++) {\n    for (auto x : se) {\n      if (x <= a[i]) {\n        if (x > a[i - 1]) {\n          f[i][x] = f[i - 1][a[i - 1]] * fast_pow(2, a[i] - x + 1) % mod;\n        } else {\n          if (a[i] > a[i - 1]) {\n            f[i][x] = (f[i - 1][x] + f[i - 1][a[i - 1]]) * fast_pow(2, a[i] - a[i - 1]) % mod;\n          } else {\n            f[i][x] = (f[i - 1][x] + f[i - 1][a[i]]) % mod;\n          }\n        }\n      }\n    }\n  }\n  cout << f[n - 1][0] << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define EB emplace_back\n\ntypedef long long ll;\ntypedef std::pair <int, int> pr;\ntypedef std::vector <int> vector;\nconst int mod = 1000000007, pmod = mod - 1;\n\ninline void add(int &x, const int y) {x += y - mod, x += x >> 31 & mod;}\ninline void sub(int &x, const int y) {x -= y, x += x >> 31 & mod;}\nll PowerMod(ll a, int n, ll c = 1) {for (n += n >> 31 & pmod; n; n >>= 1, a = a * a % mod) if (n & 1) c = c * a % mod; return c;}\n\npr solve(const vector &h) {\n\tint i, j = -1, n = h.size(), x, y = 0, P1 = 1, P2 = 1, C1, C2, W = n;\n\tvector S; x = *std::min_element(h.begin(), h.end());\n\tfor (i = 0; i <= n; ++i)\n\t\tif (i == n || h[i] == x) {\n\t\t\tif (j + 1 == i) ++j;\n\t\t\telse if (j + 2 == i) ++j, P1 = PowerMod(2, h[j] - x, P1), P2 = PowerMod(2, h[j] - x, P2), ++j;\n\t\t\telse {\n\t\t\t\tW -= i - j - 1, S.clear(), S.reserve(i - j - 1);\n\t\t\t\tfor (++y; ++j < i; S.EB(h[j] - x));\n\t\t\t\tstd::tie(C1, C2) = solve(S), P1 = (ll)P1 * (C1 + C2) % mod, P2 = (ll)P2 * C2 % mod;\n\t\t\t}\n\t\t}\n\tC2 = PowerMod(2, x, P2), C1 = PowerMod(2, W, P1), sub(C1, P2), sub(C1, P2);\n\treturn add(C1, C2), pr(C1, C2);\n}\n\nint main() {\n\tint i, n, x; vector h;\n\tscanf(\"%d\", &n), h.reserve(n);\n\tfor (i = 0; i < n; ++i) scanf(\"%d\", &x), h.EB(x);\n\tprintf(\"%d\\n\", solve(h).first);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <utility>\n#include <cstdio>\n#define MOD 1000000007\ntypedef long long ll;\ninline ll quick_pow(ll a, int n)\n{\n\tll res = 1;\n\twhile (n)\n\t{\n\t\tif (n & 1)\n\t\t\tres = res * a % MOD;\n\t\ta = a * a % MOD;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\nint arr[105];\nstd::pair<ll, ll> work(int l, int r, int d)\n{\n\tint pos = l;\n\tfor (int i = l; i <= r; i++)\n\t{\n\t\tif (arr[i] < arr[pos])\n\t\t\tpos = i;\n\t}\n\tll val = quick_pow(2, arr[pos] - d);\n\tif (l == r)\n\t\treturn {val, val};\n\tif (pos == l)\n\t{\n\t\tauto res = work(l + 1, r, arr[pos]);\n\t\treturn {(2 * res.first + (val - 1) * res.second) % MOD, val * res.second % MOD};\n\t}\n\tif (pos == r)\n\t{\n\t\tauto res = work(l, r - 1, arr[pos]);\n\t\treturn {(2 * res.first + (val - 1) * res.second) % MOD, val * res.second % MOD};\n\t}\n\tauto x = work(l, pos - 1, arr[pos]), y = work(pos + 1, r, arr[pos]);\n\treturn {4 * x.first % MOD * y.first % MOD + (val - 1) * x.second % MOD * y.second % MOD\n\t\t, val * x.second % MOD * y.second % MOD};\n}\nint main()\n{\n\t// freopen(\"AGC026-D.in\", \"r\", stdin);\n\tint n; \n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", arr + i);\n\t\tarr[i]--;\n\t}\n\tprintf(\"%lld\\n\", work(0, n - 1, 0).first * 2 % MOD);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MOD 1000000007\n#define TWO 500000004\n\nint n, x[105], par[105], ta, tc;\nset<int> m;\nset<int>::iterator it;\nlong long ya[105], yb[105], tb;\n\nint find(int a) {\n\treturn par[a] == a ? a : par[a] = find(par[a]);\n}\n\nlong long po(long long b, int p) {\n\tlong long re = 1;\n\twhile (p) {\n\t\tif (p & 1)\n\t\t\tre = re * b % MOD;\n\t\tb = b * b % MOD;\n\t\tp >>= 1;\n\t}\n\treturn re;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", x + i);\n\t\tm.insert(x[i]);\n\t}\n\tm.insert(1);\n\tit = m.end();\n\twhile (it != m.begin()) {\n\t\tit--;\n\t\tta = *it;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tif (par[i]) {\n\t\t\t\tif (par[i] == i) {\n\t\t\t\t\tyb[i] = yb[i] * po(2, x[i] - ta);\n\t\t\t\t\tx[i] = ta;\n\t\t\t\t\tif (par[i - 1]) {\n\t\t\t\t\t\ttc = find(i - 1);\n\t\t\t\t\t\ttb = yb[tc] * yb[i] % MOD * TWO % MOD;\n\t\t\t\t\t\tya[tc] = ((ya[tc] + yb[tc]) * (ya[i] + yb[i]) % MOD + MOD - tb) % MOD;\n\t\t\t\t\t\tyb[tc] = tb;\n\t\t\t\t\t\tpar[i] = tc;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (x[i] == ta) {\n\t\t\t\tif (par[i - 1]) {\n\t\t\t\t\ttc = find(i - 1);\n\t\t\t\t\tya[tc] = (ya[tc] * 2 + yb[tc]) % MOD;\n\t\t\t\t\tpar[i] = tc;\n\t\t\t\t} else {\n\t\t\t\t\tpar[i] = i;\n\t\t\t\t\tyb[i] = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t// printf(\"[%d]\\n\", ta);\n\t\t// for (int i = 1; i <= n; i++) if (par[i] == i) printf(\"%d  %lld %lld\\n\", i, ya[i], yb[i]);\n\t}\n\tprintf(\"%lld\\n\", (ya[1] + yb[1]) % MOD);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define times(n, i)      uptil(0, n, i)\n#define rtimes(n, i)     downto((n) - 1, 0, i)\n#define upto(f, t, i)    for(auto i##0_to = (t), i = decltype(t)(f); i <= i##0_to; i++)\n#define uptil(f, t, i)   for(auto i##0_to = (t), i = decltype(t)(f); i <  i##0_to; i++)\n#define downto(f, t, i)  for(auto i##0_to = decltype(f)(t), i = (f); i >= i##0_to; i--)\n#define downtil(f, t, i) for(auto i##0_to = decltype(f)(t), i = (f); i >  i##0_to; i--)\nusing LD = long double;\n#define double LD\n#define long long long\n#define LL long\n#define int long\ntemplate<class T> using vec = vector<T>;\nusing VB = vec<bool>;   using WB = vec<VB>;\nusing VC = vec<char>;   using WC = vec<VC>;\nusing VI = vec<int>;    using WI = vec<VI>;\nusing VD = vec<double>; using WD = vec<VD>;\nusing VS = vec<string>; using WS = vec<VS>;\nusing PI = pair<int, int>;  using VPI = vec<PI>; using WPI = vec<VPI>;\nusing MI = map<int, int>;   using VMI = vec<MI>;\n\n#if defined(EBUG) && !defined(ONLINE_JUDGE)\n    #define debug true\n    #define _GLIBCXX_DEBUG\n    #define _LIBCPP_DEBUG 2\n    #define _LIBCPP_DEBUG2 2\n    #define ln << endl\n    #define dd(x) cerr << #x << \" = \" << (x) << \", \"\n    #define ddd(x) cerr << #x << \" = \" << (x) ln\n#else\n    #define debug false\n    #define ln << '\\n'\n    #define dd(x) cerr\n    #define ddd(x) cerr\n#endif\n#define tb << '\\t'\n#define sp << ' '\n#define db dd\n#define dbg ddd\n\ntemplate<class T>          inline istream& operator>>(istream& s, vec<T>& v) { for(auto&& p : v) s >> p; return s; }\ntemplate<class T, class S> inline ostream& operator<<(ostream&, const pair<T, S>&);\ntemplate<class T>          inline ostream& operator<<(ostream&, const vec<T>&);\ntemplate<class T, class S> inline ostream& operator<<(ostream&, const map<T, S>&);\n#define DEFINE_ITER_OUTPUT(s, x, sep) { int i = 0; for(const auto& x##0_elem : x) { if(i++) s << sep; s << x##0_elem; } return s; }\ntemplate<class T, class S> inline ostream& operator<<(ostream& s, const pair<T, S>& p) { return s << \"(\" << p.first << \",\" << p.second << \")\"; }\ntemplate<class T>          inline ostream& operator<<(ostream& s, const vec<T>& v) DEFINE_ITER_OUTPUT(s, v, ' ')\ntemplate<class T, class S> inline ostream& operator<<(ostream& s, const map<T, S>& m) DEFINE_ITER_OUTPUT(s, m, ' ')\ntemplate<class T>          inline ostream& operator<<(ostream& s, const vec<vec<T>>& w) DEFINE_ITER_OUTPUT(s, w, '\\n')\ntemplate<class T, class S> inline ostream& operator<<(ostream& s, const vec<map<T, S>>& vm) DEFINE_ITER_OUTPUT(s, vm, '\\n')\n\nvoid solve();\n\nsigned main() {\n    if(!debug) {\n        cin.tie(0);\n        ios::sync_with_stdio(0);\n    }\n    cout << fixed << setprecision(20);\n    cerr << fixed << setprecision(20);\n\n    solve();\n\n    return 0;\n}\n\nconstexpr int mod = 1e9L + 7;\n\nLL pow_(LL x, signed LL n) {\n    LL ans = 1;\n    while(n) {\n        if(n & 1) ans = ans * x % mod;\n        x = x * x % mod;\n        n >>= 1;\n    }\n    return ans;\n}\n#define pow pow_\n\nvoid solve() {\n// N N(H)\n/* <foxy.memo-area> */\nint N;cin>>N;VI H(N);times(N,Ri_0){cin>>H[Ri_0];}\n/* </foxy.memo-area> */\n\n    if(N == 1) {\n        cout << pow(2, H[0]);\n        return;\n    }\n\n    VI th(N); int free = 0;\n\n    if(H[0] > H[1]) {\n        free += H[0] - H[1];\n        H[0] = H[1];\n    }\n    if(H[0] == 1) {\n        ++free;\n        H[0] = 0;\n    }\n\n    uptil(1, N, i) {\n        if(H[i] == 1 || (H[i-1] <= 1 && (i == N-1 || H[i+1] <= 1))) {\n            free += H[i];\n            H[i] = 0;\n        } else if(H[i-1] != 1) {\n            th[i] = min(H[i-1], H[i]);\n        }\n        if(H[i] > H[i-1]) {\n            if(i == N-1) {\n                free += H[i] - H[i-1];\n                H[i] = H[i-1];\n            } else {\n                if(H[i] > H[i+1]) {\n                    free += H[i] - max(H[i-1], H[i+1]);\n                    H[i] = max(H[i-1], H[i+1]);\n                }\n            }\n        }\n    }\n    if(debug) cerr << free ln << H ln << th ln ln;\n\n    map<int, int> thcp;\n    vec<int> thzp;\n    {\n        thzp = th;\n        thzp.push_back(0);\n        sort(thzp.begin(), thzp.end());\n        thzp.erase(unique(thzp.begin(), thzp.end()), thzp.end());\n\n        times(thzp.size(), i) thcp[thzp[i]] = i;\n    }\n    int zth = thzp.size();\n    if(debug) cerr << thcp ln ln;\n    \n    VI pyon(zth), qyon;\n    int ans = 1;\n    rtimes(N, i) {\n        qyon = pyon;\n        if(H[i] == 0) {\n            times(zth, t) pyon[t] = 0;\n        } else if(i == N-1 or H[i+1] == 0) {\n            times(zth, t) {\n                if(thzp[t] > th[i]) {\n                    pyon[t] = 0;\n                } else if(thzp[t] == th[i]) {\n                    pyon[t] = 2;\n                } else {\n                    pyon[t] = 1;\n                }\n            }\n        } else if(i == 0 or H[i-1] == 0) {\n            // leftmost\n            assert(th[i] == 0);\n\n            int a = qyon[thcp[ th[i+1] ]] % mod;\n            int g = 1;\n            downto(thcp[ th[i+1] ]-1, 0, s) {\n                int e = th[i+1] - thzp[s];\n                if(s == 0) e -= 1;\n                a += qyon[s] * (pow(2, e) - g) % mod;\n                a %= mod;\n                if(debug) {\n                    cerr << qyon[s] << \" * (2^\" << e << \" - \" << g << \") * 2;\" tb;\n                }\n                g = pow(2, e);\n            }\n\n            a *= 2;\n            a %= mod;\n            ans *= a;\n            ans %= mod;\n            if(debug) {\n                cerr ln << \"a: \" << a << \", ans: \" << ans ln;\n            }\n            times(zth, t) pyon[t] = 0;\n        } else if(th[i] > th[i+1]) {\n            assert(H[i] == th[i]);\n            times(zth, t) {\n                if(thzp[t] > th[i]) {\n                    pyon[t] = 0;\n                } else if(thzp[t] == th[i]) {\n                    pyon[t] = qyon[thcp[th[i+1]]] * 2 % mod;\n                } else {\n                    pyon[t] = qyon[ min(t, thcp[th[i+1]]) ];\n                }\n            }\n        } else if(th[i] == th[i+1]) {\n            times(zth, t) {\n                if(thzp[t] > th[i]) {\n                    pyon[t] = 0;\n                } else if(thzp[t] == th[i]) {\n                    pyon[t] = qyon[t] * 2 % mod;\n                } else {\n                    pyon[t] = qyon[t];\n                }\n            }\n        } else {\n            assert(H[i] == th[i+1]);\n            times(zth, t) {\n                if(thzp[t] > th[i]) {\n                    pyon[t] = 0;\n                } else if(thzp[t] == th[i]) {\n                    pyon[t] = qyon[thcp[ th[i+1] ]];\n                    int g = 1;\n                    downto(thcp[ th[i+1] ]-1, thcp[ th[i] ], s) {\n                        int e = th[i+1] - thzp[s];\n                        pyon[t] += qyon[s] * (pow(2, e) - g);\n                        pyon[t] %= mod;\n                        if(debug) {\n                            cerr << qyon[s] << \" * (2^\" << e << \" - \" << g << \") * 2;\" tb;\n                        }\n                        g = pow(2, e);\n                    }\n                    if(debug) cerr ln;\n                    pyon[t] *= 2;\n                    pyon[t] %= mod;\n                } else {\n                    pyon[t] = qyon[t] * pow(2, H[i] - th[i]) % mod;\n                }\n            }\n        }\n        if(debug) {\n            cerr << i << \": \" << H[i] sp << th[i] ln << pyon ln ln;\n        }\n    }\n    if(debug) cerr << ans ln;\n    ans *= pow(2, free);\n    ans %= mod;\n    if(ans < 0) ans += mod;\n    cout << ans ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\n#include <stdlib.h>\n#include <vector>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <string.h>\n#include <stack>\n#define Endl endl\n#define mp make_pair\n#define ll long long \n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define over(A) {cout<<A<<endl;exit(0);}\n#define all(A) A.begin(),A.end()\n#define ceil(a,b) ((a-1)/b+1)\n#define srand() mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n#define rand(l,r) uniform_int_distribution<int>(l,r)(rng)\ntypedef unsigned long long ull;\nconst int inf=1039074182;\nusing namespace std;\nint n;\nint h[105];\nint res=1;\nvector <pair<pair<int,int>,int> >vec;\nint dp[105][105][2];\n\nnamespace combinatorics\n{\n\tint mod=1e9+7;\n\tinline int add(int a,int b)\n\t{\n\t\treturn (a+b)%mod;\n\t}\n\tinline int minus(int a,int b)\n\t{\n\t\treturn (a-b+mod)%mod;\n\t}\n\tinline int mutiply(int a,int b)\n\t{\n\t\treturn (1LL*a*b)%mod;\n\t}\n\tinline int fastpow(int basic,int x)\n\t{\n\t\tint res=1;\n\t\twhile(x)\n\t\t{\n\t\t\tif(x&1)\tres=mutiply(res,basic);\n\t\t\tbasic=mutiply(basic,basic);\n\t\t\tx>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tinline int inv(int x)\n\t{\n\t\treturn fastpow(x,mod-2);\n\t}\n};\nusing namespace combinatorics;\n\ninline void solve(int l,int r)\n{\n\tif(l==r) return;\n\tint mi,ma;\n\tfor(int i=l;i<r;i++)\n\t{\n\t\tmi=min(mi,h[i]);\n\t}\n\tvec.push_back({{l,r},mi-(l==0 && r==n)});\n\tfor(int i=l;i<r;i++)\n\t{\n\t\th[i]-=mi;\n\t}\n\tint last=l;\n\tfor(int i=l;i<=r;i++)\n\t{\n\t\tif(h[i]==0) solve(last,i),last=i+1;\n\t}\n}\n\ninline int way(int l,int r)\n{\n\tint res=0;\n\tfor(auto x:vec)\n\t{\n\t\tif(l<=x.first.first && r>=x.first.second) res+=x.second;\n\t}\n\treturn fastpow(2,res);\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\",\"r\",stdin);\n\tcin>>n;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcin>>h[i];\n\t}\n\tsolve(0,n);\n//\tfor(auto x:vec)\n//\t{\n//\t\tprintf(\"From %d to %d, having %d floors.\\n\",x.first.first+1,x.first.second,x.second);\n//\t}\n\tdp[0][1][0]=1;\n\tdp[0][1][1]=1;\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tfor(int j=1;j<=i+1;j++)\n\t\t{\n\t\t\tfor(int k=0;k<2;k++)\n\t\t\t{\n\t\t\t\tdp[i+1][j+1][k]=add(dp[i+1][j+1][k],dp[i][j][k]);\n\t\t\t\tdp[i+1][1][!k]=add(dp[i+1][1][!k],mutiply(dp[i][j][k],way(i-j+1,i+1)));\n\t\t\t}\n\t\t}\n\t}\n\tint res=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tdp[n-1][i][0]=mutiply(dp[n-1][i][0],way(n-i,n));\n\t\tdp[n-1][i][1]=mutiply(dp[n-1][i][1],way(n-i,n));\n\t\tres=add(res,add(dp[n-1][i][0],dp[n-1][i][1]));\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<bitset>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; i++ )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef pair<ll,int> pli;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\nint dx[4]={1,0,-1,0} , dy[4]={0,1,0,-1} ;\n\nll dp[111][111][2];\nint a[111];\n\nll powmod(ll n,ll k){\n    ll ret=1;\n    while(k>0){\n        if(k&1)ret=ret*n%mod;\n        n=n*n%mod;\n        k>>=1;\n    }\n    return ret;\n}\n\nll rec(int l,int r,int h,int flag){\n    if(dp[l][r][flag]!=-1)return dp[l][r][flag];\n    int mi=inf,ma=0;\n    REP(i,l,r){\n        mi=min(mi,a[i]);\n        ma=max(ma,a[i]);\n    }\n    ll ret1,ret2;\n    ret1=ret2=1;\n    ll pos=l-1;\n    REP(i,l,r){\n        if(a[i]==mi){\n            ret2*=2;\n            if(i-pos>1){\n                ret1*=rec(pos+1,i,mi,1);\n                ret2*=(2*rec(pos+1,i,mi,1)+rec(pos+1,i,mi,0));\n            ret1%=mod;\n            ret2%=mod;\n            }\n            pos=i;\n        }\n    }\n    if(r-pos>1){\n        ret1=ret1*rec(pos+1,r,mi,1)%mod;\n        ret2=ret2*(2*rec(pos+1,r,mi,1)+rec(pos+1,r,mi,0))%mod;\n    }\n    ret2=(ret2-ret1*2+2*mod)%mod;\n    return dp[l][r][flag]=flag?ret1*powmod(2,mi-h)%mod:ret2;\n}\nint main(){\n   int n;\n   cin>>n;\n   rep(i,n)cin>>a[i];\n   rep(i,n+1)rep(j,n+1)rep(k,2)dp[i][j][k]=-1;\n   ll ans=rec(0,n,0,0)+rec(0,n,0,1);\n   cout<<ans%mod<<endl;\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define XX first\n#define YY second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define REP rep\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\nconst ll MOD=1e9+7;\n\n#define rall(X) (X).rbegin(),(X).rend()\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n\ntemplate<ll mod>\nstruct ModInt{\n  using M=ModInt;\n  ll a;\n  M& put(ll v){\n    a=(v<mod)?v:v-mod;\n    return *this;\n  }\n  ModInt(ll v=0){put(v%mod+mod);}\n  M operator+(M x){return M().put(a+x.a);}\n  M operator-(M x){return M().put(a+mod-x.a);}\n  M operator*(M x){return M().put(a*x.a%mod);}\n  M operator/(M x){return *this*x.inv();}\n  M& operator+=(M x){return *this=*this+x;};\n  M& operator-=(M x){return *this=*this-x;};\n  M& operator*=(M x){return *this=*this*x;};\n  M& operator/=(M x){return *this=*this/x;};\n  bool operator==(M x){return a==x.a;}\n\n  M pow(ll m){\n    M x=*this,res=1;\n    while(m){\n      if(m&1)res*=x;\n      x*=x;\n      m>>=1;\n    }\n    return res;\n  }\n  M inv(){return pow(mod-2);}\n};\n\nusing Int = ModInt<MOD>;\n\nint N;\nvector<LL> hs;\nInt fact = 1;\n\nstruct Val {\n  Int dp1;\n  Int dp2;\n};\n\nstruct Val Calc(vector<LL> &hs) {\n  if (hs.size() == 1) {\n    fact *= Int(2).pow(hs[0]);\n    return Val{1, 1};\n  }\n\n  LL mh = 1LL << 40;\n  for (LL h : hs) {\n    MN(mh, h);\n  }\n\n  struct Val ret = {1, 1};\n  vector<LL> vec;\n  if (mh == 1) {\n    for (LL h : hs) {\n      if (h == 1) {\n        if (vec.size()) {\n          auto res = Calc(vec);\n          ret.dp1 *= res.dp1;\n          ret.dp2 *= res.dp2;\n          if (vec.size() == 1) {\n            ret.dp2 *= 2;\n            fact /= 2;\n          }\n        }\n        vec.clear();\n        ret.dp2 *= 2;\n      } else {\n        vec.eb(h);\n      }\n    }\n\n    if (vec.size()) {\n      auto res = Calc(vec);\n      ret.dp1 *= res.dp1;\n      ret.dp2 *= res.dp2;\n      if (vec.size() == 1) {\n        ret.dp2 *= 2;\n        fact /= 2;\n      }\n    }\n    //cout << ret.dp1.a << \", \" << ret.dp2.a << endl;\n    return ret;\n  }\n  \n  int w = 0;\n  for (LL h : hs) {\n    h -= mh;\n    if (h > 0) {\n      vec.eb(h);\n    } else {\n      ++w;\n      assert(h == 0);\n      if (vec.size()) {\n        auto res = Calc(vec);\n        ret.dp1 *= res.dp1;\n        ret.dp2 *= res.dp2;\n        if (vec.size() == 1) ++w;\n      }\n      vec.clear();\n    }\n  }\n\n  if (vec.size()) {\n    auto res = Calc(vec);\n    ret.dp1 *= res.dp1;\n    ret.dp2 *= res.dp2;\n    if (vec.size() == 1) ++w;\n  }\n\n  if (w == hs.size()) {\n    return {Int(2).pow(mh-1), Int(2).pow(mh) + Int(2).pow(w) - 2};\n  }\n\n  //cout << ret.dp1.a << \", \" << ret.dp2.a << endl;\n  Int g = Int(2).pow(w);\n  ret.dp2 *= g;\n  Int t = Int(2).pow(mh);\n  ret.dp2 += ret.dp1 * (t*2+g*2-4);\n  ret.dp1 *= t;\n  //cout << ret.dp1.a << \", \" << ret.dp2.a << endl;\n  return ret;\n}\n\nsigned main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n  cin >> N;\n  rep(i, N) {\n    LL h;\n    cin >> h;\n    hs.eb(h);\n  }\n  cout << (fact*Calc(hs).dp2).a << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n\nconst int N = 1e6 + 10;\nconst int mod = 1e9 + 7;\nint h[N], st[N], top, n, ls[N], rs[N], root, f[N][2], num[N], single[N], mulsingle[N], rev[N];\nbool bsin[N];\n\ninline void build()\n{\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tint k = top;\n\t\twhile (k > 0 && h[st[k]] > h[i]) k--;\n\t\tif (k) rs[st[k]] = i;\n\t\tif (k < top) ls[i] = st[k + 1];\n\t\tst[++k] = i;\n\t\ttop = k;\n\t}\n\troot = st[1];\n}\n\nvoid dfs(int x)\n{\n\tif (!x) return;\n\tcout << \"x \" << x << endl;\n\tdfs(ls[x]), dfs(rs[x]);\n}\n\ninline int fp(int a, int n)\n{\n\tint res = 1;\n\twhile (n)\n\t{\n\t\tif (n & 1) res = (res * a) % mod;\n\t\ta = (a * a) % mod;\n\t\tn >>= 1;\n\t}\n\treturn res % mod;\n}\n\ninline void fill(int *a, int siz, int val)\n{\n\tfor (int i = 1; i <= siz; i++)\ta[i] = val;\n}\n\ninline void dp(int x, int fa)\n{\n\tif (!x) return;\n\tnum[x] = 1;\n\trev[x] = 1;\n\tint height = h[x] - h[fa];\n\t// if (!rs[x] && !ls[x] && h[x] != h[fa])\n\t// {\n\t// \tsingle[x] = 1;\n\t// \tmulsingle[x] *= fp(2, height);\n\t// \treturn;\n\t// }\n\tif (!rs[x] && !ls[x] && h[x] == h[fa])\n\t\treturn;\n\tdp(ls[x], x);\n\tdp(rs[x], x);\n\t// if (ls[x] && x - ls[x] == 1) rev[x] += single[ls[x]];\n\t// if (rs[x] && rs[x] - x == 1) rev[x] += single[rs[x]];\n\t// if (ls[x]) mulsingle[x] *= mulsingle[ls[x]];\n\t// if (rs[x]) mulsingle[x] *= mulsingle[rs[x]]; \n\tif (ls[x] && h[ls[x]] == h[x]) rev[x] += rev[ls[x]];\n\tif (rs[x] && h[rs[x]] == h[x]) rev[x] += rev[rs[x]];\n\tif (f[ls[x]][1] == 0) ls[x] = 0;\n\tif (f[rs[x]][1] == 0) rs[x] = 0;\n\n\tif (height > 0)\n\t{\n\t\tif (rs[x] && ls[x])\n\t\t{\n\t\t\tf[x][1] = f[rs[x]][1] * f[ls[x]][1] % mod  * fp(2, height) % mod;\n\t\t\t// cout << \"fk1 \" << f[rs[x]][1] << ' ' << f[ls[x]][1] << endl;\n\t\t\t// cout << \"fk0 \" << f[rs[x]][0] << ' ' << f[ls[x]][0] << endl;\n\t\t\tf[x][0] = (((f[rs[x]][1] * f[ls[x]][0] % mod * 2 * (fp(2, rev[x])) % mod + f[rs[x]][0] * f[ls[x]][1] % mod * 2 * (fp(2, rev[x])) % mod) % mod + f[rs[x]][0] * f[ls[x]][0] % mod * fp(2, rev[x]) % mod) % mod + f[rs[x]][1] * f[ls[x]][1] % mod * (2 * 2 * (fp(2, rev[x])) - 2) % mod) % mod;\n\t\t}\n\t\telse if (rs[x])\n\t\t{\n\t\t\tf[x][1] = f[rs[x]][1] * fp(2, height) % mod;\n\t\t\tf[x][0] = (f[rs[x]][0] * fp(2, rev[x]) % mod + f[rs[x]][1] * (2 * fp(2, rev[x]) - 2) % mod) % mod;\n\t\t}\n\t\telse if (ls[x])\n\t\t{\n\t\t\tf[x][1] = f[ls[x]][1] * fp(2, height) % mod;\n\t\t\tf[x][0] = (f[ls[x]][0] * fp(2, rev[x]) % mod + f[ls[x]][1] * (2 * fp(2, rev[x]) - 2) % mod) % mod;\n\t\t}\n\t\telse \n\t\t{\n\t\t\tf[x][1] = fp(2, height);\n\t\t\tf[x][0] = (fp(2, rev[x]) - 2) % mod;\n\t\t}\n\t}\t\n\telse \n\t{\n\t\tif (rs[x] && ls[x])\n\t\t{\n\t\t\tf[x][1] = f[rs[x]][1] * f[ls[x]][1] % mod;\n\t\t\tf[x][0] = ((f[rs[x]][0] * f[ls[x]][0] % mod + f[rs[x]][1] * f[ls[x]][0] % mod) % mod + f[rs[x]][0] * f[ls[x]][1] % mod) % mod;\n\t\t}\n\t\telse if (rs[x])\n\t\t{\n\t\t\tf[x][1] = f[rs[x]][1];\n\t\t\tf[x][0] = f[rs[x]][0];\n\t\t}\n\t\telse if (ls[x])\n\t\t{\n\t\t\tf[x][1] = f[ls[x]][1];\n\t\t\tf[x][0] = f[ls[x]][0];\n\t\t}\n\t}\n\t// cout << \"x \" << x << endl;\n\t// cout << \"f[x][1] \" << f[x][1] << endl;\n\t// cout << \"f[x][0] \" << f[x][0] << endl;\n\t// cout << \"rev[x] \" << rev[x] << endl;\n}\n\nsigned main()\n{\n\tint ml = 0;\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++)\tcin >> h[i];\n\tfor (int i = 1; i <= n; i++)\n\t\tif (h[i] > h[i - 1] && h[i] > h[i + 1]) ml += h[i] - max(h[i - 1], h[i + 1]), h[i] = max(h[i - 1], h[i + 1]);\n\tbuild();\n\tfill(mulsingle, n, 1);\n\tf[0][1] = f[0][0] = 1;\n\tdp(root, 0);\n\t// cout << \"mul \" << mulsingle[root] << endl;\n\tcout << (f[root][1] + f[root][0]) % mod * fp(2, ml) % mod << endl;\n\t// cout << \"1 \" << f[root][1] << endl;\n\t// cout << \"0 \" << f[root][0] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <math.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int MAXN = 100 + 10;\nconst int Mod = 1e9 + 7;\nint N;\nint A[MAXN];\nint f[MAXN];\n\ninline int fastpow_mod(int a, ll b) {\n\tint x = 1;\n\twhile(b) {\n\t\tif(b & 1) x = 1ll * x * a % Mod;\n\t\ta = 1ll * a * a % Mod; b >>= 1;\n\t}\n\treturn x;\n}\n\nint main() {\n\tregister int i, j, k;\n\tscanf(\"%d\", &N);\n\tfor(i = 1; i <= N; ++i)\n\t\tscanf(\"%d\", A + i);\n\tf[0] = 1;\n\tA[N + 1] = 1;\n\tfor(i = 1; i <= N + 1; ++i) {\n\t\tf[i] = f[i - 1] * 2 % Mod;\n\t\tfor(j = 1; j < i; ++j) {\n\t\t\tint l = max(A[i], A[j - 1]), r = A[j] - 1;\n\t\t\tll s = 0;\n\t\t\tfor(k = j; k < i; ++k)\n\t\t\t\tr = min(r, A[k] - 1), s += max(A[k + 1] - A[k], 0);\n\t\t\tif(l <= r) {\n\t\t\t\tint t1 = fastpow_mod(2, A[j] - r - 1);\n\t\t\t\tint t2 = fastpow_mod(2, r - l + 1) - 1;\n\t\t\t\tint t3 = fastpow_mod(2, s);\n\t\t\t\tf[i] = (f[i] + 4ll * f[j - 1] * t1 % Mod * t2 % Mod * t3 % Mod) % Mod;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", 1ll * f[N + 1] * (Mod + 1) / 2 % Mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"algorithm\"\n#include \"cstring\"\n#include \"cstdio\"\n#include \"vector\"\nusing namespace std;\n#define MAXN 106\n#define P 1000000007\nint n;\nint A[MAXN];\nint Pow( int x , int a ) {\n    int cur = x % P , ans = 1;\n    while( a ) {\n        if( a & 1 ) ans = 1ll * ans * cur % P;\n        cur = 1ll * cur * cur % P , a >>= 1;\n    }\n    return ans;\n}\npair<int,int> solve( int l , int r , int c ) {\n//    cout << l << ' ' << r << endl;\n    if( l > r ) return make_pair( 1 , 0 );\n    int h = 0x3f3f3f3f;\n    for( int i = l ; i <= r ; ++ i ) h = min( h , A[i] );\n    vector<int> pos;\n    pos.push_back( l - 1 );\n    for( int i = l ; i <= r ; ++ i ) if( A[i] == h ) pos.push_back( i );\n    pos.push_back( r + 1 );\n    int nm = pos.size() - 2;\n    int re = 1 , tot = 1;\n    for( int i = 0 ; i < pos.size() - 1 ; ++ i ) {\n        pair<int,int> ret = solve( pos[i] + 1, pos[i + 1] - 1, h );\n        re = 1ll * re * ret.first % P , tot = 1ll * tot * ( ret.first + ret.second ) % P;\n//        cout << l << ' ' << r << ' ' << pos[i] + 1 << ' ' << pos[i + 1] << ' ' << re << ' ' << tot << endl;\n    }\n    return make_pair( 1ll * re * Pow( 2 , h - c ) % P , ( 1ll * re * ( Pow( 2 , h - c ) - 2 ) % P + 1ll * Pow( 2 , nm ) * tot % P ) % P );\n}\nint main() {\n    cin >> n;\n    for( int i = 1 ; i <= n ; ++ i ) scanf(\"%d\",&A[i]);\n    cout << solve( 1 , n , 0 ).second << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<iostream>\n#define fi first\n#define se second\n#define pi pair<LL,LL>\n#define LL long long\nusing namespace std;\nconst LL inf=2e9;\nconst LL mod=1e9+7;\nLL n,h[110];\nLL pow(LL a,LL b)\n{\n\tLL ans=1;\n\twhile(b)\n\t{\n\t\tif(b&1) ans=ans*a%mod;\n\t\ta=a*a%mod;b>>=1;\n\t}\n\treturn ans;\n}\npi solve(LL l,LL r,LL k)//l r区间大于k的部分\n{\n\tLL Min=inf,cnt=0;pi ans;\n\tfor(LL i=l;i<=r;i++)\n\t{\n\t\tif(h[i]<Min) Min=h[i],cnt=1;\n\t\telse if(h[i]==Min) cnt++;\n\t}\n\tif(cnt==(r-l+1))\n\t{\n\t\tans.fi=(pow(2,r-l+1)+mod-2)%mod;\n\t\tans.se=pow(2,Min-k-1);\n\t\t//printf(\"1:%lld %lld %lld %lld\\n\",l,r,ans.fi,ans.se);\n\t\treturn ans;\n\t}\n\tLL re=r-l+1,s0=1,s1=1,last=0;\n\tfor(LL i=l;i<=r+1;i++) if(!last&&h[i]>Min) last=i;\n\telse if(last&&(h[i]<=Min||i>r))\n\t{\n\t\tre-=i-last;\n\t\tpi tmp=solve(last,i-1,Min);\n\t\ts0=s0*(tmp.fi+4*tmp.se%mod)%mod;\n\t\ts1=s1*(2*s1*tmp.se%mod)%mod;\n\t\tlast=0;\n\t}\n\ts0=(s0+mod-s1);\n\tans.fi=s0*pow(2,re)%mod;\n\t(ans.fi+=(s1*(pow(2,re)-2+mod)%mod)%mod)%=mod;\n\tans.se=s1*pow(2,Min-k-1)%mod;\n\t//printf(\"2:%lld %lld %lld %lld\\n\",l,r,ans.fi,ans.se);\n\treturn ans;\n} \nint main()\n{\n\tscanf(\"%lld\",&n);\n\tfor(LL i=1;i<=n;i++) scanf(\"%lld\",&h[i]);\n\tif(n==1)\n\t{\n\t\tprintf(\"%lld\",pow(2,h[1]));\n\t\treturn 0;\n\t}\n\tLL tot=1;\n\tfor(LL i=1;i<=n;i++) if(h[i]>h[i-1]&&h[i]>h[i+1])\n\t{\n\t\t(tot*=pow(2,h[i]-max(h[i-1],h[i+1])))%=mod;\n\t\th[i]=max(h[i-1],h[i+1]);\n\t}\n\tpi ans=solve(1,n,0);\n\tprintf(\"%lld\",tot*((ans.fi+ans.se*2)%mod)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst LL N=101;\nconst LL p=1e9+7;\nconst LL inf=0x3f3f3f3f;\nLL n,h[N];\ninline LL pw(LL x,LL y){\n\tLL ans=1;\n\twhile(y){\n\t\tif(y&1)ans=ans*x%p;\n\t\tx=x*x%p; y>>=1;\n\t}\n\treturn ans;\n}\n#define pii pair<LL,LL>\n#define mp(x,y) make_pair((x),(y))\n#define fi first\n#define se second\ninline pii solve(LL l,LL r,LL H){\n\tLL mn=inf;\n\tfor(LL i=l; i<=r; ++i)mn=min(mn,h[i]-H);\n\tbool flag=0; for(LL i=l; i<=r; ++i)if(h[i]>mn+H)flag=1;\n\tif(!flag)return mp(pw(2,mn-1),(pw(2,r-l+1)-2+p)%p);\n\tLL ans0=1,ans1=1,x=r-l+1,y=0;\n\tfor(LL i=l,pre=0; i<=r; ++i){\n\t\tif(!pre&&h[i]>mn+H)pre=i;\n\t\tif(pre&&h[i]==mn+H){\n\t\t\tpii P=solve(pre,i-1,mn+H);\n\t\t\tans0=2*ans0%p*P.fi%p; ans1=ans1*(P.se+4*P.fi%p)%p;\n\t\t\t++y; x-=i-pre; pre=0;\n\t\t}else if(pre&&i==r){\n\t\t\tpii P=solve(pre,r,mn+H);\n\t\t\tans0=2*ans0%p*P.fi%p; ans1=ans1*(P.se+4*P.fi%p)%p;\n\t\t\t++y; x-=r-pre+1; pre=0;\n\t\t}\n\t}\n\tans1=(ans1-ans0+p)%p;\n\tans1=ans1*pw(2,x)%p;\n\tans1=(ans1+(pw(2,x)%p-2+p)%p*ans0%p)%p;\n\tans0=ans0*pw(2,mn-1)%p;\n\treturn mp(ans0,ans1);\n}\nint main(){\n\tscanf(\"%lld\",&n);\n\tfor(LL i=1; i<=n; ++i)scanf(\"%lld\",&h[i]);\n\tpii ans=solve(1,n,0);\n\tprintf(\"%lld\",(2*ans.fi+ans.se)%p);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <utility>\n#include <cstdio>\n#define MOD 1000000007\ntypedef long long ll;\ninline ll quick_pow(ll a, int n)\n{\n\tll res = 1;\n\twhile (n)\n\t{\n\t\tif (n & 1)\n\t\t\tres = res * a % MOD;\n\t\ta = a * a % MOD;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\nint arr[105];\nstd::pair<ll, ll> work(int l, int r, int d)\n{\n\tint pos = l;\n\tfor (int i = l; i <= r; i++)\n\t{\n\t\tif (arr[i] < arr[pos])\n\t\t\tpos = i;\n\t}\n\tll val = quick_pow(2, arr[pos] - d);\n\tif (l == r)\n\t\treturn {val, val};\n\tif (pos == l)\n\t{\n\t\tauto res = work(l + 1, r, arr[pos]);\n\t\treturn {(2 * res.first + (val - 1) * res.second) % MOD, val * res.second % MOD};\n\t}\n\tif (pos == r)\n\t{\n\t\tauto res = work(l, r - 1, arr[pos]);\n\t\treturn {(2 * res.first + (val - 1) * res.second) % MOD, val * res.second % MOD};\n\t}\n\tauto x = work(l, pos - 1, arr[pos]), y = work(pos + 1, r, arr[pos]);\n\treturn {4 * x.first % MOD * y.first % MOD + (val - 1) * x.second % MOD * y.second % MOD\n\t\t, val * x.second % MOD * y.second % MOD};\n}\nint main()\n{\n\t// freopen(\"AGC026-D.in\", \"r\", stdin);\n\tint n; \n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", arr + i);\n\t\tarr[i]--;\n\t}\n\tprintf(\"%lld\\n\", work(0, n - 1, 0).first * 2 % MOD);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n\nusing namespace std;\n\nconst int maxn = 110;\nconst int base = 1e9+7;\n\nint n,a[maxn];\nll f[maxn][maxn];\nmap<int,int> cnt;\nvector<int> h;\n\nll pw(int a,int n) {\n    if (n==0) return 1ll;\n    if (n==1) return a;\n    ll tmp = pw(a,n/2);\n    tmp = (tmp*tmp)%base;\n    if (n%2==0) return tmp;\n    return (tmp*a)%base;\n}\n\nint main() {\n   // freopen(\"in.txt\",\"r\",stdin);\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin>>n;\n    for (int i=1;i<=n;i++) {\n        cin>>a[i];\n        if (cnt[a[i]]!=0) continue;\n        h.push_back(a[i]);\n        cnt[a[i]]=1;\n    }\n    cnt.clear();\n    h.push_back(0);\n    sort(h.begin(),h.end());\n    h.erase(unique(h.begin(),h.end()),h.end());\n    for (int j=0;j<h.size();j++) cnt[h[j]]=j;\n\n    for (int j=0;j<h.size();j++)\n        if (h[j] == 0) f[1][j] = pw(2,a[1]);\n        else if (h[j] < a[1]) f[1][j] = pw(2,a[1] - h[j]+1);\n    for (int i=2;i<=n;i++) {\n        if (a[i] < a[i-1]) {\n            int mi = cnt[a[i]];\n            for (int j=0;j<h.size();j++)\n                if (h[j] <= a[i])\n                    f[i][j] = (f[i-1][j] + f[i-1][mi])%base;\n        } else {\n            int mi = cnt[a[i-1]];\n            for (int j=0;j<h.size();j++) {\n                if (h[j] <= a[i-1]) f[i][j] = ((f[i-1][j] + f[i-1][mi])%base * pw(2,a[i] - a[i-1])) % base;\n                else if (h[j] <= a[i]) f[i][j] = (pw(2,a[i] - h[j]+1) * f[i-1][mi]) % base;\n            }\n        }\n    }\n    cout<<f[n][0]<<endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int N = 105, mod = 1000000007;\ntypedef long long LL;\n\nint pow(int x, int y, int ans = 1) {\n\tfor (; y; y >>= 1, x = (LL) x * x % mod)\n\t\tif (y & 1) ans = (LL) ans * x % mod;\n\treturn ans;\n}\n\nint n, p, h[N];\n\nstd::pair<int, int> solve(int l, int r, int base) {\n\tint x = h[l], w = 0;\n\tfor (int i = l; i <= r; ++i)\n\t\tx = std::min(x, h[i]);\n\tfor (int i = l; i <= r; ++i)\n\t\tif (h[i] == x) ++w;\n\tint prod0 = 1, prod1 = 1, lst = l - 1;\n\tfor (int i = l; i <= r + 1; ++i)\n\t\tif (i > r || h[i] == x) {\n\t\t\tif (i - 1 > lst)  {\n\t\t\t\tauto t = solve(lst + 1, i - 1, x);\n\t\t\t\tprod0 = (LL) prod0 * (t.first + t.second) % mod;\n\t\t\t\tprod1 = (LL) prod1 * t.second % mod;\n\t\t\t}\n\t\t\tlst = i;\n\t\t}\n\tint t = pow(2, x - base);\n\tprod0 = (pow(2, w, prod0) + (LL) (t + mod - 2) * prod1) % mod;\n\tprod1 = (LL) t * prod1 % mod;\n\treturn {prod0, prod1};\n}\nint main() {\n\tstd::ios::sync_with_stdio(0), std::cin.tie(0);\n\tstd::cin >> n;\n\tfor (int i = 1; i <= n; ++i) std::cin >> h[i];\n\tstd::cout << solve(1, n, 0).first << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define to edge[i].v\n#define mp make_pair\n#define rint register int\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define fgx cerr<<\"-------------\"<<endl\n#define N 1000\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int mod=1e9+7;\nint a[N],b[N],h[N],f[N][N];\ninline int qpow(int y,int x=2){int A=1;for(;y;y>>=1,x=(ll)x*x%mod)if(y&1)A=(ll)A*x%mod;return A;}\nint main()\n{\tint n,ans=0; cin>>n;\n\tfor(rint i=1;i<=n;i++) scanf(\"%d\",&h[i]),b[i]=h[i];\n\tsort(b+1,b+n+1); int l=unique(b+1,b+n+1)-b-1;\n\tfor(rint i=1;i<=n;i++) a[i]=lower_bound(b+1,b+l+1,h[i])-b;\n\tf[0][0]=1;\n\tfor(rint i=1;i<=n;i++)\n\t{\tf[i][0]=f[i-1][0]*2%mod; \n\t\tfor(rint j=a[i]+1;j<=a[i-1];j++) (f[i][0]+=2*f[i-1][j]%mod)%=mod;\n\t\tfor(rint j=1;j<=a[i];j++)\n\t\t{\tf[i][j]=(ll)f[i-1][j]*qpow(max(0,b[a[i]]-b[a[i-1]]))%mod;\n\t\t\tif(j>a[i-1])\n\t\t\t(f[i][j]+=((j!=1)+1LL)*f[i-1][0]%mod*qpow(b[a[i]]-b[j])%mod*(qpow(b[j]-b[j-1])-1-(j==1))%mod)%=mod;\n\t\t}\n\t}\n\tfor(rint i=0;i<=a[n];i++) (ans+=f[n][i])%=mod;\n\tcout<<ans;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <fstream>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <complex>\n#include <iomanip>\n#include <stdio.h>\n#include <string.h>\n#include <random>\n#include <functional>\n\nusing std::cin;\nusing std::cout;\nusing std::cerr;\nusing std::endl;\n\nusing std::map;\nusing std::set;\nusing std::bitset;\nusing std::vector;\nusing std::string;\nusing std::multimap;\nusing std::multiset;\nusing std::deque;\nusing std::queue;\nusing std::stack;\nusing std::pair;\nusing std::iterator;\n\nusing std::sort;\nusing std::stable_sort;\nusing std::reverse;\nusing std::max_element;\nusing std::min_element;\nusing std::unique;\nusing std::ios_base;\nusing std::swap;\nusing std::fill;\n\nusing std::setprecision;\nusing std::fixed;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<long long> vl;\ntypedef string S;\n\nll min(ll a, ll b) {return a < b ? a : b;}\nll min(int a, ll b) {return a < b ? a : b;}\nll min(ll a, int b) {return a < b ? a : b;}\nll min(int a, int b) {return a < b ? a : b;}\n\nll max(ll a, ll b) {return a > b ? a : b;}\nll max(int a, ll b) {return a > b ? a : b;}\nll max(ll a, int b) {return a > b ? a : b;}\nll max(int a, int b) {return a > b ? a : b;}\n\nnamespace MySpace{\n\n};\n\n#define F(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define fi first\n#define se second\n#define re return\n#define all(x) (x).begin(), (x).end()\n#define int long long\n\nconst int N = 111;\nconst int MOD = 1e9 + 7;\n\nint n;\nint h[500];\nint dp[N];\nint kek[N][N];\n\nlong long inq(long long x, long long y)\n{\n    if (y == 0) return 1;\n    long long l = inq(x, y / 2);\n    if (y % 2) return l * l % MOD * x % MOD;\n    return l * l % MOD;\n}\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n;\n    h[0] = 1, h[n + 1] = 1;\n    for (int i = 1; i <= n; i++) cin >> h[i];\n    for (int l = 1; l <= n; l++)\n    {\n    \tfor (int r = l; r <= n; r++)\n    \t{\n    \t\tint limit = min(h[r], h[r + 1]);\n    \t\tfor (int i = r; i >= l; i--)\n            {\n                int a = max(h[i - 1], limit);\n                int b = h[i];\n                if (b >= a)\n                {\n                    kek[l][r] += b - a;\n                }\n                limit = min(limit, h[i]);\n            }\n    \t}\n    }\n    //for (int l = 1; l <= n; cout << \"\\n\", l++) for (int r = 1; r <= n; r++) cout << kek[l][r] << \" \";\n    dp[0] = 1;\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n        {\n            dp[i] = (dp[i] + dp[j] * inq(2, kek[j + 1][i])) % MOD;\n        }\n    }\n    cout << 2 * dp[n] % MOD;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#define Starseven main\n#define ll long long\nnamespace lyt {\n\tvoid read(int &x){\n\tchar ch=getchar();int re=0,op=1;\n\twhile(ch<'0'||ch>'9'){if(ch=='-') op=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){re=(re<<3)+(re<<1)+ch-'0';ch=getchar();}\n\tx = re * op;\n\treturn ;\n\t}\n\tvoid read(long long &x){\n\tchar ch=getchar();long long re=0,op=1;\n\twhile(ch<'0'||ch>'9'){if(ch=='-') op=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){re=(re<<3ll)+(re<<1ll)+ch-'0';ch=getchar();}\n\tx = re * op;\n\treturn ;\n\t}\n\tvoid write(int x){\n\t\tif(x<0){putchar('-');x=-x;}\n\t\tif(x>9) write(x/10);\n\t\tputchar(x%10+'0');\n\t\treturn ;\n\t}//¼ÇµÃ×Ô¼º¼Ó¿Õ¸ñºÍ»»ÐÐ \n\tvoid write(long long x){\n\t\tif(x<0){putchar('-');x=-x;}\n\t\tif(x>9) write(x/10);\n\t\tputchar(x%10+'0');\n\t\treturn ;\n\t}//¼ÇµÃ×Ô¼º¼Ó¿Õ¸ñºÍ»»ÐÐ\n\tint max(int x,int y){return x<y?y:x;}\n\tint min(int x,int y){return x<y?x:y;}\n\tint abs(int x){return x<0?-x:x;}\n\tlong long max(long long x,long long y){return x<y?y:x;}\n\tlong long min(long long x,long long y){return x<y?x:y;}\n\tlong long abs(long long x){return x<0?-x:x;}\n\tdouble max(double x,double y){return x<y?y:x;}\n\tdouble min(double x,double y){return x<y?x:y;}\n\tdouble abs(double x){return x<0?-x:x;}\n\tvoid swap(int &a,int &b) {a ^= b ^= a ^= b;}\n\tvoid swap(long long &a,long long &b) {a ^= b ^= a ^= b;}\n\tll Power(ll a, ll b, ll p) {\n\t\tll re = 1;\n\t\twhile(b) {\n\t\t\tif(b & 1ll) re = (re * a) % p;\n\t\t\tb >>= 1ll;\n\t\t\ta = (a * a) % p; \n\t\t}\n\t\treturn re;\n\t}\n\tint Power(int a, int b, int p) {\n\t\tint re = 1;\n\t\twhile(b) {\n\t\t\tif(b & 1) re = 1ll * re * a % p;\n\t\t\tb >>= 1;\n\t\t\ta = 1ll * a * a % p; \n\t\t}\n\t\treturn re;\n\t}\n}using namespace lyt;\nconst int mod = 1e9 + 7;\nconst int N = 1e2 + 20;\nint va[N], minn[N][N];\n\nstruct xyx {\n\tint res1, res2;\n};\n\nxyx Dfs(int l, int r, int pre_dep) {\n\tint judge = minn[l][r], num = 0;\n\txyx re;\n\tstd::vector<int> v;\n\tv.push_back(l - 1);\n\tfor (int i = l; i <= r; i++) {\n\t\tif(va[i] == judge) {\n\t\t\tv.push_back(i);\n\t\t\tnum++;\n\t\t}\n\t}\n\tv.push_back(r + 1);\n\tre.res1 = re.res2 = 1;\n\tfor (int i = 0; i < num + 1; i++) {\n\t\tif(v[i] + 1 >= v[i + 1]) continue;\n\t\txyx hack = Dfs(v[i] + 1, v[i + 1] - 1, judge);\n\t\tre.res1 = 1ll * re.res1 * hack.res1 % mod;\n\t\tre.res2 = 1ll * re.res2 * (hack.res2 + 1ll * hack.res1 * 2 % mod) % mod;\n\t}\n\txyx ans;\n\tans.res1 = 1ll * Power(2, judge - pre_dep, mod) * re.res1 % mod;\n\tans.res2 = (1ll * Power(2, num, mod) * re.res2 % mod + (mod - 2ll * re.res1) % mod) % mod;\n\treturn ans;\n}\n\nint Starseven(void) {\n\tint n;\n\tread(n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tread(va[i]);\n\t}\n\tif(n == 1) {\n\t\tint ans = Power(2, va[1], mod);\n\t\twrite(ans);\n\t\tputs(\"\");\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tminn[i][i] = va[i];\n\t\tfor (int j = i + 1; j <= n; j++) {\n\t\t\tminn[i][j] = min(minn[i][j - 1], va[j]);\n\t\t}\n\t}\n\txyx ans = Dfs(1, n, 0);\n\tans.res1 = 1ll * (ans.res1 + ans.res2) % mod;\n\twrite(ans.res1);\n\tputs(\"\");\n\treturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <vector>\n#include <cassert>\n#include <fstream>\n#include <algorithm>\n#include <list>\n#include <random>\n#include <ctime>\n#include <cmath>\n#include <random>\n#include <bitset>\n#include <complex>\n#pragma unroll\n#pragma loop count N\n#pragma ivdep\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n//#define int ll\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef pair<ld, ld> pld;\ntypedef complex<double> base;\n\n#define mmin(a, b) a = min(a, (b))\n#define mmax(a, b) a = max(a, (b))\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define ALL(a) a.begin(),a.end()\n#define sqr(x) (x) * (x)\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define cint const int &\n#define SZ(a) ((int)(a.size()))\n#define f(cnt) (((cnt) + 1) * (cnt) / 2)\n#define watch(x) cout << (#x) << \" = \" << x << endl;\n\nconst double PI = 2 * acos(0.0);\n\ntemplate<class T>\nvoid show(const set<T> &a) {\n    for (T x : a)\n        cout << x << \" \";\n    cout << endl;\n}\n\ntemplate<class T>\nvoid show(const vector<T> &a) {\n    for (T x : a)\n        cout << x << \" \";\n    cout << endl;\n}\n\nconst ll M = 1e9 + 7;\n\nll MOD(ll a) {\n    if (a >= 0) return a >= M ? a % M : a;\n    if (a <= -M) a %= M;\n    return a ? a + M : a;\n}\n\nconst int N = 109;\nconst int L = 1e6 + 7;\n\nstruct edge {\n    int u, v;\n    ll height;\n    edge(int u, int v, ll height): u(u), v(v), height(height) {\n\n    }\n\n};\nvector<edge> e;\n\nll pw(ll a, ll p) {\n    if (p < 0LL) return pw(pw(a, -p), M - 2);\n    if (!p) return 1;\n    ll ret = pw(a, p >> 1LL);\n    ret = MOD(ret * ret);\n    if (p & 1LL) ret = MOD(ret * a);\n    return ret;\n}\n\nint counter = 1;\nvi g[L];\nll len[L];\nint vert[L];\nint start[L];\nll h[N];\nll dp[2][L];\n\ninline ll get_ways(int v) {\n    vvvl dp(N, vvl(2, vl(2, 0)));\n    vector<char> must(N, 0);\n    for (int id : g[v]) {\n        int to = e[id].v;\n        for (int i = 1; i < len[to]; ++i)\n            must[i + start[to]] = 1;\n    }\n    dp[start[v]][0][0] = dp[start[v]][0][1] = 1;\n    for (int i = 1; i < len[v]; ++i) {\n        int ind = i + start[v];\n        if (must[ind]) {\n            for (int z1 : {0, 1}) for (int z2 : {0, 1})\n                dp[ind][z1][z2] = dp[ind - 1][z1][!z2];\n        } else {\n            for (int z1 : {0, 1}) for (int z2 : {0, 1}) for (int z3 : {0, 1}) {\n                int nx = z1;\n                if (z2 != z3) nx = 1;\n                dp[ind][nx][z3] = MOD(dp[ind][nx][z3] + dp[ind - 1][z1][z2]);\n            }\n        }\n    }\n    ll ret = MOD(dp[start[v] + len[v] - 1][1][0] + dp[start[v] + len[v] - 1][1][1]);\n    return ret;\n}\n\nll dfs(int v) {\n    ll dp0 = 1;\n    ll dp1 = 1;\n    ll dp2 = 0;\n    ll restlen = len[v];\n    for (int id : g[v]) {\n        int to = e[id].v;\n        dfs(to);\n        restlen -= len[to];\n        ll curgood = MOD(pw(2, e[id].height - 1) * dp[0][to]);\n        ll curbad = dp[1][to];\n        dp2 = MOD(dp2 * (curgood * 2 + curbad) + dp1 * curbad);\n        dp1 = MOD(dp1 * curgood * 2);\n        dp0 = MOD(dp0 * curgood);\n    }\n    dp[1][v] = MOD(dp2 * pw(2, restlen) + dp0 * get_ways(v));\n    dp[0][v] = MOD(2 * dp0);\n}\n\nsigned main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n\n    int n;\n    cin >> n;\n    set<ll> hs;\n    fori (i, n) {\n        cin >> h[i];\n        hs.insert(h[i]);\n    }\n    ll prev = 0;\n    len[counter++] = n;\n    fori (i , n)\n        vert[i] = 1;\n    int curv = 0;\n    int par = 0;\n    for (auto hi : hs) {\n        int cnt = 0;\n        fori (i, n) {\n            if (h[i] >= hi) {\n                if (!cnt) {\n                    curv = counter++;\n                    start[curv] = i;\n                    par = vert[i];\n                }\n                vert[i] = curv;\n                cnt++;\n            } else {\n                if (cnt >= 2) {\n                    len[curv] = cnt;\n                    g[par].pb(SZ(e));\n                    e.pb(edge(par, curv, hi - prev));\n                }\n                cnt = 0;\n            }\n        }\n        if (cnt >= 2) {\n            len[curv] = cnt;\n            g[par].pb(SZ(e));\n            e.pb(edge(par, curv, hi - prev));\n        }\n        prev = hi;\n    }\n    ll fre = 0;\n    fori (i, n) {\n        ll neib = 0;\n        if (i) mmax(neib, h[i - 1]);\n        if (i != n - 1) mmax(neib, h[i + 1]);\n        fre += max(0LL, h[i] - neib);\n    }\n    dfs(2);\n    ll ans = MOD(dp[0][2] * pw(2, e[g[1][0]].height - 1) + dp[1][2]);\n    ans = MOD(ans * pw(2, fre));\n    cout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nconst int mod = 1e9 + 7;\nmap<vi, int> dp, dp2;\n\nint pw2(int x){\n\tint res = 1;\n\tfor(ll m = 2; x; x /= 2){\n\t\tif(x & 1) res = res * m % mod;\n\t\tm = m * m % mod;\n\t}\n\treturn res;\n}\nvector<vi> children(const vi &h){\n\tint mn = *min_element(all(h)), n = h.size();\n\tvector<vi> cs;\n\tvi tmp;\n\trep(i, n){\n\t\tif(h[i] > mn) tmp.pb(h[i] - mn);\n\t\tif(h[i] == mn || i == n-1){\n\t\t\tif(tmp.size()) cs.pb(tmp);\n\t\t\ttmp.clear();\n\t\t}\n\t}\n\treturn cs;\n}\nint rec2(const vi &h){\n\tif(dp2.count(h)) return dp2[h];\n\tint &res2 = dp2[h], mn = *min_element(all(h));\n\tres2 = pw2(mn);\n\tfor(vi &c : children(h)) res2 = (ll)res2 * rec2(c) % mod;\n\treturn res2;\n}\nint rec(const vi &h){\n\tif(dp.count(h)) return dp[h];\n\tint &res = dp[h];\n\tint mn = *min_element(all(h)), rem = count(all(h), mn);\n\t\n\t//パターン1 i列目とi+1列目が反転でも同じでもいい\n\t//パターン2 i列目とi+1列目が反転\n\tint res1 = pw2(rem);\n\tint res2 = pw2(mn) + mod - 2;\n\tfor(vi &c : children(h)){\n\t\tres1 = res1 * (ll)(rec(c) + rec2(c)) % mod;\n\t\tres2 = res2 * (ll)rec2(c) % mod;\n\t}\n\treturn res = (res1 + res2) % mod;\n}\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\t\n\tint n; cin >> n;\n\tvi h(n); rep(i, n) cin >> h[i];\n\tcout << rec(h) << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<map>\n#include<vector>\n#include<queue>\n#include<deque>\n#define ll long long\n#define mp make_pair\n#define rep(i,x,y) for(int i=(x);i<=(y);++i)\n#define r0p(i,n) for(int i=0;i<n;++i)\n#pragma GCC optimize(1)\n#pragma G++ optimize(1)\n#pragma GCC optimize(2)\n#pragma G++ optimize(2)\n#pragma GCC optimize(3)\n#pragma G++ optimize(3)\n#pragma GCC optimize(\"-funsafe-loop-optimizations\")\n#pragma GCC optimize(\"-funroll-loops\")\n#pragma GCC optimize(\"-fwhole-program\")\n#pragma GCC optimize(\"-fthread-jumps\")\n#pragma GCC optimize(\"-falign-functions\")\n#pragma GCC optimize(\"-falign-jumps\")\n#pragma GCC optimize(\"-falign-loops\")\n#pragma GCC optimize(\"-falign-labels\")\n#pragma GCC optimize(\"-fcaller-saves\")\n#pragma GCC optimize(\"-fcrossjumping\")\n#pragma GCC optimize(\"-fcse-follow-jumps\")\n#pragma GCC optimize(\"-fcse-skip-blocks\")\n#pragma GCC optimize(\"-fdelete-null-pointer-checks\")\n#pragma GCC optimize(\"-fexpensive-optimizations\")\n#pragma GCC optimize(\"-fgcse\")\n#pragma GCC optimize(\"-fgcse-lm\")\n#pragma GCC optimize(\"-finline-small-functions\")\n#pragma GCC optimize(\"-findirect-inlining\")\n#pragma GCC optimize(\"-foptimize-sibling-calls\")\n#pragma GCC optimize(\"-fpeephole2\")\n#pragma GCC optimize(\"-freorder-blocks\")\n#pragma GCC optimize(\"-freorder-functions\")\n#pragma GCC optimize(\"-frerun-cse-after-loop\")\n#pragma GCC optimize(\"-fsched-interblock\")\n#pragma GCC optimize(\"-fsched-spec\")\n#pragma GCC optimize(\"-fschedule-insns\")\n#pragma GCC optimize(\"-fschedule-insns2\")\n#pragma GCC optimize(\"-fstrict-aliasing\")\n#pragma GCC optimize(\"-fstrict-overflow\")\n#pragma GCC optimize(\"-ftree-switch-conversion\")\n#pragma GCC optimize(\"-ftree-pre\")\n#pragma GCC optimize(\"-ftree-vrp\")\n#define pii pair<int,int>\n#pragma GCC diagnostic error \"-std=c++11\"\nusing namespace std;\ninline void rdl(long long &val){\n    long long x=0;\n    int f=1;\n    char ch=getchar();\n    while((ch<'0' or ch>'9') and ch!='-') ch=getchar();\n    if(ch=='-'){\n        f=-1;\n        ch=getchar();\n\t}\n\twhile(ch>='0' and ch<='9'){\n\t    x=(x<<3)+(x<<1)+ch-'0';\n\t\tch=getchar();\n\t}\n    val=x*f;\n}\ninline void rdi(int &val){\n    int x=0;\n    int f=1;\n    char ch=getchar();\n    while((ch<'0' or ch>'9') and ch!='-') ch=getchar();\n    if(ch=='-'){\n        f=-1;\n        ch=getchar();\n    }\n    while(ch>='0' and ch<='9'){\n        x=(x<<3)+(x<<1)+ch-'0';\n        ch=getchar();\n    }\n    val=x*f;\n}\ninline long long rdl(){\n    long long x=0;\n    int f=1;\n    char ch=getchar();\n    while((ch<'0' or ch>'9') and ch!='-') ch=getchar();\n    if(ch=='-'){\n        f=-1;\n        ch=getchar();\n    }\n    while(ch>='0' and ch<='9'){\n        x=(x<<3)+(x<<1)+ch-'0';\n        ch=getchar();\n    }\n    return x*f;\n}\ninline int rdi(){\n    int x=0;\n    int f=1;\n\tchar ch=getchar();\n\twhile((ch<'0' or ch>'9') and ch!='-') ch=getchar();\n\tif(ch=='-'){\n        f=-1;\n        ch=getchar();\n    }\n    while(ch>='0' and ch<='9'){\n        x=(x<<3)+(x<<1)+ch-'0';\n        ch=getchar();\n    }\n    return x*f;\n}\ninline void write(int x){\n    if(x<0) putchar('-'),x=-x;\n    if(x>9) write(x/10);\n    putchar(x%10+'0');\n}\ninline void _write(int x){\n\twrite(x);\n\tputchar(' ');\n}\ninline void print(int x){\n\twrite(x);\n\tputchar('\\n');\n}\ninline void write(ll x){\n    if(x<0) putchar('-'),x=-x;\n    if(x>9) write(x/10);\n    putchar(x%10+'0');\n}\ninline void _write(ll x){\n\twrite(x);\n\tputchar(' ');\n}\ninline void print(ll x){\n\twrite(x);\n\tputchar('\\n');\n}\nconst ll md=1000000007;\ninline ll qp(ll a,ll b){\n\tll rt=1;\n\twhile(b){\n\t\tif(b&1) rt=(rt*a)%md;\n\t\ta=(a*a)%md;\n\t\tb>>=1; \n\t}\n\treturn rt;\n}\nll w[111],dp[111];\nint n;\nint main(){\n\tint i,j,k;\n\trdi(n);\n\tfor(i=1;i<=n;++i) rdl(w[i]);\n\tdp[0]=1;\n\tw[n+1]=1;\n\tfor(i=1;i<n+2;++i){\n\t\tdp[i]=dp[i-1]*2%md;\n\t\tfor(j=1;j<i;++j){\n\t\t\tll t=max(w[i],w[j-1]),mn=w[j]-1;\n\t\t\tll sum=0;\n\t\t\tfor(k=j;k<i;++k) mn=min(mn,w[k]-1),sum+=max(w[k+1]-w[k],0ll);\n\t\t\tif(t<=mn){\n\t\t\t\tll t1=qp(2,w[j]-1-mn);\n\t\t\t\tll t2=qp(2,mn-t+1)-1;\n\t\t\t\tll t3=qp(2,sum);\n\t\t\t\tdp[i]=(dp[i]+4ll*dp[j-1]*t1%md*t2%md*t3)%md;\n\t\t\t}\n\t\t}\n\t}\n\tprint(dp[n+1]*500000004ll%md);\n}"
  },
  {
    "language": "C++",
    "code": "//              +-- -- --++-- +-In the name of ALLAH-+ --++-- -- --+              \\\\\n\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define _sz(x) (int)x.size()\n\nusing namespace std ;\nusing ll = long long ;\nusing ld = long double ;\nusing pii = pair <int , int> ;\n\nint const N = 100 + 10 , mod = 1e9 + 7 ;\nint n , h[N] ;\n\nint inv2 = (mod + 1) >> 1 ;\n\nint z = 1 ;\nset <pii> dp ;\n\ninline void add (int &a , int b) {\n\ta += b ;\n\tif (a >= mod) a -= mod ;\n}\n\ninline int pw (int a , int b) {\n\tint res = 1 ;\n\tfor (; b ; b >>= 1 , a = 1ll * a * a % mod) \n\t\tif (b & 1) res = 1ll * res * a % mod ;\n\treturn res ;\n}\n\ninline int get (int start , int len) {\n\treturn (2 * start - (2ll * start * pw(inv2 , len)) % mod + mod) % mod ;\n}\n\nint main(){\n\tios::sync_with_stdio(false) , cin.tie(0) , cout.tie(0) ;\n\t\n\tcin >> n ;\n\tfor (int i = 0 ; i < n ; i ++) cin >> h[i] ;\n\n\tif (h[0] > 1) dp.insert({1 , pw(2 , h[0] - 1)}) ; \n\tdp.insert({h[0] , 2}) ;\n\n\tfor (int i = 1 ; i < n ; i ++) {\n\t\tif (h[i - 1] >= h[i]) {\n\t\t\tint sum = 0 , last = h[i - 1] + 1 ;\n\t\t\twhile (dp.size() && dp.rbegin() -> F > h[i]) {\n\t\t\t\tpii p = *dp.rbegin() ;\n\t\n\t\t\t\tadd(sum , get(p.S , last - p.F)) ;\n\n\t\t\t\tlast = p.F ;\n\n\t\t\t\tdp.erase(p) ;\n\t\t\t}\n\n\t\t\tif (dp.size()) {\n\t\t\t\tpii p = *dp.rbegin() ;\n\t\t\t\tadd(sum , get(1ll * p.S * pw(inv2 , h[i] - p.F) % mod , last - h[i])) ;\n\t\t\t\tif (p.F == h[i]) dp.erase(p) ;\n\t\t\t}\n\n\t\t\tadd(sum , sum) ;\n\n\t\t\tdp.insert({h[i] , sum}) ; \n\t\t}\n\t\telse {\n\t\t\tz = 1ll * z * pw(2 , h[i] - h[i - 1]) % mod ;\n\n\t\t\tpii p = *dp.rbegin() ;\n\n\t\t\tdp.insert({h[i] , 2ll * p.S * pw(inv2 , h[i] - h[i - 1]) % mod}) ;\n\t\t}\n\t}\n\n\tint last = h[n - 1] + 1 , ans = 0 ;\n\twhile (_sz(dp)) {\n\t\tpii p = *dp.rbegin() ;\n\t\n\t\tadd(ans , get(p.S , last - p.F)) ;\n\n\t\tlast = p.F ;\n\n\t\tdp.erase(p) ;\n\t}\n\n\tans = 1ll * ans * z % mod ;\n\n\tcout << ans << '\\n' ;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n\ntypedef long long LL;\n\nconst int N=105;\nconst int MOD=1000000007;\n\nint n,f[N][N],h[N],w[N],m;\n\nint ksm(int x,int y)\n{\n    if (y<0) return 1;\n    int ans=1;\n    while (y)\n    {\n        if (y&1) ans=(LL)ans*x%MOD;\n        x=(LL)x*x%MOD;y>>=1;\n    }\n    return ans;\n}\n\nint main()\n{\n    scanf(\"%d\",&n);\n    for (int i=1;i<=n;i++) scanf(\"%d\",&h[i]),w[++m]=h[i];\n    std::sort(w+1,w+m+1);\n    m=std::unique(w+1,w+m+1)-w-1;\n    for (int i=1;i<=n;i++) h[i]=std::lower_bound(w+1,w+m+1,h[i])-w;\n    f[0][0]=1;\n    for (int i=1;i<=n;i++)\n    {\n        for (int j=h[i]+1;j<=h[i-1];j++) (f[i][0]+=f[i-1][j]*2%MOD)%=MOD;\n        (f[i][0]+=f[i-1][0]*2%MOD)%=MOD;\n        for (int j=1;j<=h[i];j++)\n        {\n            f[i][j]=(LL)f[i-1][j]*ksm(2,w[h[i]]-w[h[i-1]])%MOD;\n            if (h[i-1]>=j) continue;\n            if (j>1) (f[i][j]+=(LL)f[i-1][0]*ksm(2,w[h[i]]-w[j-1])%MOD)%=MOD;\n            else (f[i][j]+=(LL)f[i-1][0]*(ksm(2,w[j])-2)%MOD*ksm(2,w[h[i]]-w[j])%MOD)%=MOD;\n        }\n    }\n    \n//    printf(\"%d\\n\", h[1]);\n//    for(int i = 0; i <= h[1]; ++i) printf(\"%d \", f[1][i]); printf(\"\\n\");\n    \n    int ans=0;\n    for (int i=0;i<=m;i++) (ans+=f[n][i])%=MOD;\n    printf(\"%d\",ans);\n    return 0;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define fi first\n#define se second\nusing namespace std;\ninline char nc()\n{\n//\treturn getchar();\n\tstatic char buf[100000],*l=buf,*r=buf;\n\treturn l==r&&(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;\n}\ntemplate<class T> void read(T &x)\n{\n\tx=0; int f=1,ch=nc();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=nc();}\n\twhile(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=nc();}\n\tx*=f;\n}\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int mod=1e9+7;\nconst int maxn=100+5;\nint n;\nint h[maxn];\nint dp[maxn][maxn][2];\nvector<pii> rec[maxn];\ninline void upd(int &x,int y) {x+=y; if(x>=mod) x-=mod;}\nll power(ll x,ll y)\n{\n\tll re=1;\n\twhile(y)\n\t{\n\t\tif(y&1) re=re*x%mod;\n\t\tx=x*x%mod;\n\t\ty>>=1;\n\t}\n\treturn re;\n}\nint main()\n{\n\tread(n);\n\tfor(int i=1;i<=n;++i) read(h[i]);\n\tfor(int i=1;i<=n;++i) if(h[i]!=1)\n\t{\n\t\tint l=i,r=i,ok=1;\n\t\tfor(l=i;;--l)\n\t\t{\n\t\t\tif(l!=i&&h[l]==h[i]) {ok=0; break;}\n\t\t\tif(l==1||h[l-1]<h[i]) break;\n\t\t}\n\t\tif(!ok) continue;\n\t\tfor(r=i;;++r)\n\t\t{\n\t\t\tif(r==n||h[r+1]<h[i]) break;\n\t\t}\n//\t\tdebug(\"%d %d %d %d\\n\",l,r,h[i],h[i]-max(l==1?1:h[l-1],r==n?1:h[r+1]));\n\t\trec[r].push_back(make_pair(l,power(2,h[i]-max(l==1?1:h[l-1],r==n?1:h[r+1]))));\n\t}\n\tdp[1][0][0]=dp[1][0][1]=rec[1].size()?rec[1][0].se:1;\n\tfor(int i=2;i<=n;++i) \n\t{\n\t\tfor(int j=0;j<i;++j) for(int k=0;k<2;++k) if(dp[i-1][j][k])\n\t\t{\n\t\t\tupd(dp[i][i][k],dp[i-1][j][k]);\n\t\t\tupd(dp[i][j][k^1],dp[i-1][j][k]);\n\t\t}\n\t\tfor(int j=0;j<=i;++j) for(int k=0;k<2;++k) if(dp[i][j][k])\n\t\t{\n\t\t\tfor(int l=0;l<rec[i].size();++l)\n\t\t\t{\n\t\t\t\tif(j<=rec[i][l].fi) dp[i][j][k]=(ll)dp[i][j][k]*rec[i][l].se%mod;\n\t\t\t}\n\t\t}\n\t}\n\tint an=0;\n\tfor(int j=0;j<=n;++j) for(int k=0;k<2;++k) upd(an,dp[n][j][k]);\n\tprintf(\"%d\\n\",an);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define sqr(x) ((x) * (x))\n#define pb push_back\n#define mp make_pair\n#define X first\n#define Y second\n#define fin(name) freopen(name, \"r\", stdin)\n#define fout(name) freopen(name, \"w\", stdout)\n#define I(x, a) for(auto x : a)\n#define F(i, l, r) for(auto i = l; i < r; ++i)\n#define E(i, l, r) for(auto i = l; i <= r; ++i)\n#define DF(i, l, r) for(auto i = l; i >= r; --i)\n#define clean(a) memset((a),0,sizeof (a))\n#define sync ios_base::sync_with_stdio(0);cin.tie(0)\n#define all(x) (x).begin(),(x).end()\n#define ret return\n#define cont continue\n#define brk break\n#define ins insert\n#define sz(a) ((int)(a).size())\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double dbl;\ntypedef pair <int, int> pii;\n\nconst int inf = (int)1e9;\nconst ll linf = (ll)1e18;\nconst int mod = (int)1e9 + 7;\nconst dbl eps = (dbl)1e-8;\nconst int maxn = (int)1e5 + 5;\nconst dbl pi = acos(-1);\n\nvoid add(ll a, ll& b) {\n\tb += a;\n\tif (b >= mod)\n\t\tb -= mod;\n}\n\nll pw(ll x, ll y) {\n\tif (y == 0)\n\t\treturn 1;\n\tif (y & 1)\n\t\treturn pw(x, y - 1) * x % mod;\n\tx = pw(x, y / 2);\n\treturn x * x % mod;\n}\n\nll d[105][105];\nint n, h[105], sh[105], pos[105];\n\nint main() {\n//\tfin(\"t.in\");\n\tsync;\n\tcin >> n;\n\tE(i, 1, n) {\n\t\tcin >> h[i];\n//\t\th[i] = 100 * i;\n\t\tsh[i] = h[i];\n\t}\n\tsh[0] = h[0] = 1;\n\tsort(sh, sh + n + 1);\n\tE(i, 0, n) {\n\t\tpos[i] = 0;\n\t\twhile (sh[pos[i]] < h[i])\n\t\t\t++pos[i];\n\t}\n\n\tclean(d);\n\td[0][0] = 1;\n\tF(i, 0, n) {\n\t\tE(j, 0, n) {\n\t\t\tif (d[i][j] == 0)\n\t\t\t\tcont;\n\t\t\tif (h[i + 1] <= h[i]) {\n\t\t\t\tif (j < pos[i + 1])\n\t\t\t\t\tadd(d[i][j], d[i + 1][j]);\n\t\t\t\telse\n\t\t\t\t\tadd(2ll * d[i][j] % mod, d[i + 1][pos[i + 1]]);\n\t\t\t} else {\n\t\t\t\tif (j < pos[i]) {\n\t\t\t\t\tadd(pw(2, h[i + 1] - h[i]) * d[i][j] % mod, d[i + 1][j]);\n\t\t\t\t} else {\n\t\t\t\t\tF(k, j, pos[i + 1]) {\n\t\t\t\t\t\tll x = 2ll * (pw(2, h[i + 1] - sh[k]) - pw(2, h[i + 1] - sh[k + 1])) * d[i][j];\n\t\t\t\t\t\tx %= mod;\n\t\t\t\t\t\tx += mod;\n\t\t\t\t\t\tx %= mod;\n\t\t\t\t\t\tadd(x, d[i + 1][k]);\n\t\t\t\t\t}\n\t\t\t\t\tadd(2ll * d[i][j] % mod, d[i + 1][pos[i + 1]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\n\tll ans = 0;\n\tE(i, 0, n) {\n//\t\tcout << i << \" \" << d[2][i] << endl;\n\t\tadd(d[n][i], ans);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <functional>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <memory>\n#include <thread>\n#include <tuple>\n\nusing namespace std;\n\nconst int mod = 1'000'000'007;\nvector<int> h;\n\nstruct dp_t {\n  long long alternating;\n  long long other;\n};\n\nlong long power(long long n, long long k, long long m) {\n  if (m < 0) m = -m;\n  n %= m;\n  long long ret = 1;\n  while (k) {\n    if (k & 1) ret = (ret * n % m);\n    n = (n * n % m);\n    k >>= 1;\n  }\n  return ret;\n}\n\n\ndp_t solve(int L, int R, int base) {\n  dp_t res = { 0, 0 };\n  if (L == R) {\n    int count = h[L] - base;\n    res.alternating = power(2, count - 1, mod);\n    return res;\n  }\n  int splitbase = *min_element(h.begin() + L, h.begin() + R + 1);\n  int last = L;\n  long long alternate = 1;\n  long long all = 1;\n  for (int i = L; i <= R; i++) {\n    if (h[i] == splitbase) {\n      last = i + 1;\n      all *= 2;\n      all %= mod;\n    }\n    else if (i + 1 > R || h[i + 1] == splitbase) {\n      dp_t sub = solve(last, i, splitbase);\n      alternate *= sub.alternating * 2;\n      alternate %= mod;\n      all *= (sub.alternating * 4 + sub.other) % mod;\n      all %= mod;\n    }\n  }\n\n  res.other = (all - alternate * 2) % mod;\n  alternate *= power(2, splitbase - base - 1, mod);\n  alternate %= mod;\n  res.alternating = alternate;\n  return res;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  h.resize(n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &h[i]);\n  }\n  dp_t ans = solve(0, n-1, 0);\n  long long val = (ans.alternating * 2 + ans.other) % mod;\n  val += mod;\n  val %= mod;\n  printf(\"%lld\\n\", val);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\n#define FILL(a, n, x) memset((a), (x), sizeof ((a)[0]) * (n))\n#define COPY(a, n, b) memcpy((b), (a), sizeof ((a)[0]) * (n))\n#define FILLA(a, x) memset((a), (x), sizeof (a))\n#define COPYA(a, b) memcpy((b), (a), sizeof (a))\n\nusing namespace std;\n\ntypedef long long li;\ntypedef unsigned long long lu;\nconst li infl = ~0LLU >> 2;\n\ntemplate <class T>\ninline void Min(T &x, T y) {\n  if (y < x) x = y;\n}\ntemplate <class T>\ninline void Max(T &x, T y) {\n  if (y > x) x = y;\n}\n\nconst int mod = 1e9 + 7;\ninline int Add(int x) { return x >= mod ? x - mod : x; }\ninline void Add(int &x, int y) { x += y; if (x >= mod) x -= mod; }\ninline int Sub(int x) { return x < 0 ? x + mod : x; }\ninline void Sub(int &x, int y) { x -= y; if (x < 0) x += mod; }\ninline int Mul(int x, int y) { return (int)((li)x * y % mod); }\ninline int Mul(int x, int y, int z) { return Mul(x, Mul(y, z)); }\nint Pow(int x, int y) {\n  int z = 1;\n  for (; y; y >>= 1) {\n    if (y & 1) z = Mul(z, x);\n    x = Mul(x, x);\n  }\n  return z;\n}\nint Inv(int x) {\n  return Pow(x, mod - 2);\n}\n\n// ----------------------------------------\n\nconst int S = 8;\nconst lu mods = 8LLU * mod * mod;\ntypedef int Mat[S][S];\n\nvoid MatMul(Mat a, const Mat b) {\n  static lu c[S][S];\n  FILLA(c, 0);\n  for (int i = 0; i < S; ++i) {\n    for (int k = 0; k < S; ++k) {\n      for (int j = 0; j < S; ++j) {\n        c[i][j] += (lu)a[i][k] * b[k][j];\n        if (c[i][j] >= mods) c[i][j] -= mods;\n      }\n    }\n  }\n  for (int i = 0; i < S; ++i) {\n    for (int j = 0; j < S; ++j) {\n      a[i][j] = (int)(c[i][j] % mod);\n    }\n  }\n}\n\nvoid MatPow(Mat a, int e) {\n  static Mat b;\n  FILLA(b, 0);\n  for (int i = 0; i < S; ++i) {\n    b[i][i] = 1;\n  }\n  for (; e; e >>= 1) {\n    if (e & 1) MatMul(b, a);\n    MatMul(a, a);\n  }\n  COPYA(b, a);\n}\n\nMat tran, tr;\n\nint State(int L, int R, int T) {\n  return L | R << 1 | T << 2;\n}\n\nvoid BuildTran(void) {\n  FILLA(tran, 0);\n  for (int L = 0; L <= 1; ++L) {\n    for (int R = 0; R <= 1; ++R) {\n      tran[State(L, R, 0)][State(!L, !R, 0)] = 1;\n      tran[State(L, R, 1)][State(!L, !R, 1)] = 1;\n      tran[State(L, R, 1)][State(L, R, 1)] = 1;\n    }\n  }\n}\n\nstruct Part {\n  int val[S];\n\n  int & operator [] (int i) {\n    return val[i];\n  }\n\n  void Tran(int h) {\n    COPYA(tran, tr);\n    MatPow(tr, h);\n    static lu valnew[S];\n    FILLA(valnew, 0);\n    for (int i = 0; i < S; ++i) {\n      for (int j = 0; j < S; ++j) {\n        valnew[j] += (lu)val[i] * tr[i][j];\n        if (valnew[j] >= mods) valnew[j] -= mods;\n      }\n    }\n    for (int i = 0; i < S; ++i) {\n      val[i] = (int)(valnew[i] % mod);\n    }\n  }\n\n  Part Combine(const Part &rhs) const {\n    Part ans;\n    FILLA(ans.val, 0);\n    for (int L1 = 0; L1 <= 1; ++L1) {\n      for (int R1 = 0; R1 <= 1; ++R1) {\n        for (int L2 = 0; L2 <= 1; ++L2) {\n          for (int R2 = 0; R2 <= 1; ++R2) {\n            for (int T1 = 0; T1 <= 1; ++T1) {\n              for (int T2 = 0; T2 <= 1; ++T2) {\n                int Tnew = T1 && T2 && (R1 != L2);\n                Add(ans.val[State(L1, R2, Tnew)],\n                    Mul(val[State(L1, R1, T1)],\n                        rhs.val[State(L2, R2, T2)]));\n              }\n            }\n          }\n        }\n      }\n    }\n    return ans;\n  }\n};\n\nPart SingleUnit(void) {\n  Part ans;\n  FILLA(ans.val, 0);\n  ans[State(0, 0, 1)] = ans[State(1, 1, 1)] = 1;\n  return ans;\n}\n\n// ----------------------------------------\n\nconst int maxn = 100;\nconst int inf = ~0U >> 1;\n\nint n, h[maxn];\n\nPart Solve(int l, int r, int d) {\n  int min_val = inf, min_pos = -1;\n  for (int i = l; i < r; ++i) {\n    if (h[i] < min_val) {\n      min_val = h[i];\n      min_pos = i;\n    }\n  }\n\n  int mid = min_pos, level = min_val - 1;\n  Part ans = SingleUnit();\n  if (mid > l) {\n    ans = Solve(l, mid, level).Combine(ans);\n  }\n  if (mid < r - 1) {\n    ans = ans.Combine(Solve(mid + 1, r, level));\n  }\n  ans.Tran(level - d);\n\n  return ans;\n}\n\nint main(void) {\n  BuildTran();\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d\", h + i);\n  }\n  Part ans = Solve(0, n, 0);\n  int sum = 0;\n  for (int i = 0; i < S; ++i) {\n    Add(sum, ans.val[i]);\n  }\n  printf(\"%d\\n\", sum);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define INF int(1e9+5)\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=1;i<=(n);i++)\n#define mp make_pair\n#define pb push_back\n#define fst first\n#define snd second\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst int maxn=105;\nconst int mod=1e9+7;\nint n;\nint h[maxn],dp[maxn][maxn][3];\n\nint quickpow(int x,int pow){\n\tint res=1;\n\tfor(;pow;pow>>=1){\n\t\tif(pow&1)res=1LL*res*x%mod;\n\t\tx=1LL*x*x%mod;\n\t}\n\treturn res;\n}\n\nvoid solve(int l,int r,int last){\n\tdp[l][r][0]=dp[l][r][1]=dp[l][r][2]=1;\n\tint mn=INF;\n\tfor(int i=l;i<=r;i++)mn=min(mn,h[i]);\n\tint cnt=0;\n\tfor(int i=l;i<=r;i++){\n\t\tif(h[i]==mn)cnt++;\n\t\telse{\n\t\t\tint j=i;\n\t\t\twhile(j<=r&&h[j]>mn)j++;\n\t\t\tsolve(i,j-1,mn-1);\n\t\t\tdp[l][r][0]=1LL*dp[l][r][0]*dp[i][j-1][(i-l)&1]%mod;\n\t\t\tdp[l][r][1]=1LL*dp[l][r][1]*dp[i][j-1][1^((i-l)&1)]%mod;\n\t\t\tdp[l][r][2]=1LL*dp[l][r][2]*dp[i][j-1][2]%mod;\n\t\t\ti=j-1; \n\t\t}\n\t}\n\tint cur=dp[l][r][0]+dp[l][r][1];\n\tif(cur>=mod)cur-=mod;\n\tdp[l][r][2]=1LL*dp[l][r][2]*quickpow(2,cnt)%mod;\n\tdp[l][r][2]-=cur;\n\tif(dp[l][r][2]<0)dp[l][r][2]+=mod;\n\tif(mn-last>1)dp[l][r][0]=dp[l][r][1]=1LL*cur*quickpow(2,mn-last-2)%mod;\n\trep(i,2){\n\t\tdp[l][r][2]+=dp[l][r][i];\n\t\tif(dp[l][r][2]>=mod)dp[l][r][2]-=mod;\n\t}\n} \n\nint main(){\n\tscanf(\"%d\",&n);\n\tREP(i,n)scanf(\"%d\",&h[i]);\n\tsolve(1,n,0);\n\tprintf(\"%d\\n\",dp[1][n][2]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <tuple>\n#include <cstdint>\n#include <cstdio>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <deque>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <cctype>\n#include <functional>\n#include <ctime>\n#include <fstream>\n#include <cmath>\n#include <limits>\n#include <numeric>\n#include <type_traits>\n#include <iomanip>\n#include <float.h>\n#include <math.h>\n#pragma warning (disable: 4996)\nusing namespace std;\nusing ll = long long;\nunsigned euclidean_gcd(unsigned a, unsigned b) {\n    if (a < b) return euclidean_gcd(b, a);\n    unsigned r;\n    while ((r = a % b)) {\n        a = b;\n        b = r;\n    }\n    return b;\n}\n\nll ll_gcd(ll a, ll b) {\n    if (a < b) return ll_gcd(b, a);\n    ll r;\n    while ((r = a % b)) {\n        a = b;\n        b = r;\n    }\n    return b;\n}\n\nstruct UnionFind {\n    vector <ll> par;\n    vector <ll> siz;\n    UnionFind(ll sz_) : par(sz_), siz(sz_, 1LL) {\n        for (ll i = 0; i < sz_; ++i) par[i] = i;\n    }\n    void init(ll sz_) {\n        par.resize(sz_);\n        siz.assign(sz_, 1LL);\n        for (ll i = 0; i < sz_; ++i) par[i] = i;\n    }\n    ll root(ll x) {\n        while (par[x] != x) {\n            x = par[x] = par[par[x]];\n        }\n        return x;\n    }\n    bool merge(ll x, ll y) {\n        x = root(x);\n        y = root(y);\n        if (x == y) return false;\n        if (siz[x] < siz[y]) swap(x, y);\n        siz[x] += siz[y];\n        par[y] = x;\n        return true;\n    }\n\n    bool issame(ll x, ll y) {\n        return root(x) == root(y);\n    }\n\n    ll size(ll x) {\n        return siz[root(x)];\n    }\n};\n\nlong long modpow(long long a, long long n, long long mod) {\n    if (n < 0)return 0;\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\nlong long modinv(long long a, long long mod) {\n    return modpow(a, mod - 2, mod);\n}\n\nvector<int> tpsort(vector<vector<int>>& G) {\n    int V = G.size();\n    vector<int> sorted_vertices;\n    queue<int> que;\n    vector<int> indegree(V);\n    for (int i = 0; i < V; i++) {\n        for (int j = 0; j < G[i].size(); j++) {\n            indegree[G[i][j]]++;\n        }\n    }\n    for (int i = 0; i < V; i++) {\n        if (indegree[i] == 0) {\n            que.push(i);\n        }\n    }\n    while (que.empty() == false) {\n        int v = que.front();\n        que.pop();\n        for (int i = 0; i < G[v].size(); i++) {\n            int u = G[v][i];\n            indegree[u] -= 1;\n            if (indegree[u] == 0) que.push(u);\n        }\n        sorted_vertices.push_back(v);\n    }\n    return sorted_vertices;\n}\n\nstruct Point\n{\n    double x;\n    double y;\n};\n\nstruct LineSegment\n{\n    Point start;\n    Point end;\n};\n\ndouble tenkyori(const LineSegment& line, const Point& point)\n{\n    double x0 = point.x, y0 = point.y;\n    double x1 = line.start.x, y1 = line.start.y;\n    double x2 = line.end.x, y2 = line.end.y;\n\n    double a = x2 - x1;\n    double b = y2 - y1;\n    double a2 = a * a;\n    double b2 = b * b;\n    double r2 = a2 + b2;\n    double tt = -(a * (x1 - x0) + b * (y1 - y0));\n\n    if (tt < 0)\n        return sqrt((x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0));\n    else if (tt > r2)\n        return sqrt((x2 - x0) * (x2 - x0) + (y2 - y0) * (y2 - y0));\n\n    double f1 = a * (y1 - y0) - b * (x1 - x0);\n    return sqrt((f1 * f1) / r2);\n}\nvoid dfs1(vector<vector<ll>>& z, ll k, ll oya, ll& ans, vector<ll>& b) {\n    for (auto m : z[k]) {\n        if (m != oya)dfs1(z, m, k, ans, b);\n    }\n    vector<ll> s;\n    for (auto m : z[k]) {\n        if (m != oya)s.push_back(b[m]);\n    }\n    ll m = b.size() - 1;\n    for (auto d : s) {\n        m -= d;\n    }\n    b[k] = b.size() - m;\n    if (m != 0)s.push_back(m);\n    ll a = modinv(2, 1000000007);\n    for (auto d : s) {\n        a += 1000000007 - modinv(modpow(2, b.size() - d, 1000000007), 1000000007);\n    }\n    a += modinv(modpow(2, b.size(), 1000000007), 1000000007) * (z[k].size() - 1);\n    ans += a;\n    ans %= 1000000007;\n    return;\n}\n\nll merge_cnt(vector<int>& a) {\n    int n = a.size();\n    if (n <= 1) { return 0; }\n\n    ll cnt = 0;\n    vector<int> b(a.begin(), a.begin() + n / 2);\n    vector<int> c(a.begin() + n / 2, a.end());\n\n    cnt += merge_cnt(b);\n    cnt += merge_cnt(c);\n\n    int ai = 0, bi = 0, ci = 0;\n    while (ai < n) {\n        if (bi < b.size() && (ci == c.size() || b[bi] <= c[ci])) {\n            a[ai++] = b[bi++];\n        }\n        else {\n            cnt += n / 2 - bi;\n            a[ai++] = c[ci++];\n        }\n    }\n    return cnt;\n}\n\nint main() {\n    ll n;\n    cin >> n;\n    vector<ll> z(n);\n    vector<ll> x(n+1);\n    x[n] = 1;\n    for (int i = 0; i < n; i++) {\n        cin >> z[i];\n        x[i] = z[i];\n    }\n    sort(x.begin(), x.end());\n    unique(x.begin(), x.end());\n    ll m = x.size();\n    vector<ll> d(n);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (z[i] == x[j])d[i] = j;\n        }\n    }\n    vector<vector<ll>> dp(n,vector<ll>(m));\n    for (int i = 0; i < d[0]+1; i++) {\n        dp[0][i] = modpow(2,min(x[d[0]],x[d[0]] - x[i]+1), 1000000007);\n    }\n    \n    for (int i = 0; i < n-1; i++) {\n        if (d[i] < d[i + 1]) {\n            for (int j = 0; j < d[i]; j++) {\n                dp[i + 1][j] += dp[i][j] * modpow(2, max((ll)0, x[d[i + 1]] - x[d[i]]), 1000000007);\n                dp[i + 1][j] %= 1000000007;\n            }\n            for (int j = 0; j < d[i]; j++) {\n                dp[i + 1][j] += dp[i][d[i]] * modpow(2, x[d[i + 1]] - x[d[i]], 1000000007);\n                dp[i + 1][j] %= 1000000007;\n            }\n            for (int j = d[i]; j < d[i + 1] + 1; j++) {\n                dp[i + 1][j] += dp[i][d[i]] * modpow(2, x[d[i + 1]] - x[j]+1, 1000000007);\n                dp[i + 1][j] %= 1000000007;\n            }\n        }\n        else {\n            for (int j = 0; j < d[i + 1] + 1; j++) {\n                dp[i + 1][j] += dp[i][j]+dp[i][d[i+1]];\n                dp[i + 1][j] %= 1000000007;\n            }\n        }\n    }\n    cout << dp[n - 1][0] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <cstdlib>\n#include <cmath>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <ctime>\n#include <vector>\n#include <fstream>\n#include <list>\n#include <iomanip>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n#define ms(s) memset(s, 0, sizeof(s))\nconst ll INF = 1e9;\ninline ll read(){\n\tll X = 0,w = 0 ;\n\tchar ch = 0;\n\twhile(!isdigit(ch)) {w |= ch == '-';ch = getchar();}\n\twhile(isdigit(ch)) X = (X<<3) + (X<<1) + (ch ^ 48),ch = getchar();\n\treturn w ? -X : X;\n}\n\n\nll h[1005];\nll Has[1005];\nll tot;\nll dp[1005][1005];\nll n;\nll mod=1e9+7;\nll Pow(ll x,ll y)\n{\n\tif(y<=0)\n\t{\n\t\treturn 1;\n\t}\n\tll res=1;\n\twhile(y)\n\t{\n\t\tif(y&1)\n\t\t{\n\t\t\tres=res*x%mod;\n\t\t}\n\t\ty>>=1;\n\t\tx=(x*x)%mod;\n\t}\n\treturn res;\n}\nint main()\n{\n\tcin>>n;\n\tdp[0][0]=1;\n\tfor(ll i=1;i<=n;i++)\n\t{\n\t\tcin>>h[i];\n\t\tHas[++tot]=h[i];\n\t}\n\tsort(Has+1,Has+tot+1);\n\ttot=unique(Has+1,Has+tot+1)-Has-1;\n\tfor(ll i=1;i<=n;i++)\n\t{\n\t\th[i]=lower_bound(Has+1,Has+tot+1,h[i])-Has;\n\t}\n\tfor(ll i=1;i<=n;i++)\n\t{\n\t\tdp[i][0]=dp[i-1][0]*2%mod;\n\t\tfor(ll j=h[i]+1;j<=h[i-1];j++)\n\t\t{\n\t\t\tdp[i][0]=(dp[i][0]+dp[i-1][j]*2%mod)%mod;\n\t\t}\n\t\tll tmpPow=Pow(2,Has[h[i]]-Has[h[i-1]]);\n\t\tfor(ll j=1;j<=min(h[i-1],h[i]);j++)\n\t\t{\n\t\t\tdp[i][j]=dp[i-1][j]*tmpPow%mod;\n\t\t}\n\t\tfor(ll j=h[i-1]+1;j<=h[i];j++)\n\t\t{\n\t\t\tdp[i][j]=(dp[i][j]+j==1?(dp[i-1][0]*(Pow(2,Has[j])-2)%mod*Pow(2,Has[h[i]]-Has[j])%mod):(dp[i-1][0]*2*(Pow(2,Has[j]-Has[j-1])-1)%mod*Pow(2,Has[h[i]]-Has[j])%mod))%mod;\n\t\t}\n\t}\n\tll res=0;\n\tfor(ll i=0;i<=tot;i++)\n\t{\n\t\tres=(res+dp[n][i])%mod;\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\nconst int MAXN = 100 + 5;\n\nconst int MOD = (int)1e9 + 7;\n\nint n, h[MAXN], sorted[MAXN];\n\nint qpow(int a, int x) {\n    int res = 1;\n    for (; x > 0; x >>= 1) {\n        if (x & 1)\n            res = 1LL * res * a % MOD;\n        a = 1LL * a * a % MOD;\n    }\n    return res;\n}\n\nbool added[MAXN];\nint R_L[MAXN], L_R[MAXN];\n\nint dp[MAXN][MAXN][2][2][2];\n\nvoid merge(int dp_l[2][2][2], int dp_r[2][2][2], int res[2][2][2]) {\n    int tmp[2][2][2];\n    \n    memset(tmp, 0, sizeof tmp);\n    \n    for (int l = 0; l < 2; ++l)\n    for (int r = 0; r < 2; ++r) {\n        for (int ll = 0; ll < 2; ++ll)\n        for (int rr = 0; rr < 2; ++rr)\n        for (int sl = 0; sl < 2; ++sl)\n        for (int sr = 0; sr < 2; ++sr) {\n            int t = sl | sr | (ll == rr);\n            tmp[l][r][t] = (tmp[l][r][t] + 1LL * dp_l[l][ll][sl] * dp_r[rr][r][sr]) % MOD;\n        }\n    }\n    \n    memcpy(res, tmp, sizeof tmp);\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; ++i) {\n        scanf(\"%d\", h + i);\n        sorted[i] = i;\n    }\n\n    for (int i = 1; i <= n; ++i)\n        for (int j = n; j > i; --j)\n            if (h[sorted[j - 1]] < h[sorted[j]]) {\n                int t = sorted[j - 1];\n                sorted[j - 1] = sorted[j];\n                sorted[j] = t;\n            }\n\n    for (int i = 1; i <= n; ++i) {\n        int j = sorted[i], k = sorted[i - 1], t = (h[k] - h[j]) & 1;\n\n        if (h[k] > h[j]) {\n            for (int L = 1; L <= n; ) {\n                if (!added[L]) {\n                    ++L;\n                } else {\n                    int R = L_R[L];\n\n                    int tmp[2][2][2];\n\n                    for (int l = 0; l < 2; ++l)\n                    for (int r = 0; r < 2; ++r) {\n                        tmp[l][r][1] = dp[L][R][l ^ t][r ^ t][1];\n                        tmp[l][r][0] = 1LL * (dp[L][R][l][r][0] + dp[L][R][l ^ 1][r ^ 1][0]) * qpow(2, h[k] - h[j] - 1) % MOD;\n                    }\n\n                    memcpy(dp[L][R], tmp, sizeof tmp);\n\n                    L = R + 1;\n                }\n            }\n        }\n\n        int tmp[2][2][2];\n        int L = j, R = j;\n\n        memset(tmp, 0, sizeof tmp);\n        tmp[0][0][0] = tmp[1][1][0] = 1;\n\n        if (R_L[j - 1]) {\n            int l = R_L[j - 1], r = j - 1;\n            L_R[l] = R_L[r] = 0;\n            merge(dp[l][r], tmp, tmp);\n            L = l;\n        }\n\n        if (L_R[j + 1]) {\n            int l = j + 1, r = L_R[j + 1];\n            L_R[l] = R_L[r] = 0;\n            merge(tmp, dp[l][r], tmp);\n            R = r;\n        }\n\n        added[j] = true;\n        memcpy(dp[L][R], tmp, sizeof tmp);\n        L_R[L] = R;\n        R_L[R] = L;\n    }\n\n    if (h[sorted[n]] > 1) {\n        int t = (h[sorted[n]] - 1) & 1;\n        int tmp[2][2][2];\n\n        for (int l = 0; l < 2; ++l)\n        for (int r = 0; r < 2; ++r) {\n            tmp[l][r][1] = dp[1][n][l ^ t][r ^ t][1];\n            tmp[l][r][0] = 1LL * (dp[1][n][l][r][0] + dp[1][n][l ^ 1][r ^ 1][0]) * qpow(2, h[sorted[n]] - 1 - 1) % MOD;\n        }\n        \n        memcpy(dp[1][n], tmp, sizeof tmp);\n    }\n\n    int ans = 0;\n    for (int i = 0; i < 2; ++i)\n    for (int j = 0; j < 2; ++j)\n    for (int k = 0; k < 2; ++k) {\n        ans = (ans + dp[1][n][i][j][k]) % MOD;\n    }\n\n    printf(\"%d\\n\", ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define fst first\n#define snd second\n#define SZ(u) ((int) (u).size())\n#define ALL(u) (u).begin(), (u).end()\n\ninline void proc_status()\n{\n    ifstream t(\"/proc/self/status\");\n    cerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate<typename T> inline T read()\n{\n\tregister T sum = 0, fg = 1;\n\tregister char ch(getchar());\n\tfor(; !isdigit(ch); ch = getchar()) if(ch == '-') fg = -1;\n\tfor(;  isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) - '0' + ch;\n\treturn sum * fg;\n}\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\nconst int MOD = (int) 1e9 + 7;\nconst int MAXN = 100;\n\nint n;\n\nint a[MAXN + 5];\n\ninline void input()\n{\n\tn = read<int>();\n\tfor(int i = 1; i <= n; ++i) a[i] = read<int>();\n}\n\nint m;\n\nint val[MAXN + 5];\n\ninline void discrete()\n{\n\tm = 0;\n\tfor(int i = 1; i <= n; ++i) val[++m] = a[i];\n\tsort(val + 1, val + m + 1), m = unique(val + 1, val + n + 1) - (val + 1);\n\tfor(int i = 1; i <= n; ++i) a[i] = lower_bound(val + 1, val + m + 1, a[i]) - val;\n}\n\ninline int fpm(int base, int exp)\n{\n\tint res = 1;\n\tfor(; exp; exp >>= 1, base = (LL) base * base % MOD) if(exp & 1) res = (LL) res * base % MOD;\n\treturn res;\n}\n\ninline void solve()\n{\n\tdiscrete();\n\n\tstatic int f[MAXN + 5][MAXN + 5] = {0};\n\n\tf[0][0] = 1;\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\tf[i][0] = f[i - 1][0] * 2 % MOD;\n\t\tfor(int j = a[i] + 1; j <= a[i - 1]; ++j) (f[i][0] += f[i - 1][j] * 2 % MOD) %= MOD;\n\n\t\tint coef = a[i] <= a[i - 1] ? 1 : fpm(2, val[a[i]] - val[a[i - 1]]);\n\t\tfor(int j = min(a[i], a[i - 1]); j; --j) f[i][j] = (LL) f[i - 1][j] * coef % MOD;\n\n\t\tfor(int j = a[i - 1] + 1; j <= a[i]; ++j)\n\t\t{\n\t\t\tcoef = (j == 1 ? fpm(2, val[j]) - 2 : fpm(2, val[j] - val[j - 1] + 1) - 2) % MOD;\n\t\t\t(f[i][j] += (LL) f[i - 1][0] * coef % MOD * fpm(2, val[a[i]] - val[j]) % MOD) %= MOD;\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor(int i = 0; i <= a[n]; ++i) (ans += f[n][i]) %= MOD;\n\tprintf(\"%d\\n\", (ans + MOD) % MOD);\n}\n\nint main()\n{\n\tinput();\n\tsolve();\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing i64 = long long;\n\nconst i64 MOD = 1000000007;\ni64 pow(i64 a, i64 k) {\n\ti64 t = 1;\n\tfor (; k; a = a * a % MOD, k >>= 1) if (k & 1) t = t * a % MOD;\n\treturn t;\n}\n\nconst int INF = int(MOD);\nconst int N = 100000 + 7;\n\nint n;\nint a[N];\n\nstruct seg {\n\tint low[N << 2];\n\tvoid build(int p, int l, int r) {\n\t\tif (l == r)\n\t\t\tlow[p] = a[l];\n\t\telse\n\t\t\tbuild(p << 1, l, l + r >> 1), build(p << 1 | 1, (l + r >> 1) + 1, r),\n\t\t\tlow[p] = std::min(low[p << 1], low[p << 1 | 1]);\n\t}\n\tint getmin(int p, int l, int r, int x, int y) {\n\t\tif (x <= l && r <= y) return low[p];\n\t\tint m = l + r >> 1, u = INF, v = INF;\n\t\tif (x <= m) u = getmin(p << 1, l, m, x, y);\n\t\tif (y > m) v = getmin(p << 1 | 1, m + 1, r, x, y);\n\t\treturn std::min(u, v);\n\t}\n\tvoid arr(int p, int l, int r, int x, int y, int k, std::vector<int>& z) {\n\t\tif (low[p] > k) return;\n\t\tif (l == r) return void(z.push_back(l));\n\t\tint m = l + r >> 1;\n\t\tif (x <= m) arr(p << 1, l, m, x, y, k, z);\n\t\tif (y > m) arr(p << 1 | 1, m + 1, r, x, y, k, z);\n\t}\n} seg;\n\nint ct;\nint l[N], r[N], h[N];\nstd::vector<int> kid[N];\nint build(int u, int v, int q) {\n\tint p = ++ct;\n\tl[p] = u, r[p] = v, h[p] = q;\n\tif (u == v) return p;\n\tstd::vector<int> z;\n\tint w = seg.getmin(1, 1, n, u, v);\n\tz.push_back(u - 1), seg.arr(1, 1, n, u, v, w, z), z.push_back(v + 1);\n\tfor (int i = 1, j; i < z.size(); ++i)\n\t\tif (z[i - 1] + 1 <= z[i] - 1)\n\t\t\tkid[p].push_back(build(z[i - 1] + 1, z[i] - 1, w));\n  return p;\n}\n\ni64 dp[N][2];\nvoid solve(int p) {\n\tint w = r[p] - l[p] + 1;\n\tfor (auto t : kid[p]) solve(t), w -= r[t] - l[t] + 1;\n\tdp[p][0] = pow(2, w), dp[p][1] = 1;\n\tw = a[l[p]];\n\tfor (auto t : kid[p])\n\t\t( dp[p][0] *= dp[t][0] + 2 * dp[t][1] ) %= MOD,\n\t\t( dp[p][1] *= dp[t][1] ) %= MOD,\n\t\tw = std::min(w, h[t]);\n\t( dp[p][0] -= dp[p][1] * 2 ) %= MOD;\n\t( dp[p][1] *= pow(2, w - h[p]) ) %= MOD;\n}\n\nint main() {\n//\tfreopen(\"code.in\", \"r\", stdin);\n//\tfreopen(\"code.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i)\n\t\tscanf(\"%lld\", a + i);\n\tif (n == 1) return printf(\"%lld\", pow(2, a[1])), 0;\n\tseg.build(1, 1, n);\n\tint rt = build(1, n, 0);\n\tsolve(rt);\n\tprintf(\"%lld\", (dp[rt][0] + dp[rt][1] + MOD * 3) % MOD);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mod 1000000007\n#define N 111\nusing namespace std;\n#define LL long long\nLL fpow(LL x,int k){\n\tLL ans=1;\n\twhile (k){\n\t\tif (k&1) ans=ans*x%mod;\n\t\tx=x*x%mod;\n\t\tk>>=1;\n\t}\n\treturn ans;\n} \nvector <int> son[N];\nint len[N],siz[N],f[N],g[N],num[N],stk[N],id[N];\n\nvoid dfs(int x) {\n\tint ans=1,s=siz[x];\n\tf[x]=1;g[x]=0;\n\tfor (int i=0;i<son[x].size();i++){\n\t\tint u=son[x][i];\n\t\tdfs(u);\n\t\tg[x]=((LL)g[x]*(f[u]+g[u])+(LL)f[x]*g[u])%mod;\n\t\tf[x]=(LL)f[x]*f[u]%mod;\n\t\ts-=siz[u];\n\t}\n\tg[x]=((LL)g[x]*fpow(2LL,s)%mod+(LL)f[x]*(fpow(2LL,s)-1+mod))%mod;\n\tf[x]=(LL)f[x]*fpow(2LL,len[x])%mod;\n} \nint solve(int l,int r){\n\tint cnt=0,top=0;\n\tstk[0]=l-1;\n\tfor (int i=l;i<=r;i++){\n\t\twhile (top&&num[stk[top]]>=num[i])\n\t\tif (num[i]==num[stk[top]]){\n\t\t\tstk[top]=i;break;\n\t\t}else if (num[i]>num[stk[top-1]]) {\n\t\t\tint v=++cnt;\n\t\t\tson[v].clear();\n\t\t\tson[v].push_back(id[top]);\n\t\t\tlen[id[top]]=num[stk[top]]-num[i];\n\t\t\tsiz[id[top]]=i-stk[top-1]-2;\n\t\t\tstk[top]=i;id[top]=v;\n\t\t\tbreak;\n\t\t}else{\n\t\t\tlen[id[top]]=num[stk[top]]-num[stk[top-1]];\n\t\t\tsiz[id[top]]=i-stk[top-1]-2;\n\t\t\tson[id[top-1]].push_back(id[top]);\n\t\t\ttop--;\n\t\t}\n\t\tif (stk[top]!=i){\n\t\t\tint v=++cnt;\n\t\t\tstk[++top]=i;id[top]=v;\n\t\t\tson[v].clear();\n\t\t}\n\t}\n\twhile (top){\n\t\tlen[id[top]]=num[stk[top]]-num[stk[top-1]];\n\t\tsiz[id[top]]=r-stk[top-1]-1;\n\t\tif (top>1) son[id[top-1]].push_back(id[top]);\n\t\ttop--;\n\t}\n\tdfs(id[1]);\n\treturn (f[id[1]]+g[id[1]])%mod;\n}\nint read(){\n\tint x=0,f=1;\n\tchar ch=getchar();\n\twhile (ch<'0' || ch>'9'){\n\t\tif (ch=='-') f=-1;\n\t\tch=getchar();\n\t}\n\twhile (ch>='0' && ch<='9'){\n\t\tx=x*10+ch-'0';ch=getchar();\n\t}\n\treturn x*f;\n}\nint main(){\n\tint n=read();\n\tfor (int i=1;i<=n;i++) num[i]=read()-1;\n\tint ans=1;\n\tfor (int i=1;i<=n;i++){\n\t\tif (!num[i] || !num[i-1]) ans=ans*2LL%mod;\n\t\tif (num[i] && !num[i+1]){\n\t\t\tint l=i;\n\t\t\twhile (num[l-1]) l--;\n\t\t\tans=ans*solve(l,i)%mod; \n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define ll long long\n\nconst ll mod = 1000000007;\nconst ll maxN = 111;\n\nll n, i, j, h[maxN], act, bef;\nvector<ll> ord;\nll dp[maxN][maxN];\n\nll poww(ll a, ll b) {\n    ll ans = 1;\n    while (b > 0) {\n        if (b & 1) ans = (ans * a) % mod;\n        b >>= 1;\n        a = (a * a) % mod;\n    }\n    return ans;\n}\n\nint get_id(int x) {\n    return lower_bound(ord.begin(), ord.end(), x) - ord.begin();\n}\n\nint main()\n{\n  //  freopen(\"test.in\",\"r\",stdin);\n\n    scanf(\"%lld\", &n);\n    for (i = 1; i <= n; i++) scanf(\"%lld\", &h[i]), ord.pb(h[i]);\n\n    ord.pb(0);\n    sort(ord.begin(), ord.end());\n    ord.resize(unique(ord.begin(), ord.end()) - ord.begin());\n\n    dp[1][0] = 2; //! doua colorari variabile\n\n    //! initializeaza\n    act = get_id(h[1]);\n    dp[1][1] = ((poww(2, ord[1]) + mod - 2) * poww(2, h[1] - ord[1])) % mod;\n\n    for (i = 2; i <= act; i++) {\n        dp[1][i] = ((poww(2, ord[i] - ord[i - 1]) + mod - 1) * 2LL) % mod;\n        dp[1][i] = (dp[1][i] * poww(2, h[1] - ord[i])) % mod;\n    }\n\n    //! rezolva\n    for (i = 2; i <= n; i++) {\n        bef = get_id(h[i - 1]);\n        act = get_id(h[i]);\n\n        if (h[i] == 1) {\n            for (j = 0; j <= bef; j++)\n                dp[i][0] = (dp[i][0] + dp[i - 1][j]) % mod;\n            dp[i][0] = (dp[i][0] * 2LL) % mod;\n            continue;\n        }\n\n        if (h[i - 1] <= h[i]) {\n            //! creste nebunia\n            for (j = 1; j <= bef; j++) {\n                dp[i][j] = (dp[i - 1][j] * poww(2, h[i] - ord[bef])) % mod;\n            }\n\n            dp[i][0] = (dp[i - 1][0] * 2) % mod;\n            for (j = bef + 1; j <= act; j++) {\n                dp[i][j] = (dp[i - 1][0] * ( poww(2, ord[j] - ord[j - 1]) + mod - 1 )) % mod;\n                dp[i][j] = (dp[i][j] * poww(2, h[i] - ord[j])) % mod;\n                dp[i][j] = (dp[i][j] * 2) % mod;\n            }\n        } else {\n            dp[i][0] = (dp[i - 1][0] * 2) % mod;\n\n            for (j = 1; j <= act; j++)\n                dp[i][j] = dp[i - 1][j];\n            for (j = act + 1; j <= bef; j++)\n                dp[i][0] = (dp[i][0] + dp[i - 1][j] * 2LL) % mod;\n        }\n    }\n\n    ll ans = 0;\n    act = get_id(h[n]);\n    for (i = 0; i <= act; i++) ans = (ans + dp[n][i]) % mod;\n\n    printf(\"%lld\", ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = int64_t;\nusing ull = uint64_t;\nusing ld = long double;\n\nconst ll MOD = 1000 * 1000 * 1000 + 7;\nconst ll INV2 = (MOD + 1) / 2;\n\nll pw(ll x, ll y) {\n    if (y == 0) {\n        return 1;\n    } else if (y % 2 == 0) {\n        return pw(x * x % MOD, y / 2);\n    } else {\n        return pw(x, y - 1) * x % MOD;\n    }\n}\n\npair<ll, ll> solve(const vector<ll>& a) {\n    if (a.size() == 1) {\n        return {pw(2, a[0]), 0};\n    } else {\n        int mn = a[0];\n        for (int x : a) {\n            mn = min(mn, x);\n        }\n        bool eq = true;\n        for (int x : a) {\n            if (mn != x) {\n                eq = false;\n            }\n        }\n        if (eq) {\n            ll fr = pw(2, a.size());\n            return {pw(2, a[0]), (fr + MOD - 2) % MOD};\n        }\n        vector<pair<ll, ll> > segs;\n        int ptr = 0;\n        while (ptr < a.size()) {\n            if (a[ptr] == mn) {\n                int go = ptr;\n                while (go < a.size() && a[go] == a[ptr]) {\n                    go++;\n                }\n                ll tot = pw(2, go - ptr);\n                segs.emplace_back(2, (tot + MOD - 2) % MOD);\n                ptr = go;\n            } else {\n                int go = ptr;\n                vector<ll> td;\n                while (go < a.size() && a[go] > mn) {\n                    td.push_back(a[go] - mn + 1);\n                    go++;\n                }\n                segs.push_back(solve(td));\n                ptr = go;\n            }\n        }\n\n        ll tot = 1;\n        for (const auto& x : segs) {\n            tot = (tot * (x.first + x.second)) % MOD;\n        }\n        ll good = 1;\n        for (const auto& x : segs) {\n            ll cur = (x.first * INV2) % MOD;\n            good = (good * cur) % MOD;\n        }\n        good = (good * 2) % MOD;\n        ll bad = (tot + MOD - good) % MOD;\n        return {good * pw(2, mn - 1) % MOD, bad};\n    }\n}\nint main() {\n#ifdef BZ\n    freopen(\"input.txt\", \"r\", stdin);\n#endif\n    ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n    int n;\n    cin >> n;\n    vector<ll> a(n);\n    for (ll& x : a) {\n        cin >> x;\n    }\n    auto res = solve(a);\n    cout << (res.first + res.second) % MOD << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#include <string.h>\n//#include <unordered_set>\n//#include <unordered_map>\n//#include <bits/stdc++.h>\n\n#define MP(A,B) make_pair(A,B)\n#define PB(A) push_back(A)\n#define SIZE(A) ((int)A.size())\n#define LEN(A) ((int)A.length())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define fi first\n#define se second\n\nusing namespace std;\n\ntemplate<typename T>inline bool upmin(T &x,T y) { return y<x?x=y,1:0; }\ntemplate<typename T>inline bool upmax(T &x,T y) { return x<y?x=y,1:0; }\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double lod;\ntypedef pair<int,int> PR;\ntypedef vector<int> VI;\n\nconst lod eps=1e-11;\nconst lod pi=acos(-1);\nconst int oo=1<<30;\nconst ll loo=1ll<<62;\nconst int mods=1e9+7;\nconst int MAXN=205;\nconst int INF=0x3f3f3f3f;//1061109567\n/*--------------------------------------------------------------------*/\ninline int read()\n{\n\tint f=1,x=0; char c=getchar();\n\twhile (c<'0'||c>'9') { if (c=='-') f=-1; c=getchar(); }\n\twhile (c>='0'&&c<='9') { x=(x<<3)+(x<<1)+(c^48); c=getchar(); }\n\treturn x*f;\n}\nvector<PR> e[MAXN];\nint a[MAXN],f[MAXN][MAXN],g[MAXN][MAXN],b[MAXN];\nint upd(int x,int y){ return x+y>=mods?x+y-mods:x+y; }\nint quick_pow(int x,int y)\n{\n\tint ret=1;\n\tfor (;y;y>>=1)\n\t{\n\t\tif (y&1) ret=1ll*ret*x%mods;\n\t\tx=1ll*x*x%mods;\n\t}\n\treturn ret;\n}\nint main()\n{\n\tint n=read();\n\tfor (int i=1;i<=n;i++) a[i]=b[i]=read();\n\tsort(b+1,b+n+1);\n\tfor (int i=1,lst=0;i<=n;i++)\n\t{\n\t\tb[i]--;\n\t\tif (b[i]!=b[i-1]) \n\t\t{\n\t\t\tint id=-1;\n\t\t\tfor (int j=1;j<=n;j++)\n\t\t\t\tif (a[j]-1>=b[i]&&a[j-1]-1<b[i]) id=j;\n\t\t\t\telse if (a[j-1]-1>=b[i]&&a[j]-1<b[i]) e[j-1].PB(MP(id,b[i]-lst)),id=-1;\n\t\t\tif (id>0) e[n].PB(MP(id,b[i]-lst));\n\t\t\tlst=b[i];\n\t\t}\n\t}\n//\tfor (int i=1;i<=n;i++)\n//\t\tfor (auto k:e[i]) cout<<k.fi<<\" \"<<i<<\":\"<<k.se<<endl;\n\tf[0][0]=2;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=0;j<=i-1;j++) f[i][1]=upd(f[i][1],f[i-1][j]);\n\t\tfor (auto k:e[i]) \n\t\t\tif (k.fi==i) f[i][1]=1ll*f[i][1]*quick_pow(2,k.se)%mods;\n\t\tfor (int j=2;j<=i;j++)\n\t\t{\n\t\t\tf[i][j]=upd(f[i][j],f[i-1][j-1]);\n\t\t\tfor (auto k:e[i])\n\t\t\t\tif (k.fi>=i-j+1) f[i][j]=1ll*f[i][j]*quick_pow(2,k.se)%mods;\n\t\t}\n//\t\tcout<<i<<\":\";\n//\t\tll sum=0;\n//\t\tfor (int j=0;j<=i;j++) cout<<f[i][j]<<\" \",sum+=f[i][j];\n//\t\tcout<<sum<<endl;\n\t}\n\tint ans=0;\n\tfor (int i=1;i<=n;i++) ans=upd(ans,f[n][i]);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast,no-stack-protector\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\")\n//#pragma GCC target(\"avx,tune=native\")\n#include<bits/stdc++.h>\n//#include<ext/pb_ds/assoc_container.hpp>\nusing namespace std;\n//using namespace __gnu_pbds;\nconst int inf=0x3f3f3f3f;\nconst double eps=1e-6;\nconst int mod=1000000007;\ntypedef long long ll;\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\ntemplate<int MOD>struct modint{\n\tint value=0;\n\tmodint(int x=0){value=x;}\n\tinline int mypow(int x,int y){\n\t\tint a=x,ret=1;\n\t\tdo{\n\t\t\tif(y&1)ret=(ll)ret*a%mod;\n\t\t\ta=(ll)a*a%mod;\n\t\t}while(y>>=1);\n\t}\n\t#define inv(x) mypow(x,MOD-2)\n\tmodint operator+(modint<MOD> x){\n\t\tvalue=value+x.value;\n\t\tif(value>=MOD)value-=MOD;\n\t\treturn *this;\n\t}\n\tmodint operator+(int x){\n\t\tvalue=value+x;\n\t\tif(value>=MOD)value-=MOD;\n\t\treturn *this;\n\t}\n\tmodint operator-(modint<MOD> x){\n\t\tvalue-=x.value;\n\t\tif(value<0)value+=MOD;\n\t\treturn *this;\n\t}\n\tmodint operator-(int x){\n\t\tvalue-=x;\n\t\tif(value<0)value+=MOD;\n\t\treturn value;\n\t}\n\tmodint operator*(modint<MOD> x){\n\t\tvalue=(ll)value*x.value%mod;\n\t\treturn *this;\n\t}\n\tmodint operator*(int x){\n\t\tvalue=(ll)value*x%mod;\n\t\treturn *this;\n\t}\n\tmodint operator/(modint<MOD> x){\n\t\tvalue=(ll)value*inv(x.value)%mod;\n\t\treturn *this;\n\t}\n\tmodint operator/(int x){\n\t\tvalue=(ll)value*inv(x)%mod;\n\t\treturn *this;\n\t}\n\tbool operator<(modint<MOD> x){\n\t\treturn value<x.value;\n\t}\n\tbool operator==(modint<MOD> x){\n\t\treturn value==x.value;\n\t}\n\tbool operator>(modint<MOD> x){\n\t\treturn value>x.value;\n\t}\n\tbool operator<=(modint<MOD> x){\n\t\treturn value<=x.value;\n\t}\n\tbool operator>=(modint<MOD> x){\n\t\treturn value>=x.value;\n\t}\n\tbool operator<(int x){\n\t\treturn value<x;\n\t}\n\tbool operator==(int x){\n\t\treturn value==x;\n\t}\n\tbool operator>(int x){\n\t\treturn value>x;\n\t}\n\tbool operator<=(int x){\n\t\treturn value<=x;\n\t}\n\tbool operator>=(int x){\n\t\treturn value>=x;\n\t}\n};\nbool operator<(int x,modint<mod>y){\n\treturn x<y.value;\n}\nbool operator==(int x,modint<mod>y){\n\treturn x==y.value;\n}\nbool operator>(int x,modint<mod>y){\n\treturn x<y.value;\n}\nbool operator<=(int x,modint<mod>y){\n\treturn x<=y.value;\n}\nbool operator>=(int x,modint<mod>y){\n\treturn x>=y.value;\n}\n#define M modint<mod>\ninline string getstr(string &s,int l,int r){string ret=\"\";for(int i=l;i<=r;i++)ret.push_back(s[i]);return ret;}\nint modpow(int x,int y,int md=mod){if(y<=0)return 1;int ret=modpow(x,y>>1,md);ret=(ll)ret*ret%md;if(y&1)ret=(ll)ret*x%md;return ret;}\nint n;\nint h[105];\npair<M,M>operator*(pair<M,M>a,pair<M,M>b){\n\ta.first=a.first*(b.first+b.second);\n\ta.second=a.second*b.second;\n\treturn a;\n}\npair<M,M>solve(int l,int r){\n\tint low=*min_element(h+l,h+r+1);\n\tint cnt=0;\n\tfor(int i=l;i<=r;i++)h[i]-=low;\n\tfor(int i=l;i<=r;i++)if(!h[i])cnt++;\n\tint L=l,R=l;h[r+1]=0;\n\tpair<M,M>ret(M(modpow(2,cnt)),M(2));\n\tfor(int i=l;i<=r+1;i++){\n\t\tR=i-1;\n\t\tif(h[i]==0){\n\t\t\tif(L<=R)ret=ret*solve(L,R);\n\t\t\tL=i+1;\n\t\t}\n\t}\n\tret.first=ret.first-ret.second;\n\tret.second=ret.second*modpow(2,low-1);\n\tret.first=ret.first+ret.second;\n\treturn ret;\n}\nsigned main(){\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)cin>>h[i];\n\tcout<<solve(1,n).first.value<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nint w[110], n, D[110], Mod = 1000000007;\nint Pow(int a, int b) {\n\tint r = 1;\n\twhile (b) {\n\t\tif (b & 1)r = 1ll * r*a%Mod;\n\t\ta = 1ll * a*a%Mod; b >>= 1;\n\t}\n\treturn r;\n}\nint main() {\n\tint i, j, k;\n\tscanf(\"%d\", &n);\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &w[i]);\n\t}\n\tD[0] = 1;\n\tw[n + 1] = 1;\n\tfor (i = 1; i <= n + 1; i++) {\n\t\tD[i] = D[i - 1] * 2;\n\t\tfor (j = 1; j < i; j++) {\n\t\t\tint b = max(w[i], w[j - 1]), e = w[j] - 1;\n\t\t\tint s = 0;\n\t\t\tfor (k = j; k < i; k++) {\n\t\t\t\te = min(e, w[k] - 1);\n\t\t\t\ts += max(w[k + 1] - w[k], 0);\n\t\t\t}\n\t\t\tif (b <= e) {\n\t\t\t\tint t1 = Pow(2, w[j] - 1 - e);\n\t\t\t\tint t2 = Pow(2, e - b + 1) - 1;\n\t\t\t\tint t3 = Pow(2, s);\n\t\t\t\tD[i] = (D[i] + 4ll * D[j - 1] * t1 % Mod* t2%Mod * t3)%Mod;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", 1ll*D[n + 1]*((Mod+1)/2)%Mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=(a); i<=(b); i++)\n#define per(i,a,b) for (register int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ninline void read(int &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 1555,mo=1e9+7,inv2=(mo+1)/2;\nint n,a[N],cnt;ll f[N],g[N],h[N];\nll power(ll a, ll n){\n\tll res=1;\n\twhile(n){\n\t\tif(n&1)res=1LL*res*a%mo;a=1LL*a*a%mo;n>>=1;\n\t}\n\treturn res;\n}\nint solve(int l, int r, int d){\n\tint k=++cnt,mn=2e9;rep(i,l,r)mn=min(mn,a[i]);\n\tVi ch;int tot=0;rep(i,l,r)tot+=(a[i]==mn);\n\trep(i,l,r)if(a[i]>mn){\n\t\tint j;for(j=i;j<=r;j++)if(a[j]<=mn)break;\n\t\tch.pb(solve(i,j-1,mn+1));i=j-1;\n\t}\n\th[k]=mn-d+1;rep(i,0,SZ(ch)-1)h[k]+=h[ch[i]];\n\tg[k]=power(2,h[k]);\n\tint x=power(2,tot),y=2;\n\trep(i,0,SZ(ch)-1)x=1LL*x*(f[ch[i]]+g[ch[i]]*2LL)%mo,y=1LL*y*g[ch[i]]%mo;\n\tf[k]=(x-y+mo)%mo;\n//\tprintf(\"%d %d %d:%d %d %d\\n\",l,r,d,f[k],g[k],h[k]);\n\treturn k;\n}\nint main() {\n\tread(n);rep(i,1,n)read(a[i]);int rt=solve(1,n,1);\n\tprintf(\"%lld\",(f[rt]+g[rt])%mo);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#define dibs reserve\n#define OVER9000 1234567890\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) (((x) < 0)?-(x):(x))\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\nusing cat = long long;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\nclass HistTree {\n\ttypedef struct {\n\t\tcat h;\n\t\tint l, r, zero;\n\t\tvector<int> son;\n\t} node;\n\n\tconstexpr static cat mod = 1000000007;\n\n\tint N;\n\tvector<cat> H;\n\tvector<node> T;\n\n\tvoid Build(int l, int r, cat h) {\n\t\tcat minh = H[l];\n\t\tfor(int i = l; i < r; i++) minh = min(minh, H[i]);\n\t\tT.push_back({minh-h, l, r, 0, vector<int>()});\n\t\tint l_higher = r, id = T.size()-1;\n\t\tfor(int i = l; i <= r; i++) {\n\t\t\tif(i < r && H[i] != minh) {\n\t\t\t\tif(l_higher == r) l_higher = i;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(i < r) T[id].zero++;\n\t\t\tif(l_higher == r) continue;\n\t\t\tT[id].son.push_back(T.size());\n\t\t\tBuild(l_higher, i, minh);\n\t\t\tl_higher = r;\n\t\t}\n\t}\n\n\tcat pw(cat a, cat e) {\n\t\tif(e <= 0) return 1;\n\t\tcat x = pw(a, e/2);\n\t\tx = x * x % mod;\n\t\tif(e&1) x = x * a % mod;\n\t\treturn x;\n\t}\n\npublic:\n\tHistTree(const vector<cat> & H) : N(H.size()), H(H) {\n\t\tBuild(0, N, 0);\n\t}\n\n\tpair<cat, cat> Solve(int node_id = 0) {\n\t\t// returns: (all, with horizontally alternating bottom)\n\t\tnode & n = T[node_id];\n\t\tvector< pair<cat, cat> > son_ans;\n\t\tALL_THE(n.son, it) son_ans.push_back(Solve(*it));\n\t\t// vertically alternating\n\t\tcat cnt_valt = 1;\n\t\tALL_THE(son_ans, it) cnt_valt = cnt_valt * (it->ff + 2 * it->ss) % mod;\n\t\tfor(int i = 0; i < n.zero; i++) cnt_valt = cnt_valt * 2 % mod;\n\t\t// horizontally alternating\n\t\tpair<cat, cat> ret = {cnt_valt, 0};\n\t\tcat cnt_halt = 1;\n\t\tALL_THE(son_ans, it) cnt_halt = cnt_halt * 2 * it->ss % mod;\n\t\tret.ff = (ret.ff + (pw(2, n.h) - 2) * cnt_halt) % mod;\n\t\tif(ret.ff < 0) ret.ff += mod;\n\t\tret.ss = cnt_halt * pw(2, n.h-1) % mod;\n\t\treturn ret;\n\t}\n};\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\tint N;\n\tcin >> N;\n\tvector<cat> H(N);\n\tfor(int i = 0; i < N; i++) cin >> H[i];\n\tHistTree T(H);\n\tcout << T.Solve().ff << \"\\n\";\n\treturn 0;\n}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 105\n\nusing namespace std;\n\nconst int mod = 1e9 + 7;\n\nint n, tot;\nint h[N], H[N], f[N][2];\n\ninline int fpm(int x, int y) {\n\tint res = 1;\n\twhile(y) {\n\t\tif(y & 1) res = 1LL * x * res % mod;\n\t\tx = 1LL * x * x % mod, y >>= 1;\n\t}\n\treturn res;\n}\n\nvoid solve(int u, int l, int r) {\n\tbool flag = false;\n\tH[u] = h[r];\n\tfor(int i = l; i < r; ++i)\n\t\tif(h[i] != h[i + 1]) {\n\t\t\tH[u] = min(H[u], h[i]);\n\t\t\tflag = true;\n\t\t}\n\t\n\tif(!flag) {\n\t\tf[u][0] = fpm(2, r - l + 1) - 2;\n\t\tf[u][1] = fpm(2, H[u]);\n\t\treturn;\n\t}\n\t\n\tf[u][0] = 1, f[u][1] = 2;\n\tfor(int i = l; i <= r; ++i) {\n\t\th[i] -= H[u];\n\t\tif(!h[i])\n\t\t\tf[u][0] = (f[u][0] + f[u][0]) % mod;\n\t}\n\t\n\tint las = 1;\n\tfor(int i = l; i <= r; ++i) {\n\t\tif(h[i - 1] == 0 && h[i] != 0) las = i;\n\t\tif(h[i] != 0 && h[i + 1] == 0) {\n\t\t\tint v = ++tot;\n\t\t\tsolve(v, las, i);\n\t\t\tf[u][0] = f[u][0] * (f[v][0] + 2LL * f[v][1]) % mod;\n\t\t\tf[u][1] = 1LL * f[u][1] * f[v][1] % mod;\n\t\t}\n\t}\n\t\n\tf[u][0] = (f[u][0] - f[u][1] + mod) % mod;\n\tf[u][1] = 1LL * f[u][1] * fpm(2, H[u] - 1);\n\t\n//\tcerr << l << ' ' << r << ' ' << H[u] << ' ' << f[u][0] << ' ' << f[u][1] << endl;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i <= n; ++i)\n\t\tscanf(\"%d\", &h[i]);\n\t\n\tsolve(0, 1, n);\n\t\n\tint ans = (f[0][0] + f[0][1]) % mod;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author majk\n */\n\n#ifndef MAJK_LIB\n#define MAJK_LIB\n\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <fstream>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <algorithm>\n#include <numeric>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <array>\n#include <bitset>\nusing namespace std;\n\n#define x first\n#define y second\ntypedef std::pair<int,int> pii; typedef long long ll; typedef unsigned long long ull; typedef unsigned int ui; typedef pair<ui,ui> puu;\n\ntemplate <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate <typename T, typename U> std::ostream&operator<<(std::ostream&o, const pair<T,U>&p) {o << p.x << ' ' << p.y; return o;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {if(t.empty())o<<'\\n';for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\nui logceil(ll x) { return x?8*sizeof(ll)-__builtin_clzll(x):0; }\n\nnamespace std { template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}}; }\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename F> double bshd(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){l=m;}else{h=m;}}return (l+h)/2;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename F> double bsld(double l,double h,const F&f){ui r=200;while(r--){double m=(l+h)/2;if(f(m)){h=m;}else{l=m;}}return (l+h)/2;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector2<T>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector2<T>>(a,vector2<T>(b,c,t)){}};\ntemplate<typename T>class vector4:public vector<vector3<T>>{public:vector4(){} vector4(size_t a,size_t b,size_t c,size_t d,T t=T()):vector<vector3<T>>(a,vector3<T>(b,c,d,t)){}};\ntemplate<typename T>class vector5:public vector<vector4<T>>{public:vector5(){} vector5(size_t a,size_t b,size_t c,size_t d,size_t e,T t=T()):vector<vector4<T>>(a,vector4<T>(b,c,d,e,t)){}};\n\n\n#endif\n#ifndef MOD_H\n#define MOD_H\n\n\n\ntemplate <unsigned int N> class Field {\n    typedef unsigned int ui;\n    typedef unsigned long long ull;\n\tinline ui pow(ui a, ui p){ui r=1,e=a;while(p){if(p&1){r=((ull)r*e)%N;}e=((ull)e*e)%N;p>>=1;}return r;}\n\t/*extended GCD(slow):ll t=0,nt=1,r=N,nr=a;while(nr){ll q=r/nr;t-=q*nt;swap(t,nt);r-=q*nr;swap(r,nr);}assert(r<=1);return(t<0)?t+N:t;*/\n\tinline ui inv(ui a){return pow(a,N-2);}\npublic:\n    inline Field(int x = 0) : v(x<0?N+x:x) {}\n\tinline Field<N> pow(int p){return (*this)^p; }\n\tinline Field<N> operator^(int p){return {(int)pow(v,(ui)p)};}\n    inline Field<N>&operator+=(const Field<N>&o) {if (v+o.v >= N) v += o.v - N; else v += o.v; return *this; }\n    inline Field<N>&operator-=(const Field<N>&o) {if (v<o.v) v -= o.v-N; else v-=o.v; return *this; }\n    inline Field<N>&operator*=(const Field<N>&o) {v=(ull)v*o.v % N; return *this; }\n    inline Field<N>&operator/=(const Field<N>&o) { return *this*=inv(o.v); }\n    inline Field<N> operator+(const Field<N>&o) const {Field<N>r{*this};return r+=o;}\n    inline Field<N> operator-(const Field<N>&o) const {Field<N>r{*this};return r-=o;}\n    inline Field<N> operator*(const Field<N>&o) const {Field<N>r{*this};return r*=o;}\n    inline Field<N> operator/(const Field<N>&o) const {Field<N>r{*this};return r/=o;}\n    inline Field<N> operator-() {if(v) return {(int)(N-v)}; else return {0};};\n    inline Field<N>& operator++() { ++v; if (v==N) v=0; return *this; }\n    inline Field<N> operator++(int) { Field<N>r{*this}; ++*this; return r; }\n    inline Field<N>& operator--() { --v; if (v==-1) v=N-1; return *this; }\n    inline Field<N> operator--(int) { Field<N>r{*this}; --*this; return r; }\n    inline bool operator==(const Field<N>&o) const { return o.v==v; }\n\tinline bool operator!=(const Field<N>&o) const { return o.v!=v; }\n\tinline explicit operator ui() const { return v; }\n\tinline static vector<Field<N>>fact(int t){vector<Field<N>>F(t+1,1);for(int i=2;i<=t;++i){F[i]=F[i-1]*i;}return F;}\n\tinline static vector<Field<N>>invfact(int t){vector<Field<N>>F(t+1,1);Field<N> X{1};for(int i=2;i<=t;++i){X=X*i;}F[t]=1/X;for(int i=t-1;i>=2;--i){F[i]=F[i+1]*(i+1);}return F;}\nprivate: ui v;\n};\ntemplate<unsigned int N>istream &operator>>(std::istream&is,Field<N>&f){unsigned int v;is>>v;f=v;return is;}\ntemplate<unsigned int N>ostream &operator<<(std::ostream&os,const Field<N>&f){return os<<(unsigned int)f;}\ntemplate<unsigned int N>Field<N> operator+(int i,const Field<N>&f){return Field<N>(i)+f;}\ntemplate<unsigned int N>Field<N> operator-(int i,const Field<N>&f){return Field<N>(i)-f;}\ntemplate<unsigned int N>Field<N> operator*(int i,const Field<N>&f){return Field<N>(i)*f;}\ntemplate<unsigned int N>Field<N> operator/(int i,const Field<N>&f){return Field<N>(i)/f;}\n\n\ntypedef Field<1000000007> FieldMod;\n\nstruct Ring {\n\ttemplate <typename T>\n\tstatic T div(T p, T q, T N) {\n\t\tT t=0,nt=1,r=N,nr=q;\n\t\twhile(nr!=0){ T q=r/nr;t-=q*nt;r-=q*nr;swap(t,nt);swap(r,nr); }\n\t\tt=(t<0)?t+N:t;\n\t\tr=(r<0)?r+N:r;\n\t\tif (gcd(p,N)%r!=0) { return 0; }\n\t\treturn (t*p/r)%N;\n\t}\n};\n#endif\n\n\nclass DHistogramColoring {\npublic:\n    int brr(vector<vector<int>> &Z, const vector<int> &A, int I, int J) {\n        while (I < A.size() && A[I] == J) { I++; J = 0; }\n        if (I == A.size()) return 1;\n        int ans = 0;\n        if (I != 0 && A[I-1] > J && J > 0) {\n            Z[I][J] = 0;\n            if (Z[I-1][J-1] + Z[I-1][J] + Z[I][J-1] + Z[I][J] == 2) ans += brr(Z, A, I, J+1);\n            Z[I][J] = 1;\n            if (Z[I-1][J-1] + Z[I-1][J] + Z[I][J-1] + Z[I][J] == 2) ans += brr(Z, A, I, J+1);\n        } else {\n\n            Z[I][J] = 0;\n            ans += brr(Z, A, I, J+1);\n            Z[I][J] = 1;\n            ans += brr(Z, A, I, J+1);\n        }\n        return ans;\n    }\n\n    int brute(vector<int> A) {\n        int N = A.size();\n        vector<vector<int>> Z(N);\n        for (int i = 0; i < N; ++i) {\n            Z[i].resize(A[i]);\n        }\n        return brr(Z, A, 0, 0);\n    }\n\n    FieldMod solve(vector<int> A) {\n        int N = A.size();\n        vector<FieldMod> D(N+1, 0);\n        D[0] = 1;\n        for (int i = 0; i <= N; ++i) {\n//            if (A[i] > 0 && (i == 0 || A[i-1] == 0)) D[i] *= 2;\n            for (int j = i+1; j <= N; ++j) {\n                int mx = 0;\n                ll choices = 0; //i == 0 ? (j == N ? A[i] : 1) : max(0, A[i]-A[i-1]);\n                int lo = A[i];\n                for (int k = i; k < j; ++k) {\n                    choices += max(0, A[k] - (k==i?0:A[k-1]));\n                    lo = min(lo, A[k]);\n                }\n\n//                cerr << i << ' ' << j << ' ' << choices << endl;\n                if (i != 0 && j != N) {\n                    choices -= min(A[i-1], A[i]);\n                    choices -= min(A[j-1], A[j]);\n                    choices += min(lo, min(A[i-1],A[j]));\n                } else if (i == 0 && j != N) {\n                    choices -= min(A[j-1], A[j]);\n                    choices++;\n                } else if (i == 0 && j == N) {\n                    // ok\n                } else {\n                    choices -= min(A[i-1], A[i]);\n                }\n\n//                cerr << i << ' ' << j << ' ' << choices << endl;\n                D[j] += D[i] * FieldMod{2}.pow(choices % (1000000006));\n            }\n        }\n        cerr << D;\n        return D[N];\n    }\n\n    void solve(istream& cin, ostream& cout) {\n        int N; cin >> N;\n        vector<int> A(N); cin >> A;\n//        cout << brute(A) << endl;\n        if (N == 1) {\n            cout << FieldMod{2}.pow(A[0]) << endl;\n            return;\n        }\n\n        FieldMod mul = 1;\n        if (A[0] > A[1]) {\n            mul *= FieldMod{2}.pow(A[0]-A[1]);\n            A[0] = A[1];\n        }\n        if (A[N-1] > A[N-2]) {\n            mul *= FieldMod{2}.pow(A[N-1]-A[N-2]);\n            A[N-1] = A[N-2];\n        }\n\n        for (int i = 1; i < N-1; ++i) {\n            if (A[i] > max(A[i-1], A[i+1])) {\n                mul *= FieldMod{2}.pow(A[i]-max(A[i-1], A[i+1]));\n                A[i] = max(A[i-1], A[i+1]);\n            }\n        }\n\n        for (int i = 0; i < N; ++i) {\n            if (A[i] == 1) {\n                A[i] = 0;\n                mul *= 2;\n            }\n        }\n\n        vector<int> B;\n        FieldMod ans = 1;\n        for (int i = 0; i < N; ++i) {\n            if (A[i] == 0 && !B.empty()) {\n                ans *= solve(B);\n                B.clear();\n            } else {\n                B.push_back(A[i]);\n            }\n        }\n\n        if (!B.empty()) {\n            ans *= solve(B);\n        }\n        cout << ans * mul << '\\n';\n    }\n};\n\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tDHistogramColoring solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i, j, k) for(int i=(j); i<=(k); i++)\n#define FFOR(i, j, k) for(int i=(j); i<(k); i++)\n#define DFOR(i, j, k) for(int i=(j); i>=(k); i--)\n#define bug(x) cerr<<#x<<\" = \"<<(x)<<'\\n'\n#define pb push_back\n#define mp make_pair\n#define bit(s, i) (((s)>>(i))&1LL)\n#define mask(i) ((1LL<<(i)))\n#define builtin_popcount __builtin_popcountll\n#define __builtin_popcount __builtin_popcountll\nusing ll=long long; using ld=long double;\nmt19937_64 rng(chrono::high_resolution_clock::now().time_since_epoch().count()); const ld pi=acos(0)*2;\ntemplate <typename T> inline void read(T &x){char c; bool nega=0; while((!isdigit(c=getchar()))&&(c!='-')); if(c=='-'){nega=1; c=getchar();} x=c-48; while(isdigit(c=getchar())) x=x*10+c-48; if(nega) x=-x;}\ntemplate <typename T> inline void writep(T x){if(x>9) writep(x/10); putchar(x%10+48);}\ntemplate <typename T> inline void write(T x){if(x<0){ putchar('-'); x=-x;} writep(x);}\ntemplate <typename T> inline void writeln(T x){write(x); putchar('\\n');}\ntemplate <typename CT, typename T> inline void reset_container(CT &c, int sz, T v){c.resize(sz); for(auto &x: c) x=v;}\n#define taskname \"agc026_d\"\nint n;\nint h[101];\nconst ll base=1000000007;\nll power(ll a, ll b){\n    if(b==0) return 1;\n    ll t=power(a, b/2);\n    t=(t*t)%base;\n    if(b%2) t=(t*a)%base;\n    return t;\n}\nint minpos[101][101];\nbool doneg[101][101][101];\nll g[101][101][101];\nll G(int l, int r, int low){\n    if(l>r) return 1;\n    ///calculate from l to r, above low\n    if(doneg[l][r][low]) return g[l][r][low];\n    doneg[l][r][low]=1;\n    int x=minpos[l][r];\n    return g[l][r][low]=((G(l, x-1, (h[x]>h[low])?x:low)*G(x+1, r, (h[x]>h[low])?x:low))%base*power(2, max(0, h[x]-h[low])))%base;\n}\nbool done[101][101];\nll f[101][101];\nll F(int l, int low){\n    if(done[l][low]) return f[l][low];\n    done[l][low]=1;\n    int aff[101];\n    aff[l]=low;\n    FOR(i, l+1, n) aff[i]=(h[i]<h[aff[i-1]])?i:aff[i-1];\n    FOR(i, l+1, n){\n        int aff2[101];\n        ll cnt=1;\n        FOR(x, l, i) aff2[x]=aff[x];\n        int now=i;\n        DFOR(j, i, l){\n            if(h[j]<h[now]) now=j;\n            if(h[aff2[j]]<h[now]) aff2[j]=now;\n        }\n        FOR(j, l, i){\n            int k=j;\n            while((k<i-1)&&(aff2[k+1]==aff2[j])) k++;\n            cnt=(cnt*G(j, k, aff2[j]))%base;\n            j=k;\n        }\n        if(h[i]>h[i-1]){\n            f[l][low]+=(cnt*F(i, i-1))%base;\n        }\n        else{\n            f[l][low]+=(cnt*F(i, i))%base;\n        }\n    }\n    ll cnt=1;\n    FOR(j, l, n){\n        int k=j;\n        while((k<n)&&(aff[k+1]==aff[j])) k++;\n        cnt=(cnt*G(j, k, aff[j]))%base;\n        j=k;\n    }\n    f[l][low]+=cnt;\n    f[l][low]%=base;\n    return f[l][low];\n}\nint main(){\n    #ifdef Aria\n        if(fopen(taskname\".in\", \"r\"))\n            freopen(taskname\".in\", \"r\", stdin);\n    #endif // Aria\n    read(n);\n    FOR(i, 1, n) read(h[i]);\n    FOR(l, 1, n) FOR(r, l, n) minpos[l][r]=min_element(h+l, h+r+1)-h;\n    h[0]=1;\n    writeln((F(1, 0)*2)%base);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MOD = 1000000007;\n\ntypedef pair<long long, long long> pll;\nlong long modpow(long long a, long long n, long long mod) {\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\nint N;\nvector<long long> H;\n\n// first: all, second: oxoxoxoxox\npll rec(int left, int right) {\n    long long resall = 0, resalt = 0;\n\n    // height\n    long long height = 1LL<<60;\n    for (int i = left; i < right; ++i) if (H[i] < height) height = H[i];\n    for (int i = left; i < right; ++i) H[i] -= height;\n    vector<pll> subs;\n    int nleft = left;\n    int width = 0;\n    for (int i = left; i < right; ++i) {\n        if (H[i] == 0) {\n            if (i > nleft) subs.push_back(rec(nleft, i));\n            nleft = i+1;\n            ++width;\n        }\n    }\n    if (right > nleft) subs.push_back(rec(nleft, right));\n    \n    // second\n    long long facalt = 1;\n    for (auto p : subs) facalt *= p.second, facalt %= MOD;\n    resalt += facalt * modpow(2LL, height, MOD) % MOD;\n    resalt %= MOD;\n    \n    // first\n    resall += resalt;\n    long long fac = 1;\n    for (auto p : subs) {\n        fac *= (p.first + p.second); fac %= MOD;\n    }\n    resall += fac * modpow(2LL, width, MOD) % MOD;\n    resall += MOD - facalt * 2 % MOD;\n    resall %= MOD;\n    \n    // result\n    return pll(resall, resalt);\n}\n\nint main() {\n    cin >> N;\n    H.resize(N); for (int i = 0; i < N; ++i) cin >> H[i];\n    pll res = rec(0, N);\n    cout << res.first << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\n#define LL long long\n#define fgx cerr<<\"--------------\"<<endl;\n#define dgx cerr<<\"==============\"<<endl;\n\ninline int read(){\n\tint x=0,f=1;char c=getchar();\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0';\n\treturn x*f;\n}\nconst int MAXN = 10010;\nconst int INF = 2147483600;\nconst LL Mod = 1000000007LL;\n\nint N; int a[MAXN+1]; \n\nint f[19][MAXN+1],g[19][MAXN+1],Log2[MAXN+1],mn;\ninline LL Pow(LL a,LL b){\n\tLL ret=1; for(;b;b>>=1,a=a*a%Mod) if(b&1) ret=ret*a%Mod; return ret;\n}\ninline int qry(int l,int r){\n\tint x=Log2[r-l+1]; mn=min(f[x][l],f[x][r-(1<<x)+1]);\n\tif(f[x][l]<=f[x][r-(1<<x)+1]) return g[x][l];\n\telse return g[x][r-(1<<x)+1];\n}\ninline void Init(){\n\tfor(int i=1;i<N;i++) f[0][i]=a[i],g[0][i]=i;\n\tfor(int i=2;i<N;i++) Log2[i]=Log2[i>>1]+1;\n\tfor(int j=1;j<=15;j++){\n\t\tfor(int i=1;i+(1<<j)-1<N;i++){\n\t\t\tf[j][i]=min(f[j-1][i],f[j-1][i+(1<<(j-1))]); g[j][i]=INF;\n\t\t\tif(f[j-1][i]==f[j][i]) g[j][i]=min(g[j][i],g[j-1][i]);\n\t\t\tif(f[j-1][i+(1<<(j-1))]==f[j][i]) g[j][i]=min(g[j][i],g[j-1][i+(1<<(j-1))]); \n\t\t}\n\t}\n} int cnt; LL Len[MAXN+1],ln[MAXN+1],rn[MAXN+1],To[MAXN+1]; LL Sum[MAXN+1];\nint nxt[MAXN+1];\ninline int div(int base,int l,int r){\n\tint x=qry(l,r); int bs=mn,id=cnt+1,nx; ln[++cnt]=l; rn[cnt]=r; Sum[cnt]=bs-base; Len[cnt]=Sum[cnt];\n\tint last=l-1; while(x<=r&&x){ if(last+1<x) {nx=div(bs,last+1,x-1); Sum[id]+=Sum[nx];} last=x; x=nxt[x]; } \n\tif(last<r) nx=div(bs,last+1,r),Sum[id]+=Sum[nx];\n\tTo[id]=cnt+1;\n\treturn id;\n}\nint b[MAXN+1],pos[MAXN+1]; LL h[MAXN+1]; LL Pw2[MAXN+1];\n\nint main(){\n\t//freopen(\"a.in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tN=read(); LL anspw=0;\n\tfor(int i=1;i<=N;i++) a[i]=read();\n\tif(N==1){\n\t\tprintf(\"%lld\\n\",Pow(2,a[1])); return 0;\n\t}\n\tfor(int i=1;i<=N;i++){\n\t\tif(a[i]>a[i-1]&&a[i]>a[i+1]){\n\t\t\tint d=a[i];\n\t\t\ta[i]=max(a[i-1],a[i+1]); anspw+=d-a[i];\n\t\t}\n\t} for(int i=1;i<=N;i++) a[i]--;\n\tfor(int i=1;i<N;i++) a[i]=min(a[i],a[i+1]),b[i]=a[i];\n\tsort(b+1,b+N); int n=unique(b+1,b+N)-b-1;\n\tfor(int i=1;i<N;i++){\n\t\tint c=lower_bound(b+1,b+n+1,a[i])-b;\n\t\tnxt[pos[c]]=i; pos[c]=i;\n\t} Init(); div(0,1,N-1);\n\th[1]=1; Pw2[0]=1;\n\tfor(int i=1;i<=N;i++) Pw2[i]=Pw2[i-1]*2%Mod;\n\tln[cnt+1]=rn[cnt+1]=N;\n\tfor(int i=1;i<=cnt;i++){\n\t\tif(!To[i]) To[i]=cnt+1;\n\t\t(h[To[i]]+=h[i]*((Pow(2,Sum[i])-Pow(2,Sum[i]-Len[i])+Mod)%Mod)%Mod*Pw2[ln[To[i]]-rn[i]-1]%Mod)%=Mod;\n\t\t(h[i+1]+=h[i]*((Pw2[ln[i+1]-ln[i]]+Mod)%Mod)%Mod)%=Mod;\n\t} \tprintf(\"%lld\\n\",h[cnt+1]*Pow(2,anspw)%Mod*2%Mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\ntemplate<typename tn> void read(tn &a){\n\ttn x=0,f=1; char c=' ';\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0';\n\ta=x*f;\n}\nconst int mod = 1e9+7;\nint n,h[110],cnt,b[110];\nll f[110][110];\nll fp(ll a,ll k){\n\tll ans=1;\n\tfor(;k;k>>=1,a=a*a%mod)\n\t\tif(k&1) ans=a*ans%mod;\n\treturn ans;\n}\nint main(){\n\tread(n);\n\tfor(int i=1;i<=n;i++)\n\t\tread(h[i]),b[++cnt]=h[i];\n\tsort(b+1,b+cnt+1);\n\tcnt=unique(b+1,b+cnt+1)-b-1;\n\tfor(int i=1;i<=n;i++)\n\t\th[i]=lower_bound(b+1,b+cnt+1,h[i])-b;\n\tf[0][0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tf[i][0]=f[i-1][0]*2;\n\t\tfor(int j=h[i]+1;j<=h[i-1];j++) (f[i][0]=f[i][0]+f[i-1][j]*2)%mod;\n\t\tfor(int j=1;j<=h[i];j++)\n\t\t\tif(h[i]>=h[i-1]) f[i][j]=f[i-1][j]*fp(2,b[h[i]]-b[h[i-1]])%mod;\n\t\t\telse f[i][j]=f[i-1][j];\n\t\tfor(int j=h[i-1]+1;j<=h[i];j++)\n\t\t\tif(j>1) f[i][j]=f[i-1][0]*(fp(2,b[j]-b[j-1]+1)-2)%mod*fp(2,b[h[i]]-b[j])%mod;\n\t\t\telse f[i][j]=f[i-1][0]*(fp(2,b[j])-2)%mod*fp(2,b[h[i]]-b[j])%mod;\n\t}\n\tll ans=0;\n\tfor(int i=0;i<=h[n];i++)\n\t\tans=(ans+f[n][i])%mod;\n\tcout<<(ans+mod)%mod<<'\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N = 105;\nconst int MOD = 1000000007;\n\nint n,dp[N][N],h[N],w[N],m;\n\nint pow_(int x,int y) {///快速幂求 x的y次方\n    int ans = 1;\n    if(y > 0) {\n        while(y) {\n            if(y % 2)ans = (LL)ans * x % MOD;\n            x = (LL)x * x % MOD;\n            y /= 2;\n        }\n    }\n    return ans;\n}\n\nint main() {\n    scanf(\"%d\",&n);\n    for(int i = 1;i <= n;i ++) {\n        scanf(\"%d\",&h[i]);\n        w[++ m] = h[i];\n    }\n    sort(w + 1,w + m + 1);///高度排序\n    m = unique(w + 1,w + m + 1) - w - 1;///离散化 m是离散化后的长度\n    for(int i = 1;i <= n;i ++) {\n        h[i] = lower_bound(w + 1,w + m + 1,h[i]) - w;\n        printf(\"%d\\n\",h[i]);\n    }\n    dp[0][0]=1;\n    for(int i = 1;i <= n;i ++) {\n        for(int j = h[i] + 1;j <= h[i-1];j ++)\n            (dp[i][0] += dp[i - 1][j] * 2 % MOD) %= MOD;\n        (dp[i][0] += dp[i - 1][0] * 2 % MOD) %= MOD;///交叉或者不交叉\n        for(int j = 1;j <= h[i];j ++) {\n            dp[i][j]=(LL)dp[i - 1][j] * pow_(2,w[h[i]] - w[h[i-1]]) % MOD;\n            if(h[i - 1] >= j)continue;\n            if(j > 1)(dp[i][j] += (LL)dp[i - 1][0] * (pow_(2,w[j] - w[j - 1]) - 1) % MOD * 2 % MOD * pow_(2,w[h[i]] - w[j]) % MOD) %= MOD;\n            else (dp[i][j] += (LL)dp[i - 1][0] * pow_(2,w[h[i]] - w[j]) % MOD) %= MOD;\n        }\n    }\n    int ans = 0;\n    for(int i = 0;i <= m;i++)\n        (ans += dp[n][i]) %= MOD;\n    printf(\"%d\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cctype>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\n\nconst int maxn = 100 + 5;\nconst int mod = 1e9 + 7;\n\nint qpow(int a,int k) { int ans = 1; for(;k > 0;k >>= 1,a = ((ll)a * a) % mod) if(k & 1) ans = ((ll)ans * a) % mod;return ans;}\n\nint h[maxn] , w[maxn] , dp[maxn][maxn];\n\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i = 1;i <= n;i++) scanf(\"%d\",h + i) , w[i] = h[i];\n\tsort(w + 1,w + n + 1); int m = unique(w + 1,w + n + 1) - w - 1;\n\tfor(int i = 1;i <= n;i++) h[i] = lower_bound(w + 1,w + m + 1,h[i]) - w;\n\tdp[0][0] = 1;\n\tfor(int i = 1;i <= n;i++){\n\t\tfor(int j = h[i] + 1;j <= h[i - 1];j++) dp[i][0] = (dp[i][0] + dp[i - 1][j] * 2 % mod) % mod;\n\t\tdp[i][0] = (dp[i][0] + dp[i - 1][0] * 2 % mod) % mod;\n\t\tfor(int j = 1;j <= h[i];j++){\n\t\t\tdp[i][j] = (ll) dp[i - 1][j] * qpow(2,w[h[i]] - w[h[i - 1]]) % mod;\n\t\t\tif(h[i - 1] >= j) continue;\n\t\t\tif(j > 1) dp[i][j] = (dp[i][j] + (ll)dp[i - 1][0] * (qpow(2,w[j] - w[j - 1]) - 1) % mod * 2 % mod * qpow(2,w[h[i]] - w[j]) % mod) % mod;\n\t\t\telse dp[i][j] = (dp[i][j] + (ll)dp[i - 1][0] * (qpow(2,w[j]) - 2) % mod * qpow(2,w[h[i]] - w[j])) % mod;\n\t\t} \n\t}\n\tint ans = 0;\n\tfor(int i = 0;i <= m;i++) ans = (ans + dp[n][i]) % mod;\n\tprintf(\"%d\\n\",ans);\n\t\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ljc 1000000007\n#define inv2 500000004\nusing namespace std;\n#define gc getchar\ninline ll read(){\n    register ll x=0,f=1;char ch=gc();\n    while (!isdigit(ch)){if (ch=='-') f=-1;ch=gc();}\n    while (isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=gc();}\n    return (f==1)?x:-x;\n}\ninline ll fast_pow(ll a,ll b,ll p){\n\tll t=1;\n\tif (b==-1) return 0;\n\twhile (b){\n\t\tif (b&1ll) t=t*a%p;\n\t\tb>>=1ll;a=a*a%p;\n\t}\n\treturn t;\n}\nint h[201010],n;\nnamespace ST{\n\tint f[201010][20],id[201010][20];\n\tinline pair<int,int> query(int l,int r){\n\t\tif (l>r) return make_pair(1e9+1,1e9+1);\n\t\tint k=log2(r-l+1);\n\t\tif (f[l][k]<=f[r-(1<<k)+1][k]){\n\t\t\treturn make_pair(f[l][k],id[l][k]);\n\t\t}else{\n\t\t\treturn make_pair(f[r-(1<<k)+1][k],id[r-(1<<k)+1][k]);\n\t\t}\n\t}\n\tinline void init(){\n\t\tfor (int i=1;i<=n;i++) f[i][0]=h[i],id[i][0]=i;\n\t\tfor (int j=1;j<=19;j++){\n\t\t\tfor (int i=1;i+(1<<j)-1<=n;i++){\n\t\t\t\tint l=i,r=i+(1<<(j-1));\n\t\t\t\tif (f[l][j-1]<=f[r][j-1]){\n\t\t\t\t\tid[l][j]=id[l][j-1];\n\t\t\t\t\tf[l][j]=f[l][j-1];\n\t\t\t\t}else{\n\t\t\t\t\tid[l][j]=id[r][j-1];\n\t\t\t\t\tf[l][j]=f[r][j-1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n}\nstruct node{\n\tll x,y;\n};\ninline node init(ll xx,ll yy){\n\tnode x;x.x=xx,x.y=yy;return x;\n}\ninline node dp(int l,int r,int H){\n\tif (l>r) return init(0,0);\n//\tif (l>r) return init(0,0,0);\n//\tif (l==r) return init(0,fast_pow(2,h[l]-H-1,ljc),fast_pow(2,h[l]-H-1,ljc));\n//\tll resr=0,resb=0,res1=0;\n//\tint id=ST::query(l,r).second;\n//\tnode ls=dp(l,id-1,h[id]),rs=dp(id+1,r,h[id]);\n//\tif (id==l){\n//\t\tres1=rs.x*2ll%ljc;\n//\t\tresb=rs.R;\n//\t\tresr=rs.B;\n//\t}else if (id==r){\n//\t\tres1=ls.x*2ll%ljc;\n//\t\tresb=ls.B;\n//\t\tresr=ls.R;\n//\t}else{\n//\t\tif ((id-l)%2==0){\n//\t\t\tll tmp=ls.R*rs.B%ljc+ls.B*rs.R%ljc;\n//\t\t\tif (h[id]==H) resb=resr=tmp;\n//\t\t\telse resr=resb=tmp*fast_pow(2ll,h[id]-H-1,ljc)%ljc;\n//\t\t}else{\n//\t\t\tll tmp=ls.B*rs.B%ljc+ls.R*rs.R%ljc;\n//\t\t\tif (h[id]==H) resb=resr=tmp;\n//\t\t\telse resr=resb=tmp*fast_pow(2ll,h[id]-H-1,ljc)%ljc;\n//\t\t}\n////\t}\n//\treturn init(res1,resr,resb);\n\tvector<int> now;now.clear();\n\tpair<ll,ll> tmp=ST::query(l,r);\n\tll xxx=tmp.first;\n\tfor (int id=tmp.second;id<=r&&h[id]==xxx;id=ST::query(id+1,r).second) \n\t\tnow.push_back(id);\n\tll resx=2,resy=0;\n\t/*if (tmp.second==l) resx=2,resy=0;\n\telse */if (tmp.second!=l){\n\t\tnode son=dp(l,tmp.second-1,xxx);\n\t\tresx=son.x*2%ljc;\n\t\tresy=son.y;\n\t\tresy=(resy*2%ljc+resx)%ljc;\n\t}\n\tfor (int i=1;i<(int)now.size();i++){\n\t\tint L=now[i-1],R=now[i];\n\t\tif (R-L>1){\n\t\t\tnode son=dp(L+1,R-1,xxx);\n\t\tresy=(resx*(son.x+son.y)%ljc+resy*(2*son.x%ljc+son.y%ljc)%ljc)%ljc;\n\t\tresx=resx*son.x%ljc;\n\t\t}\n\t\tresy=(resy*2%ljc+resx)%ljc;\n\t}\n\tif (r-now.back()>=1){\n\t\tnode son=dp(now.back()+1,r,xxx);\n\t\tresy=(resx*(son.x+son.y)%ljc+resy*(2*son.x%ljc+son.y%ljc)%ljc)%ljc;\n\t\tresx=resx*son.x%ljc;\n\t} \n\treturn init(resx*fast_pow(2,xxx-H-1,ljc)%ljc,resy);\n}\n/*\n4\n2 3 5 4\n\n3\n1 3 2\n*/\nsigned main(){\n\tn=read();\n\tfor (int i=1;i<=n;i++) h[i]=read();\n\tST::init();\n\tnode tmp=dp(1,n,0);\n\tprintf(\"%lld\\n\",(tmp.x+tmp.y)%ljc);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// new day,new strength,new thougts\n#include<bits/stdc++.h>\n#define MP make_pair\n#define PB push_back\n#define PF push_front\n#define POB pop_back\n#define POF pop_front\n#define F first\n#define S second\n#define sz(c) int((c).size())\n#define REP(i,n)  for(int i=0;i<int(n);i++)\n#define REPD(i,n) for(int i=int(n)-1;i>=0;i--)\n#define FOR(i,a,b) for(int i=int(a);i<=int(b);i++)\n#define FORD(i,a,b) for(int i=int(a);i>=int(b);i--)\n#define all(s) (s).begin(),(s).end()\n#define bit(num,i) ((num>>i)&1)\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll,ll> pll;\n\nconst ll inf=4e18;\nconst ll maxn=110;\nconst ll mod=1e9+7;\n\nll dp[maxn][maxn],a[maxn];\n\nll tavan(ll a,ll b){\n    ll an=1;\n    while(b>0){\n\tif(b%2) an=(an*a)%mod;\n\ta=(a*a)%mod;\n\tb/=2;\n    }\n    return an;\n}\n\nint main(){\n    ll n;cin>>n;\n    FOR(i,1,n){\n\tcin>>a[i];\n    }\n    a[0]=1;\n    dp[0][0]=1;\n    FOR(i,1,n){\n\tFOR(j,0,n){\n\t    if(a[j]<=a[i]){\n\t\tif(a[j]>=a[i-1]){\n\t\t    dp[i][j]=((2*dp[i-1][i-1])*tavan(2,max(ll(0),a[i]-a[j])))%mod;\n\t\t}\n\t\telse{\n\t\t    dp[i][j]=((dp[i-1][j]+dp[i-1][((a[i]>=a[i-1])?(i-1):(i))])*tavan(2,max(ll(0),a[i]-a[i-1])))%mod;\n\t\t}\n\t    }\n\t}\n    }\n    cout<<dp[n][0];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<tuple>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define Per(i,sta,n) for(int i=n-1;i>=sta;i--)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\nint dx[4]={1,-1,0,0};\nint dy[4]={0,0,1,-1};\n\ntemplate<int mod>\nstruct ModInt {\n    long long x;\n \n    ModInt() : x(0) {}\n    ModInt(long long y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n    explicit operator int() const {return x;}\n \n    ModInt &operator+=(const ModInt &p) {\n        if((x += p.x) >= mod) x -= mod;\n        return *this;\n    }\n    ModInt &operator-=(const ModInt &p) {\n        if((x += mod - p.x) >= mod) x -= mod;\n        return *this;\n    }\n    ModInt &operator*=(const ModInt &p) {\n        x = (int)(1LL * x * p.x % mod);\n        return *this;\n    }\n    ModInt &operator/=(const ModInt &p) {\n        *this *= p.inverse();\n        return *this;\n    }\n \n    ModInt operator-() const { return ModInt(-x); }\n    ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n    ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n    ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n    ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n \n    bool operator==(const ModInt &p) const { return x == p.x; }\n    bool operator!=(const ModInt &p) const { return x != p.x; }\n \n    ModInt inverse() const{\n        int a = x, b = mod, u = 1, v = 0, t;\n        while(b > 0) {\n            t = a / b;\n            a -= t * b;\n            swap(a, b);\n            u -= t * v;\n            swap(u, v);\n        }\n        return ModInt(u);\n    }\n\n    ModInt power(long long p) const{\n        int a = x;\n        if (p==0) return 1;\n        if (p==1) return ModInt(a);\n        if (p%2==1) return (ModInt(a)*ModInt(a)).power(p/2)*ModInt(a);\n        else return (ModInt(a)*ModInt(a)).power(p/2);\n    }\n\n    ModInt power(const ModInt p) const{\n        return ((ModInt)x).power(p.x);\n    }\n\n    friend ostream &operator<<(ostream &os, const ModInt<mod> &p) {\n        return os << p.x;\n    }\n    friend istream &operator>>(istream &is, ModInt<mod> &a) {\n        long long x;\n        is >> x;\n        a = ModInt<mod>(x);\n        return (is);\n    }\n};\n\nusing modint = ModInt<mod>;\n\n\n\nint n,h[110],v[110];\nset<int> se={1};\nmap<int,int> inv_v;\nmodint dp[110][110];\n\nvoid solve(){\n    cin >> n;\n    rep(i,n){\n        cin >> h[i];\n        se.insert(h[i]);\n    }\n    int it=0;\n    int m=se.size();\n    for(int s:se){\n        inv_v[s]=it;\n        v[it]=s;\n        it++;\n    }\n    v[m]=mod;\n    // cout << m << endl;\n    // rep(i,m+1){\n    //     cout << v[i] << \" \";\n    // }\n    // cout << \"\" << endl;\n    per(j,inv_v[h[0]]+1){\n        if(j==inv_v[h[0]])dp[0][j]=2;\n        else dp[0][j]=((modint)2).power(h[0]-v[j+1]+1)*(((modint)2).power(v[j+1]-v[j])-1);\n    }\n    rep(i,n-1){\n        rep(j,m){\n            if(v[j]>h[i]) continue;\n            if(v[j+1]<=min(h[i],h[i+1])) dp[i+1][j]+=((modint)2).power(max(0,h[i+1]-h[i]))*dp[i][j];\n            else if(v[j]>=h[i+1]) dp[i+1][inv_v[h[i+1]]]+=(modint)2*dp[i][j];\n            else if(v[j]==h[i] && v[j]<h[i+1]){\n                Rep(k,j,m){\n                    if(v[k]<h[i+1]) dp[i+1][k]+=((modint)2).power(h[i+1]-v[k+1]+1)*(((modint)2).power(v[k+1]-v[k])-1)*dp[i][j];\n                    else if(v[k]==h[i+1]) {\n                        dp[i+1][k]+=(modint)2*dp[i][j];\n                    }\n                }\n            }\n        }\n    }\n    // rep(i,n){\n    //     rep(j,m){\n    //         cout << i << \"  [\" << v[j] << \",\" << v[j+1] << \") \" << dp[i][j] << endl;\n    //     }\n    // }\n    modint ans=0;\n    rep(i,m){\n        ans+=dp[n-1][i];\n    }\n    cout << ans << endl;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << fixed << setprecision(50);\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stdio.h>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n \nusing namespace std;\n \ntypedef long long ll;\n \nconst ll INF = 1e9, MOD = 1e9 + 7, MOD2 = 1e6 + 3;\n\nstring s;\n\nll dp[100][2], last[100];\n\nll p[100], sz[100], n;\n\nvector < pair <ll, ll> > v;\n\nll qpow (ll a, ll b) {\n\tll s = 1;\n\n\twhile (b) {\n\t\tif (b & 1) s = s * a % MOD;\n\t\ta = a * a % MOD;\n\t\tb /= 2;\n\t}\n\n\treturn s;\n}\n\nll find (ll x) {\n\tif (x == p[x]) return x;\n\treturn p[x] = find (p[x]);\n}\n\nvoid actualize (ll x, ll y) {\n\tdp[x][0] = dp[x][0] * qpow (2, last[x] - y) % MOD;\n\tlast[x] = y;\n}\n\nvoid unite (ll a, ll b) {\n\ta = find (a);\n\tb = find (b);\n\n\tif (a == b) return;\n\n\tif (sz[a] < sz[b]) swap (a, b);\n\n\tactualize (a, min (last[a], last[b]));\n\tactualize (b, min (last[a], last[b]));\n\n\tdp[a][1] = (dp[a][1] * (2 * dp[b][0] % MOD + dp[b][1]) % MOD) % MOD + 2 * dp[a][0] * (dp[b][0] + dp[b][1]) % MOD;\n\tdp[a][0] = dp[a][0] * dp[b][0] % MOD;\n\n\tp[b] = a;\n\n\tsz[a] += sz[b];\n}\n\nint main () {\n\tcin >> n;\n\n\tfor (ll i = 0; i < n; i++) {\n\t\tll h;\n\n\t\tscanf (\"%lld\", &h);\n\n\t\tlast[i] = h;\n\n\t\tv.emplace_back (h, i);\n\n\t\tdp[i][0] = 1;\n\t\tdp[i][1] = 0;\n\n\t\tsz[i] = 1;\n\t\tp[i] = i;\n\t}\n\n\tsort (v.begin(), v.end());\n\treverse (v.begin(), v.end());\n\n\tfor (auto a : v) {\n\n\t\tif (a.second != n - 1 && last[a.second + 1] >= last[a.second]) {\n\t\t\tunite (a.second, a.second + 1);\n\t\t}\n\t\tif (a.second && last[a.second - 1] >= last[a.second]) {\n\t\t\tunite (a.second - 1, a.second);\n\t\t}\n\t}\n\n\tactualize (find (0), 1);\n\n\tcout << (2 * dp[find (0)][0] + dp[find (0)][1]) % MOD;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_set>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\nll n;\nvector<ll> a;\nconst ll inv=(MOD+1)/2;\n\nll mod_pow(ll a,ll x){\n    ll ret=1;\n    while(x>0){\n        if(x&1){(ret*=a)%=MOD;}\n        (a*=a)%=MOD;\n        x>>=1;\n    }\n    return ret;\n}\n\npll search(ll l,ll r,ll h){\n    pll ret={1,1}; //tate,yoko\n    ll mx=0;\n    ll mi=E;\n    for(ll i=l;i<r;i++){\n        mx=max(mx,a[i]-h);\n        mi=min(mi,a[i]-h);\n    }\n    if(r-l==1){return {0,mod_pow(2,mx)};}\n    if(mi==mx){return {mod_pow(2,r-l-1),mod_pow(2,mx)};}\n    ll L=l;\n    ll cnt=0;\n    for(ll i=l;i<=r;i++){\n        if(i==r || a[i]==mi+h){\n            if(L<i){\n                pll A=search(L,i,mi+h);\n                (ret.S*=A.S)%=MOD;\n                (ret.S*=inv)%=MOD;\n                (ret.F*=(A.F+A.S*2)%MOD)%=MOD;\n            }\n            L=i+1;\n            if(i!=r){cnt++;}\n        }\n    }\n    (ret.F*=mod_pow(2,cnt))%=MOD;\n    (ret.F-=ret.S*4)%=MOD;\n    (ret.S*=mod_pow(2,mi))%=MOD;\n    (ret.S*=2)%=MOD;\n    cout<<l<<\" \"<<r<<\" \"<<h<<\" \"<<ret.F<<\" \"<<ret.S<<endl;\n    return ret;\n}\n\npll search2(ll l,ll r,ll h){\n    pll ret={1,1}; //tate,yoko\n    ll mx=0;\n    ll mi=E;\n    for(ll i=l;i<r;i++){\n        mx=max(mx,a[i]-h);\n        mi=min(mi,a[i]-h);\n    }\n    if(mi==mx){return {mod_pow(2,r-l)-2,mod_pow(2,mx)};}\n    ll L=l;\n    ll cnt=0;\n    ll k2=1;\n    for(ll i=l;i<=r;i++){\n        if(i==r || a[i]==mi+h){\n            if(L<i){\n                pll A=search2(L,i,mi+h);\n                (ret.S*=A.S)%=MOD;\n                (ret.F*=(A.F+A.S*2)%MOD)%=MOD;\n                (k2*=A.S)%=MOD;\n            }\n            L=i+1;\n            if(i!=r){cnt++;}\n        }\n    }\n    (ret.S*=mod_pow(2,mi))%=MOD;\n    (ret.F*=mod_pow(2,cnt))%=MOD;\n    (ret.F-=k2*2)%=MOD;\n    //cout<<l<<\" \"<<r<<\" \"<<h<<\" \"<<ret.F<<\" \"<<ret.S<<endl;\n    return ret;\n}\n\n\n\nint main(){\n    cin>>n;\n    a.resize(n);\n    for(auto &I:a){cin>>I;}\n    pll ans=search2(0,n,0);\n    ll A=ans.F+ans.S;\n    A%=MOD;\n    if(A<0){A+=MOD;}\n    cout<<A<<endl;\n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <fstream>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <complex>\n#include <iomanip>\n#include <stdio.h>\n#include <string.h>\n#include <random>\n#include <functional>\n\nusing std::cin;\nusing std::cout;\nusing std::cerr;\nusing std::endl;\n\nusing std::map;\nusing std::set;\nusing std::bitset;\nusing std::vector;\nusing std::string;\nusing std::multimap;\nusing std::multiset;\nusing std::deque;\nusing std::queue;\nusing std::stack;\nusing std::pair;\nusing std::iterator;\n\nusing std::sort;\nusing std::stable_sort;\nusing std::reverse;\nusing std::max_element;\nusing std::min_element;\nusing std::unique;\nusing std::ios_base;\nusing std::swap;\nusing std::fill;\n\nusing std::setprecision;\nusing std::fixed;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<long long> vl;\ntypedef string S;\n\nll min(ll a, ll b) {return a < b ? a : b;}\nll min(int a, ll b) {return a < b ? a : b;}\nll min(ll a, int b) {return a < b ? a : b;}\nll min(int a, int b) {return a < b ? a : b;}\n\nll max(ll a, ll b) {return a > b ? a : b;}\nll max(int a, ll b) {return a > b ? a : b;}\nll max(ll a, int b) {return a > b ? a : b;}\nll max(int a, int b) {return a > b ? a : b;}\n\nnamespace MySpace{\n\n};\n\n#define F(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define fi first\n#define se second\n#define re return\n#define all(x) (x).begin(), (x).end()\n#define int long long\n\nconst int N = 111;\nconst int MOD = 1e9 + 7;\n\nint n;\nint h[500];\nint dp[N];\nint kek[N][N];\n\nlong long inq(long long x, long long y)\n{\n    if (y == 0) return 1;\n    long long l = inq(x, y / 2);\n    if (y % 2) return l * l % MOD * x % MOD;\n    return l * l % MOD;\n}\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n;\n    h[0] = 1, h[n + 1] = 1;\n    for (int i = 1; i <= n; i++) cin >> h[i];\n    for (int r = 1; r <= n; r++)\n    {\n        int limit = min(h[r], h[r + 1]);\n        for (int i = r; i >= 1; i--)\n        {\n            int a = max(h[i - 1], limit);\n            int b = h[i];\n            kek[i][r] = kek[i + 1][r];\n            if (b >= a)\n            {\n                kek[i][r] += b - a;\n            }\n            limit = min(limit, h[i]);\n        }\n    }\n    //for (int l = 1; l <= n; cout << \"\\n\", l++) for (int r = 1; r <= n; r++) cout << kek[l][r] << \" \";\n    dp[0] = 1;\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n        {\n            dp[i] = (dp[i] + dp[j] * inq(2, kek[j + 1][i])) % MOD;\n        }\n    }\n    cout << 2 * dp[n] % MOD;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 1e9 + 7;\n\nvoid add(int &x,int y) {\n\tx += y; if (x >= mod) x -= mod;\n}\n\nint mul(int x,int y) {\n\treturn (long long) x * y % mod;\n}\n\nint pw(int x,int y) {\n\tint ret = 1;\n\twhile (y) {\n\t\tif (y & 1) ret = mul(ret, x);\n\t\tx = mul(x, x);\n\t\ty >>= 1;\n\t}\n\treturn ret;\n}\n\npair<int,int> solve(vector<int> h) {\n\tint n = h.size();\n\tint mn = mod, cnt = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (mn > h[i]) {\n\t\t\tmn = h[i], cnt = 0;\n\t\t}\n\t\tcnt += (h[i] == mn);\n\t}\n\t\n\tint l = 0, r = 0;\n\tvector<pair<int,int>> vec; \n\twhile (l < n) {\n\t\tvector<int> new_h;\n\t\twhile (l < n && h[l] == mn) l++;\n\t\tr = l;\n\t\twhile (r < n && h[r] > mn) r++;\n\t\tfor (int i = l; i < r; ++i) new_h.push_back(h[i] - mn);\n\t\tif (new_h.size()) vec.push_back(solve(new_h));\n\t\tl = r;\t\n\t}\n\tpair<int,int> ret;\n\tret.first = pw(2, mn);\n\tfor (auto p : vec) ret.first = mul(ret.first, p.first);\n\tret.second = pw(2, cnt);\n\tfor (auto p : vec) ret.second = mul(ret.second, p.first + p.second);\n\tint coef = pw(2, mn); add(coef, mod - 2);\n\tfor (auto p : vec) coef = mul(coef, p.first);\n\tadd(ret.second, coef);\n\treturn ret;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tint n; cin >> n;\n\tvector<int> h(n);\n\tfor (int i = 0; i < n; ++i) cin >> h[i];\n\tcout << solve(h).second << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MOD = 1e9 + 7; // change if needed\n\nstruct Modint {\n  ll val;\n  \n  Modint (ll _val = 0)\n    : val(_val % MOD) {}\n\n  Modint operator+ (Modint other) const {\n    return Modint(val + other.val);\n  }\n\n  void operator+= (Modint other) {\n    val += other.val;\n    val %= MOD;\n  }\n\n  Modint operator- () const {\n    return Modint(MOD - val);\n  }\n\n  Modint operator- (Modint other) const {\n    return Modint(val + MOD - other.val);\n  }\n\n  void operator-= (Modint other) {\n    val += MOD - other.val;\n    val %= MOD;\n  }\n\n  Modint operator* (Modint other) const {\n    return Modint(val * other.val);\n  }\n\n  void operator*= (Modint other) {\n    val *= other.val;\n    val %= MOD;\n  }\n\n  bool operator== (Modint other) const {\n    return val == other.val;\n  }\n\n  bool operator!= (Modint other) const {\n    return val != other.val;\n  }\n};\n\nModint exp (Modint a, ll k) {\n  if (k == 0) {\n    return Modint(1);\n  } else if (k % 2 == 0) {\n    Modint half = exp(a, k / 2);\n    return half * half;\n  } else {\n    return a * exp(a, k - 1);\n  }\n}\n\nModint inv (Modint a) {\n  return exp(a, MOD - 2);\n}\n\nostream& operator<< (ostream& out, Modint p) {\n  out << p.val;\n  return out;\n}\n\nconst int MAX_N = 105;\n\nint arr [MAX_N];\n\nint depc [MAX_N][MAX_N];\n// depc[i][j] should be the # of deps at position i\n// that started at >= j\n\nModint dp [MAX_N][MAX_N];\n\nint main () {\n  ios::sync_with_stdio(false);\n  \n  int n;\n  cin >> n;\n\n  for (int i = 1; i <= n; i++) {\n    cin >> arr[i];\n  }\n\n  vector<pair<int, int>> stk; // <i, h>\n  stk.push_back(make_pair(1, 0));\n  int curh = arr[1];\n\n  for (int i = 2; i <= n; i++) {\n    if (arr[i] > curh) {\n      stk.push_back(make_pair(i, curh));\n      curh = arr[i];\n    }\n\n    if (arr[i] < curh) {\n      while (stk.back().second >= arr[i]) {\n        depc[i - 1][stk.back().first] += curh - stk.back().second;\n        curh = stk.back().second;\n        stk.pop_back();\n      }\n\n      depc[i - 1][stk.back().first] += curh - arr[i];\n      curh = arr[i];\n    }\n  }\n\n  while (!stk.empty()) {\n    depc[n][stk.back().first] += curh - stk.back().second;\n    curh = stk.back().second;\n    stk.pop_back();\n  }\n  depc[n][1]--;\n  \n  for (int i = 1; i <= n; i++) {\n    for (int j = MAX_N - 2; j >= 0; j--) {\n      depc[i][j] += depc[i][j + 1];\n    }\n  }\n  \n  dp[1][0] = Modint(2) * exp(Modint(2), depc[1][1]);\n  for (int i = 1; i < n; i++) {\n    for (int j = 0; j < i; j++) {\n      // put in the opposite color\n      dp[i + 1][j] += dp[i][j] * exp(Modint(2), depc[i + 1][j + 1]);\n      // put in the same color\n      dp[i + 1][i] += dp[i][j] * exp(Modint(2), depc[i + 1][i + 1]);\n    }\n  }\n  \n  Modint ans (0);\n  for (int j = 0; j < n; j++) {\n    ans += dp[n][j];\n  }\n\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//using namespace std;\n#pragma GCC target(\"avx\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define rep(i,j,n) for(ll i=(ll)(j);i<(ll)(n);i++)\n#define REP(i,j,n) for(ll i=(ll)(j);i<=(ll)(n);i++)\n#define per(i,j,n) for(ll i=(ll)(j);(ll)(n)<=i;i--)\n#define ll long long\n#define ALL(a) (a).begin(),(a).end()\n#define disup(A,key) distance(A.begin(),upper_bound(ALL(A),(ll)(key)))\n#define dislow(A,key) distance(A.begin(),lower_bound(ALL(A),(ll)(key)))\n#define pb emplace_back\n#define mp std::make_pair\n//\n#define endl \"\\n\"\n//using std::endl;\nusing std::cin;\nusing std::cout;\nusing std::vector;\nusing std::string;\nusing std::upper_bound;\nusing std::lower_bound;\nusing vi=vector<ll>;\nusing vii=vector<vi>;\nusing pii=std::pair<ll,ll>;\n//\nconstexpr ll MOD=1e9+7;\n//constexpr ll MOD=998244353; \n//constexpr ll MOD=10000000;\n//constexpr ll MOD=1e4;\nconstexpr ll MAX=3e6;\nconstexpr ll inf=(1ll<<60);\ntemplate<class T>\nclass prique :public std::priority_queue<T, std::vector<T>, std::greater<T>> {};\ntemplate<typename T>\nstruct Segment_tree{\n    ll N;\n    T mem;\n    vector<T> node;\n    Segment_tree(vector<T> &X,T m):mem(m){\n        ll sz=X.size();\n        N=1;\n        while(N<sz) N*=2;\n        node.resize(2*N-1,mem);\n        rep(i,0,sz) node[N-1+i]=X[i];\n        per(i,N-2,0){\n            node[i]=Compare(node[i*2+1],node[i*2+2]);\n        }\n    }\n    T Compare(T &A,T &B){\n        return std::max(A,B);\n    }\n    void update(ll X,T val){\n        X+=N-1;\n        node[X]=val;\n        while(X>0){\n            X=(X-1)/2;\n            node[X]=Compare(node[X*2+1],node[X*2+2]);\n        }\n    }\n    T Query(ll a,ll b,ll now,ll l,ll r){ //[a,b),[l,r)\n        if(r<0) r=N;\n        if(r<=a||b<=l) return mem;\n        if(a<=l&&r<=b) return node[now];\n        auto vl=Query(a,b,now*2+1,l,(l+r)/2),vr=Query(a,b,now*2+2,(l+r)/2,r);\n        return Compare(vl,vr);\n    }\n};\nstruct Tree{\n    int N;\n    vector<vector<int>> dp;\n    vector<int> dist;\n    Tree(vector<vector<int>> edge){\n        N=edge.size();\n        dp.resize(N);\n        dist.resize(N,-1);\n        for(int i=0;i<N;i++) dp[i].resize(30);\n        dist[0]=dp[0][0]=0;\n        std::queue<int> que;\n        que.push(0);\n        while(!que.empty()){\n            int now=que.front(); que.pop();\n            for(int i=0;i<edge[now].size();i++){\n                int next=edge[now][i];\n                if(dist[next]==-1){\n                    dist[next]=dist[now]+1;\n                    que.push(next);\n                    dp[next][0]=now;\n                }\n            }\n        }\n        for(int i=1;i<30;i++){\n            for(int j=0;j<N;j++) dp[j][i]=dp[dp[j][i-1]][i-1];\n        }\n    }\n    int LCA(int X,int Y){\n        if(dist[X]<dist[Y]) std::swap(X,Y);\n        {\n            int Z=dist[X]-dist[Y];\n            for(int i=0;i<30;i++){\n                if(Z&(1<<i)){\n                    X=dp[X][i];\n                }\n            }\n        }\n        if(X==Y) return X;\n        for(int i=29;i>=0;i--){\n            if(dp[X][i]!=dp[Y][i]){\n                X=dp[X][i];\n                Y=dp[Y][i];\n            }\n        }\n        return dp[X][0];\n    }\n};\nstruct Binary_indexed_tree{\n    int N;\n    vi bit;\n    Binary_indexed_tree(int n):N(n){\n        bit.resize(N+1,0);\n    }\n    void add(int x,ll a){\n        for(x;x<=N;x+=(x&-x)) bit[x]+=a;\n    }\n    ll sum(int x){\n        ll ret=0;\n        for(x;x>0;x-=(x&-x)) ret+=bit[x];\n        return ret;\n    }\n    ll lower_bound(ll X){\n        if(sum(N)<X) return -1;\n        ll ret=0,memo=1,sum=0;\n        while(memo*2<=N) memo*=2;\n        while(memo>0){\n            if(memo+ret<=N&&sum+bit[memo+ret]<X){\n                sum+=bit[memo+ret];\n                ret+=memo;\n            }\n            memo/=2;\n        }\n        return ret+1;\n    }\n};\nstruct Union_Find{\n    ll N;\n    vi par;\n    vi siz;\n    Union_Find(int n):N(n){\n        par.resize(N);\n        siz.resize(N,1);\n        rep(i,0,N) par[i]=i;\n    }\n    ll root(ll X){\n        if(par[X]==X) return X;\n        return par[X]=root(par[X]);\n    }\n    bool same(ll X,ll Y){\n        return root(X)==root(Y);\n    }\n    void unite(ll X,ll Y){\n        X=root(X);\n        Y=root(Y);\n        if(X==Y) return;\n        par[X]=Y;\n        siz[Y]+=siz[X];\n        siz[X]=0;\n    }\n    ll size(ll X){\n        return siz[root(X)];\n    }\n};\nlong long modpow(long long a, long long n, long long mod) {\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\nvi fac,finv,inv;\nvoid COMinit() {\n    fac.resize(MAX);\n    finv.resize(MAX);\n    inv.resize(MAX);\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\nll COM(ll n,ll r){\n    if(n<r||n<0||r<0) return 0;\n    return fac[n]*finv[r]%MOD*finv[n-r]%MOD;\n}\nvoid comp(vi &A){\n    std::map<ll,ll> memo;\n    rep(i,0,A.size()) memo[A[i]]=0;\n    ll cnt=1;\n    for(auto &p:memo) p.second=cnt++;\n    rep(i,0,A.size()) A[i]=memo[A[i]];\n}\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    ll N; cin>>N;\n    vi H(N);\n    rep(i,0,N) cin>>H[i];\n    std::map<ll,ll> memo;\n    rep(i,0,N) memo[H[i]]=0;\n    ll cnt=1;\n    vi back(memo.size()+2);\n    for(auto &p:memo){\n        p.second=cnt;\n        back[cnt++]=p.first;\n    }\n    back[0]=1;\n    vii dp(N,vi(cnt+1));\n    back[cnt]=back[cnt-1]+1;\n    REP(i,1,cnt){\n        ll X=back[i]-back[i-1];\n        if(back[i]>H[0]) break;\n        ll left=H[0]-back[i],right=H[0]-back[i-1];\n        dp[0][i]=modpow(2,right,MOD)-modpow(2,left,MOD);\n        dp[0][i]*=2;\n        dp[0][i]%=MOD;\n        if(dp[0][i]<0) dp[0][i]+=MOD;\n    }\n    dp[0][cnt]=2;\n    rep(i,1,N){\n        REP(j,0,cnt){\n            if(j==cnt){\n                if(H[i-1]>=H[i]){\n                    dp[i][cnt]+=dp[i-1][cnt]*2%MOD;\n                    dp[i][cnt]%=MOD;\n                }\n                else{\n                    dp[i][cnt]+=dp[i-1][cnt]*2%MOD;\n                    dp[i][cnt]%=MOD;\n                    REP(k,memo[H[i-1]]+1,memo[H[i]]){\n                        ll left=H[i]-back[k],right=H[i]-back[k-1];\n                        ll X=modpow(2,right,MOD)-modpow(2,left,MOD);\n                        X*=2;\n                        X%=MOD;\n                        if(X<0) X+=MOD;\n                        dp[i][k]+=dp[i-1][j]*X%MOD;\n                        dp[i][k]%=MOD;\n                    }\n                }\n            }\n            else{\n                if(back[j]<=H[i]){\n                    ll X=1;\n                    if(H[i-1]<H[i]){\n                        X=modpow(2,H[i]-H[i-1],MOD);\n                    }\n                    dp[i][j]+=dp[i-1][j]*X%MOD;\n                    dp[i][j]%=MOD;\n                }\n                else{\n                    dp[i][cnt]+=dp[i-1][j]*2%MOD;\n                    dp[i][cnt]%=MOD;\n                }\n            }\n        }\n    }\n    ll ans=0;\n    REP(i,1,cnt){\n        ans+=dp[N-1][i];\n        ans%=MOD;\n    }\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) (x = max(x,y))\n#define mins(x,y) (x = min(x,y))\n#define limit(x,l,r) max(l,min(x,r))\n#define lims(x,l,r) (x = max(l,min(x,r)))\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcountll\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,v(T),greater<T> >\n#define bn(x) ((1<<x)-1)\n#define dup(x,y) (((x)+(y)-1)/(y))\n#define newline puts(\"\")\n#define v(T) vector<T>\n#define vv(T) v(v(T))\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ntemplate<typename T>inline istream& operator>>(istream&i,v(T)&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(const v(T)&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>inline ostream& operator<<(ostream&o,const v(T)&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>inline istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>inline ostream& operator<<(ostream&o,const pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\ntemplate<typename T>inline ll suma(const v(T)& a) { ll res(0); for (auto&& x : a) res += x; return res;}\nconst double eps = 1e-10;\nconst ll LINF = 1e18;\nconst int INF = 1001001001;\n#define dame { puts(\"-1\"); return 0;}\n#define yn {puts(\"YES\");}else{puts(\"NO\");}\nconst int MX = 200005;\n\n// Mod int\nconst int mod = 1000000007;\nstruct mint {\n  ll x;\n  mint():x(0){}\n  mint(ll x):x((x%mod+mod)%mod){}\n  // mint(ll x):x(x){}\n  mint& fix() { x = (x%mod+mod)%mod; return *this;}\n  mint& operator+=(const mint& a){ if((x+=a.x)>=mod) x-=mod; return *this;}\n  mint& operator-=(const mint& a){ if((x+=mod-a.x)>=mod) x-=mod; return *this;}\n  mint& operator*=(const mint& a){ (x*=a.x)%=mod; return *this;}\n  mint& operator/=(const mint& a){ (x*=a.ex(mod-2).x)%=mod; return *this;}\n  mint operator+(const mint& a)const{ return mint(*this) += a;}\n  mint operator-(const mint& a)const{ return mint(*this) -= a;}\n  mint operator*(const mint& a)const{ return mint(*this) *= a;}\n  mint operator/(const mint& a)const{ return mint(*this) /= a;}\n  mint ex(ll t) const {\n    if(!t) return 1;\n    mint res = ex(t/2);\n    res *= res;\n    return (t&1)?res*x:res;\n  }\n  bool operator<(const mint& a)const{ return x < a.x;}\n  bool operator==(const mint& a)const{ return x == a.x;}\n};\nmint ex(mint x, ll t) { return x.ex(t);}\nistream& operator>>(istream&i,mint&a){i>>a.x;return i;}\nostream& operator<<(ostream&o,const mint&a){o<<a.x;return o;}\ntypedef vector<mint> vm;\nstruct comb {\n  vm f, g;\n  comb(){}\n  comb(int mx):f(mx+1),g(mx+1) {\n    f[0] = 1;\n    rrep(i,mx) f[i] = f[i-1]*i;\n    g[mx] = f[mx].ex(mod-2);\n    for(int i=mx;i>0;i--) g[i-1] = g[i]*i;\n  }\n  mint c(int a, int b) {\n    if (a < b) return 0;\n    return f[a]*g[b]*g[a-b];\n  }\n};\n//\n\nvi conv(vi a) {\n  vi res;\n  rep(i,sz(a)-1) {\n    res.pb(min(a[i],a[i+1])-1);\n  }\n  return res;\n}\ntypedef pair<mint,mint> MP;\nMP dfs(vi a) {\n  int n = sz(a);\n  int l = INF;\n  rep(i,n) mins(l,a[i]);\n  rep(i,n) a[i] -= l;\n  MP res(1,1);\n  vi x;\n  auto f = [&]() {\n    if (!sz(x)) return;\n    MP d = dfs(x);\n    res.fi *= d.fi;\n    res.se *= d.se;\n    x = vi();\n  };\n  rep(i,n) {\n    if (a[i]) {\n      x.pb(a[i]);\n    } else {\n      res.se *= 2;\n      f();\n    }\n  }\n  f();\n  // cerr<<l<<\": \"<<a<<endl;\n  // cerr<<res<<endl;\n  res.se += res.fi*(ex(2,l)-1);\n  res.fi *= ex(2,l);\n  // cerr<<res<<endl;\n  return res;\n}\nmint solve(vi a) {\n  int n = sz(a);\n  if (!n) return 1;\n  a = conv(a);\n  return dfs(a).se*2;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\",&n);\n  vi a(n);\n  cin>>a;\n  mint ans = 1;\n  rep(i,n) {\n    int x = 1;\n    if (i) maxs(x,a[i-1]);\n    if (i+1 < n) maxs(x,a[i+1]);\n    if (a[i] > x) {\n      ans *= ex(2,a[i]-x);\n      a[i] = x;\n    }\n  }\n\n  vi x;\n  rep(i,n) {\n    if (a[i] == 1) {\n      ans *= 2;\n      a[i] = 0;\n      ans *= solve(x);\n      x = vi();\n    } else x.pb(a[i]);\n  }\n  ans *= solve(x);\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <utility>\n\nusing namespace std;\n\n#define fi first\n#define se second\n#define long long long\ntypedef pair<int,int> ii;\ntypedef pair<long,ii> lii;\n\nconst long MOD = 1e9+7;\nlong p2(long b)\n{\n\tif(b == 0) return 1;\n\telse if(b == 2) return 4;\n\telse if(b&1) return (p2(b-1)*2)%MOD;\n\telse\n\t{\n\t\tlong temp = p2(b/2);\n\t\treturn (temp*temp)%MOD;\n\t}\n}\nlong geo(long a, long n)\n{\n\treturn (a*(p2(n)-1))%MOD;\n}\n\nvector<lii> vec;\nlong arr[100003];\n\nint main()\n{\n\t//ios_base::sync_with_stdio(); cin.tie(0); cout.tie(0);\n\t// freopen(\"input.in\", \"r\", stdin);\n\t\n\tint n; scanf(\"%d\", &n);\t\n\tfor(int i = 1; i <= n; i++)\n\t\tscanf(\"%lld\", &arr[i]);\n\tlong hit = 0;\n\tlong res = 1;\n\tlong bed = 1;\n\tfor(int i = 1; i <= n+1; i++)\n\t{\n\t\tif(arr[i] == 1 || i == n+1)\n\t\t{\n\t\t\tlong cnt = 0;\n\t\t\tcnt += bed;\n\t\t\tfor(auto j : vec)\n\t\t\t{\n\t\t\t\tcnt += geo(j.fi,j.se.fi-j.se.se+1);\n\t\t\t\tcnt %= MOD;\n\t\t\t}\n\t\t\t// printf(\"i : %d\\n\" , i);\n\t\t\t// printf(\"\tBED : %lld\\n\", bed);\n\t\t\t// printf(\"\tCNT : %lld\\n\", cnt);\n\t\t\tif(arr[i] == 1) hit++;\n\t\t\tvec.clear();\n\t\t\tbed = 1;\n\t\t\tres *= cnt;\n\t\t\tres %= MOD;\n\n\t\t}\n\t\telse if(vec.size() == 0)\n\t\t{\n\t\t\tvec.push_back({2,{arr[i],2}});\n\t\t\tbed *= 2;\n\t\t}\n\t\telse if(arr[i] > arr[i-1])\n\t\t{\n\t\t\tfor(int j = 0; j < vec.size(); j++)\n\t\t\t{\n\t\t\t\tvec[j].fi *= p2(arr[i]-arr[i-1]);\n\t\t\t\tvec[j].fi %= MOD;\n\t\t\t}\n\t\t\tbed *= 2; bed %= MOD;\n\t\t\tvec.push_back({bed,{arr[i], arr[i-1]+1}});\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvector<lii> temp;\n\t\t\tbed *= 2; bed %= MOD;\n\t\t\tfor(int j = 0; j < vec.size(); j++)\n\t\t\t{\n\t\t\t\tif(vec[j].se.fi > arr[i])\n\t\t\t\t{\n\t\t\t\t\tif(vec[j].se.se > arr[i])\n\t\t\t\t\t{\n\t\t\t\t\t\tbed += 2*geo(vec[j].fi,vec[j].se.fi-vec[j].se.se+1);\n\t\t\t\t\t\tbed %= MOD;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tbed += 2*geo(vec[j].fi, vec[j].se.fi-arr[i]);\n\t\t\t\t\t\tbed %= MOD;\n\t\t\t\t\t\ttemp.push_back({vec[j].fi*p2(vec[j].se.fi-arr[i]),{arr[i],vec[j].se.se}});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\ttemp.push_back(vec[j]);\n\t\t\t}\n\t\t\tvec = temp;\n\t\t}\n\t}\n\t// printf(\"%lld\\n\", hit);\n\tres *= p2(hit);\n\tres %= MOD;\n\tprintf(\"%lld\\n\", res);\n}\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int MOD = 1e9 + 7;\n\nint n,m,h[101],hnum[101],dh[101];\nLL dp[101][101];\n\nint pow_(int x,int y) {///快速幂求 x的y次方\n    int ans = 1;\n    if(y > 0) {\n        while(y) {\n            if(y % 2)ans = (LL)ans * x % MOD;\n            x = (LL)x * x % MOD;\n            y /= 2;\n        }\n    }\n    return ans;\n}\n\nint main() {\n    scanf(\"%d\",&n);\n    for(int i = 1;i <= n;i ++) {\n        scanf(\"%d\",&h[i]);\n        dh[++ m] = h[i];\n    }\n    sort(dh + 1,dh + m + 1);///高度排序\n    m = unique(dh + 1,dh + m + 1) - dh - 1;///离散化 m是离散化后的长度\n    for(int i = 1;i <= n;i ++) {\n        hnum[i] = lower_bound(dh + 1,dh + m + 1,hnum[i]) - dh;\n    }\n    dp[0][0]=1;\n    for(int i = 1;i <= n;i ++) {\n        for(int j = hnum[i] + 1;j <= hnum[i - 1];j ++)\n            (dp[i][0] += dp[i - 1][j] * 2 % MOD) %= MOD;\n\n        (dp[i][0] += dp[i - 1][0] * 2 % MOD) %= MOD;///交叉或者不交叉\n\n        int d = pow_(2,dh[hnum[i]] - dh[hnum[i-1]]);\n        for(int j = 1;j <= min(hnum[i - 1],hnum[i]);j ++) {\n            dp[i][j] = dp[i - 1][j] * d % MOD;\n        }\n        for(int j = hnum[i - 1] + 1;j <= hnum[i];j ++) {///比前一列高出的部分\n            if(j > 1)(dp[i][j] += dp[i - 1][0] * (pow_(2,dh[j] - dh[j - 1]) - 1) % MOD * 2 % MOD * pow_(2,dh[hnum[i]] - dh[j]) % MOD) %= MOD;\n            else (dp[i][1] += dp[i - 1][0] * (pow_(2,dh[1]) - 2) % MOD * pow_(2,dh[hnum[i]] - dh[1]) % MOD) %= MOD;///上一列中无重复相同的乘上化不超过上一列高度中有重复的\n        }\n    }\n    LL ans = 0;\n    for(int i = 0;i <= hnum[n];i++)\n        (ans += dp[n][i]) %= MOD;\n    printf(\"%lld\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\nconst int mod=1e9+7;\nconst int inf=1e9+9;\nint powmod(int x, int k){ int ret=1;for(;k;k>>=1,x=(ll)x*x%mod) if(k&1) ret=(ll)ret*x%mod;return ret;}\npair<int,int> Solve(vector<int> a)\n{\n\tint mn=inf;\n\tfor(int i:a) mn=min(mn,i);\n\tint cnt=0;\n\tfor(int i:a) cnt+=i==mn;\n\tint all=powmod(2,cnt);\n\tint only=2;\n\tvector<int> tmp;\n\tfor(int i:a)\n\t{\n\t\tif(i==mn && tmp.size())\n\t\t{\n\t\t\tpair<int,int> ans=Solve(tmp);\n\t\t\ttmp.clear();\n\t\t\tall=(ll)all*((ans.first+ans.second)%mod)%mod;\n\t\t\tonly=(ll)only*ans.second%mod;\n\t\t}\n\t\tif(i!=mn) tmp.push_back(i-mn);\n\t}\n\tif(tmp.size())\n\t{\n\t\tpair<int,int> ans=Solve(tmp);\n\t\ttmp.clear();\n\t\tall=(ll)all*((ans.first+ans.second)%mod)%mod;\n\t\tonly=(ll)only*ans.second%mod;\n\t}\n\tall-=only;\n\tif(all<0) all+=mod;\n\tonly=(ll)only*powmod(2,mn-1)%mod;\n\tall+=only;\n\tif(all>=mod) all-=mod;\n\treturn make_pair(all,only);\n}\nint main()\n{\n\tint n,i;\n\tscanf(\"%i\",&n);\n\tvector<int> a(n);\n\tfor(i=0;i<n;i++) scanf(\"%i\",&a[i]);\n\tprintf(\"%i\\n\",Solve(a).first);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<bitset>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; i++ )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef pair<ll,int> pli;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\nint dx[4]={1,0,-1,0} , dy[4]={0,1,0,-1} ;\n\nll dp[111][111][2];\nint a[111];\n\nll powmod(ll n,ll k){\n    ll ret=1;\n    while(k>0){\n        if(k&1)ret=ret*n%mod;\n        n=n*n%mod;\n        k>>=1;\n    }\n    return ret;\n}\n\nll rec(int l,int r,int h,int flag){\n    if(dp[l][r][flag]!=-1)return dp[l][r][flag];\n    if(l==r)return dp[l][r][flag]=flag;\n    if(l+1==r){\n        if(flag)return dp[l][r][flag]=powmod(2,a[l]-h);\n        else return dp[l][r][flag]=0;\n    }\n    int mi=inf,ma=0;\n    REP(i,l,r){\n        mi=min(mi,a[i]);\n        ma=max(ma,a[i]);\n    }\n    ll ret1=powmod(2,ma-h);\n    if(flag) return dp[l][r][flag]=ret1;\n    ll ret2=1;\n    ll pos=l-1;\n        REP(i,l,r){\n            if(a[i]==mi){\n                ret2=2*ret2%mod;\n                if(i-pos>1)ret2*=(2*rec(pos+1,i,mi,1)+rec(pos+1,i,mi,0));\n                ret2%=mod;\n                pos=i;\n            }\n        }\n    if(r-pos>1)ret2=ret2*(2*rec(pos+1,r,mi,1)+rec(pos+1,r,mi,0))%mod;\n    ret2=(ret2-powmod(2,ma-mi+1)+mod)%mod;\n    return dp[l][r][flag]=ret2;\n}\nint main(){\n   int n;\n   cin>>n;\n   rep(i,n)cin>>a[i];\n   rep(i,n+1)rep(j,n+1)rep(k,2)dp[i][j][k]=-1;\n   ll ans=rec(0,n,0,0)+rec(0,n,0,1);\n   cout<<ans%mod<<endl;\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define lor(a,b,c) for(register int a=b;a<=c;++a)\n#define ror(a,b,c) for(register int a=c;a>=b;--a)\ntypedef long long ll;\n\nconst int MAXN=105,MAXT=MAXN<<1,INF=0x3f3f3f3f;\nconst ll MOD=1e9+7;\n\nint n,h[MAXN];\nint tot,bor[MAXT][2],son[MAXT][MAXT],top[MAXT],bot[MAXT];\nll dp1[MAXN],dp2[MAXN];\n\ntemplate <typename T> inline T read(){\n\tchar tmp=getchar(); T sum=0; bool flag=false;\n\twhile(tmp<'0'||tmp>'9'){\n\t\tif(tmp=='-') flag=true; tmp=getchar();\n\t}\n\twhile(tmp>='0'&&tmp<='9'){\n\t\tsum=(sum<<1)+(sum<<3)+tmp-'0'; tmp=getchar();\n\t}\n\treturn flag?-sum:sum;\n}\n\ntemplate <typename T> inline void inc(T &a,T b){\n\t(a+=b)>=MOD?a-=MOD:a;\n}\n\ninline ll qsm(ll a,ll b){\n\tll ans=1ll;\n\twhile(b){\n\t\tif(b&1) (ans*=a)%=MOD; (a*=a)%=MOD; b>>=1;\n\t}\n\treturn ans;\n}\n\nint main(){\n\tn=read<int>(); lor(i,1,n) h[i]=read<int>();\n\n\ttot=1; bor[tot][0]=1; bor[tot][1]=n;\n\tint it=tot;\n\twhile(it<=tot){\n\t\tbool same=true; int minn=h[bor[it][0]];\n\t\tlor(i,bor[it][0]+1,bor[it][1]){\n\t\t\tif(h[i]!=h[i-1]) same=false; minn=min(minn,h[i]);\n\t\t}\n\t\ttop[it]=minn;\n\t\tif(!same){\n\t\t\tint pre=-1;\n\t\t\tlor(i,bor[it][0],bor[it][1]){\n\t\t\t\tif(h[i]==minn){\n\t\t\t\t\tif(pre!=-1) ++tot,son[it][++son[it][0]]=tot,bor[tot][0]=pre,bor[tot][1]=i-1,bot[tot]=minn;\n\t\t\t\t\tpre=-1;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(pre==-1) pre=i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(pre!=-1) ++tot,son[it][++son[it][0]]=tot,bor[tot][0]=pre,bor[tot][1]=bor[it][1],bot[tot]=minn;;\n\t\t}\n\t\t++it;\n\t}\n\n\tror(k,1,tot){\n\t\tll st1=1ll,st2=1ll;\n\t\tll uncover=bor[k][1]-bor[k][0]+1,h=top[k]-bot[k];\n\t\tlor(i,1,son[k][0]){\n\t\t\tint v=son[k][i];\n\t\t\tuncover-=bor[v][1]-bor[v][0]+1;\n\t\t\t(st1*=dp1[v]+dp2[v])%=MOD;\n\t\t\t(st2*=dp1[v])%=MOD;\n\t\t}\n\t\tdp1[k]=st2*qsm(2,h)%MOD;\n\t\t(dp2[k]=qsm(2,uncover)*st1%MOD+(qsm(2,h)+MOD-2)%MOD*st2%MOD)%=MOD;\n\t}\n\n\tprintf(\"%lld\\n\",dp2[1]);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long h[200009];\nlong long dp[109];\nlong long po[100009];\nlong long mod = 1e9+7;\nvector< pair<long long,long long> > v[109];\nmain(){\n    po[0] = 1;\n    for(long long i = 1 ;i  <= 10000; i++)\n        po[i] = 2 * po[i-1] % mod;\n    long long n;\n    cin >> n;\n    for(long long i = 1; i <= n; i++){\n        cin >> h[i];\n    }\n    for(long long i = 1; i <= n; i++){\n        if(h[i-1] > h[i]) continue;\n        long long lo = max((long long)2,h[i-1]+1), hi = h[i];\n        for(long long j = i; j <= n; j++){\n            if(max((long long)0,hi - max(lo,h[j]+1)+1)) v[i].push_back({j-1,max((long long)0,hi - max(lo,h[j]+1)+1)});\n            hi = min(hi,h[j]);\n        }\n        if(max((long long)0,hi-lo+1)) v[i].push_back({n,max((long long)0,hi-lo+1)});\n    }\n    for(long long i = n; i >= 1; i--){\n        for(long long j = i; j <= n; j++){\n        long long A = 0;\n            for(long long k = i; k <= j; k++){\n                for(long long t= 0; t < v[k]. size(); t++){\n                    long long r = v[k][t].first, N =  v[k][t].second;\n                    if(r <= j) A+= N;\n                }\n            }\n        if(j == n) dp[i] = (dp[i] + po[A]) % mod;\n        else dp[i] = (dp[i] + dp[j+1] * po[A])% mod;\n        }\n    }\n    cout<<  dp[1] * 2 % mod << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <vector>\n\n#include <cassert>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\ninline void ModSum(int& x, int y)\n{\n    x += y;\n    if (x >= MOD) {\n        x -= MOD;\n    }\n    if (x < 0) {\n        x += MOD;\n    }\n}\n\ninline int GetModSum(int x, int y)\n{\n    ModSum(x, y);\n    return x;\n}\n\ninline void ModMul(int& x, int y)\n{\n    x = (1LL * x * y) % MOD;\n}\n\ninline int GetModMul(int x, int y)\n{\n    ModMul(x, y);\n    return x;\n}\n\ninline int GetBinaryPow(int x, int pw)\n{\n    int r = 1;\n    while (pw > 0) {\n        if (pw & 1) {\n            ModMul(r, x);\n        }\n        ModMul(x, x);\n        pw >>= 1;\n    }\n    return r;\n}\n\nstruct TSolver\n{\n    int N;\n    vector<int> Heights;\n\n    unordered_map<int, int> HeightToIndex;\n    vector<int> IndexToHeight;\n\n    void Setup()\n    {\n    }\n\n    bool Read()\n    {\n        if (!(cin >> N)) {\n            return false;\n        }\n        Heights.resize(N);\n        for (int i = 0; i < N; ++i) {\n            cin >> Heights[i];\n        }\n        return true;\n    }\n\n    void CompressHeights()\n    {\n        HeightToIndex.clear();\n        IndexToHeight.clear();\n\n        auto add = [this] (int height) {\n            if (HeightToIndex.find(height) != HeightToIndex.end()) {\n                return;\n            }\n            auto index = IndexToHeight.size();\n            IndexToHeight.push_back(height);\n            HeightToIndex[height] = index;\n        };\n\n        add(0);\n        for (int i = 0; i < N; ++i) {\n            add(Heights[i]);\n        }\n    }\n\n    void Solve()\n    {\n        CompressHeights();\n\n        const auto zeroHeightIndex = HeightToIndex.at(0);\n        const int heightCount = HeightToIndex.size();\n\n        vector<vector<int>> dp(N, vector<int>(heightCount));\n        dp[0][zeroHeightIndex] = 1;\n\n        for (int i = 0; i + 1 < N; ++i) {\n            for (int j = 0; j < heightCount; ++j) {\n                auto middleHeight = IndexToHeight[j];\n\n                if (middleHeight > Heights[i]) {\n                    assert(dp[i][j] == 0);\n                    continue;\n                }\n\n                if (j == zeroHeightIndex) {\n                    auto mul = GetBinaryPow(2, max(0, Heights[i] - Heights[i + 1]));\n                    ModSum(dp[i + 1][j], GetModMul(dp[i][j], mul));\n                    ModSum(dp[i + 1][HeightToIndex.at(min(Heights[i], Heights[i + 1]))], GetModMul(GetModMul(dp[i][j], mul), 2));\n                } else {\n                    assert(middleHeight > 0);\n                    if (Heights[i + 1] <= middleHeight) {\n                        ModSum(dp[i + 1][HeightToIndex.at(Heights[i + 1])], GetModMul(GetModMul(dp[i][j], GetBinaryPow(2, Heights[i] - middleHeight)), 2));\n                    } else if (Heights[i + 1] > middleHeight && Heights[i + 1] <= Heights[i]) {\n                        auto mul = GetBinaryPow(2, Heights[i] - Heights[i + 1]);\n                        ModSum(dp[i + 1][HeightToIndex.at(Heights[i + 1])], GetModMul(dp[i][j], mul));\n                        ModSum(dp[i + 1][j], GetModMul(dp[i][j], mul));\n                    } else {\n                        ModSum(dp[i + 1][HeightToIndex.at(Heights[i])], dp[i][j]);\n                        ModSum(dp[i + 1][j], dp[i][j]);\n                    }\n                }\n            }\n        }\n\n        int result = 0;\n        for (int i = 0; i < heightCount; ++i) {\n            auto diff = Heights[N - 1] - IndexToHeight[i];\n            if (diff < 0) {\n                assert(dp[N - 1][i] == 0);\n                continue;\n            }\n            ModSum(result, GetModMul(dp[N - 1][i], GetBinaryPow(2, diff)));\n        }\n\n        cout << result << '\\n';\n    }\n\n    void TearDown()\n    {\n        cout.flush();\n    }\n};\n\nint main()\n{\n    // freopen(\"input.txt\", \"r\", stdin);\n    // freopen(\"output.txt\", \"w\", stdout);\n\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    TSolver solver;\n    solver.Setup();\n    while (solver.Read()) {\n        solver.Solve();\n        solver.TearDown();\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint ungigned\n#define db double\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pli pair<ll,int>\n#define vi vector<int>\n#define vpi vector<pii >\n#define IT iterator\n \n#define PB push_back\n#define MK make_pair\n#define LB lower_bound\n#define UB upper_bound\n#define y1 wzpakking \n#define fi first\n#define se second\n#define BG begin\n#define ED end\n \n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define UPD(x,y) (((x)+=(y))>=mo?(x)-=mo:233)\n#define CLR(a,v) memset(a,v,sizeof(a))\n#define CPY(a,b) memcpy(a,b,sizeof(a))\n#define sqr(x) (1ll*x*x)\n \n#define LS3 k*2,l,mid\n#define RS3 k*2+1,mid+1,r\n#define LS5 k*2,l,mid,x,y\n#define RS5 k*2+1,mid+1,r,x,y\n#define GET pushdown(k);int mid=(l+r)/2\n#define INF (1ll<<60)\nusing namespace std;\n\nconst int mo=1000000007;\nint power(int x,ll y){\n\tint s=1;\n\tfor (;y;y/=2,x=1ll*x*x%mo)\n\t\tif (y&1) s=1ll*s*x%mo;\n\treturn s;\n}\nconst int N=105;\nint a[N],mn[N][N];\nint fxor[N][N];\nint pre[N][N];\nint suf[N][N];\nint mx[N],g[N],n;\nint main(){\n\tscanf(\"%d\",&n); n++;\n\tFor(i,2,n) scanf(\"%d\",&a[i]);\n\ta[0]=a[1]=a[n+1]=a[n+2]=1;\n\tFor(i,0,n+2) mn[i][i]=i;\n\tFor(l,0,n+2) For(r,l+1,n+2)\n\t\tmn[l][r]=(a[r]<a[mn[l][r-1]]?r:mn[l][r-1]);\n\tFor(i,1,n+2) fxor[i][i-1]=1;\n\tRep(l,n+1,1) For(r,l,n+1){\n\t\tint dn=max(a[l-1],a[r+1]),md=mn[l][r];\n\t\tif (a[md]>=dn) fxor[l][r]=1ll*power(2,a[md]-dn)*fxor[l][md-1]%mo*fxor[md+1][r]%mo;\n\t}\n\tFor(l,0,n+2){\n\t\tCLR(mx,0); mx[l]=a[l];\n\t\tFor(i,l+1,n+2) mx[i]=min(a[i],mx[i-1]);\n\t\tint tmp=pre[l][l]=1,las=l;\n\t\tFor(r,l+1,n+2){\n\t\t\tpre[l][r]=1ll*tmp*fxor[las+1][r-1]%mo;\n\t\t\tif (mx[r]>=a[r]) tmp=1ll*tmp*fxor[las+1][r-1]%mo,las=r;\n\t\t}\n\t}\n\tFor(r,0,n+2){\n\t\tCLR(mx,0); mx[r]=a[r];\n\t\tRep(i,r-1,0) mx[i]=min(a[i],mx[i+1]);\n\t\tint tmp=suf[r][r]=1,las=r;\n\t\tRep(l,r-1,0){\n\t\t\tsuf[l][r]=1ll*tmp*fxor[l+1][las-1]%mo;\n\t\t\tif (mx[l]>=a[l]) tmp=1ll*tmp*fxor[l+1][las-1]%mo,las=l;\n\t\t}\n\t}\n\tg[1]=1;\n\tFor(i,2,n+2) For(j,1,i-1){\n\t\tint md=mn[j-1][i];\n\t\tUPD(g[i],1ll*g[j]*pre[j-1][md]%mo*suf[md][i]%mo);\n\t}\n\tprintf(\"%d\\n\",1ll*g[n+2]*500000004ll%mo);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define llong long long\n#define mkpr make_pair\n#define riterator reverse_iterator\n#define pll pair<llong,llong>\nusing namespace std;\n\ninline int read()\n{\n\tint x = 0,f = 1; char ch = getchar();\n\tfor(;!isdigit(ch);ch=getchar()) {if(ch=='-') f = -1;}\n\tfor(; isdigit(ch);ch=getchar()) {x = x*10+ch-48;}\n\treturn x*f;\n}\n\nconst int mxN = 100;\nconst int INF = 1e9;\nconst int P = 1e9+7;\nint a[mxN+3];\nint n;\n\nllong quickpow(llong x,llong y)\n{\n\tllong cur = x,ret = 1ll;\n\tfor(int i=0; y; i++)\n\t{\n\t\tif(y&(1ll<<i)) {y-=(1ll<<i); ret = ret*cur%P;}\n\t\tcur = cur*cur%P;\n\t}\n\treturn ret;\n}\n\npll dfs(int l,int r,int h)\n{\n//\tprintf(\"l=%d r=%d h=%d\\n\",l,r,h);\n\tint h2 = INF; for(int i=l; i<=r; i++) h2 = min(h2,a[i]);\n\tpll ret(0ll,1ll); int mncnt = 0ll,segcnt = 0ll; llong prod1 = 1ll;\n\tfor(int i=l,j=l; i<=r+1; i++)\n\t{\n\t\tif(a[i]==h2||i==r+1)\n\t\t{\n\t\t\tif(j<=i-1)\n\t\t\t{\n\t\t\t\tpll tmp = dfs(j,i-1,h2);\n\t\t\t\tret.second = ret.second*tmp.second%P;\n\t\t\t\tprod1 = prod1*(tmp.first+tmp.second*2ll)%P;\n\t\t\t\tsegcnt++;\n\t\t\t}\n\t\t\tif(i<=r)\n\t\t\t{\n\t\t\t\tmncnt++;\n\t\t\t}\n\t\t\tj = i+1;\n\t\t}\n\t}\n\tret.first = (prod1*quickpow(2ll,mncnt)-ret.second*2ll%P+P)%P;\n\tret.second = ret.second*quickpow(2ll,h2-h)%P;\n//\tprintf(\"(%lld,%lld)\\n\",ret.first,ret.second);\n\treturn ret;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1; i<=n; i++) scanf(\"%lld\",&a[i]);\n\tpll ans = dfs(1,n,0);\n\tprintf(\"%lld\\n\",(ans.first+ans.second)%P);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████\n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬████╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████  \n//\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define INF (1<<30)\n#define LINF (1LL<<60)\n#define fs first\n#define sc second\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(int i = (b-1);i>=(a);--i)\n#define REP(i,n)  FOR(i,0,(n))\n#define RREP(i,n) RFOR(i,0,(n))\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl\n#define SP << \" \" << \ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n#define MSB(x) (63-__builtin_clzll(x))\n#define pcnt(x) (__builtin_popcountll(x))\n#define parity(i,j) (i&(1LL<<j))\ntypedef tuple<int,int,int> T;\n\nvector<int> MODS = { 1000000007, 998244353 }; // 実行時に決まる\ntemplate<int IND = 0> struct Fp {\n    long long val;\n    \n    int MOD = MODS[IND];\n    constexpr Fp(long long v = 0) noexcept : val(v % MODS[IND]) {\n        if (val < 0) val += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<IND>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr istream& operator >> (istream &is, Fp<IND>& x) noexcept {\n        return is >> x.val;\n    }\n    friend constexpr Fp<IND> modpow(const Fp<IND> &a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\nusing mint = Fp<0>; // MODを変える場合は値を変更\ntypedef vector<mint> vec;\ntypedef vector<vector<mint>> mat;\ntypedef pair<mint,mint> P;\n\nvector<int> a(100);\n\nP f(int l, int r, int h){\n  mint x = 1, y = 1;\n  if(l==r) return P(0,1);\n\n  int mn = INF;\n  FOR(i,l,r) chmin(mn,a[i]);\n  \n  int now = l, cnt = 0;\n  FOR(i,l,r) cnt += (a[i]==mn); \n  FOR(i,l,r+1){\n    if(a[i]!=mn&&i!=r) continue;\n    P p = f(now,i,mn);\n    //cout << now SP i SP mn << endl;\n    //cout << p.fs SP p.sc << endl;\n    x *= p.fs+p.sc;\n    y *= p.sc;\n    now = i+1;\n  }\n\n  x = x*modpow((mint)2,cnt)+y*(modpow(mint(2),mn-h)-2);\n  y *= modpow((mint)2,mn-h);\n\n  return P(x,y);\n}\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n;\n  cin >> n;\n  \n  REP(i,n) cin >> a[i];\n  \n  cout << f(0,n,0).fs << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n\nconst int MOD = 1000000007;\nconst ll INF = 1e18;\nconst int MX = 100001;\n\n\nll po (ll b, ll p) { return !p?1:po(b*b%MOD,p/2)*(p&1?b:1)%MOD; }\nll inv (ll b) { return po(b,MOD-2); }\n\nll ad(ll a, ll b) { return (a+b)%MOD; }\nll sub(ll a, ll b) { return (a-b+MOD)%MOD; }\nll mul(ll a, ll b) { return a*b%MOD; }\nll divi(ll a, ll b) { return mul(a,inv(b)); }\n\nint N;\nvi h(N);\n\npi get(vi x);\n\npi process(vi& cur) {\n    for (int& i: cur) i --;\n    pi z = get(cur);\n    cur.clear();\n    return z;\n}\n\npi solve(vi x) {\n    vpi ret;\n    vi cur;\n    ll a = 2, b = 1;\n    for (int i: x) {\n        if (i > 1) cur.pb(i);\n        else {\n            b = mul(2,b);\n            if (sz(cur)) {\n                ret.pb(process(cur));\n                assert(sz(cur) == 0);\n            }\n        }\n    }\n    if (sz(cur)) ret.pb(process(cur));\n    \n    // dp[x][1] = 2*dp[a][1]*dp[b][1]*...\n    // dp[x][0] = 2^rem*(dp[a][0]+dp[a][1])*(dp[b][0]*dp[b][1])*... is this correct?\n    for (auto t: ret) {\n        a = mul(a,t.f);\n        b = mul(b,ad(t.f,t.s));\n    }\n    // for (int i: x) cout << i << \" \";\n    // cout << \"| \" << a << \" \" << b << \"\\n\";\n    return {a,b};\n}\n\npi transform(pi t, int mn) {\n    // cout << \"OOPS\\n\";\n    int ne = mul(po(2,mn-1),t.f);\n    t.s = ad(t.s,sub(ne,t.f));\n    t.f = ne;\n    return t;\n    // dp[x][1] = dp[a][1];\n    // dp[x][0] = dp[a][0]+dp[a][1]\n    // repeat mn-1 times\n}\n\npi get(vi x) {\n    int mn = MOD; F0R(i,sz(x)) mn = min(mn,x[i]);\n    F0R(i,sz(x)) x[i] -= (mn-1);\n    /*for (int i: x) cout << i << \" \";\n    cout << \"\\n\";\n    cout << mn << \"\\n\";\n    exit(0);*/\n    pi t = solve(x);\n    return transform(t,mn);\n}\n\nint main() {\n    // cout << brute({1,2,})\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> N; h.resize(N);\n    F0R(i,N) {\n        // h[i] = rand() % 1000000000+1;\n        cin >> h[i];\n    }\n    cout << get(h).s;\n    // dp[x][1] = 2*(dp[a][1]*dp[b][1]*dp[c][1]*...)\n    // dp[x][0] = (dp[a][0]+2*dp[a][1])*(dp[b][0]+2*dp[b][1])*...*2^stuff-dp[x][1];\n}\n\n/* Look for:\n* the exact constraints (multiple sets are too slow for n=10^6 :( ) \n* special cases (n=1?)\n* overflow (ll vs int?)\n* array bounds\n*/"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\ntypedef long long LL;\nconst int Mod = 1000000007, Phi = Mod - 1, Inv2 = (Mod + 1) / 2;\nconst int MN = 105;\n\ninline LL pw(LL e) {\n\te = (e % Phi + Phi) % Phi;\n\tLL b = 2, a = 1;\n\tfor (; e; e >>= 1, b = b * b % Mod)\n\t\tif (e & 1) a = a * b % Mod;\n\treturn a;\n}\n\nint N, A[MN];\nint stk[MN], tp;\nLL B[MN], dp[MN];\n\ninline void Add(int i, LL x) {\n\tdp[i] = (dp[i] + x) % Mod;\n}\n\nint main() {\n\tscanf(\"%d\", &N), A[0] = A[N + 1] = 1, B[0] = 1;\n\tfor (int i = 1; i <= N; ++i) {\n\t\tscanf(\"%d\", &A[i]);\n\t\tB[i] = B[i - 1] + (A[i] > A[i - 1] ? A[i] - A[i - 1] : 0);\n\t}\n\tdp[0] = 1, stk[tp = 1] = 0;\n\tfor (int i = 1; i <= N + 1; ++i) {\n\t\twhile (tp && A[stk[tp]] >= A[i]) {\n\t\t\tint j = stk[tp];\n\t\t\tif (j != i - 1) {\n\t\t\t\tint k = stk[tp + 1];\n\t\t\t\tLL num2 = B[i - 1] - B[j];\n\t\t\t\tLL num1 = num2 - (A[k] - A[j]);\n\t\t\t\tAdd(i, 4 * (pw(num2) - pw(num1)) * dp[j]);\n\t\t\t} else Add(i, 2 * dp[j]);\n\t\t\t--tp;\n\t\t}\n\t\tif (tp) {\n\t\t\tint j = stk[tp];\n\t\t\tif (j != i - 1) {\n\t\t\t\tint k = stk[tp + 1];\n\t\t\t\tif (A[k] != A[i]) {\n\t\t\t\t\tLL num2 = B[i - 1] - B[j] - (A[i] - A[j]);\n\t\t\t\t\tLL num1 = num2 - (A[k] - A[i]);\n\t\t\t\t\tAdd(i, 4 * (pw(num2) - pw(num1)) * dp[j]);\n\t\t\t\t}\n\t\t\t} else Add(i, 2 * dp[j]);\n\t\t}\n\t\tstk[++tp] = i;\n\t}\n\tprintf(\"%lld\\n\", (dp[N + 1] + Mod) * Inv2 % Mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nint N;\nint H[105];\nll mo=1000000007;\n\nll modpow(ll a, ll n = mo-2) {\n\tll r=1;a%=mo;\n\twhile(n) r=r*((n%2)?a:1)%mo,a=a*a%mo,n>>=1;\n\treturn r;\n}\n\npair<ll,ll> hoge(int L,int R,int v) {\n\tll dp1=1,dp2=1;\n\tint i;\n\t\n\tif(L>R) return {0, 0};\n\t\n\tint mi=1<<30;\n\tfor(i=L;i<=R;i++) mi=min(mi,H[i]);\n\tint W=R-L+1;\n\tfor(i=L;i<=R;i++) if(mi!=H[i]) W--;\n\t\n\tint pre=L-1;\n\tfor(i=L;i<=R;i++) {\n\t\tif(mi==H[i]) {\n\t\t\tauto r=hoge(pre+1,i-1,mi);\n\t\t\tif(r.first>=0) {\n\t\t\t\t(dp1*=r.first)%=mo;\n\t\t\t\t(dp2*=r.first+r.second)%=mo;\n\t\t\t}\n\t\t\t\n\t\t\tpre=i;\n\t\t}\n\t}\n\tauto r=hoge(pre+1,R,mi);\n\tif(r.first>=0) {\n\t\t(dp1*=r.first)%=mo;\n\t\t(dp2*=r.first+r.second)%=mo;\n\t}\n\t\n\t(dp2=dp2*modpow(2,W)+(modpow(2,mi-v)+mo-2)*dp1)%=mo;\n\t(dp1*=modpow(2,mi-v))%=mo;\n\t\n\treturn {dp1,dp2};\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tfor(i=1;i<=N;i++) cin>>H[i];\n\tcout<<hoge(1,N,0).second<<endl;\n}\n\nint main()\n{\n        solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n\nconst int N = 1e6 + 10;\nconst int mod = 1e9 + 7;\nint h[N], st[N], top, n, ls[N], rs[N], root, f[N][2], num[N], single[N], mulsingle[N], rev[N], coe[N];\nbool bsin[N];\n\ninline void build()\n{\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tint k = top;\n\t\twhile (k > 0 && h[st[k]] > h[i]) k--;\n\t\tif (k) rs[st[k]] = i;\n\t\tif (k < top) ls[i] = st[k + 1];\n\t\tst[++k] = i;\n\t\ttop = k;\n\t}\n\troot = st[1];\n}\n\nvoid dfs(int x)\n{\n\tif (!x) return;\n\tcout << \"x \" << x << endl;\n\tdfs(ls[x]), dfs(rs[x]);\n}\n\ninline int fp(int a, int n)\n{\n\tint res = 1;\n\twhile (n)\n\t{\n\t\tif (n & 1) res = (res * a) % mod;\n\t\ta = (a * a) % mod;\n\t\tn >>= 1;\n\t}\n\treturn res % mod;\n}\n\ninline void fill(int *a, int siz, int val)\n{\n\tfor (int i = 1; i <= siz; i++)\ta[i] = val;\n}\n\ninline void dp(int x, int fa)\n{\n\tif (!x) return;\n\tnum[x] = 1;\n\trev[x] = 1;\n\tcoe[x] = 1;\n\tint height = h[x] - h[fa];\n\t// if (!rs[x] && !ls[x] && h[x] != h[fa])\n\t// {\n\t// \tsingle[x] = 1;\n\t// \tmulsingle[x] *= fp(2, height);\n\t// \treturn;\n\t// }\n\tif (!rs[x] && !ls[x] && h[x] == h[fa])\n\t\treturn;\n\tdp(ls[x], x);\n\tdp(rs[x], x);\n\t// if (ls[x] && x - ls[x] == 1) rev[x] += single[ls[x]];\n\t// if (rs[x] && rs[x] - x == 1) rev[x] += single[rs[x]];\n\t// if (ls[x]) mulsingle[x] *= mulsingle[ls[x]];\n\t// if (rs[x]) mulsingle[x] *= mulsingle[rs[x]]; \n\tif (ls[x] && h[ls[x]] == h[x]) rev[x] += rev[ls[x]], coe[x] = (coe[ls[x]] * coe[x]) % mod;\n\tif (rs[x] && h[rs[x]] == h[x]) rev[x] += rev[rs[x]], coe[x] = (coe[rs[x]] * coe[x]) % mod;\n\tif (f[ls[x]][1] == 0) ls[x] = 0;\n\tif (f[rs[x]][1] == 0) rs[x] = 0;\n\tif (h[x] != h[fa]) coe[x] = 2;\n\tif (height > 0)\n\t{\n\t\tif (rs[x] && ls[x])\n\t\t{\n\t\t\tf[x][1] = f[rs[x]][1] * f[ls[x]][1] % mod * fp(2, height) % mod;\n\t\t\t// cout << \"fk1 \" << f[rs[x]][1] << ' ' << f[ls[x]][1] << endl;\n\t\t\t// cout << \"fk0 \" << f[rs[x]][0] << ' ' << f[ls[x]][0] << endl;\n\t\t\tf[x][0] = (((f[rs[x]][1] * f[ls[x]][0] % mod * coe[rs[x]] * (fp(2, rev[x])) % mod + f[rs[x]][0] * f[ls[x]][1] % mod * coe[ls[x]] * (fp(2, rev[x])) % mod) % mod + f[rs[x]][0] * f[ls[x]][0] % mod * fp(2, rev[x]) % mod) % mod + f[rs[x]][1] * f[ls[x]][1] % mod * (coe[rs[x]] * coe[ls[x]] * (fp(2, rev[x])) - 2) % mod) % mod;\n\t\t}\n\t\telse if (rs[x])\n\t\t{\n\t\t\tf[x][1] = f[rs[x]][1] * fp(2, height) % mod;\n\t\t\tf[x][0] = (f[rs[x]][0] * fp(2, rev[x]) % mod + f[rs[x]][1] * ( coe[rs[x]] * fp(2, rev[x]) - 2) % mod) % mod;\n\t\t\t// cout << \"f[rs[x]][0] \" << f[rs[x]][0] << endl;\n\t\t\t// cout << \"f[rs[x]][1] \" << f[rs[x]][1] << endl;\n\t\t\t// cout << \"coe[rs[x]] \" << coe[rs[x]] << endl;\n\t\t\t// cout << \"rev[x] \" << rev[x] << endl;\n\t\t\t// cout << \"fk \" << f[x][0] << endl;\n\t\t}\n\t\telse if (ls[x])\n\t\t{\n\t\t\tf[x][1] = f[ls[x]][1] * fp(2, height) % mod;\n\t\t\tf[x][0] = (f[ls[x]][0] * fp(2, rev[x]) % mod + f[ls[x]][1] * ( coe[ls[x]] * fp(2, rev[x]) - 2) % mod) % mod;\n\t\t}\n\t\telse \n\t\t{\n\t\t\tf[x][1] = fp(2, height);\n\t\t\tf[x][0] = (fp(2, rev[x]) - 2) % mod;\n\t\t}\n\t}\t\n\telse \n\t{\n\t\tif (rs[x] && ls[x])\n\t\t{\n\t\t\tcoe[x] *= 4;\n\t\t\tf[x][1] = f[rs[x]][1] * f[ls[x]][1] % mod;\n\t\t\tf[x][0] = ((f[rs[x]][0] * f[ls[x]][0] % mod + f[rs[x]][1] * f[ls[x]][0] * coe[rs[x]] % mod) % mod + f[rs[x]][0] * f[ls[x]][1] * coe[ls[x]] % mod) % mod;\n\t\t}\n\t\telse if (rs[x])\n\t\t{\n\t\t\tf[x][1] = f[rs[x]][1];\n\t\t\tf[x][0] = f[rs[x]][0];\n\t\t\tif (h[rs[x]] != h[x])\n\t\t\tcoe[x] *= 2;\n\t\t}\n\t\telse if (ls[x])\n\t\t{\n\t\t\tf[x][1] = f[ls[x]][1];\n\t\t\tf[x][0] = f[ls[x]][0];\n\t\t\tif (h[ls[x]] != h[x])\n\t\t\tcoe[x] *= 2;\n\t\t}\n\t}\n\t// cout << \"x \" << x << endl;\n\t// cout << \"f[x][1] \" << f[x][1] << endl;\n\t// cout << \"f[x][0] \" << f[x][0] << endl;\n\t// cout << \"rev[x] \" << rev[x] << endl;\n\t// cout << \"coe[x] \" << coe[x] << endl;\n\tcoe[x] %= mod;\n}\n\nsigned main()\n{\n\tint ml = 0;\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++)\tcin >> h[i];\n\tif (n == 1)\n\t{\n\t\tcout << fp(2, h[1]) << endl;\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tif (h[i] > h[i - 1] && h[i] > h[i + 1]) ml += h[i] - max(h[i - 1], h[i + 1]), h[i] = max(h[i - 1], h[i + 1]);\n\tbuild();\n\tfill(mulsingle, n, 1);\n\tf[0][1] = f[0][0] = 1;\n\tdp(root, 0);\n\t// cout << \"mul \" << fp(2, ml) << endl;\n\tcout << (f[root][1] + f[root][0]) % mod * fp(2, ml) % mod << endl;\n\t// cout << \"1 \" << f[root][1] << endl;\n\t// cout << \"0 \" << f[root][0] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define all(x) (x).begin(), (x).end()\n#define itn int\n#define make_unique(x) sort((x).begin(), (x).end()); (x).erase(unique((x).begin(), (x).end()), (x).end())\n\nusing namespace std;\n\ninline int nxt() {\n\tint x;\n\tscanf(\"%d\", &x);\n\treturn x;\n}\n\nconst int mod = 1000000007;\nlong long pw(long long a, long long b) {\n\tlong long res = 1;\n\twhile (b) {\n\t\tif (b & 1ll) {\n\t\t\tres = res * a % mod;\n\t\t}\n\t\tb >>= 1;\n\t\ta = a * a % mod;\n\t}\n\treturn res;\n}\n\nconst int N = 111;\nlong long dp[N][N];\n\nlong long paintPidorski(int x) {\n\treturn (pw(2, x) - 1 + mod) % mod;\n}\n\nlong long getAnswer(vector<int> a) {\n\tint n = a.size();\n\n\tif (n == 1) {\n\t\treturn pw(2, a[0]);\n\t}\n\tauto b = a;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint x = 0;\n\t\tif (i < n - 1) {\n\t\t\tx = max(x, a[i + 1]);\n\t\t}\n\t\tif (i) {\n\t\t\tx = max(x, a[i - 1]);\n\t\t}\n\t\tb[i] = min(a[i], x);\n\t}\n\tlong long ans = 1;\n\tfor (int i = 0; i < n; ++i) {\n\t\tans = ans * pw(2, a[i] - b[i]) % mod;\n\t\ta[i] = b[i];\n\t}\n\n\tmake_unique(b);\n\tb.insert(b.begin(), 0);\n\tfor (int& x : a) {\n\t\tx = lower_bound(all(b), x) - b.begin();\n\t}\n\n\t// for (int x : b) {\n\t// \tcerr << x << \" \";\n\t// }\n\t// cerr << \"\\n\";\n\n\tmemset(dp, 0, sizeof(dp));\n\n\tfor (int i = 0; i < a[0]; ++i) {\n\t\tdp[0][i] = pw(2, b[a[0]] - b[i]);\n\t}\n\tdp[0][a[0]] = 2;\n\tfor (int i = 0; i < a[0]; ++i) {\n\t\tdp[0][i] -= dp[0][i + 1];\n\t}\n\t// for (int i = a[0]; i > 0; --i) {\n\t// \tdp[0][i] -= dp[0][i - 1];\n\t// }\n\tfor (int i = 0; i <= n; ++i) {\n\t\tdp[0][i] = (dp[0][i] % mod + mod) % mod;\n\t}\n\n\tfor (int i = 1; i < n; ++i) {\n\t\tfor (int j = 0; j <= a[i - 1]; ++j) {\n\t\t\tif (j < a[i - 1] && j < a[i]) {\n\t\t\t\tdp[i][j] += dp[i - 1][j] * pw(2, b[a[i]] - b[min(a[i], a[i - 1])]) % mod;\n\t\t\t\t// cerr << i << \" \" << j << \" \" << dp[i][j] << \" --\\n\";\n\t\t\t} else if (j < a[i - 1]) {\n\t\t\t\tdp[i][a[i]] += 2 * dp[i - 1][j];\n\t\t\t} else if (j < a[i]) {\n\t\t\t\t// dp[i][a[i]] += 2 * dp[i - 1][j];\n\t\t\t\t// for (int t = j; t < a[i]; ++t) {\n\t\t\t\t// \tdp[i][t] += 2 * dp[i - 1][j] * paintPidorski(b[a[i]] - b[t]) % mod;\n\t\t\t\t// }\n\t\t\t\tvector<long long> qw(a[i] + 1);\n\t\t\t\tfor (int t = j; t <= a[i]; ++t) {\n\t\t\t\t\tqw[t] = pw(2, b[a[i]] - b[t]);\n\t\t\t\t}\n\t\t\t\t// qw[a[i]] = 2;\n\t\t\t\t// for (auto x : qw) {\n\t\t\t\t// \tcerr << x << \" \";\n\t\t\t\t// }\n\t\t\t\t// cerr << \"--\\n\";\n\t\t\t\tfor (int t = j; t < a[i]; ++t) {\n\t\t\t\t\tqw[t] -= qw[t + 1];\n\t\t\t\t\tqw[t] = (qw[t] % mod + mod) % mod;\n\t\t\t\t}\n\t\t\t\tfor (int t = j; t <= a[i]; ++t) {\n\t\t\t\t\tdp[i][t] += qw[t] * 2 * dp[i - 1][j] % mod;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdp[i][a[i]] += 2 * dp[i - 1][j];\n\t\t\t}\n\t\t}\n\n\t\tfor (int j = 0; j <= a[i]; ++j) {\n\t\t\tdp[i][j] %= mod;\n\t\t}\n\t}\n\n\t// for (int i = 0; i < n; ++i) {\n\t// \tcerr << a[i] << \" \";\n\t// }\n\t// cerr << \"\\n\";\n\t// for (int i = 0; i < n; ++i) {\n\t// \tcerr << b[a[i]] << \" \";\n\t// }\n\t// cerr << \"\\n\\n\";\n\t// for (int i = 0; i < n; ++i) {\n\t// \tfor (int j = 0; j <= a[i]; ++j) {\n\t// \t\tcerr << dp[i][j] << \" \";\n\t// \t}\n\t// \tcerr << \"\\n\";\n\t// }\n\t// cerr << \"\\n\";\n\n\tlong long tmp = 0;\n\tfor (int i = 0; i <= a[n - 1]; ++i) {\n\t\ttmp += dp[n - 1][i];\n\t}\n\ttmp %= mod;\n\treturn ans * tmp % mod;\n}\n\nint main() {\n\tint n = nxt();\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\ta[i] = nxt();\n\t}\n\n\tlong long ans = 1;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (a[i] == 1) {\n\t\t\tans = ans * 2 % mod;\n\t\t} else {\n\t\t\tint j = i;\n\t\t\twhile (j < n && a[j] > 1) {\n\t\t\t\t++j;\n\t\t\t}\n\t\t\tans = ans * getAnswer(vector<int>(a.begin() + i, a.begin() + j)) % mod;\n\t\t\ti = j - 1;\n\t\t}\n\t}\n\n\tcout << ans << \"\\n\";\n\n\treturn 0;\n}\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE RecordWildCards #-}\n\nimport           Data.Function (on)\nimport           Data.List     (groupBy)\nimport           Data.Tree     (Tree (Node, rootLabel, subForest))\n\nimport Data.Monoid\n\nmain :: IO ()\nmain = interact $ show . f . getNumbers\n\ngetNumbers :: String -> [Int]\ngetNumbers input =\n  let\n    first : second : _ = lines input\n    n = read first\n  in\n    take n . map read . words $ second\n\nf :: [Height] -> Int\nf = getSum . (Sum . allPattern) . toTree\n\ntype Width = Int\ntype Height = Int\ntype RectangleTree = Tree (Width, Height)\n\ntoTree :: [Height] -> RectangleTree\ntoTree [] = error \"empty list\"\ntoTree [n] = Node { rootLabel = (1, n), subForest = [] }\ntoTree ns = Node { rootLabel = (width, minHeight), subForest = map toTree (scrape ns) }\n  where\n    minHeight = minimum ns\n    width = length ns\n\n    scrape :: [Height] -> [[Height]]\n    scrape = filter ((0 /=) . head) . groupBy ((==) `on` (0 ==)) . map (subtract minHeight)\n\n-- test1 :: Bool\n-- test1 = f (getNumbers input) == 12800\n--   where\n--     input = \"9\\\n-- \\2 3 5 4 1 2 4 2 1\"\n\nstripe :: RectangleTree -> Int\nstripe Node { rootLabel = (_, h), .. } = 2 ^ h * product (map stripe subForest)\n\nnotStripe :: RectangleTree -> Int\nnotStripe Node { rootLabel = (w, _), subForest = [] } = 2 ^ w - 2\nnotStripe Node { rootLabel = (w, h), .. } =\n  2 ^ (w - childrenTotalWidth subForest) * product (map stripe subForest)\n  where\n    childrenTotalWidth = sum . map (fst . rootLabel)\n\nallPattern :: RectangleTree -> Int\nallPattern t@Node { rootLabel = (w, _), subForest = [] } = stripe t + 2 ^ w - 2\nallPattern Node { rootLabel = (w, h), .. } =\n  2 ^ (w - childrenTotalWidth subForest) * product (map (\\t -> allPattern t + stripe t) subForest) +\n  (2 ^ h - 2) * product (map stripe subForest)\n  where\n    childrenTotalWidth = sum . map (fst . rootLabel)\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE RecordWildCards #-}\n\nimport           Data.Function (on)\nimport           Data.List     (groupBy)\nimport           Data.Tree     (Tree (Node, rootLabel, subForest))\n\nimport Data.Monoid\n\nmain :: IO ()\nmain = interact $ show . f . getNumbers\n\ngetNumbers :: String -> [Int]\ngetNumbers input =\n  let\n    first : second : _ = lines input\n    n = read first\n  in\n    take n . map read . words $ second\n\nf :: [Height] -> Int\nf = getSum . (Sum . stripe <> Sum . allPattern) . toTree\n\ntype Width = Int\ntype Height = Int\ntype RectangleTree = Tree (Width, Height)\n\ntoTree :: [Height] -> RectangleTree\ntoTree [] = error \"empty list\"\ntoTree [n] = Node { rootLabel = (1, n), subForest = [] }\ntoTree ns = Node { rootLabel = (width, minHeight), subForest = map toTree (scrape ns) }\n  where\n    minHeight = minimum ns\n    width = length ns\n\n    scrape :: [Height] -> [[Height]]\n    scrape = filter ((0 /=) . head) . groupBy ((==) `on` (0 ==)) . map (subtract minHeight)\n\n-- test1 :: Bool\n-- test1 = f (getNumbers input) == 12800\n--   where\n--     input = \"9\\\n-- \\2 3 5 4 1 2 4 2 1\"\n\nstripe :: RectangleTree -> Int\nstripe Node { rootLabel = (_, h), .. } = 2 ^ h * product (map stripe subForest)\n\nnotStripe :: RectangleTree -> Int\nnotStripe Node { rootLabel = (w, _), subForest = [] } = 2 ^ w - 2\nnotStripe Node { rootLabel = (w, h), .. } =\n  2 ^ (w - childrenTotalWidth subForest) * product (map stripe subForest)\n  where\n    childrenTotalWidth = sum . map (fst . rootLabel)\n\nallPattern :: RectangleTree -> Int\nallPattern t@Node { rootLabel = (w, _), subForest = [] } = stripe t + 2 ^ w - 2\nallPattern Node { rootLabel = (w, h), .. } =\n  2 ^ (w - childrenTotalWidth subForest) * product (map (\\t -> allPattern t) subForest) +\n  (2 ^ h - 2) * product (map stripe subForest)\n  where\n    childrenTotalWidth = sum . map (fst . rootLabel)\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE RecordWildCards #-}\n\nimport           Data.Function (on)\nimport           Data.List     (groupBy)\nimport           Data.Tree     (Tree (Node, rootLabel, subForest))\n\nimport Data.Monoid\n\nmain :: IO ()\nmain = interact $ show . f . getNumbers\n\ngetNumbers :: String -> [Int]\ngetNumbers input =\n  let\n    first : second : _ = lines input\n    n = read first\n  in\n    take n . map read . words $ second\n\nf :: [Height] -> Int\nf = getSum . (Sum . stripe <> Sum . allPattern) . toTree\n\ntype Width = Int\ntype Height = Int\ntype RectangleTree = Tree (Width, Height)\n\ntoTree :: [Height] -> RectangleTree\ntoTree [] = error \"empty list\"\ntoTree [n] = Node { rootLabel = (1, n), subForest = [] }\ntoTree ns = Node { rootLabel = (width, minHeight), subForest = map toTree (scrape ns) }\n  where\n    minHeight = minimum ns\n    width = length ns\n\n    scrape :: [Height] -> [[Height]]\n    scrape = filter ((0 /=) . head) . groupBy ((==) `on` (0 ==)) . map (subtract minHeight)\n\n-- test1 :: Bool\n-- test1 = f (getNumbers input) == 12800\n--   where\n--     input = \"9\\\n-- \\2 3 5 4 1 2 4 2 1\"\n\nstripe :: RectangleTree -> Int\nstripe Node { rootLabel = (_, h), .. } = 2 ^ h * product (map stripe subForest)\n\nnotStripe :: RectangleTree -> Int\nnotStripe Node { rootLabel = (w, _), subForest = [] } = 2 ^ w - 2\nnotStripe Node { rootLabel = (w, h), .. } =\n  2 ^ (w - childrenTotalWidth subForest) * product (map stripe subForest)\n  where\n    childrenTotalWidth = sum . map (fst . rootLabel)\n\nallPattern :: RectangleTree -> Int\nallPattern t@Node { rootLabel = (w, _), subForest = [] } = stripe t + 2 ^ w - 2\nallPattern Node { rootLabel = (w, h), .. } =\n  2 ^ (w - childrenTotalWidth subForest) * product (map (\\t -> allPattern t + stripe t) subForest) +\n  (2 ^ h - 2) * product (map stripe subForest)\n  where\n    childrenTotalWidth = sum . map (fst . rootLabel)\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE RecordWildCards #-}\n\nimport           Data.Function (on)\nimport           Data.List     (groupBy)\nimport           Data.Tree     (Tree (Node, rootLabel, subForest))\n\nimport Data.Monoid\n\nmain :: IO ()\nmain = interact $ show . f . getNumbers\n\ngetNumbers :: String -> [Int]\ngetNumbers input =\n  let\n    first : second : _ = lines input\n    n = read first\n  in\n    take n . map read . words $ second\n\nf :: [Height] -> Int\nf = getSum . (Sum . allPattern) . toTree\n\ntype Width = Int\ntype Height = Int\ntype RectangleTree = Tree (Width, Height)\n\ntoTree :: [Height] -> RectangleTree\ntoTree [] = error \"empty list\"\ntoTree [n] = Node { rootLabel = (1, n), subForest = [] }\ntoTree ns = Node { rootLabel = (width, minHeight), subForest = map toTree (scrape ns) }\n  where\n    minHeight = minimum ns\n    width = length ns\n\n    scrape :: [Height] -> [[Height]]\n    scrape = filter ((0 /=) . head) . groupBy ((==) `on` (0 ==)) . map (subtract minHeight)\n\n-- test1 :: Bool\n-- test1 = f (getNumbers input) == 12800\n--   where\n--     input = \"9\\\n-- \\2 3 5 4 1 2 4 2 1\"\n\nstripe :: RectangleTree -> Int\nstripe Node { rootLabel = (_, h), .. } = 2 ^ h * product (map stripe subForest)\n\nnotStripe :: RectangleTree -> Int\nnotStripe Node { rootLabel = (w, _), subForest = [] } = 2 ^ w - 2\nnotStripe Node { rootLabel = (w, h), .. } =\n  2 ^ (w - childrenTotalWidth subForest) * product (map stripe subForest)\n  where\n    childrenTotalWidth = sum . map (fst . rootLabel)\n\nallPattern :: RectangleTree -> Int\nallPattern t@Node { rootLabel = (w, _), subForest = [] } = stripe t + 2 ^ w - 2\nallPattern Node { rootLabel = (w, h), .. } =\n  2 ^ (w - childrenTotalWidth subForest) * product (map (\\t -> allPattern t) subForest) +\n  (2 ^ h - 2) * product (map stripe subForest)\n  where\n    childrenTotalWidth = sum . map (fst . rootLabel)\n"
  },
  {
    "language": "Text",
    "code": "aaaa\naaab\naaba\naabb\naabc\nabaa\nabab\nabac\nabba\nabbb\nabbc\nabca\nabcb\nabcc\nabcd"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#define ll long long\n#define rep(i,l,r)for(ll i=(l);i<(r);i++)\n#define repp(i,l,r,k)for(ll i=(l);i<(r);i+=(k))\n#define INF ((1LL<<62)-(1LL<<31))\n#define max(p,q)((p)>(q)?(p):(q))\n#define min(p,q)((p)<(q)?(p):(q))\n#define bit(n,m)((n>>m)&1)\nint upll(const void*a, const void*b){return*(ll*)a<*(ll*)b?-1:*(ll*)a>*(ll*)b?1:0;}\nint downll(const void*a, const void*b){return*(ll*)a<*(ll*)b?1:*(ll*)a>*(ll*)b?-1:0;}\nvoid sortup(ll*a,int n){qsort(a,n,sizeof(ll),upll);}\nvoid sortdown(ll*a,int n){qsort(a,n,sizeof(ll),downll);}\nll pom(ll a,ll n,int m){ll x=1;for(a%=m;n;n/=2)n&1?x=x*a%m:0,a=a*a%m;return x;}\n\n#define MOD 1000000007\n\nll n,h[110];\n\nll f(ll l,ll r,ll foot,ll*a,ll*b){\n\tll m=h[l];\n\trep(i,l,r)m=min(m,h[i]);\n\tll mcnt=0;\n\trep(i,l,r)if(h[i]==m)mcnt++;\n\t\n\tll aa[110],bb[110],cnt=0;\n\tll left=l;\n\twhile(left<r){\n\t\twhile(left<r&&h[left]==m)left++;\n\t\tif(left==r)break;\n\t\tll right=left;\n\t\twhile(right<r&&h[right]!=m)right++;\n\t\tf(left,right,m,aa+cnt,bb+cnt);\n\t\tcnt++;\n\t\tleft=right;\n\t}\n\n\tif(cnt){\n\t\t*a=1;\n\t\trep(i,0,cnt)*a=*a*(aa[i]+2*bb[i])%MOD;\n\t\t*a=*a*pom(2,mcnt,MOD)%MOD;\n\t\t*b=1;\n\t\trep(i,0,cnt)*b=*b*bb[i]%MOD;\n\t\t*a=(*a-2**b+MOD+MOD)%MOD;\n\t\t*b=*b*pom(2,m-foot,MOD);\n\t}else{\n\t\t*a=(pom(2,r-l,MOD)-2+MOD)%MOD;\n\t\t*b=pom(2,m-foot,MOD);\n\t}\n}\n\nint main(){\n\tscanf(\"%lld\",&n);\n\trep(i,0,n)scanf(\"%lld\",h+i);\n\tll a,b;\n\tf(0,n,0,&a,&b);\n\tprintf(\"%lld\\n\",(a+b)%MOD);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define mod 1000000007\n#define llinf 4154118101919364364\n\nlong long llmax(long long a,long long b){if(a>b){return a;}return b;}\nlong long llmin(long long a,long long b){if(a<b){return a;}return b;}\n\nlong long power(long long a,long long b){\n  long long x=1,y=a;\n  while(b>0){\n    if(b&1ll){\n      x=(x*y)%mod;\n    }\n    y=(y*y)%mod;\n    b>>=1;\n  }\n  return x%mod;\n}\n\nlong long modular_inverse(long long n){\n  return power(n,mod-2);\n}\n\nlong long mod_nomalize(long long x){\n  if(x>=0){return x%mod;}\n  x*=-1;x%=mod;x=mod-x;\n  if(x==mod){x=0;}\n  return x;\n}\n\n//dp[seg][flag(Should the undermost RBRB... or BRBR...? 1...yes 0...free)]\nlong long dp[128][128][2];\nlong long h[128];\nlong long inv2;\nlong long rep(long long st,long long fi,long long pch){\n  long long i,dvd=llinf,mxm=-llinf,ns,ndt=fi-st+1;\n  dp[st][fi][0]=1;\n  dp[st][fi][1]=1;\n  for(i=st;i<=fi;i++){\n    dvd=llmin(h[i],dvd);\n    mxm=llmax(h[i],mxm);\n  }\n  ns=st;\n  for(i=st;i<=fi+1;i++){\n    if(h[i]==dvd || i==fi+1){\n      if(ns<=i-1){\n        rep(ns,i-1,dvd);\n        ndt-=((i-1)-ns+1);\n        dp[st][fi][1]*=(dp[ns][i-1][1]);\n        dp[st][fi][1]%=mod;\n        dp[st][fi][0]*=(dp[ns][i-1][0]+dp[ns][i-1][1]);\n        dp[st][fi][0]%=mod;\n      }\n      ns=i+1;\n    }\n  }\n\n  //free : 2^(now determine)\n  dp[st][fi][0]*=power(2,ndt);dp[st][fi][0]%=mod;\n  //RBRB... or BRBR... Already counted = 2\n  //                   Should be counted = 2^(height)\n  dp[st][fi][0]+=mod_nomalize(dp[st][fi][1]*mod_nomalize(power(2,dvd-pch)-2));dp[st][fi][0]%=mod;\n\n  //RBRB... or BRBR... : 2^height\n  dp[st][fi][1]*=power(2,dvd-pch);dp[st][fi][1]%=mod;\n  return dp[st][fi][0];\n}\n\nint main(){\n  inv2=modular_inverse(2);\n  long long i,j;\n  long long n;\n  long long dp[128]={0},k;\n  long long tg[128],tgc,p,sig;\n  scanf(\"%lld\",&n);\n  //for(i=0;i<128;i++){\n  //  dp[i][j][0]=-1;\n  //  dp[i][j][1]=-1;\n  //}\n  for(i=1;i<=n;i++){\n    scanf(\"%lld\",&h[i]);\n  }\n  printf(\"%lld\\n\",rep(1,n,0));\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<map>\n#include<vector>\n#include<queue>\n#include<deque>\n#define ll long long\n#define mp make_pair\n#define rep(i,x,y) for(int i=(x);i<=(y);++i)\n#define r0p(i,n) for(int i=0;i<n;++i)\n#pragma GCC optimize(1)\n#pragma G++ optimize(1)\n#pragma GCC optimize(2)\n#pragma G++ optimize(2)\n#pragma GCC optimize(3)\n#pragma G++ optimize(3)\n#pragma GCC optimize(\"-funsafe-loop-optimizations\")\n#pragma GCC optimize(\"-funroll-loops\")\n#pragma GCC optimize(\"-fwhole-program\")\n#pragma GCC optimize(\"-fthread-jumps\")\n#pragma GCC optimize(\"-falign-functions\")\n#pragma GCC optimize(\"-falign-jumps\")\n#pragma GCC optimize(\"-falign-loops\")\n#pragma GCC optimize(\"-falign-labels\")\n#pragma GCC optimize(\"-fcaller-saves\")\n#pragma GCC optimize(\"-fcrossjumping\")\n#pragma GCC optimize(\"-fcse-follow-jumps\")\n#pragma GCC optimize(\"-fcse-skip-blocks\")\n#pragma GCC optimize(\"-fdelete-null-pointer-checks\")\n#pragma GCC optimize(\"-fexpensive-optimizations\")\n#pragma GCC optimize(\"-fgcse\")\n#pragma GCC optimize(\"-fgcse-lm\")\n#pragma GCC optimize(\"-finline-small-functions\")\n#pragma GCC optimize(\"-findirect-inlining\")\n#pragma GCC optimize(\"-foptimize-sibling-calls\")\n#pragma GCC optimize(\"-fpeephole2\")\n#pragma GCC optimize(\"-freorder-blocks\")\n#pragma GCC optimize(\"-freorder-functions\")\n#pragma GCC optimize(\"-frerun-cse-after-loop\")\n#pragma GCC optimize(\"-fsched-interblock\")\n#pragma GCC optimize(\"-fsched-spec\")\n#pragma GCC optimize(\"-fschedule-insns\")\n#pragma GCC optimize(\"-fschedule-insns2\")\n#pragma GCC optimize(\"-fstrict-aliasing\")\n#pragma GCC optimize(\"-fstrict-overflow\")\n#pragma GCC optimize(\"-ftree-switch-conversion\")\n#pragma GCC optimize(\"-ftree-pre\")\n#pragma GCC optimize(\"-ftree-vrp\")\n#define pii pair<int,int>\n#pragma GCC diagnostic error \"-std=c++11\"\nusing namespace std;\ninline void rdl(long long &val){\n    long long x=0;\n    int f=1;\n    char ch=getchar();\n    while((ch<'0' or ch>'9') and ch!='-') ch=getchar();\n    if(ch=='-'){\n        f=-1;\n        ch=getchar();\n\t}\n\twhile(ch>='0' and ch<='9'){\n\t    x=(x<<3)+(x<<1)+ch-'0';\n\t\tch=getchar();\n\t}\n    val=x*f;\n}\ninline void rdi(int &val){\n    int x=0;\n    int f=1;\n    char ch=getchar();\n    while((ch<'0' or ch>'9') and ch!='-') ch=getchar();\n    if(ch=='-'){\n        f=-1;\n        ch=getchar();\n    }\n    while(ch>='0' and ch<='9'){\n        x=(x<<3)+(x<<1)+ch-'0';\n        ch=getchar();\n    }\n    val=x*f;\n}\ninline long long rdl(){\n    long long x=0;\n    int f=1;\n    char ch=getchar();\n    while((ch<'0' or ch>'9') and ch!='-') ch=getchar();\n    if(ch=='-'){\n        f=-1;\n        ch=getchar();\n    }\n    while(ch>='0' and ch<='9'){\n        x=(x<<3)+(x<<1)+ch-'0';\n        ch=getchar();\n    }\n    return x*f;\n}\ninline int rdi(){\n    int x=0;\n    int f=1;\n\tchar ch=getchar();\n\twhile((ch<'0' or ch>'9') and ch!='-') ch=getchar();\n\tif(ch=='-'){\n        f=-1;\n        ch=getchar();\n    }\n    while(ch>='0' and ch<='9'){\n        x=(x<<3)+(x<<1)+ch-'0';\n        ch=getchar();\n    }\n    return x*f;\n}\ninline void write(int x){\n    if(x<0) putchar('-'),x=-x;\n    if(x>9) write(x/10);\n    putchar(x%10+'0');\n}\ninline void _write(int x){\n\twrite(x);\n\tputchar(' ');\n}\ninline void print(int x){\n\twrite(x);\n\tputchar('\\n');\n}\ninline void write(ll x){\n    if(x<0) putchar('-'),x=-x;\n    if(x>9) write(x/10);\n    putchar(x%10+'0');\n}\ninline void _write(ll x){\n\twrite(x);\n\tputchar(' ');\n}\ninline void print(ll x){\n\twrite(x);\n\tputchar('\\n');\n}\nconst int md=1000000007;\ninline int qp(int a,ll b){\n\tint rt=1;\n\twhile(b){\n\t\tif(b&1) rt=(rt*a)%md;\n\t\ta=(a*a)%md;\n\t\tb>>=1; \n\t}\n\treturn rt;\n}\nint w[111],n,dp[111];\nint main(){\n\tint i,j,k;\n\trdi(n);\n\tfor(i=1;i<=n;++i) rdi(w[i]);\n\tdp[0]=1;\n\tw[n+1]=1;\n\tfor(i=1;i<n+2;++i){\n\t\tdp[i]=dp[i-1]*2%md;\n\t\tfor(j=1;j<i;++j){\n\t\t\tint t=max(w[i],w[j-1]),mn=w[j]-1;\n\t\t\tll sum=0;\n\t\t\tfor(k=j;k<i;++k) mn=min(mn,w[k]-1),sum+=max(w[k+1]-w[k],0);\n\t\t\tif(t<=mn){\n\t\t\t\tint t1=qp(2,w[j]-1-mn);\n\t\t\t\tint t2=qp(2,mn-t+1)-1;\n\t\t\t\tint t3=qp(2,sum);\n\t\t\t\tdp[i]=(dp[i]+4ll*dp[j-1]*t1%md*t2%md*t3)%md;\n\t\t\t}\n\t\t}\n\t}\n\tprint(dp[n+1]*500000004ll%md);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#define ll long long\n#define rep(i,l,r)for(ll i=(l);i<(r);i++)\n#define repp(i,l,r,k)for(ll i=(l);i<(r);i+=(k))\n#define INF ((1LL<<62)-(1LL<<31))\n#define max(p,q)((p)>(q)?(p):(q))\n#define min(p,q)((p)<(q)?(p):(q))\n#define bit(n,m)((n>>m)&1)\nint upll(const void*a, const void*b){return*(ll*)a<*(ll*)b?-1:*(ll*)a>*(ll*)b?1:0;}\nint downll(const void*a, const void*b){return*(ll*)a<*(ll*)b?1:*(ll*)a>*(ll*)b?-1:0;}\nvoid sortup(ll*a,int n){qsort(a,n,sizeof(ll),upll);}\nvoid sortdown(ll*a,int n){qsort(a,n,sizeof(ll),downll);}\nll pom(ll a,ll n,int m){ll x=1;for(a%=m;n;n/=2)n&1?x=x*a%m:0,a=a*a%m;return x;}\n\n#define MOD 1000000007\n\nll n,h[110];\n\nll f(ll l,ll r,ll foot,ll*a,ll*b){\n\tll m=h[l];\n\trep(i,l,r)m=min(m,h[i]);\n\tll mcnt=0;\n\trep(i,l,r)if(h[i]==m)mcnt++;\n\t\n\tll aa[110],bb[110],cnt=0;\n\tll left=l;\n\twhile(left<r){\n\t\twhile(left<r&&h[left]==m)left++;\n\t\tif(left==r)break;\n\t\tll right=left;\n\t\twhile(right<r&&h[right]!=m)right++;\n\t\tf(left,right,m,aa+cnt,bb+cnt);\n\t\tcnt++;\n\t\tleft=right;\n\t}\n\n\tif(cnt){\n\t\t*a=1;\n\t\trep(i,0,cnt)*a=*a*(aa[i]+2*bb[i])%MOD;\n\t\t*a=*a*pom(2,mcnt,MOD)%MOD;\n\t\t*b=1;\n\t\trep(i,0,cnt)*b=*b*bb[i]%MOD;\n\t\t*a=(*a-2**b+MOD+MOD)%MOD;\n\t\t*b=*b*pom(2,m-foot,MOD)%MOD;\n\t}else{\n\t\t*a=(pom(2,r-l,MOD)-2+MOD)%MOD;\n\t\t*b=pom(2,m-foot,MOD);\n\t}\n}\n\nint main(){\n\tscanf(\"%lld\",&n);\n\trep(i,0,n)scanf(\"%lld\",h+i);\n\tll a,b;\n\tf(0,n,0,&a,&b);\n\tprintf(\"%lld\\n\",(a+b)%MOD);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(void)\n{\n\nreturn 0;\n\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define int long long\n#define p (int)(1e9 + 7)\n#define inf (int)(1e18)\n\nint MOD(int a){\n\ta %= p;\n\treturn a >= 0 ? a : a + p;\n}\n\nint power(int a, int N){\n\tif(N == 0){\n\t\treturn 1;\n\t}\n\telse if(N % 2 == 0){\n\t\treturn power(MOD(a * a), N / 2);\n\t}\n\telse{\n\t\treturn MOD(a * power(a, N - 1));\n\t}\n}\n\nsigned compare(const void *a, const void *b){\n\tint sub = *(int *)a - *(int *)b;\n\tif(sub < 0){\n\t\treturn -1;\n\t}\n\telse if(sub == 0){\n\t\treturn 0;\n\t}\n\telse{\n\t\treturn 1;\n\t}\n}\n\nint h_to_sec(int x, int *hsub, int H){\n\tint l = -1, h, r = H;\n\twhile(r - l > 1){\n\t\th = (l + r) / 2;\n\t\tif(hsub[h] < x){\n\t\t\tl = h;\n\t\t}\n\t\telse{\n\t\t\tr = h;\n\t\t}\n\t}\n\treturn r;\n}\n\nsigned main(){\n\tint N, H, i, j;\n\tscanf(\"%lld\", &N);\n\tint *h = (int *)malloc(sizeof(int) * N);\n\tint *hsub = (int *)malloc(sizeof(int) * (N + 1));\n\tfor(i = 0; i < N; i++){\n\t\tscanf(\"%lld\", &h[i]);\n\t\th[i]--;\n\t\thsub[i] = h[i];\n\t}\n\tqsort(hsub, N, sizeof(int), compare);\n\thsub[N] = inf;\n\tfor(H = 0, i = 0; i < N; H++){\n\t\thsub[H] = hsub[i];\n\t\twhile(hsub[H] == hsub[i]){\n\t\t\ti++;\n\t\t}\n\t}\n\tint *left = (int *)malloc(sizeof(int) * H);\n\tint *right = (int *)malloc(sizeof(int) * H);\n\tfor(i = 0; i < H; i++){\n\t\tright[i] = hsub[i];\n\t}\n\tleft[0] = 0;\n\tfor(i = 1; i < H; i++){\n\t\tleft[i] = hsub[i - 1];\n\t}\n/*\tfor(i = 0; i < H; i++){\n\t\tprintf(\"section[%lld] = [%lld, %lld)\\n\", i, left[i], right[i]);\n\t}\n\tprintf(\"\\n\");\n*/\tint *dp = (int *)malloc(sizeof(int) * N);\n\tint **dp2 = (int **)malloc(sizeof(int *) * N);\n\tint *sec = (int *)malloc(sizeof(int) * N);\n\tfor(i = 0; i < N; i++){\n\t\tsec[i] = h_to_sec(h[i], hsub, H);\n//\t\tprintf(\"sec[%lld] = %lld\\n\", i, sec[i]);\n\t\tdp2[i] = (int *)malloc(sizeof(int) * (sec[i] + 1));\n\t}\n//\tprintf(\"\\n\");\n\tfor(j = 0; j <= sec[0]; j++){\n\t\tdp2[0][j] = MOD(power(2, h[0] - left[j] + 1) - power(2, h[0] - right[j] + 1));\n\t}\n\tdp[0] = 2;\n/*\tprintf(\"dp[0] = %lld\\n\", dp[0]);\n\tfor(j = 0; j <= sec[0]; j++){\n\t\tprintf(\"dp2[0][%lld] = %lld\\n\", j, dp2[0][j]);\n\t}\n\tprintf(\"\\n\");\n*/\tfor(i = 1; i < N; i++){\n//\t\tprintf(\"i = %lld\\n\", i);\n\t\tif(h[i] >= h[i - 1]){\n//\t\t\tprintf(\"test3\\n\");\n\t\t\tdp[i] = MOD(2 * dp[i - 1]);\n\t\t\tfor(j = 0; j <= sec[i - 1]; j++){\n\t\t\t\tdp2[i][j] = MOD(dp2[i - 1][j] * power(2, h[i] - h[i - 1]));\n\t\t\t}\n\t\t\tfor(j = j; j <= sec[i]; j++){\n\t\t\t\tdp2[i][j] = MOD(dp[i - 1] * MOD(power(2, h[i] - left[j] + 1) - power(2, h[i] - right[j] + 1)));\n\t\t\t}\n\t\t}\n\t\telse{\n//\t\t\tprintf(\"tesst4\\n\");\n\t\t\tdp[i] = dp[i - 1];\n\t\t\tfor(j = sec[i] + 1; j <= sec[i - 1]; j++){\n\t\t\t\tdp[i] = MOD(dp[i] + dp2[i - 1][j]);\n\t\t\t}\n\t\t\tdp[i] = MOD(2 * dp[i]);\n\t\t\tfor(j = 0; j <= sec[i]; j++){\n\t\t\t\tdp2[i][j] = dp2[i - 1][j];\n\t\t\t}\n\t\t}\n/*\t\tprintf(\"dp[%lld] = %lld\\n\", i, dp[i]);\n\t\tfor(j = 0; j <= sec[i]; j++){\n\t\t\tprintf(\"dp2[%lld][%lld] = %lld\\n\", i, j, dp2[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n*/\t}\n\tint ans = dp[N - 1];\n\tfor(j = 0; j <= sec[N - 1]; j++){\n\t\tans = MOD(ans + dp2[N - 1][j]);\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "Kotlin",
    "code": "const val P = 1000000007L\n\nclass FiniteField(xRaw: Long) {\n  val x = if (xRaw >= 0) xRaw % P else (P - ((-xRaw) % P)) % P\n  constructor(xi: Int): this(xi.toLong())\n  operator fun plus(o: Long) = FiniteField((x + o) % P)\n  operator fun plus(o: FiniteField) = this + o.x\n  operator fun minus(o: Long) = FiniteField((x + P - o) % P)\n  operator fun minus(o: FiniteField) = this - o.x\n  operator fun times(o: Long) = FiniteField((x * o) % P)\n  operator fun times(o: FiniteField) = this * o.x\n  override fun toString() = x.toString()\n}\n\nfun powerOfTwo(p: Int): FiniteField {\n  if (p == 0) return FiniteField(1)\n  val a = powerOfTwo(p / 2)\n  return a * a * if (p % 2 == 1) FiniteField(2) else FiniteField(1)\n}\n\nfun solve(hs: List<Int>): Pair<FiniteField, FiniteField> {\n  // println(hs)\n  val hMin = hs.min()!!\n  if (hs.all { it == hMin }) {\n    val w = hs.size\n    val v1 = powerOfTwo(w) + powerOfTwo(hMin) - 2\n    val v2 = powerOfTwo(hMin)\n    return Pair(v1, v2)\n  } else {\n    // Fill this.\n    val r = hs.count { it == hMin }\n\n    var p1 = FiniteField(1)\n    var p2 = FiniteField(1)\n    val childHs = mutableListOf<Int>()\n    for (h in hs) {\n      if (h == hMin) {\n        if (childHs.size > 0) {\n          val (c1, c2) = solve(childHs)\n          p1 *= c1 + c2\n          p2 *= c2\n          childHs.clear()\n        }\n      } else {\n        childHs.add(h - hMin)\n      }\n    }\n    if (childHs.size > 0) {\n      val (c1, c2) = solve(childHs)\n      p1 *= c1 + c2\n      p2 *= c2\n      childHs.clear()\n    }\n\n    val v1 = p1 * powerOfTwo(r) + (powerOfTwo(hMin) - 2) * p2\n    val v2 = powerOfTwo(hMin) * p2\n    return Pair(v1, v2)\n  }\n}\n\nfun main(args: Array<String>) {\n  val n = readLine()!!.toInt()\n  val hs = readLine()!!.split(\" \").map { it.toInt() }\n  println(solve(hs).first)\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\tstatic int mod = 1000000007;\n\tstatic long i2 = invl(2, mod);\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni();\n\t\tint[] a = na(n);\n\t\tlong[] res = dfs(0, n, 0, a);\n\t\tlong ans = res[0] + res[1];\n\t\tout.println(ans%mod);\n\t}\n\t\n\t// [shima,all]\n\tstatic long[] dfs(int l, int r, int ph, int[] a)\n\t{\n\t\tif(l >= r)return null;//new long[]{1, 1};\n\t\t\n\t\tif(r - l == 1){\n//\t\t\ttr(l, r, pow(2, a[l] - ph, mod), 0L);\n\t\t\treturn new long[]{pow(2, a[l] - ph, mod), 0L};\n\t\t}\n\t\t\n\t\tint min = Integer.MAX_VALUE;\n\t\tfor(int i = l;i < r;i++){\n\t\t\tmin = Math.min(min, a[i]);\n\t\t}\n\t\t\n\t\tint pre = l;\n\t\tlong rets = 1;\n\t\tlong retall = 1;\n\t\tint minct = 0;\n\t\tfor(int i = l;i < r;i++){\n\t\t\tif(a[i] == min){\n\t\t\t\tminct++;\n\t\t\t\tif(i-pre > 0){\n\t\t\t\t\tlong[] res = dfs(pre, i, min, a);\n\t\t\t\t\trets = rets * res[0] % mod;\n\t\t\t\t\tretall = retall * (res[0]*2 + res[1]) % mod;\n\t\t\t\t}\n\t\t\t\tpre = i+1;\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tif(r-pre > 0){\n\t\t\t\tlong[] res = dfs(pre, r, min, a);\n\t\t\t\trets = rets * res[0] % mod;\n\t\t\t\tretall = retall * (res[0]*2 + res[1]) % mod;\n\t\t\t}\n\t\t}\n//\t\ttr(rets, retall);\n\t\trets = rets * 2 % mod;\n\t\tretall = retall * pow(2, minct, mod) % mod;\n\t\tretall += mod - rets;\n\t\tretall %= mod;\n\t\tint h = min - ph;\n\t\tassert h > 0;\n\t\trets = rets * pow(2, h-1 ,mod) % mod;\n//\t\ttr(l, r, rets, retall, minct);\n\t\treturn new long[]{rets, retall};\n\t}\n\t\n\tpublic static long pow(long a, long n, long mod) {\n\t\t//\t\ta %= mod;\n\t\tlong ret = 1;\n\t\tint x = 63 - Long.numberOfLeadingZeros(n);\n\t\tfor (; x >= 0; x--) {\n\t\t\tret = ret * ret % mod;\n\t\t\tif (n << 63 - x < 0)\n\t\t\t\tret = ret * a % mod;\n\t\t}\n\t\treturn ret;\n\t}\n\n\t\n\tpublic static long invl(long a, long mod) {\n\t\tlong b = mod;\n\t\tlong p = 1, q = 0;\n\t\twhile (b > 0) {\n\t\t\tlong c = a / b;\n\t\t\tlong d;\n\t\t\td = a;\n\t\t\ta = b;\n\t\t\tb = d % b;\n\t\t\td = p;\n\t\t\tp = q;\n\t\t\tq = d - c * q;\n\t\t}\n\t\treturn p < 0 ? p + mod : p;\n\t}\n\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import static java.lang.Integer.parseInt;\nimport static java.lang.Long.parseLong;\nimport static java.lang.Math.min;\nimport static java.lang.System.exit;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tstatic final int MOD = 1000000007;\n\n\tstatic int add(int a, int b) {\n\t\tint res = a + b;\n\t\treturn res >= MOD ? res - MOD : res;\n\t}\n\n\tstatic int sub(int a, int b) {\n\t\tint res = a - b;\n\t\treturn res < 0 ? res + MOD : res;\n\t}\n\n\tstatic int mul(int a, int b) {\n\t\tint res = (int) ((long) a * b % MOD);\n\t\treturn res < 0 ? res + MOD : res;\n\t}\n\n\tstatic int pow(int a, int e) {\n\t\tif (e == 0) {\n\t\t\treturn 1;\n\t\t}\n\t\tint r = a;\n\t\tfor (int i = 30 - Integer.numberOfLeadingZeros(e); i >= 0; i--) {\n\t\t\tr = mul(r, r);\n\t\t\tif ((e & (1 << i)) != 0) {\n\t\t\t\tr = mul(r, a);\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int h[];\n\n\tstatic void solve() throws Exception {\n\t\tint n = scanInt();\n\t\th = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\th[i] = scanInt();\n\t\t}\n\t\tout.print(solve(0, n, 0));\n\t}\n\n\tstatic int resAlt;\n\tstatic int solve(int from, int to, int level) {\n\t\tint nextLevel = Integer.MAX_VALUE;\n\t\tfor (int i = from; i < to; i++) {\n\t\t\tnextLevel = min(nextLevel, h[i]);\n\t\t}\n\t\tint rTotal = 1, rAlt = 2;\n\t\tfor (int i = from, j; i < to;) {\n\t\t\tif (h[i] == nextLevel) {\n\t\t\t\trTotal = add(rTotal, rTotal);\n\t\t\t\t++i;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (j = i + 1; j < to && h[j] != nextLevel; j++) { }\n\t\t\tint curTotal = solve(i, j, nextLevel);\n\t\t\tint curAlt = resAlt;\n\t\t\trTotal = mul(rTotal, add(curTotal, curAlt));\n\t\t\trAlt = mul(rAlt, curAlt);\n\t\t\ti = j;\n\t\t}\n\t\trTotal = sub(rTotal, rAlt);\n\t\trAlt = mul(rAlt, pow(2, nextLevel - level - 1));\n\t\trTotal = add(rTotal, rAlt);\n\t\tresAlt = rAlt;\n\t\treturn rTotal;\n\t}\n\n\tstatic int scanInt() throws IOException {\n\t\treturn parseInt(scanString());\n\t}\n\n\tstatic long scanLong() throws IOException {\n\t\treturn parseLong(scanString());\n\t}\n\n\tstatic String scanString() throws IOException {\n\t\twhile (tok == null || !tok.hasMoreTokens()) {\n\t\t\ttok = new StringTokenizer(in.readLine());\n\t\t}\n\t\treturn tok.nextToken();\n\t}\n\n\tstatic BufferedReader in;\n\tstatic PrintWriter out;\n\tstatic StringTokenizer tok;\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(System.out);\n\t\t\tsolve();\n\t\t\tin.close();\n\t\t\tout.close();\n\t\t} catch (Throwable e) {\n\t\t\te.printStackTrace();\n\t\t\texit(1);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in Actual solution is at the top\n *\n * @author ilyakor\n */\npublic class Main {\n\n  public static void main(String[] args) {\n    InputStream inputStream = System.in;\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    OutputWriter out = new OutputWriter(outputStream);\n    TaskD solver = new TaskD();\n    solver.solve(1, in, out);\n    out.close();\n  }\n\n  static class TaskD {\n\n    static final int mod = 1000 * 1000 * 1000 + 7;\n    int n;\n    int[] h;\n\n    public void solve(int testNumber, InputReader in, OutputWriter out) {\n      n = in.nextInt();\n      h = new int[n + 1];\n      for (int i = 0; i < n; ++i) {\n        h[i] = in.nextInt();\n      }\n      h[n] = 1;\n\n      // long[][] d = new long[n + 1][];\n      // d[n] = new long[]{1};\n      // for (int i = n - 1; i >= 0; --i) {\n      //     d[i] = new long[h[i]];\n      //     int rem = h[i] - h[i + 1];\n      //     if (rem <= 0) {\n      //         for (int j = 0; j < h[i + 1]; ++j) {\n      //             if (j < h[i + 1] - 1 && j < h[i] - 1) {\n      //                 d[i][j] += d[i + 1][j];\n      //                 d[i][j] %= mod;\n      //             } else {\n      //                 d[i][h[i] - 1] += 2L * d[i + 1][j];\n      //                 d[i][h[i] - 1] %= mod;\n      //             }\n      //         }\n      //     } else {\n      //         for (int j = 0; j < h[i]; ++j) {\n      //             if (j < h[i + 1] - 1 && j < h[i] - 1) {\n      //                 d[i][j] += d[i + 1][j] * IntegerUtils.pow(2, rem, mod);\n      //                 d[i][j] %= mod;\n      //             } else {\n      //                 int arem = h[i] - j - 2;\n      //                 if (arem < 0) arem = 0;\n      //                 d[i][j] += d[i + 1][h[i + 1] - 1] * IntegerUtils.pow(2, arem + 1, mod);\n      //                 d[i][j] %= mod;\n      //             }\n      //         }\n      //     }\n      // }\n      // long res = 0;\n      // for (int i = 0; i < h[0]; ++i) {\n      //     res += d[0][i];\n      //     res %= mod;\n      // }\n\n      TaskD.Seg[] D = new TaskD.Seg[]{new TaskD.Seg(0, 0, 1L, 1L)};\n      for (int i = n - 1; i >= 0; --i) {\n        ArrayList<TaskD.Seg> nd = new ArrayList<>();\n        int rem = h[i] - h[i + 1];\n        if (rem <= 0) {\n          long total = 0;\n          for (TaskD.Seg s : D) {\n            if (s.r < h[i] - 1) {\n              nd.add(s);\n            } else {\n              Pair<TaskD.Seg, TaskD.Seg> parts = s.split(h[i] - 1);\n              if (parts.first != null) {\n                nd.add(parts.first);\n              }\n              if (parts.second != null) {\n                total += parts.second.sum();\n              }\n            }\n          }\n          nd.add(new TaskD.Seg(h[i] - 1, h[i] - 1, total * 2L, 1));\n        } else {\n          long p = IntegerUtils.pow(2, rem, mod);\n          for (TaskD.Seg s : D) {\n            if (s.r < h[i + 1] - 1) {\n              nd.add(new TaskD.Seg(s.l, s.r, s.start * p, s.base));\n            } else {\n              Pair<TaskD.Seg, TaskD.Seg> parts = s.split(h[i + 1] - 1);\n              if (parts.first != null) {\n                nd.add(parts.first);\n              }\n              long val = parts.second.at(h[i + 1] - 1);\n              val *= 2L;\n              val %= mod;\n              nd.add(new TaskD.Seg(h[i + 1] - 1, h[i] - 2, val, 2L));\n              nd.add(new TaskD.Seg(h[i] - 1, h[i] - 1, val, 1L));\n            }\n          }\n        }\n        D = new TaskD.Seg[nd.size()];\n        for (int j = 0; j < nd.size(); ++j) {\n          D[j] = nd.get(j);\n        }\n        // for (Seg s : D) {\n        //     for (int j = s.l; j <= s.r; ++j) {\n        //         if (s.at(j) != d[i][j]) {\n        //             throw new RuntimeException();\n        //         }\n        //     }\n        // }\n      }\n      long res = 0;\n      for (TaskD.Seg s : D) {\n        res += s.sum();\n        res %= mod;\n      }\n      out.printLine(res);\n    }\n\n    static class Seg {\n\n      int l;\n      int r;\n      long start;\n      long base;\n\n      public Seg(int l, int r, long start, long base) {\n        this.l = l;\n        this.r = r;\n        Assert.assertTrue(r >= l);\n        this.start = start % mod;\n        this.base = base;\n      }\n\n      long at(int ind) {\n        Assert.assertTrue(ind >= l && ind <= r);\n        long res = start;\n        if (base != 1) {\n          res *= IntegerUtils.pow(2, r - ind, mod);\n          res %= mod;\n        }\n        return res;\n      }\n\n      public long sum() {\n        long res;\n        if (base == 1) {\n          res = start * (r - l + 1L);\n          res %= mod;\n        } else {\n          res = start * (IntegerUtils.pow(2, r - l + 1, mod) + mod - 1);\n          res %= mod;\n        }\n        return res;\n      }\n\n      Pair<TaskD.Seg, TaskD.Seg> split(int ind) {\n        if (ind <= l) {\n          return new Pair<>(null, this);\n        }\n        if (ind > r) {\n          return new Pair<>(this, null);\n        }\n        if (base == 1) {\n          return new Pair<>(\n              new TaskD.Seg(l, ind - 1, start, 1),\n              new TaskD.Seg(ind, r, start, 1));\n        } else {\n          return new Pair<>(\n              new TaskD.Seg(l, ind - 1, at(ind - 1), 2),\n              new TaskD.Seg(ind, r, at(r), 2));\n        }\n      }\n\n    }\n\n  }\n\n  static class OutputWriter {\n\n    private final PrintWriter writer;\n\n    public OutputWriter(OutputStream outputStream) {\n      writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n    }\n\n    public OutputWriter(Writer writer) {\n      this.writer = new PrintWriter(writer);\n    }\n\n    public void print(Object... objects) {\n      for (int i = 0; i < objects.length; i++) {\n        if (i != 0) {\n          writer.print(' ');\n        }\n        writer.print(objects[i]);\n      }\n    }\n\n    public void printLine(Object... objects) {\n      print(objects);\n      writer.println();\n    }\n\n    public void close() {\n      writer.close();\n    }\n\n  }\n\n  static class InputReader {\n\n    private InputStream stream;\n    private byte[] buffer = new byte[10000];\n    private int cur;\n    private int count;\n\n    public InputReader(InputStream stream) {\n      this.stream = stream;\n    }\n\n    public static boolean isSpace(int c) {\n      return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    public int read() {\n      if (count == -1) {\n        throw new InputMismatchException();\n      }\n      try {\n        if (cur >= count) {\n          cur = 0;\n          count = stream.read(buffer);\n          if (count <= 0) {\n            return -1;\n          }\n        }\n      } catch (IOException e) {\n        throw new InputMismatchException();\n      }\n      return buffer[cur++];\n    }\n\n    public int readSkipSpace() {\n      int c;\n      do {\n        c = read();\n      } while (isSpace(c));\n      return c;\n    }\n\n    public int nextInt() {\n      int sgn = 1;\n      int c = readSkipSpace();\n      if (c == '-') {\n        sgn = -1;\n        c = read();\n      }\n      int res = 0;\n      do {\n        if (c < '0' || c > '9') {\n          throw new InputMismatchException();\n        }\n        res = res * 10 + c - '0';\n        c = read();\n      } while (!isSpace(c));\n      res *= sgn;\n      return res;\n    }\n\n  }\n\n  static class Pair<P, Q> {\n\n    public P first;\n    public Q second;\n\n    public Pair() {\n    }\n\n    public Pair(P first, Q second) {\n      this.first = first;\n      this.second = second;\n    }\n\n\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || getClass() != o.getClass()) {\n        return false;\n      }\n\n      Pair pair = (Pair) o;\n\n      if (first != null ? !first.equals(pair.first) : pair.first != null) {\n        return false;\n      }\n      if (second != null ? !second.equals(pair.second) : pair.second != null) {\n        return false;\n      }\n\n      return true;\n    }\n\n\n    public int hashCode() {\n      int result = first != null ? first.hashCode() : 0;\n      result = 31 * result + (second != null ? second.hashCode() : 0);\n      return result;\n    }\n\n  }\n\n  static class IntegerUtils {\n\n    public static int pow(long x, long y, int mod) {\n      x %= mod;\n      long res = 1;\n      while (y > 0) {\n        if (y % 2 == 1) {\n          --y;\n          res = (res * x) % mod;\n        } else {\n          y /= 2;\n          x = (x * x) % mod;\n        }\n      }\n      return (int) (res % mod);\n    }\n\n  }\n\n  static class Assert {\n\n    public static void assertTrue(boolean flag) {\n      // if (!flag)\n      // while (true);\n      if (!flag) {\n        throw new AssertionError();\n      }\n    }\n\n  }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "const val P = 1000000007L\n\nclass FiniteField(xRaw: Long) {\n  val x = if (xRaw >= 0) xRaw % P else (P - ((-xRaw) % P)) % P\n  constructor(xi: Int): this(xi.toLong())\n  operator fun plus(o: Long) = FiniteField((x + o) % P)\n  operator fun plus(o: FiniteField) = this + o.x\n  operator fun minus(o: Long) = FiniteField((x + P - o) % P)\n  operator fun minus(o: FiniteField) = this - o.x\n  operator fun times(o: Long) = FiniteField((x * o) % P)\n  operator fun times(o: FiniteField) = this * o.x\n  override fun toString() = x.toString()\n}\n\nfun powerOfTwo(p: Int): FiniteField {\n  if (p == 0) return FiniteField(1)\n  val a = powerOfTwo(p / 2)\n  return a * a * if (p % 2 == 1) FiniteField(2) else FiniteField(1)\n}\n\nfun solve(hs: List<Int>): Pair<FiniteField, FiniteField> {\n  // println(hs)\n  val hMin = hs.min()!!\n  if (hs.all { it == hMin }) {\n    val w = hs.size\n    val v1 = powerOfTwo(w) + powerOfTwo(hMin) - 2\n    val v2 = powerOfTwo(hMin)\n    return Pair(v1, v2)\n  } else {\n    // Fill this.\n    val r = hs.count { it == hMin }\n\n    var p1 = FiniteField(1)\n    var p2 = FiniteField(1)\n    val childHs = mutableListOf<Int>()\n    for (h in hs) {\n      if (h == hMin) {\n        if (childHs.size > 0) {\n          val (c1, c2) = solve(childHs)\n          p1 *= c1 + c2\n          p2 *= c2\n          childHs.clear()\n        }\n      } else {\n        childHs.add(h - hMin)\n      }\n    }\n    if (childHs.size > 0) {\n      val (c1, c2) = solve(childHs)\n      p1 *= c1 + c2\n      p2 *= c2\n      childHs.clear()\n    }\n\n    val v1 = p1 * powerOfTwo(r) + (powerOfTwo(hMin) - 2) * p2\n    val v2 = powerOfTwo(hMin) * p2\n    return Pair(v1, v2)\n  }\n}\n\nfun main(args: Array<String>) {\n  val n = readLine()!!.toInt()\n  val hs = readLine()!!.split(\" \").map { it.toInt() }\n  println(solve(hs).first)\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author kessido\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        DHistogramColoring solver = new DHistogramColoring();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class DHistogramColoring {\n        final long MOD = MathExtensions.DEFAULT_MOD;\n        final long inv2 = MathExtensions.modInverse_For_M_Prime(2, MathExtensions.DEFAULT_MOD);\n\n        long calcOptimal(int l, int r, int[] h, int fromH, boolean withNormal) {\n            if (l == r) return MathExtensions.powerMod(2, h[l] - fromH, MOD);\n            int nextH = h[l];\n            for (int i = l + 1; i <= r; i++) {\n                nextH = Math.min(nextH, h[i]);\n            }\n            long res = MathExtensions.powerMod(2, nextH - fromH, MOD);\n            if (!withNormal) res--;\n            int lastNextH = l - 1;\n            for (int i = l; i <= r; i++) {\n                if (h[i] == nextH) {\n                    if (lastNextH + 1 != i) {\n                        res = res * calcOptimal(lastNextH + 1, i - 1, h, nextH, true) % MOD;\n                    }\n                    lastNextH = i;\n                }\n            }\n            if (lastNextH != r) {\n                res = res * calcOptimal(lastNextH + 1, r, h, nextH, true) % MOD;\n            }\n            return res;\n        }\n\n        long calcNormal(int l, int r, int[] h, int fromH) {\n            if (l == r) return MathExtensions.powerMod(2, h[l] - fromH, MOD);\n            int nextH = h[l];\n            for (int i = l + 1; i <= r; i++) {\n                nextH = Math.min(nextH, h[i]);\n            }\n            long invProbability = MathExtensions.powerMod(inv2, r - l + 1, MOD);\n            long resForNormal = 1;\n            long resForOptimal = 2 * invProbability * calcOptimal(l, r, h, fromH, false) % MOD;\n            int lastNextH = l - 1;\n            for (int i = l; i <= r; i++) {\n                if (h[i] == nextH) {\n                    if (lastNextH + 1 != i) {\n                        resForNormal = resForNormal * calcNormal(lastNextH + 1, i - 1, h, nextH) % MOD;\n                    }\n                    lastNextH = i;\n                }\n            }\n            if (lastNextH != r) {\n                resForNormal = resForNormal * calcNormal(lastNextH + 1, r, h, nextH) % MOD;\n            }\n            return (resForNormal + resForOptimal) % MOD;\n        }\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.NextInt();\n            int[] h = in.NextIntArray(n);\n            long res = MathExtensions.powerMod(2, n, MOD) * calcNormal(0, h.length - 1, h, 1) % MOD;\n            if (res < 0) res += MOD;\n            out.println(res);\n        }\n\n    }\n\n    static class MathExtensions {\n        public static final long DEFAULT_MOD = 1_000_000_007L;\n\n        public static long modInverse_For_M_Prime(final long a, final long m) {\n            return powerMod(a, m - 2, m);\n        }\n\n        public static long powerMod(final long x, final long y, final long m) {\n            if (y == 0)\n                return 1;\n\n            long p = powerMod(x, y / 2, m) % m;\n            p = (p * p) % m;\n\n            if (y % 2 == 0)\n                return p;\n            else\n                return (x * p) % m;\n        }\n\n    }\n\n    static class InputReader {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine(), \" \\t\\n\\r\\f,\");\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int NextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public int[] NextIntArray(int n) {\n            return NextIntArray(n, 0);\n        }\n\n        public int[] NextIntArray(int n, int offset) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = NextInt() + offset;\n            }\n            return a;\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.*;\nclass prog{\n  \n  static int[] h;\n  static long mod = 1000000007;\n  \n  static class Node{\n    List<Node> child;\n    long w=0, h=0;\n    long dp1=1, dp2=1;\n    Node(long w, long h){this.w=w;this.h=h;}\n  }\n  \n  static Node dfs(int l, int r, long base){\n    if(r-l==0)return null;\n    long minh = Integer.MAX_VALUE;\n    for(int i=l;i<r;++i)minh = Math.min(minh, h[i]);\n    int minl = l;\n    int w = -1;\n    List<Node> nodelist = new ArrayList<>();\n    for(int i=l;i<=r;++i){\n        if(i==r || h[i]==minh){\n            ++w;\n            if(minl!=i)nodelist.add(dfs(minl, i, minh));\n            minl = i+1;\n        }\n    }\n    Node node = new Node((long)w, minh - base);\n    node.child = nodelist;\n    return node;\n  }\n    \n  \n  static long pow(long a, long p, long mod){\n    long res = 1;\n    for(int i=0;i<64;++i){\n      if(((p>>i)&1)==1)res=(res*a)%mod;\n      a = (a*a)%mod;\n    }\n    return res;\n  }\n  \n  static void culc(Node node){\n    if(node.child.isEmpty()){\n        node.dp1 = pow(2, node.h, mod) -2;\n        node.dp2 = 2;\n    }else{\n        long dp1 = 1;\n        long dp2 = 1;\n        for(Node c : node.child){\n            culc(c);\n            dp1 = (dp1*c.dp1)%mod;\n            dp2 = (dp2*c.dp2)%mod;\n        }\n        node.dp1 = ((dp1+dp2)%mod * ((pow(2, node.h, mod)-1+mod)%mod))%mod;\n        node.dp2 = (dp1+dp2)%mod * pow(2, node.w, mod)%mod;\n    }\n    System.out.println(\"dp1 : \"+node.dp1);\n    System.out.println(\"dp2 : \"+node.dp2);\n\n  }\n  \n  public static void main(String[] args){\n    Scanner scan = new Scanner(System.in);\n    int n = scan.nextInt();\n    h = new int[n];\n    for(int i=0;i<n;++i)h[i]=scan.nextInt();\n\tNode root = dfs(0, n, 0);\n    culc(root);\n    System.out.println((root.dp1+root.dp2)%mod);\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.*;\nclass Main{\n  \n  static int[] h;\n  static long mod = 1000000007;\n  \n  static class Node{\n    List<Node> child;\n    long w=0, h=0;\n    long dp1=1, dp2=1;\n    Node(long w, long h){this.w=w;this.h=h;}\n  }\n  \n  static Node dfs(int l, int r, long base){\n    if(r-l==0)return null;\n    long minh = Integer.MAX_VALUE;\n    for(int i=l;i<r;++i)minh = Math.min(minh, h[i]);\n    int minl = l;\n    int w = -1;\n    List<Node> nodelist = new ArrayList<>();\n    for(int i=l;i<=r;++i){\n        if(i==r || h[i]==minh){\n            ++w;\n            if(minl!=i)nodelist.add(dfs(minl, i, minh));\n            minl = i+1;\n        }\n    }\n    Node node = new Node((long)w, minh - base);\n    node.child = nodelist;\n    return node;\n  }\n    \n  \n  static long pow(long a, long p, long mod){\n    long res = 1;\n    for(int i=0;i<64;++i){\n      if(((p>>i)&1)==1)res=(res*a)%mod;\n      a = (a*a)%mod;\n    }\n    return res;\n  }\n  \n  static void culc(Node node){\n    if(node.child.isEmpty()){\n\t\tnode.dp1 = pow(2, node.h, mod) ;\n        node.dp2 = (pow(2, node.w, mod)-2+mod)%mod;\n    }else{\n        long dp1 = 1;\n        long dp2 = 1;\n        for(Node c : node.child){\n            culc(c);\n\t\t\tdp1 = (dp1*c.dp1)%mod;\n\t\t\tdp2 = (dp2 * (c.dp1*2+c.dp2)%mod)%mod;\n\t\t}\n\t\tdp2 = (dp2 - dp1*pow(2, node.child.size(), mod)%mod + mod)%mod;\n        node.dp1 = (dp1 * pow(2, node.h, mod)%mod);\n        node.dp2 = (dp1*((pow(2, node.w + node.child.size(), mod)-2+mod)%mod)%mod + dp2*(pow(2, node.w, mod)%mod))%mod;\n    }\n  }\n  \n  public static void main(String[] args){\n    Scanner scan = new Scanner(System.in);\n    int n = scan.nextInt();\n    h = new int[n];\n    for(int i=0;i<n;++i)h[i]=scan.nextInt();\n\tNode root = dfs(0, n, 0);\n    culc(root);\n    System.out.println((root.dp1+root.dp2)%mod);\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    FastScanner in;\n    PrintWriter out;\n\n    final int mod = (int) 1e9 + 7;\n\n    int add(int x, int y) {\n        x += y;\n        return x >= mod ? (x - mod) : x;\n    }\n\n    int mul(int x, int y) {\n        return (int) ((x * 1L * y) % mod);\n    }\n\n    int pow(int x, int y) {\n        if (y == 0) {\n            return 1;\n        }\n        int t = pow(x, y / 2);\n        t = mul(t, t);\n        if (y % 2 == 1) {\n            t = mul(t, x);\n        }\n        return t;\n    }\n\n    class Position {\n        int left, right, h;\n        int lValue, rValue;\n        boolean changed;\n\n        public Position(int left, int right, int h, int lValue, int rValue, boolean changed) {\n            this.left = left;\n            this.right = right;\n            this.h = h;\n            this.lValue = lValue;\n            this.rValue = rValue;\n            this.changed = changed;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            Position position = (Position) o;\n            return left == position.left &&\n                    right == position.right &&\n                    h == position.h &&\n                    lValue == position.lValue &&\n                    rValue == position.rValue &&\n                    changed == position.changed;\n        }\n\n        @Override\n        public int hashCode() {\n            return Objects.hash(left, right, h, lValue, rValue, changed);\n        }\n\n        @Override\n        public String toString() {\n            return \"Position{\" +\n                    \"left=\" + left +\n                    \", right=\" + right +\n                    \", h=\" + h +\n                    \", lValue=\" + lValue +\n                    \", rValue=\" + rValue +\n                    \", changed=\" + changed +\n                    '}';\n        }\n    }\n\n    HashMap<Position, Integer> ans = new HashMap<>();\n\n    int calcAns(Position p) {\n        if (p.left == p.right && p.lValue != p.rValue) {\n            return 0;\n        }\n//        if (p.h == 1 && p.lValue == 0 && p.rValue == 0 && p.changed == false && p.left == 0 && p.right== 1) {\n//            System.err.println(\"!!!\");\n//        }\n        int cnt = p.right - p.left + 1;\n        if (cnt == 2 && p.changed == false && p.lValue != p.rValue) {\n            return 0;\n        }\n        if (cnt == 1 && p.changed == false) {\n            return 0;\n        }\n        if (p.changed) {\n            if (cnt % 2 == 0) {\n                if (p.lValue == p.rValue) {\n                    return 0;\n                }\n            } else {\n                if (p.lValue != p.rValue) {\n                    return 0;\n                }\n            }\n        }\n        int min = minH[p.left][p.right];\n        if (min != p.h) {\n            if (p.changed) {\n                int diff = min - p.h;\n                int mul = pow(2, diff - 1);\n                int res = 0;\n                for (int lVal = 0; lVal < 2; lVal++) {\n                    for (int rVal = 0; rVal < 2; rVal++) {\n                        res = add(res, getAns(new Position(p.left, p.right, min, lVal, rVal, true)));\n                    }\n                }\n                return mul(mul, res);\n            } else {\n                int diff = (min - p.h) % 2;\n                return getAns(new Position(p.left, p.right, min, p.lValue ^ diff, p.rValue ^ diff, p.changed));\n            }\n        } else {\n            if (maxH[p.left][p.right] == p.h) {\n                if (p.changed) {\n                    return 1;\n                } else {\n                    return pow(2, cnt - 2);\n                }\n            } else {\n                boolean eqH = h[p.left] == p.h;\n                for (int pos = p.left + 1; pos <= p.right; pos++) {\n                    boolean curEqH = (h[pos] == p.h);\n                    if (curEqH != eqH) {\n                        int res = 0;\n                        for (int x = 0; x < 2; x++) {\n                            for (int y = 0; y < 2; y++) {\n                                for (int z1 = 0; z1 < 2; z1++) {\n                                    for (int z2 = 0; z2 < 2; z2++) {\n                                        boolean c1 = z1 == 0, c2 = z2 == 0;\n                                        boolean nextChange = c1 && c2 && (x != y);\n                                        if (nextChange != p.changed) {\n                                            continue;\n                                        }\n                                        int f = mul(getAns(new Position(p.left, pos - 1, p.h, p.lValue, x, c1)), getAns(new Position(pos, p.right, p.h, y, p.rValue, c2)));\n                                        res = add(res, f);\n                                    }\n                                }\n                            }\n                        }\n                        return res;\n                    }\n                }\n                throw new AssertionError();\n            }\n        }\n    }\n\n    int getAns(Position p) {\n        if (ans.containsKey(p)) {\n            return ans.get(p);\n        }\n        int r = calcAns(p);\n//        if (r != 0 && p.h == 2 && p.left == 1 && p.right == 1)\n//            System.err.println(p + \" -> \" + r);\n        ans.put(p, r);\n        return r;\n    }\n\n    int n;\n    int[] h;\n    int[][] minH;\n    int[][] maxH;\n\n    void solve() {\n        n = in.nextInt();\n        h = new int[n];\n        for (int i = 0; i < n; i++) {\n            h[i] = in.nextInt();\n        }\n        minH = new int[n][n];\n        maxH = new int[n][n];\n        for (int i = 0; i < n; i++) {\n            int f = Integer.MAX_VALUE;\n            int g = 0;\n            for (int j = i; j < n; j++) {\n                f = Math.min(f, h[j]);\n                g = Math.max(g, h[j]);\n                minH[i][j] = f;\n                maxH[i][j] = g;\n            }\n        }\n        int res = 0;\n        for (int l = 0; l < 2; l++) {\n            for (int r = 0; r < 2; r++) {\n                res = add(res, getAns(new Position(0, n - 1, 1, l, r, true)));\n                res = add(res, getAns(new Position(0, n - 1, 1, l, r, false)));\n            }\n        }\n        out.println(res);\n    }\n\n\n    void run() {\n        try {\n            in = new FastScanner(new File(\"Main.in\"));\n            out = new PrintWriter(new File(\"Main.out\"));\n\n            solve();\n\n            out.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n\n    void runIO() {\n\n        in = new FastScanner(System.in);\n        out = new PrintWriter(System.out);\n\n        solve();\n\n        out.close();\n    }\n\n    class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner(File f) {\n            try {\n                br = new BufferedReader(new FileReader(f));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n\n        public FastScanner(InputStream f) {\n            br = new BufferedReader(new InputStreamReader(f));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                String s = null;\n                try {\n                    s = br.readLine();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (s == null)\n                    return null;\n                st = new StringTokenizer(s);\n            }\n            return st.nextToken();\n        }\n\n        boolean hasMoreTokens() {\n            while (st == null || !st.hasMoreTokens()) {\n                String s = null;\n                try {\n                    s = br.readLine();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (s == null)\n                    return false;\n                st = new StringTokenizer(s);\n            }\n            return true;\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n\n    public static void main(String[] args) {\n        new Main().runIO();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskD {\n        static final long MODULO = (int) 1e9 + 7;\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int[] h = new int[n];\n            for (int i = 0; i < n; ++i) {\n                h[i] = in.nextInt();\n            }\n            long[] res = doit(h);\n            out.println(res[1]);\n        }\n\n        private long[] doit(int[] h) {\n            int minh = Integer.MAX_VALUE;\n            for (int x : h) minh = Math.min(minh, x);\n            int start = 0;\n            long wAlternate = 2;\n            long wTotal = 1;\n            for (int i = 0; i <= h.length; ++i) {\n                if (i == h.length || h[i] == minh) {\n                    if (i > start) {\n                        int[] child = Arrays.copyOfRange(h, start, i);\n                        for (int j = 0; j < child.length; ++j) child[j] -= minh;\n                        long[] got = doit(child);\n                        wAlternate = wAlternate * got[0] % MODULO;\n                        wTotal = wTotal * (got[1] + got[0]) % MODULO;\n                    }\n                    start = i + 1;\n                    if (i < h.length) wTotal = wTotal * 2 % MODULO;\n                }\n            }\n            wTotal = (wTotal - wAlternate + MODULO) % MODULO;\n            wAlternate = wAlternate * pow(2, minh - 1);\n            wTotal = (wTotal + wAlternate) % MODULO;\n            return new long[]{wAlternate, wTotal};\n        }\n\n        private long pow(long a, int k) {\n            if (k == 0) return 1;\n            if (k % 2 == 0) return pow(a * a % MODULO, k / 2);\n            return a * pow(a, k - 1) % MODULO;\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    FastScanner in;\n    PrintWriter out;\n\n    final int mod = (int) 1e9 + 7;\n\n    int add(int x, int y) {\n        x += y;\n        return x >= mod ? (x - mod) : x;\n    }\n\n    int mul(int x, int y) {\n        return (int) ((x * 1L * y) % mod);\n    }\n\n    int pow(int x, int y) {\n        if (y == 0) {\n            return 1;\n        }\n        int t = pow(x, y / 2);\n        t = mul(t, t);\n        if (y % 2 == 1) {\n            t = mul(t, x);\n        }\n        return t;\n    }\n\n    class Position {\n        int left, right, h;\n        int lValue, rValue;\n        boolean changed;\n\n        public Position(int left, int right, int h, int lValue, int rValue, boolean changed) {\n            this.left = left;\n            this.right = right;\n            this.h = h;\n            this.lValue = lValue;\n            this.rValue = rValue;\n            this.changed = changed;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            Position position = (Position) o;\n            return left == position.left &&\n                    right == position.right &&\n                    h == position.h &&\n                    lValue == position.lValue &&\n                    rValue == position.rValue &&\n                    changed == position.changed;\n        }\n\n        @Override\n        public int hashCode() {\n            return Objects.hash(left, right, h, lValue, rValue, changed);\n        }\n\n        @Override\n        public String toString() {\n            return \"Position{\" +\n                    \"left=\" + left +\n                    \", right=\" + right +\n                    \", h=\" + h +\n                    \", lValue=\" + lValue +\n                    \", rValue=\" + rValue +\n                    \", changed=\" + changed +\n                    '}';\n        }\n    }\n\n    HashMap<Position, Integer> ans = new HashMap<>();\n\n    int calcAns(Position p) {\n        if (p.left == p.right && p.lValue != p.rValue) {\n            return 0;\n        }\n//        if (p.h == 1 && p.lValue == 0 && p.rValue == 0 && p.changed == false && p.left == 0 && p.right== 1) {\n//            System.err.println(\"!!!\");\n//        }\n        int cnt = p.right - p.left + 1;\n        if (cnt == 2 && p.changed == false && p.lValue != p.rValue) {\n            return 0;\n        }\n        if (cnt == 1 && p.changed == false) {\n            return 0;\n        }\n        if (p.changed) {\n            if (cnt % 2 == 0) {\n                if (p.lValue == p.rValue) {\n                    return 0;\n                }\n            } else {\n                if (p.lValue != p.rValue) {\n                    return 0;\n                }\n            }\n        }\n        int min = minH[p.left][p.right];\n        if (min != p.h) {\n            if (p.changed) {\n                int diff = min - p.h;\n                int mul = pow(2, diff - 1);\n                int res = 0;\n                for (int lVal = 0; lVal < 2; lVal++) {\n                    for (int rVal = 0; rVal < 2; rVal++) {\n                        res = add(res, getAns(new Position(p.left, p.right, min, lVal, rVal, true)));\n                    }\n                }\n                return mul(mul, res);\n            } else {\n                int diff = (min - p.h) % 2;\n                return getAns(new Position(p.left, p.right, min, p.lValue ^ diff, p.rValue ^ diff, p.changed));\n            }\n        } else {\n            if (maxH[p.left][p.right] == p.h) {\n                if (p.changed) {\n                    return 1;\n                } else {\n                    int res =  pow(2, cnt - 2);\n                    if (cnt % 2 == 0) {\n                        if (p.lValue != p.rValue) {\n                            res--;\n                        }\n                    } else {\n                        if (p.lValue == p.rValue) {\n                            res--;\n                        }\n                    }\n                    if (res < 0) {\n                        res += mod;\n                    }\n                    return res;\n                }\n            } else {\n                boolean eqH = h[p.left] == p.h;\n                for (int pos = p.left + 1; pos <= p.right; pos++) {\n                    boolean curEqH = (h[pos] == p.h);\n                    if (curEqH != eqH) {\n                        int res = 0;\n                        for (int x = 0; x < 2; x++) {\n                            for (int y = 0; y < 2; y++) {\n                                for (int z1 = 0; z1 < 2; z1++) {\n                                    for (int z2 = 0; z2 < 2; z2++) {\n                                        boolean c1 = z1 == 0, c2 = z2 == 0;\n                                        boolean nextChange = c1 && c2 && (x != y);\n                                        if (nextChange != p.changed) {\n                                            continue;\n                                        }\n                                        int f = mul(getAns(new Position(p.left, pos - 1, p.h, p.lValue, x, c1)), getAns(new Position(pos, p.right, p.h, y, p.rValue, c2)));\n                                        res = add(res, f);\n                                    }\n                                }\n                            }\n                        }\n                        return res;\n                    }\n                }\n                throw new AssertionError();\n            }\n        }\n    }\n\n    int getAns(Position p) {\n        if (ans.containsKey(p)) {\n            return ans.get(p);\n        }\n        int r = calcAns(p);\n//        if (r != 0 && p.h == 2 && p.left == 1 && p.right == 1)\n//            System.err.println(p + \" -> \" + r);\n        ans.put(p, r);\n        return r;\n    }\n\n    int n;\n    int[] h;\n    int[][] minH;\n    int[][] maxH;\n\n    void solve() {\n        n = in.nextInt();\n        h = new int[n];\n        for (int i = 0; i < n; i++) {\n            h[i] = in.nextInt();\n        }\n        minH = new int[n][n];\n        maxH = new int[n][n];\n        for (int i = 0; i < n; i++) {\n            int f = Integer.MAX_VALUE;\n            int g = 0;\n            for (int j = i; j < n; j++) {\n                f = Math.min(f, h[j]);\n                g = Math.max(g, h[j]);\n                minH[i][j] = f;\n                maxH[i][j] = g;\n            }\n        }\n        int res = 0;\n        for (int l = 0; l < 2; l++) {\n            for (int r = 0; r < 2; r++) {\n                res = add(res, getAns(new Position(0, n - 1, 1, l, r, true)));\n                res = add(res, getAns(new Position(0, n - 1, 1, l, r, false)));\n            }\n        }\n        out.println(res);\n    }\n\n\n    void run() {\n        try {\n            in = new FastScanner(new File(\"Main.in\"));\n            out = new PrintWriter(new File(\"Main.out\"));\n\n            solve();\n\n            out.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n\n    void runIO() {\n\n        in = new FastScanner(System.in);\n        out = new PrintWriter(System.out);\n\n        solve();\n\n        out.close();\n    }\n\n    class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner(File f) {\n            try {\n                br = new BufferedReader(new FileReader(f));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n\n        public FastScanner(InputStream f) {\n            br = new BufferedReader(new InputStreamReader(f));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                String s = null;\n                try {\n                    s = br.readLine();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (s == null)\n                    return null;\n                st = new StringTokenizer(s);\n            }\n            return st.nextToken();\n        }\n\n        boolean hasMoreTokens() {\n            while (st == null || !st.hasMoreTokens()) {\n                String s = null;\n                try {\n                    s = br.readLine();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (s == null)\n                    return false;\n                st = new StringTokenizer(s);\n            }\n            return true;\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n\n    public static void main(String[] args) {\n        new Main().runIO();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.util.Random;\nimport java.io.UncheckedIOException;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            TaskD solver = new TaskD();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class TaskD {\n        int[] heights;\n        int[][] f;\n        int[] g;\n        int n;\n        DiscreteMap dm;\n        int m;\n        NumberTheory.Modular mod = new NumberTheory.Modular(1e9 + 7);\n        NumberTheory.Power pow = new NumberTheory.Power(mod);\n\n        public int f(int i, int j) {\n            if (f[i][j] == -1) {\n                f[i][j] = 1;\n                int r = dm.rankOf(heights[i]);\n                if (j >= r) {\n                    return f[i][j] = 0;\n                }\n                int lastR = dm.rankOf(heights[i - 1]);\n\n                if (lastR >= r) {\n                    // inherit\n                    f[i][j] = mod.subtract(f(i - 1, j), f(i - 1, r));\n                    return f[i][j];\n                }\n\n                if (j <= lastR) {\n                    // inherit\n                    f[i][j] = mod.mul(f(i - 1, j), pow.pow(2, heights[i] - heights[i - 1]));\n\n                    int plus = mod.mul(g(i - 1), 2);\n                    plus = mod.mul(plus, mod.subtract(pow.pow(2, heights[i] - heights[i - 1]), 1));\n                    f[i][j] = mod.plus(plus, f[i][j]);\n                } else {\n                    // self built\n                    f[i][j] = mod.mul(2, g(i - 1));\n                    f[i][j] = mod.mul(f[i][j], mod.subtract(pow.pow(2, heights[i] - dm.iThElement(j)), 1));\n                }\n            }\n\n            return f[i][j];\n        }\n\n        public int g(int i) {\n            if (g[i] == -1) {\n                int r = dm.rankOf(heights[i]);\n                int lastR = dm.rankOf(heights[i - 1]);\n                if (r >= lastR) {\n                    g[i] = mod.mul(2, g(i - 1));\n                } else {\n                    g[i] = mod.mul(2, mod.plus(f(i - 1, r), g(i - 1)));\n                }\n            }\n            return g[i];\n        }\n\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            n = in.readInt();\n            heights = new int[n];\n            for (int i = 0; i < n; i++) {\n                heights[i] = in.readInt();\n            }\n\n            IntList list = new IntList();\n            list.addAll(heights);\n            list.add(0);\n            dm = new DiscreteMap(list.toArray());\n            m = dm.maxRank();\n\n            f = new int[n][m + 1];\n            g = new int[n];\n            SequenceUtils.deepFill(f, -1);\n            SequenceUtils.deepFill(g, -1);\n            g[0] = 2;\n            for (int i = dm.minRank(), r = dm.rankOf(heights[0]); i <= r; i++) {\n                if (i == r) {\n                    f[0][i] = 0;\n                } else if (dm.iThElement(i) == 0) {\n                    f[0][i] = mod.mul(1, mod.subtract(pow.pow(2, heights[0] - dm.iThElement(i)), 2));\n                } else {\n                    f[0][i] = mod.mul(2, mod.subtract(pow.pow(2, heights[0] - dm.iThElement(i)), 1));\n                }\n            }\n\n            int ans = mod.plus(f(n - 1, 0), g(n - 1));\n            out.println(ans);\n        }\n\n    }\n\n    static class SequenceUtils {\n        public static void deepFill(Object array, int val) {\n            if (!array.getClass().isArray()) {\n                throw new IllegalArgumentException();\n            }\n            if (array instanceof int[]) {\n                int[] intArray = (int[]) array;\n                Arrays.fill(intArray, val);\n            } else {\n                Object[] objArray = (Object[]) array;\n                for (Object obj : objArray) {\n                    deepFill(obj, val);\n                }\n            }\n        }\n\n        public static boolean equal(int[] a, int[] b, int al, int ar, int bl, int br) {\n            if ((ar - al) != (br - bl)) {\n                return false;\n            }\n            for (int i = al, j = bl; i <= ar; i++, j++) {\n                if (a[i] != b[j]) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n\n    static class IntList {\n        private int size;\n        private int cap;\n        private int[] data;\n        private static final int[] EMPTY = new int[0];\n\n        public IntList(int cap) {\n            this.cap = cap;\n            if (cap == 0) {\n                data = EMPTY;\n            } else {\n                data = new int[cap];\n            }\n        }\n\n        public IntList(IntList list) {\n            this.size = list.size;\n            this.cap = list.cap;\n            this.data = Arrays.copyOf(list.data, size);\n        }\n\n        public IntList() {\n            this(0);\n        }\n\n        public void ensureSpace(int need) {\n            int req = size + need;\n            if (req > cap) {\n                while (cap < req) {\n                    cap = Math.max(cap + 10, 2 * cap);\n                }\n                data = Arrays.copyOf(data, cap);\n            }\n        }\n\n        public void add(int x) {\n            ensureSpace(1);\n            data[size++] = x;\n        }\n\n        public void addAll(int[] x) {\n            addAll(x, 0, x.length);\n        }\n\n        public void addAll(int[] x, int offset, int len) {\n            ensureSpace(len);\n            System.arraycopy(x, offset, data, size, len);\n            size += len;\n        }\n\n        public int[] toArray() {\n            return Arrays.copyOf(data, size);\n        }\n\n        public String toString() {\n            return Arrays.toString(toArray());\n        }\n\n        public boolean equals(Object obj) {\n            if (!(obj instanceof IntList)) {\n                return false;\n            }\n            IntList other = (IntList) obj;\n            return SequenceUtils.equal(data, other.data, 0, size - 1, 0, other.size - 1);\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput println(int c) {\n            cache.append(c).append('\\n');\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n\n    static class Randomized {\n        static Random random = new Random();\n\n        public static void randomizedArray(int[] data, int from, int to) {\n            to--;\n            for (int i = from; i <= to; i++) {\n                int s = nextInt(i, to);\n                int tmp = data[i];\n                data[i] = data[s];\n                data[s] = tmp;\n            }\n        }\n\n        public static int nextInt(int l, int r) {\n            return random.nextInt(r - l + 1) + l;\n        }\n\n    }\n\n    static class DiscreteMap {\n        int[] val;\n        int f;\n        int t;\n\n        public DiscreteMap(int[] val) {\n            this(val, 0, val.length);\n        }\n\n        public DiscreteMap(int[] val, int f, int t) {\n            Randomized.randomizedArray(val, f, t);\n            Arrays.sort(val, f, t);\n            int wpos = f + 1;\n            for (int i = f + 1; i < t; i++) {\n                if (val[i] == val[i - 1]) {\n                    continue;\n                }\n                val[wpos++] = val[i];\n            }\n            this.val = val;\n            this.f = f;\n            this.t = wpos;\n        }\n\n        public int rankOf(int x) {\n            return Arrays.binarySearch(val, f, t, x) - f;\n        }\n\n        public int iThElement(int i) {\n            return val[f + i];\n        }\n\n        public int minRank() {\n            return 0;\n        }\n\n        public int maxRank() {\n            return t - f - 1;\n        }\n\n        public String toString() {\n            return Arrays.toString(Arrays.copyOfRange(val, f, t));\n        }\n\n    }\n\n    static class NumberTheory {\n        public static class Modular {\n            int m;\n\n            public Modular(int m) {\n                this.m = m;\n            }\n\n            public Modular(long m) {\n                this.m = (int) m;\n                if (this.m != m) {\n                    throw new IllegalArgumentException();\n                }\n            }\n\n            public Modular(double m) {\n                this.m = (int) m;\n                if (this.m != m) {\n                    throw new IllegalArgumentException();\n                }\n            }\n\n            public int valueOf(int x) {\n                x %= m;\n                if (x < 0) {\n                    x += m;\n                }\n                return x;\n            }\n\n            public int valueOf(long x) {\n                x %= m;\n                if (x < 0) {\n                    x += m;\n                }\n                return (int) x;\n            }\n\n            public int mul(int x, int y) {\n                return valueOf((long) x * y);\n            }\n\n            public int plus(int x, int y) {\n                return valueOf(x + y);\n            }\n\n            public int subtract(int x, int y) {\n                return valueOf(x - y);\n            }\n\n            public String toString() {\n                return \"mod \" + m;\n            }\n\n        }\n\n        public static class Power {\n            final NumberTheory.Modular modular;\n\n            public Power(NumberTheory.Modular modular) {\n                this.modular = modular;\n            }\n\n            public int pow(int x, long n) {\n                if (n == 0) {\n                    return modular.valueOf(1);\n                }\n                long r = pow(x, n >> 1);\n                r = modular.valueOf(r * r);\n                if ((n & 1) == 1) {\n                    r = modular.valueOf(r * x);\n                }\n                return (int) r;\n            }\n\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\nclass Node {\n  final int height;\n  long numPure;\n  long numNonPure;\n  \n  Node(int height, long numPure, long numNonPure) {\n    this.height = height;\n    this.numPure = numPure;\n    this.numNonPure = numNonPure;\n  }\n}\n\nclass Solver {\n  private final ModCalculator mc = new ModCalculator(1_000_000_007L);\n  final int n;\n  final int[] hs;\n  \n  Solver(int n, int[] hs) {\n    this.n = n;\n    this.hs = hs;\n  }\n  \n  private Node createNewNode(int height, List<Node> newMergedNode, int newPileCount) {\n    /*\n    System.err.println();\n    for (Node node : newMergedNode) {\n      System.err.printf(\"%d %d\\n\", node.numPure, node.numNonPure);\n    }\n    System.err.println();\n    System.err.println(newPileCount);\n    System.err.println();\n    */\n    \n    long newNumPure = 2;\n    for (Node node : newMergedNode) {\n      newNumPure = mc.mul(newNumPure, node.numPure);\n    }\n//    System.err.println(newNumPure);\n    \n    long newNumNonPure = mc.pow(2, newPileCount);\n    for (Node node : newMergedNode) {\n      newNumNonPure = mc.mul(newNumNonPure, mc.add(mc.mul(2, node.numPure), node.numNonPure));\n    }\n//    System.err.println(newNumNonPure);\n    newNumNonPure = mc.sub(newNumNonPure, newNumPure);\n//    System.err.println(newNumNonPure);\n    \n    return new Node(height, newNumPure, newNumNonPure);\n  }\n  \n  public long solve() {\n    Set<Integer> hSet = new HashSet<>();\n//    hSet.add(0);\n    for (int h : hs) {\n      hSet.add(h);\n    }\n    if (!hSet.contains(1)) {\n      hSet.add(1);\n    }\n    List<Integer> uniqueHList = new ArrayList<>();\n    for (int h : hSet) {\n      uniqueHList.add(h);\n    }\n    Collections.sort(uniqueHList);\n    \n    List<Node> nodeList = new ArrayList<>();\n    nodeList.add(new Node(-1, 0, 0));\n    for (int i = 0; i < n; i++) {\n      nodeList.add(new Node(hs[i], 0, 0));\n    }\n    nodeList.add(new Node(-1, 0, 0));\n    \n    int prevHeight = Integer.MAX_VALUE;\n    for (int i = uniqueHList.size() - 1; i >= 0; i--) {\n      /*\n      for (Node node : nodeList) {\n        System.err.printf(\"%d %d %d\\n\", node.height, node.numPure, node.numNonPure);\n      }\n      System.err.println();\n      */\n      \n      \n      int height = uniqueHList.get(i);\n      int diffHeight = prevHeight - height;\n      long mul = mc.pow(2, diffHeight - 1);\n//      System.err.printf(\"mul: %d\\n\", mul);\n      for (Node node : nodeList) {\n        node.numPure = mc.mul(node.numPure, mul);\n      }\n      \n      List<Node> nextNodeList = new ArrayList<>();\n      \n      int newPileCount = 0;\n      List<Node> newMergedNode = new ArrayList<>();\n      for (Node node : nodeList) {\n        if (node.height > height) {\n          newMergedNode.add(node);\n        } else if (node.height == height) {\n          newPileCount++;\n        } else if (newMergedNode.size() > 0 || newPileCount > 0) {\n          nextNodeList.add(createNewNode(height, newMergedNode, newPileCount));\n          newPileCount = 0;\n          newMergedNode = new ArrayList<>();\n          nextNodeList.add(node);\n        } else {\n          nextNodeList.add(node);\n        }\n      }\n      \n      nodeList = nextNodeList;\n      prevHeight = height;\n    }\n    return mc.add(nodeList.get(1).numPure, nodeList.get(1).numNonPure);\n  }\n}\n\npublic class Main {\n  private static void execute(ContestReader reader, PrintWriter out) {\n    int n = reader.nextInt();\n    int[] hs = reader.nextInt(n);\n    out.println(new Solver(n, hs).solve());\n  }\n  \n  public static void main(String[] args) {\n    ContestReader reader = new ContestReader(System.in);\n    PrintWriter out = new PrintWriter(System.out);\n    execute(reader, out);\n    out.flush();\n  }\n}\n\nclass ContestReader {\n  private BufferedReader reader;\n  private StringTokenizer tokenizer;\n  \n  ContestReader(InputStream in) {\n    reader = new BufferedReader(new InputStreamReader(in));\n  }\n  \n  public String next() {\n    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n      try {\n        tokenizer = new java.util.StringTokenizer(reader.readLine());\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return tokenizer.nextToken();\n  }\n  \n  public int nextInt() {\n    return Integer.parseInt(next());\n  }\n  \n  public long nextLong() {\n    return Long.parseLong(next());\n  }\n  \n  public double nextDouble() {\n    return Double.parseDouble(next());\n  }\n  \n  public String[] next(int n) {\n    String[] array = new String[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = next();\n    }\n    return array;\n  }\n  \n  public int[] nextInt(int n) {\n    int[] array = new int[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextInt();\n    }\n    return array;\n  }\n  \n  public long[] nextLong(int n) {\n    long[] array = new long[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextLong();\n    }\n    return array;\n  }\n  \n  public double[] nextDouble(int n) {\n    double[] array = new double[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextDouble();\n    }\n    return array;\n  }\n  \n  public char[] nextCharArray() {\n    return next().toCharArray();\n  }\n  \n  public int[][] nextInt(int n, int m) {\n    int[][] matrix = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextInt();\n      }\n    }\n    return matrix;\n  }\n  \n  public long[][] nextLong(int n, int m) {\n    long[][] matrix = new long[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextLong();\n      }\n    }\n    return matrix;\n  }\n  \n  public double[][] nextDouble(int n, int m) {\n    double[][] matrix = new double[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextDouble();\n      }\n    }\n    return matrix;\n  }\n  \n  public char[][] nextCharArray(int n) {\n    char[][] matrix = new char[n][];\n    for (int i = 0; i < n; i++) {\n      matrix[i] = next().toCharArray();\n    }\n    return matrix;\n  }\n}\n\nclass ModCalculator {\n  private final long mod;\n  private final ModCombinationCache modCombinationCache;\n  \n  ModCalculator(long mod) {\n    this.mod = mod;\n    this.modCombinationCache = new ModCombinationCache();\n  }\n  \n  public long add(long a, long b) {\n    return (a + b) % mod;\n  }\n  \n  public long sub(long a, long b) {\n    return (a - b + mod) % mod;\n  }\n  \n  public long mul(long a, long b) {\n    return (a * b) % mod;\n  }\n  \n  public long pow(long a, long b) {\n    if (b == 0) {\n      return 1;\n    }\n    long v = pow(mul(a, a), b / 2);\n    if (b % 2 == 1) {\n      return mul(v, a);\n    } else {\n      return v;\n    }\n  }\n  \n  public long inverse(long a) {\n    return pow(a, mod - 2);\n  }\n  \n  public long div(long a, long b) {\n    return mul(a, inverse(b));\n  }\n  \n  public long getF(int n) {\n    return modCombinationCache.getF(n);\n  }\n  \n  public long getP(int n, int r) {\n    return modCombinationCache.getP(n, r);\n  }\n  \n  public long getC(int n, int k) {\n    return modCombinationCache.getC(n, k);\n  }\n  \n  class ModCombinationCache {\n    private final List<Long> factorialCache;\n    private final List<Long> factorialInverseCache;\n    \n    public ModCombinationCache() {\n      factorialCache = new ArrayList<>();\n      factorialCache.add(1L);\n      factorialInverseCache = new ArrayList<>();\n      factorialInverseCache.add(1L);\n    }\n    \n    private void resize(int n) {\n      for (int i = factorialCache.size() - 1; i < n; i++) {\n        long v = mul(factorialCache.get(i), i + 1);\n        factorialCache.add(v);\n        factorialInverseCache.add(inverse(v));\n      }\n    }\n    \n    long getF(int n) {\n      resize(n);\n      return factorialCache.get(n);\n    }\n    \n    long getP(int n, int r) {\n      resize(n);\n      return mul(factorialCache.get(n), factorialInverseCache.get(n - r));\n    }\n    \n    long getC(int n, int k) {\n      resize(n);\n      return mul(factorialCache.get(n), mul(factorialInverseCache.get(k), factorialInverseCache.get(n-k)));\n    }\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "// package agc.agc026;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class Main {\n    private static final long MOD = 1000000007;\n\n    static long __startTime = System.currentTimeMillis();\n\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n        int[] h = new int[n];\n        for (int i = 0; i < n ; i++) {\n            h[i] = in.nextInt();\n        }\n        Node root = composeTree(h);\n\n        long[] r = dfs(root);\n        out.println((r[0] + r[1]) % MOD);\n        out.flush();\n    }\n\n    static long[] dfs(Node node) {\n        if (node.children.size() == 0) {\n            long AB = pow(2, node.height);\n            long nonAB = (pow(2, node.width) + MOD - 2) % MOD;\n            return new long[]{AB, nonAB};\n        }\n\n        int cn = node.children.size();\n\n        long[][] cptn = new long[cn][];\n        for (int i = 0; i < cn ; i++) {\n            cptn[i] = dfs(node.children.get(i));\n        }\n\n        long AB = pow(2, node.height);\n        for (int i = 0; i < cn ; i++) {\n            AB *= cptn[i][0];\n            AB %= MOD;\n        }\n\n        long upNonAB = 1;\n        long allAB = 2;\n        for (int i = 0; i < cn ; i++) {\n            upNonAB *= (2 * cptn[i][0] % MOD + cptn[i][1]);\n            upNonAB %= MOD;\n            allAB *= cptn[i][0];\n            allAB %= MOD;\n        }\n\n        long nonAB = pow(2, node.freeWidth) * upNonAB % MOD;\n        nonAB += MOD - allAB;\n        nonAB %= MOD;\n\n        return new long[]{AB, nonAB};\n    }\n\n    static void traverse(Node node) {\n        debug(node.width, node.height);\n        for (Node c : node.children) {\n            traverse(c);\n        }\n    }\n\n    static class Node {\n        int width;\n        int freeWidth;\n        int height;\n        List<Node> children;\n\n\n        Node(int w, int h, List<Node> c) {\n            width = w;\n            height = h;\n            children = c;\n            freeWidth = w;\n            for (Node n : c) {\n                freeWidth -= n.width;\n            }\n        }\n    }\n\n    static Node composeTree(int[] a) {\n        int min = (int)1e9;\n        for (int i = 0; i < a.length ; i++) {\n            min = Math.min(min, a[i]);\n        }\n        for (int i = 0; i < a.length; i++) {\n            a[i] -= min;\n        }\n\n        List<Node> children = new ArrayList<>();\n        int last = 0;\n        for (int i = 0; i <= a.length ; i++) {\n            if (i == a.length || a[i] == 0) {\n                // [last, i)\n                if (last < i) {\n                    int[] sub = Arrays.copyOfRange(a, last, i);\n                    children.add(composeTree(sub));\n                }\n                last = i+1;\n            }\n        }\n        return new Node(a.length, min, children);\n    }\n\n    static long pow(long a, long x) {\n        long res = 1;\n        while (x > 0) {\n            if (x % 2 != 0) {\n                res = (res * a) % MOD;\n            }\n            a = (a * a) % MOD;\n            x /= 2;\n        }\n        return res;\n    }\n\n    static long inv(long a) {\n        return pow(a, MOD - 2) % MOD;\n    }\n\n    static long[] _fact;\n    static long[] _invfact;\n\n    static long comb(long ln, long lr) {\n        int n = (int) ln;\n        int r = (int) lr;\n        if (n < 0 || r < 0 || r > n) {\n            return 0;\n        }\n        if (r > n / 2) {\n            r = n - r;\n        }\n        return (((_fact[n] * _invfact[n - r]) % MOD) * _invfact[r]) % MOD;\n    }\n\n    static void prec(int n) {\n        _fact = new long[n + 1];\n        _invfact = new long[n + 1];\n        _fact[0] = 1;\n        _invfact[0] = 1;\n        for (int i = 1; i <= n; i++) {\n            _fact[i] = _fact[i - 1] * i % MOD;\n            _invfact[i] = inv(_fact[i]);\n        }\n    }\n\n\n    private static String[] key(int ptn, char[] c, int l, int r) {\n        StringBuilder L = new StringBuilder();\n        StringBuilder R = new StringBuilder();\n        int n = r - l;\n        for (int j = 0; j < n ; j++) {\n            if ((ptn & (1<<j)) >= 1) {\n                L.append(c[l+j]);\n            } else {\n                R.append(c[l+j]);\n            }\n        }\n        return new String[]{L.toString(), R.reverse().toString()};\n    }\n\n    private static boolean solve(long a, long b, long c, long d) {\n        if (d < b) {\n            return false;\n        }\n        if (c >= b) {\n            return true;\n        }\n        if (a < b) {\n            return false;\n        }\n        long next0 = limit(a, b, c);\n        long next1 = limit(next0 + d, b, c);\n        if (next0 < 0 || next1 < 0) {\n            return false;\n        }\n        long diff = next1 - next0;\n        if (diff == 0) {\n            return true;\n        }\n\n        \n\n        return false;\n\n    }\n\n    private static long limit(long a, long b, long c) {\n        return (a <= c) ? (a - b) : (a - ((a - c + b - 1) / b) * b);\n    }\n\n    private static void printTime(String label) {\n        debug(label, System.currentTimeMillis() - __startTime);\n    }\n\n    private static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n\n    public static class InputReader {\n        private static final int BUFFER_LENGTH = 1 << 12;\n        private InputStream stream;\n        private byte[] buf = new byte[BUFFER_LENGTH];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int next() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            return (char) skipWhileSpace();\n        }\n\n        public String nextToken() {\n            int c = skipWhileSpace();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            return (int) nextLong();\n        }\n\n        public long nextLong() {\n            int c = skipWhileSpace();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble() {\n            return Double.valueOf(nextToken());\n        }\n\n        int skipWhileSpace() {\n            int c = next();\n            while (isSpaceChar(c)) {\n                c = next();\n            }\n            return c;\n        }\n\n        boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nclass Main{\n  \n  static int[] h;\n  static long mod = 1000000007;\n  \n  static long pow(long a, long p, long mod){\n    long res = 1;\n    for(int i=0;i<32;++i){\n      if(((p>>i)&1)==1)res=(res*a)%mod;\n      a = (a*a)%mod;\n    }\n    return res;\n  }\n  \n  static long culc(int l, int r){\n    if(r-l <=1)return 1;\n    int minIndex=l;\n    for(int i=l+1;i<r;++i)if(h[i]<h[minIndex])minIndex=i;\n    long dp1 = pow(2, h[minIndex], mod)-2;\n    long dp2 = 2;\n    for(int i=minIndex+1;i<r;++i){\n      dp2 = (dp2*2)%mod;\n      long dh = Math.max(0, h[i]-h[i-1]);\n      dp1 = ((dp1 * pow(2, dh, mod))%mod + (dp2 * (pow(2, dh, mod)-1+mod)%mod)%mod)%mod;\n    }\n    for(int i=minIndex-1;i>=l;--i){\n      dp2 = (dp2*2)%mod;\n      long dh = Math.max(0, h[i]-h[i+1]);\n      dp1 = ((dp1 * pow(2, dh, mod))%mod + (dp2 * (pow(2, dh, mod)-1+mod)%mod)%mod)%mod;\n    }\n    return (dp1+dp2)%mod;\n  }\n  \n  public static void main(String[] args){\n    Scanner scan = new Scanner(System.in);\n    int n = scan.nextInt();\n    h = new int[n];\n    for(int i=0;i<n;++i)h[i]=scan.nextInt();\n    long totu = 0;\n    if(n>1 && h[0]>h[1]){\n      totu += h[0]-h[1];h[0]=h[1];\n    }\n    if(n>1 && h[n-1]>h[n-2]){\n      totu += h[n-1]-h[n-2];h[n-2]=h[n-1];\n    }\n    for(int i=1;i<n-1;++i){\n      if(h[i]>h[i-1] && h[i]>h[i+1]){\n        totu += h[i] - Math.max(h[i-1], h[i+1]);\n        h[i] = Math.max(h[i-1], h[i+1]);\n      }\n    }\n    int l=0;\n    long ans = 1;\n    for(int i=0;i<n;++i){\n      if(h[i]==1){\n        totu+=1;\n        ans = (ans * culc(l,i))%mod;\n    \tl=i+1;\n      }\n    }\n    ans = (ans * pow(2, totu, mod))%mod;\n    System.out.println(ans);\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.util.TreeSet;\n\npublic class Main {\n\tpublic static long MOD = 1000000007;\n\tpublic static void main(String[] args) {\n\t\tIO io = new IO();\n\t\tint n = io.nextInt();\n\t\tint[] h = io.nextIntArray(n);\n\t\tNode root = makeTree(0,n,0,h);\n\t\tcalc(root);\n\t\tSystem.out.println(root.all);\n\t}\n\tpublic static Node makeTree(int l,int r,int y,int[] h) {\n\t\tint min = Integer.MAX_VALUE;\n\t\tfor(int i=l;i<r;i++) {\n\t\t\tmin = Math.min(min, h[i]);\n\t\t}\n\t\tNode v = new Node(min - y, r - l);\n\t\tint nl = l;\n\t\tfor(int nr=nl;nr<=r;nr++) {\n\t\t\tif (nr == r || h[nr] == min) {\n\t\t\t\tif (nl < nr) {\n\t\t\t\t\tv.children.add(makeTree(nl, nr, min, h));\n\t\t\t\t}\n\t\t\t\tnl = nr + 1;\n\t\t\t}\n\t\t}\n\t\treturn v;\n\t}\n\tpublic static void calc(Node v) {\n\t\tlong piChecker = 1;\n\t\tlong piAllPlusChecker = 1;\n\t\tint sumWidth = 0;\n\t\tfor(Node c: v.children) {\n\t\t\tcalc(c);\n\t\t\tpiChecker = piChecker * c.checker % MOD;\n\t\t\tpiAllPlusChecker = piAllPlusChecker * (c.checker + c.all) % MOD;\n\t\t\tsumWidth += c.w;\n\t\t}\n\t\tv.checker = Mod.pow(2, v.h, MOD) * piChecker % MOD;\n\t\tv.all = Mod.pow(2, v.w - sumWidth, MOD) * piAllPlusChecker % MOD;\n\t\tv.all += (Mod.pow(2, v.h, MOD) + MOD - 2) * piChecker % MOD;\n\t\tif (v.all >= MOD) v.all -= MOD;\n\t}\n}\nclass Node {\n\tint h,w;\n\tArrayList<Node> children;\n\tlong all,checker;\n\tpublic Node(int h, int w) {\n\t\tsuper();\n\t\tthis.h = h;\n\t\tthis.w = w;\n\t\tthis.children = new ArrayList<>();\n\t}\n\t@Override\n\tpublic String toString() {\n\t\treturn \"(\" + h + \",\" + w + \":\" + children + \")\";\n\t}\n}\nclass Mod {\n\tpublic static long pow(long a,long n,long mod) {\n\t\tlong res = 1;\n\t\twhile(n > 0) {\n\t\t\tif ((n & 1) > 0) {\n\t\t\t\tres = (res * a) % mod;\n\t\t\t}\n\t\t\ta = (a * a) % mod;\n\t\t\tn/=2;\n\t\t}\n\t\treturn res;\n\t}\n}\nclass IO extends PrintWriter {\n\tprivate final InputStream in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\n\tpublic IO() {\n\t\tthis(System.in);\n\t}\n\n\tpublic IO(InputStream source) {\n\t\tsuper(System.out);\n\t\tthis.in = source;\n\t}\n\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate int readByte() {\n\t\tif (hasNextByte())\n\t\t\treturn buffer[ptr++];\n\t\telse\n\t\t\treturn -1;\n\t}\n\n\tprivate static boolean isPrintableChar(int c) {\n\t\treturn 33 <= c && c <= 126;\n\t}\n\n\tprivate static boolean isNewLine(int c) {\n\t\treturn c == '\\n' || c == '\\r';\n\t}\n\n\tpublic boolean hasNext() {\n\t\twhile (hasNextByte() && !isPrintableChar(buffer[ptr]))\n\t\t\tptr++;\n\t\treturn hasNextByte();\n\t}\n\n\tpublic boolean hasNextLine() {\n\t\twhile (hasNextByte() && isNewLine(buffer[ptr]))\n\t\t\tptr++;\n\t\treturn hasNextByte();\n\t}\n\n\tpublic String next() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile (isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic char[] nextCharArray(int len) {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tchar[] s = new char[len];\n\t\tint i = 0;\n\t\tint b = readByte();\n\t\twhile (isPrintableChar(b)) {\n\t\t\tif (i == len) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\ts[i++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn s;\n\t}\n\n\tpublic String nextLine() {\n\t\tif (!hasNextLine()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile (!isNewLine(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic long nextLong() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile (true) {\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\treturn minus ? -n : n;\n\t\t\t} else {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tpublic int nextInt() {\n\t\tlong nl = nextLong();\n\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\treturn (int) nl;\n\t}\n\n\tpublic char nextChar() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\treturn (char) readByte();\n\t}\n\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n\n\tpublic int[] nextIntArray(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic long[] nextLongArray(int n) {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n\n\tpublic double[] nextDoubleArray(int n) {\n\t\tdouble[] a = new double[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextDouble();\n\t\treturn a;\n\t}\n\n\tpublic void nextIntArrays(int[]... a) {\n\t\tfor (int i = 0; i < a[0].length; i++)\n\t\t\tfor (int j = 0; j < a.length; j++)\n\t\t\t\ta[j][i] = nextInt();\n\t}\n\n\tpublic int[][] nextIntMatrix(int n, int m) {\n\t\tint[][] a = new int[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextIntArray(m);\n\t\treturn a;\n\t}\n\n\tpublic char[][] nextCharMap(int n, int m) {\n\t\tchar[][] a = new char[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextCharArray(m);\n\t\treturn a;\n\t}\n\n\tpublic void close() {\n\t\tsuper.close();\n\t\ttry {\n\t\t\tin.close();\n\t\t} catch (IOException e) {\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskD {\n        static final long MODULO = (int) 1e9 + 7;\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int[] h = new int[n];\n            for (int i = 0; i < n; ++i) {\n                h[i] = in.nextInt();\n            }\n            long[] res = doit(h);\n            out.println(res[1]);\n        }\n\n        private long[] doit(int[] h) {\n            int minh = Integer.MAX_VALUE;\n            for (int x : h) minh = Math.min(minh, x);\n            int start = 0;\n            long wAlternate = 2;\n            long wTotal = 1;\n            for (int i = 0; i <= h.length; ++i) {\n                if (i == h.length || h[i] == minh) {\n                    if (i > start) {\n                        int[] child = Arrays.copyOfRange(h, start, i);\n                        for (int j = 0; j < child.length; ++j) child[j] -= minh;\n                        long[] got = doit(child);\n                        wAlternate = wAlternate * got[0] % MODULO;\n                        wTotal = wTotal * (got[1] + got[0]) % MODULO;\n                    }\n                    start = i + 1;\n                    if (i < h.length) wTotal = wTotal * 2 % MODULO;\n                }\n            }\n            wTotal = (wTotal - wAlternate + MODULO) % MODULO;\n            wAlternate = wAlternate * pow(2, minh - 1) % MODULO;\n            wTotal = (wTotal + wAlternate) % MODULO;\n            return new long[]{wAlternate, wTotal};\n        }\n\n        private long pow(long a, int k) {\n            if (k == 0) return 1;\n            if (k % 2 == 0) return pow(a * a % MODULO, k / 2);\n            return a * pow(a, k - 1) % MODULO;\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.NoSuchElementException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Egor Kulikov (egor@egork.net)\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        DHistogramColoring solver = new DHistogramColoring();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class DHistogramColoring {\n        int n;\n        int[] h;\n        long[] ways;\n        int[][] minAt;\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            n = in.readInt();\n            h = in.readIntArray(n);\n            if (n == 1) {\n                out.printLine(IntegerUtils.power(2, h[0], MiscUtils.MOD7));\n                return;\n            }\n            long powMult = 1;\n            for (int i = 0; i < n; i++) {\n                int max;\n                if (i == 0) {\n                    max = h[1];\n                } else if (i == n - 1) {\n                    max = h[n - 2];\n                } else {\n                    max = Math.max(h[i - 1], h[i + 1]);\n                }\n                if (h[i] > max) {\n                    powMult += h[i] - max;\n                    h[i] = max;\n                }\n            }\n            ways = ArrayUtils.createArray(n + 1, -1L);\n            minAt = new int[n][n];\n            for (int i = 0; i < n; i++) {\n                for (int j = i; j < n; j++) {\n                    minAt[i][j] = ArrayUtils.minPosition(h, i, j + 1);\n                }\n            }\n            long answer = go(0);\n            answer *= IntegerUtils.power(2, powMult, MiscUtils.MOD7);\n            answer %= MiscUtils.MOD7;\n            out.printLine(answer);\n        }\n\n        private long go(int at) {\n            if (ways[at] != -1) {\n                return ways[at];\n            }\n            if (at == n) {\n                return ways[at] = 1;\n            }\n            ways[at] = 0;\n            int left = at == 0 ? 1 : h[at - 1];\n            for (int i = at + 1; i <= n; i++) {\n                int right = i == n ? 1 : h[i];\n                ways[at] += IntegerUtils.power(2, calculate(at, i - 1, left, right), MiscUtils.MOD7) * go(i) %\n                        MiscUtils.MOD7;\n            }\n            ways[at] %= MiscUtils.MOD7;\n            return ways[at];\n        }\n\n        private int calculate(int from, int to, int leftFixed, int rightFixed) {\n            if (from > to) {\n                return 0;\n            }\n            int at = minAt[from][to];\n            return Math.max(0, h[at] - Math.max(leftFixed, rightFixed)) + calculate(from, at - 1, leftFixed, h[at]) +\n                    calculate(at + 1, to, h[at], rightFixed);\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void printLine(long i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class IntegerUtils {\n        public static long power(long base, long exponent, long mod) {\n            if (base >= mod) {\n                base %= mod;\n            }\n            if (exponent == 0) {\n                return 1 % mod;\n            }\n            long result = power(base, exponent >> 1, mod);\n            result = result * result % mod;\n            if ((exponent & 1) != 0) {\n                result = result * base % mod;\n            }\n            return result;\n        }\n\n    }\n\n    static class MiscUtils {\n        public static final int MOD7 = (int) (1e9 + 7);\n\n    }\n\n    static interface IntStream extends Iterable<Integer>, Comparable<IntStream> {\n        public IntIterator intIterator();\n\n        default public Iterator<Integer> iterator() {\n            return new Iterator<Integer>() {\n                private IntIterator it = intIterator();\n\n                public boolean hasNext() {\n                    return it.isValid();\n                }\n\n                public Integer next() {\n                    int result = it.value();\n                    it.advance();\n                    return result;\n                }\n            };\n        }\n\n        default public int compareTo(IntStream c) {\n            IntIterator it = intIterator();\n            IntIterator jt = c.intIterator();\n            while (it.isValid() && jt.isValid()) {\n                int i = it.value();\n                int j = jt.value();\n                if (i < j) {\n                    return -1;\n                } else if (i > j) {\n                    return 1;\n                }\n                it.advance();\n                jt.advance();\n            }\n            if (it.isValid()) {\n                return 1;\n            }\n            if (jt.isValid()) {\n                return -1;\n            }\n            return 0;\n        }\n\n    }\n\n    static interface IntCollection extends IntStream {\n        public int size();\n\n        default public void add(int value) {\n            throw new UnsupportedOperationException();\n        }\n\n        default public IntCollection addAll(IntStream values) {\n            for (IntIterator it = values.intIterator(); it.isValid(); it.advance()) {\n                add(it.value());\n            }\n            return this;\n        }\n\n    }\n\n    static class IntArray extends IntAbstractStream implements IntList {\n        private int[] data;\n\n        public IntArray(int[] arr) {\n            data = arr;\n        }\n\n        public int size() {\n            return data.length;\n        }\n\n        public int get(int at) {\n            return data[at];\n        }\n\n        public void addAt(int index, int value) {\n            throw new UnsupportedOperationException();\n        }\n\n        public void removeAt(int index) {\n            throw new UnsupportedOperationException();\n        }\n\n        public void set(int index, int value) {\n            data[index] = value;\n        }\n\n    }\n\n    static class ArrayUtils {\n        public static int minPosition(int[] array, int from, int to) {\n            return new IntArray(array).subList(from, to).minIndex() + from;\n        }\n\n        public static long[] createArray(int count, long value) {\n            long[] array = new long[count];\n            Arrays.fill(array, value);\n            return array;\n        }\n\n    }\n\n    static abstract class IntAbstractStream implements IntStream {\n        public String toString() {\n            StringBuilder builder = new StringBuilder();\n            boolean first = true;\n            for (IntIterator it = intIterator(); it.isValid(); it.advance()) {\n                if (first) {\n                    first = false;\n                } else {\n                    builder.append(' ');\n                }\n                builder.append(it.value());\n            }\n            return builder.toString();\n        }\n\n        public boolean equals(Object o) {\n            if (!(o instanceof IntStream)) {\n                return false;\n            }\n            IntStream c = (IntStream) o;\n            IntIterator it = intIterator();\n            IntIterator jt = c.intIterator();\n            while (it.isValid() && jt.isValid()) {\n                if (it.value() != jt.value()) {\n                    return false;\n                }\n                it.advance();\n                jt.advance();\n            }\n            return !it.isValid() && !jt.isValid();\n        }\n\n        public int hashCode() {\n            int result = 0;\n            for (IntIterator it = intIterator(); it.isValid(); it.advance()) {\n                result *= 31;\n                result += it.value();\n            }\n            return result;\n        }\n\n    }\n\n    static interface IntReversableCollection extends IntCollection {\n    }\n\n    static interface IntList extends IntReversableCollection {\n        public abstract int get(int index);\n\n        public abstract void set(int index, int value);\n\n        public abstract void addAt(int index, int value);\n\n        public abstract void removeAt(int index);\n\n        default public IntIterator intIterator() {\n            return new IntIterator() {\n                private int at;\n                private boolean removed;\n\n                public int value() {\n                    if (removed) {\n                        throw new IllegalStateException();\n                    }\n                    return get(at);\n                }\n\n                public boolean advance() {\n                    at++;\n                    removed = false;\n                    return isValid();\n                }\n\n                public boolean isValid() {\n                    return !removed && at < size();\n                }\n\n                public void remove() {\n                    removeAt(at);\n                    at--;\n                    removed = true;\n                }\n            };\n        }\n\n        default public void add(int value) {\n            addAt(size(), value);\n        }\n\n        default public int minIndex() {\n            int result = Integer.MAX_VALUE;\n            int size = size();\n            int at = -1;\n            for (int i = 0; i < size; i++) {\n                int current = get(i);\n                if (current < result) {\n                    result = current;\n                    at = i;\n                }\n            }\n            return at;\n        }\n\n        default public IntList subList(final int from, final int to) {\n            return new IntList() {\n                private final int shift;\n                private final int size;\n\n                {\n                    if (from < 0 || from > to || to > IntList.this.size()) {\n                        throw new IndexOutOfBoundsException(\"from = \" + from + \", to = \" + to + \", size = \" + size());\n                    }\n                    shift = from;\n                    size = to - from;\n                }\n\n                public int size() {\n                    return size;\n                }\n\n                public int get(int at) {\n                    if (at < 0 || at >= size) {\n                        throw new IndexOutOfBoundsException(\"at = \" + at + \", size = \" + size());\n                    }\n                    return IntList.this.get(at + shift);\n                }\n\n                public void addAt(int index, int value) {\n                    throw new UnsupportedOperationException();\n                }\n\n                public void removeAt(int index) {\n                    throw new UnsupportedOperationException();\n                }\n\n                public void set(int at, int value) {\n                    if (at < 0 || at >= size) {\n                        throw new IndexOutOfBoundsException(\"at = \" + at + \", size = \" + size());\n                    }\n                    IntList.this.set(at + shift, value);\n                }\n\n                public IntList compute() {\n                    return new IntArrayList(this);\n                }\n            };\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int[] readIntArray(int size) {\n            int[] array = new int[size];\n            for (int i = 0; i < size; i++) {\n                array[i] = readInt();\n            }\n            return array;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static interface IntIterator {\n        public int value() throws NoSuchElementException;\n\n        public boolean advance();\n\n        public boolean isValid();\n\n    }\n\n    static class IntArrayList extends IntAbstractStream implements IntList {\n        private int size;\n        private int[] data;\n\n        public IntArrayList() {\n            this(3);\n        }\n\n        public IntArrayList(int capacity) {\n            data = new int[capacity];\n        }\n\n        public IntArrayList(IntCollection c) {\n            this(c.size());\n            addAll(c);\n        }\n\n        public IntArrayList(IntStream c) {\n            this();\n            if (c instanceof IntCollection) {\n                ensureCapacity(((IntCollection) c).size());\n            }\n            addAll(c);\n        }\n\n        public IntArrayList(IntArrayList c) {\n            size = c.size();\n            data = c.data.clone();\n        }\n\n        public IntArrayList(int[] arr) {\n            size = arr.length;\n            data = arr.clone();\n        }\n\n        public int size() {\n            return size;\n        }\n\n        public int get(int at) {\n            if (at >= size) {\n                throw new IndexOutOfBoundsException(\"at = \" + at + \", size = \" + size);\n            }\n            return data[at];\n        }\n\n        private void ensureCapacity(int capacity) {\n            if (data.length >= capacity) {\n                return;\n            }\n            capacity = Math.max(2 * data.length, capacity);\n            data = Arrays.copyOf(data, capacity);\n        }\n\n        public void addAt(int index, int value) {\n            ensureCapacity(size + 1);\n            if (index > size || index < 0) {\n                throw new IndexOutOfBoundsException(\"at = \" + index + \", size = \" + size);\n            }\n            if (index != size) {\n                System.arraycopy(data, index, data, index + 1, size - index);\n            }\n            data[index] = value;\n            size++;\n        }\n\n        public void removeAt(int index) {\n            if (index >= size || index < 0) {\n                throw new IndexOutOfBoundsException(\"at = \" + index + \", size = \" + size);\n            }\n            if (index != size - 1) {\n                System.arraycopy(data, index + 1, data, index, size - index - 1);\n            }\n            size--;\n        }\n\n        public void set(int index, int value) {\n            if (index >= size) {\n                throw new IndexOutOfBoundsException(\"at = \" + index + \", size = \" + size);\n            }\n            data[index] = value;\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.util.InputMismatchException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\nimport java.util.ArrayList;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        DHistogramColoring solver = new DHistogramColoring();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class DHistogramColoring {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            long[] a = in.nextLongArray(n);\n\n            Node root = makeTree(0, n, 0, a);\n\n            long MOD = 1000000007;\n            Modulo modulo = new Modulo(MOD);\n\n            out.println(calc(root, modulo)[1]);\n        }\n\n        Node makeTree(int l, int r, long h, long[] a) {\n            int minIndex = l;\n            for (int i = l; i < r; i++) {\n                if (a[i] < a[minIndex]) minIndex = i;\n            }\n\n            Node node = new Node();\n            long w = 0;\n            for (int i = l; i < r; i++) {\n                if (a[i] == a[minIndex]) {\n                    w++;\n                } else {\n                    int j = i;\n                    while (j < r && a[j] != a[minIndex]) j++;\n                    node.children.add(makeTree(i, j, a[minIndex], a));\n                    i = j - 1;\n                }\n            }\n            node.x = a[minIndex] - h;\n            node.w = w;\n\n            return node;\n        }\n\n        long[] calc(Node node, Modulo modulo) {\n            long tmp1 = 1;\n            long tmp2 = 1;\n\n            for (Node child : node.children) {\n                long[] childDp = calc(child, modulo);\n                tmp1 = modulo.mlt(tmp1, childDp[0]);\n                tmp2 = modulo.mlt(tmp2, childDp[0] + childDp[1]);\n            }\n\n            long dp1 = modulo.mlt(modulo.pow(2, node.x), tmp1);\n            long dp2 = modulo.add(modulo.mlt(modulo.pow(2, node.w), tmp2),\n                    modulo.mlt(modulo.sub(modulo.pow(2, node.x), 2), tmp1));\n\n            return new long[]{dp1, dp2};\n        }\n\n        class Node {\n            long x;\n            long w;\n            List<Node> children;\n\n            Node() {\n                children = new ArrayList<>();\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        private BufferedReader br;\n        private StringTokenizer st;\n\n        public InputReader(InputStream inputStream) {\n            br = new BufferedReader(new InputStreamReader(inputStream));\n            st = new StringTokenizer(\"\");\n        }\n\n        public String nextString() {\n            while (!st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine(), \" \");\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(nextString());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(nextString());\n        }\n\n        public long[] nextLongArray(int n) {\n            long[] res = new long[n];\n            for (int i = 0; i < n; i++) {\n                res[i] = nextLong();\n            }\n            return res;\n        }\n\n    }\n\n    static class Modulo {\n        long m;\n\n        public Modulo(long m) {\n            this.m = m;\n        }\n\n        public long add(long a, long b) {\n            return (a + b) % m;\n        }\n\n        public long sub(long a, long b) {\n            return (a - b + m) % m;\n        }\n\n        public long mlt(long a, long b) {\n            return (a * b) % m;\n        }\n\n        public long pow(long a, long x) {\n            long ans = 1;\n            while (x > 0) {\n                if ((x & 1) != 0) {\n                    ans = (ans * a) % m;\n                }\n                x >>= 1;\n                a = (a * a) % m;\n            }\n            return ans;\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nclass Main{\n  \n  static int[] h;\n  static long mod = 1000000007;\n  \n  static long pow(long a, long p, long mod){\n    long res = 1;\n    for(int i=0;i<64;++i){\n      if(((p>>i)&1)==1)res=(res*a)%mod;\n      a = (a*a)%mod;\n    }\n    return res;\n  }\n  \n  static long culc(int l, int r){\n    if(r-l <1)return 1;\n    int minIndex=l;\n    for(int i=l+1;i<r;++i)if(h[i]<h[minIndex])minIndex=i;\n    long dp1 = pow(2, h[minIndex], mod)-2;\n    long dp2 = 2;\n    for(int i=minIndex+1;i<r;++i){\n      dp2 = (dp2*2)%mod;\n      long dh = Math.max(0, h[i]-h[i-1]);\n      dp1 = ((dp1 * pow(2, dh, mod))%mod + (dp2 * (pow(2, dh, mod)-1+mod)%mod)%mod)%mod;\n    }\n    for(int i=minIndex-1;i>=l;--i){\n      dp2 = (dp2*2)%mod;\n      long dh = Math.max(0, h[i]-h[i+1]);\n      dp1 = ((dp1 * pow(2, dh, mod))%mod + (dp2 * (pow(2, dh, mod)-1+mod)%mod)%mod)%mod;\n    }\n    return (dp1+dp2)%mod;\n  }\n  \n  public static void main(String[] args){\n    Scanner scan = new Scanner(System.in);\n    int n = scan.nextInt();\n    h = new int[n+1];h[n]=1;\n    for(int i=0;i<n;++i)h[i]=scan.nextInt();\n    long totu = -1;\n    if(n>1 && h[0]>h[1]){\n      totu += h[0]-h[1];h[0]=h[1];\n    }\n    if(n>1 && h[n-1]>h[n-2]){\n      totu += h[n-1]-h[n-2];h[n-2]=h[n-1];\n    }\n    for(int i=1;i<n-1;++i){\n      if(h[i]>h[i-1] && h[i]>h[i+1]){\n        totu += h[i] - Math.max(h[i-1], h[i+1]);\n        h[i] = Math.max(h[i-1], h[i+1]);\n      }\n    }\n    int l=0;\n    long ans = 1;\n    for(int i=0;i<n+1;++i){\n      if(h[i]==1){\n        totu+=1;\n        ans = (ans * culc(l,i))%mod;\n    \tl=i+1;\n      }\n    }\n    ans = (ans * pow(2, totu, mod))%mod;\n    System.out.println(ans);\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.NoSuchElementException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Egor Kulikov (egor@egork.net)\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        DHistogramColoring solver = new DHistogramColoring();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class DHistogramColoring {\n        int n;\n        int[] h;\n        long[] ways;\n        int[][] minAt;\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            n = in.readInt();\n            h = in.readIntArray(n);\n            if (n == 1) {\n                out.printLine(IntegerUtils.power(2, h[0], MiscUtils.MOD7));\n                return;\n            }\n            long powMult = 1;\n            for (int i = 0; i < n; i++) {\n                int max;\n                if (i == 0) {\n                    max = h[1];\n                } else if (i == n - 1) {\n                    max = h[n - 2];\n                } else {\n                    max = Math.max(h[i - 1], h[i + 1]);\n                }\n                if (h[i] > max) {\n                    powMult += h[i] - max;\n                    h[i] = max;\n                }\n            }\n            ways = ArrayUtils.createArray(n + 1, -1L);\n            minAt = new int[n][n];\n            for (int i = 0; i < n; i++) {\n                for (int j = i; j < n; j++) {\n                    minAt[i][j] = ArrayUtils.minPosition(h, i, j + 1);\n                }\n            }\n            long answer = go(0);\n            answer *= IntegerUtils.power(2, powMult, MiscUtils.MOD7);\n            answer %= MiscUtils.MOD7;\n            out.printLine(answer);\n        }\n\n        private long go(int at) {\n            if (ways[at] != -1) {\n                return ways[at];\n            }\n            if (at == n) {\n                return ways[at] = 1;\n            }\n            ways[at] = 0;\n            int left = at == 0 ? 1 : h[at - 1];\n            for (int i = at + 1; i <= n; i++) {\n                int right = i == n ? 1 : h[i];\n                ways[at] += IntegerUtils.power(2, calculate(at, i - 1, left, right), MiscUtils.MOD7) * go(i) %\n                        MiscUtils.MOD7;\n            }\n            ways[at] %= MiscUtils.MOD7;\n            return ways[at];\n        }\n\n        private long calculate(int from, int to, int leftFixed, int rightFixed) {\n            if (from > to) {\n                return 0;\n            }\n            int at = minAt[from][to];\n            return Math.max(0, h[at] - Math.max(leftFixed, rightFixed)) + calculate(from, at - 1, leftFixed, h[at]) +\n                    calculate(at + 1, to, h[at], rightFixed);\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void printLine(long i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class IntegerUtils {\n        public static long power(long base, long exponent, long mod) {\n            if (base >= mod) {\n                base %= mod;\n            }\n            if (exponent == 0) {\n                return 1 % mod;\n            }\n            long result = power(base, exponent >> 1, mod);\n            result = result * result % mod;\n            if ((exponent & 1) != 0) {\n                result = result * base % mod;\n            }\n            return result;\n        }\n\n    }\n\n    static class MiscUtils {\n        public static final int MOD7 = (int) (1e9 + 7);\n\n    }\n\n    static interface IntStream extends Iterable<Integer>, Comparable<IntStream> {\n        public IntIterator intIterator();\n\n        default public Iterator<Integer> iterator() {\n            return new Iterator<Integer>() {\n                private IntIterator it = intIterator();\n\n                public boolean hasNext() {\n                    return it.isValid();\n                }\n\n                public Integer next() {\n                    int result = it.value();\n                    it.advance();\n                    return result;\n                }\n            };\n        }\n\n        default public int compareTo(IntStream c) {\n            IntIterator it = intIterator();\n            IntIterator jt = c.intIterator();\n            while (it.isValid() && jt.isValid()) {\n                int i = it.value();\n                int j = jt.value();\n                if (i < j) {\n                    return -1;\n                } else if (i > j) {\n                    return 1;\n                }\n                it.advance();\n                jt.advance();\n            }\n            if (it.isValid()) {\n                return 1;\n            }\n            if (jt.isValid()) {\n                return -1;\n            }\n            return 0;\n        }\n\n    }\n\n    static class IntArrayList extends IntAbstractStream implements IntList {\n        private int size;\n        private int[] data;\n\n        public IntArrayList() {\n            this(3);\n        }\n\n        public IntArrayList(int capacity) {\n            data = new int[capacity];\n        }\n\n        public IntArrayList(IntCollection c) {\n            this(c.size());\n            addAll(c);\n        }\n\n        public IntArrayList(IntStream c) {\n            this();\n            if (c instanceof IntCollection) {\n                ensureCapacity(((IntCollection) c).size());\n            }\n            addAll(c);\n        }\n\n        public IntArrayList(IntArrayList c) {\n            size = c.size();\n            data = c.data.clone();\n        }\n\n        public IntArrayList(int[] arr) {\n            size = arr.length;\n            data = arr.clone();\n        }\n\n        public int size() {\n            return size;\n        }\n\n        public int get(int at) {\n            if (at >= size) {\n                throw new IndexOutOfBoundsException(\"at = \" + at + \", size = \" + size);\n            }\n            return data[at];\n        }\n\n        private void ensureCapacity(int capacity) {\n            if (data.length >= capacity) {\n                return;\n            }\n            capacity = Math.max(2 * data.length, capacity);\n            data = Arrays.copyOf(data, capacity);\n        }\n\n        public void addAt(int index, int value) {\n            ensureCapacity(size + 1);\n            if (index > size || index < 0) {\n                throw new IndexOutOfBoundsException(\"at = \" + index + \", size = \" + size);\n            }\n            if (index != size) {\n                System.arraycopy(data, index, data, index + 1, size - index);\n            }\n            data[index] = value;\n            size++;\n        }\n\n        public void removeAt(int index) {\n            if (index >= size || index < 0) {\n                throw new IndexOutOfBoundsException(\"at = \" + index + \", size = \" + size);\n            }\n            if (index != size - 1) {\n                System.arraycopy(data, index + 1, data, index, size - index - 1);\n            }\n            size--;\n        }\n\n        public void set(int index, int value) {\n            if (index >= size) {\n                throw new IndexOutOfBoundsException(\"at = \" + index + \", size = \" + size);\n            }\n            data[index] = value;\n        }\n\n    }\n\n    static interface IntCollection extends IntStream {\n        public int size();\n\n        default public void add(int value) {\n            throw new UnsupportedOperationException();\n        }\n\n        default public IntCollection addAll(IntStream values) {\n            for (IntIterator it = values.intIterator(); it.isValid(); it.advance()) {\n                add(it.value());\n            }\n            return this;\n        }\n\n    }\n\n    static class IntArray extends IntAbstractStream implements IntList {\n        private int[] data;\n\n        public IntArray(int[] arr) {\n            data = arr;\n        }\n\n        public int size() {\n            return data.length;\n        }\n\n        public int get(int at) {\n            return data[at];\n        }\n\n        public void addAt(int index, int value) {\n            throw new UnsupportedOperationException();\n        }\n\n        public void removeAt(int index) {\n            throw new UnsupportedOperationException();\n        }\n\n        public void set(int index, int value) {\n            data[index] = value;\n        }\n\n    }\n\n    static class ArrayUtils {\n        public static int minPosition(int[] array, int from, int to) {\n            return new IntArray(array).subList(from, to).minIndex() + from;\n        }\n\n        public static long[] createArray(int count, long value) {\n            long[] array = new long[count];\n            Arrays.fill(array, value);\n            return array;\n        }\n\n    }\n\n    static abstract class IntAbstractStream implements IntStream {\n        public String toString() {\n            StringBuilder builder = new StringBuilder();\n            boolean first = true;\n            for (IntIterator it = intIterator(); it.isValid(); it.advance()) {\n                if (first) {\n                    first = false;\n                } else {\n                    builder.append(' ');\n                }\n                builder.append(it.value());\n            }\n            return builder.toString();\n        }\n\n        public boolean equals(Object o) {\n            if (!(o instanceof IntStream)) {\n                return false;\n            }\n            IntStream c = (IntStream) o;\n            IntIterator it = intIterator();\n            IntIterator jt = c.intIterator();\n            while (it.isValid() && jt.isValid()) {\n                if (it.value() != jt.value()) {\n                    return false;\n                }\n                it.advance();\n                jt.advance();\n            }\n            return !it.isValid() && !jt.isValid();\n        }\n\n        public int hashCode() {\n            int result = 0;\n            for (IntIterator it = intIterator(); it.isValid(); it.advance()) {\n                result *= 31;\n                result += it.value();\n            }\n            return result;\n        }\n\n    }\n\n    static interface IntReversableCollection extends IntCollection {\n    }\n\n    static interface IntList extends IntReversableCollection {\n        public abstract int get(int index);\n\n        public abstract void set(int index, int value);\n\n        public abstract void addAt(int index, int value);\n\n        public abstract void removeAt(int index);\n\n        default public IntIterator intIterator() {\n            return new IntIterator() {\n                private int at;\n                private boolean removed;\n\n                public int value() {\n                    if (removed) {\n                        throw new IllegalStateException();\n                    }\n                    return get(at);\n                }\n\n                public boolean advance() {\n                    at++;\n                    removed = false;\n                    return isValid();\n                }\n\n                public boolean isValid() {\n                    return !removed && at < size();\n                }\n\n                public void remove() {\n                    removeAt(at);\n                    at--;\n                    removed = true;\n                }\n            };\n        }\n\n        default public void add(int value) {\n            addAt(size(), value);\n        }\n\n        default public int minIndex() {\n            int result = Integer.MAX_VALUE;\n            int size = size();\n            int at = -1;\n            for (int i = 0; i < size; i++) {\n                int current = get(i);\n                if (current < result) {\n                    result = current;\n                    at = i;\n                }\n            }\n            return at;\n        }\n\n        default public IntList subList(final int from, final int to) {\n            return new IntList() {\n                private final int shift;\n                private final int size;\n\n                {\n                    if (from < 0 || from > to || to > IntList.this.size()) {\n                        throw new IndexOutOfBoundsException(\"from = \" + from + \", to = \" + to + \", size = \" + size());\n                    }\n                    shift = from;\n                    size = to - from;\n                }\n\n                public int size() {\n                    return size;\n                }\n\n                public int get(int at) {\n                    if (at < 0 || at >= size) {\n                        throw new IndexOutOfBoundsException(\"at = \" + at + \", size = \" + size());\n                    }\n                    return IntList.this.get(at + shift);\n                }\n\n                public void addAt(int index, int value) {\n                    throw new UnsupportedOperationException();\n                }\n\n                public void removeAt(int index) {\n                    throw new UnsupportedOperationException();\n                }\n\n                public void set(int at, int value) {\n                    if (at < 0 || at >= size) {\n                        throw new IndexOutOfBoundsException(\"at = \" + at + \", size = \" + size());\n                    }\n                    IntList.this.set(at + shift, value);\n                }\n\n                public IntList compute() {\n                    return new IntArrayList(this);\n                }\n            };\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int[] readIntArray(int size) {\n            int[] array = new int[size];\n            for (int i = 0; i < size; i++) {\n                array[i] = readInt();\n            }\n            return array;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static interface IntIterator {\n        public int value() throws NoSuchElementException;\n\n        public boolean advance();\n\n        public boolean isValid();\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.util.stream.Stream;\n\n/**\n * @author baito\n */\n\npublic class Main\n{\n    @SuppressWarnings(\"unchecked\")\n    static ArrayList<Edge>[] edges;\n    static boolean[] used;\n\n    public static void main(String[] args)\n    {\n        Scanner sc = new Scanner(System.in);\n        int V = sc.nextInt();\n        int E = sc.nextInt();\n        edges = Stream.generate(ArrayList::new).limit(V).toArray(ArrayList[]::new);\n        used = new boolean[V];\n        for (int i = 0; i < E; i++)\n        {\n            addEdge(sc.nextInt(), sc.nextInt(), sc.nextInt());\n        }\n        int res = fordFulkerson(0, V - 1);\n        System.out.println(res);\n    }\n\n    public static int dfs(int now, int goal, int f)\n    {\n        if (now == goal)\n        {\n            return f;\n        }\n        used[now] = true;\n        for (int i = 0; i < edges[now].size(); i++)\n        {\n            Edge e = edges[now].get(i);\n            if (!used[e.to] && e.cap > 0)\n            {\n                int flow = dfs(e.to, goal, Math.min(f, e.cap));\n                if (flow == 0) continue;\n                e.cap -= flow;\n                edges[e.to].get(e.rev).cap += flow;\n                return flow;\n            }\n        }\n        return 0;\n    }\n\n    public static int fordFulkerson(int s, int e)\n    {\n        int flow = 0;\n        while (true)\n        {\n            Arrays.fill(used, false);\n            int river = dfs(s, e, Integer.MAX_VALUE);\n            if (river == 0) return flow;\n            flow += river;\n        }\n    }\n\n    public static void addEdge(int f, int t, int c)\n    {\n        edges[f].add(new Edge(t, c, edges[t].size()));\n        edges[t].add(new Edge(f, 0, edges[f].size() - 1));\n    }\n\n    static class Edge\n    {\n        int to, cap, rev;\n\n        Edge(int to, int cap, int rev)\n        {\n            this.to = to;\n            this.cap = cap;\n            this.rev = rev;\n        }\n    }\n\n\n}\n"
  },
  {
    "language": "C#",
    "code": "//author: camypaper\nusing System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing System.Text.RegularExpressions;\nusing Debug = System.Diagnostics.Debug;\nusing SB = System.Text.StringBuilder;\nusing System.Numerics;\nusing Point = System.Numerics.Complex;\nusing static System.Math;\nusing C = System.Int32;\n\nnamespace Program {\n    public class Solver {\n        Random rnd = new Random(0);\n        public void Solve() {\n            var n = ri;\n            var h = Enumerate(n, x => ri);\n\n            //左下のブロックの色が決まっている\n            //1: RBRB...\n            //0: not 1\n            var dp = Enumerate(n, x => new ModInt[n, 2]);\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < n; j++)\n                    dp[i][j, 0].num = dp[i][j, 1].num = -1;\n            Func<int, int, int, int, ModInt> dfs = null;\n            dfs = (l, r, k, pre) =>\n              {\n                  if (dp[l][r, k].num != -1) return dp[l][r, k];\n\n\n                  var min = 1 << 30;\n                  var cnt = 0;\n                  for (int i = l; i <= r; i++)\n                      min = Min(min, h[i]);\n                  for (int i = l; i <= r; i++)\n                      if (h[i] == min) cnt++;\n\n                  if (cnt == r - l + 1) {\n                      return dp[l][r, k] = k == 0 ? ModInt.Pow(2, r - l + 1) - 2 + ModInt.Pow(2, min - pre) : ModInt.Pow(2, min - pre);\n                  }\n                  else {\n                      ModInt ret = 1;\n                      ModInt val = 1;\n                      if (k == 0) {\n                          ret *= ModInt.Pow(2, cnt);\n                          val *= ModInt.Pow(2, min - pre) - 2;\n                      }\n                      else\n                          ret *= ModInt.Pow(2, min - pre);\n\n                      int ptr = l;\n                      while (ptr <= r) {\n                          if (h[ptr] == min) ptr++;\n                          else {\n                              int p = ptr;\n                              while (ptr <= r && h[ptr] != min) ptr++;\n                              if (k == 1) ret *= dfs(p, ptr - 1, k, min);\n                              else {\n                                  ret *= dfs(p, ptr - 1, 0, min) + dfs(p, ptr - 1, 1, min);\n                                  val *= dfs(p, ptr - 1, 1, min);\n                              }\n                              ptr++;\n                          }\n\n                      }\n                      if (k == 0)\n                          ret += val;\n                      return dp[l][r, k] = ret;\n                  }\n              };\n            var ans = dfs(0, n - 1, 0, 0);\n            Console.WriteLine(ans);\n        }\n\n\n        const long INF = 1L << 60;\n        int ri => sc.Integer();\n        long rl => sc.Long();\n        double rd => sc.Double();\n        string rs => sc.Scan();\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n        static IEnumerable<int> Rep(int n) => Enumerable.Range(0, n);\n        static IEnumerable<int> RRep(int n) => Enumerable.Range(0, n).Reverse();\n        static T[] Enumerate<T>(int n, Func<int, T> f) {\n            var a = new T[n];\n            for (int i = 0; i < a.Length; ++i) a[i] = f(i);\n            return a;\n        }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex {\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n        return string.Join(st, ie);\n    }\n    static public void Main() {\n        Console.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = false });\n        var solver = new Program.Solver();\n        solver.Solve();\n        Console.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n\n    public class Printer : StreamWriter {\n        public override IFormatProvider FormatProvider => CultureInfo.InvariantCulture;\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n\n    public class StreamScanner {\n        public StreamScanner(Stream stream) { str = stream; }\n\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n\n        private byte read() {\n            if (isEof) return 0;\n            if (ptr >= len) {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0) {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n\n        public char Char() {\n            byte b = 0;\n            do b = read(); while ((b < 33 || 126 < b) && !isEof);\n            return (char)b;\n        }\n        public string Scan() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n        public int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n        public double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n}\n\n#endregion\n\n#region ModInt\n/// <summary>\n/// [0,<see cref=\"Mod\"/>) までの値を取るような数\n/// </summary>\npublic struct ModInt {\n    /// <summary>\n    /// 剰余を取る値．\n    /// </summary>\n    public const long Mod = (int)1e9 + 7;\n\n    /// <summary>\n    /// 実際の数値．\n    /// </summary>\n    public long num;\n    /// <summary>\n    /// 値が <paramref name=\"n\"/> であるようなインスタンスを構築します．\n    /// </summary>\n    /// <param name=\"n\">インスタンスが持つ値</param>\n    /// <remarks>パフォーマンスの問題上，コンストラクタ内では剰余を取りません．そのため，<paramref name=\"n\"/> ∈ [0,<see cref=\"Mod\"/>) を満たすような <paramref name=\"n\"/> を渡してください．このコンストラクタは O(1) で実行されます．</remarks>\n    public ModInt(long n) { num = n; }\n    /// <summary>\n    /// このインスタンスの数値を文字列に変換します．\n    /// </summary>\n    /// <returns>[0,<see cref=\"Mod\"/>) の範囲内の整数を 10 進表記したもの．</returns>\n    public override string ToString() { return num.ToString(); }\n    public static ModInt operator +(ModInt l, ModInt r) { l.num += r.num; if (l.num >= Mod) l.num -= Mod; return l; }\n    public static ModInt operator -(ModInt l, ModInt r) { l.num -= r.num; if (l.num < 0) l.num += Mod; return l; }\n    public static ModInt operator *(ModInt l, ModInt r) { return new ModInt(l.num * r.num % Mod); }\n    public static implicit operator ModInt(long n) { n %= Mod; if (n < 0) n += Mod; return new ModInt(n); }\n\n    /// <summary>\n    /// 与えられた 2 つの数値からべき剰余を計算します．\n    /// </summary>\n    /// <param name=\"v\">べき乗の底</param>\n    /// <param name=\"k\">べき指数</param>\n    /// <returns>繰り返し二乗法により O(N log N) で実行されます．</returns>\n    public static ModInt Pow(ModInt v, long k) { return Pow(v.num, k); }\n\n    /// <summary>\n    /// 与えられた 2 つの数値からべき剰余を計算します．\n    /// </summary>\n    /// <param name=\"v\">べき乗の底</param>\n    /// <param name=\"k\">べき指数</param>\n    /// <returns>繰り返し二乗法により O(N log N) で実行されます．</returns>\n    public static ModInt Pow(long v, long k) {\n        long ret = 1;\n        for (k %= Mod - 1; k > 0; k >>= 1, v = v * v % Mod)\n            if ((k & 1) == 1) ret = ret * v % Mod;\n        return new ModInt(ret);\n    }\n    /// <summary>\n    /// 与えられた数の逆元を計算します．\n    /// </summary>\n    /// <param name=\"v\">逆元を取る対象となる数</param>\n    /// <returns>逆元となるような値</returns>\n    /// <remarks>法が素数であることを仮定して，フェルマーの小定理に従って逆元を O(log N) で計算します．</remarks>\n    public static ModInt Inverse(ModInt v) { return Pow(v, Mod - 2); }\n}\n#endregion"
  },
  {
    "language": "Ruby",
    "code": "class SegTreeMin\n    attr_reader :dat\n    def initialize(n_input, top=Float::INFINITY)\n        @n_input = n_input\n        @n = 1 << @n_input.to_s(2).length\n        @top = top\n        @dat = Array.new(2 * @n - 1, @top)\n    end\n\n    def update(k, a)\n        k += @n - 1\n        @dat[k] = a\n        while k > 0\n            k = (k - 1) / 2\n            #@dat[k] = [@dat[2*k+1], @dat[2*k+2]].min\n            @dat[k] = @dat[2*k+1]\n            @dat[k] = @dat[2*k+2] if @dat[k] > @dat[2*k+2]\n        end\n    end\n\n    # This works only when inserting larger value than all existing values\n    def update_larger(k, a)\n        k += @n - 1\n        @dat[k] = a\n        while k > 0\n            k = (k - 1) / 2\n            if @dat[k] <= a\n                break\n            else\n                @dat[k] = a\n            end\n        end\n    end\n\n    # include a and b\n    def min_between(a, b)\n        query(a, b + 1, 0, 0, @n)\n    end\n\n    def query(a, b, k, l, r)\n        return @top if r <= a || b <= l\n        return @dat[k] if a <= l && r <= b\n        vl = query(a, b, k * 2 + 1, l, (l + r) / 2)\n        vr = query(a, b, k * 2 + 2, (l + r) / 2, r)\n        #return [vl, vr].min\n        return vl < vr ? vl : vr\n    end\nend\n\ndef power_mod(num, power)\n    prod = 1\n    num %= MOD\n    while power > 0 do\n        if power & 1 == 1\n            prod = (prod * num) % MOD\n        end\n        num = (num * num) % MOD\n        power >>= 1\n    end\n    return prod\nend\n\nclass Array\n    include Comparable\nend\n\nMOD = 10**9+7\n\nN = gets.to_i\n$hs = gets.split.map(&:to_i)\n$st = SegTreeMin.new(N, [10**10, 10**10])\nN.times do |i|\n    $st.update(i, [$hs[i], i])\nend\n\ndef rec(left, right, height)\n    if left > right\n        return [1, -1]\n    end\n    if left == right\n        num = power_mod(2, $hs[left] - height)\n        return [num, 0]\n    end\n    min, i = $st.min_between(left, right)\n    ldp1, ldp2 = rec(left, i-1, min)\n    rdp1, rdp2 = rec(i+1, right, min)\n    dp1 = ldp1 * rdp1 * power_mod(2, min-height) % MOD\n    dp2 = ((2*ldp1 + ldp2) * (2*rdp1 + rdp2) * 2 - 2 * ldp1 * rdp1) % MOD\n    return [dp1, dp2]\nend\n\nputs rec(0, N-1, 0).inject(:+) % MOD"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.format;\nimport std.conv;\nimport std.typecons;\nimport std.algorithm;\nimport std.functional;\nimport std.bigint;\nimport std.numeric;\nimport std.array;\nimport std.math;\nimport std.range;\nimport std.container;\nimport std.concurrency;\nimport std.traits;\nimport std.uni;\nimport core.bitop : popcnt;\nalias Generator = std.concurrency.Generator;\n\nenum long INF = long.max/3;\nenum long MOD = 10L^^9+7;\n\nstruct P {\n  ModNum x, y;\n  this(T)(T x, T y) {\n    this.x = x;\n    this.y = y;\n  }\n  P opBinary(string op)(P that) {\n    return P(mixin(\"this.x\"~op~\"that.x\"), mixin(\"this.y\"~op~\"that.y\"));\n  }\n  void opOpAssign(string op)(P that) {\n      this = mixin(\"this\" ~op~ \"that\");\n  }\n}\n\nvoid main() {\n  long N;\n  scanln(N);\n  long[] hs = readln.split.to!(long[]);\n  auto seg = SegTree!(long, (a, b) => a<b ? a : b, INF)(hs);\n\n  P f(long l, long r, long bottom) {\n    assert(l <= r);\n    if (l == r) return P(1, 1);\n\n    long top = seg.query(l, r);\n    long diff = top - bottom;\n    assert(diff > 0);\n\n    if (diff == 1) {\n      P p = P(1, 1);\n      long j = l;\n      foreach(i; l..r) {\n        if (hs[i] == top) {\n          P q = f(j, i, bottom);\n          p *= q;\n          p *= P(2, 1);\n          j = i+1;\n        }\n      }\n      P q = f(j, r, bottom);\n      p *= q;\n      return p;\n    } else {\n      P q = f(l, r, top-1);\n      P p = P(\n        q.x-2*q.y + 2*q.y*ModNum(2)^^(diff-1),\n        2*q.y*ModNum(2)^^(diff-2)\n      );\n      return p;\n    }\n  }\n\n  f(0, N, 0).x.writeln;\n}\n\n// RMQ (Range Minimum Query)\n// alias RMQ(T) = SegTree!(T, (a, b) => a<b ? a:b, T.max);\n\n// SegTree (Segment Tree)\nstruct SegTree(T, alias fun, T initValue)\n    if (is(typeof(fun(T.init, T.init)) : T)) {\n\nprivate:\n    Node[] _data;\n    size_t _size;\n    size_t _l, _r;\n\npublic:\n    // size ... データ数\n    // initValue ... 初期値(例えばRMQだとINF)\n    this(size_t size) {\n        init(size);\n    }\n\n    // 配列で指定\n    this(T[] ary) {\n        init(ary.length);\n        update(ary);\n    }\n\n    // O(N)\n    void init(size_t size){\n        _size = 1;\n        while(_size < size) {\n            _size *= 2;\n        }\n        _data.length = _size*2-1;\n        _data[] = Node(size_t.max, initValue);\n        _l = 0;\n        _r = size;\n    }\n\n    // i番目の要素をxに変更\n    // O(logN)\n    void update(size_t i, T x) {\n        size_t index = i;\n        i += _size-1;\n        _data[i] = Node(index, x);\n        while(i > 0) {\n            i = (i-1)/2;\n            Node nl = _data[i*2+1];\n            Node nr = _data[i*2+2];\n            _data[i] = select(nl, nr);\n        }\n    }\n\n    // 配列で指定\n    // O(N)\n    void update(T[] ary) {\n        foreach(i, e; ary) {\n            _data[i+_size-1] = Node(i, e);\n        }\n        foreach(i; (_size-1).iota.retro) {\n            Node nl = _data[i*2+1];\n            Node nr = _data[i*2+2];\n            _data[i] = select(nl, nr);\n        }\n    }\n\n    // 区間[a, b)でのクエリ (値の取得)\n    // O(logN)\n    T query(size_t a, size_t b) {\n        return queryRec(a, b, 0, 0, _size).value;\n    }\n\n    // 区間[a, b)でのクエリ (indexの取得)\n    // O(logN)\n    size_t queryIndex(size_t a, size_t b) out(result) {\n        // fun == (a, b) => a+b のようなときはindexを聞くとassertion\n        assert(result != size_t.max);\n    } body {\n        return queryRec(a, b, 0, 0, _size).index;\n    }\n\n    private Node queryRec(size_t a, size_t b, size_t k, size_t l, size_t r) {\n        if (b<=l || r<=a) return Node(size_t.max, initValue);\n        if (a<=l && r<=b) return _data[k];\n        Node nl = queryRec(a, b, k*2+1, l, (l+r)/2);\n        Node nr = queryRec(a, b, k*2+2, (l+r)/2, r);\n        return select(nl, nr);\n    }\n\n    private Node select(Node nl, Node nr) {\n        T v = fun(nl.value, nr.value);\n        if (nl.value == v) {\n            return nl;\n        } else if (nr.value == v) {\n            return nr;\n        } else {\n            return Node(size_t.max, v);\n        }\n    }\n\n    // O(1)\n    T get(size_t i) {\n        return _data[_size-1 + i].value;\n    }\n\n    // O(N)\n    T[] array() {\n        return _data[_l+_size-1.._r+_size-1].map!\"a.value\".array;\n    }\n\nprivate:\n    struct Node {\n        size_t index;\n        T value;\n    }\n}\n\n\nalias ModNum = ModNumber!(long, MOD);\n\nstruct ModNumber(T, T mod) if (__traits(isIntegral, T)) {\n    private enum FACT_MAX = 1000000;\n\n    T value;\n    this(T value) {\n        this.value = value;\n        this.value %= mod;\n        this.value += mod;\n        this.value %= mod;\n    }\n\n    ModNumber opAssign(T value) {\n        this.value = value;\n        return this;\n    }\n\n    ModNumber opBinary(string op)(ModNumber that) if (op==\"+\" || op==\"-\" || op==\"*\") {\n        return ModNumber(mixin(\"(this.value \"~op~\" that.value + mod) % mod\"));\n    }\n    ModNumber opBinary(string op)(T that) if (op==\"+\" || op==\"-\" || op==\"*\") {\n        return ModNumber(mixin(\"(this.value \"~op~\" that + mod) % mod\"));\n    }\n    ModNumber opBinaryRight(string op)(T that) if (op==\"+\" || op==\"-\" || op==\"*\") {\n        return ModNumber(mixin(\"(that \"~op~\" this.value + mod) % mod\"));\n    }\n\n    ModNumber opBinary(string op)(ModNumber that) if (op == \"/\") {\n        return this*getReciprocal(that);\n    }\n    ModNumber opBinary(string op)(T that) if (op == \"/\") {\n        return this*getReciprocal(ModNumber(that));\n    }\n    ModNumber opBinaryRight(string op)(T that) if (op == \"/\") {\n        return ModNumber(that)*getReciprocal(this);\n    }\n\n    ModNumber opBinary(string op)(ModNumber that) if (op == \"^^\") {\n        return ModNumber(modPow(this.value, that.value));\n    }\n    ModNumber opBinary(string op)(T that) if (op == \"^^\") {\n        return ModNumber(modPow(this.value, that));\n    }\n    ModNumber opBinaryRight(string op)(T that) if (op == \"^^\") {\n        return ModNumber(modPow(that, this.value));\n    }\n\n    void opOpAssign(string op)(ModNumber that) if (op==\"+\" || op==\"-\" || op==\"*\" || op==\"/\") {\n        this = mixin(\"this\" ~op~ \"that\");\n    }\n    void opOpAssign(string op)(T that) if (op==\"+\" || op==\"-\" || op==\"*\" || op==\"/\") {\n        this = mixin(\"this\" ~op~ \"that\");\n    }\n\n    ModNumber getReciprocal(ModNumber x) in {\n        debug assert(isPrime(mod));\n    } body {\n        return ModNumber(modPow(x.value, mod-2));\n    }\n    T modPow(T base, T power)  {\n        T result = 1;\n        for (; power > 0; power >>= 1) {\n            if (power & 1) {\n                result = (result * base) % mod;\n            }\n            base = base*base % mod;\n        }\n        return result;\n    }\n\n    static bool isPrime(T n) {\n        if (n<2) {\n            return false;\n        } else if (n==2) {\n            return true;\n        } else if (n%2==0) {\n            return false;\n        } else {\n            for(T i=3; i*i<=n; i+=2) {\n                if (n%i==0) return false;\n            }\n            return true;\n        }\n    }\n\n    // n! : 階乗\n    static ModNumber fact(T n) {\n        assert(0<=n && n<=FACT_MAX);\n        static ModNumber[] memo;\n        if (memo.length == 0) memo = new ModNumber[FACT_MAX+1];\n        if (memo[n] != ModNumber.init) {\n            return memo[n];\n        } else {\n            return memo[n] = n==0 ? ModNumber(1) : n*fact(n-1);\n        }\n    }\n\n    // 1/(n!) : 階乗の逆元 (逆元テーブルを用いる)\n    static ModNumber invFact(T n) {\n        assert(0<=n && n<=FACT_MAX);\n        static ModNumber inverse(T n) {\n            assert(1<=n && n<=FACT_MAX);\n            static ModNumber[] memo;\n            if (memo.length == 0) memo = new ModNumber[FACT_MAX+1];\n            if (memo[n] != ModNumber.init) {\n                return memo[n];\n            } else {\n                return memo[n] = n==1 ? ModNumber(1) : ModNumber(-mod/n)*inverse(mod%n);\n            }\n        }\n        static ModNumber[] memo;\n        if (memo.length == 0) memo = new ModNumber[FACT_MAX+1];\n        if (memo[n] != ModNumber.init) {\n            return memo[n];\n        } else {\n            return memo[n] = n==0 ? ModNumber(1) : inverse(n)*invFact(n-1);\n        }\n    }\n\n    // {}_n C_r: 組合せ\n    static ModNumber comb(T n, T r) {\n        import std.functional : memoize;\n        if (r<0 || r>n) return ModNumber(0);\n        if (r*2 > n) return comb(n, n-r);\n\n        if (n<=FACT_MAX) {\n            return fact(n) * invFact(r) * invFact(n-r); // 逆元テーブルを使用する\n            // return fact(n) / fact(r) / fact(n-r); // 逆元テーブルを使用しない\n        }\n\n        ModNum mul(T l, T r) {\n            return l>r ? ModNumber(1) : l * memoize!mul(l+1, r);\n        }\n        return memoize!mul(n-r+1, n) / memoize!mul(1, r);\n    }\n\n    // {}_n H_r: 重複組合せ (Homogeneous Combination)\n    static ModNumber hComb(T n, T r) {\n        return comb(n+r-1, r);\n    }\n\n    string toString() {\n        import std.conv;\n        return this.value.to!string;\n    }\n\n    invariant {\n        assert(this.value>=0);\n        assert(this.value<mod);\n    }\n}\n\n\n// ----------------------------------------------\n\n\nvoid times(alias fun)(long n) {\n    // n.iota.each!(i => fun());\n    foreach(i; 0..n) fun();\n}\nauto rep(alias fun, T = typeof(fun()))(long n) {\n    // return n.iota.map!(i => fun()).array;\n    T[] res = new T[n];\n    foreach(ref e; res) e = fun();\n    return res;\n}\n\nT ceil(T)(T x, T y) if (isIntegral!T || is(T == BigInt)) {\n    // `(x+y-1)/y` will only work for positive numbers ...\n    T t = x / y;\n    if (t * y < x) t++;\n    return t;\n}\n\nT floor(T)(T x, T y) if (isIntegral!T || is(T == BigInt)) {\n    T t = x / y;\n    if (t * y > x) t--;\n    return t;\n}\n\nvoid ch(alias fun, T, S...)(ref T lhs, S rhs) {\n  lhs = fun(lhs, rhs);\n}\nunittest {\n  long x = 1000;\n  x.ch!min(2000);\n  assert(x == 1000);\n  x.ch!min(3, 2, 1);\n  assert(x == 1);\n}\n\nmixin template Constructor() {\n    import std.traits : FieldNameTuple;\n    this(Args...)(Args args) {\n        // static foreach(i, v; args) {\n        foreach(i, v; args) {\n            mixin(\"this.\" ~ FieldNameTuple!(typeof(this))[i]) = v;\n        }\n    }\n}\n\nvoid scanln(Args...)(auto ref Args args) {\n    import std.meta;\n    template getFormat(T) {\n        static if (isIntegral!T) {\n            enum getFormat = \"%d\";\n        } else static if (isFloatingPoint!T) {\n            enum getFormat = \"%g\";\n        } else static if (isSomeString!T || isSomeChar!T) {\n            enum getFormat = \"%s\";\n        } else {\n            static assert(false);\n        }\n    }\n    enum string str = [staticMap!(getFormat, Args)].join(\" \") ~ \"\\n\";\n    // readf!str(args);\n    mixin(\"str.readf(\" ~ Args.length.iota.map!(i => \"&args[%d]\".format(i)).join(\", \") ~ \");\");\n}\n\n// fold was added in D 2.071.0\nstatic if (__VERSION__ < 2071) {\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n}\n\n// cumulativeFold was added in D 2.072.0\nstatic if (__VERSION__ < 2072) {\n    template cumulativeFold(fun...)\n    if (fun.length >= 1)\n    {\n        import std.meta : staticMap;\n        private alias binfuns = staticMap!(binaryFun, fun);\n\n        auto cumulativeFold(R)(R range)\n        if (isInputRange!(Unqual!R))\n        {\n            return cumulativeFoldImpl(range);\n        }\n\n        auto cumulativeFold(R, S)(R range, S seed)\n        if (isInputRange!(Unqual!R))\n        {\n            static if (fun.length == 1)\n                return cumulativeFoldImpl(range, seed);\n            else\n                return cumulativeFoldImpl(range, seed.expand);\n        }\n\n        private auto cumulativeFoldImpl(R, Args...)(R range, ref Args args)\n        {\n            import std.algorithm.internal : algoFormat;\n\n            static assert(Args.length == 0 || Args.length == fun.length,\n                algoFormat(\"Seed %s does not have the correct amount of fields (should be %s)\",\n                    Args.stringof, fun.length));\n\n            static if (args.length)\n                alias State = staticMap!(Unqual, Args);\n            else\n                alias State = staticMap!(ReduceSeedType!(ElementType!R), binfuns);\n\n            foreach (i, f; binfuns)\n            {\n                static assert(!__traits(compiles, f(args[i], e)) || __traits(compiles,\n                        { args[i] = f(args[i], e); }()),\n                    algoFormat(\"Incompatible function/seed/element: %s/%s/%s\",\n                        fullyQualifiedName!f, Args[i].stringof, E.stringof));\n            }\n\n            static struct Result\n            {\n            private:\n                R source;\n                State state;\n\n                this(R range, ref Args args)\n                {\n                    source = range;\n                    if (source.empty)\n                        return;\n\n                    foreach (i, f; binfuns)\n                    {\n                        static if (args.length)\n                            state[i] = f(args[i], source.front);\n                        else\n                            state[i] = source.front;\n                    }\n                }\n\n            public:\n                @property bool empty()\n                {\n                    return source.empty;\n                }\n\n                @property auto front()\n                {\n                    assert(!empty, \"Attempting to fetch the front of an empty cumulativeFold.\");\n                    static if (fun.length > 1)\n                    {\n                        import std.typecons : tuple;\n                        return tuple(state);\n                    }\n                    else\n                    {\n                        return state[0];\n                    }\n                }\n\n                void popFront()\n                {\n                    assert(!empty, \"Attempting to popFront an empty cumulativeFold.\");\n                    source.popFront;\n\n                    if (source.empty)\n                        return;\n\n                    foreach (i, f; binfuns)\n                        state[i] = f(state[i], source.front);\n                }\n\n                static if (isForwardRange!R)\n                {\n                    @property auto save()\n                    {\n                        auto result = this;\n                        result.source = source.save;\n                        return result;\n                    }\n                }\n\n                static if (hasLength!R)\n                {\n                    @property size_t length()\n                    {\n                        return source.length;\n                    }\n                }\n            }\n\n            return Result(range, args);\n        }\n    }\n}\n\n// minElement/maxElement was added in D 2.072.0\nstatic if (__VERSION__ < 2072) {\n    private auto extremum(alias map, alias selector = \"a < b\", Range)(Range r)\n    if (isInputRange!Range && !isInfinite!Range &&\n        is(typeof(unaryFun!map(ElementType!(Range).init))))\n    in\n    {\n        assert(!r.empty, \"r is an empty range\");\n    }\n    body\n    {\n        alias Element = ElementType!Range;\n        Unqual!Element seed = r.front;\n        r.popFront();\n        return extremum!(map, selector)(r, seed);\n    }\n\n    private auto extremum(alias map, alias selector = \"a < b\", Range,\n                          RangeElementType = ElementType!Range)\n                         (Range r, RangeElementType seedElement)\n    if (isInputRange!Range && !isInfinite!Range &&\n        !is(CommonType!(ElementType!Range, RangeElementType) == void) &&\n         is(typeof(unaryFun!map(ElementType!(Range).init))))\n    {\n        alias mapFun = unaryFun!map;\n        alias selectorFun = binaryFun!selector;\n\n        alias Element = ElementType!Range;\n        alias CommonElement = CommonType!(Element, RangeElementType);\n        Unqual!CommonElement extremeElement = seedElement;\n\n        alias MapType = Unqual!(typeof(mapFun(CommonElement.init)));\n        MapType extremeElementMapped = mapFun(extremeElement);\n\n        // direct access via a random access range is faster\n        static if (isRandomAccessRange!Range)\n        {\n            foreach (const i; 0 .. r.length)\n            {\n                MapType mapElement = mapFun(r[i]);\n                if (selectorFun(mapElement, extremeElementMapped))\n                {\n                    extremeElement = r[i];\n                    extremeElementMapped = mapElement;\n                }\n            }\n        }\n        else\n        {\n            while (!r.empty)\n            {\n                MapType mapElement = mapFun(r.front);\n                if (selectorFun(mapElement, extremeElementMapped))\n                {\n                    extremeElement = r.front;\n                    extremeElementMapped = mapElement;\n                }\n                r.popFront();\n            }\n        }\n        return extremeElement;\n    }\n    private auto extremum(alias selector = \"a < b\", Range)(Range r)\n        if (isInputRange!Range && !isInfinite!Range &&\n            !is(typeof(unaryFun!selector(ElementType!(Range).init))))\n    {\n        alias Element = ElementType!Range;\n        Unqual!Element seed = r.front;\n        r.popFront();\n        return extremum!selector(r, seed);\n    }\n    private auto extremum(alias selector = \"a < b\", Range,\n                          RangeElementType = ElementType!Range)\n                         (Range r, RangeElementType seedElement)\n        if (isInputRange!Range && !isInfinite!Range &&\n            !is(CommonType!(ElementType!Range, RangeElementType) == void) &&\n            !is(typeof(unaryFun!selector(ElementType!(Range).init))))\n    {\n        alias Element = ElementType!Range;\n        alias CommonElement = CommonType!(Element, RangeElementType);\n        Unqual!CommonElement extremeElement = seedElement;\n        alias selectorFun = binaryFun!selector;\n\n        // direct access via a random access range is faster\n        static if (isRandomAccessRange!Range)\n        {\n            foreach (const i; 0 .. r.length)\n            {\n                if (selectorFun(r[i], extremeElement))\n                {\n                    extremeElement = r[i];\n                }\n            }\n        }\n        else\n        {\n            while (!r.empty)\n            {\n                if (selectorFun(r.front, extremeElement))\n                {\n                    extremeElement = r.front;\n                }\n                r.popFront();\n            }\n        }\n        return extremeElement;\n    }\n    auto minElement(Range)(Range r)\n        if (isInputRange!Range && !isInfinite!Range)\n    {\n        return extremum(r);\n    }\n    auto minElement(alias map, Range, RangeElementType = ElementType!Range)\n                   (Range r, RangeElementType seed)\n    if (isInputRange!Range && !isInfinite!Range &&\n        !is(CommonType!(ElementType!Range, RangeElementType) == void))\n    {\n        return extremum!map(r, seed);\n    }\n    auto minElement(Range, RangeElementType = ElementType!Range)\n                   (Range r, RangeElementType seed)\n        if (isInputRange!Range && !isInfinite!Range &&\n            !is(CommonType!(ElementType!Range, RangeElementType) == void))\n    {\n        return extremum(r, seed);\n    }\n    auto maxElement(alias map, Range)(Range r)\n    if (isInputRange!Range && !isInfinite!Range)\n    {\n        return extremum!(map, \"a > b\")(r);\n    }\n    auto maxElement(Range)(Range r)\n    if (isInputRange!Range && !isInfinite!Range)\n    {\n        return extremum!`a > b`(r);\n    }\n    auto maxElement(alias map, Range, RangeElementType = ElementType!Range)\n                   (Range r, RangeElementType seed)\n    if (isInputRange!Range && !isInfinite!Range &&\n        !is(CommonType!(ElementType!Range, RangeElementType) == void))\n    {\n        return extremum!(map, \"a > b\")(r, seed);\n    }\n    auto maxElement(Range, RangeElementType = ElementType!Range)\n                   (Range r, RangeElementType seed)\n    if (isInputRange!Range && !isInfinite!Range &&\n        !is(CommonType!(ElementType!Range, RangeElementType) == void))\n    {\n        return extremum!`a > b`(r, seed);\n    }\n}\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict, deque, Counter\nfrom heapq import heappush, heappop, heapify\nimport math\nimport bisect\nimport random\nfrom itertools import permutations, accumulate, combinations, product\nimport sys\nimport string\nfrom bisect import bisect_left, bisect_right\nfrom math import factorial, ceil, floor\nfrom operator import mul\nfrom functools import reduce\n\n\nsys.setrecursionlimit(2147483647)\nINF = 10 ** 13\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef I(): return int(sys.stdin.readline())\ndef LS(): return sys.stdin.buffer.readline().rstrip().decode('utf-8').split()\ndef S(): return sys.stdin.buffer.readline().rstrip().decode('utf-8')\ndef IR(n): return [I() for i in range(n)]\ndef LIR(n): return [LI() for i in range(n)]\ndef SR(n): return [S() for i in range(n)]\ndef LSR(n): return [LS() for i in range(n)]\ndef SRL(n): return [list(S()) for i in range(n)]\ndef MSRL(n): return [[int(j) for j in list(S())] for i in range(n)]\nmod = 10 ** 9 + 7\n\nn = I()\nH = LI() + [1]\ndp = [1] * (n + 1)\n\nfor k in range(n):\n    new_dp = [0] * (n + 1)\n    for i in range(n + 1):\n        if H[i] > H[k]:\n            new_dp[i] = dp[k] * 2\n        elif H[k - 1] <= H[i]:\n            new_dp[i] = dp[i] * 2 * pow(2, H[k] - H[i], mod)\n        elif H[k - 1] > H[k]:\n            new_dp[i] = dp[i] - dp[k] + dp[k] * 2\n        else:\n            new_dp[i] = (dp[i] - dp[k - 1] + dp[k - 1] * 2) * pow(2, H[k] - H[k - 1], mod)\n        new_dp[i] %= mod\n    dp = new_dp\n\n\nprint(dp[-1])\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict, deque, Counter\nfrom heapq import heappush, heappop, heapify\nimport math\nimport bisect\nimport random\nfrom itertools import permutations, accumulate, combinations, product\nimport sys\nimport string\nfrom bisect import bisect_left, bisect_right\nfrom math import factorial, ceil, floor\nfrom operator import mul\nfrom functools import reduce\n\n\nsys.setrecursionlimit(2147483647)\nINF = 10 ** 13\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef I(): return int(sys.stdin.readline())\ndef LS(): return sys.stdin.buffer.readline().rstrip().decode('utf-8').split()\ndef S(): return sys.stdin.buffer.readline().rstrip().decode('utf-8')\ndef IR(n): return [I() for i in range(n)]\ndef LIR(n): return [LI() for i in range(n)]\ndef SR(n): return [S() for i in range(n)]\ndef LSR(n): return [LS() for i in range(n)]\ndef SRL(n): return [list(S()) for i in range(n)]\ndef MSRL(n): return [[int(j) for j in list(S())] for i in range(n)]\nmod = 10 ** 9 + 7\n\nn = I()\nH = LI() + [1]\ndp = [0] * (n + 1)\nret = pow(2, H[0], mod)\nfor kk in range(n + 1):\n    if H[0] >= H[kk]:\n        dp[kk] = pow(2, H[0] - H[kk], mod) * 2\n    else:\n        dp[kk] = 2\n\n\nfor k in range(1, n):\n    new_dp = [0] * (n + 1)\n    for i in range(n + 1):\n        if H[i] <= H[k]:\n            if H[k - 1] <= H[i]:\n                new_dp[i] = dp[i] * 2 * pow(2, H[k] - H[i], mod)\n            elif H[k - 1] > H[k]:\n                new_dp[i] = dp[i] - dp[k] + dp[k] * 2\n            else:\n                new_dp[i] = (dp[i] - dp[k - 1] + dp[k - 1] * 2) * pow(2, H[k] - H[k - 1], mod)\n        else:\n            new_dp[i] = dp[k] * 2\n        new_dp[i] %= mod\n    dp = new_dp\n\n\nprint(dp[-1])\n"
  },
  {
    "language": "Python",
    "code": "mod=10**9+7\nn=int(input())\nH=list(map(int,input().split()))\n\ndef solve(h):\n    if not h:\n        return 1\n    elif len(h)==1:\n        return pow(2,h[0],mod)\n    N=len(h)\n    a=[h[i] for i in range(N)]\n    a=list(set(a))\n    a.sort()\n    comp={i:e+1 for e,i in enumerate(a)}\n    data={comp[e]:e for e in comp.keys()}\n    data[0]=0\n    data[0]=1\n    #print(comp)\n\n    dp=[[0 for i in range(len(a)+1)] for j in range(N)]\n\n    i=0\n    if h[i+1]>=h[i]:\n        id=comp[h[i]]\n        id2=comp[h[i+1]]\n        for j in range(id,id2+1):\n            dp[i][j]=2\n        for j in range(0,id):\n            dp[i][j]=1\n    else:\n        id=comp[h[i+1]]\n        for j in range(0,id):\n            dp[i][j]=pow(2,h[i]-h[i+1],mod)\n        dp[i][id]=2*(pow(2,h[i]-h[i+1],mod)-1)\n        dp[i][id]%=mod\n        id2=comp[h[i]]\n        dp[i][id]+=2\n        dp[i][id]%=mod\n\n    for i in range(1,N-1):\n        if h[i+1]>=h[i]:\n            id=comp[h[i]]\n            id2=comp[h[i+1]]\n            for j in range(id,id2+1):\n                dp[i][j]=(2*dp[i-1][id])%mod\n            for j in range(0,id):\n                dp[i][j]=dp[i-1][j]\n        else:\n            id=comp[h[i+1]]\n            id2=comp[h[i]]\n            for j in range(0,id):\n                dp[i][j]=(pow(2,h[i]-h[i+1],mod)*dp[i-1][j])%mod\n            for j in range(id,id2):\n                low=data[j]\n                up=data[j+1]-1\n                dp[i][id]+=dp[i-1][j]*pow(2,h[i]-up,mod)*(pow(2,up-low+1,mod)-1)\n            dp[i][id]%=mod\n            dp[i][id]+=2*dp[i-1][id2]\n            dp[i][id]%=mod\n\n    ans=0\n    id=comp[h[-1]]\n    for i in range(0,id):\n        low=data[i]\n        up=data[i+1]-1\n        ans+=dp[N-2][i]*pow(2,h[-1]-up,mod)*(pow(2,up-low+1,mod)-1)\n        ans%=mod\n    ans+=2*dp[N-2][id]\n    ans%=mod\n    return ans\n\nans=pow(2,H.count(1),mod)\ncheck=[i for i in range(n) if H[i]==1]\ncheck=[-1]+check+[n]\nfor i in range(len(check)-1):\n    l,r=check[i],check[i+1]\n    ans*=solve(H[l+1:r])\n    ans%=mod\n\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\n\nMOD = 10**9+7\ndef compress(L):\n    L2 = list(set(L))\n    L2.sort()\n    C = {v : k for k, v in enumerate(L2)}\n    return L2, C\n\nN = int(readline())\nheight = [0]\nH = list(map(int, readline().split()))\nheight.extend(H)\n\norih, C = compress(height)\n\nL = len(orih)\n\ndp = [0]*L\ndp[0] = 1\n\nphidx = 0\nfor i in range(1, N+1):\n    hidx = C[H[i-1]]\n    dp2 = [0]*L\n    if phidx >= hidx:\n        for h in range(hidx+1):\n            dp2[h] = (dp[hidx]+dp[h])%MOD\n    else:\n        if phidx == 0:\n            dp2[0] = pow(2, orih[hidx])%MOD\n            for h in range(1, hidx+1):\n                dp2[h] = pow(2,  orih[hidx]-orih[h]+1, MOD)\n        else:\n            for h in range(hidx+1):\n                dp2[h] = (dp[phidx] + dp[min(phidx, h)])*pow(2, orih[hidx]-orih[max(h, phidx)], MOD)%MOD\n    dp = dp2[:]\n    phidx = hidx\n    #print(dp)\nprint(dp[0])\n            \n"
  },
  {
    "language": "Python",
    "code": "mod=10**9+7\nn=int(input())\nH=list(map(int,input().split()))\n\ndef solve(h):\n    if not h:\n        return 1\n    elif len(h)==1:\n        return pow(2,h[0],mod)\n    N=len(h)\n    a=[h[i] for i in range(N)]\n    a=list(set(a))\n    a.sort()\n    comp={i:e+1 for e,i in enumerate(a)}\n    data={comp[e]:e for e in comp.keys()}\n    data[0]=0\n    data[0]=1\n    #print(comp)\n\n    dp=[[0 for i in range(len(a)+1)] for j in range(N)]\n\n    i=0\n    if h[i+1]>=h[i]:\n        id=comp[h[i]]\n        dp[i][id]=2\n        dp[i][id+1]=2\n        for j in range(0,id):\n            dp[i][j]=1\n    else:\n        id=comp[h[i+1]]\n        for j in range(0,id):\n            dp[i][j]=pow(2,h[i]-h[i+1],mod)\n        dp[i][id]=2*(pow(2,h[i]-h[i+1],mod)-1)\n        dp[i][id]%=mod\n        id2=comp[h[i]]\n        dp[i][id]+=2\n        dp[i][id]%=mod\n\n    for i in range(1,N-1):\n        if h[i+1]>=h[i]:\n            id=comp[h[i]]\n            id2=comp[h[i+1]]\n            for j in range(id,id2+1):\n                dp[i][j]=(2*dp[i-1][id])%mod\n            for j in range(0,id):\n                dp[i][j]=dp[i-1][j]\n        else:\n            id=comp[h[i+1]]\n            id2=comp[h[i]]\n            for j in range(0,id):\n                dp[i][j]=(pow(2,h[i]-h[i+1],mod)*dp[i-1][j])%mod\n            for j in range(id,id2):\n                low=data[j]\n                up=data[j+1]-1\n                dp[i][id]+=dp[i-1][j]*pow(2,h[i]-up,mod)*(pow(2,up-low+1,mod)-1)\n            dp[i][id]%=mod\n            dp[i][id]+=2*dp[i-1][id2]\n            dp[i][id]%=mod\n\n    ans=0\n    id=comp[h[-1]]\n    for i in range(0,id):\n        low=data[i]\n        up=data[i+1]-1\n        ans+=dp[N-2][i]*pow(2,h[-1]-up,mod)*(pow(2,up-low+1,mod)-1)\n        ans%=mod\n    ans+=2*dp[N-2][id]\n    ans%=mod\n    return ans\n\nans=pow(2,H.count(1),mod)\ncheck=[i for i in range(n) if H[i]==1]\ncheck=[-1]+check+[n]\nfor i in range(len(check)-1):\n    l,r=check[i],check[i+1]\n    ans*=solve(H[l+1:r])\n    ans%=mod\n\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "\nimport sys\n#sys.stdin=open(\"data.txt\")\ninput=sys.stdin.readline\n\nMOD=10**9+7\n\ndef powmod(b,e):\n    global MOD\n    if e==0: return 1\n    if e&1: return (powmod((b*b)%MOD,e//2)*b)%MOD\n    return powmod((b*b)%MOD,e//2)\n\nn=int(input())\nh=[1]+list(map(int,input().split()))\n\n\"\"\"\n# naive solution, O(sum h_i)\narchive=[]\n\n# do rows\na1=[1]\nfor i in range(1,n+1):\n    if h[i]<=h[i-1]:\n        c=0\n        while len(a1)>h[i]:\n            c+=a1.pop(-1)\n        a1[0]=((a1[0]+c)*2)%MOD\n    else:\n        a1[0]=(a1[0]*2)%MOD\n        mul=powmod(2,h[i]-h[i-1])\n        for j in range(1,len(a1)):\n            a1[j]=(a1[j]*mul)%MOD\n        extras=[a1[0]]\n        for _ in range(h[i]-h[i-1]-1):\n            extras.append(extras[-1]*2)\n        a1+=extras[::-1]\n    archive.append(a1)\n\nprint(sum(a1)%MOD)\n\"\"\"\n\n# smarter solution? i think it's O(N^2)\nroot=1      # number of times that this column just alternates\npos=[]      # [x,y] means it starts at x, and its size is y blocks\nsz=1\nfor i in range(1,n+1):\n    if h[i]<=h[i-1]:\n        c=0\n        while pos and sz-pos[-1][1]>=h[i]:\n            a,b=pos.pop(-1)\n            c+=(a*(powmod(2,b)-1))%MOD\n            sz-=b\n        if sz>h[i]:\n            a,b=pos.pop(-1)\n            pos.append([(a*powmod(2,sz-h[i]))%MOD,b-(sz-h[i])])\n            c+=(a*(powmod(2,sz-h[i])-1))%MOD\n            sz=h[i]\n        root=((root+c)*2)%MOD\n    else:\n        root=(root*2)%MOD\n        mul=powmod(2,h[i]-h[i-1])\n        for j in range(len(pos)):\n            pos[j][0]=(pos[j][0]*mul)%MOD\n        pos.append([root,h[i]-h[i-1]])\n        sz=h[i]\n\n# get answer\nfor a,b in pos:\n    root+=(a*(powmod(2,b)-1))%MOD\nprint(root%MOD)"
  },
  {
    "language": "Python",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\n#define ll long long\n#define ld long double\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define SZ(x) (int)(x).size()\ntemplate <typename T> using ord_set = tree <T, null_type, less <T>, rb_tree_tag, tree_order_statistics_node_update>;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int N = 105, MOD = 1e9 + 7;\nint n, h[N], mn[N][N], dp[2][N][N], same[N][N], g[N][N], p[N];\n\nint bp(int x, int y) {\n\tint res = 1;\n\twhile (y) {\n\t\tif (y & 1)\n\t\t\tres = (ll)res * x % MOD;\n\t\tx = (ll)x * x % MOD;\n\t\ty /= 2;\n\t}\n\treturn res;\n}\n\nvoid add(int & x, int y) {\n\tx += y;\n\tif (x >= MOD) x -= MOD;\n}\n\nint get(int l, int r) {\n\tif (l > r) return 1;\n\tint & res = g[l][r];\n\tif (res != -1) return res;\n\treturn res = (ll)bp(2, max(0, h[l] - max(h[l - 1], mn[l + 1][r + 1]))) * get(l + 1, r) % MOD;\n}\n\nint solve(int f, int l, int r) {\n\tif (l > r) return 1;\n\tint & res = dp[f][l][r];\n\tif (res != -1) return res;\n\tres = 0;\n\tif (f == 0) {\n\t\tfor (int i = l; i <= r; i++)\n\t\t\tadd(res, (ll)get(l, i) * solve(1, i + 1, r) % MOD);\n\t}\telse {\n\t\tfor (int i = l + 1; i <= r; i++)\n\t\t\tadd(res, (ll)same[l][i] * solve(0, i + 1, r) % MOD);\n\t}\n\treturn res;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false), cin.tie(NULL);\n\t#ifdef LOCAL\n\t\tfreopen(\"input.txt\", \"r\", stdin);\n\t#endif\n\t\n\tmemset(& g, -1, sizeof(g));\n\tmemset(& dp, -1, sizeof(dp));\n\tcin >> n;\n\tint mul = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> h[i];\n\t\tif (h[i] == 1) mul++, h[i] = 0;\n\t}\n\tfor (int r = n + 1; r >= 1; r--) {\n\t\tmn[r][r] = h[r];\n\t\tfor (int l = r - 1; l >= 1; l--) {\n\t\t\tmn[l][r] = min(h[l], mn[l + 1][r]);\n\t\t}\n\t}\n\tp[0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 0; j <= i - 2; j++) {\n\t\t\tadd(p[i], p[j]);\n\t\t}\n\t}\n\tfor (int l = 1; l <= n; l++) {\n\t\tfor (int r = l; r <= n; r++) {\n\t\t\tsame[l][r] = 1;\n\t\t\tfor (int k = l; k <= r; k++) {\n\t\t\t\tint hl = (k == l) ? 0 : h[k - 1];\n\t\t\t\tint hr = (k == r) ? 0 : h[k + 1];\n\t\t\t\tsame[l][r] = (ll)same[l][r] * bp(2, max(0, h[k] - max(hl, hr))) % MOD;\n\t\t\t}\n\t\t\tsame[l][r] = (ll)same[l][r] * p[r - l + 1] % MOD;\n\t\t}\n\t}\n\tint last = 0, res = 1;\n\tfor (int i = 1; i <= n + 1; i++) {\n\t\tif (h[i] == 0) {\n\t\t\tif (last + 1 <= i - 1) {\n\t\t\t\tint cur = (solve(0, last + 1, i - 1) + solve(1, last + 1, i - 1)) % MOD;\n\t\t\t\tcur = cur * 2 % MOD;\n\t\t\t\tcur = (cur - get(last + 1, i - 1) + MOD) % MOD;\n\t\t\t\tres = (ll)res * cur % MOD;\n\t\t\t}\n\t\t\tlast = i;\n\t\t}\n\t}\n\tcout << (ll)res * bp(2, mul) % MOD;\n}\n"
  },
  {
    "language": "Python",
    "code": "\n\"\"\"\n\nhttps://atcoder.jp/contests/agc026/tasks/agc026_d\n\n10101100011\n01010011100\n\n→1列目を決めたとする\n→2列目の置き方は、左端を決めればすべて決まる\n偶数列目を反転してみる？\n\n10 → 11\n01    00\n\n10 → 11\n10    11\n\nすなわち、偶数列目が反転して表示されるとすると\n\n全て01を入れ替える or 全てそのまま　しか許されない\n→すべてそのままが可能なのは全て0 or 1のときのみ\n\ndp[i][0][X] = i列目の下からX個まですべて0の時の通り数\ndp[i][1][X] = i列目の下からX個まですべて1の時の通り数\n→答えは dp[i][0][0]\n\nif h[i-1] >= h[i]:\n    dp[i][0][X] = dp[i-1][1][X] + dp[i-1][0][h[i]]\n    dp[i][1][X] = dp[i-1][0][X] + dp[i-1][1][h[i]]\nelse:\n    if X <= h[i-1]:\n        dp[i][0][X] = (dp[i-1][1][X] + dp[i-1][0][h[i-1]]) * pow(2,h[i]-h[i-1],mod)\n        dp[i][1][X] = (dp[i-1][0][X] + dp[i-1][1][h[i-1]]) * pow(2,h[i]-h[i-1],mod)\n    else:\n        dp[i][0][X] = (dp[i-1][1][h[i-1]] + dp[i-1][0][h[i-1]]) * pow(2,h[i]-X,mod)\n        dp[i][1][X] = (dp[i-1][0][h[i-1]] + dp[i-1][1][h[i-1]]) * pow(2,h[i]-X,mod)\n\n\"\"\"\n\nfrom sys import stdin\n\nN = int(stdin.readline())\nh = list(map(int,stdin.readline().split()))\nmod = 10**9+7\n\ndp = [ [{},{}] for i in range(N) ]\nnumlis = set()\nnumlis.add(1)\nfor i in h:\n    numlis.add(i)\nfor i in numlis:\n    if i <= h[0]:\n        dp[0][0][i] = pow(2,h[0]-i,mod)\n        dp[0][1][i] = pow(2,h[0]-i,mod)\n\nfor i in range(1,N):\n\n    for X in numlis:\n        if X > h[i]:\n            continue\n\n        if h[i-1] >= h[i]:\n            dp[i][0][X] = (dp[i-1][1][X] + dp[i-1][0][h[i]]) % mod\n            dp[i][1][X] = (dp[i-1][0][X] + dp[i-1][1][h[i]]) % mod\n        else:\n            if X <= h[i-1]:\n                dp[i][0][X] = (dp[i-1][1][X] + dp[i-1][0][h[i-1]]) * pow(2,h[i]-h[i-1],mod) % mod\n                dp[i][1][X] = (dp[i-1][0][X] + dp[i-1][1][h[i-1]]) * pow(2,h[i]-h[i-1],mod) % mod\n            else:\n                dp[i][0][X] = (dp[i-1][1][h[i-1]] + dp[i-1][0][h[i-1]]) * pow(2,h[i]-X,mod) % mod\n                dp[i][1][X] = (dp[i-1][0][h[i-1]] + dp[i-1][1][h[i-1]]) * pow(2,h[i]-X,mod) % mod\n\nprint ((dp[N-1][0][1] + dp[N-1][1][1]) % mod)\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict, deque, Counter\nfrom heapq import heappush, heappop, heapify\nimport math\nimport bisect\nimport random\nfrom itertools import permutations, accumulate, combinations, product\nimport sys\nimport string\nfrom bisect import bisect_left, bisect_right\nfrom math import factorial, ceil, floor\nfrom operator import mul\nfrom functools import reduce\n\n\nsys.setrecursionlimit(2147483647)\nINF = 10 ** 13\ndef LI(): return list(map(int, sys.stdin.buffer.readline().split()))\ndef I(): return int(sys.stdin.buffer.readline())\ndef LS(): return sys.stdin.buffer.readline().rstrip().decode('utf-8').split()\ndef S(): return sys.stdin.buffer.readline().rstrip().decode('utf-8')\ndef IR(n): return [I() for i in range(n)]\ndef LIR(n): return [LI() for i in range(n)]\ndef SR(n): return [S() for i in range(n)]\ndef LSR(n): return [LS() for i in range(n)]\ndef SRL(n): return [list(S()) for i in range(n)]\ndef MSRL(n): return [[int(j) for j in list(S())] for i in range(n)]\nmod = 10 ** 9 + 7\n\n\nn = I()\nH = LI() + [1]\nA = [0] * n\nr = 1\nret = 1\nans = 1\ndd  = 1\nfor k in range(n - 1, -1, -1):\n    if H[k - 1] == 1 and H[k + 1] == 1:\n        ans = ans * pow(2, H[k], mod) % mod\n    elif H[k] == 1:\n        r = 1\n        ret = 1\n        ans = ans * 2 % mod\n    elif H[k - 1] == 1:\n        d = min(H[k], H[k + 1])\n        ret = ret * 2 + r * (pow(2, d, mod) - 2)\n        ans = ans * ret % mod\n        ans = ans * pow(2, max(H[k] - max(H[k - 1], H[k + 1]), 0), mod)\n    else:\n        if H[k] > H[k - 1] and H[k + 1] > H[k - 1]:\n            if H[k] > H[k + 1]:\n                d = H[k + 1] - H[k - 1]\n            else:\n                d = H[k] - H[k - 1]\n            ret = ret + r * (pow(2, d, mod) - 1)\n            r = r * pow(2, d, mod) % mod\n        ret = ret * 2 % mod\n        ans = ans * pow(2, max(H[k] - max(H[k - 1], H[k + 1]), 0), mod)\n\n\n\nprint(ans % mod)\n# print(acc)\n# print(c)\n# 40, 96 , 4"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\n\nMOD = 10**9+7\ndef compress(L):\n    L2 = list(set(L))\n    L2.sort()\n    C = {v : k for k, v in enumerate(L2)}\n    return L2, C\n\nN = int(readline())\nheight = [0]\nH = list(map(int, readline().split()))\nheight.extend(H)\n\norih, C = compress(height)\n\nL = len(orih)\n\ndp = [0]*L\ndp[0] = 1\n\nphidx = 0\nfor i in range(1, N+1):\n    hidx = C[H[i-1]]\n    dp2 = [0]*L\n    if phidx >= hidx:\n        for h in range(hidx+1):\n            dp2[h] = (dp[hidx]+dp[h])%MOD\n    else:\n        if phidx == 0:\n            dp2[0] = pow(2, orih[hidx])\n            for h in range(1, hidx+1):\n                dp2[h] = pow(2,  orih[hidx]-orih[h]+1, MOD)\n        else:\n            for h in range(hidx+1):\n                dp2[h] = (dp[phidx] + dp[min(phidx, h)])*pow(2, orih[hidx]-orih[max(h, phidx)])%MOD\n    dp = dp2[:]\n    phidx = hidx\n    #print(dp)\nprint(dp[0])\n            \n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict, deque, Counter\nfrom heapq import heappush, heappop, heapify\nimport math\nimport bisect\nimport random\nfrom itertools import permutations, accumulate, combinations, product\nimport sys\nimport string\nfrom bisect import bisect_left, bisect_right\nfrom math import factorial, ceil, floor\nfrom operator import mul\nfrom functools import reduce\n\n\nsys.setrecursionlimit(2147483647)\nINF = 10 ** 13\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef I(): return int(sys.stdin.readline())\ndef LS(): return sys.stdin.buffer.readline().rstrip().decode('utf-8').split()\ndef S(): return sys.stdin.buffer.readline().rstrip().decode('utf-8')\ndef IR(n): return [I() for i in range(n)]\ndef LIR(n): return [LI() for i in range(n)]\ndef SR(n): return [S() for i in range(n)]\ndef LSR(n): return [LS() for i in range(n)]\ndef SRL(n): return [list(S()) for i in range(n)]\ndef MSRL(n): return [[int(j) for j in list(S())] for i in range(n)]\nmod = 10 ** 9 + 7\n\nn = I()\nH = LI() + [1]\ndp = [1] * (n + 1)\n\nfor k in range(n):\n    new_dp = [0] * (n + 1)\n    for i in range(n + 1):\n        if H[i] > H[k]:\n            new_dp[i] = dp[k] * 2\n        elif H[k - 1] <= H[i]:\n            new_dp[i] = dp[i] * 2 * pow(2, H[k] - H[i], mod)\n        elif H[k - 1] > H[k]:\n            new_dp[i] = dp[i] + dp[k]\n        else:\n            new_dp[i] = (dp[i] + dp[k - 1]) * pow(2, H[k] - H[k - 1], mod)\n        new_dp[i] %= mod\n    dp = new_dp\n\n\nprint(dp[-1])\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict, deque, Counter\nfrom heapq import heappush, heappop, heapify\nimport math\nimport bisect\nimport random\nfrom itertools import permutations, accumulate, combinations, product\nimport sys\nimport string\nfrom bisect import bisect_left, bisect_right\nfrom math import factorial, ceil, floor\nfrom operator import mul\nfrom functools import reduce\n\n\nsys.setrecursionlimit(2147483647)\nINF = 10 ** 13\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef I(): return int(sys.stdin.readline())\ndef LS(): return sys.stdin.buffer.readline().rstrip().decode('utf-8').split()\ndef S(): return sys.stdin.buffer.readline().rstrip().decode('utf-8')\ndef IR(n): return [I() for i in range(n)]\ndef LIR(n): return [LI() for i in range(n)]\ndef SR(n): return [S() for i in range(n)]\ndef LSR(n): return [LS() for i in range(n)]\ndef SRL(n): return [list(S()) for i in range(n)]\ndef MSRL(n): return [[int(j) for j in list(S())] for i in range(n)]\nmod = 10 ** 9 + 7\n\nn = I()\nH = LI()\ndp = [2] * n\nret = pow(2, H[0], mod)\nfor kk in range(n):\n    if H[0] > H[kk]:\n        dp[kk] = pow(2, H[0] - H[kk], mod)\n    else:\n        dp[kk] = 2\n\n\nfor k in range(1, n):\n    for i in range(n):\n        if H[i] < H[k]:\n            dp[i] = dp[i] * 2 * pow(2, H[k] - H[i] - 1, mod) % mod\n        else:\n            dp[i] = dp[i] * 2 % mod\n    if H[k] == 1:\n        ret = ret * 2 % mod\n    elif H[k] > H[k - 1]:\n        ret = dp[k] * 2 + (ret - dp[k]) * pow(2, H[k] - H[k - 1], mod)\n    else:\n        ret = dp[k] * 2 + (ret - dp[k])\n    ret %= mod\n\n\n\nprint(ret)\n# print(acc)\n# print(c)\n# 40, 96 , 4\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict, deque, Counter\nfrom heapq import heappush, heappop, heapify\nimport math\nimport bisect\nimport random\nfrom itertools import permutations, accumulate, combinations, product\nimport sys\nimport string\nfrom bisect import bisect_left, bisect_right\nfrom math import factorial, ceil, floor\nfrom operator import mul\nfrom functools import reduce\n\n\nsys.setrecursionlimit(2147483647)\nINF = 10 ** 13\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef I(): return int(sys.stdin.readline())\ndef LS(): return sys.stdin.buffer.readline().rstrip().decode('utf-8').split()\ndef S(): return sys.stdin.buffer.readline().rstrip().decode('utf-8')\ndef IR(n): return [I() for i in range(n)]\ndef LIR(n): return [LI() for i in range(n)]\ndef SR(n): return [S() for i in range(n)]\ndef LSR(n): return [LS() for i in range(n)]\ndef SRL(n): return [list(S()) for i in range(n)]\ndef MSRL(n): return [[int(j) for j in list(S())] for i in range(n)]\nmod = 10 ** 9 + 7\n\nn = I()\nH = LI()\ndp = [2] * n\nret = pow(2, H[0], mod)\nfor kk in range(n):\n    if H[0] > H[kk]:\n        dp[kk] = pow(2, H[0] - H[kk], mod)\n    else:\n        dp[kk] = 2\n\n\nfor k in range(1, n):\n    for i in range(n):\n        if H[i] < H[k]:\n            dp[i] = dp[i] * 2 * pow(2, H[k] - H[i] - 1, mod) % mod\n        else:\n            dp[i] = dp[i] * 2 % mod\n    if H[k] == 1:\n        ret = ret * 2 % mod\n    elif H[k] > H[k - 1]:\n        ret = dp[k] * 2 + (ret - dp[k]) * pow(2, H[k] - H[k - 1], mod)\n    else:\n        ret = dp[k] * 2 + (ret - dp[k])\n\n\n\nprint(ret)\n# print(acc)\n# print(c)\n# 40, 96 , 4\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict, deque, Counter\nfrom heapq import heappush, heappop, heapify\nimport math\nimport bisect\nimport random\nfrom itertools import permutations, accumulate, combinations, product\nimport sys\nimport string\nfrom bisect import bisect_left, bisect_right\nfrom math import factorial, ceil, floor\nfrom operator import mul\nfrom functools import reduce\n\n\nsys.setrecursionlimit(2147483647)\nINF = 10 ** 13\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef I(): return int(sys.stdin.readline())\ndef LS(): return sys.stdin.buffer.readline().rstrip().decode('utf-8').split()\ndef S(): return sys.stdin.buffer.readline().rstrip().decode('utf-8')\ndef IR(n): return [I() for i in range(n)]\ndef LIR(n): return [LI() for i in range(n)]\ndef SR(n): return [S() for i in range(n)]\ndef LSR(n): return [LS() for i in range(n)]\ndef SRL(n): return [list(S()) for i in range(n)]\ndef MSRL(n): return [[int(j) for j in list(S())] for i in range(n)]\nmod = 10 ** 9 + 7\n\nn = I()\nH = LI() + [1]\ndp = [1] * (n + 1)\n\nfor k in range(n):\n    new_dp = [0] * (n + 1)\n    for i in range(n + 1):\n        if H[i] <= H[k]:\n            if H[k - 1] <= H[i]:\n                new_dp[i] = dp[i] * 2 * pow(2, H[k] - H[i], mod)\n            elif H[k - 1] > H[k]:\n                new_dp[i] = dp[i] - dp[k] + dp[k] * 2\n            else:\n                new_dp[i] = (dp[i] - dp[k - 1] + dp[k - 1] * 2) * pow(2, H[k] - H[k - 1], mod)\n        else:\n            new_dp[i] = dp[k] * 2\n        new_dp[i] %= mod\n    dp = new_dp\n\n\nprint(dp[-1])\n"
  },
  {
    "language": "Python",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\nconst LL MOD = 1000000007;\nLL powmod(LL a, LL n){\n    if(n == 0) return 1;\n    if(n % 2) return (a*powmod(a,n-1)) % MOD;\n    LL c = powmod(a, n/2);\n    return (c*c) % MOD;\n}\nLL inv(LL a){\n    return powmod(a, MOD-2);\n}\nLL fact[110000];\nLL invfact[110000];\n\nLL ncr(LL n, LL r){\n    if(r < 0 || n < 0) return 0;\n    if(n < r) return 0;\n    LL a = fact[n];\n    a = (a * invfact[r]) % MOD;\n    a = (a * invfact[n-r]) % MOD;\n    return a;\n}\nvoid init(){\n    fact[0] = 1;\n    invfact[0] = 1;\n    LL inv2 = inv(2);\n    for(LL i = 1; i < 110000; i++){\n        fact[i] = (i*fact[i-1]) % MOD;\n        invfact[i] = inv(fact[i]);\n    }\n}\n\npair<LL,LL> solve(vector<LL> a){\n\tLL r = a[0];\n\tfor(int j = 0; j < a.size(); j++){\n\t\tr = min(r, a[j]);\n\t}\n\tLL num0 = 0;\n\tfor(int j = 0; j < a.size(); j++){\n\t\ta[j] -= r;\n\t\tif(a[j] == 0) num0++;\n\t}\n\tvector<LL> cur;\n\tLL total = powmod(2, num0);\n\tLL alternating = 2;\n\ta.push_back(0);\n\n\tfor(int j = 0; j < a.size(); j++){\n\t\tif(a[j] == 0 && cur.size() > 0){\n\t\t\tpair<LL,LL> d = solve(cur);\n\t\t\tcur.clear();\n\t\t\ttotal = (total * (d.first + d.second) ) % MOD;\n\t\t\talternating = (alternating * d.second) % MOD;\n\t\t}\n\t\tif(a[j] != 0){\n\t\t\tcur.push_back(a[j]);\n\t\t}\n\t\tif(a[j] == 0){\n\t\t\tnum0 ++;\n\t\t}\n\t}\n\ttotal -= alternating;\n\talternating = (alternating * powmod(2, r-1)) % MOD;\n\ttotal += alternating;\n\ttotal %= MOD;\n\tif(total < 0) total += MOD;\n\tif(alternating < 0) alternating += MOD;\n\treturn {total, alternating};\n}\nint main(){\n\tLL N;\n\tcin >> N;\n\tvector<LL> h;\n\tfor(int i = 0; i < N; i++){\n\t\tLL a;\n\t\tcin >> a;\n\t\th.push_back(a);\n\t}\n\tpair<LL,LL> ans = solve(h);\n\tcout << ans.first << endl;\n}\n"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\n\nimport numpy as np\n\nMOD = 10**9 + 7\n\nN = int(readline())\nH = [int(x) for x in readline().split()]\n\n# 「初の同色」の位置によって場合分け。座圧して、近い区間のものは和をまとめて持つようにする。\n\nH_unique = sorted(set([0,1]+H))\nH_to_I = {h:i for i,h in enumerate(H_unique)}\n\nitems = [0] + [y-x for x,y in zip(H_unique,H_unique[1:])]\n\ninv = pow(2,MOD-2,MOD)\ncoef = np.array([(pow(2,x+1,MOD)-2) * pow(inv,h,MOD) % MOD for x,h in zip(items,H_unique)],np.int64)\n\ndp = np.zeros(len(H_unique),np.int64)\ndp[0] = 1\nI1,H1 = 1,1\nfor H2 in H:\n    I2 = H_to_I[H2]\n    prev = dp\n    dp = np.zeros_like(prev)\n    if I1 < I2:\n        dp[0] = 2*prev[0]\n        dp[1:I1+1] = prev[1:I1+1] * pow(2,H2-H1,MOD)\n        dp[I1+1:I2+1] = coef[I1+1:I2+1] * pow(2,H2,MOD) % MOD * prev[0] % MOD\n    else:\n        prev[0] += prev[I2+1:].sum()\n        dp += prev\n        dp[0] *= 2\n        dp[I2+1:] = 0\n    dp %= MOD\n    I1,H1 = I2,H2\n\nanswer = dp.sum()%MOD\nprint(answer)"
  },
  {
    "language": "Rust",
    "code": "// ---------- begin ModInt ----------\nconst MOD: u32 = 1_000_000_007;\n\n#[derive(Clone, Copy)]\nstruct ModInt(u32);\n\nimpl std::ops::Add for ModInt {\n    type Output = ModInt;\n    fn add(self, rhs: ModInt) -> Self::Output {\n        let mut d = self.0 + rhs.0;\n        if d >= MOD {\n            d -= MOD;\n        }\n        ModInt(d)\n    }\n}\n\nimpl std::ops::AddAssign for ModInt {\n    fn add_assign(&mut self, rhs: ModInt) {\n        *self = *self + rhs;\n    }\n}\n\nimpl std::ops::Sub for ModInt {\n    type Output = ModInt;\n    fn sub(self, rhs: ModInt) -> Self::Output {\n        let mut d = self.0 + MOD - rhs.0;\n        if d >= MOD {\n            d -= MOD;\n        }\n        ModInt(d)\n    }\n}\n\nimpl std::ops::SubAssign for ModInt {\n    fn sub_assign(&mut self, rhs: ModInt) {\n        *self = *self - rhs;\n    }\n}\n\nimpl std::ops::Mul for ModInt {\n    type Output = ModInt;\n    fn mul(self, rhs: ModInt) -> Self::Output {\n        ModInt((self.0 as u64 * rhs.0 as u64 % MOD as u64) as u32)\n    }\n}\n\nimpl std::ops::MulAssign for ModInt {\n    fn mul_assign(&mut self, rhs: ModInt) {\n        *self = *self * rhs;\n    }\n}\n\nimpl std::ops::Neg for ModInt {\n    type Output = ModInt;\n    fn neg(self) -> Self::Output {\n        ModInt(if self.0 == 0 {0} else {MOD - self.0})\n    }\n}\n\nimpl std::fmt::Display for ModInt {\n    fn fmt<'a>(&self, f: &mut std::fmt::Formatter<'a>) -> std::fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl std::str::FromStr for ModInt {\n    type Err = std::num::ParseIntError;\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        let val = s.parse::<u32>()?;\n        Ok(ModInt::new(val))\n    }\n}\n\n#[allow(dead_code)]\nimpl ModInt {\n    pub fn new(n: u32) -> ModInt {\n        ModInt(n % MOD)\n    }\n    pub fn zero() -> ModInt {\n        ModInt(0)\n    }\n    pub fn one() -> ModInt {\n        ModInt(1)\n    }\n    pub fn pow(self, mut n: u32) -> ModInt {\n        let mut t = ModInt::one();\n        let mut s = self;\n        while n > 0 {\n            if n & 1 == 1 {\n                t *= s;\n            }\n            s *= s;\n            n >>= 1;\n        }\n        t\n    }\n    pub fn inv(self) -> ModInt {\n        assert!(self.0 > 0);\n        self.pow(MOD - 2)\n    }\n}\n// ---------- end ModInt ----------\n// ---------- begin Precalc ----------\n#[allow(dead_code)]\nstruct Precalc {\n    inv: Vec<ModInt>,\n    fact: Vec<ModInt>,\n    ifact: Vec<ModInt>,\n}\n\n#[allow(dead_code)]\nimpl Precalc {\n    pub fn new(n: usize) -> Precalc {\n        let mut inv = vec![ModInt::one(); n + 1];\n        let mut fact = vec![ModInt::one(); n + 1];\n        let mut ifact = vec![ModInt::one(); n + 1];\n        for i in 2..(n + 1) {\n            inv[i] = -inv[MOD as usize % i] * ModInt(MOD / i as u32);\n            fact[i] = fact[i - 1] * ModInt(i as u32);\n            ifact[i] = ifact[i - 1] * inv[i];\n        }\n        Precalc {\n            inv: inv,\n            fact: fact,\n            ifact: ifact,\n        }\n    }\n    pub fn inv(&self, n: usize) -> ModInt {\n        self.inv[n]\n    }\n    pub fn fact(&self, n: usize) -> ModInt {\n        self.fact[n]\n    }\n    pub fn ifact(&self, n: usize) -> ModInt {\n        self.ifact[n]\n    }\n    pub fn comb(&self, n: usize, k: usize) -> ModInt {\n        if k > n {\n            return ModInt::zero();\n        }\n        self.fact[n] * self.ifact[k] * self.ifact[n - k]\n    }\n}\n// ---------- end Precalc ----------\n\nuse std::io::Read;\n\n// BB, RR があったら次の状態が一意に定まるはず\n// BRBRB.. みたいな交互だったら次の状態は2通り、どちらも交互\n// 上から塗ってマージしていくことができそう?\n\n// 連続、交互\nfn calc(h: &mut [u32]) -> (ModInt, ModInt) {\n    let mut g = vec![];\n    g.extend_from_slice(h);\n    let d = h.iter().cloned().min().unwrap();\n    for h in h.iter_mut() {\n        *h -= d;\n    }\n    if *h.iter().max().unwrap() == 0 {\n        let (x, y) = (ModInt(2).pow(h.len() as u32) - ModInt(2), ModInt(2).pow(d));\n        return (x, y);\n    }\n    let mut a = vec![];\n    let mut cnt = 0;\n    let mut l = 0;\n    while l < h.len() {\n        if h[l] == 0 {\n            cnt += 1;\n            l += 1;\n        } else {\n            let mut r = l + 1;\n            while r < h.len() && h[r] > 0 {\n                r += 1;\n            }\n            a.push(calc(&mut h[l..r]));\n            l = r;\n        }\n    }\n    let mut x = ModInt::one();\n    let mut y = ModInt(2);\n    for a in a.iter() {\n        x *= a.0 + a.1 * ModInt(2);\n        y *= a.1;\n    }\n    let (x, y) = (x * ModInt(2).pow(cnt) - y, y);\n    let y = y * ModInt(2).pow(d - 1);\n    (x, y)\n}\n\nfn run() {\n    let mut s = String::new();\n    std::io::stdin().read_to_string(&mut s).unwrap();\n    let mut it = s.trim().split_whitespace();\n    let n: usize = it.next().unwrap().parse().unwrap();\n    let mut h: Vec<u32> = it.map(|s| s.parse().unwrap()).collect();\n    if n == 1 {\n        let ans = ModInt(2).pow(h[0]);\n        println!(\"{}\", ans);\n        return;\n    }\n    let mut ans = ModInt::one();\n    if h[0] > h[1] {\n        ans *= ModInt(2).pow(h[0]- h[1]);\n        h[0] = h[1];\n    }\n    if h[n - 1] > h[n - 2] {\n        ans *= ModInt(2).pow(h[n - 1]- h[n - 2]);\n        h[n - 1] = h[n - 2];\n    }\n    for i in 1..(n - 1) {\n        let d = std::cmp::max(h[i - 1], h[i + 1]);\n        if h[i] > d {\n            ans *= ModInt(2).pow(h[i] - d);\n            h[i] = d;\n        }\n    }\n    let (a, b) = calc(&mut h);\n    ans *= a + b;\n    println!(\"{}\", ans);\n}\n\nfn main() {\n    run();\n}\n"
  },
  {
    "language": "Rust",
    "code": "use io::*;\nuse modular::*;\n\nfn main() {\n    let con = read_string();\n    let mut sc = Scanner::new(&con);\n\n    let n: usize = sc.next();\n    let h: Vec<usize> = sc.next_vec(n);\n\n    println!(\"{}\", solve(&h).1);\n}\n\nfn solve(h: &[usize]) -> (Modular, Modular) {\n    let mut vs: Vec<Vec<usize>> = vec![];\n    let mut cur = vec![];\n    let minh = *h.iter().min().unwrap();\n    let mut mins = 0;\n\n    for i in 0..h.len() + 1 {\n        if i == h.len() || h[i] == minh {\n            if cur.len() > 0 {\n                vs.push(cur);\n                cur = vec![];\n            }\n            if i < h.len() {\n                mins += 1;\n            }\n        } else {\n            cur.push(h[i] - minh);\n        }\n    }\n\n    let mut stripe: Modular = 2.into();\n    let mut total: Modular = 1.into();\n\n    for ref v in vs.iter() {\n        let t = solve(&v);\n        stripe *= t.0;\n        total *= t.0 + t.1;\n    }\n\n    total *= Modular::new(2).pow(mins as i64);\n    total += stripe * (Modular::new(2).pow(minh as i64 - 1) - 1);\n    stripe *= Modular::new(2).pow(minh as i64 - 1);\n\n    (stripe, total)\n}\n\n//-----\n\npub mod io {\n    use std;\n    use std::str::FromStr;\n\n    pub struct Scanner<'a> {\n        iter: std::str::SplitWhitespace<'a>,\n    }\n\n    impl<'a> Scanner<'a> {\n        pub fn new(s: &'a str) -> Scanner<'a> {\n            Scanner {\n                iter: s.split_whitespace(),\n            }\n        }\n\n        pub fn next<T: FromStr>(&mut self) -> T {\n            let s = self.iter.next().unwrap();\n            if let Ok(v) = s.parse::<T>() {\n                v\n            } else {\n                panic!(\"Parse error\")\n            }\n        }\n\n        pub fn next_vec_len<T: FromStr>(&mut self) -> Vec<T> {\n            let n: usize = self.next();\n            self.next_vec(n)\n        }\n\n        pub fn next_vec<T: FromStr>(&mut self, n: usize) -> Vec<T> {\n            (0..n).map(|_| self.next()).collect()\n        }\n    }\n\n    pub fn read_string() -> String {\n        use std::io::Read;\n\n        let mut s = String::new();\n        std::io::stdin().read_to_string(&mut s).unwrap();\n        s\n    }\n\n    pub fn read_line() -> String {\n        let mut s = String::new();\n        std::io::stdin().read_line(&mut s).unwrap();\n        s.trim_right().to_owned()\n    }\n}\n\npub mod modular {\n    const M: i64 = 1000000007;\n\n    #[derive(Debug, Clone, Copy, Default, PartialOrd, Ord, PartialEq, Eq)]\n    pub struct Modular(i64);\n\n    impl ::std::fmt::Display for Modular {\n        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n            write!(f, \"{}\", self.0)\n        }\n    }\n\n    impl Modular {\n        pub fn new(v: i64) -> Modular {\n            Modular(v % M)\n        }\n\n        pub fn pow(self, mut r: i64) -> Modular {\n            let mut k = self;\n            let mut ret = 1.into();\n\n            while r > 0 {\n                if r % 2 != 0 {\n                    ret = ret * k;\n                }\n                r /= 2;\n                k = k * k;\n            }\n\n            ret\n        }\n\n        // This requires M is prime\n        pub fn recip(self) -> Modular {\n            self.pow(M - 2)\n        }\n    }\n\n    use std::ops::*;\n\n    impl<T: Into<Modular>> Add<T> for Modular {\n        type Output = Modular;\n        fn add(self, rhs: T) -> Self::Output {\n            Modular::new(self.0 + rhs.into().0)\n        }\n    }\n    impl<T: Into<Modular>> AddAssign<T> for Modular {\n        fn add_assign(&mut self, rhs: T) {\n            *self = *self + rhs;\n        }\n    }\n\n    impl<T: Into<Modular>> Sub<T> for Modular {\n        type Output = Modular;\n        fn sub(self, rhs: T) -> Self::Output {\n            Modular::new(self.0 - rhs.into().0 + M)\n        }\n    }\n    impl<T: Into<Modular>> SubAssign<T> for Modular {\n        fn sub_assign(&mut self, rhs: T) {\n            *self = *self - rhs;\n        }\n    }\n\n    impl<T: Into<Modular>> Mul<T> for Modular {\n        type Output = Modular;\n        fn mul(self, rhs: T) -> Self::Output {\n            Modular::new(self.0 * rhs.into().0)\n        }\n    }\n    impl<T: Into<Modular>> MulAssign<T> for Modular {\n        fn mul_assign(&mut self, rhs: T) {\n            *self = *self * rhs;\n        }\n    }\n\n    impl<T: Into<Modular>> Div<T> for Modular {\n        type Output = Modular;\n        fn div(self, rhs: T) -> Self::Output {\n            self * rhs.into().recip()\n        }\n    }\n    impl<T: Into<Modular>> DivAssign<T> for Modular {\n        fn div_assign(&mut self, rhs: T) {\n            *self = *self / rhs;\n        }\n    }\n\n    impl Neg for Modular {\n        type Output = Modular;\n        fn neg(self) -> Self::Output {\n            Modular(0) - self\n        }\n    }\n\n    impl<T: ::std::convert::Into<i64>> ::std::convert::From<T> for Modular {\n        fn from(v: T) -> Self {\n            Modular::new(v.into())\n        }\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "// https://atcoder.jp/contests/agc026/tasks/agc026_d\n//\n#![allow(unused_imports)]\nuse std::io::*;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\n\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($a:expr),*) => {\n        println!(concat!($(stringify!($a), \" = {:?}, \"),*), $($a),*);\n    }\n}\n\nconst MOD: i64 = 1e9 as i64 + 7;\n\nfn powmod(a: i64, p: i64, m: i64) -> i64 {\n    let mut ret = 1i64;\n    let mut aa = a;\n    let mut pp = p;\n    while pp >= 1 {\n        if pp & 1 == 1 {\n            ret *= aa;\n            ret %= m;\n        }\n        aa = aa * aa % m;\n        pp >>= 1;\n    }\n    ret\n}\n\nfn pow2(p: i64) -> i64 {\n    powmod(2, p, MOD)\n}\n\nfn main() {\n    input! {\n        n: usize,\n        a: [i64; n]\n    };\n\n\n    let mut aw = a.clone();\n    aw.sort();\n\n    let mut blocks = vec![];\n    {\n        let mut last = 0;\n        for h in aw {\n            if last < h {\n                blocks.push(h - last);\n            }\n            last = h;\n        }\n    }\n    let mut heights = vec![0; n];\n    for i in 0..n {\n        let mut cnt = 0;\n        let mut sum = 0;\n        for &b in &blocks {\n            sum += b;\n            cnt += 1;\n            if sum == a[i] {\n                heights[i] = cnt;\n                break;\n            }\n        }\n    }\n\n    let hn = blocks.len();\n    let mut dp = vec![vec![vec![0; 2]; hn+1]; n+1];\n    dp[0][0][0] = 1;\n\n    println!(\"{:?}\", blocks);\n    println!(\"{:?}\", heights);\n\n    for i in 0..n {\n        for h in 0..hn+1 {\n            for f in 0..2 {\n                let base = dp[i][h][f];\n                if base == 0 {\n                    continue;\n                }\n\n\n\n                // [from, to]\n                let mut fromh = 1;\n                let mut toh = 0;\n\n                let mut sameh = h;\n                if i == 0 {\n                    fromh = 1;\n                    toh = heights[i];\n                } else {\n                    fromh = heights[i-1]+1;\n                    toh = heights[i];\n                    if (f == 0 && h > heights[i]) || (f == 1 && h >= heights[i]) {\n                        sameh = 0;\n                    }\n                }\n\n                // println!(\"{} {} {} {} / {} {} {}\", i, h, f, base, fromh, toh, sameh);\n\n                let prevways = if sameh == 0 { 2 } else { 1 };\n                let mut totalh = 0;\n                for hi in fromh..toh+1 {\n                    totalh += blocks[hi-1];\n                }\n\n                if sameh == 0 {\n                    for hi in fromh..toh+1 {\n                        if hi >= 2 {\n                            // between\n                            dp[i+1][hi-1][1] += base * prevways % MOD * pow2(totalh-1) % MOD;\n                            dp[i+1][hi-1][1] %= MOD;\n\n                            // else\n                            dp[i+1][hi][0] += base * prevways % MOD * (pow2(blocks[hi-1]-1) + MOD - 1) % MOD * pow2(totalh - blocks[hi-1]) % MOD;\n                            dp[i+1][hi][0] %= MOD;\n                        } else {\n                            // else\n                            dp[i+1][hi][0] += base % MOD * (pow2(blocks[hi-1]) + MOD - 2) % MOD * pow2(totalh - blocks[hi-1]) % MOD;\n                            dp[i+1][hi][0] %= MOD;\n                        }\n                        totalh -= blocks[hi-1];\n                    }\n\n                    dp[i+1][0][0] += base * prevways % MOD;\n                    dp[i+1][0][0] %= MOD;\n                } else {\n                    dp[i+1][h][f] += base * pow2(totalh);\n                    dp[i+1][h][f] %= MOD;\n                }\n           }\n        }\n    }\n\n    let mut total = 0;\n    for h in 0..hn+1 {\n        for f in 0..2 {\n            total += dp[n][h][f];\n            total %= MOD;\n        }\n    }\n    println!(\"{}\", total);\n}\n"
  },
  {
    "language": "Rust",
    "code": "const MOD: i64 = 1_000_000_007;\n\nfn pow(a: i64, b: i64) -> i64 {\n    if b == 0 {\n        1\n    } else {\n        let t = pow(a, b/2);\n        let t = t * t % MOD;\n        if b % 2 == 0 {\n            t\n        } else {\n            t * a % MOD\n        }\n    }\n}\n\nfn solve(h: Vec<i64>) -> (i64, i64) {\n    //println!(\"{:?}\", h);\n    let hmin = *h.iter().min().unwrap();\n    let mut dp0 = 1;\n    let mut dp1 = 1;\n    let mut k = Vec::new();\n    let mut cnt = 0;\n    for i in 0..(h.len()) {\n        let hi = h[i];\n        if i + 1 < h.len() && (hi == hmin || h[i+1] == hmin) {\n            cnt += 1;\n        }\n        if hi == hmin {\n            if k.len() >= 1 {\n                let (mut tmp0, mut tmp1) = solve(k.clone());\n                tmp0 += tmp1;\n                tmp1 *= 2;\n                dp0 *= tmp0;\n                dp0 %= MOD;\n                dp1 *= tmp1;\n                dp1 %= MOD;\n                k.clear();\n            }\n        } else {\n            k.push(hi - hmin);\n        }\n    }\n            if k.len() >= 1 {\n                let (mut tmp0, mut tmp1) = solve(k.clone());\n                tmp0 += tmp1;\n                tmp1 *= 2;\n                dp0 *= tmp0;\n                dp0 %= MOD;\n                dp1 *= tmp1;\n                dp1 %= MOD;\n                k.clear();\n            }\n\n    //println!(\"{:?} {:?}\", dp0, dp1);\n    let ans1 = dp1 * pow(2, hmin - 1) % MOD;\n    let ans0 = dp0 * pow(2, cnt) - dp1 + ans1;\n    let ans0 = (ans0 % MOD + MOD) % MOD;\n    //println!(\"{:?} {:?}\", ans0, ans1);\n    return (ans0, ans1);\n}\n\nfn main() {\n    let cin = stdin();\n    let mut sc = Scanner::new(cin.lock());\n    let n = sc.read();\n    let h = (0..n).map(|_| sc.read()).collect();\n    println!(\"{}\", solve(h).0 * 2 % MOD);\n}\n\n\n// thanks, ir5\nuse std::io::{stdin, Read, StdinLock};\nuse std::str::FromStr;\n\nstruct Scanner<'a> {\n    cin: StdinLock<'a>,\n}\n\nimpl<'a> Scanner<'a> {\n    fn new(cin: StdinLock<'a>) -> Scanner<'a> {\n        Scanner { cin: cin }\n    }\n\n    fn read1<T: FromStr>(&mut self) -> Option<T> {\n        let token = self.cin\n            .by_ref()\n            .bytes()\n            .map(|c| c.unwrap() as char)\n            .skip_while(|c| c.is_whitespace())\n            .take_while(|c| !c.is_whitespace())\n            .collect::<String>();\n        token.parse::<T>().ok()\n    }\n\n    fn read<T: FromStr>(&mut self) -> T {\n        self.read1().unwrap()\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::{min,max};\n#[allow(unused_imports)]\nuse std::collections::BTreeMap;\n#[allow(unused_imports)]\nuse std::ops::*;\n#[allow(unused_imports)]\nuse std::collections::BinaryHeap;\n\n#[allow(unused_macros)]\nmacro_rules! tf {\n    ($c:expr, $t:expr, $f:expr) => {{\n        if $c { $t } else { $f }\n    }};\n}\n\nfn solve(xs: &[i64], prev_h: i64) -> (Mod,Mod) {\n    let min_h = *xs.iter().min().unwrap();\n    let mut cs = xs.split(|&x| x == min_h);\n    let w = xs.iter().filter(|&x| *x == min_h).count();\n    let mut c_dp: Vec<(Mod,Mod)> = vec![];\n    while let Some(c) = cs.next() {\n        if c.len() != 0 {\n            c_dp.push(solve(c, min_h));\n        }\n    }\n    let rect_h = min_h - prev_h;\n    // 底が市松の場合\n    // 長方形の天井から下に積んでいったあとで子を上に積む\n    // 天井が市松なら同じor反対を下に積んでいくから2^rect_h, 子の底が市松ならrb..でもbr..でも子を積められる\n    let dp1 = Mod(2).pow(rect_h as u64) * c_dp.iter().fold(Mod(1), |s,xi| s * xi.0);\n    // 底が市松でない場合\n    // 上に乗っかってる子に従って長方形の天井から下に積んでいくイメージ，天井が決まれば反転のみ1通り\n    // 子が乗らない列は[rb..]^T, [br..]^Tもいける．\n    // 子が乗っている列の天井は，子が市松ならrb..とbr..の2通り，それ以外は反転のみ1通り\n    // 反転のみで下に積んだ市松のパターンはdp1でも数えているのでexclusive\n    let dp2 = Mod(2).pow(w as u64) * c_dp.iter().fold(Mod(1), |s,xi| s * (Mod(2) * xi.0 + xi.1))\n            - Mod(2) * c_dp.iter().fold(Mod(1), |s,xi| s * xi.0);\n    (dp1,dp2)\n}\n\nfn main() {\n    let _n = read_i64() as usize;\n    let xs = read_vec_i64();\n    let (dp1,dp2) = solve(&xs, 0);\n    println!(\"{}\", (dp1 + dp2).0);\n}\n\nconst MOD : u64 = 1_000_000_007;\n#[derive(Clone,Copy,PartialEq,Eq,PartialOrd,Ord)]\nstruct Mod (u64);\nuse std::ops::*;\n\nimpl Mod {\n    fn pow(self, n: u64) -> Mod {\n        if n == 0 {\n            return Mod(1);\n        }\n        let t = self.pow(n/2);\n        if n % 2 == 0 {\n            t * t\n        }\n        else {\n            t * t * self\n        }\n    }\n}\n\nimpl Add for Mod {\n    type Output = Self;\n    fn add(self, rhs: Self) -> Self::Output {\n        Mod((self.0 + rhs.0) % MOD)\n    }\n}\n\nimpl AddAssign for Mod {\n    fn add_assign(&mut self, rhs: Self) {\n        *self = *self + rhs;\n    }\n}\n\nimpl Sub for Mod {\n    type Output = Self;\n    fn sub(self, rhs: Self) -> Self::Output {\n        Mod((self.0 + MOD - rhs.0 % MOD) % MOD)\n    }\n}\n\nimpl SubAssign for Mod {\n    fn sub_assign(&mut self, rhs: Self) {\n        *self = *self - rhs;\n    }\n}\n\nimpl Mul for Mod {\n    type Output = Self;\n    fn mul(self, rhs: Self) -> Self::Output {\n        Mod(self.0 % MOD * rhs.0 % MOD)\n    }\n}\n\nimpl Div for Mod {\n    type Output = Self;\n    fn div(self, rhs: Self) -> Self::Output {\n        self * rhs.pow(MOD-2)\n    }\n}\n\n#[allow(dead_code)]\nfn read_line() -> String {\n    let mut ret = String::new();\n    std::io::stdin().read_line(&mut ret).ok();\n    ret.pop();\n    return ret;\n}\n\n#[allow(dead_code)]\nfn read_i64() -> i64 {\n    let ss = read_line();\n    return ss.parse::<i64>().unwrap();\n}\n\n#[allow(dead_code)]\nfn read_vec_i64() -> Vec<i64> {\n    let mut res = vec![];\n    let ss = read_line();\n    for ts in ss.split_whitespace() {\n        let x = ts.parse::<i64>().unwrap();\n        res.push(x);\n    }\n    return res;\n}\n\nuse std::fmt::Display;\n#[allow(dead_code)]\nfn write_vec<T: Display>(xs: &Vec<T>) {\n    if xs.len() == 0 {\n        println!(\"\");\n        return;\n    }\n    print!(\"{}\", xs[0]);\n    for i in 1..xs.len() {\n        print!(\" {}\", xs[i]);\n    }\n    println!(\"\");\n}\n"
  },
  {
    "language": "Rust",
    "code": "// use std::cmp;\nuse std::collections::BTreeMap;\n// use std::collections::HashSet;\n// use std::collections::VecDeque;\n\n\nconst MOD: i64 = 1_000_000_007;\n\n\nfn pow(a: i64, b: i64) -> i64{\n    if b == 0 {\n        1\n    } else {\n        let t = pow(a, b/2);\n        let t = t * t % MOD;\n        if b % 2 == 0 {\n            t\n        } else {\n            t * a % MOD\n        }\n    }\n}\n\nstruct Solver {\n    //dp0: Vec<Vec<i64>>,\n    //dp1: Vec<Vec<i64>>,\n}\n\nimpl Solver {\n\n    fn new() -> Self {\n        Solver {\n            //dp0: vec![],\n            //dp1: vec![],\n        }\n    }\n\n    //fn solve(&mut self, h: &Vec<i64>, l: usize, r: usize) -> (i64, i64) {\n    fn solve(&mut self, h: &Vec<i64>) -> (i64, i64) {\n        /*\n        if self.dp0[l][r] < 0 {\n        }\n        return (self.dp0[l][r], self.dp1[l][r]);\n        */\n        //println!(\"{:?}\", h);\n        let hmin = *h.iter().min().unwrap();\n        let mut dp0 = 1;\n        let mut dp1 = 1;\n        let mut k = Vec::new();\n        let mut cnt = 0;\n        for i in 0..(h.len()) {\n            let hi = h[i];\n            if i + 1 < h.len() && (hi == hmin || h[i+1] == hmin) {\n                cnt += 1;\n            }\n            if hi == hmin {\n                if k.len() >= 1 {\n                    let (mut tmp0, mut tmp1) = self.solve(&mut k);\n                    tmp0 += tmp1;\n                    tmp1 *= 2;\n                    dp0 *= tmp0;\n                    dp0 %= MOD;\n                    dp1 *= tmp1;\n                    dp1 %= MOD;\n                    k.clear();\n                }\n            } else {\n                k.push(hi - hmin);\n            }\n        }\n                if k.len() >= 1 {\n                    let (mut tmp0, mut tmp1) = self.solve(&mut k);\n                    tmp0 += tmp1;\n                    tmp1 *= 2;\n                    dp0 *= tmp0;\n                    dp0 %= MOD;\n                    dp1 *= tmp1;\n                    dp1 %= MOD;\n                    k.clear();\n                }\n\n        //println!(\"{:?} {:?}\", dp0, dp1);\n        let ans1 = dp1 * pow(2, hmin - 1) % MOD;\n        let ans0 = (dp0 - dp1) * pow(2, cnt) + dp1 * (pow(2, cnt) - 1) + ans1;\n        let ans0 = (ans0 % MOD + MOD) % MOD;\n        //println!(\"{:?} {:?}\", ans0, ans1);\n        return (ans0, ans1);\n    }\n\n    fn run(&mut self, sc: &mut Scanner) {\n        let n = sc.read();\n        let mut h = vec![0; n];\n        for i in 0..n {\n            h[i] = sc.read();\n        }\n        //self.dp0.resize(n, vec![-1; n]);\n        //self.dp1.resize(n, vec![-1; n]);\n        let (ans, _) = self.solve(&h);\n        // println!(\"{:?}\", self.dp0);\n        // println!(\"{}\", self.dp0[0][n-1]);\n        println!(\"{}\", ans * 2 % MOD);\n    }\n}\n\n\nfn main() {\n    let cin = stdin();\n    Solver::new().run(&mut Scanner::new(cin.lock()));\n}\n\n// thanks, ir5\nuse std::io::{stdin, Read, StdinLock};\nuse std::str::FromStr;\n\nstruct Scanner<'a> {\n    cin: StdinLock<'a>,\n}\n\nimpl<'a> Scanner<'a> {\n    fn new(cin: StdinLock<'a>) -> Scanner<'a> {\n        Scanner { cin: cin }\n    }\n\n    fn read1<T: FromStr>(&mut self) -> Option<T> {\n        let token = self.cin\n            .by_ref()\n            .bytes()\n            .map(|c| c.unwrap() as char)\n            .skip_while(|c| c.is_whitespace())\n            .take_while(|c| !c.is_whitespace())\n            .collect::<String>();\n        token.parse::<T>().ok()\n    }\n\n    fn read<T: FromStr>(&mut self) -> T {\n        self.read1().unwrap()\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "// https://atcoder.jp/contests/agc026/tasks/agc026_d\n//\n#![allow(unused_imports)]\nuse std::io::*;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\n\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($a:expr),*) => {\n        println!(concat!($(stringify!($a), \" = {:?}, \"),*), $($a),*);\n    }\n}\n\nconst MOD: i64 = 1e9 as i64 + 7;\n\nfn powmod(a: i64, p: i64, m: i64) -> i64 {\n    let mut ret = 1i64;\n    let mut aa = a;\n    let mut pp = p;\n    while pp >= 1 {\n        if pp & 1 == 1 {\n            ret *= aa;\n            ret %= m;\n        }\n        aa = aa * aa % m;\n        pp >>= 1;\n    }\n    ret\n}\n\nfn pow2(p: i64) -> i64 {\n    powmod(2, p, MOD)\n}\n\nfn main() {\n    input! {\n        n: usize,\n        a: [i64; n]\n    };\n\n\n    let mut aw = a.clone();\n    aw.sort();\n\n    let mut blocks = vec![];\n    {\n        let mut last = 0;\n        for h in aw {\n            if last < h {\n                blocks.push(h - last);\n            }\n            last = h;\n        }\n    }\n    let mut heights = vec![0; n];\n    for i in 0..n {\n        let mut cnt = 0;\n        let mut sum = 0;\n        for &b in &blocks {\n            sum += b;\n            cnt += 1;\n            if sum == a[i] {\n                heights[i] = cnt;\n                break;\n            }\n        }\n    }\n\n    let hn = blocks.len();\n    let mut dp = vec![vec![vec![0; 2]; hn+1]; n+1];\n    dp[0][0][0] = 1;\n\n    // println!(\"{:?}\", blocks);\n    // println!(\"{:?}\", heights);\n\n    for i in 0..n {\n        for h in 0..hn+1 {\n            for f in 0..2 {\n                let base = dp[i][h][f];\n                if base == 0 {\n                    continue;\n                }\n\n\n\n                // [from, to]\n                let mut fromh = 1;\n                let mut toh = 0;\n\n                let mut sameh = h;\n                if i == 0 {\n                    fromh = 1;\n                    toh = heights[i];\n                } else {\n                    fromh = heights[i-1]+1;\n                    toh = heights[i];\n                    if (f == 0 && h > heights[i]) || (f == 1 && h >= heights[i]) {\n                        sameh = 0;\n                    }\n                }\n\n                // println!(\"{} {} {} {} / {} {} {}\", i, h, f, base, fromh, toh, sameh);\n\n                let prevways = if sameh == 0 { 2 } else { 1 };\n                let mut totalh = 0;\n                for hi in fromh..toh+1 {\n                    totalh += blocks[hi-1];\n                }\n\n                if sameh == 0 {\n                    for hi in fromh..toh+1 {\n                        if hi >= 2 {\n                            // between\n                            dp[i+1][hi-1][1] += base * prevways % MOD * pow2(totalh-1) % MOD;\n                            dp[i+1][hi-1][1] %= MOD;\n\n                            // else\n                            dp[i+1][hi][0] += base * prevways % MOD * (pow2(blocks[hi-1]-1) + MOD - 1) % MOD * pow2(totalh - blocks[hi-1]) % MOD;\n                            dp[i+1][hi][0] %= MOD;\n                        } else {\n                            // else\n                            dp[i+1][hi][0] += base % MOD * (pow2(blocks[hi-1]) + MOD - 2) % MOD * pow2(totalh - blocks[hi-1]) % MOD;\n                            dp[i+1][hi][0] %= MOD;\n                        }\n                        totalh -= blocks[hi-1];\n                    }\n\n                    dp[i+1][0][0] += base * prevways % MOD;\n                    dp[i+1][0][0] %= MOD;\n                } else {\n                    dp[i+1][h][f] += base * pow2(totalh);\n                    dp[i+1][h][f] %= MOD;\n                }\n           }\n        }\n    }\n\n    let mut total = 0;\n    for h in 0..hn+1 {\n        for f in 0..2 {\n            total += dp[n][h][f];\n            total %= MOD;\n        }\n    }\n    println!(\"{}\", total);\n}\n"
  }
]