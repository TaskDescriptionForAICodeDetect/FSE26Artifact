[
  {
    "language": "Scala",
    "code": "object Main extends App {\n  override def main(args: Array[String]): Unit = {\n    import scala.io.{StdIn => in}\n    Iterator\n      .continually(in.readLine())\n      .takeWhile(_ != \"0 0\")\n      .map(str =>\n        for (x <- 1 to str.split(\" \")(0).toInt) yield in.readLine()\n      ).map(solve).foreach(println)\n  }\n\n  def solve(input: Seq[String]): String = {\n    val list = makeString(toArray(input)).sorted\n    val ans = list.zip(list.drop(1)).map(s => getDuplicate(s._1, s._2)).max(new StringComparator)\n    if (ans.size < 2) \"0\" else ans\n  }\n\n  class StringComparator extends Ordering[String] {\n    override def compare(x: String, y: String) = {\n      if (x.length != y.length) {\n        x.length.compare(y.length)\n      } else {\n        y.compareTo(x)\n      }\n    }\n  }\n\n  def toArray(input: Seq[String]): Array[Array[Char]] = {\n    val h = input.size\n    val w = input(0).size\n    val ret = Array.ofDim[Char](h, w)\n    for (i <- 0 until h; j <- 0 until w) {\n      ret(i)(j) = input(i)(j)\n    }\n    ret\n  }\n\n  def makeString(arr: Array[Array[Char]]): Seq[String] = {\n    val h = arr.size\n    val w = arr(0).size\n    val direction = List((0, 1), (1, 0), (-1, 0), (0, -1), (1, 1), (1, -1), (-1, 1), (-1, -1))\n    for (starti <- 0 until h; startj <- 0 until w; d <- direction) yield {\n      arr(starti)(startj) + Iterator\n        .iterate(((starti + d._1 + h) % h, (startj + d._2 + w) % w))(pos => ((pos._1 + d._1 + h) % h, (pos._2 + d._2 + w) % w))\n        .takeWhile(_ != (starti, startj))\n        .map(pos => arr(pos._1)(pos._2))\n        .mkString(\"\")\n    }\n  }\n\n  def getDuplicate(str1: String, str2: String): String = {\n    str1.zip(str2).takeWhile(c => c._1 == c._2).map(_._1).mkString(\"\")\n  }\n}"
  },
  {
    "language": "Scala",
    "code": "object Main extends App {\n  override def main(args: Array[String]): Unit = {\n    import scala.io.{StdIn => in}\n    Iterator\n      .continually(in.readLine())\n      .takeWhile(_ != \"0 0\")\n      .map(str =>\n        for (x <- 1 to str.split(\" \")(0).toInt) yield in.readLine()\n      ).map(new Solver(_).solve).foreach(println)\n  }\n}\n\nclass Solver(input: Seq[String]) {\n  val h = input.size\n  val w = input(0).size\n  val arr =  Array.ofDim[Char](h, w)\n  for (i <- 0 until h; j <- 0 until w) arr(i)(j) = input(i)(j)\n\n  def solve :String = {\n    val list = makeAllList.sorted\n    val ans = list.zip(list.drop(1)).map(s => getDuplicate(s._1, s._2)).max(new StringComparator)\n    if (ans.size < 2) \"0\" else ans\n  }\n\n  def getDuplicate(str1: String, str2: String): String = str1.zip(str2).takeWhile(c => c._1 == c._2).map(_._1).mkString(\"\")\n\n  class StringComparator extends Ordering[String] {\n    override def compare(x: String, y: String) = if (x.length != y.length) x.length.compare(y.length) else  y.compareTo(x)\n  }\n\n  def makeAllList: Seq[String] = {\n    val direction = List((0, 1), (1, 0), (-1, 0), (0, -1), (1, 1), (1, -1), (-1, 1), (-1, -1))\n    for (starti <- 0 until h; startj <- 0 until w; d <- direction) yield {\n      val head = arr(starti)(startj)\n      val initPosition = (starti,startj)\n      val left = Iterator\n        .iterate(movePointer(initPosition,d))(pos => movePointer(pos,d))\n        .takeWhile(_ != (starti, startj))\n        .map(pos => arr(pos._1)(pos._2))\n        .mkString(\"\")\n      head + left\n    }\n  }\n  def movePointer(pos: (Int, Int), direction: (Int, Int)): (Int, Int) = (((pos._1 + direction._1) % h), ((pos._2 + direction._2) % w))\n}"
  },
  {
    "language": "Scala",
    "code": "object Main extends App {\n  override def main(args: Array[String]): Unit = {\n    import scala.io.{StdIn => in}\n    Iterator\n      .continually(in.readLine())\n      .takeWhile(_ != \"0 0\")\n      .map(str =>\n        for (x <- 1 to str.split(\" \")(0).toInt) yield in.readLine()\n      ).map(new Solver(_).solve).foreach(println)\n  }\n}\n\nclass Solver(input: Seq[String]) {\n  val h = input.size\n  val w = input(0).size\n  val arr = Array.ofDim[Char](h, w)\n  for (i <- 0 until h; j <- 0 until w) arr(i)(j) = input(i)(j)\n\n  def solve: String = {\n    val list = makeAllList.sorted\n    val ans = list.zip(list.drop(1)).map(s => getDuplicate(s._1, s._2)).max(new StringComparator)\n    if (ans.size < 2) \"0\" else ans\n  }\n\n  def getDuplicate(str1: String, str2: String): String = str1.zip(str2).takeWhile(c => c._1 == c._2).map(_._1).mkString(\"\")\n\n  class StringComparator extends Ordering[String] {\n    override def compare(x: String, y: String) = if (x.length != y.length) x.length.compare(y.length) else y.compareTo(x)\n  }\n\n  def makeAllList: Seq[String] = {\n    val direction = List((0, 1), (1, 0), (-1, 0), (0, -1), (1, 1), (1, -1), (-1, 1), (-1, -1))\n    for (starti <- 0 until h; startj <- 0 until w; d <- direction) yield {\n      val head = arr(starti)(startj)\n      val initPosition = (starti, startj)\n      val left = Iterator\n        .iterate(movePointer(initPosition, d))(pos => movePointer(pos, d))\n        .takeWhile(_ != (starti, startj))\n        .map(pos => arr(pos._1)(pos._2))\n        .mkString(\"\")\n      head + left\n    }\n  }\n\n  def movePointer(pos: (Int, Int), direction: (Int, Int)): (Int, Int) = (((pos._1 + direction._1 + h) % h), ((pos._2 + direction._2 + w) % w))\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define ll long long\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1316\n\nint h, w;\n\nint dy[8] = { -1, -1, -1, 0, 0, 1, 1, 1 };\nint dx[8] = { -1, 0, 1, -1, 1, -1, 0, 1 };\n\nset<string> Set;\nint Maxlen = 0;\nstring ans;\nvector<vector<char>> donut;\n\n\nvoid solve(int i, int j) {\n\tfor (int k = 0; k < 8;k++) {\n\t\tvector<vector<int>> usage(h, vector<int>(w, 0));\n\t\tstring ret = \"\";\n\t\tint y = i, x = j;\n\t\twhile (usage[y][x] == 0) {\n\t\t\tret += donut[y][x];\n\n\t\t\tif (Set.find(ret) != Set.end()) {\n\t\t\t\tif (ret.length() > Maxlen) {\n\t\t\t\t\tMaxlen = ret.length();\n\t\t\t\t\tans = ret;\n\t\t\t\t}\n\t\t\t\telse if (ret.length() == Maxlen && ret < ans) {\n\t\t\t\t\tans = ret;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSet.insert(ret);\n\t\t\t}\n\n\t\t\tusage[y][x] = 1;\n\t\t\ty = (y + dy[k] + h) % h;\n\t\t\tx = (x + dx[k] + w) % w;\n\n\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\twhile (cin >> h >> w) {\n\t\tif (h == 0 && w == 0)break;\n\t\tMaxlen = 0;\n\t\tans = \"\";\n\t\tdonut.clear();\n\t\tdonut.resize(h, vector<char>(w));\n\t\tfor (int i = 0; i < h;i++) {\n\t\t\tfor (int j = 0; j < w;j++) {\n\t\t\t\tcin >> donut[i][j];\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < h;i++) {\n\t\t\tfor (int j = 0; j < w;j++) {\n\t\t\t\tsolve(i, j);\n\t\t\t}\n\t\t}\n\t\tif (ans.length() < 2) cout << 0 << endl;\n\t\telse cout << ans << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "                                        #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                                #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,pa>\n                                        #define ppa pair<int,int>\n                                        #define ppap pair<int,pa>\n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-12)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\n                                  #define VI vector<int>\n                                        using namespace std;\n                                        \n                                  class pas{\n                                    \tpublic:\n                                    \tint x,y;\n                                    \tpas(int x=0,int y=0):x(x),y(y) {}\n                                    \tpas operator + (pas p) {return pas(x+p.x,y+p.y);}\n                                    \tpas operator - (pas p) {return pas(x-p.x,y-p.y);}\n                                    \tpas operator * (int a) {return pas(x*a,y*a);}\n                                    \tpas operator / (int a) {return pas(x/a,y/a);}\n                                    //\tdouble absv() {return sqrt(norm());}\n                                    \tint norm() {return x*x+y*y;}\n                                    \tbool operator < (const pas &p) const{\n                                   \t\treturn x != p.x ? x<p.x: y<p.y;\n                                   \t}\n                                  //\t\tbool operator < (const pas &p) const{\n                                    //\t\treturn y != p.y ? y<p.y: x<p.x;\n                                    //\t}\n                                    \tbool operator == (const pas &p) const{\n                                    \t\treturn x==p.x && y==p.y;\n                                    \t}\n                                    };\n\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                        \nstruct star{\nSegment se[5];\n};\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(b.p1),(b.p2))&&parareru((a.p2),(a.p1),(b.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n            double segment_len(Segment a){\n            \t\n            \treturn (a.p1-a.p2).absv();\n            }\n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n\t\t\tpair<Point,Point> circle_intersection(Point c1,double r1,Point c2,double r2){\n\t\t\t\tdouble d=(c1-c2).absv();\n\t\t\t\tdouble h=(r1*r1-r2*r2+d*d)/2.0/d;\n\t\t\t\tdouble l=sqrt(r1*r1-h*h);\n\t\t\t//\tcout<<d<<\" \"<<h<<\" \"<<l<<endl;\n\t\t\t\tPoint asi=c1+(c2-c1)*h/((c2-c1).absv());\n\t\t\t\tVector r1r2=(c2-c1)/((c2-c1).absv());\n\t\t\t\tVector sui={r1r2.y,-r1r2.x};\n\t\t\t//\tcout<<sui.x<<\" \"<<sui.y<<endl;\n\t\t\t\tpair<Point,Point> z=mp(asi+sui*l,asi-sui*l);\n\t\t\t\tif(z.first.x>z.second.x) swap(z.first,z.second);\n\t\t\t\treturn z;\n\t\t\t}\ndouble dist(star s1,star s2){\n\tdouble ans=10000000000.0;\n\t\n\tfor(int i=0;i<5;i++)for(int j=0;j<5;j++){\n\t\tif( is_intersected_ls(s1.se[i],s2.se[j])) {\n\t\t\t\n//\t\t\tcout<<s1.se[i].p1.x<<\" \"<<s1.se[i].p1.y<<endl;\n//\t\t\tcout<<s1.se[i].p2.x<<\" \"<<s1.se[i].p2.y<<endl;\n//\t\t\tcout<<s2.se[j].p1.x<<\" \"<<s2.se[j].p1.y<<endl;\n//\t\t\tcout<<s2.se[j].p2.x<<\" \"<<s2.se[j].p2.y<<endl;\n\t\treturn 0.0;\n\t\t}\n\t\tans=min(ans,segment_dis(s1.se[i],s2.se[j]));\n//\t\tcout<<\"   \"<<i<<\" \"<<j<<\" \"<<segment_dis(s1.se[i],s2.se[j])<<endl;\n\t}\n\treturn ans;\n}\nint gcd(int x,int y){\n\tif(x<y) return gcd(y,x);\n\tif(x==y) return x;\n\tif(x%y==0) return y;\n\treturn gcd(y,x%y);\n}\nset<string>se,ansset;\n char a[50][50]={0};\n \nint dx[8]={1,-1,0,0,1,1,-1,-1};\nint dy[8]={0,0,1,-1,-1,1,1,-1};\n     signed main(){\nint h,w;\n     \twhile(1){\n     \t\tse.clear();\n     \t\tansset.clear();\n     \t\tcin>>h>>w;\n     \t\tif(h==0) return 0;\n     \t\t\n     \t\tfor(int i=0;i<h;i++){\n     \t\tstring s;\n     \t\t\tcin>>s;\n     \t\t\tfor(int j=0;j<w;j++)a[i][j]=s[j];\n     \t\t\n     \t\t}\n     \t\tint g=gcd(h,w);\n     \t\tint lc=h*w/g;\n     \t\t\n     \t\t\n     \t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n     \t\t\tfor(int r=0;r<8;r++){\n     \t\t\t\tstring ans=\"\";\n     \t\t\t\tint x=i,y=j;\n     \t\t\t\tint moji=h;\n     \t\t\t\tif(r>=2 && r<4) moji=w;\n     \t\t\t\tif(r>=4) moji=lc;\n     \t\t\t\tint cn=0;\n     \t\t\t\twhile(cn<moji){\n     \t\t\t\t\tans+=a[x][y];\n     \t\t\t\t\tx+=dx[r];\n     \t\t\t\t\ty+=dy[r];\n     \t\t\t\t\tx=(x+3*h)%h;\n     \t\t\t\t\ty=(y+3*w)%w;\n     \t\t\t//\t\tcout<<ans<<endl;\n     \t\t\t\t\tif(ans.length()>=2){\n     \t\t\t\t\t\tif(se.find(ans)!=se.end()){\n     \t\t\t\t\t\t\tse.erase(ans);\n     \t\t\t\t\t\t\tansset.insert(ans);\n     \t\t\t\t\t\t}\n     \t\t\t\t\t\telse{\n     \t\t\t\t\t\t\tse.insert(ans);\n     \t\t\t\t\t\t}\n     \t\t\t\t\t\t\n     \t\t\t\t\t}\n     \t\t\t\tcn++;\n     \t\t\t\t}\n     \t\t\t}\n     \t\t}\n     \t\t\n     \t\tif(ansset.size()==0)cout<<0<<endl;\n     \t\t\n     \t\telse {\n     \t\t\tstring q=\"\";\n     \t\t\tfor(auto it=ansset.begin();it!=ansset.end();it++){\n     \t\t\t\tstring w=*it;\n     \t\t\t\tif(q.length()>w.length()) continue;\n     \t\t\t\telse if(q.length()<w.length()) q=w;\n     \t\t\t\telse{\n     \t\t\t\t\tif(w<q) q=w;\n     \t\t\t\t}\n     \t\t\t}\n     \t\t\tcout<<q<<endl;\n     \t\t}\n     \t\t\n     \t\n     \t}\n   \n           \treturn 0;\n           }\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<cstdio>\n#include<cstring>\n#include<map>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(n) rep(i,n)\n#define all(n) n.begin(),n.end()\n#define foreach(c,it) for(typeof(c.begin()) it=c.begin();it!=c.end();++it)\n\nint dx[] = {-1, 0, 1, -1, 1, -1, 0, 1};\nint dy[] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int MAXH = 10, MAXW = 20;\nchar tile[MAXW][MAXH];\nint checked[MAXW][MAXH];\ntypedef pair<int, string> p;\nint main()\n{\n    int w, h;\n    while(cin >> h >> w && h)\n    {\n        rep(j,h)rep(i,w){ cin >> tile[i][j];}\n        \n        vector<p> ans;\n        rep(sx,w)rep(sy,h)rep(v,8)\n        {\n            memset(checked, 0, sizeof(checked));\n            int x = sx, y = sy;\n            string s;\n            while(!checked[x][y])\n            {\n                //cout << x << \" \" << y << endl;\n                s += tile[x][y];\n                ans.push_back(p( -s.size(), s));\n                checked[x][y] = 1;\n                x += dx[v]; y += dy[v];\n                if(x == w) x = 0;\n                if(x == -1) x = w - 1;\n                if(y == h) y = 0;\n                if(y == -1) y = h - 1;\n\n            }\n        }\n        sort(all(ans));\n        int found = 0;\n        for(int i = 0; i < ans.size() - 1; i++)if(ans[i] == ans[i + 1] && ans[i].first <= -2)\n        {\n            cout << ans[i].second << endl;\n            found = 1;\n            break;\n        }\n        if(!found) cout << 0 << endl;\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0 ; i < n ; i++)\n\nconst int dx[] = {0, 1, 0, -1, 1, 1, -1, -1};\nconst int dy[] = {1, 0, -1, 0, 1, -1, 1, -1};\n\nint H, W;\nchar field[11][21];\nmap<string, int> v;\n\nvoid solve(int x, int y){\n  rep(i, 8){\n    string s = \"\";\n    s += field[y][x];\n    bool used[11][21];\n    memset(used, false, sizeof(used));\n    used[y][x] = true;\n    int nx = x+dx[i], ny = y+dy[i];\n    while(true){\n      if(nx < 0) nx = W-1;\n      else if(nx >= W) nx = 0;\n      if(ny < 0) ny = H-1;\n      else if(ny >= H) ny = 0;      \n      if(used[ny][nx]) break;\n      used[ny][nx] = true;\n      s += field[ny][nx];\n      nx += dx[i], ny += dy[i];\n      if(s.size() >= 2) v[s]++;\n    }    \n  }\n}\n\nint main(){\n  while(cin >> H >> W, H|W){\n    v.clear();\n    rep(i, H) cin >> field[i];        \n\n    rep(i, H) rep(j, W) solve(j, i);\n    \n    string ans = \"\";\n    int L = 0;\n    for(map<string, int>::iterator it = v.begin() ; it != v.end() ; it++){\n      if(it->second < 2) continue;\n\n      if(it->first.size() > L){\n\tL = it->first.size();\n\tans = it->first;\n      }\n      else if(it->first.size() == L && ans > it->first) ans = it->first;\n    }\n    if(ans.size() == 0) cout << \"0\" << endl;\n    else cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nconst int dx[8] = { 1, 1, 1, 0, -1, -1, -1, 0 };\nconst int dy[8] = { -1, 0, 1, 1, 1, 0, -1, -1 };\nchar field[100][100];\nbool visit[30][30];\nint h, w;\n\nint main() {\n  while (scanf(\"%d %d\", &h, &w), h|w) {\n    REP(y, h) {\n      scanf(\"%s\", field[y]);\n    }\n    string ans = \"0\";\n    map<string, int> open;\n    REP(sy, h) {\n      REP(sx, w) {\n        REP(dir, 8) {\n          MEMSET(visit, false);\n          string s;\n          int x = sx;\n          int y = sy;\n          while (!visit[y][x]) {\n            visit[y][x] = true;\n            s += field[y][x];\n            if (s.size() > 1) {\n              open[s]++;\n              if (open[s] >= 2) {\n                if (ans.size() < s.size() ||\n                    (ans.size() == s.size() && s < ans)) {\n                  ans = s;\n                }\n              }\n            }\n            x = (x + dx[dir] + w) % w;\n            y = (y + dy[dir] + h) % h;\n          }\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n\nint main()\n{\n    int h,w;\n    int dx[8]={0,1,1,1,0,-1,-1,-1};\n    int dy[8]={1,1,0,-1,-1,-1,0,1};\n    while(cin >>h >>w,h|w)\n    {\n        vector<string> s(h);\n        rep(i,h) cin >>s[i];\n\n        map<string,int> ct;\n        //start\n        rep(i,h)rep(j,w)rep(k,8)\n        {\n            int x=j,y=i;\n            string now=\"\";\n\n            vector<vector<int>> vis(h,vector<int>(w,0));\n            rep(a,h*w)\n            {\n                if(vis[y][x]) break;\n\n                now+=s[y][x];\n                vis[y][x]=1;\n                y=(y+dy[k]+h)%h;\n                x=(x+dx[k]+w)%w;\n\n                if(now.size()>=2)\n                {\n                    if(ct.find(now)==ct.end()) ct[now]=1;\n                    else ++ct[now];\n                }\n            }\n        }\n\n        string ans=\"\";\n        for(const auto &i:ct)\n        {\n            if(i.se>1)\n            {\n                string t=i.fi;\n                if(t.size()>ans.size()) ans=t;\n                else if(t.size()==ans.size() && t<ans) ans=t;\n            }\n        }\n\n        if(ans==\"\") ans=\"0\";\n        std::cout << ans << std::endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<set>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nint main(){\n\n  while(true){\n    int h, w; cin>> h>> w;\n    if(h==0 && w==0) break;\n    vector<string> a(h);\n    rep(i, h) cin>> a[i];\n    string best=\"\";\n    set<string> dict;\n    const int dx[]={-1, -1, -1,  0, 0,  1, 1, 1};\n    const int dy[]={-1,  0,  1, -1, 1, -1, 0, 1};\n    rep(i, h)rep(j, w){\n      rep(k, 8){\n        int x=i, y=j;\n        string t=\"\";\n        do{\n          t+=a[x][y];\n          if(dict.count(t)){\n            if(best.size()<t.size()){\n              best=t;\n            }else if(best.size()==t.size()){\n              if(t<best) best=t;\n            }\n          }else if(t.size()>=2){\n            dict.insert(t);\n          }\n          x=(x+h+dx[k])%h;\n          y=(y+w+dy[k])%w;\n        }while(x!=i || y!=j);\n      }\n    }\n\n    if(best.size()>=2) cout<< best<< endl;\n    else cout<< 0<< endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\nusing namespace std;\nconst int dy[] = {1, -1, 0, 0, 1, -1, 1, -1};\nconst int dx[] = {0, 0, 1, -1, 1, -1, -1, 1};\nint h, w, sy, sx, max_size;\nmap<string, int> mp;\nstring table[15];\nstring str;\nvoid solve(char ch)\n{\n\tfor(int i = 0; i < 8; i++)\n\t{\n\t\tint ny = sy;\n\t\tint nx = sx;\n\t\tstr = \"\";\n\t\twhile(1)\n\t\t{\n\t\t\tstr += table[ny][nx];\n\t\t\tmp[str]++;\n\t\t\tif(mp[str] >= 2)\n\t\t\t\tmax_size = max(max_size, (int)str.size());\n\t\t\t//printf(\"(%d, %d): %c\\n\", ny, nx, table[ny][nx]);\n\t\t\tint tmp_y = ny + dy[i];\n\t\t\tint tmp_x = nx + dx[i];\n\t\t\tif(tmp_y < 0) tmp_y = h - 1;\n\t\t\tif(tmp_x < 0) tmp_x = w - 1;\n\t\t\tif(tmp_y >= h) tmp_y = 0;\n\t\t\tif(tmp_x >= w) tmp_x = 0;\n\t\t\tny = tmp_y;\n\t\t\tnx = tmp_x;\n\t\t\tif(tmp_y == sy && tmp_x == sx)\n\t\t\t\tbreak;\n\t\t}\n\t\t//cout << endl;\n\t}\n}\t\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile(cin >> h >> w, h | w)\n\t{\n\t\tmp.clear();\n\t\tstr = \"\";\n\t\tmax_size = 2;\n\t\tfor(int i = 0; i < h; i++)\n\t\t{\n\t\t\tcin >> table[i];\n\t\t}\n\t\tfor(int i = 0; i < h; i++)\n\t\t{\n\t\t\tfor(int j = 0; j < w; j++)\n\t\t\t{\n\t\t\t\tsy = i; sx = j;\n\t\t\t\tsolve(table[i][j]);\n\t\t\t}\n\t\t}\n\t\tbool flag = false;\n\t\tfor(auto itr = mp.begin(); itr != mp.end(); itr++)\n\t\t{\n\t\t\tif(itr->second >= 2 && itr->first.size() == max_size)\n\t\t\t{\n\t\t\t\tflag = true;\n\t\t\t\tcout << itr->first << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!flag)\n\t\t\tcout << 0 << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<string.h>\nusing namespace std;\n\nint N,M,L,K,A,H;\nbool re[100];\nint cost[100][100];\n\nstruct Node{\n\tint total,rem,pos,total_b;\n};\n\nbool operator < (Node a,Node b){\n\treturn a.total>b.total;\n}\n\n\nvoid solve()\n{\n\tmemset(re,false,sizeof(re));\n\tmemset(cost,-1,sizeof(cost));\n\tre[A]=re[H]=true;\n\tfor(int i=0;i<L;i++){int t;cin>>t;re[t]=true;}\n\n\tfor(int i=0;i<K;i++){\n\t\tint in,out,c;cin>>in>>out>>c;\n\t\tcost[in][out]=cost[out][in]=c;\n\t}\n\n\tvector<vector<Node> >V(N);\n\tNode first;\n\tfirst.rem=M; first.total=0; first.pos=A;first.total_b=0;\n\tpriority_queue<Node> Q;\n\tQ.push(first);\n//\tcout<<endl<<endl;\n\n\twhile(!Q.empty()){\n\t\tNode now=Q.top();\n\t\tQ.pop();\n//\t\tcout<<now.pos<<\" \"<<now.rem<<\" \"<<now.total<<endl;\n\t\tif(now.rem<0) continue;\n\t\tif(now.pos==H){cout<<now.total-min(now.total_b,now.rem)<<endl; return;}\n\t\tbool ok=true;\n\t\tfor(int i=0;i<V[now.pos].size();i++){\n\t\t\tif(V[now.pos][i].rem>=now.rem && V[now.pos][i].total<=now.total){\n\t\t\t\tok=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!ok) continue;\n\t\tV[now.pos].push_back(now);\n\n\t\tfor(int i=0;i<N;i++){\n\t\t\tif(cost[now.pos][i]==-1) continue;\n\t\t\tNode next;\n\t\t\tif(re[i]){\n\t\t\t\tif(now.rem<cost[now.pos][i]) continue;\n\t\t\t\tnext.rem=M;\n\t\t\t\tnext.total=now.total+cost[now.pos][i]+M-now.rem+cost[now.pos][i];\n\t\t\t\tnext.pos=i;\n\t\t\t\tnext.total_b=now.total_b+M-now.rem+cost[now.pos][i];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tnext.rem=now.rem-cost[now.pos][i];\n\t\t\t\tnext.total=now.total+cost[now.pos][i];\n\t\t\t\tnext.pos=i;\n\t\t\t\tnext.total_b=now.total_b;\n\t\t\t}\n\t\t\tQ.push(next);\n\t\t}\n\n\t}\n\n\tcout<<\"Help!\"<<endl;\n}\n\n\n\nint main(){\n\twhile(cin>>N>>M>>L>>K>>A>>H){\n\t\tif(N==0) break;\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define allof(a) a.begin(),a.end()\n#define minit(a,b) memset(a,b,sizeof(a))\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nstruct Spell {\n\tint size; string s;\n\tSpell(int _size, string _s) : size(_size), s(_s) {}\n};\nbool operator > (const Spell& a, const Spell& b) {\n\tif (a.size > b.size) return true;\n\tif (a.size == b.size) return a.s < b.s;\n\treturn false;\n}\n\nint h, w;\nstring pat[11];\n\nint dx[8] = {0,1,1,1,0,-1,-1,-1};\nint dy[8] = {-1,-1,0,1,1,1,0,-1};\n\nvoid solve() {\n\tset<string> finds;\n\tset<Spell, greater<Spell> > setp;\n\t\n\tfor_(i,0,h) for_(j,0,w) {\n\t\tfor_(d,0,8) {\n\t\t\tint sx = (j + dx[d] + w) % w, sy = (i + dy[d] + h) % h;\n\t\t\tstring s = \"\";\n\t\t\ts += pat[i][j];\n\t\t\t\n\t\t\twhile (sx != j || sy != i) {\n\t\t\t\ts += pat[sy][sx];\n\t\t\t\tsx = (sx + dx[d] + w) % w;\n\t\t\t\tsy = (sy + dy[d] + h) % h;\n\t\t\t\n\t\t\t\tif (finds.find(s) != finds.end()) {\n\t\t\t\t\tsetp.insert(Spell((int)s.size(), s));\n\t\t\t\t} else {\n\t\t\t\t\tfinds.insert(s);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif ((int)setp.size() == 0) {\n\t\tcout << 0 << endl;\n\t\treturn;\n\t}\n\tset<Spell, greater<Spell> >::iterator it = setp.begin();\n\tcout << (*setp.begin()).s << endl;\n}\n\nint main() {\n\twhile (cin >> h >> w, h) {\n\t\tfor_(i,0,h) cin >> pat[i];\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define rall(c) c.rbegin(),c.rend()\n#define mp(a,b) make_pair((a),(b))\n#define eq ==\n\ntypedef long long ll;\ntypedef complex<double> point;\ntypedef pair<int,int> pii;\n\n// →↑←↓\nconst int dx[] = {1, 0,-1, 1,-1, 1, 0,-1};\nconst int dy[] = {1, 1, 1, 0, 0,-1,-1,-1};\n\n\nconst double EPS = 1e-9;\n\nint main(){\n    while(true){\n        int H,W;\n        cin >> H >> W;\n        if(H == 0) break;\n        vector<string> donut(H);\n        for(int i=0;i<H;i++){\n            cin >> donut[i];\n        }\n        map<string,int> spells;\n        for(int y=0;y<H;y++){\n            for(int x=0;x<W;x++){\n                for(int i=0;i<8;i++){\n                    string spell = \"\";\n                    int nx = x,ny = y;\n                    set<pair<int,int> > alr;\n                    while(alr.find(make_pair(ny,nx)) == alr.end()){\n                        alr.insert(make_pair(ny,nx));\n                        spell += donut[ny][nx];\n                        if(spell.length() > 1)\n                            spells[spell]++;\n                        ny += dy[i];\n                        nx += dx[i];\n                        if(ny < 0) ny = H-1;\n                        if(ny >= H) ny = 0;\n                        if(nx < 0) nx = W-1;\n                        if(nx >= W) nx = 0;\n                    }\n                }\n            }\n        }\n        string maxi = \"0\";\n        for(map<string,int>::iterator it=spells.begin();it!=spells.end();++it){\n            if((*it).second > 1){\n                if(maxi.length() == (*it).first.length()){\n                    maxi = min(maxi,(*it).first);\n                }else if(maxi.length() < (*it).first.length()){\n                    maxi = (*it).first;\n                }\n            }\n        }\n        cout << maxi << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define ll long long\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1316\n\nint h, w;\n\nint dy[8] = { -1, -1, -1, 0, 0, 1, 1, 1 };\nint dx[8] = { -1, 0, 1, -1, 1, -1, 0, 1 };\n\nset<string> Set;\nint Maxlen = 0;\nstring ans;\nvector<vector<char>> donut;\nvector<vector<int>> usage;\n\nvoid solve(int i, int j) {\n\tfor (int k = 0; k < 8;k++) {\n\t\tusage.resize(h, vector<int>(w, 0));\n\t\tstring ret = \"\";\n\t\tint y = i, x = j;\n\t\twhile (usage[y][x] == 0) {\n\t\t\tret += donut[y][x];\n\n\t\t\tif (Set.find(ret) != Set.end()) {\n\t\t\t\tif (ret.length() > Maxlen) {\n\t\t\t\t\tMaxlen = ret.length();\n\t\t\t\t\tans = ret;\n\t\t\t\t}\n\t\t\t\telse if (ret.length() == Maxlen && ret < ans) {\n\t\t\t\t\tans = ret;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSet.insert(ret);\n\t\t\t}\n\n\t\t\tusage[y][x] = 1;\n\t\t\ty = (y + dy[k] + h) % h;\n\t\t\tx = (x + dx[k] + w) % w;\n\n\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\twhile (cin >> h >> w) {\n\t\tif (h == 0 && w == 0)break;\n\t\tMaxlen = 0;\n\t\tans = \"\";\n\t\tdonut.resize(h, vector<char>(w));\n\t\tfor (int i = 0; i < h;i++) {\n\t\t\tfor (int j = 0; j < w;j++) {\n\t\t\t\tcin >> donut[i][j];\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < h;i++) {\n\t\t\tfor (int j = 0; j < w;j++) {\n\t\t\t\tsolve(i, j);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nint main() {\n\tint h, w;\n\twhile (cin >> h >> w, h) {\n\t\tvector<string> map(h);\n\t\tfor (auto &a : map)cin >> a;\n\t\tint dx[] = { 0,0,1,1,1,-1,-1,-1 };\n\t\tint dy[] = { 1,-1,0,-1,1,0,1,-1 };\n\t\tvector<tuple<string, int, int, int>> buf;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tfor (int d = 0; d < 8; d++) {\n\t\t\t\t\tbuf.push_back(make_tuple((string)\"\" + map[i][j], j, i, d));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint l = 1;\n\t\tfor (;; l++) {\n\t\t\tsort(buf.begin(), buf.end());\n\t\t\tvector<tuple<string, int, int, int>> buf2;\n\t\t\tfor (int i = 1; i < buf.size(); i++) {\n\t\t\t\tif (get<0>(buf[i - 1]).size() < l)continue;\n\t\t\t\tif (get<0>(buf[i - 1]) == get<0>(buf[i]))buf2.push_back(buf[i - 1]);\n\t\t\t\tfor (; i<buf.size()&&get<0>(buf[i - 1]) == get<0>(buf[i]); i++)buf2.push_back(buf[i]);\n\t\t\t}\n\t\t\tif (buf2.empty())break;\n\t\t\tbuf = move(buf2);\n\t\t\tfor (auto &a : buf) {\n\t\t\t\tstring str;\n\t\t\t\tint x, y, d;\n\t\t\t\ttie(str, x, y, d) = a;\n\t\t\t\tint x1 = ((x + dx[d]*l) % w + w) % w;\n\t\t\t\tint y1 = ((y + dy[d]*l) % h + h) % h;\n\t\t\t\tif (x1 == x && y1 == y)continue;\n\t\t\t\tstr += map[y1][x1];\n\t\t\t\ta = make_tuple(str, x, y, d);\n\t\t\t}\n\t\t}\n\t\tif (l < 3)cout << 0 << endl;\n\t\telse {\n\t\t\tstring str = get<0>(buf[0]);\n\t\t\tcout << str.substr(0, l-1) << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <vector>\nusing namespace std;\n#define REP(i,x)for(int i=0;i<x;i++)\n\nstring res;\nint H,W,dx,dy,min_len;\nchar s[200];\nchar MAP[11][22];\nbool visit[20][20];\nvector<string> ss;\nvoid dfs(int x,int y,int k){\n  if(visit[y][x]){\n    ss.push_back(string(s));\n    return;\n  }\n  s[k]=MAP[y][x];  visit[y][x]=1;\n  dfs((x + dx + W) % W, (y + dy + H) % H, k + 1);\n  s[k]=0;  visit[y][x]=0;\n}\nint main() {\n  while(scanf(\"%d%d\",&H,&W),H){\n    REP(i,H)scanf(\"%s\",MAP[i]);\n    ss.clear();\n    min_len=1; res=\"0\";\n    REP(y,H)REP(x,W){\n      for(dx=-1;dx<=1;dx++){\n        for(dy=-1;dy<=1;dy++){\n          if(dx|dy)dfs(x,y,0);\n        }\n      }\n    }\n    string res = \"0\";\n    sort(ss.begin(),ss.end());\n    REP(i,ss.size()-1){\n      int len = 0;\n      REP(k,min(ss[i].size(),ss[i+1].size())){\n        if(ss[i][k]==ss[i+1][k])len++;\n        else break;\n      }\n      if(len < res.size())continue;\n      if(res.size() == len){\n        res = min(res, ss[i].substr(0,len));\n      }else{\n        res = ss[i].substr(0, len);\n      }\n    }\n    puts(res.c_str());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\n\nint dx[] = {-1,0,1,1,1,0,-1,-1};\nint dy[] = {1,1,1,0,-1,-1,-1,0};\n\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\nint H,W;\nstring donut[11];\nmap<string, int> res;\n\nvoid dfs(string str,int sy,int sx, int y,int x,int a) {\n    int ny = (y+dy[a]+H) % H;\n    int nx = (x+dx[a]+W) % W;\n    res[str]++;\n    if(sy==ny && sx==nx) return;\n\n    dfs(str+donut[ny][nx],sy,sx,ny,nx,a);\n}\n\nstring cmp(string s1,string s2) {\n    if(s1.size() > s2.size()) return  s1;\n    else if(s1.size() < s2.size()) return s2;\n    else return s1 < s2 ? s1 : s2;\n}\n\nvoid solve() {\n    res.clear();\n    rep(i,11) donut[i]=\"\";\n    rep(i,H) cin>>donut[i];\n    rep(y,H) rep(x,W) {\n        rep(a,8) {\n            string tmp;\n            tmp = donut[y][x];\n            dfs(tmp,y,x,y,x,a);\n        }\n    }\n    string ans;\n    for(const auto &it : res){\n        if(it.sc >= 2) {\n            ans = cmp(ans,it.fr);\n        }\n    }\n    if(ans.size() <= 2) ans = \"0\";\n    cout<<ans<<endl;\n}\n\nint main() {\n    while(cin>>H>>W) {\n        if(H+W==0) break;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long int dx[] = { 0,1,1,1,0,-1,-1,-1 };\nlong long int dy[] = { 1,1,0,-1,-1,-1,0,1 };\n\nint main()\n{\n\tlong long int M , N;\n\twhile(cin >> M >> N , M || N)\n\t{\n\t\tvector<vector<char>>D(M , vector<char>(N));\n\t\tset<string>SS;\n\t\tstring ans;\n\t\tfor(size_t i = 0; i < M; i++)\n\t\t{\n\t\t\tfor(size_t j = 0; j < N; j++)\n\t\t\t{\n\t\t\t\tcin >> D[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(long long int i = 0; i < M; i++)\n\t\t{\n\t\t\tfor(long long int j = 0; j < N; j++)\n\t\t\t{\n\t\t\t\tlong long int startx = j , starty = i;\n\t\t\t\tfor(long long int k = 0; k < 8; k++)\n\t\t\t\t{\n\t\t\t\t\tlong long int p = 1;\n\t\t\t\t\tstring s;\n\t\t\t\t\ts.push_back(D[starty][startx]);\n\t\t\t\t\twhile(!( ( startx + p*dx[k] + N * 2000 ) % N == startx && ( starty + p*dy[k] + M * 2000 ) % M == starty ))\n\t\t\t\t\t{\n\t\t\t\t\t\ts.push_back(D[( starty + p*dy[k] + M * 2000 ) % M][( startx + p*dx[k] + N * 2000 ) % N]);\n\t\t\t\t\t\tif(s.length() >= ans.length())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tauto s2 = s;\n\t\t\t\t\t\t\treverse(s2.begin() , s2.end());\n\t\t\t\t\t\t\tif(s2 <= s)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif(SS.find(s2) != SS.end() && ( ans.length() < s2.length() || ans > s2 ))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tans = s2;\n\t\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tSS.insert(s2);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tp++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans.length() <= 1)\n\t\t{\n\t\t\tcout << 0 << endl;\n\t\t} else\n\t\t{\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\nusing namespace std;\n\n\nint main() {\n    int H, W;\n    while (cin >> H >> W, H) {\n        string field[10];\n        for (int i = 0; i < H; i++) {\n            cin >> field[i];\n        }\n\n        vector<string> cand;\n        for (int y = 0; y < H; y++) {\n            for (int x = 0; x < W; x++) {\n                for (int dx = -1; dx <= 1; dx++) {\n                    for (int dy = -1; dy <= +1; dy++) {\n                        if (dx == 0 && dy == 0) continue;\n                        bool visited[15][25] = { 0 };\n                        int nx = x, ny = y;\n                        string spell;\n                        while (!visited[ny][nx]) {\n                            visited[ny][nx] = true;\n                            spell += field[ny][nx];\n                            cand.push_back(spell);\n                            nx = (nx + dx + W) % W;\n                            ny = (ny + dy + H) % H;\n                        }\n                    }\n                }\n            }\n        }\n        \n        string ans = \"\";\n        sort(cand.begin(), cand.end());\n        for (int i = 1; i < (int)cand.size(); ++i) {\n            if (cand[i].size() == 1) continue;\n            if (cand[i] != cand[i - 1]) continue;\n            if (ans.size() < cand[i].size() || ans > cand[i]) {\n                ans = cand[i];\n            }\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <vector>\nusing namespace std;\n#define REP(i,x)for(int i=0;i<x;i++)\n\nstring res;\nint H,W,dx,dy,min_len;\nchar s[200];\nchar MAP[11][22];\nbool visit[20][20];\nvector<string> ss;\nvoid dfs(int x,int y,int k){\n  if(visit[y][x]){\n    ss.push_back(string(s));\n    return;\n  }\n  s[k]=MAP[y][x];  visit[y][x]=1;\n  dfs((x + dx + W) % W, (y + dy + H) % H, k + 1);\n  s[k]=0;  visit[y][x]=0;\n}\nint main() {\n  while(scanf(\"%d%d\",&W,&H),H){\n    REP(i,H)scanf(\"%s\",MAP[i]);\n    ss.clear();\n    min_len=1; res=\"0\";\n    REP(y,H)REP(x,W){\n      for(dx=-1;dx<=1;dx++){\n        for(dy=-1;dy<=1;dy++){\n          if(dx|dy)dfs(x,y,0);\n        }\n      }\n    }\n    string res = \"0\";\n    sort(ss.begin(),ss.end());\n    REP(i,ss.size()-1){\n      int len = 0;\n      REP(k,min(ss[i].size(),ss[i+1].size())){\n        if(ss[i][k]==ss[i+1][k])len++;\n      }\n      if(len < res.size())continue;\n      if(res.size() == len){\n        res = min(res, ss[i].substr(0,len));\n      }else{\n        res = ss[i].substr(0, len);\n      }\n    }\n    puts(res.c_str());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nconstexpr int gcd(int a, int b){\n\treturn b == 0 ? a : gcd(b, a%b);\n}\nint main() {\n\tint h, w;\n\twhile (cin >> h >> w, h) {\n\t\tvector<string> map(h);\n\t\tfor (auto &a : map)cin >> a;\n\t\tint dx[] = { 0,0,1,1,1,-1,-1,-1 };\n\t\tint dy[] = { 1,-1,0,-1,1,0,1,-1 };\n\t\tvector<tuple<string, int, int, int>> buf;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tfor (int d = 0; d < 8; d++) {\n\t\t\t\t\tbuf.push_back(make_tuple((string)\"\" + map[i][j], j, i, d));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint l = 0;\n\t\tfor (; l < h*w / gcd(h, w); l++) {\n\t\t\tsort(buf.begin(), buf.end());\n\t\t\tvector<tuple<string, int, int, int>> buf2;\n\t\t\tfor (int i = 1; i < buf.size(); i++) {\n\t\t\t\tif (get<0>(buf[i - 1]).size() < l)continue;\n\t\t\t\tif (get<0>(buf[i - 1]) == get<0>(buf[i]))buf2.push_back(buf[i - 1]);\n\t\t\t\tfor (; i<buf.size()&&get<0>(buf[i - 1]) == get<0>(buf[i]); i++)buf2.push_back(buf[i]);\n\t\t\t}\n\t\t\tif (buf2.empty())break;\n\t\t\tbuf = move(buf2);\n\t\t\tfor (auto &a : buf) {\n\t\t\t\tstring str;\n\t\t\t\tint x, y, d;\n\t\t\t\ttie(str, x, y, d) = a;\n\t\t\t\tint x1 = ((x + dx[d]*l) % w + w) % w;\n\t\t\t\tint y1 = ((y + dy[d]*l) % h + h) % h;\n\t\t\t\tif (x1 == x && y1 == y)continue;\n\t\t\t\tstr += map[y1][x1];\n\t\t\t\ta = make_tuple(str, x, y, d);\n\t\t\t}\n\t\t}\n\t\tif (l < 3)cout << 0 << endl;\n\t\telse {\n\t\t\tstring str = get<0>(buf[0]);\n\t\t\tcout << str.substr(0, l-1) << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * GCA : \"Computer is artificial subject absolutely,Math is God\"\n */\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <cctype>\n#include <utility>\n#include <ctime>\nusing namespace std;\n#ifdef DEBUG\n#define VAR(a,b) __typeof(b) a=(b)\n#define debug(...) printf(\"DEBUG: \"),printf(__VA_ARGS__)\n#else\n#define VAR(a,b) __typeof(b) a=(b)\n#define debug(...)\n#endif\ntypedef unsigned int uint;\ntypedef long long int Int;\ntypedef unsigned long long int UInt;\n#define Set(a,s) memset(a,s,sizeof(a))\n#define Pln() printf(\"\\n\")\n#define For(i,x)for(int i=0;i<x;i++)\n#define CON(x,y) x##y\n#define M 25\n#define PB push_back\n#define oo INT_MAX\n#define FOR(a,b) for(VAR(a,(b).begin());a!=(b).end();++a)\n#define eps 1e-9\n#define X first\n#define Y second\ninline bool xdy(double x,double y){return x>y+eps;}\ninline bool xddy(double x,double y){return x>y-eps;}\ninline bool xcy(double x,double y){return x<y-eps;}\ninline bool xcdy(double x,double y){return x<y+eps;}\nconst Int mod=1000000007;\nint nx,ny;\nchar mz[M][M];\nset<Int> sid;\nint dx[8]={0,1,1,1,0,-1,-1,-1};\nint dy[8]={1,1,0,-1,-1,-1,0,1};\nchar store[M*M];\nint ox,oy;\nstring ans;\nInt isid;\nbool vis[M][M];\nvoid dfs(int x,int y,int d,int dep){\n\n\tstore[dep]=mz[y][x];\n\tint nex=(x+dx[d]+nx)%nx;\n\tint ney=(y+dy[d]+ny)%ny;\n\tstore[dep+1]=0;\n\tisid=130*isid+store[dep];\n\tstring ss(store);\n\tif(sid.count(isid)&&ss.length()>=2){\n\t\tif(ss.length()>ans.length())ans=ss;\n\t\telse if(ss.length()==ans.length()&&ss<ans){\n\t\t\tans=ss;\n\t\t}\n\t}else sid.insert(isid);\n\tif(!vis[nex][ney]){\n\t\tvis[nex][ney]=1;\n\t\tdfs(nex,ney,d,dep+1);\n\t\tvis[nex][ney]=0;\n\t}\n\n}\nvoid solve(){\n\tSet(vis,0);\n\tfor(int i=0;i<ny;i++){\n\t\tfor(int j=0;j<nx;j++){\n\t\t\tfor(int k=0;k<8;k++){\n\t\t\t\tisid=0;\n\t\t\t\tvis[j][i]=1;\n\t\t\t\tdfs(j,i,k,0);\n\t\t\t\tvis[j][i]=0;\n\t\t\t}\n\t\t}\n\t}\n\tif(ans.size())\n\t\tputs(ans.c_str());\n\telse puts(\"0\");\n}\nint main() {\n\tios_base::sync_with_stdio(0);\n\twhile(~scanf(\"%d%d\",&ny,&nx)&&ny&&nx){\n\t\tsid.clear();\n\t\tans=\"\";\n\t\tfor(int i=0;i<ny;i++)scanf(\"%s\",mz[i]);\n\t\tsolve();\n\n\t}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stdio.h>\n#include <set>\n\nusing namespace std;\n\n#define dirmax 8\nint l[2];\nint dir[8][2] = { {0,1}, {1,0}, {-1,0}, {0,-1}, {1,1}, {-1,1}, {1,-1}, {-1,-1} };\nstring ans;\n\nvoid search( set<string> *v, int pos[2] , char ch[10][20]){\n\n\tfor(int i = 0; i < dirmax; i++) {\n\t\tstring str;\n\t\tint cpos[] = { pos[0], pos[1] };\n\n\t\tstr += ch[pos[0]][pos[1]];\n\n\t\twhile( 1 ) {\n\t\t\tfor(int j = 0; j < 2; j++) {\n\t\t\t\tcpos[j] += dir[i][j];\n\t\t\t\tif( cpos[j] < 0 ) cpos[j] = l[j] - 1;\n\t\t\t\tif( cpos[j] >= l[j] ) cpos[j] = 0;\n\t\t\t}\n\t\t\tif( cpos[0] == pos[0] && cpos[1] == pos[1] ) break;\n\t\t\tstr += ch[cpos[0]][cpos[1]];\n\t\t\t\n\t\t\tif( v->find(str) != v->end() )\n\t\t\t\tif( ( str.length() > ans.length() ) || ( str.length() == ans.length() && str < ans ) )\n\t\t\t\t\tans = str;\n\t\t\tv->insert(str);\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tcin >> l[0] >> l[1];\n\t\tif( l[0] == 0 && l[1] == 0 ) break;\n\t\tchar donut[10][20];\n\t\tans = \"\";\n\n\t\tset< string > strs;\n\n\t\t//入力を取得する\n\t\tfor(int i = 0; i < l[0]; i++) {\n\t\t\tstring str;\n\t\t\tcin >> str;\n\t\t\tfor(int j = 0; j < l[1]; j++){\n\t\t\t\tdonut[i][j] = str[j];\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < l[0]; i++) {\n\t\t\tfor(int j = 0; j < l[1]; j++) {\n\t\t\t\tint pos[2];\n\t\t\t\tpos[0] = i;\n\t\t\t\tpos[1] = j;\n\t\t\t\tsearch( &strs, pos, donut );\n\t\t\t}\n\t\t}\n\n\t\tif(ans == \"\") \n\t\t\tcout << 0 << endl;\n\t\telse \n\t\t\tcout << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <set>\nusing namespace std;\n#define REP(i,x)for(__typeof(x) i=0;i<x;i++)\n\nstring res;\nset<string> m;\nint H,W,dx,dy,min_len;\nchar s[200];\nstring MAP[11];\nbool visit[20][20];\nvoid dfs(int x,int y,int k){\n  if(k==min_len){\n    if(m.count(string(s)))res=min(res,string(s));\n    m.insert(string(s));\n  }else if(k>min_len){\n    if(m.count(string(s)))res=string(s),min_len=k;\n    m.insert(string(s));\n  }\n  if(visit[y][x])\n    return;\n  s[k]=MAP[y][x];  visit[y][x]=1;\n  dfs((x + dx + W) % W, (y + dy + H) % H, k + 1);\n  s[k]=0;  visit[y][x]=0;\n}\nint main() {\n  while(cin>>H>>W,H){\n    REP(i,H)cin>>MAP[i];\n    m.clear();\n    min_len=1;\n    res=\"0\";\n    REP(y,H)REP(x,W){\n      for(dx=-1;dx<=1;dx++){\n        for(dy=-1;dy<=1;dy++){\n          if(dx|dy)dfs(x,y,0);\n        }\n      }\n    }\n    cout<<res<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<climits>\n#include<iostream>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<list>\n#include<map>\n#include<set>\ntypedef long long ll;\ntypedef unsigned long long ull;\nusing namespace std;\n#define pb push_back\nint dy[]={0, 0, 1, -1, 1, 1, -1, -1};\nint dx[]={1, -1, 0, 0, 1, -1, 1, -1};\n \n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n\nint gcd (int a,int b){\n    if(a < b){\n        int c = b;\n        b = a;\n        a = c;\n    }\n\n    if(a % b == 0)\n        return b;\n    return gcd(b,a % b);\n}\n\nint lcm(int a,int b){\n    return a * b / gcd(a,b);\n}\n\nint main(){\n    while(1){\n        int h,w;\n        scanf(\"%d%d\",&h,&w);\n        if(h == 0 && w == 0)\n            break;\n\n        char donuts[10][21];\n        for(int i = 0;i < h;i++)\n            scanf(\"%s\",&donuts[i][0]);\n\n        int maxi = 0;\n        char s[1000] = \"\";\n        for(int i = 0;i < h * w * 8;i++){\n            for(int j = i + 1;j < h * w * 8;j++){\n                int h1 = i / (w * 8),w1 = i % (w * 8) / 8,d1 = i % (w * 8) % 8;\n                int h2 = j / (w * 8),w2 = j % (w * 8) / 8,d2 = j % (w * 8) % 8;\n                int maxlen;\n                if(d1 < 2)\n                    maxlen = w;\n                else if(d1 < 4)\n                    maxlen = h;\n                else\n                    maxlen = lcm(w,h);\n                if(d2 < 2){\n                    if(maxlen > w)\n                        maxlen = w;\n                }\n                else if(d2 < 4 && maxlen > h)\n                    maxlen = h;\n\n                int len = 0;\n                char kari[1000];\n                for(int k = 0;k < maxlen;k++){\n                    int y1 = (h1 + dy[d1] * k + h) % h,x1 = (w1 + dx[d1] * k + w) % w;\n                    int y2 = (h2 + dy[d2] * k + h) % h,x2 = (w2 + dx[d2] * k + w) % w;\n                    if(donuts[y1][x1] == donuts[y2][x2]){\n                        len++;\n                        kari[k] = donuts[y1][x1];\n                        kari[k + 1] = '\\0';\n                    }else\n                        break;\n                }\n                if(maxi < len){\n                    maxi = len;\n                    strcpy(s,kari);\n                }else if(maxi == len && strcmp(s,kari) > 0){\n                    strcpy(s,kari);\n                }\n            }\n        }\n        if(strlen(s) > 1)\n            printf(\"%s\\n\",s);\n        else\n            printf(\"0\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nint main() {\n  while(1) {\n    int h,w;\n    cin>>h>>w;\n    if(!h)break;\n    vector<string> t(h);\n    REP(i,h)cin>>t[i];\n    vector<string> alls;\n    REP(i,h)REP(j,w) {\n      int di[]={1,1,1,0,-1,-1,-1,0};\n      int dj[]={1,0,-1,-1,-1,0,1,1};\n      REP(k,8) {\n        string str;\n        REP(l,h*w) {\n          int ni=(i+di[k]*l+h*w)%h;\n          int nj=(j+dj[k]*l+h*w)%w;\n          if(l&&ni==i&&nj==j) break;\n          str += t[ni][nj];\n          alls.push_back(str);\n        }\n      }\n    }\n    sort(begin(alls),end(alls),[](const string& lhs, const string& rhs){\n      if (lhs.size() > rhs.size()) return true;\n      if (lhs.size() == rhs.size() && lhs < rhs) return true;\n      return false;\n    });\n    int n=alls.size();\n    string ans=\"0\";\n    REP(i,n-1) {\n      if (alls[i].size() == 1) break;\n      if(alls[i] == alls[i+1]) {\n        ans = alls[i];\n        break;\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\n#define rep(i, n) for(int i=0; i<(n); ++i)\n#define mp(a, b) make_pair(a, b)\n\ntemplate<typename T, typename Compare = greater<T> >\ninline void chmax(T& t, T f, Compare comp){if(!comp(t, f))t = f;}\n\nint h, w;\n\ninline int add(int a, int b, int mod){\n    int t = a + b;\n    return t < mod? t < 0? mod + t: t: t - mod;\n}\n\nstring solve(vector<string>& patterns){\n    string res = \"0\";\n    set<string> spells;\n    rep(x, h)rep(y, w){\n        for(int dx=-1; dx<=1; ++dx){\n            for(int dy=-1; dy<=1; ++dy){\n                string spell = \"\";  spell += patterns[x][y];\n                for(int nx=add(x, dx, h), ny=add(y, dy, w); nx!=x || ny!=y; nx=add(nx, dx, h), ny=add(ny, dy, w)){\n                    spell += patterns[nx][ny];\n                    if(!spells.insert(spell).second){\n                        chmax(res, spell, [](string& s, string& t){return mp(t.size(), s) < mp(s.size(), t);});\n                    }\n                }\n            }\n        }\n    }\n    return res;\n}\n\nint main(){\n    while(cin >> h >> w, h|w){\n        vector<string> patterns(h);\n        rep(i, h)cin >> patterns[i];\n        cout << solve(patterns) << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\nint d1[8] = { 1,1,1,0,0,-1,-1,-1 };\nint d2[8] = { 1,0,-1,1,-1,1,0,-1 };\nint h, w;\nint fh(int x) {\n\treturn (x% h+h)%h;\n}\nint fw(int x) {\n\treturn (x%w + w) % w;\n}\nint main() {\n\twhile (cin >> h >> w, h) {\n\t\tchar t[20][20];\n\t\tstring s;\n\t\trep(i, h) {\n\t\t\tcin >> s;\n\t\t\trep(j, w) {\n\t\t\t\tt[i][j] = s[j];\n\t\t\t}\n\t\t}\n\t\tvector<string>v;\n\t\trep(i, h) {\n\t\t\trep(j, w) {\n\t\t\t\trep(k, 8) {\n\t\t\t\t    string u;\n\t\t\t\t    u = t[i][j];\n\t\t\t\t\tint now = 1;\n\t\t\t\t\twhile (!(fh(i + now*d1[k]) == i && fw(j + now*d2[k]) == j)) {\n\t\t\t\t\t\tu += t[fh(i + now * d1[k])][fw(j + now * d2[k])];\n\t\t\t\t\t\tv.push_back(u);\n\t\t\t\t\t\tnow++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(v.begin(), v.end());\n\t\tint len = v.size();\n\t\tui ma = 0; string out = \"0\";\n\t\trep(i, len-1) {\n\t\t\tif (v[i] == v[i + 1] && ma < v[i].length()) {\n\t\t\t\tma = v[i].length(); out = v[i];\n\t\t\t}\n\t\t}\n\t\tcout << out << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\ntypedef struct List{\n\tint cnt;\n\tchar s[210];\n}LIST;\nstruct comp{\n\tbool operator() (const List& a, const List& b) const{  //free\n\t\tif(a.cnt!=b.cnt)\n\t\t\treturn a.cnt>b.cnt ? true : false;\n\t\tfor(int i=0;i<a.cnt;i++)\n\t\t\tif(a.s[i]!=b.s[i])\n\t\t\t\treturn a.s[i]>b.s[i] ? true : false;\n\t\treturn false;\n\t}\n};\nLIST now,ans;\nmap <List,int,comp> MAP;\n\nchar ss[15][25];\nint visit[15][25],op[8][2] = {{-1,-1},{-1,0},{-1,1},{0,-1},{0,1},{1,-1},{1,0},{1,1}};\n\nint main()\n{\n\t//freopen(\"in.txt\",\"r\",stdin);\n\t//freopen(\"out.txt\",\"w\",stdout);\n\t\n\tint N,n,M,m,i,j,mark,maxi,nx,ny,now_cnt;\n\twhile(~scanf(\" %d %d\",&N,&M) && (N+M)){\n\t\tgets(ss[0]);\n\t\tfor(n=0;n<N;n++)\n\t\t\tgets(ss[n]);\n\t\tMAP.clear();\n\t\tans.cnt = 0;\n\t\tnow_cnt = 0;\n\t\tmemset(visit,0,sizeof(visit));\n\t\tmark = 0;\n\t\tfor(n=0;n<N;n++){\n\t\t\tfor(m=0;m<M;m++){\n\t\t\t\tfor(i=0;i<8;i++){\n\t\t\t\t\tmark++;\n\t\t\t\t\tnow.cnt = 1;\n\t\t\t\t\tnow.s[0] = ss[n][m];\n\t\t\t\t\tvisit[n][m] = mark;\n\t\t\t\t\tnx = (n+op[i][0]+N)%N;\n\t\t\t\t\tny = (m+op[i][1]+M)%M;\n\t\t\t\t\twhile(visit[nx][ny]!=mark){\n\t\t\t\t\t\tvisit[nx][ny] = mark;\n\t\t\t\t\t\tnow.s[now.cnt++] = ss[nx][ny];\n\t\t\t\t\t\tnx = (nx+op[i][0]+N)%N;\n\t\t\t\t\t\tny = (ny+op[i][1]+M)%M;\n\t\t\t\t\t\tif(now.cnt>1 && now.cnt>=ans.cnt){\n\t\t\t\t\t\t\tif(MAP.find(now)==MAP.end()){\n\t\t\t\t\t\t\t\tMAP[now] = n*M+m;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\tif(now.cnt>ans.cnt){\n\t\t\t\t\t\t\t\t\tans = now;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if(now.cnt==ans.cnt){\n\t\t\t\t\t\t\t\t\tint which = 1;\n\t\t\t\t\t\t\t\t\tfor(j=0;j<now.cnt;j++){\n\t\t\t\t\t\t\t\t\t\tif(ans.s[j]==now.s[j])\n\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\t\tif(ans.s[j]<now.s[j])\n\t\t\t\t\t\t\t\t\t\t\t\twhich = 1;\n\t\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t\t\twhich = 2;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(which==2)\n\t\t\t\t\t\t\t\t\t\tans = now;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//printf(\"==============================================\\n\");\n\t\tif(ans.cnt>1){\n\t\t\tint re = 0;\n\t\t\tfor(i=0,j=ans.cnt-1;i<=j;i++,j--){\n\t\t\t\tif(ans.s[i]!=ans.s[j]){\n\t\t\t\t\tre = ans.s[i]>ans.s[j] ? 1 : 2;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(re==2 || re==0)\n\t\t\t\tfor(i=0;i<ans.cnt;i++)\n\t\t\t\t\tprintf(\"%c\",ans.s[i]);\n\t\t\telse\n\t\t\t\tfor(i=ans.cnt-1;i>=0;i--)\n\t\t\t\t\tprintf(\"%c\",ans.s[i]);\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\telse\n\t\t\tprintf(\"0\\n\");\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <string>\nusing namespace std;\nint main(){\n  //?????¶????????§?§£????????¨?????????\n  int H, W;\n  while(cin >> H >> W, H||W){\n    string pattern[H];\n    for(int i = 0; i < H; ++i){\n      cin >> pattern[i];\n    }\n    int ng = H*W + 1, ok = 2;\n    int dx[] = {1,0,-1,0,1,1,-1,-1}, dy[] = {0,1,0,-1,1,-1,1,-1};\n    string ans = \"0\";\n    while(ng - ok > 1){\n      int m = (ng + ok)/2;\n      map<string,int> M;\n      for(int i = 0; i < H; ++i){\n\tfor(int j = 0; j < W; ++j){\n\t  for(int k = 0; k < 8; ++k){\n\t    string str(m,'.');\n\t    str[0] = pattern[i][j];\n\t    bool f = true;\n\t    for(int l = 1; l < m; ++l){//??????????????????\n\t      int s = ((i + l*dx[k])%H+H)%H, t = ((j + l*dy[k])%W+W)%W;\n\t      if(s == i && t == j){\n\t\tf = false;\n\t\tbreak;\n\t      }else{\n\t\tstr[l] = pattern[s][t];\n\t\t//str += pattern[s][t];\n\t      }\n\t    }\n\t    //cout << str << endl;\n\t    if(f){\n\t      M[str] += 1;\n\t    }\n\t  }\n\t}\n      }\n      bool g = false;\n      //for(map<string,int>::iterator itr = M.end(); itr != M.begin(); --itr){\n      for(map<string,int>::iterator itr = M.begin(); itr != M.end(); ++itr){\n\tif(itr->second > 1){\n\t  g = true;\n\t  ans = itr->first;\n\t  break;\n\t}\n      }\n      \n      if(g){\n\tok = m;\n      }else{\n\tng = m;\n      }\n\n    }\n    \n    cout << ans << endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//29\n#include<iostream>\n#include<string>\n#include<set>\n\nusing namespace std;\n\nint main(){\n  for(int h,w;cin>>h>>w,h|w;){\n    char g[10][21];\n    for(int i=0;i<h;i++){\n      cin>>g[i];\n    }\n    set<string> s;\n    string t;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tfor(int k=-1;k<=1;k++){\n\t  for(int l=-1;l<=1;l++){\n\t    string c;\n\t    int y=i,x=j;\n\t    c=g[y][x];\n\t    for(;;){\n\t      if(!s.insert(c).second&&(t.size()<c.size()||(t.size()==c.size()&&c<t))){\n\t\tt=c;\n\t      }\n\t      y=(y+k+h)%h;\n\t      x=(x+l+w)%w;\n\t      if(y==i&&x==j)break;\n\t      c+=g[y][x];\n\t    }\n\t  }\n\t}\n      }\n    }\n    if(t.size()>=2){\n      cout<<t<<endl;\n    }else{\n      cout<<0<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <set>\n#define REP(i,a,b) for (int i = (a); i < (b); i++)\n#define rep(i,a) REP(i,0,a)\nusing namespace std;\n\nint H, W;\nint dw[] = {1,1,0,-1,-1,-1,0,1};\nint dh[] = {0,1,1,1,0,-1,-1,-1};\n\nint main(void){\n    while (cin >> H >> W && H) {\n        vector<string> S(H,\"\");\n        rep(i, H) cin >> S[i];\n        string ans = \"\";\n        set<string> appear;\n        \n        rep(h, H) rep(w, W) rep(i, 8) {\n            string s = \"\";\n            s += S[h][w];\n            int iw = w, ih = h;\n            w = (w+dw[i]+W)%W; h = (h+dh[i]+H)%H;\n            while (!(w == iw && h == ih)) {\n                s += S[h][w];\n                if (appear.find(s) != appear.end()) {\n                    if (s.length()  > ans.length()) ans = s;\n                    if (s.length() == ans.length()) ans = min(ans, s);\n                }\n                appear.insert(s);\n                w = (w+dw[i]+W)%W; h = (h+dh[i]+H)%H;\n            }\n        }\n        cout << (ans.length() > 1 ? ans:\"0\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<string>\n#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int dx[]={1,1,0,-1,-1,-1,0,1},dy[]={0,-1,-1,-1,0,1,1,1};\n\nint main(){\n\tfor(int h,w;scanf(\"%d%d\",&h,&w),h;){\n\t\tchar D[10][21];\n\t\trep(i,h) scanf(\"%s\",D[i]);\n\n\t\tmap<string,int> f;\n\t\trep(i,h) rep(j,w) rep(k,8) { // ツスツタツーツトツ暗環置ツづ陛サツ古シ\n\t\t\tint y=i,x=j;\n\t\t\tstring s;\n\t\t\tdo{\n\t\t\t\ts+=D[y][x];\n\t\t\t\tif(s.length()>=2) ++f[s];\n\t\t\t\ty=(y+dy[k]+h)%h;\n\t\t\t\tx=(x+dx[k]+w)%w;\n\t\t\t}while(y!=i||x!=j);\n\t\t}\n\n\t\tstring s_ans;\n\t\tmap<string,int>::iterator it;\n\t\tfor(it=f.begin();it!=f.end();++it) if(it->second>=2) {\n\t\t\tif(s_ans.length()<it->first.length()\n\t\t\t|| s_ans.length()==it->first.length() && s_ans>it->first) s_ans=it->first;\n\t\t}\n\t\tputs(s_ans==\"\"?\"0\":s_ans.c_str());\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nint div_row[8] = {-1,-1,-1,0,0,1,1,1},div_col[8] = {-1,0,1,-1,1,-1,0,1},H,W;\n\n\nint main(){\n\n\tint work_row,work_col,max_length;\n\tchar table[10][21];\n\tstring ans;\n\n\tset<string> SPELL;\n\n\twhile(true){\n\t\tcin >> H >> W;\n\t\tif(H == 0 && W == 0)break;\n\n\t\tSPELL.clear();\n\t\tans = \"0\";\n\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tfor(int k = 0; k < W; k++)cin >>table[i][k];\n\t\t}\n\n\t\tmax_length = 2;\n\n\t\tfor(int row = 0; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tfor(int a = 0; a < 8; a++){\n\n\t\t\t\t\tstring work;\n\t\t\t\t\twork += table[row][col];\n\n\t\t\t\t\twork_row = (row + div_row[a]+H)%H;\n\t\t\t\t\twork_col = (col + div_col[a]+W)%W;\n\n\t\t\t\t\twhile(work_row != row || work_col != col){\n\t\t\t\t\t\twork += table[work_row][work_col];\n\n\t\t\t\t\t\tif(SPELL.find(work) != SPELL.end()){\n\t\t\t\t\t\t\tif(work.length() > max_length){\n\t\t\t\t\t\t\t\tmax_length = work.length();\n\t\t\t\t\t\t\t\tans = work;\n\t\t\t\t\t\t\t}else if(work.length() == max_length){\n\t\t\t\t\t\t\t\tif(work < ans){\n\t\t\t\t\t\t\t\t\tans = work;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tSPELL.insert(work);\n\t\t\t\t\t\t}\n\t\t\t\t\t\twork_row = (work_row + div_row[a]+H)%H;\n\t\t\t\t\t\twork_col = (work_col + div_col[a]+W)%W;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e16;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n\nll mod_add(ll a, ll b) { return (a + b) % MOD; }\nll mod_sub(ll a, ll b) { return (a - b + MOD) % MOD; }\nll mod_mul(ll a, ll b) { return a*b % MOD; }\n\nll h,w;\n\nvector<string> vs;\nmap<string,ll> m;\n\nll dx[] = {0,1,0,-1,-1,-1,1,1};\nll dy[] = {1,0,-1,0,-1,1,1,-1};\n\nvoid make(int y,int x){\n    rep(i,8){\n        string t = \"\";\n        int ny = y,nx = x;\n        while(1){\n            t += vs[ny][nx];\n            ny += dy[i];\n            ny = (ny + h) % h;\n            nx += dx[i];\n            nx = (nx + w) % w;\n            if(ny == y && nx == x)break;\n        }\n        m[t]++;\n    }\n}\n\n\nint main(){\n    while(cin >> h >> w&& h + w){\n        vs.clear();\n        vs.resize(h);\n        m.clear();\n        rep(i,h)cin >> vs[i];\n        rep(i,h)rep(j,w)make(i,j);\n        ll l = 0;\n        string ans = \"\";\n        for(auto it = m.begin();it != m.end();it++){\n            if(it->second > 1){\n                if(l < it->first.size()){\n                    l = it->first.size();\n                    ans = it->first;\n                }\n            }\n        }\n        map<string,ll>::iterator end = m.end();\n        end--;\n        for(auto it = m.begin();it != end;it++){\n            auto nxt = it;\n            nxt++;\n            string s = it->first;\n            string t = nxt->first;\n            rep(i,min(t.size(),s.size())){\n                if(s[i] != t[i]){\n                    if(i != 0){\n                        string buf = s.substr(0,i);\n                        if(l < buf.size()){\n                            // cout << s << \"  \" << t << endl;\n                            // cout << \"!!\" << buf << endl;\n                            l = buf.size();\n                            ans = buf;\n                        }\n                    }\n                    break;\n                }\n            }\n        }\n        if(l <= 1)cout << 0 << endl;\n        else cout << ans << endl;\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\nint dx[8]={1,-1,0,0,1,1,-1,-1},dy[8]={0,0,1,-1,1,-1,1,-1};\nvoid renew(string &x,string y){\n\tif(x.size()>y.size()) return;\n\tif(x.size()<y.size()){\n\t\tx=y;\n\t\treturn;\n\t}\n\tif(x>y) x=y;\n}\nint main(){\n\twhile(true){\n\t\tint H,W;\n\t\tcin>>H>>W;\n\t\tif(H==0) break;\n\t\tstring s[10];\n\t\trep(i,H) cin>>s[i];\n\t\tstring ans;\n\t\trep(ai,H) rep(aj,W) rep(ad,8){\n\t\t\t//show(ai);\n\t\t\t//show(aj);\n\t\t\t//show(ad);\n\t\t\tstring sa;\n\t\t\tint ax=ai,ay=aj;\n\t\t\tdo{\n\t\t\t\tsa+=s[ax][ay];\n\t\t\t\tax+=dx[ad],ay+=dy[ad];\n\t\t\t\tif(ax==H) ax=0;\n\t\t\t\tif(ay==W) ay=0;\n\t\t\t\tif(ax==-1) ax=H-1;\n\t\t\t\tif(ay==-1) ay=W-1;\n\t\t\t\t//show(ax);\n\t\t\t\t//show(ay);\n\t\t\t}while(!(ax==ai&&ay==aj));\n\t\t\t//show(sa);\n\t\t\trep(bi,H) rep(bj,W) rep(bd,8){\n\t\t\t\tif(s[ai][aj]!=s[bi][bj]) break;\n\t\t\t\tif(ai==bi&&aj==bj&&ad==bd) continue;\n\t\t\t\t//show(bi);\n\t\t\t\t//show(bj);\n\t\t\t\t//show(bd);\n\t\t\t\tint bx=bi,by=bj,cnt=0;\n\t\t\t\tdo{\n\t\t\t\t\tif(cnt>=sa.size()||sa[cnt]!=s[bx][by]) break;\n\t\t\t\t\tcnt++;\n\t\t\t\t\tbx+=dx[bd],by+=dy[bd];\n\t\t\t\t\tif(bx==H) bx=0;\n\t\t\t\t\tif(by==W) by=0;\n\t\t\t\t\tif(bx==-1) bx=H-1;\n\t\t\t\t\tif(by==-1) by=W-1;\n\t\t\t\t}while(!(bx==bi&&by==bj));\n\t\t\t\trenew(ans,sa.substr(0,cnt));\n\t\t\t}\n\t\t}\n\t\tif(ans.size()<=1) puts(\"0\");\n\t\telse cout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <algorithm>\n#include <string>\n#include <iostream>\n#include <map>\n\nusing namespace std;\n#define loop(i,a,b) for(int i=(a);i<int(b);i++)\n#define rep(i,b) loop(i,0,b)\n\nint dx[]={1,1,1,0};\nint dy[]={-1,0,1,1};\n\nstring g[100];\n\nint h,w;\nint main(){\n    while(cin>>h>>w && h){\n        vector<string> v;\n        rep(i,h)cin>>g[i];\n        rep(i,h)rep(j,w){\n            rep(d,4){\n                string s;\n                for(int ii=i, jj=j; s.size()==0 || ii!=i || jj!=j;\n                    ii=(ii+h+dy[d])%h, jj=(jj+w+dx[d])%w){\n                    s += g[ii][jj];\n                    if(s.size()==1) continue;\n                    v.push_back(s);\n                    reverse(s.begin(),s.end());\n                    v.push_back(s);\n                    reverse(s.begin(),s.end());\n                }\n            }\n        }\n\n        sort(v.rbegin(),v.rend(),[](const string& s, const string& t){\n                if(s.size()==t.size()) return s>t;\n                return s.size()<t.size();\n            });\n\n        string ans=\"\";\n        rep(i,v.size()-1){\n            if(v[i]==v[i+1]){\n                ans=v[i];\n                break;\n            }\n        }\n        if(ans==\"\")ans=\"0\";\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint dy[8] = {-1, -1, -1, 0, 0, 1, 1, 1};\nint dx[8] = {-1, 0, 1, -1, 1, -1, 0, 1};\nint h, w;\n\nvector<string> lt;\nmap<string, int> mp;\n\nvoid dfs(int sy, int sx, int y, int x, int dir, string s) {\n    int ny = (y + dy[dir] + h) % h;\n    int nx = (x + dx[dir] + w) % w;\n    if (sy != ny || sx != nx) {\n        string ns = s + lt[ny][nx];\n        mp[ns] ++;\n        dfs(sy, sx, ny, nx, dir, ns);\n    }\n}\n\nint main() {\n    while (cin >> h >> w) {\n        if (!h) break;\n        lt.resize(h);\n        for (int i=0; i<h; ++i) {\n            cin >> lt[i];\n        }\n        mp.clear();\n        for (int i=0; i<h; ++i) {\n            for (int j=0; j<w; ++j) {\n                for (int k=0; k<8; ++k) {\n                    string s(1, lt[i][j]);\n                    dfs(i, j, i, j, k, s);\n                }\n            }\n        }\n        string magic = \"\";\n        int len = -1;\n        for (auto it=mp.begin(); it!=mp.end(); ++it) {\n            if (it->second < 2) continue;\n            if (len < (int)(it->first).size() || (len == (int)(it->first).size() && it->first < magic)) {\n                len = (it->first).size();\n                magic = it->first;\n            }\n        }\n        if (magic == \"\") {\n            cout << 0 << endl;\n        } else {\n            cout << magic << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n\nusing namespace std;\n\nint main()\n{\n\tint w, h;\n\tchar seat[10][20];\n\tmap<string, int> mp;\n\n\tint dx[] = { 0, 1, 1, 1, 0, -1, -1, -1 };\n\tint dy[] = { 1, 1, 0, -1, -1, -1, 0, 1 };\n\t\n\twhile( cin >> h >> w, (h||w))\n\t{\n\t\tmp.clear();\n\t\t\n\t\tfor( int j = 0; j < h; j++)\n\t\t\tfor( int i = 0; i < w; i++)\n\t\t\t{\n\t\t\t\tcin >> seat[j][i];\n\t\t\t}\n\t\t\n\t\t\n\t\tfor( int j = 0; j < h; j++)\n\t\t\tfor( int i = 0; i < w; i++)\n\t\t\t\tfor( int d = 0; d < 8 ; d++ )\n\t\t\t\t{ \n\t\t\t\t\tstring str = \"\";\n\t\t\t\t\tint x = i, y = j;\n\t\t\t\t\t\n\t\t\t\t\tdo\n\t\t\t\t\t{\n\t\t\t\t\t\tstr += seat[y][x];\n\n\t\t\t\t\t\tx = (x + w + dx[d]) % w;\n\t\t\t\t\t\ty = (y + h + dy[d]) % h;\n\n\t\t\t\t\t\tmp[str] += 1;\n\n\t\t\t\t\t}\n\t\t\t\t\twhile( x != i || y != j );\n\t\t\t\t\t\n\t\t\t\t}\n\t\n\t\tstring out = \"\";\n\t\tmap<string, int>::iterator it; \n\n\t\tfor( it = mp.begin() ; it != mp.end(); it++ )\n\t\t{\n\t\t\tif( (*it).second >= 2 )\n\t\t\t\tif( (*it).first.length() > out.length() )\n\t\t\t\t{\n\t\t\t\t\tout = (*it).first;\n\t\t\t\t}\n\t\t\t\telse if( (*it).first.length() == out.length() )\n\t\t\t\t{\n\t\t\t\t\tif( out > (*it).first )\n\t\t\t\t\t\tout = (*it).first;\n\t\t\t\t}\n\t\t}\n\n\t\tif( out.length() >= 2 )\n\t\t\tcout << out << endl;\n\t\telse\n\t\t\tcout << '0' << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define ll long long\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1316\n\nint h, w;\n\nint dy[8] = { -1, -1, -1, 0, 0, 1, 1, 1 };\nint dx[8] = { -1, 0, 1, -1, 1, -1, 0, 1 };\n\nset<string> Set;\nint Maxlen = 0;\nstring ans;\nvector<string> donut;\nvector<vector<int>> usage;\n\nvoid solve(int i, int j) {\n\tfor (int k = 0; k < 8;k++) {\n\t\tusage.clear();\n\t\tusage.resize(h, vector<int>(w, 0));\n\t\tstring ret = \"\";\n\t\tint y = i, x = j;\n\t\twhile (usage[y][x] == 0) {\n\t\t\tret += donut[y][x];\n\n\t\t\tif (Set.find(ret) != Set.end()) {\n\t\t\t\tif (ret.length() > Maxlen) {\n\t\t\t\t\tMaxlen = ret.length();\n\t\t\t\t\tans = ret;\n\t\t\t\t}\n\t\t\t\telse if (ret.length() == Maxlen && ret < ans) {\n\t\t\t\t\tans = ret;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSet.insert(ret);\n\t\t\t}\n\n\t\t\tusage[y][x] = 1;\n\t\t\ty = (y + dy[k] + h) % h;\n\t\t\tx = (x + dx[k] + w) % w;\n\n\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\twhile (cin >> h >> w) {\n\t\tif (h == 0 && w == 0)break;\n\t\tMaxlen = 0;\n\t\tans = \"\";\n\t\tdonut.clear();\n\t\tdonut.resize(h);\n\t\tSet.clear();\n\t\tfor (int i = 0; i < h;i++) {\n\t\t\tcin >> donut[i];\n\t\t}\n\n\t\tfor (int i = 0; i < h;i++) {\n\t\t\tfor (int j = 0; j < w;j++) {\n\t\t\t\tsolve(i, j);\n\t\t\t}\n\t\t}\n\t\tif (ans.length() < 2) cout << 0 << endl;\n\t\telse cout << ans << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long int dx[] = { 0,1,1,1,0,-1,-1,-1 };\nlong long int dy[] = { 1,1,0,-1,-1,-1,0,1 };\n\nint main()\n{\n\tlong long int M , N;\n\twhile(cin >> M >> N , M || N)\n\t{\n\t\tvector<vector<char>>D(M , vector<char>(N));\n\t\tset<string>SS;\n\t\tstring ans;\n\t\tfor(size_t i = 0; i < M; i++)\n\t\t{\n\t\t\tfor(size_t j = 0; j < N; j++)\n\t\t\t{\n\t\t\t\tcin >> D[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(long long int i = 0; i < M; i++)\n\t\t{\n\t\t\tfor(long long int j = 0; j < N; j++)\n\t\t\t{\n\t\t\t\tlong long int startx = j , starty = i;\n\t\t\t\tfor(long long int k = 0; k < 8; k++)\n\t\t\t\t{\n\t\t\t\t\tlong long int p = 1;\n\t\t\t\t\tstring s;\n\t\t\t\t\ts.push_back(D[starty][startx]);\n\t\t\t\t\twhile(!( ( startx + p*dx[k] + N * 2000 ) % N == startx && ( starty + p*dy[k] + M * 2000 ) % M == starty ))\n\t\t\t\t\t{\n\t\t\t\t\t\ts.push_back(D[( starty + p*dy[k] + M * 205 ) % M][( startx + p*dx[k] + N * 205 ) % N]);\n\t\t\t\t\t\tif(s.length() >= ans.length())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(SS.find(s) != SS.end() && ans>s)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tans = s;\n\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tSS.insert(s);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tp++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans.length() <= 1)\n\t\t{\n\t\t\tcout << 0 << endl;\n\t\t} else\n\t\t{\n\t\t\tauto ans2 = ans;\n\t\t\treverse(ans2.begin() , ans2.end());\n\t\t\tcout << ( ans < ans2 ? ans : ans2 ) << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"ctime\"\n\nusing namespace std;\n\nconstexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-12;\n\n//int N, M, K, T, H, W, L, R;\nlong long int N, M, K, T, H, W, L, R;\n\nint dx[] = { 1,1,1,0,-1,-1,-1,0 };\nint dy[] = { 1,0,-1,-1,-1,0,1,1 };\n\nstruct Node {\n\tint x, y, d;\n\tNode(int a, int b, int c) {\n\t\tx = a, y = b, d = c;\n\t}\n\tbool operator<(const Node&n)const {\n\t\treturn make_pair(x, y) < make_pair(n.x, n.y);\n\t}\n};\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\twhile (cin >> H >> W, H) {\n\t\tvector<string>s(H);\n\t\tfor (auto &i : s)cin >> i;\n\t\tmap<string, set<Node>>st;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tfor (int k = 0; k < 8; k++) {\n\t\t\t\t\tstring box;\n\t\t\t\t\tvector<vector<int>>visited(H, vector<int>(W));\n\t\t\t\t\tint ny = i, nx = j;\n\t\t\t\t\twhile (!visited[ny][nx]) {\n\t\t\t\t\t\tvisited[ny][nx] = 1;\n\t\t\t\t\t\tbox.push_back(s[ny][nx]);\n\t\t\t\t\t\tny += dy[k];\n\t\t\t\t\t\tnx += dx[k];\n\t\t\t\t\t\tif (ny < 0)ny += H;\n\t\t\t\t\t\tif (ny >= H)ny -= H;\n\t\t\t\t\t\tif (nx < 0)nx += W;\n\t\t\t\t\t\tif (nx >= W)nx -= W;\n\t\t\t\t\t\tst[box].insert(Node(i, j, k));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstring ans = \"\";\n\t\tfor (auto i : st) {\n\t\t\tif (i.second.size() == 1)continue;\n\t\t\tif (ans.size() < i.first.size())ans = i.first;\n\t\t}\n\t\tif (ans.size() <= 1) {\n\t\t\tcout << 0 << endl;\n\t\t}\n\t\telse cout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a); i<(b); ++i)\n#define REP(i,n) FOR(i,0,n)\n\nint dy[]={-1,-1,-1,0,1,1,1,0};\nint dx[]={-1,0,1,1,1,0,-1,-1};\nint main(){\n  int h,w;\n  while(cin>>h>>w,h|w){\n    vs f(h);\n    REP(i,h){\n      cin>>f[i];\n    }\n    string ans;\n    map<string,int> cnt;\n    REP(i,h){\n      REP(j,w){\n        REP(d,8){\n          int y=i,x=j;\n          string tmp;\n          do{\n            tmp+=f[y][x];\n            if(tmp.size()>=2){\n              cnt[tmp]++;\n              if(cnt[tmp]>=2){\n                if(ans.size()<tmp.size()||(ans.size()==tmp.size()&&ans>tmp)){\n                  ans=tmp;\n                }\n              }\n            }\n            y+=dy[d];\n            x+=dx[d];\n            if(y<0)y=h-1;\n            if(x<0)x=w-1;\n            if(y>=h)y=0;\n            if(x>=w)x=0;\n          }while(y!=i||x!=j);\n        }\n      }\n    }\n    if(ans.size()){\n      cout<<ans<<endl;\n    }else{\n      cout<<0<<endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\n#define rep(i, n) for(int i=0; i<(n); ++i)\n#define mp(a, b) make_pair(a, b)\n\nint h, w;\n\nstring solve(vector<string>& patterns){\n    auto comp = [](const string& s, const string& t){return mp(s.size(), t) < mp(t.size(), s);};\n    set<string, decltype(comp)> spells(comp), magicSpells(comp);\n    magicSpells.insert(\"0\");\n    rep(x, h)rep(y, w){\n        for(int dx=-1; dx<=1; ++dx){\n            for(int dy=-1; dy<=1; ++dy){\n                string spell = \"\";  spell += patterns[x][y];\n                for(int nx=(x+dx+h)%h, ny=(y+dy+w)%w; nx!=x || ny!=y; (nx+=(dx+h))%=h, (ny+=(dy+w))%=w){\n                    spell += patterns[nx][ny];\n                    (spells.count(spell)? magicSpells: spells).insert(spell);\n                }\n            }\n        }\n    }\n    return *(--magicSpells.end());\n}\n\nint main(){\n    while(cin >> h >> w, h|w){\n        vector<string> patterns(h);\n        rep(i, h)cin >> patterns[i];\n        cout << solve(patterns) << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint gcd(int a, int b){\n    while(a != b){\n        if(a > b) a = a - b; else b = b - a;\n    }\n    return a;\n}\n\nint lcm(int a, int b){\n    return ((a / gcd(a, b)) * b);\n}\n\nint main(){\n    int h, w;\n    while(true){\nchar torus[10][20];\n        string str[2048];\n        bool ok[2048];\n        int num = 0;\n\n        for(int i=0; i<2048; ++i){\n            str[i] = \"\";\n            ok[i] = true;\n        }\n\n        cin >> h >> w;\n        if(h==0 && w==0) break;\n\n        int cml = lcm(w, h);\n\n        for(int i=0; i<h; ++i){\n            for(int j=0; j<w; ++j){\n                cin >> torus[i][j];\n            }\n        }\n\n        //一番長い文字列をつくる\n\n        for(int y=0; y<h; ++y){\n            for(int x=0; x<w; ++x){\n                for(int i=0; i<h; ++i){\n                    str[num] += torus[(y+i)%h][x];\n                    str[num+1] += torus[h-(y+i)%h-1][x];\n                }\n                num += 2;\n            }\n        }\n        for(int y=0; y<h; ++y){\n            for(int x=0; x<w; ++x){\n                for(int i=0; i<w; ++i){\n                    str[num] += torus[y][(x+i)%w];\n                    str[num+1] += torus[y][w-(x+i)%w-1];\n                }\n                num += 2;\n            }\n        }\n        for(int y=0; y<h; ++y){\n            for(int x=0; x<w; ++x){\n                for(int i=0; i<cml; ++i){\n                    str[num] += torus[(y+i)%h][(x+i)%w];\n                    str[num+1] += torus[(y+i)%h][w-(x+i)%w-1];\n                    str[num+2] += torus[h-(y+i)%h-1][(x+i)%w];\n                    str[num+3] += torus[h-(y+i)%h-1][w-(x+i)%w-1];\n                }\n                num += 4;\n            }\n        }\n\n\n        string result = \"\";\n\n        sort(str, str+num);\n\n        //徐々に削る\n        for(int i=0; i<cml; ++i){\n            for(int j=num-1; j>0; --j){\n                if(ok[j] && str[j].length() >= i && str[j-1].length() >= i){\n                    cout << str[j].substr(0,i) << endl;\n                    cout << str[j-1].substr(0,i) << endl;\n                    cout << endl;\n                    if(str[j].substr(0, i) == str[j-1].substr(0, i)){\n                        result = str[j];\n                        result.resize(i);\n                    }else{\n                        ok[j] = false;\n                    }\n                }\n            }\n        }\n\n        cout << ((result.length() == 0) ? \"0\" : result) << endl;\n\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdint>\n#include <cstdio>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nusing ll = long long;\n\nconst int dh[8] = {1, 1, 0, -1, -1, -1, 0, 1}, dw[8] = {0, 1, 1, 1, 0, -1, -1, -1};\n\nint H, W;\nstring m[10];\n\nint main() {\n    cin.tie(0); ios::sync_with_stdio(false);\n    while (true) {\n        cin >> H >> W;\n        if (H+W == 0) break;\n        for (int j = 0; j < H; ++j) {\n            cin >> m[j];\n        }\n\n        string ans = \"0\";\n        for (int a = 0; a < H*W; ++a) {\n            int h1 = a / W, w1 = a % W;\n            for (int b = a; b < H*W; ++b) {\n                int h2 = b / W, w2 = b % W;\n                if (m[h1][w1] != m[h2][w2]) continue;\n\n                for (int d1 = 0; d1 < 8; ++d1) {\n                    for (int d2 = ((h1==h2&&w1==w2)?(d1+1):0); d2 < 8; ++d2) {\n\n                        string t = string(1, m[h1][w1]);\n                        for (int j = 1; ; ++j) {\n                            int nh1 = (h1 + dh[d1]*j + 100*H) % H;\n                            int nw1 = (w1 + dw[d1]*j + 100*W) % W;\n\n                            int nh2 = (h2 + dh[d2]*j + 100*H) % H;\n                            int nw2 = (w2 + dw[d2]*j + 100*W) % W;\n\n                            if ((nh1 == h1 && nw1 == w1) || (nh2 == h2 && nw2 == w2)) {\n                                break;\n                            }\n                            if (m[nh1][nw1] != m[nh2][nw2]) {\n                                break;\n                            }\n\n                            t.push_back(m[nh1][nw1]);\n                        }\n                        if (t.size() <= 1) continue;\n                        if (t.size() >= 5) {\n                        }\n\n                        bool ok = false;\n                        if (t.size() > ans.size()) {\n                            ok = true;\n                        } else if (t.size() == ans.size()) {\n                            for (int j = 0; j < t.size(); ++j) {\n                                if (t[j] < ans[j]) {\n                                    ok = true;\n                                    break;\n                                } else if (t[j] > ans[j]) {\n                                    break;\n                                }\n                            }\n                        }\n                        if (ok) {\n                            ans = t.substr(0, t.size());\n                        }\n                    }\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n        return 0;\n    }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <set>\n#include <map>\n#include <queue>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\n#define REP(i, n) for(int i=0; i<(int)n; ++i)\n#define FOR(i,c) for(__typeof((c).begin())i = (c).begin(); i != (c).end(); ++i)\n#define ALL(c) (c).begin() , (c).end()\n\nint main() {\n  int dx[8] = {-1,-1,-1,0,0,1,1,1};\n  int dy[8] = {-1,0,1,-1,1,-1,0,1};\n\n  int h,w;\n  while(cin>>h>>w, h||w) {\n    set<string> ap;\n    char ba[h][w];\n    REP(i, h) {\n      REP(j, w) {\n        cin >> ba[i][j];\n      }\n    }\n\n    string ans = \"\";\n    REP(i, h) {\n      REP(j, w) {\n        REP(k, 8) {\n          string str = \"\";\n          int y = i;\n          int x = j;\n          do {\n            str += string(1,ba[y][x]);\n\n            if(ap.find(str) != ap.end()) {\n//                            cout<<str<<endl;\n              if(ans == \"\" || ans.length() < str.length()\n                 || (ans.length() == str.length() && str < ans))\n                ans = str;\n            }\n            if(str.length() > 1) ap.insert(str);\n\n            y += dy[k];\n            x += dx[k];\n            if (x<0) x = w-1;\n            if (x>=w) x = 0;\n            if (y<0) y = h-1;\n            if (y>=h) y = 0;\n            //cout << k << \" \" << j <<\" \" << i << \" \" << x << \" \" << y << endl;\n            if (i==y && j==x) break;\n          } while(1);\n\n\n//                    cout << str << endl;\n        }\n      }\n    }\n\n    if(ans.length() == 0) ans = \"0\";\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<map>\n#define f first\n#define s second\nusing namespace std;\n \nint h,w,ii,jj;\nint X[8]={-1,1,-1,1,0,-1,0,1};\nint Y[8]={-1,1,1,-1,1,0,-1,0};\nchar Donut[10][20];\nvector<string> V;\nstring maxs;\nmap<string,pair<int,int> > M;\n \nvoid Check(string s)\n{\n  if(maxs.length()<s.length())maxs=s;\n  else if(maxs.length()==s.length()){\n    if(maxs>s)maxs=s;\n  }\n}\n \nvoid make(int x,int y)\n{\n  for(int k=0;k<8;k++){\n    string S=\"\";\n    int a=x,b=y;\n    S+=Donut[a][b];\n    while(1){\n      a+=Y[k];\n      b+=X[k];\n      if(a==-1)a=h-1;\n      if(b==-1)b=w-1;\n      if(a==h)a=0;\n      if(b==w)b=0;\n      if(a==x && b==y)break;\n      S+=Donut[a][b];\n      if(M[S].f==0 && M[S].s==0){\n    M[S].f=x+1;\n    M[S].s=y+1;\n      }\n      else {\n    Check(S);\n      }\n    }\n  }\n}\n \nint main()\n{\n  while(1){\n    cin>>h>>w;\n    if(h+w==0)break;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++)cin>>Donut[i][j];\n    }\n    M.clear();\n    maxs=\"\";\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n    make(i,j);\n      }\n    }\n    if(maxs==\"\")cout<<0<<endl;\n    else cout<<maxs<<endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nchar s[10][21];\nbool used[10][20];\nint main() {\n\tint h, w;\n\twhile (scanf(\"%d%d\", &h, &w), h) {\n\t\trep(i, h)scanf(\"%s\", s[i]);\n\t\tmap<string, int>mp;\n\t\trep(i, h)rep(j, w) {\n\t\t\tfor (int dx = -1; dx <= 1; dx++) {\n\t\t\t\tfor (int dy = -1; dy <= 1; dy++) {\n\t\t\t\t\tif (dx == 0 && dy == 0)continue;\n\t\t\t\t\tstring t;\n\t\t\t\t\tmemset(used, 0, sizeof(used));\n\t\t\t\t\tint x = i, y = j;\n\t\t\t\t\twhile (!used[x][y]) {\n\t\t\t\t\t\tt += s[x][y]; used[x][y] = 1; x += dx; y += dy;\n\t\t\t\t\t\tx = (x + h) % h; y = (y + w) % w;\n\t\t\t\t\t\tmp[t]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstring ans;\n\t\tfor (auto p : mp) {\n\t\t\tif (p.second > 1 && ans.size() < p.first.size())ans = p.first;\n\t\t}\n\t\tif (ans == \"\")ans = \"0\";\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=100005,INF=1<<30;\nvector<int> dh={-1,0,1,1,1,0,-1,-1},dw={1,1,1,0,-1,-1,-1,0};\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    while(1){\n        int H,W;cin>>H>>W;\n        if(H+W==0) break;\n        map<string,int> MA;\n        string ans=\"\";\n        \n        vector<string> S(H);\n        for(int i=0;i<H;i++) cin>>S[i];\n        \n        for(int a=0;a<H;a++){\n            for(int b=0;b<W;b++){\n                for(int k=0;k<8;k++){\n                    string T;\n                    int hnow=a,wnow=b;\n                    while(1){\n                        T+=S[hnow][wnow];\n                        MA[T]++;\n                        \n                        hnow+=dh[k];\n                        wnow+=dw[k];\n                        \n                        if(hnow<0) hnow+=H;\n                        if(hnow>=H) hnow-=H;\n                        \n                        if(wnow<0) wnow+=W;\n                        if(wnow>=W) wnow-=W;\n                        \n                        if(hnow==a&&wnow==b) break;\n                    }\n                }\n            }\n        }\n        \n        for(auto it=MA.begin();it!=MA.end();it++){\n            if((*it).second>=2){\n                if(ans.size()==(*it).first.size()){\n                    ans=min(ans,(*it).first);\n                }else if(ans.size()<(*it).first.size()){\n                    ans=(*it).first;\n                }\n            }\n        }\n        \n        if(ans.size()>=2) cout<<ans<<endl;\n        else cout<<0<<endl;\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define INFS (1LL<<28)\n#define DEKAI 1000000007\n#define INF 1000000007\n//#define MOD 1000000007\n#define lp(i,n) for(int i=0;i<n;i++)\n#define lps(i,n) for(int i=1;i<=n;i++)\n#define all(c) begin(c), end(c)\n\n//#define int long long \n\nnamespace {\n\t#define __DECLARE__(C)    \\\n\t    template <typename T> \\\n\tstd::ostream &operator<<(std::ostream &, const C<T> &);\n\n\t#define __DECLAREM__(C)               \\\n\t    template <typename T, typename U> \\\n\tstd::ostream &operator<<(std::ostream &, const C<T, U> &);\n\n\t__DECLARE__(std::vector)\n\t__DECLARE__(std::deque)\n\t__DECLARE__(std::set)\n\t__DECLARE__(std::stack)\n\t__DECLARE__(std::queue)\n\t__DECLARE__(std::priority_queue)\n\t__DECLARE__(std::unordered_set)\n\t__DECLAREM__(std::map)\n\t__DECLAREM__(std::unordered_map)\n\n\ttemplate <typename T, typename U>\n\tstd::ostream &operator<<(std::ostream &, const std::pair<T, U> &);\n\ttemplate <typename... T>\n\tstd::ostream &operator<<(std::ostream &, const std::tuple<T...> &);\n\ttemplate <typename T, std::size_t N>\n\tstd::ostream &operator<<(std::ostream &, const std::array<T, N> &);\n\n\ttemplate <typename Tuple, std::size_t N>\n\tstruct __TuplePrinter__ {\n\t\tstatic void print(std::ostream &os, const Tuple &t) {\n\t\t\t__TuplePrinter__<Tuple, N - 1>::print(os, t);\n\t\t\tos << \", \" << std::get<N - 1>(t);\n\t\t}\n\t};\n\n\ttemplate <typename Tuple>\n\tstruct __TuplePrinter__<Tuple, 1> {\n\t\tstatic void print(std::ostream &os, const Tuple &t) { os << std::get<0>(t); }\n\t};\n\n\ttemplate <typename... T>\n\tstd::ostream &operator<<(std::ostream &os, const std::tuple<T...> &t) {\n\t\tos << '(';\n\t\t__TuplePrinter__<decltype(t), sizeof...(T)>::print(os, t);\n\t\tos << ')';\n\t\treturn os;\n\t}\n\n\ttemplate <typename T, typename U>\n\tstd::ostream &operator<<(std::ostream &os, const std::pair<T, U> &v) {\n\t\treturn os << '(' << v.first << \", \" << v.second << ')';\n\t}\n\n\t#define __INNER__                             \\\n\tos << '[';                                \\\n\tfor (auto it = begin(c); it != end(c);) { \\\n\t\tos << *it;                            \\\n\t\tos << (++it != end(c) ? \", \" : \"\");   \\\n\t}                                         \\\n\treturn os << ']';\n\n\ttemplate <typename T, std::size_t N>\n\tstd::ostream &operator<<(std::ostream &os, const std::array<T, N> &c) {\n\t\t__INNER__\n\t}\n\n\t#define __DEFINE__(C)                                           \\\n\t    template <typename T>                                       \\\n\tstd::ostream &operator<<(std::ostream &os, const C<T> &c) { \\\n\t\t__INNER__                                               \\\n\t}\n\n\t#define __DEFINEM__(C)                                             \\\n\t    template <typename T, typename U>                              \\\n\tstd::ostream &operator<<(std::ostream &os, const C<T, U> &c) { \\\n\t\t__INNER__                                                  \\\n\t}\n\n\t#define __DEFINEW__(C, M1, M2)                                  \\\n\t    template <typename T>                                       \\\n\tstd::ostream &operator<<(std::ostream &os, const C<T> &c) { \\\n\t\tstd::deque<T> v;                                        \\\n\t\tfor (auto d = c; !d.empty(); d.pop()) v.M1(d.M2());     \\\n\t\t\treturn os << v;                                         \\\n\t}\n\n\t__DEFINE__(std::vector)\n\t__DEFINE__(std::deque)\n\t__DEFINE__(std::set)\n\t__DEFINEW__(std::stack, push_front, top)\n\t__DEFINEW__(std::queue, push_back, front)\n\t__DEFINEW__(std::priority_queue, push_front, top)\n\t__DEFINE__(std::unordered_set)\n\t__DEFINEM__(std::map)\n\t__DEFINEM__(std::unordered_map)\n}\n\n#define pii pair<int,int>\n#define ll long long\ninline ll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\ninline ll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\n\n// modint \ntemplate <signed M, unsigned T>\nstruct mod_int {\n\tconstexpr static signed MODULO = M;\n\tconstexpr static unsigned TABLE_SIZE = T;\n\n\tsigned x;\n\n\tmod_int() : x(0) {}\n\n\tmod_int(long long y) : x(static_cast<signed>(y >= 0 ? y % MODULO : MODULO - (-y) % MODULO)) {}\n\n\tmod_int(int y) : x(y >= 0 ? y % MODULO : MODULO - (-y) % MODULO) {}\n\n\tmod_int &operator+=(const mod_int &rhs) {\n\t\tif ((x += rhs.x) >= MODULO) x -= MODULO;\n\t\treturn *this;\n\t}\n\n\tmod_int &operator-=(const mod_int &rhs) {\n\t\tif ((x += MODULO - rhs.x) >= MODULO) x -= MODULO;\n\t\treturn *this;\n\t}\n\n\tmod_int &operator*=(const mod_int &rhs) {\n\t\tx = static_cast<signed>(1LL * x * rhs.x % MODULO);\n\t\treturn *this;\n\t}\n\n\tmod_int &operator/=(const mod_int &rhs) {\n\t\tx = static_cast<signed>((1LL * x * rhs.inv().x) % MODULO);\n\t\treturn *this;\n\t}\n\n\tmod_int operator-() const { return mod_int(-x); }\n\n\tmod_int operator+(const mod_int &rhs) const { return mod_int(*this) += rhs; }\n\n\tmod_int operator-(const mod_int &rhs) const { return mod_int(*this) -= rhs; }\n\n\tmod_int operator*(const mod_int &rhs) const { return mod_int(*this) *= rhs; }\n\n\tmod_int operator/(const mod_int &rhs) const { return mod_int(*this) /= rhs; }\n\n\tbool operator<(const mod_int &rhs) const { return x < rhs.x; }\n\n\tmod_int inv() const {\n\t\tassert(x != 0);\n\t\tif (x <= static_cast<signed>(TABLE_SIZE)) {\n\t\t\tif (_inv[1].x == 0) prepare();\n\t\t\treturn _inv[x];\n\t\t} else {\n\t\t\tsigned a = x, b = MODULO, u = 1, v = 0, t;\n\t\t\twhile (b) {\n\t\t\t\tt = a / b;\n\t\t\t\ta -= t * b;\n\t\t\t\tstd::swap(a, b);\n\t\t\t\tu -= t * v;\n\t\t\t\tstd::swap(u, v);\n\t\t\t}\n\t\t\treturn mod_int(u);\n\t\t}\n\t}\n\n\tmod_int pow(long long t) const {\n\t\tassert(!(x == 0 && t == 0));\n\t\tmod_int e = *this, res = mod_int(1);\n\t\tfor (; t; e *= e, t >>= 1)\n\t\t\tif (t & 1) res *= e;\n\t\treturn res;\n\t}\n\n\tmod_int fact() {\n\t\tif (_fact[0].x == 0) prepare();\n\t\treturn _fact[x];\n\t}\n\n\tmod_int inv_fact() {\n\t\tif (_fact[0].x == 0) prepare();\n\t\treturn _inv_fact[x];\n\t}\n\n\tmod_int choose(mod_int y) {\n\t\tassert(y.x <= x);\n\t\treturn this->fact() * y.inv_fact() * mod_int(x - y.x).inv_fact();\n\t}\n\n\tstatic mod_int _inv[TABLE_SIZE + 1];\n\n\tstatic mod_int _fact[TABLE_SIZE + 1];\n\n\tstatic mod_int _inv_fact[TABLE_SIZE + 1];\n\n\tstatic void prepare() {\n\t\t_inv[1] = 1;\n\t\tfor (int i = 2; i <= (int)TABLE_SIZE; ++i) {\n\t\t\t_inv[i] = 1LL * _inv[MODULO % i].x * (MODULO - MODULO / i) % MODULO;\n\t\t}\n\t\t_fact[0] = 1;\n\t\tfor (unsigned i = 1; i <= TABLE_SIZE; ++i) {\n\t\t\t_fact[i] = _fact[i - 1] * int(i);\n\t\t}\n\t\t_inv_fact[TABLE_SIZE] = _fact[TABLE_SIZE].inv();\n\t\tfor (int i = (int)TABLE_SIZE - 1; i >= 0; --i) {\n\t\t\t_inv_fact[i] = _inv_fact[i + 1] * (i + 1);\n\t\t}\n\t}\n};\n\ntemplate <int M, unsigned F>\nstd::ostream &operator<<(std::ostream &os, const mod_int<M, F> &rhs) {\n\treturn os << rhs.x;\n}\n\ntemplate <int M, unsigned F>\nstd::istream &operator>>(std::istream &is, mod_int<M, F> &rhs) {\n\tlong long s;\n\tis >> s;\n\trhs = mod_int<M, F>(s);\n\treturn is;\n}\n\ntemplate <int M, unsigned F>\nmod_int<M, F> mod_int<M, F>::_inv[TABLE_SIZE + 1];\n\ntemplate <int M, unsigned F>\nmod_int<M, F> mod_int<M, F>::_fact[TABLE_SIZE + 1];\n\ntemplate <int M, unsigned F>\nmod_int<M, F> mod_int<M, F>::_inv_fact[TABLE_SIZE + 1];\n\ntemplate <int M, unsigned F>\nbool operator==(const mod_int<M, F> &lhs, const mod_int<M, F> &rhs) {\n\treturn lhs.x == rhs.x;\n}\n\ntemplate <int M, unsigned F>\nbool operator!=(const mod_int<M, F> &lhs, const mod_int<M, F> &rhs) {\n\treturn !(lhs == rhs);\n}\n\nconst int MF = 1000010;\nconst int MOD = 1000000007;\n\nusing mint = mod_int<MOD, MF>;\n\nmint binom(int n, int r) { return (r < 0 || r > n || n < 0) ? 0 : mint(n).choose(r); }\n\nmint fact(int n) { return mint(n).fact(); }\n\nmint inv_fact(int n) { return mint(n).inv_fact(); }\nconst ll mod = 1000000007;\nconst int MAX_N = 10000;  // 400MB\n// const int MAX_N = 1024; // 4MB\n// nCr % mod\n\n#define int long long\n#define double long double \n\ninline ll gcds(ll a, ll b) { return b ? gcds(b, a % b) : a; }\ninline ll lcms(ll a, ll b) { return a / gcd(a, b) * b; }\n\n#define RK 200000000000\n#define LK 300000000000\n#define PL 400000000000\n#define MI 500000000000\n#define KA 600000000000\n\nstring solve(vector<string> v){\n\tset<string> ls;\n\tint ans=-1;\n\tstring as=\"0\";\n\tlp(i,v.size()){\n\t\tstring s=v[i]+v[i];\n\t\t//cout<<s<<endl;\n\t\tlp(len,v[i].size()+1){\n\t\t\tif(len==0)continue;\n\t\t\tfor(int j=0;j<v[i].size();j++){\n\t\t\t\tstring t=s.substr(j,len);\n\t\t\t\tif(ls.find(t)!=ls.end()){\n\t\t\t\t\tif(ans<(int)t.size()){\n\t\t\t\t\t\tas=t;\n\t\t\t\t\t\tans=t.size();\n\t\t\t\t\t}\n\t\t\t\t\telse if (ans==(int)t.size()&&as>t){\n\t\t\t\t\t\tas=t;\n\t\t\t\t\t\tans=t.size();\n\t\t\t\t\t}/*\n\t\t\t\t\telse if (ans==t.size()){\n\t\t\t\t\t\tcout<<as<<\" \"<<t<<endl;\n\t\t\t\t\t}*/\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tls.insert(t);\n\t\t\t\t}\n\t\t\t\t//cout<<t<<endl;\n\t\t\t}\n\t\t}\n\t}\n\t//cout<<\"A:\"<<as<<endl;\n\tif(as.size()<=1)as=\"0\";\n\tif(ans==-1||ans==1)as=\"0\";\n\treturn as;\n}\n\nsigned main(){\n\twhile(1){\n\t\tint h,w;\n\t\tcin>>h>>w;\n\t\tif(h==0&&w==0)break;\n\t\tvector<string> s(h);\n\t\tvector<string> lis;\n\t\tlp(i,h){\n\t\t\tcin>>s[i];\n\t\t\tlis.push_back(s[i]);\n\t\t\tstring t=s[i];\n\t\t\treverse(all(t));\n\t\t\tlis.push_back(t);\n\t\t}\n\t\tlp(i,w){\n\t\t\tstring t=\"\";\n\t\t\tlp(j,h){\n\t\t\t\tt+=s[j][i];\n\t\t\t}\n\t\t\tlis.push_back(t);\n\t\t\treverse(all(t));\n\t\t\tlis.push_back(t);\n\t\t}\n\t\tint done[20];\n\t\tlp(i,20)done[i]=0;\n\t\tlp(z,h){\n\t\t\tif(done[z]==1)break;\n\t\t\tint nowy=0,nowx=z;\n\t\t\tstring t=\"\";\n\t\t\twhile(1){//migisita\n\t\t\t\tt+=s[nowy][nowx];\n\t\t\t\tif(nowy==0)done[nowx]=1;\n\t\t\t\tnowx+=1;\n\t\t\t\tnowy+=1;\n\t\t\t\tnowx%=w;\n\t\t\t\tnowy%=h;\n\t\t\t\tif(nowy==0&&nowx==z)break;\n\t\t\t}\n\t\t\tlis.push_back(t);\n\t\t\treverse(all(t));\n\t\t\tlis.push_back(t);\n\n\t\t\tnowy=0,nowx=z;\n\t\t\tt=\"\";\n\t\t\twhile(1){//migisita\n\t\t\t\tt+=s[nowy][nowx];\n\t\t\t\tnowx+=1;\n\t\t\t\tnowy+=-1;\n\t\t\t\tnowx%=w;\n\t\t\t\tnowy+=h;\n\t\t\t\t(nowy)%=h;\n\t\t\t\tif(nowy==0&&nowx==z)break;\n\t\t\t}\n\t\t\tlis.push_back(t);\n\t\t\treverse(all(t));\n\t\t\tlis.push_back(t);\n\t\t}\n\t\t//cout<<lis<<endl;\n\t\tcout<<solve(lis)<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n \nusing namespace std;\n \nconst int MAXH = 10;\nconst int MAXW = 20;\nint W,H;\nchar field[MAXH][MAXW];\nbool come[MAXH][MAXW];\nint dx[] = {0,1,0,-1,1,1,-1,-1};\nint dy[] = {1,0,-1,0,1,-1,1,-1};\n \nvoid input(){\n  for(int i = 0; i < H; i++)\n    for(int j = 0; j < W; j++) cin >> field[i][j];\n}\n \nstring comp(const string& s1, const string& s2){\n   \n  int len = min(s1.length(),s2.length());\n  string s =\"\";\n \n  for(int i = 0; i < len; i++){\n    if(s1[i] != s2[i]) return s;\n    s+=s1[i];\n  }\n  return s;\n}\n \nvoid print(const vector<string>& v){\n  cout << endl;\n  for(int i = 0; i < v.size(); i++)\n    cout << v[i] << endl;\n  cout << endl;\n}\n \nvoid solve(){\n  vector<string> V;\n \n  for(int i = 0; i < H; i++) \n    for(int j = 0; j < W; j++)\n      for(int d = 0; d < 8; d++){\n        memset(come,false,sizeof(come));\n \n        string s = \"\";\n        int x=j,y=i;\n \n        while(!come[y][x]){\n          s += field[y][x];\n          come[y][x] = true;\n          y = (y+dy[d]+H)%H;\n          x = (x+dx[d]+W)%W;\n        }\n \n        V.push_back(s);\n      }\n \n  sort(V.begin(),V.end());\n  // print(V);\n  \n  string ans = \"\";\n \n  for(int i = 1; i < V.size(); i++){\n     \n    string tmp = comp(V[i-1],V[i]);\n     \n    if(tmp.length() == ans.length()) ans = min(ans,tmp);\n    else if(tmp.length() > ans.length()) ans = tmp;\n  }\n   \n  if(ans.length() > 1)cout << ans << endl;\n  else cout << \"0\" << endl;\n}\n \nint main(){\n \n  while(cin >> H >> W && H+W){\n    input();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <vector>\n#include <iostream>\nusing namespace std;\nint m[29][29];\nmain(){\n\tstring s,t;\n\tint h,w,i,j,x,y;\n\tfor(;cin>>h>>w,h;cout<<s<<endl){\n\t\tvector<string>v;\n\t\tfor(i=0;i<h;i++)cin>>s,v.push_back(s);\n\t\ts=\"0\";\n\t\tmap<string,int>M;\n\t\tfor(i=0;i<h;i++)for(j=0;j<w;j++)for(x=-1;x<=1;x++)for(y=-1;y<=1;y++){\n\t\t\tif(x==0&&y==0)continue;\n\t\t\tmemset(m,0,sizeof(m));\n\t\t\tint Y=i,X=j;\n\t\t\tt=v[Y][X],m[Y][X]=1;X=(X+x+w)%w,Y=(Y+y+h)%h;\n\t\t\tfor(;!m[Y][X];X=(X+x+w)%w,Y=(Y+y+h)%h){\n\t\t\t\tt+=v[Y][X],m[Y][X]=1;\n\t\t\t\tif(++M[t]>1 && (s.size()<t.size()||(s.size()==t.size()&&s>t)))s=t;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <iostream>\n#include <map>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint h,w;\nstring fie[11];\nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,1,-1};\nmap<string,int> cnt;\nbool used[11][21];\nvector<string> index2;\n\nvoid dfs(int y,int x,int k,string str){\n\tif(used[y][x])return;\n\tused[y][x]=true;\n\tstr+=fie[y][x];\n\tcnt[str]++;\n\tindex2.push_back(str);\n\tdfs((y+dy[k]+h)%h,(x+dx[k]+w)%w,k,str);\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&h,&w);\n\t\tif(h+w==0)break;\n\t\tcnt.clear();\n\t\tindex2.clear();\n\t\tfor(int i=0;i<h;i++){\n\t\t\tcin >> fie[i];\n\t\t}\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tfor(int k=0;k<8;k++){\n\t\t\t\t\tmemset(used,false,sizeof(used));\n\t\t\t\t\tdfs(i,j,k,\"\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(index2.begin(),index2.end());\n\t\tindex2.erase(unique(index2.begin(),index2.end()),index2.end());\n\t\tstring res=\"0\";\n\t\tfor(int i=0;i<index2.size();i++){\n\t\t\tif(cnt[index2[i]]>=2 && index2[i].size()>=2){\n\t\t\t\tif(res.size()<index2[i].size() || (res.size()==index2[i].size() && index2[i]<res)){\n\t\t\t\t\tres=index2[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <unordered_set>\n#include <unordered_map>\nusing namespace std;\n\nint dx[] = { 1,1,1,0,-1,-1,-1,0 };\nint dy[] = { 1,0,-1,-1,-1,0,1,1 };\nint main(void)\n{\n\tfor (;;)\n\t{\n\t\tint h, w; cin >> h >> w;\n\t\tif (!h)break;\n\t\tvector<string>donut;\n\t\tfor (int i = 0; i < h; ++i)\n\t\t{\n\t\t\tstring s; cin >> s;\n\t\t\tdonut.push_back(s);\n\t\t}\n\t\tmap<string, int>dic;\n\t\tfor (int i = 0; i < h; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < w; ++j)\n\t\t\t{\n\t\t\t\tfor (int dir = 0; dir < 8; ++dir)\n\t\t\t\t{\n\t\t\t\t\tint ii = i, jj = j;\n\t\t\t\t\tset<pair<int, int>>st;\n\t\t\t\t\tstring str;\n\t\t\t\t\tfor (;;)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (st.count({ ii,jj }))break;\n\t\t\t\t\t\tst.insert({ ii,jj });\n\t\t\t\t\t\tstr.push_back(donut[ii][jj]);\n\t\t\t\t\t\tdic[str]++;\n\t\t\t\t\t\tii += dx[dir]; jj += dy[dir];\n\t\t\t\t\t\tii += h;\n\t\t\t\t\t\tjj += w;\n\t\t\t\t\t\tii %= h;\n\t\t\t\t\t\tjj %= w;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstring ans = \"0\";\n\t\tfor (auto page : dic)\n\t\t{\n\t\t\tif (page.second > 1)\n\t\t\t{\n\t\t\t\tconst string& s = page.first;\n\t\t\t\tif (s.size() > ans.size())\n\t\t\t\t{\n\t\t\t\t\tans = s;\n\t\t\t\t}\n\t\t\t\telse if (s.size() == ans.size())\n\t\t\t\t{\n\t\t\t\t\tif (s < ans)ans = s;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <unordered_set>\n#include <algorithm>\nusing namespace std;\n\nint dx[8]={1, 1, 1, 0, 0,-1,-1,-1};\nint dy[8]={1, 0,-1, 1,-1, 1, 0,-1};\n\nint main(){\n    while(1){\n        int h,w;\n        cin >> h >> w;\n        if(h==0) break;\n        \n        char c[10][20];\n        for(int i=0; i<h; i++){\n            for(int j=0; j<w; j++){\n                cin >> c[i][j];\n            }\n        }\n        unordered_set<string> spell;\n        string ans = \"0\";\n        for(int i=0; i<h; i++){\n            for(int j=0; j<w; j++){\n                for(int d=0; d<8; d++){\n                    string str(1,c[i][j]);\n                    int y=(i+dy[d]+h)%h;\n                    int x=(j+dx[d]+w)%w;\n                    while(y!=i || x!=j){\n                        str += c[y][x];\n                        auto itr = spell.find(str);\n                        if(itr != spell.end()){\n                            if(str.length()>ans.length() ||\n                               (str.length()==ans.length() && str<ans)){\n                                ans = str;\n                            }\n                        }else{\n                            spell.insert(str);\n                        }\n                        y = (y+dy[d]+h)%h;\n                        x = (x+dx[d]+w)%w;\n                    }\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n#define HERE cout << \"HERE: \" << __LINE__ << endl;\n#define INSP(v) cout << v << \" at \" << __LINE__ << endl;\n\nusing namespace std;\ntypedef long long ll;\n\nint dx[] = { -1, -1, 1, 1  };\nint dy[] = { -1,  1, 1, -1 };\n\nint gcd(int a, int b)\n{\n    if (!a) return b;\n    return gcd(b % a, a);\n}\n\nint main()\n{\n    string B[11];\n    while (1) {\n        vector<string> spells;\n        int h, w; cin >> h >> w;\n        if (!h) break;\n\n        loop (h, i) cin >> B[i];\n\n        int m = h * w / gcd(h, w);\n        loop (h, i) loop (w, j) {\n            int x = i, y = j;\n            string left(w, ' ');\n            left[0] = B[i][j];\n            loop (w, k) {\n                left[k] = B[x][y];\n                y = (y + w - 1) % w;\n            }\n            spells.push_back(left);\n            string right(w, ' ');\n            x = i, y = j;\n            loop (w, k) {\n                right[k] = B[x][y];\n                y = (y + 1) % w;\n            }\n            spells.push_back(right);\n            string up(h, ' ');\n            x = i, y = j;\n            loop (h, k) {\n                up[k] = B[x][y];\n                x = (x + h - 1) % h;\n            }\n            spells.push_back(up);\n            string down(h, ' ');\n            x = i, y = j;\n            loop (h, k) {\n                down[k] = B[x][y];\n                x = (x + 1) % h;\n            }\n            spells.push_back(down);\n\n            vector<string> diags(4);\n            loop (4, k) diags[k] = string(m, ' ');\n            loop (4, p) {\n                x = i, y = j;\n                loop (m, k) {\n                    diags[p][k] = B[x][y];\n                    x = (x + dx[p] + h) % h;\n                    y = (y + dy[p] + w) % w;\n                }\n            }\n            spells.insert(spells.end(), diags.begin(), diags.end());\n        }\n\n        sort(all(spells));\n        int l = spells.size();\n\n        int m_cnt = 1;\n        string ans;\n        loop (l-1, i) {\n            int j = 0;\n            int len = min(spells[i].size(), spells[i+1].size());\n            while (j < len && spells[i][j] == spells[i+1][j]) j++;\n            if (j > m_cnt) {\n                m_cnt = j;\n                ans = spells[i].substr(0, j);\n            }\n        }\n        if (m_cnt == 1) cout << 0 << endl;\n        else cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n  for(auto &e:u) fill_v<T>(e,v...);\n}\n\nint64 dy[8] = {-1, -1, -1, 0, 0, 1, 1, 1};\nint64 dx[8] = {-1, 0, 1, -1, 1, -1, 0, 1};\n\nint main(void) {\n  int64 h, w;\n  while (cin >> h >> w && h +w) {\n    vector<string> s(h);\n    REP(i, h) cin >> s[i];\n    map<string, int> mp;\n    REP(sy, h) {\n      REP(sx, w) {\n        mp[string(1, s[sy][sx])]++;\n        REP(d, 8) {\n          int64 yy = sy, xx = sx;\n          vector<vector<int>> used(h, vector<int>(w, 0));\n          string t(1, s[sy][sx]);\n          while (!used[yy][xx]) {\n            used[yy][xx] = 1;\n            yy = (yy + dy[d] + h) % h; xx = (xx + dx[d] + w) % w;\n            if (!used[yy][xx]) {\n              t += s[yy][xx];\n              mp[t]++;\n            }\n          }\n        }\n      }\n    }\n    string res = \"\";\n    for (auto& x : mp) {\n      if (x.sc > 1) {\n        if (res.size() < x.fs.size()) {\n          res = x.fs;\n        } else if (res.size() == x.fs.size()) {\n          if (res >= x.fs) {\n            res = x.fs;\n          }\n        }\n      }\n    }\n    if (res.size() == 0) cout << 0 << endl;\n    else cout << res << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stdio.h>\n#include <set>\n\nusing namespace std;\n\n#define dirmax 8\n\nint l[2];\nint dir[8][2] = { {0,1}, {1,0}, {-1,0}, {0,-1}, {1,1}, {-1,1}, {1,-1}, {-1,-1} };\nstring ans;\n\nvoid search( set<string> *v, int pos[2] , char ch[10][20]){\n\n\tfor(int i = 0; i < dirmax; i++) {\n\t\tstring str;\n\t\tint cpos[] = { pos[0], pos[1] };\n\n\t\tstr += ch[pos[0]][pos[1]];\n\n\t\twhile( 1 ) {\n\t\t\tfor(int j = 0; j < 2; j++) {\n\t\t\t\tcpos[j] += dir[i][j];\n\t\t\t\tif( cpos[j] < 0 ) cpos[j] = l[j] - 1;\n\t\t\t\tif( cpos[j] >= l[j] ) cpos[j] = 0;\n\t\t\t}\n\t\t\tif( cpos[0] == pos[0] && cpos[1] == pos[1] ) break;\n\n\t\t\tstr += ch[cpos[0]][cpos[1]];\n\t\t\t\n\t\t\tif( v->find(str) != v->end() ) {\n \t\t\t\tif( ( str.length() > ans.length() ) || ( str.length() == ans.length() && str < ans ) ) {\n\t\t\t\t\tans = str;\n\t\t\t\t}\n\t\t\t} else \n\t\t\t\tv->insert(str);\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tcin >> l[0] >> l[1];\n\t\tif( l[0] == 0 && l[1] == 0 ) break;\n\n\t\tchar donut[10][20];\n\t\tint pos[2];\n\t\tans = \"\";\n\n\t\tset< string > strs;\n\n\t\tfor(int i = 0; i < l[0]; i++)\n\t\t\tcin >> donut[i];\n\t\t\n\t\tfor(pos[0] = 0; pos[0] < l[0]; pos[0]++)\n\t\t\tfor(pos[1] = 0; pos[1] < l[1]; pos[1]++)\n\t\t\t\tsearch( &strs, pos, donut );\n\n\t\tif(ans == \"\") \n\t\t\tcout << 0 << endl;\n\t\telse \n\t\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define repp(i, l, r) for(int i = (l); i < (r); i++)\n#define per(i, n) for(int i = ((n)-1); i >= 0; i--)\n#define perr(i, l, r) for(int i = ((r)-1); i >= (l); i--)\n#define all(x) (x).begin(),(x).end()\n#define MOD 1000000007\n#define IINF 1000000000\n#define LINF 1000000000000000000\n#define SP <<\" \"<<\n#define CYES cout<<\"Yes\"<<endl\n#define CNO cout<<\"No\"<<endl\n#define CFS cin.tie(0);ios::sync_with_stdio(false)\n\ntypedef long long LL;\ntypedef long double LD;\n\nstruct Trie{\n  struct node{\n    vector<node*> ch;\n  public:\n    int count;\n    node(){\n      ch=vector<node*>(26,NULL);\n      count=0;\n    }\n  };\n  node* root;\n  string dfs(node* now){\n    string s=\"\";\n    rep(i,26){\n      if(now->ch[i]!=NULL){\n        if(now->ch[i]->count>1){\n          string t = string(1,'A'+i)+dfs(now->ch[i]);\n          if(s.length()<t.length()){\n            s=t;\n          }\n        }\n      }\n    }\n    return s;\n  }\n  void edfs(node* now){\n    rep(i,26){\n      if(now->ch[i]!=NULL){\n        edfs(now->ch[i]);\n      }\n    }\n    delete now;\n  }\npublic:\n  Trie(){\n    root = new node;\n  }\n  void add(string &s){\n    node* now = root;\n    int n = s.length();\n    rep(i,n){\n      if(now->ch[s[i]-'A']==NULL){\n        now->ch[s[i]-'A'] = new node;\n      }\n      now=now->ch[s[i]-'A'];\n      now->count++;\n    }\n  }\n  string solve(){\n    return dfs(root);\n  }\n  ~Trie(){\n    edfs(root);\n  }\n};\n\nint main(){\n  vector<int> vx={-1,-1,-1,0,0,1,1,1};\n  vector<int> vy={-1,0,1,-1,1,-1,0,1};\n  while(1){\n    int h,w;\n    cin >> h >> w;\n    if(h==0) return 0;\n    vector<string> f(h);\n    rep(i,h) cin >> f[i];\n    Trie tr;\n    rep(i,h){\n      rep(j,w){\n        rep(k,8){\n          vector<vector<bool>> usd(h,vector<bool>(w,false));\n          string s;\n          int nx=i,ny=j;\n          while(!usd[nx][ny]){\n            usd[nx][ny]=true;\n            s.push_back(f[nx][ny]);\n            nx=(nx+vx[k]+h)%h,ny=(ny+vy[k]+w)%w;\n          }\n          tr.add(s);\n        }\n      }\n    }\n    string ans = tr.solve();\n    if(ans.length()<=1) cout << 0 << endl;\n    else cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<iomanip>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<map>\n\nusing namespace std;\n\n#define int long long\n#define endl \"\\n\"\n\nconst long long INF = (long long)1e18;\nconst long long MOD = (long long)1e9 + 7; \n\nstring yn(bool f){return f?\"Yes\":\"No\";}\nstring YN(bool f){return f?\"YES\":\"NO\";}\n\n#define MAX\n\nvector<string> str;\nmap<string, int> mp;\nint h, w, maximum, co;\nstring ans;\n\n\nvoid check(int y, int x){\n\tvector<vector<int>> used(h,vector<int>(w,0));\n\tint count = 1;\n\tstring res;\n\t// cout<<\"y = \"<<y<<\" x = \"<<x<<endl;\n\tfor(int i = -1; i <= 1; i++){\n\t\tfor(int j = -1; j <= 1; j++){\n\t\t\tstring temp;\n\t\t\t// cout<<\"i = \"<<i<<\" j = \"<<j<<endl;\n\t\t\tfor(int ny = y, nx = x; count != used[ny][nx]; nx = (j+w+nx)%w, ny = (i+h+ny)%h){\n\t\t\t\tused[ny][nx] = count;\n\t\t\t\ttemp.push_back(str[ny][nx]);\n\t\t\t\t// cout<<temp<<endl;\n\t\t\t\tif(temp.size() <= 1) continue;\n\t\t\t\t\n\t\t\t\tif(++mp[temp] != 2) continue;\n\t\t\t\tif(ans.size() < temp.size()){\n\t\t\t\t\tans = temp;\n\t\t\t\t} else if(ans.size() == temp.size() && ans > temp){\n\t\t\t\t\tans = temp;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tcount++;\n\t\t}\n\t}\n\t\n\t\n\t// return res;\n}\n\nsigned main(){\n\t// cin.tie(0);\n\t// ios::sync_with_stdio(false);\n\t// cout<<fixed<<setprecision(10);\n\t\n\twhile(true){\n\t\tmp.clear();\n\t\tans.clear();\n\t\t\n\t\tcin>>h>>w;\n\t\t\n\t\tif(!h && !w) break;\n\t\t\n\t\tstr.clear();\n\t\tstr.resize(h);\n\t\t\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tcin>>str[i];\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcheck(i,j);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout<<(ans.size()?ans:\"0\")<<endl;\n\t}\n\t\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define FOR(i, a, b) for(int i=(a);i<(b);i++)\n#define REP(i, n) FOR(i, 0, n)\n#define RFOR(i, a, b) for(int i=(a);i>=(b);i--)\n#define RREP(i, n) RFOR(i, n, 0)\n#define MFOR(i, m) for(auto i=(m).begin();i!=(m).end();i++)\n#define ALL(a) (a).begin(), (a).end()\n#define SZ(x) ((int)(x).size())\n\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vll;\ntypedef vector<vll> vvll;\n\nconst double eps = 1e-10;\nconst int MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\n\ntemplate<typename T>\nvoid printv(vector<T> const& s) {\n  REP(i, SZ(s)) {\n    cout << s[i];\n    if(i == SZ(s)-1) {\n      cout << endl;\n    } else {\n      cout << \" \";\n    }\n  }\n}\n\nvi dx = {0, -1, -1, -1, 0, 1, 1, 1};\nvi dy = {1, 1, 0, -1, -1, -1, 0, 1};\n\nstring solve(int h, int w, const vector<vector<char>> &donuts) {\n  string res = \"\";\n  map<string, bool> m;\n  REP(i, h) {\n    REP(j, w) {\n      vector<string> s;\n      REP(k, 8) {\n        string tmp = \"\";\n        int posi = i, posj = j;\n        tmp += donuts[posi][posj];\n        posi = (posi + dy[k] + h) % h;\n        posj = (posj + dx[k] + w) % w;\n        while(posi != i || posj != j) {\n          s.push_back(tmp);\n          // if(i == 4 && j == 5 && k == 5) cout << posi << \":\" << posj << endl;\n          tmp += donuts[posi][posj];\n          posi = (posi + dy[k] + h) % h;\n          posj = (posj + dx[k] + w) % w;\n        }\n        // if(i == 4 && j == 5 && k == 5) cout << tmp << endl;\n        s.push_back(tmp);\n      }\n      //printv(s);\n      REP(k, SZ(s)) {\n        if(m[s[k]] && (res == \"\" || SZ(res) < SZ(s[k]) || (SZ(res) == SZ(s[k]) && s[k] < res))) {\n          res = s[k];\n        }\n      }\n      REP(k, SZ(s)) {\n        m[s[k]] = true;\n      }\n    }\n  }\n  return res;\n}\n\nint main () {\n  cin.tie(0);\n  cout << fixed << setprecision(10);\n  \n  while(1) {\n    int h, w; cin >> h >> w;\n    if(h == 0 && w == 0) break;\n    vector<vector<char>> donuts(h, vector<char>(w));\n    REP(i, h) {\n      REP(j, w) {\n        cin >> donuts[i][j];\n      }\n    }\n    string ans = solve(h, w, donuts);\n    cout << ((SZ(ans) == 1) ? \"0\" : ans) << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<cstdio>\n#include<stack>\n#include<queue>\n#include<map>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#include<cstring>\nusing namespace std;\nchar mape[22][22];\nint m,n;\nint dirx[]={ 1, 1, 1,-1,-1,-1, 0,  0};\nint diry[]={ 1,-1, 0, 1, 0,-1, 1, -1};\nvector<string> dic;\nmap<string, int> cou;\ninline void cr(int x,int y,string s,int di){\n\tint i=x;\n\tint j=y;\n\tdo{\n\t\ts+=mape[i][j];\n\t\ti+=dirx[di]+m;\n\t\tj+=diry[di]+n;\n\t\ti%=m;\n\t\tj%=n;\n\t\tcou[s]++;\n\t\tif(s.length()>1&&cou[s]==2)dic.push_back(s);\n\t}while(!(i==x&&j==y));\n}\nint aks(string a,string b){\n\tint aa=a.length();\n\tint bb=b.length();\n\tint l=min(aa,bb);\n\tif(aa==bb){\n\t\tfor(int i=0;i<l;i++)\n\t\t\tif(a[i]!=b[i])return a[i]<b[i];\n\t}\n\telse return aa>bb;\n}\nint cmp(string a,string b){\n\tif(cou[a]==cou[b])return aks(a,b);\n}\nvoid pr(string s){\n\tcout<<s<<\"\\n\";\n}\nvoid solve(){\n\tdic.clear();\n\tcou.clear();\n\tfor(int i=0;i<m;i++)\n\t\tfor(int j=0;j<n;j++)\n\t\t\tfor(int ss=0;ss<8;ss++)\n\t\t\t\tcr(i,j,\"\",ss);\n\tsort(dic.begin(),dic.end(),cmp);\n\t/*cout<<\"\\n\";\n\tfor_each(dic.begin(),dic.end(),pr);\n\tcout<<\"\\n\";*/\n}\nint main(){\n\twhile(cin>>m>>n&&n+m>0){\n\t\tfor(int i=0;i<m;i++)\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\tcin>>mape[i][j];\n\t\tsolve();\n\t\tif(dic[0].length()>1)cout<<dic[0]<<\"\\n\";\n\t\telse cout<<\"0\\n\";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n//#include <unordered_set>\n#include <set>\n\nusing namespace std;\nchar field[1001][1001];\nbool used[1001][1001];\n\nint main(){\n  int H,W;\n  while(cin>>H>>W&&(H|W)){\n    for(int i=0;i<H;i++)\n      for(int j=0;j<W;j++)\n\tcin>>field[i][j];\n    vector<string> vs;\n    for(int dy=-1;dy<=1;dy++){\n      for(int dx=-1;dx<=1;dx++){\n\tif(dy==0&&dx==0)continue;\n\tmemset(used,0,sizeof(used));\n\tfor(int i=0;i<H;i++){\n\t  for(int j=0;j<W;j++){\n\t    if(!(i==0||j==0||i==H-1||j==W-1))continue;\n\t    int cx=j;\n\t    int cy=i;\n\t    string s;\n\t    if(used[cy][cx])continue;\n\t    while(1){\n\t      used[cy][cx]=true;\n\t      s+=field[cy][cx];\n\t      cy+=dy;cx+=dx;\n\t      cy=(cy+H)%H;\n\t      cx=(cx+W)%W;\n\t      if(used[cy][cx])break;\n\t    }\n\t    vs.push_back(s);\n\t    //cout<<s<<endl;\n\t  }\n\t}\n      }\n    }\n    //unordered_set<string> us;\n    set<string> us;\n    string cand;\n    for(int i=0;i<(int)vs.size();i++){\n      for(int j=0;j<(int)vs[i].size();j++){\n\tfor(int k=1;k<=(int)vs[i].size();k++){\n\t  string s;\n\t  for(int l=0;l<k;l++){\n\t    s+=vs[i][(j+l)%vs[i].size()];\n\t  }\n\t  if(us.count(s)==1){\n\t    if(cand==\"\"||cand.size()<s.size())\n\t      cand=s;\n\t    else if(cand.size()==s.size()&&cand>s)\n\t      cand=s;\n\t  }\n\t  else if(us.count(s)==0)\n\t    us.insert(s);\n\t}\n      }\n    }\n    if(cand.size()>1)cout<<cand<<endl;\n    else cout<<0<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <set>\nusing namespace std;\nstring mp[11];\nint w,h;\nset <string> cnt;\nstring ans;\nvoid check(int x,int y){\n  string str;\n  for(int i=-1;i<=1;i++)\n    for(int j=-1;j<=1;j++){\n      if(i==0 && j==0) continue;\n      str = mp[y][x];\n      int nx=(x+j+w)%w,ny=(y+i+h)%h;\n      while(ny!=y || nx!=x){\n\tstr+=mp[ny][nx],nx=(nx+j+w)%w,ny=(ny+i+h)%h;\n      if(cnt.count(str)){\n\tif(str.size()>ans.size()) ans = str;\n\telse if(str.size()==ans.size()) ans = min(str,ans);\n      }\n      else cnt.insert(str);\n      }\n    }\n}\n\nint main(){\n  while(1) {\n    cin >> h >> w;\n  if(w == 0 && h == 0) break;\n  for(int i=0;i<h;i++) cin >> mp[i];\n\n  ans = \"\";\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)check(j,i);\n  if(ans.size()==0) ans = \"0\";\n  cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define foreach(i,c) for(auto i=(c).begin();i!=(c).end();++i)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nint main()\n{\n\tfor(int h,w;cin>>h>>w,h|w;){\n\t\tvs d(h);\n\t\trep(i,h) cin>>d[i];\n\t\tmap<string,int> cnt;\n\t\tint di[]={-1,-1,-1,0,0,1,1,1},dj[]={-1,0,1,-1,1,-1,0,1};\n\t\trep(i0,h) rep(j0,w) rep(k,8){\n\t\t\tstring s;\n\t\t\tvvi vis(h,vi(w));\n\t\t\tfor(int i=i0,j=j0;!vis[i][j];i=(i+di[k]+h)%h,j=(j+dj[k]+w)%w){\n\t\t\t\ts+=d[i][j];\n\t\t\t\tvis[i][j]=1;\n\t\t\t\tcnt[s]++;\n\t\t\t}\n\t\t}\n\t\tstring res;\n\t\tfor(auto kv:cnt) if(kv.second>=2){\n\t\t\tstring s=kv.first;\n\t\t\tif(s.size()>res.size() || s.size()==res.size() && s<res)\n\t\t\t\tres=s;\n\t\t}\n\t\tcout<<(res.size()>=2?res:\"0\")<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define ll long long\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1316\n\nint h, w;\n\nint dy[8] = { -1, -1, -1, 0, 0, 1, 1, 1 };\nint dx[8] = { -1, 0, 1, -1, 1, -1, 0, 1 };\n\nset<string> Set;\nint Maxlen = 0;\nstring ans;\nvector<vector<char>> donut;\n\nvoid solve(int i, int j) {\n\tfor (int k = 0; k < 8;k++) {\n\t\tvector<vector<int>> usage(h, vector<int>(w, 0));\n\t\tstring ret = \"\";\n\t\tint y = i, x = j;\n\t\twhile (usage[y][x] == 0) {\n\t\t\tret += donut[y][x];\n\n\t\t\tif (Set.find(ret) != Set.end()) {\n\t\t\t\tif (ret.length() > Maxlen) {\n\t\t\t\t\tMaxlen = ret.length();\n\t\t\t\t\tans = ret;\n\t\t\t\t}\n\t\t\t\telse if (ret.length() == Maxlen && ret < ans) {\n\t\t\t\t\tans = ret;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSet.insert(ret);\n\t\t\t}\n\n\t\t\tusage[y][x] = 1;\n\t\t\ty = (y + dy[k] + h) % h;\n\t\t\tx = (x + dx[k] + w) % w;\n\n\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\twhile (cin >> h >> w) {\n\t\tif (h == 0 && w == 0)break;\n\t\tMaxlen = 0;\n\t\tans = \"\";\n\t\tdonut.resize(h, vector<char>(w));\n\t\tfor (int i = 0; i < h;i++) {\n\t\t\tfor (int j = 0; j < w;j++) {\n\t\t\t\tcin >> donut[i][j];\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < h;i++) {\n\t\t\tfor (int j = 0; j < w;j++) {\n\t\t\t\tsolve(i, j);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "// Header {{{\n// includes {{{\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <unistd.h>\n#include <vector>\n// }}}\nusing namespace std;\n// consts {{{\nstatic const int INF = 1e9;\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n// }}}\n// typedefs {{{\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<ULL> VULL;\ntypedef vector<VULL> VVULL;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef pair<int, int> PII;\ntypedef complex<int> P;\n// }}}\n// macros & inline functions {{{\n// syntax sugars {{{\n#define FOR(i, b, e) for (typeof(e) i = (b); i < (e); ++i)\n#define FORI(i, b, e) for (typeof(e) i = (b); i <= (e); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define REPI(i, n) FORI(i, 0, n)\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n// }}}\n// conversion {{{\ninline int toInt(string s) { int v; istringstream sin(s); sin>>v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout<<x; return sout.str(); }\n// }}}\n// array and STL {{{\n#define ARRSIZE(a) ( sizeof(a) / sizeof(a[0]) )\n#define ZERO(a, v) ( assert(v == 0 || v == -1), memset(a, v, sizeof(a)) )\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n#define SIZE(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c, it) for(typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define REACH(c, it) for(typeof((c).rbegin()) it=(c).rbegin(); it!=(c).rend(); ++it)\n#define EXIST(s, e) ((s).find(e) != (s).end())\n// }}}\n// bit manipulation {{{\n// singed integers are not for bitwise operations, specifically arithmetic shifts ('>>', and maybe not good for '<<' too)\n#define IS_UNSIGNED(n) (!numeric_limits<typeof(n)>::is_signed)\n#define BIT(n) (assert(IS_UNSIGNED(n)), assert(n < 64), (1ULL << (n)))\n#define BITOF(n, m) (assert(IS_UNSIGNED(n)), assert(m < 64), ((ULL)(n) >> (m) & 1))\ninline int BITS_COUNT(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int MSB(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c-1; }\ninline int MAKE_MASK(ULL upper, ULL lower) { assert(lower < 64 && upper < 64 && lower <= upper); return (BIT(upper) - 1) ^ (BIT(lower) - 1); }\n// }}}\n// for readable code {{{\n#define EVEN(n) (n % 2 == 0)\n#define ODD(n) (!EVEN(n))\n// }}}\n// debug {{{\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n#define dprt(fmt, ...) if (opt_debug) { fprintf(stderr, fmt, ##__VA_ARGS__); }\n#define darr(a) if (opt_debug) { copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define darr_range(a, f, t) if (opt_debug) { copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define dvec(v) if (opt_debug) { copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define darr2(a) if (opt_debug) { FOR(__i, 0, (arrsz(a))){ darr( (a)[__i] ); } }\n#define WAIT() if (opt_debug) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n#define dump(x) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl; }\n#define dumpl(x) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #x << endl << (x) << endl; }\n#define dumpf() if (opt_debug) { cerr << __PRETTY_FUNCTION__ << endl; }\n#define where() if (opt_debug) { cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl; }\n#define show_bits(b, s) if(opt_debug) { REP(i, s) { cerr << BITOF(b, s-1-i); if(i%4 == 3) cerr << ' '; } cerr << endl; }\n\n// ostreams {{{\n// complex\ntemplate<typename T> ostream& operator<<(ostream& s, const complex<T>& d) {return s << \"(\" << d.real() << \", \" << d.imag() << \")\";}\n\n// pair\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n\n// vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector<T>& d) {\n\tint len = d.size();\n\tREP (i, len) {\n\t\ts << d[i]; if (i < len - 1) s << \"\\t\";\n\t}\n\treturn s;\n}\n\n// 2 dimentional vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector< vector<T> >& d) {\n\tint len = d.size();\n\tREP (i, len) {\n\t\ts << d[i] << endl;\n\t}\n\treturn s;\n}\n\n// map\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const map<T1, T2>& m) {\n\ts << \"{\" << endl;\n\tfor (typeof(m.begin()) itr = m.begin(); itr != m.end(); ++itr) {\n\t\ts << \"\\t\" << (*itr).first << \" : \" << (*itr).second << endl;\n\t}\n\ts << \"}\" << endl;\n\treturn s;\n}\n// }}}\n// }}}\n// }}}\n// time {{{\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\n// }}}\n// string manipulation {{{\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\ninline string join(VS s, string j) { string t; REP(i, s.size()) { t += s[i] + j; } return t; }\n// }}}\n// geometry {{{\n#define Y real()\n#define X imag()\n// }}}\n// 2 dimentional array {{{\nP dydx4[4] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1) };\nP dydx8[8] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1), P(-1, 1), P(1, 1), P(1, -1), P(-1, -1) };\nint g_height, g_width;\nbool in_field(P p) {\n\treturn (0 <= p.Y && p.Y < g_height) && (0 <= p.X && p.X < g_width);\n}\n// }}}\n// input and output {{{\ninline void input(string filename) {\n\tfreopen(filename.c_str(), \"r\", stdin);\n}\ninline void output(string filename) {\n\tfreopen(filename.c_str(), \"w\", stdout);\n}\n// }}}\n// }}}\n\n// Header under development {{{\n\nint LCM(int a, int b) {\n\t// FIXME\n\treturn a * b;\n}\n\n// Fraction class {{{\n// ref: http://martin-thoma.com/fractions-in-cpp/\nclass Fraction {\n\tpublic:\n\t\tULL numerator;\n\t\tULL denominator;\n\t\tFraction(ULL _numerator, ULL _denominator) {\n\t\t\tassert(_denominator > 0);\n\t\t\tnumerator = _numerator;\n\t\t\tdenominator = _denominator;\n\t\t};\n\n\t\tFraction operator*(const ULL rhs) {\n\t\t\treturn Fraction(this->numerator * rhs, this->denominator);\n\t\t};\n\n\t\tFraction operator*(const Fraction& rhs) {\n\t\t\treturn Fraction(this->numerator * rhs.numerator, this->denominator * rhs.denominator);\n\t\t}\n\n\t\tFraction operator+(const Fraction& rhs) {\n\t\t\tULL lcm = LCM(this->denominator, rhs.denominator);\n\t\t\tULL numer_lhs = this->numerator * (this->denominator / lcm);\n\t\t\tULL numer_rhs = rhs.numerator * (rhs.numerator / lcm);\n\t\t\treturn Fraction(numer_lhs + numer_rhs, lcm);\n\t\t}\n\n\t\tFraction& operator+=(const Fraction& rhs) {\n\t\t\tFraction result = (*this) + rhs;\n\t\t\tthis->numerator = result.numerator;\n\t\t\tthis->denominator = result.denominator;\n\t\t\treturn *this;\n\t\t}\n};\n\nstd::ostream& operator<<(std::ostream &s, const Fraction &a) {\n\tif (a.denominator == 1) {\n\t\ts << a.numerator;\n\t} else {\n\t\ts << a.numerator << \"/\" << a.denominator;\n\t}\n\treturn s;\n}\n\n// }}}\n\n// }}}\n\nbool opt_debug = false;\n\nint main(int argc, char** argv) {\n\tstd::ios_base::sync_with_stdio(false);\n\t// set options {{{\n\tint __c;\n\twhile ( (__c = getopt(argc, argv, \"d\")) != -1 ) {\n\t\tswitch (__c) {\n\t\t\tcase 'd':\n\t\t\t\topt_debug = true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tabort();\n\t\t}\n\t}\n\t// }}}\n\n\t// input(\"./inputs/0.txt\");\n\t// output(\"./outputs/0.txt\");\n\n\tint h, w;\n\twhile (cin >> h >> w, h | w) {\n\t\tVVC field(h, VC(w, ' '));\n\t\tREP (i, h) {\n\t\t\tREP (j, w) {\n\t\t\t\tcin >> field[i][j];\n\t\t\t}\n\t\t}\n\n\t\tmap<string, int> m;\n\t\tREP (i, h) {\n\t\t\tREP (j, w) {\n\t\t\t\tP start(i, j);\n\t\t\t\tREP (d, 8) {\n\t\t\t\t\tstring s = \"\";\n\t\t\t\t\tP p(start.Y, start.X);\n\t\t\t\t\tdo {\n\t\t\t\t\t\ts += field[p.Y][p.X];\n\t\t\t\t\t\tif (!EXIST(m, s)) {\n\t\t\t\t\t\t\tm[s] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tm[s]++;\n\n\t\t\t\t\t\tp.Y = (p.Y + dydx8[d].Y + h) % h;\n\t\t\t\t\t\tp.X = (p.X + dydx8[d].X + w) % w;\n\t\t\t\t\t} while (p != start);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstring ans = \"\";\n\t\tEACH (m, itr) {\n\t\t\tstring s = (*itr).first;\n\t\t\tint c = (*itr).second;\n\t\t\tif (c > 1 && s.length() > 2 && s.length() > ans.length()) {\n\t\t\t\tans = s;\n\t\t\t}\n\t\t}\n\n\t\tif (ans == \"\") {\n\t\t\tcout << 0 << endl;\n\t\t} else {\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\n\nint dx[] = {-1,0,1,1,1,0,-1,-1};\nint dy[] = {1,1,1,0,-1,-1,-1,0};\n\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\nint H,W;\nstring donut[11];\nmap<string, int> res;\n\nvoid dfs(string str,int sy,int sx, int y,int x,int a) {\n    int ny = (y+dy[a]+H) % H;\n    int nx = (x+dx[a]+W) % W;\n    if(sy==ny && sx==nx) return;\n\n    res[str]++;\n    dfs(str+donut[ny][nx],sy,sx,ny,nx,a);\n}\n\nstring cmp(string s1,string s2) {\n    if(s1.size() > s2.size()) return  s1;\n    else if(s1.size() < s2.size()) return s2;\n    else return s1 < s2 ? s1 : s2;\n}\n\nvoid solve() {\n    res.clear();\n    rep(i,11) donut[i]=\"\";\n    rep(i,H) cin>>donut[i];\n    rep(y,H) rep(x,W) {\n        rep(a,8) {\n            string tmp;\n            tmp = donut[y][x];\n            dfs(tmp,y,x,y,x,a);\n        }\n    }\n    string ans;\n    for(const auto &it : res){\n        if(it.sc >= 2) {\n            ans = cmp(ans,it.fr);\n        }\n    }\n    if(ans.size() <= 2) ans = \"0\";\n    cout<<ans<<endl;\n}\n\nint main() {\n    while(cin>>H>>W) {\n        if(H+W==0) break;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint gcd(int a, int b){\n    while(a != b){\n        if(a > b) a = a - b; else b = b - a;\n    }\n    return a;\n}\n\nint lcm(int a, int b){\n    return ((a / gcd(a, b)) * b);\n}\n\nint main(){\n    int h, w;\n    while(true){\nchar torus[10][20];\n        string str[2048];\n        bool ok[2048];\n        int num = 0;\n\n        for(int i=0; i<2048; ++i){\n            str[i] = \"\";\n            ok[i] = true;\n        }\n\n        cin >> h >> w;\n        if(h==0 && w==0) break;\n\n        int cml = lcm(w, h);\n\n        for(int i=0; i<h; ++i){\n            for(int j=0; j<w; ++j){\n                cin >> torus[i][j];\n            }\n        }\n\n        //一番長い文字列をつくる\n\n        for(int y=0; y<h; ++y){\n            for(int x=0; x<w; ++x){\n                for(int i=0; i<h; ++i){\n                    str[num] += torus[(y+i)%h][x];\n                    str[num+1] += torus[h-(y+i)%h-1][x];\n                }\n                num += 2;\n            }\n        }\n        for(int y=0; y<h; ++y){\n            for(int x=0; x<w; ++x){\n                for(int i=0; i<w; ++i){\n                    str[num] += torus[y][(x+i)%w];\n                    str[num+1] += torus[y][w-(x+i)%w-1];\n                }\n                num += 2;\n            }\n        }\n        for(int y=0; y<h; ++y){\n            for(int x=0; x<w; ++x){\n                for(int i=0; i<cml; ++i){\n                    str[num] += torus[(y+i)%h][(x+i)%w];\n                    str[num+1] += torus[(y+i)%h][w-(x+i)%w-1];\n                    str[num+2] += torus[h-(y+i)%h-1][(x+i)%w];\n                    str[num+3] += torus[h-(y+i)%h-1][w-(x+i)%w-1];\n                }\n                num += 4;\n            }\n        }\n\n\n        string result = \"\";\n\n        sort(str, str+num);\n\n        for(int i=num-1; i>0; --i){\n            int length = 0;\n            string k = \"\";\n            for(int j=0; j<min(str[i].length(), str[i-1].length()); ++j){\n                if(str[i][j] == str[i-1][j]) k += str[i][j]; else break;\n            }\n            if(k.length() >= result.length()){\n                result = k;\n            }\n        }\n\n        cout << ((result.length() == 1) ? \"0\" : result) << endl;\n\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <bitset>\n#include <ctime>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <cassert>\n#include <cstddef>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <sstream>\n#include <fstream>\n\nusing namespace std;\n#define REP(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define FOR(i, a, b) for (int (i) = (a); (i) < (b); (i)++)\n#define RREP(i, a) for(int (i) = (a) - 1; (i) >= 0; (i)--)\n#define FORR(i, a, b) for(int (i) = (a) - 1; (i) >= (b); (i)--)\n#define DEBUG(C) cerr << #C << \" = \" << C << endl;\nusing LL = long long;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing VD = vector<double>;\nusing VVD = vector<VD>;\nusing PII = pair<int, int>;\nusing PDD = pair<double, double>;\nusing PLL = pair<LL, LL>;\nusing VPII = vector<PII>;\ntemplate<typename T> using VT = vector<T>;\n#define ALL(a) begin((a)), end((a))\n#define RALL(a) rbegin((a)), rend((a))\n#define SORT(a) sort(ALL((a)))\n#define RSORT(a) sort(RALL((a)))\n#define REVERSE(a) reverse(ALL((a)))\n#define MP make_pair\n#define FORE(a, b) for (auto &&a : (b))\n#define FIND(s, e) ((s).find(e) != (s).end())\n#define EB emplace_back\ntemplate<typename T> inline bool chmax(T &a, T b){if (a < b){a = b;return true;}return false;}\ntemplate<typename T> inline bool chmin(T &a, T b){if (a > b){a = b;return true;}return false;}\n\nconst int INF = 1e9;\nconst int MOD = INF + 7;\nconst LL LLINF = 1e18;\nconst double EPS = 1e-9;\n\nvoid init() {\n    \n}\n\nconst int dx[] = {0, 0, -1, -1, -1, 1, 1, 1};\nconst int dy[] = {1 ,-1, 1, 0, -1, 1, 0, -1};\nconst int MAX = 25;\nchar S[MAX][MAX];\nmap<string, int> cnt;\n\nvoid solve(int h, int w) {\n    for (int i = 0; i < h; i++) {\n        scanf(\"%s\", S[i]);\n    }\n    for (int i = 0; i < h; i++) {\n        for (int j = 0; j < w; j++) {\n            for (int d = 0; d < 8; d++) {\n                string buf = \"\";\n                set<pair<int, int>> se;\n                //assert(buf == \"\");\n                int ni = i, nj = j;\n                while (true) {\n                    if (se.count(make_pair(ni, nj))) break;\n                    se.insert(make_pair(ni, nj));\n                    buf += S[ni][nj];\n                    if (buf.size() > 1) cnt[buf]++;\n                    ni = (ni + dx[d] + h) % h;\n                    nj = (nj + dy[d] + w) % w;\n                }\n                //DEBUG(buf)\n                FORE(e, buf) assert(isupper(e));\n            }\n        }\n    }\n    string ans = \"\";\n    for (auto e : cnt) {\n        if (e.second > 1) {\n            if (ans.length() <= e.first.length()) {\n                if (ans.length() < e.first.length()) {\n                    ans = e.first;\n                } else if (ans > e.first) {\n                    ans = e.first;\n                }\n            }\n        }\n    }\n    if (ans == \"\") {\n        ans = \"0\";\n    }\n    printf(\"%s\\n\", ans.c_str());\n    cnt.clear();\n}\n\nsigned main(void) {\n    LL n, m, p, a, b, c, x, y, z, q;\n    string s;\n    bool f = false;\n    init();\n    while (cin >> n >> m, n) {\n        solve(n, m);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint gcd(int a, int b){\n    while(a != b){\n        if(a > b) a = a - b; else b = b - a;\n    }\n    return a;\n}\n\nint lcm(int a, int b){\n    return ((a / gcd(a, b)) * b);\n}\n\nint main(){\n    int h, w;\n    while(true){\nchar torus[10][20];\n        string str[2048];\n        bool ok[2048];\n        int num = 0;\n\n        for(int i=0; i<2048; ++i){\n            str[i] = \"\";\n            ok[i] = true;\n        }\n\n        cin >> h >> w;\n        if(h==0 && w==0) break;\n\n        int cml = lcm(w, h);\n\n        for(int i=0; i<h; ++i){\n            for(int j=0; j<w; ++j){\n                cin >> torus[i][j];\n            }\n        }\n\n        //一番長い文字列をつくる\n\n        for(int y=0; y<h; ++y){\n            for(int x=0; x<w; ++x){\n                for(int i=0; i<h; ++i){\n                    str[num] += torus[(y+i)%h][x];\n                    str[num+1] += torus[h-(y+i)%h-1][x];\n                }\n                num += 2;\n            }\n        }\n        for(int y=0; y<h; ++y){\n            for(int x=0; x<w; ++x){\n                for(int i=0; i<w; ++i){\n                    str[num] += torus[y][(x+i)%w];\n                    str[num+1] += torus[y][w-(x+i)%w-1];\n                }\n                num += 2;\n            }\n        }\n        for(int y=0; y<h; ++y){\n            for(int x=0; x<w; ++x){\n                for(int i=0; i<cml; ++i){\n                    str[num] += torus[(y+i)%h][(x+i)%w];\n                    str[num+1] += torus[(y+i)%h][w-(x+i)%w-1];\n                    str[num+2] += torus[h-(y+i)%h-1][(x+i)%w];\n                    str[num+3] += torus[h-(y+i)%h-1][w-(x+i)%w-1];\n                }\n                num += 4;\n            }\n        }\n\n\n        string result = \"\";\n\n        sort(str, str+num);\n\n        //徐々に削る\n        for(int i=0; i<cml; ++i){\n            for(int j=num-1; j>0; --j){\n                if(ok[j] && str[j].length() >= i && str[j-1].length() >= i){\n                    if(str[j].substr(0, i) == str[j-1].substr(0, i)){\n                        result = str[j];\n                        result.resize(i);\n                    }else{\n                        ok[j] = false;\n                    }\n                }\n            }\n        }\n\n        cout << ((result.length() == 0) ? \"0\" : result) << endl;\n\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long int dx[] = { 0,1,1,1,0,-1,-1,-1 };\nlong long int dy[] = { 1,1,0,-1,-1,-1,0,1 };\n\nint main()\n{\n\tlong long int M , N;\n\twhile(cin >> M >> N , M || N)\n\t{\n\t\tvector<vector<char>>D(M , vector<char>(N));\n\t\tset<string>SS;\n\t\tstring ans;\n\t\tfor(size_t i = 0; i < M; i++)\n\t\t{\n\t\t\tfor(size_t j = 0; j < N; j++)\n\t\t\t{\n\t\t\t\tcin >> D[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(long long int i = 0; i < M; i++)\n\t\t{\n\t\t\tfor(long long int j = 0; j < N; j++)\n\t\t\t{\n\t\t\t\tlong long int startx = j , starty = i;\n\t\t\t\tfor(long long int k = 0; k < 8; k++)\n\t\t\t\t{\n\t\t\t\t\tlong long int p = 1;\n\t\t\t\t\tstring s;\n\t\t\t\t\ts.push_back(D[starty][startx]);\n\t\t\t\t\twhile(!( ( startx + p*dx[k] + N * 2000 ) % N == startx && ( starty + p*dy[k] + M * 2000 ) % M == starty ))\n\t\t\t\t\t{\n\t\t\t\t\t\ts.push_back(D[( starty + p*dy[k] + M * 205 ) % M][( startx + p*dx[k] + N * 205 ) % N]);\n\t\t\t\t\t\tif(s.length() > ans.length())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(SS.find(s) != SS.end())\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tans = s;\n\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tSS.insert(s);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tp++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans.length<=1)\n\t\t{\n\t\t\tcout << 0 << endl;\n\t\t} else\n\t\t{\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <math.h>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <bitset>\n#include <complex>\n#include <unistd.h>\n#include <cassert>\n#include <cctype>\n#include <random>\n#define _USE_MATH_DEFINES\n#define _GLIBCXX_DEBUG\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> plglg;\ntypedef tuple<int, int, int> tiii;\ntypedef tuple<ll, ll, ll> tlglglg;\ntypedef complex<double> xy_t;\nint dx[8] = {1, 1, 0, -1, -1, -1, 0, 1};\nint dy[8] = {0, -1, -1, -1, 0, 1, 1, 1};\ndouble pi = 3.141592653589793;\nll mod = 1000000007;\nint intmax = 2147483647;\nint intmin = -2147483648;\nll llmax = 9223372036854775807;\nll llmin = -9223372036854775807;\nint iinf = intmax / 8;\nll inf = llmax / 8;\ndouble eps = 1e-11;\n\nstring s[30];\nstring str[2000];\nint n;\nbool bo[30][30];\n\nint main() {\n    while (1) {\n        int h, w;\n        cin >> h >> w;\n        if (h == 0) {\n            break;\n        }\n        for (int i = 0; i < h; i++) {\n            cin >> s[i];\n        }\n        int num = 0;\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                for (int k = 0; k < 8; k++) {\n                    for (int l = 0; l < h; l++) {\n                        fill(bo[l], bo[l] + w, false);\n                    }\n                    string ss = \"\";\n                    int x = i;\n                    int y = j;\n                    while (!bo[x][y]) {\n                        ss.push_back(s[x][y]);\n                        bo[x][y] = true;\n                        x = (x + h + dx[k]) % h;\n                        y = (y + w + dy[k]) % w;\n                    }\n                    str[num] = ss;\n                    num++;\n                }\n            }\n        }\n        n = h * w * 8;\n        // for (int i = 0; i < n; i++) {\n        //     cout << str[i] << endl;\n        // }\n        string ans = \"\";\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                string sa = str[i];\n                string sb = str[j];\n                int lena = sa.size();\n                int lenb = sb.size();\n                int numb = -1;\n                int len = min(lena, lenb);\n                for (int k = 0; k < len; k++) {\n                    if (sa[k] != sb[k]) {\n                        numb = k;\n                        break;\n                    }\n                }\n                if (numb == -1) {\n                    numb = len;\n                }\n                int anslen = ans.size();\n                if (numb > anslen) {\n                    ans = sa.substr(0, numb);\n                } else if (numb == anslen) {\n                    if (sa.substr(0, numb) < ans) {\n                        ans = sa.substr(0, numb);\n                    }\n                }\n            }\n        }\n        int anslenb = ans.size();\n        if (anslenb >= 2) {\n            cout << ans << endl;\n        } else {\n            cout << 0 << endl;\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-9;\nconst ll mod=1e9+7;\n//const int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\nconst int dx[8]={-1,0,1,0,-1,-1,1,1},dy[8]={0,-1,0,1,-1,1,-1,1};\n\nconst int N=16;\n\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\twhile(1){\n\t\tint h,w;\n\t\tcin>>h>>w;\n\t\tif(h==0) break;\n\t\tvs a(h);\n\t\tfor(auto &i:a) cin>>i;\n\t\tmap<string,int> mp;\n\t\tfor(int i=0;i<h;i++) for(int j=0;j<w;j++){\n\t\t\tfor(int k=0;k<8;k++){\n\t\t\t\tvvi b(h,vi(w));\n\t\t\t\tint x=i,y=j;\n\t\t\t\tstring s;\n\t\t\t\twhile(!b[x][y]){\n\t\t\t\t\tb[x][y]=1;\n\t\t\t\t\ts+=a[x][y];\n\t\t\t\t\tx+=dx[k],y+=dy[k];\n\t\t\t\t\tif(x>=h) x=0;\n\t\t\t\t\tif(x<0) x=h-1;\n\t\t\t\t\tif(y>=w) y=0;\n\t\t\t\t\tif(y<0) y=w-1;\n\t\t\t\t\tmp[s]++;\n\t\t\t\t}\n//\t\t\t\tcout<<i<<' '<<j<<' '<<k<<' '<<s<<endl;\n//\t\t\t\tmp[s]++;\n\t\t\t}\n\t\t}\n\t\tstring res=\"\";\n\t\tfor(auto p:mp) if(p.second>1&&p.first.size()>res.size()){\n\t\t\tres=p.first;\n\t\t}\n\t\tif(res.size()<=1) res=\"0\";\n\t\tcout<<res<<endl;\n//\t\tcout<<mp[\"ABRACADABRA\"]<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\nusing namespace std;\n\nint main()\n{\n    int dy[] = {-1, -1, 0, 1, 1, 1, 0, -1};\n    int dx[] = {0, 1, 1, 1, 0, -1, -1, -1};\n\n    for(;;){\n        int h, w;\n        cin >> h >> w;\n        if(h == 0)\n        return 0;\n\n        vector<string> grid(h);\n        for(int i=0; i<h; ++i)\n        cin >> grid[i];\n\n        set<string> ss;\n        string ret;\n        int maxLen = -1;\n        for(int y=0; y<h; ++y){\n            for(int x=0; x<w; ++x){\n                for(int d=0; d<8; ++d){\n                    int y1 = y;\n                    int x1 = x;\n                    string s;\n                    do{\n                        s += grid[y1][x1];\n                        y1 += dy[d] + h;\n                        x1 += dx[d] + w;\n                        y1 %= h;\n                        x1 %= w;\n                    }while(y1 != y || x1 != x);\n\n                    int n = s.size();\n                    while(n >= 2){\n                        string t = s.substr(0, n);\n                        if(ss.find(t) == ss.end()){\n                            ss.insert(t);\n                        }else{\n                            if(n > maxLen || (n == maxLen && t < ret)){\n                                maxLen = n;\n                                ret = t;\n                            }\n                            break;\n                        }\n                        -- n;\n                    }\n                }\n            }\n        }\n\n        if(maxLen == -1)\n        cout << 0 << endl;\n        else\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nint gcd(int a, int b){\n  if(b == 0)return a;\n  return gcd(b, a%b);\n}\n\nint lcm(int a, int b){\n  return a/gcd(a, b) * b;\n}\n\nint main(int argc, char *argv[]){\n  int w, h;\n  while(cin >> h >> w, h){\n    string torus[30];\n    string s[2222];\n    for (int i = 0; i < h; i++) {\n      cin >> torus[i];\n    }\n    int l = lcm(w, h);\n    int num = 0;\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        for (int k = 0; k < h; k++) {\n          s[num].push_back(torus[(h + i + k)%h][j]);\n          s[num + 1].push_back(torus[(h + i - k)%h][j]);\n        }\n        \n        for (int k = 0; k < w; k++) {\n          s[num + 2].push_back(torus[i][(w + j + k)%w]);\n          s[num + 3].push_back(torus[i][(w + j - k)%w]);\n        }\n        \n        for (int k = 0; k < l; k++) {\n          s[num + 4].push_back(torus[(l*h + i + k)%h][(l*w + j + k)%w]);\n          s[num + 5].push_back(torus[(l*h + i - k)%h][(l*w + j + k)%w]);\n          s[num + 6].push_back(torus[(l*h + i + k)%h][(l*w + j - k)%w]);\n          s[num + 7].push_back(torus[(l*h + i - k)%h][(l*w + j - k)%w]);\n        }\n        num += 8;\n      }\n    }\n    sort(s, s + 8*w*h);\n    string ans = \"\";\n    for (int i = 0; i < 8*w*h - 1; i++) {\n      int length = 0;\n      for (int j = 0;\n           j < min(s[i].length(), s[i + 1].length()); j++) {\n        if(s[i][length] == s[i + 1][length])length++;\n        else break;\n      }\n      if(length > ans.length())ans = s[i].substr(0,length);\n    }\n    if(ans.length() > 1)std::cout << ans << std::endl;\n    else std::cout << 0 << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<string>vec;\nchar c[20][20]; int H, W; bool used[20][20];\nint dx[8] = { 1,1,1,0,-1,-1,-1,0 };\nint dy[8] = { -1,0,1,1,1,0,-1,0 };\nint main() {\n\twhile (true) {\n\t\tcin >> H >> W; vec.clear(); if (H == 0)break;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++)cin >> c[i][j];\n\t\t}\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tfor (int k = 0; k < 8; k++) {\n\t\t\t\t\tfor (int l = 0; l < 400; l++)used[i / 20][i % 20] = 0;\n\t\t\t\t\tint cx = i, cy = j; string S; S += c[cx][cy]; used[cx][cy] = 1;\n\t\t\t\t\twhile (true) {\n\t\t\t\t\t\tcx += dx[k]; cy += dy[k];\n\t\t\t\t\t\tif (cx < 0)cx += H; if (cx >= H)cx -= H;\n\t\t\t\t\t\tif (cy < 0)cy += W; if (cy >= W)cy -= W;\n\t\t\t\t\t\tif (used[cx][cy] == 1)break;\n\t\t\t\t\t\tused[cx][cy] = 1; S += c[cx][cy]; vec.push_back(S);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(vec.begin(), vec.end()); string T = \"0\";\n\t\tfor (int i = 1; i < vec.size(); i++) {\n\t\t\tif (vec[i - 1] == vec[i]) {\n\t\t\t\tif (vec[i].size()>T.size())T = vec[i];\n\t\t\t\telse if (vec[i].size() == T.size())T = min(T, vec[i]);\n\t\t\t}\n\t\t}\n\t\tcout << T << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <set>\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nconst int dy[8] = {1,1,1,0,0,-1,-1,-1};\nconst int dx[8] = {-1,0,1,-1,1,-1,0,1};\n\nint h,w;\nstring str[10];\n\nvoid solve(){\n  int y, x, ansn = 0;\n  string ans = \"0\";\n  set<string> s;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      for(int k=0;k<8;k++){\n\tstring st;\n\tst += str[i][j];\n\ty = i;\n\tx = j;\n\twhile(1){\n\t  y = (y + h + dy[k]) % h;\n\t  x = (x + w + dx[k]) % w;\n\t  if(y == i && j == x) break;\n\t  else st += str[y][x];\n\t  if(!s.empty() && s.find(st) != s.end()){\n\t    if(ansn < st.size() || ansn == st.size() && ans > st){\n\t      ans = st;\n\t      ansn = st.size();\n\t    }\n\t  } else s.insert(st);\n\t}\n\n      }\n    }\n  }\n  cout << ans << endl;\n}\n\nint main(){\n  while(cin >> h >> w && (h|w)){\n    for(int i=0;i<h;i++){\n      cin >> str[i];\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define debug(x) cout << \"debug \" << x << endl;\nconst int INF = 100000000;\nusing namespace std;\n\nstring m[1000];\nstring ans;\nint h, w;\nmap<string, int> msi;\n\nstatic const int dy[8] = {0,-1,-1,-1,0,1,1,1};\nstatic const int dx[8] = {1,1,0,-1,-1,-1,0,1};\n\nstring big(string a, string b){\n    if(a.size() > b.size()) return a;\n    else if(a.size() < b.size()) return b;\n    else{\n        if(a < b) return a;\n        else return b;\n    }\n}\n\nvoid search(int y, int x){\n    rep(i,8){\n        string s;\n        int j = 0;\n        while(true){\n            s += m[y + dy[i] * j][x + dx[i] * j];\n            msi[s]++;\n            if(msi[s] == 2){\n                ans = big(ans, s);\n            }\n            j++;\n            if(dy[i] * j % h == 0 && dx[i] * j % w == 0) break;\n        }\n    }\n}\n\nint main(){\n    while(cin >> h >> w, h||w){\n        rep(i,1000) m[i] = \"\";\n        ans = \"\";\n        msi.clear();\n        rep(i,h){\n            string s;\n            cin >> s;\n            rep(j,50) rep(k,50) m[i + j * h]+=s;\n        }\n        for(int i = h * 25; i < h * 26; i++){\n            for(int j = w * 25; j < w * 26; j++){\n                search(i,j);\n            }\n        }\n        if(ans == \"\") cout << 0 << endl;\n        else cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n\n#include <tr1/unordered_map>\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n\n\nusing namespace std;\n\nchar d[20][30];\n\nint dx[8] = {-1, 0, 1,-1, 1,-1, 0, 1};\nint dy[8] = {-1,-1,-1, 0, 0, 1, 1, 1};\n\nint main(){\n  int h, w;\n\n  while(scanf(\"%d%d\", &h, &w), h + w){\n    tr1::unordered_map<string, int> m;\n\n    REP(i,h) scanf(\"%s\", d[i]);\n\n    REP(i,h) REP(j,w){\n      REP(k,8){\n        int x = j;\n        int y = i;\n        string tmp = \"\";\n\n        do{\n          tmp += d[y][x];\n          x = (x + w + dx[k]) % w;\n          y = (y + h + dy[k]) % h;\n          m[tmp]++;\n        }while(i != y || j != x);\n      }\n    }\n\n    string ans = \"\";\n\n    FOR(it, m) if(it->second > 1){\n      const string &s = it->first;\n\n      if(s.size() > ans.size()) ans = s;\n      else if(s.size() == ans.size() && s < ans) ans = s;\n    }\n\n    if(ans.size() > 1) puts(ans.c_str());\n    else puts(\"0\");\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <set>\nusing namespace std;\ntypedef unsigned long long ulli;\n\nconst int MAXH = 10;\nconst int MAXW = 20;\nconst ulli mod = 100000007ULL;\n\nint H, W;\nchar G[MAXH][MAXW];\nint cnt;\nint vis[MAXH][MAXW];\n\nint main() {\n  while(cin >> H >> W && (H|W)) {\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n        cin >> G[i][j];\n      }\n    }\n    string res = \"\";\n    set<ulli> t;\n    cnt = 0;\n    fill(vis[0], vis[MAXH], 0);\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n        for(int di = -1; di <= 1; ++di) {\n          for(int dj = -1; dj <= 1; ++dj) {\n            if(di|dj); else continue;\n            ++cnt;\n            string s(1, G[i][j]);\n            ulli h = G[i][j];\n            int ni, nj;\n            ni = i; nj = j;\n            vis[ni][nj] = cnt;\n\n            while(1) {\n              ni = (ni+di+H)%H;\n              nj = (nj+dj+W)%W;\n              if(vis[ni][nj] == cnt) break;\n              s += G[ni][nj];\n              h = h * mod + G[ni][nj];\n\n              vis[ni][nj] = cnt;\n              if(t.count(h)) {\n                if(s.size() > res.size() ||\n                   s.size() == res.size() && s < res) {\n                  res = s;\n                }\n              } else {\n                t.insert(h);\n              }\n            }\n          }\n        }\n      }\n    }\n    if(res == \"\") res = \"0\";\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <sstream>\n#include <algorithm>\n#include <tr1/unordered_map>\nusing namespace std;\n#define map tr1::unordered_map\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\nint H,W;\nchar MAP[20][20];\nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,-1,1,-1,1};\n \nbool input(){\n    cin>>H>>W;\n    if(H==0&&W==0)return false;\n    REP(y,H){\n        string t;\n        cin>>t;\n        REP(x,W){\n            MAP[x][y]=t[x];\n        }\n    }\n    return true;\n}\nmap<string,int> res;\nvoid solve(int x,int y,int d){\n    string s;\n    int nx=x,ny=y;\n    do{\n        s.push_back(MAP[nx][ny]);\n        if(x==nx&&y==ny&&d==0)res[s]++;\n        else if(x!=nx||y!=ny)res[s]++;\n        nx=nx+dx[d]+W;\n        ny=ny+dy[d]+H;\n        nx%=W;\n        ny%=H;\n    }while((nx!=x||ny!=y));\n}\nint main() {\n    while(input()){\n        res.clear();\n        REP(x,W){\n            REP(y,H){\n                REP(k,8){\n                    solve(x,y,k);\n                }\n            }\n        }\n        string ans=\"\";\n \n        FOR(it,res){\n            if(it->first.size()==1)continue;\n            if(it->second>1){\n                string r=it->first;\n                if(r.size()>ans.size()){\n                    ans=r;\n                }else if(r.size()==ans.size()){\n                    ans=min(ans,r);\n                }\n            }\n        }\n        if(ans==\"\")ans=\"0\";\n        cout<<ans<<endl;\n    }\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <iterator>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef vector<PII> VPII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define FOR( v, c ) for ( auto &v : c )\n#define EACH( it, c ) for ( auto it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n#define DRANGE( c, p ) (c).begin(), (c).begin() + p, (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\tfor ( int h, w; cin >> h >> w, h | w; )\n\t{\n\t\tVS board( h );\n\t\tFOR( line, board )\n\t\t{\n\t\t\tcin >> line;\n\t\t}\n\n\t\tmap<string,int> counts;\n\t\tREP( i, 0, h )\n\t\t{\n\t\t\tREP( j, 0, w )\n\t\t\t{\n\t\t\t\tREP( dy, -1, 2 )\n\t\t\t\t{\n\t\t\t\t\tREP( dx, -1, 2 )\n\t\t\t\t\t{\n\t\t\t\t\t\tint y = i, x = j;\n\t\t\t\t\t\tstring cur;\n\t\t\t\t\t\tVVI visited( h, VI( w ) );\n\n\t\t\t\t\t\tdo\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcur += board[y][x];\n\t\t\t\t\t\t\tcounts[ cur ] ++;\n\n\t\t\t\t\t\t\tvisited[y][x] = 1;\n\t\t\t\t\t\t\t( y += dy + h ) %= h;\n\t\t\t\t\t\t\t( x += dx + w ) %= w;\n\t\t\t\t\t\t}\n\t\t\t\t\t\twhile ( !visited[y][x] );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstring res;\n\t\tFOR( it, counts )\n\t\t{\n\t\t\tif ( it.snd < 2 )\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ( res.size() < it.fst.size() )\n\t\t\t{\n\t\t\t\tres = it.fst;\n\t\t\t}\n\t\t\telse if ( res.size() == it.fst.size() )\n\t\t\t{\n\t\t\t\tres = min( res, it.fst );\n\t\t\t}\n\t\t}\n\n\t\tcout << ( 2 <= res.size() ? res : \"0\" ) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <map>\n#include <set>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <bitset>\nusing namespace std;\n#define INF\t100000000\n#define MOD 1000000007\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define sec second\n#define lb lower_bound\n#define ub upper_bound\n#define SS stringstream\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define SORT(x) sort((x).begin(), (x).end())\n#define clr(a,b) memset((a),(b),sizeof(a))\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef vector<int> Vi;\ntypedef vector<ll> Vll;\ntypedef vector<P> Vp;\ntypedef priority_queue<P, vector<P>, greater<P> > PQ;\n\nint dx[8] = {1,1,1,-1,-1,-1,0,0}, dy[8] = {1,0,-1,1,0,-1,1,-1};\n\nint main(){\n\tint h, w;\n\twhile(scanf(\"%d%d\", &h, &w),h||w){\n\t\tvector<string> d(h);\n\t\tmap<int,map<string,int> > m;\n\t\trep(i,h) cin >> d[i];\n\t\trep(i,h) rep(j,w){\n\t\t\trep(k,8){\n\t\t\t\tint y = i, x = j;\n\t\t\t\tstring str;\n\t\t\t\tstr.pb(d[y][x]);\n\t\t\t\twhile(true){\n\t\t\t\t\ty += dy[k];\n\t\t\t\t\tx += dx[k];\n\t\t\t\t\tif(y < 0) y = h+y;\n\t\t\t\t\tif(y >= h) y = y-h;\n\t\t\t\t\tif(x < 0) x = w+x;\n\t\t\t\t\tif(x >= w) x = x-w;\n\t\t\t\t\tif(y == i && x == j) break;\n\t\t\t\t\tstr.pb(d[y][x]);\n\t\t\t\t\tm[-1*str.size()][str]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmap<int,map<string,int> >::iterator ite;\n\t\tbool ok = false;\n\t\tfor(ite = m.begin(); ite != m.end(); ite++){\n\t\t\tmap<string,int> tmp = ite->sec;\n\t\t\tmap<string,int>::iterator it;\n\t\t\tfor(it = tmp.begin(); it != tmp.end(); it++){\n\t\t\t\tif(it->sec >= 2){\n\t\t\t\t\tcout << it->fi << endl;\n\t\t\t\t\tok = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok) break;\n\t\t}\n\t\tif(!ok) cout << \"0\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\n#define x first\n#define y second\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nint dx[] = { 1, 1, 0,-1,-1,-1, 0, 1};\nint dy[] = { 0, 1, 1, 1, 0,-1,-1,-1};\n\nint main(void){\n    for(int w, h; cin >> h >> w, h;){\n        vs strs(h);\n        rep(y, h){\n            cin >> strs[y];\n        }\n\n        set<string> s;\n        string res = \"0\";\n        rep(y, h){\n            rep(x, w){\n                rep(i, 8){\n                    string cur;\n                    pii next = mp(x, y);\n\n                    do{\n                        cur.pb(strs[next.y][next.x]);\n                        if(1 < cur.size() && !s.insert(cur).second)\n                        {\n                            if((res.size() < cur.size()) || \n                               (res.size() == cur.size() && cur < res)){\n                                res = cur;\n                            }\n                        }\n\n                        next.x = (next.x + dx[i] + w) % w;\n                        next.y = (next.y + dy[i] + h) % h;\n                        debug(cur);\n                        \n                    } while(next != mp(x, y));\n                }\n            }\n        }\n\n        cout << res << endl;\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\n#include <map>\nusing namespace std;\n\nstring b[10];\nint dx[8] = { 1, 0, -1, 0, 1, 1, -1, -1 };\nint dy[8] = { 0, 1, 0, -1, 1, -1, 1, -1 };\nbool visit[10][20];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint h, w;\n\twhile(cin >> h >> w, h | w) {\n\t\tfor(int i = 0; i < h; i++) {\n\t\t\tcin >> b[i];\n\t\t}\n\n\t\tmap<string, int> m;\n\n\t\tfor(int y = 0; y < h; y++) {\n\t\t\tfor(int x = 0; x < w; x++) {\n\t\t\t\tfor(int k = 0; k < 8; k++) {\n\t\t\t\t\tint ny = y, nx = x;\n\t\t\t\t\tmemset(visit, 0, sizeof visit);\n\t\t\t\t\tstring s;\n\t\t\t\t\twhile(!visit[ny][nx]) {\n\t\t\t\t\t\tvisit[ny][nx] = true;\n\t\t\t\t\t\ts += b[ny][nx];\n\t\t\t\t\t\tm[s]++;\n\t\t\t\t\t\tny = (ny + dy[k] + h) % h;\n\t\t\t\t\t\tnx = (nx + dx[k] + w) % w;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstring ans;\n\t\tfor(auto p : m) {\n\t\t\tif(p.second <= 1 || p.first.size() <= 1) continue;\n\t\t\tstring s = p.first;\n\t\t\tif(ans.size() < s.size() || ans.size() == s.size() && ans > s) {\n\t\t\t\tans = s;\n\t\t\t}\n\t\t}\n\t\tif(ans == \"\") ans = \"0\";\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define INF (1<<29)\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> pi;\ntypedef pair<string, pi> P;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint H,W;\nint dy[]={-1,-1,-1,0,1,1,1,0}, dx[]={-1,0,1,1,1,0,-1,-1};\nchar pat[16][32];\nint vis[16][32];\n\n\nstring solve(){\n  string res = \"0\";\n  set<string>s;\n\n  rep(i,H) rep(j,W){\n    int sy=i,sx=j;\n    rep(d,8){\n      int ny=i,nx=j;\n      string str=\"\";\n      str += pat[ny][nx];\n      while(1){\n\tny=(ny+dy[d]+H)%H, nx=(nx+dx[d]+W)%W;\n\tif(ny==sy&&nx==sx) break;\n\tstr += pat[ny][nx];\n\tif(s.find(str) == s.end()){\n\t  s.insert(str);\n\t}else{\n\t  if(res.size() < str.size()) res = str;\n\t  else if(res.size() == str.size() && res > str) res = str;\n\t}\n      }\n    }\n  }\n\n  return res;\n}\n\nint main(){\n  while(cin >> H >> W && H && W){\n    rep(i,H) cin >> pat[i];\n    cout << solve() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0 ; i < n ; i++)\n\nconst int dx[] = {0, 0, 1, -1, 1, 1, -1, -1};\nconst int dy[] = {1, -1, 0, 0, 1, -1, 1, -1};\n\nint H, W;\nmap<string, int> past;\nchar field[12][22];\n\nvoid solve(int x, int y){\n  rep(i, 8){\n    bool used[12][22];\n    string s = \"\";\n    memset(used, 0, sizeof(used));\n    used[y][x] = true;\n    s += field[y][x];\n    int nx = x+dx[i], ny = y+dy[i];\n    if(nx < 0) nx = W-1;\n    else if(nx >= W) nx = 0;\n    if(ny < 0) ny = H-1;\n    else if(ny >= H) ny = 0;\n   while(true){\n      if(used[ny][nx]) break;\n      used[ny][nx] = true;\n      s += field[ny][nx];\n      nx += dx[i], ny += dy[i];\n      if(nx < 0) nx = W-1;\n      else if(nx >= W) nx = 0;\n      if(ny < 0) ny = H-1;\n      else if(ny >= H) ny = 0;\n      if(s.size() >= 2) past[s]++;\n      //if(s == \"MF\") cout << \"x = \" << x << \", y = \" << y << endl;\n    }\n  }\n}\n\nvoid init(){\n  past.clear();\n}  \n\nint main(){\n  while(cin >> H >> W, H|W){\n    init();\n    rep(i, H){\n      cin >> field[i];\n    }\n    rep(i, H){\n      rep(j, W){\n\tsolve(j, i);\n      }\n    }\n    \n    int L = 0;\n    string ans = \"\";\n    \n    for(map<string, int>::iterator it = past.begin() ; it != past.end() ; it++){\n      if(it->second < 2 ) continue;\n      string tmp = it->first;\n      //cout << tmp << endl;\n      if(tmp.size() > L){\n\tL = tmp.size();\n\tans = tmp;\n      }\n      else if(tmp.size() == L){\n\tif(ans > tmp){\n\t  ans = tmp;\n\t}\n      }\n    }\n    if(ans.size() == 0) cout << \"0\" << endl;\n    else cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define o(a) cout << a << endl\n#define int long long\n#define first fi\n#define second se\nusing namespace std;\ntypedef pair<int, int> P;\n\nint dy[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nint dx[8] = {1, 0, -1, 1, -1, 1, -1, 0};\n\nsigned main(){\n    int h, w;\n    while(1){\n        cin >> h >> w;\n        if(h + w == 0) break;\n        string s[11];\n        rep(i, 0, h) cin >> s[i];\n        string ans = \"\";\n        set<string> st;\n        rep(i, 0, h){\n            rep(j, 0, w){\n                rep(k, 0, 8){\n                    int y = i;\n                    int x = j;\n                    string now = \"\";\n                    now += s[i][j];                    \n                    for(int l = 1;; l++){\n                        y = (y + dy[k] + h) % h;\n                        x = (x + dx[k] + w) % w;\n                        if(y == i && x == j) break;\n                        now += s[y][x];\n                        if(!st.count(now)) st.insert(now);\n                        else{\n                            if(ans.size() == now.size()){\n                                if(ans > now) ans = now;\n                            }else if(ans.size() < now.size()){\n                                ans = now;\n                            }\n                        }\n                    }\n                    // cout << i << \" \" << j << \" \" << k << \" \" << now << endl;\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<cstring>\nusing namespace std;\n\nbool used[10][20];\n\nint main(){\n    int h, w;\n    while(cin >> h >> w, h+w){\n        char mat[h][w];\n        for(int i = 0; i < h; i++)  for(int j = 0; j < w; j++)  cin >> mat[i][j];\n        map<string,int> cnt;\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                for(int di = -1; di <= 1; di++){\n                    for(int dj = -1; dj <= 1; dj++){\n                        if(di == 0 && dj == 0)  continue;\n                        memset(used, 0, sizeof(used));\n                        string acc = \"\";\n                        int si = i, sj = j;\n                        while(!used[si][sj]){\n                            acc += mat[si][sj];\n                            cnt[acc]++;\n                            used[si][sj] = true;\n                            si += di, sj += dj;\n                            si = (si + h) % h;\n                            sj = (sj + w) % w;\n                        }\n                    }\n                }\n            }\n        }\n        string ans = \"0\";\n        for(pair<string,int> p : cnt){\n            if(p.second > 1 && p.first.length() > ans.length()) ans = p.first;\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <vector>\nusing namespace std;\n\nconst int MAX_H = 11;\nconst int MAX_W = 21;\n\nmap<string, int> M;\nvector<string> V;\nint H, W;\nchar G[MAX_H][MAX_W];\n\nbool compare(const string &a, const string &b) {\n  if(a.size() != b.size()) return a.size() > b.size();\n  return a < b;\n}\n\nstring solve() {\n  V.clear();\n  M.clear();\n  for(int i = 0; i < H; ++i) {\n    for(int j = 0; j < W; ++j) {\n      for(int dx = -1; dx <= 1; ++dx) {\n\tfor(int dy = -1; dy <= 1; ++dy) {\n\t  if(dx == 0 && dy == 0) continue;\n\t  int x = j;\n\t  int y = i;\n\t  string s = \"\";\n\t  do {\n\t    s += G[y][x];\n\t    if(s.size() >= 2 && ++M[s] == 2) {\n\t      V.push_back(s);\n\t    }\n\t    x = (x+dx+W)%W;\n\t    y = (y+dy+H)%H;\n\t  } while(!(x == j && y == i));\n\t}\n      }\n    }\n  }\n  if(V.size() == 0) return \"0\";\n  sort(V.begin(), V.end(), compare);\n  return V[0];\n}\n\nint main() {\n  while(cin >> H >> W && (H | W)) {\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n\tcin >> G[i][j];\n      }\n    }\n    cout << solve() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define pi M_PI\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint mod(int x, int y){\n    return x % y + (x < 0 ? y : 0);\n}\n\nint main() {\n    int w, h;\n    int dx[] = {1,1,1,0,0,0,-1,-1,-1}, dy[] = {1,0,-1,1,0,-1,1,0,-1};\n    while (cin >> h >> w && w){\n        vector<string> s(h);\n        REP(i,h) cin >> s[i];\n\n        map<string, int> mp;\n        string ans;\n        REP(si,h) REP(sj,w) REP(k,9){\n            string res;\n            res += s[si][sj];\n            for (int i=mod(si+dx[k],h), j=mod(sj+dy[k],w); i!=si || j!=sj; i=mod(i+dx[k],h), j=mod(j+dy[k],w)){\n                res += s[i][j];\n                if (mp[res]){\n                    if (res.length() > ans.length() || (res.length() == ans.length() && res < ans))\n                        ans = res;\n                }\n                mp[res] = 1;\n            }\n        }\n        if (ans.length() <= 1) cout << 0 << endl;\n        else cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nconstexpr ld EPS = 1e-12;\nconstexpr int INF = numeric_limits<int>::max() / 2;\nconstexpr int MOD = 1e9 + 7;\n\nint dx[8] = {1, 1, 1, 0, -1, -1, -1, 0}, dy[8] = {1, 0, -1, -1, -1, 0, 1, 1};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int h, w;\n    while (cin >> h >> w, h || w)\n    {\n        vector<string> v(h + 1);\n        for (int i = 1; i <= h; i++)\n        {\n            cin >> v[i];\n            v[i] = '$' + v[i];\n        }\n        vector<vector<P>> next(h + 2, vector<P>(w + 2));\n        for (int i = 0; i <= h + 1; i++)\n        {\n            for (int j = 0; j <= w + 1; j++)\n            {\n                P p;\n                if (i == 0)\n                {\n                    if (j == 0)\n                        p = P(h, w);\n                    else if (j == w + 1)\n                        p = P(h, 1);\n                    else\n                        p = P(h, j);\n                }\n                else if (i == h + 1)\n                {\n                    if (j == 0)\n                        p = P(1, w);\n                    else if (j == w + 1)\n                        p = P(1, 1);\n                    else\n                        p = P(1, j);\n                }\n                else if (j == 0)\n                {\n                    p = P(i, w);\n                }\n                else if (j == w + 1)\n                {\n                    p = P(i, 1);\n                }\n                else\n                {\n                    p = P(i, j);\n                }\n                next[i][j] = p;\n            }\n        }\n        map<string, int> mp;\n        vector<vector<bool>> used(h + 1, vector<bool>(w + 1, false));\n        for (int i = 1; i <= h; i++)\n        {\n            for (int j = 1; j <= w; j++)\n            {\n                for (int k = 0; k < 8; k++)\n                {\n                    for (int p = 1; p <= h; p++)\n                        for (int q = 1; q <= w; q++)\n                            used[p][q] = false;\n                    string tmp = \"\";\n                    int x = i, y = j;\n                    while (!used[x][y])\n                    {\n                        used[x][y] = true;\n                        tmp += v[x][y];\n                        if(tmp.length()>=2) mp[tmp]++;\n                        x += dx[k];\n                        y += dy[k];\n                        P p = next[x][y];\n                        x = p.first;\n                        y = p.second;\n                    }\n                }\n            }\n        }\n        string res = \"\";\n        for (auto v : mp)\n        {\n            if (v.second < 2)\n                continue;\n            if (v.first.length() < res.length())\n                continue;\n            if (res.length() == v.first.length())\n                res = min(res, v.first);\n            else\n                res = v.first;\n        }\n        if (res.length() < 2)\n            cout << 0 << endl;\n        else\n            cout << res << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\nusing namespace std;\n\nint gcd(int a, int b){\n  if(b == 0)return a;\n  return gcd(b, a%b);\n}\n\nint lcm(int a, int b){\n  return a/gcd(a, b) * b;\n}\n\nint main(int argc, char *argv[]){\n  int w, h;\n  while(cin >> h >> w, h){\n    string torus[30];\n    string s[2222];\n    for (int i = 0; i < h; i++) {\n      cin >> torus[i];\n    }\n    int l = lcm(w, h);\n    int num = 0;\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        for (int k = 0; k < h; k++) {\n          s[num].push_back(torus[(h + i + k)%h][j]);\n          s[num + 1].push_back(torus[(h + i - k)%h][j]);\n        }\n        \n        for (int k = 0; k < w; k++) {\n          s[num + 2].push_back(torus[i][(w + j + k)%w]);\n          s[num + 3].push_back(torus[i][(w + j - k)%w]);\n        }\n        \n        for (int k = 0; k < l; k++) {\n          s[num + 4].push_back(torus[(l*h + i + k)%h][(l*w + j + k)%w]);\n          s[num + 5].push_back(torus[(l*h + i - k)%h][(l*w + j + k)%w]);\n          s[num + 6].push_back(torus[(l*h + i + k)%h][(l*w + j - k)%w]);\n          s[num + 7].push_back(torus[(l*h + i - k)%h][(l*w + j - k)%w]);\n        }\n        num += 8;\n      }\n    }\n    sort(s, s + 8*w*h);\n    string ans = s[0];\n    for (int i = 0; i < 8*w*h - 1; i++) {\n      int length = 0;\n      for (int j = 0;\n           j < min(s[i].length(), s[i + 1].length()) - 1; j++) {\n        if(s[i][length] == s[i + 1][length])length++;\n        else break;\n      }\n      if(length > ans.length())ans = s[i].substr(0,length);\n    }\n    if(ans.length() > 1)std::cout << ans << std::endl;\n    else std::cout << 0 << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid dicch(vector<string> d){\n    vector<map<string,int>> lis(1);\n    vector<string> ans;\n    map<string, int> mp;\n    lis.push_back(mp);\n    int maxl=1,leng=1;\n    for(string x:d){\n        if(x.size()>=maxl){\n            if(x.size()>leng){\n                leng=x.size();\n                lis.resize(leng);\n                map<string,int> tmp;\n                tmp[x]=1;\n                lis.push_back(tmp);\n            }\n            else{\n                if( lis[x.size()-1].find(x)!=lis[x.size()-1].end() ){\n                    if(x.size()>maxl){\n                        ans.clear();\n                        maxl=x.size();\n                    }\n                    ans.push_back(x);\n                }\n                else{\n                    lis[x.size()-1][x]=1;\n                }\n            }\n        }\n    }\n    sort(ans.begin(),ans.end());\n    cout << ((ans.empty())?\"0\":*ans.begin())<<endl;\n}\n\nvoid dicmk(vector<string> d){\n    vector<string> pass;\n    for(string x:d){\n        string xx=x+x;\n        for(int i=2;i<=x.size();i++){\n            for(int j=0;j<x.size();j++){\n                string str=xx.substr(j,i);\n                pass.push_back(str);\n            }\n        }\n    }\n    dicch(pass);\n}\n\n\nvoid check(vector<vector<char>> d,int h,int w){\n    vector<string> dic;\n    int x,y;\n    for(int i=0;i<w;i++){\n        string str;\n        for(int j=0;j<h;j++){\n            str.push_back(d[j][i]);\n        }\n        dic.push_back(str);\n    }\n    for(int i=0;i<h;i++){\n        string str;\n        for(int j=0;j<w;j++){\n            str.push_back(d[i][j]);\n        }\n        dic.push_back(str);\n    }\n    vector<bool> s1(w,true);\n    for(int i=0;i<w;i++){\n        if(s1[i]){\n            string str;\n            x=i;\n            y=0;\n            str.push_back(d[y][x]);\n            x+=1;x=(x+w)%w;\n            y+=1;y=(y+h)%h;\n            while(!(x==i&&y==0)){\n                if(y==0){\n                    s1[x]=false;\n                }\n                str.push_back(d[y][x]);\n                x+=1;x=(x+w)%w;\n                y+=1;y=(y+h)%h;\n            }\n            dic.push_back(str);\n        }\n    }\n    vector<bool> s2(w,true);\n    for(int i=0;i<w;i++){\n        if(s2[i]){\n            string str;\n            x=i;\n            y=0;\n            str.push_back(d[y][x]);\n            x-=1;x=(x+w)%w;\n            y+=1;y=(y+h)%h;\n            while(!(x==i&&y==0)){\n                if(!y){\n                    s2[x]=false;\n                }\n                str.push_back(d[y][x]);\n                x-=1;x=(x+w)%w;\n                y+=1;y=(y+h)%h;\n            }\n            dic.push_back(str);\n        }\n    }\n    int siz=dic.size();\n    for(int i=0;i<siz;i++){\n        string rev=dic[i];\n        reverse(rev.begin(), rev.end());\n        dic.push_back(rev);\n    }\n    dicmk(dic);\n}\n\nvoid slove(int h,int w){\n    vector<vector<char>> d; \n    char t;\n    for(int i=0;i<h;i++){\n        vector<char> tmp;\n        for(int j=0;j<w;j++){\n            cin >> t;\n            tmp.push_back(t);\n        }\n        d.push_back(tmp);\n    }\n    check(d,h,w);\n}\n\n\nint main(void){\n    int h,w;\n    while(cin>>h>>w,h){\n        slove(h,w);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nconst int dy[] = {0, 1, 0, -1, 1, 1, -1, -1}, dx[] = {-1, 0, 1, 0, 1, -1, 1, -1};\nint h, w;\nstring s[10];\n\nint main(){\n\twhile(cin >> h >> w, h){;\n\t\trep(i, h) cin >> s[i];\n\t\tmap<string, int> cnt;\n\t\trep(i, h) rep(j, w) rep(d, 8){\n\t\t\t\n\t\t\tint y = i, x = j;\n\t\t\tstring t;\n\t\t\tdo{\n\t\t\t\tt += s[y][x];\n\t\t\t\tif(t.size() > 1) cnt[t]++;\n\t\t\t\ty = (y + dy[d] + h) % h;\n\t\t\t\tx = (x + dx[d] + w) % w;\n\t\t\t}while(y != i || x != j);\n\t\t}\n\t\tstring ans;\n\t\teach(i, cnt) if(i->second > 1){\n\t\t\tif(ans.size() < i->first.size()) ans = i->first;\n\t\t}\n\t\tcout << (ans == \"\" ? \"0\" : ans) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define o(a) cout << a << endl\n#define int long long\n#define first fi\n#define second se\nusing namespace std;\ntypedef pair<int, int> P;\n\nint dy[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nint dx[8] = {1, 0, -1, 1, -1, 1, -1, 0};\n\nsigned main(){\n    int h, w;\n    while(1){\n        cin >> h >> w;\n        if(h + w == 0) break;\n        string s[11];\n        rep(i, 0, h) cin >> s[i];\n        string ans = \"\";\n        set<string> st;\n        rep(i, 0, h){\n            rep(j, 0, w){\n                rep(k, 0, 8){\n                    int y = i;\n                    int x = j;\n                    string now = \"\";\n                    now += s[i][j];                    \n                    for(int l = 1;; l++){\n                        y = (y + dy[k] + h) % h;\n                        x = (x + dx[k] + w) % w;\n                        if(y == i && x == j) break;\n                        now += s[y][x];\n                        if(!st.count(now)) st.insert(now);\n                        else{\n                            if(ans.size() == now.size()){\n                                if(ans > now) ans = now;\n                            }else if(ans.size() < now.size()){\n                                ans = now;\n                            }\n                        }\n                    }\n                    // cout << i << \" \" << j << \" \" << k << \" \" << now << endl;\n                }\n            }\n        }\n        if(ans == \"\") cout << \"0\" << endl;\n        else cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"cstring\"\n#include \"cstdio\"\nusing namespace std;\nconst int N = 320010;\nconst int CH = 26;\nint dx[8] = {0, 0, 1, 1, 1, -1, -1, -1};\nint dy[8] = {1, -1, 0, 1, -1, 0, 1, -1};\nchar s[30][30];\nint trie[N][CH], word[N];\nint sz = 0;\nint n, m, ans, ax, ay, ap, al;\nvoid gao(int &x, int &y)\n{\n\tif(x < 0) x += n;\n\tif(y < 0) y += m;\n\tif(x >= n) x -= n;\n\tif(y >= m) y -= m;\n}\nbool judge(int x, int y, int p, int len)\n{\n\tint sx1 = ax, sy1 = ay, sp1 = p;\n\tint sx2 = x, sy2 = y, sp2 = p;\n\tfor(int i = 0; i < len; ++ i){\n\t\tif(s[sx1][sy1] > s[sx2][sy2]){\n\t\t\treturn true;\n\t\t}else if(s[sx1][sy1] < s[sx2][sy2]){\n\t\t\treturn false;\n\t\t}\n\t\tsx1 += dx[sp1];sy1 += dy[sp1];\n\t\tsx2 += dx[sp2];sy2 += dy[sp2];\n\t\tgao(sx1, sy1);\n\t\tgao(sx2, sy2);\n\t}\n\treturn false;\n}\nvoid insert(int sx, int sy, int p)\n{\n\tint r = 0;\t\n\tint x = sx, y = sy;\n\tint length = 0;\n\twhile(1){\n\t\tlength ++;\n\t\tint idx = s[x][y] - 'A';\n\t\tif(!trie[r][idx]){\n\t\t\ttrie[r][idx] = ++ sz;\n\t\t\tfor(int j = 0; j < CH; ++ j){\n\t\t\t\ttrie[sz][j] = 0;\n\t\t\t}\n\t\t\tword[sz] = 0;\n\t\t}\t\t\n\t\tr = trie[r][idx];\n\t\tif(word[r] > 0){\n\t\t\tif(ans < length){\n\t\t\t\tans = length;\n\t\t\t\tax = sx, ay = sy, ap = p, al = length;\n\t\t\t}else if(ans == length){\n\t\t\t\tif(judge(sx, sy, p, length)){\n\t\t\t\t\tans = length;\n\t\t\t\t\tax = sx, ay = sy, ap = p, al = length;\n\t\t\t\t}\t\t\t\n\t\t\t}\n\t\t}\n\t\tword[r] ++;\n\t\tx = x + dx[p];\n\t\ty = y + dy[p];\n\t\tgao(x, y);\n\t\tif(x == sx && y == sy) break;\n\t}\n}\t\nvoid Init()\n{\n\tsz = 0;\n\tmemset(trie[0], 0, sizeof(trie[0]));\n}\nvoid print()\n{\n\tint x = ax, y = ay, p = ap;\n\tfor(int i = 0 ; i < al; ++ i){\n\t\tprintf(\"%c\",s[x][y]);\n\t\tx = x + dx[p];\n\t\ty = y + dy[p];\n\t\tgao(x, y);\n\t}\n\tprintf(\"\\n\");\n}\nint main(void)\n{\n\twhile(scanf(\"%d%d\",&n,&m) && (n || m)){\n\t\tfor(int i = 0; i < n ; ++ i){\n\t\t\tscanf(\"%s\", s[i]);\n\t\t}\n\t\tInit();\n\t\tans = -1;\n\t\tfor(int i = 0; i < n; ++ i){\n\t\t\tfor(int j = 0; j < m; ++ j){\n\t\t\t\tfor(int k = 0; k < 8 ; ++ k){\n\t\t\t\t\tinsert(i, j, k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans < 2){\n\t\t\tprintf(\"0\\n\");\n\t\t}else{\n\t\t\tprint();\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <unordered_set>\n\nusing namespace std;\nchar field[1001][1001];\nbool used[1001][1001];\n\nint main(){\n  int H,W;\n  while(cin>>H>>W&&(H|W)){\n    for(int i=0;i<H;i++)\n      for(int j=0;j<W;j++)\n\tcin>>field[i][j];\n    vector<string> vs;\n    for(int dy=-1;dy<=1;dy++){\n      for(int dx=-1;dx<=1;dx++){\n\tif(dy==0&&dx==0)continue;\n\tmemset(used,0,sizeof(used));\n\tfor(int i=0;i<H;i++){\n\t  for(int j=0;j<W;j++){\n\t    if(!(i==0||j==0||i==H-1||j==W-1))continue;\n\t    int cx=j;\n\t    int cy=i;\n\t    string s;\n\t    if(used[cy][cx])continue;\n\t    while(1){\n\t      used[cy][cx]=true;\n\t      s+=field[cy][cx];\n\t      cy+=dy;cx+=dx;\n\t      cy=(cy+H)%H;\n\t      cx=(cx+W)%W;\n\t      if(used[cy][cx])break;\n\t    }\n\t    vs.push_back(s);\n\t    //cout<<s<<endl;\n\t  }\n\t}\n      }\n    }\n    unordered_set<string> us;\n    string cand;\n    for(int i=0;i<(int)vs.size();i++){\n      for(int j=0;j<(int)vs[i].size();j++){\n\tfor(int k=1;k<=(int)vs[i].size();k++){\n\t  string s;\n\t  for(int l=0;l<k;l++){\n\t    s+=vs[i][(j+l)%vs[i].size()];\n\t  }\n\t  if(us.count(s)==1){\n\t    if(cand==\"\"||cand.size()<s.size())\n\t      cand=s;\n\t    else if(cand.size()==s.size()&&cand>s)\n\t      cand=s;\n\t  }\n\t  else if(us.count(s)==0)\n\t    us.insert(s);\n\t}\n      }\n    }\n    if(cand.size()>1)cout<<cand<<endl;\n    else cout<<0<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <deque>\n#include <queue>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <stdio.h>\n\nusing namespace std;\n\n#define fo(i,n) for(int i=0; i<(int)n; i++)\n#define rep(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\n#define mp(a,b) make_pair(a,b)\n#define pb(x) push_back(x)\n#define pii pair<int,int>\n\nint n,m;\nstring buf[35];\nset<string> all;\nbool vis[35][35];\nint dx[] = {-1,0,1,-1,1,-1,0,1};\nint dy[] = {-1,-1,-1,0,0,1,1,1};\n\nint main() {\n\n    //freopen(\"input.txt\",\"r\",stdin);\n    //freopen(\"output.txt\",\"w\",stdout);\n\n\twhile (scanf(\"%d%d\",&n,&m) && n!=0) {\n\t\tfor (int i=0; i<n; i++) cin>>buf[i];\n\n\t\tall.clear();\n\t\tint best = 0;\n\t\tstring str;\n\t\tfor (int k=0; k<8; k++) {;\n\t\t\tfor (int i=0; i<n; i++) {\n\t\t\t\tfor (int j=0; j<m; j++) {\n\t\t\t\t\tfor (int x=0; x<n; x++) for (int y=0; y<m; y++) vis[x][y] = 0;\n\t\t\t\t\tint x = i;\n\t\t\t\t\tint y = j;\n\t\t\t\t\tstring s;\n\t\t\t\t\twhile (!vis[x][y]) {\n\t\t\t\t\t\tvis[x][y] = 1;\n\t\t\t\t\t\ts = s + buf[x][y];\n\t\t\t\t\t\tx = (x + dx[k] + n)%n;\n\t\t\t\t\t\ty = (y + dy[k] + m)%m;\n\t\t\t\t\t\tif (s.length()>=2) {\n\t\t\t\t\t\t\tif (all.find(s)==all.end()) all.insert(s);\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (best<=(int)s.length()) {\n\t\t\t\t\t\t\t\t\tif (best<(int)s.length()) {\n\t\t\t\t\t\t\t\t\t\tbest = s.length();\n\t\t\t\t\t\t\t\t\t\tstr = s;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse if (str>s) {\n\t\t\t\t\t\t\t\t\t\tstr = s;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (best==0) cout<<\"0\"<<endl;\n\t\telse cout<<str<<endl;\n\t}\n\t\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\n\n#define REP(i,a,b) for(int i=int(a);i<int(b);i++)\n\nusing namespace std;\n\ntypedef long long int lli;\n\nint main () {\n    int h, w;\n    while (cin >> h >> w, h + w) {\n        vector<vector<char>> spell(h, vector<char>(w));\n        REP (i, 0, h) REP (j, 0, w) cin >> spell[i][j];\n        map<string, int> ml;\n        REP (i, 0, h) REP (j, 0, w) {\n            REP (dy, -1, 2) REP (dx, -1, 2) {\n                if (dx == 0 && dy == 0) continue;\n                vector<vector<bool>> isAccess(h, vector<bool>(w, false));\n                int y = i, x = j;\n                string temp = \"\";\n                REP (_, 0, w * h) {\n                    if (isAccess[y][x]) break;\n                    isAccess[y][x] = true;\n                    temp += spell[y][x];\n                    ml[temp]++;\n\n                    y = (y + dy + h) % h;\n                    x = (x + dx + w) % w;\n                }\n            }\n        }\n        string ans = \"\";\n        for (auto s : ml) {\n            if (s.second <= 1 || s.first.size() <= 1) continue;\n            if (ans.size() < s.first.size()) ans = s.first;\n            else if (ans.size() == s.first.size()) ans = min(ans, s.first);\n        }\n        cout << (ans.size() == 0 ? \"0\" : ans) << endl;\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#define INF 0x3f3f3f3f\n\n#include <cstdio>\n\n#include <iostream>\n\n#include <sstream>\n\n#include <cmath>\n\n#include <cstdlib>\n\n#include <algorithm>\n\n#include <queue>\n\n#include <stack>\n\n#include <limits>\n\n#include <map>\n\n#include <string>\n\n#include <cstring>\n\n#include <set>\n\n#include <deque>\n\n#include <bitset>\n\n#include <list>\n\n#include <cctype>\n\n#include <utility>\n\n \n\nusing namespace std;\n\n \n\ntypedef long long ll;\n\ntypedef pair <int,int> P;\n\ntypedef pair <int,P > PP;\n\n \n\nconst static int tx[] = {0,1,1,1,0,-1,-1,-1};\n\nconst static int ty[] = {-1,-1,0,1,1,1,0,-1};\n\n\n\nint main(){\n\n  int H,W;\n\n  while(~scanf(\"%d %d\",&H,&W)){\n\n    if(H==0 && W==0) break;\n\n\n\n    char line[32];\n\n    char stage[10][20];\n\n\n\n    for(int y=0;y<H;y++){\n\n      scanf(\"%s\",line);\n\n      for(int x=0;x<W;x++){\n\n\tstage[y][x] = line[x];\n\n      }\n\n    }\n\n\n\n    string res = \"\";\n\n    vector<string> spells;\n\n    map<string,int> freq;\n\n    \n\n    for(int y=0;y<H;y++){\n\n      for(int x=0;x<W;x++){\n\n\tint sx = x;\n\n\tint sy = y;\n\n\n\n\tfor(int dir=0;dir<8;dir++){\n\n\t  string spell = \"\";\n\n\t  spell.push_back(stage[sy][sx]);\n\n\t  int dx = sx;\n\n\t  int dy = sy;\n\n\t  for(int i=0;i<1000;i++){\n\n\t    dx = tx[dir] + dx;\n\n\t    dy = ty[dir] + dy;\n\n\t    if(dx < 0) dx = W-1;\n\n\t    if(dx >= W) dx = 0;\n\n\t    if(dy < 0) dy = H-1;\n\n\t    if(dy >= H) dy = 0;\n\n\n\n\t    if(dy == sy && dx == sx) break;\n\n\t    spell.push_back(stage[dy][dx]);\n\n\t    freq[spell]++;\n\n\t    if(freq[spell] >= 2){\n\n\t      if(res.size() < spell.size()\n\n\t\t || (res.size() == spell.size() && res > spell)){\n\n\t\tres = spell;\n\n\t      }\n\n\t    }\n\n\t  }\n\n\t  spells.push_back(spell);\n\n\t  // cout << spell << endl;\n\n\t}\n\n      }\n\n    }\n\n    printf(\"%s\\n\",res != \"\" ? res.c_str() : \"0\");\n\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <ctime>\n#include <list>\n#include <numeric>\n#include <fstream>\n\nusing namespace std;\nstatic const double EPS = 1e-8;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> PI;\n#ifndef M_PI\nconst double M_PI=acos(-1.0);\n#endif\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define FORR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int((a).size()))\n#define F first\n#define S second\nvoid pkuassert(bool b){if(!b){int a=0;cout << 1/a << endl;}};\nint dx[]={0,-1,0,1,1,1,-1,-1},dy[]={1,0,-1,0,1,-1,1,-1};\n\nint n,m;\n\nstring in[100];\n\nvoid solve(){\n  vector<string> app;  \n  rep(i,n) cin >> in[i];\n  rep(i,n)rep(j,m){\n    rep(k,8){\n      int cx=i,cy=j;\n      string str;\n      do{\n        str += in[cx][cy];\n        cx += dx[k];\n        cy += dy[k];\n        if(cx<0) cx += n;\n        if(cy<0) cy += m;\n        if(cx>=n) cx -= n;\n        if(cy>=m) cy -= m;\n      }while(cx!=i || cy!=j);\n      app.pb(str);\n    }\n  }\n  sort(ALL(app));\n\n  string ans;\n  rep(i,SZ(app)-1){\n    int le=0;\n    while(le<SZ(app[i]) && le<SZ(app[i+1]) &&\n          app[i][le]==app[i+1][le])\n      ++le;\n    if(SZ(ans)<le) ans = app[i].substr(0,le);\n  }\n  \n  if(SZ(ans)>1) cout << ans << endl;\n  else cout << 0 << endl;\n}\n\nint main(){\n  while(cin >> n >> m && n&&m) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\nconst int dx8[] = { -1, -1, 0, 1, 1, 1, 0, -1 }; const int dy8[] = { 0, 1, 1, 1, 0, -1, -1, -1 };\n\n\nint main() {\n\tint n, m;\n\twhile (cin >> n >> m, n){\n\t\tint ma = 2;\n\t\tvector<string> code(n);\n\t\tvector<string> spell;\n\t\tset<string> ss;\n\t\tREP(i, n){\n\t\t\tcin >> code[i];\n\t\t}\n\t\tREP(i, n){\n\t\t\tREP(j, m){\n\t\t\t\tREP(k, 8){\n\t\t\t\t\tstring s = \"\";\n\t\t\t\t\tint y=i;\n\t\t\t\t\tint x=j;\n\t\t\t\t\twhile (1){\n\t\t\t\t\t\ts += code[y][x];\n\t\t\t\t\t\tif (s.length() >= ma){\n\t\t\t\t\t\t\tif (ss.find(s) == ss.end()){\n\t\t\t\t\t\t\t\tss.insert(s);\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tif (ma < s.length()){\n\t\t\t\t\t\t\t\t\tma = s.length();\n\t\t\t\t\t\t\t\t\tspell.clear();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tspell.push_back(s);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\ty += dy8[k]+n;\n\t\t\t\t\t\ty%=n;\n\t\t\t\t\t\tx +=dx8[k]+m;\n\t\t\t\t\t\tx%=m;\n\t\t\t\t\t\tif (y==i&&x==j)break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tif (spell.empty())\n\t\t\tcout << \"0\"<<endl;\n\t\telse{\n\t\t\tSORT(spell);\n\t\t\tcout << spell[0] << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <memory.h>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\ntypedef pair<int, int> P;\ntypedef pair<int, P> state;\nconst int INF = 1 << 28;\n\nmap<string, int> cnt;\nbool used[20][20];\nstring s[20];\nint h, w;\nint dx[] = {1, 1, 1, 0, 0, -1, -1, -1};\nint dy[] = {0, -1, 1, -1, 1, 0, -1, 1};\n\nvoid make_string(int y, int x){\n  \n  rep(k, 8){\n    int i = y;\n    int j = x;\n    string str;\n    memset(used, 0, sizeof(used));\n    while(!used[i][j]){\n      str += s[i][j];\n      cnt[str]++;\n      used[i][j] = true;\n      i += dy[k];\n      j += dx[k];\n      i = (i + h) % h;\n      j = (j + w) % w;\n    }\n  }\n}\n\nint main(){\n  while(cin >> h >> w && (h || w)){\n    string res = \"\";\n    cnt.clear();\n    rep(i, h) cin >> s[i];\n    rep(i, h)rep(j, w){\n      make_string(i, j);\n    }\n    \n    for(map<string, int>::iterator iter = cnt.begin(); iter != cnt.end(); iter++){\n      if(iter->second > 1 && (iter->first).size() > res.size()) res = iter->first;      \n    }\n  \n    if((int)res.size() < 2) res = \"0\";\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint gcd(int a, int b){\n    while(a != b){\n        if(a > b) a = a - b; else b = b - a;\n    }\n    return a;\n}\n\nint lcm(int a, int b){\n    return ((a / gcd(a, b)) * b);\n}\n\nint main(){\n    int h, w;\n    while(true){\nchar torus[10][20];\n        string str[2048];\n        bool ok[2048];\n        int num = 0;\n\n        for(int i=0; i<2048; ++i){\n            str[i] = \"\";\n            ok[i] = true;\n        }\n\n        cin >> h >> w;\n        if(h==0 && w==0) break;\n\n        int cml = lcm(w, h);\n\n        for(int i=0; i<h; ++i){\n            for(int j=0; j<w; ++j){\n                cin >> torus[i][j];\n            }\n        }\n\n        //一番長い文字列をつくる\n\n        for(int y=0; y<h; ++y){\n            for(int x=0; x<w; ++x){\n                for(int i=0; i<h; ++i){\n                    str[num] += torus[(y+i)%h][x];\n                    str[num+1] += torus[h-(y+i)%h-1][x];\n                }\n                num += 2;\n            }\n        }\n        for(int y=0; y<h; ++y){\n            for(int x=0; x<w; ++x){\n                for(int i=0; i<w; ++i){\n                    str[num] += torus[y][(x+i)%w];\n                    str[num+1] += torus[y][w-(x+i)%w-1];\n                }\n                num += 2;\n            }\n        }\n        for(int y=0; y<h; ++y){\n            for(int x=0; x<w; ++x){\n                for(int i=0; i<cml; ++i){\n                    str[num] += torus[(y+i)%h][(x+i)%w];\n                    str[num+1] += torus[(y+i)%h][w-(x+i)%w-1];\n                    str[num+2] += torus[h-(y+i)%h-1][(x+i)%w];\n                    str[num+3] += torus[h-(y+i)%h-1][w-(x+i)%w-1];\n                }\n                num += 4;\n            }\n        }\n\n\n        string result = \"\";\n\n        sort(str, str+num);\n\n        for(int i=0; i<num-1; ++i){\n            int length = 0;\n            string k = \"\";\n            for(int j=0; j<min(str[i].length(), str[i+1].length()); ++j){\n                if(str[i][j] == str[i+1][j]) k += str[i][j]; else break;\n            }\n            if(length >= result.length()){\n                result = k;\n            }\n        }\n\n        cout << ((result.length() == 1) ? \"0\" : result) << endl;\n\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nint lcm(int a,int b){\t//a,b < 20だしいいよね\n\t\tif (a < b){\n\t\t\tswap(a,b);\n\t\t}\n\t\tint times = a * b;\n\t\tint gcd,lcm;\n\t\twhile(1){\n\t\t\tint n;\n\t\t\tn = a % b;\n\t\t\tif(n == 0){\tbreak;}\n\t\t\ta = b;\n\t\t\tb = n;\n\t\t}\n\t\tgcd = b;\n\t\tlcm = times / gcd;\n\treturn lcm;\n}\n\nint main(){\n\tint h,w;\n\twhile(1){\n\t\tcin >> h >> w ;\n\t\tif(h == 0 && w == 0){\tbreak;}\n\t\tchar donut[10][20];\n\t\tfor(int i=0;i<10;i++){\n\t\t\tfor(int j=0;j<20;j++){\n\t\t\t\tdonut[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tstring code[1600];\n\t\tbool much[1600];\n\t\tfor(int i = 0; i < 1600; i++){\n\t\t\tcode[i] = \"\";\n\t\t\tmuch[i] = true;\n\t\t}\t//初期化…\n\n\t\tunsigned int l = lcm(w,h);\t//ななめの最大数\n\t\tint a = 0;\t//strの数を数えます\n\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j =0; j < w; j++){\n\t\t\t\tcin >> donut[i][j];\n\t\t\t}\n\t\t}\t//input\n\n\t\tfor(int y = 0; y < h; y++){\n\t\t\tfor(int x = 0; x < w; x++){\n\t\t\t\tfor(int i = 0; i < h; i++){\t//縦列\n\t\t\t\t\tcode[a].append(1,donut[(y + i)%h][x]);\n\t\t\t\t\tcode[a+1].append(1,donut[h-(y + i)%h-1][x]);\n\t\t\t\t}\n\t\t\t\ta += 2;\n\t\t\t\tfor(int j = 0; j < w; j++){\t//横列\n\t\t\t\t\tcode[a].append(1,donut[y][(x + j)%w]);\n\t\t\t\t\tcode[a+1].append(1,donut[y][w-(x+j)%w-1]);//absつけなくても0になりません！\n\t\t\t\t}\n\t\t\t\ta += 2;\n\t\t\t\tfor(unsigned int k = 0; k < l; k++){\t//ななめ\n\t\t\t\t\tcode[a].append(1,donut[(y + k)%h][(x + k)%w]);\n\t\t\t\t\tcode[a+1].append(1,donut[(y + k)%h][(l + x - k)%w]);\n\t\t\t\t\tcode[a+2].append(1,donut[(l + y - k)%h][(x + k)%w]);\n\t\t\t\t\tcode[a+3].append(1,donut[(l + y - k)%h][(l + x - k)%w]);\n\t\t\t\t}\n\t\t\t\ta += 4;\n\t\t\t}\n\t\t}\n\t\tstring mag = \"\";\t//a:strの数-1\n\t\tsort(code,code+a);//nとn+1を比べます\n\n\t\tfor(unsigned int i = 1; i < l; i++){\t//2文字目から\n\t\t\tfor(int j = a-1; j > 0; j--){\t//逆順\n\t\t\t\tif(much[j] == true && code[j].length() >= i+1 && code[j-1].length() >= i+1){//=を忘れていました\n\t\t\t\t\t//jのi+1文字目とj-1のi+1文字目を比べるよ\n\t\t\t\t\tif(code[j][i] != code[j-1][i]){\n\t\t\t\t\t\tmuch[j] = false;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tmag = code[j];\n\t\t\t\t\t\tmag.resize(i+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(mag == \"\"){\n\t\t\tcout << \"0\" << endl;\n\t\t}else{\n\t\t\tcout << mag << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <set>\n\nusing namespace std;\n\nint dy[8] = { 0, 1, 1, 1, 0,-1,-1,-1};\nint dx[8] = { 1, 1, 0,-1,-1,-1, 0, 1};\n\nint main(void){\n    int h, w;\n    while (cin>>h>>w && h) {\n        vector<string> s(h);\n        for (int i = 0; i < h; i++) cin >> s[i];\n        \n        set<string> p;\n        string ans = \"\";\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                for (int k = 0; k < 8; k++) {\n                    int ny = i, nx = j;\n                    string t = \"\";\n                    t += s[ny][nx];\n                    while ((ny+dy[k]+h)%h != i || (nx+dx[k]+w)%w != j) {\n                        ny = (ny + dy[k] + h) % h;\n                        nx = (nx + dx[k] + w) % w;\n                        t += s[ny][nx];\n                        \n                        set<string>::iterator it = p.find(t);\n                        if (it == p.end()) p.insert(t);\n                        else if (t.size() > ans.size()) ans = t;\n                        else if (t.size() == ans.size()) ans = min(ans, t);\n                    }\n                }\n            }\n        }\n        if (ans.size() == 0) cout << 0 << endl;\n        else cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint gcd(int a, int b){\n    while(a != b){\n        if(a > b) a = a - b; else b = b - a;\n    }\n    return a;\n}\n\nint lcm(int a, int b){\n    return ((a / gcd(a, b)) * b);\n}\n\nint main(){\n    int h, w;\n    while(true){\nchar torus[10][20];\n        string str[2048];\n        bool ok[2048];\n        int num = 0;\n\n        for(int i=0; i<2048; ++i){\n            str[i] = \"\";\n            ok[i] = true;\n        }\n\n        cin >> h >> w;\n        if(h==0 && w==0) break;\n\n        int cml = lcm(w, h);\n\n        for(int i=0; i<h; ++i){\n            for(int j=0; j<w; ++j){\n                cin >> torus[i][j];\n            }\n        }\n\n        //一番長い文字列をつくる\n\n        for(int y=0; y<h; ++y){\n            for(int x=0; x<w; ++x){\n                for(int i=0; i<h; ++i){\n                    str[num] += torus[(y+i)%h][x];\n                    str[num+1] += torus[h-(y+i)%h-1][x];\n                }\n                num += 2;\n            }\n        }\n        for(int y=0; y<h; ++y){\n            for(int x=0; x<w; ++x){\n                for(int i=0; i<w; ++i){\n                    str[num] += torus[y][(x+i)%w];\n                    str[num+1] += torus[y][w-(x+i)%w-1];\n                }\n                num += 2;\n            }\n        }\n        for(int y=0; y<h; ++y){\n            for(int x=0; x<w; ++x){\n                for(int i=0; i<cml; ++i){\n                    str[num] += torus[(y+i)%h][(x+i)%w];\n                    str[num+1] += torus[(y+i)%h][w-(x+i)%w-1];\n                    str[num+2] += torus[h-(y+i)%h-1][(x+i)%w];\n                    str[num+3] += torus[h-(y+i)%h-1][w-(x+i)%w-1];\n                }\n                num += 4;\n            }\n        }\n\n\n        vector<char> result;\n\n        sort(str, str+num);\n\n        for(int i=num-1; i>0; --i){\n            int length = 0;\n            vector<char> k;\n            for(int j=0; j<min(str[i].length(), str[i-1].length()); ++j){\n                if(str[i][j] == str[i-1][j]) k.push_back(str[i][j]); else break;\n            }\n            if(k.size() >= result.size()){\n                result = k;\n            }\n        }\n\n        if(result.size() == 1){\n            cout << \"0\" << endl;\n        }else{\n            vector<char>::iterator it = result.begin();\n            while( it != result.end()){\n                cout << *it;\n                ++it;\n            }\n            cout << endl;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(c) (c).begin(),(c).end()\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\n#define mem(a) memset(a,0,sizeof(a))\n#define pd(a) printf(\"%.10f\\n\",a)\n#define pb(a) push_back(a)\n#define in(a) insert(a)\n#define pi M_PI\n#define R cin>>\n#define F first\n#define S second\n#define C class\n#define ll long long\n#define ln cout<<'\\n'\n#define _(_1,_2,_3,N,...)N\n#define pr(...) _(__VA_ARGS__,pr3,pr2,pr1)(__VA_ARGS__)\ntemplate<C T>void pr1(T a){cout<<a;ln;}\ntemplate<C T,C T2>void pr2(T a,T2 b){cout<<a<<' '<<b;ln;}\ntemplate<C T,C T2,C T3>void pr3(T a,T2 b,T3 c){cout<<a<<' '<<b<<' '<<c;ln;}\ntemplate<C T>void PR(T a,int n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}\nbool check(int n,int m,int x,int y){return x>=0&&x<n&&y>=0&&y<m;}\nconst ll MAX=1000000007,MAXL=1LL<<60,dx[8]={-1,-1,-1,0,0,1,1,1},dy[8]={-1,0,1,-1,1,-1,0,1};\ntypedef pair<int,int> P;\n\nvoid Main() {\n  int n,m;\n  while(cin >> n >> m && n) {\n    string s[n];\n    rep(i,n) R s[i];\n    map<string,int> d;\n    rep(i,n) {\n      rep(j,m) {\n        rep(k,8) {\n          string t=\"\";\n          int x=i,y=j;\n          while(1) {\n            t+=s[x][y];\n            d[t]++;\n            x+=dx[k];\n            y+=dy[k];\n            if(x<0) x+=n;\n            if(x>=n) x-=n;\n            if(y<0) y+=m;\n            if(y>=m) y-=m;\n            if(x==i&&y==j) break;\n          }\n        }\n      }\n    }\n    string ans=\"0\";\n    tr(it,d) {\n      if(it->F.size()<=1 || it->S<2) continue;\n      if(ans.size()<it->F.size()) ans=it->F;\n      else if(ans.size()==it->F.size()) ans=min(ans,it->F);\n    }\n    pr(ans);\n  }\n}\n\nint main() {\n  ios::sync_with_stdio(0);cin.tie(0);\n  Main();return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint dx[] = {-1,-1,-1,0,1,1,1,0};\nint dy[] = {-1,0,1,1,1,0,-1,-1};\n\nint main(){\n\tint h, w;\n\tstring mp[10];\n\twhile(cin >> h >> w, h){\n\t\tfor(int i=0;i<h;i++) cin >> mp[i];\n\t\tstring res = \"\";\n\t\tfor(int i=0;i<w*h;i++){\n\t\t\tif(res.size() == w*h) break;\n\t\t\tint x1 = i/w, y1 = i%w;\n\t\t\tfor(int j=i+1;j<w*h;j++){\n\t\t\t\tif(res.size() == w*h) break;\n\t\t\t\tint x2 = j/w, y2 = j%w;\n\t\t\t\tif(mp[x1][y1]!=mp[x2][y2]) continue;\n\t\t\t\tfor(int di=0;di<8;di++){\n\t\t\t\t\tfor(int dj=0;dj<8;dj++){\n\t\t\t\t\t\tstring cur;\n\t\t\t\t\t\tint nx1 = (x1+dx[di]+h)%h, ny1 = (y1+dy[di]+w)%w;\n\t\t\t\t\t\tint nx2 = (x2+dx[dj]+h)%h, ny2 = (y2+dy[dj]+w)%w;\n\t\t\t\t\t\tif(mp[nx1][ny1]!=mp[nx2][ny2]) continue;\n\t\t\t\t\t\tcur += mp[x1][y1];\n\t\t\t\t\t\twhile((x1 != nx1 || y1 != ny1) && (x2 != nx2 || y2 != ny2) && mp[nx1][ny1] == mp[nx2][ny2]){\n\t\t\t\t\t\t\tcur += mp[nx1][ny1];\n\t\t\t\t\t\t\tnx1 = (nx1+dx[di]+h)%h, ny1 = (ny1+dy[di]+w)%w;\n\t\t\t\t\t\t\tnx2 = (nx2+dx[dj]+h)%h, ny2 = (ny2+dy[dj]+w)%w;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(cur.size() > res.size()) res = cur;\n\t\t\t\t\t\telse if(cur.size() == res.size()) res = min(res, cur);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << (res==\"\" ? \"0\" : res) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint H,W;\nbool visited[25][25];\nchar field[25][25];\nmap<string,int> mp;\nconst int dx[] = {-1,-1,-1,0,0,1,1,1};\nconst int dy[] = {-1,0,1,-1,1,-1,0,1};\n\nvoid rec(int x,int y,int d,string s){\n  if(visited[y][x]){ return; }\n  visited[y][x] = true;\n  int nx = (x + dx[d] + W) % W;\n  int ny = (y + dy[d] + H) % H;\n  mp[s+field[y][x]]++;\n  rec(nx,ny,d,s+field[y][x]);\n}\n\nint main(){\n  while(cin >> H >> W, H){\n    mp.clear();\n    for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n        cin >> field[i][j];\n      }\n    }\n    for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n        for(int k = 0 ; k < 8 ; k++){\n          memset(visited,false,sizeof(visited));\n          rec(j,i,k,\"\");\n        }\n      }\n    }\n    int ans_size = -1;\n    string ans;\n    map<string,int>::iterator it;\n    for(it = mp.begin() ; it != mp.end() ; ++it){\n      int size = it->first.size();\n      if(it->second < 2 || size < 2){ continue; }\n      if(ans_size < size){\n        ans_size = size;\n        ans = it->first;\n      }\n    }\n    if(ans_size == -1){\n      cout << 0 << endl;\n    }else{\n      cout << ans << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int N, M;\n    while(cin >> N >> M, N || M) {\n        vector<string> v(N);\n        for(auto &i : v) cin >> i;\n\n        string res = \"\";\n        const int dx[] = {1, 1, 1, -1, -1, -1, 0, 0};\n        const int dy[] = {-1, 0, 1, -1, 0, 1, -1, 1};\n        set<string> s;\n        for(int i = 0; i < N; i++) {\n            for(int j = 0; j < M; j++) {\n                for(int k = 0; k < 8; k++) {\n                    int x = i;\n                    int y = j;\n                    int nx = (x + dx[k] + N) % N;\n                    int ny = (y + dy[k] + M) % M;\n                    string tmp = \"\";\n                    tmp += v[i][j];\n                    while(x != nx || y != ny) {\n                        tmp += v[nx][ny];\n                        nx = (nx + dx[k] + N) % N;\n                        ny = (ny + dy[k] + M) % M;\n                        if(res.size() <= tmp.size() && s.find(tmp) != s.end()) {\n                            if(res.size() < tmp.size()) {\n                                res = tmp;\n                            } else if (res.size() == tmp.size()) {\n                                res = min(res, tmp);\n                            }\n                        } else if (res.size() <= tmp.size()){\n                            s.insert(tmp);\n                        }\n                    }\n                }\n            }\n        }\n\n        cout << (res == \"\" ? \"0\" : res) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(), (x).end()\n\nusing namespace std;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\nusing ll = long long;\nusing ld = long double;\n\nconst int INF = 1e9;\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nint W, H;\nstring mat[10][20];\nint dx[8] = {1, 1, 0, -1, -1, -1, 0, 1};\nint dy[8] = {0, 1, 1, 1, 0, -1, -1, -1};\nvector<string> strs;\nint oi, oj;\n\nvoid dfs(int i, int j, int k, string str){\n\tint ni = (i+dx[k]+H)%H; int nj = (j+dy[k]+W)%W;\n\tif(ni == oi && nj == oj) { strs.push_back(str); return; }\n\tstr.append(mat[ni][nj]);\t\n\tdfs(ni, nj, k, str);\n\treturn;\n}\n\nint main(){\n\twhile(cin >> H >> W and W + H){\n\t\tstrs.clear();\n\t\tREP(i, H) {\n\t\t\tstring str;\n\t\t\tcin >> str;\n\t\t\tREP(j, W) mat[i][j] = string(&str[j], 1);\n\t\t}\n\t\tREP(i, H) REP(j, W) REP(k, 8){\n\t\t\toi = i; oj = j;\n\t\t\tdfs(i, j, k, mat[i][j]);\n\t\t}\n\t\tsort(ALL(strs));\n\t\tint rcnt = 0;\n\t\tstring res;\n\t\tREP(i, strs.size()-1){\n\t\t\tint cnt = 0;\n\t\t\tREP(j, min(strs[i].size(), strs[i+1].size())){\n\t\t\t\tif(strs[i][j] != strs[i+1][j]) break;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tif(cnt > rcnt) { rcnt = cnt; res = strs[i].substr(0, rcnt); }\n\t\t}\n\t\tif(rcnt < 2) cout << \"0\" << endl;\n\t\telse cout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<cstdio>\n#include<sstream>\n#include<algorithm>\n#include<cmath>\n#include<map>\n#include<functional>\n#include<queue>\n#include<stack>\n#include<set>\nusing namespace std;\n#define SZ(n)  (int)n.size()\n#define dump(x) cerr<<#x<<\" = \"<<(x)<<endl;\n#define debug(x)cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#define MP make_pair\n#define PB push_back\n\t\n\n\n\tint dx[]={1,1,0,-1,-1,-1,0,1},dy[]={0,1,1,1,0,-1,-1,-1};\n\tstring _or(string a,string b){\n\t\tif(SZ(a)>SZ(b))return a;\n\t\tif(SZ(a)<SZ(b))return b;\n\t\treturn min(a,b);\n\t}\n\tchar ta[50][50];\n\tint main(){\n\tint w,h;\n\twhile(cin>>h>>w,(h||w)){\n\tmap<string,int>ans;\n\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)cin>>ta[i][j];\n\tstring tmp;\n\n\tfor(int ni=0;ni<h;ni++){\n\t\tfor(int nj=0;nj<w;nj++){\n\t\t\tfor(int p=0;p<8;p++){\n\t\t\t\ttmp.clear();\n\t\t\t\tint i=ni,j=nj;\n\t\t\t\ttmp.push_back(ta[ni][nj]);\n\t\t\t\t\twhile(true){\n\t\t\t\t\ti+=dy[p],j+=dx[p];\n\t\t\t\t\tif(i<0)i=h-1;\n\t\t\t\t\tif(j<0)j=w-1;\n\t\t\t\t\tif(i>h-1)i=0;\n\t\t\t\t\tif(j>w-1)j=0;\n\t\t\t\t\tif(i==ni&&j==nj)break;\n\t\t\t\t\ttmp.push_back(ta[i][j]);\n\n\t\t\t\t\tif(SZ(tmp)>=2){\n\t\t\t\t\tans[tmp]++;\n\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tstring tans=\"\";\n\tfor(map<string,int>::iterator it=ans.begin();it!=ans.end();it++){\n\tif((*it).second>=2){tans=_or(tans,(*it).first);}\n\t}\n\tif(SZ(tans)<2)cout<<\"0\"<<endl;\n\telse cout<<tans<<endl;\n\tfor(int i=0;i<50;i++)for(int j=0;j<50;j++)ta[i][j]=' ';\n\t}\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr, __VA_ARGS__)\n//#define LOG(...)\n#define FOR(i, a, b) for (int i = (int)(a); i < (int)(b); ++i)\n#define RFOR(i, a, b) for (int i = (int)(b - 1); i >= (int)(a); --i)\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define RREP(i, n) for (int i = (int)(n - 1); i >= 0; --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(a) ((int)(a).size())\n#define BIT(x, i) (((x) >> (i)) & 1)\n#define SQ(x) ((x) * (x))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = {-1,0,1,0,1,1,-1,-1}, dy[] = {0,1,0,-1,-1,1,1,-1};\n\nint H, W;\nchar field[10][20];\n\nint ma;\nstring mas;\n\nset<string> S;\n\nvoid add_string(int i, int n, int m, int x, int y) {\n    REP(j, n) {\n        int sx = x, sy = y;\n        stringstream ss;\n        ss << field[sy][sx];\n        REP(k, m) {\n            sx = (sx + dx[i] + W) % W;\n            sy = (sy + dy[i] + H) % H;\n            ss << field[sy][sx];\n            string s = ss.str();\n            if (!S.insert(s).second) {\n                if (ma < (int)s.length()) {\n                    ma = s.length();\n                    mas = s;\n                } if (ma == (int)s.length()) {\n                    mas = min(mas, s);\n                }\n            }\n        }\n        x = (x + dx[i] + W) % W;\n        y = (y + dy[i] + H) % H;\n    }\n}\n\nint main() {\n    while (cin >> H >> W, H|W) {\n        REP(y, H) REP(x, W) cin >> field[y][x];\n        S.clear();\n\n        ma = 0;\n        REP(i, 8) {\n            if (i < 4) {\n                if (i % 2 == 0) {\n                    REP(y, H) add_string(i, W, W-1, 0, y);\n                } else {\n                    REP(x, W) add_string(i, H, H-1, x, 0);\n                }\n            } else {\n                REP(x, W) REP(y, H) {\n                    add_string(i, 1, H*W-1, x, y);\n                }\n            }\n        }\n        if (ma == 0) {\n            cout << 0 << endl;\n        } else {\n            cout << mas << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * GCA : \"Computer is artificial subject absolutely,Math is God\"\n */\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <cctype>\n#include <utility>\n#include <ctime>\nusing namespace std;\n#ifdef DEBUG\n#define VAR(a,b) __typeof(b) a=(b)\n#define debug(...) printf(\"DEBUG: \"),printf(__VA_ARGS__)\n#else\n#define VAR(a,b) __typeof(b) a=(b)\n#define debug(...)\n#endif\ntypedef unsigned int uint;\ntypedef long long int Int;\ntypedef unsigned long long int UInt;\n#define Set(a,s) memset(a,s,sizeof(a))\n#define Pln() printf(\"\\n\")\n#define For(i,x)for(int i=0;i<x;i++)\n#define CON(x,y) x##y\n#define M 25\n#define PB push_back\n#define oo INT_MAX\n#define FOR(a,b) for(VAR(a,(b).begin());a!=(b).end();++a)\n#define eps 1e-9\n#define X first\n#define Y second\ninline bool xdy(double x,double y){return x>y+eps;}\ninline bool xddy(double x,double y){return x>y-eps;}\ninline bool xcy(double x,double y){return x<y-eps;}\ninline bool xcdy(double x,double y){return x<y+eps;}\nconst Int mod=1000000007;\nint nx,ny;\nchar mz[M][M];\nset<Int> sid;\nint dx[8]={0,1,1,1,0,-1,-1,-1};\nint dy[8]={1,1,0,-1,-1,-1,0,1};\nchar store[M*M];\nInt ist=0;\nint ox,oy;\nstring ans;\n//string has[M][M][9];\n//bool vis[M][M][9];\nvoid dfs(int x,int y,int d,int dep){\n\n\tstore[dep]=mz[y][x];\n\tist=ist*134+mz[y][x];\n\tint nex=(x+dx[d]+nx)%nx;\n\tint ney=(y+dy[d]+ny)%ny;\n\tstore[dep+1]=0;\n\tstring ss(store);\n//\t\tputs(store);\n\tif(sid.count(ist)){\n\t\tif(ss.length()>ans.length()){\n\t\t\tans=ss;\n\t\t}else if(ss.length()==ans.length()&&ss<ans){\n\t\t\tans=ss;\n\t\t}\n\t}\n\tsid.insert(ist);\n\tif(nex==ox&&ney==oy){\n\t\treturn;\n\t}\n\tdfs(nex,ney,d,dep+1);\n\n}\nvoid solve(){\n\tfor(int i=0;i<ny;i++){\n\t\tfor(int j=0;j<nx;j++){\n\t\t\tfor(int k=0;k<8;k++){\n\t\t\t\tox=j;oy=i;\n\t\t\t\tist=0;\n\t\t\t\tSet(store,0);\n\t\t\t\tdfs(j,i,k,0);\n\t\t\t}\n\t\t}\n\t}\n//\tfor(int i=0;i<8;i++){\n//\t\tox=1;oy=1;\n//\t\tdfs(1,1,i,0);\n//\t}\n\tif(ans.length()>=2)\n\t\tprintf(\"%s\\n\",ans.c_str());\n\telse puts(\"0\");\n}\nint main() {\n\tios_base::sync_with_stdio(0);\n\twhile(~scanf(\"%d%d\",&ny,&nx)&&nx+ny){\n\t\tsid.clear();\n\t\tans=\"\";\n//\t\tSet(vis,0);\n\t\tfor(int i=0;i<ny;i++)scanf(\"%s\",mz[i]);\n\t\tsolve();\n\n\t}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\nusing namespace std;\n\nint lcm(int a, int b){\n  return a/__gcd(a, b) * b;\n}\n\nint main(int argc, char *argv[]){\n  int w, h;\n  while(cin >> h >> w, h){\n    string torus[30];\n    string s[2222];\n    for (int i = 0; i < h; i++) {\n      cin >> torus[i];\n    }\n    int l = lcm(w, h);\n    int num = 0;\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        for (int k = 0; k < h; k++) {\n          s[num].push_back(torus[(h + i + k)%h][j]);\n          s[num + 1].push_back(torus[(h + i - k)%h][j]);\n        }\n        \n        for (int k = 0; k < w; k++) {\n          s[num + 2].push_back(torus[i][(w + j + k)%w]);\n          s[num + 3].push_back(torus[i][(w + j - k)%w]);\n        }\n        \n        for (int k = 0; k < l; k++) {\n          s[num + 4].push_back(torus[(l*h + i + k)%h][(l*w + j + k)%w]);\n          s[num + 5].push_back(torus[(l*h + i - k)%h][(l*w + j + k)%w]);\n          s[num + 6].push_back(torus[(l*h + i + k)%h][(l*w + j - k)%w]);\n          s[num + 7].push_back(torus[(l*h + i - k)%h][(l*w + j - k)%w]);\n        }\n        num += 8;\n      }\n    }\n    sort(s, s + 8*w*h);\n    string ans = s[0];\n    for (int i = 0; i < 8*w*h - 1; i++) {\n      int length = 0;\n      for (int j = 0;\n           j < min(s[i].length(), s[i + 1].length()) - 1; j++) {\n        if(s[i][length] == s[i + 1][length])length++;\n        else break;\n      }\n      if(length > ans.length())ans = s[i].substr(0,length);\n    }\n    if(ans.length() > 1)std::cout << ans << std::endl;\n    else std::cout << 0 << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <iostream>\n#include <map>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint h,w;\nstring fie[11];\nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,1,-1};\nmap<string,int> cnt;\nbool used[11][21];\nvector<string> index2;\n\nvoid dfs(int y,int x,int k,string str){\n\tif(used[y][x])return;\n\tused[y][x]=true;\n\tstr+=fie[y][x];\n\tcnt[str]++;\n\tindex2.push_back(str);\n\tdfs((y+dy[k]+h)%h,(x+dx[k]+w)%w,k,str);\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&h,&w);\n\t\tif(h+w==0)break;\n\t\tcnt.clear();\n\t\tindex2.clear();\n\t\tfor(int i=0;i<h;i++){\n\t\t\tcin >> fie[i];\n\t\t}\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tfor(int k=0;k<8;k++){\n\t\t\t\t\tmemset(used,false,sizeof(used));\n\t\t\t\t\tdfs(i,j,k,\"\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(index2.begin(),index2.end());\n\t\tindex2.erase(unique(index2.begin(),index2.end()),index2.end());\n\t\tstring res=\"0\";\n\t\tfor(int i=0;i<index2.size();i++){\n\t\t\tif(cnt[index2[i]]>=2 && index2[i].size()>=2){\n\t\t\t\tif(res.size()<index2[i].size() || (res.size()==index2[i].size() && index2[i]<res)){\n\t\t\t\t\tres=index2[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n#include <stack>\n#include <tuple>\n#include <array>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\n\n\ntypedef long long int ll;\ntypedef double D;      // ??§?¨?????????????double???long double?????????\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\n\n\nconst int INF = (1<<30) - 1;\nconst D EPS = 1e-9;\n\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\nint H, W;\nvector<string> field;\nint dh[] = {1, 1, 0, -1, -1, -1, 0, 1};\nint dw[] = {0, 1, 1, 1, 0, -1, -1, -1};\n\nvoid func(int h, int w, int d, map<string, int>& memo){\n    int sh = h, sw = w;\n    string s = \"\";\n    \n    do{\n        s += field[h][w];\n        if(s.length() >= 2)\n            memo[s]++;\n        h = (h+dh[d]+H)%H;\n        w = (w+dw[d]+W)%W;\n    }while(sh!=h || sw!=w);\n}\nvoid solve(){\n    map<string, int> memo;\n    \n    for(int h=0; h<H; h++){\n        for(int w=0; w<W; w++){\n            for(int i=0; i<8; i++){\n                func(h, w, i, memo);\n            }\n        }\n    }\n    \n    string ans = \"\";\n    for(auto p: memo){\n        if(p.second < 2) continue;\n        \n        if(ans.length() < p.first.length() || (ans.length() == p.first.length() && p.first < ans))\n            ans = p.first;\n    }\n    if(ans.length() == 0)\n        cout << 0 << endl;\n    else\n        cout << ans << endl;\n}\n\n//g++ -std=c++0x -msse4.2 -O3\n//#include <bits/stdc++.h>\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    //cout.precision(16);\n    //cout.setf(ios::fixed);\n    \n    while(cin>>H>>W, H|W){\n        field = vector<string>(H);\n        \n        for(int i=0; i<H; i++)\n            cin >> field[i];\n        solve();\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nstring s[21];\nint dx[]={1,1,1,0,0,-1,-1,-1};\nint dy[]={1,0,-1,1,-1,1,0,-1};\nint h,w;\nvector<string>v;\nset<string> se;\nvoid dfs(int d,int y,int x,int p,string t,int p1,int p2){\n  if(d&&y==p1&&x==p2)return;\n  t+=s[y][x];\n  if(d){\n    if(!se.count(t))se.insert(t);\n    else v.push_back(t);\n  }\n  x+=dx[p],y+=dy[p];\n  if(x<0)x=w-1;\n  if(y<0)y=h-1;\n  if(x>=w)x=0;\n  if(y>=h)y=0;\n  dfs(d+1,y,x,p,t,p1,p2);\n}\nint main(){\n  while(cin>>h>>w,h){\n    se.clear();\n    v.clear();\n    r(i,h)cin>>s[i];\n    r(i,h)r(j,w)r(k,8)dfs(0,i,j,k,\"\",i,j);\n    sort(v.begin(),v.end());\n    int p=0;\n    r(i,v.size())p=max(p,(int)v[i].size());\n    if(v.size())r(i,v.size()){\n      if(v[i].size()==p){\n        cout<<v[i]<<endl;\n        break;\n      }\n    }\n    else cout<<0<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nint gcd(int a, int b){\n  if(b == 0)return a;\n  return gcd(b, a%b);\n}\n\nint lcm(int a, int b){\n  return a/gcd(a, b) * b;\n}\n\nint main(int argc, char *argv[]){\n  int w, h;\n  while(cin >> h >> w, h){\n    string torus[30];\n    string s[2222];\n    for (int i = 0; i < h; i++) {\n      cin >> torus[i];\n    }\n    int l = lcm(w, h);\n    int num = 0;\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        for (int k = 0; k < h; k++) {\n          s[num].push_back(torus[(h + i + k)%h][j]);\n          s[num + 1].push_back(torus[(h + i - k)%h][j]);\n        }\n        \n        for (int k = 0; k < w; k++) {\n          s[num + 2].push_back(torus[i][(w + j + k)%w]);\n          s[num + 3].push_back(torus[i][(w + j - k)%w]);\n        }\n        \n        for (int k = 0; k < l; k++) {\n          s[num + 4].push_back(torus[(l*h + i + k)%h][(l*w + j + k)%w]);\n          s[num + 5].push_back(torus[(l*h + i - k)%h][(l*w + j + k)%w]);\n          s[num + 6].push_back(torus[(l*h + i + k)%h][(l*w + j - k)%w]);\n          s[num + 7].push_back(torus[(l*h + i - k)%h][(l*w + j - k)%w]);\n        }\n        num += 8;\n      }\n    }\n    sort(s, s + 8*w*h);\n    string ans = s[0];\n    for (int i = 0; i < 8*w*h - 1; i++) {\n      int length = 0;\n      for (int j = 0;\n           j < min(s[i].length(), s[i + 1].length()) - 1; j++) {\n        if(s[i][length] == s[i + 1][length])length++;\n        else break;\n      }\n      if(length > ans.length())ans = s[i].substr(0,length);\n    }\n    if(ans.length() > 1)std::cout << ans << std::endl;\n    else std::cout << 0 << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//typedef\n//-------------------------#include <bits/stdc++.h>\n \nconst double pi = 3.141592653589793238462643383279;\n \n \nusing namespace std;\n \n//conversion\n//------------------------------------------\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\ninline int readInt() { int x; scanf(\"%d\", &x); return x; }\n \n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long long, long long> PLL;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n \n \n//container util\n \n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SQ(a) ((a)*(a))\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n \n \n//repetition\n//------------------------------------------\n#define FOR(i,s,n) for(int i=s;i<(int)n;++i)\n#define REP(i,n) FOR(i,0,n)\n#define MOD 998244353\n \n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n \ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\nconst double EPS = 1E-8;\n \n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n \nclass UnionFind {\npublic:\n    vector <int> par; \n    vector <int> siz; \n\n    UnionFind(int sz_): par(sz_), siz(sz_, 1) {\n        for (ll i = 0; i < sz_; ++i) par[i] = i;\n    }\n    void init(int sz_) {\n        par.resize(sz_);\n        siz.assign(sz_, 1LL);\n        for (ll i = 0; i < sz_; ++i) par[i] = i;\n    }\n \n    int root(int x) { \n        while (par[x] != x) {\n            x = par[x] = par[par[x]];\n        }\n        return x;\n    }\n \n    bool merge(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if (x == y) return false;\n        if (siz[x] < siz[y]) swap(x, y);\n        siz[x] += siz[y];\n        par[y] = x;\n        return true;\n    }\n \n    bool issame(int x, int y) { \n        return root(x) == root(y);\n    }\n \n    int size(int x) { \n        return siz[root(x)];\n    }\n};\n \n \nll modPow(ll x, ll n, ll mod = MOD){\n    ll res = 1;\n    while(n){\n        if(n&1) res = (res * x)%mod;\n \n        res %= mod;\n        x = x * x %mod;\n        n >>= 1;\n    }\n    return res;\n}\n \n#define SIEVE_SIZE 5000000+10\nbool sieve[SIEVE_SIZE];\nvoid makeSieve(){\n    for(int i=0; i<SIEVE_SIZE; ++i) sieve[i] = true;\n    sieve[0] = sieve[1] = false;\n    for(int i=2; i*i<SIEVE_SIZE; ++i) if(sieve[i]) for(int j=2; i*j<SIEVE_SIZE; ++j) sieve[i*j] = false;\n}\n \nbool isprime(ll n){\n    if(n == 0 || n == 1) return false;\n    for(ll i=2; i*i<=n; ++i) if(n%i==0) return false;\n    return true;\n}\n \nconst int MAX = 2000010;\nlong long fac[MAX], finv[MAX], inv[MAX];\n \n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n \n// 二項係数計算\nlong long COM(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n \nlong long extGCD(long long a, long long b, long long &x, long long &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    long long d = extGCD(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\n// 負の数にも対応した mod (a = -11 とかでも OK) \ninline long long mod(long long a, long long m) {\n    return (a % m + m) % m;\n}\n \n// 逆元計算 (ここでは a と m が互いに素であることが必要)\nlong long modinv(long long a, long long m) {\n    long long x, y;\n    extGCD(a, m, x, y);\n    return mod(x, m); // 気持ち的には x % m だが、x が負かもしれないので\n}\nll GCD(ll a, ll b){\n    \n    if(b == 0) return a;\n    return GCD(b, a%b);\n}\n\ntypedef vector<ll> vec;\ntypedef vector<vec> mat;\n\nmat mul(mat &A, mat &B) {\n    mat C(A.size(), vec((int)B[0].size()));\n    for(int i=0; i<A.size(); ++i){\n        for(int k=0; k<B.size(); ++k){\n            for(int j=0; j<B[0].size(); ++j){\n                C[i][j] = (C[i][j] + A[i][k] * B[k][j] %MOD) % MOD;\n            }\n        }\n    }\n    return C;\n}\nmat matPow(mat A, ll n) {\n    mat B(A.size(), vec((int)A.size()));\n \n    for(int i=0; i<A.size(); ++i){\n        B[i][i] = 1;\n    }\n \n    while(n > 0) {\n        if(n & 1) B = mul(B, A);\n        A = mul(A, A);\n        n >>= 1;\n    }\n    return B;\n}\n\nint dx[8] = {-1,0,1,1,1,0,-1,-1};\nint dy[8] = {-1,-1,-1,0,1,1,1,0};\nbool visited[15][25];\nint h, w;\nmap<string, int> mp;\nvector<string> s;\nvoid dfs(int y, int x, int dir, string t){\n\n    mp[t]++;\n    visited[y][x] = true;\n    int ny = y + dy[dir], nx = x + dx[dir];\n    if(ny == h) ny = 0;\n    if(ny < 0) ny = h-1;\n    if(nx == w) nx = 0;\n    if(nx < 0) nx = w-1;\n\n    if(visited[ny][nx]) return;\n    dfs(ny, nx, dir, t + s[ny][nx]);\n}\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(15);\n\n    \n    while(cin >> h >> w){\n        if(h == 0 && w == 0) break;\n\n        mp.clear();\n        s.clear();\n        REP(i,h){\n            string t; cin >> t;\n            s.push_back(t);\n        }\n\n        REP(i,h){\n            REP(j, w){\n                \n                for(int k=0; k<8; k++){\n                    REP(l,h) REP(ll, w) visited[l][ll] = false;\n                    string t = \"\";\n                    t += s[i][j];\n                    dfs(i, j, k, t);\n                }\n            }\n        }\n\n        string ans = \"\";\n\n        for(auto e: mp){\n            if(e.first.size() >= 2 && e.second >= 2){\n\n                if(ans.size() < e.first.size()){\n                    ans = e.first;\n                }else if(ans.size() == e.first.size()){\n\n                    for(int i=0; i<ans.size(); i++){\n                        if(ans[i] > e.first[i]){\n                            ans = e.first;\n                            break;\n                        }else if(ans[i] < e.first[i]){\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        if(ans == \"\"){\n            cout << 0 << endl;\n        }else cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <bits/stdc++.h>\n\nusing namespace std;\n#define ll long long\n#define ld long double\n#define  P pair<ll,ll>\n#define FOR(i,n,m) for(ll i=n; i<(ll)m;i++)\n#define FORr(i,m,n) for(ll i=n; i>=(ll)m; i--)\n#define FORm(i,m) for(auto i=m.begin();i!=m.end();i++)\n#define VEC2(x,a,b) vector<vector<ll>> x = vector<vector<ll>>(a,vector<ll>(b,0))\n#define sortAl(v) sort(v.begin(),v.end())\n#define sortAlr(v) sort(v.begin(),v.end()); reverse(v.begin(),v.end())\n#define cinv(v,n,m) FOR(i,n,m) cin>>v.at(i)\n#define coutv(v,n,m) FOR(i,n,m) cout<<v.at(i) <<\" \"; cout<<endl\n#define cout(n) cout<<fixed<<setprecision(n)\n\nvector<string> v;\nvector<string> list_ans;\nll dir_j[8] = {0,1,1,1,0,-1,-1,-1};\nll dir_i[8] = {1,1,0,-1,-1,-1,0,1};\n\nvoid push(ll i, ll j){\n  ll h = v.size();\n  ll w = v[0].size();\n  FOR(p,0,8){\n    ll tmp_i = i;\n    ll tmp_j = j;\n    string s;\n    s.push_back(v[tmp_i][tmp_j]);\n    tmp_i += dir_i[p];\n    tmp_j += dir_j[p];\n    tmp_i += h;\n    tmp_j += w;\n    tmp_i %= h;\n    tmp_j %= w;\n    while(!(tmp_i == i && tmp_j == j)){\n//      cout<<\"t_i = \"<<tmp_i<<\" t_j = \"<<tmp_j<<endl;\n      s.push_back(v[tmp_i][tmp_j]);\n      tmp_i += dir_i[p];\n      tmp_j += dir_j[p];\n      tmp_i += h;\n      tmp_j += w;\n      tmp_i %= h;\n      tmp_j %= w;\n    }\n    list_ans.push_back(s);\n  }\n}\n\nstring ch_res(string a, string b){\n  if(a.size()<b.size()){\n    return b;\n  }\n  return a;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll h,w;\n    cin>>h>>w;\n    while(h!=0){\n      v = vector<string>(0,\"\");\n      list_ans = vector<string>(0,\"\");\n      FOR(i,0,h){\n        string s;\n        cin>>s;\n        v.push_back(s);\n      }\n\n      FOR(i,0,h){\n        FOR(j,0,w){\n//          cout<<\"i = \"<<i<<\" j = \"<<j<<endl;\n          push(i,j);\n        }\n      }\n\n      sortAl(list_ans);\n      string res;\n      FOR(i,1,list_ans.size()){\n        string a = list_ans[i-1];\n        string b = list_ans[i];\n        string tmp_a;\n        string tmp_b;\n        FOR(j,0,a.size()){\n          tmp_a.push_back(a[j]);\n          tmp_b.push_back(b[j]);\n          if(tmp_a == tmp_b) res = ch_res(res, tmp_a);\n        }\n      }\n\n      if(res.size() == 1) cout<<0<<endl;\n      else cout<<res<<endl;\n\n      cin>>h>>w;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF 1001000100010001000\n#define MOD 1000000007\n#define EPS 1e-10\n#define int long long\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define Rep(i, N) for (int i = 1; i < N; i++)\n#define For(i, a, b) for (int i = (a); i < (b); i++)\n#define pb push_back\n#define mp make_pair\n#define i_i pair<int, int>\n#define vi vector<int>\n#define vvi vector<vi >\n#define vb vector<bool>\n#define vvb vector<vb >\n#define vp vector< i_i >\n#define all(a) (a).begin(), (a).end()\n#define Int(x) int x; scanf(\"%lld\", &x);\n\n//int dxy[5] = {0, 1, 0, -1, 0};\nint dx[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nint dy[8] = {1, 0, -1, 1, -1, 1, 0, -1};\n// assign\n\nstring comp(string a, string b);\n\nsigned main()\n{\n    int n, m;\n    while (cin >> n >> m, n) {\n        vector<string> donut(n);\n        rep(i, n) {\n            cin >> donut[i];\n        }\n        set<string> can;\n        string ans = \"z\";\n        rep(i, n) {\n            rep(j, m) {\n                rep(k, 8) {\n                    vvb used(n, vb(m, false));\n                    string spell;\n                    int x = i, y = j;\n                    while (!used[x][y]) {\n                        spell.pb(donut[x][y]);\n                        used[x][y] = true;\n                        if (can.find(spell) != can.end()) {\n                            ans = comp(ans, spell);\n                        } else {\n                            can.insert(spell);\n                        }\n                        x = (x + dx[k] + n) % n; y = (y + dy[k] + m) % m;\n                    }\n                }\n            }\n        }\n        cout << ((ans.length() > 1) ? ans : \"0\") << endl;\n    }\n    return 0;\n}\n\nstring comp(string a, string b)\n{\n    if (a.length() < b.length()) {\n        return b;\n    } else if (a.length() > b.length()) {\n        return a;\n    } else {\n        rep(i, a.length()) {\n            if (a[i] < b[i]) {\n                return a;\n            } else if (a[i] > b[i]) {\n                return b;\n            }\n        }\n    }\n    return a;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n諤サ逧?庄莉・蠖堤コウ謌?荳牙?扈?x,y,z):\nx:逕ィ謗貞コ剰ァ」蜀ウ\ny:逕ィ謗貞コ丞刈cdq蛻?イサ隗」蜀ウ\nz:逕ィ譬醍憾謨ー扈?ァ」蜀ウ\n*/\n#include <map>\n#include <set>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <sstream>\n#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <bitset>\n#include <climits>\n#include <ostream>\n#include <ios>\n#include <cstdlib>\nusing namespace std;\n\n#define wh while\n#define inf (int)(~0u/2)\n#define FOR(i, n) for(int i = 0; i < n; i++)\n#define FOR1(i, n) for(int i = 1; i < n; i++)\n#define FOR2(i, n) for(int i = 0; i <= n; i++)\n#define REP(i,n) for(int i = 1; i <= n; i++)\n#define FORI(it,n) for(typeof(n.begin()) it = n.begin(); it != n.end(); it++)\n#define sf scanf\n#define pf printf\n#define frs first\n#define sec second\n#define psh push_back\n#define mkp make_pair\n#define PB(x) push_back(x)\n#define MP(x, y) make_pair(x, y)\n#define clr(abc,z) memset(abc,z,sizeof(abc))\n#define lt(v) v << 1\n#define rt(v) v << 1 | 1\n#define mid ((l + r) >> 1)\n#define lson l, mid, v << 1\n#define rson mid + 1, r, v << 1 | 1\n\n#define fre freopen(\"1.txt\", \"r\", stdin);\n\ntypedef long long LL;\ntypedef long double LD;\n\nconst int maxnode = 1e6 + 10;\nconst int sigma_size = 26;\n\nint h, w;\nstruct Trie {\n    map<int, string> mp;\n  int ch[maxnode][sigma_size];\n  int val[maxnode];\n  int len[maxnode];\n  bool isOK[maxnode];\n  int sz;\n  void _clear() { sz = 1; memset(ch[0], 0, sizeof(ch[0]));\n  clr(isOK, false); mp.clear();\n  }\n  int idx(char c) { return c - 'A'; }\n  void _insert(const char *s, int v) {\n    int u = 0, n = strlen(s);\n    for(int i = 0; i < n; i++) {\n        len[u] = i;\n      int c = idx(s[i]);\n      if(!ch[u][c]) {\n        memset(ch[sz], 0, sizeof(ch[sz]));\n        val[sz] = 0;\n        ch[u][c] = sz++;\n      }\n      u = ch[u][c];\n    }\n    len[u] = n;\n    if(val[u]) isOK[u] = true;\n    else{\n        val[u] = v; mp[v] = s;\n    }\n  }\n};\n\nTrie tree;\nchar tmp[12][42];\nchar tmpB[220];\nint dx[] = {-1, 1, 0, 0, 1, 1, -1, -1};\nint dy[] = {0, 0, -1, 1, 1, -1, 1, -1};\n\nint ansl, ansv;\n\nvoid dfs(int cur){\n    if(tree.val[cur]){\n        if(tree.len[cur] > ansl && tree.isOK[cur]){\n            ansl = tree.len[cur];\n            ansv = tree.val[cur];\n        }\n    }\n    FOR(i, 26){\n        if(tree.ch[cur][i]){\n            dfs(tree.ch[cur][i]);\n        }\n    }\n}\n\nint main(){\n    int cur;\n    fre\n    wh(sf(\"%d%d\", &h, &w) != EOF){\n        if(!h && !w) break;\n        cur = 0; ansl = 0;\n        tree._clear();\n        FOR(i, h) sf(\"%s\", tmp[i]);\n        FOR(i, h) FOR(j, w){\n            FOR(k, 8){\n                int cnt = 0;\n                tmpB[cnt++] = tmp[i][j]; tmpB[cnt] = '\\0';\n                tree._insert(tmpB, ++cur);\n                int ni = i + dx[k], nj = j + dy[k];\n                wh(ni < 0) ni += h; wh(nj < 0) nj += w;\n                ni = ni % h; nj = nj % w;\n                wh(!(ni == i && nj == j)){\n                    tmpB[cnt++] = tmp[ni][nj]; tmpB[cnt] = '\\0';\n                    tree._insert(tmpB, ++cur);\n                    ni = ni + dx[k]; nj = nj + dy[k];\n                    ni = ni % h; nj = nj % w;\n                    wh(ni < 0) ni += h; wh(nj < 0) nj += w;\n                }\n            }\n        }\n        dfs(0);\n        if(ansl < 2)\n            pf(\"0\\n\");\n        else\n            cout << tree.mp[ansv] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<map>\nusing namespace std;\n\nvoid chmax(string& s1, string& s2) {\n    if (s1.size() > s2.size()) return; \n    else if (s1.size() < s2.size()) {\n        s1 = s2;\n        return;\n    }\n    else {\n        for (int i = 0; i < s1.size(); i++) {\n            if (s1[i] > s2[i]) {\n                s1 = s2;\n                return;\n            }\n            else if (s1[i] < s2[i]) return;\n        }\n    }\n}\n\nbool is_palindrome(string s) {\n    int n = s.size();\n    for (int i = 0; i < n / 2; i++) {\n        if (s[i] != s[n - i - 1]) return false;\n    }\n    return true;\n}\n\nint dh[3] = {-1, 0, 1}, dw[3] = {-1, 0, 1};\n\nvoid solve(int h, int w) {\n    vector<string> grid(h);\n    for (int i = 0; i < h; i++) {\n        cin >> grid[i];\n    }\n    vector<string> s;\n    map<string, int> cnt;\n    for (int i = 0; i < h; i++) {\n        for (int j = 0; j < w; j++) {\n            for (int k = 0; k < 3; k++) {\n                for (int l = 0; l < 3; l++) {\n                    if (k == 1 && l == 1) continue;\n                    int now_h = i, now_w = j;\n                    string now_s;\n                    do {\n                        now_s.push_back(grid[now_h][now_w]);\n                        s.push_back(now_s);\n                        cnt[now_s]++;\n                        now_h = (now_h + dh[k] + h) % h;\n                        now_w = (now_w + dw[l] + w) % w;\n                    } while (now_h != i || now_w != j);\n                }\n            }\n        }\n    }\n    sort(s.begin(), s.end());\n    s.erase(unique(s.begin(), s.end()), s.end());\n    string ans = \"\";\n    for (int i = 0; i < s.size(); i++) {\n        if (s[i].size() == 1) continue;\n        if (cnt[s[i]] < 2 && !is_palindrome(s[i])) continue;\n        chmax(ans, s[i]);\n    }\n    if (ans == \"\") cout << 0 << endl;\n    else cout << ans << endl;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int H, W;\n    while (true) {\n        cin >> H >> W;\n        if (H == 0 && W == 0) break;\n        solve(H, W);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nint main() {\n\tfor (;;) {\n\t\tint h, w; cin >> h >> w;\n\t\tif (h == 0) break;\n\t\tvector<string> a(h);\n\t\tfor (int i = 0; i < h; i++) cin >> a[i];\n\t\tmap<string, int> m;\n\t\tfor (int i = 0; i < h; i++)\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\tfor (int di = -1; di <= 1; di++)\n\t\t\t\t\tfor (int dj = -1; dj <= 1; dj++) {\n\t\t\t\t\t\tif (!di && !dj) continue;\n\t\t\t\t\t\tstring s;\n\t\t\t\t\t\tint _i = i, _j = j;\n\t\t\t\t\t\tfor (;;) {\n\t\t\t\t\t\t\ts += a[_i][_j];\n\t\t\t\t\t\t\tm[s]++;\n\t\t\t\t\t\t\t_i = (_i + di + h) % h;\n\t\t\t\t\t\t\t_j = (_j + dj + w) % w;\n\t\t\t\t\t\t\tif (_i == i && _j == j) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\tstring ans;\n\t\tfor (map<string, int>::iterator it = m.begin(); it != m.end(); it++) {\n\t\t\tstring s = it->first;\n\t\t\tint x = it->second;\n\t\t\tif (x <= 1) continue;\n\t\t\tif (s.length() > ans.length() || (s.length() == ans.length() && s < ans))\n\t\t\t\tans = s;\n\t\t}\n\t\tif (ans.length() < 2) ans = \"0\";\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <vector>\n#include <cstdlib>\n#include <string>\n#include <set>\n#include <ctime>\nusing namespace std;\n\nint dx[8]={0,0,1,1,1,-1,-1,-1},dy[8]={1,-1,0,-1,1,0,-1,1};\n\nstring s[2000],temp;\n\nchar str[30][30];\n\nint main()\n{\n    int n,m,i,j,x,y;\n    while(scanf(\"%d%d\",&n,&m)==2)\n    {\n        if(!n&&!m)\n            break;\n        for(i=0;i<n;i++)\n            scanf(\"%s\",str[i]);\n        int num=0,l=0,ans=0,l1,l2,d;\n        for(i=0;i<n;i++)\n        {\n            for(j=0;j<m;j++)\n            {\n                for(d=0;d<8;d++)\n                {\n                    x=i;\n                    y=j;\n                    temp=\"\";\n                    temp+=str[x][y];\n                    while(1)\n                    {\n                        x+=dx[d];\n                        y+=dy[d];\n                     //   printf(\"%d %d %d %d %d\\n\",i,j,d,x,y);\n                        if(x>=n)\n                            x-=n;\n                        if(y>=m)\n                            y-=m;\n                        if(x<0)\n                            x+=n;\n                        if(y<0)\n                            y+=m;\n                        if(x==i&&y==j)\n                            break;\n                        temp+=str[x][y];\n                    }\n                    s[num++]=temp;\n               //     cout<<temp<<endl;\n                }\n            }\n        }\n        sort(s,s+num);\n        for(i=1;i<num;i++)\n        {\n            l1=s[i-1].size();\n            l2=s[i].size();\n            for(j=0;j<l1&&j<l2;j++)\n            {\n                if(s[i-1][j]!=s[i][j])\n                    break;\n            }\n            if(j>l)\n            {\n                l=j;\n                ans=i;\n            }\n        }\n        if(l<2)\n            printf(\"0\\n\");\n        else\n        {\n            for(i=0;i<l;i++)\n                printf(\"%c\",s[ans][i]);\n            printf(\"\\n\");\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n#define MAX_N 10\n#define MAX_M 20\nint n,m;\nchar table[MAX_N][MAX_M];\n//向上\nvoid DFS1(int i,int j,int dep,string& s)\n{\n\tif(dep==n)\n\t\treturn ;\n\ts += table[i][j];\n\tif(i==0)\n\t\tDFS1(n-1,j,dep+1,s);\n\telse\n\t\tDFS1(i-1,j,dep+1,s);\n\treturn;\n}\n// 向右上\nvoid DFS2(int i,int j,int dep,string& s)\n{\n\tif(dep==n*m)\n\t\treturn ;\n\ts += table[i][j];\n\tint nxt_i=i-1,nxt_j=j+1;\n\tif(nxt_i == -1)\n\t\tnxt_i = n-1;\n\tif(nxt_j == m)\n\t\tnxt_j = 0;\n\tDFS2(nxt_i,nxt_j,dep+1,s);\n}\n//向右\nvoid DFS3(int i,int j,int dep,string& s)\n{\n\tif(dep==m)\n\t\treturn ;\n\ts += table[i][j];\n\tif(j==m-1)\n\t\tDFS3(i,0,dep+1,s);\n\telse\n\t\tDFS3(i,j+1,dep+1,s);\n\treturn;\n}\n//向右下\nvoid DFS4(int i,int j,int dep,string& s)\n{\n\tif(dep==n*m)\n\t\treturn ;\n\ts += table[i][j];\n\tint nxt_i=i+1,nxt_j=j+1;\n\tif(nxt_i == n)\n\t\tnxt_i = 0;\n\tif(nxt_j == m)\n\t\tnxt_j = 0;\n\tDFS4(nxt_i,nxt_j,dep+1,s);\n}\nvoid DFS5(int i,int j,int dep,string& s)\n{\n\tif(dep==n)\n\t\treturn ;\n\ts += table[i][j];\n\tif(i==n-1)\n\t\tDFS5(0,j,dep+1,s);\n\telse\n\t\tDFS5(i+1,j,dep+1,s);\n\treturn;\n}\n//左下\nvoid DFS6(int i,int j,int dep,string& s)\n{\n\tif(dep==n*m)\n\t\treturn ;\n\ts += table[i][j];\n\tint nxt_i=i+1,nxt_j=j-1;\n\tif(nxt_i == n)\n\t\tnxt_i = 0;\n\tif(nxt_j == -1)\n\t\tnxt_j = m-1;\n\tDFS6(nxt_i,nxt_j,dep+1,s);\n}\n//向左\nvoid DFS7(int i,int j,int dep,string& s)\n{\n\tif(dep==m)\n\t\treturn ;\n\ts += table[i][j];\n\tif(j==0)\n\t\tDFS7(i,m-1,dep+1,s);\n\telse\n\t\tDFS7(i,j-1,dep+1,s);\n\treturn;\n}\n//左上\nvoid DFS8(int i,int j,int dep,string& s)\n{\n\tif(dep==n*m)\n\t\treturn ;\n\ts += table[i][j];\n\tint nxt_i=i-1,nxt_j=j-1;\n\tif(nxt_i == -1)\n\t\tnxt_i = n-1;\n\tif(nxt_j == -1)\n\t\tnxt_j = m-1;\n\tDFS8(nxt_i,nxt_j,dep+1,s);\n}\nint main()\n{\n\t// freopen(\"in\",\"r\",stdin);\n\t\n\twhile(scanf(\"%d%d \",&n,&m)&&(n+m)){\n\t\tmemset(table,0,sizeof(table));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%s\",table[i]);\n\t\t}\n\t\t// for(int i=0;i<n;i++){\n\t\t// \tprintf(\"%s\\n\",table[i]);\n\t\t// }\n\t\tvector<string> totalStr;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\tstring s=\"\";\n\t\t\t\tDFS1(i,j,0,s);\n\t\t\t\ttotalStr.push_back(s);\n\t\t\t\ts=\"\";\n\t\t\t\tDFS2(i,j,0,s);\n\t\t\t\ttotalStr.push_back(s);\n\t\t\t\ts=\"\";\n\t\t\t\tDFS3(i,j,0,s);\n\t\t\t\ttotalStr.push_back(s);\n\t\t\t\ts=\"\";\n\t\t\t\tDFS4(i,j,0,s);\n\t\t\t\ttotalStr.push_back(s);\n\t\t\t\ts=\"\";\n\t\t\t\tDFS5(i,j,0,s);\n\t\t\t\ttotalStr.push_back(s);\n\t\t\t\ts=\"\";\n\t\t\t\tDFS6(i,j,0,s);\n\t\t\t\ttotalStr.push_back(s);\n\t\t\t\ts=\"\";\n\t\t\t\tDFS7(i,j,0,s);\n\t\t\t\ttotalStr.push_back(s);\n\t\t\t\ts=\"\";\n\t\t\t\tDFS8(i,j,0,s);\n\t\t\t\ttotalStr.push_back(s);\n\t\t\t}\n\t\t}\n\t\tsort(totalStr.begin(),totalStr.end());\n\t\tint Max = 1;\n\t\tstring ans ;\n\t\tfor(int i=0;i<totalStr.size()-1;i++){\n\t\t\tstring s1 = totalStr[i];\n\t\t\tstring s2 = totalStr[i+1];\n\t\t\tbool isOK=true;\n\t\t\tfor(int j=0;j<min(s1.length(),s2.length())&&isOK;j++){\n\t\t\t\tif(s1[j]!=s2[j]){\n\t\t\t\t\tif(j-1>Max){\n\t\t\t\t\t\t// cout << \"s1:\" << s1 << endl;\n\t\t\t\t\t\t// cout << \"s2:\" << s2 << endl;\n\t\t\t\t\t\tMax = j-1;\n\t\t\t\t\t\tans = s1.substr(0,j);\n\t\t\t\t\t}\n\t\t\t\t\tisOK = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(isOK){\n\t\t\t\tif(s1.length() < s2.length() && s1.length() > Max){\n\t\t\t\t\tMax = s1.length();\n\t\t\t\t\tans = s1;\n\t\t\t\t}\n\t\t\t\telse if(s1.length() >= s2.length() && s2.length()>Max){\n\t\t\t\t\tMax = s2.length();\n\t\t\t\t\tans = s2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(Max==1)\n\t\t\tputs(\"0\");\n\t\telse\n\t\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\n#define rep(i, n) for(int i=0; i<(n); ++i)\n#define mp(a, b) make_pair(a, b)\n\ntemplate<typename T, typename Compare = greater<T> >\ninline void chmax(T& t, T f, Compare comp){if(!comp(t, f))t = f;}\n\nint h, w;\n\nstring solve(vector<string>& patterns){\n    string res = \"0\";\n    set<string> spells;\n    rep(x, h)rep(y, w){\n        for(int dx=-1; dx<=1; ++dx){\n            for(int dy=-1; dy<=1; ++dy){\n                string spell = \"\";  spell += patterns[x][y];\n                for(int nx=(x+dx+h)%h, ny=(y+dy+w)%w; nx!=x || ny!=y; (nx+=(dx+h))%=h, (ny+=(dy+w))%=w){\n                    spell += patterns[nx][ny];\n                    if(!spells.insert(spell).second){\n                        chmax(res, spell, [](string& s, string& t){return mp(t.size(), s) < mp(s.size(), t);});\n                    }\n                }\n            }\n        }\n    }\n    return res;\n}\n\nint main(){\n    while(cin >> h >> w, h|w){\n        vector<string> patterns(h);\n        rep(i, h)cin >> patterns[i];\n        cout << solve(patterns) << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n//#include <unordered_set>\n#include <set>\n \nusing namespace std;\nchar field[1001][1001];\nbool used[1001][1001];\n \nint main(){\n  int H,W;\n  while(cin>>H>>W&&(H|W)){\n    for(int i=0;i<H;i++)\n      for(int j=0;j<W;j++)\n    cin>>field[i][j];\n    vector<string> vs;\n    for(int dy=-1;dy<=1;dy++){\n      for(int dx=-1;dx<=1;dx++){\n    if(dy==0&&dx==0)continue;\n    memset(used,0,sizeof(used));\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n        if(!(i==0||j==0||i==H-1||j==W-1))continue;\n        int cx=j;\n        int cy=i;\n        string s;\n        if(used[cy][cx])continue;\n        while(1){\n          used[cy][cx]=true;\n          s+=field[cy][cx];\n          cy+=dy;cx+=dx;\n          cy=(cy+H)%H;\n          cx=(cx+W)%W;\n          if(used[cy][cx])break;\n        }\n        vs.push_back(s);\n        //cout<<s<<endl;\n      }\n    }\n      }\n    }\n    //unordered_set<string> us;\n    set<string> us;\n    string cand;\n    for(int i=0;i<(int)vs.size();i++){\n      for(int j=0;j<(int)vs[i].size();j++){\n    for(int k=1;k<=(int)vs[i].size();k++){\n      string s;\n      for(int l=0;l<k;l++){\n        s+=vs[i][(j+l)%vs[i].size()];\n      }\n      if(us.count(s)==1){\n        if(cand==\"\"||cand.size()<s.size())\n          cand=s;\n        else if(cand.size()==s.size()&&cand>s)\n          cand=s;\n      }\n      else if(us.count(s)==0)\n        us.insert(s);\n    }\n      }\n    }\n    if(cand.size()>1)cout<<cand<<endl;\n    else cout<<0<<endl;\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint gcd(int a, int b){\n    while(a != b){\n        if(a > b) a = a - b; else b = b - a;\n    }\n    return a;\n}\n\nint lcm(int a, int b){\n    return ((a / gcd(a, b)) * b);\n}\n\nint main(){\n    int h, w;\n    while(true){\nchar torus[10][20];\n        string str[2048];\n        bool ok[2048];\n        int num = 0;\n\n        for(int i=0; i<2048; ++i){\n            str[i] = \"\";\n            ok[i] = true;\n        }\n\n        cin >> h >> w;\n        if(h==0 && w==0) break;\n\n        int cml = lcm(w, h);\n\n        for(int i=0; i<h; ++i){\n            for(int j=0; j<w; ++j){\n                cin >> torus[i][j];\n            }\n        }\n\n        //一番長い文字列をつくる\n\n        for(int y=0; y<h; ++y){\n            for(int x=0; x<w; ++x){\n                for(int i=0; i<h; ++i){\n                    str[num] += torus[(y+i)%h][x];\n                    str[num+1] += torus[h-(y+i)%h-1][x];\n                }\n                num += 2;\n            }\n        }\n        for(int y=0; y<h; ++y){\n            for(int x=0; x<w; ++x){\n                for(int i=0; i<w; ++i){\n                    str[num] += torus[y][(x+i)%w];\n                    str[num+1] += torus[y][w-(x+i)%w-1];\n                }\n                num += 2;\n            }\n        }\n        for(int y=0; y<h; ++y){\n            for(int x=0; x<w; ++x){\n                for(int i=0; i<cml; ++i){\n                    str[num] += torus[(y+i)%h][(x+i)%w];\n                    str[num+1] += torus[(y+i)%h][w-(x+i)%w-1];\n                    str[num+2] += torus[h-(y+i)%h-1][(x+i)%w];\n                    str[num+3] += torus[h-(y+i)%h-1][w-(x+i)%w-1];\n                }\n                num += 4;\n            }\n        }\n\n\n        string result = \"\";\n\n        sort(str, str+num);\n\n        for(int i=1; i<cml; ++i){\n            for(int j=num-1; j>0; --j){\n                if(ok[j] && str[j].length() >= i && str[j-1].length() >= i){\n                    if(str[j].substr(0, i) == str[j-1].substr(0, i)){\n                        result = str[j];\n                        result.resize(i);\n                    }else{\n                        ok[j] = false;\n                    }\n                }\n            }\n        }\n\n        cout << ((result.length() == 1) ? \"0\" : result) << endl;\n\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <tuple>\n#include <assert.h>\n#include <deque>\n#include <bitset>\n#include <iomanip>\n#include <limits>\n#include <chrono>\n#include <random>\n#include <array>\n#include <unordered_map>\n#include <functional>\n#include <complex>\n#include <numeric>\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nconstexpr long long MAX = 5100000;\nconstexpr long long INF = 1LL << 60;\nconstexpr int inf = 1 << 28;\nconstexpr long long mod = 1000000007LL;\n//constexpr long long mod = 998244353LL;\n\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef long long ll;\n\nint dh[8] = { 0,1,1,1,0,-1,-1,-1 };\nint dw[8] = { 1,1,0,-1,-1,-1,0,1 };\nvector<string> vs;\nmap<string, ll> mp;\nvoid solve() {\n\tint H, W; cin >> H >> W; if (H == 0 and W == 0) exit(0);\n\tvs.resize(H); for (int i = 0; i < H; i++) cin >> vs[i];\n\tmp.clear();\n\tfor (int h = 0; h < H; h++) {\n\t\tfor (int w = 0; w < W; w++) {\n\t\t\tfor (int i = 0; i < 8; i++) {\n\t\t\t\tint nh = h;\n\t\t\t\tint nw = w;\n\t\t\t\tstring s;\n\t\t\t\ts += vs[nh][nw];\n\t\t\t\twhile (1) {\n\t\t\t\t\tnh += dh[i];\n\t\t\t\t\tnw += dw[i];\n\t\t\t\t\tif (nh >= H) nh = 0;\n\t\t\t\t\tif (nw >= W) nw = 0;\n\t\t\t\t\tif (nh < 0) nh = H - 1;\n\t\t\t\t\tif (nw < 0) nw = W - 1;\n\t\t\t\t\tif (nh == h and nw == w) break;\n\t\t\t\t\ts += vs[nh][nw];\n\t\t\t\t\tmp[s]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tstring res;\n\tfor (auto& p : mp) {\n\t\tif (p.second >= 2) {\n\t\t\tif (res.size() < p.first.size()) res = p.first;\n\t\t\telse if (res.size() == p.first.size() and res > p.first) res = p.first;\n\t\t}\n\t}\n\tif (res == \"\") cout << \"0\" << \"\\n\";\n\telse cout << res << \"\\n\";\n}\n\nint main()\n{\n\t\n\t/*\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\t*/\n\n\tint kkt = 89;\n\twhile (kkt) {\n\t\tsolve();\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long int dx[] = { 0,1,1,1,0,-1,-1,-1 };\nlong long int dy[] = { 1,1,0,-1,-1,-1,0,1 };\n\nint main()\n{\n\tlong long int M , N;\n\twhile(cin >> M >> N , M || N)\n\t{\n\t\tvector<vector<char>>D(M , vector<char>(N));\n\t\tset<string>SS;\n\t\tstring ans;\n\t\tfor(size_t i = 0; i < M; i++)\n\t\t{\n\t\t\tfor(size_t j = 0; j < N; j++)\n\t\t\t{\n\t\t\t\tcin >> D[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(long long int i = 0; i < M; i++)\n\t\t{\n\t\t\tfor(long long int j = 0; j < N; j++)\n\t\t\t{\n\t\t\t\tlong long int startx = j , starty = i;\n\t\t\t\tfor(long long int k = 0; k < 8; k++)\n\t\t\t\t{\n\t\t\t\t\tlong long int p = 1;\n\t\t\t\t\tstring s;\n\t\t\t\t\ts.push_back(D[starty][startx]);\n\t\t\t\t\twhile(!( ( startx + p*dx[k] + N * 2000 ) % N == startx && ( starty + p*dy[k] + M * 2000 ) % M == starty ))\n\t\t\t\t\t{\n\t\t\t\t\t\ts.push_back(D[( starty + p*dy[k] + M * 205 ) % M][( startx + p*dx[k] + N * 205 ) % N]);\n\t\t\t\t\t\tif(s.length() > ans.length())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(SS.find(s) != SS.end())\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tans = s;\n\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tSS.insert(s);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tp++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans.length() <= 1)\n\t\t{\n\t\t\tcout << 0 << endl;\n\t\t} else\n\t\t{\n\t\t\tauto ans2=ans;\n\t\t\treverse(ans2.begin(),ans2.end());\n\t\t\tcout << (ans<ans2?ans:ans2) << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\nusing namespace std;\n\n\nint main() {\n    int H, W;\n    while (cin >> H >> W, H) {\n        string field[10];\n        for (int i = 0; i < H; i++) {\n            cin >> field[i];\n        }\n\n        vector<string> cand;\n        for (int y = 0; y < H; y++) {\n            for (int x = 0; x < W; x++) {\n                for (int dx = -1; dx <= 1; dx++) {\n                    for (int dy = -1; dy <= +1; dy++) {\n                        if (dx == 0 && dy == 0) continue;\n                        bool visited[15][25] = { 0 };\n                        int nx = x, ny = y;\n                        string spell;\n                        while (!visited[ny][nx]) {\n                            visited[ny][nx] = true;\n                            spell += field[ny][nx];\n                            cand.push_back(spell);\n                            nx = (nx + dx + W) % W;\n                            ny = (ny + dy + H) % H;\n                        }\n                    }\n                }\n            }\n        }\n        \n        string ans = \"\";\n        sort(cand.begin(), cand.end());\n        for (int i = 1; i < (int)cand.size(); ++i) {\n            if (cand[i].size() == 1) continue;\n            if (cand[i] != cand[i - 1]) continue;\n            if (ans.size() < cand[i].size() || ans > cand[i]) {\n                ans = cand[i];\n            }\n        }\n        if (ans == \"\") ans = \"0\";\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n\nint H, W;\nvector<string> F;\n\nint dx[8] = {-1,0,1,0,-1,1,1,-1};\nint dy[8] = {0,-1,0,1,-1,-1,1,1};\n\nvoid go(int y, int x, int dir, int sy, int sx, map<string, int>& mp) {\n  string s;\n  while(1) {\n    s += F[y][x];\n    int ny = y + dy[dir];\n    int nx = x + dx[dir];\n    if(ny >= H) { ny = 0; }\n    if(ny < 0) { ny = H-1; }\n    if(nx >= W) { nx = 0; }\n    if(nx < 0) { nx = W-1; }\n    if(ny == sy && nx == sx) { break; }\n    y = ny, x = nx;\n    mp[s]++;\n  }\n}\n\nint main() {\n\n  for(; cin >> H >> W && (H | W);) {\n\n    F.clear(); rep(i, H) F.resize(H);\n    vector<string> v;\n    rep(i, H) cin >> F[i];\n    map<string, int> mp;\n    rep(i, H) rep(j, W) {\n      rep(k, 8) {\n        go(i, j, k, i, j, mp);//] ++;\n      }\n    }\n\n    vector<string> u;\n    for(auto && e: mp) {\n      if(e.first.size() > 1 && e.second > 1) {\n        u.push_back(e.first);\n      }\n    }\n\n    if(u.empty()) {\n      cout << 0 << endl;\n    }\n    else {\n      sort(all(u), [&](string const& s, string const& t){ int n=s.size(),m=t.size(); return n != m ? n > m : s < t; });\n      cout << u[0] << endl;\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF 1001000100010001000\n#define MOD 1000000007\n#define EPS 1e-10\n#define int long long\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define Rep(i, N) for (int i = 1; i < N; i++)\n#define For(i, a, b) for (int i = (a); i < (b); i++)\n#define pb push_back\n#define mp make_pair\n#define i_i pair<int, int>\n#define vi vector<int>\n#define vvi vector<vi >\n#define vb vector<bool>\n#define vvb vector<vb >\n#define vp vector< i_i >\n#define all(a) (a).begin(), (a).end()\n#define Int(x) int x; scanf(\"%lld\", &x);\n\n//int dxy[5] = {0, 1, 0, -1, 0};\nint dx[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nint dy[8] = {1, 0, -1, 1, -1, 1, 0, -1};\n// assign\n\nstring comp(string a, string b);\n\nsigned main()\n{\n    int n, m;\n    while (cin >> n >> m, n) {\n        vector<string> donut(n);\n        rep(i, n) {\n            cin >> donut[i];\n        }\n        set<string> can;\n        string ans = \"z\";\n        rep(i, n) {\n            rep(j, m) {\n                rep(k, 8) {\n                    vvb used(n, vb(m, false));\n                    string spell;\n                    int x = i, y = j;\n                    while (!used[x][y]) {\n                        spell.pb(donut[x][y]);\n                        used[x][y] = true;\n                        if (can.find(spell) != can.end()) {\n                            ans = comp(ans, spell);\n                        } else {\n                            can.insert(spell);\n                        }\n                        x = (x + dx[k] + n) % n; y = (y + dy[k] + m) % m;\n                    }\n                }\n            }\n        }\n        cout << ((ans.length() > 1) ? ans : 0) << endl;\n    }\n    return 0;\n}\n\nstring comp(string a, string b)\n{\n    if (a.length() < b.length()) {\n        return b;\n    } else if (a.length() > b.length()) {\n        return a;\n    } else {\n        rep(i, a.length()) {\n            if (a[i] < b[i]) {\n                return a;\n            } else if (a[i] > b[i]) {\n                return b;\n            }\n        }\n    }\n    return a;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <algorithm>\n#include <string>\n#include <iostream>\n#include <map>\n\nusing namespace std;\n#define loop(i,a,b) for(int i=(a);i<int(b);i++)\n#define rep(i,b) loop(i,0,b)\n\nint dx[]={1,1,1,0};\nint dy[]={-1,0,1,1};\n\nstring g[100];\n\nint h,w;\nint main(){\n    while(cin>>h>>w && h){\n        map<string,int> m;\n        rep(i,h)cin>>g[i];\n        rep(i,h)rep(j,w){\n            rep(d,4){\n                string s;\n                for(int ii=i, jj=j; s.size()==0 || ii!=i || jj!=j;\n                    ii=(ii+h+dy[d])%h, jj=(jj+w+dx[d])%w){\n                    s += g[ii][jj];\n                    m[s]++;\n                    reverse(s.begin(),s.end());\n                    m[s]++;\n                    reverse(s.begin(),s.end());\n                }\n            }\n        }\n        string ans;\n        for(auto& p:m){\n            //cout << p.first << \" \" << p.second << endl;\n            if(p.second < 2) continue;\n            if(ans.size() > p.first.size()) continue;\n            if(ans.size() == p.first.size()){\n                ans = min(ans,p.first);\n            }\n            if(ans.size() < p.first.size()) ans = p.first;\n        }\n        if(ans.size() <= 1) ans=\"0\";\n        cout<<ans<<endl;\n        getchar();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <vector>\nusing namespace std;\n#define REP(i,x)for(int i=0;i<x;i++)\n\nstring res;\nint H,W,dx,dy,min_len;\nchar s[200];\nchar MAP[11][22];\nbool visit[20][20];\nvector<string> ss;\nvoid dfs(int x,int y,int k){\n  if(visit[y][x]){\n    ss.push_back(string(s));\n    return;\n  }\n  s[k]=MAP[y][x];  visit[y][x]=1;\n  dfs((x + dx + W) % W, (y + dy + H) % H, k + 1);\n  s[k]=0;  visit[y][x]=0;\n}\nint main() {\n  while(scanf(\"%d%d\",&W,&H)){\n    REP(i,H)scanf(\"%s\",MAP[i]);\n    ss.clear();\n    min_len=1; res=\"0\";\n    REP(y,H)REP(x,W){\n      for(dx=-1;dx<=1;dx++){\n        for(dy=-1;dy<=1;dy++){\n          if(dx|dy)dfs(x,y,0);\n        }\n      }\n    }\n    string res = \"0\";\n    sort(ss.begin(),ss.end());\n    REP(i,ss.size()-1){\n      int len = 0;\n      REP(k,min(ss[i].size(),ss[i+1].size())){\n        if(ss[i][k]==ss[i+1][k])len++;\n      }\n      if(len < res.size())continue;\n      if(res.size() == len){\n        res = min(res, ss[i].substr(0,len));\n      }else{\n        res = ss[i].substr(0, len);\n      }\n    }\n    puts(res.c_str());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cctype>\nusing namespace std;\n\ntypedef long long ll;\n\n#define REP(i,n,m) for(int i=n;i<m;i++)\n#define rep(i,n) REP(i,0,n)\n\n#define MAX_H (10+10)\n#define MAX_W (20+10)\n\nint h,w;\nchar t[MAX_H][MAX_W];\nset<string> tmp;\n\nint dx[8] = {0,1,1,1,0,-1,-1,-1};\nint dy[8] = {-1,-1,0,1,1,1,0,-1};\n\nvoid solve(){\n  tmp.clear();\n  string res = \"\";\n  \n  /*\n  rep(i,h) rep(j,w){\n    string s = \"\";\n    s += t[i][j];\n    cout << \"res=\" << res << endl;\n    if(tmp.find(s) != tmp.end()){\n      if(s.size() > res.size()) res = s;\n      else if(s.size() == res.size() && s < res) res = s;\n    }\n    else{\n      tmp.insert(s);\n    }\n  }\n  */\n  \n  rep(i,h) rep(j,w) rep(k,8){\n    int sx = j, sy = i;\n    int x = j, y = i;\n    string s = \"\";\n    s += t[y][x];\n    x += w+dx[k]; x %= w;\n    y += h+dy[k]; y %= h;\n\n    while(!(x == sx && y == sy)){\n      s += t[y][x];\n      x += w+dx[k]; x %= w;\n      y += h+dy[k]; y %= h;\n\n//      cout << \"sx=\" << sx << \",sy=\" << sy << endl;\n//      cout << \"x=\" << x << \",y=\" << y << endl;\n//      cout << \"s=\" << s << endl;\n\n      \n      if(tmp.find(s) != tmp.end()){\n        if(s.size() > res.size()) res = s;\n        else if(s.size() == res.size() && s < res) res = s;\n      }\n      else{\n        tmp.insert(s);\n      }\n    }\n  }\n\n  if(res.size() == 0) cout << 0 << endl;\n  else cout << res << endl;\n}\n\nvoid solve2(string s){\n  \n}\n\nint main(){\n  while(true){\n    cin >> h >> w;\n    if(h == 0 && w == 0) break;\n    rep(i,h) cin >> t[i];\n    /*\n    if(h == 1){\n      s = t[0];\n      solve2(s);\n    }\n    else if(w == 1){\n      rep(i,h) s += t[0][i];\n      solve2(s);\n    }\n    */\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\nconst int dx[] = {-1,-1,-1, 0, 0, 1, 1, 1};\nconst int dy[] = {-1, 0, 1,-1, 1,-1, 0, 1};\n\ntypedef map<string,int>M;\nM spell;\nstring mat[10];\n\nvoid Search(int sx,int sy, int a, int h, int w)\n{\n\tbool f[10][20]={};\n\tstring str;\n\tint x,y;\n\tfor(x=sx, y=sy; ; x=(x+dx[a]+w)%w, y=(y+dy[a]+h)%h)\n\t{\n\t\tif(f[y][x])\n\t\t\tbreak;\n\t\tf[y][x]=true;\n\t\tstr+=mat[y][x];\n\t\t++spell[str];\n\t}\n}\n\nint main()\n{\n\tint h,w;\n\twhile(cin>>h>>w,h)\n\t{\n\t\tfor(int i=0; i<h; ++i)\n\t\t\tcin >> mat[i];\n\n\t\tspell.clear();\n\t\tfor(int x=0; x<w; ++x)\n\t\t\tfor(int y=0; y<h; ++y)\n\t\t\t\tfor(int a=0; a<8; ++a)\n\t\t\t\t\tSearch(x,y,a,h,w);\n\n\t\tstring res(\"\");\n\t\tfor(M::iterator ite=spell.begin(); ite!=spell.end(); ++ite)\n\t\t{\n\t\t\tif(ite->second<=1)\n\t\t\t\tcontinue;\n\t\t\tif(res.size()<ite->first.size() || res>ite->first)\n\t\t\t\tres=ite->first;\n\t\t}\n\t\tif(res.size()<=1)\n\t\t\tres=\"0\";\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <set>\n\n#define sz(x) int((x).size())\n#define phb push_back\nusing namespace std;\n\nconst int kDir[8][2] = {{1, 0}, {1, 1}, {0, 1}, {-1, 1}, {-1, 0}, {-1, -1}, {0, -1}, {1, -1}};\n\nint H, W;\nstring P[10];\n\nvoid read();\nvoid solve();\n\nint main() {\n\twhile (cin >> H >> W, H + W)\n\t\tread(), solve();\n\t\n\treturn 0;\n}\n\nvoid read() {\n\tfor (int i = 0; i < H; ++i)\n\t\tcin >> P[i];\n}\n\nvoid solve() {\n\tstatic int visit[10][20], vst_cnt;\n\tstring res;\n\tset< string > s;\n\tauto cmpf = [&] (const string &ra, const string &rb) -> string {\n\t\tif (sz(ra) != sz(rb))\n\t\t\treturn sz(ra) > sz(rb) ? ra : rb;\n\t\telse\n\t\t\treturn min(ra, rb);\n\t};\n\t\n\tfor (int i = 0; i < H; ++i)\n\t\tfor (int j = 0; j < W; ++j)\n\t\t\tfor (int d = 0; d < 8; ++d) {\n\t\t\t\tstring t;\n\t\t\t\tvector< string > v;\n\t\t\t\t\n\t\t\t\tint i_ = i, j_ = j;\n\t\t\t\t++vst_cnt;\n\t\t\t\twhile (visit[i_][j_] != vst_cnt) {\n\t\t\t\t\tt.phb(P[i_][j_]), visit[i_][j_] = vst_cnt;\n\t\t\t\t\tif (sz(t) >= 2) {\n\t\t\t\t\t\tif (s.count(t) != 0)\n\t\t\t\t\t\t\tres = cmpf(res, t);\n\t\t\t\t\t\tv.phb(t);\n\t\t\t\t\t}\n\t\t\t\t\ti_ = (i_ + kDir[d][0] + H) % H, j_ = (j_ + kDir[d][1] + W) % W;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor (auto itr = v.begin(); itr != v.end(); ++itr)\n\t\t\t\t\ts.insert(*itr);\n\t\t\t}\n\t\n\tcout << (res != \"\" ? res : \"0\") << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<string>vec;\nchar c[20][20]; int H, W; bool used[20][20];\nint dx[8] = { 1,1,1,0,-1,-1,-1,0 };\nint dy[8] = { -1,0,1,1,1,0,-1,-1 };\nint main() {\n\twhile (true) {\n\t\tcin >> H >> W; vec.clear(); if (H == 0)break;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++)cin >> c[i][j];\n\t\t}\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tfor (int k = 0; k < 8; k++) {\n\t\t\t\t\tfor (int l = 0; l < 400; l++)used[l / 20][l % 20] = false;\n\t\t\t\t\tint cx = i, cy = j; string S; S += c[cx][cy]; used[cx][cy] = true;\n\t\t\t\t\twhile (true) {\n\t\t\t\t\t\tcx += dx[k]; cy += dy[k];\n\t\t\t\t\t\tif (cx < 0)cx += H; if (cx >= H)cx -= H;\n\t\t\t\t\t\tif (cy < 0)cy += W; if (cy >= W)cy -= W;\n\t\t\t\t\t\tif (used[cx][cy] == true)break;\n\t\t\t\t\t\tused[cx][cy] = true; S += c[cx][cy]; vec.push_back(S);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(vec.begin(), vec.end()); string T = \"0\";\n\t\tfor (int i = 1; i < vec.size(); i++) {\n\t\t\tif (vec[i - 1] == vec[i]) {\n\t\t\t\tif (vec[i].size()>T.size())T = vec[i];\n\t\t\t\telse if (vec[i].size() == T.size())T = min(T, vec[i]);\n\t\t\t}\n\t\t}\n\t\tcout << T << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint main(){\n  int h,w;\n  int i,j,k;\n  int ai[]={ 1, 1, 1, 0, 0,-1,-1,-1};\n  int aj[]={ 1, 0,-1, 1,-1, 1, 0,-1};\n  cin >> h >> w;\n  while(h!=0){\n    string str[10];\n    for(i=0;i<h;i++) cin >> str[i];\n    vector <string> li;\n    vector <string> ans;\n    int mal=1;\n    for(i=0;i<h;i++){\n      //cout << i << endl;\n      for(j=0;j<w;j++){\n\tfor(k=0;k<8;k++){\n\t  int bi=i,bj=j;\n\t  string buf;\n\t  buf += str[i][j];\n\t  bi+=ai[k];bj+=aj[k];\n\t  if(bi<0) bi=h-1;\n\t  if(bi>=h) bi=0;\n\t  if(bj<0) bj=w-1;\n\t  if(bj>=w) bj=0;\n\t  while(bi!=i||bj!=j){\n\t    buf+=str[bi][bj];\n\t    if(buf.size()>=mal){\n\t      if(find(li.begin(),li.end(),buf)!=li.end()) {\n\t\tif(buf.size()>mal) ans.clear();\n\t\tans.push_back(buf);\n\t\tmal=buf.size();\n\t      }else{\n\t\tli.push_back(buf);\n\t      }\n\t    }\n\t    bi+=ai[k];bj+=aj[k];\n\t    if(bi<0) bi=h-1;\n\t    if(bi>=h) bi=0;\n\t    if(bj<0) bj=w-1;\n\t    if(bj>=w) bj=0;\n\t  }\n\t}\n      }\n    }\n    //for(i=0;i<li.size();i++) cout << li[i] << endl;\n    sort(ans.begin(),ans.end());\n    //for(i=0;i<ans.size();i++) cout << ans[i] << endl;\n    if(ans.size()!=0) cout << ans[0] << endl;\n    else cout << 0 << endl;\n    cin >> h >> w;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <string>\n#include <algorithm>\n#define  MAX_H 10\nusing namespace std;\n\nmap<string, int> mp;\nint dx[8] = {1, 0, -1, 0, 1, 1, -1, -1};\nint dy[8] = {0, 1, 0, -1, 1, -1, 1, -1};\n\nstring s[MAX_H];\nint h, w;\n\nint mystrcmp(string a, string b) {\n    if (a.size() > b.size()) return 1;\n    if (a.size() < b.size()) return -1;\n\n    for (int i = 0; i < a.size(); i++) {\n        if (a[i] < b[i]) return 1;\n        if (a[i] > b[i]) return -1;\n    }\n    return 0;\n}\n\nvoid dfs(int x, int y, int xnow, int ynow, int k, string str) {\n    int xnext = (xnow + dx[k] + h) % h;\n    int ynext = (ynow + dy[k] + w) % w;\n\n    mp[str]++;\n\n    if (x == xnext && y == ynext) return;\n    \n    string str2;\n    str2.push_back(s[xnext][ynext]);\n    dfs(x, y, xnext, ynext, k, str + str2);\n}\n\nint main() {\n    while (true) {\n        for (int i = 0; i < MAX_H; i++) {\n            s[i].erase();\n        }\n        mp.clear();\n\n        cin >> h >> w;\n        if (h == 0 && w == 0) return 0;\n        for (int i = 0; i < h; i++) {\n            cin >> s[i];\n        }\n    \n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                for (int k = 0; k < 8; k++) {\n                    string str;\n                    str.push_back(s[i][j]);\n                    dfs(i, j, i, j, k, str);\n                }\n            }\n        }\n        \n        string ans;\n        for (map<string, int>::const_iterator itr = mp.begin(); itr != mp.end(); ++itr) {\n//            cout << itr->first << \" \" << itr->second << endl;\n            if (itr == mp.begin()) {\n                ans += itr->first;\n                continue;\n            }\n            if (itr->second > 1 && mystrcmp(itr->first, ans) > 0) {\n                ans.erase();\n                ans += itr->first;\n            }\n        }\n\n        if (ans.size() >= 2) cout << ans << endl;\n        else cout << 0 << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nint H, W;\nvector<string> F;\n\nint dx[8] = {-1,0,1,0,-1,1,1,-1};\nint dy[8] = {0,-1,0,1,-1,-1,1,1};\n\nunordered_map<string, int> mp;\n\nvoid go(int y, int x, int dir, int sy, int sx) {\n  string s;\n  while(1) {\n    s += F[y][x];\n    int ny = y + dy[dir];\n    int nx = x + dx[dir];\n    if(ny >= H) { ny = 0; }\n    if(ny < 0) { ny = H-1; }\n    if(nx >= W) { nx = 0; }\n    if(nx < 0) { nx = W-1; }\n    if(ny == sy && nx == sx) { break; }\n    y = ny, x = nx;\n    mp[s]++;\n  }\n}\n\nint main() {\n\n  for(; cin >> H >> W && (H | W);) {\n\n    F.clear(); rep(i, H) F.resize(H);\n    vector<string> v;\n    rep(i, H) cin >> F[i];\n    mp.clear();\n    rep(i, H) rep(j, W) {\n      rep(k, 8) {\n        go(i, j, k, i, j);\n      }\n    }\n\n    vector<string> u;\n    for(auto && e: mp) {\n      if(e.first.size() > 1 && e.second > 1) {\n        u.push_back(e.first);\n      }\n    }\n\n    if(u.empty()) {\n      cout << 0 << endl;\n    }\n    else {\n      sort(all(u), [&](string const& s, string const& t){ int n=s.size(),m=t.size(); return n != m ? n > m : s < t; });\n      cout << u[0] << endl;\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stdio.h>\n#include <set>\n\nusing namespace std;\n\n#define dirmax 8\n\nint l[2];\nint dir[8][2] = { {0,1}, {1,0}, {-1,0}, {0,-1}, {1,1}, {-1,1}, {1,-1}, {-1,-1} };\nstring ans;\n\nvoid search( set<string> *v, int pos[2] , char ch[10][20]){\n\n\tfor(int i = 0; i < dirmax; i++) {\n\t\tstring str;\n\t\tint cpos[] = { pos[0], pos[1] };\n\n\t\tstr += ch[pos[0]][pos[1]];\n\n\t\twhile( 1 ) {\n\t\t\tfor(int j = 0; j < 2; j++) {\n\t\t\t\tcpos[j] += dir[i][j];\n\t\t\t\tif( cpos[j] < 0 ) cpos[j] = l[j] - 1;\n\t\t\t\tif( cpos[j] >= l[j] ) cpos[j] = 0;\n\t\t\t}\n\t\t\tif( cpos[0] == pos[0] && cpos[1] == pos[1] ) break;\n\n\t\t\tstr += ch[cpos[0]][cpos[1]];\n\t\t\t\n\t\t\tif( v->find(str) != v->end() ) {\n \t\t\t\tif( ( str.length() > ans.length() ) || ( str.length() == ans.length() && str < ans ) ) {\n\t\t\t\t\tans = str;\n\t\t\t\t}\n\t\t\t} else \n\t\t\t\tv->insert(str);\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tcin >> l[0] >> l[1];\n\t\tif( l[0] == 0 && l[1] == 0 ) break;\n\n\t\tchar donut[10][20];\n\t\tint pos[2];\n\t\tans = \"\";\n\n\t\tset< string > strs;\n\n\t\t//入力を取得する\n\t\tfor(int i = 0; i < l[0]; i++)\n\t\t\tcin >> donut[i];\n\n\t\t\n\t\tfor(pos[0] = 0; pos[0] < l[0]; pos[0]++)\n\t\t\tfor(pos[1] = 0; pos[1] < l[1]; pos[1]++)\n\t\t\t\tsearch( &strs, pos, donut );\n\n\t\tif(ans == \"\") \n\t\t\tcout << 0 << endl;\n\t\telse \n\t\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint dx[] = {1,0,-1,0,1,-1,1,-1};\nint dy[] = {0,1,0,-1,-1,1,1,-1};\n\nint h,w;\nchar s[15][25];\nstring ans;\n\nvoid dfs(int py,int px, int y, int x,int k,string cur,set<string> &dic){\n    if(dic.count(cur)){\n        if(cur.size() > ans.size()) ans = cur;\n        if(cur.size() == ans.size()){\n            if(cur < ans) ans = cur;\n        }\n    }\n    else dic.insert(cur);\n\n    if(px == x && py == y) return;\n\n    int vx = (x+dx[k]+w) % w;\n    int vy = (y+dy[k]+h) % h;\n\n    dfs(py,px,vy,vx,k,cur+s[y][x],dic);\n    return;\n}\n\nint main(){\n\n    while(1){\n        set<string> dic;\n        cin>>h>>w;\n        if(h == 0 && w == 0) break;\n\n        for(int i=0; i<h; i++){\n            for(int j=0; j<w; j++){\n                cin>>s[i][j];\n            }\n        }\n\n        ans = \"\";\n\n        for(int i=0; i<h; i++){\n            for(int j=0; j<w; j++){\n                string cur = \"\";\n                for(int k=0; k<8; k++){\n                    int vx = (j+dx[k]+w) % w;\n                    int vy = (i+dy[k]+h) % h;\n                    dfs(i,j,vy,vx,k,cur+s[i][j],dic);\n                }\n            }\n        }\n\n        if(ans.size() <= 1) cout<<\"0\"<<endl;\n        else cout<<ans<<endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n \nusing namespace std;\n \n#if __GNUC__\n#include <tr1/unordered_map>\n#include <tr1/unordered_set>\nusing namespace tr1;\n#else\n#include <unordered_map>\n#include <unordered_set>\n#endif\n \n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(unsigned long long n) { return __builtin_popcountll(n); }\ntemplate <> int popcount(long long n) { return __builtin_popcountll(n); }\n#else\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n \n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n \ntypedef long long ll;\ntypedef pair<int, int> pint;\n \ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os;  }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\n \n \nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n \ntemplate <class T> void print(T a, int n, int br = 1, const string& deli = \", \") { cout << \"{ \"; for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } cout << \" }\"; while (br--) cout << endl; }\ntemplate <class T> void print(const vector<T>& v, int br = 1, const string& deli = \", \") { print(v, v.size(), br, deli); }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {\tif (width != -1) cout.width(width); cout << a[i][j] << ' ';\t} cout << endl; } while (br--) cout << endl; }\n \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T, class U> void input(T& a, U& b, int n) { for (int i = 0; i < n; ++i) cin >> a[i] >> b[i]; }\n\nconst int mod = 1000000007;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n \n\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\n\tint h, w;\n\twhile (cin >> h >> w, h)\n\t{\n\t\tchar c[32][32];\n\t\tfor (int i = 0; i < h; ++i)\n\t\t\tcin >> c[i];\n\n\t\tmap<string, int> spe;\n\t\tfor (int sy = 0; sy < h; ++sy)\n\t\t{\n\t\t\tfor (int sx = 0; sx < w; ++sx)\n\t\t\t{\n\t\t\t\tfor (int dy = -1; dy <= 1; ++dy)\n\t\t\t\t{\n\t\t\t\t\tfor (int dx = -1; dx <= 1; ++dx)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (dx == 0 && dy == 0)\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tstring s;\n\t\t\t\t\t\tfor (int x = sx, y = sy; ; )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ts += c[y][x];\n\n\t\t\t\t\t\t\t++spe[s];\n\n\t\t\t\t\t\t\tx = (x + dx + w) % w;\n\t\t\t\t\t\t\ty = (y + dy + h) % h;\n\t\t\t\t\t\t\tif (x == sx && y == sy)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstring res = \"0\";\n\t\tforeach (it, spe)\n\t\t{\n\t\t\tif (it->second >= 2)\n\t\t\t{\n\t\t\t\tconst string& t = it->first;\n\t\t\t\tif (t.size() > res.size() || (t.size() == res.size() && t < res))\n\t\t\t\t\tres = t;\n\t\t\t}\n\t\t}\n\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint lcm(int a,int b){\t//a,b < 20だしいいよね\n\t\tif (a < b){\n\t\t\tswap(a,b);\n\t\t}\n\t\tint times = a * b;\n\t\tvector<int> num;\n\t\tint gcd,lcm;\n\t\twhile(1){\n\t\t\tint n;\n\t\t\tn = a % b;\n\t\t\tif(n == 0){\tbreak;}\n\t\t\ta = b;\n\t\t\tb = n;\n\t\t}\n\t\tgcd = b;\n\t\tlcm = times / gcd;\n\treturn lcm;\n}\n\nint main(){\n\tint h,w;\n\twhile(1){\n\t\tcin >> h >> w ;\n\t\tif(h == 0 && w == 0){\tbreak;}\n\t\tchar donut[10][20];\n\t\tfor(int i=0;i<10;i++){\n\t\t\tfor(int j=0;j<20;j++){\n\t\t\t\tdonut[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tstring code[1600];\n\t\tbool much[1600];\n\t\tfor(int i = 0; i < 1600; i++){\n\t\t\tcode[i] = \"\";\n\t\t\tmuch[i] = true;\n\t\t}\t//初期化…\n\n\t\tint l = lcm(w,h);\t//ななめの最大数\n\t\tint a = 0;\t//strの数を数えます\n\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j =0; j < w; j++){\n\t\t\t\tcin >> donut[i][j];\n\t\t\t}\n\t\t}\t//input\n\n\t\tfor(int y = 0; y < h; y++){\n\t\t\tfor(int x = 0; x < w; x++){\n\t\t\t\tfor(int i = 0; i < h; i++){\t//縦列\n\t\t\t\t\tcode[a].append(1,donut[(y + i)%h][x]);\n\t\t\t\t\tcode[a+1].append(1,donut[abs(h-(y + i)%h-1)][x]);\n\t\t\t\t}\n\t\t\t\ta += 2;\n\t\t\t\tfor(int j = 0; j < w; j++){\t//横列\n\t\t\t\t\tcode[a].append(1,donut[y][(x + j)%w]);\n\t\t\t\t\tcode[a+1].append(1,donut[y][abs(w-(x+j)%w-1)]);\n\t\t\t\t}\n\t\t\t\ta += 2;\n\t\t\t\tfor(int k = 0; k < l; k++){\t//ななめ\n\t\t\t\t\tcode[a].append(1,donut[(y + k)%h][(x + k)%w]);\n\t\t\t\t\tcode[a+1].append(1,donut[(y + k)%h][(l + x - k)%w]);\n\t\t\t\t\tcode[a+2].append(1,donut[(l + y - k)%h][(x + k)%w]);\n\t\t\t\t\tcode[a+3].append(1,donut[(l + y - k)%h][(l + x - k)%w]);\n\t\t\t\t}\n\t\t\t\ta += 4;\n\t\t\t}\n\t\t}\n\t\tstring mag = \"\";\n\t\t//a:strの数-1\n\n\t\tsort(code,code+a);//nとn+1を比べます\n\n\t\tfor(int i = 0; i < a-1; i++){\n\t\t\tif(code[i][0] != code[i+1][0]){\n\t\t\t\tmuch[i+1] = false;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 1; i < l; i++){\t//2文字目から\n\t\t\tfor(int j = a-1; j > 0; j--){\t//逆順\n\t\t\t\tif(much[j] == true && code[j].length() >= i+1 && code[j-1].length() >= i+1){\n\t\t\t\t\t//jのi+1文字目とj-1のi+1文字目を比べるよ\n\t\t\t\t\tif(code[j][i] != code[j-1][i]){\n\t\t\t\t\t\tmuch[j] = false;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tmag = code[j];\n\t\t\t\t\t\tmag.resize(i+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(mag == \"\"){\n\t\t\tcout << \"0\" << endl;\n\t\t}else{\n\t\t\tcout << mag << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cassert>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define all(c) begin(c),end(c)\n\ntemplate<typename T1, typename T2>\ninline void chmin(T1 &a, T2 b) { if (a > b) a = b; }\n\ntemplate<typename T1, typename T2>\ninline void chmax(T1 &a, T2 b) { if (a < b) a = b; }\n\ntypedef long long int ll;\nusing ll = long long int;\nusing ull = long long unsigned int;\nusing Int = long long int;\nusing uInt = long long unsigned int;\nusing Double = long double;\nusing namespace std;\n#define INF (1 << 30) - 1\n#define INFl (ll)5e15\n#define DEBUG 0\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 1000000007\n\n\n//edit\nclass Solve {\npublic:\n    Int N, M;\n    vector<string> A;\n    map<string, Int> mp;\n\n    Int mod_add(Int a, Int b, Int m) {\n        Int ret = a + b;\n        ret %= m;\n        if (ret < 0) ret += m;\n        return ret;\n    }\n\n    void rekkyo(Int sh, Int sw, Int dh, Int dw) {\n        Int h = sh, w = sw;\n        vector<vector<bool>> used(N, vector<bool>(M, false));\n        string s;\n\n        if (dh == 0 && dw == 0) {\n            s += A[h][w];\n            mp[s]++;\n            return;\n        }\n\n        while (true) {\n            if (used[h][w]) {\n                break;\n            }\n            used[h][w] = true;\n            s += A[h][w];\n            if (s.size() > 1)\n                mp[s]++;\n\n            h = mod_add(h, dh, N);\n            w = mod_add(w, dw, M);\n        }\n    }\n\n    bool solve() {\n        cin >> N >> M;\n        if (N == 0) return false;\n        A.resize(N);\n        rep(i, 0, N) {\n            cin >> A[i];\n        }\n\n        for (int i = 0; i < N; ++i) {\n            for (int j = 0; j < M; ++j) {\n                for (int dh = -1; dh <= 1; ++dh) {\n                    for (int dw = -1; dw <= 1; ++dw) {\n                        rekkyo(i, j, dh, dw);\n                    }\n                }\n            }\n        }\n\n        string ans;\n        for (auto e : mp) {\n            if (e.second >= 2 && e.first.size() >= 2) {\n                string s = e.first;\n                if (s.size() > ans.size()) {\n                    ans = s;\n                } else {\n                    chmin(ans, s);\n                }\n            }\n//            cerr << e.first << endl;\n        }\n        if (ans == \"\") {\n            cout << 0 << endl;\n        } else {\n            cout << ans << endl;\n        }\n\n\n        return true;\n    }\n\n};\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n//    std::ifstream in(\"input.txt\");\n//    std::cin.rdbuf(in.rdbuf());\n\n    while (Solve().solve());\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// >>> TEMPLATES\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing i32 = int32_t;\nusing i64 = int64_t;\nusing u32 = uint32_t;\nusing u64 = uint64_t;\n#define int ll\n#define double ld\n#define rep(i,n) for (int i = 0; i < (int)(n); i++)\n#define rep1(i,n) for (int i = 1; i <= (int)(n); i++)\n#define repR(i,n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rep1R(i,n) for (int i = (int)(n); i >= 1; i--)\n#define loop(i,a,B) for (int i = a; i B; i++)\n#define loopR(i,a,B) for (int i = a; i B; i--)\n#define all(x) (x).begin(), (x).end()\n#define allR(x) (x).rbegin(), (x).rend()\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fst first\n#define snd second\ntemplate <class Int> auto constexpr inf = numeric_limits<Int>::max()/2-1;\nauto constexpr INF32 = inf<int32_t>;\nauto constexpr INF64 = inf<int64_t>;\nauto constexpr INF   = inf<int>;\n#ifdef LOCAL\n#include \"debug.hpp\"\n#else\n#define dump(...) (void)(0)\n#define say(x) (void)(0)\n#define debug if (0)\n#endif\ntemplate <class T> using pque_max = priority_queue<T>;\ntemplate <class T> using pque_min = priority_queue<T, vector<T>, greater<T> >;\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nostream& operator<<(ostream& os, T const& v) { bool f = true; for (auto const& x : v) os << (f ? \"\" : \" \") << x, f = false; return os; }\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nistream& operator>>(istream& is, T &v) { for (auto& x : v) is >> x; return is; }\ntemplate <class T, class S> ostream& operator<<(ostream& os, pair<T,S> const& p) { return os << \"(\" << p.first << \", \" << p.second << \")\"; }\ntemplate <class T, class S> istream& operator>>(istream& is, pair<T,S>& p) { return is >> p.first >> p.second; }\nstruct IOSetup { IOSetup() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); } } iosetup;\ntemplate <class F> struct FixPoint : private F {\n    constexpr FixPoint(F&& f) : F(forward<F>(f)) {}\n    template <class... T> constexpr auto operator()(T&&... x) const { return F::operator()(*this, forward<T>(x)...); }\n};\nstruct MakeFixPoint {\n    template <class F> constexpr auto operator|(F&& f) const { return FixPoint<F>(forward<F>(f)); }\n};\n#define MFP MakeFixPoint()|\n#define def(name, ...) auto name = MFP [&](auto &&name, __VA_ARGS__)\ntemplate <class T, size_t d> struct vec_impl {\n    using type = vector<typename vec_impl<T,d-1>::type>;\n    template <class... U> static type make_v(size_t n, U&&... x) { return type(n, vec_impl<T,d-1>::make_v(forward<U>(x)...)); }\n};\ntemplate <class T> struct vec_impl<T,0> { using type = T; static type make_v(T const& x = {}) { return x; } };\ntemplate <class T, size_t d = 1> using vec = typename vec_impl<T,d>::type;\ntemplate <class T, size_t d = 1, class... Args> auto make_v(Args&&... args) { return vec_impl<T,d>::make_v(forward<Args>(args)...); }\ntemplate <class T> void quit(T const& x) { cout << x << endl; exit(0); }\ntemplate <class T, class U> constexpr bool chmin(T& x, U const& y) { if (x > y) { x = y; return true; } return false; }\ntemplate <class T, class U> constexpr bool chmax(T& x, U const& y) { if (x < y) { x = y; return true; } return false; }\ntemplate <class It> constexpr auto sumof(It b, It e) { return accumulate(b,e,typename iterator_traits<It>::value_type{}); }\ntemplate <class T> int sz(T const& x) { return x.size(); }\ntemplate <class C, class T> int lbd(C const& v, T const& x) {\n    return lower_bound(v.begin(), v.end(), x)-v.begin();\n}\ntemplate <class C, class T> int ubd(C const& v, T const& x) {\n    return upper_bound(v.begin(), v.end(), x)-v.begin();\n}\nconstexpr int popcnt(ll x) { return __builtin_popcountll(x); }\ntemplate <class Int> struct Random {\n    mt19937_64 mt{random_device{}()};\n    //mt19937_64 mt{(unsigned)time(0)};\n    Int a,b; // [a,b]\n    Random(Int a, Int b) : a(a), b(b) {}\n    Int operator()() { return uniform_int_distribution<Int>(a,b)(mt); }\n};\ntemplate <class Int> Int rand(Int a, Int b) { // [a,b]\n    static mt19937_64 mt{random_device{}()};\n    return uniform_int_distribution<Int>(a,b)(mt);\n}\n// <<<\nconst int dx[] = { 1,0,-1,0,1,-1,-1,1 };\nconst int dy[] = { 0,1,0,-1,1,1,-1,-1 };\n\nstring solve(int n, int m) {\n    vector<string> s(n); cin >> s;\n    map<string,int> cnt;\n    string t;\n    dump(n,m);\n    rep (i,n) rep (j,m) rep (dir,8) {\n        int x = i, y = j;\n        t.clear();\n        while (true) {\n            t += s[x][y];\n            if (sz(t) > 1) cnt[t]++;\n            x += dx[dir] + n, x %= n;\n            y += dy[dir] + m, y %= m;\n            if (x == i && y == j) break;\n        }\n    }\n\n    int ma = 0;\n    for (auto const& p : cnt) {\n        if (p.snd > 1) chmax(ma, sz(p.fst));\n    }\n    if (ma == 0) return \"0\";\n\n    string ans(1,'z'+1);\n    for (auto const& p : cnt) {\n        if (p.snd > 1 && sz(p.fst) == ma) {\n            chmin(ans, p.fst);\n        }\n    }\n    return ans;\n}\n\nint32_t main() {\n    while (true) {\n        int h,w; cin >> h >> w;\n        if (h == 0 && w == 0) break;\n        cout << solve(h,w) << \"\\n\";\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint W, H;\nstring donuts[10];\nint dx[8] = {-1, -1, -1, 0, 0, 1, 1, 1};\nint dy[8] = {-1,  0,  1, -1,1, -1,0, 1};\n\nstring ansstr;\nset<string> strs;\n\nint flgs[100][100];\n\nvoid dfs(int x, int y, int d, string cur){\n\tx = (x + W) % W;\n\ty = (y + H) % H;\n\tif(flgs[y][x]) return;\n\tstring c2 = cur + donuts[y][x];\n\tif(strs.find(c2) == strs.end()){\n\t\tstrs.insert(c2);\n\t}else{\n\t\tif(ansstr.size() < c2.size() || (ansstr.size() == c2.size() && c2 < ansstr)){\n\t\t\tansstr = c2;\n\t\t}\n\t}\n\tflgs[y][x] = true;\n\tdfs(x + dx[d], y + dy[d], d, c2);\n\tflgs[y][x] = false;\n}\n\nint main(){\n\twhile(cin >> H >> W, H){\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tcin >> donuts[i];\n\t\t}\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\tflgs[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tansstr = \"\";\n\t\tstrs.clear();\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\tfor(int k = 0; k < 8; k++){\n\t\t\t\t\tdfs(j, i, k, \"\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ansstr.size() < 2){\n\t\t\tcout << 0 << endl;\n\t\t}else{\n\t\t\tcout << ansstr << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stdio.h>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\n#define dirmax 8\nint l[2];\nint dir[8][2] = { {0,1}, {1,0}, {-1,0}, {0,-1}, {1,1}, {-1,1}, {1,-1}, {-1,-1} };\nstring ans;\n\nvoid search( set<string> *v, int pos[2] , char ch[10][20]){\n\n\tfor(int i = 0; i < dirmax; i++) {\n\t\tstring str;\n\t\tint cpos[] = { pos[0], pos[1] };\n\n\t\tstr += ch[pos[0]][pos[1]];\n\n\t\twhile( true ) {\n\t\t\tfor(int j = 0; j < 2; j++) {\n\t\t\t\tcpos[j] += dir[i][j];\n\t\t\t\tif( cpos[j] < 0 ) cpos[j] = l[j] - 1;\n\t\t\t\tif( cpos[j] >= l[j] ) cpos[j] = 0;\n\t\t\t}\n\t\t\tif( cpos[0] == pos[0] && cpos[1] == pos[1] ) break;\n\t\t\tstr += ch[cpos[0]][cpos[1]];\n\t\t\t\n\t\t\tif( v->find(str) != v->end() ) {\n\t\t\t\tif( ( str.length() > ans.length() ) || ( str.length() == ans.length() && str < ans ) ) {\n\t\t\t\t\tans = str;\n\t\t\t\t}\n\t\t\t}\n\t\t\tv->insert(str);\n\t\t}\n\t\t\n\n\t}\n}\n\nint main(void){\n\t//FILE* fp_in = freopen(\"data.txt\", \"r\", stdin);\n\twhile(1){\n\t\tcin >> l[0] >> l[1];\n\t\tif( l[0] == 0 && l[1] == 0 ) break;\n\t\tchar donut[10][20];\n\t\tans = \"\";\n\n\t\tset< string > strs;\n\n\t\t//入力を取得する\n\t\tfor(int i = 0; i < l[0]; i++) {\n\t\t\tstring str;\n\t\t\tcin >> str;\n\t\t\tfor(int j = 0; j < l[1]; j++){\n\t\t\t\tdonut[i][j] = str[j];\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < l[0]; i++) {\n\t\t\tfor(int j = 0; j < l[1]; j++) {\n\t\t\t\tint pos[2];\n\t\t\t\tpos[0] = i;\n\t\t\t\tpos[1] = j;\n\t\t\t\tsearch( &strs, pos, donut );\n\t\t\t}\n\t\t}\n\n\t\tif(ans == \"\") \n\t\t\tcout << 0 << endl;\n\t\telse \n\t\t\tcout << ans << endl;\n\n\t}\n\t//while(1){}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<set>\nusing namespace std;\nint w,h;\n\nint dx[8]={0,1,1,1,0,-1,-1,-1};\nint dy[8]={-1,-1,0,1,1,1,0,-1};\n\nvoid solve(){\n\tset<string> S;\n\tvector<string> V;\n\tfor(int i=0;i<h;i++){\n\t\tstring s;\n\t\tcin>>s;\n\t\tV.push_back(s);\n\t}\n\tstring res=\"\";\n\n\tfor(int y=0;y<h;y++){\n\t\tfor(int x=0;x<w;x++){\n\t\t\tfor(int r=0;r<8;r++){\n\t\t\t\tint nx=x,ny=y;\n\t\t\t\tstring read=\"\";\n\t\t\t\twhile(!(nx==x && ny==y) || read.size()==0){\n\t\t\t\t\tread+=V[ny][nx];\n\t\t\t\t\tif(S.count(read)){\n\t\t\t\t\t\tif(res.size()<read.size()) res=read;\n\t\t\t\t\t\tif(res.size()==read.size() && res>read) res=read;\n\t\t\t\t\t}\n\t\t\t\t\tS.insert(read);\n\t\t\t\t\tny+=dy[r];\n\t\t\t\t\tnx+=dx[r];\n\t\t\t\t\tif(ny<0) ny=h-1;\n\t\t\t\t\tif(ny>=h) ny=0;\n\t\t\t\t\tif(nx<0) nx=w-1;\n\t\t\t\t\tif(nx>=w) nx=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(res.size()>1)\n\t\tcout<<res<<endl;\n\telse cout<<0<<endl;\n}\n\n\n\nint main()\n{\n\twhile(cin>>h>>w){\n\t\tif(h==0) break;\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<string>vec;\nchar c[20][20]; int H, W; bool used[20][20];\nint dx[8] = { 1,1,1,0,-1,-1,-1,0 };\nint dy[8] = { -1,0,1,1,1,0,-1,0 };\nint main() {\n\twhile (true) {\n\t\tcin >> H >> W; vec.clear(); if (H == 0)break;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++)cin >> c[i][j];\n\t\t}\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tfor (int k = 0; k < 8; k++) {\n\t\t\t\t\tfor (int l = 0; l < 400; l++)used[l / 20][l % 20] = false;\n\t\t\t\t\tint cx = i, cy = j; string S; S += c[cx][cy]; used[cx][cy] = true;\n\t\t\t\t\twhile (true) {\n\t\t\t\t\t\tcx += dx[k]; cy += dy[k];\n\t\t\t\t\t\tif (cx < 0)cx += H; if (cx >= H)cx -= H;\n\t\t\t\t\t\tif (cy < 0)cy += W; if (cy >= W)cy -= W;\n\t\t\t\t\t\tif (used[cx][cy] == true)break;\n\t\t\t\t\t\tused[cx][cy] = true; S += c[cx][cy]; vec.push_back(S);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(vec.begin(), vec.end()); string T = \"0\";\n\t\tfor (int i = 1; i < vec.size(); i++) {\n\t\t\tif (vec[i - 1] == vec[i]) {\n\t\t\t\tif (vec[i].size()>T.size())T = vec[i];\n\t\t\t\telse if (vec[i].size() == T.size())T = min(T, vec[i]);\n\t\t\t}\n\t\t}\n\t\tcout << T << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\nusing namespace std;\nstring s[10];\nint h,w;\nint dx[]={0,1,0,-1,1,1,-1,-1},dy[]={1,0,-1,0,1,-1,1,-1};\nmain()\n{\n\twhile(cin>>h>>w,h)\n\t{\n\t\tfor(int i=0;i<h;i++)cin>>s[i];\n\t\tmap<string,int>M;\n\t\tstring ans=\"0\";\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)\n\t\t{\n\t\t\tfor(int r=0;r<8;r++)\n\t\t\t{\n\t\t\t\tstring now=s[i].substr(j,1);\n\t\t\t\tint x=i+dx[r],y=j+dy[r];\n\t\t\t\tx=(x+h)%h;y=(y+w)%w;\n\t\t\t\twhile(x!=i||y!=j)\n\t\t\t\t{\n\t\t\t\t\tnow+=s[x][y];\n\t\t\t\t\tif(M[now]++==1)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(now.size()>ans.size())ans=now;\n\t\t\t\t\t\telse if(ans.size()==now.size()&&ans>now)ans=now;\n\t\t\t\t\t}\n\t\t\t\t\tx+=dx[r],y+=dy[r];\n\t\t\t\t\tx=(x+h)%h;y=(y+w)%w;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <string>\n#include <set>\n#include <map>\n#include <list>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <cstdio>\n#include <cmath>\n#include <functional>\n\nusing namespace std;\n\n#define PQ priority_queue\n#define VT vector\n#define MP make_pair\n#define FOR(i, b, e) for(int i=b;i<e;i++)\n#define CaseRead int _TT; scanf(\"%d\", &_TT); for (int kase = 1; kase <= _TT; kase++)\n\ntypedef long long ll;\n\nchar ma[25][25];\nint n, m;\nvector<string> v;\n\nint dx[] = {0, 0, -1, -1, -1, 1, 1, 1};\nint dy[] = {1, -1, 0, 1, -1, 0, 1, -1};\n\nvoid solve(int x, int y) {\n//    printf(\"solve(%d, %d)\\n\", x, y);\n    for (int i = 0; i < 8; i++) {\n        string s = \"\";\n        s += ma[x][y];\n        int nx, ny;\n        nx = (x + n + dx[i]) % n;\n        ny = (y + m + dy[i]) % m;\n\n        while (nx != x || ny != y) {\n            s += ma[nx][ny];\n            nx = (nx + n + dx[i]) % n;\n            ny = (ny + m + dy[i]) % m;\n        }\n        v.push_back(s);\n//        cout << s << endl;\n    }\n}\n\n\n\nint main()\n{\n    while (1) {\n        scanf(\"%d%d\", &n, &m);\n        v.clear();\n        if (n == 0 && m == 0) break;\n        for (int i = 0; i < n; i++) scanf(\"%s\", ma[i]);\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < m; j++) solve(i, j);\n        sort(v.begin(), v.end());\n        int len = 0;\n        string ans;\n\n        for (int i = 1; i < v.size(); i++) {\n//            cout << \"compare \" << v[i] << \" and \" << v[i-1] << endl;\n            int len1 = 0;\n            for (int j = 0; j < min(v[i].length(), v[i-1].length()) && v[i][j] == v[i-1][j]; j++) {\n                len1++;\n            }\n            if (len1 > len) {\n                len = len1;\n                ans = v[i].substr(0, len1);\n            }\n        }\n        if (ans.length() < 2) cout << 0 << endl;\n        else cout << ans << endl;\n            \n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <set>\n#include <cstring>\nusing namespace std;\n \n#define REP(i,x,n) for(int i = x; i < (int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n \nstatic const int dx[] = {-1,-1,-1,0,0,1,1,1};\nstatic const int dy[] = {-1,0,1,-1,1,-1,0,1};\n \nint h,w;\nchar D[10][20];\nset<string> spell;\n \nstring solve(){\n  spell.clear();\n  string ret = \"0\";\n   \n  rep(i,h) rep(j,w){\n    int sx = i;\n    int sy = j;\n    rep(k,8){\n      int x = i;\n      int y = j;\n      string tmp;\n      tmp += D[x][y];\n       \n      while(true){\n        x = (x + h + dx[k]) % h;\n        y = (y + w + dy[k]) % w;\n        if(x == sx && y == sy) break;\n         \n        tmp += D[x][y];\n        if(spell.find(tmp) != spell.end()){\n          if(ret.size() == tmp.size()) ret = (ret < tmp) ? ret : tmp;\n          else ret = (ret.size() < tmp.size()) ? tmp : ret;\n        }\n        else spell.insert(tmp);\n      }\n    } \n  }\n   \n  return ret;\n}\n \nint main(){\n  while(cin >> h >> w && (h | w)){\n    rep(i,h) rep(j,w){\n      cin >> D[i][j];\n    }\n    cout << solve() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint di[8] = {0, -1, -1, -1, 0, 1, 1, 1};\nint dj[8] = {1, 1, 0, -1, -1, -1, 0, 1};\n\n\nint main(){\n    \n    while(1){\n        int h, w; cin >> h >> w;\n        if(h == 0) break;\n        vector<string> a(h);\n        for(int i = 0; i < h; i++) cin >> a[i];\n        string ans = \"[\";\n        set<string> s;\n        \n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                for(int k = 0; k < 8; k++){\n\n                    string tmp;\n                    tmp += a[i][j];\n                    int ni = (h + i + di[k]) % h;\n                    int nj = (w + j + dj[k]) % w;\n                    while(!(ni == i && nj == j)){\n                        tmp += a[ni][nj];\n                        //cout << i << \" \" << j << \" \" << ni << \" \" << nj << \" \" <<  tmp << endl;\n                        \n                        ni = (h + ni + di[k]) % h;\n                        nj = (w + nj + dj[k]) % w;\n\n                        //cout << i << \" \" << j << \" \" << ni << \" \" << nj << \" \" <<  tmp << endl;\n                        if(s.find(tmp) != s.end()){\n                            //cout << \"find\" << endl;\n                            if(ans.size() < tmp.size()){\n                                ans = tmp;\n                            }else if(ans.size() == tmp.size() && ans > tmp){\n                                ans = tmp;                                \n                            }\n                        }else{\n                            //cout << \"insert\" << endl;\n                            s.insert(tmp);\n                        }                \n                    }\n                }\n            }\n        }\n\n        //string hoge = \"ABCDEFGHIJKLMNOPQRSTUVWXYZHHHHHABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n        //cout << hoge.size() << endl;\n    \n        if(ans == \"[\") cout << 0 << endl;\n        else cout << ans << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\nusing namespace std;\nusing P = pair<int,int>;\n\nint h,w;\nint d[2][8] = {{-1,-1,-1,0,0,1,1,1},{-1,0,1,-1,1,-1,0,1}};\nvector<vector<P>> memo;\nvector<string> s;\n\nstring solve();\n\nint main() {\n    while(1){\n        cin >> h >> w;\n        if(h + w == 0)break;\n        s.resize(h);\n        for(int i = 0;i < h;++i)\n            cin >> s[i];\n        cout << solve() << endl;\n    }\n    return 0;\n}\n\nstring solve(){\n    string ans;\n    memo.assign(26,vector<P>(0,{0,0}));\n    for(int i = 0;i < h;++i)\n        for(int j = 0;j < w;++j)\n            memo[s[i][j]-'A'].push_back({i,j});\n    for(int alph = 0;alph < 26;++alph){\n        int memosize = memo[alph].size();\n        for(int j = 0;j < memosize;++j)\n            for(int k = 0;k < memosize;++k){\n                P memoj = memo[alph][j],memok = memo[alph][k];\n                for(int dj = 0;dj < 8;++dj)\n                    for(int dk = 0;dk < 8;++dk){\n                        P nowj = memoj,nowk = memok;\n                        string now;\n                        if(j == k && dj == dk)continue;\n                        while(s[nowj.fi][nowj.se] == s[nowk.fi][nowk.se]){\n                            now += s[nowj.fi][nowj.se];\n                            (nowj.fi += d[0][dj] + h) %= h;\n                            (nowj.se += d[1][dj] + w) %= w;\n                            (nowk.fi += d[0][dk] + h) %= h;\n                            (nowk.se += d[1][dk] + w) %= w;\n                            if(nowj == memoj && nowk == memok)break;\n                        }\n                        if(now.size() <= 1)continue;\n                        if(now.size() > ans.size() || (now.size() == ans.size() && now < ans))\n                            ans = now;\n                    }\n            }\n    }\n    return ans.size() == 0? \"0\":ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF 1001000100010001000\n#define MOD 1000000007\n#define EPS 1e-10\n#define int long long\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define Rep(i, N) for (int i = 1; i < N; i++)\n#define For(i, a, b) for (int i = (a); i < (b); i++)\n#define pb push_back\n#define mp make_pair\n#define i_i pair<int, int>\n#define vi vector<int>\n#define vvi vector<vi >\n#define vb vector<bool>\n#define vvb vector<vb >\n#define vp vector< i_i >\n#define all(a) (a).begin(), (a).end()\n#define Int(x) int x; scanf(\"%lld\", &x);\n\n//int dxy[5] = {0, 1, 0, -1, 0};\nint dx[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nint dy[8] = {1, 0, -1, 1, -1, 1, 0, -1};\n// assign\n\nstring comp(string a, string b);\n\nsigned main()\n{\n    int n, m;\n    while (cin >> n >> m, n) {\n        vector<string> donut(n);\n        rep(i, n) {\n            cin >> donut[i];\n        }\n        set<string> can;\n        string ans = \"z\";\n        rep(i, n) {\n            rep(j, m) {\n                rep(k, 8) {\n                    vvb used(n, vb(m, false));\n                    string spell;\n                    int x = i, y = j;\n                    while (!used[x][y]) {\n                        spell.pb(donut[x][y]);\n                        used[x][y] = true;\n                        if (can.find(spell) != can.end()) {\n                            ans = comp(ans, spell);\n                        } else {\n                            can.insert(spell);\n                        }\n                        x = (x + dx[k] + n) % n; y = (y + dy[k] + m) % m;\n                    }\n                }\n            }\n        }\n        cout << ((ans.length() > 1) ? ans : 0) << endl;\n    }\n    return 0;\n}\n\nstring comp(string a, string b)\n{\n    if (a.length() < b.length()) {\n        return b;\n    } else if (a.length() > b.length()) {\n        return a;\n    } else {\n        rep(i, a.length()) {\n            if (a[i] < b[i]) {\n                return a;\n            } else if (a[i] > b[i]) {\n                return b;\n            }\n        }\n    }\n    return a;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\nusing namespace std;\n\nint lcm(int a, int b){\n  return a/gcd(a, b) * b;\n}\n\nint main(int argc, char *argv[]){\n  int w, h;\n  while(cin >> h >> w, h){\n    string torus[30];\n    string s[2222];\n    for (int i = 0; i < h; i++) {\n      cin >> torus[i];\n    }\n    int l = lcm(w, h);\n    int num = 0;\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        for (int k = 0; k < h; k++) {\n          s[num].push_back(torus[(h + i + k)%h][j]);\n          s[num + 1].push_back(torus[(h + i - k)%h][j]);\n        }\n        \n        for (int k = 0; k < w; k++) {\n          s[num + 2].push_back(torus[i][(w + j + k)%w]);\n          s[num + 3].push_back(torus[i][(w + j - k)%w]);\n        }\n        \n        for (int k = 0; k < l; k++) {\n          s[num + 4].push_back(torus[(l*h + i + k)%h][(l*w + j + k)%w]);\n          s[num + 5].push_back(torus[(l*h + i - k)%h][(l*w + j + k)%w]);\n          s[num + 6].push_back(torus[(l*h + i + k)%h][(l*w + j - k)%w]);\n          s[num + 7].push_back(torus[(l*h + i - k)%h][(l*w + j - k)%w]);\n        }\n        num += 8;\n      }\n    }\n    sort(s, s + 8*w*h);\n    string ans = s[0];\n    for (int i = 0; i < 8*w*h - 1; i++) {\n      int length = 0;\n      for (int j = 0;\n           j < min(s[i].length(), s[i + 1].length()) - 1; j++) {\n        if(s[i][length] == s[i + 1][length])length++;\n        else break;\n      }\n      if(length > ans.length())ans = s[i].substr(0,length);\n    }\n    if(ans.length() > 1)std::cout << ans << std::endl;\n    else std::cout << 0 << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nint h, w;\nchar t[50][50];\nbool used[50][50];\nmap<string,int> cnt;\n\nint dx[] = {-1, 0, 1, -1, 1, -1, 0, 1};\nint dy[] = {-1, -1, -1, 0, 0, 1, 1, 1};\n\nvoid solve(int sx, int sy){\n  for(int i = 0; i < 8; i++){\n    int x = sx;\n    int y = sy;\n    string s = \"\";\n\n    memset(used, 0, sizeof(used));\n\n    while(!used[y][x]){\n      used[y][x] = true;\n      s += t[y][x];\n      x = (x + dx[i] + w) % w;\n      y = (y + dy[i] + h) % h;\n\n      cnt[s]++;\n      //string ts = s;\n      //reverse(ts.begin(), ts.end());\n      //cnt[ts]++;\n    };\n  }\n}\n\nint main(){\n  while(cin >> h >> w, h || w){\n    cnt.clear();\n\n    for(int i = 0; i < h; i++){\n      cin >> t[i];\n    }\n\n    for(int i = 0; i < h; i++){\n      for(int j = 0; j < w; j++){\n        solve(j, i);\n      }\n    }\n\n    string ans = \"\";\n\n    for(map<string,int>::iterator iter = cnt.begin(); iter != cnt.end(); iter++){\n      string s = iter->first;\n      int c = iter->second;\n\n      if(2 <= c && 2 <= s.length() && ans.length() < s.length()){\n        ans = s;\n      }\n    }\n\n    if(ans == \"\"){\n      cout << 0 << endl;\n    }\n    else{\n      cout << ans << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <vector>\nusing namespace std;\n#define REP(i,x)for(int i=0;i<x;i++)\n\nstring res;\nint H,W,dx,dy,min_len;\nchar s[200];\nchar MAP[11][22];\nbool visit[20][20];\nvector<string> ss;\nvoid dfs(int x,int y,int k){\n  if(visit[y][x]){\n    ss.push_back(string(s));\n    return;\n  }\n  s[k]=MAP[y][x];  visit[y][x]=1;\n  dfs((x + dx + W) % W, (y + dy + H) % H, k + 1);\n  s[k]=0;  visit[y][x]=0;\n}\nint main() {\n  while(scanf(\"%d%d\",&H,&W),H){\n    REP(i,H)scanf(\"%s\",MAP[i]);\n    ss.clear();\n    min_len=1; res=\"0\";\n    REP(y,H)REP(x,W){\n      for(dx=-1;dx<=1;dx++){\n        for(dy=-1;dy<=1;dy++){\n          if(dx|dy)dfs(x,y,0);\n        }\n      }\n    }\n    string res = \"0\";\n    sort(ss.begin(),ss.end());\n    REP(i,ss.size()-1){\n      int len = 0;\n      REP(k,min(ss[i].size(),ss[i+1].size())){\n        if(ss[i][k]==ss[i+1][k])len++;\n      }\n      if(len < res.size())continue;\n      if(res.size() == len){\n        res = min(res, ss[i].substr(0,len));\n      }else{\n        res = ss[i].substr(0, len);\n      }\n    }\n    puts(res.c_str());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nstruct bstr{\n  string str;\n  bstr(string s){str=s;}\n  bool operator<(const bstr& a) const{\n    return str.size()==a.str.size() ? (str.compare(a.str) < 0): str.size() > a.str.size();\n  }\n};\nint main(){\n  int h,w;\n  int i,j,k;\n  int ai[]={ 1, 1, 1, 0, 0,-1,-1,-1};\n  int aj[]={ 1, 0,-1, 1,-1, 1, 0,-1};\n  cin >> h >> w;\n  while(h!=0){\n    string str[10];\n    for(i=0;i<h;i++) cin >> str[i];\n    vector <bstr> li;\n    vector <string> ans;\n    int mal=1;\n    for(i=0;i<h;i++){\n      //cout << i << endl;\n      for(j=0;j<w;j++){\n\tfor(k=0;k<8;k++){\n\t  int bi=i,bj=j;\n\t  string buf;\n\t  buf += str[i][j];\n\t  bi+=ai[k];bj+=aj[k];\n\t  if(bi<0) bi=h-1;\n\t  if(bi>=h) bi=0;\n\t  if(bj<0) bj=w-1;\n\t  if(bj>=w) bj=0;\n\t  while(bi!=i||bj!=j){\n\t    buf+=str[bi][bj];\n\t    li.push_back(bstr(buf));\n\t    \n\t    bi+=ai[k];bj+=aj[k];\n\t    if(bi<0) bi=h-1;\n\t    if(bi>=h) bi=0;\n\t    if(bj<0) bj=w-1;\n\t    if(bj>=w) bj=0;\n\t  }\n\t}\n      }\n    }\n    sort(li.begin(),li.end());\n    for(i=0;i<li.size()-1;i++){\n      if(li[i].str==li[i+1].str) {\n\tans.push_back(li[i].str);\n\tbreak;\n      }\n    }\n    //for(i=0;i<li.size();i++) cout << li[i] << endl;\n    sort(ans.begin(),ans.end());\n    //for(i=0;i<ans.size();i++) cout << ans[i] << endl;\n    if(ans.size()!=0) cout << ans[0] << endl;\n    else cout << 0 << endl;\n    cin >> h >> w;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * GCA : \"Computer is artificial subject absolutely,Math is God\"\n */\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <cctype>\n#include <utility>\n#include <ctime>\nusing namespace std;\n#ifdef DEBUG\n#define VAR(a,b) __typeof(b) a=(b)\n#define debug(...) printf(\"DEBUG: \"),printf(__VA_ARGS__)\n#else\n#define VAR(a,b) __typeof(b) a=(b)\n#define debug(...)\n#endif\ntypedef unsigned int uint;\ntypedef long long int Int;\ntypedef unsigned long long int UInt;\n#define Set(a,s) memset(a,s,sizeof(a))\n#define Pln() printf(\"\\n\")\n#define For(i,x)for(int i=0;i<x;i++)\n#define CON(x,y) x##y\n#define M 25\n#define PB push_back\n#define oo INT_MAX\n#define FOR(a,b) for(VAR(a,(b).begin());a!=(b).end();++a)\n#define eps 1e-9\n#define X first\n#define Y second\ninline bool xdy(double x,double y){return x>y+eps;}\ninline bool xddy(double x,double y){return x>y-eps;}\ninline bool xcy(double x,double y){return x<y-eps;}\ninline bool xcdy(double x,double y){return x<y+eps;}\nconst Int mod=1000000007;\nint nx,ny;\nchar mz[M][M];\nset<string> sid;\nint dx[8]={0,1,1,1,0,-1,-1,-1};\nint dy[8]={1,1,0,-1,-1,-1,0,1};\nchar store[M*M];\nint ox,oy;\nstring ans;\nbool vis[M][M];\nvoid dfs(int x,int y,int d,int dep){\n\n\tstore[dep]=mz[y][x];\n\tint nex=(x+dx[d]+nx)%nx;\n\tint ney=(y+dy[d]+ny)%ny;\n\tstore[dep+1]=0;\n\tstring ss(store);\n\tif(sid.count(ss)&&ss.length()>=2){\n\t\tif(ss.length()>ans.length())ans=ss;\n\t\telse if(ss.length()==ans.length()&&ss<ans){\n\t\t\tans=ss;\n\t\t}\n\t}\n\tsid.insert(ss);\n\tvis[x][y]=1;\n\tif(!vis[nex][ney])dfs(nex,ney,d,dep+1);\n\tvis[x][y]=0;\n\n}\nvoid solve(){\n\tSet(vis,0);\n\tfor(int i=0;i<ny;i++){\n\t\tfor(int j=0;j<nx;j++){\n\t\t\tfor(int k=0;k<8;k++){\n\t\t\t\tvis[j][i]=1;\n\t\t\t\tdfs(j,i,k,0);\n\t\t\t\tvis[j][i]=0;\n\t\t\t}\n\t\t}\n\t}\n\tif(ans.size())\n\t\tputs(ans.c_str());\n\telse puts(\"0\");\n}\nint main() {\n\tios_base::sync_with_stdio(0);\n\twhile(~scanf(\"%d%d\",&ny,&nx)&&ny&&nx){\n\t\tsid.clear();\n\t\tans=\"\";\n\t\tfor(int i=0;i<ny;i++)scanf(\"%s\",mz[i]);\n\t\tsolve();\n\n\t}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint H, W; string s[11];\nint main() {\n\twhile (cin >> H >> W, H | W) {\n\t\tfor (int i = 0; i < H; i++) cin >> s[i];\n\t\tvector<string> res;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tfor (int dy = -1; dy <= 1; dy++) {\n\t\t\t\t\tfor (int dx = -1; dx <= 1; dx++) {\n\t\t\t\t\t\tif (dx == 0 && dy == 0) continue;\n\t\t\t\t\t\tstring now;\n\t\t\t\t\t\tint tx = (j + dx + W) % W, ty = (i + dy + H) % H;\n\t\t\t\t\t\tnow += s[ty][tx];\n\t\t\t\t\t\twhile (tx != j || ty != i) {\n\t\t\t\t\t\t\ttx = (tx + dx + W) % W, ty = (ty + dy + H) % H;\n\t\t\t\t\t\t\tnow += s[ty][tx];\n\t\t\t\t\t\t\tres.push_back(now);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(res.begin(), res.end());\n\t\tstring ret;\n\t\tint pre = 0;\n\t\tfor (int i = 1; i < res.size(); i++) {\n\t\t\tif (i == res.size() || res[i - 1] != res[i]) {\n\t\t\t\tif (i - pre > 1) {\n\t\t\t\t\tif (ret.size() < res[pre].size() || (ret.size() == res[pre].size() && ret > res[pre])) {\n\t\t\t\t\t\tret = res[pre];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpre = i;\n\t\t\t}\n\t\t}\n\t\tif(ret.size() > 1) cout << ret << endl;\n\t\telse cout << 0 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\nusing namespace std;\n\nint lcm(int a, int b){\n  return a/gcd(a, b) * b;\n}\n\nint main(int argc, char *argv[]){\n  int w, h;\n  while(cin >> h >> w, h){\n    string torus[30];\n    string s[2222];\n    for (int i = 0; i < h; i++) {\n      cin >> torus[i];\n    }\n    int l = lcm(w, h);\n    int num = 0;\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        for (int k = 0; k < h; k++) {\n          s[num].push_back(torus[(h + i + k)%h][j]);\n          s[num + 1].push_back(torus[(h + i - k)%h][j]);\n        }\n        \n        for (int k = 0; k < w; k++) {\n          s[num + 2].push_back(torus[i][(w + j + k)%w]);\n          s[num + 3].push_back(torus[i][(w + j - k)%w]);\n        }\n        \n        for (int k = 0; k < l; k++) {\n          s[num + 4].push_back(torus[(l*h + i + k)%h][(l*w + j + k)%w]);\n          s[num + 5].push_back(torus[(l*h + i - k)%h][(l*w + j + k)%w]);\n          s[num + 6].push_back(torus[(l*h + i + k)%h][(l*w + j - k)%w]);\n          s[num + 7].push_back(torus[(l*h + i - k)%h][(l*w + j - k)%w]);\n        }\n        num += 8;\n      }\n    }\n    sort(s, s + 8*w*h);\n    string ans = s[0];\n    for (int i = 0; i < 8*w*h - 1; i++) {\n      int length = 0;\n      for (int j = 0;\n           j < min(s[i].length(), s[i + 1].length()) - 1; j++) {\n        if(s[i][length] == s[i + 1][length])length++;\n        else break;\n      }\n      if(length > ans.length())ans = s[i].substr(0,length);\n    }\n    if(ans.length() > 1)std::cout << ans << std::endl;\n    else std::cout << 0 << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int dx[] = { 1, 1, 0, -1, -1, -1, 0, 1 };\nconst int dy[] = { 0, 1, 1, 1, 0, -1, -1, -1 };\n\nint GCD(int a, int b) {\n\treturn b ? GCD(b, a % b) : a;\n}\n\nint main()\n{\n\tint h, w;\n\twhile (cin >> h >> w, h | w) {\n\t\tint gcd = GCD(h, w);\n\t\tvector<string> c(h);\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tcin >> c[i];\n\t\t}\n\t\tint ma = 0;\n\t\tset<string> exist;\n\t\tpriority_queue<string, vector<string>, greater<string>> pq;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tfor (int k = 0; k < 8; k++) {\n\t\t\t\t\tint x = i, y = j, lim = k & 1 ? h * w / gcd : k & 2 ? w : h;\n\t\t\t\t\tstring s;\n\t\t\t\t\ts.push_back(c[x][y]);\n\t\t\t\t\tfor (int l = 1; l < lim; l++) {\n\t\t\t\t\t\tx += dx[k]; y += dy[k];\n\t\t\t\t\t\tif (x >= h) {\n\t\t\t\t\t\t\tx -= h;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (x < 0) {\n\t\t\t\t\t\t\tx += h;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (y >= w) {\n\t\t\t\t\t\t\ty -= w;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (y < 0) {\n\t\t\t\t\t\t\ty += w;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts.push_back(c[x][y]);\n\t\t\t\t\t\tif (exist.count(s)) {\n\t\t\t\t\t\t\tif ((int)s.size() > ma) {\n\t\t\t\t\t\t\t\tma = s.size();\n\t\t\t\t\t\t\t\tpq = priority_queue<string, vector<string>, greater<string>>();\n\t\t\t\t\t\t\t\tpq.push(s);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if ((int)s.size() == ma) {\n\t\t\t\t\t\t\t\tpq.push(s);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\texist.insert(s);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ma) {\n\t\t\tcout << pq.top() << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << 0 << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\n#define x first\n#define y second\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nint dx[] = { 1, 1, 0,-1,-1,-1, 0, 1};\nint dy[] = { 0, 1, 1, 1, 0,-1,-1,-1};\n\nint main(void){\n    for(int w, h; cin >> h >> w, h;){\n        vs strs(h);\n        rep(y, h){\n            cin >> strs[y];\n        }\n\n        set<string> s;\n        string res = \"0\";\n        rep(y, h){\n            rep(x, w){\n                rep(i, 8){\n                    string cur;\n                    pii next = mp(x, y);\n\n                    do{\n                        cur.pb(strs[next.y][next.x]);\n                        if(1 < cur.size() && !s.insert(cur).second)\n                        {\n                            if((res.size() < cur.size()) || \n                               (res.size() == cur.size() && cur < res)){\n                                res = cur;\n                            }\n                        }\n\n                        next.x = (next.x + dx[i] + w) % w;\n                        next.y = (next.y + dy[i] + h) % h;\n                        \n                    } while(next != mp(x, y));\n                }\n            }\n        }\n\n        cout << res << endl;\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <set>\nusing namespace std;\n\nint main(){\n  int h,w;\n  int dx[] = {-1,0,1,-1,1,-1,0,1};\n  int dy[] = {1,1,1,0,0,-1,-1,-1};\n  while(cin >> h >> w && h && w){\n    char c[11][21];\n    set<string> s;\n    string ans = \"\";\n\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin >> c[i][j];\n      }\n    }\n\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tfor(int k=0;k<8;k++){\n\t  int x = j;\n\t  int y = i;\n\n\t  string str;\n\t  str += c[y][x];\n\n\t  while(1){\n\t    x += dx[k];\n\t    y += dy[k];\n\n\t    if(x < 0) x = w - 1;\n\t    else if(x >= w) x = 0;\n\t    if(y < 0) y = h - 1;\n\t    else if(y >= h) y = 0;\n\n\t    if(x == j && y == i) break;\n\t    else str += c[y][x];\n\n\t    \n\t    if(!s.empty() && s.find(str) != s.end() && str.size() > ans.size()) ans = str;\n\t    else if(!s.empty() && s.find(str) != s.end() && str.size() == ans.size() && str < ans) ans = str;\n\t    else s.insert(str);\n\t    \n\t  }\n\n\t}\n      }\n    }\n    if(ans != \"\") cout << ans << endl;\n    else cout << \"0\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nint main() {\n\tint h, w;\n\twhile (cin >> h >> w, h) {\n\t\tvector<string> map(h);\n\t\tfor (auto &a : map)cin >> a;\n\t\tint dx[] = { 0,0,1,1,1,-1,-1,-1 };\n\t\tint dy[] = { 1,-1,0,-1,1,0,1,-1 };\n\t\tvector<tuple<string, int, int, int>> buf;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tfor (int d = 0; d < 8; d++) {\n\t\t\t\t\tbuf.push_back(make_tuple((string)\"\" + map[i][j], j, i, d));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint l = 1;\n\t\tfor (;; l++) {\n\t\t\tsort(buf.begin(), buf.end());\n\t\t\tvector<tuple<string, int, int, int>> buf2;\n\t\t\tfor (int i = 1; i < buf.size(); i++) {\n\t\t\t\tif (get<0>(buf[i - 1]).size() < l)continue;\n\t\t\t\tif (get<0>(buf[i - 1]) == get<0>(buf[i]))buf2.push_back(buf[i - 1]);\n\t\t\t\tfor (; i<buf.size()&&get<0>(buf[i - 1]) == get<0>(buf[i]); i++)buf2.push_back(buf[i]);\n\t\t\t}\n\t\t\tif (buf2.empty())break;\n\t\t\tbuf = move(buf2);\n\t\t\tfor (auto &a : buf) {\n\t\t\t\tstring str;\n\t\t\t\tint x, y, d;\n\t\t\t\ttie(str, x, y, d) = a;\n\t\t\t\tint x1 = ((x + dx[d]*l) % w + w) % w;\n\t\t\t\tint y1 = ((y + dy[d]*l) % h + h) % h;\n\t\t\t\tif (x1 == x && y1 == y)continue;\n\t\t\t\tstr += map[y1][x1];\n\t\t\t\ta = make_tuple(str, x, y, d);\n\t\t\t}\n\t\t}\n\t\tif (l < 3)cout << 0 << endl;\n\t\telse {\n\t\t\tstring str = get<0>(buf[0]);\n\t\t\tcout << str.substr(0, l-1) << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nint main() {\n\tint h, w;\n\twhile (cin >> h >> w, h) {\n\t\tvector<string> map(h);\n\t\tfor (auto &a : map)cin >> a;\n\t\tint dx[] = { 0,0,1,1,1,-1,-1,-1 };\n\t\tint dy[] = { 1,-1,0,-1,1,0,1,-1 };\n\t\tvector<tuple<string, int, int, int>> buf;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tfor (int d = 0; d < 8; d++) {\n\t\t\t\t\tbuf.push_back(make_tuple((string)\"\" + map[i][j], j, i, d));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint l = 1;\n\t\tfor (;; l++) {\n\t\t\tsort(buf.begin(), buf.end());\n\t\t\tvector<tuple<string, int, int, int>> buf2;\n\t\t\tfor (int i = 1; i < buf.size(); i++) {\n\t\t\t\tif (get<0>(buf[i - 1]).size() < l)continue;\n\t\t\t\tif (get<0>(buf[i - 1]) == get<0>(buf[i]))buf2.push_back(buf[i - 1]);\n\t\t\t\tfor (; i<buf.size()&&get<0>(buf[i - 1]) == get<0>(buf[i]); i++)buf2.push_back(buf[i]);\n\t\t\t}\n\t\t\tif (buf2.empty())break;\n\t\t\tbuf = move(buf2);\n\t\t\tfor (auto &a : buf) {\n\t\t\t\tstring str;\n\t\t\t\tint x, y, d;\n\t\t\t\ttie(str, x, y, d) = a;\n\t\t\t\tint x1 = ((x + dx[d]*l) % w + w) % w;\n\t\t\t\tint y1 = ((y + dy[d]*l) % h + h) % h;\n\t\t\t\tif (x1 == x && y1 == y)continue;\n\t\t\t\tstr += map[y1][x1];\n\t\t\t\ta = make_tuple(str, x, y, d);\n\t\t\t}\n\t\t}\n\t\tif (l < 3)cout << 0 << endl;\n\t\telse {\n\t\t\tstring str = get<0>(buf[0]);\n\t\t\tcout << str.substr(0, l-1) << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <set>\n#include <vector>\nusing  namespace std;\n\nint dr[]={-1, -1, -1, 0, 0, 1, 1, 1};\nint dc[]={-1, 0, 1, -1, 1, -1, 0, 1};\n\nbool cmp(const string& a, const string& b)\n{\n    if (a.size()<b.size()) return 1;\n    if (a.size()>b.size()) return 0;\n    return a>b;\n}\n\nint main()\n{\n    int n, m;\n    while (scanf(\"%d%d\", &n, &m), n) {\n        char s[11][21];\n        for(int i=0;i<n;++i) scanf(\"%s\", s[i]);\n\n        int maxlen=0;\n        vector<string> spells[200];\n        for(int i=0;i<n;++i) for(int j=0;j<m;++j) for(int k=0;k<8;++k) {\n            int r=i, c=j, q=0;\n            string t;\n            do {\n                t+=s[r][c];\n                spells[q++].push_back(t);\n                r=(r+dr[k]+2*n)%n;\n                c=(c+dc[k]+2*m)%m;\n            } while (r!=i || c!=j);\n            maxlen=max(maxlen, q);\n        }\n\n        string res;\n        for(int k=1;k<maxlen;++k) {\n            int N=spells[k].size();\n            set<string> v;\n            for(int i=0;i<N;++i) {\n                if (v.count(spells[k][i]) and cmp(res, spells[k][i]))\n                    res=spells[k][i];\n                v.insert(spells[k][i]);\n            }\n        }\n        puts(res.size()?res.c_str():\"0\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint H, W;\nchar F[10][21];\n\nstring get(int y1, int x1, int y2, int x2, int d1, int d2) {\n  static int dy[] = { 0, -1, -1, -1, 0, 1, 1, 1 };\n  static int dx[] = { 1, 1, 0, -1, -1, -1, 0, 1 };\n  string tmp;\n  int sy1 = y1;\n  int sx1 = x1;\n  int sy2 = y2;\n  int sx2 = x2;\n  bool first = true;\n  while(true) {\n    if(F[y1][x1] != F[y2][x2]) break;\n    if(!first && y1 == sy1 && x1 == sx1) break;\n    if(!first && y2 == sy2 && x2 == sx2) break;\n    first = false;\n    tmp += F[y1][x1];\n    y1 += dy[d1];\n    x1 += dx[d1];\n    y2 += dy[d2];\n    x2 += dx[d2];\n    // mod\n    if(y1 < 0) y1 += H;\n    if(x1 < 0) x1 += W;\n    if(y2 < 0) y2 += H;\n    if(x2 < 0) x2 += W;\n    y1 %= H;\n    x1 %= W;\n    y2 %= H;\n    x2 %= W;\n  }\n  return tmp;\n}\n\nint main() {\n  while(true) {\n    cin >> H >> W;\n    if(H == 0 && W == 0) break;\n    for(int i = 0; i < H; ++i) {\n      cin >> F[i];\n    }\n    string ans;\n    for(int y1 = 0; y1 < H; ++y1) {\n      for(int x1 = 0; x1 < W; ++x1) {\n        for(int y2 = 0; y2 < H; ++y2) {\n          for(int x2 = 0; x2 < W; ++x2) {\n            for(int d1 = 0; d1 < 8; ++d1) {\n              for(int d2 = 0; d2 < 8; ++d2) {\n                if(y1 == y2 && x1 == x2 && d1 == d2) continue;\n                string tmp = get(y1, x1, y2, x2, d1, d2);\n                if(tmp.size() > ans.size() || (tmp.size() == ans.size() && tmp < ans)) {\n                  ans = tmp;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    if(ans.size() < 2) cout << 0 << endl;\n    else cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> dy = {1, 1, 0, -1, -1, -1, 0, 1};\nvector<int> dx = {0, 1, 1, 1, 0, -1, -1, -1};\nvoid spell(map<string, int> &mp, vector<vector<char>> &c, int y, int x, int d){\n  int h = c.size();\n  int w = c[0].size();\n  string S;\n  int y2 = y;\n  int x2 = x;\n  while (1){\n    S += c[y2][x2];\n    mp[S]++;\n    y2 = (y2 + h + dy[d]) % h;\n    x2 = (x2 + w + dx[d]) % w;\n    if (y2 == y && x2 == x){\n      break;\n    }\n  }\n}\nint main(){\n  while (1){\n    int h, w;\n    cin >> h >> w;\n    if (h == 0 && w == 0){\n      break;\n    }\n    vector<vector<char>> c(h, vector<char>(w));\n    for (int i = 0; i < h; i++){\n      for (int j = 0; j < w; j++){\n        cin >> c[i][j];\n      }\n    }\n    map<string, int> mp;\n    for (int i = 0; i < h; i++){\n      for (int j = 0; j < w; j++){\n        for (int k = 0; k < 8; k++){\n          spell(mp, c, i, j, k);\n        }\n      }\n    }\n    string ans = \"A\";\n    for (auto P : mp){\n      if (P.second >= 2){\n        if (P.first.size() > ans.size() || P.first.size() == ans.size() && P.first < ans){\n          ans = P.first;\n        }\n      }\n    }\n    if (ans == \"A\"){\n      cout << 0 << endl;\n    } else {\n      cout << ans << endl;\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define debug(x) cout << \"debug \" << x << endl;\nconst int INF = 100000000;\nusing namespace std;\n\nstring m[1000];\nstring ans;\nint h, w;\nmap<string, int> msi;\n\nstatic const int dy[8] = {0,-1,-1,-1,0,1,1,1};\nstatic const int dx[8] = {1,1,0,-1,-1,-1,0,1};\n\nstring big(string a, string b){\n    if(a.size() > b.size()) return a;\n    else if(a.size() < b.size()) return b;\n    else{\n        if(a < b) return a;\n        else return b;\n    }\n}\n\nvoid search(int y, int x){\n    rep(i,8){\n        string s;\n        int j = 0;\n        while(true){\n            s += m[y + dy[i] * j][x + dx[i] * j];\n            msi[s]++;\n            if(msi[s] == 2){\n                ans = big(ans, s);\n            }\n            j++;\n            if(dy[i] * j % h == 0 && dx[i] * j % w == 0) break;\n        }\n    }\n}\n\nint main(){\n    while(cin >> h >> w, h||w){\n        rep(i,1000) m[i] = \"\";\n        ans = \"\";\n        msi.clear();\n        rep(i,h){\n            string s;\n            cin >> s;\n            rep(j,50) rep(k,50) m[i + j * h]+=s;\n        }\n        for(int i = h * 25; i < h * 26; i++){\n            for(int j = w * 25; j < w * 26; j++){\n                search(i,j);\n            }\n        }\n        if(ans.size() < 2 ) cout << 0 << endl;\n        else cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip\t;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nint dx[]={1,1,1,0,0,-1,-1,-1};\nint dy[]={1,0,-1,1,-1,1,0,-1};\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n+m){\n\t\tvector<string>in(n);\n\t\trep(i,n)cin>>in[i];\n\t\tset<string>out1,out2;\n\t\tstring out=\"\";\n\t\trep(i,n)rep(j,m)rep(k,8){\n\t\t\tint sx=i,sy=j;\n\t\t\tstring s=\"\";\n\t\t\ts+=in[sx][sy];\n\t\t\tint nx=(sx+dx[k]+n)%n,ny=(sy+dy[k]+m)%m;\n\t\t\twhile(nx!=sx||ny!=sy){\n\t\t\t\ts+=in[nx][ny];\n\t\t\t\tnx=(nx+dx[k]+n)%n,ny=(ny+dy[k]+m)%m;\n\t\t\t\tif(out1.find(s)!=out1.end()){\n\t\t\t\t\tif(out.size()==s.size()){\n\t\t\t\t\t\tif(s<out)out=s;\n\t\t\t\t\t}else if(out.size()<s.size()){\n\t\t\t\t\t\tout=s;\n\t\t\t\t\t}\n\t\t\t\t}else out1.insert(s);\n\t\t\t}\n\t\t}\n\t\tif(out==\"\")cout<<0<<endl;\n\t\telse cout<<out<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint gcd(int a, int b){\n    while(a != b){\n        if(a > b) a = a - b; else b = b - a;\n    }\n    return a;\n}\n\nint lcm(int a, int b){\n    return ((a / gcd(a, b)) * b);\n}\n\nint main(){\n    int h, w;\n    while(true){\nchar torus[10][20];\n        string str[2048];\n        bool ok[2048];\n        int num = 0;\n\n        for(int i=0; i<2048; ++i){\n            str[i] = \"\";\n            ok[i] = true;\n        }\n\n        cin >> h >> w;\n        if(h==0 && w==0) break;\n\n        int cml = lcm(w, h);\n\n        for(int i=0; i<h; ++i){\n            for(int j=0; j<w; ++j){\n                cin >> torus[i][j];\n            }\n        }\n\n        //一番長い文字列をつくる\n\n        for(int y=0; y<h; ++y){\n            for(int x=0; x<w; ++x){\n                for(int i=0; i<h; ++i){\n                    str[num] += torus[(y+i)%h][x];\n                    str[num+1] += torus[h-(y+i)%h-1][x];\n                }\n                num += 2;\n            }\n        }\n        for(int y=0; y<h; ++y){\n            for(int x=0; x<w; ++x){\n                for(int i=0; i<w; ++i){\n                    str[num] += torus[y][(x+i)%w];\n                    str[num+1] += torus[y][w-(x+i)%w-1];\n                }\n                num += 2;\n            }\n        }\n        for(int y=0; y<h; ++y){\n            for(int x=0; x<w; ++x){\n                for(int i=0; i<cml; ++i){\n                    str[num] += torus[(y+i)%h][(x+i)%w];\n                    str[num+1] += torus[(y+i)%h][w-(x+i)%w-1];\n                    str[num+2] += torus[h-(y+i)%h-1][(x+i)%w];\n                    str[num+3] += torus[h-(y+i)%h-1][w-(x+i)%w-1];\n                }\n                num += 4;\n            }\n        }\n\n\n        string result = \"\";\n\n        sort(str, str+num);\n\n        //徐々に削る\n        for(int i=0; i<cml; ++i){\n            for(int j=num-1; j>0; --j){\n                if(ok[j] && str[j].length() >= i && str[j-1].length() >= i){\n                    if(str[j].substr(0, i) == str[j-1].substr(0, i)){\n                        result = str[j];\n                        result.resize(i);\n                    }else{\n                        ok[j] = false;\n                    }\n                }\n            }\n        }\n\n        cout << ((result.length() <= 1) ? \"0\" : result) << endl;\n\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <set>\nusing namespace std;\n\n#define LET(name, value) __typeof(value) name = value\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define FOR(i, a, b) for (int i = (a); i < (int)(b); ++i)\n#define FOREQ(i, a, b) for (int i = (a); i <= (int)(b); ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define FOREACH(i, c) for (LET(i, (c).begin()); i != (c).end(); ++i)\n\nchar field[30][30];\n\nint main() {\n  int h, w;\n  while (scanf(\"%d%d\", &h, &w), h|w) {\n    REP(y, h) REP(x, w) { scanf(\" %c\", &field[y][x]); }\n\n    static const int dy[] = {-1, -1, -1, 0, 0, 1, 1, 1};\n    static const int dx[] = {-1, 0, 1, -1, 1, -1, 0, 1};\n    set<string> dict;\n    string ans, str;\n    REP(sy, h) REP(sx, w) REP(dir, 8) {\n      int y = sy, x = sx;\n      str.clear();\n      do {\n        str += field[y][x];\n        LET(it, dict.lower_bound(str));\n        if (it != dict.end() && *it == str) {\n          if (str.size() > ans.size() || (str.size() == ans.size() && str < ans)) {\n            ans = str;\n          }\n        } else {\n          dict.insert(it, str);\n        }\n        y = (y + dy[dir] + h) % h;\n        x = (x + dx[dir] + w) % w;\n      } while (y != sy || x != sx);\n    }\n    printf(\"%s\\n\", ans.size() > 1 ? ans.c_str() : \"0\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stdio.h>\n#include <set>\n\nusing namespace std;\n\n#define dirmax 8\n\nint l[2];\nint dir[8][2] = { {0,1}, {1,0}, {-1,0}, {0,-1}, {1,1}, {-1,1}, {1,-1}, {-1,-1} };\nchar ch[10][20];\nint pos[2];\nstring ans;\n\nvoid search(set<string> *v){\n\n\tfor(int i = 0; i < dirmax; i++) {\n\t\tstring str;\n\t\tint cpos[] = { pos[0], pos[1] };\n\n\t\tstr += ch[pos[0]][pos[1]];\n\n\t\twhile( 1 ) {\n\t\t\tfor(int j = 0; j < 2; j++) {\n\t\t\t\tcpos[j] += dir[i][j];\n\t\t\t\tif( cpos[j] < 0 ) cpos[j] = l[j] - 1;\n\t\t\t\tif( cpos[j] >= l[j] ) cpos[j] = 0;\n\t\t\t}\n\t\t\tif( cpos[0] == pos[0] && cpos[1] == pos[1] ) break;\n\n\t\t\tstr += ch[cpos[0]][cpos[1]];\n\t\t\t\n\t\t\tif( v->find(str) != v->end() ) {\n \t\t\t\tif( ( str.length() > ans.length() ) || ( str.length() == ans.length() && str < ans ) ) {\n\t\t\t\t\tans = str;\n\t\t\t\t}\n\t\t\t} else \n\t\t\t\tv->insert(str);\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tcin >> l[0] >> l[1];\n\t\tif( l[0] == 0 && l[1] == 0 ) break;\n\n\t\tans = \"\";\n\t\tset< string > strs;\n\n\t\tfor(int i = 0; i < l[0]; i++)\n\t\t\tcin >> ch[i];\n\t\t\n\t\tfor(pos[0] = 0; pos[0] < l[0]; pos[0]++)\n\t\t\tfor(pos[1] = 0; pos[1] < l[1]; pos[1]++)\n\t\t\t\tsearch( &strs );\n\n\t\tif(ans == \"\") \n\t\t\tcout << 0 << endl;\n\t\telse \n\t\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <queue>\n#include <cstdio>\n#include <ctime>\n#include <assert.h>\n#include <chrono>\n#include <random>\n#include <numeric>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned long long ull;\n\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n    return (ull)rng() % B;\n}\n\nmap<string,int> mp;\n\nint h,w;\nchar fi[22][22];\n\nint dx[]={1,1,1,0,0,-1,-1,-1};\nint dy[]={-1,0,1,-1,1,-1,0,1};\n\nvoid dfs(int sx,int sy,int x,int y,int k,string s){\n\ts+=fi[x][y];\n\tmp[s]++;\n\tint nx=(x+dx[k]+h)%h;\n\tint ny=(y+dy[k]+w)%w;\n\tif(nx==sx&&ny==sy)return;\n\tdfs(sx,sy,nx,ny,k,s);\n}\n\nint main(){\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\twhile(cin >> h >> w,h){\n\t\tmp.clear();\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tcin >> fi[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tfor(int k=0;k<8;k++){\n\t\t\t\t\tdfs(i,j,i,j,k,\"\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstring res=\"\";\n\t\tfor(auto p:mp){\n\t\t\tif(p.second>=2){\n\t\t\t\tif(p.first.size()>res.size())res=p.first;\n\t\t\t\telse if(p.first.size()==res.size())res=min(res,p.first);\n\t\t\t}\n\t\t}\n\t\tcout << ((res.size()>=2)?res:\"0\") << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <vector>\n#include <iostream>\n#include <cstring>\nusing namespace std;\nint m[29][29];\nmain(){\n\tstring s,t;\n\tint h,w,i,j,x,y;\n\tfor(;cin>>h>>w,h;cout<<s<<endl){\n\t\tvector<string>v;\n\t\tfor(i=0;i<h;i++)cin>>s,v.push_back(s);\n\t\ts=\"0\";\n\t\tmap<string,int>M;\n\t\tfor(i=0;i<h;i++)for(j=0;j<w;j++)for(x=-1;x<=1;x++)for(y=-1;y<=1;y++){\n\t\t\tif(x==0&&y==0)continue;\n\t\t\tmemset(m,0,sizeof(m));\n\t\t\tint Y=i,X=j;\n\t\t\tt=v[Y][X],m[Y][X]=1;X=(X+x+w)%w,Y=(Y+y+h)%h;\n\t\t\tfor(;!m[Y][X];X=(X+x+w)%w,Y=(Y+y+h)%h){\n\t\t\t\tt+=v[Y][X],m[Y][X]=1;\n\t\t\t\tif(++M[t]>1 && (s.size()<t.size()||(s.size()==t.size()&&s>t)))s=t;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nvector<string> v;\nint h,w;\nstring s[10];\n\nstring search(int a,int b,int d)\n{\n\tint dirx[8]={1,1,0,-1,-1,-1,0,1};\n\tint diry[8]={0,-1,-1,-1,0,1,1,1};\n\tstring ret;\n\tint i=a;\n\tint j=b;\n\tdo{\n\t\tret+=s[i][j];\n\t\ti+=dirx[d];\n\t\tj+=diry[d];\n\t\tif(i==-1)\n\t\t\ti=h-1;\n\t\tif(i==h)\n\t\t\ti=0;\n\t\tif(j==-1)\n\t\t\tj=w-1;\n\t\tif(j==w)\n\t\t\tj=0;\n\t}while(!(i==a && j==b));\n\treturn ret;\n}\n\nbool comp(string a,string b)\n{\n\tif(a.size()==b.size())\n\t\treturn a<b;\n\telse\n\t\treturn a.size()>b.size();\n}\n\nstring itti(string a,string b)\n{\n\tstring ret;\n\tfor(int i=0;i<min(a.size(),b.size());i++)\n\t{\n\t\tif(a[i]!=b[i])\n\t\t\tbreak;\n\t\tret+=a[i];\n\t}\n\treturn ret;\n}\n\nint main()\n{\n\twhile(1)\n\t{\n\t\tv.clear();\n\t\tcin>>h>>w;\n\t\tif(h==0)\n\t\t\tbreak;\n\t\tfor(int i=0;i<h;i++)\n\t\t\tcin>>s[i];\n\t\t\n\t\t//すべての始点を調べる\n\t\tfor(int i=0;i<h;i++)\n\t\t{\n\t\t\tfor(int j=0;j<w;j++)\n\t\t\t{\n\t\t\t\tfor(int k=0;k<8;k++)\n\t\t\t\t\tv.push_back(search(i,j,k));\n\t\t\t}\n\t\t}\n\n\t\tsort(v.begin(),v.end());\n\t\tstring ans=\"0\";\n\t\tfor(int i=1;i<v.size();i++)\n\t\t{\n\t\t\tstring tmp=itti(v[i],v[i-1]);\n\t\t\tif(comp(tmp,ans))\n\t\t\t\tans=tmp;\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) REP(i, 0, n)\n#define REP(i, s, e) for(int i = (int)(s); i< (int)(e); ++i)\n\nint dx[] = {0, 0, -1,-1, -1, 1, 1, 1};\nint dy[] = {-1, 1, 0, 1, -1, 0, 1,-1};\n\nmap<string, int> mp;\nvector<string> input;\nint H, W;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nvoid f(int x, int y, set<pii>& st, string& s, const int dir) {\n  //  cout << x << \" \" << y << \" \" << dir <<\" \" << s << endl;\n  //  cout <<mp.size() << endl;\n  //  cout <<s.size() << \" \" << st.size() << \" \" << mp.size() << endl;\n  s += input[y][x];\n  mp[s]++;\n  pii p;\n  p = make_pair(y, x);\n  st.insert(p);\n  (x += dx[dir] + W) %= W;\n  (y += dy[dir] + H) %= H;\n  assert(x >= 0 && x < W);\n  assert(y >= 0 && y < H);\n  p = make_pair(y, x);\n  if(st.count(p)) return;\n  f(x, y, st, s, dir);\n}\n\nint main() {\n  while(cin >> H >> W) {\n    if(H == 0 && W == 0) break;\n    mp.clear();\n    input.resize(H);\n    rep(i, H) cin >> input[i];\n    rep(i, H) rep(j, W) rep(k, 8) {\n      set<pii> st;\n      string s;\n      f(j, i, st, s, k);\n    }\n    string s;\n    for(map<string, int>::iterator it = mp.begin(); it != mp.end(); ++it) {\n      if(it->second == 1) continue;\n      if(s.size() < it->first.size()) s = it->first;\n      else {\n\tif(s.size() == it->first.size() && s > it->first) s = it->first;\n      }\n    }\n    if(s.size() == 0) cout << 0 << endl;\n    else cout << s << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<cstring>\n#include<algorithm>\n#include<map>\n#include<vector>\nusing namespace std;\nbool vis[30][30];\nchar str[30][30];\nvector<string>q;\nint dir[8][2] = {0,1,0,-1,1,0,-1,0,1,-1,1,1,-1,1,-1,-1};\nmap<string,int>mp;\nconst int maxn = 1000010;\nint chd[maxn][26];\nint val[maxn];\nstring Ans;\nint  sz,L;\nvoid insert(string s){\n    int l = s.length();\n    int rt = 0;\n    string ss = \"\";\n    for(int i = 0; i < l; i++){\n        int t = s[i] - 'A';\n        ss += s[i];\n        if(!chd[rt][t]){\n            chd[rt][t] = ++sz;\n        }\n        rt = chd[rt][t];\n        val[rt]++;\n        if(val[rt] >= 2 ){\n            if(i + 1 > L ){\n                L = i + 1;\n                Ans = ss;\n            }else if(i + 1 == L){\n                if(ss < Ans)  Ans = ss;\n            }\n        }\n    }\n}\nint main(){\n    int N,M;\n    while(cin>>N>>M && N + M){\n        memset(val,0,sizeof(val));\n        memset(chd,0,sizeof(chd));\n\n        for(int i = 0; i < N; i++){\n            scanf(\"%s\",str[i]);\n        }\n\n        Ans = \"\";\n        sz = 0,L = 0;\n        for(int i = 0; i < N; i++)\n            for(int j = 0; j < M; j++){\n                for(int k = 0; k < 8; k++){\n                    memset(vis,0,sizeof(vis));\n                    int x = i,y = j;\n                    string s = \"\";\n                    s += str[x][y];\n                    vis[x][y] = true;\n                    while(true){\n                        x = ((x + dir[k][0]) % N + N) % N;\n                        y = ((y + dir[k][1]) % M + M) % M;\n                        if(vis[x][y]) break;\n                        s += str[x][y];\n                        vis[x][y] = true;\n                    }\n                    insert(s);\n                }\n            }\n    if(Ans.length()<=1) puts(\"0\");\n    else\n        cout<<Ans<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long LL;\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nusing namespace std;\nint main(void)\n{\n  for(;;){\n    int h,w;\n    cin >> h >> w;\n    if(!h) return 0;\n    vector<string> f(h);\n    REP(i,h) cin >> f[i];\n    map<string,int> spell;\n    int di[3]={h-1,0,1},dj[3]={w-1,0,1};\n    REP(i,h) REP(j,w){\n      REP(k,3) REP(l,3){\n\tstring tmp=\"\";\n\tint tmpi=i,tmpj=j;\n\tdo{\n\t  tmp.push_back(f[tmpi][tmpj]);\n\t  ++spell[tmp];\n\t  tmpi=(tmpi+di[k])%h;\n\t  tmpj=(tmpj+dj[l])%w;\n\t}while(tmpi!=i||tmpj!=j);\n      }\n    }\n    string answer=\"\";\n    for(auto x:spell){\n      if(x.first.size()<=1 || x.second<2) continue;\n      if(x.first.size()>answer.size()) answer=x.first;\n      else if(x.first.size()==answer.size()) answer=min(answer,x.first);\n    }\n    if(answer.size()<2) cout << 0 << endl;\n    else cout << answer << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * GCA : \"Computer is artificial subject absolutely,Math is God\"\n */\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <cctype>\n#include <utility>\n#include <ctime>\nusing namespace std;\n#ifdef DEBUG\n#define VAR(a,b) __typeof(b) a=(b)\n#define debug(...) printf(\"DEBUG: \"),printf(__VA_ARGS__)\n#else\n#define VAR(a,b) __typeof(b) a=(b)\n#define debug(...)\n#endif\ntypedef unsigned int uint;\ntypedef long long int Int;\ntypedef unsigned long long int UInt;\n#define Set(a,s) memset(a,s,sizeof(a))\n#define Pln() printf(\"\\n\")\n#define For(i,x)for(int i=0;i<x;i++)\n#define CON(x,y) x##y\n#define M 25\n#define PB push_back\n#define oo INT_MAX\n#define FOR(a,b) for(VAR(a,(b).begin());a!=(b).end();++a)\n#define eps 1e-9\n#define X first\n#define Y second\ninline bool xdy(double x,double y){return x>y+eps;}\ninline bool xddy(double x,double y){return x>y-eps;}\ninline bool xcy(double x,double y){return x<y-eps;}\ninline bool xcdy(double x,double y){return x<y+eps;}\nconst Int mod=1000000007;\nint nx,ny;\nchar mz[M][M];\nset<Int> sid;\nint dx[8]={0,1,1,1,0,-1,-1,-1};\nint dy[8]={1,1,0,-1,-1,-1,0,1};\nchar store[M*M];\nint ox,oy;\nstring ans;\nInt isid;\nbool vis[M][M];\nvoid dfs(int x,int y,int d,int dep){\n\n\tstore[dep]=mz[y][x];\n\tint nex=(x+dx[d]+nx)%nx;\n\tint ney=(y+dy[d]+ny)%ny;\n\tstore[dep+1]=0;\n\tisid=130*isid+store[dep];\n\tstring ss(store);\n\tif(sid.count(isid)&&ss.length()>=2){\n\t\tif(ss.length()>ans.length())ans=ss;\n\t\telse if(ss.length()==ans.length()&&ss<ans){\n\t\t\tans=ss;\n\t\t}\n\t}\n\tsid.insert(isid);\n\tvis[x][y]=1;\n\tif(!vis[nex][ney])dfs(nex,ney,d,dep+1);\n\tvis[x][y]=0;\n\n}\nvoid solve(){\n\tSet(vis,0);\n\tfor(int i=0;i<ny;i++){\n\t\tfor(int j=0;j<nx;j++){\n\t\t\tfor(int k=0;k<8;k++){\n\t\t\t\tisid=0;\n\t\t\t\tvis[j][i]=1;\n\t\t\t\tdfs(j,i,k,0);\n\t\t\t\tvis[j][i]=0;\n\t\t\t}\n\t\t}\n\t}\n\tif(ans.size())\n\t\tputs(ans.c_str());\n\telse puts(\"0\");\n}\nint main() {\n\tios_base::sync_with_stdio(0);\n\twhile(~scanf(\"%d%d\",&ny,&nx)&&ny&&nx){\n\t\tsid.clear();\n\t\tans=\"\";\n\t\tfor(int i=0;i<ny;i++)scanf(\"%s\",mz[i]);\n\t\tsolve();\n\n\t}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <iostream>\n#include <map>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint h,w;\nstring fie[11];\nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,1,-1};\nmap<string,int> cnt;\nbool used[11][21];\nvector<string> index;\n\nvoid dfs(int y,int x,int k,string str){\n\tif(used[y][x])return;\n\tused[y][x]=true;\n\tstr+=fie[y][x];\n\tcnt[str]++;\n\tindex.push_back(str);\n\tdfs((y+dy[k]+h)%h,(x+dx[k]+w)%w,k,str);\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&h,&w);\n\t\tif(h+w==0)break;\n\t\tcnt.clear();\n\t\tindex.clear();\n\t\tfor(int i=0;i<h;i++){\n\t\t\tcin >> fie[i];\n\t\t}\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tfor(int k=0;k<8;k++){\n\t\t\t\t\tmemset(used,false,sizeof(used));\n\t\t\t\t\tdfs(i,j,k,\"\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(index.begin(),index.end());\n\t\tindex.erase(unique(index.begin(),index.end()),index.end());\n\t\tstring res=\"0\";\n\t\tfor(int i=0;i<index.size();i++){\n\t\t\tif(cnt[index[i]]>=2 && index[i].size()>=2){\n\t\t\t\tif(res.size()<index[i].size() || (res.size()==index[i].size() && index[i]<res)){\n\t\t\t\t\tres=index[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\npii d[8] = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  \n  int h, w;\n  while (cin >> h >> w, h) {\n    vector<string> s(h);\n    for (int i = 0; i < h; i++) {\n      cin >> s[i];\n    }\n\n    map<string, int> cnt;\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        for (int k = 0; k < 8; k++) {\n          pii now = {i, j};\n          string t = \"\";\n          do {\n            t += s[now.first][now.second];\n            cnt[t]++;\n            now.first += d[k].first, now.second += d[k].second;\n            if (now.first < 0) now.first = h - 1;\n            else if (now.first >= h) now.first = 0;\n            if (now.second < 0) now.second = w - 1;\n            else if (now.second >= w) now.second = 0;\n          } while (now != pii(i, j));\n        }\n      }\n    }\n\n    int szMax = 1;\n    string ans = \"0\";\n    for (auto& i : cnt) {\n      if (i.second == 1) continue;\n      if (i.first.size() > szMax) {\n        ans = i.first;\n        szMax = ans.size();\n      }\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define all(v) begin(v), end(v)\nusing namespace std;\nusing P = pair<int, int>;\n\nint main() {\n  for (int h, w; cin >> h >> w, h;) {\n    vector<string> s(h);\n    rep(i, h) cin >> s[i];\n    multiset<string> st;\n    auto f = [&](int i, int j) { return s[i % h][j % w]; };\n    auto g = [](string t) {\n      int n = t.length();\n      rep(i, n / 2) {\n        if (t[i] != t[n - 1 - i]) return false;\n      }\n      return true;\n    };\n    auto calc = [&](string t) {\n      rep(i, t.length() - 1) {\n        auto tmp = t.substr(0, i + 2);\n        st.insert(tmp);\n      }\n    };\n    string t;\n    P cur, goal;\n    rep(i, h) rep(j, w) {\n      goal = {i, j};\n\n      t = \"\";\n      rep(k, h) t += f(i + k, j);\n      calc(t);\n      reverse(all(t));\n      calc(t);\n\n      t = \"\";\n      rep(k, w) t += f(i, j + k);\n      calc(t);\n      reverse(all(t));\n      calc(t);\n\n      t = \"\";\n      cur = {i, j};\n      while (true) {\n        t += f(cur.first, cur.second);\n        cur = {(cur.first + 1) % h, (cur.second + 1) % w};\n        if (cur == goal) break;\n      }\n      calc(t);\n      reverse(all(t));\n      calc(t);\n\n      t = \"\";\n      cur = {i, j};\n      while (true) {\n        t += f(cur.first, cur.second);\n        cur = {(cur.first + 1) % h, (cur.second - 1 + w) % w};\n        if (cur == goal) break;\n      }\n      calc(t);\n      reverse(all(t));\n      calc(t);\n    }\n    int m = 0;\n    for (auto x : st) {\n      if (st.count(x) >= 2) m = max(m, (int)x.length());\n    }\n    bool ok = false;\n    for (auto x : st) {\n      // cerr << x << ' ' << st.count(x) << endl;\n      if (x.length() != m || st.count(x) < 2) continue;\n      cout << x << endl;\n      ok = true;\n      break;\n    }\n    if (!ok) cout << 0 << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<double> vd;\ntypedef pair<ll,ll> P;\ntypedef pair<int,int> pii;\ntypedef vector<P> vpl;\ntypedef tuple<ll,ll,ll> tapu;\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define REP(i,a,b) for(int i=(a); i<(b); i++)\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\nconst int inf = 1<<30;\nconst ll linf = 1LL<<62;\nconst int MAX = 2020000;\nll dy[8] = {1,-1,0,0,1,-1,1,-1};\nll dx[8] = {0,0,1,-1,1,-1,-1,1};\nconst double pi = acos(-1);\nconst double eps = 1e-7;\ntemplate<typename T1,typename T2> inline bool chmin(T1 &a,T2 b){\n\tif(a>b){\n\t\ta = b; return true;\n\t}\n\telse return false;\n}\ntemplate<typename T1,typename T2> inline bool chmax(T1 &a,T2 b){\n\tif(a<b){\n\t\ta = b; return true;\n\t}\n\telse return false;\n}\ntemplate<typename T> inline void print(T &a){\n    rep(i,a.size()) cout << a[i] << \" \";\n    cout << \"\\n\";\n}\ntemplate<typename T1,typename T2> inline void print2(T1 a, T2 b){cout << a << \" \" << b << \"\\n\";}\ntemplate<typename T1,typename T2,typename T3> inline void print3(T1 a, T2 b, T3 c){\n\tcout << a << \" \" << b << \" \" << c << \"\\n\";\n}\nll pcount(ll x) {return __builtin_popcount(x);};\nconst int mod = 1e9 + 7;\n//const int mod = 998244353;\n\nvoid ch(int &y, int &x, int h, int w){\n    y = (y + h) % h;\n    x = (x + w) % w;\n}\n\nint main(){\n    while(1){\n        int h,w; cin >> h >> w;\n        if(h+w == 0) break;\n        vs s(h); rep(i,h) cin >> s[i];\n        map<string,int> mp;\n        rep(i,h){\n            rep(j,w){\n                rep(k,8){\n                    vb v(26,false);\n                    v[s[i][j]-'A'] = true;\n                    int y = i;\n                    int x = j;\n                    string t;\n                    while(1){\n                        t += s[y][x];\n                        mp[t]++;\n                        y += dy[k];\n                        x += dx[k];\n                        ch(y,x,h,w);\n                        if(y == i && x == j) break;\n                    }\n                }\n            }\n        }\n        ll num = 1;\n        string ans;\n        for(auto i : mp){\n            if(i.second >= 2){\n                if(num < i.first.size()){\n                    num = i.first.size();\n                    ans = i.first;\n                }\n            }\n        }\n        if(num == 1) cout << 0 << \"\\n\";\n        else cout << ans << \"\\n\";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nconstexpr int gcd(int a, int b){\n\treturn b == 0 ? a : gcd(b, a%b);\n}\nint main() {\n\tint h, w;\n\twhile (cin >> h >> w, h) {\n\t\tvector<string> map(h);\n\t\tfor (auto &a : map)cin >> a;\n\t\tint dx[] = { 0,0,1,1,1,-1,-1,-1 };\n\t\tint dy[] = { 1,-1,0,-1,1,0,1,-1 };\n\t\tvector<tuple<string, int, int, int>> buf;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tfor (int d = 0; d < 8; d++) {\n\t\t\t\t\tbuf.push_back(make_tuple((string)\"\" + map[i][j], j, i, d));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint l = 0;\n\t\tfor (; l < h*w / gcd(h, w); l++) {\n\t\t\tsort(buf.begin(), buf.end());\n\t\t\tvector<tuple<string, int, int, int>> buf2;\n\t\t\tfor (int i = 1; i < buf.size(); i++) {\n\t\t\t\tif (get<0>(buf[i - 1]).size() < l)continue;\n\t\t\t\tif (get<0>(buf[i - 1]) == get<0>(buf[i]))buf2.push_back(buf[i - 1]);\n\t\t\t\tfor (; i<buf.size()&&get<0>(buf[i - 1]) == get<0>(buf[i]); i++)buf2.push_back(buf[i]);\n\t\t\t}\n\t\t\tif (buf2.empty())break;\n\t\t\tbuf = move(buf2);\n\t\t\tfor (auto &a : buf) {\n\t\t\t\tstring str;\n\t\t\t\tint x, y, d;\n\t\t\t\ttie(str, x, y, d) = a;\n\t\t\t\tint x1 = ((x + dx[d]*l) % w + w) % w;\n\t\t\t\tint y1 = ((y + dy[d]*l) % h + h) % h;\n\t\t\t\tif (x1 == x && y1 == y)continue;\n\t\t\t\tstr += map[y1][x1];\n\t\t\t\ta = make_tuple(str, x, y, d);\n\t\t\t}\n\t\t}\n\t\tif (l < 3)cout << 0 << endl;\n\t\telse {\n\t\t\tstring str = get<0>(buf[0]);\n\t\t\tcout << str.substr(0, l-1) << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\nusing namespace std;\n\nint gcd(int a,int b){return b?gcd(b,a%b):a;}\nint lcm(int a,int b){return a/gcd(a,b)*b;}\n\nint main(){\n  int h,w;\n  string g[10];\n  int dx[] = {0,1,1,1,0,-1,-1,-1},dy[] ={-1,-1,0,1,1,1,0,-1};\n  int lm;\n\n  while(cin>> h >> w &&(h||w)){\n    for(int i=0;i<h;i++)cin >> g[i];\n\n    map<string,int> m;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n\tfor(int k=0;k<8;k++){\n\t  string tmp;\n\t  tmp += g[i][j];\n\t  int sx = j,sy = i;\n\t  if(k&1)lm = lcm(h,w);\n\t  else if(!(k%4))lm = h;\n\t  else lm = w;\n\t  for(int t=1;t<lm;t++){\n\t    sx = (sx+w+dx[k])%w;\n\t    sy = (sy+h+dy[k])%h;\n\t    tmp += g[sy][sx];\n\t    m[tmp]++;\n\t  }\n\t}\n\n\n    string ans = \"A\";\n    map<string,int>::iterator ite;\n    for(ite=m.begin();ite!=m.end();ite++)\n      if((*ite).second>1){\n\tstring tmp = (*ite).first;\n\tif(ans.size()<tmp.size() || (ans.size()==tmp.size()&&ans>tmp))ans = tmp;\n      }\n    if(ans.size()>1)cout << ans << endl;\n    else cout << 0 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <vector>\nusing namespace std;\n#define REP(i,x)for(int i=0;i<x;i++)\n\nstring res;\nint H,W,dx,dy,min_len;\nchar s[200];\nchar MAP[11][22];\nbool visit[20][20];\nvector<string> ss;\nvoid dfs(int x,int y,int k){\n  if(visit[y][x]){\n    ss.push_back(string(s));\n    return;\n  }\n  s[k]=MAP[y][x];  visit[y][x]=1;\n  dfs((x + dx + W) % W, (y + dy + H) % H, k + 1);\n  s[k]=0;  visit[y][x]=0;\n}\nint main() {\n  while(scanf(\"%d%d\",&H,&W),H){\n    REP(i,H)scanf(\"%s\",MAP[i]);\n    ss.clear();\n    min_len=1; res=\"0\";\n    REP(y,H)REP(x,W){\n      for(dx=-1;dx<=1;dx++){\n        for(dy=-1;dy<=1;dy++){\n          if(dx|dy)dfs(x,y,0);\n        }\n      }\n    }\n    string res = \"0\";\n    sort(ss.begin(),ss.end());\n    REP(i,ss.size()-1){\n      int len = 0;\n      if(min(ss[i].size(),ss[i+1].size()) < len)continue;\n      REP(k,min(ss[i].size(),ss[i+1].size())){\n        if(ss[i][k]==ss[i+1][k])len++;\n        else break;\n      }\n      if(len < res.size())continue;\n      if(res.size() == len){\n        res = min(res, ss[i].substr(0,len));\n      }else{\n        res = ss[i].substr(0, len);\n      }\n    }\n    puts(res.c_str());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <iostream>\n#include <map>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint h,w;\nchar fie[11][21];\nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,1,-1};\nbool used[11][21];\nvector<string> index2;\nstring str;\n\nvoid dfs(int y,int x,int k){\n\tif(used[y][x])return;\n\tused[y][x]=true;\n\tstr+=fie[y][x];\n\tindex2.push_back(str);\n\tdfs((y+dy[k]+h)%h,(x+dx[k]+w)%w,k);\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d%*c\",&h,&w);\n\t\tif(h+w==0)break;\n\t\tindex2.clear();\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tscanf(\"%c\",&fie[i][j]);\n\t\t\t}\n\t\t\tscanf(\"%*c\");\n\t\t}\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tfor(int k=0;k<8;k++){\n\t\t\t\t\tmemset(used,false,sizeof(used));\n\t\t\t\t\tstr=\"\";\n\t\t\t\t\tdfs(i,j,k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(index2.begin(),index2.end());\n\t\tint res=index2.size();\n\t\tindex2.push_back(\"0\");\n\t\tfor(int i=0;i<index2.size();i++){\n\t\t\tif(index2[i].size()>=2){\n\t\t\t\tif(index2[i]==index2[i-1] && index2[res].size()<index2[i].size())res=i;\n\t\t\t}\n\t\t}\n\t\tcout << index2[res] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = (1LL << 31) - 1;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n#define MAX_N 100100 * 3\n\nint h, w;\nstring s[100];\nset<string> vs;\n\nvoid make_s(int y, int x) {\n\tstring res = \"\";\n\tint posx = x, posy = y;\n\twhile (1) {\n\t\tposx++;\n\t\tposy++;\n\t\tif (posx == w)posx = 0;\n\t\tif (posy == h)posy = 0;\n\t\tres += s[posy][posx];\n\t\tif (posy == y&&posx == x)break;\n\t}\n\tvs.insert(res);\n\t//reverse(ALL(res));\n\t//vs.insert(res);\n\n\tres.clear();\n\tposx = x, posy = y;\n\twhile (1) {\n\t\tposx--;\n\t\tposy++;\n\t\tif (posx == -1)posx = w - 1;\n\t\tif (posy == h)posy = 0;\n\t\tres += s[posy][posx];\n\t\tif (posy == y&&posx == x)break;\n\t}\n\tvs.insert(res);\n\t//reverse(ALL(res));\n\t//vs.insert(res);\n}\n\nint main() {\n\twhile (cin >> h >> w&&w + h) {\n\t\tstring ans = \"\";\n\t\tvs.clear();\n\t\tREP(i, 100)s[i].clear();\n\t\tREP(i, h)cin >> s[i];\n\t\tREP(i, h) {\n\t\t\tstring t = s[i];\n\t\t\tvs.insert(t);\n\t\t}\n\t\tREP(i, w) {\n\t\t\tstring t = \"\";\n\t\t\tREP(j, h)t += s[j][i];\n\t\t\tvs.insert(t);\n\t\t}\n\t\tREP(i, h) {\n\t\t\tmake_s(i, 0);\n\t\t\tif (h != w)break;\n\t\t}\n\t\tfor (auto it : vs) {\n\t\t\tbool F = 0;\n\t\t\tchar c = it[0];\n\t\t\tREP(i, it.size()) {\n\t\t\t\tif (c != it[i])break;\n\t\t\t\tif (i == it.size() - 1)F = 1;\n\t\t\t}\n\t\t\tif (F) {\n\t\t\t\tif (ans.size() < it.size()) {\n\t\t\t\t\tans = it;\n\t\t\t\t}\n\t\t\t\telse if (ans.size() == it.size()) {\n\t\t\t\t\tif (it < ans)ans = it;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstring t = it + it;\n\t\t\treverse(ALL(t));\n\t\t\tstring r = t;\n\t\t\treverse(ALL(t));\n\t\t\t//cout << t << endl;\n\t\t\t//cout << r << endl;\n\t\t\tfor (int i = 0; i < it.size(); i++) {\n\t\t\t\tfor (int j = 1; j <= it.size(); j++) {\n\t\t\t\t\tstring buf = t.substr(i, j);\n\t\t\t\t\tbool f = 0;\n\t\t\t\t\tint now = t.size();\n\t\t\t\t\twhile (t.find(buf) != t.rfind(buf, now)) {\n\t\t\t\t\t\tif (t.rfind(buf, now) - t.find(buf) < it.size())f = 1;\n\t\t\t\t\t\tnow = t.rfind(buf, now) - 1;\n\t\t\t\t\t\t//cout << now << endl;\n\t\t\t\t\t\tif (now == -1)break;\n\t\t\t\t\t}\n\t\t\t\t\tif (r.find(buf) != -1)f = 1;\n\t\t\t\t\tif (f) {\n\t\t\t\t\t\tif (ans.size() < buf.size()) {\n\t\t\t\t\t\t\tans = buf;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (ans.size() == buf.size()) {\n\t\t\t\t\t\t\tif (buf < ans)ans = buf;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//buf = r.substr(i, j);\n\t\t\t\t\t//if (t.find(buf) != t.rfind(buf)) {\n\t\t\t\t\t//\tif (ans.size() < buf.size()) {\n\t\t\t\t\t//\t\tans = buf;\n\t\t\t\t\t//\t}\n\t\t\t\t\t//\telse if (ans.size() == buf.size()) {\n\t\t\t\t\t//\t\tif (buf < ans)ans = buf;\n\t\t\t\t\t//\t}\n\t\t\t\t\t//}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ans.size() == 1)cout << 0 << endl;\n\t\telse cout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <cstdio>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\nstruct P{\n    int x;\n    int y;\n    P() {}\n    ~P() {}\n    P(const P& r) : x(r.x), y(r.y) {}\n    P(int a, int b) : x(a), y(b) {}\n};\n\nstruct Q{\n    string spell;\n    P pos; vector<P> visited;\n    int dir;\n    Q() {}\n    ~Q() {}\n    Q(const Q& r) : spell(r.spell), pos(r.pos),\n                    visited(r.visited), dir(r.dir) {}\n    Q(string s, P p, vector<P> v, int d) : spell(s), pos(p),\n                                                   visited(v), dir(d) {} };\n\nint dx[8] = {1, 1, 0, -1, -1, -1, 0,   1};\nint dy[8] = {0, 1, 1, 1,   0, -1, -1, -1};\n\nint main(){\n    int h, w, x, y, z;\n    for(; cin >> h >> w, h||w;){\n        char field[20][20];\n        map<string, int> found;\n        for(char c = 'A'; c <= 'Z'; c++){\n            found[ string(1, c) ] = 0;\n        }\n        queue< Q > que;\n        vector<P> EMPTY(100);\n        for(x = 0; x < h; x++){\n            scanf(\" %s\", field[x]);\n            for(y = 0; y < w; y++){\n                found[ string(1, field[x][y]) ]++;\n                que.push( Q( string(1, field[x][y]), P(x, y), EMPTY, 0) );\n                que.push( Q( string(1, field[x][y]), P(x, y), EMPTY, 1) );\n                que.push( Q( string(1, field[x][y]), P(x, y), EMPTY, 2) );\n                que.push( Q( string(1, field[x][y]), P(x, y), EMPTY, 3) );\n                que.push( Q( string(1, field[x][y]), P(x, y), EMPTY, 4) );\n                que.push( Q( string(1, field[x][y]), P(x, y), EMPTY, 5) );\n                que.push( Q( string(1, field[x][y]), P(x, y), EMPTY, 6) );\n                que.push( Q( string(1, field[x][y]), P(x, y), EMPTY, 7) );\n            }\n        }\n        string best = \"0\";\n        for(int l = 1;; l++){\n            while(true){\n                if( que.empty() ) break;\n                Q q = que.front();\n                if( q.spell.size() != l ) break;\n                que.pop();\n                if( found[ q.spell ] < 2 ) continue;\n                if( q.spell.size() > best.size() ||\n                        (q.spell.size() == best.size() && q.spell < best) ){\n                    best = q.spell;\n                }\n                int cx = q.pos.x, cy = q.pos.y, d = q.dir;\n                int nx = (cx + dx[d] + h) % h, ny = (cy + dy[d] + w) % w;\n                bool ok = true;\n                for(vector<P>::iterator it = q.visited.begin();\n                        it != q.visited.end(); it++){\n                    if( (it->x == nx) && (it->y == ny) ){\n                        ok = false;\n                        break;\n                    }\n                }\n                if( ok ){\n                    string ns = q.spell;\n                    ns.append(1, field[nx][ny]);\n                    vector<P> nv = q.visited;\n                    nv.push_back( P(cx, cy) );\n                    que.push( Q( ns, P(nx, ny), nv, d ) );\n                    if( found.find(ns) == found.end() ){\n                        found[ns] = 1;\n                    }else{\n                        found[ns] ++;\n                    }\n                }\n            }\n            if( que.empty() ) break;\n        }\n        cout << best << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-7;\nconst double PI  = acos(-1.0);\n\nint dx[]={-1,0,1,1,1,0,-1,-1};\nint dy[]={-1,-1,-1,0,1,1,1,0};\nint main(){\n\tint h,w;\n\twhile(cin>>h>>w,h|w){\n\t\tvs f(h);\n\t\tREP(i,h){\n\t\t\tcin>>f[i];\n\t\t}\n\n\t\tmap<string,int> m;\n\t\tstring ans;\n\t\tREP(i,h){\n\t\t\tREP(j,w){\n\t\t\t\tREP(d,8){\n\t\t\t\t\tvvi used(h,vi(w));\n\t\t\t\t\tstring s;\n\t\t\t\t\tint y=i,x=j;\n\t\t\t\t\twhile(1){\n\t\t\t\t\t\tif(!used[y][x]){\n\t\t\t\t\t\t\ts+=f[y][x];\n\t\t\t\t\t\t\tused[y][x]=1;\n\t\t\t\t\t\t\ty+=dy[d];\n\t\t\t\t\t\t\tx+=dx[d];\n\t\t\t\t\t\t\tif(y<0)y=h-1;\n\t\t\t\t\t\t\tif(x<0)x=w-1;\n\t\t\t\t\t\t\tif(y>=h)y=0;\n\t\t\t\t\t\t\tif(x>=w)x=0;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(s.size()>1){\n\t\t\t\t\t\t\tif(!EXIST(m,s)){\n\t\t\t\t\t\t\t\tm[s]=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tm[s]++;\n\t\t\t\t\t\t\tif(m[s]>1&&(s.size()>ans.size()||(s.size()==ans.size()&&s<ans))){\n\t\t\t\t\t\t\t\tans=s;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout<<(ans==\"\"?\"0\":ans)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\n\nint dx[] = {-1,0,1,1,1,0,-1,-1};\nint dy[] = {1,1,1,0,-1,-1,-1,0};\n\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\nint H,W;\nstring donut[11];\nmap<string, int> res;\n\nvoid dfs(string str,int sy,int sx, int y,int x,int a) {\n    int ny = (y+dy[a]+H) % H;\n    int nx = (x+dx[a]+W) % W;\n    if(sy==ny && sx==nx) return;\n\n    res[str]++;\n    dfs(str+donut[ny][nx],sy,sx,ny,nx,a);\n}\n\nstring cmp(string s1,string s2) {\n    if(s1.size() > s2.size()) return  s1;\n    else if(s1.size() < s2.size()) return s2;\n    else return s1 < s2 ? s1 : s2;\n}\n\nvoid solve() {\n    res.clear();\n    rep(i,11) donut[i]=\"\";\n    rep(i,H) cin>>donut[i];\n    rep(y,H) rep(x,W) {\n        rep(a,8) {\n            string tmp;\n            tmp = donut[y][x];\n            dfs(tmp,y,x,y,x,a);\n        }\n    }\n    string ans;\n    for(const auto &it : res){\n        if(it.sc >= 2) {\n            ans = cmp(ans,it.fr);\n        }\n    }\n    if(ans.size() <= 2) ans = \"0\";\n    cout<<ans<<endl;\n}\n\nint main() {\n    while(cin>>H>>W) {\n        if(H+W==0) break;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nint div_row[8] = {-1,-1,-1,0,0,1,1,1},div_col[8] = {-1,0,1,-1,1,-1,0,1},H,W;\n\nstruct Info{\n\tvoid init(){\n\t\tlength = count = 0;\n\t}\n\tchar spell[201];\n\tint length,count;\n};\n\n//base??¨comp??????????????????????????¢??°\nbool strCmp(char* base, char* comp){\n\tint length1 = 0,length2 = 0;\n\tfor(int i=0;base[i] != '\\0'; i++)length1++;\n\tfor(int i=0;comp[i] != '\\0'; i++)length2++;\n\tif(length1 != length2)return false;\n\n\tfor(int i=0;base[i] != '\\0'; i++){\n\t\tif(base[i] != comp[i])return false;\n\t}\n\treturn true;\n}\n\nvoid strcpy(char* to,char* str){\n\tfor(int i=0;str[i] != '\\0';i++){\n\t\tto[i] = str[i];\n\t\tto[i+1] = '\\0';\n\t}\n}\n\n//???????????????????????????3,left?????????????????´??????1,right?????????????????¨??????2\nint strCmp2(char* left,char* right){\n\tint i;\n\n\tif(strCmp(left,right))return 3;\n\n\tfor(i=0;left[i] != '\\0' && right[i] != '\\0'; i++){\n\t\tif(left[i] != right[i]){\n\t\t\tif(left[i] < right[i])return 1;\n\t\t\telse{\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t}\n\t}\n\tif(left[i] == '\\0')return 1;\n\telse{\n\t\treturn 2;\n\t}\n}\n\nint main(){\n\n\tint work_row,work_col,work_index,ans,info_index = 0,inner_work_index,tmp,max_length;\n\tchar table[10][21],work[201],inner_work[201];\n\tbool FLG;\n\n\tInfo* info = (Info*)malloc(sizeof(Info)*(39800));\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&H,&W);\n\t\tif(H == 0 && W == 0)break;\n\n\t\tfor(int i = 0; i < info_index; i++)info[i].init();\n\n\t\tans = -1; //?§£?????????????????????\n\t\tinfo_index = 0; //info?????????????????????\n\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tscanf(\"%s\",table[i]);\n\t\t}\n\n\t\tfor(int row = 0; row < H; row++){ //???????????????\n\t\t\tfor(int col = 0; col < W; col++){ //???????????????\n\t\t\t\tfor(int a = 0; a < 8; a++){ //8??????????????????\n\t\t\t\t\twork_index = 0;\n\t\t\t\t\twork[work_index++] = table[row][col];\n\n\t\t\t\t\twork_row = (row + div_row[a]+H)%H;\n\t\t\t\t\twork_col = (col + div_col[a]+W)%W;\n\n\t\t\t\t\twhile(work_row != row || work_col != col){ //???????????????????????§????§????????¶???????\n\t\t\t\t\t\twork[work_index++] = table[work_row][work_col];\n\t\t\t\t\t\t//printf(\"work_row:%d work_col:%d\\n\",work_row,work_col);\n\t\t\t\t\t\twork_row = (work_row + div_row[a]+H)%H;\n\t\t\t\t\t\twork_col = (work_col + div_col[a]+W)%W;\n\t\t\t\t\t}\n\n\t\t\t\t\t//return 0;\n\n\t\t\t\t\t//?????????????????£??????????????§?????§????????????????????¨??????????????????????????????\n\t\t\t\t\tfor(int right = 1; right <= work_index-1;right++){\n\t\t\t\t\t\tinner_work_index = 0;\n\t\t\t\t\t\tfor(int b = 0; b <= right; b++){\n\t\t\t\t\t\t\tinner_work[inner_work_index++] = work[b];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tinner_work[inner_work_index] = '\\0';\n\n\t\t\t\t\t\t//??¢?????????????????????????????????????????????\n\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\tfor(int b = 0; b < info_index; b++){\n\t\t\t\t\t\t\tif(strCmp(inner_work,info[b].spell)){\n\t\t\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\t\t\ttmp = b;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(FLG){ //??¢??????????????????????????´???\n\t\t\t\t\t\t\tinfo[tmp].count++;\n\t\t\t\t\t\t}else{ //??????????????????????????£?????´???\n\t\t\t\t\t\t\tstrcpy(info[info_index].spell,inner_work);\n\t\t\t\t\t\t\tinfo[info_index].length = right+1;\n\t\t\t\t\t\t\tinfo[info_index].count = 1;\n\t\t\t\t\t\t\tinfo_index++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmax_length = 2;\n\n\t\t//??????????????????????????°???\n\t\tfor(int i = 0; i < info_index; i++){\n\n\t\t\tif(info[i].count >= 2 && info[i].length >= max_length){\n\t\t\t\tif(ans == -1){ //?????????????§£????£?\n\t\t\t\t\tmax_length = info[i].length;\n\t\t\t\t\tans = i;\n\t\t\t\t}else{\n\t\t\t\t\tif(info[i].length > max_length){ //???????????§???\n\t\t\t\t\t\tmax_length = info[i].length;\n\t\t\t\t\t\tans = i;\n\t\t\t\t\t}else{ //info[i].length == max_length\n\t\t\t\t\t\tif(strCmp2(info[i].spell,info[ans].spell) == 1){ //?????¨????§£????????????????????§??????\n\t\t\t\t\t\t\tans = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(ans == -1){\n\t\t\tprintf(\"0\\n\");\n\t\t}else{\n\t\t\tprintf(\"%s\\n\",info[ans].spell);\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <map>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\ntypedef long long ll;\n\nint main() {\n\tint h, w;\n\twhile(cin >> h >> w, h || w) {\n\t\tvector<string> in(h);\n\t\trep(y,h) {\n\t\t\tcin >> in[y];\n\t\t}\n\t\tint dx[3] = {w-1, 0, 1};\n\t\tint dy[3] = {h-1, 0, 1};\n\t\tmap<string, int> mp;\n\t\trep(sy, h) {\n\t\t\trep(sx, w) {\n\t\t\t\trep(iy, 3) {\n\t\t\t\t\trep(ix, 3) {\n\t\t\t\t\t\tif(ix==1 && iy==1) continue;\n\t\t\t\t\t\tint nx=sx, ny=sy;\n\t\t\t\t\t\tstring str = \"\";\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tstr += in[ny][nx];\n\t\t\t\t\t\t\tnx = (nx + dx[ix]) % w;\n\t\t\t\t\t\t\tny = (ny + dy[iy]) % h;\n\t\t\t\t\t\t\tmp[str]++;\n\t\t\t\t\t\t} while(nx!=sx || ny!=sy);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint mx = 0;\n\t\tstring res = \"\";\n\t\tfor(map<string, int>::iterator it=mp.begin(); it!=mp.end(); it++) {\n\t\t\tif( it->second == 1 ) continue;\n\t\t\tif(res.length() < it->first.length() || (res.length()==it->first.length() && it->first < res)) {\n\t\t\t\tmx = it->second;\n\t\t\t\tres = it->first;\n\t\t\t}\n\t\t}\n\t\tif(res.length() < 2) {\n\t\t\tres = \"0\";\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint w,h,x,y;\nint sx,sy,gx,gy;\nint dx[9] = { 1, 1, 1, 0, 0, 0,-1,-1,-1};\nint dy[9] = {-1, 0, 1,-1, 0, 1,-1, 0, 1};\n\nbool can(int y,int x) {\n\tif(0 <= y && y < h && 0 <= x && x < w) return true;\n\treturn false;\n}\n\nint main() {\n\twhile(cin >> h >> w) {\n\t\tif(h == 0 && w == 0) break;\n\n\t\tvector<string> s(h);\n\t\trep(i, h) cin >> s[i];\n\n\t\tmap<string, int> m;\n\t\tbool used[15][25];\n\n\t\trep(i, h) {\n\t\t\trep(j, w) {\n\t\t\t\trep(k, 9) {\n\t\t\t\t\tint y = i, x = j;\n\t\t\t\t\tmemset(used, 0, sizeof(used));\n\t\t\t\t\tstring t = \"\";\n\t\t\t\t\twhile(!used[y][x]) {\n\t\t\t\t\t\tused[y][x] = true;\n\t\t\t\t\t\tt += s[y][x];\n\n\t\t\t\t\t\ty = (y + h + dy[k]) % h;\n\t\t\t\t\t\tx = (x + w + dx[k]) % w;\n\n\t\t\t\t\t\tif(t.size() > 1) m[t]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstring ans = \"\";\n\t\tmap<string, int>::iterator ite;\n\t\tfor(ite = m.begin(); ite != m.end(); ite++) {\n\t\t\tif(ite->second < 2) continue;\n\t\t\tif(ite->first.size() > ans.size()) {\n\t\t\t\tans = ite->first;\n\t\t\t} else if(ite->first.size() == ans.size()) {\n\t\t\t\tbool flag = true;\n\t\t\t\trep(i, ans.size()) {\n\t\t\t\t\tif(ite->first[i] <= ans[i]) continue;\n\t\t\t\t\tflag = false;\n\t\t\t\t}\n\n\t\t\t\tif(flag) ans = ite->first;\n\t\t\t}\n\t\t}\n\n\t\tif(ans.size() == 0) cout << 0 << endl;\n\t\telse cout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) REP(i, 0, n)\n#define REP(i, s, e) for(int i = (int)(s); i< (int)(e); ++i)\n\nint dx[] = {0, 0, -1,-1, -1, 1, 1, 1};\nint dy[] = {-1, 1, 0, 1, -1, 0, 1,-1};\n\nmap<string, int> mp;\nvector<string> input;\nint H, W;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nvoid f(int x, int y, set<pii>& st, string& s, const int dir) {\n  //  cout << x << \" \" << y << \" \" << dir <<\" \" << s << endl;\n  //  cout <<mp.size() << endl;\n  //  cout <<s.size() << \" \" << st.size() << \" \" << mp.size() << endl;\n  s += input[y][x];\n  if(s.size() >= 2)   mp[s]++;\n  pii p;\n  p = make_pair(y, x);\n  st.insert(p);\n  (x += dx[dir] + W) %= W;\n  (y += dy[dir] + H) %= H;\n  assert(x >= 0 && x < W);\n  assert(y >= 0 && y < H);\n  p = make_pair(y, x);\n  if(st.count(p)) {\n    //    mp[s]++;\n    return;\n  }\n  f(x, y, st, s, dir);\n}\n\nint main() {\n  while(cin >> H >> W) {\n    if(H == 0 && W == 0) break;\n    mp.clear();\n    input.resize(H);\n    rep(i, H) cin >> input[i];\n    rep(i, H) rep(j, W) {\n      //mp[input[i].substr(j, 1)]++;\n      rep(k, 8) {\n\tset<pii> st;\n\tstring s;\n\tf(j, i, st, s, k);\n      }\n    }\n    string s;\n    for(map<string, int>::iterator it = mp.begin(); it != mp.end(); ++it) {\n      if(it->second == 1) continue;\n      if(s.size() < it->first.size()) s = it->first;\n      else {\n\tif(s.size() == it->first.size() && s > it->first) s = it->first;\n      }\n    }\n    if(s.size() == 0) cout << 0 << endl;\n    else cout << s << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <set>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint h, w;\nconst int dx[8] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int dy[8] = {1, 1, 0, -1, -1, -1, 0, 1};\nvector<string> donut;\nbool visited[10][20];\n\ninline unsigned long long hash(const string& s) {\n\tconst unsigned long long base = 1000000007;\n\tlong long res = 0;\n\tfor(int i = 0; i < s.size(); ++i) {\n\t\tres *= base;\n\t\tres += s[i];\n\t}\n\n\treturn res;\n}\n\ninline string spell(int x, int y, int d) {\n\tif(visited[y][x])\n\t\treturn \"\";\n\n\tvisited[y][x] = true;\n\tstring res = donut[y][x] + spell((x + dx[d] + w) % w, (y + dy[d] + h) % h, d);\n\tvisited[y][x] = false;\n\treturn res;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tconst string init(2, 'z' + 1);\n\n\twhile(cin >> h >> w, h) {\n\t\tdonut.clear();\n\t\tdonut.resize(h);\n\t\tfor(int i = 0; i < h; ++i)\n\t\t\tcin >> donut[i];\n\n\t\tstring ans = init;\n\t\tset<unsigned long long> s;\n\t\tfor(int i = 0; i < h; ++i) {\n\t\t\tfor(int j = 0; j < w; ++j) {\n\t\t\t\tfor(int d = 0; d < 8; ++d) {\n\t\t\t\t\tconst string str = spell(j, i, d);\n\t\t\t\t\tfor(int i = ans.size(); i <= str.size(); ++i) {\n\t\t\t\t\t\tconst string tmp = str.substr(0, i);\n\t\t\t\t\t\tconst unsigned long long h = hash(tmp);\n\t\t\t\t\t\tif(s.find(h) == s.end())\n\t\t\t\t\t\t\ts.insert(h);\n\n\t\t\t\t\t\telse if(ans.size() < tmp.size() || (ans.size() == tmp.size() && tmp < ans))\n\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << (ans != init ? ans : \"0\") << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\n#define each(i,a) for (auto&& i : a)\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    each(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n    rep(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector< vector<T> >& vec) {\n    rep(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\n\nll dx[8] = {0, 1, 1, 1, 0, -1, -1, -1};\nll dy[8] = {-1, -1, 0, 1, 1, 1, 0, -1};\nll normalize(ll n, ll L) {\n    return (n % L + L) % L;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll h, w;\n    while (cin >> h >> w, h || w) {\n        vector<string> A(h); cin >> A;\n        ll l = 0, r = w*h+1;\n        auto f = [&](ll len) {\n            string res = \"0\";\n            if (len <= 1) return res;\n            set<string> X;\n            rep(y0, h) rep(x0, w) rep(d, 8) {\n                vector<vector<bool>> used(h, vector<bool>(w, false));\n                stack<P> S; S.push({x0, y0});\n                string s = \"\";\n                while ( !S.empty() ) {\n                    P p = S.top(); S.pop();\n                    ll x, y; tie(x, y) = p;\n                    if (used[y][x]) break;\n                    used[y][x] = true;\n                    s += A[y][x];\n                    if (s.size() == len) break;\n                    S.push({normalize(x+dx[d], w), normalize(y+dy[d], h)});\n                }\n                if (s.size() != len) continue;\n                if (X.count(s) > 0) {\n                    if (res == \"0\" || s < res) res = s;\n                }\n                else {\n                    X.insert(s);\n                }\n            }\n            return res;\n        };\n        rep(t, 20) {\n            ll m = (l + r) / 2;\n            if (f(m) == \"0\") r = m;\n            else l = m;\n        }\n        cout << f(l) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint lcm(int a,int b){\t//a,b < 20だしいいよね\n\t\tif (a < b){\n\t\t\tswap(a,b);\n\t\t}\n\t\tint times = a * b;\n\t\tvector<int> num;\n\t\tint gcd,lcm;\n\t\twhile(1){\n\t\t\tint n;\n\t\t\tn = a % b;\n\t\t\tif(n == 0){\tbreak;}\n\t\t\ta = b;\n\t\t\tb = n;\n\t\t}\n\t\tgcd = b;\n\t\tlcm = times / gcd;\n\treturn lcm;\n}\n\nint main(){\n\tint h,w;\n\twhile(1){\n\t\tcin >> h >> w ;\n\t\tif(h == 0 && w == 0){\tbreak;}\n\t\tchar donut[10][20];\n\t\tfor(int i=0;i<10;i++){\n\t\t\tfor(int j=0;j<20;j++){\n\t\t\t\tdonut[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tstring code[1600];\n\t\tbool much[1600];\n\t\tfor(int i = 0; i < 1600; i++){\n\t\t\tcode[i] = \"\";\n\t\t\tmuch[i] = true;\n\t\t}\t//初期化…\n\n\t\tint l = lcm(w,h);\t//ななめの最大数\n\t\tint a = 0;\t//strの数を数えます\n\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j =0; j < w; j++){\n\t\t\t\tcin >> donut[i][j];\n\t\t\t}\n\t\t}\t//input\n\n\t\tfor(int y = 0; y < h; y++){\n\t\t\tfor(int x = 0; x < w; x++){\n\t\t\t\tfor(int i = 0; i < h; i++){\t//縦列\n\t\t\t\t\tcode[a].append(1,donut[(y + i)%h][x]);\n\t\t\t\t\tcode[a+1].append(1,donut[h-(y + i)%h-1][x]);\n\t\t\t\t}\n\t\t\t\ta += 2;\n\t\t\t\tfor(int j = 0; j < w; j++){\t//横列\n\t\t\t\t\tcode[a].append(1,donut[y][(x + j)%w]);\n\t\t\t\t\tcode[a+1].append(1,donut[y][w-(x+j)%w-1]);//absつけなくても0になりません！\n\t\t\t\t}\n\t\t\t\ta += 2;\n\t\t\t\tfor(int k = 0; k < l; k++){\t//ななめ\n\t\t\t\t\tcode[a].append(1,donut[(y + k)%h][(x + k)%w]);\n\t\t\t\t\tcode[a+1].append(1,donut[(y + k)%h][(l + x - k)%w]);\n\t\t\t\t\tcode[a+2].append(1,donut[(l + y - k)%h][(x + k)%w]);\n\t\t\t\t\tcode[a+3].append(1,donut[(l + y - k)%h][(l + x - k)%w]);\n\t\t\t\t}\n\t\t\t\ta += 4;\n\t\t\t}\n\t\t}\n\t\tstring mag = \"\";\n\t\t//a:strの数-1\n\n\t\tsort(code,code+a);//nとn+1を比べます\n\n\t\tfor(int i = 0; i < a-1; i++){\n\t\t\tif(code[i][0] != code[i+1][0]){\n\t\t\t\tmuch[i+1] = false;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 1; i < l; i++){\t//2文字目から\n\t\t\tfor(int j = a-1; j > 0; j--){\t//逆順\n\t\t\t\tif(much[j] == true && code[j].length() >= i+1 && code[j-1].length() >= i+1){//=を忘れていました\n\t\t\t\t\t//jのi+1文字目とj-1のi+1文字目を比べるよ\n\t\t\t\t\tif(code[j][i] != code[j-1][i]){\n\t\t\t\t\t\tmuch[j] = false;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tmag = code[j];\n\t\t\t\t\t\tmag.resize(i+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(mag == \"\"){\n\t\t\tcout << \"0\" << endl;\n\t\t}else{\n\t\t\tcout << mag << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <set>\n#include <vector>\nusing namespace std;\n#define REP(i,x)for(int i=0;i<x;i++)\n\nstring res;\nint H,W,dx,dy,min_len;\nchar s[200];\nstring MAP[11];\nbool visit[20][20];\nvector<string> ss;\nvoid dfs(int x,int y,int k){\n  if(visit[y][x]){\n    ss.push_back(string(s));\n    return;\n  }\n  s[k]=MAP[y][x];  visit[y][x]=1;\n  dfs((x + dx + W) % W, (y + dy + H) % H, k + 1);\n  s[k]=0;  visit[y][x]=0;\n}\nint main() {\n  while(cin>>H>>W,H){\n    REP(i,H)cin>>MAP[i];\n    ss.clear();\n    min_len=1; res=\"0\";\n    REP(y,H)REP(x,W){\n      for(dx=-1;dx<=1;dx++){\n        for(dy=-1;dy<=1;dy++){\n          if(dx|dy)dfs(x,y,0);\n        }\n      }\n    }\n    string res = \"0\";\n    sort(ss.begin(),ss.end());\n    REP(i,ss.size()-1){\n      int len = 0;\n      REP(k,min(ss[i].size(),ss[i+1].size())){\n        if(ss[i][k]==ss[i+1][k])len++;\n        else break;\n      }\n      if(len < res.size())continue;\n      if(res.size() == len){\n        res = min(res, ss[i].substr(0,len));\n      }else{\n        res = ss[i].substr(0, len);\n      }\n    }\n    cout<<res<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstring>\n#include <cstdio>\n#include <algorithm>\n#include <complex>\n#include <set>\n#include <map>\n#include <cmath>\nusing namespace std;\n\n\nint dx[] = {-1,-1,-1,0,0,1,1,1};\nint dy[] = {-1,0,1,-1,1,-1,0,1};\n\nint main(){\n\tint H,W;\n\twhile(cin >> H >> W && H ){\n\t\tvector<string> s(H);\n\t\tfor(int i = 0 ; i < H ; i++) cin >> s[i];\n\t\t\n\t\t\n\t\tmap<string,int> answer;\n\t\tfor(int i = 0 ; i < H ; i++){\n\t\t\tfor(int j = 0 ; j < W ; j++){\n\t\t\t\tfor(int d = 0 ; d < 8 ; d++){\n\t\t\t\t\tstring wow;\n\t\t\t\t\tint done[20][20] = {};\n\t\t\t\t\tint x = j , y = i;\n\t\t\t\t\twhile( done[y][x] == 0 ){\n\t\t\t\t\t\twow += s[y][x];\n\t\t\t\t\t\tdone[y][x] = true;\n\t\t\t\t\t\tanswer[wow]++;\n\t\t\t\t\t\tx += dx[d];\n\t\t\t\t\t\ty += dy[d];\n\t\t\t\t\t\tx += W;\n\t\t\t\t\t\ty += H;\n\t\t\t\t\t\tx %= W;\n\t\t\t\t\t\ty %= H;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint len = 0;\n\t\tfor( map<string,int>::iterator it = answer.begin(); it != answer.end() ; it++){\n\t\t\tif( it->second < 2 || it->first.size() < 2 ) continue;\n\t\t\tlen = max( len , (int)it->first.size() );\n\t\t}\n\t\tint flag = 0;\n\t\tfor( map<string,int>::iterator it = answer.begin(); it != answer.end() ; it++){\n\t\t\tif( it->second < 2 || it->first.size() < 2 ) continue;\n\t\t\tif( len == it->first.size() ){\n\t\t\t\tcout << it->first << endl;\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(flag==0)cout << 0 << endl;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <set>\n\nusing namespace std;\n\nconst int dx[] = { -1, 0, 1, 1, 1, 0, -1, -1 };\nconst int dy[] = { -1, -1, -1, 0, 1, 1, 1, 0 };\n\nint main(){\n\twhile(true){\n\t\tint w, h;\n\t\tcin >> h >> w;\n\t\tif(h == 0 && w == 0){ break; }\n\t\tvector<string> v(h);\n\t\tfor(int i = 0; i < h; ++i){ cin >> v[i]; }\n\t\tset<string> found;\n\t\tstring answer;\n\t\tfor(int i = 0; i < h; ++i){\n\t\t\tfor(int j = 0; j < w; ++j){\n\t\t\t\tfor(int d = 0; d < 8; ++d){\n\t\t\t\t\tint y = i, x = j;\n\t\t\t\t\tstring s;\n\t\t\t\t\tdo {\n\t\t\t\t\t\ts += v[y][x];\n\t\t\t\t\t\tif(found.find(s) == found.end()){\n\t\t\t\t\t\t\tfound.insert(s);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif(answer.size() < s.size()){\n\t\t\t\t\t\t\t\tanswer = s;\n\t\t\t\t\t\t\t}else if(answer.size() == s.size() && s < answer){\n\t\t\t\t\t\t\t\tanswer = s;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\ty = (y + dy[d] + h) % h;\n\t\t\t\t\t\tx = (x + dx[d] + w) % w;\n\t\t\t\t\t} while(y != i || x != j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << answer << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\nint dx[] = {-1, 0, 1, 0, -1, -1, 1, 1};\nint dy[] = {0, -1, 0, 1, -1, 1, -1, 1};\n\nbool comp(const string& a, const string& b)\n{\n\tif(a.size() != b.size()) return a.size() > b.size();\n\treturn a < b;\n}\n\nint main()\n{\n\tint W, H;\n\twhile(cin >> H >> W, (W||H)) {\n\t\tstring field[10];\n\t\tfor(int i=0; i<H; i++)\n\t\t\tcin >> field[i];\n\n\t\tstring res;\n\t\tmap<string, int> spells;\n\t\tfor(int i=0; i<W; i++)\n\t\tfor(int j=0; j<H; j++)\n\t\tfor(int k=0; k<8; k++)\n\t\t{\n\t\t\tstring s;\n\t\t\tint x = i, y = j;\n\t\t\tbool visit[10][20] = {0};\n\t\t\twhile(1)\n\t\t\t{\n\t\t\t\tif(visit[y][x]) break;\n\t\t\t\tvisit[y][x] = true;\n\t\t\t\t\n\t\t\t\ts += field[y][x];\n\n\t\t\t\ty = (y+dy[k]+H)%H;\n\t\t\t\tx = (x+dx[k]+W)%W;\n\t\t\t\t\n\t\t\t\tspells[s]++;\n\t\t\t\tif(spells[s] >=2 && comp(s,res)) res = s;\n\t\t\t}\n\n\t\t}\n\n\t\tif(res.size() <= 1) res = \"0\";\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(int h,int w){\n    vector<string> vs(h);\n    rep(i,0,h) cin >> vs[i];\n    int dx[]={1,1,0,-1,-1,-1,0,1},dy[]={0,-1,-1,-1,0,1,1,1};\n    set<string> st;\n    vector<vector<bool>> used(h,vector<bool>(w));\n    string s,ans;\n    function<void(int,int,int)> dfs=[&](int y,int x,int i){\n        if(st.find(s)!=st.end() and s.size()>=ans.size() and (s.size()>ans.size() or s<ans)) ans=s;\n        st.insert(s);\n        //rep(i,0,8){\n        int ny=y+dy[i],nx=x+dx[i];\n        if(ny==h) ny=0;\n        if(ny<0) ny=h-1;\n        if(nx==w) nx=0;\n        if(nx<0) nx=w-1;\n        if(used[ny][nx]) return;\n        s.push_back(vs[ny][nx]);\n        used[ny][nx]=true;\n        dfs(ny,nx,i);\n        s.pop_back();\n        used[ny][nx]=false;\n        //}\n        return;\n    };\n    rep(y,0,h) rep(x,0,w) rep(i,0,8){\n            s.push_back(vs[y][x]);\n            used[y][x]=true;\n            dfs(y,x,i);\n            s.pop_back();\n            used[y][x]=false;\n    }\n\n    if(ans.size()<2) cout << 0 << endl;\n    else cout << ans << endl;\n}\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    for(;;){\n        int h,w;\n        cin >> h >> w;\n        if(!h and !w) break;\n        solve(h,w);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint h, w;\nstring spell[10];\n\nint dx[] = {-1, 0, 1, 0, 1, -1, 1, -1};\nint dy[] = {0, -1, 0, 1, -1, 1, 1, -1};\n\nset<string> spellset;\n\nstring ans;\n\nvoid cast(int sy, int sx, int y, int x, int d, string word)\n{\n  if(spellset.count(word)){\n    if(ans.size() < word.size() || ans.size() == word.size() && ans > word){\n      ans = word;\n    }\n  } else {\n    spellset.insert(word);\n  }\n  if(sy == y && sx == x) return;\n  int ny = (y + dy[d] + h) % h, nx = (x + dx[d] + w) % w;\n  cast(sy, sx, ny, nx, d, word + spell[y][x]);\n  return;\n}\n\nint main()\n{\n  while(cin >> h >> w, h || w){\n    spellset.clear();\n    for(int i = 0; i < h; i++) cin >> spell[i];\n    ans = \"\";\n    for(int i = 0; i < h; i++){\n      for(int j = 0; j < w; j++){\n\tstring word = \"\";\n\tfor(int k = 0; k < 8; k++){\n\t  int ny = (i + dy[k] + h) % h, nx = (j + dx[k] + w) % w;\n\t  cast(i, j, ny, nx, k, word + spell[i][j]);\n\t}\n      }\n    }\n    cout << (ans.size() > 1 ? ans:\"0\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <set>\n#define REP(i,a,b) for (int i = (a); i < (b); i++)\n#define rep(i,a) REP(i,0,a)\nusing namespace std;\n\nint H, W;\nint dw[] = {1,1,0,-1,-1,-1,0,1};\nint dh[] = {0,1,1,1,0,-1,-1,-1};\n\nint main(void){\n    while (cin >> H >> W && H) {\n        vector<string> S(H,\"\");\n        rep(i, H) cin >> S[i];\n        string ans = \"\";\n        set<string> appear;\n        \n        rep(h, H) rep(w, W) rep(i, 8) {\n            string s = \"\";\n            s += S[h][w];\n            int iw = w, ih = h;\n            w = (w+dw[i]+W)%W; h = (h+dh[i]+H)%H;\n            while (!(w == iw && h == ih)) {\n                s.append(1, S[h][w]);\n                if (s.length() >= ans.length() && appear.find(s) != appear.end()) {\n                    if (s.length()  > ans.length()) ans = s;\n                    if (s.length() == ans.length()) ans = min(ans, s);\n                }\n                appear.insert(s);\n                w = (w+dw[i]+W)%W; h = (h+dh[i]+H)%H;\n            }\n        }\n        cout << (ans.length() > 1 ? ans:\"0\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<map>\n#define f first\n#define s second\nusing namespace std;\n\nint h,w,ii,jj;\nint X[8]={-1,1,-1,1,0,-1,0,1};\nint Y[8]={-1,1,1,-1,1,0,-1,0};\nchar Donut[10][20];\nvector<string> V;\nstring maxs;\nmap<string,pair<int,int> > M;\n\nvoid Check(string s)\n{\n  if(maxs.length()<s.length())maxs=s;\n  else if(maxs.length()==s.length()){\n    if(maxs>s)maxs=s;\n  }\n}\n\nvoid make(int x,int y)\n{\n  for(int k=0;k<8;k++){\n    string S=\"\";\n    int a=x,b=y;\n    S+=Donut[a][b];\n    while(1){\n      a+=Y[k];\n      b+=X[k];\n      if(a==-1)a=h-1;\n      if(b==-1)b=w-1;\n      if(a==h)a=0;\n      if(b==w)b=0;\n      if(a==x && b==y)break;\n      S+=Donut[a][b];\n      if(M[S].f==0 && M[S].s==0){\n\tM[S].f=x+1;\n\tM[S].s=y+1;\n      }\n      else {\n\tCheck(S);\n      }\n    }\n  }\n}\n\nint main()\n{\n  while(1){\n    cin>>h>>w;\n    if(h+w==0)break;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++)cin>>Donut[i][j];\n    }\n    M.clear();\n    maxs=\"\";\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tmake(i,j);\n      }\n    }\n    if(maxs==\"\")cout<<0<<endl;\n    else cout<<maxs<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <map>\n#include <algorithm>\n#include <stack>\n\nusing namespace std;\n\nint h, w;\nstring board[20];\n\nconst int dx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int dy[] = {-1, -1, 0, 1, 1, 1, 0, -1};\n\nvoid Solve()\n{\n    map<string, int> memo;\n    string res;\n\n    for (int i = 0; i < h; ++i) {\n        for (int j = 0; j < w; ++j) {\n            for (int d = 0; d < 8; ++d) {\n                string s;\n                int nx = j, ny = i;\n\n                do {\n\n                    s += board[ny][nx];\n                    ++memo[s];\n\n                    nx = (nx + dx[d] + w) % w;\n                    ny = (ny + dy[d] + h) % h;\n\n                    if (memo[s] >= 2) {\n                        if (s.size() > res.size() ||\n                            (s.size() == res.size() && (s < res)))\n                            res = s;\n                    }\n\n                } while (nx != j || ny != i);\n\n            }\n        }\n    }\n\n    if (res.size() <= 1)\n        cout << \"0\\n\";\n    else\n        cout << res << endl;\n}\n\nint main()\n{\n    while (cin >> h >> w, h || w) {\n\n        for (int i = 0; i < h; ++i)\n            cin >> board[i];\n\n        Solve();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <regex>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef complex<double> Point;\ntypedef long long ll;\nconst int INF = 1145141919;\nconst int MOD = 100000007;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nstruct edge\n{\n\tint from, to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nint dx[] = { -1, -1, -1, 0, 0, 1, 1, 1 };\nint dy[] = { -1, 0, 1, -1, 1, -1, 0, 1 };\n\nint w, h;\nvector<string> s;\n\nint main()\n{\n\twhile (cin >> h >> w, w)\n\t{\n\t\ts.resize(h);\n\t\tREP(i, h) cin >> s[i];\n\t\tmap<string,int> used;\n\t\tREP(i, h)\n\t\t{\n\t\t\tREP(j, w)\n\t\t\t{\n\t\t\t\tREP(k, 8)\n\t\t\t\t{\n\t\t\t\t\tstring t; t+=s[i][j];\n\t\t\t\t\tint nx = i; int ny = j;\n\t\t\t\t\twhile (1)\n\t\t\t\t\t{\n\t\t\t\t\t\tnx += dx[k]; ny += dy[k];\n\t\t\t\t\t\tif (nx == h) nx = 0;\n\t\t\t\t\t\telse if (nx < 0) nx = h - 1;\n\t\t\t\t\t\tif (ny == w) ny = 0;\n\t\t\t\t\t\telse if (ny < 0) ny = w - 1;\n\t\t\t\t\t\tif (nx == i&&ny == j)  break;\n\t\t\t\t\t\tt += s[nx][ny];\n\t\t\t\t\t\tused[t]++;\n\t\t\t\t\t} \n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstring ans = \"0\";\n\t\tfor (auto ite = used.begin(); ite != used.end(); ite++)\n\t\t{\n\t\t\tif ((*ite).second >= 2)\n\t\t\t{\n\t\t\t\tauto tmp = (*ite).first;\n\t\t\t\tif (ans.size() < tmp.size()) ans = tmp;\n\t\t\t\telse if (ans.size() == tmp.size()) ans = min(ans, tmp);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * GCA : \"Computer is artificial subject absolutely,Math is God\"\n */\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <cctype>\n#include <utility>\n#include <ctime>\nusing namespace std;\n#ifdef DEBUG\n#define VAR(a,b) __typeof(b) a=(b)\n#define debug(...) printf(\"DEBUG: \"),printf(__VA_ARGS__)\n#else\n#define VAR(a,b) __typeof(b) a=(b)\n#define debug(...)\n#endif\ntypedef unsigned int uint;\ntypedef long long int Int;\ntypedef unsigned long long int UInt;\n#define Set(a,s) memset(a,s,sizeof(a))\n#define Pln() printf(\"\\n\")\n#define For(i,x)for(int i=0;i<x;i++)\n#define CON(x,y) x##y\n#define M 25\n#define PB push_back\n#define oo INT_MAX\n#define FOR(a,b) for(VAR(a,(b).begin());a!=(b).end();++a)\n#define eps 1e-9\n#define X first\n#define Y second\ninline bool xdy(double x,double y){return x>y+eps;}\ninline bool xddy(double x,double y){return x>y-eps;}\ninline bool xcy(double x,double y){return x<y-eps;}\ninline bool xcdy(double x,double y){return x<y+eps;}\nconst Int mod=1000000007;\nint nx,ny;\nchar mz[M][M];\nset<Int> sid;\nint dx[8]={0,1,1,1,0,-1,-1,-1};\nint dy[8]={1,1,0,-1,-1,-1,0,1};\nchar store[M*M];\nInt ist=0;\nint ox,oy;\nstring ans;\n//string has[M][M][9];\n//bool vis[M][M][9];\nbool vis[M][M];\nvoid dfs(int x,int y,int d,int dep){\n\n\tstore[dep]=mz[y][x];\n\tist=ist*134+mz[y][x];\n\tint nex=(x+dx[d]+nx)%nx;\n\tint ney=(y+dy[d]+ny)%ny;\n\tstore[dep+1]=0;\n\tstring ss(store);\n//\t\tputs(store);\n\tif(sid.count(ist)){\n\t\tif(ss.length()>ans.length()){\n\t\t\tans=ss;\n\t\t}else if(ss.length()==ans.length()&&ss<ans){\n\t\t\tans=ss;\n\t\t}\n\t}\n\tsid.insert(ist);\n\tif(vis[nex][ney]){\n\t\treturn;\n\t}\n\tvis[nex][ney]=1;\n\tdfs(nex,ney,d,dep+1);\n\tvis[nex][ney]=0;\n\n}\nvoid solve(){\n\tfor(int i=0;i<ny;i++){\n\t\tfor(int j=0;j<nx;j++){\n\t\t\tfor(int k=0;k<8;k++){\n\t\t\t\tist=0;\n\t\t\t\tvis[j][i]=1;\n\t\t\t\tSet(store,0);\n\t\t\t\tdfs(j,i,k,0);\n\t\t\t\tvis[j][i]=0;\n\t\t\t}\n\t\t}\n\t}\n//\tfor(int i=0;i<8;i++){\n//\t\tox=1;oy=1;\n//\t\tdfs(1,1,i,0);\n//\t}\n\tif(ans.length()>=2)\n\t\tprintf(\"%s\\n\",ans.c_str());\n\telse puts(\"0\");\n}\nint main() {\n\tios_base::sync_with_stdio(0);\n\twhile(~scanf(\"%d%d\",&ny,&nx)&&nx&&ny){\n\t\tsid.clear();\n\t\tans=\"\";\n\t\tSet(vis,0);\n\t\tfor(int i=0;i<ny;i++)scanf(\"%s\",mz[i]);\n\t\tsolve();\n\n\t}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\n#define rep(i, n) for(int i=0; i<(n); ++i)\n#define mp(a, b) make_pair(a, b)\n\ntemplate<typename T, typename Compare = greater<T> >\ninline void chmax(T& t, T f, Compare comp){if(!comp(t, f))t = f;}\n\nint h, w;\n\nstring solve(vector<string>& patterns){\n    string res = \"0\";\n    set<string> spells;\n    rep(x, h)rep(y, w){\n        for(int dx=-1; dx<=1; ++dx){\n            for(int dy=-1; dy<=1; ++dy){\n                string spell = \"\";  spell += patterns[x][y];\n                for(int nx=(x+dx+h)%h, ny=(y+dy+w)%w; nx!=x || ny!=y; (nx+=(dx+h))%=h, (ny+=(dy+w))%=w){\n                    spell += patterns[nx][ny];\n                    if(!spells.insert(spell).second){\n                        for(auto itr=spells.begin(); itr!=spells.end();){\n                            if((*itr).size() < res.size())spells.erase(itr++); else itr++;\n                        }\n                        chmax(res, spell, [](string& s, string& t){return mp(t.size(), s) < mp(s.size(), t);});\n                    }\n                }\n            }\n        }\n    }\n    return res;\n}\n\nint main(){\n    while(cin >> h >> w, h|w){\n        vector<string> patterns(h);\n        rep(i, h)cin >> patterns[i];\n        cout << solve(patterns) << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\nusing namespace std;\n\nint lcm(int a, int b){\n  return a/__gcd(a, b) * b;\n}\n\nint main(int argc, char *argv[]){\n  int w, h;\n  while(cin >> h >> w, h){\n    string torus[30];\n    string s[2222];\n    for (int i = 0; i < h; i++) {\n      cin >> torus[i];\n    }\n    int l = lcm(w, h);\n    int num = 0;\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        for (int k = 0; k < h; k++) {\n          s[num].push_back(torus[(h + i + k)%h][j]);\n          s[num + 1].push_back(torus[(h + i - k)%h][j]);\n        }\n        \n        for (int k = 0; k < w; k++) {\n          s[num + 2].push_back(torus[i][(w + j + k)%w]);\n          s[num + 3].push_back(torus[i][(w + j - k)%w]);\n        }\n        \n        for (int k = 0; k < l; k++) {\n          s[num + 4].push_back(torus[(l*h + i + k)%h][(l*w + j + k)%w]);\n          s[num + 5].push_back(torus[(l*h + i - k)%h][(l*w + j + k)%w]);\n          s[num + 6].push_back(torus[(l*h + i + k)%h][(l*w + j - k)%w]);\n          s[num + 7].push_back(torus[(l*h + i - k)%h][(l*w + j - k)%w]);\n        }\n        num += 8;\n      }\n    }\n    sort(s, s + 8*w*h);\n    string ans = s[0];\n    for (int i = 0; i < 8*w*h - 1; i++) {\n      int length = 0;\n      for (int j = 0;\n           j < min(s[i].length(), s[i + 1].length()) - 1; j++) {\n        if(s[i][length] == s[i + 1][length])length++;\n        else break;\n      }\n      if(length > ans.length())ans = s[i].substr(0,length);\n    }\n    if(ans.length() > 1)std::cout << ans << std::endl;\n    else std::cout << 0 << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint main(){\n  int h,w;\n  int i,j,k;\n  int ai[]={ 1, 1, 1, 0, 0,-1,-1,-1};\n  int aj[]={ 1, 0,-1, 1,-1, 1, 0,-1};\n  cin >> h >> w;\n  while(h!=0){\n    string str[10];\n    for(i=0;i<h;i++) cin >> str[i];\n    vector <string> li;\n    vector <string> ans;\n    int mal=1;\n    for(i=0;i<h;i++){\n      //cout << i << endl;\n      for(j=0;j<w;j++){\n\tfor(k=0;k<8;k++){\n\t  int bi=i,bj=j;\n\t  string buf;\n\t  buf += str[i][j];\n\t  bi+=ai[k];bj+=aj[k];\n\t  if(bi<0) bi=h-1;\n\t  if(bi>=h) bi=0;\n\t  if(bj<0) bj=w-1;\n\t  if(bj>=w) bj=0;\n\t  while(bi!=i||bj!=j){\n\t    buf+=str[bi][bj];\n\t    if(buf.size()>=mal){\n\t      if(find(li.begin(),li.end(),buf)!=li.end()) {\n\t\tmal=buf.size();\n\t\tif(buf.size()>mal) {\n\t\t  ans.clear();\n\t\t  ans.push_back(buf);\n\t\t  int a=0;\n\t\t  while(li[a].size()!=mal) a++;\n\t\t  li.erase(li.begin(),li.begin()+a-1);\n\t\t}else{\n\t\t  ans.push_back(buf);\n\t\t}\n\t\t\n\t      }else{\n\t\tli.push_back(buf);\n\t      }\n\t    }\n\t    bi+=ai[k];bj+=aj[k];\n\t    if(bi<0) bi=h-1;\n\t    if(bi>=h) bi=0;\n\t    if(bj<0) bj=w-1;\n\t    if(bj>=w) bj=0;\n\t  }\n\t}\n      }\n    }\n    //for(i=0;i<li.size();i++) cout << li[i] << endl;\n    sort(ans.begin(),ans.end());\n    //for(i=0;i<ans.size();i++) cout << ans[i] << endl;\n    if(ans.size()!=0) cout << ans[0] << endl;\n    else cout << 0 << endl;\n    cin >> h >> w;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n#include <cfloat>\n\nusing std::cerr;\nusing std::cin;\nusing std::cout;\nusing std::endl;\n\nint main(void){\n  /*cout << std::fixed << std::setprecision(16);\n  cin.tie(0);\n  std::ios::sync_with_stdio(false);*/\n\n  char S[99][99];\n\n  for(;;){\n    int h,w;\n    scanf(\"%d %d\",&h,&w);\n    if(h==0 && w==0) break;\n\n    for(int i = 0; i < h; ++i)\n      scanf(\"%s\",S[i]);\n\n    int dx[] = {-1,0,1,-1,1,-1,0,1}, dy[] = {-1,-1,-1,0,0,1,1,1}, dn = 8;\n\n    std::vector<std::string> spells;\n\n    for(int i = 10000*w; i < 10001*w; ++i){\n      for(int j = 10000*h; j < 10001*h; ++j){\n        for(int k = 0; k < dn; ++k){\n          std::string sub;\n          int u = i,v = j;\n          do{\n            sub += S[v%h][u%w];\n            v += dx[k];\n            u += dy[k];\n          }while(u % w != i % w || v % h != j % h);\n          spells.push_back(sub);\n        }\n      }\n    }\n\n    /*bool f = true;\n    std::string ans;\n    int anslength = 0;\n    for(auto c:Counts){\n      if(c.second == 2){\n        if(c.first.size() > anslength){\n          anslength = c.first.size();\n          ans = c.first;\n        }\n        f = false;\n      }\n    }\n    if(f) printf(\"0\\n\");\n    else printf(\"%s\\n\",ans.c_str());\n     */\n    sort(spells.begin(), spells.end());\n\n    int ansl = -1;\n    std::string ans;\n    for(int i = 0 ; i+1 < spells.size();++i){\n      int c = 0;\n      for(int j = 0; spells[i][j] == spells[i+1][j]&& spells[i][j]; ++j, c = j);\n      if(c > ansl){\n        ansl = c;\n        ans  = spells[i].substr(0, c);\n      }\n    }\n\n    if(ans.size() > 1)\n    printf(\"%s\\n\", ans.c_str());\nelse printf(\"0\\n\");\n\n  }\n\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvoid reg(int& x,int m){\n  x%=m;\n  x+=m;\n  x%=m;\n  return;\n}\n\nint main(){\n  int h,w;\n  while(cin>>h>>w,h){\n    vector<string> s(h);\n    for(int i=0;i<h;i++) cin>>s[i];\n    vector<int> dh={1,-1,0,0,1,1,-1,-1};\n    vector<int> dw={0,0,1,-1,1,-1,1,-1};\n    map<string,int> dic;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tfor(int dir=0;dir<8;dir++){\n\t  string st=\"\";\n\t  for(int k=0;;k++){\n\t    int ih=i+dh[dir]*k;\n\t    reg(ih,h);\n\t    int jw=j+dw[dir]*k;\n\t    reg(jw,w);\n\t    if(k!=0 && i==ih && j==jw) break;\n\t    st+=s[ih][jw];\n\t    if(k==0) continue;\n\t    dic[st]++;\n\t  }\n\t}\n      }\n    }\n    string res=\"\";\n    for(auto it=dic.begin();it!=dic.end();it++){\n      string st=it->first;\n      int cnt=it->second;\n      if(cnt>1){\n\tif(st.size()>res.size()){\n\t  res=st;\n\t}\n\telse if(st.size()==res.size()){\n\t  res=min(res,st);\n\t}\n      }\n    }\n\n    cout<<(res!=\"\" ? res : \"0\")<<endl;\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<stdio.h>\nusing namespace std;\nchar str[10][21];\nint dx[]={1,1,1,0,0,-1,-1,-1};\nint dy[]={1,0,-1,1,-1,1,0,-1};\nvector<string> V;\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tV.clear();\n\t\tfor(int i=0;i<a;i++)scanf(\"%s\",str[i]);\n\t\tfor(int i=0;i<a;i++){\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tfor(int k=0;k<8;k++){\n\t\t\t\t\tint row=i;\n\t\t\t\t\tint col=j;\n\t\t\t\t\tstring S=\"\";\n\t\t\t\t\tdo{\n\t\t\t\t\t\tS+=str[row][col];\n\t\t\t\t\t\trow+=dx[k];\n\t\t\t\t\t\tcol+=dy[k];\n\t\t\t\t\t\tif(row<0)row+=a;\n\t\t\t\t\t\tif(row>=a)row-=a;\n\t\t\t\t\t\tif(col<0)col+=b;\n\t\t\t\t\t\tif(col>=b)col-=b;\n\t\t\t\t\t}while(row!=i||col!=j);\n\t\t\t\t\tV.push_back(S);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstd::sort(V.begin(),V.end());\n\t\tint len=0;\n\t\tint m=0;\n\t\tfor(int i=0;i<V.size()-1;i++){\n\t\t\tint P=0;\n\t\t\tfor(int j=0;j<min(V[i].size(),V[i+1].size());j++){\n\t\t\t\tif(V[i][j]!=V[i+1][j])break;\n\t\t\t\tP++;\n\t\t\t}\n\t\t\tif(P>len){\n\t\t\t\tlen=P;\n\t\t\t\tm=i;\n\t\t\t}\n\t\t}\n\t\tif(len<2)printf(\"0\\n\");\n\t\telse{\n\t\t\tfor(int i=0;i<len;i++)printf(\"%c\",V[m][i]);\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<climits>\n#include<iomanip>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\nusing namespace std;\nint dx[] = {+0,+1,+0,-1,+1,+1,-1,-1};\nint dy[] = {+1,+0,-1,+0,-1,+1,-1,+1};\nint H,W;\nmap<string,int> cnt;\nstring ans;\nvector<string> vec;\n\n/*\nvoid compareS(string &a,string b)\n{\n  int as = a.size();\n  int bs = b.size();\n  if(bs < 2)return;\n  cnt[a]++,cnt[b]++;\n  if(cnt[b] < 2)return;\n  if(as > bs)return;\n  if(as != bs)a = (as < bs)?b:a;\n    a = min(a,b);\n}\n*/\n\nvoid dfs(string *G,bool used[][20],int x,int y,int dir,string s)\n{\n  if(used[y][x])return;\n  used[y][x] = true;\n  //compareS(ans,s);\n  if(s.size() >= 2)vec.push_back(s);\n  int nx = (x+dx[dir]+W)%W, ny = (y+dy[dir]+H)%H;\n  dfs(G,used,nx,ny,dir,s+G[ny][nx]);\n}\n\nint main()\n{\n  //clock_t s,t;\n  //s = clock();\n  while(cin >> H >> W,H|W)\n    {\n      vec.clear();\n      cnt.clear();\n      string G[H];\n      rep(i,H)\n\tcin >> G[i];\n\n      ans = \"\";\n      rep(i,H)\n\t{\n\t  rep(j,W)\n\t    {\n\t      rep(k,8)\n\t\t{\n\t\t  bool used[10][20];\n\t\t  rep(a,H)rep(b,W)used[a][b] = false;\t\t \n\t\t  dfs(G,used,j,i,k,string(1,G[i][j]));\n\t\t}\n\t    }\n\t}\n\t  \n      \n      sort(vec.begin(),vec.end());\n      rep(i,vec.size()-1)\n\t{\n\t  if(vec[i] == vec[i+1])\n\t    {\n\t      int vs = vec[i].size();\n\t      int as = ans.size();\n\t      if(vs < as)continue;\n\t      if(vs != as)ans = (as < vs)?vec[i]:ans;\n\t      else        ans = min(ans,vec[i]);\n\t      i++;\n\t    }\n\t}\n      \n\tans == \"\"?cout << 0 << endl:cout << ans << endl;\n\n    }\n  //t = clock();\n  //cout << setiosflags(ios::fixed) << setprecision(10) << (double)(t-s)/CLOCKS_PER_SEC << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long int dx[] = { 0,1,1,1,0,-1,-1,-1 };\nlong long int dy[] = { 1,1,0,-1,-1,-1,0,1 };\n\nint main()\n{\n\tlong long int M , N;\n\twhile(cin >> M >> N , M || N)\n\t{\n\t\tvector<vector<char>>D(M , vector<char>(N));\n\t\tset<string>SS;\n\t\tstring ans;\n\t\tfor(size_t i = 0; i < M; i++)\n\t\t{\n\t\t\tfor(size_t j = 0; j < N; j++)\n\t\t\t{\n\t\t\t\tcin >> D[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(long long int i = 0; i < M; i++)\n\t\t{\n\t\t\tfor(long long int j = 0; j < N; j++)\n\t\t\t{\n\t\t\t\tlong long int startx = j , starty = i;\n\t\t\t\tfor(long long int k = 0; k < 8; k++)\n\t\t\t\t{\n\t\t\t\t\tlong long int p = 1;\n\t\t\t\t\tstring s;\n\t\t\t\t\ts.push_back(D[starty][startx]);\n\t\t\t\t\twhile(!( ( startx + p*dx[k] + N * 2000 ) % N == startx && ( starty + p*dy[k] + M * 2000 ) % M == starty ))\n\t\t\t\t\t{\n\t\t\t\t\t\ts.push_back(D[( starty + p*dy[k] + M * 205 ) % M][( startx + p*dx[k] + N * 205 ) % N]);\n\t\t\t\t\t\tif(s.length() > ans.length())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(SS.find(s) != SS.end())\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tans = s;\n\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tSS.insert(s);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tp++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans == \"\")\n\t\t{\n\t\t\tcout << 0 << endl;\n\t\t} else\n\t\t{\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) rep(i,(n)+1)\n#define repst(i,s,n) reps(i,s,(n)+1)\n#define reprt(i,n,t) for(int (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(itr,v) for(auto (itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln '\\n'\n#define bln(i,n) (((i)==(n)-1)?'\\n':' ')\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln<<flush\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ')<<flush;}}\n#define zero(a) memset(a,0,sizeof(a))\n#define unq(a) sort(all(a)),a.erase(unique(all(a)),a.end())\n\ntypedef complex<double> P;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vst;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-10;\n\nll mop(ll a,ll b,ll m=mod) {ll r=1;a%=m;for(;b;b>>=1){if(b&1)r=r*a%m;a=a*a%m;}return r;}\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b) {return a*b/gcd(a,b);}\nbool ool(int x,int y,int h,int w) {return((x<0)||(h<=x)||(y<0)||(w<=y));}\nbool deq(double a,double b) {return abs(a-b)<eps;}\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n// ━━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…\n// .｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋\n// ・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・\n\nint h, w;\nstring s[10];\n\nsigned main() {\n\twhile (1) {\n\t\tcin >> h >> w;\n\t\tif (h==0) break;\n\t\trep(i,h) cin >> s[i];\n\t\tmap<string,int> m;\n\t\trep(i,h) rep(j,w) {\n\t\t\tint ii = i, jj = j;\n\t\t\trep(k,8) {\n\t\t\t\tstring t;\n\t\t\t\tt.pb(s[i][j]);\n\t\t\t\twhile (1) {\n\t\t\t\t\tii += ddx[k]+h, jj += ddy[k]+w;\n\t\t\t\t\tii %= h, jj %= w;\n\t\t\t\t\tif (ii==i && jj==j) break;\n\t\t\t\t\tt.pb(s[ii][jj]);\n\t\t\t\t\tm[t]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstring res;\n\t\teach(i,m) if (i.se>=2 && (res.size()<i.fi.size() || (res.size()==i.fi.size() && res>i.fi))) res = i.fi;\n\t\tif (res.empty()) cout << 0 << ln;\n\t\telse cout << res << ln;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define foreach(i,c) for(auto i=(c).begin();i!=(c).end();++i)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nint main()\n{\n\tfor(int h,w;cin>>h>>w,h|w;){\n\t\tvs d(h);\n\t\trep(i,h) cin>>d[i];\n\t\t\n\t\tvs ss;\n\t\trep(i0,h) rep(j0,w) rep(k,8){\n\t\t\tint di[]={-1,-1,-1,0,0,1,1,1};\n\t\t\tint dj[]={-1,0,1,-1,1,-1,0,1};\n\t\t\tstring s;\n\t\t\tvvi vis(h,vi(w));\n\t\t\tfor(int i=i0,j=j0;!vis[i][j];i=(i+di[k]+h)%h,j=(j+dj[k]+w)%w)\n\t\t\t\ts+=d[i][j],vis[i][j]=1;\n\t\t\tss.push_back(s);\n\t\t}\n\t\t\n\t\tmap<string,int> cnt;\n\t\tfor(string s:ss)\n\t\t\trep(i,s.size())\n\t\t\t\tcnt[s.substr(0,s.size()-i)]++;\n\t\t\n\t\tstring res;\n\t\tfor(auto kv:cnt)\n\t\t\tif(kv.second>=2 && res.size()<kv.first.size())\n\t\t\t\tres=kv.first;\n\t\t\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <set>\nusing namespace std;\nstring mp[11];\nint w,h;\nset <string> cnt;\nstring ans;\nvoid check(int x,int y){\n  string str;\n  for(int i=-1;i<=1;i++)\n    for(int j=-1;j<=1;j++){\n      if(i==0 && j==0) continue;\n      str = mp[y][x];\n      int nx=(x+j+w)%w,ny=(y+i+h)%h;\n      while(ny!=y || nx!=x){\n\tstr+=mp[ny][nx],nx=(nx+j+w)%w,ny=(ny+i+h)%h;\n      if(cnt.count(str)){\n\tif(str.size()>ans.size()) ans = str;\n\telse if(str.size()==ans.size()) ans = min(str,ans);\n      }\n      else cnt.insert(str);\n      }\n    }\n}\n\nint main(){\n  while(1) {\n    cin >> h >> w;\n    cnt.clear();\n  if(w == 0 && h == 0) break;\n  for(int i=0;i<h;i++) cin >> mp[i];\n\n  ans = \"\";\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)check(j,i);\n  if(ans.size()==0) ans = \"0\";\n  cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <set>\n\nusing namespace std;\n\nint dy[8] = { 0, 1, 1, 1, 0,-1,-1,-1};\nint dx[8] = { 1, 1, 0,-1,-1,-1, 0, 1};\n\nint main(void){\n    int h, w;\n    while (cin>>h>>w && h) {\n        vector<string> s(h);\n        for (int i = 0; i < h; i++) cin >> s[i];\n        \n        set<string> p;\n        string ans = \"\";\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                for (int k = 0; k < 8; k++) {\n                    int ny = i, nx = j;\n                    string t = \"\";\n                    t += s[ny][nx];\n                    while ((ny+dy[k]+h)%h != i || (nx+dx[k]+w)%w != j) {\n                        ny = (ny + dy[k] + h) % h;\n                        nx = (nx + dx[k] + w) % w;\n                        t += s[ny][nx];\n                        \n                        auto it = p.find(t);\n                        if (it == p.end()) p.insert(t);\n                        else if (t.size() > ans.size()) ans = t;\n                        else if (t.size() == ans.size()) ans = min(ans, t);\n                    }\n                }\n            }\n        }\n        if (ans.size() == 0) cout << 0 << endl;\n        else cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <bitset>\n#include <time.h>\n#include <queue>\n#include <stack>\n#include <cctype>\n#include <utility>\n#include <numeric>\n#include <cstdlib>\n#include <functional>\n#include <iomanip>\n#include <sstream>\n#define Mod 1000000007\n#define SMod 10007\n#define INint 2147483647\n#define pi acos(-1.0)\n#define eps 1e-4\n#define lll __int64\n#define ll long long\nusing namespace std;\n#define N 12\n#define M 22\n\nchar ss[N][M];\nint dx[8] = {-1,-1,-1,0,0,1,1,1};\nint dy[8] = {-1,0,1,1,-1,-1,0,1};\nstring S1,S2,ans;\nint n,m;\n\nvoid go1(int x,int y,int prex,int prey,int k)\n{\n    if(x == prex && y == prey)\n        return;\n    S1 += ss[x][y];\n    int nx = x+dx[k];\n    int ny = y+dy[k];\n    nx = (nx+n)%n;\n    ny = (ny+m)%m;\n    go1(nx,ny,prex,prey,k);\n    return;\n}\n\nvoid go2(int x,int y,int prex,int prey,int k)\n{\n    if(x == prex && y == prey)\n        return;\n    S2 += ss[x][y];\n    int nx = x+dx[k];\n    int ny = y+dy[k];\n    nx = (nx+n)%n;\n    ny = (ny+m)%m;\n    go2(nx,ny,prex,prey,k);\n    return;\n}\n\nint main()\n{\n    int i,j,k,h,ka,kb,u,v;\n    while(scanf(\"%d%d\",&n,&m)!=EOF && n+m)\n    {\n        memset(ss,0,sizeof(ss));\n        for(i=0;i<n;i++)\n            scanf(\"%s\",ss[i]);\n        int tag = 0;\n        int maxi = 0;\n        ans = \"\";\n        for(i=0;i<n;i++)\n        {\n            for(j=0;j<m;j++)\n            {\n                for(k=0;k<n;k++)\n                {\n                    for(h=0;h<m;h++)\n                    {\n                        if(ss[i][j] == ss[k][h])\n                        {\n                            for(ka=0;ka<8;ka++)\n                            {\n                                for(kb=0;kb<8;kb++)\n                                {\n                                    if(i == k && j == h && ka == kb)\n                                        continue;\n                                    S1 = \"\";\n                                    S1 += ss[i][j];\n                                    int nx = i+dx[ka];\n                                    int ny = j+dy[ka];\n                                    nx = (nx+n)%n;\n                                    ny = (ny+m)%m;\n                                    go1(nx,ny,i,j,ka);\n                                    //cout<<S1<<endl;\n                                    S2 = \"\";\n                                    S2 += ss[k][h];\n                                    int kx = k+dx[kb];\n                                    int ky = h+dy[kb];\n                                    kx = (kx+n)%n;\n                                    ky = (ky+m)%m;\n                                    go2(kx,ky,k,h,kb);\n                                    //cout<<S2<<endl;\n                                    int cnt = 0;\n                                    int len1 = S1.length();\n                                    int len2 = S2.length();\n                                    for(u=0;u<min(len1,len2);u++)\n                                    {\n                                        if(S1[u] != S2[u])\n                                            break;\n                                    }\n                                    cnt = u;\n                                    if(cnt > maxi)\n                                    {\n                                        ans = S1.substr(0,u);\n                                        //cout<<\"Sub: \"<<S1.substr(0,u)<<endl;\n                                        maxi = cnt;\n                                    }\n                                    else if(cnt == maxi)\n                                    {\n                                        if(ans > S1.substr(0,u))\n                                            ans = S1.substr(0,u);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if(ans.length() <= 1)\n            puts(\"0\");\n        else\n            cout<<ans<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long int dx[] = { 0,1,1,1,0,-1,-1,-1 };\nlong long int dy[] = { 1,1,0,-1,-1,-1,0,1 };\n\nint main()\n{\n\tlong long int M , N;\n\twhile(cin >> M >> N , M || N)\n\t{\n\t\tvector<vector<char>>D(M , vector<char>(N));\n\t\tset<string>SS;\n\t\tstring ans;\n\t\tfor(size_t i = 0; i < M; i++)\n\t\t{\n\t\t\tfor(size_t j = 0; j < N; j++)\n\t\t\t{\n\t\t\t\tcin >> D[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(long long int i = 0; i < M; i++)\n\t\t{\n\t\t\tfor(long long int j = 0; j < N; j++)\n\t\t\t{\n\t\t\t\tlong long int startx = j , starty = i;\n\t\t\t\tfor(long long int k = 0; k < 8; k++)\n\t\t\t\t{\n\t\t\t\t\tlong long int p = 1;\n\t\t\t\t\tstring s;\n\t\t\t\t\ts.push_back(D[starty][startx]);\n\t\t\t\t\twhile(!( ( startx + p*dx[k] + N * 2000 ) % N == startx && ( starty + p*dy[k] + M * 2000 ) % M == starty ))\n\t\t\t\t\t{\n\t\t\t\t\t\ts.push_back(D[( starty + p*dy[k] + M * 205 ) % M][( startx + p*dx[k] + N * 205 ) % N]);\n\t\t\t\t\t\tif(s.length() > ans.length())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(SS.find(s) != SS.end())\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tans = s;\n\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tSS.insert(s);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tp++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans.length()<=1)\n\t\t{\n\t\t\tcout << 0 << endl;\n\t\t} else\n\t\t{\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX_H=11,MAX_W=21;\nconst int dx[8]={1,0,-1,0,1,1,-1,-1};\nconst int dy[8]={0,1,0,-1,1,-1,1,-1};\n\nint h,w,x,y; string now,ans;\nstring S[MAX_H];\nint visited[MAX_H][MAX_W];\nset<string> cnt;\n\nvoid solve(){\n    ans=\"\"; cnt.clear();\n    for (int i=0;i<h;++i){\n        for (int j=0;j<w;++j){\n            for (int k=0;k<8;++k){\n                for (int l=0;l<h;++l)\n                    for (int m=0;m<w;++m)\n                        visited[l][m]=0;\n                x=i,y=j; now=\"\";\n                while(!visited[x][y]){\n                    now+=S[x][y]; visited[x][y]=1;\n                    (x+=dx[k]+h)%=h; (y+=dy[k]+w)%=w;\n                    if (!cnt.count(now)){cnt.emplace(now); continue;}\n                    if (ans.size()<now.size()) ans=now;\n                    else if (ans.size()==now.size()&&now<ans) ans=now;\n                }\n            }\n        }\n    }\n    if (ans.size()<2) cout << 0 << '\\n';\n    else cout << ans << '\\n';\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(cin >> h >> w,h){\n        for (int i=0;i<h;++i) cin >> S[i];\n        solve();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(int h,int w){\n    vector<string> vs(h);\n    rep(i,0,h) cin >> vs[i];\n    int dx[]={1,1,0,-1,-1,-1,0,1},dy[]={0,-1,-1,-1,0,1,1,1};\n    set<string> st;\n    vector<vector<bool>> used(h,vector<bool>(w));\n    string s,ans;\n    function<void(int,int)> dfs=[&](int y,int x){\n        if(st.find(s)!=st.end() and s.size()>=ans.size() and (s.size()>ans.size() or s<ans)) ans=s;\n        st.insert(s);\n        rep(i,0,8){\n            int ny=y+dy[i],nx=x+dx[i];\n            if(ny==h) ny=0;\n            if(ny<0) ny=h-1;\n            if(nx==w) nx=0;\n            if(nx<0) nx=w-1;\n            if(used[ny][nx]) continue;\n            s.push_back(vs[ny][nx]);\n            used[ny][nx]=true;\n            dfs(ny,nx);\n            s.pop_back();\n            used[ny][nx]=false;\n        }\n    };\n    rep(y,0,h) rep(x,0,w){\n        s.push_back(vs[y][x]);\n        used[y][x]=true;\n        dfs(y,x);\n        s.pop_back();\n        used[y][x]=false;\n    }\n\n    if(ans.size()<2) cout << 0 << endl;\n    else cout << ans << endl;\n}\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    for(;;){\n        int h,w;\n        cin >> h >> w;\n        if(!h and !w) break;\n        solve(h,w);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <set>\n\nusing namespace std;\n\nconst int dx[] = { -1, 0, 1, 1, 1, 0, -1, -1 };\nconst int dy[] = { -1, -1, -1, 0, 1, 1, 1, 0 };\n\nint main(){\n\twhile(true){\n\t\tint w, h;\n\t\tcin >> h >> w;\n\t\tif(h == 0 && w == 0){ break; }\n\t\tvector<string> v(h);\n\t\tfor(int i = 0; i < h; ++i){ cin >> v[i]; }\n\t\tset<string> found;\n\t\tstring answer;\n\t\tfor(int i = 0; i < h; ++i){\n\t\t\tfor(int j = 0; j < w; ++j){\n\t\t\t\tfor(int d = 0; d < 8; ++d){\n\t\t\t\t\tint y = i, x = j;\n\t\t\t\t\tstring s;\n\t\t\t\t\tdo {\n\t\t\t\t\t\ts += v[y][x];\n\t\t\t\t\t\tif(found.find(s) == found.end()){\n\t\t\t\t\t\t\tfound.insert(s);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif(answer.size() < s.size()){\n\t\t\t\t\t\t\t\tanswer = s;\n\t\t\t\t\t\t\t}else if(answer.size() == s.size() && s < answer){\n\t\t\t\t\t\t\t\tanswer = s;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\ty = (y + dy[d] + h) % h;\n\t\t\t\t\t\tx = (x + dx[d] + w) % w;\n\t\t\t\t\t} while(y != i || x != j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(answer.size() <= 1){ answer = \"0\"; }\n\t\tcout << answer << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint h, w;\nint dy[8] = {-1, -1, 0, 1, 1, 1, 0, -1};\nint dx[8] = {0, 1, 1, 1, 0, -1, -1, -1};\nbool vis[10][20];\nchar dat[10][20];\nvector<string> str;\n\nvoid calc(int y, int x, int d){\n  fill(vis[0], vis[10], false);\n  string path;\n  int ny = y;\n  int nx = x;\n  while(!vis[ny][nx]){\n    vis[ny][nx] = true;\n    path.push_back(dat[ny][nx]);\n    ny = (ny + dy[d] + h) % h;\n    nx = (nx + dx[d] + w) % w;\n  }\n  if(path.size() > 1) str.push_back(path);\n}\n\nint comp(string& a, string& b){\n  int size = min(a.size(), b.size());\n  for(int i=0;i<size;i++) if(a[i] != b[i]) return i;\n  return size;\n}\n\nmain(){\n  while(cin >> h >> w && (h|w)){\n    str.clear();\n    for(int i=0;i<h;i++) for(int j=0;j<w;j++) cin >> dat[i][j];\n    for(int i=0;i<h;i++) for(int j=0;j<w;j++) for(int k=0;k<8;k++) calc(i, j, k);\n    sort(str.begin(), str.end());\n    int ans = 0, id;\n    for(int i=1;i<str.size();i++){\n      int tmp = comp(str[i-1], str[i]);\n      if(ans < tmp){\n        ans = tmp;\n        id = i;\n      }\n    }\n    if(ans > 1) cout << str[id].substr(0, ans) << endl;\n    else cout << 0 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr, __VA_ARGS__)\n//#define LOG(...)\n#define FOR(i, a, b) for (int i = (int)(a); i < (int)(b); ++i)\n#define RFOR(i, a, b) for (int i = (int)(b - 1); i >= (int)(a); --i)\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define RREP(i, n) for (int i = (int)(n - 1); i >= 0; --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(a) ((int)(a).size())\n#define BIT(x, i) (((x) >> (i)) & 1)\n#define SQ(x) ((x) * (x))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = {-1,0,1,0,1,1,-1,-1}, dy[] = {0,1,0,-1,-1,1,1,-1};\n\nint H, W;\nchar field[10][20];\n\nint ma;\nstring mas;\n\nset<string> S;\n\nvoid add_string(int i, int n, int m, int x, int y) {\n    REP(j, n) {\n        int sx = x, sy = y;\n        stringstream ss;\n        ss << field[sy][sx];\n        REP(k, m) {\n            sx = (sx + dx[i] + W) % W;\n            sy = (sy + dy[i] + H) % H;\n            ss << field[sy][sx];\n            string s = ss.str();\n            if (!S.insert(s).second) {\n                if (ma < (int)s.length()) {\n                    ma = s.length();\n                    mas = s;\n                } if (ma == (int)s.length()) {\n                    mas = min(mas, s);\n                }\n            }\n        }\n        x = (x + dx[i] + W) % W;\n        y = (y + dy[i] + H) % H;\n    }\n}\n\nint main() {\n    while (cin >> H >> W, H|W) {\n        REP(y, H) REP(x, W) cin >> field[y][x];\n        S.clear();\n\n        ma = 0;\n        REP(i, 8) {\n            if (i < 4) {\n                if (i % 2 == 0) {\n                    REP(y, H) add_string(i, W, W-1, 0, y);\n                } else {\n                    REP(x, W) add_string(i, H, H-1, x, 0);\n                }\n            } else {\n                int n = (H == W ? H : H*W);\n                REP(x, W) REP(y, H) {\n                    add_string(i, 1, n-1, x, y);\n                }\n            }\n        }\n        if (ma == 0) {\n            cout << 0 << endl;\n        } else {\n            cout << mas << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*{{{*/  //template\n#define rep(i,n) for(int i=0;i<n;i++)\nconstexpr int INF = numeric_limits<int>::max()/2;\nconstexpr long long LINF = numeric_limits<long long>::max()/3;\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define sz(x) (int)(x).size()\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cerr<<#x<<\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n//struct fin{ fin(){ cin.tie(0); ios::sync_with_stdio(false); } } fin_;\nstruct Double{ double d; explicit Double(double x) : d(x){} };\nostream& operator<<(ostream& os,const Double x){ os << fixed << setprecision(20) << x.d; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const vector<T>& vec){ os << \"[\"; for(const auto& v : vec){ os << v << \",\"; } os << \"]\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os,const pair<T,U>& p){ os << \"(\" << p.first << \",\"<< p.second <<\")\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const set<T>& st){ os<<\"{\"; for(T v:st) os<<v<<\",\"; os <<\"}\"; return os; }\ntemplate<typename T,typename U> inline void chmax(T &x,U y){ if(y>x) x = y; }\ntemplate<typename T,typename U> inline void chmin(T &x,U y){ if(y<x) x = y; }\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nll gcd(ll a,ll b){ if(b==0) return a; else return gcd(b,a%b); }\n//constexpr double eps = 1e-14; \nconstexpr double eps = 1e-10; \nconstexpr ll mod = 1e9+7;\nconst int dx[]={1,0,-1,0} ,dy[] = {0,1,0,-1};\n/*}}}*/\n\nint W,H;\n\nvoid solve(){\n    vector<string> s(H);\n    rep(i,H) cin>>s[i];\n\n    map<string,int> mp;\n\n\n    rep(i,H) rep(j,W){\n        //cout << i << \" \" << j << endl;\n        for(int dx=-1;dx<=1;dx++) for(int dy=-1;dy<=1;dy++) if(!(dx==0 and dy==0)){\n            vector<vector<bool>> visited(H,vector<bool>(W,false));\n            int x=i,y=j;\n            string t = \"\";\n            //cout << i << \" \" << j << \" \"  << dx << \" \" << dy << endl;\n            while(!visited[x][y]){\n                //cout << \"ok\" << endl;\n                visited[x][y] = true;\n                t.pb(s[x][y]);\n                x+=dx;\n                y+=dy;\n                x += H;\n                y += W;\n                x%=H;\n                y%=W;\n                if(t.size()>1) mp[t]++;\n            }\n        }\n    }\n\n\n    string ans;\n    for(auto p : mp){\n        if(p.se >= 2){\n            if(ans==\"\" or p.fi.size() > ans.size()){\n                ans = p.fi;\n            }\n        }\n    }\n    if(ans == \"\"){\n        cout << 0 << endl;\n        return;\n    }\n    cout << ans << endl;\n    return;\n}\n\nint main(){\n    while(1){\n        cin >> H >> W;\n        if(H==0 and W==0) break;\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int dx[] = {-1, 0, 1, 0, -1, -1, 1, 1};\nconst int dy[] = {0, -1, 0, 1, -1, 1, -1, 1};\n\nint h, w;\nstring s[10];\n\nvector<string> generate(int sx, int sy, int dir)\n{\n\tint x = sx, y = sy;\n\tstring str = \"\";\n\tvector<string> res;\n\t\n\twhile (true){\n\t\tstr += s[x][y];\n\t\tres.push_back(str);\n\t\tx = (x + dx[dir] + h) % h;\n\t\ty = (y + dy[dir] + w) % w;\n\t\tif (sx == x && sy == y) break;\n\t}\n\t\n\treturn res;\n}\n\nstring solve()\n{\n\tmap<string, int> mp;\n\t\n\tfor (int i = 0; i < h; i++){\n\t\tfor (int j = 0; j < w; j++){\n\t\t\tfor (int d = 0; d < 8; d++){\n\t\t\t\tvector<string> vs = generate(i, j, d);\n\t\t\t\tfor (auto &s : vs){\n\t\t\t\t\tmp[s]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstring res = \"0\";\n\tfor (auto &p : mp){\n\t\tif (p.second < 2) continue;\n\t\tif (res.size() > p.first.size()) continue;\n\t\tif (res.size() < p.first.size()){\n\t\t\tres = p.first;\n\t\t}\n\t\telse res = min(res, p.first);\n\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\twhile (cin >> h >> w, h){\n\t\tfor (int i = 0; i < h; i++){\n\t\t\tcin >> s[i];\n\t\t}\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> V;\ntypedef vector<V> VV;\ntypedef vector<VV> VVV;\n\nint dx[8] = {1, 0, -1, 0, 1, 1, -1, -1};\nint dy[8] = {0, 1, 0, -1, 1, -1, 1, -1};\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int H, W;\n    while (cin >> H >> W, H) {\n        vector<string> s(H);\n        rep(i, H) cin >> s[i];\n\n        map<string, int> mp;\n        rep(i, H) {\n            rep(j, W) {\n                rep(k, 8) {\n                    string t = \"\";\n                    set<P> st;\n                    int x = i;\n                    int y = j;\n                    while (!st.count(P(x, y))) {\n                        t += s[x][y];\n                        mp[t]++;\n                        st.insert(P(x, y));\n                        x = (x + dx[k] + H) % H;\n                        y = (y + dy[k] + W) % W;\n                    }\n                }\n            }\n        }\n\n        string ans = \"0\";\n        for (auto p : mp) {\n            if (p.first.size() > ans.size() && p.second >= 2) {\n                ans = p.first;\n            }\n        }\n\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint lcm(int a,int b){\t//a,b < 20だしいいよね\n\t\tif (a < b){\n\t\t\tswap(a,b);\n\t\t}\n\t\tint times = a * b;\n\t\tvector<int> num;\n\t\tint gcd,lcm;\n\t\twhile(1){\n\t\t\tint n;\n\t\t\tn = a % b;\n\t\t\tif(n == 0){\tbreak;}\n\t\t\ta = b;\n\t\t\tb = n;\n\t\t}\n\t\tgcd = b;\n\t\tlcm = times / gcd;\n\treturn lcm;\n}\n\nint main(){\n\tint h,w;\n\twhile(1){\n\t\tcin >> h >> w ;\n\t\tif(h == 0 && w == 0){\tbreak;}\n\t\tchar donut[10][20];\n\t\tfor(int i=0;i<10;i++){\n\t\t\tfor(int j=0;j<20;j++){\n\t\t\t\tdonut[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tstring code[1600];\n\t\tbool much[1600];\n\t\tfor(int i = 0; i < 1600; i++){\n\t\t\tcode[i] = \"\";\n\t\t\tmuch[i] = true;\n\t\t}\t//初期化…\n\n\t\tint l = lcm(w,h);\t//ななめの最大数\n\t\tint a = 0;\t//strの数を数えます\n\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j =0; j < w; j++){\n\t\t\t\tcin >> donut[i][j];\n\t\t\t}\n\t\t}\t//input\n\n\t\tfor(int y = 0; y < h; y++){\n\t\t\tfor(int x = 0; x < w; x++){\n\t\t\t\tfor(int i = 0; i < h; i++){\t//縦列\n\t\t\t\t\tcode[a].append(1,donut[(y + i)%h][x]);\n\t\t\t\t\tcode[a+1].append(1,donut[h-(y + i)%h-1][x]);\n\t\t\t\t}\n\t\t\t\ta += 2;\n\t\t\t\tfor(int j = 0; j < w; j++){\t//横列\n\t\t\t\t\tcode[a].append(1,donut[y][(x + j)%w]);\n\t\t\t\t\tcode[a+1].append(1,donut[y][w-(x+j)%w-1]);//absつけなくても0になりません！\n\t\t\t\t}\n\t\t\t\ta += 2;\n\t\t\t\tfor(int k = 0; k < l; k++){\t//ななめ\n\t\t\t\t\tcode[a].append(1,donut[(y + k)%h][(x + k)%w]);\n\t\t\t\t\tcode[a+1].append(1,donut[(y + k)%h][(l + x - k)%w]);\n\t\t\t\t\tcode[a+2].append(1,donut[(l + y - k)%h][(x + k)%w]);\n\t\t\t\t\tcode[a+3].append(1,donut[(l + y - k)%h][(l + x - k)%w]);\n\t\t\t\t}\n\t\t\t\ta += 4;\n\t\t\t}\n\t\t}\n\t\tstring mag = \"\";\n\t\t//a:strの数-1\n\n\t\tsort(code,code+a);//nとn+1を比べます\n\n\t\tfor(int i = 0; i < a-1; i++){\n\t\t\tif(code[i][0] != code[i+1][0]){\n\t\t\t\tmuch[i+1] = false;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 1; i < l; i++){\t//2文字目から\n\t\t\tfor(int j = a-1; j > 0; j--){\t//逆順\n\t\t\t\tif(much[j] == true && code[j].length() >= i+1 && code[j-1].length() >= i+1){//=を忘れていました\n\t\t\t\t\t//jのi+1文字目とj-1のi+1文字目を比べるよ\n\t\t\t\t\tif(code[j][i] != code[j-1][i]){\n\t\t\t\t\t\tmuch[j] = false;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tmag = code[j];\n\t\t\t\t\t\tmag.resize(i+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(mag == \"\"){\n\t\t\tcout << \"0\" << endl;\n\t\t}else{\n\t\t\tcout << mag << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<set>\nusing namespace std;\ntypedef vector<int> vi;\nset<string> cands;\nint dy[]={-1,-1,-1,0,0,1,1,1};\nint dx[]={-1,0,1,-1,1,-1,0,1};\nint maxlength=0,h,w;\nstring ans=\"\";\nvoid check(int y,int x,string *board)\n{\n  for(int k=0;k<8;k++)\n  {\n    bool visited[h][w];\n    memset(visited,false,sizeof(visited));\n    int yy=y,xx=x;\n    string str=\"\";\n    while(!visited[yy][xx])\n    {\n      str+=board[yy][xx];\n      if(cands.find(str)!=cands.end())\n      {\n\t\t\t\tint str_len=str.length();\n\t\t\t\tif(maxlength<str_len)\n\t\t\t\t{\n\t  \t\t\tans=str;\n\t\t\t\t\tmaxlength=str_len;\n\t\t\t\t}\n\t\t\t\telse if(maxlength==str_len && str<ans)\n\t\t\t\t{\n\t  \t\t\tans=str;\n\t\t\t\t\tmaxlength=str_len;\n\t\t\t\t}\n      }\n      else\n      {\n\t\t\t\tcands.insert(str);\n      }\n      visited[yy][xx]=true;\n      yy=(yy+dy[k]+h)%h;\n      xx=(xx+dx[k]+w)%w;\n    }\n  }\n}\n\nint main()\n{\n  while(1) \n  {\n    cin >> h >> w;\n    if(h==0) break;\n    string board[h];\n    cands.clear();\n    for(int i=0;i<h;i++)\n    {\n      cin >> board[i];\n    }\n    maxlength=0;\n    ans=\"0\";\n    for(int i=0;i<h;i++)\n    {\n      for(int j=0;j<w;j++)\n      {\n\t\t\t\tcheck(i,j,board);\n      }\n    }\n    if(maxlength>=2)\n    {\n      cout << ans << endl;\n     }\n    else\n    {\n      cout << \"0\" << endl;\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define ll long long\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1316\n\nint h, w;\n\nint dy[8] = { -1, -1, -1, 0, 0, 1, 1, 1 };\nint dx[8] = { -1, 0, 1, -1, 1, -1, 0, 1 };\n\nset<string> Set;\nint Maxlen = 0;\nstring ans;\nvector<vector<char>> donut;\nvector<vector<int>> usage;\n\nvoid solve(int i, int j) {\n\tfor (int k = 0; k < 8;k++) {\n\t\tusage.clear();\n\t\tusage.resize(h, vector<int>(w, 0));\n\t\tstring ret = \"\";\n\t\tint y = i, x = j;\n\t\twhile (usage[y][x] == 0) {\n\t\t\tret += donut[y][x];\n\n\t\t\tif (Set.find(ret) != Set.end()) {\n\t\t\t\tif (ret.length() > Maxlen) {\n\t\t\t\t\tMaxlen = ret.length();\n\t\t\t\t\tans = ret;\n\t\t\t\t}\n\t\t\t\telse if (ret.length() == Maxlen && ret < ans) {\n\t\t\t\t\tans = ret;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSet.insert(ret);\n\t\t\t}\n\n\t\t\tusage[y][x] = 1;\n\t\t\ty = (y + dy[k] + h) % h;\n\t\t\tx = (x + dx[k] + w) % w;\n\n\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\twhile (cin >> h >> w) {\n\t\tif (h == 0 && w == 0)break;\n\t\tMaxlen = 0;\n\t\tans = \"\";\n\t\tdonut.clear();\n\t\tdonut.resize(h, vector<char>(w));\n\t\tfor (int i = 0; i < h;i++) {\n\t\t\tfor (int j = 0; j < w;j++) {\n\t\t\t\tcin >> donut[i][j];\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < h;i++) {\n\t\t\tfor (int j = 0; j < w;j++) {\n\t\t\t\tsolve(i, j);\n\t\t\t}\n\t\t}\n\t\tif (ans.length() < 2) cout << 0 << endl;\n\t\telse cout << ans << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "// Header {{{\n// includes {{{\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <unistd.h>\n#include <vector>\n// }}}\nusing namespace std;\n// consts {{{\nstatic const int INF = 1e9;\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n// }}}\n// typedefs {{{\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<ULL> VULL;\ntypedef vector<VULL> VVULL;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef pair<int, int> PII;\ntypedef complex<int> P;\n// }}}\n// macros & inline functions {{{\n// syntax sugars {{{\n#define FOR(i, b, e) for (typeof(e) i = (b); i < (e); ++i)\n#define FORI(i, b, e) for (typeof(e) i = (b); i <= (e); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define REPI(i, n) FORI(i, 0, n)\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n// }}}\n// conversion {{{\ninline int toInt(string s) { int v; istringstream sin(s); sin>>v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout<<x; return sout.str(); }\n// }}}\n// array and STL {{{\n#define ARRSIZE(a) ( sizeof(a) / sizeof(a[0]) )\n#define ZERO(a, v) ( assert(v == 0 || v == -1), memset(a, v, sizeof(a)) )\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n#define SIZE(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c, it) for(typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define REACH(c, it) for(typeof((c).rbegin()) it=(c).rbegin(); it!=(c).rend(); ++it)\n#define EXIST(s, e) ((s).find(e) != (s).end())\n// }}}\n// bit manipulation {{{\n// singed integers are not for bitwise operations, specifically arithmetic shifts ('>>', and maybe not good for '<<' too)\n#define IS_UNSIGNED(n) (!numeric_limits<typeof(n)>::is_signed)\n#define BIT(n) (assert(IS_UNSIGNED(n)), assert(n < 64), (1ULL << (n)))\n#define BITOF(n, m) (assert(IS_UNSIGNED(n)), assert(m < 64), ((ULL)(n) >> (m) & 1))\ninline int BITS_COUNT(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int MSB(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c-1; }\ninline int MAKE_MASK(ULL upper, ULL lower) { assert(lower < 64 && upper < 64 && lower <= upper); return (BIT(upper) - 1) ^ (BIT(lower) - 1); }\n// }}}\n// for readable code {{{\n#define EVEN(n) (n % 2 == 0)\n#define ODD(n) (!EVEN(n))\n// }}}\n// debug {{{\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n#define dprt(fmt, ...) if (opt_debug) { fprintf(stderr, fmt, ##__VA_ARGS__); }\n#define darr(a) if (opt_debug) { copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define darr_range(a, f, t) if (opt_debug) { copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define dvec(v) if (opt_debug) { copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define darr2(a) if (opt_debug) { FOR(__i, 0, (arrsz(a))){ darr( (a)[__i] ); } }\n#define WAIT() if (opt_debug) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n#define dump(x) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl; }\n#define dumpl(x) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #x << endl << (x) << endl; }\n#define dumpf() if (opt_debug) { cerr << __PRETTY_FUNCTION__ << endl; }\n#define where() if (opt_debug) { cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl; }\n#define show_bits(b, s) if(opt_debug) { REP(i, s) { cerr << BITOF(b, s-1-i); if(i%4 == 3) cerr << ' '; } cerr << endl; }\n\n// ostreams {{{\n// complex\ntemplate<typename T> ostream& operator<<(ostream& s, const complex<T>& d) {return s << \"(\" << d.real() << \", \" << d.imag() << \")\";}\n\n// pair\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n\n// vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector<T>& d) {\n\tint len = d.size();\n\tREP (i, len) {\n\t\ts << d[i]; if (i < len - 1) s << \"\\t\";\n\t}\n\treturn s;\n}\n\n// 2 dimentional vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector< vector<T> >& d) {\n\tint len = d.size();\n\tREP (i, len) {\n\t\ts << d[i] << endl;\n\t}\n\treturn s;\n}\n\n// map\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const map<T1, T2>& m) {\n\ts << \"{\" << endl;\n\tfor (typeof(m.begin()) itr = m.begin(); itr != m.end(); ++itr) {\n\t\ts << \"\\t\" << (*itr).first << \" : \" << (*itr).second << endl;\n\t}\n\ts << \"}\" << endl;\n\treturn s;\n}\n// }}}\n// }}}\n// }}}\n// time {{{\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\n// }}}\n// string manipulation {{{\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\ninline string join(VS s, string j) { string t; REP(i, s.size()) { t += s[i] + j; } return t; }\n// }}}\n// geometry {{{\n#define Y real()\n#define X imag()\n// }}}\n// 2 dimentional array {{{\nP dydx4[4] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1) };\nP dydx8[8] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1), P(-1, 1), P(1, 1), P(1, -1), P(-1, -1) };\nint g_height, g_width;\nbool in_field(P p) {\n\treturn (0 <= p.Y && p.Y < g_height) && (0 <= p.X && p.X < g_width);\n}\n// }}}\n// input and output {{{\ninline void input(string filename) {\n\tfreopen(filename.c_str(), \"r\", stdin);\n}\ninline void output(string filename) {\n\tfreopen(filename.c_str(), \"w\", stdout);\n}\n// }}}\n// }}}\n\n// Header under development {{{\n\nint LCM(int a, int b) {\n\t// FIXME\n\treturn a * b;\n}\n\n// Fraction class {{{\n// ref: http://martin-thoma.com/fractions-in-cpp/\nclass Fraction {\n\tpublic:\n\t\tULL numerator;\n\t\tULL denominator;\n\t\tFraction(ULL _numerator, ULL _denominator) {\n\t\t\tassert(_denominator > 0);\n\t\t\tnumerator = _numerator;\n\t\t\tdenominator = _denominator;\n\t\t};\n\n\t\tFraction operator*(const ULL rhs) {\n\t\t\treturn Fraction(this->numerator * rhs, this->denominator);\n\t\t};\n\n\t\tFraction operator*(const Fraction& rhs) {\n\t\t\treturn Fraction(this->numerator * rhs.numerator, this->denominator * rhs.denominator);\n\t\t}\n\n\t\tFraction operator+(const Fraction& rhs) {\n\t\t\tULL lcm = LCM(this->denominator, rhs.denominator);\n\t\t\tULL numer_lhs = this->numerator * (this->denominator / lcm);\n\t\t\tULL numer_rhs = rhs.numerator * (rhs.numerator / lcm);\n\t\t\treturn Fraction(numer_lhs + numer_rhs, lcm);\n\t\t}\n\n\t\tFraction& operator+=(const Fraction& rhs) {\n\t\t\tFraction result = (*this) + rhs;\n\t\t\tthis->numerator = result.numerator;\n\t\t\tthis->denominator = result.denominator;\n\t\t\treturn *this;\n\t\t}\n};\n\nstd::ostream& operator<<(std::ostream &s, const Fraction &a) {\n\tif (a.denominator == 1) {\n\t\ts << a.numerator;\n\t} else {\n\t\ts << a.numerator << \"/\" << a.denominator;\n\t}\n\treturn s;\n}\n\n// }}}\n\n// }}}\n\nbool opt_debug = false;\n\nint main(int argc, char** argv) {\n\tstd::ios_base::sync_with_stdio(false);\n\t// set options {{{\n\tint __c;\n\twhile ( (__c = getopt(argc, argv, \"d\")) != -1 ) {\n\t\tswitch (__c) {\n\t\t\tcase 'd':\n\t\t\t\topt_debug = true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tabort();\n\t\t}\n\t}\n\t// }}}\n\n\tinput(\"./inputs/0.txt\");\n\t// output(\"./outputs/0.txt\");\n\n\tint h, w;\n\twhile (cin >> h >> w, h | w) {\n\t\tVVC field(h, VC(w, ' '));\n\t\tREP (i, h) {\n\t\t\tREP (j, w) {\n\t\t\t\tcin >> field[i][j];\n\t\t\t}\n\t\t}\n\n\t\tmap<string, int> m;\n\t\tREP (i, h) {\n\t\t\tREP (j, w) {\n\t\t\t\tP start(i, j);\n\t\t\t\tREP (d, 8) {\n\t\t\t\t\tstring s = \"\";\n\t\t\t\t\tP p(start.Y, start.X);\n\t\t\t\t\tdo {\n\t\t\t\t\t\ts += field[p.Y][p.X];\n\t\t\t\t\t\tif (!EXIST(m, s)) {\n\t\t\t\t\t\t\tm[s] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tm[s]++;\n\n\t\t\t\t\t\tp.Y = (p.Y + dydx8[d].Y + h) % h;\n\t\t\t\t\t\tp.X = (p.X + dydx8[d].X + w) % w;\n\t\t\t\t\t} while (p != start);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstring ans = \"\";\n\t\tEACH (m, itr) {\n\t\t\tstring s = (*itr).first;\n\t\t\tint c = (*itr).second;\n\t\t\tif (c > 1 && s.length() > 2 && s.length() > ans.length()) {\n\t\t\t\tans = s;\n\t\t\t}\n\t\t}\n\n\t\tif (ans == \"\") {\n\t\t\tcout << 0 << endl;\n\t\t} else {\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\nusing namespace std;\n\nint main(){\n  int h,w;\n  string s[10],t;\n  map<string,int> v;\n  while(1){\n    cin>>h>>w;\n    if(!h&&!w) break;\n    for(int i=0;i<h;i++) cin>>s[i];\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tfor(int k=-1;k<=1;k++){\n\t  for(int l=-1;l<=1;l++){\n\t    if(!k&&!l) continue;\n\t    int y=i,x=j;\n\t    t=\"\";\n\t    t+=s[y][x];\n\t    while(1){\n\t      y+=k;\n\t      x+=l;\n\t      if(y<0) y+=h;\n\t      if(x<0) x+=w;\n\t      if(h<=y) y-=h;\n\t      if(w<=x) x-=w;\n\t      if(y==i&&x==j) break;\n\t      t+=s[y][x];\n\t      if(v.find(t)!=v.end()) v[t]++;\n\t      else v.insert(make_pair(t,0));\n\t    }\n\t  }\n\t}\n      }\n    }\n    int ans=0;\n    for(map<string,int>::iterator it=v.begin();it!=v.end();it++){\n      string z=it->first;\n      if(it->second>0&&ans<z.size()) ans=z.size();\n    }\n    if(ans>=2){\n      for(map<string,int>::iterator it=v.begin();it!=v.end();it++)\n\tif(it->second>0&&ans==it->first.size()){\n\t  cout<<it->first<<endl;\n\t  break;\n\t}\n    }else cout<<0<<endl;\n    v.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <map>\n\nusing namespace std;\n\nint h, w;\nchar str[32][32];\n\nint dy[] = {0, 1, 0, -1, 1, -1, 1, -1};\nint dx[] = {1, 0, -1, 0, 1, 1, -1, -1};\n\nvoid generate(int sy, int sx, map<string, int> &rec)\n{\n\tchar tmp[2] = {0, 0};\n\t\n\tfor (int i = 0; i < 8; i++){\n\t\ttmp[0] = str[sy][sx];\n\t\tstring s = tmp;\n\t\tint ny = sy, nx = sx;\n\t\twhile (1){\n\t\t\tny = (ny + h + dy[i]) % h; nx = (nx + w + dx[i]) % w;\n\t\t\tif (ny == sy && nx == sx) break;\n\t\t\ttmp[0] = str[ny][nx];\n\t\t\ts += tmp;\n\t\t\tif (rec.count(s) > 0) rec[s] += 1;\n\t\t\telse rec[s] = 1;\n\t\t}\n\t}\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &h, &w) && h){\n\t\tfor (int i = 0; i < h; i++) scanf(\"%s\", str[i]);\n\t\tmap<string, int> occ;\n\t\t\n\t\tfor (int i = 0; i < h; i++){\n\t\t\tfor (int j = 0; j < w; j++){\n\t\t\t\tgenerate(i, j, occ);\n\t\t\t}\n\t\t}\n\t\t\n\t\tstring ans = \"\";\n\t\tfor (map<string, int>::iterator it = occ.begin(); it != occ.end(); it++){\n\t\t\tif (it->second > 1 && it->first.size() >= ans.size()){\n\t\t\t\tif (it->first.size() > ans.size()) ans = it->first;\n\t\t\t\telse if (it->first.size() == ans.size() && it->first < ans) ans = it->second;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (ans != \"\") printf(\"%s\\n\", ans.c_str());\n\t\telse printf(\"0\\n\");\n\t}\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\nusing namespace std;\n\nchar s[1605][203];\nchar ans[203],sp[203];\nchar mp[11][22];\nint maxv,h,w,indx,mx[8]={1,-1,0,0,1,-1,1,-1},my[8]={0,0,1,-1,1,-1,-1,1};\n\nstruct node\n{\n    int num;\n    node *next[26];\n    node(){num=0;for(int i=0;i<26;i++)next[i]=NULL;}\n};\n\nnode *root;\n\nvoid update(node *head,int i,int j)\n{\n    head->num++;\n    if(s[i][j]=='\\0')return;\n    if(head->next[s[i][j]-'A']==NULL)\n    {\n        head->next[s[i][j]-'A']=new node();\n    }\n    update(head->next[s[i][j]-'A'],i,j+1);\n}\n\nvoid refresh(int depth)\n{\n    if(depth>maxv)\n    {\n        int i;\n        maxv=depth;\n        for(i=0;i<depth;i++)\n        ans[i]=sp[i];\n        ans[i]='\\0';\n    }\n}\n\nvoid dfs(node *head,int depth)\n{\n    if(head==NULL)\n         refresh(depth-1);\n    else if((head->num)<2)\n         refresh(depth-2);\n    else\n    {\n        int i;\n        for(i=0;i<26;i++)\n        {\n            sp[depth]=i+'A';\n            dfs(head->next[i],depth+1);\n        }\n    }\n}\n\nvoid getstr(int x,int y)\n{\n  int i,j,k,p;\n  for(k=0;k<8;k++)\n  {\n      s[indx][0]=mp[x][y];\n      i=x+mx[k];\n      j=y+my[k];\n      i=(i+h)%h;\n      j=(j+w)%w;\n      p=1;\n      while(i!=x||j!=y)\n      {\n          s[indx][p++]=mp[i][j];\n          i+=mx[k];\n          j+=my[k];\n          i=(i+h)%h;\n          j=(j+w)%w;\n      }\n      s[indx][p]='\\0';\n      //cout <<s[indx]<<endl;\n      indx++;\n  }\n}\n\nint main()\n{\n    int i,j;\n    freopen(\"B.out\",\"w\",stdout);\n    while(scanf(\"%d %d\",&h,&w)!=EOF&&(h!=0||w!=0))\n    {\n        root=new node;\n        indx=0;\n        maxv=-1;\n        for(i=0;i<h;i++)\n            scanf(\"%s\",mp[i]);\n        for(i=0;i<h;i++)\n         for(j=0;j<w;j++)\n         {\n             getstr(i,j);\n         }\n        for(i=0;i<indx;i++)update(root,i,0);\n        dfs(root,0);\n        if(strlen(ans)!=1)printf(\"%s\\n\",ans);\n        else printf(\"0\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\nusing namespace std;\nint main(){\n  int h,w;\n  int i,j,k;\n  int ai[]={ 1, 1, 1, 0, 0,-1,-1,-1};\n  int aj[]={ 1, 0,-1, 1,-1, 1, 0,-1};\n  cin >> h >> w;\n  while(h!=0){\n    string str[10];\n    for(i=0;i<h;i++) cin >> str[i];\n    vector <string> li;\n    vector <string> ans;\n    int mal=1;\n    for(i=0;i<h;i++){\n      //cout << i << endl;\n      for(j=0;j<w;j++){\n\tfor(k=0;k<8;k++){\n\t  int bi=i,bj=j;\n\t  string buf;\n\t  buf += str[i][j];\n\t  bi+=ai[k];bj+=aj[k];\n\t  if(bi<0) bi=h-1;\n\t  if(bi>=h) bi=0;\n\t  if(bj<0) bj=w-1;\n\t  if(bj>=w) bj=0;\n\t  while(bi!=i||bj!=j){\n\t    buf+=str[bi][bj];\n\t    if(buf.size()>=mal){\n\t      if(find(li.begin(),li.end(),buf)!=li.end()) {\n\t\tif(buf.size()>mal) ans.clear();\n\t\tans.push_back(buf);\n\t\tmal=buf.size();\n\t      }else{\n\t\tli.push_back(buf);\n\t      }\n\t    }\n\t    bi+=ai[k];bj+=aj[k];\n\t    if(bi<0) bi=h-1;\n\t    if(bi>=h) bi=0;\n\t    if(bj<0) bj=w-1;\n\t    if(bj>=w) bj=0;\n\t  }\n\t}\n      }\n    }\n    //for(i=0;i<li.size();i++) cout << li[i] << endl;\n    sort(ans.begin(),ans.end());\n    //for(i=0;i<ans.size();i++) cout << ans[i] << endl;\n    if(ans.size()!=0) cout << ans[0] << endl;\n    else cout << 0 << endl;\n    cin >> h >> w;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define RREP(i,n) for(ll i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<n;++i)\n#define RFOR(i,m,n) for(ll i=n-1;i>=m;--i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB(a) push_back(a)\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(i, (v).size()) { cout << v[i]; if (i != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(´・ω・`)(´・ω・`)(´・ω・`)(´・ω・`)(´・ω・`)(´・ω・`)///\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile (1) {\n\t\tint h, w;\n\t\tcin >> h >> w;\n\t\tif (!h)break;\n\t\tvector<string> v(h);\n\t\tREP(i, h)cin >> v[i];\n\t\tset<string> st;\n\t\tstring ans = \"\";\n\t\tREP(i, h) {\n\t\t\tREP(j, w) {\n\t\t\t\tREP(k, 8) {\n\t\t\t\t\tint ni = i, nj = j;\n\t\t\t\t\tstring s;\n\t\t\t\t\ts += v[i][j];\n\t\t\t\t\tREP(l, INF) {\n\t\t\t\t\t\tif (!st.insert(s).second) {\n\t\t\t\t\t\t\tif (ans.size() < s.size())ans = s;\n\t\t\t\t\t\t\telse if (ans.size() == s.size() && ans > s)ans = s;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tni = (ni + dx[k] + h) % h, nj = (nj + dy[k] + w) % w;\n\t\t\t\t\t\tif (ni == i&&nj == j)break;\n\t\t\t\t\t\ts += v[ni][nj];\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ans.size() <= 1)cout << 0 << endl;\n\t\telse cout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\nint dx[] = {1, 1, 0, -1, -1, -1, 0, 1};\nint dy[] = {0, 1, 1, 1, 0, -1, -1, -1};\n\nstring best(string a, string b) {\n\tif(a.length() < b.length()) {\n\t\treturn b;\n\t}\n\tif(a.length() == b.length() && b < a) {\n\t\treturn b;\n\t}\n\treturn a;\n}\n\nint main() {\n\tint h, w;\n\twhile(cin >> h >> w, h) {\n\t\tvs field(h);\n\t\tREP(i, h) {\n\t\t\tcin >> field[i];\n\t\t}\n\n\t\tmap<string, int> times;\n\t\tstring ans;\n\t\tREP(i, h) {\n\t\t\tREP(j, w) {\n\t\t\t\tvvi visited(h, vi(w, -1));\n\t\t\t\tREP(d, 8) {\n\t\t\t\t\tstring tmp;\n\t\t\t\t\tint y = i, x = j;\n\t\t\t\t\twhile(visited[y][x] != d) {\n\t\t\t\t\t\ttmp += field[y][x];\n\t\t\t\t\t\tvisited[y][x] = d;\n\t\t\t\t\t\ttimes[tmp]++;\n\t\t\t\t\t\tif(times[tmp] > 1) {\n\t\t\t\t\t\t\tans = best(ans, tmp);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ty = (y+dy[d]+h)%h;\n\t\t\t\t\t\tx = (x+dx[d]+w)%w;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(ans.length() < 2) {\n\t\t\tcout << 0 << endl;\n\t\t} else {\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vb=vector<bool>;\nusing vvb=vector<vb>;\nusing vd=vector<double>;\nusing vvd=vector<vd>;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vl=vector<ll>;\nusing vvl=vector<vl>;\nusing pll=pair<ll,ll>;\nusing tll=tuple<ll,ll>;\nusing tlll=tuple<ll,ll,ll>;\nusing vs=vector<string>;\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define rep(i,n) range(i,0,n)\n#define rrep(i,n) for(ll i=(n)-1;i>=0;i--)\n#define range(i,a,n) for(ll i=(a);i<(n);i++)\n#define LINF ((ll)1ll<<60)\n#define INF ((int)1<<30)\n#define EPS (1e-9)\n#define MOD (1000000007ll)\n#define fcout(a) cout<<setprecision(a)<<fixed\n#define fs first\n#define sc second\n#define PI (3.1415926535897932384)\n\nint dx[]={1,0,-1,0,1,-1,-1,1},dy[]={0,1,0,-1,1,1,-1,-1};\ntemplate<class T>bool chmax(T&a,T b){if(a<b){a=b; return true;}return false;}\ntemplate<class T>bool chmin(T&a,T b){if(a>b){a=b; return true;}return false;}\ntemplate<class S>S sum(vector<S>&a){return accumulate(all(a),S());}\ntemplate<class S>S max(vector<S>&a){return *max_element(all(a));}\ntemplate<class S>S min(vector<S>&a){return *min_element(all(a));}\nll max(int a,ll b){return max((ll)a,b);} ll max(ll a,int b){return max(a,(ll)b);}\nint sgn(const double&r){return (r>EPS)-(r<-EPS);} // a>0  : sgn(a)>0\nint sgn(const double&a,const double&b){return sgn(a-b);} // b<=c : sgn(b,c)<=0\n\ntemplate<class T>void puta(T&&t){cout<<t<<\"\\n\";}\ntemplate<class H,class...T>void puta(H&&h,T&&...t){cout<<h<<' ';puta(t...);}\ntemplate<class S,class T>void tf(bool b,S t,T f){if(b)puta(t);else puta(f);}\nvoid YN(bool b){tf(b,\"YES\",\"NO\");}\nvoid Yn(bool b){tf(b,\"Yes\",\"No\");}\nvoid yn(bool b){tf(b,\"yes\",\"no\");}\ntemplate<class S,class T>ostream&operator<<(ostream&os,pair<S,T>p){os<<\"[\"<<p.first<<\", \"<<p.second<<\"]\";return os;};\ntemplate<class S>auto&operator<<(ostream&os,vector<S>t){bool a=1;for(auto s:t){os<<(a?\"\":\" \")<<s;a=0;}return os;}\ntemplate<class S>auto&operator>>(istream&is,vector<S>&t){for(S&a:t)cin>>a;return is;}\n\n/*他のライブラリを入れる場所*/\n\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll n,m;\n    while(cin>>n>>m, n){\n        vs f(n);cin>>f;\n        vs ss;\n        rep(i,n)rep(j,m){\n            for(auto vy:vl{n-1,0,1})for(auto vx:vl{m-1,0,1})if(vy or vx){\n                vvb v=vvb(n,vb(m,false));\n                string s = \"\";\n                ll y=i, x=j;\n                while(!v[y][x]){\n                    s+=f[y][x];\n                    v[y][x]=true;\n                    y=(y+vy)%n;\n                    x=(x+vx)%m;\n                }\n                ss.push_back(s+\"/\");\n            }\n        }\n        sort(all(ss));\n        vs sss;\n        sss.push_back(\"0\");\n\n        rep(i,ss.size()-1){\n            rep(j, min(ss[i].size(), ss[i+1].size())){\n                if(ss[i][j]!=ss[i+1][j] or ss[i][j]=='/'){\n                    sss.push_back(ss[i].substr(0,j));\n                    break;\n                }\n            }\n        }\n        sort(all(sss), [](string a, string b){return a.size()>b.size() or (a.size()==b.size() and a<b);});\n        puta(sss[0]);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint H, W; string s[11];\nint main() {\n\twhile (cin >> H >> W, H | W) {\n\t\tfor (int i = 0; i < H; i++) cin >> s[i];\n\t\tvector<string> res;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tfor (int dy = -1; dy <= 1; dy++) {\n\t\t\t\t\tfor (int dx = -1; dx <= 1; dx++) {\n\t\t\t\t\t\tif (dx == 0 && dy == 0) continue;\n\t\t\t\t\t\tstring now;\n\t\t\t\t\t\tint tx = (j + dx + W) % W, ty = (i + dy + H) % H;\n\t\t\t\t\t\tnow += s[ty][tx];\n\t\t\t\t\t\twhile (tx != j || ty != i) {\n\t\t\t\t\t\t\ttx = (tx + dx + W) % W, ty = (ty + dy + H) % H;\n\t\t\t\t\t\t\tnow += s[ty][tx];\n\t\t\t\t\t\t\tres.push_back(now);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(res.begin(), res.end());\n\t\tstring ret;\n\t\tint pre = 0;\n\t\tfor (int i = 1; i <= res.size(); i++) {\n\t\t\tif (i == res.size() || res[i - 1] != res[i]) {\n\t\t\t\tif (i - pre > 1) {\n\t\t\t\t\tif (ret.size() < res[pre].size() || (ret.size() == res[pre].size() && ret > res[pre])) {\n\t\t\t\t\t\tret = res[pre];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpre = i;\n\t\t\t}\n\t\t}\n\t\tif(ret.size() > 1) cout << ret << endl;\n\t\telse cout << 0 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nint n,m;\nstring donut[15];\nset<string> check;\n\nint dx[8]={1,1,1,0,-1,-1,-1,0};\nint dy[8]={1,0,-1,-1,-1,0,1,1};\n\nvoid longest(string &res,string in){\n\tif(in.size()>res.size())\n\t\tres=in;\n\tif(in.size()==res.size()&&in<res)\n\t\tres=in;\n}\n\nstring solve(){\n\tstring res=\"\";\n\trep(i,n)rep(j,m)rep(k,8){\n\t\tstring cur=\"\";\n\t\tcur+=donut[i][j];\n\t\tint ci=(i+dx[k]+n)%n,cj=(j+dy[k]+m)%m;\n\t\twhile(ci!=i||cj!=j){\n\t\t\tcur+=donut[ci][cj];\n\t\t\tif(check.find(cur)!=check.end())\n\t\t\t\tlongest(res,cur);\n\t\t\telse\n\t\t\t\tcheck.insert(cur);\n\t\t\tci=(ci+dx[k]+n)%n,cj=(cj+dy[k]+m)%m;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(void){\n\twhile(cin >> n >> m){\n\t\trep(i,n) cin >> donut[i];\n\t\tif(n==0)\n\t\t\tbreak;\n\t\tcheck.clear();\n\t\tstring ans=solve();\n\t\tif(ans==\"\")\n\t\t\tcout << 0 << endl;\n\t\telse\n\t\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <string>\n#include <algorithm>\n\n#define MAX 22\n\nusing namespace std;\n\nchar f[MAX][MAX];\nint dx[8]={1,1,0,-1,-1,-1,0,1};   //右から\nint dy[8]={0,1,1,1,0,-1,-1,-1};\n\nint main(void)\n{\n\tint h,w;\n\tint i1,i2,i3;\n\tint x,y;\n\tstring s;\n\tint len;\n\n\twhile(1){\n\t\tcin>>h>>w;\n\t\tif(h+w==0) break;\n\n\t\tfor(i1=0;i1<h;i1++){\n\t\t\tfor(i2=0;i2<w;i2++){\n\t\t\t\tcin>>f[i1][i2];\n\t\t\t}\n\t\t}\n\n\n\t\tset<string> p;\n\t\tset<string> ok;\n\t\tlen=0;\n\n\t\tfor(i1=0;i1<h;i1++){\n\t\t\tfor(i2=0;i2<w;i2++){\n\t\t\t\tfor(i3=0;i3<8;i3++){\n\t\t\t\t\tx=i2;\n\t\t\t\t\ty=i1;\n\t\t\t\t\ts=\"\";\n\t\t\t\t\twhile(1){\n\n\t\t\t\t\t\ts+=f[y][x];\n\t\t\t\t\t\tif(s.size()!=1 && p.find(s)!=p.end()) {\n\t\t\t\t\t\t\tok.insert(s);\n\t\t\t\t\t\t\tlen=max(len,(int)s.size());\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse p.insert(s);\n\t\t\t\t\t\t\n\t\t\t\t\t\tx+=dx[i3];\n\t\t\t\t\t\ty+=dy[i3];\n\t\t\t\t\t\tif(x==w) x=0;\n\t\t\t\t\t\tif(y==h) y=0;\n\t\t\t\t\t\tif(x==-1) x=w-1;\n\t\t\t\t\t\tif(y==-1) y=h-1; \n\n\t\t\t\t\t\tif(x==i2 && y==i1) break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tset<string>::iterator it;\n\t\tset<string> ans;\n\t\t\n\t\tfor(it=ok.begin();it!=ok.end();it++){\n\t\t\tif(len==(*it).size()) ans.insert((*it));\n\t\t}\n\t\t\n\t\tif(ans.empty()) cout<<\"0\"<<endl;\n\t\telse cout<<(*ans.begin())<<endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\n#include <type_traits>\n#include <mutex>\n#include <array>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\ntypedef unsigned int uint;\ntypedef long long llong;\ntypedef unsigned long long ullong;\n#define long long long\n\n#define EPS 1e-9\n#define INF (1L << 28)\n#define LINF (1LL << 60)\n\n#define PREDICATE(t,a,exp) [&](const t & a) -> bool { return exp; }\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b,exp) [&](const t & a, const t & b) -> bool { return exp; }\n#define CONVERTER(TSrc,t,TDest,exp) [&](const TSrc &t)->TDest { return exp; }\n\n#define PRED(a,exp) [&](const auto & a) -> bool { return exp; }\n#define COMP(a,b,exp) [&](const auto & a, const auto & b) -> bool { return exp; }\n\ninline int sign_of(double x) { return abs(x) < EPS ? 0 : x > 0 ? 1 : -1; }\ninline bool inRange(int val, int min, int max) { return val >= min && val < max; }\ninline bool inRange(double val, double min, double max) { return val - min > -EPS && val - max < EPS; }\ninline bool inRange(int x, int y, int W, int H) { return x >= 0 && x < W && y >= 0 && y < H; } // W,H含まない\n\ntemplate <class T> struct vevector : public vector<vector<T>> { vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { } };\ntemplate <class T> struct vevevector : public vector<vevector<T>> { vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { } };\ntemplate <class T> struct vevevevector : public vector<vevevector<T>> { vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { } };\n\n//// i/o helper ////\n\nnamespace std {\n\ttemplate <class T1, class T2> inline istream & operator >> (istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\n\ttemplate <class T1, class T2> inline ostream & operator << (ostream &out, const pair<T1, T2> &p) { out << p.first << \" \" << p.second; return out; }\n}\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; v.reserve(n); REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; v.reserve(n); REP(i, n) v.push_back(readjag<T>()); return v; }\n\ntemplate <class T> struct iter_pair_t { T beg, end; };\ntemplate <class T> iter_pair_t<T> iter_pair(T beg, T end) { return iter_pair_t<T>{beg, end}; }\ntemplate <class T> ostream & operator << (ostream &out, const iter_pair_t<T> &v)\n{\n\tstd::copy(v.beg, v.end, ostream_iterator<typename decltype(v.beg)::reference>(out, \" \"));\n\treturn out;\n}\ntemplate <class T1> ostream & operator << (ostream &out, const vector<T1> &v) { return out << iter_pair(begin(v), end(v)); }\ntemplate <class T1> ostream & operator << (ostream &out, const set<T1> &v) { return out << iter_pair(begin(v), end(v)); }\ntemplate <class T1, class T2> ostream & operator << (ostream &out, const map<T1, T2> &v) { return out << iter_pair(begin(v), end(v)); }\n\nstruct _Reader { istream &cin; template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\nstruct _Writer { ostream &cout; bool f{ false }; template <class T> _Writer operator ,(const T &rhs) { cout << (f ? \" \" : \"\") << rhs; f = true; return *this; } };\n#define READ(t,...) t __VA_ARGS__; (_Reader{cin}), __VA_ARGS__\n#define WRITE(...) (_Writer{cout}), __VA_ARGS__; cout << '\\n'\n#define DEBUG(...) (_Writer{cerr}), __VA_ARGS__; cerr << '\\n'\n\nvoid solve();\nint main()\n{\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\n\t//auto temp = ctype<char>::classic_table();\n\t//vector<ctype<char>::mask> bar(temp, temp + ctype<char>::table_size);\n\t//bar[':'] |= ctype_base::space;\n\t//cin.imbue(locale(cin.getloc(), new ctype<char>(bar.data())));\n\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tcout << fixed;\n\tcout << setprecision(std::numeric_limits<double>::max_digits10);\n\tsolve();\n\n\treturn 0;\n}\n\n/// サイコロの出目の合計値の確率\n// retval[n] = 等確率に出目が出るサイコロ xi を N 回振って出目の合計値が n となる確率\nvector<double> xicolo_sum_prob(\n\tint N,\n\tconst vector<int> &xi = vector<int>{ 1, 2, 3, 4, 5, 6 },\n\tconst vector<double> &initial = vector<double>(1, 1))\n{\n\tint maxN = *max_element(allof(xi));\n\tauto dp = initial;\n\tREP(i, N)\n\t{\n\t\tvector<double> next(dp.size() + maxN);\n\t\tREP(i, dp.size())\n\t\t{\n\t\t\tfor (auto x : xi)\n\t\t\t{\n\t\t\t\tnext[i + x] += dp[i] / xi.size();\n\t\t\t}\n\t\t}\n\t\tdp.swap(next);\n\t}\n\treturn dp;\n}\n\n////////////////////\n/// template end ///\n////////////////////\n\nvoid solve()\n{\n\twhile (true)\n\t{\n\t\tREAD(int, R, C);\n\t\tif (!R) { break; }\n\t\tauto s = read<string>(R);\n\n\t\tint dx[] = { -1,0,1, -1, 1, -1,0,1 };\n\t\tint dy[] = { -1,-1,-1, 0, 0, 1,1,1 };\n\n\t\tstd::map<string, int> mp;\n\t\tvevevector<string> val(R, C, 8);\n\t\tvevevector<bool> ol(R, C, 8);\n\n\t\tREP(r, R) REP(c, C) REP(d, 8) {\n\t\t\tval[r][c][d].reserve(R * C);\n\t\t\tval[r][c][d] += s[r][c];\n\t\t}\n\n\t\tFOR(i, 1, R * C)\n\t\t{\n\t\t\tREP(r, R) REP(c, C) REP(d, 8)\n\t\t\t{\n\t\t\t\tif (!ol[r][c][d])\n\t\t\t\t{\n\t\t\t\t\tint x = (c + dx[d] * i + C * 100) % C;\n\t\t\t\t\tint y = (r + dy[d] * i + R * 100) % R;\n\t\t\t\t\tif (x == c && y == r)\n\t\t\t\t\t{\n\t\t\t\t\t\tol[r][c][d] = true;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tval[r][c][d] += s[y][x];\n\t\t\t\t\t\tif (i > 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmp[val[r][c][d]]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstring maxSpell = \"0\";\n\t\tfor (const auto &p : mp)\n\t\t{\n\t\t\tif (p.second >= 2 && p.first.size() > maxSpell.size())\n\t\t\t{\n\t\t\t\tmaxSpell = p.first;\n\t\t\t}\n\t\t}\n\n\t\tWRITE(maxSpell);\n\t}\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-11L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n\n#define MOD 998244353LL\n#define seg_size 262144*2LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\nunsigned long xor128() {\n\tstatic unsigned long x = 123456789, y = 362436069, z = 521288629, w = time(NULL);\n\tunsigned long t = (x ^ (x << 11));\n\tx = y; y = z; z = w;\n\treturn (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\nvoid init() {\n\tiostream::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n}\n\n#define int ll\n\nvoid solve() {\n\twhile (true) {\n\t\tint h, w;\n\t\tcin >> h >> w;\n\t\tif (h == 0) return;\n\t\tvector<string> inputs;\n\t\tREP(i, h) {\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tinputs.push_back(s);\n\t\t}\n\t\tmap<string, int> cnter;\n\t\tREP(i, h) {\n\t\t\tREP(q, w) {\n\t\t\t\tint dx[3] = { 1,0,-1 };\n\t\t\t\tREP(j, 3) {\n\t\t\t\t\tREP(t, 3) {\n\t\t\t\t\t\tif (j == 1 && t == 1) continue;\n\t\t\t\t\t\tpair<int, int> now = mp(i, q);\n\t\t\t\t\t\tstring s;\n\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\ts.push_back(inputs[now.first][now.second]);\n\t\t\t\t\t\t\tnow.first += dx[j];\n\t\t\t\t\t\t\tnow.second += dx[t];\n\t\t\t\t\t\t\tnow.first += h;\n\t\t\t\t\t\t\tnow.second += w;\n\t\t\t\t\t\t\tnow.first %= h;\n\t\t\t\t\t\t\tnow.second %= w;\n\t\t\t\t\t\t\tcnter[s]++;\n\t\t\t\t\t\t\tif (now.first == i && now.second == q) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//cout << cnter[\"ABRACADABRA\"] << endl;\n\t\tstring ans = \"0\";\n\t\tfor (auto x : cnter) {\n\t\t\tif (x.second >= 2) {\n\t\t\t\tif (ans.length() < x.first.length()) {\n\t\t\t\t\tans = x.first;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\n#undef int\nint main() {\n\tinit();\n\tsolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 310;\nconst int dx[] = {0, 1, 0, -1, 1, 1, -1, -1};\nconst int dy[] = {1, 0, -1, 0, 1, -1, 1, -1};\n\nint ch[400000][26];\nint sz;\nchar mz[22][22];\nchar str[N], ans[N];\nint la;\nint n, m;\n\nvoid getstr(int sx, int sy, int d, char *s) {\n    int len = 0;\n    int x = sx, y = sy;\n    do {\n        s[len++] = mz[x][y];\n        x += dx[d]; x = (x + n) % n;\n        y += dy[d]; y = (y + m) % m;\n    } while (x != sx || y != sy);\n    s[len] = 0;\n}\n\nchar t[N];\nint lt;\nvoid insert(char *s) {\n//puts(s);\n    int u = 0;\n    t[lt = 0] = 0;\n    bool ok = true;\n    for (int i = 0; s[i]; i++) {\n        int d = s[i] - 'A';\n        if (ch[u][d] == 0) {\n            memset(ch[sz], 0, sizeof(ch[sz]));\n            ch[u][d] = sz++;\n            ok = false;\n        }\n        u = ch[u][d];\n        if (ok) {\n            t[lt++] = s[i]; t[lt] = 0;\n        }\n    }\n}\n\nvoid work() {\n    memset(ch[0], 0, sizeof(ch[0]));\n    sz = 1;\n    for (int i = 0; i < n; i++) scanf(\"%s\", mz[i]);\n    ans[la = 0] = 0;\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < m; j++) {\n            for (int d = 0; d < 8; d++) {\n                getstr(i, j, d, str);\n                insert(str);\n                if (lt > la) {\n                    la = lt;\n                    strcpy(ans, t);\n                } else if (lt == la && strcmp(t, ans) < 0) {\n                    strcpy(ans, t);\n                }\n            }\n        }\n    if (la <= 1) puts(\"0\");\n    else puts(ans);\n}\n\nint main() {\n//freopen(\"data.in\", \"r\", stdin);\n//freopen(\"data.out\", \"w\", stdout);\n    while (scanf(\"%d%d\", &n, &m), n || m) {\n        work();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nint H,W;\nbool visited[25][25];\nchar field[25][25];\nmap<string,int> mp;\nconst int dx[] = {-1,-1,-1,0,0,1,1,1};\nconst int dy[] = {-1,0,1,-1,1,-1,0,1};\n \nvoid rec(int x,int y,int d,string s){\n    if(visited[y][x]) return;\n    visited[y][x] = true;\n    int nx = (x + dx[d] + W) % W;\n    int ny = (y + dy[d] + H) % H;\n    mp[s+field[y][x]]++;\n    rec(nx,ny,d,s+field[y][x]);\n}\n \nint main(){\n    while(cin >> H >> W, H){\n\tmp.clear();\n\tfor(int i = 0 ; i < H ; i++){\n\t    for(int j = 0 ; j < W ; j++){\n\t\tcin >> field[i][j];\n\t    }\n\t}\n\tfor(int i = 0 ; i < H ; i++){\n\t    for(int j = 0 ; j < W ; j++){\n\t\tfor(int k = 0 ; k < 8 ; k++){\n\t\t    memset(visited,false,sizeof(visited));\n\t\t    rec(j,i,k,\"\");\n\t\t}\n\t    }\n\t}\n\tint ans_size = -1;\n\tstring ans;\n\tmap<string,int>::iterator it;\n\tfor(it = mp.begin() ; it != mp.end() ; ++it){\n\t    int size = it->first.size();\n\t    if(it->second < 2 || size < 2) continue;\n\t    if(ans_size < size){\n\t\tans_size = size;\n\t\tans = it->first;\n\t    }\n\t}\n\tif(ans_size == -1){\n\t    cout << 0 << endl;\n\t}else{\n\t    cout << ans << endl;\n\t}\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * GCA : \"Computer is artificial subject absolutely,Math is God\"\n */\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <cctype>\n#include <utility>\n#include <ctime>\nusing namespace std;\n#ifdef DEBUG\n#define VAR(a,b) __typeof(b) a=(b)\n#define debug(...) printf(\"DEBUG: \"),printf(__VA_ARGS__)\n#else\n#define VAR(a,b) __typeof(b) a=(b)\n#define debug(...)\n#endif\ntypedef unsigned int uint;\ntypedef long long int Int;\ntypedef unsigned long long int UInt;\n#define Set(a,s) memset(a,s,sizeof(a))\n#define Pln() printf(\"\\n\")\n#define For(i,x)for(int i=0;i<x;i++)\n#define CON(x,y) x##y\n#define M 25\n#define PB push_back\n#define oo INT_MAX\n#define FOR(a,b) for(VAR(a,(b).begin());a!=(b).end();++a)\n#define eps 1e-9\n#define X first\n#define Y second\ninline bool xdy(double x,double y){return x>y+eps;}\ninline bool xddy(double x,double y){return x>y-eps;}\ninline bool xcy(double x,double y){return x<y-eps;}\ninline bool xcdy(double x,double y){return x<y+eps;}\nconst Int mod=1000000007;\nint nx,ny;\nchar mz[M][M];\nset<Int> sid;\nint dx[8]={0,1,1,1,0,-1,-1,-1};\nint dy[8]={1,1,0,-1,-1,-1,0,1};\nchar store[M*M];\nint ox,oy;\nstring ans;\nInt isid;\nbool vis[M][M];\nvoid dfs(int x,int y,int d,int dep){\n\n\tstore[dep]=mz[y][x];\n\tint nex=(x+dx[d]+nx)%nx;\n\tint ney=(y+dy[d]+ny)%ny;\n\tstore[dep+1]=0;\n\tisid=130*isid+store[dep];\n\tstring ss(store);\n\tif(sid.count(isid)&&ss.length()>=2){\n\t\tif(ss.length()>ans.length())ans=ss;\n\t\telse if(ss.length()==ans.length()&&ss<ans){\n\t\t\tans=ss;\n\t\t}\n\t}\n\tsid.insert(isid);\n\tvis[x][y]=1;\n\tif(!vis[nex][ney])dfs(nex,ney,d,dep+1);\n\tvis[x][y]=0;\n\n}\nvoid solve(){\n\tSet(vis,0);\n\tfor(int i=0;i<ny;i++){\n\t\tfor(int j=0;j<nx;j++){\n\t\t\tfor(int k=0;k<8;k++){\n\t\t\t\tisid=0;\n\t\t\t\tvis[j][i]=1;\n\t\t\t\tdfs(j,i,k,0);\n\t\t\t\tvis[j][i]=0;\n\t\t\t}\n\t\t}\n\t}\n\tif(ans.size())\n\t\tputs(ans.c_str());\n\telse puts(\"0\");\n}\nint main() {\n\tios_base::sync_with_stdio(0);\n\twhile(~scanf(\"%d%d\",&ny,&nx)&&ny&&nx){\n\t\tsid.clear();\n\t\tans=\"\";\n\t\tfor(int i=0;i<ny;i++)scanf(\"%s\",mz[i]);\n\t\tsolve();\n\n\t}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <set>\n#include <functional>\n\nusing namespace std;\n\nusing lint = long long;\nusing ldouble = long double;\n\nconst vector<int> dx({-1, -1, -1, 0, 0, 1, 1, 1});\nconst vector<int> dy({-1, 0, 1, -1, 1, -1, 0, 1});\n\nbool solve() {\n    int h, w;\n    cin >> h >> w;\n    if (h == 0) return false;\n\n    vector<string> torus(h);\n    for (auto& s : torus) cin >> s;\n\n    string ans = \"0\";\n    set<string> app;\n\n    function<void(int, int, int, vector<vector<bool>>&, string)> dfs =\n        [&](int x, int y, int d, vector<vector<bool>>& used, string s) {\n            if (used[x][y]) return;\n            used[x][y] = true;\n\n            s.push_back(torus[x][y]);\n            if (s.length() > 1 && app.count(s) &&\n                ((ans.length() < s.length()) ||\n                 (ans.length() == s.length() && s < ans))) {\n                ans = s;\n            }\n            app.insert(s);\n\n            x = (x + dx[d] + h) % h;\n            y = (y + dy[d] + w) % w;\n            dfs(x, y, d, used, s);\n        };\n\n    for (int x = 0; x < h; ++x) {\n        for (int y = 0; y < w; ++y) {\n            for (int d = 0; d < 8; ++d) {\n                vector<vector<bool>> used(h, vector<bool>(w, false));\n                dfs(x, y, d, used, \"\");\n            }\n        }\n    }\n\n    cout << ans << endl;\n    return true;\n}\n\nint main() {\n    while (solve()) {}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <iostream>\n#include <map>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint h,w;\nstring fie[11];\nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,1,-1};\nmap<string,int> cnt;\nbool used[11][21];\nvector<string> index;\n\nvoid dfs(int y,int x,int k,string str){\n\tif(used[y][x])return;\n\tused[y][x]=true;\n\tstr+=fie[y][x];\n\tcnt[str]++;\n\tindex.push_back(str);\n\tdfs((y+dy[k]+h)%h,(x+dx[k]+w)%w,k,str);\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&h,&w);\n\t\tif(h+w==0)break;\n\t\tcnt.clear();\n\t\tindex.clear();\n\t\tfor(int i=0;i<h;i++){\n\t\t\tcin >> fie[i];\n\t\t}\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tfor(int k=0;k<8;k++){\n\t\t\t\t\tmemset(used,false,sizeof(used));\n\t\t\t\t\tdfs(i,j,k,\"\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(index.begin(),index.end());\n\t\tindex.erase(unique(index.begin(),index.end()),index.end());\n\t\tstring res=\"0\";\n\t\tfor(int i=0;i<index.size();i++){\n\t\t\tif(cnt[index[i]]>=2 && index[i].size()>=2){\n\t\t\t\tif(res.size()<index[i].size() || (res.size()==index[i].size() && index[i]<res)){\n\t\t\t\t\tres=index[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int dy[] = {-1, -1, -1, 0, 1, 1, 1, 0};\nconst int dx[] = {-1, 0, 1, 1, 1, 0, -1, -1};\n\nint W, H;\nstring S[10];\nmap< string, int > sss;\n\nvoid dfs(string T, int y, int x, const int sy, const int sx, const int dir)\n{\n  if(!T.empty() && y == sy && x == sx) return;\n  sss[T + S[y][x]]++;\n  dfs(T + S[y][x], (y + dy[dir] + H) % H, (x + dx[dir] + W) % W, sy, sx, dir);\n}\n\nbool compare(const string& x, const string& y)\n{\n  if(x.size() != y.size()) return(x.size() > y.size());\n  return(x < y);\n}\n\nint main()\n{\n  while(cin >> H >> W, H) {\n    for(int i = 0; i < H; i++) {\n      cin >> S[i];\n    }\n    for(int i = 0; i < H; i++) {\n      for(int j = 0; j < W; j++) {\n        for(int k = 0; k < 8; k++) dfs(\"\", i, j, i, j, k);\n      }\n    }\n    string S = \"\";\n    for(auto it : sss) {\n      if(it.second >= 2) S = min(S, it.first, compare);\n    }\n    if(S.size() == 1) cout << 0 << endl;\n    else cout << S << endl;\n    sss.clear();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\nusing namespace std;\nint dx[8] = {0,1,1,1,0,-1,-1,-1};\nint dy[8] = {1,1,0,-1,-1,-1,0,1};\nint main(){\n  int h,w;\n  while(cin>>h>>w,h){\n    vector<string> s(h);\n    for(int i = 0;i < h;i++){\n      cin>>s[i];\n    }\n    map<string,int> mp;\n    for(int i = 0;i < h;i++){\n      for(int j = 0;j < w;j++){\n\tfor(int d = 0;d < 8;d++){\n\t  int y = i, x = j;\n\t  string tmps = \"\";\n\t  tmps += s[i][j];\n\t  while(true){\n\t    int ny = (y+dy[d] + h)%h, nx = (x+dx[d] + w)%w;\n\t    if(ny == i && nx == j){\n\t      break;\n\t    }else{\n\t      tmps+=s[ny][nx];\n\t      mp[tmps]++;\n\t      x=nx,y=ny;\n\t    }\n\t  }\n\t}\n      }\n    }\n    string ans;\n    int maxsize = 0;\n    for(auto itr = mp.begin();itr!=mp.end();itr++){\n      if(itr->second >= 2 && itr->first.size() > maxsize){\n\tans = itr->first;\n\tmaxsize = itr->first.size();\n      }\n    }\n    if(maxsize)cout << ans << endl;\n    else cout << 0 << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint gcd(int a, int b){\n    while(a != b){\n        if(a > b) a = a - b; else b = b - a;\n    }\n    return a;\n}\n\nint lcm(int a, int b){\n    return ((a / gcd(a, b)) * b);\n}\n\nint main(){\n    int h, w;\n    while(true){\n        char torus[10][20];\n        string str[2048];\n        bool ok[2048];\n        int num = 0;\n\n        for(int i=0; i<2048; ++i){\n            str[i] = \"\";\n            ok[i] = true;\n        }\n\n        cin >> h >> w;\n        if(h==0 && w==0) break;\n\n        int cml = lcm(w, h);\n\n        for(int i=0; i<h; ++i){\n            for(int j=0; j<w; ++j){\n                cin >> torus[i][j];\n            }\n        }\n\n        //一番長い文字列をつくる\n\n        for(int y=0; y<h; ++y){\n            for(int x=0; x<w; ++x){\n                for(int i=0; i<h; ++i){\n                    str[num] += torus[(y+i)%h][x];\n                    str[num+1] += torus[h-(y+i)%h-1][x];\n                }\n                num += 2;\n            }\n        }\n        for(int y=0; y<h; ++y){\n            for(int x=0; x<w; ++x){\n                for(int i=0; i<w; ++i){\n                    str[num] += torus[y][(x+i)%w];\n                    str[num+1] += torus[y][w-(x+i)%w-1];\n                }\n                num += 2;\n            }\n        }\n        for(int y=0; y<h; ++y){\n            for(int x=0; x<w; ++x){\n                for(int i=0; i<cml; ++i){\n                    str[num] += torus[(y+i)%h][(x+i)%w];\n                    str[num+1] += torus[(y+i)%h][w-(x+i)%w-1];\n                    str[num+2] += torus[h-(y+i)%h-1][(x+i)%w];\n                    str[num+3] += torus[h-(y+i)%h-1][w-(x+i)%w-1];\n                }\n                num += 4;\n            }\n        }\n\n\n        vector<char> result;\n\n        sort(str, str+num);\n\n        for(int i=num-1; i>0; --i){\n            int length = 0;\n            vector<char> k;\n            for(int j=0; j<min(str[i].length(), str[i-1].length()); ++j){\n                if(str[i][j] == str[i-1][j]) k.push_back(str[i][j]); else break;\n            }\n            if(k.size() >= result.size()){\n                result = k;\n            }\n        }\n\n        if(result.size() == 1){\n            cout << \"0\" << endl;\n        }else{\n            vector<char>::iterator it = result.begin();\n            while( it != result.end()){\n                cout << *it;\n                ++it;\n            }\n            cout << endl;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint h, w;\nvoid solve(int y, int x, vector<string> const& v, vector<string>& ret) {\n    int dx[8] = {0, 1, 1, 1, 0, -1, -1, -1},\n        dy[8] = {-1, -1, 0, 1, 1, 1, 0, -1};\n    for(int i=0; i<8; ++i) {\n        string s;\n        vector<vector<bool>> used(h, vector<bool>(w, false));\n        while(!used[y][x]) {\n            s += v[y][x];\n            used[y][x] = true;\n            x = (x + dx[i] + w)%w;\n            y = (y + dy[i] + h)%h;\n            if(s.size() >= 2) {\n                ret.push_back(s);\n            }\n        }\n    }\n}\n\nint main() {\n    while(cin >> h >> w, h) {\n        vector<string> v(h);\n        vector<string> ret;\n        for(int i=0; i<h; ++i) {\n            cin >> v[i];\n        }\n        for(int i=0; i<h; ++i) {\n            for(int j=0; j<w; ++j) {\n                solve(i, j, v, ret);\n            }\n        }\n        sort(ret.begin(), ret.end());\n        string ret2;\n        for(int i=0; i<ret.size()-1; ++i) {\n            if(ret[i] == ret[i+1]) {\n                if(ret2.size() < ret[i].size() || ret2.size() == ret[i].size() && ret2 > ret[i]) {\n                    ret2 = ret[i];\n                }\n            }\n        }\n        if(ret2.size() == 0) {\n            cout << 0 << endl;\n        } else {\n            cout << ret2 << endl;\n        }\n    }   \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <set>\n#include <vector>\n#include <utility>\nusing namespace std;\n\nset<string> Ws;\nset<string> W;\n\nconst int dx[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy[8] = {1, 0, -1, 1, -1, 1, 0, -1};\n\ntypedef pair<int, string> spell;\n\nint main() {\n  int h, w;\n  while (scanf(\"%d%d\", &h, &w) != EOF && w) {\n    Ws.clear();\n    vector< vector<char> > table = vector< vector<char> >(h, vector<char>(w));\n    for (auto i=0; i<h; i++) {\n      for (auto j=0; j<w; j++) {\n\tscanf(\" %c\", &table[i][j]);\n      }\n    }\n    string MS = \"\";\n    int MSsize = 0;\n    spell A = make_pair(-1*MSsize, MS);\n    for (auto i=0; i<h; i++) {\n      for (auto j=0; j<w; j++) {\n\tW.clear();\n\tfor (auto d=0; d<8; d++) {\n\t  string S = \"\";\n\t  S += table[i][j];\n\t  vector< vector<bool> > visited \n\t    = vector< vector<bool> >(h, vector<bool>(w, false));\n\t  visited[i][j] = true;\n\t  int ni, nj;\n\t  for (auto k=1; \n\t       !visited[(ni = (h*w+i+dx[d]*k)%h)][(nj = (h*w+j+dy[d]*k)%w)];\n\t       k++) {\n\t    visited[ni][nj] = true;\n\t    S += table[ni][nj];\n\t    // cerr << S << endl;\n\t    W.insert(S);\n\t  }\n\t}\n\tfor (auto k=W.begin(); k != W.end(); k++) {\n\t  string S;\n\t  if (Ws.find((S = *k)) != Ws.end()) {\n\t    spell t;\n\t    if ((t = make_pair(-1*(int)(S.size()), S)) < A) A = t;\n\t  } else {\n\t    Ws.insert(S);\n\t  }\n\t}\n      }\n    }\n    cout << (A.second == \"\" ? \"0\" : A.second) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <fstream>\n#include <cassert>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> PI;\n#define EPS (1e-6)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i, n) rep (i, n)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define min3(a,b,c) min((a),min((b),(c)))\n#define min4(a,b,c,d) min((a),min3((b),(c),(d)))\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FLL(a,b) memset((a),b,sizeof(a))\n#define CLR(a) memset((a),0,sizeof(a))\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\ntemplate<typename T,typename U> ostream& operator<< (ostream& out, const pair<T,U>& val){return out << \"(\" << val.F << \", \" << val.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& out, const vector<T>& val){out << \"{\";rep(i,SZ(val)) out << (i?\", \":\"\") << val[i];return out << \"}\";}\ntypedef double FP;\ntypedef complex<FP> pt;\ntypedef pt P;\ntypedef pair<pt,pt> line;\nFP dot(P a,P b){return real(conj(a)*b);}\nFP crs(P a,P b){return imag(conj(a)*b);}\nP ortho(P a){return conj(P(imag(a),real(a)));}\nP ortho(line a){return ortho(a.S-a.F);}\nP crspt(P a,P b,P c,P d){b-=a,d-=c;return a+b*crs(d,c-a)/crs(d,b);}\nP crspt(line a,line b){return crspt(a.F,a.S,b.F,b.S);}\nbool onl(P a1,P a2,P b){return abs(b-a1)+abs(b-a2)<abs(a1-a2)+EPS;}\nbool onl(line a,P b){return onl(a.F,a.S,b);}\nbool iscrs(line a,line b){P c=crspt(a,b);return onl(a,c)&&onl(b,c);}\nvoid pkuassert(bool t){t=1/t;};\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\nenum{TOP,BTM,LFT,RGT,FRT,BCK};\nint dxdy2ce[]={RGT,FRT,LFT,BCK};\ntemplate<class T> T shift(T a,int b,int c,int d,int e){\n __typeof(a[0])t=a[b];a[b]=a[c];a[c]=a[d];a[d]=a[e];a[e]=t;\n return a;}\ntemplate<class T> T rgt(T a){return shift(a,TOP,LFT,BTM,RGT);}\ntemplate<class T> T lft(T a){return shift(a,TOP,RGT,BTM,LFT);}\ntemplate<class T> T frt(T a){return shift(a,TOP,BCK,BTM,FRT);}\ntemplate<class T> T bck(T a){return shift(a,TOP,FRT,BTM,BCK);}\nline mkl(P a,P v){return line(a,a+v);}\nFP lpdist(line a,P b){return abs(b-crspt(a,mkl(b,ortho(a))));}\nFP spdist(line a,P b){\n  P c(crspt(a,mkl(b,ortho(a))));\n  return onl(a,c)?abs(b-c):min(abs(a.F-b),abs(a.S-b));\n}\nFP ssdist(line a,line b){\n return\n  iscrs(a,b)?0.:\n   min4(spdist(a,b.F),spdist(a,b.S),\n        spdist(b,a.F),spdist(b,a.S));\n}\nnamespace std{\n  bool operator<(const P&a,const P&b){\n    return mp(real(a),imag(a))<mp(real(b),imag(b));\n  }\n}\n\nint main(int argc, char *argv[])\n{\n  int R, C;\n  while(cin >> R >> C, C) {\n    char A[30][30] = {};\n    rep(i, R) rep(j, C) cin >> A[i][j];\n    map<string, int> M;\n    rep(i, R) rep(j, C) {\n      rep(k, 8) {\n        string s;\n        int ai = i, aj = j;\n        do {\n          s += A[ai][aj];\n          M[s] += 1;\n          ai += dx[k];\n          aj += dy[k];\n          ai = (ai+R)%R;\n          aj = (aj+C)%C;\n        } while(ai != i || aj != j);\n      }\n    }\n    string ans;\n    FOR(it, M) {\n      //cout << it->first << endl;\n      if (it->second >= 2 && SZ(ans) < SZ(it->first))\n        ans = it->first;\n    }\n    if (SZ(ans)<2) cout << 0 << endl;\n    else\n      cout << ans<< endl;\n  }\n\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#pragma warning(disable:4996)\nusing namespace std;\n\nlong long int gcd(long long int l, long long int r) {\n\tif (l > r)return gcd(r, l);\n\telse {\n\t\tif (r%l) {\n\t\t\treturn gcd(l, r%l);\n\n\t\t}\n\t\telse {\n\t\t\treturn l;\n\t\t}\n\t}\n}\nint dx[8] = { -1,-1,-1, 0, 1, 1, 1, 0 };\nint dy[8] = { -1, 0, 1, 1, 1, 0,-1,-1 };\n\nclass Compare {\npublic:\n\t//keiroが昇順に並ぶ\n\tbool operator()(const string&l, const string&r) {\n\t\treturn l.size() == r.size() ? l<r : l.size() < r.size();\n\n\t}\n};\n\n\nint main() {\n\twhile (1) {\n\t\tint H, W; cin >> H >> W;\n\t\tif (!H)break;\n\t\tvector<string>field;\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tstring st; cin >> st;\n\t\t\tfield.push_back(st);\n\t\t}\n\t\tint ytime = H;\n\t\tint xtime = W;\n\t\tint yxtime = H*W/ gcd(H,W);\n\t\tmap<string, int>mp;\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tfor (int i = 0; i < 8; ++i) {\n\t\t\t\t\tint ny(y);\n\t\t\t\t\tint nx(x);\n\t\t\t\t\tint atime;\n\t\t\t\t\tif (i % 2==0) {\n\t\t\t\t\t\tatime = yxtime;\n\t\t\t\t\t}\n\t\t\t\t\telse if (i == 1 || i == 5) {\n\t\t\t\t\t\tatime = xtime;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tatime = ytime;\n\t\t\t\t\t}\n\t\t\t\t\tstring nst;\n\t\t\t\t\tfor (int k = 0; k < atime; ++k) {\n\t\t\t\t\t\tnst += field[ny][nx];\n\t\t\t\t\t\tif (k) {\n\t\t\t\t\t\t\tmp[nst]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tny = (ny + H + dy[i]) % H;\n\t\t\t\t\t\tnx = (nx + W + dx[i]) % W;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstring ans = \"0\";\n\t\tint num = 0;\n\t\tfor (auto it = mp.begin(); it != mp.end(); ++it) {\n\t\t\tif (it->second >= 2) {\n\t\t\t\tif (num < it->first.size()) {\n\t\t\t\t\tans = it->first;\n\t\t\t\t\tnum = it->first.size();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\nusing namespace std;\n\nint gcd(int a,int b){return b?gcd(b,a%b):a;}\nint lcm(int a,int b){return a/gcd(a,b)*b;}\n\nint main(){\n  int h,w;\n  string g[10];\n  int dx[] = {0,1,1,1,0,-1,-1,-1},dy[] ={-1,-1,0,1,1,1,0,-1};\n  int lm;\n\n  while(cin>> h >> w &&(h||w)){\n    for(int i=0;i<h;i++)cin >> g[i];\n\n    map<string,int> m;\n    vector<string> v;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n\tfor(int k=0;k<8;k++){\n\t  string tmp;\n\t  tmp += g[i][j];\n\t  int sx = j,sy = i;\n\t  if(k&1)lm = lcm(h,w);\n\t  else if(!(k%4))lm = h;\n\t  else lm = w;\n\t  for(int t=1;t<lm;t++){\n\t    sx = (sx+w+dx[k])%w;\n\t    sy = (sy+h+dy[k])%h;\n\t    tmp += g[sy][sx];\n\t    m[tmp]++;\n\t    v.push_back(tmp);\n\t  }\n\t}\n    string ans = v[0];\n    for(int i=1;i<(int)v.size();i++)\n      if(m[v[i]]>1)\n\tif(ans.size()<v[i].size() || (ans.size()==v[i].size()&&ans>v[i]))ans = v[i];\n    if(m[ans]>1)cout << ans << endl;\n    else cout << 0 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <string>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\nint w, h;\nchar grid[10][20];\nmap<string, int> spell;\n\nvoid dfs(int sy, int sx, int y, int x, int d, string str)\n{\n\tspell[str]++;\n\n\tint ny = (y + dy[d] + h) % h;\n\tint nx = (x + dx[d] + w) % w;\n\t\n\tif (ny == sy&&nx == sx) {\n\t\treturn;\n\t}\n\t\n\tdfs(sy, sx, ny, nx, d, str + grid[ny][nx]);\n}\n\nint main()\n{\n\twhile (true) {\n\t\tcin >> h >> w;\n\n\t\tif (h == 0 && w == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tspell.clear();\n\t\tvector<vector<bool>> visited(h, vector<bool>(w, false));\n\n\t\trep(y, h) {\n\t\t\trep(x, w) {\n\t\t\t\tcin >> grid[y][x];\n\t\t\t}\n\t\t}\n\n\t\trep(y, h) {\n\t\t\trep(x, w) {\n\t\t\t\trep(d, 8) {\n\t\t\t\t\tstring str;\n\t\t\t\t\tdfs(y, x, y, x, d, str + grid[y][x]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstring ans;\n\n\t\tfor (auto it = spell.begin(); it != spell.end(); it++) {\n\t\t\tif (it->second >= 2) {\n\t\t\t\tif (ans.size() < it->first.size()) {\n\t\t\t\t\tans = it->first;\n\t\t\t\t}\n\t\t\t\telse if (ans.size() == it->first.size()) {\n\t\t\t\t\tif (it->first < ans) {\n\t\t\t\t\t\tans = it->first;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ans.size() != 1) {\n\t\t\tcout << ans << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << 0 << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <set>\nusing namespace std;\n\nint di[] = {0, 0, 1, -1, 1, 1, -1, -1};\nint dj[] = {1, -1, 0, 0, 1, -1, 1, -1};\nint main() {\n    int h, w;\n    while (cin >> h >> w, h) {\n        vector<string> s(h);\n        for (auto &si: s) cin >> si;\n        set<string> se;\n        vector<string> res;\n        for (int k = 0; k < 8; k++) {\n            for (int i = 0; i < h; i++) for (int j = 0; j < w; j++) {\n                string tmp;\n                int ni = i, nj = j;\n                do {\n                    (ni += di[k] + h) %= h;\n                    (nj += dj[k] + w) %= w;\n                    tmp += s[ni][nj];\n                    if (se.count(tmp)) res.emplace_back(tmp);\n                    else se.emplace(tmp);\n                } while (ni != i || nj != j);\n            }\n        }\n        int len = 0;\n        for (auto &si: res) len = max(len, (int)si.size());\n        string ans = string(len, 'a');\n        for (auto &si: res) if (si.size() == len) ans = min(ans, si);\n        if (len < 2) cout << 0 << endl;\n        else cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define lengthof(array) (sizeof(array) / sizeof(*array))\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n#define FOR(it,c) for(__typeof((c).begin())it=(c).begin(); it!=(c).end();++it)\n#define RFOR(it,c) for(__typeof((c).rbegin())it=(c).rbegin(); it!=(c).rend();++it)\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\ntemplate<typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos << '(' << p.first << \", \" << p.second << ')';\n\treturn os;\n}\n\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n\tcopy(v.begin(), v.end(), ostream_iterator<T>(os, \" \"));\n\treturn os;\n}\n\nint h, w;\nconst int dx[8] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int dy[8] = {1, 1, 0, -1, -1, -1, 0, 1};\nvector<string> donut;\nbool visited[10][20];\n\ninline unsigned long long hash(const string& s) {\n\tconst unsigned long long base = 1000000007;\n\tlong long res = 0;\n\tfor(int i = 0; i < s.size(); ++i) {\n\t\tres *= base;\n\t\tres += s[i];\n\t}\n\n\treturn res;\n}\n\nstring spell(int x, int y, int d) {\n\tif(visited[y][x])\n\t\treturn \"\";\n\n\tvisited[y][x] = true;\n\tstring res = donut[y][x] + spell((x + dx[d] + w) % w, (y + dy[d] + h) % h, d);\n\tvisited[y][x] = false;\n\treturn res;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tconst string init(2, 'z' + 1);\n\n\twhile(cin >> h >> w, h) {\n\t\tdonut.clear();\n\t\tdonut.resize(h);\n\t\tfor(int i = 0; i < h; ++i)\n\t\t\tcin >> donut[i];\n\n\t\tstring ans = init;\n//\t\tset<string> s;\n\t\tset<unsigned long long> s;\n\t\tmap<string, int> cnt;\n\t\tfor(int i = 0; i < h; ++i) {\n\t\t\tfor(int j = 0; j < w; ++j) {\n\t\t\t\tfor(int d = 0; d < 8; ++d) {\n\t\t\t\t\tconst string str = spell(j, i, d);\n\t\t\t\t\tfor(int i = ans.size(); i <= str.size(); ++i) {\n\n\t\t\t\t\t\tconst string tmp = str.substr(0, i);\n/*\n\t\t\t\t\t\tif(s.find(tmp) == s.end())\n\t\t\t\t\t\t\ts.insert(tmp);\n*/\n\n\t\t\t\t\t\tconst unsigned long long h = hash(tmp);\n\t\t\t\t\t\tif(s.find(h) == s.end())\n\t\t\t\t\t\t\ts.insert(h);\n\n\t\t\t\t\t\telse if(ans.size() < tmp.size() || (ans.size() == tmp.size() && tmp < ans))\n\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << (ans != init ? ans : \"0\") << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nconst static int tx[] = {0,1,1,1,0,-1,-1,-1};\nconst static int ty[] = {-1,-1,0,1,1,1,0,-1};\n\nint main(){\n  int H,W;\n  while(~scanf(\"%d %d\",&H,&W)){\n    if(H==0 && W==0) break;\n\n    char line[32];\n    char stage[10][20];\n\n    for(int y=0;y<H;y++){\n      scanf(\"%s\",line);\n      for(int x=0;x<W;x++){\n\tstage[y][x] = line[x];\n      }\n    }\n\n    string res = \"\";\n    vector<string> spells;\n    map<string,int> freq;\n    \n    for(int y=0;y<H;y++){\n      for(int x=0;x<W;x++){\n\tint sx = x;\n\tint sy = y;\n\n\tfor(int dir=0;dir<8;dir++){\n\t  string spell = \"\";\n\t  spell.push_back(stage[sy][sx]);\n\t  int dx = sx;\n\t  int dy = sy;\n\t  for(int i=0;i<1000;i++){\n\t    dx = tx[dir] + dx;\n\t    dy = ty[dir] + dy;\n\t    if(dx < 0) dx = W-1;\n\t    if(dx >= W) dx = 0;\n\t    if(dy < 0) dy = H-1;\n\t    if(dy >= H) dy = 0;\n\n\t    if(dy == sy && dx == sx) break;\n\t    spell.push_back(stage[dy][dx]);\n\t    freq[spell]++;\n\t    if(freq[spell] >= 2){\n\t      if(res.size() < spell.size()\n\t\t || (res.size() == spell.size() && res < spell)){\n\t\tres = spell;\n\t      }\n\t    }\n\t  }\n\t  spells.push_back(spell);\n\t  // cout << spell << endl;\n\t}\n      }\n    }\n    printf(\"%s\\n\",res != \"\" ? res.c_str() : \"0\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <vector>\n#include <iostream>\n#include <cstring>\nusing namespace std;\nint m[29][29];\nmain(){\n\tstring s,t;\n\tint h,w,i,j,x,y,X,Y;\n\tfor(;cin>>h>>w,h;cout<<s<<endl){\n\t\tvector<string>v;\n\t\tfor(i=0;i<h;i++)cin>>s,v.push_back(s);\n\t\ts=\"0\";\n\t\tmap<string,int>M;\n\t\tfor(i=0;i<h;i++)for(j=0;j<w;j++)for(x=-1;x<=1;x++)for(y=-1;y<=1;y++)if(x||y){\n\t\t\tmemset(m,0,sizeof(m));\n\t\t\tY=i,X=j;\n\t\t\tt=v[Y][X],m[Y][X]=1;X=(X+x+w)%w,Y=(Y+y+h)%h;\n\t\t\tfor(;!m[Y][X];X=(X+x+w)%w,Y=(Y+y+h)%h){\n\t\t\t\tt+=v[Y][X],m[Y][X]=1;\n\t\t\t\tif(++M[t]>1 && (s.size()<t.size()||(s.size()==t.size()&&s>t)))s=t;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\nusing namespace std;\n#define REP(i,x)for(int i=0;i<x;i++)\n\nstring res;\nint H,W,dx,dy,min_len;\nchar s[200];\nstring MAP[11];\nbool visit[20][20];\nvector<string> ss;\nvoid dfs(int x,int y,int k){\n  if(visit[y][x]){\n    ss.push_back(string(s));\n    return;\n  }\n  s[k]=MAP[y][x];  visit[y][x]=1;\n  dfs((x + dx + W) % W, (y + dy + H) % H, k + 1);\n  s[k]=0;  visit[y][x]=0;\n}\nint main() {\n  while(cin>>H>>W,H){\n    REP(i,H)cin>>MAP[i];\n    ss.clear();\n    min_len=1; res=\"0\";\n    REP(y,H)REP(x,W){\n      for(dx=-1;dx<=1;dx++){\n        for(dy=-1;dy<=1;dy++){\n          if(dx|dy)dfs(x,y,0);\n        }\n      }\n    }\n    string res = \"0\";\n    sort(ss.begin(),ss.end());\n    REP(i,ss.size()-1){\n      int len = 0;\n      REP(k,min(ss[i].size(),ss[i+1].size())){\n        if(ss[i][k]==ss[i+1][k])len++;\n        else break;\n      }\n      if(len < res.size())continue;\n      if(res.size() == len){\n        res = min(res, ss[i].substr(0,len));\n      }else{\n        res = ss[i].substr(0, len);\n      }\n    }\n    cout<<res<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <set>\nusing namespace std;\n#define REP(i,x)for(__typeof(x) i=0;i<x;i++)\n\nstring res;\nset<string> m;\nint H,W,dx,dy,min_len;\nchar s[200];\nstring MAP[11];\nbool visit[20][20];\nvoid dfs(int x,int y,int k){\n  if(k==min_len){\n    if(m.count(string(s)))res=min(res,string(s));\n    m.insert(string(s));\n  }else if(k>min_len){\n    if(m.count(string(s)))res=string(s),min_len=k;\n    m.insert(string(s));\n  }\n  m.insert(string(s));\n  if(visit[y][x])\n    return;\n  s[k]=MAP[y][x];  visit[y][x]=1;\n  dfs((x + dx + W) % W, (y + dy + H) % H, k + 1);\n  s[k]=0;  visit[y][x]=0;\n}\nint main() {\n  while(cin>>H>>W,H){\n    REP(i,H)cin>>MAP[i];\n    m.clear();\n    min_len=1; res=\"0\";\n    REP(y,H)REP(x,W){\n      for(dx=-1;dx<=1;dx++){\n        for(dy=-1;dy<=1;dy++){\n          if(dx|dy)dfs(x,y,0);\n        }\n      }\n    }\n    cout<<res<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<string>\n#include<map>\nusing namespace std;\n\nint W,H,i,j,k,l,p,m[3]={0,1,-1},h,w,sh,sw;\nchar D[10][21];\nstring T,R;\nmap<string,int> S;\nint main()\n{\n\tfor(;scanf(\"%d%d\\n\",&H,&W),H;)\n\t{\n\t\tS.clear();\n\t\tR=\"0\";\n\t\tfor(i=k=0,l=1;i<H;i++)gets(D[i]);\n\t\tfor(sh=0;sh<H;sh++)\n\t\t\tfor(sw=0;sw<W;sw++)\n\t\t\t\tfor(i=0;i<3;i++)\n\t\t\t\t\tfor(j=0;j<3;j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(i==0&&j==0)continue;\n\t\t\t\t\t\tT.clear();\n\t\t\t\t\t\tfor(h=sh,w=sw,p=0;!(p!=0&&h==sh&&w==sw);h=(h+m[i]+H)%H,w=(w+m[j]+W)%W,p++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tT+=D[h][w];\n\t\t\t\t\t\t\tif(S.find(T)!=S.end())\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif(R.length()<T.length()||(R.length()==T.length()&&R>T))\n\t\t\t\t\t\t\t\t\tR=T;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tS.insert(map<string,int>::value_type(T,1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\tcout<<R<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\nusing namespace std;\n\nint main(){\n    int h,w;\n    while(cin>>h>>w,h){\n        char D[h][w];\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                cin>>D[i][j];\n            }\n        }\n        map<string,int> M;\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                for(int di=-1;di<=1;di++){\n                    for(int dj=-1;dj<=1;dj++){\n                        if(!di&&!dj) continue;\n                        string S;\n                        int I=i,J=j;\n                        while(true){\n                            S.push_back(D[I][J]);\n                            M[S]++;\n                            I+=di;\n                            if(I<0)I=h-1;\n                            if(I>=h)I=0;\n                            J+=dj;\n                            if(J<0)J=w-1;\n                            if(J>=w)J=0;\n                            if(I==i&&J==j) break;\n                        }\n                    }\n                }\n            }\n        }\n        string ans;\n        for(auto p:M){\n            // cout<<p.first<<' '<<p.second<<endl;\n            if(p.second<=1) continue;\n            else{\n                string S = p.first;\n                if(ans.size()<S.size()){\n                    ans=S;\n                }else if(ans.size()==S.size()){\n                    ans=min(ans,S);\n                }\n            }\n        }\n        if(ans.size()==1)cout<<0<<endl;\n        else cout<<ans<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<cstring>\n#include<queue>\n#include<stack>\n\nusing namespace std;\n\n#define INF 999999999\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\nvector<string> donut(10);\nvector<string> lis(200);\n\nint main(){\n\tint i, j, w, h;\n\tint d[8][2]={{-1,-1},{-1,0},{-1,1},{0,-1},{0,1},{1,-1},{1,0},{1,1}};\n\tstring ans, ins;\n\twhile(1){\n\t\tcin >> h >> w;\n\t\tif(!h) break;\n\t\tans=\"0\";\n\t\tlis.clear();\n\t\tdonut.clear();\n\t\tREP(a,h){\n\t\t\tcin >> ins;\n\t\t\tdonut.push_back(ins);\n\t\t}\n\t\t/*REP(a,h){\n\t\t\tcout << donut[a] << endl;\n\t\t}*/\n\t\tREP(a,h){\n\t\t\tREP(b,w){\n\t\t\t\tREP(c,8){\n\t\t\t\t\t//cout << a << \",\" << b << \":\" << donut[a][b] << endl;\n\t\t\t\t\tins = donut[a][b];\n\t\t\t\t\t//cout << ins << endl;\n\t\t\t\t\tint x = a+d[c][0], y = b+d[c][1];\n\t\t\t\t\tif(x<0) x = h-1;\n\t\t\t\t\tif(x>h-1) x = 0;\n\t\t\t\t\tif(y<0) y = w-1;\n\t\t\t\t\tif(y>w-1) y = 0;\n\t\t\t\t\twhile(x!=a||y!=b){\n\t\t\t\t\t\t//cout<<a<<\",\"<<b<<\"(\"<<c<<\"):\"<<x<<\",\"<<y<<\"->\";\n\t\t\t\t\t\t//cout<<donut[y][x]<<endl;\n\t\t\t\t\t\tins += donut[x][y];\n\t\t\t\t\t\tx = x+d[c][0];\n\t\t\t\t\t\ty = y+d[c][1];\n\t\t\t\t\t\tif(x<0) x = h-1;\n\t\t\t\t\t\tif(x>h-1) x = 0;\n\t\t\t\t\t\tif(y<0) y = w-1;\n\t\t\t\t\t\tif(y>w-1) y = 0;\n\t\t\t\t\t}\n\t\t\t\t\tlis.push_back(ins);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//REP(a,lis.size()) cout << lis[a] << endl;\n\t\tREP(a,lis.size()){\n\t\t\tfor(i=a+1;i<lis.size();i++){\n\t\t\t\tif(lis[a][0]==lis[i][0]){\n\t\t\t\t\t//cout << a << \"-\" << i << endl;\n\t\t\t\t\tfor(j=max(2,(int)ans.size());j<=min(lis[a].size(),lis[i].size());j++){\n\t\t\t\t\t\tif(lis[a].substr(0,j)==lis[i].substr(0,j)){\n\t\t\t\t\t\t\tins = lis[a].substr(0,j);\n\t\t\t\t\t\t\tif(ins.size() > ans.size()) ans = ins;\n\t\t\t\t\t\t\telse if(ins.size()==ans.size()&&ins < ans) ans = ins;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <vector>\nusing namespace std;\n\n\nstruct Str2 {\n  string s;\n  Str2() {}\n  Str2(string s) : s(s) {}\n  bool operator < (const Str2 &str) const {\n    if(s.size() != str.s.size()) return s.size() > str.s.size();\n    return s < str.s;\n  }\n};\n\nconst int MAX_H = 20;\nconst int MAX_W = MAX_H;\nint H, W;\nchar G[MAX_H][MAX_W];\nmap<string, int> M;\nvector<Str2> V;\n\n\nstring solve() {\n  M.clear();\n  V.clear();\n  for(int i = 0; i < H; ++i) {\n    for(int j = 0; j < W; ++j) {\n      for(int dx = -1; dx <= 1; ++dx) {\n\tfor(int dy = -1; dy <= 1; ++dy) {\n\t  if(dx == 0 && dy == 0) continue;\n\t  int x = j;\n\t  int y = i;\n\t  string s = \"\";\n\t  do {\n\t    s += G[y][x];\n\t    if(s.size() >= 2 && ++M[s] == 2) {\n\t      V.push_back(Str2(s));\n\t    }\n\t    int nx = (x+dx+W)%W;\n\t    int ny = (y+dy+H)%H;\n\t    x = nx;\n\t    y = ny;\n\t  } while(!(x == j && y == i));\n\t}\n      }\n    }\n  }\n  if(V.size() == 0) return \"0\";\n  sort(V.begin(), V.end());\n  return V[0].s;\n}\n\nint main() {\n  while(cin >> H >> W && (H | W)) {\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n\tcin >> G[i][j];\n      }\n    }\n    cout << solve() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define MT make_tuple\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\nint dx[] = { 0, 1, 0, -1, 1, 1, -1, -1 };\nint dy[] = { -1, 0, 1, 0, -1, 1, -1, 1 };\n\nconst int N = 20;\nint visit[N][N];\nint main(){\n\tint h, w;\n\twhile (cin >> h >> w, h){\n\t\tvector<string> vs(h);\n\t\trep(i, h) cin >> vs[i];\n\n\t\tmap<string, int> m;\n\t\trep(i, h) rep(j, w) rep(d, 8){\n\t\t\tMEMSET(visit, 0);\n\t\t\tstring s;\n\t\t\ts += vs[i][j];\n\t\t\tvisit[i][j] = 1;\n\t\t\tint nx = (j + dx[d] + w) % w, ny = (i + dy[d] + h) % h;\n\t\t\twhile (!visit[ny][nx]){\n\t\t\t\ts += vs[ny][nx];\n\t\t\t\t++m[s];\n\t\t\t\tnx = (nx + dx[d] + w) % w, ny = (ny + dy[d] + h) % h;\n\t\t\t}\n\t\t}\n\t\tpair<int, string> ans = MP(0, \"0\");\n\t\tfor (auto p : m){\n\t\t\tif (p.second > 1) ans = min(ans, MP(-(int)p.first.size(), p.first));\n\t\t}\n\t\tcout << ans.second << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint gcd(int a, int b){\n    while(a != b){\n        if(a > b) a = a - b; else b = b - a;\n    }\n    return a;\n}\n\nint lcm(int a, int b){\n    return ((a / gcd(a, b)) * b);\n}\n\nint main(){\n    int h, w;\n    while(true){\nchar torus[10][20];\n        string str[2048];\n        bool ok[2048];\n        int num = 0;\n\n        for(int i=0; i<2048; ++i){\n            str[i] = \"\";\n            ok[i] = true;\n        }\n\n        cin >> h >> w;\n        if(h==0 && w==0) break;\n\n        int cml = lcm(w, h);\n\n        for(int i=0; i<h; ++i){\n            for(int j=0; j<w; ++j){\n                cin >> torus[i][j];\n            }\n        }\n\n        //一番長い文字列をつくる\n\n        for(int y=0; y<h; ++y){\n            for(int x=0; x<w; ++x){\n                for(int i=0; i<h; ++i){\n                    str[num] += torus[(y+i)%h][x];\n                    str[num+1] += torus[h-(y+i)%h-1][x];\n                }\n                num += 2;\n            }\n        }\n        for(int y=0; y<h; ++y){\n            for(int x=0; x<w; ++x){\n                for(int i=0; i<w; ++i){\n                    str[num] += torus[y][(x+i)%w];\n                    str[num+1] += torus[y][w-(x+i)%w-1];\n                }\n                num += 2;\n            }\n        }\n        for(int y=0; y<h; ++y){\n            for(int x=0; x<w; ++x){\n                for(int i=0; i<cml; ++i){\n                    str[num] += torus[(y+i)%h][(x+i)%w];\n                    str[num+1] += torus[(y+i)%h][w-(x+i)%w-1];\n                    str[num+2] += torus[h-(y+i)%h-1][(x+i)%w];\n                    str[num+3] += torus[h-(y+i)%h-1][w-(x+i)%w-1];\n                }\n                num += 4;\n            }\n        }\n\n\n        string result = \"\";\n\n        sort(str, str+num);\n\n        for(int j=num-1; j>0; --j){\n            if(str[j][0] != str[j-1][0]){\n                ok[j] = false;\n            }\n        }\n\n        for(int i=1; i<cml; ++i){\n            for(int j=num-1; j>0; --j){\n                if(ok[j] && str[j].length() >= i && str[j-1].length() >= i){\n                    if(str[j][i] == str[j-1][i]){\n                        result = str[j];\n                        result.resize(i+1);\n                    }else{\n                        ok[j] = false;\n                    }\n                }\n            }\n        }\n\n        cout << ((result.length() == 0) ? \"0\" : result) << endl;\n\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<set>\nusing namespace std;\ntypedef vector<int> vi;\nset<string> cands;\nint dy[]={-1,-1,-1,0,0,1,1,1};\nint dx[]={-1,0,1,-1,1,-1,0,1};\nint maxlength=0,h,w;\nstring ans=\"\";\nvoid check(int y,int x,string *board)\n{\n  for(int k=0;k<8;k++)\n  {\n    bool visited[h][w];\n    memset(visited,false,sizeof(visited));\n    int yy=y,xx=x;\n    string str=\"\";\n    while(!visited[yy][xx])\n    {\n      str+=board[yy][xx];\n      if(cands.find(str)!=cands.end())\n      {\n\t\t\t\tint str_len=str.length();\n\t\t\t\tif(maxlength<str_len)\n\t\t\t\t{\n\t  \t\t\tans=str;\n\t\t\t\t\tmaxlength=str_len;\n\t\t\t\t}\n\t\t\t\telse if(maxlength==str_len && str<ans)\n\t\t\t\t{\n\t  \t\t\tans=str;\n\t\t\t\t\tmaxlength=str_len;\n\t\t\t\t}\n      }\n      else\n      {\n\t\t\t\tcands.insert(str);\n      }\n      visited[yy][xx]=true;\n      yy=(yy+dy[k]+h)%h;\n      xx=(xx+dx[k]+w)%w;\n    }\n  }\n}\n\nint main()\n{\n  while(1) \n  {\n    cin >> h >> w;\n    if(h==0) break;\n    string board[h];\n    cands.clear();\n    for(int i=0;i<h;i++)\n    {\n      cin >> board[i];\n    }\n    maxlength=0;\n    ans=\"0\";\n    for(int i=0;i<h;i++)\n    {\n      for(int j=0;j<w;j++)\n      {\n\t\t\t\tcheck(i,j,board);\n      }\n    }\n    if(maxlength>=2)\n    {\n      cout << ans << endl;\n     }\n    else\n    {\n      cout << \"0\" << endl;\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * \n */\n\n// header {{{\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define CPP_STR(x) CPP_STR_I(x)\n#define CPP_CAT(x,y) CPP_CAT_I(x,y)\n#define CPP_STR_I(args...) #args\n#define CPP_CAT_I(x,y) x ## y\n\n#define SFINAE(pred...) std::enable_if_t<(pred), std::nullptr_t> = nullptr\n\n#define ASSERT(expr...) assert((expr))\n\nusing i8  = int8_t;\nusing u8  = uint8_t;\nusing i16 = int16_t;\nusing u16 = uint16_t;\nusing i32 = int32_t;\nusing u32 = uint32_t;\nusing i64 = int64_t;\nusing u64 = uint64_t;\n\nusing f32 = float;\nusing f64 = double;\nusing f80 = __float80;\n// }}}\n\nconstexpr i64 INF  = INT64_C(1'010'000'000'000'000'017);\nconstexpr f64 FINF = 1e100;\n\nconstexpr i64 MOD = INT64_C(1'000'000'007);\n//constexpr i64 MOD = INT64_C(998'244'353);\n\nconstexpr f64 EPS = 1e-12;\n\nconstexpr f64 PI = 3.14159265358979323846;\n\n// util {{{\n#define FOR(i, start, end) for(i64 i = (start), CPP_CAT(i,xxxx_end)=(end); i < CPP_CAT(i,xxxx_end); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define ALL(f,c,...) (([&](decltype((c)) cccc) { return (f)(std::begin(cccc), std::end(cccc), ## __VA_ARGS__); })(c))\n\n#define LIFT(f) ([](auto&&... args) -> decltype(auto) { return (f)(std::forward<decltype(args)>(args)...); })\n\ntemplate<typename C>\nconstexpr i64 SIZE(const C& c) noexcept { return static_cast<i64>(c.size()); }\n\ntemplate<typename T, size_t N>\nconstexpr i64 SIZE(const T (&)[N]) noexcept { return static_cast<i64>(N); }\n\ntemplate<typename T, SFINAE(is_signed<T>::value)>\nconstexpr T ABS(T x) noexcept {\n    return x < 0 ? -x : x;\n}\n\ntemplate<typename T>\nconstexpr i64 CMP(T x, T y) noexcept { return (y<x) - (x<y); }\n\ntemplate<typename T>\nconstexpr i64 SGN(T x) noexcept { return CMP(x,T(0)); }\n\ntemplate<typename T, typename U, typename Comp=less<>>\nconstexpr bool chmax(T& xmax, const U& x, Comp comp={}) noexcept {\n    if(comp(xmax, x)) {\n        xmax = x;\n        return true;\n    }\n    return false;\n}\n\ntemplate<typename T, typename U, typename Comp=less<>>\nconstexpr bool chmin(T& xmin, const U& x, Comp comp={}) noexcept {\n    if(comp(x, xmin)) {\n        xmin = x;\n        return true;\n    }\n    return false;\n}\n\ntemplate<typename BinaryFunc, typename UnaryFunc>\nauto ON(BinaryFunc&& bf, UnaryFunc&& uf) {\n    return [bf=forward<BinaryFunc>(bf),uf=forward<UnaryFunc>(uf)](const auto& x, const auto& y) {\n        return bf(uf(x), uf(y));\n    };\n}\n\ntemplate<typename F>\nauto LT_ON(F&& f) {\n    return ON(less<>{}, forward<F>(f));\n}\n\ntemplate<typename F>\nauto GT_ON(F&& f) {\n    return ON(greater<>{}, forward<F>(f));\n}\n\ntemplate<typename F>\nauto EQ_ON(F&& f) {\n    return ON(equal_to<>{}, forward<F>(f));\n}\n\ntemplate<typename F>\nauto NE_ON(F&& f) {\n    return ON(not_equal_to<>{}, forward<F>(f));\n}\n\n// tuple {{{\ntemplate<i64 I=0, typename F, typename... TS, SFINAE(sizeof...(TS) == I)>\nvoid tuple_enumerate(tuple<TS...>&, F&&) {}\n\ntemplate<i64 I=0, typename F, typename... TS, SFINAE(sizeof...(TS) > I)>\nvoid tuple_enumerate(tuple<TS...>& t, F&& f) {\n    f(I, get<I>(t));\n    tuple_enumerate<I+1>(t, forward<F>(f));\n}\n\ntemplate<i64 I=0, typename F, typename... TS, SFINAE(sizeof...(TS) == I)>\nvoid tuple_enumerate(const tuple<TS...>&, F&&) {}\n\ntemplate<i64 I=0, typename F, typename... TS, SFINAE(sizeof...(TS) > I)>\nvoid tuple_enumerate(const tuple<TS...>& t, F&& f) {\n    f(I, get<I>(t));\n    tuple_enumerate<I+1>(t, forward<F>(f));\n}\n// }}}\n\n// container {{{\ntemplate<typename T> struct is_container : false_type {};\ntemplate<typename T, size_t N> struct is_container<array<T,N>> : true_type {};\ntemplate<typename... Args> struct is_container<vector<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<deque<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<list<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<forward_list<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<set<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<multiset<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<unordered_set<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<unordered_multiset<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<map<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<multimap<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<unordered_map<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<unordered_multimap<Args...>> : true_type {};\n\ntemplate<typename T, typename Enable=void>\nstruct ProconHash {\n    size_t operator()(const T& x) const noexcept {\n        return hash<T>{}(x);\n    }\n};\n\ntemplate<typename T>\nsize_t procon_hash_value(const T& x) noexcept {\n    return ProconHash<T>{}(x);\n}\n\nsize_t procon_hash_combine(size_t h1, size_t h2) noexcept {\n    constexpr size_t M = UINT64_C(0xc6a4a7935bd1e995);\n    constexpr int    R = 47;\n\n    h2 *= M;\n    h2 ^= h2 >> R;\n    h2 *= M;\n\n    h1 ^= h2;\n    h1 *= M;\n\n    h1 += 0xe6546b64;\n\n    return h1;\n}\n\ntemplate<typename T1, typename T2>\nstruct ProconHash<pair<T1,T2>> {\n    size_t operator()(const pair<T1,T2>& p) const noexcept {\n        size_t h1 = procon_hash_value(p.first);\n        size_t h2 = procon_hash_value(p.second);\n        return procon_hash_combine(h1, h2);\n    }\n};\n\ntemplate<typename... TS>\nstruct ProconHash<tuple<TS...>> {\n    size_t operator()(const tuple<TS...>& t) const noexcept {\n        size_t h = 0;\n        tuple_enumerate(t, [&h](i64, const auto& e) {\n            h = procon_hash_combine(h, procon_hash_value(e));\n        });\n        return h;\n    }\n};\n\ntemplate<typename C>\nstruct ProconHash<C,enable_if_t<is_container<C>::value>> {\n    size_t operator()(const C& c) const noexcept {\n        size_t h = 0;\n        for(const auto& e : c)\n            h = procon_hash_combine(h, procon_hash_value(e));\n        return h;\n    }\n};\n\ntemplate<typename T, typename Hash=ProconHash<T>, typename Eq=equal_to<T>>\nusing HashSet = unordered_set<T,Hash,Eq>;\ntemplate<typename K, typename V, typename Hash=ProconHash<K>, typename Eq=equal_to<K>>\nusing HashMap = unordered_map<K,V,Hash,Eq>;\ntemplate<typename T, typename Hash=ProconHash<T>, typename Eq=equal_to<T>>\nusing HashMultiset = unordered_multiset<T,Hash,Eq>;\ntemplate<typename K, typename V, typename Hash=ProconHash<K>, typename Eq=equal_to<K>>\nusing HashMultimap = unordered_multimap<K,V,Hash,Eq>;\n\ntemplate<typename T>\nauto vec_make(i64 n, T x) {\n    return vector<T>(n, x);\n}\n\ntemplate<typename T, typename... Args, SFINAE(sizeof...(Args) >= 2)>\nauto vec_make(i64 n, Args... args) {\n    auto inner = vec_make<T>(args...);\n    return vector<decltype(inner)>(n, inner);\n}\n\ntemplate<typename T>\nauto vec_reserve(i64 cap) {\n    vector<T> res;\n    res.reserve(cap);\n    return res;\n}\n\ntemplate<typename T=i64>\nauto vec_iota(i64 n, T init={}) {\n    vector<i64> res(n);\n    ALL(iota, res, init);\n    return res;\n}\n\ntemplate<typename T, typename Comp, typename Cont=vector<T>>\nauto priority_queue_make(const Comp& comp, Cont&& cont={}) {\n    return priority_queue<T,remove_reference_t<Cont>,Comp>(comp, forward<Cont>(cont));\n}\n\ntemplate<typename T, typename Comp>\nauto priority_queue_reserve(const Comp& comp, i64 cap) {\n    return priority_queue<T,vector<T>,Comp>(comp, vec_reserve<T>(cap));\n}\n\ntemplate<typename T, size_t N, size_t... NS>\nstruct ArrayType {\n    using type = array<typename ArrayType<T,NS...>::type,N>;\n};\n\ntemplate<typename T, size_t N>\nstruct ArrayType<T,N> {\n    using type = array<T,N>;\n};\n\ntemplate<typename T, size_t... NS>\nusing Array = typename ArrayType<T,NS...>::type;\n\ntemplate<typename T, size_t N>\nT& array_at(Array<T,N>& ary, i64 i) {\n    return ary[i];\n}\n\ntemplate<typename T, size_t N, size_t... NS, typename... Args>\nT& array_at(Array<T,N,NS...>& ary, i64 i, Args... args) {\n    return array_at<T,NS...>(ary[i], args...);\n}\n\ntemplate<typename T, size_t N>\nconst T& array_at(const Array<T,N>& ary, i64 i) {\n    return ary[i];\n}\n\ntemplate<typename T, size_t N, size_t... NS, typename... Args>\nconst T& array_at(const Array<T,N,NS...>& ary, i64 i, Args... args) {\n    return array_at<T,NS...>(ary[i], args...);\n}\n\ntemplate<typename T, typename C>\nT POP(stack<T,C>& stk) {\n    T x = stk.top(); stk.pop();\n    return x;\n}\n\ntemplate<typename T, typename C>\nT POP(queue<T,C>& que) {\n    T x = que.front(); que.pop();\n    return x;\n}\n\ntemplate<typename T, typename C, typename Comp>\nT POP(priority_queue<T,C,Comp>& que) {\n    T x = que.top(); que.pop();\n    return x;\n}\n// }}}\n\n// fixpoint {{{\ntemplate<typename F>\nclass FixPoint {\npublic:\n    explicit constexpr FixPoint(F&& f) : f_(forward<F>(f)) {}\n\n    template<typename... Args>\n    constexpr decltype(auto) operator()(Args&&... args) const {\n        return f_(*this, forward<Args>(args)...);\n    }\n\nprivate:\n    F f_;\n};\n\ntemplate<typename F>\nconstexpr decltype(auto) FIX(F&& f) {\n    return FixPoint<F>(forward<F>(f));\n}\n\ntemplate<typename F, size_t... NS>\nclass FixPointMemo {\npublic:\n    explicit FixPointMemo(F&& f) : f_(forward<F>(f)) {}\n\n    template<typename... Args>\n    decltype(auto) operator()(Args... args) const {\n        using R = decltype(f_(*this,args...));\n        static Array<bool,NS...> done {};\n        static Array<R,NS...>    memo;\n\n        if(!array_at<bool,NS...>(done,args...)) {\n            array_at<R,NS...>(memo,args...) = f_(*this,args...);\n            array_at<bool,NS...>(done,args...) = true;\n        }\n        return array_at<R,NS...>(memo,args...);\n    }\n\nprivate:\n    F f_;\n};\n\ntemplate<size_t... NS, typename F>\ndecltype(auto) FIXMEMO(F&& f) {\n    return FixPointMemo<F,NS...>(forward<F>(f));\n}\n// }}}\n\n// math {{{\n/*constexpr*/ i64 GCD(i64 a, i64 b) noexcept {\n    /*constexpr*/ auto f_gcd = FIX([](auto&& self, i64 aa, i64 bb) {\n        if(bb == 0) return aa;\n        return self(bb, aa%bb);\n    });\n    return f_gcd(ABS(a), ABS(b));\n}\n\n/*constexpr*/ i64 LCM(i64 a, i64 b) noexcept {\n    ASSERT(a != 0 && b != 0);\n    /*constexpr*/ auto f_gcd = FIX([](auto&& self, i64 aa, i64 bb) {\n        if(bb == 0) return aa;\n        return self(bb, aa%bb);\n    });\n    a = ABS(a);\n    b = ABS(b);\n    return a / f_gcd(a,b) * b;\n}\n\n/*constexpr*/ tuple<i64,i64,i64> EXTGCD(i64 a, i64 b) noexcept {\n    /*constexpr*/ auto impl = FIX([](auto&& self, i64 aa, i64 bb) -> tuple<i64,i64,i64> {\n        if(bb == 0) return make_tuple(aa, 1, 0);\n        i64 g,x,y; tie(g,x,y) = self(bb, aa%bb);\n        return make_tuple(g, y, x-(aa/bb)*y);\n    });\n    i64 g,x,y; tie(g,x,y) = impl(ABS(a), ABS(b));\n    x *= SGN(a);\n    y *= SGN(b);\n    return make_tuple(g, x, y);\n}\n// }}}\n\n// string {{{\nauto str_reserve(i64 cap) {\n    string res;\n    res.reserve(cap);\n    return res;\n}\n// }}}\n\n// input {{{\ntemplate<typename T, typename Enable=void>\nstruct Scan {\n    static T scan(istream& in) {\n        T res;\n        in >> res;\n        return res;\n    }\n};\n\ntemplate<typename T, typename Enable=void>\nstruct Scan1;\n\ntemplate<typename T>\nstruct Scan1<T,enable_if_t<is_integral<T>::value && !is_same<T,bool>::value>> {\n    static T scan1(istream& in) {\n        return Scan<T>::scan(in) - 1;\n    }\n};\n\ntemplate<typename T1, typename T2>\nstruct Scan<pair<T1,T2>> {\n    static pair<T1,T2> scan(istream& in) {\n        T1 x = Scan<T1>::scan(in);\n        T2 y = Scan<T2>::scan(in);\n        return {x,y};\n    }\n};\n\ntemplate<typename T1, typename T2>\nstruct Scan1<pair<T1,T2>> {\n    static pair<T1,T2> scan1(istream& in) {\n        T1 x = Scan1<T1>::scan1(in);\n        T2 y = Scan1<T2>::scan1(in);\n        return {x,y};\n    }\n};\n\ntemplate<typename... TS>\nstruct Scan<tuple<TS...>> {\n    static tuple<TS...> scan(istream& in) {\n        return scan_impl<0>(in);\n    }\nprivate:\n    template<i64 I, SFINAE(sizeof...(TS) == I)>\n    static auto scan_impl(istream&) {\n        return make_tuple();\n    }\n    template<i64 I, SFINAE(sizeof...(TS) > I)>\n    static auto scan_impl(istream& in) {\n        using T = tuple_element_t<I,tuple<TS...>>;\n        auto head = make_tuple(Scan<T>::scan(in));\n        return tuple_cat(head, scan_impl<I+1>(in));\n    }\n};\n\ntemplate<typename... TS>\nstruct Scan1<tuple<TS...>> {\n    static tuple<TS...> scan1(istream& in) {\n        return scan1_impl<0>(in);\n    }\nprivate:\n    template<i64 I, SFINAE(sizeof...(TS) == I)>\n    static auto scan1_impl(istream&) {\n        return make_tuple();\n    }\n    template<i64 I, SFINAE(sizeof...(TS) > I)>\n    static auto scan1_impl(istream& in) {\n        using T = tuple_element_t<I,tuple<TS...>>;\n        auto head = make_tuple(Scan1<T>::scan1(in));\n        return tuple_cat(head, scan1_impl<I+1>(in));\n    }\n};\n\ntemplate<typename T=i64>\nT RD() {\n    return Scan<T>::scan(cin);\n}\n\ntemplate<typename T=i64>\nT RD1() {\n    return Scan1<T>::scan1(cin);\n}\n\ntemplate<typename T=i64>\nauto RD_VEC(i64 n) {\n    auto res = vec_reserve<T>(n);\n    REP(_, n) {\n        res.emplace_back(RD<T>());\n    }\n    return res;\n}\n\ntemplate<typename T=i64>\nauto RD1_VEC(i64 n) {\n    auto res = vec_reserve<T>(n);\n    REP(_, n) {\n        res.emplace_back(RD1<T>());\n    }\n    return res;\n}\n\ntemplate<typename T=i64>\nauto RD_VEC2(i64 h, i64 w) {\n    auto res = vec_reserve<vector<T>>(h);\n    REP(_, h) {\n        res.emplace_back(RD_VEC<T>(w));\n    }\n    return res;\n}\n\ntemplate<typename T=i64>\nauto RD1_VEC2(i64 h, i64 w) {\n    auto res = vec_reserve<vector<T>>(h);\n    REP(_, h) {\n        res.emplace_back(RD1_VEC<T>(w));\n    }\n    return res;\n}\n// }}}\n\n// output {{{\ntemplate<typename T, typename Enable=void>\nstruct Fmt {\n    static void fmt(ostream& out, const T& x) { out << x; }\n};\n\ntemplate<typename T>\nvoid fmt_write(ostream& out, const T& x) {\n    Fmt<T>::fmt(out, x);\n}\n\ntemplate<typename... TS>\nstruct Fmt<tuple<TS...>> {\n    static void fmt(ostream& out, const tuple<TS...>& t) {\n        tuple_enumerate(t, [&out](i64 i, const auto& e) {\n            if(i != 0) out << ' ';\n            fmt_write(out, e);\n        });\n    }\n};\n\ntemplate<typename T1, typename T2>\nstruct Fmt<pair<T1,T2>> {\n    static void fmt(ostream& out, const pair<T1,T2>& p) {\n        return fmt_write(out, make_tuple(p.first,p.second));\n    }\n};\n\ntemplate<typename C>\nstruct Fmt<C,enable_if_t<is_container<C>::value>> {\n    static void fmt(ostream& out, const C& c) {\n        for(auto it = begin(c); it != end(c); ++it) {\n            if(it != begin(c)) out << ' ';\n            fmt_write(out, *it);\n        }\n    }\n};\n\nvoid PRINT() {}\n\ntemplate<typename T, typename... TS>\nvoid PRINT(const T& x, const TS&... args) {\n    fmt_write(cout, x);\n    if(sizeof...(args) > 0) {\n        cout << ' ';\n        PRINT(args...);\n    }\n}\n\ntemplate<typename... TS>\nvoid PRINTLN(const TS&... args) {\n    PRINT(args...);\n    cout << '\\n';\n}\n// }}}\n\n// debug {{{\ntemplate<typename T, typename Enable=void>\nstruct Dbg {\n    static void dbg(ostream& out, const T& x) { out << x; }\n};\n\ntemplate<typename T>\nvoid dbg_write(ostream& out, const T& x) {\n    return Dbg<T>::dbg(out, x);\n}\n\ntemplate<>\nstruct Dbg<i64> {\n    static void dbg(ostream& out, i64 x) {\n        if(x == INF)\n            out << \"INF\";\n        else if(x == -INF)\n            out << \"-INF\";\n        else\n            out << x;\n    }\n};\n\ntemplate<>\nstruct Dbg<f64> {\n    static void dbg(ostream& out, f64 x) {\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wfloat-equal\"\n        if(x == FINF)\n            out << \"FINF\";\n        else if(x == -FINF)\n            out << \"-FINF\";\n        else\n            out << x;\n#pragma GCC diagnostic pop\n    }\n};\n\ntemplate<typename T, size_t N>\nstruct Dbg<T[N]> {\n    static void dbg(ostream& out, const T (&ary)[N]) {\n        out << \"[\";\n        REP(i, N) {\n            if(i != 0) out << \",\";\n            dbg_write(out, ary[i]);\n        }\n        out << \"]\";\n    }\n};\n\ntemplate<typename... TS>\nstruct Dbg<tuple<TS...>> {\n    static void dbg(ostream& out, const tuple<TS...>& t) {\n        out << \"(\";\n        tuple_enumerate(t, [&out](i64 i, const auto& e) {\n            if(i != 0) out << \",\";\n            dbg_write(out, e);\n        });\n        out << \")\";\n    }\n};\n\ntemplate<typename T1, typename T2>\nstruct Dbg<pair<T1,T2>> {\n    static void dbg(ostream& out, const pair<T1,T2>& p) {\n        return dbg_write(out, make_tuple(p.first,p.second));\n    }\n};\n\ntemplate<typename C>\nstruct Dbg<C,enable_if_t<is_container<C>::value>> {\n    static void dbg(ostream& out, const C& c) {\n        out << \"[\";\n        for(auto it = begin(c); it != end(c); ++it) {\n            if(it != begin(c)) out << \",\";\n            dbg_write(out, *it);\n        }\n        out << \"]\";\n    }\n};\n\ntemplate<typename T, typename C>\nstruct Dbg<stack<T,C>> {\n    static void dbg(ostream& out, stack<T,C> stk) {\n        out << \"[\";\n        while(!stk.empty()) {\n            dbg_write(out,stk.top()); stk.pop();\n            if(!stk.empty()) out << \",\";\n        }\n        out << \"]\";\n    }\n};\n\ntemplate<typename T, typename C>\nstruct Dbg<queue<T,C>> {\n    static void dbg(ostream& out, queue<T,C> que) {\n        out << \"[\";\n        while(!que.empty()) {\n            dbg_write(out,que.front()); que.pop();\n            if(!que.empty()) out << \",\";\n        }\n        out << \"]\";\n    }\n};\n\ntemplate<typename T, typename C, typename Comp>\nstruct Dbg<priority_queue<T,C,Comp>> {\n    static void dbg(ostream& out, priority_queue<T,C,Comp> que) {\n        out << \"[\";\n        while(!que.empty()) {\n            dbg_write(out,que.top()); que.pop();\n            if(!que.empty()) out << \",\";\n        }\n        out << \"]\";\n    }\n};\n\ntemplate<typename T>\nvoid DBG_IMPL(i64 line, const char* expr, const T& value) {\n    cerr << \"[L \" << line << \"]: \";\n    cerr << expr << \" = \";\n    dbg_write(cerr, value);\n    cerr << \"\\n\";\n}\n\nvoid DBG_IMPL_HELPER() {}\n\ntemplate<typename T, typename... TS>\nvoid DBG_IMPL_HELPER(const T& x, const TS&... args) {\n    dbg_write(cerr, x);\n    if(sizeof...(args) > 0) {\n        cerr << \",\";\n        DBG_IMPL_HELPER(args...);\n    }\n}\n\ntemplate<typename... TS>\nvoid DBG_IMPL(i64 line, const char* expr, const TS&... value) {\n    cerr << \"[L \" << line << \"]: \";\n    cerr << \"(\" << expr << \") = (\";\n    DBG_IMPL_HELPER(value...);\n    cerr << \")\\n\";\n}\n\ntemplate<size_t N, typename T, SFINAE(rank<T>::value == 0)>\nvoid DBG_DP_IMPL_HELPER(ostream& out, const T& x, const array<i64,N>&, const array<i64,N>&) {\n    dbg_write(out, x);\n}\n\ntemplate<size_t N, typename T, SFINAE(rank<T>::value > 0)>\nvoid DBG_DP_IMPL_HELPER(ostream& out, const T& x, const array<i64,N>& sizes, const array<i64,N>& offs) {\n    i64 k   = N - rank<T>::value;\n    i64 off = offs[k];\n    i64 siz = sizes[k];\n    if(siz == 0) siz = extent<T>::value - off;\n\n    out << \"[\";\n    FOR(i, off, off+siz) {\n        if(i != off) out << \",\";\n        DBG_DP_IMPL_HELPER(out, x[i], sizes, offs);\n    }\n    out << \"]\";\n}\n\ntemplate<typename T, SFINAE(rank<T>::value > 0)>\nvoid DBG_DP_IMPL(i64 line, const char* expr, const T& dp,\n                 const array<i64,rank<T>::value>& sizes={},\n                 const array<i64,rank<T>::value>& offs={})\n{\n    cerr << \"[L \" << line << \"]: \";\n    cerr << expr << \" = \";\n    DBG_DP_IMPL_HELPER<rank<T>::value>(cerr, dp, sizes, offs);\n    cerr << \"\\n\";\n}\n\ntemplate<typename T>\nvoid DBG_GRID_IMPL(i64 line, const char* expr, const vector<T>& grid) {\n    cerr << \"[L \" << line << \"]: \";\n    cerr << expr << \":\\n\";\n    for(const auto& row : grid) {\n        dbg_write(cerr, row);\n        cerr << \"\\n\";\n    }\n    cerr << \"\\n\";\n}\n\n#ifdef PROCON_LOCAL\n    #define DBG(args...) DBG_IMPL(__LINE__, CPP_STR_I(args), args)\n    #define DBG_DP(args...) DBG_DP_IMPL(__LINE__, CPP_STR_I(args), args)\n    #define DBG_GRID(args...) DBG_GRID_IMPL(__LINE__, CPP_STR_I(args), args)\n#else\n    #define DBG(args...)\n    #define DBG_DP(args...)\n    #define DBG_GRID(args...)\n#endif\n// }}}\n\n// modint {{{\ntemplate<i64 M>\nstruct ModIntT {\n    static_assert(M >= 2, \"\");\n    i64 v_;  // [0,M)\n\n    ModIntT() : v_(0) {}\n    ModIntT(i64 v) {\n        i64 r = v % M;\n        v_ = r >= 0 ? r : r+M;\n    }\n\n    ModIntT operator-() const {\n        return ModIntT(-v_);\n    }\n    ModIntT& operator+=(ModIntT rhs) {\n        v_ += rhs.v_;\n        v_ %= M;\n        return *this;\n    }\n    ModIntT& operator-=(ModIntT rhs) {\n        v_ += M;\n        v_ -= rhs.v_;\n        v_ %= M;\n        return *this;\n    }\n    ModIntT& operator*=(ModIntT rhs) {\n        v_ *= rhs.v_;\n        v_ %= M;\n        return *this;\n    }\n\n    ModIntT& operator++() {\n        return *this += 1;\n    }\n    ModIntT& operator--() {\n        return *this -= 1;\n    }\n    ModIntT operator++(int) {\n        return exchange(*this, *this+1);\n    }\n    ModIntT operator--(int) {\n        return exchange(*this, *this-1);\n    }\n\n    explicit operator i64() const { return v_; }\n\n    ModIntT inv() const {\n        i64 g,x; tie(g,x,ignore) = EXTGCD(v_, M);\n        ASSERT(g == 1);\n        return ModIntT(x);\n    }\n};\n\ntemplate<i64 M>\nModIntT<M> operator+(ModIntT<M> lhs, ModIntT<M> rhs) { return ModIntT<M>(lhs) += rhs; }\ntemplate<i64 M>\nModIntT<M> operator+(ModIntT<M> lhs, i64 rhs) { return ModIntT<M>(lhs) += rhs; }\ntemplate<i64 M>\nModIntT<M> operator+(i64 lhs, ModIntT<M> rhs) { return ModIntT<M>(rhs) += lhs; }\ntemplate<i64 M>\nModIntT<M> operator-(ModIntT<M> lhs, ModIntT<M> rhs) { return ModIntT<M>(lhs) -= rhs; }\ntemplate<i64 M>\nModIntT<M> operator-(ModIntT<M> lhs, i64 rhs) { return ModIntT<M>(lhs) -= rhs; }\ntemplate<i64 M>\nModIntT<M> operator-(i64 lhs, ModIntT<M> rhs) { return ModIntT<M>(rhs) -= lhs; }\ntemplate<i64 M>\nModIntT<M> operator*(ModIntT<M> lhs, ModIntT<M> rhs) { return ModIntT<M>(lhs) *= rhs; }\ntemplate<i64 M>\nModIntT<M> operator*(ModIntT<M> lhs, i64 rhs) { return ModIntT<M>(lhs) *= rhs; }\ntemplate<i64 M>\nModIntT<M> operator*(i64 lhs, ModIntT<M> rhs) { return ModIntT<M>(rhs) *= lhs; }\n\ntemplate<i64 M>\nbool operator==(ModIntT<M> lhs, ModIntT<M> rhs) { return lhs.v_ == rhs.v_; }\ntemplate<i64 M>\nbool operator==(ModIntT<M> lhs, i64 rhs) { return lhs == ModIntT<M>(rhs); }\ntemplate<i64 M>\nbool operator==(i64 lhs, ModIntT<M> rhs) { return ModIntT<M>(lhs) == rhs; }\ntemplate<i64 M>\nbool operator!=(ModIntT<M> lhs, ModIntT<M> rhs) { return !(lhs == rhs); }\ntemplate<i64 M>\nbool operator!=(ModIntT<M> lhs, i64 rhs) { return !(lhs == rhs); }\ntemplate<i64 M>\nbool operator!=(i64 lhs, ModIntT<M> rhs) { return !(lhs == rhs); }\n\ntemplate<i64 M>\nstruct Scan<ModIntT<M>> {\n    static ModIntT<M> scan(istream& in) {\n        return Scan<i64>::scan(in);\n    }\n};\n\ntemplate<i64 M>\nstruct Fmt<ModIntT<M>> {\n    static void fmt(ostream& out, ModIntT<M> x) {\n        fmt_write(out, x.v_);\n    }\n};\n\ntemplate<i64 M>\nstruct Dbg<ModIntT<M>> {\n    static void dbg(ostream& out, ModIntT<M> x) {\n        dbg_write(out, x.v_);\n    }\n};\n\nusing ModInt = ModIntT<MOD>;\n// }}}\n// }}}\n\n// init {{{\nstruct ProconInit {\n    static constexpr int IOS_PREC = 15;\n    static constexpr bool AUTOFLUSH = false;\n\n    ProconInit() {\n        cin.tie(nullptr);\n        ios::sync_with_stdio(false);\n        cin.exceptions(ios::failbit | ios::badbit);\n        cout << fixed << setprecision(IOS_PREC);\n#ifdef PROCON_LOCAL\n        cerr << fixed << setprecision(2);\n#endif\n        if(AUTOFLUSH)\n            cout << unitbuf;\n    }\n} PROCON_INIT;\n// }}}\n\n//--------------------------------------------------------------------\n\ntemplate<typename T>\nvoid vec_append(vector<T>& x, const vector<T>& y) {\n    x.insert(end(x), begin(y), end(y));\n}\n\nvoid solve(i64 H, i64 W) {\n    auto M = RD_VEC<string>(H);\n\n    auto enum_vert = [H,W,&M]() {\n        auto res = vec_reserve<string>(W);\n        REP(x, W) {\n            auto s = str_reserve(H);\n            REP(y, H) {\n                s.push_back(M[y][x]);\n            }\n            res.emplace_back(s);\n        }\n        return res;\n    };\n\n    auto enum_horiz = [H,W,&M]() {\n        auto res = vec_reserve<string>(H);\n        REP(y, H) {\n            auto s = str_reserve(W);\n            REP(x, W) {\n                s.push_back(M[y][x]);\n            }\n            res.emplace_back(s);\n        }\n        return res;\n    };\n\n    auto enum_diag_down = [H,W,&M]() {\n        vector<string> res;\n        auto used = vec_make<bool>(H,W, false);\n        REP(sy, H) REP(sx, W) {\n            if(used[sy][sx]) continue;\n            string s;\n            for(i64 y=sy,x=sx; !used[y][x]; y=(y+1)%H,x=(x+1)%W) {\n                used[y][x] = true;\n                s.push_back(M[y][x]);\n            }\n            res.emplace_back(s);\n        }\n        return res;\n    };\n\n    auto enum_diag_up = [H,W,&M]() {\n        vector<string> res;\n        auto used = vec_make<bool>(H,W, false);\n        REP(sy, H) REP(sx, W) {\n            if(used[sy][sx]) continue;\n            string s;\n            for(i64 y=sy,x=sx; !used[y][x]; y=(y-1+H)%H,x=(x+1)%W) {\n                used[y][x] = true;\n                s.push_back(M[y][x]);\n            }\n            res.emplace_back(s);\n        }\n        return res;\n    };\n\n    vector<string> ss;\n    vec_append(ss, enum_vert());\n    vec_append(ss, enum_horiz());\n    vec_append(ss, enum_diag_down());\n    vec_append(ss, enum_diag_up());\n    DBG(ss);\n\n    map<string,i64> m;\n    for(auto& s : ss) {\n        i64 k = SIZE(s);\n        FOR(l, 2, k+1) {\n            REP(i, k) {\n                auto t = str_reserve(k);\n                REP(j, l) {\n                    t.push_back(s[(i+j)%k]);\n                }\n                ++m[t];\n            }\n        }\n        ALL(reverse, s);\n        FOR(l, 2, k+1) {\n            REP(i, k) {\n                auto t = str_reserve(k);\n                REP(j, l) {\n                    t.push_back(s[(i+j)%k]);\n                }\n                ++m[t];\n            }\n        }\n    }\n    DBG(m);\n\n    string ans;\n    for(const auto& p : m) {\n        if(p.second < 2) continue;\n        const auto& s = p.first;\n        if(SIZE(s) < SIZE(ans)) continue;\n        if(SIZE(s) > SIZE(ans) || s < ans)\n            ans = s;\n    }\n\n    PRINTLN(ans.empty() ? \"0\" : ans);\n}\n\nsigned main() {\n    for(;;) {\n        i64 H = RD();\n        i64 W = RD();\n        if(H == 0 && W == 0) break;\n        solve(H,W);\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nint main()\n{\n    while(1)\n    {\n        int nb_lignes,nb_colonnes;\n        cin>>nb_lignes>>nb_colonnes;\n        if(nb_lignes==0)\n        {\n            break;\n        }\n        vector<string> donut(nb_lignes);\n        for(int c=0;c<donut.size();c++) cin>>donut[c];\n        int dx[8]={1,1,1,0,0,-1,-1,-1};\n        int dy[8]={0,1,-1,1,-1,0,1,-1};\n        map<string,int> m;\n        string best = \"\";\n        for(int x=0;x<nb_lignes;x++)\n        {\n            for(int y=0;y<nb_colonnes;y++)\n            {\n                for(int d=0;d<8;d++)\n                {\n                    vector<vector<bool> > visites(nb_lignes,vector<bool>(nb_colonnes,false));\n                    int xact = x;\n                    int yact = y;\n                    string act =\"\";\n                    while(!visites[xact][yact])\n                    {\n                        act=act+donut[xact][yact];\n                        m[act]++;\n                        if((act.size()>best.size()||(act.size()==best.size()&&act<best))&&m[act]>1)\n                            best=act;\n                        visites[xact][yact]=true;\n                        xact+=dx[d];\n                        yact+=dy[d];\n                        xact=(xact+nb_lignes)%nb_lignes;\n                        yact=(yact+nb_colonnes)%nb_colonnes;\n                    }\n                }\n            }\n        }\n        if(best.size()<2) cout<<0<<endl;\n        else\n            cout<<best<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint dy[] = {1, 1, 1, 0, -1, -1, -1, 0};\nint dx[] = {-1, 0, 1, 1, 1, 0, -1, -1};\n\nbool solve() {\n\tint H, W; cin >> H >> W;\n\tif (H == 0 && W == 0) return (false);\n\tvector<string> S(H);\n\tfor (int i = 0; i < H; i++) {\n\t\tcin >> S[i];\n\t}\n\tstring ans;\n\tint length = 0;\n\tunordered_set<string> st;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tfor (int k = 0; k < 8; k++) {\n\t\t\t\tbool flag[11][22] = {};\n\t\t\t\tint y = i, x = j;\n\t\t\t\tstring s;\t\n\t\t\t\tint size = 0;\n\t\t\t\twhile (!flag[y][x]) {\n\t\t\t\t\ts += S[y][x];\n\t\t\t\t\t//cout << s << endl;\n\t\t\t\t\tsize++;\n\t\t\t\t\tif (st.find(s) != st.end()) {\n\t\t\t\t\t\tif (length < size) {\n\t\t\t\t\t\t\tans = s;\n\t\t\t\t\t\t\tlength = size;\n\t\t\t\t\t\t} else if (length == size && ans > s) {\n\t\t\t\t\t\t\tans = s;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tst.insert(s);\n\t\t\t\t\tflag[y][x] = true;\n\t\t\t\t\t(y += dy[k] + H) %= H, (x += dx[k] + W) %= W;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (ans.size() > 1) {\n\t\tcout << ans << endl;\n\t} else {\n\t\tcout << 0 << endl;\n\t}\n\treturn (true);\n}\n\nint main() {\n\twhile (solve());\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nconstexpr int gcd(int a, int b){\n\treturn b == 0 ? a : gcd(b, a%b);\n}\nint main() {\n\tint h, w;\n\twhile (cin >> h >> w, h) {\n\t\tvector<string> map(h);\n\t\tfor (auto &a : map)cin >> a;\n\t\tint dx[] = { 0,0,1,1,1,-1,-1,-1 };\n\t\tint dy[] = { 1,-1,0,-1,1,0,1,-1 };\n\t\tvector<tuple<string, int, int, int>> buf;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tfor (int d = 0; d < 8; d++) {\n\t\t\t\t\tbuf.push_back(make_tuple((string)\"\" + map[i][j], j, i, d));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint l = 0;\n\t\tfor (; l < h*w / gcd(h, w); l++) {\n\t\t\tsort(buf.begin(), buf.end());\n\t\t\tvector<tuple<string, int, int, int>> buf2;\n\t\t\tfor (int i = 1; i < buf.size(); i++) {\n\t\t\t\tif (get<0>(buf[i - 1]).size() < l)continue;\n\t\t\t\tif (get<0>(buf[i - 1]) == get<0>(buf[i]))buf2.push_back(buf[i - 1]);\n\t\t\t\tfor (; i<buf.size()&&get<0>(buf[i - 1]) == get<0>(buf[i]); i++)buf2.push_back(buf[i]);\n\t\t\t}\n\t\t\tif (buf2.empty())break;\n\t\t\tbuf = move(buf2);\n\t\t\tfor (auto &a : buf) {\n\t\t\t\tstring str;\n\t\t\t\tint x, y, d;\n\t\t\t\ttie(str, x, y, d) = a;\n\t\t\t\tint x1 = ((x + dx[d]*l) % w + w) % w;\n\t\t\t\tint y1 = ((y + dy[d]*l) % h + h) % h;\n\t\t\t\tif (x1 == x && y1 == y)continue;\n\t\t\t\tstr += map[y1][x1];\n\t\t\t\ta = make_tuple(str, x, y, d);\n\t\t\t}\n\t\t}\n\t\tif (l < 2)cout << 0 << endl;\n\t\telse {\n\t\t\tstring str = get<0>(buf[0]);\n\t\t\tcout << str.substr(0, l-1) << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<string>vec;\nchar c[20][20]; int H, W; bool used[20][20];\nint dx[8] = { 1,1,1,0,-1,-1,-1,0 };\nint dy[8] = { -1,0,1,1,1,0,-1,0 };\nint main() {\n\twhile (true) {\n\t\tcin >> H >> W; vec.clear(); if (H == 0)break;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++)cin >> c[i][j];\n\t\t}\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tfor (int k = 0; k < 8; k++) {\n\t\t\t\t\tfor (int l = 0; l < 400; l++)used[i / 20][i % 20] = 0;\n\t\t\t\t\tint cx = i, cy = j; string S; S += c[cx][cy]; used[cx][cy] = 1;\n\t\t\t\t\twhile (true) {\n\t\t\t\t\t\tcx += dx[k]; cy += dy[k];\n\t\t\t\t\t\tif (used[cx][cy] == 1)break;\n\t\t\t\t\t\tused[cx][cy] = 1; S += c[cx][cy]; vec.push_back(S);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(vec.begin(), vec.end()); string T = \"0\";\n\t\tfor (int i = 1; i < vec.size(); i++) {\n\t\t\tif (vec[i - 1] == vec[i]) {\n\t\t\t\tif (vec[i].size()>T.size())T = vec[i];\n\t\t\t\telse if (vec[i].size() == T.size())T = min(T, vec[i]);\n\t\t\t}\n\t\t}\n\t\tcout << T << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max() / 32 * 15 + 208;\n\nstring maximum(string &a, string &b){\n    if(a.size() != b.size()) return (a.size() > b.size() ? a : b);\n    return min(a, b);\n}\n\nbool is_parindrome(const string &s){\n\n    return true;\n}\n\nint main() {\n    int h, w;\n    array<int, 8> dy{-1, -1, -1, 0, 0, 1, 1, 1},\n                  dx{-1, 0, 1, -1, 1, -1, 0, 1};\n    while(cin >> h >> w, h){\n        vector<string> v(h);\n        for (int i = 0; i < h; ++i) {\n            cin >> v[i];\n        }\n        string ans;\n        map<string, int> m;\n        for (int i = 0; i < h; ++i) {\n            for (int j = 0; j < w; ++j) {\n                for (int k = 0; k < 8; ++k) {\n                    int y = i, x = j;\n                    string s;\n                    vector<vector<int>> visited(h, vector<int>(w, 0));\n                    while(!visited[y][x]){\n                        s += v[y][x];\n                        visited[y][x] = 1;\n                        y = (y+dy[k]+h)%h;\n                        x = (x+dx[k]+w)%w;\n                    }\n                    for (int l = 1; l <= s.size(); ++l) {\n                        m[s.substr(0, l)]++;\n                    }\n                }\n            }\n        }\n        for (auto &&i : m) {\n            if(i.second >= 2){\n                string s = i.first;\n                ans = maximum(ans, s);\n            }\n        }\n        cout << (ans.size() <= 1 ? \"0\" : ans) << \"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\nint dx[8]={1,-1,0,0,1,1,-1,-1},dy[8]={0,0,1,-1,1,-1,1,-1};\nvoid renew(string &x,string y){\n\tif(x.size()>y.size()) return;\n\tif(x.size()<y.size()){\n\t\tx=y;\n\t\treturn;\n\t}\n\tif(x>y) x=y;\n}\nint main(){\n\twhile(true){\n\t\tint H,W;\n\t\tcin>>H>>W;\n\t\tif(H==0) break;\n\t\tstring s[10];\n\t\trep(i,H) cin>>s[i];\n\t\tstring ans;\n\t\trep(ai,H) rep(aj,W) rep(ad,8){\n\t\t\t//show(ai);\n\t\t\t//show(aj);\n\t\t\t//show(ad);\n\t\t\tstring sa;\n\t\t\tint ax=ai,ay=aj;\n\t\t\tdo{\n\t\t\t\tsa+=s[ax][ay];\n\t\t\t\tax+=dx[ad],ay+=dy[ad];\n\t\t\t\tif(ax==H) ax=0;\n\t\t\t\tif(ay==W) ay=0;\n\t\t\t\tif(ax==-1) ax=H-1;\n\t\t\t\tif(ay==-1) ay=W-1;\n\t\t\t\t//show(ax);\n\t\t\t\t//show(ay);\n\t\t\t}while(!(ax==ai&&ay==aj));\n\t\t\t//show(sa);\n\t\t\trep(bi,H) rep(bj,W) rep(bd,8){\n\t\t\t\tif(ai==bi&&aj==bj&&ad==bd) continue;\n\t\t\t\t//show(bi);\n\t\t\t\t//show(bj);\n\t\t\t\t//show(bd);\n\t\t\t\tstring sb;\n\t\t\t\tint bx=bi,by=bj;\n\t\t\t\tdo{\n\t\t\t\t\t//show(bx);\n\t\t\t\t\t//show(by);\n\t\t\t\t\tsb+=s[bx][by];\n\t\t\t\t\tbx+=dx[bd],by+=dy[bd];\n\t\t\t\t\tif(bx==H) bx=0;\n\t\t\t\t\tif(by==W) by=0;\n\t\t\t\t\tif(bx==-1) bx=H-1;\n\t\t\t\t\tif(by==-1) by=W-1;\n\t\t\t\t}while(!(bx==bi&&by==bj));\n\t\t\t\t//show(sb);\n\t\t\t\tint u=min(sa.size(),sb.size())+1,l=0;\n\t\t\t\twhile(u-l>1){\n\t\t\t\t\tint m=(u+l)/2;\n\t\t\t\t\tif(sa.substr(0,m)==sb.substr(0,m)) l=m;\n\t\t\t\t\telse u=m;\n\t\t\t\t}\n\t\t\t\trenew(ans,sb.substr(0,l));\n\t\t\t}\n\t\t}\n\t\tif(ans.size()<=1) puts(\"0\");\n\t\telse cout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\ntypedef vector<pint>vpint;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\ntemplate<class T,class U>inline void chmin(T &t,U f){if(t>f)t=f;}\ntemplate<class T,class U>inline void chmax(T &t,U f){if(t<f)t=f;}\n\nconst int dx[]={-1,0,1,-1,1,-1,0,1};\nconst int dy[]={-1,-1,-1,0,0,1,1,1};\n\nint H,W;\nchar fld[50][50];\nvoid solve(){\n    rep(i,H)cin>>fld[i];\n    map<string,int>M;\n    rep(i,H)rep(j,W)rep(d,8){\n        int y=i,x=j;\n        string hoge;\n        do{\n            hoge.pb(fld[y][x]);\n            if(hoge.size()>1)M[hoge]++;\n            y=(y+dy[d]+H)%H;\n            x=(x+dx[d]+W)%W;\n        }while(x!=j||y!=i);\n    }\n    string ans;\n    each(it,M){\n        if(it->se<=1)continue;\n        if(ans.size()<it->fi.size())ans=it->fi;\n        else if(ans.size()==it->fi.size())chmin(ans,it->fi);\n    }\n    if(ans==\"\")cout<<0<<endl;\n    else cout<<ans<<endl;\n}\n\nsigned main(){\n    while(cin>>H>>W,H||W)solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <map>\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n\n\nusing namespace std;\n\nchar d[20][30];\n\nint dx[8] = {-1, 0, 1,-1, 1,-1, 0, 1};\nint dy[8] = {-1,-1,-1, 0, 0, 1, 1, 1};\n\nint main(){\n  int h, w;\n\n  while(scanf(\"%d%d\", &h, &w), h + w){\n    map<string, int> m;\n\n    REP(i,h) scanf(\"%s\", d[i]);\n\n    REP(i,h) REP(j,w){\n      REP(k,8){\n        int x = j;\n        int y = i;\n        string tmp = \"\";\n\n        do{\n          tmp += d[y][x];\n          x = (x + w + dx[k]) % w;\n          y = (y + h + dy[k]) % h;\n          m[tmp]++;\n        }while(i != y || j != x);\n      }\n    }\n\n    string ans = \"\";\n\n    FOR(it, m) if(it->second > 1){\n      const string &s = it->first;\n\n      if(s.size() > ans.size()) ans = s;\n      else if(s.size() == ans.size() && s < ans) ans = s;\n    }\n\n    if(ans.size() > 1) puts(ans.c_str());\n    else puts(\"0\");\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <ctime>\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\n#include <random>\n#include <regex>\n#include <tuple>\n\nusing namespace std;\ntypedef long long ll;\n\n#define ALL(c) (c).begin(),(c).end()\n#define FOR(i,l,r) for(int i=(int)l;i<(int)r;++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORr(i,l,r) for(int i=(int)r-1;i>=(int)l;--i)\n#define REPr(i,n) FORr(i,0,n)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end())\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n\ntemplate<typename T,typename U> T pmod(T x,U M){return (x%M+M)%M;}\n\ntypedef long long ll;\n\n//output\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){REP(i,as.size()){if(i!=0)os<<\" \"; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<vector<T>>& as){REP(i,as.size()){if(i!=0)os<<endl; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const set<T>& ss){for(auto a:ss){if(a!=ss.begin())os<<\" \"; os<<a;}return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const pair<T1,T2>& p){os<<p.first<<\" \"<<p.second;return os;}\ntemplate<typename K,typename V> ostream& operator << (ostream& os, const map<K,V>& m){bool isF=true;for(auto& p:m){if(!isF)os<<endl;os<<p;isF=false;}return os;}\ntemplate<typename T1> ostream& operator << (ostream& os, const tuple<T1>& t){os << get<0>(t);return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const tuple<T1,T2>& t){os << get<0>(t)<<\" \"<<get<1>(t);return os;}\ntemplate<typename T1,typename T2,typename T3> ostream& operator << (ostream& os, const tuple<T1,T2,T3>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t);return os;}\ntemplate<typename T1,typename T2,typename T3,typename T4> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t);return os;}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t);return os;}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t);return os;}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t)<<\" \"<<get<6>(t);return os;}\n\nint H,W;\nvector<string> board;\nvector<vector<set<string>>> ss;\nint dx[8]={1,1,0,-1,-1,-1,0,1},dy[8]={0,1,1,1,0,-1,-1,-1};\nvector<vector<bool>> passed;\n\nstring last;\nvoid dfs(int sy,int sx,int y,int x,int dir,string s){\n\tif(passed[y][x]){last=s;return;}\n\tpassed[y][x]=true;\n\ts+=board[y][x];\n\tss[sy][sx].insert(s);\n\tdfs(sy,sx,pmod(y+dy[dir],H),pmod(x+dx[dir],W),dir,s);\n\treturn ;\n}\n\n\nmap<string,int> si;int C=0;\n\nint main() {\n\tcout <<fixed<<setprecision(15);\t\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(true){\n\t\tcin >> H >> W;if(H==0)break;\n\n\t\tboard=vector<string>(H);REP(y,H)cin >> board[y];\n\t\tsi.clear();C=0;\n\t\tss=vector<vector<set<string>>>(H,vector<set<string>>(W));\n\t\tpassed=vector<vector<bool>>(H,vector<bool>(W));\n\n\t\tmap<string,int> smap;\n\t\tREP(y,H)REP(x,W)REP(d,8){\n\t\t\tREP(_y,H)fill(ALL(passed[_y]),false);\n\t\t\tdfs(y,x,y,x,d,\"\");\n\t\t}\n\t\tREP(y,H)REP(x,W)EACH(it,ss[y][x])smap[*it]++;\n\t\t\n\t\tstring res=\"\";bool isF=true;\n\t\tEACH(it,smap)if(it->second>=2){\n\t\t\tconst string& s=it->first;\n\t\t\tif(isF)res=s;\n\t\t\tif(res.size()<s.size())res=s;\n\t\t\telse if(res.size()==s.size() && res>s)res=s;\n\t\t\tisF=false;\n\t\t}\n\t\tif(res.size()<2) cout << 0 <<endl;\n\t\telse cout << res <<endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\n\nint dx[] = {-1,0,1,1,1,0,-1,-1};\nint dy[] = {1,1,1,0,-1,-1,-1,0};\n\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\nint H,W;\nstring donut[11];\nmap<string, int> res;\n\nvoid dfs(string str,int sy,int sx, int y,int x,int a) {\n    int ny = (y+dy[a]+H) % H;\n    int nx = (x+dx[a]+W) % W;\n    res[str]++;\n    if(sy==ny && sx==nx) return;\n\n    dfs(str+donut[ny][nx],sy,sx,ny,nx,a);\n}\n\nstring cmp(string s1,string s2) {\n    if(s1.size() > s2.size()) return  s1;\n    else if(s1.size() < s2.size()) return s2;\n    else return s1 < s2 ? s1 : s2;\n}\n\nvoid solve() {\n    res.clear();\n    rep(i,11) donut[i]=\"\";\n    rep(i,H) cin>>donut[i];\n    rep(y,H) rep(x,W) {\n        rep(a,8) {\n            string tmp;\n            tmp = donut[y][x];\n            dfs(tmp,y,x,y,x,a);\n        }\n    }\n    string ans;\n    for(const auto &it : res){\n        if(it.sc >= 2) {\n            ans = cmp(ans,it.fr);\n        }\n    }\n    if(ans.size() <= 2) ans = \"0\";\n    cout<<ans<<endl;\n}\n\nint main() {\n    while(cin>>H>>W) {\n        if(H+W==0) break;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<string>\n#include<map>\nusing namespace std;\nstatic const int MAX_H = 10;\n\nint h, w;\nstring s[MAX_H];\n\nint dy[] = {0, -1, -1, -1, 0, 1, 1, 1};\nint dx[] = {1, 1, 0, -1, -1, -1, 0, 1};\n\nint main(){\n\tfor(;;){\n\t\tscanf(\"%d %d\", &h, &w);\n\t\tif(h == 0 && w == 0) break;\n\t\tfor(int i = 0; i < h; i++) cin >> s[i];\n\t\tmap<string, int> mpa;\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tint sy = i;\n\t\t\t\tint sx = j;\n\t\t\t\tfor(int k = 0; k < 8; k++){\n\t\t\t\t\tint cy = i;\n\t\t\t\t\tint cx = j;\n\t\t\t\t\tstring str;\n\t\t\t\t\tstr += s[sy][sx];\n\t\t\t\t\tmpa[str]++;\n\t\t\t\t\tfor(;;){\n\t\t\t\t\t\tcy += dy[k];\n\t\t\t\t\t\tcx += dx[k];\n\t\t\t\t\t\tcy = (cy + h) % h;\n\t\t\t\t\t\tcx = (cx + w) % w;\n\t\t\t\t\t\tif(cy == sy && cx == sx) break;\n\t\t\t\t\t\tstr += s[cy][cx];\n\t\t\t\t\t\tmpa[str]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstring res = \"0\";\n\t\tfor(map<string, int>::iterator itr = mpa.begin(); itr != mpa.end(); itr++){\n\t\t\tif(itr->second < 2 || itr->first.length() < 2) continue;\n\t\t\tif(itr->first.length() > res.length() || (itr->first.length() == res.length() && itr->first < res)) res = itr->first;\n\t\t}\n\t\tcout << res << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//Name: The Sorcerer's Donut\n//Level:\n//Category:\n//Note:\n\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <array>\n#include <map>\n\nusing namespace std;\n\n#define TIMES(i,n) for(int i = 0; i < (n); ++i)\n\nconst int DR[] = {\n    0, -1, -1, -1, 0, 1, 1, 1\n};\nconst int DC[] = {\n    1, 1, 0, -1, -1, -1, 0, 1\n};\n\narray<array<bool,20>,10> visited;\n\nstring search(int r, int c, int dir, const vector<string> &s, map<string,int> &memo) {\n    const int H = s.size();\n    const int W = s[0].size();\n    string res;\n    TIMES(i, H) {\n        TIMES(j, W) {\n            visited[i][j] = false;\n        }\n    }\n    while(!visited[r][c]) {\n        visited[r][c] = true;\n        res += s[r][c];\n        if(res.size() > 1) memo[res]++;\n        r = (r+DR[dir]+H) % H;\n        c = (c+DC[dir]+W) % W;\n    }\n    return res;\n}\n\nbool solve() {\n    int H, W;\n    cin >> H >> W;\n    if(!H && !W) return false;\n\n    vector<string> s(H);\n    TIMES(i, H) {\n        cin >> s[i];\n    }\n    map<string,int> memo;\n    for(int r = 0; r < H; ++r) {\n        for(int c = 0; c < W; ++c) {\n            for(int dir = 0; dir < 8; ++dir) {\n                search(r, c, dir, s, memo);\n            }\n        }\n    }\n    string ans = \"\";\n    for(const auto &p : memo) {\n        if(p.second < 2) continue;\n        if(p.first.size() > ans.size() || (p.first.size() == ans.size() && p.first < ans)) {\n            ans = p.first;\n        }\n    }\n    if(ans == \"\") ans = \"0\";\n    cout << ans << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\nusing ll = long long;\nconst char newl = '\\n';\n#define var auto\n\nvoid solver(int h, int w) {\n  vector< vector< char > > cs(h, vector<char>(w));\n  for (int i = 0; i < h; i += 1) {\n    for (int j = 0; j < w; j += 1) {\n      cin >> cs[i][j];\n    }\n  }\n\n  vector< int > ds{-1, 0, +1};\n  string ans;\n  set< string > st;\n\n  for (int i = 0; i < h; i += 1) {\n    for (int j = 0; j < w; j += 1) {\n      for (auto dy: ds) for (auto dx: ds) {\n        if (dy == 0 && dx == 0) continue;\n\n        string s;\n        int y = i, x = j;\n\n        do {\n          s += cs[y][x];\n          (y += dy + h) %= h;\n          (x += dx + w) %= w;\n          \n          if (st.count(s)) {\n            if (ans.size() < s.size()) ans = s;\n            else if (ans.size() == s.size() && ans > s) ans = s;\n          }\n            \n          st.insert(s);\n        } while (y != i || x != j); \n      }\n    }\n  }\n\n  if (ans.size() >= 2) cout << ans << endl;\n  else cout << 0 << endl;\n}\n\nsigned main(){\n    int h, w;\n    while (cin >> h >> w, h) {\n        solver(h, w);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[] = {0, 0, 1, -1, 1, 1, -1, -1};\nint dy[] = {1, -1, 0, 0, 1, -1, 1, -1};\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\nint H, W;\nchar board[15][25];\nbool used[15][25];\nmap<string, int> memo;\n\nvoid solve(int x, int y, int dir) {\n    string ret = \"\";\n    int s = x, t = y;\n    while(1) {\n        if(used[s][t]) break;\n        used[s][t] = true;\n        ret += board[s][t];\n        memo[ret]++;\n\n        s = (s + dx[dir] + H) % H;\n        t = (t + dy[dir] + W) % W;\n    }\n}\n\nbool isbetter(string a, string b) {\n    if(a.length() != b.length()) return a.length() > b.length();\n    else return a < b;\n}\n\nsigned main() {\n    while(cin >> H >> W, H || W) {\n        memo.clear();\n        rep(i,0,H) rep(j,0,W) cin >> board[i][j];\n        rep(i,0,H) rep(j,0,W) rep(k,0,8) {\n            memset(used, false, sizeof(used));\n            solve(i, j, k);\n        }\n        string ans = \"\";\n        for(auto elem : memo) {\n            if(elem.second < 2) continue;\n            if(elem.first.length() < 2) continue;\n            if(isbetter(elem.first, ans)) ans = elem.first;\n        }\n        if(ans == \"\") cout << 0 << endl;\n        else cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nconst int INF=INT_MAX,MOD=1e9+7;\n\nint main(){\n\tint dx[8]={0,1,1,1,0,-1,-1,-1};\n\tint dy[8]={-1,-1,0,1,1,1,0,-1};\n\tint h,w;\n\twhile(cin>>h>>w&&h){\n\t\tchar c[h][w]; rep(i,h)rep(j,w) cin>>c[i][j];\n\t\tvector<string> s;\n\t\tfor(int y=0;y<h;y++){\n\t\t\tfor(int x=0;x<w;x++){\n\t\t\t\tfor(int dir=0;dir<8;dir++){\n\t\t\t\t\tint nowy=y,nowx=x;\n\t\t\t\t\tstring tmp;\n\t\t\t\t\twhile(1){\n\t\t\t\t\t\ttmp+=c[nowy][nowx];\n\t\t\t\t\t\tnowy=(h+nowy+dy[dir])%h;\n\t\t\t\t\t\tnowx=(w+nowx+dx[dir])%w;\n\t\t\t\t\t\ts.push_back(tmp);\n\t\t\t\t\t\tif(nowy==y&&nowx==x) break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(s.begin(),s.end());\n\t\tstring ans=\"0\"; int size=1;\n\t\tfor(int i=0;i<(int)s.size()-1;i++){\n\t\t\t//cout<<s[i]<<endl;\n\t\t\tstring tmp;\n\t\t\tif(s[i]==s[i+1]){\n\t\t\t\ttmp=s[i];\n\t\t\t}\n\t\t\tif(size<(int)tmp.size()){\n\t\t\t\tans=tmp;\n\t\t\t\tsize=tmp.size();\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define SZ(x) (int)(x.size())\n#define REP(i, n) for(int i=0;i<(n);++i)\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RREP(i, n) for(int i=(int)(n)-1;i>=0;--i)\n#define RFOR(i, a, b) for(int i=(int)(b)-1;i>=(a);--i)\n#define ALL(a) a.begin(),a.end()\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define DEBUG(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<< endl;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing P = pair<int, int>;\nconst double eps = 1e-8;\nconst ll MOD = 1000000007;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\ntemplate <typename T1, typename T2>\nbool chmax(T1 &a, const T2 &b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate <typename T1, typename T2>\nbool chmin(T1 &a, const T2 &b) {\n    if (a > b) { a = b; return true; }\n    return false;\n}\ntemplate<typename T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n    os << \"[\";\n    REP(i, SZ(v)) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const map<T1, T2> &mp) {\n    os << \"{\";\n    int a = 0;\n    for (auto &tp : mp) {\n        if (a) os << \", \"; a = 1;\n        os << tp;\n    }\n    return os << \"}\";\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> &p) {\n    os << p.first << \":\" << p.second;\n    return os;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    const int di[] = {0, 1, 0, -1, 1, 1, -1, -1};\n    const int dj[] = {1, 0, -1, 0, 1, -1, 1, -1};\n\n    for (;;) {\n        int H, W; cin >> H >> W;\n        if (H == 0) break;\n        vector<string> S(H);\n        REP(i, H) cin >> S[i];\n        map<string,int> mp;\n\n        REP(si, H) REP(sj, W) {\n            REP(k, 8) {\n                string s;\n                int i = si, j = sj;\n                do {\n                    s += S[i][j];\n                    mp[s] += 1;\n                    (i += H + di[k]) %= H;\n                    (j += W + dj[k]) %= W;\n                } while (i != si or j != sj);\n            }\n        }\n        int maxlen = 0;\n        for (auto &tp : mp) {\n            if (tp.second > 1) {\n                chmax(maxlen, tp.first.size());\n            }\n        }\n        if (maxlen == 1) {\n            cout << 0 << endl;\n            continue;\n        }\n\n        string ans;\n        for (auto &tp : mp) {\n            if (tp.second > 1 and tp.first.size() == maxlen) {\n                ans = tp.first;\n                break;\n            }\n        }\n        cout << ans << endl;\n\n    }\n\n    return 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\nusing namespace std;\n\nint main()\n{\n    int dy[] = {-1, -1, 0, 1, 1, 1, 0, -1};\n    int dx[] = {0, 1, 1, 1, 0, -1, -1, -1};\n\n    for(;;){\n        int h, w;\n        cin >> h >> w;\n        if(h == 0)\n        return 0;\n\n        vector<string> grid(h);\n        for(int i=0; i<h; ++i)\n        cin >> grid[i];\n\n        set<string> ss;\n        string ret;\n        int maxLen = -1;\n        for(int y=0; y<h; ++y){\n            for(int x=0; x<w; ++x){\n                for(int d=0; d<8; ++d){\n                    int y1 = y;\n                    int x1 = x;\n                    string s;\n                    do{\n                        s += grid[y1][x1];\n                        y1 += dy[d] + h;\n                        x1 += dx[d] + w;\n                        y1 %= h;\n                        x1 %= w;\n                    }while(y1 != y || x1 != x);\n\n                    int n = s.size();\n                    while(n >= max(maxLen, 2)){\n                        string t = s.substr(0, n);\n                        if(ss.find(t) == ss.end()){\n                            ss.insert(t);\n                        }else{\n                            if(n > maxLen || (n == maxLen && t < ret)){\n                                maxLen = n;\n                                ret = t;\n                            }\n                            break;\n                        }\n                        -- n;\n                    }\n                }\n            }\n        }\n\n        if(maxLen == -1)\n        cout << 0 << endl;\n        else\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <string.h>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\nlong long int INF = 1e18;\nlong long int MOD = 1000000007;\n\nint main(){\n\t\n\twhile(true){\n\t\tint h, w;\n\t\tcin >> h >> w;\n\t\tif(h == 0){\n\t\t\tbreak;\n\t\t}\n\t\tstring str[100];\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tcin >> str[i];\n\t\t}\n\t\t\n\t\tmap<string, int> m;\n\t\tstring ans = \"\";\n\t\t\n\t\tint dx[8] = {0, 0, 1, 1, 1, -1, -1, -1};\n\t\tint dy[8] = {1, -1, 1, 0, -1, 1, 0, -1};\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tfor(int k = 0; k < 8; k++){\n\t\t\t\t\tbool used[h][w] = {};\n\t\t\t\t\tstring S = \"\", D = \" \";\n\t\t\t\t\tint y = i, x = j;\n\t\t\t\t\twhile(true){\n\t\t\t\t\t\tif(used[y][x]){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tused[y][x] = true;\n\t\t\t\t\t\tD[0] = str[y][x];\n\t\t\t\t\t\tS += D;\n\t\t\t\t\t\ty += dy[k] + h;\n\t\t\t\t\t\tx += dx[k] + w;\n\t\t\t\t\t\ty %= h;\n\t\t\t\t\t\tx %= w;\n\t\t\t\t\t\tif(m.find(S) == m.end()){\n\t\t\t\t\t\t\tm[S] = 1;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif(ans.size() < S.size()){\n\t\t\t\t\t\t\t\tans = S;\n\t\t\t\t\t\t\t}else if(ans.size() == S.size() && ans > S){\n\t\t\t\t\t\t\t\tans = S;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans.size() == 1){\n\t\t\tcout << 0 << endl;\n\t\t}else{\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i, s, e) for(int i = (int)(s); i < (int)(e); ++i)\n#define rep(i, n) REP(i, 0, n)\nint main() {\n  int h, w;\n  while(cin >> h >> w) {\n    if(h == 0 && w == 0) break;\n    vector<string> s(h);\n    rep(i, h) cin >> s[i];\n    map<string, int> mp;\n    rep(i, h) rep(j, w) {\n      REP(dx, -1, 2) REP(dy, -1, 2) {\n\tif(dx == 0 && dy == 0) continue;\n\t//cout << i << \" \" << j << \" \" << dy << \" \" << dx << endl;\n\tstring tmp;\n\ttmp += s[i][j];\n\tint x = (j + dx + w) % w;\n\tint y = (i + dy + h) % h;\n\twhile(1) {\n\t  // cout << y << \" \" << x << endl; \n\t  if(x == j && y == i) break;\n\t  tmp += s[y][x];\n\t  x = (x + dx + w) % w;\n\t  y = (y + dy + h) % h;\n\t  mp[tmp]++;\n\t}\n\t// mp[tmp]++;\n\t// cout << i << \" \" << j << \" \" << dy << \" \" << dx << \" \" << tmp << endl;\n      }\n    }\n    string ans;\n    for(const auto& p : mp) {\n      if(p.second == 1) continue;\n      if(ans.size() < p.first.size()) ans = p.first;\n      else if(ans.size() == p.first.size()) {\n\tans = min(ans, p.first);\n      }\n    }\n    if(ans == \"\") cout << 0 << endl;\n    else cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <string>\nusing namespace std;\nint w,h;\nstring ans;\nstring ptn[30];\nint di[] = {0,1,0,-1, 1,1,-1,-1};\nint dj[] = {1,0,-1,0, 1,-1,-1,1};\n\nint main(){\n  string s;\n  while( cin >> h >> w && (h|w) ){\n    for( int i=0;i<h;i++ ){\n      cin >> ptn[i];\n    }\n    ans=\"\";\n    map<string,int> mp;\n    for( int st=0;st<h;st++ ){\n      for( int en=0;en<w;en++ ){\n\tfor( int lp=0;lp<8;lp++ ){\n\t  int i=st, j=en;\n\t  //\t  cout << ptn[i][j] << endl;\n\t  string s = ptn[i].substr(j,1);\n\t  while( true ){\n\t    i+=di[lp]; j+=dj[lp];\n\t    if( i==h ) i=0;\n\t    else if( i==-1) i=h-1;\n\t    if( j==w ) j=0;\n\t    else if( j==-1 ) j=w-1;\n\t    if( i==st && j==en )\n\t      break;\n\t    s += ptn[i][j];\n\t    if( s.length() < ans.length() )\n\t      continue;\n\t    mp[s]++;\n\t    if( mp[s]==2 ){\n\t      if( s.length() > ans.length() )\n\t\tans = s;\n\t      else if( s.length()==ans.length() && s < ans )\n\t\tans = s;\n\t    }\n\t  }\n\t}\t  \n      }\n    }\n    if( ans.length()<2 )\n      cout << 0 << endl;\n    else\n      cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stdio.h>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define dirmax 8\nint l[2];\nint dir[8][2] = { {0,1}, {1,0}, {-1,0}, {0,-1}, {1,1}, {-1,1}, {1,-1}, {-1,-1} };\n\nvoid search( vector<string> *v, int pos[2] , char ch[10][20] ){\n\n\tfor(int i = 0; i < dirmax; i++) {\n\t\tstring str;\n\t\tint cpos[] = { pos[0], pos[1] };\n\n\t\tstr += ch[pos[0]][pos[1]];\n\t\tv->push_back(str);\n\n\t\twhile( true ) {\n\t\t\tfor(int j = 0; j < 2; j++) {\n\t\t\t\tcpos[j] += dir[i][j];\n\t\t\t\tif( cpos[j] < 0 ) cpos[j] = l[j] - 1;\n\t\t\t\tif( cpos[j] >= l[j] ) cpos[j] = 0;\n\t\t\t}\n\t\t\tif( cpos[0] == pos[0] && cpos[1] == pos[1] ) break;\n\t\t\tstr += ch[cpos[0]][cpos[1]];\n\t\t\tv->push_back(str);\n\t\t}\n\t\t\n\n\t}\n}\n\nint main(void){\n\t//FILE* fp_in = freopen(\"data.txt\", \"r\", stdin);\n\n\twhile(1){\n\t\tcin >> l[0] >> l[1];\n\t\tif( l[0] == 0 && l[1] == 0 ) break;\n\t\tchar donut[10][20];\n\n\t\tvector< string > strs;\n\n\t\t//入力を取得する\n\t\tfor(int i = 0; i < l[0]; i++) {\n\t\t\tstring str;\n\t\t\tcin >> str;\n\t\t\tfor(int j = 0; j < l[1]; j++){\n\t\t\t\tdonut[i][j] = str[j];\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < l[0]; i++) {\n\t\t\tfor(int j = 0; j < l[1]; j++) {\n\t\t\t\tint pos[2];\n\t\t\t\tpos[0] = i;\n\t\t\t\tpos[1] = j;\n\t\t\t\tsearch( &strs, pos, donut );\n\t\t\t}\n\t\t}\n\t\tsort( strs.begin(), strs.end() );\n\n\t\tstring ans = \"\";\n\t\tfor(int i = 0; i < strs.size(); i++) {\n\t\t\tfor(int j = i + 1; j < strs.size(); j++) {\n\t\t\t\tif( strs[i] == strs[j] && ans.length() < strs[i].length() && strs[i].length() > 1) {\n\t\t\t\t\tans = strs[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans == \"\") \n\t\t\tcout << 0 << endl;\n\t\telse \n\t\t\tcout << ans << endl;\n\n\t}\n\t//while(1){}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,a,n) for(i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,1,-1,1,-1};\n\nint main(void) {\n  int i,j;\n  int h, w;\n  while(cin >> h >> w, h){\n      vs s(h);\n      rep(i,h) cin >> s[i];\n      map<string,int> ma;\n      rep(i,h)rep(j,w)rep(k,8){\n          string t = \"\";\n          t += s[i][j];\n          int x = (i + dx[k] + h)%h;\n          int y = (j + dy[k] + w)%w;\n          while(x != i || y != j){\n              t += s[x][y];\n              ma[t]++;\n              x = (x + dx[k] + h)%h;\n              y = (y + dy[k] + w)%w;\n          }\n      }\n      string ans = \"\";\n      for(auto itr=ma.begin();itr!=ma.end();itr++){\n          if(itr->second >= 2){\n              string t = itr->first;\n              if(ans.size() < t.size()) ans = t;\n          }\n      }\n      if(ans == \"\"){\n          cout << 0 << endl;\n      }else{\n          cout << ans << endl;\n      }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr int di8[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconstexpr int dj8[] = {1, 1, 0, -1, -1, -1, 0, 1};\n\nint solve(){\n    int h, w;\n    cin >> h >> w;\n    if(h == 0) return 1;\n    vector<string> s(h);\n    for(int i=0;i<h;i++){\n        cin >> s[i];\n    }\n    map<string,int> cnt;\n    for(int k=0;k<8;k++){\n        vector<vector<bool> > used(h, vector<bool>(w));\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                if(used[i][j]) continue;\n                int len = 0, ni = i, nj = j;\n                string t;\n                while(!used[ni][nj]){\n                    t.push_back(s[ni][nj]);\n                    used[ni][nj] = true;\n                    ni = (ni+di8[k]+h)%h;\n                    nj = (nj+dj8[k]+w)%w;\n                }\n                len = t.size();\n                t += t;\n                for(int l=0;l<len;l++){\n                    for(int x=2;x<=len;x++){\n                        cnt[t.substr(l,x)]++;\n                    }\n                }\n            }\n        }\n    }\n    string ans = \"\";\n    for(auto p : cnt){\n        string t = p.first;\n        if(p.second >= 2){\n            if(t.size() > ans.size()){\n                ans = t;\n            }else if(t.size() == ans.size()){\n                ans = min(ans, t);\n            }\n        }\n    }\n    if(ans.empty()) ans = \"0\";\n    cout << ans << endl;\n    return 0;\n}\n\nint main(){\n    while(solve()==0);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n//C++11\n#if __cplusplus == 201103L\n#include <tuple>\n#endif\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\ntypedef pair<int, string> P;\nint H, W;\nbool used[20][20];\nvoid rec(int x, int y, int dx, int dy, string s, map<string, int>& count, vector<string>& grid){\n  count[s] += 1;\n  used[y][x] = true;\n  int nx = (x + dx + W) % W;\n  int ny = (y + dy + H) % H;\n  if(used[ny][nx]) return;\n  rec(nx, ny, dx, dy, s + grid[ny][nx], count, grid);\n}\n\nint main(){\n  int dx[8] = {1,1,1,0,-1,-1,-1,0};\n  int dy[8] = {-1,0,1,1,1,0,-1,-1};\n  while(cin>>H>>W && H){\n    vector<string> grid(H);\n    REP(y, H) cin>>grid[y];\n    map<string, int> count;\n    REP(y, H)REP(x, W)REP(r, 8){\n      memset(used, 0, sizeof(used));\n      rec(x, y, dx[r], dy[r], string() + grid[y][x], count, grid);\n    }\n    vector<P> v;\n    FORIT(it, count)if((it->first).size() >= 2 && it->second >= 2) v.push_back(P(-1*(it->first).size(), it->first));\n    string ans;\n    if(v.empty()) ans = \"0\";\n    else ans = (*min_element(v.begin(), v.end())).second;\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n\nusing namespace std;\n\n#define REP(i,n) for (int i=0; i<n; i++)\n\nint main(){\n  \n  while (1){\n    int w, h;\n    char mp[20][30];\n    const int diff[] = {1, 0, -1, 0, 1, 1, -1, -1, 1};\n    map<string, int> spells;\n    string input, ans=\"\";\n    \n    cin >> h >> w;\n    if (w==0 && h==0){\n      break;\n    }\n    \n    REP(j, h){\n      cin >> input;\n      REP(k, w){\n        mp[j][k] = input[k];\n      }\n    }\n    \n    REP(j0, h){\n      REP(k0, w){\n        REP(i,8){\n//          printf(\"(%d, %d) i=%d\\n\", j0, k0, i);\n          string str = \"\";\n          int j=j0, k=k0;\n          while(1){\n//            printf(\"(%d, %d)\\n\", j, k);\n            str += mp[j][k];\n            spells[str]++;\n            if (spells[str]>1){\n              if (ans.length() < str.length() || (ans.length()==str.length() && ans > str)){\n                ans = str;\n              }\n            }\n            j = (j+diff[i]+h)%h;\n            k = (k+diff[i+1]+w)%w;\n            if (j==j0 && k==k0){\n              break;\n            }\n          }\n//          cout << str << endl;\n        \n        }\n      }\n    }\n    \n    if (ans.length()<2){\n      cout << 0 << endl;\n    }else{\n      cout << ans << endl;\n    }\n    \n    \n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n   \nusing namespace std;\n\nint w, h;\nstring s[21];\n\nstring solve()\n{\n    vector<string> result;\n    int cnt = 0, wcnt = 0, hcnt = 0;\n    int dx[8] = {1, 0, -1, 0, 1, 1, -1, -1};\n    int dy[8] = {0, 1, 0, -1, 1, -1, 1, -1};\n    for(int i = 0; i < h; i++){\n        for(int j = 0; j < w; j++){\n            // ???????????????s[i][j]\n            for(int k = 0; k < 8; k++){\n                string tmp = \"\";\n                int sx = i, sy = j;\n                while(!(sx == i && sy == j) || tmp.length() == 0){\n                    tmp += s[sx][sy];\n                    // cout << tmp << endl;\n                    sx += dx[k];\n                    sy += dy[k];\n                    if(sx >= h) sx = 0;\n                    if(sy >= w) sy = 0;\n                    if(sx < 0) sx = h - 1;\n                    if(sy < 0) sy = w - 1;\n                }\n                result.push_back(tmp);\n            }\n        }\n    }\n    sort(result.begin(), result.end());\n    string ans = \"\";\n    for(int i = 0; i < result.size() - 1; i++){\n        // cout << result[i] << endl;\n        if(result[i].length() < ans.length()) continue;\n        int cnt = 0;\n        string nowans = \"\";\n        while(cnt < min(result[i].length(), result[i + 1].length())){\n            if(result[i][cnt] == result[i + 1][cnt]){\n                nowans += result[i][cnt];\n                cnt++;\n            } else {\n                break;\n            }\n        }\n        if(nowans.length() > ans.length()) ans = nowans;\n    }\n    if(ans.length() < 2) return \"0\";\n    else return ans;\n}\n\nint main()\n{\n    while(1){\n        cin >> h >> w;\n        if(h == 0 && w == 0) break;\n        for(int i = 0; i < h; i++){\n            cin >> s[i];\n        }\n        cout << solve() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define INF 1001000100010001000\n#define MOD 1000000007\n#define EPS 1e-10\n#define int long long\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define Rep(i, N) for (int i = 1; i < N; i++)\n#define For(i, a, b) for (int i = (a); i < (b); i++)\n#define pb push_back\n#define mp make_pair\n#define i_i pair<int, int>\n#define vi vector<int>\n#define vvi vector<vi >\n#define vb vector<bool>\n#define vvb vector<vb >\n#define vp vector< i_i >\n#define all(a) (a).begin(), (a).end()\n#define Int(x) int x; scanf(\"%lld\", &x);\n \n//int dxy[5] = {0, 1, 0, -1, 0};\nint dx[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nint dy[8] = {1, 0, -1, 1, -1, 1, 0, -1};\n// assign\n \nstring comp(string a, string b);\n\nsigned main()\n{\n    int n, m;\n    while (cin >> n >> m, n) {\n        vector<string> donut(n);\n        rep(i, n) {\n            cin >> donut[i];\n        }\n        set<string> can;\n        string ans = \"z\";\n        rep(i, n) {\n            rep(j, m) {\n                rep(k, 8) {\n                    vvb used(n, vb(m, false));\n                    string spell;\n                    int x = i, y = j;\n                    while (!used[x][y]) {\n                        spell.pb(donut[x][y]);\n                        used[x][y] = true;\n                    if (can.find(spell) != can.end()) {\n                    //cout << spell << endl;\n                        ans = comp(ans, spell);\n                    } else {\n                        can.insert(spell);\n                    }\n                        x = (x + dx[k] + n) % n; y = (y + dy[k] + m) % m;\n                    }\n                    /*if (can.find(spell) != can.end()) {\n                    //cout << spell << endl;\n                        ans = comp(ans, spell);\n                    } else {\n                        can.insert(spell);\n                    }*/\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\nstring comp(string a, string b)\n{\n    if (a.length() < b.length()) {\n        return b;\n    } else if (a.length() > b.length()) {\n        return a;\n    } else {\n        rep(i, a.length()) {\n            if (a[i] < b[i]) {\n                return a;\n            } else if (a[i] > b[i]) {\n                return b;\n            }\n        }\n    }\n    return a;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <algorithm>\nusing  namespace std;\n\nint dr[]={-1, -1, -1, 0, 0, 1, 1, 1};\nint dc[]={-1, 0, 1, -1, 1, -1, 0, 1};\n\nbool cmp(const string& a, const string& b)\n{\n    if (a.size()<b.size()) return false;\n    if (a.size()>b.size()) return true;\n    return a<b;\n}\n\nint main()\n{\n    int n, m;\n    while (scanf(\"%d%d\", &n, &m), n) {\n        char s[11][21];\n        for(int i=0;i<n;++i) scanf(\"%s\", s[i]);\n\n        vector<string> spells;\n        for(int i=0;i<n;++i) for(int j=0;j<m;++j) for(int k=0;k<8;++k) {\n            int r=i, c=j, q=0;\n            string t;\n            do {\n                t+=s[r][c];\n                if (t.size()>1) spells.push_back(t);\n                r=(r+dr[k]+2*n)%n;\n                c=(c+dc[k]+2*m)%m;\n            } while (r!=i || c!=j);\n        }\n        sort(begin(spells), end(spells), cmp);\n\n        string res;\n        for(int i=1;i<spells.size();++i) if (spells[i]==spells[i-1]) {\n            res=spells[i];\n            break;\n        }\n        puts(res.size()?res.c_str():\"0\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <climits>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <random>\n#include <cctype>\n#include <complex>\n#include <regex>\n\nusing namespace std;\n\n#define C_MAX(a, b) ((a)>(b)?(a):(b))\n#define SHOW_VECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOW_MAP(v){std::cerr << #v << endl; for(const auto& xxx: v){std::cerr << xxx.first << \" \" << xxx.second << \"\\n\";}}\n\nint dx[] = {0, 1, 0, -1, 1, 1, -1, -1};\nint dy[] = {1, 0, -1, 0, -1, 1, 1, -1};\n\nbool comp(string &a, string &b) {\n    if (a.size() < b.size()) return true;\n    if (a.size() > b.size()) return false;\n    return a > b;\n}\n\nint main() {\n\n    while (true) {\n        int H, W;\n        cin >> H >> W;\n\n        if (!(H | W)) break;\n\n        vector<string> M(H);\n        for (int i = 0; i < H; i++) cin >> M[i];\n\n        map<string, int> MAP;\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                for (int k = 0; k < 8; k++) {\n                    string s = \"\";\n                    vector<vector<bool>> B(H, vector<bool>(W, false));\n                    int y = i, x = j;\n                    while (true) {\n                        if (B[y][x]) break;\n                        s += M[y][x];\n                        MAP[s] += 1;\n                        B[y][x] = true;\n                        y += (2 * H + dy[k]);\n                        y %= H;\n                        x += (2 * W + dx[k]);\n                        x %= W;\n                    }\n                }\n            }\n        }\n\n        vector<string> cand;\n        for (auto x: MAP) if (x.second >= 2) cand.push_back(x.first);\n\n        sort(cand.begin(), cand.end(), comp);\n        if (cand.back().size() <= 1) cout << 0 << endl;\n        else cout << cand.back() << endl;\n\n    }\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\nusing namespace std;\nconst int dy[] = {1, -1, 0, 0, 1, -1, 1, -1};\nconst int dx[] = {0, 0, 1, -1, 1, -1, -1, 1};\nint h, w, sy, sx, max_size;\nmap<string, int> mp;\nstring table[15];\nstring str;\nvoid solve(char ch)\n{\n\tfor(int i = 0; i < 8; i++)\n\t{\n\t\tint ny = sy;\n\t\tint nx = sx;\n\t\tstr = \"\";\n\t\twhile(1)\n\t\t{\n\t\t\tstr += table[ny][nx];\n\t\t\tmp[str]++;\n\t\t\tif(mp[str] >= 2)\n\t\t\t\tmax_size = max(max_size, (int)str.size());\n\t\t\tint tmp_y = ny + dy[i];\n\t\t\tint tmp_x = nx + dx[i];\n\t\t\tif(tmp_y < 0) tmp_y = h - 1;\n\t\t\tif(tmp_x < 0) tmp_x = w - 1;\n\t\t\tif(tmp_y >= h) tmp_y = 0;\n\t\t\tif(tmp_x >= w) tmp_x = 0;\n\t\t\tny = tmp_y;\n\t\t\tnx = tmp_x;\n\t\t\tif(tmp_y == sy && tmp_x == sx)\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\t\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile(cin >> h >> w, h | w)\n\t{\n\t\tmp.clear();\n\t\tstr = \"\";\n\t\tmax_size = 2;\n\t\tfor(int i = 0; i < h; i++)\n\t\t{\n\t\t\tcin >> table[i];\n\t\t}\n\t\tfor(int i = 0; i < h; i++)\n\t\t{\n\t\t\tfor(int j = 0; j < w; j++)\n\t\t\t{\n\t\t\t\tsy = i; sx = j;\n\t\t\t\tsolve(table[i][j]);\n\t\t\t}\n\t\t}\n\t\tbool flag = false;\n\t\tfor(auto itr = mp.begin(); itr != mp.end(); itr++)\n\t\t{\n\t\t\tif(itr->second >= 2 && itr->first.size() == max_size)\n\t\t\t{\n\t\t\t\tflag = true;\n\t\t\t\tcout << itr->first << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!flag)\n\t\t\tcout << 0 << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// region template\n#define rep(i, a, b) for (int i = (a); i < (b); ++i)\n#define trav(a, x) for (auto &a : x)\n#define all(x) begin(x), end(x)\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nll gcd(ll a, ll b) { return __gcd(a, b); }\n\nll euclid(ll a, ll b, ll &x, ll &y) {\n    if (b) { ll d = euclid(b, a % b, y, x);\n        return y -= a/b * x, d; }\n    return x = 1, y = 0, a;\n}\n\ntypedef unsigned long long ull;\ntypedef long double ld;\null mod_mul(ull a, ull b, ull M) {\n    ll ret = a * b - M * ull(ld(a) * ld(b) / ld(M));\n    return ret + M * (ret < 0) - M * (ret >= (ll)M);\n}\null mod_pow(ull b, ull e, ull mod) {\n    ull ans = 1;\n    for (; e; b = mod_mul(b, b, mod), e /= 2)\n        if (e & 1) ans = mod_mul(ans, b, mod);\n    return ans;\n}\n\nconst ll mod = 1000000007;\nstruct Mod {\n    ll x;\n    Mod(ll xx) : x(xx) {}\n    Mod operator+(Mod b) { return Mod((x + b.x) % mod); }\n    Mod operator-(Mod b) { return Mod((x - b.x) % mod); }\n    Mod operator*(Mod b) { return Mod((x * b.x) % mod); }\n    Mod operator/(Mod b) { return *this * invert(b); }\n    Mod invert(Mod a) {\n        ll x, y, g = euclid(a.x, mod, x, y);\n        assert(g == 1); return Mod((x + mod) % mod);\n    }\n    Mod operator^(ll e) {\n        if (!e) return Mod(1);\n        Mod r = *this ^ (e / 2); r = r * r;\n        return e & 1 ? *this * r : r;\n    }\n};\n// endregion\n\nint n, m;\nstring grid[20];\nmap<string, int> mp;\n\nvoid gen2(string s) {\n    int l = s.length();\n    rep(i, 0, l) {\n        string k;\n        rep(j, 0, l) {\n            k += s[(i + j) % l];\n            if (k.size() > 1) mp[k]++;\n        }\n    }\n}\n\nvoid gen(string s) {\n    gen2(s);\n    reverse(s.begin(), s.end());\n    gen2(s);\n}\n\nint main() {\n    for (;;) {\n        cin >> n >> m; if (!n) break;\n        mp.clear();\n\n        for (int i = 0; i < n; i++) {\n            cin >> grid[i];\n        }\n\n        for (int i = 0; i < n; i++) {\n            string buf;\n            for (int j = 0; j < m; j++) {\n                buf += grid[i][j];\n            }\n            // cout << buf << endl;\n            gen(buf);\n        }\n\n        for (int j = 0; j < m; j++) {\n            string buf;\n            for (int i = 0; i < n; i++) {\n                buf += grid[i][j];\n            }\n            // cout << buf << endl;\n            gen(buf);\n        }\n\n        int g = __gcd(n, m);\n        for (int a = 0; a < g; a++) {\n            string buf;\n            for (int b = 0, i = a, j = 0; b < n * m / g; ++b, ++i %= n, ++j %= m) {\n                buf += grid[i][j];\n            }\n            // cout << buf << endl;\n            gen(buf);\n        }\n        for (int a = 0; a < g; a++) {\n            string buf;\n            for (int b = 0, i = a, j = 0; b < n * m / g; ++b, ++i %= n, j = (j + m - 1) % m) {\n                buf += grid[i][j];\n            }\n            // cout << buf << endl;\n            gen(buf);\n        }\n\n        string best = \"\";\n        for (auto p : mp) {\n            if (p.second >= 2 && (p.first.size() > best.size() || p.first.size() == best.size() && p.first < best)) {\n                best = p.first;\n            }\n        }\n        cout << (best.size() ? best.c_str() : \"0\") << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1316\n\n#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<numeric>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define dump(a) (cerr << #a << \"=\" << (a) << endl)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl;\n\nusing namespace std;\n\nint H,W;\nvector< vector<char> > matrix;\nmap<string, int> spell_map;\n\nint dx[8] = {1,1,0,-1,-1,-1,0,1};\nint dy[8] = {0,1,1,1,0,-1,-1,-1};\n\nstring mystrcmp(string str1, string str2)\n{\n\tif(str1.length() == str2.length()){\n\t\treturn (str1 <= str2) ? str1 : str2;\n\t}else{\n\t\treturn (str1.length() > str2.length()) ? str1 : str2;\n\t}\n}\n\nvoid dfs(int sx, int sy, int x, int y, int d, string spell)\n{\n\tint nx = (x + dx[d] + W) % W;\n\tint ny = (y + dy[d] + H) % H;\n\n\tspell_map[spell]++;\n\n\tif(nx == sx && ny == sy){ \n\t\t return; \n\t}else{\n\t\tdfs(sx,sy,nx,ny,d,spell+matrix[ny][nx]);\n\t}\n}\n\nint main()\n{\n\twhile(cin >> H >> W && H)\n\t{\n\t\tmatrix.assign(H,vector<char>(W));\n\t\tspell_map.clear();\n\t\t\n\t\trep(h,H){\n\t\t\trep(w,W){\n\t\t\t\tcin >> matrix[h][w];\n\t\t\t}\n\t\t}\n\n\t\trep(y,H){\n\t\t\trep(x,W){\n\t\t\t\trep(d,8){\n\t\t\t\t\tstring str;\n\t\t\t\t\tstr = str + matrix[y][x];\n\t\t\t\t\tdfs( x, y, x, y, d, str);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstring ans;\n\t\tfor(auto &it : spell_map){\n\t\t\tif(it.second >= 2){\n\t\t\t\tans = mystrcmp( ans, it.first );\n\t\t\t}\n\t\t}\n\n\t\tcout << ((ans.length() >= 2) ? ans : \"0\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n \nusing namespace std;\n \nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n \n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n \ntypedef long long ll;\nint const inf = 1<<29;\n \nint H, W;\nvector<string> F;\n \nint dx[8] = {-1,0,1,0,-1,1,1,-1};\nint dy[8] = {0,-1,0,1,-1,-1,1,1};\n \nunordered_map<string, int> mp;\n \nvoid go(int y, int x, int dir, int sy, int sx) {\n  string s;\n  while(1) {\n    s += F[y][x];\n    int ny = y + dy[dir];\n    int nx = x + dx[dir];\n    if(ny >= H) { ny = 0; }\n    if(ny < 0) { ny = H-1; }\n    if(nx >= W) { nx = 0; }\n    if(nx < 0) { nx = W-1; }\n    if(ny == sy && nx == sx) { break; }\n    y = ny, x = nx;\n    mp[s]++;\n  }\n  mp[s] ++;\n}\n \nint main() {\n \n  for(; cin >> H >> W && (H | W);) {\n \n    F.clear(); rep(i, H) F.resize(H);\n    vector<string> v;\n    rep(i, H) cin >> F[i];\n    mp.clear();\n    rep(i, H) rep(j, W) {\n      rep(k, 8) {\n        go(i, j, k, i, j);\n      }\n    }\n \n    vector<string> u;\n    for(auto && e: mp) {\n      if(e.first.size() > 1 && e.second > 1) {\n        u.push_back(e.first);\n      }\n    }\n \n    if(u.empty()) {\n      cout << 0 << endl;\n    }\n    else {\n      sort(all(u), [&](string const& s, string const& t){ int n=s.size(),m=t.size(); return n != m ? n > m : s < t; });\n      cout << u[0] << endl;\n    }\n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nint dx[8] = {-1, 0, 1,-1,1,-1,0,1};\nint dy[8] = {-1,-1,-1, 0,0, 1,1,1};\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int H, W;\n  while(cin>>H>>W,H){\n\tvector<string> lns(H);\n\tREP(i,H) cin>>lns[i];\n\n\tmap<string, int> mpsi;\n\tREP(y,H) REP(x,W){\n\t  REP(i,8){\n\t\tint tx = x, ty = y;\n\t\tstring s = \"\";\n\t\tvector< vector<bool> > used(H, vector<bool>(W, false));\n\t\twhile(true){\n\t\t  if(used[ty][tx]) break;\n\t\t  used[ty][tx] = true;\n\t\t  s.append(1, lns[ty][tx]);\n\t\t  tx = (tx + dx[i] + W) % W;\n\t\t  ty = (ty + dy[i] + H) % H;\n\t\t  mpsi[s]++;\n\t\t}\n\t  }\n\t}\n\tint len = 0;\n\tstring s = \"\";\n\tfor(auto it=mpsi.begin();it!=mpsi.end();++it){\n\t  if(it->second < 2) continue;\n\t  if(len < SZ(it->first) || (len == SZ(it->first) && it->first < s))\n\t\tlen = SZ(it->first), s = it->first;\n\t}\n\n\tif(len < 2) cout << 0 << endl;\n\telse cout << s << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nchar s[10][21];\nbool used[10][20];\nint main() {\n\tint h, w;\n\twhile (scanf(\"%d%d\", &h, &w), h) {\n\t\trep(i, h)scanf(\"%s\", s[i]);\n\t\tmap<string, int>mp;\n\t\trep(i, h)rep(j, w) {\n\t\t\tfor (int dx = -1; dx <= 1; dx++) {\n\t\t\t\tfor (int dy = -1; dy <= 1; dy++) {\n\t\t\t\t\tif (dx == 0 && dy == 0)continue;\n\t\t\t\t\tstring t;\n\t\t\t\t\tmemset(used, 0, sizeof(used));\n\t\t\t\t\tint x = i, y = j;\n\t\t\t\t\twhile (!used[x][y]) {\n\t\t\t\t\t\tt += s[x][y]; used[x][y] = 1; x += dx; y += dy;\n\t\t\t\t\t\tx = (x + h) % h; y = (y + w) % w;\n\t\t\t\t\t\tmp[t]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstring ans = \"0\";\n\t\tfor (auto p : mp) {\n\t\t\tif (p.second > 1 && ans.size() < p.first.size())ans = p.first;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define FOR(i, a, b) for(int i=(a);i<(b);i++)\n#define REP(i, n) FOR(i, 0, n)\n#define RFOR(i, a, b) for(int i=(a);i>=(b);i--)\n#define RREP(i, n) RFOR(i, n, 0)\n#define MFOR(i, m) for(auto i=(m).begin();i!=(m).end();i++)\n#define ALL(a) (a).begin(), (a).end()\n#define SZ(x) ((int)(x).size())\n\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vll;\ntypedef vector<vll> vvll;\n\nconst double eps = 1e-10;\nconst int MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\n\ntemplate<typename T>\nvoid printv(vector<T> const& s) {\n  REP(i, SZ(s)) {\n    cout << s[i];\n    if(i == SZ(s)-1) {\n      cout << endl;\n    } else {\n      cout << \" \";\n    }\n  }\n}\n\nvi dx = {0, -1, -1, -1, 0, 1, 1, 1};\nvi dy = {1, 1, 0, -1, -1, -1, 0, 1};\n\nstring solve(int h, int w, const vector<vector<char>> &donuts) {\n  string res = \"A\";\n  map<string, bool> m;\n  REP(i, h) {\n    REP(j, w) {\n      vector<string> s;\n      REP(k, 8) {\n        string tmp = \"\";\n        int posi = i, posj = j;\n        tmp += donuts[posi][posj];\n        posi = (posi + dy[k] + h) % h;\n        posj = (posj + dx[k] + w) % w;\n        while(posi != i || posj != j) {\n          s.push_back(tmp);\n          // if(i == 4 && j == 5 && k == 5) cout << posi << \":\" << posj << endl;\n          tmp += donuts[posi][posj];\n          posi = (posi + dy[k] + h) % h;\n          posj = (posj + dx[k] + w) % w;\n        }\n        // if(i == 4 && j == 5 && k == 5) cout << tmp << endl;\n        s.push_back(tmp);\n      }\n      // printv(s);\n      REP(k, SZ(s)) {\n        if(m[s[k]] && (res == \"A\" || SZ(res) < SZ(s[k]) || (SZ(res) == SZ(s[k]) && s[k] < res))) {\n          res = s[k];\n        }\n      }\n      REP(k, SZ(s)) {\n        m[s[k]] = true;\n      }\n    }\n  }\n  return res;\n}\n\nint main () {\n  cin.tie(0);\n  cout << fixed << setprecision(10);\n  \n  while(1) {\n    int h, w; cin >> h >> w;\n    if(h == 0 && w == 0) break;\n    vector<vector<char>> donuts(h, vector<char>(w));\n    REP(i, h) {\n      REP(j, w) {\n        cin >> donuts[i][j];\n      }\n    }\n    string ans = solve(h, w, donuts);\n    cout << ((SZ(ans) == 1) ? \"0\" : ans) << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint lcm(int a,int b){\t//a,b < 20だしいいよね\n\t\tif (a < b){\n\t\t\tswap(a,b);\n\t\t}\n\t\tint times = a * b;\n\t\tvector<int> num;\n\t\tint gcd,lcm;\n\t\twhile(1){\n\t\t\tint n;\n\t\t\tn = a % b;\n\t\t\tif(n == 0){\tbreak;}\n\t\t\ta = b;\n\t\t\tb = n;\n\t\t}\n\t\tgcd = b;\n\t\tlcm = times / gcd;\n\treturn lcm;\n}\n\nint main(){\n\tint h,w;\n\twhile(1){\n\t\tcin >> h >> w ;\n\t\tif(h == 0 && w == 0){\tbreak;}\n\t\tchar donut[10][20];\n\t\tfor(int i=0;i<10;i++){\n\t\t\tfor(int j=0;j<20;j++){\n\t\t\t\tdonut[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tstring code[1600];\n\t\tbool much[1600];\n\t\tfor(int i = 0; i < 1600; i++){\n\t\t\tcode[i] = \"\";\n\t\t\tmuch[i] = true;\n\t\t}\t//初期化…\n\n\t\tint l = lcm(w,h);\t//ななめの最大数\n\t\tint a = 0;\t//strの数を数えます\n\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j =0; j < w; j++){\n\t\t\t\tcin >> donut[i][j];\n\t\t\t}\n\t\t}\t//input\n\n\t\tfor(int y = 0; y < h; y++){\n\t\t\tfor(int x = 0; x < w; x++){\n\t\t\t\tfor(int i = 0; i < h; i++){\t//縦列\n\t\t\t\t\tcode[a].append(1,donut[(y + i)%h][x]);\n\t\t\t\t\tcode[a+1].append(1,donut[abs(h-(y + i)%h-1)][x]);\n\t\t\t\t}\n\t\t\t\ta += 2;\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tcode[a].append(1,donut[y][(x + j)%w]);\n\t\t\t\t\tcode[a+1].append(1,donut[y][abs(w-(x+j)%w-1)]);\n\t\t\t\t}\n\t\t\t\ta += 2;\n\t\t\t\tfor(int k = 0; k < l; k++){\t//ここが間違っている！！！！\n\t\t\t\t\tcode[a].append(1,donut[(y + k)%h][(x + k)%w]);\n\t\t\t\t\tcode[a+1].append(1,donut[(y + k)%h][(l + x - k)%w]);\n\t\t\t\t\tcode[a+2].append(1,donut[(l + y - k)%h][(x + k)%w]);\n\t\t\t\t\tcode[a+3].append(1,donut[(l + y - k)%h][(l + x - k)%w]);\n\t\t\t\t}\n\t\t\t\ta += 4;\n\t\t\t}\n\t\t}\n\t\tint b = a;\n\t\tstring mag = \"\";\n\t\t//a:strの数-1\n\n\t\tsort(code,code+a);//nとn+1を比べます\n\n\t\tfor(int i = 0; i < a-1; i++){\n\t\t\tif(code[i][0] != code[i+1][0]){\n\t\t\t\tmuch[i+1] = false;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 1; i < l; i++){\t//2文字目から\n\t\t\tfor(int j = a-1; j > 0; j--){\t//逆順\n\t\t\t\tif(much[j] == true && code[j].length() > i+1 && code[j-1].length() > i+1){\n\t\t\t\t\t//jのi文字目とj-1のi文字目を比べるよ\n\t\t\t\t\tif(code[j][i] != code[j-1][i]){\n\t\t\t\t\t\tmuch[j] = false;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tmag = code[j];\n\t\t\t\t\t\tmag.resize(i+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(mag == \"\"){\n\t\t\tcout << \"0\" << endl;\n\t\t}else{\n\t\t\tcout << mag << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<ctime>\n#include<cctype>\n#include<climits>\n#include<iostream>\n#include<iomanip>\n#include<string>\n#include<vector>\n#include<map>\n#include<list>\n#include<queue>\n#include<deque>\n#include<set>\n#include<unordered_set>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<memory>\n#include<functional>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define MP make_pair\n#define PB push_back\n#define MOD 1000000007\n#define INF (1LL<<30)\n#define LLINF (1LL<<60)\n#define PI 3.14159265359\n#define EPS 1e-12\n//#define int ll\n\nint dx[] = {-1, 0, 1, 1, 1, 0, -1, -1}, dy[] = {-1, -1, -1, 0, 1, 1, 1, 0};\nint st2[15][25];\nstring s[15];\nsigned main(void)\n{\n\twhile(true) {\n\t\tint h, w;\n\t\tcin >> h >> w;\n\t\tif(!h && !w) break;\n\t\tREP(i, h) cin >> s[i];\n\n\t\tunordered_set<string> st;\n\t\tstring ans = \"\";\n\t\tFOR(dist, 2, h*w+1) REP(i, h) REP(j, w) REP(vec, 8) {\n\t\t\tint y = i, x = j;\n\t\t\tstring tmp = \"\";\n\t\t\tbool flag = true;\n\t\t\t//st2?????????\n\t\t\tREP(k, h) REP(l, w) st2[k][l] = 0;\n\t\t\t//????????????????????§?????????????????¢?????£????????????\n\t\t\tREP(k, dist) {\n\t\t\t\ttmp += s[y][x];\n\t\t\t\t//cout << y << \" \" << x << \" \" << s[y][x] << endl;\n\t\t\t\tx += dx[vec];\n\t\t\t\ty += dy[vec];\n\t\t\t\tif(x < 0) x = w-1;\n\t\t\t\telse if(x >= w) x = 0;\n\t\t\t\tif(y < 0) y = h-1;\n\t\t\t\telse if(y >= h) y = 0;\n\t\t\t\tif(st2[y][x] == 1) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tst2[y][x] = 1;\n\t\t\t}\n\t\t\t//if(i == 3 && j == 5 && vec == 2) cout << tmp << endl;\n\t\t\t//st???????????¢????????????????????¨?????????ans??????????????´??°\n\t\t\tif(flag) {\n\t\t\t\tif(st.find(tmp) != st.end()) {\n\t\t\t\t\tif(tmp.size() > ans.size() || (tmp.size() == ans.size() && tmp < ans)) {\n\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t//cout << i << \" \" << j << \" \" << vec << \" \" << ans << endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tst.insert(tmp);\n\t\t\t}\n\t\t}\n\t\tif(ans == \"\") cout << 0 << endl;\n\t\telse cout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF INT_MAX/3\n\n#define MAX_N 1000\n\nint h,w;\nstring s[11];\n\nint dx[]={-1,0,1,-1,1,-1,0,1};\nint dy[]={-1,-1,-1,0,0,1,1,1};\n\nint main(){\n\tcin.sync_with_stdio(false);\n\twhile(1){\n\t\tcin>>h>>w;\n\t\tif(h==0)break;\n\t\trep(i,h)cin>>s[i];\n\t\tstring res=\"\";\n\t\tmap<string,int> smap;\n\t\trep(i,h)rep(j,w){\n\t\t\trep(d,8){\n\t\t\t\tstring ss;\n\t\t\t\tss+=s[i][j];\n\t\t\t\tint ny=i+dy[d],nx=j+dx[d];\n\t\t\t\tif(ny>=h)ny=0;\n\t\t\t\tif(ny<0)ny=h-1;\n\t\t\t\tif(nx>=w)nx=0;\n\t\t\t\tif(nx<0)nx=w-1;\n\t\t\t\twhile(ny!=i||nx!=j){\n\t\t\t\t\tss+=s[ny][nx];\n\t\t\t\t\tsmap[ss]++;\n\t\t\t\t\tif(smap[ss]==2){\n\t\t\t\t\t\tif(ss.length()>res.length()||(ss.length()==res.length()&&ss<res)){\n\t\t\t\t\t\t\tres=ss;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tny+=dy[d],nx+=dx[d];\n\t\t\t\t\tif(ny>=h)ny=0;\n\t\t\t\t\tif(ny<0)ny=h-1;\n\t\t\t\t\tif(nx>=w)nx=0;\n\t\t\t\t\tif(nx<0)nx=w-1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(res==\"\")cout<<0<<endl;\n\t\telse cout<<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define RREP(i,n) for(ll i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<n;++i)\n#define RFOR(i,m,n) for(ll i=n-1;i>=m;--i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB(a) push_back(a)\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(i, (v).size()) { cout << v[i]; if (i != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile (1) {\n\t\tint h, w;\n\t\tcin >> h >> w;\n\t\tif (!h)break;\n\t\tvector<string> v(h);\n\t\tREP(i, h)cin >> v[i];\n\t\tset<string> st;\n\t\tstring ans = \"\";\n\t\tREP(i, h) {\n\t\t\tREP(j, w) {\n\t\t\t\tREP(k, 8) {\n\t\t\t\t\tint ni = i, nj = j;\n\t\t\t\t\tstring s;\n\t\t\t\t\ts += v[i][j];\n\t\t\t\t\tREP(l, INF) {\n\t\t\t\t\t\tif (!st.insert(s).second) {\n\t\t\t\t\t\t\tif (ans.size() < s.size())ans = s;\n\t\t\t\t\t\t\telse if (ans.size() == s.size() && ans > s)ans = s;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tni = (ni + dx[k] + h) % h, nj = (nj + dy[k] + w) % w;\n\t\t\t\t\t\tif (ni == i&&nj == j)break;\n\t\t\t\t\t\ts += v[ni][nj];\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ans.size() <= 1)cout << 0 << endl;\n\t\telse cout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <string>\nusing namespace std;\nint main(){\n  //?????¶????????§?§£????????¨?????????\n  int H, W;\n  while(cin >> H >> W, H||W){\n    string pattern[H];\n    for(int i = 0; i < H; ++i){\n      cin >> pattern[i];\n    }\n    int ng = H*W + 1, ok = 2;\n    int dx[] = {1,0,-1,0,1,1,-1,-1}, dy[] = {0,1,0,-1,1,-1,1,-1};\n    string ans = \"0\";\n    while(ng - ok > 1){\n      int m = (ng + ok)/2;\n      map<string,int> M;\n      for(int i = 0; i < H; ++i){\n\tfor(int j = 0; j < W; ++j){\n\t  for(int k = 0; k < 8; ++k){\n\t    string str(m,'.');\n\t    str[0] = pattern[i][j];\n\t    bool f = true;\n\t    for(int l = 1; l < m; ++l){//??????????????????\n\t      int s = ((i + l*dx[k])%H+H)%H, t = ((j + l*dy[k])%W+W)%W;\n\t      if(s == i && t == j){\n\t\tf = false;\n\t\tbreak;\n\t      }else{\n\t\tstr[l] = pattern[s][t];\n\t\t//str += pattern[s][t];\n\t      }\n\t    }\n\t    //cout << str << endl;\n\t    if(f){\n\t      M[str] += 1;\n\t    }\n\t  }\n\t}\n      }\n      bool g = false;\n      for(map<string,int>::iterator itr = M.begin(); itr != M.end(); ++itr){\n\tif(itr->second > 1){\n\t  g = true;\n\t  ans = itr->first;\n\t}\n      }\n      \n      if(g){\n\tok = m;\n      }else{\n\tng = m;\n      }\n\n    }\n    \n    cout << ans << endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint gcd(int a, int b){\n    while(a != b){\n        if(a > b) a = a - b; else b = b - a;\n    }\n    return a;\n}\n\nint lcm(int a, int b){\n    return ((a / gcd(a, b)) * b);\n}\n\nint main(){\n    int h, w;\n    while(true){\nchar torus[10][20];\n        string str[2048];\n        bool ok[2048];\n        int num = 0;\n\n        for(int i=0; i<2048; ++i){\n            str[i] = \"\";\n            ok[i] = true;\n        }\n\n        cin >> h >> w;\n        if(h==0 && w==0) break;\n\n        int cml = lcm(w, h);\n\n        for(int i=0; i<h; ++i){\n            for(int j=0; j<w; ++j){\n                cin >> torus[i][j];\n            }\n        }\n\n        //一番長い文字列をつくる\n\n        for(int y=0; y<h; ++y){\n            for(int x=0; x<w; ++x){\n                for(int i=0; i<h; ++i){\n                    str[num] += torus[(y+i)%h][x];\n                    str[num+1] += torus[h-(y+i)%h-1][x];\n                }\n                num += 2;\n            }\n        }\n        for(int y=0; y<h; ++y){\n            for(int x=0; x<w; ++x){\n                for(int i=0; i<w; ++i){\n                    str[num] += torus[y][(x+i)%w];\n                    str[num+1] += torus[y][w-(x+i)%w-1];\n                }\n                num += 2;\n            }\n        }\n        for(int y=0; y<h; ++y){\n            for(int x=0; x<w; ++x){\n                for(int i=0; i<cml; ++i){\n                    str[num] += torus[(y+i)%h][(x+i)%w];\n                    str[num+1] += torus[(y+i)%h][w-(x+i)%w-1];\n                    str[num+2] += torus[h-(y+i)%h-1][(x+i)%w];\n                    str[num+3] += torus[h-(y+i)%h-1][w-(x+i)%w-1];\n                }\n                num += 4;\n            }\n        }\n\n\n        string result = \"\";\n\n        sort(str, str+num);\n\n        for(int i=0; i<num-1; ++i){\n            int length = 0;\n            for(int j=0; j<min(str[i].length(), str[i+1].length()); ++j){\n                if(str[i][j] == str[i+1][j]) ++length; else break;\n            }\n            if(length == result.length()){\n                result = min(result, str[i].substr(0, length));\n            }else if(length > result.length()){\n                result = str[i].substr(0, length);\n            }\n        }\n\n        cout << ((result.length() == 1) ? \"0\" : result) << endl;\n\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <set>\nusing namespace std;\n \nconst int dy[8] = {1,1,1,0,0,-1,-1,-1};\nconst int dx[8] = {-1,0,1,-1,1,-1,0,1};\n \nint h,w;\nstring str[10];\n \nvoid solve(){\n  int y, x, ansn = 0;\n  string ans = \"0\", st;\n  set<string> s;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      for(int k=0;k<8;k++){\n        st.clear();\n        st += str[i][j];\n        y = i;\n        x = j;\n        while(1){\n          y = (y + h + dy[k]) % h;\n          x = (x + w + dx[k]) % w;\n          if(y == i && j == x) break;\n          else st += str[y][x];\n          if(!s.empty() && s.find(st) != s.end()){\n            if(ansn < st.size() || ansn == st.size() && ans > st){\n              ans = st;\n              ansn = st.size();\n            }\n          } else if(st.size() >= ansn) s.insert(st);\n        }\n \n      }\n    }\n  }\n  cout << ans << endl;\n}\n \nint main(){\n  while(cin >> h >> w && (h|w)){\n    for(int i=0;i<h;i++){\n      cin >> str[i];\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<vector>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nint dx[] = {-1, -1, -1, 0, 0, 1, 1, 1};\nint dy[] = {-1, 0, 1, -1, 1, -1, 0, 1};\n\nint main() {\n  int h, w;\n  while (true) {\n    set<string> s;\n    vector<string> vs;\n    string res;\n    cin >> h >> w;\n    if (h == 0 && w == 0) break;\n    rep (i, h) {\n      string str;\n      cin >> str;\n      vs.push_back(str);\n    }\n    rep (i, h) rep (j, w) rep (d, 8) {\n      int x = j, y = i;\n      string str;\n      do {\n\tstr += vs[y][x];\n\t//cout << i << \" \" << j << \" \" << d << \" \" << str << endl;\n\tx = (x + w + dx[d]) % w;\n\ty = (y + h + dy[d]) % h;\n\tif (str.size() > 1u) {\n\t  if (s.count(str) > 0) {\n\t    if (res.size() < str.size()) {\n\t      res = str;\n\t    } else if (res.size() == str.size() && res > str) {\n\t      res = str;\n\t    }\n\t  } else {\n\t    s.insert(str);\n\t  }\n\t}\n      } while (y != i || x != j);\n    }\n    if (res == \"\") {\n      cout << 0 << endl;\n    } else {\n      cout << res << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <string>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\n// w := 幅, h := 高さ, len := 最も長い文字列の長さ\nint w, h, len;\n// memo[y][x] := (x,y) を調べたかどうか\nbool memo[20][20];\n// S := 登場した文字列\nset<string> S;\n// ans := 解の候補\nvector<string> ans;\n\nint dx[8] = {-1,-1,-1, 0, 0,+1,+1,+1};\nint dy[8] = {-1, 0,+1,-1,+1,-1, 0,+1};\n\n// memo の初期化\nvoid clear_memo(){\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tmemo[y][x] = false;\n\t\t}\n\t}\n}\n\nvoid f(const vector<string>& v, int sx, int sy){\n\t\n\tfor(int i=0 ; i < 8 ; i++ ){\n\t\tstring s;\n\t\tclear_memo();\n\t\tmemo[sy][sx] = true;\n\t\ts.push_back( v[sy][sx] );\n\t\tint mx = (sx + dx[i] + w) % w;\n\t\tint my = (sy + dy[i] + h) % h;\n\t\twhile( true ){\n\t\t\t// すでに調べているとき\n\t\t\tif( memo[my][mx] ) break;\n\t\t\tmemo[my][mx] = true;\n\t\t\t\n\t\t\ts.push_back( v[my][mx] );\n\t\t\tif( S.count( s ) ){ // 2回目以降の登場した文字列\n\t\t\t\tif( len <= s.size() ){\n\t\t\t\t\tlen = s.size();\n\t\t\t\t\tans.push_back( s );\n\t\t\t\t}\n\t\t\t}else{ // 初めてならsetに追加\n\t\t\t\tS.insert( s );\n\t\t\t}\n\t\t\tmx = (mx + dx[i] + w) % w;\n\t\t\tmy = (my + dy[i] + h) % h;\n\t\t}\n\t}\n}\n\nstring solve(const vector<string>& v){\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tf(v,x,y);\n\t\t}\n\t}\n\t\n\t// 解がないとき\n\tif( ans.size() == 0 ){\n\t\treturn \"0\";\n\t}\n\tvector<string> vs;\n\tfor(int i=0 ; i < ans.size() ; i++ ){\n\t\tif( ans[i].size() == len ){\n\t\t\tvs.push_back( ans[i] );\n\t\t}\n\t}\n\tsort( vs.begin() , vs.end() );\n\treturn vs[0];\n}\n\nint main(){\n\twhile( cin >> h >> w , h || w ){\n\t\t// 初期化\n\t\tS.clear();\n\t\tans.clear();\n\t\tlen = 0;\n\t\t\n\t\tvector<string> v(h);\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tcin >> v[y];\n\t\t}\n\t\tstring s = solve(v);\n\t\tcout << s << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(int)(a); (i)<(int)(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(int)(a)-1; (i)>=(int)(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntemplate<class T> bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T> bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\ntemplate<class T> T div_floor(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>=0 ? a/b : (a+1)/b-1;\n}\ntemplate<class T> T div_ceil(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>0 ? (a-1)/b+1 : a/b;\n}\n\nconstexpr lint mod = 1e9+7;\nconstexpr lint INF = mod * mod;\nconstexpr int MAX = 300010;\n\nint dx[8] = {-1, -1, 0, 1, 1, 1, 0, -1};\nint dy[8] = {0, 1, 1, 1, 0, -1, -1, -1};\n\nint main(){\n    int h, w;\n    while(scanf(\"%d%d\", &h, &w) && h){\n        string s[h];\n        rep(i, h) cin >> s[i];\n        map<string, int> mp;\n        rep(sx, h)rep(sy, w)rep(i, 8){\n            string tmp;\n            int x = sx, y = sy;\n            do{\n                tmp += s[x][y];\n                ++mp[tmp];\n                x = (x + dx[i] + h) % h;\n                y = (y + dy[i] + w) % w;\n            }while(x != sx || y != sy);\n        }\n\n        string ans = \"0\";\n        for(auto &p: mp)if(p.se >= 2){\n            if(ans.size() < p.fi.size() || (ans.size() == p.fi.size() && ans > p.fi)){\n                ans = p.fi;\n            }\n        }\n        cout << ans << \"\\n\";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<map>\nusing namespace std;\nint dy[8]={-1,-1,0,1,1,1,0,-1};\nint dx[8]={0,1,1,1,0,-1,-1,-1};\nchar t[20][20];\nmap<string,int> u;\nint h,w;\nbool visited[20][20];\n\nvoid func(int y,int x,int d){\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      visited[i][j]=false;\n  string str=\"\";\n  while(!visited[y][x]){\n    visited[y][x]=true;\n    str.push_back(t[y][x]);\n    u[str]++;\n    int ny=y+dy[d],nx=x+dx[d];\n    if(ny<0)ny=h-1;\n    if(ny>=h)ny=0;\n    if(nx<0)nx=w-1;\n    if(nx>=w)nx=0;\n    y=ny;x=nx;\n  }\n}\n\nint main(){\n  while(1){\n    cin>>h>>w;\n    if(h==0&&w==0)break;\n    u.clear();\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n\tcin>>t[i][j];\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n\tfor(int k=0;k<8;k++)\n\t  func(i,j,k);\n    string ans=\"\";\n    map<string,int> :: iterator it;\n    for(it=u.begin();it!=u.end();it++){\n      if(it->second<2)continue;\n      if(it->first.size()>ans.size())ans=it->first;\n      else if(it->first.size()==ans.size()&&it->first<ans)ans=it->first;\n    }\n    if((int)ans.size()<2)cout<<0<<endl;\n    else cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define var auto\nusing ll = long long;\nconst char newl = '\\n';\ntemplate <typename T1, typename T2> inline void chmin(T1& a, T2 b) {if(a > b) a = b;}\ntemplate <typename T1, typename T2> inline void chmax(T1& a, T2 b) {if(a < b) a = b;}\n\nusing namespace std;\n\nsigned main(){\n    while(true){\n        int h, w;\n        cin >> h >> w;\n        if (h == 0) return 0;\n        vector<string> s(h);\n        for (int i = 0; i < h; i++) cin >> s[i];\n\n        vector<pair<int, int>> dirs{\n            make_pair(1, 1),\n            make_pair(0, 1),\n            make_pair(-1, 1),\n            make_pair(1, 0),\n            make_pair(-1, 0),\n            make_pair(1, -1),\n            make_pair(0, -1),\n            make_pair(-1, -1),\n        };\n\n        string longest = \"\";\n\n        unordered_set<string> se{};\n        for (int i = 0; i < h; i++){\n            for (int j = 0; j < w; j++){\n                for (auto&& dir : dirs){\n                    int y = i, x = j;\n                    string cur = \"\";\n                    cur += s[y][x];\n                    do{\n                        y += dir.first;\n                        x += dir.second;\n                        if (y < 0) y += h;\n                        if (x < 0) x += w;\n                        if (h <= y) y -= h;\n                        if (w <= x) x -= w;\n                        if (y == i && x == j) break;\n                        cur += s[y][x];\n                        //cout << cur << endl;\n                        if (!se.insert(cur).second){\n                            if (cur.size() > longest.size() || (cur.size() == longest.size() && cur < longest)) longest = cur;\n                        }\n                    }\n                    while (true);\n                }\n            }\n        }\n\n\n        cout << (longest.size() == 0 ? \"0\" : longest) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<climits>\n#include<iostream>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<list>\n#include<map>\n#include<set>\ntypedef long long ll;\ntypedef unsigned long long ull;\nusing namespace std;\n#define pb push_back\nint dy[]={0, 0, 1, -1, 1, 1, -1, -1};\nint dx[]={1, -1, 0, 0, 1, -1, 1, -1};\n \n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n\nint gcd (int a,int b){\n    if(a < b){\n        int c = b;\n        b = a;\n        a = c;\n    }\n\n    if(a % b == 0)\n        return b;\n    return gcd(b,a % b);\n}\n\nint lcm(int a,int b){\n    return a * b / gcd(a,b);\n}\n\nint main(){\n    while(1){\n        int h,w;\n        scanf(\"%d%d\",&h,&w);\n        if(h == 0 && w == 0)\n            break;\n\n        char donuts[10][21];\n        for(int i = 0;i < h;i++)\n            scanf(\"%s\",&donuts[i][0]);\n\n        int maxi = 0;\n        char s[1000] = \"\";\n        for(int i = 0;i < h * w * 8;i++){\n            for(int j = i + 1;j < h * w * 8;j++){\n                int h1 = i / (w * 8),w1 = i % (w * 8) / 8,d1 = i % (w * 8) % 8;\n                int h2 = j / (w * 8),w2 = j % (w * 8) / 8,d2 = j % (w * 8) % 8;\n                int maxlen;\n                if(d1 < 2)\n                    maxlen = w;\n                else if(d1 < 4)\n                    maxlen = h;\n                else\n                    maxlen = lcm(w,h);\n                if(d2 < 2){\n                    if(maxlen > w)\n                        maxlen = w;\n                }\n                else if(d2 < 4 && maxlen > h)\n                    maxlen = h;\n\n                int len = 0;\n                char kari[1000];\n                for(int k = 0;k < maxlen;k++){\n                    int y1 = (h1 + dy[d1] * k + h * 1000) % h,x1 = (w1 + dx[d1] * k + w * 1000) % w;\n                    int y2 = (h2 + dy[d2] * k + h * 1000) % h,x2 = (w2 + dx[d2] * k + w * 1000) % w;\n                    if(donuts[y1][x1] == donuts[y2][x2]){\n                        len++;\n                        kari[k] = donuts[y1][x1];\n                        kari[k + 1] = '\\0';\n                    }else\n                        break;\n                }\n                if(maxi < len){\n                    maxi = len;\n                    strcpy(s,kari);\n                }else if(maxi == len && strcmp(s,kari) > 0){\n                    strcpy(s,kari);\n                }\n            }\n        }\n        if(strlen(s) > 1)\n            printf(\"%s\\n\",s);\n        else\n            printf(\"0\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nint main() {\n\tint h, w;\n\twhile (cin >> h >> w, h) {\n\t\tvector<string> map(h);\n\t\tfor (auto &a : map)cin >> a;\n\t\tint dx[] = { 0,0,1,1,1,-1,-1,-1 };\n\t\tint dy[] = { 1,-1,0,-1,1,0,1,-1 };\n\t\tvector<tuple<string, int, int, int>> buf;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tfor (int d = 0; d < 8; d++) {\n\t\t\t\t\tbuf.push_back(make_tuple((string)\"\" + map[i][j], j, i, d));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint l = 0;\n\t\tfor (;; l++) {\n\t\t\tsort(buf.begin(), buf.end());\n\t\t\tvector<tuple<string, int, int, int>> buf2;\n\t\t\tfor (int i = 1; i < buf.size(); i++) {\n\t\t\t\tif (get<0>(buf[i - 1]).size() < l)continue;\n\t\t\t\tif (get<0>(buf[i - 1]) == get<0>(buf[i]))buf2.push_back(buf[i - 1]);\n\t\t\t\tfor (; i<buf.size()&&get<0>(buf[i - 1]) == get<0>(buf[i]); i++)buf2.push_back(buf[i]);\n\t\t\t}\n\t\t\tif (buf2.empty())break;\n\t\t\tbuf = move(buf2);\n\t\t\tfor (auto &a : buf) {\n\t\t\t\tstring str;\n\t\t\t\tint x, y, d;\n\t\t\t\ttie(str, x, y, d) = a;\n\t\t\t\tint x1 = ((x + dx[d]*l) % w + w) % w;\n\t\t\t\tint y1 = ((y + dy[d]*l) % h + h) % h;\n\t\t\t\tif (x1 == x && y1 == y)continue;\n\t\t\t\tstr += map[y1][x1];\n\t\t\t\ta = make_tuple(str, x, y, d);\n\t\t\t}\n\t\t}\n\t\tif (l < 3)cout << 0 << endl;\n\t\telse {\n\t\t\tstring str = get<0>(buf[0]);\n\t\t\tcout << str.substr(0, l-1) << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <iostream>\n#include <queue>\n#define FI first\n#define SE second\nusing namespace std;\nconst double EPS = 1e-10;\nconst int MAXN = 5005;\nconst int INF = 1111111111;\nconst double PI = acos(-1.0);\ntypedef long long LL;\nint dcmp(double x)\n{\n    if(fabs(x)<EPS) return 0;\n    return x<0?-1:1;\n}\nstruct Point{\n    double x,y;\n    void input(){scanf(\"%lf%lf\",&x,&y);}\n}p[MAXN];\n\nbool cmp(double a,double b)\n{\n    return dcmp(a-b)<0;\n}\ndouble ang[MAXN];\nint main()\n{\n    //freopen(\"/home/qitaishui/code/in.txt\",\"r\",stdin);\n    int n;\n    int ca;\n    LL ans,sub,tri;\n    scanf(\"%d\",&ca);\n    while(ca--)\n    {\n        sub = 0;\n        scanf(\"%d\",&n);\n        ans = (LL)n*(n-1)*(n-2)*(n-3)/24;\n        tri = (n-1)*(n-2)*(n-3)/6;\n        for(int i = 0; i < n;i++)\n            p[i].input();\n        int m;\n        for(int i = 0;i < n; i++)\n        {\n            m = 0;\n            for(int j = 0; j < n; j++)\n            {\n                if(i==j) continue;\n                ang[m++] = atan2(p[j].y-p[i].y,p[j].x-p[i].x);\n            }\n            sort(ang,ang+m,cmp);\n            for(int i = 0; i < m;i++)\n                ang[i+m]=2*PI+ang[i];\n            int l,r,s;\n            s = l = 0;\n            r = 1;\n            tri = (n-1)*(n-2)*(n-3)/6;\n            while(l < m)\n            {\n                while(dcmp(ang[l]+PI-ang[r])>=0)\n                    r++,s++;\n                if(s>=2)\n                    tri-=(s-1)*s/2;\n\t\t\t\ts--;\n                l++;\n            }\n            sub+=tri;\n        }\n        cout<<ans-sub<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1316: The Sorcerer's Donut\n// 2017.12.4 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define HASHSIZ 500009\ntypedef struct { unsigned long long x1; unsigned x2; int w; } HASH;\nHASH hash[HASHSIZ+2], *hashend = hash+HASHSIZ;\t\t\t// Hash table\nchar ans[500]; int len;\n\nvoid lookup(unsigned long long x1, unsigned x2, char *s, int w)\n{\n\tint i = (int)(x1 % HASHSIZ);\n\tHASH *tp = hash + i;\n\n\twhile (tp->x1) {\n\t\tif (w == tp->w && x1 == tp->x1 && x2 == tp->x2) {\n\t\t\tif (w > len || (w == len && memcmp(s, ans, w) < 0))\n\t\t\t\tmemcpy(ans, s, w), len = w;\n\t\t\treturn;\n\t\t}\n\t\tif (++tp == hashend) tp = hash;\n\t}\n\ttp->x1 = x1, tp->x2 = x2, tp->w = w;\n}\n\n#define M 4294967291\nint h, w;\nchar m[10][22];\nint mv[8][2] = {{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\nchar buf[1000];\n\nvoid rec(int sr, int sc, int r, int c, int dir, char *s,\n\t\t unsigned long long x1, unsigned x2, int len)\n{\n\tint r2, c2, cc;\n\n\ts[len++] = m[r][c];\n\tcc = m[r][c] - ('A'-1);\n\tx1 = (x1 << 5) | cc;\n\tx2 = (((long long)x2 << 5) | cc) % M;\n\tlookup(x1, x2, s, len);\n\n\tr2 = r + mv[dir][0]; if (r2 < 0) r2 = h-1; else if (r2 >= h) r2 = 0;\n\tc2 = c + mv[dir][1]; if (c2 < 0) c2 = w-1; else if (c2 >= w) c2 = 0;\n\n\tif (r2 == sr && c2 == sc) return;\n\trec(sr, sc, r2, c2, dir, s, x1, x2, len);\n}\n\nint main()\n{\n\tint r, c, d;\n\n\twhile (scanf(\"%d%d\", &h, &w) && h > 0) {\n\t\tmemset(hash, 0, sizeof(hash));\n\t\tfor (r = 0; r < h; r++) scanf(\"%s\", m[r]);\n\n\t\tlen = 0, ans[0] = 0;\n\t\tfor (r = 0; r < h; r++) for (c = 0; c < w; c++) for (d = 0; d < 8; d++) {\n\t\t\trec(r, c, r, c, d, buf, 0, 0, 0);\n\t\t}\n\n\t\tif (len < 2) puts(\"0\");\n\t\telse {\n\t\t\tans[len] = 0;\n\t\t\tputs(ans);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1316: The Sorcerer's Donut\n// 2017.12.4 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define HASHSIZ 500009\ntypedef struct { unsigned x; int w; } HASH;\nHASH hash[HASHSIZ+2], *hashend = hash+HASHSIZ;\t\t\t// Hash table\nchar ans[500]; int len;\nchar buf[1000];\n\nvoid lookup(unsigned x, int w)\n{\n\tHASH *tp = hash + ( x % HASHSIZ);\n\n\twhile (tp->x) {\n\t\tif (w == tp->w && x == tp->x) {\n\t\t\tif (w > len || (w == len && memcmp(buf, ans, w) < 0))\n\t\t\t\tmemcpy(ans, buf, w), len = w;\n\t\t\treturn;\n\t\t}\n\t\tif (++tp == hashend) tp = hash;\n\t}\n\ttp->x = x, tp->w = w;\n}\n\n#define M 4294967291\nint h, w, sr, sc, dir;\nchar m[10][22];\nint mv[8][2] = {\n\t{1,1},{-1,1},{-1,-1},{1,-1},\n\t{0,1},{0,-1},\n\t{1,0},{-1,0}};\n\nvoid rec(int r, int c, unsigned x, int len)\n{\n\tint r2, c2;\n\n\tbuf[len++] = m[r][c];\n\tx = (((long long)x << 5) | (m[r][c]-0x40)) % M;\n\tlookup(x, len);\n\n\tr2 = r + mv[dir][0]; if (r2 < 0) r2 = h-1; else if (r2 >= h) r2 = 0;\n\tc2 = c + mv[dir][1]; if (c2 < 0) c2 = w-1; else if (c2 >= w) c2 = 0;\n\n\tif (r2 == sr && c2 == sc) return;\n\trec(r2, c2, x, len);\n}\n\nint main()\n{\n\tint r;\n\n\twhile (scanf(\"%d%d\", &h, &w) && h > 0) {\n\t\tmemset(hash, 0, sizeof(hash));\n\t\tfor (r = 0; r < h; r++) scanf(\"%s\", m[r]);\n\n\t\tlen = 0;\n\t\tfor (sr = 0; sr < h; sr++) for (sc = 0; sc < w; sc++) for (dir = 0; dir < 8; dir++) {\n\t\t\tif (len > h && (dir == 6 || dir == 7)) continue;\n\t\t\tif (len > w && (dir == 4 || dir == 5)) continue;\n\t\t\trec(sr, sc, 0, 0);\n\t\t}\n\n\t\tif (len < 2) puts(\"0\");\n\t\telse ans[len] = 0, puts(ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<time.h>\nint x,y,dx[8]={0,1,1,1,0,-1,-1,-1},dy[8]={1,1,0,-1,-1,-1,0,1},co[191],sps,final;\nchar dic[191][1000][191],sp[1000][191];\nvoid ans(char map[20][10],int nx,int ny,int dir){\n\tint fx,fy,len,po,qw,sw,ck;\n\tchar dam[191]={};\n\tfx=nx;\n\tfy=ny;\n\tlen=0;\n\twhile(1){\n\t\tdam[len]=map[nx][ny];\n\t\tlen++;\n\t\tif(len>=final){\n\t\t\tif(co[len]==0){\n\t\t\t\tstrcpy(dic[len][co[len]],dam);\n\t\t\t\tco[len]++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsw=ck=0;\n\t\t\t\tfor(po=0;po<sps;po++){\n\t\t\t\t\tif(strcmp(sp[po],dam)==0){\n\t\t\t\t\t\tck++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(ck==0){\n\t\t\t\t\tfor(po=0;po<co[len];po++){\n\t\t\t\t\t\tif(strcmp(dic[len][po],dam)==0){\n\t\t\t\t\t\t\tif(final<strlen(dam)){\n\t\t\t\t\t\t\t\tstrcpy(sp[0],dam);\n\t\t\t\t\t\t\t\tsps=1;\n\t\t\t\t\t\t\t\tfinal=strlen(dam);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\tstrcpy(sp[sps],dam);\n\t\t\t\t\t\t\t\tsps++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsw++;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(sw==0&&ck==0){\n\t\t\t\t\tstrcpy(dic[len][co[len]],dam);\n\t\t\t\t\tco[len]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnx=(nx+dx[dir]+x)%x;\n\t\tny=(ny+dy[dir]+y)%y;\n\t\tif(nx==fx&&ny==fy){\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn;\n}\nint main(void){\n\tint i,j,k,maxl,t0,t1,tsum=0;\n\tchar dn[20][10],nu;\n\twhile(1){\n\t\tt0=clock();\n\t\tscanf(\"%d %d\",&y,&x);\n\t\tif(x==0&&y==0){\n\t\t\tbreak;\n\t\t}\n\t\tfor(k=0;k<191;k++){\n\t\t\tif(co[k]==0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tco[k]=0;\n\t\t\tfor(i=0;i<1000;i++){\n\t\t\t\tif(dic[k][i][0]==0){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(j=0;j<191;j++){\n\t\t\t\t\tif(dic[k][i][j]==0){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tdic[k][i][j]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<1000;i++){\n\t\t\tif(sp[i][0]==0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(j=0;j<191;j++){\n\t\t\t\tsp[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<20;i++){\n\t\t\tif(dn[i][0]==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(j=0;j<10;j++){\n\t\t\t\tdn[i][j]=0;\n\t\t\t}\n\t\t}\n\t\ti=j=0;\n\t\twhile(1){\n\t\t\tscanf(\"%c\",&nu);\n\t\t\tif(nu!='\\n'){\n\t\t\t\tdn[i][j]=nu;\n\t\t\t\ti++;\n\t\t\t\tif(i==x){\n\t\t\t\t\ti=0;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tif(j==y){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsps=0;\n\t\tfinal=2;\n\t\tfor(i=0;i<x;i++){\n\t\t\tfor(j=0;j<y;j++){\n\t\t\t\tfor(k=0;k<8;k++){\n\t\t\t\t\tans(dn,i,j,k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmaxl=final;\n\t\tfinal=0;\n\t\tfor(i=1;i<sps;i++){\n\t\t\tif(strcmp(sp[final],sp[i])>0){\n\t\t\t\tfinal=i;\n\t\t\t}\n\t\t}\n\t\tif(strlen(sp[final])==0){\n\t\t\tprintf(\"0\\n\");\n\t\t}\n\t\telse{\n\t\t\tfor(i=0;i<maxl;i++){\n\t\t\t\tprintf(\"%c\",sp[final][i]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tt1=clock();\n\t\t//printf(\"time %d\\n\",t1-t0);\n\t\ttsum+=t1-t0;\n\t}\n\t//printf(\"Sum %d\\n\",tsum);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint x,y,dx[8]={0,1,1,1,0,-1,-1,-1},dy[8]={1,1,0,-1,-1,-1,0,1},co,sps,final;\nchar dic[10000][200],sp[10000][200];\nvoid ans(char map[30][30],int nx,int ny,int dir){\n\tint fx,fy,len,po,qw,sw;\n\tchar dam[500];\n\tfor(po=0;po<500;po++){\n\t\tdam[po]=0;\n\t}\n\tfx=nx;\n\tfy=ny;\n\tlen=0;\n\twhile(1){\n\t\tdam[len]=map[nx][ny];\n\t\tlen++;\n\t\tnx=(nx+dx[dir]+x)%x;\n\t\tny=(ny+dy[dir]+y)%y;\n\t\tif(len>=final&&len!=1){\n\t\t\tif(co==0){\n\t\t\t\tstrcpy(dic[co],dam);\n\t\t\t\tco++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsw=0;\n\t\t\t\tfor(po=0;po<co;po++){\n\t\t\t\t\tif(strcmp(dic[po],dam)==0){\n\t\t\t\t\t\tstrcpy(sp[sps],dam);\n\t\t\t\t\t\tsps++;\n\t\t\t\t\t\tfinal=strlen(dam);\n\t\t\t\t\t\tsw++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(sw==0){\n\t\t\t\t\tstrcpy(dic[co],dam);\n\t\t\t\t\tco++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(nx==fx&&ny==fy){\n\t\t\tbreak;\n\t\t}\n\t}\n\t/*\n\tfor(po=0;po<co;po++){\n\t\tfor(qw=po+1;qw<co;qw++){\n\t\t\tif(strcmp(dic[po],dic[qw])==0&&strlen(dic[qw])>=final){\n\t\t\t\tstrcpy(sp[sps],dic[qw]);\n\t\t\t\tsps++;\n\t\t\t\tfinal=strlen(dic[qw]);\n\t\t\t}\n\t\t}\n\t}\n\t*/\n\treturn;\n}\nint main(void){\n\tint i,j,k,maxl;\n\tchar dn[30][30],nu;\n\twhile(1){\n\t\tscanf(\"%d %d\",&y,&x);\n\t\tif(x==0&&y==0){\n\t\t\tbreak;\n\t\t}\n\t\tfor(i=0;i<10000;i++){\n\t\t\tfor(j=0;j<200;j++){\n\t\t\t\tdic[i][j]=sp[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<30;i++){\n\t\t\tfor(j=0;j<30;j++){\n\t\t\t\tdn[i][j]=0;\n\t\t\t}\n\t\t}\n\t\ti=j=0;\n\t\twhile(1){\n\t\t\tscanf(\"%c\",&nu);\n\t\t\tif(nu!='\\n'){\n\t\t\t\tdn[i][j]=nu;\n\t\t\t\ti++;\n\t\t\t\tif(i==x){\n\t\t\t\t\ti=0;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tif(j==y){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tco=sps=0;\n\t\tfinal=1;\n\t\tfor(i=0;i<x;i++){\n\t\t\tfor(j=0;j<y;j++){\n\t\t\t\tfor(k=0;k<8;k++){\n\t\t\t\t\tans(dn,i,j,k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmaxl=0;\n\t\tfor(i=0;i<sps;i++){\n\t\t\tif(maxl<strlen(sp[i])){\n\t\t\t\tmaxl=strlen(sp[i]);\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<sps;i++){\n\t\t\tif(maxl>strlen(sp[i])){\n\t\t\t\tsp[i][0]='a';\n\t\t\t}\n\t\t}\n\t\tfinal=0;\n\t\tfor(i=1;i<sps;i++){\n\t\t\tif(strcmp(sp[final],sp[i])>0){\n\t\t\t\tfinal=i;\n\t\t\t}\n\t\t}\n\t\tif(strlen(sp[final])==0){\n\t\t\tprintf(\"0\\n\");\n\t\t}\n\t\telse{\n\t\t\tfor(i=0;i<strlen(sp[final]);i++){\n\t\t\t\tprintf(\"%c\",sp[final][i]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1316: The Sorcerer's Donut\n// 2017.12.4 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define HASHSIZ 500009\ntypedef struct { unsigned x; int w; } HASH;\nHASH hash[HASHSIZ+2], *hashend = hash+HASHSIZ;\t\t\t// Hash table\nchar ans[500]; int len;\nchar buf[1000];\n\nvoid lookup(unsigned x, int w)\n{\n\tint i = (int)(x % HASHSIZ);\n\tHASH *tp = hash + i;\n\n\twhile (tp->x) {\n\t\tif (w == tp->w && x == tp->x) {\n\t\t\tif (w > len || (w == len && memcmp(buf, ans, w) < 0))\n\t\t\t\tmemcpy(ans, buf, w), len = w;\n\t\t\treturn;\n\t\t}\n\t\tif (++tp == hashend) tp = hash;\n\t}\n\ttp->x = x, tp->w = w;\n}\n\n#define M 4294967291\nint h, w, sr, sc, dir;\nchar m[10][22];\nint mv[8][2] = {{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\n\nvoid rec(int r, int c, unsigned x, int len)\n{\n\tint r2, c2;\n\n\tbuf[len++] = m[r][c];\n\tx = (((long long)x << 5) | (m[r][c]-0x40)) % M;\n\tlookup(x, len);\n\n\tr2 = r + mv[dir][0]; if (r2 < 0) r2 = h-1; else if (r2 >= h) r2 = 0;\n\tc2 = c + mv[dir][1]; if (c2 < 0) c2 = w-1; else if (c2 >= w) c2 = 0;\n\n\tif (r2 == sr && c2 == sc) return;\n\trec(r2, c2, x, len);\n}\n\nint main()\n{\n\tint r;\n\n\twhile (scanf(\"%d%d\", &h, &w) && h > 0) {\n\t\tmemset(hash, 0, sizeof(hash));\n\t\tfor (r = 0; r < h; r++) scanf(\"%s\", m[r]);\n\n\t\tlen = 0;\n\t\tfor (sr = 0; sr < h; sr++) for (sc = 0; sc < w; sc++) for (dir = 0; dir < 8; dir++) {\n\t\t\trec(sr, sc, 0, 0);\n\t\t}\n\n\t\tif (len < 2) puts(\"0\");\n\t\telse ans[len] = 0, puts(ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <string>\n#include <map>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int maxn = 40;\nconst int dx[] = {1, -1, 0, 0 , 1, 1, -1, -1},\n\t \t  dy[] = {0, 0, 1, -1, 1, -1, 1, -1};\n\nint n, m, ml, cnt;\nchar donut[maxn][maxn];\nstring ans[2000];\nmap<string, int> mp;\n\nint main()\n{\n#ifdef LOCAL\n\tfreopen(\"B.in\", \"r\", stdin);\n#endif\n\twhile(scanf(\"%d%d\", &n, &m) != EOF) {\n\t\tif(n == 0 && m == 0)\tbreak;\n\t\tml = cnt = 0;\n\t\tmp.clear();\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tscanf(\"%s\", donut[i]);\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tfor(int j = 0; j < m; j++) \n\t\t\t\tfor(int k = 0; k < 8; k++) {\n\t\t\t\t\tstring tmp = \"\";\n\t\t\t\t\tint nx = i, ny = j;\n\t\t\t\t\tdo{\n\t\t\t\t\t\ttmp += donut[nx][ny];\n\t\t\t\t\t\tif(tmp.size() >= 2 && tmp.size() >= ml) {\n\t\t\t\t\t\t\tif(!mp[tmp])\tmp.insert(pair <string, int> (tmp, 1));\t\n\t\t\t\t\t\t\telse if(tmp.size() == ml && mp[tmp] == 1) \n\t\t\t\t\t\t\t\tans[cnt++] = tmp;\n\t\t\t\t\t\t\telse if(tmp.size() > ml) {\n\t\t\t\t\t\t\t\tml = tmp.size();\n\t\t\t\t\t\t\t\tcnt = 0;\n\t\t\t\t\t\t\t\tans[cnt++] = tmp;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmp[tmp]++;\t\t\t\t\t\t\n\t\t\t\t\t\tnx = (nx+dx[k]+n)%n;\n\t\t\t\t\t\tny = (ny+dy[k]+m)%m;\n\t\t\t\t\t}while(nx != i || ny != j);\t\n//\t\t\t\t\tcout << tmp << endl;\t\n\t\t\t\t\t/*\n\t\t\t\t\tif(!mp[tmp])\tmp.insert(pair <string, int> (tmp, 1));\t\n\t\t\t\t\telse {\n\t\t\t\t\t\tif(tmp.size() == ml && mp[tmp] == 1) {\n\t\t\t\t\t\t\tans[cnt++] = tmp;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(tmp.size() > ml) {\n\t\t\t\t\t\t\tml = tmp.size();\n\t\t\t\t\t\t\tcnt = 0;\n\t\t\t\t\t\t\tans[cnt++] = tmp;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmp[tmp]++;\n\t\t\t\t\t}\n\t\t\t\t\t*/\n\t\t\t\t}\n\t\tsort(ans, ans+cnt);\n\t\tif(cnt)\tprintf(\"%s\\n\", ans[0].c_str());\n\t\telse\tprintf(\"0\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint x,y,dx[8]={0,1,1,1,0,-1,-1,-1},dy[8]={1,1,0,-1,-1,-1,0,1},co,sps,final;\nchar dic[10000][200],sp[10000][200];\nvoid ans(char map[30][30],int nx,int ny,int dir){\n\tint fx,fy,len,po,qw,sw;\n\tchar dam[500];\n\tfor(po=0;po<500;po++){\n\t\tdam[po]=0;\n\t}\n\tfx=nx;\n\tfy=ny;\n\tlen=0;\n\twhile(1){\n\t\tdam[len]=map[nx][ny];\n\t\tlen++;\n\t\tnx=(nx+dx[dir]+x)%x;\n\t\tny=(ny+dy[dir]+y)%y;\n\t\tif(len>=final&&len!=1){\n\t\t\tif(co==0){\n\t\t\t\tstrcpy(dic[co],dam);\n\t\t\t\tco++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsw=0;\n\t\t\t\tfor(po=0;po<co;po++){\n\t\t\t\t\tif(strcmp(dic[po],dam)==0){\n\t\t\t\t\t\tstrcpy(sp[sps],dam);\n\t\t\t\t\t\tsps++;\n\t\t\t\t\t\tfinal=strlen(dam);\n\t\t\t\t\t\tsw++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(sw==0){\n\t\t\t\t\tstrcpy(dic[co],dam);\n\t\t\t\t\tco++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(nx==fx&&ny==fy){\n\t\t\tbreak;\n\t\t}\n\t}\n\t/*\n\tfor(po=0;po<co;po++){\n\t\tfor(qw=po+1;qw<co;qw++){\n\t\t\tif(strcmp(dic[po],dic[qw])==0&&strlen(dic[qw])>=final){\n\t\t\t\tstrcpy(sp[sps],dic[qw]);\n\t\t\t\tsps++;\n\t\t\t\tfinal=strlen(dic[qw]);\n\t\t\t}\n\t\t}\n\t}\n\t*/\n\treturn;\n}\nint main(void){\n\tint i,j,k,maxl;\n\tchar dn[30][30],nu;\n\twhile(1){\n\t\tscanf(\"%d %d\",&y,&x);\n\t\tif(x==0&&y==0){\n\t\t\tbreak;\n\t\t}\n\t\tfor(i=0;i<10000;i++){\n\t\t\tfor(j=0;j<200;j++){\n\t\t\t\tdic[i][j]=sp[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<30;i++){\n\t\t\tfor(j=0;j<30;j++){\n\t\t\t\tdn[i][j]=0;\n\t\t\t}\n\t\t}\n\t\ti=j=0;\n\t\twhile(1){\n\t\t\tscanf(\"%c\",&nu);\n\t\t\tif(nu!='\\n'){\n\t\t\t\tdn[i][j]=nu;\n\t\t\t\ti++;\n\t\t\t\tif(i==x){\n\t\t\t\t\ti=0;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tif(j==y){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tco=sps=0;\n\t\tfinal=1;\n\t\tfor(i=0;i<x;i++){\n\t\t\tfor(j=0;j<y;j++){\n\t\t\t\tfor(k=0;k<8;k++){\n\t\t\t\t\tans(dn,i,j,k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmaxl=0;\n\t\tfor(i=0;i<sps;i++){\n\t\t\tif(maxl<strlen(sp[i])){\n\t\t\t\tmaxl=strlen(sp[i]);\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<sps;i++){\n\t\t\tif(maxl>strlen(sp[i])){\n\t\t\t\tsp[i][0]='a';\n\t\t\t}\n\t\t}\n\t\tfinal=0;\n\t\tfor(i=1;i<sps;i++){\n\t\t\tif(strcmp(sp[final],sp[i])>0){\n\t\t\t\tfinal=i;\n\t\t\t}\n\t\t}\n\t\tif(strlen(sp[final])==0){\n\t\t\tprintf(\"0\\n\");\n\t\t}\n\t\telse{\n\t\t\tfor(i=0;i<strlen(sp[final]);i++){\n\t\t\t\tprintf(\"%c\",sp[final][i]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1316: The Sorcerer's Donut\n// 2017.12.4 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define HASHSIZ 500009\ntypedef struct { unsigned x; int w; } HASH;\nHASH hash[HASHSIZ+2], *hashend = hash+HASHSIZ;\t\t\t// Hash table\nchar ans[500]; int len;\n\nvoid lookup(unsigned x, char *s, int w)\n{\n\tint i = (int)(x % HASHSIZ);\n\tHASH *tp = hash + i;\n\n\twhile (tp->x) {\n\t\tif (w == tp->w && x == tp->x) {\n\t\t\tif (w > len || (w == len && memcmp(s, ans, w) < 0))\n\t\t\t\tmemcpy(ans, s, w), len = w;\n\t\t\treturn;\n\t\t}\n\t\tif (++tp == hashend) tp = hash;\n\t}\n\ttp->x = x, tp->w = w;\n}\n\n#define M 4294967291\nint h, w;\nchar m[10][22];\nint mv[8][2] = {{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\nchar buf[1000];\n\nvoid rec(int sr, int sc, int r, int c, int dir, char *s,\n\t\t unsigned x, int len)\n{\n\tint r2, c2, cc;\n\n\ts[len++] = m[r][c];\n\tcc = m[r][c] - ('A'-1);\n\tx = (((long long)x << 5) | cc) % M;\n\tlookup(x, s, len);\n\n\tr2 = r + mv[dir][0]; if (r2 < 0) r2 = h-1; else if (r2 >= h) r2 = 0;\n\tc2 = c + mv[dir][1]; if (c2 < 0) c2 = w-1; else if (c2 >= w) c2 = 0;\n\n\tif (r2 == sr && c2 == sc) return;\n\trec(sr, sc, r2, c2, dir, s, x, len);\n}\n\nint main()\n{\n\tint r, c, d;\n\n\twhile (scanf(\"%d%d\", &h, &w) && h > 0) {\n\t\tmemset(hash, 0, sizeof(hash));\n\t\tfor (r = 0; r < h; r++) scanf(\"%s\", m[r]);\n\n\t\tlen = 0, ans[0] = 0;\n\t\tfor (r = 0; r < h; r++) for (c = 0; c < w; c++) for (d = 0; d < 8; d++) {\n\t\t\trec(r, c, r, c, d, buf, 0, 0);\n\t\t}\n\n\t\tif (len < 2) puts(\"0\");\n\t\telse {\n\t\t\tans[len] = 0;\n\t\t\tputs(ans);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <cstdio>\n#include <string>\n#include <map>\n\nusing namespace std;\n\nint h, w;\nchar str[32][32];\n\nint dy[] = {0, 1, 0, -1, 1, -1, 1, -1};\nint dx[] = {1, 0, -1, 0, 1, 1, -1, -1};\n\nvoid generate(int sy, int sx, map<string, int> &rec)\n{\n\tchar tmp[2] = {0, 0};\n\t\n\tfor (int i = 0; i < 8; i++){\n\t\ttmp[0] = str[sy][sx];\n\t\tstring s = tmp;\n\t\tint ny = sy, nx = sx;\n\t\twhile (1){\n\t\t\tny = (ny + h + dy[i]) % h; nx = (nx + w + dx[i]) % w;\n\t\t\tif (ny == sy && nx == sx) break;\n\t\t\ttmp[0] = str[ny][nx];\n\t\t\ts += tmp;\n\t\t\tif (rec.count(s) > 0) rec[s] += 1;\n\t\t\telse rec[s] = 1;\n\t\t}\n\t}\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &h, &w) && h){\n\t\tfor (int i = 0; i < h; i++) scanf(\"%s\", str[i]);\n\t\tmap<string, int> occ;\n\t\t\n\t\tfor (int i = 0; i < h; i++){\n\t\t\tfor (int j = 0; j < w; j++){\n\t\t\t\tgenerate(i, j, occ);\n\t\t\t}\n\t\t}\n\t\t\n\t\tstring ans = \"\";\n\t\tfor (map<string, int>::iterator it = occ.begin(); it != occ.end(); it++){\n\t\t\tif (it->second > 1 && it->first.size() >= ans.size()){\n\t\t\t\tif (it->first.size() > ans.size()) ans = it->first;\n\t\t\t\telse if (it->first.size() == ans.size() && it->first < ans) ans = it->second;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (ans != \"\") printf(\"%s\\n\", ans.c_str());\n\t\telse printf(\"0\\n\");\n\t}\n\treturn (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#define HASHTABLE_SIZE 40000\n#define SPELL_LENGTH 191\n#define NULL_INDEX -1\n\n/* グループ */\ntypedef struct {\n\tchar value[SPELL_LENGTH + 1];\n\tint length;\n\tint number;\n} Item;\n\nItem hashtable[HASHTABLE_SIZE]; /* 配列から取り出せる全ての文字列 */\nint bottomlength;\n\n/* 文字列のハッシュ値を求める */\nint hash(const char* s) {\n\tint i, h = 0, a = 3141, b = 2718;\n\tfor (i = 0; s[i] != '\\0'; i++, a = a * b % (HASHTABLE_SIZE - 1)) h = (a * h + s[i]) % HASHTABLE_SIZE;\n\treturn h;\n}\n\n/* ハッシュ表を初期化する */\nvoid init() {\n\tint i;\n\tbottomlength = 2;\n\tfor (i = 0; i < HASHTABLE_SIZE; i++) {\n\t\thashtable[i].length = 0;\n\t\thashtable[i].number = 0;\n\t}\n}\n\n/* 指定された呪文の番号を返す */\nint searchH(const char* s, int h) {\n\tint i;\n\tfor (i = hash(s); hashtable[i].number != 0; i++) {\n\t\tif (strcmp(s, hashtable[i].value) == 0) return i;\n\t}\n\treturn NULL_INDEX;\n}\nint search(const char* s) {\n\treturn searchH(s, hash(s));\n}\n\n/* 指定された呪文を配列に追加し呪文に割り当てられた番号を返す */\nint add(const char* s) {\n\tint h = hash(s);\n\tint i = searchH(s, h);\n\tif (i == NULL_INDEX) {\n\t\tfor (i = h; hashtable[i].length >= bottomlength; i++); /* 挿入可能な場所を探す */\n\t\t/* 新しい呪文を追加する */\n\t\thashtable[i].number = 0;\n\t\thashtable[i].length = strlen(s);\n\t\tstrncpy(hashtable[i].value, s, hashtable[i].length + 1);\n\t}\n\thashtable[i].number++; /* 同じ呪文の追加回数を数える */\n\treturn i;\n}\n\nint VECTOR[8][2] = {{0, 1}, {1, 1}, {1, 0}, {1, -1}, {0, -1}, {-1, -1}, {-1, 0}, {-1, 1}};\n\nint main(void) {\n\tint h, w; /* 文字配列の大きさ */\n\tchar data[10][20];\n\tint i, j, k;\n\n\t/* データセット毎の処理 */\n\twhile (scanf(\"%d%d\\n\", &h, &w) == 2 && h >= 3 && h <= 10 && w >= 3 && w <= 20) {\n\t\t/* 文字配列を読み込む */\n\t\tfor (i = 0; i < h; i++) for (j = 0; j < w; j++) {\n\t\t\tscanf(\"%c\\n\", &data[i][j]);\n\t\t}\n\n\t\tinit(); /* 初期化 */\n\n\t\t/* 配列から取り出せる全ての文字列を探索する */\n\t\tint answer = NULL_INDEX;\n\t\tfor (i = 0; i < h; i++) for (j = 0; j < w; j++) /* 始点 */ for (k = 0; k < 8; k++) /* 方向 */ {\n\t\t\tint used[10*20] = {}; /* 配列中のある文字を使ったか */\n\t\t\tint y = i, x = j; /* 現在の参照位置 */\n\t\t\tchar s[SPELL_LENGTH] = {}; /* 取り出した文字列 */\n\t\t\tint sl; /* 長さ */\n\t\t\tfor (sl = 1; used[w*y+x] == 0; sl++, y = (h + y + VECTOR[k][0]) % h, x = (w + x + VECTOR[k][1]) % w) {\n\t\t\t\tused[w*y+x] = 1;\n\t\t\t\ts[sl-1] = data[y][x]; /* 1文字加える */\n\t\t\t\t/* 文字列が呪文か判定する */\n\t\t\t\t/* if (sl > 1 || (answer != NULL_INDEX && sl >= hashtable[answer].length)) { */\n\t\t\t\tif (sl >= bottomlength) {\n\t\t\t\t\tint index = add(s);\n\t\t\t\t\t/* 同じ文字列が2回以上出現しているときこの文字列を呪文の候補とする */\n\t\t\t\t\tif (hashtable[index].number >= 2) {\n\t\t\t\t\t\tif (answer == NULL_INDEX) {\n\t\t\t\t\t\t\tanswer = index; /* 初めて見つけた呪文候補 */\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t/* 最も長く辞書順で若い文字列を呪文とする */\n\t\t\t\t\t\t\tif (hashtable[index].length > hashtable[answer].length || (hashtable[index].length == hashtable[answer].length && strcmp(hashtable[index].value, hashtable[answer].value) < 0)) {\n\t\t\t\t\t\t\t\tanswer = index;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbottomlength = sl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* 出力 */\n\t\tif (answer == NULL_INDEX) printf(\"0\\n\");\n\t\telse printf(\"%s\\n\", hashtable[answer].value);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#define HASHTABLE_SIZE 2000\n#define SPELL_LENGTH 191\n#define NULL_INDEX -1\n\nchar hashtable[HASHTABLE_SIZE][SPELL_LENGTH+1]; /* 配列から取り出せる全ての文字列 */\nint flag[HASHTABLE_SIZE];\nint maxl, maxi;\n\n/* 文字列の最初の2文字からハッシュ値を求める */\nint hash(const char* s) {\n\tint i, h = 0, a = 3141, b = 2718;\n\tfor (i = 0; s[i] != '\\0' && i < 2; i++, a = a * b % (HASHTABLE_SIZE - 1)) h = (a * h + s[i]) % HASHTABLE_SIZE;\n\treturn h;\n}\n\n/* ハッシュ表を初期化する */\nvoid init() {\n\tint i;\n\tfor (i = 0; i < HASHTABLE_SIZE; i++) flag[i] = 0;\n\tmaxl = 0;\n}\n\nint add(const char* s) {\n\tint i, j;\n\t/* これまでに追加した文字列と比較する */\n\tfor (i = hash(s); flag[i]; i = (i + 1) % HASHTABLE_SIZE) {\n\t\tfor (j = 0; s[j] != '\\0' && hashtable[i][j] != '\\0' && s[j] == hashtable[i][j]; j++);\n\t\tif (j > maxl) {\n\t\t\t/* 最も長い文字列 */\n\t\t\tmaxl = j;\n\t\t\tmaxi = i;\n\t\t} else if (j == maxl) {\n\t\t\t/* 長さが等しい場合は辞書順で最も若い文字列 */\n\t\t\tif (strncmp(s, hashtable[maxi], maxl) < 0) maxi = i;\n\t\t}\n\t}\n\t/* 新しい文字列を追加する */\n\tstrncpy(hashtable[i], s, SPELL_LENGTH + 1);\n\tflag[i] = 1;\n\treturn i;\n}\n\nint VECTOR[8][2] = {{0, 1}, {1, 1}, {1, 0}, {1, -1}, {0, -1}, {-1, -1}, {-1, 0}, {-1, 1}};\n\nint main(void) {\n\tint h, w; /* 文字配列の大きさ */\n\tchar data[10][20];\n\tint i, j, k;\n\n\t/* データセット毎の処理 */\n\twhile (scanf(\"%d%d\\n\", &h, &w) == 2 && h >= 3 && h <= 10 && w >= 3 && w <= 20) {\n\t\t/* 文字配列を読み込む */\n\t\tfor (i = 0; i < h; i++) for (j = 0; j < w; j++) {\n\t\t\tscanf(\"%c\\n\", &data[i][j]);\n\t\t}\n\n\t\tinit(); /* 初期化 */\n\n\t\t/* 配列から取り出せる全ての文字列を探索する */\n\t\tfor (i = 0; i < h; i++) for (j = 0; j < w; j++) /* 始点 */ for (k = 0; k < 8; k++) /* 方向 */ {\n\t\t\t/* 文字列を取り出す */\n\t\t\tint used[10*20] = {}; /* 配列中のある文字を使ったか */\n\t\t\tint ii = i, jj = j; /* 現在の参照位置 */\n\t\t\tchar s[SPELL_LENGTH] = {}; /* 取り出した文字列 */\n\t\t\tint l; /* 長さ */\n\t\t\tfor (l = 0; used[w*ii+jj] == 0; l++, ii = (h + ii + VECTOR[k][0]) % h, jj = (w + jj + VECTOR[k][1]) % w) {\n\t\t\t\tused[w*ii+jj] = 1;\n\t\t\t\ts[l] = data[ii][jj]; /* 1文字加える */\n\t\t\t}\n\t\t\t/* これまでに取り出した文字列と比較する */\n\t\t\tadd(s);\n\t\t}\n\n\t\t/* 出力 */\n\t\tif (maxl < 2) {\n\t\t\tprintf(\"0\\n\");\n\t\t} else {\n\t\t\thashtable[maxi][maxl] = '\\0';\n\t\t\tprintf(\"%s\\n\", hashtable[maxi]);\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<time.h>\nint x,y,dx[8]={0,1,1,1,0,-1,-1,-1},dy[8]={1,1,0,-1,-1,-1,0,1},co[191],sps,final;\nchar dic[191][1000][191],sp[1000][191];\nvoid ans(char map[20][10],int nx,int ny,int dir){\n\tint fx,fy,len,po,qw,sw,ck;\n\tchar dam[191]={};\n\tfx=nx;\n\tfy=ny;\n\tlen=0;\n\twhile(1){\n\t\tdam[len]=map[nx][ny];\n\t\tlen++;\n\t\tif(len>=final){\n\t\t\tsw=ck=0;\n\t\t\tfor(po=0;po<sps;po++){\n\t\t\t\tif(strcmp(sp[po],dam)==0){\n\t\t\t\t\tck++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ck==0){\n\t\t\t\tfor(po=0;po<co[len];po++){\n\t\t\t\t\tif(strcmp(dic[len][po],dam)==0){\n\t\t\t\t\t\tif(final<strlen(dam)){\n\t\t\t\t\t\t\tstrcpy(sp[0],dam);\n\t\t\t\t\t\t\tsps=1;\n\t\t\t\t\t\t\tfinal=strlen(dam);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tstrcpy(sp[sps],dam);\n\t\t\t\t\t\t\tsps++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsw++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(sw==0&&ck==0){\n\t\t\t\tstrcpy(dic[len][co[len]],dam);\n\t\t\t\tco[len]++;\n\t\t\t}\n\t\t}\n\t\tnx=(nx+dx[dir]+x)%x;\n\t\tny=(ny+dy[dir]+y)%y;\n\t\tif(nx==fx&&ny==fy){\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn;\n}\nint main(void){\n\tint i,j,k,maxl,t0,t1,tsum=0;\n\tchar dn[20][10],nu;\n\tfor(k=0;k<191;k++){\n\t\tco[k]=0;\n\t\tfor(i=0;i<1000;i++){\n\t\t\tfor(j=0;j<191;j++){\n\t\t\t\tdic[k][i][j]=sp[i][j]=0;\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=0;i<20;i++){\n\t\tfor(j=0;j<10;j++){\n\t\t\tdn[i][j]=0;\n\t\t}\n\t}\n\twhile(1){\n\t\tt0=clock();\n\t\tscanf(\"%d %d\",&y,&x);\n\t\tif(x==0&&y==0){\n\t\t\tbreak;\n\t\t}\n\t\tfor(k=0;k<191;k++){\n\t\t\tif(co[k]==0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tco[k]=0;\n\t\t\tfor(i=0;i<1000;i++){\n\t\t\t\tif(dic[k][i][0]==0){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(j=0;j<191;j++){\n\t\t\t\t\tif(dic[k][i][j]==0){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tdic[k][i][j]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<1000;i++){\n\t\t\tif(sp[i][0]==0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(j=0;j<191;j++){\n\t\t\t\tsp[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<20;i++){\n\t\t\tif(dn[i][0]==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(j=0;j<10;j++){\n\t\t\t\tdn[i][j]=0;\n\t\t\t}\n\t\t}\n\t\ti=j=0;\n\t\twhile(1){\n\t\t\tscanf(\"%c\",&nu);\n\t\t\tif(nu!='\\n'){\n\t\t\t\tdn[i][j]=nu;\n\t\t\t\ti++;\n\t\t\t\tif(i==x){\n\t\t\t\t\ti=0;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tif(j==y){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsps=0;\n\t\tfinal=2;\n\t\tfor(i=0;i<x;i++){\n\t\t\tfor(j=0;j<y;j++){\n\t\t\t\tfor(k=0;k<8;k++){\n\t\t\t\t\tans(dn,i,j,k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tfor(i=0;i<191;i++){\n\t\t\tprintf(\"%d:%d\",i,co[i]);\n\t\t\tif(i==final){\n\t\t\t\tprintf(\"***\");\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\t*/\n\t\tmaxl=final;\n\t\tfinal=0;\n\t\tfor(i=1;i<sps;i++){\n\t\t\tif(strcmp(sp[final],sp[i])>0){\n\t\t\t\tfinal=i;\n\t\t\t}\n\t\t}\n\t\tif(strlen(sp[final])==0){\n\t\t\tprintf(\"0\\n\");\n\t\t}\n\t\telse{\n\t\t\tfor(i=0;i<maxl;i++){\n\t\t\t\tprintf(\"%c\",sp[final][i]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tt1=clock();\n\t\t//printf(\"time %d\\n\",t1-t0);\n\t\ttsum+=t1-t0;\n\t}\n\t//printf(\"Sum %d\\n\",tsum);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<time.h>\nint x,y,dx[8]={0,1,1,1,0,-1,-1,-1},dy[8]={1,1,0,-1,-1,-1,0,1},co[191],sps,final;//dx??¨dy???8?????????????§????????????????????????????????????????????¨??????????\nchar dic[191][1000][191],sp[1000][191];//dic[??????????????????][?????°][??????]?????¨???????????????????´????????????????sp[][]????????¶?????????????????????????´??????????\nvoid ans(char map[20][10],int nx,int ny,int dir){//??????????????????????????????????????¢??§??????x??§?¨?,y??§?¨??????????(0??????7)\n\tint fx,fy,len,po,qw,sw,ck;\n\tchar dam[191]={};\n\tfx=nx;\n\tfy=ny;\n\tlen=0;\n\twhile(1){\n\t\tdam[len]=map[nx][ny];//dam[]??????????????\\???????????????\n\t\tlen++;//dam[]?????????????????????\n\t\tif(len>=final){//?????????????????¨????????????dam[]???sp[][]?????????????????§?????\\????????¨?????\\????????????????????????\n\t\t\tsw=ck=0;\n\t\t\tfor(po=0;po<sps;po++){//??¨sp[][]?????????????????§???dam[]?????????????????????dam[]???dic[][][]??????sp[][]????????\\????????????\n\t\t\t\tif(strcmp(sp[po],dam)==0){\n\t\t\t\t\tck++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ck==0){//dam[]???sp[][]???????????´????????¨dic[][][]??¨???????????§????????????????????????\n\t\t\t\tfor(po=0;po<co[len];po++){\n\t\t\t\t\tif(strcmp(dic[len][po],dam)==0){//???????????????????????°dam[]???sp[][]?????\\?????????\n\t\t\t\t\t\tif(final<strlen(dam)){//sp[][]????????§????????´??°???????????????sp[][]????????°sps???1????????????\n\t\t\t\t\t\t\tstrcpy(sp[0],dam);//????????¨??????dam[]???sp[0]?????\\??????\n\t\t\t\t\t\t\tsps=1;\n\t\t\t\t\t\t\tfinal=strlen(dam);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{//len=final??????????????????????????\\?????????\n\t\t\t\t\t\t\tstrcpy(sp[sps],dam);\n\t\t\t\t\t\t\tsps++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsw++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(sw==0&&ck==0){//dam[]???sp[][]??????dic[][][]??????????????????dam[]???dic[][][]???????????????\n\t\t\t\tstrcpy(dic[len][co[len]],dam);\n\t\t\t\tco[len]++;//co[????????????]???dir[][][]????????°????????????????????¨????????¨???????????????\n\t\t\t}\n\t\t}\n\t\tnx=(nx+dx[dir]+x)%x;\n\t\tny=(ny+dy[dir]+y)%y;//??????????±????????????????????§???????\n\t\tif(nx==fx&&ny==fy){//?§??????§?????????????????\\??????????????????\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn;\n}\nint main(void){\n\tint i,j,k,maxl,t0,t1,tsum=0;\n\tchar dn[20][10],nu;\n\tfor(k=0;k<191;k++){\n\t\tco[k]=0;\n\t\tfor(i=0;i<1000;i++){//????????????\n\t\t\tfor(j=0;j<191;j++){\n\t\t\t\tdic[k][i][j]=sp[i][j]=0;\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=0;i<20;i++){\n\t\tfor(j=0;j<10;j++){\n\t\t\tdn[i][j]=0;\n\t\t}\n\t}\n\twhile(1){\n\t\tt0=clock();\n\t\tscanf(\"%d %d\",&y,&x);//??????????????§????????????????????????\n\t\tif(x==0&&y==0){\n\t\t\tbreak;\n\t\t}\n\t\tfor(k=0;k<191;k++){//2???????????????????????????continue???,break???????????¨???\n\t\t\tif(co[k]==0){//dic???????????????????????????????????????k??§????????°0??????i,j,????????????????????????\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tco[k]=0;\n\t\t\tfor(i=0;i<1000;i++){\n\t\t\t\tif(dic[k][i][0]==0){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor(j=0;j<191;j++){\n\t\t\t\t\tif(dic[k][i][j]==0){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tdic[k][i][j]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<1000;i++){//dic??¨????§????\n\t\t\tif(sp[i][0]==0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(j=0;j<191;j++){\n\t\t\t\tsp[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<20;i++){\n\t\t\tif(dn[i][0]==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(j=0;j<10;j++){\n\t\t\t\tdn[i][j]=0;\n\t\t\t}\n\t\t}\n\t\ti=j=0;\n\t\twhile(1){\n\t\t\tscanf(\"%c\",&nu);//????????????????????????????????????\n\t\t\tif(nu!='\\n'){\n\t\t\t\tdn[i][j]=nu;\n\t\t\t\ti++;\n\t\t\t\tif(i==x){\n\t\t\t\t\ti=0;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tif(j==y){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsps=0;//sp[][]????????°???????????????0???\n\t\tfinal=2;//sp[][]?????\\????????????????????????????????????????????????2??¨?????????\n\t\tfor(i=0;i<x;i++){//?????????????????¨??????????§??????¨????????¨???????????¨?????????????????¨??????\n\t\t\tfor(j=0;j<y;j++){\n\t\t\t\tfor(k=0;k<8;k++){\n\t\t\t\t\tans(dn,i,j,k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmaxl=final;\n\t\tfinal=0;\n\t\tfor(i=1;i<sps;i++){//???????????§sp[i]??????????????\\?????´??????final????????´???\n\t\t\tif(strcmp(sp[final],sp[i])>0){\n\t\t\t\tfinal=i;\n\t\t\t}\n\t\t}\n\t\tif(strlen(sp[final])==0){//??????????±??????£???sp[][]????????????0??????sp[][]???1??????????????¨???????????¨????????§0????????????\n\t\t\tprintf(\"0\\n\");\n\t\t}\n\t\telse{\n\t\t\tfor(i=0;i<maxl;i++){//????????§??????????????????????????????\n\t\t\t\tprintf(\"%c\",sp[final][i]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tt1=clock();\n\t\t//printf(\"time %d\\n\",t1-t0);\n\t\ttsum+=t1-t0;\n\t}\n\t//printf(\"Sum %d\\n\",tsum);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint x,y,dx[8]={0,1,1,1,0,-1,-1,-1},dy[8]={1,1,0,-1,-1,-1,0,1},co,sps,final;\nchar dic[10000][500],sp[10000][500];\nvoid ans(char map[30][30],int nx,int ny,int dir){\n\tint fx,fy,len,po,qw,sw;\n\tchar dam[500];\n\tfor(po=0;po<500;po++){\n\t\tdam[po]=0;\n\t}\n\tfx=nx;\n\tfy=ny;\n\tlen=0;\n\twhile(1){\n\t\tdam[len]=map[nx][ny];\n\t\tlen++;\n\t\tnx=(nx+dx[dir]+x)%x;\n\t\tny=(ny+dy[dir]+y)%y;\n\t\tif(len>=final&&len!=1){\n\t\t\tif(co==0){\n\t\t\t\tstrcpy(dic[co],dam);\n\t\t\t\tco++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsw=0;\n\t\t\t\tfor(po=0;po<co;po++){\n\t\t\t\t\tif(strcmp(dic[po],dam)==0){\n\t\t\t\t\t\tstrcpy(sp[sps],dam);\n\t\t\t\t\t\tsps++;\n\t\t\t\t\t\tfinal=strlen(dam);\n\t\t\t\t\t\tsw++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(sw==0){\n\t\t\t\t\tstrcpy(dic[co],dam);\n\t\t\t\t\tco++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(nx==fx&&ny==fy){\n\t\t\tbreak;\n\t\t}\n\t}\n\t/*\n\tfor(po=0;po<co;po++){\n\t\tfor(qw=po+1;qw<co;qw++){\n\t\t\tif(strcmp(dic[po],dic[qw])==0&&strlen(dic[qw])>=final){\n\t\t\t\tstrcpy(sp[sps],dic[qw]);\n\t\t\t\tsps++;\n\t\t\t\tfinal=strlen(dic[qw]);\n\t\t\t}\n\t\t}\n\t}\n\t*/\n\treturn;\n}\nint main(void){\n\tint i,j,k,maxl;\n\tchar dn[30][30],nu;\n\twhile(1){\n\t\tscanf(\"%d %d\",&y,&x);\n\t\tif(x==0&&y==0){\n\t\t\tbreak;\n\t\t}\n\t\tfor(i=0;i<10000;i++){\n\t\t\tfor(j=0;j<500;j++){\n\t\t\t\tdic[i][j]=sp[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<30;i++){\n\t\t\tfor(j=0;j<30;j++){\n\t\t\t\tdn[i][j]=0;\n\t\t\t}\n\t\t}\n\t\ti=j=0;\n\t\twhile(1){\n\t\t\tscanf(\"%c\",&nu);\n\t\t\tif(nu!='\\n'){\n\t\t\t\tdn[i][j]=nu;\n\t\t\t\ti++;\n\t\t\t\tif(i==x){\n\t\t\t\t\ti=0;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tif(j==y){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tco=sps=0;\n\t\tfinal=1;\n\t\tfor(i=0;i<x;i++){\n\t\t\tfor(j=0;j<y;j++){\n\t\t\t\tfor(k=0;k<8;k++){\n\t\t\t\t\tans(dn,i,j,k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmaxl=0;\n\t\tfor(i=0;i<sps;i++){\n\t\t\tif(maxl<strlen(sp[i])){\n\t\t\t\tmaxl=strlen(sp[i]);\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<sps;i++){\n\t\t\tif(maxl>strlen(sp[i])){\n\t\t\t\tsp[i][0]='a';\n\t\t\t}\n\t\t}\n\t\tfinal=0;\n\t\tfor(i=1;i<sps;i++){\n\t\t\tif(strcmp(sp[final],sp[i])>0){\n\t\t\t\tfinal=i;\n\t\t\t}\n\t\t}\n\t\tif(strlen(sp[final])==0){\n\t\t\tprintf(\"0\\n\");\n\t\t}\n\t\telse{\n\t\t\tfor(i=0;i<strlen(sp[final]);i++){\n\t\t\t\tprintf(\"%c\",sp[final][i]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <cstdio>\n#include <string>\n#include <set>\n#include <vector>\nusing  namespace std;\n\nint dr[]={-1, -1, -1, 0, 0, 1, 1, 1};\nint dc[]={-1, 0, 1, -1, 1, -1, 0, 1};\n\nbool cmp(const string& a, const string& b)\n{\n    if (a.size()<b.size()) return 1;\n    if (a.size()>b.size()) return 0;\n    return a>b;\n}\n\nint main()\n{\n    int n, m;\n    while (scanf(\"%d%d\", &n, &m), n) {\n        char s[11][21];\n        for(int i=0;i<n;++i) scanf(\"%s\", s[i]);\n\n        int maxlen=0;\n        vector<string> spells[200];\n        for(int i=0;i<n;++i) for(int j=0;j<m;++j) for(int k=0;k<8;++k) {\n            int r=i, c=j, q=0;\n            string t;\n            do {\n                t+=s[r][c];\n                spells[q++].push_back(t);\n                r=(r+dr[k]+2*n)%n;\n                c=(c+dc[k]+2*m)%m;\n            } while (r!=i || c!=j);\n            maxlen=max(maxlen, q);\n        }\n\n        string res;\n        for(int k=1;k<maxlen;++k) {\n            int N=spells[k].size();\n            set<string> v;\n            for(int i=0;i<N;++i) {\n                if (v.count(spells[k][i]) and cmp(res, spells[k][i]))\n                    res=spells[k][i];\n                v.insert(spells[k][i]);\n            }\n        }\n        puts(res.size()?res.c_str():\"0\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint horieyui(const void* x, const void* y) {\n\tconst char* a = (const char*)x, *b = (const char*)y;\n\tsize_t aa = strlen(a), bb = strlen(b);\n\tif (aa != bb) return aa > bb ? -1 : 1;\n\treturn strcmp(a, b);\n}\n\nint h, w;\nchar data[10][21];\n\nchar visited[10][21];\n\nint candidateCount;\nchar candidates[10 * 20 * 8 * 10 * 20][10 * 20 + 1];\n\nint main(void) {\n\twhile (scanf(\"%d%d\", &h, &w) == 2 && (h|w) != 0) {\n\t\tint i, j;\n\t\tint found;\n\t\tfor (i = 0; i < h; i++) {\n\t\t\tif (scanf(\"%31s\", data[i]) != 1) return 1;\n\t\t}\n\t\tcandidateCount = 0;\n\t\tfor (i = 0; i < h; i++) {\n\t\t\tfor (j = 0; j < w; j++) {\n\t\t\t\tint dx, dy;\n\t\t\t\tfor (dy = -1; dy <= 1; dy++) {\n\t\t\t\t\tfor (dx = -1; dx <= 1; dx++) {\n\t\t\t\t\t\tif (dx != 0 || dy != 0) {\n\t\t\t\t\t\t\tint p = 0;\n\t\t\t\t\t\t\tint y = i, x = j;\n\t\t\t\t\t\t\tmemset(visited, 0, sizeof(visited));\n\t\t\t\t\t\t\twhile (!visited[y][x]) {\n\t\t\t\t\t\t\t\tvisited[y][x] = 1;\n\t\t\t\t\t\t\t\tif(p > 0) strcpy(candidates[candidateCount], candidates[candidateCount - 1]);\n\t\t\t\t\t\t\t\tcandidates[candidateCount][p] = data[y][x];\n\t\t\t\t\t\t\t\tcandidates[candidateCount][p + 1] = '\\0';\n\t\t\t\t\t\t\t\tcandidateCount++;\n\t\t\t\t\t\t\t\tp++;\n\t\t\t\t\t\t\t\ty += dy;\n\t\t\t\t\t\t\t\tx += dx;\n\t\t\t\t\t\t\t\tif (y < 0) y += h;\n\t\t\t\t\t\t\t\tif (x < 0) x += w;\n\t\t\t\t\t\t\t\tif (y >= h) y -= h;\n\t\t\t\t\t\t\t\tif (x >= w) x -= w;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tqsort(candidates, candidateCount, sizeof(*candidates), horieyui);\n\t\tfound = 0;\n\t\tfor (i = 1; i < candidateCount; i++) {\n\t\t\tif (strlen(candidates[i]) < 2) break;\n\t\t\tif (strcmp(candidates[i - 1], candidates[i]) == 0) {\n\t\t\t\tputs(candidates[i]);\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found) puts(\"0\");\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String [] args) {\n        new Main().run();\n    }\n    final int [] dx = {0, 1, 1,  1,  0, -1, -1, -1};\n    final int [] dy = {1, 1, 0, -1, -1, -1,  0,  1};\n    HashSet<String> occurOnce;\n    //HashSet<Integer> occurOnce;\n    String longestString(int y, int x) {\n        String longest = \"\";\n        for (int i = 0; i < 8; i++) {\n            String cur = String.valueOf(F[y].charAt(x));\n            StringBuilder sb = new StringBuilder(cur);\n            int ny = (y + dy[i] + H) % H, nx = (x + dx[i] + W) % W;\n            while (ny != y || nx != x) {\n                //cur = cur + String.valueOf(F[ny].charAt(nx));\n                sb.append(String.valueOf(F[ny].charAt(nx)));\n                cur = sb.toString();\n                int hashCode = cur.hashCode();\n                if (occurOnce.contains(cur)) {\n                //if (occurOnce.contains(hashCode)) {\n                    if (longest.length() < cur.length()) {\n                        //debug(cur);\n                        longest = cur;\n                    } else if (longest.length() == cur.length() && longest.compareTo(cur) > 0) {\n                        //debug(cur);\n                        longest = cur;\n                    }\n                } else {\n                    if (cur.length() >= longest.length()) occurOnce.add(cur);\n                    //occurOnce.add(hashCode);\n                }\n                ny = (ny + dy[i] + H) % H;\n                nx = (nx + dx[i] + W) % W;\n            }\n        }\n        //debug(longest);\n        return longest;\n    }\n    void debug(Object ... o) {\n        System.out.println(Arrays.deepToString(o));\n    }\n    void run() {\n        while (init()) {\n            String longest = \"\";\n            occurOnce = new HashSet<String>();\n            //occurOnce = new HashSet<Integer>();\n            for (int i = 0; i < H; i++) {\n                for (int j = 0; j < W; j++) {\n                    String cur = longestString(i, j);\n                    if (longest.length() < cur.length()) {\n                        //debug(cur);\n                        longest = cur;\n                    } else if (longest.length() == cur.length() && longest.compareTo(cur) > 0) {\n                        //debug(cur);\n                        longest = cur;\n                    }\n                }\n            }\n            if (longest.length() < 2) {\n                System.out.println(0);\n            } else {\n                System.out.println(longest);\n            }\n        }\n    }\n    Scanner sc;\n    Main() {\n        sc = new Scanner(System.in);\n    }\n    int W, H;\n    String [] F;\n    boolean init() {\n        H = sc.nextInt();\n        W = sc.nextInt();\n        if (H == 0 && W == 0) return false;\n        F = new String[H];\n        for (int i = 0; i < H; i++) {\n            F[i] = sc.next();\n        }\n        return true;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tint h, w;\n\tchar[][] map;\n\tboolean[][] visited;\n\tint[] dirx = {-1, 0, 1, -1, 1, -1, 0, 1};\n\tint[] diry = {-1, -1, -1, 0, 0, 1, 1, 1};\n\tHashSet<String> hash;\n\tString ans;\n\tint x, y;\n\t\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\th = in.nextInt();\n\t\t\tw = in.nextInt();\n\t\t\tif ((h|w) == 0) break;\n\t\t\tmap = new char[h][w];\n\t\t\tvisited = new boolean[h][w];\n\t\t\thash = new HashSet<String>(0);\n\t\t\tans = \"\";\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tString s = in.next();\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tmap[i][j] = s.charAt(j);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tfor (int k = 0; k < 8; k++) {\n\t\t\t\t\t\tx = j; y = i;\n\t\t\t\t\t\tStringBuilder sb = new StringBuilder(map[y][x]);\n\t\t\t\t\t\tfor (int l = 0; l < visited.length; l++)\n\t\t\t\t\t\t\tArrays.fill(visited[l], false);\n\t\t\t\t\t\tvisited[i][j] = true;\n\t\t\t\t\t\tfor ( ; ; ) {\n\t\t\t\t\t\t\tx = (x + dirx[k] + w) % w;\n\t\t\t\t\t\t\ty = (y + diry[k] + h) % h;\n\t\t\t\t\t\t\tsb.append(map[y][x]);\n\t\t\t\t\t\t\tif (!visited[y][x]) {\n\t\t\t\t\t\t\t\tif (hash.contains(sb.toString())) {\n\t\t\t\t\t\t\t\t\tif (sb.length() > ans.length() || (sb.length() == ans.length() && sb.toString().compareTo(ans) < 0)) {\n\t\t\t\t\t\t\t\t\t\tans = sb.toString();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if (sb.length() > Math.max(2, ans.length())) {\n\t\t\t\t\t\t\t\t\thash.add(sb.toString());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (ans.length() < 2)\n\t\t\t\tSystem.out.println(0);\n\t\t\telse\n\t\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tint h, w;\n\tchar[][] map;\n\tboolean[][] visited;\n\tint[] dirx = {-1, 0, 1, -1, 1, -1, 0, 1};\n\tint[] diry = {-1, -1, -1, 0, 0, 1, 1, 1};\n\tHashSet<String> hash;\n\tString ans;\n\t\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\th = in.nextInt();\n\t\t\tw = in.nextInt();\n\t\t\tif ((h|w) == 0) break;\n\t\t\tmap = new char[h][w];\n\t\t\tvisited = new boolean[h][w];\n\t\t\thash = new HashSet<String>();\n\t\t\tans = \"\";\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tString s = in.next();\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tmap[i][j] = s.charAt(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tfor (int k = 0; k < 8; k++) {\n\t\t\t\t\t\tint x = j, y = i;\n\t\t\t\t\t\tString s = map[y][x] + \"\";\n\t\t\t\t\t\tfor (int l = 0; l < visited.length; l++)\n\t\t\t\t\t\t\tArrays.fill(visited[l], false);\n\t\t\t\t\t\tvisited[i][j] = true;\n\t\t\t\t\t\tfor ( ; ; ) {\n\t\t\t\t\t\t\tx = (x + dirx[k] + w) % w;\n\t\t\t\t\t\t\ty = (y + diry[k] + h) % h;\n\t\t\t\t\t\t\ts += map[y][x];\n\t\t\t\t\t\t\tif (!visited[y][x]) {\n\t\t\t\t\t\t\t\tif (hash.contains(s)) {\n\t\t\t\t\t\t\t\t\tif (s.length() > ans.length() || (s.length() == ans.length() && s.compareTo(ans) < 0)) {\n\t\t\t\t\t\t\t\t\t\tans = s.toString();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\thash.add(s);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (ans.length() < 2)\n\t\t\t\tSystem.out.println(0);\n\t\t\telse\n\t\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\nclass LengthComparator implements Comparator<String> {\n    public int compare(String a, String b) {\n        if (a.length() == b.length()) {\n            return a.compareTo(b);\n        } else {\n            return b.length() - a.length();\n        }\n    }\n}\n\n\npublic class Main {\n    public static void main(String [] args) {\n        new Main().run();\n    }\n    final int [] dx = {0, 1, 1,  1,  0, -1, -1, -1};\n    final int [] dy = {1, 1, 0, -1, -1, -1,  0,  1};\n    HashSet<String> occurOnce;\n    HashSet<String> occurTwice;\n    void makeString(int y, int x) {\n        for (int i = 0; i < 8; i++) {\n            String cur = String.valueOf(F[y].charAt(x));\n            int ny = (y + dy[i] + H) % H, nx = (x + dx[i] + W) % W;\n            while (ny != y || nx != x) {\n                cur = cur + String.valueOf(F[ny].charAt(nx));\n                if (occurOnce.contains(cur)) {\n                    occurTwice.add(cur);\n                } else {\n                    occurOnce.add(cur);\n                }\n                ny = (ny + dy[i] + H) % H;\n                nx = (nx + dx[i] + W) % W;\n            }\n        }\n    }\n    void debug(Object ... o) {\n        System.out.println(Arrays.deepToString(o));\n    }\n    void run() {\n        while (init()) {\n            ArrayList<String> ans = new ArrayList<String>();\n            for (char c = 'A'; c <= 'Z'; c++) {\n                occurOnce = new HashSet<String>();\n                occurTwice = new HashSet<String>();\n                for (int i = 0; i < H; i++) {\n                    for (int j = 0; j < W; j++) {\n                        if (F[i].charAt(j) == c) makeString(i, j);\n                    }\n                }\n                ArrayList<String> list = new ArrayList<String>();\n                for (Iterator it = occurTwice.iterator(); it.hasNext(); ) {\n                    String spell = (String)it.next();\n                    list.add(spell);\n                }\n                if (list.isEmpty()) continue;\n                ans.add(Collections.min(list, new LengthComparator()));\n            }\n            if (ans.isEmpty()) {\n                System.out.println(0);\n            } else {\n                //Collections.sort(ans, new LengthComparator());\n                //System.out.println(ans.get(0));\n                System.out.println(Collections.min(ans, new LengthComparator()));\n            }\n        }\n    }\n    Scanner sc;\n    Main() {\n        sc = new Scanner(System.in);\n    }\n    int W, H;\n    String [] F;\n    boolean init() {\n        H = sc.nextInt();\n        W = sc.nextInt();\n        if (H == 0 && W == 0) return false;\n        F = new String[H];\n        for (int i = 0; i < H; i++) {\n            F[i] = sc.next();\n        }\n        return true;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tint h, w;\n\tchar[][] map;\n\tboolean[][] visited;\n\tint[] dirx = {-1, 0, 1, -1, 1, -1, 0, 1};\n\tint[] diry = {-1, -1, -1, 0, 0, 1, 1, 1};\n\tHashSet<String> hash;\n\tString ans;\n\t\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\th = in.nextInt();\n\t\t\tw = in.nextInt();\n\t\t\tif ((h|w) == 0) break;\n\t\t\tmap = new char[h][w];\n\t\t\tvisited = new boolean[h][w];\n\t\t\thash = new HashSet<String>();\n\t\t\tans = \"\";\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tString s = in.next();\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tmap[i][j] = s.charAt(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tfor (int k = 0; k < 8; k++) {\n\t\t\t\t\t\tint x = j, y = i;\n\t\t\t\t\t\tString s = map[y][x] + \"\";\n\t\t\t\t\t\tfor (int l = 0; l < visited.length; l++)\n\t\t\t\t\t\t\tArrays.fill(visited[l], false);\n\t\t\t\t\t\tvisited[i][j] = true;\n\t\t\t\t\t\tfor ( ; ; ) {\n\t\t\t\t\t\t\tx = (x + dirx[k] + w) % w;\n\t\t\t\t\t\t\ty = (y + diry[k] + h) % h;\n\t\t\t\t\t\t\ts += map[y][x];\n\t\t\t\t\t\t\tif (!visited[y][x]) {\n\t\t\t\t\t\t\t\tif (hash.contains(s)) {\n\t\t\t\t\t\t\t\t\tif (s.length() > ans.length() || (s.length() == ans.length() && s.compareTo(ans) < 0)) {\n\t\t\t\t\t\t\t\t\t\tans = s.toString();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if (s.length() >= 2 && ans.length() < s.length()){\n\t\t\t\t\t\t\t\t\thash.add(s);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (ans.length() < 2)\n\t\t\t\tSystem.out.println(0);\n\t\t\telse\n\t\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String [] args) {\n        new Main().run();\n    }\n    final int [] dx = {0, 1, 1,  1,  0, -1, -1, -1};\n    final int [] dy = {1, 1, 0, -1, -1, -1,  0,  1};\n    HashSet<String> occurOnce;\n    HashSet<String> occurTwice;\n    void makeString(int y, int x) {\n        for (int i = 0; i < 8; i++) {\n            String cur = String.valueOf(F[y].charAt(x));\n            int ny = (y + dy[i] + H) % H, nx = (x + dx[i] + W) % W;\n            while (ny != y || nx != x) {\n                cur = cur + String.valueOf(F[ny].charAt(nx));\n                if (occurOnce.contains(cur)) {\n                    occurTwice.add(cur);\n                } else {\n                    occurOnce.add(cur);\n                }\n                ny = (ny + dy[i] + H) % H;\n                nx = (nx + dx[i] + W) % W;\n            }\n        }\n    }\n    void debug(Object ... o) {\n        System.out.println(Arrays.deepToString(o));\n    }\n    void run() {\n        while (init()) {\n            occurOnce = new HashSet<String>();\n            occurTwice = new HashSet<String>();\n            for (int i = 0; i < H; i++) {\n                for (int j = 0; j < W; j++) {\n                    makeString(i, j);\n                }\n            }\n            ArrayList<String> list = new ArrayList<String>();\n            for (Iterator it = occurTwice.iterator(); it.hasNext(); ) {\n                String spell = (String)it.next();\n                list.add(spell);\n            }\n            if (list.isEmpty()) {\n                System.out.println(0);\n            } else {\n                Collections.sort(list, \n                    new Comparator<String>() {\n                        @Override public int compare(String a, String b) {\n                            if (a.length() == b.length()) {\n                                return a.compareTo(b);\n                            } else {\n                                return b.length() - a.length();\n                            }\n                        }\n                });\n                System.out.println(list.get(0));\n            }\n        }\n    }\n    Scanner sc;\n    Main() {\n        sc = new Scanner(System.in);\n    }\n    int W, H;\n    String [] F;\n    boolean init() {\n        H = sc.nextInt();\n        W = sc.nextInt();\n        if (H == 0 && W == 0) return false;\n        F = new String[H];\n        for (int i = 0; i < H; i++) {\n            F[i] = sc.next();\n        }\n        return true;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tif ((h | w) == 0)\n\t\t\t\tbreak;\n\t\t\tchar[][] field = new char[h][w];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tString s = sc.next();\n\t\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\t\tfield[i][j] = s.charAt(j);\n\t\t\t}\n\t\t\tString result = \"\";\n\t\t\tSet<String> set = new HashSet<String>(0);\n\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tString s = \"\";\n\t\t\t\t\tint[] dx = { 1, 1, 0, -1, -1, -1, 0, 1 };\n\t\t\t\t\tint[] dy = { 0, 1, 1, 1, 0, -1, -1, -1 };\n\t\t\t\t\tint px = j;\n\t\t\t\t\tint py = i;\n\t\t\t\t\tfor (int k = 0; k < 8; k++) {\n\t\t\t\t\t\ts = \"\";\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\ts += field[py][px];\n\t\t\t\t\t\t\tpx = (px + dx[k] + w) % w;\n\t\t\t\t\t\t\tpy = (py + dy[k] + h) % h;\n\t\t\t\t\t\t\tif (s.length() >= 2\n\t\t\t\t\t\t\t\t\t&& !set.add(s)\n\t\t\t\t\t\t\t\t\t&& (result.length() < s.length() || (result\n\t\t\t\t\t\t\t\t\t\t\t.length() == s.length() && result\n\t\t\t\t\t\t\t\t\t\t\t.compareTo(s) > 0))) {\n\t\t\t\t\t\t\t\tresult = s;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} while (!(px == j && py == i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tif (result.length() < 2)\n\t\t\t\tSystem.out.println(0);\n\t\t\telse\n\t\t\t\tSystem.out.println(result);\n\t\t}\n\t\tsc.close();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tif ((h | w) == 0)\n\t\t\t\tbreak;\n\t\t\tString[] field = new String[h];\n//\t\t\tchar[][] field = new char[h][w];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfield[i] = sc.next();\n//\t\t\t\tfor (int j = 0; j < w; j++)\n//\t\t\t\t\tfield[i][j] = s.charAt(j);\n\t\t\t}\n\t\t\tString result = \"\";\n\t\t\tSet<String> set = new HashSet<String>(0);\n\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tString s = \"\";\n\t\t\t\t\tint[] dx = { 1, 1, 0, -1, -1, -1, 0, 1 };\n\t\t\t\t\tint[] dy = { 0, 1, 1, 1, 0, -1, -1, -1 };\n\t\t\t\t\tint px = j;\n\t\t\t\t\tint py = i;\n\t\t\t\t\tfor (int k = 0; k < 8; k++) {\n\t\t\t\t\t\ts = \"\";\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\ts += field[py].charAt(px);\n\t\t\t\t\t\t\tpx = (px + dx[k] + w) % w;\n\t\t\t\t\t\t\tpy = (py + dy[k] + h) % h;\n\t\t\t\t\t\t\tif (s.length() >= Math.max(2, result.length())\n\t\t\t\t\t\t\t\t\t&& !set.add(s)\n\t\t\t\t\t\t\t\t\t&& (result.length() < s.length() || (result\n\t\t\t\t\t\t\t\t\t\t\t.length() == s.length() && result\n\t\t\t\t\t\t\t\t\t\t\t.compareTo(s) > 0))) {\n\t\t\t\t\t\t\t\tresult = s;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} while (!(px == j && py == i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tif (result.length() < 2)\n\t\t\t\tSystem.out.println(0);\n\t\t\telse\n\t\t\t\tSystem.out.println(result);\n\t\t}\n\t\tsc.close();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.HashMap;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\n\tint H,W;\n\tint[] DX = {0,0,1,1,1,-1,-1,-1};\n\tint[] DY = {1,-1,0,1,-1,0,1,-1};\n\tboolean[][] used;\n\tchar[][] spells;\n\tHashMap<String,Integer> map;\n\n\tpublic String dfs(int h,int w,int dy,int dx){\n\n\t\tif(used[h][w])return \"\";\n\t\tused[h][w] = true;\n\n\n\t\tString ret = \"\";\n\t\tint nh = (h + dy + H) % H;\n\t\tint nw = (w + dx + W) % W;\n\n\t\tret = spells[h][w] + dfs(nh,nw,dy,dx);\n\n\t\tused[h][w] = false;\n\t\tmap.put(ret, map.containsKey(ret)  ? map.get(ret) + 1 : 1);\n\t\treturn ret;\n\t}\n\n\n\tpublic void solve() {\n\t\twhile(true){\n\t\t\tH = nextInt();\n\t\t\tW = nextInt();\n\t\t\tif(H + W == 0)break;\n\t\t\tmap = new HashMap<String,Integer>();\n\t\t\tspells = new char[H][];\n\n\t\t\tfor(int i = 0;i < H;i++){\n\t\t\t\tspells[i] = next().toCharArray();\n\t\t\t}\n\n\t\t\tused = new boolean[H][W];\n\n\t\t\tfor(int i = 0;i < H;i++){\n\t\t\t\tfor(int j = 0;j < W;j++){\n\t\t\t\t\tfor(int k = 0;k < DX.length;k++){\n\t\t\t\t\t\tdfs(i,j,DY[k],DX[k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tString ans = \"\";\n\t\t\tfor(String key : map.keySet()){\n\t\t\t\tif(map.get(key) >= 2 && key.length() >= 2){\n\n\t\t\t\t\tif(ans.length() < key.length()){\n\t\t\t\t\t\tans = key;\n\t\t\t\t\t}else if(ans.length() == key.length() && ans.compareTo(key) == 1){\n\t\t\t\t\t\tans = key;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tout.println(ans.length() == 0 ? 0 : ans);\n\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tout.flush();\n\t\tnew Main().solve();\n\t\tout.close();\n\t}\n\n\t/* Input */\n\tprivate static final InputStream in = System.in;\n\tprivate static final PrintWriter out = new PrintWriter(System.out);\n\tprivate final byte[] buffer = new byte[2048];\n\tprivate int p = 0;\n\tprivate int buflen = 0;\n\n\tprivate boolean hasNextByte() {\n\t\tif (p < buflen)\n\t\t\treturn true;\n\t\tp = 0;\n\t\ttry {\n\t\t\tbuflen = in.read(buffer);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tif (buflen <= 0)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tpublic boolean hasNext() {\n\t\twhile (hasNextByte() && !isPrint(buffer[p])) {\n\t\t\tp++;\n\t\t}\n\t\treturn hasNextByte();\n\t}\n\n\tprivate boolean isPrint(int ch) {\n\t\tif (ch >= '!' && ch <= '~')\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tprivate int nextByte() {\n\t\tif (!hasNextByte())\n\t\t\treturn -1;\n\t\treturn buffer[p++];\n\t}\n\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = -1;\n\t\twhile (isPrint((b = nextByte()))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic long nextLong() {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class Main {\n\n    void run() {\n        Scanner sc = new Scanner(System.in);\n        while (true) {\n            int h = sc.nextInt();\n            int w = sc.nextInt();\n            if ((h | w) == 0)\n                break;\n            Set<String> set = new HashSet<String>();\n            char[][] d = new char[h][w];\n            for (int i = 0; i < h; i++) {\n                d[i] = sc.next().toCharArray();\n            }\n            int max = 0;\n            String ans = \"\";\n            for (int i = 0; i < h; i++) {\n                for (int j = 0; j < w; j++) {\n                    int[] dx = { 0, 1, 1, 1, 0, -1, -1, -1 };\n                    int[] dy = { -1, -1, 0, 1, 1, 1, 0, -1 };\n                    int x = j;\n                    int y = i;\n                    for (int k = 0; k < 8; k++) {\n                        StringBuilder sb = new StringBuilder();\n                        sb.append(d[y][x]);\n                        int nx = x;\n                        int ny = y;\n                        while (true) {\n                            nx = nx + dx[k];\n                            ny = ny + dy[k];\n                            if (nx >= w) {\n                                nx = 0;\n                            } else if (nx < 0) {\n                                nx = w - 1;\n                            }\n                            if (ny >= h) {\n                                ny = 0;\n                            } else if (ny < 0) {\n                                ny = h - 1;\n                            }\n                            if (nx == x && ny == y) {\n                                break;\n                            }\n                            sb.append(d[ny][nx]);\n                            String str = sb.toString();\n                            if (set.contains(str)) {\n                                if (str.length() > max) {\n                                    max = str.length();\n                                    ans = str;\n                                } else if (max == str.length()) {\n                                    if (str.compareTo(ans) < 0) {\n                                        ans = str;\n                                    }\n                                }\n                            } else\n                                set.add(str);\n                        }\n                    }\n                }\n            }\n            System.out.println(ans.equals(\"\") ? 0 : ans);\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        new Main().run();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String [] args) {\n        new Main().run();\n    }\n    final int [] dx = {0, 1, 1,  1,  0, -1, -1, -1};\n    final int [] dy = {1, 1, 0, -1, -1, -1,  0,  1};\n    ArrayList<String> makeString(int y, int x) {\n        ArrayList<String> strs = new ArrayList<String>();\n        for (int i = 0; i < 8; i++) {\n            strs.add(String.valueOf(F[y].charAt(x)));\n            int ny = (y + dy[i] + H) % H, nx = (x + dx[i] + W) % W;\n            while (ny != y || nx != x) {\n                strs.add(strs.get(strs.size()-1) + String.valueOf(F[ny].charAt(nx)));\n                ny = (ny + dy[i] + H) % H;\n                nx = (nx + dx[i] + W) % W;\n            }\n        }\n        return strs;\n    }\n    void debug(Object ... o) {\n        System.out.println(Arrays.deepToString(o));\n    }\n    void run() {\n        while (init()) {\n            HashMap<String, Integer> occur = new HashMap<String, Integer>(); // 文字列 , 出現回数\n            for (int i = 0; i < H; i++) {\n                for (int j = 0; j < W; j++) {\n                    ArrayList<String> strs = makeString(i, j);\n                    //debug(i, j);\n                    //debug(strs);\n                    for (String str : strs) {\n                        if (occur.containsKey(str)) {\n                            occur.put(str, occur.get(str) + 1);\n                        } else {\n                            occur.put(str, 1);\n                        }\n                    }\n                }\n            }\n            ArrayList<String> list = new ArrayList<String>();\n            for (Iterator it = occur.entrySet().iterator(); it.hasNext(); ) {\n                Map.Entry e = (Map.Entry)it.next();\n                if ((Integer)e.getValue() >= 2 && ((String)e.getKey()).length() >= 2) {\n                    list.add((String)e.getKey());\n                }\n            }\n            if (list.isEmpty()) {\n                System.out.println(0);\n            } else {\n                Collections.sort(list, \n                    new Comparator<String>() {\n                        @Override public int compare(String a, String b) {\n                            if (a.length() == b.length()) {\n                                return a.compareTo(b);\n                            } else {\n                                return b.length() - a.length();\n                            }\n                        }\n                });\n                System.out.println(list.get(0));\n            }\n        }\n    }\n    Scanner sc;\n    Main() {\n        sc = new Scanner(System.in);\n    }\n    int W, H;\n    String [] F;\n    boolean init() {\n        H = sc.nextInt();\n        W = sc.nextInt();\n        if (H == 0 && W == 0) return false;\n        F = new String[H];\n        for (int i = 0; i < H; i++) {\n            F[i] = sc.next();\n        }\n        return true;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.Arrays;\nimport java.util.TreeSet;\nimport java.util.ArrayList;\nimport java.util.Set;\n\npublic class Main {\n\tchar[][] fie;\n\tboolean[][] used;\n\tint h,w;\n\tint dx[]={1,0,-1,0,1,1,-1,-1};\n\tint dy[]={0,1,0,-1,1,-1,1,-1};\n\n\tint goindex(int first,int len){\n\t\treturn first*200+len;\n\t}\n\n\tpublic void run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfie = new char[21][11];\n\t\twhile(true){\n\t\t\th=sc.nextInt();\n\t\t\tw=sc.nextInt();\n\t\t\tif(h+w==0)break;\n\t\t\tArrayList<TreeSet<String>> magic = new ArrayList<TreeSet<String>>();\n\t\t\tfor(int i=0;i<5200;i++){\n\t\t\t\tmagic.add(new TreeSet<String>());\n\t\t\t}\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tString line = sc.next();\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tfie[j][i]=line.charAt(j); \n\t\t\t\t}\n\t\t\t}\n\t\t\tString res=\"0\";\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tfor(int k=0;k<8;k++){\n\t\t\t\t\t\tboolean[][] used = new boolean[21][11];\n\t\t\t\t\t\tString str=\"\";\n\t\t\t\t\t\tint x=j,y=i;\n\t\t\t\t\t\twhile(!used[x][y]){\n\t\t\t\t\t\t\tused[x][y]=true;\n\t\t\t\t\t\t\tstr+=fie[x][y];\n\t\t\t\t\t\t\tif(str.length()>=2){\n\t\t\t\t\t\t\t\tif(magic.get(goindex(str.charAt(0)-'A',str.length())).contains(str)){\n\t\t\t\t\t\t\t\t\tif(res.length()<str.length() || (res.length()==str.length() && str.compareTo(res)<0))res=str;\n\t\t\t\t\t\t\t\t}else if(res.length()<=str.length())magic.get(goindex(str.charAt(0)-'A',str.length())).add(str);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ty=(y+dy[k]+h)%h;\n\t\t\t\t\t\t\tx=(x+dx[k]+w)%w;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\n\n//The Sorcerer's Donut\npublic class Main{\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tint[][] move = {{-1,-1},{-1,0},{-1,1},{0,-1},{0,1},{1,-1},{1,0},{1,1}};\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint h = sc.nextInt(), w = sc.nextInt();\n\t\t\tif((h|w)==0)break;\n\t\t\tchar[][] m = new char[h][w];\n\t\t\tfor(int i=0;i<h;i++)m[i]=sc.next().toCharArray();\n\t\t\tSet<String>[][] set = new HashSet[26][201];\n\t\t\tfor(int i=0;i<26;i++)for(int j=0;j<=200;j++)set[i][j] = new HashSet<String>();\n\t\t\tString res = \"\";\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\t\tfor(int k=0;k<8;k++){\n\t\t\t\t\tStringBuilder sb = new StringBuilder(m[i][j]+\"\");\n\t\t\t\t\tint pi = (i+move[k][0]+h)%h, pj = (j+move[k][1]+w)%w;\n\t\t\t\t\twhile(pi!=i||pj!=j){\n\t\t\t\t\t\tsb.append(m[pi][pj]);\n\t\t\t\t\t\tString r = sb.toString();\n\t\t\t\t\t\tif(set[m[i][j]-'A'][r.length()].contains(r)){\n\t\t\t\t\t\t\tif(res.length()<r.length())res = r;\n\t\t\t\t\t\t\telse if(res.length()==r.length()&&r.compareTo(res)<0)res = r;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse set[m[i][j]-'A'][r.length()].add(r);\n\t\t\t\t\t\tpi = (pi+move[k][0]+h)%h; pj = (pj+move[k][1]+w)%w;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(\"\".equals(res)?\"0\":res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\nclass LengthComparator implements Comparator<String> {\n    public int compare(String a, String b) {\n        if (a.length() == b.length()) {\n            return a.compareTo(b);\n        } else {\n            return b.length() - a.length();\n        }\n    }\n}\n\npublic class Main {\n    public static void main(String [] args) {\n        new Main().run();\n    }\n    final int [] dx = {0, 1, 1,  1,  0, -1, -1, -1};\n    final int [] dy = {1, 1, 0, -1, -1, -1,  0,  1};\n    HashSet<Integer> occurOnce;\n    HashSet<String> occurTwice;\n    void makeString(int y, int x) {\n        for (int i = 0; i < 8; i++) {\n            String cur = String.valueOf(F[y].charAt(x));\n            int ny = (y + dy[i] + H) % H, nx = (x + dx[i] + W) % W;\n            while (ny != y || nx != x) {\n                cur = cur + String.valueOf(F[ny].charAt(nx));\n                int hashCode = cur.hashCode();\n                if (occurOnce.contains(hashCode)) {\n                    occurTwice.add(cur);\n                } else {\n                    occurOnce.add(hashCode);\n                }\n                ny = (ny + dy[i] + H) % H;\n                nx = (nx + dx[i] + W) % W;\n            }\n        }\n    }\n    void debug(Object ... o) {\n        System.out.println(Arrays.deepToString(o));\n    }\n    void run() {\n        while (init()) {\n            ArrayList<String> ans = new ArrayList<String>();\n            for (char c = 'A'; c <= 'Z'; c++) {\n                occurOnce = new HashSet<Integer>();\n                occurTwice = new HashSet<String>();\n                for (int i = 0; i < H; i++) {\n                    for (int j = 0; j < W; j++) {\n                        if (F[i].charAt(j) == c) makeString(i, j);\n                    }\n                }\n                if (occurTwice.isEmpty()) continue;\n                ans.add(Collections.min(occurTwice, new LengthComparator()));\n            }\n            if (ans.isEmpty()) {\n                System.out.println(0);\n            } else {\n                System.out.println(Collections.min(ans, new LengthComparator()));\n            }\n        }\n    }\n    Scanner sc;\n    Main() {\n        sc = new Scanner(System.in);\n    }\n    int W, H;\n    String [] F;\n    boolean init() {\n        H = sc.nextInt();\n        W = sc.nextInt();\n        if (H == 0 && W == 0) return false;\n        F = new String[H];\n        for (int i = 0; i < H; i++) {\n            F[i] = sc.next();\n        }\n        return true;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.HashMap;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\n\tint H,W;\n\tint[] DX = {0,0,1,1,1,-1,-1,-1};\n\tint[] DY = {1,-1,0,1,-1,0,1,-1};\n\tboolean[][] used;\n\tchar[][] spells;\n\tHashMap<String,Integer> map;\n\n\tpublic String dfs(int h,int w,int dy,int dx){\n\n\t\tif(used[h][w])return \"\";\n\t\tused[h][w] = true;\n\n\n\t\tString ret = \"\";\n\t\tint nh = (h + dy + H) % H;\n\t\tint nw = (w + dx + W) % W;\n\n\t\tret = spells[h][w] + dfs(nh,nw,dy,dx);\n\n\t\tused[h][w] = false;\n\t\tmap.put(ret, map.containsKey(ret)  ? map.get(ret) + 1 : 1);\n\t\treturn ret;\n\t}\n\n\n\tpublic void solve() {\n\t\twhile(true){\n\t\t\tH = nextInt();\n\t\t\tW = nextInt();\n\t\t\tif(H + W == 0)break;\n\t\t\tmap = new HashMap<String,Integer>();\n\t\t\tspells = new char[H][];\n\n\t\t\tfor(int i = 0;i < H;i++){\n\t\t\t\tspells[i] = next().toCharArray();\n\t\t\t}\n\n\t\t\tused = new boolean[H][W];\n\n\t\t\tfor(int i = 0;i < H;i++){\n\t\t\t\tfor(int j = 0;j < W;j++){\n\t\t\t\t\tfor(int k = 0;k < DX.length;k++){\n\t\t\t\t\t\tdfs(i,j,DY[k],DX[k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tString ans = \"\";\n\t\t\tfor(String key : map.keySet()){\n\t\t\t\tif(map.get(key) >= 2 && key.length() >= 2){\n\n\t\t\t\t\tif(ans.length() < key.length()){\n\t\t\t\t\t\tans = key;\n\t\t\t\t\t}else if(ans.length() == key.length() && ans.compareTo(key) >= 1){\n\t\t\t\t\t\tans = key;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tout.println(ans.length() == 0 ? 0 : ans);\n\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tout.flush();\n\t\tnew Main().solve();\n\t\tout.close();\n\t}\n\n\t/* Input */\n\tprivate static final InputStream in = System.in;\n\tprivate static final PrintWriter out = new PrintWriter(System.out);\n\tprivate final byte[] buffer = new byte[2048];\n\tprivate int p = 0;\n\tprivate int buflen = 0;\n\n\tprivate boolean hasNextByte() {\n\t\tif (p < buflen)\n\t\t\treturn true;\n\t\tp = 0;\n\t\ttry {\n\t\t\tbuflen = in.read(buffer);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tif (buflen <= 0)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tpublic boolean hasNext() {\n\t\twhile (hasNextByte() && !isPrint(buffer[p])) {\n\t\t\tp++;\n\t\t}\n\t\treturn hasNextByte();\n\t}\n\n\tprivate boolean isPrint(int ch) {\n\t\tif (ch >= '!' && ch <= '~')\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tprivate int nextByte() {\n\t\tif (!hasNextByte())\n\t\t\treturn -1;\n\t\treturn buffer[p++];\n\t}\n\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = -1;\n\t\twhile (isPrint((b = nextByte()))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic long nextLong() {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tint h, w;\n\tchar[][] map;\n\tboolean[][] visited;\n\tint[] dirx = {-1, 0, 1, -1, 1, -1, 0, 1};\n\tint[] diry = {-1, -1, -1, 0, 0, 1, 1, 1};\n\tHashSet<String> hash;\n\tString ans;\n\tint x, y;\n\tString s;\n\t\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\th = in.nextInt();\n\t\t\tw = in.nextInt();\n\t\t\tif ((h|w) == 0) break;\n\t\t\tmap = new char[h][w];\n\t\t\tvisited = new boolean[h][w];\n\t\t\thash = new HashSet<String>(0);\n\t\t\tans = \"\";\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tString s = in.next();\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tmap[i][j] = s.charAt(j);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tfor (int k = 0; k < 8; k++) {\n\t\t\t\t\t\tx = j; y = i;\n\t\t\t\t\t\ts = map[y][x] + \"\";\n\t\t\t\t\t\tfor (int l = 0; l < visited.length; l++)\n\t\t\t\t\t\t\tArrays.fill(visited[l], false);\n\t\t\t\t\t\tvisited[i][j] = true;\n\t\t\t\t\t\tfor ( ; ; ) {\n\t\t\t\t\t\t\tx = (x + dirx[k] + w) % w;\n\t\t\t\t\t\t\ty = (y + diry[k] + h) % h;\n\t\t\t\t\t\t\ts += map[y][x];\n\t\t\t\t\t\t\tif (!visited[y][x]) {\n\t\t\t\t\t\t\t\tif (hash.contains(s)) {\n\t\t\t\t\t\t\t\t\tif (s.length() > ans.length() || (s.length() == ans.length() && s.compareTo(ans) < 0)) {\n\t\t\t\t\t\t\t\t\t\tans = s.toString();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if (s.length() > Math.max(2, ans.length())) {\n\t\t\t\t\t\t\t\t\thash.add(s.toString());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (ans.length() < 2)\n\t\t\t\tSystem.out.println(0);\n\t\t\telse\n\t\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tif ((h | w) == 0)\n\t\t\t\tbreak;\n\t\t\tchar[][] field = new char[h][w];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tString s = sc.next();\n\t\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\t\tfield[i][j] = s.charAt(j);\n\t\t\t}\n\t\t\tString result = \"\";\n\t\t\tSet<String> set = new HashSet<String>(0);\n\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tString s = \"\";\n\t\t\t\t\tint[] dx = { 1, 1, 0, -1, -1, -1, 0, 1 };\n\t\t\t\t\tint[] dy = { 0, 1, 1, 1, 0, -1, -1, -1 };\n\t\t\t\t\tint px = j;\n\t\t\t\t\tint py = i;\n\t\t\t\t\tfor (int k = 0; k < 8; k++) {\n\t\t\t\t\t\ts = \"\";\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\ts += field[py][px];\n\t\t\t\t\t\t\tif (!set.add(s)\n\t\t\t\t\t\t\t\t\t&& (result.length() < s.length() || (result\n\t\t\t\t\t\t\t\t\t\t\t.length() == s.length() && s\n\t\t\t\t\t\t\t\t\t\t\t.compareTo(result) < 0)))\n\t\t\t\t\t\t\t\tresult = s;\n\t\t\t\t\t\t\tpx = (px + dx[k] + w) % w;\n\t\t\t\t\t\t\tpy = (py + dy[k] + h) % h;\n\t\t\t\t\t\t} while (!(px == j && py == i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tif (result.length() < 2)\n\t\t\t\tSystem.out.println(0);\n\t\t\telse\n\t\t\t\tSystem.out.println(result);\n\t\t}\n\t\tsc.close();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    int h, w;\n    int[] dx = {0, 0, 1, -1, 1, 1, -1, -1};\n    int[] dy = {1, -1, 0, 0, 1, -1, 1, -1};\n    char[][] donut;\n    String cutS;\n\n    @SuppressWarnings(\"unchecked\")\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        while(true){\n            h = sc.nextInt();\n            w = sc.nextInt();\n            if(h==0 && w==0) break;\n\n            donut = new char[h][w];\n            for(int i=0; i<h; i++){\n                String line = sc.next();\n                donut[i] = line.toCharArray();\n            }\n\n            int max = 0;\n            StringBuilder minString = new StringBuilder();\n\n            for(int l=h*w-1; l>=2; l--){\n                HashSet<String> set = new HashSet<String>();\n                for(int i=0; i<h; i++){\n                    for(int j=0; j<w; j++){\n                        for(int k=0; k<8; k++){                        \n                            StringBuilder s = new StringBuilder();\n                            s.append(donut[i][j]);\n                            int ny = (i + dy[k]) % h, nx = (j + dx[k]) % w;\n                            if(ny==-1) ny = h-1;\n                            if(nx==-1) nx = w-1;\n                            while(!(ny==i && nx==j)){\n                                if(s.length()==l) break;\n                                s.append(donut[ny][nx]);\n                                ny = (ny + dy[k]) % h;\n                                nx = (nx + dx[k]) % w;\n                                if(ny==-1) ny = h-1;\n                                if(nx==-1) nx = w-1;\n                            }\n                            if(s.length()!=l) continue;\n\n                            if(!set.add(s.toString()) && (minString.length()==0 || min(s, minString))){\n                                max = s.length();\n                                minString = s;\n                            }\n                        }\n                    }\n                }\n                if(max!=0) break;\n            }\n\n            if(minString.length()==0) System.out.println(0);\n            else System.out.println(minString.toString());\n        }\n    }\n\n    boolean min(StringBuilder s1, StringBuilder s2){ //s1 < s2?\n        int l1 = s1.length(), l2 = s2.length();\n        for(int i=0; i<Math.min(l1, l2); i++){\n            if(s1.charAt(i)<s2.charAt(i)) return true;\n            else if(s1.charAt(i)>s2.charAt(i)) return false;\n        }\n        if(l1<l2) return true;\n        return false;\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tif ((h | w) == 0)\n\t\t\t\tbreak;\n\t\t\tchar[][] field = new char[h][w];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tString s = sc.next();\n\t\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\t\tfield[i][j] = s.charAt(j);\n\t\t\t}\n\t\t\tString result = \"\";\n\t\t\tSet<String> set = new HashSet<String>(0);\n\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tString s = \"\";\n\t\t\t\t\tint[] dx = { 1, 1, 0, -1, -1, -1, 0, 1 };\n\t\t\t\t\tint[] dy = { 0, 1, 1, 1, 0, -1, -1, -1 };\n\t\t\t\t\tint px = j;\n\t\t\t\t\tint py = i;\n\t\t\t\t\tfor (int k = 0; k < 8; k++) {\n\t\t\t\t\t\ts = \"\";\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\ts += field[py][px];\n\t\t\t\t\t\t\tpx = (px + dx[k] + w) % w;\n\t\t\t\t\t\t\tpy = (py + dy[k] + h) % h;\n\t\t\t\t\t\t} while (!(px == j && py == i));\n\t\t\t\t\t\tif (!set.add(s)\n\t\t\t\t\t\t\t\t&& (result.length() < s.length() || (result\n\t\t\t\t\t\t\t\t\t\t.length() == s.length() && result\n\t\t\t\t\t\t\t\t\t\t.compareTo(s) > 0))) {\n\t\t\t\t\t\t\tresult = s;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tSet<String> tset = new HashSet<String>(0);\n\t\t\tfor (String str : set) {\n\t\t\t\tfor (String tstr : tset) {\n\t\t\t\t\tfor (int i = Math.max(result.length(), 2); i <= Math.min(\n\t\t\t\t\t\t\tstr.length(), tstr.length()); i++) {\n\t\t\t\t\t\tString s = str.substring(0, i);\n\t\t\t\t\t\tif (tstr.startsWith(s)\n\t\t\t\t\t\t\t\t&& (result.length() < s.length() || (result\n\t\t\t\t\t\t\t\t\t\t.length() == s.length() && result\n\t\t\t\t\t\t\t\t\t\t.compareTo(s) > 0)))\n\t\t\t\t\t\t\tresult = s;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttset.add(str);\n\t\t\t}\n\t\t\tif (result.length() < 2)\n\t\t\t\tSystem.out.println(0);\n\t\t\telse\n\t\t\t\tSystem.out.println(result);\n\t\t}\n\t\tsc.close();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int[] DR = { 1, 1, 1, 0, -1, -1, -1, 0 };\n\tstatic int[] DC = { -1, 0, 1, 1, 1, 0, -1, -1 };\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tint H = sc.nextInt();\n\t\t\tint W = sc.nextInt();\n\t\t\tif (H == 0) break;\n\t\t\tchar[][] f = new char[H][];\n\t\t\tfor (int i = 0; i < H; ++i) {\n\t\t\t\tf[i] = sc.next().toCharArray();\n\t\t\t}\n\t\t\tArrayList<HashSet<String>> set = new ArrayList<HashSet<String>>();\n\t\t\tfor (int i = 0; i <= H * W; ++i) {\n\t\t\t\tset.add(new HashSet<String>());\n\t\t\t}\n\t\t\tString ans = \"\";\n\t\t\tfor (int i = 0; i < H; ++i) {\n\t\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\t\tfor (int k = 0; k < 8; ++k) {\n\t\t\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\t\t\tsb.append(f[i][j]);\n\t\t\t\t\t\tint cr = i;\n\t\t\t\t\t\tint cc = j;\n\t\t\t\t\t\tboolean[][] visited = new boolean[H][W];\n\t\t\t\t\t\tvisited[cr][cc] = true;\n\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\tcr += DR[k];\n\t\t\t\t\t\t\tcc += DC[k];\n\t\t\t\t\t\t\tif (cr == -1) cr += H;\n\t\t\t\t\t\t\tif (cr == H) cr = 0;\n\t\t\t\t\t\t\tif (cc == -1) cc += W;\n\t\t\t\t\t\t\tif (cc == W) cc = 0;\n\t\t\t\t\t\t\tif (visited[cr][cc]) break;\n\t\t\t\t\t\t\tvisited[cr][cc] = true;\n\t\t\t\t\t\t\tsb.append(f[cr][cc]);\n\t\t\t\t\t\t\tString str = sb.toString();\n\t\t\t\t\t\t\tif (str.length() > ans.length() || str.length() == ans.length() && str.compareTo(ans) < 0) {\n\t\t\t\t\t\t\t\tif (set.get(str.length()).contains(str)) {\n\t\t\t\t\t\t\t\t\tans = str;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tset.get(str.length()).add(str);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans.length() == 0 ? 0 : ans);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Scanner;\n\npublic class SorcerersDonut {\n\tScanner in = new Scanner(System.in);\n\tint h, w;\n\tchar[][] map;\n\tboolean[][] visited;\n\tint[] dirx = {-1, 0, 1, -1, 1, -1, 0, 1};\n\tint[] diry = {-1, -1, -1, 0, 0, 1, 1, 1};\n\tHashSet<String> hash;\n\tString ans;\n\tint x, y;\n\t\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\th = in.nextInt();\n\t\t\tw = in.nextInt();\n\t\t\tif ((h|w) == 0) break;\n\t\t\tmap = new char[h][w];\n\t\t\thash = new HashSet<String>(0);\n\t\t\tans = \"\";\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tString s = in.next();\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tmap[i][j] = s.charAt(j);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tfor (int k = 0; k < 8; k++) {\n\t\t\t\t\t\tx = j; y = i;\n\t\t\t\t\t\tStringBuilder sb = new StringBuilder(map[y][x]);\n\t\t\t\t\t\tfor ( ; ; ) {\n\t\t\t\t\t\t\tx = (x + dirx[k] + w) % w;\n\t\t\t\t\t\t\ty = (y + diry[k] + h) % h;\n\t\t\t\t\t\t\tsb.append(map[y][x]);\n\t\t\t\t\t\t\tif (hash.contains(sb.toString())) {\n\t\t\t\t\t\t\t\tif (sb.length() > ans.length() || (sb.length() == ans.length() && ans.compareTo(sb.toString()) > 0)) {\n\t\t\t\t\t\t\t\t\tans = sb.toString();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (sb.toString().length() >= Math.max(2, ans.length())) {\n\t\t\t\t\t\t\t\thash.add(sb.toString());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (x == j && y == i) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (ans.length() < 2)\n\t\t\t\tSystem.out.println(0);\n\t\t\telse\n\t\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew SorcerersDonut().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.System.*;\n\npublic class Main {\n\n\tScanner sc = new Scanner(in);\n\t\n\tvoid run() {\n\t\tchar[] alpha = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'};\n\t\twhile (true) {\n\t\t\tint h = sc.nextInt(), w = sc.nextInt();\n\t\t\tif (h == 0 && w == 0) break;\n\t\t\t\n\t\t\tsc.nextLine();\n\t\t\tchar[][] donut = new char[h][w];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tString s = sc.nextLine();\n\t\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\t\tdonut[i][j] = s.charAt(j);\n\t\t\t}\n\t\t\t\n\t\t\tString ans = \"\";\n\t\t\t\n\t\t\tMap<Character, Set<String>> map = new HashMap<Character, Set<String>>();\n\t\t\tfor (char c : alpha)\n\t\t\t\tmap.put(c, new HashSet<String>());\n\t\t\t\n\t\t\tint[] dx = {0, 0, 1, -1, 1, -1, 1, -1};\n\t\t\tint[] dy = {1, -1, 0, 0, 1, -1, -1, 1};\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tString s; \n\t\t\t\t\tSet<String> set = map.get(donut[i][j]);\n\t\t\t\t\t\n\t\t\t\t\tint k, l;\n\t\t\t\t\tfor (int m = 0; m < 8; m++) {\n\t\t\t\t\t\tk = dx[m];\n\t\t\t\t\t\tl = dy[m];\n\t\t\t\t\t\ts = String.valueOf(donut[i][j]);\n\t\t\t\t\t\twhile (k % h != 0 || l % w != 0) {\n\t\t\t\t\t\t\ts += String.valueOf(donut[(i+k+100*h)%h][(j+l+100*w)%w]);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (set.contains(s)) {\n\t\t\t\t\t\t\t\tif (ans.length() == 0 || ans.length() < s.length() || (ans.length() == s.length() && s.compareTo(ans) < 0))\n\t\t\t\t\t\t\t\t\tans = s;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tset.add(s);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tk += dx[m];\n\t\t\t\t\t\t\tl += dy[m];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ans.length() == 0)\n\t\t\t\tout.println(0);\n\t\t\telse\n\t\t\t\tout.println(ans);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.System.*;\n\npublic class Main {\n\n\tScanner sc = new Scanner(in);\n\t\n\tvoid run() {\n\t\tSet<String> set = new HashSet<String>();\n\t\tList<String> candidate = new ArrayList<String>();\n\t\tStringBuilder sb = new StringBuilder();\n\t\t\n\t\twhile (true) {\n\t\t\tint h = sc.nextInt(), w = sc.nextInt();\n\t\t\tif (h == 0 && w == 0) break;\n\t\t\t\n\t\t\tsc.nextLine();\n\t\t\tchar[][] donut = new char[h][w];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tString s = sc.nextLine();\n\t\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\t\tdonut[i][j] = s.charAt(j);\n\t\t\t}\n\t\t\t\n\t\t\tint[] dx = {0, 0, 1, -1, 1, -1, 1, -1};\n\t\t\tint[] dy = {1, -1, 0, 0, 1, -1, -1, 1};\n\t\t\t\n\t\t\tset.clear();\n\t\t\tcandidate.clear();\n\t\t\t\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tfor (int k = 0; k < 8; k++) {\n\t\t\t\t\t\tsb.delete(0, sb.length());\n\t\t\t\t\t\tint x = i, y = j;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tsb.append(donut[x][y]);\n\t\t\t\t\t\t\tif (set.contains(sb.toString())) {\n\t\t\t\t\t\t\t\tif (candidate.isEmpty())\n\t\t\t\t\t\t\t\t\tcandidate.add(sb.toString());\n\t\t\t\t\t\t\t\telse if (candidate.get(0).length() == sb.length())\n\t\t\t\t\t\t\t\t\tcandidate.add(sb.toString());\n\t\t\t\t\t\t\t\telse if (candidate.get(0).length() < sb.length()) {\n\t\t\t\t\t\t\t\t\tcandidate.clear();\n\t\t\t\t\t\t\t\t\tcandidate.add(sb.toString());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t} else if (sb.length() > 1){\n\t\t\t\t\t\t\t\tset.add(sb.toString());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tx = (x + dx[k] + h) % h;\n\t\t\t\t\t\t\ty = (y + dy[k] + w) % w;\n\t\t\t\t\t\t} while (x != i || y != j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tCollections.sort(candidate);\n\t\t\tif (candidate.size() == 0)\n\t\t\t\tout.println(0);\n\t\t\telse\n\t\t\t\tout.println(candidate.get(0));\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\tpublic void run() {\n\t\twhile(sc.hasNext()){\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tif(h == 0 && w == 0)break;\n\t\t\telse calc(h, w);\n\t\t\t\n\t\t}\n\t}\n\tpublic void calc(int w, int h){\n\t\tString[][] donut = new String[w][h];\n\t\tfor(int i = 0; i < w; i++){\n\t\t\tString line = sc.next();\n\t\t\tfor(int j = 0; j < h; j++){\n\t\t\t\tdonut[i][j] = line.substring(j, j+1);\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tint x[] = {0, 1, 1, 1, 0,-1,-1,-1};\n\t\tint y[] = {1, 1, 0,-1,-1,-1, 0, 1};\n\t\tString max = \"\";\n\t\tHashMap<String, Integer> map = new HashMap<String, Integer>();\n\t\tfor(int i = 0; i < w; i++){\n\t\t\tfor(int j = 0; j < h; j++){\n\t\t\t\tfor(int k = 0; k < 8; k++){\n\t\t\t\t\tString s = donut[i][j];\n\t\t\t\t\tint nx = i + x[k];\n\t\t\t\t\tint ny = j + y[k];\n\t\t\t\t\tif(nx >= w) nx = 0;\n\t\t\t\t\tif(nx < 0) nx = w-1;\n\t\t\t\t\tif(ny >= h) ny = 0;\n\t\t\t\t\tif(ny < 0) ny = h-1;\n\t\t\t\t\twhile(!(nx == i && ny == j)){\n\t\t\t\t\t\ts += donut[nx][ny];\n\t\t\t\t\t\tif(map.containsKey(s)){\n\t\t\t\t\t\t\tif(max.length() < s.length()) max = s;\n\t\t\t\t\t\t\telse if(max.length() == s.length() && s.compareTo(max) < 0) max = s;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(max.length() <= s.length()) map.put(s, 1);\n\t\t\t\t\t\t\n\t\t\t\t\t\tnx += x[k];\n\t\t\t\t\t\tny += y[k];\n\t\t\t\t\t\tif(nx >= w) nx = 0;\n\t\t\t\t\t\tif(nx < 0) nx = w-1;\n\t\t\t\t\t\tif(ny >= h) ny = 0;\n\t\t\t\t\t\tif(ny < 0) ny = h-1;\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(max.equals(\"\")) System.out.println(0);\n\t\telse System.out.println(max);\n\t}\n\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    int h, w;\n    int[] dx = {0, 0, 1, -1, 1, 1, -1, -1};\n    int[] dy = {1, -1, 0, 0, 1, -1, 1, -1};\n    char[][] donut;\n    String cutS;\n\n    @SuppressWarnings(\"unchecked\")\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        while(true){\n            h = sc.nextInt();\n            w = sc.nextInt();\n            if(h==0 && w==0) break;\n\n            donut = new char[h][w];\n            for(int i=0; i<h; i++){\n                String line = sc.next();\n                donut[i] = line.toCharArray();\n            }\n\n            int max = 0;\n            StringBuilder minString = new StringBuilder();\n\n            for(int l=h*w-1; l>=2; l--){\n                ArrayList<String> list = new ArrayList<String>();\n                for(int i=0; i<h; i++){\n                    for(int j=0; j<w; j++){\n                        for(int k=0; k<8; k++){                        \n                            StringBuilder s = new StringBuilder();\n                            s.append(donut[i][j]);\n                            int ny = (i + dy[k]) % h, nx = (j + dx[k]) % w;\n                            if(ny==-1) ny = h-1;\n                            if(nx==-1) nx = w-1;\n                            while(!(ny==i && nx==j)){\n                                if(s.length()==l) break;\n                                s.append(donut[ny][nx]);\n                                ny = (ny + dy[k]) % h;\n                                nx = (nx + dx[k]) % w;\n                                if(ny==-1) ny = h-1;\n                                if(nx==-1) nx = w-1;\n                            }\n                            if(s.length()!=l) continue;\n\n                            if(!list.contains(s.toString())) list.add(s.toString());\n                            else if(minString.length()==0 || min(s, minString)){\n                                max = s.length();\n                                minString = s;\n                            }\n                        }\n                    }\n                }\n                if(max!=0) break;\n            }\n\n            if(minString.length()==0) System.out.println(0);\n            else System.out.println(minString.toString());\n        }\n    }\n\n    boolean min(StringBuilder s1, StringBuilder s2){ //s1 < s2?\n        int l1 = s1.length(), l2 = s2.length();\n        for(int i=0; i<Math.min(l1, l2); i++){\n            if(s1.charAt(i)<s2.charAt(i)) return true;\n            else if(s1.charAt(i)>s2.charAt(i)) return false;\n        }\n        if(l1<l2) return true;\n        return false;\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\t\n\t//1420 start\n\t\n\tHashSet<String> appear;\n\tchar [][] data;\n\tString ans;\n\tint h,w;\n\tint [] vx = {0,1,0,-1,1,1,-1,-1};\n\tint [] vy = {1,0,-1,0,1,-1,-1,1};\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\th = sc.nextInt();\n\t\t\tw = sc.nextInt();\n\t\t\tif((h|w) == 0) break;\n\t\t\t\n\t\t\tdata = new char[h][w];\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tString s = sc.next();\n\t\t\t\tdata[i] = s.toCharArray();\n\t\t\t}\n\t\t\tans = \"\";\n\t\t\tappear = new HashSet<String>();\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\t\n\t\t\t\t\tsolve(i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans.equals(\"\") ? 0 : ans);\n\t\t}\n\t}\n\n\tprivate void solve(int y, int x) {\n\t\t\n\t\tfor(int i = 0; i < 8; i++){\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tsb.append(data[y][x]);\n\t\t\tint xx = x, yy = y;\n\t\t\twhile(true){\n\t\t\t\txx = (xx + vx[i] + w) % w;\n\t\t\t\tyy = (yy + vy[i] + h) % h;\n\t\t\t\tif(xx == x && yy == y){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsb.append(data[yy][xx]);\n\t\t\t\t\n\t\t\t\tif(appear.contains(sb.toString())){\n\t\t\t\t\t\n\t\t\t\t\tString now = sb.toString();\n\t\t\t\t\t//System.out.println(\"now = \" + now);\n\t\t\t\t\tif(now.length() > ans.length()){\n\t\t\t\t\t\tans = now;\n\t\t\t\t\t}\n\t\t\t\t\telse if(now.length() == ans.length() && now.compareTo(ans) < 0){\n\t\t\t\t\t\tans = now;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tappear.add(sb.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner scan = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint H = scan.nextInt();\n\t\t\tif (H == 0) {\n\t\t\t\tscan.close();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint W = scan.nextInt();\n\n\t\t\tchar[][] table = new char[H][];\n\t\t\tfor (int i = 0; i < table.length; i++) {\n\t\t\t\ttable[i] = scan.next().toCharArray();\n\t\t\t}\n\n\t\t\tString answer = \"\";\n\t\t\tint[] dir = { -1, 0, 1 };\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tArrayList<String>[][] parts = new ArrayList[26][201];\n\t\t\tfor (int i = 0; i < parts.length; i++) {\n\t\t\t\tfor (int j = 0; j < parts[i].length; j++) {\n\t\t\t\t\tparts[i][j] = new ArrayList<String>();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < table.length; i++) {\n\t\t\t\tfor (int j = 0; j < table[i].length; j++) {\n\t\t\t\t\tfor (int k = 0; k < dir.length; k++) {\n\t\t\t\t\t\tfor (int l = 0; l < dir.length; l++) {\n\t\t\t\t\t\t\tif (dir[k] == dir[l] && dir[k] == 0) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tint nowi = i;\n\t\t\t\t\t\t\tint nowj = j;\n\t\t\t\t\t\t\tStringBuilder builder = new StringBuilder();\n\t\t\t\t\t\t\tbuilder.append(table[nowi][nowj]);\n\t\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\t\tnowi = (nowi + dir[k] + H) % H;\n\t\t\t\t\t\t\t\tnowj = (nowj + dir[l] + W) % W;\n\n\t\t\t\t\t\t\t\tif (nowi == i && nowj == j) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbuilder.append(table[nowi][nowj]);\n\t\t\t\t\t\t\t\tif (parts[table[i][j] - 'A'][builder.length()]\n\t\t\t\t\t\t\t\t\t\t.contains(builder.toString())) {\n\t\t\t\t\t\t\t\t\tif (builder.length() > answer.length()) {\n\t\t\t\t\t\t\t\t\t\tanswer = builder.toString();\n\t\t\t\t\t\t\t\t\t} else if (builder.length() == answer\n\t\t\t\t\t\t\t\t\t\t\t.length()) {\n\t\t\t\t\t\t\t\t\t\tif (answer\n\t\t\t\t\t\t\t\t\t\t\t\t.compareTo(builder.toString()) > 0) {\n\t\t\t\t\t\t\t\t\t\t\tanswer = builder.toString();\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if (builder.length() >= 2) {\n\t\t\t\t\t\t\t\t\tparts[table[i][j] - 'A'][builder.length()]\n\t\t\t\t\t\t\t\t\t\t\t.add(builder.toString());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(answer);\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.System.*;\n\npublic class Main {\n\n\tScanner sc = new Scanner(in);\n\t\n\tvoid run() {\n\t\twhile (true) {\n\t\t\tint h = sc.nextInt(), w = sc.nextInt();\n\t\t\tif (h == 0 && w == 0) break;\n\t\t\t\n\t\t\tsc.nextLine();\n\t\t\tchar[][] donut = new char[h][w];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tString s = sc.nextLine();\n\t\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\t\tdonut[i][j] = s.charAt(j);\n\t\t\t}\n\t\t\t\n\t\t\tString ans = \"\";\n\t\t\t\n\t\t\tSet<String> set = new HashSet<String>();\n\t\t\t\n\t\t\tint[] dx = {0, 0, 1, -1, 1, -1, 1, -1};\n\t\t\tint[] dy = {1, -1, 0, 0, 1, -1, -1, 1};\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tString s; \n\t\t\t\t\t\n\t\t\t\t\tint k, l;\n\t\t\t\t\tfor (int m = 0; m < 8; m++) {\n\t\t\t\t\t\tk = dx[m];\n\t\t\t\t\t\tl = dy[m];\n\t\t\t\t\t\ts = String.valueOf(donut[i][j]);\n\t\t\t\t\t\twhile (k % h != 0 || l % w != 0) {\n\t\t\t\t\t\t\ts += String.valueOf(donut[(i+k+100*h)%h][(j+l+100*w)%w]);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (set.contains(s)) {\n\t\t\t\t\t\t\t\tif (ans.length() == 0 || ans.length() < s.length() || (ans.length() == s.length() && s.compareTo(ans) < 0))\n\t\t\t\t\t\t\t\t\tans = s;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tset.add(s);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tk += dx[m];\n\t\t\t\t\t\t\tl += dy[m];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ans.length() == 0)\n\t\t\t\tout.println(0);\n\t\t\telse\n\t\t\t\tout.println(ans);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\tpublic void run() {\n\t\twhile(sc.hasNext()){\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tif(h == 0 && w == 0)break;\n\t\t\telse calc(h, w);\n\t\t\t\n\t\t}\n\t}\n\tpublic void calc(int w, int h){\n\t\tString[][] donut = new String[w][h];\n\t\tfor(int i = 0; i < w; i++){\n\t\t\tString line = sc.next();\n\t\t\tfor(int j = 0; j < h; j++){\n\t\t\t\tdonut[i][j] = line.substring(j, j+1);\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tint x[] = {0, 1, 1, 1, 0,-1,-1,-1};\n\t\tint y[] = {1, 1, 0,-1,-1,-1, 0, 1};\n\t\tString max = \"\";\n\t\tHashMap<String, Integer> map = new HashMap<String, Integer>();\n\t\tfor(int i = 0; i < w; i++){\n\t\t\tfor(int j = 0; j < h; j++){\n\t\t\t\tfor(int k = 0; k < 8; k++){\n\t\t\t\t\tString s = donut[i][j];\n\t\t\t\t\tint nx = i + x[k];\n\t\t\t\t\tint ny = j + y[k];\n\t\t\t\t\tif(nx >= w) nx = 0;\n\t\t\t\t\tif(nx < 0) nx = w-1;\n\t\t\t\t\tif(ny >= h) ny = 0;\n\t\t\t\t\tif(ny < 0) ny = h-1;\n\t\t\t\t\twhile(!(nx == i && ny == j)){\n\t\t\t\t\t\ts += donut[nx][ny];\n\t\t\t\t\t\tif(map.containsKey(s)){\n\t\t\t\t\t\t\tif(max.length() < s.length()) max = s;\n\t\t\t\t\t\t\telse if(max.length() == s.length() && s.compareTo(max) < 0) max = s;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse map.put(s, 1);\n\t\t\t\t\t\t\n\t\t\t\t\t\tnx += x[k];\n\t\t\t\t\t\tny += y[k];\n\t\t\t\t\t\tif(nx >= w) nx = 0;\n\t\t\t\t\t\tif(nx < 0) nx = w-1;\n\t\t\t\t\t\tif(ny >= h) ny = 0;\n\t\t\t\t\t\tif(ny < 0) ny = h-1;\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(max.equals(\"\")) System.out.println(0);\n\t\telse System.out.println(max);\n\t}\n\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\tpublic void run() {\n\t\twhile(sc.hasNext()){\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tif(h == 0 && w == 0)break;\n\t\t\telse calc(h, w);\n\t\t\t\n\t\t}\n\t}\n\tpublic void calc(int w, int h){\n\t\tString[][] donut = new String[w][h];\n\t\tfor(int i = 0; i < w; i++){\n\t\t\tString line = sc.next();\n\t\t\tfor(int j = 0; j < h; j++){\n\t\t\t\tdonut[i][j] = line.substring(j, j+1);\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tint x[] = {0, 1, 1, 1, 0,-1,-1,-1};\n\t\tint y[] = {1, 1, 0,-1,-1,-1, 0, 1};\n\t\tString max = \"\";\n\t\tHashMap<String, Integer> map = new HashMap<String, Integer>();\n\t\tfor(int i = 0; i < w; i++){\n\t\t\tfor(int j = 0; j < h; j++){\n\t\t\t\tfor(int k = 0; k < 8; k++){\n\t\t\t\t\tString s = donut[i][j];\n\t\t\t\t\tint nx = i + x[k];\n\t\t\t\t\tint ny = j + y[k];\n\t\t\t\t\tif(nx >= w) nx = 0;\n\t\t\t\t\tif(nx < 0) nx = w-1;\n\t\t\t\t\tif(ny >= h) ny = 0;\n\t\t\t\t\tif(ny < 0) ny = h-1;\n\t\t\t\t\twhile(!(nx == i && ny == j)){\n\t\t\t\t\t\ts += donut[nx][ny];\n\t\t\t\t\t\tif(map.containsKey(s)){\n\t\t\t\t\t\t\tif(max.length() < s.length()) max = s;\n\t\t\t\t\t\t\telse if(max.length() == s.length() && s.compareTo(max) < 0) max = s;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(max.length() < s.length()) map.put(s, 1);\n\t\t\t\t\t\telse if(max.length() == s.length() && s.compareTo(max) < 0) map.put(s, 1);\n\t\t\t\t\t\t\n\t\t\t\t\t\tnx += x[k];\n\t\t\t\t\t\tny += y[k];\n\t\t\t\t\t\tif(nx >= w) nx = 0;\n\t\t\t\t\t\tif(nx < 0) nx = w-1;\n\t\t\t\t\t\tif(ny >= h) ny = 0;\n\t\t\t\t\t\tif(ny < 0) ny = h-1;\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.gc();\n\t\t}\n\t\tif(max.equals(\"\")) System.out.println(0);\n\t\telse System.out.println(max);\n\t}\n\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.System.*;\n\npublic class Main {\n\n\tScanner sc = new Scanner(in);\n\t\n\tvoid run() {\n\t\tSet<String> set = new HashSet<String>();\n\t\tList<String> candidate = new ArrayList<String>();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tCollection<String> col = new ArrayList<String>();\n\t\twhile (true) {\n\t\t\tint h = sc.nextInt(), w = sc.nextInt();\n\t\t\tif (h == 0 && w == 0) break;\n\t\t\t\n\t\t\tsc.nextLine();\n\t\t\tchar[][] donut = new char[h][w];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tString s = sc.nextLine();\n\t\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\t\tdonut[i][j] = s.charAt(j);\n\t\t\t}\n\t\t\t\n\t\t\tint[] dx = {0, 0, 1, -1, 1, -1, 1, -1};\n\t\t\tint[] dy = {1, -1, 0, 0, 1, -1, -1, 1};\n\t\t\t\n\t\t\tset.clear();\n\t\t\tcandidate.clear();\n\t\t\t\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tfor (int k = 0; k < 8; k++) {\n\t\t\t\t\t\tsb.delete(0, sb.length());\n\t\t\t\t\t\tint x = i, y = j;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tsb.append(donut[x][y]);\n\t\t\t\t\t\t\tif (set.contains(sb.toString())) {\n\t\t\t\t\t\t\t\tif (candidate.isEmpty())\n\t\t\t\t\t\t\t\t\tcandidate.add(sb.toString());\n\t\t\t\t\t\t\t\telse if (candidate.get(0).length() == sb.length())\n\t\t\t\t\t\t\t\t\tcandidate.add(sb.toString());\n\t\t\t\t\t\t\t\telse if (candidate.get(0).length() < sb.length()) {\n\t\t\t\t\t\t\t\t\tcandidate.clear();\n\t\t\t\t\t\t\t\t\tcandidate.add(sb.toString());\n\t\t\t\t\t\t\t\t\tint l = sb.length();\n\t\t\t\t\t\t\t\t\tIterator<String> it = set.iterator();\n\t\t\t\t\t\t\t\t\twhile (it.hasNext()) {\n\t\t\t\t\t\t\t\t\t\tString s = it.next();\n\t\t\t\t\t\t\t\t\t\tif (s.length() < l)\n\t\t\t\t\t\t\t\t\t\t\tcol.add(s);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tset.removeAll(col);\n\t\t\t\t\t\t\t\t\tcol.clear();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t} else if (sb.length() > 1){\n\t\t\t\t\t\t\t\tset.add(sb.toString());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tx = (x + dx[k] + h) % h;\n\t\t\t\t\t\t\ty = (y + dy[k] + w) % w;\n\t\t\t\t\t\t} while (x != i || y != j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tCollections.sort(candidate);\n\t\t\tif (candidate.size() == 0)\n\t\t\t\tout.println(0);\n\t\t\telse\n\t\t\t\tout.println(candidate.get(0));\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String [] args) {\n        new Main().run();\n    }\n    final int [] dx = {0, 1, 1,  1,  0, -1, -1, -1};\n    final int [] dy = {1, 1, 0, -1, -1, -1,  0,  1};\n    HashSet<String> occurOnce;\n    HashSet<String> occurTwice;\n    void makeString(int y, int x) {\n        for (int i = 0; i < 8; i++) {\n            String cur = String.valueOf(F[y].charAt(x));\n            int ny = (y + dy[i] + H) % H, nx = (x + dx[i] + W) % W;\n            while (ny != y || nx != x) {\n                cur = cur + String.valueOf(F[ny].charAt(nx));\n                if (occurOnce.contains(cur)) {\n                    occurTwice.add(cur);\n                } else {\n                    occurOnce.add(cur);\n                }\n                ny = (ny + dy[i] + H) % H;\n                nx = (nx + dx[i] + W) % W;\n            }\n        }\n    }\n    void debug(Object ... o) {\n        System.out.println(Arrays.deepToString(o));\n    }\n    void run() {\n        while (init()) {\n            occurOnce = new HashSet<String>();\n            occurTwice = new HashSet<String>();\n            for (int i = 0; i < H; i++) {\n                for (int j = 0; j < W; j++) {\n                    makeString(i, j);\n                }\n            }\n            ArrayList<String> list = new ArrayList<String>();\n            for (Iterator it = occurTwice.iterator(); it.hasNext(); ) {\n                String spell = (String)it.next();\n                list.add(spell);\n            }\n            if (list.isEmpty()) {\n                System.out.println(0);\n            } else {\n                Collections.sort(list, \n                    new Comparator<String>() {\n                        @Override public int compare(String a, String b) {\n                            if (a.length() == b.length()) {\n                                return a.compareTo(b);\n                            } else {\n                                return b.length() - a.length();\n                            }\n                        }\n                });\n                System.out.println(list.get(0));\n            }\n        }\n    }\n    Scanner sc;\n    Main() {\n        sc = new Scanner(System.in);\n    }\n    int W, H;\n    String [] F;\n    boolean init() {\n        H = sc.nextInt();\n        W = sc.nextInt();\n        if (H == 0 && W == 0) return false;\n        F = new String[H];\n        for (int i = 0; i < H; i++) {\n            F[i] = sc.next();\n        }\n        return true;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\tpublic void run() {\n\t\twhile(sc.hasNext()){\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tif(h == 0 && w == 0)break;\n\t\t\telse calc(h, w);\n\t\t\t\n\t\t}\n\t}\n\tpublic void calc(int w, int h){\n\t\tString[][] donut = new String[w][h];\n\t\tfor(int i = 0; i < w; i++){\n\t\t\tString line = sc.next();\n\t\t\tfor(int j = 0; j < h; j++){\n\t\t\t\tdonut[i][j] = line.substring(j, j+1);\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tint x[] = {0, 1, 1, 1, 0,-1,-1,-1};\n\t\tint y[] = {1, 1, 0,-1,-1,-1, 0, 1};\n\t\tString max = \"\";\n\t\tHashMap<String, Integer> map = new HashMap<String, Integer>();\n\t\tfor(int i = 0; i < w; i++){\n\t\t\tfor(int j = 0; j < h; j++){\n\t\t\t\tfor(int k = 0; k < 8; k++){\n\t\t\t\t\tString s = donut[i][j];\n\t\t\t\t\tint nx = i + x[k];\n\t\t\t\t\tint ny = j + y[k];\n\t\t\t\t\tif(nx >= w) nx = 0;\n\t\t\t\t\tif(nx < 0) nx = w-1;\n\t\t\t\t\tif(ny >= h) ny = 0;\n\t\t\t\t\tif(ny < 0) ny = h-1;\n\t\t\t\t\twhile(!(nx == i && ny == j)){\n\t\t\t\t\t\ts += donut[nx][ny];\n\t\t\t\t\t\tif(map.containsKey(s)){\n\t\t\t\t\t\t\tif(max.length() < s.length()) max = s;\n\t\t\t\t\t\t\telse if(max.length() == s.length() && s.compareTo(max) < 0) max = s;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(max.length() < s.length()) map.put(s, 1);\n\t\t\t\t\t\telse if(max.length() == s.length() && s.compareTo(max) < 0) map.put(s, 1);\n\t\t\t\t\t\t\n\t\t\t\t\t\tnx += x[k];\n\t\t\t\t\t\tny += y[k];\n\t\t\t\t\t\tif(nx >= w) nx = 0;\n\t\t\t\t\t\tif(nx < 0) nx = w-1;\n\t\t\t\t\t\tif(ny >= h) ny = 0;\n\t\t\t\t\t\tif(ny < 0) ny = h-1;\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(max.equals(\"\")) System.out.println(0);\n\t\telse System.out.println(max);\n\t}\n\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static final int[] di = {-1,-1,-1,0,0,1,1,1};\n\tpublic static final int[] dj = {-1,0,1,-1,1,-1,0,1};\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tif (h == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tchar[][] s = new char[h][];\n\t\t\tfor(int i=0;i<h;i++) {\n\t\t\t\ts[i] = sc.next().toCharArray();\n\t\t\t}\n\t\t\tArrayList<String> found = new ArrayList<String>();\n\t\t\tfor(int i=0;i<h;i++) {\n\t\t\t\tfor(int j=0;j<w;j++) {\n\t\t\t\t\tfor(int k=0;k<8;k++) {\n\t\t\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\t\t\tint ni = i;\n\t\t\t\t\t\tint nj = j;\n\t\t\t\t\t\twhile(true) {\n\t\t\t\t\t\t\tsb.append(s[ni][nj]);\n\t\t\t\t\t\t\tni = (ni + di[k] + h) % h;\n\t\t\t\t\t\t\tnj = (nj + dj[k] + w) % w;\n\t\t\t\t\t\t\tif (ni == i && nj == j) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfound.add(sb.toString());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint maxl = 0;\n\t\t\tString maxs = \"\";\n\t\t\tCollections.sort(found);\n\t\t\tfor(int i=0;i<found.size()-1;i++) {\n\t\t\t\tint l1 = found.get(i).length();\n\t\t\t\tint l2 = found.get(i+1).length();\n\t\t\t\tint l = Math.min(l1, l2);\n\t\t\t\tint matchl = 0;\n\t\t\t\tfor(int j=0;j<=l;j++) {\n\t\t\t\t\tchar c1 = j == l ? 'a' : found.get(i).charAt(j);\n\t\t\t\t\tchar c2 = j == l ? 'b' : found.get(i+1).charAt(j);\n\t\t\t\t\tif (c1 != c2) {\n\t\t\t\t\t\tmatchl = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (matchl >= maxl) {\n\t\t\t\t\tString matchs = found.get(i).substring(0, matchl);\n\t\t\t\t\tif (matchl > maxl || maxs.compareTo(matchs) > 0) {\n\t\t\t\t\t\tmaxs = matchs;\n\t\t\t\t\t}\n\t\t\t\t\tmaxl = matchl;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (maxl < 2) {\n\t\t\t\tSystem.out.println(0);\n\t\t\t}else{\n\t\t\t\tSystem.out.println(maxs);\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    int h, w;\n    int[] dx = {0, 0, 1, -1, 1, 1, -1, -1};\n    int[] dy = {1, -1, 0, 0, 1, -1, 1, -1};\n    char[][] donut;\n    String cutS;\n\n    @SuppressWarnings(\"unchecked\")\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        while(true){\n            h = sc.nextInt();\n            w = sc.nextInt();\n            if(h==0 && w==0) break;\n\n            donut = new char[h][w];\n            for(int i=0; i<h; i++){\n                String line = sc.next();\n                donut[i] = line.toCharArray();\n            }\n\n            int max = 0;\n            String minString = \"0\";\n            ArrayList[] list = new ArrayList[201];\n            for(int i=0; i<201; i++) list[i] = new ArrayList<String>();\n\n            for(int i=0; i<h; i++){\n                for(int j=0; j<w; j++){\n                    for(int k=0; k<8; k++){\n                        \n                        String s = \"\";\n                        s += donut[i][j];\n                        int ny = (i + dy[k]) % h, nx = (j + dx[k]) % w;\n                        if(ny==-1) ny = h-1;\n                        if(nx==-1) nx = w-1;\n                        while(!(ny==i && nx==j)){\n                            s += donut[ny][nx];\n                            ny = (ny + dy[k]) % h;\n                            nx = (nx + dx[k]) % w;\n                            if(ny==-1) ny = h-1;\n                            if(nx==-1) nx = w-1;\n                            if(!list[s.length()].contains(s) && s.length()>=max) list[s.length()].add(s);\n                            else if(s.length()>max || (s.length()==max && (minString.equals(\"0\") || min(s, minString)))){\n                                if(max<s.length()){\n                                    for(int l=0; l<max; l++){\n                                        list[i] = new ArrayList<String>();\n                                    }\n                                }\n                                max = s.length();\n                                minString = s;\n                            }\n                        }\n                    }\n                }\n            }\n\n            System.out.println(minString);\n        }\n    }\n\n    boolean min(String s1, String s2){ //s1 < s2?\n        int l1 = s1.length(), l2 = s2.length();\n        for(int i=0; i<Math.min(l1, l2); i++){\n            if(s1.charAt(i)<s2.charAt(i)) return true;\n            else if(s1.charAt(i)>s2.charAt(i)) return false;\n        }\n        if(l1<l2) return true;\n        return false;\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String [] args) {\n        new Main().run();\n    }\n    final int [] dx = {0, 1, 1,  1,  0, -1, -1, -1};\n    final int [] dy = {1, 1, 0, -1, -1, -1,  0,  1};\n    HashSet<String> occurOnce;\n    //HashSet<Integer> occurOnce;\n    String longestString(int y, int x) {\n        String longest = \"\";\n        for (int i = 0; i < 8; i++) {\n            String cur = String.valueOf(F[y].charAt(x));\n            int ny = (y + dy[i] + H) % H, nx = (x + dx[i] + W) % W;\n            while (ny != y || nx != x) {\n                cur = cur + String.valueOf(F[ny].charAt(nx));\n                int hashCode = cur.hashCode();\n                if (occurOnce.contains(cur)) {\n                //if (occurOnce.contains(hashCode)) {\n                    if (longest.length() < cur.length()) {\n                        //debug(cur);\n                        longest = cur;\n                    } else if (longest.length() == cur.length() && longest.compareTo(cur) > 0) {\n                        //debug(cur);\n                        longest = cur;\n                    }\n                } else {\n                    occurOnce.add(cur);\n                    //occurOnce.add(hashCode);\n                }\n                ny = (ny + dy[i] + H) % H;\n                nx = (nx + dx[i] + W) % W;\n            }\n        }\n        //debug(longest);\n        return longest;\n    }\n    void debug(Object ... o) {\n        System.out.println(Arrays.deepToString(o));\n    }\n    void run() {\n        while (init()) {\n            String longest = \"\";\n            occurOnce = new HashSet<String>();\n            //occurOnce = new HashSet<Integer>();\n            for (int i = 0; i < H; i++) {\n                for (int j = 0; j < W; j++) {\n                    String cur = longestString(i, j);\n                    if (longest.length() < cur.length()) {\n                        //debug(cur);\n                        longest = cur;\n                    } else if (longest.length() == cur.length() && longest.compareTo(cur) > 0) {\n                        //debug(cur);\n                        longest = cur;\n                    }\n                }\n            }\n            if (longest.length() < 2) {\n                System.out.println(0);\n            } else {\n                System.out.println(longest);\n            }\n        }\n    }\n    Scanner sc;\n    Main() {\n        sc = new Scanner(System.in);\n    }\n    int W, H;\n    String [] F;\n    boolean init() {\n        H = sc.nextInt();\n        W = sc.nextInt();\n        if (H == 0 && W == 0) return false;\n        F = new String[H];\n        for (int i = 0; i < H; i++) {\n            F[i] = sc.next();\n        }\n        return true;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    int h, w;\n    int[] dx = {0, 0, 1, -1, 1, 1, -1, -1};\n    int[] dy = {1, -1, 0, 0, 1, -1, 1, -1};\n    char[][] donut;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        while(true){\n            h = sc.nextInt();\n            w = sc.nextInt();\n            if(h==0 && w==0) break;\n\n            donut = new char[h][w];\n            for(int i=0; i<h; i++){\n                String line = sc.next();\n                donut[i] = line.toCharArray();\n            }\n\n            int max = 0;\n            StringBuilder minString = new StringBuilder();\n\n            for(int l=h*w; l>=2; l--){\n                HashSet<String> set = new HashSet<String>();\n                for(int i=0; i<h; i++){\n                    for(int j=0; j<w; j++){\n                        for(int k=0; k<8; k++){                        \n                            StringBuilder s = new StringBuilder();\n                            s.append(donut[i][j]);\n                            int ny = (i + dy[k]) % h == -1 ? h-1 : (i + dy[k]) % h;\n                            int nx = (j + dx[k]) % w == -1 ? w-1 : (j + dx[k]) % w;\n                            while(!(ny==i && nx==j)){\n                                if(s.length()==l) break;\n                                s.append(donut[ny][nx]);\n                                ny = (ny + dy[k]) % h == -1 ? h-1 : (ny + dy[k]) % h;\n                                nx = (nx + dx[k]) % w == -1 ? w-1 : (nx + dx[k]) % w;\n                            }\n                            if(s.length()!=l) continue;\n\n                            if(!set.add(s.toString())){\n                                if(minString.length()==0) minString = s;\n                                else minString = min(s, minString);\n                                max = l;\n                            }\n                        }\n                    }\n                }\n                if(max!=0) break;\n            }\n\n            if(minString.length()==0) System.out.println(0);\n            else System.out.println(minString.toString());\n        }\n    }\n\n    StringBuilder min(StringBuilder s1, StringBuilder s2){\n        int l1 = s1.length(), l2 = s2.length();\n        for(int i=0; i<Math.min(l1, l2); i++){\n            if(s1.charAt(i)<s2.charAt(i)) return s1;\n            else if(s1.charAt(i)>s2.charAt(i)) return s2;\n        }\n        if(l1<l2) return s1;\n        return s2;\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner scan = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint H = scan.nextInt();\n\t\t\tif (H == 0) {\n\t\t\t\tscan.close();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint W = scan.nextInt();\n\n\t\t\tchar[][] table = new char[H][];\n\t\t\tfor (int i = 0; i < table.length; i++) {\n\t\t\t\t// 与えられるテーブルをしまっておく\n\t\t\t\ttable[i] = scan.next().toCharArray();\n\t\t\t}\n\n\t\t\tString answer = \"\";// 解答\n\t\t\tint[] dir = { -1, 0, 1 };// 方向\n\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tArrayList<String>[][] parts = new ArrayList[26][201];// [頭文字][長さ]の文字列を格納する\n\t\t\tfor (int i = 0; i < parts.length; i++) {\n\t\t\t\tfor (int j = 0; j < parts[i].length; j++) {\n\t\t\t\t\tparts[i][j] = new ArrayList<String>();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < table.length; i++) {\n\t\t\t\tfor (int j = 0; j < table[i].length; j++) {\n\t\t\t\t\tfor (int k = 0; k < dir.length; k++) {\n\t\t\t\t\t\tfor (int l = 0; l < dir.length; l++) {\n\t\t\t\t\t\t\tif (dir[k] == dir[l] && dir[k] == 0) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tint nowi = i;\n\t\t\t\t\t\t\tint nowj = j;\n\t\t\t\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\t\t\t\tsb.append(table[nowi][nowj]);\n\n\t\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\t\tnowi = (nowi + dir[k] + H) % H;\n\t\t\t\t\t\t\t\tnowj = (nowj + dir[l] + W) % W;\n\n\t\t\t\t\t\t\t\tif (nowi == i && nowj == j) {\n\t\t\t\t\t\t\t\t\t// 元の場所に戻ってきてたら終わる\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tsb.append(table[nowi][nowj]);// 文字を後ろに付け加える\n\n\t\t\t\t\t\t\t\tchar init = (char) (table[i][j] - 'A');// 頭文字\n\t\t\t\t\t\t\t\tString seq = sb.toString();// 文字列\n\t\t\t\t\t\t\t\tint length = sb.length();// 文字列の長さ\n\n\t\t\t\t\t\t\t\tif (parts[init][length].contains(seq)) {\n\t\t\t\t\t\t\t\t\tif (length > answer.length()) {\n\t\t\t\t\t\t\t\t\t\tanswer = seq;\n\t\t\t\t\t\t\t\t\t} else if (length == answer.length()) {\n\t\t\t\t\t\t\t\t\t\t// 文字列の長さが同じ時は辞書順で前のやつを採用する\n\t\t\t\t\t\t\t\t\t\tif (answer.compareTo(seq) > 0) {\n\t\t\t\t\t\t\t\t\t\t\tanswer = seq;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if (length >= 2) {\n\t\t\t\t\t\t\t\t\t// 2文字以上ならリストに加えておく\n\t\t\t\t\t\t\t\t\tparts[init][length].add(seq);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (answer.equals(\"\")) {\n\t\t\t\tSystem.out.println(0);\n\t\t\t} else {\n\t\t\t\tSystem.out.println(answer);\n\t\t\t}\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.lang.ArrayIndexOutOfBoundsException;\nimport java.math.BigInteger;\n\n/**\n * @author yoshikyoto\n */\nclass Main{\n\tstatic HashSet<String> set;\n\tstatic int maxLength;\n\tstatic String ans;\n\tstatic char[][] c;\n\tstatic int h, w;\n\tpublic static void main(String[] args) throws Exception{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\twhile(true){\n\t\t\tString[] in = br.readLine().split(\" \");\n\t\t\th = Integer.parseInt(in[0]);\n\t\t\tw = Integer.parseInt(in[1]);\n\t\t\tif(h+w == 0) break;\n\t\t\t\n\t\t\tc = new char[h][w];\n\t\t\tfor(int i = 0; i < h; i++)\n\t\t\t\tc[i] = br.readLine().toCharArray();\n\t\t\t\n\t\t\tset = new HashSet<String>();\n\t\t\tmaxLength = 0;\n\t\t\tans = \"0\";\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\t// i, j から始まる文字列を調べる\n\t\t\t\t\tcheck(i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(maxLength >= 2){\n\t\t\t\tSystem.out.println(ans);\n\t\t\t}else{\n\t\t\t\tSystem.out.println(\"0\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic int[] di = {-1, -1, -1, 0, 0, 1, 1, 1};\n\tstatic int[] dj = {-1, 0, 1, -1, 1, -1, 0, 1};\n\tstatic void check(int i, int j){\n\t\tfor(int k = 0; k < 8; k++){\n\t\t\t// 方向が決定\n\t\t\tboolean[][] visited = new boolean[h][w];\n\t\t\tint ii = i, jj = j;\n\t\t\tStringBuilder sb = new StringBuilder(\"\");\n\t\t\twhile(!visited[ii][jj]){\n\t\t\t\tsb.append(c[ii][jj]);\n\t\t\t\tString str = sb.toString();\n\t\t\t\t\n\t\t\t\tif(set.contains(str)){\n\t\t\t\t\t// すでに出現したことがある場合\n\t\t\t\t\tint str_len = str.length();\n\t\t\t\t\tif(maxLength < str_len){\n\t\t\t\t\t\t// 長さの記録更新\n\t\t\t\t\t\tans = str;\n\t\t\t\t\t\tmaxLength = str_len;\n\t\t\t\t\t}else if(maxLength == str_len && str.compareTo(ans) < 0){\n\t\t\t\t\t\t// 長さは同じだけど辞書順で早い場合\n\t\t\t\t\t\tans = str;\n\t\t\t\t\t\tmaxLength = str_len;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tset.add(str);\n\t\t\t\t}\n\t\t\t\tvisited[ii][jj] = true;\n\t\t\t\tii = (ii + di[k] + h) % h;\n\t\t\t\tjj = (jj + dj[k] + w) % w;\n\t\t\t}\n\t\t}\n\t}\n}\n\n// --- ここから下はライブラリ ----------\n/**\n * MyUtil\n * @author yoshikyoto\n */\nclass MyUtil {\n\tpublic static int[] cp(int[] a){\n\t\tint[] b = new int[a.length];\n\t\tfor(int i = 0; i < a.length; i++) b[i] = a[i];\n\t\treturn b;\n\t}\n\tpublic static int toInt(boolean[] a){\n\t\tint pow = 1, ret = 0, l = a.length;\n\t\tfor(int i = 0; i < l; i++){\n\t\t\tif(a[i]) ret += pow;\n\t\t\tpow *= 2;\n\t\t}\n\t\treturn ret;\n\t}\n\tstatic BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static int ins[];\n\tpublic static int[] readIntMap() throws IOException{return parseInt(readLine().split(\" \"));}\n\tpublic static int readIntMap(int i) throws Exception{\n\t\tif(i == 0) ins = readIntMap();\n\t\treturn ins[i];\n\t}\n\tpublic static int[][] readIntMap(int n, int m) throws IOException{\n\t\tint[][] ret = new int[n][];\n\t\tfor(int i = 0; i < n; i++) ret[i] = readIntMap();\n\t\treturn ret;\n\t}\n\tpublic static int[] readIntToMap(int n) throws IOException{\n\t\tint[] ret = new int[n];\n\t\tfor(int i = 0; i < n; i++) ret[i] = readInt();\n\t\treturn ret;\n\t}\n\tpublic static int[] readNoDistIntMap() throws IOException{\n\t\tString[] strs = readLine().split(\"\");\n\t\tint l = strs.length;\n\t\tint[] ret = new int[l-1];\n\t\tfor(int i = 1; i < l; i++)\n\t\t\tret[i-1] = parseInt(strs[i]);\n\t\treturn ret;\n\t}\n\tpublic static String readLine() throws IOException{return br.readLine();}\n\tpublic static int readInt() throws IOException{return Integer.parseInt(br.readLine());}\n\tpublic static int[] parseInt(String[] arr){\n\t\tint[] res = new int[arr.length];\n\t\tfor(int i = 0; i < arr.length; i++)res[i] = Integer.parseInt(arr[i]);\n\t\treturn res;\n\t}\n\tpublic static double[] parseDouble(String[] arr){\n\t\tdouble[] res = new double[arr.length];\n\t\tfor(int i = 0; i < arr.length; i++)res[i] = Double.parseDouble(arr[i]);\n\t\treturn res;\n\t}\n\tpublic static boolean[] parseBool(String[] arr){\n\t\tint[] t = parseInt(arr);\n\t\tboolean[] res = new boolean[t.length];\n\t\tfor(int i = 0; i < t.length; i++){\n\t\t\tif(t[i] == 1){res[i] = true;\n\t\t\t}else{res[i] = false;}\n\t\t}\n\t\treturn res;\n\t}\n\tpublic static int parseInt(Object o){\n\t\treturn Integer.parseInt(o.toString());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.lang.ArrayIndexOutOfBoundsException;\nimport java.math.BigInteger;\n\n/**\n * @author yoshikyoto\n */\nclass Main extends MyUtil{\n\t// public static Graph g;\n\tstatic HashSet<String> set;\n\tstatic int maxLength;\n\tstatic String ans;\n\tstatic char[][] c;\n\tstatic int h, w;\n\tpublic static void main(String[] args) throws Exception{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\twhile(true){\n\t\t\tString[] in = br.readLine().split(\" \");\n\t\t\th = Integer.parseInt(in[0]);\n\t\t\tw = Integer.parseInt(in[1]);\n\t\t\tif(h+w == 0) break;\n\t\t\t\n\t\t\tc = new char[h][w];\n\t\t\tfor(int i = 0; i < h; i++)\n\t\t\t\tc[i] = br.readLine().toCharArray();\n\t\t\t\n\t\t\tset = new HashSet<String>();\n\t\t\tmaxLength = 0;\n\t\t\tans = \"0\";\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tcheck(i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(maxLength >= 2){\n\t\t\t\tSystem.out.println(ans);\n\t\t\t}else{\n\t\t\t\tSystem.out.println(\"0\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic int[] di = {-1, -1, -1, 0, 0, 1, 1, 1};\n\tstatic int[] dj = {-1, 0, 1, -1, 1, -1, 0, 1};\n\tstatic void check(int i, int j){\n\t\t// System.out.println(\"check \" + i + \" \" + j);\n\t\tfor(int k = 0; k < 8; k++){\n\t\t\t// 方向が決定\n\t\t\tboolean[][] visited = new boolean[h][w];\n\t\t\tint ii = i, jj = j;\n\t\t\tStringBuffer sb = new StringBuffer(\"\");\n\t\t\twhile(!visited[ii][jj]){\n\t\t\t\t// System.out.println(\"(\" + ii + \", \" + jj + \")\");\n\t\t\t\tsb.append(c[ii][jj]);\n\t\t\t\tString str = sb.toString();\n\t\t\t\t// System.out.println(str);\n\t\t\t\t\n\t\t\t\tif(set.contains(str)){\n\t\t\t\t\t// すでに出現したことがある場合\n\t\t\t\t\tint str_len = str.length();\n\t\t\t\t\tif(maxLength < str_len){\n\t\t\t\t\t\t// 長さの記録更新\n\t\t\t\t\t\tans = str;\n\t\t\t\t\t\tmaxLength = str_len;\n\t\t\t\t\t}else if(maxLength == str_len && str.compareTo(ans) < 0){\n\t\t\t\t\t\t// 長さは同じだけど辞書順で早い場合\n\t\t\t\t\t\tans = str;\n\t\t\t\t\t\tmaxLength = str_len;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tset.add(str);\n\t\t\t\t}\n\t\t\t\tvisited[ii][jj] = true;\n\t\t\t\tii = (ii + di[k] + h) % h;\n\t\t\t\tjj = (jj + dj[k] + w) % w;\n\t\t\t}\n\t\t}\n\t}\n}\n\n// --- ここから下はライブラリ ----------\n/**\n * MyUtil\n * @author yoshikyoto\n */\nclass MyUtil {\n\tpublic static int[] cp(int[] a){\n\t\tint[] b = new int[a.length];\n\t\tfor(int i = 0; i < a.length; i++) b[i] = a[i];\n\t\treturn b;\n\t}\n\tpublic static int toInt(boolean[] a){\n\t\tint pow = 1, ret = 0, l = a.length;\n\t\tfor(int i = 0; i < l; i++){\n\t\t\tif(a[i]) ret += pow;\n\t\t\tpow *= 2;\n\t\t}\n\t\treturn ret;\n\t}\n\tstatic BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static int ins[];\n\tpublic static int[] readIntMap() throws IOException{return parseInt(readLine().split(\" \"));}\n\tpublic static int readIntMap(int i) throws Exception{\n\t\tif(i == 0) ins = readIntMap();\n\t\treturn ins[i];\n\t}\n\tpublic static int[][] readIntMap(int n, int m) throws IOException{\n\t\tint[][] ret = new int[n][];\n\t\tfor(int i = 0; i < n; i++) ret[i] = readIntMap();\n\t\treturn ret;\n\t}\n\tpublic static int[] readIntToMap(int n) throws IOException{\n\t\tint[] ret = new int[n];\n\t\tfor(int i = 0; i < n; i++) ret[i] = readInt();\n\t\treturn ret;\n\t}\n\tpublic static int[] readNoDistIntMap() throws IOException{\n\t\tString[] strs = readLine().split(\"\");\n\t\tint l = strs.length;\n\t\tint[] ret = new int[l-1];\n\t\tfor(int i = 1; i < l; i++)\n\t\t\tret[i-1] = parseInt(strs[i]);\n\t\treturn ret;\n\t}\n\tpublic static String readLine() throws IOException{return br.readLine();}\n\tpublic static int readInt() throws IOException{return Integer.parseInt(br.readLine());}\n\tpublic static int[] parseInt(String[] arr){\n\t\tint[] res = new int[arr.length];\n\t\tfor(int i = 0; i < arr.length; i++)res[i] = Integer.parseInt(arr[i]);\n\t\treturn res;\n\t}\n\tpublic static double[] parseDouble(String[] arr){\n\t\tdouble[] res = new double[arr.length];\n\t\tfor(int i = 0; i < arr.length; i++)res[i] = Double.parseDouble(arr[i]);\n\t\treturn res;\n\t}\n\tpublic static boolean[] parseBool(String[] arr){\n\t\tint[] t = parseInt(arr);\n\t\tboolean[] res = new boolean[t.length];\n\t\tfor(int i = 0; i < t.length; i++){\n\t\t\tif(t[i] == 1){res[i] = true;\n\t\t\t}else{res[i] = false;}\n\t\t}\n\t\treturn res;\n\t}\n\tpublic static int parseInt(Object o){\n\t\treturn Integer.parseInt(o.toString());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashSet;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int[] DR = { 1, 1, 1, 0, -1, -1, -1, 0 };\n\tstatic int[] DC = { -1, 0, 1, 1, 1, 0, -1, -1 };\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tint H = sc.nextInt();\n\t\t\tint W = sc.nextInt();\n\t\t\tif (H == 0) break;\n\t\t\tchar[][] f = new char[H][];\n\t\t\tfor (int i = 0; i < H; ++i) {\n\t\t\t\tf[i] = sc.next().toCharArray();\n\t\t\t}\n\t\t\tHashSet<String> set = new HashSet<String>();\n\t\t\tString ans = \"\";\n\t\t\tfor (int i = 0; i < H; ++i) {\n\t\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\t\tfor (int k = 0; k < 8; ++k) {\n\t\t\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\t\t\tsb.append(f[i][j]);\n\t\t\t\t\t\tint cr = i;\n\t\t\t\t\t\tint cc = j;\n\t\t\t\t\t\tboolean[][] visited = new boolean[H][W];\n\t\t\t\t\t\tvisited[cr][cc] = true;\n\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\tcr += DR[k];\n\t\t\t\t\t\t\tcc += DC[k];\n\t\t\t\t\t\t\tif (cr == -1) cr += H;\n\t\t\t\t\t\t\tif (cr == H) cr = 0;\n\t\t\t\t\t\t\tif (cc == -1) cc += W;\n\t\t\t\t\t\t\tif (cc == W) cc = 0;\n\t\t\t\t\t\t\tif (visited[cr][cc]) break;\n\t\t\t\t\t\t\tvisited[cr][cc] = true;\n\t\t\t\t\t\t\tsb.append(f[cr][cc]);\n\t\t\t\t\t\t\tString str = sb.toString();\n\t\t\t\t\t\t\tif (set.contains(str)\n\t\t\t\t\t\t\t\t\t&& (str.length() > ans.length() || str.length() == ans.length() && str.compareTo(ans) < 0)) {\n\t\t\t\t\t\t\t\tans = str;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tset.add(str);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans.length() == 0 ? 0 : ans);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\nclass LengthComparator implements Comparator<String> {\n    public int compare(String a, String b) {\n        if (a.length() == b.length()) {\n            return a.compareTo(b);\n        } else {\n            return b.length() - a.length();\n        }\n    }\n}\n\npublic class Main {\n    public static void main(String [] args) {\n        new Main().run();\n    }\n    final int [] dx = {0, 1, 1,  1,  0, -1, -1, -1};\n    final int [] dy = {1, 1, 0, -1, -1, -1,  0,  1};\n    HashSet<String> occurOnce;\n    HashSet<String> occurTwice;\n    void makeString(int y, int x) {\n        for (int i = 0; i < 8; i++) {\n            String cur = String.valueOf(F[y].charAt(x));\n            int ny = (y + dy[i] + H) % H, nx = (x + dx[i] + W) % W;\n            while (ny != y || nx != x) {\n                cur = cur + String.valueOf(F[ny].charAt(nx));\n                if (occurOnce.contains(cur)) {\n                    occurTwice.add(cur);\n                } else {\n                    occurOnce.add(cur);\n                }\n                ny = (ny + dy[i] + H) % H;\n                nx = (nx + dx[i] + W) % W;\n            }\n        }\n    }\n    void debug(Object ... o) {\n        System.out.println(Arrays.deepToString(o));\n    }\n    void run() {\n        while (init()) {\n            ArrayList<String> ans = new ArrayList<String>();\n            for (char c = 'A'; c <= 'Z'; c++) {\n                occurOnce = new HashSet<String>();\n                occurTwice = new HashSet<String>();\n                for (int i = 0; i < H; i++) {\n                    for (int j = 0; j < W; j++) {\n                        if (F[i].charAt(j) == c) makeString(i, j);\n                    }\n                }\n                //ArrayList<String> list = new ArrayList<String>();\n                //for (Iterator it = occurTwice.iterator(); it.hasNext(); ) {\n                //    String spell = (String)it.next();\n                //    list.add(spell);\n                //}\n                //if (list.isEmpty()) continue;\n                if (occurTwice.isEmpty()) continue;\n                ans.add(Collections.min(occurTwice, new LengthComparator()));\n            }\n            if (ans.isEmpty()) {\n                System.out.println(0);\n            } else {\n                //Collections.sort(ans, new LengthComparator());\n                //System.out.println(ans.get(0));\n                System.out.println(Collections.min(ans, new LengthComparator()));\n            }\n        }\n    }\n    Scanner sc;\n    Main() {\n        sc = new Scanner(System.in);\n    }\n    int W, H;\n    String [] F;\n    boolean init() {\n        H = sc.nextInt();\n        W = sc.nextInt();\n        if (H == 0 && W == 0) return false;\n        F = new String[H];\n        for (int i = 0; i < H; i++) {\n            F[i] = sc.next();\n        }\n        return true;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\tpublic void run() {\n\t\twhile(sc.hasNext()){\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tif(h == 0 && w == 0)break;\n\t\t\telse calc(h, w);\n\t\t\t\n\t\t}\n\t}\n\tpublic void calc(int w, int h){\n\t\tString[][] donut = new String[w][h];\n\t\tfor(int i = 0; i < w; i++){\n\t\t\tString line = sc.next();\n\t\t\tfor(int j = 0; j < h; j++){\n\t\t\t\tdonut[i][j] = line.substring(j, j+1);\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tint x[] = {0, 1, 1, 1, 0,-1,-1,-1};\n\t\tint y[] = {1, 1, 0,-1,-1,-1, 0, 1};\n\t\tString max = \"\";\n\t\tHashMap<String, Integer> map = new HashMap<String, Integer>();\n\t\tfor(int i = 0; i < w; i++){\n\t\t\tfor(int j = 0; j < h; j++){\n\t\t\t\tfor(int k = 0; k < 8; k++){\n\t\t\t\t\tString s = donut[i][j];\n\t\t\t\t\tint nx = i + x[k];\n\t\t\t\t\tint ny = j + y[k];\n\t\t\t\t\tif(nx >= w) nx = 0;\n\t\t\t\t\tif(nx < 0) nx = w-1;\n\t\t\t\t\tif(ny >= h) ny = 0;\n\t\t\t\t\tif(ny < 0) ny = h-1;\n\t\t\t\t\twhile(!(nx == i && ny == j)){\n\t\t\t\t\t\ts += donut[nx][ny];\n\t\t\t\t\t\tif(map.containsKey(s)){\n\t\t\t\t\t\t\tif(max.length() < s.length()) max = s;\n\t\t\t\t\t\t\telse if(max.length() == s.length() && s.compareTo(max) < 0) max = s;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(max.length() <= s.length()) map.put(s, 1);\n\t\t\t\t\t\t\n\t\t\t\t\t\tnx += x[k];\n\t\t\t\t\t\tny += y[k];\n\t\t\t\t\t\tif(nx >= w) nx = 0;\n\t\t\t\t\t\tif(nx < 0) nx = w-1;\n\t\t\t\t\t\tif(ny >= h) ny = 0;\n\t\t\t\t\t\tif(ny < 0) ny = h-1;\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(max.equals(\"\")) System.out.println(0);\n\t\telse System.out.println(max);\n\t}\n\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    int h, w;\n    int[] dx = {0, 0, 1, -1, 1, 1, -1, -1};\n    int[] dy = {1, -1, 0, 0, 1, -1, 1, -1};\n    char[][] donut;\n    String cutS;\n\n    @SuppressWarnings(\"unchecked\")\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        while(true){\n            h = sc.nextInt();\n            w = sc.nextInt();\n            if(h==0 && w==0) break;\n\n            donut = new char[h][w];\n            for(int i=0; i<h; i++){\n                String line = sc.next();\n                donut[i] = line.toCharArray();\n            }\n\n            int max = 0;\n            StringBuilder minString = new StringBuilder();\n\n            for(int l=h*w; l>=2; l--){\n                HashSet<String> set = new HashSet<String>();\n                for(int i=0; i<h; i++){\n                    for(int j=0; j<w; j++){\n                        for(int k=0; k<8; k++){                        \n                            StringBuilder s = new StringBuilder();\n                            s.append(donut[i][j]);\n                            int ny = (i + dy[k]) % h, nx = (j + dx[k]) % w;\n                            if(ny==-1) ny = h-1;\n                            if(nx==-1) nx = w-1;\n                            while(!(ny==i && nx==j)){\n                                if(s.length()==l) break;\n                                s.append(donut[ny][nx]);\n                                ny = (ny + dy[k]) % h;\n                                nx = (nx + dx[k]) % w;\n                                if(ny==-1) ny = h-1;\n                                if(nx==-1) nx = w-1;\n                            }\n                            if(s.length()!=l) continue;\n\n                            if(!set.add(s.toString()) && (minString.length()==0 || min(s, minString))){\n                                max = s.length();\n                                minString = s;\n                            }\n                        }\n                    }\n                }\n                if(max!=0) break;\n            }\n\n            if(minString.length()==0) System.out.println(0);\n            else System.out.println(minString.toString());\n        }\n    }\n\n    boolean min(StringBuilder s1, StringBuilder s2){ //s1 < s2?\n        int l1 = s1.length(), l2 = s2.length();\n        for(int i=0; i<Math.min(l1, l2); i++){\n            if(s1.charAt(i)<s2.charAt(i)) return true;\n            else if(s1.charAt(i)>s2.charAt(i)) return false;\n        }\n        if(l1<l2) return true;\n        return false;\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    int h, w;\n    int[] dx = {0, 0, 1, -1, 1, 1, -1, -1};\n    int[] dy = {1, -1, 0, 0, 1, -1, 1, -1};\n    char[][] donut;\n    String cutS;\n\n    @SuppressWarnings(\"unchecked\")\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        while(true){\n            h = sc.nextInt();\n            w = sc.nextInt();\n            if(h==0 && w==0) break;\n\n            donut = new char[h][w];\n            for(int i=0; i<h; i++){\n                String line = sc.next();\n                donut[i] = line.toCharArray();\n            }\n\n            int max = 0;\n            String minString = \"0\";\n            ArrayList[] list = new ArrayList[201];\n            for(int i=0; i<201; i++) list[i] = new ArrayList<String>();\n\n            for(int i=0; i<h; i++){\n                for(int j=0; j<w; j++){\n                    for(int k=0; k<8; k++){\n                        \n                        String s = \"\";\n                        s += donut[i][j];\n                        int ny = (i + dy[k]) % h, nx = (j + dx[k]) % w;\n                        if(ny==-1) ny = h-1;\n                        if(nx==-1) nx = w-1;\n                        while(!(ny==i && nx==j)){\n                            s += donut[ny][nx];\n                            ny = (ny + dy[k]) % h;\n                            nx = (nx + dx[k]) % w;\n                            if(ny==-1) ny = h-1;\n                            if(nx==-1) nx = w-1;\n                            if(!list[s.length()].contains(s) && s.length()>=max) list[s.length()].add(s);\n                            else if(s.length()>max || (s.length()==max && (minString.equals(\"0\") || min(s, minString)))){\n                                max = s.length();\n                                minString = s;\n                            }\n                        }\n                    }\n                }\n            }\n\n            System.out.println(minString);\n        }\n    }\n\n    boolean min(String s1, String s2){ //s1 < s2?\n        int l1 = s1.length(), l2 = s2.length();\n        for(int i=0; i<Math.min(l1, l2); i++){\n            if(s1.charAt(i)<s2.charAt(i)) return true;\n            else if(s1.charAt(i)>s2.charAt(i)) return false;\n        }\n        if(l1<l2) return true;\n        return false;\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int[] DR = { 1, 1, 1, 0, -1, -1, -1, 0 };\n\tstatic int[] DC = { -1, 0, 1, 1, 1, 0, -1, -1 };\n\n\tpublic static void main(String[] args) {\n\t\tint[][] visited = new int[10][20];\n\t\tint turn = 0;\n\t\twhile (true) {\n\t\t\tint H = sc.nextInt();\n\t\t\tint W = sc.nextInt();\n\t\t\tif (H == 0) break;\n\t\t\tchar[][] f = new char[H][];\n\t\t\tfor (int i = 0; i < H; ++i) {\n\t\t\t\tf[i] = sc.next().toCharArray();\n\t\t\t}\n\t\t\tArrayList<HashSet<String>> set = new ArrayList<HashSet<String>>();\n\t\t\tfor (int i = 0; i <= H * W; ++i) {\n\t\t\t\tset.add(new HashSet<String>());\n\t\t\t}\n\t\t\tString ans = \"\";\n\t\t\tfor (int i = 0; i < H; ++i) {\n\t\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\t\tfor (int k = 0; k < 8; ++k) {\n\t\t\t\t\t\t++turn;\n\t\t\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\t\t\tsb.append(f[i][j]);\n\t\t\t\t\t\tint cr = i;\n\t\t\t\t\t\tint cc = j;\n\t\t\t\t\t\tvisited[cr][cc] = turn;\n\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\tcr += DR[k];\n\t\t\t\t\t\t\tcc += DC[k];\n\t\t\t\t\t\t\tif (cr == -1) cr += H;\n\t\t\t\t\t\t\tif (cr == H) cr = 0;\n\t\t\t\t\t\t\tif (cc == -1) cc += W;\n\t\t\t\t\t\t\tif (cc == W) cc = 0;\n\t\t\t\t\t\t\tif (visited[cr][cc] == turn) break;\n\t\t\t\t\t\t\tvisited[cr][cc] = turn;\n\t\t\t\t\t\t\tsb.append(f[cr][cc]);\n\t\t\t\t\t\t\tString str = sb.toString();\n\t\t\t\t\t\t\tif (str.length() > ans.length() || str.length() == ans.length() && str.compareTo(ans) < 0) {\n\t\t\t\t\t\t\t\tif (set.get(str.length()).contains(str)) {\n\t\t\t\t\t\t\t\t\tans = str;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tset.get(str.length()).add(str);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans.length() == 0 ? 0 : ans);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner scan = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint H = scan.nextInt();\n\t\t\tif (H == 0) {\n\t\t\t\tscan.close();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint W = scan.nextInt();\n\n\t\t\tchar[][] table = new char[H][];\n\t\t\tfor (int i = 0; i < table.length; i++) {\n\t\t\t\ttable[i] = scan.next().toCharArray();\n\t\t\t}\n\n\t\t\tString answer = \"\";\n\t\t\tint[] dir = { -1, 0, 1 };\n\t\t\tArrayList<String>[][] parts = new ArrayList[26][201];\n\t\t\tfor (int i = 0; i < parts.length; i++) {\n\t\t\t\tfor (int j = 0; j < parts[i].length; j++) {\n\t\t\t\t\tparts[i][j] = new ArrayList<String>();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < table.length; i++) {\n\t\t\t\tfor (int j = 0; j < table[i].length; j++) {\n\t\t\t\t\tfor (int k = 0; k < dir.length; k++) {\n\t\t\t\t\t\tfor (int l = 0; l < dir.length; l++) {\n\t\t\t\t\t\t\tif (dir[k] == dir[l] && dir[k] == 0) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tint nowi = i;\n\t\t\t\t\t\t\tint nowj = j;\n\t\t\t\t\t\t\tStringBuilder builder = new StringBuilder();\n\t\t\t\t\t\t\tbuilder.append(table[nowi][nowj]);\n\t\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\t\tnowi = (nowi + dir[k] + H) % H;\n\t\t\t\t\t\t\t\tnowj = (nowj + dir[l] + W) % W;\n\n\t\t\t\t\t\t\t\tif (nowi == i && nowj == j) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbuilder.append(table[nowi][nowj]);\n\t\t\t\t\t\t\t\tif (parts[table[i][j] - 'A'][builder.length()]\n\t\t\t\t\t\t\t\t\t\t.contains(builder.toString())) {\n\t\t\t\t\t\t\t\t\tif (builder.length() > answer.length()) {\n\t\t\t\t\t\t\t\t\t\tanswer = builder.toString();\n\t\t\t\t\t\t\t\t\t} else if (builder.length() == answer\n\t\t\t\t\t\t\t\t\t\t\t.length()) {\n\t\t\t\t\t\t\t\t\t\tif (answer\n\t\t\t\t\t\t\t\t\t\t\t\t.compareTo(builder.toString()) > 0) {\n\t\t\t\t\t\t\t\t\t\t\tanswer = builder.toString();\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if (builder.length() >= 2) {\n\t\t\t\t\t\t\t\t\tparts[table[i][j] - 'A'][builder.length()]\n\t\t\t\t\t\t\t\t\t\t\t.add(builder.toString());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(answer);\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true){\n//\t\t\tSystem.gc();\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\n\t\t\tif(h == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tchar[][] input = new char[h][w];\n\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tinput[i] = sc.next().toCharArray();\n\t\t\t}\n\n\t\t\tString result = \"\";\n\t\t\tint dx[] = {0,1,1,1,0,w-1,w-1,w-1};\n\t\t\tint dy[] = {h-1,h-1,0,1,1,1,0,h-1};\n\t\t\tboolean visit1[][] = new boolean[h][w];\n\t\t\tboolean visit2[][] = new boolean[h][w];\n\n\t\t\tStringBuffer tmpResult;\n\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tfor(int k = 0; k < h; k++){\n\t\t\t\t\t\tfor(int l = 0; l < w; l++){\n\t\t\t\t\t\t\tif(i == k && j == l){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif(input[i][j] != input[k][l]){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif(i*w + j >= k*w + l){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tfor(int d1 = 0; d1 < 8; d1++){\n\t\t\t\t\t\t\t\tfor(int d2 = 0; d2 < 8; d2++){\n\t\t\t\t\t\t\t\t\tfor(int p = 0; p < h; p++){\n\t\t\t\t\t\t\t\t\t\tArrays.fill(visit1[p], false);\n\t\t\t\t\t\t\t\t\t\tArrays.fill(visit2[p], false);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tint x1 = j, y1 = i, x2 = l, y2 = k;\n//\t\t\t\t\t\t\t\t\tString tmpResult = \"\";\n//\t\t\t\t\t\t\t\t\ttmpResult = \"\";\n\t\t\t\t\t\t\t\t\ttmpResult = new StringBuffer();\n\t\t\t\t\t\t\t\t\twhile(input[y1][x1] == input[y2][x2]){\n//\t\t\t\t\t\t\t\t\t\ttmpResult += input[y1][x1];\n\t\t\t\t\t\t\t\t\t\ttmpResult.append(input[y1][x1]);\n\t\t\t\t\t\t\t\t\t\tvisit1[y1][x1] = true;\n\t\t\t\t\t\t\t\t\t\tvisit2[y2][x2] = true;\n\n\t\t\t\t\t\t\t\t\t\tx1 = (x1 + dx[d1])%w;\n\t\t\t\t\t\t\t\t\t\ty1 = (y1 + dy[d1])%h;\n\t\t\t\t\t\t\t\t\t\tx2 = (x2 + dx[d2])%w;\n\t\t\t\t\t\t\t\t\t\ty2 = (y2 + dy[d2])%h;\n\n\t\t\t\t\t\t\t\t\t\tif(visit1[y1][x1] || visit2[y2][x2]){\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif(tmpResult.length() > result.length() ||\n\t\t\t\t\t\t\t\t\t\t\t(tmpResult.length() == result.length() && tmpResult.toString().compareTo(result) < 0)){\n//\t\t\t\t\t\t\t\t\t\tresult = tmpResult;\n\t\t\t\t\t\t\t\t\t\tresult = tmpResult.toString();\n\t\t\t\t\t\t\t\t\t}\n//\t\t\t\t\t\t\t\t\tSystem.gc();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n//\t\t\t\t\t\t\tSystem.gc();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//System.gc();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(result.length() >= 2 ? result : 0);\n//\t\t\tSystem.gc();\n\t\t}\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tint h, w;\n\tchar[][] map;\n\tboolean[][] visited;\n\tint[] dirx = {-1, 0, 1, -1, 1, -1, 0, 1};\n\tint[] diry = {-1, -1, -1, 0, 0, 1, 1, 1};\n\tHashSet<String> hash;\n\tString ans;\n\t\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\th = in.nextInt();\n\t\t\tw = in.nextInt();\n\t\t\tif ((h|w) == 0) break;\n\t\t\tmap = new char[h][w];\n\t\t\tvisited = new boolean[h][w];\n\t\t\thash = new HashSet<String>();\n\t\t\tans = \"\";\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tString s = in.next();\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tmap[i][j] = s.charAt(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tfor (int k = 0; k < 8; k++) {\n\t\t\t\t\t\tint x = j, y = i;\n\t\t\t\t\t\tString s = map[y][x] + \"\";\n\t\t\t\t\t\tfor (int l = 0; l < visited.length; l++)\n\t\t\t\t\t\t\tArrays.fill(visited[l], false);\n\t\t\t\t\t\tvisited[i][j] = true;\n\t\t\t\t\t\tfor ( ; ; ) {\n\t\t\t\t\t\t\tx = (x + dirx[k] + w) % w;\n\t\t\t\t\t\t\ty = (y + diry[k] + h) % h;\n\t\t\t\t\t\t\ts += map[y][x];\n\t\t\t\t\t\t\tif (!visited[y][x]) {\n\t\t\t\t\t\t\t\tif (hash.contains(s)) {\n\t\t\t\t\t\t\t\t\tif (s.length() > ans.length() || (s.length() == ans.length() && s.compareTo(ans) < 0)) {\n\t\t\t\t\t\t\t\t\t\tans = s.toString();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if (s.length() >= 2 || ans.length() < s.length()){\n\t\t\t\t\t\t\t\t\thash.add(s);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (ans.length() < 2)\n\t\t\t\tSystem.out.println(0);\n\t\t\telse\n\t\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner scan = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint H = scan.nextInt();\n\t\t\tif (H == 0) {\n\t\t\t\tscan.close();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint W = scan.nextInt();\n\n\t\t\tchar[][] table = new char[H][];\n\t\t\tfor (int i = 0; i < table.length; i++) {\n\t\t\t\ttable[i] = scan.next().toCharArray();\n\t\t\t}\n\n\t\t\tString answer = \"\";\n\t\t\tint[] dir = { -1, 0, 1 };\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tArrayList<String>[][] parts = new ArrayList[26][201];\n\t\t\tfor (int i = 0; i < parts.length; i++) {\n\t\t\t\tfor (int j = 0; j < parts[i].length; j++) {\n\t\t\t\t\tparts[i][j] = new ArrayList<String>();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < table.length; i++) {\n\t\t\t\tfor (int j = 0; j < table[i].length; j++) {\n\t\t\t\t\tfor (int k = 0; k < dir.length; k++) {\n\t\t\t\t\t\tfor (int l = 0; l < dir.length; l++) {\n\t\t\t\t\t\t\tif (dir[k] == dir[l] && dir[k] == 0) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tint nowi = i;\n\t\t\t\t\t\t\tint nowj = j;\n\t\t\t\t\t\t\tStringBuilder builder = new StringBuilder();\n\t\t\t\t\t\t\tbuilder.append(table[nowi][nowj]);\n\t\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\t\tnowi = (nowi + dir[k] + H) % H;\n\t\t\t\t\t\t\t\tnowj = (nowj + dir[l] + W) % W;\n\n\t\t\t\t\t\t\t\tif (nowi == i && nowj == j) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbuilder.append(table[nowi][nowj]);\n\t\t\t\t\t\t\t\tif (parts[table[i][j] - 'A'][builder.length()]\n\t\t\t\t\t\t\t\t\t\t.contains(builder.toString())) {\n\t\t\t\t\t\t\t\t\tif (builder.length() > answer.length()) {\n\t\t\t\t\t\t\t\t\t\tanswer = builder.toString();\n\t\t\t\t\t\t\t\t\t} else if (builder.length() == answer\n\t\t\t\t\t\t\t\t\t\t\t.length()) {\n\t\t\t\t\t\t\t\t\t\tif (answer\n\t\t\t\t\t\t\t\t\t\t\t\t.compareTo(builder.toString()) > 0) {\n\t\t\t\t\t\t\t\t\t\t\tanswer = builder.toString();\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if (builder.length() >= 2) {\n\t\t\t\t\t\t\t\t\tparts[table[i][j] - 'A'][builder.length()]\n\t\t\t\t\t\t\t\t\t\t\t.add(builder.toString());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (answer.equals(\"\")) {\n\t\t\t\tSystem.out.println(0);\n\t\t\t} else {\n\t\t\t\tSystem.out.println(answer);\n\t\t\t}\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tint h, w;\n\tchar[][] map;\n\tboolean[][] visited;\n\tint[] dirx = {-1, 0, 1, -1, 1, -1, 0, 1};\n\tint[] diry = {-1, -1, -1, 0, 0, 1, 1, 1};\n\tHashSet<String> hash;\n\tString ans;\n\t\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\th = in.nextInt();\n\t\t\tw = in.nextInt();\n\t\t\tif ((h|w) == 0) break;\n\t\t\tmap = new char[h][w];\n\t\t\tvisited = new boolean[h][w];\n\t\t\thash = new HashSet<String>(0);\n\t\t\tans = \"\";\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tString s = in.next();\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tmap[i][j] = s.charAt(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tfor (int k = 0; k < 8; k++) {\n\t\t\t\t\t\tint x = j, y = i;\n\t\t\t\t\t\tString s = map[y][x] + \"\";\n\t\t\t\t\t\tfor (int l = 0; l < visited.length; l++)\n\t\t\t\t\t\t\tArrays.fill(visited[l], false);\n\t\t\t\t\t\tvisited[i][j] = true;\n\t\t\t\t\t\tfor ( ; ; ) {\n\t\t\t\t\t\t\tx = (x + dirx[k] + w) % w;\n\t\t\t\t\t\t\ty = (y + diry[k] + h) % h;\n\t\t\t\t\t\t\ts += map[y][x];\n\t\t\t\t\t\t\tif (!visited[y][x]) {\n\t\t\t\t\t\t\t\tif (hash.contains(s)) {\n\t\t\t\t\t\t\t\t\tif (s.length() > ans.length() || (s.length() == ans.length() && s.compareTo(ans) < 0)) {\n\t\t\t\t\t\t\t\t\t\tans = s.toString();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if (s.length() >= 2 && ans.length() < s.length()){\n\t\t\t\t\t\t\t\t\thash.add(s);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (ans.length() < 2)\n\t\t\t\tSystem.out.println(0);\n\t\t\telse\n\t\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\nclass LengthComparator implements Comparator<String> {\n    public int compare(String a, String b) {\n        if (a.length() == b.length()) {\n            return a.compareTo(b);\n        } else {\n            return b.length() - a.length();\n        }\n    }\n}\n\n\npublic class Main {\n    public static void main(String [] args) {\n        new Main().run();\n    }\n    final int [] dx = {0, 1, 1,  1,  0, -1, -1, -1};\n    final int [] dy = {1, 1, 0, -1, -1, -1,  0,  1};\n    HashSet<String> occurOnce;\n    HashSet<String> occurTwice;\n    void makeString(int y, int x) {\n        for (int i = 0; i < 8; i++) {\n            String cur = String.valueOf(F[y].charAt(x));\n            int ny = (y + dy[i] + H) % H, nx = (x + dx[i] + W) % W;\n            while (ny != y || nx != x) {\n                cur = cur + String.valueOf(F[ny].charAt(nx));\n                if (occurOnce.contains(cur)) {\n                    occurTwice.add(cur);\n                } else {\n                    occurOnce.add(cur);\n                }\n                ny = (ny + dy[i] + H) % H;\n                nx = (nx + dx[i] + W) % W;\n            }\n        }\n    }\n    void debug(Object ... o) {\n        System.out.println(Arrays.deepToString(o));\n    }\n    void run() {\n        while (init()) {\n            ArrayList<String> ans = new ArrayList<String>();\n            for (char c = 'A'; c <= 'Z'; c++) {\n                occurOnce = new HashSet<String>();\n                occurTwice = new HashSet<String>();\n                for (int i = 0; i < H; i++) {\n                    for (int j = 0; j < W; j++) {\n                        if (F[i].charAt(j) == c) makeString(i, j);\n                    }\n                }\n                ArrayList<String> list = new ArrayList<String>();\n                for (Iterator it = occurTwice.iterator(); it.hasNext(); ) {\n                    String spell = (String)it.next();\n                    list.add(spell);\n                }\n                if (list.isEmpty()) continue;\n                Collections.sort(list, new LengthComparator());\n                ans.add(list.get(0));\n            }\n            if (ans.isEmpty()) {\n                System.out.println(0);\n            } else {\n                Collections.sort(ans, new LengthComparator());\n                System.out.println(ans.get(0));\n            }\n        }\n    }\n    Scanner sc;\n    Main() {\n        sc = new Scanner(System.in);\n    }\n    int W, H;\n    String [] F;\n    boolean init() {\n        H = sc.nextInt();\n        W = sc.nextInt();\n        if (H == 0 && W == 0) return false;\n        F = new String[H];\n        for (int i = 0; i < H; i++) {\n            F[i] = sc.next();\n        }\n        return true;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.lang.ArrayIndexOutOfBoundsException;\nimport java.math.BigInteger;\n\n/**\n * @author yoshikyoto\n */\nclass Main{\n\tstatic HashSet<String> set;\n\tstatic int maxLength;\n\tstatic String ans;\n\tstatic char[][] c;\n\tstatic int h, w;\n\tpublic static void main(String[] args) throws Exception{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\twhile(true){\n\t\t\tString[] in = br.readLine().split(\" \");\n\t\t\th = Integer.parseInt(in[0]);\n\t\t\tw = Integer.parseInt(in[1]);\n\t\t\tif(h+w == 0) break;\n\t\t\t\n\t\t\tc = new char[h][w];\n\t\t\tfor(int i = 0; i < h; i++)\n\t\t\t\tc[i] = br.readLine().toCharArray();\n\t\t\t\n\t\t\tset = new HashSet<String>();\n\t\t\tmaxLength = 0;\n\t\t\tans = \"0\";\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\t// i, j から始まる文字列を調べる\n\t\t\t\t\tcheck(i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(maxLength >= 2){\n\t\t\t\tSystem.out.println(ans);\n\t\t\t}else{\n\t\t\t\tSystem.out.println(\"0\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic int[] di = {-1, -1, -1, 0, 0, 1, 1, 1};\n\tstatic int[] dj = {-1, 0, 1, -1, 1, -1, 0, 1};\n\tstatic void check(int i, int j){\n\t\tfor(int k = 0; k < 8; k++){\n\t\t\t// 方向が決定\n\t\t\tboolean[][] visited = new boolean[h][w];\n\t\t\tint ii = i, jj = j;\n\t\t\tString str = \"\";\n\t\t\twhile(!visited[ii][jj]){\n\t\t\t\tstr += \"\" + c[ii][jj];\n\t\t\t\t\n\t\t\t\tif(set.contains(str)){\n\t\t\t\t\t// すでに出現したことがある場合\n\t\t\t\t\tint str_len = str.length();\n\t\t\t\t\tif(maxLength < str_len){\n\t\t\t\t\t\t// 長さの記録更新\n\t\t\t\t\t\tans = str;\n\t\t\t\t\t\tmaxLength = str_len;\n\t\t\t\t\t}else if(maxLength == str_len && str.compareTo(ans) < 0){\n\t\t\t\t\t\t// 長さは同じだけど辞書順で早い場合\n\t\t\t\t\t\tans = str;\n\t\t\t\t\t\tmaxLength = str_len;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tset.add(str);\n\t\t\t\t}\n\t\t\t\tvisited[ii][jj] = true;\n\t\t\t\tii = (ii + di[k] + h) % h;\n\t\t\t\tjj = (jj + dj[k] + w) % w;\n\t\t\t}\n\t\t}\n\t}\n}\n\n// --- ここから下はライブラリ ----------\n/**\n * MyUtil\n * @author yoshikyoto\n */\nclass MyUtil {\n\tpublic static int[] cp(int[] a){\n\t\tint[] b = new int[a.length];\n\t\tfor(int i = 0; i < a.length; i++) b[i] = a[i];\n\t\treturn b;\n\t}\n\tpublic static int toInt(boolean[] a){\n\t\tint pow = 1, ret = 0, l = a.length;\n\t\tfor(int i = 0; i < l; i++){\n\t\t\tif(a[i]) ret += pow;\n\t\t\tpow *= 2;\n\t\t}\n\t\treturn ret;\n\t}\n\tstatic BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static int ins[];\n\tpublic static int[] readIntMap() throws IOException{return parseInt(readLine().split(\" \"));}\n\tpublic static int readIntMap(int i) throws Exception{\n\t\tif(i == 0) ins = readIntMap();\n\t\treturn ins[i];\n\t}\n\tpublic static int[][] readIntMap(int n, int m) throws IOException{\n\t\tint[][] ret = new int[n][];\n\t\tfor(int i = 0; i < n; i++) ret[i] = readIntMap();\n\t\treturn ret;\n\t}\n\tpublic static int[] readIntToMap(int n) throws IOException{\n\t\tint[] ret = new int[n];\n\t\tfor(int i = 0; i < n; i++) ret[i] = readInt();\n\t\treturn ret;\n\t}\n\tpublic static int[] readNoDistIntMap() throws IOException{\n\t\tString[] strs = readLine().split(\"\");\n\t\tint l = strs.length;\n\t\tint[] ret = new int[l-1];\n\t\tfor(int i = 1; i < l; i++)\n\t\t\tret[i-1] = parseInt(strs[i]);\n\t\treturn ret;\n\t}\n\tpublic static String readLine() throws IOException{return br.readLine();}\n\tpublic static int readInt() throws IOException{return Integer.parseInt(br.readLine());}\n\tpublic static int[] parseInt(String[] arr){\n\t\tint[] res = new int[arr.length];\n\t\tfor(int i = 0; i < arr.length; i++)res[i] = Integer.parseInt(arr[i]);\n\t\treturn res;\n\t}\n\tpublic static double[] parseDouble(String[] arr){\n\t\tdouble[] res = new double[arr.length];\n\t\tfor(int i = 0; i < arr.length; i++)res[i] = Double.parseDouble(arr[i]);\n\t\treturn res;\n\t}\n\tpublic static boolean[] parseBool(String[] arr){\n\t\tint[] t = parseInt(arr);\n\t\tboolean[] res = new boolean[t.length];\n\t\tfor(int i = 0; i < t.length; i++){\n\t\t\tif(t[i] == 1){res[i] = true;\n\t\t\t}else{res[i] = false;}\n\t\t}\n\t\treturn res;\n\t}\n\tpublic static int parseInt(Object o){\n\t\treturn Integer.parseInt(o.toString());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport java.awt.geom.*;\nimport java.math.*;\n\npublic class Main {\n\n\tstatic final Scanner in = new Scanner(System.in);\n\tstatic final PrintWriter out = new PrintWriter(System.out,false);\n\tstatic boolean debug = false;\n\n\tstatic int h, w;\n\tstatic char[][] t;\n\n\tstatic int[] dx = { 0, 1, 1, 1, 0,-1,-1,-1};\n\tstatic int[] dy = { 1, 1, 0,-1,-1,-1, 0, 1};\n\n\tstatic int ny(int y, int dir) {\n\t\tint ny = y + dy[dir] + h;\n\t\treturn ny%h;\n\t}\n\n\tstatic int nx(int x, int dir) {\n\t\tint nx = x + dx[dir] + w;\n\t\treturn nx%w;\n\t}\n\n\tstatic String rec(int cy, int cx, int sy, int sx, int dir) {\n\t\tif (cy == sy && cx == sx) return \"\";\n\t\tint ny = ny(cy, dir);\n\t\tint nx = nx(cx, dir);\n\t\treturn t[cy][cx] + rec(ny, nx, sy, sx, dir);\n\t}\n\n\tstatic boolean solve() {\n\t\th = in.nextInt();\n\t\tw = in.nextInt();\n\t\tif (h + w == 0) return false;\n\n\t\tt = new char[h][w];\n\t\tfor (int i=0; i<h; i++) {\n\t\t\tt[i] = in.next().toCharArray();\n\t\t}\n\t\tArrayList<String> list = new ArrayList<>();\n\n\t\tfor (int i=0; i<h; i++) {\n\t\t\tfor (int j=0; j<w; j++) {\n\t\t\t\tfor (int k=0; k<8; k++) {\n\t\t\t\t\tString s = t[i][j] + rec(ny(i, k), nx(j, k), i, j, k);\n\t\t\t\t\tlist.add(s);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tCollections.sort(list);\n\t\tString ans = \"\";\n\t\tint max = 0;\n\t\tfor (int i=0; i<list.size()-1; i++) {\n\t\t\tint n = list.get(i).length();\n\t\t\tint m = list.get(i+1).length();\n\t\t\tint l = Math.min(n, m);\n\t\t\tint x = 0;\n\t\t\tfor (int j=0; j<=l; j++) {\n\t\t\t\tif (j == l || list.get(i).charAt(j) != list.get(i+1).charAt(j)) {\n\t\t\t\t\tx = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (max <= x) {\n\t\t\t\tString s = list.get(i).substring(0, x);\n\t\t\t\tif (max < x || ans.compareTo(s) > 0) {\n\t\t\t\t\tans = s;\n\t\t\t\t}\n\t\t\t\tmax = x;\n\t\t\t}\n\t\t}\n\n\n\t\tif (max < 2) {\n\t\t\tout.println(0);\n\t\t} else {\n\t\t\tout.println(ans);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tdebug = args.length > 0;\n\t\tlong start = System.nanoTime();\n\n\t\twhile(solve());\n\t\tout.flush();\n\n\t\tlong end = System.nanoTime();\n\t\tdump((end - start) / 1000000 + \" ms\");\n\t\tin.close();\n\t\tout.close();\n\t}\n\n\tstatic void dump(Object... o) { if (debug) System.err.println(Arrays.deepToString(o)); }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tif ((h | w) == 0)\n\t\t\t\tbreak;\n\t\t\tchar[][] field = new char[h][w];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tString s = sc.next();\n\t\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\t\tfield[i][j] = s.charAt(j);\n\t\t\t}\n\t\t\tString result = \"\";\n\t\t\tSet<String> set = new HashSet<String>(0);\n\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tString s = \"\";\n\t\t\t\t\tint[] dx = { 1, 1, 0, -1, -1, -1, 0, 1 };\n\t\t\t\t\tint[] dy = { 0, 1, 1, 1, 0, -1, -1, -1 };\n\t\t\t\t\tint px = j;\n\t\t\t\t\tint py = i;\n\t\t\t\t\tfor (int k = 0; k < 8; k++) {\n\t\t\t\t\t\ts = \"\";\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\ts += field[py][px];\n\t\t\t\t\t\t\tpx = (px + dx[k] + w) % w;\n\t\t\t\t\t\t\tpy = (py + dy[k] + h) % h;\n\t\t\t\t\t\t\tif (s.length() >= Math.max(2, result.length())\n\t\t\t\t\t\t\t\t\t&& !set.add(s)\n\t\t\t\t\t\t\t\t\t&& (result.length() < s.length() || (result\n\t\t\t\t\t\t\t\t\t\t\t.length() == s.length() && result\n\t\t\t\t\t\t\t\t\t\t\t.compareTo(s) > 0))) {\n\t\t\t\t\t\t\t\tresult = s;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} while (!(px == j && py == i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tif (result.length() < 2)\n\t\t\t\tSystem.out.println(0);\n\t\t\telse\n\t\t\t\tSystem.out.println(result);\n\t\t}\n\t\tsc.close();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tif ((h | w) == 0)\n\t\t\t\tbreak;\n\t\t\tString[] field = new String[h];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfield[i] = sc.next();\n\t\t\t}\n\t\t\tString result = \"\";\n\t\t\tSet<String> set = new HashSet<String>(0);\n\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tint[] dx = { 1, 1, 0, -1, -1, -1, 0, 1 };\n\t\t\t\t\tint[] dy = { 0, 1, 1, 1, 0, -1, -1, -1 };\n\t\t\t\t\tint px = j;\n\t\t\t\t\tint py = i;\n\t\t\t\t\tfor (int k = 0; k < 8; k++) {\n\t\t\t\t\t\tStringBuilder s = new StringBuilder(\"\");\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\ts.append(field[py].charAt(px));\n\t\t\t\t\t\t\tpx = (px + dx[k] + w) % w;\n\t\t\t\t\t\t\tpy = (py + dy[k] + h) % h;\n\t\t\t\t\t\t\tif (s.length() >= Math.max(2, result.length())\n\t\t\t\t\t\t\t\t\t&& !set.add(s.toString())\n\t\t\t\t\t\t\t\t\t&& (result.length() < s.length() || (result\n\t\t\t\t\t\t\t\t\t\t\t.length() == s.length() && result\n\t\t\t\t\t\t\t\t\t\t\t.compareTo(s.toString()) > 0))) {\n\t\t\t\t\t\t\t\tresult = s.toString();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} while (!(px == j && py == i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tif (result.length() < 2)\n\t\t\t\tSystem.out.println(0);\n\t\t\telse\n\t\t\t\tSystem.out.println(result);\n\t\t}\n\t\tsc.close();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\n\nimport javax.xml.crypto.Data;\n\npublic class Main {\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\tstatic FastScanner sc = new FastScanner();\n\tstatic Scanner stdIn = new Scanner(System.in);\n\tstatic int[] vx = new int[] {0,1,0,-1,1,1,-1,-1};\n\tstatic int[] vy = new int[] {1,0,-1,0,1,-1,1,-1};\n\tpublic static void main(String[] args) {\n\t\t\n\t\twhile(true) {\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tif(h == 0 && w == 0) break;\n\t\t\tint maxLen = 1;\n\t\t\tHashMap<String,Integer> list = new HashMap<String,Integer>();\n\t\t\tArrayList<String> cd = new ArrayList<String>();\n\t\t\t\n\t\t\tchar[][] map = new char[h][];\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tmap[i] = sc.next().toCharArray();\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\t\n\t\t\t\t\tfor(int k = 0; k < 8; k++) {\n\t\t\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\t\t\tint nx = j;\n\t\t\t\t\t\tint ny = i;\n\t\t\t\t\t\twhile(true) {\n\t\t\t\t\t\t\tsb.append(map[ny][nx]);\n\t\t\t\t\t\t\tnx += vx[k];\n\t\t\t\t\t\t\tny += vy[k];\n\t\t\t\t\t\t\tif(nx < 0) nx = w-1;\n\t\t\t\t\t\t\tif(nx >= w) nx = 0;\n\t\t\t\t\t\t\tif(ny < 0) ny = h-1;\n\t\t\t\t\t\t\tif(ny >= h) ny = 0;\n\t\t\t\t\t\t\tif(nx == j && ny == i) break;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\n\t\t\t\t\t\tfor(int l = maxLen+1; l <= sb.length(); l++) {\n\t\t\t\t\t\t\tString tmp = sb.substring(0, l).toString();\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(list.containsKey(tmp)) {\n\t\t\t\t\t\t\t\tif(list.get(tmp) == 1) {\n\t\t\t\t\t\t\t\t\tlist.put(tmp, -1);\n\t\t\t\t\t\t\t\t\tcd.add(tmp);\n\t\t\t\t\t\t\t\t\tmaxLen = Math.max(maxLen, tmp.length());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tlist.put(tmp, 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tCollections.sort(cd,new MyComp());\n\t\t\tString ans = \"0\";\n\t\t\tif(!cd.isEmpty()) {\n\t\t\t\tans = cd.get(0);\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t}\n\t\tout.flush();\n\t}\n}\n\nclass MyComp implements Comparator<String> {\n\n\t@Override\n\tpublic int compare(String o1, String o2) {\n\t\tif(o1.length() < o2.length()) {\n\t\t\treturn 1;\n\t\t}\n\t\telse if(o1.length() > o2.length()) {\n\t\t\treturn -1;\n\t\t}\n\t\treturn o1.compareTo(o2);\n\t}\n\t\n}\n\n//-----------------Template------------------//\nclass FastScanner {\n\tprivate final InputStream in = System.in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t}else{\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprivate int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n\tprivate static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\tprivate void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n\tpublic boolean hasNext() { skipUnprintable(); return hasNextByte();}\n\tpublic String next() {\n\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong() {\n\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile(true){\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t}else if(b == -1 || !isPrintableChar(b)){\n\t\t\t\treturn minus ? -n : n;\n\t\t\t}else{\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t \n\tpublic int nextInt() {\n\t\t if (!hasNext()) throw new NoSuchElementException();\n\t\t int n = 0;\n\t\t boolean minus = false;\n\t\t int b = readByte();\n\t\t if (b == '-') {\n\t\t\t minus = true;\n\t\t\t b = readByte();\n\t\t }\n\t\t if (b < '0' || '9' < b) {\n\t\t\t throw new NumberFormatException();\n\t\t }\n\t\t while(true){\n\t\t\t if ('0' <= b && b <= '9') {\n\t\t\t\t n *= 10;\n\t\t\t\t n += b - '0';\n\t\t\t }else if(b == -1 || !isPrintableChar(b)){\n\t\t\t\t return minus ? -n : n;\n\t\t\t }else{\n\t\t\t\t throw new NumberFormatException();\n\t\t\t }\n\t\t\t b = readByte();\n\t\t }\n\t}\n\t \n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n\t \n \n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    int h, w;\n    int[] dx = {0, 0, 1, -1, 1, 1, -1, -1};\n    int[] dy = {1, -1, 0, 0, 1, -1, 1, -1};\n    char[][] donut;\n    String cutS;\n\n    @SuppressWarnings(\"unchecked\")\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        while(true){\n            h = sc.nextInt();\n            w = sc.nextInt();\n            if(h==0 && w==0) break;\n\n            donut = new char[h][w];\n            for(int i=0; i<h; i++){\n                String line = sc.next();\n                donut[i] = line.toCharArray();\n            }\n\n            int max = 0;\n            String minString = \"0\";\n\n            for(int l=h*w-1; l>=2; l--){\n                ArrayList<String> list = new ArrayList<String>();\n                for(int i=0; i<h; i++){\n                    for(int j=0; j<w; j++){\n                        for(int k=0; k<8; k++){                        \n                            String s = \"\";\n                            s += donut[i][j];\n                            int ny = (i + dy[k]) % h, nx = (j + dx[k]) % w;\n                            if(ny==-1) ny = h-1;\n                            if(nx==-1) nx = w-1;\n                            while(!(ny==i && nx==j)){\n                                if(s.length()==l) break;\n                                s += donut[ny][nx];\n                                ny = (ny + dy[k]) % h;\n                                nx = (nx + dx[k]) % w;\n                                if(ny==-1) ny = h-1;\n                                if(nx==-1) nx = w-1;\n                            }\n                            if(s.length()!=l) continue;\n                            \n                            if(!list.contains(s)) list.add(s);\n                            else if(minString.equals(\"0\") || min(s, minString)){\n                                max = s.length();\n                                minString = s;\n                            }\n                        }\n                    }\n                }\n                if(max!=0) break;\n            }\n\n            System.out.println(minString);\n        }\n    }\n\n    boolean min(String s1, String s2){ //s1 < s2?\n        int l1 = s1.length(), l2 = s2.length();\n        for(int i=0; i<Math.min(l1, l2); i++){\n            if(s1.charAt(i)<s2.charAt(i)) return true;\n            else if(s1.charAt(i)>s2.charAt(i)) return false;\n        }\n        if(l1<l2) return true;\n        return false;\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tint h, w;\n\tchar[][] map;\n\tboolean[][] visited;\n\tint[] dirx = {-1, 0, 1, -1, 1, -1, 0, 1};\n\tint[] diry = {-1, -1, -1, 0, 0, 1, 1, 1};\n\tHashSet<String> hash = new HashSet<String>();\n\tString ans;\n\t\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\th = in.nextInt();\n\t\t\tw = in.nextInt();\n\t\t\tif ((h|w) == 0) break;\n\t\t\tmap = new char[h][w];\n\t\t\tvisited = new boolean[h][w];\n\t\t\thash.clear();\n\t\t\tans = \"\";\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tString s = in.next();\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tmap[i][j] = s.charAt(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tfor (int k = 0; k < 8; k++) {\n\t\t\t\t\t\tint x = j, y = i;\n\t\t\t\t\t\tString s = map[y][x] + \"\";\n\t\t\t\t\t\tfor (int l = 0; l < visited.length; l++)\n\t\t\t\t\t\t\tArrays.fill(visited[l], false);\n\t\t\t\t\t\tvisited[i][j] = true;\n\t\t\t\t\t\tfor ( ; ; ) {\n\t\t\t\t\t\t\tx = (x + dirx[k] + w) % w;\n\t\t\t\t\t\t\ty = (y + diry[k] + h) % h;\n\t\t\t\t\t\t\ts += map[y][x];\n\t\t\t\t\t\t\tif (!visited[y][x]) {\n\t\t\t\t\t\t\t\tif (hash.contains(s)) {\n\t\t\t\t\t\t\t\t\tif (s.length() > ans.length() || (s.length() == ans.length() && s.compareTo(ans) < 0)) {\n\t\t\t\t\t\t\t\t\t\tans = s.toString();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\thash.add(s);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (ans.length() < 2)\n\t\t\t\tSystem.out.println(0);\n\t\t\telse\n\t\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\nclass LengthComparator implements Comparator<String> {\n    public int compare(String a, String b) {\n        if (a.length() == b.length()) {\n            return a.compareTo(b);\n        } else {\n            return b.length() - a.length();\n        }\n    }\n}\n\npublic class Main {\n    public static void main(String [] args) {\n        new Main().run();\n    }\n    final int [] dx = {0, 1, 1,  1,  0, -1, -1, -1};\n    final int [] dy = {1, 1, 0, -1, -1, -1,  0,  1};\n    HashSet<String> occurOnce;\n    HashSet<String> occurTwice;\n    void makeString(int y, int x) {\n        for (int i = 0; i < 8; i++) {\n            String cur = String.valueOf(F[y].charAt(x));\n            int ny = (y + dy[i] + H) % H, nx = (x + dx[i] + W) % W;\n            while (ny != y || nx != x) {\n                cur = cur + String.valueOf(F[ny].charAt(nx));\n                if (occurOnce.contains(cur)) {\n                    occurTwice.add(cur);\n                } else {\n                    occurOnce.add(cur);\n                }\n                ny = (ny + dy[i] + H) % H;\n                nx = (nx + dx[i] + W) % W;\n            }\n        }\n    }\n    void debug(Object ... o) {\n        System.out.println(Arrays.deepToString(o));\n    }\n    void run() {\n        while (init()) {\n            ArrayList<String> ans = new ArrayList<String>();\n            occurOnce = new HashSet<String>();\n            occurTwice = new HashSet<String>();\n            for (char c = 'A'; c <= 'Z'; c++) {\n                occurOnce.clear();\n                occurTwice.clear();\n                for (int i = 0; i < H; i++) {\n                    for (int j = 0; j < W; j++) {\n                        if (F[i].charAt(j) == c) makeString(i, j);\n                    }\n                }\n                if (occurTwice.isEmpty()) continue;\n                ans.add(Collections.min(occurTwice, new LengthComparator()));\n            }\n            if (ans.isEmpty()) {\n                System.out.println(0);\n            } else {\n                System.out.println(Collections.min(ans, new LengthComparator()));\n            }\n        }\n    }\n    Scanner sc;\n    Main() {\n        sc = new Scanner(System.in);\n    }\n    int W, H;\n    String [] F;\n    boolean init() {\n        H = sc.nextInt();\n        W = sc.nextInt();\n        if (H == 0 && W == 0) return false;\n        F = new String[H];\n        for (int i = 0; i < H; i++) {\n            F[i] = sc.next();\n        }\n        return true;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tint h, w;\n\tchar[][] map;\n\tboolean[][] visited;\n\tint[] dirx = {-1, 0, 1, -1, 1, -1, 0, 1};\n\tint[] diry = {-1, -1, -1, 0, 0, 1, 1, 1};\n\tHashSet<String> hash;\n\tString ans;\n\t\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\th = in.nextInt();\n\t\t\tw = in.nextInt();\n\t\t\tif ((h|w) == 0) break;\n\t\t\tmap = new char[h][w];\n\t\t\tvisited = new boolean[h][w];\n\t\t\thash = new HashSet<String>();\n\t\t\tans = \"\";\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tString s = in.next();\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tmap[i][j] = s.charAt(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tfor (int k = 0; k < 8; k++) {\n\t\t\t\t\t\tint x = j, y = i;\n\t\t\t\t\t\tString s = map[y][x] + \"\";\n\t\t\t\t\t\tfor (int l = 0; l < visited.length; l++)\n\t\t\t\t\t\t\tArrays.fill(visited[l], false);\n\t\t\t\t\t\tvisited[i][j] = true;\n\t\t\t\t\t\tfor ( ; ; ) {\n\t\t\t\t\t\t\tx = (x + dirx[k] + w) % w;\n\t\t\t\t\t\t\ty = (y + diry[k] + h) % h;\n\t\t\t\t\t\t\ts += map[y][x];\n\t\t\t\t\t\t\tif (!visited[y][x]) {\n\t\t\t\t\t\t\t\tif (hash.contains(s)) {\n\t\t\t\t\t\t\t\t\tif (s.length() > ans.length() || (s.length() == ans.length() && s.compareTo(ans) < 0)) {\n\t\t\t\t\t\t\t\t\t\tans = s.toString();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if (ans.length() < s.length()){\n\t\t\t\t\t\t\t\t\thash.add(s);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (ans.length() < 2)\n\t\t\t\tSystem.out.println(0);\n\t\t\telse\n\t\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tint h, w;\n\tchar[][] map;\n\tboolean[][] visited;\n\tint[] dirx = {-1, 0, 1, -1, 1, -1, 0, 1};\n\tint[] diry = {-1, -1, -1, 0, 0, 1, 1, 1};\n\tHashSet<String> hash;\n\tString ans;\n\tint x, y;\n\t\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\th = in.nextInt();\n\t\t\tw = in.nextInt();\n\t\t\tif ((h|w) == 0) break;\n\t\t\tmap = new char[h][w];\n\t\t\thash = new HashSet<String>(0);\n\t\t\tans = \"\";\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tString s = in.next();\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tmap[i][j] = s.charAt(j);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tfor (int k = 0; k < 8; k++) {\n\t\t\t\t\t\tx = j; y = i;\n\t\t\t\t\t\tStringBuilder sb = new StringBuilder(map[y][x]);\n\t\t\t\t\t\tfor ( ; ; ) {\n\t\t\t\t\t\t\tx = (x + dirx[k] + w) % w;\n\t\t\t\t\t\t\ty = (y + diry[k] + h) % h;\n\t\t\t\t\t\t\tsb.append(map[y][x]);\n\t\t\t\t\t\t\tif (hash.contains(sb.toString())) {\n\t\t\t\t\t\t\t\tif (sb.length() > ans.length() || (sb.length() == ans.length() && ans.compareTo(sb.toString()) > 0)) {\n\t\t\t\t\t\t\t\t\tans = sb.toString();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (sb.toString().length() >= Math.max(2, ans.length())) {\n\t\t\t\t\t\t\t\thash.add(sb.toString());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (x == j && y == i) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (ans.length() < 2)\n\t\t\t\tSystem.out.println(0);\n\t\t\telse\n\t\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\n\nimport javax.xml.crypto.Data;\n\npublic class Main {\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\tstatic FastScanner sc = new FastScanner();\n\tstatic Scanner stdIn = new Scanner(System.in);\n\tstatic int[] vx = new int[] {0,1,0,-1,1,1,-1,-1};\n\tstatic int[] vy = new int[] {1,0,-1,0,1,-1,1,-1};\n\tpublic static void main(String[] args) {\n\t\t\n\t\twhile(true) {\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tif(h == 0 && w == 0) break;\n\t\t\tint maxLen = 2;\n\t\t\tHashMap<String,Integer> list = new HashMap<String,Integer>();\n\t\t\tArrayList<String> cd = new ArrayList<String>();\n\t\t\t\n\t\t\tchar[][] map = new char[h][];\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tmap[i] = sc.next().toCharArray();\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\t\n\t\t\t\t\tfor(int k = 0; k < 8; k++) {\n\t\t\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\t\t\tint nx = j;\n\t\t\t\t\t\tint ny = i;\n\t\t\t\t\t\twhile(true) {\n\t\t\t\t\t\t\tsb.append(map[ny][nx]);\n\t\t\t\t\t\t\tnx += vx[k];\n\t\t\t\t\t\t\tny += vy[k];\n\t\t\t\t\t\t\tif(nx < 0) nx = w-1;\n\t\t\t\t\t\t\tif(nx >= w) nx = 0;\n\t\t\t\t\t\t\tif(ny < 0) ny = h-1;\n\t\t\t\t\t\t\tif(ny >= h) ny = 0;\n\t\t\t\t\t\t\tif(nx == j && ny == i) break;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\n\t\t\t\t\t\tfor(int l = maxLen; l <= sb.length(); l++) {\n\t\t\t\t\t\t\tString tmp = sb.substring(0, l).toString();\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(list.containsKey(tmp)) {\n\t\t\t\t\t\t\t\tif(list.get(tmp) == 1) {\n\t\t\t\t\t\t\t\t\tlist.put(tmp, -1);\n\t\t\t\t\t\t\t\t\tcd.add(tmp);\n\t\t\t\t\t\t\t\t\tmaxLen = Math.max(maxLen, tmp.length());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tlist.put(tmp, 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tCollections.sort(cd,new MyComp());\n\t\t\tString ans = \"0\";\n\t\t\tif(!cd.isEmpty()) {\n\t\t\t\tans = cd.get(0);\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t}\n\t\tout.flush();\n\t}\n}\n\nclass MyComp implements Comparator<String> {\n\n\t@Override\n\tpublic int compare(String o1, String o2) {\n\t\tif(o1.length() < o2.length()) {\n\t\t\treturn 1;\n\t\t}\n\t\telse if(o1.length() > o2.length()) {\n\t\t\treturn -1;\n\t\t}\n\t\treturn o1.compareTo(o2);\n\t}\n\t\n}\n\n//-----------------Template------------------//\nclass FastScanner {\n\tprivate final InputStream in = System.in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t}else{\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprivate int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n\tprivate static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\tprivate void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n\tpublic boolean hasNext() { skipUnprintable(); return hasNextByte();}\n\tpublic String next() {\n\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong() {\n\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile(true){\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t}else if(b == -1 || !isPrintableChar(b)){\n\t\t\t\treturn minus ? -n : n;\n\t\t\t}else{\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t \n\tpublic int nextInt() {\n\t\t if (!hasNext()) throw new NoSuchElementException();\n\t\t int n = 0;\n\t\t boolean minus = false;\n\t\t int b = readByte();\n\t\t if (b == '-') {\n\t\t\t minus = true;\n\t\t\t b = readByte();\n\t\t }\n\t\t if (b < '0' || '9' < b) {\n\t\t\t throw new NumberFormatException();\n\t\t }\n\t\t while(true){\n\t\t\t if ('0' <= b && b <= '9') {\n\t\t\t\t n *= 10;\n\t\t\t\t n += b - '0';\n\t\t\t }else if(b == -1 || !isPrintableChar(b)){\n\t\t\t\t return minus ? -n : n;\n\t\t\t }else{\n\t\t\t\t throw new NumberFormatException();\n\t\t\t }\n\t\t\t b = readByte();\n\t\t }\n\t}\n\t \n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n\t \n \n}"
  },
  {
    "language": "JavaScript",
    "code": "var input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar arr=input.trim().split(\"\\n\");\nwhile(true){\n   var hw=arr.shift();\n   if(hw==\"0 0\")break;\n   hw=hw.split(\" \").map(Number);\n   var h=hw[0];\n   var w=hw[1];\n   var yx=[];\n   for(var i=0;i<h;i++)yx.push(arr.shift().split(\"\"));\n   var ary=[];\n   for(var i=0;i<h;i++)ary.push(yx[i].join(\"\"));\n   for(var i=0;i<w;i++){\n      var str=\"\";\n      for(var j=0;j<h;j++)str+=yx[j][i];\n      ary.push(str);\n   }\n   var H=[];\n   for(var i=0;i<h;i++)H.push(i);\n   while(H.length!=0){\n      var v=H.shift();\n      //---------------------------------------------\n      var str=yx[v][0];\n      var j=v;\n      var x=0;\n      while(true){\n         j++;\n         x++;\n         if(j==h)j=0;\n         if(x==w)x=0;\n         if(x==0)H=H.filter(function(value){return (j!=value);});\n         if(j==v && x==0)break;\n         str+=yx[j][x];\n      }\n      ary.push(str);\n      //---------------------------------------------\n      var str=yx[v][0];\n      var j=v;\n      var x=0;\n      while(true){\n         j--;\n         x++;\n         if(j<0)j=h-1;\n         if(x==w)x=0;\n         if(j==v && x==0)break;\n         str+=yx[j][x];\n      }\n      ary.push(str);\n      //---------------------------------------------\n   }\n   var obj={};\n   ary.forEach(function(v){\n      var len=v.length;\n      var vA=v;\n      var vB=v.split(\"\").reverse().join(\"\");\n      vA=vA+vA;\n      vB=vB+vB;\n      for(var i=0;i<len;i++){\n         var strA=vA.slice(i,len+i);\n         var strB=vB.slice(i,len+i);\n         while(strA.length!=1){\n            if(obj.hasOwnProperty(strA))obj[strA]++;\n            else obj[strA]=1;\n            strA=strA.slice(0,-1);\n         }\n         while(strB.length!=1){\n            if(obj.hasOwnProperty(strB))obj[strB]++;\n            else obj[strB]=1;\n            strB=strB.slice(0,-1);\n         }\n      }\n   });\n   var max=0;\n   var ans=[0];\n   for(var k in obj){\n      if(obj[k]>=2 && max==k.length)ans.push(k);\n      else if(obj[k]>=2 && max<k.length){\n         ans=[k];\n         max=k.length;\n      }\n   }\n   ans.sort();\n   console.log(ans[0]);\n}"
  },
  {
    "language": "JavaScript",
    "code": "var input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar arr=input.trim().split(\"\\n\");\nwhile(true){\n   var hw=arr.shift();\n   if(hw==\"0 0\")break;\n   hw=hw.split(\" \").map(Number);\n   var h=hw[0];\n   var w=hw[1];\n   var yx=[];\n   for(var i=0;i<h;i++)yx.push(arr.shift().split(\"\"));\n   var ary=[];\n   for(var i=0;i<h;i++)ary.push(yx[i].join(\"\"));\n   for(var i=0;i<w;i++){\n      var str=\"\";\n      for(var j=0;j<h;j++)str+=yx[j][i];\n      ary.push(str);\n   }\n   var H=[];\n   for(var i=0;i<h;i++)H.push(i);\n   while(H.length!=0){\n      var v=H.shift();\n      //---------------------------------------------\n      var str=yx[v][0];\n      var j=v;\n      var x=0;\n      while(true){\n         j++;\n         x++;\n         if(j==h)j=0;\n         if(x==w)x=0;\n         if(x==0)H=H.filter(function(value){return (j!=value);});\n         if(j==v && x==0)break;\n         str+=yx[j][x];\n      }\n      ary.push(str);\n      //---------------------------------------------\n      var str=yx[v][0];\n      var j=v;\n      var x=0;\n      while(true){\n         j--;\n         x++;\n         if(j<0)j=h-1;\n         if(x==w)x=0;\n         if(j==v && x==0)break;\n         str+=yx[j][x];\n      }\n      ary.push(str);\n      //---------------------------------------------\n   }\n   var obj={};\n   ary.forEach(function(v){\n      var len=v.length;\n      var vA=v;\n      var vB=v.split(\"\").reverse().join(\"\");\n      vA=vA+vA;\n      vB=vB+vB;\n      for(var i=0;i<len;i++){\n         var strA=vA.slice(i,len+i);\n         var strB=vB.slice(i,len+i);\n         while(strA.length!=1){\n            if(obj.hasOwnProperty(strA))obj[strA]++;\n            else obj[strA]=1;\n            strA=strA.slice(0,-1);\n         }\n         while(strB.length!=1){\n            if(obj.hasOwnProperty(strB))obj[strB]++;\n            else obj[strB]=1;\n            strB=strB.slice(0,-1);\n         }\n      }\n   });\n   var max=0;\n   var ans=\"0\";\n   for(var k in obj){\n      if(obj[k]>=2 && max<k.length){max=k.length;ans=k;}\n   }\n   console.log(ans);\n}"
  },
  {
    "language": "JavaScript",
    "code": "var input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar arr=input.trim().split(\"\\n\");\nwhile(true){\n   var hw=arr.shift();\n   if(hw==\"0 0\")break;\n   hw=hw.split(\" \").map(Number);\n   var h=hw[0];\n   var w=hw[1];\n   var yx=[];\n   for(var i=0;i<h;i++)yx.push(arr.shift().split(\"\"));\n   var ary=[];\n   for(var i=0;i<h;i++)ary.push(yx[i].join(\"\"));\n   for(var i=0;i<w;i++){\n      var str=\"\";\n      for(var j=0;j<h;j++)str+=yx[j][i];\n      ary.push(str);\n   }\n   var H=[];\n   for(var i=0;i<h;i++)H.push(i);\n   while(H.length!=0){\n      var v=H.shift();\n      var str=yx[v][0];\n      var j=v;\n      var x=0;\n      while(true){\n         j++;\n         x++;\n         if(j==h)j=0;\n         if(x==w)x=0;\n         if(j==v)H=H.filter(function(value){return (x==value);});\n         if(j==v && x==0)break;\n         str+=yx[j][x];\n      }\n      ary.push(str);\n      //---------------------------------------------\n      var str=yx[v][0];\n      var j=v;\n      var x=0;\n      while(true){\n         j--;\n         x++;\n         if(j<0)j=h-1;\n         if(x==w)x=0;\n         if(j==v && x==0)break;\n         str+=yx[j][x];\n      }\n      ary.push(str);\n   }\n   var obj={};\n   ary.forEach(function(v){\n      var len=v.length;\n      var vA=v;\n      var vB=v.split(\"\").reverse().join(\"\");\n      vA=vA+vA;\n      vB=vB+vB;\n      for(var i=0;i<len;i++){\n         var strA=vA.slice(i,len+i);\n         var strB=vB.slice(i,len+i);\n         while(strA.length!=1){\n            if(obj.hasOwnProperty(strA))obj[strA]++;\n            else obj[strA]=1;\n            strA=strA.slice(0,-1);\n         }\n         while(strB.length!=1){\n            if(obj.hasOwnProperty(strB))obj[strB]++;\n            else obj[strB]=1;\n            strB=strB.slice(0,-1);\n         }\n      }\n   });\n   var max=0;\n   var ans=\"0\";\n   for(var k in obj){\n      if(obj[k]>=2 && max<k.length){max=k.length;ans=k;}\n   }\n   console.log(ans);\n}"
  },
  {
    "language": "Ruby",
    "code": "loop do\n    h, w = gets.split.map(&:to_i)\n    break if h == 0 && w == 0\n    s = h.times.map{gets.chomp}\n    hash = Hash.new(0)\n    h.times do |i|\n        w.times do |j|\n            #up\n            ni = i\n            nj = j\n            str = s[ni][nj]\n            ni -= 1\n            ni = h - 1 if ni == -1\n            while true\n                str += s[ni][nj]\n                hash[str] += 1\n                ni -= 1\n                ni = h - 1 if ni == -1\n                break if ni == i\n            end\n            #ne\n            ni = i\n            nj = j\n            str = s[ni][nj]\n            ni -= 1\n            ni = h - 1 if ni == -1\n            nj += 1\n            nj = 0 if nj == w\n            while true\n                str += s[ni][nj]\n                hash[str] += 1\n                ni -= 1\n                ni = h - 1 if ni == -1\n                nj += 1\n                nj = 0 if nj == w\n                break if nj == j && ni == i\n            end\n            #right\n            ni = i\n            nj = j\n            str = s[ni][nj]\n            nj += 1\n            nj = 0 if nj == w\n            while true\n                str += s[ni][nj]\n                hash[str] += 1\n                nj += 1\n                nj = 0 if nj == w\n                break if nj == j\n            end\n            #se\n            ni = i\n            nj = j\n            str = s[ni][nj]\n            ni += 1\n            ni = 0 if ni == h\n            nj += 1\n            nj = 0 if nj == w\n            while true\n                str += s[ni][nj]\n                hash[str] += 1\n                ni += 1\n                ni = 0 if ni == h\n                nj += 1\n                nj = 0 if nj == w\n                break if nj == j && ni == i\n            end\n            #down\n            ni = i\n            nj = j\n            str = s[ni][nj]\n            ni += 1\n            ni = 0 if ni == h\n            while true\n                str += s[ni][nj]\n                hash[str] += 1\n                ni += 1\n                ni = 0 if ni == h\n                break if ni == i\n            end\n            #sw\n            ni = i\n            nj = j\n            str = s[ni][nj]\n            ni += 1\n            ni = 0 if ni == h\n            nj -= 1\n            nj = w - 1 if nj == -1\n            while true\n                str += s[ni][nj]\n                hash[str] += 1\n                ni += 1\n                ni = 0 if ni == h\n                nj -= 1\n                nj = w - 1 if nj == -1\n                break if nj == j && ni == i\n            end\n            #left\n            ni = i\n            nj = j\n            str = s[ni][nj]\n            nj -= 1\n            nj = w - 1 if nj == -1\n            while true\n                str += s[ni][nj]\n                hash[str] += 1\n                nj -= 1\n                nj = w - 1 if nj == -1\n                break if nj == j\n            end\n            #nw\n            ni = i\n            nj = j\n            str = s[ni][nj]\n            ni -= 1\n            ni = h - 1 if ni == -1\n            nj -= 1\n            nj = w - 1 if nj == -1\n            while true\n                str += s[ni][nj]\n                hash[str] += 1\n                ni -= 1\n                ni = h - 1 if ni == -1\n                nj -= 1\n                nj = w - 1 if nj == -1\n                break if nj == j && ni == i\n            end\n        end\n    end\n    ans = hash.select{|k,v| v > 1}\n    if ans.empty?\n        puts \"0\"\n    else\n        ans = ans.sort_by{|k,v| -k.length}\n        max = ans[0][0].length\n        ans.select!{|k,v| k.length == max}\n        puts ans.sort_by{|k,v| k}[0][0]\n    end\nend"
  },
  {
    "language": "Ruby",
    "code": "while (h, w = gets.split.map(&:to_i)).inject(:+) != 0 do\n  donut = Array.new\n  count = Hash.new(0)\n  h.times do\n    donut.push(gets.chomp.chars)\n  end\n  h.times do |y|\n    w.times do |x|\n      dy = [0, 1, 1, 1, 0, -1, -1, -1]\n      dx = [1, 1, 0, -1, -1, -1, 0, 1]\n      8.times do |i|\n        used = Array.new(h){Array.new(w,false)}\n        string = donut[y][x]\n        used[y][x] = true\n        ny = (y + dy[i]) % h\n        nx = (x + dx[i]) % w\n        while !used[ny][nx] do\n          string += donut[ny][nx]\n          count[string] += 1\n          used[ny][nx] = true\n          ny = (ny + dy[i]) % h\n          nx = (nx + dx[i]) % w\n        end\n      end\n    end\n  end\n  spell = count.select{|key, value| value >= 2}.keys.sort{|v1, v2| v1.size <=> v2.size}\n  spell.select!{|v| v.size == spell.last.size}\n  puts spell.size >= 1 ? spell.sort.first : 0\nend"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nDXYS = [\n  [ 1,  0], [ 1, -1], [ 0, -1], [-1, -1],\n  [-1,  0], [-1,  1], [ 0,  1], [ 1,  1]\n]\n\n### main\n\nloop do\n  h, w = gets.split.map(&:to_i)\n  break if (h | w) == 0\n\n  dnts = h.times.map{gets.strip}\n  #p dnts\n\n  maxlen = 0\n  spells = []\n\n  for y0 in (0...h)\n    for x0 in (0...w)\n      DXYS.each do |dx, dy|\n        x = x0\n        y = y0\n        str = dnts[y][x]\n        len = 1\n        loop do\n          x = (x + dx) % w\n          y = (y + dy) % h\n          break if x == x0 && y == y0\n\n          str += dnts[y][x]\n          len += 1\n\n          spells[len] = {} if spells[len].nil?\n          if spells[len][str].nil?\n            spells[len][str] = 0\n          else\n            spells[len][str] = 1\n            maxlen = len if maxlen < len\n          end\n        end\n      end\n    end\n  end\n  #p maxlen\n  #p spells\n\n  if maxlen == 0\n    puts 0\n  else\n    puts spells[maxlen].select{|k, v| v > 0}.keys.min\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "while (h, w = gets.split.map(&:to_i)).inject(:+) != 0 do\n  donut = Array.new\n  count = Hash.new(0)\n  h.times do\n    donut.push(gets.chomp.chars)\n  end\n  h.times do |y|\n    w.times do |x|\n      dy = [0, 1, 1, 1, 0, -1, -1, -1]\n      dx = [1, 1, 0, -1, -1, -1, 0, 1]\n      8.times do |i|\n        used = Array.new(h){Array.new(w,false)}\n        string = donut[y][x]\n        used[y][x] = true\n        ny = (y + dy[i]) % h\n        nx = (x + dx[i]) % w\n        while !used[ny][nx] do\n          string += donut[ny][nx]\n          count[string] += 1\n          used[ny][nx] = true\n          ny = (ny + dy[i]) % h\n          nx = (nx + dx[i]) % w\n        end\n      end\n    end\n  end\n  spell = count.select{|key, value| value >= 2}.keys.sort{|v1, v2| v1.size <=> v2.size}\n  spell.select!{|v| v.size == spell.last.size}\n  puts spell.size >= 1 ? spell.sort.last : 0\nend"
  },
  {
    "language": "Ruby",
    "code": "class DictNode\n\tdef initialize(parent = nil, character = nil)\n\t\t@length = (parent ? parent.length + 1 : 0)\n\t\t@parent = parent\n\t\t@character = character\n\t\t@children = {}\n\tend\n\n\tdef child(c)\n\t\t@children[c]\n\tend\n\n\tdef add_child(c)\n\t\t@children[c] = self.class.new(self, c)\n\tend\n\n\tdef to_s\n\t\treturn \"\" if !@parent\n\t\t@parent.to_s + @character\n\tend\n\n\tattr_reader :length\nend\n\nloop do\n\th, w = gets.split.map(&:to_i)\n\tbreak if w == 0\n\tdonut = (1..h).map { gets.chomp.split(\"\") }\n\tdict = DictNode.new\n\tspell = ''\n\tlen = 0\n\n\t(0..h-1).each do |i0|\n\t\t(0..w-1).each do |j0|\n\t\t\t[-1, 0, 1].repeated_permutation(2) do |di, dj|\n\t\t\t\tnext if di == dj && di == 0\n\t\t\t\tu = dict\n\t\t\t\ti, j = i0, j0\n\t\t\t\tloop do\n\t\t\t\t\tc = donut[i][j]\n\t\t\t\t\tif v = u.child(c)\n\t\t\t\t\t\tif v.length > len\n\t\t\t\t\t\t\tspell = v.to_s\n\t\t\t\t\t\t\tlen = v.length\n\t\t\t\t\t\telsif v.length == len\n\t\t\t\t\t\t\ts = v.to_s\n\t\t\t\t\t\t\tif s < spell\n\t\t\t\t\t\t\t\tspell = s\n\t\t\t\t\t\t\t\tlen = v.length\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tend\n\t\t\t\t\telse\n\t\t\t\t\t\tu.add_child(c)\n\t\t\t\t\tend\n\t\t\t\t\tu = u.child(c)\n\t\t\t\t\ti = (i + di) % h\n\t\t\t\t\tj = (j + dj) % w\n\t\t\t\t\tbreak if i == i0 && j == j0\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\tputs spell.size > 1 ? spell : 0\nend"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\nvar H, W int\n\ntype point struct {\n\tx, y int\n}\n\nfunc (p *point) add(q point) {\n\tp.x += q.x\n\tp.y += q.y\n\tif p.x < 0 {\n\t\tp.x += H\n\t}\n\tif p.y < 0 {\n\t\tp.y += W\n\t}\n\tp.x %= H\n\tp.y %= W\n}\n\nfunc isPalindrome(str string) bool {\n\tfor i, j := 0, len(str)-1; i < j; i, j = i+1, j-1 {\n\t\tif str[i] != str[j] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc magicSpel(arr []string) string {\n\tvar ans string\n\tm := map[string]int{}\n\tfor i := range arr {\n\t\tfor j := range arr[i] {\n\t\t\tfor _, d := range []point{{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}} {\n\t\t\t\tcur := point{x: i, y: j}\n\t\t\t\tstr := string(arr[cur.x][cur.y])\n\t\t\t\tcur.add(d)\n\t\t\t\tfor i != cur.x || j != cur.y {\n\t\t\t\t\tstr += string(arr[cur.x][cur.y])\n\t\t\t\t\tcur.add(d)\n\t\t\t\t\tif isPalindrome(str) {\n\t\t\t\t\t\tm[str] += 2\n\t\t\t\t\t} else {\n\t\t\t\t\t\tm[str]++\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor s, v := range m {\n\t\tif 1 < v {\n\t\t\tif len(ans) < len(s) {\n\t\t\t\tans = s\n\t\t\t} else if len(ans) == len(s) && s < ans {\n\t\t\t\tans = s\n\t\t\t}\n\t\t}\n\t}\n\n\tif len(ans) == 0 {\n\t\treturn \"0\"\n\t}\n\n\treturn ans\n}\n\nfunc main() {\n\tfor {\n\t\tfmt.Scan(&H, &W)\n\t\tif H == 0 && W == 0 {\n\t\t\tbreak\n\t\t}\n\n\t\tvar arr []string\n\n\t\tfor i := 0; i < H; i++ {\n\t\t\tvar s string\n\t\t\tfmt.Scan(&s)\n\t\t\tarr = append(arr, s)\n\t\t}\n\n\t\tfmt.Println(magicSpel(arr))\n\t}\n}\n\n// 2 3\n// ABC\n// DEF\n\n\n"
  },
  {
    "language": "Python",
    "code": "\ndef gcd_recursive(a, b):\n    if b == 0:\n        return a\n    else:\n        return gcd_recursive(b, a % b)\n\n\ndef modulo(x, base):\n    return (x % base + base) % base\n\n\nclass Donut:\n    def __init__(self, letters):\n        self.letters = letters\n        self.lengths = [len(letters), len(letters[0])]\n\n        max_diag = self.lengths[0] * self.lengths[1]\n        max_i = self.lengths[0]\n        max_j = self.lengths[1]\n        self.directions = [\n            [-1, -1, max_diag],\n            [-1, 0, max_i],\n            [-1, 1, max_diag],\n            [0, -1, max_j],\n            [0, 1, max_j],\n            [1, -1, max_diag],\n            [1, 0, max_i],\n            [1, 1, max_diag]]\n\n    def get_letter(self, start, dist):\n        mi = modulo(start[0] + start[2][0]*dist, self.lengths[0])\n        mj = modulo(start[1] + start[2][1]*dist, self.lengths[1])\n        return self.letters[mi][mj]\n\n\ndef compute(rows):\n    donut = Donut(rows)\n\n    longest_spell = ''\n    for i in range(0, donut.lengths[0]):\n        for j in range(0, donut.lengths[1]):\n            for direction in donut.directions:\n                length = 0\n                spell = ''\n                duplicates = [[a, b, d]\n                              for a in range(donut.lengths[0])\n                              for b in range(donut.lengths[1])\n                              for d in donut.directions]\n\n\n\n                while True:\n                    letter = donut.get_letter([i, j, direction], length)\n                    remaining_duplicates = []\n                    for duplicate in duplicates:\n                        a = duplicate[0]\n                        b = duplicate[1]\n                        d = duplicate[2]\n                        if donut.get_letter(duplicate, length) == letter:\n                            remaining_duplicates.append(duplicate)\n\n                    if len(remaining_duplicates) > 1:\n                        length += 1\n                        spell += letter\n                        duplicates = remaining_duplicates\n                    else:\n                        break\n\n                    if length >= direction[2]:\n                        break\n\n                if len(spell) > len(longest_spell):\n                    longest_spell = spell\n\n    return longest_spell\n\n\nwhile True:\n    inp_size = input().split()\n    num_rows = int(inp_size[0])\n\n    if num_rows == 0:\n        break;\n\n    rows = []\n    for i in range(int(num_rows)):\n        rows.append(input())\n\n    print(compute(rows))\n\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 998244353\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    rr = []\n\n    dd = [(0,-1),(1,-1),(1,0),(1,1),(0,1),(-1,-1),(-1,0),(-1,1)]\n\n    while True:\n        h,w = LI()\n        if h == 0 and w == 0:\n            break\n\n        a = [S() for _ in range(h)]\n\n        rs = set()\n        r = ''\n        rm = -1\n\n        for i in range(h):\n            for j in range(w):\n                for di,dj in dd:\n                    tr = a[i][j]\n                    for k in range(1,401):\n                        ni = (i+di*k) % h\n                        nj = (j+dj*k) % w\n                        if ni == i and nj == j:\n                            break\n                        c = a[ni][nj]\n                        tr += c\n                        l = len(tr)\n                        if tr in rs and (l > rm or (l==rm and r > tr)):\n                            r = tr\n                            rm = l\n                        rs.add(tr)\n\n        if r == '':\n            rr.append(0)\n        else:\n            rr.append(r)\n\n\n    return '\\n'.join(map(str, rr))\n\n\nprint(main())\n\n\n"
  },
  {
    "language": "Python",
    "code": "\nfrom sys import stdin\n\ndef gcd_recursive(a, b):\n    if b == 0:\n        return a\n    else:\n        return gcd_recursive(b, a % b)\n\n\ndef modulo(x, base):\n    return (x % base + base) % base\n\n\nclass Donut:\n    def __init__(self, letters):\n        self.letters = letters\n        self.lengths = [len(letters), len(letters[0])]\n\n        max_diag = self.lengths[0] * self.lengths[1]\n        max_i = self.lengths[0]\n        max_j = self.lengths[1]\n        self.directions = [\n            [-1, -1, max_diag],\n            [-1, 0, max_i],\n            [-1, 1, max_diag],\n            [0, -1, max_j],\n            [0, 1, max_j],\n            [1, -1, max_diag],\n            [1, 0, max_i],\n            [1, 1, max_diag]]\n\n    def get_letter(self, start, dist):\n        mi = modulo(start[0] + start[2][0]*dist, self.lengths[0])\n        mj = modulo(start[1] + start[2][1]*dist, self.lengths[1])\n        return self.letters[mi][mj]\n\n\ndef compute(rows):\n    donut = Donut(rows)\n\n    longest_spell = ''\n    for i in range(0, donut.lengths[0]):\n        for j in range(0, donut.lengths[1]):\n            for direction in donut.directions:\n                length = 0\n                spell = ''\n                duplicates = [[a, b, d]\n                              for a in range(donut.lengths[0])\n                              for b in range(donut.lengths[1])\n                              for d in donut.directions]\n\n\n\n                while True:\n                    letter = donut.get_letter([i, j, direction], length)\n                    remaining_duplicates = []\n                    for duplicate in duplicates:\n                        a = duplicate[0]\n                        b = duplicate[1]\n                        d = duplicate[2]\n                        if donut.get_letter(duplicate, length) == letter:\n                            remaining_duplicates.append(duplicate)\n\n                    if len(remaining_duplicates) > 1:\n                        length += 1\n                        spell += letter\n                        duplicates = remaining_duplicates\n                    else:\n                        break\n\n                    if length >= direction[2]:\n                        break\n\n                if len(spell) > len(longest_spell):\n                    longest_spell = spell\n\n    return longest_spell\n\n\nif __name__ == '__main__':\n    while True:\n        inp_size = stdin.readline().split()\n        num_rows = int(inp_size[0])\n\n        if num_rows == 0:\n            break;\n\n        rows = []\n        for i in range(int(num_rows)):\n            rows.append(stdin.readline())\n\n        print(compute(rows))\n\n"
  },
  {
    "language": "Python",
    "code": "\ndef gcd_recursive(a, b):\n    if b == 0:\n        return a\n    else:\n        return gcd_recursive(b, a % b)\n\n\ndef modulo(x, base):\n    return (x % base + base) % base\n\n\nclass Donut:\n    def __init__(self, letters):\n        self.letters = letters\n        self.lengths = [len(letters), len(letters[0])]\n\n        max_diag = self.lengths[0] * self.lengths[1]\n        max_i = self.lengths[0]\n        max_j = self.lengths[1]\n        self.directions = [\n            [-1, -1, max_diag],\n            [-1, 0, max_i],\n            [-1, 1, max_diag],\n            [0, -1, max_j],\n            [0, 1, max_j],\n            [1, -1, max_diag],\n            [1, 0, max_i],\n            [1, 1, max_diag]]\n\n    def get_letter(self, start, dist):\n        mi = modulo(start[0] + start[2][0]*dist, self.lengths[0])\n        mj = modulo(start[1] + start[2][1]*dist, self.lengths[1])\n        return self.letters[mi][mj]\n\n\ndef compute(rows):\n    donut = Donut(rows)\n\n    longest_spell = ''\n    for i in range(0, donut.lengths[0]):\n        for j in range(0, donut.lengths[1]):\n            for direction in donut.directions:\n                length = 0\n                spell = ''\n                duplicates = [[a, b, d]\n                              for a in range(donut.lengths[0])\n                              for b in range(donut.lengths[1])\n                              for d in donut.directions]\n\n\n\n                while True:\n                    letter = donut.get_letter([i, j, direction], length)\n                    remaining_duplicates = []\n                    for duplicate in duplicates:\n                        a = duplicate[0]\n                        b = duplicate[1]\n                        d = duplicate[2]\n                        if donut.get_letter(duplicate, length) == letter:\n                            remaining_duplicates.append(duplicate)\n\n                    if len(remaining_duplicates) > 1:\n                        length += 1\n                        spell += letter\n                        duplicates = remaining_duplicates\n                    else:\n                        break\n\n                    if length >= direction[2]:\n                        break\n\n                if len(spell) > len(longest_spell):\n                    longest_spell = spell\n\n    return longest_spell\n\n\nif __name__ == '__main__':\n    while True:\n        inp_size = input().split()\n        num_rows = int(inp_size[0])\n\n        if num_rows == 0:\n            break;\n\n        rows = []\n        for i in range(int(num_rows)):\n            rows.append(input())\n\n        print(compute(rows))\n\n"
  },
  {
    "language": "Python",
    "code": "\nfrom sys import stdin\n\ndef gcd_recursive(a, b):\n    if b == 0:\n        return a\n    else:\n        return gcd_recursive(b, a % b)\n\n\ndef modulo(x, base):\n    return (x % base + base) % base\n\n\nclass Donut:\n    def __init__(self, letters):\n        self.letters = letters\n        self.lengths = [len(letters), len(letters[0])]\n\n        max_diag = self.lengths[0] * self.lengths[1]\n        max_i = self.lengths[0]\n        max_j = self.lengths[1]\n        self.directions = [\n            [-1, -1, max_diag],\n            [-1, 0, max_i],\n            [-1, 1, max_diag],\n            [0, -1, max_j],\n            [0, 1, max_j],\n            [1, -1, max_diag],\n            [1, 0, max_i],\n            [1, 1, max_diag]]\n\n    def get_letter(self, start, dist):\n        mi = modulo(start[0] + start[2][0]*dist, self.lengths[0])\n        mj = modulo(start[1] + start[2][1]*dist, self.lengths[1])\n        return self.letters[mi][mj]\n\n\ndef compute(rows):\n    donut = Donut(rows)\n\n    longest_spell = ''\n    for i in range(0, donut.lengths[0]):\n        for j in range(0, donut.lengths[1]):\n            for direction in donut.directions:\n                length = 0\n                spell = ''\n                duplicates = [[a, b, d]\n                              for a in range(donut.lengths[0])\n                              for b in range(donut.lengths[1])\n                              for d in donut.directions]\n\n\n\n                while True:\n                    letter = donut.get_letter([i, j, direction], length)\n                    remaining_duplicates = []\n                    for duplicate in duplicates:\n                        a = duplicate[0]\n                        b = duplicate[1]\n                        d = duplicate[2]\n                        if donut.get_letter(duplicate, length) == letter:\n                            remaining_duplicates.append(duplicate)\n\n                    if len(remaining_duplicates) > 1:\n                        length += 1\n                        spell += letter\n                        duplicates = remaining_duplicates\n                    else:\n                        break\n\n                    if length >= direction[2]:\n                        break\n\n                if len(spell) > len(longest_spell):\n                    longest_spell = spell\n\n    return longest_spell\n\n\nwhile True:\n    inp_size = stdin.readline().split()\n    num_rows = int(inp_size[0])\n\n    if num_rows == 0:\n        break;\n\n    rows = []\n    for i in range(int(num_rows)):\n        rows.append(stdin.readline())\n\n    print(compute(rows))\n\n"
  },
  {
    "language": "Python",
    "code": "dwh = zip([1,1,0,-1,-1,-1,0,1],[0,1,1,1,0,-1,-1,-1])\nwhile 1:\n    H,W = map(int,raw_input().split())\n    if H == 0: break\n    S = [raw_input() for i in xrange(H)]\n    \n    ans = \"\"\n    appear = set([])\n    for h in xrange(H):\n        for w in xrange(W):\n            for dw,dh in dwh:\n                s = S[h][w]\n                iw,ih = w,h\n                w = (w+dw+W)%W; h = (h+dh+H)%H\n                while (w,h) != (iw,ih):\n                    s += S[h][w]\n                    if s in appear:\n                        if len(s)  > len(ans): ans = s\n                        if len(s) == len(ans): ans = min(ans, s)\n                    appear.add(s)\n                    w = (w+dw+W)%W; h = (h+dh+H)%H\n    print ans if len(ans) > 1 else 0"
  },
  {
    "language": "Python",
    "code": "import sys\nDir = [(1, 0), (0, 1), (-1, 0), (0, -1), (1, 1), (-1, 1), (1, -1), (-1, -1)]\ndef ds(here, didx, lb, ub, field, start, string, spell):\n\ts = string + field[here[1]][here[0]]\n\tif s in spell :\n\t\tspell[s] -= 1\n\telse :\n\t\tspell[s] = -1\n\tdelta = Dir[didx]\n\tnext = [here[0] + delta[0], here[1]+ delta[1]]\n\tif next[0] < lb[0]:   next[0] = ub[0]\n\telif next[0] > ub[0]: next[0] = lb[0]\n\tif next[1] < lb[1]:   next[1] = ub[1]\n\telif next[1] > ub[1]: next[1] = lb[1]\n\n\tif next != start:\n\t\tds(next, didx, lb, ub, field, start, s, spell)\n\nsys.setrecursionlimit(10000)\n\nwhile 1:\n\th,w = map(int,raw_input().split(\" \"))\n\tif w == h == 0: break\n\tlb = (0,0)\n\tub = (w-1,h-1)\n\tspell = dict()\n\tdonut = [[c for c in raw_input()] for _ in range(h)]\n\tfor j in range(h):\n\t\tfor i in range(w):\n\t\t\tfor d in range(8):\n\t\t\t\tds([i,j], d, lb, ub, donut, [i,j], \"\", spell)\n\tspell_sort = sorted(spell.iteritems(), key = lambda x : (-len(x[0]),x[0],x[1]))\n\tlenspell = len(spell_sort)\n\tfor i in range(lenspell):\n\t\tif len(spell_sort[i][0]) >= 2 and spell_sort[i][1] <= -2:\n\t\t\tprint spell_sort[i][0]\n\t\t\tbreak\n\telse :\n\t\tprint 0"
  },
  {
    "language": "Python",
    "code": "\ndef gcd_recursive(a, b):\n    if b == 0:\n        return a\n    else:\n        return gcd_recursive(b, a % b)\n\n\ndef modulo(x, base):\n    return (x % base + base) % base\n\n\nclass Donut:\n    def __init__(self, letters):\n        self.letters = letters\n        self.lengths = [len(letters), len(letters[0])]\n\n        max_i = self.lengths[0]\n        max_j = self.lengths[1]\n        max_diag = self.lengths[0] * self.lengths[1] / gcd_recursive(max_i, max_j)\n        self.directions = [\n            [-1, -1, max_diag],\n            [-1, 0, max_i],\n            [-1, 1, max_diag],\n            [0, -1, max_j],\n            [0, 1, max_j],\n            [1, -1, max_diag],\n            [1, 0, max_i],\n            [1, 1, max_diag]]\n\n    def get_letter(self, start, dist):\n        mi = modulo(start[0] + start[2][0]*dist, self.lengths[0])\n        mj = modulo(start[1] + start[2][1]*dist, self.lengths[1])\n        return self.letters[mi][mj]\n\n\ndef compute(rows):\n    donut = Donut(rows)\n\n    longest = 0\n    longest_spell = ''\n    for i in range(0, donut.lengths[0]):\n        for j in range(0, donut.lengths[1]):\n            for direction in donut.directions:\n                length = 0\n                spell = ''\n                duplicates = [[a, b, d]\n                              for a in range(donut.lengths[0])\n                              for b in range(donut.lengths[1])\n                              for d in donut.directions]\n\n                # ignore shorter spells\n                if direction[2] <= longest:\n                    continue\n\n                while length < longest:\n                    spell += donut.get_letter([i, j, direction], length)\n                    length += 1\n\n                remaining_duplicates = []\n                for duplicate in duplicates:\n                    a = duplicate[0]\n                    b = duplicate[1]\n                    d = duplicate[2]\n                    match = True\n                    for l in range(0, length):\n                        if donut.get_letter(duplicate, l) != spell[l]:\n                            match = False\n                            break\n\n                    if match:\n                        remaining_duplicates.append(duplicate)\n\n                duplicates = remaining_duplicates\n\n                # extend spell as long as there is a match\n                while True:\n                    letter = donut.get_letter([i, j, direction], length)\n                    remaining_duplicates = []\n                    for duplicate in duplicates:\n                        a = duplicate[0]\n                        b = duplicate[1]\n                        d = duplicate[2]\n                        if donut.get_letter(duplicate, length) == letter:\n                            remaining_duplicates.append(duplicate)\n\n                    if len(remaining_duplicates) > 1:\n                        length += 1\n                        spell += letter\n                        duplicates = remaining_duplicates\n\n                        if len(spell) > longest:\n                            longest_spell = spell\n                            longest = length\n                    else:\n                        break\n\n                    if length >= direction[2]:\n                        break\n\n    return longest_spell\n\n\nwhile True:\n    inp_size = [input(), input()]\n    num_rows = int(inp_size[0])\n\n    if num_rows == 0:\n        break;\n\n    rows = []\n    for i in range(int(num_rows)):\n        rows.append(input())\n\n    found_spell = compute(rows)\n    if len(found_spell) == 1:\n        print(0)\n    else:\n        print(found_spell)\n\n"
  },
  {
    "language": "Python",
    "code": "'''\n7 0 1\n6   2\n5 4 3\n'''\ndx=[1,0,-1,0,1,-1,1,-1]\ndy=[0,1,0,-1,1,1,-1,-1]\n\nwhile True:\n    h,w=map(int,input().split())\n    if h==0:\n        break\n    field=[list(input()) for i in range(h)]\n    allword=set()\n    answord=set()\n    for i in range(h):\n        for j in range(w):\n            s=field[i][j]\n            if s in allword:\n                answord.add((len(s),s))\n            else:\n                allword.add(s)\n            for k in range(8):\n                used=[[False for _ in range(w)]for _ in range(h)]\n                s=field[i][j]\n                used[i][j]=True\n                while True:\n                    i=(i+dy[k])%h\n                    j=(j+dx[k])%w\n                    if used[i][j]:\n                        break\n                    s+=field[i][j]\n                    if s in allword:\n                        answord.add((len(s),s))\n                    else:\n                        allword.add(s)\n    print(sorted(answord,key=lambda x:(-x[0],x[1]))[0][1] if answord and sorted(answord,key=lambda x:(-x[0],x[1]))[0][0]>1 else 0 )\n\n\n\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "\ndef gcd_recursive(a, b):\n    if b == 0:\n        return a\n    else:\n        return gcd_recursive(b, a % b)\n\n\ndef modulo(x, base):\n    return (x % base + base) % base\n\n\nclass Donut:\n    def __init__(self, letters):\n        self.letters = letters\n        self.lengths = [len(letters), len(letters[0])]\n\n        max_diag = self.lengths[0] * self.lengths[1]\n        max_i = self.lengths[0]\n        max_j = self.lengths[1]\n        self.directions = [\n            [-1, -1, max_diag],\n            [-1, 0, max_i],\n            [-1, 1, max_diag],\n            [0, -1, max_j],\n            [0, 1, max_j],\n            [1, -1, max_diag],\n            [1, 0, max_i],\n            [1, 1, max_diag]]\n\n    def get_letter(self, start, dist):\n        mi = modulo(start[0] + start[2][0]*dist, self.lengths[0])\n        mj = modulo(start[1] + start[2][1]*dist, self.lengths[1])\n        return self.letters[mi][mj]\n\n\ndef compute(rows):\n    print('computing', rows)\n    donut = Donut(rows)\n\n    longest_spell = ''\n    for i in range(0, donut.lengths[0]):\n        for j in range(0, donut.lengths[1]):\n            for direction in donut.directions:\n                length = 0\n                spell = ''\n                duplicates = [[a, b, d]\n                              for a in range(donut.lengths[0])\n                              for b in range(donut.lengths[1])\n                              for d in donut.directions]\n\n\n\n                while True:\n                    letter = donut.get_letter([i, j, direction], length)\n                    remaining_duplicates = []\n                    for duplicate in duplicates:\n                        a = duplicate[0]\n                        b = duplicate[1]\n                        d = duplicate[2]\n                        if donut.get_letter(duplicate, length) == letter:\n                            remaining_duplicates.append(duplicate)\n\n                    if len(remaining_duplicates) > 1:\n                        length += 1\n                        spell += letter\n                        duplicates = remaining_duplicates\n                    else:\n                        break\n\n                    if length >= direction[2]:\n                        break\n\n                if len(spell) > len(longest_spell):\n                    longest_spell = spell\n\n    return longest_spell\n\n\nif __name__ == '__main__':\n    while True:\n        inp_size = input().split()\n        num_rows = int(inp_size[0])\n\n        if num_rows == 0:\n            break;\n\n        rows = []\n        for i in range(int(num_rows)):\n            rows.append(input())\n\n        print(compute(rows))\n\n"
  },
  {
    "language": "Python",
    "code": "\ndef gcd_recursive(a, b):\n    if b == 0:\n        return a\n    else:\n        return gcd_recursive(b, a % b)\n\n\ndef modulo(x, base):\n    return (x % base + base) % base\n\n\nclass Donut:\n    def __init__(self, letters):\n        self.letters = letters\n        self.lengths = [len(letters), len(letters[0])]\n\n        max_diag = self.lengths[0] * self.lengths[1]\n        max_i = self.lengths[0]\n        max_j = self.lengths[1]\n        self.directions = [\n            [-1, -1, max_diag],\n            [-1, 0, max_i],\n            [-1, 1, max_diag],\n            [0, -1, max_j],\n            [0, 1, max_j],\n            [1, -1, max_diag],\n            [1, 0, max_i],\n            [1, 1, max_diag]]\n\n    def get_letter(self, start, dist):\n        mi = modulo(start[0] + start[2][0]*dist, self.lengths[0])\n        mj = modulo(start[1] + start[2][1]*dist, self.lengths[1])\n        return self.letters[mi][mj]\n\n\ndef compute(rows):\n    donut = Donut(rows)\n\n    longest_spell = ''\n    for i in range(0, donut.lengths[0]):\n        for j in range(0, donut.lengths[1]):\n            for direction in donut.directions:\n                length = 0\n                spell = ''\n                duplicates = [[a, b, d]\n                              for a in range(donut.lengths[0])\n                              for b in range(donut.lengths[1])\n                              for d in donut.directions]\n\n\n\n                while True:\n                    letter = donut.get_letter([i, j, direction], length)\n                    remaining_duplicates = []\n                    for duplicate in duplicates:\n                        a = duplicate[0]\n                        b = duplicate[1]\n                        d = duplicate[2]\n                        if donut.get_letter(duplicate, length) == letter:\n                            remaining_duplicates.append(duplicate)\n\n                    if len(remaining_duplicates) > 1:\n                        length += 1\n                        spell += letter\n                        duplicates = remaining_duplicates\n                    else:\n                        break\n\n                    if length >= direction[2]:\n                        break\n\n                if len(spell) > len(longest_spell):\n                    longest_spell = spell\n\n    return longest_spell\n\n\nif __name__ == '__main__':\n    while True:\n        inp_size = input().split()\n        num_rows = int(inp_size[0])\n\n        if num_rows == 0:\n            break;\n\n        rows = []\n        for i in range(int(num_rows)):\n            rows.append(input())\n\n        print(compute(rows))\n\n"
  },
  {
    "language": "Python",
    "code": "dd = [(-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1)]\nwhile 1:\n    h, w = map(int, input().split())\n    if h == w == 0:\n        break\n    S = [input() for i in range(h)]\n\n    count = {}\n    for i in range(h):\n        for j in range(w):\n            for dx, dy in dd:\n                s = S[i][j]\n                count[s] = count.get(s, 0) + 1\n                x = (j + dx) % w; y = (i + dy) % h\n                while x != j or y != i:\n                    s += S[y][x]\n                    count[s] = count.get(s, 0) + 1\n                    x = (x + dx) % w; y = (y + dy) % h\n    ans = min(count, key=lambda x: (-len(x)*(count[x]>1), x))\n    print(ans*(len(ans)>1)or 0)"
  },
  {
    "language": "Python",
    "code": "\ndef gcd_recursive(a, b):\n    if b == 0:\n        return a\n    else:\n        return gcd_recursive(b, a % b)\n\n\ndef modulo(x, base):\n    return (x % base + base) % base\n\n\nclass Donut:\n    def __init__(self, letters):\n        self.letters = letters\n        self.lengths = [len(letters), len(letters[0])]\n\n        max_i = self.lengths[0]\n        max_j = self.lengths[1]\n        max_diag = self.lengths[0] * self.lengths[1] / gcd_recursive(max_i, max_j)\n        self.directions = [\n            [-1, -1, max_diag],\n            [-1, 0, max_i],\n            [-1, 1, max_diag],\n            [0, -1, max_j],\n            [0, 1, max_j],\n            [1, -1, max_diag],\n            [1, 0, max_i],\n            [1, 1, max_diag]]\n\n    def get_letter(self, start, dist):\n        mi = modulo(start[0] + start[2][0]*dist, self.lengths[0])\n        mj = modulo(start[1] + start[2][1]*dist, self.lengths[1])\n        return self.letters[mi][mj]\n\n\ndef compute(rows):\n    donut = Donut(rows)\n\n    longest = 0\n    longest_spell = ''\n    for i in range(0, donut.lengths[0]):\n        for j in range(0, donut.lengths[1]):\n            for direction in donut.directions:\n                length = 0\n                spell = ''\n                duplicates = [[a, b, d]\n                              for a in range(donut.lengths[0])\n                              for b in range(donut.lengths[1])\n                              for d in donut.directions]\n\n                # ignore shorter spells\n                if direction[2] <= longest:\n                    continue\n\n                while length < longest:\n                    spell += donut.get_letter([i, j, direction], length)\n                    length += 1\n\n                remaining_duplicates = []\n                for duplicate in duplicates:\n                    a = duplicate[0]\n                    b = duplicate[1]\n                    d = duplicate[2]\n                    match = True\n                    for l in range(0, length):\n                        if donut.get_letter(duplicate, l) != spell[l]:\n                            match = False\n                            break\n\n                    if match:\n                        remaining_duplicates.append(duplicate)\n\n                duplicates = remaining_duplicates\n\n                # extend spell as long as there is a match\n                while True:\n                    letter = donut.get_letter([i, j, direction], length)\n                    remaining_duplicates = []\n                    for duplicate in duplicates:\n                        a = duplicate[0]\n                        b = duplicate[1]\n                        d = duplicate[2]\n                        if donut.get_letter(duplicate, length) == letter:\n                            remaining_duplicates.append(duplicate)\n\n                    if len(remaining_duplicates) > 1:\n                        length += 1\n                        spell += letter\n                        duplicates = remaining_duplicates\n\n                        if len(spell) > longest:\n                            longest_spell = spell\n                            longest = length\n                    else:\n                        break\n\n                    if length >= direction[2]:\n                        break\n\n    return longest_spell\n\n\nwhile True:\n    inp_size = input().split()\n    num_rows = int(inp_size[0])\n\n    if num_rows == 0:\n        break;\n\n    rows = []\n    for i in range(int(num_rows)):\n        rows.append(input())\n\n    found_spell = compute(rows)\n    if len(found_spell) == 1:\n        print(0)\n    else:\n        print(found_spell)\n\n"
  },
  {
    "language": "Rust",
    "code": "extern crate core;\n\nuse std::fmt;\nuse std::cmp::{Ordering, min, max};\nuse std::fmt::{Display, Error, Formatter};\nuse std::ops::{Index, IndexMut};\nuse std::collections::VecDeque;\nuse std::f32::MAX;\n\nfn show<T: Display>(vec: &Vec<T>) {\n    if vec.is_empty() {\n        println!(\"[]\");\n    }else {\n        print!(\"[{}\", vec[0]);\n        for i in 1 .. vec.len() {\n            print!(\", {}\", vec[i]);\n        }\n        println!(\"]\");\n    }\n}\nmacro_rules! read_line{\n    () => {{\n        let mut line = String::new();\n        std::io::stdin().read_line(&mut line).ok();\n        line\n    }};\n    (delimiter: ' ') => {\n        read_line!().split_whitespace().map(|x|x.to_string()).collect::<Vec<_>>()\n    };\n    (delimiter: $p:expr) => {\n        read_line!().split($p).map(|x|x.to_string()).collect::<Vec<_>>()\n    };\n    (' ') => {\n        read_line!(delimiter: ' ')\n    };\n    ($delimiter:expr) => {\n        read_line!(delimiter: $delimiter)\n    };\n    (' '; $ty:ty) => {\n        read_line!().split_whitespace().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()\n    };\n    ($delimiter:expr; $ty:ty) => {\n        read_line!($delimiter).into_iter().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()\n    };\n}\nmacro_rules! let_all {\n    ($($n:ident:$t:ty),*) => {\n        let line = read_line!(delimiter: ' ');\n        let mut iter = line.iter();\n        $(let $n:$t = iter.next().unwrap().parse().ok().unwrap();)*\n    };\n}\nfn read_all(donuts: &Vec<Vec<char>>, height: i32, width: i32) -> Vec<Vec<char>> {\n    let mut result = Vec::new();\n    for y in 0 .. height {\n        for x in 0 .. width {\n            for dy in -1_i32 .. 2 {\n                for dx in -1_i32 .. 2 {\n                    if dx != 0 || dy != 0 {\n                        let mut cx = (x + dx + width) % width;\n                        let mut cy = (y + dy + height) % height;\n                        let mut current = String::new();\n                        current.push(donuts[y as usize][x as usize]);\n                        while cx != x || cy != y {\n                            //println!(\"x {}, y {}, cx {} dx {} , cy {} dy {}\", x, y, cx, dx, cy, dy);\n                            current.push(donuts[cy as usize][cx as usize]);\n                            cx = (cx + dx + width) % width;\n                            cy = (cy + dy + height) % height;\n                        }\n                        result.push(current.chars().collect());\n                    }\n                }\n            }\n        }\n    }\n    result.sort();\n    result\n}\nfn common_prefix_length(a: &Vec<char>, b: &Vec<char>) -> usize {\n    let mut i = 0;\n    while i < a.len() && i < b.len() && a[i] == b[i] {\n        i += 1;\n    }\n    i\n}\nfn main(){\n    loop {\n        let_all!(height: i32, width: i32);\n        if height == 0 && width == 0 {\n            return\n        }\n        let mut donuts = Vec::with_capacity(height as usize);\n        for _ in 0 .. height {\n            donuts.push(read_line!().chars().collect::<Vec<char>>());\n        }\n        let words = read_all(&donuts, height, width);\n        let mut from = 0;\n        let mut length = 0;\n        for i in 1 .. words.len() {\n            if length < words[i].len(){\n                let prefix = common_prefix_length(&words[i - 1], &words[i]);\n                if prefix > length {\n                    from = i;\n                    length = prefix;\n                }\n            }\n        }\n        if length < 2 {\n            println!(\"0\");\n        }else {\n            for i in 0 .. length {\n                print!(\"{}\", words[from][i]);\n            }\n            println!();\n        }\n    }\n}\n"
  }
]