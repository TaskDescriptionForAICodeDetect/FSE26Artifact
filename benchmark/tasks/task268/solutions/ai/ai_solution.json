[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_SIZE 100\n\nchar grid[MAX_SIZE][MAX_SIZE];\nint n;\n\ntypedef struct {\n    char str[MAX_SIZE * MAX_SIZE];\n    int len;\n} MagicString;\n\nMagicString magic_spells[MAX_SIZE * MAX_SIZE * MAX_SIZE];\nint magic_count = 0;\n\nint dx[] = {-1, -1, -1, 0, 1, 1, 1, 0};\nint dy[] = {-1, 0, 1, 1, 1, 0, -1, -1};\n\nvoid generate_sequences(int x, int y, int dir) {\n    char sequence[MAX_SIZE * MAX_SIZE];\n    int len = 0;\n    int visited[MAX_SIZE][MAX_SIZE] = {0};\n    int nx = x, ny = y;\n\n    while (!visited[nx][ny]) {\n        visited[nx][ny] = 1;\n        sequence[len++] = grid[nx][ny];\n        sequence[len] = '\\0';\n\n        if (len > 1) {\n            strcpy(magic_spells[magic_count].str, sequence);\n            magic_spells[magic_count].len = len;\n            magic_count++;\n        }\n\n        nx = (nx + dx[dir] + n) % n;\n        ny = (ny + dy[dir] + n) % n;\n    }\n}\n\nint compare(const void *a, const void *b) {\n    MagicString *s1 = (MagicString *)a;\n    MagicString *s2 = (MagicString *)b;\n\n    if (s1->len != s2->len) {\n        return s2->len - s1->len;\n    } else {\n        return strcmp(s1->str, s2->str);\n    }\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            for (int dir = 0; dir < 8; dir++) {\n                generate_sequences(i, j, dir);\n            }\n        }\n    }\n\n    qsort(magic_spells, magic_count, sizeof(MagicString), compare);\n\n    int max_len = 0;\n    for (int i = 0; i < magic_count; i++) {\n        if (magic_spells[i].len < max_len) break;\n        for (int j = i + 1; j < magic_count; j++) {\n            if (strcmp(magic_spells[i].str, magic_spells[j].str) == 0) {\n                max_len = magic_spells[i].len;\n                printf(\"%s\\n\", magic_spells[i].str);\n                return 0;\n            }\n        }\n    }\n\n    printf(\"0\\n\");\n    return 0;\n}",
    "timestamp": "2025-08-05 20:50:29"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nvector<pair<int, int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}, {1, 1}, {1, -1}, {-1, 1}, {-1, -1}};\n\nstring findMagicSpell(const vector<string>& grid) {\n    int n = grid.size();\n    if (n == 0) return \"0\";\n    \n    vector<string> candidates;\n    \n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            for (auto& dir : directions) {\n                int dx = dir.first, dy = dir.second;\n                string s;\n                int x = i, y = j;\n                for (int k = 0; k < n; ++k) {\n                    s += grid[x][y];\n                    x = (x + dx + n) % n;\n                    y = (y + dy + n) % n;\n                }\n                for (int len = n; len >= 1; --len) {\n                    for (int start = 0; start + len <= n; ++start) {\n                        string sub = s.substr(start, len);\n                        int count = 0;\n                        for (int a = 0; a < n; ++a) {\n                            for (int b = 0; b < n; ++b) {\n                                for (auto& dir2 : directions) {\n                                    int dx2 = dir2.first, dy2 = dir2.second;\n                                    string t;\n                                    int x2 = a, y2 = b;\n                                    bool match = true;\n                                    for (int k = 0; k < sub.size(); ++k) {\n                                        if (grid[x2][y2] != sub[k]) {\n                                            match = false;\n                                            break;\n                                        }\n                                        x2 = (x2 + dx2 + n) % n;\n                                        y2 = (y2 + dy2 + n) % n;\n                                    }\n                                    if (match) {\n                                        count++;\n                                        if (count >= 2) break;\n                                    }\n                                }\n                                if (count >= 2) break;\n                            }\n                            if (count >= 2) break;\n                        }\n                        if (count >= 2) {\n                            candidates.push_back(sub);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    if (candidates.empty()) return \"0\";\n    \n    int max_len = 0;\n    for (const auto& s : candidates) {\n        if (s.size() > max_len) {\n            max_len = s.size();\n        }\n    }\n    \n    vector<string> result;\n    for (const auto& s : candidates) {\n        if (s.size() == max_len) {\n            result.push_back(s);\n        }\n    }\n    \n    sort(result.begin(), result.end());\n    \n    return result.empty() ? \"0\" : result[0];\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<string> grid(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> grid[i];\n    }\n    cout << findMagicSpell(grid) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 20:51:00"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class MagicSpell {\n    public static String findMagicSpell(char[][] grid) {\n        int rows = grid.length;\n        if (rows == 0) return \"0\";\n        int cols = grid[0].length;\n        if (cols == 0) return \"0\";\n\n        Map<String, Integer> substringCounts = new HashMap<>();\n        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}, {1, 1}, {1, -1}, {-1, 1}, {-1, -1}};\n\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                for (int[] dir : directions) {\n                    StringBuilder sb = new StringBuilder();\n                    int x = i, y = j;\n                    for (int len = 1; len <= rows * cols; len++) {\n                        sb.append(grid[x][y]);\n                        String current = sb.toString();\n                        substringCounts.put(current, substringCounts.getOrDefault(current, 0) + 1);\n\n                        x = (x + dir[0] + rows) % rows;\n                        y = (y + dir[1] + cols) % cols;\n                    }\n                }\n            }\n        }\n\n        List<String> candidates = new ArrayList<>();\n        int maxLen = 0;\n\n        for (Map.Entry<String, Integer> entry : substringCounts.entrySet()) {\n            String s = entry.getKey();\n            int count = entry.getValue();\n            if (s.length() > 1 && count > 1) {\n                if (s.length() > maxLen) {\n                    maxLen = s.length();\n                    candidates.clear();\n                    candidates.add(s);\n                } else if (s.length() == maxLen) {\n                    candidates.add(s);\n                }\n            }\n        }\n\n        if (candidates.isEmpty()) {\n            return \"0\";\n        }\n\n        Collections.sort(candidates);\n        return candidates.get(0);\n    }\n}",
    "timestamp": "2025-08-05 20:51:56"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "class Solution {\n    public String findMagicSpell(char[][] grid) {\n        int rows = grid.length;\n        int cols = grid[0].length;\n        Set<String> spells = new HashSet<>();\n\n        // Check all 8 directions\n        int[][] directions = {{0,1}, {1,0}, {1,1}, {-1,1}, {0,-1}, {-1,0}, {-1,-1}, {1,-1}};\n\n        for (int r = 0; r < rows; r++) {\n            for (int c = 0; c < cols; c++) {\n                for (int[] dir : directions) {\n                    findSpells(grid, r, c, dir[0], dir[1], spells);\n                }\n            }\n        }\n\n        return findLongestSpell(spells);\n    }\n\n    private void findSpells(char[][] grid, int r, int c, int dr, int dc, Set<String> spells) {\n        int rows = grid.length;\n        int cols = grid[0].length;\n        StringBuilder spell = new StringBuilder();\n\n        for (int steps = 0; steps < rows; steps++) {\n            spell.append(grid[r][c]);\n            \n            if (spell.length() > 1) {\n                spells.add(spell.toString());\n            }\n\n            r = (r + dr + rows) % rows;\n            c = (c + dc + cols) % cols;\n        }\n    }\n\n    private String findLongestSpell(Set<String> spells) {\n        List<String> duplicateSpells = spells.stream()\n            .filter(s -> {\n                int firstIndex = spells.toString().indexOf(s);\n                int lastIndex = spells.toString().lastIndexOf(s);\n                return firstIndex != lastIndex;\n            })\n            .sorted((a, b) -> {\n                if (a.length() != b.length()) {\n                    return b.length() - a.length();\n                }\n                return a.compareTo(b);\n            })\n            .collect(Collectors.toList());\n\n        return duplicateSpells.isEmpty() ? \"0\" : duplicateSpells.get(0);\n    }\n}",
    "timestamp": "2025-08-05 20:52:04"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_SIZE 10\n#define MAX_DIRECTIONS 8\n\nconst int dx[MAX_DIRECTIONS] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int dy[MAX_DIRECTIONS] = {1, 1, 0, -1, -1, -1, 0, 1};\n\nint is_valid(int x, int y, int n) {\n    return x >= 0 && x < n && y >= 0 && y < n;\n}\n\nvoid trace_sequence(char grid[MAX_SIZE][MAX_SIZE], int n, int x, int y, int dir, char* seq, int* len) {\n    *len = 0;\n    seq[(*len)++] = grid[x][y];\n    \n    int curr_x = x, curr_y = y;\n    while (1) {\n        curr_x = (curr_x + dx[dir] + n) % n;\n        curr_y = (curr_y + dy[dir] + n) % n;\n        \n        if (curr_x == x && curr_y == y) break;\n        seq[(*len)++] = grid[curr_x][curr_y];\n    }\n    seq[*len] = '\\0';\n}\n\nint count_occurrences(char grid[MAX_SIZE][MAX_SIZE], int n, char* seq, int seq_len) {\n    int count = 0;\n    int used[MAX_SIZE][MAX_SIZE] = {0};\n    \n    for (int x = 0; x < n; x++) {\n        for (int y = 0; y < n; y++) {\n            for (int dir = 0; dir < MAX_DIRECTIONS; dir++) {\n                char curr_seq[MAX_SIZE + 1];\n                int curr_len;\n                trace_sequence(grid, n, x, y, dir, curr_seq, &curr_len);\n                \n                if (curr_len >= seq_len && strncmp(seq, curr_seq, seq_len) == 0) {\n                    int found = 1;\n                    for (int i = 0; i < curr_len; i++) {\n                        int dx_curr = (x + i * dx[dir] + n) % n;\n                        int dy_curr = (y + i * dy[dir] + n) % n;\n                        if (used[dx_curr][dy_curr]) {\n                            found = 0;\n                            break;\n                        }\n                    }\n                    \n                    if (found) {\n                        count++;\n                        for (int i = 0; i < curr_len; i++) {\n                            int dx_curr = (x + i * dx[dir] + n) % n;\n                            int dy_curr = (y + i * dy[dir] + n) % n;\n                            used[dx_curr][dy_curr] = 1;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    return count;\n}\n\nchar* find_magic_spell(char grid[MAX_SIZE][MAX_SIZE], int n) {\n    char* magic_spell = NULL;\n    int max_len = 0;\n    \n    for (int len = n; len > 0; len--) {\n        for (int x = 0; x < n; x++) {\n            for (int y = 0; y < n; y++) {\n                for (int dir = 0; dir < MAX_DIRECTIONS; dir++) {\n                    char seq[MAX_SIZE + 1];\n                    int curr_len;\n                    trace_sequence(grid, n, x, y, dir, seq, &curr_len);\n                    \n                    if (curr_len >= len) {\n                        seq[len] = '\\0';\n                        int occurrences = count_occurrences(grid, n, seq, len);\n                        \n                        if (occurrences > 1) {\n                            if (magic_spell == NULL || \n                                len > max_len || \n                                (len == max_len && strcmp(seq, magic_spell) < 0)) {\n                                if (magic_spell) free(magic_spell);\n                                magic_spell = strdup(seq);\n                                max_len = len;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    return magic_spell ? magic_spell : \"0\";\n}",
    "timestamp": "2025-08-05 20:52:19"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <vector>\n#include <string>\n#include <unordered_set>\n#include <algorithm>\n\nclass Solution {\npublic:\n    std::string magicSpell(std::vector<std::string>& grid) {\n        int n = grid.size();\n        std::vector<std::string> extendedGrid(n * 2);\n        \n        // Create donut-shaped extended grid\n        for (int i = 0; i < n * 2; i++) {\n            extendedGrid[i] = grid[i % n] + grid[i % n];\n        }\n        \n        std::unordered_set<std::string> sequences;\n        std::vector<std::string> candidates;\n        \n        // Directions: horizontal, vertical, diagonals\n        std::vector<std::pair<int, int>> directions = {\n            {0, 1}, {1, 0}, {1, 1}, {1, -1}\n        };\n        \n        for (int len = n * 2; len > 0; len--) {\n            sequences.clear();\n            \n            for (int i = 0; i < n * 2; i++) {\n                for (int j = 0; j < n * 2; j++) {\n                    for (auto& [dx, dy] : directions) {\n                        std::string current;\n                        int x = i, y = j;\n                        \n                        for (int k = 0; k < len; k++) {\n                            current += extendedGrid[x][y];\n                            x += dx;\n                            y += dy;\n                        }\n                        \n                        if (sequences.count(current)) {\n                            candidates.push_back(current);\n                        }\n                        sequences.insert(current);\n                    }\n                }\n            }\n            \n            if (!candidates.empty()) {\n                std::sort(candidates.begin(), candidates.end());\n                return candidates[0];\n            }\n        }\n        \n        return \"0\";\n    }\n};",
    "timestamp": "2025-08-05 20:52:26"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def find_magic_spell(grid):\n    def search_from(x, y, dx, dy, path, visited):\n        if (x, y) in visited:\n            # If visited, check if path is a repeat\n            s = ''.join(path)\n            nonlocal magic_spells\n            if len(path) > 1:\n                if s not in magic_spells:\n                    magic_spells[s] = 1\n                else:\n                    magic_spells[s] += 1\n            return\n        \n        # Mark current position visited in this path\n        visited.add((x, y))\n        path.append(grid[x][y])\n        \n        # Move to next position in the donut shape\n        nx, ny = (x + dx) % len(grid), (y + dy) % len(grid[0])\n        search_from(nx, ny, dx, dy, path, visited)\n\n        # Clean up path and visited for other searches\n        path.pop()\n        visited.remove((x, y))\n\n    # Initialize\n    magic_spells = {}\n    directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]\n    \n    # Start searching\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            for dx, dy in directions:\n                search_from(i, j, dx, dy, [], set())\n    \n    # Filter spells only appearing more than once\n    magic_spells = {k: v for k, v in magic_spells.items() if v > 1}\n    \n    # Find the longest spells\n    longest_len = max(map(len, magic_spells)) if magic_spells else 0\n    longest_spells = [spell for spell in magic_spells if len(spell) == longest_len]\n    \n    # Return the first in lexicographical order\n    if longest_spells:\n        return min(longest_spells)\n    else:\n        return '0'\n\n# Example usage:\ngrid = [['a', 'b', 'a'], ['c', 'c', 'b'], ['a', 'd', 'c']]\nprint(find_magic_spell(grid))",
    "timestamp": "2025-08-13 03:45:07"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class MagicSpellFinder {\n    public static void main(String[] args) {\n        char[][] donut = {\n            {'a', 'b', 'c', 'd'},\n            {'e', 'f', 'g', 'h'},\n            {'i', 'j', 'k', 'l'},\n            {'m', 'n', 'o', 'p'}\n        };\n        \n        System.out.println(findMagicSpell(donut));\n    }\n\n    public static String findMagicSpell(char[][] donut) {\n        int n = donut.length;\n        Set<String> uniqueStrings = new HashSet<>();\n        Map<String, Integer> spellCount = new HashMap<>();\n        List<String> resultSpells = new ArrayList<>();\n\n        // 8 possible directions for traversal\n        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}, \n                              {1, 1}, {-1, -1}, {1, -1}, {-1, 1}};\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                for (int[] dir : directions) {\n                    for (int len = 1; len < n; len++) {\n                        StringBuilder spell = new StringBuilder();\n                        int x = i, y = j;\n                        boolean valid = true;\n                        for (int k = 0; k < len; k++) {\n                            spell.append(donut[x][y]);\n                            x = (x + dir[0] + n) % n;\n                            y = (y + dir[1] + n) % n;\n                            if (spell.length() > 1 && spellCount.getOrDefault(spell.toString(), 0) > 1) {\n                                valid = false;\n                                break;\n                            }\n                        }\n                        String currentSpell = spell.toString();\n                        if (valid) {\n                            spellCount.put(currentSpell, spellCount.getOrDefault(currentSpell, 0) + 1);\n                            if (spellCount.get(currentSpell) > 1) {\n                                uniqueStrings.add(currentSpell);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        for (String spell : uniqueStrings) {\n            if (spellCount.get(spell) > 1) {\n                resultSpells.add(spell);\n            }\n        }\n\n        if (resultSpells.isEmpty()) {\n            return \"0\";\n        }\n\n        resultSpells.sort((s1, s2) -> {\n            if (s1.length() != s2.length()) {\n                return Integer.compare(s2.length(), s1.length());\n            }\n            return s1.compareTo(s2);\n        });\n\n        return resultSpells.get(0);\n    }\n}",
    "timestamp": "2025-08-13 03:45:14"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_N 50\n#define MAX_DIRECTION 8\n#define MAX_SPELL_LENGTH 100\n\ntypedef struct {\n    int dx, dy;\n} Direction;\n\nDirection directions[MAX_DIRECTION] = {\n    { 0, 1}, { 1, 0}, { 1, 1}, { 1, -1},\n    { 0,-1}, {-1, 0}, {-1,-1}, {-1, 1}\n};\n\nint N;\nchar donut[MAX_N][MAX_N];\nchar magic[MAX_SPELL_LENGTH];\nchar candidate[MAX_SPELL_LENGTH];\nint maxLength;\nint found;\n\nint checkMagicSpell(int length, int row, int col, int directionIndex) {\n    int x = row, y = col;\n    for (int i = 0; i < length; i++) {\n        candidate[i] = donut[x][y];\n        x = (x + directions[directionIndex].dx + N) % N;\n        y = (y + directions[directionIndex].dy + N) % N;\n    }\n    candidate[length] = '\\0';\n\n    // Check occurrences\n    int occurrences = 0;\n    for (int startRow = 0; startRow < N; startRow++) {\n        for (int startCol = 0; startCol < N; startCol++) {\n            for (int dir = 0; dir < MAX_DIRECTION; dir++) {\n                int match = 1;\n                x = startRow;\n                y = startCol;\n                for (int j = 0; j < length && match; j++) {\n                    if (candidate[j] != donut[x][y]) match = 0;\n                    x = (x + directions[dir].dx + N) % N;\n                    y = (y + directions[dir].dy + N) % N;\n                }\n                if (match) occurrences++;\n            }\n        }\n    }\n\n    return occurrences > 1;\n}\n\nvoid findMagicSpell() {\n    maxLength = 0;\n    found = 0;\n    for (int length = 1; length <= N && !found; length++) {\n        for (int row = 0; row < N; row++) {\n            for (int col = 0; col < N; col++) {\n                for (int dir = 0; dir < MAX_DIRECTION; dir++) {\n                    if (checkMagicSpell(length, row, col, dir)) {\n                        found = 1;\n                        if (length > maxLength || (length == maxLength && strcmp(candidate, magic) < 0)) {\n                            strcpy(magic, candidate);\n                            maxLength = length;\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d\", &N);\n    for (int i = 0; i < N; i++) {\n        scanf(\"%s\", donut[i]);\n    }\n\n    findMagicSpell();\n    if (maxLength) {\n        printf(\"%s\\n\", magic);\n    } else {\n        printf(\"0\\n\");\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 03:45:19"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def find_magic_spell(grid):\n    def generate_sequences(grid):\n        rows, cols = len(grid), len(grid[0])\n        directions = [\n            (0, 1), (0, -1), (1, 0), (-1, 0),\n            (1, 1), (1, -1), (-1, 1), (-1, -1)\n        ]\n        sequences = []\n\n        for r in range(rows):\n            for c in range(cols):\n                for dr, dc in directions:\n                    for length in range(1, max(rows, cols)):\n                        seq = []\n                        for step in range(length):\n                            new_r = (r + step * dr) % rows\n                            new_c = (c + step * dc) % cols\n                            seq.append(grid[new_r][new_c])\n                        sequences.append(''.join(seq))\n        return sequences\n\n    sequences = generate_sequences(grid)\n    sequence_counts = {}\n    for seq in sequences:\n        sequence_counts[seq] = sequence_counts.get(seq, 0) + 1\n\n    magic_spells = [seq for seq, count in sequence_counts.items() if count > 1]\n    \n    if not magic_spells:\n        return 0\n\n    max_length = max(len(spell) for spell in magic_spells)\n    longest_spells = [spell for spell in magic_spells if len(spell) == max_length]\n    \n    return min(longest_spells)",
    "timestamp": "2025-08-13 03:45:30"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def find_magic_spell(grid):\n    if not grid or not grid[0]:\n        return 0\n    \n    rows = len(grid)\n    cols = len(grid[0])\n    directions = [ (1, 0), (0, 1), (-1, 0), (0, -1), \n                  (1, 1), (1, -1), (-1, 1), (-1, -1) ]\n    \n    all_substrings = {}\n    \n    for i in range(rows):\n        for j in range(cols):\n            for di, dj in directions:\n                current_substrings = set()\n                x, y = i, j\n                path = []\n                for _ in range(rows * cols):\n                    path.append(grid[x][y])\n                    for l in range(1, len(path) + 1):\n                        substring = ''.join(path[-l:])\n                        if substring in current_substrings:\n                            continue\n                        current_substrings.add(substring)\n                        if substring in all_substrings:\n                            all_substrings[substring] += 1\n                        else:\n                            all_substrings[substring] = 1\n                    x = (x + di) % rows\n                    y = (y + dj) % cols\n    \n    candidates = []\n    max_len = 0\n    for s in all_substrings:\n        if all_substrings[s] > 1:\n            if len(s) > max_len:\n                max_len = len(s)\n                candidates = [s]\n            elif len(s) == max_len:\n                candidates.append(s)\n    \n    if not candidates:\n        return 0\n    \n    candidates.sort()\n    return candidates[0]",
    "timestamp": "2025-08-13 03:45:57"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint directions[8][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0},\n                        {1, 1}, {1, -1}, {-1, 1}, {-1, -1}};\n\nstring findLongestMagicSpell(vector<string>& grid) {\n    int n = grid.size();\n    set<string> spells;\n\n    auto isValid = [&](int x, int y) {\n        return x >= 0 && y >= 0 && x < n && y < n;\n    };\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            for (int d = 0; d < 8; ++d) {\n                string spell;\n                int x = i, y = j;\n                while (isValid(x, y)) {\n                    spell += grid[x][y];\n                    spells.insert(spell);\n                    x = (x + directions[d][0] + n) % n;\n                    y = (y + directions[d][1] + n) % n;\n                    if (x == i && y == j) break;\n                }\n            }\n        }\n    }\n\n    map<string, int> spellCount;\n    for (const auto& spell : spells) {\n        // Loop through all grid positions to count occurrences\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                for (int d = 0; d < 8; ++d) {\n                    int x = i, y = j;\n                    int k = 0;\n                    while (isValid(x, y) && k < spell.size() && grid[x][y] == spell[k]) {\n                        x = (x + directions[d][0] + n) % n;\n                        y = (y + directions[d][1] + n) % n;\n                        k++;\n                        if (x == i && y == j) break; // Complete one round\n                    }\n                    if (k == spell.size()) spellCount[spell]++;\n                }\n            }\n        }\n    }\n\n    string longestSpell;\n    for (const auto& it : spellCount) {\n        if (it.second > 1 && (it.first.size() > longestSpell.size() ||\n                              (it.first.size() == longestSpell.size() && it.first < longestSpell))) {\n            longestSpell = it.first;\n        }\n    }\n\n    return longestSpell.empty() ? \"0\" : longestSpell;\n}\n\nint main() {\n    vector<string> donutGrid = {\n        \"abc\",\n        \"def\",\n        \"ghi\"\n    };\n\n    cout << findLongestMagicSpell(donutGrid) << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:14:54"
  }
]