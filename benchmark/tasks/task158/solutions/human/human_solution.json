[
  {
    "language": "Scala",
    "code": "import scala.annotation.tailrec\nimport net.pushl.io.MyConsole\n\n// Document: http://www.scala-lang.org/api/current/#package\n// -----------------------------------------------------------------------------\nclass Solver(val stdio: MyConsole){\n  import stdio._ // shadow Console.~\n                 // val diff = List((-1,0),(1,0),(0,-1),(0,1))\n  val diff = (for(i <- -1 to 1;\n                  j <- -1 to 1;\n                  if i != 0 || j != 0) yield (i,j)).toList\n\n  def go(fil: Array[Array[Option[Int]]], will_remove: List[(Int,Int)]) : Int =\n    if(will_remove.length == 0)\n      0\n    else\n      1 + go(fil, goaux(fil, will_remove))\n\n  def goaux(fil: Array[Array[Option[Int]]], will_remove: List[(Int,Int)]) : List[(Int,Int)] = {\n    val he = fil.length\n    val we = fil(0).length\n    will_remove match {\n      case Nil    => Nil\n      case h :: t => h match {\n        case (r,c) => {\n          val inner = diff.map({case (dy,dx) => (r+dy,c+dx)}).filter({case (y,x) => 0 <= y && y < he && 0 <= x && x < we})\n          val out   = inner.map({case (i,j) => {\n                                   fil(i)(j) match {\n                                     case None    => None\n                                     case Some(k) => {\n                                       if(k == 1){\n                                         fil(i)(j) = None\n                                         Some((i,j))\n                                       }else{\n                                         fil(i)(j) = Some(k-1)\n                                         None\n                                       }\n                                     }\n                                   }\n                                 }}).collect({case Some(k) => k})\n          out ++ goaux(fil,t)\n        }\n      }\n    }\n  }\n  def main() : Unit = {\n    val h,w = nextInt\n    val fil = (1 to h).map(_ => readLine.map(c =>\n                             if(c == '.') None\n                             else         Some(c - '0')))\n\n    val copy = (fil map (_.toArray)).toArray\n    val rem  = (fil.zipWithIndex).flatMap({case (row,i) =>\n                                            row.zipWithIndex.collect({case (content,j) if content == None =>\n                                                                       (i,j)})}).toList\n    println(go(copy,rem)-1)\n  }\n}\n\n\n\n\n\n\n\n\n\n// ----------------------------------------------------------------------------0\n// ----------------------------------------------------------------------------0\nobject Main {\n  def main(args: Array[String]) : Unit = {\n    val console = new MyConsole(Console.in, Console.out, Console.err)\n    val solver  = new Solver(console)\n    solver.main()\n    console.flush()\n  }\n}\npackage net.pushl.io {\n  import java.io.{BufferedReader, PrintWriter, PrintStream, PushbackReader}\n  class MyConsole(val in: BufferedReader, val _out: PrintStream,\n                  val err: PrintStream) {\n    // PrintWriter do not flush automatically\n    val out = new PrintWriter(_out,false)\n    // If argument is null, there are ambiguous which function will be called\n    def print(obj: Any)                  = out.print(if(obj == null) \"null\" else obj.toString)\n    def println()                        = out.println()\n    def println(obj: Any)                = out.println(obj)\n    def printf(text: String, args: Any*) = out.printf(text.format(args : _*))\n    // NOTE: YOU MUST FLUSH BEFORE END OF MAIN\n    def flush()                          = out.flush()\n    def debugln(obj: Any)                = err.println(obj)\n\n    def readIntVector()    : Vector[Int]    = parseLineToVector(() => nextInt)\n    def readLongVector()   : Vector[Long]   = parseLineToVector(() => nextLong)\n    def readStringVector() : Vector[String] = parseLineToVector(() => nextString)\n    def nextInt()          : Int            = nextLong().toInt\n    def nextBigInt()       : BigInt         = BigInt(nextString())\n    def nextBigDecimal(  ) : BigDecimal     = BigDecimal(nextString())\n    def nextDouble()       : Double         = nextString().toDouble\n    def nextLong() : Long = {\n      if(!goNextValuable())\n        throw new NoSuchElementException(\"Reading long failed\")\n      val sgn = if(peek == '-') -1l else 1\n      if(sgn == -1l) read()\n      if(peek < '0' || '9' < peek)\n        throw new NumberFormatException(s\"readLong found only '-' or no number\")\n      @tailrec\n      def readLong(next: Int, cur: Long) : Long =\n        if('0' <= next && next <= '9')\n          readLong(readWithoutCheckingPeeked(), cur*10 + next-'0')\n        else if(isEnd(next) || isSpaceOrControl(next))\n          sgn*cur\n        else\n          throw new NumberFormatException(s\"readLong found strange byte $next\")\n      val res = readLong(read(),0)\n      skipTrailingSpaces()\n      res\n    }\n    def nextString() : String = {\n      if(!goNextValuable())\n        throw new NoSuchElementException(\"Reading String failed\")\n      val builder = new StringBuilder\n      @tailrec\n      def appendCode(next: Int) : String = {\n        if(isEnd(next) || isSpaceOrControl(next)){\n          builder.toString\n        }else{\n          builder.append(next.toChar)\n          appendCode(readWithoutCheckingPeeked())\n        }\n      }\n      val res = appendCode(read())\n      skipTrailingSpaces()\n      res\n    }\n    // TODO: refactoring to marge nextString\n    def readLine() : String = {\n      if(isEnd(peek))\n        throw new NoSuchElementException(\"Reading Line failed\")\n      val builder = new StringBuilder\n      @tailrec\n      def appendCode(next: Int) : String = {\n        if(isEnd(next) || isNewLine(next)){\n          builder.toString\n        }else{\n          builder.append(next.toChar)\n          appendCode(read())\n        }\n      }\n      appendCode(read())\n    }\n    // helpers\n    private[this] var peeked: Option[Int] = None\n    private[this] var last = -1\n    private def read() = {\n      val res = peeked match {\n          case None    => in.read()\n          case Some(a) => { peeked = None; a }\n        }\n      last = res\n      res\n    }\n    @inline private def readWithoutCheckingPeeked() = {\n      val res = in.read()\n      last = res\n      res\n    }\n    @inline private def peek() =\n      peeked match {\n        case None    => {\n          val res = in.read()\n          peeked  = Some(res)\n          res\n        }\n        case Some(a) => a\n      }\n    @inline private def isEnd(c: Int)    = c == -1\n    @inline private def isNewLine(c: Int) = c == 10 || c == 13     // LF and CR\n    @inline private def isThereReadable() = !isEnd(peek)\n    // XXX: this limits c is ASCII?\n    @inline private def isSpaceOrControl(c: Int) = (0 <= c && c <= 32) || c == 127\n    @tailrec\n    final private def goNextNotSpaceNorControl() : Unit =\n      if(isSpaceOrControl(peek)){\n        read()\n        goNextNotSpaceNorControl()\n      }\n    final private def skipTrailingSpaces() : Unit = {\n      @tailrec\n      def skipTrailingSpacesAux() : Unit = {\n        if(!isNewLine(last) && !isNewLine(peek) && isSpaceOrControl(peek)){\n          read()\n          skipTrailingSpacesAux()\n        }\n      }\n      skipTrailingSpacesAux\n      if(!isNewLine(last) && isNewLine(peek)) read()\n    }\n    @tailrec\n    final private def skipTrailingSpacesAndNewline() : Unit =\n      if(isNewLine(peek)){\n        val _ = read() // windows causes error. maybe.\n      }else if(isSpaceOrControl(peek)){\n        read()\n        skipTrailingSpacesAndNewline()\n      }\n    @inline private def goNextValuable() = {\n      goNextNotSpaceNorControl()\n      isThereReadable()\n    }\n    @inline private def parseLineToVector[X](parser: () => X) : Vector[X] = {\n      import scala.collection.immutable.VectorBuilder\n      val vb = new VectorBuilder[X]()\n      @tailrec\n      def parseLineToVectorAux(first: Boolean=false) : Vector[X] =\n        if((!first && isNewLine(last)) || isNewLine(peek) || isEnd(peek)) {\n          vb.result\n        }else{\n          vb += parser()\n          parseLineToVectorAux()\n        }\n      parseLineToVectorAux(true)\n    }\n  }\n}"
  },
  {
    "language": "Scala",
    "code": "import scala.annotation.tailrec\nimport net.pushl.io.MyConsole\n\n// Document: http://www.scala-lang.org/api/current/#package\n// -----------------------------------------------------------------------------\nclass Solver(val stdio: MyConsole){\n  import stdio._ // shadow Console.~\n                 // val diff = List((-1,0),(1,0),(0,-1),(0,1))\n  val diff = (for(i <- -1 to 1;\n                  j <- -1 to 1;\n                  if i != 0 || j != 0) yield (i,j)).toList\n\n  def go(fil: Array[Array[Option[Int]]], will_remove: List[(Int,Int)]) : Int =\n    if(will_remove.length == 0)\n      0\n    else\n      1 + go(fil, goaux(fil, will_remove))\n\n  def goaux(fil: Array[Array[Option[Int]]], will_remove: List[(Int,Int)]) : List[(Int,Int)] = {\n    val he = fil.length\n    val we = fil(0).length\n    will_remove match {\n      case Nil    => Nil\n      case h :: t => h match {\n        case (r,c) => {\n          val inner = diff.map({case (dy,dx) => (r+dy,c+dx)}).filter({case (y,x) => 0 <= y && y < he && 0 <= x && x < we})\n          val out   = inner.map({case (i,j) => {\n                                   fil(i)(j) match {\n                                     case None    => None\n                                     case Some(k) => {\n                                       if(k == 1){\n                                         fil(i)(j) = None\n                                         Some((i,j))\n                                       }else{\n                                         fil(i)(j) = Some(k-1)\n                                         None\n                                       }\n                                     }\n                                   }\n                                 }}).collect({case Some(k) => k})\n          out ++ goaux(fil,t)\n        }\n      }\n    }\n  }\n  def main() : Unit = {\n    val h,w = nextInt\n    val fil = (1 to h).map(_ => readLine.map(c =>\n                             if(c == '.') None\n                             else         Some(c - '0')))\n\n    val copy = (fil map (_.toArray)).toArray\n    val rem  = (fil.zipWithIndex).flatMap({case (row,i) =>\n                                            row.zipWithIndex.collect({case (content,j) if content == None =>\n                                                                       (i,j)})}).toList\n    println(go(copy,rem))\n  }\n}\n\n\n\n\n\n\n\n\n\n// ----------------------------------------------------------------------------0\n// ----------------------------------------------------------------------------0\nobject Main {\n  def main(args: Array[String]) : Unit = {\n    val console = new MyConsole(Console.in, Console.out, Console.err)\n    val solver  = new Solver(console)\n    solver.main()\n    console.flush()\n  }\n}\npackage net.pushl.io {\n  import java.io.{BufferedReader, PrintWriter, PrintStream, PushbackReader}\n  class MyConsole(val in: BufferedReader, val _out: PrintStream,\n                  val err: PrintStream) {\n    // PrintWriter do not flush automatically\n    val out = new PrintWriter(_out,false)\n    // If argument is null, there are ambiguous which function will be called\n    def print(obj: Any)                  = out.print(if(obj == null) \"null\" else obj.toString)\n    def println()                        = out.println()\n    def println(obj: Any)                = out.println(obj)\n    def printf(text: String, args: Any*) = out.printf(text.format(args : _*))\n    // NOTE: YOU MUST FLUSH BEFORE END OF MAIN\n    def flush()                          = out.flush()\n    def debugln(obj: Any)                = err.println(obj)\n\n    def readIntVector()    : Vector[Int]    = parseLineToVector(() => nextInt)\n    def readLongVector()   : Vector[Long]   = parseLineToVector(() => nextLong)\n    def readStringVector() : Vector[String] = parseLineToVector(() => nextString)\n    def nextInt()          : Int            = nextLong().toInt\n    def nextBigInt()       : BigInt         = BigInt(nextString())\n    def nextBigDecimal(  ) : BigDecimal     = BigDecimal(nextString())\n    def nextDouble()       : Double         = nextString().toDouble\n    def nextLong() : Long = {\n      if(!goNextValuable())\n        throw new NoSuchElementException(\"Reading long failed\")\n      val sgn = if(peek == '-') -1l else 1\n      if(sgn == -1l) read()\n      if(peek < '0' || '9' < peek)\n        throw new NumberFormatException(s\"readLong found only '-' or no number\")\n      @tailrec\n      def readLong(next: Int, cur: Long) : Long =\n        if('0' <= next && next <= '9')\n          readLong(readWithoutCheckingPeeked(), cur*10 + next-'0')\n        else if(isEnd(next) || isSpaceOrControl(next))\n          sgn*cur\n        else\n          throw new NumberFormatException(s\"readLong found strange byte $next\")\n      val res = readLong(read(),0)\n      skipTrailingSpaces()\n      res\n    }\n    def nextString() : String = {\n      if(!goNextValuable())\n        throw new NoSuchElementException(\"Reading String failed\")\n      val builder = new StringBuilder\n      @tailrec\n      def appendCode(next: Int) : String = {\n        if(isEnd(next) || isSpaceOrControl(next)){\n          builder.toString\n        }else{\n          builder.append(next.toChar)\n          appendCode(readWithoutCheckingPeeked())\n        }\n      }\n      val res = appendCode(read())\n      skipTrailingSpaces()\n      res\n    }\n    // TODO: refactoring to marge nextString\n    def readLine() : String = {\n      if(isEnd(peek))\n        throw new NoSuchElementException(\"Reading Line failed\")\n      val builder = new StringBuilder\n      @tailrec\n      def appendCode(next: Int) : String = {\n        if(isEnd(next) || isNewLine(next)){\n          builder.toString\n        }else{\n          builder.append(next.toChar)\n          appendCode(read())\n        }\n      }\n      appendCode(read())\n    }\n    // helpers\n    private[this] var peeked: Option[Int] = None\n    private[this] var last = -1\n    private def read() = {\n      val res = peeked match {\n          case None    => in.read()\n          case Some(a) => { peeked = None; a }\n        }\n      last = res\n      res\n    }\n    @inline private def readWithoutCheckingPeeked() = {\n      val res = in.read()\n      last = res\n      res\n    }\n    @inline private def peek() =\n      peeked match {\n        case None    => {\n          val res = in.read()\n          peeked  = Some(res)\n          res\n        }\n        case Some(a) => a\n      }\n    @inline private def isEnd(c: Int)    = c == -1\n    @inline private def isNewLine(c: Int) = c == 10 || c == 13     // LF and CR\n    @inline private def isThereReadable() = !isEnd(peek)\n    // XXX: this limits c is ASCII?\n    @inline private def isSpaceOrControl(c: Int) = (0 <= c && c <= 32) || c == 127\n    @tailrec\n    final private def goNextNotSpaceNorControl() : Unit =\n      if(isSpaceOrControl(peek)){\n        read()\n        goNextNotSpaceNorControl()\n      }\n    final private def skipTrailingSpaces() : Unit = {\n      @tailrec\n      def skipTrailingSpacesAux() : Unit = {\n        if(!isNewLine(last) && !isNewLine(peek) && isSpaceOrControl(peek)){\n          read()\n          skipTrailingSpacesAux()\n        }\n      }\n      skipTrailingSpacesAux\n      if(!isNewLine(last) && isNewLine(peek)) read()\n    }\n    @tailrec\n    final private def skipTrailingSpacesAndNewline() : Unit =\n      if(isNewLine(peek)){\n        val _ = read() // windows causes error. maybe.\n      }else if(isSpaceOrControl(peek)){\n        read()\n        skipTrailingSpacesAndNewline()\n      }\n    @inline private def goNextValuable() = {\n      goNextNotSpaceNorControl()\n      isThereReadable()\n    }\n    @inline private def parseLineToVector[X](parser: () => X) : Vector[X] = {\n      import scala.collection.immutable.VectorBuilder\n      val vb = new VectorBuilder[X]()\n      @tailrec\n      def parseLineToVectorAux(first: Boolean=false) : Vector[X] =\n        if((!first && isNewLine(last)) || isNewLine(peek) || isEnd(peek)) {\n          vb.result\n        }else{\n          vb += parser()\n          parseLineToVectorAux()\n        }\n      parseLineToVectorAux(true)\n    }\n  }\n}"
  },
  {
    "language": "Scala",
    "code": "import scala.annotation.tailrec\nimport net.pushl.io.MyConsole\n\n// Document: http://www.scala-lang.org/api/current/#package\n// -----------------------------------------------------------------------------\nclass Solver(val stdio: MyConsole){\n  import stdio._ // shadow Console.~\n                 // val diff = List((-1,0),(1,0),(0,-1),(0,1))\n  val diff = (for(i <- -1 to 1;\n                  j <- -1 to 1;\n                  if i != 0 || j != 0) yield (i,j)).toList\n\n  @tailrec\n  final def go(fil: Array[Array[Option[Int]]], will_remove: List[(Int,Int)], ans: Int = 0) : Int =\n    if(will_remove.length == 0)\n      ans\n    else\n      go(fil, goaux(fil, will_remove), 1 + ans)\n\n  def goaux(fil: Array[Array[Option[Int]]], will_remove: List[(Int,Int)]) : List[(Int,Int)] = {\n    val he = fil.length\n    val we = fil(0).length\n    will_remove match {\n      case Nil    => Nil\n      case h :: t => h match {\n        case (r,c) => {\n          val inner = diff.map({case (dy,dx) => (r+dy,c+dx)}).filter({case (y,x) => 0 <= y && y < he && 0 <= x && x < we})\n          val out   = inner.map({case (i,j) => {\n                                   fil(i)(j) match {\n                                     case None    => None\n                                     case Some(k) => {\n                                       if(k == 1){\n                                         fil(i)(j) = None\n                                         Some((i,j))\n                                       }else{\n                                         fil(i)(j) = Some(k-1)\n                                         None\n                                       }\n                                     }\n                                   }\n                                 }}).collect({case Some(k) => k})\n          out ++ goaux(fil,t)\n        }\n      }\n    }\n  }\n  def main() : Unit = {\n    val h,w = nextInt\n    val fil = (1 to h).map(_ => readLine.map(c =>\n                             if(c == '.') None\n                             else         Some(c - '0')))\n\n    val copy = (fil map (_.toArray)).toArray\n    val rem  = (fil.zipWithIndex).flatMap({case (row,i) =>\n                                            row.zipWithIndex.collect({case (content,j) if content == None =>\n                                                                       (i,j)})}).toList\n    println(go(copy,rem)-1)\n  }\n}\n\n\n\n\n\n\n\n\n\n// ----------------------------------------------------------------------------0\n// ----------------------------------------------------------------------------0\nobject Main {\n  def main(args: Array[String]) : Unit = {\n    val console = new MyConsole(Console.in, Console.out, Console.err)\n    val solver  = new Solver(console)\n    solver.main()\n    console.flush()\n  }\n}\npackage net.pushl.io {\n  import java.io.{BufferedReader, PrintWriter, PrintStream, PushbackReader}\n  class MyConsole(val in: BufferedReader, val _out: PrintStream,\n                  val err: PrintStream) {\n    // PrintWriter do not flush automatically\n    val out = new PrintWriter(_out,false)\n    // If argument is null, there are ambiguous which function will be called\n    def print(obj: Any)                  = out.print(if(obj == null) \"null\" else obj.toString)\n    def println()                        = out.println()\n    def println(obj: Any)                = out.println(obj)\n    def printf(text: String, args: Any*) = out.printf(text.format(args : _*))\n    // NOTE: YOU MUST FLUSH BEFORE END OF MAIN\n    def flush()                          = out.flush()\n    def debugln(obj: Any)                = err.println(obj)\n\n    def readIntVector()    : Vector[Int]    = parseLineToVector(() => nextInt)\n    def readLongVector()   : Vector[Long]   = parseLineToVector(() => nextLong)\n    def readStringVector() : Vector[String] = parseLineToVector(() => nextString)\n    def nextInt()          : Int            = nextLong().toInt\n    def nextBigInt()       : BigInt         = BigInt(nextString())\n    def nextBigDecimal(  ) : BigDecimal     = BigDecimal(nextString())\n    def nextDouble()       : Double         = nextString().toDouble\n    def nextLong() : Long = {\n      if(!goNextValuable())\n        throw new NoSuchElementException(\"Reading long failed\")\n      val sgn = if(peek == '-') -1l else 1\n      if(sgn == -1l) read()\n      if(peek < '0' || '9' < peek)\n        throw new NumberFormatException(s\"readLong found only '-' or no number\")\n      @tailrec\n      def readLong(next: Int, cur: Long) : Long =\n        if('0' <= next && next <= '9')\n          readLong(readWithoutCheckingPeeked(), cur*10 + next-'0')\n        else if(isEnd(next) || isSpaceOrControl(next))\n          sgn*cur\n        else\n          throw new NumberFormatException(s\"readLong found strange byte $next\")\n      val res = readLong(read(),0)\n      skipTrailingSpaces()\n      res\n    }\n    def nextString() : String = {\n      if(!goNextValuable())\n        throw new NoSuchElementException(\"Reading String failed\")\n      val builder = new StringBuilder\n      @tailrec\n      def appendCode(next: Int) : String = {\n        if(isEnd(next) || isSpaceOrControl(next)){\n          builder.toString\n        }else{\n          builder.append(next.toChar)\n          appendCode(readWithoutCheckingPeeked())\n        }\n      }\n      val res = appendCode(read())\n      skipTrailingSpaces()\n      res\n    }\n    // TODO: refactoring to marge nextString\n    def readLine() : String = {\n      if(isEnd(peek))\n        throw new NoSuchElementException(\"Reading Line failed\")\n      val builder = new StringBuilder\n      @tailrec\n      def appendCode(next: Int) : String = {\n        if(isEnd(next) || isNewLine(next)){\n          builder.toString\n        }else{\n          builder.append(next.toChar)\n          appendCode(read())\n        }\n      }\n      appendCode(read())\n    }\n    // helpers\n    private[this] var peeked: Option[Int] = None\n    private[this] var last = -1\n    private def read() = {\n      val res = peeked match {\n          case None    => in.read()\n          case Some(a) => { peeked = None; a }\n        }\n      last = res\n      res\n    }\n    @inline private def readWithoutCheckingPeeked() = {\n      val res = in.read()\n      last = res\n      res\n    }\n    @inline private def peek() =\n      peeked match {\n        case None    => {\n          val res = in.read()\n          peeked  = Some(res)\n          res\n        }\n        case Some(a) => a\n      }\n    @inline private def isEnd(c: Int)    = c == -1\n    @inline private def isNewLine(c: Int) = c == 10 || c == 13     // LF and CR\n    @inline private def isThereReadable() = !isEnd(peek)\n    // XXX: this limits c is ASCII?\n    @inline private def isSpaceOrControl(c: Int) = (0 <= c && c <= 32) || c == 127\n    @tailrec\n    final private def goNextNotSpaceNorControl() : Unit =\n      if(isSpaceOrControl(peek)){\n        read()\n        goNextNotSpaceNorControl()\n      }\n    final private def skipTrailingSpaces() : Unit = {\n      @tailrec\n      def skipTrailingSpacesAux() : Unit = {\n        if(!isNewLine(last) && !isNewLine(peek) && isSpaceOrControl(peek)){\n          read()\n          skipTrailingSpacesAux()\n        }\n      }\n      skipTrailingSpacesAux\n      if(!isNewLine(last) && isNewLine(peek)) read()\n    }\n    @tailrec\n    final private def skipTrailingSpacesAndNewline() : Unit =\n      if(isNewLine(peek)){\n        val _ = read() // windows causes error. maybe.\n      }else if(isSpaceOrControl(peek)){\n        read()\n        skipTrailingSpacesAndNewline()\n      }\n    @inline private def goNextValuable() = {\n      goNextNotSpaceNorControl()\n      isThereReadable()\n    }\n    @inline private def parseLineToVector[X](parser: () => X) : Vector[X] = {\n      import scala.collection.immutable.VectorBuilder\n      val vb = new VectorBuilder[X]()\n      @tailrec\n      def parseLineToVectorAux(first: Boolean=false) : Vector[X] =\n        if((!first && isNewLine(last)) || isNewLine(peek) || isEnd(peek)) {\n          vb.result\n        }else{\n          vb += parser()\n          parseLineToVectorAux()\n        }\n      parseLineToVectorAux(true)\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//q5.cpp\n\n#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\ntypedef long long ll;\n\nusing namespace std;\n\nlong long h,w,ans,flag=0;\nchar m[1020][1020];\nbool mc[1020][1020];\n\nint check(int y,int x){\n    int c=0;\n    \n    for(int i=-1;i<=1;i++)\n        for(int j=-1;j<=1;j++)\n            if(m[y+i][x+j]=='.') c++;\n    \n    if((int)(m[y][x]-'0')<=c){\n        mc[y][x]=true;\n        return 1;\n    }\n    \n    return 0;\n}\n\nint main(){\n    scanf(\"%lld%lld\",&h,&w);\n    \n    for(int i=0;i<h;i++)\n        scanf(\"%s\",m[i]);\n    \n    do{\n        flag=0;\n        \n        for(int i=0;i<h;i++)\n            for(int j=0;j<w;j++)\n                mc[i][j]=false;\n        \n        for(int i=1;i<h-1;i++)\n            for(int j=1;j<w-1;j++)\n                if(m[i][j]!='.') flag+=check(i,j);\n        \n        for(int i=0;i<h;i++)\n            for(int j=0;j<w;j++)\n                if(mc[i][j]) m[i][j]='.';\n        \n        if(flag) ans++;\n        \n    }while(flag);\n    \n    printf(\"%lld\\n\",ans);\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <queue>\nusing namespace std;\nchar field[2000][2000];\nint dx[] = {1,1,1,0,0,-1,-1,-1};\nint dy[] = {1,0,-1,1,-1,1,0,-1};\nint x,y,d,ans;\nint main()\n{\n    queue<int> str[3];\n    int h,w;\n    char kara;\n    scanf(\"%d%d\",&h,&w);\n    ans = 0;\n    for(int i = 0; i < h; i++)\n    {\n        for(int j = 0; j < w + 1; j++)\n        {\n            scanf(\"%c\",&field[i][j]);\n        }\n    }\n    for(int i = 0; i < h; i++)\n    {\n        for(int j = 1; j < w + 1; j++)\n        {\n            if(field[i][j] == '.')\n            {\n                str[0].push(i);\n                str[1].push(j);\n                str[2].push(0);\n            }\n        }\n    }\n    while(str[0].size())\n    {\n        x = str[0].front();str[0].pop();\n        y = str[1].front();str[1].pop();\n        d = str[2].front();str[2].pop();\n        if(ans < d)ans = d;\n        for(int i = 0; i < 8; i++)\n        {\n            if(0 <= x + dx[i]&&x + dx[i] < w&&0 <= y + dy[i]&&y + dy[i] < h)\n            {\n                field[x + dx[i]][y + dy[i]]--;\n                if(field[x + dx[i]][y + dy[i]] == '0')\n                {\n                    str[0].push(x + dx[i]);\n                    str[1].push(y + dy[i]);\n                    str[2].push(d + 1);\n                }\n            }\n        }\n    }\n    printf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef pair<int,int>P;\n\nchar s[1000][1001];\nint d[1000][1000],cnt[1000][1000];\nint main(){\n\tint h,w;scanf(\"%d%d\",&h,&w);\n\trep(i,h)scanf(\"%s\",s[i]);\n\tint Max=0;\n\tqueue<P>que;\n\trep(i,h)rep(j,w){\n\t\tif(s[i][j]=='.')continue;\n\t\tfor(int k=-1;k<=1;k++){\n\t\t\tfor(int l=-1;l<=1;l++){\n\t\t\t\tint x=i+k,y=j+l;\n\t\t\t\tif(0<=x&&x<h&&0<=y&&y<w&&s[x][y]=='.')cnt[i][j]++;\n\t\t\t}\n\t\t}\n\t\tif(cnt[i][j]>=s[i][j]-'0'){\n\t\t\td[i][j]=Max=1;que.push(P(i,j));\n\t\t}\n\t}\n\twhile(!que.empty()){\n\t\tP p=que.front();que.pop();\n\t\tfor(int i=-1;i<=1;i++)for(int j=-1;j<=1;j++){\n\t\t\tint x=p.first+i,y=p.second+j;\n\t\t\tif(0<=x&&x<h&&0<=y&&y<w&&s[x][y]!='.'&&!d[x][y]){\n\t\t\t\tif(++cnt[x][y]>=s[x][y]-'0'){\n\t\t\t\t\td[x][y]=Max=d[p.first][p.second]+1;que.push(P(x,y));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",Max);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\nusing namespace std;\n\nint h, w;\nchar t[1001];\nvector<string> v;\nint dx[8] = {0, 1, 1, 1, 0, -1, -1, -1};\nint dy[8] = {-1, -1, 0, 1, 1, 1, 0, -1};\nint ans;\ntypedef pair<int, int> P;\n\nbool solve(){\n/*\n\tprintf(\"\\n\");\n\tfor(int i=0; i<h; i++){\n\t\tprintf(\"%s\\n\", v[i].c_str());\n\t}\n*/\n\tbool d = false;\n\tvector<P> u;\n\tfor(int i=1; i<w+1; i++){\n\t\tfor(int j=1; j<h+1; j++){\n\t\t\tif(v[i][j] != '.'){\n\t\t\t\tint c = 0;\n\t\t\t\tfor(int k=0; k<8; k++){\n\t\t\t\t\tint nx, ny;\n\t\t\t\t\tnx = i + dx[k];\n\t\t\t\t\tny = j + dy[k];\n\t\t\t\t\tif(v[nx][ny] == '.') c++;\n\t\t\t\t}\n\t\t\t\tif(v[i][j] - '0' <= c){\n\t\t\t\t\tu.push_back(P(i, j));\n\t\t\t\t\td = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0; i<u.size(); i++){\n\t\tv[u[i].first][u[i].second] = '.';\n\t}\n\tif(d) ans++;\n\treturn d;\n}\n\nint main(){\n\tscanf(\"%d %d\", &h, &w);\n\tfor(int i=0; i<h; i++){\n\t\tscanf(\"%s\", t);\n\t\tv.push_back(t);\n\t}\n\tbool f = true;\n\twhile(f){\n\t\tf = false;\n\t\tvector<P> u;\n\t\tfor(int i=1; i<w+1; i++){\n\t\t\tfor(int j=1; j<h+1; j++){\n\t\t\t\tif(v[i][j] != '.'){\n\t\t\t\t\tint c = 0;\n\t\t\t\t\tfor(int k=0; k<8; k++){\n\t\t\t\t\t\tint nx, ny;\n\t\t\t\t\t\tnx = i + dx[k];\n\t\t\t\t\t\tny = j + dy[k];\n\t\t\t\t\t\tif(v[nx][ny] == '.') c++;\n\t\t\t\t\t}\n\t\t\t\t\tif(v[i][j] - '0' <= c){\n\t\t\t\t\t\tu.push_back(P(i, j));\n\t\t\t\t\t\tf = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<u.size(); i++){\n\t\t\tv[u[i].first][u[i].second] = '.';\n\t\t}\n\t\tif(f) ans++;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstring>\nusing namespace std;\n   \n#define MAX 11\n   \nint main(){\n    string S;\n    int n,m,t,sum,a,p=0;\n    sum=0;\n    short x[MAX][MAX];\n    short z[MAX][MAX];\n    short v[MAX][MAX];\n    memset(x,0,sizeof(x));\n    memset(z,0,sizeof(z));\n    char T[10]={'.','1','2','3','4','5','6','7','8','9'};\n    cin>>n>>m;\n    for(int i=1;i<=n;i++){\n        cin>>S;\n        for(int j=1;j<=m;j++){\n            for(int k=0;k<10;k++){\n                if(S[j-1]==T[k]){\n                    x[i][j]=k;\n                    if(k==0){\n                        for(int l=-1;l<=1;l++){\n                            for(int o=-1;o<=1;o++){\n                                z[i+l][j+o] += 1;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    while(true){\n        t=0;\n        sum++;\n        for(int i=2;i<n;i++){\n            for(int j=2;j<m;j++){\n                if(x[i][j]>=1 && z[i][j]>=x[i][j]){\n                    v[i][j] += 1;\n                    t++;\n                    for(int l=-1;l<=1;l++){\n                        for(int o=-1;o<=1;o++){\n                            v[i+l][j+o]+= 10;\n                        }\n                    }\n                }\n            }\n        }\n        if(t==0){\n            break;\n        }\n        for(int i=2;i<n;i++){\n            for(int j=2;j<m;j++){\n                if(v[i][j]%10>=1){\n                    x[i][j]=0;\n                }\n                z[i][j] += v[i][j]/10;\n                v[i][j]=0;\n            }\n        }\n    }\n    cout<<sum-1<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define Rep(i, a, b) for(int i = (a); i < (b); i++)\n#define rep(i, n) Rep(i, 0, n)\n\nint movX[8] = {-1, 0, 1,-1, 1,-1, 0, 1};\nint movY[8] = {-1,-1,-1, 0, 0, 1, 1, 1};\ntypedef pair<int, int> pii;\n\ntemplate<class T> T read() {\n\tT t;\n\tcin >> t;\n\treturn t;\n}\n\nint main(){\n\tint h=read<int>(),w=read<int>();\n\tint mp[h][w];\n\trep(i,h) rep(j,w){\n\t\tchar c=read<char>();\n\t\tif(c=='.'){\n\t\t\tmp[i][j]=0;\n\t\t}else{\n\t\t\tmp[i][j]=c-'0';\n\t\t}\n\t}\n\tint around[h][w];\n\tRep(i, 1, h-1){\n\t\tRep(j, 1, w-1){\n\t\t\tint a = 0;\n\t\t\trep(k,8) {\n\t\t\t\tint x = i+movX[k];\n\t\t\t\tint y = j+movY[k];\n\t\t\t\tif(!mp[x][y]){\n\t\t\t\t\ta++;\n\t\t\t\t}\n\t\t\t}\n\t\t\taround[i][j]=a;\n\t\t}\n\t}\n\t\n\t\n\tvector<pii> list;\n\tRep(i, 1, h-1){\n\t\tRep(j, 1, w-1){\n\t\t\tif(mp[i][j]>0 && around[i][j]>=mp[i][j]){\n\t\t\t\tlist.push_back(pii(i,j)); \n\t\t\t}\n\t\t}\n\t}\n\tif(list.size()==0){\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\tfor(vector<pii>::iterator it=list.begin();it!=list.end();it++){\n\t\tint i = it->first, j = it->second;\n\t\tmp[i][j] = 0;\n\t\trep(k,8) {\n\t\t\tint x = i+movX[k];\n\t\t\tint y = j+movY[k];\n\t\t\taround[x][y]++;\n\t\t}\n\t\t// printf(\"(%d, %d)\\n\",i,j);\n\t}\n\t// printf(\"=============\\n\");\n\t\n\tint count = 1;\n\twhile(true){\n\t\tvector<pii> list2;\n\t\tfor(vector<pii>::iterator it=list.begin();it!=list.end();it++){\n\t\t\tint i = it->first, j = it->second;\n\t\t\t// cout << i << \" \" << j << endl;\n\t\t\trep(k,8) {\n\t\t\t\tint x = i+movX[k];\n\t\t\t\tint y = j+movY[k];\n\t\t\t\tif(mp[x][y]>0 && around[x][y]>=mp[x][y]){\n\t\t\t\t\tlist2.push_back(pii(x,y));\n\t\t\t\t\t// cout << \"    \" <<  i << \" \" << j << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(list2.size()==0){\n\t\t\tcout << count << endl;\n\t\t\treturn 0;\n\t\t}\n//\t\tcout << list2.size() << endl;\n\t\tcount++;\n\t\tvector<pii> list3;\n\t\tfor(vector<pii>::iterator it=list2.begin();it!=list2.end();it++){\n\t\t\tint i = it->first, j = it->second;\n\t\t\tif(mp[i][j]){\n\t\t\t\tlist3.push_back(*it);\n\t\t\t\tmp[i][j] = 0;\n\t\t\t\trep(k,8) {\n\t\t\t\t\tint x = i+movX[k];\n\t\t\t\t\tint y = j+movY[k];\n\t\t\t\t\taround[x][y]++;\n\t\t\t\t}\n\t\t\t\t// printf(\"(%d, %d)\\n\",i,j);\n\t\t\t}\n\t\t}\n\t\t// printf(\"=============\\n\");\n\t\tstd::vector<pii>().swap(list);\n\t\tstd::vector<pii>().swap(list2);\n\t\tlist = list3;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\nint x, y;\nchar map[1024][1024];\nqueue< pair<int,int> > q;\n\nbool check_map(void){\n\tbool flg = true;\n\tint dx[8] = { 0, 0, 1, -1, 1, -1, 1, -1 }, dy[8] = { 1, -1, 0, 0, 1, -1, -1, 1 };\n\tfor(int i = 0; i < y; i++){\n\t\tfor(int i2 = 0; i2 < x; i2++){\n\t\t\tint cnt = 0;\n\t\t\tif( map[i][i2] != '.' ){\n\t\t\t\tfor(int i3 = 0; i3 < 8; i3++){\n\t\t\t\t\tif(map[ i + dy[i3] ][ i2 + dx[i3] ] == '.'){\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tchar temp = map[i][i2];\n\t\t\t\tif(cnt >= atoi(&temp)){\n\t\t\t\t\tq.push(make_pair(i, i2));\n\t\t\t\t\tflg = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn flg;\n}\n\nint main(){\n\tint cnt = 0;\n\tcin >> y >> x;\n\n\tfor(int i = 0; i < y; i++){\n\t\tfor(int i2 = 0; i2 < x; i2++){\n\t\t\tcin >> map[i][i2];\n\t\t}\n\t}\n\n\twhile(!check_map()){\n\t\twhile(!q.empty()){\n\t\t\tpair<int, int> temp = q.front();\n\t\t\tq.pop();\n\t\t\tmap[temp.first][temp.second] = '.';\n\t\t}\n\t\tcnt++;\n\t}\n\tcout << cnt << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n#define size_of(a) (int)(a).size()\n\ntypedef pair< int, int > pii;\n\nconst int dx[8] = {0,1,1,1,0,-1,-1,-1}, dy[8] = {-1,-1,0,1,1,1,0,-1};\n\nconst int MASK = (1 << 15) - 1;\nconst int SHIFT = 15;\n\nint H, W, counter[1010][1010];\nstring grid[1010];\n\nint main() {\n\tcin >> H >> W;\n\tfor_(i,0,H) cin >> grid[i];\n\t\n\tqueue< pii > cur_que;\n\t\n\tfor_(y,0,H) for_(x,0,W) {\n\t\tcounter[y][x] = 0;\n\t\tif (grid[y][x] == '.') continue;\n\t\tcounter[y][x] = grid[y][x] - '0';\n\t\t\n\t\tfor_(d,0,8) {\n\t\t\tint xx = x + dx[d], yy = y + dy[d];\n\t\t\tif (grid[yy][xx] == '.') --counter[y][x];\n\t\t}\n\t\t\n\t\tif (counter[y][x] == 0) cur_que.push(pii(x, y));\n\t}\n\t\n\tqueue< pii > nxt_que;\n\t\n\tint ans = 0;\n\t\n\twhile (!cur_que.empty()) {\n\t\twhile (!cur_que.empty()) {\n\t\t\tpii p = cur_que.front(); cur_que.pop();\n\t\t\tint x = p.first, y = p.second;\n\t\t\t\n\t\t\tfor_(d,0,8) {\n\t\t\t\tint xx = x + dx[d], yy = y + dy[d];\n\t\t\t\t--counter[yy][xx];\n\t\t\t\tif (counter[yy][xx] == 0) nxt_que.push(pii(xx, yy));\n\t\t\t}\n\t\t}\n\t\t\n\t\t++ans;\n\t\tswap(cur_que, nxt_que);\n\t}\n\t\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n#define INF 2000000000\n\n#define MAX_H 1050\n#define MAX_W 1050\n\nint H, W;\n\nchar sand[MAX_H][MAX_W];\n\nint dp[MAX_H][MAX_W];\n\nconst int dx[8] = { -1, -1, -1, 0, 0, 1, 1, 1 };\nconst int dy[8] = { -1, 0, 1, -1, 1, -1, 0, 1 };\n\nbool dfs[MAX_H][MAX_W];\n\nvoid memo(int x, int y)\n{\n\tdfs[y][x] = true;\n\n\tif (dp[y][x] > 1 && x > 0 && x < W - 1 && y > 0 && y < H - 1)\n\t{\n\t\tint temp[8];\n\n\t\tfor (int dir = 0; dir < 8; dir++)\n\t\t{\n\t\t\ttemp[dir] = dp[y + dy[dir]][x + dx[dir]];\n\t\t}\n\n\t\tsort(temp, temp + 8);\n\n\t\tif (sand[y][x] != '9')\n\t\t{\n\t\t\tif (temp[sand[y][x] - 49] != INF)\n\t\t\t{\n\t\t\t\tdp[y][x] = temp[sand[y][x] - 49] + 1;\n\t\t\t}\n\n\t\t\tif (dp[y][x] < INF)\n\t\t\t{\n\t\t\t\tfor (int dir = 0; dir < 8; dir++)\n\t\t\t\t{\n\t\t\t\t\tif (dfs[y + dy[dir]][x + dx[dir]] == false)\n\t\t\t\t\t{\n\t\t\t\t\t\tmemo(x + dx[dir], y + dy[dir]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tmemset(dp, 0, sizeof(dp));\n\n\tcin >> H >> W;\n\n\tfor (int i = 0; i < H; i++)\n\t{\n\t\tfor (int j = 0; j < W; j++)\n\t\t{\n\t\t\tcin >> sand[i][j];\n\n\t\t\tif (sand[i][j] != '.')\n\t\t\t{\n\t\t\t\tdp[i][j] = INF;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 1; i < H - 1; i++)\n\t{\n\t\tfor (int j = 1; j < W - 1; j++)\n\t\t{\n\t\t    for(int i1 = 0; i1 < H; i1++)\n\t\t    {\n\t\t        for(int j1 = 0; j1 < W; j1++)\n\t\t        {\n\t\t            if(dfs[i1][j1] == true)\n\t\t            {\n\t\t                dfs[i1][j1] = false;\n\t\t            }\n\t\t        }\n\t\t    }\n\t\t    \n\t\t\tmemo(j, i);\n\t\t}\n\t}\n\n\tint maxdepth = 0;\n\n\tfor (int i = 1; i < H - 1; i++)\n\t{\n\t\tfor (int j = 1; j < W - 1; j++)\n\t\t{\n\t\t\tif (dp[i][j] < INF)\n\t\t\t{\n\t\t\t\tmaxdepth = max(dp[i][j], maxdepth);\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << maxdepth << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define loop(i,n) for(int i=1;i<=n;i++)\nchar sh[1002][1002];\nbool houkai[1002][1002];\n\nint main() {\n  int h,w;\n  cin>>h>>w;\n  loop(i,h)loop(j,w)cin>>sh[i][j];\n  bool changed=1;\n  int res=0;\n  while(changed){\n    changed=0;\n    loop(i,h)loop(j,w){\n      if(i==1||i==h||j==1||j==w)continue;\n      if(sh[i][j]=='.')continue;\n      int kyoudo=(int)(sh[i][j]-'0');\n      int dir[9]={0,-1,-1,0,1,1,-1,1,0};\n      int sara=0;\n      loop(d,8){\n        int x=i+dir[d-1];\n        int y=j+dir[d];\n        if(sh[x][y]=='.')sara++;\n      }\n      if(sara>=kyoudo){\n        changed=1;\n        houkai[i][j]=1;\n      }\n    }\n    loop(i,h)loop(j,w){\n      if(houkai[i][j]){\n        sh[i][j]='.';\n        houkai[i][j]=0;\n      }\n    }\n    if(changed)res++;\n  }\n  cout<<res<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\nint x, y;\nchar m[1024][1024];\nqueue<pair<int, int>> q;\n\nbool check_map() {\n\tbool flg = true;\n\tfor (int i = 0; i < y; i++) {\n\t\tfor (int i1 = 0; i1 < x; i1++) {\n\t\t\tint cnt = 0;\n\t\t\tif (m[i][i1] != '.') {\n\t\t\t\tint dx[8] = { 0, 0, 1, -1, 1, -1, 1, -1 }, dy[8] = { 1, -1, 0, 0, -1, -1, 1, 1 };\n\t\t\t\tfor (int i2 = 0; i2 < 8; i2++) {\n\t\t\t\t\tif (m[i + dy[i2]][i1 + dx[i2]] == '.') {\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tchar temp = m[i][i1];\n\t\t\t\tif (cnt >= atoi(&temp)) {\n\t\t\t\t\tq.push(make_pair(i, i1));\n\t\t\t\t\tflg = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn flg;\n}\n\nint main()\n{\n\tint cnt = 0;\n\tcin >> y >> x;\n\n\tfor (int i = 0; i < y; i++) {\n\t\tfor (int i1 = 0; i1 < x; i1++) {\n\t\t\tcin >> m[i][i1];\n\t\t}\n\t}\n\n\twhile (!check_map()) {\n\t\twhile (!q.empty()) {\n\t\t\tpair<int, int> temp = q.front();\n\t\t\tq.pop();\n\t\t\tm[temp.first][temp.second] = '.';\n\t\t}\n\t\tcnt++;\n\t}\n\n\tcout << cnt << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n#define INF 2000000000\n\n#define MAX_H 1050\n#define MAX_W 1050\n\nint H, W;\n\nchar sand[MAX_H][MAX_W];\n\nint dp[MAX_H][MAX_W];\n\nconst int dx[8] = { -1, -1, -1, 0, 0, 1, 1, 1 };\nconst int dy[8] = { -1, 0, 1, -1, 1, -1, 0, 1 };\n\nvoid memo(int x, int y)\n{\n\tif (dp[y][x] == INF && x > 0 && x < W - 1 && y > 0 && y < H - 1)\n\t{\n\t\tint temp[8];\n\n\t\tfor (int dir = 0; dir < 8; dir++)\n\t\t{\n\t\t\ttemp[dir] = dp[y + dy[dir]][x + dx[dir]];\n\t\t}\n\n\t\tsort(temp, temp + 8);\n\n\t\tif (sand[y][x] != '9')\n\t\t{\n\t\t\tif (temp[sand[y][x] - 49] != INF)\n\t\t\t{\n\t\t\t\tdp[y][x] = temp[sand[y][x] - 49] + 1;\n\t\t\t}\n\n\t\t\tif (dp[y][x] < INF)\n\t\t\t{\n\t\t\t\tfor (int dir = 0; dir < 8; dir++)\n\t\t\t\t{\n\t\t\t\t\tmemo(x + dx[dir], y + dy[dir]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tmemset(dp, 0, sizeof(dp));\n\n\tcin >> H >> W;\n\n\tfor (int i = 0; i < H; i++)\n\t{\n\t\tfor (int j = 0; j < W; j++)\n\t\t{\n\t\t\tcin >> sand[i][j];\n\n\t\t\tif (sand[i][j] != '.')\n\t\t\t{\n\t\t\t\tdp[i][j] = INF;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 1; i < H - 1; i++)\n\t{\n\t\tfor (int j = 1; j < W - 1; j++)\n\t\t{\n\t\t\tmemo(j, i);\n\t\t}\n\t}\n\n\tint maxdepth = 0;\n\n\tfor (int i = 1; i < H - 1; i++)\n\t{\n\t\tfor (int j = 1; j < W - 1; j++)\n\t\t{\n\t\t\tif (dp[i][j] < INF)\n\t\t\t{\n\t\t\t\tmaxdepth = max(dp[i][j], maxdepth);\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << maxdepth << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstring>\n#include<queue>\nusing namespace std;\n\nstring S[2000];\nint x[2000][2000];\nint z[2000][2000];\nqueue<int> Q;\nqueue<int> R;\n\nint main() {\n\tint n, m;\n\tchar T[10] = { '.','1','2','3','4','5','6','7','8','9' };\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> S[i];\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tfor (int k = 0; k < 10; k++) {\n\t\t\t\tif (S[i][j] == T[k]) {\n\t\t\t\t\tx[i][j] = k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint t = 1;\n\tint p = 0;\n\tint sum = 0;\n\tmemset(z, 0, sizeof(z));\n\tt = 0;\n\tsum++;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tif (x[i][j] >= 1) {\n\t\t\t\tp = 0;\n\t\t\t\tfor (int k = -1; k <= 1; k++) {\n\t\t\t\t\tfor (int l = -1; l <= 1; l++) {\n\t\t\t\t\t\tif (x[i + k][j + l] == 0) {\n\t\t\t\t\t\t\tp++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (p >= x[i][j]) {\n\t\t\t\t\tz[i][j] = 1;\n\t\t\t\t\tQ.push(i * 1000 + j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tif (z[i][j] == 1) {\n\t\t\t\tx[i][j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tint c, d;\n\n\twhile (sum==0 || !Q.empty()) {\n\t\tsum++;\n\t\twhile (!Q.empty()) {\n\t\t\tc = Q.front() / 1000;\n\t\t\td = Q.front() % 1000;\n\t\t\tfor (int i = -1; i <= 1; i++) {\n\t\t\t\tfor (int j = -1; j <= 1; j++) {\n\t\t\t\t\tif (x[c + i][d + j] >= 1) {\n\t\t\t\t\t\tp = 0;\n\t\t\t\t\t\tfor (int k = -1; k <= 1; k++) {\n\t\t\t\t\t\t\tfor (int l = -1; l <= 1; l++) {\n\t\t\t\t\t\t\t\tif (x[c + i + k][d + j + l]) {\n\t\t\t\t\t\t\t\t\tp++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (p >= x[c + i][d + j] && x[c + i][d + j] != 10) {\n\t\t\t\t\t\t\tx[c + i][d + j] = 10;\n\t\t\t\t\t\t\tR.push((c + i) * 1000 + (d + j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t\twhile (!R.empty()) {\n\t\t\tc = R.front() / 1000;\n\t\t\td = R.front() % 1000;\n\t\t\tx[c][d] = 0;\n\t\t\tQ.push(R.front());\n\t\t\tR.pop();\n\t\t}\n\t}\n\n\tcout << sum << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <map>\n#define FLAG -1\nusing namespace std;\ntypedef pair<int,int> P;\nint main(){\n      int h,w,dh[] = {1,1,1,0,-1,-1,-1,0}, dw[] = {1,0,-1,-1,-1,0,1,1},ctn;\n      int solve = -1 ;\n      cin >> h >> w;\n      queue<P> que,tmp;\n      char d[h][w];\n      for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++)\n            {\n                  cin >> d[i][j];\n                  if('1'<=d[i][j]&&'9'>=d[i][j])\n                        que.push(make_pair(i,j));\n            }\n      }\n\n      que.push(make_pair(FLAG,FLAG));\n      for(;;){\n            solve++;\n            int m[h][w];\n            for(int i=0;i<h;i++)for(int j=0;j<w;j++)m[i][j]=0;\n            for(;;){\n                  //cout << que.size()<<endl;\n                  P p = que.front();\n                  que.pop();\n                  if(d[p.first][p.second]=='.')continue;\n                  if(p.first==FLAG)\n                  {//cout <<\" break \"<<endl<<endl;\n                  break;\n                  }\n                  ctn = 0;\n                  for(int i = 0;i < 8;i++){\n                        if(d[p.first+dh[i]][p.second+dw[i]]=='.')ctn++;\n                  }\n\n                  if(ctn >= d[p.first][p.second]-'0'){\n                        tmp.push(p);\n                        for(int j=0;j<8;j++)\n                        if(m[p.first+dh[j]][p.second+dw[j]]==0){\n                        que.push(make_pair(p.first+dh[j],p.second+dw[j]));\n                        m[p.first+dh[j]][p.second+dw[j]]=1;\n                        }\n                  }\n            }\n            if(que.empty())break;\n            while(!tmp.empty())\n            {\n                  d[tmp.front().first][tmp.front().second]='.';\n                  tmp.pop();\n            }\n            /*for(int i =0 ;i<h;i++)\n            {\n                  for( int j=0;j<w;j++)cout << d[i][j];\n                  cout <<endl;\n            }\n            */\n\n\n            que.push(make_pair(FLAG,FLAG));\n\n      }\n      cout << solve << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//AOJ 0612\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\nint w,h,field[50][50],copied[50][50];\n\nvoid show(){\n\tfor(int i = 0;i < h;i++){\n\t\tfor(int j = 0;j < w;j++){\n\t\t\tcout << field[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\nvoid copyarray(){\n\tfor(int i = 0;i < h;i++){\n\t\tfor(int j = 0;j < w;j++){\n\t\t\tfield[i][j] = copied[i][j];\n\t\t}\n\t}\n}\n\nint around(int a,int b){\n\tint cnt = 0;\n\tfor(int i = max(0,a - 1);i < min(h,a + 2);i++){\n\t\tfor(int j = max(0,b - 1);j < min(w,b + 2);j++){\n\t\t\tif(!(a == i && b == j) && field[i][j] == 0) cnt++;\n\t\t}\n\t}\n\treturn cnt;\n}\n\nint main(){\n\tqueue<pair<int,int> > que1,que2;\n\tcin >> h >> w;\n\tgetchar();\n\tfor(int i = 0;i < h;i++){\n\t\tfor(int j = 0;j < w;j++){\n\t\t\tchar c = getchar();\n\t\t\tif(c == '.') copied[i][j] = 0;\n\t\t\telse copied[i][j] = c - '0';\n\t\t}\n\t\tgetchar();\n\t}\n\tint chg = -1,cnt = -1;\n\twhile(chg){\n\t\tcopyarray();\n\t\tcnt++;\n\t\tif(chg == -1){\n\t\t\tchg++;\n\t\t\tfor(int i = 0;i < h;i++){\n\t\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\t\tif(field[i][j] != 0 && around(i,j) >= field[i][j]) {\n\t\t\t\t\t\tcopied[i][j] = 0;\n\t\t\t\t\t\tchg++;\n\t\t\t\t\t\tque2.push(make_pair(i,j));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tchg = 0;\n\t\t\tque1 = que2;\n\t\t\twhile(!que2.empty()) que2.pop();\n\t\t\twhile(!que1.empty()){\n\t\t\t\tpair<int,int> p = que1.front();que1.pop();\n\t\t\t\tfor(int i = max(0,p.first - 1);i < min(h,p.first + 2);i++){\n\t\t\t\t\tfor(int j = max(0,p.second - 1);j < min(w,p.second + 2);j++){\n\t\t\t\t\t\tif(field[i][j] > 0 && around(i,j) >= field[i][j]) {\n\t\t\t\t\t\t\tfield[i][j] = -1;\n\t\t\t\t\t\t\tcopied[i][j] = 0;\n\t\t\t\t\t\t\tchg++;\n\t\t\t\t\t\t\tque2.push(make_pair(i,j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << cnt << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int>P;\n\nchar sand[1005][1005];\nint sara[1005][1005];\n\nint main(){\n\tint h,w;\n\tcin>>h>>w;\n\tfor(int i=0;i<h;i++)\n\tfor(int j=0;j<w;j++)cin>>sand[i][j];\n\t\n\tfor(int i=1;i<h-1;i++){\n\t\tfor(int j=1;j<w-1;j++){\n\t\t\tif(sand[i][j]!='.'){\n\t\t\t\tfor(int k=-1;k<=1;k++){\n\t\t\t\t\tfor(int l=-1;l<=-1;l++){\n\t\t\t\t\t\tif(sand[i+k][j+l]=='.')sara[i][j]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tqueue<P>now;\n\t\tqueue<P>next;\n\t\t\n\t\tfor(int i=1;i<h-1;i++){\n\t\t\tfor(int j=1;j<w-1;j++){\n\t\t\t\tif(sand[i][j]!='.'){\n\t\t\t\t\tint a=sand[i][j]-'0';\n\t\t\t\t\tif(a<=sara[i][j])now.push(make_pair(i,j));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint ans=0;\n\t\twhile(now.empty()==false){\n\t\t\tans++;\n\t\t\t\n\t\t\tint a=now.size();\n\t\t\tfor(int i=0;i<a;i++){\n\t\t\t\tP p;\n\t\t\t\tp=now.front();\n\t\t\t\tnow.pop();\n\t\t\t\tfor(int j=-1;j<=1;j++){\n\t\t\t\t\tfor(int k=-1;k<=1;k++){\n\t\t\t\t\tif(sara[p.first+j][p.second+k]!=0)sara[p.first+j][p.second+k]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\tsara[p.first][p.second]=0;\n\t\t\t\tsand[p.first][p.second]='.';\n\t\t\t\t\n\t\t\t\tfor(int j=-1;j<=1;j++){\n\t\t\t\t\tfor(int k=-1;k<=1;k++){\n\t\t\t\t\t\t\n\t\t\t\tif(sand[p.first+j][p.second+k]!='.'){\n\t\t\t\t\tint a=sand[p.first+j][p.first+k]-'0';\n\t\t\t\t\tif(a<=sara[p.first+j][p.first+k])next.push(make_pair(p.first+j,p.first+k));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t\twhile(!next.empty()){\n\t\t\t\tnow.push(next.front());\n\t\t\t\tnext.pop();\n\t\t\t\t}\n\t\t}\t\n\t\tcout<<ans<<endl;\n\t\treturn 0;\n\t}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {+0,+1,+1,+1,+0,-1,-1,-1};\nstatic const int ty[] = {-1,-1,+0,+1,+1,+1,+0,-1};\n\nchar stage[1001][1001];\nchar buffer[1001][1001];\n\nint main(){\n  int H,W;\n  while(~scanf(\"%d %d\",&H,&W)){\n    for(int y = 0; y < H; y++){\n      char line[101];\n      scanf(\"%s\",line);\n      for(int x = 0; x < W; x++){\n        stage[y][x] = line[x];\n        buffer[y][x] = line[x];\n      }\n    }\n\n    int res = 0;\n    for(int round = 0; round < 10010; round++){\n      bool is_over = true;\n      for(int y = 0; y < H; y++){\n        for(int x = 0; x < W; x++){\n          if(stage[y][x] == '.') continue;\n          int strongness = stage[y][x] - '0';\n\n          int count = 0;\n          for(int i = 0; i < 8; i++){\n            int dx = x + tx[i];\n            int dy = y + ty[i];\n            if(dx < 0 || dx >= W || dy < 0 || dy >= H) continue;\n            if(stage[dy][dx] == '.'){\n              count++;\n            }\n          }\n\n          if(count >= strongness){\n            is_over = false;\n            buffer[y][x] = '.';\n          }\n        }\n      }\n      if(is_over){\n        res = round;\n        break;\n      }\n      memcpy(stage,buffer,sizeof(char)*1001*1001);\n    }\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<bits//stdc++.h>\n#include<functional>\nusing namespace std;\nstruct P{\n\tint x,y;\n};\nint main() {\n\tint a[500][500];\n\tint h,w;\n\tcin>>h>>w;\n\tfor(int i=0;i<h;i++){\n\t\tstring s;\n\t\tcin>>s;\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(s[j]=='.') a[i][j]=0;\n\t\t\telse a[i][j]=(int)s[j]-'0';\n\t\t}\n\t}\n\tint sum=0,sum2=1;\n\twhile(sum2){\n\t\tsum2=0;\n\t\tint sum3;\n\t\tP p[100000];\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(a[i][j]){\n\t\t\t\t\tsum3=0;\n\t\t\t\t\tfor(int x=-1;x<=1;x++){\n\t\t\t\t\t\tfor(int y=-1;y<=1;y++){\n\t\t\t\t\t\t\tif(i+x<h&&i+x>=0&&j+y<w&&j+y>=0&&a[i+x][j+y]==0) sum3++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(sum3>=a[i][j]) {\n\t\t\t\t\t\tp[sum2]=P{i,j};\n\t\t\t\t\t\tsum2++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<sum2;i++){\n\t\t\ta[p[i].x][p[i].y]=0;\n\t\t}\n\t\tsum++;\n\t}\n\tcout<<--sum<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <time.h>\n#include <math.h>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <iterator>\n#include <sstream>\n#include <string>\n#include <bitset>\nusing namespace std;\n#define FOR(I,F,N) for(int I = F; I < (int)(N); I++)\n#define rep(i, n) FOR(i, 0, n)\n#define FIN(V) cout<<V<<endl\n#define pb push_back\n#define INF (1 << 28)\n\ntemplate<typename T>\nvoid remove(vector<T>& vector, unsigned int index){\nvector.erase(vector.begin() + index);\n}\n\ntypedef pair<int, int> P;\ntypedef long long ll;\ntypedef priority_queue<int> pq;\nint StrToInt(string);\nstring IntToStr(int);\nint dx[8] = {-1, 0, 1, 1, 1, 0, -1, -1};\nint dy[8] = {1, 1, 1, 0, -1, -1, -1, 0};\n\nint w, h, ans = 0;\nint state[51][51];\nint score[51][51];\nvoid show(){\n\trep(i,h){\n\t\trep(j,w){\n\t\t\tif(state[j][i] == 0)cout << '.';\n\t\t\telse cout << state[j][i];\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nint main(void){\n\tcin >> h >> w;\n\tfill_n(*state, 51*51, -1);\n\trep(i,h)rep(j,w){\n\t\tchar c;\n\t\tcin >> c;\n\t\tif(c == '.')state[j][i] = 0;\n\t\telse state[j][i] = c-'0';\n\t}\n\tqueue<P> que;\n\trep(i,h)rep(j,w){\n\t\tif(state[j][i] == 0)continue;\n\t\tint count = 0;\n\t\trep(k,8){\n\t\t\tint nx = j+dx[k];\n\t\t\tint ny = i+dy[k];\n\t\t\tif(nx < 0 || ny < 0 || state[nx][ny] == -1)continue;\n\t\t\tif(state[nx][ny] == 0)count++;\n\t\t}\n\t\tscore[j][i] = count;\n\t\tif(state[j][i] <= count){\n\t\t\tque.push(P(j, i));\n\t\t}\n\t}\n\t///show();\n\twhile(!que.empty()){\n\t\tqueue<P> reQue;\n\t\twhile(!que.empty()){\n\t\t\treQue.push(que.front());\n\t\t\t///cout << \"(\" << que.front().first << \",\" << que.front().second << \")\" << endl;\n\t\t\tP p = que.front();\n\t\t\tint x = p.first;\n\t\t\tint y = p.second;\n\t\t\tstate[x][y] = 0;\n\t\t\tscore[x][y] = 0;\n\t\t\trep(k,8){\n\t\t\t\tint nx = x+dx[k];\n\t\t\t\tint ny = y+dy[k];\n\t\t\t\tscore[nx][ny]++;\n\t\t\t}\n\t\t\tque.pop();\n\t\t}\n\t\tint memo[51][51] = {0};\n\t\twhile(!reQue.empty()){\n\t\t\tP p = reQue.front();\n\t\t\treQue.pop();\n\t\t\tint x = p.first;\n\t\t\tint y = p.second;\n\t\t\t///cout << \"(\" << x << \",\" << y << \")\" << endl;\n\t\t\trep(k,8){\n\t\t\t\tint nx = x+dx[k];\n\t\t\t\tint ny = y+dy[k];\n\t\t\t\tif(nx < 0 || ny < 0 || state[nx][ny] == -1)continue;\n\t\t\t\tif(state[nx][ny] == 0)continue;\n\t\t\t\tif(state[nx][ny] <= score[nx][ny] && !memo[nx][ny]){\n\t\t\t\t\tmemo[nx][ny]=1;\n\t\t\t\t\tque.push(P(nx, ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t///show();\n\t\tans++;\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}\n\n\n\nint StrToInt(string s){\n\tstringstream ss;\n\tss << s;\n\tint val;\n\tss >> val;\n\treturn val;\n}\nstring IntToStr(int i){\n\tstringstream ss;\n\tss << i;\n\treturn ss.str();\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\n#include<iostream>\n\n#include<algorithm>\n\n#include<queue>\n\n#define REP(i,n) for(int i=0;i<(n);i++)\n\n#define RREP(i,n) for(int i=(n)-1;i>=0;i++)\n\nusing namespace::std;\n\ntypedef pair<int,int> P;\n\ntypedef pair<P,int> PP;\n\nqueue <PP> q;//width,height,cost\n\n\n\n\n\nbool judge(int,int);\n\nvoid solve();\n\nvoid loop();\n\n\n\nint h,w,map[2000][2000]={0},ans=0;//\n\n\n\nint main(){\n\n\tchar c;\n\n\tcin>>h>>w;\n\n\tREP(j,h)REP(i,w){\n\n\t\tcin>>c;\n\n\t\tif(c=='.')map[i][j]=0;\n\n\t\telse map[i][j]=int(c)-48;\n\n\t}\n\n\tsolve();\n\n\tloop();\n\n\t\n\n//\tREP(j,h){REP(i,w){\n\n//\t\tprintf(\"%d\",map[i][j]);\n\n//\t}printf(\"\\n\");}\n\n\tcout<<ans<<endl;\n\n}\n\n\n\nbool judge(int i,int j){\n\n\tint v=0;\n//\tcout<<\"hoge\"<<i<<\":\"<<j<<endl;\n\n\tif(map[i][j]==0)return false;\n\n\tREP(a,3)REP(b,3)if(map[i+a-1][j+b-1]==0&&!(a==1&&b==1))v++;\n//\tcout<<v<<endl;\n\n\tif(map[i][j]>v)return false;\n\n\telse return true;\n\n}\n\n\n\n\n\nvoid solve(){\n\n\tREP(j,w)REP(i,h){\n\n\t\tif(judge(i,j)==true){\n\n\t\t\tq.push(PP(P(i,j),1));\n\n\t\t}\n\n\t}\t\n\n}\n\n\n\nvoid loop(){\n\nwhile(q.size()){\n\n\tPP p = q.front();q.pop();\n\n\t\n\n\tint k=p.second,i=p.first.first,j=p.first.second;\n\n//\tcout<<q.size()<<\"[\"<<i<<\",\"<<j<<\"]cost:\"<<k<<endl;\n\tmap[i][j]=0;\n\n//\tif(judge(i,j)==true){\n\n\t\tREP(a,3)REP(b,3)if(map[i+a-1][j+b-1]!=0&&judge(i+a-1,j+b-1)==true&&!(a==1&&b==1)){\n\n\t\t\tq.push(PP(P(i+a-1,j+b-1),(++k)));\n\n\t\t\tans=max(k,ans);\n\n//\t\t\tcout<<\"pushed!\"<<endl;\n\n\t\t\t\n\n\t\t}\n\n//\t}\t\n\n//\tREP(j,h){REP(i,w){\n\n//\t\tprintf(\"%d\",map[i][j]);\n\n//\t}printf(\"\\n\");}\n\n\t\n\n}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"queue\"\n#include \"utility\"\n#include \"math.h\"\n\nusing namespace std;\nint H, W;\nchar status[1002][1002];\nint field[1002][1002];\npair<int, int> dir[8] = {make_pair(0,1),make_pair(1,1),make_pair(1,0),make_pair(1,-1),make_pair(0,-1),make_pair(-1,-1),make_pair(-1,0),make_pair(-1,1)};\nqueue<pair<int,int> > Q;\nqueue<pair<int, int> >del;\nint ans = 0;\nint box = 0;\nint num = 0;\nint x, y;\n\nint main() {\n\tcin >> H >> W;\n\tfor (int i = 1; i <= H; i++) {\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tcin >> status[i][j];\n\t\t\tif (status[i][j] == '.') {\n\t\t\t\tfield[i][j] = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfield[i][j] = status[i][j] - '0';\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= H; i++) {\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tif (field[i][j] != 0) {\n\t\t\t\tbox = 0;\n\t\t\t\tfor (int k = 0; k < 8; k++) {\n\t\t\t\t\tif (field[i + dir[k].first][j + dir[k].second] == 0)box++;\n\t\t\t\t}\n\t\t\t\tif (box >= field[i][j]) {\n\t\t\t\t\tQ.push(make_pair(i, j));\n\t\t\t\t\tans = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdel = Q;\n\t\n\twhile (!del.empty()) {\n\t\ty = del.front().first;\n\t\tx = del.front().second;\n\t\tfield[y][x] = 0;\n\t\tdel.pop();\n\t}\n\twhile (1) {\n\t\tnum = Q.size();\n\t\tcout << num <<\" \";\n\t\tfor (int i = 0; i < num; i++) {\n\t\t\ty = Q.front().first;\n\t\t\tx = Q.front().second;\n\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\tif (field[y + dir[j].first][x + dir[j].second] != 0&&y+dir[j].first>=1&&y+dir[j].first<=H&&x+dir[j].second>=1&&x+dir[j].second<=W) {\n\t\t\t\t\tbox = 0;\n\t\t\t\t\tfor (int k = 0; k < 8; k++) {\n\t\t\t\t\t\tif (field[y + dir[j].first + dir[k].first][x + dir[j].second + dir[k].second] == 0)box++;\n\t\t\t\t\t}\n\t\t\t\t\tif (box >= field[y + dir[j].first][x + dir[j].second]) {\n\t\t\t\t\t\tQ.push(make_pair(y + dir[j].first, x + dir[j].second));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t\tcout << Q.size() << \"\\n\";\n\t\tif (Q.empty())break;\n\t\tdel = Q;\n\t\tans++;\n\t\t//cout << del.size() << \"\\n\";\n\t\twhile (!del.empty()) {\n\t\t\ty = del.front().first;\n\t\t\tx = del.front().second;\n\t\t\tfield[y][x] = 0;\n\t\t\tdel.pop();\n\t\t}\n\t\t\n\t}\n\tcout << ans << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int dx[8] = { -1, 0, 1, -1, 1, -1, 0, 1 };\nconst int dy[8] = { -1, -1, -1, 0, 0, 1, 1, 1 };\n\nint main()\n{\n\tint H, W;\n\n\tcin >> H >> W;\n\n\tvector<vector<char> > D(H, vector<char>(W));\n\n\tvector<vector<int> > memo(H, vector<int>(W, 1 << 29));\n\n\tfor (int i = 0; i < H; i++)\n\t\tfor (int j = 0; j < W; j++)\n\t\t\tcin >> D[i][j];\n\n\tbool ok = true;\n\n\tint count_ = -1;\n\n\twhile (ok)\n\t{\n\t\tok = false;\n\n\t\tcount_++;\n\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tif (D[i][j] != '.')\n\t\t\t\t{\n\t\t\t\t\tint count = 0;\n\n\t\t\t\t\tfor (int dir = 0; dir < 8; dir++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (0 <= i + dy[dir] && i + dy[dir] < H && 0 <= j + dx[dir] && j + dx[dir] < W)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (D[i + dy[dir]][j + dx[dir]] == '.' && memo[i + dy[dir]][j + dx[dir]] != count_)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (count >= D[i][j] - 48)\n\t\t\t\t\t{\n\t\t\t\t\t\tD[i][j] = '.';\n\n\t\t\t\t\t\tmemo[i][j] = count_;\n\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << count_ << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*************************\n\n\t\tPCK 2012 t1\n\n************************/\n\n/*#include <stdio.h>\nint main(){\n\n\tint s;\n\tint sum = 0;\n\tint i;\n\n\tfor ( i = 0; i < 10; i++){\n\t\tscanf(\"%d\", &s);\n\t\tsum += s;\n\t}\n\n\tprintf(\"%d\\n\", sum);\n}*/\n\n/************************\n\n\t\tPCK 2012 t2\n\n************************/\n/*\n#include <stdio.h>\nint main(){\n\n\tint b[3];\n\tint i;\n\tfor ( i = 0; i < 3; i++){\n\t\tscanf(\"%d\", &b[i]);\n\t}\n\n\tif (b[2] == 1)\n\t\tprintf(\"Open\\n\");\n\telse if (b[0] == 1){\n\t\tif (b[1] == 1)\n\t\t\tprintf(\"Open\\n\");\n\t\telse\n\t\t\tprintf(\"Close\\n\");\n\t}\n\telse\n\t\tprintf(\"Close\\n\");\n}*/\n\n/****************************\n\n\t\tPCK 2012 t3\n\n****************************/\n/*\n\t#include <stdio.h>\n\tint main(){\n\n\t\tint n;\n\t\tint h[101] = { 0 };\n\t\tint i;\n\t\tint temp;\n\n\t\tscanf(\"%d\", &n);\n\n\t\twhile (n != 0){\n\t\t\tfor (i = 0; i < n + 1; i++){\n\t\t\t\tscanf(\"%d\", &h[i]);\n\t\t\t}\n\n\t\t\tif ((h[1] - h[0]) + h[1] == h[2]){\n\t\t\t\ttemp = h[1] - h[0];\n\t\t\t\tfor (i = 1; i < n; i++){\n\t\t\t\t\tif (h[i] + temp != h[i + 1]){\n\t\t\t\t\t\tprintf(\"%d\\n\", h[i + 1]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif ((h[2] - h[1]) + h[2] == h[3])\n\t\t\t\t\tprintf(\"%d\\n\", h[0]);\n\t\t\t\telse if ((h[1] - h[0]) + h[2] != h[3])\n\t\t\t\t\tprintf(\"%d\\n\", h[2]);\n\t\t\t\telse\n\t\t\t\t\tprintf(\"%d\\n\", h[1]);\n\t\t\t}\n\n\t\t\tscanf(\"%d\", &n);\n\t\t}\n\t}\n*/\n\n/*************************************\n\n\t\t\tPCK 2012 t4\n\t\t\t\t\t\t(2???????????????????)\n*************************************/\n/*\n#include <stdio.h>\nint main(void)\n\n{\n\n\tint n;\n\tint num[4], l, s, count, i, j, temp;\n\tscanf(\"%d\", &n);\n\twhile (n != 0000){\n\t\tcount = 0;\n\t\twhile (n != 6174){\n\t\t\tnum[0] = n / 1000;\n\t\t\tnum[1] = (n - num[0] * 1000) / 100;\n\t\t\tnum[2] = (n - num[0] * 1000 - num[1] * 100) / 10;\n\t\t\tnum[3] = n - num[0] * 1000 - num[1] * 100 - num[2] * 10;\n\t\t\tif (num[0] == num[1] && num[1] == num[2] && num[2] == num[3]) //????????????????(1111??????7777??????)??????\n\t\t\t\tbreak;\n\t\t\tfor (i = 0; i<3; i++){\n\t\t\t\tfor (j = i + 1; j<4; j++){\n\t\t\t\t\tif (num[i]>num[j]){\n\t\t\t\t\t\ttemp = num[i];\n\t\t\t\t\t\tnum[i] = num[j];\n\t\t\t\t\t\tnum[j] = temp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ts = num[0] * 1000 + num[1] * 100 + num[2] * 10 + num[3];\n\t\t\tl = num[3] * 1000 + num[2] * 100 + num[1] * 10 + num[0];\n\t\t\tn = l - s;\n\t\t\tcount++;\n\t\t}\n\t\tif (n == 6174 || count>0)\n\t\t\tprintf(\"%d\\n\", count);\n\t\telse\n\t\t\tprintf(\"NA\\n\");\n\n\t\tscanf(\"%d\", &n);\n\t}\n\n\treturn 0;\n\n}*/\n\n/*************************************\n\n\t\t\tPCK 2012 t5\n\n*************************************/\n/*\n#include <stdio.h>\n#include <algorithm>\n\nint *p, *j;\n\nint bfs(int n,int ){\n\n\treturn max(n * )\n}\n\nint main(){\n\n\tint n;\n\n\tscanf(\"%d\", &n);\n\twhile (n != 0){\n\n\t\tp = new int[n];\n\t\tj = new int[n - 1];\n\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &p[i]);\n\t\tfor (int i = 0; i < n - 1; i++)\n\t\t\tscanf(\"%d\", &j[i]);\n\n\t\tscanf(\"%d\", &n);\n\t}\n}*/\n\n//PCK 2013 t4 ????????????????????????\n/*/\n#include <iostream>\nusing namespace std;\n#include <cstring>\n#include <algorithm>\n\nint main(){\n\n\tint n;\n\tint hand[100];\n\n\twhile (cin >> n && n != 0){\n\n\t\tmemset(hand, 0, sizeof(hand));\n\t\tint field = 0;\n\t\tint num = 0;\n\n\t\tfor (int i = 0; i < 100; i++){\n\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tif (c == 'M') hand[num]++;\n\t\t\telse if (c == 'S'){ field += hand[num] + 1; hand[num] = 0; }\n\t\t\telse { hand[num] += field + 1; field = 0; }\n\t\t\tif (num + 1 < n) num++; else num = 0;\n\t\t}\n\n\t\tsort(hand, hand + n);\n\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tcout << hand[i] << ' ';\n\t\tcout << field << endl;\n\t}\n}\n*/\n/*********************************************************************\n\n\tpck 2009 t1\t\t\t?????\\??????????????????????????\n\n*********************************************************************/\n/*\n#include <iostream>\nusing namespace std;\n\nint main(){\n\n\tint s1, s2;\n\n\twhile (cin >> s1 >> s2 && s1 != 0 && s2 != 0){\n\n\t\tint sum[5];\n\t\tint max;\n\t\tint num;\n\t\tsum[0] = s1 + s2;\n\t\tmax = sum[0];\n\t\tnum = 0;\n\t\tfor (int i = 1; i < 5; i++){\n\t\t\tcin >> s1 >> s2;\n\t\t\tsum[i] = s1 + s2;\n\t\t\tif (max < sum[i]){\n\t\t\t\tmax = sum[i];\n\t\t\t\tnum = i;\n\t\t\t}\n\t\t}\n\n\t\tcout << (char)('A' + num) << ' ' << max << endl;\n\t}\n}*/\n\n/******************************************************************************\n\n\tpck 2009 t3\t\t\t???????????-??????????????????????????????\n\n*******************************************************************************/\n/*\n#include <iostream>\nusing namespace std;\n#include <algorithm>\n\nint main(){\n\n\tint x, y;\n\twhile (cin >> x >> y && x != 0 && y != 0){\n\n\t\tif (y > x) swap(x, y);\n\t\tint count = 0;\n\t\twhile (y != 0){\n\t\t\tcount++;\n\t\t\tx = x % y;\n\t\t\tswap(x, y);\n\t\t}\n\n\t\tcout << x << ' ' << count << endl;\n\t}\n}\n*/\n\n/************************************************************\n\n\t\tPCK 2013 t3\t\t\t?????????????????????\n\n************************************************************/\n/*\n#include <iostream>\nusing namespace std;\n\nint main(){\n\n\tint n;\n\twhile (cin >> n && n != 0){\n\n\t\tint m = n;\n\t\tbool flg = false;\n\n\t\tint k;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\t\n\t\t\tcin >> k;\n\t\t\tif (k >= 2) flg = true;\n\t\t\tif (k == 0) m--;\n\t\t}\n\n\t\tif (flg)\n\t\t\tcout << m + 1 << endl;\n\t\telse cout << \"NA\" << endl;\n\t}\n}\n*/\n\n/*******************************************\n\n\t\tPCK 2013 t5\t\t\t????\n\n********************************************/\n/*\n#include <iostream>\nusing namespace std;\n\nint main(){\n\n\tint q;\n\tcin >> q;\n\tfor (int i = 0; i < q; i++){\n\n\t\tint c, a, n;\n\t\tint count = 0;\n\n\t\tcin >> c >> a >> n;\n\n\t\tfor (; c > 0 && a > 0 && n > 0; count++){\n\t\t\tc--; a--; n--;\n\t\t}\n\t\tfor (; c >= 2 && a > 0; count++){\n\t\t\tc -= 2; a--;\n\t\t}\n\t\tfor (; c >= 3; count++)\n\t\t\tc -= 3;\n\n\t\tcout << count << endl;\n\t}\n}\n*/\n\n/*****************************************************************\n\n\t\tPCK 2012 t1\t\t\t10???????????????????????????????\n\n*****************************************************************/\n/*\n#include <iostream>\nusing namespace std;\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\n\tint sum = 0;\n\tint s;\n\t\n\tfor (int i = 0; i < 10; i++){\n\t\n\t\tcin >> s;\n\t\tsum += s;\n\t}\n\n\tcout << sum << \"\\n\";\n}\n*/\n/*\n#include <stdio.h>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\nclass Game\n{\npublic:\n\tint k;   // ????????????????????????????\n\tint m;   // ?????????????????????????????????\n\tbitset <16> x;   // ?????????????????\n\tGame(int k1, int m1, bitset<16> x1)\n\t{\n\t\tk = k1;\n\t\tm = m1;\n\t\tx = x1;\n\t}\n};\n\nint main()\n{\n\tint i1, i2, m, m1, n=1, n1, n2, c=1, k, k1, max;\n\tbitset <16> x, y;\n\n\tscanf(\"%d %d\\n\", &n, &c);\n\twhile (n > 0) {\n\t\t// ??\\???\n\t\tbitset<16> a[n];\n\t\tfor (i1 = 0; i1 < n; i1++) {\n\t\t\tfor (i2 = 15; i2 >= 0; i2--) {\n\t\t\t\tscanf(\"%d\", &k);\n\t\t\t\ta[i1].set(i2, k);\n\t\t\t}\n\t\t}\n\t\tbitset<16> b[c];\n\t\tfor (i1 = 0; i1 < c; i1++) {\n\t\t\tfor (i2 = 15; i2 >= 0; i2--) {\n\t\t\t\tscanf(\"%d\", &k);\n\t\t\t\tb[i1].set(i2, k);\n\t\t\t}\n\t\t}\n\t\t// ??????\n\t\tmax = 0;\n\t\tstack<Game> st;\n\t\tst.push(Game(0, 0, a[0]));\n\t\twhile (!st.empty()) {\n\t\t\tk = st.top().k;\n\t\t\tm = st.top().m;\n\t\t\tx = st.top().x;\n\t\t\tst.pop();\n\t\t\tfor (i1 = 0; i1 < c; i1++) {\n\t\t\t\ty = x;\n\t\t\t\tn1 = y.count();\n\t\t\t\ty ^= b[i1];\n\t\t\t\ty &= x;\n\t\t\t\tn2 = y.count();\n\t\t\t\tm1 = m + n1 - n2;\n\t\t\t\tif (k == n - 1) {\n\t\t\t\t\tif (m1 > max)\n\t\t\t\t\t\tmax = m1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tk1 = k + 1;\n\t\t\t\t\ty |= a[k1];\n\t\t\t\t\tst.push(Game(k1, m1, y));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", max);\n\t\t// ??????????????\n\t\tscanf(\"%d %d\\n\", &n, &c);\n\t}\n\n\treturn 0;\n}\n*/\n/*\n#include<iostream>\nusing namespace std;\n\n#include<algorithm>\n#include<cstring>\n\nint main(){\n\n\tint n, m, a[101], b[101];\n\tint point[101];\n\tmemset(point, 0, sizeof(point));\n\n\tcin >> n >> m;\n\n\tfor (int i = 1; i <= m; i++)\n\t\tcin >> a[i];\n\tfor (int i = 1; i <= m; i++){\n\t\tfor (int j = 1; j <= n; j++){\n\t\t\tcin >> b[j];\n\t\t\tif (b[j] == a[i])point[j]++;\n\t\t\telse point[a[i]]++;\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++)\n\t\tcout << point[i] << endl;\n}*/\n/*\t\t\t\t\t\tJOI ?????\n#include<iostream>\nusing namespace std;\n#include<stdio.h>\nint map[1002][1002];\t//???????????????????\nint dat[1002][1002];\t//????????????????????????????????????????????????????\nint x[1000001], y[1000001];\t//[n]???????????????????????????????????????????????????\nint dx[4] = { 1,0,-1,0 };\t//???????????\nint dy[4] = { 0,1,0,-1 };\t//???????????\nint main()\n{\n\tint mx, my;\n\tscanf(\"%d%d\", &mx, &my);\n\tfor (int i = 0; i < mx + 2; i++) {\n\t\tfor (int j = 0; j < my + 2; j++) {\n\t\t\tmap[i][j] = 1000000000; dat[i][j] = 0;\t//?????????\n\t\t}\n\t}\n\tfor (int i = 0; i < mx; i++) {\n\t\tfor (int j = 0; j < my; j++) {\n\t\t\tscanf(\"%d\", &map[i + 1][j + 1]);\t//??\\???\n\t\t}\n\t}\n\tfor (int i = 1; i <= mx; i++) {\n\t\tfor (int j = 1; j <= my; j++) {\n\t\t\tx[map[i][j]] = i, y[map[i][j]] = j;\t//???????????????????????????????\n\t\t}\n\t}\n\tint c = 0;\t//??????????\n\tfor (int i = 1; i <= mx*my; i++){\t//???????\n\n\t\tint r = 0;\n\t\tfor (int j = 0; j < 4; j++){\t//4??????????????\n\t\t\n\t\t\tint a = x[i] + dx[j], b = y[i] + dy[j];\t//????????\n\t\t\tif (map[a][b] < i)\t//???????????????????? i ??\\?????????\n\t\t\t{\n\t\t\t\tif (r == 0)r = dat[a][b];\t//?????????????????????????????????\n\t\t\t\telse if (r != dat[a][b])r = -1;\t//????????????????????????????????????\n\t\t\t}\n\t\t}\n\t\tif (r == 0)dat[x[i]][y[i]] = i;\t//?????????????????????????????????????????\n\t\telse dat[x[i]][y[i]] = r;\t//????????????????????????????????????\n\t\tif (r == -1)c++;\t//??????????????\n\t}\n\tprintf(\"%d\\n\", c);\n}\n*/\n\n/*\tJOI 2006 ????? t2 ??????????????? */\n/*#include <iostream>\nusing namespace std;\n\nint main() {\n\tint n, k;\n\twhile (cin >> n >> k && n != 0 && k != 0) {\n\n\t}\n\n\treturn 0;\n}*/\n\n/* ??????????? */\n/*\n#include<iostream>\nusing namespace std;\n#include<vector>\n#include<algorithm>\n\nint main() {\n\tlong long int n;\n\tlong long int k;\n\twhile (cin >> n >> k && n != 0 && k != 0) {\n\t\tvector<long long int> v;\n\t\tv.push_back(0);\n\n\t\tfor (long long int i = 1; i <= n; ++i) {\n\t\t\tlong long int m;\n\t\t\tcin >> m;\n\t\t\tv.push_back(m);\n\t\t\tv[i] += v[i - 1];\n\t\t}\n\n\t\tlong long int sum = 0;\n\t\tfor (long long int i = 1; i + k <= n; ++i) {\n\t\t\tsum = max(sum, v[i + k] - v[i]);\n\t\t}\n\n\t\tcout << sum << endl;\n\t}\n\t\n\treturn 0;\n}*/\n\n/* JOI 2016 t3 ?????????????????? */\n/*\n#include<iostream>\nusing namespace std;\n\n#include<cstring>\n\nint map[102][102] = { 1 };\n\nint main(){\n\tmemset(map, 1, sizeof(map));\n\tint n, m, d;\n\tcin >> n >> m >> d;\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int i2 = 0; i2 < m; ++i2) {\n\t\t\tchar str;\n\t\t\tcin >> str;\n\t\t\tif (str == '.') { map[i][i2] = 0; }\n\t\t}\n\t}\n\n\tint cnt = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int i2 = 0; i2 < m; ++i2) {\n\t\t\tif (map[i][i2] == 0) {\n\n\t\t\t\tbool flg = true;\n\t\t\t\tfor (int j = 1; j < d; ++j) {\n\t\t\t\t\tif (map[i + j][i2] != 0) {\n\t\t\t\t\t\tflg = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (flg) { ++cnt; }\n\n\t\t\t\tflg = true;\n\t\t\t\tfor (int j = 1; j < d; ++j) {\n\t\t\t\t\tif (map[i][i2 + j] != 0) {\n\t\t\t\t\t\tflg = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (flg) { ++cnt; }\n\t\t\t}\n\t\t}\n\t}\n\tcout << cnt << endl;\n\n\treturn 0;\n}\n*/\n/*\n\n#include<iostream>\nusing namespace std;\n\n#include<string>\n\nint dp[101][101] = { 0 };\n\nint main(){\n\tstring s, t;\n\tcin >> s >> t;\n\n\tfor (int i = 0; i <= t.size(); ++i) { dp[i][0] = 0; }\n\tfor (int i = 0; i <= s.size(); ++i) { dp[0][i] = 1; }\n\n\tfor (int i = 1; i <= t.size(); ++i) {\n\t\tfor (int i2 = 1; i2 <= s.size(); ++i2) {\n\t\t\tif (t[i - 1] == s[i2 - 1]) {\n\t\t\t\tdp[i][i2] = dp[i - 1][i2 - 1] + dp[i][i2 - 1];\n\t\t\t}\n\t\t\telse dp[i][i2] = dp[i][i2 - 1];\n\t\t}\n\t}\t\n\n\tcout << dp[t.size()][s.size()] << endl;\n\t\n\treturn 0;\n}\n*/\n/*\n#include<iostream>\nusing namespace std;\n\n#include<algorithm>\n\nint a[100001];\n\nint main() {\n\tint n, k;\n\twhile (cin >> n >> k && n != 0 && k != 0) {\n\t\ta[0] = 0;\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tcin >> a[i];\n\t\t\ta[i] += a[i - 1];\n\t\t}\n\t\tint maxi = 0;\n\t\tfor (int i = k; i <= n; ++i) {\n\t\t\tmaxi = max(maxi, a[i] - a[i - k]);\n\t\t}\n\n\t\tcout << maxi << endl;\n\t}\n\n\treturn 0;\n}\n*/\n\n/* JOI 2010 ???????? */\n/*\n#include<iostream>\nusing namespace std;\n\n#include<algorithm>\n\nunsigned long long dp[21][101] = { 0 };\n\nint main() {\n\tunsigned long long n, num;\n\tcin >> n;\n\tfor (unsigned long long i = 0; i < n - 1; ++i) {\n\t\tcin >> num;\n\t\tif (i == 0) {\n\t\t\t++dp[num][i];\n\t\t}\n\t\telse {\n\t\t\tfor (unsigned long long j = 0; j <= 20; ++j) {\n\t\t\t\tif (dp[j][i - 1] != 0) {\n\t\t\t\t\tif (j + num >= 0 && j + num <= 20) {\n\t\t\t\t\t\tdp[j + num][i] += dp[j][i - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (j - num >= 0 && j - num <= 20) {\n\t\t\t\t\t\tdp[j - num][i] += dp[j][i - 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcin >> num;\n\tcout << dp[num][n - 2] << endl;\n\n\treturn 0;\n}\n*/\n\n/* JOI 2010 t5 ????????? */\n/*\n#include<iostream>\nusing namespace std;\n\n#include<queue>\n#include<cstring>\n\ntypedef unsigned long long int ullint;\n\nstruct Q {\n\tullint x;\n\tullint y;\n};\n\nQ In(ullint x, ullint y) { Q a; a.x = x; a.y = y; return a; }\n\nchar map[1002][1002];\nullint num[1003][1003] = { 0 };\n\nullint xm[] = { 0,0,-1,1 };\nullint ym[] = { -1,1,0,0 };\n\nint main() {\n\tullint h, w, n;\n\tQ st;\n\tcin >> h >> w >> n;\n\tfor (ullint i = 0; i <= h + 1; ++i) {\n\t\tfor (ullint i2 = 0; i2 <= w + 1; ++i2) {\n\t\t\tmap[i][i2] = 'X';\n\t\t}\n\t}\n\tfor (ullint i = 1; i <= h; ++i) {\n\t\tfor (ullint i2 = 1; i2 <= w; ++i2) {\n\t\t\tchar str;\n\t\t\tcin >> str;\n\t\t\tmap[i][i2] = str;\n\t\t\tif (str == 'S') { st.y = i; st.x = i2; }\n\t\t}\n\t}\n\n\tqueue<Q> que; que.push(st);\n\tullint number = 1;\n\tullint ans = 0;\n\tfor (number = 1; number <= n; ++number) {\n\t\twhile (!que.empty()) {\n\t\t\tQ now;\n\t\t\tnow = que.front();\n\t\t\tque.pop();\n\t\t\tullint memo = num[now.y][now.x];\n\t\t\tif (map[now.y][now.x] == '0' + number) {\n\t\t\t\tans += memo;\n\t\t\t\tfor (ullint i = 0; i <= h + 1; ++i) {\n\t\t\t\t\tfor (ullint i2 = 0; i2 <= w + 1; ++i2) {\n\t\t\t\t\t\tnum[i][i2] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile (!que.empty()) { que.pop(); }\n\t\t\t\tque.push(In(now.x, now.y));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (ullint i = 0; i < 4; ++i) {\n\t\t\t\tif (map[now.y + ym[i]][now.x + xm[i]] != 'X') {\n\t\t\t\t\tif (num[now.y + ym[i]][now.x + xm[i]] == 0) {\n\t\t\t\t\t\tnum[now.y + ym[i]][now.x + xm[i]] = memo + 1;\n\t\t\t\t\t\tque.push(In(now.x + xm[i], now.y + ym[i]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}\n*/\n\n/* JOI 2014 t3 ??????????? */\n/*\n#include<iostream>\nusing namespace std;\n#include<cstring>\n\nint main() {\n\tint h, w;\n\tint map[102][102];\n\tchar data[102][102];\n\tmemset(map, -1, sizeof(map));\n\n\tcin >> h >> w;\n\tfor (int i = 0; i < h; ++i) {\n\t\tfor (int i2 = 0; i2 < w; ++i2) {\n\t\t\tchar str;\n\t\t\tcin >> str;\n\t\t\tdata[i][i2] = str;\n\t\t\tif (data[i][i2] == 'c') {\n\t\t\t\tmap[i][i2] = 0;\n\t\t\t}\n\t\t\tif (data[i][i2] == '.') {\n\t\t\t\tif (i2 != 0) {\n\t\t\t\t\tif (map[i][i2 - 1] != -1) {\n\t\t\t\t\t\tmap[i][i2] = map[i][i2 - 1] + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < h; ++i) {\n\t\tfor (int i2 = 0; i2 < w; ++i2) {\n\t\t\tcout << map[i][i2];\n\t\t\tif (i2 < w - 1) {\n\t\t\t\tcout << \" \";\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n*/\n\n/* JOI 2014 t4 ?????????????????? */\n/*\n#include<iostream>\nusing namespace std;\n#include<cstring>\n#include<algorithm>\n\n#define INF 1000000001\n\ntypedef long long int llint;\n\nllint dp[1002][1002];\n\nint main() {\n\tllint n, m;\n\tllint d[1002];\n\tllint c[1002];\n\n\tmemset(dp, 0, sizeof(dp));\n\n\tcin >> n >> m;\n\tfor (llint i = 1; i <= n; ++i) {\n\t\tcin >> d[i];\n\t}\n\tfor (llint i = 1; i <= m; ++i) {\n\t\tcin >> c[i];\n\t}\n\n\tfor (llint day = 0; day <= m; ++day) {\n\t\tfor (llint num = 1; num <= n; ++num) {\n\t\t\tdp[day][num] = INF;\n\t\t}\n\t}\n\n\tfor (llint day = 1; day <= m; ++day) {\n\t\tfor (llint num = 1; num <= n; ++num) {\n\t\t\tdp[day][num] = min(dp[day - 1][num], dp[day - 1][num - 1] + c[day] * d[num]);\n\t\t}\n\t}\n\n\tcout << dp[m][n] << endl;\n\n\treturn 0;\n}\n*/\n/* JOI 2014 t5 ????????? */\n\n#include<iostream>\nusing namespace std;\n#include<queue>\n#include<cstring>\n\nstruct XY{\n\tint x;\n\tint y;\n};\n\nint map[1002][1002] = {};\nbool map_flg[1002][1002] = {};\n\nint xm[] = { -1,0,1,-1,0,1,-1,0,1 };\nint ym[] = { -1,-1,-1,0,0,0,1,1,1 };\n\nint main() {\n\tmemset(map, -1, sizeof(map));\n\tmemset(map_flg, true, sizeof(map_flg));\n\tint h, w;\n\tXY st;\n\tqueue<XY> que;\n\tcin >> h >> w;\n\tfor (int i = 1; i <= h; ++i) {\n\t\tfor (int i2 = 1; i2 <= w; ++i2) {\n\t\t\tchar str;\n\t\t\tcin >> str;\n\t\t\tif (str <= '9' || str > '0') {\n\t\t\t\tmap[i][i2] = str - '0';\n\t\t\t}\n\t\t\tif (str == '.') {\n\t\t\t\tmap[i][i2] = 0;\n\t\t\t\tst.y = i; st.x = i2;\n\t\t\t\tque.push(st);\n\t\t\t}\n\t\t}\n\t}\n\n\tqueue<XY> temp;\n\tint ans = 0;\n\tdo {\n\t\twhile (!que.empty()) {\n\t\t\tXY now = que.front();\n\t\t\tque.pop();\n\t\t\tmap_flg[now.y][now.x] = false;\n\t\t\tfor (int i = 0; i < 8; ++i) {\n\t\t\t\tif (map_flg[now.y + ym[i]][now.x + xm[i]]) {\n\t\t\t\t\tif(map[now.y + ym[i]][now.x + xm[i]] > 0) {\n\t\t\t\t\t\t--map[now.y + ym[i]][now.x + xm[i]];\n\t\t\t\t\t\tif (map[now.y + ym[i]][now.x + xm[i]] == 0) {\n\t\t\t\t\t\t\tXY next;\n\t\t\t\t\t\t\tnext.y = now.y + ym[i];\n\t\t\t\t\t\t\tnext.x = now.x + xm[i];\n\t\t\t\t\t\t\ttemp.push(next);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (temp.empty()) {\n\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t\t++ans;\n\t\t\twhile (!temp.empty()) {\n\t\t\t\tque.push(temp.front());\n\t\t\t\ttemp.pop();\n\t\t\t}\n\t\t}\n\t} while (1);\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\nint x, y;\nchar map[1024][1024];\nqueue<pair<int,int>> q;\n\nbool check_map(void){\n\tbool flg = true;\n\tint dx[8] = { 0, 0, 1, -1, 1, -1, 1, -1 }, dy[8] = { 1, -1, 0, 0, 1, -1, -1, 1 };\n\tfor(int i = 0; i < y; i++){\n\t\tfor(int i2 = 0; i2 < x; i2++){\n\t\t\tint cnt = 0;\n\t\t\tif( map[i][i2] != '.' ){\n\t\t\t\tfor(int i3 = 0; i3 < 8; i3++){\n\t\t\t\t\tif(map[ i + dy[i3] ][ i2 + dx[i3] ] == '.'){\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tchar temp = map[i][i2];\n\t\t\t\tif(cnt >= atoi(&temp)){\n\t\t\t\t\tq.push(make_pair(i, i2));\n\t\t\t\t\tflg = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn flg;\n}\n\nint main(){\n\tint cnt = 0;\n\tcin >> y >> x;\n\n\tfor(int i = 0; i < y; i++){\n\t\tfor(int i2 = 0; i2 < x; i2++){\n\t\t\tcin >> map[i][i2];\n\t\t}\n\t}\n\n\twhile(!check_map()){\n\t\twhile(!q.empty()){\n\t\t\tpair<int, int> temp = q.front();\n\t\t\tq.pop();\n\t\t\tmap[temp.first][temp.second] = '.';\n\t\t}\n\t\tcnt++;\n\t}\n\n\tcout << cnt << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<string.h>\nusing namespace std;\nstruct log{\n\tint x,y;\n};\nqueue <log> cls;\nqueue <log> q;\nlog g;\nlong h,w,ans=0,length;\nchar sand[1004][1004];\nint main(){\n\tcin>>h>>w;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int o=0;o<w;o++){\n\t\t\tcin>>sand[i][o];\n\t\t\tif(sand[i][o]!='.'&&sand[i][o]!='9'){\n\t\t\t\tg.y=i;\n\t\t\t\tg.x=o;\n\t\t\t\tq.push(g);\n\t\t\t}\n\t\t}\n\t}\n\tint f,c,fx,fy,my[]={0,1,1,1,0,-1,-1,-1},mx[]={1,1,0,-1,-1,-1,0,1};\n\tdo{\n\t\tf=0;\n\t\twhile(!cls.empty()){\n\t\t\tg=cls.front();\n\t\t\tcls.pop();\n\t\t\tsand[g.y][g.x]='.';\n\t\t}\n\t\t/*for(int i=0;i<h;i++){\n\t\t\tfor(int yu=0;yu<w;yu++){\n\t\t\t\tcout<<sand[i][yu];\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}*/\n\t\tlength=q.size();\n\t\tfor(int i=0;i<length;i++){\n\t\t\tg=q.front();\n\t\t\tq.pop();\n\t\t\tc=0;\n\t\t\tfor(int r=0;r<8;r++){\n\t\t\t\tfx=g.x+mx[r];\n\t\t\t\tfy=g.y+my[r];\n\t\t\t\tif(fx>=0&&fx<w&&fy>=0&&fy<h&&sand[fy][fx]=='.'){\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(c>=sand[g.y][g.x]-48){\n\t\t\t\tcls.push(g);\n\t\t\t\t//cout<<sand[g.y][g.x]<<endl;\n\t\t\t\tf=1;\n\t\t\t}\n\t\t\telse if(c<sand[g.y][g.x]-48){\n\t\t\t\tq.push(g);\n\t\t\t}\n\t\t}\n\t\tif(f==1){\n\t\t\tans++;\n\t\t}\n\t}while(!cls.empty());\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mp make_pair\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;//cnt, coodinate\nstring grid[1111];\nint neiber[1111][1111];\nint dx[] = {0, 1, 1,  1,  0, -1, -1, -1};\nint dy[] = {1, 1, 0, -1, -1, -1,  0,  1};\nint w, h;\nbool renge(int x, int y){\n  return (0 <= x && x < w &&\n          0 <= y && y < h);\n}\nbool del(int x, int y){\n  if(!renge(x, y) ||\n     grid[y][x] == '.') return false;\n  int cnt = 0;\n  for (int i = 0; i < 8; i++) {\n    int nx = x + dx[i], ny = y + dy[i];\n    if(!renge(nx, ny))continue;\n    if(grid[ny][nx] == '.')cnt++;\n  }\n  char tmp = grid[y][x];\n  neiber[y][x] = cnt;\n  return cnt >= atoi(&tmp);\n}\n \nint main(int argc, char *argv[]){\n  queue<piii> que;\n  cin >> h >> w;\n  for (int i = 0; i < h; i++) {\n    cin >> grid[i];\n  }\n  for (int i = 0; i < h; i++) {\n    for (int j = 0; j < w; j++) {\n      if(del(j, i)){\n        que.push(mp(1, mp(j, i)));\n      }\n    }\n  }\n  int ans = 0;\n  while(!que.empty()){\n    int cnt = que.front().first;\n    int x = que.front().second.first;\n    int y = que.front().second.second;\n    que.pop();\n    if(grid[y][x] == '.')continue;\n    grid[y][x] = '.';\n    ans = cnt;\n    for (int i = 0; i < 8; i++) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if(!renge(nx, ny))continue;\n      char tmp = grid[ny][nx];\n      neiber[ny][nx]++;\n      if(neiber[ny][nx] >= atoi(&tmp)){\n        que.push(mp(cnt + 1, mp(nx, ny)));\n      }\n    }\n  }\n  std::cout << ans << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\n#include<iostream>\n\n#include<algorithm>\n\n#include<queue>\n\n#define REP(i,n) for(int i=0;i<(n);i++)\n\n#define RREP(i,n) for(int i=(n)-1;i>=0;i++)\n\nusing namespace::std;\n\ntypedef pair<int,int> P;\n\ntypedef pair<P,int> PP;\n\nqueue <PP> q;//width,height,cost\n\n\n\n\n\nbool judge(int,int);\n\nvoid solve();\n\nvoid loop();\n\n\n\nint h,w,map[2000][2000]={0},memo[2000][2000]={0},ans=0;//\n\n\n\nint main(){\n\n\tchar c;\n\n\tcin>>h>>w;\n\n\tREP(j,h)REP(i,w){\n\n\t\tcin>>c;\n\n\t\tif(c=='.')map[i][j]=0;\n\n\t\telse map[i][j]=int(c)-48;\n\n\t}\n\n\tsolve();\n\n\tloop();\n\n\t\n\n//\tREP(j,h){REP(i,w){\n\n//\t\tprintf(\"%d\",map[i][j]);\n\n//\t}printf(\"\\n\");}\n\n\tcout<<ans<<endl;\n\n}\n\n\n\nbool judge(int i,int j){\n\n\tint v=0;\n//\tcout<<\"hoge\"<<i<<\":\"<<j<<endl;\n\n\tif(map[i][j]==0)return false;\n\n\tREP(a,3)REP(b,3)if(map[i+a-1][j+b-1]==0&&!(a==1&&b==1))v++;\n//\tcout<<v<<endl;\n\n\tif(map[i][j]>v)return false;\n\n\telse return true;\n\n}\n\n\n\n\n\nvoid solve(){\n\n\tREP(j,w)REP(i,h){\n\n\t\tif(judge(i,j)==true){\n\n\t\t\tq.push(PP(P(i,j),1));\nmemo[i][j]=1;\n\n\t\t}\n\n\t}\t\n\n}\n\n\n\nvoid loop(){\n\nwhile(q.size()){\n\n\tPP p = q.front();q.pop();\n\n\t\n\n\tint k=p.second,i=p.first.first,j=p.first.second;\n\tmemo[i][j]=0;\n\n//\tcout<<q.size()<<\"[\"<<i<<\",\"<<j<<\"]cost:\"<<k<<endl;\n\tmap[i][j]=0;\n\n//\tif(judge(i,j)==true){\n\n\t\tREP(a,3)REP(b,3)if(memo[i+a-1][j+b-1]==0&&map[i+a-1][j+b-1]!=0&&judge(i+a-1,j+b-1)==true&&!(a==1&&b==1)){\n\n\t\t\tq.push(PP(P(i+a-1,j+b-1),(k+1)));\n\t\t\tmemo[i+a-1][j+b-1]=1;\n\n\t\t\tans=max(k+1,ans);\n\n//\t\t\tcout<<\"pushed!\"<<\"[\"<<i+a-1<<\",\"<<j+b-1<<\"]\"<<endl;\n//\t\t\tmap[i+a-1][j+b-1]=0;\n\n\t\t\t\n\n\t\t}\n\n//\t}\t\n\n//\tREP(j,h){REP(i,w){\n\n//\t\tprintf(\"%d\",map[i][j]);\n\n//\t}printf(\"\\n\");}\n\n\t\n\n}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<queue>\n#define MP make_pair\nusing namespace std;\nlong long int sc[1001][1001],ssc[1001][1001];\nchar c[1001];\nint main()\n{\n\tint h, w, cnt = 0, ans = 0, n;\n\tint x, y;\n\tpair<int, int> p;\n\tqueue< pair<int, int> > que;\n\tqueue< pair<int, int> >que1;\n\tscanf(\"%d%d\", &h, &w);\n\tfor (int i = 0; i < h; i++)\n\t{\n\t\tscanf(\"%s\", c);\n\t\tfor (int j = 0; j < w; j++)\n\t\t{\n\n\t\t\tif (c[j] == '.')\n\t\t\t\tsc[i][j] = -1;\n\t\t\telse\n\t\t\t\tsc[i][j] = c[j] - 48;\n\t\t}\n\t}\n\tfor (int i = 1; i < h; i++)\n\t{\n\t\tfor (int j = 1; j < w; j++)\n\t\t{\n\t\t\tif (sc[i][j] != -1)\n\t\t\t{\n\t\t\t\tfor (int a = i - 1; a < i + 2; a++)\n\t\t\t\t{\n\t\t\t\t\tfor (int b = j - 1; b < j + 2; b++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (sc[a][b] == -1)ssc[i][j] ++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (sc[i][j] <= ssc[i][j])\n\t\t\t\t\tque.push(MP(i, j));\n\t\t\t\telse if (sc[i][j] != 9)\n\t\t\t\t\tque1.push(MP(i, j));\n\t\t\t}\n\t\t}\n\t}\n\twhile (!que.empty())\n\t{\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tx = que.front().first;\n\t\t\ty = que.front().second;\n\t\t\tque.pop();\n\t\t\tfor (int a = -1; a < 2; a++)\n\t\t\t{\n\t\t\t\tssc[x - 1][y + a]++;\n\t\t\t\tssc[x + 1][y + a]++;\n\t\t\t}\n\t\t\tssc[x][y - 1]++;\n\t\t\tssc[x][y + 1]++;\n\t\t}\n\t\tn = que1.size();\n\t\tfor (int i=0;i<n;i++)\n\t\t{\n\t\t\tx = que1.front().first;\n\t\t\ty = que1.front().second;\n\t\t\tque1.pop();\n\t\t\tif (sc[x][y] <= ssc[x][y])\n\t\t\t\tque.push(MP(x, y));\n\t\t\telse if (sc[x][y] != 9)\n\t\t\t\tque1.push(MP(x, y));\n\t\t}\n\t\tans++;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\ntemplate<typename T>\nvector<vector<T> > make_v(size_t a,size_t b){\n  return vector<vector<T> >(a,make_v<T>(b));\n}\ntemplate<typename T>\nvector<vector<vector<T> > > make_v(size_t a,size_t b,size_t c){\n  return vector<vector<vector<T> > > (a,make_v<T>(b,c));\n}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value==0>::type\nfill_v(T &t,const V &v){t=v;}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t,const V &v){\n  for(auto &e:t) fill_v(e,v);\n}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int h,w;\n  cin>>h>>w;\n  vector<string> s(h);\n  for(Int i=0;i<h;i++) cin>>s[i];\n\n  auto cnt=make_v<signed char>(h,w);\n  fill_v(cnt,0);\n\n  Int dy[]={-1,-1,-1,0,1,1,1,0};\n  Int dx[]={-1,0,1,1,1,0,-1,-1};\n  for(Int i=1;i<h-1;i++)\n    for(Int j=1;j<w-1;j++)\n      for(Int k=0;k<8;k++)\n\tcnt[i][j]+=s[i+dy[k]][j+dx[k]]=='.';\n\n  auto used=make_v<signed char>(h,w);\n  fill_v(used,0);\n  using P = pair<Int, Int>;\n  queue<P> cur,nxt;\n\n  \n  for(Int i=1;i<h-1;i++){\n    for(Int j=1;j<w-1;j++){\n      if(s[i][j]=='.') continue;\n      if(cnt[i][j]>=s[i][j]-'0'){\n\ts[i][j]='.';\n\tused[i][j]=1;\n\tcur.emplace(i,j);\n      }\n    }\n  }\n  \n  auto dec=[&](Int y,Int x){\n    for(Int k=0;k<8;k++)\n      cnt[y+dy[k]][x+dx[k]]++;\n  };\n\n  Int ans=0;\n  while(!cur.empty()){\n    while(!cur.empty()){\n      Int y,x;\n      tie(y,x)=cur.front();cur.pop();\n      //cout<<y<<\" \"<<x<<endl;\n\n      dec(y,x);\n      \n      for(Int k=0;k<8;k++){\n\tInt ny=y+dy[k],nx=x+dx[k];\n\tif(s[ny][nx]=='.'||used[ny][nx]) continue;\n\tif(cnt[ny][nx]>=s[ny][nx]-'0'){\n\t  s[ny][nx]='.';\n\t  used[ny][nx]=1;\n\t  nxt.emplace(ny,nx);\n\t}\n      }\n    }\n    \n    ans++;\n    swap(cur,nxt);\n  }\n  \n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <queue>\nusing namespace std;\n\nconst int MAX_SIZE = 1000;\ntypedef pair<int, int> P;\ntypedef pair<int, P> Q;\n\nint calc(int f[][MAX_SIZE], queue<Q> q, int H, int W) {\n  for (int i = 0; i < H; ++i) {\n    for (int j = 0; j < W; ++j) {\n      cout << f[i][j];\n    }\n    cout << endl;\n  }\n\n  P d[] = {P(-1, -1), P(-1, 0), P(-1, 1), P(0, -1), P(0, 1), P(1, -1), P(1, 0), P(1, 1)};\n  int n = 0;\n  while (q.size()) {\n    int c = q.front().first;\n    P p = q.front().second;\n    q.pop();\n    if (c > n) n++;\n    for (int k = 0; k < 8; ++k) {\n      int i = p.first  + d[k].first;\n      int j = p.second + d[k].second;\n      if (i >= 0 && i < H && j >= 0 && j < W && --f[i][j] == 0) {\n        q.push(Q(c + 1, P(i, j)));\n      };\n    }\n  }\n  return n;\n}\n\nint main() {\n  int H, W;\n  int f[MAX_SIZE][MAX_SIZE];\n  queue<Q> q;\n\n  cin >> H >> W;\n  for (int i = 0; i < H; ++i) {\n    string str;\n    cin >> str;\n    for (int j = 0; j < W; ++j) {\n      if (str[j] == '.') {\n        f[i][j] = 0;\n        q.push(Q(0, P(i, j)));\n      } else {\n        f[i][j] = str[j] - '0';\n      }\n    }\n  }\n  cout << calc(f, q, H, W) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint dx[] = {1,1,0,-1,-1,-1,0,1};\nint dy[] = {0,-1,-1,-1,0,1,1,1};\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint h,w; cin >> h >> w;\n\n\tchar field[1005][1005];\n\n\tfor (int i = 0;i < h;i++){\n\t\tfor (int j = 0;j < w;j++){\n\t\t\tcin >> field[i][j];\n\t\t}\n\t}\n\n\tint cnt[1005][1005]; memset(cnt,0,sizeof(cnt));\n\tvector<P> lis[2];\n\n\tfor (int i = 0;i < h;i++){\n\t\tfor (int j = 0;j < w;j++){\n\t\t\tif(field[i][j] >= '1' && field[i][j] <= '9'){\n\t\t\t\tfor (int k = 0;k < 8;k++){\n\t\t\t\t\tint ni = i+dx[k], nj = j+dy[k];\n\t\t\t\t\tif(field[ni][nj] == '.') cnt[i][j]++;\n\t\t\t\t}\n\t\t\t\tif(cnt[i][j] >= field[i][j]-'0') lis[0].push_back(P(i,j));\n\t\t\t}\n\t\t}\n\t}\n\n\tint crt = 0, next = 1;\n\tint ans = 0;\n\n\twhile(lis[crt].size()){\n\t\tans++;\n\t\tmap<P,bool> mp;\n\t\tfor (int i = 0;i < lis[crt].size();i++){\n\t\t\tint ii = lis[crt][i].first, jj = lis[crt][i].second;\n\t\t\tfield[ii][jj] = '.';\n\t\t\tcnt[ii][jj] = 0;\n\t\t}\n\t\tfor (int i = 0;i < lis[crt].size();i++){\n\t\t\tint ii = lis[crt][i].first, jj = lis[crt][i].second;\n\t\t\tfor (int j = 0;j < 8;j++){\n\t\t\t\tint ni = ii+dx[j], nj = jj+dy[j];\n\t\t\t\tif(field[ni][nj] >= '1' && field[ni][nj] <= '9'){\n\t\t\t\t\tcnt[ni][nj]++;\n\t\t\t\t\tif(cnt[ni][nj] >= field[ni][nj]-'0'){\n\t\t\t\t\t\t   \tif(!mp[P(ni,nj)]){\n\t\t\t\t\t\t\t\tlis[next].push_back(P(ni,nj));\n\t\t\t\t\t\t\t\tmp[P(ni,nj)] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlis[crt] = vector<P>(0);\n\t\tswap(crt,next);\t\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<functional>\n#include<string>\n#include<vector>\n#include<utility>\n#include<queue>\nusing namespace std;\n\nint H, W, snd[1001][1001], ans = 0, scnt = 0;\nqueue<pair<int, int>> q;\n\nbool Is_inmap(int i, int j) {\n\tbool jud = true;\n\tif (i < 0 || j < 0) jud = false;\n\tif (i >= H || j >= W) jud = false;\n\treturn jud;\n}\n\nint main() {\n\t//input\n\tcin >> H >> W;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tchar C;  cin >> C;\n\t\t\tif (C == '.') {\n\t\t\t\tsnd[i][j] = -1;\n\t\t\t\tq.push({ i, j });\n\t\t\t}\n\t\t\telse snd[i][j] = C - 48;\n\t\t}\n\t}\n\tq.push({ -1, -1 });\n\twhile (!q.empty()) {\n\t\tpair<int, int> tp = q.front(); q.pop();\n\t\tint I = tp.first, J = tp.second; \n\t\tif(I == -1 && J == -1){\n\t\t\t/*\n\t\t\tcout << endl << \"ans = \" << ans << endl;\n\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\t\tcout << (snd[i][j] == -1 ? 0 : snd[i][j]);\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t\t*/\n\t\t\tif (scnt) {\n\t\t\t\tscnt = 0;\n\t\t\t\tq.push({ -1, -1 });//new wave\n\t\t\t}\n\t\t\telse break;//no change\n\t\t\tans++;//end of wave\n\t\t}\n\t\tfor (int i = -1; i <= 1; i++) {\n\t\t\tfor (int j = -1; j <= 1; j++) {\n\t\t\t\tint ni = I + i, nj = J + j;\n\t\t\t\tif (!Is_inmap(ni, nj)) continue;\n\t\t\t\tif (snd[ni][nj] > 0) {\n\t\t\t\t\tsnd[ni][nj]--;\n\t\t\t\t\tif (snd[ni][nj] == 0) {\n\t\t\t\t\t\tsnd[ni][nj]--;\n\t\t\t\t\t\tscnt++;\n\t\t\t\t\t\tq.push({ ni, nj });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<queue>\nusing namespace std;\nstring fie[1001];\nint fiec[1001][1001];\nint dy[8]={-1,-1,-1,0,0,1,1,1},dx[8]={-1,0,1,-1,1,-1,0,1};\nstruct data{\n    int y;\n    int x;\n    int n;\n};\nqueue<data> Q;\nqueue<int> lisy;\nqueue<int> lisx;\nint main(){\n    int H,W;\n    cin>>H>>W;\n    for(int i=0;i<H;i++)cin>>fie[i];\n    for(int i=1;i<H-1;i++){\n        for(int j=1;j<W-1;j++){\n            int cou=0;\n            for(int k=0;k<8;k++){\n                if(fie[i+dy[k]][j+dx[k]]=='.')cou++;\n            }\n            if(fie[i][j]-'0'<=cou)lisy.push(i),lisx.push(j);\n        }\n    }\n    int befn=0;\n    while(1){\n        if(lisy.size()==0)break;\n        befn++;\n        if(Q.size()==0){\n            while(lisy.size()){\n                int kariy,karix;\n                kariy=lisy.front();\n                karix=lisx.front(),lisy.pop(),lisx.pop();\n                fie[kariy][karix]='.';\n                for(int k=0;k<8;k++){\n                    if(fie[kariy+dy[k]][karix+dx[k]]!='.'){\n                        fiec[kariy+dy[k]][karix+dx[k]]=1;\n                        data kariba;\n                        kariba.y=kariy+dy[k],kariba.x=karix+dx[k],kariba.n=befn+1;\n                        Q.push(kariba);\n                    }\n                }\n            }\n        }\n        while(Q.size()){\n            data kari;\n            kari=Q.front(),Q.pop();\n            int cou=0;\n            if(kari.y!=0&&kari.y!=H-1&&kari.x!=0&&kari.x!=W-1){\n                for(int i=0;i<8;i++){\n                    if(fie[kari.y+dy[i]][kari.x+dx[i]]=='.')cou++;\n                }\n                if(fie[kari.y][kari.x]-'0'<=cou)lisy.push(kari.y),lisx.push(kari.x);\n            }\n        }\n    }\n    cout<<befn<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint H, W; char s[1009][1009]; bool vis[1009][1009];\nint main() {\n????????scanf(\"%d%d\", &H, &W);\n????????for (int i = 0; i < H; i++) scanf(\"%s\", s[i]);\n????????vector<pair<int, int> > v;\n????????for (int i = 0; i < H; i++) {\n????????????????for (int j = 0; j < W; j++) {\n????????????????????????if (s[i][j] == '.' || s[i][j] == '9') continue;\n????????????????????????int cnt = 0;\n????????????????????????for (int k = -1; k <= 1; k++) {\n????????????????????????????????for (int l = -1; l <= 1; l++) {\n????????????????????????????????????????int tx = j + l, ty = i + k;\n????????????????????????????????????????if (0 <= tx && tx < W && 0 <= ty && ty < H && s[ty][tx] == '.') cnt++;\n????????????????????????????????}\n????????????????????????}\n????????????????????????if (cnt >= s[i][j] - 48) v.push_back(make_pair(j, i));\n????????????????}\n????????}\n????????int ret = 0;\n????????for (; !v.empty(); ret++) {\n????????????????for (pair<int, int> i : v) s[i.second][i.first] = '.';\n????????????????vector<pair<int, int> > w;\n????????????????for (pair<int, int> i : v) {\n????????????????????????int sx = i.first, sy = i.second;\n????????????????????????for (int j = -1; j <= 1; j++) {\n????????????????????????????????for (int k = -1; k <= 1; k++) {\n????????????????????????????????????????int tx = sx + k, ty = sy + j;\n????????????????????????????????????????if (!(0 <= tx && tx < W && 0 <= ty && ty < H)) continue;\n????????????????????????????????????????if (s[ty][tx] == '.' || s[ty][tx] == '9' || vis[ty][tx]) continue;\n????????????????????????????????????????int cnt = 0;\n????????????????????????????????????????for (int l = -1; l <= 1; l++) {\n????????????????????????????????????????????????for (int m = -1; m <= 1; m++) {\n????????????????????????????????????????????????????????int ux = tx + m, uy = ty + l;\n????????????????????????????????????????????????????????if (0 <= ux && ux < W && 0 <= uy && uy < H && s[uy][ux] == '.') cnt++;\n????????????????????????????????????????????????}\n????????????????????????????????????????}\n????????????????????????????????????????if (cnt >= s[ty][tx] - 48) w.push_back(make_pair(tx, ty)), vis[ty][tx] = true;\n????????????????????????????????}\n????????????????????????}\n????????????????}\n????????????????for (pair<int, int> i : w) vis[i.second][i.first] = false;\n????????????????v = w;\n????????}\n????????printf(\"%d\\n\", ret);\n????????return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rrep(i,a,b) for(int i=(a);i<=(b);i++)\n#define P pair<int,int>\nusing namespace std;\n\nint dx[8]={-1,-1,0,1,1,1,0,-1};\nint dy[8]={0,-1,-1,-1,0,1,1,1};\n\nint h,w;\nint a[1002][1002];\nint b[1002][1002];\nstring s[1002];\n\nint make(int x,int y)\n{\n\tint ans=0;\n\trep(i,8)\n\t{\n\t\tint tx=x+dx[i];\n\t\tint ty=y+dy[i];\n\t\tif(s[tx][ty]=='.')ans++;\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tcin>>h>>w;\n\trep(i,h)cin>>s[i];\n\tvector<P> f[2];\n\tint now=0,pre=1,ans=0;\n\tbool flag;\n\trrep(i,1,h-2)\n\t{\n\t\trrep(j,1,w-2)\n\t\t{\n\t\t\ta[i][j]=make(i,j);\n\t\t\tif(s[i][j]!='.'&&s[i][j]-'0'<=a[i][j])f[now].pb(mp(i,j));\n\t\t}\n\t}\n\twhile(1)\n\t{\n\t\tflag=false;\n\t\tnow=!now;\n\t\tpre=!pre;\n\t\tf[now].clear();\n\t\tmemset(b,0,sizeof(b));\n\t\trep(i,f[pre].size())\n\t\t{\n\t\t\tP p=f[pre][i];\n\t\t\tif(s[p.fi][p.se]!='.'&&s[p.fi][p.se]-'0'<=a[p.fi][p.se])\n\t\t\t{\n\t\t\t\tflag=true;\n\t\t\t\ts[p.fi][p.se]='.';\n\t\t\t\trep(j,8)\n\t\t\t\t{\n\t\t\t\t\tint tx=p.fi+dx[j];\n\t\t\t\t\tint ty=p.se+dy[j];\n\t\t\t\t\tif(tx<=0||tx>=h-1||ty<=0||ty>=w-1)continue;\n\t\t\t\t\ta[tx][ty]++;\n\t\t\t\t\tif(s[tx][ty]!='.'&&s[tx][ty]-'0'==a[tx][ty])f[now].pb(mp(tx,ty));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(flag)ans++;\n\t\telse break;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define F first\n#define S second\nusing namespace std;\n\nint h, w;\nstring s[1111];\nint data[1111][1111];\ntypedef pair < int, int > P;\ntypedef pair < int, P > PP; \nqueue < PP > que;\n\nvoid cnt(int x, int y){\n\n  for(int i=-1;i<2;i++)\n    for(int j=-1;j<2;j++)\n      if(i+y >= 0 && j+x >= 0) data[i+y][j+x]++;\n}\n\n      \nint main(){\n\n  cin >> h >> w;\n  for(int i=0;i<h;i++) cin >> s[i];\n\n  for(int i=0;i<h;i++) for(int j=0;j<w;j++) if(s[i][j] == '.') cnt(j, i);\n\n  \n\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      if(s[i][j] != '.' && data[i][j] >= s[i][j]-'0') que.push( PP(1, P(j, i)) );\n      \n  int ans = 0;\n  while(!que.empty()){\n    PP p = que.front(); que.pop();\n    int x = p.S.F, y = p.S.S;\n\n    if(s[y][x] == '.') continue;\n\n    ans = max(ans, p.F);\n    s[y][x] = '.';\n    cnt(x, y);\n\n    for(int i=-1;i<2;i++){\n      for(int j=-1;j<2;j++){\n\tint xx = j+x, yy = i+y;\n\tif(xx >= 0 && yy >= 0 && s[yy][xx] != '.' && data[yy][xx] >= s[yy][xx]-'0')  que.push( PP(p.F+1, P(xx, yy)) );\n      }\n    }\n\n  }\n\n  cout << ans << endl;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <queue>\n#include <set>\n#include <algorithm>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nint dp[501][501];\n\nint main(void){\n\tint n1, n2; cin >> n1 >> n2;\n\tvector<int> a(n1), b(n2);\n\trep(i, n1) cin >> a[i];\n\trep(i, n2) cin >> b[i];\n\n\trep(i, 501)rep(j, 501)dp[i][j] = 0;\n\n\tfor (int i = 1; i <= n1; ++i){\n\t\tfor (int j = 1; j <= n2; ++j){\n\t\t\t// printf(\"%d %d\\n\", a[i], b[j]);\n\t\t\tif(a[i - 1] == b[j - 1]){\n\t\t\t\t// printf(\"%d %d\\n\", i, j);\n\t\t\t\t// printf(\"%d\\n\", dp[i - 1][j - 1]);\n\t\t\t\tdp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + 1);\n\t\t\t}\n\t\t\telse dp[i][j] = max(dp[i][j], max(dp[i - 1][j], dp[i][j - 1]));\n\t\t}\n\t}\n\t/*\n\trep(i, n1){\n\t\trep(j, n2){\n\t\t\tprintf(\"dp[%d][%d] = %d\\n\", i, j, dp[i][j]);\n\t\t}\n\t}\n\t*/\n\tprintf(\"%d\\n\", dp[n1][n2]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<queue>\n#include<fstream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint sand[1005][1005];\nbool used[1005][1005];\nconst int MAX=1007;\nqueue<int> q1,q2;\n\nint main(){\n\tstring sa;\n\tint i,j,k,l;\n\tint n,m;\n\tint a,b,c,d;\n\tcin>>n>>m;\n\tfor(i=0;i<n;i++){\n\t\tcin>>sa;\n\t\tfor(j=0;j<m;j++){\n\t\t\tif(sa[j]=='.'){\n\t\t\t\tfor(k=-1;k<=1;k++){\n\t\t\t\t\tfor(l=-1;l<=1;l++){\n\t\t\t\t\t\tif(i+k>0 && i+k<n-1 && j+l>0 && j+l<m-1){\n\t\t\t\t\t\t\tif(used[i+k][j+l])continue;\n\t\t\t\t\t\t\tused[i+k][j+l]=true;\n\t\t\t\t\t\t\tq1.push((i+k)*MAX+(j+l));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(char ca='1',k=1;k<10;k++,ca++){\n\t\t\t\tif(sa[j]==ca){\n\t\t\t\t\tsand[i][j]=k;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tmemset(used,false,sizeof(used));\n\tfor(i=0;;i++){\n\t\ta=q1.size();\n\t\tfor(j=0;j<a;j++){\n\t\t\tc=q1.front(),q1.pop();\n\t\t\tb=c/MAX,c%=MAX;\n\t\t\tif(sand[b][c]==0)continue;\n\t\t\tif(used[b][c])continue;\n\t\t\td=0;\n\t\t\tfor(k=-1;k<=1;k++){\n\t\t\t\tfor(l=-1;l<=1;l++){\n\t\t\t\t\tif(sand[b+k][c+l]==0)d++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(d<sand[b][c])continue;\n\t\t\tused[b][c]=true;\n\t\t\tq2.push(b*MAX+c);\n\t\t\tfor(k=-1;k<=1;k++){\n\t\t\t\tfor(l=-1;l<=1;l++){\n\t\t\t\t\tif(sand[b+k][c+l]==0)continue;\n\t\t\t\t\tq1.push((b+k)*MAX+(c+l));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(q2.empty())break;\n\t\twhile(!q2.empty()){\n\t\t\tc=q2.front(),q2.pop();\n\t\t\tb=c/MAX,c%=MAX;\n\t\t\tsand[b][c]=0;\n\t\t}\n\t}\n\tcout<<i<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <time.h>\n#include <math.h>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <iterator>\n#include <sstream>\n#include <string>\n#include <bitset>\nusing namespace std;\n#define FOR(I,F,N) for(int I = F; I < (int)(N); I++)\n#define rep(i, n) FOR(i, 0, n)\n#define FIN(V) cout<<V<<endl\n#define pb push_back\n#define INF (1 << 28)\n\ntemplate<typename T>\nvoid remove(vector<T>& vector, unsigned int index){\nvector.erase(vector.begin() + index);\n}\n\ntypedef pair<int, int> P;\ntypedef long long ll;\ntypedef priority_queue<int> pq;\nint StrToInt(string);\nstring IntToStr(int);\nint dx[8] = {-1, 0, 1, 1, 1, 0, -1, -1};\nint dy[8] = {1, 1, 1, 0, -1, -1, -1, 0};\n\nint w, h, ans = 0;\nint state[51][51];\nvoid show(){\n\trep(i,h){\n\t\trep(j,w){\n\t\t\tif(state[j][i] == 0)cout << '.';\n\t\t\telse cout << state[j][i];\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nint main(void){\n\tcin >> h >> w;\n\tfill_n(*state, 51*51, -1);\n\trep(i,h)rep(j,w){\n\t\tchar c;\n\t\tcin >> c;\n\t\tif(c == '.')state[j][i] = 0;\n\t\telse state[j][i] = c-'0';\n\t}\n\tqueue<P> que;\n\trep(i,h)rep(j,w){\n\t\tif(state[j][i] == 0)continue;\n\t\tint count = 0;\n\t\trep(k,8){\n\t\t\tint nx = j+dx[k];\n\t\t\tint ny = i+dy[k];\n\t\t\tif(nx < 0 || ny < 0 || state[nx][ny] == -1)continue;\n\t\t\tif(state[nx][ny] == 0)count++;\n\t\t}\n\t\tif(state[j][i] <= count){\n\t\t\tque.push(P(j, i));\n\t\t}\n\t}\n\t///show();\n\twhile(!que.empty()){\n\t\tqueue<P> reQue;\n\t\twhile(!que.empty()){\n\t\t\treQue.push(que.front());\n\t\t\t///cout << \"(\" << que.front().first << \",\" << que.front().second << \")\" << endl;\n\t\t\tstate[que.front().first][que.front().second] = 0;\n\t\t\tque.pop();\n\t\t}\n\t\tint memo[51][51] = {0};\n\t\twhile(!reQue.empty()){\n\t\t\tP p = reQue.front();\n\t\t\treQue.pop();\n\t\t\tint x = p.first;\n\t\t\tint y = p.second;\n\t\t\t///cout << \"(\" << x << \",\" << y << \")\" << endl;\n\t\t\trep(k,8){\n\t\t\t\tint nx = x+dx[k];\n\t\t\t\tint ny = y+dy[k];\n\t\t\t\tif(nx < 0 || ny < 0 || state[nx][ny] == -1)continue;\n\t\t\t\tif(state[nx][ny] == 0)continue;\n\t\t\t\tint count = 0;\n\t\t\t\trep(l,8){\n\t\t\t\t\tint nnx = nx+dx[l];\n\t\t\t\t\tint nny = ny+dy[l];\n\t\t\t\t\tif(nnx < 0 || nny < 0 || state[nnx][nny] == -1)continue;\n\t\t\t\t\tif(state[nnx][nny] == 0)count++;\n\t\t\t\t}\n\t\t\t\tif(state[nx][ny] <= count && !memo[nx][ny]){\n\t\t\t\t\tmemo[nx][ny]=1;\n\t\t\t\t\tque.push(P(nx, ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t///show();\n\t\tans++;\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}\n\n\n\nint StrToInt(string s){\n\tstringstream ss;\n\tss << s;\n\tint val;\n\tss >> val;\n\treturn val;\n}\nstring IntToStr(int i){\n\tstringstream ss;\n\tss << i;\n\treturn ss.str();\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <queue>\nusing namespace std;\ntypedef pair<int, int> P;\n \nint h, w, ans;\nint castle[1001][1001], times[1001][1001];\nint dx[] = {-1, 0, 1, -1, 1, -1, 0, 1}, dy[] = {-1, -1, -1, 0, 0, 1, 1, 1};\nchar beach[1001][1001];\n \ninline int input(){\n\tint temp;\n\tscanf(\"%d\", &temp);\n\treturn temp;\n}\n\nint main(){\n    h = input();\n    w = input();\n    for(int i = 0; i < h; i++){\n        scanf(\"%s\", beach[i]);\n    }\n \n    queue<P> Q;\n    for(int i = 0; i < h; i++){\n        for(int j = 0; j < w; j++){\n            if(beach[i][j] == '.'){\n                Q.push(P(i, j));\n            } else{\n                castle[i][j] = beach[i][j] - '0';\n            }\n        }\n    }\n \n    while(Q.size()){\n        P p = Q.front();\n        Q.pop();\n        ans = max(ans, times[p.first][p.second]);\n \n        for(int i = 0; i < 8; i++){\n            int y = p.first + dy[i], x = p.second + dx[i];\n            if(y < 0 || y >= h || x < 0 || x >= w){\n                continue;\n            }\n \n            castle[y][x]--;\n            if(castle[y][x] == 0){\n                Q.push(P(y, x));\n                times[y][x] = times[p.first][p.second] + 1;\n            }\n        }\n    }\n \n    printf(\"%d\\n\", ans);\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\n#define INF 1000000000\n\nusing namespace std;\n\nconst vector<int> dx = { 0, 1, 1, 1, 0, -1, -1, -1 };\nconst vector<int> dy = { -1, -1, 0, 1, 1, 1, 0, -1 };\n\nint H, W; vector<string> M;\n\nvector<vector<int> > state;\n\nint check(int x, int y, int s)\n{\n\tint ret = 0;\n\n\tfor (int dir = 0; dir < 8; dir++)\n\t{\n\t\tif (state[y + dy[dir]][x + dx[dir]] < s || M[y + dy[dir]][x + dx[dir]] == '.')\n\t\t{\n\t\t\tret++;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint main()\n{\n\tscanf(\"%d\", &H);\n\tscanf(\"%d\", &W);\n\n\tM = vector<string>(H);\n\n\tfor (int i = 0; i < H; i++) cin >> M[i];\n\n\tstate = vector<vector<int> >(H, vector<int>(W, INF));\n\n\tqueue<pair<int, int> > que;\n\n\tfor (int i = 1; i < H - 1; i++)\n\t{\n\t\tfor (int j = 1; j < W - 1; j++)\n\t\t{\n\t\t\tif (check(j, i, 1) >= M[i][j] - 48 && M[i][j] != '.')\n\t\t\t{\n\t\t\t\tque.push(make_pair(j, i)); state[i][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\twhile (!que.empty())\n\t{\n\t\tint x = que.front().first;\n\t\tint y = que.front().second; que.pop();\n\n\t\tfor (int dir = 0; dir < 8; dir++)\n\t\t{\n\t\t\tint x2 = x + dx[dir];\n\t\t\tint y2 = y + dy[dir];\n\n\t\t\tif (state[y2][x2] == INF && M[y2][x2] != '.' && check(x2, y2) >= M[y2][x2])\n\t\t\t{\n\t\t\t\tstate[y2][x2] = state[y][x] + 1;\n\n\t\t\t\tque.push(make_pair(x2, y2));\n\t\t\t}\n\t\t}\n\t}\n\n\tint ret = 0;\n\n\tfor (int i = 1; i < H - 1; i++)\n\t{\n\t\tfor (int j = 1; j < W - 1; j++)\n\t\t{\n\t\t\tif (state[i][j] != INF)\n\t\t\t{\n\t\t\t\tret = max(ret, state[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint dx[] = {-1,-1,-1,0,0,1,1,1},dy[] = {-1,0,1,-1,1,-1,0,1};\n\nint main(){\n\tint h,w,cnt[1000][1000] = {};\n\tstring field[1000];\n\tcin >> h >> w;\n\tfor(int i = 0;i < h;i++) cin >> field[i];\n\tfor(int i = 0;i < h;i++){\n\t\tfor(int j = 0;j < w;j++){\n\t\t\tif(field[i][j] == '.') continue;\n\t\t\tfor(int k = 0;k < 8;k++){\n\t\t\t\tint nx = i + dx[k],ny = j + dy[k];\n\t\t\t\tif(nx >= 0 && nx < h && ny >= 0 && ny < w && field[nx][ny] == '.') cnt[i][j]++;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int res = 0;;res++){\n\t\tbool chg = false;\n\t\tvector<P> chgs;\n\t\tfor(int i = 0;i < h;i++){\n\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\tif(field[i][j] != '.' && cnt[i][j] >= field[i][j] - '0'){\n\t\t\t\t\tfield[i][j] = '.';\n\t\t\t\t\tchg = true;\n\t\t\t\t\tfor(int k = 0;k < 8;k++){\n\t\t\t\t\t\tint nx = i + dx[k],ny = j + dy[k];\n\t\t\t\t\t\tif(nx >= 0 && nx < h && ny >= 0 && ny < w && field[nx][ny] != '.') {\n\t\t\t\t\t\t\tchgs.push_back(P(nx,ny));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < chgs.size();i++){\n\t\t\tint x = chgs[i].first,y = chgs[i].second;\n\t\t\tcnt[x][y]++;\n\t\t}\n\t\tif(!chg){\n\t\t\tcout << res << endl;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mp make_pair\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;//cnt, coodinate\nstring grid[1111];\nint neiber[1111][1111];\nint dx[] = {0, 1, 1,  1,  0, -1, -1, -1};\nint dy[] = {1, 1, 0, -1, -1, -1,  0,  1};\nint w, h;\nbool renge(int x, int y){\n  if(0 <= x && x < w &&\n     0 <= y && y < h)return true;\n  return false;\n}\nbool del(int x, int y){\n  int cnt = 0;\n  if(!(0 <= x && x < w &&\n       0 <= y && y < h))return false;\n  if(grid[y][x] == '.') return false;\n  for (int i = 0; i < 8; i++) {\n    int nx = x + dx[i], ny = y + dy[i];\n    if(!(0 <= nx && nx < w &&\n         0 <= ny && ny < h))continue;\n    if(grid[ny][nx] == '.')cnt++;\n  }\n  char tmp = grid[y][x];\n  neiber[y][x] = cnt;\n  if(cnt >= atoi(&tmp))return true;\n  else return false;\n}\n\nint main(int argc, char *argv[]){\n  queue<piii> que;\n  queue<pii> p;\n  cin >> h >> w;\n  for (int i = 0; i < h; i++) {\n    cin >> grid[i];\n  }\n  for (int i = 0; i < h; i++) {\n    for (int j = 0; j < w; j++) {\n      if(del(j, i)){\n        p.push(mp(j, i));\n        que.push(mp(1, mp(j, i)));\n      }\n    }\n  }\n  int ans = 0;\n  while(!que.empty()){\n    int cnt = que.front().first;\n    if(ans != cnt){\n      while(!p.empty()){\n        int x = p.front().first;\n        int y = p.front().second;\n        p.pop();\n        if(grid[y][x] == '.')continue;\n        grid[y][x] = '.';\n        for (int i = 0; i < 8; i++) {\n          int nx = x + dx[i], ny = y + dy[i];\n          if(!renge(nx, ny))continue;\n          neiber[ny][nx]++;\n        }\n      }\n    }\n    int x = que.front().second.first;\n    int y = que.front().second.second;\n    que.pop();\n    if(grid[y][x] == '.')continue;\n    ans = cnt;\n    for (int i = 0; i < 8; i++) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if(!renge(nx, ny))continue;\n      char tmp = grid[ny][nx];\n      if(neiber[ny][nx] >= atoi(&tmp) && grid[ny][nx] != '.'){\n        p.push(mp(nx, ny));\n        que.push(mp(cnt + 1, mp(nx, ny)));\n      }\n    }\n  }\n  std::cout << ans << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(void){\n    // Your code here!\n    int h,w;\n    cin >> h >> w;\n    queue<pair<pair<int,int>,int>> q;\n    pair<pair<int,int>,int> v;\n    vector<int> dx={1,1,1,-1,-1,-1,0,0},dy={1,-1,0,1,-1,0,1,-1};\n    vector<vector<int>> a(w+2,vector<int>(h+2));\n    for (int i=0;i<h+2;i++){\n        for (int j=0;j<w+2;j++){\n            a.at(j).at(i)=0;\n        }\n    }\n    for (int i=1;i<h+1;i++){\n        for (int j=1;j<w+1;j++){\n            char s;\n            cin >> s;\n            if (s!='.') a.at(j).at(i)=s-'0';\n        }\n    }\n    for (int i=1;i<h+1;i++){\n        for (int j=1;j<w+1;j++){\n            if (a.at(j).at(i)==0){\n                for (int k=0;k<8;k++){\n                    if (a.at(j+dx.at(k)).at(i+dy.at(k))!=0) {\n                        a.at(j+dx.at(k)).at(i+dy.at(k))--;\n                        if (a.at(j+dx.at(k)).at(i+dy.at(k))==0){\n                            a.at(j+dx.at(k)).at(i+dy.at(k))=10;\n                            v.first.first=j+dx.at(k);v.first.second=i+dy.at(k);v.second=1;\n                            q.push(v);\n                        }\n                    }\n                }\n            } \n        }\n    }\n    while(!q.empty()){\n        int x=q.front().first.first,y=q.front().first.second,p=q.front().second;\n        a.at(x).at(y)=0;\n        q.pop();\n        for (int k=0;k<8;k++){\n                    if (a.at(x+dx.at(k)).at(y+dy.at(k))!=0) {\n                        a.at(x+dx.at(k)).at(y+dy.at(k))--;\n                        if (a.at(x+dx.at(k)).at(y+dy.at(k))==0){\n                            v.first.first=x+dx.at(k);v.first.second=y+dy.at(k);v.second=p+1;\n                            q.push(v);\n                        }\n                    }\n                }\n            \n        }\n        cout << v.second << endl;\n    }\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\nint dp[1000][1000];\nchar ddpp[1000][1000];\nint cop[1000][1000];\nint main(){\n\tint h,w;\n\tcin>>h>>w;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tcin>>ddpp[i][j];\n\t\t\tif(ddpp[i][j]=='.')\n\t\t\t\tdp[i][j]=0;\n\t\t\tif(ddpp[i][j]=='1')\n\t\t\t\tdp[i][j]=1;\n\t\t\tif(ddpp[i][j]=='2')\n\t\t\t\tdp[i][j]=2;\n\t\t\tif(ddpp[i][j]=='3')\n\t\t\t\tdp[i][j]=3;\n\t\t\tif(ddpp[i][j]=='4')\n\t\t\t\tdp[i][j]=4;\n\t\t\tif(ddpp[i][j]=='5')\n\t\t\t\tdp[i][j]=5;\n\t\t\tif(ddpp[i][j]=='6')\n\t\t\t\tdp[i][j]=6;\n\t\t\tif(ddpp[i][j]=='7')\n\t\t\t\tdp[i][j]=7;\n\t\t\tif(ddpp[i][j]=='8')\n\t\t\t\tdp[i][j]=8;\n\t\t\tif(ddpp[i][j]=='9')\n\t\t\t\tdp[i][j]=9;\n\t\t}\n\t}\n\tint count=0;\n\tif(h!=1000||w!=1000){\n\twhile(true){\n\t\tfor(int i=0;i<h;i++)\n\t\t\tfor(int j=0;j<w;j++)\n\t\t\t\tcop[i][j]=dp[i][j];\n\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tint s=0;\n\t\t\t\tif(j>0&&cop[i][j-1]==0)\n\t\t\t\t\ts++;\n\t\t\t\tif(j<w-1&&cop[i][j+1]==0)\n\t\t\t\t\ts++;\n\t\t\t\tif(i>0){\n\t\t\t\t\tif(cop[i-1][j]==0)\n\t\t\t\t\t    s++;\n\t\t\t\t\tif(j>0&&cop[i-1][j-1]==0)\n\t\t\t\t\t\ts++;\n\t\t\t\t\tif(j<w-1&&cop[i-1][j+1]==0)\n\t\t\t\t\t\ts++;\n\t\t\t\t}\n\t\t\t\tif(i<h-1){\n\t\t\t\t\tif(cop[i+1][j]==0)\n\t\t\t\t\t    s++;\n\t\t\t\t\tif(j>0&&cop[i+1][j-1]==0)\n\t\t\t\t\t\ts++;\n\t\t\t\t\tif(j<w-1&&cop[i+1][j+1]==0)\n\t\t\t\t\t\ts++;\n\t\t\t\t}\n\t\t\t\tif(s>=dp[i][j])\n\t\t\t\t\tdp[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tbool G=true;\n\t\tint i=0;\n\t\twhile(true){\n\t\t\tint j=0;\n\t\t\twhile(true){\n\t\t\t\tif(cop[i][j]!=dp[i][j])\n\t\t\t\t\tG==false;\n\t\t\t}\n\t\t\ti++;\n\t\t\tif(i==h)\n\t\t\t\tbreak;\n\t\t}\n\t\tif(G==true)\n\t\t\tbreak;\n\t\tcount++;\n\t}\n\t}\n\tif(count==0)\n\t\tcount=993949;\n\tcout<<count<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define pb push_back\nusing pii = pair <int, int>;\n\nconst int N = 1011;\n\nchar c[N][N];\nint cnt[N][N];\n\nint main() {\n\tint n, m; cin >> n >> m;\n\tfor(int i = 1; i <= n; i ++)\n\t\tscanf(\"%s\", c[i] + 1);\n\tvector <pii> v;\n\tfor(int i = 1; i <= n; i ++)\n\t\tfor(int j = 1; j <= m; j ++) if(c[i][j] != '.') {\n\t\t\tfor(int s : {-1, 0, 1}) for(int t : {-1, 0, 1})\n\t\t\t\tcnt[i][j] += (c[i + s][j + t] == '.');\n\t\t\tif(cnt[i][j] >= c[i][j] - '0')\n\t\t\t\tv.pb({i, j});\n\t\t}\n\tint ans = 0;\n\twhile(v.size()) {\n\t\tvector <pii> u;\n\t\tfor(pii p : v)\n\t\t\tfor(int s : {-1, 0, 1}) for(int t : {-1, 0, 1}) {\n\t\t\t\tint i = p.fi + s, j = p.se + t;\n\t\t\t\tcnt[i][j] ++;\n\t\t\t\tif(c[i][j] != '.' && cnt[i][j] == c[i][j] - '0')\n\t\t\t\t\tu.pb({i, j});\n\t\t\t}\n\t\tv = u;\n\t\tans ++;\n\t}\n\tcout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<iostream>\n#include<math.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<string>\n#include<cmath>\n#include<set>\n#include<stack>\n\nusing namespace std;\n\nint h,w;\nint sa[1005][1005];\nint d[9]={-1,0,1};\nstruct P{\n    int x,y,h;\n    P(int a,int b, int c){x=a,y=b,h=c;}\n};\nint main(){\n    cin>>h>>w;\n    queue<P>q;\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            char c;\n            cin>>c;\n            if(c=='.'){\n                sa[i][j]=0;\n                q.push(P(j,i,0));\n            } else sa[i][j]=c-'0';\n        }\n    }\n    int ans=0;\n    while(q.size()){\n        P t=q.front();\n        int y=t.y,x=t.x,ph=t.h;\n        ans=ph;\n        q.pop();\n        for(int i=0;i<3;i++)\n            for(int j=0;j<3;j++){\n                int nx=x+d[i];\n                int ny=y+d[j];\n                if(nx>=0&&nx<w&&ny>=0&&ny<h&&--sa[ny][nx]==0)\n                    q.push(P(nx,ny,ph+1));\n            }\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int h, w;\n    int count = 0;\n    int dx[] = {1, 0, -1, 0, 1, 1, -1, -1};\n    int dy[] = {0, 1, 0, -1, 1, -1, 1, -1};\n    char prev[50][50], cur[50][50];\n    bool has_changed = true;\n    cin >> h >> w;\n    for (int y = 0; y < h; ++y) {\n        cin.ignore();\n        for (int x = 0; x < w; ++x) {\n            cin >> cur[y][x];\n        }\n    }\n    while (has_changed) {\n        has_changed = false;\n        for (int y = 0; y < h; ++y) {\n            for (int x = 0; x < w; ++x) {\n                prev[y][x] = cur[y][x];\n            }\n        }\n        for (int y = 0; y < h; ++y) {\n            for (int x = 0; x < w; ++x) {\n                int n = 0;\n                if (prev[y][x] == '.') {\n                    continue;\n                }\n                for (int i = 0; i < 8; ++i) {\n                    int nx = x + dx[i];\n                    int ny = y + dy[i];\n                    if (nx < 0 || ny < 0 || w <= nx || h <= ny) {\n                        continue;\n                    }\n                    if (prev[ny][nx] == '.') {\n                        ++n;\n                    }\n                }\n                if (cur[y][x] - '0' <= n) {\n                    cur[y][x] = '.';\n                    has_changed = true;\n                }\n            }\n        }\n        if (has_changed) {\n            ++count;\n        }\n    }\n    cout << count << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nstruct log{\n\tint x,y;\n};\nqueue <log> cls;\nqueue <log> q;\nlog g;\nlong h,w,ans=0,length;\nchar sand[1004][1004];\nint main(){\n\tcin>>h>>w;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int o=0;o<w;o++){\n\t\t\tcin>>sand[i][o];\n\t\t\tif(sand[i][o]=='9'){\n\t\t\t\tg.y=i;\n\t\t\t\tg.x=o;\n\t\t\t\tq.push(g);\n\t\t\t}\n\t\t}\n\t}\n\tint f,c,d,fx,fy,my[]={0,1,1,1,0,-1,-1,-1},mx[]={1,1,0,-1,-1,-1,0,1};\n\tint dx,dy;\n\tdo{\n\t\tlength=q.size();\n\t\tfor(int i=0;i<length;i++){\n\t\t\tg=q.front();\n\t\t\tq.pop();\n\t\t\tdx=g.x;\n\t\t\tdy=g.y;\n\t\t\tc=0;\n\t\t\tfor(int r=0;r<8;r++){\n\t\t\t\tfx=dx+mx[r];\n\t\t\t\tfy=dy+my[r];\n\t\t\t\tif(fx>=0&&fx<w&&fy>=0&&fy<h&&sand[fy][fx]!='.'&&sand[fy][fx]!='9'){\n\t\t\t\t\tsand[fy][fx]++;\n\t\t\t\t}\n\t\t\t\tif(fx>=0&&fx<w&&fy>=0&&fy<h&&sand[fy][fx]!='.'&&sand[fy][fx]=='9'){\n\t\t\t\t\tg.y=fy;\n\t\t\t\t\tg.x=fx;\n\t\t\t\t\tq.push(g);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsand[dy][dx]=-1;\n\t\t}\n\t}while(!q.empty());\n\tfor(int i=0;i<h;i++){\n\t\tfor(int o=0;o<w;o++){\n\t\t\tif(sand[i][o]!='9'&&sand[i][o]!='.'){\n\t\t\t\tg.y=i;\n\t\t\t\tg.x=o;\n\t\t\t\tq.push(g);\n\t\t\t}\n\t\t}\n\t}\n\tdo{\n\t\tf=0;\n\t\twhile(!cls.empty()){\n\t\t\tg=cls.front();\n\t\t\tcls.pop();\n\t\t\tsand[g.y][g.x]='.';\n\t\t}\n\t\tlength=q.size();\n\t\tfor(int i=0;i<length;i++){\n\t\t\tg=q.front();\n\t\t\tq.pop();\n\t\t\tc=0;\n\t\t\tfor(int r=0;r<8;r++){\n\t\t\t\tfx=g.x+mx[r];\n\t\t\t\tfy=g.y+my[r];\n\t\t\t\tif(fx>=0&&fx<w&&fy>=0&&fy<h&&sand[fy][fx]=='.'){\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(c>=sand[g.y][g.x]-48){\n\t\t\t\tcls.push(g);\n\t\t\t\tf=1;\n\t\t\t}\n\t\t\telse if(c<sand[g.y][g.x]-48){\n\t\t\t\tq.push(g);\n\t\t\t}\n\t\t}\n\t\tif(f==1){\n\t\t\tans++;\n\t\t}\n\t}while(!cls.empty());\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"queue\"\n#include \"Utility\"\n#include \"math.h\"\n\nusing namespace std;\nint H, W;\nchar status[1002][1002];\nint field[1002][1002];\npair<int, int> dir[8] = {make_pair(0,1),make_pair(1,1),make_pair(1,0),make_pair(1,-1),make_pair(0,-1),make_pair(-1,-1),make_pair(-1,0),make_pair(-1,1)};\nqueue<pair<int,int> > Q;\nqueue<pair<int, int> >del;\nint ans = 0;\nint box = 0;\nint num = 0;\nint x, y;\n\nint main() {\n\tcin >> H >>W;\n\tfor (int i = 1; i <= H; i++) {\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tcin >> status[i][j];\n\t\t\tif (status[i][j] == '.') {\n\t\t\t\tfield[i][j] = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfield[i][j] = status[i][j] - '0';\n\t\t\t}\n\t\t}\n\t}\n\t/*for (int i = 1; i <= H; i++) {\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tcout << field[i][j];\n\t\t}\n\t\tcout << \"\\n\";\n\t}\n\tcout << \"\\n\";*/\n\tfor (int i = 1; i <= H; i++) {\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tbox = 0;\n\t\t\tif (field[i][j] != 0) {\n\t\t\t\tfor (int k = 0; k < 8; k++) {\n\t\t\t\t\tif (field[i + dir[k].first][j + dir[k].second] == 0)box++;\n\t\t\t\t}\n\t\t\t\tif (box >= field[i][j]) {\n\t\t\t\t\tQ.push(make_pair(i, j));\n\t\t\t\t\tans = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdel = Q;\n\twhile (!del.empty()) {\n\t\ty = del.front().first;\n\t\tx = del.front().second;\n\t\tfield[y][x] = 0;\n\t\tdel.pop();\n\t}\n\twhile (1) {\n\t\t/*for (int i = 1; i <= H; i++) {\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\tcout << field[i][j];\n\t\t\t}\n\t\t\tcout << \"\\n\";\n\t\t}\n\t\tcout << \"\\n\";*/\n\t\tnum = Q.size();\n\t\tfor (int i = 0; i < num; i++) {\n\t\t\ty = Q.front().first;\n\t\t\tx = Q.front().second;\n\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\tif (field[y + dir[j].first][x + dir[j].second] != 0) {\n\t\t\t\t\tbox = 0;\n\t\t\t\t\tfor (int k = 0; k < 8; k++) {\n\t\t\t\t\t\tif (field[y + dir[j].first + dir[k].first][x + dir[j].second + dir[k].second] == 0)box++;\n\t\t\t\t\t}\n\t\t\t\t\tif (box >= field[y + dir[j].first][x + dir[j].second]) {\n\t\t\t\t\t\tQ.push(make_pair(y + dir[j].first, x + dir[j].second));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t\tif (Q.empty())break;\n\t\tans++;\n\t\tdel = Q;\n\t\twhile (!del.empty()) {\n\t\t\ty = del.front().first;\n\t\t\tx = del.front().second;\n\t\t\tfield[y][x] = 0;\n\t\t\tdel.pop();\n\t\t}\n\t}\n\tcout << ans << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF 999999999\n\n\nint main(){\n    int h,w;\n    while(cin>>h>>w){\n        string data[1200];\n        rep(i,h) cin>>data[i];\n        \n        static int num[1200][1200]={};\n        queue<pii> que;\n        for(int i=1;i<h-1;i++){\n            for(int j=1;j<w-1;j++){\n                for(int x=-1;x<=1;x++){\n                    for(int y=-1;y<=1;y++){\n                        if(x==0&&y==0)continue;\n                        if(data[i+y][j+x]=='.'){\n                            num[i][j]++;\n                        }\n                    }\n                }\n            if(isdigit(data[i][j]) && num[i][j]>=data[i][j]-'0')que.push(pii(i,j));\n            }\n        }\n        int c=1;\n        queue<pii> a,b;\n        a=que;\n        while(1){\n            int y=a.front().first, x=a.front().second;\n            a.pop();\n            data[y][x]='.';\n            for(int k=-1;k<=1;k++){\n                for(int l=-1;l<=1;l++){\n                    if(k==0&&l==0)continue;\n                    num[y+k][x+l]++;\n                }\n            }\n\n            for(int i=-1;i<=1;i++){\n                for(int j=-1;j<=1;j++){\n                    if(i==0&&j==0)continue;\n                    if( isdigit(data[y+i][x+j]) && num[y+i][x+j]==data[y+i][x+j]-'0'){\n                        b.push(pii(y+i,x+j));\n                    }\n                }\n            }\n            if(a.empty()){\n                if(b.empty())break;\n                else{\n                    a=b;\n                    while(b.size())b.pop();\n                    c++;\n                }\n            }\n        }\n        cout<<c<<endl;\n        \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <utility>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n\n#define INF_LL 9000000000000000000\n#define INF 2000000000\n\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int i = (a);i < (b);i++)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> PPII;\ntypedef pair<int, PPII> PPPII;\n\nclass Union_find{\nprivate:\n\tvector<int> par;\n\tvector<int> rank;\n\tint n;\n\npublic:\n\tUnion_find(int a){\n\t\tn = a;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tpar.push_back(i);\n\t\t\trank.push_back(0);\n\t\t}\n\t}\n\n\tint find(int x){\n\t\tif(par[x] == x){\n\t\t\treturn x;\n\t\t}else{\n\t\t\treturn par[x] = find(par[x]);\n\t\t}\n\t}\n\n\tvoid unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return;\n\n\t\tif(rank[x] < rank[y]){\n\t\t\tpar[x] = y;\n\t\t}else{\n\t\t\tpar[y] = x;\n\t\t\tif(rank[x] == rank[y]) rank[x]++;\n\t\t}\n\t}\n\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n};\n\nint dx[3] = {-1, 1, 0};\n\nint main(void){\n\tint h, w;\n\tstring sand[1010][2];\n\tcin >> h >> w;\n\tREP(i, h){\n\t\tcin >> sand[i][0];\n\t}\n\tint cnt = 1;\n\tint res = 0;\n\twhile(cnt != 0){\n\t\tcnt = 0;\n\t\tFOR(i, 1, h-1){\n\t\t\tFOR(j, 1, w-1){\n\t\t\t\tint sarati = 0;\n\t\t\t\tREP(x, 3){\n\t\t\t\t\tREP(y, 3){\n\t\t\t\t\t\tif(x == 2 && y == 2) continue;\n\t\t\t\t\t\tif(sand[i+dx[x]][res%2][j+dx[y]] == '.') sarati++;\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(sand[i][res%2][j] != '.' && sarati >= sand[i][res%2][j]-'0'){\n\t\t\t\t\tsand[i][(res+1)%2][j] = '.';\n\t\t\t\t\tcnt++;\n\t\t\t\t}else{\n\t\t\t\t\tsand[i][(res+1)%2][j] = sand[i][res%2][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(cnt > 0) res++;\n\t}\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<cctype>\n#include<cmath>\n#include<string>\n#include<set>\n#include<map>\n#include<queue>\n#include<vector>\nusing namespace std;\n\nint main() {\n\tint H, W;\n\tcin >> H >> W;\n\n\tchar c;\n\tstatic int a[1001][1001];\n\tfor (int i = 1; i <= H; i++)\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tcin >> c;\n\t\t\ta[i][j] = isdigit(c) ? (int)c-(int)'0' : 0;\n\t\t}\n\n\tint cnt = 0;\n\tstatic int temp[1001][1001] = { 0 };\n\tbool f;\n\tdo {\n\t\tf = false;\n\n\t\tfor (int i = 1; i <= H; i++)\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\tif (a[i][j] == 0) continue;\n\t\t\t\tint sarachi = 0;\n\t\t\t\tsarachi += (a[i - 1][j - 1] == 0) ? 1 : 0;\n\t\t\t\tsarachi += (a[i - 1][j] == 0) ? 1 : 0;\n\t\t\t\tsarachi += (a[i - 1][j + 1] == 0) ? 1 : 0;\n\t\t\t\tsarachi += (a[i][j - 1] == 0) ? 1 : 0;\n\t\t\t\tsarachi += (a[i][j + 1] == 0) ? 1 : 0;\n\t\t\t\tsarachi += (a[i + 1][j - 1] == 0) ? 1 : 0;\n\t\t\t\tsarachi += (a[i + 1][j] == 0) ? 1 : 0;\n\t\t\t\tsarachi += (a[i + 1][j + 1] == 0) ? 1 : 0;\n\t\t\t\tcout << sarachi <<\" \"<< a[i][j] << endl;\n\t\t\t\tif (sarachi >= a[i][j]) {\n\t\t\t\t\ttemp[i][j] = -1;\n\t\t\t\t\tf = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\tfor (int i = 1; i <= H; i++)\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\ta[i][j] = temp[i][j] == -1 ? 0 : a[i][j];\n\t\t\t}\n\n\t\tcnt += f ? 1 : 0;\n\n\t} while (f);\n\n\tcout << cnt << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <string>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nstruct state { int x, y, c; };\nbool operator<(const state& s1, const state& s2) { return s1.c > s2.c; }\nint dx[] = { 0, 1, 1, 1, 0, -1, -1, -1 };\nint dy[] = { 1, 1, 0, -1, -1, -1, 0, 1 };\nint H, W, dist[1009][1009]; string s[1009];\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> H >> W;\n\tpriority_queue<state> que;\n\tfor (int i = 0; i < H; i++) {\n\t\tcin >> s[i];\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (s[i][j] == '.') {\n\t\t\t\tdist[i][j] = 0;\n\t\t\t\tque.push(state{ i, j, 0 });\n\t\t\t}\n\t\t\telse dist[i][j] = 1012345678;\n\t\t}\n\t}\n\tint ret = 0;\n\twhile (!que.empty()) {\n\t\tstate u = que.top(); que.pop();\n\t\tret = max(ret, dist[u.x][u.y]);\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tint tx = u.x + dx[i], ty = u.y + dy[i];\n\t\t\tif (0 <= tx && tx < H && 0 <= ty && ty < W) {\n\t\t\t\tvector<int> v;\n\t\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\t\tint rx = tx + dx[j], ry = ty + dy[j];\n\t\t\t\t\tif (0 <= rx && rx < H && 0 <= ry && ry < W && dist[rx][ry] != -1) {\n\t\t\t\t\t\tv.push_back(dist[rx][ry]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsort(v.begin(), v.end());\n\t\t\t\tif (v.size() >= s[tx][ty] - 48 && dist[tx][ty] > v[s[tx][ty] - 49] + 1) {\n\t\t\t\t\tdist[tx][ty] = v[s[tx][ty] - 49] + 1;\n\t\t\t\t\tque.push(state{ tx, ty, dist[tx][ty] });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <queue>\nusing namespace std;\ntypedef pair<int, int> P;\n \nint h, w, ans;\nint castle[1001][1001], times[1001][1001];\nint dx[] = {-1, 0, 1, -1, 1, -1, 0, 1}, dy[] = {-1, -1, -1, 0, 0, 1, 1, 1};\nchar beach[1001][1001];\n \nint main(){\n    scanf(\"%d%d\", &h, &w);\n    for(int i = 0; i < h; i++){\n        for(int j = 0; j < w; j++){\n            scanf(\"%c\", &beach[i][j]);\n        }\n    }\n \n    queue<P> Q;\n    for(int i = 0; i < h; i++){\n        for(int j = 0; j < w; j++){\n            if(beach[i][j] == '.'){\n                Q.push(P(i, j));\n            } else{\n                castle[i][j] = beach[i][j] - 48;\n            }\n        }\n    }\n \n    while(Q.size()){\n        P p = Q.front();\n        Q.pop();\n        ans = max(ans, times[p.first][p.second]);\n \n        for(int i = 0; i < 8; i++){\n            int y = p.first + dy[i], x = p.second + dx[i];\n            if(y < 0 || y >= h || x < 0 || x >= w){\n                continue;\n            }\n \n            castle[y][x]--;\n            if(castle[y][x] == 0){\n                Q.push(P(y, x));\n                times[y][x] = times[p.first][p.second] + 1;\n            }\n        }\n    }\n \n    printf(\"%d\\n\", ans);\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define Rep(i, a, b) for(int i = (a); i < (b); i++)\n#define rep(i, n) Rep(i, 0, n)\n\nint movX[8] = {-1, 0, 1,-1, 1,-1, 0, 1};\nint movY[8] = {-1,-1,-1, 0, 0, 1, 1, 1};\n\ntemplate<class T> T read() {\n\tT t;\n\tcin >> t;\n\treturn t;\n}\n\nint main(){\n\tint h=read<int>(),w=read<int>();\n\tint mp[h][w];\n\trep(i,h) rep(j,w){\n\t\tchar c=read<char>();\n\t\tif(c=='.'){\n\t\t\tmp[i][j]=0;\t\t\t\n\t\t}else{\n\t\t\tmp[i][j]=c-'0';\n\t\t}\n\t}\n\tint around[h][w];\n\tRep(i, 1, h-1){\n\t\tRep(j, 1, w-1){\n\t\t\tint a = 0;\n\t\t\trep(k,8) {\n\t\t\t\tint x = i+movX[k];\n\t\t\t\tint y = j+movY[k];\n\t\t\t\t// printf(\"(%d, %d) -> (%d, %d) \", i, j, x, y);\n\t\t\t\tif(!mp[x][y]){\n\t\t\t\t\t// cout << \"o\";\n\t\t\t\t\ta++;\n\t\t\t\t}\n\t\t\t\t// cout << endl;\n\t\t\t}\n\t\t\taround[i][j]=a;\n\t\t}\n\t}\n\t// return 0;\n\t\t// rep(i,h){\n\t\t// \trep(j,w){\n\t\t// \t\tcout << mp[i][j];\n\t\t// \t}\n\t\t// \tcout << \" \";\n\t\t// \trep(j,w){\n\t\t// \t\tif(around[i][j]<0)\n\t\t// \t\t\tcout << \"x\";\n\t\t// \t\telse\n\t\t// \t\t\tcout << around[i][j];\n\t\t// \t}\n\t\t// \tcout << endl;\n\t\t// }\n\t\t// cout << \"-------------------------------------------\" << endl;\n\t\n\ttypedef pair<int, int> pii;\n\t\n\tint count = 0;\n\twhile(true){\n\t\tvector<pii> list;\n\t\tRep(i, 1, h-1){\n\t\t\tRep(j, 1, w-1){\n\t\t\t\tif(mp[i][j]>0 && around[i][j]>=mp[i][j]){\n\t\t\t\t\t// cout << i << \" \" << j << endl;\n\t\t\t\t\tlist.push_back(pii(i,j)); // mp[i][j] = 0;\n\t\t\t\t\t// now++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(list.size()==0){\n\t\t\tbreak;\n\t\t}\n\t\tcount++;\n\t\tfor(vector<pii>::iterator it=list.begin();it!=list.end();it++){\n\t\t\tint i = it->first, j = it->second;\n\t\t\tmp[i][j] = 0;\n\t\t\trep(k,8) {\n\t\t\t\tint x = i+movX[k];\n\t\t\t\tint y = j+movY[k];\n\t\t\t\taround[x][y]++;\n\t\t\t}\n\t\t}\n\t\t// rep(i,h){\n\t\t// \trep(j,w){\n\t\t// \t\tcout << mp[i][j];\n\t\t// \t}\n\t\t// \tcout << \" \";\n\t\t// \trep(j,w){\n\t\t// \t\tif(around[i][j]<0)\n\t\t// \t\t\tcout << \"x\";\n\t\t// \t\telse\n\t\t// \t\t\tcout << around[i][j];\n\t\t// \t}\n\t\t// \tcout << endl;\n\t\t// }\n\t\t// cout << \"-------------------------------------------\" << endl;\n\t}\n\tcout << count << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<utility>\n#include<string>\nusing namespace std;\ntypedef pair<int, int>P;\n\nstring sand[1005];\nint sara[1005][1005];\nqueue<P>now;\nqueue<P>nxt;\n\nint main() {\n\tint h, w;\n\tcin >> h >> w;\n\n\tfor (int i = 0;i<h;i++)cin >> sand[i];\n\n\tfor (int i = 0;i<h;i++) {\n\t\tfor (int j = 0;j<w;j++) {\n\t\t\tif (sand[i][j] != '.') {\n\t\t\t\tfor (int k = -1;k <= 1;k++) {\n\t\t\t\t\tfor (int l = -1;l <= 1;l++) {\n\t\t\t\t\t\tif (sand[i + k][j + l] == '.')sara[i][j]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0;i<h;i++) {\n\t\tfor (int j = 0;j<w;j++) {\n\t\t\tif (sand[i][j] != '.') {\n\t\t\t\tint a = sand[i][j] - '0';\n\t\t\t\tif (a <= sara[i][j]) {\n\t\t\t\t\tnow.push(make_pair(i, j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\twhile (now.size()) {\n\t\tans++;\n\t\tint a = now.size();\n\t\tqueue<P>q;\n\n\t\tfor (int i = 0;i < a;i++) {\n\t\t\tP p = now.front();\n\t\t\tnow.pop();\n\n\t\t\tint f = p.first, s = p.second;\n\n\t\t\tif (sand[f][s]!='.'&&(sara[f][s] >= sand[f][s] - '0')) {\n\t\t\t\tsand[f][s] = '.';\n\n\t\t\t\tfor (int j = -1;j <= 1;j++) {\n\t\t\t\t\tfor (int k = -1;k <= 1;k++) {\n\t\t\t\t\t\tif (sand[f + j][s + k] != '.') { q.push(make_pair(f + j, s + k)); }\n\t\t\t\t\t\tsara[f + j][s + k]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint b = q.size();\n\t\tfor (int i = 0;i < b;i++) {\n\t\t\tP pa = q.front();\n\t\t\tq.pop();\n\t\t\tif ((sand[pa.first][pa.second] != '.') && sara[pa.first][pa.second] >= (sand[pa.first][pa.second] - '0'))nxt.push(pa);\n\t\t}\n\n\t\tqueue<P>kari;\n\t\tnow = nxt;\n\t\tnxt = kari;\n\n\t}\n\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n#define INF 10000000\ntypedef pair<int, int>P;\nint h, w;\nint f[1005][1005] = { 0 };\nint cnt[1005][1005] = { 0 };\nint t[1005][1005] = { 0 };\nint res = 0;\nvoid bfs() {\n\tqueue<P>que;\n\tqueue<P>que2;\n\tfor (int i = 0; i < h; i++) {\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tif (f[i][j]) {\n\t\t\t\tfor (int k = -1; k <= 1; k++) {\n\t\t\t\t\tfor (int l = -1; l <= 1; l++) {\n\t\t\t\t\t\tif (f[i + k][j + l] == 0) cnt[i][j]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (cnt[i][j] >= f[i][j]) {\n\t\t\t\t\tque.push(P(i, j));\n\t\t\t\t\tt[i][j] = 1;\n\t\t\t\t\tque2.push(P(i, j));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse cnt[i][j] = -1;\n\t\t}\n\t}\n\twhile (!que2.empty()) {\n\t\tP p = que2.front();\n\t\tque2.pop();\n\t\tf[p.first][p.second] = 0;\n\t}\n\twhile (true) {\n\t\tP p = que.front();\n\t\tque.pop();\n\t\tfor (int i = -1; i <= 1; i++) {\n\t\t\tfor (int j = -1; j <= 1; j++) {\n\t\t\t\tint nx = p.first + i;\n\t\t\t\tint ny = p.second + j;\n\t\t\t\tcnt[nx][ny]++;\n\t\t\t\tif (f[nx][ny]) {\n\t\t\t\t\tif (cnt[nx][ny] == f[nx][ny]) {\n\t\t\t\t\t\tque2.push(P(nx, ny));\n\t\t\t\t\t\tt[nx][ny] = t[p.first][p.second] + 1;\n\t\t\t\t\t\tres = max(res, t[nx][ny]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (que.empty()) {\n\t\t\tif (que2.empty()) goto e;\n\t\t\twhile (!que2.empty()) {\n\t\t\t\tP p = que2.front();\n\t\t\t\tque2.pop();\n\t\t\t\tf[p.first][p.second] = 0;\n\t\t\t\tque.push(P(p.first, p.second));\n\t\t\t}\n\t\t}\n\n\t}\ne:;\n\tcout << res << endl;\n\treturn;\n}\nint main() {\n\tcin >> h >> w;\n\tfor (int i = 0; i < h; i++) {\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tif (c == '.') f[i][j] = 0;\n\t\t\telse f[i][j] = c - '0';\n\t\t}\n\t}\n\tbfs();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<map>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define in_range(x,l,r) (l<=x && x<r)\nusing namespace std;\ntypedef pair<int,int> pii;\n\nconst int INF = 1e9+7;\nconst int dy[] = {-1,-1,0,1,1,1,0,-1}, dx[] = {0,1,1,1,0,-1,-1,-1};\n\nbool check(int y, int x, int k, vector< vector<int> > &d, int t){\n  int h = d.size(), w = d[0].size();\n  int cnt = 0;\n  rep(i,8){\n    int ny = y+dy[i], nx = x+dx[i];\n    if(!in_range(ny,0,h) || !in_range(nx,0,w))continue;\n    if(d[ny][nx] <= t)cnt++;\n  }\n  //cout << y << \" \" << x << \" \" << cnt << endl;\n\n  return (k <= cnt);\n}\n\nint main(){\n  int h,w;\n  cin >> h >> w;\n\n  vector<string> g(h);\n  vector< vector<int> > d(h,vector<int>(w,INF));\n\n  queue<pii> q;\n  rep(i,h){\n    cin >> g[i];\n    rep(j,w){\n      if(g[i][j] == '.'){\n\tq.push(pii(i,j));\n\td[i][j] = 0;\n      }\n    }\n  }\n\n  int res = 0;\n  while(q.size()){\n    pii p = q.front(); q.pop();\n    int y = p.first, x = p.second;\n\n    res = max(res, d[y][x]);\n\n    rep(i,8){\n      int ny = y+dy[i], nx = x+dx[i];      \n      if(!in_range(ny,0,h) || !in_range(nx,0,w))continue;\n      \n      if(g[ny][nx] != '.' && check(ny,nx,g[ny][nx]-'0',d,d[y][x])){\n\tg[ny][nx] = '.';\n\td[ny][nx] = d[y][x] + 1;\n\tq.push(pii(ny,nx));\n      }\n    }\n  }\n  /*\n  rep(i,h){\n    rep(j,w)cout << d[i][j] << \" \";\n    cout << endl;\n  }\n  */\n\n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstring>\nusing namespace std;\n\nint main(){\n\tstring S;\n\tint n,m,t,sum,a;\n\tsum=0;\n\tint x[52][52];\n\tbool y[52][52];\n\tmemset(x,0,sizeof(x));\n\tchar T[10]={'.','1','2','3','4','5','6','7','8','9'};\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>S;\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tfor(int k=0;k<10;k++){\n\t\t\t\tif(S[j-1]==T[k]){\n\t\t\t\t\tx[i][j]=k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\twhile(true){\n\t\tt=0;\n\t\tsum++;\n\t\tmemset(y,false,sizeof(y));\n\t\tfor(int i=2;i<n;i++){\n\t\t\tfor(int j=2;j<m;j++){\n\t\t\t\tif(x[i][j]>=1){\n\t\t\t\t\ta=0;\n\t\t\t\t\tfor(int k=-1;k<=1;k++){\n\t\t\t\t\t\tfor(int l=-1;l<=1;l++){\n\t\t\t\t\t\t\tif(k!=0 || l!=0){\n\t\t\t\t\t\t\t\tif(x[i+k][j+l]==0){\n\t\t\t\t\t\t\t\t\ta++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(a>=x[i][j]){\n\t\t\t\t\t\ty[i][j]=true;\n\t\t\t\t\t\tt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\t\n\t\t}\n\t\tif(t==0){\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i=2;i<n;i++){\n\t\t\tfor(int j=2;j<=m;j++){\n\t\t\t\tif(y[i][j]==true){\n\t\t\t\t\tx[i][j]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<sum<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <string>\nusing namespace std;\n#define F first\n#define S second\nconst int INF = 1 << 31, MAX_HW = 1000;\ntypedef pair<int, int> P;\n\nint check(int x, int y);\nint h, w, ans;\nint land[MAX_HW + 2][MAX_HW + 2];\nqueue<P> que;\n\nint main(){\n\n  cin >> h >> w;\n  for(int i = 1; i <= h; i++){\n    for(int j = 1; j <= w; j++){\n      char in;\n      cin >> in;\n      land[i][j] = in - 48; // . = -2 \n    }\n  }\n  for(int i = 1; i <= h; i++){\n    for(int j = 1; j <= w; j++){\n      if(land[i][j] != -2 && land[i][j] <= check(i, j)){\n\tque.push(P(i, j));\n      }\n    }\n  }\n  for(;;){\n    queue<P> que2;\n    while(!que.empty()){\n      bool reach[MAX_HW + 2][MAX_HW + 2] = {};\n      P p =que.front();\n      que.pop();\n      land[p.F][p.S] = -2;\n      for(int i = -1; i <= 1; i++){\n\tfor(int j = -1; j <= 1; j++){\n\t  if(land[p.F+i][p.S+j] != -2 && !reach[p.F+i][p.S+j] && land[p.F+i][p.S+j] <= check(p.F+i, p.S+j)){\n\t    que2.push(P(p.F + i,p.S + j));\n\t  }\n\t}\n      }\n    }\n    ans++;\n    if(que2.empty()){\n      break;\n    }\n    while(!que2.empty()){\n      que.push(que2.front());\n      que2.pop();\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n\n\nint check(int y, int x){\n  int re = 0;\n  for(int i = -1; i <= 1; i++){\n    for(int j = -1; j <= 1; j++){\n      if(land[y+i][x+j]==-2){\n\tre++;\n      }\n    }\n  }\n  return re;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define F first\n#define S second\nusing namespace std;\n\nint h, w;\nstring s[1111];\nint data[1111][1111];\ntypedef pair < int, int > P;\ntypedef pair < int, P > PP; \nqueue < PP > que;\n\nvoid cnt(int x, int y){\n\n  for(int i=-1;i<2;i++)\n    for(int j=-1;j<2;j++)\n      if(i+y >= 0 && j+x >= 0) data[i+y][j+x]++;\n}\n\n      \nint main(){\n\n  cin >> h >> w;\n  for(int i=0;i<h;i++) cin >> s[i];\n\n  for(int i=0;i<h;i++) for(int j=0;j<w;j++) if(s[i][j] == '.') cnt(j, i);\n\n  \n\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      if(s[i][j] != '.' && data[i][j] >= s[i][j]-'0')\n\tque.push( PP(1, P(j, i)) );\n      \n  int ans = 0;\n  while(!que.empty()){\n    PP p = que.front(); que.pop();\n    int x = p.S.F, y = p.S.S;\n\n    if(s[y][x] == '.') continue;\n    ans = max(ans, p.F);\n\n    s[y][x] = '.';\n    cnt(x, y);\n\n    for(int i=-1;i<2;i++){\n      for(int j=-1;j<2;j++){\n\tint xx = j+x, yy = i+y;\n\tif(xx >= 0 && yy >= 0 && s[yy][xx] != '.' && data[yy][xx] >= s[yy][xx]-'0')\n\t  que.push( PP(p.F+1, P(xx, yy)) );\n      }\n    }\n\n  }\n\n  cout << ans << endl;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<utility>\n#include<string>\nusing namespace std;\ntypedef pair<int, int>P;\n\nstring sand[1005];\nint sara[1005][1005];\nqueue<P>now;\nqueue<P>nxt;\n\nint main() {\n\tint h, w;\n\tcin >> h >> w;\n\n\tfor (int i = 0;i<h;i++)cin>>sand[i];\n\n\tfor (int i = 0;i<h;i++) {\n\t\tfor (int j = 0;j<w;j++) {\n\t\t\tif (sand[i][j] != '.') {\n\t\t\t\tfor (int k = -1;k <= 1;k++) {\n\t\t\t\t\tfor (int l = -1;l <= 1;l++) {\n\t\t\t\t\t\tif (sand[i + k][j + l] == '.')sara[i][j]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0;i<h;i++) {\n\t\tfor (int j = 0;j<w;j++) {\n\t\t\tif (sand[i][j] != '.') {\n\t\t\t\tint a = sand[i][j] - '0';\n\t\t\t\tif (a <= sara[i][j]) {\n\t\t\t\t\tnow.push(make_pair(i, j));\n\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\n\twhile(now.size()){\n\tint a = now.size();\n\tqueue<P>q;\n\n\tfor (int i = 0;i < a;i++) {\n\t\tP p = now.front();\n\t\tnow.pop();\n\n\t\tint f = p.first, s = p.second;\n\n\t\tsand[f][s] = '.';\n\t\tsara[f][s] = 0;\n\t\t\n\t\tfor (int j = -1;j <= 1;j++) {\n\t\t\tfor (int k = -1;k <= 1;k++) {\n\t\t\t\tif (sand[f + j][s + k] != '.')q.push(make_pair(f + j, s + k));\n\t\t\t}\n\t\t}\n\t}\n\n\tint b = q.size();\n\tfor (int i = 0;i < b;i++) {\n\t\tP pa = q.front();\n\t\tq.pop();\n\t\tint m=0;\n\t\tfor (int j = -1;j <= 1;j++) {\n\t\t\tfor (int k = -1;k <= 1;k++) {\n\t\t\t\tif (sand[pa.first + j][pa.second + k] == '.')m++;\n\t\t\t}\n\t\t}\n\t\tsara[pa.first][pa.second] = m;\n\t\tif (sara[pa.first][pa.second] >= sand[pa.first][pa.second] - '0')nxt.push(pa);\n\t}\n\n\tint c=nxt.size();\n\n\tfor(int i=0;i<c;i++){\n\tnow.push(nxt.front());\n\tnxt.pop();\n\t}\n\n\tans++;\n\t}\n\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <queue>\nusing namespace std;\ntypedef pair<int, int> P;\n \nint h, w, ans;\nint castle[1001][1001], times[1001][1001];\nint dx[] = {-1, 0, 1, -1, 1, -1, 0, 1}, dy[] = {-1, -1, -1, 0, 0, 1, 1, 1};\nchar beach[1001][1001];\n \ninline int input_i(){\n\tint temp;\n\tscanf(\"%d\", &temp);\n\treturn temp;\n}\n\ninline char input_c(){\n\tchar temp;\n\tscanf(\"%c\", &temp);\n\treturn temp;\n}\n\n\nint main(){\n    h = input_i();\n    w = input_i();\n    for(int i = 0; i < h; i++){\n        beach[i] = input_c();\n    }\n \n    queue<P> Q;\n    for(int i = 0; i < h; i++){\n        for(int j = 0; j < w; j++){\n            if(beach[i][j] == '.'){\n                Q.push(P(i, j));\n            } else{\n                castle[i][j] = beach[i][j] - '0';\n            }\n        }\n    }\n \n    while(Q.size()){\n        P p = Q.front();\n        Q.pop();\n        ans = max(ans, times[p.first][p.second]);\n \n        for(int i = 0; i < 8; i++){\n            int y = p.first + dy[i], x = p.second + dx[i];\n            if(y < 0 || y >= h || x < 0 || x >= w){\n                continue;\n            }\n \n            castle[y][x]--;\n            if(castle[y][x] == 0){\n                Q.push(P(y, x));\n                times[y][x] = times[p.first][p.second] + 1;\n            }\n        }\n    }\n \n    printf(\"%d\\n\", ans);\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint a;\nint b;\nchar are[1001][1001];\nint kore[1001][1001];\nint sore[1001][1001];\nint sata[1001][1001];\nint ushi;\nint uma;\n\nint main(){\n\tcin >> a >> b;\n\tfor (int i = 0; i < a; i++){\n\t\tfor (int j = 0; j < b; j++){\n\t\t\tcin >> are[i][j];\n\t\t\tif (are[i][j] !='.'){\n\t\t\tkore[i - 1][j - 1]++;\n\t\t\tkore[i][j - 1]++;\n\t\t\tkore[i + 1][j - 1]++;\n\t\t\tkore[i - 1][j]++;\n\t\t\tkore[i + 1][j]++;\n\t\t\tkore[i - 1][j + 1]++;\n\t\t\tkore[i][j + 1]++;\n\t\t\tkore[i + 1][j + 1]++;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < a; i++){\n\t\tfor (int j = 0; j < b; j++){\n\t\t\tsore[i][j] = kore[i][j];\n\t\t\tsata[i][j] = 1;\n\t\t//\tcout<<sore[i][j];\n\t\t}\n\t}\n\twhile (true){\n\t\tuma = 0;\n\t\tfor (int i = 1; i < a; i++){\n\t\t\tfor (int j = 1; j < b; j++){\n\t\t\t\tif (sata[i - 1][j - 1] ==1||sata[i][j - 1] == 1||sata[i + 1][j - 1] == 1||sata[i - 1][j] == 1||sata[i + 1][j] == 1||sata[i - 1][j + 1] == 1||sata[i][j + 1] == 1||sata[i + 1][j + 1] == 1){\n\t\t\t\t\t//cout<<are[i][j]<<\" \"<<9-sore[i][j]<<endl;\n\t\t\t\t\tif (are[i][j] != '.'&&9-sore[i][j] > are[i][j]-48){\n\t\t\t\t\t//cout<<1234<<endl;\n\t\t\t\t\t\tare[i][j] = '.';\n\t\t\t\t\t\tkore[i - 1][j - 1]--;\n\t\t\t\t\t\tkore[i][j - 1]--;\n\t\t\t\t\t\tkore[i + 1][j - 1]--;\n\t\t\t\t\t\tkore[i - 1][j]--;\n\t\t\t\t\t\tkore[i + 1][j]--;\n\t\t\t\t\t\tkore[i - 1][j + 1]--;\n\t\t\t\t\t\tkore[i][j + 1]--;\n\t\t\t\t\t\tkore[i + 1][j + 1]--;\n\t\t\t\t\t\tuma = 1;\n\t\t\t\t\t\tsata[i][j] = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse{ sata[i][j] = 0; }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (uma == 1){\n\t\t\tushi++;\n\t\t}\n\t\tif (uma == 0){\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < a; i++){\n\t\t\tfor (int j = 0; j < b; j++){\n\t\t\t\tsore[i][j] = kore[i][j];\n\t\t\t}\n\t\t//cout<<\"po\"<<endl;\n\t\t}\n\t}\n\tcout << ushi << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <map>\n#define FLAG -1\nusing namespace std;\ntypedef pair<int,int> P;\nint main(){\n      int h,w,dh[] = {1,1,1,0,-1,-1,-1,0}, dw[] = {1,0,-1,-1,-1,0,1,1},ctn,i,j;\n      int solve = -2 ;\n      cin >> h >> w;\n      queue<P> que,tmp;\n      char d[h][w];\n      for(i=0;i<h;i++){\n            for(j=0;j<w;j++)\n            {\n                  cin >> d[i][j];\n                  if('1'<=d[i][j]&&'9'>=d[i][j])\n                        que.push(make_pair(i,j));\n            }\n      }\n\n      que.push(make_pair(FLAG,FLAG));\n      for(;;){\n            solve++;\n            map<P,bool> m;\n            for(;;){\n                  //cout << que.size()<<endl;\n                  P p = que.front();\n                  que.pop();\n                  if(p.first==FLAG)\n                  {//cout <<\" break \"<<endl<<endl;\n                  break;\n                  }\n                  if(d[p.first][p.second]=='.')continue;\n                  ctn = 0;\n                  for(i = 0;i < 8;i++){\n                        if(d[p.first+dh[i]][p.second+dw[i]]=='.')ctn++;\n                  }\n\n                  if(ctn >= d[p.first][p.second]-'0'){\n                        tmp.push(p);\n                        for(j=0;j<8;j++)\n                        if(m.count(make_pair(p.first+dh[j],p.second+dw[j]))==0){\n                        que.push(make_pair(p.first+dh[j],p.second+dw[j]));\n                        m[make_pair(p.first+dh[j],p.second+dw[j])]=true;\n                        }\n                  }\n            }\n            if(tmp.empty())break;\n            while(!tmp.empty())\n            {\n                  d[tmp.front().first][tmp.front().second]='.';\n                  tmp.pop();\n            }\n            /*for(i =0 ;i<h;i++)\n            {\n                  for(j=0;j<w;j++)cout << d[i][j];\n                  cout <<endl;\n            }\n            */\n\n            que.push(make_pair(FLAG,FLAG));\n\n      }\n      cout << solve << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <map>\n#define FLAG -1\nusing namespace std;\ntypedef pair<int,int> P;\nint main(){\n      int h,w,dh[] = {1,1,1,0,-1,-1,-1,0}, dw[] = {1,0,-1,-1,-1,0,1,1},ctn,i,j;\n      int solve = -2 ;\n      cin >> h >> w;\n      queue<P> que,tmp;\n      char d[h][w];\n      for(i=0;i<h;i++){\n            for(j=0;j<w;j++)\n            {\n                  cin >> d[i][j];\n                  if('1'<=d[i][j]&&'9'>=d[i][j])\n                        que.push(make_pair(i,j));\n            }\n      }\n\n      que.push(make_pair(FLAG,FLAG));\n      for(;;){\n            solve++;\n            map<P,bool> m;\n            for(;;){\n                  //cout << que.size()<<endl;\n                  P p = que.front();\n                  que.pop();\n                  if(p.first==FLAG)\n                  {//cout <<\" break \"<<endl<<endl;\n                  break;\n                  }\n                  ctn = 0;\n                  for(i = 0;i < 8;i++){\n                        if(d[p.first+dh[i]][p.second+dw[i]]=='.')ctn++;\n                  }\n\n                  if(ctn >= d[p.first][p.second]-'0'){\n                        tmp.push(p);\n                        for(j=0;j<8;j++)\n                        if(m.count(make_pair(p.first+dh[j],p.second+dw[j]))==0&&d[p.first+dh[j]][p.second+dw[j]]!='.'){\n                        que.push(make_pair(p.first+dh[j],p.second+dw[j]));\n                        m[make_pair(p.first+dh[j],p.second+dw[j])]=true;\n                        }\n                  }\n            }\n            if(tmp.empty())break;\n            while(!tmp.empty())\n            {\n                  d[tmp.front().first][tmp.front().second]='.';\n                  tmp.pop();\n            }\n            /*for(i =0 ;i<h;i++)\n            {\n                  for(j=0;j<w;j++)cout << d[i][j];\n                  cout <<endl;\n            }\n            */\n\n            que.push(make_pair(FLAG,FLAG));\n\n      }\n      cout << solve << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int dx[]={-1,0,1,-1,1,-1,0,1};\nconst int dy[]={-1,-1,-1,0,0,1,1,1};\nint H,W;\nchar fld[1001][1001];\nbool used[1000][1000];\nint f(int z){\n    int y=z/W,x=z%W;\n    int ret=0;\n    for(int d=0;d<8;d++){\n        int ty=y+dy[d],tx=x+dx[d];\n        if(ty<0||ty>=H||tx<0||tx>=W)continue;\n        if(fld[ty][tx]=='.')ret++;\n    }\n    return ret;\n}\n\nint main(){\n    scanf(\"%d%d\",&H,&W);\n    for(int i=0;i<H;i++)scanf(\"%s\",fld[i]);\n\n    vector<int>V[2];\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            if(fld[i][j]=='.')continue;\n            if(f(i*W+j)>=(fld[i][j]-'0')){\n                V[0].push_back(i*W+j);\n                used[i][j]=true;\n            }\n        }\n    }\n\n    for(int i=0;;i++){\n        if(V[i&1].size()==0){\n            printf(\"%d\\n\",i);\n            break;\n        }\n        for(int j=0;j<V[i&1].size();j++){\n            int y=V[i&1][j]/W,x=V[i&1][j]%W;\n            fld[y][x]='.';\n            for(int d=0;d<8;d++){\n                int ty=y+dy[d],tx=x+dx[d];\n                if(ty<0||ty>=H||tx<0||tx>=W)continue;\n                if(used[ty][tx]||fld[ty][tx]=='.')continue;\n                if(f(ty*W+tx)>=(fld[ty][tx]-'0')){\n                    used[ty][tx]=true;\n                    V[(i+1)&1].push_back(ty*W+tx);\n                }\n            }\n        }\n\n        V[i&1].clear();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n\n#include<iostream>\nusing namespace std;\n\nint f[1100][1100];\nint m[1100][1100];\nint count(int h,int w){\n\tint a[9]={0,1,1,0,-1,-1,1,-1,0},sum=0;\n\tfor(int i =0;i<8;i++){\n\t\tif(f[h+a[i]][w+a[i+1]]==-1)sum++;\n\t}\n\treturn sum;\n}\nvoid change(int h,int w){\n\tint a[9]={0,1,1,0,-1,-1,1,-1,0};\n\tfor(int i =0;i<8;i++){\n\t\tm[h+a[i]][w+a[i+1]]++;\n\t}\n}\n\nint main(){\n\tint h,w;\n\tcin>>h>>w;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tchar t;\n\t\t\tcin>>t;\n\t\t\tif(t=='.')f[i][j]=-1;\n\t\t\telse f[i][j]=t-'0';\n\t\t}\n\t}\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tm[i][j]=count(i,j);\n\t\t}\n\t}\n\tint c=0;\n\twhile(1){\n\t\tbool end=true;\n\t\tfor(int i=1;i<h-1;i++){\n\t\t\tfor(int j=1;j<w-1;j++){\n\t\t\t\tif(f[i][j]!=-1&&f[i][j]<=m[i][j]){\n\t\t\t\t\tf[i][j]=-10;\n\t\t\t\t\tend=false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<h-1;i++){\n\t\t\tfor(int j=1;j<w-1;j++){\n\t\t\t\tif(f[i][j]==-10){\n\t\t\t\t\tf[i][j]=-1;\n\t\t\t\t\tchange(i,j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(end)break;\n\t\tc++;\n\t}\n\tcout<<c<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX_H 1010\n#define MAX_W 1010\n \nstruct P{\n    int x,y;\n    P(int x,int y) : x(x), y(y) {}\n};\n \nbool inField(int x,int y,int H,int W){\n    return (0 <= x && x < W && 0 <= y && y < H);\n}\n \nint main(){\n    int H,W,arr[MAX_H][MAX_W];\n    char ch;\n    cin >> H >> W;\n    for(int i = 0 ; i < H ; i++){\n\tfor(int j = 0 ; j < W ; j++){\n\t    cin >> ch;\n\t    arr[i][j] = (ch == '.' ? -1 : ch-'0');\n\t}\n    }\n    int cnt[MAX_H][MAX_W];\n    memset(cnt,0,sizeof(cnt));\n    const int dx[8] = {-1,-1,-1,0,0,1,1,1};\n    const int dy[8] = {-1,0,1,-1,1,-1,0,1};\n    queue<P> Q;\n    for(int i = 0 ; i < H ; i++){\n\tfor(int j = 0 ; j < W ; j++){\n\t    if(arr[i][j] == -1){ continue; }\n\t    for(int k = 0 ; k < 8 ; k++){\n\t\tint nx = j + dx[k];\n\t\tint ny = i + dy[k];\n\t\tif(!inField(nx,ny,H,W)){ continue; }\n\t\tif(arr[ny][nx] == -1){\n\t\t    cnt[i][j]++;\n\t\t}\n\t    }\n\t    if(arr[i][j] <= cnt[i][j]){\n\t\tQ.push(P(j,i));\n\t    }\n\t}\n    }\n    int res = 0;\n    while(!Q.empty()){\n\tqueue<P> nQ;\n\twhile(!Q.empty()){\n\t    P p = Q.front(); Q.pop();\n\t    for(int i = 0 ; i < 8 ; i++){\n\t\tint nx = p.x + dx[i];\n\t\tint ny = p.y + dy[i];\n\t\tif(!inField(nx,ny,H,W)){ continue; }\n\t\tif(arr[ny][nx] == -1){ continue; }\n\t\tif(arr[ny][nx] <= cnt[ny][nx]){ continue; }\n\t\tcnt[ny][nx]++;\n\t\tif(arr[ny][nx] <= cnt[ny][nx]){\n\t\t    nQ.push(P(nx,ny));\n\t\t}\n\t    }\n\t}\n\tQ = nQ;\n\tres++;\n    }\n    cout << res << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<functional>\nusing namespace std;\nstruct P {\n\tint time, cost;\n};\nstruct Q {\n\tint x, y;\n};\nconst int inf = 1000000;\nint a[1000][1000];\nint g[1000][1000];\nP b[1000][1000];\nint main() {\n\tint h, w;\n\tcin >> h >> w;\n\tstring s;\n\tfor (int i = 0; i < h; i++) {\n\t\tcin >> s;\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tif (s[j] == '.') a[i][j] = 0;\n\t\t\telse a[i][j] = (int)s[j] - '0';\n\t\t\tg[i][j] = 0;\n\t\t\tb[i][j] = P{ 0,0 };\n\t\t}\n\t}\n\tfor (int i = 0; i < h; i++) {\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tif (a[i][j] == 0) {\n\t\t\t\tfor (int x = -1; x <= 1; x++) {\n\t\t\t\t\tfor (int y = -1; y <= 1; y++) {\n\t\t\t\t\t\tif (i + x < h&&i + x >= 0 && j + y < w&&j + y >= 0) {\n\t\t\t\t\t\t\tg[i + x][j + y]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tqueue<Q>p;\n\tint sum = 0;\n\tfor (int i = 0; i < h; i++) {\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tif (a[i][j] != 0 && a[i][j] <= g[i][j]) {\n\t\t\t\ta[i][j] = 0;\n\t\t\t\tb[i][j] = P{ 1,0 };\n\t\t\t\tsum = 1;\n\t\t\t\tfor (int x = -1; x <= 1; x++) {\n\t\t\t\t\tfor (int y = -1; y <= 1; y++) {\n\t\t\t\t\t\tif (i + x < h&&i + x >= 0 && j + y < w&&j + y >= 0) {\n\t\t\t\t\t\t\tp.push(Q{ i + x,j + y });\n\t\t\t\t\t\t\tb[i + x][j + y] = P{ 2,b[i + x][j + y].cost + 1 };\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\twhile (!p.empty()) {\n\t\tQ t = p.front(); p.pop();\n\t\tint i = t.x, j = t.y;\n\t\tif (a[i][j] <= g[i][j] + b[i][j].cost&&a[i][j] != 0) {\n\t\t\ta[i][j] = 0;\n\t\t\tsum = max(sum, b[i][j].time);\n\t\t\tfor (int x = -1; x <= 1; x++) {\n\t\t\t\tfor (int y = -1; y <= 1; y++) {\n\t\t\t\t\tif (i + x < h&&i + x >= 0 && j + y < w&&j + y >= 0&&a[i+x][j+y]!=0) {\n\t\t\t\t\t\tif (a[i + x][j + y] > g[i + x][j + y] + b[i + x][j + y].cost) {\n\t\t\t\t\t\t\tb[i + x][j + y] = P{ max(b[i + x][j + y].time,b[i][j].time + 1),b[i + x][j + y].cost + 1 };\n\t\t\t\t\t\t\tif (b[i + x][j + y].time >= 1736) {\n\t\t\t\t\t\t\t\tint o = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (a[i + x][j + y] != 0 && a[i + x][j + y] <= g[i + x][j + y] + b[i + x][j + y].cost) {\n\t\t\t\t\t\t\tp.push(Q{ i + x,j + y });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << sum << endl;\n\tcin >> sum;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstdio>\nusing namespace std;\n\nint x, y;\nchar map[1024][1024];\nqueue<pair<int,int>> q;\n\nbool check_map(void){\n\tbool flg = true;\n\tint dx[8] = { 0, 0, 1, -1, 1, -1, 1, -1 }, dy[8] = { 1, -1, 0, 0, 1, -1, -1, 1 };\n\tfor(int i = 0; i < y; i++){\n\t\tfor(int i2 = 0; i2 < x; i2++){\n\t\t\tint cnt = 0;\n\t\t\tif( map[i][i2] != '.' ){\n\t\t\t\tfor(int i3 = 0; i3 < 8; i3++){\n\t\t\t\t\tif(map[ i + dy[i3] ][ i2 + dx[i3] ] == '.'){\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tchar temp = map[i][i2];\n\t\t\t\tif(cnt >= atoi(&temp)){\n\t\t\t\t\tq.push(make_pair(i, i2));\n\t\t\t\t\tflg = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn flg;\n}\n\nint main(){\n\tint cnt = 0;\n\tcin >> y >> x;\n\n\tfor(int i = 0; i < y; i++){\n\t\tfor(int i2 = 0; i2 < x; i2++){\n\t\t\tcin >> map[i][i2];\n\t\t}\n\t}\n\n\twhile(!check_map()){\n\t\twhile(!q.empty()){\n\t\t\tpair<int, int> temp = q.front();\n\t\t\tq.pop();\n\t\t\tmap[temp.first][temp.second] = '.';\n\t\t}\n\t\tcnt++;\n\t}\n\n\tcout << cnt << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll,ll> mp;\n#define inf 1e9\nint dx[] = {1,1,1,-1,-1,-1,0,0,0};\nint dy[] = {0,1,-1,0,1,-1,0,1,-1};\n\nint main(){\n\tint h,w;\n\tcin>>h>>w;\n\tvector<vector<int> > map(h+2,vector<int>(w+2,0) );\n\tvector<vector<int> > cnt(h+2,vector<int>(h+2,0) );\n\tqueue<mp> q;\n\tfor(int i=1;i<=h;i++)\n\t    for(int j=1;j<=w;j++){\n\t\tchar tmp ;\n\t\tcin>>tmp;\n\t\tif(tmp=='.'){\n\t\t\tq.push( mp(i,j) );\t\n\t\t}else{\n\t\t\tmap[i][j] = tmp-'0';\n\t\t}\n\t    }\n\n\tint res = 0;\n\tif(q.empty()){\n\t\tcout<<res<<endl;\n\t\treturn 0;\n\t}\n\twhile(!q.empty() ){\n\t\tqueue<mp> tt;\n\t\twhile(!q.empty() ){\n\t\t\tmp now = q.front();\n\t\t\tq.pop();\n\t\t\tint x = now.first;\n\t\t\tint y = now.second;\n\t\t\tfor(int i=0;i<9;i++){\n\t\t\t\tint nx = x + dx[i];\n\t\t\t\tint ny = y + dy[i];\n\t\t\t\tcnt[nx][ny]++;\n\t\t\t\tif(cnt[nx][ny] == map[nx][ny]){\n\t\t\t\t\ttt.push( mp(nx,ny) );\n\t\t\t\t}\n\t\n\t\t\t}\n\t\t}\n\t\tres++;\n\t\tq = tt;\n\t}\n\tcout<<res-1<<endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n\nstring S[2000];\nint x[2000][2000];\n\nint main() {\n\tint n, m;\n\tchar T[10] = { '.','1','2','3','4','5','6','7','8','9' };\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> S[i];\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tfor (int k = 0; k < 10; k++) {\n\t\t\t\tif (S[i][j] == T[k]) {\n\t\t\t\t\tx[i][j] = k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint t = 1;\n\tint p = 0;\n\tint sum=0;\n\twhile (t != 0) {\n\t\tt = 0;\n\t\tsum++;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tif (x[i][j] >= 1) {\n\t\t\t\t\tp = 0;\n\t\t\t\t\tfor (int k = -1; k <= 1; k++) {\n\t\t\t\t\t\tfor (int l = -1; l <= 1; l++) {\n\t\t\t\t\t\t\tif (x[i + k][j + l] == 0) {\n\t\t\t\t\t\t\t\tp++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (p >= x[i][j]) {\n\t\t\t\t\t\tx[i][j] = 0;\n\t\t\t\t\t\tt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << sum << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint grd[1010][1010];\nint mx[]={1,1,1,0,0,0,-1,-1,-1},my[]={1,0,-1,1,0,-1,1,0,-1};\nint main(){\n\tint h,w;\tcin>>h>>w;\n\tqueue<pair<int,int>> ls;\n\tfor(int i=0;i<h;i++){\n\t\tstring s;\tcin>>s;\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(s[j]=='.')\tgrd[i][j]=-1;\n\t\t\telse{\n\t\t\t\tgrd[i][j]=s[j]-'0';\n\t\t\t\tls.push(make_pair(i,j));\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\twhile(true){\n\t\t//cout<<ans<<endl;\n\t\t//for(int i=0;i<h;i++){\n\t\t//\tfor(int j=0;j<w;j++)\tcout<<grd[i][j]<<\" \";\n\t\t//\tcout<<endl;\n\t\t//}\n\t\t//cout<<endl;\n\t\tqueue<pair<int,int>> next;\n\t\tqueue<pair<int,int>> broken;\n\t\twhile(!ls.empty()){\n\t\t\tauto now=ls.front();\tls.pop();\n\t\t\tint y=now.first,x=now.second;\n\t\t\tif(grd[y][x]==-1)\tcontinue;\n\t\t\tint cnt=0;\n\t\t\tfor(int i=0;i<9;i++)\tif(grd[y+my[i]][x+mx[i]]==-1)\tcnt++;\n\t\t\tif(cnt>=grd[y][x])\tbroken.push(make_pair(y,x));\n\t\t}\n\t\tif(broken.empty()){\n\t\t\tcout<<ans<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\twhile(!broken.empty()){\n\t\t\tauto now=broken.front();\tbroken.pop();\n\t\t\tint y=now.first,x=now.second;\n\t\t\tgrd[y][x]=-1;\n\t\t\tfor(int i=0;i<9;i++){\n\t\t\t\tint xx=x+mx[i],yy=y+my[i];\n\t\t\t\tnext.push(make_pair(yy,xx));\n\t\t\t}\n\t\t}\n\t\twhile(!next.empty()){\n\t\t\tls.push(next.front());\tnext.pop();\n\t\t}\n\t\tans++;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <queue>\nusing namespace std;\ntypedef pair<int, int> P;\n\nint h, w, ans;\nint castle[1001][1001], times[1001][1001];\nint dx[] = {-1, 0, 1, -1, 1, -1, 0, 1}, dy[] = {-1, -1, -1, 0, 0, 1, 1, 1};\nchar beach[1001][1001];\n\nint main(){\n    scanf(\"%d%d\", &h, &w);\n    for(int i = 0; i < h; i++){\n        scanf(\"%s\", &beach[i]);\n    }\n\n    queue<P> Q;\n    for(int i = 0; i < h; i++){\n        for(int j = 0; j < w; j++){\n            if(beach[i][j] == '.'){\n                Q.push(P(i, j));\n            } else{\n                castle[i][j] = (int)beach[i][j] - 48;\n            }\n        }\n    }\n\n    while(Q.size()){\n        P p = Q.front();\n        Q.pop();\n        ans = max(ans, times[p.first][p.second]);\n\n        for(int i = 0; i < 8; i++){\n            int y = p.first + dy[i], x = p.second + dx[i];\n            if(y < 0 || y >= h || x < 0 || x >= w){\n                continue;\n            }\n\n            castle[y][x]--;\n            if(castle[y][x] == 0){\n                Q.push(P(y, x));\n                times[y][x] = times[p.first][p.second] + 1;\n            }\n        }\n    }\n\n    printf(\"%d\\n\", ans);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// JOI14-quest5.cpp :   \n//\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <queue>\n\nint height, width;\nint beach[1000][1000] = { 0 };\n\nusing namespace std;\nqueue<int> que_i, que_j;\n\nint power(int i, int j) {\n\tint count = 0;\n\n\tif (beach[i - 1][j] == 0) {\n\t\tcount++;\n\t}\n\tif (beach[i][j + 1] == 0) {\n\t\tcount++;\n\t}\n\tif (beach[i + 1][j] == 0) {\n\t\tcount++;\n\t}\n\tif (beach[i][j - 1] == 0) {\n\t\tcount++;\n\t}\n\n\tif (beach[i - 1][j + 1] == 0) {\n\t\tcount++;\n\t}\n\tif (beach[i + 1][j + 1] == 0) {\n\t\tcount++;\n\t}\n\tif (beach[i + 1][j - 1] == 0) {\n\t\tcount++;\n\t}\n\tif (beach[i - 1][j - 1] == 0) {\n\t\tcount++;\n\t}\n\n\treturn count;\n}\n\nvoid around(int i, int j) {\n\tif (beach[i - 1][j] != 0) {\n\t\tif (beach[i - 1][j] <= power(i - 1, j)) {\n\t\t\tque_i.push(i - 1);\n\t\t\tque_j.push(j);\n\t\t}\n\t}\n\tif (beach[i][j + 1] != 0) {\n\t\tif (beach[i][j + 1] <= power(i, j + 1)) {\n\t\t\tque_i.push(i);\n\t\t\tque_j.push(j + 1);\n\t\t}\n\t}\n\tif (beach[i + 1][j] != 0) {\n\t\tif (beach[i + 1][j] <= power(i + 1, j)) {\n\t\t\tque_i.push(i + 1);\n\t\t\tque_j.push(j);\n\t\t}\n\t}\n\tif (beach[i][j - 1] != 0) {\n\t\tif (beach[i][j - 1] <= power(i, j - 1)) {\n\t\t\tque_i.push(i);\n\t\t\tque_j.push(j - 1);\n\t\t}\n\t}\n\n\tif (beach[i - 1][j + 1] != 0) {\n\t\tif (beach[i - 1][j + 1] <= power(i - 1, j + 1)) {\n\t\t\tque_i.push(i - 1);\n\t\t\tque_j.push(j + 1);\n\t\t}\n\t}\n\tif (beach[i + 1][j + 1] != 0) {\n\t\tif (beach[i + 1][j + 1] <= power(i + 1, j + 1)) {\n\t\t\tque_i.push(i + 1);\n\t\t\tque_j.push(j + 1);\n\t\t}\n\t}\n\tif (beach[i + 1][j - 1] != 0) {\n\t\tif (beach[i + 1][j - 1] <= power(i + 1, j - 1)) {\n\t\t\tque_i.push(i + 1);\n\t\t\tque_j.push(j - 1);\n\t\t}\n\t}\n\tif (beach[i - 1][j - 1] != 0) {\n\t\tif (beach[i - 1][j - 1] <= power(i - 1, j - 1)) {\n\t\t\tque_i.push(i - 1);\n\t\t\tque_j.push(j - 1);\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\t\n\n\tscanf(\"%d %d\", &height, &width);\n\n\tchar c;\n\tfor (int i = 0; i < height; i++) {\n\t\tfor (int j = 0; j < width; j++) {\n\t\t\tc = getchar();\n\t\t\tif (c == '\\n') {\n\t\t\t\tj--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (c == '.') {\n\t\t\t\tbeach[i][j] = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbeach[i][j] = c - 48;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < height; i++) {\n\t\tfor (int j = 0; j < width; j++) {\n\t\t\tif (beach[i][j] != 0) {\n\t\t\t\tif (beach[i][j] <= power(i, j)) {\n\t\t\t\t\tque_i.push(i);\n\t\t\t\t\tque_j.push(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint wave = 0, x[1000], y[1000], count, save, size;\n\twhile (que_i.empty() == false) {\n\t\twave++;\n\t\tcount = 0;\n\t\tsize = que_i.size();\n\t\tfor (int i = 0; i < size; i++) {\n\t\t\tif (beach[que_i.front()][que_j.front()] != 0) {\n\t\t\t\t\n\t\t\t\tbeach[que_i.front()][que_j.front()] = 0;\n\t\t\t\ty[count] = que_i.front();\n\t\t\t\tx[count] = que_j.front();\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tque_i.pop();\n\t\t\tque_j.pop();\n\t\t}\n\n\t\tfor (int i = 0; i < count; i++) {\n\t\t\taround(y[i], x[i]);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", wave);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n\ntypedef pair<int,int> pi;\n\nconst int INF=123456789;\n\nint h,w;\nstring f[1000];\n\nint dx[8]={0,1,1,1,0,-1,-1,-1}, dy[8]={1,1,0,-1,-1,-1,0,1};\nint dp[1000][1000];\n\ninline bool in(int y, int x)\n{\n    return (0<=y&&y<h && 0<=x&&x<w);\n}\n\nint main()\n{\n    cin >>h >>w;\n    rep(i,h) cin >>f[i];\n\n    fill(dp[0],dp[1000],INF);\n    rep(i,h)rep(j,w) if(f[i][j]=='.') dp[i][j]=0;\n\n    queue<pi> que;\n\n    rep(i,h)rep(j,w)\n    {\n        if(dp[i][j]==0)\n        {\n            rep(k,8)\n            {\n                int nx=j+dx[k], ny=i+dy[k];\n                if(in(ny,nx) && f[ny][nx]!='.')\n                {\n                    int ct=0;\n                    int lim=f[ny][nx]-'0';\n                    rep(l,8)\n                    {\n                        int nnx=nx+dx[l], nny=ny+dy[l];\n                        if(f[nny][nnx]=='.') ++ct;\n                    }\n\n                    if(ct>=lim)\n                    {\n                        dp[ny][nx]=1;\n                        que.push(pi(ny,nx));\n                    }\n                }\n            }\n        }\n    }\n\n    while(!que.empty())\n    {\n        pi now=que.front();\n        que.pop();\n        rep(i,8)\n        {\n            int nx=now.se+dx[i], ny=now.fi+dy[i];\n\n            if(f[ny][nx]=='.') continue;\n            if(f[ny][nx]=='9') continue;\n\n            vector<int> a;\n            rep(j,8)\n            {\n                int nnx=nx+dx[j], nny=ny+dy[j];\n                a.pb(dp[nny][nnx]);\n            }\n            sort(all(a));\n\n            int p=f[ny][nx]-'0';\n\n            if(dp[ny][nx]>a[p-1]+1)\n            {\n                dp[ny][nx]=a[p-1]+1;\n                que.push(pi(ny,nx));\n            }\n        }\n    }\n\n    int ans=0;\n    rep(i,h)rep(j,w) if(dp[i][j]!=INF) ans=max(ans,dp[i][j]);\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define ALL(a) (a).begin(),(a).end()\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ndouble EPS=1e-8;\nint INF = 2e9;\nchar fld[1050][1050];\nint cnt[1050][1050];\nbool used[1050][1050];\nint main(){\n\tint h,w,turn=0;\n\tcin>>h>>w;\n\tREP(i,h)REP(j,w)cin>>fld[j][i];\n\tmemset(used,false,sizeof(used));\n\tqueue<P> Q;\n\tREP(i,h)REP(j,w){\n\t\tif(fld[j][i]=='.')continue;\n\t\tfor(int x=-1;x<=1;x++)for(int y=-1;y<=1;y++)if(fld[j+x][i+y]=='.')cnt[j][i]++;\n\t\tif(cnt[j][i]>=(fld[j][i]-'0')){\n\t\t\tQ.push(P(j,i));\n\t\t\tused[j][i]=true;\n\t\t}\n\t}\n\tif(Q.size())turn++;\n\telse{\n\t\tcout<<0<<endl;\n\t\treturn 0;\n\t}\n\tbool update=true;\n\twhile(update){\n\t\tint ql=Q.size();\n\t\tREP(i,ql){\n\t\t\tP p=Q.front();Q.pop();\n\t\t\tfor(int x=-1;x<=1;x++){\n\t\t\t\tfor(int y=-1;y<=1;y++){\n\t\t\t\t\tif(fld[p.first+x][p.second+y]!='.'){\n\t\t\t\t\t\tcnt[p.first+x][p.second+y]++;\n\t\t\t\t\t\tif(cnt[p.first+x][p.second+y]>=(fld[p.first+x][p.second+y]-'0')&&!used[p.first+x][p.second+y]){\n\t\t\t\t\t\t\tQ.push(P(p.first+x,p.second+y));\n\t\t\t\t\t\t\tused[p.first+x][p.second+y]=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!Q.size()){\n\t\t\tcout<<turn<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tturn++;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <queue>\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> P;\n\n#define fst first\n#define scd second\n#define rep(i,x) for(int i=0;i<(x);++i)\n\nint dx[8] = {-1, 0, 1, -1, 1, -1, 0, 1}, dy[8] = {-1, -1, -1, 0, 0, 1, 1, 1};\n\nint st[1000][1002];\n\nint main()\n{\n\tint H, W; scanf(\"%d %d\", &H, &W);\n\n\tqueue<P> q;\n\n\trep(i, H) rep(j, W) {\n\t\tchar c; scanf(\"\\n%c\", &c);\n\t\tif (c == '.') {\n\t\t\tst[i][j] = -1;\n\t\t\tq.push(P(0, pii(i, j)));\n\t\t} else {\n\t\t\tst[i][j] = c - '0';\n\t\t}\n\t}\n\n\tint ans;\n\n\twhile (q.size()) {\n\t\tP p = q.front(); q.pop();\n\t\tans = p.fst;\n\t\trep(i, 8) {\n\t\t\tint ny = p.scd.fst + dy[i], nx = p.scd.scd + dx[i];\n\t\t\tif (ny < 0 || ny >= H || nx < 0 || nx >= W) continue;\n\t\t\tif (--st[ny][nx] == 0) {\n\t\t\t\tq.push(P(p.fst + 1, pii(ny, nx)));\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {+0,+1,+1,+1,+0,-1,-1,-1};\nstatic const int ty[] = {-1,-1,+0,+1,+1,+1,+0,-1};\n\nint main(){\n  int H,W;\n  while(~scanf(\"%d %d\",&H,&W)){\n    char stage[101][101];\n    char buffer[101][101];\n    for(int y = 0; y < H; y++){\n      char line[101];\n      scanf(\"%s\",line);\n      for(int x = 0; x < W; x++){\n        stage[y][x] = line[x];\n        buffer[y][x] = line[x];\n      }\n    }\n    \n\n    int res = 0;\n    for(int round = 0; round < 10010; round++){\n      bool is_over = true;\n      for(int y = 0; y < H; y++){\n        for(int x = 0; x < W; x++){\n          if(stage[y][x] == '.') continue;\n          int strongness = stage[y][x] - '0';\n\n          int count = 0;\n          for(int i = 0; i < 8; i++){\n            int dx = x + tx[i];\n            int dy = y + ty[i];\n            if(dx < 0 || dx >= W || dy < 0 || dy >= H) continue;\n            if(stage[dy][dx] == '.'){\n              count++;\n            }\n          }\n\n          if(count >= strongness){\n            is_over = false;\n            buffer[y][x] = '.';\n          }\n        }\n      }\n      if(is_over){\n        res = round;\n        break;\n      }\n      memcpy(stage,buffer,sizeof(char)*101*101);\n    }\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <string>\nusing namespace std;\n#define F first\n#define S second\nconst int INF = 1 << 31, MAX_HW = 1000;\ntypedef pair<int, int> P;\n\nint check(int x, int y);\nint h, w, ans;\nint land[MAX_HW + 2][MAX_HW + 2];\nqueue<P> que;\n\nint main(){\n\n  cin >> h >> w;\n  for(int i = 1; i <= h; i++){\n    for(int j = 1; j <= w; j++){\n      char in;\n      cin >> in;\n      land[i][j] = in - 48; // . = -2 \n    }\n  }\n  for(int i = 1; i <= h; i++){\n    for(int j = 1; j <= w; j++){\n      if(land[i][j] != -2 && land[i][j] <= check(i, j)){\n\tque.push(P(i, j));\n      }\n    }\n  }\n  for(;;){\n    queue<P> que2;\n    bool reach[MAX_HW + 2][MAX_HW + 2] = {};\n    while(!que.empty()){   \n      P p =que.front();\n      que.pop();\n      land[p.F][p.S] = -2;\n      que2.push(p);\n    }\n    while(!que2.empty()){\n      P p = que2.front();\n      que2.pop();\n      for(int i = -1; i <= 1; i++){\n\tfor(int j = -1; j <= 1; j++){\n\t  if(land[p.F+i][p.S+j] != -2 && !reach[p.F+i][p.S+j] && land[p.F+i][p.S+j] <= check(p.F+i, p.S+j)){\n\t    que.push(P(p.F + i,p.S + j));\n\t  }\n\t  reach[p.F + i][p.S + j] = 1;\n\t}\n      }\n    }\n    ans++;\n    if(que.empty()){\n      break;\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n\n\nint check(int y, int x){\n  int re = 0;\n  for(int i = -1; i <= 1; i++){\n    for(int j = -1; j <= 1; j++){\n      if(land[y+i][x+j]==-2){\n\tre++;\n      }\n    }\n  }\n  return re;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\n#define REP(i, n) for(int i = 0; i < (int)(n); i++)\n#define FOR(i,n,m) for (int i=n; i<(int)(m); i++)\n#define INF 1000000007\n#define mp make_pair\n\ntypedef long long ll;\ntypedef long double ld;\nll dy[4]={-1,1,0,0};\nll dx[4]={0,0,1,-1};\n\n/*---------- template ----------*/\nint H,W;\nchar field[1010][1010];\nint around_zero_num[1010][1010];\n\nint main(){\n    cin >> H >> W;\n    REP(i,H){\n        cin >> field[i];\n    }\n    queue<pair<int,int> > que;\n    REP(i,H){\n        REP(j,W){\n            FOR(k,i-1,i+2){\n                FOR(l,j-1,j+2){\n                    if(i==k&&j==l) continue;\n                    if(k<0||l<0||H<=k||W<=l) around_zero_num[i][j]++;\n                    else if(field[k][l]=='.') around_zero_num[i][j]++;\n                }\n            }\n        }\n    }\n    \n    //???????????\n    REP(i,H){\n        REP(j,W){\n            if(field[i][j]!='.'&&int(field[i][j]-'0')<=around_zero_num[i][j]){\n                que.push(mp(i,j));\n            }\n        }\n    }\n    \n    int ans=0;\n    while(que.size()!=0){\n//        cout << endl;\n//        REP(i,H) cout << field[i] << endl;\n//        \n//        cout << endl;\n//        REP(i,H){REP(j,W){\n//            cout << around_zero_num[i][j];\n//        }cout<<endl;}\n        \n        //???????????\n        vector<pair<int,int> > broke;\n        while(que.size()!=0){\n            auto x = que.front();\n            que.pop();\n            if(field[x.first][x.second]!='.'&&int(field[x.first][x.second]-'0')<=around_zero_num[x.first][x.second]){\n                broke.push_back(x);\n            }\n        }\n        set<pair<int,int> > se;\n        if(broke.size()!=0) ans++;\n        //????????????????????\n        for(auto x: broke){\n            field[x.first][x.second]='.';\n            FOR(i,x.first-1,x.first+2){\n                FOR(j,x.second-1,x.second+2){\n                    if(i==x.first&&j==x.second) continue;\n                    if(i<0||j<0||H<=i||W<=j) continue;\n                    if(field[i][j]=='.') continue;\n                    se.insert(mp(i,j));//??????????????????????\n                    around_zero_num[i][j]++;\n                }\n            }\n        }\n        for(auto x: se) que.push(x);\n    }\n//    cout << endl;\n//    REP(i,H) cout << field[i] << endl;\n    \n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <stdlib.h>\n#include <stdio.h>\n#include <bitset>\n#include <cstring>\n#include <deque>\nusing namespace std;\n#define FOR(I,A,B) for(int I = (A); I < (B); ++I)\n#define CLR(mat) memset(mat, 0, sizeof(mat))\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<P, int> PP;\nint H, W;\nint cas[1000][1000];\nvector<string> vs;\nqueue<PP> que; // PP(P(y, x),???i??????)??????????\\???\nint vy[8] = {-1, -1, 0, 1, 1, 1, 0, -1};\nint vx[8] = {0, 1, 1, 1, 0, -1, -1, -1};\nint main()\n{\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> H >> W;\n  FOR(i,0,H) {\n    string s; cin >> s;\n    vs.push_back(s);\n  }\n  FOR(i,0,H) {\n    FOR(j,0,W) {\n      if(isdigit(vs[i][j])) {\n        cas[i][j] = 1e9;\n        que.push(PP(P(i, j), 1));\n      }\n    }\n  }\n  int ans = 0;\n  while(!que.empty()) {\n    PP p = que.front(); que.pop();\n    int y = p.first.first;\n    int x = p.first.second;\n    int t = p.second;\n    if(cas[y][x] <= t) continue; // ??????????????????????\n    int cnt = 0;\n    FOR(i,0,8) if(cas[y+vy[i]][x+vx[i]] < t) cnt++;\n    // ????????\n    if(cnt >= vs[y][x] - '0') {\n      cas[y][x] = t;\n      ans = max(ans, t);\n      FOR(i,0,8) {\n        if(cas[y+vy[i]][x+vx[i]] > t) {\n          que.push(PP(P(y+vy[i], x+vx[i]), t + 1));\n        }\n      }\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<28;\nconst ll INF=1ll<<50;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst int mod=1e9+7;\nconst vi emp;\nconst int dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\nconst int DX[8]={-1,-1,-1,0,0,1,1,1},DY[8]={1,0,-1,1,-1,1,0,-1};\n\nint h,w;\nvvi a;\n\nbool func(){\n\tvvi b=a;\n\tbool flag=0;\n\tfor(int i=0;i<h;i++) for(int j=0;j<w;j++) if(b[i][j]){\n\t\tint num=0;\n\t\tfor(int k=0;k<8;k++){\n\t\t\tint cx=i+DX[k],cy=j+DY[k];\n\t\t\tif(cx>=0&&cx<h&&cy>=0&&cy<w&&!b[cx][cy]) num++;\n\t\t}\n\t\tif(a[i][j]<=num){\n\t\t\tflag=1;\n\t\t\ta[i][j]=0;\n\t\t}\n\t}\n\treturn flag;\n}\n\nint main(){\n\tcin>>h>>w;\n\ta=vvi(h,vi(w));\n\tfor(int i=0;i<h;i++) for(int j=0;j<w;j++){\n\t\tchar t;\n\t\tcin>>t;\n\t\tif(t!='.') a[i][j]=t-'0';\n\t}\n\tint ans=0;\n\twhile(func()) ans++;\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<stdio.h>\n#include<stack>\nint mp[1002][1002] = { 0 }, mj[1002][1002] = { 0 }, mh[1002][1002] = { 0 };\nint main()\n{\n\tint x[8] = { -1,0,1,1,1,0,-1,-1 },m;\n\tint y[8] = { 1,1,1,0,-1,-1,-1,0 };\n\tint i,j,h, w,c=0,g,n=0;\n\tchar a;\n\tcin >> h >> w;\n\tfor (i = 0; i < h; i++)\n\t{\n\t\tfor (j = 0; j < w; j++)\n\t\t{\n\t\t\tcin >> a;\n\t\t\tif (a == '1')\n\t\t\t\tmp[i][j] =1;\n\t\t\tif (a == '2')\n\t\t\t\tmp[i][j] = 2;\n\t\t\tif (a == '3')\n\t\t\t\tmp[i][j] = 3;\n\t\t\tif (a == '4')\n\t\t\t\tmp[i][j] = 4;\n\t\t\tif (a == '5')\n\t\t\t\tmp[i][j] = 5;\n\t\t\tif (a == '6')\n\t\t\t\tmp[i][j] = 6;\n\t\t\tif (a == '7')\n\t\t\t\tmp[i][j] = 7;\n\t\t\tif (a == '8')\n\t\t\t\tmp[i][j] = 8;\n\t\t\tif (a == '9')\n\t\t\t\tmp[i][j] = 9;\n\t\t}\n\t}\n\tg = 0;\n\twhile(1)\n\t{\n\t\t\n\t\tfor (i = 1; i < h; i++)\n\t\t{\n\t\t\tfor (j = 1; j < w; j++)\n\t\t\t{\n\t\t\t\tmj[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor (i = 1; i < h; i++)\n\t\t{\n\t\t\tfor (j = 1; j < w; j++)\n\t\t\t{\n\t\t\t\tif (mp[i][j] >= 1&&mp[i][j]!=9)\n\t\t\t\t{\n\t\t\t\t\tfor (m = 0; m < 8; m++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (mp[i + y[m]][j + x[m]] == 0)\n\t\t\t\t\t\t\tc++;\n\t\t\t\t\t\tif (mp[i][j] <= c)\n\t\t\t\t\t\t\tmj[i][j] = 1;\n\t\t\t\t\t}\n\t\t\t\t\tc = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (i = 1; i < h; i++)\n\t\t{\n\t\t\tfor (j = 1; j < w; j++)\n\t\t\t{\n\t\t\t\tif (mj[i][j] == 1)\n\t\t\t\t\tmp[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tbool flg = true;\n\t\tfor (i = 0; i < h; i++)\n\t\t{\n\t\t\tfor (j = 0; j < w; j++)\n\t\t\t{\n\t\t\t\tif (mj[i][j] == 0)\n\t\t\t\t\tn++;\n\t\t\t\tif (mj[i][j] != 0) {\n\t\t\t\t\tflg = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (n == h*w || flg)\n\t\t\tbreak;\n\t\tg++;\n\t}\n\tcout<< g << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<queue>\n#include<fstream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint sand[1005][1005];\nbool used[1005][1005];\nconst int MAX=1007;\nqueue<int> q1,q2;\n\nint main(){\n\tstring sa;\n\tint i,j,k,l;\n\tint n,m;\n\tint a,b,c,d;\n\tcin>>n>>m;\n\tfor(i=0;i<n;i++){\n\t\tcin>>sa;\n\t\tfor(j=0;j<m;j++){\n\t\t\tif(sa[j]=='.'){\n\t\t\t\tfor(k=-1;k<=1;k++){\n\t\t\t\t\tfor(l=-1;l<=1;l++){\n\t\t\t\t\t\tif(i+k>0 && i+k<n-1 && j+l>0 && j+l<m-1){\n\t\t\t\t\t\t\tif(used[i+k][j+l])continue;\n\t\t\t\t\t\t\tused[i+k][j+l]=true;\n\t\t\t\t\t\t\tq1.push((i+k)*MAX+(j+l));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(char ca='1',k=1;k<10;k++,ca++){\n\t\t\t\tif(sa[j]==ca){\n\t\t\t\t\tsand[i][j]=k;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tmemset(used,false,sizeof(used));\n\tfor(i=0;;i++){\n\t\ta=q1.size();\n\t\tcout<<a<<endl;\n\t\tfor(j=0;j<a;j++){\n\t\t\tc=q1.front(),q1.pop();\n\t\t\tb=c/MAX,c%=MAX;\n\t\t\tif(sand[b][c]==0)continue;\n\t\t\tif(used[b][c])continue;\n\t\t\td=0;\n\t\t\tfor(k=-1;k<=1;k++){\n\t\t\t\tfor(l=-1;l<=1;l++){\n\t\t\t\t\tif(sand[b+k][c+l]==0)d++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(d<sand[b][c])continue;\n\t\t\tused[b][c]=true;\n\t\t\tq2.push(b*MAX+c);\n\t\t\tfor(k=-1;k<=1;k++){\n\t\t\t\tfor(l=-1;l<=1;l++){\n\t\t\t\t\tif(sand[b+k][c+l]==0)continue;\n\t\t\t\t\tq1.push((b+k)*MAX+(c+l));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(q2.empty())break;\n\t\twhile(!q2.empty()){\n\t\t\tc=q2.front(),q2.pop();\n\t\t\tb=c/MAX,c%=MAX;\n\t\t\tsand[b][c]=0;\n\t\t}\n\t}\n\tcout<<i<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<queue>\n#define MP make_pair\nusing namespace std;\nlong long int sc[1001][1001],ssc[1001][1001];\nchar c[1001];\nint main()\n{\n\tint h, w, cnt = 0, ans = 0, n;\n\tint x, y;\n\tpair<int, int> p;\n\tqueue< pair<int, int> > que;\n\tqueue< pair<int, int> >que1;\n\tscanf(\"%d%d\", &h, &w);\n\tfor (int i = 0; i < h; i++)\n\t{\n\t\tscanf(\"%s\", c);\n\t\tfor (int j = 0; j < w; j++)\n\t\t{\n\n\t\t\tif (c[j] == '.')\n\t\t\t\tsc[i][j] = -1;\n\t\t\telse\n\t\t\t\tsc[i][j] = c[j] - 48;\n\t\t}\n\t}\n\tfor (int i = 0; i < h; i++)\n\t{\n\t\tfor (int j = 0; j < w; j++)\n\t\t{\n\t\t\tif (i != 0)\n\t\t\t{\n\t\t\t\tfor (int a = -1; a < 2; a++)\n\t\t\t\t{\n\t\t\t\t\tif (sc[i - 1][j + a] == -1)\n\t\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i != h - 1)\n\t\t\t{\n\t\t\t\tfor (int a = -1; a < 2; a++)\n\t\t\t\t{\n\t\t\t\t\tif (sc[i + 1][j + a] == -1)\n\t\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (sc[i][j - 1] == -1 && j != 0)\n\t\t\t\tcnt++;\n\t\t\tif (sc[i][j + 1] == -1 && j != w - 1)\n\t\t\t\tcnt++;\n\t\t\tssc[i][j] = cnt;\n\t\t\tcnt = 0;\n\t\t}\n\t}\n\t/*\tfor (int i = 0; i < h; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t{\n\n\t\t\t\tprintf(\"%2lld\", ssc[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\tfor (int i = 0; i < h; i++)\n\t{\n\n\t\tfor (int j = 0; j < w; j++)\n\t\t{\n\t\t\tif (sc[i][j] != -1)\n\t\t\t{\n\t\t\t\tif (sc[i][j] <= ssc[i][j])\n\t\t\t\t\tque.push(MP(i, j));\n\t\t\t\telse if (sc[i][j] != 9)\n\t\t\t\t\tque1.push(MP(i, j));\n\t\t\t}\n\t\t}\n\t}\n\twhile (!que.empty())\n\t{\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tx = que.front().first;\n\t\t\ty = que.front().second;\n\t\t\tque.pop();\n\t\t\tfor (int a = -1; a < 2; a++)\n\t\t\t{\n\t\t\t\tssc[x - 1][y + a]++;\n\t\t\t\tssc[x + 1][y + a]++;\n\t\t\t}\n\t\t\tssc[x][y - 1]++;\n\t\t\tssc[x][y + 1]++;\n\t\t}\n\t\tn = que1.size();\n\t\tfor (int i=0;i<n;i++)\n\t\t{\n\t\t\tx = que1.front().first;\n\t\t\ty = que1.front().second;\n\t\t\tque1.pop();\n\t\t\tif (sc[x][y] <= ssc[x][y])\n\t\t\t\tque.push(MP(x, y));\n\t\t\telse if (sc[x][y] != 9)\n\t\t\t\tque1.push(MP(x, y));\n\t\t}\n\t\tans++;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair< int, int > Pi;\ntypedef pair< int, Pi > Pii;\nconst static int dy[] = {-1, -1, 0, 1, 1, 1, 0, -1};\nconst static int dx[] = {0, 1, 1, 1, 0, -1, -1, -1};\n\nint main()\n{\n  int H, W;\n  char S[1000][1001];\n\n  cin >> H >> W;\n  for(int i = 0; i < H; i++) {\n    cin >> S[i];\n  }\n\n  queue< Pii > Que;\n  int ret = 0;\n\n  for(int i = 0; i < H; i++) {\n    for(int j = 0; j < W; j++) {\n      if(S[i][j] == '.') Que.push(Pii(0, Pi(j, i)));\n      else S[i][j] -= '0';\n    }\n  }\n  while(!Que.empty()) {\n    Pii& p = Que.front();\n    ret = max(ret, p.first);\n    for(int i = 0; i < 8; i++) {\n      int ny = p.second.second + dy[i];\n      int nx = p.second.first  + dx[i];\n      --S[ny][nx];\n      if(ny >= 0 && ny < H && nx >= 0 && nx < W && S[ny][nx] == 0) {\n        Que.push(Pii(p.first + 1, Pi(nx, ny)));\n      }\n    }\n    Que.pop();\n  }\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\nint x, y;\nchar m[1024][1024];\nqueue<pair<int, int> > q;\n\nbool check_map() {\n\tbool flg = true;\n\tfor (int i = 0; i < y; i++) {\n\t\tfor (int i1 = 0; i1 < x; i1++) {\n\t\t\tint cnt = 0;\n\t\t\tif (m[i][i1] != '.') {\n\t\t\t\tint dx[8] = { 0, 0, 1, -1, 1, -1, 1, -1 }, dy[8] = { 1, -1, 0, 0, -1, -1, 1, 1 };\n\t\t\t\tfor (int i2 = 0; i2 < 8; i2++) {\n\t\t\t\t\tif (m[i + dy[i2]][i1 + dx[i2]] == '.') {\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tchar temp = m[i][i1];\n\t\t\t\tif (cnt >= atoi(&temp)) {\n\t\t\t\t\tq.push(make_pair(i, i1));\n\t\t\t\t\tflg = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn flg;\n}\n\nint main()\n{\n\tint cnt = 0;\n\tcin >> y >> x;\n\n\tfor (int i = 0; i < y; i++) {\n\t\tfor (int i1 = 0; i1 < x; i1++) {\n\t\t\tcin >> m[i][i1];\n\t\t}\n\t}\n\n\twhile (!check_map()) {\n\t\twhile (!q.empty()) {\n\t\t\tpair<int, int> temp = q.front();\n\t\t\tq.pop();\n\t\t\tm[temp.first][temp.second] = '.';\n\t\t}\n\t\tcnt++;\n\t}\n\n\tcout << cnt << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <algorithm>\n\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint n, m;\nchar c[1000][1001];\n\nint main(){\n\tscanf(\"%d%d\", &n, &m);\n\trep(i, n){\n\t\tscanf(\"%s\", c[i]);\n\t}\n\n\tqueue<P> q;\n\trep(i, n){\n\t\trep(j, m){\n\t\t\tif(c[i][j] != '.'){\n\t\t\t\tq.push(P(i, j));\n\t\t\t}\n\t\t}\n\t}\n\n\tint a = 0;\n\twhile(!q.empty()){\n\t\t/*\n\t\trep(i, n){\n\t\t\tputs(c[i]);\n\t\t}\n\t\tputs(\"\");\n\t\t*/\n\n\t\tvector<P> s;\n\t\tint y = q.size();\n\t\trep(k, y){\n\t\t\tP v = q.front();\n\t\t\tq.pop();\n\t\t\tif(c[v.first][v.second] == '.'){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint z = 0;\n\t\t\tvector<P> t;\n\t\t\tfor(int i = -1; i <= 1; ++i){\n\t\t\t\tfor(int j = -1; j <= 1; ++j){\n\t\t\t\t\tint x = v.first + i;\n\t\t\t\t\tint y = v.second + j;\n\t\t\t\t\tif((i != 0 || j != 0) && 0 <= x && x < n && 0 <= y && y < m){\n\t\t\t\t\t\tif(c[x][y] == '.'){\n\t\t\t\t\t\t\t++z;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tt.push_back(P(x, y));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(z >= c[v.first][v.second] - '0'){\n\t\t\t\ts.push_back(v);\n\t\t\t\trep(i, t.size()){\n\t\t\t\t\tq.push(t[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!s.empty()){\n\t\t\t++a;\n\t\t}\n\t\trep(i, s.size()){\n\t\t\tc[s[i].first][s[i].second] = '.';\n\t\t}\n\t}\n\tprintf(\"%d\\n\", a);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <queue>\nusing namespace std;\n\nint x, y;\nchar m[1024][1024];\nqueue<pair<int, int> > q;\n\nbool check_map() {\n\tbool flg = true;\n\tfor (int i = 0; i < y; i++) {\n\t\tfor (int i1 = 0; i1 < x; i1++) {\n\t\t\tint cnt = 0;\n\t\t\tif (m[i][i1] != '.') {\n\t\t\t\tint dx[8] = { 0, 0, 1, -1, 1, -1, 1, -1 }, dy[8] = { 1, -1, 0, 0, -1, -1, 1, 1 };\n\t\t\t\tfor (int i2 = 0; i2 < 8; i2++) {\n\t\t\t\t\tif (m[i + dy[i2]][i1 + dx[i2]] == '.') {\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tchar temp = m[i][i1];\n\t\t\t\tif (cnt >= atoi(&temp)) {\n\t\t\t\t\tq.push(make_pair(i, i1));\n\t\t\t\t\tflg = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn flg;\n}\n\nint main()\n{\n\tint cnt = 0;\n\tcin >> y >> x;\n\n\tfor (int i = 0; i < y; i++) {\n\t\tfor (int i1 = 0; i1 < x; i1++) {\n\t\t\tcin >> m[i][i1];\n\t\t}\n\t}\n\n\twhile (!check_map()) {\n\t\twhile (!q.empty()) {\n\t\t\tpair<int, int> temp = q.front();\n\t\t\tq.pop();\n\t\t\tm[temp.first][temp.second] = '.';\n\t\t}\n\t\tcnt++;\n\t}\n\n\tcout << cnt << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<algorithm>\n#define p pair<int,int>\n#define P pair<p,int>\nusing namespace std;\n\np x[1000000];\nint g[1000][1000];\nint main() {\n\tqueue<P>Q;\n\tint a, b;\n\tcin >> a >> b;\n\tchar d[1000];\n\tfor (int c = 0; c < a; c++) {\n\t\tscanf(\"%s\", d);\n\t\tfor (int e = 0; e < b; e++) {\n\t\t\tif (d[e] == '.')g[c][e] = 0;\n\t\t\telse g[c][e] = d[e] - '0';\n\t\t}\n\t}\n\tint k = 0;\n\tfor (int f = 1; f < a-1; f++) {\n\t\tfor (int h = 1; h < b-1; h++) {\n\t\t\tif (g[f][h]) {\n\t\t\t\tint sum = 0;\n\t\t\t\tfor (int i = -1; i < 2; i++) {\n\t\t\t\t\tfor (int j = -1; j < 2; j++) {\n\t\t\t\t\t\tif (g[f + i][h + j])sum++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (9 - sum >= g[f][h]) {\n\t\t\t\t\tQ.push(P(p(f, h), 1));\n\t\t\t\t\tx[k] = p(f, h);\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int t = 0; t < k; t++)g[x[t].first][x[t].second] = 0;\n\tint MAX = 0;\n\tint w = 0, now = 0;\n\twhile (Q.size()) {\n\t\tP s = Q.front();\n\t\tQ.pop();\n\t\tif (s.second != now) {\n\t\t\tfor (int t = 0; t < w; t++) { g[x[t].first][x[t].second] = 0; }\n\t\t\tw = 0;\n\t\t\tnow = s.second;\n\t\t}\n\t\tMAX = max(MAX, s.second);\n\t\tfor (int i = -1; i < 2; i++) {\n\t\t\tfor (int j = -1; j < 2; j++) {\n\t\t\t\tif (s.first.first + i>=1&& s.first.first + i<a-1&&s.first.second + j>=1&& s.first.second + j<b-1&&g[s.first.first + i][s.first.second + j]) {\n\t\t\t\t\tint sum = 0;\n\t\t\t\t\tfor (int n = -1; n < 2; n++) {\n\t\t\t\t\t\tfor (int m = -1; m < 2; m++) {\n\t\t\t\t\t\t\tif (g[s.first.first + i+n][s.first.second+j+m])sum++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (9 - sum >= g[s.first.first + i][s.first.second + j]) {\n\t\t\t\t\t\tQ.push(P(p(s.first.first + i, s.first.second + j), s.second + 1)); \n\t\t\t\t\t\tx[w] = p(s.first.first + i, s.first.second + j);\n\t\t\t\t\t\tw++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << MAX << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define Rep(i, a, b) for(int i = (a); i < (b); i++)\n#define rep(i, n) Rep(i, 0, n)\n\nint movX[8] = {-1, 0, 1,-1, 1,-1, 0, 1};\nint movY[8] = {-1,-1,-1, 0, 0, 1, 1, 1};\ntypedef pair<int, int> pii;\n\ntemplate<class T> T read() {\n\tT t;\n\tcin >> t;\n\treturn t;\n}\n\nint main(){\n\tint h=read<int>(),w=read<int>();\n\tint mp[h][w];\n\trep(i,h) rep(j,w){\n\t\tchar c=read<char>();\n\t\tif(c=='.'){\n\t\t\tmp[i][j]=0;\n\t\t}else{\n\t\t\tmp[i][j]=c-'0';\n\t\t}\n\t}\n\tint around[h][w];\n\tRep(i, 1, h-1){\n\t\tRep(j, 1, w-1){\n\t\t\tint a = 0;\n\t\t\trep(k,8) {\n\t\t\t\tint x = i+movX[k];\n\t\t\t\tint y = j+movY[k];\n\t\t\t\tif(!mp[x][y]){\n\t\t\t\t\ta++;\n\t\t\t\t}\n\t\t\t}\n\t\t\taround[i][j]=a;\n\t\t}\n\t}\n\t\n\t\n\tvector<pii> list;\n\tRep(i, 1, h-1){\n\t\tRep(j, 1, w-1){\n\t\t\tif(mp[i][j]>0 && around[i][j]>=mp[i][j]){\n\t\t\t\tlist.push_back(pii(i,j)); \n\t\t\t}\n\t\t}\n\t}\n\tif(list.size()==0){\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\tfor(vector<pii>::iterator it=list.begin();it!=list.end();it++){\n\t\tint i = it->first, j = it->second;\n\t\tmp[i][j] = 0;\n\t\trep(k,8) {\n\t\t\tint x = i+movX[k];\n\t\t\tint y = j+movY[k];\n\t\t\taround[x][y]++;\n\t\t}\n\t\t// printf(\"(%d, %d)\\n\",i,j);\n\t}\n\t// printf(\"=============\\n\");\n\t\n\tint count = 1;\n\twhile(true){\n\t\tvector<pii> list2;\n\t\tfor(vector<pii>::iterator it=list.begin();it!=list.end();it++){\n\t\t\tint i = it->first, j = it->second;\n\t\t\t// cout << i << \" \" << j << endl;\n\t\t\trep(k,8) {\n\t\t\t\tint x = i+movX[k];\n\t\t\t\tint y = j+movY[k];\n\t\t\t\tif(mp[x][y]>0 && around[x][y]>=mp[x][y]){\n\t\t\t\t\tlist2.push_back(pii(x,y));\n\t\t\t\t\t// cout << \"    \" <<  i << \" \" << j << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(list2.size()==0){\n\t\t\tcout << count << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tcout << list2.size() << endl;\n\t\tcount++;\n\t\tvector<pii> list3;\n\t\tfor(vector<pii>::iterator it=list2.begin();it!=list2.end();it++){\n\t\t\tint i = it->first, j = it->second;\n\t\t\tif(mp[i][j]){\n\t\t\t\tlist3.push_back(*it);\n\t\t\t\tmp[i][j] = 0;\n\t\t\t\trep(k,8) {\n\t\t\t\t\tint x = i+movX[k];\n\t\t\t\t\tint y = j+movY[k];\n\t\t\t\t\taround[x][y]++;\n\t\t\t\t}\n\t\t\t\t// printf(\"(%d, %d)\\n\",i,j);\n\t\t\t}\n\t\t}\n\t\t// printf(\"=============\\n\");\n\t\tstd::vector<pii>().swap(list);\n\t\tstd::vector<pii>().swap(list2);\n\t\tlist = list3;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <stdio.h>\n#include <stdlib.h>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <math.h>\n#include <utility>\n#include <set>\n#include <map>\n#define INF 1000000000\n#define rep(i,n) for(int i =0;i<n;i++)\nusing namespace std;\ntypedef long long int ll;\n\n\nint main(){\n    int h,w;\n    cin >>h >> w;\n    vector<int> area(h*w);\n    vector<int> ch(h*w,0);\n    rep(i, h){\n        rep(j, w){\n            char hoge;\n            cin >> hoge;\n            if (hoge == '.') {\n                area[i*w+j]=-1;\n                for (int k=-1; k<2; k++) {\n                    for (int l=-1; l<2; l++) {\n                        if((k==0 and l==0) or area[(i+k)*w+j+l]==-1) continue;\n                        if (i+k>0 and i+k<h-1 and j+l>0 and j+l<w-1) {\n                            ch[(i+k)*w+j+l]++;\n                        }\n                    }\n                }\n            }else{\n                area[i*w+j]=(int)hoge-(int)'0';\n            }\n        }\n    }\n    int ans = 0;\n    int flag = 1;\n    while (flag > 0) {\n        vector<int> olda = area;\n        vector<int> oldc = ch;\n        flag = 0;\n        rep(i, h){\n            rep(j, w){\n                if (olda[i*w+j]!=-1 and oldc[i*w+j]>=olda[i*w+j]) {\n                    area[i*w+j]=-1;\n                    for (int k=-1; k<2; k++) {\n                        for (int l=-1; l<2; l++) {\n                            if(k==0 and l==0) continue;\n                            if (i+k>0 and i+k<h-1 and j+l>0 and j+l<w-1) {\n                                ch[(i+k)*w+j+l]++;\n                            }\n                        }\n                    }\n                    flag++;\n                }\n            }\n        }\n        if(flag > 0) ans++;\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<bits//stdc++.h>\n#include<functional>\nusing namespace std;\nstruct P{\n\tint x,y;\n};\nint main() {\n\tint a[1000][1000],g[1000][1000];\n\tint h,w;\n\tcin>>h>>w;\n\tfor(int i=0;i<h;i++){\n\t\tstring s;\n\t\tcin>>s;\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(s[j]=='.') a[i][j]=0;\n\t\t\telse a[i][j]=(int)s[j]-'0';\n\t\t}\n\t}\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++)g[i][j]=0;\n\t}\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(a[i][j]==0){\n\t\t\t\tfor(int x=-1;x<=1;x++){\n\t\t\t\t\tfor(int y=-1;y<=1;y++) {\n\t\t\t\t\t\tif(i+x<h&&i+x>=0&&j+y<w&&j+y>=0){\n\t\t\t\t\t\t\tg[i+x][j+y]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint sum=0;\n\tbool l=true;\n\twhile(l){\n\t\tl=false;\n\t\tvector<P>p;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(g[i][j]>=a[i][j]&&a[i][j]!=0){\n\t\t\t\t\ta[i][j]=0;\n\t\t\t\t\tp.push_back(P{i,j});\n\t\t\t\t\tl=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<(int)p.size();i++){\n\t\t\tfor(int x=-1;x<=1;x++){\n\t\t\t\tfor(int y=-1;y<=1;y++){\n\t\t\t\t\t g[p[i].x+x][p[i].y+y]++;\n\t\t\t\t }\n\t\t\t}\n\t\t}\n\t\tsum++;\n\t}\n\tcout<<--sum<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define Rep(i, N) for(int i = 0; i < N; i++)\n#define F first\n#define S second\ntypedef pair<int,int> Pi;\n#define INF 1 << 28\n\nint mx[] = {-1,0,1,1,1,0,-1,-1};\nint my[] = {1,1,1,0,-1,-1,-1,0};\n\nint main()\n{\n  int H, W;\n  char mas[1005][1005];\n  int cnt[1005][1005];\n  int mc[1005][1005];\n  int maxv = 0;\n  queue<Pi>que;\n  fill_n(*mas, 1005 * 1005, '.');\n  fill_n(*mc, 1005 * 1005, INF);\n  cin >> H >> W;\n  Rep(i, H) Rep(j, W) cin >> mas[i + 1][j + 1];\n\n  for(int i = 1; i <= H; i++) {\n    for(int j = 1; j <= W; j++) {\n      int cnt = 0;\n      Rep(k, 8) {\n\tint ny = i + my[k], nx = j + mx[k];\n\tif(mas[ny][nx] == '.') cnt++;\n      }\n      if(cnt >= mas[i][j] - '0') {\n\tque.push(Pi(i, j));\n\tmc[i][j] = 1;\n      }\n    }\n  }\n  while(!que.empty()) {\n    int y = que.front().F, x = que.front().S; que.pop();\n    Rep(i,8) {\n      int ny = y + my[i], nx = x + mx[i];\n      if(mas[ny][nx] == '.' || mc[ny][nx] != INF || ++cnt[ny][nx] < mas[ny][nx] - '0')continue;\n      que.push(Pi(ny, nx)); mc[ny][nx] = mc[y][x] + 1;\n      maxv = max(maxv, mc[ny][nx]);\n    }\n  }\n  cout << maxv << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstring>\nusing namespace std;\n\n#define MAX 1001\n\nint main(){\n\tstring S;\n\tint n,m,t,sum,a;\n\tsum=0;\n\tshort x[MAX][MAX];\n\tshort z[MAX][MAX];\n\tshort v[MAX][MAX];\n\tmemset(x,0,sizeof(x));\n\tmemset(z,0,sizeof(z));\n\tchar T[10]={'.','1','2','3','4','5','6','7','8','9'};\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>S;\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tfor(int k=0;k<10;k++){\n\t\t\t\tif(S[j-1]==T[k]){\n\t\t\t\t\tx[i][j]=k;\n\t\t\t\t\tif(k==0){\n\t\t\t\t\t\tfor(int l=-1;l<=1;l++){\n\t\t\t\t\t\t\tfor(int o=-1;o<=1;o++){\n\t\t\t\t\t\t\t\tz[i+l][j+o] += 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\twhile(true){\n\t\tt=0;\n\t\tsum++;\n\t\tfor(int i=2;i<n;i++){\n\t\t\tfor(int j=2;j<m;j++){\n\t\t\t\tif(x[i][j]>=1 && z[i][j]>=x[i][j]){\n\t\t\t\t\ta=0;\n\t\t\t\t\tv[i][j] += 1;\n\t\t\t\t\tt++;\n\t\t\t\t\tfor(int l=-1;l<=1;l++){\n\t\t\t\t\t\tfor(int o=-1;o<=1;o++){\n\t\t\t\t\t\t\tv[i+l][j+o]+= 10;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(t==0){\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i=2;i<n;i++){\n\t\t\tfor(int j=2;j<m;j++){\n\t\t\t\tif(v[i][j]%10>=1){\n\t\t\t\t\tx[i][j]=0;\n\t\t\t\t}\n\t\t\t\tz[i][j] += v[i][j]/10;\n\t\t\t\tv[i][j]=0;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<sum-1<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> pa;\ntypedef pair<int,pa> pp;\n\nint ary[1010][1010];\nint dy[8]={0,1,1,1,0,-1,-1,-1},dx[8]={1,1,0,-1,-1,-1,0,1};\nint H,W;\n\nint main(){\n\tcin>>H>>W;\n\tchar ch;\n\tqueue<pa> quf;\n\tset<pa> se[2];\n\tfor(int i=1;i<=H;i++){\n\t\tfor(int j=1;j<=W;j++){\n\t\t\tcin>>ch;\n\t\t\tif(ch=='.') ary[i][j]=0;\n\t\t\telse ary[i][j]=ch-'0';\n\t\t\tse[1].insert(pa(i,j));\n\t\t}\n\t}\n\t\n\tint tmx,tmy,now=0,cnt=0,res=0;\n\tquf.push(pa(0,0));\n\tfor(int i=1;;i++){\n\t\tif(quf.empty()){\n\t\t\tres=i-2;\n\t\t\tbreak;\n\t\t}\n\t\twhile(!quf.empty()){\n\t\t\tary[quf.front().first][quf.front().second]=0;\n\t\t\tquf.pop();\n\t\t}\n\t\tse[1-(i&1)].clear();\n\t\tfor(auto it=se[i&1].begin();it!=se[i&1].end();it++){\n\t\t\tif(ary[it->first][it->second]==0) continue;\n\t\t\tcnt=0;\n\t\t\tfor(int j=0;j<8;j++){\n\t\t\t\tif(ary[it->first+dx[j]][it->second+dy[j]]==0){\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ary[it->first][it->second]<=cnt){\n\t\t\t\tquf.push(pa(it->first,it->second));\n\t\t\t\tfor(int j=0;j<8;j++){\n\t\t\t\t\tif((1<=it->first+dx[j])&&(it->first+dx[j]<=H)&&(1<=it->second+dy[j])&&(it->second+dy[j]<=W)) se[1-(i&1)].insert(pa(it->first+dx[j],it->second+dy[j]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<\"\";\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <iostream>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\nint h,w;\nint fie[1001][1001];\nint fade[1001][1001];\nint cnt[1001][1001];\nint t[1001][1001];\n\nint bfs(){\n\tqueue<P> que;\n\tint res=0;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tint none=0;\n\t\t\tfor(int k=-1;k<=1;k++){\n\t\t\t\tfor(int l=-1;l<=1;l++){\n\t\t\t\t\tint y=i+k,x=j+l;\n\t\t\t\t\tif(x>=0 && x<w && y>=0 && y<h){\n\t\t\t\t\t\tif(fie[y][x]==0)none++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcnt[i][j]=none;\n\t\t\tif(none>=fie[i][j] && fie[i][j]>=1){\n\t\t\t\tt[i][j]=1;\n\t\t\t\tfade[i][j]=1;\n\t\t\t\tque.push(P(i,j));\n\t\t\t}\n\t\t}\n\t}\n\twhile(que.size()){\n\t\tP q=que.front();\n\t\tque.pop();\n\t\tint y=q.first,x=q.second;\n\t\tfie[y][x]=0;\n\t\tfor(int i=-1;i<=1;i++){\n\t\t\tfor(int j=-1;j<=1;j++){\n\t\t\t\tint nx=x+j,ny=y+i;\n\t\t\t\tif(nx>=0 && nx<w && ny>=0 && ny<w){\n\t\t\t\t\tcnt[ny][nx]++;\n\t\t\t\t\tif(cnt[ny][nx]>=fie[ny][nx] && fie[ny][nx]>=1 && fade[ny][nx]==0){\n\t\t\t\t\t\tfade[ny][nx]=1;\n\t\t\t\t\t\tt[ny][nx]=t[y][x]+1;\n\t\t\t\t\t\tque.push(P(ny,nx));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tres=max(res,t[i][j]);\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(void){\n\tscanf(\"%d %d\",&h,&w);\n\tfor(int i=0;i<h;i++){\n\t\tstring str;\n\t\tcin >> str;\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(str[j]>='0' && str[j]<='9')fie[i][j]=str[j]-'0';\n\t\t}\n\t}\n\tprintf(\"%d\\n\",bfs());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstring>\nusing namespace std;\n\n#define MAX 1001\n\nint main(){\n\tstring S;\n\tint n,m,t,sum,a;\n\tsum=0;\n\tshort x[MAX][MAX];\n\tshort z[MAX][MAX];\n\tshort v[MAX][MAX];\n\tmemset(x,0,sizeof(x));\n\tmemset(z,0,sizeof(z));\n\tchar T[10]={'.','1','2','3','4','5','6','7','8','9'};\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>S;\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tfor(int k=0;k<10;k++){\n\t\t\t\tif(S[j-1]==T[k]){\n\t\t\t\t\tx[i][j]=k;\n\t\t\t\t\tif(k==0){\n\t\t\t\t\t\tfor(int l=-1;l<=1;l++){\n\t\t\t\t\t\t\tfor(int o=-1;o<=1;o++){\n\t\t\t\t\t\t\t\tz[i+l][j+o] += 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\twhile(true){\n\t\tt=0;\n\t\tsum++;\n\t\tmemset(v,0,sizeof(v));\n\t\tfor(int i=2;i<n;i++){\n\t\t\tfor(int j=2;j<m;j++){\n\t\t\t\tif(x[i][j]>=1 && z[i][j]>=x[i][j]){\n\t\t\t\t\ta=0;\n\t\t\t\t\tv[i][j] += 1;\n\t\t\t\t\tt++;\n\t\t\t\t\tfor(int l=-1;l<=1;l++){\n\t\t\t\t\t\tfor(int o=-1;o<=1;o++){\n\t\t\t\t\t\t\tv[i+l][j+o]+= 10;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(t==0){\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i=2;i<n;i++){\n\t\t\tfor(int j=2;j<m;j++){\n\t\t\t\tif(v[i][j]%10>=1){\n\t\t\t\t\tx[i][j]=0;\n\t\t\t\t}\n\t\t\t\tz[i][j] += v[i][j]/10;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<sum-1<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<utility>\nusing namespace std;\ntypedef pair<int, int>P;\n\nchar sand[1005][1005];\nint sara[1005][1005];\n\nint main() {\n\tint h, w;\n\tcin >> h >> w;\n\tqueue<P>now;\n\tqueue<P>next;\n\n\tfor (int i = 0;i<h;i++)\n\t\tfor (int j = 0;j<w;j++)cin >> sand[i][j];\n\n\tfor (int i = 0;i<h;i++) {\n\t\tfor (int j = 0;j<w;j++) {\n\t\t\tif (sand[i][j] != '.') {\n\t\t\t\tfor (int k = -1;k <= 1;k++) {\n\t\t\t\t\tfor (int l = -1;l <= 1;l++) {\n\t\t\t\t\t\tif (sand[i + k][j + l] == '.')sara[i][j]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0;i<h;i++) {\n\t\tfor (int j = 0;j<w;j++) {\n\t\t\tif (sand[i][j] != '.') {\n\t\t\t\tint a = sand[i][j] - '0';\n\t\t\t\tif (a <= sara[i][j]) {\n\t\t\t\t\tnow.push(make_pair(i, j));\n\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\n\twhile(now.size()){\n\tint a = now.size();\n\tqueue<P>q;\n\n\tfor (int i = 0;i < a;i++) {\n\t\tP p = now.front();\n\t\tnow.pop();\n\n\t\tint f = p.first, s = p.second;\n\n\t\tsand[f][s] = '.';\n\t\tsara[f][s] = 0;\n\t\t\n\t\tfor (int j = -1;j <= 1;j++) {\n\t\t\tfor (int k = -1;k <= 1;k++) {\n\t\t\t\tif (sand[f + j][s + k] != '.')q.push(make_pair(f + j, s + k));\n\t\t\t}\n\t\t}\n\t}\n\n\tint b = q.size();\n\tfor (int i = 0;i < b;i++) {\n\t\tP pa = q.front();\n\t\tq.pop();\n\t\tint m=0;\n\t\tfor (int j = -1;j <= 1;j++) {\n\t\t\tfor (int k = -1;k <= 1;k++) {\n\t\t\t\tif (sand[pa.first + j][pa.second + k] == '.')m++;\n\t\t\t}\n\t\t}\n\t\tsara[pa.first][pa.second] = m;\n\t\tif (sara[pa.first][pa.second] >= sand[pa.first][pa.second] - '0')next.push(pa);\n\t}\n\n\tint c=next.size();\n\n\tfor(int i=0;i<c;i++){\n\tnow.push(next.front());\n\tnext.pop();\n\t}\n\n\tans++;\n\t}\n\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint main(){\n\tint h,w;\n\tscanf(\"%d%d\",&h,&w);\n\tchar d[1000][1001];\n\tfor(int i=0;i<h;i++) scanf(\"%s\",d[i]);\n\tvector<P> *v; vector<P> p; v=&p;\n\tfor(int i=0;i<h;i++) for(int j=0;j<w;j++){\n\t\tif(d[i][j]!='.'){\n\t\t\tint z=0;\n\t\t\tfor(int k=-1;k<=1;k++) for(int r=-1;r<=1;r++) if(d[i+k][j+r]=='.') z++;\n\t\t\tif(z>=d[i][j]-48) v->push_back(P(i,j));\n\t\t}\n\t}\n\tint res=0;\n\twhile(v->size()){\n\t\tres++;\n\t\tvector<P> *p= new vector<P>;\n\t\tfor(int i=0;i<v->size();i++){\n\t\t\tP x=v->at(i);\n\t\t\td[x.first][x.second]='.';\n\t\t}\n\t\tfor(int q=0;q<v->size();q++){\n\t\t\tP x=v->at(q);\n\t\t\tfor(int i=x.first-1;i<=x.first+1;i++) for(int j=x.second-1;j<=x.second+1;j++){\n\t\t\t\tif(d[i][j]=='.') continue;\n\t\t\t\tint z=0;\n\t\t\t\tfor(int k=-1;k<=1;k++) for(int r=-1;r<=1;r++) if(i+k!=-1&&i+k!=h&&j+r!=-1&&j+r!=w) if(d[i+k][j+r]=='.') z++;\n\t\t\t\tif(z>=d[i][j]-48) p->push_back(P(i,j));\n\t\t\t}\n\t\t}\n\t\tsort(p->begin(),p->end());\n\t\tp->erase(unique(p->begin(),p->end()),p->end());\n\t\tv=p;\n\t}\n\tprintf(\"%d\\n\",res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <list>\n#include <stdio.h>\n#include <string.h>\n#include <cstdlib>\n#include <math.h>\n#include <bitset>\n#include <iterator>\n#include <iomanip>\n#include <sstream>\n#include <numeric>\n#define INF 2000000000\nusing namespace std;\nint dx[8]={1,1,0,-1,-1,-1,0,1},dy[8]={0,1,1,1,0,-1,-1,-1};\n#define sym cout<<\"---------\"<<endl;\n#define ll long long\n#define PL pair<long long, long long>\n#define P pair<int,int>\n#define mk make_pair\n#define en endl\n#define WHITE 0\n#define BLACK 2\n#define GRAY 1\n#define RE return 0\n#define int ll\n\n#define MAX 1005\nint castle[MAX][MAX];\nint many[MAX][MAX];\nbool come[MAX][MAX];\n\nsigned main(){\n  int h,w;\n  cin>>h>>w;\n  \n  for(int i=1; i<=h; i++) for(int j=1; j<=w; j++){\n    char ch;\n    cin>>ch;\n    if(ch=='.') castle[i][j]=-1;\n    else castle[i][j]=(int)ch-'0';\n    come[i][j]=false;\n  }\n  \n  queue<P> que;\n  for(int i=1; i<=h; i++) for(int j=1; j<=w; j++){\n    int cnt=0;\n    if(castle[i][j]==-1) continue;\n    for(int k=0; k<8; k++){\n      int y=i+dy[k],x=j+dx[k];\n      if(castle[y][x]==-1) cnt++;\n    }\n    if(cnt>=castle[i][j]){\n      come[i][j]=true;\n      que.push(mk(i,j));\n      many[i][j]=1;\n    }else castle[i][j]-=cnt;\n  }\n  \n  while(!que.empty()){\n    int y=que.front().first,x=que.front().second;\n    que.pop();\n    for(int i=0; i<8; i++){\n      if(come[y+dy[i]][x+dx[i]]) continue;\n      if(y+dy[i]<1||y+dy[i]>h) continue;\n      if(x+dx[i]<1||x+dx[i]>w) continue;\n      if(castle[y+dy[i]][x+dx[i]]==-1) continue;\n      castle[y+dy[i]][x+dx[i]]--;\n      if(castle[y+dy[i]][x+dx[i]]==0){\n        que.push(mk(y+dy[i],x+dx[i]));\n        many[y+dy[i]][x+dx[i]]=many[y][x]+1;\n        come[y+dy[i]][x+dx[i]]=true;\n      }\n    }\n  }\n  \n  int ans=0;\n  for(int i=1; i<=h; i++) for(int j=1; j<=w; j++) ans=max(ans,many[i][j]);\n  \n  cout<<ans<<en;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\n\nint main() {\n\tint H, W;\n\tchar S[100][100];\n\tint i, j;\n\tint ans = 0, cou = 0, cou2 = 0;\n\tint s[100][100], ss[100][100];\n\tscanf(\"%d %d\", &H, &W);\n\tfor (i = 1; i <= H; i++) {\n\t\tfor (j = 1; j <= W; j++) {\n\t\t\tscanf(\" %c\", &S[i][j]);\n\t\t\tif (S[i][j] == '.') {\n\t\t\t\ts[i][j] = 0;\n\t\t\t\tss[i][j] = 10;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ts[i][j] = S[i][j] - 48;\n\t\t\t\tss[i][j] = 10;\n\t\t\t}\n\t\t}\n\t}\n\t//////////////\n\t//for (i = 1; i <= H; i++) {\n\t\t//for (j = 1; j <= W; j++) {\n\t\t\t//printf(\"%d\", ss[i][j]);\n\t\t//}\n\t\t//printf(\"\\n\");\n\t//}\n\t////////\n\twhile (1) {\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\tif ((s[i][j] != 0 && ss[i][j]==10) && ((s[i - 1][j] == 0) | (s[i - 1][j-1] == 0) | (s[i][j-1] == 0) | (s[i - 1][j+1] == 0) | (s[i + 1][j-1] == 0) | (s[i + 1][j] == 0) | (s[i][j+1] == 0) |(s[i + 1][j+1] == 0) )) {\n\t\t\t\t\tif (s[i - 1][j - 1] == 0) {\n\t\t\t\t\t\tcou++;\n\t\t\t\t\t}\n\t\t\t\t\tif (s[i - 1][j] == 0) {\n\t\t\t\t\t\tcou++;\n\t\t\t\t\t}\n\t\t\t\t\tif (s[i - 1][j + 1] == 0) {\n\t\t\t\t\t\tcou++;\n\t\t\t\t\t}\n\t\t\t\t\tif (s[i][j - 1] == 0) {\n\t\t\t\t\t\tcou++;\n\t\t\t\t\t}\n\t\t\t\t\tif (s[i][j + 1] == 0) {\n\t\t\t\t\t\tcou++;\n\t\t\t\t\t}\n\t\t\t\t\tif (s[i + 1][j - 1] == 0) {\n\t\t\t\t\t\tcou++;\n\t\t\t\t\t}\n\t\t\t\t\tif (s[i + 1][j] == 0) {\n\t\t\t\t\t\tcou++;\n\t\t\t\t\t}\n\t\t\t\t\tif (s[i + 1][j + 1] == 0) {\n\t\t\t\t\t\tcou++;\n\t\t\t\t\t}\n\t\t\t\t\tif (cou >= s[i][j]) {\n\t\t\t\t\t\tss[i][j] = 0;\n\t\t\t\t\t\tcou2++;\n\t\t//     \t\t\tprintf(\"%d %d\\n\", i, j);\n\t\t\t\t\t}\n\t\t\t\t\tcou = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//printf(\"%d\\n\", cou2);\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\tif (ss[i][j] == 0) {\n\t\t\t\t\ts[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (cou2 == 0) break;\n\t\tcou2 = 0;\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t//\tprintf(\"%d\", s[i][j]);\n\t\t\t}\n\t\t\t//printf(\"\\n\");\n\t\t}\n\t\t//printf(\"\\n\");\n\t\tans++;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstring>\nusing namespace std;\n \n#define MAX 12\n \nint main(){\n    string S;\n    int n,m,t,sum,a;\n    sum=0;\n    short x[MAX][MAX];\n    short z[MAX][MAX];\n    short v[MAX][MAX];\n    memset(x,0,sizeof(x));\n    memset(z,0,sizeof(z));\n    char T[10]={'.','1','2','3','4','5','6','7','8','9'};\n    cin>>n>>m;\n    for(int i=1;i<=n;i++){\n        cin>>S;\n        for(int j=1;j<=m;j++){\n            for(int k=0;k<10;k++){\n                if(S[j-1]==T[k]){\n                    x[i][j]=k;\n                    if(k==0){\n                        for(int l=-1;l<=1;l++){\n                            for(int o=-1;o<=1;o++){\n                                z[i+l][j+o] += 1;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    while(true){\n        t=0;\n        sum++;\n        for(int i=2;i<n;i++){\n            for(int j=2;j<m;j++){\n                if(x[i][j]>=1 && z[i][j]>=x[i][j]){\n                    a=0;\n                    v[i][j] += 1;\n                    t++;\n                    for(int l=-1;l<=1;l++){\n                        for(int o=-1;o<=1;o++){\n                            v[i+l][j+o]+= 10;\n                        }\n                    }\n                }\n            }\n        }\n        if(t==0){\n            break;\n        }\n        for(int i=2;i<n;i++){\n            for(int j=2;j<m;j++){\n                if(v[i][j]%10>=1){\n                    x[i][j]=0;\n                }\n                z[i][j] += v[i][j]/10;\n                v[i][j]=0;\n            }\n        }\n    }\n    cout<<sum-1<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\nint dx8[8] = { -1,-1,-1, 0, 1, 1, 1, 0 };\nint dy8[8] = { -1, 0, 1, 1, 1, 0,-1,-1 };\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\nint main() {\n\tint H, W; cin >> H >> W;\n\tvector<vector<int>>field(H+2, vector<int>(W + 2));\n\tvector<vector<int>>nums(H + 2, vector<int>(W + 2));\n\tfor (int i = 0; i < H; ++i) {\n\t\tstring st; cin >> st;\n\t\tfor (int j = 0; j < W; ++j) {\n\t\t\tif (st[j] == '.') {\n\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfield[i + 1][j + 1] = st[j] - '0';\n\t\t\t\tnums[i+1][j+1] = st[j] - '0';\n\t\t\t}\n\t\t}\n\t}\n\tqueue<pair<int, int>>que;\n\tvector<vector<int>>newnums(nums);\n\tfor (int y = 1; y < H + 1; ++y) {\n\t\tfor (int x = 1; x < W + 1; ++x) {\n\t\t\tif (nums[y][x] <= 0) {\n\t\t\t\tfor (int way = 0; way < 8; ++way) {\n\t\t\t\t\tconst int ax = x + dx8[way];\n\t\t\t\t\tconst int ay = y + dy8[way];\n\t\t\t\t\tnewnums[ay][ax]--;\n\t\t\t\t\tif (!newnums[ay][ax]) {\n\t\t\t\t\t\tque.push(make_pair(ax, ay));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tnums = newnums;\n\tint ans = 0;\n\twhile (!que.empty()) {\n\t\tqueue<pair<int, int>>newque;\n\t\twhile (!que.empty()) {\n\t\t\tauto p(que.front());\n\t\t\tque.pop();\n\t\t\tconst int x = p.first;\n\t\t\tconst int y = p.second;\n\t\t\tfor (int way = 0; way < 8; ++way) {\n\t\t\t\tconst int ax = x + dx8[way];\n\t\t\t\tconst int ay = y + dy8[way];\n\t\t\t\tnums[ay][ax]--;\n\t\t\t\tif (!nums[ay][ax]) {\n\t\t\t\t\tnewque.push(make_pair(ax, ay));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tque = newque;\n\t\tans++;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <string>\nusing namespace std;\n#define F first\n#define S second\nconst int INF = 1 << 31, MAX_HW = 1000;\ntypedef pair<int, int> P;\n\nint check(int x, int y);\nint h, w, ans;\nint land[MAX_HW + 2][MAX_HW + 2];\nqueue<P> que;\n\nint main(){\n\n  cin >> h >> w;\n  for(int i = 1; i <= h; i++){\n    for(int j = 1; j <= w; j++){\n      char in;\n      cin >> in;\n      land[i][j] = in - 48; // . = -2 \n    }\n  }\n  for(int i = 1; i <= h; i++){\n    for(int j = 1; j <= w; j++){\n      if(land[i][j] != -2 && land[i][j] <= check(i, j)){\n\tque.push(P(i, j));\n      }\n    }\n  }\n  for(;;){\n    queue<P> que2;\n    bool reach[MAX_HW + 2][MAX_HW + 2] = {};\n    while(!que.empty()){   \n      P p =que.front();\n      que.pop();\n      land[p.F][p.S] = -2;\n      for(int i = -1; i <= 1; i++){\n\tfor(int j = -1; j <= 1; j++){\n\t  if(land[p.F+i][p.S+j] != -2 && !reach[p.F+i][p.S+j] && land[p.F+i][p.S+j] <= check(p.F+i, p.S+j)){\n\t    que2.push(P(p.F + i,p.S + j));\n\t  }\n\t}\n      }\n    }\n    ans++;\n    if(que2.empty()){\n      break;\n    }\n    while(!que2.empty()){\n      que.push(que2.front());\n      que2.pop();\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n\n\nint check(int y, int x){\n  int re = 0;\n  for(int i = -1; i <= 1; i++){\n    for(int j = -1; j <= 1; j++){\n      if(land[y+i][x+j]==-2){\n\tre++;\n      }\n    }\n  }\n  return re;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <map>\n#define FLAG -1\nusing namespace std;\ntypedef pair<int,int> P;\nint main(){\n      int h,w,dh[] = {1,1,1,0,-1,-1,-1,0}, dw[] = {1,0,-1,-1,-1,0,1,1},ctn,i,j;\n      int solve = -2 ;\n      cin >> h >> w;\n      queue<P> que,tmp;\n      char d[h][w];\n      bool f[w][h];\n      for(i=0;i<h;i++){\n            for(j=0;j<w;j++)\n            {\n                  cin >> d[i][j];\n                  if('1'<=d[i][j]&&'9'>=d[i][j])\n                        que.push(make_pair(i,j));\n            }\n      }\n\n      que.push(make_pair(FLAG,FLAG));\n      for(;;){\n            solve++;\n            map<P,bool> m;\n            for(i=0;i<h;i++)for(j=0;j<w;j++)f[i][j]=false;\n            for(;;){\n                  //cout << que.size()<<endl;\n                  P p = que.front();\n                  que.pop();\n                  if(p.first==FLAG)\n                  {//cout <<\" break \"<<endl<<endl;\n                  break;\n                  }\n                  ctn = 0;\n                  for(i = 0;i < 8;i++){\n                        if(d[p.first+dh[i]][p.second+dw[i]]=='.')ctn++;\n                  }\n\n                  if(ctn >= d[p.first][p.second]-'0'){\n                        tmp.push(p);\n                        for(j=0;j<8;j++)\n                        if(!f[p.first][p.second]&&d[p.first][p.second]!='.'){\n                        que.push(make_pair(p.first+dh[j],p.second+dw[j]));\n                        f[p.first][p.second]=true;\n\n                  }\n                  }\n            }\n            if(tmp.empty())break;\n            while(!tmp.empty())\n            {\n                  d[tmp.front().first][tmp.front().second]='.';\n                  tmp.pop();\n            }\n            /*for(i =0 ;i<h;i++)\n            {\n                  for(j=0;j<w;j++)cout << d[i][j];\n                  cout <<endl;\n            }\n            */\n\n            que.push(make_pair(FLAG,FLAG));\n\n      }\n      cout << solve << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstring>\nusing namespace std;\n \n#define MAX 1001\n \nint main(){\n    string S;\n    int n,m,t,sum,a;\n    sum=0;\n    short x[MAX][MAX];\n    short z[MAX][MAX];\n    short v[MAX][MAX];\n    memset(x,0,sizeof(x));\n    memset(z,0,sizeof(z));\n    char T[10]={'.','1','2','3','4','5','6','7','8','9'};\n    cin>>n>>m;\n    for(int i=1;i<=n;i++){\n        cin>>S;\n        for(int j=1;j<=m;j++){\n            for(int k=0;k<10;k++){\n                if(S[j-1]==T[k]){\n                    x[i][j]=k;\n                    if(k==0){\n                        for(int l=-1;l<=1;l++){\n                            for(int o=-1;o<=1;o++){\n                                z[i+l][j+o] += 1;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    while(true){\n        t=0;\n        sum++;\n        for(int i=2;i<n;i++){\n            for(int j=2;j<m;j++){\n                if(x[i][j]>=1 && z[i][j]>=x[i][j]){\n                    a=0;\n                    v[i][j] += 1;\n                    t++;\n                    for(int l=-1;l<=1;l++){\n                        for(int o=-1;o<=1;o++){\n                            v[i+l][j+o]+= 10;\n                        }\n                    }\n                }\n            }\n        }\n        if(t==0){\n            break;\n        }\n        for(int i=2;i<n;i++){\n            for(int j=2;j<m;j++){\n                if(v[i][j]%10>=1){\n                    x[i][j]=0;\n                }\n                z[i][j] += v[i][j]/10;\n                v[i][j]=0;\n            }\n        }\n    }\n    cout<<sum-1<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nstring board[1001];\nint dx[8] = {0, 1, 1, 1, 0, -1, -1, -1};\nint dy[8] = {1, 1, 0, -1, -1, -1, 0, 1};\nint h, w;\nbool hantei(int y, int x){\n\tif(0 <= y && y < h && 0 <= x && x < w) return true;\n\telse return false;\n}\n\nint main(void){\n\tcin >> h >> w;\n\trep(i, h) cin >> board[i];\n\tqueue<pair<int, int> > q1, q2;\n\trep(i, h)rep(j, w){\n\t\tif(board[i][j] != '.') q1.push(make_pair(i, j));\n\t}\n\n\tint ans = -1, cnt = 0, nowy, nowx;\n\tbool flag = true;\n\twhile(flag && cnt < 500){\n\t\tflag = false; ans++;\n\t\tvector<pair<int, int> > memo;//?????????????????????????????????????????????????????????\n\n\t\tif(cnt % 2 == 0){\n\t\t\twhile(!q1.empty()){//q1??????????????\n\t\t\t\tpair<int, int> now = q1.front(); q1.pop();\n\t\t\t\tif(board[now.first][now.second] == '.') continue;\n\t\t\t\tint tmp = 0;\n\t\t\t\trep(i, 8){\n\t\t\t\t\tint nowy = now.first + dy[i], nowx = now.second + dx[i];\n\t\t\t\t\tif(!hantei(nowy, nowx)) continue;\n\t\t\t\t\tif(board[nowy][nowx] == '.')tmp++;\n\t\t\t\t}\n\t\t\t\tif(tmp >= board[now.first][now.second] - '0'){\n\t\t\t\t\t// printf(\"q1 y:%d  x:%d\\n\", now.first, now.second);\n\t\t\t\t\tmemo.push_back(make_pair(now.first, now.second));\n\t\t\t\t\t// printf(\"mawari\\n\");\n\t\t\t\t\trep(k, 8){//???????????????????????????????????????????????????????????????????\n\t\t\t\t\t\tint ny = now.first + dy[k], nx = now.second + dx[k];\n\t\t\t\t\t\tif(!hantei(ny, nx)) continue;\n\t\t\t\t\t\tif(board[ny][nx] != '.') q2.push(make_pair(ny, nx));\n\t\t\t\t\t\t// printf(\"q2 ny:%d  nx:%d\\n\", ny, nx);\n\t\t\t\t\t}\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\twhile(!q2.empty()){//q2??????????????\n\t\t\t\tpair<int, int> now = q2.front(); q2.pop();\n\t\t\t\tif(board[now.first][now.second] == '.') continue;\n\t\t\t\tint tmp = 0;\n\t\t\t\trep(i, 8){\n\t\t\t\t\tint nowy = now.first + dy[i], nowx = now.second + dx[i];\n\t\t\t\t\tif(!hantei(nowy, nowx)) continue;\n\t\t\t\t\tif(board[nowy][nowx] == '.')tmp++;\n\t\t\t\t}\n\t\t\t\tif(tmp >= board[now.first][now.second] - '0'){\n\t\t\t\t\t// printf(\"q2 y:%d  x:%d\\n\", now.first, now.second);\n\t\t\t\t\tmemo.push_back(make_pair(now.first, now.second));\n\t\t\t\t\t// printf(\"mawari\\n\");\n\t\t\t\t\trep(k, 8){//???????????????????????????????????????????????????????????????????\n\t\t\t\t\t\tint ny = now.first + dy[k], nx = now.second + dx[k];\n\t\t\t\t\t\tif(!hantei(ny, nx)) continue;\n\t\t\t\t\t\tif(board[ny][nx] != '.') q1.push(make_pair(ny, nx));\n\t\t\t\t\t\t// printf(\"q1 ny:%d  nx:%d\\n\", ny, nx);\n\t\t\t\t\t}\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//???????????\n\t\trep(k, memo.size()){\n\t\t\tboard[memo[k].first][memo[k].second] = '.';\n\t\t}\n\t\tcnt++;\n\t\t// rep(i, h) cout << board[i] << endl;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> pa;\ntypedef pair<int,pa> pp;\n\nint ary[1010][1010];\nint dy[8]={0,1,1,1,0,-1,-1,-1},dx[8]={1,1,0,-1,-1,-1,0,1};\nint H,W;\n\nint main(){\n\tcin>>H>>W;\n\tchar ch;\n\tqueue<pa> quf;\n\tset<pa> se[2];\n\tfor(int i=1;i<=H;i++){\n\t\tfor(int j=1;j<=W;j++){\n\t\t\tcin>>ch;\n\t\t\tif(ch=='.') ary[i][j]=0;\n\t\t\telse ary[i][j]=ch-'0';\n\t\t\tse[1].insert(pa(i,j));\n\t\t}\n\t}\n\t\n\tint tmx,tmy,now=0,cnt=0,res=0;\n\tquf.push(pa(0,0));\n\tfor(int i=1;;i++){\n\t\tif(quf.empty()){\n\t\t\tres=i-2;\n\t\t\tbreak;\n\t\t}\n\t\twhile(!quf.empty()){\n\t\t\tary[quf.front().first][quf.front().second]=0;\n\t\t\tquf.pop();\n\t\t}\n\t\tse[1-(i&1)].clear();\n\t\tfor(auto it=se[i&1].begin();it!=se[i&1].end();it++){\n\t\t\tif(ary[it->first][it->second]==0) continue;\n\t\t\tcnt=0;\n\t\t\tfor(int j=0;j<8;j++){\n\t\t\t\tif(ary[it->first+dx[j]][it->second+dy[j]]==0){\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ary[it->first][it->second]<=cnt){\n\t\t\t\tquf.push(pa(it->first,it->second));\n\t\t\t\tfor(int j=0;j<8;j++){\n\t\t\t\t\tif((1<=it->first+dx[j])&&(it->first+dx[j]<=H)&&(1<=it->second+dy[j])&&(it->second+dy[j]<=W)) se[1-(i&1)].insert(pa(it->first+dx[j],it->second+dy[j]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<\"\";\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <stdio.h>\n#include <stdlib.h>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <math.h>\n#include <utility>\n#include <set>\n#include <map>\n#define INF 1000000000\n#define rep(i,n) for(int i =0;i<n;i++)\nusing namespace std;\ntypedef long long int ll;\n\n\nint main(){\n    int h,w;\n    cin >>h >> w;\n    vector<int> area(h*w);\n    vector<int> ch(h*w,0);\n    queue<pair<int,int> > lis;\n    rep(i, h){\n        rep(j, w){\n            char hoge;\n            cin >> hoge;\n            if (hoge == '.') {\n                area[i*w+j]=-1;\n                for (int k=-1; k<2; k++) {\n                    for (int l=-1; l<2; l++) {\n                        if(k==0 and l==0) continue;\n                        if (i+k>0 and i+k<h-1 and j+l>0 and j+l<w-1) {\n                            ch[(i+k)*w+j+l]++;\n                        }\n                    }\n                }\n            }else{\n                area[i*w+j]=(int)hoge-(int)'0';\n            }\n        }\n    }\n    rep(i, h){\n        rep(j, w){\n            if (area[i*w+j]!=-1 and ch[i*w+j]>=area[i*w+j]) {\n                lis.push({i,j});\n            }\n        }\n    }\n    int ans = 0;\n    int flag = 1;\n    while (flag > 0) {\n        int si = lis.size();\n        flag = 0;\n        rep(p, si){\n            if (ans==0) ans = 1;\n            int i = lis.front().first;\n            int j = lis.front().second;\n            lis.pop();\n            area[i*w+j]=-1;\n            for (int k=-1; k<2; k++) {\n                for (int l=-1; l<2; l++) {\n                    if(k==0 and l==0) continue;\n                    if (i+k>0 and i+k<h-1 and j+l>0 and j+l<w-1) {\n                        ch[(i+k)*w+j+l]++;\n                        if (area[(i+k)*w+j+l]!=-1 and ch[(i+k)*w+j+l]==area[(i+k)*w+j+l]) {\n                            lis.push({i+k,j+l});\n                            flag++;\n                        }\n                    }\n                }\n            }\n        }\n        if(flag > 0) ans++;\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rrep(i,a,b) for(int i=(a);i<=(b);i++)\n#define P pair<int,int>\nusing namespace std;\n\nint dx[8]={-1,-1,0,1,1,1,0,-1};\nint dy[8]={0,-1,-1,-1,0,1,1,1};\n\nint h,w;\nint a[1002][1002];\nstring s[1002];\n\nint main()\n{\n\tcin>>h>>w;\n\trep(i,h)cin>>s[i];\n\tvector<P> f[2];\n\tint now=0,pre=1,ans=0;\n\tbool flag;\n\trrep(i,1,h-2)\n\t{\n\t\trrep(j,1,w-2)\n\t\t{\n\t\t\trep(k,8)if(s[i+dx[k]][j+dy[k]]=='.')a[i][j]++;\n\t\t\tif(s[i][j]!='.'&&s[i][j]-'0'<=a[i][j])f[now].pb(mp(i,j));\n\t\t}\n\t}\n\twhile(1)\n\t{\n\t\tflag=false;\n\t\tnow=!now;\n\t\tpre=!pre;\n\t\tf[now].clear();\n\t\trep(i,f[pre].size())\n\t\t{\n\t\t\tP p=f[pre][i];\n\t\t\tif(s[p.fi][p.se]!='.'&&s[p.fi][p.se]-'0'<=a[p.fi][p.se])\n\t\t\t{\n\t\t\t\tflag=true;\n\t\t\t\ts[p.fi][p.se]='.';\n\t\t\t\trep(j,8)\n\t\t\t\t{\n\t\t\t\t\tint tx=p.fi+dx[j];\n\t\t\t\t\tint ty=p.se+dy[j];\n\t\t\t\t\tif(tx<=0||tx>=h-1||ty<=0||ty>=w-1)continue;\n\t\t\t\t\ta[tx][ty]++;\n\t\t\t\t\tif(s[tx][ty]!='.'&&s[tx][ty]-'0'==a[tx][ty])f[now].pb(mp(tx,ty));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(flag)ans++;\n\t\telse break;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<stdio.h>\n#include<stack>\nint mp[1002][1002] = { 0 }, mj[1002][1002] = { 0 };\nint main()\n{\n\tint x[8] = { -1,0,1,1,1,0,-1,-1 },m;\n\tint y[8] = { 1,1,1,0,-1,-1,-1,0 };\n\tint i,j,h, w,c=0,g,n=0;\n\tchar a;\n\tcin >> h >> w;\n\tfor (i = 0; i < h; i++)\n\t{\n\t\tfor (j = 0; j < w; j++)\n\t\t{\n\t\t\tcin >> a;\n\t\t\tif (a == '1')\n\t\t\t\tmp[i][j] =1;\n\t\t\tif (a == '2')\n\t\t\t\tmp[i][j] = 2;\n\t\t\tif (a == '3')\n\t\t\t\tmp[i][j] = 3;\n\t\t\tif (a == '4')\n\t\t\t\tmp[i][j] = 4;\n\t\t\tif (a == '5')\n\t\t\t\tmp[i][j] = 5;\n\t\t\tif (a == '6')\n\t\t\t\tmp[i][j] = 6;\n\t\t\tif (a == '7')\n\t\t\t\tmp[i][j] = 7;\n\t\t\tif (a == '8')\n\t\t\t\tmp[i][j] = 8;\n\t\t\tif (a == '9')\n\t\t\t\tmp[i][j] = 9;\n\t\t}\n\t}\n\tg = 0;\n\twhile(1)\n\t{\n\t\t\n\t\tfor (i = 0; i < h; i++)\n\t\t{\n\t\t\tfor (j = 0; j < w; j++)\n\t\t\t{\n\t\t\t\tmj[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < h; i++)\n\t\t{\n\t\t\tfor (j = 0; j < w; j++)\n\t\t\t{\n\t\t\t\tif (mp[i][j] >= 1)\n\t\t\t\t{\n\t\t\t\t\tfor (m = 0; m < 8; m++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (mp[i + y[m]][j + x[m]] == 0)\n\t\t\t\t\t\t\tc++;\n\t\t\t\t\t\tif (mp[i][j] <= c)\n\t\t\t\t\t\t\tmj[i][j] = 1;\n\t\t\t\t\t}\n\t\t\t\t\tc = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < h; i++)\n\t\t{\n\t\t\tfor (j = 0; j < w; j++)\n\t\t\t{\n\t\t\t\tif (mj[i][j] == 1)\n\t\t\t\t\tmp[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t/*for (i = 0; i < h; i++)\n\t\t{\n\t\t\tfor (j = 0; j < w; j++)\n\t\t\t{\n\t\t\t\tcout << mj[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\t\tbool flg = true;\n\t\tfor (i = 0; i < h; i++)\n\t\t{\n\t\t\tfor (j = 0; j < w; j++)\n\t\t\t{\n\t\t\t\tif (mj[i][j] == 0)\n\t\t\t\t\tn++;\n\t\t\t\tif (mj[i][j] != 0) {\n\t\t\t\t\tflg = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (n == h*w || flg)\n\t\t\tbreak;\n\t\tg++;\n\t}\n\tcout<< g << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Sandcastle\n#include <iostream>\n#include <queue>\n#include <set>\n\nusing namespace std;\n\nstatic const int drow[8] = {0, -1, -1, -1, 0, 1, 1, 1};\nstatic const int dcol[8] = {-1, -1, 0, 1, 1, 1, 0, -1};\n\nint main() {\n    int H, W;\n    cin >> H >> W;\n    int S[H + 2][W + 2], T[H + 1][W + 1];\n    for(int i = 0; i < H + 2; i++) {\n        S[i][0] = 0;\n        S[i][W + 1] = 0;\n    }\n    for(int j = 0; j < W + 2; j++) {\n        S[0][j] = 0;\n        S[H + 1][j] = 0;\n    }\n    char c;\n    for(int i = 1; i < H + 1; i++) {\n        for(int j = 1; j < W + 1; j++) {\n            cin >> c;\n            if(c == '.') S[i][j] = 0;\n            else S[i][j] = c - '0';\n        }\n    }\n\n    queue<int> P, Q;\n    set<int> E;\n    for(int i = 1; i < H + 1; i++) {\n        for(int j = 1; j < W + 1; j++) {\n            T[i][j] = 0;\n            for(int k = 0; k < 8; k++) {\n                int si = i + drow[k];\n                int sj = j + dcol[k];\n                if(S[si][sj] == 0) T[i][j]++;\n            }\n            if(S[i][j] != 0 && T[i][j] >= S[i][j]) {\n                P.push(i * W + j);\n                E.insert(i * W + j);\n            }\n        }\n    }\n\n    int cnt = 0;\n    while(!P.empty() || !Q.empty()) {\n        while(!P.empty()) {\n            int i = P.front() / W;\n            int j = P.front() % W;\n            P.pop();\n            S[i][j] = 0;\n            for(int k = 0; k < 8; k++) {\n                int si = i + drow[k];\n                int sj = j + dcol[k];\n                T[si][sj]++;\n                if(S[si][sj] != 0 && T[si][sj] >= S[si][sj] && E.find(si * W + sj) == E.end()) {\n                    Q.push(si * W + sj);\n                    E.insert(si * W + sj);\n                }\n            }\n        }\n        swap(P, Q);\n        cnt++;\n    }\n    \n    cout << cnt << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint main(){\n\t\n\tint H, W;\n\t\n\tcin >> H >> W;\n\t\n\tint ans = 0;\n\t\n\tstring map[1001];\n\t\n\tfor(int i = 0; i < H; i++){\n\t\tcin >> map[i];\n\t}\n\t\n\tqueue<P> que;\n\t\n\tfor(int i = 1; i < H - 1; i++){\n\t\tfor(int j = 1; j < W - 1; j++){\n\t\t\tif(map[i][j] == '.'){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint num = map[i][j] - '0';\n\t\t\tint count = 0;\n\t\t\tfor(int x = -1; x <= 1; x++){\n\t\t\t\tfor(int y = -1; y <= 1; y++){\n\t\t\t\t\tif(x == 0 && y == 0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(map[i + y][j + x] == '.'){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(count >= num){\n\t\t\t\tP p;\n\t\t\t\tp.first = i;\n\t\t\t\tp.second = j;\n\t\t\t\tque.push(p);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint q_size = que.size();\n\t\n\tfor(int i = 0; i < q_size; i++){\n\t\tP p = que.front();\n\t\tque.pop();\n\t\tmap[p.first][p.second] = '.';\n\t\tque.push(p);\n\t}\n\t/*\n\tfor(int i = 0; i < H; i++){\n\t\tcout << map[i] << endl;\n\t}\n\t*/\n\twhile(!que.empty()){\n\t\tans++;\n\t\tqueue<P> que_next;\n\t\twhile(!que.empty()){\n\t\t\tP p = que.front();\n\t\t\tque.pop();\n\t\t\t\n\t\t\tfor(int i = p.first - 1; i <= p.first + 1; i++){\n\t\t\t\tfor(int j = p.second - 1; j <= p.second + 1; j++){\n\t\t\t\t\tif(map[i][j] == '.'){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tint num = map[i][j] - '0';\n\t\t\t\t\tint count = 0;\n\t\t\t\t\tfor(int x = -1; x <= 1; x++){\n\t\t\t\t\t\tfor(int y = -1; y <= 1; y++){\n\t\t\t\t\t\t\tif(x == 0 && y == 0){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(map[i + y][j + x] == '.'){\n\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(count >= num){\n\t\t\t\t\t\tP p2;\n\t\t\t\t\t\tp2.first = i;\n\t\t\t\t\t\tp2.second = j;\n\t\t\t\t\t\tque_next.push(p2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tque = que_next;\n\t\t\n\t\tint q_size = que.size();\n\t\t\n\t\tfor(int i = 0; i < q_size; i++){\n\t\t\tP p = que.front();\n\t\t\tque.pop();\n\t\t\tif(map[p.first][p.second] != '.'){\n\t\t\t\tmap[p.first][p.second] = '.';\n\t\t\t\tque.push(p);\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tcout << map[i] << endl;\n\t\t}\n\t\t*/\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define times(n, i)      uptil(0, n, i)\n#define upto(f, t, i)    for(decltype(t) _##i = (t), i = (f); i <= _##i; i++)\n#define uptil(f, t, i)   for(decltype(t) _##i = (t), i = (f); i < _##i; i++)\n#define downto(f, t, i)  for(decltype(t) _##i = (t), i = (f); i >= _##i; i--)\n#define downtil(f, t, i) for(decltype(t) _##i = (t), i = (f); i > _##i; i--)\n#define unless(c) if(!(c))\n#define until(c) while(!(c))\n#define loop while(true)\n\n#define all(v) v.begin(), v.end()\n#define ln << \"\\n\"\n\nstruct line{};\n\ntemplate<class T> istream& operator>>(istream& in, vector<T>& v) {\n    times(v.capacity(), i) in >> v[i];\n    return in;\n}\n\ntemplate<class T> ostream& operator<<(ostream& out, const vector<T>& v) {\n    times(v.size(), i) out << (i ? \" \" : \"\") << v[i];\n    return out;\n}\n\ntemplate<class T, class...U> typename enable_if<is_same<T, line>::value, string>::type next(istream& in, const U&... args) {\n    string s;\n    getline(in, s, args...);\n    return move(s);\n}\n\ntemplate<class T, class...U> typename enable_if<!is_same<T, line>::value, T>::type next(istream& in, const U&... args) {\n    T t(args...);\n    in >> t;\n    return move(t);\n}\ntemplate<class T, class...U> auto next(const U&... args) -> decltype(next<T>(cin)) {\n    return next<T>(cin, args...);\n}\n\ntemplate<class T> T sum(const vector<T>& v) {\n    T ans = T();\n    for(const T& t : v) ans += t;\n    return ans;\n}\n\ntemplate<class T> T sum(const typename vector<T>::iterator& begin, const typename vector<T>::iterator& end) {\n    T ans = T();\n    for(typename vector<T>::iterator t = begin; t != end; t++) ans += *t;\n    return ans;\n}\n\ntemplate<class T> T min(const vector<T>& v) {\n    return *min_element(v.begin(), v.end());\n}\n\ntemplate<class T> T min(const typename vector<T>::iterator& begin, const typename vector<T>::iterator& end) {\n    return *min_element(begin, end);\n}\n\ntemplate<class T> T max(const vector<T>& v) {\n    return *max_element(v.begin(), v.end());\n}\n\ntemplate<class T> T max(const typename vector<T>::iterator& begin, const typename vector<T>::iterator& end) {\n    return *max_element(begin, end);\n}\n\ntemplate<class T> void uniq(vector<T>& v) {\n    sort(all(v));\n    v.erase(unique(all(v)), v.end());\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    #define eight_loop \\\n        upto(i-1, i+1, k) \\\n            upto(j-1, j+1, l) \\\n                if(0 <= k && k < H && 0 <= l && l < W && (i != k || j != l))\n\n\n    int H = next<int>(), W = next<int>();\n    vector<vector<bool>> broken(H, vector<bool>(W));\n    vector<vector<int>> strength(H, vector<int>(W));\n    vector<pair<int, int>> change_now, change_next, change_real;\n    times(H, i) {\n        times(W, j) {\n            char c = next<char>();\n            broken[i][j] = c == '.';\n            strength[i][j] = c - '0';\n        }\n    }\n    times(H, i)\n        times(W, j)\n            if(broken[i][j])\n                eight_loop\n                    if(!broken[k][l]) change_now.push_back(make_pair(k, l));\n    uniq(change_now);\n\n    int ans = 0;    \n    until(change_now.empty()) {\n        for(auto& p : change_now) {\n            int i = p.first, j = p.second, s = 0;\n            #ifdef debug\n                cout << '(' << i << ',' << j << ')';\n            #endif\n            eight_loop s += broken[k][l];\n            if(s >= strength[i][j]) {\n                change_real.push_back(p);\n                eight_loop\n                    if(!broken[k][l])\n                        change_next.push_back(make_pair(k, l));\n                #ifdef debug\n                    cout << '*';\n                #endif\n            } else {\n                #ifdef debug\n                    cout << ' ';\n                #endif\n            }\n        }        \n        for(auto& p : change_real) broken[p.first][p.second] = true;\n        #ifdef debug\n            cout ln;\n        #endif\n        uniq(change_next);\n        change_now = change_next;\n        change_next.clear();\n        change_real.clear();\n        ans++;\n    }\n\n    cout << ans - 1 ln;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#define FOR(hoge,a) for(hoge=0;hoge<a;hoge++)\nint change;\nint i,j;\nint castle[1002][1002];\nint n,m;\nvoid solve(){\n\tint second[1002][1002];\n\tFOR(i,n){\n\t\tFOR(j,m){\n\t\t\tsecond[i][j]=0;\n\t\t\tif(castle[i][j]!=0){\n\t\t\t\tint u=0;\n\t\t\t\tfor(int k=-1;k<=1;k++){\n\t\t\t\t\tfor(int y=-1;y<=1;y++){\n\t\t\t\t\t\tif(castle[i+y][j+k]==0){\n\t\t\t\t\t\t\tu++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(u>=castle[i][j]){second[i][j]=1;change++;}\n\t\t\t}\n\t\t}\n\t}\n\tFOR(i,n){FOR(j,m){\n\t\tif(second[i][j]==1){castle[i][j]=0;}\n\t}}\n}\n\nint main() {\n\tcin>>n>>m;\n\tFOR(i,n){\n\t\tFOR(j,m){\n\t\t\tchar t;\n\t\t\tcin>>t;\n\t\t\tif(t=='.'){castle[i+1][j+1]=0;}\n\t\t\telse{castle[i+1][j+1]=t-48;}\n\t\t}\n\t}\n\tint ans=0;\n\twhile(1){\n\t\tchange=0;\n\t\tsolve();\n\t\tif(change==0){break;}\n\t\tans++;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\nusing namespace std;\ntypedef pair<int, int> P;\n\nint h, w, ans;\nint castle[1001][1001], times[1001][1001];\nint dx[] = {-1, 0, 1, -1, 1, -1, 0, 1}, dy[] = {-1, -1, -1, 0, 0, 1, 1, 1};\nchar beach[1001][1001];\n\nint main(){\n    cin >> h >> w;\n    for(int i = 0; i < h; i++){\n        cin >> beach[i];\n    }\n\n    queue<P> Q;\n    for(int i = 0; i < h; i++){\n        for(int j = 0; j < w; j++){\n            if(beach[i][j] == '.'){\n                Q.push(P(i, j));\n            } else{\n                castle[i][j] = (int)beach[i][j] - 48;\n            }\n        }\n    }\n\n    while(Q.size()){\n        P p = Q.front();\n        Q.pop();\n        ans = max(ans, times[p.first][p.second]);\n\n        for(int i = 0; i < 8; i++){\n            int y = p.first + dy[i], x = p.second + dx[i];\n            if(y < 0 || y >= h || x < 0 || x >= w){\n                continue;\n            }\n\n            castle[y][x]--;\n            if(castle[y][x] == 0){\n                Q.push(P(y, x));\n                times[y][x] = times[p.first][p.second] + 1;\n            }\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef pair<int,int>P;\n\nchar s[1000][1001];\nint d[1000][1000],cnt[1000][1000];\nint main(){\n\tint h,w;scanf(\"%d%d\",&h,&w);\n\tmemset(d,-1,sizeof(d));\n\trep(i,h)scanf(\"%s\",s[i]);\n\tint Max=0;\n\tqueue<P>que;\n\trep(i,h)rep(j,w){\n\t\tif(s[i][j]=='.')continue;\n\t\tfor(int k=-1;k<=1;k++){\n\t\t\tfor(int l=-1;l<=1;l++){\n\t\t\t\tint nx=i+k,ny=j+l;\n\t\t\t\tif(0<=nx&&nx<h&&0<=ny&&ny<w&&s[nx][ny]=='.')cnt[i][j]++;\n\t\t\t}\n\t\t}\n\t\tif(cnt[i][j]>=s[i][j]-'0'){\n\t\t\td[i][j]=Max=1;que.push(P(i,j));\n\t\t}\n\t}\n\twhile(!que.empty()){\n\t\tP p=que.front();que.pop();\n\t\tfor(int i=-1;i<=1;i++)for(int j=-1;j<=1;j++){\n\t\t\tint x=p.first+i,y=p.second+j;\n\t\t\tif(0<=x&&x<h&&0<=y&&y<w&&s[x][y]!='.'&&d[x][y]==-1){\n\t\t\t\tif(++cnt[x][y]>=s[x][y]-'0'){\n\t\t\t\t\td[x][y]=Max=d[p.first][p.second]+1;que.push(P(x,y));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",Max);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <map>\n#define FLAG -1\nusing namespace std;\ntypedef pair<int,int> P;\nint main(){\n      int h,w,dh[] = {1,1,1,0,-1,-1,-1,0}, dw[] = {1,0,-1,-1,-1,0,1,1},ctn,i,j;\n      int solve = -2 ;\n      cin >> h >> w;\n      queue<P> que,tmp;\n      char d[h][w];\n      bool f[w][h];\n      for(i=0;i<h;i++){\n            for(j=0;j<w;j++)\n            {\n                  cin >> d[i][j];\n                  if('1'<=d[i][j]&&'9'>=d[i][j])\n                        que.push(make_pair(i,j));\n            }\n      }\n\n      que.push(make_pair(FLAG,FLAG));\n      for(;;){\n            solve++;\n            map<P,bool> m;\n            for(i=0;i<h;i++)for(j=0;j<w;j++)f[i][j]=false;\n            for(;;){\n                  //cout << que.size()<<endl;\n                  P p = que.front();\n                  que.pop();\n                  if(p.first==FLAG)\n                  {//cout <<\" break \"<<endl<<endl;\n                  break;\n                  }\n                  ctn = 0;\n                  for(i = 0;i < 8;i++){\n                        if(d[p.first+dh[i]][p.second+dw[i]]=='.')ctn++;\n                  }\n\n                  if(ctn >= d[p.first][p.second]-'0'){\n                        tmp.push(p); \n                        for(j=0;j<8;j++)\n                              if(!f[p.first+dh[j]][p.second+dw[j]]&&d[p.first][p.second]!='.'){\n                                    que.push(make_pair(p.first+dh[j],p.second+dw[j]));\n                                    f[p.first+dh[j]][p.second+dw[j]]=true;\n                              }\n\n                  }\n            }\n            if(tmp.empty())break;\n            while(!tmp.empty())\n            {\n                  d[tmp.front().first][tmp.front().second]='.';\n                  tmp.pop();\n            }\n            /*for(i =0 ;i<h;i++)\n            {\n                  for(j=0;j<w;j++)cout << d[i][j];\n                  cout <<endl;\n            }\n            */\n\n            que.push(make_pair(FLAG,FLAG));\n\n      }\n      cout << solve << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n#define FLAG -1\nusing namespace std;\ntypedef pair<int,int> P;\nint main(){\n      int h,w,dh[] = {1,1,1,0,-1,-1,-1,0}, dw[] = {1,0,-1,-1,-1,0,1,1},ctn,i,j,solve = -1 ;\n      cin >> h >> w;\n      queue<P> que,tmp;\n      char d[h][w];\n      for(i=0;i<h;i++){\n            for(j=0;j<w;j++){\n                  cin >> d[i][j];\n                  if('1'<=d[i][j]&&'9'>=d[i][j])\n                        que.push(make_pair(i,j));\n            }\n      }\n      que.push(make_pair(FLAG,FLAG));\n      for(;;){\n            solve++;\n            map<P,bool> m;\n            for(;;){\n                  P p = que.front();\n                  que.pop();\n                  if(p.first==FLAG)break;\n                  if(d[p.first][p.second]=='.')continue;\n                  ctn = 0;\n                  for(i = 0;i < 8;i++)if(d[p.first+dh[i]][p.second+dw[i]]=='.')ctn++;\n                  if(ctn >= d[p.first][p.second]-'0'){\n                        tmp.push(p);\n                        for(j=0;j<8;j++)\n                              if(m.count(make_pair(p.first+dh[j],p.second+dw[j]))==0){\n                                    que.push(make_pair(p.first+dh[j],p.second+dw[j]));\n                                    m[make_pair(p.first+dh[j],p.second+dw[j])]=true;\n                              }\n                  }\n            }\n            if(tmp.empty())break;\n            while(!tmp.empty()){\n                  d[tmp.front().first][tmp.front().second]='.';\n                  tmp.pop();\n            }\n            que.push(make_pair(FLAG,FLAG));\n      }\n      cout << solve << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nstruct k{\n\tint x,y;\n};\nint map[1003][1003],b[1001][2],co[1001][2];\nint main(){\n\tint X,Y,c,cnt=0,longer,crash,dx[8]={-1,0,1,-1,1,-1,0,1},dy[8]={1,1,1,0,0,-1,-1,-1},i,i2,ix,iy,cc=0,tf,ccc;\n\tk ii;\n\tchar d;\n\tqueue<k> Q;\n\tcin>>Y>>X;\n\tfor(i=1;i<=Y;i++){\n\t\tfor(i2=1;i2<=X;i2++){\n\t\t\tcin>>d;\n\t\t\tswitch (d){\n\t\t\t\tcase '.':\n\t\t\t\t\tmap[i2][i]=0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '1':\n\t\t\t\t\tmap[i2][i]=1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '2':\n\t\t\t\t\tmap[i2][i]=2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '3':\n\t\t\t\t\tmap[i2][i]=3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '4':\n\t\t\t\t\tmap[i2][i]=4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '5':\n\t\t\t\t\tmap[i2][i]=5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '6':\n\t\t\t\t\tmap[i2][i]=6;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '7':\n\t\t\t\t\tmap[i2][i]=7;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '8':\n\t\t\t\t\tmap[i2][i]=8;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '9':\n\t\t\t\t\tmap[i2][i]=9;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tc=1;\n\tfor(i=1;i<=Y;i++){\n\t\tfor(i2=1;i2<=X;i2++){\n\t\t\tcrash=0;\n\t\t\tif(map[i2][i]!=0){\n\t\t\t\tfor(int i3=0;i3<8;i3++)if(map[i2+dx[i3]][i+dy[i3]]==0)crash++;\n\t\t\t\tif(map[i2][i]<=crash){\n\t\t\t\t\tb[c][0]=i2;\n\t\t\t\t\tb[c][1]=i;\n\t\t\t\t\tc++;\n\t\t\t\t\tii.x=i2;\n\t\t\t\t\tii.y=i;\n\t\t\t\t\tQ.push(ii);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\twhile(1){\n\t\tif(Q.empty()){\n\t\t\tbreak;\n\t\t}\n\t\telse{\n\t\t\tcnt++;\n\t\t}\n\t\tlonger=Q.size();\n\t\tfor(i=1;!Q.empty();i++){\n\t\t\tii=Q.front();\n\t\t\tb[i][0]=ii.x;\n\t\t\tb[i][1]=ii.y;\n\t\t\tmap[ii.x][ii.y]=0;\n\t\t\tQ.pop();\n\t\t}\n\t\tfor(i=0;i<=X*Y;i++){\n\t\t\tco[i][0]=0;\n\t\t\tco[i][1]=0;\n\t\t}\n\t\tcout<<longer<<endl;\n\t\tccc=0;\n\t\tfor(i=1;i<=longer;i++){\n\t\t\tfor(i2=0;i2<8;i2++){\n\t\t\t\tix=b[i][0]+dx[i2];\n\t\t\t\tiy=b[i][1]+dy[i2];\n\t\t\t\tcc++;\n\t\t\t\tcrash=0;\n\t\t\t\ttf=0;\n\t\t\t\tfor(int www=0;co[www][0]!=0;www++)if(co[www][0]==ix&&co[www][1]==iy)tf=1;\n\t\t\t\tif(map[ix][iy]!=0&&tf==0){\n\t\t\t\t\t\tco[ccc][0]=ix;\n\t\t\t\t\t\tco[ccc][1]=iy;\n\t\t\t\t\t\tccc++;\n\t\t\t\t\tfor(int i3=0;i3<8;i3++){\n\t\t\t\t\t\tif(map[ix+dx[i3]][iy+dy[i3]]==0){\n\t\t\t\t\t\t\tcrash++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(map[ix][iy]<=crash){\n\t\t\t\t\t\tii.x=ix;\n\t\t\t\t\t\tii.y=iy;\n\t\t\t\t\t\tQ.push(ii);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<cnt<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\n#include<iostream>\n\n#include<algorithm>\n\n#include<queue>\n\n#define REP(i,n) for(int i=0;i<(n);i++)\n\n#define RREP(i,n) for(int i=(n)-1;i>=0;i++)\n\nusing namespace::std;\n\ntypedef pair<int,int> P;\n\ntypedef pair<P,int> PP;\n\nqueue <PP> q;//width,height,cost\n\n\n\n\n\nbool judge(int,int);\n\nvoid solve();\n\nvoid loop();\n\n\n\nint h,w,map[2000][2000]={0},ans=0;//\n\n\n\nint main(){\n\n\tchar c;\n\n\tcin>>h>>w;\n\n\tREP(j,h)REP(i,w){\n\n\t\tcin>>c;\n\n\t\tif(c=='.')map[i][j]=0;\n\n\t\telse map[i][j]=int(c)-48;\n\n\t}\n\n\tsolve();\n\n\tloop();\n\n\t\n\n//\tREP(j,h){REP(i,w){\n\n//\t\tprintf(\"%d\",map[i][j]);\n\n//\t}printf(\"\\n\");}\n\n\tcout<<ans<<endl;\n\n}\n\n\n\nbool judge(int i,int j){\n\n\tint v=0;\n//\tcout<<\"hoge\"<<i<<\":\"<<j<<endl;\n\n\tif(map[i][j]==0)return false;\n\n\tREP(a,3)REP(b,3)if(map[i+a-1][j+b-1]==0&&!(a==1&&b==1))v++;\n//\tcout<<v<<endl;\n\n\tif(map[i][j]>v)return false;\n\n\telse return true;\n\n}\n\n\n\n\n\nvoid solve(){\n\n\tREP(j,w)REP(i,h){\n\n\t\tif(judge(i,j)==true){\n\n\t\t\tq.push(PP(P(i,j),1));\n\n\t\t}\n\n\t}\t\n\n}\n\n\n\nvoid loop(){\n\nwhile(q.size()){\n\n\tPP p = q.front();q.pop();\n\n\t\n\n\tint k=p.second,i=p.first.first,j=p.first.second;\n\n//\tcout<<q.size()<<\"[\"<<i<<\",\"<<j<<\"]cost:\"<<k<<endl;\n\tmap[i][j]=0;\n\n//\tif(judge(i,j)==true){\n\n\t\tREP(a,3)REP(b,3)if(map[i+a-1][j+b-1]!=0&&judge(i+a-1,j+b-1)==true&&!(a==1&&b==1)){\n\n\t\t\tq.push(PP(P(i+a-1,j+b-1),(k+1)));\n\n\t\t\tans=max(k+1,ans);\n\n//\t\t\tcout<<\"pushed!\"<<\"[\"<<i+a-1<<\",\"<<j+b-1<<\"]\"<<endl;\n//\t\t\tmap[i+a-1][j+b-1]=0;\n\n\t\t\t\n\n\t\t}\n\n//\t}\t\n\n//\tREP(j,h){REP(i,w){\n\n//\t\tprintf(\"%d\",map[i][j]);\n\n//\t}printf(\"\\n\");}\n\n\t\n\n}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n#define INF 2000000000\n\n#define MAX_H 1050\n#define MAX_W 1050\n\nint H, W;\n\nchar sand[MAX_H][MAX_W];\n\nint dp[MAX_H][MAX_W];\n\nconst int dx[8] = { -1, -1, -1, 0, 0, 1, 1, 1 };\nconst int dy[8] = { -1, 0, 1, -1, 1, -1, 0, 1 };\n\nbool dfs[MAX_H][MAX_W];\n\nvoid memo(int x, int y)\n{\n\tdfs[y][x] = true;\n\n\tif (dp[y][x] > 1 && x > 0 && x < W - 1 && y > 0 && y < H - 1)\n\t{\n\t\tint temp[8];\n\n\t\tfor (int dir = 0; dir < 8; dir++)\n\t\t{\n\t\t\ttemp[dir] = dp[y + dy[dir]][x + dx[dir]];\n\t\t}\n\n\t\tsort(temp, temp + 8);\n\n\t\tif (sand[y][x] != '9')\n\t\t{\n\t\t\tif (temp[sand[y][x] - 49] != INF)\n\t\t\t{\n\t\t\t\tdp[y][x] = temp[sand[y][x] - 49] + 1;\n\t\t\t}\n\n\t\t\tif (dp[y][x] < INF)\n\t\t\t{\n\t\t\t\tfor (int dir = 0; dir < 8; dir++)\n\t\t\t\t{\n\t\t\t\t\tif (dfs[y + dy[dir]][x + dx[dir]] == false)\n\t\t\t\t\t{\n\t\t\t\t\t\tmemo(x + dx[dir], y + dy[dir]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tmemset(dp, 0, sizeof(dp));\n\n\tcin >> H >> W;\n\n\tfor (int i = 0; i < H; i++)\n\t{\n\t\tfor (int j = 0; j < W; j++)\n\t\t{\n\t\t\tcin >> sand[i][j];\n\n\t\t\tif (sand[i][j] != '.')\n\t\t\t{\n\t\t\t\tdp[i][j] = INF;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 1; i < H - 1; i++)\n\t{\n\t\tfor (int j = 1; j < W - 1; j++)\n\t\t{\n\t\t\tmemset(dfs, false, sizeof(dfs));\n\n\t\t\tmemo(j, i);\n\t\t}\n\t}\n\n\tint maxdepth = 0;\n\n\tfor (int i = 1; i < H - 1; i++)\n\t{\n\t\tfor (int j = 1; j < W - 1; j++)\n\t\t{\n\t\t\tif (dp[i][j] < INF)\n\t\t\t{\n\t\t\t\tmaxdepth = max(dp[i][j], maxdepth);\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << maxdepth << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <string>\nusing namespace std;\nstruct nami {\n\n  int x,y;\n  /*\n  nami(int a,int b){\n    x=a;\n    y=b;\n  }\n  */\n};\n\nqueue <nami> Q;\nint h,w;\nstring str[1000];\nint map[1000][1000];\n\n\nint main() {\n\n  cin >> h >> w;\n\n  for(int i=0;i<h;i++) {\n    cin >> str[i];\n    for(int j=0;j<w;j++) {\n      if(str[i][j] == '.') {\n\tmap[i][j] = -1;\n\tQ.push((nami){j,i});\n      }\n      else map[i][j] = str[i][j] - '0';\n\n    }\n  }\n\n  int dx[8] = {1,1,1,0,0,-1,-1,-1};\n  int dy[8] = {-1,0,1,-1,1,-1,0,1};\n\n  Q.push((nami){-1,-1});\n\n    nami t;\n    int count = 0;\n  while(!Q.empty()) {\n\n    t  = Q.front();\n    Q.pop();\n\n    if(t.x == -1 && t.y == -1){\n      if(! Q.empty()){\n      Q.push(t);\n      count++;\n      }\n     \n      continue;\n    } \n\n   for(int i=0;i<8;i++) {\n\n     if(t.x+dx[i] >=0 && t.x+dx[i] < w && t.y+dy[i] >=0 && t.y+dy[i] < h) {\n       if(map[t.y+dy[i]][t.x+dx[i]] >= 1 ){\n\t map[t.y+dy[i]][t.x+dx[i]]--;\n\t if(map[t.y+dy[i]][t.x+dx[i]] == 0)\n\t   Q.push((nami){t.x+dx[i],t.y+dy[i]});\n       }\n     }   \n   }\n   \n  }\n  \n  cout << count << endl;\n  \n  \n  return 0;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<bits//stdc++.h>\n#include<functional>\nusing namespace std;\nint main() {\n\tint a[1000][1000],g[1000][1000];\n\tint h,w;\n\tcin>>h>>w;\n\tfor(int i=0;i<h;i++){\n\t\tstring s;\n\t\tcin>>s;\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(s[j]=='.') a[i][j]=0;\n\t\t\telse a[i][j]=(int)s[j]-'0';\n\t\t}\n\t}\n\tint sum=0,sum2=1;\n\twhile(sum2){\n\t\tsum2=0;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tg[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(a[i][j]==0){\n\t\t\t\t\tfor(int x=-1;x<=1;x++){\n\t\t\t\t\t\tfor(int y=-1;y<=1;y++){\n\t\t\t\t\t\t\tif(i+x<h&&i+x>=0&&j+y<w&&j+y>=0)g[i+x][j+y]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(a[i][j]!=0&&g[i][j]>=a[i][j]){\n\t\t\t\t\tsum2++;\n\t\t\t\t\ta[i][j]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsum++;\n\t}\n\tcout<<--sum<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\nusing namespace std;\n\nint main()\n{\n  int h,w;\n  scanf(\"%d%d\",&h,&w);\n  static char M[1000][1001];\n  for(int i=0;i<h;i++){\n    scanf(\"%s\",M[i]);\n  }\n  static int K[1000][1001]={0};\n  int dx[8]={1,1,1,0,0,-1,-1,-1},dy[8]={-1,0,1,-1,1,-1,0,1};\n  queue<pair<int,int> > Q[2];\n  bool b=0;\n  for(int i=1;i<h-1;i++){\n    for(int j=1;j<w-1;j++){\n      for(int v=0;v<8;v++){\n\tint x=i+dx[v],y=j+dy[v];\n\tif(M[x][y]=='.'){\n\t  K[i][j]++;\n\t}\n      }\n      if(M[i][j]!='.'&&K[i][j]>=M[i][j]-'0'){\n\tQ[b].push(make_pair(i,j));\n      }\n    }\n  }\n  int t=0;\n  while(!Q[b].empty()){\n    while(!Q[b].empty()){\n      pair<int,int> p=Q[b].front();\n      Q[b].pop();\n      int i=p.first,j=p.second;\n      for(int v=0;v<8;v++){\n\tint x=i+dx[v],y=j+dy[v];\n\tK[x][y]++;\n\tif(M[x][y]!='.'&&K[x][y]==M[x][y]-'0'){\n\t  Q[!b].push(make_pair(x,y));\n\t}\n      }\n    }\n    t++;\n    b=!b;\n  }\n  printf(\"%d\\n\",t);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n#define INF 2000000000\n\n#define MAX_H 1050\n#define MAX_W 1050\n\nint H, W;\n\nchar sand[MAX_H][MAX_W];\n\nint dp[MAX_H][MAX_W];\n\nconst int dx[8] = { -1, -1, -1, 0, 0, 1, 1, 1 };\nconst int dy[8] = { -1, 0, 1, -1, 1, -1, 0, 1 };\n\nbool dfs[MAX_H][MAX_W];\n\nvoid memo(int x, int y)\n{\n\tdfs[y][x] = true;\n\n\tif (dp[y][x] > 1 && x > 0 && x < W - 1 && y > 0 && y < H - 1)\n\t{\n\t\tint temp[8];\n\n\t\tfor (int dir = 0; dir < 8; dir++)\n\t\t{\n\t\t\ttemp[dir] = dp[y + dy[dir]][x + dx[dir]];\n\t\t}\n\n\t\tsort(temp, temp + 8);\n\n\t\tif (sand[y][x] != '9')\n\t\t{\n\t\t\tif (temp[sand[y][x] - 49] != INF)\n\t\t\t{\n\t\t\t\tdp[y][x] = temp[sand[y][x] - 49] + 1;\n\t\t\t}\n\n\t\t\tif (dp[y][x] < INF)\n\t\t\t{\n\t\t\t\tfor (int dir = 0; dir < 8; dir++)\n\t\t\t\t{\n\t\t\t\t\tif (dfs[y + dy[dir]][x + dx[dir]] == false)\n\t\t\t\t\t{\n\t\t\t\t\t\tmemo(x + dx[dir], y + dy[dir]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tmemset(dp, 0, sizeof(dp));\n\n\tcin >> H >> W;\n\n\tfor (int i = 0; i < H; i++)\n\t{\n\t\tfor (int j = 0; j < W; j++)\n\t\t{\n\t\t\tcin >> sand[i][j];\n\n\t\t\tif (sand[i][j] != '.')\n\t\t\t{\n\t\t\t\tdp[i][j] = INF;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 1; i < H - 1; i++)\n\t{\n\t\tfor (int j = 1; j < W - 1; j++)\n\t\t{\n\t\t    for(int i1 = 0; i1 < H; i1++)\n\t\t    {\n\t\t        for(int j1 = 0; j1 < W; j1++)\n\t\t        {\n                    dfs[i1][j1] = false;\n\t\t        }\n\t\t    }\n\t\t    \n\t\t\tmemo(j, i);\n\t\t}\n\t}\n\n\tint maxdepth = 0;\n\n\tfor (int i = 1; i < H - 1; i++)\n\t{\n\t\tfor (int j = 1; j < W - 1; j++)\n\t\t{\n\t\t\tif (dp[i][j] < INF)\n\t\t\t{\n\t\t\t\tmaxdepth = max(dp[i][j], maxdepth);\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << maxdepth << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nint H, W;\nchar sand_before[1123][1123], sand_after[1123][1123];\nbool broken_cou = false;\nint ans = 0;\n\nint main(void) {\n\tscanf(\"%d%d\", &H, &W);\n\tfor (int i = 0; i < H; ++i) { scanf(\"%s\", &sand_before[i]); }\n\n\tfor (int i = 0; i < H; ++i) { for (int j = 0; j < W; ++j) { sand_after[i][j] = sand_before[i][j]; } }\n\twhile (true) {\n\t\tfor (int i = 1; i < H - 1; ++i) {\n\t\t\tfor (int j = 1; j < W - 1; ++j) {\n\t\t\t\tif (sand_before[i][j] != '.') {\n\t\t\t\t\tint wave = 0;\n\t\t\t\t\tfor (int x = i - 1; x <= i + 1; ++x) {\n\t\t\t\t\t\tfor (int y = j - 1; y <= j + 1; ++y) {\n\t\t\t\t\t\t\tif (sand_before[x][y] == '.') { wave++; }\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (sand_before[i][j] - '0' <= wave) { sand_after[i][j] = '.'; broken_cou = true; }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (broken_cou == false) { break; }\n\t\tfor (int i = 0; i < H; ++i) { for (int j = 0; j < W; ++j) { sand_before[i][j] = sand_after[i][j]; } }\n\t\tans++;\n\t\tbroken_cou = false;\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstring>\nusing namespace std;\n\nint main(){\n\tstring S;\n\tint n,m,t,sum,a;\n\tsum=0;\n\tint x[1200][1200];\n\tbool y[1200][1200];\n\tbool z[1200][1200];\n\tmemset(x,0,sizeof(x));\n\tmemset(z,false,sizeof(z));\n\tchar T[10]={'.','1','2','3','4','5','6','7','8','9'};\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>S;\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tfor(int k=0;k<10;k++){\n\t\t\t\tif(S[j-1]==T[k]){\n\t\t\t\t\tx[i][j]=k;\n\t\t\t\t\tif(k==0){\n\t\t\t\t\t\tfor(int l=-1;l<=1;l++){\n\t\t\t\t\t\t\tfor(int o=-1;o<=1;o++){\n\t\t\t\t\t\t\t\tz[i+l][j+o]=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\twhile(true){\n\t\tt=0;\n\t\tsum++;\n\t\tmemset(y,false,sizeof(y));\n\t\tfor(int i=2;i<n;i++){\n\t\t\tfor(int j=2;j<m;j++){\n\t\t\t\tif(x[i][j]>=1 && z[i][j]==true){\n\t\t\t\t\ta=0;\n\t\t\t\t\tfor(int k=-1;k<=1;k++){\n\t\t\t\t\t\tfor(int l=-1;l<=1;l++){\n\t\t\t\t\t\t\tif(k!=0 || l!=0){\n\t\t\t\t\t\t\t\tif(x[i+k][j+l]==0){\n\t\t\t\t\t\t\t\t\ta++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(a>=x[i][j]){\n\t\t\t\t\t\ty[i][j]=true;\n\t\t\t\t\t\tt++;\n\t\t\t\t\t\tfor(int l=-1;l<=1;l++){\n\t\t\t\t\t\t\tfor(int o=-1;o<=1;o++){\n\t\t\t\t\t\t\t\tz[i+l][j+o]=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\t\n\t\t}\n\t\tif(t==0){\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i=2;i<n;i++){\n\t\t\tfor(int j=2;j<m;j++){\n\t\t\t\tif(y[i][j]==true){\n\t\t\t\t\tx[i][j]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<sum-1<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <queue>\n#include <set>\n#include <algorithm>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nstring board[1001];\nint dx[8] = {0, 1, 1, 1, 0, -1, -1, -1};\nint dy[8] = {1, 1, 0, -1, -1, -1, 0, 1};\nint h, w;\nbool hantei(int y, int x){\n\tif(0 <= y && y < h && 0 <= x && x < w) return true;\n\telse return false;\n}\n\nint main(void){\n\tcin >> h >> w;\n\trep(i, h) cin >> board[i];\n\tqueue<pair<int, int> > q1, q2;\n\trep(i, h)rep(j, w){\n\t\tif(board[i][j] != '.') q1.push(make_pair(i, j));\n\t}\n\n\tint ans = -1, cnt = 0, nowy, nowx;\n\tbool flag = true;\n\twhile(flag){\n\t\t// printf(\"cnt %d\\n\", cnt);\n\t\tflag = false; ans++;\n\t\tvector<pair<int, int> > memo;//?????????????????????????????????????????????????????????\n\t\tset<pair<int, int> > s;\n\t\tif(cnt % 2 == 0){\n\t\t\twhile(!q1.empty()){//q1??????????????\n\t\t\t\tpair<int, int> now = q1.front(); q1.pop();\n\t\t\t\tif(board[now.first][now.second] == '.') continue;\n\t\t\t\tint tmp = 0;\n\t\t\t\trep(i, 8){\n\t\t\t\t\tint nowy = now.first + dy[i], nowx = now.second + dx[i];\n\t\t\t\t\tif(!hantei(nowy, nowx)) continue;\n\t\t\t\t\tif(board[nowy][nowx] == '.')tmp++;\n\t\t\t\t}\n\t\t\t\tif(tmp >= board[now.first][now.second] - '0'){\n\t\t\t\t\t// printf(\"q1 y:%d  x:%d\\n\", now.first, now.second);\n\t\t\t\t\tmemo.push_back(make_pair(now.first, now.second));\n\t\t\t\t\t// printf(\"mawari\\n\");\n\t\t\t\t\trep(k, 8){//???????????????????????????????????????????????????????????????????\n\t\t\t\t\t\tint ny = now.first + dy[k], nx = now.second + dx[k];\n\t\t\t\t\t\tif(!hantei(ny, nx)) continue;\n\t\t\t\t\t\tif(board[ny][nx] != '.'){\n\t\t\t\t\t\t\t// q2.push(make_pair(ny, nx));\n\t\t\t\t\t\t\ts.insert(make_pair(ny, nx));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// printf(\"q2 ny:%d  nx:%d\\n\", ny, nx);\n\t\t\t\t\t}\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\twhile(!q2.empty()){//q2??????????????\n\t\t\t\tpair<int, int> now = q2.front(); q2.pop();\n\t\t\t\tif(board[now.first][now.second] == '.') continue;\n\t\t\t\tint tmp = 0;\n\t\t\t\trep(i, 8){\n\t\t\t\t\tint nowy = now.first + dy[i], nowx = now.second + dx[i];\n\t\t\t\t\tif(!hantei(nowy, nowx)) continue;\n\t\t\t\t\tif(board[nowy][nowx] == '.')tmp++;\n\t\t\t\t}\n\t\t\t\tif(tmp >= board[now.first][now.second] - '0'){\n\t\t\t\t\t// printf(\"q2 y:%d  x:%d\\n\", now.first, now.second);\n\t\t\t\t\tmemo.push_back(make_pair(now.first, now.second));\n\t\t\t\t\t// printf(\"mawari\\n\");\n\t\t\t\t\trep(k, 8){//???????????????????????????????????????????????????????????????????\n\t\t\t\t\t\tint ny = now.first + dy[k], nx = now.second + dx[k];\n\t\t\t\t\t\tif(!hantei(ny, nx)) continue;\n\t\t\t\t\t\tif(board[ny][nx] != '.'){\n\t\t\t\t\t\t\t// q1.push(make_pair(ny, nx));\n\t\t\t\t\t\t\ts.insert(make_pair(ny, nx));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// printf(\"q1 ny:%d  nx:%d\\n\", ny, nx);\n\t\t\t\t\t}\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//???????????\n\t\trep(k, memo.size()){\n\t\t\tboard[memo[k].first][memo[k].second] = '.';\n\t\t}\n\t\tif(cnt % 2 == 0){\n\t\t\tfor(auto x : s) q2.push(make_pair(x.first, x.second));\n\t\t}else{\n\t\t\tfor(auto x : s) q1.push(make_pair(x.first, x.second));\n\t\t}\n\t\tcnt++;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<bits//stdc++.h>\n#include<functional>\nusing namespace std;\nstruct P{\n\tint x,y;\n};\nint main() {\n\tint a[1000][1000],g[1000][1000];\n\tint h,w;\n\tcin>>h>>w;\n\tfor(int i=0;i<h;i++){\n\t\tstring s;\n\t\tcin>>s;\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(s[j]=='.') a[i][j]=0;\n\t\t\telse a[i][j]=(int)s[j]-'0';\n\t\t}\n\t}\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++)g[i][j]=0;\n\t}\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(a[i][j]==0){\n\t\t\t\tfor(int x=-1;x<=1;x++){\n\t\t\t\t\tfor(int y=-1;y<=1;y++) {\n\t\t\t\t\t\tif(i+x<h&&i+x>=0&&j+y<w&&j+y>=0){\n\t\t\t\t\t\t\tg[i+x][j+y]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint sum=0;\n\tbool l=true;\n\twhile(l){\n\t\tl=false;\n\t\tvector<P>p;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(g[i][j]>=a[i][j]&&a[i][j]!=0){\n\t\t\t\t\ta[i][j]=0;\n\t\t\t\t\tp.push_back(P{i,j});\n\t\t\t\t\tl=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<(int)p.size();i++){\n\t\t\tfor(int x=-1;x<=1;x++){\n\t\t\t\tfor(int y=-1;y<=1;y++){\n\t\t\t\t\t g[p[i].x+x][p[i].y+y]++;\n\t\t\t\t }\n\t\t\t}\n\t\t}\n\t\tsum++;\n\t}\n\tcout<<--sum<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\ntypedef pair< int, int > pii;\n\nconst int dx[8] = {0,1,1,1,0,-1,-1,-1}, dy[8] = {-1,-1,0,1,1,1,0,-1};\n\nint H, W, counter[1010][1010];\nstring grid[1010];\n\nint main() {\n\tcin >> H >> W;\n\tfor_(i,0,H) cin >> grid[i];\n\t\n\tqueue< pii > cur_que;\n\t\n\tfor_(y,0,H) for_(x,0,W) {\n\t\tcounter[y][x] = -1;\n\t\tif (grid[y][x] == '.') continue;\n\t\tcounter[y][x] = grid[y][x] - '0';\n\t\t\n\t\tfor_(d,0,8) {\n\t\t\tint xx = x + dx[d], yy = y + dy[d];\n\t\t\tif (grid[yy][xx] == '.') --counter[y][x];\n\t\t}\n\t\t\n\t\tif (counter[y][x] <= 0) cur_que.push(pii(x, y));\n\t}\n\t\n\tqueue< pii > nxt_que;\n\t\n\tint ans = 0;\n\t\n\twhile (!cur_que.empty()) {\n\t\twhile (!cur_que.empty()) {\n\t\t\tpii p = cur_que.front(); cur_que.pop();\n\t\t\tint x = p.first, y = p.second;\n\t\t\tassert(grid[y][x] != '.');\n\t\t\tgrid[y][x] = '.';\n\t\t\t\n\t\t\tfor_(d,0,8) {\n\t\t\t\tint xx = x + dx[d], yy = y + dy[d];\n\t\t\t\tif (grid[yy][xx] == '.') continue;\n\t\t\t\t--counter[yy][xx];\n\t\t\t\tif (counter[yy][xx] == 0) nxt_que.push(pii(xx, yy));\n\t\t\t}\n\t\t}\n\t\t\n\t\t++ans;\n\t\tswap(cur_que, nxt_que);\n\t}\n\t\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <string>\n#include <iostream>\nusing namespace std;\nstruct state { int x, y; };\nint dx[] = { 0, 1, 1, 1, 0, -1, -1, -1 };\nint dy[] = { 1, 1, 0, -1, -1, -1, 0, 1 };\nint H, W, dist[1009][1009]; string s[1009];\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> H >> W;\n\tqueue<state> que;\n\tfor (int i = 0; i < H; i++) {\n\t\tcin >> s[i];\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (s[i][j] == '.') {\n\t\t\t\tdist[i][j] = 0;\n\t\t\t\tque.push(state{ i, j });\n\t\t\t}\n\t\t\telse dist[i][j] = -1;\n\t\t}\n\t}\n\tint ret = 0;\n\twhile (!que.empty()) {\n\t\tstate u = que.front(); que.pop();\n\t\tret = max(ret, dist[u.x][u.y]);\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tint tx = u.x + dx[i], ty = u.y + dy[i];\n\t\t\tif (0 <= tx && tx < H && 0 <= ty && ty < W && dist[tx][ty] == -1) {\n\t\t\t\tvector<int> v;\n\t\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\t\tint rx = tx + dx[j], ry = ty + dy[j];\n\t\t\t\t\tif (0 <= rx && rx < H && 0 <= ry && ry < W && dist[rx][ry] != -1) {\n\t\t\t\t\t\tv.push_back(dist[rx][ry]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsort(v.begin(), v.end());\n\t\t\t\tif (v.size() >= s[tx][ty] - 48) {\n\t\t\t\t\tdist[tx][ty] = v[s[tx][ty] - 49] + 1;\n\t\t\t\t\tque.push(state{ tx, ty });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <utility>\n\n#define REP(i, a, b) for (int i = int(a); i < int(b); i++)\n#ifdef _DEBUG_\n#define dump(val) cerr << __LINE__ << \":\\t\" << #val << \" = \" << (val) << endl\n#else\n#define dump(val)\n#endif\n\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> P;\n\ntemplate<typename T>\nvector<T> make_v(size_t a, T b) {\n    return vector<T>(a, b);\n}\n\ntemplate<typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v(ts...))>(a, make_v(ts...));\n}\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int h, w;\n    cin >> h >> w;\n    auto mp = make_v(h + 2, w + 2, '#');\n    REP(i, 1, h + 1) {\n        REP(j, 1, w + 1) {\n            cin >> mp[i][j];\n        }\n    }\n    queue<P> q;\n    auto mpcopy = mp;\n    REP(i, 1, h + 1) {\n        REP(j, 1, w + 1) {\n            if (mp[i][j] == '.') continue;\n            int n = mp[i][j] - '0';\n            REP(a, -1, 2) {\n                REP(b, -1, 2) {\n                    if (mp[i + a][j + b] == '#') continue;\n                    n -= (mp[i + a][j + b] == '.');\n                }\n            }\n            if (n <= 0) {\n                mpcopy[i][j] = '.';\n                q.emplace(j, i);\n            } else {\n                mpcopy[i][j] = n + '0';\n            }\n        }\n    }\n    mp = mpcopy;\n    int ans = 0;\n    while (q.size()) {\n        queue<P> qcopy;\n        ans++;\n        while (q.size()) {\n            int x = q.front().first, y = q.front().second;\n            q.pop();\n            REP(a, -1, 2) {\n                REP(b, -1, 2) {\n                    if (a == 0 && b == 0) {\n                        continue;\n                    }\n                    if (mp[y + a][x + b] == '#' || mp[y + a][x + b] == '.') continue;\n                    mp[y + a][x + b]--;\n                    if (mp[y + a][x + b] <= '0') {\n                        mp[y + a][x + b] = '.';\n                        qcopy.emplace(x + b, y + a);\n                    }\n                }\n            }\n        }\n        while (qcopy.size()) {\n            int x = qcopy.front().first, y = qcopy.front().second;\n            qcopy.pop();\n            mp[y][x] = '.';\n            q.emplace(x, y);\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nint main() {\n\tchar map[1002][1002];\n\tint H, W;\n\tcin >> H >> W;\n\tfor (int i = 0; i <= W + 1; ++i) {\n\t\tmap[i][0] = '.';\n\t\tmap[i][H + 1] = '.';\n\t}\n\tfor (int i = 0; i <= H + 1; ++i) {\n\t\tmap[0][i] = '.';\n\t\tmap[W + 1][i] = '.';\n\t}\n\tfor (int y = 1; y <= H; ++y) {\n\t\tfor (int x = 1; x <= W; ++x) {\n\t\t\tcin >> map[x][y];\n\t\t}\n\t}\n\tqueue<pair<short,short> > stock;\n\tshort movex[]{ 0,1,1,1,0,-1,-1,-1 }, movey[]{ 1,1,0,-1,-1,-1,0,1 };\n\tfor (int y = 1; y <= H; ++y) {\n\t\tfor (int x = 1; x <= W; ++x) {\n\t\t\tint count=0;\n\t\t\tif (map[x][y] != '.'&&map[x][y] != '?') {\n\t\t\t\tfor (int i = 0; i < 8; ++i) {\n\t\t\t\t\tif (map[x + movex[i]][y + movey[i]] == '.') {\n\t\t\t\t\t\t++count;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ('0' >= (map[x][y] = map[x][y] - count)) {\n\t\t\t\t\tstock.push(pair<short, short>(x, y));\n\t\t\t\t\tmap[x][y] = '?';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint answer = 0;\n\tpair<short, short> dummy;\n\tqueue<pair<short,short> > date;\n\twhile (!stock.empty()) {\n\t\t++answer;\n\t\twhile (!stock.empty()) {\n\t\t\tdummy = stock.front();\n\t\t\tstock.pop();\n\t\t\tfor (int i = 0; i < 8; ++i) {\n\t\t\t\tif (map[dummy.first + movex[i]][dummy.second + movey[i]] != '.'&&map[dummy.first+movex[i]][dummy.second+movey[i]]!='?') {\n\t\t\t\t\tif (--map[dummy.first + movex[i]][dummy.second + movey[i]] == '0') {\n\t\t\t\t\t\tdate.push(pair<short, short>(dummy.first + movex[i], dummy.second + movey[i]));\n\t\t\t\t\t\tmap[dummy.first + movex[i]][dummy.second + movey[i]] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswap(date, stock);\n\t}\n\tcout << answer << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mp make_pair\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;//cnt, coodinate\nstring grid[1111];\nint dx[] = {0, 1, 1,  1,  0, -1, -1, -1};\nint dy[] = {1, 1, 0, -1, -1, -1,  0,  1};\nint w, h;\n\nbool del(int x, int y){\n  int cnt = 0;\n  if(!(0 <= x && x < w &&\n       0 <= y && y < h))return false;\n  if(grid[y][x] == '.') return false;\n  for (int i = 0; i < 8; i++) {\n    int nx = x + dx[i], ny = y + dy[i];\n    //std::cout << \"nx:\" << nx << \" ny:\" << ny <<  \" \" <<\n    //grid[ny][nx] << std::endl;\n    if(!(0 <= nx && nx < w &&\n         0 <= ny && ny < h))continue;\n    if(grid[ny][nx] == '.')cnt++;\n  }\n  char tmp = grid[y][x];\n  //std::cout << \"atoi:\" << atoi(&tmp)  << \" cnt:\" << cnt << std::endl;\n  //std::cout << std::endl;\n  if(cnt >= atoi(&tmp))return true;\n  else return false;\n}\n\nint main(int argc, char *argv[]){\n  queue<piii> que;\n  queue<pii> p;\n  cin >> h >> w;\n  for (int i = 0; i < h; i++) {\n    cin >> grid[i];\n  }\n  for (int i = 0; i < h; i++) {\n    for (int j = 0; j < w; j++) {\n      if(del(j, i)){\n        //std::cout << i <<  \" \" << j << std::endl;\n        p.push(mp(j, i));\n        que.push(mp(1, mp(j, i)));\n      }\n    }\n  }\n  int ans = 0;\n  // std::cout << \"size:\"<<que.size() << std::endl;\n  // std::cout << \"p size:\"<<p.size() << std::endl;\n  \n  while(!que.empty()){\n    int cnt = que.front().first;\n    if(ans != cnt){\n      while(!p.empty()){\n        int x = p.front().first;\n        int y = p.front().second;\n        p.pop();\n        grid[y][x] = '.';\n      } \n    }\n    int x = que.front().second.first;\n    int y = que.front().second.second;\n\n    //std::cout << x << \" \" << y  << \" \" << cnt<< std::endl;\n    // for (int i = 0; i < h; i++) {\n    //   for (int j = 0; j < w; j++) {\n    //     std::cout << grid[i][j] << \" \";\n    //   }\n    //   std::cout << std::endl;\n    // }\n    que.pop();\n    ans = cnt;\n    for (int i = 0; i < 8; i++) {\n      if(del(x + dx[i], y + dy[i])){\n        p.push(mp(x + dx[i], y + dy[i]));\n        que.push(mp(cnt + 1, mp(x + dx[i], y + dy[i])));\n      }\n    }\n  }\n  std::cout << ans << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n#define INF (1<<30)\n#define INFLL (1ll<<60)\ntypedef pair<int, int> P;\ntypedef pair<int, P> E;\n#define MOD (1000000007ll)\n#define l_ength size\n\nvoid mul_mod(ll& a, ll b){\n\ta *= b;\n\ta %= MOD;\n}\n\nvoid add_mod(ll& a, ll b){\n\ta += b;\n\tif(a>MOD){\n\t\ta -= MOD;\n\t}\n}\n\nint h,w,t[1024][1024];\nstring s[1024];\nqueue<P> q;\n\nint main(void){\n\tint i,j,x,y,a,b,ans=0;\n\tcin >> h >> w;\n\tfor(i=0; i<h; ++i){\n\t\tcin >> s[i];\n\t\tfor(j=0; j<w; ++j){\n\t\t\tif(s[i][j]=='.'){\n\t\t\t\tq.push(P(i,j));\n\t\t\t\ts[i][j] = 0;\n\t\t\t}else{\n\t\t\t\ts[i][j] -= '0';\n\t\t\t}\n\t\t}\n\t}\n\twhile(!q.empty()){\n\t\ta = q.front().first;\n\t\tb = q.front().second;\n\t\tq.pop();\n\t\tans = max(ans,t[a][b]);\n\t\tfor(i=-1; i<2; ++i){\n\t\t\tfor(j=-1; j<2; ++j){\n\t\t\t\tx = a+i; y = b+j;\n\t\t\t\tif(!(0<=x && x<h && 0<=y && y<w)){\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(!(i||j)){\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(!s[x][y]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t--s[x][y];\n\t\t\t\tif(!s[x][y]){\n\t\t\t\t\tq.push(P(x,y));\n\t\t\t\t\tt[x][y] = t[a][b]+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <set>\n#include <vector>\nusing namespace std;\n\nconst int MAX_SIZE = 1000;\ntypedef pair<int, int> P;\n\nint calc(char f[][MAX_SIZE], vector<P> v, int H, int W) {\n  int c = 0;\n  int di[8] = {-1, 0, 1, -1, 1, -1, 0, 1};\n  int dj[8] = {-1, -1, -1, 0, 0, 1, 1, 1};\n  while(++c) {\n    vector<P> b;\n    set<P> s;\n    for (vector<P>::iterator it = v.begin(); it != v.end(); ++it) {\n      int i = it->first, j = it->second;\n      int n = 0;\n      for (int k = 0; k < 8; ++k) {\n        if (i + di[k] >= 0 && i + di[k] < H &&\n            j + dj[k] >= 0 && j + dj[k] < W &&\n            f[i + di[k]][j + dj[k]] == '.') {\n          n++;\n        }\n      }\n      if (n >= f[i][j] - '0') {\n        b.push_back(P(i, j));\n        for (int k = 0; k < 8; ++k) {\n          if (i + di[k] >= 0 && i + di[k] < H &&\n              j + dj[k] >= 0 && j + dj[k] < W &&\n              f[i + di[k]][j + dj[k]] != '.') {\n              s.insert(P(i + di[k], j + dj[k]));\n          }\n        }\n      }\n    }\n    if (!b.size()) {\n      return c - 1;\n    }\n    for (vector<P>::iterator it = b.begin(); it != b.end(); ++it) {\n      f[it->first][it->second] = '.';\n      s.erase(P(it->first, it->second));\n    }\n    v = vector<P>(s.begin(), s.end());\n  }\n  return 0;\n}\n\nint main() {\n  int H, W;\n  char f[MAX_SIZE][MAX_SIZE];\n  set<P> s;\n\n  cin >> H >> W;\n  for (int i = 0; i < H; ++i) {\n    cin >> f[i];\n    for (int j = 0; j < W; ++j) {\n      if (f[i][j] != '.') {\n        s.insert(P(i, j));\n      }\n    }\n  }\n  cout << calc(f, vector<P>(s.begin(), s.end()), H, W) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<iostream>\n#include<queue>\n#include<stdlib.h>\nusing namespace std;\nint h, w;\nint map[1005][1005];\nint d[9] = { -1, 0, 1 };\nclass S{\npublic:\n\tint x, y, z;\n\tS(int a, int b, int c){\n\t\tx = a, y = b, z = c;\n\t}\n};\nint main()\n{\n\tint ans = 0;\n\tqueue<S>q;\n\tcin >> h >> w;\n\tfor (int i = 0; i < h; i++){\n\t\tfor (int i2 = 0; i2 < w; i2++){\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tif (c == '.'){\n\t\t\t\tmap[i][i2] = 0;\n\t\t\t\tq.push(S(i2, i, 0));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tmap[i][i2] = atoi(&c);\n\t\t\t}\n\t\t}\n\t}\n\twhile (!q.empty()){\n\t\tS s = q.front();\n\t\tint x = s.x, y = s.y, z = s.z;\n\t\tans = z;\n\t\tq.pop();\n\t\tfor (int i = 0; i < 3; i++){\n\t\t\tfor (int i2 = 0; i2 < 3; i2++){\n\t\t\t\tint xx = x + d[i2];\n\t\t\t\tint yy = y + d[i];\n\t\t\t\tif (xx >= 0 && xx < w&&yy >= 0 && yy < h&&--map[yy][xx] == 0){\n\t\t\t\t\tq.push(S(xx, yy, z + 1));\n\t\t\t\t\t/*for (int i3 = 0; i3 < h; i3++){\n\t\t\t\t\t\tfor (int i4 = 0; i4 < w; i4++){\n\t\t\t\t\t\t\tprintf(\"%3d\", map[i3][i4]);\n\t\t\t\t\t\t}cout << endl;\n\t\t\t\t\t}\n\t\t\t\t\tcout << endl;*/\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define fr first\n#define sc second\ntypedef pair<int, int> Pii;\ntypedef vector<int> Vi;\nconst int INF = (1<<30);\nconst int dx[]={-1,0,1,1,1,0,-1,-1}, dy[]={-1,-1,-1,0,1,1,1,0};\n\nint main()\n{\n  int h, w;\n  int maps[1000][1000];\n  int cnt[1000][1000] = {0};\n\n  cin >> h >> w;\n  for(int i=0; i<h; i++) {\n    for(int j=0; j<w; j++) {\n      char c;\n      cin >> c;\n      if( c == '.' ) {\n\tmaps[i][j] = 0;\n\tfor(int l=0; l<8; l++) {\n\t  int nx = j+dx[l], ny = i+dy[l];\n\t  if( 0 <= nx && nx < w && 0 <= ny && ny < h ) {\n\t    cnt[ny][nx]++;\n\t  }\n\t}\n      }\n      else maps[i][j] = c - '0';\n    }\n  }\n\n  bool flag = true;\n  int ans = 0;\n  while( 1 ) {\n    vector<Pii> v;\n    flag = false;\n    for(int i=0; i<h; i++) {\n      for(int j=0; j<w; j++) {\n\tif( maps[i][j] && maps[i][j] <= cnt[i][j] ) {\n\t  flag = true;\n\t  maps[i][j] = 0;\n\t  v.pb(Pii(i, j));\n\t}\n      }\n    }\n\n    if( !flag ) break;\n    for(int i=0; i<v.size(); i++) {\n      for(int l=0; l<8; l++) {\n\tint nx = v[i].sc+dx[l], ny = v[i].fr+dy[l];\n\tif( 0 <= nx && nx < w && 0 <= ny && ny < h ) {\n\t  cnt[ny][nx]++;\n\t}\n      }\n    }\n    ans++;\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nstring board[51];\nint dx[8] = {0, 1, 1, 1, 0, -1, -1, -1};\nint dy[8] = {1, 1, 0, -1, -1, -1, 0, 1};\nint h, w;\nbool hantei(int y, int x){\n\tif(0 <= y && y < h && 0 <= x && x < w) return true;\n\telse return false;\n}\nint main(void){\n\tcin >> h >> w;\n\trep(i, h) cin >> board[i];\n\tint ans = -1, nowy, nowx;\n\tbool flag = true;\n\twhile(flag){\n\t\tflag = false; ans++;\n\t\tvector<pair<int, int> > memo;//?????????????????????????????????????????????????????????\n\t\trep(y, h){\n\t\t\trep(x, w){\n\t\t\t\tif(board[y][x] == '.') continue;\n\t\t\t\tint tmp = 0;\n\t\t\t\trep(i, 8){\n\t\t\t\t\tnowy = y + dy[i]; nowx = x + dx[i];\n\t\t\t\t\tif(!hantei(nowy, nowx))continue;\n\t\t\t\t\tif(board[nowy][nowx] == '.')tmp++;\n\t\t\t\t}\n\t\t\t\tif(tmp >= board[y][x] - '0'){\n\t\t\t\t\t// board[y][x] = '.';?????????????????????????????????????\n\t\t\t\t\tmemo.push_back(make_pair(y, x));\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//???????????\n\t\trep(k, memo.size()){\n\t\t\tboard[memo[k].first][memo[k].second] = '.';\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint a;\nint b;\nchar are[1001][1001];\nint kore[1001][1001];\nint sore[1001][1001];\nint sata[1001][1001];\nint shun[1001][1001];\nint ushi;\nint uma;\n\nint main(){\n\tcin >> a >> b;\n\tfor (int i = 0; i < a; i++){\n\t\tfor (int j = 0; j < b; j++){\n\t\t\tcin >> are[i][j];\n\t\t\tif (are[i][j] != '.'){\n\t\t\t\tkore[i - 1][j - 1]++;\n\t\t\t\tkore[i][j - 1]++;\n\t\t\t\tkore[i + 1][j - 1]++;\n\t\t\t\tkore[i - 1][j]++;\n\t\t\t\tkore[i + 1][j]++;\n\t\t\t\tkore[i - 1][j + 1]++;\n\t\t\t\tkore[i][j + 1]++;\n\t\t\t\tkore[i + 1][j + 1]++;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i < a - 1; i++){\n\t\tfor (int j = 1; j < b - 1; j++){\n\t\t\tsore[i][j] = kore[i][j];\n\t\t\tsata[i][j] = 1;\n\t\t\t//\tcout<<sore[i][j];\n\t\t}\n\t}\n\t//\tfor (int i = 0; i < a; i++){\n\t//\t\tcout<<endl;\n\t//\t\t\tfor (int j = 0; j < b; j++){\n\t//\t\t\t\tcout<<sata[i][j];}}\n\twhile (true){\n\t\tuma = 0;\n\t\tfor (int i = 1; i < a - 1; i++){\n\t\t\tfor (int j = 1; j < b - 1; j++){\n\t\t\t\tif (sata[i][j] == 1){\n\t\t\t\t\t//cout<<are[i][j]<<\" \"<<9-sore[i][j]<<endl;\n\t\t\t\t\tif (are[i][j] != '.' && 9 - sore[i][j] > are[i][j] - 48){\n\t\t\t\t\t\t//cout<<1234<<endl;\n\t\t\t\t\t\tare[i][j] = '.';\n\t\t\t\t\t\tkore[i - 1][j - 1]--;\n\t\t\t\t\t\tkore[i][j - 1]--;\n\t\t\t\t\t\tkore[i + 1][j - 1]--;\n\t\t\t\t\t\tkore[i - 1][j]--;\n\t\t\t\t\t\tkore[i + 1][j]--;\n\t\t\t\t\t\tkore[i - 1][j + 1]--;\n\t\t\t\t\t\tkore[i][j + 1]--;\n\t\t\t\t\t\tkore[i + 1][j + 1]--;\n\t\t\t\t\t\tuma = 1;\n\t\t\t\t\t\tshun[i][j] = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse{shun[i][j] = 0; }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (uma == 1){\n\t\t\tushi++;\n\t\t}\n\t\tif (uma == 0){\n\t\t\tbreak;\n\t\t}\n\t\t//if(ushi>30){\n\t\t//\tcout<<\"popopopopop\"<<endl;\n\t\t//\t\tfor (int i = 0; i < a; i++){\n\t\t//cout<<endl;\n\t\t//\tfor (int j = 0; j < b; j++){\n\t\t//\t\tcout<<sata[i][j];}}\n\t\t//\t}\n\t\tfor (int i = 0; i < a; i++){\n\t\t\tfor (int j = 0; j < b; j++){\n\t\t\t\tsore[i][j] = kore[i][j];\n\t\t\t\tsata[i][j] = 0;\n\t\t\t}\n\t\t\t//cout<<\"po\"<<endl; \n\t\t}\n\t\tfor (int i = 1; i < a-1; i++){\n\t\t\tfor (int j = 1; j < b-1; j++){\n\t\t\t\tif (shun[i][j] == 1){\n\t\t\t\t\tsata[i - 1][j - 1]=1;\n\t\t\t\t\tsata[i][j - 1] = 1;\n\t\t\t\t\tsata[i + 1][j - 1]=1;\n\t\t\t\t\tsata[i - 1][j]=1;\n\t\t\t\t\tsata[i + 1][j]=1;\n\t\t\t\t\tsata[i - 1][j + 1]=1;\n\t\t\t\t\tsata[i][j + 1]=1;\n\t\t\t\t\tsata[i + 1][j + 1]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ushi << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> ip;\nconst int MAX=1010;\nint cnt[MAX][MAX];\nint mx[]={1,1,1,0,0,-1,-1,-1},my[]={1,0,-1,1,-1,1,0,-1};\nint main(){\n\tint h,w;\tcin>>h>>w;\n\tvector<string> s(h);\n\tfor(int i=0;i<h;i++)\tcin>>s[i];\n\tqueue<ip> q;\n\tfor(int i=0;i<h;i++){//\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(s[i][j]=='.')\tcontinue;\n\t\t\tfor(int k=0;k<8;k++){\n\t\t\t\tif(s[i+my[k]][j+mx[k]]=='.')\tcnt[i][j]++;\n\t\t\t}\n\t\t\tif(cnt[i][j]>=s[i][j]-'0'){//\n\t\t\t\ts[i][j]='0';\n\t\t\t\tq.push(make_pair(i,j));\n\t\t\t}\n\t\t}\n\t}\n\tif(q.empty()){\n\t\tcout<<0<<endl;\n\t\treturn 0;\n\t}\n\tint ans=1;\n\twhile(true){\n\t\tqueue<pair<int,int>> broken;\n\t\twhile(!q.empty()){\n\t\t\tauto now=q.front();\tq.pop();\n\t\t\tint y=now.first,x=now.second;\n\t\t\tfor(int i=0;i<8;i++){//\n\t\t\t\tint yy=y+my[i],xx=x+mx[i];\n\t\t\t\tif(s[yy][xx]=='.'||s[yy][xx]=='0')\tcontinue;\n\t\t\t\tcnt[yy][xx]++;\n\t\t\t\tif(cnt[yy][xx]>=s[yy][xx]-'0'){\n\t\t\t\t\ts[yy][xx]='0';\n\t\t\t\t\tbroken.push(make_pair(yy,xx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(broken.empty()){\n\t\t\tcout<<ans<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\twhile(!broken.empty()){\n\t\t\tq.push(broken.front());\tbroken.pop();\n\t\t}\n\t\tans++;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nusing ll=long long;\nusing vi=vector<int>;\nusing pii=pair<int,int>;\n#define ALL(c) begin(c),end(c)\n#define RALL(c) rbegin(c),rend(c)\n#define ITR(i,b,e) for(auto i=(b);i!=(e);++i)\n#define FORE(x,c) for(auto &x:c)\n#define REPF(i,a,n) for(int i=a,i##len=(int)(n);i<i##len;++i)\n#define REP(i,n) REPF(i,0,n)\n#define REPR(i,n) for(int i=(int)(n);i>=0;--i)\n#define SZ(c) ((int)c.size())\n#define CONTAIN(c,x) (c.find(x)!=end(c))\n#define OUTOFRANGE(y,x,h,w) (y<0||x<0||y>=h||x>=w)\n#define dump(...)\nconst int DX[9]={0,1,0,-1,1,1,-1,-1,0},DY[9]={-1,0,1,0,-1,1,1,-1,0};\n#define INF (1001001001)\n#define INFLL (1001001001001001001ll)\ntemplate<class T> ostream& operator << (ostream &os,const vector<T> &v) {\n    ITR(i,begin(v),end(v)) os<<*i<<(i==end(v)-1?\"\":\" \"); return os; }\ntemplate<class T> istream& operator >> (istream &is,vector<T> &v) {\n    ITR(i,begin(v),end(v)) is>>*i; return is; }\ntemplate<class T> istream& operator >> (istream &is, pair<T,T> &p) {\n    is>>p.first>>p.second; return is; }\ntemplate<class T> bool chmax(T &a,const T &b) {if(a<b) {a=b;return 1;} return 0;}\ntemplate<class T> bool chmin(T &a,const T &b) {if(b<a) {a=b;return 1;} return 0;}\ntemplate <class T> using heap = priority_queue<T,vector<T>,greater<T>>;\n//------------------------------------------------------------------------------\nstruct before_main_function {\n    before_main_function() {\n        #ifdef int\n            #undef INF\n            #define INF INFLL\n            #define stoi stoll\n        #endif\n        cin.tie(0);ios::sync_with_stdio(false);\n        cout<<setprecision(15)<<fixed;\n        #define endl \"\\n\"\n    }\n} before_main_function;\n//------------------8<------------------------------------8<--------------------\n\nsigned main() {\n    int H,W;\n    cin>>H>>W;\n    vector<string> s(H);\n    cin>>s;\n\n    queue<pii> A,B;\n    auto check=[&](int i,int j) {\n        if(s[i][j]=='.') return false;\n        int cnt=0;\n        REP(d,8) {\n            int ii=i+DY[d];\n            int jj=j+DX[d];\n            if(s[ii][jj]=='.') cnt++;\n        }\n        if(s[i][j]-'0'<=cnt) {\n            return true;\n        } else {\n            return false;\n        }\n    };\n    int ans=0;\n    REP(i,H) {\n        REP(j,W) {\n            if(check(i,j)) {\n                A.push({i,j});\n            }\n        }\n    }\n    while(1) {\n        if(A.empty()) break;\n        ans++;\n        // dump(ans,SZ(A));\n        while(!A.empty()) {\n            int y=A.front().first;\n            int x=A.front().second;\n            A.pop();\n            s[y][x]='.';\n            B.push({y,x});\n        }\n        set<pii> next;\n        while(!B.empty()) {\n            int y=B.front().first;\n            int x=B.front().second;\n            B.pop();\n            REP(d,8) {\n                int yy=y+DY[d];\n                int xx=x+DX[d];\n                if(check(yy,xx)) {\n                    next.insert({yy,xx});\n                }\n            }\n        }\n        FORE(x,next) A.push(x);\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair< int, int > Pi;\ntypedef pair< int, Pi > Pii;\nconst static int dy[] = {-1, -1, 0, 1, 1, 1, 0, -1};\nconst static int dx[] = {0, 1, 1, 1, 0, -1, -1, -1};\n\nint main()\n{\n  int H, W;\n  string S[1000];\n\n  cin >> H >> W;\n  for(int i = 0; i < H; i++) {\n    cin >> S[i];\n  }\n\n  queue< Pii > Que;\n  int ret = 0;\n\n  for(int i = 0; i < H; i++) {\n    for(int j = 0; j < W; j++) {\n      if(S[i][j] == '.') Que.push(Pii(0, Pi(j, i)));\n      else S[i][j] -= '0';\n    }\n  }\n  while(!Que.empty()) {\n    Pii& p = Que.front();\n    ret = max(ret, p.first);\n    for(int i = 0; i < 8; i++) {\n      int ny = p.second.second + dy[i];\n      int nx = p.second.first  + dx[i];\n      --S[ny][nx];\n      if(ny >= 0 && ny < H && nx >= 0 && nx < W && S[ny][nx] == 0) {\n        Que.push(Pii(p.first + 1, Pi(nx, ny)));\n      }\n    }\n    Que.pop();\n  }\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<bits//stdc++.h>\n#include<functional>\nusing namespace std;\nstruct P{\n\tint x,y;\n};\nint main() {\n\tint a[500][500];\n\tint h,w;\n\tcin>>h>>w;\n\tfor(int i=0;i<h;i++){\n\t\tstring s;\n\t\tcin>>s;\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(s[j]=='.') a[i][j]=0;\n\t\t\telse a[i][j]=(int)s[j]-'0';\n\t\t}\n\t}\n\tint sum=0,sum2=1;\n\twhile(sum2){\n\t\tsum2=0;\n\t\tint sum3;\n\t\tvector<P>p;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(a[i][j]){\n\t\t\t\t\tsum3=0;\n\t\t\t\t\tfor(int x=-1;x<=1;x++){\n\t\t\t\t\t\tfor(int y=-1;y<=1;y++){\n\t\t\t\t\t\t\tif(i+x<h&&i+x>=0&&j+y<w&&j+y>=0&&a[i+x][j+y]==0) sum3++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(sum3>=a[i][j]) {\n\t\t\t\t\t\tp.push_back(P{i,j});\n\t\t\t\t\t\tsum2++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<sum2;i++){\n\t\t\ta[p[i].x][p[i].y]=0;\n\t\t}\n\t\tsum++;\n\t}\n\tcout<<--sum<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<algorithm>\n#include<vector>\n#include<unordered_map>\n#define p pair<int,int>\n#define P pair<p,int>\nusing namespace std;\n\np x[1000000];\nint g[1000][1000];\nint main() {\n    unordered_map<int, bool>oq;\n\tqueue<P>Q;\n\tint a, b;\n\tcin >> a >> b;\n\tchar d[1000];\n\tfor (int c = 0; c < a; c++) {\n\t\tscanf(\"%s\", d);\n\t\tfor (int e = 0; e < b; e++) {\n\t\t\tif (d[e] == '.')g[c][e] = 0;\n\t\t\telse g[c][e] = d[e] - '0';\n\t\t}\n\t}\n\tint k = 0;\n\tfor (int f = 1; f < a-1; f++) {\n\t\tfor (int h = 1; h < b-1; h++) {\n\t\t\tif (g[f][h]) {\n\t\t\t\tint sum = 0;\n\t\t\t\tfor (int i = -1; i < 2; i++) {\n\t\t\t\t\tfor (int j = -1; j < 2; j++) {\n\t\t\t\t\t\tif (g[f + i][h + j])sum++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (9 - sum >= g[f][h]&&!oq[f*10000+h]) {\n\t\t\t\t\tQ.push(P(p(f, h), 1));\n\t\t\t\t\toq[f*10000+h] = true;\n\t\t\t\t\tx[k] = p(f, h);\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int t = 0; t < k; t++)g[x[t].first][x[t].second] = 0;\n\tint MAX = 0;\n\tint w = 0, now = 0;\n\twhile (Q.size()) {\n\t\tP s = Q.front();\n\t\tQ.pop();\n\t\tif (s.second != now) {\n\t\t\tfor (int t = 0; t < w; t++) { g[x[t].first][x[t].second] = 0; }\n\t\t\tw = 0;\n\t\t\tnow = s.second;\n\t\t}\n\t\tMAX = max(MAX, s.second);\n\t\tfor (int i = -1; i < 2; i++) {\n\t\t\tfor (int j = -1; j < 2; j++) {\n\t\t\t\tif (s.first.first + i>=1&& s.first.first + i<a-1&&s.first.second + j>=1&& s.first.second + j<b-1&&g[s.first.first + i][s.first.second + j]) {\n\t\t\t\t\tint sum = 0;\n\t\t\t\t\tfor (int n = -1; n < 2; n++) {\n\t\t\t\t\t\tfor (int m = -1; m < 2; m++) {\n\t\t\t\t\t\t\tif (g[s.first.first + i+n][s.first.second+j+m])sum++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (9 - sum >= g[s.first.first + i][s.first.second + j]&&!oq[(s.first.first + i)*10000+ s.first.second + j]) {\n\t\t\t\t\t\tQ.push(P(p(s.first.first + i, s.first.second + j), s.second + 1)); \n\t\t\t\t\t\toq[(s.first.first + i) * 10000 + s.first.second + j] = true;\n\t\t\t\t\t\tx[w] = p(s.first.first + i, s.first.second + j);\n\t\t\t\t\t\tw++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << MAX << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <set>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint dx[] = {-1,-1,-1,0,0,1,1,1},dy[] = {-1,0,1,-1,1,-1,0,1};\n\nint main(){\n\tint h,w,cnt[1000][1000] = {};\n\tstring field[1000];\n\tcin >> h >> w;\n\tfor(int i = 0;i < h;i++) cin >> field[i];\n\tset<P> next;\n\tfor(int i = 0;i < h;i++){\n\t\tfor(int j = 0;j < w;j++){\n\t\t\tif(field[i][j] == '.') continue;\n\t\t\tnext.insert(P(i,j));\n\t\t\tfor(int k = 0;k < 8;k++){\n\t\t\t\tint nx = i + dx[k],ny = j + dy[k];\n\t\t\t\tif(nx >= 0 && nx < h && ny >= 0 && ny < w && field[nx][ny] == '.') cnt[i][j]++;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int res = 0;;res++){\n\t\tbool chg = false;\n\t\tvector<P> chgs;\n\t\tfor(auto it = next.begin();it != next.end();it++){\n\t\t\tP p = *it;\n\t\t\tint i = p.first,j = p.second;\n\t\t\tif(field[i][j] != '.' && cnt[i][j] >= field[i][j] - '0'){\n\t\t\t\tfield[i][j] = '.';\n\t\t\t\tchg = true;\n\t\t\t\tfor(int k = 0;k < 8;k++){\n\t\t\t\t\tint nx = i + dx[k],ny = j + dy[k];\n\t\t\t\t\tif(nx >= 0 && nx < h && ny >= 0 && ny < w && field[nx][ny] != '.') {\n\t\t\t\t\t\tchgs.push_back(P(nx,ny));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnext.clear();\n\t\tfor(int i = 0;i < chgs.size();i++){\n\t\t\tint x = chgs[i].first,y = chgs[i].second;\n\t\t\tcnt[x][y]++;\n\t\t\tnext.insert(P(x,y));\n\t\t}\n\t\tif(!chg){\n\t\t\tcout << res << endl;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nstruct State {\n  int i, j, t;\n};\n\nconst int INF = 1<<28;\nconst int MAXN = 1001;\nint H, W;\nchar C[MAXN][MAXN];\nint G[MAXN][MAXN];\n\nint main() {\n  while(cin >> H >> W) {\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n        cin >> C[i][j];\n      }\n    }\n    memset(G, 0, sizeof(G));\n    queue<State> que;\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n        if(!isdigit(C[i][j])) {\n          G[i][j] = INF;\n          continue;\n        }\n        for(int di = -1; di <= 1; ++di) {\n          for(int dj = -1; dj <= 1; ++dj) {\n            if(di == 0 && dj == 0) continue;\n            int ni = i + di;\n            int nj = j + dj;\n            if(C[ni][nj] == '.') ++G[i][j];\n          }\n        }\n        if(G[i][j] >= C[i][j]-'0') {\n          que.push((State){i, j, 1});\n        }\n      }\n    }\n    int res = 0;\n    while(que.size()) {\n      const State s = que.front();\n      que.pop();\n      res = s.t;\n      for(int di = -1; di <= 1; ++di) {\n        for(int dj = -1; dj <= 1; ++dj) {\n          if(di == 0 && dj == 0) continue;\n          int ni = s.i + di;\n          int nj = s.j + dj;\n          if(G[ni][nj] >= C[ni][nj]-'0') continue;\n          if(++G[ni][nj] >= C[ni][nj]-'0') {\n            que.push((State){ni, nj, s.t + 1});\n          }\n        }\n      }\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <time.h>\n#include <math.h>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <iterator>\n#include <sstream>\n#include <string>\n#include <bitset>\nusing namespace std;\n#define FOR(I,F,N) for(int I = F; I < (int)(N); I++)\n#define rep(i, n) FOR(i, 0, n)\n#define FIN(V) cout<<V<<endl\n#define pb push_back\n#define INF (1 << 28)\n\ntemplate<typename T>\nvoid remove(vector<T>& vector, unsigned int index){\nvector.erase(vector.begin() + index);\n}\n\ntypedef pair<int, int> P;\ntypedef long long ll;\ntypedef priority_queue<int> pq;\nint StrToInt(string);\nstring IntToStr(int);\nint dx[8] = {-1, 0, 1, 1, 1, 0, -1, -1};\nint dy[8] = {1, 1, 1, 0, -1, -1, -1, 0};\n\nint w, h, ans = 0;\nint state[1001][1001];\nint score[1001][1001];\nvoid show(){\n\trep(i,h){\n\t\trep(j,w){\n\t\t\tif(state[j][i] == 0)cout << '.';\n\t\t\telse cout << state[j][i];\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nint main(void){\n\tcin >> h >> w;\n\tfill_n(*state, 1001*1001, -1);\n\trep(i,h)rep(j,w){\n\t\tchar c;\n\t\tcin >> c;\n\t\tif(c == '.')state[j][i] = 0;\n\t\telse state[j][i] = c-'0';\n\t}\n\tqueue<P> que;\n\trep(i,h)rep(j,w){\n\t\tif(state[j][i] == 0)continue;\n\t\tint count = 0;\n\t\trep(k,8){\n\t\t\tint nx = j+dx[k];\n\t\t\tint ny = i+dy[k];\n\t\t\tif(nx < 0 || ny < 0 || state[nx][ny] == -1)continue;\n\t\t\tif(state[nx][ny] == 0)count++;\n\t\t}\n\t\tscore[j][i] = count;\n\t\tif(state[j][i] <= count){\n\t\t\tque.push(P(j, i));\n\t\t}\n\t}\n\t///show();\n\twhile(!que.empty()){\n\t\tqueue<P> reQue;\n\t\twhile(!que.empty()){\n\t\t\treQue.push(que.front());\n\t\t\t///cout << \"(\" << que.front().first << \",\" << que.front().second << \")\" << endl;\n\t\t\tP p = que.front();\n\t\t\tint x = p.first;\n\t\t\tint y = p.second;\n\t\t\tstate[x][y] = 0;\n\t\t\tscore[x][y] = 0;\n\t\t\trep(k,8){\n\t\t\t\tint nx = x+dx[k];\n\t\t\t\tint ny = y+dy[k];\n\t\t\t\tscore[nx][ny]++;\n\t\t\t}\n\t\t\tque.pop();\n\t\t}\n\t\tint memo[1001][1001] = {0};\n\t\twhile(!reQue.empty()){\n\t\t\tP p = reQue.front();\n\t\t\treQue.pop();\n\t\t\tint x = p.first;\n\t\t\tint y = p.second;\n\t\t\t///cout << \"(\" << x << \",\" << y << \")\" << endl;\n\t\t\trep(k,8){\n\t\t\t\tint nx = x+dx[k];\n\t\t\t\tint ny = y+dy[k];\n\t\t\t\tif(nx < 0 || ny < 0 || state[nx][ny] == -1)continue;\n\t\t\t\tif(state[nx][ny] == 0)continue;\n\t\t\t\tif(state[nx][ny] <= score[nx][ny] && !memo[nx][ny]){\n\t\t\t\t\tmemo[nx][ny]=1;\n\t\t\t\t\tque.push(P(nx, ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t///show();\n\t\tans++;\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}\n\n\n\nint StrToInt(string s){\n\tstringstream ss;\n\tss << s;\n\tint val;\n\tss >> val;\n\treturn val;\n}\nstring IntToStr(int i){\n\tstringstream ss;\n\tss << i;\n\treturn ss.str();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nstruct Mapchip{\n\tunsigned char num : 4;\n\tunsigned char change : 1;\n};\n\nint main() {\n\tint w,h, s[2] = {}, e[2] = {};\n\tMapchip map[1000][1000] = {};\n\tint dir[2][8] = {\n\t\t{-1, 0, 1, -1, 1, -1, 0, 1},\n\t\t{-1, -1, -1, 0, 0, 1, 1, 1}\n\t};\n\tscanf(\"%d %d\", &h, &w);\n\tfor (int i = 0; h > i; i++){\n\t\tscanf(\"%*c\");\n\t\tfor(int j = 0; w > j; j++){\n\t\t\tchar buf;\n\t\t\tscanf(\"%c\", &buf);\n\t\t\t\n\t\t\tif(buf == '.') buf = '0';\n\t\t\telse {\n\t\t\t\tif(s[0] == 0){\n\t\t\t\t\ts[0] = i; s[1] = j;\n\t\t\t\t}\n\t\t\t\tif(e[0] < i || e[1] < j) {\n\t\t\t\t\te[0] = i; e[1] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tmap[i][j].num = buf - '0';\n\t\t\t\n\t\t}\n\t}\n\t\n\tint t = 1, count;\n\tfor(count = 0; t; count++){\n\t\tt = 0;\n\t\tfor(int i = s[0]; e[0] >= i; i++){\n\t\t\tfor(int j = s[1]; e[1] >= j; j++){\n\t\t\t\tif (map[i][j].num){\n\t\t\t\t\tint emptyc = 0;\n\t\t\t\t\tfor (int c = 0; 8 > c; c++){\n\t\t\t\t\t\tif (!map[i + dir[0][c]][j + dir[1][c]].num && !map[i + dir[0][c]][j + dir[1][c]].change) emptyc++;\n\t\t\t\t\t}\n\t\t\t\t\tif (emptyc >= map[i][j].num){\n\t\t\t\t\t\tt = 1;\n\t\t\t\t\t\tmap[i][j].num = 0;\n\t\t\t\t\t\tmap[i][j].change = 1;\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = s[0]; e[0] >= i; i++){\n\t\t\tfor (int j = s[1]; e[1] >= j; j++){\n\t\t\t\tmap[i][j].change = 0;\n\t\t\t}\n\t\t}\n\t};\n\tprintf(\"%d\\n\", count-1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define Rep(i, a, b) for(int i = (a); i < (b); i++)\n#define rep(i, n) Rep(i, 0, n)\n\nint movX[8] = {-1, 0, 1,-1, 1,-1, 0, 1};\nint movY[8] = {-1,-1,-1, 0, 0, 1, 1, 1};\n\ntemplate<class T> T read() {\n\tT t;\n\tcin >> t;\n\treturn t;\n}\n\nint main(){\n\tint h=read<int>(),w=read<int>();\n\tint mp[h][w];\n\trep(i,h) rep(j,w){\n\t\tchar c=read<char>();\n\t\tif(c=='.'){\n\t\t\tmp[i][j]=0;\t\t\t\n\t\t}else{\n\t\t\tmp[i][j]=c-'0';\n\t\t}\n\t}\n\tint around[h][w];\n\tRep(i, 1, h-1){\n\t\tRep(j, 1, w-1){\n\t\t\tint a = 0;\n\t\t\trep(k,8) {\n\t\t\t\tint x = i+movX[k];\n\t\t\t\tint y = j+movY[k];\n\t\t\t\t// printf(\"(%d, %d) -> (%d, %d) \", i, j, x, y);\n\t\t\t\tif(!mp[x][y]){\n\t\t\t\t\t// cout << \"o\";\n\t\t\t\t\ta++;\n\t\t\t\t}\n\t\t\t\t// cout << endl;\n\t\t\t}\n\t\t\taround[i][j]=a;\n\t\t}\n\t}\n\t// return 0;\n\t\t// rep(i,h){\n\t\t// \trep(j,w){\n\t\t// \t\tcout << mp[i][j];\n\t\t// \t}\n\t\t// \tcout << \" \";\n\t\t// \trep(j,w){\n\t\t// \t\tif(around[i][j]<0)\n\t\t// \t\t\tcout << \"x\";\n\t\t// \t\telse\n\t\t// \t\t\tcout << around[i][j];\n\t\t// \t}\n\t\t// \tcout << endl;\n\t\t// }\n\t\t// cout << \"-------------------------------------------\" << endl;\n\t\n\ttypedef pair<int, int> pii;\n\t\n\tint count = 0;\n\twhile(true){\n\t\tvector<pii> list;\n\t\tRep(i, 1, h-1){\n\t\t\tRep(j, 1, w-1){\n\t\t\t\tif(mp[i][j]>0 && around[i][j]>=mp[i][j]){\n\t\t\t\t\t// cout << i << \" \" << j << endl;\n\t\t\t\t\tlist.push_back(pii(i,j)); // mp[i][j] = 0;\n\t\t\t\t\t// now++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(list.size()==0){\n\t\t\tbreak;\n\t\t}\n\t\tcount++;\n\t\tfor(vector<pii>::iterator it=list.begin();it!=list.end();it++){\n\t\t\tint i = it->first, j = it->second;\n\t\t\tmp[i][j] = 0;\n\t\t\trep(k,8) {\n\t\t\t\tint x = i+movX[k];\n\t\t\t\tint y = j+movY[k];\n\t\t\t\taround[x][y]++;\n\t\t\t}\n\t\t}\n\t\t// rep(i,h){\n\t\t// \trep(j,w){\n\t\t// \t\tcout << mp[i][j];\n\t\t// \t}\n\t\t// \tcout << \" \";\n\t\t// \trep(j,w){\n\t\t// \t\tif(around[i][j]<0)\n\t\t// \t\t\tcout << \"x\";\n\t\t// \t\telse\n\t\t// \t\t\tcout << around[i][j];\n\t\t// \t}\n\t\t// \tcout << endl;\n\t\t// }\n\t\t// cout << \"-------------------------------------------\" << endl;\n\t}\n\tcout << count << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<stdio.h>\n#include<stack>\nint mp[1002][1002] = { 0 }, mj[1002][1002] = { 0 };\nint main()\n{\n\tint x[8] = { -1,0,1,1,1,0,-1,-1 },m;\n\tint y[8] = { 1,1,1,0,-1,-1,-1,0 };\n\tint i,j,h, w,c=0,g,n=0;\n\tchar a;\n\tcin >> h >> w;\n\tfor (i = 0; i < h; i++)\n\t{\n\t\tfor (j = 0; j < w; j++)\n\t\t{\n\t\t\tcin >> a;\n\t\t\tif (a == '1')\n\t\t\t\tmp[i][j] =1;\n\t\t\tif (a == '2')\n\t\t\t\tmp[i][j] = 2;\n\t\t\tif (a == '3')\n\t\t\t\tmp[i][j] = 3;\n\t\t\tif (a == '4')\n\t\t\t\tmp[i][j] = 4;\n\t\t\tif (a == '5')\n\t\t\t\tmp[i][j] = 5;\n\t\t\tif (a == '6')\n\t\t\t\tmp[i][j] = 6;\n\t\t\tif (a == '7')\n\t\t\t\tmp[i][j] = 7;\n\t\t\tif (a == '8')\n\t\t\t\tmp[i][j] = 8;\n\t\t\tif (a == '9')\n\t\t\t\tmp[i][j] = 9;\n\t\t}\n\t}\n\tg = 0;\n\twhile(1)\n\t{\n\t\tfor (i = 0; i < h; i++)\n\t\t{\n\t\t\tfor (j = 0; j < w; j++)\n\t\t\t{\n\t\t\t\tif (mp[i][j] == 0)\n\t\t\t\t\tn++;\n\t\t\t}\n\t\t}\n\t\tif (n == h*w)\n\t\t\tbreak;\n\t\tfor (i = 0; i < h; i++)\n\t\t{\n\t\t\tfor (j = 0; j < w; j++)\n\t\t\t{\n\t\t\t\tif (mp[i][j] >= 1)\n\t\t\t\t{\n\t\t\t\t\tfor (m = 0; m < 8; m++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (mp[i + y[m]][j + x[m]] == 0)\n\t\t\t\t\t\t\tc++;\n\t\t\t\t\t\tif (mp[i][j] <= c)\n\t\t\t\t\t\t\tmj[i][j] = 1;\n\t\t\t\t\t}\n\t\t\t\t\tc = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\tfor (i = 0; i < h; i++)\n\t\t\t{\n\t\t\t\tfor (j = 0; j < w; j++)\n\t\t\t\t{\n\t\t\t\t\tif (mj[i][j] == 1)\n\t\t\t\t\t\tmp[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tg++;\n\t\t}\n\tcout<< g << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <string>\nusing namespace std;\n\nstruct p{\n  int co,x,y;\n  p(int a,int b,int c){\n    co=a;\n    x=b;\n    y=c;\n  }\n};\nint a[1000][1000],b[1000][1000];\nint main (){\n  int h,w;\n  queue<p> Q; \n  string s;\n  cin >>h>>w;\n  for(int i=0;i<h;i++){\n    cin >>s;\n    for(int j=0;j<w;j++){\n      if(s[j] == '.'){\n\ta[i][j] = -1;\n\tQ.push(p(0,j,i));\n      } else a[i][j] = s[j]-'0';\n      b[i][j] = 0;\n    }\n  }\n  int res = 0;\n  while( !Q.empty() ){\n    p np = Q.front();\n    Q.pop();\n    if(res < np.co) res = np.co;\n    for(int i=-1;i<=1;i++)\n      for(int j=-1;j<=1;j++){\n\tif(i==0 && j==0) continue;\n\tint nx = np.x+i;\n\tint ny = np.y+j;\n\tif(0>=nx || nx>w-1 || 0>=ny || ny>h-1) continue;\n\tb[nx][ny]++;\n\tif(a[nx][ny] == b[nx][ny]) Q.push(p(np.co+1,nx,ny));\n      }\n  }\n  cout << res<<endl;\n  return 0;\n}\n    "
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<queue>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int, int>P;\ntypedef long long ll;\n\nint h, w;\nchar ca[1000][1001];\nqueue<P>que1;\nqueue<P>que2;\n\nint cnt(int a, int b){\n\tint res = 0;\n\tfor (int i = -1; i <= 1; i++){\n\t\tfor (int j = -1; j <= 1; j++){\n\t\t\tif (ca[a + i][b + j] == '.')\n\t\t\t\tres++;\n\t\t}\n\t}\n\treturn res;\n}\nvoid wave(){\n\twhile (!que1.empty()){\n\t\tP p = que1.front(); que1.pop();\n\t\tint f = p.first, s = p.second;\n\t\tca[f][s] = '.';\n\t\tfor (int i = -1; i <= 1; i++){\n\t\t\tfor (int j = -1; j <= 1; j++){\n\t\t\t\tif ('1' <= ca[f + i][s + j] && ca[f + i][s + j] - '0' <= cnt(f + i, s + j))\n\t\t\t\t\tque2.push(P(f + i, s + j));\n\t\t\t}\n\t\t}\n\t}\n\tswap(que1, que2);\n}\nint main(){\n\tscanf(\"%d%d\", &h, &w);\n\trep(i, h)\n\t\tscanf(\"%s\", ca[i]);\n\trep(i, h){\n\t\trep(j, w){\n\t\t\tif ('1' <= ca[i][j] && ca[i][j] - '0' <= cnt(i, j))\n\t\t\t\tque1.push(P(i, j));\n\t\t}\n\t}\n\tint cnt = 0;\n\twhile (!que1.empty()){\n\t\twave();\n\t\tcnt++;\n\t}\n\tprintf(\"%d\\n\", cnt);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int, int>;\n\nconstexpr int dx[8] = {0, 1, 1, 1, 0, -1, -1, -1};\nconstexpr int dy[8] = {-1, -1, 0, 1, 1, 1, 0, -1};\n\nint main() {\n    int H, W;\n    cin >> H >> W;\n    vector<string> v(H);\n    for(int i = 0; i < H; ++i) {\n        cin >> v[i];\n    }\n\n    vector<pii> now;\n    for(int i = 0; i < H; ++i) {\n        for(int j = 0; j < W; ++j) {\n            if(v[i][j] == '.') {\n                continue;\n            }\n            for(int k = 0; k < 8; ++k) {\n                int ny = i + dy[k];\n                int nx = j + dx[k];\n                if(ny < 0 || H <= ny || nx < 0 || W <= nx) {\n                    continue;\n                }\n                v[i][j] -= v[ny][nx] == '.';\n                v[i][j] = max('0', v[i][j]);\n            }\n        }\n    }\n    for(int i = 0; i < H; ++i) {\n        for(int j = 0; j < W; ++j) {\n            if(v[i][j] == '0') {\n                v[i][j] = '.';\n                now.emplace_back(i, j);\n            }\n        }\n    }\n\n    int res = 0;\n    while(!now.empty()) {\n        vector<pii> next;\n        for(auto& p : now) {\n            for(int i = 0; i < 8; ++i) {\n                int ny = p.first + dy[i];\n                int nx = p.second + dx[i];\n                if(ny < 0 || H <= ny || nx < 0 || W <= nx || v[ny][nx] == '.') {\n                    continue;\n                }\n                v[ny][nx]--;\n                v[ny][nx] = max('0', v[ny][nx]);\n                if(v[ny][nx] == '0') {\n                    v[ny][nx] = '.';\n                    next.emplace_back(ny, nx);\n                }\n            }\n        }\n        now = move(next);\n        res++;\n    }\n\n    cout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nusing ll=long long;\nusing vi=vector<int>;\nusing pii=pair<int,int>;\n#define ALL(c) begin(c),end(c)\n#define RALL(c) rbegin(c),rend(c)\n#define ITR(i,b,e) for(auto i=(b);i!=(e);++i)\n#define FORE(x,c) for(auto &x:c)\n#define REPF(i,a,n) for(int i=a,i##len=(int)(n);i<i##len;++i)\n#define REP(i,n) REPF(i,0,n)\n#define REPR(i,n) for(int i=(int)(n);i>=0;--i)\n#define SZ(c) ((int)c.size())\n#define CONTAIN(c,x) (c.find(x)!=end(c))\n#define OUTOFRANGE(y,x,h,w) (y<0||x<0||y>=h||x>=w)\n#define dump(...)\nconst int DX[9]={0,1,0,-1,1,1,-1,-1,0},DY[9]={-1,0,1,0,-1,1,1,-1,0};\n#define INF (1001001001)\n#define INFLL (1001001001001001001ll)\ntemplate<class T> ostream& operator << (ostream &os,const vector<T> &v) {\n    ITR(i,begin(v),end(v)) os<<*i<<(i==end(v)-1?\"\":\" \"); return os; }\ntemplate<class T> istream& operator >> (istream &is,vector<T> &v) {\n    ITR(i,begin(v),end(v)) is>>*i; return is; }\ntemplate<class T> istream& operator >> (istream &is, pair<T,T> &p) {\n    is>>p.first>>p.second; return is; }\ntemplate<class T> bool chmax(T &a,const T &b) {if(a<b) {a=b;return 1;} return 0;}\ntemplate<class T> bool chmin(T &a,const T &b) {if(b<a) {a=b;return 1;} return 0;}\ntemplate <class T> using heap = priority_queue<T,vector<T>,greater<T>>;\n//------------------------------------------------------------------------------\nstruct before_main_function {\n    before_main_function() {\n        #ifdef int\n            #undef INF\n            #define INF INFLL\n            #define stoi stoll\n        #endif\n        cin.tie(0);ios::sync_with_stdio(false);\n        cout<<setprecision(15)<<fixed;\n        #define endl \"\\n\"\n    }\n} before_main_function;\n//------------------8<------------------------------------8<--------------------\n\nsigned main() {\n    int H,W;\n    cin>>H>>W;\n    vector<string> s(H);\n    cin>>s;\n\n    queue<pii> A,B;\n    auto check=[&](int i,int j) {\n        int cnt=0;\n        REP(d,8) {\n            int ii=i+DY[d];\n            int jj=j+DX[d];\n            if(s[ii][jj]=='.') cnt++;\n        }\n        if(s[i][j]-'0'<=cnt) {\n            return true;\n        } else {\n            return false;\n        }\n    };\n    int ans=0;\n    REP(i,H) {\n        REP(j,W) {\n            if(s[i][j]!='.') {\n                if(check(i,j)) {\n                    A.push({i,j});\n                }\n            }\n        }\n    }\n    while(1) {\n        if(A.empty()) break;\n        ans++;\n        while(!A.empty()) {\n            int y=A.front().first;\n            int x=A.front().second;\n            A.pop();\n            B.push({y,x});\n            s[y][x]='.';\n        }\n        while(!B.empty()) {\n            int y=B.front().first;\n            int x=B.front().second;\n            B.pop();\n            REP(d,8) {\n                int yy=y+DY[d];\n                int xx=x+DX[d];\n                if(s[yy][xx]!='.') {\n                    if(check(yy,xx)) {\n                        A.push({yy,xx});\n                    }\n                }\n            }\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\nusing namespace std;\n\nint main()\n{\n  int h,w;\n  scanf(\"%d%d\",&h,&w);\n  static char M[1000][1001];\n  for(int i=0;i<h;i++){\n    scanf(\"%s\",M[i]);\n  }\n  static int K[1000][1001]={0};\n  int dx[8]={1,1,1,0,0,-1,-1,-1},dy[8]={-1,0,1,-1,1,-1,0,1};\n  queue<pair<int,int> > Q[2];\n  bool b=0;\n  for(int i=1;i<h-1;i++){\n    for(int j=1;j<w-1;j++){\n      for(int v=0;v<8;v++){\n\tint x=i+dx[v],y=j+dy[v];\n\tif(M[x][y]=='.'){\n\t  K[i][j]++;\n\t}\n      }\n      if(M[i][j]!='.'&&K[i][j]>=M[i][j]-'0'){\n\tQ[b].push(make_pair(i,j));\n      }\n    }\n  }\n  int t=0;\n  while(!Q[b].empty()){\n    while(!Q[b].empty()){\n      pair<int,int> p=Q[b].front();\n      Q[b].pop();\n      int i=p.first,j=p.second;\n      for(int v=0;v<8;v++){\n\tint x=i+dx[v],y=j+dy[v];\n\tK[x][y]++;\n\tif(M[x][y]!='.'&&K[x][y]==M[x][y]-'0'){\n\t  Q[!b].push(make_pair(x,y));\n\t}\n      }\n    }\n    t++;\n    b=!b;\n  }\n  printf(\"%d\\n\",t);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rrep(i,a,b) for(int i=(a);i<=(b);i++)\n#define P pair<int,int>\nusing namespace std;\n\nint dx[8]={-1,-1,0,1,1,1,0,-1};\nint dy[8]={0,-1,-1,-1,0,1,1,1};\n\nint h,w;\nint a[1002][1002];\nint b[1002][1002];\nstring s[1002];\n\nint make(int x,int y)\n{\n\tint ans=0;\n\trep(i,8)\n\t{\n\t\tint tx=x+dx[i];\n\t\tint ty=y+dy[i];\n\t\tif(s[tx][ty]=='.')ans++;\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tcin>>h>>w;\n\trep(i,h)cin>>s[i];\n\tvector<P> f[2];\n\tint now=0,pre=1,ans=0;\n\tbool flag;\n\trrep(i,1,h-2)\n\t{\n\t\trrep(j,1,w-2)\n\t\t{\n\t\t\ta[i][j]=make(i,j);\n\t\t\tf[now].pb(mp(i,j));\n\t\t}\n\t}\n\twhile(1)\n\t{\n\t\tflag=false;\n\t\tnow=!now;\n\t\tpre=!pre;\n\t\tf[now].clear();\n\t\tmemset(b,0,sizeof(b));\n\t\trep(i,f[pre].size())\n\t\t{\n\t\t\tP p=f[pre][i];\n\t\t\tif(s[p.fi][p.se]!='.'&&s[p.fi][p.se]-'0'<=a[p.fi][p.se])\n\t\t\t{\n\t\t\t\tflag=true;\n\t\t\t\ts[p.fi][p.se]='.';\n\t\t\t\trep(j,8)\n\t\t\t\t{\n\t\t\t\t\tint tx=p.fi+dx[j];\n\t\t\t\t\tint ty=p.se+dy[j];\n\t\t\t\t\tif(tx<=0||tx>=h-1||ty<=0||ty>=w-1)continue;\n\t\t\t\t\tb[tx][ty]++;\n\t\t\t\t\tf[now].pb(mp(tx,ty));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i,h)rep(j,w)a[i][j]+=b[i][j];\n\t\tif(flag)ans++;\n\t\telse break;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\nusing namespace std;\n\nint h, w;\nchar t[1001];\nvector<string> v;\nint dx[8] = {0, 1, 1, 1, 0, -1, -1, -1};\nint dy[8] = {-1, -1, 0, 1, 1, 1, 0, -1};\nint ans;\ntypedef pair<int, int> P;\n\nint main(){\n\tscanf(\"%d %d\", &h, &w);\n\tfor(int i=0; i<h; i++){\n\t\tscanf(\"%s\", t);\n\t\tv.push_back(t);\n\t}\n\tbool f = true;\n\twhile(f){\n/*\t\t\n\t\tprintf(\"\\n\");\n\t\tfor(int i=0; i<h; i++)\n\t\t\tprintf(\"%s\\n\", v[i].c_str());\n*/\t\t\n\t\tf = false;\n\t\tvector<P> u;\n\t\tfor(int i=1; i<w-1; i++){\n\t\t\tfor(int j=1; j<h-1; j++){\n\t\t\t\tif(v[j][i] != '.'){\n\t\t\t\t\tint c = 0;\n\t\t\t\t\tfor(int k=0; k<8; k++){\n\t\t\t\t\t\tint nx, ny;\n\t\t\t\t\t\tnx = i + dx[k];\n\t\t\t\t\t\tny = j + dy[k];\n\t\t\t\t\t\tif(v[ny][nx] == '.') c++;\n\t\t\t\t\t}\n\t\t\t\t\tif(v[j][i] - '0' <= c){\n\t\t\t\t\t\tu.push_back(P(j, i));\n\t\t\t\t\t\tf = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<u.size(); i++){\n\t\t\tv[u[i].first][u[i].second] = '.';\n\t\t}\n\t\tif(f) ans++;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint dx[]={1,1,1,0,0,-1,-1,-1};\nint dy[]={1,0,-1,1,-1,1,0,-1};\nint main(){\n  int w,h;\n  cin>>h>>w;\n  string s[h];\n  for(int i=0;i<h;i++)cin>>s[i];\n  for(int i=0;i<100;i++){\n    vector<pair<int,int> >v;\n    for(int j=0;j<h;j++){\n      for(int k=0;k<w;k++){\n        if(s[j][k]=='.')continue;\n        int p=0;\n        for(int l=0;l<8;l++){\n          int y=j+dy[l],x=dx[l]+k;\n          if(y>=0&&x>=0&&y<h&&x<w)\n            if(s[y][x]=='.')p++;\n        }\n        if(p>=s[j][k]-'0')\n          v.push_back(make_pair(j,k));\n      }\n    }\n    if(v.size()){\n      for(int i=0;i<v.size();i++)\n        s[v[i].first][v[i].second]='.';\n    }\n    else{\n      cout<<i<<endl;\n      break;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define f first\n#define s second\n#define mk make_pair\nusing namespace std;\ntypedef pair<int,int> P;\nint h,w,ans=0;\nint dx[]={-1,-1,-1,0,0,1,1,1};\nint dy[]={1,0,-1,1,-1,1,0,-1};\nstring s[1001];\nmain(){\n\tcin>>h>>w;\n\tr(i,h)cin>>s[i];\n\tqueue<pair<pair<int,int>,int> >q;\n\tr(i,h)r(j,w)if(isdigit(s[i][j])){\n\t\tint sum=0;\n\t\tr(k,8){\n\t\t\tint y=i+dy[k];\n\t\t\tint x=j+dx[k];\n\t\t\tif(y<0||x<0||x>=w||y>=h)continue;\n\t\t\tif(s[y][x]=='.')sum++;\n\t\t}\n\t\tif(s[i][j]-'0'<=sum)q.push(mk(mk(i,j),1));\n\t}\n\twhile(!q.empty()){\n\t\tvector<P>v;\n\t\twhile(!q.empty()){\n\t\t\tpair<pair<int,int>,int>p=q.front();q.pop();\n\t\t\tans=p.s;\n\t\t\ts[p.f.f][p.f.s]='.';\n\t\t\tv.push_back(P(p.f.f,p.f.s));\n\t\t}\n\t\tr(i,v.size())r(j,8){\n\t\t\tint y=v[i].f+dy[j];\n\t\t\tint x=v[i].s+dx[j];\n\t\t\tif(0<=y&&y<h&&0<=x&&x<w&&isdigit(s[y][x])){\n\t\t\t\tint sum=0;\n\t\t\t\tr(k,8){\n\t\t\t\t  int yy=y+dy[k];\n\t\t\t      int xx=x+dx[k];\n\t\t\t      if(yy<0||xx<0||xx>=w||yy>=h)continue;\n\t\t\t      if(s[yy][xx]=='.')sum++;\n\t\t\t    }\n\t\t\t    if(s[y][x]-'0'<=sum)q.push(mk(mk(y,x),ans+1));\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"queue\"\n#include \"utility\"\n#include \"math.h\"\n\nusing namespace std;\nint H, W;\nchar status[1002][1002];\nint field[1002][1002];\npair<int, int> dir[8] = {make_pair(0,1),make_pair(1,1),make_pair(1,0),make_pair(1,-1),make_pair(0,-1),make_pair(-1,-1),make_pair(-1,0),make_pair(-1,1)};\nqueue<pair<int,int> > Q;\nqueue<pair<int, int> >del;\nbool flag[1002][1002];\nint ans = 0;\nint box = 0;\nint num = 0;\nint x, y;\n\nint main() {\n\tcin >> H >> W;\n\tfor (int i = 1; i <= H; i++) {\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tcin >> status[i][j];\n\t\t\tif (status[i][j] == '.') {\n\t\t\t\tfield[i][j] = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfield[i][j] = status[i][j] - '0';\n\t\t\t\tflag[i][j] = true;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= H; i++) {\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tif (field[i][j] != 0) {\n\t\t\t\tbox = 0;\n\t\t\t\tfor (int k = 0; k < 8; k++) {\n\t\t\t\t\tif (field[i + dir[k].first][j + dir[k].second] == 0)box++;\n\t\t\t\t}\n\t\t\t\tif (box >= field[i][j]&&flag[i][j]) {\n\t\t\t\t\tQ.push(make_pair(i, j));\n\t\t\t\t\tflag[i][j] = false;\n\t\t\t\t\tans = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdel = Q;\n\t\n\twhile (!del.empty()) {\n\t\ty = del.front().first;\n\t\tx = del.front().second;\n\t\tfield[y][x] = 0;\n\t\tdel.pop();\n\t}\n\twhile (1) {\n\t\tnum = Q.size();\n\t\t//cout << num <<\" \";\n\t\tfor (int i = 0; i < num; i++) {\n\t\t\ty = Q.front().first;\n\t\t\tx = Q.front().second;\n\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\tif (field[y + dir[j].first][x + dir[j].second] != 0&&y+dir[j].first>=1&&y+dir[j].first<=H&&x+dir[j].second>=1&&x+dir[j].second<=W) {\n\t\t\t\t\tbox = 0;\n\t\t\t\t\tfor (int k = 0; k < 8; k++) {\n\t\t\t\t\t\tif (field[y + dir[j].first + dir[k].first][x + dir[j].second + dir[k].second] == 0)box++;\n\t\t\t\t\t}\n\t\t\t\t\tif (box >= field[y + dir[j].first][x + dir[j].second]&& flag[y + dir[j].first][x + dir[j].second]) {\n\t\t\t\t\t\tQ.push(make_pair(y + dir[j].first, x + dir[j].second));\n\t\t\t\t\t\tflag[y + dir[j].first][x + dir[j].second] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t\t//cout << Q.size() << \"\\n\";\n\t\tif (Q.empty())break;\n\t\tdel = Q;\n\t\tans++;\n\t\t//cout << del.size() << \"\\n\";\n\t\twhile (!del.empty()) {\n\t\t\ty = del.front().first;\n\t\t\tx = del.front().second;\n\t\t\tfield[y][x] = 0;\n\t\t\tdel.pop();\n\t\t}\n\t\t\n\t}\n\tcout << ans << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint W, H, m[1000][1000];\nint dx[] = {-1, 0, 1, 1, 1, 0, -1, -1}, dy[] = {1, 1, 1, 0, -1, -1, -1, 0};\n\n\nint main()\n{\n  cin >> H >> W;\n  queue<int> up1, up2, bks;\n  for(int y = 0; y < H; y++)\n  {\n    for(int x = 0; x < W; x++)\n    {\n      char c;\n      cin >> c;\n      if(c == '.')\n      {\n        m[y][x] = -1;\n      }\n      else\n      {\n        m[y][x] = c - '0';\n        up1.push(x);\n        up1.push(y);\n      }\n    }\n  }\n  int ans = 0;\n  while(!(up1.empty() && up2.empty()))\n  {\n    ans += 1;\n    queue<int> *upp1, *upp2;\n    if(up1.empty())\n    {\n      upp2 = &up1;\n      upp1 = &up2;\n    }\n    else\n    {\n      upp1 = &up1;\n      upp2 = &up2;\n    }\n    while(!upp1->empty())\n    {\n      int x = upp1->front(); upp1->pop();\n      int y = upp1->front(); upp1->pop();\n      if(m[y][x] == -1)\n        continue;\n      int c = 0;\n      for(int i = 0; i < 8; i++)\n      {\n        int tx = x + dx[i], ty = y + dy[i];\n        if(m[ty][tx] == -1)\n          c++;\n      }\n      if(c < m[y][x])\n        continue;\n      bks.push(x);\n      bks.push(y);\n    }\n    while(!bks.empty())\n    {\n      int x = bks.front(); bks.pop();\n      int y = bks.front(); bks.pop();\n      if(m[y][x] == -1)\n        continue;\n      m[y][x] = -1;\n      for(int i = 0; i < 8; i++)\n      {\n        int tx = x + dx[i], ty = y + dy[i];\n        if(m[ty][tx] != -1)\n        {\n          upp2->push(tx);\n          upp2->push(ty);\n        }\n      }\n    }\n  }\n  cout << ans - 1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<queue>\n#define MP make_pair\nusing namespace std;\nlong long int sc[1001][1001],ssc[1001][1001];\nchar c[1001];\nint main()\n{\n\tint h, w, cnt = 0, ans = 0, n,kfc=0;\n\tint x, y;\n\tpair<int, int> p;\n\tqueue< pair<int, int> > que;\n\tqueue< pair<int, int> > que1;\n\tscanf(\"%d%d\", &h, &w);\n\tfor (int i = 0; i < h; i++)\n\t{\n\t\tscanf(\"%s\", c);\n\t\tfor (int j = 0; j < w; j++)\n\t\t{\n\n\t\t\tif (c[j] == '.')\n\t\t\t\tsc[i][j] = -1;\n\t\t\telse\n\t\t\t\tsc[i][j] = c[j] - 48;\n\t\t}\n\t}\n\tfor (int i = 1; i < h; i++)\n\t{\n\t\tfor (int j = 1; j < w; j++)\n\t\t{\n\t\t\tif (sc[i][j] != -1)\n\t\t\t{\n\t\t\t\tfor (int a = i - 1; a < i + 2; a++)\n\t\t\t\t{\n\t\t\t\t\tfor (int b = j - 1; b < j + 2; b++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (sc[a][b] == -1)ssc[i][j] ++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (sc[i][j] <= ssc[i][j])\n\t\t\t\t{\n\t\t\t\t\tque.push(MP(i, j)); que1.push(MP(i, j));  kfc++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < kfc; i++) {\n\t\tx = que.front().first;\n\t\ty = que.front().second;\n\t\tque.pop();\n\t\tque1.pop();\n\t\tsc[x][y] = -1; que.push(MP(x, y)); que1.push(MP(x, y));\n\t}\n\twhile (!que.empty())\n\t{\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tx = que.front().first;\n\t\t\ty = que.front().second;\n\t\t\tque.pop();\n\t\t\tfor (int a = -1; a < 2; a++)\n\t\t\t{\n\t\t\t\tssc[x - 1][y + a]++;\n\t\t\t\tssc[x + 1][y + a]++;\n\t\t\t}\n\t\t\tssc[x][y - 1]++;\n\t\t\tssc[x][y + 1]++;\n\t\t}\n\t\tn = que1.size();\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tx = que1.front().first;\n\t\t\ty = que1.front().second;\n\t\t\tque1.pop();\n\t\t\tfor (int a = -1; a < 2; a++)\n\t\t\t{\n\t\t\t\tif (sc[x - 1][y + a] <= ssc[x - 1][y + a] && sc[x - 1][y + a] != -1) {\n\t\t\t\t\tque.push(MP(x - 1, y + a)); que1.push(MP(x - 1, y + a)); sc[x - 1][y + a] = -1;\n\t\t\t\t}\n\t\t\t\tif (sc[x + 1][y + a] <= ssc[x + 1][y + a] && sc[x + 1][y + a] != -1) {\n\t\t\t\t\tque.push(MP(x + 1, y + a)); que1.push(MP(x + 1, y + a)); sc[x + 1][y + a] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (sc[x][y - 1] <= ssc[x][y - 1] && sc[x][y - 1] != -1) {\n\t\t\tque.push(MP(x, y - 1)); que1.push(MP(x, y - 1)); sc[x][y - 1] = -1;\n\t\t\t}\n\t\t\tif (sc[x][y + 1] <= ssc[x][y + 1] && sc[x][y + 1] != -1) {\n\t\t\t\tque.push(MP(x, y + 1)); que1.push(MP(x, y + 1)); sc[x][y + 1] = -1;\n\t\t\t}\n\t\t}\n\t\tans++;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define loop(i,n) for(int i=1;i<=n;i++)\nconst int INF=100000000;\ntypedef pair<int,int> P;\nint h,w;\nchar sh[1002][1002];\nbool miket[1002][1002];\nint houkai[1002][1002];\nqueue<P> que;\nint dir[9]={0,-1,-1,0,1,1,-1,1,0};\n\nint main() {\n  cin>>h>>w;\n  loop(i,h)loop(j,w){\n    cin>>sh[i][j];\n    if(sh[i][j]=='.'){\n      houkai[i][j]=0;\n    }else if(sh[i][j]=='9'){\n      houkai[i][j]=INF;\n    }else{\n      que.push(P(i,j));\n      miket[i][j]=1;\n    }\n  }\n  while(!que.empty()){\n    P p=que.front();que.pop();\n    int i=p.first,j=p.second;\n    int sara=0;\n    int yama=0;\n    vector<int> v;\n    int kyoudo=(int)(sh[i][j]-'0');\n    loop(d,8){\n      int x=i+dir[d-1];\n      int y=j+dir[d];\n      if(!miket[x][y]){\n        if(houkai[x][y]<INF){\n          sara++;\n          v.push_back(houkai[x][y]);\n        }else{\n          yama++;\n        }\n      }\n    }\n    if(sara>=kyoudo){\n      miket[i][j]=0;\n      sort(v.begin(),v.end());\n      houkai[i][j]=v[kyoudo-1]+1;\n    }else if(8-yama<kyoudo){\n      miket[i][j]=0;\n      houkai[i][j]=INF;\n    }else{\n      que.push(p);\n    }\n  }\n  int m=0;\n  loop(i,h)loop(j,w){\n    if(houkai[i][j]==INF)continue;\n    m=max(m,houkai[i][j]);\n  }\n  cout<<m<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<bits//stdc++.h>\n#include<functional>\nusing namespace std;\nstruct P{\n\tint x,y;\n};\nint main() {\n\tint a[500][500];\n\tint h,w;\n\tcin>>h>>w;\n\tfor(int i=0;i<h;i++){\n\t\tstring s;\n\t\tcin>>s;\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(s[j]=='.') a[i][j]=0;\n\t\t\telse a[i][j]=(int)s[j]-'0';\n\t\t}\n\t}\n\tint sum=-1,sum2=1;\n\twhile(sum2){\n\t\tsum2=0;\n\t\tint sum3;\n\t\tvector<P>p;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(a[i][j]){\n\t\t\t\t\tsum3=0;\n\t\t\t\t\tfor(int x=-1;x<=1;x++){\n\t\t\t\t\t\tfor(int y=-1;y<=1;y++){\n\t\t\t\t\t\t\tif(i+x<h&&i+x>=0&&j+y<w&&j+y>=0&&a[i+x][j+y]==0) sum3++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(sum3>=a[i][j]) {\n\t\t\t\t\t\tp.push_back(P{i,j});\n\t\t\t\t\t\tsum2++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<(int)p.size();i++){\n\t\t\ta[p[i].x][p[i].y]=0;\n\t\t}\n\t\tsum++;\n\t}\n\tcout<<sum<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <queue>\nusing namespace std;\nchar field[2000][2000];\nint dx[] = {1,1,1,0,0,-1,-1,-1};\nint dy[] = {1,0,-1,1,-1,1,0,-1};\nint x,y,d,ans;\nqueue<int> str[3];\nint main()\n{\n    int h,w;\n    scanf(\"%d%d\",&h,&w);\n    ans = 0;\n    for(int i = 0; i < h; i++)\n    {\n        for(int j = 0; j < w + 1; j++)\n        {\n            scanf(\"%c\",&field[i][j]);\n        }\n    }\n    for(int i = 0; i < h; i++)\n    {\n        for(int j = 1; j < w; j++)\n        {\n            if(field[i][j] == '.')\n            {\n                str[0].push(i);\n                str[1].push(j);\n                str[2].push(0);\n            }\n        }\n    }\n    while(str[0].size())\n    {\n        x = str[0].front();str[0].pop();\n        y = str[1].front();str[1].pop();\n        d = str[2].front();str[2].pop();\n        if(ans < d)ans = d;\n        for(int i = 0; i < 8; i++)\n        {\n            if(0 <= x + dx[i]&&x + dx[i] < w&&0 <= y + dy[i]&&y + dy[i] < h)\n            {\n                field[x + dx[i]][y + dy[i]]--;\n                if(field[x + dx[i]][y + dy[i]] == '0')\n                {\n                    str[0].push(x + dx[i]);\n                    str[1].push(y + dy[i]);\n                    str[2].push(d + 1);\n                }\n            }\n        }\n    }\n    printf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint h, w;\nbool naka(int x, int y){\n  return (x >= 0 && x < w && y >= 0 && y < h);\n}\n\nstring maptmp;\nqueue<pair<pair<int, int>,  int> > que;\n\nint maps[1010][1010];\n\nint main(){\n\n  cin >> h >> w;\n  for(int i = 0;i < h;i++){\n    cin >> maptmp;\n    for(int j = 0;j < w;j++){\n      if(maptmp[j] == '.'){\n        que.push(make_pair(make_pair(i,j),0));\n        maps[i][j] = 0;\n      }else{\n        maps[i][j] = maptmp[j] - '0';\n      }\n    }\n  }\n\n  int ans = 0;\n  pair<pair<int, int>, int> data;\n\n  while(!que.empty()){\n    data = que.front();\n    que.pop();\n    ans = max(ans, data.second);\n\n    int y = data.first.first;\n    int x = data.first.second;\n    for(int i = -1;i <= 1;i++){\n      for(int j = -1;j <= 1;j++){\n        if(naka(x+j,y+i) && maps[y+i][x+j] > 0){\n          maps[y+i][x+j]--;\n          if(maps[y+i][x+j] == 0){\n            que.push(make_pair(make_pair(y+i,x+j),data.second+1));\n          }\n        }\n      }\n    }\n  }\n\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <utility>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n\n#define INF_LL 9000000000000000000\n#define INF 2000000000\n\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int i = (a);i < (b);i++)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> PPII;\ntypedef pair<int, PPII> PPPII;\n\nclass Union_find{\nprivate:\n\tvector<int> par;\n\tvector<int> rank;\n\tint n;\n\npublic:\n\tUnion_find(int a){\n\t\tn = a;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tpar.push_back(i);\n\t\t\trank.push_back(0);\n\t\t}\n\t}\n\n\tint find(int x){\n\t\tif(par[x] == x){\n\t\t\treturn x;\n\t\t}else{\n\t\t\treturn par[x] = find(par[x]);\n\t\t}\n\t}\n\n\tvoid unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return;\n\n\t\tif(rank[x] < rank[y]){\n\t\t\tpar[x] = y;\n\t\t}else{\n\t\t\tpar[y] = x;\n\t\t\tif(rank[x] == rank[y]) rank[x]++;\n\t\t}\n\t}\n\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n};\n\nint dx[3] = {-1, 1, 0};\n\nint main(void){\n\tint h, w;\n\tstring sand[1010][2];\n\tcin >> h >> w;\n\tREP(i, h){\n\t\tcin >> sand[i][0];\n\t}\n\tint cnt = 1;\n\tint res = 0;\n\twhile(cnt != 0){\n\t\tcnt = 0;\n\t\tFOR(i, 1, h-1){\n\t\t\tFOR(j, 1, w-1){\n\t\t\t\tint sarati = 0;\n\t\t\t\tREP(x, 3){\n\t\t\t\t\tREP(y, 3){\n\t\t\t\t\t\tif(x == 2 && y == 2) continue;\n\t\t\t\t\t\tif(sand[i+dx[x]][res%2][j+dx[y]] == '.') sarati++;\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(sand[i][res%2][j] != '.' && sarati >= sand[i][res%2][j]-'0'){\n\t\t\t\t\tsand[i][(res+1)%2][j] = '.';\n\t\t\t\t\tcnt++;\n\t\t\t\t}else{\n\t\t\t\t\tsand[i][(res+1)%2][j] = sand[i][res%2][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(cnt > 0) res++;\n\t}\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint a;\nint b;\nchar are[1001][1001];\nint kore[1001][1001];\nint sore[1001][1001];\nint sata[1001][1001];\nint shun[1001][1001];\nint ushi;\nint uma;\n\nint main(){\n\tcin >> a >> b;\n\tfor (int i = 0; i < a; i++){\n\t\tfor (int j = 0; j < b; j++){\n\t\t\tcin >> are[i][j];\n\t\t\tif (are[i][j] != '.'){\n\t\t\t\tkore[i - 1][j - 1]++;\n\t\t\t\tkore[i][j - 1]++;\n\t\t\t\tkore[i + 1][j - 1]++;\n\t\t\t\tkore[i - 1][j]++;\n\t\t\t\tkore[i + 1][j]++;\n\t\t\t\tkore[i - 1][j + 1]++;\n\t\t\t\tkore[i][j + 1]++;\n\t\t\t\tkore[i + 1][j + 1]++;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i < a - 1; i++){\n\t\tfor (int j = 1; j < b - 1; j++){\n\t\t\tsore[i][j] = kore[i][j];\n\t\t\tsata[i][j] = 1;\n\t\t\t//\tcout<<sore[i][j];\n\t\t}\n\t}\n\t//\tfor (int i = 0; i < a; i++){\n\t//\t\tcout<<endl;\n\t//\t\t\tfor (int j = 0; j < b; j++){\n\t//\t\t\t\tcout<<sata[i][j];}}\n\twhile (true){\n\t\tuma = 0;\n\t\tfor (int i = 1; i < a - 1; i++){\n\t\t\tfor (int j = 1; j < b - 1; j++){\n\t\t\t\tif (sata[i][j] == 1){\n\t\t\t\t\t//cout<<are[i][j]<<\" \"<<9-sore[i][j]<<endl;\n\t\t\t\t\tif (are[i][j] != '.' && 9 - sore[i][j] > are[i][j] - 48){\n\t\t\t\t\t\t//cout<<1234<<endl;\n\t\t\t\t\t\tare[i][j] = '.';\n\t\t\t\t\t\tkore[i - 1][j - 1]--;\n\t\t\t\t\t\tkore[i][j - 1]--;\n\t\t\t\t\t\tkore[i + 1][j - 1]--;\n\t\t\t\t\t\tkore[i - 1][j]--;\n\t\t\t\t\t\tkore[i + 1][j]--;\n\t\t\t\t\t\tkore[i - 1][j + 1]--;\n\t\t\t\t\t\tkore[i][j + 1]--;\n\t\t\t\t\t\tkore[i + 1][j + 1]--;\n\t\t\t\t\t\tuma = 1;\n\t\t\t\t\t\tshun[i][j] = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse{shun[i][j] = 0; }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (uma == 1){\n\t\t\tushi++;\n\t\t}\n\t\tif (uma == 0){\n\t\t\tbreak;\n\t\t}\n\t\t//if(ushi>30){\n\t\t//\tcout<<\"popopopopop\"<<endl;\n\t\t//\t\tfor (int i = 0; i < a; i++){\n\t\t//cout<<endl;\n\t\t//\tfor (int j = 0; j < b; j++){\n\t\t//\t\tcout<<sata[i][j];}}\n\t\t//\t}\n\t\tfor (int i = 0; i < a; i++){\n\t\t\tfor (int j = 0; j < b; j++){\n\t\t\t\tsore[i][j] = kore[i][j];\n\t\t\t\tsata[i][j] = 0;\n\t\t\t}\n\t\t\t//cout<<\"po\"<<endl; \n\t\t}\n\t\tfor (int i = 0; i < a; i++){\n\t\t\tfor (int j = 0; j < b; j++){\n\t\t\t\tif (shun[i][j] == 1){\n\t\t\t\t\tsata[i - 1][j - 1]=1;\n\t\t\t\t\tsata[i][j - 1] = 1;\n\t\t\t\t\tsata[i + 1][j - 1]=1;\n\t\t\t\t\tsata[i - 1][j]=1;\n\t\t\t\t\tsata[i + 1][j]=1;\n\t\t\t\t\tsata[i - 1][j + 1]=1;\n\t\t\t\t\tsata[i][j + 1]=1;\n\t\t\t\t\tsata[i + 1][j + 1]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ushi << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define Rep(i, a, b) for(int i = (a); i < (b); i++)\n#define rep(i, n) Rep(i, 0, n)\n\nint movX[8] = {-1, 0, 1,-1, 1,-1, 0, 1};\nint movY[8] = {-1,-1,-1, 0, 0, 1, 1, 1};\ntypedef pair<int, int> pii;\n\ntemplate<class T> T read() {\n\tT t;\n\tcin >> t;\n\treturn t;\n}\n\nint main(){\n\tint h=read<int>(),w=read<int>();\n\tint mp[h][w];\n\trep(i,h) rep(j,w){\n\t\tchar c=read<char>();\n\t\tif(c=='.'){\n\t\t\tmp[i][j]=0;\n\t\t}else{\n\t\t\tmp[i][j]=c-'0';\n\t\t}\n\t}\n\tint around[h][w];\n\tRep(i, 1, h-1){\n\t\tRep(j, 1, w-1){\n\t\t\tint a = 0;\n\t\t\trep(k,8) {\n\t\t\t\tint x = i+movX[k];\n\t\t\t\tint y = j+movY[k];\n\t\t\t\tif(!mp[x][y]){\n\t\t\t\t\ta++;\n\t\t\t\t}\n\t\t\t}\n\t\t\taround[i][j]=a;\n\t\t}\n\t}\n\t\n\t\n\tvector<pii> list;\n\tRep(i, 1, h-1){\n\t\tRep(j, 1, w-1){\n\t\t\tif(mp[i][j]>0 && around[i][j]>=mp[i][j]){\n\t\t\t\tlist.push_back(pii(i,j)); \n\t\t\t}\n\t\t}\n\t}\n\tif(list.size()==0){\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\tfor(vector<pii>::iterator it=list.begin();it!=list.end();it++){\n\t\tint i = it->first, j = it->second;\n\t\tmp[i][j] = 0;\n\t\trep(k,8) {\n\t\t\tint x = i+movX[k];\n\t\t\tint y = j+movY[k];\n\t\t\taround[x][y]++;\n\t\t}\n\t\t// printf(\"(%d, %d)\\n\",i,j);\n\t}\n\t// printf(\"=============\\n\");\n\t\n\tint count = 1;\n\twhile(true){\n\t\tvector<pii> list2;\n\t\tfor(vector<pii>::iterator it=list.begin();it!=list.end();it++){\n\t\t\tint i = it->first, j = it->second;\n\t\t\t// cout << i << \" \" << j << endl;\n\t\t\trep(k,8) {\n\t\t\t\tint x = i+movX[k];\n\t\t\t\tint y = j+movY[k];\n\t\t\t\tif(mp[x][y]>0 && around[x][y]>=mp[x][y]){\n\t\t\t\t\tlist2.push_back(pii(x,y));\n\t\t\t\t\t// cout << \"    \" <<  i << \" \" << j << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(list2.size()==0){\n\t\t\tcout << count << endl;\n\t\t\treturn 0;\n\t\t}\n//\t\tcout << list2.size() << endl;\n\t\tcount++;\n\t\tvector<pii> list3;\n\t\tfor(vector<pii>::iterator it=list2.begin();it!=list2.end();it++){\n\t\t\tint i = it->first, j = it->second;\n\t\t\tif(mp[i][j]){\n\t\t\t\tlist3.push_back(*it);\n\t\t\t\tmp[i][j] = 0;\n\t\t\t\trep(k,8) {\n\t\t\t\t\tint x = i+movX[k];\n\t\t\t\t\tint y = j+movY[k];\n\t\t\t\t\taround[x][y]++;\n\t\t\t\t}\n\t\t\t\t// printf(\"(%d, %d)\\n\",i,j);\n\t\t\t}\n\t\t}\n\t\t// printf(\"=============\\n\");\n//\t\tstd::vector<pii>().swap(list);\n//\t\tstd::vector<pii>().swap(list2);\n\t\tlist = list3;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define int long long int\n#define rep(a,b,c) for(int a=b;a<c;a++)\n#define repm(a,b,c) for(int a=(b-1);a>=c;a--)\n#define pb push_back\n#define str string\n#define sf(a) scanfs(\"%d\",&a)\n#define pb push_back\n#define mp make_pair\n#define Fi first\n#define Se second\n#define ALL(v) (v).begin(), (v).end()\n\nusing namespace std;\n\nconst int INF = 1e18 + 9;\nconst int Mod = 1e9 + 7;\ninline int replac(str s){double ans=0;rep(i,0,s.length()){ans+=(s[i]-'0')*pow(10,s.length()-i-1);}return (int)ans;}\ninline string numstr(int m){str s=\"\";while(m>0){char c;int a=m/10;if(a>0)a=m%(a*10);else a=m;c=(char)('0'+a);s+=c;m/=10;}str st=\"\";for(int i=s.size()-1;i>=0;i--){st+=s[i];}return st;}\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vii;\nint flag[1003][1003];\nint num[1003][1003];\nint dx[8]={-1,0,1,1,1,0,-1,-1};\nint w,h;\nint dy[8]={1,1,1,0,-1,-1,-1,0};\nstring c[1003];\nbool in(int a,int b){\n    if(a>=0&&b>=0&&a<h&&b<w)return true;\n    else false;\n}\nsigned main()\n{\n    cin >> h >> w;\n    rep(i,0,h){\n        cin >> c[i];\n    }\n    rep(i,0,1000){\n        rep(j,0,1000){\n            num[i][j]=0;\n            flag[i][j]=0;\n        }\n    }\n    rep(i,0,h){\n        rep(j,0,w){\n            if(c[i][j]=='.'){\n                num[i][j]=0;\n                rep(k,0,8){\n                    if((i+dy[k])>=0&&(j+dx[k])>=0&&(i+dy[k])<h&&(j+dx[k])<w){flag[i+dy[k]][j+dx[k]]++;}\n                }\n            }else{\n                num[i][j]=(c[i][j]-'0');\n            }\n        }\n    }\n    int ans=0;\n    queue<pii> que;\n    queue<pii> ser;\n    rep(i,0,h){\n            rep(j,0,w){\n                if(num[i][j]==0)continue;\n                if(flag[i][j]>=num[i][j]){\n                    num[i][j]=0;\n                    que.push(mp(i,j));\n                }\n            }\n    }\n    while(1){\n        if(ans!=0){\n            if(ser.empty())break;\n            while(!ser.empty()){\n                pii p=ser.front();ser.pop();\n                int i=p.first;int j=p.second;\n                if(num[i][j]==0)continue;\n                if(flag[i][j]>=num[i][j]){\n                    num[i][j]=0;\n                    que.push(mp(i,j));\n                    //flag[i][j]++;\n                }\n            }\n        }\n        if(que.empty())break;\n        ans++;\n        while(!que.empty()){\n            pii p=que.front();que.pop();\n            int y=p.first;\n            int x=p.second;\n            rep(k,0,8){\n                if((y+dy[k])>=0&&(x+dx[k])>=0&&(y+dy[k])<h&&(x+dx[k])<w){\n                    if(num[y+dy[k]][x+dx[k]]!=0){\n                        //if(flag[y+dy[k]][x+dx[k]]>=num[y+dy[k]][x+dx[k]]){\n                            //num[y+dy[k]][x+dx[k]]=0;\n                            ser.push(mp(y+dy[k],x+dx[k]));\n                            flag[y+dy[k]][x+dx[k]]++;\n                        //}\n                    }\n                }\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <map>\n#define FLAG -1\nusing namespace std;\ntypedef pair<int,int> P;\nint main(){\n      int h,w,dh[] = {1,1,1,0,-1,-1,-1,0}, dw[] = {1,0,-1,-1,-1,0,1,1},ctn;\n      int solve = -1 ;\n      cin >> h >> w;\n      queue<P> que,tmp;\n      char d[h][w];\n      for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++)\n            {\n                  cin >> d[i][j];\n                  if('1'<=d[i][j]&&'9'>=d[i][j])\n                        que.push(make_pair(i,j));\n            }\n      }\n\n      que.push(make_pair(FLAG,FLAG));\n      for(;;){\n            solve++;\n            int m[h][w];\n            for(int i=0;i<h;i++)for(int j=0;j<w;j++)m[i][j]=0;\n            for(;;){\n                  //cout << que.size()<<endl;\n                  P p = que.front();\n                  que.pop();\n                  if(p.first==FLAG)\n                  {//cout <<\" break \"<<endl<<endl;\n                  break;\n                  }\n                  ctn = 0;\n                  for(int i = 0;i < 8;i++){\n                        if(d[p.first+dh[i]][p.second+dw[i]]=='.')ctn++;\n                  }\n\n                  if(ctn >= d[p.first][p.second]-'0'){\n                        tmp.push(p);\n                        for(int j=0;j<8;j++)\n                        if(m[p.first+dh[j]][p.second+dw[j]]==0&&d[p.first][p.second]!='.'){\n                        que.push(make_pair(p.first+dh[j],p.second+dw[j]));\n                        m[p.first+dh[j]][p.second+dw[j]]=1;\n                        }\n                  }\n            }\n            if(que.empty())break;\n            while(!tmp.empty())\n            {\n                  d[tmp.front().first][tmp.front().second]='.';\n                  tmp.pop();\n            }\n            /*for(i =0 ;i<h;i++)\n            {\n                  for(j=0;j<w;j++)cout << d[i][j];\n                  cout <<endl;\n            }\n            */\n\n            que.push(make_pair(FLAG,FLAG));\n\n      }\n      cout << solve << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<algorithm>\n#define p pair<int,int>\n#define P pair<p,int>\nusing namespace std;\n\np x[100000];\nint g[1000][1000];\nint main() {\n\tqueue<P>Q;\n\tint a, b;\n\tcin >> a >> b;\n\tchar d[1000];\n\tfor (int c = 0; c < a; c++) {\n\t\tscanf(\"%s\", d);\n\t\tfor (int e = 0; e < b; e++) {\n\t\t\tif (d[e] == '.')g[c][e] = 0;\n\t\t\telse g[c][e] = d[e] - '0';\n\t\t}\n\t}\n\tint k = 0;\n\tfor (int f = 1; f < a-1; f++) {\n\t\tfor (int h = 1; h < b-1; h++) {\n\t\t\tif (g[f][h]) {\n\t\t\t\tint sum = 0;\n\t\t\t\tfor (int i = -1; i < 2; i++) {\n\t\t\t\t\tfor (int j = -1; j < 2; j++) {\n\t\t\t\t\t\tif (g[f + i][h + j])sum++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (9 - sum >= g[f][h]) {\n\t\t\t\t\tQ.push(P(p(f, h), 1));\n\t\t\t\t\tx[k] = p(f, h);\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int t = 0; t < k; t++)g[x[t].first][x[t].second] = 0;\n\tint MAX = 0;\n\tint w = 0, now = 0;\n\twhile (Q.size()) {\n\t\tP s = Q.front();\n\t\tQ.pop();\n\t\tif (s.second != now) {\n\t\t\tfor (int t = 0; t < w; t++) { g[x[t].first][x[t].second] = 0; }\n\t\t\tw = 0;\n\t\t\tnow = s.second;\n\t\t}\n\t\tMAX = max(MAX, s.second);\n\t\tfor (int i = -1; i < 2; i++) {\n\t\t\tfor (int j = -1; j < 2; j++) {\n\t\t\t\tif (s.first.first + i>=1&& s.first.first + i<a-1&&s.first.second + j>=1&& s.first.second + j<b-1&&g[s.first.first + i][s.first.second + j]) {\n\t\t\t\t\tint sum = 0;\n\t\t\t\t\tfor (int n = -1; n < 2; n++) {\n\t\t\t\t\t\tfor (int m = -1; m < 2; m++) {\n\t\t\t\t\t\t\tif (g[s.first.first + i+n][s.first.second+j+m])sum++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (9 - sum >= g[s.first.first + i][s.first.second + j]) {\n\t\t\t\t\t\tQ.push(P(p(s.first.first + i, s.first.second + j), s.second + 1)); \n\t\t\t\t\t\tx[w] = p(s.first.first + i, s.first.second + j);\n\t\t\t\t\t\tw++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << MAX << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <math.h>\n#include <utility>\n#include <set>\n#include <map>\n#define INF 1000000000\n#define rep(i,n) for(int i =0;i<n;i++)\nusing namespace std;\ntypedef long long int ll;\n\n\nint main(){\n    int h,w;\n    cin >>h >> w;\n    vector<int> area(h*w);\n    vector<int> ch(h*w,0);\n    queue<pair<int,int> > lis;\n    rep(i, h){\n        rep(j, w){\n            char hoge;\n            cin >> hoge;\n            if (hoge == '.') {\n                area[i*w+j]=-1;\n                for (int k=-1; k<2; k++) {\n                    for (int l=-1; l<2; l++) {\n                        if(k==0 and l==0) continue;\n                        if (i+k>0 and i+k<h-1 and j+l>0 and j+l<w-1) {\n                            ch[(i+k)*w+j+l]++;\n                        }\n                    }\n                }\n            }else{\n                area[i*w+j]=(int)hoge-(int)'0';\n                lis.push({i,j});\n            }\n        }\n    }\n    int ans = 0;\n    int flag = 1;\n    while (flag > 0) {\n        vector<int> olda = area;\n        vector<int> oldc = ch;\n        int si = lis.size();\n        flag = 0;\n        rep(p, si){\n            int i = lis.front().first;\n            int j = lis.front().second;\n            lis.pop();\n            if (olda[i*w+j]!=-1 and oldc[i*w+j]>=olda[i*w+j]) {\n                 area[i*w+j]=-1;\n                 for (int k=-1; k<2; k++) {\n                    for (int l=-1; l<2; l++) {\n                        if(k==0 and l==0) continue;\n                        if (i+k>0 and i+k<h-1 and j+l>0 and j+l<w-1) {\n                            ch[(i+k)*w+j+l]++;\n                        }\n                    }\n                }\n                flag++;\n            }else{\n                lis.push({i,j});\n            }\n        }\n        if(flag > 0) ans++;\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\n\nint data[1010][1010];\nint num[1010][1010];\n\nint main(){\n\tcin.tie();\n\tios::sync_with_stdio(false);\n\n\tint h, w;\n\tcin >> h >> w;\n\n\tfor(int i = 0; i < h; ++i){\n\t\tfor(int j = 0; j < w; ++j){\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tif(c == '.'){\n\t\t\t\tdata[i][j] = -1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdata[i][j] = (int)(c - '0');\n\t\t\t}\n\t\t\t//cout << data[i][j] << \" \";\n\t\t}\n\t\t//cout << endl;\n\t}\n\n\tvector<int> cx;\n\tvector<int> cy;\n\tfor(int i = 0; i < h; ++i){\n\t\tfor(int j = 0; j < w; ++j){\n\t\t\tif(data[i][j] == -1) continue;\n\t\t\tfor(int k = -1; k <= 1; ++k){\n\t\t\t\tfor(int l = -1; l <= 1; ++l){\n\t\t\t\t\tif(k == 0 && l == 0) continue;\n\t\t\t\t\tif(data[i + k][j + l] == -1){\n\t\t\t\t\t\t++num[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(num[i][j] >= data[i][j]){\n\t\t\t\tcx.push_back(i);\n\t\t\t\tcy.push_back(j);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(size_t i = 0; i < cx.size(); ++i){\n\t\tdata[cx[i]][cy[i]] = -1;\n\t}\n\n\tif(cx.empty()){\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\tint turn = 1;\n\twhile(1){\n\t\tvector<int> cx2;\n\t\tvector<int> cy2;\n\t\tfor(size_t a = 0; a < cx.size(); ++a){\n\t\t\tfor(int i = -1; i <= 1; ++i){\n\t\t\t\tfor(int j = -1; j <= 1; ++j){\n\t\t\t\t\tif(i == 0 && j == 0) continue;\n\t\t\t\t\tint x = cx[a] + i;\n\t\t\t\t\tint y = cy[a] + j;\n\t\t\t\t\tif(data[x][y] == -1) continue;\n\t\t\t\t\t++num[x][y];\n\t\t\t\t\tif(num[x][y] >= data[x][y]){\n\t\t\t\t\t\tcx2.push_back(x);\n\t\t\t\t\t\tcy2.push_back(y);\n\t\t\t\t\t\tdata[x][y] = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(cx2.empty()) break;\n\t\t++turn;\n\t\tcx = cx2;\n\t\tcy = cy2;\n\t\t/*\n\t\tfor(int i = 0; i < h; ++i){\n\t\t\tfor(int j = 0; j < w; ++j){\n\t\t\t\tcout << data[i][j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << endl;\n\t\tfor(int i = 0; i < h; ++i){\n\t\t\tfor(int j = 0; j < w; ++j){\n\t\t\t\tcout << num[i][j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << endl;\n\t\tfor(size_t i = 0; i < cx.size(); ++i){\n\t\t\tcout << cx[i] << \" \" << cy[i] << endl;\n\t\t}\n\t\t*/\n\t}\n\n\tcout << turn << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstring>\nusing namespace std;\n\nint main(){\n\tstring S;\n\tint n,m,t,sum,a;\n\tsum=0;\n\tint x[1001][1001];\n\tbool y[1001][1001];\n\tbool z[1001][1001];\n\tmemset(x,0,sizeof(x));\n\tmemset(z,false,sizeof(z));\n\tchar T[10]={'.','1','2','3','4','5','6','7','8','9'};\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>S;\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tfor(int k=0;k<10;k++){\n\t\t\t\tif(S[j-1]==T[k]){\n\t\t\t\t\tx[i][j]=k;\n\t\t\t\t\tif(k==0){\n\t\t\t\t\t\tfor(int l=-1;l<=1;l++){\n\t\t\t\t\t\t\tfor(int o=-1;o<=1;o++){\n\t\t\t\t\t\t\t\tz[i+l][j+o]=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\twhile(true){\n\t\tt=0;\n\t\tsum++;\n\t\tmemset(y,false,sizeof(y));\n\t\tfor(int i=2;i<n;i++){\n\t\t\tfor(int j=2;j<m;j++){\n\t\t\t\tif(x[i][j]>=1 && z[i][j]==true){\n\t\t\t\t\ta=0;\n\t\t\t\t\tfor(int k=-1;k<=1;k++){\n\t\t\t\t\t\tfor(int l=-1;l<=1;l++){\n\t\t\t\t\t\t\tif(k!=0 || l!=0){\n\t\t\t\t\t\t\t\tif(x[i+k][j+l]==0){\n\t\t\t\t\t\t\t\t\ta++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(a>=x[i][j]){\n\t\t\t\t\t\ty[i][j]=true;\n\t\t\t\t\t\tt++;\n\t\t\t\t\t\tfor(int l=-1;l<=1;l++){\n\t\t\t\t\t\t\tfor(int o=-1;o<=1;o++){\n\t\t\t\t\t\t\t\tz[i+l][j+o]=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\t\n\t\t}\n\t\tif(t==0){\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i=2;i<n;i++){\n\t\t\tfor(int j=2;j<m;j++){\n\t\t\t\tif(y[i][j]==true){\n\t\t\t\t\tx[i][j]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<sum-1<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint W, H, m[1000][1000];\nint dx[] = {-1, 0, 1, 1, 1, 0, -1, -1}, dy[] = {1, 1, 1, 0, -1, -1, -1, 0};\n\n\nint main()\n{\n  cin >> H >> W;\n  queue<int> up1, up2, bks;\n  for(int y = 0; y < H; y++)\n  {\n    for(int x = 0; x < W; x++)\n    {\n      char c;\n      cin >> c;\n      if(c == '.')\n      {\n        m[y][x] = -1;\n      }\n      else\n      {\n        m[y][x] = c - '0';\n        up1.push(x);\n        up1.push(y);\n      }\n    }\n  }\n  int ans = 0;\n  while(!(up1.empty() && up2.empty()))\n  {\n    queue<int> *upp1, *upp2;\n    if(up1.empty())\n    {\n      upp2 = &up1;\n      upp1 = &up2;\n    }\n    else\n    {\n      upp1 = &up1;\n      upp2 = &up2;\n    }\n    while(!upp1->empty())\n    {\n      int x = upp1->front(); upp1->pop();\n      int y = upp1->front(); upp1->pop();\n      if(m[y][x] == -1)\n        continue;\n      int c = 0;\n      for(int i = 0; i < 8; i++)\n      {\n        int tx = x + dx[i], ty = y + dy[i];\n        if(m[ty][tx] == -1)\n          c++;\n      }\n      if(c < m[y][x])\n        continue;\n      bks.push(x);\n      bks.push(y);\n    }\n    if(bks.empty())\n      break;\n    while(!bks.empty())\n    {\n      int x = bks.front(); bks.pop();\n      int y = bks.front(); bks.pop();\n      if(m[y][x] == -1)\n        continue;\n      m[y][x] = -1;\n      for(int i = 0; i < 8; i++)\n      {\n        int tx = x + dx[i], ty = y + dy[i];\n        if(m[ty][tx] != -1)\n        {\n          upp2->push(tx);\n          upp2->push(ty);\n        }\n      }\n    }\n\n    ans += 1;\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nbool check_destroy(vector<vector<int> >& mp, int h, int w) {\n    int cnt=0;\n    int dh[8]={-1,-1,-1,0,1,1,1,0};\n    int dw[8]={-1,0,1,1,1,0,-1,-1};\n\n    for(int i=0; i<8; ++i) {\n        cnt+=(mp[h+dh[i]][w+dw[i]]==0?1:0);\n    }\n\n    return mp[h][w]<=cnt;\n}\n\nbool check_stable(vector<vector<int> >& mp, int h, int w) {\n    if(mp[h][w]==9) return true;\n\n    int cnt=0;\n    int dh[8]={-1,-1,-1,0,1,1,1,0};\n    int dw[8]={-1,0,1,1,1,0,-1,-1};\n\n    for(int i=0; i<8; ++i) {\n        cnt+=(mp[h+dh[i]][w+dw[i]]==9?1:0);\n    }\n\n    return mp[h][w]+cnt>8;\n}\n\nint main()\n{\n    int H,W;\n    cin >> H >> W;\n\n    queue<P> q[2];\n    queue<P> dest[2];\n\n    vector<vector<int> > mp(H);\n    int ans=0;\n\n    for(int i=0; i<H; ++i) mp[i].resize(W);\n\n    for(int i=0; i<H; ++i) {\n        string instr;\n        cin >> instr;\n        for(int j=0; j<W; ++j) {\n            switch(instr[j]) {\n            case '.' :\n                mp[i][j]=0;\n                break;\n            default :\n                mp[i][j]=instr[j]-'0';\n                break;\n            }\n        }\n    }\n\n    for(int i=1; i<H-1; ++i) {\n        for(int j=1; j<W-1; ++j) {\n            if(!check_stable(mp,i,j)) q[ans%2].push(P(i,j));\n        }\n    }\n\n    while(1) {\n        int QCNT=q[ans%2].size();\n\n        while(!q[ans%2].empty()) {\n            P temp=q[ans%2].front(); q[ans%2].pop();\n            if(check_destroy(mp,temp.first,temp.second)) dest[ans%2].push(temp);\n            else q[(ans+1)%2].push(temp);\n        }\n\n        while(!dest[ans%2].empty()) {\n            P temp=dest[ans%2].front(); dest[ans%2].pop();\n            mp[temp.first][temp.second]=0;\n        }\n\n        if(QCNT==q[(ans+1)%2].size()) break;\n        ++ans;\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\nint dp[1000][1000];\nchar ddpp[1000][1000];\nint cop[1000][1000];\nint main(){\n\tint h,w;\n\tcin>>h>>w;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tcin>>ddpp[i][j];\n\t\t\tif(ddpp[i][j]=='.')\n\t\t\t\tdp[i][j]=0;\n\t\t\tif(ddpp[i][j]=='1')\n\t\t\t\tdp[i][j]=1;\n\t\t\tif(ddpp[i][j]=='2')\n\t\t\t\tdp[i][j]=2;\n\t\t\tif(ddpp[i][j]=='3')\n\t\t\t\tdp[i][j]=3;\n\t\t\tif(ddpp[i][j]=='4')\n\t\t\t\tdp[i][j]=4;\n\t\t\tif(ddpp[i][j]=='5')\n\t\t\t\tdp[i][j]=5;\n\t\t\tif(ddpp[i][j]=='6')\n\t\t\t\tdp[i][j]=6;\n\t\t\tif(ddpp[i][j]=='7')\n\t\t\t\tdp[i][j]=7;\n\t\t\tif(ddpp[i][j]=='8')\n\t\t\t\tdp[i][j]=8;\n\t\t\tif(ddpp[i][j]=='9')\n\t\t\t\tdp[i][j]=9;\n\t\t}\n\t}\n\tint count=0;\n\twhile(true){\n\t\tfor(int i=0;i<h;i++)\n\t\t\tfor(int j=0;j<w;j++)\n\t\t\t\tcop[i][j]=dp[i][j];\n\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tint s=0;\n\t\t\t\tif(j>0&&cop[i][j-1]==0)\n\t\t\t\t\ts++;\n\t\t\t\tif(j<w-1&&cop[i][j+1]==0)\n\t\t\t\t\ts++;\n\t\t\t\tif(i>0){\n\t\t\t\t\tif(cop[i-1][j]==0)\n\t\t\t\t\t    s++;\n\t\t\t\t\tif(j>0&&cop[i-1][j-1]==0)\n\t\t\t\t\t\ts++;\n\t\t\t\t\tif(j<w-1&&cop[i-1][j+1]==0)\n\t\t\t\t\t\ts++;\n\t\t\t\t}\n\t\t\t\tif(i<h-1){\n\t\t\t\t\tif(cop[i+1][j]==0)\n\t\t\t\t\t    s++;\n\t\t\t\t\tif(j>0&&cop[i+1][j-1]==0)\n\t\t\t\t\t\ts++;\n\t\t\t\t\tif(j<w-1&&cop[i+1][j+1]==0)\n\t\t\t\t\t\ts++;\n\t\t\t\t}\n\t\t\t\tif(s>=dp[i][j])\n\t\t\t\t\tdp[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tbool G=true;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(cop[i][j]!=dp[i][j])\n\t\t\t\t\tG=false;\n\t\t\t}\n\t\t}\n\t\tif(G==true)\n\t\t\tbreak;\n\t\tcount++;\n\t}\n\tcout<<count<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<queue>\nusing namespace std;\nint m[1000][1000],p[1000][1000]={0};\nint main(){\nint i,j,w,h,n,k,b[2]={1,-1},g=0,u=0,l=0,z=0;\nchar s[2001];\npair<int,int> e;\nqueue<pair<int,int> > q;\ncin>>h>>w;\nfor(i=0;i<h;i++){\n\tscanf(\"%s\",s);\n\tfor(j=0;j<w;j++){\n\t\tk=s[j];\n\t\tif(k>48&&k<58)m[i][j]=k-48;\n\t\telse m[i][j]=0;\n\t}\n}\nfor(i=1;i<h-1;i++){\n\tfor(j=1;j<w-1;j++){\n\t\tif(m[i][j]!=0){\n\t\tfor(n=i-1;n<=i+1;n++){\n\t\t\tfor(k=j-1;k<=j+1;k++){\n\t\t\t\tif(m[n][k]==0)p[i][j]++;\n\t\t\t}\n\t\t}\n\t\tif(m[i][j]<=p[i][j]){\n\t\t\te.first=i;\n\t\t\te.second=j;\n\t\t\tq.push(e);\n\t\t\tz++;\n\t\t}\n\t\t}\n\t}\n}\nfor(i=0;i<z;i++){\ne=q.front();\nq.pop();\nm[e.first][e.second]=0;\nq.push(e);\n}\nwhile(!q.empty()){\n\te=q.front();\n\tq.pop();\n\tm[e.first][e.second]=-1;\n\tfor(i=e.first-1;i<=e.first+1;i++){\n\t\tfor(j=e.second-1;j<=e.second+1;j++){\n\t\t\tp[i][j]++;\n\t\t}\n\t}\nif(z==l){\n\tz=u;\n\tl=0;\tu=0;\n\tg++;\n\t}\nl++;\n\tfor(i=0;i<2;i++){\n\t\tif(m[e.first+b[i]][e.second]<=p[e.first+b[i]][e.second]&&m[e.first+b[i]][e.second]>0){\n\t\t\te.first+=b[i];\tm[e.first][e.second]=0;\n\t\t\tq.push(e);\n\t\t\te.first-=b[i];\n\t\t\tu++;\n\t\t}\n\t\tif(m[e.first+b[i]][e.second+b[i]]<=p[e.first+b[i]][e.second+b[i]]&&m[e.first+b[i]][e.second+b[i]]>0){\n\t\t\te.first+=b[i];\n\t\t\te.second+=b[i];\tm[e.first][e.second]=0;\n\t\t\tq.push(e);\n\t\t\te.first-=b[i];\n\t\t\te.second-=b[i];\n\t\t\tu++;\n\t\t}\n\t\tif(m[e.first][e.second+b[i]]<=p[e.first][e.second+b[i]]&&m[e.first][e.second+b[i]]>0){\n\t\t\te.second+=b[i];\tm[e.first][e.second]=0;\n\t\t\tq.push(e);\n\t\t\te.second-=b[i];\n\t\t\tu++;\n\t\t}\n\t\tif(m[e.first+b[i]][e.second-b[i]]<=p[e.first+b[i]][e.second-b[i]]&&m[e.first+b[i]][e.second-b[i]]>0){\n\t\t\te.first+=b[i];\n\t\t\te.second-=b[i];\tm[e.first][e.second]=0;\n\t\t\tq.push(e);\n\t\t\te.first-=b[i];\n\t\t\te.second+=b[i];\n\t\t\tu++;\n\t\t}\n\t}\n}\ng++;\ncout<<g<<endl;\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\nstruct p{\n  int co,x,y;\n  p(int a,int b,int c){\n    co=a;\n    x=b;\n    y=c;\n  }\n};\nint a[1000][1000],b[1000][1000];\nint main (){\n  int h,w;\n  queue<p> Q; \n  char ch;\n  cin >>h>>w;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      cin >> ch;\n      if(ch == '.'){\n\ta[i][j] = -1;\n\tQ.push(p(0,j,i));\n      } else a[i][j] = ch-'0';\n      b[i][j] = 0;\n    }\n  }\n  int res = 0;\n  while( !Q.empty() ){\n    p np = Q.front();\n    Q.pop();\n    res = np.co;\n    for(int i=-1;i<=1;i++)\n      for(int j=-1;j<=1;j++){\n\tif(i==0 && j==0) continue;\n\tint nx = np.x+i;\n\tint ny = np.y+j;\n\tif(0>nx || nx>w-1 || 0>=ny || ny>h-1) continue;\n\tb[ny][nx]++;\n\tif(a[ny][nx] == b[ny][nx]) Q.push(p(np.co+1,nx,ny));\n      }\n  }\n  cout << res<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<iostream>\n#include<math.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<string>\n#include<cmath>\n#include<set>\n#include<stack>\n\nusing namespace std;\ntypedef unsigned long long ll;\n\nint h,w;\nint sa[1005][1005];\n\nint main(){\n    cin>>h>>w;\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            char c;\n            cin>>c;\n            if(c=='.')sa[i][j]=-1;\n            else sa[i][j]=c-'0';\n        }\n    }\n    int ans=0;\n    while(1){\n        int ch=false;\n        queue<pair<int, int> >q;\n        for(int i=1;i<h-1;i++){\n            for(int j=1;j<w-1;j++){\n                if(sa[i][j]==-1)continue;\n                int c=0;\n                if(sa[i-1][j-1]==-1)c++;\n                if(sa[i-1][j]==-1)c++;\n                if(sa[i-1][j+1]==-1)c++;\n                if(sa[i][j-1]==-1)c++;\n                if(sa[i][j]==-1)c++;\n                if(sa[i][j+1]==-1)c++;\n                if(sa[i+1][j-1]==-1)c++;\n                if(sa[i+1][j]==-1)c++;\n                if(sa[i+1][j+1]==-1)c++;\n                if(sa[i][j]<=c){\n                    q.push(make_pair(i,j));\n                    ch=true;\n                }\n            }\n        }\n        while(!q.empty()){\n            pair<int, int>p=q.front();\n            q.pop();\n            sa[p.first][p.second]=-1;\n        }\n        if(!ch)break;\n        ans++;\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n//#include<string.h>\nusing namespace std;\nstruct log{\n\tint x,y;\n};\nqueue <log> cls;\nqueue <log> q;\nlog g;\nlong h,w,ans=0,length;\nchar sand[1004][1004];\nint main(){\n\tcin>>h>>w;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int o=0;o<w;o++){\n\t\t\tcin>>sand[i][o];\n\t\t\tif(sand[i][o]!='.'&&sand[i][o]!='9'){\n\t\t\t\tg.y=i;\n\t\t\t\tg.x=o;\n\t\t\t\tq.push(g);\n\t\t\t}\n\t\t}\n\t}\n\tint f,c,fx,fy,my[]={0,1,1,1,0,-1,-1,-1},mx[]={1,1,0,-1,-1,-1,0,1};\n\tdo{\n\t\tf=0;\n\t\twhile(!cls.empty()){\n\t\t\tg=cls.front();\n\t\t\tcls.pop();\n\t\t\tsand[g.y][g.x]='.';\n\t\t}\n\t\t/*for(int i=0;i<h;i++){\n\t\t\tfor(int yu=0;yu<w;yu++){\n\t\t\t\tcout<<sand[i][yu];\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}*/\n\t\tlength=q.size();\n\t\tfor(int i=0;i<length;i++){\n\t\t\tg=q.front();\n\t\t\tq.pop();\n\t\t\tc=0;\n\t\t\tfor(int r=0;r<8;r++){\n\t\t\t\tfx=g.x+mx[r];\n\t\t\t\tfy=g.y+my[r];\n\t\t\t\tif(fx>=0&&fx<w&&fy>=0&&fy<h&&sand[fy][fx]=='.'){\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(c>=sand[g.y][g.x]-48){\n\t\t\t\tcls.push(g);\n\t\t\t\t//cout<<sand[g.y][g.x]<<endl;\n\t\t\t\tf=1;\n\t\t\t}\n\t\t\telse if(c<sand[g.y][g.x]-48){\n\t\t\t\tq.push(g);\n\t\t\t}\n\t\t}\n\t\tif(f==1){\n\t\t\tans++;\n\t\t}\n\t}while(!cls.empty());\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n\n    int w,h;\n\n    cin >> w >> h;\n\n    int table[w][h],copy[w][h];\n\n    char c;\n\n    for(int i=0;i<w;i++){\n      for(int j=0;j<h;j++){\n        cin >> c;\n        if(c=='.'){\n          table[i][j] = -1;\n        }\n        else{\n          table[i][j] = atoi(&c);\n        }\n      }\n    }\n\n    bool flag = true;\n\n    int ans = -1;\n\n    while(flag){\n      ans++;\n      flag = false;\n      for(int i=1;i<w-1;i++){\n        for(int j=1;j<h-1;j++){\n\n          if(table[i][j]!=-1){\n\n            int count = 0;\n            if(table[i+1][j] == -1) count++;\n            if(table[i+1][j-1] == -1) count++;\n            if(table[i+1][j+1] == -1) count++;\n            if(table[i][j-1] == -1) count++;\n            if(table[i][j+1] == -1) count++;\n            if(table[i-1][j] == -1) count++;\n            if(table[i-1][j+1] == -1) count++;\n            if(table[i-1][j-1] == -1) count++;\n\n            if(count >= table[i][j]){\n              flag = true;\n              copy[i][j] = -1;\n            }\n            else{\n              copy[i][j] = table[i][j];\n            }\n\n          }\n          else{\n            copy[i][j] = -1;\n          }\n        }\n      }\n\n      for(int i=0;i<w;i++){\n        for(int j=0;j<h;j++){\n          table[i][j] = copy[i][j];\n        }\n      }\n\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef double db;\nstring s[1000];\nll vx[8]={1,1,0,-1,-1,-1,0,1};\nll vy[8]={0,1,1,1,0,-1,-1,-1};\nll H,W;\nqueue<P> q;\nqueue<P> yaru;\nbool pushed[1000][1000];\nll N,nx,ny;\nll ans,cnt;\nint main()\n{\n\tscanf(\"%lld%lld\",&H,&W);\n\tfor(ll i=0;i<H;i++) cin>>s[i];\n\tfor(ll i=0;i<H;i++) for(ll j=0;j<W;j++) if(s[i][j]!='.') q.push(P(i,j));\n\t\n\tbool update=0;\n\twhile(q.size()){\n\t\tN=q.size();\n\t\tupdate=0;\n\t\tmemset(pushed,0,sizeof(pushed));\n\t\tfor(ll I=0;I<N;I++){\n\t\t\tP p=q.front();\n\t\t\tq.pop();\n\t\t\tif(s[p.first][p.second]=='.') continue;\n\t\t\tcnt=0;\n\t\t\tfor(ll i=0;i<8;i++){\n\t\t\t\tny=p.first+vy[i];\n\t\t\t\tnx=p.second+vx[i];\n\t\t\t\tif(0<=nx&&nx<W&&0<=ny&&ny<H&&s[ny][nx]=='.') cnt++;\n\t\t\t}\n\t\t\tif(cnt>=s[p.first][p.second]-'0'){\n\t\t\t\tyaru.push(P(p.first,p.second));\n\t\t\t\tupdate=1;\n\t\t\t}\n\t\t}\n\t\twhile(yaru.size()){\n\t\t\tP p=yaru.front();\n\t\t\tyaru.pop();\n\t\t\ts[p.first][p.second]='.';\n\t\t\tfor(ll i=0;i<8;i++){\n\t\t\t\tny=p.first+vy[i];\n\t\t\t\tnx=p.second+vx[i];\n\t\t\t\tif(0<=nx&&nx<W&&0<=ny&&ny<H&&s[ny][nx]!='.'&&s[ny][nx]!='9'&&!pushed[ny][nx]){\n\t\t\t\t\tpushed[ny][nx]=1;\n\t\t\t\t\tq.push(P(ny,nx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(update) ans++;\n\t}\n\t//for(ll i=0;i<H;i++) c\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct vec2{\n  int x;\n  int y;\n  vec2(int x,int y){\n    this->x = x;\n    this->y = y;\n  }\n};\n\nint main(){\n\n    int w,h;\n\n    cin >> w >> h;\n\n    int table[w][h],copy[w][h];\n\n    char c;\n\n    for(int i=0;i<w;i++){\n      for(int j=0;j<h;j++){\n        cin >> c;\n        if(c=='.'){\n          table[i][j] = -1;\n        }\n        else{\n          stringstream ss;\n          ss << c;\n          ss >> table[i][j];\n        }\n      }\n    }\n\n    bool flag = true;\n\n    int ans = 0,com=-1,sub,rep=-3;\n\n    queue<vec2> q1,q2;\n\n    for(int i=0;i<w;i++){\n      for(int j=0;j<h;j++){\n\n        if(table[i][j] != com && i != 0 && i != w-1 && j != 0 && j!= h-1){\n\n          int count = 0;\n          if(table[i+1][j] == com || table[i+1][j] == rep) count++;\n          if(table[i+1][j-1] == com || table[i+1][j-1] == rep) count++;\n          if(table[i+1][j+1] == com || table[i+1][j+1] == rep) count++;\n          if(table[i][j-1] == com) count++;\n          if(table[i][j+1] == com || table[i][j+1] == rep) count++;\n          if(table[i-1][j] == com) count++;\n          if(table[i-1][j+1] == com) count++;\n          if(table[i-1][j-1] == com) count++;\n\n          if(count >= table[i][j]){\n            table[i][j] = rep;\n            vec2 tmpvec(i-1,j-1);\n            q1.push(tmpvec);\n            tmpvec.y++;\n            q1.push(tmpvec);\n            tmpvec.y++;\n            q1.push(tmpvec);\n            tmpvec.x++;tmpvec.y-=2;\n            q1.push(tmpvec);\n            tmpvec.y+=2;\n            q1.push(tmpvec);\n            tmpvec.x++;tmpvec.y-=2;\n            q1.push(tmpvec);\n            tmpvec.y++;\n            q1.push(tmpvec);\n            tmpvec.y++;\n            q1.push(tmpvec);\n          }\n\n        }\n        else{\n          table[i][j] = com;\n        }\n      }\n    }\n\n    for(int i=1;i<w-1;i++){\n      for(int j=1;j<h-1;j++){\n\n        if(table[i][j] == rep){\n          table[i][j] = com;\n\n        }\n      }\n    }\n\n  /*  while(!q1.empty()){\n      cout << q1.front().x << \" \" << q1.front().y << endl;\n      q1.pop();\n    }\n    while(1){}*/\n\n    /*for(int i=0;i<w;i++){\n      for(int j=0;j<h;j++){\n        cout << table[i][j] << \" \";\n      }\n      cout << endl;\n    }\n    cout << endl;*/\n\n    while(1){\n\n      if(q1.empty()){\n        /*for(int i=0;i<w;i++){\n          for(int j=0;j<h;j++){\n            cout << table[i][j] << \" \";\n          }\n          cout << endl;\n        }\n        cout << endl;*/\n        ans++;\n        if(q2.empty()){\n          break;\n        }\n        else{\n\n          while(!q2.empty()){\n            q1.push(q2.front());\n            q2.pop();\n          }\n\n          for(int i=1;i<w-1;i++){\n            for(int j=1;j<h-1;j++){\n              if(table[i][j] == rep){\n                table[i][j] = com;\n              }\n            }\n          }\n\n        }\n      }\n\n      vec2 tmpvec = q1.front();\n      q1.pop();\n      int i = tmpvec.x;\n      int j = tmpvec.y;\n\n      if(table[i][j] > 0 && i != 0 && i != w-1 && j != 0 && j!= h-1){\n\n        int count = 0;\n\n        if(table[i+1][j] == com /*|| table[i+1][j] == rep*/) count++;\n        if(table[i+1][j-1] == com /*|| table[i+1][j-1] == rep*/) count++;\n        if(table[i+1][j+1] == com /*|| table[i+1][j+1] == rep*/) count++;\n        if(table[i][j-1] == com) count++;\n        if(table[i][j+1] == com /*|| table[i][j+1] == rep*/) count++;\n        if(table[i-1][j] == com) count++;\n        if(table[i-1][j+1] == com) count++;\n        if(table[i-1][j-1] == com) count++;\n\n\n\n        if(count >= table[i][j]){\n                  //cout << count << \" \" << table[i][j] << \" \" << i << \" \" << j << endl;\n          table[i][j] = rep;\n          vec2 tmpvec(i-1,j-1);\n          q2.push(tmpvec);\n          tmpvec.y++;\n          q2.push(tmpvec);\n          tmpvec.y++;\n          q2.push(tmpvec);\n          tmpvec.x++;tmpvec.y-=2;\n          q2.push(tmpvec);\n          tmpvec.y+=2;\n          q2.push(tmpvec);\n          tmpvec.x++;tmpvec.y-=2;\n          q2.push(tmpvec);\n          tmpvec.y++;\n          q2.push(tmpvec);\n          tmpvec.y++;\n          q2.push(tmpvec);\n        }\n      }\n\n    }\n\n\n\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define fr first\n#define sc second\ntypedef pair<int, int> Pii;\ntypedef vector<int> Vi;\nconst int INF = (1<<30);\nconst int dx[]={-1,0,1,1,1,0,-1,-1}, dy[]={-1,-1,-1,0,1,1,1,0};\n\nint main()\n{\n  int h, w;\n  int maps[1000][1000];\n  int cnt[1000][1000] = {0};\n  queue<Pii> q;\n\n  cin >> h >> w;\n  for(int i=0; i<h; i++) {\n    for(int j=0; j<w; j++) {\n      char c;\n      cin >> c;\n      if( c == '.' ) {\n\tmaps[i][j] = 0;\n\tfor(int l=0; l<8; l++) {\n\t  int nx = j+dx[l], ny = i+dy[l];\n\t  if( 0 <= nx && nx < w && 0 <= ny && ny < h ) {\n\t    cnt[ny][nx]++;\n\t  }\n\t}\n      }\n      else {\n\tmaps[i][j] = c - '0';\n\tq.push(Pii(i, j));\n      }\n    }\n  }\n\n  bool flag = true;\n  int ans = 0;\n  while( 1 ) {\n    vector<Pii> v;\n    flag = false;\n    int tmp = q.size();\n    for(int i=0; i<tmp; i++) {\n      Pii p = q.front(); q.pop();\n      int x = p.sc, y = p.fr;\n      if( maps[y][x] && maps[y][x] <= cnt[y][x] ) {\n\tflag = true;\n\tmaps[y][x] = 0;\n\tv.pb(Pii(y, x));\n      }\n    }\n  \n\n    if( !flag ) {\n      break;\n    }\n    for(int i=0; i<v.size(); i++) {\n      for(int l=0; l<8; l++) {\n\tint nx = v[i].sc+dx[l], ny = v[i].fr+dy[l];\n\tif( 0 <= nx && nx < w && 0 <= ny && ny < h ) {\n\t  cnt[ny][nx]++;\n\t  q.push(Pii(ny, nx));\n\t}\n      }\n    }\n \n    ans++;\n  }\n\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstring>\nusing namespace std;\n   \n#define MAX 100\n   \nint main(){\n    string S;\n    int n,m,t,sum,a,p=0;\n    sum=0;\n    short x[MAX][MAX];\n    short z[MAX][MAX];\n    short v[MAX][MAX];\n    memset(x,0,sizeof(x));\n    memset(z,0,sizeof(z));\n    char T[10]={'.','1','2','3','4','5','6','7','8','9'};\n    cin>>n>>m;\n    for(int i=1;i<=n;i++){\n        cin>>S;\n        for(int j=1;j<=m;j++){\n            for(int k=0;k<10;k++){\n                if(S[j-1]==T[k]){\n                    x[i][j]=k;\n                    if(k==0){\n                        for(int l=-1;l<=1;l++){\n                            for(int o=-1;o<=1;o++){\n                                z[i+l][j+o] += 1;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    while(true){\n        t=0;\n        sum++;\n        for(int i=2;i<n;i++){\n            for(int j=2;j<m;j++){\n                if(x[i][j]>=1 && z[i][j]>=x[i][j]){\n                    v[i][j] += 1;\n                    t++;\n                    for(int l=-1;l<=1;l++){\n                        for(int o=-1;o<=1;o++){\n                            v[i+l][j+o]+= 10;\n                        }\n                    }\n                }\n            }\n        }\n        if(t==0){\n            break;\n        }\n        for(int i=2;i<n;i++){\n            for(int j=2;j<m;j++){\n                if(v[i][j]%10>=1){\n                    x[i][j]=0;\n                }\n                z[i][j] += v[i][j]/10;\n                v[i][j]=0;\n            }\n        }\n    }\n    cout<<sum-1<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define vvvel vector<vvel>\nvoid mmin(int &a, int b) { a = min(a, b); }\nvoid mmax(int &a, int b){ a = max(a, b); }\nvoid sor(vel &v) { sort(v.begin(), v.end()); }\nint zero() { return 0; }\nsigned main() {\n\tint h, w;\n\tcin >> h >> w;\n\tvvel co(h, vel(w));\n\tvvel alch(h, vel(w, 0));\n\tfor (int i = 0; i < h; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tif (s[j] == '.') {\n\t\t\t\talch[i][j] = 1;\n\t\t\t\tco[i][j] = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tco[i][j] = s[j];\n\t\t\t\tco[i][j] -= 48;\n\t\t\t}\n\t\t}\n\t}\n\tvel queh(h*w);\n\tvel quew(h*w);\n\tint st = 0;\n\tint to = 0;\n\tfor (int i = 0; i < h; i++) {\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tif (alch[i][j] == 0) {\n\t\t\t\tfor (int k = i - 1; k <= i + 1; k++) {\n\t\t\t\t\tfor (int l = j - 1; l <= j + 1; l++) {\n\t\t\t\t\t\tco[i][j] -= alch[k][l];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (co[i][j] <= 0) {\n\t\t\t\t\tqueh[to] = i;\n\t\t\t\t\tquew[to] = j;\n\t\t\t\t\tto++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\twhile (to > st) {\n\t\tans++;\n\t\tint qto = to;\n\t\tfor (int in = st; in < to; in++){\n\t\t\tint chi = queh[in];\n\t\t\tint chj = quew[in];\n\t\t\tfor (int i = chi - 1; i <= chi + 1; i++) {\n\t\t\t\tfor (int j = chj - 1; j <= chj + 1; j++) {\n\t\t\t\t\tif (co[i][j] > 0) {\n\t\t\t\t\t\tco[i][j]--;\n\t\t\t\t\t\tif (co[i][j] <= 0) {\n\t\t\t\t\t\t\tqueh[qto] = i;\n\t\t\t\t\t\t\tquew[qto] = j;\n\t\t\t\t\t\t\tqto++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tst = to;\n\t\tto=qto;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef double db;\nstring s[1000];\nll vx[8]={1,1,0,-1,-1,-1,0,1};\nll vy[8]={0,1,1,1,0,-1,-1,-1};\nll H,W;\nqueue<P> q;\nqueue<P> yaru;\nbool pushed[1000][1000];\nll N,nx,ny;\nll ans,cnt;\nint main()\n{\n\tscanf(\"%lld%lld\",&H,&W);\n\tfor(ll i=0;i<H;i++) cin>>s[i];\n\tfor(ll i=0;i<H;i++) for(ll j=0;j<W;j++) q.push(P(i,j));\n\twhile(q.size()){\n\t\tN=q.size();\n\t\tans++;\n\t\tmemset(pushed,0,sizeof(pushed));\n\t\tfor(ll I=0;I<N;I++){\n\t\t\tP p=q.front();\n\t\t\tq.pop();\n\t\t\tif(s[p.first][p.second]=='.') continue;\n\t\t\tcnt=0;\n\t\t\tfor(ll i=0;i<8;i++){\n\t\t\t\tny=p.first+vy[i];\n\t\t\t\tnx=p.second+vx[i];\n\t\t\t\tif(0<=nx&&nx<W&&0<=ny&&ny<H&&s[ny][nx]=='.') cnt++;\n\t\t\t}\n\t\t\tif(cnt>=s[p.first][p.second]-'0') yaru.push(P(p.first,p.second));\n\t\t}\n\t\twhile(yaru.size()){\n\t\t\tP p=yaru.front();\n\t\t\tyaru.pop();\n\t\t\ts[p.first][p.second]='.';\n\t\t\tfor(ll i=0;i<8;i++){\n\t\t\t\tny=p.first+vy[i];\n\t\t\t\tnx=p.second+vx[i];\n\t\t\t\tif(0<=nx&&nx<W&&0<=ny&&ny<H&&s[ny][nx]!='.'&&s[ny][nx]!='9'&&!pushed[ny][nx]){\n\t\t\t\t\tpushed[ny][nx]=1;\n\t\t\t\t\tq.push(P(ny,nx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//for(ll i=0;i<H;i++) c\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<int, int> pint;\nqueue<pint> nowque, nexque;\nint h, w;\nint castle[1002][1002] = {};\nbool inq[1002][1002] = {};\nchar str[1001];\n\nconst int dir[9] = { -1,-1,0,1,1,0,-1,1,-1 };\ninline bool check(int i,int j)\n{\n\tif (castle[i][j] == 0)return false;\n\tint c = 0;\n\tfor (int k = 0; k < 8; ++k)\n\t{\n\t\tif (castle[i + dir[k]][j + dir[k + 1]] == 0)++c;\n\t}\n\tif (c >= castle[i][j])\n\t{\n\t\tinq[i][j] = true;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nint main()\n{\n\tscanf(\"%d %d\", &h, &w);\n\tfor (int i = 1; i <= h; ++i)\n\t{\n\t\tscanf(\"%s\",str);\n\t\tfor (int j = 1; j <= w; ++j)\n\t\t{\n\t\t\tcastle[i][j] = ((str[j - 1] == '.') ? 0 : (str[j - 1] - '0'));\n\t\t\tif (castle[i][j] == 0)\n\t\t\t{\n\t\t\t\tnowque.emplace(i, j);\n\t\t\t}\n\t\t}\n\t}\n\tint time = 0;\n\tfor (; true; ++time)\n\t{\n\t\twhile (!nowque.empty())\n\t\t{\n\t\t\tpint x = nowque.front(); nowque.pop();\n\t\t\tfor (int k = 0; k < 8; ++k)\n\t\t\t{\n\t\t\t\tif (!inq[x.first + dir[k]][x.second + dir[k + 1]])\n\t\t\t\t{\n\t\t\t\t\tif (check(x.first + dir[k], x.second + dir[k + 1]))\n\t\t\t\t\t{\n\t\t\t\t\t\tnexque.emplace(x.first + dir[k], x.second + dir[k + 1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnowque = nexque;\n\t\twhile (!nexque.empty())\n\t\t{\n\t\t\tpint y = nexque.front(); nexque.pop();\n\t\t\tcastle[y.first][y.second] = 0;\n\t\t}\n\t\tif (nowque.empty())break;\n\t}\n\tprintf(\"%d\\n\",time);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\ntypedef pair<int,int> PA;\ntypedef pair<PA,int> PPA;\nint main(){\n  int h,w;\n  char masu[50][50];\n  int suji[50][50]={};\n  queue<PPA> que;\n  PA p;\n  int sum = 0;\n  cin >> h >> w;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++){\n      cin >> masu[i][j];\n      if(masu[i][j] == '.'){\n\tfor(int k=-1;k<=1;k++)\n\t  for(int l=-1;l<=1;l++){\n\t    if(k==0 && l==0) continue;\n\t    int y = i+k;\n\t    int x = j+l;\n\t    if(y<0||y>=h||x<0||x>=w||masu[y][x]=='.') continue;\n\t    suji[y][x]++;\n\t  }\n      }\n    }\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++){\n      if(suji[i][j] >= masu[i][j]-'0' && masu[i][j]!='.'){\n\tque.push(PPA(PA(i,j),1));\n      }\n    }\n  queue<PA> queb;\n  while(!que.empty()){\n    p = que.front().first;\n    if(sum != que.front().second){\n      while(!queb.empty()){\n\tmasu[queb.front().first][queb.front().second] = '.';\n\tqueb.pop();\n      }\n      sum++;\n    }\n    que.pop();\n    queb.push(p);\n    for(int k=-1;k<=1;k++)\n      for(int l=-1;l<=1;l++){\n\tif(k==0 && l==0) continue;\n\tint y = p.first+k;\n\tint x = p.second+l;\n\tif(y<0||y>=h||x<0||x>=w||masu[y][x]=='.') continue;\n\tsuji[y][x]++;\n\tif(suji[y][x] == masu[y][x]-'0'){\n\t  que.push(PPA(PA(y,x),sum+1));\n\t}\n      }\n  }\n  cout << sum << endl;\n  return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define int long long int\n#define rep(a,b,c) for(int a=b;a<c;a++)\n#define repm(a,b,c) for(int a=(b-1);a>=c;a--)\n#define pb push_back\n#define str string\n#define sf(a) scanfs(\"%d\",&a)\n#define pb push_back\n#define mp make_pair\n#define Fi first\n#define Se second\n#define ALL(v) (v).begin(), (v).end()\n\nusing namespace std;\n\nconst int INF = 1e18 + 9;\nconst int Mod = 1e9 + 7;\ninline int replac(str s){double ans=0;rep(i,0,s.length()){ans+=(s[i]-'0')*pow(10,s.length()-i-1);}return (int)ans;}\ninline string numstr(int m){str s=\"\";while(m>0){char c;int a=m/10;if(a>0)a=m%(a*10);else a=m;c=(char)('0'+a);s+=c;m/=10;}str st=\"\";for(int i=s.size()-1;i>=0;i--){st+=s[i];}return st;}\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vii;\nint a[2000][2000];\n queue<pii> p1;\n queue<pii> p2;\nsigned main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int w,h;\n    cin >> h >> w;\n    memset(a,0,sizeof(a));\n    rep(i,0,h){\n        rep(j,0,w){\n            char c;\n            cin >> c;\n            if(c=='.'){\n                p1.push(mp(j,i));\n            }else{\n                //cout << c-'0' << endl;\n                a[i][j]=c-'0';\n            }\n        }\n    }\n    int dx[8]={0,1,0,-1,1,-1,-1,1};\n    int dy[8]={1,0,-1,0,1,-1,1,-1};\n    int ans=0;\n    while(!p1.empty()){\n        //if(p1.empty())break;\n        ans++;\n        while(!p1.empty()){\n            pii pa = p1.front();p1.pop();\n            rep(i,0,8){\n                int x=dx[i]+pa.first;\n                int y=dy[i]+pa.second;\n                if(x<0||y<0||x>=w||y>=h)continue;\n                ///a[y][x]--;\n                //cout << a[y][x];\n                if(a[y][x]==1){\n                   // cout << y << x << endl;\n                    p2.push(mp(x,y));\n                }\n                if(a[y][x]>0)a[y][x]--;\n            }\n        }\n        if(p2.empty())break;\n        ans++;\n        while(!p2.empty()){\n            pii pa = p2.front();p2.pop();\n            rep(i,0,8){\n                int x=dx[i]+pa.first;\n                int y=dy[i]+pa.second;\n                if(x<0||y<0||x>=w||y>=h)continue;\n                if(a[y][x]==1){\n                    p1.push(mp(x,y));\n                  //  cout << y << x << endl;\n                }\n                if(a[y][x]>0)a[y][x]--;\n            }\n        }\n    }\n    cout << ans-1 << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <string>\nusing namespace std;\n\nstruct p{\n  int co,x,y;\n  p(int a,int b,int c){\n    co=a;\n    x=b;\n    y=c;\n  }\n};\nint a[1000][1000],b[1000][1000];\nint main (){\n  int h,w;\n  queue<p> Q; \n  string s;\n  cin >>h>>w;\n  for(int i=0;i<h;i++){\n    cin >>s;\n    for(int j=0;j<w;j++){\n      if(s[j] == '.'){\n\ta[i][j] = -1;\n\tQ.push(p(0,j,i));\n      } else a[i][j] = s[j]-'0';\n      b[i][j] = 0;\n    }\n  }\n  int res = 0;\n  while( !Q.empty() ){\n    p np = Q.front();\n    Q.pop();\n    res = np.co;\n    for(int i=-1;i<=1;i++)\n      for(int j=-1;j<=1;j++){\n\tif(i==0 && j==0) continue;\n\tint nx = np.x+i;\n\tint ny = np.y+j;\n\tif(0>nx || nx>=w || 0>ny || ny>=h) continue;\n\tb[nx][ny]++;\n\tif(a[nx][ny] == b[nx][ny]) Q.push(p(np.co+1,nx,ny));\n      }\n  }\n  cout << res<<endl;\n  return 0;\n}\n    "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstring>\nusing namespace std;\n\nstring S[2000];\nint x[2000][2000];\nint z[2000][2000];\n\nint main() {\n\tint n, m;\n\tchar T[10] = { '.','1','2','3','4','5','6','7','8','9' };\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> S[i];\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tfor (int k = 0; k < 10; k++) {\n\t\t\t\tif (S[i][j] == T[k]) {\n\t\t\t\t\tx[i][j] = k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint t = 1;\n\tint p = 0;\n\tint sum=0;\n\twhile (t != 0) {\n\t\tmemset(z, 0, sizeof(z));\n\t\tt = 0;\n\t\tsum++;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tif (x[i][j] >= 1) {\n\t\t\t\t\tp = 0;\n\t\t\t\t\tfor (int k = -1; k <= 1; k++) {\n\t\t\t\t\t\tfor (int l = -1; l <= 1; l++) {\n\t\t\t\t\t\t\tif (x[i + k][j + l] == 0) {\n\t\t\t\t\t\t\t\tp++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (p >= x[i][j]) {\n\t\t\t\t\t\tz[i][j] = 1;\n\t\t\t\t\t\tt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tif (z[i][j] == 1) {\n\t\t\t\t\tx[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << sum-1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <queue>\nusing namespace std;\nchar field[2000][2000];\nint dx[] = {1,1,1,0,0,-1,-1,-1};\nint dy[] = {1,0,-1,1,-1,1,0,-1};\nint x,y,d,ans;\nqueue<int> str[3];\nint main()\n{\n    int h,w;\n    scanf(\"%d%d\",&h,&w);\n    ans = 0;\n    for(int i = 0; i < h; i++)\n    {\n        for(int j = 0; j < w + 1; j++)\n        {\n            scanf(\"%c\",&field[i][j]);\n        }\n    }\n    for(int i = 0; i < h + 1; i++)\n    {\n        for(int j = 1; j < w + 1; j++)\n        {\n            if(field[i][j] == '.')\n            {\n                str[0].push(i);\n                str[1].push(j);\n                str[2].push(0);\n            }\n        }\n    }\n    while(str[0].size())\n    {\n        x = str[0].front();str[0].pop();\n        y = str[1].front();str[1].pop();\n        d = str[2].front();str[2].pop();\n        if(ans < d)ans = d;\n        for(int i = 0; i < 8; i++)\n        {\n            if(0 <= x + dx[i]&&x + dx[i] < h&&0 <= y + dy[i]&&y + dy[i] < w)\n            {\n                field[x + dx[i]][y + dy[i]]--;\n                if(field[x + dx[i]][y + dy[i]] == '0')\n                {\n                    str[0].push(x + dx[i]);\n                    str[1].push(y + dy[i]);\n                    str[2].push(d + 1);\n                }\n            }\n        }\n    }\n    printf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rrep(i,n) for(int i=1;i<=n;i++)\n#define drep(i,n) for(int i=n;i>=0;i--)\n#define MAX 1006\n#define B 100\n#define dpb push_back\n#define fi first\n#define se second\ntypedef pair<int, int> P;\ntypedef long long ll;\nconst int inf = 1e9;\nconst ll INF = 1e16;\n//__gcd(a,b), __builtin_popcount(a);\n\nchar a[MAX][MAX];\nint fld1[MAX][MAX], fld2[MAX][MAX], flag[MAX][MAX];\nint dy[8] = {-1, -1, -1, 0, 0, 1, 1, 1};\nint dx[8] = {0, -1, 1, -1, 1, 0, -1, 1};\nqueue<P> q1, q2;\n\nint bfs1(){\n\tint check = 1;\n\trep(i,MAX)rep(j,MAX){\n\t\tif(fld2[i][j] <= 0)\n\t\tfld1[i][j] = fld2[i][j] = inf;\n\t\telse fld1[i][j] = fld2[i][j];\n\t}\n\twhile(!q2.empty()){\n\t\tP p = q2.front();q2.pop();\n\t\tint y = p.fi, x = p.se;\n\t\tif(fld2[y][x] == inf){\n\t\t\tfor(int i = 0;i < 8;i++){\n\t\t\t\tif(fld2[y+dy[i]][x+dx[i]] != inf){\n\t\t\t\t\tif(fld1[y+dy[i]][x+dx[i]] == fld2[y+dy[i]][x+dx[i]]){\n\t\t\t\t\t\tcheck = 0;\n\t\t\t\t\t\tq1.push(P(y+dy[i], x+dx[i]));\n\t\t\t\t\t}\n\t\t\t\t\tfld1[y+dy[i]][x+dx[i]]--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn check;\n}\n\nint bfs2(){\n\tint check = 1;\n\trep(i,MAX)rep(j,MAX){\n\t\tif(fld1[i][j] <= 0)\n\t\tfld1[i][j] = fld2[i][j] = inf;\n\t\telse fld2[i][j] = fld1[i][j];\n\t}\n\twhile(!q1.empty()){\n\t\tP p = q1.front();q1.pop();\n\t\tint y = p.fi, x = p.se;\n\t\tif(fld1[y][x] == inf){\n\t\t\tfor(int i = 0;i < 8;i++){\n\t\t\t\tif(fld1[y+dy[i]][x+dx[i]] != inf){\n\t\t\t\t\tif(fld2[y+dy[i]][x+dx[i]] == fld1[y+dy[i]][x+dx[i]]){\n\t\t\t\t\t\tcheck = 0;\n\t\t\t\t\t\tq2.push(P(y+dy[i], x+dx[i]));\n\t\t\t\t\t}\n\t\t\t\t\tfld2[y+dy[i]][x+dx[i]]--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn check;\n}\n\nint main(){\n\tint h, w;\n\tscanf(\"%d%d\", &h, &w);\n\tfill((int*)fld1, (int*)(fld1+MAX), inf);\n\tfill((int*)fld2, (int*)(fld2+MAX), inf);\n\trep(i,h)scanf(\"%s\", a[i]);\n\trrep(i,h)rrep(j,w){\n\t\tif(a[i-1][j-1] != '.')\n\t\tfld1[i][j] = fld2[i][j] = a[i-1][j-1]-'0';\n\t}\n\t\n\tfor(int y = 1;y <= h;y++){\n\t\tfor(int x = 1;x <= w;x++){\n\t\t\tif(fld1[y][x] == inf){\n\t\t\tfor(int i = 0;i < 8;i++){\n\t\t\t\t\n\t\t\t\tint yy = y+dy[i], xx = x+dx[i];\n\t\t\t\tif(fld1[yy][xx] != inf){\n\t\t\t\t\tif(flag[yy][xx] == 0){\n\t\t\t\t\t\tq2.push(P(yy, xx));\n\t\t\t\t\t}\n\t\t\t\t\tfld2[yy][xx]--;\n\t\t\t\t\tflag[yy][xx] = 1;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i = 0;i <= h;i++){\n\t\tfor(int j = 0;j <= w;j++){\n\t\t\tif(fld2[i][j] <= 0)fld2[i][j] = inf;\n\t\t}\n\t}\n\t\n\tint check = 1, ans = 0;\n\twhile(1){\n\t\tcheck = bfs1();\n\t\tif(check == 1)break;\n\t\tans++;\n\t\t//printf(\"*\\n\");\n\t\tcheck = bfs2();\n\t\tif(check == 1)break;\n\t\tans++;\n\t}\n\t/*while(!q1.empty()){\n\t\tP p = q1.front();q1.pop();\n\t\tprintf(\"%d %d\\n\", p.fi, p.se);\n\t}*/\n\t\n\t/*for(int i = 0;i <= h;i++){\n\t\tfor(int j = 0;j <= w;j++){\n\t\t\tprintf(\"%10d \", fld1[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\tprintf(\"\\n\");\n\tfor(int i = 0;i <= h;i++){\n\t\tfor(int j = 0;j <= w;j++){\n\t\t\tprintf(\"%10d \", fld2[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}*/\n\t\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<tuple>\nusing namespace std;\nint x[1005][1005], H, W; bool J[1005][1005];\nint solve(int r, int s) {\n\tif (r <= 0 || s <= 0 || r > H || s > W)return 0; int B = 0;\n\tfor (int i = -1; i <= 1; i++) { for (int j = -1; j <= 1; j++) { if (x[r + i][s + j] == 0)B++; } }\n\treturn B;\n}\nint main() {\n\tcin >> H >> W; queue<tuple<int, int, int>>Q;\n\tfor (int i = 1; i <= H; i++) { for (int j = 1; j <= W; j++) { char c; cin >> c; if (c == '.')x[i][j] = 0; else { x[i][j] = c - '0'; } } }\n\tvector<pair<int, int>>vec1;\n\tfor (int i = 1; i <= H; i++) {\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tif (solve(i, j) >= x[i][j] && x[i][j] != 0) { vec1.push_back(make_pair(i, j)); J[i][j] = true; Q.push(make_tuple(i, j, 1)); }\n\t\t}\n\t}\n\tif (vec1.size() == 0) { cout << \"0\" << endl; return 0; }int Life = 1;\n\tfor (int i = 0; i < vec1.size(); i++) { x[vec1[i].first][vec1[i].second] = 0; }vec1.clear();\n\twhile (!Q.empty()) {\n\t\tint a1 = get<0>(Q.front()), a2 = get<1>(Q.front()), a3 = get<2>(Q.front()); Q.pop();\n\t\tif (a3 != Life) {\n\t\t\tfor (int i = 0; i < vec1.size(); i++) { x[vec1[i].first][vec1[i].second] = 0; }\n\t\t\tvec1.clear(); Life++;\n\t\t}\n\t\tfor (int i = -1; i <= 1; i++) {\n\t\t\tfor (int j = -1; j <= 1; j++) {\n\t\t\t\tif (solve(a1 + i, a2 + j) >= x[a1 + i][a2 + j] && x[a1 + i][a2 + j] != 0 && J[a1 + i][a2 + j] == false) {\n\t\t\t\t\tvec1.push_back(make_pair(a1 + i, a2 + j)); J[a1 + i][a2 + j] = true;\n\t\t\t\t\tQ.push(make_tuple(a1 + i, a2 + j, a3 + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << Life << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <map>\n#define FLAG -1\nusing namespace std;\ntypedef pair<int,int> P;\nint main(){\n      int h,w,dh[] = {1,1,1,0,-1,-1,-1,0}, dw[] = {1,0,-1,-1,-1,0,1,1},ctn,i,j;\n      int solve = -1 ;\n      cin >> h >> w;\n      queue<P> que,tmp;\n      char d[h][w];\n      for(i=0;i<h;i++){\n            for(j=0;j<w;j++)\n            {\n                  cin >> d[i][j];\n                  if('1'<=d[i][j]&&'9'>=d[i][j])\n                        que.push(make_pair(i,j));\n            }\n      }\n\n      que.push(make_pair(FLAG,FLAG));\n      for(;;){\n            solve++;\n            map<P,bool> m;\n            for(;;){\n                  //cout << que.size()<<endl;\n                  P p = que.front();\n                  que.pop();\n                  if(p.first==FLAG)\n                  {//cout <<\" break \"<<endl<<endl;\n                  break;\n                  }\n                  if(d[p.first][p.second]=='.')continue;\n                  ctn = 0;\n                  for(i = 0;i < 8;i++){\n                        if(d[p.first+dh[i]][p.second+dw[i]]=='.')ctn++;\n                  }\n\n                  if(ctn >= d[p.first][p.second]-'0'){\n                        tmp.push(p);\n                        for(j=0;j<8;j++)\n                        if(m.count(make_pair(p.first+dh[j],p.second+dw[j]))==0){\n                        que.push(make_pair(p.first+dh[j],p.second+dw[j]));\n                        m[make_pair(p.first+dh[j],p.second+dw[j])]=true;\n                        }\n                  }\n            }\n            if(tmp.empty())break;\n            while(!tmp.empty())\n            {\n                  d[tmp.front().first][tmp.front().second]='.';\n                  tmp.pop();\n            }\n            /*for(i =0 ;i<h;i++)\n            {\n                  for(j=0;j<w;j++)cout << d[i][j];\n                  cout <<endl;\n            }\n            */\n\n            que.push(make_pair(FLAG,FLAG));\n\n      }\n      cout << solve << endl;\n}"
  },
  {
    "language": "C++",
    "code": "     #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n//  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x,y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tdouble x;\n                                            \tint y,z,w;\n                                            \tpa4(double x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n/*\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n */                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\n                                \n                int pr[500010];\n                int inv[500010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n                                         //----------------kokomade tenpure------------\n                //vector<double> ans(100000000),ans2(100000000)\n      \nint ban[1010][1010]={0};\n\nset<pa> kouho,nxkouho,ok;\n\nbool ch(pa z){\n\tint i=z.first,j=z.second;\n\tint rou=0;\n  \t\tfor(int r=0;r<8;r++)if(ban[i+dx[r]][j+dy[r]]==0)rou++;\n  \t\treturn rou>=ban[i][j];\n}\n\n  signed main(){\n    \t       cin.tie(0);\n    \t\t\tios::sync_with_stdio(false);\nint n,m;\n  \tcin>>n>>m;\n\n  \tfor(int i=0;i<n;i++){\n  \t\tstring s;\n  \t\tcin>>s;\n  \t\tfor(int j=0;j<m;j++)if(s[j]!='.')ban[i][j]=s[j]-'0';\n  \t}\n  \t\n  \tfor(int i=1;i<n-1;i++)for(int j=1;j<m-1;j++)if(ban[i][j]){\n  \t\tint rou=0;\n  \t\tfor(int r=0;r<8;r++)if(ban[i+dx[r]][j+dy[r]]==0)rou++;\n  \t\tif(rou>=ban[i][j])nxkouho.insert(mp(i,j));\n  \t\t\n  \t}\n  \tint ans=0;\n  \twhile(1){\n  \t\tkouho=nxkouho;\n  \t\tnxkouho.clear();\n  \t\tok.clear();\n  \t\tfor(auto it=kouho.begin();it!=kouho.end();it++){\n  \t\t\tif(ch(*it))ok.insert(*it);\n  \t\t}\n  \t\tif(ok.size()==0){\n  \t\t\tcout<<ans<<endl;\n  \t\t\treturn 0;\n  \t\t}\n  \t\tfor(auto it=ok.begin();it!=ok.end();it++)ban[(*it).first][(*it).second]=0;\n  \t\tfor(auto it=ok.begin();it!=ok.end();it++){\n  \t\t\tint i=(*it).first,j=(*it).second;\n  \t\t\tfor(int r=0;r<8;r++)if(ban[i+dx[r]][j+dy[r]])nxkouho.insert(mp(i+dx[r],j+dy[r]));\n  \t\t}\n  \t\t\n  \t\t\n  \t\t\n  \t\tans++;\n  \t}\n  \treturn 0;\n    }\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<map>\n#include<queue>\n#include<vector>\nusing namespace std;\n#define INF 1000000000\ntypedef pair<int,int> P;\ntypedef long long int ll;\nqueue<P> que[2];\nchar mas[1001][1001];\nint cou[1001][1001]={{0}};\n\nint main(){\n\tint h,w;\n\tint ans=0;\n\tcin >> h >> w;\n\tfor(int i=0;i<h;i++){\n\t\tscanf(\"%s\",mas[i]);\n\t}\n\tfor(int i=1;i<h-1;i++){\n\t\tfor(int j=1;j<w-1;j++){\n\t\t\tfor(int k=-1;k<=1;k++){\n\t\t\t\tfor(int o=-1;o<=1;o++){\n\t\t\t\t\tint nx = i + k;\n\t\t\t\t\tint ny = j + o;\n\t\t\t\t\tif(mas[nx][ny]=='.') cou[i][j]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(mas[i][j]!='.' && cou[i][j]>=mas[i][j]-'0') que[ans].push(P(i,j));\n\t\t}\n\t}\n\twhile(!que[ans%2].empty()){\n\t\twhile(!que[ans%2].empty()){\n\t\t\tP p = que[ans%2].front(); que[ans%2].pop();\n\t\t\tint x = p.first;\n\t\t\tint y = p.second;\n\t\t\tfor(int i=-1;i<=1;i++){\n\t\t\t\tfor(int j=-1;j<=1;j++){\n\t\t\t\t\tint nx = x + i;\n\t\t\t\t\tint ny = y + j;\n\t\t\t\t\tcou[nx][ny]++;\n\t\t\t\t\tif(mas[nx][ny]!='.' && cou[nx][ny]==mas[nx][ny]-'0') que[(ans+1)%2].push(P(nx,ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans++;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define fi first\n#define se second\nconst int inf = 1e9;\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define rrep(i,n) for(int i = 1;i <= n;i++)\ntypedef pair<int,int> P;\n\nqueue<P> q1, q2;\nchar str[1004][1004];\nint a[1004][1004], b[1004][1004], h, w;\nint dy[] = {-1, -1, -1, 0, 0, 1, 1, 1};\nint dx[] = {-1, 0, 1, -1, 1, -1, 0, 1};\nbool ok(int y, int x){\n\tif(y < 0 || h+1 < y)return 1;\n\tif(x < 0 || w+1 < x)return 1;\n\treturn 0;\n}\n\nvoid calc(int y, int x){\n\tif(b[y][x] || !a[y][x] || ok(y, x))return ;\n\tif(a[y][x] != inf){\n\t\ta[y][x]--;\n\t\tif(!a[y][x])q1.push(P(y, x));\n\t\treturn ;\n\t}\n\tb[y][x] = 1;\n\tfor(int i = 0;i < 8;i++){\n\t\tcalc(y+dy[i], x+dx[i]);\n\t}\n}\n\nint solve(int k){\n\tif(q1.empty())return 0;\n\twhile(!q1.empty()){\n\t\tP p = q1.front();q1.pop();\n\t\tb[p.fi][p.se] = 1;\n\t\tfor(int i = 0;i < 8;i++){\n\t\t\tint yy = p.fi+dy[i], xx = p.se+dx[i];\n\t\t\tif(!b[yy][xx] && a[yy][xx] != inf && a[yy][xx] != 0){\n\t\t\t\ta[yy][xx]--;\n\t\t\t\tif(a[yy][xx] == 0)q2.push(P(yy, xx));\n\t\t\t}\n\t\t}\n\t}\n\tswap(q1, q2);\n\treturn k+1;\n}\n\nint main(){\n\tfill((int*)a, (int*)(a+1004), inf);\n\tscanf(\"%d%d\", &h, &w);\n\trep(i,h)scanf(\"%s\", str[i]);\n\trep(i,h)rep(j,w){\n\t\tif(str[i][j] != '.')\n\t\ta[i+1][j+1] = str[i][j]-'0';\n\t}\n\t\n\tint res = 0, ans = 1;\n\trrep(i,h)rrep(j,w)if(a[i][j] == inf)calc(i, j);\n\twhile(1){\n\t\tres = solve(res);\n\t\tif(res == 0)break;\n\t\tans = res;\n\t}\n\tprintf(\"%d\\n\", ans);\n\t\n\t/*for(int i = 1;i <= h;i++){\n\t\tfor(int j = 1;j <= w;j++)printf(\"%d \", a[i][j]);\n\t\tprintf(\"\\n\");\n\t}*/\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define REP(i,n) for(int i=0;i<n;i++)\n#define ARR(i,j) for(int i=-1;i<=1;i++)for(int j=-1;j<=1;j++)if(i!=0||j!=0)\ntypedef pair<int,int> P;\n\nint h,w;\nchar a[1002][1002];\nint kd[1002][1002];\nint sr[1002][1002];\nqueue<P> now;\nqueue<P> nxt;\n\nsigned main(){\n  cin>>h>>w;\n  REP(i,h)REP(j,w)cin>>a[i][j];\n  REP(i,h)REP(j,w){\n    if(i==0||i==h-1||j==0||j==w-1)continue;\n    if(a[i][j]!='.'){\n      kd[i][j]=a[i][j]-'0';\n      ARR(dx,dy)if(a[i+dx][j+dy]=='.')sr[i][j]++;\n      if(sr[i][j]>=kd[i][j])nxt.push(P(i,j));\n    }\n  }\n  int res=0;\n  while(!nxt.empty()){\n    res++;\n    swap(now,nxt);\n    while(!now.empty()){\n      P p=now.front();now.pop();\n      if(a[p.first][p.second]=='.')continue;\n      a[p.first][p.second]='.';\n      nxt.push(p);\n    }\n    swap(now,nxt);\n    while(!now.empty()){\n      P p=now.front();now.pop();\n      ARR(dx,dy){\n        int qx=p.first+dx;\n        int qy=p.second+dy;\n        sr[qx][qy]++;\n        if(a[qx][qy]!='.'&&sr[qx][qy]>=kd[qx][qy])nxt.push(P(qx,qy));\n      }\n    }\n  }\n  cout<<res<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <queue>\n#include <Windows.h>\n\nusing namespace std;\n\nint x, y;\nchar m[1024][1024];\nint map[1024][1024];\nqueue<pair<int, pair<int, int> > > q;\npair<int, pair<int, int> > temp;\n\n\nint dx[8] = { 0, 0, 1, -1, 1, -1, 1, -1 }, dy[8] = { 1, -1, 0, 0, -1, -1, 1, 1 };\n\nvoid check_map() {\n\n\tfor (int i = 0; i < y; i++) {\n\t\tfor (int i1 = 0; i1 < x; i1++) {\n\t\t\tint cnt = 0;\n\t\t\tif (m[i][i1] == '.') {\n\t\t\t\tmap[i][i1] = 0;\n\t\t\t\tq.push(make_pair(0, make_pair(i, i1)));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmap[i][i1] = m[i][i1] - '0';\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint cnt = 0;\n\n\tcin >> y >> x;\n\n\tfor (int i = 0; i < y; i++) {\n\t\tfor (int i1 = 0; i1 < x; i1++) {\n\t\t\tcin >> m[i][i1];\n\t\t}\n\t}\n\n\tcheck_map();\n\t\t\n\twhile (!q.empty()) {\n\n\t\ttemp = q.front();\n\n\t\tq.pop();\n\n\t\tcnt = temp.first;\n\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tif ((map[temp.second.first + dy[i]][temp.second.second + dx[i]] -= 1) == 0)\n\t\t\t\tq.push(make_pair(temp.first + 1, make_pair(temp.second.first + dy[i], temp.second.second + dx[i])));\n\t\t}\n\n\t}\n\n\tcout << cnt << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <algorithm>\nusing namespace std;\nint ary[1010][1010]={};\nint mwri(int y,int x){\n\tint cnt=0;\n\tif(ary[y-1][x-1]==0)cnt++;\n\tif(ary[y-1][x]==0)cnt++;\n\tif(ary[y-1][x+1]==0)cnt++;\n\tif(ary[y][x-1]==0)cnt++;\n\tif(ary[y][x+1]==0)cnt++;\n\tif(ary[y+1][x-1]==0)cnt++;\n\tif(ary[y+1][x]==0)cnt++;\n\tif(ary[y+1][x+1]==0)cnt++;\n\treturn cnt;\n}\n\nint main(){\n\tint H,W,cnt,are,ax,ay;\n\tchar tmp;\n\tbool isen;\n\tset<int> *sew,*sew2;\n\tset<int> se,se2,se3;\n\tset<int>::iterator it,it2;\n\tcin>>H>>W;\n\tfor(int i=0;i<H;i++){\n\t\tfor(int j=0;j<W;j++){\n\t\t\tcin>>tmp;\n\t\t\tif(tmp=='.') ary[i][j]=0;\n\t\t\telse ary[i][j]=tmp-'0';\n\t\t}\n\t}\n\n\t//??????????????\n\tisen=true;\n\tfor(int i=1;i<H-1;i++){\n\t\tfor(int j=1;j<W-1;j++){\n\t\t\tif(ary[i][j]!=0&&mwri(i,j)>=ary[i][j]){\n\t\t\t\tse3.insert(i*W+j);\n\t\t\t\tse.insert(i*W+j-1);\n\t\t\t\tse.insert(i*W+j+1);\n\t\t\t\tse.insert(i*W+j+W-1);\n\t\t\t\tse.insert(i*W+j+W);\n\t\t\t\tse.insert(i*W+j+W+1);\n\t\t\t\tse.insert(i*W+j-W-1);\n\t\t\t\tse.insert(i*W+j-W);\n\t\t\t\tse.insert(i*W+j-W+1);\n\t\t\t\tisen=false;\n\t\t\t\t//cout<<\"cc \"<<i<<\" \"<<j<<endl;//\n\t\t\t}\n\t\t}\n\t}\n\tif(isen){\n\t\tcout<<0<<endl;\n\t\treturn 0;\n\t}\n\tit=se3.begin();\n\twhile(se3.end()!=it){\n\t\tay=*it/W;\n\t\tax=*it%W;\n\t\tary[ay][ax]=0;\n\t\tit++;\n\t}\n\n\tcnt=0;\n\t//cout<<\"nnn\"<<endl;//\n\twhile(1){\n\tse3.clear();\n\tcnt++;\n\tisen=true;\n\tif(cnt%2==1){\n\t\tsew=&se;\n\t\tsew2=&se2;\n\t}\n\telse{\n\t\tsew=&se2;\n\t\tsew2=&se;\n\t}\n\t(*sew2).clear();\n\tit=(*sew).begin();\n\t\n\twhile(it!=(*sew).end()){\n\t\tare=*it;\n\t\tay=are/W;\n\t\tax=are%W;\n\t\tif(ary[ay][ax]!=0&&mwri(ay,ax)>=ary[ay][ax]){\n\t\t\tse3.insert(ay*W+ax);\n\t\t\t(*sew2).insert(ay*W+ax-1);\n\t\t\t(*sew2).insert(ay*W+ax+1);\n\t\t\t(*sew2).insert(ay*W+ax+W-1);\n\t\t\t(*sew2).insert(ay*W+ax+W);\n\t\t\t(*sew2).insert(ay*W+ax+W+1);\n\t\t\t(*sew2).insert(ay*W+ax-W-1);\n\t\t\t(*sew2).insert(ay*W+ax-W);\n\t\t\t(*sew2).insert(ay*W+ax-W+1);\n\t\t\tisen=false;\n\t\t\t//cout<<\"ccc \"<<ay<<\" \"<<ax<<endl;//\n\t\t}\n\t\tit++;\n\t}\n\tif(isen){\n\t\tcout<<cnt<<endl;\n\t\treturn 0;\n\t}\n\tit2=se3.begin();\n\twhile(se3.end()!=it2){\n\t\tay=*it2/W;\n\t\tax=*it2%W;\n\t\tary[ay][ax]=0;\n\t\tit2++;\n\t}\n\t//cout<<\"aaa\"<<endl;//\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<28;\nconst ll INF=1ll<<50;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst int mod=1e9+7;\nconst vi emp;\nconst int dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\nconst int DX[8]={-1,-1,-1,0,0,1,1,1},DY[8]={1,0,-1,1,-1,1,0,-1};\n\nint h,w;\nvvi a;\n\nint main(){\n\tcin>>h>>w;\n\ta=vvi(h,vi(w));\n\tfor(int i=0;i<h;i++) for(int j=0;j<w;j++){\n\t\tchar t;\n\t\tcin>>t;\n\t\tif(t!='.') a[i][j]=t-'0';\n\t}\n\tqueue<pip> q;\n\tfor(int i=0;i<h;i++) for(int j=0;j<w;j++) if(!a[i][j]) q.push(pip(1,P(i,j)));\n\tint ans=0;\n\twhile(!q.empty()){\n\t\tpip p=q.front();\n\t\tq.pop();\n\t\tint x=p.second.first,y=p.second.second;\n\t\tfor(int i=0;i<8;i++){\n\t\t\tint cx=x+DX[i],cy=y+DY[i];\n\t\t\tif(cx>=0&&cx<h&&cy>=0&&cy<w){\n\t\t\t\ta[cx][cy]--;\n\t\t\t\tif(!a[cx][cy]){\n\t\t\t\t\tans=p.first;\n\t\t\t\t\tq.push(pip(ans+1,P(cx,cy)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n \nint h, w, ans;\nint castle[1001][1001], times[1001][1001];\nint dx[] = {-1, 0, 1, -1, 1, -1, 0, 1}, dy[] = {-1, -1, -1, 0, 0, 1, 1, 1};\nchar beach[1001][1001];\n \nint main(){\n    scanf(\"%d%d\", &h, &w);\n    for(int i = 0; i < h; i++){\n        scanf(\"%s\", &beach[i]);\n    }\n \n    queue< pair<int, int> > Q;\n    for(int i = 0; i < h; i++){\n        for(int j = 0; j < w; j++){\n            if(beach[i][j] == '.'){\n                Q.push(P(i, j));\n            } else{\n                castle[i][j] = beach[i][j] - '0';\n            }\n        }\n    }\n \n    while(Q.size()){\n        P p = Q.front();\n        Q.pop();\n        ans = max(ans, times[p.first][p.second]);\n \n        for(int i = 0; i < 8; i++){\n            int y = p.first + dy[i], x = p.second + dx[i];\n            if(y < 0 || y >= h || x < 0 || x >= w){\n                continue;\n            }\n \n            castle[y][x]--;\n            if(castle[y][x] == 0){\n                Q.push(P(y, x));\n                times[y][x] = times[p.first][p.second] + 1;\n            }\n        }\n    }\n \n    printf(\"%d\\n\", ans);\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\nint dp[1000][1000];\nchar ddpp[1000][1000];\nint cop[1000][1000];\nint main(){\n\tint h,w;\n\tcin>>h>>w;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tcin>>ddpp[i][j];\n\t\t\tif(ddpp[i][j]=='.')\n\t\t\t\tdp[i][j]=0;\n\t\t\tif(ddpp[i][j]=='1')\n\t\t\t\tdp[i][j]=1;\n\t\t\tif(ddpp[i][j]=='2')\n\t\t\t\tdp[i][j]=2;\n\t\t\tif(ddpp[i][j]=='3')\n\t\t\t\tdp[i][j]=3;\n\t\t\tif(ddpp[i][j]=='4')\n\t\t\t\tdp[i][j]=4;\n\t\t\tif(ddpp[i][j]=='5')\n\t\t\t\tdp[i][j]=5;\n\t\t\tif(ddpp[i][j]=='6')\n\t\t\t\tdp[i][j]=6;\n\t\t\tif(ddpp[i][j]=='7')\n\t\t\t\tdp[i][j]=7;\n\t\t\tif(ddpp[i][j]=='8')\n\t\t\t\tdp[i][j]=8;\n\t\t\tif(ddpp[i][j]=='9')\n\t\t\t\tdp[i][j]=9;\n\t\t}\n\t}\n\tint count=0;\n\tif(h!=1000||w!=1000){\n\twhile(true){\n\t\tfor(int i=0;i<h;i++)\n\t\t\tfor(int j=0;j<w;j++)\n\t\t\t\tcop[i][j]=dp[i][j];\n\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tint s=0;\n\t\t\t\tif(j>0&&cop[i][j-1]==0)\n\t\t\t\t\ts++;\n\t\t\t\tif(j<w-1&&cop[i][j+1]==0)\n\t\t\t\t\ts++;\n\t\t\t\tif(i>0){\n\t\t\t\t\tif(cop[i-1][j]==0)\n\t\t\t\t\t    s++;\n\t\t\t\t\tif(j>0&&cop[i-1][j-1]==0)\n\t\t\t\t\t\ts++;\n\t\t\t\t\tif(j<w-1&&cop[i-1][j+1]==0)\n\t\t\t\t\t\ts++;\n\t\t\t\t}\n\t\t\t\tif(i<h-1){\n\t\t\t\t\tif(cop[i+1][j]==0)\n\t\t\t\t\t    s++;\n\t\t\t\t\tif(j>0&&cop[i+1][j-1]==0)\n\t\t\t\t\t\ts++;\n\t\t\t\t\tif(j<w-1&&cop[i+1][j+1]==0)\n\t\t\t\t\t\ts++;\n\t\t\t\t}\n\t\t\t\tif(s>=dp[i][j])\n\t\t\t\t\tdp[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tbool G=true;\n\t\tint i=0;\n\t\twhile(true){\n\t\t\tint j=0;\n\t\t\twhile(true){\n\t\t\t\tif(cop[i][j]!=dp[i][j])\n\t\t\t\t\tG==false;\n\t\t\t}\n\t\t\ti++;\n\t\t\tif(i==h)\n\t\t\t\tbreak;\n\t\t}\n\t\tif(G==true)\n\t\t\tbreak;\n\t\tcount++;\n\t}\n\t}\n\tif(count==0)\n\t\tcount=993949;\n\tcout<<count<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint H, W; char s[1009][1009]; bool vis[1009][1009];\nint main() {\n\tscanf(\"%d%d\", &H, &W);\n\tfor (int i = 0; i < H; i++) scanf(\"%s\", s[i]);\n\tvector<pair<int, int> > v;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (s[i][j] == '.' || s[i][j] == '9') continue;\n\t\t\tint cnt = 0;\n\t\t\tfor (int k = -1; k <= 1; k++) {\n\t\t\t\tfor (int l = -1; l <= 1; l++) {\n\t\t\t\t\tint tx = j + l, ty = i + k;\n\t\t\t\t\tif (0 <= tx && tx < W && 0 <= ty && ty < H && s[ty][tx] == '.') cnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (cnt >= s[i][j] - 48) v.push_back(make_pair(j, i));\n\t\t}\n\t}\n\tint ret = 0;\n\tfor (; !v.empty(); ret++) {\n\t\tfor (pair<int, int> i : v) s[i.second][i.first] = '.';\n\t\tvector<pair<int, int> > w;\n\t\tfor (pair<int, int> i : v) {\n\t\t\tint sx = i.first, sy = i.second;\n\t\t\tfor (int j = -1; j <= 1; j++) {\n\t\t\t\tfor (int k = -1; k <= 1; k++) {\n\t\t\t\t\tint tx = sx + k, ty = sy + j;\n\t\t\t\t\tif (!(0 <= tx && tx < W && 0 <= ty && ty < H)) continue;\n\t\t\t\t\tif (s[ty][tx] == '.' || s[ty][tx] == '9' || vis[ty][tx]) continue;\n\t\t\t\t\tint cnt = 0;\n\t\t\t\t\tfor (int l = -1; l <= 1; l++) {\n\t\t\t\t\t\tfor (int m = -1; m <= 1; m++) {\n\t\t\t\t\t\t\tint ux = tx + m, uy = ty + l;\n\t\t\t\t\t\t\tif (0 <= ux && ux < W && 0 <= uy && uy < H && s[uy][ux] == '.') cnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (cnt >= s[ty][tx] - 48) w.push_back(make_pair(tx, ty)), vis[ty][tx] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (pair<int, int> i : w) vis[i.second][i.first] = false;\n\t\tv = w;\n\t}\n\tprintf(\"%d\\n\", ret);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint a;\nint b;\nchar are[1001][1001];\nint kore[1001][1001];\nint sore[1001][1001];\nint sata[1001][1001];\nint ushi;\nint uma;\n\nint main(){\n\tcin >> a >> b;\n\tfor (int i = 0; i < a; i++){\n\t\tfor (int j = 0; j < b; j++){\n\t\t\tcin >> are[i][j];\n\t\t\tif (are[i][j] !='.'){\n\t\t\tkore[i - 1][j - 1]++;\n\t\t\tkore[i][j - 1]++;\n\t\t\tkore[i + 1][j - 1]++;\n\t\t\tkore[i - 1][j]++;\n\t\t\tkore[i + 1][j]++;\n\t\t\tkore[i - 1][j + 1]++;\n\t\t\tkore[i][j + 1]++;\n\t\t\tkore[i + 1][j + 1]++;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < a; i++){\n\t\tfor (int j = 0; j < b; j++){\n\t\t\tsore[i][j] = kore[i][j];\n\t\t\tsata[i][j] = 1;\n\t\t//\tcout<<sore[i][j];\n\t\t}\n\t}\n\twhile (true){\n\t\tuma = 0;\n\t\tfor (int i = 1; i < a-1; i++){\n\t\t\tfor (int j = 1; j < b-1; j++){\n\t\t\t\tif (sata[i - 1][j - 1] ==1||sata[i][j - 1] == 1||sata[i + 1][j - 1] == 1||sata[i - 1][j] == 1||sata[i + 1][j] == 1||sata[i - 1][j + 1] == 1||sata[i][j + 1] == 1||sata[i + 1][j + 1] == 1){\n\t\t\t\t\t//cout<<are[i][j]<<\" \"<<9-sore[i][j]<<endl;\n\t\t\t\t\tif (are[i][j] != '.'&&9-sore[i][j] > are[i][j]-48){\n\t\t\t\t\t//cout<<1234<<endl;\n\t\t\t\t\t\tare[i][j] = '.';\n\t\t\t\t\t\tkore[i - 1][j - 1]--;\n\t\t\t\t\t\tkore[i][j - 1]--;\n\t\t\t\t\t\tkore[i + 1][j - 1]--;\n\t\t\t\t\t\tkore[i - 1][j]--;\n\t\t\t\t\t\tkore[i + 1][j]--;\n\t\t\t\t\t\tkore[i - 1][j + 1]--;\n\t\t\t\t\t\tkore[i][j + 1]--;\n\t\t\t\t\t\tkore[i + 1][j + 1]--;\n\t\t\t\t\t\tuma = 1;\n\t\t\t\t\t\tsata[i][j] = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse{ sata[i][j] = 0; }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (uma == 1){\n\t\t\tushi++;\n\t\t}\n\t\tif (uma == 0){\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < a; i++){\n\t\t\tfor (int j = 0; j < b; j++){\n\t\t\t\tsore[i][j] = kore[i][j];\n\t\t\t}\n\t\t//cout<<\"po\"<<endl;\n\t\t}\n\t}\n\tcout << ushi << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n\nstring S[2000];\nint x[2000][2000];\nint z[2000][2000];\n\nint main() {\n\tint n, m;\n\tchar T[10] = { '.','1','2','3','4','5','6','7','8','9' };\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> S[i];\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tfor (int k = 0; k < 10; k++) {\n\t\t\t\tif (S[i][j] == T[k]) {\n\t\t\t\t\tx[i][j] = k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint t = 1;\n\tint p = 0;\n\tint sum=0;\n\twhile (t != 0) {\n\t\tmemset(z, 0, sizeof(z));\n\t\tt = 0;\n\t\tsum++;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tif (x[i][j] >= 1) {\n\t\t\t\t\tp = 0;\n\t\t\t\t\tfor (int k = -1; k <= 1; k++) {\n\t\t\t\t\t\tfor (int l = -1; l <= 1; l++) {\n\t\t\t\t\t\t\tif (x[i + k][j + l] == 0) {\n\t\t\t\t\t\t\t\tp++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (p >= x[i][j]) {\n\t\t\t\t\t\tz[i][j] = 1;\n\t\t\t\t\t\tt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tif (z[i][j] == 1) {\n\t\t\t\t\tx[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << sum-1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint data[1111][1111];\n\nvoid cnt(int x, int y){\n\n  for(int i=-1;i<2;i++){\n    for(int j=-1;j<2;j++){\n      if(y+i < 0 || x+j < 0) continue;\n      data[y+i][x+j]++;\n    }\n  }\n\n}\n\n\nint main(){\n\n  int h, w, ans = -1;\n\n  string s[1111];\n  typedef pair < int, int > P;\n  queue < P > que;\n  \n  cin >> h >> w;\n  for(int i=0;i<h;i++) cin >> s[i];\n\n  for(int i=0;i<h;i++) for(int j=0;j<w;j++) if(s[i][j] == '.') cnt(j, i);\n\n  //for(int i=0;i<h;i++, puts(\"\")) for(int j=0;j<w;j++) cout << data[i][j] << \" \";\n  while(!que.empty()) que.pop();\n  \n  do{\n\n    while(!que.empty()){\n      P p = que.front(); que.pop();\n      cnt(p.first, p.second);\n    }\n\n    \n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tif(s[i][j] != '.'){\n\t  int num = s[i][j] - '0';\n\t  if(num <= data[i][j]){ que.push( P(j, i) ); s[i][j] = '.'; }\n\t}\n      }\n    }\n\n    ans++;\n  }while(!que.empty());\n\n    cout << ans << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "/*************************\n\n\t\tPCK 2012 t1\n\n************************/\n\n/*#include <stdio.h>\nint main(){\n\n\tint s;\n\tint sum = 0;\n\tint i;\n\n\tfor ( i = 0; i < 10; i++){\n\t\tscanf(\"%d\", &s);\n\t\tsum += s;\n\t}\n\n\tprintf(\"%d\\n\", sum);\n}*/\n\n/************************\n\n\t\tPCK 2012 t2\n\n************************/\n/*\n#include <stdio.h>\nint main(){\n\n\tint b[3];\n\tint i;\n\tfor ( i = 0; i < 3; i++){\n\t\tscanf(\"%d\", &b[i]);\n\t}\n\n\tif (b[2] == 1)\n\t\tprintf(\"Open\\n\");\n\telse if (b[0] == 1){\n\t\tif (b[1] == 1)\n\t\t\tprintf(\"Open\\n\");\n\t\telse\n\t\t\tprintf(\"Close\\n\");\n\t}\n\telse\n\t\tprintf(\"Close\\n\");\n}*/\n\n/****************************\n\n\t\tPCK 2012 t3\n\n****************************/\n/*\n\t#include <stdio.h>\n\tint main(){\n\n\t\tint n;\n\t\tint h[101] = { 0 };\n\t\tint i;\n\t\tint temp;\n\n\t\tscanf(\"%d\", &n);\n\n\t\twhile (n != 0){\n\t\t\tfor (i = 0; i < n + 1; i++){\n\t\t\t\tscanf(\"%d\", &h[i]);\n\t\t\t}\n\n\t\t\tif ((h[1] - h[0]) + h[1] == h[2]){\n\t\t\t\ttemp = h[1] - h[0];\n\t\t\t\tfor (i = 1; i < n; i++){\n\t\t\t\t\tif (h[i] + temp != h[i + 1]){\n\t\t\t\t\t\tprintf(\"%d\\n\", h[i + 1]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif ((h[2] - h[1]) + h[2] == h[3])\n\t\t\t\t\tprintf(\"%d\\n\", h[0]);\n\t\t\t\telse if ((h[1] - h[0]) + h[2] != h[3])\n\t\t\t\t\tprintf(\"%d\\n\", h[2]);\n\t\t\t\telse\n\t\t\t\t\tprintf(\"%d\\n\", h[1]);\n\t\t\t}\n\n\t\t\tscanf(\"%d\", &n);\n\t\t}\n\t}\n*/\n\n/*************************************\n\n\t\t\tPCK 2012 t4\n\t\t\t\t\t\t(2???????????????????)\n*************************************/\n/*\n#include <stdio.h>\nint main(void)\n\n{\n\n\tint n;\n\tint num[4], l, s, count, i, j, temp;\n\tscanf(\"%d\", &n);\n\twhile (n != 0000){\n\t\tcount = 0;\n\t\twhile (n != 6174){\n\t\t\tnum[0] = n / 1000;\n\t\t\tnum[1] = (n - num[0] * 1000) / 100;\n\t\t\tnum[2] = (n - num[0] * 1000 - num[1] * 100) / 10;\n\t\t\tnum[3] = n - num[0] * 1000 - num[1] * 100 - num[2] * 10;\n\t\t\tif (num[0] == num[1] && num[1] == num[2] && num[2] == num[3]) //????????????????(1111??????7777??????)??????\n\t\t\t\tbreak;\n\t\t\tfor (i = 0; i<3; i++){\n\t\t\t\tfor (j = i + 1; j<4; j++){\n\t\t\t\t\tif (num[i]>num[j]){\n\t\t\t\t\t\ttemp = num[i];\n\t\t\t\t\t\tnum[i] = num[j];\n\t\t\t\t\t\tnum[j] = temp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ts = num[0] * 1000 + num[1] * 100 + num[2] * 10 + num[3];\n\t\t\tl = num[3] * 1000 + num[2] * 100 + num[1] * 10 + num[0];\n\t\t\tn = l - s;\n\t\t\tcount++;\n\t\t}\n\t\tif (n == 6174 || count>0)\n\t\t\tprintf(\"%d\\n\", count);\n\t\telse\n\t\t\tprintf(\"NA\\n\");\n\n\t\tscanf(\"%d\", &n);\n\t}\n\n\treturn 0;\n\n}*/\n\n/*************************************\n\n\t\t\tPCK 2012 t5\n\n*************************************/\n/*\n#include <stdio.h>\n#include <algorithm>\n\nint *p, *j;\n\nint bfs(int n,int ){\n\n\treturn max(n * )\n}\n\nint main(){\n\n\tint n;\n\n\tscanf(\"%d\", &n);\n\twhile (n != 0){\n\n\t\tp = new int[n];\n\t\tj = new int[n - 1];\n\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &p[i]);\n\t\tfor (int i = 0; i < n - 1; i++)\n\t\t\tscanf(\"%d\", &j[i]);\n\n\t\tscanf(\"%d\", &n);\n\t}\n}*/\n\n//PCK 2013 t4 ????????????????????????\n/*/\n#include <iostream>\nusing namespace std;\n#include <cstring>\n#include <algorithm>\n\nint main(){\n\n\tint n;\n\tint hand[100];\n\n\twhile (cin >> n && n != 0){\n\n\t\tmemset(hand, 0, sizeof(hand));\n\t\tint field = 0;\n\t\tint num = 0;\n\n\t\tfor (int i = 0; i < 100; i++){\n\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tif (c == 'M') hand[num]++;\n\t\t\telse if (c == 'S'){ field += hand[num] + 1; hand[num] = 0; }\n\t\t\telse { hand[num] += field + 1; field = 0; }\n\t\t\tif (num + 1 < n) num++; else num = 0;\n\t\t}\n\n\t\tsort(hand, hand + n);\n\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tcout << hand[i] << ' ';\n\t\tcout << field << endl;\n\t}\n}\n*/\n/*********************************************************************\n\n\tpck 2009 t1\t\t\t?????\\??????????????????????????\n\n*********************************************************************/\n/*\n#include <iostream>\nusing namespace std;\n\nint main(){\n\n\tint s1, s2;\n\n\twhile (cin >> s1 >> s2 && s1 != 0 && s2 != 0){\n\n\t\tint sum[5];\n\t\tint max;\n\t\tint num;\n\t\tsum[0] = s1 + s2;\n\t\tmax = sum[0];\n\t\tnum = 0;\n\t\tfor (int i = 1; i < 5; i++){\n\t\t\tcin >> s1 >> s2;\n\t\t\tsum[i] = s1 + s2;\n\t\t\tif (max < sum[i]){\n\t\t\t\tmax = sum[i];\n\t\t\t\tnum = i;\n\t\t\t}\n\t\t}\n\n\t\tcout << (char)('A' + num) << ' ' << max << endl;\n\t}\n}*/\n\n/******************************************************************************\n\n\tpck 2009 t3\t\t\t???????????-??????????????????????????????\n\n*******************************************************************************/\n/*\n#include <iostream>\nusing namespace std;\n#include <algorithm>\n\nint main(){\n\n\tint x, y;\n\twhile (cin >> x >> y && x != 0 && y != 0){\n\n\t\tif (y > x) swap(x, y);\n\t\tint count = 0;\n\t\twhile (y != 0){\n\t\t\tcount++;\n\t\t\tx = x % y;\n\t\t\tswap(x, y);\n\t\t}\n\n\t\tcout << x << ' ' << count << endl;\n\t}\n}\n*/\n\n/************************************************************\n\n\t\tPCK 2013 t3\t\t\t?????????????????????\n\n************************************************************/\n/*\n#include <iostream>\nusing namespace std;\n\nint main(){\n\n\tint n;\n\twhile (cin >> n && n != 0){\n\n\t\tint m = n;\n\t\tbool flg = false;\n\n\t\tint k;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\t\n\t\t\tcin >> k;\n\t\t\tif (k >= 2) flg = true;\n\t\t\tif (k == 0) m--;\n\t\t}\n\n\t\tif (flg)\n\t\t\tcout << m + 1 << endl;\n\t\telse cout << \"NA\" << endl;\n\t}\n}\n*/\n\n/*******************************************\n\n\t\tPCK 2013 t5\t\t\t????\n\n********************************************/\n/*\n#include <iostream>\nusing namespace std;\n\nint main(){\n\n\tint q;\n\tcin >> q;\n\tfor (int i = 0; i < q; i++){\n\n\t\tint c, a, n;\n\t\tint count = 0;\n\n\t\tcin >> c >> a >> n;\n\n\t\tfor (; c > 0 && a > 0 && n > 0; count++){\n\t\t\tc--; a--; n--;\n\t\t}\n\t\tfor (; c >= 2 && a > 0; count++){\n\t\t\tc -= 2; a--;\n\t\t}\n\t\tfor (; c >= 3; count++)\n\t\t\tc -= 3;\n\n\t\tcout << count << endl;\n\t}\n}\n*/\n\n/*****************************************************************\n\n\t\tPCK 2012 t1\t\t\t10???????????????????????????????\n\n*****************************************************************/\n/*\n#include <iostream>\nusing namespace std;\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\n\tint sum = 0;\n\tint s;\n\t\n\tfor (int i = 0; i < 10; i++){\n\t\n\t\tcin >> s;\n\t\tsum += s;\n\t}\n\n\tcout << sum << \"\\n\";\n}\n*/\n/*\n#include <stdio.h>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\nclass Game\n{\npublic:\n\tint k;   // ????????????????????????????\n\tint m;   // ?????????????????????????????????\n\tbitset <16> x;   // ?????????????????\n\tGame(int k1, int m1, bitset<16> x1)\n\t{\n\t\tk = k1;\n\t\tm = m1;\n\t\tx = x1;\n\t}\n};\n\nint main()\n{\n\tint i1, i2, m, m1, n=1, n1, n2, c=1, k, k1, max;\n\tbitset <16> x, y;\n\n\tscanf(\"%d %d\\n\", &n, &c);\n\twhile (n > 0) {\n\t\t// ??\\???\n\t\tbitset<16> a[n];\n\t\tfor (i1 = 0; i1 < n; i1++) {\n\t\t\tfor (i2 = 15; i2 >= 0; i2--) {\n\t\t\t\tscanf(\"%d\", &k);\n\t\t\t\ta[i1].set(i2, k);\n\t\t\t}\n\t\t}\n\t\tbitset<16> b[c];\n\t\tfor (i1 = 0; i1 < c; i1++) {\n\t\t\tfor (i2 = 15; i2 >= 0; i2--) {\n\t\t\t\tscanf(\"%d\", &k);\n\t\t\t\tb[i1].set(i2, k);\n\t\t\t}\n\t\t}\n\t\t// ??????\n\t\tmax = 0;\n\t\tstack<Game> st;\n\t\tst.push(Game(0, 0, a[0]));\n\t\twhile (!st.empty()) {\n\t\t\tk = st.top().k;\n\t\t\tm = st.top().m;\n\t\t\tx = st.top().x;\n\t\t\tst.pop();\n\t\t\tfor (i1 = 0; i1 < c; i1++) {\n\t\t\t\ty = x;\n\t\t\t\tn1 = y.count();\n\t\t\t\ty ^= b[i1];\n\t\t\t\ty &= x;\n\t\t\t\tn2 = y.count();\n\t\t\t\tm1 = m + n1 - n2;\n\t\t\t\tif (k == n - 1) {\n\t\t\t\t\tif (m1 > max)\n\t\t\t\t\t\tmax = m1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tk1 = k + 1;\n\t\t\t\t\ty |= a[k1];\n\t\t\t\t\tst.push(Game(k1, m1, y));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", max);\n\t\t// ??????????????\n\t\tscanf(\"%d %d\\n\", &n, &c);\n\t}\n\n\treturn 0;\n}\n*/\n/*\n#include<iostream>\nusing namespace std;\n\n#include<algorithm>\n#include<cstring>\n\nint main(){\n\n\tint n, m, a[101], b[101];\n\tint point[101];\n\tmemset(point, 0, sizeof(point));\n\n\tcin >> n >> m;\n\n\tfor (int i = 1; i <= m; i++)\n\t\tcin >> a[i];\n\tfor (int i = 1; i <= m; i++){\n\t\tfor (int j = 1; j <= n; j++){\n\t\t\tcin >> b[j];\n\t\t\tif (b[j] == a[i])point[j]++;\n\t\t\telse point[a[i]]++;\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++)\n\t\tcout << point[i] << endl;\n}*/\n/*\t\t\t\t\t\tJOI ?????\n#include<iostream>\nusing namespace std;\n#include<stdio.h>\nint map[1002][1002];\t//???????????????????\nint dat[1002][1002];\t//????????????????????????????????????????????????????\nint x[1000001], y[1000001];\t//[n]???????????????????????????????????????????????????\nint dx[4] = { 1,0,-1,0 };\t//???????????\nint dy[4] = { 0,1,0,-1 };\t//???????????\nint main()\n{\n\tint mx, my;\n\tscanf(\"%d%d\", &mx, &my);\n\tfor (int i = 0; i < mx + 2; i++) {\n\t\tfor (int j = 0; j < my + 2; j++) {\n\t\t\tmap[i][j] = 1000000000; dat[i][j] = 0;\t//?????????\n\t\t}\n\t}\n\tfor (int i = 0; i < mx; i++) {\n\t\tfor (int j = 0; j < my; j++) {\n\t\t\tscanf(\"%d\", &map[i + 1][j + 1]);\t//??\\???\n\t\t}\n\t}\n\tfor (int i = 1; i <= mx; i++) {\n\t\tfor (int j = 1; j <= my; j++) {\n\t\t\tx[map[i][j]] = i, y[map[i][j]] = j;\t//???????????????????????????????\n\t\t}\n\t}\n\tint c = 0;\t//??????????\n\tfor (int i = 1; i <= mx*my; i++){\t//???????\n\n\t\tint r = 0;\n\t\tfor (int j = 0; j < 4; j++){\t//4??????????????\n\t\t\n\t\t\tint a = x[i] + dx[j], b = y[i] + dy[j];\t//????????\n\t\t\tif (map[a][b] < i)\t//???????????????????? i ??\\?????????\n\t\t\t{\n\t\t\t\tif (r == 0)r = dat[a][b];\t//?????????????????????????????????\n\t\t\t\telse if (r != dat[a][b])r = -1;\t//????????????????????????????????????\n\t\t\t}\n\t\t}\n\t\tif (r == 0)dat[x[i]][y[i]] = i;\t//?????????????????????????????????????????\n\t\telse dat[x[i]][y[i]] = r;\t//????????????????????????????????????\n\t\tif (r == -1)c++;\t//??????????????\n\t}\n\tprintf(\"%d\\n\", c);\n}\n*/\n\n/*\tJOI 2006 ????? t2 ??????????????? */\n/*#include <iostream>\nusing namespace std;\n\nint main() {\n\tint n, k;\n\twhile (cin >> n >> k && n != 0 && k != 0) {\n\n\t}\n\n\treturn 0;\n}*/\n\n/* ??????????? */\n/*\n#include<iostream>\nusing namespace std;\n#include<vector>\n#include<algorithm>\n\nint main() {\n\tlong long int n;\n\tlong long int k;\n\twhile (cin >> n >> k && n != 0 && k != 0) {\n\t\tvector<long long int> v;\n\t\tv.push_back(0);\n\n\t\tfor (long long int i = 1; i <= n; ++i) {\n\t\t\tlong long int m;\n\t\t\tcin >> m;\n\t\t\tv.push_back(m);\n\t\t\tv[i] += v[i - 1];\n\t\t}\n\n\t\tlong long int sum = 0;\n\t\tfor (long long int i = 1; i + k <= n; ++i) {\n\t\t\tsum = max(sum, v[i + k] - v[i]);\n\t\t}\n\n\t\tcout << sum << endl;\n\t}\n\t\n\treturn 0;\n}*/\n\n/* JOI 2016 t3 ?????????????????? */\n/*\n#include<iostream>\nusing namespace std;\n\n#include<cstring>\n\nint map[102][102] = { 1 };\n\nint main(){\n\tmemset(map, 1, sizeof(map));\n\tint n, m, d;\n\tcin >> n >> m >> d;\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int i2 = 0; i2 < m; ++i2) {\n\t\t\tchar str;\n\t\t\tcin >> str;\n\t\t\tif (str == '.') { map[i][i2] = 0; }\n\t\t}\n\t}\n\n\tint cnt = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int i2 = 0; i2 < m; ++i2) {\n\t\t\tif (map[i][i2] == 0) {\n\n\t\t\t\tbool flg = true;\n\t\t\t\tfor (int j = 1; j < d; ++j) {\n\t\t\t\t\tif (map[i + j][i2] != 0) {\n\t\t\t\t\t\tflg = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (flg) { ++cnt; }\n\n\t\t\t\tflg = true;\n\t\t\t\tfor (int j = 1; j < d; ++j) {\n\t\t\t\t\tif (map[i][i2 + j] != 0) {\n\t\t\t\t\t\tflg = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (flg) { ++cnt; }\n\t\t\t}\n\t\t}\n\t}\n\tcout << cnt << endl;\n\n\treturn 0;\n}\n*/\n/*\n\n#include<iostream>\nusing namespace std;\n\n#include<string>\n\nint dp[101][101] = { 0 };\n\nint main(){\n\tstring s, t;\n\tcin >> s >> t;\n\n\tfor (int i = 0; i <= t.size(); ++i) { dp[i][0] = 0; }\n\tfor (int i = 0; i <= s.size(); ++i) { dp[0][i] = 1; }\n\n\tfor (int i = 1; i <= t.size(); ++i) {\n\t\tfor (int i2 = 1; i2 <= s.size(); ++i2) {\n\t\t\tif (t[i - 1] == s[i2 - 1]) {\n\t\t\t\tdp[i][i2] = dp[i - 1][i2 - 1] + dp[i][i2 - 1];\n\t\t\t}\n\t\t\telse dp[i][i2] = dp[i][i2 - 1];\n\t\t}\n\t}\t\n\n\tcout << dp[t.size()][s.size()] << endl;\n\t\n\treturn 0;\n}\n*/\n/*\n#include<iostream>\nusing namespace std;\n\n#include<algorithm>\n\nint a[100001];\n\nint main() {\n\tint n, k;\n\twhile (cin >> n >> k && n != 0 && k != 0) {\n\t\ta[0] = 0;\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tcin >> a[i];\n\t\t\ta[i] += a[i - 1];\n\t\t}\n\t\tint maxi = 0;\n\t\tfor (int i = k; i <= n; ++i) {\n\t\t\tmaxi = max(maxi, a[i] - a[i - k]);\n\t\t}\n\n\t\tcout << maxi << endl;\n\t}\n\n\treturn 0;\n}\n*/\n\n/* JOI 2010 ???????? */\n/*\n#include<iostream>\nusing namespace std;\n\n#include<algorithm>\n\nunsigned long long dp[21][101] = { 0 };\n\nint main() {\n\tunsigned long long n, num;\n\tcin >> n;\n\tfor (unsigned long long i = 0; i < n - 1; ++i) {\n\t\tcin >> num;\n\t\tif (i == 0) {\n\t\t\t++dp[num][i];\n\t\t}\n\t\telse {\n\t\t\tfor (unsigned long long j = 0; j <= 20; ++j) {\n\t\t\t\tif (dp[j][i - 1] != 0) {\n\t\t\t\t\tif (j + num >= 0 && j + num <= 20) {\n\t\t\t\t\t\tdp[j + num][i] += dp[j][i - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (j - num >= 0 && j - num <= 20) {\n\t\t\t\t\t\tdp[j - num][i] += dp[j][i - 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcin >> num;\n\tcout << dp[num][n - 2] << endl;\n\n\treturn 0;\n}\n*/\n\n/* JOI 2010 t5 ????????? */\n/*\n#include<iostream>\nusing namespace std;\n\n#include<queue>\n#include<cstring>\n\ntypedef unsigned long long int ullint;\n\nstruct Q {\n\tullint x;\n\tullint y;\n};\n\nQ In(ullint x, ullint y) { Q a; a.x = x; a.y = y; return a; }\n\nchar map[1002][1002];\nullint num[1003][1003] = { 0 };\n\nullint xm[] = { 0,0,-1,1 };\nullint ym[] = { -1,1,0,0 };\n\nint main() {\n\tullint h, w, n;\n\tQ st;\n\tcin >> h >> w >> n;\n\tfor (ullint i = 0; i <= h + 1; ++i) {\n\t\tfor (ullint i2 = 0; i2 <= w + 1; ++i2) {\n\t\t\tmap[i][i2] = 'X';\n\t\t}\n\t}\n\tfor (ullint i = 1; i <= h; ++i) {\n\t\tfor (ullint i2 = 1; i2 <= w; ++i2) {\n\t\t\tchar str;\n\t\t\tcin >> str;\n\t\t\tmap[i][i2] = str;\n\t\t\tif (str == 'S') { st.y = i; st.x = i2; }\n\t\t}\n\t}\n\n\tqueue<Q> que; que.push(st);\n\tullint number = 1;\n\tullint ans = 0;\n\tfor (number = 1; number <= n; ++number) {\n\t\twhile (!que.empty()) {\n\t\t\tQ now;\n\t\t\tnow = que.front();\n\t\t\tque.pop();\n\t\t\tullint memo = num[now.y][now.x];\n\t\t\tif (map[now.y][now.x] == '0' + number) {\n\t\t\t\tans += memo;\n\t\t\t\tfor (ullint i = 0; i <= h + 1; ++i) {\n\t\t\t\t\tfor (ullint i2 = 0; i2 <= w + 1; ++i2) {\n\t\t\t\t\t\tnum[i][i2] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile (!que.empty()) { que.pop(); }\n\t\t\t\tque.push(In(now.x, now.y));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (ullint i = 0; i < 4; ++i) {\n\t\t\t\tif (map[now.y + ym[i]][now.x + xm[i]] != 'X') {\n\t\t\t\t\tif (num[now.y + ym[i]][now.x + xm[i]] == 0) {\n\t\t\t\t\t\tnum[now.y + ym[i]][now.x + xm[i]] = memo + 1;\n\t\t\t\t\t\tque.push(In(now.x + xm[i], now.y + ym[i]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}\n*/\n\n/* JOI 2014 t3 ??????????? */\n/*\n#include<iostream>\nusing namespace std;\n#include<cstring>\n\nint main() {\n\tint h, w;\n\tint map[102][102];\n\tchar data[102][102];\n\tmemset(map, -1, sizeof(map));\n\n\tcin >> h >> w;\n\tfor (int i = 0; i < h; ++i) {\n\t\tfor (int i2 = 0; i2 < w; ++i2) {\n\t\t\tchar str;\n\t\t\tcin >> str;\n\t\t\tdata[i][i2] = str;\n\t\t\tif (data[i][i2] == 'c') {\n\t\t\t\tmap[i][i2] = 0;\n\t\t\t}\n\t\t\tif (data[i][i2] == '.') {\n\t\t\t\tif (i2 != 0) {\n\t\t\t\t\tif (map[i][i2 - 1] != -1) {\n\t\t\t\t\t\tmap[i][i2] = map[i][i2 - 1] + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < h; ++i) {\n\t\tfor (int i2 = 0; i2 < w; ++i2) {\n\t\t\tcout << map[i][i2];\n\t\t\tif (i2 < w - 1) {\n\t\t\t\tcout << \" \";\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n*/\n\n/* JOI 2014 t4 ?????????????????? */\n/*\n#include<iostream>\nusing namespace std;\n#include<cstring>\n#include<algorithm>\n\n#define INF 1000000001\n\ntypedef long long int llint;\n\nllint dp[1002][1002];\n\nint main() {\n\tllint n, m;\n\tllint d[1002];\n\tllint c[1002];\n\n\tmemset(dp, 0, sizeof(dp));\n\n\tcin >> n >> m;\n\tfor (llint i = 1; i <= n; ++i) {\n\t\tcin >> d[i];\n\t}\n\tfor (llint i = 1; i <= m; ++i) {\n\t\tcin >> c[i];\n\t}\n\n\tfor (llint day = 0; day <= m; ++day) {\n\t\tfor (llint num = 1; num <= n; ++num) {\n\t\t\tdp[day][num] = INF;\n\t\t}\n\t}\n\n\tfor (llint day = 1; day <= m; ++day) {\n\t\tfor (llint num = 1; num <= n; ++num) {\n\t\t\tdp[day][num] = min(dp[day - 1][num], dp[day - 1][num - 1] + c[day] * d[num]);\n\t\t}\n\t}\n\n\tcout << dp[m][n] << endl;\n\n\treturn 0;\n}\n*/\n/* JOI 2014 t5 ????????? */\n\n#include<iostream>\nusing namespace std;\n#include<queue>\n#include<cstring>\n\nstruct XY{\n\tint x;\n\tint y;\n};\n\nint map[1002][1002] = {};\nbool map_flg[1002][1002] = {};\n\nint xm[] = { -1,0,1,-1,1,-1,0,1 };\nint ym[] = { -1,-1,-1,0,0,1,1,1 };\n\nint main() {\n\tmemset(map, -1, sizeof(map));\n\tmemset(map_flg, true, sizeof(map_flg));\n\tint h, w;\n\tXY st;\n\tqueue<XY> que;\n\tcin >> h >> w;\n\tfor (int i = 1; i <= h; ++i) {\n\t\tfor (int i2 = 1; i2 <= w; ++i2) {\n\t\t\tchar str;\n\t\t\tcin >> str;\n\t\t\tif (str <= '9' || str > '0') {\n\t\t\t\tmap[i][i2] = str - '0';\n\t\t\t}\n\t\t\tif (str == '.') {\n\t\t\t\tmap[i][i2] = 0;\n\t\t\t\tst.y = i; st.x = i2;\n\t\t\t\tque.push(st);\n\t\t\t}\n\t\t}\n\t}\n\n\tqueue<XY> temp;\n\tint ans = 0;\n\tdo {\n\t\twhile (!que.empty()) {\n\t\t\tXY now = que.front();\n\t\t\tque.pop();\n\t\t\tmap_flg[now.y][now.x] = false;\n\t\t\tfor (int i = 0; i < 8; ++i) {\n\t\t\t\tif (map_flg[now.y + ym[i]][now.x + xm[i]]) {\n\t\t\t\t\tif(map[now.y + ym[i]][now.x + xm[i]] > 0) {\n\t\t\t\t\t\t--map[now.y + ym[i]][now.x + xm[i]];\n\t\t\t\t\t\tif (map[now.y + ym[i]][now.x + xm[i]] == 0) {\n\t\t\t\t\t\t\tXY next;\n\t\t\t\t\t\t\tnext.y = now.y + ym[i];\n\t\t\t\t\t\t\tnext.x = now.x + xm[i];\n\t\t\t\t\t\t\ttemp.push(next);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (temp.empty()) {\n\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t\t++ans;\n\t\t\twhile (!temp.empty()) {\n\t\t\t\tque.push(temp.front());\n\t\t\t\ttemp.pop();\n\t\t\t}\n\t\t}\n\t} while (1);\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\ntypedef int ll;\ntypedef pair<ll,ll> P;\ntypedef double db;\nstring s[1000];\nll vx[8]={1,1,0,-1,-1,-1,0,1};\nll vy[8]={0,1,1,1,0,-1,-1,-1};\nll H,W;\nqueue<P> q;\nqueue<P> yaru;\nbool pushed[1000][1000];\nll N,nx,ny;\nll ans,cnt;\nint main()\n{\n\tscanf(\"%d%d\",&H,&W);\n\tfor(ll i=0;i<H;i++) cin>>s[i];\n\tfor(ll i=0;i<H;i++) for(ll j=0;j<W;j++) if(s[i][j]!='.'&&s[i][j]!='9') q.push(P(i,j));\n\t\n\tbool update=0;\n\twhile(q.size()){\n\t\tN=q.size();\n\t\tupdate=0;\n\t\tmemset(pushed,0,sizeof(pushed));       \n\t\tfor(ll I=0;I<N;I++){\n\t\t\tP p=q.front();\n\t\t\tq.pop();\n\t\t\tif(s[p.first][p.second]=='.'||s[p.first][p.second]=='9') continue;\n\t\t\tcnt=0;\n\t\t\tfor(ll i=0;i<8;i++){\n\t\t\t\tny=p.first+vy[i];\n\t\t\t\tnx=p.second+vx[i];\n\t\t\t\tif(0<=nx&&nx<W&&0<=ny&&ny<H&&s[ny][nx]=='.') cnt++;\n\t\t\t}\n\t\t\tif(cnt>=s[p.first][p.second]-'0'){\n\t\t\t\tyaru.push(P(p.first,p.second));\n\t\t\t\tupdate=1;\n\t\t\t}\n\t\t}\n\t\twhile(yaru.size()){\n\t\t\tP p=yaru.front();\n\t\t\tyaru.pop();\n\t\t\ts[p.first][p.second]='.';\n\t\t\tfor(ll i=0;i<8;i++){\n\t\t\t\tny=p.first+vy[i];\n\t\t\t\tnx=p.second+vx[i];\n\t\t\t\tif(0<=nx&&nx<W&&0<=ny&&ny<H&&s[ny][nx]!='.'&&s[ny][nx]!='9'&&!pushed[ny][nx]){\n\t\t\t\t\tpushed[ny][nx]=1;\n\t\t\t\t\tq.push(P(ny,nx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(update) ans++;\n\t}\n\t//for(ll i=0;i<H;i++) c\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst double PI = acos(-1);\nusing ll = long long;\nusing ull = unsigned long long;\nconst int inf = 2e9;\nconst ll INF = 2e18;\nconst ll MOD = 1e9+7;\ntypedef pair<int,int> P;\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define sz(s) (s).size()\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n\nconst int d[] = {0, 1, 1, 0, -1, 1, -1, -1, 0};\n\nint main(){\n  int h, w;\n  scanf(\"%d%d\", &h, &w);\n  static int cell[1123][1123], stat[1123][1123];\n  REP(i, h) REP(j, w){\n    while(isspace(cell[i][j] = getchar()));\n    if(cell[i][j] == '.'){\n      cell[i][j] = -1;\n      stat[i][j] = -1;\n    }else{\n      cell[i][j] -= '0';\n      stat[i][j] = 0;\n    }\n  }\n\n  /*REP(i, h){\n    REP(j, w) putchar(cell[i][j]);\n    putchar('\\n');\n  }*/\n\n  set<P> next;\n  REP(i, h) REP(j, w) next.insert(mp(i, j));\n\n  for(int t = 0;; ++t){\n    set<P> next_;\n    vector<P> ochita;\n    for(auto i : next){\n      if(stat[i.fi][i.se] != -1){\n        int count = 0;\n        REP(j, 8){\n          if(stat[i.fi + d[j]][i.se + d[j + 1]] == -1) ++count;\n        }\n        if(count >= cell[i.fi][i.se]){\n          //stat[i.fi][i.se] = -1;\n          ochita.pb(mp(i.fi, i.se));\n          REP(k, 8){\n            next_.insert(mp(i.fi + d[k], i.se + d[k + 1]));\n          }\n        }\n      }\n    }\n    for(auto i : ochita) stat[i.fi][i.se] = -1;\n\n\n    if(next_.empty()){\n      printf(\"%d\\n\", t);\n      return 0;\n    }else{\n      next = next_;\n    }\n\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<queue>\n#include<string>\n#include<cstring>\n#include<algorithm>\n#include<ctype.h>\n#include<cstdio>\nusing namespace std;\ntypedef pair<int,int> P;\nint dx[8]={0,1,1,1,0,-1,-1,-1};\nint dy[8]={1,1,0,-1,-1,-1,0,1};\nint kyoudo[1003][1003]={0};\nchar masu[1003][1003];\nint check[1003][1003]={0};\nmain(){\n  int h,w;\n  queue<P> q;\n  queue<P> stacking;\n  int nowx,nowy;\n  P p,a;\n  cin>>h>>w;\n  for(int i=0;i<=h+1;i++){\n    for(int j=0;j<=w+1;j++){\n      if(i==0||j==0||i==h+1||j==w+1){\n\tkyoudo[i][j]=0;\n\tmasu[i][j]='.';\n\tp.first=i;\n\tp.second=j;\n\tq.push(p);\n\tcheck[i][j]=1;\n      }\n      else{\n\tcin>>masu[i][j];\n\tif(masu[i][j]!='.'){\n\t  kyoudo[i][j]=masu[i][j]-'0';\n\t}\n\telse{\n\t  kyoudo[i][j]=0;\n\t  p.first=i;\n\t  p.second=j;\n\t  q.push(p);\n\t  check[i][j]=1;\n\t}\n      }\n    }\n  }\n  int count=0;\n  while(!q.empty()){\n    while(!q.empty()){\n      p=q.front();\n      nowx=p.first;\n      nowy=p.second;\n      for(int k=0;k<8;k++){\n\tint nx,ny;\n\tnx=nowx+dx[k];\n\tny=nowy+dy[k];\n\tif(nx>=0&&nx<=w&&ny>=0&&ny<=h&&kyoudo[nx][ny]!=0&&kyoudo[nx][ny]!=9){\n\t  kyoudo[nx][ny]=kyoudo[nx][ny]-1;\n\t  if(check[nx][ny]==0&&kyoudo[nx][ny]==0&&masu[nx][ny]!='.'){\n\t    a.first=nx;\n\t    a.second=ny;\n\t    stacking.push(a);\n\t    check[nx][ny]=1;\n\t  }\n\t}\n      }\n      check[nowx][nowy]=1;\n      q.pop();\n    }\n    while(!stacking.empty()){\n      p=stacking.front();\n      masu[p.first][p.second]='.';\n      q.push(stacking.front());\n      stacking.pop();\n    }\n    count=count+1;\n  }\n  cout<<count-1<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int, int>P;\ntypedef long long ll;\n\nint h, w;\nchar ca[1000][1001];\nchar cpy[1000][1001];\nint cnt[1000][1000];\nbool b = 0;\nqueue<P> que[2];\n\nint main(){\n\tscanf(\"%d%d\", &h, &w);\n\trep(i, h)\n\t\tscanf(\"%s\", ca[i]);\n\trep(i, h){\n\t\trep(j, w){\n\t\t\tif (ca[i][j] == '.')continue;\n\t\t\tfor (int t = -1; t <= 1; t++)\n\t\t\t\tfor (int k = -1; k <= 1; k++)\n\t\t\t\t\tif (ca[i + t][j + k] == '.')\n\t\t\t\t\t\tcnt[i][j]++;\n\t\t\tif (cpy[i][j] != '.'&&ca[i][j] - '0' <= cnt[i][j]){\n\t\t\t\tcpy[i][j] = '.';\n\t\t\t\tque[b].push(P(i, j));\n\t\t\t}\n\t\t}\n\t}\n\tint res = 0;\n\twhile (!que[b].empty()){\n\t\tres++;\n\t\twhile (!que[b].empty()){\n\t\t\tP p = que[b].front(); que[b].pop();\n\t\t\tint f = p.first, s = p.second;\n\t\t\tfor (int i = -1; i <= 1; i++){\n\t\t\t\tfor (int j = -1; j <= 1; j++){\n\t\t\t\t\tint t = f + i, k = s + j;\n\t\t\t\t\tif (ca[t][k] == '.')continue;\n\t\t\t\t\tcnt[t][k]++;\n\t\t\t\t\tif (cpy[t][k] != '.'&&ca[t][k] - '0' <= cnt[t][k]){\n\t\t\t\t\t\tcpy[t][k] = '.';\n\t\t\t\t\t\tque[!b].push(P(t, k));\n\t\t\t\t\t}\n\t\t\t \t}\n\t\t\t}\n\t\t}\n\t\tb = !b;\n\t}\n\tprintf(\"%d\\n\", res );\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mp make_pair\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;//cnt, coodinate\nstring grid[1111];\nint neiber[1111][1111];\nint dx[] = {0, 1, 1,  1,  0, -1, -1, -1};\nint dy[] = {1, 1, 0, -1, -1, -1,  0,  1};\nint w, h;\nbool renge(int x, int y){\n  if(0 <= x && x < w &&\n     0 <= y && y < h)return true;\n  return false;\n}\nbool del(int x, int y){\n  int cnt = 0;\n  if(!(0 <= x && x < w &&\n       0 <= y && y < h))return false;\n  if(grid[y][x] == '.') return false;\n  for (int i = 0; i < 8; i++) {\n    int nx = x + dx[i], ny = y + dy[i];\n    if(!(0 <= nx && nx < w &&\n         0 <= ny && ny < h))continue;\n    if(grid[ny][nx] == '.')cnt++;\n  }\n  char tmp = grid[y][x];\n  neiber[y][x] = cnt;\n  if(cnt >= atoi(&tmp))return true;\n  else return false;\n}\n\nint main(int argc, char *argv[]){\n  queue<piii> que;\n  queue<pii> p;\n  cin >> h >> w;\n  for (int i = 0; i < h; i++) {\n    cin >> grid[i];\n  }\n  for (int i = 0; i < h; i++) {\n    for (int j = 0; j < w; j++) {\n      if(del(j, i)){\n        p.push(mp(j, i));\n        que.push(mp(1, mp(j, i)));\n      }\n    }\n  }\n  int ans = 0;\n  while(!que.empty()){\n    int cnt = que.front().first;\n    if(ans != cnt){\n      while(!p.empty()){\n        int x = p.front().first;\n        int y = p.front().second;\n        p.pop();\n        if(grid[y][x] == '.')continue;\n        grid[y][x] = '.';\n        for (int i = 0; i < 8; i++) {\n          int nx = x + dx[i], ny = y + dy[i];\n          if(!renge(nx, ny))continue;\n          neiber[ny][nx]++;\n        }\n      }\n    }\n    int x = que.front().second.first;\n    int y = que.front().second.second;\n    if(grid[y][x] == '.')continue;\n    que.pop();\n    ans = cnt;\n    for (int i = 0; i < 8; i++) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if(!renge(nx, ny))continue;\n      char tmp = grid[ny][nx];\n      if(neiber[ny][nx] >= atoi(&tmp) && grid[ny][nx] != '.'){\n        p.push(mp(nx, ny));\n        que.push(mp(cnt + 1, mp(nx, ny)));\n      }\n    }\n  }\n  std::cout << ans << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int, int>P;\ntypedef long long ll;\n\nint h, w;\nchar ca[1000][1001];\nchar cpy[1000][1001];\nint cnt[1000][1000];\nbool b = 0;\nqueue<P> que[2];\n\nint main(){\n\tscanf(\"%d%d\", &h, &w);\n\trep(i, h){\n\t\tscanf(\"%s\", ca[i]);\n\t\tstrcpy(cpy[i], ca[i]);\n\t}\n\trep(i, h){\n\t\trep(j, w){\n\t\t\tif (ca[i][j] == '.')continue;\n\t\t\tfor (int t = -1; t <= 1; t++)\n\t\t\t\tfor (int k = -1; k <= 1; k++)\n\t\t\t\t\tif (ca[i + t][j + k] == '.')\n\t\t\t\t\t\tcnt[i][j]++;\n\t\t\tif (cpy[i][j] != '.'&&ca[i][j] - '0' <= cnt[i][j]){\n\t\t\t\tcpy[i][j] = '.';\n\t\t\t\tque[b].push(P(i, j));\n\t\t\t}\n\t\t}\n\t}\n\tint res = 0;\n\twhile (!que[b].empty()){\n\t\tres++;\n\t\trep(i, h)\n\t\t\tstrcpy(ca[i], cpy[i]);\n\t\twhile (!que[b].empty()){\n\t\t\tP p = que[b].front(); que[b].pop();\n\t\t\tint f = p.first, s = p.second;\n\t\t\tfor (int i = -1; i <= 1; i++){\n\t\t\t\tfor (int j = -1; j <= 1; j++){\n\t\t\t\t\tint t = f + i, k = s + j;\n\t\t\t\t\tif (ca[t][k] == '.')continue;\n\t\t\t\t\tcnt[t][k]++;\n\t\t\t\t\tif (cpy[t][k] != '.'&&ca[t][k] - '0' <= cnt[t][k]){\n\t\t\t\t\t\tcpy[t][k] = '.';\n\t\t\t\t\t\tque[!b].push(P(t, k));\n\t\t\t\t\t}\n\t\t\t \t}\n\t\t\t}\n\t\t}\n\t\tb = !b;\n\t}\n\tprintf(\"%d\\n\", res );\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint main(){\n\t\n\tint H, W;\n\t\n\tcin >> H >> W;\n\t\n\tint ans = 0;\n\t\n\tstring map[1001];\n\t\n\tfor(int i = 0; i < H; i++){\n\t\tcin >> map[i];\n\t}\n\t\n\tqueue<P> que, que_empty;\n\t\n\tfor(int i = 1; i < H - 1; i++){\n\t\tfor(int j = 1; j < W - 1; j++){\n\t\t\tif(map[i][j] == '.'){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint num = map[i][j] - '0';\n\t\t\tint count = 0;\n\t\t\tfor(int x = -1; x <= 1; x++){\n\t\t\t\tfor(int y = -1; y <= 1; y++){\n\t\t\t\t\tif(x == 0 && y == 0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(map[i + y][j + x] == '.'){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(count >= num){\n\t\t\t\tP p;\n\t\t\t\tp.first = i;\n\t\t\t\tp.second = j;\n\t\t\t\tque.push(p);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i < que.size(); i++){\n\t\tP p = que.front();\n\t\tque.pop();\n\t\tmap[p.first][p.second] = '.';\n\t\tque.push(p);\n\t}\n\t/*\n\tfor(int i = 0; i < H; i++){\n\t\tcout << map[i] << endl;\n\t}\n\t*/\n\twhile(!que.empty()){\n\t\tans++;\n\t\tqueue<P> que_next = que_empty;\n\t\twhile(!que.empty()){\n\t\t\tP p = que.front();\n\t\t\tque.pop();\n\t\t\t\n\t\t\tfor(int i = p.first - 1; i <= p.first + 1; i++){\n\t\t\t\tfor(int j = p.second - 1; j <= p.second + 1; j++){\n\t\t\t\t\tif(map[i][j] == '.'){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tint num = map[i][j] - '0';\n\t\t\t\t\tint count = 0;\n\t\t\t\t\tfor(int x = -1; x <= 1; x++){\n\t\t\t\t\t\tfor(int y = -1; y <= 1; y++){\n\t\t\t\t\t\t\tif(x == 0 && y == 0){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(map[i + y][j + x] == '.'){\n\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(count >= num){\n\t\t\t\t\t\tP p;\n\t\t\t\t\t\tp.first = i;\n\t\t\t\t\t\tp.second = j;\n\t\t\t\t\t\tque_next.push(p);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tque = que_next;\n\t\t\n\t\tfor(int i = 0; i < que.size(); i++){\n\t\t\tP p = que.front();\n\t\t\tque.pop();\n\t\t\tif(map[p.first][p.second] != '.'){\n\t\t\t\tmap[p.first][p.second] = '.';\n\t\t\t}\n\t\t\tque.push(p);\n\t\t}\n\t\t/*\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tcout << map[i] << endl;\n\t\t}\n\t\t*/\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\ntypedef pair<int,int> PA;\ntypedef pair<PA,int> PPA;\nint main(){\n  int h,w;\n  char masu[1001][1001];\n  int suji[1001][1001]={};\n  queue<PPA> que;\n  PA p;\n  int sum = 0;\n  cin >> h >> w;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++){\n      cin >> masu[i][j];\n      if(masu[i][j] == '.'){\n\tfor(int k=-1;k<=1;k++)\n\t  for(int l=-1;l<=1;l++){\n\t    if(k==0 && l==0) continue;\n\t    int y = i+k;\n\t    int x = j+l;\n\t    if(y<0||y>=h||x<0||x>=w||masu[y][x]=='.') continue;\n\t    suji[y][x]++;\n\t  }\n      }\n    }\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++){\n      if(suji[i][j] >= masu[i][j]-'0' && masu[i][j]!='.'){\n\tque.push(PPA(PA(i,j),1));\n      }\n    }\n  queue<PA> queb;\n  while(!que.empty()){\n    p = que.front().first;\n    if(sum != que.front().second){\n      while(!queb.empty()){\n\tmasu[queb.front().first][queb.front().second] = '.';\n\tqueb.pop();\n      }\n      sum++;\n    }\n    que.pop();\n    queb.push(p);\n    for(int k=-1;k<=1;k++)\n      for(int l=-1;l<=1;l++){\n\tif(k==0 && l==0) continue;\n\tint y = p.first+k;\n\tint x = p.second+l;\n\tif(y<0||y>=h||x<0||x>=w||masu[y][x]=='.') continue;\n\tsuji[y][x]++;\n\tif(suji[y][x] == masu[y][x]-'0'){\n\t  que.push(PPA(PA(y,x),sum+1));\n\t}\n      }\n  }\n  cout << sum << endl;\n  return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <map>\n#define FLAG -1\nusing namespace std;\ntypedef pair<int,int> P;\nint main(){\n      int h,w,dh[] = {1,1,1,0,-1,-1,-1,0}, dw[] = {1,0,-1,-1,-1,0,1,1},ctn,i,j;\n      int solve = -2 ;\n      cin >> h >> w;\n      queue<P> que,tmp;\n      char d[h][w];\n      for(i=0;i<h;i++){\n            for(j=0;j<w;j++)\n            {\n                  cin >> d[i][j];\n                  if('1'<=d[i][j]&&'9'>=d[i][j])\n                        que.push(make_pair(i,j));\n            }\n      }\n\n      que.push(make_pair(FLAG,FLAG));\n      for(;;){\n            solve++;\n            map<P,bool> m;\n            for(;;){\n                  //cout << que.size()<<endl;\n                  P p = que.front();\n                  que.pop();\n                  if(p.first==FLAG)\n                  {//cout <<\" break \"<<endl<<endl;\n                  break;\n                  }\n                  ctn = 0;\n                  for(i = 0;i < 8;i++){\n                        if(d[p.first+dh[i]][p.second+dw[i]]=='.')ctn++;\n                  }\n\n                  if(ctn >= d[p.first][p.second]-'0'){\n                        tmp.push(p);\n                        for(j=0;j<8;j++)\n                        if(m.count(make_pair(p.first+dh[j],p.second+dw[j]))==0&&d[p.first][p.second]!='.'){\n                        que.push(make_pair(p.first+dh[j],p.second+dw[j]));\n                        m[make_pair(p.first+dh[j],p.second+dw[j])]=true;\n                        }\n                  }\n            }\n            if(tmp.empty())break;\n            while(!tmp.empty())\n            {\n                  d[tmp.front().first][tmp.front().second]='.';\n                  tmp.pop();\n            }\n            /*for(i =0 ;i<h;i++)\n            {\n                  for(j=0;j<w;j++)cout << d[i][j];\n                  cout <<endl;\n            }\n            */\n\n            que.push(make_pair(FLAG,FLAG));\n\n      }\n      cout << solve << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<queue>\n#include<string>\n#include<cstring>\n#include<algorithm>\n#include<ctype.h>\n#include<cstdio>\nusing namespace std;\ntypedef pair<int,int> P;\nint dx[8]={0,1,1,1,0,-1,-1,-1};\nint dy[8]={1,1,0,-1,-1,-1,0,1};\nint kyoudo[1003][1003]={0};\nchar masu[1003][1003];\nint check[1003][1003]={0};\nmain(){\n  int h,w;\n  queue<P> q;\n  queue<P> stacking;\n  int nowx,nowy;\n  P p,a;\n  cin>>h>>w;\n  for(int i=0;i<=h+1;i++){\n    for(int j=0;j<=w+1;j++){\n      if(i==0||j==0||i==h+1||j==w+1){\n\tkyoudo[i][j]=0;\n\tmasu[i][j]='.';\n\tp.first=i;\n\tp.second=j;\n\tq.push(p);\n\tcheck[i][j]=1;\n      }\n      else{\n\tcin>>masu[i][j];\n\tif(masu[i][j]!='.'){\n\t  kyoudo[i][j]=masu[i][j]-'0';\n\t}\n\telse{\n\t  kyoudo[i][j]=0;\n\t  p.first=i;\n\t  p.second=j;\n\t  q.push(p);\n\t  check[i][j]=1;\n\t}\n      }\n    }\n  }\n  int count=0;\n  while(!q.empty()){\n    while(!q.empty()){\n      p=q.front();\n      nowx=p.first;\n      nowy=p.second;\n      for(int k=0;k<8;k++){\n\tint nx,ny;\n\tnx=nowx+dx[k];\n\tny=nowy+dy[k];\n\tif(nx>=0&&nx<=w&&ny>=0&&ny<=h&&kyoudo[nx][ny]!=0&&kyoudo[nx][ny]!=9){\n\t  kyoudo[nx][ny]=kyoudo[nx][ny]-1;\n\t  if(check[nx][ny]==0&&kyoudo[nx][ny]==0&&masu[nx][ny]!='.'){\n\t    a.first=nx;\n\t    a.second=ny;\n\t    stacking.push(a);\n\t    check[nx][ny]=1;\n\t  }\n\t}\n      }\n      check[nowx][nowy]=1;\n      q.pop();\n    }\n    while(!stacking.empty()){\n      p=stacking.front();\n      masu[p.first][p.second]='.';\n      q.push(stacking.front());\n      stacking.pop();\n    }\n    count=count+1;\n  }\n  cout<<count-1<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<queue>\n#include<vector>\nusing namespace std;\n#define INF 1000000000\ntypedef pair<int,int> P;\ntypedef long long int ll;\n\nint main(){\n\tint h,w;\n\tchar mas[1001][1001];\n\tcin >> h >> w;\n\tqueue<P> que1,que2;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tcin >> mas[i][j];\n\t\t\tif(mas[i][j]!='.' && mas[i][j]!='9'){\n\t\t\t\tque1.push(P(j,i));\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\twhile(1){\n\t\twhile(!que1.empty()){\n\t\t\tP p = que1.front(); que1.pop();\n\t\t\tint x = p.first;\n\t\t\tint y = p.second;\n\t\t\tint power = mas[y][x] - '0';\n\t\t\tint cou = 0;\n\t\t\tfor(int i=-1;i<=1;i++){\n\t\t\t\tif(power == cou) break;\n\t\t\t\tfor(int j=-1;j<=1;j++){\n\t\t\t\t\tif(power == cou) break;\n\t\t\t\t\tint nx = x+i;\n\t\t\t\t\tint ny = y+j;\n\t\t\t\t\tif(mas[ny][nx]=='.'){\n\t\t\t\t\t\tcou++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(power == cou){\n\t\t\t\tque2.push(P(x,y));\n\t\t\t}\n\t\t}\n\t\tif(que2.empty()) break;\n\t\tans++;\n\t\twhile(!que2.empty()){\n\t\t\tP p = que2.front(); que2.pop();\n\t\t\tint x = p.first;\n\t\t\tint y = p.second;\n\t\t\tmas[y][x] = '.';\n\t\t\tfor(int i=-1;i<=1;i++){\n\t\t\t\tfor(int j=-1;j<=1;j++){\n\t\t\t\t\tint nx = x+i;\n\t\t\t\t\tint ny = y+j;\n\t\t\t\t\tif(mas[ny][nx]!='.' && mas[ny][nx]!='9'){\n\t\t\t\t\t\tque1.push(P(nx,ny));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define Rep(i, a, b) for(int i = (a); i < (b); i++)\n#define rep(i, n) Rep(i, 0, n)\n\nint movX[8] = {-1, 0, 1,-1, 1,-1, 0, 1};\nint movY[8] = {-1,-1,-1, 0, 0, 1, 1, 1};\n\ntemplate<class T> T read() {\n\tT t;\n\tcin >> t;\n\treturn t;\n}\n\nint main(){\n\tint h=read<int>(),w=read<int>();\n\tint mp[h][w];\n\trep(i,h) rep(j,w){\n\t\tchar c=read<char>();\n\t\tif(c=='.'){\n\t\t\tmp[i][j]=0;\t\t\t\n\t\t}else{\n\t\t\tmp[i][j]=c-'0';\n\t\t}\n\t}\n\tint around[h][w] = {};\n\tRep(i, 1, h-1){\n\t\tRep(j, 1, w-1){\n\t\t\tint a = 0;\n\t\t\trep(k,8) {\n\t\t\t\tint x = i+movX[k];\n\t\t\t\tint y = j+movY[k];\n\t\t\t\t// printf(\"(%d, %d) -> (%d, %d) \", i, j, x, y);\n\t\t\t\tif(!mp[x][y]){\n\t\t\t\t\t// cout << \"o\";\n\t\t\t\t\ta++;\n\t\t\t\t}\n\t\t\t\t// cout << endl;\n\t\t\t}\n\t\t\taround[i][j]=a;\n\t\t}\n\t}\n\t// return 0;\n\t\t// rep(i,h){\n\t\t// \trep(j,w){\n\t\t// \t\tcout << mp[i][j];\n\t\t// \t}\n\t\t// \tcout << \" \";\n\t\t// \trep(j,w){\n\t\t// \t\tif(around[i][j]<0)\n\t\t// \t\t\tcout << \"x\";\n\t\t// \t\telse\n\t\t// \t\t\tcout << around[i][j];\n\t\t// \t}\n\t\t// \tcout << endl;\n\t\t// }\n\t\t// cout << \"-------------------------------------------\" << endl;\n\t\n\ttypedef pair<int, int> pii;\n\t\n\tint count = 0;\n\twhile(true){\n\t\tvector<pii> list;\n\t\tRep(i, 1, h-1){\n\t\t\tRep(j, 1, w-1){\n\t\t\t\tif(mp[i][j]>0 && around[i][j]>=mp[i][j]){\n\t\t\t\t\t// cout << i << \" \" << j << endl;\n\t\t\t\t\tlist.push_back(pii(i,j)); // mp[i][j] = 0;\n\t\t\t\t\t// now++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(list.size()==0){\n\t\t\tbreak;\n\t\t}\n\t\tcount++;\n\t\tfor(vector<pii>::iterator it=list.begin();it!=list.end();it++){\n\t\t\tint i = it->first, j = it->second;\n\t\t\tmp[i][j] = 0;\n\t\t\trep(k,8) {\n\t\t\t\tint x = i+movX[k];\n\t\t\t\tint y = j+movY[k];\n\t\t\t\taround[x][y]++;\n\t\t\t}\n\t\t}\n\t\t// rep(i,h){\n\t\t// \trep(j,w){\n\t\t// \t\tcout << mp[i][j];\n\t\t// \t}\n\t\t// \tcout << \" \";\n\t\t// \trep(j,w){\n\t\t// \t\tif(around[i][j]<0)\n\t\t// \t\t\tcout << \"x\";\n\t\t// \t\telse\n\t\t// \t\t\tcout << around[i][j];\n\t\t// \t}\n\t\t// \tcout << endl;\n\t\t// }\n\t\t// cout << \"-------------------------------------------\" << endl;\n\t}\n\tcout << count << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint h,w;\nint t[1000][1000];\nint u[1000][1000];\nchar str[51];\nint q[1000000],l,r;\n\nvoid init(){\n  l=r=0;\n}\n\nvoid push(int x){\n  q[r++]=x;\n}\n\nint pop(){\n  return q[l++];\n}\n\nint main(){\n  init();\n  scanf(\"%d %d\",&h,&w);\n  for(int i=0;i<h;i++){\n    scanf(\"%s\",str);\n    for(int j=0;j<w;j++){\n      if(str[j]=='.'){\n        t[i][j]=0;\n        u[i][j]=0;\n        push(i*w+j);\n      }else{\n        t[i][j]=str[j]-'0';\n      }\n    }\n  }\n  int ans=0;\n  while(l!=r){\n    int x=pop();\n    int i=x/w,j=x%w;\n    \n    cout<<u[i][j]<<endl;\n    for(int a=0;a<h;a++){\n      for(int b=0;b<w;b++){\n        printf(\"%3d\",t[a][b]);\n      }\n      cout<<endl;\n    }\n    cout<<endl;\n    for(int a=i-1;a<=i+1;a++){\n      for(int b=j-1;b<=j+1;b++){\n        if(0<=a&&a<h&&0<=b&&b<w){\n          t[a][b]--;\n          if(t[a][b]==0){\n            ans=u[a][b]=u[i][j]+1;\n            push(a*w+b);\n          }\n        }\n      }\n    }    \n  }\n  printf(\"%d\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint main(){\n\t\n\tint H, W;\n\t\n\tcin >> H >> W;\n\t\n\tint ans = 0;\n\t\n\tstring map[1001];\n\t\n\tfor(int i = 0; i < H; i++){\n\t\tcin >> map[i];\n\t}\n\t\n\tqueue<P> que, que_empty;\n\t\n\tfor(int i = 1; i < H - 1; i++){\n\t\tfor(int j = 1; j < W - 1; j++){\n\t\t\tif(map[i][j] == '.'){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint num = map[i][j] - '0';\n\t\t\tint count = 0;\n\t\t\tfor(int x = -1; x <= 1; x++){\n\t\t\t\tfor(int y = -1; y <= 1; y++){\n\t\t\t\t\tif(x == 0 && y == 0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(map[i + y][j + x] == '.'){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(count >= num){\n\t\t\t\tP p;\n\t\t\t\tp.first = i;\n\t\t\t\tp.second = j;\n\t\t\t\tque.push(p);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i < que.size(); i++){\n\t\tP p = que.front();\n\t\tque.pop();\n\t\tmap[p.first][p.second] = '.';\n\t\tans++;\n\t\tque.push(p);\n\t}\n\t/*\n\tfor(int i = 0; i < H; i++){\n\t\tcout << map[i] << endl;\n\t}\n\t*/\n\twhile(!que.empty()){\n\t\tqueue<P> que_next = que_empty;\n\t\twhile(!que.empty()){\n\t\t\tP p = que.front();\n\t\t\tque.pop();\n\t\t\t\n\t\t\tfor(int i = p.first - 1; i <= p.first + 1; i++){\n\t\t\t\tfor(int j = p.second - 1; j <= p.second + 1; j++){\n\t\t\t\t\tif(map[i][j] == '.'){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tint num = map[i][j] - '0';\n\t\t\t\t\tint count = 0;\n\t\t\t\t\tfor(int x = -1; x <= 1; x++){\n\t\t\t\t\t\tfor(int y = -1; y <= 1; y++){\n\t\t\t\t\t\t\tif(x == 0 && y == 0){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(map[i + y][j + x] == '.'){\n\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(count >= num){\n\t\t\t\t\t\tP p;\n\t\t\t\t\t\tp.first = i;\n\t\t\t\t\t\tp.second = j;\n\t\t\t\t\t\tque_next.push(p);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tque = que_next;\n\t\t\n\t\tfor(int i = 0; i < que.size(); i++){\n\t\t\tP p = que.front();\n\t\t\tque.pop();\n\t\t\tif(map[p.first][p.second] != '.'){\n\t\t\t\tmap[p.first][p.second] = '.';\n\t\t\t\tans++;\n\t\t\t}\n\t\t\tque.push(p);\n\t\t}\n\t\t/*\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tcout << map[i] << endl;\n\t\t}\n\t\t*/\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <time.h>\n#include <math.h>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <iterator>\n#include <sstream>\n#include <string>\n#include <bitset>\nusing namespace std;\n#define FOR(I,F,N) for(int I = F; I < (int)(N); I++)\n#define rep(i, n) FOR(i, 0, n)\n#define FIN(V) cout<<V<<endl\n#define pb push_back\n#define INF (1 << 28)\n\ntemplate<typename T>\nvoid remove(vector<T>& vector, unsigned int index){\nvector.erase(vector.begin() + index);\n}\n\ntypedef pair<int, int> P;\ntypedef long long ll;\ntypedef priority_queue<int> pq;\nint StrToInt(string);\nstring IntToStr(int);\nint dx[8] = {-1, 0, 1, 1, 1, 0, -1, -1};\nint dy[8] = {1, 1, 1, 0, -1, -1, -1, 0};\n\nint w, h, ans = 0;\nint state[1001][1001];\nint score[1001][1001];\nvoid show(){\n\trep(i,h){\n\t\trep(j,w){\n\t\t\tif(state[j][i] == 0)cout << '.';\n\t\t\telse cout << state[j][i];\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nint main(void){\n\tcin >> h >> w;\n\tfill_n(*state, 1001*1001, -1);\n\trep(i,h)rep(j,w){\n\t\tchar c;\n\t\tcin >> c;\n\t\tif(c == '.')state[j][i] = 0;\n\t\telse state[j][i] = c-'0';\n\t}\n\tqueue<P> que;\n\trep(i,h)rep(j,w){\n\t\tif(state[j][i] == 0)continue;\n\t\tint count = 0;\n\t\trep(k,8){\n\t\t\tint nx = j+dx[k];\n\t\t\tint ny = i+dy[k];\n\t\t\tif(nx < 0 || ny < 0 || state[nx][ny] == -1)continue;\n\t\t\tif(state[nx][ny] == 0)count++;\n\t\t}\n\n\t\tscore[j][i] = count;\n\t\tif(state[j][i] <= count){\n\t\t\tque.push(P(j, i));\n\t\t}\n\t}\n\t///show();\n\tint memo[1001][1001] = {0};\n\twhile(!que.empty()){\n\t\tqueue<P> reQue;\n\t\twhile(!que.empty()){\n\t\t\treQue.push(que.front());\n\t\t\t///cout << \"(\" << que.front().first << \",\" << que.front().second << \")\" << endl;\n\t\t\tP p = que.front();\n\t\t\tint x = p.first;\n\t\t\tint y = p.second;\n\t\t\tstate[x][y] = 0;\n\t\t\tscore[x][y] = 0;\n\t\t\trep(k,8){\n\t\t\t\tint nx = x+dx[k];\n\t\t\t\tint ny = y+dy[k];\n\t\t\t\tscore[nx][ny]++;\n\t\t\t}\n\t\t\tque.pop();\n\t\t}\n\t\twhile(!reQue.empty()){\n\t\t\tP p = reQue.front();\n\t\t\treQue.pop();\n\t\t\tint x = p.first;\n\t\t\tint y = p.second;\n\t\t\t///cout << \"(\" << x << \",\" << y << \")\" << endl;\n\t\t\trep(k,8){\n\t\t\t\tint nx = x+dx[k];\n\t\t\t\tint ny = y+dy[k];\n\t\t\t\tif(nx < 0 || ny < 0 || state[nx][ny] == -1)continue;\n\t\t\t\tif(state[nx][ny] == 0 || state[nx][ny] == 9)continue;\n\t\t\t\tif(state[nx][ny] <= score[nx][ny] && !memo[nx][ny]){\n\t\t\t\t\tmemo[nx][ny]=1;\n\t\t\t\t\tque.push(P(nx, ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans++;\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}\n\n\n\nint StrToInt(string s){\n\tstringstream ss;\n\tss << s;\n\tint val;\n\tss >> val;\n\treturn val;\n}\nstring IntToStr(int i){\n\tstringstream ss;\n\tss << i;\n\treturn ss.str();\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <tuple>\n# include <unordered_map>\n# include <numeric>\n# include <complex>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconstexpr int INF = 2000000000;\nconstexpr int HINF = INF / 2;\nconstexpr double DINF = 100000000000000000.0;\nconstexpr long long LINF = 9223372036854775807;\nconstexpr long long HLINF = 4500000000000000000;\nconst double PI = acos(-1);\nint dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\n# define ALL(x)     (x).begin(),(x).end()\n# define UNIQ(c)    (c).erase(unique(ALL((c))), end((c)))\n# define mp         make_pair\n# define eb         emplace_back\n# define FOR(i,a,b) for(int i=(a);i<(b);++i)\n# define REP(i,n)   FOR(i,0,n)\n# define INIT       std::ios::sync_with_stdio(false);std::cin.tie(0);\n\nconstexpr int MAX_V = 10010;\nint n, k;\nint C[10010], R[10010];\nstruct edge { LL to, cost; };\n\ntypedef pair<LL, LL> PP;\n\nLL d[10010]; //?????\nvector<edge> vec[10010];\n\nint last = 0;\n\nLL dijkstra() {\n\tfor (int i = 0; i < 10010; i++)d[i] = LINF;\n\tpriority_queue<PP, std::vector<PP>, std::greater<PP>> pq;\n\td[0] = 0;\n\tpq.push(make_pair(d[0], 0));//cost,to\n\twhile (!pq.empty()) {\n\t\tPP p = pq.top();\n\t\tpq.pop();\n\t\tint i = p.second;\n\t\tif (d[i] < p.first)continue;\n\t\tfor (int k = 0; k < vec[i].size(); k++) {\n\t\t\tedge e = vec[i][k];\n\t\t\tif (d[e.to] <= d[i] + e.cost)continue;\n\t\t\tif (e.to == n - 1)last = e.cost;\n\t\t\td[e.to] = d[i] + e.cost;\n\t\t\tpq.push(make_pair(d[e.to], e.to));\n\t\t}\n\t}\n\treturn d[n - 1];\n}\n\nvector<int> G[MAX_V];\nint start, goal;\n\nint dis[MAX_V]; //???????????????????????????\n\n\nvoid bfs() {\n\tqueue<int>que;\n\t//?????????\n\tfor (int i = 0; i < MAX_V; i++)dis[i] = INF;\n\n\tque.push(start);\n\tdis[start] = 0;\n\n\twhile (que.size()) {\n\t\tint p = que.front();\n\t\tque.pop();\n\n\t\t//if (p == goal)break;\n\t\tfor (int i = 0; i < G[p].size(); i++) {\n\t\t\tif (dis[G[p][i]] == INF) {\n\t\t\t\tque.push(G[p][i]);\n\t\t\t\tdis[G[p][i]] = dis[p] + 1;\n\t\t\t}\n\t\t}\n\t}\n\tREP(i, n) {\n\t\tif (dis[i] <= R[start]) {\n\t\t\tif (i == start)continue;\n\t\t\t//cout << start+1 << \" \" << i+1 << endl;\n\t\t\t//vec[i].emplace_back(edge{ start,C[start] });\n\t\t\tvec[start].emplace_back(edge{ i,C[start] });\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> n >> k;\n\tint a, b, c;\n\n\tREP(i, n) {\n\t\tcin >> C[i] >> R[i];\n\t}\n\n\tfor (int i = 0; i < k; i++) {\n\t\tcin >> a >> b;\n\t\ta--, b--;\n\t\t//edgedata[a].emplace_back(edge{ b,c });\n\t\t//edgedata[b].emplace_back(edge{ a,c });\n\t\tG[a].emplace_back(b);\n\t\tG[b].emplace_back(a);\n\t\t//vec[a].push_back(edge{ b,c });\n\t\t//vec[b].push_back(edge{ a,c });\n\t}\n\tREP(j, n) {\n\t\tstart = j;\n\t\tbfs();\n\t}\n\tcout << dijkstra() << endl;\n\t//system(\"pause\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n#define DIM 1100\n\n//field\nint f[DIM*DIM];\n//the count of . around f[i][j]\nint m[DIM*DIM];\nint count(int h,int w){\n\tint a[9]={0,1,1,0,-1,-1,1,-1,0},sum=0;\n\tfor(int i =0;i<8;i++){\n\t\tif(f[(h+a[i])*DIM+w+a[i+1]]==-1)sum++;\n\t}\n\treturn sum;\n}\nvoid change(int h,int w){\n\tint a[9]={0,1,1,0,-1,-1,1,-1,0};\n\tfor(int i =0;i<8;i++){\n\t\tm[(h+a[i])*DIM+w+a[i+1]]++;\n\t}\n}\nvoid add(int h,int w,vector<int>& v){\n\tint a[9]={0,1,1,0,-1,-1,1,-1,0};\n\tfor(int i =0;i<8;i++){\n\t\tif(m[(h+a[i])*DIM+w+a[i+1]] >= f[(h+a[i])*DIM+w+a[i+1]] && f[(h+a[i])*DIM+w+a[i+1]] >= 0 &&f[(h+a[i])*DIM+w+a[i+1]] <9){\n\t\t//\tcout<<f[(h+a[i])*DIM+w+a[i+1]]<<endl;\n\t\t\tf[(h+a[i])*DIM+w+a[i+1]] = -10;\n\t\t\tv.push_back((h+a[i])*DIM+w+a[i+1]);\n\t\t}\n\t}\n}\n\nint main(){\n\tint h,w;\n\tcin>>h>>w;\n\tvector<int> v;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tchar t;\n\t\t\tcin>>t;\n\t\t\tif(t=='.')f[i*DIM+j]=-1;\n\t\t\telse f[i*DIM+j]=t-'0';\n\t\t}\n\t}\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tm[i*DIM+j]=count(i,j);\n\t\t\tif(m[i*DIM+j] >= f[i*DIM+j] && f[i*DIM+j] != -1){\n\t\t\t\tv.push_back(i*DIM+j);\n\t\t\t\tf[i*DIM+j]=-10;\n\t\t\t}\n\t\t}\n\t}\n\tint c=1;\n\tint cnt;\n\twhile(1){\n\t\tcnt = v.size();\n\t\t/*for(int i = 0;i < cnt;i++){\n\t\t  f[v[i]] = e;\n\t\t  }*/\n\t\tfor(int i = 0;i < cnt;i++){\n\t\t\tchange(v[i]/DIM,v[i]%DIM);\n\t\t}\n\t\tfor(int i = 0;i < cnt;i++){\n\t\t\tadd(v[i]/DIM,v[i]%DIM,v);\n\t\t}\n\t\tv.erase(v.begin(),v.begin()+cnt);\n\t\tif(v.size() == 0){\n\t\t\tbreak;\n\t\t}\n\t\tc++;\n\t}\n\tcout<<c<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstring>\nusing namespace std;\n\n#define MAX 1001\n\nint main(){\n\tstring S;\n\tint n,m,t,sum,a;\n\tsum=0;\n\tshort x[MAX][MAX];\n\tshort z[MAX][MAX];\n\tshort v[MAX][MAX];\n\tmemset(x,0,sizeof(x));\n\tmemset(z,0,sizeof(z));\n\tchar T[10]={'.','1','2','3','4','5','6','7','8','9'};\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>S;\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tfor(int k=0;k<10;k++){\n\t\t\t\tif(S[j-1]==T[k]){\n\t\t\t\t\tx[i][j]=k;\n\t\t\t\t\tif(k==0){\n\t\t\t\t\t\tfor(int l=-1;l<=1;l++){\n\t\t\t\t\t\t\tfor(int o=-1;o<=1;o++){\n\t\t\t\t\t\t\t\tz[i+l][j+o] += 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\twhile(true){\n\t\tt=0;\n\t\tsum++;\n\t\tmemset(v,0,sizeof(v));\n\t\tfor(int i=2;i<n;i++){\n\t\t\tfor(int j=2;j<m;j++){\n\t\t\t\tif(x[i][j]>=1 && z[i][j]>=x[i][j]){\n\t\t\t\t\ta=0;\n\t\t\t\t\tv[i][j] += 1;\n\t\t\t\t\tt++;\n\t\t\t\t\tfor(int l=-1;l<=1;l++){\n\t\t\t\t\t\tfor(int o=-1;o<=1;o++){\n\t\t\t\t\t\t\tv[i+l][j+o]+= 10;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(t==0){\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i=2;i<n;i++){\n\t\t\tfor(int j=2;j<m;j++){\n\t\t\t\tif(v[i][j]%10>=1){\n\t\t\t\t\tx[i][j]=0;\n\t\t\t\t}\n\t\t\t\tz[i][j] += v[i][j]/10;\n\t\t\t\tv[i][j]=0;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<sum-1<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint a;\nint b;\nchar are[1001][1001];\nint kore[1001][1001];\nint sore[1001][1001];\nint ushi = 0;\nint uma;\n\nint main(){\n\tcin >> a >> b;\n\tfor (int i = 0; i < a; i++){\n\t\tfor (int j = 0; j < b; j++){\n\t\t\tcin >> are[i][j];\n\t\t\tif (are[i][j] != '.'){\n\t\t\t\tkore[i - 1][j - 1]++;\n\t\t\t\tkore[i][j - 1]++;\n\t\t\t\tkore[i + 1][j - 1]++;\n\t\t\t\tkore[i - 1][j]++;\n\t\t\t\tkore[i + 1][j]++;\n\t\t\t\tkore[i - 1][j + 1]++;\n\t\t\t\tkore[i][j + 1]++;\n\t\t\t\tkore[i + 1][j + 1]++;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < a; i++){\n\t\tfor (int j = 0; j < b; j++){\n\t\t\tsore[i][j] = kore[i][j];\n\t\t}\n\t}\n\twhile (true){\n\t\tuma = 0;\n\t\tfor (int i = 0; i < a; i++){\n\t\t\tfor (int j = 0; j < b; j++){\n\t\t\t\tif (are[i][j] != '.'||are[i][j]!='9'){\n\t\t\t\t\tif (9 - sore[i][j] > are[i][j] - 48){\n\t\t\t\t\t\tare[i][j] = '.';\n\t\t\t\t\t\tkore[i - 1][j - 1]--;\n\t\t\t\t\t\tkore[i][j - 1]--;\n\t\t\t\t\t\tkore[i + 1][j - 1]--;\n\t\t\t\t\t\tkore[i - 1][j]--;\n\t\t\t\t\t\tkore[i + 1][j]--;\n\t\t\t\t\t\tkore[i - 1][j + 1]--;\n\t\t\t\t\t\tkore[i][j + 1]--;\n\t\t\t\t\t\tkore[i + 1][j + 1]--;\n\t\t\t\t\t\tuma = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (uma == 1){\n\t\t\tushi++;\n\t\t}\n\t\tif (uma == 0){\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < a; i++){\n\t\t\tfor (int j = 0; j < b; j++){\n\t\t\t\tsore[i][j] = kore[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tcout << ushi << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <queue>\nusing namespace std;\nchar field[2000][2000];\nint dx[] = {1,1,1,0,0,-1,-1,-1};\nint dy[] = {1,0,-1,1,-1,1,0,-1};\nint x,y,d,ans;\nint main()\n{\n    queue<int> str[3];\n    int h,w;\n    char kara;\n    scanf(\"%d%d\",&h,&w);\n    ans = 0;\n    for(int i = 0; i < h; i++)\n    {\n        for(int j = 0; j < w + 1; j++)\n        {\n            scanf(\"%c\",&field[i][j]);\n        }\n    }\n    for(int i = 0; i < h; i++)\n    {\n        for(int j = 1; j < w + 1; j++)\n        {\n            if(field[i][j] == '.')\n            {\n                str[0].push(i);\n                str[1].push(j);\n                str[2].push(0);\n            }\n        }\n    }\n    while(str[0].size())\n    {\n        x = str[0].front();str[0].pop();\n        y = str[1].front();str[1].pop();\n        d = str[2].front();str[2].pop();\n        if(ans < d)ans = d;\n        for(int i = 0; i < 8; i++)\n        {\n            if(0 <= x + dx[i]&&x + dx[i] < w&&0 <= y + dy[i]&&y + dy[i] < h)\n            {\n                field[x + dx[i]][y + dy[i]]--;\n                if(field[x + dx[i]][y + dy[i]] == '0')\n                {\n                    str[0].push(x + dx[i]);\n                    str[1].push(y + dy[i]);\n                    str[2].push(d + 1);\n                }\n            }\n        }\n    }\n    printf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\nint h, w;\nvector<string> v;\nchar t[1001];\nint a[1000][1000];\nint dx[8] = {1, 1, 1, 0, -1, -1, -1, 0};\nint dy[8] = {-1, 0, 1, 1, 1, 0, -1, -1};\ntypedef pair<int, int> P;\nqueue<P> q[2];\nint b = 0;\nint ans;\n\nint main(){\n\tscanf(\"%d %d\", &h, &w);\n\tfor(int i=0; i<h; i++){\n\t\tscanf(\"%s\", t);\n\t\tv.push_back(t);\n\t}\n\tfor(int i=1; i<w-1; i++){\n\t\tfor(int j=1; j<h-1; j++){\n\t\t\tint c = 0;;\n\t\t\tfor(int k=0; k<8; k++){\n\t\t\t\tint nx, ny;\n\t\t\t\tnx = i + dx[k];\n\t\t\t\tny = j + dy[k];\n\t\t\t\tif(v[ny][nx] == '.') c++;\n\t\t\t}\n\t\t\ta[j][i] = c;\n\t\t}\n\t}\n\tfor(int i=1; i<w-1; i++){\n\t\tfor(int j=1; j<h-1; j++){\n\t\t\tif(v[j][i] != '.'){\n\t\t\t\tif(v[j][i] - '0' <= a[j][i]) q[0].push(P(i, j));\n\t\t\t}\n\t\t}\n\t}\n\n\twhile(q[b].size()){\n\t\twhile(q[b].size()){\n\t\t\tans++;\n\t\t\tP p = q[b].front();\n\t\t\tq[b].pop();\n\t\t\tfor(int i=0; i<8; i++){\n\t\t\t\tint nx, ny;\n\t\t\t\tnx = p.first + dx[i];\n\t\t\t\tny = p.second + dy[i];\n\t\t\t\ta[ny][nx] ++;\n\t\t\t\tif(v[ny][nx] != '.' && a[ny][nx] >= v[ny][nx] - '0') q[1-b].push(P(nx, ny));\n\t\t\t}\n\t\t}\n\t\tb=1-b;\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <set>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint dx[] = {-1,-1,-1,0,0,1,1,1},dy[] = {-1,0,1,-1,1,-1,0,1};\n\nint main(){\n\tint h,w,cnt[1000][1000] = {};\n\tstring field[1000];\n\tcin >> h >> w;\n\tfor(int i = 0;i < h;i++) cin >> field[i];\n\tset<P> next;\n\tfor(int i = 0;i < h;i++){\n\t\tfor(int j = 0;j < w;j++){\n\t\t\tif(field[i][j] == '.') continue;\n\t\t\tnext.insert(P(i,j));\n\t\t\tfor(int k = 0;k < 8;k++){\n\t\t\t\tint nx = i + dx[k],ny = j + dy[k];\n\t\t\t\tif(nx >= 0 && nx < h && ny >= 0 && ny < w && field[nx][ny] == '.') cnt[i][j]++;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int res = 0;;res++){\n\t\tbool chg = false;\n\t\tvector<P> chgs;\n\t\tfor(auto it = next.begin();it != next.end();it++){\n\t\t\tP p = *it;\n\t\t\tint i = p.first,j = p.second;\n\t\t\tif(field[i][j] != '.' && cnt[i][j] >= field[i][j] - '0'){\n\t\t\t\tfield[i][j] = '.';\n\t\t\t\tchg = true;\n\t\t\t\tfor(int k = 0;k < 8;k++){\n\t\t\t\t\tint nx = i + dx[k],ny = j + dy[k];\n\t\t\t\t\tif(nx >= 0 && nx < h && ny >= 0 && ny < w && field[nx][ny] != '.') {\n\t\t\t\t\t\tchgs.push_back(P(nx,ny));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnext.clear();\n\t\tfor(int i = 0;i < chgs.size();i++){\n\t\t\tint x = chgs[i].first,y = chgs[i].second;\n\t\t\tcnt[x][y]++;\n\t\t\tnext.insert(P(x,y));\n\t\t}\n\t\tif(!chg){\n\t\t\tcout << res << endl;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing P = pair<int, int>;\n\nvector<P> next(int y, int x) {return {{y-1, x-1}, {y-1, x}, {y-1, x+1}, {y, x-1}, {y, x+1}, {y+1, x-1}, {y+1, x}, {y+1, x+1}};}\n\nint main() {\n  int H, W;\n  cin >> H >> W;\n\n  auto valid = [&](auto y, auto x) {return 0 <= y && y < H && 0 <= x && x < W;};\n\n  vector<vector<int>> hp(H, vector<int>(W)), flat(H, vector<int>(W));\n\n  for(auto i = 0; i < H; ++i) for(auto j = 0; j < W; ++j) {\n    char c;\n    cin >> c;\n    hp[i][j] = (c == '.') ? 0 : (c - '0');\n  }\n\n  queue<P> cur, nex;\n  for(auto i = 0; i < H; ++i) for(auto j = 0; j < W; ++j) if(hp[i][j] <= flat[i][j]) cur.emplace(i, j);\n  for(auto step = 0; ; ++step) {\n    if(cur.empty()) {cout << step - 1 << endl; break;}\n    while(!cur.empty()) {\n      int y, x;\n      tie(y, x) = cur.front();\n      cur.pop();\n      for(auto p: next(y, x)) if(valid(p.first, p.second)) if(++flat[p.first][p.second] == hp[p.first][p.second]) nex.emplace(p);\n    }\n    swap(cur, nex);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<queue>\n#define MP make_pair\nusing namespace std;\nlong long int sc[1001][1001];\nchar c[1001];\nint main()\n{\n\tint h, w, cnt = 0, ans = 0;\n\tint x, y;\n\tpair<int, int> p;\n\tqueue< pair<int, int>> que;\n\tscanf(\"%d%d\",&h,&w);\n\tfor (int i = 0; i < h; i++)\n\t{\n\t\tscanf(\"%s\", c);\n\t\tfor (int j = 0; j < w; j++)\n\t\t{\n\n\t\t\tif (c[j] == '.')\n\t\t\t\tsc[i][j] = -1;\n\t\t\telse\n\t\t\t\tsc[i][j] = c[j] - 48;\n\t\t}\n\t}\n/*\t\tfor (int i = 0; i < h; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t{\n\n\t\t\t\tprintf(\"%2d\", sc[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t}*/\n\t\tdo\n\t\t{\n\t\t\tif (!que.empty())\n\t\t\t{\n\t\t\t\twhile (!que.empty())\n\t\t\t\t{\n\t\t\t\t\tx = que.front().first;\n\t\t\t\t\ty = que.front().second;\n\t\t\t\t\tque.pop();\n\t\t\t\t\tsc[x][y] = -1;\n\t\t\t\t}\n\t\t\t\tans++;\n\t\t\t}\n\t\t\tfor (int i = 1; i < h; i++)\n\t\t\t{\n\t\t\t\tfor (int j = 1; j < w; j++)\n\t\t\t\t{\n\t\t\t\t\tif (sc[i][j] != -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int a = -1; a < 2; a++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (sc[i - 1][j + a] == -1)\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\tif (sc[i + 1][j + a] == -1)\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (sc[i][j - 1] == -1)\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tif (sc[i][j + 1] == -1)\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tif (sc[i][j] <= cnt)\n\t\t\t\t\t\t\tque.push(MP(i, j));\n\t\t\t\t\t}\n\t\t\t\t\tcnt = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t} while (!que.empty());\n\t\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n#include<iostream>\nusing namespace std;\n\nint main()\n{\n\tchar a[10];\n\tint b;\n\tcin >> a;\n\tb = a[0]-48;\n\tcout << b << endl;\n\treturn 0;\n}\n*/\n\n\n\n#include<iostream>\n#include<queue>\n\nusing namespace std;\n\n#define ny first\n#define nx second\n\ntypedef pair < int, int > PR;\n\nPR tp;\n\n\nqueue< PR > qu1,qu2;\n\nint gy[] = { 1,0,-1,0,1,1,-1,-1};\nint gx[] = { 0,1,0,-1,1,-1,1,-1};\n\nint ly, lx;\nchar map[1000 + 10][1000 + 10];\nint mmap[1000 + 10][1000 + 10] = { 0 };\n\n\nint nami1(void);\nint nami2(void);\n\nint ans = 0;\n\n\nint main()\n{\n\tint i, j, k;\n\tint a;\n\n\n\tcin >> ly >> lx;\n\n\tfor (i = 0; i < ly; i++)\n\t{\n\t\tcin >> map[i];\n\t}\n\n\tfor (i = 1; i < ly-1; i++)\n\t{\n\t\tfor (j = 1; j < lx-1; j++)\n\t\t{\n\t\t\tfor (k = 0; k < 8; k++)\n\t\t\t{\n\t\t\t\tif (map[i + gy[k]][j + gx[k]] == '.')\n\t\t\t\t{\n\t\t\t\t\tmmap[i][j]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (map[i][j] != '.' && map[i][j] != '9')\n\t\t\t{\n\t\t\t\ta = map[i][j] - 48;\n\t\t\t\tif (a <= mmap[i][j])\n\t\t\t\t{\n\t\t\t\t\ttp.ny = i;\n\t\t\t\t\ttp.nx = j;\n\n\t\t\t\t\tqu1.push(tp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\n\tnami1();\n\n\tcout << ans << endl;\n\n\treturn 0;\n}\n\n\nint nami1(void)\n{\n\tint i, j;\n\tint b;\n\tPR tmp;\n\tans++;\n\n\twhile (!qu1.empty())\n\t{\n\t\ttp = qu1.front();\n\t\tqu1.pop();\n\n\t\tfor (i = 0; i < 8; i++)\n\t\t{\n\t\t\tmmap[tp.ny + gy[i]][tp.nx + gx[i]]++;\n\n\t\t\tb = map[tp.ny + gy[i]][tp.nx + gx[i]] - 48;\n\n\t\t\tif (mmap[tp.ny + gy[i]][tp.nx + gx[i]] - b == 0)\n\t\t\t{\n\t\t\t\ttmp.ny = tp.ny + gy[i];\n\t\t\t\ttmp.nx = tp.nx + gx[i];\n\n\t\t\t\tqu2.push(tmp);\n\t\t\t}\n\t\t}\n\t}\n\tif (!qu2.empty())\n\t{\n\t\treturn nami2();\n\t}\n\telse\n\t{\n\t\treturn 0;\n\t}\n\treturn 0;\n}\n\nint nami2(void)\n{\n\tint i, j;\n\tint b;\n\tPR tmp;\n\tans++;\n\n\twhile (!qu2.empty())\n\t{\n\t\ttp = qu2.front();\n\t\tqu2.pop();\n\n\t\tfor (i = 0; i < 8; i++)\n\t\t{\n\t\t\tmmap[tp.ny + gy[i]][tp.nx + gx[i]]++;\n\n\t\t\tb = map[tp.ny + gy[i]][tp.nx + gx[i]] - 48;\n\n\t\t\tif (mmap[tp.ny + gy[i]][tp.nx + gx[i]] - b == 0)\n\t\t\t{\n\t\t\t\ttmp.ny = tp.ny + gy[i];\n\t\t\t\ttmp.nx = tp.nx + gx[i];\n\n\t\t\t\tqu1.push(tmp);\n\t\t\t}\n\t\t}\n\t}\n\tif (!qu1.empty())\n\t{\n\t\treturn nami1();\n\t}\n\telse\n\t{\n\t\treturn 0;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <stdlib.h>\n#include <stdio.h>\n#include <bitset>\n#include <cstring>\n#include <deque>\nusing namespace std;\n#define FOR(I,A,B) for(int I = (A); I < (B); ++I)\n#define CLR(mat) memset(mat, 0, sizeof(mat))\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<P, int> PP;\nint H, W;\nint cas[1000][1000];\nvector<string> vs;\nqueue<PP> que; // PP(P(y, x),???i??????)??????????\\???\nint vy[8] = {-1, -1, 0, 1, 1, 1, 0, -1};\nint vx[8] = {0, 1, 1, 1, 0, -1, -1, -1};\nint main()\n{\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> H >> W;\n  FOR(i,0,H) {\n    string s; cin >> s;\n    vs.push_back(s);\n  }\n  FOR(i,0,H) {\n    FOR(j,0,W) {\n      if(isdigit(vs[i][j])) {\n        cas[i][j] = 1e9;\n        que.push(PP(P(i, j), 1));\n      }\n    }\n  }\n  int ans = 0;\n  while(!que.empty()) {\n    PP p = que.front(); que.pop();\n    int y = p.first.first;\n    int x = p.first.second;\n    int t = p.second;\n    if(cas[y][x] < t) continue; // ??????????????????????\n    int cnt = 0;\n    FOR(i,0,8) if(cas[y+vy[i]][x+vx[i]] < t) cnt++;\n    // ????????\n    if(cnt >= vs[y][x] - '0') {\n      cas[y][x] = t;\n      ans = max(ans, t);\n      FOR(i,0,8) {\n        if(cas[y+vy[i]][x+vx[i]] > t) {\n          que.push(PP(P(y+vy[i], x+vx[i]), t + 1));\n        }\n      }\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<queue>\n#define MP make_pair\nusing namespace std;\nlong long int sc[1001][1001];\nchar c[1001];\nint main()\n{\n\tint h, w, cnt = 0, ans = 0;\n\tint x, y;\n\tpair<int, int> p;\n\tqueue< pair<int, int>> que;\n\tscanf(\"%d%d\",&h,&w);\n\tfor (int i = 0; i < h; i++)\n\t{\n\t\tscanf(\"%s\", c);\n\t\tfor (int j = 0; j < w; j++)\n\t\t{\n\n\t\t\tif (c[j] == '.')\n\t\t\t\tsc[i][j] = -1;\n\t\t\telse\n\t\t\t\tsc[i][j] = c[j] - 48;\n\t\t}\n\t}\n\t\tfor (int i = 0; i < h; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t{\n\n\t\t\t\tprintf(\"%2d\", sc[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t}\n\t\tdo\n\t\t{\n\t\t\tif (!que.empty())\n\t\t\t{\n\t\t\t\twhile (!que.empty())\n\t\t\t\t{\n\t\t\t\t\tx = que.front().first;\n\t\t\t\t\ty = que.front().second;\n\t\t\t\t\tque.pop();\n\t\t\t\t\tsc[x][y] = -1;\n\t\t\t\t}\n\t\t\t\tans++;\n\t\t\t}\n\t\t\tfor (int i = 1; i < h; i++)\n\t\t\t{\n\t\t\t\tfor (int j = 1; j < w; j++)\n\t\t\t\t{\n\t\t\t\t\tif (sc[i][j] != -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int a = -1; a < 2; a++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (sc[i - 1][j + a] == -1)\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\tif (sc[i + 1][j + a] == -1)\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (sc[i][j - 1] == -1)\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tif (sc[i][j + 1] == -1)\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tif (sc[i][j] <= cnt)\n\t\t\t\t\t\t\tque.push(MP(i, j));\n\t\t\t\t\t}\n\t\t\t\t\tcnt = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t} while (!que.empty());\n\t\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\nint dx8[8] = { -1,-1,-1, 0, 1, 1, 1, 0 };\nint dy8[8] = { -1, 0, 1, 1, 1, 0,-1,-1 };\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\nint main() {\n\tint H, W; cin >> H >> W;\n\tvector<vector<int>>nums(H + 2, vector<int>(W + 2));\n\tfor (int i = 0; i < H; ++i) {\n\t\tstring st; cin >> st;\n\t\tfor (int j = 0; j < W; ++j) {\n\t\t\tif (st[j] != '.') {\n\t\t\t\tnums[i+1][j+1] = st[j] - '0';\n\t\t\t}\n\t\t}\n\t}\n\tqueue<pair<int, int>>que;\n\tvector<vector<int>>newnums(nums);\n\tfor (int y = 1; y < H + 1; ++y) {\n\t\tfor (int x = 1; x < W + 1; ++x) {\n\t\t\tif (nums[y][x] <= 0) {\n\t\t\t\tfor (int way = 0; way < 8; ++way) {\n\t\t\t\t\tconst int ax = x + dx8[way];\n\t\t\t\t\tconst int ay = y + dy8[way];\n\t\t\t\t\tnewnums[ay][ax]--;\n\t\t\t\t\tif (!newnums[ay][ax]) {\n\t\t\t\t\t\tque.push(make_pair(ax, ay));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tnums = newnums;\n\tint ans = 0;\n\twhile (!que.empty()) {\n\t\tqueue<pair<int, int>>newque;\n\t\twhile (!que.empty()) {\n\t\t\tauto p(que.front());\n\t\t\tque.pop();\n\t\t\tconst int x = p.first;\n\t\t\tconst int y = p.second;\n\t\t\tfor (int way = 0; way < 8; ++way) {\n\t\t\t\tconst int ax = x + dx8[way];\n\t\t\t\tconst int ay = y + dy8[way];\n\t\t\t\tnums[ay][ax]--;\n\t\t\t\tif (!nums[ay][ax]) {\n\t\t\t\t\tnewque.push(make_pair(ax, ay));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tque = newque;\n\t\tans++;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//AOJ 0612\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\nint w,h,field[1000][1000],copied[1000][1000];\n\nvoid show(){\n\tfor(int i = 0;i < h;i++){\n\t\tfor(int j = 0;j < w;j++){\n\t\t\tcout << field[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\nvoid copyarray(){\n\tfor(int i = 0;i < h;i++){\n\t\tfor(int j = 0;j < w;j++){\n\t\t\tfield[i][j] = copied[i][j];\n\t\t}\n\t}\n}\n\nint around(int a,int b){\n\tint cnt = 0;\n\tfor(int i = max(0,a - 1);i < min(h,a + 2);i++){\n\t\tfor(int j = max(0,b - 1);j < min(w,b + 2);j++){\n\t\t\tif(!(a == i && b == j) && field[i][j] == 0) cnt++;\n\t\t}\n\t}\n\treturn cnt;\n}\n\nint main(){\n\tqueue<pair<int,int> > que1,que2;\n\tcin >> h >> w;\n\tgetchar();\n\tfor(int i = 0;i < h;i++){\n\t\tfor(int j = 0;j < w;j++){\n\t\t\tchar c = getchar();\n\t\t\tif(c == '.') copied[i][j] = 0;\n\t\t\telse copied[i][j] = c - '0';\n\t\t}\n\t\tgetchar();\n\t}\n\tint chg = -1,cnt = -1;\n\twhile(chg){\n\t\tcopyarray();\n\t\tcnt++;\n\t\tif(chg == -1){\n\t\t\tchg++;\n\t\t\tfor(int i = 0;i < h;i++){\n\t\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\t\tif(field[i][j] != 0 && around(i,j) >= field[i][j]) {\n\t\t\t\t\t\tcopied[i][j] = 0;\n\t\t\t\t\t\tchg++;\n\t\t\t\t\t\tque2.push(make_pair(i,j));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tchg = 0;\n\t\t\tque1 = que2;\n\t\t\twhile(!que2.empty()) que2.pop();\n\t\t\twhile(!que1.empty()){\n\t\t\t\tpair<int,int> p = que1.front();que1.pop();\n\t\t\t\tfor(int i = max(0,p.first - 1);i < min(h,p.first + 2);i++){\n\t\t\t\t\tfor(int j = max(0,p.second - 1);j < min(w,p.second + 2);j++){\n\t\t\t\t\t\tif(field[i][j] > 0 && around(i,j) >= field[i][j]) {\n\t\t\t\t\t\t\tfield[i][j] = -1;\n\t\t\t\t\t\t\tcopied[i][j] = 0;\n\t\t\t\t\t\t\tchg++;\n\t\t\t\t\t\t\tque2.push(make_pair(i,j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << cnt << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <string>\nusing namespace std;\n\nstruct p{\n  int co,x,y;\n  p(int a,int b,int c){\n    co=a;\n    x=b;\n    y=c;\n  }\n};\nint a[1000][1000],b[1000][1000];\nint main (){\n  int h,w;\n  queue<p> Q; \n  string s;\n  cin >>h>>w;\n  for(int i=0;i<h;i++){\n    cin >>s;\n    for(int j=0;j<w;j++){\n      if(s[j] == '.'){\n\ta[i][j] = -1;\n\tQ.push(p(0,j,i));\n      } else a[i][j] = s[j]-'0';\n      b[i][j] = 0;\n    }\n  }\n  int res = 0;\n  while( !Q.empty() ){\n    p np = Q.front();\n    Q.pop();\n    res = np.co;\n    for(int i=-1;i<=1;i++)\n      for(int j=-1;j<=1;j++){\n\tif(i==0 && j==0) continue;\n\tint nx = np.x+i;\n\tint ny = np.y+j;\n\tif(0>nx || nx>w || 0>ny || ny>h) continue;\n\tb[nx][ny]++;\n\tif(a[nx][ny] == b[nx][ny]) Q.push(p(np.co+1,nx,ny));\n      }\n  }\n  cout << res<<endl;\n  return 0;\n}\n    "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> P;\n\nconst int dxy[] = {-1, 0, 1};\n\nchar sand[1024][1024];\nchar tmp[1024][1024];\n\nbool check(int y, int x)\n{\n    int cnt = 0;\n\n    for (int i = 0; i < 3; i++){\n        for (int j = 0; j < 3; j++){\n            cnt += (sand[y + dxy[i]][x + dxy[j]] == '.');\n        }\n    }\n\n    return (sand[y][x] - '0' <= cnt);\n}\n\nint main()\n{\n    int h, w;\n\n    scanf(\"%d %d\", &h, &w);\n    for (int i = 0; i < h; i++) scanf(\"%s\", sand[i]);\n\n    queue<P> que;\n    int cnt = 0;\n    memcpy(tmp, sand, 1024 * 1024);\n    for (int i = 0; i < h; i++){\n        for (int j = 0; j < w; j++){\n            if (sand[i][j] != '.' && check(i, j)){\n                tmp[i][j] = '.';\n                que.push(P(i, j));\n            }\n        }\n    }\n    memcpy(sand, tmp, 1024 * 1024);\n\n    for (int size = que.size(); size; size = que.size()){\n        cnt++;\n        for (int i = 0; i < size; i++, que.pop()){\n            P p = que.front();\n            int y = p.first, x = p.second;\n\n            for (int j = 0; j < 3; j++){\n                for (int k = 0; k < 3; k++){\n                    if (j == 1 && k == 1) continue;\n                    int ty = y + dxy[j], tx = x + dxy[k];\n\n                    if (sand[ty][tx] != '.' && check(ty, tx)){\n                        tmp[ty][tx] = '.';\n                        que.push(P(ty, tx));\n                    }\n                }\n            }\n        }\n        memcpy(sand, tmp, 1024 * 1024);\n    }\n\n    printf(\"%d\\n\", cnt);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n \nint h, w, ans;\nint castle[1001][1001], times[1001][1001];\nint dx[] = {-1, 0, 1, -1, 1, -1, 0, 1}, dy[] = {-1, -1, -1, 0, 0, 1, 1, 1};\nchar beach[1001][1001];\n \nint main(){\n    scanf(\"%d%d\", &h, &w);\n    for(int i = 0; i < h; i++){\n        scanf(\"%s\", &beach[i]);\n    }\n \n    queue< pair<int, int> > Q;\n    for(int i = 0; i < h; i++){\n        for(int j = 0; j < w; j++){\n            if(beach[i][j] == '.'){\n                Q.push(P(i, j));\n            } else{\n                castle[i][j] = beach[i][j] - '0';\n            }\n        }\n    }\n \n    while(Q.size()){\n        pair<int, int> p = Q.front();\n        Q.pop();\n        ans = max(ans, times[p.first][p.second]);\n \n        for(int i = 0; i < 8; i++){\n            int y = p.first + dy[i], x = p.second + dx[i];\n            if(y < 0 || y >= h || x < 0 || x >= w){\n                continue;\n            }\n \n            castle[y][x]--;\n            if(castle[y][x] == 0){\n                Q.push(P(y, x));\n                times[y][x] = times[p.first][p.second] + 1;\n            }\n        }\n    }\n \n    printf(\"%d\\n\", ans);\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\nusing namespace std;\n\nint h, w;\nchar t[1001];\nvector<string> v;\nint dx[8] = {0, 1, 1, 1, 0, -1, -1, -1};\nint dy[8] = {-1, -1, 0, 1, 1, 1, 0, -1};\nint ans;\ntypedef pair<int, int> P;\n\nint main(){\n\tscanf(\"%d %d\", &h, &w);\n\tfor(int i=0; i<h; i++){\n\t\tscanf(\"%s\", t);\n\t\tv.push_back(t);\n\t}\n\tbool f = true;\n\twhile(f){\n\t\tf = false;\n\t\tvector<P> u;\n\t\tfor(int i=1; i<w+1; i++){\n\t\t\tfor(int j=1; j<h+1; j++){\n\t\t\t\tif(v[j][i] != '.'){\n\t\t\t\t\tint c = 0;\n\t\t\t\t\tfor(int k=0; k<8; k++){\n\t\t\t\t\t\tint nx, ny;\n\t\t\t\t\t\tnx = j + dx[k];\n\t\t\t\t\t\tny = i + dy[k];\n\t\t\t\t\t\tif(v[nx][ny] == '.') c++;\n\t\t\t\t\t}\n\t\t\t\t\tif(v[j][i] - '0' <= c){\n\t\t\t\t\t\tu.push_back(P(j, i));\n\t\t\t\t\t\tf = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<u.size(); i++){\n\t\t\tv[u[i].first][u[i].second] = '.';\n\t\t}\n\t\tif(f) ans++;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n\n    int w,h;\n\n    cin >> w >> h;\n\n    int table[w][h],copy[w][h];\n\n    char c;\n\n    for(int i=0;i<w;i++){\n      for(int j=0;j<h;j++){\n        cin >> c;\n        if(c=='.'){\n          table[i][j] = -1;\n        }\n        else{\n          stringstream ss;\n          ss << c;\n          ss >> table[i][j];\n        }\n      }\n    }\n\n    bool flag = true;\n\n    int ans = -1,com=-1,sub,rep=-3;\n\n    while(flag){\n\n      ans++;\n\n      flag = false;\n\n      //cout << endl;\n\n      for(int i=0;i<w;i++){\n        for(int j=0;j<h;j++){\n\n          if(table[i][j] == rep){\n              table[i][j] = com;\n          }\n\n          else if(table[i][j] != com && i != 0 && i != w-1 && j != 0 && j!= h-1){\n\n            int count = 0;\n            if(table[i+1][j] == com || table[i+1][j] == rep) count++;\n            if(table[i+1][j-1] == com || table[i+1][j-1] == rep) count++;\n            if(table[i+1][j+1] == com || table[i+1][j+1] == rep) count++;\n            if(table[i][j-1] == com) count++;\n            if(table[i][j+1] == com || table[i][j+1] == rep) count++;\n            if(table[i-1][j] == com) count++;\n            if(table[i-1][j+1] == com) count++;\n            if(table[i-1][j-1] == com) count++;\n\n            if(count >= table[i][j]){\n              flag = true;\n              table[i][j] = rep;\n            }\n            else{\n              //copy[i][j] = table[i][j];\n            }\n\n          }\n          else{\n            table[i][j] = com;\n          }\n        }\n      }\n\n      /*cout << endl;\n\n      for(int i=0;i<w;i++){\n        cout << endl;\n        for(int j=0;j<h;j++){\n          cout << table[i][j] << \" \";\n        }\n      }\n\n      while(1){}*/\n\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <algorithm>\n#include <queue>\nusing namespace std;\ntypedef pair<int, int> P;\n \nint h, w, ans;\nint castle[1001][1001], times[1001][1001];\nint dx[] = {-1, 0, 1, -1, 1, -1, 0, 1}, dy[] = {-1, -1, -1, 0, 0, 1, 1, 1};\nchar beach[1001][1001];\n \ninline int input_i(){\n\tint temp;\n\tscanf(\"%d\", &temp);\n\treturn temp;\n}\n\ninline string input_s(){\n\tstring temp;\n\tscanf(\"%s\", temp);\n\treturn temp;\n}\n\n\nint main(){\n    h = input_i();\n    w = input_i();\n    for(int i = 0; i < h; i++){\n        beach[i] = input_s();\n    }\n \n    queue<P> Q;\n    for(int i = 0; i < h; i++){\n        for(int j = 0; j < w; j++){\n            if(beach[i][j] == '.'){\n                Q.push(P(i, j));\n            } else{\n                castle[i][j] = beach[i][j] - '0';\n            }\n        }\n    }\n \n    while(Q.size()){\n        P p = Q.front();\n        Q.pop();\n        ans = max(ans, times[p.first][p.second]);\n \n        for(int i = 0; i < 8; i++){\n            int y = p.first + dy[i], x = p.second + dx[i];\n            if(y < 0 || y >= h || x < 0 || x >= w){\n                continue;\n            }\n \n            castle[y][x]--;\n            if(castle[y][x] == 0){\n                Q.push(P(y, x));\n                times[y][x] = times[p.first][p.second] + 1;\n            }\n        }\n    }\n \n    printf(\"%d\\n\", ans);\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nstring board[1001];\nint dx[8] = {0, 1, 1, 1, 0, -1, -1, -1};\nint dy[8] = {1, 1, 0, -1, -1, -1, 0, 1};\nint h, w;\nbool hantei(int y, int x){\n\tif(0 <= y && y < h && 0 <= x && x < w) return true;\n\telse return false;\n}\n\nint main(void){\n\tcin >> h >> w;\n\trep(i, h) cin >> board[i];\n\tqueue<pair<int, int> > q1, q2;\n\trep(i, h)rep(j, w){\n\t\tif(board[i][j] != '.') q1.push(make_pair(i, j));\n\t}\n\n\tint ans = -1, cnt = 0, nowy, nowx;\n\tbool flag = true;\n\twhile(flag){\n\t\tflag = false; ans++;\n\t\tvector<pair<int, int> > memo;//?????????????????????????????????????????????????????????\n\n\t\tif(cnt % 2 == 0){\n\t\t\twhile(!q1.empty()){//q1??????????????\n\t\t\t\tpair<int, int> now = q1.front(); q1.pop();\n\t\t\t\tif(board[now.first][now.second] == '.') continue;\n\t\t\t\tint tmp = 0;\n\t\t\t\trep(i, 8){\n\t\t\t\t\tint nowy = now.first + dy[i], nowx = now.second + dx[i];\n\t\t\t\t\tif(!hantei(nowy, nowx)) continue;\n\t\t\t\t\tif(board[nowy][nowx] == '.')tmp++;\n\t\t\t\t}\n\t\t\t\tif(tmp >= board[now.first][now.second] - '0'){\n\t\t\t\t\t// printf(\"q1 y:%d  x:%d\\n\", now.first, now.second);\n\t\t\t\t\tmemo.push_back(make_pair(now.first, now.second));\n\t\t\t\t\trep(k, 8){//???????????????????????????????????????????????????????????????????\n\t\t\t\t\t\tint ny = now.first + dy[k], nx = now.second + dx[k];\n\t\t\t\t\t\tif(!hantei(ny, nx)) continue;\n\t\t\t\t\t\tif(board[ny][nx] != '.') q2.push(make_pair(ny, nx));\n\t\t\t\t\t}\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\twhile(!q2.empty()){//q2??????????????\n\t\t\t\tpair<int, int> now = q2.front(); q2.pop();\n\t\t\t\tif(board[now.first][now.second] == '.') continue;\n\t\t\t\tint tmp = 0;\n\t\t\t\trep(i, 8){\n\t\t\t\t\tint nowy = now.first + dy[i], nowx = now.second + dx[i];\n\t\t\t\t\tif(!hantei(nowy, nowx)) continue;\n\t\t\t\t\tif(board[nowy][nowx] == '.')tmp++;\n\t\t\t\t}\n\t\t\t\tif(tmp >= board[now.first][now.second] - '0'){\n\t\t\t\t\t// printf(\"q2 y:%d  x:%d\\n\", now.first, now.second);\n\t\t\t\t\tmemo.push_back(make_pair(now.first, now.second));\n\t\t\t\t\trep(k, 8){//???????????????????????????????????????????????????????????????????\n\t\t\t\t\t\tint ny = now.first + dy[k], nx = now.second + dx[k];\n\t\t\t\t\t\tif(!hantei(ny, nx)) continue;\n\t\t\t\t\t\tif(board[ny][nx] != '.') q1.push(make_pair(ny, nx));\n\t\t\t\t\t}\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcnt++;\n\t\t//???????????\n\t\trep(k, memo.size()){\n\t\t\tboard[memo[k].first][memo[k].second] = '.';\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n#define MAX_H 1111\n#define MAX_W 1111\n\nint H, W, maxdepth = -1;\n\nchar sand[MAX_H][MAX_W];\n\nconst int dx[8] = { -1, -1, -1, 0, 0, 1, 1, 1 };\nconst int dy[8] = { -1, 0, 1, -1, 1, -1, 0, 1 };\n\nvoid dfs(int x, int y, int depth)\n{\n\tmaxdepth = max(maxdepth, depth);\n\n\tif (sand[y][x] != '.')\n\t{\n\t\tint count = 0;\n\n\t\tfor (int dir = 0; dir < 8; dir++)\n\t\t{\n\t\t\tif (sand[y + dy[dir]][x + dx[dir]] == '.')\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\n\t\tif (depth == 0)\n\t\t{\n\t\t\tif (count >= sand[y][x] - 48)\n\t\t\t{\n\t\t\t\tsand[y][x] = '.';\n\n\t\t\t\tfor (int dir = 0; dir < 8; dir++)\n\t\t\t\t{\n\t\t\t\t\tdfs(x + dx[dir], y + dy[dir], 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (count == sand[y][x] - 48)\n\t\t\t{\n\t\t\t\tsand[y][x] = '.';\n\n\t\t\t\tfor (int dir = 0; dir < 8; dir++)\n\t\t\t\t{\n\t\t\t\t\tdfs(x + dx[dir], y + dy[dir], depth + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tcin >> H >> W;\n\n\tfor (int i = 0; i < H; i++)\n\t\tcin >> sand[i];\n\n\tfor (int i = 1; i < H - 1; i++)\n\t\tfor (int j = 1; j < W - 1; j++)\n\t\t\tdfs(j, i, 0);\n\n\tcout << maxdepth << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <queue>\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\n#define fst first\n#define scd second\n#define rep(i,x) for(int i=0;i<(x);++i)\n\nint dx[8] = {-1, 0, 1, -1, 1, -1, 0, 1}, dy[8] = {-1, -1, -1, 0, 0, 1, 1, 1};\n\nint st[1000][1002];\n\nint main()\n{\n\tint H, W; scanf(\"%d %d\", &H, &W);\n\n\trep(i, H) rep(j, W) {\n\t\tchar c; scanf(\"\\n%c\", &c);\n\t\tst[i][j] = (c == '.') ? -1 : c - '0';\n\t}\n\n\tqueue<pii> q;\n\n\trep(i, H) rep(j, W) if (st[i][j] == -1) q.push(pii(i, j));\n\n\tint ans = 0;\n\n\twhile (q.size()) {\n\t\tqueue<pii> Q;\n\n\t\twhile (q.size()) {\n\t\t\tpii p = q.front(); q.pop();\n\t\t\trep(i, 8) {\n\t\t\t\tint ny = p.fst + dy[i], nx = p.scd + dx[i];\n\t\t\t\tif (0 <= ny && ny < H && 0 <= nx && nx < W && st[ny][nx] > 0) {\n\t\t\t\t\tst[ny][nx]--;\n\t\t\t\t\tif (st[ny][nx] == 0) Q.push(pii(ny, nx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (Q.empty()) break;\n\n\t\twhile (Q.size()) {\n\t\t\tq.push(Q.front()); Q.pop();\n\t\t}\n\n\t\tans++;\n\t}\n\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <cstring>\n#include <vector>\n\nusing namespace std;\n\nint h,w;\nchar bch[1003][1003];\nbool done[1003][1003];\n\nint wav (int i, int j)\n{\n    int c=0;\n    if (bch[i-1][j-1]=='.') c++;\n    if (bch[i-1][j]=='.') c++;\n    if (bch[i-1][j+1]=='.') c++;\n    if (bch[i][j-1]=='.') c++;\n    if (bch[i][j+1]=='.') c++;\n    if (bch[i+1][j-1]=='.') c++;\n    if (bch[i+1][j]=='.') c++;\n    if (bch[i+1][j+1]=='.') c++;\n    return c;\n}\n\nint bfs ()\n{\n    int cnt, ans=0;\n    bool ok=true, done[1003][1003];\n    vector<pair<int, int>> que, vec;\n    for (int i=1; i<h-1; i++)\n    {\n        for (int j=1; j<w-1; j++)\n        {\n            if (bch[i][j]=='.') continue;\n            cnt=wav(i, j);\n            if (cnt>=bch[i][j]-'0') que.push_back({i, j});\n        }\n    }\n    while (1)\n    {\n        if (que.empty())\n        {\n            if (!ok) break;\n            ans++;\n            ok=false;\n            for (auto u : vec)\n            {\n                int i=u.first, j=u.second;\n                bch[i][j]='.';\n            }\n            memset(done, false, sizeof(done));\n            for (auto u : vec)\n            {\n                int i=u.first, j=u.second;\n                if (bch[i-1][j-1]!='.' && !done[i-1][j-1] && wav(i-1, j-1)>=bch[i-1][j-1]-'0') { done[i-1][j-1]=true; que.push_back({i-1, j-1}); }\n                if (bch[i-1][j]!='.' && !done[i-1][j] && wav(i-1, j)>=bch[i-1][j]-'0') { done[i-1][j]=true; que.push_back({i-1, j}); }\n                if (bch[i-1][j+1]!='.' && !done[i-1][j+1] && wav(i-1, j+1)>=bch[i-1][j+1]-'0') { done[i-1][j+1]=true; que.push_back({i-1, j+1}); }\n                if (bch[i][j-1]!='.' && !done[i][j-1] && wav(i, j-1)>=bch[i][j-1]-'0') { done[i][j-1]=true; que.push_back({i, j-1}); }\n                if (bch[i][j+1]!='.' && !done[i][j+1] && wav(i, j+1)>=bch[i][j+1]-'0') { done[i][j+1]=true; que.push_back({i, j+1}); }\n                if (bch[i+1][j-1]!='.' && !done[i+1][j-1] && wav(i+1, j-1)>=bch[i+1][j-1]-'0') { done[i+1][j-1]=true; que.push_back({i+1, j-1}); }\n                if (bch[i+1][j]!='.' && !done[i+1][j] && wav(i+1, j)>=bch[i+1][j]-'0') { done[i+1][j]=true; que.push_back({i+1, j}); }\n                if (bch[i+1][j+1]!='.' && !done[i+1][j+1] && wav(i+1, j+1)>=bch[i+1][j+1]-'0') { done[i+1][j+1]=true; que.push_back({i+1, j+1}); }\n            }\n            vec.clear();\n        }\n        if (que.empty()) break;\n        for (auto u : que)\n        {\n            vec.push_back(u);\n            ok=true;\n        }\n        que.clear();\n    }\n    return ans;\n}\n\nint main()\n{\n    cin>>h>>w;\n    for (int i=0; i<h; i++) for (int j=0; j<w; j++) cin>>bch[i][j];\n    cout<<bfs()<<'\\n';\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cctype>\n#include <algorithm>\n\nusing P = std::pair<std::pair<int, int>, int>;\nconstexpr int MAX = 1000;\n\nint h, w;\nint board[MAX][MAX];\nint dx[8] = { 0,-1,-1,-1,0,1,1,1 }, dy[8] = { -1,-1,0,1,1,1,0,-1 };\n\nint count(int x, int y) {\n\tint cnt = 0;\n\tfor (int i = 0; i < 8; ++i) {\n\t\tif (!board[y + dy[i]][x + dx[i]])\n\t\t\t++cnt;\n\t}\n\treturn cnt;\n}\n\nint solve() {\n\tstd::queue<P> que;\n\n\tfor (int i = 0; i < h; ++i) {\n\t\tfor (int j = 0; j < w; ++j) {\n\t\t\tif (board[i][j]) {\n\t\t\t\tif (board[i][j] <= count(j, i)) {\n\t\t\t\t\tque.push(P(std::make_pair(j, i), 0));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint max = 0;\n\n\tstd::vector<std::pair<int, int>> vec;\n\n\twhile (!que.empty()) {\n\t\tP p = que.front(); que.pop();\n\t\tif (max < p.second) {\n\t\t\tfor (auto& x : vec)\n\t\t\t\tboard[x.second][x.first] = 0;\n\t\t\tvec.clear();\n\t\t\tmax = p.second;\n\n\t\t\tfor (int i = 0; i < h; ++i) {\n\t\t\t\tfor (int j = 0; j < w; ++j)\n\t\t\t\t\tstd::cout << board[i][j] << ' ';\n\t\t\t\tstd::cout << std::endl;\n\t\t\t}\n\n\t\t}\n\t\tif (board[p.first.second][p.first.first] <= count(p.first.first, p.first.second)) {\n\t\t\tvec.push_back(std::make_pair(p.first.first, p.first.second));\n\t\t\tint nx, ny;\n\t\t\tfor (int i = 0; i < 8; ++i) {\n\t\t\t\tnx = p.first.first + dx[i];\n\t\t\t\tny = p.first.second + dy[i];\n\t\t\t\tif (board[ny][nx])\n\t\t\t\t\tque.push(P(std::make_pair(nx, ny), p.second + 1));\n\t\t\t}\n\t\t}\n\t}\n\n\t/*if (!vec.size())\n\t\t--max;*/\n\n\treturn max;\n}\n\nint main() {\n\tstd::cin >> h >> w;\n\n\tchar ch;\n\tfor (int i = 0; i < h; ++i) {\n\t\tfor (int j = 0; j < w; ++j) {\n\t\t\tstd::cin >> ch;\n\t\t\tif (std::isdigit(ch)) {\n\t\t\t\tboard[i][j] = atoi(&ch);\n\t\t\t}\n\t\t}\n\t}\n\n\tstd::cout << solve() << std::endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef pair<int,int> P;\nint dx[8]={-1,-1,-1,0,0,1,1,1},dy[8]={-1,0,1,-1,1,-1,0,1};\nbool check(int n, int m, int x, int y) {return (x>=0&&x<n&&y>=0&&y<m);}\n \nint main() {\n  int n,m;\n  cin >> n >> m;\n  string s[n];\n  for(int i=0; i<n; i++) cin >> s[i];\n  queue<P> que;\n  int d[n][m],a[n][m];\n  memset(d,0,sizeof(d));\n  for(int i=0; i<n; i++) {\n    for(int j=0; j<m; j++) {\n      if(s[i][j]=='.') {\n        que.push(P(i,j));\n        a[i][j]=0;\n      } else a[i][j]=s[i][j]-'0';\n    }\n  }\n  int ans=0;\n  while(!que.empty()) {\n    P p=que.front();que.pop();\n    ans=max(ans,d[p.first][p.second]);\n    for(int i=0; i<8; i++) {\n      int x=p.first+dx[i],y=p.second+dy[i];\n      if(!check(n,m,x,y) || !a[x][y]) continue;\n      a[x][y]--;\n      if(!a[x][y]) {\n        d[x][y]=d[p.first][p.second]+1;\n        que.push(P(x,y));\n      }\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nint dx[] = { 1, 0, -1, 0, 1, 1, -1, -1 };\nint dy[] = { 0, 1, 0, -1, 1, -1, 1, -1 };\n\nint main() {\n  ios::sync_with_stdio( false );\n  cin.tie( 0 );\n  int H, W;\n  cin >> H >> W;\n  vector<vector<int> > info( H, vector<int>(W) );\n  for ( int i = 0; i < H; i++ ) {\n    string c;\n    cin >> c;\n    for ( int j = 0; j < W; j++ ) {\n      if ( c[j] == '.' ) info[ i ][ j ] = 0;\n      else info[ i ][ j ] = c[j] - '0';\n    }\n  }\n  queue<pair<int, pair<int, int> > > q;\n  vector<vector<int> > cnt( H, vector<int>( W, 0 ) );\n  for ( int i = 1; i + 1 < H; i++ ) {\n    for ( int j = 1; j + 1 < W; j++ ) {\n      if ( info[ i ][ j ] ) {\n        for ( int k = 0; k < 8; k++ ) {\n          cnt[ i ][ j ] += !info[ i + dx[ k ] ][ j + dy[ k ] ];\n        }\n        if ( cnt[ i ][ j ] >= info[ i ][ j ] ) {\n          q.push( make_pair( 1, make_pair( i, j ) ) );\n        }\n      }\n    }\n  }\n  int ans = 0;\n  while ( q.size() )\n  {\n    int num = q.front().first;\n    pair<int, int> pos = q.front().second;\n    q.pop();\n    int x = pos.first, y = pos.second;\n    ans = max( ans, num );\n    for ( int i = 0; i < 8; i++ ) {\n      cnt[ x + dx[ i ] ][ y + dy[ i ] ]++;\n      if ( cnt[ x + dx[ i ] ][ y + dy[ i ] ] == info[ x + dx[ i ] ][ y + dy[ i ] ] )\n      {\n        q.push( make_pair( num + 1, make_pair( x + dx[ i ], y + dy[ i ] ) ) );\n      }\n    }\n  }\n  cout << ans << \"\\n\";\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<map>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define in_range(x,l,r) (l<=x && x<r)\nusing namespace std;\ntypedef pair<int,int> pii;\n\nconst int INF = 1e9+7;\nconst int dy[] = {-1,-1,0,1,1,1,0,-1}, dx[] = {0,1,1,1,0,-1,-1,-1};\n\nbool check(int y, int x, int k, vector< vector<int> > &d, int t){\n  int h = d.size(), w = d[0].size();\n  int cnt = 0;\n  rep(i,8){\n    int ny = y+dy[i], nx = x+dx[i];\n    if(!in_range(ny,0,h) || !in_range(nx,0,w))continue;\n    if(d[ny][nx] <= t)cnt++;\n  }\n  return (k <= cnt);\n}\n\nint main(){\n  int h,w;\n  cin >> h >> w;\n\n  vector<string> g(h);\n  vector< vector<int> > d(h,vector<int>(w,INF));\n\n  queue<pii> q;\n  rep(i,h){\n    cin >> g[i];\n    rep(j,w){\n      if(g[i][j] == '.'){\n\tq.push(pii(i,j));\n\td[i][j] = 0;\n      }\n    }\n  }\n\n  int res = 0;\n  while(q.size()){\n    pii p = q.front(); q.pop();\n    int y = p.first, x = p.second;\n\n    res = max(res, d[y][x]);\n\n    rep(i,8){\n      int ny = y+dy[i], nx = x+dx[i];      \n      if(!in_range(ny,0,h) || !in_range(nx,0,w))continue;\n      \n      if(g[ny][nx] != '.' && check(ny,nx,g[ny][nx]-'0',d,d[y][x])){\n\tg[ny][nx] = '.';\n\td[ny][nx] = d[y][x] + 1;\n\tq.push(pii(ny,nx));\n      }\n    }\n  }\n\n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<functional>\nusing namespace std;\nchar s[1000][1001];\ntypedef pair<int,int> P;\nP ko1[1000*1000],ko2[1000*1000];\nint main(void)\n{\n\tint i,j,k,l,n,cnt,h,w,p1,p2,xx,yy,x,y;\n\tint dx[8]={-1,-1,-1,0,0,1,1,1},dy[8]={-1,0,1,-1,1,-1,0,1};\n\tscanf(\"%d %d\",&h,&w);\n\tfor(i=0;i<h;i++)\tscanf(\"%s\",s[i]);\n\tp1=0;\n\tfor(i=0;i<h;i++)\t{\n\t\tfor(j=0;j<w;j++)\t{\n\t\t\tif(s[i][j]!='.')\t{\n\t\t\t\tcnt=0;\n\t\t\t\tfor(k=0;k<8;k++)\t{\n\t\t\t\t\txx=j+dx[k];\tyy=i+dy[k];\n\t\t\t\t\tif(s[yy][xx]=='.')\tcnt++;\n\t\t\t\t}\n\t\t\t\tif(cnt>=s[i][j]-'0')\t{\n\t\t\t\t\tko1[p1].first=i;\tko1[p1].second=j;\n\t\t\t\t\tp1++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tn=0;\n\tif(p1!=0)\t{\n\t\twhile(1)\t{\n\t\t\tp2=0;\n\t\t\tfor(i=0;i<p1;i++)\t{\n\t\t\t\tif(i==0\t|| (i!=0 && !(ko1[i].first==ko1[i-1].first && ko1[i].second==ko1[i-1].second))){\n\t\t\t\t\ty=ko1[i].first;\tx=ko1[i].second;\n//\t\t\t\t\tprintf(\"y=%d x=%d\\n\",y,x);\n\t\t\t\t\tcnt=0;\n\t\t\t\t\tfor(k=0;k<8;k++)\t{\n\t\t\t\t\t\tyy=y+dy[k];\txx=x+dx[k];\n\t\t\t\t\t\tif(s[yy][xx]=='.')\tcnt++;\n\t\t\t\t\t}\n\t\t\t\t\tif(cnt>=s[y][x]-'0')\t{\n//\t\t\t\t\t\tprintf(\"y=%d x=%d\\n\",y,x);\n\t\t\t\t\t\tko2[p2].first=y;\tko2[p2].second=x;\n\t\t\t\t\t\tp2++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n//\t\t\tprintf(\"p2=%d\\n\",p2);\n\t\t\tif(p2==0)\tbreak;\n\t\t\tn++;\n\t\t\tp1=0;\n\t\t\tfor(i=0;i<p2;i++)\t{\n\t\t\t\ty=ko2[i].first;\tx=ko2[i].second;\n\t\t\t\ts[y][x]='.';\n\t\t\t}\n\t\t\tfor(i=0;i<p2;i++)\t{\n\t\t\t\ty=ko2[i].first;\tx=ko2[i].second;\t\t\t\n\t\t\t\tfor(k=0;k<8;k++)\t{\n\t\t\t\t\tyy=y+dy[k];\txx=x+dx[k];\t\n\t\t\t\t\tif(s[yy][xx]!='.')\t{\n\t\t\t\t\t\tko1[p1].first=yy;\tko1[p1].second=xx;\n\t\t\t\t\t\tp1++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(ko1,ko1+p1);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",n);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n#define INF 2000000000\n\n#define MAX_H 1050\n#define MAX_W 1050\n\nint H, W;\n\nchar sand[MAX_H][MAX_W];\n\nint dp[MAX_H][MAX_W];\n\nconst int dx[8] = { -1, -1, -1, 0, 0, 1, 1, 1 };\nconst int dy[8] = { -1, 0, 1, -1, 1, -1, 0, 1 };\n\nbool dfs[MAX_H][MAX_W];\n\nvoid memo(int x, int y)\n{\n\tdfs[y][x] = true;\n\n\tif (dp[y][x] > 1 && x > 0 && x < W - 1 && y > 0 && y < H - 1)\n\t{\n\t\tint temp[8];\n\n\t\tfor (int dir = 0; dir < 8; dir++)\n\t\t{\n\t\t\ttemp[dir] = dp[y + dy[dir]][x + dx[dir]];\n\t\t}\n\n\t\tsort(temp, temp + 8);\n\n\t\tif (sand[y][x] != '9')\n\t\t{\n\t\t\tif (temp[sand[y][x] - 49] != INF)\n\t\t\t{\n\t\t\t\tdp[y][x] = temp[sand[y][x] - 49] + 1;\n\t\t\t}\n\n\t\t\tif (dp[y][x] < INF)\n\t\t\t{\n\t\t\t\tfor (int dir = 0; dir < 8; dir++)\n\t\t\t\t{\n\t\t\t\t\tif (dfs[y + dy[dir]][x + dx[dir]] == false)\n\t\t\t\t\t{\n\t\t\t\t\t\tmemo(x + dx[dir], y + dy[dir]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tmemset(dp, 0, sizeof(dp));\n\n\tcin >> H >> W;\n\n\tfor (int i = 0; i < H; i++)\n\t{\n\t\tfor (int j = 0; j < W; j++)\n\t\t{\n\t\t\tcin >> sand[i][j];\n\n\t\t\tif (sand[i][j] != '.')\n\t\t\t{\n\t\t\t\tdp[i][j] = INF;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 1; i < H - 1; i++)\n\t{\n\t\tfor (int j = 1; j < W - 1; j++)\n\t\t{\n\t\t\tif(dfs[i][j] == true)\n\t\t\t{\n\t\t\t    dfs[i][j] = false;\n\t\t\t}\n\n\t\t\tmemo(j, i);\n\t\t}\n\t}\n\n\tint maxdepth = 0;\n\n\tfor (int i = 1; i < H - 1; i++)\n\t{\n\t\tfor (int j = 1; j < W - 1; j++)\n\t\t{\n\t\t\tif (dp[i][j] < INF)\n\t\t\t{\n\t\t\t\tmaxdepth = max(dp[i][j], maxdepth);\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << maxdepth << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstring>\nusing namespace std;\n\nint main(){\n\tstring S;\n\tint n,m,t,sum,a;\n\tsum=0;\n\tint x[52][52];\n\tbool y[52][52];\n\tmemset(x,0,sizeof(x));\n\tchar T[10]={'.','1','2','3','4','5','6','7','8','9'};\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>S;\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tfor(int k=0;k<10;k++){\n\t\t\t\tif(S[j-1]==T[k]){\n\t\t\t\t\tx[i][j]=k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\twhile(true){\n\t\tt=0;\n\t\tsum++;\n\t\tmemset(y,false,sizeof(y));\n\t\tfor(int i=2;i<n;i++){\n\t\t\tfor(int j=2;j<m;j++){\n\t\t\t\tif(x[i][j]>=1){\n\t\t\t\t\ta=0;\n\t\t\t\t\tfor(int k=-1;k<=1;k++){\n\t\t\t\t\t\tfor(int l=-1;l<=1;l++){\n\t\t\t\t\t\t\tif(k!=0 || l!=0){\n\t\t\t\t\t\t\t\tif(x[i+k][j+l]==0){\n\t\t\t\t\t\t\t\t\ta++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(a>=x[i][j]){\n\t\t\t\t\t\ty[i][j]=true;\n\t\t\t\t\t\tt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\t\n\t\t}\n\t\tif(t==0){\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i=2;i<n;i++){\n\t\t\tfor(int j=2;j<m;j++){\n\t\t\t\tif(y[i][j]==true){\n\t\t\t\t\tx[i][j]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<sum-1<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\nint x, y;\nchar map[1024][1024];\nqueue< pair<int,int> > q;\n\nbool check_map(void){\n\tbool flg = true;\n\tint dx[8] = { 0, 0, 1, -1, 1, -1, 1, -1 }, dy[8] = { 1, -1, 0, 0, 1, -1, -1, 1 };\n\tfor(int i = 0; i < y; i++){\n\t\tfor(int i2 = 0; i2 < x; i2++){\n\t\t\tint cnt = 0;\n\t\t\tif( map[i][i2] != '.' ){\n\t\t\t\tfor(int i3 = 0; i3 < 8; i3++){\n\t\t\t\t\tif(map[ i + dy[i3] ][ i2 + dx[i3] ] == '.'){\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tchar temp = map[i][i2];\n\t\t\t\tif(cnt >= atoi(&temp)){\n\t\t\t\t\tq.push(make_pair(i, i2));\n\t\t\t\t\tflg = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn flg;\n}\n\nint main(){\n\tint cnt = 0;\n\tcin >> y >> x;\n\n\tfor(int i = 0; i < y; i++){\n\t\tfor(int i2 = 0; i2 < x; i2++){\n\t\t\tcin >> map[i][i2];\n\t\t}\n\t}\n\n\twhile(!check_map()){\n\t\twhile(!q.empty()){\n\t\t\tpair<int, int> temp = q.front();\n\t\t\tq.pop();\n\t\t\tmap[temp.first][temp.second] = '.';\n\t\t}\n\t\tcnt++;\n\t}\n\n\tcout << cnt << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint a;\nint b;\nchar are[1001][1001];\nint kore[1001][1001];\nint sore[1001][1001];\nint sata[1001][1001];\nint ushi;\nint uma;\n\nint main(){\n\tcin >> a >> b;\n\tfor (int i = 0; i < a; i++){\n\t\tfor (int j = 0; j < b; j++){\n\t\t\tcin >> are[i][j];\n\t\t\tif (are[i][j] != '.'){\n\t\t\t\tkore[i - 1][j - 1]++;\n\t\t\t\tkore[i][j - 1]++;\n\t\t\t\tkore[i + 1][j - 1]++;\n\t\t\t\tkore[i - 1][j]++;\n\t\t\t\tkore[i + 1][j]++;\n\t\t\t\tkore[i - 1][j + 1]++;\n\t\t\t\tkore[i][j + 1]++;\n\t\t\t\tkore[i + 1][j + 1]++;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i < a - 1; i++){\n\t\tfor (int j = 1; j < b - 1; j++){\n\t\t\tsore[i][j] = kore[i][j];\n\t\t\tsata[i][j] = 1;\n\t\t\t//\tcout<<sore[i][j];\n\t\t}\n\t}\n\t//\tfor (int i = 0; i < a; i++){\n\t//\t\tcout<<endl;\n\t//\t\t\tfor (int j = 0; j < b; j++){\n\t//\t\t\t\tcout<<sata[i][j];}}\n\twhile (true){\n\t\tuma = 0;\n\t\tfor (int i = 1; i < a - 1; i++){\n\t\t\tfor (int j = 1; j < b - 1; j++){\n\t\t\t\tif (sata[i - 1][j - 1] + sata[i][j - 1] + sata[i + 1][j - 1] + sata[i - 1][j] + sata[i + 1][j] + sata[i - 1][j + 1] + sata[i][j + 1] + sata[i+1][j+1] >0){\n\t\t\t\t\t//cout<<are[i][j]<<\" \"<<9-sore[i][j]<<endl;\n\t\t\t\t\tif (are[i][j] != '.' && 9 - sore[i][j] > are[i][j] - 48){\n\t\t\t\t\t\t//cout<<1234<<endl;\n\t\t\t\t\t\tare[i][j] = '.';\n\t\t\t\t\t\tkore[i - 1][j - 1]--;\n\t\t\t\t\t\tkore[i][j - 1]--;\n\t\t\t\t\t\tkore[i + 1][j - 1]--;\n\t\t\t\t\t\tkore[i - 1][j]--;\n\t\t\t\t\t\tkore[i + 1][j]--;\n\t\t\t\t\t\tkore[i - 1][j + 1]--;\n\t\t\t\t\t\tkore[i][j + 1]--;\n\t\t\t\t\t\tkore[i + 1][j + 1]--;\n\t\t\t\t\t\tuma = 1;\n\t\t\t\t\t\tsata[i][j] = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse{sata[i][j] = 0; }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (uma == 1){\n\t\t\tushi++;\n\t\t}\n\t\tif (uma == 0){\n\t\t\tbreak;\n\t\t}\n\t\t//if(ushi>30){\n\t\t//\tcout<<\"popopopopop\"<<endl;\n\t\t//\t\tfor (int i = 0; i < a; i++){\n\t\t//cout<<endl;\n\t\t//\tfor (int j = 0; j < b; j++){\n\t\t//\t\tcout<<sata[i][j];}}\n\t\t//\t}\n\t\tfor (int i = 0; i < a; i++){\n\t\t\tfor (int j = 0; j < b; j++){\n\t\t\t\tsore[i][j] = kore[i][j];\n\t\t//\t\tsata[i][j] = 0;\n\t\t\t}\n\t\t\t//cout<<\"po\"<<endl; \n\t\t}\n\t}\n\tcout << ushi << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <iostream>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\nint h,w;\nint fie[1501][1501];\nint fade[1501][1501];\nint cnt[1501][1501];\nint t[1501][1501];\n\nint bfs(){\n\tqueue<P> que;\n\tint res=0;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tint none=0;\n\t\t\tfor(int k=-1;k<=1;k++){\n\t\t\t\tfor(int l=-1;l<=1;l++){\n\t\t\t\t\tint y=i+k,x=j+l;\n\t\t\t\t\tif(x>=0 && x<w && y>=0 && y<h){\n\t\t\t\t\t\tif(fie[y][x]==0)none++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcnt[i][j]=none;\n\t\t\tif(none>=fie[i][j] && fie[i][j]>=1){\n\t\t\t\tt[i][j]=1;\n\t\t\t\tfade[i][j]=1;\n\t\t\t\tque.push(P(i,j));\n\t\t\t}\n\t\t}\n\t}\n\twhile(que.size()){\n\t\tP q=que.front();\n\t\tque.pop();\n\t\tint y=q.first,x=q.second;\n\t\tfie[y][x]=0;\n\t\tfor(int i=-1;i<=1;i++){\n\t\t\tfor(int j=-1;j<=1;j++){\n\t\t\t\tint nx=x+j,ny=y+i;\n\t\t\t\tif(nx>=0 && nx<w && ny>=0 && ny<h){\n\t\t\t\t\tcnt[ny][nx]++;\n\t\t\t\t\tif(cnt[ny][nx]>=fie[ny][nx] && fie[ny][nx]>=1 && fade[ny][nx]==0){\n\t\t\t\t\t\tfade[ny][nx]=1;\n\t\t\t\t\t\tt[ny][nx]=t[y][x]+1;\n\t\t\t\t\t\tque.push(P(ny,nx));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tres=max(res,t[i][j]);\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(void){\n\tscanf(\"%d %d\",&h,&w);\n\tfor(int i=0;i<h;i++){\n\t\tstring str;\n\t\tcin >> str;\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(str[j]>='0' && str[j]<='9')fie[i][j]=str[j]-'0';\n\t\t}\n\t}\n\tprintf(\"%d\\n\",bfs());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nstruct k{\n\tint x,y;\n};\nint map[1002][1002];\nint main(){\n\tint X,Y,cnt=-1,crash,dx[8]={-1,0,1,-1,1,-1,0,1},dy[8]={1,1,1,0,0,-1,-1,-1},i,i2;\n\tk ii;\n\tchar d;\n\tqueue<k> Q;\n\tcin>>Y>>X;\n\tfor(i=1;i<=Y;i++){\n\t\tfor(i2=1;i2<=X;i2++){\n\t\t\tcin>>d;\n\t\t\tswitch (d){\n\t\t\t\tcase '.':\n\t\t\t\t\tmap[i2][i]=0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '1':\n\t\t\t\t\tmap[i2][i]=1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '2':\n\t\t\t\t\tmap[i2][i]=2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '3':\n\t\t\t\t\tmap[i2][i]=3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '4':\n\t\t\t\t\tmap[i2][i]=4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '5':\n\t\t\t\t\tmap[i2][i]=5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '6':\n\t\t\t\t\tmap[i2][i]=6;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '7':\n\t\t\t\t\tmap[i2][i]=7;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '8':\n\t\t\t\t\tmap[i2][i]=8;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '9':\n\t\t\t\t\tmap[i2][i]=9;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tdo{\n\t\tcnt++;\n\t\twhile(!Q.empty()){\n\t\t\tii=Q.front();\n\t\t\tmap[ii.x][ii.y]=0;\n\t\t\tQ.pop();\n\t\t}\n\t\tfor(i=1;i<=Y;i++){\n\t\t\tfor(i2=1;i2<=X;i2++){\n\t\t\t\tcrash=0;\n\t\t\t\tif(map[i2][i]!=0){\n\t\t\t\t\tfor(int i3=0;i3<8;i3++)if(map[i2+dx[i3]][i+dy[i3]]==0)crash++;\n\t\t\t\t\tif(map[i2][i]<=crash){\n\t\t\t\t\t\tii.x=i2;\n\t\t\t\t\t\tii.y=i;\n\t\t\t\t\t\tQ.push(ii);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}while(!Q.empty());\n\tcout<<cnt<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<int, int> pint;\nqueue<pint> nowque, nexque;\nint h, w;\nint castle[1002][1002] = {};\nchar str[1001];\n\nconst int dir[9] = { -1,-1,0,1,1,0,-1,1,-1 };\nbool check(int i,int j)\n{\n\tif (castle[i][j] == 0)return false;\n\tint c = 0;\n\tfor (int k = 0; k < 8; ++k)\n\t{\n\t\tif (castle[i + dir[k]][j + dir[k + 1]] == 0)++c;\n\t}\n\tif (c >= castle[i][j])\n\t{\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nint main()\n{\n\tscanf(\"%d %d\", &h, &w);\n\tfor (int i = 1; i <= h; ++i)\n\t{\n\t\tscanf(\"%s\",str);\n\t\tfor (int j = 1; j <= w; ++j)\n\t\t{\n\t\t\tcastle[i][j] = ((str[j - 1] == '.') ? 0 : (str[j - 1] - '0'));\n\t\t\tif (castle[i][j] == 0)\n\t\t\t{\n\t\t\t\tnowque.emplace(i, j);\n\t\t\t}\n\t\t}\n\t}\n\tint time = 0;\n\tfor (; true; ++time)\n\t{\n\t\twhile (!nowque.empty())\n\t\t{\n\t\t\tpint x = nowque.front(); nowque.pop();\n\t\t\tfor (int k = 0; k < 8; ++k)\n\t\t\t{\n\t\t\t\tif (check(x.first + dir[k],x.second + dir[k + 1]))\n\t\t\t\t{\n\t\t\t\t\tnexque.emplace(x.first + dir[k], x.second + dir[k + 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnowque = nexque;\n\t\twhile (!nexque.empty())\n\t\t{\n\t\t\tpint y = nexque.front(); nexque.pop();\n\t\t\tcastle[y.first][y.second] = 0;\n\t\t}\n\t\tif (nowque.empty())break;\n\t}\n\tprintf(\"%d\\n\",time);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<string.h>\nusing namespace std;\nstruct log{\n\tint x,y,cnt;\n};\nqueue <log> cls;\nqueue <log> q;\nlog g;\nlong h,w,ans=0,length;\nchar sand[1004][1004];\nint main(){\n\tcin>>h>>w;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int o=0;o<w;o++){\n\t\t\tcin>>sand[i][o];\n\t\t\tif(sand[i][o]!='.'&&sand[i][o]!='9'){\n\t\t\t\tg.y=i;\n\t\t\t\tg.x=o;\n\t\t\t\tg.cnt=0;\n\t\t\t\tq.push(g);\n\t\t\t}\n\t\t}\n\t}\n\tint f,c,fx,fy,my[]={0,1,1,1,0,-1,-1,-1},mx[]={1,1,0,-1,-1,-1,0,1};\n\tdo{\n\t\tf=0;\n\t\tif(!cls.empty()){\n\t\t\tg=cls.front();\n\t\t\tcls.pop();\n\t\t\tsand[g.y][g.x]='.';\n\t\t}\n\t\tlength=q.size();\n\t\tfor(int i=0;i<length;i++){\n\t\t\tg=q.front();\n\t\t\tq.pop();\n\t\t\tc=0;\n\t\t\tfor(int r=0;r<8;r++){\n\t\t\t\tfx=g.x+mx[r];\n\t\t\t\tfy=g.y+my[r];\n\t\t\t\tif(fx>=0&&fx<w&&fy>=0&&fy<h&&sand[fy][fx]=='.'){\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(c>=sand[g.y][g.x]-48){\n\t\t\t\tcls.push(g);\n\t\t\t\tf=1;\n\t\t\t}\n\t\t\telse if(c<sand[g.y][g.x]-48){\n\t\t\t\tq.push(g);\n\t\t\t}\n\t\t}\n\t\tif(f==1){\n\t\t\tans++;\n\t\t}\n\t}while(!cls.empty());\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rrep(i,a,b) for(int i=(a);i<=(b);i++)\n#define P pair<int,int>\nusing namespace std;\n\nint dx[8]={-1,-1,0,1,1,1,0,-1};\nint dy[8]={0,-1,-1,-1,0,1,1,1};\n\nint h,w;\nint a[1002][1002];\nstring s[1002];\n\nint make(int x,int y)\n{\n\tint ans=0;\n\trep(i,8)\n\t{\n\t\tint tx=x+dx[i];\n\t\tint ty=y+dy[i];\n\t\tif(s[tx][ty]=='.')ans++;\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tcin>>h>>w;\n\trep(i,h)cin>>s[i];\n\tvector<P> f[2];\n\tint now=0,pre=1,ans=0;\n\tbool flag;\n\trrep(i,1,h-2)\n\t{\n\t\trrep(j,1,w-2)\n\t\t{\n\t\t\trep(k,8)if(s[i+dx[k]][j+dy[k]]=='.')a[i][j]++;\n\t\t\tif(s[i][j]!='.'&&s[i][j]-'0'<=a[i][j])f[now].pb(mp(i,j));\n\t\t}\n\t}\n\twhile(1)\n\t{\n\t\tflag=false;\n\t\tnow=!now;\n\t\tpre=!pre;\n\t\tf[now].clear();\n\t\trep(i,f[pre].size())\n\t\t{\n\t\t\tP p=f[pre][i];\n\t\t\tif(s[p.fi][p.se]!='.'&&s[p.fi][p.se]-'0'<=a[p.fi][p.se])\n\t\t\t{\n\t\t\t\tflag=true;\n\t\t\t\ts[p.fi][p.se]='.';\n\t\t\t\trep(j,8)\n\t\t\t\t{\n\t\t\t\t\tint tx=p.fi+dx[j];\n\t\t\t\t\tint ty=p.se+dy[j];\n\t\t\t\t\tif(tx<=0||tx>=h-1||ty<=0||ty>=w-1)continue;\n\t\t\t\t\ta[tx][ty]++;\n\t\t\t\t\tif(s[tx][ty]!='.'&&s[tx][ty]-'0'==a[tx][ty])f[now].pb(mp(tx,ty));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(flag)ans++;\n\t\telse break;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct vec2{\n  int x;\n  int y;\n  vec2(int x,int y){\n    this->x = x;\n    this->y = y;\n  }\n};\n\nshort s[1000][1000];\n\nint main(){\n\n    int w,h;\n\n    cin >> w >> h;\n\n    short table[w][h];\n\n    int dirx[8] = {-1,-1,-1,0,0,1,1,1},diry[8] = {-1,0,1,-1,1,-1,0,1};\n\n    char c;\n\n    for(int i=0;i<w;i++){\n      for(int j=0;j<h;j++){\n        cin >> c;\n        if(c=='.'){\n          table[i][j] = -1;\n        }\n        else{\n          stringstream ss;\n          ss << c;\n          ss >> table[i][j];\n        }\n      }\n    }\n\n    int ans = 0,com=-1,rep=-3;\n\n    queue<vec2> q1,q2;\n\n    for(int i=1;i<w-1;i++){\n      for(int j=1;j<h-1;j++){\n\n        int count = 0;\n        for(int k=0;k<8;k++){\n          int di = i + dirx[k],dj = j + diry[k];\n          if(table[di][dj] == -1){\n            count++;\n          }\n        }\n\n        s[i][j] = count;\n\n        if(table[i][j] > 0 && count >= table[i][j]){\n          vec2 tmpvec(i,j);\n          q1.push(tmpvec);\n          //table[i][j] = com;\n        }\n\n\n      }\n    }\n\n    /*for(int i=0;i<w;i++){\n      for(int j=0;j<h;j++){\n        cout << s[i][j] << \" \";\n      }\n      cout << endl;\n    }*/\n\n  //  cout << endl;\n\n    /*for(int i=1;i<w-1;i++){\n      for(int j=1;j<h-1;j++){\n\n          int count = 0;\n          if(table[i+1][j] == com || table[i+1][j] == rep) count++;\n          if(table[i+1][j-1] == com || table[i+1][j-1] == rep) count++;\n          if(table[i+1][j+1] == com || table[i+1][j+1] == rep) count++;\n          if(table[i][j-1] == com) count++;\n          if(table[i][j+1] == com || table[i][j+1] == rep) count++;\n          if(table[i-1][j] == com) count++;\n          if(table[i-1][j+1] == com) count++;\n          if(table[i-1][j-1] == com) count++;\n\n          s[i][j] = count;\n\n      }\n    }*/\n\n    /*for(int i=1;i<w-1;i++){\n      for(int j=1;j<h-1;j++){\n\n        if(table[i][j] == rep){\n          table[i][j] = com;\n\n        }\n      }\n    }*/\n\n  /*  while(!q1.empty()){\n      cout << q1.front().x << \" \" << q1.front().y << endl;\n      q1.pop();\n    }\n    while(1){}*/\n\n  /*  for(int i=0;i<w;i++){\n      for(int j=0;j<h;j++){\n        cout << table[i][j] << \" \";\n      }\n      cout << endl;\n    }\n    cout << endl;*/\n\n    if(q1.empty()) ans = -1;\n\n    while(1){\n\n      if(q1.empty()){\n      /*  for(int i=0;i<w;i++){\n          for(int j=0;j<h;j++){\n            cout << table[i][j] << \" \";\n          }\n          cout << endl;\n        }\n        cout << endl;*/\n        ans++;\n        if(q2.empty()){\n          break;\n        }\n        else{\n          while(!q2.empty()){\n            //cout << ans << \" \" <<  q2.front().x << \" \" << q2.front().y << endl;\n            q1.push(q2.front());\n            q2.pop();\n          }\n\n          /*for(int i=1;i<w-1;i++){\n            for(int j=1;j<h-1;j++){\n              if(table[i][j] == rep){\n                table[i][j] = com;\n              }\n            }\n          }*/\n\n        }\n      }\n\n      vec2 tmpvec = q1.front();\n      q1.pop();\n      int i = tmpvec.x;\n      int j = tmpvec.y;\n\n      if(i != 0 && i != w-1 && j != 0 && j != h-1){\n\n        table[i][j] = com;\n        for(int k=0;k<8;k++){\n          int vi = i+dirx[k];\n          int vj = j+diry[k];\n          s[vi][vj]++;\n        //  cout << ans  << \" \" << vi << \" \" << vj << \" \" << table[vi][vj] << \" \" << s[vi][vj] << endl;\n          if(table[vi][vj] > 0 && s[vi][vj] == table[vi][vj]){\n            vec2 tmpvecs(vi,vj);\n            q2.push(tmpvecs);\n            //table[vi][vj] = com;\n          }\n\n/*\n          s[i+1][j]++;\n          s[i+1][j-1]++;\n          s[i+1][j+1]++;\n          s[i][j-1]++;\n          s[i][j+1]++;\n          s[i-1][j]++;\n          s[i-1][j+1]++;\n          s[i-1][j-1]++;\n\n          table[i][j] = com;\n          vec2 tmpvec(i-1,j-1);\n          q2.push(tmpvec);\n          tmpvec.y++;\n          q2.push(tmpvec);\n          tmpvec.y++;\n          q2.push(tmpvec);\n          tmpvec.x++;tmpvec.y-=2;\n          q2.push(tmpvec);\n          tmpvec.y+=2;\n          q2.push(tmpvec);\n          tmpvec.x++;tmpvec.y-=2;\n          q2.push(tmpvec);\n          tmpvec.y++;\n          q2.push(tmpvec);\n          tmpvec.y++;\n          q2.push(tmpvec);*/\n        }\n      }\n\n    }\n\n\n\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\nusing namespace std;\ntypedef pair<int, int> P;\n\nint h, w, ans;\nint castle[1001][1001];\nint times[1001][1001];\nint dx[] = {-1, 0, 1, -1, 1, -1, 0, 1}, dy[] = {-1, -1, -1, 0, 0, 1, 1, 1};\nchar beach[1001][1001];\n\nint main(){\n    cin >> h >> w;\n    for(int i = 1; i < h; i++){\n        cin >> beach[i];\n    }\n\n    queue<P> Q;\n    for(int i = 1; i < h; i++){\n        for(int j = 1; j < w; j++){\n            if(beach[i][j] == '.'){\n                Q.push(P(i, j));\n            } else{\n                castle[i][j] = (int)beach[i][j] - 48;\n            }\n        }\n    }\n\n    while(Q.size()){\n        P p = Q.front();\n        Q.pop();\n        ans = max(ans, times[p.first][p.second]);\n\n        for(int i = 0; i < 8; i++){\n            int x = p.first + dx[i], y = p.second + dy[i];\n            castle[x][y]--;\n            if(castle[x][y] == 0){\n                Q.push(P(x, y));\n                times[x][y] = times[p.first][p.second] + 1;\n            }\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <queue>\n#include <set>\n#include <algorithm>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nstring board[1001];\nint dx[8] = {0, 1, 1, 1, 0, -1, -1, -1};\nint dy[8] = {1, 1, 0, -1, -1, -1, 0, 1};\nint h, w;\nbool hantei(int y, int x){\n\tif(0 <= y && y < h && 0 <= x && x < w) return true;\n\telse return false;\n}\n\nint main(void){\n\tcin >> h >> w;\n\trep(i, h) cin >> board[i];\n\tqueue<pair<int, int> > q1, q2;\n\trep(i, h)rep(j, w){\n\t\tif(board[i][j] != '.') q1.push(make_pair(i, j));\n\t}\n\n\tint ans = -1, cnt = 0, nowy, nowx;\n\tbool flag = true;\n\twhile(flag){\n\t\tflag = false; ans++;\n\t\tvector<pair<int, int> > memo;//?????????????????????????????????????????????????????????\n\t\tset<pair<int, int> > s;\n\t\tif(cnt % 2 == 0){\n\t\t\twhile(!q1.empty()){//q1??????????????\n\t\t\t\tpair<int, int> now = q1.front(); q1.pop();\n\t\t\t\tif(board[now.first][now.second] == '.') continue;\n\t\t\t\tint tmp = 0;\n\t\t\t\trep(i, 8){\n\t\t\t\t\tint nowy = now.first + dy[i], nowx = now.second + dx[i];\n\t\t\t\t\tif(!hantei(nowy, nowx)) continue;\n\t\t\t\t\tif(board[nowy][nowx] == '.')tmp++;\n\t\t\t\t}\n\t\t\t\tif(tmp >= board[now.first][now.second] - '0'){\n\t\t\t\t\tmemo.push_back(make_pair(now.first, now.second));\n\t\t\t\t\trep(k, 8){//???????????????????????????????????????????????????????????????????\n\t\t\t\t\t\tint ny = now.first + dy[k], nx = now.second + dx[k];\n\t\t\t\t\t\tif(!hantei(ny, nx)) continue;\n\t\t\t\t\t\tif(board[ny][nx] != '.'){\n\t\t\t\t\t\t\ts.insert(make_pair(ny, nx));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\twhile(!q2.empty()){//q2??????????????\n\t\t\t\tpair<int, int> now = q2.front(); q2.pop();\n\t\t\t\tif(board[now.first][now.second] == '.') continue;\n\t\t\t\tint tmp = 0;\n\t\t\t\trep(i, 8){\n\t\t\t\t\tint nowy = now.first + dy[i], nowx = now.second + dx[i];\n\t\t\t\t\tif(!hantei(nowy, nowx)) continue;\n\t\t\t\t\tif(board[nowy][nowx] == '.')tmp++;\n\t\t\t\t}\n\t\t\t\tif(tmp >= board[now.first][now.second] - '0'){\n\t\t\t\t\tmemo.push_back(make_pair(now.first, now.second));\n\t\t\t\t\trep(k, 8){//???????????????????????????????????????????????????????????????????\n\t\t\t\t\t\tint ny = now.first + dy[k], nx = now.second + dx[k];\n\t\t\t\t\t\tif(!hantei(ny, nx)) continue;\n\t\t\t\t\t\tif(board[ny][nx] != '.'){\n\t\t\t\t\t\t\ts.insert(make_pair(ny, nx));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//???????????\n\t\trep(k, memo.size()){\n\t\t\tboard[memo[k].first][memo[k].second] = '.';\n\t\t}\n\t\tif(cnt % 2 == 0){\n\t\t\tfor(auto x : s) q2.push(make_pair(x.first, x.second));\n\t\t}else{\n\t\t\tfor(auto x : s) q1.push(make_pair(x.first, x.second));\n\t\t}\n\t\tcnt++;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long int\n#define MP make_pair\n#define PB push_back\n#define F first\n#define S second\nusing namespace std;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\ntypedef vector<PII> VP;\n\nconst int INF = 3e18;\n\nint h, w;\nchar field[1010][1010];\n\nqueue<PII> qu, qu_new;\nint ans = 0;\n\nint dx[] = {-1, -1, -1, 0, 1, 1, 1, 0}, dy[] = {-1, 0, 1, 1, 1, 0, -1, -1};\n\nsigned main()\n{\n  cin >> h >> w;\n  for(int i = 0; i < h; i++){\n    for(int j = 0; j < w; j++){\n      cin >> field[i][j];\n    }\n  }\n\n  for(int i = 0; i < h; i++){\n    for(int j = 0; j < w; j++){\n      if(field[i][j] == '.'){\n\tqu.push(MP(i, j));\n      }\n    }\n  }\n\n  while(!qu.empty()){\n\n    while(!qu_new.empty()){\n      PII now = qu_new.front();\n      qu_new.pop();\n\n      field[now.F][now.S] = '.';\n    }\n\n    int sz = qu.size();\n    for(int i = 0; i < sz; i++){\n\n      PII now = qu.front();\n      qu.pop();\n      \n      if(field[now.F][now.S] == '.'){\n\tfield[now.F][now.S] = ':';\n\t\n\tfor(int j = 0; j < 8; j++){\n\t  PII next = MP(now.F + dx[j], now.S + dy[j]);\n\n\t  if(1 <= next.F && next.F < h - 1 && 1 <= next.S && next.S < w - 1 && '0' <= field[next.F][next.S] && field[next.F][next.S] <= '9'){\n\t    int ct = 0;\n\t    for(int k = 0; k < 8; k++){\n\t      if(!('0' <= field[next.F + dx[k]][next.S + dy[k]] && field[next.F + dx[k]][next.S + dy[k]] <= '9')){\n\t\tct++;\n\t      }\n\t    }\n\n\t    if(ct >= field[next.F][next.S] - '0'){\n\t      qu_new.push(next);\n\t      qu.push(next);\n\t    }\n\t  }\n\t  \n\t}\n      }\n    }\n    if(!qu.empty()){\n      ans++;\n    }\n  }\n  \n  cout << ans << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\ntypedef pair<int,int> pii;\nint dx[] = {0,0,1,-1,1,1,-1,-1};\nint dy[] = {1,-1,0,0,-1,1,1,-1};\n\nqueue<pii> q;\n\nint main(){\n  int h,w,sand[1000][1000];\n  int sond[1000][1000];\n  scanf(\"%d %d\",&h,&w);\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      char c;\n      scanf(\" %c\",&c);\n      if(c=='.') sand[i][j] = -10;\n      else sand[i][j] = c-'0';\n      if(c=='.') sond[i][j] = -10;\n      else sond[i][j] = c-'0';\n    }\n  }\n  q.push(pii(h,w));\n  for(int i=1;i<h-1;i++){\n    for(int j=1;j<w-1;j++){\n      for(int k=0;k<8;k++) if(sand[i+dx[k]][j+dy[k]]<=-10) sand[i][j]--;\n      if(sand[i][j]<=0&&sand[i][j]>-10) q.push(pii(i,j));\n    }\n  }\n  int ans = 0;\n  while(q.size()>1){\n    int x = q.front().first;\n    int y = q.front().second;\n    q.pop();\n    if(x==h&&y==w){\n      ans++;\n      q.push(pii(x,y));\n      continue;\n    }\n    for(int i=0;i<8;i++){\n      int nx = x+dx[i];\n      int ny = y+dy[i];\n      if(nx>=0&&nx<h&&ny>=0&&ny<w&&sand[nx][ny]>0){\n        sand[nx][ny]--;\n        if(sand[nx][ny]==0){\n          q.push(pii(nx,ny));\n        }\n      }\n    }\n  }\n  printf(\"%d\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\n\nint main() {\n\tint H, W;\n\tchar S[100][100];\n\tint i, j;\n\tint ans = 0, cou = 0, cou2 = 0;\n\tint s[100][100], ss[100][100];\n\tscanf(\"%d %d\", &H, &W);\n\tfor (i = 1; i <= H; i++) {\n\t\tfor (j = 1; j <= W; j++) {\n\t\t\tscanf(\" %c\", &S[i][j]);\n\t\t\tif (S[i][j] == '.') {\n\t\t\t\ts[i][j] = 0;\n\t\t\t\tss[i][j] = 10;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ts[i][j] = S[i][j] - 48;\n\t\t\t\tss[i][j] = 10;\n\t\t\t}\n\t\t}\n\t}\n\t//////////////\n\t//for (i = 1; i <= H; i++) {\n\t\t//for (j = 1; j <= W; j++) {\n\t\t\t//printf(\"%d\", ss[i][j]);\n\t\t//}\n\t\t//printf(\"\\n\");\n\t//}\n\t////////\n\twhile (1) {\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\tif (s[i][j] != 0 && ss[i][j]==10) {\n\t\t\t\t\tif (s[i - 1][j - 1] == 0) {\n\t\t\t\t\t\tcou++;\n\t\t\t\t\t}\n\t\t\t\t\tif (s[i - 1][j] == 0) {\n\t\t\t\t\t\tcou++;\n\t\t\t\t\t}\n\t\t\t\t\tif (s[i - 1][j + 1] == 0) {\n\t\t\t\t\t\tcou++;\n\t\t\t\t\t}\n\t\t\t\t\tif (s[i][j - 1] == 0) {\n\t\t\t\t\t\tcou++;\n\t\t\t\t\t}\n\t\t\t\t\tif (s[i][j + 1] == 0) {\n\t\t\t\t\t\tcou++;\n\t\t\t\t\t}\n\t\t\t\t\tif (s[i + 1][j - 1] == 0) {\n\t\t\t\t\t\tcou++;\n\t\t\t\t\t}\n\t\t\t\t\tif (s[i + 1][j] == 0) {\n\t\t\t\t\t\tcou++;\n\t\t\t\t\t}\n\t\t\t\t\tif (s[i + 1][j + 1] == 0) {\n\t\t\t\t\t\tcou++;\n\t\t\t\t\t}\n\t\t\t\t\tif (cou >= s[i][j]) {\n\t\t\t\t\t\tss[i][j] = 0;\n\t\t\t\t\t\tcou2++;\n\t\t//     \t\t\tprintf(\"%d %d\\n\", i, j);\n\t\t\t\t\t}\n\t\t\t\t\tcou = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//printf(\"%d\\n\", cou2);\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\tif (ss[i][j] == 0) {\n\t\t\t\t\ts[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (cou2 == 0) break;\n\t\tcou2 = 0;\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t//\tprintf(\"%d\", s[i][j]);\n\t\t\t}\n\t\t\t//printf(\"\\n\");\n\t\t}\n\t\t//printf(\"\\n\");\n\t\tans++;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <tuple>\n#include <utility>\n#include <cstring>\n\nusing namespace std;\n\nint h,w;\nchar bch[1003][1003];\nbool done[1003][1003];\n\nint wav (int i, int j)\n{\n    int c=0;\n    if (bch[i-1][j-1]=='.') c++;\n    if (bch[i-1][j]=='.') c++;\n    if (bch[i-1][j+1]=='.') c++;\n    if (bch[i][j-1]=='.') c++;\n    if (bch[i][j+1]=='.') c++;\n    if (bch[i+1][j-1]=='.') c++;\n    if (bch[i+1][j]=='.') c++;\n    if (bch[i+1][j+1]=='.') c++;\n    return c;\n}\n\nint bfs ()\n{\n    int cnt, ans=0;\n    queue<tuple<int, int, int>> que;\n    vector<pair<int, int>> vec;\n    for (int i=1; i<h-1; i++)\n    {\n        for (int j=1; j<w-1; j++)\n        {\n            if (bch[i][j]=='.') continue;\n            cnt=wav(i, j);\n            if (cnt>=bch[i][j]-'0') que.push(make_tuple(1, i, j));\n        }\n    }\n    while (!que.empty())\n    {\n        int a=get<0>(que.front()), b=get<1>(que.front()), c=get<2>(que.front());\n        que.pop();\n        if (bch[b][c]=='.') continue;\n        if (a>ans)\n        {\n            ans=a;\n            for (auto u : vec)\n            {\n                int i=u.first, j=u.second;\n                bch[i][j]='.';\n            }\n            vec.clear();\n            memset(done, false, sizeof(done));\n        }\n        done[b][c]=true;\n        cnt=wav(b, c);\n        if (cnt<bch[b][c]-'0') continue;\n        vec.push_back({b,c});\n        if (bch[b-1][c-1]!='.' && !done[b-1][c-1]) que.push(make_tuple(a+1, b-1, c-1));\n        if (bch[b-1][c]!='.' && !done[b-1][c]) que.push(make_tuple(a+1, b-1, c));\n        if (bch[b-1][c+1]!='.' && !done[b-1][c+1]) que.push(make_tuple(a+1, b-1, c+1));\n        if (bch[b][c-1]!='.' && !done[b][c-1]) que.push(make_tuple(a+1, b, c-1));\n        if (bch[b][c+1]!='.' && !done[b][c+1]) que.push(make_tuple(a+1, b, c+1));\n        if (bch[b+1][c-1]!='.' && !done[b+1][c-1]) que.push(make_tuple(a+1, b+1, c-1));\n        if (bch[b+1][c]!='.' && !done[b+1][c]) que.push(make_tuple(a+1, b+1, c));\n        if (bch[b+1][c+1]!='.' && !done[b+1][c+1]) que.push(make_tuple(a+1, b+1, c+1));\n    }\n    return ans;\n}\n\nint main()\n{\n    cin>>h>>w;\n    for (int i=0; i<h; i++) for (int j=0; j<w; j++) cin>>bch[i][j];\n    cout<<bfs()-1<<'\\n';\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint a;\nint b;\nchar are[1001][1001];\nint kore[1001][1001];\nint sore[1001][1001];\nint sata[1001][1001];\nint ushi;\nint uma;\n\nint main(){\n\tcin >> a >> b;\n\tfor (int i = 0; i < a; i++){\n\t\tfor (int j = 0; j < b; j++){\n\t\t\tcin >> are[i][j];\n\t\t\tif (are[i][j] !='.'){\n\t\t\tkore[i - 1][j - 1]++;\n\t\t\tkore[i][j - 1]++;\n\t\t\tkore[i + 1][j - 1]++;\n\t\t\tkore[i - 1][j]++;\n\t\t\tkore[i + 1][j]++;\n\t\t\tkore[i - 1][j + 1]++;\n\t\t\tkore[i][j + 1]++;\n\t\t\tkore[i + 1][j + 1]++;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < a; i++){\n\t\tfor (int j = 0; j < b; j++){\n\t\t\tsore[i][j] = kore[i][j];\n\t\t\tsata[i][j] = 1;\n\t\t//\tcout<<sore[i][j];\n\t\t}\n\t}\n\twhile (true){\n\t\tuma = 0;\n\t\tfor (int i = 0; i < a; i++){\n\t\t\tfor (int j = 0; j < b; j++){\n\t\t\t\tif (sata[i - 1][j - 1] ==1||sata[i][j - 1] == 1||sata[i + 1][j - 1] == 1||sata[i - 1][j] == 1||sata[i + 1][j] == 1||sata[i - 1][j + 1] == 1||sata[i][j + 1] == 1||sata[i + 1][j + 1] == 1){\n\t\t\t\t\t//cout<<are[i][j]<<\" \"<<9-sore[i][j]<<endl;\n\t\t\t\t\tif (are[i][j] != '.'&&9-sore[i][j] > are[i][j]-48){\n\t\t\t\t\t//cout<<1234<<endl;\n\t\t\t\t\t\tare[i][j] = '.';\n\t\t\t\t\t\tkore[i - 1][j - 1]--;\n\t\t\t\t\t\tkore[i][j - 1]--;\n\t\t\t\t\t\tkore[i + 1][j - 1]--;\n\t\t\t\t\t\tkore[i - 1][j]--;\n\t\t\t\t\t\tkore[i + 1][j]--;\n\t\t\t\t\t\tkore[i - 1][j + 1]--;\n\t\t\t\t\t\tkore[i][j + 1]--;\n\t\t\t\t\t\tkore[i + 1][j + 1]--;\n\t\t\t\t\t\tuma = 1;\n\t\t\t\t\t\tsata[i][j] = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse{ sata[i][j] = 0; }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (uma == 1){\n\t\t\tushi++;\n\t\t}\n\t\tif (uma == 0){\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < a; i++){\n\t\t\tfor (int j = 0; j < b; j++){\n\t\t\t\tsore[i][j] = kore[i][j];\n\t\t\t}\n\t\t//cout<<\"po\"<<endl;\n\t\t}\n\t}\n\tcout << ushi << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstring>\nusing namespace std;\n\nint main(){\n\tstring S;\n\tint n,m,t,sum,a;\n\tsum=0;\n\tint x[52][52];\n\tmemset(x,0,sizeof(x));\n\tchar T[10]={'.','1','2','3','4','5','6','7','8','9'};\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>S;\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tfor(int k=0;k<10;k++){\n\t\t\t\tif(S[j-1]==T[k]){\n\t\t\t\t\tx[i][j]=k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\twhile(true){\n\t\tt=0;\n\t\tsum++;\n\t\tfor(int i=2;i<n;i++){\n\t\t\tfor(int j=2;j<m;j++){\n\t\t\t\tif(x[i][j]>=1){\n\t\t\t\t\ta=0;\n\t\t\t\t\tfor(int k=-1;k<=1;k++){\n\t\t\t\t\t\tfor(int l=-1;l<=1;l++){\n\t\t\t\t\t\t\tif(k!=0 || l!=0){\n\t\t\t\t\t\t\t\tif(x[i+k][j+l]==0){\n\t\t\t\t\t\t\t\t\ta++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(a>=x[i][j]){\n\t\t\t\t\t\tx[i][j]=0;\n\t\t\t\t\t\tt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\t\n\t\t}\n\t\tif(t==0){\n\t\t\tbreak;\n\t\t}\n\t}\n\tcout<<sum<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define loop(i,n) for(int i=1;i<=n;i++)\ntypedef pair<int,int> P;\nint h,w;\nchar sh[1002][1002];\nint houkai[1002][1002];\nqueue<P> q1;\nqueue<P> q2;\nint dir[9]={0,-1,-1,0,1,1,-1,1,0};\n\nbool kuzureru(int i,int j){\n  if(i==1||i==h||j==1||j==w)return 0;\n  if(sh[i][j]=='.')return 0;\n  int kyoudo=(int)(sh[i][j]-'0');\n  int sara=0;\n  loop(e,8){\n    int x=i+dir[e-1];\n    int y=j+dir[e];\n    if(sh[x][y]=='.')sara++;\n  }\n  return (sara>=kyoudo);\n}\n\nint main() {\n  cin>>h>>w;\n  loop(i,h)loop(j,w){\n    cin>>sh[i][j];\n  }\n  loop(i,h)loop(j,w){\n    if(kuzureru(i,j))q1.push(P(i,j));\n  }\n  int nami=0;\n  while(!q1.empty()){\n    nami++;\n    while(!q1.empty()){\n      P p=q1.front();q1.pop();\n      q2.push(p);\n      sh[p.first][p.second]='.';\n    }\n    while(!q2.empty()){\n      P p=q2.front();q2.pop();\n      loop(e,8){\n        int x=p.first+dir[e-1];\n        int y=p.second+dir[e];\n        if(kuzureru(x,y))q1.push(P(x,y));\n      }\n    }\n  }\n  cout<<nami<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <queue>\n\nusing namespace std;\n\nint x, y;\nchar m[1024][1024];\nint map[1024][1024];\nqueue<pair<int, pair<int, int> > > q;\npair<int, pair<int, int> > temp;\n\n\nint dx[8] = { 0, 0, 1, -1, 1, -1, 1, -1 }, dy[8] = { 1, -1, 0, 0, -1, -1, 1, 1 };\n\nvoid check_map() {\n\n\tfor (int i = 0; i < y; i++) {\n\t\tfor (int i1 = 0; i1 < x; i1++) {\n\t\t\tint cnt = 0;\n\t\t\tif (m[i][i1] == '.') {\n\t\t\t\tmap[i][i1] = 0;\n\t\t\t\tq.push(make_pair(0, make_pair(i, i1)));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmap[i][i1] = m[i][i1] - '0';\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint cnt = 0;\n\n\tcin >> y >> x;\n\n\tfor (int i = 0; i < y; i++) {\n\t\tfor (int i1 = 0; i1 < x; i1++) {\n\t\t\tcin >> m[i][i1];\n\t\t}\n\t}\n\n\tcheck_map();\n\t\t\n\twhile (!q.empty()) {\n\n\t\ttemp = q.front();\n\n\t\tq.pop();\n\n\t\tcnt = temp.first;\n\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tif ((map[temp.second.first + dy[i]][temp.second.second + dx[i]] -= 1) == 0)\n\t\t\t\tq.push(make_pair(temp.first + 1, make_pair(temp.second.first + dy[i], temp.second.second + dx[i])));\n\t\t}\n\n\t}\n\n\tcout << cnt << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) begin(r),end(r)\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\nconst int mod = 1000000007;\nconstexpr int inf = ((1<<30)-1)*2+1 ;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dx[] = {-1, 0, 1};\nconst int dy[] = {-1, 0, 1};\n\ninline bool value(int x,int y,int w,int h){\n  return (x >= 0 && x < w && y >= 0 && y < h);\n}\n\nll h,w;\nint im[1000][1000];\ntemplate<class T>\nbool solve(T &v){\n  auto tmp = v;\n  bool f = true;\n  rep(i,h){\n    rep(j,w){\n      if(!im[i][j] && v[i][j] != '.'){\n        ll cnt = 0,imo = 0;\n        rep(y,3){\n          rep(x,3){\n            ll nx = j+dx[x],ny = i + dy[y];\n            if(value(nx,ny,w,h)){\n              if(v[ny][nx] == '.')\n              ++cnt;\n              if(im[ny][nx])\n                ++imo;\n            }\n          }\n        }\n        if(cnt >= v[i][j] - '0'){\n          tmp[i][j] = '.';\n          f = false;\n        }\n        else if(v[i][j] - '0' > 8 - imo){\n          im[i][j] = 1;\n        }\n      }\n    }\n  }\n  v = tmp;\n  return f;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cin >> h >> w;\n  vector<vector<char>> v(h,vector<char>(w));\n  rep(i,h){\n    rep(j,w){\n      cin >> v[i][j];\n      if(v[i][j] == '9') im[i][j] = 1;\n    }\n  }\n\n  ll ans = 0;\n  while(1){\n    if(solve(v)){\n      cout << ans << endl;\n      break;\n    }\n    ++ans;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define Rep(i, a, b) for(int i = (a); i < (b); i++)\n#define rep(i, n) Rep(i, 0, n)\n\nint movX[8] = {-1, 0, 1,-1, 1,-1, 0, 1};\nint movY[8] = {-1,-1,-1, 0, 0, 1, 1, 1};\ntypedef pair<int, int> pii;\n\ntemplate<class T> T read() {\n\tT t;\n\tcin >> t;\n\treturn t;\n}\n\nint main(){\n\tint h=read<int>(),w=read<int>();\n\tint mp[h][w];\n\trep(i,h) rep(j,w){\n\t\tchar c=read<char>();\n\t\tif(c=='.'){\n\t\t\tmp[i][j]=0;\t\t\t\n\t\t}else{\n\t\t\tmp[i][j]=c-'0';\n\t\t}\n\t}\n\tint around[h][w];\n\tRep(i, 1, h-1){\n\t\tRep(j, 1, w-1){\n\t\t\tint a = 0;\n\t\t\trep(k,8) {\n\t\t\t\tint x = i+movX[k];\n\t\t\t\tint y = j+movY[k];\n\t\t\t\tif(!mp[x][y]){\n\t\t\t\t\ta++;\n\t\t\t\t}\n\t\t\t}\n\t\t\taround[i][j]=a;\n\t\t}\n\t}\n\t\n\t\n\tvector<pii> list;\n\tRep(i, 1, h-1){\n\t\tRep(j, 1, w-1){\n\t\t\tif(mp[i][j]>0 && around[i][j]>=mp[i][j]){\n\t\t\t\tlist.push_back(pii(i,j)); \n\t\t\t}\n\t\t}\n\t}\n\tif(list.size()==0){\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\tfor(vector<pii>::iterator it=list.begin();it!=list.end();it++){\n\t\tint i = it->first, j = it->second;\n\t\tmp[i][j] = 0;\n\t\trep(k,8) {\n\t\t\tint x = i+movX[k];\n\t\t\tint y = j+movY[k];\n\t\t\taround[x][y]++;\n\t\t}\n\t\t// printf(\"(%d, %d)\\n\",i,j);\n\t}\n\t// printf(\"=============\\n\");\n\t\n\tint count = 1;\n\twhile(true){\n\t\tvector<pii> list2;\n\t\tfor(vector<pii>::iterator it=list.begin();it!=list.end();it++){\n\t\t\tint i = it->first, j = it->second;\n\t\t\t// cout << i << \" \" << j << endl;\n\t\t\trep(k,8) {\n\t\t\t\tint x = i+movX[k];\n\t\t\t\tint y = j+movY[k];\n\t\t\t\tif(mp[x][y]>0 && around[x][y]>=mp[x][y]){\n\t\t\t\t\tlist2.push_back(pii(x,y));\n\t\t\t\t\t// cout << \"    \" <<  i << \" \" << j << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(list2.size()==0){\n\t\t\tcout << count << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tcount++;\n\t\tfor(vector<pii>::iterator it=list2.begin();it!=list2.end();it++){\n\t\t\tint i = it->first, j = it->second;\n\t\t\tif(mp[i][j]){\n\t\t\t\tmp[i][j] = 0;\n\t\t\t\trep(k,8) {\n\t\t\t\t\tint x = i+movX[k];\n\t\t\t\t\tint y = j+movY[k];\n\t\t\t\t\taround[x][y]++;\n\t\t\t\t}\n\t\t\t\t// printf(\"(%d, %d)\\n\",i,j);\n\t\t\t}\n\t\t}\n\t\t// printf(\"=============\\n\");\n\t\tlist = list2;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint h,w;\nint t[50][50];\nint u[50][50];\nchar str[51];\nint q[3000],l,r;\n\nvoid init(){\n  l=r=0;\n}\n\nvoid push(int x){\n  q[r++]=x;\n}\n\nint pop(){\n  return q[l++];\n}\n\nint main(){\n  init();\n  scanf(\"%d %d\",&h,&w);\n  for(int i=0;i<h;i++){\n    scanf(\"%s\",str);\n    for(int j=0;j<w;j++){\n      if(str[j]=='.'){\n        t[i][j]=0;\n        u[i][j]=0;\n        push(i*w+j);\n      }else{\n        t[i][j]=str[j]-'0';\n      }\n    }\n  }\n\n  int ans=0;\n  while(l!=r){\n    int x=pop();\n    int i=x/w,j=x%w;\n    \n    for(int a=i-1;a<=i+1;a++){\n      for(int b=j-1;b<=j+1;b++){\n        if(0<=a&&a<h&&0<=b&&b<w){\n          t[a][b]--;\n          if(t[a][b]==0){\n            ans=u[a][b]=u[i][j]+1;\n            push(a*w+b);\n          }\n        }\n      }\n    }    \n  }\n  printf(\"%d\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF (1<<29)//INF\n#define F first\n#define S second\n#define VS vector<string>\n#define VI vector<int>\n#define REPI(i,s,n) for(int i=s;i<n;i++)//sni\n#define REPJ(j,s,n) for(int j=s;j<n;j++)//sni\n#define RREPI(i,s,n) for(int i=s;i>=n;i--)//sni\n#define RREPJ(j,s,n) for(int j=s;j>=n;j--)//snj\n#define ALL(a) a.begin(),a.end()// sort(ALL(vec))\n#define SET(a,c) memset(a,c,sizeof(a));//ac0or1\n#define DEBUGONE(x) cout<<#x<<\" : \"<<x<<endl;//\n#define DEBUGTWO(x,y) cout<<#x<<\" : \"<<x<<\" \"<<#y<<\" : \"<<y<<endl;//\n#define DEBUGTHREE(x,y,z) cout<<#x<<\" : \"<<x<<\" \"<<#y<<\" : \"<<y<<\" \"<<#z<<\" : \"<<z<<endl;//\n#define OUTONE(x) cout<<x<<endl;//\n#define OUTTWO(x,y) cout<<x<<\" \"<<y<<endl;//\n#define OUTTHREE(x,y,z) cout<<x<<\" \"<<y<<\" \"<<z<<endl;//\ntypedef long long int64;\ntypedef pair<string,int> Psi;\ntypedef pair<int,int> Pii;\nmain(){\n  int h,w;\n  char map[1001][1001];\n  int dx[8]={-1,0,1,-1,1,-1,0,1};\n  int dy[8]={-1,-1,-1,0,0,1,1,1};\n  cin>>h>>w;\n  REPI(i,0,h){\n    REPJ(j,0,w){\n      cin>>map[i][j];\n    }\n  }\n  queue<Pii> que;\n  queue<Pii> que2;\n  int ans=0;\n  REPI(i,1,h){\n    REPJ(j,1,w){\n      if(map[i][j]!='.'){\n\tint cnt=0;\n\tfor(int k=0;k<8;k++){\n\t  int nx=j+dx[k];\n\t  int ny=i+dy[k];\n\t  if(nx>=0&&ny>=0&&nx<w&&ny<h&&map[ny][nx]=='.'){\n\t    cnt++;\n\t  }\n\t}\n\tif(cnt>=map[i][j]-'0'){\n\t  for(int k=0;k<8;k++){\n\t    int nx=j+dx[k];\n\t    int ny=i+dy[k];\n\t    if(nx>=0&&ny>=0&&nx<w&&ny<h&&map[ny][nx]!='.'){\n\t      que.push(Pii(ny,nx));\n\t    }\n\t  }\n\t  map[i][j]='9';\n\t  que2.push(Pii(i,j));\n\t  ans=1;\n\t}\n      }\n    }\n  }\n  while(!que2.empty()){\n    Pii now=que2.front();\n    que2.pop();\n    int y=now.F;\n    int x=now.S;\n    map[y][x]='.';\n  }\n  while(!que.empty()){\n    int size=que.size();\n    REPI(i,0,size){\n      Pii now=que.front();\n      int x=now.S;\n      int y=now.F;\n      //DEBUGTHREE(ans,x,y);\n      que.pop();\n      int cnt=0;\n      for(int k=0;k<8;k++){\n\tint nx=x+dx[k];\n\tint ny=y+dy[k];\n\tif(nx>=0&&ny>=0&&nx<w&&ny<h&&map[ny][nx]=='.'){\n\t  cnt++;\n\t}\n      }\n      if(map[y][x]!='.'&&cnt>=map[y][x]-'0'){\n\tfor(int k=0;k<8;k++){\n\t  int nx=x+dx[k];\n\t  int ny=y+dy[k]; \n\t  if(nx>=0&&ny>=0&&nx<w&&ny<h&&map[ny][nx]!='.'){\n\t    que.push(Pii(ny,nx));\n\t  }\n\t  map[y][x]='9';\n\t  que2.push(Pii(y,x));\n\t}\n      }\n    }\n    while(!que2.empty()){\n      Pii now=que2.front();\n      que2.pop();\n      int y=now.F;\n      int x=now.S;\n      map[y][x]='.';\n    }\n    if(que.empty()) break;\n    ans++;\n  }\n  OUTONE(ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int>P;\n\nchar sand[1005][1005];\nint sara[1005][1005];\n\nint main(){\n\tint h,w;\n\tcin>>h>>w;\n\t\tqueue<P>now;\n\t\tqueue<P>next;\n\t\t\n\tfor(int i=0;i<h;i++)\n\tfor(int j=0;j<w;j++)cin>>sand[i][j];\n\t\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(sand[i][j]!='.'){\n\t\t\t\tfor(int k=-1;k<=1;k++){\n\t\t\t\t\tfor(int l=-1;l<=1;l++){\n\t\t\t\t\t\tif(sand[i+k][j+l]=='.')sara[i][j]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(sand[i][j]!='.'){\n\t\t\t\t\tint a=sand[i][j]-'0';\n\t\t\t\t\tif(a<=sara[i][j])now.push(make_pair(i,j));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint ans=0;\n\t\t\t\n\t\twhile(now.size()){\n\t\t\tans++;\n\t\t\tint broke=0;\n\t\t\t\n\t\t\twhile(now.size()){\n\t\t\t\tP p=now.front();\n\t\t\t\tnow.pop();\n\t\t\t\t\t\n\t\t\t\tfor(int j=-1;j<=1;j++){\n\t\t\t\t\tfor(int k=-1;k<=1;k++){\t\t\n\t\t\t\tif(sand[p.first+j][p.second+k]!='.'){\n\t\t\t\t\tnext.push(make_pair(p.first+j,p.first+k));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\t\n\t\t\t\tint b=sand[p.first][p.second]-'0';\n\t\t\t\t\n\t\t\t\tif(sara[p.first][p.second]>=b){\n\t\t\t\tfor(int j=-1;j<=1;j++){\n\t\t\t\t\tfor(int k=-1;k<=1;k++){\n\t\t\t\t\tif(sand[p.first+j][p.second+k]!='.')sara[p.first+j][p.second+k]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tsara[p.first][p.second]=0;\n\t\t\t\tsand[p.first][p.second]='.';\n\t\t\t\tbroke++;\n\t\t\t\t}\n\t\t}\n\t\tif(broke==0)break;\n\t\t\n\t\tint c=next.size();\n\t\t\tfor(int i=0;i<c;i++){\n\t\t\t\tnow.push(next.front());\n\t\t\t\tnext.pop();\n\t\t\t\t}\n\t\t}\t\n\t\tcout<<ans<<endl;\n\t\treturn 0;\n\t}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n \nint h, w, ans;\nint castle[1001][1001], times[1001][1001];\nint dx[] = {-1, 0, 1, -1, 1, -1, 0, 1}, dy[] = {-1, -1, -1, 0, 0, 1, 1, 1};\nchar beach[1001][1001];\n \nint main(){\n    scanf(\"%d%d\", &h, &w);\n    for(int i = 0; i < h; i++){\n        scanf(\"%s\", &beach[i]);\n    }\n \n    queue< pair<int, int> > Q;\n    for(int i = 0; i < h; i++){\n        for(int j = 0; j < w; j++){\n            if(beach[i][j] == '.'){\n                Q.push(P(i, j));\n            } else{\n                castle[i][j] = beach[i][j] - '0';\n            }\n        }\n    }\n \n    while(Q.size()){\n        P p = Q.front();\n        Q.pop();\n        ans = max(ans, times[p.first][p.second]);\n \n        for(int i = 0; i < 8; i++){\n            int y = p.first + dy[i], x = p.second + dx[i];\n            if(y < 0 || y >= h || x < 0 || x >= w){\n                continue;\n            }\n \n            castle[y][x]--;\n            if(castle[y][x] == 0){\n                Q.push(P(y, x));\n                times[y][x] = times[p.first][p.second] + 1;\n            }\n        }\n    }\n \n    printf(\"%d\\n\", ans);\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n\nusing namespace std;\n\nint h, w, map[1001][1001];\n\nstruct pos {\n\tint x, y;\n};\n\nstd::queue<pair<pos, int> > que;\n\nint check(int _X, int _Y) {\n\tint count = 0;\n\tfor (int i = -1;i <= 1;i++) {\n\t\tfor (int j = -1;j <= 1;j++) {\n\t\t\tif (map[_X + i][_Y + j] == -1)count++;\n\t\t}\n\t}\n\treturn count;\n}\n\nbool Cl(int _X, int _Y) { return check(_X, _Y) >= map[_X][_Y]; };\n\nvoid Break(int _x, int _y, int _wave) {\n\tpos p;\n\tp.x = _x, p.y = _y;\n\tque.push(make_pair(p, _wave));\n}\n\nint main() {\n\tcin >> h >> w;\n\tfor (int i = 1;i <= h;i++) {\n\t\tfor (int j = 1;j <= w;j++) {\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tif (c == '.')map[i][j] = -1;\n\t\t\telse map[i][j] = c - '0';\n\t\t}\n\t}\n\tfor (int i = 2;i <= h - 1;i++) {\n\t\tfor (int j = 2;j <= w - 1;j++) {\n\t\t\tif (Cl(i, j) && map[i][j] != -1)map[i][j] = 0, Break(i, j, 1);\n\t\t\telse if (map[i][j] != -1) {\n\t\t\t\tmap[i][j] -= check(i, j);\n\t\t\t}\n\t\t}\n\t}\n\tint big = 0;\n\twhile (que.size()) {\n\t\tpair<pos, int> P = que.front();\n\t\tque.pop();\n\t\tpos po;\n\t\tpo = P.first;\n\t\tif (map[po.x][po.y] == -1)continue;\n\t\tbig = std::max(big, P.second);\n\t\tmap[po.x][po.y] = -1;\n\t\tfor (int i = -1;i <= 1;i++) {\n\t\t\tfor (int j = -1;j <= 1;j++) {\n\t\t\t\tpos tep;\n\t\t\t\ttep.x = po.x + i, tep.y = po.y + j;\n\t\t\t\tif (map[tep.x][tep.y] > 0)map[tep.x][tep.y]--;\n\t\t\t\tif (map[tep.x][tep.y] == 0)que.push(make_pair(tep, P.second+1));\n\t\t\t}\n\t\t}\n\t}\n\tcout << big << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<string>\nusing namespace std;\ntypedef pair<int, int> p;\nint main(){\n\tqueue<p> q;\n\tqueue<p> q1;\n\tp s;\n\tp temp;\n\tchar tizu[100][100], mozi[11] = \"123456789\";\n\tint W, H, count = 0, bre = 0, tizu1[100][100] = { 0 }, nami = 0, kazu = 0;\n\tcin >> H >> W;\n\tfor (int i = 0; i < H; i++){\n\t\tfor (int l = 0; l < W; l++){\n\t\t\tcin >> tizu[i][l];\n\t\t\tif (tizu[i][l] != '.'){\n\t\t\t\tfor (int m = 0; m < 10; m++){\n\t\t\t\t\tif (tizu[i][l] == mozi[m]) tizu1[i][l] = m + 1;\n\t\t\t\t}\n\t\t\t\tkazu++;\n\t\t\t\ts = make_pair(i, l);\n\t\t\t\tq.push(s);\n\t\t\t}\n\t\t}\n\t}\n\twhile (!q.empty()){\n\t\tnami++;\n\t\tfor (int l = 0; l < kazu; l++){\n\t\t\ts = q.front();\n\t\t\tq.pop();\n\t\t\tint dx1[8] = { 1, -1, 0, 0, -1, -1, 1, 1 }, dx2[8] = { 0, 0, 1, -1, -1, 1, -1, 1 };\n\t\t\tfor (int i = 0; i < 8; i++){\n\t\t\t\tif (tizu[s.first + dx1[i]][s.second + dx2[i]] == '.'){\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}if (count >= tizu1[s.first][s.second]) {\n\t\t\t\tq1.push(s);\n\t\t\t\tbre++;\n\t\t\t}\n\t\t\telse q.push(s);\n\t\t\tcount = 0;\n\t\t}cout << bre;\n\t\tfor (int i = 0; i < bre; i++){\n\t\t\ttemp = q1.front();\n\t\t\tq1.pop();\n\t\t\ttizu[temp.first][temp.second] = '.';\n\t\t}\n\t\tfor (int i = 0; i < H; i++){\n\t\t\tfor (int l = 0; l < W; l++){\n\t\t\t\tcout << tizu[i][l];\n\t\t\t}cout << endl;\n\t\t}\n\t\tif (bre == 0) {\n\t\t\tcout << nami-1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tkazu = kazu - bre;\n\t\tbre = 0;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint h, w;\nint a[1010][1010];\n\nint dx[] = {-1, 0, 1, -1, 1, -1, 0, 1};\nint dy[] = {-1, -1, -1, 0, 0, 1, 1, 1};\n\nint main()\n{\n  cin >> h >> w;\n  for (int i = 0; i < h; i++){\n    for (int j = 0; j < w; j++){\n      char c;\n      cin >> c;\n      if (c == '.') a[i][j] = 0;\n      else a[i][j] = c - '0';\n    }\n  }\n\n  int cnt = 0;\n  bool f = true;\n\n  while (f){\n/*    cout << cnt << endl;\n    for (int i = 0; i < h; i++){\n      for (int j = 0; j < w; j++){\n        if (a[i][j] != -1) cout << \" \";\n        cout << a[i][j] << \" \";\n      }\n      cout << endl;\n    }\n    cout << endl;\n*/\n\n    for (int i = 0; i < h; i++){\n      for (int j = 0; j < w; j++){\n        if (a[i][j] == 0) a[i][j] = -1;\n      }\n    }\n\n    f = false;\n    for (int i = 0; i < h; i++){\n      for (int j = 0; j < w; j++){\n        if (a[i][j] != -1) continue;\n        a[i][j]--;\n        \n        for (int k = 0; k < 8; k++){\n          int y = i + dy[k];\n          int x = j + dx[k];\n          if (y < 0 || h <= y || x < 0 || w <= x) continue;\n          if (a[y][x] <= 0) continue;\n          a[y][x]--;\n        }\n      }\n    }\n\n    for (int i = 0; i < h; i++){\n      for (int j = 0; j < w; j++){\n        if (a[i][j] == 0) f = true;\n      }\n    }\n\n    cnt++;\n  }\n\n  cout << cnt - 1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint n, m;\nchar c[1000][1001];\n\nint main(){\n\tscanf(\"%d%d\", &n, &m);\n\trep(i, n){\n\t\tscanf(\"%s\", c[i]);\n\t}\n\n\tqueue<P> q;\n\trep(i, n){\n\t\trep(j, m){\n\t\t\tif(c[i][j] != '.'){\n\t\t\t\tq.push(P(i, j));\n\t\t\t}\n\t\t}\n\t}\n\n\tint a = 0;\n\twhile(!q.empty()){\n\t\t/*\n\t\trep(i, n){\n\t\t\tputs(c[i]);\n\t\t}\n\t\tprintf(\"%d\\n\", q.size());\n\t\t*/\n\n\t\tset<P> s;\n\t\tset<P> t;\n\t\tint y = q.size();\n\t\trep(k, y){\n\t\t\tP v = q.front();\n\t\t\tq.pop();\n\t\t\tif(c[v.first][v.second] == '.'){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint z = 0;\n\t\t\t\n\t\t\tfor(int i = -1; i <= 1; ++i){\n\t\t\t\tfor(int j = -1; j <= 1; ++j){\n\t\t\t\t\tint x = v.first + i;\n\t\t\t\t\tint y = v.second + j;\n\t\t\t\t\tif((i != 0 || j != 0) && 0 <= x && x < n && 0 <= y && y < m){\n\t\t\t\t\t\tif(c[x][y] == '.'){\n\t\t\t\t\t\t\t++z;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(z >= c[v.first][v.second] - '0'){\n\t\t\t\ts.insert(v);\n\t\t\t\tfor(int i = -1; i <= 1; ++i){\n\t\t\t\t\tfor(int j = -1; j <= 1; ++j){\n\t\t\t\t\t\tint x = v.first + i;\n\t\t\t\t\t\tint y = v.second + j;\n\t\t\t\t\t\tif((i != 0 || j != 0) && 0 <= x && x < n && 0 <= y && y < m){\n\t\t\t\t\t\t\tif(c[x][y] != '.'){\n\t\t\t\t\t\t\t\tt.insert(P(x, y));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!s.empty()){\n\t\t\t++a;\n\t\t}\n\t\tfor(auto it = s.begin(); it != s.end(); ++it){\n\t\t\tc[it->first][it->second] = '.';\n\t\t\t// printf(\"s %d\\n\", s.size());\n\t\t}\n\t\tfor(auto it = t.begin(); it != t.end(); ++it){\n\t\t\tq.push(*it);\n\t\t\t// printf(\"t %d\\n\", t.size());\n\t\t}\n\t}\n\tprintf(\"%d\\n\", a);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define f first\n#define s second\n#define mk make_pair\nusing namespace std;\ntypedef pair<int,int> P;\nint h,w,ans=0;\nint dx[]={-1,-1,-1,0,0,1,1,1};\nint dy[]={1,0,-1,1,-1,1,0,-1};\nstring s[1001];\nbool used[1001][1001];\nmain(){\n\tcin>>h>>w;\n\tr(i,h)cin>>s[i];\n\tqueue<pair<pair<int,int>,int> >q;\n\tr(i,h)r(j,w)if(isdigit(s[i][j])){\n\t\tint sum=0;\n\t\tr(k,8){\n\t\t\tint y=i+dy[k];\n\t\t\tint x=j+dx[k];\n\t\t\tif(y<0||x<0||x>=w||y>=h)continue;\n\t\t\tif(s[y][x]=='.')sum++;\n\t\t}\n\t\tif(s[i][j]-'0'<=sum){\n\t\t\tused[i][j]=1;\n\t\t\tq.push(mk(mk(i,j),1));\n\t\t}\n\t}\n\twhile(!q.empty()){\n\t\tvector<P>v;\n\t\twhile(!q.empty()){\n\t\t\tpair<pair<int,int>,int>p=q.front();q.pop();\n\t\t\tans=p.s;\n\t\t\ts[p.f.f][p.f.s]='.';\n\t\t\tv.push_back(P(p.f.f,p.f.s));\n\t\t}\n\t\tr(i,v.size())r(j,8){\n\t\t\tint y=v[i].f+dy[j];\n\t\t\tint x=v[i].s+dx[j];\n\t\t\tif(0<=y&&y<h&&0<=x&&x<w&&isdigit(s[y][x])){\n\t\t\t\tint sum=0;\n\t\t\t\tr(k,8){\n\t\t\t\t  int yy=y+dy[k];\n\t\t\t      int xx=x+dx[k];\n\t\t\t      if(yy<0||xx<0||xx>=w||yy>=h)continue;\n\t\t\t      if(s[yy][xx]=='.')sum++;\n\t\t\t    }\n\t\t\t    if(s[y][x]-'0'<=sum&&!used[y][x]){\n\t\t\t    \tused[y][x]=1;\n\t\t\t    \tq.push(mk(mk(y,x),ans+1));\n\t\t\t    }\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct vec2{\n  int x;\n  int y;\n  vec2(int x,int y){\n    this->x = x;\n    this->y = y;\n  }\n};\n\nint main(){\n\n    int w,h;\n\n    cin >> w >> h;\n\n    int table[w][h],copy[w][h];\n\n    char c;\n\n    for(int i=0;i<w;i++){\n      for(int j=0;j<h;j++){\n        cin >> c;\n        if(c=='.'){\n          table[i][j] = -1;\n        }\n        else{\n          stringstream ss;\n          ss << c;\n          ss >> table[i][j];\n        }\n      }\n    }\n\n    bool flag = true;\n\n    int ans = 0,com=-1,sub,rep=-3;\n\n    queue<vec2> q1,q2;\n\n    for(int i=0;i<w;i++){\n      for(int j=0;j<h;j++){\n\n        if(table[i][j] != com && i != 0 && i != w-1 && j != 0 && j!= h-1){\n\n          int count = 0;\n          if(table[i+1][j] == com || table[i+1][j] == rep) count++;\n          if(table[i+1][j-1] == com || table[i+1][j-1] == rep) count++;\n          if(table[i+1][j+1] == com || table[i+1][j+1] == rep) count++;\n          if(table[i][j-1] == com) count++;\n          if(table[i][j+1] == com || table[i][j+1] == rep) count++;\n          if(table[i-1][j] == com) count++;\n          if(table[i-1][j+1] == com) count++;\n          if(table[i-1][j-1] == com) count++;\n\n          if(count >= table[i][j]){\n            table[i][j] = rep;\n            vec2 tmpvec(i-1,j-1);\n            q1.push(tmpvec);\n            tmpvec.y++;\n            q1.push(tmpvec);\n            tmpvec.y++;\n            q1.push(tmpvec);\n            tmpvec.x++;tmpvec.y-=2;\n            q1.push(tmpvec);\n            tmpvec.y+=2;\n            q1.push(tmpvec);\n            tmpvec.x++;tmpvec.y-=2;\n            q1.push(tmpvec);\n            tmpvec.y++;\n            q1.push(tmpvec);\n            tmpvec.y++;\n            q1.push(tmpvec);\n          }\n\n        }\n        else{\n          table[i][j] = com;\n        }\n      }\n    }\n\n    for(int i=1;i<w-1;i++){\n      for(int j=1;j<h-1;j++){\n\n        if(table[i][j] == rep){\n          table[i][j] = com;\n\n        }\n      }\n    }\n\n  /*  while(!q1.empty()){\n      cout << q1.front().x << \" \" << q1.front().y << endl;\n      q1.pop();\n    }\n    while(1){}*/\n\n    /*for(int i=0;i<w;i++){\n      for(int j=0;j<h;j++){\n        cout << table[i][j] << \" \";\n      }\n      cout << endl;\n    }\n    cout << endl;*/\n\n    while(1){\n\n      if(q1.empty()){\n        /*for(int i=0;i<w;i++){\n          for(int j=0;j<h;j++){\n            cout << table[i][j] << \" \";\n          }\n          cout << endl;\n        }\n        cout << endl;*/\n        ans++;\n        if(q2.empty()){\n          break;\n        }\n        else{\n          while(!q2.empty()){\n            q1.push(q2.front());\n            q2.pop();\n          }\n          for(int i=1;i<w-1;i++){\n            for(int j=1;j<h-1;j++){\n\n              if(table[i][j] == rep){\n                table[i][j] = com;\n\n              }\n            }\n          }\n        }\n      }\n\n      vec2 tmpvec = q1.front();\n      q1.pop();\n      int i = tmpvec.x;\n      int j = tmpvec.y;\n\n      if(table[i][j] != com && i != 0 && i != w-1 && j != 0 && j!= h-1){\n\n        int count = 0;\n\n        if(table[i+1][j] == com /*|| table[i+1][j] == rep*/) count++;\n        if(table[i+1][j-1] == com /*|| table[i+1][j-1] == rep*/) count++;\n        if(table[i+1][j+1] == com /*|| table[i+1][j+1] == rep*/) count++;\n        if(table[i][j-1] == com) count++;\n        if(table[i][j+1] == com /*|| table[i][j+1] == rep*/) count++;\n        if(table[i-1][j] == com) count++;\n        if(table[i-1][j+1] == com) count++;\n        if(table[i-1][j-1] == com) count++;\n\n      //  cout << count << \" \" << table[i][j] << \" \" << i << \" \" << j << endl;\n\n        if(count >= table[i][j]){\n          table[i][j] = rep;\n          vec2 tmpvec(i-1,j-1);\n          q2.push(tmpvec);\n          tmpvec.y++;\n          q2.push(tmpvec);\n          tmpvec.y++;\n          q2.push(tmpvec);\n          tmpvec.x++;tmpvec.y-=2;\n          q2.push(tmpvec);\n          tmpvec.y+=2;\n          q2.push(tmpvec);\n          tmpvec.x++;tmpvec.y-=2;\n          q2.push(tmpvec);\n          tmpvec.y++;\n          q2.push(tmpvec);\n          tmpvec.y++;\n          q2.push(tmpvec);\n        }\n      }\n\n    }\n\n\n\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <queue>\nusing namespace std;\ntypedef pair<int, int> P;\n \nint h, w, ans;\nint castle[1001][1001], times[1001][1001];\nint dx[] = {-1, 0, 1, -1, 1, -1, 0, 1}, dy[] = {-1, -1, -1, 0, 0, 1, 1, 1};\nchar beach[1001][1001];\n \nint main(){\n    scanf(\"%d%d\", &h, &w);\n    for(int i = 0; i < h; i++){\n        scanf(\"%s\", &beach[i]);\n    }\n \n    queue<P> Q;\n    for(int i = 0; i < h; i++){\n        for(int j = 0; j < w; j++){\n            if(beach[i][j] == '.'){\n                Q.push(P(i, j));\n            } else{\n                castle[i][j] = (int)beach[i][j] - '0';\n            }\n        }\n    }\n \n    while(Q.size()){\n        P p = Q.front();\n        Q.pop();\n        ans = max(ans, times[p.first][p.second]);\n \n        for(int i = 0; i < 8; i++){\n            int y = p.first + dy[i], x = p.second + dx[i];\n            if(y < 0 || y >= h || x < 0 || x >= w){\n                continue;\n            }\n \n            castle[y][x]--;\n            if(castle[y][x] == 0){\n                Q.push(P(y, x));\n                times[y][x] = times[p.first][p.second] + 1;\n            }\n        }\n    }\n \n    printf(\"%d\\n\", ans);\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <utility>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n\n#define INF_LL 9000000000000000000\n#define INF 2000000000\n\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int i = (a);i < (b);i++)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> PPII;\ntypedef pair<int, PPII> PPPII;\n\nclass Union_find{\nprivate:\n\tvector<int> par;\n\tvector<int> rank;\n\tint n;\n\npublic:\n\tUnion_find(int a){\n\t\tn = a;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tpar.push_back(i);\n\t\t\trank.push_back(0);\n\t\t}\n\t}\n\n\tint find(int x){\n\t\tif(par[x] == x){\n\t\t\treturn x;\n\t\t}else{\n\t\t\treturn par[x] = find(par[x]);\n\t\t}\n\t}\n\n\tvoid unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return;\n\n\t\tif(rank[x] < rank[y]){\n\t\t\tpar[x] = y;\n\t\t}else{\n\t\t\tpar[y] = x;\n\t\t\tif(rank[x] == rank[y]) rank[x]++;\n\t\t}\n\t}\n\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n};\n\nint dx[3] = {-1, 1, 0};\n\nint main(void){\n\tint h, w;\n\tstring sand[1010][2];\n\tcin >> h >> w;\n\tREP(i, h){\n\t\tcin >> sand[i][0];\n\t}\n\tint cnt = 1;\n\tint res = 0;\n\twhile(cnt != 0){\n\t\tcnt = 0;\n\t\tFOR(i, 1, h-1){\n\t\t\tFOR(j, 1, w-1){\n\t\t\t\tint sarati = 0;\n\t\t\t\tREP(x, 3){\n\t\t\t\t\tREP(y, 3){\n\t\t\t\t\t\tif(x == 2 && y == 2) continue;\n\t\t\t\t\t\tif(sand[i+dx[x]][res%2][j+dx[y]] == '.') sarati++;\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(sand[i][res%2][j] != '.' && sarati >= sand[i][res%2][j]-'0'){\n\t\t\t\t\tsand[i][(res+1)%2][j] = '.';\n\t\t\t\t\tcnt++;\n\t\t\t\t}else{\n\t\t\t\t\tsand[i][(res+1)%2][j] = sand[i][res%2][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(cnt > 0) res++;\n\t}\n\tcout << res;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define f first\n#define s second\n#define mk make_pair\nusing namespace std;\ntypedef pair<int,int> P;\nint h,w,ans=0;\nint dx[]={-1,-1,-1,0,0,1,1,1};\nint dy[]={1,0,-1,1,-1,1,0,-1};\nstring s[1001];\nmain(){\n\tcin>>h>>w;\n\tr(i,h)cin>>s[i];\n\tqueue<pair<pair<int,int>,int>>q;\n\tr(i,h)r(j,w)if(isdigit(s[i][j])){\n\t\tint sum=0;\n\t\tr(k,8){\n\t\t\tint y=i+dy[k];\n\t\t\tint x=j+dx[k];\n\t\t\tif(y<0||x<0||x>=w||y>=h)continue;\n\t\t\tif(s[y][x]=='.')sum++;\n\t\t}\n\t\tif(s[i][j]-'0'<=sum)q.push(mk(mk(i,j),1));\n\t}\n\twhile(!q.empty()){\n\t\tvector<P>v;\n\t\twhile(!q.empty()){\n\t\t\tpair<pair<int,int>,int>p=q.front();q.pop();\n\t\t\tans=p.s;\n\t\t\ts[p.f.f][p.f.s]='.';\n\t\t\tv.push_back(P(p.f.f,p.f.s));\n\t\t}\n\t\tr(i,v.size())r(j,8){\n\t\t\tint y=v[i].f+dy[j];\n\t\t\tint x=v[i].s+dx[j];\n\t\t\tif(0<=y&&y<h&&0<=x&&x<w&&isdigit(s[y][x])){\n\t\t\t\tint sum=0;\n\t\t\t\tr(k,8){\n\t\t\t\t  int yy=y+dy[k];\n\t\t\t      int xx=x+dx[k];\n\t\t\t      if(yy<0||xx<0||xx>=w||yy>=h)continue;\n\t\t\t      if(s[yy][xx]=='.')sum++;\n\t\t\t    }\n\t\t\t    if(s[y][x]-'0'<=sum)q.push(mk(mk(y,x),ans+1));\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\nint main() {\n    int h, w;\n    cin >> h >> w;\n    vector<vector<int>> v(h, vector<int>(w, 0));\n    auto visited = v;\n    queue<tuple<int, int, int>> Q;\n    for (int i = 0; i < h; ++i) {\n        string s;\n        cin >> s;\n        for (int j = 0; j < w; ++j) {\n            if(s[j] != '.') {\n                v[i][j] = s[j] - '0';\n                Q.emplace(i, j, 1);\n                visited[i][j] = 1;\n            }\n        }\n    }\n    array<int, 8> dx{1, 1, 1, 0, 0, -1, -1, -1}, dy{1, 0, -1, 1, -1, 1, 0, -1};\n    int ans = 0;\n    int m = 0;\n    stack<pair<int, int>> S;\n    while(!Q.empty()){\n        int i, j, n; tie(i, j, n) = Q.front(); Q.pop();\n\n        int cnt = 0;\n        if(n > m){\n            m = n;\n            while(!S.empty()){\n                int p, q; tie(p, q) = S.top(); S.pop();\n                v[p][q] = 0;\n            }\n        }\n        if(!v[i][j]) continue;\n        for (int k = 0; k < 8; ++k) {\n            if(!v[i+dy[k]][j+dx[k]]) cnt++;\n        }\n        if(cnt >= v[i][j]){\n            S.emplace(i, j);\n            ans = max(ans, n);\n            for (int k = 0; k < 8; ++k) {\n                if(v[i+dy[k]][j+dx[k]] && visited[i+dy[k]][j+dx[k]] < n+1) {\n                    visited[i+dy[k]][j+dx[k]] = n+1;\n                    Q.emplace(i+dy[k], j+dx[k], n+1);\n                }\n            }\n        }\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<math.h>\n#include<queue>\n#include<set>\n#include<map>\n#include<random>\n#include<functional>\n#include<utility>\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define pb push_back\n#define P pair<int, int>\n#define mp make_pair\n\nusing namespace std;\n\ntypedef long long ll;\n\n\nint dx[] = { 0, 1, 1, 1, 0, -1, -1, -1 };\nint dy[] = { -1, -1, 0, 1, 1, 1, 0 , -1 };\n\nstruct castle {\n\tint x, y;\n\tcastle(int x, int y) :x(x), y(y) {}\n};\n\nint H, W;\nstring masu[1000];\nint cnt[1000][1000] = {};\nbool broken[1000][1000] = {};\n\nqueue<castle> que[2];\n\nint main() {\n\tint t = 0;\n\n\tcin >> H >> W;\n\tfor (int i = 0; i < H; i++) {\n\t\tcin >> masu[i];\n\t}\n\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (masu[i][j] == '.') continue;\n\t\t\t\n\t\t\tfor (int k = 0; k < 8; k++) {\n\t\t\t\tif (masu[i + dx[k]][j + dy[k]] == '.') {\n\t\t\t\t\tcnt[i][j]++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (masu[i][j] - '0' <= cnt[i][j]) {\n\t\t\t\tbroken[i][j] = true;\n\t\t\t\tque[t].emplace(i, j);\n\t\t\t}\n\t\t}\n\t}\n\n\tint res = 0;\n\twhile (!que[t].empty())\n\t{\n\t\tres++;\n\t\twhile (!que[t].empty())\n\t\t{\n\t\t\tcastle last = que[t].front();\n\t\t\tque[t].pop();\n\n\t\t\tfor (int i = 0; i < 8; i++) {\n\t\t\t\tint x = last.x + dx[i], y = last.y + dy[i];\n\t\t\t\tif (masu[x][y] == '.' || broken[x][y]) continue;\n\t\t\t\tcnt[x][y]++;\n\n\t\t\t\tif (masu[x][y] - '0' <= cnt[x][y]) {\n\t\t\t\t\tbroken[x][y] = true;\n\t\t\t\t\tque[!t].emplace(x, y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tt = !t;\n\t}\n\t\n\n\tcout << res << endl;\n\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint h,w;\nint t[1000][1000];\nint u[1000][1000];\nchar str[1001];\nint q[1000000],l,r;\n\nvoid init(){\n  l=r=0;\n}\n\nvoid push(int x){\n  q[r++]=x;\n}\n\nint pop(){\n  return q[l++];\n}\n\nint main(){\n  init();\n  scanf(\"%d %d\",&h,&w);\n  for(int i=0;i<h;i++){\n    scanf(\"%s\",str);\n    for(int j=0;j<w;j++){\n      if(str[j]=='.'){\n        t[i][j]=0;\n        u[i][j]=0;\n        push(i*w+j);\n      }else{\n        t[i][j]=str[j]-'0';\n      }\n    }\n  }\n  int ans=0;\n  while(l!=r){\n    int x=pop();\n    int i=x/w,j=x%w;\n    /*\n    cout<<u[i][j]<<endl;\n    for(int a=0;a<h;a++){\n      for(int b=0;b<w;b++){\n        printf(\"%3d\",t[a][b]);\n      }\n      cout<<endl;\n    }\n    cout<<endl;\n    */\n    for(int a=i-1;a<=i+1;a++){\n      for(int b=j-1;b<=j+1;b++){\n        if(0<=a&&a<h&&0<=b&&b<w){\n          t[a][b]--;\n          if(t[a][b]==0){\n            ans=u[a][b]=u[i][j]+1;\n            push(a*w+b);\n          }\n        }\n      }\n    }    \n  }\n  printf(\"%d\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint h,w;\nint t[1000][1000];\nint u[1000][1000];\nchar str[51];\nint q[1000000],l,r;\n\nvoid init(){\n  l=r=0;\n}\n\nvoid push(int x){\n  q[r++]=x;\n}\n\nint pop(){\n  return q[l++];\n}\n\nint main(){\n  init();\n  scanf(\"%d %d\",&h,&w);\n  for(int i=0;i<h;i++){\n    scanf(\"%s\",str);\n    for(int j=0;j<w;j++){\n      if(str[j]=='.'){\n        t[i][j]=0;\n        u[i][j]=0;\n        push(i*w+j);\n      }else{\n        t[i][j]=str[j]-'0';\n      }\n    }\n  }\n  int ans=0;\n  while(l!=r){\n    int x=pop();\n    int i=x/w,j=x%w;\n    /*\n    cout<<u[i][j]<<endl;\n    for(int a=0;a<h;a++){\n      for(int b=0;b<w;b++){\n        printf(\"%3d\",t[a][b]);\n      }\n      cout<<endl;\n    }\n    cout<<endl;\n    */\n    for(int a=i-1;a<=i+1;a++){\n      for(int b=j-1;b<=j+1;b++){\n        if(0<=a&&a<h&&0<=b&&b<w){\n          t[a][b]--;\n          if(t[a][b]==0){\n            ans=u[a][b]=u[i][j]+1;\n            push(a*w+b);\n          }\n        }\n      }\n    }    \n  }\n  printf(\"%d\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_H 1010\n#define MAX_W 1010\n\nstruct P{\n  int x,y;\n  P(int x,int y) : x(x), y(y) {}\n};\n\nbool inField(int x,int y,int H,int W){\n  return (0 <= x && x < W && 0 <= y && y < H);\n}\n\nint main(){\n  int H,W,arr[MAX_H][MAX_W];\n  char ch;\n  cin >> H >> W;\n  for(int i = 0 ; i < H ; i++){\n    for(int j = 0 ; j < W ; j++){\n      cin >> ch;\n      arr[i][j] = (ch == '.' ? -1 : ch-'0');\n    }\n  }\n  int cnt[MAX_H][MAX_W];\n  memset(cnt,0,sizeof(cnt));\n  const int dx[8] = {-1,-1,-1,0,0,1,1,1};\n  const int dy[8] = {-1,0,1,-1,1,-1,0,1};\n  queue<P> Q;\n  for(int i = 0 ; i < H ; i++){\n    for(int j = 0 ; j < W ; j++){\n      if(arr[i][j] == -1){ continue; }\n      for(int k = 0 ; k < 8 ; k++){\n        int nx = j + dx[k];\n        int ny = i + dy[k];\n        if(!inField(nx,ny,H,W)){ continue; }\n        if(arr[ny][nx] == -1){\n          cnt[i][j]++;\n        }\n      }\n      if(arr[i][j] <= cnt[i][j]){\n        Q.push(P(j,i));\n      }\n    }\n  }\n  int res = 0;\n  while(!Q.empty()){\n    queue<P> nQ;\n    while(!Q.empty()){\n      P p = Q.front(); Q.pop();\n      for(int i = 0 ; i < 8 ; i++){\n        int nx = p.x + dx[i];\n        int ny = p.y + dy[i];\n        if(!inField(nx,ny,H,W)){ continue; }\n        if(arr[ny][nx] == -1){ continue; }\n        if(arr[ny][nx] <= cnt[ny][nx]){ continue; }\n        cnt[ny][nx]++;\n        if(arr[ny][nx] <= cnt[ny][nx]){\n          nQ.push(P(nx,ny));\n        }\n      }\n    }\n    Q = nQ;\n    res++;\n  }\n  cout << res << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint a;\nint b;\nchar are[1001][1001];\nint kore[1001][1001];\nint sore[1001][1001];\nint sata[1001][1001];\nint shun[1001][1001];\nint ushi;\nint uma;\n\nint main(){\n\tcin >> a >> b;\n\tfor (int i = 0; i < a; i++){\n\t\tfor (int j = 0; j < b; j++){\n\t\t\tcin >> are[i][j];\n\t\t\tif (are[i][j] != '.'){\n\t\t\t\tkore[i - 1][j - 1]++;\n\t\t\t\tkore[i][j - 1]++;\n\t\t\t\tkore[i + 1][j - 1]++;\n\t\t\t\tkore[i - 1][j]++;\n\t\t\t\tkore[i + 1][j]++;\n\t\t\t\tkore[i - 1][j + 1]++;\n\t\t\t\tkore[i][j + 1]++;\n\t\t\t\tkore[i + 1][j + 1]++;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i < a - 1; i++){\n\t\tfor (int j = 1; j < b - 1; j++){\n\t\t\tsore[i][j] = kore[i][j];\n\t\t\tsata[i][j] = 1;\n\t\t\t//\tcout<<sore[i][j];\n\t\t}\n\t}\n\t//\tfor (int i = 0; i < a; i++){\n\t//\t\tcout<<endl;\n\t//\t\t\tfor (int j = 0; j < b; j++){\n\t//\t\t\t\tcout<<sata[i][j];}}\n\twhile (true){\n\t\tuma = 0;\n\t\tfor (int i = 1; i < a - 1; i++){\n\t\t\tfor (int j = 1; j < b - 1; j++){\n\t\t\t\tif (sata[i][j] == 1){\n\t\t\t\t\t//cout<<are[i][j]<<\" \"<<9-sore[i][j]<<endl;\n\t\t\t\t\tif (are[i][j] != '.' && 9 - sore[i][j] > are[i][j] - 48){\n\t\t\t\t\t\t//cout<<1234<<endl;\n\t\t\t\t\t\tare[i][j] = '.';\n\t\t\t\t\t\tkore[i - 1][j - 1]--;\n\t\t\t\t\t\tkore[i][j - 1]--;\n\t\t\t\t\t\tkore[i + 1][j - 1]--;\n\t\t\t\t\t\tkore[i - 1][j]--;\n\t\t\t\t\t\tkore[i + 1][j]--;\n\t\t\t\t\t\tkore[i - 1][j + 1]--;\n\t\t\t\t\t\tkore[i][j + 1]--;\n\t\t\t\t\t\tkore[i + 1][j + 1]--;\n\t\t\t\t\t\tuma = 1;\n\t\t\t\t\t\tshun[i][j] = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse{shun[i][j] = 0; }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (uma == 1){\n\t\t\tushi++;\n\t\t}\n\t\tif (uma == 0){\n\t\t\tbreak;\n\t\t}\n\t\t//if(ushi>30){\n\t\t//\tcout<<\"popopopopop\"<<endl;\n\t\t//\t\tfor (int i = 0; i < a; i++){\n\t\t//cout<<endl;\n\t\t//\tfor (int j = 0; j < b; j++){\n\t\t//\t\tcout<<sata[i][j];}}\n\t\t//\t}\n\t\tfor (int i = 0; i < a; i++){\n\t\t\tfor (int j = 0; j < b; j++){\n\t\t\t\tsore[i][j] = kore[i][j];\n\t\t\t\tsata[i][j] = 0;\n\t\t\t}\n\t\t\t//cout<<\"po\"<<endl; \n\t\t}\n\t\tfor (int i = 1; i < a-1; i++){\n\t\t\tfor (int j = 1; j < b-1; j++){\n\t\t\t\tif (shun[i][j] == 1){\n\t\t\t\t\tsata[i - 1][j - 1]=1;\n\t\t\t\t\tsata[i][j - 1] = 1;\n\t\t\t\t\tsata[i + 1][j - 1]=1;\n\t\t\t\t\tsata[i - 1][j]=1;\n\t\t\t\t\tsata[i + 1][j]=1;\n\t\t\t\t\tsata[i - 1][j + 1]=1;\n\t\t\t\t\tsata[i][j + 1]=1;\n\t\t\t\t\tsata[i + 1][j + 1]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ushi << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <stdio.h>\n#include <stdlib.h>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <math.h>\n#include <utility>\n#include <set>\n#include <map>\n#define INF 1000000000\n#define rep(i,n) for(int i =0;i<n;i++)\nusing namespace std;\ntypedef long long int ll;\n\n\nint main(){\n    int h,w;\n    cin >>h >> w;\n    vector<int> area(h*w);\n    vector<int> ch(h*w,0);\n    rep(i, h){\n        rep(j, w){\n            char hoge;\n            cin >> hoge;\n            if (hoge == '.') {\n                area[i*w+j]=-1;\n                for (int k=-1; k<2; k++) {\n                    for (int l=-1; l<2; l++) {\n                        if(k==0 and l==0)  continue;\n                        if (i+k>0 and i+k<h-1 and j+l>0 and j+l<w-1) {\n                            ch[(i+k)*w+j+l]++;\n                        }\n                    }\n                }\n            }else{\n                area[i*w+j]=(int)hoge-(int)'0';\n            }\n        }\n    }\n    ll ans = 0;\n    ll flag = 1;\n    while (flag > 0) {\n        vector<int> olda = area;\n        vector<int> oldc = ch;\n        flag = 0;\n        rep(i, h){\n            rep(j, w){\n                if (olda[i*w+j]!=-1 and oldc[i*w+j]>=olda[i*w+j]) {\n                    area[i*w+j]=-1;\n                    for (int k=-1; k<2; k++) {\n                        for (int l=-1; l<2; l++) {\n                            if(k==0 and l==0) continue;\n                            if (i+k>0 and i+k<h-1 and j+l>0 and j+l<w-1) {\n                                ch[(i+k)*w+j+l]++;\n                            }\n                        }\n                    }\n                    flag++;\n                }\n            }\n        }\n        if(flag > 0) ans++;\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint h, w;\nvector<string> v;\nchar t[1001];\nint a[1000][1000];\nint ans;\nint dx[8] = {1, 1, 1, 0, -1, -1, -1, 0};\nint dy[8] = {-1, 0, 1, 1, 1, 0, -1, -1};\n\n\nbool b(){\n/*\t\n\tfor(int i=0; i<h; i++){\n\t\tfor(int j=0; j<w; j++){\n\t\t\tprintf(\"%d\", a[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n*/\t\n\tfor(int i=1; i<w-1; i++){\n\t\tfor(int j=1; j<h-1; j++){\n\t\t\tif(a[j][i] == 1) return true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\tscanf(\"%d %d\", &h, &w);\n\tfor(int i=0; i<h; i++){\n\t\tscanf(\"%s\", t);\n\t\tv.push_back(t);\n\t}\n\n\tfor(int i=1; i<w-1; i++){\n\t\tfor(int j=1; j<h-1; j++){\n\t\t\tif(v[j][i] == '.') continue;\n\t\t\tint c = 0;\n\t\t\tfor(int k=0; k<8; k++){\n\t\t\t\tint nx, ny;\n\t\t\t\tnx = i + dx[k];\n\t\t\t\tny = j + dy[k];\n\t\t\t\tif(v[ny][nx] == '.') c++;\n\t\t\t}\n\t\t\tif(v[j][i] - '0' <= c){\n\t\t\t\ta[j][i] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1; i<w-1; i++){\n\t\tfor(int j=1; j<h-1; j++){\n\t\t\tif(a[j][i] == 1) v[j][i] = '.';\n\t\t}\n\t}\n\n\twhile(b()){\n\t\tans++;\n/*\n\t\tprintf(\"\\n\");\n\t\tfor(int i=0; i<h; i++)\n\t\t\tprintf(\"%s\\n\", v[i].c_str());\n*/\n\t\tint d[1000][1000] = {{}};\n\t\tfor(int i=1; i<w-1; i++){\n\t\t\tfor(int j=1; j<h-1; j++){\n\t\t\t\tif(a[j][i] != 1) continue;\n\t\t\t\tfor(int k=0; k<8; k++){\n\t\t\t\t\tint nx, ny;\n\t\t\t\t\tnx = i + dx[k];\n\t\t\t\t\tny = j + dy[k];\n\t\t\t\t\tif(v[ny][nx] == '.') continue;\n\t\t\t\t\tint c = 0;\n\t\t\t\t\tfor(int l=0; l<8; l++){\n\t\t\t\t\t\tint mx, my;\n\t\t\t\t\t\tmx = nx + dx[l];\n\t\t\t\t\t\tmy = ny + dy[l];\n\t\t\t\t\t\tif(v[my][mx] == '.') c++;\n\t\t\t\t\t}\n\t\t\t\t\tif(v[ny][nx] - '0' <= c) d[ny][nx] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=1; i<w-1; i++){\n\t\t\tfor(int j=1; j<h-1; j++){\n\t\t\t\ta[j][i] = d[j][i];\n\t\t\t\tif(a[j][i] == 1) v[j][i] = '.';\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstring>\n#include<queue>\nusing namespace std;\n\nstring S[2000];\nint x[2000][2000];\nint z[2000][2000];\nqueue<int> Q;\nqueue<int> R;\n\nint main() {\n\tint n, m;\n\tchar T[10] = { '.','1','2','3','4','5','6','7','8','9' };\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> S[i];\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tfor (int k = 0; k < 10; k++) {\n\t\t\t\tif (S[i][j] == T[k]) {\n\t\t\t\t\tx[i][j] = k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint t = 1;\n\tint p = 0;\n\tint sum = 0;\n\tmemset(z, 0, sizeof(z));\n\tt = 0;\n\tsum++;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tif (x[i][j] >= 1) {\n\t\t\t\tp = 0;\n\t\t\t\tfor (int k = -1; k <= 1; k++) {\n\t\t\t\t\tfor (int l = -1; l <= 1; l++) {\n\t\t\t\t\t\tif (x[i + k][j + l] == 0) {\n\t\t\t\t\t\t\tp++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (p >= x[i][j]) {\n\t\t\t\t\tz[i][j] = 1;\n\t\t\t\t\tQ.push(i * 1000 + j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tif (z[i][j] == 1) {\n\t\t\t\tx[i][j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tint c, d;\n\n\twhile (sum==0 || !Q.empty()) {\n\t\tsum++;\n\t\twhile (!Q.empty()) {\n\t\t\tc = Q.front() / 1000;\n\t\t\td = Q.front() % 1000;\n\t\t\tfor (int i = -1; i <= 1; i++) {\n\t\t\t\tfor (int j = -1; j <= 1; j++) {\n\t\t\t\t\tif (x[c + i][d + j] >= 1) {\n\t\t\t\t\t\tp = 0;\n\t\t\t\t\t\tfor (int k = -1; k <= 1; k++) {\n\t\t\t\t\t\t\tfor (int l = -1; l <= 1; l++) {\n\t\t\t\t\t\t\t\tif (x[c + i + k][d + j + l]==0) {\n\t\t\t\t\t\t\t\t\tp++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (p >= x[c + i][d + j] && x[c + i][d + j] != 10) {\n\t\t\t\t\t\t\tx[c + i][d + j] = 10;\n\t\t\t\t\t\t\tR.push((c + i) * 1000 + (d + j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t\twhile (!R.empty()) {\n\t\t\tc = R.front() / 1000;\n\t\t\td = R.front() % 1000;\n\t\t\tx[c][d] = 0;\n\t\t\tQ.push(R.front());\n\t\t\tR.pop();\n\t\t}\n\t}\n\n\tcout << sum-1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <queue>\n\nusing namespace std;\n\nint x, y;\nchar m[1024][1024];\nint map[1024][1024];\nqueue<pair<int, pair<int, int> > > q;\npair<int, pair<int, int> > temp;\n\n\nint dx[8] = { 0, 0, 1, -1, 1, -1, 1, -1 }, dy[8] = { 1, -1, 0, 0, -1, -1, 1, 1 };\n\nvoid check_map() {\n\n\tfor (int i = 0; i < y; i++) {\n\t\tfor (int i1 = 0; i1 < x; i1++) {\n\t\t\tint cnt = 0;\n\t\t\tif (m[i][i1] == '.') {\n\t\t\t\tmap[i][i1] = 0;\n\t\t\t\tq.push(make_pair(0, make_pair(i, i1)));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmap[i][i1] = m[i][i1] - '0';\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint cnt = 0;\n\n\tcin >> y >> x;\n\n\tfor (int i = 0; i < y; i++) {\n\t\tfor (int i1 = 0; i1 < x; i1++) {\n\t\t\tcin >> m[i][i1];\n\t\t}\n\t}\n\n\tcheck_map();\n\t\t\n\twhile (!q.empty()) {\n\n\t\ttemp = q.front();\n\n\t\tq.pop();\n\n\t\tcnt = temp.first;\n\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tif ((map[temp.second.first + dy[i]][temp.second.second + dx[i]] -= 1) == 0)\n\t\t\t\tq.push(make_pair(temp.first + 1, make_pair(temp.second.first + dy[i], temp.second.second + dx[i])));\n\t\t}\n\n\t}\n\n\tcout << cnt << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int, int>P;\ntypedef long long ll;\n\nint h, w;\nchar ca[1000][1001];\nchar cpy[1000][1001];\nint cnt[1000][1000];\nqueue<P>que1;\nqueue<P>que2;\n\nint main(){\n\tscanf(\"%d%d\", &h, &w);\n\trep(i, h){\n\t\tscanf(\"%s\", ca[i]);\n\t\tstrcpy(cpy[i], ca[i]);\n\t}\n\trep(i, h){\n\t\trep(j, w){\n\t\t\tif (ca[i][j] == '.')continue;\n\t\t\tfor (int t = -1; t <= 1; t++)\n\t\t\t\tfor (int k = -1; k <= 1; k++)\n\t\t\t\t\tif (ca[i + t][j + k] == '.')\n\t\t\t\t\t\tcnt[i][j]++;\n\t\t\tif (cpy[i][j] != '.'&&ca[i][j] - '0' <= cnt[i][j]){\n\t\t\t\tcpy[i][j] = '.';\n\t\t\t\tque1.push(P(i, j));\n\t\t\t}\n\t\t}\n\t}\n\tint res = 0;\n\twhile (!que1.empty()){\n\t\tres++;\n\t\trep(i, h)\n\t\t\tstrcpy(ca[i], cpy[i]);\n\t\twhile (!que1.empty()){\n\t\t\tP p = que1.front(); que1.pop();\n\t\t\tint f = p.first, s = p.second;\n\t\t\tfor (int i = -1; i <= 1; i++){\n\t\t\t\tfor (int j = -1; j <= 1; j++){\n\t\t\t\t\tint t = f + i, k = s + j;\n\t\t\t\t\tif (ca[t][k] == '.')continue;\n\t\t\t\t\tcnt[t][k]++;\n\t\t\t\t\tif (cpy[t][k] != '.'&&ca[t][k] - '0' <= cnt[t][k]){\n\t\t\t\t\t\tcpy[t][k] = '.';\n\t\t\t\t\t\tque2.push(P(t, k));\n\t\t\t\t\t}\n\t\t\t \t}\n\t\t\t}\n\t\t}\n\t\tswap(que1, que2);\n\t}\n\tprintf(\"%d\\n\", res );\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nchar str[1100][1100];\nint rem[1100][1100];\nint dx[]={1,1,1,0,0,-1,-1,-1};\nint dy[]={1,0,-1,1,-1,1,0,-1};\nint main(){\n\tint a,b;scanf(\"%d%d\",&a,&b);\n\tfor(int i=0;i<a;i++)scanf(\"%s\",str[i]);\n\tqueue<pair<int,pair<int,int> > >Q;\n\tfor(int i=0;i<a;i++){\n\t\tfor(int j=0;j<b;j++){\n\t\t\tif(str[i][j]=='.'){\n\t\t\t\tQ.push(make_pair(0,make_pair(i,j)));\n\t\t\t\trem[i][j]=-1;\n\t\t\t}else rem[i][j]=str[i][j]-'0';\n\t\t}\n\t}\n\tint ret=0;\n\twhile(Q.size()){\n\t\tint cost=Q.front().first;\n\t\tint row=Q.front().second.first;\n\t\tint col=Q.front().second.second;\n\t\tQ.pop();\n\t\tret=max(ret,cost);\n\t\tfor(int i=0;i<8;i++){\n\t\t\tint tr=row+dx[i];\n\t\t\tint tc=col+dy[i];\n\t\t\tif(tr<0||tc<0||tr>=a||tc>=b||rem[tr][tc]<=0)continue;\n\t\t\trem[tr][tc]--;\n\t\t\tif(rem[tr][tc]==0){\n\t\t\t\tQ.push(make_pair(cost+1,make_pair(tr,tc)));\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "/* {{{ Shinobu kawaii */\n/*\n  ______   __        _                  __                 \n.' ____ \\ [  |      (_)                [  |                \n| (___ \\_| | |--.   __   _ .--.   .--.  | |.--.   __   _   \n _.____`.  | .-. | [  | [ `.-. |/ .'`\\ \\| '/'`\\ \\[  | | |  \n| \\____) | | | | |  | |  | | | || \\__. ||  \\__/ | | \\_/ |, \n \\______.'[___]|__][___][___||__]'.__.'[__;.__.'  '.__.'_/ \n\n*/\n// clang-format off\n/* }}} */\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n// #define int long long\nstruct Fast {Fast(){std::cin.tie(0);ios::sync_with_stdio(false);}} fast;\n\n/* cpp template {{{ */\n\n/* short */\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define Fi first\n#define Se second\n#define ALL(v) (v).begin(), (v).end()\n#define X real()\n#define Y imag()\n\n/* REPmacro */\n#define REPS(i, a, n) for (int i = (a); i < (n); ++i)\n#define REP(i, n) REPS(i, 0, n)\n#define RREP(i, n) REPS(i, 1, n + 1)\n#define DEPS(i, a, n) for (int i = (a); i >= n; --i)\n#define DEP(i, n) DEPS(i, n, 0)\n\n/* debug */\n#define debug(x) cerr << x << \" \" << \"(L:\" << __LINE__ << \")\" << '\\n';\n\n/* alias */\nusing ll = long long;\nusing ull = unsigned long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nusing pii = pair<int, int>;\nusing D = double;\nusing P = complex<D>;\ntemplate <typename T> using PQ = priority_queue<T>;\ntemplate <typename T> using minPQ = priority_queue<T, vector<T>, greater<T>>;\n\n/* const */\nconst int INF = 1001001001;\nconst ll LINF = 1001001001001001001ll;\nconst int MOD = 1e9 + 7;\nconst D EPS = 1e-9;\nconst int dx[] = {0, 1, 0, -1, 1, -1, 1, -1}, dy[] = {1, 0, -1, 0, 1, -1, -1, 1};\n\n/* func */\ninline bool inside(int y, int x, int H, int W) {return y >= 0 && x >= 0 && y < H && x < W;}\ninline int in() {int x; cin >> x; return x;}\ntemplate <typename T> inline void print(const T& x) {cout << x << '\\n';}\ntemplate <typename T, typename S> inline void print(const pair<T, S>& p) {cout << p.first << \" \" << p.second << '\\n';}\ntemplate <typename T, typename S> inline void print(const vector<pair<T, S>>& v) {\n  REP(i, v.size()) print(v[i]);\n}\ntemplate <typename T> inline void print(const vector<T>& v, string s = \" \") {\n  REP(i, v.size()) {\n    if (i != 0) cout << s;\n    cout << v[i];\n  }\n  cout << '\\n';\n}\n// clang-format on\n/* }}} */\n\nchar field[1010][1010];\nint cnt[1010][1010];\n\nsigned main() {\n  int h = in(), w = in();\n  REP(i, h) cin >> field[i];\n  queue<pii> q;\n  \n  REP(i, h) REP(j, w) {\n    if (field[i][j] == '.') continue;\n    REP(k, 8) {\n      int ny = i + dy[k], nx = j + dx[k];\n      if (!inside(ny, nx, h, w)) continue;\n      if (field[ny][nx] != '.') continue;\n      cnt[i][j]++;\n    }\n    if (cnt[i][j] >= field[i][j] - '0') {\n      q.emplace(i, j);\n    }\n  }\n  if (q.empty()) {\n    print(0);\n    return 0;\n  }\n  int ans = 1;\n  while (q.size()) {\n    //debug(q.size());\n    queue<pii> qq;\n    while (q.size()) {\n      pii t = q.front(); q.pop();\n      REP(i, 8) {\n        int ny = t.first + dy[i], nx = t.second + dx[i];\n        if (!inside(ny, nx, h, w)) continue;\n        if (field[ny][nx] == '.') continue;\n        cnt[ny][nx]++;\n        if (cnt[ny][nx] == field[ny][nx] - '0') {\n          qq.emplace(ny, nx);\n        }\n      }\n    }\n    if (qq.size()) ans++;\n    q = qq;\n  }\n  print(ans);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<bits//stdc++.h>\n#include<functional>\nusing namespace std;\nstruct P{\n\tint x,y;\n};\nint main() {\n\tint a[500][500];\n\tint h,w;\n\tcin>>h>>w;\n\tfor(int i=0;i<h;i++){\n\t\tstring s;\n\t\tcin>>s;\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(s[j]=='.') a[i][j]=0;\n\t\t\telse a[i][j]=(int)s[j]-'0';\n\t\t}\n\t}\n\tint sum=0,sum2=1;\n\twhile(sum2){\n\t\tsum2=0;\n\t\tint sum3;\n\t\tvector<P>p;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(a[i][j]){\n\t\t\t\t\tsum3=0;\n\t\t\t\t\tfor(int x=-1;x<=1;x++){\n\t\t\t\t\t\tfor(int y=-1;y<=1;y++){\n\t\t\t\t\t\t\tif(i+x<h&&i+x>=0&&j+y<w&&j+y>=0&&a[i+x][j+y]==0) sum3++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(sum3>=a[i][j]) {\n\t\t\t\t\t\tp.push_back(P{i,j});\n\t\t\t\t\t\tsum2++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<(int)p.size();i++){\n\t\t\ta[p[i].x][p[i].y]=0;\n\t\t}\n\t\tsum++;\n\t}\n\tcout<<--sum<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nstruct MAP {\n\tint a[1024][1024];\n};\n\nMAP map,update;\nint y_move[] = { -1, -1, -1, 0, 0, +1, +1, +1 }, x_move[] = { -1, 0, +1, -1, +1, -1, 0, +1 };\nint main() {\n\tint h, w;\n\tcin >> h >> w;\n\n\tfor (int i = 1; i <= h; ++i) {\n\t\tfor (int i2 = 1; i2 <= w; ++i2) {\n\t\t\tchar str;\n\t\t\tcin >> str;\n\t\t\tif (str == '.')map.a[i][i2] = 0;\n\t\t\telse map.a[i][i2] = str - '0';\n\t\t}\n\t}\n\tupdate = map;\n\n\tfor (int count = 0;; ++count) {\n\t\tmap = update;\n\t\tbool flg = false;\n\t\tfor (int i = 1; i <= h; i++) {\n\t\t\tfor (int i2 = 1; i2 <= w; i2++) {\n\t\t\t\tif (map.a[i][i2] > 0) {\n\t\t\t\t\tint cnt = 0;\n\t\t\t\t\tfor (int k = 0; k < 8; k++) {\n\t\t\t\t\t\tif (map.a[i + y_move[k]][i2 + x_move[k]] == 0) { cnt++; }\n\t\t\t\t\t}\n\t\t\t\t\tif (map.a[i][i2] <= cnt) {\n\t\t\t\t\t\tupdate.a[i][i2] = 0;\n\t\t\t\t\t\tflg = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!flg) { cout << count << endl; break; }\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <queue>\nusing namespace std;\ntypedef pair<int, int> P;\n \nint h, w, ans;\nint castle[1001][1001], times[1001][1001];\nint dx[] = {-1, 0, 1, -1, 1, -1, 0, 1}, dy[] = {-1, -1, -1, 0, 0, 1, 1, 1};\nchar beach[1001][1001];\n \nint main(){\n    scanf(\"%d%d\", &h, &w);\n    for(int i = 0; i < h; i++){\n        scanf(\"%s\", &beach[i]);\n    }\n \n    queue<P> Q;\n    for(int i = 0; i < h; i++){\n        for(int j = 0; j < w; j++){\n            if(beach[i][j] == '.'){\n                Q.push(P(i, j));\n            } else{\n                castle[i][j] = beach[i][j] - '0';\n            }\n        }\n    }\n \n    while(Q.size()){\n        P p = Q.front();\n        Q.pop();\n        ans = max(ans, times[p.first][p.second]);\n \n        for(int i = 0; i < 8; i++){\n            int y = p.first + dy[i], x = p.second + dx[i];\n            if(y < 0 || y >= h || x < 0 || x >= w){\n                continue;\n            }\n \n            castle[y][x]--;\n            if(castle[y][x] == 0){\n                Q.push(P(y, x));\n                times[y][x] = times[p.first][p.second] + 1;\n            }\n        }\n    }\n \n    printf(\"%d\\n\", ans);\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstring>\nusing namespace std;\n\n#define MAX 1001\n\nint main(){\n\tstring S;\n\tint n,m,t,sum,a;\n\tsum=0;\n\tshort x[MAX][MAX];\n\tbool y[MAX][MAX];\n\tshort z[MAX][MAX];\n\tshort v[MAX][MAX];\n\tmemset(x,0,sizeof(x));\n\tmemset(z,0,sizeof(z));\n\tchar T[10]={'.','1','2','3','4','5','6','7','8','9'};\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>S;\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tfor(int k=0;k<10;k++){\n\t\t\t\tif(S[j-1]==T[k]){\n\t\t\t\t\tx[i][j]=k;\n\t\t\t\t\tif(k==0){\n\t\t\t\t\t\tfor(int l=-1;l<=1;l++){\n\t\t\t\t\t\t\tfor(int o=-1;o<=1;o++){\n\t\t\t\t\t\t\t\tz[i+l][j+o] += 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\twhile(true){\n\t\tt=0;\n\t\tsum++;\n\t\tmemset(v,0,sizeof(v));\n\t\tmemset(y,false,sizeof(y));\n\t\tfor(int i=2;i<n;i++){\n\t\t\tfor(int j=2;j<m;j++){\n\t\t\t\tif(x[i][j]>=1 && z[i][j]>=x[i][j]){\n\t\t\t\t\ta=0;\n\t\t\t\t\ty[i][j]=true;\n\t\t\t\t\tt++;\n\t\t\t\t\tfor(int l=-1;l<=1;l++){\n\t\t\t\t\t\tfor(int o=-1;o<=1;o++){\n\t\t\t\t\t\t\tv[i+l][j+o]+= 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(t==0){\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i=2;i<n;i++){\n\t\t\tfor(int j=2;j<m;j++){\n\t\t\t\tif(y[i][j]==true){\n\t\t\t\t\tx[i][j]=0;\n\t\t\t\t}\n\t\t\t\tz[i][j] += v[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tcout<<sum-1<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n\nint main(void){\n  int h, w, i, j, k, l, m, count;\n  bool flag;\n  int com[3] = {-1, 0, 1};\n  char c;\n  int map[1000][1000];\n\n  // map?\n  for(i = 0; i < 1000; i++){\n    for(j = 0; j < 1000; j++){\n      map[i][j] = (i == 0) ? 0 : -1;\n    }\n  }\n\n  scanf(\"%d%d\", &h, &w);\n  for(i = 0; i < h; i++){\n    getchar();\n    for(j = 0; j < w; j++){\n      scanf(\"%c\", &c);\n      //printf(\"%c\", c);\n      if(c == '.'){ map[i][j] = 0; }\n      else{ map[i][j] = c - '0'; }\n    }\n    //printf(\"\\n\");\n  }\n\n  // 1?????\n  for(m = 1;; m++){\n    flag = false;\n    // ?????????\n    for(i = 1; i < h-1; i++){\n      for(j = 1; j < w-1; j++){\n\t// 8???\n\tif(map[i][j] <= 0) continue;\n\tcount = map[i][j];\n\tfor(k = 0; k < 3; k++){\n\t  for(l = 0; l < 3; l++){\n\t    // ??????\n\t    // ????\n\t    if(map[i+com[k]][j+com[l]] <= 0 && map[i+com[k]][j+com[l]] != -m){ count--; }\n\t  }  \n\t}\n\n\t// ?????????\n\tif(count <= 0){\n\t  map[i][j] = -m;\n\t  flag = true;\n\t}\n      }\n    }\n    /*\n    for(i = 0; i < h; i++){\n      for(j = 0; j < w; j++){\n\tprintf(\"%-3d\", map[i][j]);\n      }\n      printf(\"\\n\");\n    }\n    */\n\n    // ?????reak\n    if(!flag) break;\n  }\n\n  printf(\"%d\\n\", m-1);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nstruct State {\n  int i, j, t;\n};\n\nconst int INF = 1<<28;\nconst int MAXN = 1001;\nint H, W;\nchar C[MAXN][MAXN];\nint G[MAXN][MAXN];\n\nint main() {\n  while(cin >> H >> W) {\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n        cin >> C[i][j];\n      }\n    }\n    memset(G, 0, sizeof(G));\n    queue<State> que;\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n        if(!isdigit(C[i][j])) {\n          G[i][j] = INF;\n          continue;\n        }\n        for(int di = -1; di <= 1; ++di) {\n          for(int dj = -1; dj <= 1; ++dj) {\n            if(di == 0 && dj == 0) continue;\n            int ni = i + di;\n            int nj = j + dj;\n            if(C[ni][nj] == '.') ++G[i][j];\n          }\n        }\n        if(G[i][j] >= C[i][j]-'0') {\n          que.push((State){i, j, 1});\n        }\n      }\n    }\n    int res = 0;\n    while(que.size()) {\n      const State s = que.front();\n      que.pop();\n      res = s.t;\n      for(int di = -1; di <= 1; ++di) {\n        for(int dj = -1; dj <= 1; ++dj) {\n          if(di == 0 && dj == 0) continue;\n          int ni = s.i + di;\n          int nj = s.j + dj;\n          if(G[ni][nj] >= C[ni][nj]-'0') continue;\n          if(++G[ni][nj] >= C[ni][nj]-'0') {\n            que.push((State){ni, nj, s.t + 1});\n          }\n        }\n      }\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define chmin(a, b) ((a)=min((a), (b)))\n#define chmax(a, b) ((a)=max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n \nconst ll MOD=1e9+7;\nconst ll INF=1e18;\n \nint dx[]={1,0,-1,-1,-1,0,1,1};\nint dy[]={1,1,1,0,-1,-1,-1,0};\n\nint sum[1010][1010];\nint m[1010][1010];\n\nint main(){\n    int h,w;\n\n    cin >> h >> w;\n    for(int i = 0;i < h;i++){\n        char tmp[1010];\n        cin >> tmp;\n        for(int j = 0;j < w;j++){\n            if(tmp[j] == '.'){\n                m[i][j] = 0;\n                sum[i][j] = 0;\n            }else{\n                m[i][j] = tmp[j] - '0';\n                sum[i][j] = -1;\n            }\n        }\n    }\n    queue<P> que;\n    int ans = 0;\n    for(int i = 0;i < h;i++){\n        for(int j = 0;j < w;j++){\n            if(sum[i][j] == -1){\n                int s = 0;\n                for(int k = 0;k < 8;k++){\n                    if(sum[i+dx[k]][j+dy[k]] == 0) s++;\n                }\n                if(s >= m[i][j]){\n                    que.push(P(i,j));\n                    sum[i][j] = 1;\n                    ans = 1;\n                }\n            }\n        }\n    }\n    while(!que.empty()){\n        P q = que.front(); que.pop();\n        int x = q.fs,y = q.sc;\n        for(int k = 0;k < 8;k++){\n            if(sum[x+dx[k]][y+dy[k]] == -1){\n                int smax = 0;\n                int count = 0;\n                int nx = x + dx[k],ny = y + dy[k];\n                vector<int> v;\n                for(int l = 0;l < 8;l++){\n                    if(sum[nx+dx[l]][ny+dy[l]] == -1)continue;\n               //     smax = max(smax,sum[nx+dx[k]][ny+dy[k]]);\n                    v.push_back(sum[nx+dx[l]][ny+dy[l]]);\n                    count++;\n                }\n                if(count >= m[x+dx[k]][y+dy[k]]){\n                    int th = m[x+dx[k]][y+dy[k]];\n                    sort(v.begin(),v.end());\n\n                    ans = max(ans,v[th-1]+1);\n                    sum[x+dx[k]][y+dy[k]] = v[th-1]+1;\n                    que.push(P(x+dx[k],y+dy[k]));\n                }\n            }\n        }\n    }\n    cout << ans << endl;\n\n\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint main(){\n\tint H=3,W=3,a;\n\tchar hoge;\n\tcin>>H>>W;\n\tint check[1001][1001],map[1001][1001];\n\tvector<int> temp[1001];\n\t\n\tfor(int i=0;i<H;i++){\n\t\tfor(int j=0;j<W;j++){\n\t\t\tcin>>hoge;\n\t\t\tif(hoge=='.'){\n\t\t\t\tmap[i][j]=0;\n\t\t\t}else{\n\t\t\t\ta=hoge-'0';\n\t\t\t\tmap[i][j]=a;\n\t\t\t}\n\t\t\ttemp[i].push_back(0);\n\t\t\tcheck[i][j]=0;\n\t\t}\n\t}\n\tint cnt=0;\n\tfor(int i=1;i<H-1;i++){\n\t\tfor(int j=1;j<W-1;j++){\n\t\t\tcnt=0;\n\t\t\tif(map[i-1][j-1]==0)cnt++;\n\t\t\tif(map[i][j-1]==0)cnt++;\n\t\t\tif(map[i+1][j-1]==0)cnt++;\n\t\t\tif(map[i-1][j]==0)cnt++;\n\t\t\tif(map[i+1][j]==0)cnt++;\n\t\t\tif(map[i-1][j+1]==0)cnt++;\n\t\t\tif(map[i][j+1]==0)cnt++;\n\t\t\tif(map[i+1][j+1]==0)cnt++;\n\t\t\tcheck[i][j]=cnt;\n\t\t\ttemp[i][j]=cnt;\n\t\t}\n\t}\n\t\n\t/*for(int i=0;i<H;i++){\n\t\tfor(int j=0;j<W;j++){\n\t\t\tcout<<check2[i][j];\n\t\t}\n\t\tcout<<endl;\n\t}*/\n\tint ans=0;\n\tbool flag=true;\n\twhile(flag==true){\n\t\t/*for(int i=0;i<H;i++){\n\t\tfor(int j=0;j<W;j++){\n\t\t\tcout<<map[i][j];\n\t\t}\n\t\tcout<<endl;\n\t\t}*/\n\t\tflag=false;\n\t\tfor(int i=1;i<H-1;i++){\n\t\t\tfor(int j=1;j<W-1;j++){\n\t\t\t\tif(map[i][j]<=check[i][j]&&map[i][j]!=0){\n\t\t\t\t\tflag=true;\n\t\t\t\t\tmap[i][j]=0;\n\t\t\t\t\tif(map[i][j-1]>0)temp[i][j-1]++;\n\t\t\t\t\ttemp[i][j]=0;\n\t\t\t\t\tif(map[i][j+1]>0)temp[i][j+1]++;\n\t\t\t\t\tif(map[i+1][j-1]>0)temp[i+1][j-1]++;\n\t\t\t\t\tif(map[i+1][j]>0)temp[i+1][j]++;\n\t\t\t\t\tif(map[i+1][j+1]>0)temp[i+1][j+1]++;\n\t\t\t\t\tif(map[i-1][j-1]>0)temp[i-1][j-1]++;\n\t\t\t\t\tif(map[i-1][j]>0)temp[i-1][j]++;\n\t\t\t\t\tif(map[i-1][j+1]>0)temp[i-1][j+1]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!flag){break;\n\t\t}else{\n\t\t\tans++;\n\t\t\t\tfor(int i=1;i<H-1;i++){\n\t\t\t\t\tfor(int j=1;j<W-1;j++){\n\t\t\t\t\t\tcheck[i][j]=temp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <queue>\nusing namespace std;\n\nconst int MAX_SIZE = 1000;\ntypedef pair<int, int> P;\ntypedef pair<int, P> Q;\n\nint calc(int f[][MAX_SIZE], queue<Q> q, int H, int W) {\n  P d[] = {P(-1, -1), P(-1, 0), P(-1, 1), P(0, -1), P(0, 1), P(1, -1), P(1, 0), P(1, 1)};\n  int n = 0;\n  while (q.size()) {\n    int c = q.front().first;\n    P p = q.front().second;\n    q.pop();\n    if (c > n) n++;\n    for (int k = 0; k < 8; ++k) {\n      int i = p.first  + d[k].first;\n      int j = p.second + d[k].second;\n      if (i >= 0 && i < H && j >= 0 && j < W && --f[i][j] == 0) {\n        q.push(Q(c + 1, P(i, j)));\n      };\n    }\n  }\n  return n;\n}\n\nint main() {\n  int H, W;\n  int f[MAX_SIZE][MAX_SIZE];\n  queue<Q> q;\n\n  cin >> H >> W;\n  for (int i = 0; i < H; ++i) {\n    string str;\n    cin >> str;\n    for (int j = 0; j < W; ++j) {\n      if (str[j] == '.') {\n        f[i][j] = 0;\n        q.push(Q(0, P(i, j)));\n      } else {\n        f[i][j] = str[j] - '0';\n      }\n    }\n  }\n  cout << calc(f, q, H, W) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int>P;\n\nchar sand[1005][1005];\nint sara[1005][1005]={};\n\nint main(){\n\tint h,w;\n\tcin>>h>>w;\n\t\tqueue<P>now;\n\t\tqueue<P>next;\n\t\t\n\tfor(int i=0;i<h;i++)\n\tfor(int j=0;j<w;j++)cin>>sand[i][j];\n\t\n\tfor(int i=1;i<h-1;i++){\n\t\tfor(int j=1;j<w-1;j++){\n\t\t\tif(sand[i][j]!='.'){\n\t\t\t\tfor(int k=-1;k<=1;k++){\n\t\t\t\t\tfor(int l=-1;l<=1;l++){\n\t\t\t\t\t\tif(sand[i+k][j+l]=='.')sara[i][j]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=1;i<h-1;i++){\n\t\t\tfor(int j=1;j<w-1;j++){\n\t\t\t\tif(sand[i][j]!='.'){\n\t\t\t\t\tint a=sand[i][j]-'0';\n\t\t\t\t\tif(a<=sara[i][j])now.push(make_pair(i,j));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint ans=0;\n\t\t\t\n\t\twhile(now.size()){\n\t\t\tans++;\n\t\t\t\n\t\t\tfor(int i=0;i<now.size();i++){\n\t\t\t\tP p=now.front();\n\t\t\t\tnow.pop();\n\t\t\t\t\t\n\t\t\t\tfor(int j=-1;j<=1;j++){\n\t\t\t\t\tfor(int k=-1;k<=1;k++){\n\t\t\t\t\t\t\n\t\t\t\tif(sand[p.first+j][p.second+k]!='.'){\n\t\t\t\t\tint a=sand[p.first+j][p.first+k]-'0';\n\t\t\t\t\tnext.push(make_pair(p.first+j,p.first+k));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\t\n\t\t\t\tint b=sand[p.first][p.second]-'0';\n\t\t\t\t\n\t\t\t\tif(sara[p.first][p.second]>=b){\n\t\t\t\tfor(int j=-1;j<=1;j++){\n\t\t\t\t\tfor(int k=-1;k<=1;k++){\n\t\t\t\t\tif(sara[p.first+j][p.second+k]!=0)sara[p.first+j][p.second+k]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tsara[p.first][p.second]=0;\n\t\t\t\tsand[p.first][p.second]='.';\n\t\t\t\t}\n\t\t}\n\n\t\t\twhile(next.size()){\n\t\t\t\tnow.push(next.front());\n\t\t\t\tnext.pop();\n\t\t\t\t}\n\t\t}\t\n\t\tcout<<ans<<endl;\n\t\treturn 0;\n\t}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <time.h>\n#include <math.h>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <iterator>\n#include <sstream>\n#include <string>\n#include <bitset>\nusing namespace std;\n#define FOR(I,F,N) for(int I = F; I < (int)(N); I++)\n#define rep(i, n) FOR(i, 0, n)\n#define FIN(V) cout<<V<<endl\n#define pb push_back\n#define INF (1 << 28)\n\ntemplate<typename T>\nvoid remove(vector<T>& vector, unsigned int index){\nvector.erase(vector.begin() + index);\n}\n\ntypedef pair<int, int> P;\ntypedef long long ll;\ntypedef priority_queue<int> pq;\nint StrToInt(string);\nstring IntToStr(int);\nint dx[8] = {-1, 0, 1, 1, 1, 0, -1, -1};\nint dy[8] = {1, 1, 1, 0, -1, -1, -1, 0};\n\nint w, h, ans = 0;\nint state[51][51];\nvoid show(){\n\trep(i,h){\n\t\trep(j,w){\n\t\t\tif(state[j][i] == 0)cout << '.';\n\t\t\telse cout << state[j][i];\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nint main(void){\n\tcin >> h >> w;\n\tfill_n(*state, 51*51, -1);\n\trep(i,h)rep(j,w){\n\t\tchar c;\n\t\tcin >> c;\n\t\tif(c == '.')state[j][i] = 0;\n\t\telse state[j][i] = c-'0';\n\t}\n\tqueue<P> que;\n\trep(i,h)rep(j,w){\n\t\tif(state[j][i] == 0)continue;\n\t\tint count = 0;\n\t\trep(k,8){\n\t\t\tint nx = j+dx[k];\n\t\t\tint ny = i+dy[k];\n\t\t\tif(nx < 0 || ny < 0 || state[nx][ny] == -1)continue;\n\t\t\tif(state[nx][ny] == 0)count++;\n\t\t}\n\t\tif(state[j][i] <= count){\n\t\t\tque.push(P(j, i));\n\t\t}\n\t}\n\t///show();\n\twhile(!que.empty()){\n\t\tqueue<P> reQue;\n\t\twhile(!que.empty()){\n\t\t\treQue.push(que.front());\n\t\t\t///cout << \"(\" << que.front().first << \",\" << que.front().second << \")\" << endl;\n\t\t\tstate[que.front().first][que.front().second] = 0;\n\t\t\tque.pop();\n\t\t}\n\t\twhile(!reQue.empty()){\n\t\t\tP p = reQue.front();\n\t\t\treQue.pop();\n\t\t\tint x = p.first;\n\t\t\tint y = p.second;\n\t\t\t///cout << \"(\" << x << \",\" << y << \")\" << endl;\n\t\t\trep(k,8){\n\t\t\t\tint nx = x+dx[k];\n\t\t\t\tint ny = y+dy[k];\n\t\t\t\tif(nx < 0 || ny < 0 || state[nx][ny] == -1)continue;\n\t\t\t\tif(state[nx][ny] == 0)continue;\n\t\t\t\tint count = 0;\n\t\t\t\trep(l,8){\n\t\t\t\t\tint nnx = nx+dx[l];\n\t\t\t\t\tint nny = ny+dy[l];\n\t\t\t\t\tif(nnx < 0 || nny < 0 || state[nnx][nny] == -1)continue;\n\t\t\t\t\tif(state[nnx][nny] == 0)count++;\n\t\t\t\t}\n\t\t\t\tif(state[nx][ny] <= count)que.push(P(nx, ny));\n\t\t\t}\n\t\t}\n\t\t///show();\n\t\tans++;\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}\n\n\n\nint StrToInt(string s){\n\tstringstream ss;\n\tss << s;\n\tint val;\n\tss >> val;\n\treturn val;\n}\nstring IntToStr(int i){\n\tstringstream ss;\n\tss << i;\n\treturn ss.str();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint H, W;\nint field[1010][1010];\nint ctr[1010][1010];\n\nint count_emp(int x, int y) {\n  int c = 0;\n  for (int xs=-1; xs<=1; xs++) {\n    for (int ys=-1; ys<=1; ys++) {\n      if (xs == 0 && ys == 0) continue;\n      if (field[x+xs][y+ys] == 0) c++;\n    }\n  }\n  return c;\n}\nvoid re_count(int x, int y) {\n  field[x][y] = 0;\n  for (int xs=-1; xs<=1; xs++) {\n    for (int ys=-1; ys<=1; ys++) {\n      if (xs == 0 && ys == 0) continue;\n      ctr[x+xs][y+ys]++;\n    }\n  }\n}\n\n\nint main() {\n  cin >> H >> W;\n  for (int y=0; y<H; y++) {\n    for (int x=0; x<W; x++) {\n      char c;\n      cin >> c;\n      int t = 0;\n      if (c != '.') t = (int)c - (int)'0';\n      field[x][y] = t;\n    }\n  }\n\n  // count all\n  vector<P> updates;\n  for (int x=1; x<W-1; x++) {\n    for (int y=1; y<H-1; y++) {\n      ctr[x][y] = count_emp(x, y);\n      int t = field[x][y];\n      if (t > 0 && ctr[x][y] >= t) {\n        updates.push_back(P(x, y));\n      }\n    }\n  }\n\n  int ans = 0;\n  if (!updates.empty()) {\n    // O(N^2 log(N))\n    while (true) {\n      ans++;\n      for (auto p : updates) {\n        re_count(p.first, p.second);\n      }\n      vector<P> tmp;\n      for (auto p : updates) {\n        for (int xs=-1; xs<=1; xs++) {\n          for (int ys=-1; ys<=1; ys++) {\n            if (xs == 0 && ys == 0) continue;\n            int x = p.first + xs, y = p.second + ys;\n            int t = field[x][y];\n            if (t > 0 && ctr[x][y] >= t) {\n              if (find(tmp.begin(), tmp.end(), P(x, y)) == tmp.end())\n                tmp.push_back(P(x, y));\n            }\n          }\n        }\n      }\n      updates.clear();\n      for (auto p : tmp) updates.push_back(p);\n      if (updates.empty()) break;\n    }\n  }\n  cout << ans << \"\\n\";\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long int;\nusing P = pair<int, int>;\nusing P3 = pair<int,P>;\nusing PP = pair<P, P>;\nconstexpr ll INF = 1LL<<60;\n\nint main(){\n    int h, w;\n    cin >> h >> w;\n    vector<string> s(h);\n    vector<vector<bool> > used(h, vector<bool>(w));\n    vector<vector<int> > cnt(h, vector<int>(w));\n    for(int i=0;i<h;i++){\n        cin >> s[i];\n    }\n    queue<P> que[2];\n    for(int i=1;i<h-1;i++){\n        for(int j=1;j<w-1;j++){\n            if(s[i][j] == '.') continue;\n            for(int di=-1;di<=1;di++)for(int dj=-1;dj<=1;dj++){\n                int ni = i+di, nj = j+dj;\n                if(s[ni][nj] == '.') cnt[i][j]++;\n            }\n            if(cnt[i][j] >= s[i][j]-'0'){\n                que[0].push(P(i,j));\n            }\n        }\n    }\n    bool update = true;\n    int t = 0;\n    while(update){\n        update = false;\n        while(!que[0].empty()){\n            auto p = que[0].front();\n            que[0].pop();\n            int i = p.first, j = p.second;\n            if(s[i][j] == '.') continue;\n            if(used[i][j]) continue;\n            if(cnt[i][j] >= s[i][j]-'0'){\n                que[1].push(P(i,j));\n                used[i][j] = true;\n                update = true;\n            }\n        }\n        while(!que[1].empty()){\n            auto p = que[1].front();\n            que[1].pop();\n            int i = p.first, j = p.second;\n            s[i][j] = '.';\n            for(int di=-1;di<=1;di++)for(int dj=-1;dj<=1;dj++){\n                int ni = i+di, nj = j+dj;\n                if(s[ni][nj] == '.') continue;\n                if(used[ni][nj]) continue;\n                cnt[ni][nj]++;\n                if(cnt[ni][nj] >= s[ni][nj]-'0') que[0].push(P(ni,nj));\n            }\n        }\n        if(update) t++;\n    }\n    cout << t << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define f first\n#define s second\n#define mk make_pair\nusing namespace std;\ntypedef pair<int,int> P;\nint h,w,ans=0;\nint dx[]={-1,-1,-1,0,0,1,1,1};\nint dy[]={1,0,-1,1,-1,1,0,-1};\nstring s[1001];\nbool used[1001][1001];\nmain(){\n\tcin>>h>>w;\n\tr(i,h)cin>>s[i];\n\tqueue<pair<pair<int,int>,int>>q;\n\tr(i,h)r(j,w)if(isdigit(s[i][j])){\n\t\tint sum=0;\n\t\tr(k,8){\n\t\t\tint y=i+dy[k];\n\t\t\tint x=j+dx[k];\n\t\t\tif(y<0||x<0||x>=w||y>=h)continue;\n\t\t\tif(s[y][x]=='.')sum++;\n\t\t}\n\t\tif(s[i][j]-'0'<=sum){\n\t\t\tused[i][j]=1;\n\t\t\tq.push(mk(mk(i,j),1));\n\t\t}\n\t}\n\twhile(!q.empty()){\n\t\tvector<P>v;\n\t\twhile(!q.empty()){\n\t\t\tpair<pair<int,int>,int>p=q.front();q.pop();\n\t\t\tans=p.s;\n\t\t\ts[p.f.f][p.f.s]='.';\n\t\t\tv.push_back(P(p.f.f,p.f.s));\n\t\t}\n\t\tr(i,v.size())r(j,8){\n\t\t\tint y=v[i].f+dy[j];\n\t\t\tint x=v[i].s+dx[j];\n\t\t\tif(0<=y&&y<h&&0<=x&&x<w&&isdigit(s[y][x])){\n\t\t\t\tint sum=0;\n\t\t\t\tr(k,8){\n\t\t\t\t  int yy=y+dy[k];\n\t\t\t      int xx=x+dx[k];\n\t\t\t      if(yy<0||xx<0||xx>=w||yy>=h)continue;\n\t\t\t      if(s[yy][xx]=='.')sum++;\n\t\t\t    }\n\t\t\t    if(s[y][x]-'0'<=sum&&!used[y][x]){\n\t\t\t    \tused[y][x]=1;\n\t\t\t    \tq.push(mk(mk(y,x),ans+1));\n\t\t\t    }\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint W, H, m[1000][1000];\nint dx[] = {-1, 0, 1, 1, 1, 0, -1, -1}, dy[] = {1, 1, 1, 0, -1, -1, -1, 0};\n\n\nint main()\n{\n  cin >> H >> W;\n  queue<int> up1, up2, bks;\n  for(int y = 0; y < H; y++)\n  {\n    for(int x = 0; x < W; x++)\n    {\n      char c;\n      cin >> c;\n      if(c == '.')\n      {\n        m[y][x] = -1;\n      }\n      else\n      {\n        m[y][x] = c - '0';\n        up1.push(x);\n        up1.push(y);\n      }\n    }\n  }\n  int ans = 0;\n  while(!(up1.empty() && up2.empty()))\n  {\n    ans += 1;\n    queue<int> *upp1, *upp2;\n    if(up1.empty())\n    {\n      upp2 = &up1;\n      upp1 = &up2;\n    }\n    else\n    {\n      upp1 = &up1;\n      upp2 = &up2;\n    }\n    while(!upp1->empty())\n    {\n      int x = upp1->front(); upp1->pop();\n      int y = upp1->front(); upp1->pop();\n      if(m[y][x] == -1)\n        continue;\n      int c = 0;\n      for(int i = 0; i < 8; i++)\n      {\n        int tx = x + dx[i], ty = y + dy[i];\n        if(m[ty][tx] == -1)\n          c++;\n      }\n      if(c < m[y][x])\n        continue;\n      bks.push(x);\n      bks.push(y);\n      for(int i = 0; i < 8; i++)\n      {\n        int tx = x + dx[i], ty = y + dy[i];\n        if(m[ty][tx] != -1)\n        {\n          upp2->push(tx);\n          upp2->push(ty);\n        }\n      }\n    }\n    while(!bks.empty())\n    {\n      int x = bks.front(); bks.pop();\n      int y = bks.front(); bks.pop();\n      m[y][x] = -1;\n    }\n  }\n  cout << ans - 1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"queue\"\n#include \"utility\"\n#include \"math.h\"\n\nusing namespace std;\nint H, W;\nchar status[1002][1002];\nint field[1002][1002];\npair<int, int> dir[8] = {make_pair(0,1),make_pair(1,1),make_pair(1,0),make_pair(1,-1),make_pair(0,-1),make_pair(-1,-1),make_pair(-1,0),make_pair(-1,1)};\nqueue<pair<int,int> > Q;\nqueue<pair<int, int> >del;\nint ans = 0;\nint box = 0;\nint num = 0;\nint x, y;\n\nint main() {\n\tcin >> H >>W;\n\tfor (int i = 1; i <= H; i++) {\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tcin >> status[i][j];\n\t\t\tif (status[i][j] == '.') {\n\t\t\t\tfield[i][j] = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfield[i][j] = status[i][j] - '0';\n\t\t\t}\n\t\t}\n\t}\n\t/*for (int i = 1; i <= H; i++) {\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tcout << field[i][j];\n\t\t}\n\t\tcout << \"\\n\";\n\t}\n\tcout << \"\\n\";*/\n\tfor (int i = 1; i <= H; i++) {\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tif (field[i][j] != 0) {\n\t\t\t\tbox = 0;\n\t\t\t\tfor (int k = 0; k < 8; k++) {\n\t\t\t\t\tif (field[i + dir[k].first][j + dir[k].second] == 0)box++;\n\t\t\t\t}\n\t\t\t\tif (box >= field[i][j]) {\n\t\t\t\t\tQ.push(make_pair(i, j));\n\t\t\t\t\tans = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdel = Q;\n\twhile (!del.empty()) {\n\t\ty = del.front().first;\n\t\tx = del.front().second;\n\t\tfield[y][x] = 0;\n\t\tdel.pop();\n\t}\n\twhile (1) {\n\t\t/*for (int i = 1; i <= H; i++) {\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\tcout << field[i][j];\n\t\t\t}\n\t\t\tcout << \"\\n\";\n\t\t}\n\t\tcout << \"\\n\";*/\n\t\tnum = Q.size();\n\t\tfor (int i = 0; i < num; i++) {\n\t\t\ty = Q.front().first;\n\t\t\tx = Q.front().second;\n\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\tif (field[y + dir[j].first][x + dir[j].second] != 0) {\n\t\t\t\t\tbox = 0;\n\t\t\t\t\tfor (int k = 0; k < 8; k++) {\n\t\t\t\t\t\tif (field[y + dir[j].first + dir[k].first][x + dir[j].second + dir[k].second] == 0)box++;\n\t\t\t\t\t}\n\t\t\t\t\tif (box >= field[y + dir[j].first][x + dir[j].second]) {\n\t\t\t\t\t\tQ.push(make_pair(y + dir[j].first, x + dir[j].second));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t\tif (Q.empty())break;\n\t\tans++;\n\t\tdel = Q;\n\t\twhile (!del.empty()) {\n\t\t\ty = del.front().first;\n\t\t\tx = del.front().second;\n\t\t\tfield[y][x] = 0;\n\t\t\tdel.pop();\n\t\t}\n\t}\n\tcout << ans << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint h,w;\nchar beach[1000][1000];\nchar beachcopy[1000][1000];\nint saraticount(int a,int b){\n  int ret=0;\n  if(beach[a][b+1]=='.')ret++;\n  if(beach[a][b-1]=='.')ret++;\n  if(beach[a-1][b-1]=='.')ret++;\n  if(beach[a-1][b]=='.')ret++;\n  if(beach[a-1][b+1]=='.')ret++;\n  if(beach[a+1][b-1]=='.')ret++;\n  if(beach[a+1][b]=='.')ret++;\n  if(beach[a+1][b+1]=='.')ret++;\n  return ret;\n}\nint main(){\n  cin>>h>>w;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      cin>>beach[i][j];\n      beachcopy[i][j]=beach[i][j];\n    }\n  }\n  int count=0;\n  while(true){\n    bool change =false;\n    for(int i=1;i<h-1;i++){\n      for(int j=1;j<w-1;j++){\n        int num;\n        if(beach[i][j]!='.'){\n          stringstream ss;\n          ss<<beach[i][j];\n          ss>>num;\n          if(num<=saraticount(i,j)){\n            beachcopy[i][j]='.';\n            change=true;\n          }\n        }\n      }\n    }\n    if(change)count++;\n    else break;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        beach[i][j]=beachcopy[i][j];\n      }\n    }\n  }\n  cout<<count<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint h, w;\nint a[1010][1010];\nint dx[8] = {-1, 0, 1, -1, 1, -1, 0, 1};\nint dy[8] = {-1, -1, -1, 0, 0, 1, 1, 1};\n\nqueue<pair<int, int>> q;\nvector<pair<int, int>> n;\n\nint main()\n{\n  cin >> h >> w;\n  for (int i = 0; i < h; i++){\n    for (int j = 0; j < w; j++){\n      char c;\n      cin >> c;\n      if (c == '.') c = '0' - 1;\n      a[i][j] = c - '0';\n    }\n  }\n\n  for (int i = 0; i < h; i++){\n    for (int j = 0; j < w; j++){\n      if (a[i][j] != -1) continue;\n      for (int k = 0; k < 8; k++){\n        int x = j + dx[k];\n        int y = i + dy[k];\n        if (x < 0 || w <= x || y < 0 || h <= y) continue;\n        if (a[y][x] <= 0) continue;\n        a[y][x]--;\n        if (a[y][x] == 0) n.push_back(make_pair(y, x));\n      }\n    }\n  }\n\n  int cnt = 0;\n  while (n.size()){\n    cnt++;\n    for (auto v : n){\n      q.push(v);\n    }\n    n.clear();\n    while (!q.empty()){\n      auto v = q.front(); q.pop();\n      int i = v.first, j = v.second;\n      a[i][j]--;\n      for (int k = 0; k < 8; k++){\n        int x = j + dx[k];\n        int y = i + dy[k];\n        if (x < 0 || w <= x || y < 0 || h <= y) continue;\n        if (a[y][x] <= 0) continue;\n        a[y][x]--;\n        if (a[y][x] == 0) n.push_back(make_pair(y, x));\n      }\n    }\n  }\n\n  cout << cnt << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define FOR(i,n) for(int i=0;i<n;i++)\nstruct int2{\n  int x;\n  int y;\n};\nint h,w;\nint a[]={1,1,1,0,0,-1,-1,-1};\nint b[]={-1,0,1,-1,1,1,0,-1};\nqueue<int2> q1;\nqueue<int2> q2;\nstring beach1;\nint beach[1000][1000];\nint sarachi[1000][1000];\nint main(){\n  cin>>h>>w;\n  int count=0;\n  for(int i=0;i<h;i++){\n    cin>>beach1;\n    for(int j=0;j<w;j++){\n      sarachi[i][j]=0;\n      if(beach1[j]=='.')beach[i][j]=10;\n      else beach[i][j]=beach1[j]-'0';\n    }\n  }\n  for(int i=1;i<h-1;i++){\n    for(int j=1;j<w-1;j++){\n      FOR(k,8){\n        if(beach[i+a[k]][j+b[k]]==10)sarachi[i][j]++;\n      }\n      if(sarachi[i][j]>=beach[i][j]){\n        int2 num;\n        num.x=i;\n        num.y=j;\n        q1.push(num);\n      }\n    }\n  }\n  while(!q1.empty()){\n    int2 num=q1.front();\n    q1.pop();\n    beach[num.x][num.y]=10;\n    q2.push(num);\n  }\n  count = 0;\n  while(!q2.empty()){\n    while(!q2.empty()){\n      int2 num=q2.front();\n      q2.pop();\n      FOR(i,8){\n        sarachi[num.x+a[i]][num.y+b[i]]++;\n          if(sarachi[num.x+a[i]][num.y+b[i]]>=beach[num.x+a[i]][num.y+b[i]]){\n            int2 num2;\n            num2.x=num.x+a[i];\n            num2.y=num.y+b[i];\n            beach[num.x+a[i]][num.y+b[i]]=10;\n            q1.push(num2);\n          }\n        }\n      }\n    while(!q1.empty()){\n      int2 num=q1.front();\n      q1.pop();\n      q2.push(num);\n    }\n    count++;\n  }\n  cout<<count<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint a;\nint b;\nchar are[1001][1001];\nint kore[1001][1001];\nint sore[1001][1001];\nint sata[1001][1001];\nint ushi;\nint uma;\n\nint main(){\n\tcin >> a >> b;\n\tfor (int i = 0; i < a; i++){\n\t\tfor (int j = 0; j < b; j++){\n\t\t\tcin >> are[i][j];\n\t\t\tif (are[i][j] !='.'){\n\t\t\tkore[i - 1][j - 1]++;\n\t\t\tkore[i][j - 1]++;\n\t\t\tkore[i + 1][j - 1]++;\n\t\t\tkore[i - 1][j]++;\n\t\t\tkore[i + 1][j]++;\n\t\t\tkore[i - 1][j + 1]++;\n\t\t\tkore[i][j + 1]++;\n\t\t\tkore[i + 1][j + 1]++;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < a; i++){\n\t\tfor (int j = 0; j < b; j++){\n\t\t\tsore[i][j] = kore[i][j];\n\t\t\tsata[i][j] = 1;\n\t\t//\tcout<<sore[i][j];\n\t\t}\n\t}\n\twhile (true){\n\t\tuma = 0;\n\t\tfor (int i = 0; i < a; i++){\n\t\t\tfor (int j = 0; j < b; j++){\n\t\t\t//\tif (sata[i - 1][j - 1] ==1||sata[i][j - 1] == 1||sata[i + 1][j - 1] == 1||sata[i - 1][j] == 1||sata[i + 1][j] == 1||sata[i - 1][j + 1] == 1||sata[i][j + 1] == 1||sata[i + 1][j + 1] == 1){\n\t\t\t\t\t//cout<<are[i][j]<<\" \"<<9-sore[i][j]<<endl;\n\t\t\t\t\tif (are[i][j] != '.'&&9-sore[i][j] > are[i][j]-48){\n\t\t\t\t\t//cout<<1234<<endl;\n\t\t\t\t\t\tare[i][j] = '.';\n\t\t\t\t\t\tkore[i - 1][j - 1]--;\n\t\t\t\t\t\tkore[i][j - 1]--;\n\t\t\t\t\t\tkore[i + 1][j - 1]--;\n\t\t\t\t\t\tkore[i - 1][j]--;\n\t\t\t\t\t\tkore[i + 1][j]--;\n\t\t\t\t\t\tkore[i - 1][j + 1]--;\n\t\t\t\t\t\tkore[i][j + 1]--;\n\t\t\t\t\t\tkore[i + 1][j + 1]--;\n\t\t\t\t\t\tuma = 1;\n\t\t\t\t\t\tsata[i][j] = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse{ sata[i][j] = 0; }\n\t\t\t//\t}\n\t\t\t}\n\t\t}\n\t\tif (uma == 1){\n\t\t\tushi++;\n\t\t}\n\t\tif (uma == 0){\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < a; i++){\n\t\t\tfor (int j = 0; j < b; j++){\n\t\t\t\tsore[i][j] = kore[i][j];\n\t\t\t}\n\t\t//cout<<\"po\"<<endl;\n\t\t}\n\t}\n\tcout << ushi << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define times(n, i)      uptil(0, n, i)\n#define upto(f, t, i)    for(decltype(t) _##i = (t), i = (f); i <= _##i; i++)\n#define uptil(f, t, i)   for(decltype(t) _##i = (t), i = (f); i < _##i; i++)\n#define downto(f, t, i)  for(decltype(t) _##i = (t), i = (f); i >= _##i; i--)\n#define downtil(f, t, i) for(decltype(t) _##i = (t), i = (f); i > _##i; i--)\n#define unless(c) if(!(c))\n#define until(c) while(!(c))\n#define loop while(true)\n\n#define all(v) v.begin(), v.end()\n#define ln << \"\\n\"\n\nstruct line{};\n\ntemplate<class T> istream& operator>>(istream& in, vector<T>& v) {\n    times(v.capacity(), i) in >> v[i];\n    return in;\n}\n\ntemplate<class T> ostream& operator<<(ostream& out, const vector<T>& v) {\n    times(v.size(), i) out << (i ? \" \" : \"\") << v[i];\n    return out;\n}\n\ntemplate<class T, class...U> typename enable_if<is_same<T, line>::value, string>::type next(istream& in, const U&... args) {\n    string s;\n    getline(in, s, args...);\n    return move(s);\n}\n\ntemplate<class T, class...U> typename enable_if<!is_same<T, line>::value, T>::type next(istream& in, const U&... args) {\n    T t(args...);\n    in >> t;\n    return move(t);\n}\ntemplate<class T, class...U> auto next(const U&... args) -> decltype(next<T>(cin)) {\n    return next<T>(cin, args...);\n}\n\ntemplate<class T> T sum(const vector<T>& v) {\n    T ans = T();\n    for(const T& t : v) ans += t;\n    return ans;\n}\n\ntemplate<class T> T sum(const typename vector<T>::iterator& begin, const typename vector<T>::iterator& end) {\n    T ans = T();\n    for(typename vector<T>::iterator t = begin; t != end; t++) ans += *t;\n    return ans;\n}\n\ntemplate<class T> T min(const vector<T>& v) {\n    return *min_element(v.begin(), v.end());\n}\n\ntemplate<class T> T min(const typename vector<T>::iterator& begin, const typename vector<T>::iterator& end) {\n    return *min_element(begin, end);\n}\n\ntemplate<class T> T max(const vector<T>& v) {\n    return *max_element(v.begin(), v.end());\n}\n\ntemplate<class T> T max(const typename vector<T>::iterator& begin, const typename vector<T>::iterator& end) {\n    return *max_element(begin, end);\n}\n\ntemplate<class T> void uniq(vector<T>& v) {\n    sort(all(v));\n    v.erase(unique(all(v)), v.end());\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    #define eight_loop \\\n        upto(i-1, i+1, k) \\\n            upto(j-1, j+1, l) \\\n                if(0 <= k && k < H && 0 <= l && l < W && (i != k || j != l))\n\n\n    int H = next<int>(), W = next<int>();\n    vector<vector<bool>> broken(H, vector<bool>(W));\n    vector<vector<int>> strength(H, vector<int>(W));\n    vector<pair<int, int>> change_now, change_next, change_real;\n    times(H, i) {\n        times(W, j) {\n            char c = next<char>();\n            broken[i][j] = c == '.';\n            strength[i][j] = c - '0';\n        }\n    }\n    times(H, i)\n        times(W, j)\n            if(broken[i][j])\n                eight_loop\n                    if(!broken[k][l]) change_now.push_back(make_pair(k, l));\n    uniq(change_now);\n\n    int ans = 0;    \n    until(change_now.empty()) {\n        for(auto& p : change_now) {\n            int i = p.first, j = p.second, s = 0;\n            #ifdef debug\n                cout << '(' << i << ',' << j << ')';\n            #endif\n            eight_loop s += broken[k][l];\n            if(s >= strength[i][j]) {\n                change_real.push_back(p);\n                #ifdef debug\n                    cout << '*';\n                #endif\n            } else {\n                #ifdef debug\n                    cout << ' ';\n                #endif\n            }\n        }        \n        for(auto& p : change_real) broken[p.first][p.second] = true;\n        for(auto& p : change_real) {\n            int i = p.first, j = p.second;\n            eight_loop\n                if(!broken[k][l])\n                    change_next.push_back(make_pair(k, l));\n        }\n        #ifdef debug\n            cout ln;\n        #endif\n        uniq(change_next);\n        change_now = change_next;\n        change_next.clear();\n        change_real.clear();\n        ans++;\n    }\n\n    cout << ans - 1 ln;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cctype>\n#include <algorithm>\n\nusing P = std::pair<std::pair<int, int>, int>;\nconstexpr int MAX = 1000;\n\nint h, w;\nint board[MAX][MAX];\nint dx[8] = { 0,-1,-1,-1,0,1,1,1 }, dy[8] = { -1,-1,0,1,1,1,0,-1 };\n\nint count(int x, int y) {\n\tint cnt = 0;\n\tfor (int i = 0; i < 8; ++i) {\n\t\tif (!board[y + dy[i]][x + dx[i]])\n\t\t\t++cnt;\n\t}\n\treturn cnt;\n}\n\nint solve() {\n\tstd::queue<P> que;\n\n\tfor (int i = 0; i < h; ++i) {\n\t\tfor (int j = 0; j < w; ++j) {\n\t\t\tif (board[i][j]) {\n\t\t\t\t\tque.push(P(std::make_pair(j, i), 0));\n\t\t\t}\n\t\t}\n\t}\n\n\tint max = 0;\n\n\tstd::vector<std::pair<int, int>> vec;\n\n\twhile (!que.empty()) {\n\t\tP p = que.front(); que.pop();\n\n\t\tif (max < p.second) {\n\t\t\tfor (auto& x : vec)\n\t\t\t\tboard[x.second][x.first] = 0;\n\t\t\tvec.clear();\n\t\t\tmax = p.second;\n\n\t\t\tfor (int i = 0; i < h; ++i) {\n\t\t\t\tfor (int j = 0; j < w; ++j)\n\t\t\t\t\tstd::cout << board[i][j] << ' ';\n\t\t\t\tstd::cout << std::endl;\n\t\t\t}\n\t\t}\n\n\t\tif (board[p.first.second][p.first.first] <= count(p.first.first, p.first.second)) {\n\n\t\t\tvec.push_back(std::make_pair(p.first.first, p.first.second));\n\t\t\tint nx, ny;\n\t\t\tfor (int i = 0; i < 8; ++i) {\n\t\t\t\tnx = p.first.first + dx[i];\n\t\t\t\tny = p.first.second + dy[i];\n\t\t\t\tif (board[ny][nx]) {\n\t\t\t\t\tque.push(P(std::make_pair(nx, ny), p.second + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/*if (!vec.size())\n\t\t--max;*/\n\n\treturn max;\n}\n\nint main() {\n\tstd::cin >> h >> w;\n\n\tchar ch;\n\tfor (int i = 0; i < h; ++i) {\n\t\tfor (int j = 0; j < w; ++j) {\n\t\t\tstd::cin >> ch;\n\t\t\tif (std::isdigit(ch)) {\n\t\t\t\tboard[i][j] = atoi(&ch);\n\t\t\t}\n\t\t}\n\t}\n\n\tstd::cout << solve() << std::endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <cstring>\n#include <vector>\n\nusing namespace std;\n\nint h,w;\nchar bch[1003][1003];\nbool done[1003][1003];\n\nint wav (int i, int j)\n{\n    int c=0;\n    if (bch[i-1][j-1]=='.') c++;\n    if (bch[i-1][j]=='.') c++;\n    if (bch[i-1][j+1]=='.') c++;\n    if (bch[i][j-1]=='.') c++;\n    if (bch[i][j+1]=='.') c++;\n    if (bch[i+1][j-1]=='.') c++;\n    if (bch[i+1][j]=='.') c++;\n    if (bch[i+1][j+1]=='.') c++;\n    return c;\n}\n\nint bfs ()\n{\n    int cnt, ans=0;\n    bool done[1003][1003];\n    vector<pair<int, int>> que, vec;\n    for (int i=1; i<h-1; i++)\n    {\n        for (int j=1; j<w-1; j++)\n        {\n            if (bch[i][j]=='.') continue;\n            cnt=wav(i, j);\n            if (cnt>=bch[i][j]-'0') que.push_back({i, j});\n        }\n    }\n    while (1)\n    {\n        if (que.empty())\n        {\n            ans++;\n            for (auto u : vec)\n            {\n                int i=u.first, j=u.second;\n                bch[i][j]='.';\n            }\n            memset(done, false, sizeof(done));\n            for (auto u : vec)\n            {\n                int i=u.first, j=u.second;\n                if (bch[i-1][j-1]!='.' && !done[i-1][j-1] && wav(i-1, j-1)>=bch[i-1][j-1]-'0') { done[i-1][j-1]=true; que.push_back({i-1, j-1}); }\n                if (bch[i-1][j]!='.' && !done[i-1][j] && wav(i-1, j)>=bch[i-1][j]-'0') { done[i-1][j]=true; que.push_back({i-1, j}); }\n                if (bch[i-1][j+1]!='.' && !done[i-1][j+1] && wav(i-1, j+1)>=bch[i-1][j+1]-'0') { done[i-1][j+1]=true; que.push_back({i-1, j+1}); }\n                if (bch[i][j-1]!='.' && !done[i][j-1] && wav(i, j-1)>=bch[i][j-1]-'0') { done[i][j-1]=true; que.push_back({i, j-1}); }\n                if (bch[i][j+1]!='.' && !done[i][j+1] && wav(i, j+1)>=bch[i][j+1]-'0') { done[i][j+1]=true; que.push_back({i, j+1}); }\n                if (bch[i+1][j-1]!='.' && !done[i+1][j-1] && wav(i+1, j-1)>=bch[i+1][j-1]-'0') { done[i+1][j-1]=true; que.push_back({i+1, j-1}); }\n                if (bch[i+1][j]!='.' && !done[i+1][j] && wav(i+1, j)>=bch[i+1][j]-'0') { done[i+1][j]=true; que.push_back({i+1, j}); }\n                if (bch[i+1][j+1]!='.' && !done[i+1][j+1] && wav(i+1, j+1)>=bch[i+1][j+1]-'0') { done[i+1][j+1]=true; que.push_back({i+1, j+1}); }\n            }\n            vec.clear();\n        }\n        if (que.empty()) break;\n        vec.swap(que);\n        que.clear();\n    }\n    return ans;\n}\n\nint main()\n{\n    cin>>h>>w;\n    for (int i=0; i<h; i++) for (int j=0; j<w; j++) cin>>bch[i][j];\n    cout<<bfs()<<'\\n';\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\nint st,map1[2000];\nchar map[1002][1002];\nvoid snake(int x,int y){\n    if(map[y][x+1]=='.')\n        st++;\n    if(map[y+1][x]=='.')\n        st++;\n    if(map[y][x-1]=='.')\n        st++;\n    if(map[y-1][x]=='.')\n        st++;\n    if(map[y-1][x+1]=='.')\n        st++;\n    if(map[y+1][x+1]=='.')\n        st++;\n    if(map[y+1][x-1]=='.')\n        st++;\n    if(map[y-1][x-1]=='.')\n        st++;\n}\nint main(void){\n    int h,w,sign=1,sum=-1,i,t=0,o,p;\n    scanf(\"%d %d\",&h,&w);\n    p=getchar();\n    for(i=1;i<=h;i++){\n        for(o=1;o<=w;o++){\n            map[i][o]=getchar();\n        }\n        p=getchar();\n    }\n    while(t=0,sign){\n        sign=0;\n        for(i=1;i<=h;i++){\n            for(o=1;o<=w;o++){\n                if(st=0,map[i][o] != '.' && map[i][o] < '9'){\n                    snake(o,i);\n                    if(map[i][o]-48<=st){\n                        sign=1;\n                        map1[t++]=i;\n                        map1[t++]=o;\n                    }\n                }\n            }\n        }\n        for(p=0;p<t;p+=2)\n            map[map1[p]][map1[p+1]]='.';\n        sum++;\n    }\n    printf(\"%d\\n\",sum);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : JOI.cpp\n// Author      :\n// Version     :\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <algorithm>\nusing namespace std;\ntypedef struct pair<int,int> P;\n//1.???????DP\nint dp[1001][1001]={};\nint H,W;\nint d[1001][1001]={};\n\nint main() {\n\tcin>>H>>W;\n//2. ??\\???\n\tchar chr;\n\tfor(int i=0;i<H;i++){\n\t\tfor(int j=0;j<W;j++){\n\t\t\tcin>>chr;\n\t\t\tif(chr=='.')d[i][j]=0;\n\t\t\tif(chr=='1')d[i][j]=1;\n\t\t\tif(chr=='2')d[i][j]=2;\n\t\t\tif(chr=='3')d[i][j]=3;\n\t\t\tif(chr=='4')d[i][j]=4;\n\t\t\tif(chr=='5')d[i][j]=5;\n\t\t\tif(chr=='6')d[i][j]=6;\n\t\t\tif(chr=='7')d[i][j]=7;\n\t\t\tif(chr=='8')d[i][j]=8;\n\t\t\tif(chr=='9')d[i][j]=9;\n\t\t}\n\t}\n//3.queue\n\tqueue<P> que1,que2;\n\tint total=0;\n\tfor(int i=1;i<H-1;i++){\n\t\tfor(int j=1;j<W-1;j++){\n\t\t\tint t2=0;\n\t\t\tif(d[i-1][j]==0)++t2;\n\t\t\tif(d[i-1][j-1]==0)++t2;\n\t\t\tif(d[i-1][j+1]==0)++t2;\n\t\t\tif(d[i][j-1]==0)++t2;\n\t\t\tif(d[i][j+1]==0)++t2;\n\t\t\tif(d[i+11][j]==0)++t2;\n\t\t\tif(d[i+1][j-1]==0)++t2;\n\t\t\tif(d[i+1][j+1]==0)++t2;\n\t\t\tif(t2>=d[i][j])que1.push(P(i,j));\n\t\t}\n\t}\n\n\twhile(!que1.empty()){\n\t\ttotal++;\n\t\twhile(!que1.empty()){\n\t\t\tP p1=que1.front();\n\t\t\tque1.pop();\n\t\t\tint x=p1.first;\n\t\t\tint y=p1.second;\n\t\t\tif(d[x][y]==0)continue;\n\t\t\tint t2=0;\n\t\t\tif(d[x-1][y]==0)++t2;\n\t\t\tif(d[x-1][y-1]==0)++t2;\n\t\t\tif(d[x-1][y+1]==0)++t2;\n\t\t\tif(d[x][y-1]==0)++t2;\n\t\t\tif(d[x][y+1]==0)++t2;\n\t\t\tif(d[x+11][y]==0)++t2;\n\t\t\tif(d[x+1][y-1]==0)++t2;\n\t\t\tif(d[x+1][y+1]==0)++t2;\n\t\t\tif(t2<d[x][y])continue;\n\t\t\td[x][y]=0;\n\t\t\tque2.push(P(x-1,y));\n\t\t\tque2.push(P(x-1,y-1));\n\t\t\tque2.push(P(x-1,y+1));\n\t\t\tque2.push(P(x,y-1));\n\t\t\tque2.push(P(x,y+1));\n\t\t\tque2.push(P(x+1,y-1));\n\t\t\tque2.push(P(x+1,y));\n\t\t\tque2.push(P(x+1,y+1));\n\t\t}\n\t\twhile(!que2.empty()){\n\t\t\tP p2=que2.front();que2.pop();\n\t\t\tque1.push(p2);\n\t\t}\n\t}\n\n\tcout<<total<<endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair< int, int > P;\n\nint H, W;\nint fld[1000][1000];\nint cnt[1000][1000];\nint dx[] = {-1, -1, 0, 1, 1, 1, 0, -1}, dy[] = {0, -1, -1, -1, 0, 1, 1, 1};\n\nint main() {\n\tcin >> H >> W;\n\tqueue<P> Q;\n\tfor (int i = 0; i < H; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tfld[i][j] = (s[j] == '.' ? 0 : s[j] - '0');\n            if (fld[i][j] == 0) Q.push(P(i, j));\n\t\t}\n\t}\n\tint ans = -1;\n    while(Q.size()) {\n\t\tans++;\n\t\tint sz = Q.size();\n\t\tfor (int i = 0; i < sz; i++) {\n\t\t\tP p = Q.front(); Q.pop();\n\t\t\tint x = p.second, y = p.first;\n            for (int j = 0; j < 8; j++) {\n\t\t\t\tint nx = x + dx[j], ny = y + dy[j];\n\t\t\t\tif (nx < 0 || nx >= W || ny < 0 || ny >= H || fld[ny][nx] == 0) continue;\n\t\t\t\tcnt[ny][nx]++;\n                if (cnt[ny][nx] >= fld[ny][nx]) {\n\t\t\t\t\tfld[ny][nx] = 0;\n                    Q.push(P(ny, nx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"queue\"\n#include \"utility\"\n#include \"math.h\"\n\nusing namespace std;\nint H, W;\nchar status[1002][1002];\nint field[1002][1002];\npair<int, int> dir[8] = {make_pair(0,1),make_pair(1,1),make_pair(1,0),make_pair(1,-1),make_pair(0,-1),make_pair(-1,-1),make_pair(-1,0),make_pair(-1,1)};\nqueue<pair<int,int> > Q;\nqueue<pair<int, int> >del;\nint ans = 0;\nint box = 0;\nint num = 0;\nint x, y;\n\nint main() {\n\tcin >> H >> W;\n\tfor (int i = 1; i <= H; i++) {\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tcin >> status[i][j];\n\t\t\tif (status[i][j] == '.') {\n\t\t\t\tfield[i][j] = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfield[i][j] = status[i][j] - '0';\n\t\t\t}\n\t\t}\n\t}\n\t/*for (int i = 1; i <= H; i++) {\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tcout << field[i][j];\n\t\t}\n\t\tcout << \"\\n\";\n\t}\n\tcout << \"\\n\";*/\n\tfor (int i = 1; i <= H; i++) {\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tif (field[i][j] != 0) {\n\t\t\t\tbox = 0;\n\t\t\t\tfor (int k = 0; k < 8; k++) {\n\t\t\t\t\tif (field[i + dir[k].first][j + dir[k].second] == 0)box++;\n\t\t\t\t}\n\t\t\t\tif (box >= field[i][j]) {\n\t\t\t\t\tQ.push(make_pair(i, j));\n\t\t\t\t\tans = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tqueue<pair<int, int> >del(Q);\n\t\n\twhile (!del.empty()) {\n\t\ty = del.front().first;\n\t\tx = del.front().second;\n\t\tfield[y][x] = 0;\n\t\tdel.pop();\n\t}\n\twhile (1) {\n\t\t//cout << Q.size() << \"\\n\";\n\t\t/*for (int i = 1; i <= H; i++) {\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\tcout << field[i][j];\n\t\t\t}\n\t\t\tcout << \"\\n\";\n\t\t}\n\t\tcout << \"\\n\";*/\n\t\tnum = Q.size();\n\t\tfor (int i = 0; i < num; i++) {\n\t\t\ty = Q.front().first;\n\t\t\tx = Q.front().second;\n\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\tif (field[y + dir[j].first][x + dir[j].second] != 0) {\n\t\t\t\t\tbox = 0;\n\t\t\t\t\tfor (int k = 0; k < 8; k++) {\n\t\t\t\t\t\tif (field[y + dir[j].first + dir[k].first][x + dir[j].second + dir[k].second] == 0)box++;\n\t\t\t\t\t}\n\t\t\t\t\tif (box >= field[y + dir[j].first][x + dir[j].second]) {\n\t\t\t\t\t\tQ.push(make_pair(y + dir[j].first, x + dir[j].second));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t\tif (Q.empty())break;\n\t\tans++;\n\t\tqueue<pair<int, int> >del(Q);\n\t\t//del = Q;\n\t\t//cout << sizeof(del) << \"\\n\";\n\t\twhile (!del.empty()) {\n\t\t\t//cout << del.size() << \"\\n\";\n\t\t\ty = del.front().first;\n\t\t\tx = del.front().second;\n\t\t\tfield[y][x] = 0;\n\t\t\tdel.pop();\n\t\t}\n\t}\n\tcout << ans << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* {{{ Shinobu kawaii */\n/*\n  ______   __        _                  __\n.' ____ \\ [  |      (_)                [  |\n| (___ \\_| | |--.   __   _ .--.   .--.  | |.--.   __   _\n _.____`.  | .-. | [  | [ `.-. |/ .'`\\ \\| '/'`\\ \\[  | | |\n| \\____) | | | | |  | |  | | | || \\__. ||  \\__/ | | \\_/ |,\n \\______.'[___]|__][___][___||__]'.__.'[__;.__.'  '.__.'_/\n\n*/\n// clang-format off\n/* }}} */\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n// #define int long long\nstruct Fast {Fast(){std::cin.tie(0);ios::sync_with_stdio(false);}} fast;\n\n/* cpp template {{{ */\n\n/* short */\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define Fi first\n#define Se second\n#define ALL(v) (v).begin(), (v).end()\n#define X real()\n#define Y imag()\n\n/* REPmacro */\n#define REPS(i, a, n) for (int i = (a); i < (n); ++i)\n#define REP(i, n) REPS(i, 0, n)\n#define RREP(i, n) REPS(i, 1, n + 1)\n#define DEPS(i, a, n) for (int i = (a); i >= n; --i)\n#define DEP(i, n) DEPS(i, n, 0)\n\n/* debug */\n#define debug(x) cerr << x << \" \" << \"(L:\" << __LINE__ << \")\" << '\\n';\n\n/* alias */\nusing ll = long long;\nusing ull = unsigned long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nusing pii = pair<int, int>;\nusing D = double;\nusing P = complex<D>;\ntemplate <typename T> using PQ = priority_queue<T>;\ntemplate <typename T> using minPQ = priority_queue<T, vector<T>, greater<T>>;\n\n/* const */\nconst int INF = 1001001001;\nconst ll LINF = 1001001001001001001ll;\nconst int MOD = 1e9 + 7;\nconst D EPS = 1e-9;\nconst int dx[] = {0, 1, 0, -1, 1, -1, 1, -1}, dy[] = {1, 0, -1, 0, 1, -1, -1, 1};\n\n/* func */\ninline bool inside(int y, int x, int H, int W) {return y >= 0 && x >= 0 && y < H && x < W;}\ninline int in() {int x; cin >> x; return x;}\ntemplate <typename T> inline void print(const T& x) {cout << x << '\\n';}\ntemplate <typename T, typename S> inline void print(const pair<T, S>& p) {cout << p.first << \" \" << p.second << '\\n';}\ntemplate <typename T, typename S> inline void print(const vector<pair<T, S>>& v) {\n  REP(i, v.size()) print(v[i]);\n}\ntemplate <typename T> inline void print(const vector<T>& v, string s = \" \") {\n  REP(i, v.size()) {\n    if (i != 0) cout << s;\n    cout << v[i];\n  }\n  cout << '\\n';\n}\n// clang-format on\n/* }}} */\n\nchar field[1010][1010];\n\nsigned main() {\n  int h = in(), w = in();\n  REP(i, h) cin >> field[i];\n  bool flg = false;\n  queue<pii> q;\n  REP(i, h) REP(j, w) {\n    int cnt = 0;\n    if (field[i][j] == '.') continue;\n    REP(k, 8) if (inside(dy[k] + i, dx[k] + j, h, w) && field[dy[k] + i][dx[k] + j] == '.') ++cnt;\n    if (cnt >= field[i][j] - '0') {\n      q.emplace(i, j);\n      flg = true;\n    }\n  }\n  //debug(\"shinobu\");\n  if (!flg) {\n    print(0);\n    return 0;\n  }\n  //debug(q.size());\n  int ans = 1;\n  while (flg) {\n    flg = false;\n    queue<pii> qq;\n    while (q.size()) {\n      pii t = q.front(); q.pop();\n      field[t.first][t.second] = '.';\n      REP(i, 8) {\n        int ny = dy[i] + t.first, nx = dx[i] + t.second;\n        if (!inside(ny, nx, h, w)) continue;\n        //debug(field[ny][nx]);\n        qq.emplace(ny, nx);\n      }\n    }\n    while (qq.size()) {\n      pii t = qq.front(); qq.pop();\n      int cnt = 0;\n      if (field[t.first][t.second] == '.') continue;\n      REP(i, 8) {\n        int ny = dy[i] + t.first, nx = dx[i] + t.second;\n        if (field[ny][nx] == '.') ++cnt;\n      }\n      if (cnt >= field[t.first][t.second] - '0') {\n        q.push(t);\n        flg = true;\n      }\n    }\n    if (flg) ++ans;\n  }\n  print(ans);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <queue>\n#include <utility>\nusing namespace std;\n\nint main(void) {\n  int i, j, k, h, w, now = 0;\n  int x[8] = {-1, -1, -1, 0, 0, 1, 1, 1}, y[8] = {-1, 0, 1, -1, 1, -1, 0, 1};\n  scanf(\"%d%d\", &h, &w);\n  char s[h][w + 10];\n  for(i = 0; i < h; ++i) scanf(\"%s\", s[i]);\n  queue< pair<int, int> > q1, q2;\n  for(i = 1; i < h - 1; ++i) for(j = 1; j < w - 1; ++j) if(s[i][j] != '.') {\n    int a = 0;\n    for(k = 0; k < 8; ++k) if(s[i + x[k]][j + y[k]] == '.') ++a;\n    if(s[i][j] - '0' <= a) {\n      pair<int, int> p = make_pair(i, j);\n      q2.push(p);\n    }\n  }\n  while(!q2.empty()) {\n    pair<int, int> p;\n    p = q2.front();\n    s[p.first][p.second] = '.';\n    q1.push(p);\n    q2.pop();\n  }\n  if(q1.empty()) {\n    printf(\"0\\n\");\n    return 0;\n  }\n  while( !q1.empty() ) {\n    /*for(i = 0; i < h;++i) printf(\"%s\\n\", s[i]);\n    printf(\"\\n\");*/\n    while( !q1.empty() ) {\n      pair<int, int> p = q1.front();\n      q1.pop();\n      for(i = 0; i < 8; ++i) if(s[p.first + x[i]][p.second + y[i]] != '.') {\n        int a = 0;\n        for(j = 0; j < 8; ++j) {\n          if(s[p.first + x[i] + x[j]][p.second + y[i] + y[j]] == '.') ++a;\n        }\n        if(a >= s[p.first + x[i]][p.second + y[i]] - '0') {\n           pair<int, int> pp = make_pair(p.first + x[i], p.second + y[i]);\n           q2.push(pp);\n           s[p.first + x[i]][p.second + y[i]] = '0' + 9;\n        }\n      }\n    }\n    while(!q2.empty()) {\n      pair<int, int> p;\n      p = q2.front();\n      s[p.first][p.second] = '.';\n      q1.push(p);\n      q2.pop();\n    }\n    ++now;\n  }\n  printf(\"%d\\n\", now);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define fi first\n#define se second\nconst int inf = 1e9;\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define rrep(i,n) for(int i = 1;i <= n;i++)\ntypedef pair<int,int> P;\n\nqueue<P> q1, q2;\nchar str[1004][1004];\nint a[1004][1004], b[1004][1004], h, w;\nint dy[] = {-1, -1, -1, 0, 0, 1, 1, 1};\nint dx[] = {-1, 0, 1, -1, 1, -1, 0, 1};\nbool ok(int y, int x){\n\tif(y < 0 || h+1 < y)return 1;\n\tif(x < 0 || w+1 < x)return 1;\n\treturn 0;\n}\n\nvoid calc(int y, int x){\n\tif(b[y][x] || !a[y][x] || ok(y, x))return ;\n\tif(a[y][x] != inf){\n\t\ta[y][x]--;\n\t\tif(!a[y][x])q1.push(P(y, x));\n\t\treturn ;\n\t}\n\tb[y][x] = 1;\n\tfor(int i = 0;i < 8;i++){\n\t\tcalc(y+dy[i], x+dx[i]);\n\t}\n}\n\nint solve(int k){\n\tif(q1.empty())return k;\n\twhile(!q1.empty()){\n\t\tP p = q1.front();q1.pop();\n\t\tb[p.fi][p.se] = 1;\n\t\tfor(int i = 0;i < 8;i++){\n\t\t\tint yy = p.fi+dy[i], xx = p.se+dx[i];\n\t\t\tif(!b[yy][xx] && a[yy][xx] != inf && a[yy][xx] != 0){\n\t\t\t\ta[yy][xx]--;\n\t\t\t\tif(a[yy][xx] == 0)q2.push(P(yy, xx));\n\t\t\t}\n\t\t}\n\t}\n\tswap(q1, q2);\n\tk = solve(k+1);\n\treturn k;\n}\n\nint main(){\n\tfill((int*)a, (int*)(a+1004), inf);\n\tscanf(\"%d%d\", &h, &w);\n\trep(i,h)scanf(\"%s\", str[i]);\n\trep(i,h)rep(j,w){\n\t\tif(str[i][j] != '.')\n\t\ta[i+1][j+1] = str[i][j]-'0';\n\t}\n\t\n\trrep(i,h)rrep(j,w)if(a[i][j] == inf)calc(i, j);\n\tprintf(\"%d\\n\", solve(0));\n\t\n\t/*for(int i = 1;i <= h;i++){\n\t\tfor(int j = 1;j <= w;j++)printf(\"%d \", a[i][j]);\n\t\tprintf(\"\\n\");\n\t}*/\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> plli;\ntypedef pair<int,pii> pipii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\n\n#define int long long\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n\nconst ll mod = 1e9 + 7;\nconst ll INF = 1<<30;\nconst int dx4[4] = {1, 0, -1, 0};\nconst int dy4[4] = {0, 1, 0, -1};\nconst int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy8[8] = {0, 1, -1, 1, -1, 0, 1, -1};\nconst double pi = 3.141592653589793;\n\nint h,w;\nint g[1005][1005];\n\nbool check(int y,int x){\n    if ((0<=y && y<=h-1) && (0<=x && x<=w-1)) return true;\n    return false;\n}\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> h >> w;\n    queue<pair<int,int>> q;\n    rep(i,h)rep(j,w){\n        char s;\n        cin >> s;\n        if (s=='.'){\n            g[i][j]=0;\n            q.push(make_pair(i,j));\n        }\n        else g[i][j]=s-'0';\n    }\n    int ans=0;\n    while (true){\n        queue<pair<int,int>> tmp;\n        while (!q.empty()){\n            pair<int,int> now=q.front();\n            q.pop();\n            int y=now.fi;\n            int x=now.se;\n            rep(i,8){\n                int ny=y+dy8[i];\n                int nx=x+dx8[i];\n                if (!check(ny,nx)) continue;\n                if (g[ny][nx]>0){\n                    g[ny][nx]--;\n                    if (g[ny][nx]==0) tmp.push(make_pair(ny,nx));\n                }\n            }\n        }\n        q=tmp;\n        if (q.empty()) break;\n        ans++;\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<queue>\n#include<string>\n#include<cstring>\n#include<algorithm>\n#include<ctype.h>\n#include<cstdio>\nusing namespace std;\ntypedef pair<int,int> P;\nmain(){\n  int dx[8]={0,1,1,1,0,-1,-1,-1};\n  int dy[8]={1,1,0,-1,-1,-1,0,1};\n  int kyoudo[1003][1003]={0};\n  char masu[1003][1003];\n  int check[1003][1003]={0};\n  int h,w;\n  queue<P> q;\n  queue<P> stacking;\n  int nowx,nowy;\n  P p,a;\n  cin>>h>>w;\n  for(int i=0;i<=h+1;i++){\n    for(int j=0;j<=w+1;j++){\n      if(i==0||j==0||i==h+1||j==w+1){\n\tkyoudo[i][j]=0;\n\tmasu[i][j]='.';\n\tp.first=i;\n\tp.second=j;\n\tq.push(p);\n\tcheck[i][j]=1;\n      }\n      else{\n\tcin>>masu[i][j];\n\tif(masu[i][j]!='.'){\n\t  if(masu[i][j]=='1'){\n\t    kyoudo[i][j]=1;\n\t  }\n\t  if(masu[i][j]=='2'){\n\t    kyoudo[i][j]=2;\n\t  }\n\t  if(masu[i][j]=='3'){\n\t    kyoudo[i][j]=3;\n\t  }\n\t  if(masu[i][j]=='4'){\n\t    kyoudo[i][j]=4;\n\t  }\n\t  if(masu[i][j]=='5'){\n\t    kyoudo[i][j]=5;\n\t  }\n\t  if(masu[i][j]=='6'){\n\t    kyoudo[i][j]=6;\n\t  }\n\t  if(masu[i][j]=='7'){\n\t    kyoudo[i][j]=7;\n\t  }\n\t  if(masu[i][j]=='8'){\n\t    kyoudo[i][j]=8;\n\t  }\n\t  if(masu[i][j]=='9'){\n\t    kyoudo[i][j]=9;\n\t  }\n\t}\n\telse{\n\t  kyoudo[i][j]=0;\n\t  p.first=i;\n\t  p.second=j;\n\t  q.push(p);\n\t  check[i][j]=1;\n\t}\n      }\n    }\n  }\n  int count=0;\n  while(!q.empty()){\n    while(!q.empty()){\n      p=q.front();\n      nowx=p.first;\n      nowy=p.second;\n      for(int k=0;k<8;k++){\n\tint nx,ny;\n\tnx=nowx+dx[k];\n\tny=nowy+dy[k];\n\tif(nx>=0&&nx<=w&&ny>=0&&ny<=h&&kyoudo[nx][ny]!=0&&kyoudo[nx][ny]!=9){\n\t  kyoudo[nx][ny]=kyoudo[nx][ny]-1;\n\t  if(check[nx][ny]==0&&kyoudo[nx][ny]==0&&masu[nx][ny]!='.'){\n\t    a.first=nx;\n\t    a.second=ny;\n\t    stacking.push(a);\n\t    check[nx][ny]=1;\n\t  }\n\t}\n      }\n      check[nowx][nowy]=1;\n      q.pop();\n    }\n    while(!stacking.empty()){\n      p=stacking.front();\n      masu[p.first][p.second]='.';\n      q.push(stacking.front());\n      stacking.pop();\n    }\n    count=count+1;\n  }\n  cout<<count-1<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define ALL(a) (a).begin(), (a).end()\n#define llong long long\n\nusing namespace std;\nint dx[] = {-1,0,1,-1,1,-1,0,1};\nint dy[] = {-1,-1,-1,0,0,1,1,1};\n\nbool breakable(const vector<vector<int>> &f, int i, int j){\n\tint tmp  = 0;\n\tfor(int k = 0; k < 8; k++){\n\t\tif(f[i+dx[k]][j+dy[k]] == 0)tmp++;\n\t}\n\treturn tmp >= f[i][j];\n}\n\nbool iswiped(const vector<vector<int>> &f){\n\tfor(auto a : f)for(auto e : a)if(e != 0)return false;\n\treturn true;\n}\n\nbool innerRange(const int tar, const int l, const int r){\n\treturn l <= tar && tar < r;\n}\n\nsigned main(){\n\tint n,m; cin >> n >> m;\n\tint acc = 0;\n\tvector<vector<int>> f(n+2, vector<int>(m+2, 0));\n\tvector<vector<bool>> used(n+2, vector<bool>(m+2, false));\n\tfor(int i = 1; i <= n; i++)for(int j = 1; j <= m; j++){\n\t\tchar t; cin >> t;\n\t\tif(isdigit(t)){\n\t\t\tf[i][j] = (int)(t - '0');\n\t\t\tacc++;\n\t\t}\n\t}\n\tqueue<pair<pair<int,int>,int>> q;\n\tint sum = 0;\n\tfor(int i = 1; i <= n; i++)for(int j = 1; j<= m; j++){\n\t\tint tmp = 0;\n\t\tif(breakable(f,i,j) && f[i][j] != 0){\n\t\t\tq.push(make_pair(make_pair(i,j),0));\n\t\t\tused[i][j] = true;\n\t\t\tsum++;\n\t\t}\n\t}\n\tint ans = 0;\n\twhile(!q.empty()){\n\t\tauto now = q.front().first;\n//\t\tcerr << now.first << \" \" << now.second << endl;\n\n\t\tauto nowstep = q.front().second;\n\t\tq.pop();\n\t\tf[now.first][now.second] = 0;\n\t\tfor(int i = 0; i < 8; i++){\n\t\t\tint nextx = now.first+dx[i];\n\t\t\tint nexty = now.second+dy[i];\n\t\t\tif(!innerRange(nextx, 1, n+1) || !innerRange(nexty, 1, m+1))continue;\n\t\t\tif(breakable(f,nextx, nexty) && f[nextx][nexty] != 0){\n\t\t\t\tif(used[nextx][nexty])continue;\n\t\t\t\tq.push(make_pair(make_pair(nextx, nexty),nowstep+1));\n\t\t\t\tused[nextx][nexty] = true;\n\t\t\t\tsum++;\n\t\t\t}\n\t\t}\n\t\tans = nowstep+1;\n\t\t//if(acc == sum)break;\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "// JOI14-quest5.cpp :   \n//\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <queue>\n\nint height, width;\nint beach[1000][1000] = { 0 };\n\nusing namespace std;\nqueue<int> que_i, que_j;\n\nint power(int i, int j) {\n\tint count = 0;\n\n\tif (beach[i - 1][j] == 0) {\n\t\tcount++;\n\t}\n\tif (beach[i][j + 1] == 0) {\n\t\tcount++;\n\t}\n\tif (beach[i + 1][j] == 0) {\n\t\tcount++;\n\t}\n\tif (beach[i][j - 1] == 0) {\n\t\tcount++;\n\t}\n\n\tif (beach[i - 1][j + 1] == 0) {\n\t\tcount++;\n\t}\n\tif (beach[i + 1][j + 1] == 0) {\n\t\tcount++;\n\t}\n\tif (beach[i + 1][j - 1] == 0) {\n\t\tcount++;\n\t}\n\tif (beach[i - 1][j - 1] == 0) {\n\t\tcount++;\n\t}\n\n\treturn count;\n}\n\nvoid around(int i, int j) {\n\tif (beach[i - 1][j] != 0) {\n\t\tif (beach[i - 1][j] <= power(i - 1, j)) {\n\t\t\tque_i.push(i - 1);\n\t\t\tque_j.push(j);\n\t\t}\n\t}\n\tif (beach[i][j + 1] != 0) {\n\t\tif (beach[i][j + 1] <= power(i, j + 1)) {\n\t\t\tque_i.push(i);\n\t\t\tque_j.push(j + 1);\n\t\t}\n\t}\n\tif (beach[i + 1][j] != 0) {\n\t\tif (beach[i + 1][j] <= power(i + 1, j)) {\n\t\t\tque_i.push(i + 1);\n\t\t\tque_j.push(j);\n\t\t}\n\t}\n\tif (beach[i][j - 1] != 0) {\n\t\tif (beach[i][j - 1] <= power(i, j - 1)) {\n\t\t\tque_i.push(i);\n\t\t\tque_j.push(j - 1);\n\t\t}\n\t}\n\n\tif (beach[i - 1][j + 1] != 0) {\n\t\tif (beach[i - 1][j + 1] <= power(i - 1, j + 1)) {\n\t\t\tque_i.push(i - 1);\n\t\t\tque_j.push(j + 1);\n\t\t}\n\t}\n\tif (beach[i + 1][j + 1] != 0) {\n\t\tif (beach[i + 1][j + 1] <= power(i + 1, j + 1)) {\n\t\t\tque_i.push(i + 1);\n\t\t\tque_j.push(j + 1);\n\t\t}\n\t}\n\tif (beach[i + 1][j - 1] != 0) {\n\t\tif (beach[i + 1][j - 1] <= power(i + 1, j - 1)) {\n\t\t\tque_i.push(i + 1);\n\t\t\tque_j.push(j - 1);\n\t\t}\n\t}\n\tif (beach[i - 1][j - 1] != 0) {\n\t\tif (beach[i - 1][j - 1] <= power(i - 1, j - 1)) {\n\t\t\tque_i.push(i - 1);\n\t\t\tque_j.push(j - 1);\n\t\t}\n\t}\n}\n\nint _tmain(int argc, _TCHAR* argv[])\n{\n\t\n\n\tscanf(\"%d %d\", &height, &width);\n\n\tchar c;\n\tfor (int i = 0; i < height; i++) {\n\t\tfor (int j = 0; j < width; j++) {\n\t\t\tc = getchar();\n\t\t\tif (c == '\\n') {\n\t\t\t\tj--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (c == '.') {\n\t\t\t\tbeach[i][j] = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbeach[i][j] = c - 48;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < height; i++) {\n\t\tfor (int j = 0; j < width; j++) {\n\t\t\tif (beach[i][j] != 0) {\n\t\t\t\tif (beach[i][j] <= power(i, j)) {\n\t\t\t\t\tque_i.push(i);\n\t\t\t\t\tque_j.push(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint wave = 0, x[1000], y[1000], count, save, size;\n\twhile (que_i.empty() == false) {\n\t\twave++;\n\t\tcount = 0;\n\t\tsize = que_i.size();\n\t\tfor (int i = 0; i < size; i++) {\n\t\t\tif (beach[que_i.front()][que_j.front()] != 0) {\n\t\t\t\t\n\t\t\t\tbeach[que_i.front()][que_j.front()] = 0;\n\t\t\t\ty[count] = que_i.front();\n\t\t\t\tx[count] = que_j.front();\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tque_i.pop();\n\t\t\tque_j.pop();\n\t\t}\n\n\t\tfor (int i = 0; i < count; i++) {\n\t\t\taround(y[i], x[i]);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", wave);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define MP make_pair\n\ntypedef pair<int, int> PII;\n\nint h, w;\nchar maps[1000][1001];\nint cnt[1000][1000];\nqueue<pair<PII, int> > qu;\n\nbool check(int x, int y) {\n\treturn x >= 0 && x < w && y >= 0 && y < h;\n}\n\nint main() {\n\tcin >> h >> w;\n\tREP(i, h) cin >> maps[i];\n\t\n\tREP(i, h) REP(j, h) {\n\t\tif (maps[i][j] == '.') {\n\t\t\tcnt[i][j] = 0;\n\t\t\tqu.push(MP(MP(i, j), 0));\n\t\t}\n\t\telse {\n\t\t\tcnt[i][j] = maps[i][j] - '0';\n\t\t}\n\t}\n\n\tint ans = 0;\n\twhile (!qu.empty()) {\n\t\tpair<PII, int> now = qu.front(); qu.pop();\n\t\tPII pos = now.first;\t//y, x\n\t\tans = max(ans, now.second);\n\t\t\n\t\tint dx[] = { 1, 1, 1, 0, -1, -1, -1, 0 };\n\t\tint dy[] = { 1, 0, -1, -1, -1, 0, 1, 1 };\n\t\tREP(i, 8) {\n\t\t\tint nx = pos.second + dx[i], ny = pos.first + dy[i];\n\t\t\tif (!check(nx, ny) || cnt[ny][nx] <= 0) continue;\n\t\t\tcnt[ny][nx]--;\n\t\t\tif (cnt[ny][nx] == 0) qu.push(MP(MP(ny, nx), now.second + 1));\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#define F first\n#define S second\n#define MP make_pair\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PP;\nchar c[1000][1000];\nbool flag[1000][1000];\nint w, h, ans;\nint cdt[1000][1000];\nqueue<PP> que, que2;\n\nvoid fanc(PP p)\n{\n  for(int i = -1; i < 2; i++)\n  {\n    for(int j = -1; j < 2; j++)\n    {\n      if(!i && !j) continue;\n      if(p.F.F + i < h && p.F.F + i < h && p.F.S + j < w && p.F.S + j < w)\n        cdt[p.F.F + i][p.F.S + j]++;\n      if(cdt[p.F.F + i][p.F.S + j] == c[p.F.F + i][p.F.S + j] - '0')\n        que.push(MP(MP(p.F.F + i, p.F.S + j), p.S));\n    }\n  }\n}\nvoid bfs()\n{\n  while(!que.empty())\n  {\n    fanc(MP(que.front().F, que.front().S + 1));\n    ans = max(ans, que.front().S);\n    que.pop();\n  }\n}\nint main()\n{\n  cin >> h >> w;\n  for(int i = 0; i < h; i++)\n  {\n    for(int j = 0; j < w; j++)\n    {\n      cin >> c[i][j];\n    }\n  }\n  for(int i = 0; i < h; i++)\n  {\n    for(int j = 0; j < w; j++)\n    {\n      if(c[i][j] == '.')\n      {\n        fanc(MP(MP(i, j), 1));\n      }\n    }\n  }\n  bfs();\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\n#define REP(i, n) for(int i = 0; i < (int)(n); i++)\n#define FOR(i,n,m) for (int i=n; i<(int)(m); i++)\n#define INF 1000000007\n#define mp make_pair\n\ntypedef long long ll;\ntypedef long double ld;\nll dy[4]={-1,1,0,0};\nll dx[4]={0,0,1,-1};\n\n/*---------- template ----------*/\nint H,W;\nchar field[1010][1010];\nint around_zero_num[1010][1010];\n\nint main(){\n    cin >> H >> W;\n    REP(i,H){\n        cin >> field[i];\n    }\n    queue<pair<int,int> > que;\n    REP(i,H){\n        REP(j,W){\n            if(field[i][j]!='.') que.push(mp(i,j));\n            FOR(k,i-1,i+2){\n                FOR(l,j-1,j+2){\n                    if(i==k&&j==l) continue;\n                    if(k<0||l<0||H<=k||W<=l) around_zero_num[i][j]++;\n                    else if(field[k][l]=='.') around_zero_num[i][j]++;\n                }\n            }\n        }\n    }\n    \n    int ans=0;\n    while(que.size()!=0){\n        \n        //???????????\n        vector<pair<int,int> > broken;\n        while(que.size()!=0){\n            auto x = que.front();\n            que.pop();\n            if(field[x.first][x.second]!='.'&&int(field[x.first][x.second]-'0')<=around_zero_num[x.first][x.second]){\n                broken.push_back(x);\n            }\n        }\n        if(broken.size()!=0) ans++;\n        \n        //????????????????????\n        set<pair<int,int> > se;\n        for(auto x: broken){\n            field[x.first][x.second]='.';\n            FOR(i,x.first-1,x.first+2){\n                FOR(j,x.second-1,x.second+2){\n                    if(i==x.first&&j==x.second) continue;\n                    if(i<0||j<0||H<=i||W<=j) continue;\n                    if(field[i][j]=='.') continue;\n                    se.insert(mp(i,j));//??????????????????????\n                    around_zero_num[i][j]++;\n                }\n            }\n        }\n        for(auto x: se) que.push(x);\n    }\n    \n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint h,w;\nint t[52][52];\nint u[52][52];\nchar str[51];\nint q[3000],l,r;\n\nvoid init(){\n  l=r=0;\n}\n\nvoid push(int x){\n  q[r++]=x;\n}\n\nint pop(){\n  return q[l++];\n}\n\nint main(){\n  init();\n  scanf(\"%d %d\",&h,&w);\n  for(int i=1;i<=h;i++){\n    scanf(\"%s\",str);\n    for(int j=1;j<=w;j++){\n      if(str[j-1]=='.'){\n        t[i][j]=0;\n        u[i][j]=0;\n        push(i*w+j);\n      }else{\n        t[i][j]=str[j-1]-'0';\n      }\n    }\n  }\n  \n  int ans=0;\n  while(l!=r){\n    int x=pop();\n    int i=x/w,j=x%w;\n    for(int a=i-1;a<=i+1;a++){\n      for(int b=j-1;b<=j+1;b++){\n        t[a][b]--;\n        if(t[a][b]==0){\n          ans=u[a][b]=u[i][j]+1;\n          push(a*w+b);\n        }\n      }\n    }    \n  }\n  printf(\"%d\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint grd[1010][1010];\nint mx[]={1,1,1,0,0,0,-1,-1,-1},my[]={1,0,-1,1,0,-1,1,0,-1};\nint main(){\n\tint h,w;\tcin>>h>>w;\n\tqueue<pair<int,int>> ls;\n\tfor(int i=0;i<h;i++){\n\t\tstring s;\tcin>>s;\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(s[j]=='.')\tgrd[i][j]=-1;\n\t\t\telse{\n\t\t\t\tgrd[i][j]=s[j]-'0';\n\t\t\t\tls.push(make_pair(i,j));\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\twhile(true){\n\t\t//cout<<ans<<endl;\n\t\t//for(int i=0;i<h;i++){\n\t\t//\tfor(int j=0;j<w;j++)\tcout<<grd[i][j]<<\" \";\n\t\t//\tcout<<endl;\n\t\t//}\n\t\t//cout<<endl;\n\t\tqueue<pair<int,int>> next;\n\t\tqueue<pair<int,int>> broken;\n\t\twhile(!ls.empty()){\n\t\t\tauto now=ls.front();\tls.pop();\n\t\t\tint y=now.first,x=now.second;\n\t\t\tint cnt=0;\n\t\t\tfor(int i=0;i<9;i++)\tif(grd[y+my[i]][x+mx[i]]==-1)\tcnt++;\n\t\t\tif(cnt>=grd[y][x])\tbroken.push(make_pair(y,x));\n\t\t\telse \tnext.push(make_pair(y,x));\n\t\t}\n\t\tif(broken.empty()){\n\t\t\tcout<<ans<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\twhile(!broken.empty()){\n\t\t\tauto now=broken.front();\tbroken.pop();\n\t\t\tgrd[now.first][now.second]=-1;\n\t\t}\n\t\twhile(!next.empty()){\n\t\t\tls.push(next.front());\tnext.pop();\n\t\t}\n\t\tans++;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/*************************\n\n\t\tPCK 2012 t1\n\n************************/\n\n/*#include <stdio.h>\nint main(){\n\n\tint s;\n\tint sum = 0;\n\tint i;\n\n\tfor ( i = 0; i < 10; i++){\n\t\tscanf(\"%d\", &s);\n\t\tsum += s;\n\t}\n\n\tprintf(\"%d\\n\", sum);\n}*/\n\n/************************\n\n\t\tPCK 2012 t2\n\n************************/\n/*\n#include <stdio.h>\nint main(){\n\n\tint b[3];\n\tint i;\n\tfor ( i = 0; i < 3; i++){\n\t\tscanf(\"%d\", &b[i]);\n\t}\n\n\tif (b[2] == 1)\n\t\tprintf(\"Open\\n\");\n\telse if (b[0] == 1){\n\t\tif (b[1] == 1)\n\t\t\tprintf(\"Open\\n\");\n\t\telse\n\t\t\tprintf(\"Close\\n\");\n\t}\n\telse\n\t\tprintf(\"Close\\n\");\n}*/\n\n/****************************\n\n\t\tPCK 2012 t3\n\n****************************/\n/*\n\t#include <stdio.h>\n\tint main(){\n\n\t\tint n;\n\t\tint h[101] = { 0 };\n\t\tint i;\n\t\tint temp;\n\n\t\tscanf(\"%d\", &n);\n\n\t\twhile (n != 0){\n\t\t\tfor (i = 0; i < n + 1; i++){\n\t\t\t\tscanf(\"%d\", &h[i]);\n\t\t\t}\n\n\t\t\tif ((h[1] - h[0]) + h[1] == h[2]){\n\t\t\t\ttemp = h[1] - h[0];\n\t\t\t\tfor (i = 1; i < n; i++){\n\t\t\t\t\tif (h[i] + temp != h[i + 1]){\n\t\t\t\t\t\tprintf(\"%d\\n\", h[i + 1]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif ((h[2] - h[1]) + h[2] == h[3])\n\t\t\t\t\tprintf(\"%d\\n\", h[0]);\n\t\t\t\telse if ((h[1] - h[0]) + h[2] != h[3])\n\t\t\t\t\tprintf(\"%d\\n\", h[2]);\n\t\t\t\telse\n\t\t\t\t\tprintf(\"%d\\n\", h[1]);\n\t\t\t}\n\n\t\t\tscanf(\"%d\", &n);\n\t\t}\n\t}\n*/\n\n/*************************************\n\n\t\t\tPCK 2012 t4\n\t\t\t\t\t\t(2???????????????????)\n*************************************/\n/*\n#include <stdio.h>\nint main(void)\n\n{\n\n\tint n;\n\tint num[4], l, s, count, i, j, temp;\n\tscanf(\"%d\", &n);\n\twhile (n != 0000){\n\t\tcount = 0;\n\t\twhile (n != 6174){\n\t\t\tnum[0] = n / 1000;\n\t\t\tnum[1] = (n - num[0] * 1000) / 100;\n\t\t\tnum[2] = (n - num[0] * 1000 - num[1] * 100) / 10;\n\t\t\tnum[3] = n - num[0] * 1000 - num[1] * 100 - num[2] * 10;\n\t\t\tif (num[0] == num[1] && num[1] == num[2] && num[2] == num[3]) //????????????????(1111??????7777??????)??????\n\t\t\t\tbreak;\n\t\t\tfor (i = 0; i<3; i++){\n\t\t\t\tfor (j = i + 1; j<4; j++){\n\t\t\t\t\tif (num[i]>num[j]){\n\t\t\t\t\t\ttemp = num[i];\n\t\t\t\t\t\tnum[i] = num[j];\n\t\t\t\t\t\tnum[j] = temp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ts = num[0] * 1000 + num[1] * 100 + num[2] * 10 + num[3];\n\t\t\tl = num[3] * 1000 + num[2] * 100 + num[1] * 10 + num[0];\n\t\t\tn = l - s;\n\t\t\tcount++;\n\t\t}\n\t\tif (n == 6174 || count>0)\n\t\t\tprintf(\"%d\\n\", count);\n\t\telse\n\t\t\tprintf(\"NA\\n\");\n\n\t\tscanf(\"%d\", &n);\n\t}\n\n\treturn 0;\n\n}*/\n\n/*************************************\n\n\t\t\tPCK 2012 t5\n\n*************************************/\n/*\n#include <stdio.h>\n#include <algorithm>\n\nint *p, *j;\n\nint bfs(int n,int ){\n\n\treturn max(n * )\n}\n\nint main(){\n\n\tint n;\n\n\tscanf(\"%d\", &n);\n\twhile (n != 0){\n\n\t\tp = new int[n];\n\t\tj = new int[n - 1];\n\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &p[i]);\n\t\tfor (int i = 0; i < n - 1; i++)\n\t\t\tscanf(\"%d\", &j[i]);\n\n\t\tscanf(\"%d\", &n);\n\t}\n}*/\n\n//PCK 2013 t4 ????????????????????????\n/*/\n#include <iostream>\nusing namespace std;\n#include <cstring>\n#include <algorithm>\n\nint main(){\n\n\tint n;\n\tint hand[100];\n\n\twhile (cin >> n && n != 0){\n\n\t\tmemset(hand, 0, sizeof(hand));\n\t\tint field = 0;\n\t\tint num = 0;\n\n\t\tfor (int i = 0; i < 100; i++){\n\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tif (c == 'M') hand[num]++;\n\t\t\telse if (c == 'S'){ field += hand[num] + 1; hand[num] = 0; }\n\t\t\telse { hand[num] += field + 1; field = 0; }\n\t\t\tif (num + 1 < n) num++; else num = 0;\n\t\t}\n\n\t\tsort(hand, hand + n);\n\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tcout << hand[i] << ' ';\n\t\tcout << field << endl;\n\t}\n}\n*/\n/*********************************************************************\n\n\tpck 2009 t1\t\t\t?????\\??????????????????????????\n\n*********************************************************************/\n/*\n#include <iostream>\nusing namespace std;\n\nint main(){\n\n\tint s1, s2;\n\n\twhile (cin >> s1 >> s2 && s1 != 0 && s2 != 0){\n\n\t\tint sum[5];\n\t\tint max;\n\t\tint num;\n\t\tsum[0] = s1 + s2;\n\t\tmax = sum[0];\n\t\tnum = 0;\n\t\tfor (int i = 1; i < 5; i++){\n\t\t\tcin >> s1 >> s2;\n\t\t\tsum[i] = s1 + s2;\n\t\t\tif (max < sum[i]){\n\t\t\t\tmax = sum[i];\n\t\t\t\tnum = i;\n\t\t\t}\n\t\t}\n\n\t\tcout << (char)('A' + num) << ' ' << max << endl;\n\t}\n}*/\n\n/******************************************************************************\n\n\tpck 2009 t3\t\t\t???????????-??????????????????????????????\n\n*******************************************************************************/\n/*\n#include <iostream>\nusing namespace std;\n#include <algorithm>\n\nint main(){\n\n\tint x, y;\n\twhile (cin >> x >> y && x != 0 && y != 0){\n\n\t\tif (y > x) swap(x, y);\n\t\tint count = 0;\n\t\twhile (y != 0){\n\t\t\tcount++;\n\t\t\tx = x % y;\n\t\t\tswap(x, y);\n\t\t}\n\n\t\tcout << x << ' ' << count << endl;\n\t}\n}\n*/\n\n/************************************************************\n\n\t\tPCK 2013 t3\t\t\t?????????????????????\n\n************************************************************/\n/*\n#include <iostream>\nusing namespace std;\n\nint main(){\n\n\tint n;\n\twhile (cin >> n && n != 0){\n\n\t\tint m = n;\n\t\tbool flg = false;\n\n\t\tint k;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\t\n\t\t\tcin >> k;\n\t\t\tif (k >= 2) flg = true;\n\t\t\tif (k == 0) m--;\n\t\t}\n\n\t\tif (flg)\n\t\t\tcout << m + 1 << endl;\n\t\telse cout << \"NA\" << endl;\n\t}\n}\n*/\n\n/*******************************************\n\n\t\tPCK 2013 t5\t\t\t????\n\n********************************************/\n/*\n#include <iostream>\nusing namespace std;\n\nint main(){\n\n\tint q;\n\tcin >> q;\n\tfor (int i = 0; i < q; i++){\n\n\t\tint c, a, n;\n\t\tint count = 0;\n\n\t\tcin >> c >> a >> n;\n\n\t\tfor (; c > 0 && a > 0 && n > 0; count++){\n\t\t\tc--; a--; n--;\n\t\t}\n\t\tfor (; c >= 2 && a > 0; count++){\n\t\t\tc -= 2; a--;\n\t\t}\n\t\tfor (; c >= 3; count++)\n\t\t\tc -= 3;\n\n\t\tcout << count << endl;\n\t}\n}\n*/\n\n/*****************************************************************\n\n\t\tPCK 2012 t1\t\t\t10???????????????????????????????\n\n*****************************************************************/\n/*\n#include <iostream>\nusing namespace std;\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\n\tint sum = 0;\n\tint s;\n\t\n\tfor (int i = 0; i < 10; i++){\n\t\n\t\tcin >> s;\n\t\tsum += s;\n\t}\n\n\tcout << sum << \"\\n\";\n}\n*/\n/*\n#include <stdio.h>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\nclass Game\n{\npublic:\n\tint k;   // ????????????????????????????\n\tint m;   // ?????????????????????????????????\n\tbitset <16> x;   // ?????????????????\n\tGame(int k1, int m1, bitset<16> x1)\n\t{\n\t\tk = k1;\n\t\tm = m1;\n\t\tx = x1;\n\t}\n};\n\nint main()\n{\n\tint i1, i2, m, m1, n=1, n1, n2, c=1, k, k1, max;\n\tbitset <16> x, y;\n\n\tscanf(\"%d %d\\n\", &n, &c);\n\twhile (n > 0) {\n\t\t// ??\\???\n\t\tbitset<16> a[n];\n\t\tfor (i1 = 0; i1 < n; i1++) {\n\t\t\tfor (i2 = 15; i2 >= 0; i2--) {\n\t\t\t\tscanf(\"%d\", &k);\n\t\t\t\ta[i1].set(i2, k);\n\t\t\t}\n\t\t}\n\t\tbitset<16> b[c];\n\t\tfor (i1 = 0; i1 < c; i1++) {\n\t\t\tfor (i2 = 15; i2 >= 0; i2--) {\n\t\t\t\tscanf(\"%d\", &k);\n\t\t\t\tb[i1].set(i2, k);\n\t\t\t}\n\t\t}\n\t\t// ??????\n\t\tmax = 0;\n\t\tstack<Game> st;\n\t\tst.push(Game(0, 0, a[0]));\n\t\twhile (!st.empty()) {\n\t\t\tk = st.top().k;\n\t\t\tm = st.top().m;\n\t\t\tx = st.top().x;\n\t\t\tst.pop();\n\t\t\tfor (i1 = 0; i1 < c; i1++) {\n\t\t\t\ty = x;\n\t\t\t\tn1 = y.count();\n\t\t\t\ty ^= b[i1];\n\t\t\t\ty &= x;\n\t\t\t\tn2 = y.count();\n\t\t\t\tm1 = m + n1 - n2;\n\t\t\t\tif (k == n - 1) {\n\t\t\t\t\tif (m1 > max)\n\t\t\t\t\t\tmax = m1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tk1 = k + 1;\n\t\t\t\t\ty |= a[k1];\n\t\t\t\t\tst.push(Game(k1, m1, y));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", max);\n\t\t// ??????????????\n\t\tscanf(\"%d %d\\n\", &n, &c);\n\t}\n\n\treturn 0;\n}\n*/\n/*\n#include<iostream>\nusing namespace std;\n\n#include<algorithm>\n#include<cstring>\n\nint main(){\n\n\tint n, m, a[101], b[101];\n\tint point[101];\n\tmemset(point, 0, sizeof(point));\n\n\tcin >> n >> m;\n\n\tfor (int i = 1; i <= m; i++)\n\t\tcin >> a[i];\n\tfor (int i = 1; i <= m; i++){\n\t\tfor (int j = 1; j <= n; j++){\n\t\t\tcin >> b[j];\n\t\t\tif (b[j] == a[i])point[j]++;\n\t\t\telse point[a[i]]++;\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++)\n\t\tcout << point[i] << endl;\n}*/\n/*\t\t\t\t\t\tJOI ?????\n#include<iostream>\nusing namespace std;\n#include<stdio.h>\nint map[1002][1002];\t//???????????????????\nint dat[1002][1002];\t//????????????????????????????????????????????????????\nint x[1000001], y[1000001];\t//[n]???????????????????????????????????????????????????\nint dx[4] = { 1,0,-1,0 };\t//???????????\nint dy[4] = { 0,1,0,-1 };\t//???????????\nint main()\n{\n\tint mx, my;\n\tscanf(\"%d%d\", &mx, &my);\n\tfor (int i = 0; i < mx + 2; i++) {\n\t\tfor (int j = 0; j < my + 2; j++) {\n\t\t\tmap[i][j] = 1000000000; dat[i][j] = 0;\t//?????????\n\t\t}\n\t}\n\tfor (int i = 0; i < mx; i++) {\n\t\tfor (int j = 0; j < my; j++) {\n\t\t\tscanf(\"%d\", &map[i + 1][j + 1]);\t//??\\???\n\t\t}\n\t}\n\tfor (int i = 1; i <= mx; i++) {\n\t\tfor (int j = 1; j <= my; j++) {\n\t\t\tx[map[i][j]] = i, y[map[i][j]] = j;\t//???????????????????????????????\n\t\t}\n\t}\n\tint c = 0;\t//??????????\n\tfor (int i = 1; i <= mx*my; i++){\t//???????\n\n\t\tint r = 0;\n\t\tfor (int j = 0; j < 4; j++){\t//4??????????????\n\t\t\n\t\t\tint a = x[i] + dx[j], b = y[i] + dy[j];\t//????????\n\t\t\tif (map[a][b] < i)\t//???????????????????? i ??\\?????????\n\t\t\t{\n\t\t\t\tif (r == 0)r = dat[a][b];\t//?????????????????????????????????\n\t\t\t\telse if (r != dat[a][b])r = -1;\t//????????????????????????????????????\n\t\t\t}\n\t\t}\n\t\tif (r == 0)dat[x[i]][y[i]] = i;\t//?????????????????????????????????????????\n\t\telse dat[x[i]][y[i]] = r;\t//????????????????????????????????????\n\t\tif (r == -1)c++;\t//??????????????\n\t}\n\tprintf(\"%d\\n\", c);\n}\n*/\n\n/*\tJOI 2006 ????? t2 ??????????????? */\n/*#include <iostream>\nusing namespace std;\n\nint main() {\n\tint n, k;\n\twhile (cin >> n >> k && n != 0 && k != 0) {\n\n\t}\n\n\treturn 0;\n}*/\n\n/* ??????????? */\n/*\n#include<iostream>\nusing namespace std;\n#include<vector>\n#include<algorithm>\n\nint main() {\n\tlong long int n;\n\tlong long int k;\n\twhile (cin >> n >> k && n != 0 && k != 0) {\n\t\tvector<long long int> v;\n\t\tv.push_back(0);\n\n\t\tfor (long long int i = 1; i <= n; ++i) {\n\t\t\tlong long int m;\n\t\t\tcin >> m;\n\t\t\tv.push_back(m);\n\t\t\tv[i] += v[i - 1];\n\t\t}\n\n\t\tlong long int sum = 0;\n\t\tfor (long long int i = 1; i + k <= n; ++i) {\n\t\t\tsum = max(sum, v[i + k] - v[i]);\n\t\t}\n\n\t\tcout << sum << endl;\n\t}\n\t\n\treturn 0;\n}*/\n\n/* JOI 2016 t3 ?????????????????? */\n/*\n#include<iostream>\nusing namespace std;\n\n#include<cstring>\n\nint map[102][102] = { 1 };\n\nint main(){\n\tmemset(map, 1, sizeof(map));\n\tint n, m, d;\n\tcin >> n >> m >> d;\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int i2 = 0; i2 < m; ++i2) {\n\t\t\tchar str;\n\t\t\tcin >> str;\n\t\t\tif (str == '.') { map[i][i2] = 0; }\n\t\t}\n\t}\n\n\tint cnt = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int i2 = 0; i2 < m; ++i2) {\n\t\t\tif (map[i][i2] == 0) {\n\n\t\t\t\tbool flg = true;\n\t\t\t\tfor (int j = 1; j < d; ++j) {\n\t\t\t\t\tif (map[i + j][i2] != 0) {\n\t\t\t\t\t\tflg = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (flg) { ++cnt; }\n\n\t\t\t\tflg = true;\n\t\t\t\tfor (int j = 1; j < d; ++j) {\n\t\t\t\t\tif (map[i][i2 + j] != 0) {\n\t\t\t\t\t\tflg = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (flg) { ++cnt; }\n\t\t\t}\n\t\t}\n\t}\n\tcout << cnt << endl;\n\n\treturn 0;\n}\n*/\n/*\n\n#include<iostream>\nusing namespace std;\n\n#include<string>\n\nint dp[101][101] = { 0 };\n\nint main(){\n\tstring s, t;\n\tcin >> s >> t;\n\n\tfor (int i = 0; i <= t.size(); ++i) { dp[i][0] = 0; }\n\tfor (int i = 0; i <= s.size(); ++i) { dp[0][i] = 1; }\n\n\tfor (int i = 1; i <= t.size(); ++i) {\n\t\tfor (int i2 = 1; i2 <= s.size(); ++i2) {\n\t\t\tif (t[i - 1] == s[i2 - 1]) {\n\t\t\t\tdp[i][i2] = dp[i - 1][i2 - 1] + dp[i][i2 - 1];\n\t\t\t}\n\t\t\telse dp[i][i2] = dp[i][i2 - 1];\n\t\t}\n\t}\t\n\n\tcout << dp[t.size()][s.size()] << endl;\n\t\n\treturn 0;\n}\n*/\n/*\n#include<iostream>\nusing namespace std;\n\n#include<algorithm>\n\nint a[100001];\n\nint main() {\n\tint n, k;\n\twhile (cin >> n >> k && n != 0 && k != 0) {\n\t\ta[0] = 0;\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tcin >> a[i];\n\t\t\ta[i] += a[i - 1];\n\t\t}\n\t\tint maxi = 0;\n\t\tfor (int i = k; i <= n; ++i) {\n\t\t\tmaxi = max(maxi, a[i] - a[i - k]);\n\t\t}\n\n\t\tcout << maxi << endl;\n\t}\n\n\treturn 0;\n}\n*/\n\n/* JOI 2010 ???????? */\n/*\n#include<iostream>\nusing namespace std;\n\n#include<algorithm>\n\nunsigned long long dp[21][101] = { 0 };\n\nint main() {\n\tunsigned long long n, num;\n\tcin >> n;\n\tfor (unsigned long long i = 0; i < n - 1; ++i) {\n\t\tcin >> num;\n\t\tif (i == 0) {\n\t\t\t++dp[num][i];\n\t\t}\n\t\telse {\n\t\t\tfor (unsigned long long j = 0; j <= 20; ++j) {\n\t\t\t\tif (dp[j][i - 1] != 0) {\n\t\t\t\t\tif (j + num >= 0 && j + num <= 20) {\n\t\t\t\t\t\tdp[j + num][i] += dp[j][i - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (j - num >= 0 && j - num <= 20) {\n\t\t\t\t\t\tdp[j - num][i] += dp[j][i - 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcin >> num;\n\tcout << dp[num][n - 2] << endl;\n\n\treturn 0;\n}\n*/\n\n/* JOI 2010 t5 ????????? */\n/*\n#include<iostream>\nusing namespace std;\n\n#include<queue>\n#include<cstring>\n\ntypedef unsigned long long int ullint;\n\nstruct Q {\n\tullint x;\n\tullint y;\n};\n\nQ In(ullint x, ullint y) { Q a; a.x = x; a.y = y; return a; }\n\nchar map[1002][1002];\nullint num[1003][1003] = { 0 };\n\nullint xm[] = { 0,0,-1,1 };\nullint ym[] = { -1,1,0,0 };\n\nint main() {\n\tullint h, w, n;\n\tQ st;\n\tcin >> h >> w >> n;\n\tfor (ullint i = 0; i <= h + 1; ++i) {\n\t\tfor (ullint i2 = 0; i2 <= w + 1; ++i2) {\n\t\t\tmap[i][i2] = 'X';\n\t\t}\n\t}\n\tfor (ullint i = 1; i <= h; ++i) {\n\t\tfor (ullint i2 = 1; i2 <= w; ++i2) {\n\t\t\tchar str;\n\t\t\tcin >> str;\n\t\t\tmap[i][i2] = str;\n\t\t\tif (str == 'S') { st.y = i; st.x = i2; }\n\t\t}\n\t}\n\n\tqueue<Q> que; que.push(st);\n\tullint number = 1;\n\tullint ans = 0;\n\tfor (number = 1; number <= n; ++number) {\n\t\twhile (!que.empty()) {\n\t\t\tQ now;\n\t\t\tnow = que.front();\n\t\t\tque.pop();\n\t\t\tullint memo = num[now.y][now.x];\n\t\t\tif (map[now.y][now.x] == '0' + number) {\n\t\t\t\tans += memo;\n\t\t\t\tfor (ullint i = 0; i <= h + 1; ++i) {\n\t\t\t\t\tfor (ullint i2 = 0; i2 <= w + 1; ++i2) {\n\t\t\t\t\t\tnum[i][i2] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile (!que.empty()) { que.pop(); }\n\t\t\t\tque.push(In(now.x, now.y));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (ullint i = 0; i < 4; ++i) {\n\t\t\t\tif (map[now.y + ym[i]][now.x + xm[i]] != 'X') {\n\t\t\t\t\tif (num[now.y + ym[i]][now.x + xm[i]] == 0) {\n\t\t\t\t\t\tnum[now.y + ym[i]][now.x + xm[i]] = memo + 1;\n\t\t\t\t\t\tque.push(In(now.x + xm[i], now.y + ym[i]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}\n*/\n\n/* JOI 2014 t3 ??????????? */\n/*\n#include<iostream>\nusing namespace std;\n#include<cstring>\n\nint main() {\n\tint h, w;\n\tint map[102][102];\n\tchar data[102][102];\n\tmemset(map, -1, sizeof(map));\n\n\tcin >> h >> w;\n\tfor (int i = 0; i < h; ++i) {\n\t\tfor (int i2 = 0; i2 < w; ++i2) {\n\t\t\tchar str;\n\t\t\tcin >> str;\n\t\t\tdata[i][i2] = str;\n\t\t\tif (data[i][i2] == 'c') {\n\t\t\t\tmap[i][i2] = 0;\n\t\t\t}\n\t\t\tif (data[i][i2] == '.') {\n\t\t\t\tif (i2 != 0) {\n\t\t\t\t\tif (map[i][i2 - 1] != -1) {\n\t\t\t\t\t\tmap[i][i2] = map[i][i2 - 1] + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < h; ++i) {\n\t\tfor (int i2 = 0; i2 < w; ++i2) {\n\t\t\tcout << map[i][i2];\n\t\t\tif (i2 < w - 1) {\n\t\t\t\tcout << \" \";\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n*/\n\n/* JOI 2014 t4 ?????????????????? */\n/*\n#include<iostream>\nusing namespace std;\n#include<cstring>\n#include<algorithm>\n\n#define INF 1000000001\n\ntypedef long long int llint;\n\nllint dp[1002][1002];\n\nint main() {\n\tllint n, m;\n\tllint d[1002];\n\tllint c[1002];\n\n\tmemset(dp, 0, sizeof(dp));\n\n\tcin >> n >> m;\n\tfor (llint i = 1; i <= n; ++i) {\n\t\tcin >> d[i];\n\t}\n\tfor (llint i = 1; i <= m; ++i) {\n\t\tcin >> c[i];\n\t}\n\n\tfor (llint day = 0; day <= m; ++day) {\n\t\tfor (llint num = 1; num <= n; ++num) {\n\t\t\tdp[day][num] = INF;\n\t\t}\n\t}\n\n\tfor (llint day = 1; day <= m; ++day) {\n\t\tfor (llint num = 1; num <= n; ++num) {\n\t\t\tdp[day][num] = min(dp[day - 1][num], dp[day - 1][num - 1] + c[day] * d[num]);\n\t\t}\n\t}\n\n\tcout << dp[m][n] << endl;\n\n\treturn 0;\n}\n*/\n/* JOI 2014 t5 ????????? */\n\n#include<iostream>\nusing namespace std;\n#include<queue>\n#include<cstring>\n\nstruct XY{\n\tint x;\n\tint y;\n};\n\nint map[1002][1002] = {};\nint map2[1002][1002] = {};\nbool map_flg[1002][1002] = {};\n\nint xm[] = { -1,0,1,-1,0,1,-1,0,1 };\nint ym[] = { -1,-1,-1,0,0,0,1,1,1 };\n\nvoid Updata(int h,int w) {\n\tfor (int i = 1; i <= h; ++i) {\n\t\tfor (int i2 = 1; i2 <= w; ++i2) {\n\t\t\tmap[i][i2] = map2[i][i2];\n\t\t}\n\t}\n\n\treturn;\n}\n\nint main() {\n\tmemset(map, -1, sizeof(map));\n\tmemset(map2, -1, sizeof(map2));\n\tmemset(map_flg, true, sizeof(map_flg));\n\tint h, w;\n\tXY st;\n\tcin >> h >> w;\n\tbool st_flg = true;\n\tfor (int i = 1; i <= h; ++i) {\n\t\tfor (int i2 = 1; i2 <= w; ++i2) {\n\t\t\tchar str;\n\t\t\tcin >> str;\n\t\t\tif (str <= '9' || str > '0') {\n\t\t\t\tmap[i][i2] = str - '0';\n\t\t\t\tmap2[i][i2] = str - '0';\n\t\t\t}\n\t\t\tif (str == '.') {\n\t\t\t\tmap[i][i2] = 0;\n\t\t\t\tmap2[i][i2] = 0;\n\t\t\t\tif (st_flg) {\n\t\t\t\t\tst_flg = false;\n\t\t\t\t\tst.y = i; st.x = i2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tqueue<XY> que;\n\tqueue<XY> temp;\n\tque.push(st);\n\tint ans = 0;\n\tdo {\n\t\twhile (!que.empty()) {\n\t\t\tXY now = que.front();\n\t\t\tque.pop();\n\t\t\tmap_flg[now.y][now.x] = false;\n\t\t\tfor (int i = 0; i < 8; ++i) {\n\t\t\t\tif (map_flg[now.y + ym[i]][now.x + xm[i]]) {\n\t\t\t\t\tif (map[now.y + ym[i]][now.x + xm[i]] == 0) {\n\t\t\t\t\t\tXY next;\n\t\t\t\t\t\tnext.y = now.y + ym[i];\n\t\t\t\t\t\tnext.x = now.x + xm[i];\n\t\t\t\t\t\tque.push(next);\n\t\t\t\t\t}\n\t\t\t\t\telse if(map2[now.y + ym[i]][now.x + xm[i]] > 0) {\n\t\t\t\t\t\t--map2[now.y + ym[i]][now.x + xm[i]];\n\t\t\t\t\t\tif (map2[now.y + ym[i]][now.x + xm[i]] == 0) {\n\t\t\t\t\t\t\tXY next;\n\t\t\t\t\t\t\tnext.y = now.y + ym[i];\n\t\t\t\t\t\t\tnext.x = now.x + xm[i];\n\t\t\t\t\t\t\ttemp.push(next);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (temp.empty()) {\n\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t\t++ans;\n\t\t\twhile (!temp.empty()) {\n\t\t\t\tque.push(temp.front());\n\t\t\t\ttemp.pop();\n\t\t\t}\n\t\t\tUpdata(h, w);\n\t\t}\n\t} while (1);\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rrep(i,n) for(int i=1;i<=n;i++)\n#define drep(i,n) for(int i=n;i>=0;i--)\n#define MAX 200004\n#define B 100\n#define dpb push_back\n#define fi first\n#define se second\ntypedef pair<int, int> P;\ntypedef long long ll;\nconst int inf = 1e9;\nconst ll INF = 1e16;\n//__gcd(a,b), __builtin_popcount(a);\n\nchar a[1006][1006];\nint fld1[1006][1006], fld2[1006][1006], flag[1006][1006];\nint dy[8] = {-1, -1, -1, 0, 0, 1, 1, 1};\nint dx[8] = {0, -1, 1, -1, 1, 0, -1, 1};\nqueue<P> q1, q2;\n\nint bfs1(){\n\tint check = 1;\n\trep(i,56)rep(j,56){\n\t\tif(fld2[i][j] <= 0)\n\t\tfld1[i][j] = fld2[i][j] = inf;\n\t\telse fld1[i][j] = fld2[i][j];\n\t}\n\twhile(!q2.empty()){\n\t\tP p = q2.front();q2.pop();\n\t\tint y = p.fi, x = p.se;\n\t\tif(fld2[y][x] == inf){\n\t\t\tfor(int i = 0;i < 8;i++){\n\t\t\t\tif(fld2[y+dy[i]][x+dx[i]] != inf){\n\t\t\t\t\tif(fld1[y+dy[i]][x+dx[i]] == fld2[y+dy[i]][x+dx[i]]){\n\t\t\t\t\t\tcheck = 0;\n\t\t\t\t\t\tq1.push(P(y+dy[i], x+dx[i]));\n\t\t\t\t\t}\n\t\t\t\t\tfld1[y+dy[i]][x+dx[i]]--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn check;\n}\n\nint bfs2(){\n\tint check = 1;\n\trep(i,56)rep(j,56){\n\t\tif(fld1[i][j] <= 0)\n\t\tfld1[i][j] = fld2[i][j] = inf;\n\t\telse fld2[i][j] = fld1[i][j];\n\t}\n\twhile(!q1.empty()){\n\t\tP p = q1.front();q1.pop();\n\t\tint y = p.fi, x = p.se;\n\t\tif(fld1[y][x] == inf){\n\t\t\tfor(int i = 0;i < 8;i++){\n\t\t\t\tif(fld1[y+dy[i]][x+dx[i]] != inf){\n\t\t\t\t\tif(fld2[y+dy[i]][x+dx[i]] == fld1[y+dy[i]][x+dx[i]]){\n\t\t\t\t\t\tcheck = 0;\n\t\t\t\t\t\tq2.push(P(y+dy[i], x+dx[i]));\n\t\t\t\t\t}\n\t\t\t\t\tfld2[y+dy[i]][x+dx[i]]--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn check;\n}\n\nint main(){\n\tint h, w;\n\tscanf(\"%d%d\", &h, &w);\n\tfill((int*)fld1, (int*)(fld1+56), inf);\n\tfill((int*)fld2, (int*)(fld2+56), inf);\n\trep(i,h)scanf(\"%s\", a[i]);\n\trrep(i,h)rrep(j,w){\n\t\tif(a[i-1][j-1] != '.')\n\t\tfld1[i][j] = fld2[i][j] = a[i-1][j-1]-'0';\n\t}\n\t\n\tfor(int y = 1;y <= h;y++){\n\t\tfor(int x = 1;x <= w;x++){\n\t\t\tif(fld1[y][x] == inf){\n\t\t\tfor(int i = 0;i < 8;i++){\n\t\t\t\t\n\t\t\t\tint yy = y+dy[i], xx = x+dx[i];\n\t\t\t\tif(fld1[yy][xx] != inf){\n\t\t\t\t\tif(flag[yy][xx] == 0){\n\t\t\t\t\t\tq2.push(P(yy, xx));\n\t\t\t\t\t}\n\t\t\t\t\tfld2[yy][xx]--;\n\t\t\t\t\tflag[yy][xx] = 1;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i = 0;i <= h;i++){\n\t\tfor(int j = 0;j <= w;j++){\n\t\t\tif(fld2[i][j] <= 0)fld2[i][j] = inf;\n\t\t}\n\t}\n\t\n\tint check = 1, ans = 0;\n\twhile(1){\n\t\tcheck = bfs1();\n\t\tif(check == 1)break;\n\t\tans++;\n\t\t//printf(\"*\\n\");\n\t\tcheck = bfs2();\n\t\tif(check == 1)break;\n\t\tans++;\n\t}\n\t/*while(!q1.empty()){\n\t\tP p = q1.front();q1.pop();\n\t\tprintf(\"%d %d\\n\", p.fi, p.se);\n\t}*/\n\t\n\t/*for(int i = 0;i <= h;i++){\n\t\tfor(int j = 0;j <= w;j++){\n\t\t\tprintf(\"%10d \", fld1[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\tprintf(\"\\n\");\n\tfor(int i = 0;i <= h;i++){\n\t\tfor(int j = 0;j <= w;j++){\n\t\t\tprintf(\"%10d \", fld2[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}*/\n\t\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n#define INF (1 << 29)\n\nconst int dx[8] = { -1, 0, 1, -1, 1, -1, 0, 1 };\nconst int dy[8] = { -1, -1, -1, 0, 0, 1, 1, 1 };\n\nint H, W;\n\nint main()\n{\n\tcin >> H >> W;\n\n\tvector<vector<char> > D(H, vector<char>(W));\n\tvector<vector<int> > dp(H, vector<int>(W, INF));\n\n\tfor (int i = 0; i < H; i++)\n\t{\n\t\tfor (int j = 0; j < W; j++)\n\t\t{\n\t\t\tcin >> D[i][j];\n\n\t\t\tif (D[i][j] == '.')\n\t\t\t{\n\t\t\t\tdp[i][j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tqueue<pair<int, int> > que;\n\tqueue<int> q2;\n\n\tfor (int i = 0; i < H; i++)\n\t{\n\t\tfor (int j = 0; j < W; j++)\n\t\t{\n\t\t\tif (dp[i][j] != 0)\n\t\t\t{\n\t\t\t\tint count = 0;\n\n\t\t\t\tfor (int dir = 0; dir < 8; dir++)\n\t\t\t\t{\n\t\t\t\t\tif (0 <= i + dy[dir] && i + dy[dir] < H && 0 <= j + dx[dir] && j + dx[dir] < W)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (dp[i + dy[dir]][j + dx[dir]] == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (count >= D[i][j] - 48)\n\t\t\t\t{\n\t\t\t\t\tpair<int, int> p1;\n\n\t\t\t\t\tp1.first = j;\n\t\t\t\t\tp1.second = i;\n\n\t\t\t\t\tque.push(p1);\n\t\t\t\t\tq2.push(1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\twhile (!que.empty())\n\t{\n\t\tpair<int, int> p1 = que.front(); que.pop();\n\n\t\tint dist = q2.front(); q2.pop();\n\n\t\tint x = p1.first;\n\t\tint y = p1.second;\n\t\tint count = 0;\n\n\t\tfor (int dir = 0; dir < 8; dir++)\n\t\t{\n\t\t\tif (0 <= y + dy[dir] && y + dy[dir] < H && 0 <= x + dx[dir] && x + dx[dir] < W)\n\t\t\t{\n\t\t\t\tif (dp[y + dy[dir]][x + dx[dir]] < dist)\n\t\t\t\t{\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (count >= D[y][x] - 48)\n\t\t{\n\t\t\tdp[y][x] = dist;\n\n\t\t\tpair<int, int> p2;\n\n\t\t\tfor (int dir = 0; dir < 8; dir++)\n\t\t\t{\n\t\t\t\tif (0 <= y + dy[dir] && y + dy[dir] < H && 0 <= x + dx[dir] && x + dx[dir] < W)\n\t\t\t\t{\n\t\t\t\t\tif (dp[y + dy[dir]][x + dx[dir]] == INF)\n\t\t\t\t\t{\n\t\t\t\t\t\tp2.first = x + dx[dir];\n\t\t\t\t\t\tp2.second = y + dy[dir];\n\n\t\t\t\t\t\tque.push(p2);\n\t\t\t\t\t\tq2.push(dist + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint Ans = 0;\n\n\tfor (int i = 0; i < H; i++)\n\t{\n\t\tfor (int j = 0; j < W; j++)\n\t\t{\n\t\t\tif (dp[i][j] != INF)\n\t\t\t{\n\t\t\t\tAns = max(Ans, dp[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << Ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<bits//stdc++.h>\n#include<functional>\nusing namespace std;\nstruct P{\n\tint x,y;\n};\nint main() {\n\tint a[500][500];\n\tint h,w;\n\tcin>>h>>w;\n\tfor(int i=0;i<h;i++){\n\t\tstring s;\n\t\tcin>>s;\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(s[j]=='.') a[i][j]=0;\n\t\t\telse a[i][j]=(int)s[j]-'0';\n\t\t}\n\t}\n\tint sum=0,sum2=1;\n\twhile(sum2){\n\t\tsum2=0;\n\t\tint sum3;\n\t\tP p[1000];\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(a[i][j]){\n\t\t\t\t\tsum3=0;\n\t\t\t\t\tfor(int x=-1;x<=1;x++){\n\t\t\t\t\t\tfor(int y=-1;y<=1;y++){\n\t\t\t\t\t\t\tif(i+x<h&&i+x>=0&&j+y<w&&j+y>=0&&a[i+x][j+y]==0) sum3++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(sum3>=a[i][j]) {\n\t\t\t\t\t\tp[sum2]=P{i,j};\n\t\t\t\t\t\tsum2++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<sum2;i++){\n\t\t\ta[p[i].x][p[i].y]=0;\n\t\t}\n\t\tsum++;\n\t}\n\tcout<<--sum<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <vector>\n#include <math.h>\n#include <queue>\n#include <stack>\n#include <list>\n#include <functional>\n\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (n); i++)\n\nint H, W;\nchar S[1234][1234];\nconst int dx[] = {\n\t-1, 0, 1,\n\t-1,    1,\n\t-1, 0, 1\n}, dy[] = {\n\t-1,-1,-1,\n\t 0,    0,\n\t 1, 1, 1\n};\n\nint main() {\n\n\tscanf(\"%d%d\", &H, &W);\n\n\tqueue<pair<pair<int, int>, int>> q;\n\tset<pair<int, int>> qs;\n\n\trep(i, H) {\n\t\tscanf(\"%s\", S[i]);\n\t\trep(j, W) {\n\t\t\tif (S[i][j] == '.') {\n\t\t\t\tS[i][j] = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tS[i][j] -= '0';\n\t\t\t}\n\t\t}\n\t}\n\n\trep(i, H) {\n\t\trep(j, W) {\n\t\t\tif (!S[i][j]) {\n\t\t\t\trep(k, 8) {\n\t\t\t\t\tif (j + dx[k] >= 0 && j + dx[k] < W && i + dy[k] >= 0 && i + dy[k] < H && qs.find(make_pair(j + dx[k], i + dy[k])) == qs.end() && S[i + dy[k]][j + dx[k]]) {\n\t\t\t\t\t\tq.push(make_pair(make_pair(j + dx[k], i + dy[k]), 0));\n\t\t\t\t\t\tqs.insert(make_pair(j + dx[k], i + dy[k]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\tqs.clear();\n\twhile (!q.empty()) {\n\t\tans = q.front().second;\n\t\tauto current = q.front().first;\n\t\tq.pop();\n\t\tint c = 0;\n\t\trep(k, 8) {\n\t\t\tif (!S[current.second + dy[k]][current.first + dx[k]]) c++;\n\t\t}\n\t\tif (S[current.second][current.first] <= c) {\n\t\t\tqs.insert(current);\n\t\t}\n\t\tif (q.empty()) {\n\t\t\tfor (auto qq : qs) {\n\t\t\t\tS[qq.second][qq.first] = 0;\n\t\t\t}\n\t\t\tfor (auto qq : qs) {\n\t\t\t\trep(k, 8) {\n\t\t\t\t\tif (S[qq.second + dy[k]][qq.first + dx[k]]) q.push(make_pair(make_pair(qq.first + dx[k], qq.second + dy[k]), ans + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tqs.clear();\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n\tEACH(x,vec) is >> x;\n\treturn is;\n}\n/*\ntemplate<class... T>\nostream& operator<<(ostream& os, tuple<T...>& t) {\n\tfor (size_t i = 0; i < tuple_size< tuple<T...> >::value; ++i) {\n\t\tif (i) os << \" \";\n\t\tos << get<0>(t);\n\t}\n\treturn os;\n}\n*/\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << \" \";\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << endl;\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\n\nconst int dx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int dy[] = {-1, -1, 0, 1, 1, 1, 0, -1};\nbool inRange(int x, int y, int w, int h) {\n\treturn 0 <= x && x < w && 0 <= y && y < h;\n}\nint H, W;\nvoid update(vector< vector<int> >& m, queue<P>& q, int x, int y) {\n\tassert( m[y][x] == 0 );\n\tREP(i, 8) {\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\t\tif (inRange(nx, ny, W, H) && m[ny][nx] > 0) {\n\t\t\tif ( --m[ny][nx] == 0 ) {\n\t\t\t\tq.push(P(nx, ny));\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tcin >> H >> W;\n\tvector< vector<int> > m(H, vector<int>(W, 0));\n\tREP(y, H) {\n\t\tstring s; cin >> s;\n\t\tREP(x, W) {\n\t\t\tif (isdigit(s[x])) {\n\t\t\t\tm[y][x] = s[x]-'0';\n\t\t\t}\n\t\t\telse {\n\t\t\t\tm[y][x] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tint ans = -1;\n\tqueue<P> Q;\n\tREP(y, H) {\n\t\tREP(x, W) {\n\t\t\tif (m[y][x] == 0) {\n\t\t\t\tQ.push(P(x, y));\n\t\t\t}\n\t\t}\n\t}\n\twhile (1) {\n\t\tif ( Q.empty() ) break;\n\t\tqueue<P> q;\n\t\twhile ( !Q.empty() ) {\n\t\t\tP p = Q.front(); Q.pop();\n\t\t\tint x = p.first, y = p.second;\n\t\t\tupdate(m, q, x, y);\n//\t\t\tcout << x << \" \" << y << endl;\n\t\t}\n//\t\tcout << endl;\n\t\tQ = q;\n\t\t++ans;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nstruct log{\n\tint x,y;\n};\nqueue <log> cls;\nqueue <log> q;\nlog g;\nlong h,w,ans=0,length;\nchar sand[1004][1004];\nint main(){\n\tcin>>h>>w;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int o=0;o<w;o++){\n\t\t\tcin>>sand[i][o];\n\t\t\tif(sand[i][o]!='.'&&sand[i][o]!='9'){\n\t\t\t\tg.y=i;\n\t\t\t\tg.x=o;\n\t\t\t\tq.push(g);\n\t\t\t}\n\t\t}\n\t}\n\tint f,c,d,fx,fy,my[]={0,1,1,1,0,-1,-1,-1},mx[]={1,1,0,-1,-1,-1,0,1};\n\tdo{\n\t\tf=0;\n\t\twhile(!cls.empty()){\n\t\t\tg=cls.front();\n\t\t\tcls.pop();\n\t\t\tsand[g.y][g.x]='.';\n\t\t}\n\t\t/*for(int i=0;i<h;i++){\n\t\t\tfor(int yu=0;yu<w;yu++){\n\t\t\t\tcout<<sand[i][yu];\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}*/\n\t\tlength=q.size();\n\t\tfor(int i=0;i<length;i++){\n\t\t\tg=q.front();\n\t\t\tq.pop();\n\t\t\tc=0;\n\t\t\td=0;\n\t\t\tfor(int r=0;r<8;r++){\n\t\t\t\tfx=g.x+mx[r];\n\t\t\t\tfy=g.y+my[r];\n\t\t\t\tif(fx>=0&&fx<w&&fy>=0&&fy<h&&sand[fy][fx]=='.'){\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t\telse if(fx>=0&&fx<w&&fy>=0&&fy<h&&sand[fy][fx]=='9'||sand[fy][fx]=='8'){\n\t\t\t\t\td++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(c>=sand[g.y][g.x]-48){\n\t\t\t\tcls.push(g);\n\t\t\t\t//cout<<sand[g.y][g.x]<<endl;\n\t\t\t\tf=1;\n\t\t\t}\n\t\t\telse if(c-d<sand[g.y][g.x]-48){\n\t\t\t\tq.push(g);\n\t\t\t}\n\t\t}\n\t\tif(f==1){\n\t\t\tans++;\n\t\t}\n\t}while(!cls.empty());\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "//q5.cpp\n\n#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\ntypedef long long ll;\n\nusing namespace std;\n\nlong long h,w,ans,flag=0;\nchar m[1020][1020];\nint md[1020][1020];\nbool mc[1020][1020];\nqueue<pair<int,int> > s,s1,che;\npair<int,int> p;\n\nint check(int y,int x){\n    int c=0;\n    \n    for(int i=-1;i<=1;i++)\n        for(int j=-1;j<=1;j++)\n            if(m[y+i][x+j]=='.') c++;\n    \n    if((int)(m[y][x]-'0')<=c &&  !mc[y][x]){\n        mc[y][x]=true;\n        che.push(make_pair(y,x));\n        s1.push(make_pair(y,x));\n        return 1;\n    }\n    \n    return 0;\n}\n\nint main(){\n    scanf(\"%lld%lld\",&h,&w);\n    \n    for(int i=0;i<h;i++)\n        scanf(\"%s\",m[i]);\n    \n    for(int i=0;i<h;i++)\n        for(int j=0;j<w;j++)\n            if(m[i][j]=='.')\n                md[i][j]=0;\n            else\n                md[i][j]=m[i][j]-'0';\n    \n    \n    //1\n    flag=0;\n    \n    for(int i=1;i<h-1;i++)\n        for(int j=1;j<w-1;j++)\n            if(m[i][j]!='.') flag+=check(i,j);\n    \n    while(!che.empty()){\n        p=che.front();\n        che.pop();\n        m[p.first][p.second]='.';\n    }\n    \n    \n    if(flag)\n        ans++;\n    else{\n        puts(\"0\");\n        return 0;\n    }\n    \n    //2-\n    do{\n        s=s1;\n        \n        while(!s1.empty())\n            s1.pop();\n        \n        flag=0;\n        \n        for(int i=0;!s.empty();i++){\n            p=s.front();\n            s.pop();\n            \n            for(int j=-1;j<=1;j++)\n                for(int k=-1;k<=1;k++)\n                    if(m[p.first+j][p.second+k]!='.' && !mc[p.first+j][p.second+k]) flag+=check(p.first+j,p.second+k);\n            \n        }\n        \n        while(!che.empty()){\n            p=che.front();\n            che.pop();\n            m[p.first][p.second]='.';\n        }\n        \n        if(flag) ans++;\n        \n        \n    }while(flag);\n    \n    printf(\"%lld\\n\",ans);\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint H, W; char s[1009][1009];\nint main() {\n\tscanf(\"%d%d\", &H, &W);\n\tfor (int i = 0; i < H; i++) scanf(\"%s\", s[i]);\n\tvector<pair<int, int> > v;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (s[i][j] == '.' || s[i][j] == '9') continue;\n\t\t\tint cnt = 0;\n\t\t\tfor (int k = -1; k <= 1; k++) {\n\t\t\t\tfor (int l = -1; l <= 1; l++) {\n\t\t\t\t\tint tx = j + l, ty = i + k;\n\t\t\t\t\tif (0 <= tx && tx < W && 0 <= ty && ty < H && s[ty][tx] == '.') cnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (cnt >= s[i][j] - 48) v.push_back(make_pair(j, i));\n\t\t}\n\t}\n\tint ret = 0;\n\tfor (; !v.empty(); ret++) {\n\t\tfor (pair<int, int> i : v) s[i.second][i.first] = '.';\n\t\tvector<pair<int, int> > w;\n\t\tfor (pair<int, int> i : v) {\n\t\t\tint sx = i.first, sy = i.second;\n\t\t\tfor (int j = -1; j <= 1; j++) {\n\t\t\t\tfor (int k = -1; k <= 1; k++) {\n\t\t\t\t\tint tx = sx + k, ty = sy + j;\n\t\t\t\t\tif (!(0 <= tx && tx < W && 0 <= ty && ty < H)) continue;\n\t\t\t\t\tif (s[ty][tx] == '.' || s[ty][tx] == '9') continue;\n\t\t\t\t\tint cnt = 0;\n\t\t\t\t\tfor (int l = -1; l <= 1; l++) {\n\t\t\t\t\t\tfor (int m = -1; m <= 1; m++) {\n\t\t\t\t\t\t\tint ux = tx + m, uy = ty + l;\n\t\t\t\t\t\t\tif (0 <= ux && ux < W && 0 <= uy && uy < H && s[uy][ux] == '.') cnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (cnt >= s[ty][tx] - 48) w.push_back(make_pair(tx, ty));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(w.begin(), w.end());\n\t\tw.resize(unique(w.begin(), w.end()) - w.begin());\n\t\tv = w;\n\t}\n\tprintf(\"%d\\n\", ret);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1<<30;\nint n,m;\nvector<string>in,tmp;\nint dx[]={1,1,1,0,0,-1,-1,-1};\nint dy[]={1,0,-1,1,-1,1,0,-1};\nbool f(int a,int b){\n\tint c=in[a][b]-'0';\n\tint co=0;\n\trep(i,8){\n\t\tint x=a+dx[i];\n\t\tint y=b+dy[i];\n\t\tif(in[x][y]=='.')co++;\n\t}\n\tif(co>=c){\n\t\ttmp[a][b]='.';\n\t\treturn true;\n\t}\n\treturn false;\n}\nbool F(){\n\ttmp=in;\n\tbool h=false;\n\trep(i,n)rep(j,m)if(in[i][j]!='.'&&f(i,j))h=true;\n\tin=tmp;\n\treturn h;\n}\nint main(){\n\tcin>>n>>m;\n\tin=vector<string>(n);\n\trep(i,n)cin>>in[i];\n\tint co=0;\n\twhile(F())co++;\n\tcout<<co<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mp make_pair\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;//cnt, coodinate\nstring grid[1111];\nint neiber[1111][1111];\nint dx[] = {0, 1, 1,  1,  0, -1, -1, -1};\nint dy[] = {1, 1, 0, -1, -1, -1,  0,  1};\nint w, h;\nbool renge(int x, int y){\n  if(0 <= x && x < w &&\n     0 <= y && y < h)return true;\n  return false;\n}\nbool del(int x, int y){\n  int cnt = 0;\n  if(renge(x, y) == false || \n     grid[y][x] == '.') return false;\n  for (int i = 0; i < 8; i++) {\n    int nx = x + dx[i], ny = y + dy[i];\n    if(renge(nx, ny) == false)continue;\n    if(grid[ny][nx] == '.')cnt++;\n  }\n  char tmp = grid[y][x];\n  neiber[y][x] = cnt;\n  if(cnt >= atoi(&tmp))return true;\n  else return false;\n}\n \nint main(int argc, char *argv[]){\n  queue<piii> que;\n  queue<pii> p;\n  cin >> h >> w;\n  for (int i = 0; i < h; i++) {\n    cin >> grid[i];\n  }\n  for (int i = 0; i < h; i++) {\n    for (int j = 0; j < w; j++) {\n      if(del(j, i)){\n        p.push(mp(j, i));\n        que.push(mp(1, mp(j, i)));\n      }\n    }\n  }\n  int ans = 0;\n  while(!que.empty()){\n    int cnt = que.front().first;\n    if(ans != cnt){\n      while(!p.empty()){\n        int x = p.front().first;\n        int y = p.front().second;\n        p.pop();\n        for (int i = 0; i < 8; i++) {\n          int nx = x + dx[i], ny = y + dy[i];\n          if(!renge(nx, ny))continue;\n          neiber[ny][nx]++;\n        }\n      }\n    }\n    int x = que.front().second.first;\n    int y = que.front().second.second;\n    que.pop();\n    ans = cnt;\n    for (int i = 0; i < 8; i++) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if(renge(nx, ny) == false ||\n         grid[ny][nx] == '.')continue;\n      char tmp = grid[ny][nx];\n      if(neiber[ny][nx] >= atoi(&tmp)){\n        grid[y][x] = '.';\n        p.push(mp(nx, ny));\n        que.push(mp(cnt + 1, mp(nx, ny)));\n      }\n    }\n  }\n  std::cout << ans << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<n;i++)\n#define ARR(i,j) for(int i=-1;i<=1;i++)for(int j=-1;j<=1;j++)if(i!=0||j!=0)\ntypedef pair<int,int> P;\n\nint h,w;\nchar a[1002][1002];\nint kd[1002][1002];\nint sr[1002][1002];\nqueue<P> now;\nqueue<P> nxt;\n\nint main(){\n  cin>>h>>w;\n  REP(i,h)REP(j,w)cin>>a[i][j];\n  REP(i,h)REP(j,w){\n    if(i<=0||h-1<=i||j<=0||w-1<=j)continue;\n    if(a[i][j]!='.'){\n      kd[i][j]=a[i][j]-'0';\n      ARR(dx,dy)if(a[i+dx][j+dy]=='.')sr[i][j]++;\n      if(sr[i][j]>=kd[i][j])nxt.push(P(i,j));\n    }\n  }\n  int res=0;\n  while(!nxt.empty()){\n    res++;\n    swap(now,nxt);\n    while(!now.empty()){\n      P p=now.front();now.pop();\n      if(a[p.first][p.second]=='.')continue;\n      a[p.first][p.second]='.';\n      ARR(dx,dy){\n        int qx=p.first+dx;\n        int qy=p.second+dy;\n        sr[qx][qy]++;\n        if(a[qx][qy]!='.'&&sr[qx][qy]>=kd[qx][qy])nxt.push(P(qx,qy));\n      }\n    }\n  }\n  cout<<res<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n\nusing ll=long long;\nusing ld=long double;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int, int>;\nusing vpii=vector<pii>;\n\ntemplate<class T,class U>ostream&operator<<(ostream&os,const pair<T,U>p){os<<\"(\"<<p.fst<<\", \"<<p.scd<<\")\";return os;}\ntemplate<class T>ostream&operator<<(ostream&os,const vector<T>v){rep(i,v.size()){if(i)os<<\", \";os<<v[i];}return os;}\ntemplate<typename T>T&max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T&min(T&a,T&b){if(a < b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a < b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a > b){a=b;return true;}return false;}\n\nconstexpr int inf = 1e9;\nconstexpr ll linf = 3e18;\nconstexpr double eps = 1e-9;\n\nint dy[8] = {-1, -1, -1, 0, 0, 1, 1, 1};\nint dx[8] = {-1, 0, 1, -1, 1, -1, 0, 1};\n\nint H, W;\nint c[1005][1005];\nint cnt[1005][1005];\n\nbool inside(int y, int x)\n{\n    return (0 <= y && y < H && 0 <= x && x < W);\n}\n\nint main()\n{\n    cin >> H >> W;\n\n    rep(i, H) {\n        rep(j, W) {\n            char tmp; cin >> tmp;\n\n            if (tmp == '.') {\n                c[i][j] = 0;\n            } else {\n                c[i][j] = tmp - '0';\n            }\n        }\n    }\n\n    queue<pii> q;\n\n    rep(i, H) {\n        rep(j, W) {\n            if (c[i][j] == 0) continue;\n\n            rep(k, 8) {\n                int ny = i + dy[k], nx = j + dx[k];\n                if (!inside(ny, nx)) continue;\n\n                if (c[ny][nx] == 0) {\n                    cnt[i][j]++;\n                }\n            }\n\n            if (cnt[i][j] >= c[i][j]) {\n                q.push(pii(i, j));\n            }\n        }\n    }\n\n    if (q.empty()) {\n        cout << 0 << endl;\n        return 0;\n    }\n\n    int ans = 1;\n\n    while (q.size()) {\n        queue<pii> qq;\n        while (q.size()) {\n            pii p = q.front(); q.pop();\n\n            rep(i, 8) {\n                int ny = p.fst + dy[i], nx = p.scd + dx[i];\n\n                if (!inside(ny, nx)) continue;\n\n                if (cnt[ny][nx] >= c[ny][nx]) continue;\n\n                cnt[ny][nx]++;\n\n                if (cnt[ny][nx] >= c[ny][nx]) {\n                    qq.push(pii(ny, nx));\n                }\n            }\n        }\n\n        if (qq.size()) {\n            while (qq.size()) {\n                q.push(qq.front());\n                qq.pop();\n            }\n\n            ans++;\n        } else {\n            break;\n        }\n    }\n\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\n#define INF 1000000000\n\nusing namespace std;\n\nconst vector<int> dx = { 0, 1, 1, 1, 0, -1, -1, -1 };\nconst vector<int> dy = { -1, -1, 0, 1, 1, 1, 0, -1 };\n\nint H, W; vector<string> M;\n\nvector<vector<int> > state;\n\nint check(int x, int y, int s)\n{\n\tint ret = 0;\n\n\tfor (int dir = 0; dir < 8; dir++)\n\t{\n\t\tif (state[y + dy[dir]][x + dx[dir]] < s || M[y + dy[dir]][x + dx[dir]] == '.')\n\t\t{\n\t\t\tret++;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint main()\n{\n\tscanf(\"%d\", &H);\n\tscanf(\"%d\", &W);\n\n\tM = vector<string>(H);\n\n\tfor (int i = 0; i < H; i++) cin >> M[i];\n\n\tstate = vector<vector<int> >(H, vector<int>(W, INF));\n\n\tqueue<pair<int, int> > que;\n\n\tfor (int i = 1; i < H - 1; i++)\n\t{\n\t\tfor (int j = 1; j < W - 1; j++)\n\t\t{\n\t\t\tif (check(j, i, 1) >= M[i][j] - 48 && M[i][j] != '.')\n\t\t\t{\n\t\t\t\tque.push(make_pair(j, i)); state[i][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\twhile (!que.empty())\n\t{\n\t\tint x = que.front().first;\n\t\tint y = que.front().second; que.pop();\n\n\t\tfor (int dir = 0; dir < 8; dir++)\n\t\t{\n\t\t\tint x2 = x + dx[dir];\n\t\t\tint y2 = y + dy[dir];\n\n\t\t\tif (state[y2][x2] == INF && M[y2][x2] != '.' && check(x2, y2, state[y][x] + 1) >= M[y2][x2] - 48)\n\t\t\t{\n\t\t\t\tstate[y2][x2] = state[y][x] + 1;\n\n\t\t\t\tque.push(make_pair(x2, y2));\n\t\t\t}\n\t\t}\n\t}\n\n\tint ret = 0;\n\n\tfor (int i = 1; i < H - 1; i++)\n\t{\n\t\tfor (int j = 1; j < W - 1; j++)\n\t\t{\n\t\t\tif (state[i][j] != INF)\n\t\t\t{\n\t\t\t\tret = max(ret, state[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint H, W; vector<string> s;\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> H >> W; s.resize(H);\n\tfor (int i = 0; i < H; i++) cin >> s[i];\n\tvector<pair<int, int> > v;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (s[i][j] == '.' || s[i][j] == '9') continue;\n\t\t\tint cnt = 0;\n\t\t\tfor (int k = -1; k <= 1; k++) {\n\t\t\t\tfor (int l = -1; l <= 1; l++) {\n\t\t\t\t\tint tx = j + l, ty = i + k;\n\t\t\t\t\tif (0 <= tx && tx < W && 0 <= ty && ty < H && s[ty][tx] == '.') cnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (cnt >= s[i][j] - 48) v.push_back(make_pair(j, i));\n\t\t}\n\t}\n\tint ret = 0;\n\tfor (; !v.empty(); ret++) {\n\t\tfor (pair<int, int> i : v) s[i.second][i.first] = '.';\n\t\tvector<pair<int, int> > w;\n\t\tfor (pair<int, int> i : v) {\n\t\t\tint sx = i.first, sy = i.second;\n\t\t\tfor (int j = -1; j <= 1; j++) {\n\t\t\t\tfor (int k = -1; k <= 1; k++) {\n\t\t\t\t\tint tx = sx + k, ty = sy + j;\n\t\t\t\t\tif (!(0 <= tx && tx < W && 0 <= ty && ty < H)) continue;\n\t\t\t\t\tif (s[ty][tx] == '.' || s[ty][tx] == '9') continue;\n\t\t\t\t\tint cnt = 0;\n\t\t\t\t\tfor (int l = -1; l <= 1; l++) {\n\t\t\t\t\t\tfor (int m = -1; m <= 1; m++) {\n\t\t\t\t\t\t\tint ux = tx + m, uy = ty + l;\n\t\t\t\t\t\t\tif (0 <= ux && ux < W && 0 <= uy && uy < H && s[uy][ux] == '.') cnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (cnt >= s[ty][tx] - 48) w.push_back(make_pair(tx, ty));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(w.begin(), w.end());\n\t\tw.resize(unique(w.begin(), w.end()) - w.begin());\n\t\tv = w;\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\nint x, y;\nchar map[1024][1024];\nqueue< pair<int, int> > q;\n\nbool check_map(void){\n\tbool flag = true;\n\tint dx[8] = { 0, 0, 1, -1, 1, -1, 1, -1 }, dy[8] = { 1, -1, 0, 0, 1, -1, -1, 1 };\n\tfor (int i = 0; i < y; i++){\n\t\tfor (int i2 = 0; i2 < x; i2++){\n\t\t\tint cnt = 0;\n\t\t\tif (map[i][i2] != '.'){\n\t\t\t\tfor (int i3 = 0; i3 < 8; i3++){\n\t\t\t\t\tif (map[i + dy[i3]][i2 + dx[i3]] == '.'){\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tchar temp = map[i][i2];\n\t\t\t\tif (cnt >= atoi(&temp)){\n\t\t\t\t\tq.push(make_pair(i, i2));\n\t\t\t\t\tflag = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn flag;\n}\n\nint main(){\n\tint cnt = 0;\n\tcin >> y >> x;\n\n\tfor (int i = 0; i < y; i++){\n\t\tfor (int i2 = 0; i2 < x; i2++){\n\t\t\tcin >> map[i][i2];\n\t\t}\n\t}\n\n\twhile (!check_map()){\n\t\twhile (!q.empty()){\n\t\t\tpair<int, int> temp = q.front();\n\t\t\tq.pop();\n\t\t\tmap[temp.first][temp.second] = '.';\n\t\t}\n\t\tcnt++;\n\t}\n\n\tcout << cnt << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <string>\nusing namespace std;\n\nstruct p{\n  int co,x,y;\n  p(int a,int b,int c){\n    co=a;\n    x=b;\n    y=c;\n  }\n};\nint a[1000][1000],b[1000][1000];\nint main (){\n  int h,w;\n  queue<p> Q; \n  string s;\n  cin >>h>>w;\n  for(int i=0;i<h;i++){\n    cin >>s;\n    for(int j=0;j<w;j++){\n      if(s[j] == '.'){\n\ta[i][j] = -1;\n\tQ.push(p(0,j,i));\n      } else a[i][j] = s[j]-'0';\n      b[i][j] = 0;\n    }\n  }\n  int res = 0;\n  while( !Q.empty() ){\n    p np = Q.front();\n    Q.pop();\n    res = np.co;\n    for(int i=-1;i<=1;i++)\n      for(int j=-1;j<=1;j++){\n\tif(i==0 && j==0) continue;\n\tint nx = np.x+i;\n\tint ny = np.y+j;\n\tif(0>=nx || nx>w-1 || 0>=ny || ny>h-1) continue;\n\tb[nx][ny]++;\n\tif(a[nx][ny] == b[nx][ny]) Q.push(p(np.co+1,nx,ny));\n      }\n  }\n  cout << res<<endl;\n  return 0;\n}\n    "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef pair<int, int> pii;\n\nint di[] = {-1, -1, -1, 0, 0, 1, 1, 1};\nint dj[] = {-1, 0, 1, -1, 1, -1, 0, 1};\nint cnt[1010][1010];\n\nint main(void) {\n  int h, w;\n  cin >> h >> w;\n\n  vector<string> s(h);\n  for (int i = 0; i < h; i++) {\n    cin >> s[i];\n  }\n\n  queue<pii> que[2];\n  for (int i = 1; i < h - 1; i++) {\n    for (int j = 1; j < w - 1; j++) {\n      for (int k = 0; k < 8; k++) {\n        int ni = i + di[k], nj = j + dj[k];\n        if (s[ni][nj] != '.') continue;\n        cnt[i][j]++;\n      }\n      if (s[i][j] == '.') continue;\n      if (cnt[i][j] < s[i][j] - '0') continue;\n      que[0].push(pii(i, j));\n    }\n  }\n\n  int ans = 0;\n  bool turn = false;\n  while (!que[turn].empty()) {\n    while (!que[turn].empty()) {\n      pii v = que[turn].front();\n      que[turn].pop();\n      int i = v.first, j = v.second;\n      for (int k = 0; k < 8; k++) {\n        int ni = i + di[k], nj = j + dj[k];\n        cnt[ni][nj]++;\n        if (s[ni][nj] == '.') continue;\n        if (cnt[ni][nj] == s[ni][nj] - '0') {\n          que[!turn].push(pii(ni, nj));\n        }\n      }\n    }\n    ans++;\n    turn = !turn;\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define f first\n#define s second\n#define mk make_pair\nusing namespace std;\ntypedef pair<int,int> P;\nint h,w,ans=0;\nint dx[]={-1,-1,-1,0,0,1,1,1};\nint dy[]={1,0,-1,1,-1,1,0,-1};\nstring s[1001];\nmain(){\n\tcin>>h>>w;\n\tr(i,h)cin>>s[i];\n\tqueue<pair<pair<int,int>,int>>q;\n\tr(i,h)r(j,w)if(isdigit(s[i][j])){\n\t\tint sum=0;\n\t\tr(k,8){\n\t\t\tint y=i+dy[k];\n\t\t\tint x=j+dx[k];\n\t\t\tif(y<0||x<0||x>=w||y>=h)continue;\n\t\t\tif(s[y][x]=='.')sum++;\n\t\t}\n\t\tif(s[i][j]-'0'<=sum)q.push(mk(mk(i,j),1));\n\t}\n\twhile(!q.empty()){\n\t\tvector<P>v;\n\t\twhile(!q.empty()){\n\t\t\tpair<pair<int,int>,int>p=q.front();q.pop();\n\t\t\tans=p.s;\n\t\t\ts[p.f.f][p.f.s]='.';\n\t\t\tv.push_back(P(p.f.f,p.f.s));\n\t\t}\n\t\tr(i,v.size())r(j,8){\n\t\t\tint y=v[i].f+dy[j];\n\t\t\tint x=v[i].s+dx[j];\n\t\t\tif(0<=y&&y<h&&0<=x&&x<w&&isdigit(s[y][x])){\n\t\t\t\tint sum=0;\n\t\t\t\tr(k,8){\n\t\t\t\t  int yy=y+dy[k];\n\t\t\t      int xx=x+dx[k];\n\t\t\t      if(yy<0||xx<0||xx>=w||yy>=h)continue;\n\t\t\t      if(s[yy][xx]=='.')sum++;\n\t\t\t    }\n\t\t\t    if(s[y][x]-'0'<=sum)q.push(mk(mk(y,x),ans+1));\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#include <queue>\n\nstruct QUE{\n\tint y;\n\tint x;\n\tint count;\n\tQUE(int a, int b, int c) { y = a,x = b,count = c; }\n};\n\nint map[1024][1024] = { 0 };\nint y_move[] = { -1, -1, -1, 0, 0, +1, +1, +1 }, x_move[] = { -1, 0, +1, -1, +1, -1, 0, +1 };\nbool search(int y, int x);\n\nint main(void){\n\n\tint h, w;\n\tcin >> h >> w;\n\n\tfor (int i = 1; i <= h; i++){\n\t\tfor (int i2 = 1; i2 <= w; i2++){\n\t\t\tchar str;\n\t\t\tcin >> str;\n\t\t\tif (str == '.')map[i][i2] = 0;\n\t\t\telse map[i][i2] = str - '0';\n\t\t}\n\t}\n\n\tint count = 1;\n\tqueue<QUE> q,q2;\n\tQUE que=QUE(0,0,0);\n\tfor (int i = 1; i <= h; i++){\n\t\tfor (int i2 = 1; i2 <= w; i2++){\n\t\t\tif (map[i][i2] > 0){\n\t\t\t\tif (search(i, i2)){ q.push(QUE(i,i2,1)); }\n\t\t\t}\n\t\t}\n\t}\n\twhile (!q.empty()){\n\t\tque.y = q.front().y, que.x = q.front().x; que.count = q.front().count;\n\t\tmap[que.y][que.x] = 0;\n\t\tfor (int k = 0; k < 8; k++){\n\t\t\tif (map[que.y + y_move[k]][que.x + x_move[k]] > 0){\n\t\t\t\tif (search(que.y + y_move[k], que.x + x_move[k])) { q.push(QUE(que.y + y_move[k], que.x + x_move[k], que.count + 1)); }\n\t\t\t}\n\t\t}q.pop();\n\t}\n\n\tcout << que.count << endl;\n}\n\nbool search(int y,int x){\n\n\tint count = 0;\n\tfor (int k = 0; k < 8; k++){\n\t\tif (map[y + y_move[k]][x + x_move[k]] == 0){ count++; }\n\t\tif (map[y][x] <= count) { return true; }\n\t}\n\n\treturn false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <stdio.h>\n#include <cstdlib>\n#include <string>\n#include <tuple>\n#include <vector>\n#include <map>\n#include <list>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <math.h>\n#include <random>\n#include <time.h>\n#include <cassert>\nusing namespace std;\n#define LL long long\n#undef INT_MIN\n#undef INT_MAX\n#define INT_MIN -2147483648\n#define INT_MAX 2147483647\n#define LL_MIN -9223372036854775808\n#define LL_MAX 9223372036854775807\n\nint field[1000][1000];\n\nint check(int I, int J) {\n\tif (field[I][J] == 0) return false;\n\tint c = 0;\n\tfor (int i = I - 1; i <= I + 1; i++) {\n\t\tfor (int j = J - 1; j <= J + 1; j++) {\n\t\t\tif (field[i][j] == 0) c++;\n\t\t}\n\t}\n\tif (c >= field[I][J]) return true;\n\telse return false;\n}\n\nint main() {\n\tint H, W;\n\tcin >> H >> W;\n\t\n\tfor (int i = 0; i < H; i++) {\n\t\tstring tmp;\n\t\tcin >> tmp;\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (tmp[j] == '.') field[i][j] = 0;\n\t\t\telse field[i][j] = tmp[j] - '0';\n\t\t}\n\t}\n\n\tset<pair<int, int> > changed;\n\tfor (int i = 1; i < H-1; i++) {\n\t\tfor (int j = 1; j < W-1; j++) {\n\t\t\tif (check(i, j)) {\n\t\t\t\tchanged.insert(make_pair(i, j));\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\twhile (true) {\n\t\t\n\t\tif (changed.size() == 0) break;\n\t\tvector<pair<int, int>> changed2;\n\t\tfor (auto itr = changed.begin(); itr != changed.end(); itr++) {\n\t\t\tfield[(*itr).first][(*itr).second] = 0;\n\t\t\tchanged2.push_back(make_pair((*itr).first, (*itr).second));\n\t\t}\n\t\tchanged.clear();\n\n\t\tfor (auto itr = changed2.begin(); itr != changed2.end(); itr++) {\n\t\t\tfor (int i = (*itr).first - 1; i <= (*itr).first + 1; i++) {\n\t\t\t\tfor (int j = (*itr).second - 1; j <= (*itr).second + 1; j++) {\n\t\t\t\t\tif (check(i, j)) {\n\t\t\t\t\t\tchanged.insert(make_pair(i, j));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tans++;\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<queue>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int, int>P;\ntypedef long long ll;\n\nint h, w;\nchar ca[1000][1001];\nqueue<P>que1;\nqueue<P>que2;\n\nint cnt(int a, int b){\n\tint res = 0;\n\tfor (int i = -1; i <= 1; i++){\n\t\tfor (int j = -1; j <= 1; j++){\n\t\t\tif (ca[a + i][b + j] == '.')\n\t\t\t\tres++;\n\t\t}\n\t}\n\treturn res;\n}\nvoid wave(){\n\twhile (!que1.empty()){\n\t\tP p = que1.front(); que1.pop();\n\t\tint f = p.first, s = p.second;\n\t\tfor (int i = -1; i <= 1; i++){\n\t\t\tfor (int j = -1; j <= 1; j++){\n\t\t\t\tif ('1' <= ca[f + i][s + j] && ca[f + i][s + j] - '0' <= cnt(f + i, s + j))\n\t\t\t\t\tque2.push(P(f + i, s + j));\n\t\t\t}\n\t\t}\n\t}\n\tswap(que1, que2);\n}\nint main(){\n\tscanf(\"%d%d\", &h, &w);\n\trep(i, h)\n\t\tscanf(\"%s\", ca[i]);\n\trep(i, h){\n\t\trep(j, w){\n\t\t\tif ('1' <= ca[i][j] && ca[i][j] - '0' <= cnt(i, j))\n\t\t\t\tque1.push(P(i, j));\n\t\t}\n\t}\n\tint cnt = 0;\n\twhile (!que1.empty()){\n\t\twave();\n\t\trep(i, que1.size()){\n\t\t\tP p = que1.front(); que1.pop();\n\t\t\tca[p.first][p.second] = '.';\n\t\t\tque1.push(p);\n\t\t}\n\t\tcnt++;\n\t}\n\tprintf(\"%d\\n\", cnt - 1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\nusing namespace std;\n\nint main()\n{\n  int h,w;\n  scanf(\"%d%d\",&h,&w);\n  static char M[1000][1001];\n  for(int i=0;i<h;i++){\n    scanf(\"%s\",M[i]);\n  }\n  static int K[1000][1001]={0};\n  int dx[8]={1,1,1,0,0,-1,-1,-1},dy[8]={-1,0,1,-1,1,-1,0,1};\n  queue<pair<int,int> > Q[2];\n  bool b=0;\n  for(int i=1;i<h-1;i++){\n    for(int j=1;j<w-1;j++){\n      for(int v=0;v<8;v++){\n\tint x=i+dx[v],y=j+dy[v];\n\tif(M[x][y]=='.'){\n\t  K[i][j]++;\n\t}\n      }\n      if(M[i][j]!='.'&&K[i][j]>=M[i][j]-'0'){\n\tQ[b].push(make_pair(i,j));\n      }\n    }\n  }\n  int t=0;\n  while(!Q[b].empty()){\n    while(!Q[b].empty()){\n      pair<int,int> p=Q[b].front();\n      Q[b].pop();\n      int i=p.first,j=p.second;\n      for(int v=0;v<8;v++){\n\tint x=i+dx[v],y=j+dy[v];\n\tK[x][y]++;\n\tif(M[x][y]!='.'&&K[x][y]==M[x][y]-'0'){\n\t  Q[!b].push(make_pair(x,y));\n\t}\n      }\n    }\n    t++;\n    b=!b;\n  }\n  printf(\"%d\\n\",t);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nbool check_destroy(vector<vector<int> >& mp, int h, int w) {\n    int cnt=0;\n    int dh[8]={-1,-1,-1,0,1,1,1,0};\n    int dw[8]={-1,0,1,1,1,0,-1,-1};\n\n    for(int i=0; i<8; ++i) {\n        cnt+=(mp[h+dh[i]][w+dw[i]]==0?1:0);\n    }\n\n    return mp[h][w]<=cnt;\n}\n\nint main()\n{\n    int H,W;\n    cin >> H >> W;\n\n    queue<P> q[2];\n    queue<P> dest[2];\n\n    vector<vector<int> > mp(H);\n    int ans=0;\n\n    for(int i=0; i<H; ++i) mp[i].resize(W);\n\n    for(int i=0; i<H; ++i) {\n        string instr;\n        cin >> instr;\n        for(int j=0; j<W; ++j) {\n            switch(instr[j]) {\n            case '.' :\n                mp[i][j]=0;\n                break;\n            default :\n                mp[i][j]=instr[j]-'0';\n                q[ans%2].push(P(i,j));\n                break;\n            }\n        }\n    }\n\n    while(1) {\n        int QCNT=q[ans%2].size();\n\n        while(!q[ans%2].empty()) {\n            P temp=q[ans%2].front(); q[ans%2].pop();\n            if(check_destroy(mp,temp.first,temp.second)) dest[ans%2].push(temp);\n            else q[(ans+1)%2].push(temp);\n        }\n\n        while(!dest[ans%2].empty()) {\n            P temp=dest[ans%2].front(); dest[ans%2].pop();\n            mp[temp.first][temp.second]=0;\n        }\n\n        if(QCNT==q[(ans+1)%2].size()) break;\n        ++ans;\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint h, w;\nchar t[1001];\nvector<string> v;\nint dx[8] = {0, 1, 1, 1, 0, -1, -1, -1};\nint dy[8] = {-1, -1, 0, 1, 1, 1, 0, -1};\nint ans;\ntypedef pair<int, int> P;\n\nbool solve(){\n/*\n\tprintf(\"\\n\");\n\tfor(int i=0; i<h; i++){\n\t\tprintf(\"%s\\n\", v[i].c_str());\n\t}\n*/\n\tbool d = false;\n\tvector<P> u;\n\tfor(int i=1; i<w+1; i++){\n\t\tfor(int j=1; j<h+1; j++){\n\t\t\tif(v[i][j] != '.'){\n\t\t\t\tint c = 0;\n\t\t\t\tfor(int k=0; k<8; k++){\n\t\t\t\t\tint nx, ny;\n\t\t\t\t\tnx = i + dx[k];\n\t\t\t\t\tny = j + dy[k];\n\t\t\t\t\tif(v[nx][ny] == '.') c++;\n\t\t\t\t}\n\t\t\t\tif(v[i][j] - '0' <= c){\n\t\t\t\t\tu.push_back(P(i, j));\n\t\t\t\t\td = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0; i<u.size(); i++){\n\t\tv[u[i].first][u[i].second] = '.';\n\t}\n\tif(d){\n\t\tans++;\n\t\tsolve();\n\t}\n\treturn true;\n}\n\nint main(){\n\tscanf(\"%d %d\", &h, &w);\n\tfor(int i=0; i<h; i++){\n\t\tscanf(\"%s\", t);\n\t\tv.push_back(t);\n\t}\n\tsolve();\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n\n\n#define max(a,b) ((a) > (b) ? (a) : (b))\n#define min(a,b) ((a) > (b) ? (b) : (a))\nchar st[51][51], sts[51][51];\nint H, W;\n\ninline void copy(char a[51][51], char b[51][51]) {\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\ta[i][j] = b[i][j];\n\t\t}\n\t}\n}\n\ninline bool is_castle(char a) {\n\treturn a != '.';\n}\n\ninline int conv(char a) {\n\treturn a - '0';\n}\n\ninline bool state(int x, int y) {\n\tint c = 0;\n\tfor (int i = max(x - 1, 0); i < min(x + 2, W); i++) {\n\t\tfor (int j = max(y - 1, 0); j < min(y + 2, H); j++) {\n\t\t\tif (st[i][j] == '.')\n\t\t\t\tc++;\n\t\t}\n\t}\n\treturn c >= conv(st[x][y]);\n\n}\n\ninline bool collapse(int x, int y) {\n\tif (is_castle(st[x][y]) && state(x,y)) {\n\t\tsts[x][y] = '.';\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool wave() {\n\tbool e = false;\n\tcopy(sts, st);\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\te = collapse(i, j) ? true : e;\n\t\t}\n\t}\n\tcopy(st, sts);\n\treturn e;\n}\n\nint main(){\n\tscanf(\"%d%d\", &H, &W);\n\tfor (int i = 0; i < H; i++) {\n\t\tscanf(\"%s\", st[i]);\n\t}\n\tfor (int i = 0;;i++) {\n\t\tif (!wave()) {\n\t\t\tprintf(\"%d\\n\", i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <queue>\nusing namespace std;\ntypedef pair<int, int> P;\n \nint h, w, ans;\nint castle[1001][1001], times[1001][1001];\nint dx[] = {-1, 0, 1, -1, 1, -1, 0, 1}, dy[] = {-1, -1, -1, 0, 0, 1, 1, 1};\nchar beach[1001][1001];\n \ninline int input_i(){\n\tint temp;\n\tscanf(\"%d\", &temp);\n\treturn temp;\n}\n\ninline string input_c(){\n\tstring temp;\n\tscanf(\"%s\", temp);\n\treturn temp;\n}\n\n\nint main(){\n    h = input_i();\n    w = input_i();\n    for(int i = 0; i < h; i++){\n        beach[i] = input_s();\n    }\n \n    queue<P> Q;\n    for(int i = 0; i < h; i++){\n        for(int j = 0; j < w; j++){\n            if(beach[i][j] == '.'){\n                Q.push(P(i, j));\n            } else{\n                castle[i][j] = beach[i][j] - '0';\n            }\n        }\n    }\n \n    while(Q.size()){\n        P p = Q.front();\n        Q.pop();\n        ans = max(ans, times[p.first][p.second]);\n \n        for(int i = 0; i < 8; i++){\n            int y = p.first + dy[i], x = p.second + dx[i];\n            if(y < 0 || y >= h || x < 0 || x >= w){\n                continue;\n            }\n \n            castle[y][x]--;\n            if(castle[y][x] == 0){\n                Q.push(P(y, x));\n                times[y][x] = times[p.first][p.second] + 1;\n            }\n        }\n    }\n \n    printf(\"%d\\n\", ans);\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<bits//stdc++.h>\n#include<functional>\nusing namespace std;\nstruct P{\n\tint x,y;\n};\nint main() {\n\tint a[1000][1000];\n\tint h,w;\n\tcin>>h>>w;\n\tfor(int i=0;i<h;i++){\n\t\tstring s;\n\t\tcin>>s;\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(s[j]=='.') a[i][j]=0;\n\t\t\telse a[i][j]=(int)s[j]-'0';\n\t\t}\n\t}\n\tint sum=-1,sum2=1;\n\twhile(sum2){\n\t\tsum2=0;\n\t\tint sum3;\n\t\tvector<P>p;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(a[i][j]){\n\t\t\t\t\tsum3=0;\n\t\t\t\t\tfor(int x=-1;x<=1;x++){\n\t\t\t\t\t\tfor(int y=-1;y<=1;y++){\n\t\t\t\t\t\t\tif(i+x<h&&i+x>=0&&j+y<w&&j+y>=0&&a[i+x][j+y]==0) sum3++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(sum3>=a[i][j]) {\n\t\t\t\t\t\tp.push_back(P{i,j});\n\t\t\t\t\t\tsum2++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<(int)p.size();i++){\n\t\t\ta[p[i].x][p[i].y]=0;\n\t\t}\n\t\tsum++;\n\t}\n\tcout<<sum<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <utility>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n\n#define INF_LL 9000000000000000000\n#define INF 2000000000\n\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int i = (a);i < (b);i++)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> PPII;\ntypedef pair<int, PPII> PPPII;\n\nclass Union_find{\nprivate:\n\tvector<int> par;\n\tvector<int> rank;\n\tint n;\n\npublic:\n\tUnion_find(int a){\n\t\tn = a;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tpar.push_back(i);\n\t\t\trank.push_back(0);\n\t\t}\n\t}\n\n\tint find(int x){\n\t\tif(par[x] == x){\n\t\t\treturn x;\n\t\t}else{\n\t\t\treturn par[x] = find(par[x]);\n\t\t}\n\t}\n\n\tvoid unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return;\n\n\t\tif(rank[x] < rank[y]){\n\t\t\tpar[x] = y;\n\t\t}else{\n\t\t\tpar[y] = x;\n\t\t\tif(rank[x] == rank[y]) rank[x]++;\n\t\t}\n\t}\n\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n};\n\nint dx[3] = {-1, 1, 0};\n\nint main(void){\n\tint h, w;\n\tstring sand[1010][2];\n\tcin >> h >> w;\n\tREP(i, h){\n\t\tcin >> sand[i][0];\n\t}\n\tint cnt = 1;\n\tint res = 0;\n\twhile(cnt != 0){\n\t\tcnt = 0;\n\t\tFOR(i, 1, h-1){\n\t\t\tFOR(j, 1, w-1){\n\t\t\t\tint sarati = 0;\n\t\t\t\tREP(x, 3){\n\t\t\t\t\tREP(y, 3){\n\t\t\t\t\t\tif(x == 2 && y == 2) continue;\n\t\t\t\t\t\tif(sand[i+dx[x]][res%2][j+dx[y]] == '.') sarati++;\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(sand[i][res%2][j] != '.' && sarati >= sand[i][res%2][j]-'0'){\n\t\t\t\t\tsand[i][(res+1)%2][j] = '.';\n\t\t\t\t\tcnt++;\n\t\t\t\t}else{\n\t\t\t\t\tsand[i][(res+1)%2][j] = sand[i][res%2][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(cnt > 0) res++;\n\t}\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {+0,+1,+1,+1,+0,-1,-1,-1};\nstatic const int ty[] = {-1,-1,+0,+1,+1,+1,+0,-1};\n\nchar stage[1001][1001];\nint cost[1001][1001];\nint H,W;\n\nclass State {\npublic:\n  int x;\n  int y;\n  int cost;\n\n  State(int x, int y, int cost){\n    this->x = x;\n    this->y = y;\n    this->cost = cost;\n  }\n\n  bool operator<(State s) const {\n    return cost < s.cost;\n  }\n\n  bool operator>(State s) const {\n    return cost > s.cost;\n  }\n};\n\nbool is_new_vacant_lot(int x, int y,int current_cost){\n  if(stage[y][x] == '.') return false;\n\n  int count = 0;\n  int strongness = stage[y][x] - '0';\n\n  for(int i = 0; i < 8; i++){\n    int dx = x + tx[i];\n    int dy = y + ty[i];\n    if(dx < 0 || dx >= W || dy < 0 || dy >= H) continue;\n    if(stage[dy][dx] == '.' && current_cost > cost[dy][dx]){\n      count++;\n    }\n  }\n  return (count >= strongness);\n}\n\nint main(){\n  while(~scanf(\"%d %d\",&H,&W)){\n    memset(cost,0x3f,sizeof(cost));\n    priority_queue<State,vector<State>,greater<State> > que;\n    for(int y = 0; y < H; y++){\n      char line[1001];\n      scanf(\"%s\",line);\n      for(int x = 0; x < W; x++){\n        stage[y][x] = line[x];\n        if(line[x] == '.'){\n          que.push(State(x,y,0));\n          cost[y][x] = 0;\n        }\n      }\n    }\n\n\n    int res = 0;\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      res = max(s.cost,res);\n\n      for(int i = 0; i < 8; i++){\n        int dx = s.x + tx[i];\n        int dy = s.y + ty[i];\n        if(dx < 0 || dx >= W || dy < 0 || dy >= H) continue;\n        if(cost[dy][dx] <= s.cost + 1) continue;\n        if(!is_new_vacant_lot(dx,dy,s.cost + 1)) continue;\n        \n        stage[dy][dx] = '.';\n        cost[dy][dx] = s.cost + 1;\n        que.push(State(dx,dy,s.cost + 1));\n      }\n    }\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define fi first\n#define se second\nconst int inf = 1e9;\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define rrep(i,n) for(int i = 1;i <= n;i++)\ntypedef pair<int,int> P;\n\nqueue<P> q1, q2;\nchar str[1004][1004];\nint a[1004][1004], b[1004][1004], h, w;\nint dy[] = {-1, -1, -1, 0, 0, 1, 1, 1};\nint dx[] = {-1, 0, 1, -1, 1, -1, 0, 1};\n\nvoid calc(int y, int x){\n\tif(b[y][x] || !a[y][x] || a[y][x] == -1)return ;\n\tif(a[y][x] != inf){\n\t\tif(!(--a[y][x]))q1.push(P(y, x));\n\t\treturn ;\n\t}\n\tb[y][x] = 1;\n\tfor(int i = 0;i < 8;i++)calc(y+dy[i], x+dx[i]);\n}\n\nint solve(int k){\n\tif(q1.empty())return 0;\n\twhile(!q1.empty()){\n\t\tP p = q1.front();q1.pop();\n\t\tb[p.fi][p.se] = 1;\n\t\tfor(int i = 0;i < 8;i++){\n\t\t\tint yy = p.fi+dy[i], xx = p.se+dx[i];\n\t\t\tif(!b[yy][xx] && a[yy][xx] != inf && a[yy][xx] != 0){\n\t\t\t\tif(--a[yy][xx] == 0)q2.push(P(yy, xx));\n\t\t\t}\n\t\t}\n\t}\n\tswap(q1, q2);\n\treturn k+1;\n}\n\nint main(){\n\tfill((int*)a, (int*)(a+1004), -1);\n\tscanf(\"%d%d\", &h, &w);\n\trep(i,h)scanf(\"%s\", str[i]);\n\trep(i,h)rep(j,w){\n\t\tif(str[i][j] == '.')a[i+1][j+1] = inf;\n\t\telse a[i+1][j+1] = str[i][j]-'0';\n\t}\n\t\n\tint res = 0, ans = 1;\n\trrep(i,h)rrep(j,w)if(a[i][j] == inf)calc(i, j);\n\twhile(1){\n\t\tres = solve(res);\n\t\tif(res == 0)break;\n\t\tans = res;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint H, W;\n\nbool contains(int x, int y) {\n  return 0 <= x && x < W && 0 <= y && y < H;\n}\n\nint main() {\n  int dx[] = {-1, 0, 1, -1, 1, -1, 0, 1};\n  int dy[] = {-1, -1, -1, 0, 0, 1, 1, 1};\n\n  while (cin >> H >> W) {\n    vector<string> t(H);\n\n    for (int i = 0; i < H; i++) {\n      cin >> t[i];\n    }\n\n    vector<vector<int> > rawCnt(H, vector<int>(W, 0));\n    queue<P> open;\n\n    for (int i = 0; i < H; i++) {\n      for (int j = 0; j < W; j++) {\n        if (t[i][j] != '.') continue;\n\n        for (int k = 0; k < 8; k++) {\n          int nx = j + dx[k];\n          int ny = i + dy[k];\n\n          if (!contains(nx, ny)) continue;\n          if (t[ny][nx] == '.') continue;\n\n          rawCnt[ny][nx]++;\n\n          if (rawCnt[ny][nx] == t[ny][nx] - '0') {\n            open.push(P(nx, ny));\n          }\n        }\n      }\n    }\n\n    int ans = 0;\n\n    while (!open.empty()) {\n      queue<P> nextOpen;\n\n      while (!open.empty()) {\n        P p = open.front();\n        open.pop();\n\n        for (int k = 0; k < 8; k++) {\n          int nx = p.first + dx[k];\n          int ny = p.second + dy[k];\n\n          if (!contains(nx, ny)) continue;\n          if (t[ny][nx] == '.') continue;\n\n          rawCnt[ny][nx]++;\n\n          if (rawCnt[ny][nx] == t[ny][nx] - '0') {\n            nextOpen.push(P(nx, ny));\n          }\n        }\n      }\n\n      open = nextOpen;\n      ans++;\n    }\n\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 0612.cc: Sandcastle\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_H = 1000;\nconst int MAX_W = 1000;\nconst int MAX_GN = MAX_H * MAX_W;\n\nconst int dxs[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst int dys[] = {0, -1, -1, -1, 0, 1, 1, 1};\n\n/* typedef */\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\n/* global variables */\n\nint ids[MAX_H][MAX_W], dists[MAX_H][MAX_W];\nint xs[MAX_GN], ys[MAX_GN], ps[MAX_GN], flds[MAX_GN];\nvi nbrs[MAX_H][MAX_W];\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  int h, w;\n  cin >> h >> w;\n\n  int gn = 0;\n  \n  for (int y = 0; y < h; y++) {\n    string s;\n    cin >> s;\n    for (int x = 0; x < w; x++) {\n      if (s[x] == '.') ids[y][x] = -1;\n      else {\n\tids[y][x] = gn;\n\tflds[gn] = s[x] - '0';\n\txs[gn] = x, ys[gn] = y;\n\tgn++;\n      }\n    }\n  }\n  //printf(\"gn=%d\\n\", gn);\n\n  for (int y = 0; y < h; y++)\n    for (int x = 0; x < w; x++)\n      for (int di = 0; di < 8; di++) {\n\tint vx = x + dxs[di], vy = y + dys[di];\n\tif (vx >= 0 && vx < w && vy >= 0 && vy < h && ids[vy][vx] >= 0)\n\t  nbrs[y][x].push_back(ids[vy][vx]);\n      }\n\n  queue<pii> q;\n  int maxd = 0;\n  \n  for (int y = 0; y < h; y++)\n    for (int x = 0; x < w; x++)\n      if (ids[y][x] < 0) q.push(pii(x, y));\n  //printf(\"%lu\\n\", q.size());\n\n  while (! q.empty()) {\n    pii u = q.front(); q.pop();\n    int &ux = u.first, &uy = u.second;\n\n    int vd = dists[uy][ux] + 1;\n    vi &nbr = nbrs[uy][ux];\n    for (vi::iterator vit = nbr.begin(); vit != nbr.end(); vit++) {\n      int &v = *vit, &vx = xs[v], &vy = ys[v];\n      if (dists[vy][vx] == 0 && ++ps[v] >= flds[v]) {\n\tdists[vy][vx] = vd;\n\tif (maxd < vd) maxd = vd;\n\tq.push(pii(vx, vy));\n      }\n    }\n  }\n\n  printf(\"%d\\n\", maxd);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef long long ll;\n\nint h, w;\nchar ca[1000][1001];\nchar cpy[1000][1001];\n\nint cnt(int a, int b){\n\tint res = 0;\n\tfor (int i = -1; i <= 1; i++){\n\t\tfor (int j = -1; j <= 1; j++){\n\t\t\tif (ca[a + i][b + j] == '.')\n\t\t\t\tres++;\n\t\t}\n\t}\n\treturn res;\n}\nvoid wave(){\n\trep(i, h){\n\t\trep(j, w){\n\t\t\tif ('1' <= ca[i][j] && ca[i][j] - '0' <= cnt(i, j))\n\t\t\t\tcpy[i][j] = '.';\n\t\t}\n\t}\n}\nint main(){\n\tscanf(\"%d%d\", &h, &w);\n\trep(i, h){\n\t\tscanf(\"%s\", ca[i]);\n\t\tstrcpy(cpy[i], ca[i]);\n\t}\n\tbool flag = true;\n\tint cnt = 0;\n\tfor (; flag; cnt++){\n\t\twave();\n\t\tflag = false;\n\t\trep(i, h){\n\t\t\tif (strcmp(ca[i], cpy[i])){\n\t\t\t\tflag = true;\n\t\t\t\tstrcpy(ca[i], cpy[i]);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", cnt - 1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\nusing namespace std;\n\nint h, w;\nchar t[1001];\nvector<string> v;\nint dx[8] = {0, 1, 1, 1, 0, -1, -1, -1};\nint dy[8] = {-1, -1, 0, 1, 1, 1, 0, -1};\nint ans;\ntypedef pair<int, int> P;\n\nbool solve(){\n/*\n\tprintf(\"\\n\");\n\tfor(int i=0; i<h; i++){\n\t\tprintf(\"%s\\n\", v[i].c_str());\n\t}\n*/\n\tbool d = false;\n\tvector<P> u;\n\tfor(int i=1; i<w+1; i++){\n\t\tfor(int j=1; j<h+1; j++){\n\t\t\tif(v[i][j] != '.'){\n\t\t\t\tint c = 0;\n\t\t\t\tfor(int k=0; k<8; k++){\n\t\t\t\t\tint nx, ny;\n\t\t\t\t\tnx = i + dx[k];\n\t\t\t\t\tny = j + dy[k];\n\t\t\t\t\tif(v[nx][ny] == '.') c++;\n\t\t\t\t}\n\t\t\t\tif(v[i][j] - '0' <= c){\n\t\t\t\t\tu.push_back(P(i, j));\n\t\t\t\t\td = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0; i<u.size(); i++){\n\t\tv[u[i].first][u[i].second] = '.';\n\t}\n\tif(d) ans++;\n\treturn d;\n}\n\nint main(){\n\tscanf(\"%d %d\", &h, &w);\n\tfor(int i=0; i<h; i++){\n\t\tscanf(\"%s\", t);\n\t\tv.push_back(t);\n\t}\n\twhile(solve());\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) begin(r),end(r)\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\nconst int mod = 1000000007;\nconstexpr int inf = ((1<<30)-1)*2+1 ;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dx[] = {-1, 0, 1};\nconst int dy[] = {-1, 0, 1};\n\ninline bool value(int x,int y,int w,int h){\n  return (x >= 0 && x < w && y >= 0 && y < h);\n}\n\nll h,w;\ntemplate<class T>\nbool solve(T &v){\n  auto tmp = v;\n  bool f = true;\n  rep(i,h){\n    rep(j,w){\n      if(v[i][j] != '.'){\n        ll cnt = 0;\n        rep(y,3){\n          rep(x,3){\n            ll nx = j+dx[x],ny = i + dy[y];\n            if(value(nx,ny,w,h) && v[ny][nx] == '.'){\n              ++cnt;\n            }\n          }\n        }\n        if(cnt >= v[i][j] - '0'){\n          tmp[i][j] = '.';\n          f = false;\n        }\n      }\n    }\n  }\n  v = tmp;\n  return f;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cin >> h >> w;\n  vector<vector<char>> v(h,vector<char>(w));\n  rep(i,h){\n    rep(j,w){\n      cin >> v[i][j];\n    }\n  }\n  ll ans = 0;\n  while(1){\n    if(solve(v)){\n      cout << ans << endl;\n      return 0 ;\n    }\n    ++ans;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tInfo(int arg_row,int arg_col){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\tint row,col;\n};\n\nint H,W;\nint diff_row[8] = {-1,-1,-1,0,0,1,1,1},diff_col[8] = {-1,0,1,-1,1,-1,0,1};\n\nint main(){\n\n\tscanf(\"%d %d\",&H,&W);\n\n\tchar** map = new char*[H+2];\n\tfor(int row = 0; row <= H+1; row++){\n\t\tmap[row] = new char[W+2];\n\t}\n\n\tfor(int col = 0; col <= W+1; col++){\n\t\tmap[0][col] = '.';\n\t\tmap[H+1][col] = '.';\n\t}\n\n\tfor(int row = 0; row <= H+1; row++){\n\t\tmap[row][0] = '.';\n\t\tmap[row][W+1] = '.';\n\t}\n\n\tchar buf[W+1];\n\n\tfor(int row = 1; row <= H; row++){\n\t\tscanf(\"%s\",buf);\n\t\tfor(int col = 1; col <= W; col++){\n\t\t\tmap[row][col] = buf[col-1];\n\t\t}\n\t}\n\n\tvector<Info> broke_points;\n\tvector<Info> next_broke_points;\n\n\tint tmp,count,adj_row,adj_col;\n\n\tbool** deleted = new bool*[H+1];\n\tbool** pushed = new bool*[H+1];\n\n\tfor(int row = 1; row <= H; row++){\n\t\tdeleted[row] = new bool[W+1];\n\t\tpushed[row] = new bool[W+1];\n\t\tfor(int col = 1; col <= W; col++){\n\t\t\tdeleted[row][col] = false;\n\t\t\tpushed[row][col] = false;\n\t\t}\n\t}\n\n\tfor(int row = 1; row <= H; row++){\n\t\tfor(int col = 1; col <= W; col++){\n\t\t\tif(map[row][col] >= '1' && map[row][col] <= '8'){\n\n\t\t\t\ttmp = map[row][col] - '0';\n\t\t\t\tcount = 0;\n\n\t\t\t\tfor(int i = 0; i < 8; i++){\n\t\t\t\t\tadj_row = row + diff_row[i];\n\t\t\t\t\tadj_col = col + diff_col[i];\n\n\t\t\t\t\tif(map[adj_row][adj_col] == '.')count++;\n\t\t\t\t}\n\n\t\t\t\tif(count >= tmp){\n\t\t\t\t\tbroke_points.push_back(Info(row,col));\n\t\t\t\t\tdeleted[row][col] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif(broke_points.size() == 0){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\n\tint ans = 1;\n\tint next_adj_row,next_adj_col;\n\n\n\twhile(true){\n\n\t\tfor(int i = 0; i < broke_points.size(); i++){\n\t\t\tmap[broke_points[i].row][broke_points[i].col] = '.';\n\n\t\t\tfor(int k = 0; k < 8;k++){\n\t\t\t\tadj_row = broke_points[i].row + diff_row[k];\n\t\t\t\tadj_col = broke_points[i].col + diff_col[k];\n\n\t\t\t\tif(deleted[adj_row][adj_col] == false && pushed[adj_row][adj_col] == false && map[adj_row][adj_col] >= '1' && map[adj_row][adj_col] <= '8'){\n\t\t\t\t\ttmp = map[adj_row][adj_col] - '0';\n\t\t\t\t\tcount = 0;\n\n\t\t\t\t\tfor(int p = 0; p < 8; p++){\n\t\t\t\t\t\tnext_adj_row = adj_row + diff_row[p];\n\t\t\t\t\t\tnext_adj_col = adj_col + diff_col[p];\n\n\t\t\t\t\t\tif(map[next_adj_row][next_adj_col] == '.' || deleted[next_adj_row][next_adj_col] == true){\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(count >= tmp){\n\t\t\t\t\t\tpushed[adj_row][adj_col] = true;\n\t\t\t\t\t\tnext_broke_points.push_back(Info(adj_row,adj_col));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\n\t\t}\n\t\tbroke_points.clear();\n\n\t\tif(next_broke_points.size() == 0){\n\t\t\tbreak;\n\t\t}\n\t\tans++;\n\n\t\tfor(int i = 0; i < next_broke_points.size(); i++){\n\t\t\tdeleted[next_broke_points[i].row][next_broke_points[i].col] = true;\n\t\t\tbroke_points.push_back(next_broke_points[i]);\n\t\t}\n\t\tnext_broke_points.clear();\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint a;\nint b;\nchar are[1001][1001];\nint kore[1001][1001];\nint sore[1001][1001];\nint sata[1001][1001];\nint ushi;\nint uma;\n\nint main(){\n\tcin >> a >> b;\n\tfor (int i = 0; i < a; i++){\n\t\tfor (int j = 0; j < b; j++){\n\t\t\tcin >> are[i][j];\n\t\t\tif (are[i][j] !='.'){\n\t\t\tkore[i - 1][j - 1]++;\n\t\t\tkore[i][j - 1]++;\n\t\t\tkore[i + 1][j - 1]++;\n\t\t\tkore[i - 1][j]++;\n\t\t\tkore[i + 1][j]++;\n\t\t\tkore[i - 1][j + 1]++;\n\t\t\tkore[i][j + 1]++;\n\t\t\tkore[i + 1][j + 1]++;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < a; i++){\n\t\tfor (int j = 0; j < b; j++){\n\t\t\tsore[i][j] = kore[i][j];\n\t\t\tsata[i][j] = 1;\n\t\t}\n\t}\n\twhile (true){\n\t\tuma = 0;\n\t\tfor (int i = 0; i < a; i++){\n\t\t\tfor (int j = 0; j < b; j++){\n\t\t\t\tif (sata[i - 1][j - 1] ==1||sata[i][j - 1] == 1||sata[i + 1][j - 1] == 1||sata[i - 1][j] == 1||sata[i + 1][j] == 1||sata[i - 1][j + 1] == 1||sata[i][j + 1] == 1||sata[i + 1][j + 1] == 1){\n\t\t\t\t\tif (are[i][j] != '.'&&9-sore[i][j] > are[i][j]-'0'){\n\t\t\t\t\t\tare[i][j] = '.';\n\t\t\t\t\t\tkore[i - 1][j - 1]--;\n\t\t\t\t\t\tkore[i][j - 1]--;\n\t\t\t\t\t\tkore[i + 1][j - 1]--;\n\t\t\t\t\t\tkore[i - 1][j]--;\n\t\t\t\t\t\tkore[i + 1][j]--;\n\t\t\t\t\t\tkore[i - 1][j + 1]--;\n\t\t\t\t\t\tkore[i][j + 1]--;\n\t\t\t\t\t\tkore[i + 1][j + 1]--;\n\t\t\t\t\t\tuma = 1;\n\t\t\t\t\t\tsata[i][j] = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse{ sata[i][j] = 0; }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (uma == 1){\n\t\t\tushi++;\n\t\t}\n\t\tif (uma == 0){\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < a; i++){\n\t\t\tfor (int j = 0; j < b; j++){\n\t\t\t\tsore[i][j] = kore[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tcout << ushi << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <tuple>\n#include <string>\n\nsize_t constexpr m1 = -1;\nsize_t constexpr di[] = {m1, m1, m1, 0, 0, 1, 1, 1};\nsize_t constexpr dj[] = {m1, 0, 1, m1, 1, m1, 0, 1};\n\nusing zahyo = std::pair<size_t, size_t>;\n\nbool nyan(std::vector<std::string>& s, std::queue<zahyo>& q) {\n  size_t h = s.size();\n  size_t w = s[0].length();\n  std::queue<zahyo> r;\n  bool res = false;\n  while (!q.empty()) {\n    size_t i, j;\n    std::tie(i, j) = q.front();\n    q.pop();\n    for (size_t k = 0; k < 8; ++k) {\n      size_t ni = i + di[k];\n      size_t nj = j + dj[k];\n      if (!(ni < h && nj < w)) continue;\n      if (s[ni][nj] == '.') continue;\n      if (--s[ni][nj] == '0') {\n        s[ni][nj] = '.';\n        res = true;\n        r.emplace(ni, nj);\n      }\n    }\n  }\n  q = r;\n  return res;\n}\n\nint main() {\n  size_t h, w;\n  scanf(\"%zu %zu\", &h, &w);\n\n  std::vector<std::string> s(h);\n  std::queue<zahyo> q;\n  for (size_t i = 0; i < h; ++i) {\n    char buf[1024];\n    scanf(\"%s\", buf);\n    s[i] = buf;\n    for (size_t j = 0; j < w; ++j) {\n      if (s[i][j] == '.') q.emplace(i, j);\n    }\n  }\n\n  // for (auto const& si: s)\n  //   fprintf(stderr, \"%s\\n\", si.c_str());\n  // fprintf(stderr, \"---\\n\");\n  int res = 0;\n  while (nyan(s, q)) {\n    ++res;\n    // for (auto const& si: s)\n    //   fprintf(stderr, \"%s\\n\", si.c_str());\n    // fprintf(stderr, \"---\\n\");\n  }\n\n  printf(\"%d\\n\", res);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cctype>\n#include <algorithm>\n\nusing P = std::pair<std::pair<int, int>, int>;\nconstexpr int MAX = 1000;\n\nint h, w;\nint board[MAX][MAX];\nint dx[8] = { 0,-1,-1,-1,0,1,1,1 }, dy[8] = { -1,-1,0,1,1,1,0,-1 };\n\nint count(int x, int y) {\n\tint cnt = 0;\n\tfor (int i = 0; i < 8; ++i) {\n\t\tif (!board[y + dy[i]][x + dx[i]])\n\t\t\t++cnt;\n\t}\n\treturn cnt;\n}\n\nint solve() {\n\tstd::queue<P> que;\n\n\tfor (int i = 0; i < h; ++i) {\n\t\tfor (int j = 0; j < w; ++j) {\n\t\t\tif (board[i][j]) {\n\t\t\t\t\tque.push(P(std::make_pair(j, i), 0));\n\t\t\t}\n\t\t}\n\t}\n\n\tint max = 0;\n\n\tstd::vector<std::pair<int, int>> vec;\n\n\twhile (!que.empty()) {\n\t\tP p = que.front(); que.pop();\n\n\t\tif (board[p.first.second][p.first.first] <= count(p.first.first, p.first.second)) {\n\t\t\tif (max < p.second) {\n\t\t\t\tfor (auto& x : vec)\n\t\t\t\t\tboard[x.second][x.first] = 0;\n\t\t\t\tvec.clear();\n\t\t\t\tmax = p.second;\n\n\t\t\t\tfor (int i = 0; i < h; ++i) {\n\t\t\t\t\tfor (int j = 0; j < w; ++j)\n\t\t\t\t\t\tstd::cout << board[i][j] << ' ';\n\t\t\t\t\tstd::cout << std::endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvec.push_back(std::make_pair(p.first.first, p.first.second));\n\n\t\t\tint nx, ny;\n\t\t\tfor (int i = 0; i < 8; ++i) {\n\t\t\t\tnx = p.first.first + dx[i];\n\t\t\t\tny = p.first.second + dy[i];\n\t\t\t\tif (board[ny][nx]) {\n\t\t\t\t\tque.push(P(std::make_pair(nx, ny), p.second + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/*if (!vec.size())\n\t\t--max;*/\n\n\treturn max;\n}\n\nint main() {\n\tstd::cin >> h >> w;\n\n\tchar ch;\n\tfor (int i = 0; i < h; ++i) {\n\t\tfor (int j = 0; j < w; ++j) {\n\t\t\tstd::cin >> ch;\n\t\t\tif (std::isdigit(ch)) {\n\t\t\t\tboard[i][j] = atoi(&ch);\n\t\t\t}\n\t\t}\n\t}\n\n\tstd::cout << solve() << std::endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef double db;\nstring s[1000];\nll vx[8]={1,1,0,-1,-1,-1,0,1};\nll vy[8]={0,1,1,1,0,-1,-1,-1};\nll H,W;\nqueue<P> q;\nqueue<P> yaru;\nbool pushed[1000][1000];\nll N,nx,ny;\nll ans,cnt;\nint main()\n{\n\tscanf(\"%lld%lld\",&H,&W);\n\tfor(ll i=0;i<H;i++) cin>>s[i];\n\tfor(ll i=0;i<H;i++) for(ll j=0;j<W;j++) if(s[i][j]!='.') q.push(P(i,j));\n\twhile(q.size()){\n\t\tN=q.size();\n\t\tans++;\n\t\tmemset(pushed,0,sizeof(pushed));\n\t\tfor(ll I=0;I<N;I++){\n\t\t\tP p=q.front();\n\t\t\tq.pop();\n\t\t\tif(s[p.first][p.second]=='.') continue;\n\t\t\tcnt=0;\n\t\t\tfor(ll i=0;i<8;i++){\n\t\t\t\tny=p.first+vy[i];\n\t\t\t\tnx=p.second+vx[i];\n\t\t\t\tif(0<=nx&&nx<W&&0<=ny&&ny<H&&s[ny][nx]=='.') cnt++;\n\t\t\t}\n\t\t\tif(cnt>=s[p.first][p.second]-'0') yaru.push(P(p.first,p.second));\n\t\t}\n\t\twhile(yaru.size()){\n\t\t\tP p=yaru.front();\n\t\t\tyaru.pop();\n\t\t\ts[p.first][p.second]='.';\n\t\t\tfor(ll i=0;i<8;i++){\n\t\t\t\tny=p.first+vy[i];\n\t\t\t\tnx=p.second+vx[i];\n\t\t\t\tif(0<=nx&&nx<W&&0<=ny&&ny<H&&s[ny][nx]!='.'&&s[ny][nx]!='9'&&!pushed[ny][nx]){\n\t\t\t\t\tpushed[ny][nx]=1;\n\t\t\t\t\tq.push(P(ny,nx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//for(ll i=0;i<H;i++) c\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <queue>\nusing namespace std;\ntypedef pair<int, int> P;\n \nint h, w, ans;\nint castle[1001][1001], times[1001][1001];\nint dx[] = {-1, 0, 1, -1, 1, -1, 0, 1}, dy[] = {-1, -1, -1, 0, 0, 1, 1, 1};\nchar beach[1001][1001];\n \nint main(){\n    scanf(\"%d%d\", &h, &w);\n    for(int i = 0; i < h; i++){\n        scanf(\"%s\", &beach[i]);\n    }\n \n    queue<P> Q;\n    for(int i = 0; i < h; i++){\n        for(int j = 0; j < w; j++){\n            if(beach[i][j] == '.'){\n                Q.push(P(i, j));\n            } else{\n                castle[i][j] = beach[i][j] - 48;\n            }\n        }\n    }\n \n    while(Q.size()){\n        P p = Q.front();\n        Q.pop();\n        ans = max(ans, times[p.first][p.second]);\n \n        for(int i = 0; i < 8; i++){\n            int y = p.first + dy[i], x = p.second + dx[i];\n            if(y < 0 || y >= h || x < 0 || x >= w){\n                continue;\n            }\n \n            castle[y][x]--;\n            if(castle[y][x] == 0){\n                Q.push(P(y, x));\n                times[y][x] = times[p.first][p.second] + 1;\n            }\n        }\n    }\n \n    printf(\"%d\\n\", ans);\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<queue>\nusing namespace std;\nstring fie[1001];\nint fiec[1001][1001];\nint dy[8]={-1,-1,-1,0,0,1,1,1},dx[8]={-1,0,1,-1,1,-1,0,1};\nstruct data{\n    int y;\n    int x;\n    int n;\n};\nqueue<data> Q;\nqueue<int> lisy;\nqueue<int> lisx;\nint main(){\n    int H,W;\n    cin>>H>>W;\n    for(int i=0;i<H;i++)cin>>fie[i];\n    for(int i=1;i<H-1;i++){\n        for(int j=1;j<W-1;j++){\n            int cou=0;\n            for(int k=0;k<8;k++){\n                if(fie[i+dy[k]][j+dx[k]]=='.')cou++;\n            }\n            if(fie[i][j]-'0'<=cou&&fie[i][j]!='.')lisy.push(i),lisx.push(j);\n        }\n    }\n    int befn=0;\n    while(1){\n        if(lisy.size()==0)break;\n        befn++;\n        if(Q.size()==0){\n            while(lisy.size()){\n                int kariy,karix;\n                kariy=lisy.front();\n                karix=lisx.front(),lisy.pop(),lisx.pop();\n                fie[kariy][karix]='.';\n                for(int k=0;k<8;k++){\n                    if(fiec[kariy+dy[k]][karix+dx[k]]==0&&fie[kariy+dy[k]][karix+dx[k]]!='.'){\n                        fiec[kariy+dy[k]][karix+dx[k]]=1;\n                        data kariba;\n                        kariba.y=kariy+dy[k],kariba.x=karix+dx[k],kariba.n=befn+1;\n                        Q.push(kariba);\n                    }\n                }\n            }\n        }\n        while(Q.size()){\n            data kari;\n            kari=Q.front(),Q.pop();\n            int cou=0;\n            if(kari.y!=0&&kari.y!=H-1&&kari.x!=0&&kari.x!=W-1){\n                for(int i=0;i<8;i++){\n                    if(fie[kari.y+dy[i]][kari.x+dx[i]]=='.')cou++;\n                }\n                if(fie[kari.y][kari.x]-'0'<=cou&&fie[kari.y][kari.x]!='.'){\n                        lisy.push(kari.y),lisx.push(kari.x);\n                    //printf(\"[%d][%d]\\n\",kari.y,kari.x);\n                    //for(int pp=0;pp<100000000;pp++){\n                    //}\n                }\n                else fiec[kari.y][kari.x]=0;\n            }\n        }\n    }\n    cout<<befn<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstring>\nusing namespace std;\n  \n#define MAX 1001\n  \nint main(){\n    string S;\n    int n,m,t,sum,a,p=0;\n    sum=0;\n    short x[MAX][MAX];\n    short z[MAX][MAX];\n    short v[MAX][MAX];\n    memset(x,0,sizeof(x));\n    memset(z,0,sizeof(z));\n    char T[10]={'.','1','2','3','4','5','6','7','8','9'};\n    cin>>n>>m;\n    for(int i=1;i<=n;i++){\n        cin>>S;\n        for(int j=1;j<=m;j++){\n            for(int k=0;k<10;k++){\n                if(S[j-1]==T[k]){\n                    x[i][j]=k;\n                    if(k==0){\n                        for(int l=-1;l<=1;l++){\n                            for(int o=-1;o<=1;o++){\n                                z[i+l][j+o] += 1;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    while(true){\n        t=0;\n        sum++;\n        for(int i=2;i<n;i++){\n            for(int j=2;j<m;j++){\n                if(x[i][j]>=1 && z[i][j]>=x[i][j]){\n                    v[i][j] += 1;\n                    t++;\n                    for(int l=-1;l<=1;l++){\n                        for(int o=-1;o<=1;o++){\n                            v[i+l][j+o]+= 10;\n                        }\n                    }\n                }\n            }\n        }\n        if(t==0){\n            break;\n        }\n        for(int i=2;i<n;i++){\n            for(int j=2;j<m;j++){\n                if(v[i][j]%10>=1){\n                    x[i][j]=0;\n                }\n                z[i][j] += v[i][j]/10;\n                v[i][j]=0;\n            }\n        }\n    }\n    cout<<sum-1<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <queue>\nusing namespace std;\nchar field[1000][1000];\nint dx[] = {1,1,1,0,0,-1,-1,-1};\nint dy[] = {1,0,-1,1,-1,1,0,-1};\nint x,y,d,ans;\nint main()\n{\n    queue<int> str[3];\n    int h,w;\n    char kara;\n    scanf(\"%d%d\",&h,&w);\n    ans = 0;\n    for(int i = 0; i < h; i++)\n    {\n        for(int j = 0; j < w + 1; j++)\n        {\n            scanf(\"%c\",&field[i][j]);\n        }\n    }\n    for(int i = 0; i < h; i++)\n    {\n        for(int j = 1; j < w + 1; j++)\n        {\n            if(field[i][j] == '.')\n            {\n                str[0].push(i);\n                str[1].push(j);\n                str[2].push(0);\n            }\n        }\n    }\n    while(str[0].size())\n    {\n        x = str[0].front();str[0].pop();\n        y = str[1].front();str[1].pop();\n        d = str[2].front();str[2].pop();\n        if(ans < d)ans = d;\n        for(int i = 0; i < 8; i++)\n        {\n            if(0 <= x + dx[i]&&x + dx[i] < w&&0 <= y + dy[i]&&y + dy[i] < h)\n            {\n                field[x + dx[i]][y + dy[i]]--;\n                if(field[x + dx[i]][y + dy[i]] == '0')\n                {\n                    str[0].push(x + dx[i]);\n                    str[1].push(y + dy[i]);\n                    str[2].push(d + 1);\n                }\n            }\n        }\n    }\n    printf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1<<30;\nint n,m;\nvector<string>in,tmp;\nint dx[]={1,1,1,0,0,-1,-1,-1};\nint dy[]={1,0,-1,1,-1,1,0,-1};\nvp t,nt;\nbool f(int a,int b){\n\tint c=in[a][b]-'0';\n\tint co=0;\n\trep(i,8){\n\t\tint x=a+dx[i];\n\t\tint y=b+dy[i];\n\t\tif(in[x][y]=='.')co++;\n\t}\n\tif(co>=c){\n\t\ttmp[a][b]='.';\n\t\treturn true;\n\t}\n\treturn false;\n}\nbool F(bool e){\n\tnt=vp(0);\n\ttmp=in;\n\tbool h=false;\n\tif(!e){\n\t\trep(i,n)rep(j,m)if(in[i][j]!='.'&&f(i,j))h=true,nt.pb(pii(i,j));\n\t}else{\n\t\trep(i,t.size())rep(j,8){\n\t\t\tint x=t[i].first+dx[j];\n\t\t\tint y=t[i].second+dy[j];\n\t\t\tif(tmp[x][y]!='.'&&f(x,y))h=true,nt.pb(pii(x,y));\n\t\t}\n\t}\n\tin=tmp;\n\tt=nt;\n\treturn h;\n}\nint main(){\n\tcin>>n>>m;\n\tin=vector<string>(n);\n\trep(i,n)cin>>in[i];\n\tint co=0;\n\tif(F(0)){\n\t\tco++;\n\t\twhile(F(1))co++;\n\t}\n\tcout<<co<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define loop(i,n) for(int i=1;i<=n;i++)\nconst int INF=100000000;\ntypedef pair<int,int> P;\nint h,w;\nchar sh[1002][1002];\nbool miket[1002][1002];\nint houkai[1002][1002];\nqueue<P> que;\nint dir[9]={0,-1,-1,0,1,1,-1,1,0};\n\nint main() {\n  cin>>h>>w;\n  loop(i,h)loop(j,w){\n    cin>>sh[i][j];\n    if(sh[i][j]=='.'){\n      houkai[i][j]=0;\n    }else if(sh[i][j]=='9'){\n      houkai[i][j]=INF;\n    }else{\n      que.push(P(i,j));\n      miket[i][j]=1;\n    }\n  }\n  bool changed=0;\n  que.push(P(0,0));\n  while(!que.empty()){\n    P p=que.front();que.pop();\n    int i=p.first,j=p.second;\n    if(i==0&&j==0){\n      if(!changed)break;\n      else {\n        changed=0;\n        que.push(p);\n        continue;\n      }\n    }\n    int sara=0;\n    int yama=0;\n    vector<int> v;\n    int kyoudo=(int)(sh[i][j]-'0');\n    loop(d,8){\n      int x=i+dir[d-1];\n      int y=j+dir[d];\n      if(!miket[x][y]){\n        if(houkai[x][y]<INF){\n          sara++;\n          v.push_back(houkai[x][y]);\n        }else{\n          yama++;\n        }\n      }\n    }\n    if(sara>=kyoudo){\n      miket[i][j]=0;\n      sort(v.begin(),v.end());\n      houkai[i][j]=v[kyoudo-1]+1;\n      changed=1;\n    }else if(8-yama<kyoudo){\n      miket[i][j]=0;\n      houkai[i][j]=INF;\n      changed=1;\n    }else{\n      que.push(p);\n    }\n  }\n  int m=0;\n  loop(i,h)loop(j,w){\n    if(houkai[i][j]==INF)continue;\n    m=max(m,houkai[i][j]);\n  }\n  cout<<m<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<utility>\nusing namespace std;\ntypedef pair<int, int>P;\n\nchar sand[1005][1005];\nint sara[1005][1005];\n\nint main() {\n\tint h, w;\n\tcin >> h >> w;\n\tqueue<P>now;\n\tqueue<P>next;\n\n\tfor (int i = 0;i<h;i++)\n\t\tfor (int j = 0;j<w;j++)cin >> sand[i][j];\n\n\tfor (int i = 0;i<h;i++) {\n\t\tfor (int j = 0;j<w;j++) {\n\t\t\tif (sand[i][j] != '.') {\n\t\t\t\tfor (int k = -1;k <= 1;k++) {\n\t\t\t\t\tfor (int l = -1;l <= 1;l++) {\n\t\t\t\t\t\tif (sand[i + k][j + l] == '.')sara[i][j]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0;i<h;i++) {\n\t\tfor (int j = 0;j<w;j++) {\n\t\t\tif (sand[i][j] != '.') {\n\t\t\t\tint a = sand[i][j] - '0';\n\t\t\t\tif (a <= sara[i][j]) {\n\t\t\t\t\tnow.push(make_pair(i, j));\n\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\n\twhile(now.size()){\n\tint a = now.size();\n\tqueue<P>q;\n\n\tfor (int i = 0;i < a;i++) {\n\t\tP p = now.front();\n\t\tnow.pop();\n\n\t\tint f = p.first, s = p.second;\n\n\t\tsand[f][s] = '.';\n\t\tsara[f][s] = 0;\n\t\t\n\t\tfor (int j = -1;j <= 1;j++) {\n\t\t\tfor (int k = -1;k <= 1;k++) {\n\t\t\t\tif (sand[f + j][s + k] != '.')q.push(make_pair(f + j, s + k));\n\n\t\t\t\tif( sand[f + j][s + k] != '.'&&sand[f + j][s + k] - '0' <= sara[f + j][s + k]) {\n\t\t\t\t\tnext.push(make_pair(f + j, s + k));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint b = q.size();\n\tfor (int i = 0;i < b;i++) {\n\t\tP pa = q.front();\n\t\tq.pop();\n\t\tint m=0;\n\t\tfor (int j = -1;j <= 1;j++) {\n\t\t\tfor (int k = -1;k <= 1;k++) {\n\t\t\t\tif (sand[pa.first + j][pa.second + k] == '.')m++;\n\t\t\t}\n\t\t}\n\t\tsara[pa.first][pa.second] = m;\n\t}\n\n\tint c=next.size();\n\n\tfor(int i=0;i<c;i++){\n\tnow.push(next.front());\n\tnext.pop();\n\t}\n\n\tans++;\n\t}\n\n\tcout<<ans<<endl;\n\tgetchar();\n\tgetchar();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\n#define chmin(a, b) ((a) = min((a), (b)))\n#define chmax(a, b) ((a) = max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n\nconst ll MOD = 1e9 + 7;\nconst ll INF = 1e18;\nconst double pi = acos(-1);\nconst double eps = 1e-10;\n\nint dx[] = {1, 1, 0, -1, -1, -1, 0, 1};\nint dy[] = {0, -1, -1, -1, 0, 1, 1, 1};\n\nint main(){\n    int h, w; cin>>h>>w;\n    vector<string> s(h);\n    for(int i=0; i<h; i++) cin>>s[i];\n\n    vector<vector<int>> turn(h, vector<int>(w, 0));\n    queue<T> que;\n    for(int i=0; i<h; i++){\n        for(int j=0; j<w; j++){\n            if('1' <= s[i][j] && s[i][j] <= '8'){\n                int num = s[i][j] - '0';\n                int sum = 0;\n                for(int k=0; k<8; k++){\n                    int ny = i + dy[k];\n                    int nx = j + dx[k];\n\n                    if(s[ny][nx] == '.' && turn[ny][nx] == 0) sum++;\n                }\n\n                if(num <= sum){\n                    s[i][j] = '.';\n                    turn[i][j] = 1;\n                    que.emplace(i, j, 1);\n                }\n            }\n        }\n    }\n\n    int ans = 0;\n    while(que.size()){\n        int cy, cx, cnt;\n        tie(cy, cx, cnt) = que.front();\n        que.pop();\n\n        //cout << cy << \" \" << cx << \" \" << cnt << endl;\n\n        ans = max(ans, cnt);\n\n        for(int i=0; i<8; i++){\n            int ny = cy + dy[i];\n            int nx = cx + dx[i];\n\n            if('1' <= s[ny][nx] && s[ny][nx] <= '8'){\n                int num = s[ny][nx] - '0';\n                int sum = 0;\n                for(int j=0; j<8; j++){\n                    int nny = ny + dy[j];\n                    int nnx = nx + dx[j];\n\n                    if(s[nny][nnx] == '.' && turn[nny][nnx] <= cnt) sum++;\n                }\n\n                if(num <= sum){\n                    s[ny][nx] = '.';\n                    turn[ny][nx] = cnt + 1;\n                    que.emplace(ny, nx, cnt + 1);\n                }\n            }\n        }\n    }\n\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint a;\nint b;\nchar are[1001][1001];\nint kore[1001][1001];\nint sore[1001][1001];\nint sata[1001][1001];\nint ushi;\nint uma;\n\nint main(){\n\tcin >> a >> b;\n\tfor (int i = 0; i < a; i++){\n\t\tfor (int j = 0; j < b; j++){\n\t\t\tcin >> are[i][j];\n\t\t\tif (are[i][j] !='.'){\n\t\t\tkore[i - 1][j - 1]++;\n\t\t\tkore[i][j - 1]++;\n\t\t\tkore[i + 1][j - 1]++;\n\t\t\tkore[i - 1][j]++;\n\t\t\tkore[i + 1][j]++;\n\t\t\tkore[i - 1][j + 1]++;\n\t\t\tkore[i][j + 1]++;\n\t\t\tkore[i + 1][j + 1]++;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < a; i++){\n\t\tfor (int j = 0; j < b; j++){\n\t\t\tsore[i][j] = kore[i][j];\n\t\t\tsata[i][j] = 1;\n\t\t//\tcout<<sore[i][j];\n\t\t}\n\t}\n\twhile (true){\n\t\tuma = 0;\n\t\tfor (int i = 0; i < a; i++){\n\t\t\tfor (int j = 0; j < b; j++){\n\t\t\t\tif (sata[i - 1][j - 1] ==1||sata[i][j - 1] == 1||sata[i + 1][j - 1] == 1||sata[i - 1][j] == 1||sata[i + 1][j] == 1||sata[i - 1][j + 1] == 1||sata[i][j + 1] == 1||sata[i + 1][j + 1] == 1){\n\t\t\t\t\t//cout<<are[i][j]<<\" \"<<9-sore[i][j]<<endl;\n\t\t\t\t\tif (are[i][j] != '.'&&9-sore[i][j] > are[i][j]-'0'){\n\t\t\t\t\t//cout<<1234<<endl;\n\t\t\t\t\t\tare[i][j] = '.';\n\t\t\t\t\t\tkore[i - 1][j - 1]--;\n\t\t\t\t\t\tkore[i][j - 1]--;\n\t\t\t\t\t\tkore[i + 1][j - 1]--;\n\t\t\t\t\t\tkore[i - 1][j]--;\n\t\t\t\t\t\tkore[i + 1][j]--;\n\t\t\t\t\t\tkore[i - 1][j + 1]--;\n\t\t\t\t\t\tkore[i][j + 1]--;\n\t\t\t\t\t\tkore[i + 1][j + 1]--;\n\t\t\t\t\t\tuma = 1;\n\t\t\t\t\t\tsata[i][j] = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse{ sata[i][j] = 0; }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (uma == 1){\n\t\t\tushi++;\n\t\t}\n\t\tif (uma == 0){\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < a; i++){\n\t\t\tfor (int j = 0; j < b; j++){\n\t\t\t\tsore[i][j] = kore[i][j];\n\t\t\t}\n\t\t//cout<<\"po\"<<endl;\n\t\t}\n\t}\n\tcout << ushi << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<queue>\n#define MP make_pair\nusing namespace std;\nlong long int sc[1001][1001],ssc[1001][1001];\nchar c[1001];\nint main()\n{\n\tint h, w, cnt = 0, ans = 0, n,kfc=0;\n\tint x, y;\n\tpair<int, int> p;\n\tqueue< pair<int, int> > que;\n\tqueue< pair<int, int> > que1;\n\tscanf(\"%d%d\", &h, &w);\n\tfor (int i = 0; i < h; i++)\n\t{\n\t\tscanf(\"%s\", c);\n\t\tfor (int j = 0; j < w; j++)\n\t\t{\n\n\t\t\tif (c[j] == '.')\n\t\t\t\tsc[i][j] = -1;\n\t\t\telse\n\t\t\t\tsc[i][j] = c[j] - 48;\n\t\t}\n\t}\n\tfor (int i = 1; i < h; i++)\n\t{\n\t\tfor (int j = 1; j < w; j++)\n\t\t{\n\t\t\tif (sc[i][j] != -1)\n\t\t\t{\n\t\t\t\tfor (int a = i - 1; a < i + 2; a++)\n\t\t\t\t{\n\t\t\t\t\tfor (int b = j - 1; b < j + 2; b++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (sc[a][b] == -1)ssc[i][j] ++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (sc[i][j] <= ssc[i][j])\n\t\t\t\t{\n\t\t\t\t\tque.push(MP(i, j)); que1.push(MP(i, j));  kfc++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < kfc; i++) {\n\t\tx = que.front().first;\n\t\ty = que.front().second;\n\t\tque.pop();\n\t\tque1.pop();\n\t\tsc[x][y] = -1; que.push(MP(x, y)); que1.push(MP(x, y));\n\t}\n\twhile (!que.empty())\n\t{\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tx = que.front().first;\n\t\t\ty = que.front().second;\n\t\t\tque.pop();\n\t\t\tfor (int a = -1; a < 2; a++)\n\t\t\t{\n\t\t\t\tssc[x - 1][y + a]++;\n\t\t\t\tssc[x + 1][y + a]++;\n\t\t\t}\n\t\t\tssc[x][y - 1]++;\n\t\t\tssc[x][y + 1]++;\n\t\t}\n\t\tn = que1.size();\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tx = que1.front().first;\n\t\t\ty = que1.front().second;\n\t\t\tque1.pop();\n\t\t\tfor (int a = -1; a < 2; a++)\n\t\t\t{\n\t\t\t\tif (sc[x - 1][y + a] <= ssc[x - 1][y + a] && sc[x - 1][y + a] != -1) {\n\t\t\t\t\tque.push(MP(x - 1, y + a)); que1.push(MP(x - 1, y + a)); sc[x - 1][y + a] = -1;\n\t\t\t\t}\n\t\t\t\tif (sc[x + 1][y + a] <= ssc[x + 1][y + a] && sc[x + 1][y + a] != -1) {\n\t\t\t\t\tque.push(MP(x + 1, y + a)); que1.push(MP(x + 1, y + a)); sc[x + 1][y + a] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (sc[x][y - 1] <= ssc[x][y - 1] && sc[x][y - 1] != -1) {\n\t\t\tque.push(MP(x, y - 1)); que1.push(MP(x, y - 1)); sc[x][y - 1] = -1;\n\t\t\t}\n\t\t\tif (sc[x][y + 1] <= ssc[x][y + 1] && sc[x][y + 1] != -1) {\n\t\t\t\tque.push(MP(x, y + 1)); que1.push(MP(x, y + 1)); sc[x][y + 1] = -1;\n\t\t\t}\n\t\t}\n\t\tans++;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define\t_USE_MATH_DEFINES\n#include <iostream>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cfloat>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <string>\n#include <set>\nusing namespace std;\nchar s[1001][1001];\nint co(int i,int j){\n\tif(s[i][j]=='.')\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\nint main(){\n\t\n\tstack<int> x;\n\tstack<int> y;\n\tint h,w;\n\tint count=0;\n\tcin>>h>>w;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tcin>>s[i][j];\n\t\t}\n\t}\n\t\n\twhile(1){\n\t\tbool f=false;\n\t\t\n\t\tfor(int i=1;i<h-1;i++){\n\t\t\tfor(int j=1;j<w-1;j++){\n\t\t\t\tif(s[i][j]!='.'){\n\t\t\t\t\tint sum=co(i-1,j-1)+co(i-1,j)+co(i-1,j+1)+co(i,j-1)+co(i,j+1)+co(i+1,j-1)+co(i+1,j)+co(i+1,j+1);\n\t\t\t\t\tif(sum>=s[i][j]-'0'){\n\t\t\t\t\t\tx.push(j);\n\t\t\t\t\t\ty.push(i);\n\t\t\t\t\t\tf=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(f){\n\t\t\twhile(!x.empty()){\n\t\t\t\ts[y.top()][x.top()]='.';\n\t\t\t\ty.pop();\n\t\t\t\tx.pop();\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tbreak;\n\t\t\n\t\tcount++;\n\t\t\n\t}\n\t\n\tcout<<count<<endl;\n\t\n\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<queue>\nusing namespace std;\nint sand[1005][1005];\nconst int MAX=1007;\nqueue<int> q1,q2;\n\nint main(){\n\tstring sa;\n\tint i,j,k,l;\n\tint n,m;\n\tint a,b,c,d;\n\tcin>>n>>m;\n\tfor(i=0;i<n;i++){\n\t\tcin>>sa;\n\t\tfor(j=0;j<m;j++){\n\t\t\tif(sa[j]=='.'){\n\t\t\t\tfor(k=-1;k<=1;k++){\n\t\t\t\t\tfor(l=-1;l<=1;l++){\n\t\t\t\t\t\tif(i+k>0 && i+k<n-1 && j+l>0 && j+l<m-1){\n\t\t\t\t\t\t\tq1.push((i+k)*MAX+(j+l));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(char ca='1',k=1;k<10;k++,ca++){\n\t\t\t\tif(sa[j]==ca){\n\t\t\t\t\tsand[i][j]=k;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=0;;i++){\n\t\ta=q1.size();\n\t\tfor(j=0;j<a;j++){\n\t\t\tc=q1.front(),q1.pop();\n\t\t\tb=c/MAX,c%=MAX;\n\t\t\tif(sand[b][c]==0)continue;\n\t\t\td=0;\n\t\t\tfor(k=-1;k<=1;k++){\n\t\t\t\tfor(l=-1;l<=1;l++){\n\t\t\t\t\tif(sand[b+k][c+l]==0)d++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(d<sand[b][c])continue;\n\t\t\tq2.push(b*MAX+c);\n\t\t\tfor(k=-1;k<=1;k++){\n\t\t\t\tfor(l=-1;l<=1;l++){\n\t\t\t\t\tif(sand[b+k][c+l]==0)continue;\n\t\t\t\t\tq1.push((b+k)*MAX+(c+l));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(q2.empty())break;\n\t\twhile(!q2.empty()){\n\t\t\tc=q2.front(),q2.pop();\n\t\t\tb=c/MAX,c%=MAX;\n\t\t\tsand[b][c]=0;\n\t\t}\n\t}\n\tcout<<i<<endl;\n\treturn 0;\n}\n\t\t\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstring>\nusing namespace std;\n\n#define MAX 1001\n\nint main(){\n\tstring S;\n\tint n,m,t,sum,a;\n\tsum=0;\n\tshort x[MAX][MAX];\n\tbool y[MAX][MAX];\n\tshort z[MAX][MAX];\n\tshort v[MAX][MAX];\n\tmemset(x,0,sizeof(x));\n\tmemset(z,0,sizeof(z));\n\tchar T[10]={'.','1','2','3','4','5','6','7','8','9'};\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>S;\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tfor(int k=0;k<10;k++){\n\t\t\t\tif(S[j-1]==T[k]){\n\t\t\t\t\tx[i][j]=k;\n\t\t\t\t\tif(k==0){\n\t\t\t\t\t\tfor(int l=-1;l<=1;l++){\n\t\t\t\t\t\t\tfor(int o=-1;o<=1;o++){\n\t\t\t\t\t\t\t\tz[i+l][j+o] += 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\twhile(true){\n\t\tt=0;\n\t\tsum++;\n\t\tmemset(v,0,sizeof(v));\n\t\tmemset(y,false,sizeof(y));\n\t\tfor(int i=2;i<n;i++){\n\t\t\tfor(int j=2;j<m;j++){\n\t\t\t\tif(x[i][j]>=1 && z[i][j]>=x[i][j]){\n\t\t\t\t\ta=0;\n\t\t\t\t\ty[i][j]=true;\n\t\t\t\t\tt++;\n\t\t\t\t\tfor(int l=-1;l<=1;l++){\n\t\t\t\t\t\tfor(int o=-1;o<=1;o++){\n\t\t\t\t\t\t\tv[i+l][j+o]+= 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(t==0){\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i=2;i<n;i++){\n\t\t\tfor(int j=2;j<m;j++){\n\t\t\t\tif(y[i][j]==true){\n\t\t\t\t\tx[i][j]=0;\n\t\t\t\t}\n\t\t\t\tz[i][j] += v[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tcout<<sum-1<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\nusing namespace std;\n#define INF 1000000000\ntypedef pair<int,int> P;\ntypedef long long int ll;\n\nint main(){\n\tint h,w;\n\tchar mas[1001][1001];\n\tvector<P> cas;\n\tcin >> h >> w;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tcin >> mas[i][j];\n\t\t\tif(mas[i][j] != '.' && mas[i][j] != '9'){\n\t\t\t\tcas.push_back(P(i,j));\n\t\t\t}\n\t\t}\n\t}\n\tbool flg = false;\n\tint ans = -1;\n\twhile(1){\n\t\tint now = 0;\n\t\tif(flg) break;\n\t\tflg = true;\n\t\tans++;\n\t\tint len = cas.size();\n\t\tvector<P> change;\n\t\twhile(len!=now){\n\t\t\tP p = cas[now];\n\t\t\tint y = p.first; int x = p.second;\n\t\t\tint power = mas[y][x] - '0';\n\t\t\tint cou = 0;\n\t\t\tfor(int i=-1;i<2;i++){\n\t\t\t\tif(power == cou) break;\n\t\t\t\tfor(int j=-1;j<2;j++){\n\t\t\t\t\tif(power == cou) break;\n\t\t\t\t\tint nx = x + i;\n\t\t\t\t\tint ny = y + j;\n\t\t\t\t\tif(mas[ny][nx] == '.'){\n\t\t\t\t\t\tcou++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(power == cou){\n\t\t\t\tchange.push_back(P(y,x));\n\t\t\t\tcas.erase(cas.begin()+now);\n\t\t\t\tflg = false;\n\t\t\t\tlen = cas.size();\n\t\t\t}\n\t\t\telse now++;\n\t\t}\n\t\tint c = change.size();\n\t\tfor(int i=0;i<c;i++){\n\t\t\tP p = change[i];\n\t\t\tint y = p.first;\n\t\t\tint x = p.second;\n\t\t\tmas[y][x] = '.';\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {+0,+1,+1,+1,+0,-1,-1,-1};\nstatic const int ty[] = {-1,-1,+0,+1,+1,+1,+0,-1};\n\nchar stage[1001][1001];\nchar buffer[1001][1001];\n\nint main(){\n  int H,W;\n  while(~scanf(\"%d %d\",&H,&W)){\n    for(int y = 0; y < H; y++){\n      char line[1001];\n      scanf(\"%s\",line);\n      for(int x = 0; x < W; x++){\n        stage[y][x] = line[x];\n        buffer[y][x] = line[x];\n      }\n    }\n\n    int res = 0;\n    for(int round = 0; round < 10010; round++){\n      bool is_over = true;\n      for(int y = 0; y < H; y++){\n        for(int x = 0; x < W; x++){\n          if(stage[y][x] == '.') continue;\n          int strongness = stage[y][x] - '0';\n\n          int count = 0;\n          for(int i = 0; i < 8; i++){\n            int dx = x + tx[i];\n            int dy = y + ty[i];\n            if(dx < 0 || dx >= W || dy < 0 || dy >= H) continue;\n            if(stage[dy][dx] == '.'){\n              count++;\n            }\n          }\n\n          if(count >= strongness){\n            is_over = false;\n            buffer[y][x] = '.';\n          }\n        }\n      }\n      if(is_over){\n        res = round;\n        break;\n      }\n      memcpy(stage,buffer,sizeof(char)*1001*1001);\n    }\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<queue>\n#define MP make_pair\nusing namespace std;\nlong long int sc[1001][1001],ssc[1001][1001];\nchar c[1001];\nint main()\n{\n\tint h, w, cnt = 0, ans = 0, n;\n\tint x, y;\n\tpair<int, int> p;\n\tqueue< pair<int, int> > que;\n\tqueue< pair<int, int> >que1;\n\tscanf(\"%d%d\", &h, &w);\n\tfor (int i = 0; i < h; i++)\n\t{\n\t\tscanf(\"%s\", c);\n\t\tfor (int j = 0; j < w; j++)\n\t\t{\n\n\t\t\tif (c[j] == '.')\n\t\t\t\tsc[i][j] = -1;\n\t\t\telse\n\t\t\t\tsc[i][j] = c[j] - 48;\n\t\t}\n\t}\n\tfor (int i = 0; i < h; i++)\n\t{\n\t\tfor (int j = 0; j < w; j++)\n\t\t{\n\t\t\tif (i != 0)\n\t\t\t{\n\t\t\t\tfor (int a = -1; a < 2; a++)\n\t\t\t\t{\n\t\t\t\t\tif (sc[i - 1][j + a] == -1)\n\t\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i != h - 1)\n\t\t\t{\n\t\t\t\tfor (int a = -1; a < 2; a++)\n\t\t\t\t{\n\t\t\t\t\tif (sc[i + 1][j + a] == -1)\n\t\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (sc[i][j - 1] == -1 && j != 0)\n\t\t\t\tcnt++;\n\t\t\tif (sc[i][j + 1] == -1 && j != w - 1)\n\t\t\t\tcnt++;\n\t\t\tssc[i][j] = cnt;\n\t\t\tcnt = 0;\n\t\t}\n\t}\n\tfor (int i = 0; i < h; i++)\n\t{\n\n\t\tfor (int j = 0; j < w; j++)\n\t\t{\n\t\t\tif (sc[i][j] != -1)\n\t\t\t{\n\t\t\t\tif (sc[i][j] <= ssc[i][j])\n\t\t\t\t\tque.push(MP(i, j));\n\t\t\t\telse if (sc[i][j] != 9)\n\t\t\t\t\tque1.push(MP(i, j));\n\t\t\t}\n\t\t}\n\t}\n\twhile (!que.empty())\n\t{\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tx = que.front().first;\n\t\t\ty = que.front().second;\n\t\t\tque.pop();\n\t\t\tfor (int a = -1; a < 2; a++)\n\t\t\t{\n\t\t\t\tssc[x - 1][y + a]++;\n\t\t\t\tssc[x + 1][y + a]++;\n\t\t\t}\n\t\t\tssc[x][y - 1]++;\n\t\t\tssc[x][y + 1]++;\n\t\t}\n\t\tn = que1.size();\n\t\tfor (int i=0;i<n;i++)\n\t\t{\n\t\t\tx = que1.front().first;\n\t\t\ty = que1.front().second;\n\t\t\tque1.pop();\n\t\t\tif (sc[x][y] <= ssc[x][y])\n\t\t\t\tque.push(MP(x, y));\n\t\t\telse if (sc[x][y] != 9)\n\t\t\t\tque1.push(MP(x, y));\n\t\t}\n\t\tans++;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n\n\n#define max(a,b) ((a) > (b) ? (a) : (b))\n#define min(a,b) ((a) > (b) ? (b) : (a))\nchar st[64][64], sts[64][64];\nint H, W;\n\ninline void copy(char a[64][64], char b[64][64]) {\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\ta[i][j] = b[i][j];\n\t\t}\n\t}\n}\n\ninline bool is_castle(char a) {\n\treturn a != '.';\n}\n\ninline int conv(char a) {\n\treturn a - '0';\n}\n\ninline bool state(int x, int y) {\n\tint c = 0;\n\tfor (int i = max(x - 1, 0); i < min(x + 2, W); i++) {\n\t\tfor (int j = max(y - 1, 0); j < min(y + 2, H); j++) {\n\t\t\tif (st[i][j] == '.')\n\t\t\t\tc++;\n\t\t}\n\t}\n\treturn c >= conv(st[x][y]);\n\n}\n\nbool collapse(int x, int y) {\n\tif (is_castle(st[x][y]) && state(x,y)) {\n\t\tsts[x][y] = '.';\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool wave() {\n\tbool e = false;\n\tcopy(sts, st);\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\te = collapse(i, j) ? true : e;\n\t\t}\n\t}\n\tcopy(st, sts);\n\treturn e;\n}\n\nint main(){\n\tscanf(\"%d%d\", &H, &W);\n\tfor (int i = 0; i < H; i++) {\n\t\tscanf(\"%s\", st[i]);\n\t}\n\tfor (int i = 0;;i++) {\n\t\tif (!wave()) {\n\t\t\tprintf(\"%d\\n\", i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#define F first\n#define S second\n#define MP make_pair\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PP;\nchar c[1000][1000];\nbool flag[1000][1000];\nint w, h, ans;\nint cdt[1000][1000];\nqueue<PP> que, que2;\n\nvoid fanc(PP p)\n{\n  for(int i = -1; i < 2; i++)\n  {\n    for(int j = -1; j < 2; j++)\n    {\n      if(!i && !j) continue;\n      if(p.F.F + i < h && p.F.F + i < h && p.F.S + j < w && p.F.S + j < w)\n      {\n        cdt[p.F.F + i][p.F.S + j]++;\n        if(cdt[p.F.F + i][p.F.S + j] == c[p.F.F + i][p.F.S + j] - '0')\n        {\n          que.push(MP(MP(p.F.F + i, p.F.S + j), p.S));\n        }\n      }\n    }\n  }\n}\nvoid bfs()\n{\n  while(!que.empty())\n  {\n    fanc(MP(que.front().F, que.front().S + 1));\n    ans = max(ans, que.front().S);\n    que.pop();\n  }\n}\nint main()\n{\n  cin >> h >> w;\n  for(int i = 0; i < h; i++)\n  {\n    for(int j = 0; j < w; j++)\n    {\n      cin >> c[i][j];\n    }\n  }\n  for(int i = 0; i < h; i++)\n  {\n    for(int j = 0; j < w; j++)\n    {\n      if(c[i][j] == '.')\n      {\n        fanc(MP(MP(i, j), 1));\n      }\n    }\n  }\n  bfs();\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nint mx[8] = {1,1,1,0,0,-1,-1,-1};\nint my[8] = {1,0,-1,1,-1,1,0,-1};\n\nint m[100][100];\nbool field[100][100];\nint h, w;\nint cnt;\n\nvoid nami(){\n  \n  for(int i=0 ; i < h ; i++){\n    for(int j=0 ; j < w ; j++){\n      field[i][j]=false;\n    }\n  }\n  \n  for(int i=0 ; i < h ; i++){\n    for(int j=0 ; j < w ; j++){\n      if(m[i][j] != 10){\t\n\tint cnt2=0;\n\tfor(int k=0 ; k < 8 ; k++){\n\t  int nx=mx[k]+j;\n\t  int ny=my[k]+i;\n\t  if(m[ny][nx] == 10)cnt2++;\n\t}\n\tif(cnt2 >= m[i][j]){\n\t  field[i][j]=true;\n\t  cnt++;\n\t}      \n      }\n    }\n  }\n\n  for(int i=0 ; i < h ; i++){\n     for(int j=0 ; j < w ; j++){\n       if(field[i][j])m[i][j]=10;\n     }\n  }\n  \n}\n\nint main(){\n  \n  cin >> h >> w;\n  \n  string str[h];\n  \n  for(int i = 0; i < h; i++)cin >>str[i];\n  \n  for(int i=0 ; i < h ; i++){\n    for(int j=0 ; j < w ; j++){\n      if(str[i][j] == '.'){\n\tm[i][j]=10;\n      }else{\n\tm[i][j]=str[i][j]-'0';\n      }\n    }\n  }\n   \n  int ans=0;\n  while(1){\n    cnt=0;\n    nami();\n    if(cnt==0)break;\n    ans++;\n  }\n  \n  cout <<ans<<endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define Rep(i, a, b) for(int i = (a); i < (b); i++)\n#define rep(i, n) Rep(i, 0, n)\n\nint movX[8] = {-1, 0, 1,-1, 1,-1, 0, 1};\nint movY[8] = {-1,-1,-1, 0, 0, 1, 1, 1};\ntypedef pair<int, int> pii;\n\ntemplate<class T> T read() {\n\tT t;\n\tcin >> t;\n\treturn t;\n}\n\nint main(){\n\tint h=read<int>(),w=read<int>();\n\tint mp[h][w];\n\trep(i,h) rep(j,w){\n\t\tchar c=read<char>();\n\t\tif(c=='.'){\n\t\t\tmp[i][j]=0;\t\t\t\n\t\t}else{\n\t\t\tmp[i][j]=c-'0';\n\t\t}\n\t}\n\tint around[h][w];\n\tRep(i, 1, h-1){\n\t\tRep(j, 1, w-1){\n\t\t\tint a = 0;\n\t\t\trep(k,8) {\n\t\t\t\tint x = i+movX[k];\n\t\t\t\tint y = j+movY[k];\n\t\t\t\tif(!mp[x][y]){\n\t\t\t\t\ta++;\n\t\t\t\t}\n\t\t\t}\n\t\t\taround[i][j]=a;\n\t\t}\n\t}\n\t\n\t\n\tvector<pii> list;\n\tRep(i, 1, h-1){\n\t\tRep(j, 1, w-1){\n\t\t\tif(mp[i][j]>0 && around[i][j]>=mp[i][j]){\n\t\t\t\tlist.push_back(pii(i,j)); \n\t\t\t}\n\t\t}\n\t}\n\tif(list.size()==0){\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\tfor(vector<pii>::iterator it=list.begin();it!=list.end();it++){\n\t\tint i = it->first, j = it->second;\n\t\tmp[i][j] = 0;\n\t\trep(k,8) {\n\t\t\tint x = i+movX[k];\n\t\t\tint y = j+movY[k];\n\t\t\taround[x][y]++;\n\t\t}\n\t\t// printf(\"(%d, %d)\\n\",i,j);\n\t}\n\t// printf(\"=============\\n\");\n\t\n\tint count = 1;\n\twhile(true){\n\t\tvector<pii> list2;\n\t\tfor(vector<pii>::iterator it=list.begin();it!=list.end();it++){\n\t\t\tint i = it->first, j = it->second;\n\t\t\t// cout << i << \" \" << j << endl;\n\t\t\trep(k,8) {\n\t\t\t\tint x = i+movX[k];\n\t\t\t\tint y = j+movY[k];\n\t\t\t\tif(mp[x][y]>0 && around[x][y]>=mp[x][y]){\n\t\t\t\t\tlist2.push_back(pii(x,y));\n\t\t\t\t\t// cout << \"    \" <<  i << \" \" << j << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(list2.size()==0){\n\t\t\tcout << count << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tcount++;\n\t\tfor(vector<pii>::iterator it=list2.begin();it!=list2.end();it++){\n\t\t\tint i = it->first, j = it->second;\n\t\t\tif(mp[i][j]){\n\t\t\t\tmp[i][j] = 0;\n\t\t\t\trep(k,8) {\n\t\t\t\t\tint x = i+movX[k];\n\t\t\t\t\tint y = j+movY[k];\n\t\t\t\t\taround[x][y]++;\n\t\t\t\t}\n\t\t\t\t// printf(\"(%d, %d)\\n\",i,j);\n\t\t\t}\n\t\t}\n\t\t// printf(\"=============\\n\");\n\t\tstd::vector<pii>().swap(list);\n\t\tlist = list2;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint h, w;\nint dy[8] = { 1, 1, 1, 0, 0,-1,-1,-1};\nint dx[8] = { 1, 0,-1, 1,-1, 1, 0,-1};\n\nbool can(int y, int x) {\n\tif(0 <= y && y < h && 0 <= x && x < w) return true;\n\treturn false;\n}\n\n\nint cnt[1005][1005];\nbool inQ[1005][1005], used[1005][1005];\n\nvoid printQ(queue<P> que) {\n\tcout << \" ---- in queue --- \" << endl;\n\twhile(que.size()) {\n\t\tP p = que.front();\n\t\tque.pop();\n\n\t\tcout << \"(\" << p.first << \",\" << p.second << \") \";\n\t}\n\tcout << endl;\n}\n\nint main() {\n\tcin >> h >> w;\n\n\tvector<string> s(h);\n\trep(i, h) cin >> s[i];\n\n\tmemset(cnt, 0, sizeof(cnt));\n\tmemset(used, 0, sizeof(used));\n\tmemset(inQ, 0, sizeof(inQ));\n\n\tqueue<P> que;\n\trep(i, h) {\n\t\trep(j, w) {\n\t\t\tif(s[i][j] != '.') {\n\t\t\t\trep(k, 8) {\n\t\t\t\t\tint y = i + dy[k];\n\t\t\t\t\tint x = j + dx[k];\n\t\t\t\t\tif(can(y, x) && s[y][x] == '.') {\n\t\t\t\t\t\tcnt[i][j]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(s[i][j] - '0' <= cnt[i][j]) {\n\t\t\t\t\tque.push(mp(i, j));\n\t\t\t\t\tused[i][j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\tint ans = 0;\n\twhile(que.size()) {\n\t\tqueue<P> tmp;\n\t\twhile(que.size()) {\n\t\t\tP p = que.front();\n\t\t\tque.pop();\n\n\t\t\trep(k, 8) {\n\t\t\t\tint y = p.first + dy[k];\n\t\t\t\tint x = p.second + dx[k];\n\n\t\t\t\tif(can(y, x)) {\n\t\t\t\t\tcnt[y][x]++;\n\t\t\t\t\tif(s[y][x] != '.' && (s[y][x] - '0') <= cnt[y][x] && !used[y][x]) {\n\t\t\t\t\t\tused[y][x] = true;\n\t\t\t\t\t\ttmp.push(mp(y, x));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile(tmp.size()) {\n\t\t\tP p = tmp.front();\n\t\t\ttmp.pop();\n\t\t\tque.push(p);\n\t\t}\n\n\t\tans++;\n\t}\n\n\t// rep(i, h) {\n\t// \trep(j, w) {\n\t// \t\tif(s[i][j] == '.') cout << s[i][j];\n\t// \t\telse {\n\t// \t\t\tif(used[i][j]) cout << \" \";\n\t// \t\t\telse cout << \"X\";\n\t// \t\t}\n\t// \t\tcout << \" \";\n\t// \t}\n\t// \tcout << endl;\n\t// }\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nint mx[8] = {1,1,1,0,0,-1,-1,-1};\nint my[8] = {1,0,-1,1,-1,1,0,-1};\n\nint m[10000][10000];\nbool field[10000][10000];\nint h, w;\nint cnt;\n\nvoid nami(){\n  \n  for(int i=0 ; i < h ; i++){\n    for(int j=0 ; j < w ; j++){\n      field[i][j]=false;\n    }\n  }\n  \n  for(int i=0 ; i < h ; i++){\n    for(int j=0 ; j < w ; j++){\n      if(m[i][j] != 10){\t\n\tint cnt2=0;\n\tfor(int k=0 ; k < 8 ; k++){\n\t  int nx=mx[k]+j;\n\t  int ny=my[k]+i;\n\t  if(m[ny][nx] == 10)cnt2++;\n\t}\n\tif(cnt2 >= m[i][j]){\n\t  field[i][j]=true;\n\t  cnt++;\n\t}      \n      }\n    }\n  }\n\n  for(int i=0 ; i < h ; i++){\n     for(int j=0 ; j < w ; j++){\n       if(field[i][j])m[i][j]=10;\n     }\n  }\n  \n}\n\nint main(){\n  \n  cin >> h >> w;\n  \n  string str[h];\n  \n  for(int i = 0; i < h; i++)cin >>str[i];\n  \n  for(int i=0 ; i < h ; i++){\n    for(int j=0 ; j < w ; j++){\n      if(str[i][j] == '.'){\n\tm[i][j]=10;\n      }else{\n\tm[i][j]=str[i][j]-'0';\n      }\n    }\n  }\n   \n  int ans=0;\n  while(1){\n    cnt=0;\n    nami();\n    if(cnt==0)break;\n    ans++;\n  }\n  \n  cout <<ans<<endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <queue>\nusing namespace std;\n\nconst int MAX_SIZE = 1000;\ntypedef pair<int, int> P;\ntypedef pair<int, P> Q;\n\nint calc(int f[][MAX_SIZE], queue<Q> q, int H, int W) {\n  P d[] = {P(-1, -1), P(-1, 0), P(-1, 1), P(0, -1), P(0, 1), P(1, -1), P(1, 0), P(1, 1)};\n  int n = 0;\n  while (q.size()) {\n    int c = q.front().first;\n    P p = q.front().second;\n    q.pop();\n    if (c > n) n++;\n    for (int k = 0; k < 8; ++k) {\n      int i = p.first  + d[k].first;\n      int j = p.second + d[k].second;\n      if (i >= 0 && i < H && j >= 0 && j < W && --f[i][j] == 0) {\n        q.push(Q(c + 1, P(i, j)));\n      };\n    }\n  }\n  return n;\n}\n\nint main() {\n  int H, W;\n  int f[MAX_SIZE][MAX_SIZE];\n  queue<Q> q;\n  char c[MAX_SIZE];\n\n  cin >> H >> W;\n  for (int i = 0; i < H; ++i) {\n    cin >> c;\n    for (int j = 0; j < W; ++j) {\n      if (c[j] == '.') {\n        f[i][j] = 0;\n        q.push(Q(0, P(i, j)));\n      } else {\n        f[i][j] = c[j] - '0';\n      }\n    }\n  }\n  cout << calc(f, q, H, W) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nint mx[8] = {1,1,1,0,0,-1,-1,-1};\nint my[8] = {1,0,-1,1,-1,1,0,-1};\n\nint m[55][55];\nbool field[55][55];\nint h, w;\nint cnt;\n\nvoid nami(){\n  \n  for(int i=0 ; i < h ; i++){\n    for(int j=0 ; j < w ; j++){\n      field[i][j]=false;\n    }\n  }\n  \n  for(int i=0 ; i < h ; i++){\n    for(int j=0 ; j < w ; j++){\n      if(m[i][j] != 10){\t\n\tint cnt2=0;\n\tfor(int k=0 ; k < 8 ; k++){\n\t  int nx=mx[k]+j;\n\t  int ny=my[k]+i;\n\t  if(m[ny][nx] == 10)cnt2++;\n\t}\n\tif(cnt2 >= m[i][j]){\n\t  field[i][j]=true;\n\t  cnt++;\n\t}      \n      }\n    }\n  }\n\n  for(int i=0 ; i < h ; i++){\n     for(int j=0 ; j < w ; j++){\n       if(field[i][j])m[i][j]=10;\n     }\n  }\n  \n}\n\nint main(){\n  \n  cin >> h >> w;\n  \n  string str[h];\n  \n  for(int i = 0; i < h; i++)cin >>str[i];\n  \n  for(int i=0 ; i < h ; i++){\n    for(int j=0 ; j < w ; j++){\n      if(str[i][j] == '.'){\n\tm[i][j]=10;\n      }else{\n\tm[i][j]=str[i][j]-'0';\n      }\n    }\n  }\n   \n  int ans=0;\n  while(1){\n    cnt=0;\n    nami();\n    if(cnt==0)break;\n    ans++;\n  }\n  \n  cout <<ans<<endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<queue>\nusing namespace std;\nstruct k{\n\tint x,y,c;\n};\nqueue<k> q;\nint m[1002][1002],p[1002][1002];\nint main(void) {\n\tk g,k;\n\tchar d;\n\tint h,w,i,j,z,dx[8]={0,0,-1,1,-1,1,-1,1},dy[8]={-1,1,0,0,-1,-1,1,1};\n\tcin >> h >> w;\n\tfor (i = 0; i <= h+1; i++) {\n\t\tfor (j = 0; j <= w+1; j++)\n\t\t\tm[i][j]=0;\n\t}\n\tfor (i = 1; i <= h; i++) {\n\t\tfor (j = 1; j <= w; j++){\n\t\t\tcin >> d;\n\t\t\tswitch(d){\n\t\t\t\tcase '.':\n\t\t\t\t\tm[i][j]=0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '1':\n\t\t\t\t\tm[i][j]=1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '2':\n\t\t\t\t\tm[i][j]=2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '3':\n\t\t\t\t\tm[i][j]=3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '4':\n\t\t\t\t\tm[i][j]=4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '5':\n\t\t\t\t\tm[i][j]=5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '6':\n\t\t\t\t\tm[i][j]=6;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '7':\n\t\t\t\t\tm[i][j]=7;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '8':\n\t\t\t\t\tm[i][j]=8;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '9':\n\t\t\t\t\tm[i][j]=9;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=0;j<=w;j++){\n\t\t\t\tif(p[i][j]<=0)\n\t\t\t\t\tp[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=0;j<=w;j++){\n\t\t\t\tif(m[i][j]==0){\n\t\t\t\t\tfor(z=0;z!=8;z++)\n\t\t\t\t\t\tp[i+dy[z]][j+dx[z]]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=0;j<=w;j++){\n\t\t\t\tif(m[i][j]!=0&&m[i][j]<=p[i][j]){\n\t\t\t\t\tm[i][j]=0;\n\t\t\t\t\tg.c=1;\n\t\t\t\t\tg.x=i;\n\t\t\t\t\tg.y=j;\n\t\t\t\t\tq.push(g);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(!q.empty()){\n\t\t\tg=q.front();\n\t\t//\tcout<<g.x<<\" \"<<g.y<<\" \"<<g.c<<endl;\n\t\t\tq.pop();\n\t\t\tfor(i=0;i!=8;i++){\n\t\t\t\tp[g.x+dx[i]][g.y+dy[i]]++;\n\t\t\t\tif(m[g.x+dx[i]][g.y+dy[i]]-p[g.x+dx[i]][g.y+dy[i]]==0){\n\t\t\t\t\tm[g.x+dx[i]][g.y+dy[i]]=0;\n\t\t\t\t\tk.c=g.c+1;\n\t\t\t\t\tk.x=g.x+dx[i];\n\t\t\t\t\tk.y=g.y+dy[i];\n\t\t\t\t\tq.push(k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tcout<<g.c<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint H, W;\nint field[1010][1010];\nint ctr[1010][1010];\nint ctr_copy[1010][1010];\n\nint count_emp(int x, int y) {\n  int c = 0;\n  for (int xs=-1; xs<=1; xs++) {\n    for (int ys=-1; ys<=1; ys++) {\n      if (xs == 0 && ys == 0) continue;\n      if (field[x+xs][y+ys] == 0) c++;\n    }\n  }\n  return c;\n}\nvoid re_count(int x, int y) {\n  for (int xs=-1; xs<=1; xs++) {\n    for (int ys=-1; ys<=1; ys++) {\n      if (xs == 0 && ys == 0) continue;\n      ctr[x+xs][y+ys]++;\n    }\n  }\n}\n\n\nint main() {\n  cin >> H >> W;\n  for (int y=0; y<H; y++) {\n    for (int x=0; x<W; x++) {\n      char c;\n      cin >> c;\n      int t = 0;\n      if (c != '.') t = (int)c - (int)'0';\n      field[x][y] = t;\n    }\n  }\n\n  // count all\n  for (int x=1; x<W-1; x++) {\n    for (int y=1; y<H-1; y++) {\n      ctr[x][y] = count_emp(x, y);\n    }\n  }\n\n  int ans = 0;\n  while (true) {\n    // copy ctr\n    for (int x=1; x<W-1; x++) {\n      for (int y=1; y<H-1; y++) {\n        ctr_copy[x][y] = ctr[x][y];\n      }\n    }\n    bool changed = false;\n    for (int x=1; x<W-1; x++) {\n      for (int y=1; y<H-1; y++) {\n        int t = field[x][y];\n        if (t > 0 && ctr_copy[x][y] >= t) {\n          field[x][y] = 0;\n          re_count(x, y);\n          changed = true;\n        }\n      }\n    }\n    if (!changed) break;\n    ans += 1;\n  }\n  cout << ans << \"\\n\";\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <tuple>\n\nvoid solve() {\n    int h, w;\n    std::cin >> h >> w;\n\n    std::vector<std::vector<int>> dss(h, std::vector<int>(w));\n    for (auto& ds : dss) {\n        for (auto& d : ds) {\n            char c;\n            std::cin >> c;\n            d = (c == '.' ? 0 : c - '0');\n        }\n    }\n\n    std::queue<std::tuple<int, int, int>> que;\n    for (int x = 0; x < h; ++x) {\n        for (int y = 0; y < w; ++y) {\n            if (dss[x][y] == 0) que.emplace(x, y, 0);\n        }\n    }\n\n    int ans = 0;\n    while (!que.empty()) {\n        int x, y, t;\n        std::tie(x, y, t) = que.front();\n        que.pop();\n        ans = t;\n\n        for (int dx = -1; dx <= 1; ++dx) {\n            for (int dy = -1; dy <= 1; ++dy) {\n                int nx = x + dx, ny = y + dy;\n                if (nx < 0 || h <= nx || ny < 0 || w <= ny) continue;\n                if (--dss[nx][ny] == 0) {\n                    que.emplace(nx, ny, t + 1);\n                }\n            }\n        }\n    }\n\n    std::cout << ans << std::endl;\n}\n\nint main() {\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    solve();\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstring>\nusing namespace std;\n\nint main(){\n\tstring S;\n\tint n,m,t,sum,a;\n\tsum=0;\n\tint x[1001][1001];\n\tbool y[1001][1001];\n\tbool z[1001][1001];\n\tmemset(x,0,sizeof(x));\n\tmemset(z,false,sizeof(z));\n\tchar T[10]={'.','1','2','3','4','5','6','7','8','9'};\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>S;\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tfor(int k=0;k<10;k++){\n\t\t\t\tif(S[j-1]==T[k]){\n\t\t\t\t\tx[i][j]=k;\n\t\t\t\t\tif(k==0){\n\t\t\t\t\t\tfor(int l=-1;l<=1;l++){\n\t\t\t\t\t\t\tfor(int o=-1;o<=1;o++){\n\t\t\t\t\t\t\t\tz[i+l][j+o]=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\twhile(true){\n\t\tt=0;\n\t\tsum++;\n\t\tmemset(y,false,sizeof(y));\n\t\tfor(int i=2;i<n;i++){\n\t\t\tfor(int j=2;j<m;j++){\n\t\t\t\tif(x[i][j]>=1 && z[i][j]==true){\n\t\t\t\t\ta=0;\n\t\t\t\t\tfor(int k=-1;k<=1;k++){\n\t\t\t\t\t\tfor(int l=-1;l<=1;l++){\n\t\t\t\t\t\t\tif(k!=0 || l!=0){\n\t\t\t\t\t\t\t\tif(x[i+k][j+l]==0){\n\t\t\t\t\t\t\t\t\ta++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(a>=x[i][j]){\n\t\t\t\t\t\ty[i][j]=true;\n\t\t\t\t\t\tt++;\n\t\t\t\t\t\tfor(int l=-1;l<=1;l++){\n\t\t\t\t\t\t\tfor(int o=-1;o<=1;o++){\n\t\t\t\t\t\t\t\tz[i+l][j+o]=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\t\n\t\t}\n\t\tif(t==0){\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i=2;i<n;i++){\n\t\t\tfor(int j=2;j<m;j++){\n\t\t\t\tif(y[i][j]==true){\n\t\t\t\t\tx[i][j]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<sum-1<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\ntypedef pair< int, int > pii;\n\nconst int dx[8] = {0,1,1,1,0,-1,-1,-1}, dy[8] = {-1,-1,0,1,1,1,0,-1};\n\nint H, W, counter[1010][1010];\nstring grid[1010];\n\nint main() {\n\tcin >> H >> W;\n\tfor_(i,0,H) cin >> grid[i];\n\t\n\tqueue< pii > cur_que;\n\t\n\tfor_(y,0,H) for_(x,0,W) {\n\t\tcounter[y][x] = -1;\n\t\tif (grid[y][x] == '.') continue;\n\t\tcounter[y][x] = grid[y][x] - '0';\n\t\t\n\t\tfor_(d,0,8) {\n\t\t\tint xx = x + dx[d], yy = y + dy[d];\n\t\t\tif (grid[yy][xx] == '.') --counter[y][x];\n\t\t}\n\t\t\n\t\tif (counter[y][x] == 0) cur_que.push(pii(x, y));\n\t}\n\t\n\tqueue< pii > nxt_que;\n\t\n\tint ans = 0;\n\t\n\twhile (!cur_que.empty()) {\n\t\twhile (!cur_que.empty()) {\n\t\t\tpii p = cur_que.front(); cur_que.pop();\n\t\t\tint x = p.first, y = p.second;\n\t\t\tassert(grid[y][x] != '.');\n\t\t\tgrid[y][x] = '.';\n\t\t\t\n\t\t\tfor_(d,0,8) {\n\t\t\t\tint xx = x + dx[d], yy = y + dy[d];\n\t\t\t\tif (grid[yy][xx] == '.') continue;\n\t\t\t\t--counter[yy][xx];\n\t\t\t\tif (counter[yy][xx] == 0) nxt_que.push(pii(xx, yy));\n\t\t\t}\n\t\t}\n\t\t\n\t\t++ans;\n\t\tswap(cur_que, nxt_que);\n\t}\n\t\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n\nusing namespace std;\n\nint h, w, map[1001][1001];\n\nstruct pos {\n\tint x, y;\n};\n\nstd::queue<pair<pos, int> > que;\n\nint check(int _X, int _Y) {\n\tint count = 0;\n\tfor (int i = -1;i <= 1;i++) {\n\t\tfor (int j = -1;j <= 1;j++) {\n\t\t\tif (map[_X + i][_Y + j] == -1)count++;\n\t\t}\n\t}\n\treturn count;\n}\n\nbool Cl(int _X, int _Y) { return check(_X, _Y) >= map[_X][_Y]; };\n\nvoid Break(int _x, int _y, int _wave) {\n\tpos p;\n\tp.x = _x, p.y = _y;\n\tque.push(make_pair(p, _wave));\n}\n\nint main() {\n\tcin >> h >> w;\n\tfor (int i = 1;i <= h;i++) {\n\t\tfor (int j = 1;j <= w;j++) {\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tif (c == '.')map[i][j] = -1;\n\t\t\telse map[i][j] = c - '0';\n\t\t}\n\t}\n\tfor (int i = 2;i <= h - 1;i++) {\n\t\tfor (int j = 2;j <= w - 1;j++) {\n\t\t\tif (Cl(i, j) && map[i][j] !=-1)map[i][j] = 0, Break(i, j, 1);\n\t\t\telse if(map[i][j]!=-1){\n\t\t\t\tmap[i][j] -= check(i, j);\n\t\t\t}\n\t\t}\n\t}\n\tint big = 0;\n\twhile (que.size()) {\n\t\tpair<pos, int> P = que.front();\n\t\tque.pop();\n\t\tpos po;\n\t\tpo = P.first;\n\t\tif (map[po.x][po.y] == -1)continue;\n\t\tbig = std::max(big, P.second);\n\t\tmap[po.x][po.y] = -1;\n\t\tfor (int i = -1;i <= 1;i++) {\n\t\t\tfor (int j = -1;j <= 1;j++) {\n\t\t\t\tpos tep;\n\t\t\t\ttep.x = po.x + i, tep.y = po.y + j;\n\t\t\t\tif (map[tep.x][tep.y] > 0)map[tep.x][tep.y]--;\n\t\t\t\tif (map[tep.x][tep.y] == 0)que.push(make_pair(tep, ++P.second));\n\t\t\t}\n\t\t}\n\t}\n\tcout << big << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"avx\")\n#define all(x) (x).begin(),(x).end()\n#define rep(i,n) for(int (i)=0;i<(n);i++)\n#define rrep(i,n) for(int (i)=1;i<=(n);i++)\n#define REP(i,m,n) for(int (i)=(m);(i)<(n);(i)++)\n#define MOD 1000000007\n#define INF 1e18\n#define int long long\n#define endl \"\\n\"\n#define yorn(f) puts((f)?\"Yes\":\"No\")\n#define YORN(f) puts((f)?\"YES\":\"NO\")\ntypedef long long ll;\ntypedef pair<int, int> P;\nint gcd(int a,int b){return b?gcd(b,a%b):a;};\nint lcm(int a,int b){return a/gcd(a,b)*b;};\nint mod(int a,int b){return (a+b-1)/b;};\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N],const T &val){std::fill((T*)array,(T*)(array+N),val);}\ntemplate<class T>inline bool chmax(T& a,T b){if(a<b){a=b;return true;}return false;};\ntemplate<class T>inline bool chmin(T& a,T b){if(a>b){a=b;return true;}return false;};\n\nint h, w;\nint fld[1001][1001];\nint sea[1001][1001];\nqueue<P> que[2];\nconst int dx[] = {-1, -1, -1, 0, 0, 1, 1, 1};\nconst int dy[] = {-1, 0, 1, -1, 1, -1, 0, 1};\n\nbool wave(bool flag) {\n\tif(que[flag].empty()) return 0;\n\twhile(!que[flag].empty()) {\n\t\tP p = que[flag].front();\n\t\tque[flag].pop();\n\t\trep(i, 8) {\n\t\t\tint nx = p.first + dx[i];\n\t\t\tint ny = p.second + dy[i];\n\t\t\tsea[ny][nx]++;\n\t\t\tif(fld[ny][nx] != 0 && fld[ny][nx] == sea[ny][nx]) {\n\t\t\t\tque[!flag].push(P(nx, ny));\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}\n\nsigned main() {\n\tcin.tie(0);\n\tcout.tie(0);\n\tios::sync_with_stdio(false);\n\t//cout << fixed << setprecision(15);\n\t\n\tcin >> h >> w;\n\trep(i, h) {\n\t\tstring s;\n\t\tcin >> s;\n\t\trep(j, w) {\n\t\t\tif(s[j] == '.') fld[i][j] = 0;\n\t\t\telse fld[i][j] = s[j] - '0';\n\t\t}\n\t}\n\n\tREP(i, 1, h-1) {\n\t\tREP(j, 1, w-1) {\n\t\t\trep(d, 8) {\n\t\t\t\tint nx = j + dx[d];\n\t\t\t\tint ny = i + dy[d];\n\t\t\t\tif(fld[ny][nx] == 0) sea[i][j]++;\n\t\t\t}\n\t\t\tif(fld[i][j] != 0 && sea[i][j] >= fld[i][j]) {\n\t\t\t\tque[0].push(P(j, i));\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\tbool f = 0;\n\twhile(wave(f)) {\n\t\tf = !f;\n\t\tans++;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint H, W; vector<string> s;\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> H >> W; s.resize(H);\n\tfor(int i = 0; i < H; i++) cin >> s[i];\n\tvector<pair<int, int> > v;\n\tfor(int i = 0; i < H; i++) {\n\t\tfor(int j = 0; j < W; j++) {\n\t\t\tif(s[i][j] == '.' || s[i][j] == '9') continue;\n\t\t\tint cnt = 0;\n\t\t\tfor(int k = -1; k <= 1; k++) {\n\t\t\t\tfor(int l = -1; l <= 1; l++) {\n\t\t\t\t\tint tx = j + l, ty = i + k;\n\t\t\t\t\tif(0 <= tx && tx < W && 0 <= ty && ty < H && s[ty][tx] == '.') cnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(cnt >= s[i][j] - 48) v.push_back(make_pair(j, i));\n\t\t}\n\t}\n\tint ret = 0;\n\tfor(; !v.empty(); ret++) {\n\t\tfor(pair<int, int> i : v) s[i.second][i.first] = '.';\n\t\tvector<pair<int, int> > w;\n\t\tfor(pair<int, int> i : v) {\n\t\t\tint sx = i.first, sy = i.second;\n\t\t\tfor(int j = -1; j <= 1; j++) {\n\t\t\t\tfor(int k = -1; k <= 1; k++) {\n\t\t\t\t\tint tx = sx + k, ty = sy + j;\n\t\t\t\t\tif(!(0 <= tx && tx < W && 0 <= ty && ty < H && s[ty][tx] != '.' && s[ty][tx] != '9')) continue;\n\t\t\t\t\tint cnt = 0;\n\t\t\t\t\tfor(int l = -1; l <= 1; l++) {\n\t\t\t\t\t\tfor(int m = -1; m <= 1; m++) {\n\t\t\t\t\t\t\tint ux = tx + m, uy = ty + l;\n\t\t\t\t\t\t\tif(0 <= ux && ux < W && 0 <= uy && uy < H && s[uy][ux] == '.') cnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(cnt >= s[ty][tx] - 48) w.push_back(make_pair(tx, ty));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tv = w;\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"queue\"\n#include \"utility\"\n#include \"math.h\"\n\nusing namespace std;\nint H, W;\nchar status[1002][1002];\nint field[1002][1002];\npair<int, int> dir[8] = {make_pair(0,1),make_pair(1,1),make_pair(1,0),make_pair(1,-1),make_pair(0,-1),make_pair(-1,-1),make_pair(-1,0),make_pair(-1,1)};\nqueue<pair<int,int> > Q;\nqueue<pair<int, int> >del;\nint ans = 0;\nint box = 0;\nint num = 0;\nint x, y;\n\nint main() {\n\tcin >> H >>W;\n\tfor (int i = 1; i <= H; i++) {\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tcin >> status[i][j];\n\t\t\tif (status[i][j] == '.') {\n\t\t\t\tfield[i][j] = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfield[i][j] = status[i][j] - '0';\n\t\t\t}\n\t\t}\n\t}\n\t/*for (int i = 1; i <= H; i++) {\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tcout << field[i][j];\n\t\t}\n\t\tcout << \"\\n\";\n\t}\n\tcout << \"\\n\";*/\n\tfor (int i = 1; i <= H; i++) {\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tbox = 0;\n\t\t\tif (field[i][j] != 0) {\n\t\t\t\tfor (int k = 0; k < 8; k++) {\n\t\t\t\t\tif (field[i + dir[k].first][j + dir[k].second] == 0)box++;\n\t\t\t\t}\n\t\t\t\tif (box >= field[i][j]) {\n\t\t\t\t\tQ.push(make_pair(i, j));\n\t\t\t\t\tans = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdel = Q;\n\twhile (!del.empty()) {\n\t\ty = del.front().first;\n\t\tx = del.front().second;\n\t\tfield[y][x] = 0;\n\t\tdel.pop();\n\t}\n\twhile (1) {\n\t\t/*for (int i = 1; i <= H; i++) {\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\tcout << field[i][j];\n\t\t\t}\n\t\t\tcout << \"\\n\";\n\t\t}\n\t\tcout << \"\\n\";*/\n\t\tnum = Q.size();\n\t\tfor (int i = 0; i < num; i++) {\n\t\t\ty = Q.front().first;\n\t\t\tx = Q.front().second;\n\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\tif (field[y + dir[j].first][x + dir[j].second] != 0) {\n\t\t\t\t\tbox = 0;\n\t\t\t\t\tfor (int k = 0; k < 8; k++) {\n\t\t\t\t\t\tif (field[y + dir[j].first + dir[k].first][x + dir[j].second + dir[k].second] == 0)box++;\n\t\t\t\t\t}\n\t\t\t\t\tif (box >= field[y + dir[j].first][x + dir[j].second]) {\n\t\t\t\t\t\tQ.push(make_pair(y + dir[j].first, x + dir[j].second));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t\tif (Q.empty())break;\n\t\tans++;\n\t\tdel = Q;\n\t\twhile (!del.empty()) {\n\t\t\ty = del.front().first;\n\t\t\tx = del.front().second;\n\t\t\tfield[y][x] = 0;\n\t\t\tdel.pop();\n\t\t}\n\t}\n\tcout << ans << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstring>\nusing namespace std;\n\nint main(){\n\tstring S;\n\tint n,m,t,sum,a;\n\tsum=0;\n\tint x[1200][1200];\n\tbool y[1200][1200];\n\tmemset(x,0,sizeof(x));\n\tchar T[10]={'.','1','2','3','4','5','6','7','8','9'};\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>S;\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tfor(int k=0;k<10;k++){\n\t\t\t\tif(S[j-1]==T[k]){\n\t\t\t\t\tx[i][j]=k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\twhile(true){\n\t\tt=0;\n\t\tsum++;\n\t\tmemset(y,false,sizeof(y));\n\t\tfor(int i=2;i<n;i++){\n\t\t\tfor(int j=2;j<m;j++){\n\t\t\t\tif(x[i][j]>=1){\n\t\t\t\t\ta=0;\n\t\t\t\t\tfor(int k=-1;k<=1;k++){\n\t\t\t\t\t\tfor(int l=-1;l<=1;l++){\n\t\t\t\t\t\t\tif(k!=0 || l!=0){\n\t\t\t\t\t\t\t\tif(x[i+k][j+l]==0){\n\t\t\t\t\t\t\t\t\ta++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(a>=x[i][j]){\n\t\t\t\t\t\ty[i][j]=true;\n\t\t\t\t\t\tt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\t\n\t\t}\n\t\tif(t==0){\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i=2;i<n;i++){\n\t\t\tfor(int j=2;j<m;j++){\n\t\t\t\tif(y[i][j]==true){\n\t\t\t\t\tx[i][j]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<sum-1<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\nint h, w;\nvector<string> v;\nchar t[1001];\nint a[1000][1000];\nint dx[8] = {1, 1, 1, 0, -1, -1, -1, 0};\nint dy[8] = {-1, 0, 1, 1, 1, 0, -1, -1};\ntypedef pair<int, int> P;\nqueue<P> q[2];\nint b = 0;\nint ans;\n\nint main(){\n\tscanf(\"%d %d\", &h, &w);\n\tfor(int i=0; i<h; i++){\n\t\tscanf(\"%s\", t);\n\t\tv.push_back(t);\n\t}\n\tfor(int i=1; i<w-1; i++){\n\t\tfor(int j=1; j<h-1; j++){\n\t\t\tint c = 0;;\n\t\t\tfor(int k=0; k<8; k++){\n\t\t\t\tint nx, ny;\n\t\t\t\tnx = i + dx[k];\n\t\t\t\tny = j + dy[k];\n\t\t\t\tif(v[ny][nx] == '.') c++;\n\t\t\t}\n\t\t\ta[j][i] = c;\n\t\t}\n\t}\n\tfor(int i=1; i<w-1; i++){\n\t\tfor(int j=1; j<h-1; j++){\n\t\t\tif(v[j][i] != '.'){\n\t\t\t\tif(v[j][i] - '0' <= a[j][i]) q[0].push(P(i, j));\n\t\t\t}\n\t\t}\n\t}\n\n\twhile(q[b].size()){\n\t\twhile(q[b].size()){\n\t\t\tans++;\n\t\t\tP p = q[b].front();\n\t\t\tq[b].pop();\n\t\t\tfor(int i=0; i<8; i++){\n\t\t\t\tint nx, ny;\n\t\t\t\tnx = p.first + dx[i];\n\t\t\t\tny = p.second + dy[i];\n\t\t\t\ta[ny][nx] ++;\n\t\t\t\tif(a[ny][nx] >= v[ny][nx] - '0') q[1-b].push(P(nx, ny));\n\t\t\t}\n\t\t}\n\t\tb=1-b;\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\n\nint main() {\n\tint H, W;\n\tchar S[2000][2000];\n\tint i, j, ii, jj;\n\tint ans = 0, cou = 0, cou2 = 0;\n\tint s[2000][2000] = { -1 }, ss[2000][12000]={ -1 };\n\tint x[] = { 0,0,1,1,1,-1,-1,-1 };\n\tint y[] = { 1,-1,0,1,-1,0,1,-1 };\n\tscanf(\"%d %d\", &H, &W);\n\t//for (int i = 0; i < 8; i++) {\n\t\t//printf(\"%d%d\", x[i], y[i]);\n\t//}\n\tfor (i = 1; i <= H; i++) {\n\t\tfor (j = 1; j <= W; j++) {\n\t\t\tscanf(\" %c\", &S[i][j]);\n\t\t\tif (S[i][j] == '.') {\n\t\t\t\ts[i][j] = 0;\n\t\t\t\tss[i][j] = 10;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ts[i][j] = S[i][j] - 48;\n\t\t\t\tss[i][j] = 10;\n\t\t\t}\n\t\t}\n\t}\n\t//////////////\n\t//for (i = 1; i <= H; i++) {\n\t\t//for (j = 1; j <= W; j++) {\n\t\t\t//printf(\"%d\", ss[i][j]);\n\t\t//}\n\t\t//printf(\"\\n\");\n\t//}\n\t////////\n\twhile (1) {\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\tif (s[i][j] == 0) {\n\t\t\t\t\tfor (int k = 0; k < 8; k++) {\n\t\t\t\t\t\tii= i+x[k];\n\t\t\t\t\t\tjj = j+y[k];\n\t\t\t\t\t\tif (s[ii][jj] != 0) {\n\t\t\t\t\t\t\tif (s[ii - 1][jj - 1] == 0) {\n\t\t\t\t\t\t\t\tcou++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (s[ii- 1][jj] == 0) {\n\t\t\t\t\t\t\t\tcou++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (s[ii - 1][jj + 1] == 0) {\n\t\t\t\t\t\t\t\tcou++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (s[ii][jj - 1] == 0) {\n\t\t\t\t\t\t\t\tcou++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (s[ii][jj + 1] == 0) {\n\t\t\t\t\t\t\t\tcou++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (s[ii + 1][jj - 1] == 0) {\n\t\t\t\t\t\t\t\tcou++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (s[ii + 1][jj] == 0) {\n\t\t\t\t\t\t\t\tcou++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (s[ii + 1][jj + 1] == 0) {\n\t\t\t\t\t\t\t\tcou++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (cou >= s[ii][jj] && s[ii][jj]>=0) {\n\t\t\t\t\t\t\t\tss[ii][jj] = 0;\n\t\t\t\t\t\t\t\tcou2++;\n\t\t\t\t\t\t\t\t//printf(\"%d %d\\n\", ii, jj);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcou = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//printf(\"%d\\n\", cou2);\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\tif (ss[i][j] == 0) {\n\t\t\t\t\ts[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (cou2 == 0) break;\n\t\tcou2 = 0;\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t//\tprintf(\"%d\", s[i][j]);\n\t\t\t}\n\t\t\t//printf(\"\\n\");\n\t\t}\n\t    //printf(\"\\n\");\n\t\tans++;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<queue>\n#include<vector>\nusing namespace std;\n#define INF 1000000000\ntypedef pair<int,int> P;\ntypedef long long int ll;\nqueue<P> que1,que2;\nchar mas[1001][1001];\n\nint main(){\n\tint h,w;\n\tcin >> h >> w;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tcin >> mas[i][j];\n\t\t\tif(mas[i][j]!='.' && mas[i][j]!='9'){\n\t\t\t\tque1.push(P(j,i));\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\twhile(1){\n\t\twhile(!que1.empty()){\n\t\t\tP p = que1.front(); que1.pop();\n\t\t\tint x = p.first;\n\t\t\tint y = p.second;\n\t\t\tint power = mas[y][x] - '0';\n\t\t\tint cou = 0;\n\t\t\tfor(int i=-1;i<=1;i++){\n\t\t\t\tif(power == cou) break;\n\t\t\t\tfor(int j=-1;j<=1;j++){\n\t\t\t\t\tif(power == cou) break;\n\t\t\t\t\tint nx = x+i;\n\t\t\t\t\tint ny = y+j;\n\t\t\t\t\tif(mas[ny][nx]=='.'){\n\t\t\t\t\t\tcou++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(power == cou){\n\t\t\t\tque2.push(P(x,y));\n\t\t\t}\n\t\t}\n\t\tif(que2.empty()) break;\n\t\tans++;\n\t\twhile(!que2.empty()){\n\t\t\tP p = que2.front(); que2.pop();\n\t\t\tint x = p.first;\n\t\t\tint y = p.second;\n\t\t\tmas[y][x] = '.';\n\t\t\tfor(int i=-1;i<=1;i++){\n\t\t\t\tfor(int j=-1;j<=1;j++){\n\t\t\t\t\tint nx = x+i;\n\t\t\t\t\tint ny = y+j;\n\t\t\t\t\tif(mas[ny][nx]!='.' && mas[ny][nx]!='9'){\n\t\t\t\t\t\tque1.push(P(nx,ny));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<utility>\n#include<string>\nusing namespace std;\ntypedef pair<int, int>P;\n\nstring sand[1005];\nint sara[1005][1005];\nqueue<P>now;\nqueue<P>nxt;\n\nint main() {\n\tint h, w;\n\tcin >> h >> w;\n\n\tfor (int i = 0;i<h;i++)cin>>sand[i];\n\n\tfor (int i = 0;i<h;i++) {\n\t\tfor (int j = 0;j<w;j++) {\n\t\t\tif (sand[i][j] != '.') {\n\t\t\t\tfor (int k = -1;k <= 1;k++) {\n\t\t\t\t\tfor (int l = -1;l <= 1;l++) {\n\t\t\t\t\t\tif (sand[i + k][j + l] == '.')sara[i][j]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0;i<h;i++) {\n\t\tfor (int j = 0;j<w;j++) {\n\t\t\tif (sand[i][j] != '.') {\n\t\t\t\tint a = sand[i][j] - '0';\n\t\t\t\tif (a <= sara[i][j]) {\n\t\t\t\t\tnow.push(make_pair(i, j));\n\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\n\twhile(now.size()){\n\tint a = now.size();\n\tqueue<P>q;\n\n\tfor (int i = 0;i < a;i++) {\n\t\tP p = now.front();\n\t\tnow.pop();\n\n\t\tint f = p.first, s = p.second;\n\n\t\tsand[f][s] = '.';\n\t\tsara[f][s] = 0;\n\t\t\n\t\tfor (int j = -1;j <= 1;j++) {\n\t\t\tfor (int k = -1;k <= 1;k++) {\n\t\t\t\tif (sand[f + j][s + k] != '.')q.push(make_pair(f + j, s + k));\n\t\t\t}\n\t\t}\n\t}\n\n\tint b = q.size();\n\tfor (int i = 0;i < b;i++) {\n\t\tP pa = q.front();\n\t\tq.pop();\n\t\tint m=0;\n\t\tfor (int j = -1;j <= 1;j++) {\n\t\t\tfor (int k = -1;k <= 1;k++) {\n\t\t\t\tif (sand[pa.first + j][pa.second + k] == '.')m++;\n\t\t\t}\n\t\t}\n\t\tsara[pa.first][pa.second] = m;\n\t\tif (sara[pa.first][pa.second] >= sand[pa.first][pa.second] - '0')nxt.push(pa);\n\t}\n\n\tqueue<P>kari;\n\tnow = nxt;\n\tnxt = kari;\n\n\tans++;\n\t}\n\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nstruct Mapchip{\n\tunsigned char num : 4;\n\tunsigned char change : 1;\n};\n\nint main() {\n\tint w,h, s[2] = {}, e[2] = {};\n\tMapchip map[1000][1000] = {};\n\tint dir[2][8] = {\n\t\t{-1, 0, 1, -1, 1, -1, 0, 1},\n\t\t{-1, -1, -1, 0, 0, 1, 1, 1}\n\t};\n\tscanf(\"%d %d\", &h, &w);\n\tfor (int i = 0; h > i; i++){\n\t\tscanf(\"%*c\");\n\t\tfor(int j = 0; w > j; j++){\n\t\t\tchar buf;\n\t\t\tscanf(\"%c\", &buf);\n\t\t\t\n\t\t\tif(buf == '.') buf = '0';\n\t\t\telse {\n\t\t\t\tif(s[0] == 0){\n\t\t\t\t\ts[0] = i; s[1] = j;\n\t\t\t\t}\n\t\t\t\tif(e[0] < i || e[1] < j) {\n\t\t\t\t\te[0] = i; e[1] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tmap[i][j].num = buf - '0';\n\t\t\t\n\t\t}\n\t}\n\t\n\tint t = 1, count;\n\tfor(count = 0; t; count++){\n\t\tt = 0;\n\t\tfor(int i = s[0]; e[0] >= i; i++){\n\t\t\tfor(int j = s[1]; e[1] >= j; j++){\n\t\t\t\tif (map[i][j].num){\n\t\t\t\t\tint emptyc = 0;\n\t\t\t\t\tfor (int c = 0; 8 > c; c++){\n\t\t\t\t\t\tif (!map[i + dir[0][c]][j + dir[1][c]].num && !map[i + dir[0][c]][j + dir[1][c]].change) emptyc++;\n\t\t\t\t\t}\n\t\t\t\t\tif (emptyc >= map[i][j].num){\n\t\t\t\t\t\tt = 1;\n\t\t\t\t\t\tmap[i][j].num = 0;\n\t\t\t\t\t\tmap[i][j].change = 1;\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = s[0]; e[0] >= i; i++){\n\t\t\tfor (int j = s[1]; e[1] >= j; j++){\n\t\t\t\tmap[i][j].change = 0;\n\t\t\t}\n\t\t}\n\t};\n\tprintf(\"\\n\\n%d\\n\", count-1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair< int, int > Pi;\ntypedef pair< int, Pi > Pii;\nconst static int dy[] = {-1, -1, 0, 1, 1, 1, 0, -1};\nconst static int dx[] = {0, 1, 1, 1, 0, -1, -1, -1};\n\nint main()\n{\n  int H, W;\n  char S[1000][1001];\n\n  cin >> H >> W;\n  for(int i = 0; i < H; i++) {\n    cin >> S[i];\n  }\n\n  queue< Pii > Que;\n  int ret = 0;\n\n  for(int i = 0; i < H; i++) {\n    for(int j = 0; j < W; j++) {\n      if(S[i][j] == '.') Que.push(Pii(0, Pi(j, i)));\n      else S[i][j] -= '0';\n    }\n  }\n  while(!Que.empty()) {\n    Pii& p = Que.front();\n    ret = max(ret, p.first);\n    for(int i = 0; i < 8; i++) {\n      int ny = p.second.second + dy[i];\n      int nx = p.second.first  + dx[i];\n      if(ny >= 0 && ny < H && nx >= 0 && nx < W && S[nx][ny] != '.') {\n        --S[ny][nx];\n        if(S[ny][nx] == 0) {\n          Que.push(Pii(p.first + 1, Pi(nx, ny)));\n        }\n      }\n      Que.pop();\n    }\n  }\n  cout << ret << endl;\n  return(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n//#include<string.h>\nusing namespace std;\nstruct log{\n\tint x,y;\n};\nqueue <log> cls;\nqueue <log> q;\nlog g;\nlong h,w,ans=0,length;\nchar sand[1004][1004];\nint main(){\n\tcin>>h>>w;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int o=0;o<w;o++){\n\t\t\tcin>>sand[i][o];\n\t\t\tif(sand[i][o]!='.'&&sand[i][o]!='9'){\n\t\t\t\tg.y=i;\n\t\t\t\tg.x=o;\n\t\t\t\tq.push(g);\n\t\t\t}\n\t\t}\n\t}\n\tint f,c,fx,fy,my[]={0,1,1,1,0,-1,-1,-1},mx[]={1,1,0,-1,-1,-1,0,1};\n\tdo{\n\t\tf=0;\n\t\twhile(!cls.empty()){\n\t\t\tg=cls.front();\n\t\t\tcls.pop();\n\t\t\tsand[g.y][g.x]='.';\n\t\t}\n\t\t/*for(int i=0;i<h;i++){\n\t\t\tfor(int yu=0;yu<w;yu++){\n\t\t\t\tcout<<sand[i][yu];\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}*/\n\t\tlength=q.size();\n\t\tfor(int i=0;i<length;i++){\n\t\t\tg=q.front();\n\t\t\tq.pop();\n\t\t\tc=0;\n\t\t\tfor(int r=0;r<8;r++){\n\t\t\t\tfx=g.x+mx[r];\n\t\t\t\tfy=g.y+my[r];\n\t\t\t\tif(fx>=0&&fx<w&&fy>=0&&fy<h&&sand[fy][fx]=='.'){\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(c>=sand[g.y][g.x]-48){\n\t\t\t\tcls.push(g);\n\t\t\t\t//cout<<sand[g.y][g.x]<<endl;\n\t\t\t\tf=1;\n\t\t\t}\n\t\t\telse if(c<sand[g.y][g.x]-48){\n\t\t\t\tq.push(g);\n\t\t\t}\n\t\t}\n\t\tif(f==1){\n\t\t\tans++;\n\t\t}\n\t}while(!cls.empty());\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint dx[]={1,1,1,0,0,-1,-1,-1};\nint dy[]={1,0,-1,1,-1,1,0,-1};\nint main(){\n  int w,h;\n  cin>>h>>w;\n  string s[h];\n  for(int i=0;i<h;i++)cin>>s[i];\n  for(int i=0;i<1000000;i++){\n    vector<pair<int,int> >v;\n    for(int j=0;j<h;j++){\n      for(int k=0;k<w;k++){\n        if(s[j][k]=='.')continue;\n        int p=0;\n        for(int l=0;l<8;l++){\n          int y=j+dy[l],x=dx[l]+k;\n          if(y>=0&&x>=0&&y<h&&x<w)\n            if(s[y][x]=='.')p++;\n        }\n        if(p>=s[j][k]-'0')\n          v.push_back(make_pair(j,k));\n      }\n    }\n    if(v.size()){\n      for(int i=0;i<v.size();i++)\n        s[v[i].first][v[i].second]='.';\n    }\n    else{\n      cout<<i<<endl;\n      break;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing pii = pair<int, int>;\n\nconst int INF = 1e9;\n\nconst int dx[] = { 1, 1, 0, -1, -1, -1, 0, 1 };\nconst int dy[] = { 0, 1, 1, 1, 0, -1, -1, -1 };\n\nint main()\n{\n\tint H, W;\n\tcin >> H >> W;\n\tvector<string> a(H);\n\tvector<vector<int>> d(H, vector<int>(W, INF));\n\tdeque<pii> dq;\n\tfor (int i = 0; i < H; i++) {\n\t\tcin >> a[i];\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (a[i][j] == '.') {\n\t\t\t\ta[i][j] = '0';\n\t\t\t\tdq.emplace_front(i * W + j, 0);\n\t\t\t}\n\t\t}\n\t}\n\twhile (!dq.empty()) {\n\t\tauto p = dq.front(); dq.pop_front();\n\t\tint x = p.first / W, y = p.first % W;\n\t\tif (d[x][y] != INF) continue;\n\t\tint cnt = 0;\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tint tx = x + dx[i], ty = y + dy[i];\n\t\t\tcnt += (0 <= tx && tx < H && 0 <= ty && ty < W && d[tx][ty] < p.second);\n\t\t}\n\t\tif (cnt < a[x][y] - '0') continue;\n\t\td[x][y] = p.second;\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tint tx = x + dx[i], ty = y + dy[i];\n\t\t\tif (tx < 0 || H <= tx || ty < 0 || W <= ty || d[tx][ty] != INF) continue;\n\t\t\tint cnt = 0;\n\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\tint ttx = tx + dx[j], tty = ty + dy[j];\n\t\t\t\tcnt += (0 <= ttx && ttx < H && 0 <= tty && tty < W && d[ttx][tty] < d[x][y]);\n\t\t\t}\n\t\t\tif (cnt >= a[tx][ty] - '0') {\n\t\t\t\tdq.emplace_front(tx * W + ty, d[x][y]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdq.emplace_back(tx * W + ty, d[x][y] + 1);\n\t\t\t}\n\t\t}\n\t}\n\tint res = 0;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (d[i][j] != INF) {\n\t\t\t\tres = max(res, d[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tcout << res << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\n\nint main() {\n\tint H, W;\n\tchar S[1000][1000];\n\tint i, j, ii, jj;\n\tint ans = 0, cou = 0, cou2 = 0;\n\tint s[1000][1000] = { -1 }, ss[1000][1000]={ -1 };\n\tint x[] = { 0,0,1,1,1,-1,-1,-1 };\n\tint y[] = { 1,-1,0,1,-1,0,1,-1 };\n\tscanf(\"%d %d\", &H, &W);\n\t//for (int i = 0; i < 8; i++) {\n\t\t//printf(\"%d%d\", x[i], y[i]);\n\t//}\n\tfor (i = 1; i <= H; i++) {\n\t\tfor (j = 1; j <= W; j++) {\n\t\t\tscanf(\" %c\", &S[i][j]);\n\t\t\tif (S[i][j] == '.') {\n\t\t\t\ts[i][j] = 0;\n\t\t\t\tss[i][j] = 10;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ts[i][j] = S[i][j] - 48;\n\t\t\t\tss[i][j] = 10;\n\t\t\t}\n\t\t}\n\t}\n\t//////////////\n\t//for (i = 1; i <= H; i++) {\n\t\t//for (j = 1; j <= W; j++) {\n\t\t\t//printf(\"%d\", ss[i][j]);\n\t\t//}\n\t\t//printf(\"\\n\");\n\t//}\n\t////////\n\twhile (1) {\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\tif (s[i][j] == 0) {\n\t\t\t\t\tfor (int k = 0; k < 8; k++) {\n\t\t\t\t\t\tii= i+x[k];\n\t\t\t\t\t\tjj = j+y[k];\n\t\t\t\t\t\tif (s[ii][jj] != 0) {\n\t\t\t\t\t\t\tif (s[ii - 1][jj - 1] == 0) {\n\t\t\t\t\t\t\t\tcou++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (s[ii- 1][jj] == 0) {\n\t\t\t\t\t\t\t\tcou++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (s[ii - 1][jj + 1] == 0) {\n\t\t\t\t\t\t\t\tcou++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (s[ii][jj - 1] == 0) {\n\t\t\t\t\t\t\t\tcou++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (s[ii][jj + 1] == 0) {\n\t\t\t\t\t\t\t\tcou++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (s[ii + 1][jj - 1] == 0) {\n\t\t\t\t\t\t\t\tcou++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (s[ii + 1][jj] == 0) {\n\t\t\t\t\t\t\t\tcou++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (s[ii + 1][jj + 1] == 0) {\n\t\t\t\t\t\t\t\tcou++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (cou >= s[ii][jj] && s[ii][jj]>=0) {\n\t\t\t\t\t\t\t\tss[ii][jj] = 0;\n\t\t\t\t\t\t\t\tcou2++;\n\t\t\t\t\t\t\t\t//printf(\"%d %d\\n\", ii, jj);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcou = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//printf(\"%d\\n\", cou2);\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\tif (ss[i][j] == 0) {\n\t\t\t\t\ts[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (cou2 == 0) break;\n\t\tcou2 = 0;\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t//\tprintf(\"%d\", s[i][j]);\n\t\t\t}\n\t\t\t//printf(\"\\n\");\n\t\t}\n\t    //printf(\"\\n\");\n\t\tans++;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\nusing namespace std;\ntypedef pair<int, int> P;\n\nint h, w, ans;\nint castle[1001][1001];\nint times[1001][1001];\nint dx[] = {-1, 0, 1, -1, 1, -1, 0, 1}, dy[] = {-1, -1, -1, 0, 0, 1, 1, 1};\nchar beach[1001][1001];\n\nint main(){\n    cin >> h >> w;\n    for(int i = 1; i < h; i++){\n        cin >> beach[i];\n    }\n\n    queue<P> Q;\n    for(int i = 0; i < h; i++){\n        for(int j = 0; j < w; j++){\n            if(beach[i][j] == '.'){\n                Q.push(P(i, j));\n            } else{\n                castle[i][j] = (int)beach[i][j] - 48;\n            }\n        }\n    }\n\n    while(Q.size()){\n        P p = Q.front();\n        Q.pop();\n        ans = max(ans, times[p.first][p.second]);\n\n        for(int i = 0; i < 8; i++){\n            int x = p.first + dx[i], y = p.second + dy[i];\n            if(x < 0 || x >= w || y < 0 || y >= h){\n                continue;\n            }\n            castle[x][y]--;\n            if(castle[x][y] == 0){\n                Q.push(P(x, y));\n                times[x][y] = times[p.first][p.second] + 1;\n            }\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint f[1000][1000];\nint m[1000][1000];\nint count(int h,int w){\n        int a[9]={0,1,1,0,-1,-1,1,-1,0},sum=0;\n        for(int i =0;i<8;i++){\n                if(f[h+a[i]][w+a[i+1]]==-1)sum++;\n        }\n        return sum;\n}\nvoid change(int h,int w){\n        int a[9]={0,1,1,0,-1,-1,1,-1,0};\n        for(int i =0;i<8;i++){\n                m[h+a[i]][w+a[i+1]]++;\n        }\n}\n\nint main(){\n        int h,w;\n        cin>>h>>w;\n        for(int i=0;i<h;i++){\n                for(int j=0;j<w;j++){\n                        char t;\n                        cin>>t;\n                        if(t=='.')f[i][j]=-1;\n                        else f[i][j]=t-'0';\n                }\n        }\n        for(int i=0;i<h;i++){\n                for(int j=0;j<w;j++){\n                        m[i][j]=count(i,j);\n                }\n        }\n        int c=0;\n        while(1){\n                bool end=true;\n                for(int i=1;i<h-1;i++){\n                        for(int j=1;j<w-1;j++){\n                                if(f[i][j]!=-1&&f[i][j]<=m[i][j]){\n                                        f[i][j]=-10;\n                                        end=false;\n                                }\n                        }\n                }\n                for(int i=1;i<h-1;i++){\n                        for(int j=1;j<w-1;j++){\n                                if(f[i][j]==-10){\n                                        f[i][j]=-1;\n                                        change(i,j);\n                                }\n                        }\n                }\n                if(end)break;\n                c++;\n        }\n        cout<<c<<endl;\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\nint w,h,field[50][50],copied[50][50];\n\nvoid show(){\n\tfor(int i = 0;i < h;i++){\n\t\tfor(int j = 0;j < w;j++){\n\t\t\tcout << field[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\nvoid copyarray(){\n\tfor(int i = 0;i < h;i++){\n\t\tfor(int j = 0;j < w;j++){\n\t\t\tfield[i][j] = copied[i][j];\n\t\t}\n\t}\n}\n\nint around(int a,int b){\n\tint cnt = 0;\n\tfor(int i = max(0,a - 1);i < min(h,a + 2);i++){\n\t\tfor(int j = max(0,b - 1);j < min(w,b + 2);j++){\n\t\t\tif(!(a == i && b == j) && field[i][j] == 0) cnt++;\n\t\t}\n\t}\n\treturn cnt;\n}\n\nint main(){\n\tqueue<pair<int,int> > que1,que2;\n\tcin >> h >> w;\n\tgetchar();\n\tfor(int i = 0;i < h;i++){\n\t\tfor(int j = 0;j < w;j++){\n\t\t\tchar c = getchar();\n\t\t\tif(c == '.') copied[i][j] = 0;\n\t\t\telse copied[i][j] = c - '0';\n\t\t}\n\t\tgetchar();\n\t}\n\tint chg = -1,cnt = -1;\n\twhile(chg){\n\t\tcopyarray();\n\t\tcnt++;\n\t\tif(chg == -1){\n\t\t\tchg++;\n\t\t\tfor(int i = 0;i < h;i++){\n\t\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\t\tif(field[i][j] != 0 && around(i,j) >= field[i][j]) {\n\t\t\t\t\t\tcopied[i][j] = 0;\n\t\t\t\t\t\tchg++;\n\t\t\t\t\t\tque2.push(make_pair(i,j));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tchg = 0;\n\t\t\tque1 = que2;\n\t\t\twhile(!que1.empty()){\n\t\t\t\tpair<int,int> p = que1.front();que1.pop();\n\t\t\t\tfor(int i = max(0,p.first - 1);i < min(h,p.first + 2);i++){\n\t\t\t\t\tfor(int j = max(0,p.second - 1);j < min(w,p.second + 2);j++){\n\t\t\t\t\t\tif(field[i][j] != 0 && around(i,j) >= field[i][j]) {\n\t\t\t\t\t\t\tcopied[i][j] = 0;\n\t\t\t\t\t\t\tchg++;\n\t\t\t\t\t\t\tque2.push(make_pair(i,j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << cnt << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n\nusing namespace std;\n\nint countaround(vector<vector<int> >& mp, int h, int w) {\n    int cnt=0;\n    int dh[8]={-1,-1,-1,0,1,1,1,0};\n    int dw[8]={-1,0,1,1,1,0,-1,-1};\n\n    for(int i=0; i<8; ++i) {\n        if(h+dh[i]>=0 && h+dh[i]<(int)mp.size() && w+dw[i]>=0 && w+dw[i]<(int)mp[0].size() && mp[h+dh[i]][w+dw[i]]==0) ++cnt;\n    }\n    return cnt;\n}\n\nbool checkcount(vector<vector<int> >& mp, int h, int w) {\n    return countaround(mp,h,w)>=mp[h][w];\n}\n\ntypedef pair<int,int> P;\n\nint main()\n{\n    int H,W;\n    cin >> H >> W;\n\n    vector<vector<int> > mp,updt;\n\n    mp.resize(H);\n    updt.resize(H);\n\n    for(int i=0; i<H; ++i) {\n        string instr;\n        cin >> instr;\n\n        mp[i].resize(W);\n        updt[i].resize(W);\n        for(int j=0; j<W; ++j) {\n            if(instr[j]=='.') mp[i][j]=0;\n            else mp[i][j]=instr[j]-'0';\n            updt[i][j]=0;\n        }\n    }\n\n    queue<P> q[2];\n    int idxq=0;\n\n    for(int i=0; i<H; ++i) {\n        for(int j=0; j<W; ++j) {\n            if(checkcount(mp,i,j)) {\n                q[idxq].push(P(i,j));\n                updt[i][j]=1;\n            }\n        }\n    }\n\n    int dh[8]={-1,-1,-1,0,1,1,1,0};\n    int dw[8]={-1,0,1,1,1,0,-1,-1};\n\n    while(true) {\n        while(!q[idxq%2].empty()) {\n            P p=q[idxq%2].front(); q[idxq%2].pop();\n            mp[p.first][p.second]=0;\n            for(int i=0; i<8; ++i) {\n                if(p.first+dh[i]>=0 && p.first+dh[i]<(int)mp.size() && p.second+dw[i]>=0 && p.second+dw[i]<(int)mp[0].size() &&\n                   updt[p.first+dh[i]][p.second+dw[i]]==0 && checkcount(mp,p.first+dh[i],p.second+dw[i])) {\n                    q[(idxq+1)%2].push(P(p.first+dh[i],p.second+dw[i]));\n                    updt[p.first+dh[i]][p.second+dw[i]]=1;\n                }\n            }\n        }\n\n        ++idxq;\n        if(q[idxq%2].empty()) break;\n    }\n\n    cout << idxq << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dx[] = {-1, -1, -1, 0, 1, 1, 1, 0};\nconst int dy[] = {-1, 0, 1, 1, 1, 0, -1, -1};\nconst int INF = 1 << 28;\n\nint h, w;\nint grid[1000][1000];\nint br[1000][1000];\n\nbool check(int x, int y, int t)\n{\n\tint cnt = 0;\n\tfor (int dir = 0; dir < 8; dir++){\n\t\tint nx = x + dx[dir];\n\t\tint ny = y + dy[dir];\n\t\tif (br[nx][ny] <= t) cnt++;\n\t}\n\treturn cnt >= grid[x][y];\n}\n\nint main()\n{\n\tcin >> h >> w;\n\tfor (int i = 0; i < h; i++){\n\t\tfor (int j = 0; j < w; j++){\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tif (c != '.'){\n\t\t\t\tgrid[i][j] = c - '0';\n\t\t\t\tbr[i][j] = INF;\n\t\t\t}\n\t\t}\n\t}\n\t\n\ttypedef tuple<int, int, int> Tp;\n\tqueue<Tp> q;\n\t\n\tfor (int i = 0; i < h; i++){\n\t\tfor (int j = 0; j < w; j++){\n\t\t\tif (br[i][j] < INF) continue;\n\t\t\tif (check(i, j, 0)){\n\t\t\t\tbr[i][j] = 1;\n\t\t\t\tq.push(Tp(i, j, 1));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint res = 0;\n\twhile (q.size()){\n\t\tint x, y, t;\n\t\ttie(x, y, t) = q.front(); q.pop();\n\t\tfor (int dir = 0; dir < 8; dir++){\n\t\t\tint nx = x + dx[dir];\n\t\t\tint ny = y + dy[dir];\n\t\t\tif (br[nx][ny] < INF) continue;\n\t\t\tif (check(nx, ny, t)){\n\t\t\t\tbr[nx][ny] = t + 1;\n\t\t\t\tq.push(Tp(nx, ny, t + 1));\n\t\t\t}\n\t\t}\n\t\tres = t;\n\t}\n\t\n\tcout << res << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mp make_pair\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;//cnt, coodinate\nstring grid[1111];\nint neiber[1111][1111];\nint dx[] = {0, 1, 1,  1,  0, -1, -1, -1};\nint dy[] = {1, 1, 0, -1, -1, -1,  0,  1};\nint w, h;\n\nbool del(int x, int y){\n  int cnt = 0;\n  if(!(0 <= x && x < w &&\n       0 <= y && y < h))return false;\n  if(grid[y][x] == '.') return false;\n  for (int i = 0; i < 8; i++) {\n    int nx = x + dx[i], ny = y + dy[i];\n    if(!(0 <= nx && nx < w &&\n         0 <= ny && ny < h))continue;\n    if(grid[ny][nx] == '.')cnt++;\n  }\n  char tmp = grid[y][x];\n  neiber[y][x] = cnt;\n  if(cnt >= atoi(&tmp))return true;\n  else return false;\n}\n\nint main(int argc, char *argv[]){\n  queue<piii> que;\n  queue<pii> p;\n  cin >> h >> w;\n  for (int i = 0; i < h; i++) {\n    cin >> grid[i];\n  }\n  for (int i = 0; i < h; i++) {\n    for (int j = 0; j < w; j++) {\n      if(del(j, i)){\n        p.push(mp(j, i));\n        que.push(mp(1, mp(j, i)));\n      }\n    }\n  }\n  int ans = 0;\n  while(!que.empty()){\n    int cnt = que.front().first;\n    if(ans != cnt){\n      while(!p.empty()){\n        int x = p.front().first;\n        int y = p.front().second;\n        p.pop();\n        if(grid[y][x] == '.')continue;\n        grid[y][x] = '.';\n        for (int i = 0; i < 8; i++) {\n          int nx = x + dx[i], ny = y + dy[i];\n          if(!(0 <= nx && nx < w &&\n               0 <= ny && ny < h))continue;\n          neiber[ny][nx]++;\n        }\n      }\n    }\n    int x = que.front().second.first;\n    int y = que.front().second.second;\n    que.pop();\n    ans = cnt;\n    for (int i = 0; i < 8; i++) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if(!(0 <= nx && nx < w &&\n           0 <= ny && ny < h))continue;\n      char tmp = grid[ny][nx];\n      if(neiber[ny][nx] >= atoi(&tmp) && grid[ny][nx] != '.'){\n        p.push(mp(nx, ny));\n        que.push(mp(cnt + 1, mp(nx, ny)));\n      }\n    }\n  }\n  std::cout << ans << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<queue>\n#include<fstream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint sand[1005][1005];\nbool used[1005][1005];\nconst int MAX=1007;\nqueue<int> q1,q2;\n\nint main(){\n\tifstream ifs(\"answer.txt\");\n\tstring sa;\n\tint i,j,k,l;\n\tint n,m;\n\tint a,b,c,d;\n\tifs>>n>>m;\n\tfor(i=0;i<n;i++){\n\t\tifs>>sa;\n\t\tfor(j=0;j<m;j++){\n\t\t\tif(sa[j]=='.'){\n\t\t\t\tfor(k=-1;k<=1;k++){\n\t\t\t\t\tfor(l=-1;l<=1;l++){\n\t\t\t\t\t\tif(i+k>0 && i+k<n-1 && j+l>0 && j+l<m-1){\n\t\t\t\t\t\t\tif(used[i+k][j+l])continue;\n\t\t\t\t\t\t\tused[i+k][j+l]=true;\n\t\t\t\t\t\t\tq1.push((i+k)*MAX+(j+l));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(char ca='1',k=1;k<10;k++,ca++){\n\t\t\t\tif(sa[j]==ca){\n\t\t\t\t\tsand[i][j]=k;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tmemset(used,false,sizeof(used));\n\tfor(i=0;;i++){\n\t\ta=q1.size();\n\t\tcout<<a<<endl;\n\t\tfor(j=0;j<a;j++){\n\t\t\tc=q1.front(),q1.pop();\n\t\t\tb=c/MAX,c%=MAX;\n\t\t\tif(sand[b][c]==0)continue;\n\t\t\tif(used[b][c])continue;\n\t\t\td=0;\n\t\t\tfor(k=-1;k<=1;k++){\n\t\t\t\tfor(l=-1;l<=1;l++){\n\t\t\t\t\tif(sand[b+k][c+l]==0)d++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(d<sand[b][c])continue;\n\t\t\tused[b][c]=true;\n\t\t\tq2.push(b*MAX+c);\n\t\t\tfor(k=-1;k<=1;k++){\n\t\t\t\tfor(l=-1;l<=1;l++){\n\t\t\t\t\tif(sand[b+k][c+l]==0)continue;\n\t\t\t\t\tq1.push((b+k)*MAX+(c+l));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(q2.empty())break;\n\t\twhile(!q2.empty()){\n\t\t\tc=q2.front(),q2.pop();\n\t\t\tb=c/MAX,c%=MAX;\n\t\t\tsand[b][c]=0;\n\t\t}\n\t}\n\tcout<<i<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define int long long int\n#define rep(a,b,c) for(int a=b;a<c;a++)\n#define repm(a,b,c) for(int a=(b-1);a>=c;a--)\n#define pb push_back\n#define str string\n#define sf(a) scanfs(\"%d\",&a)\n#define pb push_back\n#define mp make_pair\n#define Fi first\n#define Se second\n#define ALL(v) (v).begin(), (v).end()\n\nusing namespace std;\n\nconst int INF = 1e18 + 9;\nconst int Mod = 1e9 + 7;\ninline int replac(str s){double ans=0;rep(i,0,s.length()){ans+=(s[i]-'0')*pow(10,s.length()-i-1);}return (int)ans;}\ninline string numstr(int m){str s=\"\";while(m>0){char c;int a=m/10;if(a>0)a=m%(a*10);else a=m;c=(char)('0'+a);s+=c;m/=10;}str st=\"\";for(int i=s.size()-1;i>=0;i--){st+=s[i];}return st;}\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vii;\nint flag[1003][1003];\nint num[1003][1003];\nint dx[8]={-1,0,1,1,1,0,-1,-1};\nint w,h;\nint dy[8]={1,1,1,0,-1,-1,-1,0};\nstring c[1003];\nbool in(int a,int b){\n    if(a>=0&&b>=0&&a<h&&b<w)return true;\n    else false;\n}\nsigned main()\n{\n    cin >> h >> w;\n    rep(i,0,h){\n        cin >> c[i];\n    }\n    rep(i,0,1000){\n        rep(j,0,1000){\n            num[i][j]=0;\n            flag[i][j]=0;\n        }\n    }\n    rep(i,0,h){\n        rep(j,0,w){\n            if(c[i][j]=='.'){\n                num[i][j]=0;\n                rep(k,0,8){\n                    if((i+dy[k])>=0&&(j+dx[k])>=0&&(i+dy[k])<h&&(j+dx[k])<w){flag[i+dy[k]][j+dx[k]]++;}\n                }\n            }else{\n                num[i][j]=(c[i][j]-'0');\n            }\n        }\n    }\n    int ans=0;\n    queue<pii> que;\n    while(1){\n        rep(i,0,h){\n            rep(j,0,w){\n                if(num[i][j]==0)continue;\n                if(flag[i][j]>=num[i][j]){\n                    num[i][j]=0;\n                    que.push(mp(i,j));\n                }\n            }\n        }\n        if(que.empty())break;\n        ans++;\n        while(!que.empty()){\n            pii p=que.front();que.pop();\n            int y=p.first;\n            int x=p.second;\n            rep(k,0,8){\n                if((y+dy[k])>=0&&(x+dx[k])>=0&&(y+dy[k])<h&&(x+dx[k])<w)flag[y+dy[k]][x+dx[k]]++;\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <utility>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n\n#define INF_LL 9000000000000000000\n#define INF 2000000000\n\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int i = (a);i < (b);i++)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> PPII;\ntypedef pair<int, PPII> PPPII;\n\nclass Union_find{\nprivate:\n\tvector<int> par;\n\tvector<int> rank;\n\tint n;\n\npublic:\n\tUnion_find(int a){\n\t\tn = a;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tpar.push_back(i);\n\t\t\trank.push_back(0);\n\t\t}\n\t}\n\n\tint find(int x){\n\t\tif(par[x] == x){\n\t\t\treturn x;\n\t\t}else{\n\t\t\treturn par[x] = find(par[x]);\n\t\t}\n\t}\n\n\tvoid unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return;\n\n\t\tif(rank[x] < rank[y]){\n\t\t\tpar[x] = y;\n\t\t}else{\n\t\t\tpar[y] = x;\n\t\t\tif(rank[x] == rank[y]) rank[x]++;\n\t\t}\n\t}\n\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n};\n\nint dx[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nint dy[8] = {1, 0, -1, 1, -1, 1, 0, -1};\n\nint main(void){\n\tint h, w;\n\tstring m[1010];\n\tstring tmp[1010];\n\tqueue<PII> que[2];\n\tll res = 0;\n\tcin >> h >> w;\n\tREP(i, h){\n\t\tcin >> m[i];\n\t\ttmp[i] = m[i];\n\t\tREP(j, m[i].size()){\n\t\t\tif(m[i][j] != '.')\n\t\t\t\tque[res%2].push({i, j});\n\t\t}\n\t}\n\n\tint cnt = 1;\n\twhile(cnt != 0){\n\t\tcnt = 0;\n\t\tREP(i, h) tmp[i] = m[i];\n\t\twhile(que[res%2].size()){\n\t\t\tPII p = que[res%2].front(); que[res%2].pop();\n\t\t\tint sarati = 0;\n\t\t\tREP(i, 8){\n\t\t\t\tif(m[p.first+dx[i]][p.second+dy[i]] == '.')\n\t\t\t\t\tsarati++;\n\t\t\t}\n\t\t\tif(m[p.first][p.second] != '.' && sarati >= m[p.first][p.second]-'0'){\n\t\t\t\tcnt++;\n\t\t\t\ttmp[p.first][p.second] = '.';\n\t\t\t\tREP(i, 8){\n\t\t\t\t\tif(m[p.first+dx[i]][p.second+dy[i]] != '.')\n\t\t\t\t\t\tque[(res+1)%2].push({p.first+dx[i], p.second+dy[i]});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(cnt > 0) res++;\n\t\tREP(i, h) m[i] = tmp[i];\n\t}\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint f[1100][1100];\nint m[1100][1100];\nint count(int h,int w){\n        int a[9]={0,1,1,0,-1,-1,1,-1,0},sum=0;\n        for(int i =0;i<8;i++){\n                if(f[h+a[i]][w+a[i+1]]==-1)sum++;\n        }\n        return sum;\n}\nvoid change(int h,int w){\n        int a[9]={0,1,1,0,-1,-1,1,-1,0};\n        for(int i =0;i<8;i++){\n                m[h+a[i]][w+a[i+1]]++;\n        }\n}\n\nint main(){\n        int h,w;\n        cin>>h>>w;\n        for(int i=0;i<h;i++){\n                for(int j=0;j<w;j++){\n                        char t;\n                        cin>>t;\n                        if(t=='.')f[i][j]=-1;\n                        else f[i][j]=t-'0';\n                }\n        }\n        for(int i=0;i<h;i++){\n                for(int j=0;j<w;j++){\n                        m[i][j]=count(i,j);\n                }\n        }\n        int c=0;\n        while(1){\n                bool end=true;\n                for(int i=1;i<h-1;i++){\n                        for(int j=1;j<w-1;j++){\n                                if(f[i][j]!=-1&&f[i][j]<=m[i][j]){\n                                        f[i][j]=-10;\n                                        end=false;\n                                }\n                        }\n                }\n                for(int i=1;i<h-1;i++){\n                        for(int j=1;j<w-1;j++){\n                                if(f[i][j]==-10){\n                                        f[i][j]=-1;\n                                        change(i,j);\n                                }\n                        }\n                }\n                if(end)break;\n                c++;\n        }\n        cout<<c<<endl;\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint f[1000][1000];\nint count(int h,int w){\n        int a[9]={0,1,1,0,-1,-1,1,-1,0},sum=0;\n        for(int i =0;i<8;i++){\n                if(f[h+a[i]][w+a[i+1]]==-1)sum++;\n        }\n        return sum;\n}\n\nint main(){\n        int h,w;\n        cin>>h>>w;\n        for(int i=0;i<h;i++){\n                for(int j=0;j<w;j++){\n                        char t;\n                        cin>>t;\n                        if(t=='.')f[i][j]=-1;\n                        else f[i][j]=t-'0';\n                }\n        }\n        int c=0;\n        while(1){\n                bool end=true;\n                for(int i=1;i<h-1;i++){\n                        for(int j=1;j<w-1;j++){\n                                if(f[i][j]!=-1&&count(i,j)>=f[i][j]){\n                                        end=false;\n                                        f[i][j]=-10;\n                                }\n                        }\n                }\n                for(int i=1;i<h-1;i++){\n                        for(int j=1;j<w-1;j++){\n                                if(f[i][j]==-10){\n                                        f[i][j]=-1;\n                                }\n                        }\n                }\n                if(end)break;\n                c++;\n        }\n        cout<<c<<endl;\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\nint h, w;\nvector<string> v;\nchar t[1001];\nint a[1000][1000];\nint dx[8] = {1, 1, 1, 0, -1, -1, -1, 0};\nint dy[8] = {-1, 0, 1, 1, 1, 0, -1, -1};\ntypedef pair<int, int> P;\nqueue<P> q[2];\nint b = 0;\nint ans;\n\nint main(){\n\tscanf(\"%d %d\", &h, &w);\n\tfor(int i=0; i<h; i++){\n\t\tscanf(\"%s\", t);\n\t\tv.push_back(t);\n\t}\n\tfor(int i=1; i<w-1; i++){\n\t\tfor(int j=1; j<h-1; j++){\n\t\t\tint c = 0;;\n\t\t\tfor(int k=0; k<8; k++){\n\t\t\t\tint nx, ny;\n\t\t\t\tnx = i + dx[k];\n\t\t\t\tny = j + dy[k];\n\t\t\t\tif(v[ny][nx] == '.') c++;\n\t\t\t}\n\t\t\ta[j][i] = c;\n\t\t}\n\t}\n\tfor(int i=1; i<w-1; i++){\n\t\tfor(int j=1; j<h-1; j++){\n\t\t\tif(v[j][i] != '.'){\n\t\t\t\tif(v[j][i] - '0' <= a[j][i]) q[0].push(P(i, j));\n\t\t\t}\n\t\t}\n\t}\n\n\twhile(q[b].size()){\n\t\twhile(q[b].size()){\n\t\t\tans++;\n\t\t\tP p = q[b].front();\n\t\t\tq[b].pop();\n\t\t\tfor(int i=0; i<8; i++){\n\t\t\t\tint nx, ny;\n\t\t\t\tnx = p.first + dx[i];\n\t\t\t\tny = p.second + dy[i];\n\t\t\t\ta[ny][nx] ++;\n\t\t\t\tif(v[ny][nx] == '.') continue;\n\t\t\t\tif(a[ny][nx] >= v[ny][nx] - '0') q[1-b].push(P(nx, ny));\n\t\t\t}\n\t\t}\n\t\tb=1-b;\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "int main() {\n\tint h, w;\n\tcin >> h >> w;\n\tvector<string> vec;\n\tfor (int i = 0; i < h; i++) {\n\t\tstring t;\n\t\tcin >> t;\n\t\tvec.emplace_back(t);\n\t}\n\tset<pair<int, int>> se;\n\tfor (int i = 1; i < h - 1; i++) {\n\t\tfor (int j = 1; j < w - 1; j++) {\n\t\t\tif (vec[i][j] == '.')continue;\n\t\t\tint cnt = 0;\n\t\t\tfor (int k = -1; k <= 1; k++) {\n\t\t\t\tfor (int l = -1; l <= 1; l++) {\n\t\t\t\t\tif (i == 0 && j == 0)continue;\n\t\t\t\t\tif (vec[i + k][j + l] == '.') {\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (cnt >= vec[i][j] - '0') {\n\t\t\t\tse.insert(make_pair(i, j));\n\t\t\t}\n\t\t}\n\t}\n\tfor (auto i : se) {\n\t\tvec[i.first][i.second] = '.';\n\t}\n\tint ans = 0;\n\tfor (;; ans++) {\n\t\tif (se.empty())break;\n\t\tset<pair<int, int>> temp;\n\t\tfor (auto i : se) {\n\t\t\tfor (int j = -1; j <= 1; j++) {\n\t\t\t\tfor (int k = -1; k <= 1; k++) {\n\t\t\t\t\tif (j == 0 && k == 0)continue;\n\t\t\t\t\tint x = i.first + j, y = i.second + k;\n\t\t\t\t\tif (vec[x][y] == '.')continue;\n\t\t\t\t\tint cnt = 0;\n\t\t\t\t\tfor (int l = -1; l <= 1; l++) {\n\t\t\t\t\t\tfor (int m = -1; m <= 1; m++) {\n\t\t\t\t\t\t\tif (l == 0 && m == 0)continue;\n\t\t\t\t\t\t\tif (vec[x + l][y + m] == '.') {\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (cnt >= vec[x][y] - '0') {\n\t\t\t\t\t\ttemp.insert(make_pair(x, y));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tse = temp;\n\t\tfor (auto i : se) {\n\t\t\tvec[i.first][i.second] = '.';\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<tuple>\nusing namespace std;\nint x[1005][1005], H, W;\nint solve(int r, int s) {\n\tif (r <= 0 || s <= 0 || r > H || s > W)return 0; int B = 0;\n\tfor (int i = -1; i <= 1; i++) { for (int j = -1; j <= 1; j++) { if (x[r + i][s + j] == 0)B++; } }\n\treturn B;\n}\nint main() {\n\tcin >> H >> W; queue<tuple<int, int, int>>Q;\n\tfor (int i = 1; i <= H; i++) { for (int j = 1; j <= W; j++) { char c; cin >> c; if (c == '.')x[i][j] = 0; else { x[i][j] = c - '0'; } } }\n\tvector<pair<int, int>>vec1;\n\tfor (int i = 1; i <= H; i++) {\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tif (solve(i, j) >= x[i][j] && x[i][j] != 0) { vec1.push_back(make_pair(i, j)); Q.push(make_tuple(i, j, 1)); }\n\t\t}\n\t}\n\tif (vec1.size() == 0) { cout << \"0\" << endl; return 0; }int Life = 1;\n\tfor (int i = 0; i < vec1.size(); i++) { x[vec1[i].first][vec1[i].second] = 0; }vec1.clear();\n\twhile (!Q.empty()) {\n\t\tint a1 = get<0>(Q.front()), a2 = get<1>(Q.front()), a3 = get<2>(Q.front()); Q.pop();\n\t\tif (a3 != Life) {\n\t\t\tfor (int i = 0; i < vec1.size(); i++) { x[vec1[i].first][vec1[i].second] = 0; }\n\t\t\tvec1.clear(); Life++;\n\t\t}\n\t\tfor (int i = -1; i <= 1; i++) {\n\t\t\tfor (int j = -1; j <= 1; j++) {\n\t\t\t\tif (solve(a1 + i, a2 + j) >= x[a1 + i][a2 + j] && x[a1 + i][a2 + j] != 0) {\n\t\t\t\t\tvec1.push_back(make_pair(a1 + i, a2 + j));\n\t\t\t\t\tQ.push(make_tuple(a1 + i, a2 + j, a3 + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << Life << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <utility>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n\n#define INF_LL 9000000000000000000\n#define INF 2000000000\n\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int i = (a);i < (b);i++)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> PPII;\ntypedef pair<int, PPII> PPPII;\n\nclass Union_find{\nprivate:\n\tvector<int> par;\n\tvector<int> rank;\n\tint n;\n\npublic:\n\tUnion_find(int a){\n\t\tn = a;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tpar.push_back(i);\n\t\t\trank.push_back(0);\n\t\t}\n\t}\n\n\tint find(int x){\n\t\tif(par[x] == x){\n\t\t\treturn x;\n\t\t}else{\n\t\t\treturn par[x] = find(par[x]);\n\t\t}\n\t}\n\n\tvoid unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return;\n\n\t\tif(rank[x] < rank[y]){\n\t\t\tpar[x] = y;\n\t\t}else{\n\t\t\tpar[y] = x;\n\t\t\tif(rank[x] == rank[y]) rank[x]++;\n\t\t}\n\t}\n\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n};\n\nint dx[3] = {-1, 1, 0};\n\nint main(void){\n\tint h, w;\n\tstring sand[1010][2];\n\tcin >> h >> w;\n\tREP(i, h){\n\t\tcin >> sand[i][0];\n\t}\n\tint cnt = 1;\n\tint res = 0;\n\twhile(cnt != 0){\n\t\tcnt = 0;\n\t\tFOR(i, 1, h-1){\n\t\t\tFOR(j, 1, w-1){\n\t\t\t\tint sarati = 0;\n\t\t\t\tREP(x, 3){\n\t\t\t\t\tREP(y, 3){\n\t\t\t\t\t\tif(x == 2 && y == 2) continue;\n\t\t\t\t\t\tif(sand[i+dx[x]][res%2][j+dx[y]] == '.') sarati++;\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(sand[i][res%2][j] != '.' && sarati >= sand[i][res%2][j]-'0'){\n\t\t\t\t\tsand[i][(res+1)%2][j] = '.';\n\t\t\t\t\tcnt++;\n\t\t\t\t}else{\n\t\t\t\t\tsand[i][(res+1)%2][j] = sand[i][res%2][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(cnt > 0) res++;\n\t}\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef pair<int,int>P;\n \nchar s[1000][1001];\nint d[1000][1000],cnt[1000][1000];\nint main(){\n    int h,w;scanf(\"%d%d\",&h,&w);\n    rep(i,h)scanf(\"%s\",s[i]);\n    int Max=0;\n    queue<P>que;\n    rep(i,h)rep(j,w){\n        if(s[i][j]=='.')continue;\n        for(int k=-1;k<=1;k++){\n            for(int l=-1;l<=1;l++){\n                int x=i+k,y=j+l;\n                if(0<=x&&x<h&&0<=y&&y<w&&s[x][y]=='.')cnt[i][j]++;\n            }\n        }\n        if(cnt[i][j]>=s[i][j]-'0'){\n            d[i][j]=Max=1;que.push(P(i,j));\n        }\n    }\n    while(!que.empty()){\n        P p=que.front();que.pop();\n        for(int i=-1;i<=1;i++)for(int j=-1;j<=1;j++){\n            int x=p.first+i,y=p.second+j;\n            if(0<=x&&x<h&&0<=y&&y<w&&s[x][y]!='.'&&!d[x][y]){\n                if(++cnt[x][y]>=s[x][y]-'0'){\n                    d[x][y]=Max=d[p.first][p.second]+1;que.push(P(x,y));\n                }\n            }\n        }\n    }\n    printf(\"%d\\n\",Max);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<queue>\nstruct QUE {\n\tint y;\n\tint x;\n\tint count;\n\tQUE(int a, int b, int c) { y = a, x = b, count = c; }\n};\n\nint map[1024][1024];\nqueue<QUE> q;\nint y_move[] = { -1, -1, -1, 0, 0, +1, +1, +1 }, x_move[] = { -1, 0, +1, -1, +1, -1, 0, +1 };\nint main() {\n\tint h, w;\n\tcin >> h >> w;\n\n\tfor (int i = 1; i <= h; ++i) {\n\t\tfor (int i2 = 1; i2 <= w; ++i2) {\n\t\t\tchar str;\n\t\t\tcin >> str;\n\t\t\tif (str == '.') { map[i][i2] = 0; q.push(QUE(i, i2, 1)); }\n\t\t\telse map[i][i2] = str - '0';\n\t\t}\n\t}\n\n\tint ans;\n\twhile (!q.empty()) {\n\t\tint y = q.front().y, x = q.front().x; ans = q.front().count;\n\t\tq.pop();\n\t\tfor (int k = 0; k < 8; ++k) {\n\t\t\tif (map[y + y_move[k]][x + x_move[k]] > 0) {\n\t\t\t\tmap[y + y_move[k]][x + x_move[k]]--;\n\t\t\t\tif (map[y + y_move[k]][x + x_move[k]] == 0) { q.push(QUE(y + y_move[k], x + x_move[k], ans + 1)); }\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans-1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <string>\n#include <set>\n#include <queue>\nusing namespace std;\n\nint h, w;\nvector<string> v;\nchar t[1001];\nint ans;\nint dx[8] = {1, 1, 1, 0, -1, -1, -1, 0};\nint dy[8] = {-1, 0, 1, 1, 1, 0, -1, -1};\ntypedef pair<int, int> P;\nqueue<P> q, r;\n\nint main(){\n\tscanf(\"%d %d\", &h, &w);\n\tfor(int i=0; i<h; i++){\n\t\tscanf(\"%s\", t);\n\t\tv.push_back(t);\n\t}\n\n\tfor(int i=1; i<w-1; i++){\n\t\tfor(int j=1; j<h-1; j++){\n\t\t\tif(v[j][i] == '.') continue;\n\t\t\tint c = 0;\n\t\t\tfor(int k=0; k<8; k++){\n\t\t\t\tint nx, ny;\n\t\t\t\tnx = i + dx[k];\n\t\t\t\tny = j + dy[k];\n\t\t\t\tif(v[ny][nx] == '.') c++;\n\t\t\t}\n\t\t\tif(v[j][i] - '0' <= c){\n\t\t\t\tq.push(P(i, j));\n\t\t\t}\n\t\t}\n\t}\n\twhile(q.size()){\n\t\tP p = q.front();\n\t\tq.pop();\n\t\tv[p.second][p.first] = '.';\n\t\tr.push(p);\n\t}\n\n\twhile(r.size()){\n\t\tans++;\n/*\n\t\tprintf(\"\\n\");\n\t\tfor(int i=0; i<h; i++)\n\t\t\tprintf(\"%s\\n\", v[i].c_str());\n*/\n\t\twhile(r.size()){\n\t\t\tP p = r.front();\n\t\t\tr.pop();\n\t\t\tfor(int k=0; k<8; k++){\n\t\t\t\tint nx, ny;\n\t\t\t\tnx = p.first + dx[k];\n\t\t\t\tny = p.second + dy[k];\n\t\t\t\tif(v[ny][nx] == '.') continue;\n\t\t\t\tint c = 0;\n\t\t\t\tfor(int l=0; l<8; l++){\n\t\t\t\t\tint mx, my;\n\t\t\t\t\tmx = nx + dx[l];\n\t\t\t\t\tmy = ny + dy[l];\n\t\t\t\t\tif(v[my][mx] == '.') c++;\n\t\t\t\t}\n\t\t\t\tif(v[ny][nx] - '0' <= c) q.push(P(nx, ny));\n\t\t\t}\n\t\t}\n\t\twhile(q.size()){\n\t\t\tP p = q.front();\n\t\t\tq.pop();\n\t\t\tv[p.second][p.first] = '.';\n\t\t\tr.push(p);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<queue>\n#define inRange(x,a,b) (a <= x && x < b)\n\nusing namespace std;\nint di[8] = {0,0,1,-1,1,1,-1,-1};\nint dj[8] = {1,-1,0,0,1,-1,1,-1};\n\nint main(){\n    int h, w;\n    cin >> h >> w;\n\n    char mat[h][w];\n    int arr[h][w];\n    memset(arr, 0, sizeof(arr));\n    queue<pair<int,pair<int,int>>> q;\n\n    for(int i = 0; i < h; i++){\n        for(int j = 0; j < w; j++){\n            cin >> mat[i][j];\n        }\n    }\n\n    for(int i = 0; i < h; i++){\n        for(int j = 0; j < w; j++){\n            if(mat[i][j] == '.'){\n                for(int k = 0; k < 8; k++){\n                    int ni = i+di[k], nj = j+dj[k];\n                    if(!inRange(ni,0,h) || !inRange(nj,0,w)) continue;\n                    arr[ni][nj]++;\n                    if(mat[ni][nj] != '.' && mat[ni][nj]-'0' == arr[ni][nj]){\n                        q.push({1, {ni,nj}});\n                    }\n                }\n            }\n        }\n    }\n    \n    int ans = 0;\n    while(!q.empty()){\n        auto p = q.front(); q.pop();\n        ans = p.first;\n        int i = p.second.first, j = p.second.second;\n        mat[i][j] = '.';\n        for(int k = 0; k < 8; k++){\n            int ni = i+di[k], nj = j+dj[k];\n            arr[ni][nj]++;\n            if(mat[ni][nj] != '.' && mat[ni][nj]-'0' == arr[ni][nj]){\n                q.push({ans+1, {ni,nj}});\n            }\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <utility>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n\n#define INF_LL 9000000000000000000\n#define INF 2000000000\n\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int i = (a);i < (b);i++)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> PPII;\ntypedef pair<int, PPII> PPPII;\n\nclass Union_find{\nprivate:\n\tvector<int> par;\n\tvector<int> rank;\n\tint n;\n\npublic:\n\tUnion_find(int a){\n\t\tn = a;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tpar.push_back(i);\n\t\t\trank.push_back(0);\n\t\t}\n\t}\n\n\tint find(int x){\n\t\tif(par[x] == x){\n\t\t\treturn x;\n\t\t}else{\n\t\t\treturn par[x] = find(par[x]);\n\t\t}\n\t}\n\n\tvoid unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return;\n\n\t\tif(rank[x] < rank[y]){\n\t\t\tpar[x] = y;\n\t\t}else{\n\t\t\tpar[y] = x;\n\t\t\tif(rank[x] == rank[y]) rank[x]++;\n\t\t}\n\t}\n\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n};\n\nint dx[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nint dy[8] = {1, 0, -1, 1, -1, 1, 0, -1};\n\nint main(void){\n\tint H, W;\n\tstring f[2][1010];\n\tcin >> H >> W;\n\tqueue<PII> que[2];\n\tREP(i, H){\n\t\tcin >> f[0][i];\n\t\tREP(j, W){\n\t\t\tif(f[0][i][j] != '.')\n\t\t\t\tque[0].push(PII(i, j));\n\t\t}\n\t}\n\tint cnt = 0;\n\tll res = 0;\n\twhile(1){\n\t\tcnt = 0;\n\t\tREP(i, 1010){\n\t\t\tf[(res+1)%2][i] = f[res%2][i];\n\t\t}\n\t\twhile(que[res%2].size()){\n\t\t\tPII p = que[res%2].front(); que[res%2].pop();\n\t\t\tint sarati = 0;\n\t\t\tREP(i, 8){\n\t\t\t\tif(f[res%2][p.first+dy[i]][p.second+dx[i]] == '.')\n\t\t\t\t\tsarati++;\n\t\t\t}\n\t\t\tif(f[res%2][p.first][p.second] != '.' && sarati >= f[res%2][p.first][p.second]-'0'){\n\t\t\t\tf[(res+1)%2][p.first][p.second] = '.';\n\t\t\t\tREP(i, 8){\n\t\t\t\t\tif(f[res%2][p.first+dy[i]][p.second+dx[i]] != '.')\n\t\t\t\t\t\tque[(res+1)%2].push({p.first+dy[i], p.second+dx[i]});\n\t\t\t\t}\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tif(cnt == 0) break;\n\t\telse res++;\n\t}\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\ntypedef pair< int, int > pii;\n\nconst int dx[8] = {0,1,1,1,0,-1,-1,-1}, dy[8] = {-1,-1,0,1,1,1,0,-1};\n\nint H, W, counter[1010][1010];\nstring grid[1010];\n\nint main() {\n\tcin >> H >> W;\n\tfor_(i,0,H) cin >> grid[i];\n\t\n\tqueue< pii > cur_que;\n\t\n\tfor_(y,0,H) for_(x,0,W) {\n\t\tcounter[y][x] = -1;\n\t\tif (grid[y][x] == '.') continue;\n\t\tcounter[y][x] = grid[y][x] - '0';\n\t\t\n\t\tfor_(d,0,8) {\n\t\t\tint xx = x + dx[d], yy = y + dy[d];\n\t\t\tif (grid[yy][xx] == '.') --counter[y][x];\n\t\t}\n\t\t\n\t\tif (counter[y][x] == 0) cur_que.push(pii(x, y));\n\t}\n\t\n\tqueue< pii > nxt_que;\n\t\n\tint ans = 0;\n\t\n\twhile (!cur_que.empty()) {\n\t\twhile (!cur_que.empty()) {\n\t\t\tpii p = cur_que.front(); cur_que.pop();\n\t\t\tint x = p.first, y = p.second;\n\t\t\t\n\t\t\tfor_(d,0,8) {\n\t\t\t\tint xx = x + dx[d], yy = y + dy[d];\n\t\t\t\t--counter[yy][xx];\n\t\t\t\tif (counter[yy][xx] == 0) nxt_que.push(pii(xx, yy));\n\t\t\t}\n\t\t}\n\t\t\n\t\t++ans;\n\t\tswap(cur_que, nxt_que);\n\t}\n\t\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\ntypedef pair< int, int > pii;\n\nconst int dx[8] = {0,1,1,1,0,-1,-1,-1}, dy[8] = {-1,-1,0,1,1,1,0,-1};\n\nint H, W, counter[1010][1010];\nstring grid[1010];\n\nint main() {\n\tcin >> H >> W;\n\tfor_(i,0,H) cin >> grid[i];\n\t\n\tqueue< pii > cur_que;\n\t\n\tfor_(y,0,H) for_(x,0,W) {\n\t\tcounter[y][x] = -1;\n\t\tif (grid[y][x] == '.') continue;\n\t\tcounter[y][x] = grid[y][x] - '0';\n\t\t\n\t\tfor_(d,0,8) {\n\t\t\tint xx = x + dx[d], yy = y + dy[d];\n\t\t\tif (grid[yy][xx] == '.') --counter[y][x];\n\t\t}\n\t\t\n\t\tif (counter[y][x] <= 0) cur_que.push(pii(x, y));\n\t}\n\t\n\tqueue< pii > nxt_que;\n\t\n\tint ans = 0;\n\t\n\twhile (!cur_que.empty()) {\n\t\twhile (!cur_que.empty()) {\n\t\t\tpii p = cur_que.front(); cur_que.pop();\n\t\t\tint x = p.first, y = p.second;\n\t\t\t\n\t\t\tfor_(d,0,8) {\n\t\t\t\tint xx = x + dx[d], yy = y + dy[d];\n\t\t\t\t--counter[yy][xx];\n\t\t\t\tif (counter[yy][xx] == 0) nxt_que.push(pii(xx, yy));\n\t\t\t}\n\t\t}\n\t\t\n\t\t++ans;\n\t\tswap(cur_que, nxt_que);\n\t}\n\t\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#define ll long long\nusing namespace std;\n\nconst int dy[16] = { 0,-1, 0, 1, 1,-1, 1,-1, 0,-2, 0, 2 };\nconst int dx[16] = { 1, 0,-1, 0, 1, 1,-1,-1, 2, 0,-2, 0 };\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tll H, W; cin >> H >> W;\n\tvector<vector<ll>> m(H + 1, vector<ll>(W + 1, -1));\n\tfor (int i = 1; i <= H;i++) {\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tchar c; cin >> c;\n\t\t\tif (c != '.') {\n\t\t\t\tm[i][j] = c - '0';\n\t\t\t}\n\t\t}\n\t}\n\tbool f;\n\tint count = 0;\n\twhile (true) {\n\t\tf = false;\n\t\tauto temp_m = m;\n\t\tfor (int i = 2; i <= H - 1;i++) {\n\t\t\tfor (int j = 2; j <= W - 1; j++) {\n\t\t\t\tif (temp_m[i][j] > 0) {\n\t\t\t\t\tint count2 = 0;\n\t\t\t\t\tfor (int k = 0; k < 8; k++) {\n\n\t\t\t\t\t\tif (temp_m[i + dx[k]][j + dy[k]] == -1) {\n\t\t\t\t\t\t\tcount2++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (count2 >= temp_m[i][j]) {\n\t\t\t\t\t\tm[i][j] = -1;\n\t\t\t\t\t\tf = true;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\tfor (int i = 1; i <= H;i++) {\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\tif (m[i][j] == -1) {\n\t\t\t\t\tcout << \"# \";continue;\n\t\t\t\t}\n\t\t\t\tcout << m[i][j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << endl;\n\t\t*/\n\n\t\tif (f == true) count++;\n\t\telse break;\n\t}\n\n\tcout << count << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <queue>\n#include <set>\n#include <algorithm>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nstring board[1001];\nint dx[8] = {0, 1, 1, 1, 0, -1, -1, -1};\nint dy[8] = {1, 1, 0, -1, -1, -1, 0, 1};\nint h, w;\nbool hantei(int y, int x){\n\tif(0 <= y && y < h && 0 <= x && x < w) return true;\n\telse return false;\n}\n\nint main(void){\n\tcin >> h >> w;\n\trep(i, h) cin >> board[i];\n\tqueue<pair<int, int> > q1, q2;\n\trep(i, h)rep(j, w){\n\t\tif(board[i][j] != '.') q1.push(make_pair(i, j));\n\t}\n\n\tint ans = -1, cnt = 0, nowy, nowx;\n\tbool flag = true;\n\twhile(flag){\n\t\tflag = false; ans++;\n\t\tvector<pair<int, int> > memo;//?????????????????????????????????????????????????????????\n\t\tset<pair<int, int> > s;\n\t\tif(cnt % 2 == 0){\n\t\t\twhile(!q1.empty()){//q1??????????????\n\t\t\t\tpair<int, int> now = q1.front(); q1.pop();\n\t\t\t\tif(board[now.first][now.second] == '.') continue;\n\t\t\t\tint tmp = 0;\n\t\t\t\trep(i, 8){\n\t\t\t\t\tint nowy = now.first + dy[i], nowx = now.second + dx[i];\n\t\t\t\t\tif(!hantei(nowy, nowx)) continue;\n\t\t\t\t\tif(board[nowy][nowx] == '.')tmp++;\n\t\t\t\t}\n\t\t\t\tif(tmp >= board[now.first][now.second] - '0'){\n\t\t\t\t\tmemo.push_back(make_pair(now.first, now.second));\n\t\t\t\t\trep(k, 8){//???????????????????????????????????????????????????????????????????\n\t\t\t\t\t\tint ny = now.first + dy[k], nx = now.second + dx[k];\n\t\t\t\t\t\tif(!hantei(ny, nx)) continue;\n\t\t\t\t\t\tif(board[ny][nx] != '.'){\n\t\t\t\t\t\t\ts.insert(make_pair(ny, nx));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\twhile(!q2.empty()){//q2??????????????\n\t\t\t\tpair<int, int> now = q2.front(); q2.pop();\n\t\t\t\tif(board[now.first][now.second] == '.') continue;\n\t\t\t\tint tmp = 0;\n\t\t\t\trep(i, 8){\n\t\t\t\t\tint nowy = now.first + dy[i], nowx = now.second + dx[i];\n\t\t\t\t\tif(!hantei(nowy, nowx)) continue;\n\t\t\t\t\tif(board[nowy][nowx] == '.')tmp++;\n\t\t\t\t}\n\t\t\t\tif(tmp >= board[now.first][now.second] - '0'){\n\t\t\t\t\tmemo.push_back(make_pair(now.first, now.second));\n\t\t\t\t\trep(k, 8){//???????????????????????????????????????????????????????????????????\n\t\t\t\t\t\tint ny = now.first + dy[k], nx = now.second + dx[k];\n\t\t\t\t\t\tif(!hantei(ny, nx)) continue;\n\t\t\t\t\t\tif(board[ny][nx] != '.'){\n\t\t\t\t\t\t\ts.insert(make_pair(ny, nx));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//???????????\n\t\trep(k, memo.size()){\n\t\t\tboard[memo[k].first][memo[k].second] = '.';\n\t\t}\n\t\tif(cnt % 2 == 0){\n\t\t\tfor(auto x : s) q2.push(make_pair(x.first, x.second));\n\t\t}else{\n\t\t\tfor(auto x : s) q1.push(make_pair(x.first, x.second));\n\t\t}\n\t\tcnt++;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint h,w;\nint map[1001][1001];\nint dx[9]={1,1,1,0,0,0,-1,-1,-1},dy[9]={1,0,-1,1,0,-1,1,0,-1};\nint qx[1000001],qy[1000001],ql[1000001];\nint head=0,tail=0;\nvoid BFS(int y,int x,int len){\n\tmap[y][x]--;\n\tfor(int i=0;i<9;i++){\n\t\tif(x+dx[i]>=0&&x+dx[i]<w&&y+dy[i]>=0&&y+dy[i]<h){\n\t\t\tmap[y+dy[i]][x+dx[i]]--;\n\t\t\tif(map[y+dy[i]][x+dx[i]]==0){\n\t\t\t\tqx[tail]=x+dx[i],qy[tail]=y+dy[i];\n\t\t\t\tql[tail]=len+1;\n\t\t\t\ttail++;\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\tcin>>h>>w;\n\tchar z;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tcin>>z;\n\t\t\tif(z=='.'){\n\t\t\t\tmap[i][j]=0;\n\t\t\t\tqy[tail]=i,qx[tail]=j;\n\t\t\t\tql[tail]=0;\n\t\t\t\ttail++;\n\t\t\t}\n\t\t\telse map[i][j]=z-'0';\n\t\t}\n\t}\n\tint ans=0;\n\twhile(true){\n\t\tif(head==tail)break;\n\t\tans=max(ans,ql[head]);\n\t\tBFS(qy[head],qx[head],ql[head]);\n\t\thead++;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <queue>\nusing namespace std;\ntypedef pair<int, int> P;\n \nint h, w, ans;\nint castle[1001][1001], times[1001][1001];\nint dx[] = {-1, 0, 1, -1, 1, -1, 0, 1}, dy[] = {-1, -1, -1, 0, 0, 1, 1, 1};\nchar beach[1001][1001];\n \ninline int input_i(){\n\tint temp;\n\tscanf(\"%d\", &temp);\n\treturn temp;\n}\n\ninline string input_s(){\n\tstring temp;\n\tscanf(\"%s\", temp);\n\treturn temp;\n}\n\n\nint main(){\n    h = input_i();\n    w = input_i();\n    for(int i = 0; i < h; i++){\n        beach[i] = input_s();\n    }\n \n    queue<P> Q;\n    for(int i = 0; i < h; i++){\n        for(int j = 0; j < w; j++){\n            if(beach[i][j] == '.'){\n                Q.push(P(i, j));\n            } else{\n                castle[i][j] = beach[i][j] - '0';\n            }\n        }\n    }\n \n    while(Q.size()){\n        P p = Q.front();\n        Q.pop();\n        ans = max(ans, times[p.first][p.second]);\n \n        for(int i = 0; i < 8; i++){\n            int y = p.first + dy[i], x = p.second + dx[i];\n            if(y < 0 || y >= h || x < 0 || x >= w){\n                continue;\n            }\n \n            castle[y][x]--;\n            if(castle[y][x] == 0){\n                Q.push(P(y, x));\n                times[y][x] = times[p.first][p.second] + 1;\n            }\n        }\n    }\n \n    printf(\"%d\\n\", ans);\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <tuple>\n#include <utility>\n#include <cstring>\n\nusing namespace std;\n\nint h,w;\nchar bch[1003][1003];\nbool done[1003][1003];\n\nint wav (int i, int j)\n{\n    int c=0;\n    if (bch[i-1][j-1]=='.') c++;\n    if (bch[i-1][j]=='.') c++;\n    if (bch[i-1][j+1]=='.') c++;\n    if (bch[i][j-1]=='.') c++;\n    if (bch[i][j+1]=='.') c++;\n    if (bch[i+1][j-1]=='.') c++;\n    if (bch[i+1][j]=='.') c++;\n    if (bch[i+1][j+1]=='.') c++;\n    return c;\n}\n\nint bfs ()\n{\n    int cnt, ans=0;\n    bool ok;\n    queue<tuple<int, int, int>> que;\n    vector<pair<int, int>> vec;\n    for (int i=1; i<h-1; i++)\n    {\n        for (int j=1; j<w-1; j++)\n        {\n            if (bch[i][j]=='.') continue;\n            cnt=wav(i, j);\n            if (cnt>=bch[i][j]-'0') que.push(make_tuple(1, i, j));\n        }\n    }\n    while (!que.empty())\n    {\n        int a=get<0>(que.front()), b=get<1>(que.front()), c=get<2>(que.front());\n        que.pop();\n        if (bch[b][c]=='.') continue;\n        if (a>ans)\n        {\n            ans=a;\n            for (auto u : vec)\n            {\n                int i=u.first, j=u.second;\n                bch[i][j]='.';\n            }\n            vec.clear();\n            memset(done, false, sizeof(done));\n            ok=false;\n        }\n        done[b][c]=true;\n        cnt=wav(b, c);\n        if (cnt<bch[b][c]-'0') continue;\n        vec.push_back({b,c});\n        ok=true;\n        if (bch[b-1][c-1]!='.' && !done[b-1][c-1]) que.push(make_tuple(a+1, b-1, c-1));\n        if (bch[b-1][c]!='.' && !done[b-1][c]) que.push(make_tuple(a+1, b-1, c));\n        if (bch[b-1][c+1]!='.' && !done[b-1][c+1]) que.push(make_tuple(a+1, b-1, c+1));\n        if (bch[b][c-1]!='.' && !done[b][c-1]) que.push(make_tuple(a+1, b, c-1));\n        if (bch[b][c+1]!='.' && !done[b][c+1]) que.push(make_tuple(a+1, b, c+1));\n        if (bch[b+1][c-1]!='.' && !done[b+1][c-1]) que.push(make_tuple(a+1, b+1, c-1));\n        if (bch[b+1][c]!='.' && !done[b+1][c]) que.push(make_tuple(a+1, b+1, c));\n        if (bch[b+1][c+1]!='.' && !done[b+1][c+1]) que.push(make_tuple(a+1, b+1, c+1));\n    }\n    /*if (ok) return ans;\n    else return ans-1;*/\n        return ans;\n}\n\nint main()\n{\n    cin>>h>>w;\n    for (int i=0; i<h; i++) for (int j=0; j<w; j++) cin>>bch[i][j];\n    cout<<bfs()<<'\\n';\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <array>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <sstream>\n#include <stdio.h>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <list>\n#include <numeric>\n#include <stack>\n\nusing namespace std;\n\n#define Rep(i,a,b) for(int i = a; i < b; i++)\n#define rep(i,b) Rep(i,0,b)\n#define rrep(i,a) for(int i = a; i >= 0; i--)\n#define allof(a) (a).begin(), (a).end()\n\ntypedef long long ll;\nconst int inf = 1e9 + 7;\nconst ll infll = 1ll << 60ll;\nconst ll mod = 1e9 + 7;\n// 0~3 4~7\nconstexpr int dx[] = { 1, 0, -1, 0, 1, 1, -1, -1 };\nconstexpr int dy[] = { 0, -1, 0, 1, 1, -1, -1, 1 };\n\n/*\n// \nll gcd(ll a, ll b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a % b);\n}\n\n// \nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}*/\n\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint h, w;\n\tcin >> h >> w;\n\tvector<string> field(h);\n\trep(i, h) cin >> field[i];\n\n\tqueue<pair<int, int>> que;\n\tvector<vector<bool>> isDead(h, vector<bool>(w, false));\n\tRep(i,1, h - 1) {\n\t\tRep(j, 1, w - 1) {\n\t\t\tif (field[i][j] == '.') continue;\n\t\t\tif (isDead[i][j]) continue;\n\t\t\tint cnt = 0;\n\t\t\trep(k, 8) {\n\t\t\t\tif (field[i + dy[k]][j + dx[k]] == '.')\n\t\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tif ((field[i][j] - '0') <= cnt) {\n\t\t\t\tque.push({ i, j });\n\t\t\t\tisDead[i][j] = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\n\tif (que.empty()) {\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\n\twhile (!que.empty()) {\n\t\tqueue<pair<int, int>> next;\n\t\tans++;\n\t\twhile (!que.empty()) {\n\t\t\tint x = que.front().second;\n\t\t\tint y = que.front().first;\n\t\t\tque.pop();\n\t\t\tfield[y][x] = '.';\n\n\t\t\trep(k, 8) {\n\t\t\t\tint cnt = 0;\n\t\t\t\tif (isDead[y + dy[k]][x + dx[k]]) continue;\n\t\t\t\tif (field[y + dy[k]][x + dx[k]] != '.') {\n\t\t\t\t\trep(j, 8) {\n\t\t\t\t\t\tif (field[y + dy[k] + dy[j]][x + dx[k] + dx[j]] == '.') {\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ((field[y + dy[k]][x + dx[k]] - '0') <= cnt) {\n\t\t\t\t\t\tnext.push({ y + dy[k], x + dx[k] });\n\t\t\t\t\t\tisDead[y + dy[k]][x + dx[k]] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tque = next;\n\t}\n\n\n\tcout << ans << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <queue>\nusing namespace std;\ntypedef pair<int, int> P;\n \nint h, w, ans;\nint castle[1001][1001], times[1001][1001];\nint dx[] = {-1, 0, 1, -1, 1, -1, 0, 1}, dy[] = {-1, -1, -1, 0, 0, 1, 1, 1};\nchar beach[1001][1001];\n \ninline int input(){\n\tint temp;\n\tscanf(\"%d\", &temp);\n\treturn temp;\n}\n\nint main(){\n    h = input();\n\tw = input();\n    for(int i = 0; i < h; i++){\n        beach[i] = input();\n    }\n \n    queue<P> Q;\n    for(int i = 0; i < h; i++){\n        for(int j = 0; j < w; j++){\n            if(beach[i][j] == '.'){\n                Q.push(P(i, j));\n            } else{\n                castle[i][j] = beach[i][j] - '0';\n            }\n        }\n    }\n \n    while(Q.size()){\n        P p = Q.front();\n        Q.pop();\n        ans = max(ans, times[p.first][p.second]);\n \n        for(int i = 0; i < 8; i++){\n            int y = p.first + dy[i], x = p.second + dx[i];\n            if(y < 0 || y >= h || x < 0 || x >= w){\n                continue;\n            }\n \n            castle[y][x]--;\n            if(castle[y][x] == 0){\n                Q.push(P(y, x));\n                times[y][x] = times[p.first][p.second] + 1;\n            }\n        }\n    }\n \n    printf(\"%d\\n\", ans);\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\nusing namespace std;\n\nint main()\n{\n  int h,w;\n  scanf(\"%d%d\",&h,&w);\n  static char M[1000][1001];\n  for(int i=0;i<h;i++){\n    scanf(\"%s\",M[i]);\n  }\n  static int K[1000][1001]={0};\n  int dx[8]={1,1,1,0,0,-1,-1,-1},dy[8]={-1,0,1,-1,1,-1,0,1};\n  queue<pair<int,int> > Q[2];\n  bool b=0;\n  for(int i=1;i<h-1;i++){\n    for(int j=1;j<w-1;j++){\n      for(int v=0;v<8;v++){\n\tint x=i+dx[v],y=j+dy[v];\n\tif(M[x][y]=='.'){\n\t  K[i][j]++;\n\t}\n      }\n      if(M[i][j]!='.'&&K[i][j]>=M[i][j]-'0'){\n\tQ[b].push(make_pair(i,j));\n      }\n    }\n  }\n  int t=0;\n  while(!Q[b].empty()){\n    while(!Q[b].empty()){\n      pair<int,int> p=Q[b].front();\n      Q[b].pop();\n      int i=p.first,j=p.second;\n      for(int v=0;v<8;v++){\n\tint x=i+dx[v],y=j+dy[v];\n\tK[x][y]++;\n\tif(M[x][y]!='.'&&K[x][y]==M[x][y]-'0'){\n\t  Q[!b].push(make_pair(x,y));\n\t}\n      }\n    }\n    t++;\n    b=!b;\n  }\n  printf(\"%d\\n\",t);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\nint h,w;\nchar bch[1003][1003];\n\nint bfs ()\n{\n    int ans=0, cas[1003][1003],c;\n    vector<pair<int, int>> que, vec;\n    for (int i=1; i<h-1; i++)\n    {\n        for (int j=1; j<w-1; j++)\n        {\n            if (bch[i][j]!='.')\n            {\n                c=0;\n                if (bch[i-1][j-1]=='.') c++;\n                if (bch[i-1][j]=='.') c++;\n                if (bch[i-1][j+1]=='.') c++;\n                if (bch[i][j-1]=='.') c++;\n                if (bch[i][j+1]=='.') c++;\n                if (bch[i+1][j-1]=='.') c++;\n                if (bch[i+1][j]=='.') c++;\n                if (bch[i+1][j+1]=='.') c++;\n                cas[i][j]=bch[i][j]-'0'-c;\n                if (cas[i][j]<=0) que.push_back({i, j});\n            }\n        }\n    }\n    while (1)\n    {\n        if (que.empty())\n        {\n            ans++;\n            for (auto u : vec)\n            {\n                int i=u.first, j=u.second;\n                if (bch[i-1][j-1]!='.') { cas[i-1][j-1]--; if (cas[i-1][j-1]==0) que.push_back({i-1, j-1}); }\n                if (bch[i-1][j]!='.') { cas[i-1][j]--; if (cas[i-1][j]==0) que.push_back({i-1, j}); }\n                if (bch[i-1][j+1]!='.') { cas[i-1][j+1]--; if (cas[i-1][j+1]==0) que.push_back({i-1, j+1}); }\n                if (bch[i][j-1]!='.') { cas[i][j-1]--; if (cas[i][j-1]==0) que.push_back({i, j-1}); }\n                if (bch[i][j+1]!='.') { cas[i][j+1]--; if (cas[i][j+1]==0) que.push_back({i, j+1}); }\n                if (bch[i+1][j-1]!='.') { cas[i+1][j-1]--; if (cas[i+1][j-1]==0) que.push_back({i+1, j-1}); }\n                if (bch[i+1][j]!='.') { cas[i+1][j]--; if (cas[i+1][j]==0) que.push_back({i+1, j}); }\n                if (bch[i+1][j+1]!='.') { cas[i+1][j+1]--; if (cas[i+1][j+1]==0) que.push_back({i+1, j+1}); }\n            }\n            vec.clear();\n        }\n        if (que.empty()) break;\n        vec.swap(que);\n    }\n    return ans;\n}\n\nint main()\n{\n    cin>>h>>w;\n    for (int i=0; i<h; i++) for (int j=0; j<w; j++) cin>>bch[i][j];\n    cout<<bfs()<<'\\n';\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <tuple>\n# include <unordered_map>\n# include <numeric>\n# include <complex>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconstexpr int INF = 2000000000;\nconstexpr int HINF = INF / 2;\nconstexpr double DINF = 100000000000000000.0;\nconstexpr long long LINF = 9223372036854775807;\nconstexpr long long HLINF = 4500000000000000000;\nconst double PI = acos(-1);\nint dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\n# define ALL(x)     (x).begin(),(x).end()\n# define UNIQ(c)    (c).erase(unique(ALL((c))), end((c)))\n# define mp         make_pair\n# define eb         emplace_back\n# define FOR(i,a,b) for(int i=(a);i<(b);++i)\n# define REP(i,n)   FOR(i,0,n)\n# define INIT       std::ios::sync_with_stdio(false);std::cin.tie(0);\n\nint main() {\n\tint h, w;\n\tcin >> h >> w;\n\tvector<string> vec;\n\tfor (int i = 0; i < h; i++) {\n\t\tstring t;\n\t\tcin >> t;\n\t\tvec.emplace_back(t);\n\t}\n\tset<pair<int, int>> se;\n\tfor (int i = 1; i < h - 1; i++) {\n\t\tfor (int j = 1; j < w - 1; j++) {\n\t\t\tif (vec[i][j] == '.')continue;\n\t\t\tint cnt = 0;\n\t\t\tfor (int k = -1; k <= 1; k++) {\n\t\t\t\tfor (int l = -1; l <= 1; l++) {\n\t\t\t\t\tif (i == 0 && j == 0)continue;\n\t\t\t\t\tif (vec[i + k][j + l] == '.') {\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (cnt >= vec[i][j] - '0') {\n\t\t\t\tse.insert(make_pair(i, j));\n\t\t\t}\n\t\t}\n\t}\n\tfor (auto i : se) {\n\t\tvec[i.first][i.second] = '.';\n\t}\n\tint ans = 0;\n\tfor (;; ans++) {\n\t\tif (se.empty())break;\n\t\tset<pair<int, int>> temp;\n\t\tfor (auto i : se) {\n\t\t\tfor (int j = -1; j <= 1; j++) {\n\t\t\t\tfor (int k = -1; k <= 1; k++) {\n\t\t\t\t\tif (j == 0 && k == 0)continue;\n\t\t\t\t\tint x = i.first + j, y = i.second + k;\n\t\t\t\t\tif (vec[x][y] == '.')continue;\n\t\t\t\t\tint cnt = 0;\n\t\t\t\t\tfor (int l = -1; l <= 1; l++) {\n\t\t\t\t\t\tfor (int m = -1; m <= 1; m++) {\n\t\t\t\t\t\t\tif (l == 0 && m == 0)continue;\n\t\t\t\t\t\t\tif (vec[x + l][y + m] == '.') {\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (cnt >= vec[x][y] - '0') {\n\t\t\t\t\t\ttemp.insert(make_pair(x, y));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tse = temp;\n\t\tfor (auto i : se) {\n\t\t\tvec[i.first][i.second] = '.';\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\nusing namespace std;\nstruct Point{ int x; int y; };\nint H, W;\nstring S[1000];\nint board[1000][1000];\nint board1[1000][1000];\nvector<Point>Now;\nvector<Point>Now1;\nint dx[8] = { -1, -1, -1, 0, 0, 1, 1, 1 };\nint dy[8] = { -1, 0, 1, -1, 1, -1, 0, 1 };\nint main()\n{\n\tint x, y;\n\tint i,j,k;\n\tint cou;\n\tint ans = 0;\n\tbool flag;\n\tscanf(\"%d%d\", &H, &W);\n\tfor (y = 0; y < H; y++)cin >> S[y];\n\tfor (y = 0; y < H; y++){\n\t\tfor (x = 0; x < W; x++){\n\t\t\tif (S[y][x] == '.')board[y][x] = -1;\n\t\t\telse board[y][x] = (S[y][x] - '0');\n\t\t}\n\t}\n\tfor (y = 0; y < H; y++){\n\t\tfor (x = 0; x < W; x++){\n\t\t\tPoint p;\n\t\t\tp.x = x; p.y = y;\n\t\t\tif(board[y][x]>0)Now.push_back(p);\n\t\t}\n\t}\n\twhile (true){\n\t\tflag = false;\n\t\tNow1.clear();\n\t\tfor (i = 0; i < (int)Now.size(); i++){\n\t\t\tfor (j = 0; j < 8; j++){\n\t\t\t\tcou = 0;\n\t\t\t\tx = Now[i].x + dx[j];\n\t\t\t\ty = Now[i].y + dy[j];\n\t\t\t\tfor (k = 0; k < 8; k++){\n\t\t\t\t\tif (board[y + dy[k]][x + dx[k]] == -1)cou++;\n\t\t\t\t}\n\t\t\t\tif (cou >= board[y][x] && board[y][x] != -1){\n\t\t\t\t\tboard1[y][x] = -1;\n\t\t\t\t\tNow1.push_back(Point{ x, y });\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\t\t\t\telse board1[y][x] = board[y][x];\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (x = 0; x < W; x++)for (y = 0; y < H; y++)board[y][x] = board1[y][x];\n\t\tNow.clear();\n\t\tfor (i = 0; i < (int)Now1.size(); i++)Now.push_back(Now1[i]);\n\t\tif (!flag)break;\n\t\tans++;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint a;\nint b;\nchar are[1001][1001];\nint kore[1001][1001];\nint sore[1001][1001];\nint ushi=0;\nint uma;\n\nint main(){\n\tcin >> a >> b;\n\tfor (int i = 0; i < a; i++){\n\t\tfor (int j = 0; j < b; j++){\n\t\t\tcin >> are[i][j];\n\t\t\tif (are[i][j] != '.'){\n\t\t\t\tkore[i - 1][j - 1]++;\n\t\t\t\tkore[i][j - 1]++;\n\t\t\t\tkore[i + 1][j - 1]++;\n\t\t\t\tkore[i - 1][j]++;\n\t\t\t\tkore[i + 1][j]++;\n\t\t\t\tkore[i - 1][j + 1]++;\n\t\t\t\tkore[i][j + 1]++;\n\t\t\t\tkore[i + 1][j + 1]++;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < a; i++){\n\t\t\tfor (int j = 0; j < b; j++){\n\t\t\t\tsore[i][j] = kore[i][j];\n\t\t\t}\n\t\t}\n\twhile (true){\n\t\tuma = 0;\n\t\tfor (int i = 0; i < a; i++){\n\t\t\tfor (int j = 0; j < b; j++){\n\t\t\t\tif (are[i][j] != '.'){\n\t\t\t\t\tif (9 - sore[i][j] > are[i][j]-48){\n\t\t\t\t\t\tare[i][j] = '.';\n\t\t\t\t\t\tkore[i - 1][j - 1]--;\n\t\t\t\t\t\tkore[i][j - 1]--;\n\t\t\t\t\t\tkore[i + 1][j - 1]--;\n\t\t\t\t\t\tkore[i - 1][j]--;\n\t\t\t\t\t\tkore[i + 1][j]--;\n\t\t\t\t\t\tkore[i - 1][j + 1]--;\n\t\t\t\t\t\tkore[i][j + 1]--;\n\t\t\t\t\t\tkore[i + 1][j + 1]--;\n\t\t\t\t\t\tuma = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (uma == 1){\n\t\t\tushi++;\n\t\t}\n\t\tif (uma == 0){\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < a; i++){\n\t\t\tfor (int j = 0; j < b; j++){\n\t\t\t\tsore[i][j] = kore[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tcout << ushi << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <tuple>\n#include <utility>\n#include <cstring>\n\nusing namespace std;\n\nint h,w;\nchar bch[1003][1003];\nbool done[1003][1003];\n\nint wav (int i, int j)\n{\n    int c=0;\n    if (bch[i-1][j-1]=='.') c++;\n    if (bch[i-1][j]=='.') c++;\n    if (bch[i-1][j+1]=='.') c++;\n    if (bch[i][j-1]=='.') c++;\n    if (bch[i][j+1]=='.') c++;\n    if (bch[i+1][j-1]=='.') c++;\n    if (bch[i+1][j]=='.') c++;\n    if (bch[i+1][j+1]=='.') c++;\n    return c;\n}\n\nint bfs ()\n{\n    int cnt, ans=0;\n    bool ok;\n    queue<tuple<int, int, int>> que;\n    vector<pair<int, int>> vec;\n    for (int i=1; i<h-1; i++)\n    {\n        for (int j=1; j<w-1; j++)\n        {\n            if (bch[i][j]=='.') continue;\n            cnt=wav(i, j);\n            if (cnt>=bch[i][j]-'0') que.push(make_tuple(1, i, j));\n        }\n    }\n    while (!que.empty())\n    {\n        int a=get<0>(que.front()), b=get<1>(que.front()), c=get<2>(que.front());\n        que.pop();\n        if (bch[b][c]=='.') continue;\n        if (a>ans)\n        {\n            ans=a;\n            for (auto u : vec)\n            {\n                int i=u.first, j=u.second;\n                bch[i][j]='.';\n            }\n            vec.clear();\n            memset(done, false, sizeof(done));\n            ok=false;\n        }\n        cnt=wav(b, c);\n        if (cnt<bch[b][c]-'0') continue;\n        vec.push_back({b,c});\n        ok=true;\n        if (bch[b-1][c-1]!='.' && !done[b-1][c-1]) { done[b-1][c-1]=true; que.push(make_tuple(a+1, b-1, c-1)); }\n        if (bch[b-1][c]!='.' && !done[b-1][c]) { done[b-1][c]=true; que.push(make_tuple(a+1, b-1, c)); }\n        if (bch[b-1][c+1]!='.' && !done[b-1][c+1]) { done[b-1][c+1]=true; que.push(make_tuple(a+1, b-1, c+1)); }\n        if (bch[b][c-1]!='.' && !done[b][c-1]) { done[b][c-1]=true; que.push(make_tuple(a+1, b, c-1)); }\n        if (bch[b][c+1]!='.' && !done[b][c+1]) { done[b][c+1]=true; que.push(make_tuple(a+1, b, c+1)); }\n        if (bch[b+1][c-1]!='.' && !done[b+1][c-1]) { done[b+1][c-1]=true; que.push(make_tuple(a+1, b+1, c-1)); }\n        if (bch[b+1][c]!='.' && !done[b+1][c]) { done[b+1][c]=true; que.push(make_tuple(a+1, b+1, c)); }\n        if (bch[b+1][c+1]!='.' && !done[b+1][c+1]) { done[b+1][c+1]=true; que.push(make_tuple(a+1, b+1, c+1)); }\n    }\n    if (!ok) return ans-1;\n    else return ans;\n}\n\nint main()\n{\n    cin>>h>>w;\n    for (int i=0; i<h; i++) for (int j=0; j<w; j++) cin>>bch[i][j];\n    cout<<bfs()<<'\\n';\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nstruct Data { int x,y; };\nint h,w;\nchar c[1010][1010];\n\ninline bool isValid(int nx,int ny) { return 0 <= nx && nx < w && 0 <= ny && ny < h; }\n\nint main(){\n  cin >> h >> w;\n  rep(i,h) {\n    string s;\n    cin >> s;\n    rep(j,w) c[i][j] = s[j];\n  }\n  int phase = 0;\n  deque<Data> deq;\n  rep(i,h) rep(j,w) if( c[i][j] != '.' ) {\n    int cnt = 0;\n    REP(dy,-1,2) REP(dx,-1,2) {\n      int nx = j + dx, ny = i + dy;\n      if( !isValid(nx,ny) ) continue;\n      if( c[ny][nx] == '.' ) ++cnt;\n    }\n    if( cnt >= ( c[i][j] - '0' ) ) deq.push_back((Data){j,i});\n  }\n\n  while( !deq.empty() ) {\n    ++phase;\n    deque<Data> next_deq;\n    rep(i,deq.size()) c[deq[i].y][deq[i].x] = '.';\n    rep(i,deq.size()) {\n      REP(dy,-1,2) REP(dx,-1,2){\n\tint nx = deq[i].x + dx, ny = deq[i].y + dy;\n\tif( !isValid(nx,ny) ) continue;\n\tif( c[ny][nx] == '.' ) continue;\n\tint cnt = 0;\n\tREP(dy2,-1,2) REP(dx2,-1,2) {\n\t  int nx2 = nx + dx2, ny2 = ny + dy2;\n\t  if( !isValid(nx2,ny2) ) continue;\n\t  if( c[ny2][nx2] == '.' ) ++cnt;\n\t}\n\tif( cnt >= ( c[ny][nx] - '0' ) ) next_deq.push_back((Data){nx,ny});\n      }\n      deq = next_deq;\n    }\n  }\n  \n  cout << phase << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) begin(r),end(r)\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\nconst int mod = 1000000007;\nconstexpr int inf = ((1<<30)-1)*2+1 ;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dx[] = {-1, 0, 1};\nconst int dy[] = {-1, 0, 1};\n\ninline bool value(int x,int y,int w,int h){\n  return (x >= 0 && x < w && y >= 0 && y < h);\n}\n\nll h,w;\nint im[1000][1000];\ntemplate<class T>\nbool solve(T &v){\n  auto tmp = v;\n  bool f = true;\n  rep(i,h){\n    rep(j,w){\n      if(v[i][j] != '.'){\n        ll cnt = 0;\n        rep(y,3){\n          rep(x,3){\n            ll nx = j+dx[x],ny = i + dy[y];\n            if(value(nx,ny,w,h)){\n              if(v[ny][nx] == '.')\n                ++cnt;\n            }\n          }\n        }\n        if(cnt >= v[i][j] - '0'){\n          tmp[i][j] = '.';\n          f = false;\n        }\n      }\n    }\n  }\n  v = tmp;\n  return f;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cin >> h >> w;\n  vector<vector<char>> v(h,vector<char>(w));\n  rep(i,h){\n    rep(j,w){\n      cin >> v[i][j];\n    }\n  }\n\n  ll ans = 0;\n  while(1){\n    if(solve(v)){\n      cout << ans << endl;\n      break;\n    }\n    ++ans;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mp make_pair\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;//cnt, coodinate\nstring grid[1111];\nint neiber[1111][1111];\nint dx[] = {0, 1, 1,  1,  0, -1, -1, -1};\nint dy[] = {1, 1, 0, -1, -1, -1,  0,  1};\nint w, h;\nbool renge(int x, int y){\n  if(0 <= x && x < w &&\n     0 <= y && y < h)return true;\n  return false;\n}\nbool del(int x, int y){\n  int cnt = 0;\n  if(renge(x, y) == false || \n     grid[y][x] == '.') return false;\n  for (int i = 0; i < 8; i++) {\n    int nx = x + dx[i], ny = y + dy[i];\n    if(renge(nx, ny) == false)continue;\n    if(grid[ny][nx] == '.')cnt++;\n  }\n  char tmp = grid[y][x];\n  neiber[y][x] = cnt;\n  if(cnt >= atoi(&tmp))return true;\n  else return false;\n}\n \nint main(int argc, char *argv[]){\n  queue<piii> que;\n  queue<pii> p;\n  cin >> h >> w;\n  for (int i = 0; i < h; i++) {\n    cin >> grid[i];\n  }\n  for (int i = 0; i < h; i++) {\n    for (int j = 0; j < w; j++) {\n      if(del(j, i)){\n        p.push(mp(j, i));\n        que.push(mp(1, mp(j, i)));\n      }\n    }\n  }\n  int ans = 0;\n  while(!que.empty()){\n    int cnt = que.front().first;\n    if(ans != cnt){\n      while(!p.empty()){\n        int x = p.front().first;\n        int y = p.front().second;\n        p.pop();\n        if(grid[y][x] == '.')continue;\n        grid[y][x] = '.';\n        for (int i = 0; i < 8; i++) {\n          int nx = x + dx[i], ny = y + dy[i];\n          if(!renge(nx, ny))continue;\n          neiber[ny][nx]++;\n        }\n      }\n    }\n    int x = que.front().second.first;\n    int y = que.front().second.second;\n    que.pop();\n    ans = cnt;\n    for (int i = 0; i < 8; i++) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if(renge(nx, ny) == false ||\n         grid[ny][nx] == '.' ||\n         grid[ny][nx] == '#')continue;\n      char tmp = grid[ny][nx];\n      if(neiber[ny][nx] >= atoi(&tmp)){\n        grid[y][x] = '#';\n        p.push(mp(nx, ny));\n        que.push(mp(cnt + 1, mp(nx, ny)));\n      }\n    }\n  }\n  std::cout << ans << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<functional>\nusing namespace std;\nstruct P {\n\tint time, cost;\n};\nstruct Q {\n\tint x, y;\n};\nconst int inf = 1000000;\nint a[1000][1000];//????????????????????????????\nint g[1000][1000];//??????????????????????\nP b[1000][1000];//????????????????????????\nint main() {\n\tint h, w;\n\tcin >> h >> w;\n\tstring s;\n\tfor (int i = 0; i < h; i++) {\n\t\tcin >> s;\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tif (s[j] == '.') a[i][j] = 0;\n\t\t\telse a[i][j] = (int)s[j] - '0';\n\t\t\tg[i][j] = 0;\n\t\t\tb[i][j] = P{ 0,0 };\n\t\t}\n\t}\n\tfor (int i = 0; i < h; i++) {\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tif (a[i][j] == 0) {\n\t\t\t\tfor (int x = -1; x <=1; x++) {\n\t\t\t\t\tfor (int y = -1; y <= 1; y++) {\n\t\t\t\t\t\tif (i + x < h&&i + x >= 0 && j + y < w&&j + y >= 0) {\n\t\t\t\t\t\t\tg[i + x][j + y]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tqueue<Q>p;\n\tint sum = 0;\n\tfor (int i = 0; i < h; i++) {\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tif (a[i][j] != 0 && a[i][j] <= g[i][j]) {\n\t\t\t\ta[i][j] = 0;\n\t\t\t\tb[i][j] = P{ 1,0 };\n\t\t\t\tsum = 1;\n\t\t\t\tfor (int x = -1; x <= 1; x++) {\n\t\t\t\t\tfor (int y = -1; y <= 1; y++) {\n\t\t\t\t\t\tif (i + x < h&&i + x >= 0 && j + y < w&&j + y >= 0) {\n\t\t\t\t\t\t\tp.push(Q{ i + x,j + y });\n\t\t\t\t\t\t\tb[i + x][j + y] = P{ 2,b[i + x][j + y].cost + 1 };\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\twhile (!p.empty()) {\n\t\tQ t = p.front(); p.pop();\n\t\tint i = t.x, j = t.y;\n\t\tif (a[i][j] <= g[i][j]+b[i][j].cost&&a[i][j]!=0) {\n\t\t\ta[i][j] = 0;\n\t\t\tsum = max(sum, b[i][j].time);\n\t\t\tfor (int x = -1; x <= 1; x++) {\n\t\t\t\tfor (int y = -1; y <= 1; y++) {\n\t\t\t\t\tif (i + x < h&&i + x >= 0 && j + y < w&&j + y >= 0) {\n\t\t\t\t\t\tif (a[i + x][j + y] > g[i + x][j + y] + b[i + x][j + y].cost) {\n\t\t\t\t\t\t\tb[i + x][j + y] = P{ max(b[i + x][j + y].time,b[i][j].time + 1),b[i + x][j + y].cost + 1 };\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (a[i + x][j + y] != 0&&a[i+x][j+y]>=g[i+x][j+y]+b[i+x][j+y].cost) {\n\t\t\t\t\t\t\tp.push(Q{ i + x,j + y });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} \n\t\t\t}\n\t\t}\n\t}\n\tcout << sum << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <time.h>\n#include <math.h>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <iterator>\n#include <sstream>\n#include <string>\n#include <bitset>\nusing namespace std;\n#define FOR(I,F,N) for(int I = F; I < (int)(N); I++)\n#define rep(i, n) FOR(i, 0, n)\n#define FIN(V) cout<<V<<endl\n#define pb push_back\n#define INF (1 << 28)\n\ntemplate<typename T>\nvoid remove(vector<T>& vector, unsigned int index){\nvector.erase(vector.begin() + index);\n}\n\ntypedef pair<int, int> P;\ntypedef long long ll;\ntypedef priority_queue<int> pq;\nint StrToInt(string);\nstring IntToStr(int);\nint dx[8] = {-1, 0, 1, 1, 1, 0, -1, -1};\nint dy[8] = {1, 1, 1, 0, -1, -1, -1, 0};\n\nint w, h, ans = 0;\nint state[1001][1001];\nint score[1001][1001];\nvoid show(){\n\trep(i,h){\n\t\trep(j,w){\n\t\t\tif(state[j][i] == 0)cout << '.';\n\t\t\telse cout << state[j][i];\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nint main(void){\n\tcin >> h >> w;\n\tfill_n(*state, 1001*1001, -1);\n\trep(i,h)rep(j,w){\n\t\tchar c;\n\t\tcin >> c;\n\t\tif(c == '.')state[j][i] = 0;\n\t\telse state[j][i] = c-'0';\n\t}\n\tqueue<P> que;\n\tint memo[1001][1001] ={0};\n\trep(i,h)rep(j,w){\n\t\tif(state[j][i] == 0)continue;\n\t\tint count = 0;\n\t\trep(k,8){\n\t\t\tint nx = j+dx[k];\n\t\t\tint ny = i+dy[k];\n\t\t\tif(nx < 0 || ny < 0 || state[nx][ny] == -1)continue;\n\t\t\tif(state[nx][ny] == 0)count++;\n\t\t}\n\n\t\tscore[j][i] = count;\n\t\tif(state[j][i] <= count && !memo[j][i]){\n\t\t\tmemo[j][i]=true;\n\t\t\tque.push(P(j, i));\n\t\t}\n\t}\n\t///show();\n\twhile(!que.empty()){\n\t\tqueue<P> reQue;\n\t\twhile(!que.empty()){\n\t\t\treQue.push(que.front());\n\t\t\t///cout << \"(\" << que.front().first << \",\" << que.front().second << \")\" << endl;\n\t\t\tP p = que.front();\n\t\t\tint x = p.first;\n\t\t\tint y = p.second;\n\t\t\tstate[x][y] = 0;\n\t\t\tscore[x][y] = 0;\n\t\t\trep(k,8){\n\t\t\t\tint nx = x+dx[k];\n\t\t\t\tint ny = y+dy[k];\n\t\t\t\tscore[nx][ny]++;\n\t\t\t}\n\t\t\tque.pop();\n\t\t}\n\t\tint memo2[1001][1001] = {0};\n\t\twhile(!reQue.empty()){\n\t\t\tP p = reQue.front();\n\t\t\treQue.pop();\n\t\t\tint x = p.first;\n\t\t\tint y = p.second;\n\t\t\t///cout << \"(\" << x << \",\" << y << \")\" << endl;\n\t\t\trep(k,8){\n\t\t\t\tint nx = x+dx[k];\n\t\t\t\tint ny = y+dy[k];\n\t\t\t\tif(nx < 0 || ny < 0 || state[nx][ny] == -1)continue;\n\t\t\t\tif(state[nx][ny] == 0 || state[nx][ny] == 9)continue;\n\t\t\t\tif(state[nx][ny] <= score[nx][ny] && !memo2[nx][ny]){\n\t\t\t\t\tmemo2[nx][ny]=1;\n\t\t\t\t\tque.push(P(nx, ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans++;\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}\n\n\n\nint StrToInt(string s){\n\tstringstream ss;\n\tss << s;\n\tint val;\n\tss >> val;\n\treturn val;\n}\nstring IntToStr(int i){\n\tstringstream ss;\n\tss << i;\n\treturn ss.str();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mp make_pair\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;//cnt, coodinate\nstring grid[1111];\nint neiber[1111][1111];\nint dx[] = {0, 1, 1,  1,  0, -1, -1, -1};\nint dy[] = {1, 1, 0, -1, -1, -1,  0,  1};\nint w, h;\nbool renge(int x, int y){\n  return (0 <= x && x < w &&\n          0 <= y && y < h);\n}\nbool del(int x, int y){\n  if(!renge(x, y) ||\n     grid[y][x] == '.') return false;\n  int cnt = 0;\n  for (int i = 0; i < 8; i++) {\n    int nx = x + dx[i], ny = y + dy[i];\n    if(!renge(nx, ny))continue;\n    if(grid[ny][nx] == '.')cnt++;\n  }\n  char tmp = grid[y][x];\n  neiber[y][x] = cnt;\n  return cnt >= atoi(&tmp);\n}\n \nint main(int argc, char *argv[]){\n  queue<piii> que;\n  cin >> h >> w;\n  for (int i = 0; i < h; i++) {\n    cin >> grid[i];\n  }\n  for (int i = 0; i < h; i++) {\n    for (int j = 0; j < w; j++) {\n      if(del(j, i)){\n        que.push(mp(1, mp(j, i)));\n      }\n    }\n  }\n  int ans = 0;\n  while(!que.empty()){\n    int cnt = que.front().first;\n    int x = que.front().second.first;\n    int y = que.front().second.second;\n    que.pop();\n    if(grid[y][x] == '.')continue;\n    grid[y][x] = '.';\n    ans = cnt;\n    for (int i = 0; i < 8; i++) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if(!renge(nx, ny))continue;\n      char tmp = grid[ny][nx];\n      if(neiber[ny][nx] >= atoi(&tmp)){\n        que.push(mp(cnt + 1, mp(nx, ny)));\n      }\n    }\n  }\n  std::cout << ans << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <queue>\nusing namespace std;\nchar field[1000][1000];\nint dx[] = {1,1,1,0,0,-1,-1,-1};\nint dy[] = {1,0,-1,1,-1,1,0,-1};\nint x,y,d,ans;\nint main()\n{\n    queue<int> str[3];\n    int h,w;\n    char kara;\n    scanf(\"%d%d\",&h,&w);\n    ans = 0;\n    for(int i = 0; i < h; i++)\n    {\n        for(int j = 0; j < w + 1; j++)\n        {\n            scanf(\"%c\",&field[i][j]);\n        }\n    }\n    for(int i = 0; i < h; i++)\n    {\n        for(int j = 1; j < w + 1; j++)\n        {\n            if(field[i][j] == '.')\n            {\n                str[0].push(i);\n                str[1].push(j);\n                str[2].push(0);\n            }\n        }\n    }\n    while(str[0].size())\n    {\n        x = str[0].front();str[0].pop();\n        y = str[1].front();str[1].pop();\n        d = str[2].front();str[2].pop();\n        if(ans < d)ans = d;\n        for(int i = 0; i < 8; i++)\n        {\n            if(0 <= x + dx[i]&&x + dx[i] < w&&0 <= y + dy[i]&&y + dy[i] < h)\n            {\n                field[x + dx[i]][y + dy[i]]--;\n                if(field[x + dx[i]][y + dy[i]] == '0')\n                {\n                    str[0].push(x + dx[i]);\n                    str[1].push(y + dy[i]);\n                    str[2].push(d + 1);\n                }\n            }\n        }\n    }\n    printf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\n#define MAX_SIZE 1000+10\n\nint map[MAX_SIZE][MAX_SIZE];\nint m_cnt[MAX_SIZE][MAX_SIZE];\n\nint my[8] = { 1,1,1,0,-1,-1,-1,0 };\nint mx[8] = { 1,0,-1,-1,-1,0,1,1 };\n\nstruct ST\n{\n\tint cnt;\n\tint y, x;\n};\n\nint main(void)\n{\n\tqueue<ST> QU;\n\tST now, tp;\n\n\tint h, w;\n\tchar tmp;\n\n\tint c_max=0;\n\n\tint i, j,k;\n\n\tcin >> h >> w;\n\n\tfor (i = 1; i <= h; i++)\n\t{\n\t\tscanf(\"%c\", &tmp);\n\t\tfor (j = 1; j <= w; j++)\n\t\t{\n\t\t\tscanf(\"%c\", &tmp);\n\t\t\tif (tmp == '.')\n\t\t\t{\n\t\t\t\tmap[i][j] = -1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmap[i][j] = tmp - 48;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 2; i < h; i++)\n\t{\n\t\tfor (j = 2; j < w; j++)\n\t\t{\n\t\t\tfor (k = 0; k < 8; k++)\n\t\t\t{\n\t\t\t\tif (map[i + my[k]][j + mx[k]] == -1)\n\t\t\t\t{\n\t\t\t\t\tm_cnt[i][j]++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (map[i][j] <= m_cnt[i][j] && map[i][j]!=-1)\n\t\t\t{\n\t\t\t\tnow.cnt = 1;\n\t\t\t\tnow.y = i;\n\t\t\t\tnow.x = j;\n\t\t\t\tQU.push(now);\n\t\t\t}\n\t\t}\n\t}\n\n\twhile (!QU.empty())\n\t{\n\t\tnow = QU.front();\n\t\tQU.pop();\n\n\t\tif (map[now.y][now.x] == -1)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tmap[now.y][now.x] = -1;\n\n\t\tc_max = max(c_max, now.cnt);\n\n\t\tfor (i = 0; i < 8; i++)\n\t\t{\n\t\t\tm_cnt[now.y + my[i]][now.x + mx[i]]++;\n\n\t\t\tif (map[now.y + my[i]][now.x + mx[i]] <= m_cnt[now.y + my[i]][now.x + mx[i]] && map[now.y + my[i]][now.x + mx[i]] != -1)\n\t\t\t{\n\t\t\t\ttp.cnt = now.cnt+1;\n\t\t\t\ttp.y = now.y + my[i];\n\t\t\t\ttp.x = now.x + mx[i];\n\t\t\t\tQU.push(tp);\n\t\t\t}\n\t\t}\n\n\n\t}\n\n\tcout << c_max << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mp make_pair\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;//cnt, coodinate\nstring grid[1111];\nint neiber[1111][1111];\nint dx[] = {0, 1, 1,  1,  0, -1, -1, -1};\nint dy[] = {1, 1, 0, -1, -1, -1,  0,  1};\nint w, h;\n\nbool del(int x, int y){\n  int cnt = 0;\n  if(!(0 <= x && x < w &&\n       0 <= y && y < h))return false;\n  if(grid[y][x] == '.') return false;\n  for (int i = 0; i < 8; i++) {\n    int nx = x + dx[i], ny = y + dy[i];\n    if(!(0 <= nx && nx < w &&\n         0 <= ny && ny < h))continue;\n    if(grid[ny][nx] == '.')cnt++;\n  }\n  char tmp = grid[y][x];\n  //std::cout << cnt << std::endl;\n  neiber[y][x] = cnt;\n  if(cnt >= atoi(&tmp))return true;\n  else return false;\n}\n\nint main(int argc, char *argv[]){\n  queue<piii> que;\n  queue<pii> p;\n  cin >> h >> w;\n  for (int i = 0; i < h; i++) {\n    cin >> grid[i];\n  }\n  for (int i = 0; i < h; i++) {\n    for (int j = 0; j < w; j++) {\n      if(del(j, i)){\n        p.push(mp(j, i));\n        que.push(mp(1, mp(j, i)));\n      }\n    }\n  }\n  int ans = 0;\n  while(!que.empty()){\n    int cnt = que.front().first;\n    if(ans != cnt){\n      while(!p.empty()){\n        int x = p.front().first;\n        int y = p.front().second;\n        p.pop();\n        if(grid[y][x] == '.')continue;\n        grid[y][x] = '.';\n        for (int i = 0; i < 8; i++) {\n          int nx = x + dx[i], ny = y + dy[i];\n          neiber[ny][nx]++;\n        }\n      } \n    }\n    int x = que.front().second.first;\n    int y = que.front().second.second;\n    que.pop();\n    ans = cnt;\n    //std::cout << cnt << std::endl;\n    //std::cout << \"x:\" << x << \" y:\" << y << std::endl;\n    for (int i = 0; i < 8; i++) {\n      int nx = x + dx[i], ny = y + dy[i];\n      char tmp = grid[ny][nx];\n      if(neiber[ny][nx] >= atoi(&tmp) && grid[ny][nx] != '.'){\n        p.push(mp(nx, ny));\n        que.push(mp(cnt + 1, mp(nx, ny)));\n      }\n    }\n  }\n  std::cout << ans << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rrep(i,n) for(int i=1;i<=n;i++)\n#define drep(i,n) for(int i=n;i>=0;i--)\n#define MAX 200004\n#define B 100\n#define dpb push_back\n#define fi first\n#define se second\ntypedef pair<int, int> P;\ntypedef long long ll;\nconst int inf = 1e9;\nconst ll INF = 1e16;\n//__gcd(a,b), __builtin_popcount(a);\n\nchar a[56][56];\nint fld1[56][56], fld2[56][56], flag[56][56];\nint dy[8] = {-1, -1, -1, 0, 0, 1, 1, 1};\nint dx[8] = {0, -1, 1, -1, 1, 0, -1, 1};\nqueue<P> q1, q2;\n\nint bfs1(){\n\tint check = 1;\n\trep(i,56)rep(j,56){\n\t\tif(fld2[i][j] <= 0)\n\t\tfld1[i][j] = fld2[i][j] = inf;\n\t\telse fld1[i][j] = fld2[i][j];\n\t}\n\twhile(!q2.empty()){\n\t\tP p = q2.front();q2.pop();\n\t\tint y = p.fi, x = p.se;\n\t\tif(fld2[y][x] == inf){\n\t\t\tfor(int i = 0;i < 8;i++){\n\t\t\t\tif(fld2[y+dy[i]][x+dx[i]] != inf){\n\t\t\t\t\tif(fld1[y+dy[i]][x+dx[i]] == fld2[y+dy[i]][x+dx[i]]){\n\t\t\t\t\t\tcheck = 0;\n\t\t\t\t\t\tq1.push(P(y+dy[i], x+dx[i]));\n\t\t\t\t\t}\n\t\t\t\t\tfld1[y+dy[i]][x+dx[i]]--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn check;\n}\n\nint bfs2(){\n\tint check = 1;\n\trep(i,56)rep(j,56){\n\t\tif(fld1[i][j] <= 0)\n\t\tfld1[i][j] = fld2[i][j] = inf;\n\t\telse fld2[i][j] = fld1[i][j];\n\t}\n\twhile(!q1.empty()){\n\t\tP p = q1.front();q1.pop();\n\t\tint y = p.fi, x = p.se;\n\t\tif(fld1[y][x] == inf){\n\t\t\tfor(int i = 0;i < 8;i++){\n\t\t\t\tif(fld1[y+dy[i]][x+dx[i]] != inf){\n\t\t\t\t\tif(fld2[y+dy[i]][x+dx[i]] == fld1[y+dy[i]][x+dx[i]]){\n\t\t\t\t\t\tcheck = 0;\n\t\t\t\t\t\tq2.push(P(y+dy[i], x+dx[i]));\n\t\t\t\t\t}\n\t\t\t\t\tfld2[y+dy[i]][x+dx[i]]--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn check;\n}\n\nint main(){\n\tint h, w;\n\tscanf(\"%d%d\", &h, &w);\n\tfill((int*)fld1, (int*)(fld1+56), inf);\n\tfill((int*)fld2, (int*)(fld2+56), inf);\n\trep(i,h)scanf(\"%s\", a[i]);\n\trrep(i,h)rrep(j,w){\n\t\tif(a[i-1][j-1] != '.')\n\t\tfld1[i][j] = fld2[i][j] = a[i-1][j-1]-'0';\n\t}\n\t\n\tfor(int y = 1;y <= h;y++){\n\t\tfor(int x = 1;x <= w;x++){\n\t\t\tif(fld1[y][x] == inf){\n\t\t\tfor(int i = 0;i < 8;i++){\n\t\t\t\t\n\t\t\t\tint yy = y+dy[i], xx = x+dx[i];\n\t\t\t\tif(fld1[yy][xx] != inf){\n\t\t\t\t\tif(flag[yy][xx] == 0){\n\t\t\t\t\t\tq2.push(P(yy, xx));\n\t\t\t\t\t}\n\t\t\t\t\tfld2[yy][xx]--;\n\t\t\t\t\tflag[yy][xx] = 1;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i = 0;i <= h;i++){\n\t\tfor(int j = 0;j <= w;j++){\n\t\t\tif(fld2[i][j] <= 0)fld2[i][j] = inf;\n\t\t}\n\t}\n\t\n\tint check = 1, ans = 0;\n\twhile(1){\n\t\tcheck = bfs1();\n\t\tif(check == 1)break;\n\t\tans++;\n\t\t//printf(\"*\\n\");\n\t\tcheck = bfs2();\n\t\tif(check == 1)break;\n\t\tans++;\n\t}\n\t/*while(!q1.empty()){\n\t\tP p = q1.front();q1.pop();\n\t\tprintf(\"%d %d\\n\", p.fi, p.se);\n\t}*/\n\t\n\t/*for(int i = 0;i <= h;i++){\n\t\tfor(int j = 0;j <= w;j++){\n\t\t\tprintf(\"%10d \", fld1[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\tprintf(\"\\n\");\n\tfor(int i = 0;i <= h;i++){\n\t\tfor(int j = 0;j <= w;j++){\n\t\t\tprintf(\"%10d \", fld2[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}*/\n\t\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint dy[]={-1,-1,-1,0,0,1,1,1};\nint dx[]={-1,0,1,-1,1,-1,0,1};\n\nint H,W;\nchar fld[1010][1010];\n\nint cnt[1010][1010];\n\nsigned main(){\n    scanf(\"%lld%lld\",&H,&W);\n    rep(i,H)scanf(\"%s\",fld[i]);\n\n    queue<pint>que;\n\n    rep(i,H)rep(j,W){\n        if(fld[i][j]=='.')continue;\n        rep(d,8){\n            int ny=i+dy[d],nx=j+dx[d];\n            if(fld[ny][nx]=='.')cnt[i][j]++;\n        }\n        if(cnt[i][j]>=fld[i][j]-'0')que.push(pint(i,j));\n    }\n\n    for(int t=0;;t++){\n        if(que.size()==0){\n            cout<<t<<endl;\n            return 0;\n        }\n        queue<pint>que2;\n        while(que.size()){\n            int y,x;\n            tie(y,x)=que.front();\n            que.pop();\n            fld[y][x]='.';\n            rep(i,8){\n                int ny=y+dy[i],nx=x+dx[i];\n                if(fld[ny][nx]=='.')continue;\n                if(++cnt[ny][nx]==fld[ny][nx]-'0'){\n                    que2.push(pint(ny,nx));\n                }\n            }\n        }\n        que=que2;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define f first\n#define s second\ntypedef pair<int,int> P;\nint x,y,i,j,k,mp[1010][1010],cnt[1010][1010],flg,sum,n,m;\nP p[1000000];\nint main(void)\n{\n\tqueue<P> qu;\n\tchar s,d[11]={'1','2','3','4','5','6','7','8','9'};\n\tint b[11]={1,2,3,4,5,6,7,8,9};\n\tint xx[8]={1,0,-1,0,1,-1,1,-1};\n\tint yy[8]={0,1,0,-1,1,-1,-1,1};\n\tcin>>x>>y;\n\tfor(i=0;i<=x+1;i++) for(j=0;j<=y+1;j++) mp[i][j]=0,cnt[i][j]=0;\n\tfor(i=1;i<=x;i++){\n\t\tfor(j=1;j<=y;j++){\n\t\t\tcin>>s;\n\t\t\tif(s=='.') qu.push(P(i,j));\n\t\t\tfor(k=0;k<9;k++) if(s==d[k]) mp[i][j]=b[k];\n\t\t}\n\t}\n\tsum=0;\n\twhile(qu.size()!=0){\n\t\tk=0; flg=0;\n\t\twhile(qu.size()!=0){\n\t\t\tp[k]=qu.front();\n\t\t\tqu.pop();\n\t\t\tk++;\n\t\t}\n\t\tfor(i=0;i<k;i++){\n\t\t\tfor(j=0;j<8;j++){\n\t\t\t\tn=p[i].f+xx[j];\n\t\t\t\tm=p[i].s+yy[j];\n\t\t\t\tcnt[n][m]++;\n\t\t\t\t//\n\t\t\t\tif(mp[n][m]!=0&&mp[n][m]<=cnt[n][m]){\n\t\t\t\t\tqu.push(P(n,m));\n\t\t\t\t\tmp[n][m]=0;\n\t\t\t\t\tflg=1;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}/*\n\t\tfor(i=1;i<=x;i++){\n\t\t\tfor(j=1;j<=y;j++){\n\t\t\t\tif(mp[i][j]!=0&&mp[i][j]<=cnt[i][j]){\n\t\t\t\t\tqu.push(P(i,j));\n\t\t\t\t\tmp[i][j]=0;\n\t\t\t\t\tflg=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}/*\n\t\tfor(i=1;i<=x;i++){\n\t\t\tfor(j=1;j<=y;j++){\n\t\t\t\tcout<<mp[i][j];\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}\n\t\tcout<<endl;*/\n\t\tif(flg==1) sum++;\n\t}\n\tcout<<sum<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> P;\n\nconst int dxy[] = {-1, 0, 1};\n\nchar sand[1024][1024];\nchar tmp[1024][1024];\n\nbool check(int y, int x)\n{\n    int cnt = 0;\n\n    for (int i = 0; i < 3; i++){\n        for (int j = 0; j < 3; j++){\n            cnt += (sand[y + dxy[i]][x + dxy[j]] == '.');\n        }\n    }\n\n    return (sand[y][x] - '0' <= cnt);\n}\n\nint main()\n{\n    int h, w;\n\n    scanf(\"%d %d\", &h, &w);\n    for (int i = 0; i < h; i++) scanf(\"%s\", sand[i]);\n\n    queue<P> que;\n    int cnt = 0;\n    queue<P> change;\n    memcpy(tmp, sand, 1024 * 1024);\n    for (int i = 0; i < h; i++){\n        for (int j = 0; j < w; j++){\n            if (sand[i][j] != '.' && check(i, j)){\n                tmp[i][j] = '.';\n                que.push(P(i, j));\n                change.push(P(i, j));\n            }\n        }\n    }\n    while (!change.empty()){\n        P p = change.front();\n        sand[p.first][p.second] = tmp[p.first][p.second];\n        change.pop();\n    }\n\n    for (int size = que.size(); size; size = que.size()){\n        cnt++;\n        for (int i = 0; i < size; i++, que.pop()){\n            P p = que.front();\n            int y = p.first, x = p.second;\n\n            for (int j = 0; j < 3; j++){\n                for (int k = 0; k < 3; k++){\n                    if (j == 1 && k == 1) continue;\n                    int ty = y + dxy[j], tx = x + dxy[k];\n\n                    if (sand[ty][tx] != '.' && check(ty, tx)){\n                        tmp[ty][tx] = '.';\n                        que.push(P(ty, tx));\n                        change.push(P(ty, tx));\n                    }\n                }\n            }\n        }\n\n        while (!change.empty()){\n            P p = change.front();\n            sand[p.first][p.second] = tmp[p.first][p.second];\n            change.pop();\n        }\n    }\n\n    printf(\"%d\\n\", cnt);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\nusing namespace std;\ntypedef long long int LL;\ntypedef pair<int, int> PII;\ntypedef vector<PII> VP;\ntypedef VP::iterator VPI;\ntypedef string::iterator STI;\nconst int INF = (int)2e9;\n\nint h, w;\nint field[1010][1010];\nint broken[1010][1010];\nint ans = 0;\nint dx[] = {-1, -1, -1, 0, 1, 1, 1, 0};\nint dy[] = {-1, 0, 1, 1, 1, 0, -1, -1};\nqueue<PII> sr;\nint main()\n{\n  cin >> h >> w;\n  for(int i = 0; i < h; i++)\n    for(int j = 0; j < w; j++){\n      char in;\n      cin >> in;\n      if(in == '.')\n\tfield[i][j] = 0;\n      else{\n\tfield[i][j] = in - '0';\n\tbroken[i][j] = INF;\n      }\n    }\n\n  for(int i = 1; i < h - 1; i++)\n    for(int j = 1; j < w - 1; j++){\n      if(!(broken[i][j] <= 1)){\n\tint many = 0;\n\tfor(int k = 0; k < 8; k++)\n\t  if(broken[i + dx[k]][j + dy[k]] < 1)\n\t    many++;\n\tif(many >= field[i][j]){\n\t  sr.push(MP(i, j));\n\t  broken[i][j] = 1;\n\t}\n      }\n    }\n  \n  while(!sr.empty()){\n    ans++;\n    \n    int sz = sr.size();\n    for(int i = 0; i < sz; i++){\n      PII now = sr.front();\n      sr.pop();\n      \n      for(int j = 0; j < 8; j++){\n\tPII next = MP(now.first + dx[j], now.second + dy[j]);\n\t\n\tif(!(broken[next.first][next.second] <= ans + 1)){\n\t  int many = 0;\n\t  for(int k = 0; k < 8; k++)\n\t    if(broken[next.first + dx[k]][next.second + dy[k]] < ans + 1)\n\t      many++;\n\t  \n\t  if(many >= field[next.first][next.second]){\n\t    sr.push(MP(next.first, next.second));\n\t    broken[next.first][next.second] = ans + 1;\n\t  }\n\t}\n      }\n      \n    }\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\nusing namespace std;\n\nint dl[3]={-1,0,1};\n\nint main(){\n\tint h,w;\n\tcin>>h>>w;\n\tchar dt[h][w];\n\tbool alt[h][w];\n\trep(i,h)rep(j,w)cin>>dt[i][j];\n\tlong long cnt=0;\n\tbool check=true;\n\twhile(check){\n\t\tcheck=false;\n\t\trep(i,h){\n\t\t\trep(j,w){\n\t\t\t\talt[i][j]=false;\n\t\t\t\tif(dt[i][j]!='.'){\n\t\t\t\t\tint hoge=0;\n\t\t\t\t\trep(k,3){\n\t\t\t\t\t\trep(l,3){\n\t\t\t\t\t\t\tif(dt[i+dl[k]][j+dl[l]]=='.')hoge++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(hoge>=(int)(dt[i][j]-'0')){\n\t\t\t\t\t\talt[i][j]=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i,h){\n\t\t\trep(j,w){\n\t\t\t\tif(alt[i][j]){\n\t\t\t\t\tcheck=true;\n\t\t\t\t\tdt[i][j]='.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(check)cnt++;\n\t}\n\tcout<<cnt<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\ntypedef pair<int,int> pa;\ntypedef pair<int,pa> pp;\n\nint ary[1010][1010];\nint dy[8]={0,1,1,1,0,-1,-1,-1},dx[8]={1,1,0,-1,-1,-1,0,1};\nint H,W;\n\nint main(){\n\tcin>>H>>W;\n\tchar ch;\n\tint in=0,ou=1;\n\tqueue<pp> que;\n\tqueue<pa> quf;\n\tfor(int i=1;i<=H;i++){\n\t\tfor(int j=1;j<=W;j++){\n\t\t\tcin>>ch;\n\t\t\tif(ch=='.') ary[i][j]=0;\n\t\t\telse ary[i][j]=ch-'0';\n\t\t\tque.push(pp(0,pa(i,j)));\n\t\t}\n\t}\n\t\n\tint tmx,tmy,now=0,cnt=0,res=0;\n\twhile(!que.empty()){\n\t\ttmx=que.front().second.first;\n\t\ttmy=que.front().second.second;\n\t\tif(now!=que.front().first){\n\t\t\tnow=que.front().first;\n\t\t\twhile(!quf.empty()){\n\t\t\t\tary[quf.front().first][quf.front().second]=0;\n\t\t\t\tquf.pop();\n\t\t\t}\n\t\t\tres++;\n\t\t}\n\t\tque.pop();\n\t\tif(ary[tmx][tmy]==0) continue;\n\t\tcnt=0;\n\t\tfor(int i=0;i<8;i++){\n\t\t\tif(ary[tmx+dx[i]][tmy+dy[i]]==0){\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tif(ary[tmx][tmy]<=cnt){\n\t\t\tquf.push(pa(tmx,tmy));\n\t\t\tfor(int i=0;i<8;i++){\n\t\t\t\tque.push(pp(now+1,pa(tmx+dx[i],tmy+dy[i])));\n\t\t\t}\n\t\t}\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstring>\nusing namespace std;\n\n#define MAX 1001\n\nint main(){\n\tstring S;\n\tint n,m,t,sum,a;\n\tsum=0;\n\tshort x[MAX][MAX];\n\tshort z[MAX][MAX];\n\tshort v[MAX][MAX];\n\tmemset(x,0,sizeof(x));\n\tmemset(z,0,sizeof(z));\n\tchar T[10]={'.','1','2','3','4','5','6','7','8','9'};\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>S;\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tfor(int k=0;k<10;k++){\n\t\t\t\tif(S[j-1]==T[k]){\n\t\t\t\t\tx[i][j]=k;\n\t\t\t\t\tif(k==0){\n\t\t\t\t\t\tfor(int l=-1;l<=1;l++){\n\t\t\t\t\t\t\tfor(int o=-1;o<=1;o++){\n\t\t\t\t\t\t\t\tz[i+l][j+o] += 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\twhile(true){\n\t\tt=0;\n\t\tsum++;\n\t\tfor(int i=2;i<n;i++){\n\t\t\tfor(int j=2;j<m;j++){\n\t\t\t\tif(x[i][j]>=1 && z[i][j]>=x[i][j]){\n\t\t\t\t\ta=0;\n\t\t\t\t\tv[i][j] += 1;\n\t\t\t\t\tt++;\n\t\t\t\t\tfor(int l=-1;l<=1;l++){\n\t\t\t\t\t\tfor(int o=-1;o<=1;o++){\n\t\t\t\t\t\t\tv[i+l][j+o]+= 10;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(t==0){\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i=2;i<n;i++){\n\t\t\tfor(int j=2;j<m;j++){\n\t\t\t\tif(v[i][j]%10>=1){\n\t\t\t\t\tx[i][j]=0;\n\t\t\t\t}\n\t\t\t\tz[i][j] += v[i][j]/10;\n\t\t\t\tv[i][j]=0;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<sum-1<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <cstring>\n#include <vector>\n#define INV -10\n\nusing namespace std;\n\nint h,w;\nchar bch[1003][1003];\n\nint wav (int i, int j)\n{\n    int c=0;\n    if (bch[i-1][j-1]=='.') c++;\n    if (bch[i-1][j]=='.') c++;\n    if (bch[i-1][j+1]=='.') c++;\n    if (bch[i][j-1]=='.') c++;\n    if (bch[i][j+1]=='.') c++;\n    if (bch[i+1][j-1]=='.') c++;\n    if (bch[i+1][j]=='.') c++;\n    if (bch[i+1][j+1]=='.') c++;\n    return c;\n}\n\nint bfs ()\n{\n    int ans=0, cas[1003][1003];\n    bool done[1003][1003];\n    vector<pair<int, int>> que, vec;\n    memset(cas, -10, sizeof(cas));\n    for (int i=1; i<h-1; i++)\n    {\n        for (int j=1; j<w-1; j++)\n        {\n            if (bch[i][j]!='.')\n            {\n                cas[i][j]=(bch[i][j]-'0')-wav(i, j);\n                if (cas[i][j]<=0) que.push_back({i, j});\n            }\n        }\n    }\n    while (1)\n    {\n        if (que.empty())\n        {\n            ans++;\n            for (auto u : vec)\n            {\n                int i=u.first, j=u.second;\n                cas[i][j]=INV;\n            }\n            memset(done, false, sizeof(done));\n            for (auto u : vec)\n            {\n                int i=u.first, j=u.second;\n                if (cas[i-1][j-1]!=INV && !done[i-1][j-1]) { cas[i-1][j-1]--; if (cas[i-1][j-1]==0) { done[i-1][j-1]=true; que.push_back({i-1, j-1}); } }\n                if (cas[i-1][j]!=INV && !done[i-1][j]) { cas[i-1][j]--; if (cas[i-1][j]==0) { done[i-1][j]=true; que.push_back({i-1, j}); } }\n                if (cas[i-1][j+1]!=INV && !done[i-1][j+1]) { cas[i-1][j+1]--; if (cas[i-1][j+1]==0) { done[i-1][j+1]=true; que.push_back({i-1, j+1}); } }\n                if (cas[i][j-1]!=INV && !done[i][j-1]) { cas[i][j-1]--; if (cas[i][j-1]==0) { done[i][j-1]=true; que.push_back({i, j-1}); } }\n                if (cas[i][j+1]!=INV && !done[i][j+1]) { cas[i][j+1]--; if (cas[i][j+1]==0) {done[i][j+1]=true; que.push_back({i, j+1}); } }\n                if (cas[i+1][j-1]!=INV && !done[i+1][j-1]) { cas[i+1][j-1]--; if (cas[i+1][j-1]==0) { done[i+1][j-1]=true; que.push_back({i+1, j-1}); } }\n                if (cas[i+1][j]!=INV && !done[i+1][j]) { cas[i+1][j]--; if (cas[i+1][j]==0) { done[i+1][j]=true; que.push_back({i+1, j}); } }\n                if (cas[i+1][j+1]!=INV && !done[i+1][j+1]) { cas[i+1][j+1]--; if (cas[i+1][j+1]==0) { done[i+1][j+1]=true; que.push_back({i+1, j+1}); } }\n\n            }\n            vec.clear();\n        }\n        if (que.empty()) break;\n        vec.swap(que);\n    }\n    return ans;\n}\n\nint main()\n{\n    cin>>h>>w;\n    for (int i=0; i<h; i++) for (int j=0; j<w; j++) cin>>bch[i][j];\n    cout<<bfs()<<'\\n';\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<cctype>\n#include<cmath>\n#include<string>\n#include<set>\n#include<map>\n#include<queue>\n#include<vector>\nusing namespace std;\n\nint main() {\n\tint H, W;\n\tcin >> H >> W;\n\n\tchar c;\n\tstatic int a[1001][1001];\n\tfor (int i = 1; i <= H; i++)\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tcin >> c;\n\t\t\ta[i][j] = isdigit(c) ? (int)c-(int)'0' : 0;\n\t\t}\n\n\tint cnt = 0;\n\tstatic int temp[1001][1001] = { 0 };\n\tbool f;\n\tdo {\n\t\tf = false;\n\n\t\tfor (int i = 1; i <= H; i++)\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\tif (a[i][j] == 0) continue;\n\t\t\t\tint sarachi = 0;\n\t\t\t\tsarachi += (a[i - 1][j - 1] == 0) ? 1 : 0;\n\t\t\t\tsarachi += (a[i - 1][j] == 0) ? 1 : 0;\n\t\t\t\tsarachi += (a[i - 1][j + 1] == 0) ? 1 : 0;\n\t\t\t\tsarachi += (a[i][j - 1] == 0) ? 1 : 0;\n\t\t\t\tsarachi += (a[i][j + 1] == 0) ? 1 : 0;\n\t\t\t\tsarachi += (a[i + 1][j - 1] == 0) ? 1 : 0;\n\t\t\t\tsarachi += (a[i + 1][j] == 0) ? 1 : 0;\n\t\t\t\tsarachi += (a[i + 1][j + 1] == 0) ? 1 : 0;\n\t\t\t\t//cout << sarachi <<\" \"<< a[i][j] << endl;\n\t\t\t\tif (sarachi >= a[i][j]) {\n\t\t\t\t\ttemp[i][j] = -1;\n\t\t\t\t\tf = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\tfor (int i = 1; i <= H; i++)\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\ta[i][j] = temp[i][j] == -1 ? 0 : a[i][j];\n\t\t\t}\n\n\t\tcnt += f ? 1 : 0;\n\n\t} while (f);\n\n\tcout << cnt << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dx[] = {-1, -1, -1, 0, 1, 1, 1, 0};\nconst int dy[] = {-1, 0, 1, 1, 1, 0, -1, -1};\nconst int INF = 1 << 28;\n\nint h, w;\nint grid[1000][1000];\nint br[1000][1000];\n\nbool check(int x, int y, int t)\n{\n\tint cnt = 0;\n\tfor (int dir = 0; dir < 8; dir++){\n\t\tint nx = x + dx[dir];\n\t\tint ny = y + dy[dir];\n\t\tif (br[nx][ny] <= t) cnt++;\n\t}\n\treturn cnt >= grid[x][y];\n}\n\nint main()\n{\n\tcin >> h >> w;\n\tfor (int i = 0; i < h; i++){\n\t\tfor (int j = 0; j < w; j++){\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tif (c != '.'){\n\t\t\t\tgrid[i][j] = c - '0';\n\t\t\t\tbr[i][j] = INF;\n\t\t\t}\n\t\t}\n\t}\n\t\n\ttypedef tuple<int, int, int> Tp;\n\tqueue<Tp> q;\n\t\n\tfor (int i = 0; i < h; i++){\n\t\tfor (int j = 0; j < w; j++){\n\t\t\tif (br[i][j] < INF) continue;\n\t\t\tif (check(i, j, 0)){\n\t\t\t\tbr[i][j] = 1;\n\t\t\t\tq.push(Tp(i, j, 1));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint res = 0;\n\twhile (q.size()){\n\t\tint x, y, t;\n\t\ttie(x, y, t) = q.front(); q.pop();\n\t\tfor (int dir = 0; dir < 8; dir++){\n\t\t\tint nx = x + dx[dir];\n\t\t\tint ny = y + dy[dir];\n\t\t\tif (br[nx][ny] < INF) continue;\n\t\t\tif (check(nx, ny, t)){\n\t\t\t\tbr[nx][ny] = t + 1;\n\t\t\t\tq.push(Tp(nx, ny, t + 1));\n\t\t\t}\n\t\t}\n\t\tres = t;\n\t}\n\t\n\tcout << res << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n\n#include<iostream>\nusing namespace std;\n\nint f[1000][1000];\nint m[1000][1000];\nint count(int h,int w){\n\tint a[9]={0,1,1,0,-1,-1,1,-1,0},sum=0;\n\tfor(int i =0;i<8;i++){\n\t\tif(f[h+a[i]][w+a[i+1]]==-1)sum++;\n\t}\n\treturn sum;\n}\nvoid change(int h,int w){\n\tint a[9]={0,1,1,0,-1,-1,1,-1,0};\n\tfor(int i =0;i<8;i++){\n\t\tm[h+a[i]][w+a[i+1]]++;\n\t}\n}\n\nint main(){\n\tint h,w;\n\tcin>>h>>w;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tchar t;\n\t\t\tcin>>t;\n\t\t\tif(t=='.')f[i][j]=-1;\n\t\t\telse f[i][j]=t-'0';\n\t\t}\n\t}\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tm[i][j]=count(i,j);\n\t\t}\n\t}\n\tint c=0;\n\twhile(1){\n\t\tbool end=true;\n\t\tfor(int i=1;i<h-1;i++){\n\t\t\tfor(int j=1;j<w-1;j++){\n\t\t\t\tif(f[i][j]!=-1&&f[i][j]<=m[i][j]){\n\t\t\t\t\tf[i][j]=-10;\n\t\t\t\t\tend=false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<h-1;i++){\n\t\t\tfor(int j=1;j<w-1;j++){\n\t\t\t\tif(f[i][j]==-10){\n\t\t\t\t\tf[i][j]=-1;\n\t\t\t\t\tchange(i,j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(end)break;\n\t\tc++;\n\t}\n\tcout<<c<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nchar c[1001][1001];\nint K[1001][1001];\nint main(){\n  int w,h;\n  cin>>h>>w;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      cin>>c[i][j];\n      K[i][j]=0;\n    }\n  }\n  int dx[8]={-1,-1,-1,0,0,1,1,1};\n  int dy[8]={-1,0,1,-1,1,-1,0,1};\n  bool b=0;\n  queue<P> que[2];\n  queue<P> que2;\n   \n  for(int i=1;i<h-1;i++){\n    for(int j=1;j<w-1;j++){\n      for(int k=0;k<8;k++){\n    int y=i+dy[k];\n    int x=j+dx[k];\n    if(c[y][x]=='.'){\n      K[i][j]++;\n    }\n      }\n      if(c[i][j]!='.' && K[i][j]>=c[i][j]-'0'){\n    que[b].push(P(i,j));\n    que2.push(P(i,j));\n    //c[i][j]='.';\n      }\n    }\n  }\n \n  int ans=0;\n  while(!que[b].empty()){\n    while(!que[b].empty()){\n      while(!que2.empty()){\n    P p=que2.front();\n    que2.pop();\n    c[p.first][p.second]='.';\n      }\n      //cout<<\"ok\"<<endl;\n      P p=que[b].front();\n      int i=p.first;\n      int j=p.second;\n      que[b].pop();\n      c[i][j]='.';\n      for(int k=0;k<8;k++){\n    int y=i+dy[k];\n    int x=j+dx[k];\n    K[y][x]++;\n    if(c[y][x]!='.' && K[y][x]>=c[y][x]-'0'){\n      que[!b].push(P(y,x));\n      que2.push(P(y,x));\n    }\n      }\n    }\n    ans++;\n    b=!b;\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint a;\nint b;\nchar are[1001][1001];\nint kore[1001][1001];\nint sore[1001][1001];\nint ushi = 0;\nint uma;\n\nint main(){\n\tcin >> a >> b;\n\tfor (int i = 0; i < a; i++){\n\t\tfor (int j = 0; j < b; j++){\n\t\t\tcin >> are[i][j];\n\t\t\tif (are[i][j] != '.'){\n\t\t\t\tkore[i - 1][j - 1]++;\n\t\t\t\tkore[i][j - 1]++;\n\t\t\t\tkore[i + 1][j - 1]++;\n\t\t\t\tkore[i - 1][j]++;\n\t\t\t\tkore[i + 1][j]++;\n\t\t\t\tkore[i - 1][j + 1]++;\n\t\t\t\tkore[i][j + 1]++;\n\t\t\t\tkore[i + 1][j + 1]++;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < a; i++){\n\t\tfor (int j = 0; j < b; j++){\n\t\t\tsore[i][j] = kore[i][j];\n\t\t}\n\t}\n\twhile (true){\n\t\tuma = 0;\n\t\tfor (int i = 0; i < a; i++){\n\t\t\tfor (int j = 0; j < b; j++){\n\t\t\t\tif (are[i][j] != '.'){\n\t\t\t\t\tif (9 - sore[i][j] > are[i][j] - 48){\n\t\t\t\t\t\tare[i][j] = '.';\n\t\t\t\t\t\tkore[i - 1][j - 1]--;\n\t\t\t\t\t\tkore[i][j - 1]--;\n\t\t\t\t\t\tkore[i + 1][j - 1]--;\n\t\t\t\t\t\tkore[i - 1][j]--;\n\t\t\t\t\t\tkore[i + 1][j]--;\n\t\t\t\t\t\tkore[i - 1][j + 1]--;\n\t\t\t\t\t\tkore[i][j + 1]--;\n\t\t\t\t\t\tkore[i + 1][j + 1]--;\n\t\t\t\t\t\tuma = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (uma == 1){\n\t\t\tushi++;\n\t\t}\n\t\tif (uma == 0){\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < a; i++){\n\t\t\tfor (int j = 0; j < b; j++){\n\t\t\t\tsore[i][j] = kore[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tcout << ushi << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n\n    int w,h;\n\n    cin >> w >> h;\n\n    int table[w][h],copy[w][h];\n\n    char c;\n\n    for(int i=0;i<w;i++){\n      for(int j=0;j<h;j++){\n        cin >> c;\n        if(c=='.'){\n          table[i][j] = -1;\n        }\n        else{\n          stringstream ss;\n          ss << c;\n          ss >> table[i][j];\n        }\n      }\n    }\n\n    bool flag = true;\n\n    int ans = -1;\n\n    while(flag){\n      ans++;\n      flag = false;\n      for(int i=0;i<w;i++){\n        for(int j=0;j<h;j++){\n\n          if(table[i][j]!=-1 && i != 0 && i != w-1 && j != 0 && j!= h-1){\n\n            int count = 0;\n            if(table[i+1][j] == -1) count++;\n            if(table[i+1][j-1] == -1) count++;\n            if(table[i+1][j+1] == -1) count++;\n            if(table[i][j-1] == -1) count++;\n            if(table[i][j+1] == -1) count++;\n            if(table[i-1][j] == -1) count++;\n            if(table[i-1][j+1] == -1) count++;\n            if(table[i-1][j-1] == -1) count++;\n\n            if(count >= table[i][j]){\n              flag = true;\n              copy[i][j] = -1;\n            }\n            else{\n              copy[i][j] = table[i][j];\n            }\n\n          }\n          else{\n            copy[i][j] = -1;\n          }\n        }\n      }\n\n      for(int i=0;i<w;i++){\n        for(int j=0;j<h;j++){\n          table[i][j] = copy[i][j];\n        }\n      }\n\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\n\nint main() {\n\tint H, W;\n\tchar S[100][100];\n\tint i, j, ii, jj;\n\tint ans = 0, cou = 0, cou2 = 0;\n\tint s[100][100] = { -1 }, ss[100][100]={ -1 };\n\tint x[] = { 0,0,1,1,1,-1,-1,-1 };\n\tint y[] = { 1,-1,0,1,-1,0,1,-1 };\n\tscanf(\"%d %d\", &H, &W);\n\t//for (int i = 0; i < 8; i++) {\n\t\t//printf(\"%d%d\", x[i], y[i]);\n\t//}\n\tfor (i = 1; i <= H; i++) {\n\t\tfor (j = 1; j <= W; j++) {\n\t\t\tscanf(\" %c\", &S[i][j]);\n\t\t\tif (S[i][j] == '.') {\n\t\t\t\ts[i][j] = 0;\n\t\t\t\tss[i][j] = 10;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ts[i][j] = S[i][j] - 48;\n\t\t\t\tss[i][j] = 10;\n\t\t\t}\n\t\t}\n\t}\n\t//////////////\n\t//for (i = 1; i <= H; i++) {\n\t\t//for (j = 1; j <= W; j++) {\n\t\t\t//printf(\"%d\", ss[i][j]);\n\t\t//}\n\t\t//printf(\"\\n\");\n\t//}\n\t////////\n\twhile (1) {\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\tif (s[i][j] == 0) {\n\t\t\t\t\tfor (int k = 0; k < 8; k++) {\n\t\t\t\t\t\tii= i+x[k];\n\t\t\t\t\t\tjj = j+y[k];\n\t\t\t\t\t\tif (s[ii][jj] != 0) {\n\t\t\t\t\t\t\tif (s[ii - 1][jj - 1] == 0) {\n\t\t\t\t\t\t\t\tcou++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (s[ii- 1][jj] == 0) {\n\t\t\t\t\t\t\t\tcou++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (s[ii - 1][jj + 1] == 0) {\n\t\t\t\t\t\t\t\tcou++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (s[ii][jj - 1] == 0) {\n\t\t\t\t\t\t\t\tcou++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (s[ii][jj + 1] == 0) {\n\t\t\t\t\t\t\t\tcou++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (s[ii + 1][jj - 1] == 0) {\n\t\t\t\t\t\t\t\tcou++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (s[ii + 1][jj] == 0) {\n\t\t\t\t\t\t\t\tcou++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (s[ii + 1][jj + 1] == 0) {\n\t\t\t\t\t\t\t\tcou++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (cou >= s[ii][jj] && s[ii][jj]>=0) {\n\t\t\t\t\t\t\t\tss[ii][jj] = 0;\n\t\t\t\t\t\t\t\tcou2++;\n\t\t\t\t\t\t\t\t//printf(\"%d %d\\n\", ii, jj);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcou = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//printf(\"%d\\n\", cou2);\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\tif (ss[i][j] == 0) {\n\t\t\t\t\ts[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (cou2 == 0) break;\n\t\tcou2 = 0;\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t//\tprintf(\"%d\", s[i][j]);\n\t\t\t}\n\t\t\t//printf(\"\\n\");\n\t\t}\n\t    //printf(\"\\n\");\n\t\tans++;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <stdio.h>\n#include <stdlib.h>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <math.h>\n#include <utility>\n#include <set>\n#include <map>\n#define INF 1000000000\n#define rep(i,n) for(int i =0;i<n;i++)\nusing namespace std;\ntypedef long long int ll;\n\n\nint main(){\n    int h,w;\n    cin >>h >> w;\n    vector<int> area(h*w);\n    vector<int> ch(h*w,0);\n    queue<pair<int,int> > lis;\n    rep(i, h){\n        rep(j, w){\n            char hoge;\n            cin >> hoge;\n            if (hoge == '.') {\n                area[i*w+j]=-1;\n                for (int k=-1; k<2; k++) {\n                    for (int l=-1; l<2; l++) {\n                        if(k==0 and l==0) continue;\n                        if (i+k>0 and i+k<h-1 and j+l>0 and j+l<w-1) {\n                            ch[(i+k)*w+j+l]++;\n                        }\n                    }\n                }\n            }else{\n                area[i*w+j]=(int)hoge-(int)'0';\n            }\n        }\n    }\n    rep(i, h){\n        rep(j, w){\n            if (area[i*w+j]!=-1 and ch[i*w+j]>=area[i*w+j]) {\n                lis.push({i,j});\n            }\n        }\n    }\n    int ans = 0;\n    int flag = 1;\n    while (flag > 0) {\n        vector<int> oldc = ch;\n        int si = lis.size();\n        flag = 0;\n        rep(p, si){\n            if (ans==0) ans = 1;\n            int i = lis.front().first;\n            int j = lis.front().second;\n            lis.pop();\n            area[i*w+j]=-1;\n            for (int k=-1; k<2; k++) {\n                for (int l=-1; l<2; l++) {\n                    if(k==0 and l==0) continue;\n                    if (i+k>0 and i+k<h-1 and j+l>0 and j+l<w-1) {\n                        ch[(i+k)*w+j+l]++;\n                        if (area[(i+k)*w+j+l]!=-1 and ch[(i+k)*w+j+l]==area[(i+k)*w+j+l]) {\n                            lis.push({i+k,j+l});\n                            flag++;\n                        }\n                    }\n                }\n            }\n        }\n        if(flag > 0) ans++;\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <queue>\n#define ll long long\n#define INF (1<<30)\nusing namespace std;\nint dx[8] = { 0, 0, 1, -1, 1, 1, -1, -1 };\nint dy[8] = { 1, -1, 0, 0, 1, -1, 1, -1 };\nstruct Castle {\n\tint h;\n\tint w;\n\tint times;\n};\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tll H, W; cin >> H >> W;\n\tvector<vector<char>> sand(H, vector<char>(W));\n\tvector<vector<int>> m(H, vector<int>(W, 0));\n\tqueue<Castle> q;\n\tfor (int i = 0; i < H;i++) for (int j = 0; j < W;j++) cin >> sand[i][j];\n\tfor (int i = 0; i < H;i++) {\n\t\tfor (int j = 0; j < W;j++) {\n\t\t\tif (sand[i][j] == '.') m[i][j] = INF;\n\t\t\telse {\n\t\t\t\tfor (int k = 0; k < 8;k++) {\n\t\t\t\t\tint vi = i + dx[k];\n\t\t\t\t\tint vj = j + dy[k];\n\t\t\t\t\tif (sand[vi][vj] == '.')m[i][j]++;\n\t\t\t\t}\n\t\t\t\tif (m[i][j] >= sand[i][j] - '0') {\n\t\t\t\t\tq.push({ i,j,1 });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ret = 0;\n\twhile (!q.empty()) {\n\t\tCastle cas = q.front(); q.pop();\n\t\tret = cas.times;\n\t\tfor (int k = 0; k < 8;k++) {\n\t\t\tint vi = cas.h + dx[k];\n\t\t\tint vj = cas.w + dy[k];\n\t\t\tif (m[vi][vj] >= sand[vi][vj] - '0')continue;\n\t\t\tm[vi][vj]++;\n\t\t\tif (m[vi][vj] >= sand[vi][vj] - '0') q.push({ vi,vj,ret + 1 });\n\t\t}\n\t}\n\tcout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <numeric>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n\nusing namespace std;\n\n#define rep(i,n) for(int i = 0; i<n ; i++)\n#define FOR(i,a,n) for(int i=a; i<n; i++)\n#define REPSTR(i,s) for(int i=0; (s)[i]; i++)\n#define REPITR(i,s) for(auto i=(s)begin(); i!=(s).end();i++)\n\n#define RANGE(a,i,b) ((a)<=(i)&&(i)<=(b))\n\n#define pb push_back\n#define mp make_pair\n\n#define ALL(a) (a).begin(), (a).end()\n\n#define EXIST(s,x) ((s).find(x)!=(s).end())\n\n#define SET(a,c) memset(a,c,sizeof(a))\n#define CLR(a) memset(a,0,sizeof(a))\n\n#define DEBUG(x) cerr<<#x<<\":\"<<x<<endl\n#define PRINTJOIN(x,n) rep(i,n){if(i)cout<<\" \";cout<<x[i];}cout<<endl \n\n#define INF 1001001001\n#define LLINF 1001001001001001001LL\n\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef stringstream SS;\n\n#define PQ priority_queue\n\n#define FST first\n#define SEC second\n\nint dx[8]={ 1, 1, 1, 0, 0,-1,-1,-1};\nint dy[8]={-1, 0, 1, 1,-1, 1, 0,-1};\n\n//------------------HEAD---------------------\n\nchar _field[1005][1005];\nint field[1005][1005];\n\nint h,w;\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin>>h>>w;\n    rep(x,h){\n        rep(y,w){\n            char t;\n            cin>>t;\n            _field[x][y]=t=='.'?0:t-'1'+1;\n        }\n    }\n    queue<PII> Q;\n    FOR(x,1,h-1){\n        FOR(y,1,w-1){\n            if(_field[x][y]==0){\n                field[x][y]=0;\n                continue;\n            }\n            int s=0;\n            rep(i,8){\n                if(_field[x+dx[i]][y+dy[i]]==0)s++;\n            }\n            field[x][y]=max(0,_field[x][y]-s);\n            if(_field[x][y]<=s)Q.push(mp(x,y));\n        }\n    }\n    if(Q.empty()){\n        cout<<0<<endl;\n        return 0;\n    }\n    int cnt=1;\n    Q.push(mp(-1,-1));\n    while(!Q.empty()){\n        PII p=Q.front();Q.pop();\n        int x=p.FST;int y=p.SEC;\n        if(p==mp(-1,-1)){\n            if(Q.empty())break;\n            else{\n                cnt++;\n                //cerr<<\"wave \"<<cnt<<endl;\n                Q.push(mp(-1,-1));\n            }\n            continue;\n        }\n        rep(i,8){\n            int nx=x+dx[i];\n            int ny=y+dy[i];\n            if(field[nx][ny]==0)continue;\n            field[nx][ny]--;\n            if(field[nx][ny]==0){\n                Q.push(mp(nx,ny));\n                //cerr<<\"(\"<<nx<<\",\"<<ny<<\") crashed\"<<endl;\n            }\n        }\n    }\n    cout<<cnt<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define ALL(a) (a).begin(),(a).end()\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ndouble EPS=1e-8;\nint INF = 2e9;\nchar fld[55][55];\nint cnt[55][55];\nbool used[55][55];\nint main(){\n\tint h,w,turn=0;\n\tcin>>h>>w;\n\tREP(i,h)REP(j,w)cin>>fld[j][i];\n\tmemset(used,false,sizeof(used));\n\tqueue<P> Q;\n\tREP(i,h)REP(j,w){\n\t\tif(fld[j][i]=='.')continue;\n\t\tfor(int x=-1;x<=1;x++)for(int y=-1;y<=1;y++)if(fld[j+x][i+y]=='.')cnt[j][i]++;\n\t\tif(cnt[j][i]>=(fld[j][i]-'0')){\n\t\t\tQ.push(P(j,i));\n\t\t\tused[j][i]=true;\n\t\t}\n\t}\n\tif(Q.size())turn++;\n\telse{\n\t\tcout<<0<<endl;\n\t\treturn 0;\n\t}\n\tbool update=true;\n\twhile(update){\n\t\tint ql=Q.size();\n\t\tREP(i,ql){\n\t\t\tP p=Q.front();Q.pop();\n\t\t\tfor(int x=-1;x<=1;x++){\n\t\t\t\tfor(int y=-1;y<=1;y++){\n\t\t\t\t\tif(fld[p.first+x][p.second+y]!='.'){\n\t\t\t\t\t\tcnt[p.first+x][p.second+y]++;\n\t\t\t\t\t\tif(cnt[p.first+x][p.second+y]>=(fld[p.first+x][p.second+y]-'0')&&!used[p.first+x][p.second+y]){\n\t\t\t\t\t\t\tQ.push(P(p.first+x,p.second+y));\n\t\t\t\t\t\t\tused[p.first+x][p.second+y]=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!Q.size()){\n\t\t\tcout<<turn<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tturn++;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\n#include<iostream>\n\n#include<algorithm>\n\n#include<queue>\n\n#define REP(i,n) for(int i=0;i<(n);i++)\n\n#define RREP(i,n) for(int i=(n)-1;i>=0;i++)\n\nusing namespace::std;\n\ntypedef pair<int,int> P;\n\ntypedef pair<P,int> PP;\n\nqueue <PP> q;//width,height,cost\n\n\n\n\n\nbool judge(int,int);\n\nvoid solve();\n\nvoid loop();\n\n\n\nint h,w,map[2000][2000]={0},memo[2000][2000]={0},ans=0;//\n\n\n\nint main(){\n\n\tchar c;\n\n\tcin>>h>>w;\n\n\tREP(j,h)REP(i,w){\n\n\t\tcin>>c;\n\n\t\tif(c=='.')map[i][j]=0;\n\n\t\telse map[i][j]=int(c)-48;\n\n\t}\n\n\tsolve();\n\n\tloop();\n\n\t\n\n//\tREP(j,h){REP(i,w){\n\n//\t\tprintf(\"%d\",map[i][j]);\n\n//\t}printf(\"\\n\");}\n\n\tcout<<ans<<endl;\n\n}\n\n\n\nbool judge(int i,int j){\n\n\tint v=0;\n//\tcout<<\"hoge\"<<i<<\":\"<<j<<endl;\n\n\tif(map[i][j]==0)return false;\n\n\tREP(a,3)REP(b,3)if(map[i+a-1][j+b-1]==0&&!(a==1&&b==1))v++;\n//\tcout<<v<<endl;\n\n\tif(map[i][j]>v)return false;\n\n\telse return true;\n\n}\n\n\n\n\n\nvoid solve(){\n\n\tREP(j,w)REP(i,h){\n\n\t\tif(judge(i,j)==true){\n\n\t\t\tq.push(PP(P(i,j),1));\nmemo[i][j]=1;\n\n\t\t}\n\n\t}\t\n\n}\n\n\n\nvoid loop(){\n\nwhile(q.size()){\n\n\tPP p = q.front();q.pop();\n\n\t\n\n\tint k=p.second,i=p.first.first,j=p.first.second;\n\tmemo[i][j]=0;\n\n\tcout<<q.size()<<\"[\"<<i<<\",\"<<j<<\"]cost:\"<<k<<endl;\n\tmap[i][j]=0;\n\n//\tif(judge(i,j)==true){\n\n\t\tREP(a,3)REP(b,3)if(memo[i+a-1][j+b-1]==0&&map[i+a-1][j+b-1]!=0&&judge(i+a-1,j+b-1)==true&&!(a==1&&b==1)){\n\n\t\t\tq.push(PP(P(i+a-1,j+b-1),(k+1)));\n\t\t\tmemo[i+a-1][j+b-1]=1;\n\n\t\t\tans=max(k+1,ans);\n\n//\t\t\tcout<<\"pushed!\"<<\"[\"<<i+a-1<<\",\"<<j+b-1<<\"]\"<<endl;\n//\t\t\tmap[i+a-1][j+b-1]=0;\n\n\t\t\t\n\n\t\t}\n\n//\t}\t\n\n//\tREP(j,h){REP(i,w){\n\n//\t\tprintf(\"%d\",map[i][j]);\n\n//\t}printf(\"\\n\");}\n\n\t\n\n}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dx[]={1,0,0,-1,1,-1,-1,1};\nconst int dy[]={0,1,-1,0,1,1,-1,-1};\nconst int INF = 1<<30;\nconst double EPS = 1e-8;\n#define PB push_back\n#define mk make_pair\n#define fr first\n#define sc second\n#define reps(i,j,k) for(int i = (j); i < (k); ++i)\n#define rep(i,j) reps(i,0,j)\n#define MOD 1000000007\n#define lengthof(x) (sizeof(x) / sizeof(*(x)))\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> Pii;\ntypedef pair<int,vi > P;\ntypedef unsigned long long ll;\nchar stage[1024][1024];\nclass data{\npublic:\n\tint y;\n\tint x;\n\tint cnt;\n\tdata(){}\n\tdata(int _y,int _x,int _cnt){\n\t\ty = _y;\n\t\tx = _x;\n\t\tcnt = _cnt;\n\t}\n};\nint memo[1024][1024];\nint main(){\n\tint H,W;\n\tcin >> H >> W;\n\tqueue < data > Q; \n\trep(i,H){\n\t\tcin >> stage[i];\n\t\trep(j,W){\n\t\t\tif(stage[i][j] == '.'){\n\t\t\t\tQ.push(data(i,j,0));\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\twhile(!Q.empty()){\n\t\tdata d = Q.front();Q.pop();\n\t\trep(i,8){\n\t\t\tint ny = d.y + dy[i];\n\t\t\tint nx = d.x + dx[i];\n\t\t\tif(ny < 0 || ny > H-1 || nx < 0 || nx > W-1)continue;\n\t\t\tmemo[ny][nx]++;\n\t\t\tif(memo[ny][nx]==stage[ny][nx]-'0'){\n\t\t\t\tQ.push(data(ny,nx,d.cnt+1));\n\t\t\t\tans = max(ans,d.cnt+1);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\nusing namespace std;\n\nint dl[3]={-1,0,1};\n\nint main(){\n\tint h,w;\n\tcin>>h>>w;\n\tchar dt[h][w];\n\tbool alt[h][w];\n\trep(i,h)rep(j,w)cin>>dt[i][j];\n\tint cnt=0;\n\tbool check=true;\n\twhile(check){\n\t\tcheck=false;\n\t\trep(i,h){\n\t\t\trep(j,w){\n\t\t\t\talt[i][j]=false;\n\t\t\t\tif(dt[i][j]!='.'){\n\t\t\t\t\tint hoge=0;\n\t\t\t\t\trep(k,3){\n\t\t\t\t\t\trep(l,3){\n\t\t\t\t\t\t\tif(dt[i+dl[k]][j+dl[l]]=='.')hoge++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(hoge>=(int)(dt[i][j]-'0')){\n\t\t\t\t\t\talt[i][j]=true;\n\t\t\t\t\t\tcheck=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i,h){\n\t\t\trep(j,w){\n\t\t\t\tif(alt[i][j])dt[i][j]='.';\n\t\t\t}\n\t\t}\n\t\tif(check)cnt++;\n\t}\n\tcout<<cnt<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mp make_pair\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;//cnt, coodinate\nstring grid[1001];\nint neiber[1001][1001],\n  dx[] = {0, 1, 1,  1,  0, -1, -1, -1},\n  dy[] = {1, 1, 0, -1, -1, -1,  0,  1};\nint w, h;\ninline bool renge(int x, int y){\n  return (0 <= x && x < w &&\n          0 <= y && y < h);\n}\nbool del(int x, int y){\n  int cnt = 0;\n  for (int i = 0; i < 8; i++) {\n    int nx = x + dx[i], ny = y + dy[i];\n    if(!renge(nx, ny))continue;\n    if(grid[ny][nx] == '.')cnt++;\n  }\n  char tmp = grid[y][x];\n  neiber[y][x] = cnt;\n  return cnt >= atoi(&tmp);\n}\n \nint main(int argc, char *argv[]){\n  queue<piii> que;\n  cin >> h >> w;\n  for (int i = 0; i < h; i++)\n    cin >> grid[i];\n\n  for (int i = 0; i < h; i++) {\n    for (int j = 0; j < w; j++) {\n      if(grid[i][j] != '.' && del(j, i))\n        que.push(mp(1, mp(j, i)));\n    }\n  }\n  \n  int ans = 0;\n  while(!que.empty()){\n    int cnt = que.front().first;\n    int x = que.front().second.first;\n    int y = que.front().second.second;\n    que.pop();\n    if(grid[y][x] == '.')continue;\n    grid[y][x] = '.';\n    ans = cnt;\n    for (int i = 0; i < 8; i++) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if(!renge(nx, ny))continue;\n      char tmp = grid[ny][nx];\n      neiber[ny][nx]++;\n      if(neiber[ny][nx] >= atoi(&tmp))\n        que.push(mp(cnt + 1, mp(nx, ny)));\n    }\n  }\n  std::cout << ans << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n\nusing namespace std;\n\nint h, w, map[1001][1001];\n\nstruct pos {\n\tint x, y;\n};\n\nstd::queue<pair<pos, int>> que;\n\nint check(int _X, int _Y) {\n\tint count = 0;\n\tfor (int i = -1;i <= 1;i++) {\n\t\tfor (int j = -1;j <= 1;j++) {\n\t\t\tif (map[_X + i][_Y + j] == -1)count++;\n\t\t}\n\t}\n\treturn count;\n}\n\nbool Cl(int _X, int _Y) { return check(_X, _Y) >= map[_X][_Y]; };\n\nvoid Break(int _x, int _y, int _wave) {\n\tpos p;\n\tp.x = _x, p.y = _y;\n\tque.push(make_pair(p, _wave));\n}\n\nint main() {\n\tcin >> h >> w;\n\tfor (int i = 1;i <= h;i++) {\n\t\tfor (int j = 1;j <= w;j++) {\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tif (c == '.')map[i][j] = -1;\n\t\t\telse map[i][j] = c - '0';\n\t\t}\n\t}\n\tfor (int i = 2;i <= h - 1;i++) {\n\t\tfor (int j = 2;j <= w - 1;j++) {\n\t\t\tif (Cl(i, j) && map[i][j] !=-1)map[i][j] = 0, Break(i, j, 1);\n\t\t\telse if(map[i][j]!=-1){\n\t\t\t\tmap[i][j] -= check(i, j);\n\t\t\t}\n\t\t}\n\t}\n\tint big = 0;\n\twhile (que.size()) {\n\t\tpair<pos, int> P = que.front();\n\t\tque.pop();\n\t\tpos po;\n\t\tpo = P.first;\n\t\tif (map[po.x][po.y] == -1)continue;\n\t\tbig = std::max(big, P.second);\n\t\tmap[po.x][po.y] = -1;\n\t\tfor (int i = -1;i <= 1;i++) {\n\t\t\tfor (int j = -1;j <= 1;j++) {\n\t\t\t\tpos tep;\n\t\t\t\ttep.x = po.x + i, tep.y = po.y + j;\n\t\t\t\tif (map[tep.x][tep.y] > 0)map[tep.x][tep.y]--;\n\t\t\t\tif (map[tep.x][tep.y] == 0)que.push(make_pair(tep, ++P.second));\n\t\t\t}\n\t\t}\n\t}\n\tcout << big << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <queue>\nusing namespace std;\ntypedef pair<int, int> P;\n \nint h, w, ans;\nint castle[1001][1001], times[1001][1001];\nint dx[] = {-1, 0, 1, -1, 1, -1, 0, 1}, dy[] = {-1, -1, -1, 0, 0, 1, 1, 1};\nchar beach[1001][1001];\n \nint main(){\n    scanf(\"%d%d\", &h, &w);\n    for(int i = 0; i < h; i++){\n        scanf(\"%s\", &beach[i]);\n    }\n \n    queue<P> Q;\n    for(int i = 0; i < h; i++){\n        for(int j = 0; j < w; j++){\n            if(beach[i][j] == '.'){\n                Q.push(P(i, j));\n            } else{\n                castle[i][j] = beach[i][j] - '0';\n            }\n        }\n    }\n \n    while(Q.size()){\n        P p = Q.front();\n        Q.pop();\n        ans = max(ans, times[p.first][p.second]);\n \n        for(int i = 0; i < 8; i++){\n            int y = p.first + dy[i], x = p.second + dx[i];\n            if(y < 0 || y >= h || x < 0 || x >= w){\n                continue;\n            }\n \n            castle[y][x]--;\n            if(castle[y][x] == 0){\n                Q.push(P(y, x));\n                times[y][x] = times[p.first][p.second] + 1;\n            }\n        }\n    }\n \n    printf(\"%d\\n\", ans);\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<queue>\n#define MP make_pair\nusing namespace std;\nlong long int sc[1001][1001],ssc[1001][1001];\nchar c[1001];\nint main()\n{\n\tint h, w, cnt = 0, ans = 0, n;\n\tint x, y;\n\tpair<int, int> p;\n\tqueue< pair<int, int> > que;\n\tqueue< pair<int, int> >que1;\n\tscanf(\"%d%d\", &h, &w);\n\tfor (int i = 0; i < h; i++)\n\t{\n\t\tscanf(\"%s\", c);\n\t\tfor (int j = 0; j < w; j++)\n\t\t{\n\n\t\t\tif (c[j] == '.')\n\t\t\t\tsc[i][j] = -1;\n\t\t\telse\n\t\t\t\tsc[i][j] = c[j] - 48;\n\t\t}\n\t}\n\tfor (int i = 1; i < h; i++)\n\t{\n\t\tfor (int j = 1; j < w; j++)\n\t\t{\n\t\t\tif (sc[i][j] != -1)\n\t\t\t{\n\t\t\t\tfor (int a = i - 1; a < i + 2; a++)\n\t\t\t\t{\n\t\t\t\t\tfor (int b = j - 1; b < j + 2; b++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (sc[a][b] == -1)ssc[i][j] ++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < h; i++)\n\t{\n\n\t\tfor (int j = 0; j < w; j++)\n\t\t{\n\t\t\tif (sc[i][j] != -1)\n\t\t\t{\n\t\t\t\tif (sc[i][j] <= ssc[i][j])\n\t\t\t\t\tque.push(MP(i, j));\n\t\t\t\telse if (sc[i][j] != 9)\n\t\t\t\t\tque1.push(MP(i, j));\n\t\t\t}\n\t\t}\n\t}\n\twhile (!que.empty())\n\t{\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tx = que.front().first;\n\t\t\ty = que.front().second;\n\t\t\tque.pop();\n\t\t\tfor (int a = -1; a < 2; a++)\n\t\t\t{\n\t\t\t\tssc[x - 1][y + a]++;\n\t\t\t\tssc[x + 1][y + a]++;\n\t\t\t}\n\t\t\tssc[x][y - 1]++;\n\t\t\tssc[x][y + 1]++;\n\t\t}\n\t\tn = que1.size();\n\t\tfor (int i=0;i<n;i++)\n\t\t{\n\t\t\tx = que1.front().first;\n\t\t\ty = que1.front().second;\n\t\t\tque1.pop();\n\t\t\tif (sc[x][y] <= ssc[x][y])\n\t\t\t\tque.push(MP(x, y));\n\t\t\telse if (sc[x][y] != 9)\n\t\t\t\tque1.push(MP(x, y));\n\t\t}\n\t\tans++;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<tuple>\nusing namespace std;\nint x[1005][1005], H, W; bool J[1005][1005];\nint solve(int r, int s) {\n\tif (r <= 0 || s <= 0 || r > H || s > W)return 0; int B = 0;\n\tfor (int i = -1; i <= 1; i++) { for (int j = -1; j <= 1; j++) { if (x[r + i][s + j] == 0)B++; } }\n\treturn B;\n}\nint main() {\n\tcin >> H >> W; queue<tuple<int, int, int>>Q;\n\tfor (int i = 1; i <= H; i++) { for (int j = 1; j <= W; j++) { char c; cin >> c; if (c == '.')x[i][j] = 0; else { x[i][j] = c - '0'; } } }\n\tvector<pair<int, int>>vec1;\n\tfor (int i = 1; i <= H; i++) {\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tif (solve(i, j) >= x[i][j] && x[i][j] != 0) { vec1.push_back(make_pair(i, j)); J[i][j] = true; Q.push(make_tuple(i, j, 1)); }\n\t\t}\n\t}\n\tif (vec1.size() == 0) { cout << \"0\" << endl; return 0; }int Life = 1;\n\tfor (int i = 0; i < vec1.size(); i++) { x[vec1[i].first][vec1[i].second] = 0; }vec1.clear();\n\twhile (!Q.empty()) {\n\t\tint a1 = get<0>(Q.front()), a2 = get<1>(Q.front()), a3 = get<2>(Q.front()); Q.pop();\n\t\tif (a3 != Life) {\n\t\t\tfor (int i = 0; i < vec1.size(); i++) { x[vec1[i].first][vec1[i].second] = 0; }\n\t\t\tvec1.clear(); Life++;\n\t\t}\n\t\tfor (int i = -1; i <= 1; i++) {\n\t\t\tfor (int j = -1; j <= 1; j++) {\n\t\t\t\tif (solve(a1 + i, a2 + j) >= x[a1 + i][a2 + j] && x[a1 + i][a2 + j] != 0 && J[a1 + i][a2 + j] == false) {\n\t\t\t\t\tvec1.push_back(make_pair(a1 + i, a2 + j)); J[a1 + i][a2 + j] = true;\n\t\t\t\t\tQ.push(make_tuple(a1 + i, a2 + j, a3 + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << Life << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\nint h,w;\nchar bch[1003][1003];\n\nint bfs ()\n{\n    int ans=0, cas[1003][1003],c;\n    vector<pair<int, int>> que, vec;\n    for (int i=1; i<h-1; i++)\n    {\n        for (int j=1; j<w-1; j++)\n        {\n            if (bch[i][j]!='.')\n            {\n                c=0;\n                if (bch[i-1][j-1]=='.') c++;\n                if (bch[i-1][j]=='.') c++;\n                if (bch[i-1][j+1]=='.') c++;\n                if (bch[i][j-1]=='.') c++;\n                if (bch[i][j+1]=='.') c++;\n                if (bch[i+1][j-1]=='.') c++;\n                if (bch[i+1][j]=='.') c++;\n                if (bch[i+1][j+1]=='.') c++;\n                cas[i][j]=cbch[i][j]-'0'-c;\n                if (cas[i][j]<=0) que.push_back({i, j});\n            }\n        }\n    }\n    while (1)\n    {\n        if (que.empty())\n        {\n            ans++;\n            for (auto u : vec)\n            {\n                int i=u.first, j=u.second;\n                if (bch[i-1][j-1]!='.') { cas[i-1][j-1]--; if (cas[i-1][j-1]==0) que.push_back({i-1, j-1}); }\n                if (bch[i-1][j]!='.') { cas[i-1][j]--; if (cas[i-1][j]==0) que.push_back({i-1, j}); }\n                if (bch[i-1][j+1]!='.') { cas[i-1][j+1]--; if (cas[i-1][j+1]==0) que.push_back({i-1, j+1}); }\n                if (bch[i][j-1]!='.') { cas[i][j-1]--; if (cas[i][j-1]==0) que.push_back({i, j-1}); }\n                if (bch[i][j+1]!='.') { cas[i][j+1]--; if (cas[i][j+1]==0) que.push_back({i, j+1}); }\n                if (bch[i+1][j-1]!='.') { cas[i+1][j-1]--; if (cas[i+1][j-1]==0) que.push_back({i+1, j-1}); }\n                if (bch[i+1][j]!='.') { cas[i+1][j]--; if (cas[i+1][j]==0) que.push_back({i+1, j}); }\n                if (bch[i+1][j+1]!='.') { cas[i+1][j+1]--; if (cas[i+1][j+1]==0) que.push_back({i+1, j+1}); }\n            }\n            vec.clear();\n        }\n        if (que.empty()) break;\n        vec.swap(que);\n    }\n    return ans;\n}\n\nint main()\n{\n    cin>>h>>w;\n    for (int i=0; i<h; i++) for (int j=0; j<w; j++) cin>>bch[i][j];\n    cout<<bfs()<<'\\n';\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\n\nint main() {\n\tint H, W;\n\tchar S[100][100];\n\tint i, j;\n\tint ans = 0, cou = 0, cou2 = 0;\n\tint s[100][100], ss[100][100];\n\tscanf(\"%d %d\", &H, &W);\n\tfor (i = 1; i <= H; i++) {\n\t\tfor (j = 1; j <= W; j++) {\n\t\t\tscanf(\" %c\", &S[i][j]);\n\t\t\tif (S[i][j] == '.') {\n\t\t\t\ts[i][j] = 0;\n\t\t\t\tss[i][j] = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ts[i][j] = S[i][j] - 48;\n\t\t\t\tss[i][j] = s[i][j];\n\t\t\t}\n\t\t}\n\t}\n\t//////////////\n\t//for (i = 1; i <= H; i++) {\n\t\t//for (j = 1; j <= W; j++) {\n\t\t\t//printf(\"%d\", s[i][j]);\n\t\t//}\n\t\t//printf(\"\\n\");\n\t//}\n\t////////\n\twhile (1) {\n\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\tif (s[i][j] != 0) {\n\t\t\t\t\tif (s[i - 1][j - 1] == 0) {\n\t\t\t\t\t\tcou++;\n\t\t\t\t\t}\n\t\t\t\t\tif (s[i - 1][j] == 0) {\n\t\t\t\t\t\tcou++;\n\t\t\t\t\t}\n\t\t\t\t\tif (s[i - 1][j + 1] == 0) {\n\t\t\t\t\t\tcou++;\n\t\t\t\t\t}\n\t\t\t\t\tif (s[i][j - 1] == 0) {\n\t\t\t\t\t\tcou++;\n\t\t\t\t\t}\n\t\t\t\t\tif (s[i][j + 1] == 0) {\n\t\t\t\t\t\tcou++;\n\t\t\t\t\t}\n\t\t\t\t\tif (s[i + 1][j - 1] == 0) {\n\t\t\t\t\t\tcou++;\n\t\t\t\t\t}\n\t\t\t\t\tif (s[i + 1][j] == 0) {\n\t\t\t\t\t\tcou++;\n\t\t\t\t\t}\n\t\t\t\t\tif (s[i + 1][j + 1] == 0) {\n\t\t\t\t\t\tcou++;\n\t\t\t\t\t}\n\t\t\t\t\tif (cou >= ss[i][j]) {\n\t\t\t\t\t\tss[i][j] = 0;\n\t\t\t\t\t\tcou2++;\n\t\t//\t\t\t\tprintf(\"%d %d\\n\", i, j);\n\t\t\t\t\t}\n\t\t\t\t\tcou = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//printf(\"%d\\n\", cou2);\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\ts[i][j] = ss[i][j];\n\t\t\t}\n\t\t}\n\t\tif (cou2 == 0) break;\n\t\tcou2 = 0;\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t//\tprintf(\"%d\", s[i][j]);\n\t\t\t}\n\t\t//\tprintf(\"\\n\");\n\t\t}\n\t\t//printf(\"\\n\");\n\t\tans++;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"queue\"\n#include \"utility\"\n#include \"math.h\"\n\nusing namespace std;\nint H, W;\nchar status[1002][1002];\nint field[1002][1002];\npair<int, int> dir[8] = {make_pair(0,1),make_pair(1,1),make_pair(1,0),make_pair(1,-1),make_pair(0,-1),make_pair(-1,-1),make_pair(-1,0),make_pair(-1,1)};\nqueue<pair<int,int> > Q;\nqueue<pair<int, int> >del;\nint ans = 0;\nint box = 0;\nint num = 0;\nint x, y;\n\nint main() {\n\tcin >> H >> W;\n\tfor (int i = 1; i <= H; i++) {\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tcin >> status[i][j];\n\t\t\tif (status[i][j] == '.') {\n\t\t\t\tfield[i][j] = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfield[i][j] = status[i][j] - '0';\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= H; i++) {\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tif (field[i][j] != 0) {\n\t\t\t\tbox = 0;\n\t\t\t\tfor (int k = 0; k < 8; k++) {\n\t\t\t\t\tif (field[i + dir[k].first][j + dir[k].second] == 0)box++;\n\t\t\t\t}\n\t\t\t\tif (box >= field[i][j]) {\n\t\t\t\t\tQ.push(make_pair(i, j));\n\t\t\t\t\tans = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdel = Q;\n\t\n\twhile (!del.empty()) {\n\t\ty = del.front().first;\n\t\tx = del.front().second;\n\t\tfield[y][x] = 0;\n\t\tdel.pop();\n\t}\n\twhile (1) {\n\t\tnum = Q.size();\n\t\t//cout << num <<\" \";\n\t\tfor (int i = 0; i < num; i++) {\n\t\t\ty = Q.front().first;\n\t\t\tx = Q.front().second;\n\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\tif (field[y + dir[j].first][x + dir[j].second] != 0&&y+dir[j].first>=1&&y+dir[j].first<=H&&x+dir[j].second>=1&&x+dir[j].second<=W) {\n\t\t\t\t\tbox = 0;\n\t\t\t\t\tfor (int k = 0; k < 8; k++) {\n\t\t\t\t\t\tif (field[y + dir[j].first + dir[k].first][x + dir[j].second + dir[k].second] == 0)box++;\n\t\t\t\t\t}\n\t\t\t\t\tif (box >= field[y + dir[j].first][x + dir[j].second]) {\n\t\t\t\t\t\tQ.push(make_pair(y + dir[j].first, x + dir[j].second));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t\t//cout << Q.size() << \"\\n\";\n\t\tif (Q.empty())break;\n\t\tdel = Q;\n\t\tans++;\n\t\t//cout << del.size() << \"\\n\";\n\t\twhile (!del.empty()) {\n\t\t\ty = del.front().first;\n\t\t\tx = del.front().second;\n\t\t\tfield[y][x] = 0;\n\t\t\tdel.pop();\n\t\t}\n\t\t\n\t}\n\tcout << ans << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n#define INF (1 << 29)\n\nconst int dx[8] = { -1, 0, 1, -1, 1, -1, 0, 1 };\nconst int dy[8] = { -1, -1, -1, 0, 0, 1, 1, 1 };\n\nint H, W;\n\nint main()\n{\n\tcin >> H >> W;\n\n\tvector<vector<char> > D(H, vector<char>(W));\n\tvector<vector<int> > dp(H, vector<int>(W, INF));\n\n\tfor (int i = 0; i < H; i++)\n\t{\n\t\tfor (int j = 0; j < W; j++)\n\t\t{\n\t\t\tcin >> D[i][j];\n\n\t\t\tif (D[i][j] == '.')\n\t\t\t{\n\t\t\t\tdp[i][j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tqueue<pair<int, int> > que;\n\tqueue<int> q2;\n\n\tfor (int i = 0; i < H; i++)\n\t{\n\t\tfor (int j = 0; j < W; j++)\n\t\t{\n\t\t\tif (dp[i][j] != 0)\n\t\t\t{\n\t\t\t\tint count = 0;\n\n\t\t\t\tfor (int dir = 0; dir < 8; dir++)\n\t\t\t\t{\n\t\t\t\t\tif (0 <= i + dy[dir] && i + dy[dir] < H && 0 <= j + dx[dir] && j + dx[dir] < W)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (dp[i + dy[dir]][j + dx[dir]] == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (count >= D[i][j] - 48)\n\t\t\t\t{\n\t\t\t\t\tpair<int, int> p1;\n\n\t\t\t\t\tp1.first = j;\n\t\t\t\t\tp1.second = i;\n\n\t\t\t\t\tque.push(p1);\n\t\t\t\t\tq2.push(1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\twhile (!que.empty())\n\t{\n\t\tpair<int, int> p1 = que.front(); que.pop();\n\n\t\tint dist = q2.front(); q2.pop();\n\n\t\tint x = p1.first;\n\t\tint y = p1.second;\n\t\tint count = 0;\n\n\t\tfor (int dir = 0; dir < 8; dir++)\n\t\t{\n\t\t\tif (0 <= y + dy[dir] && y + dy[dir] < H && 0 <= x + dx[dir] && x + dx[dir] < W)\n\t\t\t{\n\t\t\t\tif (dp[y + dy[dir]][x + dx[dir]] < dist)\n\t\t\t\t{\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (count >= D[y][x] - 48)\n\t\t{\n\t\t\tdp[y][x] = dist;\n\n\t\t\tpair<int, int> p2;\n\n\t\t\tfor (int dir = 0; dir < 8; dir++)\n\t\t\t{\n\t\t\t\tif (0 <= y + dy[dir] && y + dy[dir] < H && 0 <= x + dx[dir] && x + dx[dir] < W)\n\t\t\t\t{\n\t\t\t\t\tif (dp[y + dy[dir]][x + dx[dir]] == INF)\n\t\t\t\t\t{\n\t\t\t\t\t\tp2.first = x + dx[dir];\n\t\t\t\t\t\tp2.second = y + dy[dir];\n\n\t\t\t\t\t\tque.push(p2);\n\t\t\t\t\t\tq2.push(dist + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint Ans = 0;\n\n\tfor (int i = 0; i < H; i++)\n\t\tfor (int j = 0; j < W; j++)\n\t\t\tAns = max(Ans, dp[i][j]);\n\n\tcout << Ans << endl;\n\n\tgetchar();\n\tgetchar();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define x first\n#define y second\nusing namespace std;\ntypedef pair<int, int> PII;\ntypedef vector<PII> VP;\ntypedef VP::iterator VPI;\n\nint h, w, ans = 0, near[1000][1000];\nchar beach[1000][1000];\nVP broken1, broken2;\nVPI p;\nint dx[8] = {-1, -1, -1, 0, 0, 1, 1, 1};\nint dy[8] = {-1, 0, 1, -1, 1, -1, 0, 1};\n\nint main()\n{\n  cin >> h >> w;\n  for(int i = 0; i < h; i++){\n    for(int j = 0; j < w; j++) cin >> beach[i][j];\n  }\n\n  for(int i = 0; i < h; i++){\n    for(int j = 0; j < w; j++){\n      if(beach[i][j] == '.') near[i][j] = -1;\n      else{\n\tfor(int k = 0; k < 8; k++) if(beach[i + dx[k]][j + dy[k]] == '.') near[i][j]++;\n\tif(beach[i][j] - '0' <= near[i][j]){\n\t  broken2.push_back(make_pair(i, j));\n\t  near[i][j] = -1;\n\t}\n      }\n    }\n  }\n\n  while(!broken2.empty()){\n    ans++;\n    broken1 = broken2;\n    broken2.clear();\n    for(p = broken1.begin(); p != broken1.end(); p++){\n      for(int i = 0; i < 8; i++){\n\tPII next = make_pair(p->x + dx[i], p->y + dy[i]);\n\tif(near[next.x][next.y] != -1){\n\t  near[next.x][next.y]++;\n\t  if(beach[next.x][next.y] - '0' <= near[next.x][next.y]){\n\t    broken2.push_back(next);\n\t    near[next.x][next.y] = -1;\n\t  }\n\t}\n      }\n    }\n  }\n\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define rep(i,n) for(int i=0;i<n;++i)\n#define FOR(i,a,b) for(int i=a;i<=b;++i)\nusing namespace std;\nstatic const LL INF = 1LL<<61LL;\nstatic const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };\nstatic const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };\ntypedef pair<LL,LL> PLL;\n\nstring mp[1010];\nLL feld[1010][1010];\nLL h,w;\nLL ans;\n\nLL slove(int x,int y){\n    LL cnt=0;\n    rep(i,8){\n        if(mp[y+dy[i]][x+dx[i]]!='.')continue;\n        cnt++;\n    }\n    if(cnt>=mp[y][x]-'0')return 1;\n    else return 0;\n}\n\n\nint main(){\n   cin>>h>>w;\n   rep(y,h)cin>>mp[y];\n   while(1){\n       int cnt=0;\n       rep(y,h){\n           rep(x,w){\n               int k;\n               if(mp[y][x]=='.')continue;\n               if(k=slove(x,y))feld[y][x]=INF;\n               cnt+=k;\n           }\n       }\n       rep(y,h)rep(x,w){\n               if(feld[y][x]!=INF)continue;\n               mp[y][x]='.';\n        }\n       if(cnt)ans++;\n       else break;\n   }\n   cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <utility>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <set>\n\n#define INF_LL 9000000000000000000\n#define INF 2000000000\n\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int i = (a);i < (b);i++)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> PPII;\ntypedef pair<int, PPII> PPPII;\n\nclass Union_find{\nprivate:\n\tvector<int> par;\n\tvector<int> rank;\n\tint n;\n\npublic:\n\tUnion_find(int a){\n\t\tn = a;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tpar.push_back(i);\n\t\t\trank.push_back(0);\n\t\t}\n\t}\n\n\tint find(int x){\n\t\tif(par[x] == x){\n\t\t\treturn x;\n\t\t}else{\n\t\t\treturn par[x] = find(par[x]);\n\t\t}\n\t}\n\n\tvoid unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return;\n\n\t\tif(rank[x] < rank[y]){\n\t\t\tpar[x] = y;\n\t\t}else{\n\t\t\tpar[y] = x;\n\t\t\tif(rank[x] == rank[y]) rank[x]++;\n\t\t}\n\t}\n\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n};\n\nint dx[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nint dy[8] = {1, 0, -1, 1, -1, 1, 0, -1};\n\nint main(void){\n\tint H, W;\n\tstring f[2][1010];\n\tcin >> H >> W;\n\tqueue<PII> que[2];\n\tREP(i, H){\n\t\tcin >> f[0][i];\n\t\tREP(j, W){\n\t\t\tif(f[0][i][j] != '.')\n\t\t\t\tque[0].push(PII(i, j));\n\t\t}\n\t}\n\tint cnt = 0;\n\tll res = 0;\n\twhile(1){\n\t\tcnt = 0;\n\t\tset<PII> st;\n\t\tREP(i, 1010){\n\t\t\tf[(res+1)%2][i] = f[res%2][i];\n\t\t}\n\t\twhile(que[res%2].size()){\n\t\t\tPII p = que[res%2].front(); que[res%2].pop();\n\t\t\tint sarati = 0;\n\t\t\tREP(i, 8){\n\t\t\t\tif(f[res%2][p.first+dy[i]][p.second+dx[i]] == '.')\n\t\t\t\t\tsarati++;\n\t\t\t}\n\t\t\tif(f[res%2][p.first][p.second] != '.' && sarati >= f[res%2][p.first][p.second]-'0'){\n\t\t\t\tf[(res+1)%2][p.first][p.second] = '.';\n\t\t\t\tREP(i, 8){\n\t\t\t\t\tif(f[res%2][p.first+dy[i]][p.second+dx[i]] != '.')\n\t\t\t\t\t\tst.insert({p.first+dy[i], p.second+dx[i]});\n\t\t\t\t}\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tfor(auto x : st){\n\t\t\tque[(res+1)%2].push(x);\n\t\t}\n\t\tif(cnt == 0) break;\n\t\telse res++;\n\t}\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct vec2{\n  int x;\n  int y;\n  vec2(int x,int y){\n    this->x = x;\n    this->y = y;\n  }\n};\n\nshort s[1000][1000];\n\nint main(){\n\n    int w,h;\n\n    cin >> w >> h;\n\n    short table[w][h];\n\n    int dirx[8] = {-1,-1,-1,0,0,1,1,1},diry[8] = {-1,0,1,-1,1,-1,0,1};\n\n    char c;\n\n    for(int i=0;i<w;i++){\n      for(int j=0;j<h;j++){\n        cin >> c;\n        if(c=='.'){\n          table[i][j] = -1;\n        }\n        else{\n          stringstream ss;\n          ss << c;\n          ss >> table[i][j];\n        }\n      }\n    }\n\n    int ans = 0,com=-1,rep=-3;\n\n    queue<vec2> q1,q2;\n\n    for(int i=1;i<w-1;i++){\n      for(int j=1;j<h-1;j++){\n\n        int count = 0;\n        for(int k=0;k<8;k++){\n          int di = i + dirx[k],dj = j + diry[k];\n          if(table[di][dj] == -1){\n            count++;\n          }\n        }\n\n        s[i][j] = count;\n\n        if(table[i][j] > 0 && count >= table[i][j]){\n          vec2 tmpvec(i,j);\n          q1.push(tmpvec);\n          table[i][j] = com;\n        }\n\n\n      }\n    }\n\n    /*for(int i=0;i<w;i++){\n      for(int j=0;j<h;j++){\n        cout << s[i][j] << \" \";\n      }\n      cout << endl;\n    }*/\n\n  //  cout << endl;\n\n    /*for(int i=1;i<w-1;i++){\n      for(int j=1;j<h-1;j++){\n\n          int count = 0;\n          if(table[i+1][j] == com || table[i+1][j] == rep) count++;\n          if(table[i+1][j-1] == com || table[i+1][j-1] == rep) count++;\n          if(table[i+1][j+1] == com || table[i+1][j+1] == rep) count++;\n          if(table[i][j-1] == com) count++;\n          if(table[i][j+1] == com || table[i][j+1] == rep) count++;\n          if(table[i-1][j] == com) count++;\n          if(table[i-1][j+1] == com) count++;\n          if(table[i-1][j-1] == com) count++;\n\n          s[i][j] = count;\n\n      }\n    }*/\n\n    /*for(int i=1;i<w-1;i++){\n      for(int j=1;j<h-1;j++){\n\n        if(table[i][j] == rep){\n          table[i][j] = com;\n\n        }\n      }\n    }*/\n\n  /*  while(!q1.empty()){\n      cout << q1.front().x << \" \" << q1.front().y << endl;\n      q1.pop();\n    }\n    while(1){}*/\n\n  /*  for(int i=0;i<w;i++){\n      for(int j=0;j<h;j++){\n        cout << table[i][j] << \" \";\n      }\n      cout << endl;\n    }\n    cout << endl;*/\n\n    if(q1.empty()) ans = -1;\n\n    while(1){\n\n      if(q1.empty()){\n      /*  for(int i=0;i<w;i++){\n          for(int j=0;j<h;j++){\n            cout << table[i][j] << \" \";\n          }\n          cout << endl;\n        }\n        cout << endl;*/\n        ans++;\n        if(q2.empty()){\n          break;\n        }\n        else{\n          while(!q2.empty()){\n            //cout << ans << \" \" <<  q2.front().x << \" \" << q2.front().y << endl;\n            q1.push(q2.front());\n            q2.pop();\n          }\n\n          /*for(int i=1;i<w-1;i++){\n            for(int j=1;j<h-1;j++){\n              if(table[i][j] == rep){\n                table[i][j] = com;\n              }\n            }\n          }*/\n\n        }\n      }\n\n      vec2 tmpvec = q1.front();\n      q1.pop();\n      int i = tmpvec.x;\n      int j = tmpvec.y;\n\n      if(i != 0 && i != w-1 && j != 0 && j != h-1){\n\n        table[i][j] = com;\n        for(int k=0;k<8;k++){\n          int vi = i+dirx[k];\n          int vj = j+diry[k];\n          s[vi][vj]++;\n        //  cout << ans  << \" \" << vi << \" \" << vj << \" \" << table[vi][vj] << \" \" << s[vi][vj] << endl;\n          if(table[vi][vj] > 0 && s[vi][vj] == table[vi][vj]){\n            vec2 tmpvecs(vi,vj);\n            q2.push(tmpvecs);\n            //table[vi][vj] = com;\n          }\n\n/*\n          s[i+1][j]++;\n          s[i+1][j-1]++;\n          s[i+1][j+1]++;\n          s[i][j-1]++;\n          s[i][j+1]++;\n          s[i-1][j]++;\n          s[i-1][j+1]++;\n          s[i-1][j-1]++;\n\n          table[i][j] = com;\n          vec2 tmpvec(i-1,j-1);\n          q2.push(tmpvec);\n          tmpvec.y++;\n          q2.push(tmpvec);\n          tmpvec.y++;\n          q2.push(tmpvec);\n          tmpvec.x++;tmpvec.y-=2;\n          q2.push(tmpvec);\n          tmpvec.y+=2;\n          q2.push(tmpvec);\n          tmpvec.x++;tmpvec.y-=2;\n          q2.push(tmpvec);\n          tmpvec.y++;\n          q2.push(tmpvec);\n          tmpvec.y++;\n          q2.push(tmpvec);*/\n        }\n      }\n\n    }\n\n\n\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint h, w;\nchar t[1001];\nvector<string> v;\nint dx[8] = {0, 1, 1, 1, 0, -1, -1, -1};\nint dy[8] = {-1, -1, 0, 1, 1, 1, 0, -1};\nint ans;\ntypedef pair<int, int> P;\n\nbool solve(){\n/*\n\tprintf(\"\\n\");\n\tfor(int i=0; i<h; i++){\n\t\tprintf(\"%s\\n\", v[i].c_str());\n\t}\n*/\n\tbool d = false;\n\tvector<P> u;\n\tfor(int i=1; i<w+1; i++){\n\t\tfor(int j=1; j<h+1; j++){\n\t\t\tif(v[i][j] != '.'){\n\t\t\t\tint c = 0;\n\t\t\t\tfor(int k=0; k<8; k++){\n\t\t\t\t\tint nx, ny;\n\t\t\t\t\tnx = i + dx[k];\n\t\t\t\t\tny = j + dy[k];\n\t\t\t\t\tif(v[nx][ny] == '.') c++;\n\t\t\t\t}\n\t\t\t\tif(v[i][j] - '0' <= c){\n\t\t\t\t\tu.push_back(P(i, j));\n\t\t\t\t\td = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0; i<u.size(); i++){\n\t\tv[u[i].first][u[i].second] = '.';\n\t}\n\tif(d) ans++;\n\treturn d;\n}\n\nint main(){\n\tscanf(\"%d %d\", &h, &w);\n\tfor(int i=0; i<h; i++){\n\t\tscanf(\"%s\", t);\n\t\tv.push_back(t);\n\t}\n\twhile(solve());\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nstring board[1001];\nint dx[8] = {0, 1, 1, 1, 0, -1, -1, -1};\nint dy[8] = {1, 1, 0, -1, -1, -1, 0, 1};\nint h, w;\nbool hantei(int y, int x){\n\tif(0 <= y && y < h && 0 <= x && x < w) return true;\n\telse return false;\n}\nint main(void){\n\tcin >> h >> w;\n\trep(i, h) cin >> board[i];\n\tint ans = -1, nowy, nowx;\n\tbool flag = true;\n\twhile(flag){\n\t\tflag = false; ans++;\n\t\tvector<pair<int, int> > memo;//?????????????????????????????????????????????????????????\n\t\trep(y, h){\n\t\t\trep(x, w){\n\t\t\t\tif(board[y][x] == '.') continue;\n\t\t\t\tint tmp = 0;\n\t\t\t\trep(i, 8){\n\t\t\t\t\tnowy = y + dy[i]; nowx = x + dx[i];\n\t\t\t\t\tif(!hantei(nowy, nowx))continue;\n\t\t\t\t\tif(board[nowy][nowx] == '.')tmp++;\n\t\t\t\t}\n\t\t\t\tif(tmp >= board[y][x] - '0'){\n\t\t\t\t\t// board[y][x] = '.';?????????????????????????????????????\n\t\t\t\t\tmemo.push_back(make_pair(y, x));\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//???????????\n\t\trep(k, memo.size()){\n\t\t\tboard[memo[k].first][memo[k].second] = '.';\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define int long long int\n#define rep(a,b,c) for(int a=b;a<c;a++)\n#define repm(a,b,c) for(int a=(b-1);a>=c;a--)\n#define pb push_back\n#define str string\n#define sf(a) scanfs(\"%d\",&a)\n#define pb push_back\n#define mp make_pair\n#define Fi first\n#define Se second\n#define ALL(v) (v).begin(), (v).end()\n\nusing namespace std;\n\nconst int INF = 1e18 + 9;\nconst int Mod = 1e9 + 7;\ninline int replac(str s){double ans=0;rep(i,0,s.length()){ans+=(s[i]-'0')*pow(10,s.length()-i-1);}return (int)ans;}\ninline string numstr(int m){str s=\"\";while(m>0){char c;int a=m/10;if(a>0)a=m%(a*10);else a=m;c=(char)('0'+a);s+=c;m/=10;}str st=\"\";for(int i=s.size()-1;i>=0;i--){st+=s[i];}return st;}\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vii;\nint a[50][2000];\n queue<pii> p1;\n queue<pii> p2;\nsigned main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int w,h;\n    cin >> h >> w;\n    memset(a,0,sizeof(a));\n    rep(i,0,h){\n        rep(j,0,w){\n            char c;\n            cin >> c;\n            if(c=='.'){\n                p1.push(mp(j,i));\n            }else{\n                //cout << c-'0' << endl;\n                a[i][j]=c-'0';\n            }\n        }\n    }\n    int dx[8]={0,1,0,-1,1,-1,-1,1};\n    int dy[8]={1,0,-1,0,1,-1,1,-1};\n    int ans=0;\n    while(!p1.empty()){\n        //if(p1.empty())break;\n        ans++;\n        while(!p1.empty()){\n            pii pa = p1.front();p1.pop();\n            rep(i,0,8){\n                int x=dx[i]+pa.first;\n                int y=dy[i]+pa.second;\n                if(x<0||y<0||x>=w||y>=h)continue;\n                ///a[y][x]--;\n                //cout << a[y][x];\n                if(a[y][x]==1){\n                   // cout << y << x << endl;\n                    p2.push(mp(x,y));\n                }\n                if(a[y][x]>0)a[y][x]--;\n            }\n        }\n        if(p2.empty())break;\n        ans++;\n        while(!p2.empty()){\n            pii pa = p2.front();p2.pop();\n            rep(i,0,8){\n                int x=dx[i]+pa.first;\n                int y=dy[i]+pa.second;\n                if(x<0||y<0||x>=w||y>=h)continue;\n                if(a[y][x]==1){\n                    p1.push(mp(x,y));\n                  //  cout << y << x << endl;\n                }\n                if(a[y][x]>0)a[y][x]--;\n            }\n        }\n    }\n    cout << ans-1 << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n\nusing namespace std;\n\nint main() {\n    int h, w;\n    cin >> h >> w;\n    vector<string> ban(h);\n    vector<vector<int>> count(h, vector<int>(w));\n    for (int i = 0; i < h; i++) {\n        cin >> ban[i];\n        for (int j = 0; j < w; j++) {\n            if (ban[i][j] != '.') {\n                for (int k = -1; k <= 1; k++) {\n                    for (int l = -1; l <= 1; l++) {\n                        if (k == 0 && l == 0)continue;\n                        count[i + k][j + l]++;\n                    }\n                }\n            }\n        }\n    }\n    queue<pair<int, int>> q;\n    vector<vector<bool>> broken(h, vector<bool>(w));\n    for (int i = 0; i < h; i++) {\n        for (int j = 0; j < w; j++) {\n            if (ban[i][j] != '.') {\n                if (ban[i][j] - '0' <= 8 - count[i][j]) {\n                    q.push(make_pair(i, j));\n                    broken[i][j] = true;\n                }\n            }\n        }\n    }\n    q.push(make_pair(-1, -1));\n    int ret = 0;\n    while (true) {\n        pair<int, int> x = q.front();\n        if (x.first < 0) {\n            q.pop();\n            ret++;\n            if (q.empty())break;\n            q.push(make_pair(-1, -1));\n        } else {\n            q.pop();\n            for (int k = -1; k <= 1; k++) {\n                for (int l = -1; l <= 1; l++) {\n                    if (k == 0 && l == 0)continue;\n                    int a = x.first + k;\n                    int b = x.second + l;\n                    count[a][b]--;\n                    bool flag=broken[a][b];\n                    if (ban[a][b] != '.' && !flag) {\n                        if (ban[a][b] - '0' <= 8 - count[a][b]) {\n                            q.push(make_pair(a, b));\n                            broken[a][b] = true;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    cout << ret << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint broken[1024][1024];\nbool vis[1024][1024];\nchar board[1024][1024];\n\nint countBroken(int y, int x, int lev)\n{\n    int ret = 0;\n    \n    for (int i = -1; i <= 1; i++){\n        for (int j = -1; j <= 1; j++){\n            if (i == 0 && j == 0) continue;\n            ret += (~broken[y + i][x + j] && broken[y + i][x + j] <= lev);\n        }\n    }\n    \n    return (ret);\n}\n\nint main()\n{\n    int w, h;\n    \n    scanf(\"%d %d\", &h, &w);\n    \n    memset(broken, -1, sizeof(broken));\n    memset(board, '.', sizeof(board));\n    \n    int ans = 0;\n    queue<pair<int, int> > q;\n    \n    for (int i = 1; i <= h; i++){\n        scanf(\"%s\", board[i] + 1);\n        for (int j = 1; j <= w; j++){\n            if (board[i][j] == '.'){\n                broken[i][j] = 0;\n                vis[i][j] = true;\n                q.push(make_pair(i, j));\n            }\n            else board[i][j] -= '0';\n        }\n    }\n    \n    while (q.size()){\n        pair<int, int> x = q.front(); q.pop();\n        \n        int Y = x.first, X = x.second;\n        ans = max(ans, broken[Y][X]);\n        \n        for (int i = -1; i <= 1; i++){\n            for (int j = -1; j <= 1; j++){\n                if (i == 0 && j == 0) continue;\n                if (!vis[Y + i][X + j] && countBroken(Y + i, X + j, broken[Y][X]) >= board[Y + i][X + j]){\n                    broken[Y + i][X + j] = broken[Y][X] + 1;\n                    vis[Y + i][X + j] = true;\n                    q.push(make_pair(Y + i, X + j));\n                }\n            }\n        }\n    }\n    \n    printf(\"%d\\n\", ans);\n    \n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <queue>\n#define ll long long\n#define INF (1<<30)\nusing namespace std;\nint dx[8] = { 0, 0, 1, -1, 1, 1, -1, -1 };\nint dy[8] = { 1, -1, 0, 0, 1, -1, 1, -1 };\nstruct Castle {\n\tint h;\n\tint w;\n\tint times;\n};\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tll H, W; cin >> H >> W;\n\tvector<vector<char>> sand(H, vector<char>(W));\n\tvector<vector<int>> m(H, vector<int>(W, 0));\n\tqueue<Castle> q;\n\tfor (int i = 0; i < H;i++) for (int j = 0; j < W;j++) cin >> sand[i][j];\n\tfor (int i = 0; i < H;i++) {\n\t\tfor (int j = 0; j < W;j++) {\n\t\t\tif (sand[i][j] == '.') m[i][j] = INF;\n\t\t\telse {\n\t\t\t\tfor (int k = 0; k < 8;k++) {\n\t\t\t\t\tint vi = i + dx[k];\n\t\t\t\t\tint vj = j + dy[k];\n\t\t\t\t\tif (sand[vi][vj] == '.')m[i][j]++;\n\t\t\t\t}\n\t\t\t\tif (m[i][j] >= sand[i][j] - '0') {\n\t\t\t\t\tq.push({ i,j,1 });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ret = 0;\n\twhile (!q.empty()) {\n\t\tCastle cas = q.front(); q.pop();\n\t\tret = cas.times;\n\t\tfor (int k = 0; k < 8;k++) {\n\t\t\tint vi = cas.h + dx[k];\n\t\t\tint vj = cas.w + dy[k];\n\t\t\tif (m[vi][vj] >= sand[vi][vj] - '0')continue;\n\t\t\tm[vi][vj]++;\n\t\t\tif (m[vi][vj] >= sand[vi][vj] - '0') q.push({ vi,vj,ret + 1 });\n\t\t}\n\t}\n\tcout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<functional>\nusing namespace std;\nstruct P {\n\tint time, cost;\n};\nstruct Q {\n\tint x, y;\n};\nconst int inf = 1000000;\nint a[1000][1000];//????????????????????????????\nint g[1000][1000];//??????????????????????\nP b[1000][1000];//????????????????????????\nint main() {\n\tint h, w;\n\tcin >> h >> w;\n\tfor (int i = 0; i < h; i++) {\n\t\tstring u;\n\t\tcin >> u;\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tif (u[j] == '.') a[i][j] = 0;\n\t\t\telse a[i][j] = (int)u[j] - '0';\n\t\t\tg[i][j] = 0;\n\t\t\tb[i][j] = P{ 0,0 };\n\t\t}\n\t}\n\tfor (int i = 0; i < h; i++) {\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tif (a[i][j] == 0) {\n\t\t\t\tfor (int x = -1; x <= 1; x++) {\n\t\t\t\t\tfor (int y = -1; y <= 1; y++) {\n\t\t\t\t\t\tif (i + x < h&&i + x >= 0 && j + y < w&&j + y >= 0) {\n\t\t\t\t\t\t\tg[i + x][j + y]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint sum = 0;\n\tqueue<Q>p;\n\tfor (int i = 0; i < h; i++) {\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tif (g[i][j] >= a[i][j]&&a[i][j]!=0) {\n\t\t\t\ta[i][j] = 0;\n\t\t\t\tfor (int x = -1; x <= 1; x++) {\n\t\t\t\t\tfor (int y = -1; y <= 1; y++) {\n\t\t\t\t\t\tif (i + x < h&&i + x >= 0 && j + y < w&&j + y >= 0 && a[i + x][j + y] != 0) {\n\t\t\t\t\t\t\tp.push(Q{ i + x,j + y });\n\t\t\t\t\t\t\tb[i+x][j+y] = P{2,b[i+x][j+y].cost+1};\n\t\t\t\t\t\t\tsum = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\twhile (!p.empty()) {\n\t\tQ t = p.front(); p.pop();\n\t\tif (b[t.x][t.y].cost+g[t.x][t.y] >= a[t.x][t.y]&&a[t.x][t.y]!=0) {\n\t\t\ta[t.x][t.y] = 0;\n\t\t\tsum=max(sum, b[t.x][t.y].time);\n\t\t\tfor (int x = -1; x <= 1; x++) {\n\t\t\t\tfor (int y = -1; y <= 1; y++) {\n\t\t\t\t\tif (t.x + x < h&&t.x + x >= 0 && t.y + y < w&&t.y + y >= 0 && a[t.x + x][t.y + y] != 0) {\n\t\t\t\t\t\tif (b[t.x + x][t.y + y].cost < a[t.x + x][t.y + y]) {\n\t\t\t\t\t\t\tb[t.x + x][t.y + y] = P{ max(b[t.x + x][t.y + y].time,b[t.x][t.y].time + 1),b[t.x + x][t.y + y].cost + 1 };\n\t\t\t\t\t\t\tp.push(Q{ t.x + x, t.y + y });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << sum << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct vec2{\n  int x;\n  int y;\n  vec2(int x,int y){\n    this->x = x;\n    this->y = y;\n  }\n};\n\nshort s[1000][1000];\n\nint main(){\n\n    int w,h;\n\n    cin >> w >> h;\n\n    short table[w][h];\n\n    int dirx[8] = {-1,-1,-1,0,0,1,1,1},diry[8] = {-1,0,1,-1,1,-1,0,1};\n\n    char c;\n\n    for(int i=0;i<w;i++){\n      for(int j=0;j<h;j++){\n        cin >> c;\n        if(c=='.'){\n          table[i][j] = -1;\n        }\n        else{\n          stringstream ss;\n          ss << c;\n          ss >> table[i][j];\n        }\n      }\n    }\n\n    int ans = 0,com=-1,rep=-3;\n\n    queue<vec2> q1,q2;\n\n    for(int i=1;i<w-1;i++){\n      for(int j=1;j<h-1;j++){\n\n        int count = 0;\n        for(int k=0;k<8;k++){\n          int di = i + dirx[k],dj = j + diry[k];\n          if(table[di][dj] == -1){\n            count++;\n          }\n        }\n\n        s[i][j] = count;\n\n        if(table[i][j] > 0 && count >= table[i][j]){\n          vec2 tmpvec(i,j);\n          q1.push(tmpvec);\n          //table[i][j] = com;\n        }\n\n\n      }\n    }\n\n    /*for(int i=0;i<w;i++){\n      for(int j=0;j<h;j++){\n        cout << s[i][j] << \" \";\n      }\n      cout << endl;\n    }*/\n\n  //  cout << endl;\n\n    /*for(int i=1;i<w-1;i++){\n      for(int j=1;j<h-1;j++){\n\n          int count = 0;\n          if(table[i+1][j] == com || table[i+1][j] == rep) count++;\n          if(table[i+1][j-1] == com || table[i+1][j-1] == rep) count++;\n          if(table[i+1][j+1] == com || table[i+1][j+1] == rep) count++;\n          if(table[i][j-1] == com) count++;\n          if(table[i][j+1] == com || table[i][j+1] == rep) count++;\n          if(table[i-1][j] == com) count++;\n          if(table[i-1][j+1] == com) count++;\n          if(table[i-1][j-1] == com) count++;\n\n          s[i][j] = count;\n\n      }\n    }*/\n\n    /*for(int i=1;i<w-1;i++){\n      for(int j=1;j<h-1;j++){\n\n        if(table[i][j] == rep){\n          table[i][j] = com;\n\n        }\n      }\n    }*/\n\n  /*  while(!q1.empty()){\n      cout << q1.front().x << \" \" << q1.front().y << endl;\n      q1.pop();\n    }\n    while(1){}*/\n\n  /*  for(int i=0;i<w;i++){\n      for(int j=0;j<h;j++){\n        cout << table[i][j] << \" \";\n      }\n      cout << endl;\n    }\n    cout << endl;*/\n\n    if(q1.empty()) ans = -1;\n\n    while(1){\n\n      if(q1.empty()){\n      /*  for(int i=0;i<w;i++){\n          for(int j=0;j<h;j++){\n            cout << table[i][j] << \" \";\n          }\n          cout << endl;\n        }\n        cout << endl;*/\n        ans++;\n        if(q2.empty()){\n          break;\n        }\n        else{\n          while(!q2.empty()){\n            //cout << ans << \" \" <<  q2.front().x << \" \" << q2.front().y << endl;\n            q1.push(q2.front());\n            q2.pop();\n          }\n\n          /*for(int i=1;i<w-1;i++){\n            for(int j=1;j<h-1;j++){\n              if(table[i][j] == rep){\n                table[i][j] = com;\n              }\n            }\n          }*/\n\n        }\n      }\n\n      vec2 tmpvec = q1.front();\n      q1.pop();\n      int i = tmpvec.x;\n      int j = tmpvec.y;\n\n      if(i != 0 && i != w-1 && j != 0 && j != h-1){\n\n        table[i][j] = com;\n        for(int k=0;k<8;k++){\n          int vi = i+dirx[k];\n          int vj = j+diry[k];\n          s[vi][vj]++;\n        //  cout << ans  << \" \" << vi << \" \" << vj << \" \" << table[vi][vj] << \" \" << s[vi][vj] << endl;\n          if(table[vi][vj] > 0 && s[vi][vj] == table[vi][vj]){\n            vec2 tmpvecs(vi,vj);\n            q2.push(tmpvecs);\n            //table[vi][vj] = com;\n          }\n\n/*\n          s[i+1][j]++;\n          s[i+1][j-1]++;\n          s[i+1][j+1]++;\n          s[i][j-1]++;\n          s[i][j+1]++;\n          s[i-1][j]++;\n          s[i-1][j+1]++;\n          s[i-1][j-1]++;\n\n          table[i][j] = com;\n          vec2 tmpvec(i-1,j-1);\n          q2.push(tmpvec);\n          tmpvec.y++;\n          q2.push(tmpvec);\n          tmpvec.y++;\n          q2.push(tmpvec);\n          tmpvec.x++;tmpvec.y-=2;\n          q2.push(tmpvec);\n          tmpvec.y+=2;\n          q2.push(tmpvec);\n          tmpvec.x++;tmpvec.y-=2;\n          q2.push(tmpvec);\n          tmpvec.y++;\n          q2.push(tmpvec);\n          tmpvec.y++;\n          q2.push(tmpvec);*/\n        }\n      }\n\n    }\n\n\n\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <stdio.h>\n#include <stdlib.h>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <math.h>\n#include <utility>\n#include <set>\n#include <map>\n#define INF 1000000000\n#define rep(i,n) for(int i =0;i<n;i++)\nusing namespace std;\ntypedef long long int ll;\n\n\nint main(){\n    int h,w;\n    cin >>h >> w;\n    vector<int> area(h*w);\n    vector<int> ch(h*w,0);\n    queue<pair<int,int> > lis;\n    rep(i, h){\n        rep(j, w){\n            char hoge;\n            cin >> hoge;\n            if (hoge == '.') {\n                area[i*w+j]=-1;\n                for (int k=-1; k<2; k++) {\n                    for (int l=-1; l<2; l++) {\n                        if(k==0 and l==0) continue;\n                        if (i+k>0 and i+k<h-1 and j+l>0 and j+l<w-1) {\n                            ch[(i+k)*w+j+l]++;\n                        }\n                    }\n                }\n            }else{\n                area[i*w+j]=(int)hoge-(int)'0';\n            }\n        }\n    }\n    rep(i, h){\n        rep(j, w){\n            if (area[i*w+j]!=-1 and ch[i*w+j]>=area[i*w+j]) {\n                lis.push({i,j});\n            }\n        }\n    }\n    int ans = 0;\n    int flag = 1;\n    while (flag > 0) {\n        vector<int> oldc = ch;\n        int si = lis.size();\n        flag = 0;\n        rep(p, si){\n            int i = lis.front().first;\n            int j = lis.front().second;\n            lis.pop();\n            area[i*w+j]=-1;\n            for (int k=-1; k<2; k++) {\n                for (int l=-1; l<2; l++) {\n                    if(k==0 and l==0) continue;\n                    if (i+k>0 and i+k<h-1 and j+l>0 and j+l<w-1) {\n                        ch[(i+k)*w+j+l]++;\n                        if (area[(i+k)*w+j+l]!=-1 and ch[(i+k)*w+j+l]==area[(i+k)*w+j+l]) {\n                            lis.push({i+k,j+l});\n                        }\n                    }\n                }\n            flag++;\n            }\n        }\n        if(flag > 0) ans++;\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue> \n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint main() {\n\tint h, w;\n\tcin >> h >> w;\n\tint dx[] = {-1, 0, 1, -1, 1, -1, 0, 1};\n\tint dy[] = {-1, -1, -1, 0, 0, 1, 1, 1};\n\tvector< vector<int> > data(h, vector<int>(w, 0));\n\tchar c;\n\tqueue<P> q;\n\tfor (int i = 0; i < h; i++) {\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tcin >> c;\n\t\t\tif (c != '.') {\n\t\t\t\tif (c == '9') {\n\t\t\t\t\tdata[i][j] = 9;\n\t\t\t\t} else {\n\t\t\t\t\tq.push(P(i, j));\n\t\t\t\t\tdata[i][j] = c-'0';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvector< vector<int> > data2(h, vector<int>(w, 0));\n\tint n = q.size();\n\tint nami = 0;\n\tdo {\n\t\tqueue<P> q2;\n\t\tn = q.size();\n\t\tdata2 = data;\n\t\twhile (!q.empty()) {\n\t\t\tP p = q.front();\n\t\t\tq.pop();\n\t\t\tint count = 0;\n\t\t\tfor (int i = 0; i < 8; i++) {\n\t\t\t\tif (p.first+dy[i] >= 0 && p.first+dy[i] < h && p.second+dx[i] >= 0 && p.second+dx[i] < w) {\n\t\t\t\t\tif (data[p.first+dy[i]][p.second+dx[i]] == 0) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (count >= data[p.first][p.second]) {\n\t\t\t\tdata2[p.first][p.second] = 0;\n\t\t\t} else {\n\t\t\t\tq2.push(p);\n\t\t\t}\n\t\t}\n\t\tq = q2;\n\t\tdata = data2;\n\t\tif (q.size() != n) {\n\t\t\tnami++;\n\t\t}\n\t}while(n > q.size());\n\tcout << nami << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n#include <algorithm>\n#include <vector>\n#define INF (1<<30)\n#define ll long long\nusing namespace std;\n\nconst int dy[16] = { 0,-1, 0, 1, 1,-1, 1,-1, 0,-2, 0, 2 };\nconst int dx[16] = { 1, 0,-1, 0, 1, 1,-1,-1, 2, 0,-2, 0 };\n\nll H, W;\nvector<vector<ll>> m(1010, vector<ll>(1010, -1));\nvector<vector<ll>> C(1010, vector<ll>(1010, 0));\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tcin >> H >> W;\n\tfor (int i = 1; i <= H;i++) {\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tchar c; cin >> c;\n\t\t\tif (c != '.') {\n\t\t\t\tm[i][j] = c - '0';\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int k = 0;k < 8; k++) {\n\t\t\t\t\tC[i + dx[k]][j + dy[k]]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tll res = 0;\n\tqueue<pair<pair<ll, ll>, ll>> q;\n\n\tfor (int i = 2; i <= H - 1;i++) {\n\t\tfor (int j = 2; j <= W - 1; j++) {\n\t\t\tif (m[i][j] > 0) {\n\t\t\t\tif (C[i][j] >= m[i][j]) {\n\t\t\t\t\tq.push({ {i,j},1 });\n\t\t\t\t\tm[i][j] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\twhile (!q.empty()) {\n\t\tauto p = q.front(); q.pop();\n\t\tres = p.second;\n\t\tfor (int i = 0; i < 8;i++) {\n\t\t\tint x = p.first.first + dx[i];\n\t\t\tint y = p.first.second + dy[i];\n\t\t\tif (m[x][y] == -1)continue;\n\n\t\t\tC[x][y]++;\n\n\t\t\tif (C[x][y] >= m[x][y]) {\n\t\t\t\tq.push({{ x,y }, res + 1});\n\t\t\t\tm[x][y] = -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int>P;\n\nchar sand[1005][1005];\nint sara[1005][1005];\n\nint main(){\n\tint h,w;\n\tcin>>h>>w;\n\t\tqueue<P>now;\n\t\tqueue<P>next;\n\t\t\n\tfor(int i=0;i<h;i++)\n\tfor(int j=0;j<w;j++)cin>>sand[i][j];\n\t\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(sand[i][j]!='.'){\n\t\t\t\tfor(int k=-1;k<=1;k++){\n\t\t\t\t\tfor(int l=-1;l<=1;l++){\n\t\t\t\t\t\tif(sand[i+k][j+l]=='.')sara[i][j]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(sand[i][j]!='.'){\n\t\t\t\t\tint a=sand[i][j]-'0';\n\t\t\t\t\tif(a<=sara[i][j])now.push(make_pair(i,j));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint ans=0;\n\t\t\t\n\t\twhile(now.size()){\n\t\t\tans++;\n\t\t\tint broke=0;\n\t\t\t\n\t\t\twhile(now.size()){\n\t\t\t\tP p=now.front();\n\t\t\t\tnow.pop();\n\t\t\t\t\t\n\t\t\t\tfor(int j=-1;j<=1;j++){\n\t\t\t\t\tfor(int k=-1;k<=1;k++){\t\t\n\t\t\t\tif(sand[p.first+j][p.second+k]!='.'){\n\t\t\t\t\tnext.push(make_pair(p.first+j,p.first+k));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\t\n\t\t\t\tint b=sand[p.first][p.second]-'0';\n\t\t\t\t\n\t\t\t\tif(sara[p.first][p.second]>=b){\n\t\t\t\tfor(int j=-1;j<=1;j++){\n\t\t\t\t\tfor(int k=-1;k<=1;k++){\n\t\t\t\t\tif(sand[p.first+j][p.second+k]!='.')sara[p.first+j][p.second+k]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tsara[p.first][p.second]=0;\n\t\t\t\tsand[p.first][p.second]='.';\n\t\t\t\tbroke++;\n\t\t\t\t}\n\t\t}\n\t\tif(broke==0)break;\n\t\t\n\t\tint c=next.size();\n\t\t\tfor(int i=0;i<c;i++){\n\t\t\t\tnow.push(next.front());\n\t\t\t\tnext.pop();\n\t\t\t\t}\n\t\t}\t\n\t\tcout<<ans<<endl;\n\t\treturn 0;\n\t}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nstruct k{\n\tint x,y;\n};\nint map[1003][1003],b[1001][2],co[1001][2];\nint main(){\n\tint X,Y,c,cnt=0,longer,crash,dx[8]={-1,0,1,-1,1,-1,0,1},dy[8]={1,1,1,0,0,-1,-1,-1},i,i2,ix,iy,cc=0,tf,ccc;\n\tk ii;\n\tchar d;\n\tqueue<k> Q;\n\tcin>>Y>>X;\n\tfor(i=1;i<=Y;i++){\n\t\tfor(i2=1;i2<=X;i2++){\n\t\t\tcin>>d;\n\t\t\tswitch (d){\n\t\t\t\tcase '.':\n\t\t\t\t\tmap[i2][i]=0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '1':\n\t\t\t\t\tmap[i2][i]=1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '2':\n\t\t\t\t\tmap[i2][i]=2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '3':\n\t\t\t\t\tmap[i2][i]=3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '4':\n\t\t\t\t\tmap[i2][i]=4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '5':\n\t\t\t\t\tmap[i2][i]=5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '6':\n\t\t\t\t\tmap[i2][i]=6;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '7':\n\t\t\t\t\tmap[i2][i]=7;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '8':\n\t\t\t\t\tmap[i2][i]=8;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '9':\n\t\t\t\t\tmap[i2][i]=9;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tc=1;\n\tfor(i=1;i<=Y;i++){\n\t\tfor(i2=1;i2<=X;i2++){\n\t\t\tcrash=0;\n\t\t\tif(map[i2][i]!=0){\n\t\t\t\tfor(int i3=0;i3<8;i3++)if(map[i2+dx[i3]][i+dy[i3]]==0)crash++;\n\t\t\t\tif(map[i2][i]<=crash){\n\t\t\t\t\tb[c][0]=i2;\n\t\t\t\t\tb[c][1]=i;\n\t\t\t\t\tc++;\n\t\t\t\t\tii.x=i2;\n\t\t\t\t\tii.y=i;\n\t\t\t\t\tQ.push(ii);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\twhile(1){\n\t\tif(Q.empty()){\n\t\t\tbreak;\n\t\t}\n\t\telse{\n\t\t\tcnt++;\n\t\t}\n\t\tlonger=Q.size();\n\t\tfor(i=1;!Q.empty();i++){\n\t\t\tii=Q.front();\n\t\t\tb[i][0]=ii.x;\n\t\t\tb[i][1]=ii.y;\n\t\t\tmap[ii.x][ii.y]=0;\n\t\t\tQ.pop();\n\t\t}\n\t\tfor(i=0;i<=X*Y;i++){\n\t\t\tco[i][0]=0;\n\t\t\tco[i][1]=0;\n\t\t}\n\t\t//cout<<longer<<endl;\n\t\tccc=0;\n\t\tfor(i=1;i<=longer;i++){\n\t\t\tfor(i2=0;i2<8;i2++){\n\t\t\t\tix=b[i][0]+dx[i2];\n\t\t\t\tiy=b[i][1]+dy[i2];\n\t\t\t\tcc++;\n\t\t\t\tcrash=0;\n\t\t\t\ttf=0;\n\t\t\t\tfor(int www=0;co[www][0]!=0;www++)if(co[www][0]==ix&&co[www][1]==iy)tf=1;\n\t\t\t\tif(map[ix][iy]!=0&&tf==0){\n\t\t\t\t\t\tco[ccc][0]=ix;\n\t\t\t\t\t\tco[ccc][1]=iy;\n\t\t\t\t\t\tccc++;\n\t\t\t\t\tfor(int i3=0;i3<8;i3++){\n\t\t\t\t\t\tif(map[ix+dx[i3]][iy+dy[i3]]==0){\n\t\t\t\t\t\t\tcrash++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(map[ix][iy]<=crash){\n\t\t\t\t\t\tii.x=ix;\n\t\t\t\t\t\tii.y=iy;\n\t\t\t\t\t\tQ.push(ii);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<cnt<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint dx[]={1,1,1,0,0,-1,-1,-1};\nint dy[]={1,0,-1,1,-1,1,0,-1};\nint main(){\n  int w,h;\n  cin>>h>>w;\n  string s[h];\n  for(int i=0;i<h;i++)cin>>s[i];\n  for(int i=0;i<10000;i++){\n    vector<pair<int,int> >v;\n    for(int j=0;j<h;j++){\n      for(int k=0;k<w;k++){\n        if(s[j][k]=='.')continue;\n        int p=0;\n        for(int l=0;l<8;l++){\n          int y=j+dy[l],x=dx[l]+k;\n          if(y>=0&&x>=0&&y<h&&x<w)\n            if(s[y][x]=='.')p++;\n        }\n        if(p>=s[j][k]-'0')\n          v.push_back(make_pair(j,k));\n      }\n    }\n    if(v.size()){\n      for(int i=0;i<v.size();i++)\n        s[v[i].first][v[i].second]='.';\n    }\n    else{\n      cout<<i<<endl;\n      break;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main(){\n\tint h,w,n=0,f=0;\n\tchar c[1001][1001];\n\tint p[1001][1001],s[1000][1001];\n\tcin>>h>>w;\n\tfor(int i=1;i<=h;++i){\n\t\tfor(int j=1;j<=w;++j){\n\t\t\tcin>>c[i][j];\n\t\t\tif(c[i][j]=='.'){\n\t\t\t\tp[i][j]=-1;\n\t\t\t}else if(c[i][j]=='1'){\n\t\t\t\tp[i][j]=1;\n\t\t\t}else if(c[i][j]=='2'){\n\t\t\t\tp[i][j]=2;\n\t\t\t}else if(c[i][j]=='3'){\n\t\t\t\tp[i][j]=3;\n\t\t\t}else if(c[i][j]=='4'){\n\t\t\t\tp[i][j]=4;\n\t\t\t}else if(c[i][j]=='5'){\n\t\t\t\tp[i][j]=5;\n\t\t\t}else if(c[i][j]=='6'){\n\t\t\t\tp[i][j]=6;\n\t\t\t}else if(c[i][j]=='7'){\n\t\t\t\tp[i][j]=7;\n\t\t\t}else if(c[i][j]=='8'){\n\t\t\t\tp[i][j]=8;\n\t\t\t}else{\n\t\t\t\tp[i][j]=9;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=2;i<=h-1;++i){\n\t\tfor(int j=1;j<=w;++j){\n\t\t\ts[i][j]=p[i-1][j]+p[i][j]+p[i+1][j];\n\t\t}\n\t}\n\twhile(1){\n\t\tfor(int i=2;i<=h-1;++i){\n\t\t\tfor(int j=2;j<=w-1;++j){\n\t\t\t\tif(p[i][j]>0&&s[i][j-1]+s[i][j]+s[i][j+1]<=0){\n\t\t\t\t\ts[max(2,i-1)][j]=s[max(2,i-1)][j]-p[i][j]-1;\n\t\t\t\t\ts[i][j]=s[i][j]-p[i][j]-1;\n\t\t\t\t\ts[min(h-1,i+1)][j]=s[min(h-1,i+1)][j]-p[i][j]-1;\n\t\t\t\t\tp[i][j]=-1;\n\t\t\t\t\tf=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(f=0){\n\t\t\tbreak;\n\t\t}\n\t\tf=0;\n\t\t++n;\t\n\t}\n\tcout<<n;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<bits//stdc++.h>\n#include<functional>\nusing namespace std;\nstruct P{\n\tint x,y;\n};\nint main() {\n\tint a[50][50];\n\tint h,w;\n\tcin>>h>>w;\n\tfor(int i=0;i<h;i++){\n\t\tstring s;\n\t\tcin>>s;\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(s[j]=='.') a[i][j]=0;\n\t\t\telse a[i][j]=(int)s[j]-'0';\n\t\t}\n\t}\n\tint sum=0,sum2=1;\n\twhile(sum2){\n\t\tsum2=0;\n\t\tint sum3;\n\t\tP p[1000];\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(a[i][j]){\n\t\t\t\t\tsum3=0;\n\t\t\t\t\tfor(int x=-1;x<=1;x++){\n\t\t\t\t\t\tfor(int y=-1;y<=1;y++){\n\t\t\t\t\t\t\tif(i+x<h&&i+x>=0&&j+y<w&&j+y>=0&&a[i+x][j+y]==0) sum3++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(sum3>=a[i][j]) {\n\t\t\t\t\t\tp[sum2]=P{i,j};\n\t\t\t\t\t\tsum2++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<sum2;i++){\n\t\t\ta[p[i].x][p[i].y]=0;\n\t\t}\n\t\tsum++;\n\t}\n\tcout<<--sum<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<stdio.h>\n#include<stack>\nint mp[1002][1002] = { 0 }, mj[1002][1002] = { 0 };\nint main()\n{\n\tint x[8] = { -1,0,1,1,1,0,-1,-1 },m;\n\tint y[8] = { 1,1,1,0,-1,-1,-1,0 };\n\tint i,j,h, w,c=0,g,n=0;\n\tchar a;\n\tcin >> h >> w;\n\tfor (i = 0; i < h; i++)\n\t{\n\t\tfor (j = 0; j < w; j++)\n\t\t{\n\t\t\tcin >> a;\n\t\t\tif (a == '1')\n\t\t\t\tmp[i][j] =1;\n\t\t\tif (a == '2')\n\t\t\t\tmp[i][j] = 2;\n\t\t\tif (a == '3')\n\t\t\t\tmp[i][j] = 3;\n\t\t\tif (a == '4')\n\t\t\t\tmp[i][j] = 4;\n\t\t\tif (a == '5')\n\t\t\t\tmp[i][j] = 5;\n\t\t\tif (a == '6')\n\t\t\t\tmp[i][j] = 6;\n\t\t\tif (a == '7')\n\t\t\t\tmp[i][j] = 7;\n\t\t\tif (a == '8')\n\t\t\t\tmp[i][j] = 8;\n\t\t\tif (a == '9')\n\t\t\t\tmp[i][j] = 9;\n\t\t}\n\t}\n\tg = 0;\n\twhile(1)\n\t{\n\t\t\n\t\tfor (i = 0; i < h; i++)\n\t\t{\n\t\t\tfor (j = 0; j < w; j++)\n\t\t\t{\n\t\t\t\tmj[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < h; i++)\n\t\t{\n\t\t\tfor (j = 0; j < w; j++)\n\t\t\t{\n\t\t\t\tif (mp[i][j] >= 1)\n\t\t\t\t{\n\t\t\t\t\tfor (m = 0; m < 8; m++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (mp[i + y[m]][j + x[m]] == 0)\n\t\t\t\t\t\t\tc++;\n\t\t\t\t\t\tif (mp[i][j] <= c)\n\t\t\t\t\t\t\tmj[i][j] = 1;\n\t\t\t\t\t}\n\t\t\t\t\tc = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < h; i++)\n\t\t{\n\t\t\tfor (j = 0; j < w; j++)\n\t\t\t{\n\t\t\t\tif (mj[i][j] == 1)\n\t\t\t\t\tmp[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < h; i++)\n\t\t{\n\t\t\tfor (j = 0; j < w; j++)\n\t\t\t{\n\t\t\t\tif (mj[i][j] == 0)\n\t\t\t\t\tn++;\n\t\t\t}\n\t\t}\n\t\tif (n == h*w)\n\t\t\tbreak;\n\t\tg++;\n\t}\n\tcout<< g << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <bitset>\n#include <stack>\n#include <cstdlib>\n#include <complex>\n#include <unordered_map>\n#define rep(i,s,n) for(int i = s; n > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define MODU 33\n#define Range(x,a,b) ((a) <= (x) && (x) <= (b))\n#define POWT(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\nusing namespace std;\ntypedef vector<int> Ivec;\ntypedef pair<int, int> pii;\ntypedef long long int ll;\nconst pii eight_Dir[8] = { //?????????\n\t{ -1 ,1 },{ 0 ,1 },{ 1 ,1 },\n\t{ -1 ,0 },{ 1 ,0 },\n\t{ -1 ,-1 },{ 0 ,-1 },{ 1 ,-1 }\n};\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*)array, (T*)(array + N), val);\n}\nint main() {\n\tint h, w;\n\tscanf(\"%d %d\", &h, &w);\n\tvector<vector<int>> M(h, vector<int>(w)), dam(h, vector<int>(w));\n\tqueue<pair<int,pii>> sara;\n\tREP(i, h) {\n\t\tscanf(\"%*c\");\n\t\tREP(j, w) {\n\t\t\tscanf(\"%c\", &M[i][j]);\n\t\t\tif (M[i][j] == '.') {\n\t\t\t\tsara.push({ 0,{i,j} });\n\t\t\t\tdam[i][j] = '.';\n\t\t\t}\n\t\t\telse M[i][j] -= '0';\n\t\t}\n\t}\n\tint ans = 0;\n\twhile (sara.size()) {\n\t\tint turn = sara.front().first;\n\t\tpii pos = sara.front().second;\n\t\tsara.pop();\n\t\tREP(k, 8) {\n\t\t\tpii cur = { eight_Dir[k].first + pos.first ,eight_Dir[k].second + pos.second };\n\t\t\tif (Range(cur.first, 0, h - 1) && Range(cur.second, 0, w - 1)) {\n\t\t\t\tif (dam[cur.first][cur.second] != '.') {\n\t\t\t\t\tif ((++dam[cur.first][cur.second]) == M[cur.first][cur.second]) {\n\t\t\t\t\t\tdam[cur.first][cur.second] = '.';\n\t\t\t\t\t\tsara.push({ turn + 1, cur });\n\t\t\t\t\t\tans = turn + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#define F first\n#define S second\n#define MP make_pair\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PP;\nchar c[1000][1000];\nbool flag[1000][1000];\nint w, h, ans;\nint cdt[1000][1000];\nqueue<PP> que, que2;\n\nvoid fanc(PP p)\n{\n  for(int i = -1; i < 2; i++)\n  {\n    for(int j = -1; j < 2; j++)\n    {\n      if(!i && !j) continue;\n      if(p.F.F + i < h && p.F.F + i >= 0 && p.F.S + j < w && p.F.S + j >= 0)\n      {\n        cdt[p.F.F + i][p.F.S + j]++;\n        if(cdt[p.F.F + i][p.F.S + j] == c[p.F.F + i][p.F.S + j] - '0')\n        {\n          que.push(MP(MP(p.F.F + i, p.F.S + j), p.S));\n        }\n      }\n    }\n  }\n}\nvoid bfs()\n{\n  while(!que.empty())\n  {\n    fanc(MP(que.front().F, que.front().S + 1));\n    ans = max(ans, que.front().S);\n    que.pop();\n  }\n}\nint main()\n{\n  cin >> h >> w;\n  for(int i = 0; i < h; i++)\n  {\n    for(int j = 0; j < w; j++)\n    {\n      cin >> c[i][j];\n    }\n  }\n  for(int i = 0; i < h; i++)\n  {\n    for(int j = 0; j < w; j++)\n    {\n      if(c[i][j] == '.')\n      {\n        fanc(MP(MP(i, j), 1));\n      }\n    }\n  }\n  bfs();\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing pii = pair<int, int>;\n\nconst int INF = 1e9;\n\nconst int dx[] = { 1, 1, 0, -1, -1, -1, 0, 1 };\nconst int dy[] = { 0, 1, 1, 1, 0, -1, -1, -1 };\n\nint main()\n{\n\tint H, W;\n\tcin >> H >> W;\n\tvector<string> a(H);\n\tvector<vector<int>> d(H, vector<int>(W, INF));\n\tdeque<pii> dq;\n\tfor (int i = 0; i < H; i++) {\n\t\tcin >> a[i];\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (a[i][j] == '.') {\n\t\t\t\ta[i][j] = '0';\n\t\t\t\tdq.emplace_front(i * W + j, 0);\n\t\t\t}\n\t\t}\n\t}\n\twhile (!dq.empty()) {\n\t\tauto p = dq.front(); dq.pop_front();\n\t\tint x = p.first / W, y = p.first % W;\n\t\tif (d[x][y] != INF) continue;\n\t\tint cnt = 0;\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tint tx = x + dx[i], ty = y + dy[i];\n\t\t\tcnt += (0 <= tx && tx < H && 0 <= ty && ty < W && d[tx][ty] < p.second);\n\t\t}\n\t\tif (cnt < a[x][y] - '0') continue;\n\t\td[x][y] = p.second;\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tint tx = x + dx[i], ty = y + dy[i];\n\t\t\tif (tx < 0 || H <= tx || ty < 0 || W <= ty || d[tx][ty] != INF) continue;\n\t\t\tdq.emplace_front(tx * W + ty, d[x][y]);\n\t\t\tdq.emplace_back(tx * W + ty, d[x][y] + 1);\n\t\t}\n\t}\n\tint res = 0;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (d[i][j] != INF) {\n\t\t\t\tres = max(res, d[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tcout << res << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n\n\nint w,h;\n\nchar dat[1005][1005];\n\n\nint gs(int y,int x){\n\tint res=0;\n\treg(dy,-1,1){\n\t\treg(dx,-1,1){\n\t\t\tres += (dat[y+dy][x+dx]=='.'?1:0);\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(void){\n\tscanf(\"%d%d\",&h,&w);\n\trep(y,h)scanf(\"%s\",dat[y]);\n\n\tint ans=0;\n\tvector<mp> v[2];\n\trep(y,h){\n\t\trep(x,w){\n\t\t\tchar c = dat[y][x];\n\t\t\tif(c=='.')continue;\n\t\t\tif(gs(y,x)>=(c-'0'))v[0].push_back(mp(y,x));\n\t\t}\n\t}\n\t\n\tfor(;;){\n\t\tbool bd=false;\n\t\t\n\t\trep(i,v[0].size()){\n\t\t\tmp pa=v[0][i];\n\t\t\tint y=pa.fir,x=pa.sec;\n\t\t\tif(dat[y][x]=='.')continue;\n\t\t\tdat[y][x]='.';\n\t\t\tbd=true;\n\t\t\t\n\t\t\treg(dy,-1,1){\n\t\t\t\treg(dx,-1,1){\n\t\t\t\t\tchar c = dat[y+dy][x+dx];\n\t\t\t\t\tif(gs(y+dy,x+dx)>=(c-'0'))v[1].push_back(mp(y+dy,x+dx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tswap(v[0],v[1]);\n\t\tv[1].clear();\n\t\tif(!bd)break;\n\t\tans++;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define\t_USE_MATH_DEFINES\n#include <iostream>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cfloat>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <string>\n#include <set>\nusing namespace std;\nchar s[1200][1200];\nint co(int i,int j){\n\tif(s[i][j]=='.')\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\nint main(){\n\t\n\tstack<int> x;\n\tstack<int> y;\n\tint h,w;\n\tint count=0;\n\tcin>>h>>w;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tcin>>s[i][j];\n\t\t}\n\t}\n\t\n\twhile(1){\n\t\tbool f=false;\n\t\t\n\t\tfor(int i=1;i<h-1;i++){\n\t\t\tfor(int j=1;j<w-1;j++){\n\t\t\t\tif(s[i][j]!='.'){\n\t\t\t\t\tint sum=co(i-1,j-1)+co(i-1,j)+co(i-1,j+1)+co(i,j-1)+co(i,j+1)+co(i+1,j-1)+co(i+1,j)+co(i+1,j+1);\n\t\t\t\t\tif(sum>=s[i][j]-'0'){\n\t\t\t\t\t\tx.push(j);\n\t\t\t\t\t\ty.push(i);\n\t\t\t\t\t\tf=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(f){\n\t\t\twhile(!x.empty()){\n\t\t\t\ts[y.top()][x.top()]='.';\n\t\t\t\ty.pop();\n\t\t\t\tx.pop();\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tbreak;\n\t\t\n\t\tcount++;\n\t\t\n\t}\n\t\n\tcout<<count<<endl;\n\t\n\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <math.h>\n#include <utility>\n#include <set>\n#include <map>\n#define INF 1000000000\n#define rep(i,n) for(int i =0;i<n;i++)\nusing namespace std;\ntypedef long long int ll;\n\n\nint main(){\n    int h,w;\n    cin >>h >> w;\n    vector<int> area(h*w);\n    vector<int> ch(h*w,0);\n    queue<pair<int,int> > lis;\n    rep(i, h){\n        rep(j, w){\n            char hoge;\n            cin >> hoge;\n            if (hoge == '.') {\n                area[i*w+j]=-1;\n                for (int k=-1; k<2; k++) {\n                    for (int l=-1; l<2; l++) {\n                        if((k==0 and l==0) or area[(i+k)*w+j+l]==-1) continue;\n                        if (i+k>0 and i+k<h-1 and j+l>0 and j+l<w-1) {\n                            ch[(i+k)*w+j+l]++;\n                        }\n                    }\n                }\n            }else{\n                area[i*w+j]=(int)hoge-(int)'0';\n                lis.push({i,j});\n            }\n        }\n    }\n    int ans = 0;\n    int flag = 1;\n    while (flag > 0) {\n        vector<int> olda = area;\n        vector<int> oldc = ch;\n        int si = lis.size();\n        flag = 0;\n        rep(p, si){\n            int i = lis.front().first;\n            int j = lis.front().second;\n            lis.pop();\n            if (olda[i*w+j]!=-1 and oldc[i*w+j]>=olda[i*w+j]) {\n                 area[i*w+j]=-1;\n                 for (int k=-1; k<2; k++) {\n                    for (int l=-1; l<2; l++) {\n                        if(k==0 and l==0) continue;\n                        if (i+k>0 and i+k<h-1 and j+l>0 and j+l<w-1) {\n                            ch[(i+k)*w+j+l]++;\n                        }\n                    }\n                }\n                flag++;\n            }else{\n                lis.push({i,j});\n            }\n        }\n        if(flag > 0) ans++;\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nstruct Data { int x,y; };\nint h,w;\nchar c[1010][1010];\n\ninline bool isValid(int nx,int ny) { return 0 <= nx && nx < w && 0 <= ny && ny < h; }\n\nint main(){\n  cin >> h >> w;\n  rep(i,h) {\n    string s;\n    cin >> s;\n    rep(j,w) c[i][j] = s[j];\n  }\n  int phase = 0;\n  deque<Data> deq;\n  rep(i,h) rep(j,w) if( c[i][j] != '.' ) {\n    int cnt = 0;\n    REP(dy,-1,2) REP(dx,-1,2) {\n      int nx = j + dx, ny = i + dy;\n      if( !isValid(nx,ny) ) continue;\n      if( c[ny][nx] == '.' ) ++cnt;\n    }\n    if( cnt >= ( c[i][j] - '0' ) ) deq.push_back((Data){j,i});\n  }\n\n  while( !deq.empty() ) {\n    ++phase;\n    deque<Data> next_deq;\n    rep(i,deq.size()) c[deq[i].y][deq[i].x] = '.';\n    rep(i,deq.size()) {\n      REP(dy,-1,2) REP(dx,-1,2){\n\tint nx = deq[i].x + dx, ny = deq[i].y + dy;\n\tif( !isValid(nx,ny) ) continue;\n\tif( c[ny][nx] == '.' ) continue;\n\tint cnt = 0;\n\tREP(dy2,-1,2) REP(dx2,-1,2) {\n\t  int nx2 = nx + dx2, ny2 = ny + dy2;\n\t  if( !isValid(nx2,ny2) ) continue;\n\t  if( c[ny2][nx2] == '.' ) ++cnt;\n\t}\n       if( cnt >= ( c[ny][nx] - '0' ) ) next_deq.push_back((Data){nx,ny});\n      }\n      swap(deq,next_deq);\n    }\n  }\n  \n  cout << phase << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define REP(i,n) for(int i=0;i<n;i++)\n#define ARR(i,j) for(int i=-1;i<=1;i++)for(int j=-1;j<=1;j++)if(i!=0||j!=0)\ntypedef pair<int,int> P;\n\nint h,w;\nchar a[1002][1002];\nint kd[1002][1002];\nint sr[1002][1002];\nqueue<P> now;\nqueue<P> nxt;\n\nsigned main(){\n  cin>>h>>w;\n  REP(i,h)REP(j,w)cin>>a[i][j];\n  REP(i,h)REP(j,w){\n    if(i<=0||h-1<=i||j<=0||w-1<=j)continue;\n    if(a[i][j]!='.'){\n      kd[i][j]=a[i][j]-'0';\n      ARR(dx,dy)if(a[i+dx][j+dy]=='.')sr[i][j]++;\n      if(sr[i][j]>=kd[i][j])nxt.push(P(i,j));\n    }\n  }\n  int res=0;\n  while(!nxt.empty()){\n    res++;\n    swap(now,nxt);\n    while(!now.empty()){\n      P p=now.front();now.pop();\n      if(a[p.first][p.second]=='.')continue;\n      a[p.first][p.second]='.';\n      ARR(dx,dy){\n        int qx=p.first+dx;\n        int qy=p.second+dy;\n        sr[qx][qy]++;\n        if(a[qx][qy]!='.'&&sr[qx][qy]>=kd[qx][qy])nxt.push(P(qx,qy));\n      }\n    }\n  }\n  cout<<res<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define fi first\n#define se second\nconst int inf = 1e9;\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define rrep(i,n) for(int i = 1;i <= n;i++)\ntypedef pair<int,int> P;\n\nqueue<P> q1, q2;\nchar str[54][54];\nint a[54][54], b[54][54], h, w;\nint dy[] = {-1, -1, -1, 0, 0, 1, 1, 1};\nint dx[] = {-1, 0, 1, -1, 1, -1, 0, 1};\nbool ok(int y, int x){\n\tif(y < 0 || h+1 < y)return 1;\n\tif(x < 0 || w+1 < x)return 1;\n\treturn 0;\n}\n\nvoid calc(int y, int x){\n\tif(b[y][x] || !a[y][x] || ok(y, x))return ;\n\tif(a[y][x] != inf){\n\t\ta[y][x]--;\n\t\tif(!a[y][x])q1.push(P(y, x));\n\t\treturn ;\n\t}\n\tb[y][x] = 1;\n\tfor(int i = 0;i < 8;i++){\n\t\tcalc(y+dy[i], x+dx[i]);\n\t}\n}\n\nint solve(int k){\n\tif(q1.empty())return k;\n\twhile(!q1.empty()){\n\t\tP p = q1.front();q1.pop();\n\t\tb[p.fi][p.se] = 1;\n\t\tfor(int i = 0;i < 8;i++){\n\t\t\tint yy = p.fi+dy[i], xx = p.se+dx[i];\n\t\t\tif(!b[yy][xx] && a[yy][xx] != inf && a[yy][xx] != 0){\n\t\t\t\ta[yy][xx]--;\n\t\t\t\tif(a[yy][xx] == 0)q2.push(P(yy, xx));\n\t\t\t}\n\t\t}\n\t}\n\tswap(q1, q2);\n\tk = solve(k+1);\n\treturn k;\n}\n\nint main(){\n\tfill((int*)a, (int*)(a+54), inf);\n\tscanf(\"%d%d\", &h, &w);\n\trep(i,h)scanf(\"%s\", str[i]);\n\trep(i,h)rep(j,w){\n\t\tif(str[i][j] != '.')\n\t\ta[i+1][j+1] = str[i][j]-'0';\n\t}\n\t\n\trrep(i,h)rrep(j,w)if(a[i][j] == inf)calc(i, j);\n\tprintf(\"%d\\n\", solve(0));\n\t\n\t/*for(int i = 1;i <= h;i++){\n\t\tfor(int j = 1;j <= w;j++)printf(\"%d \", a[i][j]);\n\t\tprintf(\"\\n\");\n\t}*/\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\n//const int dx[] = { -1, 0, 0, 1 }, dy[] = { 0, -1, 1, 0 };\nconst int dx[] = { -1, -1, -1, 0, 0, 1, 1, 1 }, dy[] = { 0, -1, 1, -1, 1, 0, -1, 1 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\tint h, w;\n\tcin >> h >> w;\n\tvs fld(h);\n\tREP(i, h) cin >> fld[i];\n\tint ans = 0;\n\tset<pii> st;\n\tREP(i, h)REP(j, w) st.emplace(i, j);\n\tfor (ans = 0;; ans++)\n\t{\n\t\tvector<pii> col;\n\t\tfor(auto i: st)\n\t\t{\n\t\t\tint x = i.first, y = i.second;\n\t\t\tif (fld[x][y] == '.') continue;\n\t\t\tint cnt = 0;\n\t\t\tREP(k, 8)\n\t\t\t{\n\t\t\t\tint nx = x + dx[k], ny = y + dy[k];\n\t\t\t\tif (!valid(nx, ny, h, w)) continue;\n\t\t\t\tif (fld[nx][ny] == '.') cnt++;\n\t\t\t}\n\t\t\tif (cnt >= fld[x][y] - '0') col.emplace_back(i);\n\t\t}\n\t\tif (col.empty()) break;\n\t\tst.clear();\n\t\tfor (auto i : col)\n\t\t{\n\t\t\tfld[i.first][i.second] = '.';\n\t\t\tREP(k, 8)\n\t\t\t{\n\t\t\t\tint nx = i.first + dx[k], ny = i.second + dy[k];\n\t\t\t\tif (!valid(nx, ny, h, w)) continue;\n\t\t\t\tst.emplace(nx, ny);\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mp make_pair\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;//cnt, coodinate\nstring grid[1111];\nint neiber[1111][1111];\nint dx[] = {0, 1, 1,  1,  0, -1, -1, -1};\nint dy[] = {1, 1, 0, -1, -1, -1,  0,  1};\nint w, h;\n\nbool del(int x, int y){\n  int cnt = 0;\n  if(!(0 <= x && x < w &&\n       0 <= y && y < h))return false;\n  if(grid[y][x] == '.') return false;\n  for (int i = 0; i < 8; i++) {\n    int nx = x + dx[i], ny = y + dy[i];\n    if(!(0 <= nx && nx < w &&\n         0 <= ny && ny < h))continue;\n    if(grid[ny][nx] == '.')cnt++;\n  }\n  char tmp = grid[y][x];\n  neiber[y][x] = cnt;\n  if(cnt >= atoi(&tmp))return true;\n  else return false;\n}\n\nint main(int argc, char *argv[]){\n  queue<piii> que;\n  queue<pii> p;\n  cin >> h >> w;\n  for (int i = 0; i < h; i++) {\n    cin >> grid[i];\n  }\n  for (int i = 0; i < h; i++) {\n    for (int j = 0; j < w; j++) {\n      if(del(j, i)){\n        p.push(mp(j, i));\n        que.push(mp(1, mp(j, i)));\n      }\n    }\n  }\n  int ans = 0;\n  while(!que.empty()){\n    int cnt = que.front().first;\n    if(ans != cnt){\n      while(!p.empty()){\n        int x = p.front().first;\n        int y = p.front().second;\n        p.pop();\n        if(grid[y][x] == '.')continue;\n        grid[y][x] = '.';\n        for (int i = 0; i < 8; i++) {\n          int nx = x + dx[i], ny = y + dy[i];\n          neiber[ny][nx]++;\n        }\n      }\n    }\n    int x = que.front().second.first;\n    int y = que.front().second.second;\n    que.pop();\n    ans = cnt;\n    for (int i = 0; i < 8; i++) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if(!(0 <= nx && nx < w &&\n           0 <= ny && ny < h))continue;\n      char tmp = grid[ny][nx];\n      if(neiber[ny][nx] >= atoi(&tmp) && grid[ny][nx] != '.'){\n        p.push(mp(nx, ny));\n        que.push(mp(cnt + 1, mp(nx, ny)));\n      }\n    }\n  }\n  std::cout << ans << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<int,int> pint;\n\nconst int dx[]={-1,-1,-1,0,0,1,1,1},dy[]={-1,0,1,-1,1,-1,0,1};\nint p[1001][1001];\nstring s[1002];\nvector<pint> v0,v1;\nint main(){\n    int h,w;\n    cin>>h>>w;\n    rep(i,h) cin>>s[i];\n    FOR(i,1,h-1)FOR(j,1,w-1){\n        if(s[i][j]=='.') continue;\n        int cnt=0,cur=s[i][j]-'0';\n        rep(k,8){\n            int tx=j+dx[k],ty=i+dy[k];\n            if(s[ty][tx]=='.') ++cnt;\n        }\n        if(cur<=cnt) v0.pb(i-1,j-1);\n        else p[i-1][j-1]=cur-cnt;\n    }\n    int ans=0;\n    while(!v0.empty()){\n        v1.clear();\n        for(auto it:v0){\n            rep(i,8){\n                int ty=it.first+dy[i],tx=it.second+dx[i];\n                if(ty<0||tx<0||p[ty][tx]<=0) continue;\n                --p[ty][tx];\n                if(p[ty][tx]==0) v1.pb(ty,tx);\n            }\n        }\n        swap(v0,v1);\n        ++ans;\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#define ll long long\nusing namespace std;\n\nconst int dy[16] = { 0,-1, 0, 1, 1,-1, 1,-1, 0,-2, 0, 2 };\nconst int dx[16] = { 1, 0,-1, 0, 1, 1,-1,-1, 2, 0,-2, 0 };\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tll H, W; cin >> H >> W;\n\tvector<vector<ll>> m(H + 1, vector<ll>(W + 1, -1));\n\tfor (int i = 1; i <= H;i++) {\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tchar c; cin >> c;\n\t\t\tif (c != '.') {\n\t\t\t\tm[i][j] = c - '0';\n\t\t\t}\n\t\t}\n\t}\n\tbool f;\n\tint count = 0;\n\twhile (true) {\n\t\tf = false;\n\t\tauto temp_m = m;\n\t\tfor (int i = 2; i <= H - 1;i++) {\n\t\t\tfor (int j = 2; j <= W - 1; j++) {\n\t\t\t\tif (temp_m[i][j] > 0) {\n\t\t\t\t\tint count2 = 0;\n\t\t\t\t\tfor (int k = 0; k < 8; k++) {\n\n\t\t\t\t\t\tif (temp_m[i + dx[k]][j + dy[k]] == -1) {\n\t\t\t\t\t\t\tcount2++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (count2 >= temp_m[i][j]) {\n\t\t\t\t\t\tm[i][j] = -1;\n\t\t\t\t\t\tf = true;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\tfor (int i = 1; i <= H;i++) {\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\tif (m[i][j] == -1) {\n\t\t\t\t\tcout << \"# \";continue;\n\t\t\t\t}\n\t\t\t\tcout << m[i][j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << endl;\n\t\t*/\n\n\t\tif (f == true) count++;\n\t\telse break;\n\t}\n\n\tcout << count << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nstruct Data { \n  int x,y; \n  bool operator < ( const Data &data ) const {\n    return ( x == data.x ) ? y < data.y : x < data.x;\n  }\n  bool operator == ( const Data &data ) const {\n    return x == data.x && y == data.y;\n  }\n};\nint h,w;\nchar c[1010][1010];\n\ninline bool isValid(int nx,int ny) { return 0 <= nx && nx < w && 0 <= ny && ny < h; }\n\nint main(){\n  cin >> h >> w;\n  rep(i,h) {\n    string s;\n    cin >> s;\n    rep(j,w) c[i][j] = s[j];\n  }\n  int phase = 0;\n  deque<Data> deq;\n  rep(i,h) rep(j,w) if( c[i][j] != '.' ) {\n    int cnt = 0;\n    REP(dy,-1,2) REP(dx,-1,2) {\n      int nx = j + dx, ny = i + dy;\n      if( !isValid(nx,ny) ) continue;\n      if( c[ny][nx] == '.' ) ++cnt;\n    }\n    if( cnt >= ( c[i][j] - '0' ) ) deq.push_back((Data){j,i});\n  }\n\n  while( !deq.empty() ) {\n    ++phase;\n    deque<Data> next_deq;\n    rep(i,deq.size()) c[deq[i].y][deq[i].x] = '.';\n    rep(i,deq.size()) {\n      REP(dy,-1,2) REP(dx,-1,2){\n\tint nx = deq[i].x + dx, ny = deq[i].y + dy;\n\tif( !isValid(nx,ny) ) continue;\n\tif( c[ny][nx] == '.' ) continue;\n\tint cnt = 0;\n\tREP(dy2,-1,2) REP(dx2,-1,2) {\n\t  int nx2 = nx + dx2, ny2 = ny + dy2;\n\t  if( !isValid(nx2,ny2) ) continue;\n\t  if( c[ny2][nx2] == '.' ) ++cnt;\n\t}\n       if( cnt >= ( c[ny][nx] - '0' ) ) next_deq.push_back((Data){nx,ny});\n      }\n    }\n    deq = next_deq;\n    sort(deq.begin(),deq.end());\n    deq.erase(unique(deq.begin(),deq.end()),deq.end());\n  }\n  \n  cout << phase << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\n#define INF 1000000000\n\nusing namespace std;\n\nconst vector<int> dx = { 0, 1, 1, 1, 0, -1, -1, -1 };\nconst vector<int> dy = { -1, -1, 0, 1, 1, 1, 0, -1 };\n\nint H, W; vector<string> M;\n\nvector<vector<int> > state;\n\nint check(int x, int y, int s)\n{\n\tint ret = 0;\n\n\tfor (int dir = 0; dir < 8; dir++)\n\t{\n\t\tif (state[y + dy[dir]][x + dx[dir]] < s || M[y + dy[dir]][x + dx[dir]] == '.')\n\t\t{\n\t\t\tret++;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint main()\n{\n\tscanf(\"%d\", &H);\n\tscanf(\"%d\", &W);\n\n\tM = vector<string>(H);\n\n\tfor (int i = 0; i < H; i++) cin >> M[i];\n\n\tstate = vector<vector<int> >(H, vector<int>(W, INF));\n\n\tqueue<pair<int, int> > que;\n\n\tfor (int i = 1; i < H - 1; i++)\n\t{\n\t\tfor (int j = 1; j < W - 1; j++)\n\t\t{\n\t\t\tif (check(j, i, 1) >= M[i][j] - 48 && M[i][j] != '.')\n\t\t\t{\n\t\t\t\tque.push(make_pair(j, i)); state[i][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\twhile (!que.empty())\n\t{\n\t\tint x = que.front().first;\n\t\tint y = que.front().second; que.pop();\n\n\t\tfor (int dir = 0; dir < 8; dir++)\n\t\t{\n\t\t\tint x2 = x + dx[dir];\n\t\t\tint y2 = y + dy[dir];\n\n\t\t\tif (state[y2][x2] == INF && M[y2][x2] != '.' && check(x2, y2, state[y][x] + 1) >= M[y2][x2])\n\t\t\t{\n\t\t\t\tstate[y2][x2] = state[y][x] + 1;\n\n\t\t\t\tque.push(make_pair(x2, y2));\n\t\t\t}\n\t\t}\n\t}\n\n\tint ret = 0;\n\n\tfor (int i = 1; i < H - 1; i++)\n\t{\n\t\tfor (int j = 1; j < W - 1; j++)\n\t\t{\n\t\t\tif (state[i][j] != INF)\n\t\t\t{\n\t\t\t\tret = max(ret, state[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nusing ll=long long;\nusing vi=vector<int>;\nusing pii=pair<int,int>;\n#define ALL(c) begin(c),end(c)\n#define RALL(c) rbegin(c),rend(c)\n#define ITR(i,b,e) for(auto i=(b);i!=(e);++i)\n#define FORE(x,c) for(auto &x:c)\n#define REPF(i,a,n) for(int i=a,i##len=(int)(n);i<i##len;++i)\n#define REP(i,n) REPF(i,0,n)\n#define REPR(i,n) for(int i=(int)(n);i>=0;--i)\n#define SZ(c) ((int)c.size())\n#define CONTAIN(c,x) (c.find(x)!=end(c))\n#define OUTOFRANGE(y,x,h,w) (y<0||x<0||y>=h||x>=w)\n#define dump(...)\nconst int DX[9]={0,1,0,-1,1,1,-1,-1,0},DY[9]={-1,0,1,0,-1,1,1,-1,0};\n#define INF (1001001001)\n#define INFLL (1001001001001001001ll)\ntemplate<class T> ostream& operator << (ostream &os,const vector<T> &v) {\n    ITR(i,begin(v),end(v)) os<<*i<<(i==end(v)-1?\"\":\" \"); return os; }\ntemplate<class T> istream& operator >> (istream &is,vector<T> &v) {\n    ITR(i,begin(v),end(v)) is>>*i; return is; }\ntemplate<class T> istream& operator >> (istream &is, pair<T,T> &p) {\n    is>>p.first>>p.second; return is; }\ntemplate<class T> bool chmax(T &a,const T &b) {if(a<b) {a=b;return 1;} return 0;}\ntemplate<class T> bool chmin(T &a,const T &b) {if(b<a) {a=b;return 1;} return 0;}\ntemplate <class T> using heap = priority_queue<T,vector<T>,greater<T>>;\n//------------------------------------------------------------------------------\nstruct before_main_function {\n    before_main_function() {\n        #ifdef int\n            #undef INF\n            #define INF INFLL\n            #define stoi stoll\n        #endif\n        cin.tie(0);ios::sync_with_stdio(false);\n        cout<<setprecision(15)<<fixed;\n        #define endl \"\\n\"\n    }\n} before_main_function;\n//------------------8<------------------------------------8<--------------------\n\nsigned main() {\n    int H,W;\n    cin>>H>>W;\n    vector<string> s(H);\n    cin>>s;\n\n    queue<pair<pii,int>> q;\n    auto check=[&](int i,int j) {\n        int cnt=0;\n        REP(d,8) {\n            int ii=i+DY[d];\n            int jj=j+DX[d];\n            if(s[ii][jj]=='.') cnt++;\n        }\n        if(cnt>=s[i][j]-'0') {\n            return true;\n        }\n        return false;\n    };\n\n    int ans=0;\n    REP(i,H) {\n        REP(j,W) {\n            if(s[i][j]!='.') {\n                if(check(i,j)) {\n                    q.push({{i,j},1});\n                }\n            }\n        }\n    }\n    while(!q.empty()) {\n        int i=q.front().first.first;\n        int j=q.front().first.second;\n        s[i][j]='.';\n        int k=q.front().second; q.pop();\n        dump(i,j,k);\n        chmax(ans,k);\n        REP(d,8) {\n            int ii=i+DY[d];\n            int jj=j+DX[d];\n            if(s[ii][jj]!='.') {\n                if(check(ii,jj)) {\n                    q.push({{ii,jj},k+1});\n                }\n            }\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define Rep(i, a, b) for(int i = (a); i < (b); i++)\n#define rep(i, n) Rep(i, 0, n)\n\nint movX[8] = {-1, 0, 1,-1, 1,-1, 0, 1};\nint movY[8] = {-1,-1,-1, 0, 0, 1, 1, 1};\n\ntemplate<class T> T read() {\n\tT t;\n\tcin >> t;\n\treturn t;\n}\n\nint main(){\n\tint h=read<int>(),w=read<int>();\n\tint mp[h][w];\n\trep(i,h) rep(j,w){\n\t\tchar c=read<char>();\n\t\tif(c=='.'){\n\t\t\tmp[i][j]=0;\t\t\t\n\t\t}else{\n\t\t\tmp[i][j]=c-'0';\n\t\t}\n\t}\n\tint around[h][w] = {};\n\tRep(i, 1, h-1){\n\t\tRep(j, 1, w-1){\n\t\t\tint a = 0;\n\t\t\trep(k,8) {\n\t\t\t\tint x = i+movX[k];\n\t\t\t\tint y = j+movY[k];\n\t\t\t\t// printf(\"(%d, %d) -> (%d, %d) \", i, j, x, y);\n\t\t\t\tif(!mp[x][y]){\n\t\t\t\t\t// cout << \"o\";\n\t\t\t\t\ta++;\n\t\t\t\t}\n\t\t\t\t// cout << endl;\n\t\t\t}\n\t\t\taround[i][j]=a;\n\t\t}\n\t}\n\t// return 0;\n\t\t// rep(i,h){\n\t\t// \trep(j,w){\n\t\t// \t\tcout << mp[i][j];\n\t\t// \t}\n\t\t// \tcout << \" \";\n\t\t// \trep(j,w){\n\t\t// \t\tif(around[i][j]<0)\n\t\t// \t\t\tcout << \"x\";\n\t\t// \t\telse\n\t\t// \t\t\tcout << around[i][j];\n\t\t// \t}\n\t\t// \tcout << endl;\n\t\t// }\n\t\t// cout << \"-------------------------------------------\" << endl;\n\t\n\ttypedef pair<int, int> pii;\n\t\n\tint count = 0;\n\twhile(true){\n\t\tvector<pii> list;\n\t\tRep(i, 1, h-1){\n\t\t\tRep(j, 1, w-1){\n\t\t\t\tif(mp[i][j]>0 && around[i][j]>=mp[i][j]){\n\t\t\t\t\t// cout << i << \" \" << j << endl;\n\t\t\t\t\tlist.push_back(pii(i,j)); // mp[i][j] = 0;\n\t\t\t\t\t// now++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(list.size()==0){\n\t\t\tbreak;\n\t\t}\n\t\tcount++;\n\t\tfor(vector<pii>::iterator it=list.begin();it!=list.end();it++){\n\t\t\tint i = it->first, j = it->second;\n\t\t\tmp[i][j] = 0;\n\t\t\trep(k,8) {\n\t\t\t\tint x = i+movX[k];\n\t\t\t\tint y = j+movY[k];\n\t\t\t\taround[x][y]++;\n\t\t\t}\n\t\t}\n\t\t// rep(i,h){\n\t\t// \trep(j,w){\n\t\t// \t\tcout << mp[i][j];\n\t\t// \t}\n\t\t// \tcout << \" \";\n\t\t// \trep(j,w){\n\t\t// \t\tif(around[i][j]<0)\n\t\t// \t\t\tcout << \"x\";\n\t\t// \t\telse\n\t\t// \t\t\tcout << around[i][j];\n\t\t// \t}\n\t\t// \tcout << endl;\n\t\t// }\n\t\t// cout << \"-------------------------------------------\" << endl;\n\t}\n\tcout << count << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <queue>\nusing namespace std;\n\nint x, y;\nchar m[1024][1024];\nqueue<pair<int, int> > q;\n\nbool check_map() {\n\tbool flg = true;\n\tfor (int i = 0; i < y; i++) {\n\t\tfor (int i1 = 0; i1 < x; i1++) {\n\t\t\tint cnt = 0;\n\t\t\tif (m[i][i1] == '.')\n\t\t\t\tcontinue;\n\t\t\tif (m[i][i1] != '.') {\n\t\t\t\tint dx[8] = { 0, 0, 1, -1, 1, -1, 1, -1 }, dy[8] = { 1, -1, 0, 0, -1, -1, 1, 1 };\n\t\t\t\tfor (int i2 = 0; i2 < 8; i2++) {\n\t\t\t\t\tif (m[i + dy[i2]][i1 + dx[i2]] == '.') {\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tchar temp = m[i][i1];\n\t\t\t\tif (cnt >= atoi(&temp)) {\n\t\t\t\t\tq.push(make_pair(i, i1));\n\t\t\t\t\tflg = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn flg;\n}\n\nint main()\n{\n\tint cnt = 0;\n\tcin >> y >> x;\n\n\tfor (int i = 0; i < y; i++) {\n\t\tfor (int i1 = 0; i1 < x; i1++) {\n\t\t\tcin >> m[i][i1];\n\t\t}\n\t}\n\n\twhile (!check_map()) {\n\t\twhile (!q.empty()) {\n\t\t\tpair<int, int> temp = q.front();\n\t\t\tq.pop();\n\t\t\tm[temp.first][temp.second] = '.';\n\t\t}\n\t\tcnt++;\n\t}\n\n\tcout << cnt << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#include <cstring>\n\nusing namespace std;\n\nint h,w;\nchar bch[1003][1003];\nbool done[1003][1003];\n\nint wav (int i, int j)\n{\n    int c=0;\n    if (bch[i-1][j-1]=='.') c++;\n    if (bch[i-1][j]=='.') c++;\n    if (bch[i-1][j+1]=='.') c++;\n    if (bch[i][j-1]=='.') c++;\n    if (bch[i][j+1]=='.') c++;\n    if (bch[i+1][j-1]=='.') c++;\n    if (bch[i+1][j]=='.') c++;\n    if (bch[i+1][j+1]=='.') c++;\n    return c;\n}\n\nint bfs ()\n{\n    int cnt, ans=0;\n    bool ok=true;\n    queue<pair<int, int>> que;\n    vector<pair<int, int>> vec;\n    for (int i=1; i<h-1; i++)\n    {\n        for (int j=1; j<w-1; j++)\n        {\n            if (bch[i][j]=='.') continue;\n            cnt=wav(i, j);\n            if (cnt>=bch[i][j]-'0') que.push({i, j});\n        }\n    }\n    while (1)\n    {\n        if (que.empty())\n        {\n            if (!ok) break;\n            ans++;\n            ok=false;\n            for (auto u : vec)\n            {\n                int i=u.first, j=u.second;\n                bch[i][j]='.';\n            }\n            memset(done, false, sizeof(done));\n            for (auto u : vec)\n            {\n                int i=u.first, j=u.second;\n                if (bch[i-1][j-1]!='.' && !done[i-1][j-1]) { done[i-1][j-1]=true; que.push({i-1, j-1}); }\n                if (bch[i-1][j]!='.' && !done[i-1][j]) { done[i-1][j]=true; que.push({i-1, j}); }\n                if (bch[i-1][j+1]!='.' && !done[i-1][j+1]) { done[i-1][j+1]=true; que.push({i-1, j+1}); }\n                if (bch[i][j-1]!='.' && !done[i][j-1]) { done[i][j-1]=true; que.push({i, j-1}); }\n                if (bch[i][j+1]!='.' && !done[i][j+1]) { done[i][j+1]=true; que.push({i, j+1}); }\n                if (bch[i+1][j-1]!='.' && !done[i+1][j-1]) { done[i+1][j-1]=true; que.push({i+1, j-1}); }\n                if (bch[i+1][j]!='.' && !done[i+1][j]) { done[i+1][j]=true; que.push({i+1, j}); }\n                if (bch[i+1][j+1]!='.' && !done[i+1][j+1]) { done[i+1][j+1]=true; que.push({i+1, j+1}); }\n            }\n            vec.clear();\n        }\n        if (que.empty()) break;\n        int b=que.front().first, c=que.front().second;\n        que.pop();\n        if (bch[b][c]=='.') continue;\n        cnt=wav(b, c);\n        if (cnt<bch[b][c]-'0') continue;\n        vec.push_back({b,c});\n        ok=true;\n    }\n    return ans;\n}\n\nint main()\n{\n    cin>>h>>w;\n    for (int i=0; i<h; i++) for (int j=0; j<w; j++) cin>>bch[i][j];\n    cout<<bfs()<<'\\n';\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\nint H,W;\nchar a[1050][1050];\nint f[1050][1050];\nint num[1050][1050];\nint dx[8]={-1,-1,-1,0,0,1,1,1};\nint dy[8]={1,0,-1,1,-1,1,0,-1};\nvector<P> cur,tmp,next;\nint update()\n{\n\tint col = 0;\n\tfor(int i=0;i<cur.size();i++)\n\t{\n\t\tint x = cur[i].fi,y = cur[i].sec;\n\t\tif(f[x][y]!=0&&f[x][y]<=num[x][y])\n\t\t{\n\t\t\ttmp.pb(P(x,y));\n\t\t\tcol++;\n\t\t}\n\t}\n\tfor(int i=0;i<col;i++)\n\t{\n\t\tint x=tmp[i].fi,y=tmp[i].sec;\n\t\tf[x][y]=0;\n\t\tfor(int j=0;j<8;j++)\n\t\t{\n\t\t\tint nx=x+dx[j],ny=y+dy[j];\n\t\t\tnum[nx][ny]++;\n\t\t}\n\t}\n\tfor(int i=0;i<tmp.size();i++)\n\t{\n\t\tint x = tmp[i].fi,y = tmp[i].sec;\n\t\tfor(int j=0;j<8;j++)\n\t\t{\n\t\t\tint nx = x+dx[j],ny=y+dy[j];\n\t\t\tif(nx<0||nx>=H||ny<0||ny>=W)continue;\n\t\t\tif(f[nx][ny]!=0)next.pb(P(nx,ny));\n\t\t}\n\t}\n\tsort(next.begin(),next.end());\n\tnext.erase(unique(next.begin(),next.end()),next.end());\n\ttmp.clear();\n\tcur.clear();\n\tcur=next;\n\tnext.clear();\n\treturn col;\n}\nint main()\n{\n\tcin >> H >> W;\n\tfor(int i=0;i<H;i++)\n\t{\n\t\tfor(int j=0;j<W;j++)\n\t\t{\n\t\t\tcin >> a[i][j];\n\t\t\tif(a[i][j]!='.')f[i][j]=a[i][j]-'0';\n\t\t}\n\t}\n\tfor(int i=1;i<H-1;i++)\n\t{\n\t\tfor(int j=1;j<W-1;j++)\n\t\t{\n\t\t\tcur.pb(P(i,j));\n\t\t\tint cnt = 0;\n\t\t\tfor(int k=0;k<8;k++)\n\t\t\t{\n\t\t\t\tint nx=i+dx[k],ny=j+dy[k];\n\t\t\t\tif(f[nx][ny]==0)cnt++;\n\t\t\t}\n\t\t\tnum[i][j]=cnt;\n\t\t}\n\t}\n\tint ans = 0;\n\twhile(1)\n\t{\n\t\tint n = update();\n\t\tif(n==0)break;\n\t\tans++;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cctype>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\n#define INF (2 << 28)\n#define fr first\n#define sc second\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> iP;\n\nint main(){\n  \n  int W, H;\n  int dx[] = { 0, 1, 0, -1, 1, 1, -1, -1 }, dy[] = { 1, 0, -1, 0, 1, -1, 1, -1 };\n  char mas[1000][1000];\n  queue< iP > que;\n\n  cin >> H >> W;\n  for(int i = 0; i < H; i++) { \n    for(int j = 0; j < W; j++) {\n      cin >> mas[i][j];\n      if(isdigit(mas[i][j])) que.push(iP(j, i));\n    }\n  }\n  \n  int ans = 0, cnt;\n  while(!que.empty()) {\n    \n    bool judge = false;\n    vector< vector< bool > > used(H, vector< bool >(W, true));\n    queue< iP > query;\n    for(int lim = 0, size = que.size(); lim < size; lim++)  {\n      iP p = que.front(); que.pop();\n      cnt = 0;\n      for(int i = 0; i < 8; i++) {\n        int nx = p.fr + dx[i], ny = p.sc + dy[i];\n        if(mas[ny][nx] == '.') cnt++;\n      }\n      if(isdigit(mas[p.sc][p.fr]) && mas[p.sc][p.fr] - '0' <= cnt) {\n        query.push(p);\n        //mas[p.sc][p.fr] = '.';\n        for(int i = 0; i < 8; i++) {\n          int nx = p.fr + dx[i], ny = p.sc + dy[i];\n          if(isdigit(mas[ny][nx]) && used[ny][nx]) {\n            que.push(iP(nx, ny));\n            used[ny][nx] = false;\n          }\n        }\n      }\n    }\n    while(!query.empty()) {\n      judge = true;\n      mas[query.front().sc][query.front().fr] = '.';\n      query.pop();\n    }\n    if(judge) ans++;\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<queue>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int, int>P;\ntypedef long long ll;\n\nint h, w;\nchar ca[1000][1001];\nqueue<P>que1;\nqueue<P>que2;\n\nint cnt(int a, int b){\n\tint res = 0;\n\tfor (int i = -1; i <= 1; i++){\n\t\tfor (int j = -1; j <= 1; j++){\n\t\t\tif (ca[a + i][b + j] == '.')\n\t\t\t\tres++;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tscanf(\"%d%d\", &h, &w);\n\trep(i, h)\n\t\tscanf(\"%s\", ca[i]);\n\trep(i, h){\n\t\trep(j, w){\n\t\t\tif ('1' <= ca[i][j] && ca[i][j] - '0' <= cnt(i, j))\n\t\t\t\tque1.push(P(i, j));\n\t\t}\n\t}\n\tint res = 0;\n\twhile (!que1.empty()){\n\t\tres++;\n\t\trep(i, que1.size()){\n\t\t\tP p = que1.front(); que1.pop();\n\t\t\tca[p.first][p.second] = '.';\n\t\t\tque1.push(p);\n\t\t}\n\t\twhile (!que1.empty()){\n\t\t\tP p = que1.front(); que1.pop();\n\t\t\tint f = p.first, s = p.second;\n\t\t\tfor (int i = -1; i <= 1; i++){\n\t\t\t\tfor (int j = -1; j <= 1; j++){\n\t\t\t\t\tif ('1' <= ca[f + i][s + j] && ca[f + i][s + j] - '0' <= cnt(f + i, s + j))\n\t\t\t\t\t\tque2.push(P(f + i, s + j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswap(que1, que2);\n\t}\n\tprintf(\"%d\\n\", res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\nint h, w;\nvector<string> v;\nchar t[1001];\nint a[1000][1000];\nint dx[8] = {1, 1, 1, 0, -1, -1, -1, 0};\nint dy[8] = {-1, 0, 1, 1, 1, 0, -1, -1};\ntypedef pair<int, int> P;\nqueue<P> q[2];\nint b = 0;\nint ans;\n\nint main(){\n\tscanf(\"%d %d\", &h, &w);\n\tfor(int i=0; i<h; i++){\n\t\tscanf(\"%s\", t);\n\t\tv.push_back(t);\n\t}\n\tfor(int i=1; i<w-1; i++){\n\t\tfor(int j=1; j<h-1; j++){\n\t\t\tint c = 0;;\n\t\t\tfor(int k=0; k<8; k++){\n\t\t\t\tint nx, ny;\n\t\t\t\tnx = i + dx[k];\n\t\t\t\tny = j + dy[k];\n\t\t\t\tif(v[ny][nx] == '.') c++;\n\t\t\t}\n\t\t\ta[j][i] = c;\n\t\t}\n\t}\n\tfor(int i=1; i<w-1; i++){\n\t\tfor(int j=1; j<h-1; j++){\n\t\t\tif(v[j][i] != '.'){\n\t\t\t\tif(v[j][i] - '0' <= a[j][i]) q[0].push(P(i, j));\n\t\t\t}\n\t\t}\n\t}\n\n\twhile(q[b].size()){\n\t\tans++;\n\t\twhile(q[b].size()){\n\t\t\tP p = q[b].front();\n\t\t\tq[b].pop();\n\t\t\tfor(int i=0; i<8; i++){\n\t\t\t\tint nx, ny;\n\t\t\t\tnx = p.first + dx[i];\n\t\t\t\tny = p.second + dy[i];\n\t\t\t\ta[ny][nx] ++;\n\t\t\t\tif(v[ny][nx] != '.' && a[ny][nx] == v[ny][nx] - '0') q[1-b].push(P(nx, ny));\n\t\t\t}\n\t\t}\n\t\tb=1-b;\n/*\n\t\tfor(int i=0; i<h; i++){\n\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\tprintf(\"%d\\t\", a[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tprintf(\"\\n\");\n*/\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <queue>\n#include <set>\n#include <algorithm>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nstring board[1001];\nint dx[8] = {0, 1, 1, 1, 0, -1, -1, -1};\nint dy[8] = {1, 1, 0, -1, -1, -1, 0, 1};\nint h, w;\nbool hantei(int y, int x){\n\tif(0 <= y && y < h && 0 <= x && x < w) return true;\n\telse return false;\n}\n\nint main(void){\n\tcin >> h >> w;\n\trep(i, h) cin >> board[i];\n\tqueue<pair<int, int> > q1, q2;\n\trep(i, h)rep(j, w){\n\t\tif(board[i][j] != '.') q1.push(make_pair(i, j));\n\t}\n\n\tint ans = -1, cnt = 0, nowy, nowx;\n\tbool flag = true;\n\twhile(flag){\n\t\t// printf(\"cnt %d\\n\", cnt);\n\t\tflag = false; ans++;\n\t\tvector<pair<int, int> > memo;//?????????????????????????????????????????????????????????\n\t\tset<pair<int, int> > s;\n\t\tif(cnt % 2 == 0){\n\t\t\twhile(!q1.empty()){//q1??????????????\n\t\t\t\tpair<int, int> now = q1.front(); q1.pop();\n\t\t\t\tif(board[now.first][now.second] == '.') continue;\n\t\t\t\tint tmp = 0;\n\t\t\t\trep(i, 8){\n\t\t\t\t\tint nowy = now.first + dy[i], nowx = now.second + dx[i];\n\t\t\t\t\tif(!hantei(nowy, nowx)) continue;\n\t\t\t\t\tif(board[nowy][nowx] == '.')tmp++;\n\t\t\t\t}\n\t\t\t\tif(tmp >= board[now.first][now.second] - '0'){\n\t\t\t\t\t// printf(\"q1 y:%d  x:%d\\n\", now.first, now.second);\n\t\t\t\t\tmemo.push_back(make_pair(now.first, now.second));\n\t\t\t\t\t// printf(\"mawari\\n\");\n\t\t\t\t\trep(k, 8){//???????????????????????????????????????????????????????????????????\n\t\t\t\t\t\tint ny = now.first + dy[k], nx = now.second + dx[k];\n\t\t\t\t\t\tif(!hantei(ny, nx)) continue;\n\t\t\t\t\t\tif(board[ny][nx] != '.'){\n\t\t\t\t\t\t\t// q2.push(make_pair(ny, nx));\n\t\t\t\t\t\t\ts.insert(make_pair(ny, nx));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// printf(\"q2 ny:%d  nx:%d\\n\", ny, nx);\n\t\t\t\t\t}\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\twhile(!q2.empty()){//q2??????????????\n\t\t\t\tpair<int, int> now = q2.front(); q2.pop();\n\t\t\t\tif(board[now.first][now.second] == '.') continue;\n\t\t\t\tint tmp = 0;\n\t\t\t\trep(i, 8){\n\t\t\t\t\tint nowy = now.first + dy[i], nowx = now.second + dx[i];\n\t\t\t\t\tif(!hantei(nowy, nowx)) continue;\n\t\t\t\t\tif(board[nowy][nowx] == '.')tmp++;\n\t\t\t\t}\n\t\t\t\tif(tmp >= board[now.first][now.second] - '0'){\n\t\t\t\t\t// printf(\"q2 y:%d  x:%d\\n\", now.first, now.second);\n\t\t\t\t\tmemo.push_back(make_pair(now.first, now.second));\n\t\t\t\t\t// printf(\"mawari\\n\");\n\t\t\t\t\trep(k, 8){//???????????????????????????????????????????????????????????????????\n\t\t\t\t\t\tint ny = now.first + dy[k], nx = now.second + dx[k];\n\t\t\t\t\t\tif(!hantei(ny, nx)) continue;\n\t\t\t\t\t\tif(board[ny][nx] != '.'){\n\t\t\t\t\t\t\t// q1.push(make_pair(ny, nx));\n\t\t\t\t\t\t\ts.insert(make_pair(ny, nx));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// printf(\"q1 ny:%d  nx:%d\\n\", ny, nx);\n\t\t\t\t\t}\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//???????????\n\t\trep(k, memo.size()){\n\t\t\tboard[memo[k].first][memo[k].second] = '.';\n\t\t}\n\t\tif(cnt % 2 == 0){\n\t\t\tfor(auto x : s) q2.push(make_pair(x.first, x.second));\n\t\t}else{\n\t\t\tfor(auto x : s) q1.push(make_pair(x.first, x.second));\n\t\t}\n\t\tcnt++;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define rep(i,n) for(int i=0;i<n;++i)\n#define FOR(i,a,b) for(int i=a;i<=b;++i)\nusing namespace std;\nstatic const LL INF = 1LL<<61LL;\nstatic const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };\nstatic const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };\ntypedef pair<LL,LL> PLL;\n\nstring mp[1010];\nLL feld[1010][1010];\nLL h,w;\nLL ans;\n\nLL slove(int x,int y){\n    LL cnt=0;\n    rep(i,8){\n        if(x==3&&y==2)cout<<mp[y+dy[i]][x+dx[i]]<<\" \"<<dy[i]<<\" \"<<dx[i]<<endl;\n        if(mp[y+dy[i]][x+dx[i]]!='.')continue;\n        cnt++;\n    }\n    if(cnt>=mp[y][x]-'0')return 1;\n    else return 0;\n}\n\n\nint main(){\n   cin>>h>>w;\n   rep(y,h)cin>>mp[y];\n   while(1){\n       int cnt=0;\n       rep(y,h){\n           rep(x,w){\n               int k;\n               if(mp[y][x]=='.')continue;\n               if(k=slove(x,y))feld[y][x]=INF;\n               cnt+=k;\n           }\n       }\n       rep(y,h)rep(x,w){\n               if(feld[y][x]!=INF)continue;\n               mp[y][x]='.';\n        }\n       if(cnt)ans++;\n       else break;\n   }\n   cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint H,W;\nint ans=0;\nchar table[1010][1010] ;\nint dx[] = {-1,0,1,-1,1,-1,0,1} ;\nint dy[] = {-1,-1,-1,0,0,1,1,1} ;\n\nbool check( int y , int x ){\n\tint cnt = 0;\n\tfor( int k=0 ; k<8 ; k++ ){\n\t\tcnt += (table[y+dy[k]][x+dx[k]] == '.') ;\n\t}\n\treturn ( ( table[y][x]-'0' <= cnt )?true :false ) ;\n}\n\nint main(){\n\t\n\tcin >> H >> W ;\n\tfor( int i=0 ; i<H ; i++ )\n\t\tfor( int j=0 ; j<W ; j++ )\n\t\t\tcin >> table[i][j] ;\n\t\n\twhile(1){\n\t\t\n\t\tbool ChangeFlag[1010][1010] = {} ;\n\t\tfor( int i=0 ; i<H ; i++ ){\n\t\t\tfor( int j=0 ; j<W ; j++ ){\n\t\t\t\tif( '1' <= table[i][j] && table[i][j] <= '9' ){\n\t\t\t\t\tChangeFlag[i][j] = check(i,j);\n\t\t\t\t}else ChangeFlag[i][j] = false;\n\t\t\t}\n\t\t}\n\t\t\n\t\tbool t = false;\n\t\tfor( int i=0 ; i<H ; i++ ){\n\t\t\tfor( int j=0 ; j<W ; j++ ){\n\t\t\t\tif( ChangeFlag[i][j] ){\n\t\t\t\t\tt = true;\n\t\t\t\t\ttable[i][j] = '.' ;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif( t ) ans++;\n\t\telse break ;\n\t}\n\t\n\tcout << ans << endl ;\n\t\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<queue>\n#define MP make_pair\nusing namespace std;\nlong long int sc[1001][1001];\nchar c[1001];\nint main()\n{\n\tint h, w, cnt = 0, ans = 0;\n\tint x, y;\n\tpair<int, int> p;\n\tqueue< pair<int, int> > que;\n\tscanf(\"%d%d\",&h,&w);\n\tfor (int i = 0; i < h; i++)\n\t{\n\t\tscanf(\"%s\", c);\n\t\tfor (int j = 0; j < w; j++)\n\t\t{\n\n\t\t\tif (c[j] == '.')\n\t\t\t\tsc[i][j] = -1;\n\t\t\telse\n\t\t\t\tsc[i][j] = c[j] - 48;\n\t\t}\n\t}\n/*\t\tfor (int i = 0; i < h; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t{\n\n\t\t\t\tprintf(\"%2d\", sc[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t}*/\n\t\tdo\n\t\t{\n\t\t\tif (!que.empty())\n\t\t\t{\n\t\t\t\twhile (!que.empty())\n\t\t\t\t{\n\t\t\t\t\tx = que.front().first;\n\t\t\t\t\ty = que.front().second;\n\t\t\t\t\tque.pop();\n\t\t\t\t\tsc[x][y] = -1;\n\t\t\t\t}\n\t\t\t\tans++;\n\t\t\t}\n\t\t\tfor (int i = 1; i < h; i++)\n\t\t\t{\n\t\t\t\tfor (int j = 1; j < w; j++)\n\t\t\t\t{\n\t\t\t\t\tif (sc[i][j] != -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int a = -1; a < 2; a++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (sc[i - 1][j + a] == -1)\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\tif (sc[i + 1][j + a] == -1)\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (sc[i][j - 1] == -1)\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tif (sc[i][j + 1] == -1)\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tif (sc[i][j] <= cnt)\n\t\t\t\t\t\t\tque.push(MP(i, j));\n\t\t\t\t\t}\n\t\t\t\t\tcnt = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t} while (!que.empty());\n\t\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : JOI.cpp\n// Author      :\n// Version     :\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <algorithm>\nusing namespace std;\ntypedef struct pair<int,int> P;\n//1.???????DP\nint dp[1001][1001]={};\nint H,W;\nint d[1001][1001]={};\n\nint main() {\n\tcin>>H>>W;\n//2. ??\\???\n\tchar chr;\n\tfor(int i=0;i<H;i++){\n\t\tfor(int j=0;j<W;j++){\n\t\t\tcin>>chr;\n\t\t\tif(chr=='.')d[i][j]=0;\n\t\t\tif(chr=='1')d[i][j]=1;\n\t\t\tif(chr=='2')d[i][j]=2;\n\t\t\tif(chr=='3')d[i][j]=3;\n\t\t\tif(chr=='4')d[i][j]=4;\n\t\t\tif(chr=='5')d[i][j]=5;\n\t\t\tif(chr=='6')d[i][j]=6;\n\t\t\tif(chr=='7')d[i][j]=7;\n\t\t\tif(chr=='8')d[i][j]=8;\n\t\t}\n\t}\n//3.queue\n\tqueue<P> que1,que2;\n\tint total=0;\n\tfor(int i=1;i<H-1;i++){\n\t\tfor(int j=1;j<W-1;j++){\n\t\t\tint t2=0;\n\t\t\tif(d[i-1][j]==0)++t2;\n\t\t\tif(d[i-1][j-1]==0)++t2;\n\t\t\tif(d[i-1][j+1]==0)++t2;\n\t\t\tif(d[i][j-1]==0)++t2;\n\t\t\tif(d[i][j+1]==0)++t2;\n\t\t\tif(d[i+11][j]==0)++t2;\n\t\t\tif(d[i+1][j-1]==0)++t2;\n\t\t\tif(d[i+1][j+1]==0)++t2;\n\t\t\tif(t2>=d[i][j])que1.push(P(i,j));\n\t\t}\n\t}\n\n\twhile(!que1.empty()){\n\t\ttotal++;\n\t\twhile(!que1.empty()){\n\t\t\tP p1=que1.front();\n\t\t\tque1.pop();\n\t\t\tint x=p1.first;\n\t\t\tint y=p1.second;\n\t\t\tif(d[x][y]==0)continue;\n\t\t\tint t2=0;\n\t\t\tif(d[x-1][y]==0)++t2;\n\t\t\tif(d[x-1][y-1]==0)++t2;\n\t\t\tif(d[x-1][y+1]==0)++t2;\n\t\t\tif(d[x][y-1]==0)++t2;\n\t\t\tif(d[x][y+1]==0)++t2;\n\t\t\tif(d[x+11][y]==0)++t2;\n\t\t\tif(d[x+1][y-1]==0)++t2;\n\t\t\tif(d[x+1][y+1]==0)++t2;\n\t\t\tif(t2<d[x][y])continue;\n\t\t\td[x][y]=0;\n\t\t\tque2.push(P(x-1,y));\n\t\t\tque2.push(P(x-1,y-1));\n\t\t\tque2.push(P(x-1,y+1));\n\t\t\tque2.push(P(x,y-1));\n\t\t\tque2.push(P(x,y+1));\n\t\t\tque2.push(P(x+1,y-1));\n\t\t\tque2.push(P(x+1,y));\n\t\t\tque2.push(P(x+1,y+1));\n\t\t}\n\t\twhile(!que2.empty()){\n\t\t\tP p2=que2.front();que2.pop();\n\t\t\tque1.push(p2);\n\t\t}\n\t}\n\n\tcout<<total<<endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstring>\nusing namespace std;\n\n#define MAX 12\n\nint main(){\n\tstring S;\n\tint n,m,t,sum,a;\n\tsum=0;\n\tshort x[MAX][MAX];\n\tbool y[MAX][MAX];\n\tshort z[MAX][MAX];\n\tshort v[MAX][MAX];\n\tmemset(x,0,sizeof(x));\n\tmemset(z,0,sizeof(z));\n\tchar T[10]={'.','1','2','3','4','5','6','7','8','9'};\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>S;\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tfor(int k=0;k<10;k++){\n\t\t\t\tif(S[j-1]==T[k]){\n\t\t\t\t\tx[i][j]=k;\n\t\t\t\t\tif(k==0){\n\t\t\t\t\t\tfor(int l=-1;l<=1;l++){\n\t\t\t\t\t\t\tfor(int o=-1;o<=1;o++){\n\t\t\t\t\t\t\t\tz[i+l][j+o] += 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\twhile(true){\n\t\tt=0;\n\t\tsum++;\n\t\tmemset(v,0,sizeof(v));\n\t\tmemset(y,false,sizeof(y));\n\t\tfor(int i=2;i<n;i++){\n\t\t\tfor(int j=2;j<m;j++){\n\t\t\t\tif(x[i][j]>=1 && z[i][j]>=x[i][j]){\n\t\t\t\t\ta=0;\n\t\t\t\t\ty[i][j]=true;\n\t\t\t\t\tt++;\n\t\t\t\t\tfor(int l=-1;l<=1;l++){\n\t\t\t\t\t\tfor(int o=-1;o<=1;o++){\n\t\t\t\t\t\t\tv[i+l][j+o]+= 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(t==0){\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i=2;i<n;i++){\n\t\t\tfor(int j=2;j<m;j++){\n\t\t\t\tif(y[i][j]==true){\n\t\t\t\t\tx[i][j]=0;\n\t\t\t\t}\n\t\t\t\tz[i][j] += v[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tcout<<sum-1<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nusing ll=long long;\nusing vi=vector<int>;\nusing pii=pair<int,int>;\n#define ALL(c) begin(c),end(c)\n#define RALL(c) rbegin(c),rend(c)\n#define ITR(i,b,e) for(auto i=(b);i!=(e);++i)\n#define FORE(x,c) for(auto &x:c)\n#define REPF(i,a,n) for(int i=a,i##len=(int)(n);i<i##len;++i)\n#define REP(i,n) REPF(i,0,n)\n#define REPR(i,n) for(int i=(int)(n);i>=0;--i)\n#define SZ(c) ((int)c.size())\n#define CONTAIN(c,x) (c.find(x)!=end(c))\n#define OUTOFRANGE(y,x,h,w) (y<0||x<0||y>=h||x>=w)\n#define dump(...)\nconst int DX[9]={0,1,0,-1,1,1,-1,-1,0},DY[9]={-1,0,1,0,-1,1,1,-1,0};\n#define INF (1001001001)\n#define INFLL (1001001001001001001ll)\ntemplate<class T> ostream& operator << (ostream &os,const vector<T> &v) {\n    ITR(i,begin(v),end(v)) os<<*i<<(i==end(v)-1?\"\":\" \"); return os; }\ntemplate<class T> istream& operator >> (istream &is,vector<T> &v) {\n    ITR(i,begin(v),end(v)) is>>*i; return is; }\ntemplate<class T> istream& operator >> (istream &is, pair<T,T> &p) {\n    is>>p.first>>p.second; return is; }\ntemplate<class T> bool chmax(T &a,const T &b) {if(a<b) {a=b;return 1;} return 0;}\ntemplate<class T> bool chmin(T &a,const T &b) {if(b<a) {a=b;return 1;} return 0;}\ntemplate <class T> using heap = priority_queue<T,vector<T>,greater<T>>;\n//------------------------------------------------------------------------------\nstruct before_main_function {\n    before_main_function() {\n        #ifdef int\n            #undef INF\n            #define INF INFLL\n            #define stoi stoll\n        #endif\n        cin.tie(0);ios::sync_with_stdio(false);\n        cout<<setprecision(15)<<fixed;\n        #define endl \"\\n\"\n    }\n} before_main_function;\n//------------------8<------------------------------------8<--------------------\n\nsigned main() {\n    int H,W;\n    cin>>H>>W;\n    vector<string> s(H);\n    cin>>s;\n\n    queue<pii> A,B;\n    auto check=[&](int i,int j) {\n        if(s[i][j]=='.') return false;\n        int cnt=0;\n        REP(d,8) {\n            int ii=i+DY[d];\n            int jj=j+DX[d];\n            if(s[ii][jj]=='.') cnt++;\n        }\n        if(s[i][j]-'0'<=cnt) {\n            return true;\n        } else {\n            return false;\n        }\n    };\n    int ans=0;\n    REP(i,H) {\n        REP(j,W) {\n            if(check(i,j)) {\n                A.push({i,j});\n            }\n        }\n    }\n    while(1) {\n        if(A.empty()) break;\n        ans++;\n        while(!A.empty()) {\n            int y=A.front().first;\n            int x=A.front().second;\n            A.pop();\n            s[y][x]='.';\n            B.push({y,x});\n        }\n        vector<vector<bool>> checked(H,vector<bool>(W,false));\n        while(!B.empty()) {\n            int y=B.front().first;\n            int x=B.front().second;\n            B.pop();\n            REP(d,8) {\n                int yy=y+DY[d];\n                int xx=x+DX[d];\n                if(check(yy,xx) && !checked[yy][xx]) {\n                    A.push({yy,xx});\n                    checked[yy][xx]=1;\n                }\n            }\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair< int, int > Pi;\ntypedef pair< int, Pi > Pii;\nconst static int dy[] = {-1, -1, 0, 1, 1, 1, 0, -1};\nconst static int dx[] = {0, 1, 1, 1, 0, -1, -1, -1};\n\nint main()\n{\n  int H, W;\n  char S[1000][1000];\n\n  cin >> H >> W;\n  for(int i = 0; i < H; i++) {\n    cin >> S[i];\n  }\n\n  queue< Pii > Que;\n  int ret = 0;\n\n  for(int i = 0; i < H; i++) {\n    for(int j = 0; j < W; j++) {\n      if(S[i][j] == '.') Que.push(Pii(0, Pi(j, i)));\n      else S[i][j] -= '0';\n    }\n  }\n  while(!Que.empty()) {\n    Pii& p = Que.front();\n    ret = max(ret, p.first);\n    for(int i = 0; i < 8; i++) {\n      int ny = p.second.second + dy[i];\n      int nx = p.second.first  + dx[i];\n      if(ny >= 0 && ny < H && nx >= 0 && nx < W && S[ny][nx] != '.') {\n        --S[ny][nx];\n        if(S[ny][nx] == 0) {\n          Que.push(Pii(p.first + 1, Pi(nx, ny)));\n        }\n      }\n    }\n    Que.pop();\n  }\n  cout << ret << endl;\n  return(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing P = pair<int, int>;\n\nvector<P> next(int y, int x) {return {{y-1, x-1}, {y-1, x}, {y-1, x+1}, {y, x-1}, {y, x+1}, {y+1, x-1}, {y+1, x}, {y+1, x+1}};}\n\nint main() {\n  int H, W;\n  cin >> H >> W;\n\n  auto valid = [&](auto y, auto x) {return 0 <= y && y < H && 0 <= x && x < W;};\n\n  vector<vector<int>> toughness(H, vector<int>(W)), blank(H, vector<int>(W));\n\n  for(auto i = 0; i < H; ++i) for(auto j = 0; j < W; ++j) {\n    char c;\n    cin >> c;\n    toughness[i][j] = (c == '.') ? 0 : (c - '0');\n  }\n\n  queue<P> cur, nex;\n  for(auto i = 0; i < H; ++i) for(auto j = 0; j < W; ++j) if(toughness[i][j] <= blank[i][j]) cur.emplace(i, j);\n  for(auto step = 0; ; ++step) {\n    if(cur.empty()) {cout << step - 1 << endl; break;}\n    while(!cur.empty()) {\n      int y, x;\n      tie(y, x) = cur.front();\n      cur.pop();\n      for(auto p: next(y, x)) if(valid(p.first, p.second)) if(++blank[p.first][p.second] == toughness[p.first][p.second]) nex.emplace(p);\n    }\n    swap(cur, nex);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint grd[1010][1010];\nint mx[]={1,1,1,0,0,0,-1,-1,-1},my[]={1,0,-1,1,0,-1,1,0,-1};\nint main(){\n\tint h,w;\tcin>>h>>w;\n\tqueue<pair<int,int>> ls;\n\tfor(int i=0;i<h;i++){\n\t\tstring s;\tcin>>s;\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(s[j]=='.')\tgrd[i][j]=-1;\n\t\t\telse{\n\t\t\t\tgrd[i][j]=s[j]-'0';\n\t\t\t\tls.push(make_pair(i,j));\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\twhile(true){\n\t\t//cout<<ans<<endl;\n\t\t//for(int i=0;i<h;i++){\n\t\t//\tfor(int j=0;j<w;j++)\tcout<<grd[i][j]<<\" \";\n\t\t//\tcout<<endl;\n\t\t//}\n\t\t//cout<<endl;\n\t\tqueue<pair<int,int>> next;\n\t\tqueue<pair<int,int>> broken;\n\t\twhile(!ls.empty()){\n\t\t\tauto now=ls.front();\tls.pop();\n\t\t\tint y=now.first,x=now.second;\n\t\t\tif(grd[y][x]==-1)\tcontinue;\n\t\t\tint cnt=0;\n\t\t\tfor(int i=0;i<9;i++)\tif(grd[y+my[i]][x+mx[i]]==-1)\tcnt++;\n\t\t\tif(cnt>=grd[y][x])\tbroken.push(make_pair(y,x));\n\t\t}\n\t\tif(broken.empty()){\n\t\t\tcout<<ans<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\twhile(!broken.empty()){\n\t\t\tauto now=broken.front();\tbroken.pop();\n\t\t\tint y=now.first,x=now.second;\n\t\t\tgrd[y][x]=-1;\n\t\t\tfor(int i=0;i<9;i++){\n\t\t\t\tint xx=x+mx[i],yy=y+my[i];\n\t\t\t\tnext.push(make_pair(yy,xx));\n\t\t\t}\n\t\t}\n\t\twhile(!next.empty()){\n\t\t\tls.push(next.front());\tnext.pop();\n\t\t}\n\t\tans++;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n\n\n#define max(a,b) ((a) > (b) ? (a) : (b))\n#define min(a,b) ((a) > (b) ? (b) : (a))\nchar st[64][64], sts[64][64];\nint H, W;\n\ninline void copy(char a[64][64], char b[64][64]) {\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\ta[i][j] = b[i][j];\n\t\t}\n\t}\n}\n\ninline bool is_castle(char a) {\n\treturn a != '.';\n}\n\ninline int conv(char a) {\n\treturn a - '0';\n}\n\ninline bool state(int x, int y) {\n\tint c = 0;\n\tfor (int i = max(x - 1, 0); i < min(x + 2, W); i++) {\n\t\tfor (int j = max(y - 1, 0); j < min(y + 2, H); j++) {\n\t\t\tif (st[i][j] == '.')\n\t\t\t\tc++;\n\t\t}\n\t}\n\treturn c >= conv(st[x][y]);\n\n}\n\ninline bool collapse(int x, int y) {\n\tif (is_castle(st[x][y]) && state(x,y)) {\n\t\tsts[x][y] = '.';\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool wave() {\n\tbool e = false;\n\tcopy(sts, st);\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\te = collapse(i, j) ? true : e;\n\t\t}\n\t}\n\tcopy(st, sts);\n\treturn e;\n}\n\nint main(){\n\tscanf(\"%d%d\", &H, &W);\n\tfor (int i = 0; i < H; i++) {\n\t\tscanf(\"%s\", st[i]);\n\t}\n\tfor (int i = 0;;i++) {\n\t\tif (!wave()) {\n\t\t\tprintf(\"%d\\n\", i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <map>\n#define FLAG -1\nusing namespace std;\ntypedef pair<int,int> P;\nint main(){\n      int h,w,dh[] = {1,1,1,0,-1,-1,-1,0}, dw[] = {1,0,-1,-1,-1,0,1,1},ctn,i,j;\n      int solve = -2 ;\n      cin >> h >> w;\n      queue<P> que,tmp;\n      char d[h][w];\n      for(i=0;i<h;i++){\n            for(j=0;j<w;j++)\n            {\n                  cin >> d[i][j];\n                  if('1'<=d[i][j]&&'9'>=d[i][j])\n                        que.push(make_pair(i,j));\n            }\n      }\n\n      que.push(make_pair(FLAG,FLAG));\n      for(;;){\n            solve++;\n            //map<P,bool> m;\n            for(;;){\n                  //cout << que.size()<<endl;\n                  P p = que.front();\n                  que.pop();\n                  if(p.first==FLAG)\n                  {//cout <<\" break \"<<endl<<endl;\n                  break;\n                  }\n                  ctn = 0;\n                  for(i = 0;i < 8;i++){\n                        if(d[p.first+dh[i]][p.second+dw[i]]=='.')ctn++;\n                  }\n\n                  if(ctn >= d[p.first][p.second]-'0'){\n                        tmp.push(p);\n                        for(j=0;j<8;j++)\n                        if(/*m.count(make_pair(p.first+dh[j],p.second+dw[j]))==0&& */ d[p.first][p.second]!='.'){\n                        que.push(make_pair(p.first+dh[j],p.second+dw[j]));\n                        //m[make_pair(p.first+dh[j],p.second+dw[j])]=true;\n                        }\n                  }\n            }\n            if(tmp.empty())break;\n            while(!tmp.empty())\n            {\n                  d[tmp.front().first][tmp.front().second]='.';\n                  tmp.pop();\n            }\n            /*for(i =0 ;i<h;i++)\n            {\n                  for(j=0;j<w;j++)cout << d[i][j];\n                  cout <<endl;\n            }\n            */\n\n            que.push(make_pair(FLAG,FLAG));\n\n      }\n      cout << solve << endl;\n}"
  },
  {
    "language": "C",
    "code": "\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n\nint search(char map[1001][1001], char before[1001][1001],int h, int w)\n{\n\tint castle_num = map[h][w] - '0';\n\n\tint i, j;\n\tint sara = 0;\n\tfor (i = h - 1; i <= h + 1; i++)\n\t{\n\t\tfor (j = w - 1; j <= w + 1; j++)\n\t\t{\n\t\t\tif (map[i][j]=='.')sara++;\n\t\t}\n\t}\n\n\tif (castle_num <= sara)\n\t{\n\t\tbefore[h][w] = '.';\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n\nint main()\n{\n\tint H, W;\n\tint i, j;\n\tint wave_count = 0;\n\tint wave_flag = -1;\n\n\tchar castle[1001][1001];\n\tchar before[1001][1001];\n\n\tscanf(\"%d %d\", &H, &W);\n\t\n\tfor (i = 0; i<H; i++)\n\t{\n\t\tfor (j = 0; j < W; j++)\n\t\t{\n\t\t\tscanf(\" %c\", &castle[i][j]);\n\t\t}\n\t}\n\t\n\tfor (i = 0; i < H; i++)\n\t\tstrcpy(before[i], castle[i]);\n\n\t//?????????\n\twhile (1)\n\t{\n\t\twave_flag = 0;\n\t\tfor (i = 0; i<H; i++)\n\t\t{\n\t\t\tfor (j = 0; j<W; j++)\n\t\t\t{\n\t\t\t\tif (castle[i][j] != '.')\n\t\t\t\t{\n\t\t\t\t\tif (search(castle,before,i, j) == 1)wave_flag++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tif (wave_flag != 0)\n\t\t{\n\t\t\twave_count++;\n\t\t\tfor (i = 0; i < H; i++)\n\t\t\t\tstrcpy(castle[i], before[i]);\n\t\t}\n\t\telse{ break; }\n\t}\n\n\tprintf(\"%d\\n\", wave_count);\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint x[1000000],y[1000000];\nchar d[1010][1010]={0};\nint Y[]={1,1,0,-1,-1,-1,0,1};\nint X[]={0,1,1,1,0,-1,-1,-1};\nint main(){\n  int w,h,i,j,t=0,r=0,rr=0,ny,nx;\n  scanf(\"%d %d\",&h,&w);\n  for(i=1;i<=h;i++){\n    for(j=1;j<=w;j++){\n      scanf(\" %c\",&d[i][j]);\n      if(d[i][j]=='.'){\n\td[y[r]=i][x[r]=j]=0;\n\tr++;\n      }\n    }\n  }\n  for(i=0;r-rr;i++){\n    for(rr=r;rr-t;t++){\n      for(j=0;j<8;j++){\n\tny=y[t]+Y[j];\n\tnx=x[t]+X[j];\n\tif(d[ny][nx]==0)continue;\n\td[ny][nx]--;\n\tif(d[ny][nx]=='0'){\n\t  d[y[r]=ny][x[r]=nx]=0;\n\t  r++;\n\t}\n      }\n    }\n  }\n  printf(\"%d\\n\",i-1);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint h,w;\nint castle[1001][1001]={0};\nint castle_check[1001][1001]={0};\nint castledes[1001][1001]={0};\nint sand1[8]={0,0,1,1,1,-1,-1,-1};\nint sand2[8]={1,-1,0,1,-1,0,1,-1};\n\nchar num[]={\"0123456789\"};\nvoid check(int high,int low){\n\tint i,j,z;\n\tfor(i=1;i<high;i++){\n\t\tfor(j=1;j<low;j++){\n\t\t\tif(castle[i][j]>0&&castle[i][j]<=9){\n\t\t\t\tfor(z=0;z<8;z++){\n\t\t\t\t\tif(castle[i+sand1[z]][j+sand2[z]]==-1){\n\t\t\t\t\t\tcastle_check[i][j]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nvoid tukareta(int high,int low){\n\tint i,j,z;\n\tfor(i=1;i<high;i++){\n\t\tfor(j=1;j<low;j++){\n\t\t\tif(castledes[i][j]==1){\n\t\t\t\tfor(z=0;z<8;z++){\n\t\t\t\t\tif(castle[i+sand1[z]][j+sand2[z]]!=-1){\n\t\t\t\t\t\tcastle_check[i+sand1[z]][j+sand2[z]]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcastledes[i][j]=0;\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\tint i,j,r,ans=0,broke=0;\n\tchar a;\n\tscanf(\"%d%d\",&h,&w);\n\tfor(i=0;i<h;i++){\n\t\tgetchar();\n\t\tfor(j=0;j<w;j++){\n\t\t\ta=getchar();\n\t\t\tif(a=='.'){\n\t\t\t\tcastle[i][j]=-1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcastle[i][j]=a-'0';\n\t\t\t}\n\t\t}\n\t}\n\t\t\t\t/*for(i=0;i<h;i++){\n\t\t\t\tfor(j=0;j<w;j++){\n\t\t\t\t\tprintf(\"%2d\",castle[i][j]);\n\t\t\t\t}\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}*/\n\tcheck(h-1,w-1);\n\twhile(1){\n\t\tbroke=0;\n\t\tfor(int i=1;i<h-1;i++){\n\t\t\tfor(int j=1;j<w-1;j++){\n\t\t\t\tif(castle[i][j]<=9&&castle[i][j]>0){\n\t\t\t\t\tif(castle[i][j]<=castle_check[i][j]){\n\t\t\t\t\t\tcastle[i][j]=-1;\n\t\t\t\t\t\tbroke++;\n\t\t\t\t\t\tcastledes[i][j]=1;\n\t\t\t\t\t\tcastle_check[i][j]=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(broke==0){\n\t\t\tprintf(\"%d\\n\",ans);\n\t\t\tbreak;\n\t\t}\n\t\tans++;\n\t\ttukareta(h-1,w-1);\n\t\t\t/*for(i=0;i<h;i++){\n\t\t\t\tfor(j=0;j<w;j++){\n\t\t\t\t\tprintf(\"%2d\",castle[i][j]);\n\t\t\t\t}\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}*/\n\t}\n}\n\t\n"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 0612\n  Title:Sandcastle\n  @kankichi573\n*/\n#include <stdio.h>\n#include <string.h>\n\nint W,H;\nchar castle[1000][1001];\nchar castle2[1000][1001];\n\nint wave()\n{\n  int i,j,k,l,cnt,flag;\n\n  flag=0;\n  memcpy(castle2,castle,sizeof(castle));\n  for(i=1;i<H-1;i++)\n    for(j=1;j<W-1;j++)\n      {\n\tif(castle[i][j]!='.')\n\t  {\n\t    cnt=0;\n\t    for(k=-1;k<=1;k++)\n\t      for(l=-1;l<=1;l++)\n\t\tif(k||l)\n\t\t  cnt += (castle[i+k][j+l]=='.')?1:0;\n\t    if(cnt>=castle[i][j]-'0')\n\t      {\n\t\tcastle2[i][j]='.';\n\t\tflag=1;\n\t      }\n\t  }\n      }\n  memcpy(castle,castle2,sizeof(castle));\n  return(flag);\n}\n\nmain()\n{\n  int i,ret,broken;\n  \n\n  scanf(\"%d %d\",&H,&W);\n  for(i=0;i<H;i++)\n    scanf(\"%s\",&castle[i][0]);\n\n  for(ret=0;;ret++)\n    {\n      broken=wave();\n          if(broken==0)\n      break;\n    }\n  printf(\"%d\\n\",ret);\n  \n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n\nint h ,w ;\n\nint mx[] = { 1 ,1 ,1 ,-1 ,-1 ,-1 ,0 ,0 } ;\nint my[] = { 1 ,-1 ,0 ,1 ,-1 ,0 ,1 ,-1 } ;\n\n\nchar castle[ 1000 ][ 1000 ] ;\nchar castles[ 1000 ][ 1000 ] ;\n\nchar sand[ 1000 ][ 1000 ] ;\n\n\nint dead ;\n\nchar del[ 999 * 999 ][ 2 ] ;\nint DEL ;\n\n#define x j + mx[ k ]\n#define y i + my[ k ]\n\n#define dy [ 0 ]\n#define dx [ 1 ]\n\n\nvoid make9( int i ,int j )\n{\n\tint k ;\n\tfor( k = 0 ; k < 8 ; ++k )\n\t{\n\t\tint kale = castle[ y ][ x ] ;\n\n\t\tif( kale < 9 && kale > -1 )\n\t\t{\n\t\t\t++castle[ y ][ x ] ;\n\n\t\t\tif( castle[ y ][ x ] == 9 )\n\t\t\t{\n\t\t\t\tmake9( y ,x ) ;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid look9( int H ,int W )\n{\n\tint i ,j ;\n\tfor( i = 1 ; i < H ; ++i )\n\t{\n\t\tfor( j = 1 ; j < W ; ++j )\n\t\t{\n\t\t\tif( castle[ i ][ j ] == 9 )\n\t\t\t{\n\t\t\t\tmake9( i ,j ) ;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nvoid input_del( int i ,int j )\n{\n\tint minus = 0 ;\n\n\tint k ;\n\tfor( k = 0 ; k < 8 ; ++k )\n\t{\n\t\tminus += castles[ y ][ x ] ;\n\t}\n\n\tif( castle[ i ][ j ] <= -minus )\n\t{\n\t\tcastle[ i ][ j ] = 0 ;\n\n\t\tdel[ DEL ] dy = i ;\n\t\tdel[ DEL ] dx = j ;\n\n\t\t++DEL ;\n\t}\n}\n\nvoid undo( int H ,int W )\n{\n\tint i ,j ;\n\tfor( i = 1 ; i < H ; ++i )\n\t{\n\t\tfor( j = 1 ; j < W ; ++j )\n\t\t{\n\t\t\tif( castle[ i ][ j ] < 9 )\n\t\t\t{\n\t\t\t\tcastle[ i ][ j ] = castles[ i ][ j ] ;\n\t\t\t}\n\n\t\t\tif( castle[ i ][ j ] > 0 )\n\t\t\t{\n\t\t\t\tcastles[ i ][ j ] = 0 ;\n\n\t\t\t\tif( castle[ i ][ j ] == 9 )\n\t\t\t\t{\n\t\t\t\t\t--dead ;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid update( int i ,int j )\n{\n\t--dead ;\n\n\tcastles[ i ][ j ] = -1 ;\n\n\tint k ;\n\tfor( k = 0 ; k < 8 ; ++k )\n\t{\n\t\tif( castle[ y ][ x ] < 9 && castle[ y ][ x ] > 0 )\n\t\t{\n\t\t\tinput_del( y ,x ) ;\n\t\t}\n\t}\n}\n\n\n//\tcastle checker\n/*\nvoid check( int i = 0 ,int j = 0 )\n{\n\tputs( \"\" ) ;\n\n\twhile( i < h )\n\t{\n\t\twhile( j < w )\n\t\t{\n\t\t\tprintf( \"%2d\" ,castle[ i ][ j++ ] ) ;\n\t\t}\n\n\t\t++i ; j = 0 ;\n\n\t\tputs( \"\" ) ;\n\t}\n\n\tputs( \"\" ) ;\n}\n*/\n\n//\tcastles checker\n/*\nvoid checks( int i = 0 ,int j = 0 )\n{\n\tputs( \"\" ) ;\n\n\twhile( i < h )\n\t{\n\t\twhile( j < w )\n\t\t{\n\t\t\tprintf( \"%2d\" ,castles[ i ][ j++ ] ) ;\n\t\t}\n\n\t\t++i ; j = 0 ;\n\n\t\tputs( \"\" ) ;\n\t}\n\n\tputs( \"\" ) ;\n}\n*/\n\nint main()\n{\n\tscanf( \"%d %d\" ,&h ,&w ) ;\n\n\tint i ,j ;\n\tfor( i = 0 ; i < h ; ++i )\n\t{\n\t\tgetchar() ;\n\n\t\tfor( j = 0 ; j < w ; ++j )\n\t\t{\n\t\t\tchar c = getchar() ;\n\n\t\t\tif( c == '.' )\n\t\t\t{\n\t\t\t\tcastles[ i ][ j ] = castle[ i ][ j ] = -1 ;\n\t\t\t}\n\n\t\t\telse\n\t\t\t{\n\t\t\t\t++dead ;\n\n\t\t\t\tcastles[ i ][ j ] = castle[ i ][ j ] = c - '0' ;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tlook9( h - 1 ,w - 1 ) ;\n\n\tundo( h - 1 ,w - 1 ) ;\n\n\n\tfor( i = 1 ; i < h - 1 ; ++i )\n\t{\n\t\tfor( j = 1 ; j < w - 1 ; ++j )\n\t\t{\n\t\t\tif( castle[ i ][ j ] > 0 && castle[ i ][ j ] < 9 )\n\t\t\t{\n\t\t\t\tinput_del( i ,j ) ;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tint ans = 0 ;\n\n\tint next_del = 0 ;\n\n\twhile( dead )\n\t{\n\t\t++ans ;\n\t\t\n\t\tint limit = DEL ;\n\t\tfor( i = next_del ,next_del = limit ; i < limit ; ++i )\n\t\t{\n\t\t\tif( del[ i ] dy > 0 )\n\t\t\t{\n\t\t\t\tupdate( del[ i ] dy ,del[ i ] dx ) ;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf( \"%d\\n\" ,ans ) ;\n\t\n\treturn 0 ;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int w,h,i,j,a,k,f=1,c;\n  char d[51][51];\n  int X[]={0,1,1,1,0,-1,-1,-1};\n  int Y[]={1,1,0,-1,-1,-1,0,1};\n  scanf(\"%d %d\",&h,&w);\n  for(i=0;i<h;i++)scanf(\"%s\",d[i]);\n  for(a=-1;f;a++){\n    f=0;\n    for(i=1;i<h-1;i++){\n      for(j=1;j<w-1;j++){\n\tif(d[i][j]=='.')continue;\n\tfor(k=c=0;k<8;k++){\n\t  if(d[i+Y[k]][j+X[k]]=='.')c++;\n\t}\n\tif(d[i][j]-'0'<=c){\n\t  d[i][j]='0';\n\t  f=1;\n\t}\n      }\n    }\n    for(i=1;i<h-1;i++){\n      for(j=1;j<w-1;j++){\n\tif(d[i][j]=='0')d[i][j]='.';//printf(\"%c\",d[i][j]);\n      }//printf(\"\\n\");\n    }//printf(\"\\n\");\n  }\n  printf(\"%d\\n\",a);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n\nint search(char **map, char **before,int h, int w)\n{\n\tint castle_num = map[h][w] - '0';\n\n\tint i, j;\n\tint sara = 0;\n\tfor (i = h - 1; i <= h + 1; i++)\n\t{\n\t\tfor (j = w - 1; j <= w + 1; j++)\n\t\t{\n\t\t\tif (map[i][j]=='.')sara++;\n\t\t}\n\t}\n\n\tif (castle_num <= sara)\n\t{\n\t\tbefore[h][w] = '.';\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n\nint main()\n{\n\tint H, W;\n\tint i, j;\n\tint wave_count = 0;\n\tint wave_flag = -1;\n\n\tchar **castle;\n\tchar **before;\n\n\tscanf(\"%d %d\", &H, &W);\n\tcastle = (char **)malloc(sizeof(char *)*H);\n\tbefore = (char **)malloc(sizeof(char *)*H);\n\n\tfor (i = 0; i < W; i++)\n\t{\n\t\tcastle[i] = (char *)malloc(sizeof(char)*(W));\n\t\tbefore[i] = (char *)malloc(sizeof(char)*(W));\n\t}\n\tfor (i = 0; i<H; i++)\n\t{\n\t\tfor (j = 0; j < W; j++)\n\t\t{\n\t\t\tscanf(\" %c\", &castle[i][j]);\n\t\t}\n\t}\n\tfor (i = 0; i < H; i++)\n\t\tstrcpy(before[i], castle[i]);\n\n\t//?????????\n\twhile (1)\n\t{\n\t\twave_flag = 0;\n\t\tfor (i = 0; i<H; i++)\n\t\t{\n\t\t\tfor (j = 0; j<W; j++)\n\t\t\t{\n\t\t\t\tif (castle[i][j] != '.')\n\t\t\t\t{\n\t\t\t\t\tif (search(castle,before,i, j) == 1)wave_flag++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (wave_flag != 0)\n\t\t{\n\t\t\twave_count++;\n\t\t\tfor (i = 0; i < H; i++)\n\t\t\t\tstrcpy(castle[i], before[i]);\n\t\t}\n\t\telse{ break; }\n\t}\n\n\tprintf(\"%d\\n\", wave_count);\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n\nint h ,w ;\n\nint mx[] = { 1 ,1 ,1 ,-1 ,-1 ,-1 ,0 ,0 } ;\nint my[] = { 1 ,-1 ,0 ,1 ,-1 ,0 ,1 ,-1 } ;\n\n\nchar castle[ 1000 ][ 1000 ] ;\nchar castles[ 1000 ][ 1000 ] ;\n\nchar sand[ 1000 ][ 1000 ] ;\n\n\nint dead ;\n\nchar del[ 999 * 999 ][ 2 ] ;\nint DEL ;\n\n#define x j + mx[ k ]\n#define y i + my[ k ]\n\n#define dy [ 0 ]\n#define dx [ 1 ]\n\n\nvoid make9( int i ,int j )\n{\n\tint k ;\n\tfor( k = 0 ; k < 8 ; ++k )\n\t{\n\t\tint kale = castle[ y ][ x ] ;\n\n\t\tif( kale < 9 && kale > -1 )\n\t\t{\n\t\t\t++castle[ y ][ x ] ;\n\n\t\t\tif( castle[ y ][ x ] == 9 )\n\t\t\t{\n\t\t\t\tmake9( y ,x ) ;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid look9( int H ,int W )\n{\n\tint i ,j ;\n\tfor( i = 1 ; i < H ; ++i )\n\t{\n\t\tfor( j = 1 ; j < W ; ++j )\n\t\t{\n\t\t\tif( castle[ i ][ j ] == 9 )\n\t\t\t{\n\t\t\t\tmake9( i ,j ) ;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nvoid input_del( int i ,int j )\n{\n\tint minus = 0 ;\n\n\tint k ;\n\tfor( k = 0 ; k < 8 ; ++k )\n\t{\n\t\tminus += castles[ y ][ x ] ;\n\t}\n\n\tif( castle[ i ][ j ] <= -minus )\n\t{\n\t\tcastle[ i ][ j ] = 0 ;\n\n\t\tdel[ DEL ] dy = i ;\n\t\tdel[ DEL ] dx = j ;\n\n\t\t++DEL ;\n\t}\n}\n\nvoid undo( int H ,int W )\n{\n\tint i ,j ;\n\tfor( i = 1 ; i < H ; ++i )\n\t{\n\t\tfor( j = 1 ; j < W ; ++j )\n\t\t{\n\t\t\tif( castle[ i ][ j ] < 9 )\n\t\t\t{\n\t\t\t\tcastle[ i ][ j ] = castles[ i ][ j ] ;\n\t\t\t}\n\n\t\t\tif( castle[ i ][ j ] > 0 )\n\t\t\t{\n\t\t\t\tcastles[ i ][ j ] = 0 ;\n\n\t\t\t\tif( castle[ i ][ j ] == 9 )\n\t\t\t\t{\n\t\t\t\t\t--dead ;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid update( int i ,int j )\n{\n\t--dead ;\n\n\tcastles[ i ][ j ] = -1 ;\n\n\tint k ;\n\tfor( k = 0 ; k < 8 ; ++k )\n\t{\n\t\tif( castle[ y ][ x ] < 9 && castle[ y ][ x ] > 0 )\n\t\t{\n\t\t\tinput_del( y ,x ) ;\n\t\t}\n\t}\n}\n\n\n//\tcastle checker\n/*\nvoid check( int i = 0 ,int j = 0 )\n{\n\tputs( \"\" ) ;\n\n\twhile( i < h )\n\t{\n\t\twhile( j < w )\n\t\t{\n\t\t\tprintf( \"%2d\" ,castle[ i ][ j++ ] ) ;\n\t\t}\n\n\t\t++i ; j = 0 ;\n\n\t\tputs( \"\" ) ;\n\t}\n\n\tputs( \"\" ) ;\n}\n*/\n\n//\tcastles checker\n/*\nvoid checks( int i = 0 ,int j = 0 )\n{\n\tputs( \"\" ) ;\n\n\twhile( i < h )\n\t{\n\t\twhile( j < w )\n\t\t{\n\t\t\tprintf( \"%2d\" ,castles[ i ][ j++ ] ) ;\n\t\t}\n\n\t\t++i ; j = 0 ;\n\n\t\tputs( \"\" ) ;\n\t}\n\n\tputs( \"\" ) ;\n}\n*/\n\nint main()\n{\n\tscanf( \"%d %d\" ,&h ,&w ) ;\n\n\tint i ,j ;\n\tfor( i = 0 ; i < h ; ++i )\n\t{\n\t\tgetchar() ;\n\n\t\tfor( j = 0 ; j < w ; ++j )\n\t\t{\n\t\t\tchar c = getchar() ;\n\n\t\t\tif( c == '.' )\n\t\t\t{\n\t\t\t\tcastles[ i ][ j ] = castle[ i ][ j ] = -1 ;\n\t\t\t}\n\n\t\t\telse\n\t\t\t{\n\t\t\t\t++dead ;\n\n\t\t\t\tcastles[ i ][ j ] = castle[ i ][ j ] = c - '0' ;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tlook9( h - 1 ,w - 1 ) ;\n\n\tundo( h - 1 ,w - 1 ) ;\n\n\n\tfor( i = 1 ; i < h - 1 ; ++i )\n\t{\n\t\tfor( j = 1 ; j < w - 1 ; ++j )\n\t\t{\n\t\t\tif( castle[ i ][ j ] > 0 && castle[ i ][ j ] < 9 )\n\t\t\t{\n\t\t\t\tinput_del( i ,j ) ;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tint limit = 0 ;\n\n\tint ans = 0 ;\n\n\tint next_del = 0 ;\n\n\twhile( dead )\n\t{\n\t\t++ans ;\n\t\t\n\t\tif( limit == DEL )\n\t\t\tbreak ;\n\n\t\tlimit = DEL ;\n\t\tfor( i = next_del ,next_del = limit ; i < limit ; ++i )\n\t\t{\n\t\t\tif( del[ i ] dy > 0 )\n\t\t\t{\n\t\t\t\tupdate( del[ i ] dy ,del[ i ] dx ) ;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf( \"%d\\n\" ,ans ) ;\n\t\n\treturn 0 ;\n}"
  },
  {
    "language": "C",
    "code": "\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n\nint search(char map[1000][1000], char before[1000][1000],int h, int w)\n{\n\tint castle_num = map[h][w] - '0';\n\n\tint i, j;\n\tint sara = 0;\n\tfor (i = h - 1; i <= h + 1; i++)\n\t{\n\t\tfor (j = w - 1; j <= w + 1; j++)\n\t\t{\n\t\t\tif (map[i][j]=='.')sara++;\n\t\t}\n\t}\n\n\tif (castle_num <= sara)\n\t{\n\t\tbefore[h][w] = '.';\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n\nint main()\n{\n\tint H, W;\n\tint i, j;\n\tint wave_count = 0;\n\tint wave_flag = -1;\n\n\tchar castle[1000][1000];\n\tchar before[1000][1000];\n\n\tscanf(\"%d %d\", &H, &W);\n\t\n\tfor (i = 0; i<H; i++)\n\t{\n\t\tfor (j = 0; j < W; j++)\n\t\t{\n\t\t\tscanf(\" %c\", &castle[i][j]);\n\t\t}\n\t}\n\t\n\tfor (i = 0; i < H; i++)\n\t\tstrcpy(before[i], castle[i]);\n\n\t//?????????\n\twhile (1)\n\t{\n\t\twave_flag = 0;\n\t\tfor (i = 0; i<H; i++)\n\t\t{\n\t\t\tfor (j = 0; j<W; j++)\n\t\t\t{\n\t\t\t\tif (castle[i][j] != '.')\n\t\t\t\t{\n\t\t\t\t\tif (search(castle,before,i, j) == 1)wave_flag++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i<H; i++)\n\t\t{\n\t\t\tfor (j = 0; j<W; j++)\n\t\t\t{\n\t\t\t\tprintf(\"%c\", castle[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\n\t\tif (wave_flag != 0)\n\t\t{\n\t\t\twave_count++;\n\t\t\tfor (i = 0; i < H; i++)\n\t\t\t\tstrcpy(castle[i], before[i]);\n\t\t}\n\t\telse{ break; }\n\t}\n\n\tprintf(\"%d\\n\", wave_count);\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\nint map[50][50];\nint H, W;\nint sum = 0;\n\nvoid d(int sh, int sw, int h, int w)\n{\n  int i, j, k, f = -1;\n  int mh[49], mw[49];\n  for (i = sh; i < h; i++){\n    for (j = sw; j < w; j++){\n      if (map[i][j] != 0){\n        k = 0;\n        k += (map[i + 1][j - 1] == 0) ? 1 : 0;\n        k += (map[i + 1][j] == 0) ? 1 : 0;\n        k += (map[i + 1][j + 1] == 0) ? 1 : 0;\n        k += (map[i][j - 1]) == 0 ? 1 : 0;\n        k += (map[i][j + 1] == 0) ? 1 : 0;\n        k += (map[i - 1][j - 1] == 0) ? 1 : 0;\n        k += (map[i - 1][j] == 0) ? 1 : 0;\n        k += (map[i - 1][j + 1] == 0) ? 1 : 0;\n        if (map[i][j] <= k){\n          f++;\n          mh[f] = i;\n          mw[f] = j;\n        }\n      }\n    }\n  }\n  for (k = 0; k < f + 1; k++){\n    map[mh[k]][mw[k]] = 0;\n  }\n  for (k = 0; k < f + 1; k++){\n    for (i = -1; i <= 1; i++){\n      for (j = -1; j <= 1; j++){\n        if (map[mh[k] + i][mw[k] + j] != 0){\n          d(mh[k] + i, mw[k] + j, mh[k] + i + 1, mw[k] + j + 1);\n        }\n      }\n    }\n    if (f >= 0) sum++;\n  }\n}\n\nint main(void)\n{\n  int i, j;\n  char c;\n  scanf(\"%d %d \", &H, &W);\n  for (i = 0; i < H; i++){\n    for (j = 0; j < W; j++){\n      if (j == W - 1) scanf(\"%c%*c\", &c);\n      else scanf(\"%c\", &c);\n      if (c == '.') map[i][j] = 0;\n      else map[i][j] = c - 0x30;\n    }\n  }\n  d(1, 1, H - 1, W - 1);\n  printf(\"%d\\n\", sum);\n  return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint h,w;\nint castle[1001][1001]={0};\nint castle_check[1001][1001]={0};\nint castledes[1001][1001]={0};\nint sand1[8]={0,0,1,1,1,-1,-1,-1};\nint sand2[8]={1,-1,0,1,-1,0,1,-1};\n\nchar num[]={\"0123456789\"};\nvoid check(int high,int low){\n\tint i,j,z;\n\tfor(i=1;i<high;i++){\n\t\tfor(j=1;j<low;j++){\n\t\t\tif(castle[i][j]>0&&castle[i][j]<=9){\n\t\t\t\tfor(z=0;z<8;z++){\n\t\t\t\t\tif(castle[i+sand1[z]][j+sand2[z]]==-1){\n\t\t\t\t\t\tcastle_check[i][j]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nvoid tukareta(int high,int low){\n\tint i,j,z;\n\tfor(i=1;i<high;i++){\n\t\tfor(j=1;j<low;j++){\n\t\t\tif(castledes[i][j]==1){\n\t\t\t\tfor(z=0;z<8;z++){\n\t\t\t\t\tif(castle[i+sand1[z]][j+sand2[z]]!=-1){\n\t\t\t\t\t\tcastle_check[i+sand1[z]][j+sand2[z]]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcastledes[i][j]=0;\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\tint i,j,r,ans=0,broke=0;\n\tchar a;\n\tscanf(\"%d%d\",&h,&w);\n\tfor(i=0;i<h;i++){\n\t\tgetchar();\n\t\tfor(j=0;j<w;j++){\n\t\t\ta=getchar();\n\t\t\tif(a=='.'){\n\t\t\t\tcastle[i][j]=-1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcastle[i][j]=a-'0';\n\t\t\t}\n\t\t}\n\t}\n\t\t\t\tfor(i=0;i<h;i++){\n\t\t\t\tfor(j=0;j<w;j++){\n\t\t\t\t\tprintf(\"%2d\",castle[i][j]);\n\t\t\t\t}\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\tcheck(h-1,w-1);\n\twhile(1){\n\t\tbroke=0;\n\t\tfor(int i=1;i<h-1;i++){\n\t\t\tfor(int j=1;j<w-1;j++){\n\t\t\t\tif(castle[i][j]<=9&&castle[i][j]>0){\n\t\t\t\t\tif(castle[i][j]<=castle_check[i][j]){\n\t\t\t\t\t\tcastle[i][j]=-1;\n\t\t\t\t\t\tbroke++;\n\t\t\t\t\t\tcastledes[i][j]=1;\n\t\t\t\t\t\tcastle_check[i][j]=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(broke==0){\n\t\t\tprintf(\"%d\\n\",ans);\n\t\t\tbreak;\n\t\t}\n\t\tans++;\n\t\ttukareta(h-1,w-1);\n\t\t\t/*for(i=0;i<h;i++){\n\t\t\t\tfor(j=0;j<w;j++){\n\t\t\t\t\tprintf(\"%2d\",castle[i][j]);\n\t\t\t\t}\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}*/\n\t}\n}\n\t\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\nint st,map1[2000];\nchar map[1002][1002];\nvoid snake(int x,int y){\n    if(map[y][x+1]=='.')\n        st++;\n    if(map[y+1][x]=='.')\n        st++;\n    if(map[y][x-1]=='.')\n        st++;\n    if(map[y-1][x]=='.')\n        st++;\n    if(map[y-1][x+1]=='.')\n        st++;\n    if(map[y+1][x+1]=='.')\n        st++;\n    if(map[y+1][x-1]=='.')\n        st++;\n    if(map[y-1][x-1]=='.')\n        st++;\n}\nint main(void){\n    int h,w,sign=1,sum=-1,i,t=0,o,p;\n    scanf(\"%d %d\",&h,&w);\n    p=getchar();\n    for(i=1;i<=h;i++){\n        for(o=1;o<=w;o++){\n            map[i][o]=getchar();\n        }\n        p=getchar();\n    }\n    while(t=0,sign){\n        sign=0;\n        for(i=1;i<=h;i++){\n            for(o=1;o<=w;o++){\n                if(st=0,map[i][o] != '.' && map[i][o] < '9'){\n                    snake(o,i);\n                    if(map[i][o]-48<=st){\n                        sign=1;\n                        map1[t++]=i;\n                        map1[t++]=o;\n                    }\n                }\n            }\n        }\n        for(p=0;p<t;p+=2)\n            map[map1[p]][map1[p+1]]='.';\n        sum++;\n    }\n    printf(\"%d\\n\",sum);\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n\nint h ,w ;\n\nint mx[] = { 1 ,1 ,1 ,-1 ,-1 ,-1 ,0 ,0 } ;\nint my[] = { 1 ,-1 ,0 ,1 ,-1 ,0 ,1 ,-1 } ;\n\n\nchar castle[ 1000 ][ 1000 ] ;\nchar castles[ 1000 ][ 1000 ] ;\n\nchar sand[ 1000 ][ 1000 ] ;\n\n\nint del[ 999 * 999 ][ 2 ] ;\nint DEL ;\n\n#define x j + mx[ k ]\n#define y i + my[ k ]\n\n#define dy [ 0 ]\n#define dx [ 1 ]\n\n\nvoid make9( int i ,int j )\n{\n\tint k ;\n\tfor( k = 0 ; k < 8 ; ++k )\n\t{\n\t\tint kale = castle[ y ][ x ] ;\n\n\t\tif( kale < 9 && kale > -1 )\n\t\t{\n\t\t\t++castle[ y ][ x ] ;\n\n\n\t\t\tif( castle[ y ][ x ] == 9 )\n\t\t\t{\n\t\t\t\tmake9( y ,x ) ;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid look9( int H ,int W )\n{\n\tint i ,j ;\n\tfor( i = 1 ; i < H ; ++i )\n\t{\n\t\tfor( j = 1 ; j < W ; ++j )\n\t\t{\n\t\t\tif( castle[ i ][ j ] == 9 )\n\t\t\t{\n\t\t\t\tmake9( i ,j ) ;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nvoid input_del( int i ,int j )\n{\n\tint minus = 0 ;\n\n\tint k ;\n\tfor( k = 0 ; k < 8 ; ++k )\n\t{\n\t\tminus += castles[ y ][ x ] ;\n\t}\n\n\tif( castle[ i ][ j ] <= -minus )\n\t{\n\t\tcastle[ i ][ j ] = -1 ;\n\n\t\tdel[ DEL ] dy = i ;\n\t\tdel[ DEL ] dx = j ;\n\n\t\t++DEL ;\n\t}\n}\n\nvoid undo( int H ,int W )\n{\n\tint i ,j ;\n\tfor( i = 1 ; i < H ; ++i )\n\t{\n\t\tfor( j = 1 ; j < W ; ++j )\n\t\t{\n\t\t\tif( castle[ i ][ j ] < 9 )\n\t\t\t{\n\t\t\t\tcastle[ i ][ j ] = castles[ i ][ j ] ;\n\t\t\t}\n\t\t\t\n\t\t\tif( castle[ i ][ j ] > -1 )\n\t\t\t{\n\t\t\t\tcastles[ i ][ j ] = 0 ;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid update( int i ,int j )\n{\n\tcastles[ i ][ j ] = -1 ;\n\n\tint k ;\n\tfor( k = 0 ; k < 8 ; ++k )\n\t{\n\t\tif( castle[ y ][ x ] < 9 && castle[ y ][ x ] > -1 )\n\t\t{\n\t\t\tinput_del( y ,x ) ;\n\t\t}\n\t}\n}\n\n\nint main()\n{\n\tscanf( \"%d %d\" ,&h ,&w ) ;\n\t\n\tint i ,j ;\n\tfor( i = 0 ; i < h ; ++i )\n\t{\n\t\tgetchar() ;\n\n\t\tfor( j = 0 ; j < w ; ++j )\n\t\t{\n\t\t\tchar c = getchar() ;\n\n\t\t\tif( c == '.' )\n\t\t\t{\n\t\t\t\tcastles[ i ][ j ] = castle[ i ][ j ] = -1 ;\n\t\t\t}\n\n\t\t\telse\n\t\t\t{\n\t\t\t\tcastles[ i ][ j ] = castle[ i ][ j ] = c - '0' ;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tlook9( h - 1 ,w - 1 ) ;\n\n\tundo( h - 1 ,w - 1 ) ;\n\n\tfor( i = 1 ; i < h - 1 ; ++i )\n\t{\n\t\tfor( j = 1 ; j < w - 1 ; ++j )\n\t\t{\n\t\t\tif( castle[ i ][ j ] > -1 && castle[ i ][ j ] < 9 )\n\t\t\t{\n\t\t\t\tinput_del( i ,j ) ;\n\t\t\t}\n\t\t}\n\t}\n\n\tint limit = 0 ;\n\n\tint ans = 0 ;\n\n\tint next_del = 0 ;\n\n\twhile( limit != DEL )\n\t{\n\n\t\t++ans ;\n\n\t\tlimit = DEL ;\n\t\tfor( i = next_del ,next_del = limit ; i < limit ; ++i )\n\t\t{\n\t\t\tif( del[ i ] dy > 0 )\n\t\t\t{\n\t\t\t\tupdate( del[ i ] dy ,del[ i ] dx ) ;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf( \"%d\\n\" ,ans ) ;\n\n\treturn 0 ;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\nint map[50][50];\nint H, W;\nint sum = 0;\n\nvoid d(int sh, int sw, int h, int w)\n{\n  int i, j, k, f = -1;\n  int mh[49], mw[49];\n  for (i = sh; i < h; i++){\n    for (j = sw; j < w; j++){\n      if (map[i][j] != 0){\n        k = 0;\n        k += (map[i + 1][j - 1] == 0) ? 1 : 0;\n        k += (map[i + 1][j] == 0) ? 1 : 0;\n        k += (map[i + 1][j + 1] == 0) ? 1 : 0;\n        k += (map[i][j - 1]) == 0 ? 1 : 0;\n        k += (map[i][j + 1] == 0) ? 1 : 0;\n        k += (map[i - 1][j - 1] == 0) ? 1 : 0;\n        k += (map[i - 1][j] == 0) ? 1 : 0;\n        k += (map[i - 1][j + 1] == 0) ? 1 : 0;\n        if (map[i][j] <= k){\n          f++;\n          mh[f] = i;\n          mw[f] = j;\n        }\n      }\n    }\n  }\n  for (k = 0; k < f + 1; k++){\n    map[mh[k]][mw[k]] = 0;\n  }\n  for (k = 0; k < f + 1; k++){\n    for (i = -1; i <= 1; i++){\n      for (j = -1; j <= 1; j++){\n        if (map[mh[k] + i][mw[k] + j] != 0){\n          d(mh[k] + i, mw[k] + j, mh[k] + i + 1, mw[k] + j + 1);\n        }\n      }\n    }\n  }\n  if (f >= 0) sum++;\n}\n\nint main(void)\n{\n  int i, j;\n  char c;\n  scanf(\"%d %d \", &H, &W);\n  for (i = 0; i < H; i++){\n    for (j = 0; j < W; j++){\n      if (j == W - 1) scanf(\"%c%*c\", &c);\n      else scanf(\"%c\", &c);\n      if (c == '.') map[i][j] = 0;\n      else map[i][j] = c - 0x30;\n    }\n  }\n  d(1, 1, H - 1, W - 1);\n  printf(\"%d\\n\", sum);\n  return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <ctype.h>\n\nint H, W;\nchar map[1024][1024];\nchar mark0[1024][1024];\nchar mark1[1024][1024];\nint target0[1024 * 1024][2];\nint target1[1024 * 1024][2];\nint houkai[1024 * 1024][2];\n\nint houkaisuru(int y, int x) {\n\tint count = 0;\n\tint i, j;\n\tif (map[y][x] <= 0) return 0;\n\tfor (i = -1; i <= 1; i++) {\n\t\tfor (j = -1; j <= 1; j++) {\n\t\t\tif (i == 0 && j == 0) continue;\n\t\t\tif (map[y + i][x + j] == 0) count++;\n\t\t}\n\t}\n\treturn map[y][x] <= count;\n}\n\nint main(void) {\n\tint i, j, k;\n\tint count = 0;\n\tint (*current_target)[2] = target0, ct_num = 0;\n\tint (*next_target)[2] = target1, nt_num = 0;\n\tchar (*current_mark)[1024] = mark0;\n\tchar (*next_mark)[1024] = mark1;\n\tint (*target_temp)[2];\n\tchar (*mark_temp)[1024];\n\tint houkai_num = 0;\n\tif (scanf(\"%d%d\", &H, &W) != 2) return 1;\n\tfor (i = 0; i < H; i++) {\n\t\tif (scanf(\"%1023s\", map[i]) != 1) return 1;\n\t\tfor (j = 0; j < W; j++) {\n\t\t\tif (isdigit((unsigned char)map[i][j])) {\n\t\t\t\tmap[i][j] -= '0';\n\t\t\t} else {\n\t\t\t\tmap[i][j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 1; i < H - 1; i++) {\n\t\tfor (j = 1; j < W - 1; j++) {\n\t\t\tcurrent_target[ct_num][0] = i;\n\t\t\tcurrent_target[ct_num][1] = j;\n\t\t\tct_num++;\n\t\t}\n\t}\n\tfor (;;) {\n\t\tnt_num = 0;\n\t\thoukai_num = 0;\n\t\tfor (i = 0; i < ct_num; i++) {\n\t\t\tint y = current_target[i][0];\n\t\t\tint x = current_target[i][1];\n\t\t\tcurrent_mark[y][x] = 0;\n\t\t\tif (houkaisuru(y, x)) {\n\t\t\t\thoukai[houkai_num][0] = y;\n\t\t\t\thoukai[houkai_num][1] = x;\n\t\t\t\thoukai_num++;\n\t\t\t\tfor (j = -1; j <= 1; j++) {\n\t\t\t\t\tfor (k = -1; k <= 1; k++) {\n\t\t\t\t\t\tif (j == 0 && k == 0) continue;\n\t\t\t\t\t\tif (next_mark[y + j][x + k] == 0) {\n\t\t\t\t\t\t\tnext_mark[y + j][x + k] = 1;\n\t\t\t\t\t\t\tnext_target[nt_num][0] = y + j;\n\t\t\t\t\t\t\tnext_target[nt_num][1] = x + k;\n\t\t\t\t\t\t\tnt_num++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (houkai_num == 0) break;\n\t\tcount++;\n\t\tfor (i = 0; i < houkai_num; i++) {\n\t\t\tmap[houkai[i][0]][houkai[i][1]] = 0;\n\t\t}\n\t\tct_num = nt_num;\n\t\ttarget_temp = current_target;\n\t\tcurrent_target = next_target;\n\t\tnext_target = target_temp;\n\t\tmark_temp = current_mark;\n\t\tcurrent_mark = next_mark;\n\t\tnext_mark = mark_temp;\n\t}\n\tprintf(\"%d\\n\", count);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n\nint h ,w ;\n\nint mx[] = { 1 ,1 ,1 ,-1 ,-1 ,-1 ,0 ,0 } ;\nint my[] = { 1 ,-1 ,0 ,1 ,-1 ,0 ,1 ,-1 } ;\n\n\nchar castle[ 1000 ][ 1000 ] ;\nchar castles[ 1000 ][ 1000 ] ;\n\nchar sand[ 1000 ][ 1000 ] ;\n\n\nint dead ;\n\nchar del[ 999 * 999 ][ 2 ] ;\nint DEL ;\n\n#define x j + mx[ k ]\n#define y i + my[ k ]\n\n#define dy [ 0 ]\n#define dx [ 1 ]\n\n\nvoid make9( int i ,int j )\n{\n\tint k ;\n\tfor( k = 0 ; k < 8 ; ++k )\n\t{\n\t\tint kale = castle[ y ][ x ] ;\n\n\t\tif( kale < 9 && kale > -1 )\n\t\t{\n\t\t\t++castle[ y ][ x ] ;\n\n\t\t\tif( castle[ y ][ x ] == 9 )\n\t\t\t{\n\t\t\t\tmake9( y ,x ) ;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid look9( int H ,int W )\n{\n\tint i ,j ;\n\tfor( i = 1 ; i < H ; ++i )\n\t{\n\t\tfor( j = 1 ; j < W ; ++j )\n\t\t{\n\t\t\tif( castle[ i ][ j ] == 9 )\n\t\t\t{\n\t\t\t\tmake9( i ,j ) ;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nvoid input_del( int i ,int j )\n{\n\tint minus = 0 ;\n\n\tint k ;\n\tfor( k = 0 ; k < 8 ; ++k )\n\t{\n\t\tminus += castles[ y ][ x ] ;\n\t}\n\n\tif( castle[ i ][ j ] <= -minus )\n\t{\n\t\tcastle[ i ][ j ] = 0 ;\n\n\t\tdel[ DEL ] dy = i ;\n\t\tdel[ DEL ] dx = j ;\n\n\t\t++DEL ;\n\t}\n}\n\nvoid undo( int H ,int W )\n{\n\tint i ,j ;\n\tfor( i = 1 ; i < H ; ++i )\n\t{\n\t\tfor( j = 1 ; j < W ; ++j )\n\t\t{\n\t\t\tif( castle[ i ][ j ] < 9 )\n\t\t\t{\n\t\t\t\tcastle[ i ][ j ] = castles[ i ][ j ] ;\n\t\t\t}\n\n\t\t\tif( castle[ i ][ j ] > 0 )\n\t\t\t{\n\t\t\t\tcastles[ i ][ j ] = 0 ;\n\n\t\t\t\tif( castle[ i ][ j ] == 9 )\n\t\t\t\t{\n\t\t\t\t\t--dead ;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid update( int i ,int j )\n{\n\t--dead ;\n\n\tcastles[ i ][ j ] = -1 ;\n\n\tint k ;\n\tfor( k = 0 ; k < 8 ; ++k )\n\t{\n\t\tif( castle[ y ][ x ] < 9 && castle[ y ][ x ] > 0 )\n\t\t{\n\t\t\tinput_del( y ,x ) ;\n\t\t}\n\t}\n}\n\n\n//\tcastle checker\nvoid check( int i = 0 ,int j = 0 )\n{\n\tputs( \"\" ) ;\n\n\twhile( i < h )\n\t{\n\t\twhile( j < w )\n\t\t{\n\t\t\tprintf( \"%2d\" ,castle[ i ][ j++ ] ) ;\n\t\t}\n\n\t\t++i ; j = 0 ;\n\n\t\tputs( \"\" ) ;\n\t}\n\n\tputs( \"\" ) ;\n}\n\n//\tcastles checker\nvoid checks( int i = 0 ,int j = 0 )\n{\n\tputs( \"\" ) ;\n\n\twhile( i < h )\n\t{\n\t\twhile( j < w )\n\t\t{\n\t\t\tprintf( \"%2d\" ,castles[ i ][ j++ ] ) ;\n\t\t}\n\n\t\t++i ; j = 0 ;\n\n\t\tputs( \"\" ) ;\n\t}\n\n\tputs( \"\" ) ;\n}\n\n\nint main()\n{\n\tscanf( \"%d %d\" ,&h ,&w ) ;\n\n\tint i ,j ;\n\tfor( i = 0 ; i < h ; ++i )\n\t{\n\t\tgetchar() ;\n\n\t\tfor( j = 0 ; j < w ; ++j )\n\t\t{\n\t\t\tchar c = getchar() ;\n\n\t\t\tif( c == '.' )\n\t\t\t{\n\t\t\t\tcastles[ i ][ j ] = castle[ i ][ j ] = -1 ;\n\t\t\t}\n\n\t\t\telse\n\t\t\t{\n\t\t\t\t++dead ;\n\n\t\t\t\tcastles[ i ][ j ] = castle[ i ][ j ] = c - '0' ;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tlook9( h - 1 ,w - 1 ) ;\n\n\tundo( h - 1 ,w - 1 ) ;\n\n\n\tfor( i = 1 ; i < h - 1 ; ++i )\n\t{\n\t\tfor( j = 1 ; j < w - 1 ; ++j )\n\t\t{\n\t\t\tif( castle[ i ][ j ] > 0 && castle[ i ][ j ] < 9 )\n\t\t\t{\n\t\t\t\tinput_del( i ,j ) ;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tint ans = 0 ;\n\n\tint next_del = 0 ;\n\n\twhile( dead )\n\t{\n\t\t++ans ;\n\t\t\n\t\tint limit = DEL ;\n\t\tfor( i = next_del ,next_del = limit ; i < limit ; ++i )\n\t\t{\n\t\t\tif( del[ i ] dy > 0 )\n\t\t\t{\n\t\t\t\tupdate( del[ i ] dy ,del[ i ] dx ) ;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf( \"%d\\n\" ,ans ) ;\n\t\n\treturn 0 ;\n}"
  },
  {
    "language": "C",
    "code": "\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n\nint search(char map[1001][1001], char before[1001][1001],int h, int w)\n{\n\tint castle_num = map[h][w] - '0';\n\n\tint i, j;\n\tint sara = 0;\n\tfor (i = h - 1; i <= h + 1; i++)\n\t{\n\t\tfor (j = w - 1; j <= w + 1; j++)\n\t\t{\n\t\t\tif (map[i][j]=='.')sara++;\n\t\t}\n\t}\n\n\tif (castle_num <= sara)\n\t{\n\t\tbefore[h][w] = '.';\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n\nint main()\n{\n\tint H, W;\n\tint i, j;\n\tint wave_count = 0;\n\tint wave_flag = -1;\n\n\tchar castle[1001][1001];\n\tchar before[1001][1001];\n\n\tscanf(\"%d %d\", &H, &W);\n\t\n\tfor (i = 0; i<H; i++)\n\t{\n\t\tfor (j = 0; j < W; j++)\n\t\t{\n\t\t\tscanf(\" %c\", &castle[i][j]);\n\t\t}\n\t}\n\t\n\tfor (i = 0; i < H; i++)\n\t\tstrcpy(before[i], castle[i]);\n\n\t//?????????\n\twhile (1)\n\t{\n\t\twave_flag = 0;\n\t\tfor (i = 0; i<H; i++)\n\t\t{\n\t\t\tfor (j = 0; j<W; j++)\n\t\t\t{\n\t\t\t\tif (castle[i][j] != '.')\n\t\t\t\t{\n\t\t\t\t\tif (search(castle,before,i, j) == 1)wave_flag++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tif (wave_flag != 0)\n\t\t{\n\t\t\twave_count++;\n\t\t\tfor (i = 0; i < H; i++)\n\t\t\t\tstrcpy(castle[i], before[i]);\n\t\t}\n\t\telse{ break; }\n\t}\n\n\tprintf(\"%d\\n\", wave_count);\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0612 Sandcastle\n// 2018.2.26 bal4u\n\n#include <stdio.h>\n#include <ctype.h>\n\ntypedef struct { short r, c; } Q;\nQ q[2][2000]; int top[2], tail[2];\nchar map[1002][1002];\nchar a[1002][1002];\nint mv[8][2] = {{-1,0},{-1,1},{0,1},{1,1},{1,0},{1,-1},{0,-1},{-1,-1}};\n\nint main()\n{\n\tint h, w, r, c, i, k1, k2, nr, nc, ans, f;\n\tchar buf[15], *p;\n\n\tfgets(buf, 15, stdin), sscanf(buf, \"%d%d\", &h, &w);\n\n\tfor (r = 0; r < h; r++) {\n\t\tfgets(p=map[r], 1002, stdin);\n\t\twhile (*p > ' ') {\n\t\t\tif (isdigit(*p)) *p &= 0xf;\n\t\t\tp++;\n\t\t}\n\t}\n\n\tfor (r = 1; r < h-1; r++) for (c = 1; c < w-1; c++) {\n\t\tfor (i = 0; i < 8; i++) {\n\t\t\tnr = r + mv[i][0], nc = c + mv[i][1];\n\t\t\tif (map[nr][nc] == '.') a[r][c]++;\n\t\t}\n\t\tif (map[r][c] < 10 && a[r][c] >= map[r][c]) {\n\t\t\tq[0][tail[0]].r = r, q[0][tail[0]++].c = c;\n\t\t}\n\t}\n\n\tans = 0;\n\tfor (k1 = 0, k2 = 1; ; k1 = k2, k2 = !k2) {\n\t\t f = 0;\n\t\t top[k2] = tail[k2] = 0;\n\t\t while (top[k1] < tail[k1]) {\n\t\t\tr = q[k1][top[k1]].r, c = q[k1][top[k1]++].c;\n\t\t\tfor (i = 0; i < 8; i++) {\n\t\t\t\tnr = r + mv[i][0], nc = c + mv[i][1];\n\t\t\t\tif (map[nr][nc] < 10 && ++a[nr][nc] == map[nr][nc]) {\n\t\t\t\t\tq[k2][tail[k2]].r = nr, q[k2][tail[k2]++].c = nc, f = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans++;\n\t\tif (!f) break;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ 0612 Sandcastle\n// 2018.2.26 bal4u\n\n#include <stdio.h>\n#include <ctype.h>\n\ntypedef struct { short r, c; } Q;\nQ q[2][2000]; int top[2], tail[2];\nchar map[1002][1002];\nchar a[1002][1002];\nint mv[8][2] = {{-1,0},{-1,1},{0,1},{1,1},{1,0},{1,-1},{0,-1},{-1,-1}};\n\nint main()\n{\n\tint h, w, r, c, i, k1, k2, nr, nc, ans, f;\n\tchar buf[15], *p;\n\n\tfgets(buf, 15, stdin), sscanf(buf, \"%d%d\", &h, &w);\n\n\tfor (r = 0; r < h; r++) {\n\t\tfgets(p=map[r], 1002, stdin);\n\t\twhile (*p > ' ') {\n\t\t\tif (isdigit(*p)) *p &= 0xf;\n\t\t\tp++;\n\t\t}\n\t}\n\n\tfor (r = 1; r < h-1; r++) for (c = 1; c < w-1; c++) {\n\t\tif (map[r][c] == '.') continue;\n\t\tfor (i = 0; i < 8; i++) {\n\t\t\tnr = r + mv[i][0], nc = c + mv[i][1];\n\t\t\tif (map[nr][nc] == '.') a[r][c]++;\n\t\t}\n\t\tif (a[r][c] >= map[r][c]) {\n\t\t\tq[0][tail[0]].r = r, q[0][tail[0]++].c = c;\n\t\t}\n\t}\n\n\tans = 0;\n\tfor (k1 = 0, k2 = 1; ; k1 = k2, k2 = !k2) {\n\t\t f = 0;\n\t\t top[k2] = tail[k2] = 0;\n\t\t while (top[k1] < tail[k1]) {\n\t\t\tr = q[k1][top[k1]].r, c = q[k1][top[k1]++].c;\n\t\t\tfor (i = 0; i < 8; i++) {\n\t\t\t\tnr = r + mv[i][0], nc = c + mv[i][1];\n\t\t\t\tif (map[nr][nc] < 10 && ++a[nr][nc] == map[nr][nc]) {\n\t\t\t\t\tq[k2][tail[k2]].r = nr, q[k2][tail[k2]++].c = nc, f = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans++;\n\t\tif (!f) break;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n\n\nint h ,w ;\n\nint mx[] = { 1 ,1 ,1 ,-1 ,-1 ,-1 ,0 ,0 } ;\nint my[] = { 1 ,-1 ,0 ,1 ,-1 ,0 ,1 ,-1 } ;\n\n\nchar castle[ 1000 ][ 1000 ] ;\nchar castles[ 1000 ][ 1000 ] ;\n\nchar sand[ 1000 ][ 1000 ] ;\n\n\nint del[ 999 * 999 ][ 2 ] ;\nint DEL ;\n\n#define x j + mx[ k ]\n#define y i + my[ k ]\n\n#define dy [ 0 ]\n#define dx [ 1 ]\n\n\nvoid make9( int i ,int j )\n{\n\tint k ;\n\tfor( k = 0 ; k < 8 ; ++k )\n\t{\n\t\tint kale = castle[ y ][ x ] ;\n\n\t\tif( kale < 9 && kale > -1 )\n\t\t{\n\t\t\t++castle[ y ][ x ] ;\n\n\n\t\t\tif( castle[ y ][ x ] == 9 )\n\t\t\t{\n\t\t\t\tmake9( y ,x ) ;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid look9( int H ,int W )\n{\n\tint i ,j ;\n\tfor( i = 1 ; i < H ; ++i )\n\t{\n\t\tfor( j = 1 ; j < W ; ++j )\n\t\t{\n\t\t\tif( castle[ i ][ j ] == 9 )\n\t\t\t{\n\t\t\t\tmake9( i ,j ) ;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nvoid input_del( int i ,int j )\n{\n\tint minus = 0 ;\n\n\tint k ;\n\tfor( k = 0 ; k < 8 ; ++k )\n\t{\n\t\tminus += castles[ y ][ x ] ;\n\t}\n\n\tif( castle[ i ][ j ] <= -minus )\n\t{\n\t\tcastle[ i ][ j ] = -1 ;\n\n\t\tdel[ DEL ] dy = i ;\n\t\tdel[ DEL ] dx = j ;\n\n\t\t++DEL ;\n\t}\n}\n\nvoid undo( int H ,int W )\n{\n\tint i ,j ;\n\tfor( i = 1 ; i < H ; ++i )\n\t{\n\t\tfor( j = 1 ; j < W ; ++j )\n\t\t{\n\t\t\tif( castle[ i ][ j ] < 9 )\n\t\t\t{\n\t\t\t\tcastle[ i ][ j ] = castles[ i ][ j ] ;\n\t\t\t}\n\t\t\t\n\t\t\tif( castle[ i ][ j ] > -1 )\n\t\t\t{\n\t\t\t\tcastles[ i ][ j ] = 0 ;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid update( int i ,int j )\n{\n\tcastles[ i ][ j ] = -1 ;\n\n\tint k ;\n\tfor( k = 0 ; k < 8 ; ++k )\n\t{\n\t\tif( castle[ y ][ x ] < 9 && castle[ y ][ x ] > -1 )\n\t\t{\n\t\t\tinput_del( y ,x ) ;\n\t\t}\n\t}\n}\n\n\n//\tcastle checker\n/*\nvoid check( int i = 0 ,int j = 0 )\n{\n\tputs( \"\" ) ;\n\n\twhile( i < h )\n\t{\n\t\twhile( j < w )\n\t\t{\n\t\t\tprintf( \"%2d\" ,castle[ i ][ j++ ] ) ;\n\t\t}\n\n\t\t++i ; j = 0 ;\n\n\t\tputs( \"\" ) ;\n\t}\n\n\tputs( \"\" ) ;\n}\n*/\n\n//\tcastles checker\n/*\nvoid checks( int i = 0 ,int j = 0 )\n{\n\tputs( \"\" ) ;\n\n\twhile( i < h )\n\t{\n\t\twhile( j < w )\n\t\t{\n\t\t\tprintf( \"%2d\" ,castles[ i ][ j++ ] ) ;\n\t\t}\n\n\t\t++i ; j = 0 ;\n\n\t\tputs( \"\" ) ;\n\t}\n\n\tputs( \"\" ) ;\n}\n*/\n\nint main()\n{\n\tscanf( \"%d %d\" ,&h ,&w ) ;\n\t\n\tint i ,j ;\n\tfor( i = 0 ; i < h ; ++i )\n\t{\n\t\tgetchar() ;\n\n\t\tfor( j = 0 ; j < w ; ++j )\n\t\t{\n\t\t\tchar c = getchar() ;\n\n\t\t\tif( c == '.' )\n\t\t\t{\n\t\t\t\tcastles[ i ][ j ] = castle[ i ][ j ] = -1 ;\n\t\t\t}\n\n\t\t\telse\n\t\t\t{\n\t\t\t\tcastles[ i ][ j ] = castle[ i ][ j ] = c - '0' ;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tlook9( h - 1 ,w - 1 ) ;\n\n\tundo( h - 1 ,w - 1 ) ;\n\n\tfor( i = 1 ; i < h - 1 ; ++i )\n\t{\n\t\tfor( j = 1 ; j < w - 1 ; ++j )\n\t\t{\n\t\t\tif( castle[ i ][ j ] > -1 && castle[ i ][ j ] < 9 )\n\t\t\t{\n\t\t\t\tinput_del( i ,j ) ;\n\t\t\t}\n\t\t}\n\t}\n\n\tint limit = 0 ;\n\n\tint ans = 0 ;\n\n\tint next_del = 0 ;\n\n\twhile( limit != DEL )\n\t{\n\n\t\t++ans ;\n\n\t\tlimit = DEL ;\n\t\tfor( i = next_del ,next_del = limit ; i < limit ; ++i )\n\t\t{\n\t\t\tif( del[ i ] dy > 0 )\n\t\t\t{\n\t\t\t\tupdate( del[ i ] dy ,del[ i ] dx ) ;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf( \"%d\\n\" ,ans ) ;\n\n\treturn 0 ;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\nint map[50][50];\nint H, W;\nint sum = 0;\n\nvoid d(int sh, int sw, int h, int w)\n{\n  int i, j, k, f = -1;\n  int mh[49], mw[49];\n  for (i = sh; i < h; i++){\n    for (j = sw; j < w; j++){\n      if (map[i][j] != 0){\n        k = 0;\n        k += (map[i + 1][j - 1] == 0) ? 1 : 0;\n        k += (map[i + 1][j] == 0) ? 1 : 0;\n        k += (map[i + 1][j + 1] == 0) ? 1 : 0;\n        k += (map[i][j - 1]) == 0 ? 1 : 0;\n        k += (map[i][j + 1] == 0) ? 1 : 0;\n        k += (map[i - 1][j - 1] == 0) ? 1 : 0;\n        k += (map[i - 1][j] == 0) ? 1 : 0;\n        k += (map[i - 1][j + 1] == 0) ? 1 : 0;\n        if (map[i][j] <= k){\n          f++;\n          mh[f] = i;\n          mw[f] = j;\n        }\n      }\n    }\n  }\n  for (k = 0; k < f + 1; k++){\n    map[mh[k]][mw[k]] = 0;\n  }\n  for (k = 0; k < f + 1; k++){\n    for (i = -1; i <= 1; i++){\n      for (j = -1; j <= 1; j++){\n        if (map[mh[k] + i][mw[k] + j] != 0){\n          d(mh[k] + i, mw[k] + j, mh[k] + i + 1, mw[k] + j + 1);\n        }\n      }\n    }\n    if (f >= 0) sum++;\n  }\n}\n\nint main(void)\n{\n  int i, j;\n  char c;\n  scanf(\"%d %d \", &H, &W);\n  for (i = 0; i < H; i++){\n    for (j = 0; j < W; j++){\n      if (j == W - 1) scanf(\"%c%*c\", &c);\n      else scanf(\"%c\", &c);\n      if (c == '.') map[i][j] = 0;\n      else map[i][j] = c - 0x30;\n    }\n  }\n  d(1, 1, H - 1, W - 1);\n  printf(\"%d\", sum);\n  return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<time.h>\n\nvoid wait()\n{\n\tint i = clock() ;\n\twhile( clock() - i < 353 ) ;\n}\n\nint h ,w ;\n\nint mx[] = { 1 ,1 ,1 ,-1 ,-1 ,-1 ,0 ,0 } ;\nint my[] = { 1 ,-1 ,0 ,1 ,-1 ,0 ,1 ,-1 } ;\n\n\nchar castle[ 1000 ][ 1000 ] ;\nchar castles[ 1000 ][ 1000 ] ;\n\nchar sand[ 1000 ][ 1000 ] ;\n\n\nchar del[ 999 * 999 ][ 2 ] ;\nint DEL ;\n\n#define x j + mx[ k ]\n#define y i + my[ k ]\n\n#define dy [ 0 ]\n#define dx [ 1 ]\n\n\nvoid make9( int i ,int j )\n{\n\tint k ;\n\tfor( k = 0 ; k < 8 ; ++k )\n\t{\n\t\tint kale = castle[ y ][ x ] ;\n\n\t\tif( kale < 9 && kale > -1 )\n\t\t{\n\t\t\t++castle[ y ][ x ] ;\n\n\n\t\t\tif( castle[ y ][ x ] == 9 )\n\t\t\t{\n\t\t\t\tmake9( y ,x ) ;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid look9( int H ,int W )\n{\n\tint i ,j ;\n\tfor( i = 1 ; i < H ; ++i )\n\t{\n\t\tfor( j = 1 ; j < W ; ++j )\n\t\t{\n\t\t\tif( castle[ i ][ j ] == 9 )\n\t\t\t{\n\t\t\t\tmake9( i ,j ) ;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nvoid input_del( int i ,int j )\n{\n\tint minus = 0 ;\n\n\tint k ;\n\tfor( k = 0 ; k < 8 ; ++k )\n\t{\n\t\tminus += castles[ y ][ x ] ;\n\t}\n\n\tif( castle[ i ][ j ] <= -minus )\n\t{\n\t\tcastle[ i ][ j ] = -1 ;\n\n\t\tdel[ DEL ] dy = i ;\n\t\tdel[ DEL ] dx = j ;\n\n\t\t++DEL ;\n\t}\n}\n\nvoid undo( int H ,int W )\n{\n\tint i ,j ;\n\tfor( i = 1 ; i < H ; ++i )\n\t{\n\t\tfor( j = 1 ; j < W ; ++j )\n\t\t{\n\t\t\tif( castle[ i ][ j ] < 9 )\n\t\t\t{\n\t\t\t\tcastle[ i ][ j ] = castles[ i ][ j ] ;\n\t\t\t}\n\t\t\t\n\t\t\tif( castle[ i ][ j ] > -1 )\n\t\t\t{\n\t\t\t\tcastles[ i ][ j ] = 0 ;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid update( int i ,int j )\n{\n\tcastles[ i ][ j ] = -1 ;\n\n\tint k ;\n\tfor( k = 0 ; k < 8 ; ++k )\n\t{\n\t\tif( castle[ y ][ x ] < 9 && castle[ y ][ x ] > -1 )\n\t\t{\n\t\t\tinput_del( y ,x ) ;\n\t\t}\n\t}\n}\n\n\n//\tcastle checker\n/*\nvoid check( int i = 0 ,int j = 0 )\n{\n\tputs( \"\" ) ;\n\n\twhile( i < h )\n\t{\n\t\twhile( j < w )\n\t\t{\n\t\t\tprintf( \"%2d\" ,castle[ i ][ j++ ] ) ;\n\t\t}\n\n\t\t++i ; j = 0 ;\n\n\t\tputs( \"\" ) ;\n\t}\n\n\tputs( \"\" ) ;\n}\n*/\n\n//\tcastles checker\n/*\nvoid checks( int i = 0 ,int j = 0 )\n{\n\tputs( \"\" ) ;\n\n\twhile( i < h )\n\t{\n\t\twhile( j < w )\n\t\t{\n\t\t\tprintf( \"%2d\" ,castles[ i ][ j++ ] ) ;\n\t\t}\n\n\t\t++i ; j = 0 ;\n\n\t\tputs( \"\" ) ;\n\t}\n\n\tputs( \"\" ) ;\n}\n*/\n\nint main()\n{\n\tscanf( \"%d %d\" ,&h ,&w ) ;\n\n\tint i ,j ;\n\tfor( i = 0 ; i < h ; ++i )\n\t{\n\t\tgetchar() ;\n\n\t\tfor( j = 0 ; j < w ; ++j )\n\t\t{\n\t\t\tchar c = getchar() ;\n\n\t\t\tif( c == '.' )\n\t\t\t{\n\t\t\t\tcastles[ i ][ j ] = castle[ i ][ j ] = -1 ;\n\t\t\t}\n\n\t\t\telse\n\t\t\t{\n\t\t\t\tcastles[ i ][ j ] = castle[ i ][ j ] = c - '0' ;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tlook9( h - 1 ,w - 1 ) ;\n\n\tundo( h - 1 ,w - 1 ) ;\n\n\tfor( i = 1 ; i < h - 1 ; ++i )\n\t{\n\t\tfor( j = 1 ; j < w - 1 ; ++j )\n\t\t{\n\t\t\tif( castle[ i ][ j ] > -1 && castle[ i ][ j ] < 9 )\n\t\t\t{\n\t\t\t\tinput_del( i ,j ) ;\n\t\t\t}\n\t\t}\n\t}\n\n\tint limit = 0 ;\n\n\tint ans = 0 ;\n\n\tint next_del = 0 ;\n\n\twhile( limit != DEL )\n\t{\n\n\t\t++ans ;\n\n\t\tlimit = DEL ;\n\t\tfor( i = next_del ,next_del = limit ; i < limit ; ++i )\n\t\t{\n\t\t\tif( del[ i ] dy > 0 )\n\t\t\t{\n\t\t\t\tupdate( del[ i ] dy ,del[ i ] dx ) ;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf( \"%d\\n\" ,ans ) ;\n\t\n\treturn 0 ;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint h,w;\nint castle[1001][1001]={0};\nint castle_check[1001][1001]={0};\nint castledes[1001][1001]={0};\nint sand1[8]={0,0,1,1,1,-1,-1,-1};\nint sand2[8]={1,-1,0,1,-1,0,1,-1};\n\nchar num[]={\"0123456789\"};\nvoid check(int high,int low){\n\tint i,j,z;\n\tfor(i=1;i<high;i++){\n\t\tfor(j=1;j<low;j++){\n\t\t\tif(castle[i][j]>0&&castle[i][j]<=9){\n\t\t\t\tfor(z=0;z<8;z++){\n\t\t\t\t\tif(castle[i+sand1[z]][j+sand2[z]]==-1){\n\t\t\t\t\t\tcastle_check[i][j]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nvoid tukareta(int high,int low){\n\tint i,j,z;\n\tfor(i=1;i<high;i++){\n\t\tfor(j=1;j<low;j++){\n\t\t\tif(castledes[i][j]==1){\n\t\t\t\tfor(z=0;z<8;z++){\n\t\t\t\t\tif(castle[i+sand1[z]][j+sand2[z]]!=-1){\n\t\t\t\t\t\tcastle_check[i+sand1[z]][j+sand2[z]]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcastledes[i][j]=0;\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\tint i,j,r,ans=0,broke=0;\n\tchar a;\n\tscanf(\"%d%d\",&h,&w);\n\tfor(i=0;i<h;i++){\n\t\tgetchar();\n\t\tfor(j=0;j<w;j++){\n\t\t\ta=getchar();\n\t\t\tif(a=='.'){\n\t\t\t\tcastle[i][j]=-1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(r=1;r<=9;r++){\n\t\t\t\t\tif(a==num[r]){\n\t\t\t\t\t\tcastle[i][j]=r;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\t\t\t/*for(i=0;i<h;i++){\n\t\t\t\tfor(j=0;j<w;j++){\n\t\t\t\t\tprintf(\"%2d\",castle[i][j]);\n\t\t\t\t}\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}*/\n\tcheck(h-1,w-1);\n\twhile(1){\n\t\tbroke=0;\n\t\tfor(int i=1;i<h-1;i++){\n\t\t\tfor(int j=1;j<w-1;j++){\n\t\t\t\tif(castle[i][j]<=9&&castle[i][j]>0){\n\t\t\t\t\tif(castle[i][j]<=castle_check[i][j]){\n\t\t\t\t\t\tcastle[i][j]=-1;\n\t\t\t\t\t\tbroke++;\n\t\t\t\t\t\tcastledes[i][j]=1;\n\t\t\t\t\t\tcastle_check[i][j]=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(broke==0){\n\t\t\tprintf(\"%d\\n\",ans);\n\t\t\tbreak;\n\t\t}\n\t\tans++;\n\t\ttukareta(h-1,w-1);\n\t\t\t/*for(i=0;i<h;i++){\n\t\t\t\tfor(j=0;j<w;j++){\n\t\t\t\t\tprintf(\"%2d\",castle[i][j]);\n\t\t\t\t}\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}*/\n\t}\n}\n\t\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n \nint map[1000][1000],cmap[1000][1000],w,h;\nint dx[8]={-1,-1,-1,0,1,1,1,0};\nint dy[8]={-1,0,1,1,1,0,-1,-1};\n \nint chk(int x,int y){\n    if(x<h && y<w && x>=0 && y>=0){\n        return cmap[x][y];\n    }\n    return -1;\n}\n \nint check(int x,int y){\n    int i,c=0;\n    for(i=0;i<8;i++){\n        if(chk(x+dx[i],y+dy[i])>0) c++;\n    }\n    if(c<map[x][y]){\n        return 0;\n    }\n    map[x][y]=0;\n    return 1;\n}\n \nint main(){\n    int ans,i,j;\n    long n;\n    char c[2];\n        scanf(\"%d %d\",&w,&h);\n        for(i=0;i<h;i++){\n            for(j=0;j<w;j++){\n                scanf(\"%c\",&c[0]);\n                if(c[0]=='.'){\n                    map[i][j]=0;\n                }else{\n                    c[1]='\\0';\n                    map[i][j]=atoi(c);\n                }\n            }\n        }\n        ans=0;\n        do{\n            ans++;\n            n=0;\n            memcpy(cmap,map,sizeof(map));\n            for(i=0;i<h;i++){\n                for(j=0;j<w;j++){\n                    if(check(i,j)) n++;\n                }\n            }\n        }while(n>0);\n        printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n\nint search(char map[1000][1000], char before[1000][1000],int h, int w)\n{\n\tint castle_num = map[h][w] - '0';\n\n\tint i, j;\n\tint sara = 0;\n\tfor (i = h - 1; i <= h + 1; i++)\n\t{\n\t\tfor (j = w - 1; j <= w + 1; j++)\n\t\t{\n\t\t\tif (map[i][j]=='.')sara++;\n\t\t}\n\t}\n\n\tif (castle_num <= sara)\n\t{\n\t\tbefore[h][w] = '.';\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n\nint main()\n{\n\tint H, W;\n\tint i, j;\n\tint wave_count = 0;\n\tint wave_flag = -1;\n\n\tchar castle[1000][1000];\n\tchar before[1000][1000];\n\n\tscanf(\"%d %d\", &H, &W);\n\t\n\tfor (i = 0; i<H; i++)\n\t{\n\t\tfor (j = 0; j < W; j++)\n\t\t{\n\t\t\tscanf(\" %c\", &castle[i][j]);\n\t\t}\n\t}\n\t\n\tfor (i = 0; i < H; i++)\n\t\tstrcpy(before[i], castle[i]);\n\n\t//?????????\n\twhile (1)\n\t{\n\t\twave_flag = 0;\n\t\tfor (i = 0; i<H; i++)\n\t\t{\n\t\t\tfor (j = 0; j<W; j++)\n\t\t\t{\n\t\t\t\tif (castle[i][j] != '.')\n\t\t\t\t{\n\t\t\t\t\tif (search(castle,before,i, j) == 1)wave_flag++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i<H; i++)\n\t\t{\n\t\t\tfor (j = 0; j<W; j++)\n\t\t\t{\n\t\t\t\tprintf(\"%c\", castle[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\n\t\tif (wave_flag != 0)\n\t\t{\n\t\t\twave_count++;\n\t\t\tfor (i = 0; i < H; i++)\n\t\t\t\tstrcpy(castle[i], before[i]);\n\t\t}\n\t\telse{ break; }\n\t}\n\n\tprintf(\"%d\\n\", wave_count);\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint x[1000000],y[1000000];\nchar d[1010][1010]={0};\nint Y[]={1,1,0,-1,-1,-1,0,1};\nint X[]={0,1,1,1,0,-1,-1,-1};\nint main(){\n  int w,h,i,j,t=0,r=0,rr=0,ny,nx;\n  scanf(\"%d %d\",&h,&w);\n  for(i=1;i<=h;i++){\n    for(j=1;j<=w;j++){\n      scanf(\" %c\",&d[i][j]);\n      if(d[i][j]=='.'){\n\td[y[r]=i][x[r]=j]=0;\n\tr++;\n      }\n    }\n  }\n  for(i=0;r-rr;i++){\n    for(rr=r;rr-t;t++){\n      for(j=0;j<8;j++){\n\tny=y[t]+Y[j];\n\tnx=x[t]+X[j];\n\tif(d[ny][nx]==0)continue;\n\td[ny][nx]--;\n\tif(d[ny][nx]=='0'){\n\t  d[y[r]=ny][x[r]=nx]=0;\n\t  r++;\n\t}\n      }\n    }\n  }\n  printf(\"%d\\n\",i-1);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(void)\n{\n\tint b,d=0,n,i,j,k,p,q=0,x,y,z;\n\tchar a[1000][1000],c;\n\tscanf(\"%d%d\",&n,&k);\n\tfor(i=1;i<=n;i++){\n\t\tscanf(\"%s\",a[i]);\n\t}\n\twhile(1){\n\t\tp=q;\n\t\tb=0;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tfor(j=1;j<=k;j++){\n\t\t\t\tif(a[i][j]=='.'){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tfor(x=i-1;x<i+1;x++){\n\t\t\t\t\t\tfor(y=j-1;y<j+1;y++){\n\t\t\t\t\t\t\tif(a[x][y]=='.'){\n\t\t\t\t\t\t\t\tb+=1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tz=a[i][j];\n\t\t\t\t\tif(z>=b){\n\t\t\t\t\t\ta[i][j]='.';\n\t\t\t\t\t\tq+=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\td+=1;\n\t\tif(p==q){\n\t\t\tbreak;\n\t\t}\n\t}\n\td=d*d-1;\n\tprintf(\"%d\\n\",d);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n\nint map[1000][1000],cmap[1000][1000],w,h;\nint dx[8]={-1,-1,-1,0,1,1,1,0};\nint dy[8]={-1,0,1,1,1,0,-1,-1};\n\nint chk(int x,int y){\n\tif(x<h && y<w && x>=0 && y>=0){\n\t\treturn cmap[x][y];\n\t}\n\treturn -1;\n}\n\nint check(int x,int y){\n\tint i,c=0;\n\tfor(i=0;i<8;i++){\n\t\tif(chk(x+dx[i],y+dy[i])>0) c++;\n\t}\n\tif(c<map[x][y]){\n\t\treturn 0;\n\t}\n\tmap[x][y]=0;\n\treturn 1;\n}\n\nint main(){\n\tint ans,i,j;\n\tlong n;\n\tchar c[2];\n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w==0) break;\n\t\tfor(i=0;i<h;i++){\n\t\t\tfor(j=0;j<w;j++){\n\t\t\t\tscanf(\"%c\",&c[0]);\n\t\t\t\tif(c[0]=='.'){\n\t\t\t\t\tmap[i][j]=0;\n\t\t\t\t}else{\n\t\t\t\t\tc[1]='\\0';\n\t\t\t\t\tmap[i][j]=atoi(c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans=0;\n\t\tdo{\n\t\t\tans++;\n\t\t\tn=0;\n\t\t\tmemcpy(cmap,map,sizeof(map));\n\t\t\tfor(i=0;i<h;i++){\n\t\t\t\tfor(j=0;j<w;j++){\n\t\t\t\t\tif(check(i,j)) n++;\n\t\t\t\t}\n\t\t\t}\n\t\t}while(n>0);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int w,h,i,j,a,k,f=1,c;\n  char d[1001][1001];\n  int X[]={0,1,1,1,0,-1,-1,-1};\n  int Y[]={1,1,0,-1,-1,-1,0,1};\n  scanf(\"%d %d\",&h,&w);\n  for(i=0;i<h;i++)scanf(\"%s\",d[i]);\n  for(a=-1;f;a++){\n    f=0;\n    for(i=1;i<h-1;i++){\n      for(j=1;j<w-1;j++){\n\tif(d[i][j]=='.')continue;\n\tfor(k=c=0;k<8;k++){\n\t  if(d[i+Y[k]][j+X[k]]=='.')c++;\n\t}\n\tif(d[i][j]-'0'<=c){\n\t  d[i][j]='0';\n\t  f=1;\n\t}\n      }\n    }\n    for(i=1;i<h-1;i++){\n      for(j=1;j<w-1;j++){\n\tif(d[i][j]=='0')d[i][j]='.';//printf(\"%c\",d[i][j]);\n      }//printf(\"\\n\");\n    }//printf(\"\\n\");\n  }\n  printf(\"%d\\n\",a);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n\nint search(char **map, char **before,int h, int w)\n{\n\tint castle_num = map[h][w] - '0';\n\n\tint i, j;\n\tint sara = 0;\n\tfor (i = h - 1; i <= h + 1; i++)\n\t{\n\t\tfor (j = w - 1; j <= w + 1; j++)\n\t\t{\n\t\t\tif (map[i][j]=='.')sara++;\n\t\t}\n\t}\n\n\tif (castle_num <= sara)\n\t{\n\t\tbefore[h][w] = '.';\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n\nint main()\n{\n\tint H, W;\n\tint i, j;\n\tint wave_count = 0;\n\tint wave_flag = -1;\n\n\tchar **castle;\n\tchar **before;\n\n\tscanf(\"%d %d\", &H, &W);\n\tcastle = (char **)malloc(sizeof(char *)*H);\n\tbefore = (char **)malloc(sizeof(char *)*H);\n\n\tfor (i = 0; i < W; i++)\n\t{\n\t\tcastle[i] = (char *)malloc(sizeof(char)*(W));\n\t\tbefore[i] = (char *)malloc(sizeof(char)*(W));\n\t}\n\tfor (i = 0; i<H; i++)\n\t{\n\t\tfor (j = 0; j < W; j++)\n\t\t{\n\t\t\tscanf(\" %c\", &castle[i][j]);\n\t\t}\n\t}\n\tfor (i = 0; i < H; i++)\n\t\tstrcpy(before[i], castle[i]);\n\n\t//?????????\n\twhile (1)\n\t{\n\t\twave_flag = 0;\n\t\tfor (i = 0; i<H; i++)\n\t\t{\n\t\t\tfor (j = 0; j<W; j++)\n\t\t\t{\n\t\t\t\tif (castle[i][j] != '.')\n\t\t\t\t{\n\t\t\t\t\tif (search(castle,before,i, j) == 1)wave_flag++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (wave_flag != 0)\n\t\t{\n\t\t\twave_count++;\n\t\t\tfor (i = 0; i < H; i++)\n\t\t\t\tstrcpy(castle[i], before[i]);\n\t\t}\n\t\telse{ break; }\n\t}\n\n\tprintf(\"%d\\n\", wave_count);\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\nint st,map1[2000];\nchar map[1002][1002];\nvoid snake(int x,int y){\n    if(map[y][x+1]=='.')\n        st++;\n    if(map[y+1][x]=='.')\n        st++;\n    if(map[y][x-1]=='.')\n        st++;\n    if(map[y-1][x]=='.')\n        st++;\n    if(map[y-1][x+1]=='.')\n        st++;\n    if(map[y+1][x+1]=='.')\n        st++;\n    if(map[y+1][x-1]=='.')\n        st++;\n    if(map[y-1][x-1]=='.')\n        st++;\n}\nint main(void){\n    int h,w,sign=1,sum=-1,i,t=0,o,p;\n    scanf(\"%d %d\",&h,&w);\n    p=getchar();\n    for(i=1;i<=h;i++){\n        for(o=1;o<=w;o++){\n            map[i][o]=getchar();\n        }\n        p=getchar();\n    }\n    while(sign){\n        sign=0;\n        for(i=1;i<=h;i++){\n            for(o=1;o<=w;o++){\n                if(st=0,map[i][o] != '.' && map[i][o] < '9'){\n                    snake(o,i);\n                    if(map[i][o]-48<=st){\n                        sign=1;\n                        map1[t++]=i;\n                        map1[t++]=o;\n                    }\n                }\n            }\n        }\n        for(p=0;p<t;p+=2)\n            map[map1[p]][map1[p+1]]='.';\n        sum++;\n    }\n    printf(\"%d\\n\",sum);\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n\nint h ,w ;\n\nint mx[] = { 1 ,1 ,1 ,-1 ,-1 ,-1 ,0 ,0 } ;\nint my[] = { 1 ,-1 ,0 ,1 ,-1 ,0 ,1 ,-1 } ;\n\n\nchar castle[ 1000 ][ 1000 ] ;\nchar castles[ 1000 ][ 1000 ] ;\n\nchar sand[ 1000 ][ 1000 ] ;\n\n\nint dead ;\n\nchar del[ 999 * 999 ][ 2 ] ;\nint DEL ;\n\n#define x j + mx[ k ]\n#define y i + my[ k ]\n\n#define dy [ 0 ]\n#define dx [ 1 ]\n\n\nvoid make9( int i ,int j )\n{\n\tint k ;\n\tfor( k = 0 ; k < 8 ; ++k )\n\t{\n\t\tint kale = castle[ y ][ x ] ;\n\n\t\tif( kale < 9 && kale > -1 )\n\t\t{\n\t\t\t++castle[ y ][ x ] ;\n\n\t\t\tif( castle[ y ][ x ] == 9 )\n\t\t\t{\n\t\t\t\tmake9( y ,x ) ;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid look9( int H ,int W )\n{\n\tint i ,j ;\n\tfor( i = 1 ; i < H ; ++i )\n\t{\n\t\tfor( j = 1 ; j < W ; ++j )\n\t\t{\n\t\t\tif( castle[ i ][ j ] == 9 )\n\t\t\t{\n\t\t\t\tmake9( i ,j ) ;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nvoid input_del( int i ,int j )\n{\n\tint minus = 0 ;\n\n\tint k ;\n\tfor( k = 0 ; k < 8 ; ++k )\n\t{\n\t\tminus += castles[ y ][ x ] ;\n\t}\n\n\tif( castle[ i ][ j ] <= -minus )\n\t{\n\t\tcastle[ i ][ j ] = 0 ;\n\n\t\tdel[ DEL ] dy = i ;\n\t\tdel[ DEL ] dx = j ;\n\n\t\t++DEL ;\n\t}\n}\n\nvoid undo( int H ,int W )\n{\n\tint i ,j ;\n\tfor( i = 1 ; i < H ; ++i )\n\t{\n\t\tfor( j = 1 ; j < W ; ++j )\n\t\t{\n\t\t\tif( castle[ i ][ j ] < 9 )\n\t\t\t{\n\t\t\t\tcastle[ i ][ j ] = castles[ i ][ j ] ;\n\t\t\t}\n\n\t\t\tif( castle[ i ][ j ] > 0 )\n\t\t\t{\n\t\t\t\tcastles[ i ][ j ] = 0 ;\n\n\t\t\t\tif( castle[ i ][ j ] == 9 )\n\t\t\t\t{\n\t\t\t\t\t--dead ;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid update( int i ,int j )\n{\n\t--dead ;\n\n\tcastles[ i ][ j ] = -1 ;\n\n\tint k ;\n\tfor( k = 0 ; k < 8 ; ++k )\n\t{\n\t\tif( castle[ y ][ x ] < 9 && castle[ y ][ x ] > 0 )\n\t\t{\n\t\t\tinput_del( y ,x ) ;\n\t\t}\n\t}\n}\n\n\n//\tcastle checker\n/*\nvoid check( int i = 0 ,int j = 0 )\n{\n\tputs( \"\" ) ;\n\n\twhile( i < h )\n\t{\n\t\twhile( j < w )\n\t\t{\n\t\t\tprintf( \"%2d\" ,castle[ i ][ j++ ] ) ;\n\t\t}\n\n\t\t++i ; j = 0 ;\n\n\t\tputs( \"\" ) ;\n\t}\n\n\tputs( \"\" ) ;\n}\n*/\n\n//\tcastles checker\n/*\nvoid checks( int i = 0 ,int j = 0 )\n{\n\tputs( \"\" ) ;\n\n\twhile( i < h )\n\t{\n\t\twhile( j < w )\n\t\t{\n\t\t\tprintf( \"%2d\" ,castles[ i ][ j++ ] ) ;\n\t\t}\n\n\t\t++i ; j = 0 ;\n\n\t\tputs( \"\" ) ;\n\t}\n\n\tputs( \"\" ) ;\n}\n*/\n\nint main()\n{\n\tscanf( \"%d %d\" ,&h ,&w ) ;\n\n\tint i ,j ;\n\tfor( i = 0 ; i < h ; ++i )\n\t{\n\t\tgetchar() ;\n\n\t\tfor( j = 0 ; j < w ; ++j )\n\t\t{\n\t\t\tchar c = getchar() ;\n\n\t\t\tif( c == '.' )\n\t\t\t{\n\t\t\t\tcastles[ i ][ j ] = castle[ i ][ j ] = -1 ;\n\t\t\t}\n\n\t\t\telse\n\t\t\t{\n\t\t\t\t++dead ;\n\n\t\t\t\tcastles[ i ][ j ] = castle[ i ][ j ] = c - '0' ;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tlook9( h - 1 ,w - 1 ) ;\n\n\tundo( h - 1 ,w - 1 ) ;\n\n\n\tfor( i = 1 ; i < h - 1 ; ++i )\n\t{\n\t\tfor( j = 1 ; j < w - 1 ; ++j )\n\t\t{\n\t\t\tif( castle[ i ][ j ] > 0 && castle[ i ][ j ] < 9 )\n\t\t\t{\n\t\t\t\tinput_del( i ,j ) ;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tint limit = 0 ;\n\n\tint ans = 0 ;\n\n\tint next_del = 0 ;\n\n\twhile( dead )\n\t{\n\t\t++ans ;\n\n\t\tlimit = DEL ;\n\t\tfor( i = next_del ,next_del = limit ; i < limit ; ++i )\n\t\t{\n\t\t\tif( del[ i ] dy > 0 )\n\t\t\t{\n\t\t\t\tupdate( del[ i ] dy ,del[ i ] dx ) ;\n\t\t\t}\n\t\t}\n\n\t\tif( limit == DEL )\n\t\t\tbreak ;\n\t}\n\n\tprintf( \"%d\\n\" ,ans) ;\n\t\n\treturn 0 ;\n}"
  },
  {
    "language": "C",
    "code": "\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n\nint search(char map[1000][1000], char before[1000][1000],int h, int w)\n{\n\tint castle_num = map[h][w] - '0';\n\n\tint i, j;\n\tint sara = 0;\n\tfor (i = h - 1; i <= h + 1; i++)\n\t{\n\t\tfor (j = w - 1; j <= w + 1; j++)\n\t\t{\n\t\t\tif (map[i][j]=='.')sara++;\n\t\t}\n\t}\n\n\tif (castle_num <= sara)\n\t{\n\t\tbefore[h][w] = '.';\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n\nint main()\n{\n\tint H, W;\n\tint i, j;\n\tint wave_count = 0;\n\tint wave_flag = -1;\n\n\tchar castle[1000][1000];\n\tchar before[1000][1000];\n\n\tscanf(\"%d %d\", &H, &W);\n\t\n\tfor (i = 0; i<H; i++)\n\t{\n\t\tfor (j = 0; j < W; j++)\n\t\t{\n\t\t\tscanf(\" %c\", &castle[i][j]);\n\t\t}\n\t}\n\t\n\tfor (i = 0; i < H; i++)\n\t\tstrcpy(before[i], castle[i]);\n\n\t//?????????\n\twhile (1)\n\t{\n\t\twave_flag = 0;\n\t\tfor (i = 0; i<H; i++)\n\t\t{\n\t\t\tfor (j = 0; j<W; j++)\n\t\t\t{\n\t\t\t\tif (castle[i][j] != '.')\n\t\t\t\t{\n\t\t\t\t\tif (search(castle,before,i, j) == 1)wave_flag++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tif (wave_flag != 0)\n\t\t{\n\t\t\twave_count++;\n\t\t\tfor (i = 0; i < H; i++)\n\t\t\t\tstrcpy(castle[i], before[i]);\n\t\t}\n\t\telse{ break; }\n\t}\n\n\tprintf(\"%d\\n\", wave_count);\n\n\treturn 0;\n}"
  },
  {
    "language": "Kotlin",
    "code": "import java.util.*\n\n\ndata class Coordinate(val x:Int, val y:Int){\n    inline fun forEachNeighbors(func:(Int, Int) -> Unit):Unit {\n        (-1 .. 1).forEach { dx ->\n            if (dx == 0) (-1 .. 1 step 2).forEach { func(x + dx, y + it) }\n            else (-1..1).forEach { func(x + dx, y + it) }\n        }\n    }\n}\nfun main(args:Array<String>):Unit {\n    val (h, w) = readLine()!!.trim().split(' ').map(String::toInt)\n    val state = Array(h){readLine()!!.trim().map{if (it == '.') 0 else it.toString().toInt()}.toIntArray()}\n    val queue :Deque<Coordinate> = LinkedList<Coordinate>()\n    state.forEachIndexed { y, chars -> chars.forEachIndexed { x, c -> if (c == 0) queue.push(Coordinate(x, y)) } }\n    var count = 0\n    if (queue.size == h * w) {\n        println(0)\n        return\n    }\n    while (queue.isNotEmpty()){\n        ++count\n        repeat(queue.size){\n            queue.removeFirst().forEachNeighbors { x, y ->\n                if (x in 0 until w && y in 0 until h && state[y][x] > 0){\n                    --state[y][x]\n                    if (state[y][x] == 0) queue.addLast(Coordinate(x, y))\n                }\n            }\n        }\n    }\n    println(count - 1)\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.StringTokenizer;\nimport java.util.Deque;\nimport java.util.ArrayDeque;\n\nclass Main{\n\nstatic final PrintWriter out=new PrintWriter(System.out);\nstatic final int INF=Integer.MAX_VALUE/2;\nstatic int[] d={-1,0,1};\n\nstatic class TPair{\nint t;\nint x;\nint y;\nTPair(int t,int x,int y){\nthis.t=t; this.x=x; this.y=y;\n}\n}\n\npublic static void main(String[] args) throws IOException{\nBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\nString line=\"\";\nwhile((line=br.readLine())!=null&&!line.isEmpty()){\nStringTokenizer st=new StringTokenizer(line);\nint h=Integer.parseInt(st.nextToken());\nint w=Integer.parseInt(st.nextToken());\nint[][] map=new int[h][w];\nfor(int i=0;i<h;i++){\nline=br.readLine();\nfor(int j=0;j<w;j++){\nmap[i][j]=(line.charAt(j)=='.')?INF:(int)(line.charAt(j)-'0');\n}\n}\nout.println(bfs(h,w,map));\nout.flush();\n}\n}\n\nprivate static int bfs(int h,int w,int[][] map){\nDeque<Pair> que=new ArrayDeque<Pair>();\nint[][] hmap=new int[h][];\nint ans=-1;\nfor(int i=0;i<h;i++) hmap[i]=map[i].clone();\nfor(int i=0;i<h;i++){\nfor(int j=0;j<w;j++){\nif(map[i][j]!=INF){\nque.offerLast(new TPair(0,i,j));\n}\n}\n}\nwhile(!que.isEmpty()){\nTPair p=que.pollFirst();\nif(ans!=p.t){\nfor(int i=0;i<h;i++) hmap[i]=map[i].clone();\nans=p.t;\n}\nint x=p.x;\nint y=p.y;\nint nx;\nint ny;\nint cnt1=0;\nint cnt2=0;\nint hxy=hmap[x][y];\nloop:\nfor(int i=0;i<3;i++){\nfor(int j=0;j<3;j++){\nif(i==1&&j==1) continue;\nnx=x+d[i];\nny=y+d[j];\nif(hmap[nx][ny]==INF) cnt1++;\nif(hmap[nx][ny]<INF) cnt2++;\nif(cnt1>=hxy){\nmap[x][y]=INF;\nbreak loop;\n}\nif(cnt2>8-hxy){\nque,offerLast(new TPair(ans+1,x,y));\nbreak loop;\n}\n}\n}\nreturn ans;\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.StringTokenizer;\nimport java.util.Deque;\nimport java.util.ArrayDeque;\n\nclass Main{\n\nstatic final PrintWriter out=new PrintWriter(System.out);\nstatic final int INF=Integer.MAX_VALUE/2;\nstatic int[] d={-1,0,1};\n\nstatic class TPair{\nint t;\nint x;\nint y;\nTPair(int t,int x,int y){\nthis.t=t; this.x=x; this.y=y;\n}\n}\n\npublic static void main(String[] args) throws IOException{\nBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\nString line=\"\";\nwhile((line=br.readLine())!=null&&!line.isEmpty()){\nStringTokenizer st=new StringTokenizer(line);\nint h=Integer.parseInt(st.nextToken());\nint w=Integer.parseInt(st.nextToken());\nint[][] map=new int[h][w];\nfor(int i=0;i<h;i++){\nline=br.readLine();\nfor(int j=0;j<w;j++){\nmap[i][j]=(line.charAt(j)=='.')?INF:(int)(line.charAt(j)-'0');\n}\n}\nout.println(bfs(h,w,map));\nout.flush();\n}\n}\n\nprivate static int bfs(int h,int w,int[][] map){\nDeque<TPair> que=new ArrayDeque<TPair>();\nint[][] hmap=new int[h][];\nboolean update=true;\nint ans=-1;\nfor(int i=0;i<h;i++){\nfor(int j=0;j<w;j++){\nif(map[i][j]!=INF) que.offerLast(new TPair(0,i,j));\n}\n}\nwhile(!que.isEmpty()){\nTPair p=que.pollFirst();\nif(ans!=p.t){\nif(update){\nupdate=false;\nfor(int i=0;i<h;i++) hmap[i]=map[i].clone();\nans=p.t;\n}\nelse return ans;\n}\nint x=p.x;\nint y=p.y;\nint nx;\nint ny;\nint cnt1=0;\nint cnt2=0;\nint hxy=hmap[x][y];\nloop:\nfor(int i=0;i<3;i++){\nfor(int j=0;j<3;j++){\nif(i==1&&j==1) continue;\nnx=x+d[i];\nny=y+d[j];\nif(hmap[nx][ny]==INF) cnt1++;\nif(hmap[nx][ny]<INF) cnt2++;\nif(cnt1>=hxy){\nmap[x][y]=INF;\nupdate=true;\nbreak loop;\n}\nif(cnt2>8-hxy){\nque.offerLast(new TPair(ans+1,x,y));\nbreak loop;\n}\n}\n}\n}\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.ArrayList;\nimport java.util.HashMap;\n\npublic class Main {\n\t\n\tpublic static HashMap<String,String> map = new HashMap<>();\n\n\tpublic static void main(String[] args) {\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint h = sc.nextInt();\n\t\tint w = sc.nextInt();\n\t\tint[][] map = new int[h][w];\n\t\tint[][] ck  = new int[h][w];\n\t\tboolean[][] cc = new boolean[h][w];\n\t\tfor(int i = 0; i < h; i++) {\n\t\t\tchar[] mm = sc.next().toCharArray();\n\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\tif(mm[j] == '.') continue;\n\t\t\t\tmap[i][j] = mm[j] - '0';\n\t\t\t}\n\t\t}\n\t\tArrayDeque<Node> q = new ArrayDeque<Node>();\n\t\tArrayDeque<Node> n_q = new ArrayDeque<Node>();\n\t\tint[] vx = {1,1,1,0,0,-1,-1,-1};\n\t\tint[] vy = {1,0,-1,1,-1,1,0,-1};\n\t\tfor(int i = 0; i < h; i++) {\n\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\tif(map[i][j] == 0) {\n\t\t\t\t\tfor(int k = 0; k < 8; k++) {\n\t\t\t\t\t\tint ty = i + vy[k];\n\t\t\t\t\t\tint tx = j + vx[k];\n\t\t\t\t\t\tif(r(h,w,ty,tx) && map[ty][tx] != 0) {\n\t\t\t\t\t\t\tcc[ty][tx] = true;\n\t\t\t\t\t\t\tck[ty][tx]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < h; i++) {\n\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\tif(cc[i][j]) {\n\t\t\t\t\tq.add(new Node(i,j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tboolean o = true;\n\t\tint ans = 0;\n\t\tArrayDeque<Node> er = new ArrayDeque<Node>();\n\t\twhile(o) {\n\t\t\to = false;\n\t\t\twhile(!q.isEmpty()) {\n\t\t\t\tNode n = q.poll();\n\t\t\t\tif(map[n.h][n.w] == 0) continue;\n\t\t\t\t\n\t\t\t\tif(ck[n.h][n.w] >= map[n.h][n.w]) {\n\t\t\t\t\to = true;\n\t\t\t\t\ter.add(n);\n\t\t\t\t\tfor(int i = 0; i < 8; i++) {\n\t\t\t\t\t\tint tx = n.w + vx[i];\n\t\t\t\t\t\tint ty = n.h + vy[i];\n\t\t\t\t\t\tif(r(h,w,ty,tx) && map[ty][tx] != 0 && !cc[ty][tx]) {\n\t\t\t\t\t\t\tn_q.add(new Node(ty,tx));\n\t\t\t\t\t\t\tcc[ty][tx] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tn_q.add(n);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\twhile(!er.isEmpty()) {\n\t\t\t\tNode p = er.poll();\n\t\t\t\tfor(int i = 0; i < 8; i++) {\n\t\t\t\t\tint tx = p.w + vx[i];\n\t\t\t\t\tint ty = p.h + vy[i];\n\t\t\t\t\tif(r(h,w,ty,tx) && map[ty][tx] != 0) {\n\t\t\t\t\t\tck[ty][tx]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmap[p.h][p.w] = 0;\n\t\t\t}\n\t\t\tArrayDeque<Node> tmp = q;\n\t\t\tq = n_q;\n\t\t\tn_q = tmp;\n\t\t\tif(o) ans++;\n\t\t}\n\t\tSystem.out.println(ans);\n\t\t\n\t}\n\t\n\tstatic boolean r(int a, int b, int c, int d) {\n\t\tif(c < 0 || d < 0 || c >= a || d >= b) return false;\n\t\treturn true;\n\t}\n\t\n\tstatic class Node {\n\t\tint h;\n\t\tint w;\n\t\tNode(int a, int b) {\n\t\t\th = a;\n\t\t\tw = b;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.StringTokenizer;\nimport java.util.Deque;\nimport java.util.ArrayDeque;\n\nclass Main{\n\nstatic final PrintWriter out=new PrintWriter(System.out);\nstatic final int INF=Integer.MAX_VALUE/2;\nstatic int[] d={-1,0,1};\n\nstatic class Pair{\nint x;\nint y;\nPair(int x,int y){\nthis.x=x; this.y=y;\n}\n}\n\npublic static void main(String[] args) throws IOException{\nBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\nString line=\"\";\nwhile((line=br.readLine())!=null&&!line.isEmpty()){\nStringTokenizer st=new StringTokenizer(line);\nint h=Integer.parseInt(st.nextToken());\nint w=Integer.parseInt(st.nextToken());\nint[][] map=new int[h][w];\nfor(int i=0;i<h;i++){\nline=br.readLine();\nfor(int j=0;j<w;j++){\nmap[i][j]=(line.charAt(j)=='.')?INF:(int)(line.charAt(j)-'0');\n}\n}\nint cnt=0;\nwhile(true){\nif(bfs(h,w,map)) cnt++;\nelse break;\n}\nout.println(cnt);\nout.flush();\n}\n}\n\nprivate static boolean bfs(int h,int w,int[][] map){\nDeque<Pair> que=new ArrayDeque<Pair>();\nint[][] hmap=new int[h][];\nboolean update=false;\nfor(int i=0;i<h;i++) hmap[i]=map[i].clone();\nfor(int i=0;i<h;i++){\nfor(int j=0;j<w;j++){\nif(map[i][j]!=INF){\nque.offerLast(new Pair(i,j));\n}\n}\n}\nwhile(!que.isEmpty()){\nPair p=que.pollFirst();\nint x=p.x;\nint y=p.y;\nint nx;\nint ny;\nint cnt1=0;\nint cnt2=0;\nint hxy=hmap[x][y];\nloop:\nfor(int i=0;i<3;i++){\nfor(int j=0;j<3;j++){\nif(i==1&&j==1) continue;\nnx=x+d[i];\nny=y+d[j];\nif(hmap[nx][ny]==INF) cnt1++;\nif(hmap[nx][ny]<INF) cnt2++;\nif(cnt1>=hxy){\nmap[x][y]=INF;\nupdate=true;\nbreak loop;\n}\nif(cnt2>8-hxy) break loop;\n}\n}\n}\nreturn update;\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.ArrayList;\nimport java.util.HashMap;\n\npublic class Main {\n\t\n\tpublic static HashMap<String,String> map = new HashMap<>();\n\n\tpublic static void main(String[] args) {\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint h = sc.nextInt();\n\t\tint w = sc.nextInt();\n\t\tint[][] map = new int[h][w];\n\t\tboolean[][] cc = new boolean[h][w];\n\t\tfor(int i = 0; i < h; i++) {\n\t\t\tchar[] mm = sc.next().toCharArray();\n\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\tif(mm[j] == '.') continue;\n\t\t\t\tmap[i][j] = mm[j] - '0';\n\t\t\t}\n\t\t}\n\t\tArrayDeque<Node> q = new ArrayDeque<Node>();\n\t\tArrayDeque<Node> n_q = new ArrayDeque<Node>();\n\t\tint[] vx = {1,1,1,0,0,-1,-1,-1};\n\t\tint[] vy = {1,0,-1,1,-1,1,0,-1};\n\t\tfor(int i = 0; i < h; i++) {\n\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\tif(map[i][j] == 0) {\n\t\t\t\t\tfor(int k = 0; k < 8; k++) {\n\t\t\t\t\t\tint ty = i + vy[k];\n\t\t\t\t\t\tint tx = j + vx[k];\n\t\t\t\t\t\tif(r(h,w,ty,tx) && map[ty][tx] != 0) cc[ty][tx] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < h; i++) {\n\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\tif(cc[i][j]) {\n\t\t\t\t\tq.add(new Node(i,j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tboolean o = true;\n\t\tint ans = 0;\n\t\tArrayDeque<Node> er = new ArrayDeque<Node>();\n\t\twhile(o) {\n\t\t\to = false;\n\t\t\twhile(!q.isEmpty()) {\n\t\t\t\t\n\t\t\t\tNode n = q.poll();\n\t\t\t\tif(map[n.h][n.w] == 0) continue;\n\t\t\t\tint sum = 0;\n\t\t\t\tfor(int i = 0; i < 8; i++) {\n\t\t\t\t\tif(r(h,w,n.h + vy[i], n.w + vx[i]) && map[n.h + vy[i]][n.w + vx[i]] == 0) {\n\t\t\t\t\t\tsum++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(sum >= map[n.h][n.w]) {\n\t\t\t\t\to = true;\n\t\t\t\t\ter.add(n);\n\t\t\t\t\tfor(int i = 0; i < 8; i++) {\n\t\t\t\t\t\tint tx = n.w + vx[i];\n\t\t\t\t\t\tint ty = n.h + vy[i];\n\t\t\t\t\t\tif(r(h,w,ty,tx) && map[ty][tx] != 0 && !cc[ty][tx]) {\n\t\t\t\t\t\t\tn_q.add(new Node(ty,tx));\n\t\t\t\t\t\t\tcc[ty][tx] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tn_q.add(n);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\twhile(!er.isEmpty()) {\n\t\t\t\tNode p = er.poll();\n\t\t\t\tmap[p.h][p.w] = 0;\n\t\t\t}\n\t\t\tArrayDeque<Node> tmp = q;\n\t\t\tq = n_q;\n\t\t\tn_q = tmp;\n\t\t\tif(o) ans++;\n\t\t}\n\t\tSystem.out.println(ans);\n\t\t\n\t}\n\t\n\tstatic boolean r(int a, int b, int c, int d) {\n\t\tif(c < 0 || d < 0 || c >= a || d >= b) return false;\n\t\treturn true;\n\t}\n\t\n\tstatic class Node {\n\t\tint h;\n\t\tint w;\n\t\tNode(int a, int b) {\n\t\t\th = a;\n\t\t\tw = b;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.StringTokenizer;\nimport java.util.Deque;\nimport java.util.ArrayDeque;\n\nclass Main{\n\nstatic final PrintWriter out=new PrintWriter(System.out);\nstatic final int INF=Integer.MAX_VALUE/2;\nstatic int[] d={-1,0,1};\n\nstatic class TPair{\nint t;\nint x;\nint y;\nTPair(int t,int x,int y){\nthis.t=t; this.x=x; this.y=y;\n}\n}\n\npublic static void main(String[] args) throws IOException{\nBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\nString line=\"\";\nwhile((line=br.readLine())!=null&&!line.isEmpty()){\nStringTokenizer st=new StringTokenizer(line);\nint h=Integer.parseInt(st.nextToken());\nint w=Integer.parseInt(st.nextToken());\nint[][] map=new int[h][w];\nfor(int i=0;i<h;i++){\nline=br.readLine();\nfor(int j=0;j<w;j++){\nmap[i][j]=(line.charAt(j)=='.')?INF:(int)(line.charAt(j)-'0');\n}\n}\nout.println(bfs(h,w,map));\nout.flush();\n}\n}\n\nprivate static int bfs(int h,int w,int[][] map){\nDeque<TPair> que=new ArrayDeque<TPair>();\nint[][] hmap=new int[h][];\nint ans=-1;\nfor(int i=0;i<h;i++){\nfor(int j=0;j<w;j++){\nif(map[i][j]!=INF) que.offerLast(new TPair(0,i,j));\n}\n}\nwhile(!que.isEmpty()){\nTPair p=que.pollFirst();\nif(ans!=p.t){\nfor(int i=0;i<h;i++) hmap[i]=map[i].clone();\nans=p.t;\n}\nint x=p.x;\nint y=p.y;\nint nx;\nint ny;\nint cnt1=0;\nint cnt2=0;\nint hxy=hmap[x][y];\nloop:\nfor(int i=0;i<3;i++){\nfor(int j=0;j<3;j++){\nif(i==1&&j==1) continue;\nnx=x+d[i];\nny=y+d[j];\nif(hmap[nx][ny]==INF) cnt1++;\nif(hmap[nx][ny]<INF) cnt2++;\nif(cnt1>=hxy){\nmap[x][y]=INF;\nbreak loop;\n}\nif(cnt2>8-hxy){\nque.offerLast(new TPair(ans+1,x,y));\nbreak loop;\n}\n}\n}\n}\nreturn ans;\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.StringTokenizer;\nimport java.util.Deque;\nimport java.util.ArrayDeque;\n\nclass Main{\n\nstatic final PrintWriter out=new PrintWriter(System.out);\nstatic final int INF=Integer.MAX_VALUE/2;\nstatic int[] d={-1,0,1};\n\nstatic class TPair{\nint t;\nint x;\nint y;\nTPair(int t,int x,int y){\nthis.t=t; this.x=x; this.y=y;\n}\n}\n\npublic static void main(String[] args) throws IOException{\nBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\nString line=\"\";\nwhile((line=br.readLine())!=null&&!line.isEmpty()){\nStringTokenizer st=new StringTokenizer(line);\nint h=Integer.parseInt(st.nextToken());\nint w=Integer.parseInt(st.nextToken());\nint[][] map=new int[h][w];\nfor(int i=0;i<h;i++){\nline=br.readLine();\nfor(int j=0;j<w;j++){\nmap[i][j]=(line.charAt(j)=='.')?INF:(int)(line.charAt(j)-'0');\n}\n}\nout.println(bfs(h,w,map));\nout.flush();\n}\n}\n\nprivate static int bfs(int h,int w,int[][] map){\nDeque<TPair> que=new ArrayDeque<TPair>();\nint[][] hmap=new int[h][];\nint ans=-1;\nfor(int i=0;i<h;i++) hmap[i]=map[i].clone();\nfor(int i=0;i<h;i++){\nfor(int j=0;j<w;j++){\nif(map[i][j]!=INF) que.offerLast(new TPair(0,i,j));\n}\n}\nwhile(!que.isEmpty()){\nTPair p=que.pollFirst();\nif(ans!=p.t){\nfor(int i=0;i<h;i++) hmap[i]=map[i].clone();\nans=p.t;\n}\nint x=p.x;\nint y=p.y;\nint nx;\nint ny;\nint cnt1=0;\nint cnt2=0;\nint hxy=hmap[x][y];\nloop:\nfor(int i=0;i<3;i++){\nfor(int j=0;j<3;j++){\nif(i==1&&j==1) continue;\nnx=x+d[i];\nny=y+d[j];\nif(hmap[nx][ny]==INF) cnt1++;\nif(hmap[nx][ny]<INF) cnt2++;\nif(cnt1>=hxy){\nmap[x][y]=INF;\nbreak loop;\n}\nif(cnt2>8-hxy){\nque,offerLast(new TPair(ans+1,x,y));\nbreak loop;\n}\n}\n}\nreturn ans;\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.StringTokenizer;\nimport java.util.Deque;\nimport java.util.ArrayDeque;\n\nclass Main{\n\nstatic final PrintWriter out=new PrintWriter(System.out);\nstatic final int INF=Integer.MAX_VALUE/2;\nstatic int[] d={-1,0,1};\n\nstatic class Pair{\nint x;\nint y;\nPair(int x,int y){\nthis.x=x; this.y=y;\n}\n}\n\npublic static void main(String[] args) throws IOException{\nBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\nString line=\"\";\nwhile((line=br.readLine())!=null&&!line.isEmpty()){\nStringTokenizer st=new StringTokenizer(line);\nint h=Integer.parseInt(st.nextToken());\nint w=Integer.parseInt(st.nextToken());\nint[][] map=new int[h][w];\nfor(int i=0;i<h;i++){\nline=br.readLine();\nfor(int j=0;j<w;j++){\nmap[i][j]=(line.charAt(j)=='.')?INF:(int)(line.charAt(j)-'0');\n}\n}\nint cnt=0;\nwhile(true){\nif(bfs(h,w,map)) cnt++;\nelse break;\n}\nout.println(cnt);\nout.flush();\n}\n}\n\nprivate static boolean bfs(int h,int w,int[][] map){\nDeque<Pair> que=new ArrayDeque<Pair>();\nint[][] hmap=new int[h][];\nboolean update=false;\nfor(int i=0;i<h;i++) hmap[i]=map[i].clone();\nfor(int i=0;i<h;i++){\nfor(int j=0;j<w;j++){\nif(map[i][j]!=INF){\nque.offerLast(new Pair(i,j));\n}\n}\n}\nwhile(!que.isEmpty()){\nPair p=que.pollFirst();\nint x=p.x;\nint y=p.y;\nint nx;\nint ny;\nint cnt1=0;\nint cnt2=0;\nloop:\nfor(int i=0;i<3;i++){\nfor(int j=0;j<3;j++){\nif(i==1&&j==1) continue;\nnx=x+d[i];\nny=y+d[j];\nif(h[nx][ny]==INF) cnt1++;\nelse cnt2++;\nif(cnt1>=h[x][y]){\nmap[x][y]=INF;\nupdate=true;\nbreak loop;\n}\nif(cnt2+h[x][y]<8) break loop;\n}\n}\n}\nreturn update;\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.StringTokenizer;\nimport java.util.Deque;\nimport java.util.ArrayDeque;\n\nclass Main{\n\nstatic final PrintWriter out=new PrintWriter(System.out);\nstatic final int INF=Integer.MAX_VALUE/2;\nstatic int[] d={-1,0,1};\n\nstatic class Pair{\nint x;\nint y;\nPair(int x,int y){\nthis.x=x; this.y=y;\n}\n}\n\npublic static void main(String[] args) throws IOException{\nBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\nString line=\"\";\nwhile((line=br.readLine())!=null&&!line.isEmpty()){\nStringTokenizer st=new StringTokenizer(line);\nint h=Integer.parseInt(st.nextToken());\nint w=Integer.parseInt(st.nextToken());\nint[][] map=new int[h][w];\nfor(int i=0;i<h;i++){\nline=br.readLine();\nfor(int j=0;j<w;j++){\nmap[i][j]=(line.charAt(j)=='.')?INF:(int)(line.charAt(j)-'0');\n}\n}\nint cnt=0;\nwhile(true){\nif(bfs(h,w,map)) cnt++;\nelse break;\n}\nout.println(cnt);\nout.flush();\n}\n}\n\nprivate static boolean bfs(int h,int w,int[][] map){\nDeque<Pair> que=new ArrayDeque<Pair>();\nint[][] hmap=new int[h][];\nboolean update=false;\nfor(int i=0;i<h;i++) hmap[i]=map[i].clone();\nfor(int i=0;i<h;i++){\nfor(int j=0;j<w;j++){\nif(map[i][j]!=INF){\nque.offerLast(new Pair(i,j));\n}\n}\n}\nwhile(!que.isEmpty()){\nPair p=que.pollFirst();\nint x=p.x;\nint y=p.y;\nint nx;\nint ny;\nint cnt1=0;\nint cnt2=0;\nint hxy=hmap[x][y]\nloop:\nfor(int i=0;i<3;i++){\nfor(int j=0;j<3;j++){\nif(i==1&&j==1) continue;\nnx=x+d[i];\nny=y+d[j];\nif(hmap[nx][ny]==INF) cnt1++;\nif(hmap[nx][ny]<INF) cnt2++;\nif(cnt1>=hxy){\nmap[x][y]=INF;\nupdate=true;\nbreak loop;\n}\nif(cnt2>8-hxy) break loop;\n}\n}\n}\nreturn update;\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.StringTokenizer;\nimport java.util.Deque;\nimport java.util.ArrayDeque;\n\nclass Main{\n\nstatic final PrintWriter out=new PrintWriter(System.out);\nstatic final int INF=Integer.MAX_VALUE/2;\nstatic int[] d={-1,0,1};\n\nstatic class Pair{\nint x;\nint y;\nPair(int x,int y){\nthis.x=x; this.y=y;\n}\n}\n\npublic static void main(String[] args) throws IOException{\nBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\nString line=\"\";\nwhile((line=br.readLine())!=null&&!line.isEmpty()){\nStringTokenizer st=new StringTokenizer(line);\nint h=Integer.parseInt(st.nextToken());\nint w=Integer.parseInt(st.nextToken());\nint[][] map=new int[h][w];\nfor(int i=0;i<h;i++){\nline=br.readLine();\nfor(int j=0;j<w;j++){\nmap[i][j]=(line.charAt(j)=='.')?INF:(int)(line.charAt(j)-'0');\n}\n}\nint cnt=0;\nwhile(true){\nif(bfs(h,w,map)) cnt++;\nelse break;\n}\nout.println(cnt);\nout.flush();\n}\n}\n\nprivate static boolean bfs(int h,int w,int[][] map){\nDeque<Pair> que=new ArrayDeque<Pair>();\nint[][] hmap=new int[h][];\nboolean update=false;\nfor(int i=0;i<h;i++) hmap[i]=map[i].clone();\nfor(int i=0;i<h;i++){\nfor(int j=0;j<w;j++){\nif(map[i][j]!=INF){\nque.offerLast(new Pair(i,j));\n}\n}\n}\nwhile(!que.isEmpty()){\nPair p=que.pollFirst();\nint x=p.x;\nint y=p.y;\nint nx;\nint ny;\nint cnt1=0;\nint cnt2=0;\nint hxy=hmap[x][y];\nloop:\nfor(int i=0;i<3;i++){\nfor(int j=0;j<3;j++){\nif(i==1&&j==1) continue;\nnx=x+d[i];\nny=y+d[j];\nif(hxy==INF) cnt1++;\nelse cnt2++;\nif(cnt1>=hxy){\nmap[x][y]=INF;\nupdate=true;\nbreak loop;\n}\nif(cnt2+hxy<8) break loop;\n}\n}\n}\nreturn update;\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.StringTokenizer;\nimport java.util.Deque;\nimport java.util.ArrayDeque;\n\nclass Main{\n\nstatic final PrintWriter out=new PrintWriter(System.out);\nstatic final int INF=Integer.MAX_VALUE/2;\nstatic int[] d={-1,0,1};\n\nstatic class Pair{\nint x;\nint y;\nPair(int x,int y){\nthis.x=x; this.y=y;\n}\n}\n\npublic static void main(String[] args) throws IOException{\nBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\nString line=\"\";\nwhile((line=br.readLine())!=null&&!line.isEmpty()){\nStringTokenizer st=new StringTokenizer(line);\nint h=Integer.parseInt(st.nextToken());\nint w=Integer.parseInt(st.nextToken());\nint[][] map=new int[h][w];\nfor(int i=0;i<h;i++){\nline=br.readLine();\nfor(int j=0;j<w;j++){\nmap[i][j]=(line.charAt(j)=='.')?INF:(int)(line.charAt(j)-'0');\n}\n}\nint cnt=0;\nwhile(true){\nif(bfs(h,w,map)) cnt++;\nelse break;\n}\nout.println(cnt);\nout.flush();\n}\n}\n\nprivate static boolean bfs(int h,int w,int[][] map){\nDeque<Pair> que=new ArrayDeque<Pair>();\nint[][] hmap=new int[h][];\nboolean update=false;\nfor(int i=0;i<h;i++) hmap[i]=map[i].clone();\nfor(int i=0;i<h;i++){\nfor(int j=0;j<w;j++){\nif(map[i][j]!=INF){\nque.offerLast(new Pair(i,j));\n}\n}\n}\nwhile(!que.isEmpty()){\nPair p=que.pollFirst();\nint x=p.x;\nint y=p.y;\nint nx;\nint ny;\nint cnt1=0;\nint cnt2=0;\nloop:\nfor(int i=0;i<3;i++){\nfor(int j=0;j<3;j++){\nif(i==1&&j==1) continue loop;\nnx=x+d[i];\nny=y+d[j];\nif(hmap[nx][ny]==INF) cnt1++;\nif(hmap[nx][ny]<INF) cnt2++;\nif(cnt1>=hmap[x][y]){\nmap[x][y]=INF;\nupdate=true;\nbreak loop;\n}\nif(cnt2>8-hmap[x][y]) break loop;\n}\n}\n}\nreturn update;\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.math.*;\nimport java.awt.geom.*;\nimport java.io.*;\n   \n   \npublic class Main {\n\tstatic int INF = 2 << 29;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint h = sc.nextInt();\n\t\tint w = sc.nextInt();\n\t\tchar[][] map = new char[h][w];\n\t\tfor(int i = 0; i < h; i++) {\n\t\t\tmap[i] = sc.next().toCharArray();\n\t\t}\n\t\tboolean[][] al = new boolean[h][w];\n\t\tArrayDeque<Data> queue = new ArrayDeque<Data>();\n\t\t\n\t\tfor(int i = 0; i < h; i++) {\n\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\tif(al[i][j]) continue;\n\t\t\t\tif(map[i][j] == '.') {\n\t\t\t\t\tal[i][j] = true;\n\t\t\t\t\tfor(int k = 0; k < 9; k++) {\n\t\t\t\t\t\tint ty = i + vy[k];\n\t\t\t\t\t\tint tx = j + vx[k];\n\t\t\t\t\t\tif(ty < 0 || tx < 0 || ty >= h || tx >= w) continue;\n\t\t\t\t\t\tif(al[ty][tx]) continue;\n\t\t\t\t\t\tal[ty][tx] = true;\n\t\t\t\t\t\tif(map[ty][tx] != '.') {\n\t\t\t\t\t\t\tqueue.add(new Data(ty,tx));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint cou = 0;\n\t\twhile(!queue.isEmpty()) {\n\t\t\tcou++;\n\t\t\tArrayDeque<Data> tmp = new ArrayDeque<Data>();\n\t\t\tArrayDeque<Data> er  = new ArrayDeque<Data>();\n\t\t\twhile(!queue.isEmpty()) {\n\t\t\t\tData p = queue.poll();\n\t\t\t\tint count = 0;\n\t\t\t\tfor(int i = 0; i < 9; i++) {\n\t\t\t\t\tint ty = p.y + vy[i];\n\t\t\t\t\tint tx = p.x + vx[i];\n\t\t\t\t\tif(ty < 0 || tx < 0 || ty >= h || tx >= w) continue;\n\t\t\t\t\tif(map[ty][tx] == '.') count++;\n\t\t\t\t}\n\t\t\t\tif(count >= map[p.y][p.x] - '0') {\n\t\t\t\t\ter.add(p);\n\t\t\t\t\tfor(int i = 0; i < 9; i++) {\n\t\t\t\t\t\tint ty = p.y + vy[i];\n\t\t\t\t\t\tint tx = p.x + vx[i];\n\t\t\t\t\t\tif(ty < 0 || tx < 0 || ty >= h || tx >= w) continue;\n\t\t\t\t\t\tif(map[ty][tx] != '.' && !al[ty][tx]) {\n\t\t\t\t\t\t\tal[ty][tx] = true;\n\t\t\t\t\t\t\ttmp.add(new Data(ty,tx));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttmp.add(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(er.isEmpty()) {\n\t\t\t\tcou-=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\twhile(!er.isEmpty()) {\n\t\t\t\tData p = er.poll();\n\t\t\t\tmap[p.y][p.x] = '.';\n\t\t\t}\n\t\t\t\n\t\t\tqueue.addAll(tmp);\n\t\t\ttmp.clear();\n\t\t}\n\t\tSystem.out.println(cou);\n\t\t\n\t\t\n\t\t\n\t\t\n\t}\n\tstatic int[] vx = {-1, 0, 1,-1, 0, 1,-1, 0, 1};\n\tstatic int[] vy = {-1,-1,-1, 0, 0, 0, 1, 1, 1};\n\t\n\tstatic class Data {\n\t\tint y;\n\t\tint x;\n\t\tData(int a, int b) {\n\t\t\ty = a;\n\t\t\tx = b;\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.StringTokenizer;\nimport java.util.Deque;\nimport java.util.ArrayDeque;\n\nclass Main{\n\nstatic final PrintWriter out=new PrintWriter(System.out);\nstatic final int INF=Integer.MAX_VALUE/2;\nstatic int[] d={-1,0,1};\n\nstatic class Pair{\nint x;\nint y;\nPair(int x,int y){\nthis.x=x; this.y=y;\n}\n}\n\npublic static void main(String[] args) throws IOException{\nBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\nString line=\"\";\nwhile((line=br.readLine())!=null&&!line.isEmpty()){\nStringTokenizer st=new StringTokenizer(line);\nint h=Integer.parseInt(st.nextToken());\nint w=Integer.parseInt(st.nextToken());\nint[][] map=new int[h][w];\nfor(int i=0;i<h;i++){\nline=br.readLine();\nfor(int j=0;j<w;j++){\nmap[i][j]=(line.charAt(j)=='.')?INF:(int)(line.charAt(j)-'0');\n}\n}\nint cnt=0;\nwhile(true){\nif(bfs(h,w,map)) cnt++;\nelse break;\n}\nout.println(cnt);\nout.flush();\n}\n}\n\nprivate static boolean bfs(int h,int w,int[][] map){\nDeque<Pair> que=new ArrayDeque<Pair>();\nint[][] hmap=new int[h][];\nboolean update=false;\nfor(int i=0;i<h;i++) hmap[i]=map[i].clone();\nfor(int i=0;i<h;i++){\nfor(int j=0;j<w;j++){\nif(map[i][j]!=INF){\nque.offerLast(new Pair(i,j));\n}\n}\n}\nwhile(!que.isEmpty()){\nPair p=que.pollFirst();\nint x=p.x;\nint y=p.y;\nint nx;\nint ny;\nint cnt=0;\nloop:\nfor(int i=0;i<3;i++){\nfor(int j=0;j<3;j++){\nif(i==1&&j==1) continue loop;\nnx=x+d[i];\nny=y+d[j];\nif(hmap[nx][ny]==INF) cnt++;\nif(cnt>=hmap[x][y]){\nmap[x][y]=INF;\nupdate=true;\nbreak loop;\n}\n}\n}\n}\nreturn update;\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.ArrayList;\nimport java.util.HashMap;\n\npublic class Main {\n\t\n\tpublic static HashMap<String,String> map = new HashMap<>();\n\n\tpublic static void main(String[] args) {\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint h = sc.nextInt();\n\t\tint w = sc.nextInt();\n\t\tint[][] map = new int[h][w];\n\t\tint[][] ck  = new int[h][w];\n\t\tboolean[][] cc = new boolean[h][w];\n\t\tfor(int i = 0; i < h; i++) {\n\t\t\tchar[] mm = sc.next().toCharArray();\n\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\tif(mm[j] == '.') continue;\n\t\t\t\tmap[i][j] = mm[j] - '0';\n\t\t\t}\n\t\t}\n\t\tArrayDeque<Node> q = new ArrayDeque<Node>();\n\t\tArrayDeque<Node> n_q = new ArrayDeque<Node>();\n\t\tint[] vx = {1,1,1,0,0,-1,-1,-1};\n\t\tint[] vy = {1,0,-1,1,-1,1,0,-1};\n\t\tfor(int i = 0; i < h; i++) {\n\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\tif(map[i][j] == 0) {\n\t\t\t\t\tfor(int k = 0; k < 8; k++) {\n\t\t\t\t\t\tint ty = i + vy[k];\n\t\t\t\t\t\tint tx = j + vx[k];\n\t\t\t\t\t\tif(r(h,w,ty,tx) && map[ty][tx] != 0) {\n\t\t\t\t\t\t\tcc[ty][tx] = true;\n\t\t\t\t\t\t\tck[ty][tx]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < h; i++) {\n\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\tif(cc[i][j]) {\n\t\t\t\t\tq.add(new Node(i,j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tboolean o = true;\n\t\tint ans = 0;\n\t\tArrayDeque<Node> er = new ArrayDeque<Node>();\n\t\twhile(o) {\n\t\t\to = false;\n\t\t\twhile(!q.isEmpty()) {\n\t\t\t\tNode n = q.poll();\n\t\t\t\tif(map[n.h][n.w] == 0) continue;\n\t\t\t\t\n\t\t\t\tif(ck[n.h][n.w] >= map[n.h][n.w]) {\n\t\t\t\t\to = true;\n\t\t\t\t\ter.add(n);\n\t\t\t\t\tfor(int i = 0; i < 8; i++) {\n\t\t\t\t\t\tint tx = n.w + vx[i];\n\t\t\t\t\t\tint ty = n.h + vy[i];\n\t\t\t\t\t\tif(r(h,w,ty,tx) && map[ty][tx] != 0 && !cc[ty][tx]) {\n\t\t\t\t\t\t\tn_q.add(new Node(ty,tx));\n\t\t\t\t\t\t\tcc[ty][tx] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcc[n.h][n.w] = false;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\twhile(!er.isEmpty()) {\n\t\t\t\tNode p = er.poll();\n\t\t\t\tfor(int i = 0; i < 8; i++) {\n\t\t\t\t\tint tx = p.w + vx[i];\n\t\t\t\t\tint ty = p.h + vy[i];\n\t\t\t\t\tif(r(h,w,ty,tx) && map[ty][tx] != 0) {\n\t\t\t\t\t\tck[ty][tx]++;\n\t\t\t\t\t\tif(!cc[ty][tx]) {\n\t\t\t\t\t\t\tn_q.add(new Node(ty,tx));\n\t\t\t\t\t\t\tcc[ty][tx] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmap[p.h][p.w] = 0;\n\t\t\t}\n\t\t\tArrayDeque<Node> tmp = q;\n\t\t\tq = n_q;\n\t\t\tn_q = tmp;\n\t\t\tif(o) ans++;\n\t\t}\n\t\tSystem.out.println(ans);\n\t\t\n\t}\n\t\n\tstatic boolean r(int a, int b, int c, int d) {\n\t\tif(c < 0 || d < 0 || c >= a || d >= b) return false;\n\t\treturn true;\n\t}\n\t\n\tstatic class Node {\n\t\tint h;\n\t\tint w;\n\t\tNode(int a, int b) {\n\t\t\th = a;\n\t\t\tw = b;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.StringTokenizer;\nimport java.util.Deque;\nimport java.util.ArrayDeque;\n\nclass Main{\n\nstatic final PrintWriter out=new PrintWriter(System.out);\nstatic final int INF=Integer.MAX_VALUE/2;\nstatic int[] d={-1,0,1};\n\nstatic class Pair{\nint x;\nint y;\nPair(int x,int y){\nthis.x=x; this.y=y;\n}\n}\n\npublic static void main(String[] args) throws IOException{\nBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\nString line=\"\";\nwhile((line=br.readLine())!=null&&!line.isEmpty()){\nStringTokenizer st=new StringTokenizer(line);\nint h=Integer.parseInt(st.nextToken());\nint w=Integer.parseInt(st.nextToken());\nint[][] map=new int[h][w];\nfor(int i=0;i<h;i++){\nline=br.readLine();\nfor(int j=0;j<w;j++){\nmap[i][j]=(line.charAt(j)=='.')?INF:(int)(line.charAt(j)-'0');\n}\n}\nint cnt=0;\nwhile(true){\nif(bfs(h,w,map)) cnt++;\nelse break;\n}\nout.println(cnt);\nout.flush();\n}\n}\n\nprivate static boolean bfs(int h,int w,int[][] map){\nDeque<Pair> que=new ArrayDeque<Pair>();\nint[][] hmap=new int[h][];\nboolean update=false;\nfor(int i=0;i<h;i++) hmap[i]=map[i].clone();\nfor(int i=0;i<h;i++){\nfor(int j=0;j<w;j++){\nif(map[i][j]!=INF){\nque.offerLast(new Pair(i,j));\n}\n}\n}\nwhile(!que.isEmpty()){\nPair p=que.pollFirst();\nint x=p.x;\nint y=p.y;\nint nx;\nint ny;\nint cnt=0;\nloop:\nfor(int i=0;i<3;i++){\nfor(int j=0;j<3;j++){\nif(i==1&&j==1) continue;\nnx=x+d[i];\nny=y+d[j];\nif(hmap[nx][ny]==INF) cnt++;\nif(cnt>=hmap[x][y]){\nmap[x][y]=INF;\nupdate=true;\nbreak loop;\n}\n}\n}\n}\nreturn update;\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.StringTokenizer;\nimport java.util.Deque;\nimport java.util.ArrayDeque;\n\nclass Main{\n\nstatic final PrintWriter out=new PrintWriter(System.out);\nstatic final int INF=Integer.MAX_VALUE/2;\n\nstatic class Pair{\nint x;\nint y;\nPair(int x,int y){\nthis.x=x; this.y=y;\n}\n}\n\npublic static void main(String[] args) throws IOException{\nBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\nString line=\"\";\nwhile((line=br.readLine())!=null&&!line.isEmpty()){\nStringTokenizer st=new StringTokenizer(line);\nint h=Integer.parseInt(st.nextToken());\nint w=Integer.parseInt(st.nextToken());\nint[][] map=new int[h][w];\nfor(int i=0;i<h;i++){\nline=br.readLine();\nfor(int j=0;j<w;j++){\nmap[i][j]=(line.charAt(j)=='.')?INF:(int)(line.charAt(j)-'0');\n}\n}\nint cnt=0;\nwhile(true){\nif(bfs(h,w,map)) cnt++;\nelse break;\n}\nout.println(cnt);\nout.flush();\n}\n}\n\nprivate static boolean bfs(int h,int w,int[][] map){\nDeque<Pair> que=new ArrayDeque<Pair>();\nint[][] hmap=new int[h][];\nboolean update=false;\nfor(int i=0;i<h;i++) hmap[i]=map[i].clone();\nfor(int i=0;i<h;i++){\nfor(int j=0;j<w;j++){\nif(map[i][j]!=INF){\nque.offerLast(new Pair(i,j));\n}\n}\n}\nwhile(!que.isEmpty()){\nPair p=que.pollFirst();\nint x=p.x;\nint y=p.y;\nint nx;\nint ny;\nint cnt=0;\nint[] d={-1,0,1};\nfor(int i=0;i<3;i++){\nfor(int j=0;j<3;j++){\nnx=x+d[i];\nny=y+d[j];\nif(hmap[nx][ny]==INF) cnt++;\n}\n}\nif(cnt>=hmap[x][y]){\nmap[x][y]=INF;\nupdate=true;\n}\n}\nreturn update;\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.StringTokenizer;\nimport java.util.Deque;\nimport java.util.ArrayDeque;\n\nclass Main{\n\nstatic final PrintWriter out=new PrintWriter(System.out);\nstatic final int INF=Integer.MAX_VALUE/2;\nstatic int[] d={-1,0,1};\n\nstatic class TPair{\nint t;\nint x;\nint y;\nTPair(int t,int x,int y){\nthis.t=t; this.x=x; this.y=y;\n}\n}\n\npublic static void main(String[] args) throws IOException{\nBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\nString line=\"\";\nwhile((line=br.readLine())!=null&&!line.isEmpty()){\nStringTokenizer st=new StringTokenizer(line);\nint h=Integer.parseInt(st.nextToken());\nint w=Integer.parseInt(st.nextToken());\nint[][] map=new int[h][w];\nfor(int i=0;i<h;i++){\nline=br.readLine();\nfor(int j=0;j<w;j++){\nmap[i][j]=(line.charAt(j)=='.')?INF:(int)(line.charAt(j)-'0');\n}\n}\nout.println(bfs(h,w,map));\nout.flush();\n}\n}\n\nprivate static int bfs(int h,int w,int[][] map){\nDeque<TPair> que=new ArrayDeque<TPair>();\nint[][] hmap=new int[h][];\nint ans=-1;\nfor(int i=0;i<h;i++) hmap[i]=map[i].clone();\nfor(int i=0;i<h;i++){\nfor(int j=0;j<w;j++){\nif(map[i][j]!=INF) que.offerLast(new TPair(0,i,j));\n}\n}\nwhile(!que.isEmpty()){\nTPair p=que.pollFirst();\nif(ans!=p.t){\nfor(int i=0;i<h;i++) hmap[i]=map[i].clone();\nans=p.t;\n}\nint x=p.x;\nint y=p.y;\nint nx;\nint ny;\nint cnt1=0;\nint cnt2=0;\nint hxy=hmap[x][y];\nloop:\nfor(int i=0;i<3;i++){\nfor(int j=0;j<3;j++){\nif(i==1&&j==1) continue;\nnx=x+d[i];\nny=y+d[j];\nif(hmap[nx][ny]==INF) cnt1++;\nif(hmap[nx][ny]<INF) cnt2++;\nif(cnt1>=hxy){\nmap[x][y]=INF;\nbreak loop;\n}\nif(cnt2>8-hxy){\nque.offerLast(new TPair(ans+1,x,y));\nbreak loop;\n}\n}\n}\n}\nreturn ans;\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.StringTokenizer;\nimport java.util.Deque;\nimport java.util.ArrayDeque;\n\nclass Main{\n\nstatic final PrintWriter out=new PrintWriter(System.out);\nstatic final int INF=Integer.MAX_VALUE/2;\nstatic int[] d={-1,0,1};\n\nstatic class Pair{\nint x;\nint y;\nPair(int x,int y){\nthis.x=x; this.y=y;\n}\n}\n\npublic static void main(String[] args) throws IOException{\nBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\nString line=\"\";\nwhile((line=br.readLine())!=null&&!line.isEmpty()){\nStringTokenizer st=new StringTokenizer(line);\nint h=Integer.parseInt(st.nextToken());\nint w=Integer.parseInt(st.nextToken());\nint[][] map=new int[h][w];\nfor(int i=0;i<h;i++){\nline=br.readLine();\nfor(int j=0;j<w;j++){\nmap[i][j]=(line.charAt(j)=='.')?INF:(int)(line.charAt(j)-'0');\n}\n}\nint cnt=0;\nwhile(true){\nif(bfs(h,w,map)) cnt++;\nelse break;\n}\nout.println(cnt);\nout.flush();\n}\n}\n\nprivate static boolean bfs(int h,int w,int[][] map){\nDeque<Pair> que=new ArrayDeque<Pair>();\nint[][] hmap=new int[h][];\nboolean update=false;\nfor(int i=0;i<h;i++) hmap[i]=map[i].clone();\nfor(int i=0;i<h;i++){\nfor(int j=0;j<w;j++){\nif(map[i][j]!=INF){\nque.offerLast(new Pair(i,j));\n}\n}\n}\nwhile(!que.isEmpty()){\nPair p=que.pollFirst();\nint x=p.x;\nint y=p.y;\nint nx;\nint ny;\nint cnt1=0;\nint cnt2=0;\nloop:\nfor(int i=0;i<3;i++){\nfor(int j=0;j<3;j++){\nif(i==1&&j==1) continue;\nnx=x+d[i];\nny=y+d[j];\nif(hmap[nx][ny]==INF) cnt1++;\nif(hmap[nx][ny]<INF) cnt2++;\nif(cnt1>=hmap[x][y]){\nmap[x][y]=INF;\nupdate=true;\nbreak loop;\n}\nif(cnt2>8-hmap[x][y]) break loop;\n}\n}\n}\nreturn update;\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.StringTokenizer;\nimport java.util.Deque;\nimport java.util.ArrayDeque;\n \nclass Main{\n \nstatic final PrintWriter out=new PrintWriter(System.out);\nstatic final int INF=Integer.MAX_VALUE/2;\nstatic int[] d={-1,0,1};\n \nstatic class Pair{\nint x;\nint y;\nPair(int x,int y){\nthis.x=x; this.y=y;\n}\n}\n \npublic static void main(String[] args) throws IOException{\nBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\nString line=\"\";\nwhile((line=br.readLine())!=null&&!line.isEmpty()){\nStringTokenizer st=new StringTokenizer(line);\nint h=Integer.parseInt(st.nextToken());\nint w=Integer.parseInt(st.nextToken());\nint[][] map=new int[h][w];\nfor(int i=0;i<h;i++){\nline=br.readLine();\nfor(int j=0;j<w;j++){\nmap[i][j]=(line.charAt(j)=='.')?INF:(int)(line.charAt(j)-'0');\n}\n}\nint cnt=0;\nwhile(true){\nif(bfs(h,w,map)) cnt++;\nelse break;\n}\nout.println(cnt);\nout.flush();\n}\n}\n \nprivate static boolean bfs(int h,int w,int[][] map){\nDeque<Pair> que=new ArrayDeque<Pair>();\nint[][] hmap=new int[h][];\nboolean update=false;\nfor(int i=0;i<h;i++) hmap[i]=map[i].clone();\nfor(int i=0;i<h;i++){\nfor(int j=0;j<w;j++){\nif(map[i][j]!=INF){\nque.offerLast(new Pair(i,j));\n}\n}\n}\nwhile(!que.isEmpty()){\nPair p=que.pollFirst();\nint x=p.x;\nint y=p.y;\nint nx;\nint ny;\nint cnt1=0;\nint cnt2=0;\nloop:\nfor(int i=0;i<3;i++){\nfor(int j=0;j<3;j++){\nif(i==1&&j==1) continue;\nnx=x+d[i];\nny=y+d[j];\nif(hmap[nx][ny]==INF) cnt1++;\nelse cnt2++;\nif(cnt1>=hmap[x][y]){\nmap[x][y]=INF;\nupdate=true;\nbreak loop;\n}\nif(cnt2+hmap[x][y]<8) break loop;\n}\n}\n}\nreturn update;\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.StringTokenizer;\nimport java.util.Deque;\nimport java.util.ArrayDeque;\n\nclass Main{\n\nstatic final PrintWriter out=new PrintWriter(System.out);\nstatic final int INF=Integer.MAX_VALUE/2;\n\nstatic class Pair{\nint x;\nint y;\nPair(int x,int y){\nthis.x=x; this.y=y;\n}\n}\n\npublic static void main(String[] args) throws IOException{\nBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\nString line=\"\";\nwhile((line=br.readLine())!=null&&!line.isEmpty()){\nStringTokenizer st=new StringTokenizer(line);\nint h=Integer.parseInt(st.nextToken());\nint w=Integer.parseInt(st.nextToken());\nint[][] map=new int[h][w];\nfor(int i=0;i<h;i++){\nline=br.readLine();\nfor(int j=0;j<w;j++){\nmap[i][j]=(line.charAt(j)=='.')?INF:(int)(line.charAt(j)-'0');\n}\n}\nint cnt=0;\nwhile(true){\nif(bfs(h,w,map)) cnt++;\nelse break;\n}\nout.println(cnt);\nout.flush();\n}\n}\n\nprivate static boolean bfs(int h,int w,int[][] map){\nDeque<Pair> que=new ArrayDeque<Pair>();\nint[][] hmap=new int[h][];\nboolean update=false;\nfor(int i=0;i<h;i++) hmap[i]=map[i].clone();\nfor(int i=0;i<h;i++){\nfor(int j=0;j<w;j++){\nif(map[i][j]!=INF){\nque.offerLast(new Pair(i,j));\n}\n}\n}\nwhile(!que.isEmpty()){\nPair p=que.pollFirst();\nint x=p.x;\nint y=p.y;\nint nx;\nint ny;\nint cnt=0;\nint[] d={-1,0,1};\nloop:\nfor(int i=0;i<3;i++){\nfor(int j=0;j<3;j++){\nnx=x+d[i];\nny=y+d[j];\nif(hmap[nx][ny]==INF) cnt++;\nif(cnt>=hmap[x][y]){\nmap[x][y]=INF;\nupdate=true;\nbreak loop;\n}\n}\n}\n}\nreturn update;\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.StringTokenizer;\nimport java.util.Deque;\nimport java.util.ArrayDeque;\n\nclass Main{\n\nstatic final PrintWriter out=new PrintWriter(System.out);\nstatic final int INF=Integer.MAX_VALUE/2;\nstatic int[] d={-1,0,1};\n\nstatic class TPair{\nint t;\nint x;\nint y;\nTPair(int t,int x,int y){\nthis.t=t; this.x=x; this.y=y;\n}\n}\n\npublic static void main(String[] args) throws IOException{\nBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\nString line=\"\";\nwhile((line=br.readLine())!=null&&!line.isEmpty()){\nStringTokenizer st=new StringTokenizer(line);\nint h=Integer.parseInt(st.nextToken());\nint w=Integer.parseInt(st.nextToken());\nint[][] map=new int[h][w];\nfor(int i=0;i<h;i++){\nline=br.readLine();\nfor(int j=0;j<w;j++){\nmap[i][j]=(line.charAt(j)=='.')?INF:(int)(line.charAt(j)-'0');\n}\n}\nout.println(bfs(h,w,map));\nout.flush();\n}\n}\n\nprivate static int bfs(int h,int w,int[][] map){\nDeque<TPair> que=new ArrayDeque<TPair>();\nint[][] hmap=new int[h][];\nboolean update=true;\nint ans=-1;\nfor(int i=0;i<h;i++){\nfor(int j=0;j<w;j++){\nif(map[i][j]!=INF) que.offerLast(new TPair(0,i,j));\n}\n}\nwhile(!que.isEmpty()){\nTPair p=que.pollFirst();\nif(ans!=p.t){\nif(update){\nupdate=false;\nfor(int i=0;i<h;i++) hmap[i]=map[i].clone();\nans=p.t;\n}\nelse break;\n}\nint x=p.x;\nint y=p.y;\nint nx;\nint ny;\nint cnt1=0;\nint cnt2=0;\nint hxy=hmap[x][y];\nloop:\nfor(int i=0;i<3;i++){\nfor(int j=0;j<3;j++){\nif(i==1&&j==1) continue;\nnx=x+d[i];\nny=y+d[j];\nif(hmap[nx][ny]==INF) cnt1++;\nif(hmap[nx][ny]<INF) cnt2++;\nif(cnt1>=hxy){\nmap[x][y]=INF;\nupdate=true;\nbreak loop;\n}\nif(cnt2>8-hxy){\nque.offerLast(new TPair(ans+1,x,y));\nbreak loop;\n}\n}\n}\n}\nreturn ans;\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.StringTokenizer;\nimport java.util.Deque;\nimport java.util.ArrayDeque;\n\nclass Main{\n\nstatic final PrintWriter out=new PrintWriter(System.out);\nstatic final int INF=Integer.MAX_VALUE/2;\n\nclass Pair{\nint x;\nint y;\nPair(int x,int y){\nthis.x=x; this.y=y;\n}\n}\n\npublic static void main(String[] args) throws IOException{\nBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\nString line=\"\";\nwhile((line=br.readLine())!=null&&!line.isEmpty()){\nStringTokenizer st=new StringTokenizer(line);\nint h=Integer.parseInt(st.nextToken());\nint w=Integer.parseInt(st.nextToken());\nint[][] map=new int[h][w];\nfor(int i=0;i<h;i++){\nline=br.readLine();\nfor(int j=0;j<w;j++){\nmap[i][j]=(line.charAt(j)=='.')?INF:(int)(line.charAt(j)-'0');\n}\n}\nint cnt=0;\nwhile(true){\nif(bfs(h,w,map)) cnt++;\nelse break;\n}\nout.println(cnt);\nout.flush();\n}\n}\n\nprivate static boolean bfs(int h,int w,int[][] map){\nDeque<Pair> que=new ArrayDeque<Pair>();\nint[][] hmap=new int[h][];\nboolean update=false;\nfor(int i=0;i<h;i++) hmap[i]=map[i].clone();\nfor(int i=0;i<h;i++){\nfor(int j=0;j<w;j++){\nif(map[i][j]!=INF){\nque.offerLast(new Pair(i,j));\n}\n}\n}\nwhile(!que.isEmpty()){\nPair p=que.pollFirst();\nint x=p.x;\nint y=p.y;\nint nx;\nint ny;\nint cnt=0;\nint[] d={-1,0,1};\nfor(int i=0;i<3;i++){\nfor(int j=0;j<3;j++){\nnx=x+d[i];\nny=y+d[j];\nif(hmap[nx][ny]==INF) cnt++;\n}\n}\nif(cnt>=hmap[x][y]){\nmap[x][y]=INF;\nupdate=true;\n}\n}\nreturn update;\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.math.*;\nimport java.awt.geom.*;\nimport java.io.*;\n   \n   \npublic class Main {\n\tstatic int INF = 2 << 29;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint h = sc.nextInt();\n\t\tint w = sc.nextInt();\n\t\tchar[][] map = new char[h][w];\n\t\tfor(int i = 0; i < h; i++) {\n\t\t\tmap[i] = sc.next().toCharArray();\n\t\t}\n\t\tboolean[][] al = new boolean[h][w];\n\t\tArrayDeque<Data> queue = new ArrayDeque<Data>();\n\t\t\n\t\tfor(int i = 0; i < h; i++) {\n\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\tif(al[i][j]) continue;\n\t\t\t\tif(map[i][j] == '.') {\n\t\t\t\t\tal[i][j] = true;\n\t\t\t\t\tfor(int k = 0; k < 8; k++) {\n\t\t\t\t\t\tint ty = i + vy[k];\n\t\t\t\t\t\tint tx = j + vx[k];\n\t\t\t\t\t\tif(ty < 0 || tx < 0 || ty >= h || tx >= w) continue;\n\t\t\t\t\t\tif(al[ty][tx]) continue;\n\t\t\t\t\t\tal[ty][tx] = true;\n\t\t\t\t\t\tif(map[ty][tx] != '.') {\n\t\t\t\t\t\t\tqueue.add(new Data(ty,tx));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint cou = 0;\n\t\twhile(!queue.isEmpty()) {\n\t\t\tcou++;\n\t\t\tboolean ok = false;\n\t\t\tArrayDeque<Data> tmp = new ArrayDeque<Data>();\n\t\t\tArrayDeque<Data> er  = new ArrayDeque<Data>();\n\t\t\twhile(!queue.isEmpty()) {\n\t\t\t\tData p = queue.poll();\n\t\t\t\tint count = 0;\n\t\t\t\tfor(int i = 0; i < 8; i++) {\n\t\t\t\t\tint ty = p.y + vy[i];\n\t\t\t\t\tint tx = p.x + vx[i];\n\t\t\t\t\tif(ty < 0 || tx < 0 || ty >= h || tx >= w) continue;\n\t\t\t\t\tif(map[ty][tx] == '.') count++;\n\t\t\t\t}\n\t\t\t\tif(count >= map[p.y][p.x] - '0') {\n\t\t\t\t\tok = true;\n\t\t\t\t\ter.add(p);\n\t\t\t\t\tfor(int i = 0; i < 8; i++) {\n\t\t\t\t\t\tint ty = p.y + vy[i];\n\t\t\t\t\t\tint tx = p.x + vx[i];\n\t\t\t\t\t\tif(ty < 0 || tx < 0 || ty >= h || tx >= w) continue;\n\t\t\t\t\t\tif(map[ty][tx] != '.' && !al[ty][tx]) {\n\t\t\t\t\t\t\tal[ty][tx] = true;\n\t\t\t\t\t\t\ttmp.add(new Data(ty,tx));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttmp.add(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(!er.isEmpty()) {\n\t\t\t\tData p = er.poll();\n\t\t\t\tmap[p.y][p.x] = '.';\n\t\t\t}\n\t\t\tif(!ok) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tqueue.addAll(tmp);\n\t\t\ttmp.clear();\n\t\t}\n\t\t\n\t\tSystem.out.println(cou-1);\n\t\t\n\t\t\n\t\t\n\t\t\n\t}\n\tstatic int[] vx = {-1,0,1,-1,0,1,-1,0,1};\n\tstatic int[] vy = {-1,-1,-1,0,0,0,1,1,1};\n\t\n\tstatic class Data {\n\t\tint y;\n\t\tint x;\n\t\tData(int a, int b) {\n\t\t\ty = a;\n\t\t\tx = b;\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main {\n    static int W;\n    static int H;\n    static int s[][];\n    public static void main(String args[]) {\n        Scanner sc = new Scanner(System.in);\n        H = sc.nextInt();\n        W = sc.nextInt();\n        s = new int[H][W];\n        for (int i = 0; i < H; i++) {\n            String line = sc.next();\n            for (int j = 0; j < W; j++) {\n                char c = line.charAt(j);\n                if (c == '.') {\n                    s[i][j] = 0;\n                } else {\n                    s[i][j] = c - '0';\n                }\n            }\n        }\n        int count = 0;\n        Set<Integer> set = rush0();\n        while (set.size() > 0) {\n            for(int x: set) {\n                int i = x >> 16;\n                int j = x & 0xffff;\n                s[i][j] = 0;\n            }\n            count++;\n            set = rush1(set);\n        }\n        System.out.printf(\"%d\\n\", count);\n    }\n\n    static Set<Integer> rush1(Set<Integer> set) {\n        Set<Integer> set2 = new HashSet<Integer>();\n        for(int x: set) {\n            int p = x >> 16;\n            int q = x & 0xffff;\n            for (int i = p-1; i <= p+1; i++) {\n                for (int j = q-1; j <= q+1; j++) {\n                    if (i == p && j == q) continue;\n                    if (s[i][j] > 0 && count(i, j) >= s[i][j]) {\n                        set2.add(i << 16 | j);\n                    }\n                }\n            }\n        }\n        return set2;\n    }\n\n    static int count(int p, int q) {\n        int c = 0;\n        for (int i = p-1; i <= p+1; i++) {\n            for (int j = q-1; j <= q+1; j++) {\n                if (s[i][j] == 0) c++;\n            }\n        }\n        return c;\n    }\n\n    static Set<Integer> rush0() {\n        Set<Integer> set = new HashSet<Integer>();\n        for (int i = 1; i < H-1; i++) {\n            for (int j = 1; j < W-1; j++) {\n                if (s[i][j] > 0 && count(i, j) >= s[i][j]) {\n                    set.add(i << 16 | j);\n                }\n            }\n        }\n        return set;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.StringTokenizer;\nimport java.util.Deque;\nimport java.util.ArrayDeque;\n\nclass Main{\n\nstatic final PrintWriter out=new PrintWriter(System.out);\nstatic final int INF=Integer.MAX_VALUE/2;\nstatic int[] d={-1,0,1};\n\nstatic class Pair{\nint x;\nint y;\nPair(int x,int y){\nthis.x=x; this.y=y;\n}\n}\n\npublic static void main(String[] args) throws IOException{\nBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\nString line=\"\";\nwhile((line=br.readLine())!=null&&!line.isEmpty()){\nStringTokenizer st=new StringTokenizer(line);\nint h=Integer.parseInt(st.nextToken());\nint w=Integer.parseInt(st.nextToken());\nint[][] map=new int[h][w];\nfor(int i=0;i<h;i++){\nline=br.readLine();\nfor(int j=0;j<w;j++){\nmap[i][j]=(line.charAt(j)=='.')?INF:(int)(line.charAt(j)-'0');\n}\n}\nint cnt=0;\nwhile(true){\nif(bfs(h,w,map)) cnt++;\nelse break;\n}\nout.println(cnt);\nout.flush();\n}\n}\n\nprivate static boolean bfs(int h,int w,int[][] map){\nDeque<Pair> que=new ArrayDeque<Pair>();\nint[][] hmap=new int[h][];\nboolean update=false;\nfor(int i=0;i<h;i++) hmap[i]=map[i].clone();\nfor(int i=0;i<h;i++){\nfor(int j=0;j<w;j++){\nif(map[i][j]!=INF){\nque.offerLast(new Pair(i,j));\n}\n}\n}\nwhile(!que.isEmpty()){\nPair p=que.pollFirst();\nint x=p.x;\nint y=p.y;\nint nx;\nint ny;\nint cnt1=0;\nint hxy=hmap[x][y];\nloop:\nfor(int i=0;i<3;i++){\nfor(int j=0;j<3;j++){\nif(i==1&&j==1) continue;\nnx=x+d[i];\nny=y+d[j];\nif(hxy==INF) cnt1++;\nelse cnt2++;\nif(cnt1>=hxy){\nmap[x][y]=INF;\nupdate=true;\nbreak loop;\n}\nif(cnt2+hxy<8) break loop;\n}\n}\n}\nreturn update;\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.StringTokenizer;\nimport java.util.Deque;\nimport java.util.ArrayDeque;\n\nclass Main{\n\nstatic final PrintWriter out=new PrintWriter(System.out);\nstatic final int INF=Integer.MAX_VALUE/2;\n\nclass Pair{\nint x;\nint y;\nPair(int x,int y){\nthis.x=x; this.y=y;\n}\n}\n\npublic staitc void main(String[] args) throws IOException{\nBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\nString line=\"\";\nwhile((line=br.readLine())!=null&&!line.isEmpty()){\nStringTokenizer st=new StringTokenizer(line);\nint h=Integer.parseInt(st.nextToken());\nint w=Integer.parseInt(st.nextToken());\nint[][] map=new int[h][w];\nfor(int i=0;i<h;i++){\nline=br.readLine();\nfor(int j=0;j<w;j++){\nmap[i][j]=(line.charAt(j)=='.')?INF:(int)(line.charAt(j)-'0');\n}\n}\nint cnt=0;\nwhile(true){\nif(bfs(h,w,map)) cnt++;\nelse break;\n}\nout.println(cnt);\nout.flush();\n}\n}\n\nprivate static boolean bfs(int h,int w,int[][] map){\nDeque<Pair> que=new ArrayDeque<Pair>();\nint[][] hmap=new int[h][];\nboolean update=false;\nfor(int i=0;i<h;i++) hmap[i]=map[i].clone();\nfor(int i=0;i<h;i++){\nfor(int j=0;j<w;j++){\nif(map[i][j]!=INF){\nque.offerLast(new Pair(i,j));\n}\n}\n}\nwhile(!que.isEmpty()){\nPair p=que.pollFirst();\nint x=p.x;\nint y=p.y;\nint nx;\nint ny;\nint cnt=0;\nint[] d={-1,0,1};\nfor(int i=0;i<3;i++){\nfor(int j=0;j<3;j++){\nnx=x+d[i];\nny=y+d[j];\nif(hmap[nx][ny]==INF) cnt++;\n}\n}\nif(cnt>=hmap[x][y]){\nmap[x][y]=INF;\nupdate=true;\n}\n}\nreturn update;\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    private static final int[] DIR = {-1, -1, 1, 1, -1, 0, 1, 0, -1};\n\n    public static void main(String[] args) {\n        int[][] fld;\n        int h, w;\n        try(Scanner scn = new Scanner(System.in)) {\n            h = scn.nextInt();\n            w = scn.nextInt();\n            fld = new int[h][w];\n            for(int i = 0; i < h; i++) {\n                char[] ary = scn.next().toCharArray();\n                for(int j = 0; j < w; j++) {\n                    try {\n                        fld[i][j] = Integer.parseInt(String.valueOf(ary[j]));\n                    } catch(NumberFormatException e) {\n                        fld[i][j] = 0;\n                    }\n                }\n            }\n        }\n\n        int ans = -1;\n        ArrayList<int[]> list = null;\n        while(list == null || list.size() > 0) {\n            list = new ArrayList<>();\n            for(int i = 1; i < ~-h; i++) {\n                for(int j = 1; j < ~-w; j++) {\n                    if(fld[i][j] > 0) {\n                        int cnt = 0;\n                        for(int d = 0; d < 8; d++) {\n                            if(fld[i + DIR[d]][j + DIR[-~d]] == 0) {\n                                cnt++;\n                            }\n                        }\n                        if(fld[i][j] <= cnt) {\n                            list.add(new int[] {i, j});\n                        }\n                    }\n                }\n            }\n            for(int[] coord : list) {\n                fld[coord[0]][coord[1]] = 0;\n            }\n            ans++;\n        }\n        System.out.println(ans);\n    }\n}"
  },
  {
    "language": "Java",
    "code": "public class Main{\n  static int head, tail;\n  static int infi = 1000001;\n  public void run(java.io.InputStream in, java.io.PrintStream out){\n    java.util.Scanner sc = new java.util.Scanner(in);\n    int h, w, i, j, k, x, y, max;\n    int[] nowx, nowy;\n    int[][] c;\n    char[][] f;\n    String s;\n\n    h = sc.nextInt(); w = sc.nextInt();\n    c = new int[h][w]; f = new char[h][w];\n    nowx = new int[h * w]; nowy = new int[h * w];\n    for(i = 0;i < h;i++){\n      s = sc.next();\n      for(j = 0;j < w;j++){\n        f[i][j] = s.charAt(j);\n        c[i][j] = infi;\n        if(f[i][j] == '.')c[i][j] = 0;\n      }\n    }\n\n    for(i = 0;i < h;i++)for(j = 0;j < w;j++){\n      if(judge(c, f, i, j, h, w))enqueuexy(nowx, nowy, h * w, i, j);\n      for(;head != tail;){\n        x = dequeuex(nowx, h * w); y = dequeuey(nowy, h * w);\n        if(judge(c, f, x - 1, y - 1, h, w))\n          enqueuexy(nowx, nowy, h * w, x - 1, y - 1);\n        if(judge(c, f, x - 1, y, h, w))\n          enqueuexy(nowx, nowy, h * w, x - 1, y);\n        if(judge(c, f, x - 1, y + 1, h, w))\n          enqueuexy(nowx, nowy, h * w, x - 1, y + 1);\n        if(judge(c, f, x, y + 1, h, w))\n          enqueuexy(nowx, nowy, h * w, x, y + 1);\n        if(judge(c, f, x + 1, y + 1, h, w))\n          enqueuexy(nowx, nowy, h * w, x + 1, y + 1);\n        if(judge(c, f, x + 1, y, h, w))\n          enqueuexy(nowx, nowy, h * w, x + 1, y);\n        if(judge(c, f, x + 1, y - 1, h, w))\n          enqueuexy(nowx, nowy, h * w, x + 1, y - 1);\n        if(judge(c, f, x, y - 1, h, w))\n          enqueuexy(nowx, nowy, h * w, x, y - 1);\n      }\n    }\n\n    max = 0;\n    for(i = 0;i < h;i++)for(j = 0;j < w;j++)\n      if(max < c[i][j] && c[i][j] != infi)max = c[i][j];\n\n    out.println(max);\n\n    sc.close();\n  }\n  public static void main(String[] args){\n    (new Main()).run(System.in, System.out);\n  }\n  private static boolean judge(int[][] c, char[][] f,\n                                  int i, int j, int h, int w){\n    int count, a;\n    int[] d;\n    d = new int[8];\n\n    if(f[i][j] != '.' && f[i][j] != '9'){\n      count = dotcount(c, d, i, j, h, w);\n      a = (int)(f[i][j] - '0');\n      if(count >= a){\n        sort(d, count);\n        if(c[i][j] > d[a - 1] + 1){\n          c[i][j] = d[a - 1] + 1; return true;\n        }\n      }\n    }\n    return false;\n  }\n  private static int dotcount(int[][] c, int[] d, int i, int j, int h, int w){\n    int count = 0;\n    if(i != 0 && j != 0 && c[i - 1][j - 1] < infi){\n      d[count] = c[i - 1][j - 1]; count++;\n    }\n    if(j != 0 && c[i][j - 1] < infi){\n      d[count] = c[i][j - 1]; count++;\n    }\n    if(i != h - 1 && j != 0 && c[i + 1][j - 1] < infi){\n      d[count] = c[i + 1][j - 1]; count++;\n    }\n    if(i != h - 1 && c[i + 1][j] < infi){\n      d[count] = c[i + 1][j]; count++;\n    }\n    if(i != h - 1 && j != w - 1 && c[i + 1][j + 1] < infi){\n      d[count] = c[i + 1][j + 1]; count++;\n    }\n    if(j != w - 1 && c[i][j + 1] < infi){\n      d[count] = c[i][j + 1]; count++;\n    }\n    if(i != 0 && j != w - 1 && c[i - 1][j + 1] < infi){\n      d[count] = c[i - 1][j + 1]; count++;\n    }\n    if(i != 0 && c[i - 1][j] < infi){\n      d[count] = c[i - 1][j]; count++;\n    }\n    return count;\n  }\n\n  private static void sort(int[] d, int n){\n    int i, j, tmp;\n    for(i = 0;i < n - 1;i++)for(j = 0;j < n - 1 - i;j++)if(d[j] > d[j + 1]){\n        tmp = d[j]; d[j] = d[j + 1]; d[j + 1] = tmp;\n    }\n    return;\n  }\n\n  private static void enqueuexy(int[] nowx, int[] nowy, int n, int x, int y){\n    nowx[tail] = x; nowy[tail] = y;\n    tail = (tail + 1) % (n + 1);\n  }\n\n  private static int dequeuex(int[] nowx, int n){\n    return nowx[head % (n + 1)];\n  }\n  private static int dequeuey(int[] nowy, int n){\n    head = (head + 1) % (n + 1);\n    return nowy[(n + head) % (n + 1)];\n  }\n\n  private static boolean isnotEmpty(){\n    if(head == tail)return false;\n    else return true;\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main {\n    static int W;\n    static int H;\n    static int s[][];\n    public static void main(String args[]) {\n        Scanner sc = new Scanner(System.in);\n        W = sc.nextInt();\n        H = sc.nextInt();\n        s = new int[H][W];\n        for (int i = 0; i < H; i++) {\n            String line = sc.next();\n            for (int j = 0; j < W; j++) {\n                char c = line.charAt(j);\n                if (c == '.') {\n                    s[i][j] = 0;\n                } else {\n                    s[i][j] = c - '0';\n                }\n            }\n        }\n        int count = 0;\n        Set<Integer> set = rush0();\n        while (set.size() > 0) {\n            for(int x: set) {\n                int i = x >> 16;\n                int j = x & 0xffff;\n                s[i][j] = 0;\n            }\n            count++;\n            set = rush1(set);\n        }\n        System.out.printf(\"%d\\n\", count);\n    }\n\n    static Set<Integer> rush1(Set<Integer> set) {\n        Set<Integer> set2 = new HashSet<Integer>();\n        for(int x: set) {\n            int p = x >> 16;\n            int q = x & 0xffff;\n            for (int i = p-1; i <= p+1; i++) {\n                for (int j = q-1; j <= q+1; j++) {\n                    if (i == p && j == q) continue;\n                    if (s[i][j] > 0 && count(i, j) >= s[i][j]) {\n                        set2.add(i << 16 | j);\n                    }\n                }\n            }\n        }\n        return set2;\n    }\n\n    static int count(int p, int q) {\n        int c = 0;\n        for (int i = p-1; i <= p+1; i++) {\n            for (int j = q-1; j <= q+1; j++) {\n                if (s[i][j] == 0) c++;\n            }\n        }\n        return c;\n    }\n\n    static Set<Integer> rush0() {\n        Set<Integer> set = new HashSet<Integer>();\n        for (int i = 1; i < H-1; i++) {\n            for (int j = 1; j < W-1; j++) {\n                if (s[i][j] > 0 && count(i, j) >= s[i][j]) {\n                    set.add(i << 16 | j);\n                }\n            }\n        }\n        return set;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.StringTokenizer;\nimport java.util.Deque;\nimport java.util.ArrayDeque;\n\nclass Main{\n\nstatic final PrintWriter out=new PrintWriter(System.out);\nstatic final int INF=Integer.MAX_VALUE/2;\nstatic int[] d={-1,0,1};\n\nstatic class TPair{\nint t;\nint x;\nint y;\nTPair(int t,int x,int y){\nthis.t=t; this.x=x; this.y=y;\n}\n}\n\npublic static void main(String[] args) throws IOException{\nBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\nString line=\"\";\nwhile((line=br.readLine())!=null&&!line.isEmpty()){\nStringTokenizer st=new StringTokenizer(line);\nint h=Integer.parseInt(st.nextToken());\nint w=Integer.parseInt(st.nextToken());\nint[][] map=new int[h][w];\nfor(int i=0;i<h;i++){\nline=br.readLine();\nfor(int j=0;j<w;j++){\nmap[i][j]=(line.charAt(j)=='.')?INF:(int)(line.charAt(j)-'0');\n}\n}\nout.println(bfs(h,w,map));\nout.flush();\n}\n}\n\nprivate static int bfs(int h,int w,int[][] map){\nDeque<TPair> que=new ArrayDeque<TPair>();\nint[][] hmap=new int[h][];\nint ans=-1;\nfor(int i=0;i<h;i++){\nfor(int j=0;j<w;j++){\nif(map[i][j]!=INF) que.offerLast(new TPair(0,i,j));\n}\n}\nwhile(!que.isEmpty()){\nTPair p=que.pollFirst();\nif(ans!=p.t){\nif(update){\nboolean update=false;\nfor(int i=0;i<h;i++) hmap[i]=map[i].clone();\nans=p.t;\n}\nelse return ans;\n}\nint x=p.x;\nint y=p.y;\nint nx;\nint ny;\nint cnt1=0;\nint cnt2=0;\nint hxy=hmap[x][y];\nloop:\nfor(int i=0;i<3;i++){\nfor(int j=0;j<3;j++){\nif(i==1&&j==1) continue;\nnx=x+d[i];\nny=y+d[j];\nif(hmap[nx][ny]==INF) cnt1++;\nif(hmap[nx][ny]<INF) cnt2++;\nif(cnt1>=hxy){\nmap[x][y]=INF;\nupdate=true;\nbreak loop;\n}\nif(cnt2>8-hxy){\nque.offerLast(new TPair(ans+1,x,y));\nbreak loop;\n}\n}\n}\n}\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.StringTokenizer;\nimport java.util.Deque;\nimport java.util.ArrayDeque;\n\nclass Main{\n\nstatic final PrintWriter out=new PrintWriter(System.out);\nstatic final int INF=Integer.MAX_VALUE/2;\nstatic int[] d={-1,0,1};\n\nstatic class Pair{\nint x;\nint y;\nPair(int x,int y){\nthis.x=x; this.y=y;\n}\n}\n\npublic static void main(String[] args) throws IOException{\nBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\nString line=\"\";\nwhile((line=br.readLine())!=null&&!line.isEmpty()){\nStringTokenizer st=new StringTokenizer(line);\nint h=Integer.parseInt(st.nextToken());\nint w=Integer.parseInt(st.nextToken());\nint[][] map=new int[h][w];\nfor(int i=0;i<h;i++){\nline=br.readLine();\nfor(int j=0;j<w;j++){\nmap[i][j]=(line.charAt(j)=='.')?INF:(int)(line.charAt(j)-'0');\n}\n}\nint cnt=0;\nwhile(true){\nif(bfs(h,w,map)) cnt++;\nelse break;\n}\nout.println(cnt);\nout.flush();\n}\n}\n\nprivate static boolean bfs(int h,int w,int[][] map){\nDeque<Pair> que=new ArrayDeque<Pair>();\nint[][] hmap=new int[h][];\nboolean update=false;\nfor(int i=0;i<h;i++) hmap[i]=map[i].clone();\nfor(int i=0;i<h;i++){\nfor(int j=0;j<w;j++){\nif(map[i][j]!=INF){\nque.offerLast(new Pair(i,j));\n}\n}\n}\nwhile(!que.isEmpty()){\nPair p=que.pollFirst();\nint x=p.x;\nint y=p.y;\nint nx;\nint ny;\nint cnt=0;\nloop:\nfor(int i=0;i<3;i++){\nfor(int j=0;j<3;j++){\nif(i==1&&j=1) continue loop;\nnx=x+d[i];\nny=y+d[j];\nif(hmap[nx][ny]==INF) cnt++;\nif(cnt>=hmap[x][y]){\nmap[x][y]=INF;\nupdate=true;\nbreak loop;\n}\n}\n}\n}\nreturn update;\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.math.*;\nimport java.awt.geom.*;\nimport java.io.*;\n   \n   \npublic class Main {\n\tstatic int INF = 2 << 29;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint h = sc.nextInt();\n\t\tint w = sc.nextInt();\n\t\tchar[][] map = new char[h][w];\n\t\tfor(int i = 0; i < h; i++) {\n\t\t\tmap[i] = sc.next().toCharArray();\n\t\t}\n\t\tboolean[][] al = new boolean[h][w];\n\t\tArrayDeque<Data> queue = new ArrayDeque<Data>();\n\t\t\n\t\tfor(int i = 0; i < h; i++) {\n\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\tif(al[i][j]) continue;\n\t\t\t\tif(map[i][j] == '.') {\n\t\t\t\t\tal[i][j] = true;\n\t\t\t\t\tfor(int k = 0; k < 8; k++) {\n\t\t\t\t\t\tint ty = i + vy[k];\n\t\t\t\t\t\tint tx = j + vx[k];\n\t\t\t\t\t\tif(ty < 0 || tx < 0 || ty >= h || tx >= w) continue;\n\t\t\t\t\t\tif(al[ty][tx]) continue;\n\t\t\t\t\t\tal[ty][tx] = true;\n\t\t\t\t\t\tif(map[ty][tx] != '.') {\n\t\t\t\t\t\t\tqueue.add(new Data(ty,tx));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint cou = 0;\n\t\twhile(!queue.isEmpty()) {\n\t\t\tcou++;\n\t\t\tboolean ok = false;\n\t\t\tArrayDeque<Data> tmp = new ArrayDeque<Data>();\n\t\t\tArrayDeque<Data> er  = new ArrayDeque<Data>();\n\t\t\twhile(!queue.isEmpty()) {\n\t\t\t\tData p = queue.poll();\n\t\t\t\tint count = 0;\n\t\t\t\tfor(int i = 0; i < 8; i++) {\n\t\t\t\t\tint ty = p.y + vy[i];\n\t\t\t\t\tint tx = p.x + vx[i];\n\t\t\t\t\tif(ty < 0 || tx < 0 || ty >= h || tx >= w) continue;\n\t\t\t\t\tif(map[ty][tx] == '.') count++;\n\t\t\t\t}\n\t\t\t\tif(count >= map[p.y][p.x] - '0') {\n\t\t\t\t\tok = true;\n\t\t\t\t\ter.add(p);\n\t\t\t\t\tfor(int i = 0; i < 8; i++) {\n\t\t\t\t\t\tint ty = p.y + vy[i];\n\t\t\t\t\t\tint tx = p.x + vx[i];\n\t\t\t\t\t\tif(ty < 0 || tx < 0 || ty >= h || tx >= w) continue;\n\t\t\t\t\t\tif(map[ty][tx] != '.' && !al[ty][tx]) {\n\t\t\t\t\t\t\tal[ty][tx] = true;\n\t\t\t\t\t\t\ttmp.add(new Data(ty,tx));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttmp.add(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(!er.isEmpty()) {\n\t\t\t\tData p = er.poll();\n\t\t\t\tmap[p.y][p.x] = '.';\n\t\t\t}\n\t\t\tif(!ok) {\n\t\t\t\tcou-=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tqueue.addAll(tmp);\n\t\t\ttmp.clear();\n\t\t}\n\t\t\n\t\tSystem.out.println(cou);\n\t\t\n\t\t\n\t\t\n\t\t\n\t}\n\tstatic int[] vx = {-1,0,1,-1,0,1,-1,0,1};\n\tstatic int[] vy = {-1,-1,-1,0,0,0,1,1,1};\n\t\n\tstatic class Data {\n\t\tint y;\n\t\tint x;\n\t\tData(int a, int b) {\n\t\t\ty = a;\n\t\t\tx = b;\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class Po\n{\n    public int x { get; set; }\n    public int y { get; set; }\n    public Po(int x, int y)\n    {\n        this.x = x;\n        this.y = y;\n    }\n}\n\npublic class Hello\n{\n    public static void Main()\n    {\n        var dx = new int[] { 1, 1, 0, -1, -1, -1, 0, 1 };\n        var dy = new int[] { 0, 1, 1, 1, 0, -1, -1, -1 };\n        string[] line = Console.ReadLine().Trim().Split(' ');\n        var h = int.Parse(line[0]);\n        var w = int.Parse(line[1]);\n        var map = new int[h, w];\n        var ps = new List<Po>();\n        for (int i = 0; i < h; i++)\n        {\n            var s = Console.ReadLine().Trim();\n            for (int j = 0; j < w; j++)\n                if (s[j] != '.')\n                {\n                    map[i, j] = int.Parse(s[j].ToString());\n                    if (map[i, j] != 9) ps.Add(new Po(i, j));\n                }\n        }\n        var count = 0;\n        while (true)\n        {\n            if (destroyC(map, ps, dx, dy)) count++;\n            else break;\n        }\n        Console.WriteLine(count);\n    }\n    public static bool destroyC(int[,] map, List<Po> ps,  int[] dx, int[] dy)\n    {\n        var h = map.GetLength(0); var w = map.GetLength(1);\n        var dlist = new List<Po>();\n        foreach (var p in ps)\n        {\n            if (map[p.x, p.y] == 0) continue;\n            var count = 0;\n            for (int i = 0; i < 8; i++)\n            {\n                var nx = p.x + dx[i];\n                var ny = p.y + dy[i];\n                if (nx >= 0 && nx < h && ny >= 0 && ny < w && map[nx, ny] == 0) count++;\n            }\n            if (count >= map[p.x, p.y]) dlist.Add(new Po(p.x, p.y));\n        }\n        if (dlist.Count() == 0) return false;\n        ps.Clear();\n        foreach (var p in dlist)\n        {\n            map[p.x, p.y] = 0;\n            for (int i = 0; i < 8; i++)\n            {\n                var nx = p.x + dx[i];\n                var ny = p.y + dy[i];\n                if (nx >= 0 && nx < h && ny >= 0 && ny < w && map[nx, ny] != 0 && map[nx, ny] != 9)\n                    ps.Add(new Po(nx, ny));\n            }\n        }\n        return true;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic struct Po\n{\n    public int x { get; set; }\n    public int y { get; set; }\n}\n\npublic class Hello\n{\n    public static void Main()\n    {\n        var dx = new int[] { 1, 1, 0, -1, -1, -1, 0, 1 };\n        var dy = new int[] { 0, 1, 1, 1, 0, -1, -1, -1 };\n        string[] line = Console.ReadLine().Trim().Split(' ');\n        var h = int.Parse(line[0]);\n        var w = int.Parse(line[1]);\n        var map = new int[h, w];\n        var ps = new List<Po>();\n        for (int i = 0; i < h; i++)\n        {\n            var s = Console.ReadLine().Trim();\n            for (int j = 0; j < w; j++)\n                if (s[j] != '.')\n                {\n                    map[i, j] = int.Parse(s[j].ToString());\n                    if (map[i, j] != 9) ps.Add(new Po { x = i, y = j });\n                }\n        }\n        var count = 0;\n        while (true)\n        {\n            if (destroyC(map, ps, dx, dy)) count++;\n            else break;\n        }\n        Console.WriteLine(count);\n    }\n    public static bool destroyC(int[,] map, List<Po> ps, int[] dx, int[] dy)\n    {\n        var h = map.GetLength(0); var w = map.GetLength(1);\n        var dlist = new List<Po>();\n        foreach (var p in ps)\n        {\n            if (map[p.x, p.y] == 0) continue;\n            var count = 0;\n            for (int i = 0; i < 8; i++)\n            {\n                var nx = p.x + dx[i];\n                var ny = p.y + dy[i];\n                if (nx >= 0 && nx < h && ny >= 0 && ny < w && map[nx, ny] == 0) count++;\n            }\n            if (count >= map[p.x, p.y]) dlist.Add(new Po { x = p.x, y = p.y });\n        }\n        if (dlist.Count() == 0) return false;\n        var pst = new List<Po>();\n        foreach (var p in dlist)\n        {\n            map[p.x, p.y] = 0;\n            for (int i = 0; i < 8; i++)\n            {\n                var nx = p.x + dx[i];\n                var ny = p.y + dy[i];\n                if (nx >= 0 && nx < h && ny >= 0 && ny < w && map[nx, ny] != 0 && map[nx, ny] != 9)\n                    pst.Add(new Po { x = nx, y = ny });\n            }\n        }\n        ps.Clear();\n        var pst2 = pst.Distinct().ToList();\n        foreach (var a in pst2) ps.Add(a);\n        return true;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class Po : IEquatable<Po>\n{\n    public int x { get; set; }\n    public int y { get; set; }\n\n    public override bool Equals(object obj)\n    {\n        if (obj == null) return false;\n        var a = (Po)obj;\n        return Equals(a);\n    }\n    public override int GetHashCode()\n    {\n        return x + y;\n    }\n    public bool Equals(Po other)\n    {\n        return (other.x == this.x && other.y == this.y);\n    }\n}\n\npublic class Hello\n{\n    public static void Main()\n    {\n        var dx = new int[] { 1, 1, 0, -1, -1, -1, 0, 1 };\n        var dy = new int[] { 0, 1, 1, 1, 0, -1, -1, -1 };\n        string[] line = Console.ReadLine().Trim().Split(' ');\n        var h = int.Parse(line[0]);\n        var w = int.Parse(line[1]);\n        var map = new int[h, w];\n        var q1 = new Queue<Po>();\n        var q2 = new Queue<Po>();\n        for (int i = 0; i < h; i++)\n        {\n            var s = Console.ReadLine().Trim();\n            for (int j = 0; j < w; j++)\n                if (s[j] != '.')\n                {\n                    map[i, j] = int.Parse(s[j].ToString());\n                    if (map[i, j] != 9) q1.Enqueue(new Po { x = i, y = j });\n                }\n        }\n        var sc = new int[h, w];\n        setSandCount(map, sc, q1, q2, dx, dy);\n        var count = 1;\n        var st = 2;\n        while (true)\n        {\n            if (destroyC(map, q1, q2, sc, dx, dy, st))\n            {\n                count++;\n                if (st == 1) st = 2;\n                else st = 1;\n            }\n            else break;\n        }\n        Console.WriteLine(count);\n    }\n    public static void setSandCount(int[,] map, int[,] sc, Queue<Po> q1, Queue<Po> q2, int[] dx, int[] dy)\n    {\n        var h = map.GetLength(0); var w = map.GetLength(1);\n        while (q1.Count() > 0)\n        {\n            var p = q1.Dequeue();\n            var count = 0;\n            for (int i = 0; i < 8; i++)\n            {\n                var nx = p.x + dx[i];\n                var ny = p.y + dy[i];\n                if (nx >= 0 && nx < h && ny >= 0 && ny < w && map[nx, ny] == 0) count++;\n            }\n            sc[p.x, p.y] = count;\n            if (count >= map[p.x, p.y]) q2.Enqueue(new Po { x = p.x, y = p.y });\n        }\n    }\n    public static bool destroyC(int[,] map, Queue<Po> q1, Queue<Po> q2, int[,] sc, int[] dx, int[] dy, int st)\n    {\n        var h = map.GetLength(0); var w = map.GetLength(1);\n        if (st == 1)\n        {\n            for (int i = 0; i < q1.Count(); i++)\n            {\n                var p = q1.Dequeue(); q1.Enqueue(p);\n                map[p.x, p.y] = 0;\n            }\n            while (q1.Count() > 0)\n            {\n                var p = q1.Dequeue();\n                for (int i = 0; i < 8; i++)\n                {\n                    var nx = p.x + dx[i];\n                    var ny = p.y + dy[i];\n                    if (nx >= 0 && nx < h && ny >= 0 && ny < w && map[nx, ny] != 0 && map[nx, ny] != 9)\n                    {\n                        sc[nx, ny]++;\n                        if (sc[nx, ny] >= map[nx, ny])\n                        {\n                            var wa = new Po { x = nx, y = ny };\n                            if (!q2.Contains(wa)) q2.Enqueue(wa);\n                        }\n                    }\n                }\n            }\n        }\n        else\n        {\n            for (int i = 0; i < q2.Count(); i++)\n            {\n                var p = q2.Dequeue(); q2.Enqueue(p);\n                map[p.x, p.y] = 0;\n            }\n            while (q2.Count() > 0)\n            {\n                var p = q2.Dequeue();\n                for (int i = 0; i < 8; i++)\n                {\n                    var nx = p.x + dx[i];\n                    var ny = p.y + dy[i];\n                    if (nx >= 0 && nx < h && ny >= 0 && ny < w && map[nx, ny] != 0 && map[nx, ny] != 9)\n                    {\n                        sc[nx, ny]++;\n                        if (sc[nx, ny] >= map[nx, ny])\n                        {\n                            var wa = new Po { x = nx, y = ny };\n                            if (!q1.Contains(wa)) q1.Enqueue(wa);\n                        }\n                    }\n                }\n            }\n        }\n        if ((st == 1 && q2.Count() == 0) | (st == 2 && q1.Count() == 0)) return false;\n        return true;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class Po\n{\n    public int x { get; set; }\n    public int y { get; set; }\n    public Po(int x, int y)\n    {\n        this.x = x;\n        this.y = y;\n    }\n}\n\npublic class Hello\n{\n    public static void Main()\n    {\n        var dx = new int[] { 1, 1, 0, -1, -1, -1, 0, 1 };\n        var dy = new int[] { 0, 1, 1, 1, 0, -1, -1, -1 };\n        string[] line = Console.ReadLine().Trim().Split(' ');\n        var h = int.Parse(line[0]);\n        var w = int.Parse(line[1]);\n        var map = new int[h, w];\n        var ps = new List<Po>();\n        for (int i = 0; i < h; i++)\n        {\n            var s = Console.ReadLine().Trim();\n            for (int j = 0; j < w; j++)\n                if (s[j] != '.')\n                {\n                    map[i, j] = int.Parse(s[j].ToString());\n                    if (map[i, j] != 9) ps.Add(new Po(i, j));\n                }\n        }\n        var count = 0;\n        while (true)\n        {\n            if (destroyC(map, ps, dx, dy)) count++;\n            else break;\n        }\n        Console.WriteLine(count);\n    }\n    public static bool destroyC(int[,] map, List<Po> ps,  int[] dx, int[] dy)\n    {\n        var h = map.GetLength(0); var w = map.GetLength(1);\n        var dlist = new List<Po>();\n        foreach (var p in ps)\n        {\n            if (map[p.x, p.y] == 0) continue;\n            var count = 0;\n            for (int i = 0; i < 8; i++)\n            {\n                var nx = p.x + dx[i];\n                var ny = p.y + dy[i];\n                if (nx >= 0 && nx < h && ny >= 0 && ny < w && map[nx, ny] == 0) count++;\n            }\n            if (count >= map[p.x, p.y]) dlist.Add(new Po(p.x, p.y));\n        }\n        if (dlist.Count() == 0) return false;\n        foreach (var p in dlist)\n            map[p.x, p.y] = 0;\n        return true;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System.Collections.Generic;\nusing System.Linq;\nusing System;\n\npublic class Hello\n{\n    static int h, w;\n    static int[] dx, dy;\n    static int[,] map;\n    public static void Main()\n    {\n        dx = new int[] { 0, 1, 1, 1, 0, -1, -1, -1 };\n        dy = new int[] { 1, 1, 0, -1, -1, -1, 0, 1 };\n        string[] line = Console.ReadLine().Trim().Split(' ');\n        h = int.Parse(line[0]);\n        w = int.Parse(line[1]);\n        map = new int[h, w];\n        for (int i = 0; i < h; i++)\n        {\n            var s = Console.ReadLine().Trim();\n            for (int j = 0; j < w; j++)\n                if (s[j] != '.') map[i, j] = int.Parse(s[j].ToString());\n        }\n        var ans = getAns();\n        Console.WriteLine(ans);\n    }\n    static int getAns()\n    {\n        var a = getA();\n        if (a.Count() == 0) return 0;\n        var b = new List<int>();\n        var count = 1;\n        changeSand(a);\n        while (true)\n        {\n            AtoB(a, b);\n            if (b.Count() == 0) return count;\n            b = b.Distinct().ToList();\n            changeSand(b);\n            count++;\n            AtoB(b, a);\n            if (a.Count() == 0) return count;\n            a = a.Distinct().ToList();\n            changeSand(a);\n            count++;\n        }\n    }\n    static void AtoB(List<int> a, List<int> b)\n    {\n        b.Clear();\n        foreach (var x in a)\n        {\n            for (int i = 0; i < 8; i++)\n            {\n                var nx = x / w + dx[i];\n                var ny = x % w + dy[i];\n                var nmp = map[nx, ny];\n                if (nmp >= 1 && nmp <= 8)\n                {\n                    var count = 0;\n                    for (int j = 0; j < 8; j++)\n                    {\n                        var nnx = nx + dx[j];\n                        var nny = ny + dy[j];\n                        if (nnx >= 0 && nnx < h && nny >= 0 && nny < w &&\n                            map[nnx, nny] == 0)\n                        {\n                            count++;\n                            if (count >= nmp) { b.Add(nx * w + ny); break; }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    static void changeSand(List<int> a)\n    {\n        foreach (var x in a)\n            map[x / w, x % w] = 0;\n    }\n    static List<int> getA()\n    {\n        var a = new List<int>();\n        for (int i = 0; i < h; i++)\n            for (int j = 0; j < w; j++)\n            {\n                var mp = map[i, j];\n                if (mp >= 1 && mp <= 8)\n                {\n                    var count = 0;\n                    for (int k = 0; k < 8; k++)\n                    {\n                        var nx = i + dx[k];\n                        var ny = j + dy[k];\n                        if (map[nx, ny] == 0)\n                        {\n                            count++;\n                            if (count >= mp) { a.Add(i * w + j); break; }\n                        }\n                    }\n                }\n            }\n        return a;\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class Po : IEquatable<Po>\n{\n    public int x { get; set; }\n    public int y { get; set; }\n\n    public override bool Equals(object obj)\n    {\n        if (obj == null) return false;\n        var a = (Po)obj;\n        return Equals(a);\n    }\n    public override int GetHashCode()\n    {\n        return x + y;\n    }\n    public bool Equals(Po other)\n    {\n        return (other.x == this.x && other.y == this.y);\n    }\n}\n\npublic class Hello\n{\n    public static void Main()\n    {\n        var dx = new int[] { 1, 1, 0, -1, -1, -1, 0, 1 };\n        var dy = new int[] { 0, 1, 1, 1, 0, -1, -1, -1 };\n        string[] line = Console.ReadLine().Trim().Split(' ');\n        var h = int.Parse(line[0]);\n        var w = int.Parse(line[1]);\n        var map = new int[h, w];\n        var ps1 = new List<Po>();\n        var ps2 = new List<Po>();\n        for (int i = 0; i < h; i++)\n        {\n            var s = Console.ReadLine().Trim();\n            for (int j = 0; j < w; j++)\n                if (s[j] != '.')\n                {\n                    map[i, j] = int.Parse(s[j].ToString());\n                    if (map[i, j] != 9) ps1.Add(new Po { x = i, y = j });\n                }\n        }\n        var sc = new int[h, w];\n        setSandCount(map, sc, ps1,ps2,   dx, dy);\n        var count = 1;\n        var st = 2;\n        while (true)\n        {\n            if (destroyC(map, ps1, ps2, sc, dx, dy, st))\n            {\n                count++;\n                if (st == 1) st = 2;\n                else st = 1;\n            }\n            else break;\n        }\n        Console.WriteLine(count);\n    }\n    public static void setSandCount(int[,] map, int[,] sc, List<Po> ps1 ,List<Po> ps2   , int[] dx, int[] dy)\n    {\n        var h = map.GetLength(0); var w = map.GetLength(1);\n        var wk = new List<Po>();\n        foreach (var p in ps1)\n        {\n            var count = 0;\n            for (int i = 0; i < 8; i++)\n            {\n                var nx = p.x + dx[i];\n                var ny = p.y + dy[i];\n                if (nx >= 0 && nx < h && ny >= 0 && ny < w && map[nx, ny] == 0) count++;\n            }\n            sc[p.x, p.y] = count;\n            if (count >= map[p.x, p.y]) ps2.Add(new Po { x = p.x, y = p.y });\n        }\n    }\n    public static bool destroyC(int[,] map, List<Po> ps1, List<Po> ps2, int[,] sc, int[] dx, int[] dy, int st)\n    {\n        var h = map.GetLength(0); var w = map.GetLength(1);\n        if (st == 1)\n        {\n            ps2.Clear();\n            foreach (var p in ps1) map[p.x, p.y] = 0;\n            foreach (var p in ps1)\n            {\n                for (int i = 0; i < 8; i++)\n                {\n                    var nx = p.x + dx[i];\n                    var ny = p.y + dy[i];\n                    if (nx >= 0 && nx < h && ny >= 0 && ny < w && map[nx, ny] != 0 && map[nx, ny] != 9)\n                    {\n                        sc[nx, ny]++;\n                        if (sc[nx, ny] >= map[nx, ny])\n                        {\n                            var wa = new Po { x = nx, y = ny };\n                            if (!ps2.Contains(wa)) ps2.Add(wa);\n                        }\n                    }\n                }\n            }\n        }\n        else\n        {\n            ps1.Clear();\n            foreach (var p in ps2) map[p.x, p.y] = 0;\n            foreach (var p in ps2)\n            {\n                for (int i = 0; i < 8; i++)\n                {\n                    var nx = p.x + dx[i];\n                    var ny = p.y + dy[i];\n                    if (nx >= 0 && nx < h && ny >= 0 && ny < w && map[nx, ny] != 0 && map[nx, ny] != 9)\n                    {\n                        sc[nx, ny]++;\n                        if (sc[nx, ny] >= map[nx, ny])\n                        {\n                            var wa = new Po { x = nx, y = ny };\n                            if (!ps1.Contains(wa)) ps1.Add(wa);\n                        }\n                    }\n                }\n            }\n\n        }\n        if ((st == 1 && ps2.Count == 0) | (st == 2 && ps1.Count() == 0)) return false;\n        return true;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class Po : IEquatable<Po>\n{\n    public int x { get; set; }\n    public int y { get; set; }\n\n    public override bool Equals(object obj)\n    {\n        if (obj == null) return false;\n        var a = (Po)obj;\n        return Equals(a);\n    }\n    public override int GetHashCode()\n    {\n        return x + y;\n    }\n    public bool Equals(Po other)\n    {\n        return (other.x == this.x && other.y == this.y);\n    }\n}\n\npublic class Hello\n{\n    public static void Main()\n    {\n        var dx = new int[] { 1, 1, 0, -1, -1, -1, 0, 1 };\n        var dy = new int[] { 0, 1, 1, 1, 0, -1, -1, -1 };\n        string[] line = Console.ReadLine().Trim().Split(' ');\n        var h = int.Parse(line[0]);\n        var w = int.Parse(line[1]);\n        var map = new int[h, w];\n        var ps1 = new List<Po>();\n        var ps2 = new List<Po>();\n        for (int i = 0; i < h; i++)\n        {\n            var s = Console.ReadLine().Trim();\n            for (int j = 0; j < w; j++)\n                if (s[j] != '.')\n                {\n                    map[i, j] = int.Parse(s[j].ToString());\n                    if (map[i, j] != 9) ps1.Add(new Po { x = i, y = j });\n                }\n        }\n        var sc = new int[h, w];\n        setSandCount(map, sc, ps1,ps2,   dx, dy);\n        var count = 1;\n        var st = 2;\n        while (true)\n        {\n            if (destroyC(map, ps1, ps2, sc, dx, dy, st))\n            {\n                count++;\n                if (st == 1) st = 2;\n                else st = 1;\n            }\n            else break;\n        }\n        Console.WriteLine(count);\n    }\n    public static void setSandCount(int[,] map, int[,] sc, List<Po> ps1 ,List<Po> ps2   , int[] dx, int[] dy)\n    {\n        var h = map.GetLength(0); var w = map.GetLength(1);\n         foreach (var p in ps1)\n        {\n            var count = 0;\n            for (int i = 0; i < 8; i++)\n            {\n                var nx = p.x + dx[i];\n                var ny = p.y + dy[i];\n                if (nx >= 0 && nx < h && ny >= 0 && ny < w && map[nx, ny] == 0) count++;\n            }\n            sc[p.x, p.y] = count;\n            if (count >= map[p.x, p.y]) ps2.Add(new Po { x = p.x, y = p.y });\n        }\n    }\n    public static bool destroyC(int[,] map, List<Po> ps1, List<Po> ps2, int[,] sc, int[] dx, int[] dy, int st)\n    {\n        var h = map.GetLength(0); var w = map.GetLength(1);\n        if (st == 1)\n        {\n            ps2.Clear();\n            foreach (var p in ps1) map[p.x, p.y] = 0;\n            foreach (var p in ps1)\n            {\n                for (int i = 0; i < 8; i++)\n                {\n                    var nx = p.x + dx[i];\n                    var ny = p.y + dy[i];\n                    if (nx >= 0 && nx < h && ny >= 0 && ny < w && map[nx, ny] != 0 && map[nx, ny] != 9)\n                    {\n                        sc[nx, ny]++;\n                        if (sc[nx, ny] >= map[nx, ny])\n                        {\n                            var wa = new Po { x = nx, y = ny };\n                            if (!ps2.Contains(wa)) ps2.Add(wa);\n                        }\n                    }\n                }\n            }\n        }\n        else\n        {\n            ps1.Clear();\n            foreach (var p in ps2) map[p.x, p.y] = 0;\n            foreach (var p in ps2)\n            {\n                for (int i = 0; i < 8; i++)\n                {\n                    var nx = p.x + dx[i];\n                    var ny = p.y + dy[i];\n                    if (nx >= 0 && nx < h && ny >= 0 && ny < w && map[nx, ny] != 0 && map[nx, ny] != 9)\n                    {\n                        sc[nx, ny]++;\n                        if (sc[nx, ny] >= map[nx, ny])\n                        {\n                            var wa = new Po { x = nx, y = ny };\n                            if (!ps1.Contains(wa)) ps1.Add(wa);\n                        }\n                    }\n                }\n            }\n\n        }\n        if ((st == 1 && ps2.Count == 0) | (st == 2 && ps1.Count() == 0)) return false;\n        return true;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class Po : IEquatable<Po>\n{\n    public int x { get; set; }\n    public int y { get; set; }\n\n    public override bool Equals(object obj)\n    {\n        if (obj == null) return false;\n        var a = (Po)obj;\n        return Equals(a);\n    }\n    public override int GetHashCode()\n    {\n        return x + y;\n    }\n    public bool Equals(Po other)\n    {\n        return (other.x == this.x && other.y == this.y);\n    }\n}\n\npublic class Hello\n{\n    public static void Main()\n    {\n        var dx = new int[] { 1, 1, 0, -1, -1, -1, 0, 1 };\n        var dy = new int[] { 0, 1, 1, 1, 0, -1, -1, -1 };\n        string[] line = Console.ReadLine().Trim().Split(' ');\n        var h = int.Parse(line[0]);\n        var w = int.Parse(line[1]);\n        var map = new int[h, w];\n        var ps1 = new List<Po>();\n        var ps2 = new List<Po>();\n        for (int i = 0; i < h; i++)\n        {\n            var s = Console.ReadLine().Trim();\n            for (int j = 0; j < w; j++)\n                if (s[j] != '.')\n                {\n                    map[i, j] = int.Parse(s[j].ToString());\n                    if (map[i, j] != 9) ps1.Add(new Po { x = i, y = j });\n                }\n        }\n        var sc = new int[h, w];\n        setSandCount(map, sc, ps1, dx, dy);\n        var count = 1;\n        var st = 1;\n        while (true)\n        {\n            if (destroyC(map, ps1, ps2, sc, dx, dy, st))\n            {\n                count++;\n                if (st == 1) st = 2;\n                else st = 1;\n            }\n            else break;\n        }\n        Console.WriteLine(count);\n    }\n    public static void setSandCount(int[,] map, int[,] sc, List<Po> ps, int[] dx, int[] dy)\n    {\n        var h = map.GetLength(0); var w = map.GetLength(1);\n        var wk = new List<Po>();\n        foreach (var p in ps)\n        {\n            var count = 0;\n            for (int i = 0; i < 8; i++)\n            {\n                var nx = p.x + dx[i];\n                var ny = p.y + dy[i];\n                if (nx >= 0 && nx < h && ny >= 0 && ny < w && map[nx, ny] == 0) count++;\n            }\n            sc[p.x, p.y] = count;\n            if (count >= map[p.x, p.y]) wk.Add(new Po { x = p.x, y = p.y });\n        }\n        ps.Clear();\n        foreach (var p in wk) ps.Add(p);\n    }\n    public static bool destroyC(int[,] map, List<Po> ps1, List<Po> ps2, int[,] sc, int[] dx, int[] dy, int st)\n    {\n        var h = map.GetLength(0); var w = map.GetLength(1);\n        if (st == 1)\n        {\n            ps2.Clear();\n            foreach (var p in ps1) map[p.x, p.y] = 0;\n            foreach (var p in ps1)\n            {\n                for (int i = 0; i < 8; i++)\n                {\n                    var nx = p.x + dx[i];\n                    var ny = p.y + dy[i];\n                    if (nx >= 0 && nx < h && ny >= 0 && ny < w && map[nx, ny] != 0 && map[nx, ny] != 9)\n                    {\n                        sc[nx, ny]++;\n                        if (sc[nx, ny] >= map[nx, ny])\n                        {\n                            var wa = new Po { x = nx, y = ny };\n                            if (!ps2.Contains(wa)) ps2.Add(wa);\n                        }\n                    }\n                }\n            }\n        }\n        else\n        {\n            ps1.Clear();\n            foreach (var p in ps2) map[p.x, p.y] = 0;\n            foreach (var p in ps2)\n            {\n                for (int i = 0; i < 8; i++)\n                {\n                    var nx = p.x + dx[i];\n                    var ny = p.y + dy[i];\n                    if (nx >= 0 && nx < h && ny >= 0 && ny < w && map[nx, ny] != 0 && map[nx, ny] != 9)\n                    {\n                        sc[nx, ny]++;\n                        if (sc[nx, ny] >= map[nx, ny])\n                        {\n                            var wa = new Po { x = nx, y = ny };\n                            if (!ps1.Contains(wa)) ps1.Add(wa);\n                        }\n                    }\n                }\n            }\n\n        }\n        if ((st == 1 && ps2.Count == 0) | (st == 2 && ps1.Count() == 0)) return false;\n        return true;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic struct Po\n{\n    public int x { get; set; }\n    public int y { get; set; }\n}\n\npublic class Hello\n{\n    public static void Main()\n    {\n        var dx = new int[] { 1, 1, 0, -1, -1, -1, 0, 1, 0 };\n        var dy = new int[] { 0, 1, 1, 1, 0, -1, -1, -1, 0 };\n        string[] line = Console.ReadLine().Trim().Split(' ');\n        var h = int.Parse(line[0]);\n        var w = int.Parse(line[1]);\n        var map = new int[h, w];\n        var ps = new List<Po>();\n        for (int i = 0; i < h; i++)\n        {\n            var s = Console.ReadLine().Trim();\n            for (int j = 0; j < w; j++)\n                if (s[j] != '.')\n                {\n                    map[i, j] = int.Parse(s[j].ToString());\n                    if (map[i, j] != 9) ps.Add(new Po { x = i, y = j });\n                }\n        }\n        var sc = new int[h, w];\n        setSandCount(map, sc, ps, dx, dy);\n        var count = 0;\n        while (true)\n        {\n            if (destroyC(map, ps, sc, dx, dy)) count++;\n            else break;\n        }\n        Console.WriteLine(count+1);\n    }\n    public static void setSandCount(int[,] map, int[,] sc, List<Po> ps, int[] dx, int[] dy)\n    {\n        var h = map.GetLength(0); var w = map.GetLength(1);\n        var wk = new List<Po>();\n        foreach (var p in ps)\n        {\n            var count = 0;\n            for (int i = 0; i < 8; i++)\n            {\n                var nx = p.x + dx[i];\n                var ny = p.y + dy[i];\n                if (nx >= 0 && nx < h && ny >= 0 && ny < w && map[nx, ny] == 0) count++;\n            }\n            sc[p.x, p.y] = count;\n            if (count >= map[p.x, p.y]) wk.Add(new Po { x = p.x, y = p.y });\n        }\n        ps.Clear();\n        foreach (var p in wk) ps.Add(p);\n    }\n    public static bool destroyC(int[,] map, List<Po> ps, int[,] sc, int[] dx, int[] dy)\n    {\n        var h = map.GetLength(0); var w = map.GetLength(1);\n        var wk = new List<Po>();\n        foreach (var p in ps)\n        {\n            map[p.x, p.y] = 0;\n            for (int i = 0; i < 8; i++)\n            {\n                var nx = p.x + dx[i];\n                var ny = p.y + dy[i];\n                if (nx >= 0 && nx < h && ny >= 0 && ny < w && map[nx,ny] != 0 && map[nx, ny] != 9)\n                {\n                    sc[nx, ny]++;\n                    if (sc[nx, ny] >= map[nx, ny])\n                    {\n                        var wkb = new Po { x = nx, y = ny };\n                        if (!wk.Contains(wkb)) wk.Add(wkb);\n                    }\n                }\n            }\n        }\n        if (wk.Count() == 0) return false;\n        ps.Clear();\n        foreach (var p in wk) ps.Add(p);\n        return true;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic struct Po\n{\n    public int x { get; set; }\n    public int y { get; set; }\n}\n\npublic class Hello\n{\n    public static void Main()\n    {\n        var dx = new int[] { 1, 1, 0, -1, -1, -1, 0, 1 };\n        var dy = new int[] { 0, 1, 1, 1, 0, -1, -1, -1 };\n        string[] line = Console.ReadLine().Trim().Split(' ');\n        var h = int.Parse(line[0]);\n        var w = int.Parse(line[1]);\n        var map = new int[h, w];\n        var ps = new List<Po>();\n        for (int i = 0; i < h; i++)\n        {\n            var s = Console.ReadLine().Trim();\n            for (int j = 0; j < w; j++)\n                if (s[j] != '.')\n                {\n                    map[i, j] = int.Parse(s[j].ToString());\n                    if (map[i, j] != 9) ps.Add(new Po { x = i, y = j });\n                }\n        }\n        var count = 0;\n        while (true)\n        {\n            if (destroyC(map, ps, dx, dy)) count++;\n            else break;\n        }\n        Console.WriteLine(count);\n    }\n    public static bool destroyC(int[,] map, List<Po> ps, int[] dx, int[] dy)\n    {\n        var h = map.GetLength(0); var w = map.GetLength(1);\n        var dlist = new List<Po>();\n        foreach (var p in ps)\n        {\n            var count = 0;\n            for (int i = 0; i < 8; i++)\n            {\n                var nx = p.x + dx[i];\n                var ny = p.y + dy[i];\n                if (nx >= 0 && nx < h && ny >= 0 && ny < w && map[nx, ny] == 0) count++;\n            }\n            if (count >= map[p.x, p.y]) dlist.Add(new Po { x = p.x, y = p.y });\n        }\n        if (dlist.Count() == 0) return false;\n        var pst = new List<Po>();\n        foreach (var p in dlist)\n        {\n            map[p.x, p.y] = 0;\n            for (int i = 0; i < 8; i++)\n            {\n                var nx = p.x + dx[i];\n                var ny = p.y + dy[i];\n                if (nx >= 0 && nx < h && ny >= 0 && ny < w && map[nx, ny] != 0 && map[nx, ny] != 9)\n                {\n                    var aa = new Po { x = nx, y = ny };\n                    if (!pst.Contains(aa)) pst.Add(aa);\n                }\n            }\n        }\n        ps.Clear();\n        foreach (var a in pst) ps.Add(a);\n        return true;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic struct Po\n{\n    public int x { get; set; }\n    public int y { get; set; }\n    public Po(int x, int y)\n    {\n        this.x = x;\n        this.y = y;\n    }\n}\n\npublic class Hello\n{\n    public static void Main()\n    {\n        var dx = new int[] { 1, 1, 0, -1, -1, -1, 0, 1 };\n        var dy = new int[] { 0, 1, 1, 1, 0, -1, -1, -1 };\n        string[] line = Console.ReadLine().Trim().Split(' ');\n        var h = int.Parse(line[0]);\n        var w = int.Parse(line[1]);\n        var map = new int[h, w];\n        var ps = new List<Po>();\n        for (int i = 0; i < h; i++)\n        {\n            var s = Console.ReadLine().Trim();\n            for (int j = 0; j < w; j++)\n                if (s[j] != '.')\n                {\n                    map[i, j] = int.Parse(s[j].ToString());\n                    if (map[i, j] != 9) ps.Add(new Po(i, j));\n                }\n        }\n        var count = 0;\n        while (true)\n        {\n            if (destroyC(map, ps, dx, dy))  count++; \n            else break;\n        }\n        Console.WriteLine(count);\n    }\n    public static bool destroyC(int[,] map, List<Po> ps,  int[] dx, int[] dy)\n    {\n        var h = map.GetLength(0); var w = map.GetLength(1);\n        var dlist = new List<Po>();\n        foreach (var p in ps)\n        {\n            if (map[p.x, p.y] == 0) continue;\n            var count = 0;\n            for (int i = 0; i < 8; i++)\n            {\n                var nx = p.x + dx[i];\n                var ny = p.y + dy[i];\n                if (nx >= 0 && nx < h && ny >= 0 && ny < w && map[nx, ny] == 0) count++;\n            }\n            if (count >= map[p.x, p.y]) dlist.Add(new Po(p.x, p.y));\n        }\n        if (dlist.Count() == 0) return false;\n        ps.Clear();\n        var pst = new List<Po>();\n        foreach (var p in dlist)\n        {\n            map[p.x, p.y] = 0;\n            for (int i = 0; i < 8; i++)\n            {\n                var nx = p.x + dx[i];\n                var ny = p.y + dy[i];\n                if (nx >= 0 && nx < h && ny >= 0 && ny < w && map[nx, ny] != 0 && map[nx, ny] != 9)\n                    pst.Add(new Po(nx, ny));\n            }\n        }\n        var pst2 = pst.Distinct().ToList();\n        foreach (var a in pst2) ps.Add(a);\n        return true;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class Po : IEquatable<Po>\n{\n    public int x { get; set; }\n    public int y { get; set; }\n\n    public override bool Equals(object obj)\n    {\n        if (obj == null) return false;\n        var a = (Po)obj;\n        return Equals(a);\n    }\n    public override int GetHashCode()\n    {\n        return x + y;\n    }\n    public bool Equals(Po other)\n    {\n        return (other.x == this.x && other.y == this.y);\n    }\n}\n\npublic class Hello\n{\n    public static void Main()\n    {\n        var dx = new int[] { 1, 1, 0, -1, -1, -1, 0, 1 };\n        var dy = new int[] { 0, 1, 1, 1, 0, -1, -1, -1 };\n        string[] line = Console.ReadLine().Trim().Split(' ');\n        var h = int.Parse(line[0]);\n        var w = int.Parse(line[1]);\n        var map = new int[h, w];\n        var ps = new List<Po>();\n        for (int i = 0; i < h; i++)\n        {\n            var s = Console.ReadLine().Trim();\n            for (int j = 0; j < w; j++)\n                if (s[j] != '.')\n                {\n                    map[i, j] = int.Parse(s[j].ToString());\n                    if (map[i, j] != 9) ps.Add(new Po { x = i, y = j });\n                }\n        }\n        var sc = new int[h, w];\n        setSandCount(map, sc, ps, dx, dy);\n        var count = 1;\n        while (true)\n        {\n            if (destroyC(map, ps, sc, dx, dy)) count++;\n            else break;\n        }\n        Console.WriteLine(count);\n    }\n    public static void setSandCount(int[,] map, int[,] sc, List<Po> ps, int[] dx, int[] dy)\n    {\n        var h = map.GetLength(0); var w = map.GetLength(1);\n        var wk = new List<Po>();\n        foreach (var p in ps)\n        {\n            var count = 0;\n            for (int i = 0; i < 8; i++)\n            {\n                var nx = p.x + dx[i];\n                var ny = p.y + dy[i];\n                if (nx >= 0 && nx < h && ny >= 0 && ny < w && map[nx, ny] == 0) count++;\n            }\n            sc[p.x, p.y] = count;\n            if (count >= map[p.x, p.y]) wk.Add(new Po { x = p.x, y = p.y });\n        }\n        ps.Clear();\n        foreach (var p in wk) ps.Add(p);\n    }\n    public static bool destroyC(int[,] map, List<Po> ps, int[,] sc, int[] dx, int[] dy)\n    {\n        var h = map.GetLength(0); var w = map.GetLength(1);\n        var wk = new List<Po>();\n        foreach (var p in ps) map[p.x, p.y] = 0;\n        foreach (var p in ps)\n        {\n            for (int i = 0; i < 8; i++)\n            {\n                var nx = p.x + dx[i];\n                var ny = p.y + dy[i];\n                if (nx >= 0 && nx < h && ny >= 0 && ny < w && map[nx, ny] != 0 && map[nx, ny] != 9)\n                {\n                    sc[nx, ny]++;\n                    if (sc[nx, ny] >= map[nx, ny])\n                    {\n                        var wa = new Po { x = nx, y = ny };\n                        if (!wk.Contains(wa)) wk.Add(wa);\n                    }\n                }\n            }\n        }\n        if (wk.Count() == 0) return false;\n        ps.Clear();\n        foreach (var p in wk) ps.Add(p);\n        return true;\n    }\n}"
  },
  {
    "language": "JavaScript",
    "code": "var n, m, c;\n\nfunction investigate(p){\n\tvar a = 0;\n\tvar q = [];\n\tfor(var i = -1; i <= 1; ++i){\n\t\tfor(var j = -1; j <= 1; ++j){\n\t\t\tvar x = p[0] + i;\n\t\t\tvar y = p[1] + j;\n\t\t\tif(!(i == 0 && j == 0) && 0 <= x && x < n && 0 <= y && y < m){\n\t\t\t\tif(c[x][y] == '.'){\n\t\t\t\t\t++a;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tq[q.length] = [x, y];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn [a >= +c[p[0]][p[1]], q];\n}\n\nfunction main(){\n\tn = scan();\n\tm = scan();\n\tc = Array(n);\n\trep(n, function(i){\n\t\tc[i] = scan(\"string\").split('');\n\t});\n\tvar p = [];\n\trep(n, function(i){\n\t\trep(m, function(j){\n\t\t\tp[p.length] = [i, j];\n\t\t});\n\t});\n\tvar a = 0;\n\twhile(p.length != 0){\n\t\t/*\n\t\trep(n, function(i){\n\t\t\tprint(c[i].join(''));\n\t\t});\n\t\tprint('');\n\t\t*/\n\n\t\tvar v = false;\n\t\tvar q = [];\n\t\tvar r = [];\n\t\tvar cnt = 0;\n\t\trep(p.length, function(i){\n\t\t\tr[r.length] = investigate(p[i]);\n\t\t});\n\t\trep(p.length, function(i){\n\t\t\tif(r[i][0]){\n\t\t\t\tc[p[i][0]][p[i][1]] = '.';\n\t\t\t\tq.push.apply(q, r[i][1]);\n\t\t\t\tv = true;\n\t\t\t}\n\t\t});\n\t\tif(v){\n\t\t\t++a;\n\t\t}\n\t\tp = q.slice(0);\n\t}\n\tprint(a);\n}\n\nfunction rep(n, func){\n\tfor(var i = 0; i < n; ++i){\n\t\tfunc(i);\n\t}\n}\n\nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\n\nvar input = '';\nvar input_index = 0;\n\nfunction scan(type){\n\tif(type === 'string'){\n\t\treturn input[input_index++];\n\t}\n\telse{\n\t\treturn +input[input_index++];\n\t}\n}\n\nfunction print(val){\n\tconsole.log(val);\n}\n\nprocess.stdin.on('data', function(chunk){\n\tinput += chunk;\n});\nprocess.stdin.on('end', function(){\n\tinput = input.split(/\\s+/);\n\tmain();\n});"
  },
  {
    "language": "Ruby",
    "code": "h, w = gets.split.map(&:to_i)\ncastle = {}\n(0..h-1).each do |i|\n    l = gets.chomp\n    (0..w-1).each do |j|\n        c = l[j]\n        if c != ?.\n            castle[[i, j]] = c.to_i\n        end\n    end\nend\ncount = 0\nloop do\n    unchanged = true\n    new_castle = {}\n    castle.each do |key, s|\n        i, j = key\n        n = (i-1..i+1).to_a.product((j-1..j+1).to_a).select {|y, x| !castle[[y, x]]}.size\n        if n >= s\n            unchanged = false\n        else\n            new_castle[key] = s\n        end\n    end\n    break if unchanged\n    count += 1\n    castle = new_castle\nend\np count\n"
  },
  {
    "language": "Ruby",
    "code": "hight, width = gets.split(\" \").map(&:to_i)\ncastle = []\nhight.times do |hig|\n  castle << gets.split(\"\").map(&:to_i)\nend\n\ndef wave(castle)\n  wave_count = 0\n  break_array = []\n   (1..castle.size).each do |hi|\n    next if castle[hi].nil?\n     (0..castle.first.size-1).each do |wi|\n      next if castle[hi][wi].nil?\n      next if castle[hi][wi] == 0 \n      next if castle[hi][wi] > 8\n      (hi-1..hi+1).each do |y|\n        next if castle[y].nil?\n        (wi-1..wi+1).each do |x|\n          next if castle[y][x].nil?\n          if castle[y][x] == 0\n            castle[hi][wi] -= 1 \n          end\n        end\n      end\n      if 0 >= castle[hi][wi]\n        break_array << [hi, wi]\n        castle[hi][wi] = \"done\"\n      end\n    end\n  end\n  break_array.each {|h, w| castle[h][w] = 0}\n  until break_array.empty?\n    next_break_array = []\n    break_array.each do |h, w|\n      (h-1..h+1).each do |y|\n        next if castle[y].nil?\n        (w-1..w+1).each do |x|\n          next if castle[y][x].nil?\n          next if x == w && y == h\n          if castle[y][x] != \"done\" && castle[y][x] > 0\n            castle[y][x] -= 1 \n            if castle[y][x] <= 0\n              next_break_array << [y, x]\n              castle[y][x] = \"done\"\n            end\n          end\n        end\n      end\n    end\n    next_break_array.each {|h, w| castle[h][w] = 0}\n    break_array = next_break_array\n    wave_count += 1\n  end\n  wave_count\nend\nputs wave(castle)\n"
  },
  {
    "language": "Ruby",
    "code": "def calc(c, q, h, w)\n  n = 0\n  while q.size > 0\n    e = q.shift\n    n += 1 if e[0] > n\n    (-1..1).each do |di|\n      (-1..1).each do |dj|\n        i = e[1][0] + di\n        j = e[1][1] + dj\n        if i >= 0 && i < h && j >= 0 && j < w\n          q.push([e[0] + 1, [i, j]]) if (c[i][j] -= 1) == 0\n        end\n      end\n    end\n  end\n  n\nend\n1.times do\n  c, q = [], []\n  h, w = gets.split.map(&:to_i)\n  h.times do |i|\n    c[i] = gets.chomp.split(//).map(&:to_i)\n    c[i].each.with_index do |e, j|\n      q.push([0, [i, j]]) if c[i][j] == 0\n    end\n  end\n  puts calc(c, q, h, w)\nend"
  },
  {
    "language": "Ruby",
    "code": "def check_broken(width, height, maps, strength)\n  count = 0\n  (-1..1).each do |i|\n    (-1..1).each do |j|\n      next if i ==0 && j == 0\n      if maps[width + i][height + j].zero?\n        strength -= 1 \n      end\n      if strength < 1\n        return true\n      end\n    end\n  end\n  return false\nend\n\ndef check_can_break_area(start_width, end_width, start_height, end_height, maps)\n  can_break_area = []\n  for i in (start_width..end_width)\n    for j in (start_height..end_height)\n      strength = maps[i][j]\n      next if strength.zero?\n      can_break_area << [i, j] if 1 <= strength && strength < 9\n    end\n  end\n  can_break_area\nend\n\nw, h = gets.split(\" \").map(&:to_i)\nmaps = []\nw.times do |i|\n  chara = []\n  gets.chomp.each_char do |char|\n    if char == \".\" || (char.to_i) > 0\n      chara << char.to_i\n    end\n  end\n  maps << chara\nend\ncan_break_area = check_can_break_area(1, w - 2, 1, h - 2, maps)\nwave = 0\nwhile true\n  next_can_break_area = []\n  can_break_area.each do |width, height|\n    strength = maps[width][height]\n    next_can_break_area << [width, height] if check_broken(width, height, maps, strength)\n  end\n  can_break_area = []\n  next_can_break_area.each do |width, height|\n    maps[width][height] = 0\n  end\n  next_can_break_area.each do |width, height|\n    can_break_area += check_can_break_area(-1 + width, 1 + width, -1 + height, 1 + height, maps)\n  end\n  if next_can_break_area.length > 0\n    wave += 1\n  else\n    break\n  end\n  can_break_area.uniq!\nend\n\nputs wave\n"
  },
  {
    "language": "Ruby",
    "code": "def change(i, j)\n  $cnt[i][j] = 0\n  (-1..1).each do |y|\n    (-1..1).each do |x|\n      next if x == 0 && y == 0 || i+y < 0 || i+y >= $h || j+x < 0 || j+x >= $w\n      $cnt[i+y][j+x] += 1\n    end\n  end\nend \n$h, $w = gets.split.map(&:to_i)\n$fld = Array.new($h){ Array.new }\n$h.times{ |i| $fld[i] = gets.chomp.gsub('.', '0').split('').map(&:to_i) }\n$cnt = Array.new($h){ Array.new($w, 0) }\n$h.times do |i|\n  $w.times do |j|\n    change(i, j) if $fld[i][j] == 0\n  end\nend\nret = 0\nf = false\nuntil f\n  f = true\n  arr = []\n  (1...$h-1).each do |i|\n    (1...$w-1).each do |j|\n      if $fld[i][j] > 0 && $cnt[i][j] >= $fld[i][j]\n        arr << [i, j] \n        f = false\n      end\n    end\n  end\n  arr.each{ |i, j| change(i, j); $fld[i][j] = 0 }\n  ret += 1 unless f\nend\np ret"
  },
  {
    "language": "Ruby",
    "code": "h, w = gets.split.map(&:to_i)\nfld = Array.new(h){ Array.new(w) }\narr = []\nh.times do |i|\n   str = gets.chomp\n   w.times do |j|\n    if str[j] == '.'\n      fld[i][j] = -1\n      arr << [0, [i, j]]\n    else fld[i][j] = str[j].to_i\n    end\n  end\nend\nret = 0\nuntil arr.empty?\n  cnt, pos = arr.shift\n  y, x = pos\n  ret = [ret, cnt].max\n  (-1..1).each do |i|\n    (-1..1).each do |j|\n      p = i+y; q = j+x\n      next if i == 0 && j == 0 || p < 0 || p >= h || q < 0 || q >= w || fld[p][q] <= 0\n      fld[p][q] -= 1\n      arr << [cnt+1, [p, q]] if fld[p][q] == 0\n    end\n  end\nend\np ret"
  },
  {
    "language": "Ruby",
    "code": "def calc(c, q, h, w)\n  n = 0\n  while q.size > 0\n    e = q.shift\n    n += 1 if e[0] > n\n    (-1..1).each do |di|\n      (-1..1).each do |dj|\n        i = e[1][0] + di\n        j = e[1][1] + dj\n        if i >= 0 && i < h && j >= 0 && j < w\n          if (c[i][j] -= 1) == 0\n            q.push([e[0] + 1, [i, j]])\n          end\n        end\n      end\n    end\n  end\n  n\nend\n1.times do\n  c, q = [], []\n  h, w = gets.split.map(&:to_i)\n  h.times do |i|\n    c[i] = gets.chomp.split(//).map(&:to_i)\n    c[i].each.with_index do |e, j|\n      q.push([0, [i, j]]) if c[i][j] == 0\n    end\n  end\n  puts calc(c, q, h, w)\nend"
  },
  {
    "language": "Ruby",
    "code": "h, w = gets.split.map(&:to_i)\na = (1..h).map { gets.split(\"\").map(&:to_i) }\n\nqueue = []\n(1..h-1).each do |i|\n    (0..w-1).each do |j|\n        next if a[i][j] == 0\n        (i-1..i+1).each do |y|\n            (j-1..j+1).each do |x|\n                a[i][j] -= 1 if a[y][x] == 0\n            end\n        end\n        if a[i][j] <= 0\n            queue << [i, j]\n            a[i][j] = 'd'\n        end\n    end\nend\nqueue.each do |i, j|\n    a[i][j] = 0\nend\n\ncount = 0\nuntil queue.empty?\n    new_queue = []\n    queue.each do |i, j|\n        (i-1..i+1).each do |y|\n            (j-1..j+1).each do |x|\n                next if y == i && x == j\n                if a[y][x] != ?d && a[y][x] > 0\n                    a[y][x] -= 1\n                    if a[y][x] <= 0\n                        new_queue << [y, x]\n                        a[y][x] = ?d\n                    end\n                end\n            end\n        end\n    end\n    queue = new_queue\n    queue.each do |i, j|\n        a[i][j] = 0\n    end\n    count += 1\nend\np count\n\n"
  },
  {
    "language": "Ruby",
    "code": "h, w = gets.split.map(&:to_i)\ncastle = {}\n(0..h-1).each do |i|\n    l = gets.chomp\n    (0..w-1).each do |j|\n        c = l[j]\n        if c != ?.\n            castle[[i, j]] = c.to_i\n        end\n    end\nend\n\nqueue = []\ncastle.keys.each do |key|\n    i, j = key\n    n = (i-1..i+1).to_a.product((j-1..j+1).to_a).select {|y, x| !castle[[y, x]]}.size\n    castle[key] -= n\n    queue << key if castle[key] <= 0\nend\ncastle.delete_if {|_, k| k <= 0}\n\ncount = 0\nuntil queue.empty?\n    new_queue = []\n    queue.each do |i, j|\n        (i-1..i+1).each do |y|\n            (j-1..j+1).each do |x|\n                next if y == i && x == j\n                key = [y, x]\n                if castle[key]\n                    castle[key] -= 1\n                    if castle[key] <= 0\n                        new_queue << key\n                        castle.delete(key)\n                    end\n                end\n            end\n        end\n    end\n    queue = new_queue\n    count += 1\nend\np count\n\n"
  },
  {
    "language": "Ruby",
    "code": "h, w = gets.split.map(&:to_i)\nfld = Array.new(h){ Array.new(w) }\narr = []\nh.times do |i|\n   str = gets.chomp\n   w.times do |j|\n    if str[j] == '.'\n      fld[i][j] = 0\n      arr << [0, [i, j]]\n    else fld[i][j] = str[j].to_i\n    end\n  end\nend\nret = 0\nuntil arr.empty?\n  ret, pos = arr.shift\n  y, x = pos\n  (-1..1).each do |i|\n    (-1..1).each do |j|\n      p = i+y; q = j+x\n      next if i == 0 && j == 0 || p < 0 || p >= h || q < 0 || q >= w || fld[p][q] <= 0\n      fld[p][q] -= 1\n      arr << [ret+1, [p, q]] if fld[p][q] == 0\n    end\n  end\nend\np ret"
  },
  {
    "language": "Ruby",
    "code": "$sandpool = []\n$check_points = []\n$wave_count = 0\n$break_points = []\n\ndef breakable?(castle)\n    1 <= castle && castle < 9\nend\n\ndef search_around(px, py)\n    ((px - 1)..(px + 1)).each do |x|\n        ((py - 1)..(py + 1)).each do |y|\n            next if x == px && y == py\n            yield(x, y)\n        end\n    end\nend\n\ndef check_break_points\n    $check_points.each do |i, j|\n        castle = $sandpool[i][j]\n        search_around(i, j) do |pi, pj|\n            break if castle == 0\n            castle -= 1 if $sandpool[pi][pj] == 0\n        end\n        $break_points << [i, j] if castle == 0\n    end\nend\n\ndef break_castles\n    $break_points.each do |i, j|\n        $sandpool[i][j] = 0\n    end\nend\n\ndef setup_next_check_points\n    $check_points = []\n    $break_points.each do |i, j|\n        search_around(i, j) do |pi, pj|\n            castle = $sandpool[pi][pj]\n            $check_points << [pi, pj] if breakable?(castle)\n        end\n    end\n    $check_points.uniq!\nend\n\ndef broken?\n    bool = $break_points.length > 0\n    $break_points = []\n    $wave_count += 1 if bool\n    bool\nend\n\ndef wave\n    check_break_points\n    break_castles\n    setup_next_check_points\n    broken?\nend\n\n#initialize\nrow, column = gets.split(\" \").map(&:to_i)\nrow.times do\n    ar = []\n    gets.chomp.each_char do |char|\n        ar << (char == \".\" ? 0 : char.to_i)\n    end\n    $sandpool << ar\nend\n(1..(row - 2)).each do |i|\n    (1..(column - 2)).each do |j|\n        castle = $sandpool[i][j]\n        $check_points << [i, j] if breakable?(castle)\n    end\nend\n#count\nis_broken = true\nwhile is_broken\n    \n    is_broken = wave\nend\n#output\nputs $wave_count\n\n"
  },
  {
    "language": "Python",
    "code": "import queue as Q\na = list(map(int,input().split()))\nb = [[] for i in range(a[0])]\nc = [[] for i in range(a[0])]\nqs = [None,None]\nqs[0]= Q.Queue()\nqs[1]= Q.Queue()\narounds=[(-1,-1),(-1,0),(-1,1),(0,-1),(0,1),(1,-1),(1,0),(1,1)]\nfor i in range(a[0]):\n\tb[i]=list(input())\n\tfor j in range(a[1]):\n\t\tc[i].append(0)\n\t\tif b[i][j]!='.':\n\t\t\tb[i][j]=int(b[i][j])\nfor i in range(1,a[0]-1):\n\tfor j in range(1,a[1]-1):\n\t\tfor k in arounds:\n\t\t\tif b[i+k[0]][j+k[1]]=='.':\n\t\t\t\tc[i][j]+=1\nans=0\nfor i in range(a[0]):\n\tfor j in range(a[1]):\n\t\tif b[i][j]!='.' and b[i][j]<=c[i][j]:\n\t\t\tb[i][j]='.'\n\t\t\tqs[0].put((i,j))\nif qs[0].empty():\n\tquit()\nq=0\nwhile not qs[q].empty():\n\twhile not qs[q].empty():\n\t\tp=qs[q].get()\n\t\tfor k in arounds:\n\t\t\tc[p[0]+k[0]][p[1]+k[1]]+=1\n\t\t\tif b[p[0]+k[0]][p[1]+k[1]]!='.' and b[p[0]+k[0]][p[1]+k[1]]==c[p[0]+k[0]][p[1]+k[1]]:\n\t\t\t\tb[p[0]+k[0]][p[1]+k[1]]='.'\n\t\t\t\tqs[q^1].put((p[0]+k[0],p[1]+k[1]))\n\tq^=1\n\tans+=1\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "# AOJ 0612\n# http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0612\n\ncastle = []\ncmp = []\nh = w = 0\nleft = 0\n\ndef initial():\n    global h, w, left\n    left = h * w\n    for i in range(0, h):\n        left -= castle[i].count(0)\n    for i in range(0, h):\n        c = []\n        for j in range(0, w):\n            if castle[i][j] == 0:\n                c.append(-99)\n            else:\n                a  = castle[i - 1][j - 1:j + 2].count(0)\n                a += castle[i][j - 1: j + 2].count(0)\n                a += castle[i + 1][j - 1: j + 2].count(0)\n                c.append(a)\n        cmp.append(c)\n\ndef wave(xy):\n    global h, w, left\n    z = []\n    xy1 = []\n    for i, j in xy:\n        if castle[i][j] > 0 and castle[i][j] <= cmp[i][j]:\n            castle[i][j] = 0\n            left -= 1\n            z.append((i, j))\n    for i, j in z:\n        cmp[i - 1][j - 1] += 1\n        cmp[i - 1][j    ] += 1\n        cmp[i - 1][j + 1] += 1\n        cmp[i    ][j - 1] += 1\n        cmp[i    ][j    ] = -99\n        cmp[i    ][j + 1] += 1\n        cmp[i + 1][j - 1] += 1\n        cmp[i + 1][j    ] += 1\n        cmp[i + 1][j + 1] += 1\n        y = [(i - 1, j - 1), (i - 1, j), (i - 1, j + 1),\n             (i, j - 1), (i, j + 1),\n             (i + 1, j - 1), (i + 1, j), (i + 1, j + 1)]\n        xy1 += y\n    return xy1\n        \ndef solve():\n    global h, w, left\n    initial()\n    p_left = left + 1\n    count = 0\n    xy = [ (i, j) for j in range(1, w) for i in range(1, h)]\n    while True:\n        count += 1\n        xy1 = wave(xy)\n        if p_left == left:\n            break\n        p_left = left\n        xy = xy1\n    return count - 1\n\nh, w = map(int, input().split())\nfor _ in range(0, h):\n    c = input().strip()\n    castle.append([int(x) if x != '.' else 0 for x in c])\nans = solve()\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "H, W = map(int, input().split())\nS = []\nfor i in range(H):\n    tmp = []\n    s = input()\n    for j in range(W):\n        if s[j] == '.':\n            tmp.append(-1)\n        else:\n            tmp.append(int(s[j]))\n    S.append(tmp)\nD = [0, 1, -1, -1, 0, -1, 1, 1, 0]\nupdate = 1; ans = 0\nwhile update:\n    update = 0; ans += 1\n    d = set()\n    for i in range(H):\n        for j in range(W):\n            if S[i][j] > -1:\n                cnt = 0\n                for k in range(8):\n                    ni = i + D[k]; nj = j + D[k+1]\n                    if S[ni][nj] == -1:\n                        cnt += 1\n                if S[i][j] <= cnt:\n                    d.add((i, j))\n                    update = 1\n    for i, j in d:\n        S[i][j] = -1\nprint(ans-1)"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nH, W = map(int, input().split())\nS = [list(map(lambda x: int(x) if x != '.' else -1, input())) for i in range(H)]\ndd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\nque = []\nD = [[0]*W for i in range(H)]\nfor i in range(H):\n    for j in range(W):\n        v = S[i][j]\n        if v == -1:\n            continue\n        x = sum(S[i+dy][j+dx] == -1 for dx, dy in dd)\n        if v <= x:\n            S[i][j] = 0\n            que.append((i, j))\n        else:\n            S[i][j] -= x\nans = 0\nwhile que:\n    que2 = []\n    for y, x in que:\n        if S[y][x] == -1:\n            continue\n        S[y][x] = -1\n        for dx, dy in dd:\n            nx = x + dx; ny = y + dy\n            if S[ny][nx] > 0:\n                S[ny][nx] -= 1\n                if not S[ny][nx]:\n                    que2.append((ny, nx))\n    que = que2\n    ans += 1\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "import copy\n\ndef check(y,x):\n    if 0<=y<=h-1 and 0<=x<=w-1:\n        return True\n    return False\n\nh,w=map(int,raw_input().split())\nfield=[raw_input() for _ in xrange(h)]\ndx=(1,1,1,0,0,-1,-1,-1)\ndy=(1,0,-1,1,-1,1,0,-1)\nbefore_field=copy.deepcopy(field)\nans=-1\nwhile 1:\n    ans+=1\n    cnt=[[0]*w for _ in xrange(h)]\n    for i in xrange(h):\n        for j in xrange(w):\n            if field[i][j]==\".\":continue\n            for k in xrange(8):\n                ny=i+dy[k]\n                nx=j+dx[k]\n                if field[ny][nx]==\".\":\n                    cnt[i][j]+=1\n    for i in xrange(h):\n        for j in xrange(w):\n            if field[i][j]==\".\":continue\n            if int(field[i][j])<=cnt[i][j]:\n                field[i]=field[i][0:j]+\".\"+field[i][j+1:]\n    if before_field==field:\n        print(ans)\n        break\n    before_field=copy.deepcopy(field)"
  },
  {
    "language": "Python",
    "code": "h, w = map(int, input().split())\na = []\nc = set()\n\ndef check(c):\n    global a\n    s = sum(a[c[0] + i][c[1] + j] == 0 for i in range(-1, 2) for j in range(-1, 2))\n    if s >= a[c[0]][c[1]]:\n        return True\n    else:\n        return False\n            \nfor _ in range(h):\n    a.append(list(input()))\nfor i in range(h):\n    for j in range(w):\n        if a[i][j] != \".\":\n            a[i][j] = int(a[i][j])\n            if a[i][j] != 9:\n                c.add((i, j))\n        else:\n            a[i][j] = 0\n\ncount = 0\nwhile True:\n    flag = False\n    z = set()\n    for i in c:\n        if check(i):\n            z.add(i)\n            flag = True\n    for i in z:\n        a[i[0]][i[1]] = 0\n        c.remove(i)\n    if flag:\n        count += 1\n    else:\n        break\nprint(count)\n"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\nh, w = map(int, input().split())\nmp = [[-1] + list(input()) + [-1] for _ in range(h)]\nmp.insert(0, [-1] * (w + 2))\nmp.append([-1] * (w + 2))\nque = []\nfor y in range(1, h + 1):\n  for x in range(1, w + 1):\n    if \"1\" <= mp[y][x] <= \"9\":\n      mp[y][x] = int(mp[y][x])\n    elif mp[y][x] == \".\":\n      mp[y][x] = 0\n      heappush(que, (0, x, y))\nvec = ((0, 1), (0, -1), (1, 1), (1, 0), (1, -1), (-1, 1), (-1, 0), (-1, -1))\nwhile que:\n  turn, x, y = heappop(que)\n  for dx, dy in vec:\n    nx, ny = x + dx, y + dy\n    if mp[ny][nx] > 0:\n      mp[ny][nx] -= 1\n      if mp[ny][nx] == 0:\n        heappush(que, (turn + 1, nx, ny))\n\nprint(turn)\n"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\n\ndef main():\n  h, w = map(int, input().split())\n  mp = [[-1] + list(input()) + [-1] for _ in range(h)]\n  mp.insert(0, [-1] * (w + 2))\n  mp.append([-1] * (w + 2))\n  \n  que = []\n  for y in range(1, h + 1):\n    for x in range(1, w + 1):\n      if \"1\" <= mp[y][x] <= \"9\":\n        mp[y][x] = int(mp[y][x])\n      elif mp[y][x] == \".\":\n        mp[y][x] = 0\n        heappush(que, (0, x, y))\n  \n  vec = ((0, 1), (0, -1), (1, 1), (1, 0), (1, -1), (-1, 1), (-1, 0), (-1, -1))\n  while que:\n    turn, x, y = heappop(que)\n    for dx, dy in vec:\n      nx, ny = x + dx, y + dy\n      if mp[ny][nx] > 0:\n        mp[ny][nx] -= 1\n        if mp[ny][nx] == 0:\n          heappush(que, (turn + 1, nx, ny))\n  \n  print(turn)\n\nmain()\n"
  },
  {
    "language": "Rust",
    "code": "use std::collections::HashSet;\nuse std::collections::VecDeque;\n\nfn main(){\n  let hw: Vec<usize> = read_vec();\n  let h = hw[0];\n  let w = hw[1];\n\n  let mut vm: Vec<Vec<u32>> = Vec::new();\n\n  for _ in 0 .. h {\n    let s: String = read();\n    vm.push(s.chars().map(|c| if c == '.' {0} else {c.to_digit(10).unwrap()}).collect());\n  }\n\n  let mut sc: HashSet<(usize, usize)> = HashSet::new();\n  \n  for i in 1 .. h-1 {\n    for j in 1 .. w-1 {\n      if vm[i][j] > 0 {\n        sc.insert((i, j));\n      }\n    }\n  }\n  \n  let mut ct = 0;\n\n  loop {\n    let mut q: VecDeque<(usize, usize)> = VecDeque::new();\n    \n    for &(i, j) in sc.iter() {\n      if vm[i][j] > 0 {\n        let an = [(i+1,j),(i+1, j+1),(i, j+1),(i-1,j+1),(i-1,j),(i-1, j-1),(i,j-1),(i+1,j-1)];\n        let cn: u32 = an.iter().map(|&(y, x)| {if vm[y][x] == 0 {1} else {0}}).sum();\n        if cn >= vm[i][j] {\n          q.push_back((i, j));\n        }\n      }\n    }\n\n    if q.is_empty() { break; }\n    \n    let mut snc: HashSet<(usize, usize)> = HashSet::new();\n    \n    for &(i, j) in q.iter() {\n      vm[i][j] = 0;\n\n      let an = [(i+1,j),(i+1, j+1),(i, j+1),(i-1,j+1),(i-1,j),(i-1, j-1),(i,j-1),(i+1,j-1)];\n\n      for &(ni, nj) in an.iter() {\n        if vm[ni][nj] > 0 {\n          snc.insert((ni, nj));\n        }\n      }\n    }\n\n    sc = snc;\n    \n    ct += 1;\n  }\n\n  println!(\"{}\", ct);\n}\n\nfn read<T>() -> T\n  where T: std::str::FromStr,\n        T::Err: std::fmt::Debug\n{\n  let mut buf = String::new();\n  std::io::stdin().read_line(&mut buf).expect(\"failed to read\");\n  buf.trim().parse().unwrap()\n}\n\nfn read_vec<T>() -> Vec<T>\n  where T: std::str::FromStr,\n        T::Err: std::fmt::Debug\n{\n  let mut buf = String::new();\n  std::io::stdin().read_line(&mut buf).expect(\"failed to read\");\n  buf.split_whitespace().map(|e| e.parse().unwrap()).collect()\n}\n\n"
  }
]