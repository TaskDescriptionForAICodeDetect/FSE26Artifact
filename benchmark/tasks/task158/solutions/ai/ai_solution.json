[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int x, y;\n} Position;\n\nint main() {\n    int H, W;\n    scanf(\"%d %d\", &H, &W);\n    \n    char grid[H][W + 1]; // +1 for null terminator\n    int strength[H][W];\n    int wave = 0;\n    \n    for (int i = 0; i < H; i++) {\n        scanf(\"%s\", grid[i]);\n        for (int j = 0; j < W; j++) {\n            if (grid[i][j] != '.') {\n                strength[i][j] = grid[i][j] - '0';\n            } else {\n                strength[i][j] = 0;\n            }\n        }\n    }\n    \n    while (1) {\n        Position to_collapse[H * W];\n        int collapse_count = 0;\n        \n        for (int i = 1; i < H - 1; i++) {\n            for (int j = 1; j < W - 1; j++) {\n                if (strength[i][j] == 0) continue;\n                \n                int empty_adjacent = 0;\n                if (strength[i-1][j] == 0) empty_adjacent++;\n                if (strength[i+1][j] == 0) empty_adjacent++;\n                if (strength[i][j-1] == 0) empty_adjacent++;\n                if (strength[i][j+1] == 0) empty_adjacent++;\n                \n                if (empty_adjacent >= strength[i][j]) {\n                    to_collapse[collapse_count].x = i;\n                    to_collapse[collapse_count].y = j;\n                    collapse_count++;\n                }\n            }\n        }\n        \n        if (collapse_count == 0) break;\n        \n        for (int i = 0; i < collapse_count; i++) {\n            int x = to_collapse[i].x;\n            int y = to_collapse[i].y;\n            strength[x][y] = 0;\n        }\n        \n        wave++;\n    }\n    \n    printf(\"%d\\n\", wave);\n    return 0;\n}",
    "timestamp": "2025-08-05 18:51:19"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class SandcastleCollapse {\n    static int H, W;\n    static int[][] castle;\n    static int[] dx = {0, 0, 1, -1};\n    static int[] dy = {1, -1, 0, 0};\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        \n        H = Integer.parseInt(st.nextToken());\n        W = Integer.parseInt(st.nextToken());\n        \n        castle = new int[H][W];\n        \n        for (int i = 0; i < H; i++) {\n            st = new StringTokenizer(br.readLine());\n            for (int j = 0; j < W; j++) {\n                castle[i][j] = Integer.parseInt(st.nextToken());\n            }\n        }\n        \n        int waves = 0;\n        while (true) {\n            boolean[][] collapse = findCollapsingSquares();\n            \n            if (!applyCollapse(collapse)) {\n                break;\n            }\n            \n            waves++;\n        }\n        \n        System.out.println(waves);\n    }\n    \n    static boolean[][] findCollapsingSquares() {\n        boolean[][] collapse = new boolean[H][W];\n        \n        for (int i = 1; i < H - 1; i++) {\n            for (int j = 1; j < W - 1; j++) {\n                if (castle[i][j] > 0 && countEmptyAdjacent(i, j) >= castle[i][j]) {\n                    collapse[i][j] = true;\n                }\n            }\n        }\n        \n        return collapse;\n    }\n    \n    static int countEmptyAdjacent(int x, int y) {\n        int emptyCount = 0;\n        \n        for (int k = 0; k < 4; k++) {\n            int nx = x + dx[k];\n            int ny = y + dy[k];\n            \n            if (castle[nx][ny] == 0) {\n                emptyCount++;\n            }\n        }\n        \n        return emptyCount;\n    }\n    \n    static boolean applyCollapse(boolean[][] collapse) {\n        boolean anyCollapse = false;\n        \n        for (int i = 1; i < H - 1; i++) {\n            for (int j = 1; j < W - 1; j++) {\n                if (collapse[i][j]) {\n                    castle[i][j] = 0;\n                    anyCollapse = true;\n                }\n            }\n        }\n        \n        return anyCollapse;\n    }\n}",
    "timestamp": "2025-08-05 18:51:27"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nint main() {\n    int H, W;\n    cin >> H >> W;\n    vector<vector<char>> grid(H, vector<char>(W));\n    vector<vector<int>> strength(H, vector<int>(W, 0));\n    queue<pair<int, int>> q;\n\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            cin >> grid[i][j];\n            if (grid[i][j] != '.') {\n                strength[i][j] = grid[i][j] - '0';\n            }\n        }\n    }\n\n    int waves = 0;\n    bool changed;\n    vector<vector<bool>> removed(H, vector<bool>(W, false));\n\n    do {\n        changed = false;\n        vector<pair<int, int>> toRemove;\n\n        for (int i = 1; i < H - 1; ++i) {\n            for (int j = 1; j < W - 1; ++j) {\n                if (grid[i][j] == '.' || removed[i][j]) continue;\n                int emptyAdj = 0;\n                if (grid[i-1][j] == '.') emptyAdj++;\n                if (grid[i+1][j] == '.') emptyAdj++;\n                if (grid[i][j-1] == '.') emptyAdj++;\n                if (grid[i][j+1] == '.') emptyAdj++;\n                if (emptyAdj >= strength[i][j]) {\n                    toRemove.push_back({i, j});\n                }\n            }\n        }\n\n        if (!toRemove.empty()) {\n            changed = true;\n            waves++;\n            for (auto &p : toRemove) {\n                grid[p.first][p.second] = '.';\n                removed[p.first][p.second] = true;\n            }\n        }\n    } while (changed);\n\n    cout << waves << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 18:51:52"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n\n#define MAX_SIZE 100\n\nint H, W;\nint castle[MAX_SIZE][MAX_SIZE];\nbool visited[MAX_SIZE][MAX_SIZE];\n\nint dx[] = {1, -1, 0, 0};\nint dy[] = {0, 0, 1, -1};\n\nint count_empty_neighbors(int x, int y) {\n    int empty_count = 0;\n    for (int i = 0; i < 4; i++) {\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        if (nx >= 0 && nx < H && ny >= 0 && ny < W && castle[nx][ny] == 0) {\n            empty_count++;\n        }\n    }\n    return empty_count;\n}\n\nbool collapse_wave() {\n    bool collapsed = false;\n    int new_castle[MAX_SIZE][MAX_SIZE];\n    \n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            new_castle[i][j] = castle[i][j];\n        }\n    }\n    \n    for (int i = 1; i < H - 1; i++) {\n        for (int j = 1; j < W - 1; j++) {\n            if (castle[i][j] > 0) {\n                int empty_neighbors = count_empty_neighbors(i, j);\n                if (empty_neighbors >= castle[i][j]) {\n                    new_castle[i][j] = 0;\n                    collapsed = true;\n                }\n            }\n        }\n    }\n    \n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            castle[i][j] = new_castle[i][j];\n        }\n    }\n    \n    return collapsed;\n}\n\nint main() {\n    scanf(\"%d %d\", &H, &W);\n    \n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            scanf(\"%d\", &castle[i][j]);\n        }\n    }\n    \n    int waves = 0;\n    while (collapse_wave()) {\n        waves++;\n    }\n    \n    printf(\"%d\\n\", waves);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 18:52:04"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nint main() {\n    int H, W;\n    cin >> H >> W;\n    \n    vector<vector<int>> castle(H, vector<int>(W, 0));\n    vector<vector<bool>> visited(H, vector<bool>(W, false));\n    \n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            cin >> castle[i][j];\n        }\n    }\n    \n    int waves = 0;\n    bool changed;\n    \n    do {\n        changed = false;\n        vector<vector<int>> new_castle = castle;\n        \n        for (int i = 1; i < H - 1; i++) {\n            for (int j = 1; j < W - 1; j++) {\n                if (castle[i][j] > 0) {\n                    int empty_count = 0;\n                    if (castle[i-1][j] == 0) empty_count++;\n                    if (castle[i+1][j] == 0) empty_count++;\n                    if (castle[i][j-1] == 0) empty_count++;\n                    if (castle[i][j+1] == 0) empty_count++;\n                    \n                    if (empty_count >= castle[i][j]) {\n                        new_castle[i][j] = 0;\n                        changed = true;\n                    }\n                }\n            }\n        }\n        \n        castle = new_castle;\n        \n        if (changed) waves++;\n    } while (changed);\n    \n    cout << waves << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 18:52:11"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class SandCastle {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int H = scanner.nextInt();\n        int W = scanner.nextInt();\n        scanner.nextLine(); // consume the rest of the line\n\n        char[][] grid = new char[H][W];\n        for (int i = 0; i < H; i++) {\n            String line = scanner.nextLine();\n            for (int j = 0; j < W; j++) {\n                grid[i][j] = line.charAt(j);\n            }\n        }\n\n        int waves = 0;\n        boolean changed;\n        do {\n            changed = false;\n            Queue<int[]> toCollapse = new LinkedList<>();\n            for (int i = 1; i < H - 1; i++) {\n                for (int j = 1; j < W - 1; j++) {\n                    if (grid[i][j] != '.') {\n                        int strength = grid[i][j] - '0';\n                        int adjacentEmpty = 0;\n                        if (grid[i-1][j] == '.') adjacentEmpty++;\n                        if (grid[i+1][j] == '.') adjacentEmpty++;\n                        if (grid[i][j-1] == '.') adjacentEmpty++;\n                        if (grid[i][j+1] == '.') adjacentEmpty++;\n                        if (adjacentEmpty >= strength) {\n                            toCollapse.add(new int[]{i, j});\n                        }\n                    }\n                }\n            }\n            if (!toCollapse.isEmpty()) {\n                waves++;\n                changed = true;\n                while (!toCollapse.isEmpty()) {\n                    int[] pos = toCollapse.poll();\n                    grid[pos[0]][pos[1]] = '.';\n                }\n            }\n        } while (changed);\n\n        System.out.println(waves);\n    }\n}",
    "timestamp": "2025-08-05 18:52:27"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def count_waves_to_collapse(grid):\n    def can_collapse(x, y, strength):\n        empty_adjacent = sum(\n            1 for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]\n            if grid[x + dx][y + dy] == 0\n        )\n        return empty_adjacent >= strength\n\n    rows = len(grid)\n    cols = len(grid[0])\n    waves = 0\n\n    while True:\n        collapsed = False\n        to_collapse = []\n\n        for x in range(1, rows - 1):\n            for y in range(1, cols - 1):\n                if grid[x][y] > 0 and can_collapse(x, y, grid[x][y]):\n                    to_collapse.append((x, y))\n                    collapsed = True\n\n        if not collapsed:\n            break\n\n        for x, y in to_collapse:\n            grid[x][y] = 0\n\n        waves += 1\n\n    return waves",
    "timestamp": "2025-08-13 01:16:06"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Sandcastle {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        sc.nextLine();\n        \n        int[][] grid = new int[n][m];\n        \n        for (int i = 0; i < n; i++) {\n            String line = sc.nextLine();\n            for (int j = 0; j < m; j++) {\n                char c = line.charAt(j);\n                if (c == '.') {\n                    grid[i][j] = 0; // empty square\n                } else {\n                    grid[i][j] = c - '0'; // castle square with strength\n                }\n            }\n        }\n        \n        System.out.println(calculateWaves(grid, n, m));\n        sc.close();\n    }\n    \n    private static int calculateWaves(int[][] grid, int n, int m) {\n        int[] dx = {-1, 1, 0, 0};\n        int[] dy = {0, 0, -1, 1};\n        Queue<int[]> queue = new LinkedList<>();\n        int waves = 0;\n        \n        while (true) {\n            boolean collapsed = false;\n            boolean[][] visited = new boolean[n][m];\n            \n            for (int i = 1; i < n - 1; i++) {\n                for (int j = 1; j < m - 1; j++) {\n                    if (grid[i][j] > 0 && !visited[i][j]) {\n                        int emptyCount = 0;\n                        for (int d = 0; d < 4; d++) {\n                            int ni = i + dx[d];\n                            int nj = j + dy[d];\n                            if (grid[ni][nj] == 0) {\n                                emptyCount++;\n                            }\n                        }\n                        if (emptyCount >= grid[i][j]) {\n                            queue.add(new int[]{i, j});\n                            collapsed = true;\n                        }\n                    }\n                }\n            }\n            \n            if (!collapsed) break;\n            \n            while (!queue.isEmpty()) {\n                int[] cell = queue.poll();\n                int x = cell[0], y = cell[1];\n                grid[x][y] = 0;\n                visited[x][y] = true;\n            }\n            \n            waves++;\n        }\n        \n        return waves;\n    }\n}",
    "timestamp": "2025-08-13 01:16:14"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n\n#define MAX_SIZE 100\n\nint grid[MAX_SIZE][MAX_SIZE];\nint rows, cols;\n\nint isCollapse(int i, int j) {\n    int emptyCount = 0;\n    if (grid[i-1][j] == 0) ++emptyCount;\n    if (grid[i+1][j] == 0) ++emptyCount;\n    if (grid[i][j-1] == 0) ++emptyCount;\n    if (grid[i][j+1] == 0) ++emptyCount;\n    return emptyCount >= grid[i][j];\n}\n\nint simulateWave() {\n    int collapseCount = 0;\n    int nextGrid[MAX_SIZE][MAX_SIZE];\n\n    for (int i = 0; i < rows; ++i) {\n        for (int j = 0; j < cols; ++j) {\n            nextGrid[i][j] = grid[i][j];\n            if (grid[i][j] != 0 && isCollapse(i, j)) {\n                nextGrid[i][j] = 0;\n                collapseCount++;\n            }\n        }\n    }\n\n    for (int i = 0; i < rows; ++i) {\n        for (int j = 0; j < cols; ++j) {\n            grid[i][j] = nextGrid[i][j];\n        }\n    }\n\n    return collapseCount;\n}\n\nint main() {\n    scanf(\"%d %d\", &rows, &cols);\n    for (int i = 0; i < rows; ++i) {\n        for (int j = 0; j < cols; ++j) {\n            scanf(\"%d\", &grid[i][j]);\n        }\n    }\n\n    int waveCount = 0;\n    while (simulateWave() > 0) {\n        waveCount++;\n    }\n\n    printf(\"%d\\n\", waveCount);\n    return 0;\n}",
    "timestamp": "2025-08-13 01:16:17"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_sandcastle(H, W, grid):\n    def count_adjacent_empty(r, c):\n        empty_count = 0\n        for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < H and 0 <= nc < W and grid[nr][nc] == 0:\n                empty_count += 1\n        return empty_count\n\n    waves = 0\n    while True:\n        collapse_squares = []\n        for r in range(1, H-1):\n            for c in range(1, W-1):\n                if grid[r][c] > 0:\n                    if count_adjacent_empty(r, c) >= grid[r][c]:\n                        collapse_squares.append((r, c))\n        \n        if not collapse_squares:\n            break\n        \n        for r, c in collapse_squares:\n            grid[r][c] = 0\n        \n        waves += 1\n    \n    return waves\n\ndef main():\n    H, W = map(int, input().split())\n    grid = []\n    for _ in range(H):\n        row = list(map(int, list(input())))\n        grid.append(row)\n    \n    print(solve_sandcastle(H, W, grid))\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 01:16:30"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque\n\ndef solve():\n    H, W = map(int, input().split())\n    grid = [list(input().strip()) for _ in range(H)]\n    directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]\n    \n    queue = deque()\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] != '.':\n                grid[i][j] = int(grid[i][j])\n    \n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == '.':\n                continue\n            count = 0\n            for di, dj in directions:\n                ni, nj = i + di, j + dj\n                if 0 <= ni < H and 0 <= nj < W and grid[ni][nj] == '.':\n                    count += 1\n            if count >= grid[i][j]:\n                queue.append((i, j))\n    \n    waves = 0\n    while queue:\n        next_queue = deque()\n        affected = set()\n        while queue:\n            i, j = queue.popleft()\n            if grid[i][j] == '.':\n                continue\n            count = 0\n            for di, dj in directions:\n                ni, nj = i + di, j + dj\n                if 0 <= ni < H and 0 <= nj < W and grid[ni][nj] == '.':\n                    count += 1\n            if count >= grid[i][j]:\n                grid[i][j] = '.'\n                affected.add((i, j))\n        \n        if not affected:\n            break\n        \n        waves += 1\n        for i, j in affected:\n            for di, dj in directions:\n                ni, nj = i + di, j + dj\n                if 0 <= ni < H and 0 <= nj < W and grid[ni][nj] != '.' and (ni, nj) not in affected:\n                    count = 0\n                    for dx, dy in directions:\n                        x, y = ni + dx, nj + dy\n                        if 0 <= x < H and 0 <= y < W and grid[x][y] == '.':\n                            count += 1\n                    if count >= grid[ni][nj]:\n                        next_queue.append((ni, nj))\n        \n        queue = next_queue\n    \n    print(waves)\n\nsolve()",
    "timestamp": "2025-08-13 01:16:51"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    int H, W;\n    cin >> H >> W;\n    vector<vector<int>> castle(H, vector<int>(W));\n    \n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            char ch;\n            cin >> ch;\n            if (ch == '.') {\n                castle[i][j] = 0; // empty square\n            } else {\n                castle[i][j] = ch - '0'; // strength of castle square\n            }\n        }\n    }\n    \n    int waves = 0;\n    bool hasCollapsed;\n    int dx[4] = {-1, 1, 0, 0};\n    int dy[4] = {0, 0, -1, 1};\n\n    do {\n        hasCollapsed = false;\n        vector<vector<int>> collapse(H, vector<int>(W, 0));\n        \n        for (int i = 1; i < H - 1; ++i) {\n            for (int j = 1; j < W - 1; ++j) {\n                if (castle[i][j] == 0) continue;\n                \n                int emptyAdj = 0;\n                for (int d = 0; d < 4; ++d) {\n                    int ni = i + dx[d];\n                    int nj = j + dy[d];\n                    if (castle[ni][nj] == 0) {\n                        ++emptyAdj;\n                    }\n                }\n                \n                if (emptyAdj >= castle[i][j]) {\n                    collapse[i][j] = 1;\n                    hasCollapsed = true;\n                }\n            }\n        }\n\n        if (hasCollapsed) {\n            ++waves;\n            for (int i = 1; i < H - 1; ++i) {\n                for (int j = 1; j < W - 1; ++j) {\n                    if (collapse[i][j] == 1) {\n                        castle[i][j] = 0;\n                    }\n                }\n            }\n        }\n        \n    } while (hasCollapsed);\n\n    cout << waves << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 10:59:11"
  }
]