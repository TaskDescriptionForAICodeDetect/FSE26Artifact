[
  {
    "language": "Scala",
    "code": "object Main extends App {\n  import scala.io.StdIn._\n\n\n  val Array(n, k)  = readLine.trim.split(' ').map(_.toInt)\n  val digit = calMaxDigit(n)\n  val edges = makeGraph(n)\n  println(edges.length)\n  if (edges.nonEmpty) println(edges.map(s ⇒ s\"${s._1} ${s._2}\").mkString(\"\\n\"))\n  for (_ ← 0 until k){\n    var result = 0\n    var response = \"No\"\n    var count = 0\n    while(response != \"Yes\" && count <= digit) {\n      println(1 << (digit - count))\n      response = readLine.trim\n      if (response == \"No\") result *= 2\n      else result = (result * 2) + 1\n      count += 1\n    }\n    if (response != \"Yes\") {\n      println(result)\n      readLine()\n    }\n  }\n  def calMaxDigit(n: Int): Int = {\n    if (n != 1) calMaxDigit(n / 2) + 1\n    else 0\n  }\n  def makeGraph(n: Int, digit: Int = 1, result: List[(Int, Int)] = Nil): List[(Int, Int)] = {\n    if (digit <= n){\n      makeGraph(n, digit << 1, (1 to n).filter(i ⇒ i != digit && (i & digit) != 0).map((digit, _)).toList ++ result)\n    }else result\n  }\n  implicit class Scope[T](val value: T) extends AnyVal {\n    @inline\n    def let[A](func: T ⇒ A): A = func(value)\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\ntypedef long long LL;\nint N,K;\n\nvector<int>v[201];\n\nvoid dfs(int N,int now){\n\tint mid=(now+N)/2;\n\tif(now==mid)return;\n\tif(now==mid-1)return;\n\tfor(int i=now+1;i<mid;i++){\n\t\tv[now].push_back(i);\n\t}\n\t/*for(int i=mid+1;i<N;i++){\n\t\tv[mid].push_back(i);\n\t}*/\n\tdfs(mid-1,now+1);\n\tdfs(N,mid);\n}\n\nvoid answer(int N,int now){\n\tcout<<now+1<<endl;\n\tstring s;\n\tcin>>s;\n\tif(s==\"Yes\"){\n\t}\n\tif(s==\"Near\"){\n\t\tanswer((now+N)/2-1,now+1);\n\t}\n\tif(s==\"No\"){\n\t\tif((now+N)/2==now){\n\t\t\tanswer(N,(now+N)/2+1);\n\t\t}else{\n\t\t\tanswer(N,(now+N)/2);\n\t\t}\n\t}\n}\n\nint main(){\n\tcin>>N>>K;\n\tdfs(N,0);\n\tint a=0;\n\tREP(i,N){\n\t\ta+=v[i].size();\n\t}\n\tcout<<a<<endl;\n\tREP(i,N){\n\t\tREP(j,v[i].size()){\n\t\t\tcout<<i+1<<\" \"<<v[i][j]+1<<endl;\n\t\t}\n\t}\n\tREP(i,K){\n\t\tanswer(N,0);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\n//#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a = b; return 1; } return 0; }\n//---------------------------------------------------------------------------------------------------\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧  \n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     \n　　　　／　　　＼　 　 |　|     \n　　　 /　　 /￣￣￣￣/　　|  \n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  \n　 　　　＼/＿＿＿＿/　（u　⊃  \n---------------------------------------------------------------------------------------------------*/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nint N, K;\n//---------------------------------------------------------------------------------------------------\nstring ask(int x) {\n    printf(\"%d\\n\", x + 1);\n    fflush(stdout);\n\n    string s; cin >> s;\n    return s;\n}\n//---------------------------------------------------------------------------------------------------\nvoid solve1() {\n    printf(\"0\\n\");\n    fflush(stdout);\n\n    rep(k, 0, K) rep(i, 0, N) if (ask(i) == \"Yes\") break;\n}\nvoid solve2() {\n    vector<pair<int, int>> v;\n    rep(i, 8, N) rep(d, 0, 8) if (i & (1 << d)) v.push_back({ d, i });\n    int n = v.size();\n    printf(\"%d\\n\", n);\n    fore(p, v) printf(\"%d %d\\n\", p.first + 1, p.second + 1);\n\n    rep(k, 0, K) {\n        int ans = 0, ng = 1;\n        rep(d, 0, 8) {\n            string res = ask(d);\n\n            if (res == \"Yes\") {\n                ng = 0;\n                break;\n            }\n            if (res == \"Near\") ans += 1 << d;\n        }\n        if (ng) ask(ans);\n    }\n}\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    cin >> N >> K;\n\n    if (N <= 10) solve1();\n    else solve2();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <bitset>\n\nusing namespace std;\n\nint a[40000], b[40000];\n\nvoid solve(){\n  int answer = 0;\n  for(int i=0;i<9;i++){\n    cout << i+1 << endl;\n    string ans;\n    cin >> ans;\n    if(ans == \"Yes\"){\n      return;\n    }\n    else if(ans == \"Near\"){\n      answer |= 1<<i;\n    }\n  }\n  string ans;\n  //  cout << \"answer\" << endl;\n  //  cout << bitset<9>(answer) << endl;\n  cout << answer + 10 << endl;\n  cin >> ans;\n  return;\n}\n\nint main(){\n  int N, K;    \n  cin >> N >> K;\n  if(N <= 10){\n    cout << 0 << endl;\n  }else{\n      int M = 0;\n      for(int j=9;j<N;j++){\n\tint n_idx = j-9;\n\tfor(int k=0;k<9;k++){\n\t  //\t  cout << bitset<9>(n_idx) << \" AND \" << bitset<9>(1<<k) << \" = \" << bitset<9>(n_idx & (1<<k)) << endl;\n\t  if(n_idx & (1<<k)){\n\t    a[M] = k;\n\t    b[M] = j;\n\t    M++;\n\t  }\n\t}\n      }\n      cout << M << endl;\n      for(int i=0;i<M;i++){\n\tcout << a[i] + 1 << \" \" << b[i] + 1<< endl;\n      }\n  }    \n\n  for(int i=0;i<K;i++){\n    if(N <= 10){\n      for(int j=0;j<N;j++){\n\tcout << j+1 << endl;\n\tstring answer;\n\tcin >> answer;\n\tif(answer == \"Yes\"){\n\t  break;\n\t}\n      }\n    }else{\n      solve();\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define all(vec) vec.begin(),vec.end()\n#define mp make_pair\nusing namespace std;\nusing ll=long long;\nusing P=pair<int,int>;\nconst ll INF=1LL<<30;\nconst ll LINF=1LL<<60;\nconst double eps=1e-9;\nconst ll MOD=1000000007LL;\ntemplate<typename T>void chmin(T &a,T b){a=min(a,b);};\ntemplate<typename T>void chmax(T &a,T b){a=max(a,b);};\ntemplate<typename T>vector<T> make_v(size_t a){return vector<T>(a);}\ntemplate<typename T,typename... Ts>auto make_v(size_t a,Ts... ts){return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));}\ntemplate<typename T,typename V>typename enable_if<is_class<T>::value==0>::type fill_v(T& t,const V& v){t=v;}\ntemplate<typename T,typename V>typename enable_if<is_class<T>::value!=0>::type fill_v(T& t,const V& v){for(auto &e:t)fill_v(e,v);};\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\nint main(){\n\tint n,k;\n\tcin >> n >> k;\n\tvector<vector<int>> edge;\n    for (int i = 9; i <= n; i++)\n    {\n        for (int j = 0; j < 8; j++)\n        {\n            if (((i >> j) & 1) == 1) {\n            \tedge.push_back(vector<int>{j + 1, i});\n            }\n        }\n    }\n    cout << edge.size() << endl;\n    for(const auto& e : edge){\n    \tcout << e[0] << \" \" << e[1] << endl;\n    }\n    \n    string judge;\n    for (int i = 0; i < k; i++)\n    {\n        int res = 0;\n        for (int j = 0; j < 8; j++)\n        {\n            cout << j + 1 << endl;\n            cin >> judge;\n            if (judge == \"Yes\") goto end;\n            if (judge == \"Near\") res |= (1 << j);\n        }\n        cout << res << endl;\n        cin >> judge;\n        if (judge == \"Yes\") goto end;\n        while (true)\n        {            \n            cout << res << endl;\n            cin >> judge;\n        }\n        end:;\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Edge{\n\tEdge(int arg_from,int arg_to){\n\t\tfrom = arg_from;\n\t\tto = arg_to;\n\t}\n\tint from,to;\n};\n\n\nint main(){\n\n\tint N,K;\n\n\tscanf(\"%d %d\",&N,&K);\n\n\tint M = 0;\n\tvector<Edge> G;\n\n\tfor(int base = 1; base <= N; base*=2){\n\n\t\tfor(int adj = base+1; adj <= N; adj++){\n\t\t\tif((base&adj)){\n\t\t\t\tG.push_back(Edge(base,adj));\n\t\t\t\tM++;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",M);\n\n\tfor(int i = 0; i < G.size(); i++){\n\n\t\tprintf(\"%d %d\\n\",G[i].from,G[i].to);\n\t\tfflush(stdout);\n\t}\n\n\tint sum;\n\tchar buf[10];\n\tbool FLG;\n\n\tfor(int loop = 0; loop < K; loop++){\n\n\t\tsum = 0;\n\t\tFLG = false;\n\n\t\tfor(int base = 1; base <= N; base*=2){\n\n\t\t\tprintf(\"%d\\n\",base);\n\t\t\tfflush(stdout);\n\n\t\t\tscanf(\"%s\",buf);\n\t\t\tif(buf[0] == 'Y'){\n\t\t\t\tFLG = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(buf[0] == 'N' && buf[1] == 'e')sum += base;\n\t\t}\n\t\tif(FLG)continue;\n\n\t\tprintf(\"%d\\n\",sum);\n\t\tfflush(stdout);\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define DEBUG_MODE\n#define endl '\\n'\n#ifdef DEBUG_MODE\n#define DEBUG(X) debug_func(X, #X)\n#define DEBUG_ENDL endl\n#define DEBUG_SEPARATOR_LINE cout<<\"=================\\n\"\n#else\n#define DEBUG(X) 0\n#define DEBUG_ENDL 0\n#define DEBUG_SEPARATOR_LINE 0\n#endif\n#define ALL(V) (V).begin(), (V).end()\n#define ALLR(V) (V).rbegin(), (V).rend()\n#define DEBUG_ENDL_S(S) ((S).size() ? \"\\n\" : \"\")\ntemplate <typename T> using V = vector<T>;\ntemplate <typename T> using VV = V<V<T>>;\ntemplate <typename T, typename U> using P = pair<T, U>;\nusing ll = int64_t;\nusing PLL = P<ll, ll>;\ntemplate <typename T> const T& var_min(const T &t) { return t; }\ntemplate <typename T> const T& var_max(const T &t) { return t; }\ntemplate <typename Head, typename... Tail> const Head& var_min(const Head &head, const Tail&... tail) { return min(head, var_min(tail...)); }\ntemplate <typename Head, typename... Tail> const Head& var_max(const Head &head, const Tail&... tail) { return max(head, var_max(tail...)); }\ntemplate <typename T, typename... Tail> void chmin(T &t, const Tail&... tail) { t = var_min(t, tail...); }\ntemplate <typename T, typename... Tail> void chmax(T &t, const Tail&... tail) { t = var_max(t, tail...); }\nvoid debug_func_preffix(const string &s) { if(s.size()) cout << s << \" = \"; }\ntemplate <typename T>\nvoid debug_func(const T &t, const string &s = \"\") {\n    debug_func_preffix(s);\n    cout << t << DEBUG_ENDL_S(s);\n}\ntemplate <typename T, typename U>\nvoid debug_func(const P<T, U> &p, const string &s = \"\") {\n    debug_func_preffix(s);\n    cout << \"(\";\n    debug_func(p.first);\n    cout << \", \";\n    debug_func(p.second);\n    cout << \")\" << DEBUG_ENDL_S(s);\n}\ntemplate <typename T>\nvoid debug_func(const V<T> &v, const string &s = \"\") {\n    for(ll i = 0; i < v.size(); i++) {\n        string t = s + \"[\" + to_string(i) + \"]\";\n        debug_func(v[i], t);\n    }\n}\n\nVV<ll> edges;\nVV<ll> dummy_children;\nll e_cnt;\nll N, K;\n\nvoid create_dummy_children(V<ll> now, ll num) {\n    V<ll> nxt;\n    for(ll e : now) {\n        for(ll i = 0; i < 2; i++) {\n            if(num == N) break;\n            dummy_children[e].push_back(num);\n            nxt.push_back(num);\n            num++;\n        }\n    }\n    if(nxt.size()) create_dummy_children(move(nxt), num);\n}\n\nV<ll> add_edges(ll now) {\n    V<ll> tmp1(0), tmp2(0);\n    if(dummy_children[now].size() >= 1) {\n        tmp1 = add_edges(dummy_children[now][0]);\n        for(ll e : tmp1) {\n            e_cnt++;\n            edges[now].push_back(e);\n        }\n    }\n    if(dummy_children[now].size() >= 2) {\n        tmp2 = add_edges(dummy_children[now][1]);\n        for(ll e : tmp2) tmp1.push_back(e);\n    }\n    tmp1.push_back(now);\n    return move(tmp1);\n}\n\nint main() {\n    cin >> N >> K;\n    edges.resize(N);\n    dummy_children.resize(N);\n    if(N != 1 && N != 2) {\n        create_dummy_children({0}, 1);\n        add_edges(0);\n    }\n    cout << e_cnt << endl;\n    for(ll i = 0; i < N; i++) for(ll e : edges[i]) if(i < e) cout << i + 1 << ' ' <<  e + 1 << endl;\n    cout << flush;\n    for(ll que = 0; que < K; que++) {\n        ll now = 0;\n        while(1) {\n            cout << now + 1 << endl << flush;\n            string s;\n            cin >> s;\n            if(s == \"Yes\") break;\n            if(N != 2) {\n                if(s == \"Near\") now = dummy_children[now][0];\n                if(s == \"No\") now = dummy_children[now][1];\n            } else {\n                now = 1;\n            }\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N,K;\n\nbool G[300][300];\n\n\nvoid solve(){\n  cout<<1<<endl;\n  string str;\n  cin>>str;\n  if(str==\"Yes\")return;\n\n  vector<int> tmp;\n  int last = -1;\n  int pos=1;\n  while(pos*2<=N){\n    \n    cout<<pos*2<<endl;\n    \n    string str;\n    cin>>str;\n    if(str==\"Yes\")return;\n    \n    if(str==\"Near\"){\n      pos=pos*2;\n    }else{\n\n      last=pos;\n      \n      tmp.push_back(pos*2+1);\n      pos=pos*2+1;\n    }\n  }\n\n  cout<<pos<<endl;\n  cin>>str;\n  if(str==\"Yes\")return;\n\n  cout<<last*2+1<<endl;\n  cin>>str;\n   \n}\nvoid dfs(int pos,int root){\n  if( pos > N )return;\n  G[root][pos]=G[pos][root]=true;\n  dfs( pos*2 , root );\n  dfs( pos*2+1 , root );\n}\n\nint main(){\n  cin>>N>>K;\n  for(int i=1;i<=N;i++)dfs(i,i);\n  vector<int> from,to;\n  for(int i=1;i<=N;i++){\n    for(int j=i+1;j<=N;j++){\n      if(G[i][j]){\n        from.push_back(i);\n        to.push_back(j);\n      }\n    }\n  }\n  cout<<from.size()<<endl;\n  for(int i=0;i<(int)from.size();i++){\n    cout<<from[i]<<' '<<to[i]<<endl;\n  }\n\n\n  while(K--){\n\n    solve();\n\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define F first\n#define S second\n#define int long long\n#define double long double\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> iP;\ntypedef pair<P,int> Pi;\ntypedef pair<P,P> PP;\ndouble eps=1e-8;\nint mod=1e9+7;\nint inf=1LL<<55;\n\npriority_queue<P,vector<P>,greater<P> > pq;\n\nvector<int> e[201];\n\nsigned main(){\n  int n,k;\n  \n  cin>>n>>k;\n  int m=0;\n\n  for(int i=1;i<=n;i*=2){\n    for(int j=1;j<=n;j++){\n      if(i!=j&&(i&j))e[i].push_back(j);\n    }\n    m+=e[i].size();\n  }\n\n  \n  cout<<m<<endl;\n  \n  for(int i=1;i<=n;i++){\n    for(int j=0;j<e[i].size();j++)cout<<i<<\" \" <<e[i][j]<<endl;\n  }\n\n  \n  while(k--){\n    string s;\n    int ans=0;\n    bool f=1;\n  \n    for(int i=1;f&&i<=n;i*=2){\n      cout<<i<<endl;\n      cin>>s;\n      if(s==\"Yes\")f=0;\n      else if(s==\"Near\")ans|=i;\n    }\n    if(f)cout<<ans<<endl,cin>>s;\n    \n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\n\nint main()\n{\n    int n, k; cin>>n>>k;\n    vector<int> g[201];\n    int m=0;\n    for(int i=0; (1<<i)<=n; i++){\n        for(int j=1; j<=n; j++){\n            if(j==(1<<i)) continue;\n            if(j&(1<<i)){\n                g[1<<i].push_back(j);m++;\n            }\n        }\n    }\n    cout<<m<<endl;\n    for(int i=0; (1<<i)<=n; i++){\n        for(auto x:g[1<<i]){\n            cout<<(1<<i)<<\" \"<<x<<endl;\n        }\n    }\n    for(int i=0; i<k; i++){\n        bool ok=0;\n        int ans=0;\n        for(int j=0; (1<<j)<=n; j++){\n            cout<<(1<<j)<<endl;\n            string s; cin>>s;\n            if(s==\"Yes\"){\n                ok=1;\n                break;\n            }else if(s==\"Near\"){\n                ans^=(1<<j);\n            }\n        }\n        if(ok) continue;\n        cout<<ans<<endl;\n        string s0; cin>>s0;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define int long long\n//#define endl '\\n'\nint mod=1e9+7;\nint mod2=998244353;\nconst int INF=1e9;\n\nsigned main(){\n  int n,k;\n  cin>>n>>k;\n  vector<int> a;\n  vector<int> b;\n  for(int i=1;i<=n;i++){\n    for(int j=0;(1<<j)<=n;j++){\n      if(i&(1<<j)&&i!=(1<<j)){\n        a.push_back(i);\n        b.push_back(1<<j);\n      }\n    }\n  }\n  cout<<a.size()<<endl;\n  for(int i=0;i<a.size();i++)cout<<a[i]<<\" \"<<b[i]<<endl;\n\n  for(int g=0;g<k;g++){\n    int ans=0;\n    string s;\n    bool f=false;\n    for(int i=0;(1<<i)<=n;i++){\n      cout<<(1<<i)<<endl;\n      cin>>s;\n      if(s==\"Yes\"){\n        f=true;\n        break;\n      }else if(s==\"Near\"){\n        ans=ans|(1<<i);\n      }\n    }\n    if(!f){\n      cout<<ans<<endl;\n      cin>>s;\n    }\n  }\n}\n\n// `.`..`(WNNNNNNMNWWWH9rttwgHM8OtttwwVtttrrtrttrw0rtrtwrrrtrZUAOOrrrXWppHMHyZHpWHMHMkWWVHMNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN\n// `.`.`..`(WMNMHfWH9ZtrtAdNM8ttttOwVtrrtrrtrrrrrdrrttrZkOrrrrrrXWyrtrrZWWWWMmwXWppWHHMmWHkWMMNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN\n// .`.```_..(HMfWH9OtttwXWHBrttrOw0rttrOvrrrtrZrrRrtrrrtZHwrrrrrwwZHyrrrrZWWpWMmwWppkWHHMkHNkVWMNNNNN#NN#NN#NN#NN#NN#NN#NN#NN#NN#NNNN\n// .``.. ..HNfWW9wtrrOdWHM0trttOdSrtrtwwrtrtrw0twSrtOrrrrZHwtrrrrrXwdWwrrrrXHppWNkXWpkvWH@MkHMHkWMMNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN\n// `.`. -jMWWXXwtrttO0d@BrtrttwXVrtrrwVrrrtrtXrrd0rrXrrrrrZWyrrrrrrZXwWyZOrrvWWpWMkZHbkwrdHMMKMMNHkHMNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN\n// `.`. v8Xdk9ttttrOwXM0tttrtwXwwrtrw0rrtrrtwKrrd0rrXrtrrrrZHkwrrrrrrXkVkrrrvrZHWpHHkWkwrwvVHHNWMMMMkWMNNNNNNN#NN#NN#NN#NN#NN#NN#NNNN\n// .. JHZdbKOrrrtrtwWWOOttrOwSzVrOrw0rrttrrrdRrrdZrrdOrtrtrrZHkXwrrrrrZWXHwwrrrvWWWWNkWkvrrrwWM@RMMMNNmWMNNNNNNNNNNNNNNNNNNNNNNNNNNNN\n// . .JGXHStttttrtwW9OrtrrrdSX0rtrdStrtrtrrwHVrrdkrrtSrrrrrrrdMyXrrrrrvXWXWmwvrrvdHWWNkWyvvvvvT@MNWM#N#MNWMMNNNNNNNNNNNNNNNNNNNNNNNNN\n// (.zqHXZtrttrrOwU0trttrOdWX0OtOdRrrtrrrrrdNrrrdkrrrXOwrrrrrrdNySrrrrrwXXkUmvvwvrZHWfNkUkvwvvvdMMMRM#MMNNNkMMNNNNNN#NN#NN#NN#NN#NNNN\n// (wdS0OttrtOOrwSrtttrrtwKukrrrwKrrrrrtrrwW@rrrXKrrrZkr0OrrrrrWNwkrvvrrvzXkXHwvvrvwWVVHkUyrvvvvZHMMNWMMNNNNNkWMNNNNNNNNNNNNNNNNNNNNN\n// wWtrrttrrOwrwStrttrtrwWZXOrtwX0rrrttrrrXMSrrrXWrrrrXrwvrrrrvZHHXkrrrrvrzWkXNyvrvvvWWWHHWwvvvvvwHNMHRM#NNNNNMmWMMNNNNNNNNNNNNNNNNNN\n// 8OtttrwZwwtwSrrttrrrwdyXwtrrdWrrtrrrrrdWH0rrrXWOrrrwRz0rrvrrrdMHWwvvrrvvXWkWHyrvvvrWWWHkHvvvvvvwWMMMNWMMNNNNNMHWMMNMNNNN#NN#NNNNNN\n// wttrrdVrZrwWwtOrrrrwdWX0rrtdH0rrrtrrtwWHHrrrrXWRrrvrXXXrrvrrrvXHkSwvvrvrrXWkVHyvvvvwHVWHWRvvvvvvdHdMMMKMNNNNNNNMNkWMNNNNNNNNNNNNNM\n// ttrrd0rwrOX0rrtrrtwXHXSrwrwHKrtrtrrtrdWH#rrrrdpkrrrrvHwkwvrrvrZWHXkzzvvvvwUWkpNwvrvvZHfVNHwvvvvvzXHWMNMNMNNNNNNNN#NkWMNNNNNNNNNM3>\n// rrrdSrwwtXSrrtrrrwXWWKwrrrdHXrrrrrrrwWWH#vrrrvWpvrrvrdRXwvrvrvvXHWWwkvvrvvwWWKWHzwvvvXHVWWHvzzzzvzWRHMMMNHMNNNNNNNNMNkMMNNNNNN@<<>\n// OOd9rw0rdKOtrtrrruXHW0rrrdH#rrrrrrrrdpWp#rrrrrXWkvrvvrWwkrvrrvwwWHpKdvvrrvvXHHfWmdwvzwWHVHWkzzzzzzwWXHMHHNWMNNNNNNNNNMNkMNNNN#z>>>\n// OdSOwSwwW0rrrrtrwXNW8rrtrWWSrtrrrrrrXpHWHvrrrrXpHrrrvwZHdyvvvvvvXHpHwkvvvvvrXHHfNwXvzzwWWWKHzzzzzzzWSWHHHMMKMNNNNNNNNNNMNKMNN#>>;>\n// wWwOXrwX8rtrrrrwWWpHrrrrdNNrrrrrrrrwppNWHrvrvrypWwvvrrvXKWvrvrvvZXHHkXzvvvvvwWWWWNdkvvzXHfHWkXzzzzzwWXHHHHNMHMNNNNNNNNNNNNNWMN+>>>\n// R0rd0rdKrrtrtrrdWHWSrrrwWWDrrrrrrrrXpWHqWvrrrvdWbRvvrvvwWZkvvvrvvXHbHzRvvvvvvdHHpHkWwvzXWHWHHzuzzzzzXXWHHHMHMNHMNNNNNNNNNNNMNWh<>>\n// wOwSrwXSrtrtrrwHWWMwrrrdNWSrrrrrrrvppWpHprrvrvddWHwvvrrvXHXwvvvrvzXWHkXzvvvvvzWWKWNdRvzzXWWHHXzzzzzzzudWHbH@HNNWMNNNNNNNNNNNNNkHe>\n// rOXwwwKrrrrrrrXWHHDrrwrdHHXwrrrrrrwpWWbHWvvvrvwHHpHrvvvrXWHWwvvrwwXHkHdkvzvvvvZHHpHKWzzzwWHWHRzzzzuzzzzWHHkHHMMNWMNNNNNNNNNNNNNNKm\n// rdX0OXSrrtrrrdHHWMXrrrwHWHrrrrrrrrXppqWHWkrrvvwWMHHXwwvvvZWKRvvvvrWHWHwWvzvzzzzXWKWNXRzzwXWWNHzzzzzzzzzXUHkHWMMHNWMNNNNNNNNNNNNNNN\n// wSwww#rrrrrrwWWHM#vrrrd#WKvrrrrrvvXppmWMWkvvvvwXNNpNvSXzzvdHkkvvzvdWWWRXwzzzzzzdNNpMkHzzzWVHHpXzzzzzzzzdkHkHHHNMHNkMNNNNNNNNNNNNNN\n// XwSwWwrrrrrrdHWWMKrvrvWHWSrvrvvvvwpppHW#HRwUUUWWMMMMMHHHHmmXHWwvvzwWHbNwRzzzzzzzWWWWHWkzzdXWWWRzzzzzzzuzWWbHHWMNMMNkMNNNNNNNNNNNNN\n// 8drd#rrrrrrwWWkHMmXmywMfWXrvrrrvrwppWNWMNWvrvvwvW#MNHmdkrvvXHMMmmwzdWpM0WzzzzzzzdHHWNUHzzzWWmHHzzuzzuzuzWXbbNkHMqMHNkHNNNNNNNNNNNN\n// dSwWSrrrrrrdHHHMHrrrwWMfWvvvrvrrrdppWNW#WWRvvrvvdM?WNHkXkzvvdWMHXHNmHHHkfwzzzzzzXHHpMWHkzuXWHNWXzzuzzuzzXXkkHbHMHMMMMkMNNNNNNNNNNN\n// Xrd#wrrrrrrXpHWH#rrrvdMWWvrrvrvvrdppWHW#(NWwvvvvwMr~TNHmdkvzvXWMKzzzWMHKXXzzzzzzuWHbHkWKuzdWWHWkzzzuzzuuXXHkHkgHk@H@HHkMNNNNNNNNNN\n// RvWDrrrrrrwHWkMW#rvvrMMfWwrvrrvvrdppWHW@~?HHuvvrvdb_~?NWkdkzzzUWMkzuuWWHWXuzwzzuzXHHHKWHuzzWW@WRuzuzzzzzduWbHHgMH@HHHMMHMNNNNNNNNN\n// rdHwrrrrrrXHHWNW#vvvdMMHWkvrvrrvrdppWbWD~~?XKkrrrwMc~~~THHZHwzzWHNkvzwMRdHHzuzzzzXHHWHXNkuzdWHkWuzzuzuzzXzWkHHHMHHHkH@MMNWMNNNNNNN\n// rdHvrrrrrrWkHHHW#rrrd#dNWKrvrvvrvwbpWWW$...vVkkOrtXb~~~~(WHkWkvwWWMkzzWRXkSWXzzzuwmNWHXHRuuwHMKWzzuzzzuzXzWHWHHMHHHkkMMMHHWNNNNNNN\n// wW#rrvrrrwHWHMpWNrvrd@(NWWvrrrrrvvWpWXH$..._?dkkttOWl~~~~~?HHdHXXbWMkzUHXWkzzzzzzuHNk#XHHzzukHHXzuzzzuzuXuXqkMHMHMbbkHHH@HNWMNNNNN\n// dH#rrrvrrdNWWNpHHwrrd@_WHWkrvvrrrrZpWXWr...__?WkWyOvN~~~~~__7HkWkbbkNkzXHZkzzzuzzzWHW#ugbXuzWWHXXuzzuzuuuzXkkHHH@MbkHMHMHMMNWMNNNN\n// X@KrrvrvrXNHWHpHHHrrdb~(NWHrrrrrrrrXWXWr..`...-7HZkzvn~~~~~~~_TNyHHkHMyzXkXuzzzzuuWHW#uHkkzzWHHXuzzzzuzzuuXHkHHHMNbkHHHHHHMMNWMNNN\n// WHKvvrvrvXHNMbpHmHkOwb..?HWRrwOrtrtrWKWr`.`.`..._?6dkJn~~~~~~-_~7NHMHbNkuUkzzuzzzuWHW#uHbRzuXHHXzzuuuuzuuzXHkHHMMbkkHkMkkkMMMNUMMN\n// WHKrrvrrvXqHMpfHHHWkrb...vkHyOrtttttdNXr.`.J>~-((J+ggQkHXHHHmaJz7&JWHMMWkuHXzuuuzzWgHHwHkKuzXMKXuzuuzuzzuzdkHHHHHkHWMHHbkWHMMMNXM#\n// Wg#rvrvrrXmHNpfHHHMMRd-.._4kfyttttllOHWr`` <udT\"\"\"7\"\"\"\"\"TMHHMNHHMNgv4HMRXHXHwuzzzuWHHKXHkHzzXMSWzuzzuzuuzudbkHHHHkkHqHuWkWHHMMMNWM\n// WHNrvrvvvXHmNppgg@MMMHr..` UkWOlllllldW$..?!     `     ` ?@MMHHMM#NMMmMkXXWkHuzuzuWNHSXHHHuuXNSWuzuuzuzuzuWkHNgMkkkMHSuWkqmqHHMNNK\n// WHMkvvrvrXHHMppHHHMNMTN_``` 4kWOz====vXP` `   `        ``.HggmgM@MH###NKkkuXWHzzuXHHMzdMHHuzWNXKzuuzuzuzuuHkHHNMkkHHBuzWkHHHHuHMMM\n// WHHNzvvrvwHMMppHMMMM>.#L`````?kyy====?0S``  `     ` ``...dmqqqmmHHHMMM#WRSzuzWHuzXHq#uWHHHzuWHXKzuzzuzuzuXHkHWMNkWM#uzuWHHHHSuuWM#\n// WM@MkwvvrzXMMHpgHMMM[.MN.`````(HXy1???zd.``  `  `   ` dHkkqkkqkHHHHHHMMWWXzzuzwWwXHHKXMkHHuXMRXSuuuzuuzuzXHkHdHHWHHXuuwWHqHHuXzXWM\n// XHHMNyrvvwdW@HpHWMHML MM[`  ` `.4kGz<<>Or```  `      `dWpbbbbbHMMbbbHHMXXuzzuzuzXWHHSXMkHHuXMSXuzzuzzuzuzWkkHWMHMSwuzzXHkHHXuzuWd#\n// dHHH@NyzwwwWHMHHWMMMR dW]`` ` ```(HZx<<<4.```` `` ``  OZppfppppWfpWpK9NKXuuzuuzuXWHHudMqNHXWNuHuzzuzuzuzuHkHXMMBuuuzuuWkHHUuuuXSMS\n// wWHMMMMkwwvdNpHHHM#MH-jWP``` `` ```7kI<:<h.``````` `` ,2OWVVyVVyWWWWIdMKWzuuuzzuXHHSwHHHHKXHHXSuuzuuzuzuXHHHXMXuuuuuuXHHHuzuuXSX#X\n// wdWHMMMMmwXwHbpMNHMM@b.hb``````````` 7x1_(>_```````````(x7UUUV0XwvCI1dMWKXuzzuzuWHHudMkgkWbMSXuzzzuzzuzuWkHSW#zXwXuXXWHHuuXXuWXWSX\n// vvXWHMMHWNkvWHbbMWMMMN_JF.```` `` `````?1_(_.`.`........(<777=<<<><<+dMXUuzuuuuWWMRwMHWMkWHHXSuuzuzuzzuXqHHXMHUXuXXHHHSuuwuXWud8uH\n// mzzXWH#zHbHkXNbbWMMMMD~(_``````````````` .~_`.``.`.`.....___(<~(<<(<<dHkkuuuuuXkHHuWMkHkkkHSXXzuuzuuuuzXHHSd#uuXXWHHXuuuZuXSuqHudS\n// UHzzXWSXXWbbHHHbWHMH#<~...```` ``````````````.```.` -_____<~~_<_<~~(jMWSuzuzuXWHMHXMHHHkkH#XSuzzuzuzuzuKkHXMQkWHHWUXuXXUuXUuXHuXBu\n// .(Smd8wSvXbbbbHHHWHW3___.``````` `` ``````.```.```.`...._.._~~..~_~~(#WuzuuzXXkHMqMMHMkkkMUXuXzuuwuuzuXkHSWMWUUuuuXXUUuXHXXWSuXHXu\n// .. JKwSvwzWkkkkHHHH5~~..```````````````````.```.````````.` .........dWSuuzzzdkHMW@MHMkkkHHXXuzuuXSuzuuWWHd#uuuXXkWSuXXWUXXHUXWHuuu\n// .`(HXSzzzzwWbkWHNHr_...``````````````````.```````.```````.`.`..`.-.(HKuzzuuwHHMNMHHMkkkHHuZuuzuuXuuuuXkHWMHHHUUuXXXWHXXHHUuXW8uuuu\n// .-MXWwzzzuzXkHHMHHN-.`````````` ````````````.`.````.``.```.`.`....-dXUXuzuXHWHMMHHBWHMMMSZuzuuzXXzuuXHHMHMHkHHHHHHHWHHSuXkHWSuuuuX\n// (#XKzzzzzuzuWHHkWHHp ``.````````````````````````.````````.....-((-(NSXuzzXHW@D:~`(/1- .kXuzuuzXSuuzXXkHWMHHHHHHHHMWuuuQXUXWuuuXuXH\n// MXWzuzzzzzuXHHbHNMMMt`.```````````````````````````.`.` ..-J7\"!``  XKuzzuXHHM9;/<-.J-u!JXXuuzuXWuuuuXHHH#WMNHmkkkuXXkWUXXWXXuuuXqHH\n// XWzzzzuzzwXHHHH#\"````<.````````````````````.``.`...-c\"7``` ` `  `(BzuuuXmHH8<!(- ?_!`jWUuzuuuWuuuzXWHNH> ..7WHHqHmQkWWXXuuuuuXWqHH\n// SwuzzzXuwXHNHY``  ``  <,`.`````````````` `` ..J7=``` ` ` `` ````.#zuzXXHHH$~`` ```(_(HSuuuzuXSuzuuXHHWCi(` ._ ?WggHHHHWkkkkWHHHHMH\n// zzzuzuzwWHMY!`  `   ` `(&.```````````` ..J7^ `` `  `  `   ` `. .HXuuXWHW#!` ` ```` (WUuzzuXXSzuuudHHXY$. : (..``.THHkqkHHHgHHMHkkk\n// zzzzzzXHWK``  ` `` ` ` ` TJ.``````..J7=````    ` `  ` ` `` ` `.8zuXXHHW=`   ``  ..(XSuuuuuXWuuuuXHWH5~~` .`_?_,-``.TMMMMMMHkkqqHHH\n// zzuuzdHHkN ` ` `  ``  ` ``(Wm,.(J7!```  `  ``` `` `` ` ` ``` .SzuXWHHY `` .._~<~~(dSuuuzzXHuuuuXHWHD::?C._.( -`(!_1 ,WHqHHHmqHHHHN\n// zuzXXHHkHM;`  ` ` ` ``  ` .;jY= ` .``_``  `  `  `  ` `` ` `.dXuXWm@^ .._~_.~~~~~(d0uuzuuXHUuuuXHWH5:::::::_.<&._4r?_.;WMMM@MMY\"<!`\n// zzXHHHHMHMb`` `` ` `` `` .J!  ` ..`_~  ` ` ` `` `   `  ``.JXXXHY! .__.....~.~~~-d0wuzuXXHSuuuXWWH$::::;:::;:+- ~`(.i +HqHHkkHL..`.\n// XWHHHMMHMHM; `  ` `   ` ._`` ...(:.=_` `  ` `  ` ```` .-dVT7^``````......~~~~~_jWuuuuuXHSuzuXHHH3<;:::::;;j<+z ``` -dHNkkMqkkN..``\n// HHHMMHHHHNMN.``  ` `  `!`z(. ~..~ ! . ` ``  ` ` ` ..gHr``````````........~~~~_jWuuuuuXkSuuuXHWHC:;::;;:::+v>:((J<!(WHHMkkHNqkM;`..\n// HMMkkHHHHM9?b ``  ` `  ``     .``. `  ` ` `  ``` 4HkkkH,  ``````.`......~~~~_+KuuuzuXHSuuuXHHK<(::::::<;<J+g9>::;<  .4NkkqMHqH]..`\n// MHkHHHMM$<<:?L` `` ` `  ` ``.` `  !``  ` ` ` `  ` ?HbkkHx``````.`..`...~~~~_jKuuuuuXHSuuuqMHD<:<;:<++ddNMB3:;::;:<` `,HkkqH@HH].``\n// kkHHkHY``` (;?h`` ` ` ``  ````  ` ` ` ` ` ` ` ` ```.4XWbHx```..`......~~~~_gKuuuuXWH0uuuXHH3:;++1z<jgMB3<::::::::~` `jMkqkHMHHF.`.\n// kHHHH=` . ` _<?L  ` `  ` `    `  ` ` ` ` ` ` `  ` `  ?kwWHp .`.......~_~~(dKuuuuXWHUuuXWH9++z1<;+jWB3::::;;;::;:;_`` MNkqkqMNMF..`\n// HHk@!.  ` ` ` ~?L  ` ` `` ` `` `` ` ` ` `  ` ` `   `  -WuXHh..`.....~~~~(dWuuuXXkHUuuXHH9>:<:++YY<:;::::;:::::;:::+.``?HHkHHHM>`.`\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(int (i) = (s);(i) <= (e);(i)++)\n#define all(x) x.begin(),x.end()\n\ni64 N,K;\n\n\nvector<i64> a,b;\n\nint NEAR[202];\nint NO[202];\n\nvoid solve() {\n  int v = 1;\n  while(1) {\n    cout << v << endl;\n    string s;\n    cin >> s;\n    if(s == \"Yes\") return;\n    if(s == \"Near\") {\n      v = NEAR[v];\n    }\n    if(s == \"No\") {\n      v = NO[v];\n    }\n  }\n}\n\nint idx = 1;\n\nvector<int> par;\n\nint rec(i64 n) {\n  if(n == 0) return -1;\n  for(auto p: par) {\n    a.push_back(p);\n    b.push_back(idx);\n  }\n  par.push_back(idx);\n  int res = idx;\n  n--;\n  idx++;\n\n  NEAR[res] = rec(n / 2);\n\n  par.pop_back();\n\n  NO[res] = rec(n - n / 2);\n\n  return res;\n}\n\nint main() {\n  cin >> N >> K;\n  rec(N);\n\n  cout << a.size() << endl;\n  for(int i = 0;i < a.size();i++) {\n    cout << min(a[i], b[i]) << \" \" << max(a[i], b[i]) << endl;\n  }\n\n  for(int i = 0;i < K;i++) {\n    solve();\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<vector>\n#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<iomanip>\n#include<assert.h>\n#include<unordered_map>\n#include<unordered_set>\n#include<string>\n#include<stack>\n#include<complex>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\t\n#define WHATS(var)//cout<<__LINE__<<' '<<#var<<\"=\"<<var<<endl;\n\t\ntemplate<class S, class T> ostream& operator <<(ostream &os, const pair<S, T> v){\n\tos << \"( \" << v.first << \", \" << v.second << \")\"; return os;\n}\ntemplate<class T> ostream& operator <<(ostream &os, const vector<T> &v){\n\tfor(int i = 0; i < v.size(); i++){if(i > 0){os << \" \";} os << v[i];} return os;\n}\ntemplate<class T> ostream& operator <<(ostream &os, const vector<vector<T>> &v){\n\tfor(int i = 0; i < v.size(); i++){if(i > 0){os << endl;} os << v[i];} return os;\n}\ntemplate<class T> ostream& operator <<(ostream &os, const vector<set<T>> &v){\n\tfor(int i = 0; i < v.size(); i++){if(i > 0){os << endl;} os << v[i];} return os;\n}\ntemplate<class T> ostream& operator <<(ostream &os, const set<T> &v){\n\tint i=0;\n\tfor(auto it:v){\n\t\tif(i > 0){os << ' ';}\n\t\tos << it;\n\t\ti++;\n\t} \n\treturn os;\n}\n\nusing ll =long long ;\nll mod;\n\nvoid solve(vector<vector<int>>&cango){\n\tint tt=cango.size();\n\tfor(int i=0;i<tt;++i){\n\t\tfor(int j=0;j<tt;++j){\n\t\t\tfor(int k=0;k<tt;++k){\n\t\t\t\tcango[j][k]|=cango[j][i]&cango[i][k];\n\t\t\t}\n\t\t}\n\t}\n}\nvector<int> dfs(int now,int N,vector<pair<int,int>>&edges){\n\tvector<int>av{now};\n\tif(now*2+1<N){\n\t\tauto v=dfs(now*2+1,N,edges);\n\t\tav.insert(av.end(),v.begin(),v.end());\n\t}\n\tif(now*2+2<N){\n\t\tauto v=dfs(now*2+2,N,edges);\n\t\tfor(auto e:v){\n\t\t\tedges.push_back(make_pair(now,e));\n\t\t}\n\t\tav.insert(av.end(),v.begin(),v.end());\n\t}\n\treturn av;\n}\n\nint ask(int x){\n\tcout<<x+1<<endl;\n\tfflush(stdout);\n\tstring st;cin>>st;\n\tif(st==\"Yes\")return -1;\n\telse if(st==\"No\")return 0;\n\telse return 1;\n}\nint main() {\n\tios::sync_with_stdio(false);\n\tint N;cin>>N;\n\tint K;cin>>K;\n\tvector<pair<int,int>>edges;\n\tdfs(0,N,edges);\n\tsort(edges.begin(),edges.end());\n\tcout<<edges.size()<<endl;\n\tfor(auto e:edges){\n\t\tcout<<e.first+1<<' '<<e.second+1<<endl;\n\t}\n\n\twhile(K--){\n\t\t\n\t\tint now=0;\n\t\twhile(true){\n\t\t\tint xx=ask(now);\n\t\t\tif(xx==-1)break;\n\t\t\telse{\n\t\t\t\tnow=now*2+1+xx;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\t\n}\n"
  },
  {
    "language": "C++",
    "code": "    #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n//    int dx[8]={0,1,0,-1,1,1,-1,-1};\n  //  int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                        \n\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\nll extgcd(ll a, ll b, ll &x, ll &y) {\n    if (b == 0ll) {\n        x = 1ll;\n        y = 0ll;\n        return a;\n    }\n    ll d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n} \n                                \n                int pr[200010];\n                int inv[200010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tinv[ert]=beki(pr[ert],mod-2,mod);\n                \t\n                \tfor(int i=ert-1;i>=0;i--) inv[i]=inv[i+1]*(i+1)%mod;\n                \t\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n    //mt19937(clock_per_sec);\n  //  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()) ;\n\t   \n       \n                               //----------------kokomade tenpure------------\n\nvector<pa> eda;\n\nvoid saiki(int l,int r){\n\tif(r-l<1) return;\n\t\n\tint l2=l+1,r2=r;\n\tint m2=(l2+r2)/2;\n\tfor(int i=l2;i<=m2;i++){\n\t\t\teda.pb({l,i});\n\t}\n\tsaiki(l2,m2);\n\tsaiki(m2+1,r2);\n}\n\nvoid junbi(int n){\n\t\n\tsaiki(1,n);\n\t\n\tcout<<eda.size()<<endl;\n\tfor(auto v:eda)cout<<v.first<<\" \"<<v.second<<endl;\n\t\n}\n\n\nvoid solve(int n){\n\t\n\tint l=1,r=n;\n\t\n\twhile(1){\n\t\tcout<<l<<endl;\n\t\tstring s;\n\t\tcin>>s;\n\t\t\n\t\tint l2=l+1,r2=r;\n\t\tint m2=(l2+r2)/2;\n\t\tif(s[0]=='Y')return;\n\t\tif(s[1]=='o'){\n\t\t\tl=m2+1,r=r2;\n\t\t}\n\t\telse{\n\t\t\tl=l2,r=m2;\n\t\t}\n\t}\n\t\n\t\n}\n\nsigned main(){\n\n//\t\t\t  cin.tie(0);\n//\t\t\tios::sync_with_stdio(false);\nint n,k;\n\tcin>>n>>k;\n\t\n\tjunbi(n);\n\t\n\t\n\tfor(int i=0;i<k;i++)solve(n);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<ll(n);++i)\n#define RREP(i,n) for(ll i=ll(n)-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<ll(n);++i)\n#define RFOR(i,m,n) for(ll i=ll(n)-1;i>=ll(m);--i)\n#define ALL(v) (v).begin(),(v).end()\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconstexpr int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconstexpr int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vvi = vector<vi>;\nusing vvl = vector<vl>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\ntemplate <class T> bool chmin(T &a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate <class T> bool chmax(T &a, T b) { if (a < b) { a = b; return true; } return false; }\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n, k; cin >> n >> k;\n\tvvi c(n);\n\tvvi g(n);\n\tfunction<void(int)> dfs = [&](int v) {\n\t\tc[v].push_back(v);\n\t\tint l = v * 2 + 1, r = v * 2 + 2;\n\t\tif (l < n) {\n\t\t\tdfs(l);\n\t\t\tREP(i, c[l].size())c[v].push_back(c[l][i]);\n\t\t}\n\t\tif (r < n) {\n\t\t\tdfs(r);\n\t\t\tREP(i, c[r].size())c[v].push_back(c[r][i]);\n\t\t}\n\t};\n\n\tdfs(0);\n\tREP(i, n) {\n\t\tint l = i * 2 + 1, r = i * 2 + 2;\n\t\tif (l < n) {\n\t\t\tREP(j, c[l].size()) {\n\t\t\t\tg[i].push_back(c[l][j]);\n\t\t\t}\n\t\t}\n\t}\n\tint cnt = 0;\n\tREP(i, n)cnt += g[i].size();\n\tcout << cnt << endl;\n\tREP(i, n)REP(j, g[i].size())cout << i + 1 << \" \" << g[i][j] + 1 << endl;\n\tint v = 0;\n\tREP(aaa, k) {\n\t\tint v = 0;\n\t\twhile (1) {\n\t\t\tcout << v + 1 << endl;\n\t\t\tstring s; cin >> s;\n\t\t\tif (s == \"No\") {\n\t\t\t\tv = 2 * v + 2;\n\t\t\t}\n\t\t\telse if (s == \"Near\") {\n\t\t\t\tv = 2 * v + 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n    if (n < 10) {\n        int m = 0;\n        cout << m << endl;\n        for (int i = 0; i < k; i++)\n        {\n            for (int j = 1; j <= n; j++)\n            {\n                cout << j << endl;\n                string s;\n                cin >> s;\n                if (s == \"Yes\") {\n                    break;\n                }\n            }\n        }\n    }\n    else {\n        int a = 8;\n        vector<vector<int>> edge(n + 1);\n        int m = 0;\n        for (int i = n, l = 1; i > n - a; i--, l <<= 1)\n        {\n            for (int j = 1; j <= n - a; j++)\n            {\n                if ((j & l) > 0) {\n                    edge[j].push_back(i);\n                    ++m;\n                }\n            }\n        }\n        cout << m << endl;\n        for (int i = 1; i <= n - a; i++)\n        {\n            for (auto& item : edge[i]) {\n                cout << i << ' ' << item << endl;\n            }\n        }\n        for (int i = 0; i < k; i++)\n        {\n            int ans = 0;\n            for (int j = n, l = 1; j > n - a; j--, l <<= 1)\n            {\n                cout << j << endl;\n                string s;\n                cin >> s;\n                if (s == \"Yes\") {\n                    goto A;\n                }\n                else if (s == \"Near\") {\n                    ans |= l;\n                }\n            }\n            cout << ans << endl;\n            {\n                string s;\n                cin >> s;\n                assert(s == \"Yes\");\n            }\n            A: continue;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Edge{\n\tEdge(int arg_from,int arg_to){\n\t\tfrom = arg_from;\n\t\tto = arg_to;\n\t}\n\tint from,to;\n};\n\n\nint main(){\n\n\tint N,K;\n\n\tscanf(\"%d %d\",&N,&K);\n\n\tint M = 0;\n\tvector<Edge> G;\n\n\tfor(int base = 1; base <= N; base*=2){\n\n\t\tfor(int adj = base+1; adj <= N; adj++){\n\t\t\tif((base&adj)){\n\t\t\t\tG.push_back(Edge(base,adj));\n\t\t\t\tM++;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",M);\n\tfflush(stdout);\n\n\tfor(int i = 0; i < G.size(); i++){\n\n\t\tprintf(\"%d %d\\n\",G[i].from,G[i].to);\n\t\tfflush(stdout);\n\t}\n\n\tint sum;\n\tchar buf[10];\n\tbool FLG;\n\n\tfor(int loop = 0; loop < K; loop++){\n\n\t\tsum = 0;\n\t\tFLG = false;\n\n\t\tfor(int base = 1; base <= N; base*=2){\n\n\t\t\tprintf(\"%d\\n\",base);\n\t\t\tfflush(stdout);\n\n\t\t\tscanf(\"%s\",buf);\n\t\t\tif(buf[0] == 'Y'){\n\t\t\t\tFLG = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(buf[0] == 'N' && buf[1] == 'e')sum += base;\n\t\t}\n\t\tif(FLG)continue;\n\n\t\tprintf(\"%d\\n\",sum);\n\t\tfflush(stdout);\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//実装が重そうな問題はある程度考えてから書く\n//初期化を忘れずに（特に二分探索とか）\n//コーナーケースを考えて（特に場合分けとか）\n//不可解すぎるバグは配列外参照（配列の長さ）を検討\n#include \"bits/stdc++.h\"\n#define YES \"YES\"\n#define NO \"NO\"\n#define YESNO OUT(three(solve(),YES,NO))\n#define ECHO OUT(solve())\n#define three(A,B,C) ((A)?(B):(C))\n#define FOR(i,a,b)  for(LL i=(a);i< (LL)(b);i++)\n#define EFOR(i,a,b) for(LL i=(a);i<=(LL)(b);i++)\n#define RFOR(i,a,b) for(LL i=(a);i>=(LL)(b);i--)\n#define REP(i,b) FOR(i,zero,b)\n#define EREP(i,b) EFOR(i,zero,b)\n#define RREP(i,b) RFOR(i,b-1,zero)\n#define ALL(c) c.begin(),c.end()\n#define UNIQUE(c) sort(ALL(c));c.erase(unique(ALL(c)),c.end())\n#define MAX(c) (*max_element(ALL(c)))\n#define MIN(c) (*min_element(ALL(c)))\n#define MP make_pair\n#define FI first\n#define SE second\n#define SI(x) (LL(x.size()))\n#define PB emplace_back\n#define DEBUG(a) OUT(a)\n#define DEBUG2(a,b) OUT2(a,b)\n#define cat cout << __LINE__ << endl\n#define OUT(a) cout << (a) << endl\n#define OUT2(a,b) cout << (a) <<\" \"<<(b) << endl\n#define int long long\n#define zero 0LL\n#define pb PB\nusing namespace std;\ntemplate<typename T> inline bool middle(T a, T b, T c) { return b <= a && a <= c; }\ntemplate<class T> inline bool MX(T &l, const T &r) { return l < r ? l = r, 1 : 0; }\ntemplate<class T> inline bool MN(T &l, const T &r) { return l > r ? l = r, 1 : 0; }\ntypedef long long LL;\ntypedef double ld;\ntypedef LL ut;\ntypedef vector<ut> VI;\ntypedef vector<VI> VII;\ntypedef pair<ut, ut> pr;\ntypedef pair<ut, pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef vector<ppr> Vppr;\ntypedef priority_queue<pr, Vpr ,greater<pr> > PQ;\ninline void outputVI(VI x) { REP(i, SI(x)) { cout << three(i, \" \", \"\") << x[i]; }OUT(\"\"); }\nint dx[] = { 0,1,0,-1,0 }, dy[] = { 1,0,-1,0,0 };\nconst int SIZE1 =3e5 + 1000;\nconst int SIZE2 = 5010;\nconst int SIZE3 = 22;\nconst int SIZE = SIZE1;\nconst LL p = 7 + 1e9;\nconst LL INF = 1LL << 60;\nconst long double EPS = 1e-7;\nut N, M, K, X, L, Y,H,W,Q;\n// ut A,B,C,D,E,F,G,H,I,J,O,P,Q,R,T,U;\nVI edges[SIZE];\nLL vals[SIZE], nums[SIZE], maps[SIZE3][SIZE3], answer = zero;\nLL A[SIZE], B[SIZE];\nLL output(int x) {\n\tcout << x << endl;\n\tstring k;\n\tcin >> k;\n\tif (k == \"No\") return 0;\n\telse if (k == \"Yes\") return 2;\n\telse return 1;\n}\nLL solve2() {\n\tLL num = 0;\n\tLL ans = 0;\n\tEFOR(i, 1, 9) {\n\t\tans = output(i);\n\t\tif (ans == 2) return 0;\n\t\telse if (ans == 1) num += 1 << (i - 1);\n\t}\n\tassert(num <= N);\n\tassert(output(num)==2);\n\treturn 0;\n}\nLL solve() {\n\tcin >> N >> K;\n\tif (N <=10) {\n\t\tcout << 0 << endl;\n\t\tREP(k,K)\n\t\t\tEFOR(i,1, N) {\n\t\t\t\tif (output(i)==2) break;\n\t\t\t}\n\t}\n\telse {\n\t\tVpr v;\n\t\tEFOR(i, 1, 9)\n\t\t\tEFOR(j, 10, N) {\n\t\t\tif (j&(1 << (i - 1))) {\n\t\t\t\tv.pb(i, j);\n\t\t\t}\n\t\t}\n\t\tcout << v.size() << endl;\n\t\tREP(i, v.size()) cout << v[i].first << \" \" << v[i].second << endl;\n\n\t\tREP(i, K) solve2();\n\t}\n\treturn 0;\n}\nsigned main() {\n\tios_base::sync_with_stdio(false);\n\tcout << fixed << setprecision(10);\n\n\tsolve();\n//\tcin >> N;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_set>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\n\n\nint main(){\n    ll n,k;\n    cin>>n>>k;\n    if(n<=10){\n        cout<<0<<endl;\n        while(k--){\n            for(int t=0;t<n;t++){\n                cout<<t+1<<endl;\n                string s;\n                cin>>s;\n                if(s==\"Yes\"){break;}\n            }\n        }\n    }\n    else{\n        ll s=n-9;\n        ll cnt=0;\n        for(int i=0;i<9;i++){\n            for(int t=0;t<s;t++){\n                if(t>>i&1){cnt++;}\n            }\n        }\n        cout<<cnt<<endl;\n        for(int i=0;i<9;i++){\n            for(int t=0;t<s;t++){\n                if(t>>i&1){cout<<t+1<<\" \"<<s+i+1<<endl;}\n            }\n        }\n        while(k--){\n            ll ans=0;\n            bool done=false;\n            for(int i=0;i<9;i++){\n                cout<<s+i+1<<endl;\n                string s;\n                cin>>s;\n                if(s==\"Yes\"){done=true; break;}\n                else if(s==\"Near\"){ans|=(1LL<<i);}\n            }\n            if(!done){\n                cout<<ans+1<<endl;\n                string s;\n                cin>>s;\n            }\n        }\n    }\n    \n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int n, k; cin >> n >> k;\n    vector<int> as, bs;\n    for (int k = 1; k < 8; ++k) {\n        for (int a = 1 << k; a < n; a += 1 << k + 1) {\n            for (int b = a + 1; b < min(n, a + (1 << k)); ++b) {\n                as.push_back(a);\n                bs.push_back(b);\n            }\n        }\n    }\n    int m = as.size();\n    cout << m << endl;\n    for (int i = 0; i < m; ++i) {\n        cout << as[i] + 1 << ' ' << bs[i] + 1 << endl;\n    }\n    auto query = [&](int x) -> int {\n        if (x >= n) return 0;\n        cout << x + 1 << endl;\n        string s; cin >> s;\n        if (s == \"Yes\") return -1;\n        if (s == \"Near\") return 1;\n        assert(s == \"No\");\n        return 0;\n    };\n    auto solve = [&]() -> void {\n        int l = 0, u = 256;\n        while (true) {\n            int mid = u + l >> 1;\n            int r = query(mid);\n            if (r == -1) return;\n            (r ? l : u) = mid;\n        }\n        // return l;\n    };\n    while (k--) {\n        solve();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    int N,K;\n    cin >> N >> K;\n    vector<pair<int,int>> edge;\n    vector<vector<int>> des(N+1, vector<int>());\n    for(int i=1;i<N;i++){\n        // if(2*i<=N)edge.emplace_back(i,2*i);\n        if(2*i+1<=N)edge.emplace_back(i,2*i+1);\n    }\n    for (int i = N; i >= 1;i--){\n        if(2*i<=N){\n            des[i].push_back(2 * i);\n            for(auto x:des[2*i])\n                des[i].push_back(x);\n        }\n        if (2 * i+1 <= N)\n        {\n            des[i].push_back(2*i+1);\n            for (auto x : des[2 * i+1])\n                des[i].push_back(x);\n        }\n    }\n    for (int i = 1;i<N;i++){\n        if(2*i+1<=N){\n            for(auto x:des[2*i+1]){\n                edge.emplace_back(i, x);\n            }\n        }\n    }\n    int M = edge.size();\n    cout << edge.size() << endl;\n    for (int i = 0; i < M; i++)\n    {\n        cout << edge[i].first << \" \" << edge[i].second << endl;\n    }\n    for(int i=0;i<K;i++){\n        int num = 1;\n        cout << num << endl;\n        string answer;\n        while (cin >> answer)\n        {\n            if (answer == \"Yes\")\n            {\n                break;\n            }\n            else if (answer == \"No\")\n            {\n                num = num * 2;\n                cout << num << endl;\n            }\n            else\n            {\n                num = num * 2 + 1;\n                cout << num << endl;\n            }\n        }\n    }\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "/*  -*- coding: utf-8 -*-\n *\n * 2940.cc: \n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 200;\nconst int MAX_M = MAX_N * (MAX_N - 1) / 2;\n\n/* typedef */\n\ntypedef pair<int,int> pii;\ntypedef queue<pii> qpii;\n\nenum { YES, NO, NEAR };\n\n/* global variables */\n\npii es[MAX_M];\n\n/* subroutines */\n\nint query(int a) {\n  printf(\"%d\\n\", a + 1); fflush(stdout);\n\n  char s[16];\n  scanf(\"%s\", s);\n\n  if (s[0] == 'Y') return YES;\n  if (s[1] == 'o') return NO;\n  return NEAR;\n}\n\n/* main */\n\nint main() {\n  int n, k;\n  scanf(\"%d%d\", &n, &k);\n\n  qpii q;\n  q.push(pii(0, n));\n\n  int m = 0;\n  while (! q.empty()) {\n    pii u = q.front(); q.pop();\n    int ui = u.first, uj = u.second;\n    int i0 = ui + 1, i2 = uj, i1 = (i0 + i2) / 2;\n\n    for (int i = i0; i < i1; i++) es[m++] = pii(ui, i);\n    if (i0 + 1 < i1) q.push(pii(i0, i1));\n    if (i1 + 1 < i2) q.push(pii(i1, i2));\n  }\n\n  printf(\"%d\\n\", m);\n  for (int i = 0; i < m; i++)\n    printf(\"%d %d\\n\", es[i].first + 1, es[i].second + 1);\n  fflush(stdout);\n\n  while (k--) {\n    qpii qq;\n    qq.push(pii(0, n));\n\n    while (! qq.empty()) {\n      pii u = qq.front(); qq.pop();\n      int ui = u.first, uj = u.second;\n      int i0 = ui + 1, i2 = uj, i1 = (i0 + i2) / 2;\n\n      int r = query(ui);\n      if (r == YES) break;\n\n      if (r == NEAR) qq.push(pii(i0, i1));\n      else qq.push(pii(i1, i2));\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <cassert>\n#include <vector>\n#include <algorithm>\n#include <string>\n\nstd::string query(size_t v) {\n  printf(\"%zu\\n\", v+1);\n  fflush(stdout);\n  char buf[8];\n  scanf(\"%s\", buf);\n  std::string reply = buf;\n  return reply;\n}\n\nvoid game(size_t n) {\n  if (n <= 10) {\n    for (size_t i = 0; i < n; ++i) {\n      if (query(i) == \"Yes\") return;\n    }\n    assert(false);\n  }\n\n  size_t res = 0;\n  for (size_t i = 1; i < n; i <<= 1) {\n    auto reply = query(i);\n    if (reply == \"Yes\") return;\n    if (reply == \"Near\") res |= i;\n  }\n  query(res);\n  return;\n}\n\nint main() {\n  size_t n, k;\n  scanf(\"%zu %zu\", &n, &k);\n\n  std::vector<std::pair<size_t, size_t>> es;\n  for (size_t i = 0; i < n; ++i)\n    for (size_t j = 1; j < i; j <<= 1)\n      if (i & j)\n        es.emplace_back(i, j);\n\n  printf(\"%zu\\n\", es.size());\n  for (const auto& e: es)\n    printf(\"%zu %zu\\n\", e.first+1, e.second+1);\n\n  for (size_t i = 0; i < k; ++i)\n    game(n);\n} \n\n"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <bits/stdc++.h>\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef long long LL;\ntypedef vector<LL> VL;\ntypedef vector<VL> VVL;\ntypedef vector<string> VS;\ntypedef pair<LL, LL> PLL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int MOD = 1000000007;\n\n// grid\n//--------------------------------------------\nVL dx = {0, 1, 0, -1};\nVL dy = {1, 0, -1, 0};\nVL dx2 = {-1, 0, 1, -1, 1, -1, 0, 1};\nVL dy2 = {-1, -1, -1, 0, 0, 1, 1, 1};\n\n//debug\n//--------------------------------------------\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\n//main code\nint main(int argc, char const* argv[])\n{\n\tint n,k;\n\tcin >> n >> k;\n\tVVL g(8);\n\tint edges = 0;\n\tfor (int i = 3; i <= n; i++) {\n\t\tfor (int j = 0; j < 8; j++) {\n\t\t\tif (((i >> j) & 1) == 1) {\n\t\t\t\tg[j].push_back(i);\n\t\t\t\tedges++;\n\t\t\t}\n\t\t}\n\t}\n\tcout << edges << endl;\n\tfor (int i = 0; i < 8; i++) {\n\t\tfor (int j = 0; j < g[i].size(); j++) {\n\t\t\tcout << i+1 << \" \" << g[i][j] << endl;\n\t\t}\n\t}\n\n\tfor (int j = 0; j < k; j++) {\n\t\tstring s;\n\t\tint ans = 0;\n\t\tfor (int i = 1; i <= min(8,n); i++) {\n\t\t\tcout << i << endl;\n\t\t\tcin >> s;\n\t\t\tif (s == \"Yes\") {\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tif (s == \"Near\") {\n\t\t\t\tans += (1 << (i - 1));\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t\tcin >> s;\nend:\n\t\tint tmp;\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint nth_bit(int64_t num, int n){\n    return (num >> n) & 1;\n}\n\nvoid solve(){\n    int ans = 0;\n    for(int k=0; k<=7; k++){\n        cout << k+1 << endl;\n        string res;\n        cin >> res;\n        if(res == \"Yes\") return;\n        if(res == \"Near\") ans += 1<<k;\n    }\n    cout << ans+1 << endl;\n    string res;\n    cin >> res;\n    assert(res == \"Yes\");\n}\n\nint main(){\n    int N, K;\n    cin >> N >> K;\n    vector<pair<int, int>> edges;\n    for(int i=8; i<N; i++) for(int k=0; k<=7; k++) if(nth_bit(i, k)) edges.emplace_back(i, k);\n    cout << edges.size() << endl;\n    for(auto& p : edges) cout << p.first+1 << \" \" << p.second+1 << endl;\n    while(K--) solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\n//const int MOD = 998244353;\n\nlong long int N, M, K, H, W, L, R;\n//int N, M, K, H, W, L, R\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> K;\n\tvector<vector<int>>edge(N + 1);\n\tint box = 0;\n\twhile ((1 << box) < N) {\n\t\tfor (int i = (1 << box) + 1; i <= N; i++) {\n\t\t\tif ((i >> box) & 1)edge[1 << box].push_back(i);\n\t\t}\n\t\tbox++;\n\t}\n\tvector<pair<int, int>>ret;\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (auto j : edge[i]) {\n\t\t\tret.push_back({ i,j });\n\t\t}\n\t}\n\tcout << ret.size() << endl;\n\tfor (auto i : ret) {\n\t\tcout << i.first << \" \" << i.second << endl;\n\t}\n\tfor (int i = 0; i < K; i++) {\n\t\tint box = 1;\n\t\tint ans = 0;\n\t\tbool flag = false;\n\t\twhile (box <= N) {\n\t\t\tcout << box << endl;\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tif (s == \"Yes\") {\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (s == \"Near\")ans += box;\n\t\t\tbox *= 2;\n\t\t}\n\t\tif (!flag) {\n\t\t\tcout << ans << endl;\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//----------------------------templates\n    #pragma GCC optimize (\"Ofast\")\n    #pragma GCC target (\"tune=native\")\n    #pragma GCC target (\"avx\")\n    //----------------------------\n    #include <bits/stdc++.h>\n    using namespace std;\n\n    typedef long long ll;\n    typedef unsigned long long ull;\n    #define int ll\n\n    #define FOR(i,j,n) for (int i=(int)(j);i<(n);i++)\n    #define REP(i,n) for (int i=0;i<(int)(n);i++)\n    #define REPS(i,n) for (int i=1;i<=(int)(n);i++)\n    #define REPN(i,n) for (int i=(int)(n)-1;i>=0;i--)\n    #define REPNS(i,n) for (int i=(int)(n);i>0;i--)\n\n    #define I(n) scanf(\"%lld\", &(n))\n    #define LL(n) scanf(\"%lld\", &(n))\n    #define pb(n) push_back((n))\n    #define mp(i,j) make_pair((i),(j))\n    #define eb(i,j) emplace_back((i),(j))\n    #define y0 y3487465\n    #define y1 y8687969\n    #define j0 j1347829\n    #define j1 j234892\n    #define uniq(v) v.erase( unique(v.begin(), v.end()), v.end() )\n\n    #define all(x) (x).begin(),(x).end()\n    #define sz(x) ((int)(x).size())\n\n    typedef vector<int> vi;\n    typedef pair<int,int> pi;\n    typedef vector<pi> vpi;\n    typedef vector<vi> vvi;\n    typedef vector<vpi> vvpi;\n    typedef vector<vvi> vvvi;\n\n    const int mod = 1000000007;\n\n//--------------------------------------------\n\nint n,k;\nvpi edges;\nstring resp;\n\nsigned main(){\n    I(n); I(k);\n    if (n <= 8){\n        cout << 0 << endl;\n    } else {\n        //1-8 がクエリノード、9-N が正解ノード\n        //9を引いて2進数表記\n        FOR(i,9,n+1){\n            int ni = i-8;\n            if (ni & 1) edges.eb(i,1);\n            if (ni & 2) edges.eb(i,2);\n            if (ni & 4) edges.eb(i,3);\n            if (ni & 8) edges.eb(i,4);\n            if (ni & 16) edges.eb(i,5);\n            if (ni & 32) edges.eb(i,6);\n            if (ni & 64) edges.eb(i,7);\n            if (ni & 128) edges.eb(i,8);\n        }\n        cout << sz(edges) << endl;\n        for(auto e: edges) cout << e.first << \" \" << e.second << endl;\n    }\n    while(k){\n        int ansn = 0;\n        REPS(i,8){\n            cout << i << endl;\n            cin >> resp;\n            if(resp == \"Yes\"){\n                goto LAST;\n            } else if (resp == \"Near\"){\n                ansn |= (1 << (i-1));\n            }\n        }\n        cout << ansn + 8 << endl;\n        cin >> resp;\n        LAST:\n        k--;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\nusing namespace std;\nvector<pair<int,int>> v;\nint main(){\n\tint i,j,n,k;\n\tcin >> n >> k;\n\tfor(i=0;i<10;i++){\n\t\tif((1<<i)>n) break;\n\t\tfor(j=1;j<=n;j++){\n\t\t\tif((1<<i)==j) continue;\n\t\t\tif((1<<i) & j){\n\t\t\t\tv.push_back({(1<<i),j});\n\t\t\t}\n\t\t}\n\t}\n\tcout << v.size() << endl;\n\tfor(i=0;i<v.size();i++){\n\t\tcout << v[i].first << \" \" << v[i].second << endl;\n\t}\n\twhile(k){\n\t\tk--;\n\t\tstring s;\n\t\tint res = 0;\n\t\tfor(i=0;i<10;i++){\n\t\t\tif((1<<i)>n) break;\n\t\t\tcout << (1<<i) << endl;\n\t\t\tcin >> s;\n\t\t\tif(s[0]=='Y'){\n\t\t\t\tres = -1;\n\t\t\t\tbreak;\n\t\t\t}else if(s[1]=='e'){\n\t\t\t\tres += (1<<i);\n\t\t\t}\n\t\t}\n\t\tif(res>0){\n\t\t\tcout << res << endl;\n\t\t\tcin >> s;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nint N, K;\nusing P = pair<int, int>;\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> N >> K;\n\n  if ( N <= 10 ) {\n    cout << N-1 << endl;    \n    for ( int i = 2; i <= N; i++ ) {\n      cout << i-1 << \" \" << i << endl;      \n    }\n    while ( K-- ) {\n      for ( int i = 1; i <= N; i++ ) {\n\tcout << i << endl;\n\tstring s;\n\tcin >> s;\n\tif ( s == \"Yes\" ) break;\t\n      }\n    }    \n  } else {\n    vector<P> v;    \n    for ( int i = 10; i <= N; i++ ) {\n      for ( int j = 0; j < 9; j++ ) {\n\tif ( i & (1<<j) ) v.push_back(P(i, j+1));\t\n      }      \n    }\n\n    cout << v.size() << endl;\n    for ( P p : v ) cout << p.first << \" \" << p.second << endl;\n\n    while ( K-- ) {\n      int ans = 0;\n      bool f = false;      \n      for ( int i = 0; i < 9; i++ ) {\n\tcout << i+1 << endl;\n\tstring s;\n\tcin >> s;\n\tif ( s == \"Yes\" ) {\n\t  f = true;\n\t  break;\t  \n\t} else if ( s == \"Near\" ) {\n\t  ans |= (1<<i);\t  \n\t}\n      }\n\n      if ( !f ) {\n\tcout << ans << endl;\n\tstring s;\n\tcin >> s;\n\tassert(s == \"Yes\");\t\n      }\n    }    \n  }  \n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <bits/stdc++.h>\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef long long LL;\ntypedef vector<LL> VL;\ntypedef vector<VL> VVL;\ntypedef vector<string> VS;\ntypedef pair<LL, LL> PLL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int MOD = 1000000007;\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\n//main code\n\nint main(int argc, char const* argv[])\n{\n\tint n,k;\n\tcin >> n >> k;\n\tvector<set<int>> nodes(n+1);\n\tint m = 0;\n\tfor (int i = 0; i < 8; i++) {\n\t\tfor (int j = 2+i; j <= n; j++) {\n\t\t\tif ((j & (1<<i)) > 0) {\n\t\t\t\tnodes[i+1].insert(j);\n\t\t\t\tm++;\n\t\t\t}\n\t\t}\n\t}\n\tcout << m << endl;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (auto&& j : nodes[i]) {\n\t\t\tcout << i << \" \" << j << endl;\n\t\t}\n\t}\n\tfor (int i = 0; i < k; i++) {\n\t\tint ans = 0, j = 0;\n\t\tstring s;\n\t\twhile(j < 8) {\n\t\t\tcout << j + 1 << endl;\n\t\t\tcin >> s;\n\t\t\tif (s == \"Yes\") {\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tif (s == \"Near\") {\n\t\t\t\tans += (1<<j);\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t\tcout << ans << endl;\n\t\tcin >> s;\nend:\n\t\tint tmp;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define INF (1<<28)\n#define DEKAI 1000000007\n#define lp(i,n) for(int i=0;i<n;i++)\n#define int long long\n\nvector<int> g[8];\nvector<pair<int,int> > outa;\nint vr;\nvoid makeg(int n){\n    int a[7]={128,64,32,16,8,4,2};\n    int num=1;\n    lp(i,7){\n      int x=0;\n      lp(j,num){\n        for(int k=x;k<a[i]+x;k++){\n          g[i].push_back(k+1);\n        }\n        if(i!=0)x+=a[i-1];\n      }\n      num*=2;\n    }\n  lp(i,7){\n    if(n<a[i]){\n      vr=i+1;\n      continue;\n    }\n    lp(j,g[i].size()){\n      if(g[i][j]>n) break;\n      outa.push_back(make_pair(i+1,g[i][j]));\n    }\n  }\n    return;\n}\n\nvoid outp(int n){\n  if(n<=10){\n    cout<<0<<endl;\n    return;\n  } \n  cout<<outa.size()<<endl;\n  lp(i,outa.size()){\n    cout<<outa[i].first<<\" \"<<outa[i].second<<endl;\n  }\n\n  //if(outa.size()>n*(n-1)/2)cout<<\"error!\"<<endl;\n}\n\nsigned main(){\n  int n,k;\n  cin>>n>>k;\n  makeg(n);\n  /*lp(i,7) cout<<g[i].size()<<endl;\n  return 0;*/\n  outp(n);\n  lp(zzz,k){\n    if(n<=10){\n      lp(i,11){\n        if(i==0) continue;\n        cout<<i<<endl;\n        string s;\n        cin>>s;\n        if(s==\"Yes\") break;\n      }\n      continue;\n    }\n    int ans=1;\n    int add=128;\n    int st=0;\n    lp(i,8){\n      if(i==0) continue;\n      cout<<i<<endl;\n      string s;\n      cin>>s;\n      if(s==\"Yes\"){\n        st=1;\n        break;\n      }\n      if(s==\"No\"&&vr<i){\n        ans+=add;\n      }\n      add/=2;\n    }\n    if(st==1) continue;\n    while(1){\n      cout<<ans<<endl;\n      string s;\n      cin>>s;\n      if(s==\"Yes\") break;\n      else ans++;\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define fst(t) std::get<0>(t)\n#define snd(t) std::get<1>(t)\n#define thd(t) std::get<2>(t)\n#define unless(p) if(!(p))\n#define until(p) while(!(p))\n\nusing ll = std::int64_t;\nusing P = std::tuple<int,int>;\n\nint N, K;\nint M;\nstd::vector<int> G[210];\n\nstd::string ask(int v){\n    std::cout << v << std::endl;\n\n    std::string res;\n    std::cin >> res;\n\n    return res;\n}\n\nvoid gen(int s, int n){\n    if(n <= 1){\n        return;\n    }\n\n    int n1 = n / 2, n2 = n - n1;\n    for(int i=1;i<n1;++i){\n        M += 1;\n        G[s].emplace_back(s + i);\n    }\n\n    gen(s + 1, n1 - 1);\n    gen(s + n1, n2);\n}\n\nvoid solve(int s, int n){\n    if(n == 1){\n        ask(s);\n        return;\n    }\n\n    int n1 = n / 2, n2 = n - n1;\n    std::string res = ask(s);\n    \n    if(res == \"Yes\"){\n        return;\n    }else if(res == \"Near\"){\n        solve(s + 1, n1 - 1);\n    }else{\n        solve(s + n1, n2);\n    }\n}\n\nint main(){\n    std::cin.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    std::cin >> N >> K;\n\n    gen(1, N);\n\n    std::cout << M << std::endl;\n\n    for(int i=1;i<=N;++i){\n        for(int j : G[i]){\n            std::cout << i << \" \" << j << std::endl;\n        }\n    }\n\n    for(int t=0;t<K;++t){\n        solve(1, N);   \n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Edge{\n\tEdge(int arg_from,int arg_to){\n\t\tfrom = arg_from;\n\t\tto = arg_to;\n\t}\n\tint from,to;\n};\n\n\nint main(){\n\n\tint N,K;\n\n\tcin >> N >> K;\n\n\tint M = 0;\n\tvector<Edge> G;\n\n\tfor(int base = 1; base <= N; base*=2){\n\n\t\tfor(int adj = base+1; adj <= N; adj++){\n\t\t\tif((base&adj)){\n\t\t\t\tG.push_back(Edge(base,adj));\n\t\t\t\tM++;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << M << endl;\n\n\tfor(int i = 0; i < G.size(); i++){\n\n\t\tcout << G[i].from << \" \" << G[i].to << endl;\n\t}\n\n\tint sum;\n\tstring buf;\n\tbool FLG;\n\n\tfor(int loop = 0; loop < K; loop++){\n\n\t\tsum = 0;\n\t\tFLG = false;\n\n\t\tfor(int base = 1; base <= N; base*=2){\n\n\t\t\tcout << base << endl;\n\n\t\t\tcin >> buf;\n\t\t\tif(buf[0] == 'Y'){\n\t\t\t\tFLG = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(buf[0] == 'N' && buf[1] == 'e')sum += base;\n\t\t}\n\t\tif(FLG)continue;\n\n\t\tcout << sum << endl;\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int, int>;\n\nenum {\n    No,\n    Near,\n    Yes\n};\n\nint query(int n) {\n    cout << n << endl;\n    string r; cin >> r;\n    if(r == \"Yes\") return Yes;\n    else if(r == \"No\") return No;\n    return Near;\n}\n\nint main() {\n    int n, k; cin >> n >> k;\n\n    vector<pii> es;\n    function<void(int, int)> create = [&] (int i, int w) {\n        if(i >= n || w <= 1) return;\n        for(int j = i + 1; j < min(i + w, n); ++j) {\n            es.emplace_back(i + 1, j + 1);\n        }\n        int tw = w / 2;\n        int ii = i + 1;\n        while(tw >= 2) {\n            create(ii, tw);\n            ii += tw;\n            tw = (tw + 1) / 2;\n        }\n    };\n    create(0, n);\n    cout << es.size() << endl;\n    for(auto const& p : es) {\n        cout << p.first << \" \" << p.second << endl;\n    }\n\n    while(k--) {\n        function<int(int, int)> solve = [&] (int i, int w) {\n            auto r = query(i + 1);\n            if(r == Yes) return Yes;\n            if(r == No) return No;\n            int ii = i + 1, tw = w / 2;\n            while(tw >= 1) {\n                r = solve(ii, tw);\n                if(r == Yes) return Yes;\n                ii += tw;\n                tw = (tw + 1) / 2;\n            }\n            assert(false);\n        };\n        solve(0, n);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int n, k; cin >> n >> k;\n    vector<int> as, bs;\n    for (int k = 1; k < 8; ++k) {\n        for (int a = 1 << k; a < n; a += 1 << k + 1) {\n            for (int b = a + 1; b < min(n, a + (1 << k)); ++b) {\n                as.push_back(a);\n                bs.push_back(b);\n            }\n        }\n    }\n    int m = as.size();\n    cout << m << endl;\n    for (int i = 0; i < m; ++i) {\n        cout << as[i] + 1 << ' ' << bs[i] + 1 << endl;\n    }\n    auto query = [&](int x) -> int {\n        if (x >= n) return 0;\n        cout << x + 1 << endl;\n        string s; cin >> s;\n        if (s == \"Yes\") return -1;\n        if (s == \"Near\") return 1;\n        return 0;\n    };\n    auto solve = [&]() -> void {\n        int l = 0, u = 256;\n        while (true) {\n            int mid = u + l >> 1;\n            int r = query(mid);\n            if (r == -1) return;\n            (r ? l : u) = mid;\n        }\n    };\n    while (k--) {\n        solve();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace  std;\n \ntypedef pair<int,int>P;\n#define fi first\n#define se second\n \n \nint n,k ;\n \nvector<P>A;\n \nvoid dfs(vector<int> v,int now){\n  r(i,v.size()){\n    A.push_back(P(v[i],now));\n  }\n  if(now*2+1<n){\n    vector<int>nex=v;\n    nex.push_back(now);\n    dfs(nex,now*2+1);\n  }\n  if(now*2+2<n){\n    vector<int>nex=v;\n    nex.push_back(now);\n    dfs(nex,now*2+2);\n  }\n}\n \n//int x=0;\n \nstring output(int num){\n \n  //cerr<<\"aaa:\"<<num<<endl;\n  //if(x++==10)exit(0);\n \n  cout<<num<<endl;\n \n  string s;\n/*\n  const int atari = 3;\n \n  if(atari == num)return \"Yes\";\n \n  r(i,A.size()){\n    if(A[i].fi==num-1 && A[i].se+1 == atari)return \"Near\";\n    if(A[i].se==num-1 && A[i].fi+1 == atari)return \"Near\";\n  }\n  return \"No\";\n*/\n  cin>>s;\n  return s;\n}\n \nint main(){\n \n  cin>>n>>k;\n \n  vector<int>init;\n \n  dfs(init,0);\n \n  cout<<A.size()<<'\\n';\n \n  r(i,A.size()){\n    cout<<A[i].fi+1<<' '<<A[i].se+1;\n    if(i!=(int)A.size())cout<<'\\n';\n    else cout<<endl;\n  }\n \n  while(k--){\n \n    int idx=0,p=0,F=-1,S=0;\n \n    while(1){\n \n      if(!p){\n        string s=output(idx+1);\n        if(s==\"Yes\"){\n          S++;\n          break;\n        }\n        p++;\n      }\n \n      int nex=idx*2+1;\n \n      if(nex>=n)break;\n \n      string s=output(nex+1);\n \n      if(s==\"No\"){\n        F=nex+1;\n        idx=idx*2+2;\n      }\n \n      else if(s==\"Yes\"){\n        S++;\n        break;\n      }\n \n      else{\n        idx=idx*2+1;\n      }\n      if(idx>=n)break;\n    }\n \n    if(!S){\n \n      //cout<<F<<endl;\n \n      if(F+1<=n){\n        string s=output(F+1);\n        //cout<<s<<endl;\n        if(s==\"Yes\")continue;\n      }\n \n      if(F-1>=1){\n        string s=output(F-1);\n        if(s==\"Yes\")continue;\n      }\n      //cout<<\"ERROR\"<<endl;\n      //exit(1);\n    }\n \n  }\n \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing ull=unsigned long long;\nusing uint=unsigned int;\nusing pcc=pair<char,char>;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing pdd=pair<double,double>;\nusing tuplis=pair<ll,pll>;\nusing tuplis2=pair<pll,ll>;\ntemplate<class T> using pq=priority_queue<T,vector<T>,greater<T>>;\nconst ll LINF=0x1fffffffffffffff;\nconst ll MOD=1000000007;\nconst ll MODD=998244353;\nconst int INF=0x3fffffff;\nconst double DINF=numeric_limits<double>::infinity();\nconst vector<pii> four={{-1,0},{0,1},{1,0},{0,-1}};\n#define _overload4(_1,_2,_3,_4,name,...) name\n#define _overload3(_1,_2,_3,name,...) name\n#define _rep1(n) for(ll i=0;i<n;++i)\n#define _rep2(i,n) for(ll i=0;i<n;++i)\n#define _rep3(i,a,b) for(ll i=a;i<b;++i)\n#define _rep4(i,a,b,c) for(ll i=a;i<b;i+=c)\n#define rep(...) _overload4(__VA_ARGS__,_rep4,_rep3,_rep2,_rep1)(__VA_ARGS__)\n#define _rrep1(n) for(ll i=n-1;i>=0;i--)\n#define _rrep2(i,n) for(ll i=n-1;i>=0;i--)\n#define _rrep3(i,a,b) for(ll i=b-1;i>=a;i--)\n#define _rrep4(i,a,b,c) for(ll i=a+(b-a-1)/c*c;i>=a;i-=c)\n#define rrep(...) _overload4(__VA_ARGS__,_rrep4,_rrep3,_rrep2,_rrep1)(__VA_ARGS__)\n#define each(i,a) for(auto& i:a)\n#define sum(...) accumulate(range(__VA_ARGS__),0LL)\n#define dsum(...) accumulate(range(__VA_ARGS__),double(0))\n#define _range(i) (i).begin(),(i).end()\n#define _range2(i,k) (i).begin(),(i).begin()+k\n#define _range3(i,a,b) (i).begin()+a,(i).begin()+b\n#define range(...) _overload3(__VA_ARGS__,_range3,_range2,_range)(__VA_ARGS__)\n#define _rrange(i) (i).rbegin(),(i).rend()\n#define _rrange2(i,k) (i).rbegin(),(i).rbegin()+k\n#define _rrange3(i,a,b) (i).rbegin()+a,(i).rbegin()+b\n#define rrange(...) _overload3(__VA_ARGS__,_rrange3,_rrange2,_rrange)(__VA_ARGS__)\n#define yes(i) out(i?\"yes\":\"no\")\n#define Yes(i) out(i?\"Yes\":\"No\")\n#define YES(i) out(i?\"YES\":\"NO\")\n#define Possible(i) out(i?\"Possible\":\"Impossible\")\n#define elif else if\n#define unless(a) if(!(a))\n#define mp make_pair\n#define mt make_tuple\n#define INT(...) int __VA_ARGS__;in(__VA_ARGS__)\n#define LL(...) ll __VA_ARGS__;in(__VA_ARGS__)\n#define STR(...) string __VA_ARGS__;in(__VA_ARGS__)\n#define CHR(...) char __VA_ARGS__;in(__VA_ARGS__)\n#define DBL(...) double __VA_ARGS__;in(__VA_ARGS__)\n#define vec(type,name,...) vector<type> name(__VA_ARGS__)\n#define VEC(type,name,size) vector<type> name(size);in(name)\n#define vv(type,name,h,...) vector<vector<type>>name(h,vector<type>(__VA_ARGS__))\n#define VV(type,name,h,...) vector<vector<type>>name(h,vector<type>(__VA_ARGS__));in(name)\n#define vvv(type,name,h,w,...) vector<vector<vector<type>>>name(h,vector<vector<type>>(w,vector<type>(__VA_ARGS__)))\n__attribute__((constructor)) void SETTINGS(){cin.tie(0); cout.tie(0); ios::sync_with_stdio(0); cout<<fixed<<setprecision(20);};\ninline constexpr ll gcd(ll a,ll b){if(!a||!b)return 0;if(a<b){ll c=a;a=b;b=c;}while(b){ll c=b;b=a%b;a=c;}return a;}\ninline constexpr ll lcm(ll a,ll b){if(!a||!b)return 0;return a*b/gcd(a,b);}\ntemplate<class T>inline constexpr T min(vector<T>& v){return *min_element(range(v));}\ninline char min(string& v){return *min_element(range(v));}\ntemplate<class T>inline constexpr T max(vector<T>& v){return *max_element(range(v));}\ninline char max(string& v){return *max_element(range(v));}\ninline constexpr ll intpow(ll a,ll b){if(b==0)return 1;ll ans=intpow(a,b/2);return ans*ans*(b&1?a:1);}\ninline constexpr ll modpow(ll a,ll b,ll mod=MOD){if(b==0)return 1;ll ans=modpow(a,b/2);return ans*ans*(b&1?a:1)%mod;}\ntemplate<typename T>\ninline constexpr bool update_min(T& mn,const T& cnt){if(mn>cnt){mn=cnt;return 1;}else return 0;}\ntemplate<typename T>\ninline constexpr bool update_max(T& mx,const T& cnt){if(mx<cnt){mx=cnt;return 1;}else return 0;}\ninline void in() {}\ntemplate<class T>\nistream& operator >> (istream& is, vector<T>& vec);\ntemplate<class T,size_t size>\nistream& operator >> (istream& is, array<T,size>& vec);\ntemplate<class T,class L>\nistream& operator >> (istream& is, pair<T,L>& p);\ntemplate<class T>\nostream& operator << (ostream& os, vector<T>& vec);\ntemplate<class T,class L>\nostream& operator << (ostream& os, pair<T,L>& p);\ntemplate<class T>\nistream& operator >> (istream& is, vector<T>& vec){for(T& x: vec) is >> x;return is;}\ntemplate<class T,class L>\nistream& operator >> (istream& is, pair<T,L>& p){is >> p.first;is >> p.second;return is;}\ntemplate<class T>\nostream& operator << (ostream& os, vector<T>& vec){os << vec[0];rep(i,1,vec.size()){os << ' ' << vec[i];}return os;}\ntemplate<class T>\nostream& operator << (ostream& os, deque<T>& deq){os << deq[0];rep(i,1,deq.size()){os << ' ' << deq[i];}return os;}\ntemplate<class T,class L>\nostream& operator << (ostream& os, pair<T,L>& p){os << p.first << \" \" << p.second;return os;}\ntemplate<class T,class L>\npair<T,L> operator + (pair<T,L> a, pair<T,L> b){return {a.first + b.first, a.second + b.second};}\ntemplate <class Head, class... Tail>\ninline void in(Head&& head,Tail&&... tail){cin>>head;in(move(tail)...);}\ntemplate <class T>\ninline bool out(T t){cout<<t<<endl;return 0;}\ninline bool out(){cout<<'\\n';return 0;}\ntemplate <class Head, class... Tail>\ninline bool out(Head head,Tail... tail){cout<<head<<' ';out(move(tail)...);return 0;}\ntemplate <class T>\ninline void err(T t){cerr<<t<<'\\n';}\ninline void err(){cerr<<'\\n';}\ntemplate <class Head, class... Tail>\ninline void err(Head head,Tail... tail){cerr<<head<<' ';out(move(tail)...);}\n\n\n\n\nvector<unordered_set<ll>>g;\nvector<ll>near,no;\nvoid make_graph(ll a,ll b){\n    if(a>=b)return;\n    ll cen=(a+b+1)/2;\n    rep(i,a+1,cen){\n        g[a].insert(i);\n        g[i].insert(a);\n    }\n    near[a]=a+1;\n    make_graph(a+1,cen);\n    no[a]=cen;\n    make_graph(cen,b);\n}\nsigned main(){\n    LL(n,k);\n    g.resize(n+1);\n    near.resize(n+1);\n    no.resize(n+1);\n    make_graph(1,n+1);\n    ll m=0;\n    each(i,g)m+=i.size();\n    m/=2;\n    out(m);\n    rep(n+1)each(j,g[i])if(i<j)out(i,j);\n    rep(k){\n        ll a=1;\n        string s;\n        while(true){\n            out(a);\n            STR(s);\n            if(s==\"Yes\")break;\n            elif(s==\"Near\")a=near[a];\n            else a=no[a];\n        }\n    }\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n#define endl \"\\n\"\n#define rep(i, a, b) for (auto (i) = (a); (i) < (b); (i)++)\n#define rrep(i, a, b) for (auto (i) = (a); (i) > (b); (i)--)\n#define UNIQUE(v) (v).erase(unique((v).begin(), (v).end()), (v).end());\n\n#ifdef LOCAL_DEFINE\nstruct InitInput{\n  InitInput() {\n    FILE *stream1;\n    stream1=freopen(\"/Users/aim_cpo/CLionProjects/competitive/in.txt\",\"r\",stdin);\n    assert(stream1 != nullptr);\n    cerr << \"This problem is not interactive\" << endl;\n  }\n}/*LOCAL_INPUT*/;\nstruct LOCAL_OUTPUT{\n  LOCAL_OUTPUT() {\n    FILE *stream2;\n    const char *outputfile = \"out.txt\";\n    stream2 = freopen(outputfile, \"w\", stdout);\n    assert(stream2 != nullptr);\n    cerr << \"output [ \" << outputfile << \" ]\" << endl;\n  }\n}/*LOCAL_OUTPUT*/;\n#define show(x) cerr << #x << \" = \" << (x) << \" (line \" << __LINE__ << \")\" << endl\n#define showV(v, n) do{\\\nfor(int _i_t_e_=0; _i_t_e_<(n);_i_t_e_++)\\\ncerr<<\"(\"<<_i_t_e_<<\" = \"<<(v)[_i_t_e_]<<\") \";\\\ncerr<<endl;}while(0)\n#define showA(a, n) do{\\\nfor(int _i_t_e_=0;_i_t_e_<(n);_i_t_e_++)\\\ncerr<<\"(\"<<_i_t_e_<<\" = \"<<(a)[_i_t_e_]<<\") \";\\\ncerr<<endl;}while(0)\n#define showA2(a, n, m) do{\\\nfor(int _i_t_e_=0;_i_t_e_<(n);_i_t_e_++){\\\nfor(int _i_t_e_2=0;_i_t_e_2<(m);_i_t_e_2++){\\\ncerr<<\"(\"<<_i_t_e_<<\", \"<<_i_t_e_2<<\" = \"<<(a)[_i_t_e_][_i_t_e_2]<<\") \";\\\n}cerr<<endl;}cerr<<endl;}while(0)\n#else\n#define show(x)\n#define showV(v, n)\n#define showA(a, n)\n#define showA2(a, n, m)\n#endif\n\nstruct InitAim {\n  InitAim() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.precision(12);\n    cout << fixed;\n#ifdef LOCAL_DEFINE\n    cerr << \"This problem is not interactive\" << endl;\n#endif\n  }\n}/*aim_cpo*/;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nconstexpr const int INT_INF = 0x3f3f3f3f; //1061109567\nconstexpr const ll LL_INF = 0x3f3f3f3f3f3f3f3f; //4557430888798830399\n\ntemplate< typename T >\nbool chmin(T &a, T b) { return a > b ? (a = b, true) : false; }\n\ntemplate< typename T >\nbool chmax(T &a, T b) { return a < b ? (a = b, true) : false; }\n\ntemplate< typename T >\nvoid ln(T i, T n) { cout << (i == n - 1 ? \"\\n\" : \" \"); }\n\ntemplate< typename T, typename S >\nostream &operator<<(ostream &out, const pair< T, S > &pair1) {\n  out << '(' << pair1.fi << \", \" << pair1.se << ')';\n  return out;\n}\n\ntemplate< typename T >\nostream &operator<<(ostream &out, const vector< T > &vector1) {\n  out << '[';\n  for(unsigned int i = 0; i < vector1.size(); i++) {\n    out << vector1[i];\n    if(i == vector1.size() - 1)out << \"]\"; else out << \", \";\n  }\n  return out;\n}\n\n// INT\n#define GCD(a, b) __gcd(a, b)\n\ntemplate< typename T >\nT LCM(T a, T b) { return a / GCD(a, b) * b; }\n\ntemplate< typename T >\nT EXTGCD(T a, T b, T &x, T &y) {\n  T d = a;\n  if(b != 0) {\n    d = EXTGCD(b, a % b, y, x);\n    y -= (a / b) * x;\n  } else x = 1, y = 0;\n  return d;\n}\n\ntemplate< typename T >\nbool is_prime(T a) {\n  for(int i = 2; i * i <= a; i++)if(a % i == 0)return true;\n  return false;\n}\n\ntemplate< typename T, typename S >\nT Pow(T a, S b) {\n  T res = 1, now = a;\n  while(b) {\n    if(b & 1)res *= now;\n    b >>= 1;\n    now *= now;\n  }\n  return res;\n}\n\n// MOD\nll MOD = 1000000000L + 7L;\n#define add(a, b) ((a % MOD) + (b % MOD)) % MOD\n#define mul(a, b) ((a % MOD) * (b % MOD)) % MOD\n#define sub(a, b) ((a % MOD) + MOD - (b % MOD)) % MOD\n\ntemplate< typename T, typename S >\nT ModPow(T a, S b) {\n  T res = 1, now = a;\n  while(b) {\n    if(b & 1)res = mul(res, now);\n    b >>= 1;\n    now = mul(now, now);\n  }\n  return res;\n}\n\ntemplate< typename T >\nT mod_inverse(T a, T mod, bool prime) { // if mod is prime, \"prime\" is true.\n  if(prime)return ModPow(a, mod - 2);\n  else {\n    T x, y;\n    EXTGCD(a, mod, x, y);\n    return (mod + x % mod) % mod;\n  }\n}\n\n#define divide(a, b) ((a % MOD) * (mod_inverse(b, MOD, true))) % MOD\n\n//LLの数値をつかう時は最後にLLをつける癖をつけよう\n///////////////////////////////////////////////////////////////////////////////////\n// VARIABLE\n///////////////////////////////////////////////////////////////////////////////////\n\nint n, k;\nvector< int > v[201];\nint edgesize = 0;\n\n///////////////////////////////////////////////////////////////////////////////////\n// TEMPLATE(data structure)\n///////////////////////////////////////////////////////////////////////////////////\n\n\n\n///////////////////////////////////////////////////////////////////////////////////\n// MAIN\n///////////////////////////////////////////////////////////////////////////////////\n\nvoid AddEdge(int now, int left, int right) {\n  show(now + 1);\n  show(left + 1);\n  show(right + 1);\n  int mid = (left + right + 1) / 2;\n  for(int i = mid; i <= right; i++) {\n    v[now].push_back(i);\n    edgesize++;\n    //cout << now + 1 << \" \" << i + 1 << endl;\n  }\n  if(now + 1 < n && now < left) AddEdge(now + 1, left + 1, mid - 1);\n  if(mid + 1 <= right) AddEdge(mid, mid + 1, right);\n}\n\nint Ask(int num) {\n  cout << num + 1 << endl;\n  string s;\n  cin >> s;\n  if(s == \"Yes\") return 1;\n  else if(s == \"Near\") return 0;\n  else return -1;\n}\n\nvoid question(int now, int left, int right) {\n  int mid = (left + right + 1) / 2;\n  int tmp = Ask(now);\n  if(tmp == 1) {\n    return;\n  } else if(tmp == 0) {\n    question(mid, mid + 1, right);\n  } else {\n    question(now + 1, left + 1, mid - 1);\n  }\n}\n\nint main() {\n  cin >> n >> k;\n  AddEdge(0, 1, n - 1);\n  cout << edgesize << endl;\n  for(int i = 0; i < n; i++) {\n    for(int j = 0; j < (int) v[i].size(); j++) {\n      cout << i + 1 << \" \" << v[i][j] + 1 << endl;\n    }\n  }\n  rep(i, 0, k) {\n    question(0, 1, n - 1);\n  }\n#ifdef LOCAL_DEFINE\n  cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \"s.\" << endl;\n  show(MOD);\n#endif\n  return 0;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// NOTE\n///////////////////////////////////////////////////////////////////////////////////\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\n// mod\nconst ll MOD = 1000000007ll;\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n// floating\ntypedef double Real;\nconst Real EPS = 1e-11;\n#define EQ0(x) (abs(x)<EPS)\n#define EQ(a,b) (abs(a-b)<EPS)\ntypedef complex<Real> P;\n\nint n,k;\nbool g[252][252];\n\nint main(){\n  scanf(\"%d%d\",&n,&k);\n  REP(b,9){\n    int s = 1<<b;\n    REP(i,n)if(i!=s && (i&s)){\n      g[min(i,s)][max(i,s)] = true;\n    }\n  }\n  int m = 0;\n  REP(i,n)REP(j,n)if(g[i][j])m++;\n  printf(\"%d\\n\",m);\n  REP(i,n)REP(j,n)if(g[i][j])printf(\"%d %d\\n\",i+1,j+1);\n  fflush(stdout);\n\n  REP(_,k){\n    int ans = 0;\n    REP(b,9){\n      int s = 1<<b;\n      if(s>=n)break;\n      printf(\"%d\\n\",s+1);fflush(stdout);\n      char buf[10];\n      scanf(\"%s\",buf);\n      if(buf[0]=='Y'){\n        ans = -1; break;\n      }else if(buf[1]=='e'){\n        ans ^= s;\n      }\n    }\n    if(ans != -1){\n      printf(\"%d\\n\",ans+1);fflush(stdout);\n      char buf[10];\n      scanf(\"%s\",buf);\n      assert(buf[0]=='Y');\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// vvvvvvvvvvvv TEMPLATE vvvvvvvvvvvv\n#include <bits/stdc++.h>\nusing namespace std; using ll = long long; using P = pair<ll, ll>;\nconst ll linf = 1e18; const double eps = 1e-12, pi = acos(-1);\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define each(i,a) for (auto&& i : a)\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define eb emplace_back\n#define all(a) begin(a),end(a)\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\ntemplate<typename T> ll min(ll a, const T&& b) { return a < b ? a : b; }\ntemplate<typename T> ll min(const T&& a, ll b) { return a < b ? a : b; }\ntemplate<typename T> ll max(ll a, const T&& b) { return a > b ? a : b; }\ntemplate<typename T> ll max(const T&& a, ll b) { return a > b ? a : b; }\ntemplate<typename Head> void out(Head h) { cout << h << endl; } template<typename Head, typename... Tail>void out(Head h, Tail... t) { cout << h << \" \"; out(t...); }\ntemplate<typename T> istream& operator>>(istream& is, vector<T>& v) { each(x,v) is >> x; return is; }\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) { rep(i,v.size()) { if (i) os << \" \"; os << v[i]; } return os; }\nostream& operator<<(ostream& os, const vector<string>& v) { rep(i,v.size()) { if (i) os << endl; os << v[i]; } return os; }\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<vector<T>>& v) { rep(i,v.size()) { if (i) os << endl; os << v[i]; } return os; }\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& os, const pair<T1, T2>& p) { return os << \"(\" << p.first << \", \" << p.second << \")\"; }\nstruct yes_no : std::numpunct<char> { string_type do_truename() const { return \"Yes\"; } string_type do_falsename() const { return \"No\"; } };\nvoid solve(); int main() {\n  solve();\n}\n// ^^^^^^^^^^^^ TEMPLATE ^^^^^^^^^^^^\n\nvoid solve() {\n  ll n, K; cin >> n >> K;\n  vector<P> edges;\n  rep(i, 1, n+1) {\n    ll k = i & -i;\n    ll v = i;\n    while (k <= v) {\n      if (v & k) {\n        v ^= k;\n        if (v > 0) {\n          edges.eb(v, i);\n        }\n      }\n      k <<= 1;\n    }\n  }\n  cout << edges.size() << endl;\n  each(e, edges) {\n    cout << e.first << \" \" << e.second << endl;\n  }\n  rep(t, K) {\n    ll v = 0;\n    rrep(i, 10) {\n      string result;\n      ll nv = v | (1LL<<i);\n      if (nv <= n) {\n        cout << nv << endl;\n        cin >> result;\n      }\n      else {\n        result = \"No\";\n      }\n      if (result == \"No\") {\n        continue;\n      }\n      else if (result == \"Near\") {\n        v = nv;\n      }\n      else {\n        break;\n      }\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstdio>\nusing namespace std;\nint n,K;\nvector<int>G[22222];\nvector<pair<int,int> >E;\nmain()\n{\n\tscanf(\"%d%d\",&n,&K);\n\tint cnt=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint now=i;\n\t\twhile((now-1)/2>=1)\n\t\t{\n\t\t\tG[i].push_back((now-1)/2);\n\t\t\tG[(now-1)/2].push_back(i);\n\t\t\tE.push_back(make_pair((now-1)/2,i));\n\t\t\tnow=(now-1)/2;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",(int)E.size());\n\tfor(int i=0;i<E.size();i++)printf(\"%d %d\\n\",E[i].first,E[i].second);\n\tfflush(stdout);\n\tfor(;K--;)\n\t{\n\t\tint nowp=1;\n\t\tvector<bool>ok(n*4,true);\n\t\tbool flag=0;\n\t\twhile(nowp<=n)\n\t\t{\n\t\t\tprintf(\"%d\\n\",nowp);\n\t\t\tfflush(stdout);\n\t\t\tstring in;\n\t\t\tcin>>in;\n\t\t\tif(in==\"Yes\")\n\t\t\t{\n\t\t\t\tflag=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if(in==\"Near\")\n\t\t\t{\n\t\t\t\tok[nowp-1]=false;\n\t\t\t\tvector<bool>ok2(n,false);\n\t\t\t\tfor(int j=0;j<G[nowp].size();j++)ok2[G[nowp][j]-1]=true;\n\t\t\t\tfor(int j=0;j<n;j++)ok[j]=ok[j]&&ok2[j];\n\t\t\t\tnowp=nowp*2+1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tok[nowp-1]=false;\n\t\t\t\tfor(int j=0;j<G[nowp].size();j++)\n\t\t\t\t{\n\t\t\t\t\tok[G[nowp][j]-1]=false;\n\t\t\t\t}\n\t\t\t\tnowp=(nowp+1)*2+1;\n\t\t\t}\n\t\t}\n\t\tif(!flag)\n\t\t{\n\t\t\tint id=0;\n\t\t\twhile(1)\n\t\t\t{\n\t\t\t\twhile(id<n&&!ok[id])id++;\n\t\t\t\tprintf(\"%d\\n\",id+1);\n\t\t\t\tfflush(stdout);\n\t\t\t\tstring in;\n\t\t\t\tcin>>in;\n\t\t\t\tif(in==\"Yes\")\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tok[id]=false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#ifdef LOCAL\n    #define _GLIBCXX_DEBUG\n    #define __clock__\n#else\n    #pragma GCC optimize(\"Ofast\")\n    // #define NDEBUG\n#endif\n#define __precision__ 10\n#define iostream_untie true\n#define debug_stream std::cerr\n\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n\n#define all(v) std::begin(v), std::end(v)\n#define rall(v) std::rbegin(v), std::rend(v)\n#define odd(n) ((n) & 1)\n#define even(n) (not __odd(n))\n#define __popcount(n) __builtin_popcountll(n)\n#define __clz32(n) __builtin_clz(n)\n#define __clz64(n) __builtin_clzll(n)\n#define __ctz32(n) __builtin_ctz(n)\n#define __ctz64(n) __builtin_ctzll(n)\n\nusing i32 = int_least32_t; using i64 = int_least64_t; using u32 = uint_least32_t; using u64 = uint_least64_t;\nusing pii = std::pair<i32, i32>; using pll = std::pair<i64, i64>;\ntemplate <class T> using heap = std::priority_queue<T>;\ntemplate <class T> using rheap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\ntemplate <class K, class T> using hashmap = std::unordered_map<K, T>;\ntemplate <class T> using hashset = std::unordered_set<T>;\n\nnamespace execution\n{\n    using namespace std::chrono;\n    system_clock::time_point start_time, end_time;\n    long long get_elapsed_time() { end_time = system_clock::now(); return duration_cast<milliseconds>(end_time - start_time).count(); }\n    void print_elapsed_time() { std::cerr << \"\\n----- Exec time : \" << get_elapsed_time() << \" ms -----\\n\\n\"; }\n    struct setupper\n    {\n        setupper()\n        {\n            if(iostream_untie) std::ios::sync_with_stdio(false), std::cin.tie(nullptr);\n            std::cout << std::fixed << std::setprecision(__precision__);\n    #ifdef stderr_path\n            if(freopen(stderr_path, \"a\", stderr))\n            {\n                std::cerr << std::fixed << std::setprecision(__precision__);\n            }\n    #endif\n    #ifdef stdout_path\n            if(not freopen(stdout_path, \"w\", stdout))\n            {\n                freopen(\"CON\", \"w\", stdout);\n                std::cerr << \"Failed to open the stdout file\\n\\n\";\n            }\n            std::cout << \"\";\n    #endif\n    #ifdef stdin_path\n            if(not freopen(stdin_path, \"r\", stdin))\n            {\n                freopen(\"CON\", \"r\", stdin);\n                std::cerr << \"Failed to open the stdin file\\n\\n\";\n            }\n    #endif\n    #ifdef LOCAL\n            std::cerr << \"----- stderr at LOCAL -----\\n\\n\";\n            atexit(print_elapsed_time);\n    #else\n            fclose(stderr);\n    #endif\n    #ifdef __clock__\n            start_time = system_clock::now();\n    #endif\n        }\n    } __setupper;\n    class myclock_t\n    {\n        system_clock::time_point built_pt, last_pt; int built_ln, last_ln;\n        std::string built_func, last_func; bool is_built;\n    public:\n        myclock_t() : is_built(false) {}\n        void build(int crt_ln, const std::string &crt_func)\n        {\n            is_built = true, last_pt = built_pt = system_clock::now(),  last_ln = built_ln = crt_ln, last_func = built_func = crt_func;\n        }\n        void set(int crt_ln, const std::string &crt_func)\n        {\n            if(is_built) last_pt = system_clock::now(), last_ln = crt_ln, last_func = crt_func;\n            else debug_stream << \"[ \" << crt_ln << \" : \" << crt_func << \" ] \" << \"myclock_t::set failed (yet to be built!)\\n\";\n        }\n        void get(int crt_ln, const std::string &crt_func)\n        {\n            if(is_built)\n            {\n                system_clock::time_point crt_pt(system_clock::now());\n                long long diff = duration_cast<milliseconds>(crt_pt - last_pt).count();\n                debug_stream << diff << \" ms elapsed from\" << \" [ \" << last_ln << \" : \" << last_func << \" ]\";\n                if(last_ln == built_ln) debug_stream << \" (when built)\";\n                debug_stream << \" to\" << \" [ \" << crt_ln << \" : \" << crt_func << \" ]\" << \"\\n\";\n                last_pt = built_pt, last_ln = built_ln, last_func = built_func;\n            }\n            else\n            {\n                debug_stream << \"[ \" << crt_ln << \" : \" << crt_func << \" ] \" << \"myclock_t::get failed (yet to be built!)\\n\";\n            }\n        }\n    };\n} // namespace execution\n\n#ifdef __clock__\n    execution::myclock_t __myclock;\n    #define build_clock() __myclock.build(__LINE__, __func__)\n    #define set_clock() __myclock.set(__LINE__, __func__)\n    #define get_clock() __myclock.get(__LINE__, __func__)\n#else\n    #define build_clock() ((void)0)\n    #define set_clock() ((void)0)\n    #define get_clock() ((void)0)\n#endif\n\nnamespace std\n{\n    template <class P> void rsort(P __first, P __last) { sort(__first, __last, greater<>()); }\n    template <class T> size_t hash_combine(size_t seed, T const &key) { return seed ^ (hash<T>()(key) + 0x9e3779b9 + (seed << 6) + (seed >> 2)); }\n    template <class T, class U> struct hash<pair<T, U>> { size_t operator()(pair<T, U> const &pr) const { return hash_combine(hash_combine(0, pr.first), pr.second); } };\n    template <class tuple_t, size_t index = tuple_size<tuple_t>::value - 1> struct tuple_hash_calc { static size_t apply(size_t seed, tuple_t const &t) { return hash_combine(tuple_hash_calc<tuple_t, index - 1>::apply(seed, t), get<index>(t)); } };\n    template <class tuple_t> struct tuple_hash_calc<tuple_t, 0> { static size_t apply(size_t seed, tuple_t const &t) { return hash_combine(seed, get<0>(t)); } };\n    template <class... T> struct hash<tuple<T...>> { size_t operator()(tuple<T...> const &t) const { return tuple_hash_calc<tuple<T...>>::apply(0, t); } };\n    template <class T, class U> istream &operator>>(std::istream &s, pair<T, U> &p) { return s >> p.first >> p.second; }\n    template <class T, class U> ostream &operator<<(std::ostream &s, const pair<T, U> &p) { return s << p.first << \" \" << p.second; }\n    template <class T> istream &operator>>(istream &s, vector<T> &v) { for(T &e : v) s >> e; return s; }\n    template <class T> ostream &operator<<(ostream &s, const vector<T> &v)  { bool is_front = true; for(const T &e : v) { if(not is_front) s << ' '; else is_front = false; s << e; } return s; }\n    template <class tuple_t, size_t index> struct tupleos { static ostream &apply(ostream &s, const tuple_t &t) { tupleos<tuple_t, index - 1>::apply(s, t); return s << \" \" << get<index>(t); } };\n    template <class tuple_t> struct tupleos<tuple_t, 0> { static ostream &apply(ostream &s, const tuple_t &t) { return s << get<0>(t); } };\n    template <class... T> ostream &operator<<(ostream &s, const tuple<T...> &t)  { return tupleos<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(s, t); }\n    template <> ostream &operator<<(ostream &s, const tuple<> &t) { return s; }\n    string revstr(string str) { reverse(str.begin(), str.end()); return str; }\n} // namespace std\n\n#ifdef LOCAL\n    #define dump(...)                                                              \\\n        debug_stream << \"[ \" << __LINE__ << \" : \" << __FUNCTION__ << \" ]\\n\",       \\\n            dump_func(#__VA_ARGS__, __VA_ARGS__)\n    template <class T> void dump_func(const char *ptr, const T &x)\n    {\n        debug_stream << '\\t';\n        for(char c = *ptr; c != '\\0'; c = *++ptr) if(c != ' ') debug_stream << c;\n        debug_stream << \" : \" << x << '\\n';\n    }\n    template <class T, class... rest_t> void dump_func(const char *ptr, const T &x, rest_t... rest)\n    {\n        debug_stream << '\\t';\n        for(char c = *ptr; c != ','; c = *++ptr) if(c != ' ') debug_stream << c;\n        debug_stream << \" : \" << x << \",\\n\"; dump_func(++ptr, rest...);\n    }\n#else\n    #define dump(...) ((void)0)\n#endif\ntemplate <class P> void read_range(P __first, P __second) { for(P i = __first; i != __second; ++i) std::cin >> *i; }\ntemplate <class P> void write_range(P __first, P __second) { for(P i = __first; i != __second; std::cout << (++i == __second ? '\\n' : ' ')) std::cout << *i; }\n\n// substitue y for x if x > y.\ntemplate <class T> inline bool sbmin(T &x, const T &y) { return x > y ? x = y, true : false; }\n// substitue y for x if x < y.\ntemplate <class T> inline bool sbmax(T &x, const T &y) { return x < y ? x = y, true : false; }\n// binary search.\ni64 bin(const std::function<bool(i64)> &pred, i64 ok, i64 ng)\n{\n    while(std::abs(ok - ng) > 1) { i64 mid = (ok + ng) / 2; (pred(mid) ? ok : ng) = mid; }\n    return ok;\n}\ndouble bin(const std::function<bool(double)> &pred, double ok, double ng, const double eps)\n{\n    while(std::abs(ok - ng) > eps) { double mid = (ok + ng) / 2; (pred(mid) ? ok : ng) = mid; }\n    return ok;\n}\n// be careful that val is type-sensitive.\ntemplate <class T, class A, size_t N> void init(A (&array)[N], const T &val) { std::fill((T *)array, (T *)(array + N), val); }\n// reset all bits.\ntemplate <class A> void reset(A &array) { memset(array, 0, sizeof(array)); }\n\n\n/* The main code follows. */\n\nusing namespace std;\n\nsigned main()\n{\n    void __solve();\n    u32 t = 1;\n#ifdef LOCAL\n    t = 1;\n#endif\n    // t = -1;\n    // cin >> t;\n    while(t--)\n    {\n        __solve();\n    }\n}\n\nvoid __solve()\n{\n    int n,k; cin>>n>>k;\n    vector<pii> eg;\n    for(int i=1; i<=n; ++i)\n    {\n        int pwr=1<<(32-__clz32(i));\n        for(int j=i+1; j<=n; ++j)\n        {\n            if(((pwr-1)&j)==i)\n            {\n                eg.emplace_back(i,j);\n            }\n        }\n    }\n    std::cout << eg.size() << '\\n';\n    for(auto e: eg)\n    {\n        std::cout << e << '\\n';\n    }\n    cout<<flush;\n\n    while(k--)\n    {\n        int now=0;\n        int h=0;\n        while(true)\n        {\n            now|=1<<h;\n            if(now>n)\n            {\n                now^=1<<h;\n                cout<<now<<endl;\n            }\n            else\n            {\n                cout<<now<<endl;\n            }\n            string res; cin>>res;\n            if(res==\"Yes\")\n            {\n                break;\n            }\n            if(res==\"No\")\n            {\n                now^=1<<h;\n            }\n            h++;\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<stack>\n#include<queue>\n#include<math.h>\n#include<functional>\n#include<bitset>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing pint = pair<int, int>;\nusing pll = pair<ll, ll>;\n#define MOD 1000000007LL\n#define INF 1000000000LL\n#define EPS 1e-10\n#define FOR(i,n,m) for(ll i=n;i<(int)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v)  sort(ALL(v));v.erase(unique(ALL(v)),v.end());\n#define pb push_back\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n, k;\n\tcin >> n >> k;\n\tint mxbit = 0, tmp = n;\n\twhile(tmp > 0) {\n\t\ttmp /= 2;\n\t\tmxbit++;\n\t}\n\tint m = 0;\n\tvector<pint> edge;\n\tREP(i, mxbit) {\n\t\tbitset<10> bi1(0); bi1[i] = 1;\n\t\tREP(j, n) {\n\t\t\tif(j + 1 == bi1.to_ulong()) continue;\n\t\t\tbitset<10> bi2(j + 1);\n\t\t\tif(bi2[i]) {\n\t\t\t\tedge.pb({(int)bi1.to_ulong(), j + 1});\n\t\t\t\tm++;\n\t\t\t}\n\t\t}\n\t}\n\tcout << m << endl;\n\tREP(i, m) {\n\t\tcout << edge[i].first << \" \" << edge[i].second << endl;\n\t}\n\tREP(game, k) {\n\t\tbitset<10> ans(0);\n\t\tbool ok = false;\n\t\tREP(i, mxbit) {\n\t\t\tbitset<10> q(0); q[i] = 1;\n\t\t\tcout << q.to_ulong() << endl;\n\t\t\tstring res = \"\";\n\t\t\tcin >> res;\n\t\t\tif(res == \"Yes\") {\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t} else if(res == \"Near\") {\n\t\t\t\tans[i] = 1;\n\t\t\t} else {\n\t\t\t\tans[i] = 0;\n\t\t\t}\n\t\t}\n\t\tif(!ok) {\n\t\t\tcout << ans.to_ulong() << endl;\n\t\t\tstring res = \"\";\n\t\t\tcin >> res;\n\t\t}\n\t}\n}\n/* --------------------------------------- */\n\n"
  },
  {
    "language": "C++",
    "code": "//答えによって、頂点集合を2分割するイメージ。\n#include <iostream>\n#include <vector>\n#include <string>\n#define rep(i, n) for(i = 0; i < n; i++)\nusing namespace std;\n\nint n, k;\nvector<int> et[200];\nint cnt[200];\n\t\nvoid game() {\n\tint v = 0;\n\tstring s;\n\t\n\twhile (true) {\n\t\tcout << v + 1 << endl;\n\t\tcin >> s;\n\t\tif (s == \"Yes\") return;\n\t\tif (s == \"Near\") v += 1;\n\t\tif (s == \"No\") v += cnt[v] / 2 + 1;\n\t}\n}\n\nint main() {\n\tint i, j;\n\t\n\tcin >> n >> k;\n\t\n\tcnt[0] = n;\n\t\n\trep(i, n) {\n\t\tint h = cnt[i] / 2;\n\t\trep(j, h) {\n\t\t\tet[i].push_back(i + 1 + j);\n\t\t\tcnt[i + 1 + j] = h;\n\t\t}\n\t\trep(j, cnt[i] - 1 - h) {\n\t\t\tet[i + 1].push_back(i + h + 1 + j);\n\t\t\tcnt[i + h + 1 + j] = cnt[i] - 1 - h;\n\t\t}\n\t}\n\t\n\tint m = 0;\n\trep(i, n) m += et[i].size();\n\t\n\tcout << m << endl;\n\trep(i, n) {\n\t\trep(j, et[i].size()) {\n\t\t\tcout << i + 1 << \" \" << et[i][j] + 1 << endl;\n\t\t}\n\t}\n\t\n\t//K回ゲームをする\n\trep(i, k) {\n\t\tgame();\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nset<pair<int, int>> es;\n\nvoid dfs(int l, int r) {\n    if (r <= l + 1) return;\n    int m = (l + r) / 2;\n    for (int i = l + 1; i < m; i++) {\n        es.insert({l, i});\n    }\n    for (int i = m + 1; i < r; i++) {\n        es.insert({m, i});\n    }\n    dfs(l, m);\n    dfs(m, r);\n}\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n\n    dfs(0, n);\n    cout << es.size() << endl;\n    for (auto& e : es) {\n        cout << e.first + 1 << ' ' << e.second + 1 << endl; \n    }\n\n    while (k--) {\n        cout << 1 << endl;\n        string s;\n        cin >> s;\n        if (s == \"Yes\") continue;\n        if (s == \"Near\") {\n            int l = 0, r = n / 2;\n            while (1) {\n                int m = (l + r) / 2;\n                cout << m + 1 << endl;\n                string s;\n                cin >> s;\n                if (s == \"Yes\") break;\n                if (s == \"Near\") {\n                    l = m;\n                } else {\n                    r = m;\n                }\n            }\n        } else {\n            cout << n / 2 + 1 << endl;\n            string s;\n            cin >> s;\n            if (s == \"Yes\") continue;\n            int l = n / 2, r = n;\n            while (1) {\n                int m = (l + r) / 2;\n                cout << m + 1 << endl;\n                string s;\n                cin >> s;\n                if (s == \"Yes\") break;\n                if (s == \"Near\") {\n                    l = m;\n                } else {\n                    r = m;\n                }\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvoid rec(vector<vector<int> > &G, int left, int right) {\n    if (right - left <= 1) return;\n    int mid = (left + right) / 2;\n    for (int i = mid + 1; i < right; ++i) G[mid].push_back(i);\n    rec(G, left, mid);\n    rec(G, mid, right);\n}\n\nvector<vector<int> > make_graph(int N) {\n    vector<vector<int> > G(N);\n    rec(G, 0, N);\n    return G;\n}\n\nint main() {\n    int N, K; cin >> N >> K;\n    auto G = make_graph(N);\n    int M = 0;\n    for (int i = 0; i < N; ++i) M += G[i].size();\n    cout << M << endl;\n    for (int i = 0; i < N; ++i) for (auto e : G[i]) cout << i+1 << \" \" << e+1 << endl;\n    \n    for (int _ = 0; _ < K; ++_) {\n        int left = 0, right = N;\n        string res;\n        while (true) {\n            int mid = (left + right) / 2;\n            cout << mid + 1 << endl;\n            cin >> res;\n            if (res == \"Yes\") break;\n            else if (res == \"Near\") left = mid;\n            else right = mid;\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <vector>\nusing namespace std;\nvector<int> Map[205];\nvoid work(int l, int r) {\n    if(r - l <= 1) return;\n    int m = (l + r) >> 1;\n    for(int i = m + 1; i < r; i++)\n        Map[m].push_back(i);\n    work(l, m);\n    work(m, r);\n}\nint main() {\n    int n, k, e = 0;\n    cin >> n >> k;\n    work(0, n);\n    for(int i = 0; i < n; i++)\n        e += Map[i].size();\n    cout << e << endl;\n    for(int i = 0; i < n; i++)\n        for(int j = 0; j < Map[i].size(); j++)\n            cout << i + 1 << \" \" << Map[i][j] + 1 << endl;\n    while(k--) {\n        int l = 0, r = n;\n        string s;\n        while(s != \"Yes\") {\n            int m = (l + r) / 2;\n            cout << m + 1 << endl;\n            cin >> s;\n            if (s == \"Near\")\n                l = m;\n            else if(s == \"No\")\n                r = m;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nint n, k, edge;\nvector<int> G[205];\n\nvector<int> make_graph(int node){\n  \n  if( n <= node ) return vector<int>();\n  \n  vector<int> res;\n  \n  vector<int> l = make_graph(node*2+1);\n  \n  vector<int> r = make_graph(node*2+2);\n  \n  for(int num : l ) G[node].push_back(num);\n  \n  if( n > node*2+2 ) G[node].push_back(node*2+2);\n  \n  for(int num : l ) res.push_back(num);\n  \n  for(int num : r ) res.push_back(num);\n  \n  res.push_back(node);\n  \n  return res;  \n}\n\nsigned main(){\n  \n  cin>>n>>k;\n  \n  make_graph(0);\n  \n  for(int i=0;i<n;i++){\n    for(int to : G[i] ) edge++;\n  }\n  \n  cout<<edge<<endl;\n  \n  for(int i=0;i<n;i++){\n    for(int to : G[i] ) cout<<i+1<<' '<<to+1<<endl;\n  }\n  \n  for(int i=0;i<k;i++){\n    \n    int A = 0;\n    int S = -1;\n    \n    while(1){\n      \n      if( n <= A ){\n\tcout<<S+1<<endl;\n      }else cout<<A+1<<endl;\n            \n      string s;\n\n      cin>>s;\n      \n      if( s == \"Yes\" ) break;\n      \n      if( s == \"No\" ) A = A * 2 + 2;\n      \n      if( s == \"Near\" ){\n\tS = A * 2 + 2;\n\tA = A * 2 + 1;\n      }\n\n      \n    }\n    \n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nconst int N = 8;\n\nint ask(int x){\n    cout << x+1 << endl;\n\n    string s;\n    cin >>s;\n\n    if(s==\"Yes\") return -1;\n    return s==\"Near\";\n}\n\nint main(){\n    int n,k;\n    cin >>n >>k;\n\n    // make graph\n    vector<pair<int,int>> e;\n    for(int i=N; i<n; ++i){\n        int mask = i-N;\n        rep(j,N)if(mask>>j&1){\n            e.pb({j+1, i+1});\n        }\n    }\n\n    cout << e.size() << endl;\n    for(const auto &p:e) cout << p.fi << \" \" << p.se << endl;\n\n    auto game = [&](){\n        int m = 0;\n        rep(i,N){\n            int a = ask(i);\n            if(a == -1) return;\n            m |= a<<i;\n        }\n\n        assert(ask(N+m) == -1);\n    };\n\n    while(k--) game();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> G;\n\nvoid create_two_uni(int l, int r){\n  // cout << l << \" \" << r << endl;\n  if(r - l <= 1) return;\n  int med = (l+r)/2;\n  for(int i = l+1; i < med; i++){\n    G.at(l).at(i) = true;\n    G.at(i).at(l) = true;\n  }\n  for(int i = med+1; i < r; i++){\n    G.at(med).at(i) = true;\n    G.at(i).at(med) = true;\n  }\n\n  create_two_uni(l+1, med);\n  create_two_uni(med + 1, r);\n}\n\nint num_of_edge(){\n  int res = 0;\n  for(int i = 0; i < (int)G.size(); i++){\n    for(int j = 0; j < i; j++){\n      if(G.at(i).at(j) == true) res++;\n    }\n  }\n  return res;\n}\n\nint main(void){\n  int N, K; cin >> N >> K;\n\n  G = vector<vector<int>>(N, vector<int>(N, false));\n\n  create_two_uni(0, N);\n\n  // for(const auto& gg: G){\n  //   for(const auto& g: gg){\n  //     cout  << g << ' ';\n  //   }\n  //   cout << '\\n';\n  // }\n\n  int E = num_of_edge();\n  cout << E << '\\n';\n  for(int i = 0; i < N; i++){\n    for(int j = 0; j < i; j++){\n      if(G.at(i).at(j) == true) cout << i+1 << \" \" << j+1 << '\\n';\n    }\n  }\n  fflush(stdout);\n\n  for(int loop = 0; loop < K; loop++){\n    int cnt = 0;\n    int l = 0, r = N;\n    bool YES = false;\n    vector<int> history;\n    while(1){\n      // cout << l << \" \" << r << endl;\n      // if(cnt >=  10) while(1);\n      if(r - l <= 0) break;\n      cout << l+1 << endl;\n      cnt++;\n      string res; cin >> res;\n      if(res == \"Yes\"){\n        YES = true;\n        break;\n      }\n      if(r - l <= 1) break;\n      if(res == \"Near\"){\n        r = (l + r) / 2;\n        l = l + 1;\n      }else if(res == \"No\"){\n        if(r - l == 2){\n          l = (l + r) / 2;\n        }else{\n        l = (l + r) / 2 + 1;\n        }\n        history.push_back(l);\n      }else{\n        // assert(false);\n      }\n    }\n    if(YES == false){\n      int p = history.back();\n      // if(cnt >= 9) while(1);\n      cout << p << endl;\n      string str; cin >> str;\n      // assert(str == \"Yes\");\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcountll\n\n#define INF 1e16\n#define mod 1000000007\n\nvector<P> es;\n\nvoid makegraph(int l,int r){ // [l,r)\n  if(l>=r)return ;\n  if(l+1==r){\n    return ;\n  }\n  int m=(l+1+r)/2;\n  repl(i,l+1,m)es.push_back(P(l,i));\n  makegraph(l+1,m); makegraph(m,r);\n}\n\nstring query(int x){\n  cout<<x+1<<endl;\n  fflush(stdout);\n  string res;\n  cin>>res;\n  return res;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int N,K;\n  cin>>N>>K;\n  makegraph(0,N);\n  cout<<es.size()<<endl;\n  rep(i,es.size())cout<<es[i].fi+1<<\" \"<<es[i].se+1<<endl;\n\n  rep(_,K){\n    int l=0,r=N;\n    while(1){\n      string q=query(l);\n      int m=(l+1+r)/2;\n      if(q==\"Yes\"){\n        break;\n      }else if(q==\"Near\"){\n        l++; r=m;\n      }else{\n        l=m;\n      }\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,_7,_8,NAME,...) NAME\n#define pr(...) cerr<< GET_MACRO(__VA_ARGS__,pr8,pr7,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__) <<endl\n#define pr1(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr2(a,b) pr1(a)<<pr1(b)\n#define pr3(a,b,c) pr1(a)<<pr2(b,c)\n#define pr4(a,b,c,d) pr1(a)<<pr3(b,c,d)\n#define pr5(a,b,c,d,e) pr1(a)<<pr4(b,c,d,e)\n#define pr6(a,b,c,d,e,f) pr1(a)<<pr5(b,c,d,e,f)\n#define pr7(a,b,c,d,e,f,g) pr1(a)<<pr6(b,c,d,e,f,g)\n#define pr8(a,b,c,d,e,f,g,h) pr1(a)<<pr7(b,c,d,e,f,g,h)\n#define prArr(a) {cerr<<(#a)<<\"={\";int i=0;for(auto t:(a))cerr<<(i++?\", \":\"\")<<t;cerr<<\"}\"<<endl;}\nusing namespace std;\nusing Int = long long;\nusing _int = int;\nusing ll = long long;\nusing Double = long double;\nconst Int INF = (1LL<<60)+1e9; // ~ 1.15 * 1e18\nconst Int mod = (1e9)+7;\nconst Double EPS = 1e-8;\nconst Double PI = 6.0 * asin((Double)0.5);\nusing P = pair<Int,Int>;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\ntemplate<class T1, class T2> ostream& operator<<(ostream& o,pair<T1,T2> p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\ntemplate<class T1, class T2, class T3> ostream& operator<<(ostream& o,tuple<T1,T2,T3> t){\n  return o<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\ntemplate<class T1, class T2> istream& operator>>(istream& i,pair<T1,T2> &p){return i>>p.first>>p.second;}\ntemplate<class T> ostream& operator<<(ostream& o,vector<T> a){Int i=0;for(T t:a)o<<(i++?\" \":\"\")<<t;return o;}\ntemplate<class T> istream& operator>>(istream& i,vector<T> &a){for(T &t:a)i>>t;return i;}\n//INSERT ABOVE HERE\n\nint N, K;\nvector<vector<int> > G;\n\nint solve1(){ //N < 9;\n  \n  for(int i=0;i<N;i++){\n    cout<<i+1<<endl;\n    string res;\n    cin>>res;\n    if(res == \"Yes\") return 0;\n  }\n  assert(0);\n  //return 0;\n}\n\nint solve2(){\n  \n  int ans = 0;\n  for(int i=0;i<9;i++){\n    cout<<i+1<<endl;\n    string res;\n    cin>>res;\n    if(res == \"Yes\") return 0;\n    if(res == \"Near\") ans = ans + (1<<i);\n  }\n  cout<<ans+1<<endl;\n  string res;\n  cin>>res;\n  assert(res == \"Yes\");\n  return 0;\n}\n\nsigned main(){\n  srand((unsigned)time(NULL));\n  //cin.tie(0);\n  //ios_base::sync_with_stdio(0);\n  //cout << fixed << setprecision(12);\n\n\n  cin>>N>>K;\n\n  if(N < 9){\n    cout<<0<<endl;\n    while(K--) solve1();\n  }\n  else{\n\n    int M = 0;\n    G.resize(N);\n    for(int i=9;i<N;i++)\n      for(int j=0;j<9;j++){\n\tif(i>>j&1) G[i].push_back(j), G[j].push_back(i), M++;\n      }\n\n    cout<<M<<endl;\n    for(int i=0;i<N;i++)\n      for(int j:G[i]) if(i < j) cout<<i+1<<\" \"<<j+1<<endl;\n\n    while(K--) solve2();\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n#include <deque>\n#include <iomanip>\n#include <cstdio>\n#include <stack>\n#include <numeric>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\n\nint main(){\n    int n,k;\n    cin >> n >> k;\n    if(n<=10){\n        int m = 0;\n        cout << m << endl;\n        int cnt = 0;\n        while(1){\n            string s;\n            \n            for(int i=1;i<=n;i++){\n                cout << i << endl;\n                cin >> s;\n                if(s==\"Yes\"){\n                    cnt++;\n                    if(cnt==k)break;\n                }\n            }\n            if(cnt==k)break;\n        }\n    }else{\n        vector<pair<int,int> > g;\n        for(int i=10;i<=n;i++){\n            int bit = i-10;\n            for(int j=1;j<=9;j++){\n                if((bit>>(j-1))&1){\n                    g.push_back(MP(j,i));\n                }\n            }\n        }\n        cout << g.size() << endl;\n        rep(i,g.size()){\n            cout << g[i].first << \" \" << g[i].second << endl;\n        }\n        rep(zz,k){\n            int ans = 10;\n            string s;\n            for(int i=1;i<=9;i++){\n                cout << i << endl;\n                cin >> s;\n                if(s==\"Yes\"){\n                    break;\n                }else if(s==\"Near\"){\n                    ans += 1<<(i-1);\n                }\n            }\n            if(s==\"Yes\")continue;\n            cout << ans << endl;\n            cin >> s;\n        }\n    }\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define rep1(i, n) for (int i = 1; i < (n); i++)\n#define all(v) (v).begin(), (v).end()\nusing namespace std;\ntypedef long long LL;\nconst LL INF = 999999999999;\n\n\nint main(){\n    string buff;\n    int n, k;\n    cin >> n >> k;\n    vector<vector<int>> G(n+1);\n    vector<pair<int, int>> E;\n    for(int i=1; i<=n; i<<=1){\n        rep1(j, n+1){\n            if(i != j && i&j){\n                E.emplace_back(i, j);\n                G[i].push_back(j);\n                G[j].push_back(i);\n            }\n        }\n    }\n    cout << E.size() << endl;\n    rep(i, E.size()){\n        cout << E[i].first << \" \" << E[i].second << endl;\n    }\n    rep(q, k){\n        int ans = 0;\n        bool f = 0;\n        for(int i=1; i<=n; i<<=1){\n            cout << i << endl;\n            cin >> buff;\n            if(buff != \"No\") ans += i;\n            if(buff == \"Yes\"){\n                f = 1;\n                break;\n            }\n        }\n        if(!f){\n            cout << ans << endl;\n            cin >> buff;\n            assert(buff == \"Yes\");\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC target (\"avx\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define _USE_MATH_DEFINES\n#include<iostream>\n#include<string>\n#include<queue>\n#include<cmath>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<random>\n#include<functional>\n#include<algorithm>\n#include<stack>\n#include<cstdio>\n#include<cstring>\n#include<bitset>\n#include<unordered_map>\n#include<climits>\n#include<fstream>\n#include<complex>\n#include<time.h>\n#include<cassert>\n#include<functional>\n#include<numeric>\n#include<tuple>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n#define int long long\n#define all(a) (a).begin(),(a).end()\n#define fs first\n#define sc second\n#define xx first\n#define yy second.first\n#define zz second.second\n#define H pair<int, int>\n#define P pair<int, pair<int, int>>\n#define Q(i,j,k) mkp(i,mkp(j,k))\n#define rng(i,s,n) for(int i = (s) ; i < (n) ; i++)\n#define rep(i,n) rng(i, 0, (n))\n#define mkp make_pair\n#define vec vector\n#define vi vec<int>\n#define pb emplace_back\n#define siz(a) (int)(a).size()\n#define crdcomp(b) sort(all((b)));(b).erase(unique(all((b))),(b).end())\n#define getidx(b,i) (lower_bound(all(b),(i))-(b).begin())\n#define ssp(i,n) (i==(int)(n)-1?\"\\n\":\" \")\n#define ctoi(c) (int)(c-'0')\n#define itoc(c) (char)(c+'0')\n#define cyes printf(\"Yes\\n\")\n#define cno printf(\"No\\n\")\n#define cdf(n) int quetimes_=(n);rep(qq123_,quetimes_)\n#define gcj printf(\"Case #%lld: \",qq123_+1)\n#define readv(a,n) a.resize(n,0);rep(i,(n)) a[i]=read()\n#define found(a,x) (a.find(x)!=a.end())\n//#define endl \"\\n\"\nconstexpr int mod = (ll)1e9 + 7;\nconstexpr int Mod = 998244353;\nconstexpr ld EPS = 1e-10;\nconstexpr ll inf = (ll)3 * 1e18;\nconstexpr int Inf = (ll)15 * 1e8;\nconstexpr int dx[] = { -1,1,0,0 }, dy[] = { 0,0,-1,1 };\ntemplate<class T>bool chmax(T& a, const T& b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T& a, const T& b) { if (b < a) { a = b; return 1; } return 0; }\nll read() { ll u, k = scanf(\"%lld\", &u); return u; }\nstring reads() { string s; cin >> s; return s; }\nH readh(short g = 0) { H u; int k = scanf(\"%lld %lld\", &u.fs, &u.sc); if (g == 1) u.fs--, u.sc--; if (g == 2) u.fs--; return u; }\nbool ina(H t, int h, int w) { return 0 <= t.fs && t.fs < h && 0 <= t.sc && t.sc < w; }\nbool ina(int t, int l, int r) { return l <= t && t < r; }\nll gcd(ll i, ll j) { return j ? gcd(j, i % j) : i; }\nll popcount(ll x) {\n    int sum = 0; for (int i = 0; i < 60; i++)if ((1ll << i) & x) sum++;\n    return sum;\n}\ntemplate<typename T>\nclass csum {\n    vec<T> v;\npublic:\n    csum(vec<T>& a) :v(a) { build(); }\n    csum() {}\n    void init(vec<T>& a) { v = a; build(); }\n    void build() {\n        for (int i = 1; i < v.size(); i++) v[i] += v[i - 1];\n    }\n    T a(int l, int r) {\n        if (r < l) return 0;\n        return v[r] - (l == 0 ? 0 : v[l - 1]);\n    }//[l,r]\n    T b(int l, int r) {\n        return a(l, r - 1);\n    }//[l,r)\n    T a(pair<int, int>t) {\n        return a(t.first, t.second);\n    }\n    T b(pair<int, int>t) {\n        return b(t.first, t.second);\n    }\n};\nclass mint {\npublic:ll v;\n      mint(ll v = 0) { s(v % mod + mod); }\n      constexpr static int mod = (ll)1e9 + 7;\n      constexpr static int fn_ = (ll)2e6 + 5;\n      static mint fact[fn_], comp[fn_];\n      mint pow(int x) const {\n          mint b(v), c(1);\n          while (x) {\n              if (x & 1) c *= b;\n              b *= b;\n              x >>= 1;\n          }\n          return c;\n      }\n      inline mint& s(int vv) {\n          v = vv < mod ? vv : vv - mod;\n          return *this;\n      }\n      inline mint inv()const { return pow(mod - 2); }\n      inline mint operator-()const { return mint() - *this; }\n      inline mint& operator+=(const mint b) { return s(v + b.v); }\n      inline mint& operator-=(const mint b) { return s(v + mod - b.v); }\n      inline mint& operator*=(const mint b) { v = v * b.v % mod; return *this; }\n      inline mint& operator/=(const mint b) { v = v * b.inv().v % mod; return *this; }\n      inline mint operator+(const mint b) const { return mint(v) += b; }\n      inline mint operator-(const mint b) const { return mint(v) -= b; }\n      inline mint operator*(const mint b) const { return mint(v) *= b; }\n      inline mint operator/(const mint b) const { return mint(v) /= b; }\n      friend ostream& operator<<(ostream& os, const mint& m) {\n          return os << m.v;\n      }\n      friend istream& operator>>(istream& is, mint& m) {\n          int x; is >> x; m = mint(x);\n          return is;\n      }\n      bool operator<(const mint& r)const { return v < r.v; }\n      bool operator>(const mint& r)const { return v > r.v; }\n      bool operator<=(const mint& r)const { return v <= r.v; }\n      bool operator>=(const mint& r)const { return v >= r.v; }\n      bool operator==(const mint& r)const { return v == r.v; }\n      bool operator!=(const mint& r)const { return v != r.v; }\n      explicit operator bool()const { return v; }\n      explicit operator int()const { return v; }\n      mint comb(mint k) {\n          if (k > * this) return mint();\n          if (!fact[0]) combinit();\n          if (v >= fn_) {\n              if (k > * this - k) k = *this - k;\n              mint tmp(1);\n              for (int i = v; i >= v - k.v + 1; i--) tmp *= mint(i);\n              return tmp * comp[k.v];\n          }\n          return fact[v] * comp[k.v] * comp[v - k.v];\n      }//nCk\n      mint perm(mint k) {\n          if (k > * this) return mint();\n          if (!fact[0]) combinit();\n          if (v >= fn_) {\n              mint tmp(1);\n              for (int i = v; i >= v - k.v + 1; i--) tmp *= mint(i);\n              return tmp;\n          }\n          return fact[v] * comp[v - k.v];\n      }//nPk\n      static void combinit() {\n          fact[0] = 1;\n          for (int i = 1; i < fn_; i++) fact[i] = fact[i - 1] * mint(i);\n          comp[fn_ - 1] = fact[fn_ - 1].inv();\n          for (int i = fn_ - 2; i >= 0; i--) comp[i] = comp[i + 1] * mint(i + 1);\n      }\n}; mint mint::fact[fn_], mint::comp[fn_];\n//--------------------------------------------------------------\n//---------------------------------------------------------------------\nint n, k, tmp;\nbool a[300][300];\nint ask(int t) {\n    cout << t << endl;\n    string s;\n    if (t == tmp) s = \"Yes\";\n    else if (a[t][tmp])  s = \"Near\";\n    else s = \"No\";\n    s = reads();\n    if (s == \"Yes\") return 0;\n    else if (s == \"Near\") return 1;\n    else return 2;\n}\nvoid answer(int t) {\n    cout << \"! \" << t << endl;\n}\nvoid solve() {\n    cin >> n >> k;\n    vec<H>e;\n    auto dfs = [&](int l, int r, auto& dfs) ->void{\n        if ((r - l) <= 2) return;\n        rng(i, l + 1, (l + r) / 2) {\n            e.pb(H{ l + 1,i + 1 });\n            a[l + 1][i + 1] = 1;\n        }\n        dfs(l + 1, (l + r) / 2, dfs);\n        dfs((l + r) / 2, r, dfs);\n    };\n\n    dfs(0, n, dfs);\n    cout << siz(e) << endl;\n    for (auto g : e) cout << g.fs << \" \" << g.sc << endl;\n\n    cdf(k) {\n        int ok = 0, ng = n;\n        while (ng - ok > 1) {\n            int num = ask(ok + 1);\n            if (num == 0) {\n                goto loop;\n            }\n            else if (num == 1) {\n                ng = (ok + ng) / 2;\n                ok++;\n            }\n            else ok = (ok + ng) / 2;\n        }\n        ask(ok + 1);\n    loop:;\n    }\n}\nsigned main() {\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Edge{\n\tEdge(int arg_from,int arg_to){\n\t\tfrom = arg_from;\n\t\tto = arg_to;\n\t}\n\tint from,to;\n};\n\n\nint main(){\n\n\tint N,K;\n\n\tcin >> N >> K;\n\n\tint M = 0;\n\tvector<Edge> G;\n\n\tfor(int base = 1; base <= N; base*=2){\n\n\t\tfor(int adj = base+1; adj <= N; adj++){\n\t\t\tif((base&adj)){\n\t\t\t\tG.push_back(Edge(base,adj));\n\t\t\t\tM++;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << M << endl;\n\n\tfor(int i = 0; i < G.size(); i++){\n\n\t\tcout << G[i].from << G[i].to << endl;\n\t}\n\n\tint sum;\n\tstring buf;\n\tbool FLG;\n\n\tfor(int loop = 0; loop < K; loop++){\n\n\t\tsum = 0;\n\t\tFLG = false;\n\n\t\tfor(int base = 1; base <= N; base*=2){\n\n\t\t\tcout << base << endl;\n\n\t\t\tcin >> buf;\n\t\t\tif(buf[0] == 'Y'){\n\t\t\t\tFLG = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(buf[0] == 'N' && buf[1] == 'e')sum += base;\n\t\t}\n\t\tif(FLG)continue;\n\n\t\tcout << sum << endl;\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n//#include <deque>\n#include <valarray>\n#include <unordered_map>\n#include <unordered_set>\n#include <array>\n// stream\n//#include <istream>\n#include <sstream>\n//#include <ostream>\n#include <fstream>\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int w_=0; w_<n; ++w_){MACRO_VEC_ROW_Scan(w_, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& R:c)for(auto& w:R)std::cin>>w;\n// output\n#define OUT(dist) std::cout<<(dist);\n#define FOUT(n, dist) std::cout<<std::fixed<<std::setprecision(n)<<(dist);\n#define SOUT(n, c, dist) std::cout<<std::setw(n)<<std::setfill(c)<<(dist);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(w, n) std::cout<<(w + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(dist) {std::cerr << #dist << \"\\t:\" << (dist) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(w, a, n) for(int w=(a);w<(n);++w)\n#define RFOR(w, a, n) for(int w=(n)-1;w>=(a);--w)\n#define REP(w, n) for(int w=0;w<int(n);++w)\n#define RREP(w, n) for(int w=int(n)-1;w>=0;--w)\n#define FORLL(w, a, n) for(ll w=ll(a);w<ll(n);++w)\n#define RFORLL(w, a, n) for(ll w=ll(n)-1;w>=ll(a);--w)\n#define REPLL(w, n) for(ll w=0;w<ll(n);++w)\n#define RREPLL(w, n) for(ll w=ll(n)-1;w>=0;--w)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<class T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<class T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\n\n// test\ntemplate<class T> using V = std::vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n#define random_shuffle \"USE std::shuffle!\";\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-6;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n// ------------>8------------------------------------->8------------\n\nstd::map<int, std::string> map;\n\nint query(int i) {\n\tstd::string res;\n\tif (map.count(i)) res = map[i];\n\telse {\n\t\tOUT(i + 1)ENDL;\n\t\tstd::cin >> res;\n\t\tmap[i] = res;\n\t}\n\tif (res[0] == 'Y') return 1; // Yes\n\tif (res[1] == 'e') return 0; // Near\n\telse return -1;              // No\n}\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, n, k);\n\n\tstd::set<PAIR> eset;\n\tauto make = [&](int l, int r) {\n\t\tFOR(i, l + 1, r) eset.insert(PAIR(l, i));\n\t};\n\tauto rec = [&](auto&& f, int l, int r) -> void {\n\t\tint len = r - l;\n\t\tif (len == 1) return;\n\t\tif (len == 2) {\n\t\t\tmake(l, r);\n\t\t\treturn;\n\t\t}\n\t\tint m = (l + r) / 2;\n\t\tf(f, l, m);\n\t\tf(f, m, r);\n\t\tmake(m, r);\n\t};\n\n\trec(rec, 0, n);\n\n\tOUT(eset.size())ENDL;\n\tfor (auto& p : eset) {\n\t\tOUT(p.first + 1)SP OUT(p.second + 1)ENDL;\n\t}\n\n\tREP(_, k) {\n\t\tmap.clear();\n\n\t\t[&] {\n\t\t\tint l = 0, r = n;\n\t\t\twhile (r - l > 2) {\n\t\t\t\tint m = (l + r) / 2;\n\t\t\t\tint q = query(m);\n\t\t\t\tif (q == 1) return;\n\t\t\t\tif (q == 0) l = m;\n\t\t\t\telse r = m;\n\t\t\t}\n\t\t\tif (query(l + 0) == 1) return;\n\t\t\tif (query(l + 1) == 1) return;\n\t\t\tassert(false);\n\t\t}();\n\t}\n\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <string>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\nusing namespace std;\n#define int long long\nint MOD = 1000000007;\nint N, K, T;\nint ask(int a) {\n\n\n\tcout << a + 1 << endl << flush;\n\tstring res;\n\tcin >> res;\n\tif (res[0] == 'Y')return 1;\n\tif (res == \"No\")return -1;\n\tif (res == \"Near\")return 0;\n\n}\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tcin >> N >> K;\n\n\tT = max((int)0, N - 9);\n\n\n\tvector<pair<int, int> > es;\n\n\tfor (int i = 0; i < T; i++) {\n\t\tfor (int j = 0; j < 9; j++) {\n\t\t\tif (i & (1 << j)) {\n\t\t\t\tes.emplace_back(i, T + j);\n\t\t\t}\n\t\t}\n\t}\n\tcout << es.size() << endl;\n\tfor (int i = 0; i < es.size(); i++) {\n\t\tcout << es[i].first + 1 << \" \" << es[i].second + 1 << endl;\n\t}\n\tcout << flush;\n\n\tfor (int t = 0; t < K; t++) {\n\t\tint X = 0;\n\t\tint r;\n\t\tint ans = 0;\n\t\tfor (int i = T; i < N; i++) {\n\t\t\tr = ask(i);\n\t\t\tif (r == 1)break;\n\t\t\telse if (r == 0) {\n\t\t\t\tans += (1 << (i - T));\n\t\t\t}\n\t\t}\n\t\tif (r != 1) {\n\t\t\task(ans);\n\t\t}\n\n\n\n\t}\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\ntemplate<typename T>\nvector<T> compress(vector<T> v){\n  sort(v.begin(),v.end());\n  v.erase(unique(v.begin(),v.end()),v.end());\n  return v;\n}\n\n//INSERT ABOVE HERE\nsigned main(){\n  int n,k;\n  cin>>n>>k;\n  using P = pair<int, int>;\n  vector<P> vp;\n  for(int i=0;i<min(8,n);i++)\n    for(int j=0;j<n;j++)\n      if(i!=j&&((j>>i)&1)) vp.emplace_back(min(i,j),max(i,j));\n\n  vp=compress(vp);\n  cout<<vp.size()<<endl;\n  for(auto p:vp) cout<<p.first+1<<\" \"<<p.second+1<<endl;\n  for(int i=0;i<k;i++){    \n    int res=0;\n    auto ask=\n      [&](int k){\n        if(res<0) return \"\"s;\n        cout<<k+1<<endl;\n        string s;\n        cin>>s;\n        if(s==\"Yes\"s) res=-1;\n        return s;\n      };\n    for(int i=0;i<min(8,n);i++){\n      auto s=ask(i);\n      if(s==\"Near\"s) res|=(1<<i);      \n    }\n    ask(res);\n  }  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace  std;\n\ntypedef pair<int,int>P;\n#define fi first\n#define se second\n\n\nint n,k ;\n\nvector<P>A;\n\nvoid dfs(vector<int> v,int now){\n  r(i,v.size()){\n    A.push_back(P(v[i],now));\n  }\n  if(now*2+1<n){\n    vector<int>nex=v;\n    nex.push_back(now);\n    dfs(nex,now*2+1);\n  }\n  if(now*2+2<n){\n    vector<int>nex=v;\n    nex.push_back(now);\n    dfs(nex,now*2+2);\n  }\n}\n\n//int x=0;\n\nstring output(int num){\n\n  //cerr<<\"aaa:\"<<num<<endl;\n  //if(x++==10)exit(0);\n\n  cout<<num<<endl;\n\n  string s;\n/*\n  const int atari = 3;\n\n  if(atari == num)return \"Yes\";\n\n  r(i,A.size()){\n    if(A[i].fi==num-1 && A[i].se+1 == atari)return \"Near\";\n    if(A[i].se==num-1 && A[i].fi+1 == atari)return \"Near\";\n  }\n  return \"No\";\n*/\n  cin>>s;\n  return s;\n}\n\nint main(){\n\n  cin>>n>>k;\n\n  vector<int>init;\n\n  dfs(init,0);\n\n  cout<<A.size()<<'\\n';\n\n  r(i,A.size()){\n    cout<<A[i].fi+1<<' '<<A[i].se+1;\n    if(i!=(int)A.size())cout<<'\\n';\n    else cout<<endl;\n  }\n\n  while(k--){\n\n    int idx=0,p=0,F=-1,S=0;\n\n    while(1){\n\n      if(!p){\n        string s=output(idx+1);\n        if(s==\"Yes\"){\n          S++;\n          break;\n        }\n        p++;\n      }\n\n      int nex=idx*2+1;\n\n      if(nex>=n)break;\n\n      string s=output(nex+1);\n\n      if(s==\"No\"){\n        F=nex+1;\n        idx=idx*2+2;\n      }\n\n      else if(s==\"Yes\"){\n        S++;\n        break;\n      }\n\n      else{\n        idx=idx*2+1;\n      }\n      if(idx>=n)break;\n    }\n\n    if(!S){\n\n      //cout<<F<<endl;\n\n      if(F+1<=n){\n        string s=output(F+1);\n        //cout<<s<<endl;\n        if(s==\"Yes\")continue;\n      }\n\n      if(F-1>=1){\n        string s=output(F-1);\n        if(s==\"Yes\")continue;\n      }\n      //cout<<\"ERROR\"<<endl;\n      //exit(1);\n    }\n\n  }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef pair<ll,int> pli;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\n\nvector<pint> v;\nvoid add_edge(int a,int b){\n    if(b-a<=1)return;\n    int m=(b-a)/2;\n    rep(i,m){\n        v.emplace_back(a,a+i+1);\n    }\n    add_edge(a+1,a+m+1);\n    add_edge(a+m+1,b);\n}\nint main(){\n    int n,k;\n    cin>>n>>k;\n    add_edge(1,n+1);\n    int m=v.size();\n    cout<<m<<endl;\n    rep(i,m){\n        cout<<v[i].first<<\" \"<<v[i].second<<endl;\n    }\n    while(k--){\n        int ans=1;\n        int right=n+1;\n        while(1){\n            cout<<ans<<endl;\n            string ret;\n            cin>>ret;\n            if(ret==\"Yes\")break;\n            int mid=(right-ans)/2;\n            if(ret==\"No\"){\n                ans+=mid+1;\n            }\n            else {\n                right=ans+mid+1;\n                ++ans;\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<map>\n#include<stack>\n#include<cmath>\n#include<iomanip>\n#include<set>\n#include<numeric>\n#include<sstream>\n#include<random>\n#include<cassert>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for (int i = 0; i < n; ++i)\n#define rrep(i, st, n) for (int i = st; i < n; ++i)\nusing pii = pair<int, int>;\nconst int inf = 1e9 + 7;\nint dy[] = {0, 0, -1, 1, -1, 1, -1, 1};\nint dx[] = {1, -1, 0, 0, -1, 1, 1, -1};\n#define ceil(a, b) a / b + !!(a % b)\n#define chmax(a, b) a = max(a, b)\n#define chmin(a, b) a = min(a, b)\n\nvector<int> v[200 + 1];\nint c;\nvoid recur(int l, int r) {\n    //cout << l << \" \" << r << endl;\n    if (l == r) return;\n    int mid = (l + r) / 2;\n    rrep(i, mid + 1, r + 1) {\n        v[mid].push_back(i);\n        c++;\n    }\n    if (l <= mid - 1) recur(l, mid - 1);\n    if (mid + 1 <= r) recur(mid + 1, r);\n}\nint main() {\n    cin.tie(0); ios::sync_with_stdio(false);\n    int n, k; cin >> n >> k;\n    recur(1, n);\n    cout << c << endl;\n    rep(i, n + 1) {\n        rep(j, v[i].size()) {\n            cout << i << \" \" << v[i][j] << endl;\n        }\n    }\n    while (k--) {\n        int now = (1 + n) / 2;\n        int l = 1, r = n;\n        while (1) {\n            cout << now << endl;\n            string s; cin >> s;\n            if (s == \"Yes\") break;\n            else if (s == \"Near\") {\n                l = now + 1;\n            } else {\n                r = now - 1;\n            }\n            now = (l + r) / 2;\n        }\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define chmin(a, b) ((a)=min((a), (b)))\n#define chmax(a, b) ((a)=max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n\nconst ll MOD=1e9+7;\nconst ll INF=1e18;\nconst double pi=acos(-1);\nconst double eps=1e-10;\n\nint dx[]={1, -1, 0, 0};\nint dy[]={0, 0, 1, -1};\n\nint main(){\n    // 1-indexed\n    int n, k; cin>>n>>k;\n    vector<vector<int>> g(n+1);\n    vector<P> edge;\n    for(int i=1; i<=8; i++){\n        int num=(1<<(i-1));\n        if(n<num) break;\n        for(int j=1; j<=n; j++){\n            if(i==j) continue;\n            if(num & j){\n                g[i].push_back(j);\n                g[j].push_back(i);\n                edge.push_back(P(i, j));\n            }\n        }\n    }\n\n    cout << edge.size() << endl;\n    for(int i=0; i<edge.size(); i++){\n        cout << edge[i].fs << \" \" << edge[i].sc << endl;\n    }\n\n    while(k){\n        string s;\n        int sum=0;\n        for(int i=1; i<=8; i++){\n            int num=(1<<(i-1));\n            if(n<num) break;\n\n            // i ビット目が立っているか\n            cout << i << endl;\n            cin>>s;\n            if(s==\"Yes\"){\n                k--;\n                goto END;\n            }\n            if(s==\"Near\"){\n                sum+=num;\n            }\n        }\n        cout << sum << endl;\n        cin>>s;\n        k--;\n        END:;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "// includes {{{\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<tuple>\n#include<cmath>\n#include<random>\n#include<cassert>\n// #include<deque>\n// #include<multiset>\n// #include<bitset>\n// #include<cstring>\n// #include<bits/stdc++.h>\n// }}}\nusing namespace std;\nusing ll = long long;\n\nint n, k;\n\nvoid solve() {\n  string res;\n  int ans = 0;\n  for(int i = 0; i < 9; i++) {\n    cout << i + 1 << endl;\n    cin >> res;\n    if(res == \"Yes\") return;\n    if(res == \"Near\") ans ^= 1 << i; // あほくさ\n  }\n  cout << ans + 1 << endl;\n  cin >> res;\n  assert(res == \"Yes\");\n}\n\nint main() {\n  // ios::sync_with_stdio(false), cin.tie(0);\n  cin >> n >> k;\n\n  // int cnt = 0;\n  vector<pair<int, int>> v;\n  for(int i = 9; i < n; i++) {\n    for(int j = 0; j < 9; j++) {\n      if(i & (1 << j)) {\n        v.emplace_back(j, i);\n      }\n    }\n  }\n\n  cout << v.size() << \"\\n\";\n  for(auto p : v){\n    cout << p.first + 1 << \" \" << p.second + 1 << \"\\n\"; //// \n  }\n  cout << flush;\n\n  for(int i = 0; i < k; i++) {\n    solve();\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <unordered_set>\n#include <unordered_map>\n#include <array>\n#include <cassert>\n#include <bitset>\nusing namespace std;\nusing LL = long long;\n\nLL N, K;\n\nint ask(int k) {\n\tcout << k + 1 << endl;\n\tstring S;\n\tcin >> S;\n\tif (S == \"Yes\") {\n\t\treturn -1;\n\t}\n\tif (S == \"Near\") {\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nint main(void)\n{\n\tcin >> N >> K;\n\tif (N <= 10) {\n\t\tcout << 0 << endl;\n\t\tfor (int g = 0; g < K; ++g) {\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tif (ask(i) < 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint P = N - 9;\n\tvector<pair<int, int>>vec;//0-indexed\n\tfor (int i = 0; i < 9; ++i) {\n\t\tfor (int s = 0; s < P; ++s) {\n\t\t\tif (s & (1 << i)) {\n\t\t\t\tvec.push_back({ s,i + P });\n\t\t\t}\n\t\t}\n\t}\n\tint M = vec.size();\n\tcout << M << endl;\n\tfor (int i = 0; i < M; ++i) {\n\t\tcout << vec[i].first + 1 << \" \" << vec[i].second + 1 << endl;\n\t}\n\tfor (int g = 0; g < K; ++g) {\n\t\tbool tok = false;\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < 9; ++i) {\n\t\t\tint res = ask(i + P);\n\t\t\tif (res < 0) {\n\t\t\t\ttok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(res)ans += (1 << i);\n\t\t}\n\t\tif (tok)continue;\n\t\tint ult = ask(ans);\n\t\tassert(ult < 0);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing LL = long long;\nconst LL MOD = 1e9+9;\nusing namespace std;\n\n\n\nint main(){\n    int N,K;cin >> N >> K;\n    set<pair<int,int>> Edge;\n    function<void(int,int)> calc = [&](int i,int j){\n        if(j == 0)return ;\n        Edge.insert({i,(j-1)/2});\n        calc(i,(j-1)/2);\n    };\n    for(int a = N-1;a >= 1;a--){\n        calc(a,a);\n    }\n    cout<<Edge.size()<<endl;\n    for(auto e :Edge){\n        cout<<e.first+1<<\" \"<<e.second+1<<endl;\n    }\n    for(int index = 0;index < K;index++){\n        int i = 0;\n        int result = -1;\n        while(i < N){\n            cout<<i+1<<endl;\n            string s;cin >> s;\n            if(s == \"Yes\"){\n                result = -1;\n                break;\n            }\n            if(s == \"Near\"){\n                i *= 2;\n                i++;\n            }else{\n                i++;\n                result = i;\n                i *= 2;\n                i++;\n            }\n        }\n        if(result != -1){\n            cout<<result+1<<endl;\n            string s;cin >> s;\n            continue;\n        }\n    }\n    cout<<flush;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Edge{\n\tEdge(int arg_from,int arg_to){\n\t\tfrom = arg_from;\n\t\tto = arg_to;\n\t}\n\tint from,to;\n};\n\n\nint main(){\n\n\tint N,K;\n\n\tcin >> N >> K;\n\n\tint M = 0;\n\tvector<Edge> G;\n\n\tfor(int base = 1; base <= N; base*=2){\n\n\t\tfor(int adj = base+1; adj <= N; adj++){\n\t\t\tif((base&adj)){\n\t\t\t\tG.push_back(Edge(base,adj));\n\t\t\t\tM++;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << M << endl;\n\n\tfor(int i = 0; i < G.size(); i++){\n\n\t\tcout << G[i].from << \" \" << G[i].to << endl;\n\t}\n\n\tint sum;\n\tstring buf;\n\tbool FLG;\n\n\tfor(int loop = 0; loop < K; loop++){\n\n\t\tsum = 0;\n\t\tFLG = false;\n\n\t\tfor(int base = 1; base <= N; base*=2){\n\n\t\t\tcout << base << endl;\n\n\t\t\tcin >> buf;\n\t\t\tif(buf[0] == 'Y'){\n\t\t\t\tFLG = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(buf[0] == 'N' && buf[1] == 'e')sum += base;\n\t\t}\n\t\tif(FLG)continue;\n\n\t\tcout << sum << endl;\n\t\tcin >> buf;\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//!============================================!//\n//!    8888ba.88ba             oo              !//\n//!    88  '8b  '8b                            !//\n//!    88   88   88  .d8888b.  dP  88d888b.    !//\n//!    88   88   88  88'  '88  88  88'  '88    !//\n//!    88   88   88  88.  .88  88  88    88    !//\n//!    dP   dP   dP  '88888P8  dP  dP    dP    !//\n//!============================================!//\nint main()\n{\n    int N, K;\n    std::cin >> N >> K;\n    std::vector<std::vector<int>> g(N);\n    int E = 0;\n    for (int i = 0; i < N - 8; i++) {\n        for (int j = 0; j < 8; j++) {\n            if (i & (1 << j)) {\n                g[j].push_back(i + 8);\n                E++;\n            }\n        }\n    }\n    std::cout << E << std::endl;\n    for (int i = 0; i < std::min(N, 8); i++) {\n        for (const int to : g[i]) {\n            std::cout << i + 1 << \" \" << to + 1 << std::endl;\n        }\n    }\n    for (int k = 0; k < K; k++) {\n        auto ask = [](const int p) {\n            std::cout << p << std::endl;\n            std::string ans;\n            std::cin >> ans;\n            return ans;\n        };\n        std::vector<bool> n(8, false);\n        bool ok = false;\n        for (int i = 0; i < 8; i++) {\n            const auto ans = ask(i + 1);\n            if (ans == \"Yes\") {\n                ok = true;\n                break;\n            }\n            if (ans == \"Near\") { n[i] = true; }\n        }\n        if (not ok) {\n            int pos = 0;\n            for (int i = 0, d = 1; i < 8; i++, d *= 2) { pos += d * n[i]; }\n            const auto ans = ask(pos + 9);\n            assert(ans == \"Yes\");\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = 1'000'000'007;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nvector<int> powerArray(int p, int n) {\n\tvector<int> power(n + 1); power[0] = 1;\n\tfor (int i = 0; i < n; i++)\n\t\tpower[i + 1] = power[i] * p;\n\treturn power;\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint N, K; cin >> N >> K;\n\n\tvector<int> pow2 = powerArray(2, 10);\n\tvector<int> sum = pow2;\n\n\trep(i, 1, 9)sum[i + 1] += sum[i];\n\n\n\tint k = 1;\n\n\tvector<int> a, b;\n\n\tfor (int i = 1; i <= N; i++) {\n\t\trep(j, 0, 10) {\n\t\t\tif (i & (1 << j)) {\n\t\t\t\tif (pow2[j] == i)continue;\n\t\t\t\ta.emplace_back(i);\n\t\t\t\tb.emplace_back(pow2[j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << a.size() << endl;\n\trep(i, 0, a.size()) {\n\t\tcout << a[i] << \" \" << b[i] << endl;\n\t}\n\n\trep(_, 0, K) {\n\t\tint out = 1;\n\t\tint k = 1;\n\n\t\tbool yes = false;\n\t\tint ans = 0;\n\t\trep(j, 0, 10) {\n\t\t\tif ((1 << j) > N)continue;\n\t\t\tcout << (1 << j) <<endl;\n\t\t\tstring s; cin >> s;\n\t\t\tif (s == \"Yes\") {\n\t\t\t\tyes = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (s == \"Near\") {\n\t\t\t\tans |= (1 << j);\n\t\t\t}\n\t\t}\n\t\tif (yes)continue;\n\n\t\tcout << ans << endl;\n\t\tstring s; cin >> s;\n\t\t\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include <map>\n#include <fstream>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <assert.h>\n#include <complex>\nusing namespace std;\n#define eps 0.000001\n#define LONG_INF 10000000000000\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007\n#define MOD 998244353\n#define seg_size 65536*4\n#define REP(i,n) for(long long i = 0;i < n;++i)\nint graphs[300][300] = {};\nint main() {\n\tiostream::sync_with_stdio(false);\n\tint n, k;\n\tcin >> n >> k;\n\tvector<pair<int, int>> edges;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tint q = i/2;\n\t\tgraphs[i][i] = 1;\n\t\twhile (q != 0) {\n\t\t\tgraphs[i][q] = 1;\n\t\t\tgraphs[q][i] = 1;\n\t\t\tedges.push_back(make_pair(i, q));\n\t\t\tq /= 2;\n\t\t}\n\t}\n\tcout << edges.size() << endl;\n\tREP(i, edges.size()) {\n\t\tcout << edges[i].first << \" \" << edges[i].second << endl;\n\t}\n\tREP(cnter, k) {\n\t\tint game_grid[600] = {};\n\t\tfor (int q = 1; q <= n; ++q) {\n\t\t\tgame_grid[q] = 1;\n\t\t}\n\t\tfor (int i = 0; i <= 10; ++i) {\n\t\t\tint decided_itr = 0;\n\t\t\tint maximum_determination = -1;\n\t\t\tfor (int q = 1; q <= n; ++q) {\n\t\t\t\tif (game_grid[q] == 0) continue;\n\t\t\t\tint cnta = 0;\n\t\t\t\tint cntb = 0;\n\t\t\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\t\t\tif (graphs[q][j] == 1) {\n\t\t\t\t\t\tcnta += game_grid[j];\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tcntb += game_grid[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (min(cnta,cntb) > maximum_determination) {\n\t\t\t\t\tmaximum_determination = min(cnta,cntb);\n\t\t\t\t\tdecided_itr = q;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << decided_itr << endl;\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tif (s == \"Yes\") break;\n\t\t\tif (s == \"Near\") {\n\t\t\t\tfor (int q = 1; q <= n; ++q) {\n\t\t\t\t\tif (graphs[decided_itr][q] == 0) {\n\t\t\t\t\t\tgame_grid[q] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgame_grid[decided_itr] = 0;\n\t\t\t}\n\t\t\tif (s == \"No\") {\n\t\t\t\tfor (int q = 1; q <= n; ++q) {\n\t\t\t\t\tif (graphs[decided_itr][q] == 1) game_grid[q] = 0;\n\t\t\t\t}\n\t\t\t\tgame_grid[decided_itr] = 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\ntypedef long double ld;\nconst int INF=1e9,MOD=1e9+7;\nconst ll LINF=1e18;\nusing namespace std;\n#define int long long\n\nint pw(int n,int k){\n  int res=1;\n  while(k--)res*=n;\n  return res;\n}\n\nsigned main(){\n  int N,K;cin>>N>>K;\n  typedef pair<int,int> P;\n  std::vector<P> ans;\n  for(int i=1;i<=N;i++)for(int j=0;pw(2,j)<i;j++)if(i&pw(2,j))ans.push_back(P(i,pw(2,j)));\n  cout<<ans.size()<<endl;\n  for(P p:ans)cout<<p.first<<\" \"<<p.second<<endl;\n  for(int i=0;i<K;i++){\n    int rr=0;\n    for(int j=0;j<9;j++){\n      if(pw(2,j)>N)break;\n      cout<<pw(2,j)<<endl;\n      string s;cin>>s;\n      if(s==\"Yes\"){rr=-1;break;}\n      if(s==\"Near\")rr+=pw(2,j);\n    }\n    if(rr==-1)continue;\n    cout<<rr<<endl;string t;cin>>t;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\nvector<P> es;\n\nvoid build(int l, int r){\n    if(r-l <= 1) return;\n    int mid = (l+r+1)/2;\n    for(int i=l+1;i<mid;i++){\n        es.push_back({l+1,i+1});\n    }\n    build(l+1, mid);\n    build(mid, r);\n}\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n    build(0, n);\n    cout << es.size() << endl;\n    for(int i=0;i<int(es.size());i++){\n        cout << es[i].first << \" \" << es[i].second << endl;\n    }\n    for(int i=0;i<k;i++){\n        int l = 0, r = n;\n        string res;\n        while(1){\n            cout << l+1 << endl;\n            cin >> res;\n            if(res == \"Yes\"){\n                break;\n            }\n            else if(res == \"Near\"){\n                r = (l+r+1)/2;\n                l++;\n            }\n            else{\n                l = (l+r+1)/2;\n            }\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<stdint.h>\n#include<inttypes.h>\n\ntypedef int32_t i32;\n\n#define ALLOC(size,type) ((type*)calloc((size),sizeof(type)))\n\ni32 query (i32 v) {\n  printf (\"%\" PRIi32 \"\\n\", v);\n  fflush (stdout);\n  char s[5];\n  scanf (\"%s\", s);\n  if (s[0] == 'Y') return 2;\n  return s[1] == 'e' ? 1 : 0;\n}\n\nvoid run (void) {\n  i32 n, k;\n  scanf (\"%\" SCNi32 \"%\" SCNi32, &n, &k);\n  i32 *a = ALLOC (n * n, i32);\n  i32 *b = ALLOC (n * n, i32);\n  i32 len = 0;\n  for (i32 i = 1; i <= n; i *= 2) {\n    for (i32 j = i + 1; j <= n; ++j) {\n      if ((j & i) == i) {\n        a[len] = i;\n        b[len] = j;\n        len++;\n      }\n    }\n  }\n  printf (\"%\" PRIi32 \"\\n\", len);\n  for (i32 i = 0; i < len; ++i) {\n    printf (\"%\" PRIi32 \" %\" PRIi32 \"\\n\", a[i], b[i]);\n  }\n  fflush (stdout);\n  while (k--) {\n    i32 ans = 0;\n    for (i32 i = 1; i <= n; i *= 2) {\n      i32 res = query (i);\n      if (res == 2) {\n        break;\n      }\n      if (res == 1) {\n        ans |= i;\n      }\n    }\n    if (ans > 0) {\n      query (ans);\n    }\n  }\n}\n\nint main (void) {\n  run();\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2940 Numbers game\n// 2018.3.13 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#if 1\n#define gc() getchar_unlocked()\n#define pc(c) putchar_unlocked(c)\n#else\n#define gc() getchar()\n#define pc(c) putchar(c)\n#endif\nint in()\n{\n\tint n = 0, c = gc();\n\tdo n = 10 * n + (c & 0xf), c = gc(); while (c >= '0');\n\treturn n;\n}\n\nvoid ins(char *s)\n{\n\tdo *s = gc();\n\twhile (*s++ > ' ');\n\t*(s - 1) = 0;\n}\n\nvoid out(int n)\n{\n\tint i;\n\tchar ob[20];\n\n\tif (!n) pc('0');\n\telse {\n\t\ti = 0; while (n) ob[i++] = n % 10 + '0', n /= 10;\n\t\twhile (i--) pc(ob[i]);\n\t}\n}\n\nint N;\nint a[20000][2], M;\n\nvoid bsch()\n{\n\tint m, l = 0, r = N;\n\tchar s[10];\n\n\twhile (l < r) {\n\t\tm = (l + r) >> 1;\n\t\tout(m + 1), pc('\\n'), fflush(stdout);\n\t\tins(s);\n\t\tif (s[0] == 'Y') return;   // Yes\n\t\tif (s[1] == 'e') r = m;    // Near\n\t\telse l = m + 1;\n\t}\n}\n\nvoid mkgraph(int l, int r)\n{\n\tint i, m;\n\n\tif (l >= r) return;\n\tm = (l + r) >> 1;\n\tfor (i = l; i < m; i++) {\n\t\ta[M][0] = m + 1;\n\t\ta[M++][1] = i + 1;\n\t}\n\tmkgraph(l, m), mkgraph(m + 1, r);\n}\n\nint main()\n{\n\tint i, K;\n\n\tN = in(), K = in();\n\tmkgraph(0, N);\n\tout(M), pc('\\n');\n\tfor (i = 0; i < M; i++) {\n\t\tout(a[i][0]), pc(' ');\n\t\tout(a[i][1]), pc('\\n');\n\t}\n\tfflush(stdout);\n\n\twhile (K--) bsch();\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint cnt;\nint a[90010],b[90010];\nvoid f(int v,int x){\n\tif(x<=1)return;\n\tx--;\n\tint near=(x+1)/2;\n\tint no=x/2;\n\tfor(int i=1;i<=near;i++){\n\t\ta[cnt]=v;\n\t\tb[cnt]=v+i;\n\t\tcnt++;\n\t}\n\tf(v+1,near);\n\tf(v+1+near,no);\n}\nint ask(int x){\n\tprintf(\"%d\\n\",x);\n\tfflush(0);\n\tchar s[10];\n\tscanf(\"%s\",s);\n\tif(s[0]=='Y')return 0;\n\tif(s[1]=='e')return 1;\n\treturn 2;\n}\nint main(){\n\tint n,k;\n\tscanf(\"%d%d\",&n,&k);\n\tf(1,n);\n\tprintf(\"%d\\n\",cnt);\n\tfor(int i=0;i<cnt;i++)printf(\"%d %d\\n\",a[i],b[i]);\n\tfflush(0);\n\twhile(k--){\n\t\tint v=1,cnt=n;\n\t\tint ret=1;\n\t\twhile(ret){\n\t\t\tret=ask(v);\n\t\t\tif(ret==1){\n\t\t\t\tv=v+1;\n\t\t\t\tcnt=cnt/2;\n\t\t\t}else if(ret==2){\n\t\t\t\tv=v+1+cnt/2;\n\t\t\t\tcnt-=cnt/2+1;\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing static System.Math;\nusing MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions;\nusing MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute;\n\nclass P\n{\n    static void Main()\n    {\n        var nk = Console.ReadLine().Split().Select(int.Parse).ToList();\n        int n = nk[0];\n        int k = nk[1];\n\n        if (n <= 8) Console.WriteLine(0);\n        else\n        {\n            List<Tuple<int, int>> edge = new List<Tuple<int, int>>();\n            for (int i = 9; i <= n; i++)\n            {\n                for (int j = 0; j < 8; j++)\n                {\n                    if (((i >> j) & 1) == 1) edge.Add(new Tuple<int, int>(j + 1, i));\n                }\n            }\n            Console.WriteLine(edge.Count);\n            Console.WriteLine(string.Join(\"\\n\", edge.Select(x => $\"{x.Item1} {x.Item2}\")));\n        }\n\n        for (int i = 0; i < k; i++)\n        {\n            int res = 0;\n            string judge;\n            for (int j = 0; j < 8; j++)\n            {\n                Console.WriteLine(j + 1);\n                judge = Console.ReadLine();\n                if (judge == \"Yes\") goto end;\n                if (judge == \"Near\") res |= (1 << j);\n            }\n            Console.WriteLine(res);\n            judge = Console.ReadLine();\n            if (judge == \"Yes\") goto end;\n            throw new Exception();\n            end:;\n        }\n    }\n}\n"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop, core.stdc.string;\n\nint XXX;\n\nvoid main() {\n    auto s = readln.split.map!(to!int);\n    auto N = s[0];\n    auto K = s[1];\n\n    immutable int X = 9;\n    auto G = new int[][](N+1);\n\n    foreach (x; 0..X) {\n        if ((1 << x) > N) break;\n        foreach (i; 1..N+1) {\n            if ((i & (1 << x)) && i != (1 << x)) {\n                G[1<<x] ~= i;\n            }\n        }\n    }\n\n    int sm = 0;\n    foreach (i; 1..N+1) {\n        G[i] = G[i].sort().uniq.array;\n        sm += G[i].length.to!int;\n    }\n\n    sm.writeln;\n    foreach (i; 0..N) {\n        foreach (j; G[i]) {\n            writeln(i, \" \", j);\n        }\n    }\n    stdout.flush;\n\n\n    int ask(int n) {\n        debug {\n            if (n == XXX) {\n                writeln(n, \" \", \"OK\");\n                return 2;\n            } else if (G[n].canFind(XXX) || G[XXX].canFind(n)) {\n                return 1;\n            } else {\n                return 0;\n            }\n        }\n\n        writeln(n);\n        stdout.flush;\n\n\n        auto s = readln.chomp;\n        if (s == \"Yes\") {\n            return 2;\n        } else if (s == \"Near\") {\n            return 1;\n        } else {\n            return 0;\n        }\n    }\n\n\n\n    while (K--) {\n        debug {\n            XXX = readln.chomp.to!int;\n        }\n        int ans = 0;\n        bool ok = false;\n        foreach (x; 0..X) {\n            int res = (1<<x) <= N ? ask(1<<x) : 0;\n            if (res == 2) {\n                ok = true;\n                break;\n            } else if (res == 1) {\n                ans |= (1 << x);\n            }\n        }\n        if (!ok) {\n            ask(ans);\n        }\n    }\n}\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n\nfrom collections import deque\nimport itertools as it\nimport sys\nimport math\n\nsys.setrecursionlimit(1000000)\n\nINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\nN, K = map(int, raw_input().split())\n\nif N <= 10:\n    print 0\n    sys.stdout.flush()\n    for _ in range(K):\n        for j in range(1, N + 1):\n            print j\n            sys.stdout.flush()\n            if raw_input() == \"Yes\":\n                break\n    exit()\n\nE = []\nfor i in range(8):\n    E += [(1, i + 2)]\n\nfor v in range(10, N + 1):\n    num = v - 10\n    for i in range(8):\n        if num & (1 << i):\n            E += [(v, i + 2)]\n\nprint len(E)\nfor u, v in E:\n    print u, v\n\nfor _ in range(K):\n    print 1\n    sys.stdout.flush()\n    S = raw_input()\n    if S == \"Yes\":\n        continue\n    if S == \"Near\":\n        for i in range(2, 10):\n            print i\n            sys.stdout.flush()\n            if raw_input() == \"Yes\":\n                break\n        continue\n    ans = 10\n    for i in range(2, 10):\n        print i\n        sys.stdout.flush()\n        if raw_input() == \"Near\":\n            ans += (1 << (i - 2))\n    print ans\n    sys.stdout.flush()\n    S = raw_input()\n"
  }
]