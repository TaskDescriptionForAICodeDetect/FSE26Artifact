[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 200\n#define MAX_GAMES 200\n#define MAX_QUESTIONS 10\n\nint N, K;\nint graph[MAX_N + 1][MAX_N + 1];\nint degree[MAX_N + 1];\n\nvoid read_graph() {\n    int M, a, b;\n    scanf(\"%d\", &M);\n    memset(graph, 0, sizeof(graph));\n    memset(degree, 0, sizeof(degree));\n\n    for (int i = 0; i < M; i++) {\n        scanf(\"%d %d\", &a, &b);\n        graph[a][++degree[a]] = b;\n        graph[b][++degree[b]] = a;\n    }\n    fflush(stdout);\n}\n\nint ask_question(int vertex) {\n    printf(\"%d\\n\", vertex);\n    fflush(stdout);\n\n    char response[10];\n    scanf(\"%s\", response);\n\n    if (strcmp(response, \"Yes\") == 0) return 1;\n    if (strcmp(response, \"Near\") == 0) return 2;\n    return 0;\n}\n\nint solve_game() {\n    int questions = 0;\n    int possible_vertices[MAX_N + 1] = {0};\n    for (int i = 1; i <= N; i++) possible_vertices[i] = 1;\n\n    while (questions < MAX_QUESTIONS) {\n        int guess = 0;\n        for (int i = 1; i <= N; i++) {\n            if (possible_vertices[i]) {\n                guess = i;\n                break;\n            }\n        }\n\n        int result = ask_question(guess);\n        questions++;\n\n        if (result == 1) return 1;\n        if (result == 0) {\n            possible_vertices[guess] = 0;\n            for (int j = 1; j <= degree[guess]; j++) {\n                possible_vertices[graph[guess][j]] = 0;\n            }\n        }\n        if (result == 2) {\n            possible_vertices[guess] = 0;\n            int found = 0;\n            for (int j = 1; j <= degree[guess]; j++) {\n                if (possible_vertices[graph[guess][j]]) {\n                    guess = graph[guess][j];\n                    found = 1;\n                    break;\n                }\n            }\n            if (!found) {\n                for (int i = 1; i <= N; i++) {\n                    if (possible_vertices[i]) {\n                        guess = i;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    return 0;\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &K);\n    read_graph();\n\n    for (int game = 0; game < K; game++) {\n        if (!solve_game()) {\n            printf(\"Unable to solve game %d\\n\", game + 1);\n            return 1;\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:04:25"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint adj[201][201];\nint N, K;\n\nvoid initialize_graph() {\n    int M;\n    scanf(\"%d\", &M);\n    for (int i = 0; i < M; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        adj[a][b] = 1;\n        adj[b][a] = 1;\n    }\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &K);\n    \n    // Output the graph (empty graph)\n    printf(\"0\\n\");\n    fflush(stdout);\n    \n    for (int game = 0; game < K; game++) {\n        int possible[N + 1];\n        for (int i = 1; i <= N; i++) possible[i] = 1;\n        int remaining = N;\n        \n        while (1) {\n            int guess = -1;\n            // Find the first possible candidate\n            for (int i = 1; i <= N; i++) {\n                if (possible[i]) {\n                    guess = i;\n                    break;\n                }\n            }\n            if (guess == -1) break;\n            \n            printf(\"%d\\n\", guess);\n            fflush(stdout);\n            \n            char response[10];\n            scanf(\"%s\", response);\n            \n            if (strcmp(response, \"Yes\") == 0) {\n                break;\n            } else if (strcmp(response, \"Near\") == 0) {\n                // Mark all except guess and its adjacent as impossible\n                for (int i = 1; i <= N; i++) {\n                    if (possible[i] && i != guess && !adj[guess][i]) {\n                        possible[i] = 0;\n                        remaining--;\n                    }\n                }\n            } else if (strcmp(response, \"No\") == 0) {\n                // Mark guess and its adjacent as impossible\n                possible[guess] = 0;\n                remaining--;\n                for (int i = 1; i <= N; i++) {\n                    if (adj[guess][i] && possible[i]) {\n                        possible[i] = 0;\n                        remaining--;\n                    }\n                }\n            }\n        }\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:04:45"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <queue>\n\nusing namespace std;\n\nint main() {\n    int N, K;\n    cin >> N >> K;\n\n    // Output the graph (empty graph to minimize adjacency info)\n    cout << \"0\" << endl;\n    cout.flush();\n\n    for (int game = 0; game < K; ++game) {\n        set<int> candidates;\n        for (int i = 1; i <= N; ++i) {\n            candidates.insert(i);\n        }\n\n        bool found = false;\n        for (int q = 0; q < 10; ++q) {\n            if (candidates.size() == 1) {\n                int guess = *candidates.begin();\n                cout << guess << endl;\n                cout.flush();\n                string response;\n                cin >> response;\n                if (response == \"Yes\") {\n                    found = true;\n                    break;\n                }\n            } else {\n                // Find the vertex that splits the candidates best\n                int best_guess = -1;\n                int min_max = N + 1;\n                for (int guess : candidates) {\n                    // Simulate the three possible responses\n                    int max_part = 0;\n                    // 'Yes' case: only 1 candidate left\n                    // 'Near' case: adjacent vertices (but since graph is empty, no adjacency)\n                    // 'No' case: all except guess\n                    int near_count = 0; // In empty graph, 'Near' is impossible\n                    int no_count = candidates.size() - 1;\n                    max_part = no_count;\n                    if (max_part < min_max) {\n                        min_max = max_part;\n                        best_guess = guess;\n                    }\n                }\n                if (best_guess == -1) {\n                    best_guess = *candidates.begin();\n                }\n                cout << best_guess << endl;\n                cout.flush();\n                string response;\n                cin >> response;\n                if (response == \"Yes\") {\n                    found = true;\n                    break;\n                } else if (response == \"Near\") {\n                    // Since graph is empty, this should not happen\n                    candidates.erase(best_guess);\n                } else { // \"No\"\n                    candidates.erase(best_guess);\n                }\n            }\n        }\n        if (!found) {\n            // Must guess the last candidate (though should not reach here)\n            cout << *candidates.begin() << endl;\n            cout.flush();\n            string response;\n            cin >> response;\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:05:07"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int K = sc.nextInt();\n\n        // Output the graph (empty graph)\n        System.out.println(0);\n        System.out.flush();\n\n        for (int game = 0; game < K; game++) {\n            Set<Integer> candidates = new HashSet<>();\n            for (int i = 1; i <= N; i++) {\n                candidates.add(i);\n            }\n\n            while (true) {\n                int guess = candidates.iterator().next();\n                System.out.println(guess);\n                System.out.flush();\n\n                String response = sc.next();\n                if (response.equals(\"Yes\")) {\n                    break;\n                } else if (response.equals(\"No\")) {\n                    candidates.remove(guess);\n                } else if (response.equals(\"Near\")) {\n                    // In the empty graph, 'Near' is impossible since there are no edges\n                    // So this case should not occur\n                    candidates.remove(guess);\n                }\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-05 22:05:19"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class LocationGuessingGame {\n    private static final int MAX_QUESTIONS = 10;\n    private static int N, K;\n    private static List<List<Integer>> graph;\n    private static boolean[] visited;\n    private static Scanner scanner;\n    private static PrintWriter out;\n\n    public static void main(String[] args) {\n        scanner = new Scanner(System.in);\n        out = new PrintWriter(System.out, true);\n\n        N = scanner.nextInt();\n        K = scanner.nextInt();\n\n        graph = new ArrayList<>(N + 1);\n        for (int i = 0; i <= N; i++) {\n            graph.add(new ArrayList<>());\n        }\n\n        int M = scanner.nextInt();\n        for (int i = 0; i < M; i++) {\n            int a = scanner.nextInt();\n            int b = scanner.nextInt();\n            graph.get(a).add(b);\n            graph.get(b).add(a);\n        }\n\n        for (int game = 0; game < K; game++) {\n            playGame();\n        }\n    }\n\n    private static void playGame() {\n        visited = new boolean[N + 1];\n        int startVertex = findStartVertex();\n        guessVertex(startVertex);\n    }\n\n    private static int findStartVertex() {\n        for (int v = 1; v <= N; v++) {\n            if (!graph.get(v).isEmpty()) {\n                return v;\n            }\n        }\n        return 1;\n    }\n\n    private static void guessVertex(int startVertex) {\n        List<Integer> possibleVertices = new ArrayList<>();\n        for (int v = 1; v <= N; v++) {\n            if (!visited[v]) {\n                possibleVertices.add(v);\n            }\n        }\n\n        int questionsAsked = 0;\n        while (questionsAsked < MAX_QUESTIONS) {\n            if (possibleVertices.size() == 1) {\n                int vertex = possibleVertices.get(0);\n                out.println(vertex);\n                out.flush();\n                String response = scanner.next();\n                if (response.equals(\"Yes\")) {\n                    visited[vertex] = true;\n                    return;\n                }\n            }\n\n            int guessVertex = possibleVertices.get(0);\n            out.println(guessVertex);\n            out.flush();\n            String response = scanner.next();\n\n            questionsAsked++;\n\n            if (response.equals(\"Yes\")) {\n                visited[guessVertex] = true;\n                return;\n            } else if (response.equals(\"Near\")) {\n                List<Integer> nearVertices = new ArrayList<>();\n                nearVertices.add(guessVertex);\n                for (int neighbor : graph.get(guessVertex)) {\n                    nearVertices.add(neighbor);\n                }\n                possibleVertices.retainAll(nearVertices);\n            } else {\n                possibleVertices.remove(Integer.valueOf(guessVertex));\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-05 22:05:31"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <queue>\n#include <cstring>\n\nusing namespace std;\n\nconst int MAXN = 205;\n\nvector<int> graph[MAXN];\nbool visited[MAXN];\n\nvoid solve() {\n    int N, K;\n    cin >> N >> K;\n\n    int M;\n    cin >> M;\n\n    for (int i = 0; i < M; i++) {\n        int a, b;\n        cin >> a >> b;\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n    }\n\n    for (int game = 0; game < K; game++) {\n        memset(visited, 0, sizeof(visited));\n        vector<int> candidates;\n        for (int i = 1; i <= N; i++) {\n            candidates.push_back(i);\n        }\n\n        for (int query = 0; query < 10; query++) {\n            if (candidates.size() == 1) {\n                cout << candidates[0] << endl;\n                fflush(stdout);\n                string response;\n                cin >> response;\n                if (response == \"Yes\") break;\n            }\n\n            int guess = candidates[0];\n            cout << guess << endl;\n            fflush(stdout);\n\n            string response;\n            cin >> response;\n\n            if (response == \"Yes\") break;\n\n            vector<int> newCandidates;\n            if (response == \"Near\") {\n                for (int adj : graph[guess]) {\n                    newCandidates.push_back(adj);\n                }\n            } else {\n                for (int candidate : candidates) {\n                    if (candidate == guess) continue;\n                    bool isNear = false;\n                    for (int adj : graph[guess]) {\n                        if (adj == candidate) {\n                            isNear = true;\n                            break;\n                        }\n                    }\n                    if (!isNear) newCandidates.push_back(candidate);\n                }\n            }\n\n            candidates = newCandidates;\n        }\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    solve();\n    return 0;\n}",
    "timestamp": "2025-08-05 22:05:40"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nimport random\nfrom collections import defaultdict\n\ndef read_ints():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef main():\n    # Read number of vertices and games\n    N, K = read_ints()\n\n    # Read the graph\n    M = int(sys.stdin.readline().strip())\n    adjacency_list = defaultdict(set)\n\n    for _ in range(M):\n        u, v = read_ints()\n        adjacency_list[u].add(v)\n        adjacency_list[v].add(u)\n\n    # Play K games\n    for _ in range(K):\n        unvisited = set(range(1, N + 1))\n\n        while True:\n            v = random.choice(list(unvisited))\n            print(v)\n            sys.stdout.flush()\n\n            response = sys.stdin.readline().strip()\n\n            if response == \"Yes\":\n                break\n            elif response == \"Near\":\n                unvisited.intersection_update(adjacency_list[v])\n            elif response == \"No\":\n                unvisited.remove(v)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 08:52:39"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class LocationGuessingGame {\n    private static List<List<Integer>> graph;\n    private static final int MAX_QUESTIONS = 10;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        // Read number of vertices and number of games\n        int N = scanner.nextInt();\n        int K = scanner.nextInt();\n\n        // Initialize graph adjacency list\n        graph = new ArrayList<>(N + 1);\n        for (int i = 0; i <= N; i++) {\n            graph.add(new ArrayList<>());\n        }\n\n        // Read number of edges\n        int M = scanner.nextInt();\n\n        // Read each edge and populate the graph\n        for (int i = 0; i < M; i++) {\n            int Ai = scanner.nextInt();\n            int Bi = scanner.nextInt();\n            graph.get(Ai).add(Bi);\n            graph.get(Bi).add(Ai);\n        }\n\n        // Play K games\n        for (int game = 0; game < K; game++) {\n            playGame(scanner, N);\n        }\n\n        scanner.close();\n    }\n\n    private static void playGame(Scanner scanner, int N) {\n        Set<Integer> guessed = new HashSet<>();\n\n        for (int q = 0; q < MAX_QUESTIONS; q++) {\n            int guess = findBestGuess(N, guessed);\n            guessed.add(guess);\n            System.out.println(guess);\n            System.out.flush();\n\n            String response = scanner.next();\n            if (response.equals(\"Yes\")) {\n                return;\n            } else if (response.equals(\"Near\")) {\n                Set<Integer> neighbors = new HashSet<>(graph.get(guess));\n                neighbors.removeAll(guessed);\n                for (int neighbor : neighbors) {\n                    System.out.println(neighbor);\n                    System.out.flush();\n                    response = scanner.next();\n                    if (response.equals(\"Yes\")) {\n                        return;\n                    }\n                    guessed.add(neighbor);\n                }\n            }\n        }\n    }\n\n    private static int findBestGuess(int N, Set<Integer> guessed) {\n        for (int i = 1; i <= N; i++) {\n            if (!guessed.contains(i)) {\n                return i;\n            }\n        }\n        // Fallback, should not occur\n        return 1;\n    }\n}",
    "timestamp": "2025-08-13 08:52:43"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 200\n\ntypedef struct {\n    int adj[MAX_N][MAX_N];\n    int visited[MAX_N];\n    int n;\n} Graph;\n\nGraph graph;\n\nvoid init_graph(int n) {\n    graph.n = n;\n    memset(graph.adj, 0, sizeof(graph.adj));\n}\n\nvoid add_edge(int a, int b) {\n    graph.adj[a][b] = 1;\n    graph.adj[b][a] = 1;\n}\n\nint guess_vertex(int target) {\n    for (int i = 1; i <= graph.n; i++) {\n        printf(\"%d\\n\", i);\n        fflush(stdout);\n\n        char response[10];\n        scanf(\"%s\", response);\n\n        if (strcmp(response, \"Yes\") == 0) {\n            return 1;\n        } else if (strcmp(response, \"Near\") == 0) {\n            for (int j = 1; j <= graph.n; j++) {\n                if (graph.adj[i][j] && !graph.visited[j]) {\n                    printf(\"%d\\n\", j);\n                    fflush(stdout);\n                    scanf(\"%s\", response);\n                    if (strcmp(response, \"Yes\") == 0) {\n                        return 1;\n                    }\n                    // Mark visited to prevent re-guessing\n                    graph.visited[j] = 1;\n                }\n            }\n        }\n    }\n    return 0; // Should not reach here as per problem\n}\n\nint main() {\n    int N, K, M, a, b;\n    scanf(\"%d %d\", &N, &K);\n    scanf(\"%d\", &M);\n\n    init_graph(N);\n\n    for (int i = 0; i < M; ++i) {\n        scanf(\"%d %d\", &a, &b);\n        add_edge(a, b);\n    }\n\n    for (int game = 0; game < K; ++game) {\n        memset(graph.visited, 0, sizeof(graph.visited));\n        guess_vertex(1); // Sosuusa's guess loop\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 08:52:48"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\n\ndef build_graph(N, edges):\n    graph = [[] for _ in range(N+1)]\n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    return graph\n\ndef solve_game(graph, N):\n    visited = [False] * (N+1)\n    \n    def find_vertex():\n        for v in range(1, N+1):\n            if not visited[v]:\n                return v\n        return -1\n    \n    def ask_vertex(v):\n        print(v)\n        sys.stdout.flush()\n        response = input().strip()\n        return response\n    \n    while True:\n        target = find_vertex()\n        if target == -1:\n            break\n        \n        questions = 0\n        while questions < 10:\n            response = ask_vertex(target)\n            \n            if response == 'Yes':\n                visited[target] = True\n                break\n            \n            if response == 'Near':\n                for neighbor in graph[target]:\n                    if not visited[neighbor]:\n                        target = neighbor\n                        break\n            \n            if response == 'No':\n                target = find_vertex()\n                if target == -1:\n                    break\n            \n            questions += 1\n        \n        if questions >= 10:\n            sys.exit(1)\n\ndef main():\n    N, K = map(int, input().split())\n    M = int(input())\n    \n    edges = []\n    for _ in range(M):\n        a, b = map(int, input().split())\n        edges.append((a, b))\n    \n    graph = build_graph(N, edges)\n    \n    for _ in range(K):\n        solve_game(graph, N)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 08:53:00"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    N, K = map(int, input[ptr:ptr+2])\n    ptr += 2\n    \n    # Output the graph (empty graph)\n    print(0)\n    sys.stdout.flush()\n    \n    for _ in range(K):\n        remaining = set(range(1, N+1))\n        for _ in range(10):\n            guess = remaining.pop()\n            print(guess)\n            sys.stdout.flush()\n            response = input[ptr].strip()\n            ptr += 1\n            if response == 'Yes':\n                break\n            elif response == 'Near':\n                # Need to find adjacent nodes, but since graph is empty, this shouldn't happen\n                pass\n            # 'No' just continues\n\nif __name__ == '__main__':\n    main()",
    "timestamp": "2025-08-13 08:53:17"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <unordered_set>\n\nusing namespace std;\n\nint main() {\n    int N, K;\n    cin >> N >> K;\n\n    int M;\n    cin >> M;\n\n    vector<vector<int>> adj(N + 1);\n    for (int i = 0; i < M; ++i) {\n        int A, B;\n        cin >> A >> B;\n        adj[A].push_back(B);\n        adj[B].push_back(A);\n    }\n\n    for (int game = 0; game < K; ++game) {\n        vector<int> guessed(N + 1, false);\n        queue<int> q;\n\n        // Try guessing each vertex until we succeed within 10 guesses\n        for (int i = 1; i <= N; ++i) {\n            q.push(i);\n            unordered_set<int> visited;\n            visited.insert(i);\n            int guess_count = 0;\n\n            while (!q.empty() && guess_count < 10) {\n                int current_vertex = q.front();\n                q.pop();\n\n                cout << current_vertex << endl;\n                cout.flush();\n                string response;\n                cin >> response;\n\n                if (response == \"Yes\") {\n                    break;\n                } else if (response == \"Near\") {\n                    for (int neighbor : adj[current_vertex]) {\n                        if (!visited.count(neighbor)) {\n                            visited.insert(neighbor);\n                            q.push(neighbor);\n                        }\n                    }\n                }\n                ++guess_count;\n            }\n        }\n        \n        // Reset data structures if desired (not necessary for current constraints)\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:48:13"
  }
]